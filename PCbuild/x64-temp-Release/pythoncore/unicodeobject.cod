; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BF@BEBBJAIL@string?5helper?5module?$AA@	; `string'
PUBLIC	??_C@_07PGCBFEPB@_string?$AA@			; `string'
PUBLIC	??_C@_0CG@FCKLAMOB@parse?5the?5argument?5as?5a?5format?5s@ ; `string'
PUBLIC	??_C@_0BB@JJJFGPCM@formatter_parser?$AA@	; `string'
PUBLIC	??_C@_0CD@LNGEKMIN@split?5the?5argument?5as?5a?5field?5na@ ; `string'
PUBLIC	??_C@_0BL@GJEMJGHD@formatter_field_name_split?$AA@ ; `string'
PUBLIC	??_C@_0N@GHJLLMAJ@str_iterator?$AA@		; `string'
PUBLIC	??_C@_0N@MOOGCAMH@__setstate__?$AA@		; `string'
PUBLIC	??_C@_0L@NNMACJIG@__reduce__?$AA@		; `string'
PUBLIC	??_C@_0BA@BJLPBKGK@__length_hint__?$AA@		; `string'
PUBLIC	PyUnicode_RichCompare
PUBLIC	??_C@_03OJMAPEGJ@str?$AA@			; `string'
PUBLIC	??_C@_06IEOJBDIK@object?$AA@			; `string'
PUBLIC	PyUnicode_Contains
PUBLIC	PyUnicode_Concat
PUBLIC	??_C@_0P@BCBHENLA@__getnewargs__?$AA@		; `string'
PUBLIC	??_C@_0L@HOGGIPGN@__sizeof__?$AA@		; `string'
PUBLIC	??_C@_09PBBLPCAA@maketrans?$AA@			; `string'
PUBLIC	??_C@_0L@MEMCGMKL@__format__?$AA@		; `string'
PUBLIC	??_C@_0L@DBBJLEAP@format_map?$AA@		; `string'
PUBLIC	??_C@_06DLEPGFEF@format?$AA@			; `string'
PUBLIC	??_C@_05DMFNFMHA@zfill?$AA@			; `string'
PUBLIC	??_C@_0M@JGKJDKBM@isprintable?$AA@		; `string'
PUBLIC	??_C@_0N@DOKMMCGL@isidentifier?$AA@		; `string'
PUBLIC	??_C@_07EOADCIGC@isalnum?$AA@			; `string'
PUBLIC	??_C@_07EGIOHHOB@isalpha?$AA@			; `string'
PUBLIC	??_C@_09KOMAEOED@isnumeric?$AA@			; `string'
PUBLIC	??_C@_07CFBKIKCH@isdigit?$AA@			; `string'
PUBLIC	??_C@_09CGNFEIIK@isdecimal?$AA@			; `string'
PUBLIC	??_C@_07CNBMLEON@isspace?$AA@			; `string'
PUBLIC	??_C@_07DBHCJBDG@istitle?$AA@			; `string'
PUBLIC	??_C@_07BCOOJPCO@isupper?$AA@			; `string'
PUBLIC	??_C@_07EJFAPEJH@islower?$AA@			; `string'
PUBLIC	??_C@_08MLCMCPNP@endswith?$AA@			; `string'
PUBLIC	??_C@_0L@MPOGHCCL@startswith?$AA@		; `string'
PUBLIC	??_C@_05NECKJAMC@upper?$AA@			; `string'
PUBLIC	??_C@_09ODNGOEIO@translate?$AA@			; `string'
PUBLIC	??_C@_08EDJLBCEI@swapcase?$AA@			; `string'
PUBLIC	??_C@_05GGNGIGHC@strip?$AA@			; `string'
PUBLIC	??_C@_0L@BCMGLLLC@splitlines?$AA@		; `string'
PUBLIC	??_C@_0L@KEEHLNKL@rpartition?$AA@		; `string'
PUBLIC	??_C@_06DBIPDJKN@rstrip?$AA@			; `string'
PUBLIC	??_C@_05JKFAKHCP@rjust?$AA@			; `string'
PUBLIC	??_C@_06NCDOMFM@rindex?$AA@			; `string'
PUBLIC	??_C@_05BLFDIAHL@rfind?$AA@			; `string'
PUBLIC	??_C@_06GGONODO@lstrip?$AA@			; `string'
PUBLIC	??_C@_05IPJEPLHL@lower?$AA@			; `string'
PUBLIC	??_C@_05KDIMMEME@ljust?$AA@			; `string'
PUBLIC	??_C@_05FKHKFDID@index?$AA@			; `string'
PUBLIC	??_C@_09IKAEIPAD@partition?$AA@			; `string'
PUBLIC	??_C@_04CKFJHKAP@find?$AA@			; `string'
PUBLIC	??_C@_0L@DEOCELBD@expandtabs?$AA@		; `string'
PUBLIC	??_C@_05IOMEMJEC@count?$AA@			; `string'
PUBLIC	??_C@_06BBLOAEEI@center?$AA@			; `string'
PUBLIC	??_C@_05PHLGJONK@title?$AA@			; `string'
PUBLIC	??_C@_08NAILFLBF@casefold?$AA@			; `string'
PUBLIC	??_C@_0L@NMODNBEH@capitalize?$AA@		; `string'
PUBLIC	??_C@_04DFGCDGNN@join?$AA@			; `string'
PUBLIC	??_C@_06BAKFHKMF@rsplit?$AA@			; `string'
PUBLIC	??_C@_05EHPMMFBK@split?$AA@			; `string'
PUBLIC	??_C@_07CLEHDIEJ@replace?$AA@			; `string'
PUBLIC	??_C@_06GDGADLDP@encode?$AA@			; `string'
PUBLIC	??_C@_0BC@PNFANA@fieldnameiterator?$AA@		; `string'
PUBLIC	??_C@_0BC@OEBNLFHC@formatteriterator?$AA@	; `string'
PUBLIC	??_C@_08EMIAAFLA@keepends?$AA@			; `string'
PUBLIC	??_C@_08HONNCIIN@maxsplit?$AA@			; `string'
PUBLIC	??_C@_03MGBCFPKM@sep?$AA@			; `string'
PUBLIC	??_C@_08NLCECJOD@?$HMO?3strip?$AA@		; `string'
PUBLIC	??_C@_09LGDKGINA@?$HMO?3rstrip?$AA@		; `string'
PUBLIC	??_C@_09IBNLIPED@?$HMO?3lstrip?$AA@		; `string'
PUBLIC	??_C@_06EOMHCNPI@errors?$AA@			; `string'
PUBLIC	??_C@_08MLPGAEIK@encoding?$AA@			; `string'
PUBLIC	??_C@_0DL@NCJPFEFM@O?$CBn?$DLtranslating?5error?5handler?5mu@ ; `string'
PUBLIC	??_C@_0M@MLHFIPEJ@EncodingMap?$AA@		; `string'
PUBLIC	??_C@_0CK@PIMLJJMB@Return?5the?5size?5?$CIin?5bytes?$CJ?5of?5th@ ; `string'
PUBLIC	??_C@_04IAGNFIBA@size?$AA@			; `string'
PUBLIC	??_C@_0DN@ECBPBGH@On?$DLencoding?5error?5handler?5must?5r@ ; `string'
PUBLIC	??_C@_0DI@COHDJOGC@O?$CBn?$DLdecoding?5error?5handler?5must?5@ ; `string'
PUBLIC	tls_static_strings
PUBLIC	tls_interned
PUBLIC	tls_unicode_latin1
PUBLIC	_Py_ascii_whitespace
PUBLIC	PyUnicode_Type
PUBLIC	PyUnicodeIter_Type
EXTRN	PyObject_Free:PROC
EXTRN	PyBaseObject_Type:BYTE
EXTRN	PyObject_SelfIter:PROC
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	PyType_Type:BYTE
_TLS	SEGMENT
tls_static_strings DQ 01H DUP (?)
tls_interned DQ	01H DUP (?)
tls_unicode_latin1 DQ 0100H DUP (?)
_TLS	ENDS
_BSS	SEGMENT
interned DQ	01H DUP (?)
unicode_empty DQ 01H DUP (?)
static_strings DQ 01H DUP (?)
unicode_latin1 DQ 0100H DUP (?)
?nul@?1??_PyUnicode_HasNULChars@@9@9 DQ 01H DUP (?)	; `_PyUnicode_HasNULChars'::`2'::nul
ucnhash_CAPI DQ	01H DUP (?)
formatteriter_methods DB 020H DUP (?)
fieldnameiter_methods DB 020H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BF@BEBBJAIL@string?5helper?5module?$AA@
CONST	SEGMENT
??_C@_0BF@BEBBJAIL@string?5helper?5module?$AA@ DB 'string helper module', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PGCBFEPB@_string?$AA@
CONST	SEGMENT
??_C@_07PGCBFEPB@_string?$AA@ DB '_string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FCKLAMOB@parse?5the?5argument?5as?5a?5format?5s@
CONST	SEGMENT
??_C@_0CG@FCKLAMOB@parse?5the?5argument?5as?5a?5format?5s@ DB 'parse the '
	DB	'argument as a format string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JJJFGPCM@formatter_parser?$AA@
CONST	SEGMENT
??_C@_0BB@JJJFGPCM@formatter_parser?$AA@ DB 'formatter_parser', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LNGEKMIN@split?5the?5argument?5as?5a?5field?5na@
CONST	SEGMENT
??_C@_0CD@LNGEKMIN@split?5the?5argument?5as?5a?5field?5na@ DB 'split the '
	DB	'argument as a field name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GJEMJGHD@formatter_field_name_split?$AA@
CONST	SEGMENT
??_C@_0BL@GJEMJGHD@formatter_field_name_split?$AA@ DB 'formatter_field_na'
	DB	'me_split', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GHJLLMAJ@str_iterator?$AA@
CONST	SEGMENT
??_C@_0N@GHJLLMAJ@str_iterator?$AA@ DB 'str_iterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOOGCAMH@__setstate__?$AA@
CONST	SEGMENT
??_C@_0N@MOOGCAMH@__setstate__?$AA@ DB '__setstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNMACJIG@__reduce__?$AA@
CONST	SEGMENT
??_C@_0L@NNMACJIG@__reduce__?$AA@ DB '__reduce__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
CONST	SEGMENT
??_C@_0BA@BJLPBKGK@__length_hint__?$AA@ DB '__length_hint__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OJMAPEGJ@str?$AA@
CONST	SEGMENT
??_C@_03OJMAPEGJ@str?$AA@ DB 'str', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IEOJBDIK@object?$AA@
CONST	SEGMENT
??_C@_06IEOJBDIK@object?$AA@ DB 'object', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BCBHENLA@__getnewargs__?$AA@
CONST	SEGMENT
??_C@_0P@BCBHENLA@__getnewargs__?$AA@ DB '__getnewargs__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGGIPGN@__sizeof__?$AA@
CONST	SEGMENT
??_C@_0L@HOGGIPGN@__sizeof__?$AA@ DB '__sizeof__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PBBLPCAA@maketrans?$AA@
CONST	SEGMENT
??_C@_09PBBLPCAA@maketrans?$AA@ DB 'maketrans', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MEMCGMKL@__format__?$AA@
CONST	SEGMENT
??_C@_0L@MEMCGMKL@__format__?$AA@ DB '__format__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DBBJLEAP@format_map?$AA@
CONST	SEGMENT
??_C@_0L@DBBJLEAP@format_map?$AA@ DB 'format_map', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06DLEPGFEF@format?$AA@
CONST	SEGMENT
??_C@_06DLEPGFEF@format?$AA@ DB 'format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DMFNFMHA@zfill?$AA@
CONST	SEGMENT
??_C@_05DMFNFMHA@zfill?$AA@ DB 'zfill', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JGKJDKBM@isprintable?$AA@
CONST	SEGMENT
??_C@_0M@JGKJDKBM@isprintable?$AA@ DB 'isprintable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DOKMMCGL@isidentifier?$AA@
CONST	SEGMENT
??_C@_0N@DOKMMCGL@isidentifier?$AA@ DB 'isidentifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EOADCIGC@isalnum?$AA@
CONST	SEGMENT
??_C@_07EOADCIGC@isalnum?$AA@ DB 'isalnum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EGIOHHOB@isalpha?$AA@
CONST	SEGMENT
??_C@_07EGIOHHOB@isalpha?$AA@ DB 'isalpha', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KOMAEOED@isnumeric?$AA@
CONST	SEGMENT
??_C@_09KOMAEOED@isnumeric?$AA@ DB 'isnumeric', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CFBKIKCH@isdigit?$AA@
CONST	SEGMENT
??_C@_07CFBKIKCH@isdigit?$AA@ DB 'isdigit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09CGNFEIIK@isdecimal?$AA@
CONST	SEGMENT
??_C@_09CGNFEIIK@isdecimal?$AA@ DB 'isdecimal', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNBMLEON@isspace?$AA@
CONST	SEGMENT
??_C@_07CNBMLEON@isspace?$AA@ DB 'isspace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DBHCJBDG@istitle?$AA@
CONST	SEGMENT
??_C@_07DBHCJBDG@istitle?$AA@ DB 'istitle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BCOOJPCO@isupper?$AA@
CONST	SEGMENT
??_C@_07BCOOJPCO@isupper?$AA@ DB 'isupper', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EJFAPEJH@islower?$AA@
CONST	SEGMENT
??_C@_07EJFAPEJH@islower?$AA@ DB 'islower', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLCMCPNP@endswith?$AA@
CONST	SEGMENT
??_C@_08MLCMCPNP@endswith?$AA@ DB 'endswith', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MPOGHCCL@startswith?$AA@
CONST	SEGMENT
??_C@_0L@MPOGHCCL@startswith?$AA@ DB 'startswith', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05NECKJAMC@upper?$AA@
CONST	SEGMENT
??_C@_05NECKJAMC@upper?$AA@ DB 'upper', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09ODNGOEIO@translate?$AA@
CONST	SEGMENT
??_C@_09ODNGOEIO@translate?$AA@ DB 'translate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EDJLBCEI@swapcase?$AA@
CONST	SEGMENT
??_C@_08EDJLBCEI@swapcase?$AA@ DB 'swapcase', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05GGNGIGHC@strip?$AA@
CONST	SEGMENT
??_C@_05GGNGIGHC@strip?$AA@ DB 'strip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BCMGLLLC@splitlines?$AA@
CONST	SEGMENT
??_C@_0L@BCMGLLLC@splitlines?$AA@ DB 'splitlines', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KEEHLNKL@rpartition?$AA@
CONST	SEGMENT
??_C@_0L@KEEHLNKL@rpartition?$AA@ DB 'rpartition', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06DBIPDJKN@rstrip?$AA@
CONST	SEGMENT
??_C@_06DBIPDJKN@rstrip?$AA@ DB 'rstrip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKFAKHCP@rjust?$AA@
CONST	SEGMENT
??_C@_05JKFAKHCP@rjust?$AA@ DB 'rjust', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NCDOMFM@rindex?$AA@
CONST	SEGMENT
??_C@_06NCDOMFM@rindex?$AA@ DB 'rindex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BLFDIAHL@rfind?$AA@
CONST	SEGMENT
??_C@_05BLFDIAHL@rfind?$AA@ DB 'rfind', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GGONODO@lstrip?$AA@
CONST	SEGMENT
??_C@_06GGONODO@lstrip?$AA@ DB 'lstrip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IPJEPLHL@lower?$AA@
CONST	SEGMENT
??_C@_05IPJEPLHL@lower?$AA@ DB 'lower', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KDIMMEME@ljust?$AA@
CONST	SEGMENT
??_C@_05KDIMMEME@ljust?$AA@ DB 'ljust', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKHKFDID@index?$AA@
CONST	SEGMENT
??_C@_05FKHKFDID@index?$AA@ DB 'index', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IKAEIPAD@partition?$AA@
CONST	SEGMENT
??_C@_09IKAEIPAD@partition?$AA@ DB 'partition', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CKFJHKAP@find?$AA@
CONST	SEGMENT
??_C@_04CKFJHKAP@find?$AA@ DB 'find', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DEOCELBD@expandtabs?$AA@
CONST	SEGMENT
??_C@_0L@DEOCELBD@expandtabs?$AA@ DB 'expandtabs', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count?$AA@
CONST	SEGMENT
??_C@_05IOMEMJEC@count?$AA@ DB 'count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BBLOAEEI@center?$AA@
CONST	SEGMENT
??_C@_06BBLOAEEI@center?$AA@ DB 'center', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PHLGJONK@title?$AA@
CONST	SEGMENT
??_C@_05PHLGJONK@title?$AA@ DB 'title', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NAILFLBF@casefold?$AA@
CONST	SEGMENT
??_C@_08NAILFLBF@casefold?$AA@ DB 'casefold', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NMODNBEH@capitalize?$AA@
CONST	SEGMENT
??_C@_0L@NMODNBEH@capitalize?$AA@ DB 'capitalize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DFGCDGNN@join?$AA@
CONST	SEGMENT
??_C@_04DFGCDGNN@join?$AA@ DB 'join', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BAKFHKMF@rsplit?$AA@
CONST	SEGMENT
??_C@_06BAKFHKMF@rsplit?$AA@ DB 'rsplit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EHPMMFBK@split?$AA@
CONST	SEGMENT
??_C@_05EHPMMFBK@split?$AA@ DB 'split', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CLEHDIEJ@replace?$AA@
CONST	SEGMENT
??_C@_07CLEHDIEJ@replace?$AA@ DB 'replace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GDGADLDP@encode?$AA@
CONST	SEGMENT
??_C@_06GDGADLDP@encode?$AA@ DB 'encode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PNFANA@fieldnameiterator?$AA@
CONST	SEGMENT
??_C@_0BC@PNFANA@fieldnameiterator?$AA@ DB 'fieldnameiterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OEBNLFHC@formatteriterator?$AA@
CONST	SEGMENT
??_C@_0BC@OEBNLFHC@formatteriterator?$AA@ DB 'formatteriterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EMIAAFLA@keepends?$AA@
CONST	SEGMENT
??_C@_08EMIAAFLA@keepends?$AA@ DB 'keepends', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HONNCIIN@maxsplit?$AA@
CONST	SEGMENT
??_C@_08HONNCIIN@maxsplit?$AA@ DB 'maxsplit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03MGBCFPKM@sep?$AA@
CONST	SEGMENT
??_C@_03MGBCFPKM@sep?$AA@ DB 'sep', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08NLCECJOD@?$HMO?3strip?$AA@
CONST	SEGMENT
??_C@_08NLCECJOD@?$HMO?3strip?$AA@ DB '|O:strip', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LGDKGINA@?$HMO?3rstrip?$AA@
CONST	SEGMENT
??_C@_09LGDKGINA@?$HMO?3rstrip?$AA@ DB '|O:rstrip', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IBNLIPED@?$HMO?3lstrip?$AA@
CONST	SEGMENT
??_C@_09IBNLIPED@?$HMO?3lstrip?$AA@ DB '|O:lstrip', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EOMHCNPI@errors?$AA@
CONST	SEGMENT
??_C@_06EOMHCNPI@errors?$AA@ DB 'errors', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLPGAEIK@encoding?$AA@
CONST	SEGMENT
??_C@_08MLPGAEIK@encoding?$AA@ DB 'encoding', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@NCJPFEFM@O?$CBn?$DLtranslating?5error?5handler?5mu@
CONST	SEGMENT
??_C@_0DL@NCJPFEFM@O?$CBn?$DLtranslating?5error?5handler?5mu@ DB 'O!n;tra'
	DB	'nslating error handler must return (str, int) tuple', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MLHFIPEJ@EncodingMap?$AA@
CONST	SEGMENT
??_C@_0M@MLHFIPEJ@EncodingMap?$AA@ DB 'EncodingMap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PIMLJJMB@Return?5the?5size?5?$CIin?5bytes?$CJ?5of?5th@
CONST	SEGMENT
??_C@_0CK@PIMLJJMB@Return?5the?5size?5?$CIin?5bytes?$CJ?5of?5th@ DB 'Retu'
	DB	'rn the size (in bytes) of this object', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04IAGNFIBA@size?$AA@
CONST	SEGMENT
??_C@_04IAGNFIBA@size?$AA@ DB 'size', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@ECBPBGH@On?$DLencoding?5error?5handler?5must?5r@
CONST	SEGMENT
??_C@_0DN@ECBPBGH@On?$DLencoding?5error?5handler?5must?5r@ DB 'On;encodin'
	DB	'g error handler must return (str/bytes, int) tuple', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@COHDJOGC@O?$CBn?$DLdecoding?5error?5handler?5must?5@
CONST	SEGMENT
??_C@_0DI@COHDJOGC@O?$CBn?$DLdecoding?5error?5handler?5must?5@ DB 'O!n;de'
	DB	'coding error handler must return (str, int) tuple', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
ascii_linebreak DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
bloom_linebreak DD 0ffffffffH
	ORG $+4
?argparse@?1??unicode_decode_call_errorhandler@@9@9 DQ FLAT:??_C@_0DI@COHDJOGC@O?$CBn?$DLdecoding?5error?5handler?5must?5@ ; `unicode_decode_call_errorhandler'::`2'::argparse
utf7_category DB 03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	03H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	03H
	DB	03H
?argparse@?1??unicode_encode_call_errorhandler@@9@9 DQ FLAT:??_C@_0DN@ECBPBGH@On?$DLencoding?5error?5handler?5must?5r@ ; `unicode_encode_call_errorhandler'::`2'::argparse
?argparse@?1??unicode_translate_call_errorhandler@@9@9 DQ FLAT:??_C@_0DL@NCJPFEFM@O?$CBn?$DLtranslating?5error?5handler?5mu@ ; `unicode_translate_call_errorhandler'::`2'::argparse
encoding_map_methods DQ FLAT:??_C@_04IAGNFIBA@size?$AA@
	DQ	FLAT:encoding_map_size
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CK@PIMLJJMB@Return?5the?5size?5?$CIin?5bytes?$CJ?5of?5th@
	DQ	0000000000000000H
	ORG $+24
EncodingMapType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0M@MLHFIPEJ@EncodingMap?$AA@
	DQ	0000000000000090H
	DQ	0000000000000000H
	DQ	FLAT:encoding_map_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040000H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:encoding_map_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+56
title__doc__ DB	'S.title() -> str', 0aH, 0aH, 'Return a titlecased versio'
	DB	'n of S, i.e. words start with title case', 0aH, 'characters, '
	DB	'all remaining cased characters have lower case.', 00H
	ORG $+7
?kwlist@?1??unicode_encode@@9@9 DQ FLAT:??_C@_08MLPGAEIK@encoding?$AA@ ; `unicode_encode'::`2'::kwlist
	DQ	FLAT:??_C@_06EOMHCNPI@errors?$AA@
	DQ	0000000000000000H
capitalize__doc__ DB 'S.capitalize() -> str', 0aH, 0aH, 'Return a capital'
	DB	'ized version of S, i.e. make the first character', 0aH, 'have'
	DB	' upper case and the rest lower case.', 00H
	ORG $+7
stripformat DQ	FLAT:??_C@_09IBNLIPED@?$HMO?3lstrip?$AA@
	DQ	FLAT:??_C@_09LGDKGINA@?$HMO?3rstrip?$AA@
	DQ	FLAT:??_C@_08NLCECJOD@?$HMO?3strip?$AA@
casefold__doc__ DB 'S.casefold() -> str', 0aH, 0aH, 'Return a version of '
	DB	'S suitable for caseless comparisons.', 00H
	ORG $+2
center__doc__ DB 'S.center(width[, fillchar]) -> str', 0aH, 0aH, 'Return '
	DB	'S centered in a string of length width. Padding is', 0aH, 'do'
	DB	'ne using the specified fill character (default is a space)', 00H
	ORG $+5
count__doc__ DB	'S.count(sub[, start[, end]]) -> int', 0aH, 0aH, 'Return '
	DB	'the number of non-overlapping occurrences of substring sub in'
	DB	0aH, 'string S[start:end].  Optional arguments start and end a'
	DB	're', 0aH, 'interpreted as in slice notation.', 00H
	ORG $+1
?kwlist@?1??unicode_split@@9@9 DQ FLAT:??_C@_03MGBCFPKM@sep?$AA@ ; `unicode_split'::`2'::kwlist
	DQ	FLAT:??_C@_08HONNCIIN@maxsplit?$AA@
	DQ	0000000000000000H
encode__doc__ DB 'S.encode(encoding=''utf-8'', errors=''strict'') -> byte'
	DB	's', 0aH, 0aH, 'Encode S using the codec registered for encodi'
	DB	'ng. Default encoding', 0aH, 'is ''utf-8''. errors may be give'
	DB	'n to set a different error', 0aH, 'handling scheme. Default i'
	DB	's ''strict'' meaning that encoding errors raise', 0aH, 'a Uni'
	DB	'codeEncodeError. Other possible values are ''ignore'', ''repl'
	DB	'ace'' and', 0aH, '''xmlcharrefreplace'' as well as any other '
	DB	'name registered with', 0aH, 'codecs.register_error that can h'
	DB	'andle UnicodeEncodeErrors.', 00H
	ORG $+5
expandtabs__doc__ DB 'S.expandtabs([tabsize]) -> str', 0aH, 0aH, 'Return '
	DB	'a copy of S where all tab characters are expanded using space'
	DB	's.', 0aH, 'If tabsize is not given, a tab size of 8 character'
	DB	's is assumed.', 00H
	ORG $+1
?kwlist@?1??unicode_rsplit@@9@9 DQ FLAT:??_C@_03MGBCFPKM@sep?$AA@ ; `unicode_rsplit'::`2'::kwlist
	DQ	FLAT:??_C@_08HONNCIIN@maxsplit?$AA@
	DQ	0000000000000000H
find__doc__ DB	'S.find(sub[, start[, end]]) -> int', 0aH, 0aH, 'Return t'
	DB	'he lowest index in S where substring sub is found,', 0aH, 'su'
	DB	'ch that sub is contained within S[start:end].  Optional', 0aH
	DB	'arguments start and end are interpreted as in slice notation.'
	DB	0aH, 0aH, 'Return -1 on failure.', 00H
	ORG $+2
index__doc__ DB	'S.index(sub[, start[, end]]) -> int', 0aH, 0aH, 'Like S.'
	DB	'find() but raise ValueError when the substring is not found.', 00H
	ORG $+7
islower__doc__ DB 'S.islower() -> bool', 0aH, 0aH, 'Return True if all ca'
	DB	'sed characters in S are lowercase and there is', 0aH, 'at lea'
	DB	'st one cased character in S, False otherwise.', 00H
	ORG $+3
isupper__doc__ DB 'S.isupper() -> bool', 0aH, 0aH, 'Return True if all ca'
	DB	'sed characters in S are uppercase and there is', 0aH, 'at lea'
	DB	'st one cased character in S, False otherwise.', 00H
	ORG $+3
istitle__doc__ DB 'S.istitle() -> bool', 0aH, 0aH, 'Return True if S is a'
	DB	' titlecased string and there is at least one', 0aH, 'characte'
	DB	'r in S, i.e. upper- and titlecase characters may only', 0aH, 'f'
	DB	'ollow uncased characters and lowercase characters only cased '
	DB	'ones.', 0aH, 'Return False otherwise.', 00H
	ORG $+7
?kwlist@?1??unicode_splitlines@@9@9 DQ FLAT:??_C@_08EMIAAFLA@keepends?$AA@ ; `unicode_splitlines'::`2'::kwlist
	DQ	0000000000000000H
unicode_as_mapping DQ FLAT:unicode_length
	DQ	FLAT:unicode_subscript
	DQ	0000000000000000H
isspace__doc__ DB 'S.isspace() -> bool', 0aH, 0aH, 'Return True if all ch'
	DB	'aracters in S are whitespace', 0aH, 'and there is at least on'
	DB	'e character in S, False otherwise.', 00H
	ORG $+6
upper__doc__ DB	'S.upper() -> str', 0aH, 0aH, 'Return a copy of S convert'
	DB	'ed to uppercase.', 00H
	ORG $+3
sizeof__doc__ DB 'S.__sizeof__() -> size of S in memory, in bytes', 00H
length_hint_doc DB 'Private method returning an estimate of len(list(it))'
	DB	'.', 00H
	ORG $+1
isalpha__doc__ DB 'S.isalpha() -> bool', 0aH, 0aH, 'Return True if all ch'
	DB	'aracters in S are alphabetic', 0aH, 'and there is at least on'
	DB	'e character in S, False otherwise.', 00H
	ORG $+6
?kwlist@?1??unicode_new@@9@9 DQ FLAT:??_C@_06IEOJBDIK@object?$AA@ ; `unicode_new'::`2'::kwlist
	DQ	FLAT:??_C@_08MLPGAEIK@encoding?$AA@
	DQ	FLAT:??_C@_06EOMHCNPI@errors?$AA@
	DQ	0000000000000000H
reduce_doc DB	'Return state information for pickling.', 00H
	ORG $+1
isalnum__doc__ DB 'S.isalnum() -> bool', 0aH, 0aH, 'Return True if all ch'
	DB	'aracters in S are alphanumeric', 0aH, 'and there is at least '
	DB	'one character in S, False otherwise.', 00H
	ORG $+4
setstate_doc DB	'Set state information for unpickling.', 00H
	ORG $+2
isdecimal__doc__ DB 'S.isdecimal() -> bool', 0aH, 0aH, 'Return True if th'
	DB	'ere are only decimal characters in S,', 0aH, 'False otherwise'
	DB	'.', 00H
	ORG $+1
isdigit__doc__ DB 'S.isdigit() -> bool', 0aH, 0aH, 'Return True if all ch'
	DB	'aracters in S are digits', 0aH, 'and there is at least one ch'
	DB	'aracter in S, False otherwise.', 00H
	ORG $+2
isnumeric__doc__ DB 'S.isnumeric() -> bool', 0aH, 0aH, 'Return True if th'
	DB	'ere are only numeric characters in S,', 0aH, 'False otherwise'
	DB	'.', 00H
	ORG $+1
isidentifier__doc__ DB 'S.isidentifier() -> bool', 0aH, 0aH, 'Return True'
	DB	' if S is a valid identifier according', 0aH, 'to the language'
	DB	' definition.', 0aH, 0aH, 'Use keyword.iskeyword() to test for'
	DB	' reserved identifiers', 0aH, 'such as "def" and "class".', 0aH
	DB	00H
	ORG $+3
isprintable__doc__ DB 'S.isprintable() -> bool', 0aH, 0aH, 'Return True i'
	DB	'f all characters in S are considered', 0aH, 'printable in rep'
	DB	'r() or S is empty, False otherwise.', 00H
	ORG $+1
join__doc__ DB	'S.join(iterable) -> str', 0aH, 0aH, 'Return a string whi'
	DB	'ch is the concatenation of the strings in the', 0aH, 'iterabl'
	DB	'e.  The separator between elements is S.', 00H
	ORG $+6
ljust__doc__ DB	'S.ljust(width[, fillchar]) -> str', 0aH, 0aH, 'Return S '
	DB	'left-justified in a Unicode string of length width. Padding i'
	DB	's', 0aH, 'done using the specified fill character (default is'
	DB	' a space).', 00H
	ORG $+7
lower__doc__ DB	'S.lower() -> str', 0aH, 0aH, 'Return a copy of the strin'
	DB	'g S converted to lowercase.', 00H
	ORG $+8
strip__doc__ DB	'S.strip([chars]) -> str', 0aH, 0aH, 'Return a copy of th'
	DB	'e string S with leading and trailing', 0aH, 'whitespace remov'
	DB	'ed.', 0aH, 'If chars is given and not None, remove characters'
	DB	' in chars instead.', 00H
	ORG $+7
lstrip__doc__ DB 'S.lstrip([chars]) -> str', 0aH, 0aH, 'Return a copy of '
	DB	'the string S with leading whitespace removed.', 0aH, 'If char'
	DB	's is given and not None, remove characters in chars instead.', 00H
	ORG $+3
rstrip__doc__ DB 'S.rstrip([chars]) -> str', 0aH, 0aH, 'Return a copy of '
	DB	'the string S with trailing whitespace removed.', 0aH, 'If cha'
	DB	'rs is given and not None, remove characters in chars instead.'
	DB	00H
	ORG $+2
replace__doc__ DB 'S.replace(old, new[, count]) -> str', 0aH, 0aH, 'Retur'
	DB	'n a copy of S with all occurrences of substring', 0aH, 'old r'
	DB	'eplaced by new.  If the optional argument count is', 0aH, 'gi'
	DB	'ven, only the first count occurrences are replaced.', 00H
	ORG $+8
rfind__doc__ DB	'S.rfind(sub[, start[, end]]) -> int', 0aH, 0aH, 'Return '
	DB	'the highest index in S where substring sub is found,', 0aH, 's'
	DB	'uch that sub is contained within S[start:end].  Optional', 0aH
	DB	'arguments start and end are interpreted as in slice notation.'
	DB	0aH, 0aH, 'Return -1 on failure.', 00H
rindex__doc__ DB 'S.rindex(sub[, start[, end]]) -> int', 0aH, 0aH, 'Like '
	DB	'S.rfind() but raise ValueError when the substring is not foun'
	DB	'd.', 00H
	ORG $+5
rjust__doc__ DB	'S.rjust(width[, fillchar]) -> str', 0aH, 0aH, 'Return S '
	DB	'right-justified in a string of length width. Padding is', 0aH
	DB	'done using the specified fill character (default is a space).'
	DB	00H
	ORG $+14
split__doc__ DB	'S.split(sep=None, maxsplit=-1) -> list of strings', 0aH, 0aH
	DB	'Return a list of the words in S, using sep as the', 0aH, 'del'
	DB	'imiter string.  If maxsplit is given, at most maxsplit', 0aH, 's'
	DB	'plits are done. If sep is not specified or is None, any', 0aH
	DB	'whitespace string is a separator and empty strings are', 0aH, 'r'
	DB	'emoved from the result.', 00H
	ORG $+8
partition__doc__ DB 'S.partition(sep) -> (head, sep, tail)', 0aH, 0aH, 'S'
	DB	'earch for the separator sep in S, and return the part before '
	DB	'it,', 0aH, 'the separator itself, and the part after it.  If '
	DB	'the separator is not', 0aH, 'found, return S and two empty st'
	DB	'rings.', 00H
	ORG $+10
rpartition__doc__ DB 'S.rpartition(sep) -> (head, sep, tail)', 0aH, 0aH, 'S'
	DB	'earch for the separator sep in S, starting at the end of S, a'
	DB	'nd return', 0aH, 'the part before it, the separator itself, a'
	DB	'nd the part after it.  If the', 0aH, 'separator is not found,'
	DB	' return two empty strings and S.', 00H
	ORG $+15
rsplit__doc__ DB 'S.rsplit(sep=None, maxsplit=-1) -> list of strings', 0aH
	DB	0aH, 'Return a list of the words in S, using sep as the', 0aH, 'd'
	DB	'elimiter string, starting at the end of the string and', 0aH, 'w'
	DB	'orking to the front.  If maxsplit is given, at most maxsplit', 0aH
	DB	'splits are done. If sep is not specified, any whitespace stri'
	DB	'ng', 0aH, 'is a separator.', 00H
	ORG $+4
splitlines__doc__ DB 'S.splitlines([keepends]) -> list of strings', 0aH, 0aH
	DB	'Return a list of the lines in S, breaking at line boundaries.'
	DB	0aH, 'Line breaks are not included in the resulting list unles'
	DB	's keepends', 0aH, 'is given and true.', 00H
	ORG $+15
swapcase__doc__ DB 'S.swapcase() -> str', 0aH, 0aH, 'Return a copy of S w'
	DB	'ith uppercase characters converted to lowercase', 0aH, 'and v'
	DB	'ice versa.', 00H
	ORG $+7
maketrans__doc__ DB 'str.maketrans(x[, y[, z]]) -> dict (static method)', 0aH
	DB	0aH, 'Return a translation table usable for str.translate().', 0aH
	DB	'If there is only one argument, it must be a dictionary mappin'
	DB	'g Unicode', 0aH, 'ordinals (integers) or characters to Unicod'
	DB	'e ordinals, strings or None.', 0aH, 'Character keys will be t'
	DB	'hen converted to ordinals.', 0aH, 'If there are two arguments'
	DB	', they must be strings of equal length, and', 0aH, 'in the re'
	DB	'sulting dictionary, each character in x will be mapped to the'
	DB	0aH, 'character at the same position in y. If there is a third'
	DB	' argument, it', 0aH, 'must be a string, whose characters will'
	DB	' be mapped to None in the result.', 00H
	ORG $+7
translate__doc__ DB 'S.translate(table) -> str', 0aH, 0aH, 'Return a copy'
	DB	' of the string S, where all characters have been mapped', 0aH
	DB	'through the given translation table, which must be a mapping '
	DB	'of', 0aH, 'Unicode ordinals to Unicode ordinals, strings, or '
	DB	'None.', 0aH, 'Unmapped characters are left untouched. Charact'
	DB	'ers mapped to None', 0aH, 'are deleted.', 00H
	ORG $+9
zfill__doc__ DB	'S.zfill(width) -> str', 0aH, 0aH, 'Pad a numeric string '
	DB	'S with zeros on the left, to fill a field', 0aH, 'of the spec'
	DB	'ified width. The string S is never truncated.', 00H
	ORG $+1
startswith__doc__ DB 'S.startswith(prefix[, start[, end]]) -> bool', 0aH, 0aH
	DB	'Return True if S starts with the specified prefix, False othe'
	DB	'rwise.', 0aH, 'With optional start, test S beginning at that '
	DB	'position.', 0aH, 'With optional end, stop comparing S at that'
	DB	' position.', 0aH, 'prefix can also be a tuple of strings to t'
	DB	'ry.', 00H
	ORG $+2
endswith__doc__ DB 'S.endswith(suffix[, start[, end]]) -> bool', 0aH, 0aH
	DB	'Return True if S ends with the specified suffix, False otherw'
	DB	'ise.', 0aH, 'With optional start, test S beginning at that po'
	DB	'sition.', 0aH, 'With optional end, stop comparing S at that p'
	DB	'osition.', 0aH, 'suffix can also be a tuple of strings to try'
	DB	'.', 00H
	ORG $+6
PyFormatterIter_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BC@OEBNLFHC@formatteriterator?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:formatteriter_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040000H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:formatteriter_next
	DQ	FLAT:formatteriter_methods
	DQ	0000000000000000H
	ORG $+144
PyFieldNameIter_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BC@PNFANA@fieldnameiterator?$AA@
	DQ	0000000000000090H
	DQ	0000000000000000H
	DQ	FLAT:fieldnameiter_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040000H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:fieldnameiter_next
	DQ	FLAT:fieldnameiter_methods
	DQ	0000000000000000H
	ORG $+144
format__doc__ DB 'S.format(*args, **kwargs) -> str', 0aH, 0aH, 'Return a '
	DB	'formatted version of S, using substitutions from args and kwa'
	DB	'rgs.', 0aH, 'The substitutions are identified by braces (''{'''
	DB	' and ''}'').', 00H
	ORG $+9
format_map__doc__ DB 'S.format_map(mapping) -> str', 0aH, 0aH, 'Return a '
	DB	'formatted version of S, using substitutions from mapping.', 0aH
	DB	'The substitutions are identified by braces (''{'' and ''}'').'
	DB	00H
	ORG $+5
p_format__doc__ DB 'S.__format__(format_spec) -> str', 0aH, 0aH, 'Return '
	DB	'a formatted version of S as described by format_spec.', 00H
	ORG $+1
unicode_methods DQ FLAT:??_C@_06GDGADLDP@encode?$AA@
	DQ	FLAT:unicode_encode
	DD	03H
	ORG $+4
	DQ	FLAT:encode__doc__
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	FLAT:unicode_replace
	DD	01H
	ORG $+4
	DQ	FLAT:replace__doc__
	DQ	FLAT:??_C@_05EHPMMFBK@split?$AA@
	DQ	FLAT:unicode_split
	DD	03H
	ORG $+4
	DQ	FLAT:split__doc__
	DQ	FLAT:??_C@_06BAKFHKMF@rsplit?$AA@
	DQ	FLAT:unicode_rsplit
	DD	03H
	ORG $+4
	DQ	FLAT:rsplit__doc__
	DQ	FLAT:??_C@_04DFGCDGNN@join?$AA@
	DQ	FLAT:unicode_join
	DD	08H
	ORG $+4
	DQ	FLAT:join__doc__
	DQ	FLAT:??_C@_0L@NMODNBEH@capitalize?$AA@
	DQ	FLAT:unicode_capitalize
	DD	04H
	ORG $+4
	DQ	FLAT:capitalize__doc__
	DQ	FLAT:??_C@_08NAILFLBF@casefold?$AA@
	DQ	FLAT:unicode_casefold
	DD	04H
	ORG $+4
	DQ	FLAT:casefold__doc__
	DQ	FLAT:??_C@_05PHLGJONK@title?$AA@
	DQ	FLAT:unicode_title
	DD	04H
	ORG $+4
	DQ	FLAT:title__doc__
	DQ	FLAT:??_C@_06BBLOAEEI@center?$AA@
	DQ	FLAT:unicode_center
	DD	01H
	ORG $+4
	DQ	FLAT:center__doc__
	DQ	FLAT:??_C@_05IOMEMJEC@count?$AA@
	DQ	FLAT:unicode_count
	DD	01H
	ORG $+4
	DQ	FLAT:count__doc__
	DQ	FLAT:??_C@_0L@DEOCELBD@expandtabs?$AA@
	DQ	FLAT:unicode_expandtabs
	DD	01H
	ORG $+4
	DQ	FLAT:expandtabs__doc__
	DQ	FLAT:??_C@_04CKFJHKAP@find?$AA@
	DQ	FLAT:unicode_find
	DD	01H
	ORG $+4
	DQ	FLAT:find__doc__
	DQ	FLAT:??_C@_09IKAEIPAD@partition?$AA@
	DQ	FLAT:unicode_partition
	DD	08H
	ORG $+4
	DQ	FLAT:partition__doc__
	DQ	FLAT:??_C@_05FKHKFDID@index?$AA@
	DQ	FLAT:unicode_index
	DD	01H
	ORG $+4
	DQ	FLAT:index__doc__
	DQ	FLAT:??_C@_05KDIMMEME@ljust?$AA@
	DQ	FLAT:unicode_ljust
	DD	01H
	ORG $+4
	DQ	FLAT:ljust__doc__
	DQ	FLAT:??_C@_05IPJEPLHL@lower?$AA@
	DQ	FLAT:unicode_lower
	DD	04H
	ORG $+4
	DQ	FLAT:lower__doc__
	DQ	FLAT:??_C@_06GGONODO@lstrip?$AA@
	DQ	FLAT:unicode_lstrip
	DD	01H
	ORG $+4
	DQ	FLAT:lstrip__doc__
	DQ	FLAT:??_C@_05BLFDIAHL@rfind?$AA@
	DQ	FLAT:unicode_rfind
	DD	01H
	ORG $+4
	DQ	FLAT:rfind__doc__
	DQ	FLAT:??_C@_06NCDOMFM@rindex?$AA@
	DQ	FLAT:unicode_rindex
	DD	01H
	ORG $+4
	DQ	FLAT:rindex__doc__
	DQ	FLAT:??_C@_05JKFAKHCP@rjust?$AA@
	DQ	FLAT:unicode_rjust
	DD	01H
	ORG $+4
	DQ	FLAT:rjust__doc__
	DQ	FLAT:??_C@_06DBIPDJKN@rstrip?$AA@
	DQ	FLAT:unicode_rstrip
	DD	01H
	ORG $+4
	DQ	FLAT:rstrip__doc__
	DQ	FLAT:??_C@_0L@KEEHLNKL@rpartition?$AA@
	DQ	FLAT:unicode_rpartition
	DD	08H
	ORG $+4
	DQ	FLAT:rpartition__doc__
	DQ	FLAT:??_C@_0L@BCMGLLLC@splitlines?$AA@
	DQ	FLAT:unicode_splitlines
	DD	03H
	ORG $+4
	DQ	FLAT:splitlines__doc__
	DQ	FLAT:??_C@_05GGNGIGHC@strip?$AA@
	DQ	FLAT:unicode_strip
	DD	01H
	ORG $+4
	DQ	FLAT:strip__doc__
	DQ	FLAT:??_C@_08EDJLBCEI@swapcase?$AA@
	DQ	FLAT:unicode_swapcase
	DD	04H
	ORG $+4
	DQ	FLAT:swapcase__doc__
	DQ	FLAT:??_C@_09ODNGOEIO@translate?$AA@
	DQ	FLAT:unicode_translate
	DD	08H
	ORG $+4
	DQ	FLAT:translate__doc__
	DQ	FLAT:??_C@_05NECKJAMC@upper?$AA@
	DQ	FLAT:unicode_upper
	DD	04H
	ORG $+4
	DQ	FLAT:upper__doc__
	DQ	FLAT:??_C@_0L@MPOGHCCL@startswith?$AA@
	DQ	FLAT:unicode_startswith
	DD	01H
	ORG $+4
	DQ	FLAT:startswith__doc__
	DQ	FLAT:??_C@_08MLCMCPNP@endswith?$AA@
	DQ	FLAT:unicode_endswith
	DD	01H
	ORG $+4
	DQ	FLAT:endswith__doc__
	DQ	FLAT:??_C@_07EJFAPEJH@islower?$AA@
	DQ	FLAT:unicode_islower
	DD	04H
	ORG $+4
	DQ	FLAT:islower__doc__
	DQ	FLAT:??_C@_07BCOOJPCO@isupper?$AA@
	DQ	FLAT:unicode_isupper
	DD	04H
	ORG $+4
	DQ	FLAT:isupper__doc__
	DQ	FLAT:??_C@_07DBHCJBDG@istitle?$AA@
	DQ	FLAT:unicode_istitle
	DD	04H
	ORG $+4
	DQ	FLAT:istitle__doc__
	DQ	FLAT:??_C@_07CNBMLEON@isspace?$AA@
	DQ	FLAT:unicode_isspace
	DD	04H
	ORG $+4
	DQ	FLAT:isspace__doc__
	DQ	FLAT:??_C@_09CGNFEIIK@isdecimal?$AA@
	DQ	FLAT:unicode_isdecimal
	DD	04H
	ORG $+4
	DQ	FLAT:isdecimal__doc__
	DQ	FLAT:??_C@_07CFBKIKCH@isdigit?$AA@
	DQ	FLAT:unicode_isdigit
	DD	04H
	ORG $+4
	DQ	FLAT:isdigit__doc__
	DQ	FLAT:??_C@_09KOMAEOED@isnumeric?$AA@
	DQ	FLAT:unicode_isnumeric
	DD	04H
	ORG $+4
	DQ	FLAT:isnumeric__doc__
	DQ	FLAT:??_C@_07EGIOHHOB@isalpha?$AA@
	DQ	FLAT:unicode_isalpha
	DD	04H
	ORG $+4
	DQ	FLAT:isalpha__doc__
	DQ	FLAT:??_C@_07EOADCIGC@isalnum?$AA@
	DQ	FLAT:unicode_isalnum
	DD	04H
	ORG $+4
	DQ	FLAT:isalnum__doc__
	DQ	FLAT:??_C@_0N@DOKMMCGL@isidentifier?$AA@
	DQ	FLAT:unicode_isidentifier
	DD	04H
	ORG $+4
	DQ	FLAT:isidentifier__doc__
	DQ	FLAT:??_C@_0M@JGKJDKBM@isprintable?$AA@
	DQ	FLAT:unicode_isprintable
	DD	04H
	ORG $+4
	DQ	FLAT:isprintable__doc__
	DQ	FLAT:??_C@_05DMFNFMHA@zfill?$AA@
	DQ	FLAT:unicode_zfill
	DD	01H
	ORG $+4
	DQ	FLAT:zfill__doc__
	DQ	FLAT:??_C@_06DLEPGFEF@format?$AA@
	DQ	FLAT:do_string_format
	DD	03H
	ORG $+4
	DQ	FLAT:format__doc__
	DQ	FLAT:??_C@_0L@DBBJLEAP@format_map?$AA@
	DQ	FLAT:do_string_format_map
	DD	08H
	ORG $+4
	DQ	FLAT:format_map__doc__
	DQ	FLAT:??_C@_0L@MEMCGMKL@__format__?$AA@
	DQ	FLAT:unicode__format__
	DD	01H
	ORG $+4
	DQ	FLAT:p_format__doc__
	DQ	FLAT:??_C@_09PBBLPCAA@maketrans?$AA@
	DQ	FLAT:unicode_maketrans
	DD	021H
	ORG $+4
	DQ	FLAT:maketrans__doc__
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:unicode__sizeof__
	DD	04H
	ORG $+4
	DQ	FLAT:sizeof__doc__
	DQ	FLAT:??_C@_0P@BCBHENLA@__getnewargs__?$AA@
	DQ	FLAT:unicode_getnewargs
	DD	04H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
unicode_as_number DQ 0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:unicode_mod
	ORG $+240
unicode_as_sequence DQ FLAT:unicode_length
	DQ	FLAT:PyUnicode_Concat
	DQ	FLAT:unicode_repeat
	DQ	FLAT:unicode_getitem
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyUnicode_Contains
	ORG $+16
unicode_doc DB	'str(object='''') -> str', 0aH, 'str(bytes_or_buffer[, en'
	DB	'coding[, errors]]) -> str', 0aH, 0aH, 'Create a new string ob'
	DB	'ject from the given object. If encoding or', 0aH, 'errors is '
	DB	'specified, then the object must expose a data buffer', 0aH, 't'
	DB	'hat will be decoded using the given encoding and error handle'
	DB	'r.', 0aH, 'Otherwise, returns the result of object.__str__() '
	DB	'(if defined)', 0aH, 'or repr(object).', 0aH, 'encoding defaul'
	DB	'ts to sys.getdefaultencoding().', 0aH, 'errors defaults to '''
	DB	'strict''.', 00H
	ORG $+10
PyUnicode_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_03OJMAPEGJ@str?$AA@
	DQ	00000000000000b0H
	DQ	0000000000000000H
	DQ	FLAT:unicode_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:unicode_repr
	DQ	FLAT:unicode_as_number
	DQ	FLAT:unicode_as_sequence
	DQ	FLAT:unicode_as_mapping
	DQ	FLAT:unicode_hash
	DQ	0000000000000000H
	DQ	FLAT:unicode_str
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	010040400H
	ORG $+4
	DQ	FLAT:unicode_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyUnicode_RichCompare
	DQ	0000000000000000H
	DQ	FLAT:unicode_iter
	DQ	0000000000000000H
	DQ	FLAT:unicode_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyBaseObject_Type
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:unicode_new
	DQ	FLAT:PyObject_Free
	ORG $+64
unicodeiter_methods DQ FLAT:??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
	DQ	FLAT:unicodeiter_len
	DD	04H
	ORG $+4
	DQ	FLAT:length_hint_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:unicodeiter_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:unicodeiter_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
PyUnicodeIter_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0N@GHJLLMAJ@str_iterator?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:unicodeiter_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:unicodeiter_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:unicodeiter_next
	DQ	FLAT:unicodeiter_methods
	DQ	0000000000000000H
	ORG $+144
_string_methods DQ FLAT:??_C@_0BL@GJEMJGHD@formatter_field_name_split?$AA@
	DQ	FLAT:formatter_field_name_split
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0CD@LNGEKMIN@split?5the?5argument?5as?5a?5field?5na@
	DQ	FLAT:??_C@_0BB@JJJFGPCM@formatter_parser?$AA@
	DQ	FLAT:formatter_parser
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0CG@FCKLAMOB@parse?5the?5argument?5as?5a?5format?5s@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
_string_module DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_07PGCBFEPB@_string?$AA@
	DQ	FLAT:??_C@_0BF@BEBBJAIL@string?5helper?5module?$AA@
	DQ	0000000000000000H
	DQ	FLAT:_string_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
CONST	SEGMENT
_Py_ascii_whitespace DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\include\objimpl.h
_TEXT	ENDS
;	COMDAT _PyObject_InitHead
_TEXT	SEGMENT
op$ = 8
_PyObject_InitHead PROC					; COMDAT

; 216  :     assert(Py_TYPE(op));
; 217  :     op->is_px = _Py_NOT_PARALLEL;

  00000	48 ba 78 56 ef
	be 34 12 ad de	 mov	 rdx, -2401243008567650696 ; dead1234beef5678H

; 218  :     op->px    = _Py_NOT_PARALLEL;
; 219  :     op->slist_entry.Next = NULL;

  0000a	33 c0		 xor	 eax, eax

; 220  :     op->px_flags  = Py_PXFLAGS_ISPY;

  0000c	48 c7 41 20 01
	00 00 00	 mov	 QWORD PTR [rcx+32], 1
  00014	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00017	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  0001b	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 221  :     op->srw_lock  = NULL;

  0001f	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 222  :     op->event     = NULL;

  00023	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 223  :     op->orig_type = NULL;

  00027	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 224  : #ifdef Py_TRACE_REFS
; 225  :     op->_ob_next = NULL;
; 226  :     op->_ob_prev = NULL;
; 227  : #else
; 228  :     op->_ob_next = _Py_NOT_PARALLEL;

  0002b	48 89 51 40	 mov	 QWORD PTR [rcx+64], rdx

; 229  :     op->_ob_prev = _Py_NOT_PARALLEL;

  0002f	48 89 51 48	 mov	 QWORD PTR [rcx+72], rdx

; 230  : #endif
; 231  : }

  00033	c3		 ret	 0
_PyObject_InitHead ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@JKHPLOII@PyObject_INIT?$AA@		; `string'
PUBLIC	??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@ ; `string'
EXTRN	_Px_NewReference:PROC
EXTRN	_PxObject_Init:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_INIT DD imagerel PyObject_INIT
	DD	imagerel PyObject_INIT+185
	DD	imagerel $unwind$PyObject_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_INIT DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0O@JKHPLOII@PyObject_INIT?$AA@
CONST	SEGMENT
??_C@_0O@JKHPLOII@PyObject_INIT?$AA@ DB 'PyObject_INIT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@
CONST	SEGMENT
??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@ DB 'c:\src\pypa'
	DB	'rallel\include\objimpl.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_INIT
_TEXT	SEGMENT
op$ = 64
tp$ = 72
PyObject_INIT PROC					; COMDAT

; 236  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 237  :     Px_RETURN(_PxObject_Init(op, tp))

  00010	e8 00 00 00 00	 call	 _Py_PXCTX
  00015	85 c0		 test	 eax, eax
  00017	74 15		 je	 SHORT $LN1@PyObject_I
  00019	48 8b d7	 mov	 rdx, rdi
  0001c	48 8b cb	 mov	 rcx, rbx

; 242  : }

  0001f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00024	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00028	5f		 pop	 rdi
  00029	e9 00 00 00 00	 jmp	 _PxObject_Init
$LN1@PyObject_I:

; 238  :     Py_TYPE(op) = tp;
; 239  :     _PyObject_InitHead(op);

  0002e	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00038	33 c0		 xor	 eax, eax

; 240  :     _Py_NewReference(op);

  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@
  00041	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  00044	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx
  00048	48 89 4b 40	 mov	 QWORD PTR [rbx+64], rcx
  0004c	48 89 4b 48	 mov	 QWORD PTR [rbx+72], rcx
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@JKHPLOII@PyObject_INIT?$AA@
  00057	4c 8b cb	 mov	 r9, rbx
  0005a	41 b8 f0 00 00
	00		 mov	 r8d, 240		; 000000f0H
  00060	48 89 7b 58	 mov	 QWORD PTR [rbx+88], rdi
  00064	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
  00068	48 c7 43 20 01
	00 00 00	 mov	 QWORD PTR [rbx+32], 1
  00070	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  00074	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax
  00078	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
  0007c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00084	e8 00 00 00 00	 call	 _PyParallel_Guard
  00089	85 c0		 test	 eax, eax
  0008b	74 16		 je	 SHORT $LN4@PyObject_I
  0008d	48 8b cb	 mov	 rcx, rbx
  00090	e8 00 00 00 00	 call	 _Px_NewReference

; 241  :     return op;

  00095	48 8b c3	 mov	 rax, rbx

; 242  : }

  00098	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a1	5f		 pop	 rdi
  000a2	c3		 ret	 0
$LN4@PyObject_I:

; 240  :     _Py_NewReference(op);

  000a3	48 c7 43 50 01
	00 00 00	 mov	 QWORD PTR [rbx+80], 1

; 241  :     return op;

  000ab	48 8b c3	 mov	 rax, rbx

; 242  : }

  000ae	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
PyObject_INIT ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_GetMax
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
;	COMDAT PyUnicode_GetMax
_TEXT	SEGMENT
PyUnicode_GetMax PROC					; COMDAT

; 305  : #ifdef Py_UNICODE_WIDE
; 306  :     return 0x10FFFF;
; 307  : #else
; 308  :     /* This is actually an illegal character, so it should
; 309  :        not be passed to unichr. */
; 310  :     return 0xFFFF;

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 311  : #endif
; 312  : }

  00005	c3		 ret	 0
PyUnicode_GetMax ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$make_bloom_mask DD imagerel make_bloom_mask
	DD	imagerel make_bloom_mask+95
	DD	imagerel $unwind$make_bloom_mask
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$make_bloom_mask DD 020501H
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT make_bloom_mask
_TEXT	SEGMENT
kind$ = 8
ptr$ = 16
len$ = 24
make_bloom_mask PROC					; COMDAT

; 569  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	49 8b d8	 mov	 rbx, r8

; 570  :     /* calculate simple bloom-style bitmask for a given unicode string */
; 571  : 
; 572  :     BLOOM_MASK mask;
; 573  :     Py_ssize_t i;
; 574  : 
; 575  :     mask = 0;

  00008	45 33 c0	 xor	 r8d, r8d
  0000b	4c 8b d2	 mov	 r10, rdx

; 576  :     for (i = 0; i < len; i++)

  0000e	45 8b c8	 mov	 r9d, r8d
  00011	44 8b d9	 mov	 r11d, ecx
  00014	48 85 db	 test	 rbx, rbx
  00017	7e 3d		 jle	 SHORT $LN12@make_bloom
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL3@make_bloom:

; 577  :         BLOOM_ADD(mask, PyUnicode_READ(kind, ptr, i));

  00020	41 83 fb 01	 cmp	 r11d, 1
  00024	75 07		 jne	 SHORT $LN8@make_bloom
  00026	43 0f b6 04 11	 movzx	 eax, BYTE PTR [r9+r10]
  0002b	eb 11		 jmp	 SHORT $LN7@make_bloom
$LN8@make_bloom:
  0002d	41 83 fb 02	 cmp	 r11d, 2
  00031	75 07		 jne	 SHORT $LN6@make_bloom
  00033	43 0f b7 04 4a	 movzx	 eax, WORD PTR [r10+r9*2]
  00038	eb 04		 jmp	 SHORT $LN7@make_bloom
$LN6@make_bloom:

; 576  :     for (i = 0; i < len; i++)

  0003a	43 8b 04 8a	 mov	 eax, DWORD PTR [r10+r9*4]
$LN7@make_bloom:

; 577  :         BLOOM_ADD(mask, PyUnicode_READ(kind, ptr, i));

  0003e	83 e0 1f	 and	 eax, 31
  00041	ba 01 00 00 00	 mov	 edx, 1
  00046	49 ff c1	 inc	 r9
  00049	0f b6 c8	 movzx	 ecx, al
  0004c	d3 e2		 shl	 edx, cl
  0004e	44 0b c2	 or	 r8d, edx
  00051	4c 3b cb	 cmp	 r9, rbx
  00054	7c ca		 jl	 SHORT $LL3@make_bloom
$LN12@make_bloom:

; 578  : 
; 579  :     return mask;
; 580  : }

  00056	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0005b	41 8b c0	 mov	 eax, r8d
  0005e	c3		 ret	 0
make_bloom_mask ENDP
_TEXT	ENDS
EXTRN	__imp_memchr:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$asciilib_fastsearch_memchr_1char DD imagerel asciilib_fastsearch_memchr_1char
	DD	imagerel asciilib_fastsearch_memchr_1char+72
	DD	imagerel $unwind$asciilib_fastsearch_memchr_1char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_fastsearch_memchr_1char DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT asciilib_fastsearch_memchr_1char
_TEXT	SEGMENT
s$ = 48
n$ = 56
needle$ = 64
mode$ = 72
asciilib_fastsearch_memchr_1char PROC			; COMDAT

; 40   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	41 0f b6 c0	 movzx	 eax, r8b
  0000a	48 8b d9	 mov	 rbx, rcx

; 41   :     if (mode == FAST_SEARCH) {

  0000d	41 83 f9 01	 cmp	 r9d, 1
  00011	75 2d		 jne	 SHORT $LN6@asciilib_f

; 42   :         const STRINGLIB_CHAR *ptr = s;
; 43   :         const STRINGLIB_CHAR *e = s + n;

  00013	4c 8d 04 11	 lea	 r8, QWORD PTR [rcx+rdx]

; 44   :         while (ptr < e) {

  00017	49 3b c8	 cmp	 rcx, r8
  0001a	73 11		 jae	 SHORT $LN4@asciilib_f

; 45   :             void *candidate = memchr((const void *) ptr, needle, (e - ptr) * sizeof(STRINGLIB_CHAR));

  0001c	4c 2b c1	 sub	 r8, rcx
  0001f	0f b6 d0	 movzx	 edx, al
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr

; 46   :             if (candidate == NULL)

  00028	48 85 c0	 test	 rax, rax
  0002b	75 0a		 jne	 SHORT $LN3@asciilib_f
$LN4@asciilib_f:

; 47   :                 return -1;

  0002d	48 83 c8 ff	 or	 rax, -1

; 78   :     }
; 79   : 
; 80   : #undef DO_MEMCHR
; 81   : }

  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5b		 pop	 rbx
  00036	c3		 ret	 0
$LN3@asciilib_f:

; 48   :             ptr = (const STRINGLIB_CHAR *) _Py_ALIGN_DOWN(candidate, sizeof(STRINGLIB_CHAR));
; 49   :             if (sizeof(STRINGLIB_CHAR) == 1 || *ptr == ch)
; 50   :                 return (ptr - s);

  00037	48 2b c3	 sub	 rax, rbx

; 78   :     }
; 79   : 
; 80   : #undef DO_MEMCHR
; 81   : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	c3		 ret	 0
$LN6@asciilib_f:

; 51   :             /* False positive */
; 52   :             ptr++;
; 53   :         }
; 54   :         return -1;
; 55   :     }
; 56   : #ifdef HAVE_MEMRCHR
; 57   :     /* memrchr() is a GNU extension, available since glibc 2.1.91.
; 58   :        it doesn't seem as optimized as memchr(), but is still quite
; 59   :        faster than our hand-written loop in FASTSEARCH below */
; 60   :     else if (mode == FAST_RSEARCH) {
; 61   :         while (n > 0) {
; 62   :             const STRINGLIB_CHAR *found;
; 63   :             void *candidate = memrchr((const void *) s, needle, n * sizeof(STRINGLIB_CHAR));
; 64   :             if (candidate == NULL)
; 65   :                 return -1;
; 66   :             found = (const STRINGLIB_CHAR *) _Py_ALIGN_DOWN(candidate, sizeof(STRINGLIB_CHAR));
; 67   :             n = found - s;
; 68   :             if (sizeof(STRINGLIB_CHAR) == 1 || *found == ch)
; 69   :                 return n;
; 70   :             /* False positive */
; 71   :         }
; 72   :         return -1;
; 73   :     }
; 74   : #endif
; 75   :     else {
; 76   :         assert(0); /* Should never get here */
; 77   :         return 0;

  00040	33 c0		 xor	 eax, eax

; 78   :     }
; 79   : 
; 80   : #undef DO_MEMCHR
; 81   : }

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5b		 pop	 rbx
  00047	c3		 ret	 0
asciilib_fastsearch_memchr_1char ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$asciilib_fastsearch DD imagerel asciilib_fastsearch
	DD	imagerel asciilib_fastsearch+346
	DD	imagerel $unwind$asciilib_fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$asciilib_fastsearch DD imagerel asciilib_fastsearch+346
	DD	imagerel asciilib_fastsearch+977
	DD	imagerel $chain$2$asciilib_fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$asciilib_fastsearch DD imagerel asciilib_fastsearch+977
	DD	imagerel asciilib_fastsearch+991
	DD	imagerel $chain$3$asciilib_fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$asciilib_fastsearch DD imagerel asciilib_fastsearch+991
	DD	imagerel asciilib_fastsearch+996
	DD	imagerel $chain$4$asciilib_fastsearch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$asciilib_fastsearch DD 060021H
	DD	067400H
	DD	076400H
	DD	0e5400H
	DD	imagerel asciilib_fastsearch
	DD	imagerel asciilib_fastsearch+346
	DD	imagerel $unwind$asciilib_fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$asciilib_fastsearch DD 021H
	DD	imagerel asciilib_fastsearch
	DD	imagerel asciilib_fastsearch+346
	DD	imagerel $unwind$asciilib_fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$asciilib_fastsearch DD 061321H
	DD	067413H
	DD	07640aH
	DD	0e5405H
	DD	imagerel asciilib_fastsearch
	DD	imagerel asciilib_fastsearch+346
	DD	imagerel $unwind$asciilib_fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_fastsearch DD 061201H
	DD	0f00e7212H
	DD	0d00ae00cH
	DD	03006c008H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT asciilib_fastsearch
_TEXT	SEGMENT
s$ = 112
mask$1$ = 120
n$ = 120
p$ = 128
skip$1$ = 136
m$ = 136
maxcount$ = 144
mode$ = 152
asciilib_fastsearch PROC				; COMDAT

; 87   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	53		 push	 rbx
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	41 56		 push	 r14
  0000c	41 57		 push	 r15
  0000e	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00012	4d 8b e9	 mov	 r13, r9

; 88   :     unsigned long mask;
; 89   :     Py_ssize_t skip, count = 0;

  00015	45 33 db	 xor	 r11d, r11d

; 90   :     Py_ssize_t i, j, mlast, w;
; 91   : 
; 92   :     w = n - m;

  00018	4c 8b d2	 mov	 r10, rdx
  0001b	4d 2b d5	 sub	 r10, r13
  0001e	4d 8b f8	 mov	 r15, r8
  00021	48 8b d9	 mov	 rbx, rcx
  00024	45 8b cb	 mov	 r9d, r11d

; 93   : 
; 94   :     if (w < 0 || (mode == FAST_COUNT && maxcount == 0))

  00027	0f 88 1b 01 00
	00		 js	 $LN41@asciilib_f@2
  0002d	44 8b b4 24 98
	00 00 00	 mov	 r14d, DWORD PTR mode$[rsp]
  00035	4c 8b a4 24 90
	00 00 00	 mov	 r12, QWORD PTR maxcount$[rsp]
  0003d	45 85 f6	 test	 r14d, r14d
  00040	75 09		 jne	 SHORT $LN61@asciilib_f@2
  00042	4d 85 e4	 test	 r12, r12
  00045	0f 84 fd 00 00
	00		 je	 $LN41@asciilib_f@2
$LN61@asciilib_f@2:

; 95   :         return -1;
; 96   : 
; 97   :     /* look for special cases */
; 98   :     if (m <= 1) {

  0004b	49 83 fd 01	 cmp	 r13, 1
  0004f	0f 8f 05 01 00
	00		 jg	 $LN59@asciilib_f@2

; 99   :         if (m <= 0)

  00055	4d 85 ed	 test	 r13, r13

; 100  :             return -1;

  00058	0f 8e ea 00 00
	00		 jle	 $LN41@asciilib_f@2

; 101  :         /* use special case for 1-character strings */
; 102  :         if (n > 10 && (mode == FAST_SEARCH
; 103  : #ifdef HAVE_MEMRCHR
; 104  :                     || mode == FAST_RSEARCH
; 105  : #endif
; 106  :                     )) {

  0005e	48 83 fa 0a	 cmp	 rdx, 10
  00062	7e 3a		 jle	 SHORT $LN57@asciilib_f@2
  00064	41 83 fe 01	 cmp	 r14d, 1
  00068	75 34		 jne	 SHORT $LN57@asciilib_f@2

; 107  :             /* use memchr if we can choose a needle without two many likely
; 108  :                false positives */
; 109  :             unsigned char needle;
; 110  :             needle = p[0] & 0xff;
; 111  : #if STRINGLIB_SIZEOF_CHAR > 1
; 112  :             /* If looking for a multiple of 256, we'd have too
; 113  :                many false positives looking for the '\0' byte in UCS2
; 114  :                and UCS4 representations. */
; 115  :             if (needle != 0)
; 116  : #endif
; 117  :                 return STRINGLIB(fastsearch_memchr_1char)
; 118  :                        (s, n, p[0], needle, maxcount, mode);

  0006a	4c 8d 04 11	 lea	 r8, QWORD PTR [rcx+rdx]
  0006e	49 3b c8	 cmp	 rcx, r8
  00071	0f 83 d1 00 00
	00		 jae	 $LN41@asciilib_f@2
  00077	41 0f b6 17	 movzx	 edx, BYTE PTR [r15]
  0007b	4c 2b c1	 sub	 r8, rcx
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00084	48 85 c0	 test	 rax, rax
  00087	0f 84 bb 00 00
	00		 je	 $LN41@asciilib_f@2
  0008d	48 2b c3	 sub	 rax, rbx

; 223  : }

  00090	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00094	41 5f		 pop	 r15
  00096	41 5e		 pop	 r14
  00098	41 5d		 pop	 r13
  0009a	41 5c		 pop	 r12
  0009c	5b		 pop	 rbx
  0009d	c3		 ret	 0
$LN57@asciilib_f@2:

; 119  :         }
; 120  :         if (mode == FAST_COUNT) {

  0009e	45 85 f6	 test	 r14d, r14d
  000a1	75 45		 jne	 SHORT $LN56@asciilib_f@2

; 121  :             for (i = 0; i < n; i++)

  000a3	48 85 d2	 test	 rdx, rdx
  000a6	7e 1e		 jle	 SHORT $LN99@asciilib_f@2
  000a8	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  000ac	0f 1f 40 00	 npad	 4
$LL55@asciilib_f@2:

; 122  :                 if (s[i] == p[0]) {

  000b0	41 38 04 0b	 cmp	 BYTE PTR [r11+rcx], al
  000b4	75 08		 jne	 SHORT $LN54@asciilib_f@2

; 123  :                     count++;

  000b6	49 ff c1	 inc	 r9

; 124  :                     if (count == maxcount)

  000b9	4d 3b cc	 cmp	 r9, r12
  000bc	74 19		 je	 SHORT $LN81@asciilib_f@2
$LN54@asciilib_f@2:

; 121  :             for (i = 0; i < n; i++)

  000be	49 ff c3	 inc	 r11
  000c1	4c 3b da	 cmp	 r11, rdx
  000c4	7c ea		 jl	 SHORT $LL55@asciilib_f@2
$LN99@asciilib_f@2:

; 126  :                 }
; 127  :             return count;

  000c6	49 8b c1	 mov	 rax, r9

; 223  : }

  000c9	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000cd	41 5f		 pop	 r15
  000cf	41 5e		 pop	 r14
  000d1	41 5d		 pop	 r13
  000d3	41 5c		 pop	 r12
  000d5	5b		 pop	 rbx
  000d6	c3		 ret	 0
$LN81@asciilib_f@2:

; 125  :                         return maxcount;

  000d7	49 8b c4	 mov	 rax, r12

; 223  : }

  000da	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000de	41 5f		 pop	 r15
  000e0	41 5e		 pop	 r14
  000e2	41 5d		 pop	 r13
  000e4	41 5c		 pop	 r12
  000e6	5b		 pop	 rbx
  000e7	c3		 ret	 0
$LN56@asciilib_f@2:

; 128  :         } else if (mode == FAST_SEARCH) {

  000e8	41 83 fe 01	 cmp	 r14d, 1
  000ec	75 3a		 jne	 SHORT $LN49@asciilib_f@2

; 129  :             for (i = 0; i < n; i++)

  000ee	48 85 d2	 test	 rdx, rdx
  000f1	7e 55		 jle	 SHORT $LN41@asciilib_f@2
  000f3	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
$LL48@asciilib_f@2:

; 130  :                 if (s[i] == p[0])

  000f7	41 38 04 0b	 cmp	 BYTE PTR [r11+rcx], al
  000fb	74 1a		 je	 SHORT $LN82@asciilib_f@2

; 129  :             for (i = 0; i < n; i++)

  000fd	49 ff c3	 inc	 r11
  00100	4c 3b da	 cmp	 r11, rdx
  00103	7c f2		 jl	 SHORT $LL48@asciilib_f@2

; 135  :                     return i;
; 136  :         }
; 137  :         return -1;

  00105	48 83 c8 ff	 or	 rax, -1

; 223  : }

  00109	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0010d	41 5f		 pop	 r15
  0010f	41 5e		 pop	 r14
  00111	41 5d		 pop	 r13
  00113	41 5c		 pop	 r12
  00115	5b		 pop	 rbx
  00116	c3		 ret	 0
$LN82@asciilib_f@2:

; 131  :                     return i;

  00117	49 8b c3	 mov	 rax, r11

; 223  : }

  0011a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0011e	41 5f		 pop	 r15
  00120	41 5e		 pop	 r14
  00122	41 5d		 pop	 r13
  00124	41 5c		 pop	 r12
  00126	5b		 pop	 rbx
  00127	c3		 ret	 0
$LN49@asciilib_f@2:

; 132  :         } else {    /* FAST_RSEARCH */
; 133  :             for (i = n - 1; i > -1; i--)

  00128	48 8d 42 ff	 lea	 rax, QWORD PTR [rdx-1]
  0012c	48 83 f8 ff	 cmp	 rax, -1
  00130	7e 16		 jle	 SHORT $LN41@asciilib_f@2
  00132	41 0f b6 08	 movzx	 ecx, BYTE PTR [r8]
$LL43@asciilib_f@2:

; 134  :                 if (s[i] == p[0])

  00136	38 0c 18	 cmp	 BYTE PTR [rax+rbx], cl
  00139	0f 84 92 02 00
	00		 je	 $LN62@asciilib_f@2

; 132  :         } else {    /* FAST_RSEARCH */
; 133  :             for (i = n - 1; i > -1; i--)

  0013f	48 ff c8	 dec	 rax
  00142	48 83 f8 ff	 cmp	 rax, -1
  00146	7f ee		 jg	 SHORT $LL43@asciilib_f@2
$LN41@asciilib_f@2:

; 135  :                     return i;
; 136  :         }
; 137  :         return -1;

  00148	48 83 c8 ff	 or	 rax, -1

; 223  : }

  0014c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00150	41 5f		 pop	 r15
  00152	41 5e		 pop	 r14
  00154	41 5d		 pop	 r13
  00156	41 5c		 pop	 r12
  00158	5b		 pop	 rbx
  00159	c3		 ret	 0
$LN59@asciilib_f@2:
  0015a	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  0015f	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi

; 138  :     }
; 139  : 
; 140  :     mlast = m - 1;
; 141  :     skip = mlast - 1;
; 142  :     mask = 0;
; 143  : 
; 144  :     if (mode != FAST_RSEARCH) {

  00164	48 83 cd ff	 or	 rbp, -1
  00168	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0016d	49 8d 7d ff	 lea	 rdi, QWORD PTR [r13-1]
  00171	45 8b c3	 mov	 r8d, r11d
  00174	48 8d 47 ff	 lea	 rax, QWORD PTR [rdi-1]

; 145  : 
; 146  :         /* create compressed boyer-moore delta 1 table */
; 147  : 
; 148  :         /* process pattern[:-1] */
; 149  :         for (i = 0; i < mlast; i++) {

  00178	8d 75 02	 lea	 esi, QWORD PTR [rbp+2]
  0017b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR skip$1$[rsp], rax
  00183	41 83 fe 02	 cmp	 r14d, 2
  00187	0f 84 5b 01 00
	00		 je	 $LN39@asciilib_f@2
  0018d	48 85 ff	 test	 rdi, rdi
  00190	7e 75		 jle	 SHORT $LN36@asciilib_f@2
  00192	46 0f b6 3c 3f	 movzx	 r15d, BYTE PTR [rdi+r15]
  00197	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR p$[rsp]
  0019f	4c 8d 4f ff	 lea	 r9, QWORD PTR [rdi-1]
  001a3	4c 8b f7	 mov	 r14, rdi
  001a6	4d 8b e1	 mov	 r12, r9
  001a9	41 8b fb	 mov	 edi, r11d
  001ac	0f 1f 40 00	 npad	 4
$LL38@asciilib_f@2:

; 150  :             STRINGLIB_BLOOM_ADD(mask, p[i]);

  001b0	44 0f b6 45 00	 movzx	 r8d, BYTE PTR [rbp]
  001b5	8b d6		 mov	 edx, esi
  001b7	41 8b c8	 mov	 ecx, r8d
  001ba	83 e1 1f	 and	 ecx, 31
  001bd	d3 e2		 shl	 edx, cl
  001bf	0b fa		 or	 edi, edx

; 151  :             if (p[i] == p[mlast])

  001c1	45 3a c7	 cmp	 r8b, r15b
  001c4	4d 0f 44 cc	 cmove	 r9, r12
  001c8	48 ff c5	 inc	 rbp
  001cb	49 ff cc	 dec	 r12
  001ce	49 ff ce	 dec	 r14
  001d1	75 dd		 jne	 SHORT $LL38@asciilib_f@2
  001d3	4c 8b a4 24 90
	00 00 00	 mov	 r12, QWORD PTR maxcount$[rsp]
  001db	44 8b b4 24 98
	00 00 00	 mov	 r14d, DWORD PTR mode$[rsp]
  001e3	4c 8b bc 24 80
	00 00 00	 mov	 r15, QWORD PTR p$[rsp]
  001eb	89 7c 24 78	 mov	 DWORD PTR mask$1$[rsp], edi
  001ef	4c 89 8c 24 88
	00 00 00	 mov	 QWORD PTR skip$1$[rsp], r9
  001f7	48 83 cd ff	 or	 rbp, -1
  001fb	44 8b 44 24 78	 mov	 r8d, DWORD PTR mask$1$[rsp]
  00200	4d 8b cb	 mov	 r9, r11
  00203	49 8d 7d ff	 lea	 rdi, QWORD PTR [r13-1]
$LN36@asciilib_f@2:

; 152  :                 skip = mlast - i - 1;
; 153  :         }
; 154  :         /* process pattern[-1] outside the loop */
; 155  :         STRINGLIB_BLOOM_ADD(mask, p[mlast]);

  00207	42 0f b6 04 3f	 movzx	 eax, BYTE PTR [rdi+r15]

; 156  : 
; 157  :         for (i = 0; i <= w; i++) {

  0020c	49 8b d3	 mov	 rdx, r11
  0020f	83 e0 1f	 and	 eax, 31
  00212	0f b6 c8	 movzx	 ecx, al
  00215	d3 e6		 shl	 esi, cl
  00217	44 0b c6	 or	 r8d, esi
  0021a	44 89 44 24 78	 mov	 DWORD PTR mask$1$[rsp], r8d
  0021f	4d 85 d2	 test	 r10, r10
  00222	0f 88 9f 00 00
	00		 js	 $LN100@asciilib_f@2
  00228	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR p$[rsp]
  00230	4e 8d 3c 2b	 lea	 r15, QWORD PTR [rbx+r13]
$LN108@asciilib_f@2:
  00234	42 0f b6 44 2e
	ff		 movzx	 eax, BYTE PTR [rsi+r13-1]

; 158  :             /* note: using mlast in the skip path slows things down on x86 */
; 159  :             if (s[i+m-1] == p[m-1]) {

  0023a	41 38 44 17 ff	 cmp	 BYTE PTR [r15+rdx-1], al
  0023f	75 69		 jne	 SHORT $LN31@asciilib_f@2

; 160  :                 /* candidate match */
; 161  :                 for (j = 0; j < mlast; j++)

  00241	4d 8b c3	 mov	 r8, r11
  00244	48 85 ff	 test	 rdi, rdi
  00247	7e 28		 jle	 SHORT $LN84@asciilib_f@2
  00249	48 8b c2	 mov	 rax, rdx
  0024c	48 8b ce	 mov	 rcx, rsi
  0024f	48 2b c6	 sub	 rax, rsi
  00252	48 8d 34 18	 lea	 rsi, QWORD PTR [rax+rbx]
$LL30@asciilib_f@2:

; 162  :                     if (s[i+j] != p[j])

  00256	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00259	38 04 0e	 cmp	 BYTE PTR [rsi+rcx], al
  0025c	75 0b		 jne	 SHORT $LN102@asciilib_f@2

; 160  :                 /* candidate match */
; 161  :                 for (j = 0; j < mlast; j++)

  0025e	49 ff c0	 inc	 r8
  00261	48 ff c1	 inc	 rcx
  00264	4c 3b c7	 cmp	 r8, rdi
  00267	7c ed		 jl	 SHORT $LL30@asciilib_f@2
$LN102@asciilib_f@2:
  00269	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR p$[rsp]
$LN84@asciilib_f@2:

; 163  :                         break;
; 164  :                 if (j == mlast) {

  00271	4c 3b c7	 cmp	 r8, rdi
  00274	75 17		 jne	 SHORT $LN26@asciilib_f@2

; 165  :                     /* got a match! */
; 166  :                     if (mode != FAST_COUNT)

  00276	45 85 f6	 test	 r14d, r14d
  00279	75 65		 jne	 SHORT $LN85@asciilib_f@2

; 168  :                     count++;

  0027b	49 ff c1	 inc	 r9

; 169  :                     if (count == maxcount)

  0027e	4d 3b cc	 cmp	 r9, r12
  00281	74 55		 je	 SHORT $LN86@asciilib_f@2

; 171  :                     i = i + mlast;
; 172  :                     continue;

  00283	44 8b 44 24 78	 mov	 r8d, DWORD PTR mask$1$[rsp]
  00288	48 03 d7	 add	 rdx, rdi
  0028b	eb 2e		 jmp	 SHORT $LN33@asciilib_f@2
$LN26@asciilib_f@2:

; 173  :                 }
; 174  :                 /* miss: check if next character is part of pattern */
; 175  :                 if (!STRINGLIB_BLOOM(mask, s[i+m]))

  0028d	41 0f b6 04 17	 movzx	 eax, BYTE PTR [r15+rdx]
  00292	44 8b 44 24 78	 mov	 r8d, DWORD PTR mask$1$[rsp]
  00297	83 e0 1f	 and	 eax, 31
  0029a	41 0f a3 c0	 bt	 r8d, eax

; 176  :                     i = i + m;
; 177  :                 else

  0029e	73 18		 jae	 SHORT $LN107@asciilib_f@2

; 178  :                     i = i + skip;

  002a0	48 03 94 24 88
	00 00 00	 add	 rdx, QWORD PTR skip$1$[rsp]

; 179  :             } else {

  002a8	eb 11		 jmp	 SHORT $LN33@asciilib_f@2
$LN31@asciilib_f@2:

; 180  :                 /* skip: check if next character is part of pattern */
; 181  :                 if (!STRINGLIB_BLOOM(mask, s[i+m]))

  002aa	41 0f b6 04 17	 movzx	 eax, BYTE PTR [r15+rdx]
  002af	83 e0 1f	 and	 eax, 31
  002b2	41 0f a3 c0	 bt	 r8d, eax
  002b6	72 03		 jb	 SHORT $LN33@asciilib_f@2
$LN107@asciilib_f@2:

; 182  :                     i = i + m;

  002b8	49 03 d5	 add	 rdx, r13
$LN33@asciilib_f@2:

; 156  : 
; 157  :         for (i = 0; i <= w; i++) {

  002bb	48 ff c2	 inc	 rdx
  002be	49 3b d2	 cmp	 rdx, r10
  002c1	0f 8e 6d ff ff
	ff		 jle	 $LN108@asciilib_f@2
$LN100@asciilib_f@2:

; 216  :             }
; 217  :         }
; 218  :     }
; 219  : 
; 220  :     if (mode != FAST_COUNT)

  002c7	45 85 f6	 test	 r14d, r14d
  002ca	0f 85 ef 00 00
	00		 jne	 $LN101@asciilib_f@2

; 222  :     return count;

  002d0	49 8b c1	 mov	 rax, r9
  002d3	e9 ea 00 00 00	 jmp	 $LN106@asciilib_f@2
$LN86@asciilib_f@2:

; 170  :                         return maxcount;

  002d8	49 8b c4	 mov	 rax, r12
  002db	e9 e2 00 00 00	 jmp	 $LN106@asciilib_f@2
$LN85@asciilib_f@2:

; 167  :                         return i;

  002e0	48 8b c2	 mov	 rax, rdx
  002e3	e9 da 00 00 00	 jmp	 $LN106@asciilib_f@2
$LN39@asciilib_f@2:

; 183  :             }
; 184  :         }
; 185  :     } else {    /* FAST_RSEARCH */
; 186  : 
; 187  :         /* create compressed boyer-moore delta 1 table */
; 188  : 
; 189  :         /* process pattern[0] outside the loop */
; 190  :         STRINGLIB_BLOOM_ADD(mask, p[0]);

  002e8	45 0f b6 37	 movzx	 r14d, BYTE PTR [r15]
  002ec	44 8b e6	 mov	 r12d, esi
  002ef	41 8b ce	 mov	 ecx, r14d
  002f2	83 e1 1f	 and	 ecx, 31
  002f5	41 d3 e4	 shl	 r12d, cl

; 191  :         /* process pattern[:0:-1] */
; 192  :         for (i = mlast; i > 0; i--) {

  002f8	48 85 ff	 test	 rdi, rdi
  002fb	7e 41		 jle	 SHORT $LN16@asciilib_f@2
  002fd	4e 8d 0c 3f	 lea	 r9, QWORD PTR [rdi+r15]
  00301	49 2b ef	 sub	 rbp, r15
  00304	4c 8b df	 mov	 r11, rdi
  00307	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL18@asciilib_f@2:

; 193  :             STRINGLIB_BLOOM_ADD(mask, p[i]);

  00310	45 0f b6 01	 movzx	 r8d, BYTE PTR [r9]
  00314	8b d6		 mov	 edx, esi
  00316	41 8b c8	 mov	 ecx, r8d
  00319	83 e1 1f	 and	 ecx, 31
  0031c	d3 e2		 shl	 edx, cl
  0031e	44 0b e2	 or	 r12d, edx

; 194  :             if (p[i] == p[0])

  00321	45 3a c6	 cmp	 r8b, r14b
  00324	75 0c		 jne	 SHORT $LN17@asciilib_f@2

; 195  :                 skip = i - 1;

  00326	49 8d 04 29	 lea	 rax, QWORD PTR [r9+rbp]
  0032a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR skip$1$[rsp], rax
$LN17@asciilib_f@2:

; 191  :         /* process pattern[:0:-1] */
; 192  :         for (i = mlast; i > 0; i--) {

  00332	49 ff c9	 dec	 r9
  00335	49 ff cb	 dec	 r11
  00338	75 d6		 jne	 SHORT $LL18@asciilib_f@2
  0033a	48 83 cd ff	 or	 rbp, -1
$LN16@asciilib_f@2:

; 196  :         }
; 197  : 
; 198  :         for (i = w; i >= 0; i--) {

  0033e	4d 8b c2	 mov	 r8, r10
  00341	4d 2b c7	 sub	 r8, r15
  00344	4c 03 c3	 add	 r8, rbx
$LL14@asciilib_f@2:

; 199  :             if (s[i] == p[0]) {

  00347	45 38 34 1a	 cmp	 BYTE PTR [r10+rbx], r14b
  0034b	75 50		 jne	 SHORT $LN11@asciilib_f@2

; 200  :                 /* candidate match */
; 201  :                 for (j = mlast; j > 0; j--)

  0034d	48 8b d7	 mov	 rdx, rdi
  00350	48 85 ff	 test	 rdi, rdi
  00353	7e 1f		 jle	 SHORT $LN103@asciilib_f@2
  00355	4a 8d 0c 3f	 lea	 rcx, QWORD PTR [rdi+r15]
  00359	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@asciilib_f@2:

; 202  :                     if (s[i+j] != p[j])

  00360	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00363	41 38 04 08	 cmp	 BYTE PTR [r8+rcx], al
  00367	75 0b		 jne	 SHORT $LN103@asciilib_f@2

; 200  :                 /* candidate match */
; 201  :                 for (j = mlast; j > 0; j--)

  00369	48 ff ca	 dec	 rdx
  0036c	48 ff c9	 dec	 rcx
  0036f	48 85 d2	 test	 rdx, rdx
  00372	7f ec		 jg	 SHORT $LL10@asciilib_f@2
$LN103@asciilib_f@2:

; 203  :                         break;
; 204  :                 if (j == 0)

  00374	48 85 d2	 test	 rdx, rdx
  00377	74 66		 je	 SHORT $LN88@asciilib_f@2

; 207  :                 /* miss: check if previous character is part of pattern */
; 208  :                 if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))

  00379	4d 85 d2	 test	 r10, r10
  0037c	7e 0f		 jle	 SHORT $LN5@asciilib_f@2
  0037e	41 0f b6 44 1a
	ff		 movzx	 eax, BYTE PTR [r10+rbx-1]
  00384	83 e0 1f	 and	 eax, 31
  00387	41 0f a3 c4	 bt	 r12d, eax

; 209  :                     i = i - m;
; 210  :                 else

  0038b	73 24		 jae	 SHORT $LN109@asciilib_f@2
$LN5@asciilib_f@2:

; 211  :                     i = i - skip;

  0038d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR skip$1$[rsp]
  00395	4c 2b d2	 sub	 r10, rdx
  00398	4c 2b c2	 sub	 r8, rdx

; 212  :             } else {

  0039b	eb 1a		 jmp	 SHORT $LN13@asciilib_f@2
$LN11@asciilib_f@2:

; 213  :                 /* skip: check if previous character is part of pattern */
; 214  :                 if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))

  0039d	4d 85 d2	 test	 r10, r10
  003a0	7e 15		 jle	 SHORT $LN13@asciilib_f@2
  003a2	41 0f b6 44 1a
	ff		 movzx	 eax, BYTE PTR [r10+rbx-1]
  003a8	83 e0 1f	 and	 eax, 31
  003ab	41 0f a3 c4	 bt	 r12d, eax
  003af	72 06		 jb	 SHORT $LN13@asciilib_f@2
$LN109@asciilib_f@2:

; 215  :                     i = i - m;

  003b1	4d 2b d5	 sub	 r10, r13
  003b4	4d 2b c5	 sub	 r8, r13
$LN13@asciilib_f@2:

; 196  :         }
; 197  : 
; 198  :         for (i = w; i >= 0; i--) {

  003b7	49 ff c8	 dec	 r8
  003ba	49 ff ca	 dec	 r10
  003bd	79 88		 jns	 SHORT $LL14@asciilib_f@2
$LN101@asciilib_f@2:

; 221  :         return -1;

  003bf	48 8b c5	 mov	 rax, rbp
$LN106@asciilib_f@2:
  003c2	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  003c7	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  003cc	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN62@asciilib_f@2:

; 223  : }

  003d1	48 83 c4 40	 add	 rsp, 64			; 00000040H
  003d5	41 5f		 pop	 r15
  003d7	41 5e		 pop	 r14
  003d9	41 5d		 pop	 r13
  003db	41 5c		 pop	 r12
  003dd	5b		 pop	 rbx
  003de	c3		 ret	 0
$LN88@asciilib_f@2:

; 205  :                     /* got a match! */
; 206  :                     return i;

  003df	49 8b c2	 mov	 rax, r10
  003e2	eb de		 jmp	 SHORT $LN106@asciilib_f@2
asciilib_fastsearch ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\count.h
pdata	SEGMENT
$pdata$asciilib_count DD imagerel asciilib_count
	DD	imagerel asciilib_count+40
	DD	imagerel $unwind$asciilib_count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$asciilib_count DD imagerel asciilib_count+40
	DD	imagerel asciilib_count+73
	DD	imagerel $chain$0$asciilib_count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$asciilib_count DD imagerel asciilib_count+73
	DD	imagerel asciilib_count+78
	DD	imagerel $chain$1$asciilib_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$asciilib_count DD 021H
	DD	imagerel asciilib_count
	DD	imagerel asciilib_count+40
	DD	imagerel $unwind$asciilib_count
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$asciilib_count DD 020521H
	DD	063405H
	DD	imagerel asciilib_count
	DD	imagerel asciilib_count+40
	DD	imagerel $unwind$asciilib_count
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_count DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT asciilib_count
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
maxcount$ = 96
asciilib_count PROC					; COMDAT

; 11   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 12   :     Py_ssize_t count;
; 13   : 
; 14   :     if (str_len < 0)

  00004	48 85 d2	 test	 rdx, rdx
  00007	79 07		 jns	 SHORT $LN3@asciilib_c

; 15   :         return 0; /* start > len(str) */

  00009	33 c0		 xor	 eax, eax

; 22   :         return 0; /* no match */
; 23   : 
; 24   :     return count;
; 25   : }

  0000b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0000f	c3		 ret	 0
$LN3@asciilib_c:

; 16   :     if (sub_len == 0)
; 17   :         return (str_len < maxcount) ? str_len + 1 : maxcount;

  00010	48 8b 44 24 60	 mov	 rax, QWORD PTR maxcount$[rsp]
  00015	4d 85 c9	 test	 r9, r9
  00018	75 0e		 jne	 SHORT $LN2@asciilib_c
  0001a	48 3b d0	 cmp	 rdx, rax
  0001d	7d 2a		 jge	 SHORT $LN1@asciilib_c
  0001f	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]

; 22   :         return 0; /* no match */
; 23   : 
; 24   :     return count;
; 25   : }

  00023	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00027	c3		 ret	 0
$LN2@asciilib_c:
  00028	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 18   : 
; 19   :     count = FASTSEARCH(str, str_len, sub, sub_len, maxcount, FAST_COUNT);

  0002d	33 db		 xor	 ebx, ebx
  0002f	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  00033	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00038	e8 00 00 00 00	 call	 asciilib_fastsearch

; 20   : 
; 21   :     if (count < 0)

  0003d	48 85 c0	 test	 rax, rax
  00040	48 0f 48 c3	 cmovs	 rax, rbx
  00044	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN1@asciilib_c:

; 22   :         return 0; /* no match */
; 23   : 
; 24   :     return count;
; 25   : }

  00049	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004d	c3		 ret	 0
asciilib_count ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$asciilib_find DD imagerel asciilib_find
	DD	imagerel asciilib_find+58
	DD	imagerel $unwind$asciilib_find
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$asciilib_find DD imagerel asciilib_find+58
	DD	imagerel asciilib_find+235
	DD	imagerel $chain$4$asciilib_find
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$asciilib_find DD imagerel asciilib_find+235
	DD	imagerel asciilib_find+513
	DD	imagerel $chain$6$asciilib_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$asciilib_find DD 0a0021H
	DD	06f400H
	DD	07d400H
	DD	0fc400H
	DD	0e6400H
	DD	0c5400H
	DD	imagerel asciilib_find
	DD	imagerel asciilib_find+58
	DD	imagerel $unwind$asciilib_find
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$asciilib_find DD 0a1c21H
	DD	06f41cH
	DD	07d417H
	DD	0fc40fH
	DD	0e640aH
	DD	0c5405H
	DD	imagerel asciilib_find
	DD	imagerel asciilib_find+58
	DD	imagerel $unwind$asciilib_find
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_find DD 040901H
	DD	0e0057209H
	DD	030027003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\find.h
xdata	ENDS
;	COMDAT asciilib_find
_TEXT	SEGMENT
w$1$ = 32
str$ = 96
skip$1$ = 104
str_len$ = 104
sub$ = 112
sub_len$ = 120
offset$ = 128
asciilib_find PROC					; COMDAT

; 11   : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 56		 push	 r14
  00005	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00009	49 8b d9	 mov	 rbx, r9
  0000c	4d 8b f0	 mov	 r14, r8
  0000f	48 8b f9	 mov	 rdi, rcx

; 12   :     Py_ssize_t pos;
; 13   : 
; 14   :     if (str_len < 0)

  00012	48 85 d2	 test	 rdx, rdx
  00015	79 0d		 jns	 SHORT $LN3@asciilib_f@3

; 15   :         return -1;

  00017	48 83 c8 ff	 or	 rax, -1

; 25   : }

  0001b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0001f	41 5e		 pop	 r14
  00021	5f		 pop	 rdi
  00022	5b		 pop	 rbx
  00023	c3		 ret	 0
$LN3@asciilib_f@3:

; 16   :     if (sub_len == 0)

  00024	48 85 db	 test	 rbx, rbx
  00027	75 11		 jne	 SHORT $LN2@asciilib_f@3

; 17   :         return offset;

  00029	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR offset$[rsp]

; 25   : }

  00031	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00035	41 5e		 pop	 r14
  00037	5f		 pop	 rdi
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
$LN2@asciilib_f@3:
  0003a	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  0003f	48 89 74 24 70	 mov	 QWORD PTR [rsp+112], rsi
  00044	4c 89 64 24 78	 mov	 QWORD PTR [rsp+120], r12

; 18   : 
; 19   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_SEARCH);

  00049	48 8b ea	 mov	 rbp, rdx
  0004c	4c 89 6c 24 38	 mov	 QWORD PTR [rsp+56], r13
  00051	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  00056	48 2b eb	 sub	 rbp, rbx
  00059	48 89 6c 24 20	 mov	 QWORD PTR w$1$[rsp], rbp
  0005e	78 62		 js	 SHORT $LN65@asciilib_f@3
  00060	48 83 fb 01	 cmp	 rbx, 1
  00064	0f 8f 81 00 00
	00		 jg	 $LN64@asciilib_f@3
  0006a	48 85 db	 test	 rbx, rbx
  0006d	7e 53		 jle	 SHORT $LN65@asciilib_f@3
  0006f	48 83 fa 0a	 cmp	 rdx, 10
  00073	7e 2f		 jle	 SHORT $LN62@asciilib_f@3
  00075	4c 8d 04 11	 lea	 r8, QWORD PTR [rcx+rdx]
  00079	49 3b c8	 cmp	 rcx, r8
  0007c	73 15		 jae	 SHORT $LN72@asciilib_f@3
  0007e	41 0f b6 16	 movzx	 edx, BYTE PTR [r14]
  00082	4c 2b c1	 sub	 r8, rcx
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0008b	4c 8b c8	 mov	 r9, rax
  0008e	48 85 c0	 test	 rax, rax
  00091	75 09		 jne	 SHORT $LN71@asciilib_f@3
$LN72@asciilib_f@3:
  00093	49 83 c9 ff	 or	 r9, -1
  00097	e9 4f 01 00 00	 jmp	 $LN67@asciilib_f@3
$LN71@asciilib_f@3:
  0009c	4c 2b cf	 sub	 r9, rdi
  0009f	e9 47 01 00 00	 jmp	 $LN67@asciilib_f@3
$LN62@asciilib_f@3:
  000a4	45 33 c9	 xor	 r9d, r9d
  000a7	48 85 d2	 test	 rdx, rdx
  000aa	7e 16		 jle	 SHORT $LN65@asciilib_f@3
  000ac	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
$LL53@asciilib_f@3:
  000b0	41 38 04 09	 cmp	 BYTE PTR [r9+rcx], al
  000b4	0f 84 31 01 00
	00		 je	 $LN67@asciilib_f@3
  000ba	49 ff c1	 inc	 r9
  000bd	4c 3b ca	 cmp	 r9, rdx
  000c0	7c ee		 jl	 SHORT $LL53@asciilib_f@3
$LN65@asciilib_f@3:
  000c2	49 83 c9 ff	 or	 r9, -1
$LN1@asciilib_f@3:
  000c6	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]
  000cb	4c 8b 6c 24 38	 mov	 r13, QWORD PTR [rsp+56]
  000d0	4c 8b 64 24 78	 mov	 r12, QWORD PTR [rsp+120]
  000d5	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  000da	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]

; 23   : 
; 24   :     return pos;

  000df	49 8b c1	 mov	 rax, r9

; 25   : }

  000e2	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000e6	41 5e		 pop	 r14
  000e8	5f		 pop	 rdi
  000e9	5b		 pop	 rbx
  000ea	c3		 ret	 0

; 18   : 
; 19   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_SEARCH);

$LN64@asciilib_f@3:
  000eb	4d 8d 51 ff	 lea	 r10, QWORD PTR [r9-1]
  000ef	45 33 c9	 xor	 r9d, r9d
  000f2	4d 8d 62 ff	 lea	 r12, QWORD PTR [r10-1]
  000f6	45 8b f9	 mov	 r15d, r9d
  000f9	45 8d 59 01	 lea	 r11d, QWORD PTR [r9+1]
  000fd	4d 85 d2	 test	 r10, r10
  00100	7e 55		 jle	 SHORT $LN41@asciilib_f@3
  00102	47 0f b6 2c 02	 movzx	 r13d, BYTE PTR [r10+r8]
  00107	49 8b ec	 mov	 rbp, r12
  0010a	4d 8b e2	 mov	 r12, r10
  0010d	4c 8b d5	 mov	 r10, rbp
  00110	49 8b f0	 mov	 rsi, r8
  00113	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL43@asciilib_f@3:
  00120	44 0f b6 06	 movzx	 r8d, BYTE PTR [rsi]
  00124	41 8b d3	 mov	 edx, r11d
  00127	41 8b c8	 mov	 ecx, r8d
  0012a	83 e1 1f	 and	 ecx, 31
  0012d	d3 e2		 shl	 edx, cl
  0012f	44 0b fa	 or	 r15d, edx
  00132	45 3a c5	 cmp	 r8b, r13b
  00135	4c 0f 44 d5	 cmove	 r10, rbp
  00139	48 ff c6	 inc	 rsi
  0013c	48 ff cd	 dec	 rbp
  0013f	49 ff cc	 dec	 r12
  00142	75 dc		 jne	 SHORT $LL43@asciilib_f@3
  00144	48 8b 6c 24 20	 mov	 rbp, QWORD PTR w$1$[rsp]
  00149	4c 89 54 24 68	 mov	 QWORD PTR skip$1$[rsp], r10
  0014e	4c 8d 53 ff	 lea	 r10, QWORD PTR [rbx-1]
  00152	4c 8b 64 24 68	 mov	 r12, QWORD PTR skip$1$[rsp]
$LN41@asciilib_f@3:
  00157	43 0f b6 0c 32	 movzx	 ecx, BYTE PTR [r10+r14]
  0015c	49 8b d1	 mov	 rdx, r9
  0015f	83 e1 1f	 and	 ecx, 31
  00162	41 d3 e3	 shl	 r11d, cl
  00165	45 0b fb	 or	 r15d, r11d
  00168	48 85 ed	 test	 rbp, rbp
  0016b	0f 88 51 ff ff
	ff		 js	 $LN65@asciilib_f@3
  00171	45 0f b6 6c 1e
	ff		 movzx	 r13d, BYTE PTR [r14+rbx-1]
  00177	48 8d 34 1f	 lea	 rsi, QWORD PTR [rdi+rbx]
  0017b	0f 1f 44 00 00	 npad	 5
$LL39@asciilib_f@3:
  00180	44 38 6c 16 ff	 cmp	 BYTE PTR [rsi+rdx-1], r13b
  00185	75 44		 jne	 SHORT $LN36@asciilib_f@3
  00187	4d 8b c1	 mov	 r8, r9
  0018a	4d 85 d2	 test	 r10, r10
  0018d	7e 25		 jle	 SHORT $LN89@asciilib_f@3
  0018f	4c 8b da	 mov	 r11, rdx
  00192	49 8b ce	 mov	 rcx, r14
  00195	4d 2b de	 sub	 r11, r14
  00198	4c 03 df	 add	 r11, rdi
  0019b	0f 1f 44 00 00	 npad	 5
$LL35@asciilib_f@3:
  001a0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  001a3	41 38 04 0b	 cmp	 BYTE PTR [r11+rcx], al
  001a7	75 0b		 jne	 SHORT $LN89@asciilib_f@3
  001a9	49 ff c0	 inc	 r8
  001ac	48 ff c1	 inc	 rcx
  001af	4d 3b c2	 cmp	 r8, r10
  001b2	7c ec		 jl	 SHORT $LL35@asciilib_f@3
$LN89@asciilib_f@3:
  001b4	4d 3b c2	 cmp	 r8, r10
  001b7	74 2f		 je	 SHORT $LN83@asciilib_f@3
  001b9	0f b6 04 16	 movzx	 eax, BYTE PTR [rsi+rdx]
  001bd	83 e0 1f	 and	 eax, 31
  001c0	41 0f a3 c7	 bt	 r15d, eax
  001c4	73 12		 jae	 SHORT $LN90@asciilib_f@3
  001c6	49 03 d4	 add	 rdx, r12
  001c9	eb 10		 jmp	 SHORT $LN38@asciilib_f@3
$LN36@asciilib_f@3:
  001cb	0f b6 04 16	 movzx	 eax, BYTE PTR [rsi+rdx]
  001cf	83 e0 1f	 and	 eax, 31
  001d2	41 0f a3 c7	 bt	 r15d, eax
  001d6	72 03		 jb	 SHORT $LN38@asciilib_f@3
$LN90@asciilib_f@3:
  001d8	48 03 d3	 add	 rdx, rbx
$LN38@asciilib_f@3:
  001db	48 ff c2	 inc	 rdx
  001de	48 3b d5	 cmp	 rdx, rbp
  001e1	7e 9d		 jle	 SHORT $LL39@asciilib_f@3
  001e3	e9 da fe ff ff	 jmp	 $LN65@asciilib_f@3
$LN83@asciilib_f@3:
  001e8	4c 8b ca	 mov	 r9, rdx
$LN67@asciilib_f@3:

; 20   : 
; 21   :     if (pos >= 0)

  001eb	4d 85 c9	 test	 r9, r9
  001ee	0f 88 d2 fe ff
	ff		 js	 $LN1@asciilib_f@3

; 22   :         pos += offset;

  001f4	4c 03 8c 24 80
	00 00 00	 add	 r9, QWORD PTR offset$[rsp]
  001fc	e9 c5 fe ff ff	 jmp	 $LN1@asciilib_f@3
asciilib_find ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$asciilib_rfind DD imagerel asciilib_rfind
	DD	imagerel asciilib_rfind+58
	DD	imagerel $unwind$asciilib_rfind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$asciilib_rfind DD imagerel asciilib_rfind+58
	DD	imagerel asciilib_rfind+161
	DD	imagerel $chain$2$asciilib_rfind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$asciilib_rfind DD imagerel asciilib_rfind+161
	DD	imagerel asciilib_rfind+198
	DD	imagerel $chain$4$asciilib_rfind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$asciilib_rfind DD imagerel asciilib_rfind+198
	DD	imagerel asciilib_rfind+280
	DD	imagerel $chain$6$asciilib_rfind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$asciilib_rfind DD imagerel asciilib_rfind+280
	DD	imagerel asciilib_rfind+425
	DD	imagerel $chain$7$asciilib_rfind
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$asciilib_rfind DD 021H
	DD	imagerel asciilib_rfind+161
	DD	imagerel asciilib_rfind+198
	DD	imagerel $chain$4$asciilib_rfind
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$asciilib_rfind DD 040d21H
	DD	07740dH
	DD	066405H
	DD	imagerel asciilib_rfind+161
	DD	imagerel asciilib_rfind+198
	DD	imagerel $chain$4$asciilib_rfind
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$asciilib_rfind DD 060021H
	DD	0e400H
	DD	01d400H
	DD	08c400H
	DD	imagerel asciilib_rfind
	DD	imagerel asciilib_rfind+58
	DD	imagerel $unwind$asciilib_rfind
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$asciilib_rfind DD 061421H
	DD	0e414H
	DD	01d40dH
	DD	08c405H
	DD	imagerel asciilib_rfind
	DD	imagerel asciilib_rfind+58
	DD	imagerel $unwind$asciilib_rfind
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_rfind DD 040901H
	DD	0f0051209H
	DD	030025003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\find.h
xdata	ENDS
;	COMDAT asciilib_rfind
_TEXT	SEGMENT
str$ = 48
str_len$ = 56
sub$ = 64
sub_len$ = 72
offset$ = 80
asciilib_rfind PROC					; COMDAT

; 31   : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	41 57		 push	 r15
  00005	48 83 ec 10	 sub	 rsp, 16
  00009	49 8b d9	 mov	 rbx, r9
  0000c	4d 8b f8	 mov	 r15, r8
  0000f	48 8b e9	 mov	 rbp, rcx

; 32   :     Py_ssize_t pos;
; 33   : 
; 34   :     if (str_len < 0)

  00012	48 85 d2	 test	 rdx, rdx
  00015	79 0d		 jns	 SHORT $LN3@asciilib_r

; 35   :         return -1;

  00017	48 83 c8 ff	 or	 rax, -1

; 45   : }

  0001b	48 83 c4 10	 add	 rsp, 16
  0001f	41 5f		 pop	 r15
  00021	5d		 pop	 rbp
  00022	5b		 pop	 rbx
  00023	c3		 ret	 0
$LN3@asciilib_r:

; 36   :     if (sub_len == 0)

  00024	48 85 db	 test	 rbx, rbx
  00027	75 11		 jne	 SHORT $LN2@asciilib_r

; 37   :         return str_len + offset;

  00029	48 8b 44 24 50	 mov	 rax, QWORD PTR offset$[rsp]
  0002e	48 03 c2	 add	 rax, rdx

; 45   : }

  00031	48 83 c4 10	 add	 rsp, 16
  00035	41 5f		 pop	 r15
  00037	5d		 pop	 rbp
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
$LN2@asciilib_r:
  0003a	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12

; 38   : 
; 39   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_RSEARCH);

  0003f	4c 8b ca	 mov	 r9, rdx
  00042	4c 89 6c 24 08	 mov	 QWORD PTR [rsp+8], r13
  00047	4c 2b cb	 sub	 r9, rbx
  0004a	4c 89 34 24	 mov	 QWORD PTR [rsp], r14
  0004e	78 33		 js	 SHORT $LN65@asciilib_r
  00050	48 83 fb 01	 cmp	 rbx, 1
  00054	7f 4b		 jg	 SHORT $LN64@asciilib_r
  00056	48 85 db	 test	 rbx, rbx
  00059	7e 28		 jle	 SHORT $LN65@asciilib_r
  0005b	4c 8d 4a ff	 lea	 r9, QWORD PTR [rdx-1]
  0005f	49 83 f9 ff	 cmp	 r9, -1
  00063	7e 1e		 jle	 SHORT $LN65@asciilib_r
  00065	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL48@asciilib_r:
  00070	41 38 04 09	 cmp	 BYTE PTR [r9+rcx], al
  00074	0f 84 15 01 00
	00		 je	 $LN83@asciilib_r
  0007a	49 ff c9	 dec	 r9
  0007d	49 83 f9 ff	 cmp	 r9, -1
  00081	7f ed		 jg	 SHORT $LL48@asciilib_r
$LN65@asciilib_r:
  00083	49 83 ca ff	 or	 r10, -1
$LN1@asciilib_r:
  00087	4c 8b 34 24	 mov	 r14, QWORD PTR [rsp]
  0008b	4c 8b 6c 24 08	 mov	 r13, QWORD PTR [rsp+8]
  00090	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]

; 43   : 
; 44   :     return pos;

  00095	49 8b c2	 mov	 rax, r10

; 45   : }

  00098	48 83 c4 10	 add	 rsp, 16
  0009c	41 5f		 pop	 r15
  0009e	5d		 pop	 rbp
  0009f	5b		 pop	 rbx
  000a0	c3		 ret	 0

; 38   : 
; 39   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_RSEARCH);

$LN64@asciilib_r:
  000a1	45 0f b6 18	 movzx	 r11d, BYTE PTR [r8]
  000a5	4c 8d 63 ff	 lea	 r12, QWORD PTR [rbx-1]
  000a9	41 be 01 00 00
	00		 mov	 r14d, 1
  000af	41 8b cb	 mov	 ecx, r11d
  000b2	49 83 ca ff	 or	 r10, -1
  000b6	4d 8d 6c 24 ff	 lea	 r13, QWORD PTR [r12-1]
  000bb	83 e1 1f	 and	 ecx, 31
  000be	41 d3 e6	 shl	 r14d, cl
  000c1	4d 85 e4	 test	 r12, r12
  000c4	7e 52		 jle	 SHORT $LN21@asciilib_r
  000c6	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  000cb	49 8b f2	 mov	 rsi, r10
  000ce	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  000d3	4f 8d 1c 04	 lea	 r11, QWORD PTR [r12+r8]
  000d7	49 8b fc	 mov	 rdi, r12
  000da	45 0f b6 20	 movzx	 r12d, BYTE PTR [r8]
  000de	49 2b f0	 sub	 rsi, r8
$LL23@asciilib_r:
  000e1	45 0f b6 03	 movzx	 r8d, BYTE PTR [r11]
  000e5	ba 01 00 00 00	 mov	 edx, 1
  000ea	41 8b c8	 mov	 ecx, r8d
  000ed	83 e1 1f	 and	 ecx, 31
  000f0	d3 e2		 shl	 edx, cl
  000f2	44 0b f2	 or	 r14d, edx
  000f5	45 3a c4	 cmp	 r8b, r12b
  000f8	75 04		 jne	 SHORT $LN22@asciilib_r
  000fa	4e 8d 2c 1e	 lea	 r13, QWORD PTR [rsi+r11]
$LN22@asciilib_r:
  000fe	49 ff cb	 dec	 r11
  00101	48 ff cf	 dec	 rdi
  00104	75 db		 jne	 SHORT $LL23@asciilib_r
  00106	45 0f b6 1f	 movzx	 r11d, BYTE PTR [r15]
  0010a	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  0010f	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00114	4c 8d 63 ff	 lea	 r12, QWORD PTR [rbx-1]
$LN21@asciilib_r:
  00118	4d 8b c1	 mov	 r8, r9
  0011b	4d 2b c7	 sub	 r8, r15
  0011e	4c 03 c5	 add	 r8, rbp
$LL19@asciilib_r:
  00121	45 38 1c 29	 cmp	 BYTE PTR [r9+rbp], r11b
  00125	75 41		 jne	 SHORT $LN16@asciilib_r
  00127	49 8b d4	 mov	 rdx, r12
  0012a	4d 85 e4	 test	 r12, r12
  0012d	7e 18		 jle	 SHORT $LN89@asciilib_r
  0012f	4b 8d 0c 3c	 lea	 rcx, QWORD PTR [r12+r15]
$LL15@asciilib_r:
  00133	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00136	41 38 04 08	 cmp	 BYTE PTR [r8+rcx], al
  0013a	75 0b		 jne	 SHORT $LN89@asciilib_r
  0013c	48 ff ca	 dec	 rdx
  0013f	48 ff c9	 dec	 rcx
  00142	48 85 d2	 test	 rdx, rdx
  00145	7f ec		 jg	 SHORT $LL15@asciilib_r
$LN89@asciilib_r:
  00147	48 85 d2	 test	 rdx, rdx
  0014a	74 43		 je	 SHORT $LN83@asciilib_r
  0014c	4d 85 c9	 test	 r9, r9
  0014f	7e 0f		 jle	 SHORT $LN10@asciilib_r
  00151	41 0f b6 44 29
	ff		 movzx	 eax, BYTE PTR [r9+rbp-1]
  00157	83 e0 1f	 and	 eax, 31
  0015a	41 0f a3 c6	 bt	 r14d, eax
  0015e	73 1c		 jae	 SHORT $LN90@asciilib_r
$LN10@asciilib_r:
  00160	4d 2b cd	 sub	 r9, r13
  00163	4d 2b c5	 sub	 r8, r13
  00166	eb 1a		 jmp	 SHORT $LN18@asciilib_r
$LN16@asciilib_r:
  00168	4d 85 c9	 test	 r9, r9
  0016b	7e 15		 jle	 SHORT $LN18@asciilib_r
  0016d	41 0f b6 44 29
	ff		 movzx	 eax, BYTE PTR [r9+rbp-1]
  00173	83 e0 1f	 and	 eax, 31
  00176	41 0f a3 c6	 bt	 r14d, eax
  0017a	72 06		 jb	 SHORT $LN18@asciilib_r
$LN90@asciilib_r:
  0017c	4c 2b cb	 sub	 r9, rbx
  0017f	4c 2b c3	 sub	 r8, rbx
$LN18@asciilib_r:
  00182	49 ff c8	 dec	 r8
  00185	49 ff c9	 dec	 r9
  00188	79 97		 jns	 SHORT $LL19@asciilib_r
  0018a	e9 f8 fe ff ff	 jmp	 $LN1@asciilib_r
$LN83@asciilib_r:
  0018f	4d 8b d1	 mov	 r10, r9

; 40   : 
; 41   :     if (pos >= 0)

  00192	4d 85 c9	 test	 r9, r9
  00195	0f 88 ec fe ff
	ff		 js	 $LN1@asciilib_r

; 42   :         pos += offset;

  0019b	48 8b 44 24 50	 mov	 rax, QWORD PTR offset$[rsp]
  001a0	4d 8d 14 01	 lea	 r10, QWORD PTR [r9+rax]
  001a4	e9 de fe ff ff	 jmp	 $LN1@asciilib_r
asciilib_rfind ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$asciilib_find_slice DD imagerel asciilib_find_slice
	DD	imagerel asciilib_find_slice+75
	DD	imagerel $unwind$asciilib_find_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_find_slice DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT asciilib_find_slice
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
start$ = 96
end$ = 104
asciilib_find_slice PROC				; COMDAT

; 66   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	4c 8b d2	 mov	 r10, rdx

; 67   :     ADJUST_INDICES(start, end, str_len);

  00007	48 8b 54 24 68	 mov	 rdx, QWORD PTR end$[rsp]
  0000c	45 33 db	 xor	 r11d, r11d
  0000f	49 3b d2	 cmp	 rdx, r10
  00012	7e 05		 jle	 SHORT $LN6@asciilib_f@4
  00014	49 8b d2	 mov	 rdx, r10
  00017	eb 0c		 jmp	 SHORT $LN3@asciilib_f@4
$LN6@asciilib_f@4:
  00019	48 85 d2	 test	 rdx, rdx
  0001c	79 07		 jns	 SHORT $LN3@asciilib_f@4
  0001e	49 03 d2	 add	 rdx, r10
  00021	49 0f 48 d3	 cmovs	 rdx, r11
$LN3@asciilib_f@4:
  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0002a	48 85 c0	 test	 rax, rax
  0002d	79 07		 jns	 SHORT $LN1@asciilib_f@4
  0002f	49 03 c2	 add	 rax, r10
  00032	49 0f 48 c3	 cmovs	 rax, r11
$LN1@asciilib_f@4:

; 68   :     return STRINGLIB(find)(str + start, end - start, sub, sub_len, start);

  00036	48 2b d0	 sub	 rdx, rax
  00039	48 03 c8	 add	 rcx, rax
  0003c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00041	e8 00 00 00 00	 call	 asciilib_find

; 69   : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
asciilib_find_slice ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$asciilib_rfind_slice DD imagerel asciilib_rfind_slice
	DD	imagerel asciilib_rfind_slice+75
	DD	imagerel $unwind$asciilib_rfind_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_rfind_slice DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT asciilib_rfind_slice
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
start$ = 96
end$ = 104
asciilib_rfind_slice PROC				; COMDAT

; 75   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	4c 8b d2	 mov	 r10, rdx

; 76   :     ADJUST_INDICES(start, end, str_len);

  00007	48 8b 54 24 68	 mov	 rdx, QWORD PTR end$[rsp]
  0000c	45 33 db	 xor	 r11d, r11d
  0000f	49 3b d2	 cmp	 rdx, r10
  00012	7e 05		 jle	 SHORT $LN6@asciilib_r@2
  00014	49 8b d2	 mov	 rdx, r10
  00017	eb 0c		 jmp	 SHORT $LN3@asciilib_r@2
$LN6@asciilib_r@2:
  00019	48 85 d2	 test	 rdx, rdx
  0001c	79 07		 jns	 SHORT $LN3@asciilib_r@2
  0001e	49 03 d2	 add	 rdx, r10
  00021	49 0f 48 d3	 cmovs	 rdx, r11
$LN3@asciilib_r@2:
  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0002a	48 85 c0	 test	 rax, rax
  0002d	79 07		 jns	 SHORT $LN1@asciilib_r@2
  0002f	49 03 c2	 add	 rax, r10
  00032	49 0f 48 c3	 cmovs	 rax, r11
$LN1@asciilib_r@2:

; 77   :     return STRINGLIB(rfind)(str + start, end - start, sub, sub_len, start);

  00036	48 2b d0	 sub	 rdx, rax
  00039	48 03 c8	 add	 rcx, rax
  0003c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00041	e8 00 00 00 00	 call	 asciilib_rfind

; 78   : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
asciilib_rfind_slice ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\localeutil.h
_TEXT	ENDS
;	COMDAT asciilib_GroupGenerator_init
_TEXT	SEGMENT
self$ = 8
grouping$ = 16
asciilib_GroupGenerator_init PROC			; COMDAT

; 18   :     self->grouping = grouping;

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 19   :     self->i = 0;

  00003	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 20   :     self->previous = 0;

  0000b	c6 41 08 00	 mov	 BYTE PTR [rcx+8], 0

; 21   : }

  0000f	c3		 ret	 0
asciilib_GroupGenerator_init ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT asciilib_GroupGenerator_next
_TEXT	SEGMENT
self$ = 8
asciilib_GroupGenerator_next PROC			; COMDAT

; 27   :     /* Note that we don't really do much error checking here. If a
; 28   :        grouping string contains just CHAR_MAX, for example, then just
; 29   :        terminate the generator. That shouldn't happen, but at least we
; 30   :        fail gracefully. */
; 31   :     switch (self->grouping[self->i]) {

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00007	41 0f b6 14 00	 movzx	 edx, BYTE PTR [r8+rax]
  0000c	0f b6 c2	 movzx	 eax, dl
  0000f	84 d2		 test	 dl, dl
  00011	74 17		 je	 SHORT $LN3@asciilib_G
  00013	3c 7f		 cmp	 al, 127			; 0000007fH
  00015	74 10		 je	 SHORT $LN2@asciilib_G

; 37   :     default: {
; 38   :         char ch = self->grouping[self->i];
; 39   :         self->previous = ch;
; 40   :         self->i++;

  00017	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]
  0001b	88 51 08	 mov	 BYTE PTR [rcx+8], dl
  0001e	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 41   :         return (Py_ssize_t)ch;

  00022	48 0f be c2	 movsx	 rax, dl

; 42   :     }
; 43   :     }
; 44   : }

  00026	c3		 ret	 0
$LN2@asciilib_G:

; 34   :     case CHAR_MAX:
; 35   :         /* Stop the generator. */
; 36   :         return 0;

  00027	33 c0		 xor	 eax, eax

; 42   :     }
; 43   :     }
; 44   : }

  00029	c3		 ret	 0
$LN3@asciilib_G:

; 32   :     case 0:
; 33   :         return self->previous;

  0002a	48 0f be 41 08	 movsx	 rax, BYTE PTR [rcx+8]

; 42   :     }
; 43   :     }
; 44   : }

  0002f	c3		 ret	 0
asciilib_GroupGenerator_next ENDP
_TEXT	ENDS
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$asciilib_fill DD imagerel asciilib_fill
	DD	imagerel asciilib_fill+133
	DD	imagerel $unwind$asciilib_fill
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_fill DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT asciilib_fill
_TEXT	SEGMENT
digits_end$ = 48
buffer_end$ = 56
n_chars$ = 64
n_zeros$ = 72
thousands_sep$ = 80
thousands_sep_len$ = 88
asciilib_fill PROC					; COMDAT

; 52   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b da	 mov	 rbx, rdx

; 53   :     Py_ssize_t i;
; 54   : 
; 55   :     if (thousands_sep) {

  00017	48 8b 54 24 50	 mov	 rdx, QWORD PTR thousands_sep$[rsp]
  0001c	49 8b f9	 mov	 rdi, r9
  0001f	49 8b f0	 mov	 rsi, r8
  00022	48 8b e9	 mov	 rbp, rcx
  00025	48 85 d2	 test	 rdx, rdx
  00028	74 10		 je	 SHORT $LN4@asciilib_f@5

; 56   :         *buffer_end -= thousands_sep_len;

  0002a	4c 8b 44 24 58	 mov	 r8, QWORD PTR thousands_sep_len$[rsp]
  0002f	4c 29 03	 sub	 QWORD PTR [rbx], r8

; 57   : 
; 58   :         /* Copy the thousands_sep chars into the buffer. */
; 59   :         memcpy(*buffer_end, thousands_sep,
; 60   :                thousands_sep_len * STRINGLIB_SIZEOF_CHAR);

  00032	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00035	e8 00 00 00 00	 call	 memcpy
$LN4@asciilib_f@5:

; 61   :     }
; 62   : 
; 63   :     *buffer_end -= n_chars;

  0003a	48 29 33	 sub	 QWORD PTR [rbx], rsi

; 64   :     *digits_end -= n_chars;

  0003d	48 29 75 00	 sub	 QWORD PTR [rbp], rsi

; 65   :     memcpy(*buffer_end, *digits_end, n_chars * sizeof(STRINGLIB_CHAR));

  00041	48 8b 55 00	 mov	 rdx, QWORD PTR [rbp]
  00045	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00048	4c 8b c6	 mov	 r8, rsi
  0004b	e8 00 00 00 00	 call	 memcpy

; 66   : 
; 67   :     *buffer_end -= n_zeros;

  00050	48 29 3b	 sub	 QWORD PTR [rbx], rdi

; 68   :     for (i = 0; i < n_zeros; i++)

  00053	33 c9		 xor	 ecx, ecx
  00055	48 85 ff	 test	 rdi, rdi
  00058	7e 16		 jle	 SHORT $LN1@asciilib_f@5
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL3@asciilib_f@5:

; 69   :         (*buffer_end)[i] = '0';

  00060	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00063	48 ff c1	 inc	 rcx
  00066	c6 44 01 ff 30	 mov	 BYTE PTR [rcx+rax-1], 48 ; 00000030H
  0006b	48 3b cf	 cmp	 rcx, rdi
  0006e	7c f0		 jl	 SHORT $LL3@asciilib_f@5
$LN1@asciilib_f@5:

; 70   : }

  00070	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00075	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0007a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
asciilib_fill ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$asciilib_InsertThousandsGrouping DD imagerel asciilib_InsertThousandsGrouping
	DD	imagerel asciilib_InsertThousandsGrouping+461
	DD	imagerel $unwind$asciilib_InsertThousandsGrouping
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_InsertThousandsGrouping DD 0b6f01H
	DD	0a746fH
	DD	013546aH
	DD	0f00fa213H
	DD	0d00be00dH
	DD	06007c009H
	DD	03006H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT asciilib_InsertThousandsGrouping
_TEXT	SEGMENT
digits_end$ = 48
groupgen$ = 56
buffer$ = 144
n_buffer$ = 152
digits$ = 160
buffer_end$ = 168
n_digits$ = 168
min_width$ = 176
grouping$ = 184
thousands_sep$ = 192
thousands_sep_len$ = 200
asciilib_InsertThousandsGrouping PROC			; COMDAT

; 112  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	56		 push	 rsi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	41 57		 push	 r15
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 113  :     Py_ssize_t count = 0;

  00013	45 33 e4	 xor	 r12d, r12d
  00016	48 8b c2	 mov	 rax, rdx

; 114  :     Py_ssize_t n_zeros;
; 115  :     int loop_broken = 0;
; 116  :     int use_separator = 0; /* First time through, don't append the
; 117  :                               separator. They only go between
; 118  :                               groups. */
; 119  :     STRINGLIB_CHAR *buffer_end = NULL;
; 120  :     STRINGLIB_CHAR *digits_end = NULL;
; 121  :     Py_ssize_t l;
; 122  :     Py_ssize_t n_chars;
; 123  :     Py_ssize_t remaining = n_digits; /* Number of chars remaining to
; 124  :                                         be looked at */
; 125  :     /* A generator that returns all of the grouping widths, until it
; 126  :        returns 0. */
; 127  :     STRINGLIB(GroupGenerator) groupgen;
; 128  :     STRINGLIB(GroupGenerator_init)(&groupgen, grouping);

  00019	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR grouping$[rsp]
  00021	4c 8b d9	 mov	 r11, rcx
  00024	48 8d 4c 24 38	 lea	 rcx, QWORD PTR groupgen$[rsp]
  00029	49 8b f1	 mov	 rsi, r9
  0002c	45 8b fc	 mov	 r15d, r12d
  0002f	45 8b d4	 mov	 r10d, r12d
  00032	4c 89 a4 24 a8
	00 00 00	 mov	 QWORD PTR buffer_end$[rsp], r12
  0003a	4c 89 64 24 30	 mov	 QWORD PTR digits_end$[rsp], r12
  0003f	e8 00 00 00 00	 call	 asciilib_GroupGenerator_init

; 129  : 
; 130  :     if (buffer) {

  00044	4d 85 db	 test	 r11, r11
  00047	74 14		 je	 SHORT $LN26@asciilib_I

; 131  :         buffer_end = buffer + n_buffer;

  00049	49 03 c3	 add	 rax, r11
  0004c	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR buffer_end$[rsp], rax

; 132  :         digits_end = digits + n_digits;

  00054	4b 8d 04 08	 lea	 rax, QWORD PTR [r8+r9]
  00058	48 89 44 24 30	 mov	 QWORD PTR digits_end$[rsp], rax
$LN26@asciilib_I:

; 133  :     }
; 134  : 
; 135  :     while ((l = STRINGLIB(GroupGenerator_next)(&groupgen)) > 0) {

  0005d	48 8d 4c 24 38	 lea	 rcx, QWORD PTR groupgen$[rsp]
  00062	48 89 ac 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rbp
  0006a	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0006f	e8 00 00 00 00	 call	 asciilib_GroupGenerator_next
  00074	4c 8b b4 24 c8
	00 00 00	 mov	 r14, QWORD PTR thousands_sep_len$[rsp]
  0007c	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR min_width$[rsp]
  00084	41 bd 01 00 00
	00		 mov	 r13d, 1
$LN35@asciilib_I:
  0008a	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR thousands_sep$[rsp]
  00092	48 8b d8	 mov	 rbx, rax
  00095	48 85 c0	 test	 rax, rax
  00098	0f 8e ac 00 00
	00		 jle	 $LN29@asciilib_I

; 136  :         l = Py_MIN(l, Py_MAX(Py_MAX(remaining, min_width), 1));

  0009e	48 3b f7	 cmp	 rsi, rdi
  000a1	49 8b c5	 mov	 rax, r13
  000a4	48 8b cf	 mov	 rcx, rdi
  000a7	48 0f 4f ce	 cmovg	 rcx, rsi
  000ab	48 3b c8	 cmp	 rcx, rax
  000ae	48 0f 4f c1	 cmovg	 rax, rcx
  000b2	48 3b d8	 cmp	 rbx, rax
  000b5	7e 0a		 jle	 SHORT $LN12@asciilib_I
  000b7	49 8b dd	 mov	 rbx, r13
  000ba	48 3b cb	 cmp	 rcx, rbx
  000bd	48 0f 4f d9	 cmovg	 rbx, rcx
$LN12@asciilib_I:

; 137  :         n_zeros = Py_MAX(0, l - remaining);

  000c1	4c 8b cb	 mov	 r9, rbx

; 138  :         n_chars = Py_MAX(0, Py_MIN(remaining, l));

  000c4	48 8b ee	 mov	 rbp, rsi

; 139  : 
; 140  :         /* Use n_zero zero's and n_chars chars */
; 141  : 
; 142  :         /* Count only, don't do anything. */
; 143  :         count += (use_separator ? thousands_sep_len : 0) + n_zeros + n_chars;

  000c7	49 8b c4	 mov	 rax, r12
  000ca	4c 2b ce	 sub	 r9, rsi
  000cd	4d 0f 48 cc	 cmovs	 r9, r12
  000d1	48 3b f3	 cmp	 rsi, rbx
  000d4	48 0f 4f eb	 cmovg	 rbp, rbx
  000d8	48 85 ed	 test	 rbp, rbp
  000db	49 0f 48 ec	 cmovs	 rbp, r12
  000df	45 85 d2	 test	 r10d, r10d
  000e2	49 0f 45 c6	 cmovne	 rax, r14
  000e6	48 03 c5	 add	 rax, rbp
  000e9	49 03 c1	 add	 rax, r9
  000ec	4c 03 f8	 add	 r15, rax

; 144  : 
; 145  :         if (buffer) {

  000ef	4d 85 db	 test	 r11, r11
  000f2	74 31		 je	 SHORT $LN4@asciilib_I

; 146  :             /* Copy into the output buffer. */
; 147  :             STRINGLIB(fill)(&digits_end, &buffer_end, n_chars, n_zeros,
; 148  :                  use_separator ? thousands_sep : NULL, thousands_sep_len);

  000f4	45 85 d2	 test	 r10d, r10d
  000f7	49 8b c4	 mov	 rax, r12
  000fa	48 8d 4c 24 30	 lea	 rcx, QWORD PTR digits_end$[rsp]
  000ff	48 0f 45 c2	 cmovne	 rax, rdx
  00103	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR buffer_end$[rsp]
  0010b	4c 8b c5	 mov	 r8, rbp
  0010e	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00113	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00118	e8 00 00 00 00	 call	 asciilib_fill
  0011d	4c 8b 9c 24 90
	00 00 00	 mov	 r11, QWORD PTR buffer$[rsp]
$LN4@asciilib_I:

; 149  :         }
; 150  : 
; 151  :         /* Use a separator next time. */
; 152  :         use_separator = 1;
; 153  : 
; 154  :         remaining -= n_chars;

  00125	48 2b f5	 sub	 rsi, rbp

; 155  :         min_width -= l;

  00128	48 2b fb	 sub	 rdi, rbx
  0012b	45 8b d5	 mov	 r10d, r13d

; 156  : 
; 157  :         if (remaining <= 0 && min_width <= 0) {

  0012e	48 85 f6	 test	 rsi, rsi
  00131	7f 05		 jg	 SHORT $LN3@asciilib_I
  00133	48 85 ff	 test	 rdi, rdi
  00136	7e 76		 jle	 SHORT $LN30@asciilib_I
$LN3@asciilib_I:

; 133  :     }
; 134  : 
; 135  :     while ((l = STRINGLIB(GroupGenerator_next)(&groupgen)) > 0) {

  00138	48 8d 4c 24 38	 lea	 rcx, QWORD PTR groupgen$[rsp]

; 158  :             loop_broken = 1;
; 159  :             break;
; 160  :         }
; 161  :         min_width -= thousands_sep_len;

  0013d	49 2b fe	 sub	 rdi, r14
  00140	e8 00 00 00 00	 call	 asciilib_GroupGenerator_next
  00145	e9 40 ff ff ff	 jmp	 $LN35@asciilib_I
$LN29@asciilib_I:

; 162  :     }
; 163  :     if (!loop_broken) {
; 164  :         /* We left the loop without using a break statement. */
; 165  : 
; 166  :         l = Py_MAX(Py_MAX(remaining, min_width), 1);

  0014a	48 3b f7	 cmp	 rsi, rdi

; 167  :         n_zeros = Py_MAX(0, l - remaining);
; 168  :         n_chars = Py_MAX(0, Py_MIN(remaining, l));
; 169  : 
; 170  :         /* Use n_zero zero's and n_chars chars */
; 171  :         count += (use_separator ? thousands_sep_len : 0) + n_zeros + n_chars;

  0014d	49 8b c4	 mov	 rax, r12
  00150	48 0f 4f fe	 cmovg	 rdi, rsi
  00154	49 3b fd	 cmp	 rdi, r13
  00157	4c 0f 4f ef	 cmovg	 r13, rdi
  0015b	4d 8b cd	 mov	 r9, r13
  0015e	4c 2b ce	 sub	 r9, rsi
  00161	4d 0f 48 cc	 cmovs	 r9, r12
  00165	49 3b f5	 cmp	 rsi, r13
  00168	49 0f 4f f5	 cmovg	 rsi, r13
  0016c	48 85 f6	 test	 rsi, rsi
  0016f	49 0f 48 f4	 cmovs	 rsi, r12
  00173	45 85 d2	 test	 r10d, r10d
  00176	49 0f 45 c6	 cmovne	 rax, r14
  0017a	48 03 c6	 add	 rax, rsi
  0017d	49 03 c1	 add	 rax, r9
  00180	4c 03 f8	 add	 r15, rax

; 172  :         if (buffer) {

  00183	4d 85 db	 test	 r11, r11
  00186	74 26		 je	 SHORT $LN30@asciilib_I

; 173  :             /* Copy into the output buffer. */
; 174  :             STRINGLIB(fill)(&digits_end, &buffer_end, n_chars, n_zeros,
; 175  :                  use_separator ? thousands_sep : NULL, thousands_sep_len);

  00188	45 85 d2	 test	 r10d, r10d
  0018b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR digits_end$[rsp]
  00190	4c 8b c6	 mov	 r8, rsi
  00193	4c 0f 45 e2	 cmovne	 r12, rdx
  00197	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR buffer_end$[rsp]
  0019f	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  001a4	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  001a9	e8 00 00 00 00	 call	 asciilib_fill
$LN30@asciilib_I:

; 176  :         }
; 177  :     }
; 178  :     return count;

  001ae	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  001b3	48 8b ac 24 98
	00 00 00	 mov	 rbp, QWORD PTR [rsp+152]
  001bb	49 8b c7	 mov	 rax, r15

; 179  : }

  001be	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001c2	41 5f		 pop	 r15
  001c4	41 5e		 pop	 r14
  001c6	41 5d		 pop	 r13
  001c8	41 5c		 pop	 r12
  001ca	5e		 pop	 rsi
  001cb	5b		 pop	 rbx
  001cc	c3		 ret	 0
asciilib_InsertThousandsGrouping ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs1lib_fastsearch_memchr_1char DD imagerel ucs1lib_fastsearch_memchr_1char
	DD	imagerel ucs1lib_fastsearch_memchr_1char+72
	DD	imagerel $unwind$ucs1lib_fastsearch_memchr_1char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_fastsearch_memchr_1char DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs1lib_fastsearch_memchr_1char
_TEXT	SEGMENT
s$ = 48
n$ = 56
needle$ = 64
mode$ = 72
ucs1lib_fastsearch_memchr_1char PROC			; COMDAT

; 40   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	41 0f b6 c0	 movzx	 eax, r8b
  0000a	48 8b d9	 mov	 rbx, rcx

; 41   :     if (mode == FAST_SEARCH) {

  0000d	41 83 f9 01	 cmp	 r9d, 1
  00011	75 2d		 jne	 SHORT $LN6@ucs1lib_fa

; 42   :         const STRINGLIB_CHAR *ptr = s;
; 43   :         const STRINGLIB_CHAR *e = s + n;

  00013	4c 8d 04 11	 lea	 r8, QWORD PTR [rcx+rdx]

; 44   :         while (ptr < e) {

  00017	49 3b c8	 cmp	 rcx, r8
  0001a	73 11		 jae	 SHORT $LN4@ucs1lib_fa

; 45   :             void *candidate = memchr((const void *) ptr, needle, (e - ptr) * sizeof(STRINGLIB_CHAR));

  0001c	4c 2b c1	 sub	 r8, rcx
  0001f	0f b6 d0	 movzx	 edx, al
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr

; 46   :             if (candidate == NULL)

  00028	48 85 c0	 test	 rax, rax
  0002b	75 0a		 jne	 SHORT $LN3@ucs1lib_fa
$LN4@ucs1lib_fa:

; 47   :                 return -1;

  0002d	48 83 c8 ff	 or	 rax, -1

; 78   :     }
; 79   : 
; 80   : #undef DO_MEMCHR
; 81   : }

  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5b		 pop	 rbx
  00036	c3		 ret	 0
$LN3@ucs1lib_fa:

; 48   :             ptr = (const STRINGLIB_CHAR *) _Py_ALIGN_DOWN(candidate, sizeof(STRINGLIB_CHAR));
; 49   :             if (sizeof(STRINGLIB_CHAR) == 1 || *ptr == ch)
; 50   :                 return (ptr - s);

  00037	48 2b c3	 sub	 rax, rbx

; 78   :     }
; 79   : 
; 80   : #undef DO_MEMCHR
; 81   : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	c3		 ret	 0
$LN6@ucs1lib_fa:

; 51   :             /* False positive */
; 52   :             ptr++;
; 53   :         }
; 54   :         return -1;
; 55   :     }
; 56   : #ifdef HAVE_MEMRCHR
; 57   :     /* memrchr() is a GNU extension, available since glibc 2.1.91.
; 58   :        it doesn't seem as optimized as memchr(), but is still quite
; 59   :        faster than our hand-written loop in FASTSEARCH below */
; 60   :     else if (mode == FAST_RSEARCH) {
; 61   :         while (n > 0) {
; 62   :             const STRINGLIB_CHAR *found;
; 63   :             void *candidate = memrchr((const void *) s, needle, n * sizeof(STRINGLIB_CHAR));
; 64   :             if (candidate == NULL)
; 65   :                 return -1;
; 66   :             found = (const STRINGLIB_CHAR *) _Py_ALIGN_DOWN(candidate, sizeof(STRINGLIB_CHAR));
; 67   :             n = found - s;
; 68   :             if (sizeof(STRINGLIB_CHAR) == 1 || *found == ch)
; 69   :                 return n;
; 70   :             /* False positive */
; 71   :         }
; 72   :         return -1;
; 73   :     }
; 74   : #endif
; 75   :     else {
; 76   :         assert(0); /* Should never get here */
; 77   :         return 0;

  00040	33 c0		 xor	 eax, eax

; 78   :     }
; 79   : 
; 80   : #undef DO_MEMCHR
; 81   : }

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5b		 pop	 rbx
  00047	c3		 ret	 0
ucs1lib_fastsearch_memchr_1char ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs1lib_fastsearch DD imagerel ucs1lib_fastsearch
	DD	imagerel ucs1lib_fastsearch+346
	DD	imagerel $unwind$ucs1lib_fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ucs1lib_fastsearch DD imagerel ucs1lib_fastsearch+346
	DD	imagerel ucs1lib_fastsearch+977
	DD	imagerel $chain$2$ucs1lib_fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ucs1lib_fastsearch DD imagerel ucs1lib_fastsearch+977
	DD	imagerel ucs1lib_fastsearch+991
	DD	imagerel $chain$3$ucs1lib_fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ucs1lib_fastsearch DD imagerel ucs1lib_fastsearch+991
	DD	imagerel ucs1lib_fastsearch+996
	DD	imagerel $chain$4$ucs1lib_fastsearch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ucs1lib_fastsearch DD 060021H
	DD	067400H
	DD	076400H
	DD	0e5400H
	DD	imagerel ucs1lib_fastsearch
	DD	imagerel ucs1lib_fastsearch+346
	DD	imagerel $unwind$ucs1lib_fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ucs1lib_fastsearch DD 021H
	DD	imagerel ucs1lib_fastsearch
	DD	imagerel ucs1lib_fastsearch+346
	DD	imagerel $unwind$ucs1lib_fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ucs1lib_fastsearch DD 061321H
	DD	067413H
	DD	07640aH
	DD	0e5405H
	DD	imagerel ucs1lib_fastsearch
	DD	imagerel ucs1lib_fastsearch+346
	DD	imagerel $unwind$ucs1lib_fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_fastsearch DD 061201H
	DD	0f00e7212H
	DD	0d00ae00cH
	DD	03006c008H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs1lib_fastsearch
_TEXT	SEGMENT
s$ = 112
mask$1$ = 120
n$ = 120
p$ = 128
skip$1$ = 136
m$ = 136
maxcount$ = 144
mode$ = 152
ucs1lib_fastsearch PROC					; COMDAT

; 87   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	53		 push	 rbx
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	41 56		 push	 r14
  0000c	41 57		 push	 r15
  0000e	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00012	4d 8b e9	 mov	 r13, r9

; 88   :     unsigned long mask;
; 89   :     Py_ssize_t skip, count = 0;

  00015	45 33 db	 xor	 r11d, r11d

; 90   :     Py_ssize_t i, j, mlast, w;
; 91   : 
; 92   :     w = n - m;

  00018	4c 8b d2	 mov	 r10, rdx
  0001b	4d 2b d5	 sub	 r10, r13
  0001e	4d 8b f8	 mov	 r15, r8
  00021	48 8b d9	 mov	 rbx, rcx
  00024	45 8b cb	 mov	 r9d, r11d

; 93   : 
; 94   :     if (w < 0 || (mode == FAST_COUNT && maxcount == 0))

  00027	0f 88 1b 01 00
	00		 js	 $LN41@ucs1lib_fa@2
  0002d	44 8b b4 24 98
	00 00 00	 mov	 r14d, DWORD PTR mode$[rsp]
  00035	4c 8b a4 24 90
	00 00 00	 mov	 r12, QWORD PTR maxcount$[rsp]
  0003d	45 85 f6	 test	 r14d, r14d
  00040	75 09		 jne	 SHORT $LN61@ucs1lib_fa@2
  00042	4d 85 e4	 test	 r12, r12
  00045	0f 84 fd 00 00
	00		 je	 $LN41@ucs1lib_fa@2
$LN61@ucs1lib_fa@2:

; 95   :         return -1;
; 96   : 
; 97   :     /* look for special cases */
; 98   :     if (m <= 1) {

  0004b	49 83 fd 01	 cmp	 r13, 1
  0004f	0f 8f 05 01 00
	00		 jg	 $LN59@ucs1lib_fa@2

; 99   :         if (m <= 0)

  00055	4d 85 ed	 test	 r13, r13

; 100  :             return -1;

  00058	0f 8e ea 00 00
	00		 jle	 $LN41@ucs1lib_fa@2

; 101  :         /* use special case for 1-character strings */
; 102  :         if (n > 10 && (mode == FAST_SEARCH
; 103  : #ifdef HAVE_MEMRCHR
; 104  :                     || mode == FAST_RSEARCH
; 105  : #endif
; 106  :                     )) {

  0005e	48 83 fa 0a	 cmp	 rdx, 10
  00062	7e 3a		 jle	 SHORT $LN57@ucs1lib_fa@2
  00064	41 83 fe 01	 cmp	 r14d, 1
  00068	75 34		 jne	 SHORT $LN57@ucs1lib_fa@2

; 107  :             /* use memchr if we can choose a needle without two many likely
; 108  :                false positives */
; 109  :             unsigned char needle;
; 110  :             needle = p[0] & 0xff;
; 111  : #if STRINGLIB_SIZEOF_CHAR > 1
; 112  :             /* If looking for a multiple of 256, we'd have too
; 113  :                many false positives looking for the '\0' byte in UCS2
; 114  :                and UCS4 representations. */
; 115  :             if (needle != 0)
; 116  : #endif
; 117  :                 return STRINGLIB(fastsearch_memchr_1char)
; 118  :                        (s, n, p[0], needle, maxcount, mode);

  0006a	4c 8d 04 11	 lea	 r8, QWORD PTR [rcx+rdx]
  0006e	49 3b c8	 cmp	 rcx, r8
  00071	0f 83 d1 00 00
	00		 jae	 $LN41@ucs1lib_fa@2
  00077	41 0f b6 17	 movzx	 edx, BYTE PTR [r15]
  0007b	4c 2b c1	 sub	 r8, rcx
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00084	48 85 c0	 test	 rax, rax
  00087	0f 84 bb 00 00
	00		 je	 $LN41@ucs1lib_fa@2
  0008d	48 2b c3	 sub	 rax, rbx

; 223  : }

  00090	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00094	41 5f		 pop	 r15
  00096	41 5e		 pop	 r14
  00098	41 5d		 pop	 r13
  0009a	41 5c		 pop	 r12
  0009c	5b		 pop	 rbx
  0009d	c3		 ret	 0
$LN57@ucs1lib_fa@2:

; 119  :         }
; 120  :         if (mode == FAST_COUNT) {

  0009e	45 85 f6	 test	 r14d, r14d
  000a1	75 45		 jne	 SHORT $LN56@ucs1lib_fa@2

; 121  :             for (i = 0; i < n; i++)

  000a3	48 85 d2	 test	 rdx, rdx
  000a6	7e 1e		 jle	 SHORT $LN99@ucs1lib_fa@2
  000a8	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  000ac	0f 1f 40 00	 npad	 4
$LL55@ucs1lib_fa@2:

; 122  :                 if (s[i] == p[0]) {

  000b0	41 38 04 0b	 cmp	 BYTE PTR [r11+rcx], al
  000b4	75 08		 jne	 SHORT $LN54@ucs1lib_fa@2

; 123  :                     count++;

  000b6	49 ff c1	 inc	 r9

; 124  :                     if (count == maxcount)

  000b9	4d 3b cc	 cmp	 r9, r12
  000bc	74 19		 je	 SHORT $LN81@ucs1lib_fa@2
$LN54@ucs1lib_fa@2:

; 121  :             for (i = 0; i < n; i++)

  000be	49 ff c3	 inc	 r11
  000c1	4c 3b da	 cmp	 r11, rdx
  000c4	7c ea		 jl	 SHORT $LL55@ucs1lib_fa@2
$LN99@ucs1lib_fa@2:

; 126  :                 }
; 127  :             return count;

  000c6	49 8b c1	 mov	 rax, r9

; 223  : }

  000c9	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000cd	41 5f		 pop	 r15
  000cf	41 5e		 pop	 r14
  000d1	41 5d		 pop	 r13
  000d3	41 5c		 pop	 r12
  000d5	5b		 pop	 rbx
  000d6	c3		 ret	 0
$LN81@ucs1lib_fa@2:

; 125  :                         return maxcount;

  000d7	49 8b c4	 mov	 rax, r12

; 223  : }

  000da	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000de	41 5f		 pop	 r15
  000e0	41 5e		 pop	 r14
  000e2	41 5d		 pop	 r13
  000e4	41 5c		 pop	 r12
  000e6	5b		 pop	 rbx
  000e7	c3		 ret	 0
$LN56@ucs1lib_fa@2:

; 128  :         } else if (mode == FAST_SEARCH) {

  000e8	41 83 fe 01	 cmp	 r14d, 1
  000ec	75 3a		 jne	 SHORT $LN49@ucs1lib_fa@2

; 129  :             for (i = 0; i < n; i++)

  000ee	48 85 d2	 test	 rdx, rdx
  000f1	7e 55		 jle	 SHORT $LN41@ucs1lib_fa@2
  000f3	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
$LL48@ucs1lib_fa@2:

; 130  :                 if (s[i] == p[0])

  000f7	41 38 04 0b	 cmp	 BYTE PTR [r11+rcx], al
  000fb	74 1a		 je	 SHORT $LN82@ucs1lib_fa@2

; 129  :             for (i = 0; i < n; i++)

  000fd	49 ff c3	 inc	 r11
  00100	4c 3b da	 cmp	 r11, rdx
  00103	7c f2		 jl	 SHORT $LL48@ucs1lib_fa@2

; 135  :                     return i;
; 136  :         }
; 137  :         return -1;

  00105	48 83 c8 ff	 or	 rax, -1

; 223  : }

  00109	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0010d	41 5f		 pop	 r15
  0010f	41 5e		 pop	 r14
  00111	41 5d		 pop	 r13
  00113	41 5c		 pop	 r12
  00115	5b		 pop	 rbx
  00116	c3		 ret	 0
$LN82@ucs1lib_fa@2:

; 131  :                     return i;

  00117	49 8b c3	 mov	 rax, r11

; 223  : }

  0011a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0011e	41 5f		 pop	 r15
  00120	41 5e		 pop	 r14
  00122	41 5d		 pop	 r13
  00124	41 5c		 pop	 r12
  00126	5b		 pop	 rbx
  00127	c3		 ret	 0
$LN49@ucs1lib_fa@2:

; 132  :         } else {    /* FAST_RSEARCH */
; 133  :             for (i = n - 1; i > -1; i--)

  00128	48 8d 42 ff	 lea	 rax, QWORD PTR [rdx-1]
  0012c	48 83 f8 ff	 cmp	 rax, -1
  00130	7e 16		 jle	 SHORT $LN41@ucs1lib_fa@2
  00132	41 0f b6 08	 movzx	 ecx, BYTE PTR [r8]
$LL43@ucs1lib_fa@2:

; 134  :                 if (s[i] == p[0])

  00136	38 0c 18	 cmp	 BYTE PTR [rax+rbx], cl
  00139	0f 84 92 02 00
	00		 je	 $LN62@ucs1lib_fa@2

; 132  :         } else {    /* FAST_RSEARCH */
; 133  :             for (i = n - 1; i > -1; i--)

  0013f	48 ff c8	 dec	 rax
  00142	48 83 f8 ff	 cmp	 rax, -1
  00146	7f ee		 jg	 SHORT $LL43@ucs1lib_fa@2
$LN41@ucs1lib_fa@2:

; 135  :                     return i;
; 136  :         }
; 137  :         return -1;

  00148	48 83 c8 ff	 or	 rax, -1

; 223  : }

  0014c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00150	41 5f		 pop	 r15
  00152	41 5e		 pop	 r14
  00154	41 5d		 pop	 r13
  00156	41 5c		 pop	 r12
  00158	5b		 pop	 rbx
  00159	c3		 ret	 0
$LN59@ucs1lib_fa@2:
  0015a	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  0015f	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi

; 138  :     }
; 139  : 
; 140  :     mlast = m - 1;
; 141  :     skip = mlast - 1;
; 142  :     mask = 0;
; 143  : 
; 144  :     if (mode != FAST_RSEARCH) {

  00164	48 83 cd ff	 or	 rbp, -1
  00168	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0016d	49 8d 7d ff	 lea	 rdi, QWORD PTR [r13-1]
  00171	45 8b c3	 mov	 r8d, r11d
  00174	48 8d 47 ff	 lea	 rax, QWORD PTR [rdi-1]

; 145  : 
; 146  :         /* create compressed boyer-moore delta 1 table */
; 147  : 
; 148  :         /* process pattern[:-1] */
; 149  :         for (i = 0; i < mlast; i++) {

  00178	8d 75 02	 lea	 esi, QWORD PTR [rbp+2]
  0017b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR skip$1$[rsp], rax
  00183	41 83 fe 02	 cmp	 r14d, 2
  00187	0f 84 5b 01 00
	00		 je	 $LN39@ucs1lib_fa@2
  0018d	48 85 ff	 test	 rdi, rdi
  00190	7e 75		 jle	 SHORT $LN36@ucs1lib_fa@2
  00192	46 0f b6 3c 3f	 movzx	 r15d, BYTE PTR [rdi+r15]
  00197	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR p$[rsp]
  0019f	4c 8d 4f ff	 lea	 r9, QWORD PTR [rdi-1]
  001a3	4c 8b f7	 mov	 r14, rdi
  001a6	4d 8b e1	 mov	 r12, r9
  001a9	41 8b fb	 mov	 edi, r11d
  001ac	0f 1f 40 00	 npad	 4
$LL38@ucs1lib_fa@2:

; 150  :             STRINGLIB_BLOOM_ADD(mask, p[i]);

  001b0	44 0f b6 45 00	 movzx	 r8d, BYTE PTR [rbp]
  001b5	8b d6		 mov	 edx, esi
  001b7	41 8b c8	 mov	 ecx, r8d
  001ba	83 e1 1f	 and	 ecx, 31
  001bd	d3 e2		 shl	 edx, cl
  001bf	0b fa		 or	 edi, edx

; 151  :             if (p[i] == p[mlast])

  001c1	45 3a c7	 cmp	 r8b, r15b
  001c4	4d 0f 44 cc	 cmove	 r9, r12
  001c8	48 ff c5	 inc	 rbp
  001cb	49 ff cc	 dec	 r12
  001ce	49 ff ce	 dec	 r14
  001d1	75 dd		 jne	 SHORT $LL38@ucs1lib_fa@2
  001d3	4c 8b a4 24 90
	00 00 00	 mov	 r12, QWORD PTR maxcount$[rsp]
  001db	44 8b b4 24 98
	00 00 00	 mov	 r14d, DWORD PTR mode$[rsp]
  001e3	4c 8b bc 24 80
	00 00 00	 mov	 r15, QWORD PTR p$[rsp]
  001eb	89 7c 24 78	 mov	 DWORD PTR mask$1$[rsp], edi
  001ef	4c 89 8c 24 88
	00 00 00	 mov	 QWORD PTR skip$1$[rsp], r9
  001f7	48 83 cd ff	 or	 rbp, -1
  001fb	44 8b 44 24 78	 mov	 r8d, DWORD PTR mask$1$[rsp]
  00200	4d 8b cb	 mov	 r9, r11
  00203	49 8d 7d ff	 lea	 rdi, QWORD PTR [r13-1]
$LN36@ucs1lib_fa@2:

; 152  :                 skip = mlast - i - 1;
; 153  :         }
; 154  :         /* process pattern[-1] outside the loop */
; 155  :         STRINGLIB_BLOOM_ADD(mask, p[mlast]);

  00207	42 0f b6 04 3f	 movzx	 eax, BYTE PTR [rdi+r15]

; 156  : 
; 157  :         for (i = 0; i <= w; i++) {

  0020c	49 8b d3	 mov	 rdx, r11
  0020f	83 e0 1f	 and	 eax, 31
  00212	0f b6 c8	 movzx	 ecx, al
  00215	d3 e6		 shl	 esi, cl
  00217	44 0b c6	 or	 r8d, esi
  0021a	44 89 44 24 78	 mov	 DWORD PTR mask$1$[rsp], r8d
  0021f	4d 85 d2	 test	 r10, r10
  00222	0f 88 9f 00 00
	00		 js	 $LN100@ucs1lib_fa@2
  00228	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR p$[rsp]
  00230	4e 8d 3c 2b	 lea	 r15, QWORD PTR [rbx+r13]
$LN108@ucs1lib_fa@2:
  00234	42 0f b6 44 2e
	ff		 movzx	 eax, BYTE PTR [rsi+r13-1]

; 158  :             /* note: using mlast in the skip path slows things down on x86 */
; 159  :             if (s[i+m-1] == p[m-1]) {

  0023a	41 38 44 17 ff	 cmp	 BYTE PTR [r15+rdx-1], al
  0023f	75 69		 jne	 SHORT $LN31@ucs1lib_fa@2

; 160  :                 /* candidate match */
; 161  :                 for (j = 0; j < mlast; j++)

  00241	4d 8b c3	 mov	 r8, r11
  00244	48 85 ff	 test	 rdi, rdi
  00247	7e 28		 jle	 SHORT $LN84@ucs1lib_fa@2
  00249	48 8b c2	 mov	 rax, rdx
  0024c	48 8b ce	 mov	 rcx, rsi
  0024f	48 2b c6	 sub	 rax, rsi
  00252	48 8d 34 18	 lea	 rsi, QWORD PTR [rax+rbx]
$LL30@ucs1lib_fa@2:

; 162  :                     if (s[i+j] != p[j])

  00256	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00259	38 04 0e	 cmp	 BYTE PTR [rsi+rcx], al
  0025c	75 0b		 jne	 SHORT $LN102@ucs1lib_fa@2

; 160  :                 /* candidate match */
; 161  :                 for (j = 0; j < mlast; j++)

  0025e	49 ff c0	 inc	 r8
  00261	48 ff c1	 inc	 rcx
  00264	4c 3b c7	 cmp	 r8, rdi
  00267	7c ed		 jl	 SHORT $LL30@ucs1lib_fa@2
$LN102@ucs1lib_fa@2:
  00269	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR p$[rsp]
$LN84@ucs1lib_fa@2:

; 163  :                         break;
; 164  :                 if (j == mlast) {

  00271	4c 3b c7	 cmp	 r8, rdi
  00274	75 17		 jne	 SHORT $LN26@ucs1lib_fa@2

; 165  :                     /* got a match! */
; 166  :                     if (mode != FAST_COUNT)

  00276	45 85 f6	 test	 r14d, r14d
  00279	75 65		 jne	 SHORT $LN85@ucs1lib_fa@2

; 168  :                     count++;

  0027b	49 ff c1	 inc	 r9

; 169  :                     if (count == maxcount)

  0027e	4d 3b cc	 cmp	 r9, r12
  00281	74 55		 je	 SHORT $LN86@ucs1lib_fa@2

; 171  :                     i = i + mlast;
; 172  :                     continue;

  00283	44 8b 44 24 78	 mov	 r8d, DWORD PTR mask$1$[rsp]
  00288	48 03 d7	 add	 rdx, rdi
  0028b	eb 2e		 jmp	 SHORT $LN33@ucs1lib_fa@2
$LN26@ucs1lib_fa@2:

; 173  :                 }
; 174  :                 /* miss: check if next character is part of pattern */
; 175  :                 if (!STRINGLIB_BLOOM(mask, s[i+m]))

  0028d	41 0f b6 04 17	 movzx	 eax, BYTE PTR [r15+rdx]
  00292	44 8b 44 24 78	 mov	 r8d, DWORD PTR mask$1$[rsp]
  00297	83 e0 1f	 and	 eax, 31
  0029a	41 0f a3 c0	 bt	 r8d, eax

; 176  :                     i = i + m;
; 177  :                 else

  0029e	73 18		 jae	 SHORT $LN107@ucs1lib_fa@2

; 178  :                     i = i + skip;

  002a0	48 03 94 24 88
	00 00 00	 add	 rdx, QWORD PTR skip$1$[rsp]

; 179  :             } else {

  002a8	eb 11		 jmp	 SHORT $LN33@ucs1lib_fa@2
$LN31@ucs1lib_fa@2:

; 180  :                 /* skip: check if next character is part of pattern */
; 181  :                 if (!STRINGLIB_BLOOM(mask, s[i+m]))

  002aa	41 0f b6 04 17	 movzx	 eax, BYTE PTR [r15+rdx]
  002af	83 e0 1f	 and	 eax, 31
  002b2	41 0f a3 c0	 bt	 r8d, eax
  002b6	72 03		 jb	 SHORT $LN33@ucs1lib_fa@2
$LN107@ucs1lib_fa@2:

; 182  :                     i = i + m;

  002b8	49 03 d5	 add	 rdx, r13
$LN33@ucs1lib_fa@2:

; 156  : 
; 157  :         for (i = 0; i <= w; i++) {

  002bb	48 ff c2	 inc	 rdx
  002be	49 3b d2	 cmp	 rdx, r10
  002c1	0f 8e 6d ff ff
	ff		 jle	 $LN108@ucs1lib_fa@2
$LN100@ucs1lib_fa@2:

; 216  :             }
; 217  :         }
; 218  :     }
; 219  : 
; 220  :     if (mode != FAST_COUNT)

  002c7	45 85 f6	 test	 r14d, r14d
  002ca	0f 85 ef 00 00
	00		 jne	 $LN101@ucs1lib_fa@2

; 222  :     return count;

  002d0	49 8b c1	 mov	 rax, r9
  002d3	e9 ea 00 00 00	 jmp	 $LN106@ucs1lib_fa@2
$LN86@ucs1lib_fa@2:

; 170  :                         return maxcount;

  002d8	49 8b c4	 mov	 rax, r12
  002db	e9 e2 00 00 00	 jmp	 $LN106@ucs1lib_fa@2
$LN85@ucs1lib_fa@2:

; 167  :                         return i;

  002e0	48 8b c2	 mov	 rax, rdx
  002e3	e9 da 00 00 00	 jmp	 $LN106@ucs1lib_fa@2
$LN39@ucs1lib_fa@2:

; 183  :             }
; 184  :         }
; 185  :     } else {    /* FAST_RSEARCH */
; 186  : 
; 187  :         /* create compressed boyer-moore delta 1 table */
; 188  : 
; 189  :         /* process pattern[0] outside the loop */
; 190  :         STRINGLIB_BLOOM_ADD(mask, p[0]);

  002e8	45 0f b6 37	 movzx	 r14d, BYTE PTR [r15]
  002ec	44 8b e6	 mov	 r12d, esi
  002ef	41 8b ce	 mov	 ecx, r14d
  002f2	83 e1 1f	 and	 ecx, 31
  002f5	41 d3 e4	 shl	 r12d, cl

; 191  :         /* process pattern[:0:-1] */
; 192  :         for (i = mlast; i > 0; i--) {

  002f8	48 85 ff	 test	 rdi, rdi
  002fb	7e 41		 jle	 SHORT $LN16@ucs1lib_fa@2
  002fd	4e 8d 0c 3f	 lea	 r9, QWORD PTR [rdi+r15]
  00301	49 2b ef	 sub	 rbp, r15
  00304	4c 8b df	 mov	 r11, rdi
  00307	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL18@ucs1lib_fa@2:

; 193  :             STRINGLIB_BLOOM_ADD(mask, p[i]);

  00310	45 0f b6 01	 movzx	 r8d, BYTE PTR [r9]
  00314	8b d6		 mov	 edx, esi
  00316	41 8b c8	 mov	 ecx, r8d
  00319	83 e1 1f	 and	 ecx, 31
  0031c	d3 e2		 shl	 edx, cl
  0031e	44 0b e2	 or	 r12d, edx

; 194  :             if (p[i] == p[0])

  00321	45 3a c6	 cmp	 r8b, r14b
  00324	75 0c		 jne	 SHORT $LN17@ucs1lib_fa@2

; 195  :                 skip = i - 1;

  00326	49 8d 04 29	 lea	 rax, QWORD PTR [r9+rbp]
  0032a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR skip$1$[rsp], rax
$LN17@ucs1lib_fa@2:

; 191  :         /* process pattern[:0:-1] */
; 192  :         for (i = mlast; i > 0; i--) {

  00332	49 ff c9	 dec	 r9
  00335	49 ff cb	 dec	 r11
  00338	75 d6		 jne	 SHORT $LL18@ucs1lib_fa@2
  0033a	48 83 cd ff	 or	 rbp, -1
$LN16@ucs1lib_fa@2:

; 196  :         }
; 197  : 
; 198  :         for (i = w; i >= 0; i--) {

  0033e	4d 8b c2	 mov	 r8, r10
  00341	4d 2b c7	 sub	 r8, r15
  00344	4c 03 c3	 add	 r8, rbx
$LL14@ucs1lib_fa@2:

; 199  :             if (s[i] == p[0]) {

  00347	45 38 34 1a	 cmp	 BYTE PTR [r10+rbx], r14b
  0034b	75 50		 jne	 SHORT $LN11@ucs1lib_fa@2

; 200  :                 /* candidate match */
; 201  :                 for (j = mlast; j > 0; j--)

  0034d	48 8b d7	 mov	 rdx, rdi
  00350	48 85 ff	 test	 rdi, rdi
  00353	7e 1f		 jle	 SHORT $LN103@ucs1lib_fa@2
  00355	4a 8d 0c 3f	 lea	 rcx, QWORD PTR [rdi+r15]
  00359	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@ucs1lib_fa@2:

; 202  :                     if (s[i+j] != p[j])

  00360	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00363	41 38 04 08	 cmp	 BYTE PTR [r8+rcx], al
  00367	75 0b		 jne	 SHORT $LN103@ucs1lib_fa@2

; 200  :                 /* candidate match */
; 201  :                 for (j = mlast; j > 0; j--)

  00369	48 ff ca	 dec	 rdx
  0036c	48 ff c9	 dec	 rcx
  0036f	48 85 d2	 test	 rdx, rdx
  00372	7f ec		 jg	 SHORT $LL10@ucs1lib_fa@2
$LN103@ucs1lib_fa@2:

; 203  :                         break;
; 204  :                 if (j == 0)

  00374	48 85 d2	 test	 rdx, rdx
  00377	74 66		 je	 SHORT $LN88@ucs1lib_fa@2

; 207  :                 /* miss: check if previous character is part of pattern */
; 208  :                 if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))

  00379	4d 85 d2	 test	 r10, r10
  0037c	7e 0f		 jle	 SHORT $LN5@ucs1lib_fa@2
  0037e	41 0f b6 44 1a
	ff		 movzx	 eax, BYTE PTR [r10+rbx-1]
  00384	83 e0 1f	 and	 eax, 31
  00387	41 0f a3 c4	 bt	 r12d, eax

; 209  :                     i = i - m;
; 210  :                 else

  0038b	73 24		 jae	 SHORT $LN109@ucs1lib_fa@2
$LN5@ucs1lib_fa@2:

; 211  :                     i = i - skip;

  0038d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR skip$1$[rsp]
  00395	4c 2b d2	 sub	 r10, rdx
  00398	4c 2b c2	 sub	 r8, rdx

; 212  :             } else {

  0039b	eb 1a		 jmp	 SHORT $LN13@ucs1lib_fa@2
$LN11@ucs1lib_fa@2:

; 213  :                 /* skip: check if previous character is part of pattern */
; 214  :                 if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))

  0039d	4d 85 d2	 test	 r10, r10
  003a0	7e 15		 jle	 SHORT $LN13@ucs1lib_fa@2
  003a2	41 0f b6 44 1a
	ff		 movzx	 eax, BYTE PTR [r10+rbx-1]
  003a8	83 e0 1f	 and	 eax, 31
  003ab	41 0f a3 c4	 bt	 r12d, eax
  003af	72 06		 jb	 SHORT $LN13@ucs1lib_fa@2
$LN109@ucs1lib_fa@2:

; 215  :                     i = i - m;

  003b1	4d 2b d5	 sub	 r10, r13
  003b4	4d 2b c5	 sub	 r8, r13
$LN13@ucs1lib_fa@2:

; 196  :         }
; 197  : 
; 198  :         for (i = w; i >= 0; i--) {

  003b7	49 ff c8	 dec	 r8
  003ba	49 ff ca	 dec	 r10
  003bd	79 88		 jns	 SHORT $LL14@ucs1lib_fa@2
$LN101@ucs1lib_fa@2:

; 221  :         return -1;

  003bf	48 8b c5	 mov	 rax, rbp
$LN106@ucs1lib_fa@2:
  003c2	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  003c7	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  003cc	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN62@ucs1lib_fa@2:

; 223  : }

  003d1	48 83 c4 40	 add	 rsp, 64			; 00000040H
  003d5	41 5f		 pop	 r15
  003d7	41 5e		 pop	 r14
  003d9	41 5d		 pop	 r13
  003db	41 5c		 pop	 r12
  003dd	5b		 pop	 rbx
  003de	c3		 ret	 0
$LN88@ucs1lib_fa@2:

; 205  :                     /* got a match! */
; 206  :                     return i;

  003df	49 8b c2	 mov	 rax, r10
  003e2	eb de		 jmp	 SHORT $LN106@ucs1lib_fa@2
ucs1lib_fastsearch ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\count.h
pdata	SEGMENT
$pdata$ucs1lib_count DD imagerel ucs1lib_count
	DD	imagerel ucs1lib_count+40
	DD	imagerel $unwind$ucs1lib_count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ucs1lib_count DD imagerel ucs1lib_count+40
	DD	imagerel ucs1lib_count+73
	DD	imagerel $chain$0$ucs1lib_count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ucs1lib_count DD imagerel ucs1lib_count+73
	DD	imagerel ucs1lib_count+78
	DD	imagerel $chain$1$ucs1lib_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ucs1lib_count DD 021H
	DD	imagerel ucs1lib_count
	DD	imagerel ucs1lib_count+40
	DD	imagerel $unwind$ucs1lib_count
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ucs1lib_count DD 020521H
	DD	063405H
	DD	imagerel ucs1lib_count
	DD	imagerel ucs1lib_count+40
	DD	imagerel $unwind$ucs1lib_count
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_count DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs1lib_count
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
maxcount$ = 96
ucs1lib_count PROC					; COMDAT

; 11   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 12   :     Py_ssize_t count;
; 13   : 
; 14   :     if (str_len < 0)

  00004	48 85 d2	 test	 rdx, rdx
  00007	79 07		 jns	 SHORT $LN3@ucs1lib_co

; 15   :         return 0; /* start > len(str) */

  00009	33 c0		 xor	 eax, eax

; 22   :         return 0; /* no match */
; 23   : 
; 24   :     return count;
; 25   : }

  0000b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0000f	c3		 ret	 0
$LN3@ucs1lib_co:

; 16   :     if (sub_len == 0)
; 17   :         return (str_len < maxcount) ? str_len + 1 : maxcount;

  00010	48 8b 44 24 60	 mov	 rax, QWORD PTR maxcount$[rsp]
  00015	4d 85 c9	 test	 r9, r9
  00018	75 0e		 jne	 SHORT $LN2@ucs1lib_co
  0001a	48 3b d0	 cmp	 rdx, rax
  0001d	7d 2a		 jge	 SHORT $LN1@ucs1lib_co
  0001f	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]

; 22   :         return 0; /* no match */
; 23   : 
; 24   :     return count;
; 25   : }

  00023	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00027	c3		 ret	 0
$LN2@ucs1lib_co:
  00028	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 18   : 
; 19   :     count = FASTSEARCH(str, str_len, sub, sub_len, maxcount, FAST_COUNT);

  0002d	33 db		 xor	 ebx, ebx
  0002f	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  00033	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00038	e8 00 00 00 00	 call	 ucs1lib_fastsearch

; 20   : 
; 21   :     if (count < 0)

  0003d	48 85 c0	 test	 rax, rax
  00040	48 0f 48 c3	 cmovs	 rax, rbx
  00044	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN1@ucs1lib_co:

; 22   :         return 0; /* no match */
; 23   : 
; 24   :     return count;
; 25   : }

  00049	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004d	c3		 ret	 0
ucs1lib_count ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs1lib_find DD imagerel ucs1lib_find
	DD	imagerel ucs1lib_find+58
	DD	imagerel $unwind$ucs1lib_find
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ucs1lib_find DD imagerel ucs1lib_find+58
	DD	imagerel ucs1lib_find+235
	DD	imagerel $chain$4$ucs1lib_find
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$ucs1lib_find DD imagerel ucs1lib_find+235
	DD	imagerel ucs1lib_find+513
	DD	imagerel $chain$6$ucs1lib_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$ucs1lib_find DD 0a0021H
	DD	06f400H
	DD	07d400H
	DD	0fc400H
	DD	0e6400H
	DD	0c5400H
	DD	imagerel ucs1lib_find
	DD	imagerel ucs1lib_find+58
	DD	imagerel $unwind$ucs1lib_find
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ucs1lib_find DD 0a1c21H
	DD	06f41cH
	DD	07d417H
	DD	0fc40fH
	DD	0e640aH
	DD	0c5405H
	DD	imagerel ucs1lib_find
	DD	imagerel ucs1lib_find+58
	DD	imagerel $unwind$ucs1lib_find
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_find DD 040901H
	DD	0e0057209H
	DD	030027003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\find.h
xdata	ENDS
;	COMDAT ucs1lib_find
_TEXT	SEGMENT
w$1$ = 32
str$ = 96
skip$1$ = 104
str_len$ = 104
sub$ = 112
sub_len$ = 120
offset$ = 128
ucs1lib_find PROC					; COMDAT

; 11   : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 56		 push	 r14
  00005	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00009	49 8b d9	 mov	 rbx, r9
  0000c	4d 8b f0	 mov	 r14, r8
  0000f	48 8b f9	 mov	 rdi, rcx

; 12   :     Py_ssize_t pos;
; 13   : 
; 14   :     if (str_len < 0)

  00012	48 85 d2	 test	 rdx, rdx
  00015	79 0d		 jns	 SHORT $LN3@ucs1lib_fi

; 15   :         return -1;

  00017	48 83 c8 ff	 or	 rax, -1

; 25   : }

  0001b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0001f	41 5e		 pop	 r14
  00021	5f		 pop	 rdi
  00022	5b		 pop	 rbx
  00023	c3		 ret	 0
$LN3@ucs1lib_fi:

; 16   :     if (sub_len == 0)

  00024	48 85 db	 test	 rbx, rbx
  00027	75 11		 jne	 SHORT $LN2@ucs1lib_fi

; 17   :         return offset;

  00029	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR offset$[rsp]

; 25   : }

  00031	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00035	41 5e		 pop	 r14
  00037	5f		 pop	 rdi
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
$LN2@ucs1lib_fi:
  0003a	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  0003f	48 89 74 24 70	 mov	 QWORD PTR [rsp+112], rsi
  00044	4c 89 64 24 78	 mov	 QWORD PTR [rsp+120], r12

; 18   : 
; 19   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_SEARCH);

  00049	48 8b ea	 mov	 rbp, rdx
  0004c	4c 89 6c 24 38	 mov	 QWORD PTR [rsp+56], r13
  00051	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  00056	48 2b eb	 sub	 rbp, rbx
  00059	48 89 6c 24 20	 mov	 QWORD PTR w$1$[rsp], rbp
  0005e	78 62		 js	 SHORT $LN65@ucs1lib_fi
  00060	48 83 fb 01	 cmp	 rbx, 1
  00064	0f 8f 81 00 00
	00		 jg	 $LN64@ucs1lib_fi
  0006a	48 85 db	 test	 rbx, rbx
  0006d	7e 53		 jle	 SHORT $LN65@ucs1lib_fi
  0006f	48 83 fa 0a	 cmp	 rdx, 10
  00073	7e 2f		 jle	 SHORT $LN62@ucs1lib_fi
  00075	4c 8d 04 11	 lea	 r8, QWORD PTR [rcx+rdx]
  00079	49 3b c8	 cmp	 rcx, r8
  0007c	73 15		 jae	 SHORT $LN72@ucs1lib_fi
  0007e	41 0f b6 16	 movzx	 edx, BYTE PTR [r14]
  00082	4c 2b c1	 sub	 r8, rcx
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0008b	4c 8b c8	 mov	 r9, rax
  0008e	48 85 c0	 test	 rax, rax
  00091	75 09		 jne	 SHORT $LN71@ucs1lib_fi
$LN72@ucs1lib_fi:
  00093	49 83 c9 ff	 or	 r9, -1
  00097	e9 4f 01 00 00	 jmp	 $LN67@ucs1lib_fi
$LN71@ucs1lib_fi:
  0009c	4c 2b cf	 sub	 r9, rdi
  0009f	e9 47 01 00 00	 jmp	 $LN67@ucs1lib_fi
$LN62@ucs1lib_fi:
  000a4	45 33 c9	 xor	 r9d, r9d
  000a7	48 85 d2	 test	 rdx, rdx
  000aa	7e 16		 jle	 SHORT $LN65@ucs1lib_fi
  000ac	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
$LL53@ucs1lib_fi:
  000b0	41 38 04 09	 cmp	 BYTE PTR [r9+rcx], al
  000b4	0f 84 31 01 00
	00		 je	 $LN67@ucs1lib_fi
  000ba	49 ff c1	 inc	 r9
  000bd	4c 3b ca	 cmp	 r9, rdx
  000c0	7c ee		 jl	 SHORT $LL53@ucs1lib_fi
$LN65@ucs1lib_fi:
  000c2	49 83 c9 ff	 or	 r9, -1
$LN1@ucs1lib_fi:
  000c6	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]
  000cb	4c 8b 6c 24 38	 mov	 r13, QWORD PTR [rsp+56]
  000d0	4c 8b 64 24 78	 mov	 r12, QWORD PTR [rsp+120]
  000d5	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  000da	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]

; 23   : 
; 24   :     return pos;

  000df	49 8b c1	 mov	 rax, r9

; 25   : }

  000e2	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000e6	41 5e		 pop	 r14
  000e8	5f		 pop	 rdi
  000e9	5b		 pop	 rbx
  000ea	c3		 ret	 0

; 18   : 
; 19   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_SEARCH);

$LN64@ucs1lib_fi:
  000eb	4d 8d 51 ff	 lea	 r10, QWORD PTR [r9-1]
  000ef	45 33 c9	 xor	 r9d, r9d
  000f2	4d 8d 62 ff	 lea	 r12, QWORD PTR [r10-1]
  000f6	45 8b f9	 mov	 r15d, r9d
  000f9	45 8d 59 01	 lea	 r11d, QWORD PTR [r9+1]
  000fd	4d 85 d2	 test	 r10, r10
  00100	7e 55		 jle	 SHORT $LN41@ucs1lib_fi
  00102	47 0f b6 2c 02	 movzx	 r13d, BYTE PTR [r10+r8]
  00107	49 8b ec	 mov	 rbp, r12
  0010a	4d 8b e2	 mov	 r12, r10
  0010d	4c 8b d5	 mov	 r10, rbp
  00110	49 8b f0	 mov	 rsi, r8
  00113	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL43@ucs1lib_fi:
  00120	44 0f b6 06	 movzx	 r8d, BYTE PTR [rsi]
  00124	41 8b d3	 mov	 edx, r11d
  00127	41 8b c8	 mov	 ecx, r8d
  0012a	83 e1 1f	 and	 ecx, 31
  0012d	d3 e2		 shl	 edx, cl
  0012f	44 0b fa	 or	 r15d, edx
  00132	45 3a c5	 cmp	 r8b, r13b
  00135	4c 0f 44 d5	 cmove	 r10, rbp
  00139	48 ff c6	 inc	 rsi
  0013c	48 ff cd	 dec	 rbp
  0013f	49 ff cc	 dec	 r12
  00142	75 dc		 jne	 SHORT $LL43@ucs1lib_fi
  00144	48 8b 6c 24 20	 mov	 rbp, QWORD PTR w$1$[rsp]
  00149	4c 89 54 24 68	 mov	 QWORD PTR skip$1$[rsp], r10
  0014e	4c 8d 53 ff	 lea	 r10, QWORD PTR [rbx-1]
  00152	4c 8b 64 24 68	 mov	 r12, QWORD PTR skip$1$[rsp]
$LN41@ucs1lib_fi:
  00157	43 0f b6 0c 32	 movzx	 ecx, BYTE PTR [r10+r14]
  0015c	49 8b d1	 mov	 rdx, r9
  0015f	83 e1 1f	 and	 ecx, 31
  00162	41 d3 e3	 shl	 r11d, cl
  00165	45 0b fb	 or	 r15d, r11d
  00168	48 85 ed	 test	 rbp, rbp
  0016b	0f 88 51 ff ff
	ff		 js	 $LN65@ucs1lib_fi
  00171	45 0f b6 6c 1e
	ff		 movzx	 r13d, BYTE PTR [r14+rbx-1]
  00177	48 8d 34 1f	 lea	 rsi, QWORD PTR [rdi+rbx]
  0017b	0f 1f 44 00 00	 npad	 5
$LL39@ucs1lib_fi:
  00180	44 38 6c 16 ff	 cmp	 BYTE PTR [rsi+rdx-1], r13b
  00185	75 44		 jne	 SHORT $LN36@ucs1lib_fi
  00187	4d 8b c1	 mov	 r8, r9
  0018a	4d 85 d2	 test	 r10, r10
  0018d	7e 25		 jle	 SHORT $LN89@ucs1lib_fi
  0018f	4c 8b da	 mov	 r11, rdx
  00192	49 8b ce	 mov	 rcx, r14
  00195	4d 2b de	 sub	 r11, r14
  00198	4c 03 df	 add	 r11, rdi
  0019b	0f 1f 44 00 00	 npad	 5
$LL35@ucs1lib_fi:
  001a0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  001a3	41 38 04 0b	 cmp	 BYTE PTR [r11+rcx], al
  001a7	75 0b		 jne	 SHORT $LN89@ucs1lib_fi
  001a9	49 ff c0	 inc	 r8
  001ac	48 ff c1	 inc	 rcx
  001af	4d 3b c2	 cmp	 r8, r10
  001b2	7c ec		 jl	 SHORT $LL35@ucs1lib_fi
$LN89@ucs1lib_fi:
  001b4	4d 3b c2	 cmp	 r8, r10
  001b7	74 2f		 je	 SHORT $LN83@ucs1lib_fi
  001b9	0f b6 04 16	 movzx	 eax, BYTE PTR [rsi+rdx]
  001bd	83 e0 1f	 and	 eax, 31
  001c0	41 0f a3 c7	 bt	 r15d, eax
  001c4	73 12		 jae	 SHORT $LN90@ucs1lib_fi
  001c6	49 03 d4	 add	 rdx, r12
  001c9	eb 10		 jmp	 SHORT $LN38@ucs1lib_fi
$LN36@ucs1lib_fi:
  001cb	0f b6 04 16	 movzx	 eax, BYTE PTR [rsi+rdx]
  001cf	83 e0 1f	 and	 eax, 31
  001d2	41 0f a3 c7	 bt	 r15d, eax
  001d6	72 03		 jb	 SHORT $LN38@ucs1lib_fi
$LN90@ucs1lib_fi:
  001d8	48 03 d3	 add	 rdx, rbx
$LN38@ucs1lib_fi:
  001db	48 ff c2	 inc	 rdx
  001de	48 3b d5	 cmp	 rdx, rbp
  001e1	7e 9d		 jle	 SHORT $LL39@ucs1lib_fi
  001e3	e9 da fe ff ff	 jmp	 $LN65@ucs1lib_fi
$LN83@ucs1lib_fi:
  001e8	4c 8b ca	 mov	 r9, rdx
$LN67@ucs1lib_fi:

; 20   : 
; 21   :     if (pos >= 0)

  001eb	4d 85 c9	 test	 r9, r9
  001ee	0f 88 d2 fe ff
	ff		 js	 $LN1@ucs1lib_fi

; 22   :         pos += offset;

  001f4	4c 03 8c 24 80
	00 00 00	 add	 r9, QWORD PTR offset$[rsp]
  001fc	e9 c5 fe ff ff	 jmp	 $LN1@ucs1lib_fi
ucs1lib_find ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs1lib_rfind DD imagerel ucs1lib_rfind
	DD	imagerel ucs1lib_rfind+58
	DD	imagerel $unwind$ucs1lib_rfind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ucs1lib_rfind DD imagerel ucs1lib_rfind+58
	DD	imagerel ucs1lib_rfind+161
	DD	imagerel $chain$2$ucs1lib_rfind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ucs1lib_rfind DD imagerel ucs1lib_rfind+161
	DD	imagerel ucs1lib_rfind+198
	DD	imagerel $chain$4$ucs1lib_rfind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$ucs1lib_rfind DD imagerel ucs1lib_rfind+198
	DD	imagerel ucs1lib_rfind+280
	DD	imagerel $chain$6$ucs1lib_rfind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$ucs1lib_rfind DD imagerel ucs1lib_rfind+280
	DD	imagerel ucs1lib_rfind+425
	DD	imagerel $chain$7$ucs1lib_rfind
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$ucs1lib_rfind DD 021H
	DD	imagerel ucs1lib_rfind+161
	DD	imagerel ucs1lib_rfind+198
	DD	imagerel $chain$4$ucs1lib_rfind
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$ucs1lib_rfind DD 040d21H
	DD	07740dH
	DD	066405H
	DD	imagerel ucs1lib_rfind+161
	DD	imagerel ucs1lib_rfind+198
	DD	imagerel $chain$4$ucs1lib_rfind
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ucs1lib_rfind DD 060021H
	DD	0e400H
	DD	01d400H
	DD	08c400H
	DD	imagerel ucs1lib_rfind
	DD	imagerel ucs1lib_rfind+58
	DD	imagerel $unwind$ucs1lib_rfind
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ucs1lib_rfind DD 061421H
	DD	0e414H
	DD	01d40dH
	DD	08c405H
	DD	imagerel ucs1lib_rfind
	DD	imagerel ucs1lib_rfind+58
	DD	imagerel $unwind$ucs1lib_rfind
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_rfind DD 040901H
	DD	0f0051209H
	DD	030025003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\find.h
xdata	ENDS
;	COMDAT ucs1lib_rfind
_TEXT	SEGMENT
str$ = 48
str_len$ = 56
sub$ = 64
sub_len$ = 72
offset$ = 80
ucs1lib_rfind PROC					; COMDAT

; 31   : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	41 57		 push	 r15
  00005	48 83 ec 10	 sub	 rsp, 16
  00009	49 8b d9	 mov	 rbx, r9
  0000c	4d 8b f8	 mov	 r15, r8
  0000f	48 8b e9	 mov	 rbp, rcx

; 32   :     Py_ssize_t pos;
; 33   : 
; 34   :     if (str_len < 0)

  00012	48 85 d2	 test	 rdx, rdx
  00015	79 0d		 jns	 SHORT $LN3@ucs1lib_rf

; 35   :         return -1;

  00017	48 83 c8 ff	 or	 rax, -1

; 45   : }

  0001b	48 83 c4 10	 add	 rsp, 16
  0001f	41 5f		 pop	 r15
  00021	5d		 pop	 rbp
  00022	5b		 pop	 rbx
  00023	c3		 ret	 0
$LN3@ucs1lib_rf:

; 36   :     if (sub_len == 0)

  00024	48 85 db	 test	 rbx, rbx
  00027	75 11		 jne	 SHORT $LN2@ucs1lib_rf

; 37   :         return str_len + offset;

  00029	48 8b 44 24 50	 mov	 rax, QWORD PTR offset$[rsp]
  0002e	48 03 c2	 add	 rax, rdx

; 45   : }

  00031	48 83 c4 10	 add	 rsp, 16
  00035	41 5f		 pop	 r15
  00037	5d		 pop	 rbp
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
$LN2@ucs1lib_rf:
  0003a	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12

; 38   : 
; 39   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_RSEARCH);

  0003f	4c 8b ca	 mov	 r9, rdx
  00042	4c 89 6c 24 08	 mov	 QWORD PTR [rsp+8], r13
  00047	4c 2b cb	 sub	 r9, rbx
  0004a	4c 89 34 24	 mov	 QWORD PTR [rsp], r14
  0004e	78 33		 js	 SHORT $LN65@ucs1lib_rf
  00050	48 83 fb 01	 cmp	 rbx, 1
  00054	7f 4b		 jg	 SHORT $LN64@ucs1lib_rf
  00056	48 85 db	 test	 rbx, rbx
  00059	7e 28		 jle	 SHORT $LN65@ucs1lib_rf
  0005b	4c 8d 4a ff	 lea	 r9, QWORD PTR [rdx-1]
  0005f	49 83 f9 ff	 cmp	 r9, -1
  00063	7e 1e		 jle	 SHORT $LN65@ucs1lib_rf
  00065	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL48@ucs1lib_rf:
  00070	41 38 04 09	 cmp	 BYTE PTR [r9+rcx], al
  00074	0f 84 15 01 00
	00		 je	 $LN83@ucs1lib_rf
  0007a	49 ff c9	 dec	 r9
  0007d	49 83 f9 ff	 cmp	 r9, -1
  00081	7f ed		 jg	 SHORT $LL48@ucs1lib_rf
$LN65@ucs1lib_rf:
  00083	49 83 ca ff	 or	 r10, -1
$LN1@ucs1lib_rf:
  00087	4c 8b 34 24	 mov	 r14, QWORD PTR [rsp]
  0008b	4c 8b 6c 24 08	 mov	 r13, QWORD PTR [rsp+8]
  00090	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]

; 43   : 
; 44   :     return pos;

  00095	49 8b c2	 mov	 rax, r10

; 45   : }

  00098	48 83 c4 10	 add	 rsp, 16
  0009c	41 5f		 pop	 r15
  0009e	5d		 pop	 rbp
  0009f	5b		 pop	 rbx
  000a0	c3		 ret	 0

; 38   : 
; 39   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_RSEARCH);

$LN64@ucs1lib_rf:
  000a1	45 0f b6 18	 movzx	 r11d, BYTE PTR [r8]
  000a5	4c 8d 63 ff	 lea	 r12, QWORD PTR [rbx-1]
  000a9	41 be 01 00 00
	00		 mov	 r14d, 1
  000af	41 8b cb	 mov	 ecx, r11d
  000b2	49 83 ca ff	 or	 r10, -1
  000b6	4d 8d 6c 24 ff	 lea	 r13, QWORD PTR [r12-1]
  000bb	83 e1 1f	 and	 ecx, 31
  000be	41 d3 e6	 shl	 r14d, cl
  000c1	4d 85 e4	 test	 r12, r12
  000c4	7e 52		 jle	 SHORT $LN21@ucs1lib_rf
  000c6	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  000cb	49 8b f2	 mov	 rsi, r10
  000ce	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  000d3	4f 8d 1c 04	 lea	 r11, QWORD PTR [r12+r8]
  000d7	49 8b fc	 mov	 rdi, r12
  000da	45 0f b6 20	 movzx	 r12d, BYTE PTR [r8]
  000de	49 2b f0	 sub	 rsi, r8
$LL23@ucs1lib_rf:
  000e1	45 0f b6 03	 movzx	 r8d, BYTE PTR [r11]
  000e5	ba 01 00 00 00	 mov	 edx, 1
  000ea	41 8b c8	 mov	 ecx, r8d
  000ed	83 e1 1f	 and	 ecx, 31
  000f0	d3 e2		 shl	 edx, cl
  000f2	44 0b f2	 or	 r14d, edx
  000f5	45 3a c4	 cmp	 r8b, r12b
  000f8	75 04		 jne	 SHORT $LN22@ucs1lib_rf
  000fa	4e 8d 2c 1e	 lea	 r13, QWORD PTR [rsi+r11]
$LN22@ucs1lib_rf:
  000fe	49 ff cb	 dec	 r11
  00101	48 ff cf	 dec	 rdi
  00104	75 db		 jne	 SHORT $LL23@ucs1lib_rf
  00106	45 0f b6 1f	 movzx	 r11d, BYTE PTR [r15]
  0010a	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  0010f	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00114	4c 8d 63 ff	 lea	 r12, QWORD PTR [rbx-1]
$LN21@ucs1lib_rf:
  00118	4d 8b c1	 mov	 r8, r9
  0011b	4d 2b c7	 sub	 r8, r15
  0011e	4c 03 c5	 add	 r8, rbp
$LL19@ucs1lib_rf:
  00121	45 38 1c 29	 cmp	 BYTE PTR [r9+rbp], r11b
  00125	75 41		 jne	 SHORT $LN16@ucs1lib_rf
  00127	49 8b d4	 mov	 rdx, r12
  0012a	4d 85 e4	 test	 r12, r12
  0012d	7e 18		 jle	 SHORT $LN89@ucs1lib_rf
  0012f	4b 8d 0c 3c	 lea	 rcx, QWORD PTR [r12+r15]
$LL15@ucs1lib_rf:
  00133	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00136	41 38 04 08	 cmp	 BYTE PTR [r8+rcx], al
  0013a	75 0b		 jne	 SHORT $LN89@ucs1lib_rf
  0013c	48 ff ca	 dec	 rdx
  0013f	48 ff c9	 dec	 rcx
  00142	48 85 d2	 test	 rdx, rdx
  00145	7f ec		 jg	 SHORT $LL15@ucs1lib_rf
$LN89@ucs1lib_rf:
  00147	48 85 d2	 test	 rdx, rdx
  0014a	74 43		 je	 SHORT $LN83@ucs1lib_rf
  0014c	4d 85 c9	 test	 r9, r9
  0014f	7e 0f		 jle	 SHORT $LN10@ucs1lib_rf
  00151	41 0f b6 44 29
	ff		 movzx	 eax, BYTE PTR [r9+rbp-1]
  00157	83 e0 1f	 and	 eax, 31
  0015a	41 0f a3 c6	 bt	 r14d, eax
  0015e	73 1c		 jae	 SHORT $LN90@ucs1lib_rf
$LN10@ucs1lib_rf:
  00160	4d 2b cd	 sub	 r9, r13
  00163	4d 2b c5	 sub	 r8, r13
  00166	eb 1a		 jmp	 SHORT $LN18@ucs1lib_rf
$LN16@ucs1lib_rf:
  00168	4d 85 c9	 test	 r9, r9
  0016b	7e 15		 jle	 SHORT $LN18@ucs1lib_rf
  0016d	41 0f b6 44 29
	ff		 movzx	 eax, BYTE PTR [r9+rbp-1]
  00173	83 e0 1f	 and	 eax, 31
  00176	41 0f a3 c6	 bt	 r14d, eax
  0017a	72 06		 jb	 SHORT $LN18@ucs1lib_rf
$LN90@ucs1lib_rf:
  0017c	4c 2b cb	 sub	 r9, rbx
  0017f	4c 2b c3	 sub	 r8, rbx
$LN18@ucs1lib_rf:
  00182	49 ff c8	 dec	 r8
  00185	49 ff c9	 dec	 r9
  00188	79 97		 jns	 SHORT $LL19@ucs1lib_rf
  0018a	e9 f8 fe ff ff	 jmp	 $LN1@ucs1lib_rf
$LN83@ucs1lib_rf:
  0018f	4d 8b d1	 mov	 r10, r9

; 40   : 
; 41   :     if (pos >= 0)

  00192	4d 85 c9	 test	 r9, r9
  00195	0f 88 ec fe ff
	ff		 js	 $LN1@ucs1lib_rf

; 42   :         pos += offset;

  0019b	48 8b 44 24 50	 mov	 rax, QWORD PTR offset$[rsp]
  001a0	4d 8d 14 01	 lea	 r10, QWORD PTR [r9+rax]
  001a4	e9 de fe ff ff	 jmp	 $LN1@ucs1lib_rf
ucs1lib_rfind ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs1lib_find_slice DD imagerel ucs1lib_find_slice
	DD	imagerel ucs1lib_find_slice+75
	DD	imagerel $unwind$ucs1lib_find_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_find_slice DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs1lib_find_slice
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
start$ = 96
end$ = 104
ucs1lib_find_slice PROC					; COMDAT

; 66   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	4c 8b d2	 mov	 r10, rdx

; 67   :     ADJUST_INDICES(start, end, str_len);

  00007	48 8b 54 24 68	 mov	 rdx, QWORD PTR end$[rsp]
  0000c	45 33 db	 xor	 r11d, r11d
  0000f	49 3b d2	 cmp	 rdx, r10
  00012	7e 05		 jle	 SHORT $LN6@ucs1lib_fi@2
  00014	49 8b d2	 mov	 rdx, r10
  00017	eb 0c		 jmp	 SHORT $LN3@ucs1lib_fi@2
$LN6@ucs1lib_fi@2:
  00019	48 85 d2	 test	 rdx, rdx
  0001c	79 07		 jns	 SHORT $LN3@ucs1lib_fi@2
  0001e	49 03 d2	 add	 rdx, r10
  00021	49 0f 48 d3	 cmovs	 rdx, r11
$LN3@ucs1lib_fi@2:
  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0002a	48 85 c0	 test	 rax, rax
  0002d	79 07		 jns	 SHORT $LN1@ucs1lib_fi@2
  0002f	49 03 c2	 add	 rax, r10
  00032	49 0f 48 c3	 cmovs	 rax, r11
$LN1@ucs1lib_fi@2:

; 68   :     return STRINGLIB(find)(str + start, end - start, sub, sub_len, start);

  00036	48 2b d0	 sub	 rdx, rax
  00039	48 03 c8	 add	 rcx, rax
  0003c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00041	e8 00 00 00 00	 call	 ucs1lib_find

; 69   : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
ucs1lib_find_slice ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs1lib_rfind_slice DD imagerel ucs1lib_rfind_slice
	DD	imagerel ucs1lib_rfind_slice+75
	DD	imagerel $unwind$ucs1lib_rfind_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_rfind_slice DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs1lib_rfind_slice
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
start$ = 96
end$ = 104
ucs1lib_rfind_slice PROC				; COMDAT

; 75   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	4c 8b d2	 mov	 r10, rdx

; 76   :     ADJUST_INDICES(start, end, str_len);

  00007	48 8b 54 24 68	 mov	 rdx, QWORD PTR end$[rsp]
  0000c	45 33 db	 xor	 r11d, r11d
  0000f	49 3b d2	 cmp	 rdx, r10
  00012	7e 05		 jle	 SHORT $LN6@ucs1lib_rf@2
  00014	49 8b d2	 mov	 rdx, r10
  00017	eb 0c		 jmp	 SHORT $LN3@ucs1lib_rf@2
$LN6@ucs1lib_rf@2:
  00019	48 85 d2	 test	 rdx, rdx
  0001c	79 07		 jns	 SHORT $LN3@ucs1lib_rf@2
  0001e	49 03 d2	 add	 rdx, r10
  00021	49 0f 48 d3	 cmovs	 rdx, r11
$LN3@ucs1lib_rf@2:
  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0002a	48 85 c0	 test	 rax, rax
  0002d	79 07		 jns	 SHORT $LN1@ucs1lib_rf@2
  0002f	49 03 c2	 add	 rax, r10
  00032	49 0f 48 c3	 cmovs	 rax, r11
$LN1@ucs1lib_rf@2:

; 77   :     return STRINGLIB(rfind)(str + start, end - start, sub, sub_len, start);

  00036	48 2b d0	 sub	 rdx, rax
  00039	48 03 c8	 add	 rcx, rax
  0003c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00041	e8 00 00 00 00	 call	 ucs1lib_rfind

; 78   : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
ucs1lib_rfind_slice ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\find_max_char.h
_TEXT	ENDS
;	COMDAT ucs1lib_find_max_char
_TEXT	SEGMENT
begin$ = 8
end$ = 16
ucs1lib_find_max_char PROC				; COMDAT

; 20   :     const unsigned char *p = (const unsigned char *) begin;
; 21   :     const unsigned char *aligned_end =
; 22   :             (const unsigned char *) _Py_ALIGN_DOWN(end, SIZEOF_LONG);

  00000	4c 8b c2	 mov	 r8, rdx
  00003	49 83 e0 fc	 and	 r8, -4
$LN19@ucs1lib_fi@3:

; 23   : 
; 24   :     while (p < end) {

  00007	48 3b ca	 cmp	 rcx, rdx
  0000a	73 3d		 jae	 SHORT $LN7@ucs1lib_fi@3

; 25   :         if (_Py_IS_ALIGNED(p, SIZEOF_LONG)) {

  0000c	f6 c1 03	 test	 cl, 3
  0000f	75 28		 jne	 SHORT $LN2@ucs1lib_fi@3

; 26   :             /* Help register allocation */
; 27   :             register const unsigned char *_p = p;

  00011	48 8b c1	 mov	 rax, rcx

; 28   :             while (_p < aligned_end) {

  00014	49 3b c8	 cmp	 rcx, r8
  00017	73 18		 jae	 SHORT $LN4@ucs1lib_fi@3
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@ucs1lib_fi@3:

; 29   :                 unsigned long value = *(unsigned long *) _p;
; 30   :                 if (value & UCS1_ASCII_CHAR_MASK)

  00020	f7 00 80 80 80
	80		 test	 DWORD PTR [rax], -2139062144 ; 80808080H
  00026	75 1b		 jne	 SHORT $LN13@ucs1lib_fi@3

; 32   :                 _p += SIZEOF_LONG;

  00028	48 83 c0 04	 add	 rax, 4
  0002c	49 3b c0	 cmp	 rax, r8
  0002f	72 ef		 jb	 SHORT $LL5@ucs1lib_fi@3
$LN4@ucs1lib_fi@3:

; 33   :             }
; 34   :             p = _p;

  00031	48 8b c8	 mov	 rcx, rax

; 35   :             if (p == end)

  00034	48 3b c2	 cmp	 rax, rdx
  00037	74 10		 je	 SHORT $LN7@ucs1lib_fi@3
$LN2@ucs1lib_fi@3:

; 36   :                 break;
; 37   :         }
; 38   :         if (*p++ & 0x80)

  00039	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  0003c	48 ff c1	 inc	 rcx
  0003f	24 80		 and	 al, 128			; 00000080H
  00041	74 c4		 je	 SHORT $LN19@ucs1lib_fi@3
$LN13@ucs1lib_fi@3:

; 31   :                     return 255;

  00043	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH

; 42   : }

  00048	c3		 ret	 0
$LN7@ucs1lib_fi@3:

; 39   :             return 255;
; 40   :     }
; 41   :     return 127;

  00049	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH

; 42   : }

  0004e	c3		 ret	 0
ucs1lib_find_max_char ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\localeutil.h
_TEXT	ENDS
;	COMDAT ucs1lib_GroupGenerator_init
_TEXT	SEGMENT
self$ = 8
grouping$ = 16
ucs1lib_GroupGenerator_init PROC			; COMDAT

; 18   :     self->grouping = grouping;

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 19   :     self->i = 0;

  00003	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 20   :     self->previous = 0;

  0000b	c6 41 08 00	 mov	 BYTE PTR [rcx+8], 0

; 21   : }

  0000f	c3		 ret	 0
ucs1lib_GroupGenerator_init ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ucs1lib_GroupGenerator_next
_TEXT	SEGMENT
self$ = 8
ucs1lib_GroupGenerator_next PROC			; COMDAT

; 27   :     /* Note that we don't really do much error checking here. If a
; 28   :        grouping string contains just CHAR_MAX, for example, then just
; 29   :        terminate the generator. That shouldn't happen, but at least we
; 30   :        fail gracefully. */
; 31   :     switch (self->grouping[self->i]) {

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00007	41 0f b6 14 00	 movzx	 edx, BYTE PTR [r8+rax]
  0000c	0f b6 c2	 movzx	 eax, dl
  0000f	84 d2		 test	 dl, dl
  00011	74 17		 je	 SHORT $LN3@ucs1lib_Gr
  00013	3c 7f		 cmp	 al, 127			; 0000007fH
  00015	74 10		 je	 SHORT $LN2@ucs1lib_Gr

; 37   :     default: {
; 38   :         char ch = self->grouping[self->i];
; 39   :         self->previous = ch;
; 40   :         self->i++;

  00017	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]
  0001b	88 51 08	 mov	 BYTE PTR [rcx+8], dl
  0001e	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 41   :         return (Py_ssize_t)ch;

  00022	48 0f be c2	 movsx	 rax, dl

; 42   :     }
; 43   :     }
; 44   : }

  00026	c3		 ret	 0
$LN2@ucs1lib_Gr:

; 34   :     case CHAR_MAX:
; 35   :         /* Stop the generator. */
; 36   :         return 0;

  00027	33 c0		 xor	 eax, eax

; 42   :     }
; 43   :     }
; 44   : }

  00029	c3		 ret	 0
$LN3@ucs1lib_Gr:

; 32   :     case 0:
; 33   :         return self->previous;

  0002a	48 0f be 41 08	 movsx	 rax, BYTE PTR [rcx+8]

; 42   :     }
; 43   :     }
; 44   : }

  0002f	c3		 ret	 0
ucs1lib_GroupGenerator_next ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs1lib_fill DD imagerel ucs1lib_fill
	DD	imagerel ucs1lib_fill+133
	DD	imagerel $unwind$ucs1lib_fill
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_fill DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs1lib_fill
_TEXT	SEGMENT
digits_end$ = 48
buffer_end$ = 56
n_chars$ = 64
n_zeros$ = 72
thousands_sep$ = 80
thousands_sep_len$ = 88
ucs1lib_fill PROC					; COMDAT

; 52   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b da	 mov	 rbx, rdx

; 53   :     Py_ssize_t i;
; 54   : 
; 55   :     if (thousands_sep) {

  00017	48 8b 54 24 50	 mov	 rdx, QWORD PTR thousands_sep$[rsp]
  0001c	49 8b f9	 mov	 rdi, r9
  0001f	49 8b f0	 mov	 rsi, r8
  00022	48 8b e9	 mov	 rbp, rcx
  00025	48 85 d2	 test	 rdx, rdx
  00028	74 10		 je	 SHORT $LN4@ucs1lib_fi@4

; 56   :         *buffer_end -= thousands_sep_len;

  0002a	4c 8b 44 24 58	 mov	 r8, QWORD PTR thousands_sep_len$[rsp]
  0002f	4c 29 03	 sub	 QWORD PTR [rbx], r8

; 57   : 
; 58   :         /* Copy the thousands_sep chars into the buffer. */
; 59   :         memcpy(*buffer_end, thousands_sep,
; 60   :                thousands_sep_len * STRINGLIB_SIZEOF_CHAR);

  00032	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00035	e8 00 00 00 00	 call	 memcpy
$LN4@ucs1lib_fi@4:

; 61   :     }
; 62   : 
; 63   :     *buffer_end -= n_chars;

  0003a	48 29 33	 sub	 QWORD PTR [rbx], rsi

; 64   :     *digits_end -= n_chars;

  0003d	48 29 75 00	 sub	 QWORD PTR [rbp], rsi

; 65   :     memcpy(*buffer_end, *digits_end, n_chars * sizeof(STRINGLIB_CHAR));

  00041	48 8b 55 00	 mov	 rdx, QWORD PTR [rbp]
  00045	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00048	4c 8b c6	 mov	 r8, rsi
  0004b	e8 00 00 00 00	 call	 memcpy

; 66   : 
; 67   :     *buffer_end -= n_zeros;

  00050	48 29 3b	 sub	 QWORD PTR [rbx], rdi

; 68   :     for (i = 0; i < n_zeros; i++)

  00053	33 c9		 xor	 ecx, ecx
  00055	48 85 ff	 test	 rdi, rdi
  00058	7e 16		 jle	 SHORT $LN1@ucs1lib_fi@4
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL3@ucs1lib_fi@4:

; 69   :         (*buffer_end)[i] = '0';

  00060	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00063	48 ff c1	 inc	 rcx
  00066	c6 44 01 ff 30	 mov	 BYTE PTR [rcx+rax-1], 48 ; 00000030H
  0006b	48 3b cf	 cmp	 rcx, rdi
  0006e	7c f0		 jl	 SHORT $LL3@ucs1lib_fi@4
$LN1@ucs1lib_fi@4:

; 70   : }

  00070	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00075	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0007a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
ucs1lib_fill ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs1lib_InsertThousandsGrouping DD imagerel ucs1lib_InsertThousandsGrouping
	DD	imagerel ucs1lib_InsertThousandsGrouping+461
	DD	imagerel $unwind$ucs1lib_InsertThousandsGrouping
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_InsertThousandsGrouping DD 0b6f01H
	DD	0a746fH
	DD	013546aH
	DD	0f00fa213H
	DD	0d00be00dH
	DD	06007c009H
	DD	03006H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs1lib_InsertThousandsGrouping
_TEXT	SEGMENT
digits_end$ = 48
groupgen$ = 56
buffer$ = 144
n_buffer$ = 152
digits$ = 160
buffer_end$ = 168
n_digits$ = 168
min_width$ = 176
grouping$ = 184
thousands_sep$ = 192
thousands_sep_len$ = 200
ucs1lib_InsertThousandsGrouping PROC			; COMDAT

; 112  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	56		 push	 rsi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	41 57		 push	 r15
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 113  :     Py_ssize_t count = 0;

  00013	45 33 e4	 xor	 r12d, r12d
  00016	48 8b c2	 mov	 rax, rdx

; 114  :     Py_ssize_t n_zeros;
; 115  :     int loop_broken = 0;
; 116  :     int use_separator = 0; /* First time through, don't append the
; 117  :                               separator. They only go between
; 118  :                               groups. */
; 119  :     STRINGLIB_CHAR *buffer_end = NULL;
; 120  :     STRINGLIB_CHAR *digits_end = NULL;
; 121  :     Py_ssize_t l;
; 122  :     Py_ssize_t n_chars;
; 123  :     Py_ssize_t remaining = n_digits; /* Number of chars remaining to
; 124  :                                         be looked at */
; 125  :     /* A generator that returns all of the grouping widths, until it
; 126  :        returns 0. */
; 127  :     STRINGLIB(GroupGenerator) groupgen;
; 128  :     STRINGLIB(GroupGenerator_init)(&groupgen, grouping);

  00019	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR grouping$[rsp]
  00021	4c 8b d9	 mov	 r11, rcx
  00024	48 8d 4c 24 38	 lea	 rcx, QWORD PTR groupgen$[rsp]
  00029	49 8b f1	 mov	 rsi, r9
  0002c	45 8b fc	 mov	 r15d, r12d
  0002f	45 8b d4	 mov	 r10d, r12d
  00032	4c 89 a4 24 a8
	00 00 00	 mov	 QWORD PTR buffer_end$[rsp], r12
  0003a	4c 89 64 24 30	 mov	 QWORD PTR digits_end$[rsp], r12
  0003f	e8 00 00 00 00	 call	 ucs1lib_GroupGenerator_init

; 129  : 
; 130  :     if (buffer) {

  00044	4d 85 db	 test	 r11, r11
  00047	74 14		 je	 SHORT $LN26@ucs1lib_In

; 131  :         buffer_end = buffer + n_buffer;

  00049	49 03 c3	 add	 rax, r11
  0004c	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR buffer_end$[rsp], rax

; 132  :         digits_end = digits + n_digits;

  00054	4b 8d 04 08	 lea	 rax, QWORD PTR [r8+r9]
  00058	48 89 44 24 30	 mov	 QWORD PTR digits_end$[rsp], rax
$LN26@ucs1lib_In:

; 133  :     }
; 134  : 
; 135  :     while ((l = STRINGLIB(GroupGenerator_next)(&groupgen)) > 0) {

  0005d	48 8d 4c 24 38	 lea	 rcx, QWORD PTR groupgen$[rsp]
  00062	48 89 ac 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rbp
  0006a	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0006f	e8 00 00 00 00	 call	 ucs1lib_GroupGenerator_next
  00074	4c 8b b4 24 c8
	00 00 00	 mov	 r14, QWORD PTR thousands_sep_len$[rsp]
  0007c	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR min_width$[rsp]
  00084	41 bd 01 00 00
	00		 mov	 r13d, 1
$LN35@ucs1lib_In:
  0008a	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR thousands_sep$[rsp]
  00092	48 8b d8	 mov	 rbx, rax
  00095	48 85 c0	 test	 rax, rax
  00098	0f 8e ac 00 00
	00		 jle	 $LN29@ucs1lib_In

; 136  :         l = Py_MIN(l, Py_MAX(Py_MAX(remaining, min_width), 1));

  0009e	48 3b f7	 cmp	 rsi, rdi
  000a1	49 8b c5	 mov	 rax, r13
  000a4	48 8b cf	 mov	 rcx, rdi
  000a7	48 0f 4f ce	 cmovg	 rcx, rsi
  000ab	48 3b c8	 cmp	 rcx, rax
  000ae	48 0f 4f c1	 cmovg	 rax, rcx
  000b2	48 3b d8	 cmp	 rbx, rax
  000b5	7e 0a		 jle	 SHORT $LN12@ucs1lib_In
  000b7	49 8b dd	 mov	 rbx, r13
  000ba	48 3b cb	 cmp	 rcx, rbx
  000bd	48 0f 4f d9	 cmovg	 rbx, rcx
$LN12@ucs1lib_In:

; 137  :         n_zeros = Py_MAX(0, l - remaining);

  000c1	4c 8b cb	 mov	 r9, rbx

; 138  :         n_chars = Py_MAX(0, Py_MIN(remaining, l));

  000c4	48 8b ee	 mov	 rbp, rsi

; 139  : 
; 140  :         /* Use n_zero zero's and n_chars chars */
; 141  : 
; 142  :         /* Count only, don't do anything. */
; 143  :         count += (use_separator ? thousands_sep_len : 0) + n_zeros + n_chars;

  000c7	49 8b c4	 mov	 rax, r12
  000ca	4c 2b ce	 sub	 r9, rsi
  000cd	4d 0f 48 cc	 cmovs	 r9, r12
  000d1	48 3b f3	 cmp	 rsi, rbx
  000d4	48 0f 4f eb	 cmovg	 rbp, rbx
  000d8	48 85 ed	 test	 rbp, rbp
  000db	49 0f 48 ec	 cmovs	 rbp, r12
  000df	45 85 d2	 test	 r10d, r10d
  000e2	49 0f 45 c6	 cmovne	 rax, r14
  000e6	48 03 c5	 add	 rax, rbp
  000e9	49 03 c1	 add	 rax, r9
  000ec	4c 03 f8	 add	 r15, rax

; 144  : 
; 145  :         if (buffer) {

  000ef	4d 85 db	 test	 r11, r11
  000f2	74 31		 je	 SHORT $LN4@ucs1lib_In

; 146  :             /* Copy into the output buffer. */
; 147  :             STRINGLIB(fill)(&digits_end, &buffer_end, n_chars, n_zeros,
; 148  :                  use_separator ? thousands_sep : NULL, thousands_sep_len);

  000f4	45 85 d2	 test	 r10d, r10d
  000f7	49 8b c4	 mov	 rax, r12
  000fa	48 8d 4c 24 30	 lea	 rcx, QWORD PTR digits_end$[rsp]
  000ff	48 0f 45 c2	 cmovne	 rax, rdx
  00103	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR buffer_end$[rsp]
  0010b	4c 8b c5	 mov	 r8, rbp
  0010e	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00113	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00118	e8 00 00 00 00	 call	 ucs1lib_fill
  0011d	4c 8b 9c 24 90
	00 00 00	 mov	 r11, QWORD PTR buffer$[rsp]
$LN4@ucs1lib_In:

; 149  :         }
; 150  : 
; 151  :         /* Use a separator next time. */
; 152  :         use_separator = 1;
; 153  : 
; 154  :         remaining -= n_chars;

  00125	48 2b f5	 sub	 rsi, rbp

; 155  :         min_width -= l;

  00128	48 2b fb	 sub	 rdi, rbx
  0012b	45 8b d5	 mov	 r10d, r13d

; 156  : 
; 157  :         if (remaining <= 0 && min_width <= 0) {

  0012e	48 85 f6	 test	 rsi, rsi
  00131	7f 05		 jg	 SHORT $LN3@ucs1lib_In
  00133	48 85 ff	 test	 rdi, rdi
  00136	7e 76		 jle	 SHORT $LN30@ucs1lib_In
$LN3@ucs1lib_In:

; 133  :     }
; 134  : 
; 135  :     while ((l = STRINGLIB(GroupGenerator_next)(&groupgen)) > 0) {

  00138	48 8d 4c 24 38	 lea	 rcx, QWORD PTR groupgen$[rsp]

; 158  :             loop_broken = 1;
; 159  :             break;
; 160  :         }
; 161  :         min_width -= thousands_sep_len;

  0013d	49 2b fe	 sub	 rdi, r14
  00140	e8 00 00 00 00	 call	 ucs1lib_GroupGenerator_next
  00145	e9 40 ff ff ff	 jmp	 $LN35@ucs1lib_In
$LN29@ucs1lib_In:

; 162  :     }
; 163  :     if (!loop_broken) {
; 164  :         /* We left the loop without using a break statement. */
; 165  : 
; 166  :         l = Py_MAX(Py_MAX(remaining, min_width), 1);

  0014a	48 3b f7	 cmp	 rsi, rdi

; 167  :         n_zeros = Py_MAX(0, l - remaining);
; 168  :         n_chars = Py_MAX(0, Py_MIN(remaining, l));
; 169  : 
; 170  :         /* Use n_zero zero's and n_chars chars */
; 171  :         count += (use_separator ? thousands_sep_len : 0) + n_zeros + n_chars;

  0014d	49 8b c4	 mov	 rax, r12
  00150	48 0f 4f fe	 cmovg	 rdi, rsi
  00154	49 3b fd	 cmp	 rdi, r13
  00157	4c 0f 4f ef	 cmovg	 r13, rdi
  0015b	4d 8b cd	 mov	 r9, r13
  0015e	4c 2b ce	 sub	 r9, rsi
  00161	4d 0f 48 cc	 cmovs	 r9, r12
  00165	49 3b f5	 cmp	 rsi, r13
  00168	49 0f 4f f5	 cmovg	 rsi, r13
  0016c	48 85 f6	 test	 rsi, rsi
  0016f	49 0f 48 f4	 cmovs	 rsi, r12
  00173	45 85 d2	 test	 r10d, r10d
  00176	49 0f 45 c6	 cmovne	 rax, r14
  0017a	48 03 c6	 add	 rax, rsi
  0017d	49 03 c1	 add	 rax, r9
  00180	4c 03 f8	 add	 r15, rax

; 172  :         if (buffer) {

  00183	4d 85 db	 test	 r11, r11
  00186	74 26		 je	 SHORT $LN30@ucs1lib_In

; 173  :             /* Copy into the output buffer. */
; 174  :             STRINGLIB(fill)(&digits_end, &buffer_end, n_chars, n_zeros,
; 175  :                  use_separator ? thousands_sep : NULL, thousands_sep_len);

  00188	45 85 d2	 test	 r10d, r10d
  0018b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR digits_end$[rsp]
  00190	4c 8b c6	 mov	 r8, rsi
  00193	4c 0f 45 e2	 cmovne	 r12, rdx
  00197	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR buffer_end$[rsp]
  0019f	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  001a4	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  001a9	e8 00 00 00 00	 call	 ucs1lib_fill
$LN30@ucs1lib_In:

; 176  :         }
; 177  :     }
; 178  :     return count;

  001ae	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  001b3	48 8b ac 24 98
	00 00 00	 mov	 rbp, QWORD PTR [rsp+152]
  001bb	49 8b c7	 mov	 rax, r15

; 179  : }

  001be	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001c2	41 5f		 pop	 r15
  001c4	41 5e		 pop	 r14
  001c6	41 5d		 pop	 r13
  001c8	41 5c		 pop	 r12
  001ca	5e		 pop	 rsi
  001cb	5b		 pop	 rbx
  001cc	c3		 ret	 0
ucs1lib_InsertThousandsGrouping ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs2lib_fastsearch_memchr_1char DD imagerel ucs2lib_fastsearch_memchr_1char
	DD	imagerel ucs2lib_fastsearch_memchr_1char+24
	DD	imagerel $unwind$ucs2lib_fastsearch_memchr_1char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ucs2lib_fastsearch_memchr_1char DD imagerel ucs2lib_fastsearch_memchr_1char+24
	DD	imagerel ucs2lib_fastsearch_memchr_1char+121
	DD	imagerel $chain$1$ucs2lib_fastsearch_memchr_1char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ucs2lib_fastsearch_memchr_1char DD imagerel ucs2lib_fastsearch_memchr_1char+121
	DD	imagerel ucs2lib_fastsearch_memchr_1char+129
	DD	imagerel $chain$3$ucs2lib_fastsearch_memchr_1char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ucs2lib_fastsearch_memchr_1char DD imagerel ucs2lib_fastsearch_memchr_1char+129
	DD	imagerel ucs2lib_fastsearch_memchr_1char+142
	DD	imagerel $chain$4$ucs2lib_fastsearch_memchr_1char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ucs2lib_fastsearch_memchr_1char DD 021H
	DD	imagerel ucs2lib_fastsearch_memchr_1char
	DD	imagerel ucs2lib_fastsearch_memchr_1char+24
	DD	imagerel $unwind$ucs2lib_fastsearch_memchr_1char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ucs2lib_fastsearch_memchr_1char DD 040021H
	DD	075400H
	DD	063400H
	DD	imagerel ucs2lib_fastsearch_memchr_1char
	DD	imagerel ucs2lib_fastsearch_memchr_1char+24
	DD	imagerel $unwind$ucs2lib_fastsearch_memchr_1char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ucs2lib_fastsearch_memchr_1char DD 041121H
	DD	075411H
	DD	063405H
	DD	imagerel ucs2lib_fastsearch_memchr_1char
	DD	imagerel ucs2lib_fastsearch_memchr_1char+24
	DD	imagerel $unwind$ucs2lib_fastsearch_memchr_1char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_fastsearch_memchr_1char DD 040a01H
	DD	08640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs2lib_fastsearch_memchr_1char
_TEXT	SEGMENT
s$ = 48
n$ = 56
ch$ = 64
needle$ = 72
mode$ = 80
ucs2lib_fastsearch_memchr_1char PROC			; COMDAT

; 40   : {

  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 41   :     if (mode == FAST_SEARCH) {

  0000a	83 7c 24 50 01	 cmp	 DWORD PTR mode$[rsp], 1
  0000f	41 0f b7 f0	 movzx	 esi, r8w
  00013	48 8b f9	 mov	 rdi, rcx
  00016	75 69		 jne	 SHORT $LN7@ucs2lib_fa

; 42   :         const STRINGLIB_CHAR *ptr = s;
; 43   :         const STRINGLIB_CHAR *e = s + n;

  00018	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0001d	48 8d 1c 51	 lea	 rbx, QWORD PTR [rcx+rdx*2]
  00021	48 8b c1	 mov	 rax, rcx
  00024	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp

; 44   :         while (ptr < e) {

  00029	48 3b cb	 cmp	 rcx, rbx
  0002c	73 32		 jae	 SHORT $LN5@ucs2lib_fa
  0002e	41 0f b6 e9	 movzx	 ebp, r9b
$LL6@ucs2lib_fa:

; 45   :             void *candidate = memchr((const void *) ptr, needle, (e - ptr) * sizeof(STRINGLIB_CHAR));

  00032	4c 8b c3	 mov	 r8, rbx
  00035	8b d5		 mov	 edx, ebp
  00037	48 8b c8	 mov	 rcx, rax
  0003a	4c 2b c0	 sub	 r8, rax
  0003d	49 d1 f8	 sar	 r8, 1
  00040	4d 03 c0	 add	 r8, r8
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr

; 46   :             if (candidate == NULL)

  00049	48 85 c0	 test	 rax, rax
  0004c	74 12		 je	 SHORT $LN5@ucs2lib_fa

; 47   :                 return -1;
; 48   :             ptr = (const STRINGLIB_CHAR *) _Py_ALIGN_DOWN(candidate, sizeof(STRINGLIB_CHAR));

  0004e	48 83 e0 fe	 and	 rax, -2

; 49   :             if (sizeof(STRINGLIB_CHAR) == 1 || *ptr == ch)

  00052	66 39 30	 cmp	 WORD PTR [rax], si
  00055	74 22		 je	 SHORT $LN12@ucs2lib_fa

; 51   :             /* False positive */
; 52   :             ptr++;

  00057	48 83 c0 02	 add	 rax, 2
  0005b	48 3b c3	 cmp	 rax, rbx
  0005e	72 d2		 jb	 SHORT $LL6@ucs2lib_fa
$LN5@ucs2lib_fa:

; 53   :         }
; 54   :         return -1;

  00060	48 83 c8 ff	 or	 rax, -1
$LN15@ucs2lib_fa:
  00064	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00069	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 78   :     }
; 79   : 
; 80   : #undef DO_MEMCHR
; 81   : }

  0006e	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
$LN12@ucs2lib_fa:

; 50   :                 return (ptr - s);

  00079	48 2b c7	 sub	 rax, rdi
  0007c	48 d1 f8	 sar	 rax, 1
  0007f	eb e3		 jmp	 SHORT $LN15@ucs2lib_fa
$LN7@ucs2lib_fa:

; 55   :     }
; 56   : #ifdef HAVE_MEMRCHR
; 57   :     /* memrchr() is a GNU extension, available since glibc 2.1.91.
; 58   :        it doesn't seem as optimized as memchr(), but is still quite
; 59   :        faster than our hand-written loop in FASTSEARCH below */
; 60   :     else if (mode == FAST_RSEARCH) {
; 61   :         while (n > 0) {
; 62   :             const STRINGLIB_CHAR *found;
; 63   :             void *candidate = memrchr((const void *) s, needle, n * sizeof(STRINGLIB_CHAR));
; 64   :             if (candidate == NULL)
; 65   :                 return -1;
; 66   :             found = (const STRINGLIB_CHAR *) _Py_ALIGN_DOWN(candidate, sizeof(STRINGLIB_CHAR));
; 67   :             n = found - s;
; 68   :             if (sizeof(STRINGLIB_CHAR) == 1 || *found == ch)
; 69   :                 return n;
; 70   :             /* False positive */
; 71   :         }
; 72   :         return -1;
; 73   :     }
; 74   : #endif
; 75   :     else {
; 76   :         assert(0); /* Should never get here */
; 77   :         return 0;

  00081	33 c0		 xor	 eax, eax

; 78   :     }
; 79   : 
; 80   : #undef DO_MEMCHR
; 81   : }

  00083	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00088	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008c	5f		 pop	 rdi
  0008d	c3		 ret	 0
ucs2lib_fastsearch_memchr_1char ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs2lib_fastsearch DD imagerel ucs2lib_fastsearch
	DD	imagerel ucs2lib_fastsearch+75
	DD	imagerel $unwind$ucs2lib_fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ucs2lib_fastsearch DD imagerel ucs2lib_fastsearch+75
	DD	imagerel ucs2lib_fastsearch+296
	DD	imagerel $chain$0$ucs2lib_fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ucs2lib_fastsearch DD imagerel ucs2lib_fastsearch+296
	DD	imagerel ucs2lib_fastsearch+700
	DD	imagerel $chain$2$ucs2lib_fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ucs2lib_fastsearch DD imagerel ucs2lib_fastsearch+700
	DD	imagerel ucs2lib_fastsearch+720
	DD	imagerel $chain$3$ucs2lib_fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$ucs2lib_fastsearch DD imagerel ucs2lib_fastsearch+720
	DD	imagerel ucs2lib_fastsearch+993
	DD	imagerel $chain$5$ucs2lib_fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$ucs2lib_fastsearch DD imagerel ucs2lib_fastsearch+993
	DD	imagerel ucs2lib_fastsearch+1009
	DD	imagerel $chain$6$ucs2lib_fastsearch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$ucs2lib_fastsearch DD 021H
	DD	imagerel ucs2lib_fastsearch
	DD	imagerel ucs2lib_fastsearch+75
	DD	imagerel $unwind$ucs2lib_fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$ucs2lib_fastsearch DD 060021H
	DD	08d400H
	DD	09c400H
	DD	0107400H
	DD	imagerel ucs2lib_fastsearch
	DD	imagerel ucs2lib_fastsearch+75
	DD	imagerel $unwind$ucs2lib_fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ucs2lib_fastsearch DD 021H
	DD	imagerel ucs2lib_fastsearch+75
	DD	imagerel ucs2lib_fastsearch+296
	DD	imagerel $chain$0$ucs2lib_fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ucs2lib_fastsearch DD 040a21H
	DD	08d40aH
	DD	09c405H
	DD	imagerel ucs2lib_fastsearch+75
	DD	imagerel ucs2lib_fastsearch+296
	DD	imagerel $chain$0$ucs2lib_fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ucs2lib_fastsearch DD 020821H
	DD	0107408H
	DD	imagerel ucs2lib_fastsearch
	DD	imagerel ucs2lib_fastsearch+75
	DD	imagerel $unwind$ucs2lib_fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_fastsearch DD 061501H
	DD	0f0119215H
	DD	0600de00fH
	DD	0300b500cH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs2lib_fastsearch
_TEXT	SEGMENT
skip$1$ = 48
s$ = 128
mask$1$ = 136
n$ = 136
p$ = 144
m$ = 152
maxcount$ = 160
mode$ = 168
ucs2lib_fastsearch PROC					; COMDAT

; 87   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 88   :     unsigned long mask;
; 89   :     Py_ssize_t skip, count = 0;

  00015	45 33 d2	 xor	 r10d, r10d

; 90   :     Py_ssize_t i, j, mlast, w;
; 91   : 
; 92   :     w = n - m;

  00018	4c 8b da	 mov	 r11, rdx
  0001b	49 8b e8	 mov	 rbp, r8
  0001e	4d 2b d9	 sub	 r11, r9
  00021	48 8b d9	 mov	 rbx, rcx
  00024	41 8b f2	 mov	 esi, r10d

; 93   : 
; 94   :     if (w < 0 || (mode == FAST_COUNT && maxcount == 0))

  00027	0f 88 b4 03 00
	00		 js	 $LN61@ucs2lib_fa@2
  0002d	44 8b bc 24 a8
	00 00 00	 mov	 r15d, DWORD PTR mode$[rsp]
  00035	4c 8b b4 24 a0
	00 00 00	 mov	 r14, QWORD PTR maxcount$[rsp]
  0003d	45 85 ff	 test	 r15d, r15d
  00040	75 09		 jne	 SHORT $LN62@ucs2lib_fa@2
  00042	4d 85 f6	 test	 r14, r14
  00045	0f 84 96 03 00
	00		 je	 $LN61@ucs2lib_fa@2
$LN62@ucs2lib_fa@2:
  0004b	48 89 bc 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rdi

; 96   : 
; 97   :     /* look for special cases */
; 98   :     if (m <= 1) {

  00053	49 83 f9 01	 cmp	 r9, 1
  00057	0f 8f c3 00 00
	00		 jg	 $LN60@ucs2lib_fa@2

; 99   :         if (m <= 0)

  0005d	4d 85 c9	 test	 r9, r9

; 100  :             return -1;

  00060	0f 8e b1 00 00
	00		 jle	 $LN41@ucs2lib_fa@2

; 101  :         /* use special case for 1-character strings */
; 102  :         if (n > 10 && (mode == FAST_SEARCH
; 103  : #ifdef HAVE_MEMRCHR
; 104  :                     || mode == FAST_RSEARCH
; 105  : #endif
; 106  :                     )) {

  00066	48 83 fa 0a	 cmp	 rdx, 10
  0006a	7e 25		 jle	 SHORT $LN57@ucs2lib_fa@2
  0006c	41 83 ff 01	 cmp	 r15d, 1
  00070	75 1f		 jne	 SHORT $LN57@ucs2lib_fa@2

; 107  :             /* use memchr if we can choose a needle without two many likely
; 108  :                false positives */
; 109  :             unsigned char needle;
; 110  :             needle = p[0] & 0xff;

  00072	45 0f b6 08	 movzx	 r9d, BYTE PTR [r8]

; 111  : #if STRINGLIB_SIZEOF_CHAR > 1
; 112  :             /* If looking for a multiple of 256, we'd have too
; 113  :                many false positives looking for the '\0' byte in UCS2
; 114  :                and UCS4 representations. */
; 115  :             if (needle != 0)

  00076	45 84 c9	 test	 r9b, r9b
  00079	74 52		 je	 SHORT $LN91@ucs2lib_fa@2

; 116  : #endif
; 117  :                 return STRINGLIB(fastsearch_memchr_1char)
; 118  :                        (s, n, p[0], needle, maxcount, mode);

  0007b	45 0f b7 00	 movzx	 r8d, WORD PTR [r8]
  0007f	41 8b ff	 mov	 edi, r15d
  00082	44 89 7c 24 20	 mov	 DWORD PTR [rsp+32], r15d
  00087	e8 00 00 00 00	 call	 ucs2lib_fastsearch_memchr_1char
  0008c	e9 2b 02 00 00	 jmp	 $LN99@ucs2lib_fa@2
$LN57@ucs2lib_fa@2:

; 119  :         }
; 120  :         if (mode == FAST_COUNT) {

  00091	45 85 ff	 test	 r15d, r15d
  00094	75 31		 jne	 SHORT $LN56@ucs2lib_fa@2

; 121  :             for (i = 0; i < n; i++)

  00096	48 85 d2	 test	 rdx, rdx
  00099	7e 1c		 jle	 SHORT $LN93@ucs2lib_fa@2
  0009b	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
  0009f	90		 npad	 1
$LL55@ucs2lib_fa@2:

; 122  :                 if (s[i] == p[0]) {

  000a0	66 42 39 04 51	 cmp	 WORD PTR [rcx+r10*2], ax
  000a5	75 08		 jne	 SHORT $LN54@ucs2lib_fa@2

; 123  :                     count++;

  000a7	48 ff c6	 inc	 rsi

; 124  :                     if (count == maxcount)

  000aa	49 3b f6	 cmp	 rsi, r14
  000ad	74 10		 je	 SHORT $LN74@ucs2lib_fa@2
$LN54@ucs2lib_fa@2:

; 121  :             for (i = 0; i < n; i++)

  000af	49 ff c2	 inc	 r10
  000b2	4c 3b d2	 cmp	 r10, rdx
  000b5	7c e9		 jl	 SHORT $LL55@ucs2lib_fa@2
$LN93@ucs2lib_fa@2:

; 126  :                 }
; 127  :             return count;

  000b7	48 8b c6	 mov	 rax, rsi
  000ba	e9 fd 01 00 00	 jmp	 $LN99@ucs2lib_fa@2
$LN74@ucs2lib_fa@2:

; 125  :                         return maxcount;

  000bf	49 8b c6	 mov	 rax, r14
  000c2	e9 f5 01 00 00	 jmp	 $LN99@ucs2lib_fa@2
$LN56@ucs2lib_fa@2:

; 128  :         } else if (mode == FAST_SEARCH) {

  000c7	41 83 ff 01	 cmp	 r15d, 1
  000cb	75 29		 jne	 SHORT $LN49@ucs2lib_fa@2
$LN91@ucs2lib_fa@2:

; 129  :             for (i = 0; i < n; i++)

  000cd	48 85 d2	 test	 rdx, rdx
  000d0	7e 45		 jle	 SHORT $LN41@ucs2lib_fa@2
  000d2	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
$LL48@ucs2lib_fa@2:

; 130  :                 if (s[i] == p[0])

  000d6	66 42 39 04 51	 cmp	 WORD PTR [rcx+r10*2], ax
  000db	74 11		 je	 SHORT $LN75@ucs2lib_fa@2

; 129  :             for (i = 0; i < n; i++)

  000dd	49 ff c2	 inc	 r10
  000e0	4c 3b d2	 cmp	 r10, rdx
  000e3	7c f1		 jl	 SHORT $LL48@ucs2lib_fa@2

; 135  :                     return i;
; 136  :         }
; 137  :         return -1;

  000e5	48 83 c8 ff	 or	 rax, -1
  000e9	e9 ce 01 00 00	 jmp	 $LN99@ucs2lib_fa@2
$LN75@ucs2lib_fa@2:

; 131  :                     return i;

  000ee	49 8b c2	 mov	 rax, r10
  000f1	e9 c6 01 00 00	 jmp	 $LN99@ucs2lib_fa@2
$LN49@ucs2lib_fa@2:

; 132  :         } else {    /* FAST_RSEARCH */
; 133  :             for (i = n - 1; i > -1; i--)

  000f6	48 8d 42 ff	 lea	 rax, QWORD PTR [rdx-1]
  000fa	48 83 f8 ff	 cmp	 rax, -1
  000fe	7e 17		 jle	 SHORT $LN41@ucs2lib_fa@2
  00100	41 0f b7 08	 movzx	 ecx, WORD PTR [r8]
$LL43@ucs2lib_fa@2:

; 134  :                 if (s[i] == p[0])

  00104	66 39 0c 43	 cmp	 WORD PTR [rbx+rax*2], cx
  00108	0f 84 ae 01 00
	00		 je	 $LN99@ucs2lib_fa@2

; 132  :         } else {    /* FAST_RSEARCH */
; 133  :             for (i = n - 1; i > -1; i--)

  0010e	48 ff c8	 dec	 rax
  00111	48 83 f8 ff	 cmp	 rax, -1
  00115	7f ed		 jg	 SHORT $LL43@ucs2lib_fa@2
$LN41@ucs2lib_fa@2:

; 135  :                     return i;
; 136  :         }
; 137  :         return -1;

  00117	48 83 c8 ff	 or	 rax, -1
  0011b	e9 9c 01 00 00	 jmp	 $LN99@ucs2lib_fa@2
$LN60@ucs2lib_fa@2:

; 138  :     }
; 139  : 
; 140  :     mlast = m - 1;

  00120	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR m$[rsp]
  00128	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  0012d	4c 89 6c 24 40	 mov	 QWORD PTR [rsp+64], r13
  00132	4c 8d 6a ff	 lea	 r13, QWORD PTR [rdx-1]

; 141  :     skip = mlast - 1;
; 142  :     mask = 0;

  00136	45 8b e2	 mov	 r12d, r10d

; 143  : 
; 144  :     if (mode != FAST_RSEARCH) {
; 145  : 
; 146  :         /* create compressed boyer-moore delta 1 table */
; 147  : 
; 148  :         /* process pattern[:-1] */
; 149  :         for (i = 0; i < mlast; i++) {

  00139	bf 01 00 00 00	 mov	 edi, 1
  0013e	4d 8d 45 ff	 lea	 r8, QWORD PTR [r13-1]
  00142	4c 89 44 24 30	 mov	 QWORD PTR skip$1$[rsp], r8
  00147	41 83 ff 02	 cmp	 r15d, 2
  0014b	0f 84 92 01 00
	00		 je	 $LN39@ucs2lib_fa@2
  00151	4d 8b ca	 mov	 r9, r10
  00154	4d 85 ed	 test	 r13, r13
  00157	7e 6c		 jle	 SHORT $LN36@ucs2lib_fa@2
  00159	4c 8b bc 24 90
	00 00 00	 mov	 r15, QWORD PTR p$[rsp]
  00161	49 8d 75 ff	 lea	 rsi, QWORD PTR [r13-1]
  00165	45 8b f1	 mov	 r14d, r9d
  00168	47 0f b7 24 6f	 movzx	 r12d, WORD PTR [r15+r13*2]
  0016d	48 8b ee	 mov	 rbp, rsi
$LL38@ucs2lib_fa@2:
  00170	47 0f b7 04 4f	 movzx	 r8d, WORD PTR [r15+r9*2]

; 150  :             STRINGLIB_BLOOM_ADD(mask, p[i]);

  00175	8b d7		 mov	 edx, edi
  00177	41 8b c8	 mov	 ecx, r8d
  0017a	83 e1 1f	 and	 ecx, 31
  0017d	d3 e2		 shl	 edx, cl
  0017f	44 0b f2	 or	 r14d, edx

; 151  :             if (p[i] == p[mlast])

  00182	66 45 3b c4	 cmp	 r8w, r12w
  00186	48 0f 44 f5	 cmove	 rsi, rbp
  0018a	49 ff c1	 inc	 r9
  0018d	48 ff cd	 dec	 rbp
  00190	4d 3b cd	 cmp	 r9, r13
  00193	7c db		 jl	 SHORT $LL38@ucs2lib_fa@2
  00195	44 8b bc 24 a8
	00 00 00	 mov	 r15d, DWORD PTR mode$[rsp]
  0019d	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR m$[rsp]
  001a5	44 89 b4 24 88
	00 00 00	 mov	 DWORD PTR mask$1$[rsp], r14d
  001ad	44 8b a4 24 88
	00 00 00	 mov	 r12d, DWORD PTR mask$1$[rsp]
  001b5	4c 8b b4 24 a0
	00 00 00	 mov	 r14, QWORD PTR maxcount$[rsp]
  001bd	48 89 74 24 30	 mov	 QWORD PTR skip$1$[rsp], rsi
  001c2	49 8b f2	 mov	 rsi, r10
$LN36@ucs2lib_fa@2:

; 152  :                 skip = mlast - i - 1;
; 153  :         }
; 154  :         /* process pattern[-1] outside the loop */
; 155  :         STRINGLIB_BLOOM_ADD(mask, p[mlast]);

  001c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  001cd	4b 8d 6c 2d 00	 lea	 rbp, QWORD PTR [r13+r13]

; 156  : 
; 157  :         for (i = 0; i <= w; i++) {

  001d2	4d 8b ca	 mov	 r9, r10
  001d5	0f b7 0c 28	 movzx	 ecx, WORD PTR [rax+rbp]
  001d9	83 e1 1f	 and	 ecx, 31
  001dc	d3 e7		 shl	 edi, cl
  001de	44 0b e7	 or	 r12d, edi
  001e1	4d 85 db	 test	 r11, r11
  001e4	0f 88 eb 00 00
	00		 js	 $LN94@ucs2lib_fa@2

; 152  :                 skip = mlast - i - 1;
; 153  :         }
; 154  :         /* process pattern[-1] outside the loop */
; 155  :         STRINGLIB_BLOOM_ADD(mask, p[mlast]);

  001ea	48 8d 3c 12	 lea	 rdi, QWORD PTR [rdx+rdx]
  001ee	4c 8d 04 1f	 lea	 r8, QWORD PTR [rdi+rbx]
  001f2	48 2b d8	 sub	 rbx, rax
  001f5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL34@ucs2lib_fa@2:

; 158  :             /* note: using mlast in the skip path slows things down on x86 */
; 159  :             if (s[i+m-1] == p[m-1]) {

  00200	0f b7 4c 07 fe	 movzx	 ecx, WORD PTR [rdi+rax-2]
  00205	66 41 39 48 fe	 cmp	 WORD PTR [r8-2], cx
  0020a	75 70		 jne	 SHORT $LN31@ucs2lib_fa@2

; 160  :                 /* candidate match */
; 161  :                 for (j = 0; j < mlast; j++)

  0020c	49 8b d2	 mov	 rdx, r10
  0020f	4d 85 ed	 test	 r13, r13
  00212	7e 18		 jle	 SHORT $LN96@ucs2lib_fa@2
  00214	48 8b c8	 mov	 rcx, rax
$LL30@ucs2lib_fa@2:

; 162  :                     if (s[i+j] != p[j])

  00217	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  0021a	66 39 04 0b	 cmp	 WORD PTR [rbx+rcx], ax
  0021e	75 0c		 jne	 SHORT $LN96@ucs2lib_fa@2

; 160  :                 /* candidate match */
; 161  :                 for (j = 0; j < mlast; j++)

  00220	48 ff c2	 inc	 rdx
  00223	48 83 c1 02	 add	 rcx, 2
  00227	49 3b d5	 cmp	 rdx, r13
  0022a	7c eb		 jl	 SHORT $LL30@ucs2lib_fa@2
$LN96@ucs2lib_fa@2:

; 163  :                         break;
; 164  :                 if (j == mlast) {

  0022c	49 3b d5	 cmp	 rdx, r13
  0022f	75 24		 jne	 SHORT $LN26@ucs2lib_fa@2

; 165  :                     /* got a match! */
; 166  :                     if (mode != FAST_COUNT)

  00231	45 85 ff	 test	 r15d, r15d
  00234	0f 85 96 00 00
	00		 jne	 $LN78@ucs2lib_fa@2

; 168  :                     count++;

  0023a	48 ff c6	 inc	 rsi

; 169  :                     if (count == maxcount)

  0023d	49 3b f6	 cmp	 rsi, r14
  00240	74 6d		 je	 SHORT $LN79@ucs2lib_fa@2

; 171  :                     i = i + mlast;
; 172  :                     continue;

  00242	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR m$[rsp]
  0024a	4d 03 cd	 add	 r9, r13
  0024d	48 03 dd	 add	 rbx, rbp
  00250	4c 03 c5	 add	 r8, rbp
  00253	eb 3d		 jmp	 SHORT $LN33@ucs2lib_fa@2
$LN26@ucs2lib_fa@2:

; 173  :                 }
; 174  :                 /* miss: check if next character is part of pattern */
; 175  :                 if (!STRINGLIB_BLOOM(mask, s[i+m]))

  00255	41 0f b7 00	 movzx	 eax, WORD PTR [r8]

; 176  :                     i = i + m;

  00259	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR m$[rsp]
  00261	83 e0 1f	 and	 eax, 31
  00264	41 0f a3 c4	 bt	 r12d, eax

; 177  :                 else

  00268	73 1f		 jae	 SHORT $LN102@ucs2lib_fa@2

; 178  :                     i = i + skip;

  0026a	48 8b 44 24 30	 mov	 rax, QWORD PTR skip$1$[rsp]
  0026f	4c 03 c8	 add	 r9, rax
  00272	48 8d 1c 43	 lea	 rbx, QWORD PTR [rbx+rax*2]
  00276	4d 8d 04 40	 lea	 r8, QWORD PTR [r8+rax*2]

; 179  :             } else {

  0027a	eb 16		 jmp	 SHORT $LN33@ucs2lib_fa@2
$LN31@ucs2lib_fa@2:

; 180  :                 /* skip: check if next character is part of pattern */
; 181  :                 if (!STRINGLIB_BLOOM(mask, s[i+m]))

  0027c	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
  00280	83 e0 1f	 and	 eax, 31
  00283	41 0f a3 c4	 bt	 r12d, eax
  00287	72 09		 jb	 SHORT $LN33@ucs2lib_fa@2
$LN102@ucs2lib_fa@2:

; 182  :                     i = i + m;

  00289	4c 03 ca	 add	 r9, rdx
  0028c	48 03 df	 add	 rbx, rdi
  0028f	4c 03 c7	 add	 r8, rdi
$LN33@ucs2lib_fa@2:

; 156  : 
; 157  :         for (i = 0; i <= w; i++) {

  00292	49 ff c1	 inc	 r9
  00295	48 83 c3 02	 add	 rbx, 2
  00299	49 83 c0 02	 add	 r8, 2
  0029d	4d 3b cb	 cmp	 r9, r11
  002a0	7f 33		 jg	 SHORT $LN94@ucs2lib_fa@2
  002a2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  002aa	e9 51 ff ff ff	 jmp	 $LL34@ucs2lib_fa@2
$LN79@ucs2lib_fa@2:

; 170  :                         return maxcount;

  002af	49 8b c6	 mov	 rax, r14
$LN101@ucs2lib_fa@2:
  002b2	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  002b7	4c 8b 6c 24 40	 mov	 r13, QWORD PTR [rsp+64]
$LN99@ucs2lib_fa@2:
  002bc	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR [rsp+128]

; 223  : }

  002c4	48 83 c4 50	 add	 rsp, 80			; 00000050H
  002c8	41 5f		 pop	 r15
  002ca	41 5e		 pop	 r14
  002cc	5e		 pop	 rsi
  002cd	5d		 pop	 rbp
  002ce	5b		 pop	 rbx
  002cf	c3		 ret	 0
$LN78@ucs2lib_fa@2:

; 167  :                         return i;

  002d0	49 8b c1	 mov	 rax, r9
  002d3	eb dd		 jmp	 SHORT $LN101@ucs2lib_fa@2
$LN94@ucs2lib_fa@2:

; 216  :             }
; 217  :         }
; 218  :     }
; 219  : 
; 220  :     if (mode != FAST_COUNT)

  002d5	45 85 ff	 test	 r15d, r15d
  002d8	0f 85 f2 00 00
	00		 jne	 $LN95@ucs2lib_fa@2

; 222  :     return count;

  002de	48 8b c6	 mov	 rax, rsi
  002e1	eb cf		 jmp	 SHORT $LN101@ucs2lib_fa@2
$LN39@ucs2lib_fa@2:

; 183  :             }
; 184  :         }
; 185  :     } else {    /* FAST_RSEARCH */
; 186  : 
; 187  :         /* create compressed boyer-moore delta 1 table */
; 188  : 
; 189  :         /* process pattern[0] outside the loop */
; 190  :         STRINGLIB_BLOOM_ADD(mask, p[0]);

  002e3	0f b7 75 00	 movzx	 esi, WORD PTR [rbp]
  002e7	44 8b d7	 mov	 r10d, edi

; 191  :         /* process pattern[:0:-1] */
; 192  :         for (i = mlast; i > 0; i--) {

  002ea	4d 8b cd	 mov	 r9, r13
  002ed	8b ce		 mov	 ecx, esi
  002ef	83 e1 1f	 and	 ecx, 31
  002f2	41 d3 e2	 shl	 r10d, cl
  002f5	4d 85 ed	 test	 r13, r13
  002f8	7e 3f		 jle	 SHORT $LN16@ucs2lib_fa@2
  002fa	66 0f 1f 44 00
	00		 npad	 6
$LL18@ucs2lib_fa@2:
  00300	46 0f b7 44 4d
	00		 movzx	 r8d, WORD PTR [rbp+r9*2]

; 193  :             STRINGLIB_BLOOM_ADD(mask, p[i]);

  00306	8b d7		 mov	 edx, edi
  00308	41 8b c8	 mov	 ecx, r8d
  0030b	83 e1 1f	 and	 ecx, 31
  0030e	d3 e2		 shl	 edx, cl
  00310	44 0b d2	 or	 r10d, edx

; 194  :             if (p[i] == p[0])

  00313	66 44 3b c6	 cmp	 r8w, si
  00317	75 0b		 jne	 SHORT $LN98@ucs2lib_fa@2

; 195  :                 skip = i - 1;

  00319	4d 8d 41 ff	 lea	 r8, QWORD PTR [r9-1]
  0031d	4c 89 44 24 30	 mov	 QWORD PTR skip$1$[rsp], r8
  00322	eb 05		 jmp	 SHORT $LN17@ucs2lib_fa@2
$LN98@ucs2lib_fa@2:
  00324	4c 8b 44 24 30	 mov	 r8, QWORD PTR skip$1$[rsp]
$LN17@ucs2lib_fa@2:

; 191  :         /* process pattern[:0:-1] */
; 192  :         for (i = mlast; i > 0; i--) {

  00329	49 ff c9	 dec	 r9
  0032c	4d 85 c9	 test	 r9, r9
  0032f	7f cf		 jg	 SHORT $LL18@ucs2lib_fa@2
  00331	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR m$[rsp]
$LN16@ucs2lib_fa@2:
  00339	4c 8b 64 24 30	 mov	 r12, QWORD PTR skip$1$[rsp]

; 196  :         }
; 197  : 
; 198  :         for (i = w; i >= 0; i--) {

  0033e	4b 8d 3c 00	 lea	 rdi, QWORD PTR [r8+r8]
  00342	4f 8d 04 1b	 lea	 r8, QWORD PTR [r11+r11]
  00346	4c 2b c5	 sub	 r8, rbp
  00349	4c 8d 0c 12	 lea	 r9, QWORD PTR [rdx+rdx]
  0034d	4c 03 c3	 add	 r8, rbx
$LL14@ucs2lib_fa@2:

; 199  :             if (s[i] == p[0]) {

  00350	66 42 39 34 5b	 cmp	 WORD PTR [rbx+r11*2], si
  00355	75 56		 jne	 SHORT $LN11@ucs2lib_fa@2

; 200  :                 /* candidate match */
; 201  :                 for (j = mlast; j > 0; j--)

  00357	49 8b d5	 mov	 rdx, r13
  0035a	4d 85 ed	 test	 r13, r13
  0035d	7e 1b		 jle	 SHORT $LN97@ucs2lib_fa@2
  0035f	4a 8d 4c 6d 00	 lea	 rcx, QWORD PTR [rbp+r13*2]
$LL10@ucs2lib_fa@2:

; 202  :                     if (s[i+j] != p[j])

  00364	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00367	66 41 39 04 08	 cmp	 WORD PTR [r8+rcx], ax
  0036c	75 0c		 jne	 SHORT $LN97@ucs2lib_fa@2

; 200  :                 /* candidate match */
; 201  :                 for (j = mlast; j > 0; j--)

  0036e	48 ff ca	 dec	 rdx
  00371	48 83 e9 02	 sub	 rcx, 2
  00375	48 85 d2	 test	 rdx, rdx
  00378	7f ea		 jg	 SHORT $LL10@ucs2lib_fa@2
$LN97@ucs2lib_fa@2:

; 203  :                         break;
; 204  :                 if (j == 0)

  0037a	48 85 d2	 test	 rdx, rdx
  0037d	74 5a		 je	 SHORT $LN81@ucs2lib_fa@2

; 207  :                 /* miss: check if previous character is part of pattern */
; 208  :                 if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))

  0037f	4d 85 db	 test	 r11, r11
  00382	7e 19		 jle	 SHORT $LN5@ucs2lib_fa@2
  00384	42 0f b7 44 5b
	fe		 movzx	 eax, WORD PTR [rbx+r11*2-2]
  0038a	83 e0 1f	 and	 eax, 31
  0038d	41 0f a3 c2	 bt	 r10d, eax
  00391	72 0a		 jb	 SHORT $LN5@ucs2lib_fa@2

; 209  :                     i = i - m;

  00393	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR m$[rsp]

; 210  :                 else

  0039b	eb 24		 jmp	 SHORT $LN103@ucs2lib_fa@2
$LN5@ucs2lib_fa@2:

; 211  :                     i = i - skip;
; 212  :             } else {

  0039d	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR m$[rsp]
  003a5	4d 2b dc	 sub	 r11, r12
  003a8	4c 2b c7	 sub	 r8, rdi
  003ab	eb 1a		 jmp	 SHORT $LN13@ucs2lib_fa@2
$LN11@ucs2lib_fa@2:

; 213  :                 /* skip: check if previous character is part of pattern */
; 214  :                 if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))

  003ad	4d 85 db	 test	 r11, r11
  003b0	7e 15		 jle	 SHORT $LN13@ucs2lib_fa@2
  003b2	42 0f b7 44 5b
	fe		 movzx	 eax, WORD PTR [rbx+r11*2-2]
  003b8	83 e0 1f	 and	 eax, 31
  003bb	41 0f a3 c2	 bt	 r10d, eax
  003bf	72 06		 jb	 SHORT $LN13@ucs2lib_fa@2
$LN103@ucs2lib_fa@2:

; 215  :                     i = i - m;

  003c1	4c 2b da	 sub	 r11, rdx
  003c4	4d 2b c1	 sub	 r8, r9
$LN13@ucs2lib_fa@2:

; 196  :         }
; 197  : 
; 198  :         for (i = w; i >= 0; i--) {

  003c7	49 83 e8 02	 sub	 r8, 2
  003cb	49 ff cb	 dec	 r11
  003ce	79 80		 jns	 SHORT $LL14@ucs2lib_fa@2
$LN95@ucs2lib_fa@2:

; 221  :         return -1;

  003d0	48 83 c8 ff	 or	 rax, -1
  003d4	e9 d9 fe ff ff	 jmp	 $LN101@ucs2lib_fa@2
$LN81@ucs2lib_fa@2:

; 205  :                     /* got a match! */
; 206  :                     return i;

  003d9	49 8b c3	 mov	 rax, r11
  003dc	e9 d1 fe ff ff	 jmp	 $LN101@ucs2lib_fa@2
$LN61@ucs2lib_fa@2:

; 95   :         return -1;

  003e1	48 83 c8 ff	 or	 rax, -1

; 223  : }

  003e5	48 83 c4 50	 add	 rsp, 80			; 00000050H
  003e9	41 5f		 pop	 r15
  003eb	41 5e		 pop	 r14
  003ed	5e		 pop	 rsi
  003ee	5d		 pop	 rbp
  003ef	5b		 pop	 rbx
  003f0	c3		 ret	 0
ucs2lib_fastsearch ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\count.h
pdata	SEGMENT
$pdata$ucs2lib_count DD imagerel ucs2lib_count
	DD	imagerel ucs2lib_count+40
	DD	imagerel $unwind$ucs2lib_count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ucs2lib_count DD imagerel ucs2lib_count+40
	DD	imagerel ucs2lib_count+73
	DD	imagerel $chain$0$ucs2lib_count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ucs2lib_count DD imagerel ucs2lib_count+73
	DD	imagerel ucs2lib_count+78
	DD	imagerel $chain$1$ucs2lib_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ucs2lib_count DD 021H
	DD	imagerel ucs2lib_count
	DD	imagerel ucs2lib_count+40
	DD	imagerel $unwind$ucs2lib_count
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ucs2lib_count DD 020521H
	DD	063405H
	DD	imagerel ucs2lib_count
	DD	imagerel ucs2lib_count+40
	DD	imagerel $unwind$ucs2lib_count
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_count DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs2lib_count
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
maxcount$ = 96
ucs2lib_count PROC					; COMDAT

; 11   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 12   :     Py_ssize_t count;
; 13   : 
; 14   :     if (str_len < 0)

  00004	48 85 d2	 test	 rdx, rdx
  00007	79 07		 jns	 SHORT $LN3@ucs2lib_co

; 15   :         return 0; /* start > len(str) */

  00009	33 c0		 xor	 eax, eax

; 22   :         return 0; /* no match */
; 23   : 
; 24   :     return count;
; 25   : }

  0000b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0000f	c3		 ret	 0
$LN3@ucs2lib_co:

; 16   :     if (sub_len == 0)
; 17   :         return (str_len < maxcount) ? str_len + 1 : maxcount;

  00010	48 8b 44 24 60	 mov	 rax, QWORD PTR maxcount$[rsp]
  00015	4d 85 c9	 test	 r9, r9
  00018	75 0e		 jne	 SHORT $LN2@ucs2lib_co
  0001a	48 3b d0	 cmp	 rdx, rax
  0001d	7d 2a		 jge	 SHORT $LN1@ucs2lib_co
  0001f	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]

; 22   :         return 0; /* no match */
; 23   : 
; 24   :     return count;
; 25   : }

  00023	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00027	c3		 ret	 0
$LN2@ucs2lib_co:
  00028	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 18   : 
; 19   :     count = FASTSEARCH(str, str_len, sub, sub_len, maxcount, FAST_COUNT);

  0002d	33 db		 xor	 ebx, ebx
  0002f	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  00033	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00038	e8 00 00 00 00	 call	 ucs2lib_fastsearch

; 20   : 
; 21   :     if (count < 0)

  0003d	48 85 c0	 test	 rax, rax
  00040	48 0f 48 c3	 cmovs	 rax, rbx
  00044	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN1@ucs2lib_co:

; 22   :         return 0; /* no match */
; 23   : 
; 24   :     return count;
; 25   : }

  00049	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004d	c3		 ret	 0
ucs2lib_count ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs2lib_find DD imagerel ucs2lib_find
	DD	imagerel ucs2lib_find+58
	DD	imagerel $unwind$ucs2lib_find
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ucs2lib_find DD imagerel ucs2lib_find+58
	DD	imagerel ucs2lib_find+303
	DD	imagerel $chain$4$ucs2lib_find
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$ucs2lib_find DD imagerel ucs2lib_find+303
	DD	imagerel ucs2lib_find+566
	DD	imagerel $chain$6$ucs2lib_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$ucs2lib_find DD 0a0021H
	DD	04f400H
	DD	05e400H
	DD	0d7400H
	DD	0c6400H
	DD	0a5400H
	DD	imagerel ucs2lib_find
	DD	imagerel ucs2lib_find+58
	DD	imagerel $unwind$ucs2lib_find
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ucs2lib_find DD 0a1c21H
	DD	04f41cH
	DD	05e417H
	DD	0d740fH
	DD	0c640aH
	DD	0a5405H
	DD	imagerel ucs2lib_find
	DD	imagerel ucs2lib_find+58
	DD	imagerel $unwind$ucs2lib_find
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_find DD 040a01H
	DD	0d006520aH
	DD	03002c004H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\find.h
xdata	ENDS
;	COMDAT ucs2lib_find
_TEXT	SEGMENT
str$ = 80
w$1$ = 88
str_len$ = 88
sub$ = 96
sub_len$ = 104
offset$ = 112
ucs2lib_find PROC					; COMDAT

; 11   : {

  00000	40 53		 push	 rbx
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	4d 8b e1	 mov	 r12, r9
  0000d	4d 8b e8	 mov	 r13, r8
  00010	48 8b d9	 mov	 rbx, rcx

; 12   :     Py_ssize_t pos;
; 13   : 
; 14   :     if (str_len < 0)

  00013	48 85 d2	 test	 rdx, rdx
  00016	79 0e		 jns	 SHORT $LN3@ucs2lib_fi

; 15   :         return -1;

  00018	48 83 c8 ff	 or	 rax, -1

; 25   : }

  0001c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00020	41 5d		 pop	 r13
  00022	41 5c		 pop	 r12
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
$LN3@ucs2lib_fi:

; 16   :     if (sub_len == 0)

  00026	4d 85 c9	 test	 r9, r9
  00029	75 0f		 jne	 SHORT $LN2@ucs2lib_fi

; 17   :         return offset;

  0002b	48 8b 44 24 70	 mov	 rax, QWORD PTR offset$[rsp]

; 25   : }

  00030	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00034	41 5d		 pop	 r13
  00036	41 5c		 pop	 r12
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
$LN2@ucs2lib_fi:
  0003a	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0003f	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00044	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi

; 18   : 
; 19   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_SEARCH);

  00049	48 8b ea	 mov	 rbp, rdx
  0004c	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00051	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00056	49 2b e9	 sub	 rbp, r9
  00059	48 89 6c 24 58	 mov	 QWORD PTR w$1$[rsp], rbp
  0005e	0f 88 a1 00 00
	00		 js	 $LN66@ucs2lib_fi
  00064	49 83 f9 01	 cmp	 r9, 1
  00068	0f 8f c1 00 00
	00		 jg	 $LN65@ucs2lib_fi
  0006e	4d 85 c9	 test	 r9, r9
  00071	0f 8e 8e 00 00
	00		 jle	 $LN66@ucs2lib_fi
  00077	48 83 fa 0a	 cmp	 rdx, 10
  0007b	7e 69		 jle	 SHORT $LN62@ucs2lib_fi
  0007d	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00081	84 c0		 test	 al, al
  00083	74 61		 je	 SHORT $LN62@ucs2lib_fi
  00085	41 0f b7 30	 movzx	 esi, WORD PTR [r8]
  00089	48 8d 3c 51	 lea	 rdi, QWORD PTR [rcx+rdx*2]
  0008d	4c 8b c9	 mov	 r9, rcx
  00090	48 3b cf	 cmp	 rcx, rdi
  00093	73 3d		 jae	 SHORT $LN74@ucs2lib_fi
  00095	0f b6 e8	 movzx	 ebp, al
  00098	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL75@ucs2lib_fi:
  000a0	4c 8b c7	 mov	 r8, rdi
  000a3	8b d5		 mov	 edx, ebp
  000a5	49 8b c9	 mov	 rcx, r9
  000a8	4d 2b c1	 sub	 r8, r9
  000ab	49 d1 f8	 sar	 r8, 1
  000ae	4d 03 c0	 add	 r8, r8
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000b7	4c 8b c8	 mov	 r9, rax
  000ba	48 85 c0	 test	 rax, rax
  000bd	74 13		 je	 SHORT $LN74@ucs2lib_fi
  000bf	49 83 e1 fe	 and	 r9, -2
  000c3	66 41 39 31	 cmp	 WORD PTR [r9], si
  000c7	74 12		 je	 SHORT $LN85@ucs2lib_fi
  000c9	49 83 c1 02	 add	 r9, 2
  000cd	4c 3b cf	 cmp	 r9, rdi
  000d0	72 ce		 jb	 SHORT $LL75@ucs2lib_fi
$LN74@ucs2lib_fi:
  000d2	49 83 c9 ff	 or	 r9, -1
  000d6	e9 48 01 00 00	 jmp	 $LN68@ucs2lib_fi
$LN85@ucs2lib_fi:
  000db	4c 2b cb	 sub	 r9, rbx
  000de	49 d1 f9	 sar	 r9, 1
  000e1	e9 3d 01 00 00	 jmp	 $LN68@ucs2lib_fi
$LN62@ucs2lib_fi:
  000e6	45 33 c9	 xor	 r9d, r9d
  000e9	48 85 d2	 test	 rdx, rdx
  000ec	7e 17		 jle	 SHORT $LN66@ucs2lib_fi
  000ee	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
$LL53@ucs2lib_fi:
  000f2	66 42 39 04 49	 cmp	 WORD PTR [rcx+r9*2], ax
  000f7	0f 84 26 01 00
	00		 je	 $LN68@ucs2lib_fi
  000fd	49 ff c1	 inc	 r9
  00100	4c 3b ca	 cmp	 r9, rdx
  00103	7c ed		 jl	 SHORT $LL53@ucs2lib_fi
$LN66@ucs2lib_fi:
  00105	49 83 c9 ff	 or	 r9, -1
$LN1@ucs2lib_fi:
  00109	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  0010e	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]
  00113	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00118	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0011d	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 23   : 
; 24   :     return pos;

  00122	49 8b c1	 mov	 rax, r9

; 25   : }

  00125	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00129	41 5d		 pop	 r13
  0012b	41 5c		 pop	 r12
  0012d	5b		 pop	 rbx
  0012e	c3		 ret	 0

; 18   : 
; 19   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_SEARCH);

$LN65@ucs2lib_fi:
  0012f	4d 8d 59 ff	 lea	 r11, QWORD PTR [r9-1]
  00133	45 33 c9	 xor	 r9d, r9d
  00136	4d 8d 7b ff	 lea	 r15, QWORD PTR [r11-1]
  0013a	45 8b f1	 mov	 r14d, r9d
  0013d	41 8b f9	 mov	 edi, r9d
  00140	45 8d 51 01	 lea	 r10d, QWORD PTR [r9+1]
  00144	4d 85 db	 test	 r11, r11
  00147	7e 34		 jle	 SHORT $LN41@ucs2lib_fi
  00149	43 0f b7 2c 58	 movzx	 ebp, WORD PTR [r8+r11*2]
  0014e	49 8b f7	 mov	 rsi, r15
$LL43@ucs2lib_fi:
  00151	45 0f b7 44 7d
	00		 movzx	 r8d, WORD PTR [r13+rdi*2]
  00157	41 8b d2	 mov	 edx, r10d
  0015a	41 8b c8	 mov	 ecx, r8d
  0015d	83 e1 1f	 and	 ecx, 31
  00160	d3 e2		 shl	 edx, cl
  00162	44 0b f2	 or	 r14d, edx
  00165	66 44 3b c5	 cmp	 r8w, bp
  00169	4c 0f 44 fe	 cmove	 r15, rsi
  0016d	48 ff c7	 inc	 rdi
  00170	48 ff ce	 dec	 rsi
  00173	49 3b fb	 cmp	 rdi, r11
  00176	7c d9		 jl	 SHORT $LL43@ucs2lib_fi
  00178	48 8b 6c 24 58	 mov	 rbp, QWORD PTR w$1$[rsp]
$LN41@ucs2lib_fi:
  0017d	43 0f b7 44 5d
	00		 movzx	 eax, WORD PTR [r13+r11*2]
  00183	83 e0 1f	 and	 eax, 31
  00186	0f b6 c8	 movzx	 ecx, al
  00189	41 d3 e2	 shl	 r10d, cl
  0018c	45 0b f2	 or	 r14d, r10d
  0018f	4d 8b d1	 mov	 r10, r9
  00192	48 85 ed	 test	 rbp, rbp
  00195	0f 88 6a ff ff
	ff		 js	 $LN66@ucs2lib_fi
  0019b	4b 8d 3c 24	 lea	 rdi, QWORD PTR [r12+r12]
  0019f	4b 8d 34 3f	 lea	 rsi, QWORD PTR [r15+r15]
  001a3	4c 8d 04 1f	 lea	 r8, QWORD PTR [rdi+rbx]
  001a7	49 2b dd	 sub	 rbx, r13
$LN97@ucs2lib_fi:
  001aa	42 0f b7 44 2f
	fe		 movzx	 eax, WORD PTR [rdi+r13-2]
  001b0	66 41 39 40 fe	 cmp	 WORD PTR [r8-2], ax
  001b5	75 3d		 jne	 SHORT $LN36@ucs2lib_fi
  001b7	49 8b d1	 mov	 rdx, r9
  001ba	4d 85 db	 test	 r11, r11
  001bd	7e 18		 jle	 SHORT $LN95@ucs2lib_fi
  001bf	49 8b cd	 mov	 rcx, r13
$LL35@ucs2lib_fi:
  001c2	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  001c5	66 39 04 0b	 cmp	 WORD PTR [rbx+rcx], ax
  001c9	75 0c		 jne	 SHORT $LN95@ucs2lib_fi
  001cb	48 ff c2	 inc	 rdx
  001ce	48 83 c1 02	 add	 rcx, 2
  001d2	49 3b d3	 cmp	 rdx, r11
  001d5	7c eb		 jl	 SHORT $LL35@ucs2lib_fi
$LN95@ucs2lib_fi:
  001d7	49 3b d3	 cmp	 rdx, r11
  001da	74 44		 je	 SHORT $LN88@ucs2lib_fi
  001dc	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
  001e0	83 e0 1f	 and	 eax, 31
  001e3	41 0f a3 c6	 bt	 r14d, eax
  001e7	73 18		 jae	 SHORT $LN96@ucs2lib_fi
  001e9	4d 03 d7	 add	 r10, r15
  001ec	48 03 de	 add	 rbx, rsi
  001ef	4c 03 c6	 add	 r8, rsi
  001f2	eb 16		 jmp	 SHORT $LN38@ucs2lib_fi
$LN36@ucs2lib_fi:
  001f4	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
  001f8	83 e0 1f	 and	 eax, 31
  001fb	41 0f a3 c6	 bt	 r14d, eax
  001ff	72 09		 jb	 SHORT $LN38@ucs2lib_fi
$LN96@ucs2lib_fi:
  00201	4d 03 d4	 add	 r10, r12
  00204	48 03 df	 add	 rbx, rdi
  00207	4c 03 c7	 add	 r8, rdi
$LN38@ucs2lib_fi:
  0020a	49 ff c2	 inc	 r10
  0020d	48 83 c3 02	 add	 rbx, 2
  00211	49 83 c0 02	 add	 r8, 2
  00215	4c 3b d5	 cmp	 r10, rbp
  00218	0f 8f e7 fe ff
	ff		 jg	 $LN66@ucs2lib_fi
  0021e	eb 8a		 jmp	 SHORT $LN97@ucs2lib_fi
$LN88@ucs2lib_fi:
  00220	4d 8b ca	 mov	 r9, r10
$LN68@ucs2lib_fi:

; 20   : 
; 21   :     if (pos >= 0)

  00223	4d 85 c9	 test	 r9, r9
  00226	0f 88 dd fe ff
	ff		 js	 $LN1@ucs2lib_fi

; 22   :         pos += offset;

  0022c	4c 03 4c 24 70	 add	 r9, QWORD PTR offset$[rsp]
  00231	e9 d3 fe ff ff	 jmp	 $LN1@ucs2lib_fi
ucs2lib_find ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs2lib_rfind DD imagerel ucs2lib_rfind
	DD	imagerel ucs2lib_rfind+55
	DD	imagerel $unwind$ucs2lib_rfind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ucs2lib_rfind DD imagerel ucs2lib_rfind+55
	DD	imagerel ucs2lib_rfind+168
	DD	imagerel $chain$4$ucs2lib_rfind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$ucs2lib_rfind DD imagerel ucs2lib_rfind+168
	DD	imagerel ucs2lib_rfind+405
	DD	imagerel $chain$6$ucs2lib_rfind
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$ucs2lib_rfind DD 0a0021H
	DD	0e400H
	DD	07d400H
	DD	067400H
	DD	056400H
	DD	045400H
	DD	imagerel ucs2lib_rfind
	DD	imagerel ucs2lib_rfind+55
	DD	imagerel $unwind$ucs2lib_rfind
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ucs2lib_rfind DD 0a1b21H
	DD	0e41bH
	DD	07d417H
	DD	06740fH
	DD	05640aH
	DD	045405H
	DD	imagerel ucs2lib_rfind
	DD	imagerel ucs2lib_rfind+55
	DD	imagerel $unwind$ucs2lib_rfind
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_rfind DD 030801H
	DD	0c0040208H
	DD	03002H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\find.h
xdata	ENDS
;	COMDAT ucs2lib_rfind
_TEXT	SEGMENT
str$ = 32
str_len$ = 40
sub$ = 48
sub_len$ = 56
offset$ = 64
ucs2lib_rfind PROC					; COMDAT

; 31   : {

  00000	40 53		 push	 rbx
  00002	41 54		 push	 r12
  00004	48 83 ec 08	 sub	 rsp, 8
  00008	4d 8b d9	 mov	 r11, r9
  0000b	4d 8b e0	 mov	 r12, r8
  0000e	48 8b d9	 mov	 rbx, rcx

; 32   :     Py_ssize_t pos;
; 33   : 
; 34   :     if (str_len < 0)

  00011	48 85 d2	 test	 rdx, rdx
  00014	79 0c		 jns	 SHORT $LN3@ucs2lib_rf

; 35   :         return -1;

  00016	48 83 c8 ff	 or	 rax, -1

; 43   : 
; 44   :     return pos;
; 45   : }

  0001a	48 83 c4 08	 add	 rsp, 8
  0001e	41 5c		 pop	 r12
  00020	5b		 pop	 rbx
  00021	c3		 ret	 0
$LN3@ucs2lib_rf:

; 36   :     if (sub_len == 0)

  00022	4d 85 c9	 test	 r9, r9
  00025	75 10		 jne	 SHORT $LN2@ucs2lib_rf

; 37   :         return str_len + offset;

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  0002c	48 03 c2	 add	 rax, rdx

; 43   : 
; 44   :     return pos;
; 45   : }

  0002f	48 83 c4 08	 add	 rsp, 8
  00033	41 5c		 pop	 r12
  00035	5b		 pop	 rbx
  00036	c3		 ret	 0
$LN2@ucs2lib_rf:
  00037	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0003c	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  00041	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 38   : 
; 39   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_RSEARCH);

  00046	4c 8b ca	 mov	 r9, rdx
  00049	4c 89 6c 24 38	 mov	 QWORD PTR [rsp+56], r13
  0004e	4c 89 34 24	 mov	 QWORD PTR [rsp], r14
  00052	4d 2b cb	 sub	 r9, r11
  00055	78 2d		 js	 SHORT $LN66@ucs2lib_rf
  00057	49 83 fb 01	 cmp	 r11, 1
  0005b	7f 4b		 jg	 SHORT $LN65@ucs2lib_rf
  0005d	4d 85 db	 test	 r11, r11
  00060	7e 22		 jle	 SHORT $LN66@ucs2lib_rf
  00062	4c 8d 4a ff	 lea	 r9, QWORD PTR [rdx-1]
  00066	49 83 f9 ff	 cmp	 r9, -1
  0006a	7e 18		 jle	 SHORT $LN66@ucs2lib_rf
  0006c	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
$LL48@ucs2lib_rf:
  00070	66 42 39 04 49	 cmp	 WORD PTR [rcx+r9*2], ax
  00075	0f 84 01 01 00
	00		 je	 $LN85@ucs2lib_rf
  0007b	49 ff c9	 dec	 r9
  0007e	49 83 f9 ff	 cmp	 r9, -1
  00082	7f ec		 jg	 SHORT $LL48@ucs2lib_rf
$LN66@ucs2lib_rf:
  00084	48 83 c8 ff	 or	 rax, -1
$LN1@ucs2lib_rf:
  00088	4c 8b 34 24	 mov	 r14, QWORD PTR [rsp]
  0008c	4c 8b 6c 24 38	 mov	 r13, QWORD PTR [rsp+56]
  00091	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00096	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  0009b	48 8b 6c 24 20	 mov	 rbp, QWORD PTR [rsp+32]

; 43   : 
; 44   :     return pos;
; 45   : }

  000a0	48 83 c4 08	 add	 rsp, 8
  000a4	41 5c		 pop	 r12
  000a6	5b		 pop	 rbx
  000a7	c3		 ret	 0

; 38   : 
; 39   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_RSEARCH);

$LN65@ucs2lib_rf:
  000a8	45 0f b7 30	 movzx	 r14d, WORD PTR [r8]
  000ac	49 8d 73 ff	 lea	 rsi, QWORD PTR [r11-1]
  000b0	bd 01 00 00 00	 mov	 ebp, 1
  000b5	41 8b ce	 mov	 ecx, r14d
  000b8	48 8d 7e ff	 lea	 rdi, QWORD PTR [rsi-1]
  000bc	4c 8b d6	 mov	 r10, rsi
  000bf	83 e1 1f	 and	 ecx, 31
  000c2	d3 e5		 shl	 ebp, cl
  000c4	48 85 f6	 test	 rsi, rsi
  000c7	7e 2d		 jle	 SHORT $LN21@ucs2lib_rf
  000c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL23@ucs2lib_rf:
  000d0	47 0f b7 04 54	 movzx	 r8d, WORD PTR [r12+r10*2]
  000d5	ba 01 00 00 00	 mov	 edx, 1
  000da	41 8b c8	 mov	 ecx, r8d
  000dd	83 e1 1f	 and	 ecx, 31
  000e0	d3 e2		 shl	 edx, cl
  000e2	0b ea		 or	 ebp, edx
  000e4	66 45 3b c6	 cmp	 r8w, r14w
  000e8	75 04		 jne	 SHORT $LN22@ucs2lib_rf
  000ea	49 8d 7a ff	 lea	 rdi, QWORD PTR [r10-1]
$LN22@ucs2lib_rf:
  000ee	49 ff ca	 dec	 r10
  000f1	4d 85 d2	 test	 r10, r10
  000f4	7f da		 jg	 SHORT $LL23@ucs2lib_rf
$LN21@ucs2lib_rf:
  000f6	4b 8d 14 09	 lea	 rdx, QWORD PTR [r9+r9]
  000fa	4f 8d 14 1b	 lea	 r10, QWORD PTR [r11+r11]
  000fe	4c 8d 2c 3f	 lea	 r13, QWORD PTR [rdi+rdi]
  00102	49 2b d4	 sub	 rdx, r12
  00105	48 03 d3	 add	 rdx, rbx
$LL19@ucs2lib_rf:
  00108	66 46 39 34 4b	 cmp	 WORD PTR [rbx+r9*2], r14w
  0010d	75 46		 jne	 SHORT $LN16@ucs2lib_rf
  0010f	4c 8b c6	 mov	 r8, rsi
  00112	48 85 f6	 test	 rsi, rsi
  00115	7e 1e		 jle	 SHORT $LN91@ucs2lib_rf
  00117	49 8d 0c 74	 lea	 rcx, QWORD PTR [r12+rsi*2]
  0011b	0f 1f 44 00 00	 npad	 5
$LL15@ucs2lib_rf:
  00120	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00123	66 39 04 0a	 cmp	 WORD PTR [rdx+rcx], ax
  00127	75 0c		 jne	 SHORT $LN91@ucs2lib_rf
  00129	49 ff c8	 dec	 r8
  0012c	48 83 e9 02	 sub	 rcx, 2
  00130	4d 85 c0	 test	 r8, r8
  00133	7f eb		 jg	 SHORT $LL15@ucs2lib_rf
$LN91@ucs2lib_rf:
  00135	4d 85 c0	 test	 r8, r8
  00138	74 42		 je	 SHORT $LN85@ucs2lib_rf
  0013a	4d 85 c9	 test	 r9, r9
  0013d	7e 0e		 jle	 SHORT $LN10@ucs2lib_rf
  0013f	42 0f b7 44 4b
	fe		 movzx	 eax, WORD PTR [rbx+r9*2-2]
  00145	83 e0 1f	 and	 eax, 31
  00148	0f a3 c5	 bt	 ebp, eax
  0014b	73 1b		 jae	 SHORT $LN92@ucs2lib_rf
$LN10@ucs2lib_rf:
  0014d	4c 2b cf	 sub	 r9, rdi
  00150	49 2b d5	 sub	 rdx, r13
  00153	eb 19		 jmp	 SHORT $LN18@ucs2lib_rf
$LN16@ucs2lib_rf:
  00155	4d 85 c9	 test	 r9, r9
  00158	7e 14		 jle	 SHORT $LN18@ucs2lib_rf
  0015a	42 0f b7 44 4b
	fe		 movzx	 eax, WORD PTR [rbx+r9*2-2]
  00160	83 e0 1f	 and	 eax, 31
  00163	0f a3 c5	 bt	 ebp, eax
  00166	72 06		 jb	 SHORT $LN18@ucs2lib_rf
$LN92@ucs2lib_rf:
  00168	4d 2b cb	 sub	 r9, r11
  0016b	49 2b d2	 sub	 rdx, r10
$LN18@ucs2lib_rf:
  0016e	48 83 ea 02	 sub	 rdx, 2
  00172	49 ff c9	 dec	 r9
  00175	79 91		 jns	 SHORT $LL19@ucs2lib_rf
  00177	e9 08 ff ff ff	 jmp	 $LN66@ucs2lib_rf
$LN85@ucs2lib_rf:
  0017c	49 8b c1	 mov	 rax, r9

; 40   : 
; 41   :     if (pos >= 0)

  0017f	4d 85 c9	 test	 r9, r9
  00182	0f 88 00 ff ff
	ff		 js	 $LN1@ucs2lib_rf

; 42   :         pos += offset;

  00188	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  0018d	49 03 c1	 add	 rax, r9
  00190	e9 f3 fe ff ff	 jmp	 $LN1@ucs2lib_rf
ucs2lib_rfind ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs2lib_find_slice DD imagerel ucs2lib_find_slice
	DD	imagerel ucs2lib_find_slice+76
	DD	imagerel $unwind$ucs2lib_find_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_find_slice DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs2lib_find_slice
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
start$ = 96
end$ = 104
ucs2lib_find_slice PROC					; COMDAT

; 66   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	4c 8b d2	 mov	 r10, rdx

; 67   :     ADJUST_INDICES(start, end, str_len);

  00007	48 8b 54 24 68	 mov	 rdx, QWORD PTR end$[rsp]
  0000c	45 33 db	 xor	 r11d, r11d
  0000f	49 3b d2	 cmp	 rdx, r10
  00012	7e 05		 jle	 SHORT $LN6@ucs2lib_fi@2
  00014	49 8b d2	 mov	 rdx, r10
  00017	eb 0c		 jmp	 SHORT $LN3@ucs2lib_fi@2
$LN6@ucs2lib_fi@2:
  00019	48 85 d2	 test	 rdx, rdx
  0001c	79 07		 jns	 SHORT $LN3@ucs2lib_fi@2
  0001e	49 03 d2	 add	 rdx, r10
  00021	49 0f 48 d3	 cmovs	 rdx, r11
$LN3@ucs2lib_fi@2:
  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0002a	48 85 c0	 test	 rax, rax
  0002d	79 07		 jns	 SHORT $LN1@ucs2lib_fi@2
  0002f	49 03 c2	 add	 rax, r10
  00032	49 0f 48 c3	 cmovs	 rax, r11
$LN1@ucs2lib_fi@2:

; 68   :     return STRINGLIB(find)(str + start, end - start, sub, sub_len, start);

  00036	48 8d 0c 41	 lea	 rcx, QWORD PTR [rcx+rax*2]
  0003a	48 2b d0	 sub	 rdx, rax
  0003d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00042	e8 00 00 00 00	 call	 ucs2lib_find

; 69   : }

  00047	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004b	c3		 ret	 0
ucs2lib_find_slice ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs2lib_rfind_slice DD imagerel ucs2lib_rfind_slice
	DD	imagerel ucs2lib_rfind_slice+76
	DD	imagerel $unwind$ucs2lib_rfind_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_rfind_slice DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs2lib_rfind_slice
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
start$ = 96
end$ = 104
ucs2lib_rfind_slice PROC				; COMDAT

; 75   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	4c 8b d2	 mov	 r10, rdx

; 76   :     ADJUST_INDICES(start, end, str_len);

  00007	48 8b 54 24 68	 mov	 rdx, QWORD PTR end$[rsp]
  0000c	45 33 db	 xor	 r11d, r11d
  0000f	49 3b d2	 cmp	 rdx, r10
  00012	7e 05		 jle	 SHORT $LN6@ucs2lib_rf@2
  00014	49 8b d2	 mov	 rdx, r10
  00017	eb 0c		 jmp	 SHORT $LN3@ucs2lib_rf@2
$LN6@ucs2lib_rf@2:
  00019	48 85 d2	 test	 rdx, rdx
  0001c	79 07		 jns	 SHORT $LN3@ucs2lib_rf@2
  0001e	49 03 d2	 add	 rdx, r10
  00021	49 0f 48 d3	 cmovs	 rdx, r11
$LN3@ucs2lib_rf@2:
  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0002a	48 85 c0	 test	 rax, rax
  0002d	79 07		 jns	 SHORT $LN1@ucs2lib_rf@2
  0002f	49 03 c2	 add	 rax, r10
  00032	49 0f 48 c3	 cmovs	 rax, r11
$LN1@ucs2lib_rf@2:

; 77   :     return STRINGLIB(rfind)(str + start, end - start, sub, sub_len, start);

  00036	48 8d 0c 41	 lea	 rcx, QWORD PTR [rcx+rax*2]
  0003a	48 2b d0	 sub	 rdx, rax
  0003d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00042	e8 00 00 00 00	 call	 ucs2lib_rfind

; 78   : }

  00047	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004b	c3		 ret	 0
ucs2lib_rfind_slice ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\find_max_char.h
_TEXT	ENDS
;	COMDAT ucs2lib_find_max_char
_TEXT	SEGMENT
begin$ = 8
end$ = 16
ucs2lib_find_max_char PROC				; COMDAT

; 60   : #if STRINGLIB_SIZEOF_CHAR == 2
; 61   :     const Py_UCS4 mask_limit = MASK_UCS1;
; 62   :     const Py_UCS4 max_char_limit = MAX_CHAR_UCS2;
; 63   : #elif STRINGLIB_SIZEOF_CHAR == 4
; 64   :     const Py_UCS4 mask_limit = MASK_UCS2;
; 65   :     const Py_UCS4 max_char_limit = MAX_CHAR_UCS4;
; 66   : #else
; 67   : #error Invalid STRINGLIB_SIZEOF_CHAR (must be 1, 2 or 4)
; 68   : #endif
; 69   :     register Py_UCS4 mask;
; 70   :     Py_ssize_t n = end - begin;

  00000	48 8b c2	 mov	 rax, rdx
  00003	4c 8b c9	 mov	 r9, rcx

; 71   :     const STRINGLIB_CHAR *p = begin;
; 72   :     const STRINGLIB_CHAR *unrolled_end = begin + _Py_SIZE_ROUND_DOWN(n, 4);
; 73   :     Py_UCS4 max_char;
; 74   : 
; 75   :     max_char = MAX_CHAR_ASCII;

  00006	41 ba 7f 00 00
	00		 mov	 r10d, 127		; 0000007fH
  0000c	48 2b c1	 sub	 rax, rcx

; 76   :     mask = MASK_ASCII;

  0000f	41 b8 80 ff ff
	ff		 mov	 r8d, -128		; ffffff80H
  00015	48 d1 f8	 sar	 rax, 1
  00018	48 83 e0 fc	 and	 rax, -4
  0001c	4c 8d 1c 41	 lea	 r11, QWORD PTR [rcx+rax*2]

; 77   :     while (p < unrolled_end) {

  00020	49 3b cb	 cmp	 rcx, r11
$LN25@ucs2lib_fi@3:
  00023	73 5e		 jae	 SHORT $LN18@ucs2lib_fi@3

; 78   :         STRINGLIB_CHAR bits = p[0] | p[1] | p[2] | p[3];
; 79   :         if (bits & mask) {

  00025	41 0f b7 41 04	 movzx	 eax, WORD PTR [r9+4]
  0002a	41 0f b7 49 06	 movzx	 ecx, WORD PTR [r9+6]
  0002f	0b c8		 or	 ecx, eax
  00031	41 0f b7 41 02	 movzx	 eax, WORD PTR [r9+2]
  00036	0b c8		 or	 ecx, eax
  00038	41 0f b7 01	 movzx	 eax, WORD PTR [r9]
  0003c	0b c8		 or	 ecx, eax
  0003e	41 85 c8	 test	 ecx, r8d
  00041	74 31		 je	 SHORT $LN10@ucs2lib_fi@3

; 80   :             if (mask == mask_limit) {

  00043	41 81 f8 00 ff
	ff ff		 cmp	 r8d, -256		; ffffff00H
  0004a	74 31		 je	 SHORT $LN19@ucs2lib_fi@3

; 83   :             }
; 84   :             if (mask == MASK_ASCII) {

  0004c	41 83 f8 80	 cmp	 r8d, -128		; ffffff80H
  00050	75 11		 jne	 SHORT $LN8@ucs2lib_fi@3

; 85   :                 max_char = MAX_CHAR_UCS1;

  00052	41 ba ff 00 00
	00		 mov	 r10d, 255		; 000000ffH

; 86   :                 mask = MASK_UCS1;

  00058	41 b8 00 ff ff
	ff		 mov	 r8d, -256		; ffffff00H
  0005e	4d 3b cb	 cmp	 r9, r11
  00061	eb c0		 jmp	 SHORT $LN25@ucs2lib_fi@3
$LN8@ucs2lib_fi@3:

; 87   :             }
; 88   :             else {
; 89   :                 /* mask can't be MASK_UCS2 because of mask_limit above */
; 90   :                 assert(mask == MASK_UCS1);
; 91   :                 max_char = MAX_CHAR_UCS2;

  00063	41 ba ff ff 00
	00		 mov	 r10d, 65535		; 0000ffffH

; 92   :                 mask = MASK_UCS2;

  00069	41 b8 00 00 ff
	ff		 mov	 r8d, -65536		; ffff0000H
  0006f	4d 3b cb	 cmp	 r9, r11
  00072	eb af		 jmp	 SHORT $LN25@ucs2lib_fi@3
$LN10@ucs2lib_fi@3:

; 93   :             }
; 94   :             /* We check the new mask on the same chars in the next iteration */
; 95   :             continue;
; 96   :         }
; 97   :         p += 4;

  00074	49 83 c1 08	 add	 r9, 8
  00078	4d 3b cb	 cmp	 r9, r11
  0007b	eb a6		 jmp	 SHORT $LN25@ucs2lib_fi@3
$LN19@ucs2lib_fi@3:

; 81   :                 /* Limit reached */
; 82   :                 return max_char_limit;

  0007d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 121  : }

  00082	c3		 ret	 0
$LN18@ucs2lib_fi@3:

; 98   :     }
; 99   :     while (p < end) {

  00083	4c 3b ca	 cmp	 r9, rdx
  00086	73 3a		 jae	 SHORT $LN24@ucs2lib_fi@3

; 100  :         if (p[0] & mask) {

  00088	41 0f b7 01	 movzx	 eax, WORD PTR [r9]
  0008c	41 85 c0	 test	 eax, r8d
  0008f	74 2b		 je	 SHORT $LN4@ucs2lib_fi@3

; 101  :             if (mask == mask_limit) {

  00091	41 81 f8 00 ff
	ff ff		 cmp	 r8d, -256		; ffffff00H
  00098	74 e3		 je	 SHORT $LN19@ucs2lib_fi@3

; 102  :                 /* Limit reached */
; 103  :                 return max_char_limit;
; 104  :             }
; 105  :             if (mask == MASK_ASCII) {

  0009a	41 83 f8 80	 cmp	 r8d, -128		; ffffff80H
  0009e	75 0e		 jne	 SHORT $LN2@ucs2lib_fi@3

; 106  :                 max_char = MAX_CHAR_UCS1;

  000a0	41 ba ff 00 00
	00		 mov	 r10d, 255		; 000000ffH

; 107  :                 mask = MASK_UCS1;

  000a6	41 b8 00 ff ff
	ff		 mov	 r8d, -256		; ffffff00H

; 108  :             }
; 109  :             else {

  000ac	eb d5		 jmp	 SHORT $LN18@ucs2lib_fi@3
$LN2@ucs2lib_fi@3:

; 110  :                 /* mask can't be MASK_UCS2 because of mask_limit above */
; 111  :                 assert(mask == MASK_UCS1);
; 112  :                 max_char = MAX_CHAR_UCS2;

  000ae	41 ba ff ff 00
	00		 mov	 r10d, 65535		; 0000ffffH

; 113  :                 mask = MASK_UCS2;

  000b4	41 b8 00 00 ff
	ff		 mov	 r8d, -65536		; ffff0000H

; 114  :             }
; 115  :             /* We check the new mask on the same chars in the next iteration */
; 116  :             continue;

  000ba	eb c7		 jmp	 SHORT $LN18@ucs2lib_fi@3
$LN4@ucs2lib_fi@3:

; 117  :         }
; 118  :         p++;

  000bc	49 83 c1 02	 add	 r9, 2

; 98   :     }
; 99   :     while (p < end) {

  000c0	eb c1		 jmp	 SHORT $LN18@ucs2lib_fi@3
$LN24@ucs2lib_fi@3:

; 119  :     }
; 120  :     return max_char;

  000c2	41 8b c2	 mov	 eax, r10d

; 121  : }

  000c5	c3		 ret	 0
ucs2lib_find_max_char ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\localeutil.h
_TEXT	ENDS
;	COMDAT ucs2lib_GroupGenerator_init
_TEXT	SEGMENT
self$ = 8
grouping$ = 16
ucs2lib_GroupGenerator_init PROC			; COMDAT

; 18   :     self->grouping = grouping;

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 19   :     self->i = 0;

  00003	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 20   :     self->previous = 0;

  0000b	c6 41 08 00	 mov	 BYTE PTR [rcx+8], 0

; 21   : }

  0000f	c3		 ret	 0
ucs2lib_GroupGenerator_init ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ucs2lib_GroupGenerator_next
_TEXT	SEGMENT
self$ = 8
ucs2lib_GroupGenerator_next PROC			; COMDAT

; 27   :     /* Note that we don't really do much error checking here. If a
; 28   :        grouping string contains just CHAR_MAX, for example, then just
; 29   :        terminate the generator. That shouldn't happen, but at least we
; 30   :        fail gracefully. */
; 31   :     switch (self->grouping[self->i]) {

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00007	41 0f b6 14 00	 movzx	 edx, BYTE PTR [r8+rax]
  0000c	0f b6 c2	 movzx	 eax, dl
  0000f	84 d2		 test	 dl, dl
  00011	74 17		 je	 SHORT $LN3@ucs2lib_Gr
  00013	3c 7f		 cmp	 al, 127			; 0000007fH
  00015	74 10		 je	 SHORT $LN2@ucs2lib_Gr

; 37   :     default: {
; 38   :         char ch = self->grouping[self->i];
; 39   :         self->previous = ch;
; 40   :         self->i++;

  00017	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]
  0001b	88 51 08	 mov	 BYTE PTR [rcx+8], dl
  0001e	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 41   :         return (Py_ssize_t)ch;

  00022	48 0f be c2	 movsx	 rax, dl

; 42   :     }
; 43   :     }
; 44   : }

  00026	c3		 ret	 0
$LN2@ucs2lib_Gr:

; 34   :     case CHAR_MAX:
; 35   :         /* Stop the generator. */
; 36   :         return 0;

  00027	33 c0		 xor	 eax, eax

; 42   :     }
; 43   :     }
; 44   : }

  00029	c3		 ret	 0
$LN3@ucs2lib_Gr:

; 32   :     case 0:
; 33   :         return self->previous;

  0002a	48 0f be 41 08	 movsx	 rax, BYTE PTR [rcx+8]

; 42   :     }
; 43   :     }
; 44   : }

  0002f	c3		 ret	 0
ucs2lib_GroupGenerator_next ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs2lib_fill DD imagerel ucs2lib_fill
	DD	imagerel ucs2lib_fill+149
	DD	imagerel $unwind$ucs2lib_fill
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_fill DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs2lib_fill
_TEXT	SEGMENT
digits_end$ = 48
buffer_end$ = 56
n_chars$ = 64
n_zeros$ = 72
thousands_sep$ = 80
thousands_sep_len$ = 88
ucs2lib_fill PROC					; COMDAT

; 52   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b da	 mov	 rbx, rdx

; 53   :     Py_ssize_t i;
; 54   : 
; 55   :     if (thousands_sep) {

  00017	48 8b 54 24 50	 mov	 rdx, QWORD PTR thousands_sep$[rsp]
  0001c	49 8b f9	 mov	 rdi, r9
  0001f	49 8b e8	 mov	 rbp, r8
  00022	48 8b f1	 mov	 rsi, rcx
  00025	48 85 d2	 test	 rdx, rdx
  00028	74 14		 je	 SHORT $LN4@ucs2lib_fi@4

; 56   :         *buffer_end -= thousands_sep_len;

  0002a	48 8b 44 24 58	 mov	 rax, QWORD PTR thousands_sep_len$[rsp]
  0002f	4c 8d 04 00	 lea	 r8, QWORD PTR [rax+rax]
  00033	4c 29 03	 sub	 QWORD PTR [rbx], r8

; 57   : 
; 58   :         /* Copy the thousands_sep chars into the buffer. */
; 59   :         memcpy(*buffer_end, thousands_sep,
; 60   :                thousands_sep_len * STRINGLIB_SIZEOF_CHAR);

  00036	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00039	e8 00 00 00 00	 call	 memcpy
$LN4@ucs2lib_fi@4:

; 61   :     }
; 62   : 
; 63   :     *buffer_end -= n_chars;

  0003e	4c 8d 44 2d 00	 lea	 r8, QWORD PTR [rbp+rbp]
  00043	4c 29 03	 sub	 QWORD PTR [rbx], r8

; 64   :     *digits_end -= n_chars;

  00046	4c 29 06	 sub	 QWORD PTR [rsi], r8

; 65   :     memcpy(*buffer_end, *digits_end, n_chars * sizeof(STRINGLIB_CHAR));

  00049	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  0004c	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0004f	e8 00 00 00 00	 call	 memcpy

; 66   : 
; 67   :     *buffer_end -= n_zeros;

  00054	4c 8b df	 mov	 r11, rdi

; 68   :     for (i = 0; i < n_zeros; i++)

  00057	33 c9		 xor	 ecx, ecx
  00059	49 f7 db	 neg	 r11
  0005c	4d 03 db	 add	 r11, r11
  0005f	4c 01 1b	 add	 QWORD PTR [rbx], r11
  00062	48 85 ff	 test	 rdi, rdi
  00065	7e 19		 jle	 SHORT $LN1@ucs2lib_fi@4
  00067	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  0006c	0f 1f 40 00	 npad	 4
$LL3@ucs2lib_fi@4:

; 69   :         (*buffer_end)[i] = '0';

  00070	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00073	48 ff c1	 inc	 rcx
  00076	66 89 54 48 fe	 mov	 WORD PTR [rax+rcx*2-2], dx
  0007b	48 3b cf	 cmp	 rcx, rdi
  0007e	7c f0		 jl	 SHORT $LL3@ucs2lib_fi@4
$LN1@ucs2lib_fi@4:

; 70   : }

  00080	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00085	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0008a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0008f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00093	5f		 pop	 rdi
  00094	c3		 ret	 0
ucs2lib_fill ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs2lib_InsertThousandsGrouping DD imagerel ucs2lib_InsertThousandsGrouping
	DD	imagerel ucs2lib_InsertThousandsGrouping+462
	DD	imagerel $unwind$ucs2lib_InsertThousandsGrouping
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_InsertThousandsGrouping DD 0b7001H
	DD	0a7470H
	DD	013546bH
	DD	0f00fa213H
	DD	0d00be00dH
	DD	06007c009H
	DD	03006H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs2lib_InsertThousandsGrouping
_TEXT	SEGMENT
digits_end$ = 48
groupgen$ = 56
buffer$ = 144
n_buffer$ = 152
digits$ = 160
buffer_end$ = 168
n_digits$ = 168
min_width$ = 176
grouping$ = 184
thousands_sep$ = 192
thousands_sep_len$ = 200
ucs2lib_InsertThousandsGrouping PROC			; COMDAT

; 112  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	56		 push	 rsi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	41 57		 push	 r15
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 113  :     Py_ssize_t count = 0;

  00013	45 33 e4	 xor	 r12d, r12d
  00016	48 8b c2	 mov	 rax, rdx

; 114  :     Py_ssize_t n_zeros;
; 115  :     int loop_broken = 0;
; 116  :     int use_separator = 0; /* First time through, don't append the
; 117  :                               separator. They only go between
; 118  :                               groups. */
; 119  :     STRINGLIB_CHAR *buffer_end = NULL;
; 120  :     STRINGLIB_CHAR *digits_end = NULL;
; 121  :     Py_ssize_t l;
; 122  :     Py_ssize_t n_chars;
; 123  :     Py_ssize_t remaining = n_digits; /* Number of chars remaining to
; 124  :                                         be looked at */
; 125  :     /* A generator that returns all of the grouping widths, until it
; 126  :        returns 0. */
; 127  :     STRINGLIB(GroupGenerator) groupgen;
; 128  :     STRINGLIB(GroupGenerator_init)(&groupgen, grouping);

  00019	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR grouping$[rsp]
  00021	4c 8b d9	 mov	 r11, rcx
  00024	48 8d 4c 24 38	 lea	 rcx, QWORD PTR groupgen$[rsp]
  00029	49 8b f1	 mov	 rsi, r9
  0002c	45 8b fc	 mov	 r15d, r12d
  0002f	45 8b d4	 mov	 r10d, r12d
  00032	4c 89 a4 24 a8
	00 00 00	 mov	 QWORD PTR buffer_end$[rsp], r12
  0003a	4c 89 64 24 30	 mov	 QWORD PTR digits_end$[rsp], r12
  0003f	e8 00 00 00 00	 call	 ucs2lib_GroupGenerator_init

; 129  : 
; 130  :     if (buffer) {

  00044	4d 85 db	 test	 r11, r11
  00047	74 15		 je	 SHORT $LN26@ucs2lib_In

; 131  :         buffer_end = buffer + n_buffer;

  00049	49 8d 04 43	 lea	 rax, QWORD PTR [r11+rax*2]
  0004d	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR buffer_end$[rsp], rax

; 132  :         digits_end = digits + n_digits;

  00055	4b 8d 04 48	 lea	 rax, QWORD PTR [r8+r9*2]
  00059	48 89 44 24 30	 mov	 QWORD PTR digits_end$[rsp], rax
$LN26@ucs2lib_In:

; 133  :     }
; 134  : 
; 135  :     while ((l = STRINGLIB(GroupGenerator_next)(&groupgen)) > 0) {

  0005e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR groupgen$[rsp]
  00063	48 89 ac 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rbp
  0006b	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00070	e8 00 00 00 00	 call	 ucs2lib_GroupGenerator_next
  00075	4c 8b b4 24 c8
	00 00 00	 mov	 r14, QWORD PTR thousands_sep_len$[rsp]
  0007d	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR min_width$[rsp]
  00085	41 bd 01 00 00
	00		 mov	 r13d, 1
$LN35@ucs2lib_In:
  0008b	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR thousands_sep$[rsp]
  00093	48 8b d8	 mov	 rbx, rax
  00096	48 85 c0	 test	 rax, rax
  00099	0f 8e ac 00 00
	00		 jle	 $LN29@ucs2lib_In

; 136  :         l = Py_MIN(l, Py_MAX(Py_MAX(remaining, min_width), 1));

  0009f	48 3b f7	 cmp	 rsi, rdi
  000a2	49 8b c5	 mov	 rax, r13
  000a5	48 8b cf	 mov	 rcx, rdi
  000a8	48 0f 4f ce	 cmovg	 rcx, rsi
  000ac	48 3b c8	 cmp	 rcx, rax
  000af	48 0f 4f c1	 cmovg	 rax, rcx
  000b3	48 3b d8	 cmp	 rbx, rax
  000b6	7e 0a		 jle	 SHORT $LN12@ucs2lib_In
  000b8	49 8b dd	 mov	 rbx, r13
  000bb	48 3b cb	 cmp	 rcx, rbx
  000be	48 0f 4f d9	 cmovg	 rbx, rcx
$LN12@ucs2lib_In:

; 137  :         n_zeros = Py_MAX(0, l - remaining);

  000c2	4c 8b cb	 mov	 r9, rbx

; 138  :         n_chars = Py_MAX(0, Py_MIN(remaining, l));

  000c5	48 8b ee	 mov	 rbp, rsi

; 139  : 
; 140  :         /* Use n_zero zero's and n_chars chars */
; 141  : 
; 142  :         /* Count only, don't do anything. */
; 143  :         count += (use_separator ? thousands_sep_len : 0) + n_zeros + n_chars;

  000c8	49 8b c4	 mov	 rax, r12
  000cb	4c 2b ce	 sub	 r9, rsi
  000ce	4d 0f 48 cc	 cmovs	 r9, r12
  000d2	48 3b f3	 cmp	 rsi, rbx
  000d5	48 0f 4f eb	 cmovg	 rbp, rbx
  000d9	48 85 ed	 test	 rbp, rbp
  000dc	49 0f 48 ec	 cmovs	 rbp, r12
  000e0	45 85 d2	 test	 r10d, r10d
  000e3	49 0f 45 c6	 cmovne	 rax, r14
  000e7	48 03 c5	 add	 rax, rbp
  000ea	49 03 c1	 add	 rax, r9
  000ed	4c 03 f8	 add	 r15, rax

; 144  : 
; 145  :         if (buffer) {

  000f0	4d 85 db	 test	 r11, r11
  000f3	74 31		 je	 SHORT $LN4@ucs2lib_In

; 146  :             /* Copy into the output buffer. */
; 147  :             STRINGLIB(fill)(&digits_end, &buffer_end, n_chars, n_zeros,
; 148  :                  use_separator ? thousands_sep : NULL, thousands_sep_len);

  000f5	45 85 d2	 test	 r10d, r10d
  000f8	49 8b c4	 mov	 rax, r12
  000fb	48 8d 4c 24 30	 lea	 rcx, QWORD PTR digits_end$[rsp]
  00100	48 0f 45 c2	 cmovne	 rax, rdx
  00104	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR buffer_end$[rsp]
  0010c	4c 8b c5	 mov	 r8, rbp
  0010f	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00114	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00119	e8 00 00 00 00	 call	 ucs2lib_fill
  0011e	4c 8b 9c 24 90
	00 00 00	 mov	 r11, QWORD PTR buffer$[rsp]
$LN4@ucs2lib_In:

; 149  :         }
; 150  : 
; 151  :         /* Use a separator next time. */
; 152  :         use_separator = 1;
; 153  : 
; 154  :         remaining -= n_chars;

  00126	48 2b f5	 sub	 rsi, rbp

; 155  :         min_width -= l;

  00129	48 2b fb	 sub	 rdi, rbx
  0012c	45 8b d5	 mov	 r10d, r13d

; 156  : 
; 157  :         if (remaining <= 0 && min_width <= 0) {

  0012f	48 85 f6	 test	 rsi, rsi
  00132	7f 05		 jg	 SHORT $LN3@ucs2lib_In
  00134	48 85 ff	 test	 rdi, rdi
  00137	7e 76		 jle	 SHORT $LN30@ucs2lib_In
$LN3@ucs2lib_In:

; 133  :     }
; 134  : 
; 135  :     while ((l = STRINGLIB(GroupGenerator_next)(&groupgen)) > 0) {

  00139	48 8d 4c 24 38	 lea	 rcx, QWORD PTR groupgen$[rsp]

; 158  :             loop_broken = 1;
; 159  :             break;
; 160  :         }
; 161  :         min_width -= thousands_sep_len;

  0013e	49 2b fe	 sub	 rdi, r14
  00141	e8 00 00 00 00	 call	 ucs2lib_GroupGenerator_next
  00146	e9 40 ff ff ff	 jmp	 $LN35@ucs2lib_In
$LN29@ucs2lib_In:

; 162  :     }
; 163  :     if (!loop_broken) {
; 164  :         /* We left the loop without using a break statement. */
; 165  : 
; 166  :         l = Py_MAX(Py_MAX(remaining, min_width), 1);

  0014b	48 3b f7	 cmp	 rsi, rdi

; 167  :         n_zeros = Py_MAX(0, l - remaining);
; 168  :         n_chars = Py_MAX(0, Py_MIN(remaining, l));
; 169  : 
; 170  :         /* Use n_zero zero's and n_chars chars */
; 171  :         count += (use_separator ? thousands_sep_len : 0) + n_zeros + n_chars;

  0014e	49 8b c4	 mov	 rax, r12
  00151	48 0f 4f fe	 cmovg	 rdi, rsi
  00155	49 3b fd	 cmp	 rdi, r13
  00158	4c 0f 4f ef	 cmovg	 r13, rdi
  0015c	4d 8b cd	 mov	 r9, r13
  0015f	4c 2b ce	 sub	 r9, rsi
  00162	4d 0f 48 cc	 cmovs	 r9, r12
  00166	49 3b f5	 cmp	 rsi, r13
  00169	49 0f 4f f5	 cmovg	 rsi, r13
  0016d	48 85 f6	 test	 rsi, rsi
  00170	49 0f 48 f4	 cmovs	 rsi, r12
  00174	45 85 d2	 test	 r10d, r10d
  00177	49 0f 45 c6	 cmovne	 rax, r14
  0017b	48 03 c6	 add	 rax, rsi
  0017e	49 03 c1	 add	 rax, r9
  00181	4c 03 f8	 add	 r15, rax

; 172  :         if (buffer) {

  00184	4d 85 db	 test	 r11, r11
  00187	74 26		 je	 SHORT $LN30@ucs2lib_In

; 173  :             /* Copy into the output buffer. */
; 174  :             STRINGLIB(fill)(&digits_end, &buffer_end, n_chars, n_zeros,
; 175  :                  use_separator ? thousands_sep : NULL, thousands_sep_len);

  00189	45 85 d2	 test	 r10d, r10d
  0018c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR digits_end$[rsp]
  00191	4c 8b c6	 mov	 r8, rsi
  00194	4c 0f 45 e2	 cmovne	 r12, rdx
  00198	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR buffer_end$[rsp]
  001a0	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  001a5	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  001aa	e8 00 00 00 00	 call	 ucs2lib_fill
$LN30@ucs2lib_In:

; 176  :         }
; 177  :     }
; 178  :     return count;

  001af	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  001b4	48 8b ac 24 98
	00 00 00	 mov	 rbp, QWORD PTR [rsp+152]
  001bc	49 8b c7	 mov	 rax, r15

; 179  : }

  001bf	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001c3	41 5f		 pop	 r15
  001c5	41 5e		 pop	 r14
  001c7	41 5d		 pop	 r13
  001c9	41 5c		 pop	 r12
  001cb	5e		 pop	 rsi
  001cc	5b		 pop	 rbx
  001cd	c3		 ret	 0
ucs2lib_InsertThousandsGrouping ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs4lib_fastsearch_memchr_1char DD imagerel ucs4lib_fastsearch_memchr_1char
	DD	imagerel ucs4lib_fastsearch_memchr_1char+23
	DD	imagerel $unwind$ucs4lib_fastsearch_memchr_1char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ucs4lib_fastsearch_memchr_1char DD imagerel ucs4lib_fastsearch_memchr_1char+23
	DD	imagerel ucs4lib_fastsearch_memchr_1char+117
	DD	imagerel $chain$1$ucs4lib_fastsearch_memchr_1char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ucs4lib_fastsearch_memchr_1char DD imagerel ucs4lib_fastsearch_memchr_1char+117
	DD	imagerel ucs4lib_fastsearch_memchr_1char+126
	DD	imagerel $chain$3$ucs4lib_fastsearch_memchr_1char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ucs4lib_fastsearch_memchr_1char DD imagerel ucs4lib_fastsearch_memchr_1char+126
	DD	imagerel ucs4lib_fastsearch_memchr_1char+139
	DD	imagerel $chain$4$ucs4lib_fastsearch_memchr_1char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ucs4lib_fastsearch_memchr_1char DD 021H
	DD	imagerel ucs4lib_fastsearch_memchr_1char
	DD	imagerel ucs4lib_fastsearch_memchr_1char+23
	DD	imagerel $unwind$ucs4lib_fastsearch_memchr_1char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ucs4lib_fastsearch_memchr_1char DD 040021H
	DD	075400H
	DD	063400H
	DD	imagerel ucs4lib_fastsearch_memchr_1char
	DD	imagerel ucs4lib_fastsearch_memchr_1char+23
	DD	imagerel $unwind$ucs4lib_fastsearch_memchr_1char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ucs4lib_fastsearch_memchr_1char DD 041121H
	DD	075411H
	DD	063405H
	DD	imagerel ucs4lib_fastsearch_memchr_1char
	DD	imagerel ucs4lib_fastsearch_memchr_1char+23
	DD	imagerel $unwind$ucs4lib_fastsearch_memchr_1char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_fastsearch_memchr_1char DD 040a01H
	DD	08640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs4lib_fastsearch_memchr_1char
_TEXT	SEGMENT
s$ = 48
n$ = 56
ch$ = 64
needle$ = 72
mode$ = 80
ucs4lib_fastsearch_memchr_1char PROC			; COMDAT

; 40   : {

  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 41   :     if (mode == FAST_SEARCH) {

  0000a	83 7c 24 50 01	 cmp	 DWORD PTR mode$[rsp], 1
  0000f	41 8b f0	 mov	 esi, r8d
  00012	48 8b f9	 mov	 rdi, rcx
  00015	75 67		 jne	 SHORT $LN7@ucs4lib_fa

; 42   :         const STRINGLIB_CHAR *ptr = s;
; 43   :         const STRINGLIB_CHAR *e = s + n;

  00017	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0001c	48 8d 1c 91	 lea	 rbx, QWORD PTR [rcx+rdx*4]
  00020	48 8b c1	 mov	 rax, rcx
  00023	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp

; 44   :         while (ptr < e) {

  00028	48 3b cb	 cmp	 rcx, rbx
  0002b	73 2f		 jae	 SHORT $LN5@ucs4lib_fa
  0002d	41 0f b6 e9	 movzx	 ebp, r9b
$LL6@ucs4lib_fa:

; 45   :             void *candidate = memchr((const void *) ptr, needle, (e - ptr) * sizeof(STRINGLIB_CHAR));

  00031	4c 8b c3	 mov	 r8, rbx
  00034	8b d5		 mov	 edx, ebp
  00036	48 8b c8	 mov	 rcx, rax
  00039	4c 2b c0	 sub	 r8, rax
  0003c	49 83 e0 fc	 and	 r8, -4
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr

; 46   :             if (candidate == NULL)

  00046	48 85 c0	 test	 rax, rax
  00049	74 11		 je	 SHORT $LN5@ucs4lib_fa

; 47   :                 return -1;
; 48   :             ptr = (const STRINGLIB_CHAR *) _Py_ALIGN_DOWN(candidate, sizeof(STRINGLIB_CHAR));

  0004b	48 83 e0 fc	 and	 rax, -4

; 49   :             if (sizeof(STRINGLIB_CHAR) == 1 || *ptr == ch)

  0004f	39 30		 cmp	 DWORD PTR [rax], esi
  00051	74 22		 je	 SHORT $LN12@ucs4lib_fa

; 51   :             /* False positive */
; 52   :             ptr++;

  00053	48 83 c0 04	 add	 rax, 4
  00057	48 3b c3	 cmp	 rax, rbx
  0005a	72 d5		 jb	 SHORT $LL6@ucs4lib_fa
$LN5@ucs4lib_fa:

; 53   :         }
; 54   :         return -1;

  0005c	48 83 c8 ff	 or	 rax, -1
$LN15@ucs4lib_fa:
  00060	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00065	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 78   :     }
; 79   : 
; 80   : #undef DO_MEMCHR
; 81   : }

  0006a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0006f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00073	5f		 pop	 rdi
  00074	c3		 ret	 0
$LN12@ucs4lib_fa:

; 50   :                 return (ptr - s);

  00075	48 2b c7	 sub	 rax, rdi
  00078	48 c1 f8 02	 sar	 rax, 2
  0007c	eb e2		 jmp	 SHORT $LN15@ucs4lib_fa
$LN7@ucs4lib_fa:

; 55   :     }
; 56   : #ifdef HAVE_MEMRCHR
; 57   :     /* memrchr() is a GNU extension, available since glibc 2.1.91.
; 58   :        it doesn't seem as optimized as memchr(), but is still quite
; 59   :        faster than our hand-written loop in FASTSEARCH below */
; 60   :     else if (mode == FAST_RSEARCH) {
; 61   :         while (n > 0) {
; 62   :             const STRINGLIB_CHAR *found;
; 63   :             void *candidate = memrchr((const void *) s, needle, n * sizeof(STRINGLIB_CHAR));
; 64   :             if (candidate == NULL)
; 65   :                 return -1;
; 66   :             found = (const STRINGLIB_CHAR *) _Py_ALIGN_DOWN(candidate, sizeof(STRINGLIB_CHAR));
; 67   :             n = found - s;
; 68   :             if (sizeof(STRINGLIB_CHAR) == 1 || *found == ch)
; 69   :                 return n;
; 70   :             /* False positive */
; 71   :         }
; 72   :         return -1;
; 73   :     }
; 74   : #endif
; 75   :     else {
; 76   :         assert(0); /* Should never get here */
; 77   :         return 0;

  0007e	33 c0		 xor	 eax, eax

; 78   :     }
; 79   : 
; 80   : #undef DO_MEMCHR
; 81   : }

  00080	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00085	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00089	5f		 pop	 rdi
  0008a	c3		 ret	 0
ucs4lib_fastsearch_memchr_1char ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs4lib_fastsearch DD imagerel ucs4lib_fastsearch
	DD	imagerel ucs4lib_fastsearch+75
	DD	imagerel $unwind$ucs4lib_fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ucs4lib_fastsearch DD imagerel ucs4lib_fastsearch+75
	DD	imagerel ucs4lib_fastsearch+291
	DD	imagerel $chain$0$ucs4lib_fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ucs4lib_fastsearch DD imagerel ucs4lib_fastsearch+291
	DD	imagerel ucs4lib_fastsearch+700
	DD	imagerel $chain$2$ucs4lib_fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ucs4lib_fastsearch DD imagerel ucs4lib_fastsearch+700
	DD	imagerel ucs4lib_fastsearch+720
	DD	imagerel $chain$3$ucs4lib_fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$ucs4lib_fastsearch DD imagerel ucs4lib_fastsearch+720
	DD	imagerel ucs4lib_fastsearch+1004
	DD	imagerel $chain$5$ucs4lib_fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$ucs4lib_fastsearch DD imagerel ucs4lib_fastsearch+1004
	DD	imagerel ucs4lib_fastsearch+1020
	DD	imagerel $chain$6$ucs4lib_fastsearch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$ucs4lib_fastsearch DD 021H
	DD	imagerel ucs4lib_fastsearch
	DD	imagerel ucs4lib_fastsearch+75
	DD	imagerel $unwind$ucs4lib_fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$ucs4lib_fastsearch DD 060021H
	DD	08d400H
	DD	09c400H
	DD	0107400H
	DD	imagerel ucs4lib_fastsearch
	DD	imagerel ucs4lib_fastsearch+75
	DD	imagerel $unwind$ucs4lib_fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ucs4lib_fastsearch DD 021H
	DD	imagerel ucs4lib_fastsearch+75
	DD	imagerel ucs4lib_fastsearch+291
	DD	imagerel $chain$0$ucs4lib_fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ucs4lib_fastsearch DD 040a21H
	DD	08d40aH
	DD	09c405H
	DD	imagerel ucs4lib_fastsearch+75
	DD	imagerel ucs4lib_fastsearch+291
	DD	imagerel $chain$0$ucs4lib_fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ucs4lib_fastsearch DD 020821H
	DD	0107408H
	DD	imagerel ucs4lib_fastsearch
	DD	imagerel ucs4lib_fastsearch+75
	DD	imagerel $unwind$ucs4lib_fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_fastsearch DD 061501H
	DD	0f0119215H
	DD	0600de00fH
	DD	0300b500cH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs4lib_fastsearch
_TEXT	SEGMENT
skip$1$ = 48
s$ = 128
mask$1$ = 136
n$ = 136
p$ = 144
m$ = 152
maxcount$ = 160
mode$ = 168
ucs4lib_fastsearch PROC					; COMDAT

; 87   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 88   :     unsigned long mask;
; 89   :     Py_ssize_t skip, count = 0;

  00015	45 33 d2	 xor	 r10d, r10d

; 90   :     Py_ssize_t i, j, mlast, w;
; 91   : 
; 92   :     w = n - m;

  00018	4c 8b da	 mov	 r11, rdx
  0001b	49 8b e8	 mov	 rbp, r8
  0001e	4d 2b d9	 sub	 r11, r9
  00021	48 8b d9	 mov	 rbx, rcx
  00024	41 8b f2	 mov	 esi, r10d

; 93   : 
; 94   :     if (w < 0 || (mode == FAST_COUNT && maxcount == 0))

  00027	0f 88 bf 03 00
	00		 js	 $LN61@ucs4lib_fa@2
  0002d	44 8b bc 24 a8
	00 00 00	 mov	 r15d, DWORD PTR mode$[rsp]
  00035	4c 8b b4 24 a0
	00 00 00	 mov	 r14, QWORD PTR maxcount$[rsp]
  0003d	45 85 ff	 test	 r15d, r15d
  00040	75 09		 jne	 SHORT $LN62@ucs4lib_fa@2
  00042	4d 85 f6	 test	 r14, r14
  00045	0f 84 a1 03 00
	00		 je	 $LN61@ucs4lib_fa@2
$LN62@ucs4lib_fa@2:
  0004b	48 89 bc 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rdi

; 96   : 
; 97   :     /* look for special cases */
; 98   :     if (m <= 1) {

  00053	49 83 f9 01	 cmp	 r9, 1
  00057	0f 8f be 00 00
	00		 jg	 $LN60@ucs4lib_fa@2

; 99   :         if (m <= 0)

  0005d	4d 85 c9	 test	 r9, r9

; 100  :             return -1;

  00060	0f 8e ac 00 00
	00		 jle	 $LN41@ucs4lib_fa@2

; 101  :         /* use special case for 1-character strings */
; 102  :         if (n > 10 && (mode == FAST_SEARCH
; 103  : #ifdef HAVE_MEMRCHR
; 104  :                     || mode == FAST_RSEARCH
; 105  : #endif
; 106  :                     )) {

  00066	48 83 fa 0a	 cmp	 rdx, 10
  0006a	7e 24		 jle	 SHORT $LN57@ucs4lib_fa@2
  0006c	41 83 ff 01	 cmp	 r15d, 1
  00070	75 1e		 jne	 SHORT $LN57@ucs4lib_fa@2

; 107  :             /* use memchr if we can choose a needle without two many likely
; 108  :                false positives */
; 109  :             unsigned char needle;
; 110  :             needle = p[0] & 0xff;

  00072	45 0f b6 08	 movzx	 r9d, BYTE PTR [r8]

; 111  : #if STRINGLIB_SIZEOF_CHAR > 1
; 112  :             /* If looking for a multiple of 256, we'd have too
; 113  :                many false positives looking for the '\0' byte in UCS2
; 114  :                and UCS4 representations. */
; 115  :             if (needle != 0)

  00076	45 84 c9	 test	 r9b, r9b
  00079	74 51		 je	 SHORT $LN91@ucs4lib_fa@2

; 116  : #endif
; 117  :                 return STRINGLIB(fastsearch_memchr_1char)
; 118  :                        (s, n, p[0], needle, maxcount, mode);

  0007b	45 8b 00	 mov	 r8d, DWORD PTR [r8]
  0007e	41 8b ff	 mov	 edi, r15d
  00081	44 89 7c 24 20	 mov	 DWORD PTR [rsp+32], r15d
  00086	e8 00 00 00 00	 call	 ucs4lib_fastsearch_memchr_1char
  0008b	e9 2c 02 00 00	 jmp	 $LN99@ucs4lib_fa@2
$LN57@ucs4lib_fa@2:

; 119  :         }
; 120  :         if (mode == FAST_COUNT) {

  00090	45 85 ff	 test	 r15d, r15d
  00093	75 31		 jne	 SHORT $LN56@ucs4lib_fa@2

; 121  :             for (i = 0; i < n; i++)

  00095	48 85 d2	 test	 rdx, rdx
  00098	7e 1c		 jle	 SHORT $LN93@ucs4lib_fa@2
  0009a	41 8b 00	 mov	 eax, DWORD PTR [r8]
  0009d	0f 1f 00	 npad	 3
$LL55@ucs4lib_fa@2:

; 122  :                 if (s[i] == p[0]) {

  000a0	42 39 04 91	 cmp	 DWORD PTR [rcx+r10*4], eax
  000a4	75 08		 jne	 SHORT $LN54@ucs4lib_fa@2

; 123  :                     count++;

  000a6	48 ff c6	 inc	 rsi

; 124  :                     if (count == maxcount)

  000a9	49 3b f6	 cmp	 rsi, r14
  000ac	74 10		 je	 SHORT $LN74@ucs4lib_fa@2
$LN54@ucs4lib_fa@2:

; 121  :             for (i = 0; i < n; i++)

  000ae	49 ff c2	 inc	 r10
  000b1	4c 3b d2	 cmp	 r10, rdx
  000b4	7c ea		 jl	 SHORT $LL55@ucs4lib_fa@2
$LN93@ucs4lib_fa@2:

; 126  :                 }
; 127  :             return count;

  000b6	48 8b c6	 mov	 rax, rsi
  000b9	e9 fe 01 00 00	 jmp	 $LN99@ucs4lib_fa@2
$LN74@ucs4lib_fa@2:

; 125  :                         return maxcount;

  000be	49 8b c6	 mov	 rax, r14
  000c1	e9 f6 01 00 00	 jmp	 $LN99@ucs4lib_fa@2
$LN56@ucs4lib_fa@2:

; 128  :         } else if (mode == FAST_SEARCH) {

  000c6	41 83 ff 01	 cmp	 r15d, 1
  000ca	75 27		 jne	 SHORT $LN49@ucs4lib_fa@2
$LN91@ucs4lib_fa@2:

; 129  :             for (i = 0; i < n; i++)

  000cc	48 85 d2	 test	 rdx, rdx
  000cf	7e 41		 jle	 SHORT $LN41@ucs4lib_fa@2
  000d1	41 8b 00	 mov	 eax, DWORD PTR [r8]
$LL48@ucs4lib_fa@2:

; 130  :                 if (s[i] == p[0])

  000d4	42 39 04 91	 cmp	 DWORD PTR [rcx+r10*4], eax
  000d8	74 11		 je	 SHORT $LN75@ucs4lib_fa@2

; 129  :             for (i = 0; i < n; i++)

  000da	49 ff c2	 inc	 r10
  000dd	4c 3b d2	 cmp	 r10, rdx
  000e0	7c f2		 jl	 SHORT $LL48@ucs4lib_fa@2

; 135  :                     return i;
; 136  :         }
; 137  :         return -1;

  000e2	48 83 c8 ff	 or	 rax, -1
  000e6	e9 d1 01 00 00	 jmp	 $LN99@ucs4lib_fa@2
$LN75@ucs4lib_fa@2:

; 131  :                     return i;

  000eb	49 8b c2	 mov	 rax, r10
  000ee	e9 c9 01 00 00	 jmp	 $LN99@ucs4lib_fa@2
$LN49@ucs4lib_fa@2:

; 132  :         } else {    /* FAST_RSEARCH */
; 133  :             for (i = n - 1; i > -1; i--)

  000f3	48 8d 42 ff	 lea	 rax, QWORD PTR [rdx-1]
  000f7	48 83 f8 ff	 cmp	 rax, -1
  000fb	7e 15		 jle	 SHORT $LN41@ucs4lib_fa@2
  000fd	41 8b 08	 mov	 ecx, DWORD PTR [r8]
$LL43@ucs4lib_fa@2:

; 134  :                 if (s[i] == p[0])

  00100	39 0c 83	 cmp	 DWORD PTR [rbx+rax*4], ecx
  00103	0f 84 b3 01 00
	00		 je	 $LN99@ucs4lib_fa@2

; 132  :         } else {    /* FAST_RSEARCH */
; 133  :             for (i = n - 1; i > -1; i--)

  00109	48 ff c8	 dec	 rax
  0010c	48 83 f8 ff	 cmp	 rax, -1
  00110	7f ee		 jg	 SHORT $LL43@ucs4lib_fa@2
$LN41@ucs4lib_fa@2:

; 135  :                     return i;
; 136  :         }
; 137  :         return -1;

  00112	48 83 c8 ff	 or	 rax, -1
  00116	e9 a1 01 00 00	 jmp	 $LN99@ucs4lib_fa@2
$LN60@ucs4lib_fa@2:

; 138  :     }
; 139  : 
; 140  :     mlast = m - 1;

  0011b	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR m$[rsp]
  00123	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  00128	4c 89 6c 24 40	 mov	 QWORD PTR [rsp+64], r13
  0012d	4c 8d 6a ff	 lea	 r13, QWORD PTR [rdx-1]

; 141  :     skip = mlast - 1;
; 142  :     mask = 0;

  00131	45 8b e2	 mov	 r12d, r10d

; 143  : 
; 144  :     if (mode != FAST_RSEARCH) {
; 145  : 
; 146  :         /* create compressed boyer-moore delta 1 table */
; 147  : 
; 148  :         /* process pattern[:-1] */
; 149  :         for (i = 0; i < mlast; i++) {

  00134	bf 01 00 00 00	 mov	 edi, 1
  00139	4d 8d 45 ff	 lea	 r8, QWORD PTR [r13-1]
  0013d	4c 89 44 24 30	 mov	 QWORD PTR skip$1$[rsp], r8
  00142	41 83 ff 02	 cmp	 r15d, 2
  00146	0f 84 97 01 00
	00		 je	 $LN39@ucs4lib_fa@2
  0014c	4d 8b ca	 mov	 r9, r10
  0014f	4d 85 ed	 test	 r13, r13
  00152	7e 6f		 jle	 SHORT $LN36@ucs4lib_fa@2
  00154	4c 8b bc 24 90
	00 00 00	 mov	 r15, QWORD PTR p$[rsp]
  0015c	49 8d 75 ff	 lea	 rsi, QWORD PTR [r13-1]
  00160	45 8b f1	 mov	 r14d, r9d
  00163	47 8b 24 af	 mov	 r12d, DWORD PTR [r15+r13*4]
  00167	48 8b ee	 mov	 rbp, rsi
  0016a	66 0f 1f 44 00
	00		 npad	 6
$LL38@ucs4lib_fa@2:
  00170	47 8b 04 8f	 mov	 r8d, DWORD PTR [r15+r9*4]

; 150  :             STRINGLIB_BLOOM_ADD(mask, p[i]);

  00174	8b d7		 mov	 edx, edi
  00176	41 8b c8	 mov	 ecx, r8d
  00179	83 e1 1f	 and	 ecx, 31
  0017c	d3 e2		 shl	 edx, cl
  0017e	44 0b f2	 or	 r14d, edx

; 151  :             if (p[i] == p[mlast])

  00181	45 3b c4	 cmp	 r8d, r12d
  00184	48 0f 44 f5	 cmove	 rsi, rbp
  00188	49 ff c1	 inc	 r9
  0018b	48 ff cd	 dec	 rbp
  0018e	4d 3b cd	 cmp	 r9, r13
  00191	7c dd		 jl	 SHORT $LL38@ucs4lib_fa@2
  00193	44 8b bc 24 a8
	00 00 00	 mov	 r15d, DWORD PTR mode$[rsp]
  0019b	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR m$[rsp]
  001a3	44 89 b4 24 88
	00 00 00	 mov	 DWORD PTR mask$1$[rsp], r14d
  001ab	44 8b a4 24 88
	00 00 00	 mov	 r12d, DWORD PTR mask$1$[rsp]
  001b3	4c 8b b4 24 a0
	00 00 00	 mov	 r14, QWORD PTR maxcount$[rsp]
  001bb	48 89 74 24 30	 mov	 QWORD PTR skip$1$[rsp], rsi
  001c0	49 8b f2	 mov	 rsi, r10
$LN36@ucs4lib_fa@2:

; 152  :                 skip = mlast - i - 1;
; 153  :         }
; 154  :         /* process pattern[-1] outside the loop */
; 155  :         STRINGLIB_BLOOM_ADD(mask, p[mlast]);

  001c3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  001cb	4a 8d 2c ad 00
	00 00 00	 lea	 rbp, QWORD PTR [r13*4]

; 156  : 
; 157  :         for (i = 0; i <= w; i++) {

  001d3	4d 8b ca	 mov	 r9, r10
  001d6	8b 0c 28	 mov	 ecx, DWORD PTR [rax+rbp]
  001d9	83 e1 1f	 and	 ecx, 31
  001dc	d3 e7		 shl	 edi, cl
  001de	44 0b e7	 or	 r12d, edi
  001e1	4d 85 db	 test	 r11, r11
  001e4	0f 88 eb 00 00
	00		 js	 $LN94@ucs4lib_fa@2

; 152  :                 skip = mlast - i - 1;
; 153  :         }
; 154  :         /* process pattern[-1] outside the loop */
; 155  :         STRINGLIB_BLOOM_ADD(mask, p[mlast]);

  001ea	48 8d 3c 95 00
	00 00 00	 lea	 rdi, QWORD PTR [rdx*4]
  001f2	4c 8d 04 1f	 lea	 r8, QWORD PTR [rdi+rbx]
  001f6	48 2b d8	 sub	 rbx, rax
  001f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL34@ucs4lib_fa@2:

; 158  :             /* note: using mlast in the skip path slows things down on x86 */
; 159  :             if (s[i+m-1] == p[m-1]) {

  00200	8b 4c 07 fc	 mov	 ecx, DWORD PTR [rdi+rax-4]
  00204	41 39 48 fc	 cmp	 DWORD PTR [r8-4], ecx
  00208	75 73		 jne	 SHORT $LN31@ucs4lib_fa@2

; 160  :                 /* candidate match */
; 161  :                 for (j = 0; j < mlast; j++)

  0020a	49 8b d2	 mov	 rdx, r10
  0020d	4d 85 ed	 test	 r13, r13
  00210	7e 16		 jle	 SHORT $LN96@ucs4lib_fa@2
  00212	48 8b c8	 mov	 rcx, rax
$LL30@ucs4lib_fa@2:

; 162  :                     if (s[i+j] != p[j])

  00215	8b 01		 mov	 eax, DWORD PTR [rcx]
  00217	39 04 0b	 cmp	 DWORD PTR [rbx+rcx], eax
  0021a	75 0c		 jne	 SHORT $LN96@ucs4lib_fa@2

; 160  :                 /* candidate match */
; 161  :                 for (j = 0; j < mlast; j++)

  0021c	48 ff c2	 inc	 rdx
  0021f	48 83 c1 04	 add	 rcx, 4
  00223	49 3b d5	 cmp	 rdx, r13
  00226	7c ed		 jl	 SHORT $LL30@ucs4lib_fa@2
$LN96@ucs4lib_fa@2:

; 163  :                         break;
; 164  :                 if (j == mlast) {

  00228	49 3b d5	 cmp	 rdx, r13
  0022b	75 24		 jne	 SHORT $LN26@ucs4lib_fa@2

; 165  :                     /* got a match! */
; 166  :                     if (mode != FAST_COUNT)

  0022d	45 85 ff	 test	 r15d, r15d
  00230	0f 85 9a 00 00
	00		 jne	 $LN78@ucs4lib_fa@2

; 168  :                     count++;

  00236	48 ff c6	 inc	 rsi

; 169  :                     if (count == maxcount)

  00239	49 3b f6	 cmp	 rsi, r14
  0023c	74 71		 je	 SHORT $LN79@ucs4lib_fa@2

; 171  :                     i = i + mlast;
; 172  :                     continue;

  0023e	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR m$[rsp]
  00246	4d 03 cd	 add	 r9, r13
  00249	48 03 dd	 add	 rbx, rbp
  0024c	4c 03 c5	 add	 r8, rbp
  0024f	eb 41		 jmp	 SHORT $LN33@ucs4lib_fa@2
$LN26@ucs4lib_fa@2:

; 173  :                 }
; 174  :                 /* miss: check if next character is part of pattern */
; 175  :                 if (!STRINGLIB_BLOOM(mask, s[i+m]))

  00251	41 8b 00	 mov	 eax, DWORD PTR [r8]

; 176  :                     i = i + m;

  00254	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR m$[rsp]
  0025c	83 e0 1f	 and	 eax, 31
  0025f	41 0f a3 c4	 bt	 r12d, eax

; 177  :                 else

  00263	73 24		 jae	 SHORT $LN102@ucs4lib_fa@2

; 178  :                     i = i + skip;

  00265	48 8b 44 24 30	 mov	 rax, QWORD PTR skip$1$[rsp]
  0026a	4c 03 c8	 add	 r9, rax
  0026d	48 8d 0c 85 00
	00 00 00	 lea	 rcx, QWORD PTR [rax*4]
  00275	48 03 d9	 add	 rbx, rcx
  00278	4c 03 c1	 add	 r8, rcx

; 179  :             } else {

  0027b	eb 15		 jmp	 SHORT $LN33@ucs4lib_fa@2
$LN31@ucs4lib_fa@2:

; 180  :                 /* skip: check if next character is part of pattern */
; 181  :                 if (!STRINGLIB_BLOOM(mask, s[i+m]))

  0027d	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00280	83 e0 1f	 and	 eax, 31
  00283	41 0f a3 c4	 bt	 r12d, eax
  00287	72 09		 jb	 SHORT $LN33@ucs4lib_fa@2
$LN102@ucs4lib_fa@2:

; 182  :                     i = i + m;

  00289	4c 03 ca	 add	 r9, rdx
  0028c	48 03 df	 add	 rbx, rdi
  0028f	4c 03 c7	 add	 r8, rdi
$LN33@ucs4lib_fa@2:

; 156  : 
; 157  :         for (i = 0; i <= w; i++) {

  00292	49 ff c1	 inc	 r9
  00295	48 83 c3 04	 add	 rbx, 4
  00299	49 83 c0 04	 add	 r8, 4
  0029d	4d 3b cb	 cmp	 r9, r11
  002a0	7f 33		 jg	 SHORT $LN94@ucs4lib_fa@2
  002a2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  002aa	e9 51 ff ff ff	 jmp	 $LL34@ucs4lib_fa@2
$LN79@ucs4lib_fa@2:

; 170  :                         return maxcount;

  002af	49 8b c6	 mov	 rax, r14
$LN101@ucs4lib_fa@2:
  002b2	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  002b7	4c 8b 6c 24 40	 mov	 r13, QWORD PTR [rsp+64]
$LN99@ucs4lib_fa@2:
  002bc	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR [rsp+128]

; 223  : }

  002c4	48 83 c4 50	 add	 rsp, 80			; 00000050H
  002c8	41 5f		 pop	 r15
  002ca	41 5e		 pop	 r14
  002cc	5e		 pop	 rsi
  002cd	5d		 pop	 rbp
  002ce	5b		 pop	 rbx
  002cf	c3		 ret	 0
$LN78@ucs4lib_fa@2:

; 167  :                         return i;

  002d0	49 8b c1	 mov	 rax, r9
  002d3	eb dd		 jmp	 SHORT $LN101@ucs4lib_fa@2
$LN94@ucs4lib_fa@2:

; 216  :             }
; 217  :         }
; 218  :     }
; 219  : 
; 220  :     if (mode != FAST_COUNT)

  002d5	45 85 ff	 test	 r15d, r15d
  002d8	0f 85 fd 00 00
	00		 jne	 $LN95@ucs4lib_fa@2

; 222  :     return count;

  002de	48 8b c6	 mov	 rax, rsi
  002e1	eb cf		 jmp	 SHORT $LN101@ucs4lib_fa@2
$LN39@ucs4lib_fa@2:

; 183  :             }
; 184  :         }
; 185  :     } else {    /* FAST_RSEARCH */
; 186  : 
; 187  :         /* create compressed boyer-moore delta 1 table */
; 188  : 
; 189  :         /* process pattern[0] outside the loop */
; 190  :         STRINGLIB_BLOOM_ADD(mask, p[0]);

  002e3	8b 75 00	 mov	 esi, DWORD PTR [rbp]
  002e6	44 8b d7	 mov	 r10d, edi

; 191  :         /* process pattern[:0:-1] */
; 192  :         for (i = mlast; i > 0; i--) {

  002e9	4d 8b cd	 mov	 r9, r13
  002ec	8b ce		 mov	 ecx, esi
  002ee	83 e1 1f	 and	 ecx, 31
  002f1	41 d3 e2	 shl	 r10d, cl
  002f4	4d 85 ed	 test	 r13, r13
  002f7	7e 3e		 jle	 SHORT $LN16@ucs4lib_fa@2
  002f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL18@ucs4lib_fa@2:
  00300	46 8b 44 8d 00	 mov	 r8d, DWORD PTR [rbp+r9*4]

; 193  :             STRINGLIB_BLOOM_ADD(mask, p[i]);

  00305	8b d7		 mov	 edx, edi
  00307	41 8b c8	 mov	 ecx, r8d
  0030a	83 e1 1f	 and	 ecx, 31
  0030d	d3 e2		 shl	 edx, cl
  0030f	44 0b d2	 or	 r10d, edx

; 194  :             if (p[i] == p[0])

  00312	44 3b c6	 cmp	 r8d, esi
  00315	75 0b		 jne	 SHORT $LN98@ucs4lib_fa@2

; 195  :                 skip = i - 1;

  00317	4d 8d 41 ff	 lea	 r8, QWORD PTR [r9-1]
  0031b	4c 89 44 24 30	 mov	 QWORD PTR skip$1$[rsp], r8
  00320	eb 05		 jmp	 SHORT $LN17@ucs4lib_fa@2
$LN98@ucs4lib_fa@2:
  00322	4c 8b 44 24 30	 mov	 r8, QWORD PTR skip$1$[rsp]
$LN17@ucs4lib_fa@2:

; 191  :         /* process pattern[:0:-1] */
; 192  :         for (i = mlast; i > 0; i--) {

  00327	49 ff c9	 dec	 r9
  0032a	4d 85 c9	 test	 r9, r9
  0032d	7f d1		 jg	 SHORT $LL18@ucs4lib_fa@2
  0032f	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR m$[rsp]
$LN16@ucs4lib_fa@2:
  00337	4c 8b 64 24 30	 mov	 r12, QWORD PTR skip$1$[rsp]

; 196  :         }
; 197  : 
; 198  :         for (i = w; i >= 0; i--) {

  0033c	4a 8d 3c 85 00
	00 00 00	 lea	 rdi, QWORD PTR [r8*4]
  00344	4e 8d 04 9d 00
	00 00 00	 lea	 r8, QWORD PTR [r11*4]
  0034c	4c 2b c5	 sub	 r8, rbp
  0034f	4c 8d 0c 95 00
	00 00 00	 lea	 r9, QWORD PTR [rdx*4]
  00357	4c 03 c3	 add	 r8, rbx
  0035a	66 0f 1f 44 00
	00		 npad	 6
$LL14@ucs4lib_fa@2:

; 199  :             if (s[i] == p[0]) {

  00360	42 39 34 9b	 cmp	 DWORD PTR [rbx+r11*4], esi
  00364	75 53		 jne	 SHORT $LN11@ucs4lib_fa@2

; 200  :                 /* candidate match */
; 201  :                 for (j = mlast; j > 0; j--)

  00366	49 8b d5	 mov	 rdx, r13
  00369	4d 85 ed	 test	 r13, r13
  0036c	7e 19		 jle	 SHORT $LN97@ucs4lib_fa@2
  0036e	4a 8d 4c ad 00	 lea	 rcx, QWORD PTR [rbp+r13*4]
$LL10@ucs4lib_fa@2:

; 202  :                     if (s[i+j] != p[j])

  00373	8b 01		 mov	 eax, DWORD PTR [rcx]
  00375	41 39 04 08	 cmp	 DWORD PTR [r8+rcx], eax
  00379	75 0c		 jne	 SHORT $LN97@ucs4lib_fa@2

; 200  :                 /* candidate match */
; 201  :                 for (j = mlast; j > 0; j--)

  0037b	48 ff ca	 dec	 rdx
  0037e	48 83 e9 04	 sub	 rcx, 4
  00382	48 85 d2	 test	 rdx, rdx
  00385	7f ec		 jg	 SHORT $LL10@ucs4lib_fa@2
$LN97@ucs4lib_fa@2:

; 203  :                         break;
; 204  :                 if (j == 0)

  00387	48 85 d2	 test	 rdx, rdx
  0038a	74 58		 je	 SHORT $LN81@ucs4lib_fa@2

; 207  :                 /* miss: check if previous character is part of pattern */
; 208  :                 if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))

  0038c	4d 85 db	 test	 r11, r11
  0038f	7e 18		 jle	 SHORT $LN5@ucs4lib_fa@2
  00391	42 8b 44 9b fc	 mov	 eax, DWORD PTR [rbx+r11*4-4]
  00396	83 e0 1f	 and	 eax, 31
  00399	41 0f a3 c2	 bt	 r10d, eax
  0039d	72 0a		 jb	 SHORT $LN5@ucs4lib_fa@2

; 209  :                     i = i - m;

  0039f	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR m$[rsp]

; 210  :                 else

  003a7	eb 23		 jmp	 SHORT $LN103@ucs4lib_fa@2
$LN5@ucs4lib_fa@2:

; 211  :                     i = i - skip;
; 212  :             } else {

  003a9	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR m$[rsp]
  003b1	4d 2b dc	 sub	 r11, r12
  003b4	4c 2b c7	 sub	 r8, rdi
  003b7	eb 19		 jmp	 SHORT $LN13@ucs4lib_fa@2
$LN11@ucs4lib_fa@2:

; 213  :                 /* skip: check if previous character is part of pattern */
; 214  :                 if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))

  003b9	4d 85 db	 test	 r11, r11
  003bc	7e 14		 jle	 SHORT $LN13@ucs4lib_fa@2
  003be	42 8b 44 9b fc	 mov	 eax, DWORD PTR [rbx+r11*4-4]
  003c3	83 e0 1f	 and	 eax, 31
  003c6	41 0f a3 c2	 bt	 r10d, eax
  003ca	72 06		 jb	 SHORT $LN13@ucs4lib_fa@2
$LN103@ucs4lib_fa@2:

; 215  :                     i = i - m;

  003cc	4c 2b da	 sub	 r11, rdx
  003cf	4d 2b c1	 sub	 r8, r9
$LN13@ucs4lib_fa@2:

; 196  :         }
; 197  : 
; 198  :         for (i = w; i >= 0; i--) {

  003d2	49 83 e8 04	 sub	 r8, 4
  003d6	49 ff cb	 dec	 r11
  003d9	79 85		 jns	 SHORT $LL14@ucs4lib_fa@2
$LN95@ucs4lib_fa@2:

; 221  :         return -1;

  003db	48 83 c8 ff	 or	 rax, -1
  003df	e9 ce fe ff ff	 jmp	 $LN101@ucs4lib_fa@2
$LN81@ucs4lib_fa@2:

; 205  :                     /* got a match! */
; 206  :                     return i;

  003e4	49 8b c3	 mov	 rax, r11
  003e7	e9 c6 fe ff ff	 jmp	 $LN101@ucs4lib_fa@2
$LN61@ucs4lib_fa@2:

; 95   :         return -1;

  003ec	48 83 c8 ff	 or	 rax, -1

; 223  : }

  003f0	48 83 c4 50	 add	 rsp, 80			; 00000050H
  003f4	41 5f		 pop	 r15
  003f6	41 5e		 pop	 r14
  003f8	5e		 pop	 rsi
  003f9	5d		 pop	 rbp
  003fa	5b		 pop	 rbx
  003fb	c3		 ret	 0
ucs4lib_fastsearch ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\count.h
pdata	SEGMENT
$pdata$ucs4lib_count DD imagerel ucs4lib_count
	DD	imagerel ucs4lib_count+40
	DD	imagerel $unwind$ucs4lib_count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ucs4lib_count DD imagerel ucs4lib_count+40
	DD	imagerel ucs4lib_count+73
	DD	imagerel $chain$0$ucs4lib_count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ucs4lib_count DD imagerel ucs4lib_count+73
	DD	imagerel ucs4lib_count+78
	DD	imagerel $chain$1$ucs4lib_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ucs4lib_count DD 021H
	DD	imagerel ucs4lib_count
	DD	imagerel ucs4lib_count+40
	DD	imagerel $unwind$ucs4lib_count
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ucs4lib_count DD 020521H
	DD	063405H
	DD	imagerel ucs4lib_count
	DD	imagerel ucs4lib_count+40
	DD	imagerel $unwind$ucs4lib_count
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_count DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs4lib_count
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
maxcount$ = 96
ucs4lib_count PROC					; COMDAT

; 11   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 12   :     Py_ssize_t count;
; 13   : 
; 14   :     if (str_len < 0)

  00004	48 85 d2	 test	 rdx, rdx
  00007	79 07		 jns	 SHORT $LN3@ucs4lib_co

; 15   :         return 0; /* start > len(str) */

  00009	33 c0		 xor	 eax, eax

; 22   :         return 0; /* no match */
; 23   : 
; 24   :     return count;
; 25   : }

  0000b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0000f	c3		 ret	 0
$LN3@ucs4lib_co:

; 16   :     if (sub_len == 0)
; 17   :         return (str_len < maxcount) ? str_len + 1 : maxcount;

  00010	48 8b 44 24 60	 mov	 rax, QWORD PTR maxcount$[rsp]
  00015	4d 85 c9	 test	 r9, r9
  00018	75 0e		 jne	 SHORT $LN2@ucs4lib_co
  0001a	48 3b d0	 cmp	 rdx, rax
  0001d	7d 2a		 jge	 SHORT $LN1@ucs4lib_co
  0001f	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]

; 22   :         return 0; /* no match */
; 23   : 
; 24   :     return count;
; 25   : }

  00023	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00027	c3		 ret	 0
$LN2@ucs4lib_co:
  00028	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 18   : 
; 19   :     count = FASTSEARCH(str, str_len, sub, sub_len, maxcount, FAST_COUNT);

  0002d	33 db		 xor	 ebx, ebx
  0002f	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  00033	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00038	e8 00 00 00 00	 call	 ucs4lib_fastsearch

; 20   : 
; 21   :     if (count < 0)

  0003d	48 85 c0	 test	 rax, rax
  00040	48 0f 48 c3	 cmovs	 rax, rbx
  00044	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN1@ucs4lib_co:

; 22   :         return 0; /* no match */
; 23   : 
; 24   :     return count;
; 25   : }

  00049	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004d	c3		 ret	 0
ucs4lib_count ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs4lib_find DD imagerel ucs4lib_find
	DD	imagerel ucs4lib_find+58
	DD	imagerel $unwind$ucs4lib_find
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ucs4lib_find DD imagerel ucs4lib_find+58
	DD	imagerel ucs4lib_find+300
	DD	imagerel $chain$4$ucs4lib_find
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$ucs4lib_find DD imagerel ucs4lib_find+300
	DD	imagerel ucs4lib_find+561
	DD	imagerel $chain$6$ucs4lib_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$ucs4lib_find DD 0a0021H
	DD	04f400H
	DD	05e400H
	DD	0d7400H
	DD	0c6400H
	DD	0a5400H
	DD	imagerel ucs4lib_find
	DD	imagerel ucs4lib_find+58
	DD	imagerel $unwind$ucs4lib_find
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ucs4lib_find DD 0a1c21H
	DD	04f41cH
	DD	05e417H
	DD	0d740fH
	DD	0c640aH
	DD	0a5405H
	DD	imagerel ucs4lib_find
	DD	imagerel ucs4lib_find+58
	DD	imagerel $unwind$ucs4lib_find
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_find DD 040a01H
	DD	0d006520aH
	DD	03002c004H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\find.h
xdata	ENDS
;	COMDAT ucs4lib_find
_TEXT	SEGMENT
str$ = 80
w$1$ = 88
str_len$ = 88
sub$ = 96
sub_len$ = 104
offset$ = 112
ucs4lib_find PROC					; COMDAT

; 11   : {

  00000	40 53		 push	 rbx
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	4d 8b e1	 mov	 r12, r9
  0000d	4d 8b e8	 mov	 r13, r8
  00010	48 8b d9	 mov	 rbx, rcx

; 12   :     Py_ssize_t pos;
; 13   : 
; 14   :     if (str_len < 0)

  00013	48 85 d2	 test	 rdx, rdx
  00016	79 0e		 jns	 SHORT $LN3@ucs4lib_fi

; 15   :         return -1;

  00018	48 83 c8 ff	 or	 rax, -1

; 25   : }

  0001c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00020	41 5d		 pop	 r13
  00022	41 5c		 pop	 r12
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
$LN3@ucs4lib_fi:

; 16   :     if (sub_len == 0)

  00026	4d 85 c9	 test	 r9, r9
  00029	75 0f		 jne	 SHORT $LN2@ucs4lib_fi

; 17   :         return offset;

  0002b	48 8b 44 24 70	 mov	 rax, QWORD PTR offset$[rsp]

; 25   : }

  00030	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00034	41 5d		 pop	 r13
  00036	41 5c		 pop	 r12
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
$LN2@ucs4lib_fi:
  0003a	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0003f	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00044	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi

; 18   : 
; 19   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_SEARCH);

  00049	48 8b ea	 mov	 rbp, rdx
  0004c	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00051	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00056	49 2b e9	 sub	 rbp, r9
  00059	48 89 6c 24 58	 mov	 QWORD PTR w$1$[rsp], rbp
  0005e	0f 88 9e 00 00
	00		 js	 $LN66@ucs4lib_fi
  00064	49 83 f9 01	 cmp	 r9, 1
  00068	0f 8f be 00 00
	00		 jg	 $LN65@ucs4lib_fi
  0006e	4d 85 c9	 test	 r9, r9
  00071	0f 8e 8b 00 00
	00		 jle	 $LN66@ucs4lib_fi
  00077	48 83 fa 0a	 cmp	 rdx, 10
  0007b	7e 67		 jle	 SHORT $LN62@ucs4lib_fi
  0007d	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00081	84 c0		 test	 al, al
  00083	74 5f		 je	 SHORT $LN62@ucs4lib_fi
  00085	41 8b 30	 mov	 esi, DWORD PTR [r8]
  00088	48 8d 3c 91	 lea	 rdi, QWORD PTR [rcx+rdx*4]
  0008c	4c 8b c9	 mov	 r9, rcx
  0008f	48 3b cf	 cmp	 rcx, rdi
  00092	73 3b		 jae	 SHORT $LN74@ucs4lib_fi
  00094	0f b6 e8	 movzx	 ebp, al
  00097	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL75@ucs4lib_fi:
  000a0	4c 8b c7	 mov	 r8, rdi
  000a3	8b d5		 mov	 edx, ebp
  000a5	49 8b c9	 mov	 rcx, r9
  000a8	4d 2b c1	 sub	 r8, r9
  000ab	49 83 e0 fc	 and	 r8, -4
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000b5	4c 8b c8	 mov	 r9, rax
  000b8	48 85 c0	 test	 rax, rax
  000bb	74 12		 je	 SHORT $LN74@ucs4lib_fi
  000bd	49 83 e1 fc	 and	 r9, -4
  000c1	41 39 31	 cmp	 DWORD PTR [r9], esi
  000c4	74 12		 je	 SHORT $LN85@ucs4lib_fi
  000c6	49 83 c1 04	 add	 r9, 4
  000ca	4c 3b cf	 cmp	 r9, rdi
  000cd	72 d1		 jb	 SHORT $LL75@ucs4lib_fi
$LN74@ucs4lib_fi:
  000cf	49 83 c9 ff	 or	 r9, -1
  000d3	e9 46 01 00 00	 jmp	 $LN68@ucs4lib_fi
$LN85@ucs4lib_fi:
  000d8	4c 2b cb	 sub	 r9, rbx
  000db	49 c1 f9 02	 sar	 r9, 2
  000df	e9 3a 01 00 00	 jmp	 $LN68@ucs4lib_fi
$LN62@ucs4lib_fi:
  000e4	45 33 c9	 xor	 r9d, r9d
  000e7	48 85 d2	 test	 rdx, rdx
  000ea	7e 16		 jle	 SHORT $LN66@ucs4lib_fi
  000ec	41 8b 00	 mov	 eax, DWORD PTR [r8]
  000ef	90		 npad	 1
$LL53@ucs4lib_fi:
  000f0	42 39 04 89	 cmp	 DWORD PTR [rcx+r9*4], eax
  000f4	0f 84 24 01 00
	00		 je	 $LN68@ucs4lib_fi
  000fa	49 ff c1	 inc	 r9
  000fd	4c 3b ca	 cmp	 r9, rdx
  00100	7c ee		 jl	 SHORT $LL53@ucs4lib_fi
$LN66@ucs4lib_fi:
  00102	49 83 c9 ff	 or	 r9, -1
$LN1@ucs4lib_fi:
  00106	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  0010b	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]
  00110	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00115	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0011a	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 23   : 
; 24   :     return pos;

  0011f	49 8b c1	 mov	 rax, r9

; 25   : }

  00122	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00126	41 5d		 pop	 r13
  00128	41 5c		 pop	 r12
  0012a	5b		 pop	 rbx
  0012b	c3		 ret	 0

; 18   : 
; 19   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_SEARCH);

$LN65@ucs4lib_fi:
  0012c	4d 8d 59 ff	 lea	 r11, QWORD PTR [r9-1]
  00130	45 33 c9	 xor	 r9d, r9d
  00133	4d 8d 7b ff	 lea	 r15, QWORD PTR [r11-1]
  00137	45 8b f1	 mov	 r14d, r9d
  0013a	41 8b f9	 mov	 edi, r9d
  0013d	45 8d 51 01	 lea	 r10d, QWORD PTR [r9+1]
  00141	4d 85 db	 test	 r11, r11
  00144	7e 34		 jle	 SHORT $LN41@ucs4lib_fi
  00146	43 8b 2c 98	 mov	 ebp, DWORD PTR [r8+r11*4]
  0014a	49 8b f7	 mov	 rsi, r15
  0014d	0f 1f 00	 npad	 3
$LL43@ucs4lib_fi:
  00150	45 8b 44 bd 00	 mov	 r8d, DWORD PTR [r13+rdi*4]
  00155	41 8b d2	 mov	 edx, r10d
  00158	41 8b c8	 mov	 ecx, r8d
  0015b	83 e1 1f	 and	 ecx, 31
  0015e	d3 e2		 shl	 edx, cl
  00160	44 0b f2	 or	 r14d, edx
  00163	44 3b c5	 cmp	 r8d, ebp
  00166	4c 0f 44 fe	 cmove	 r15, rsi
  0016a	48 ff c7	 inc	 rdi
  0016d	48 ff ce	 dec	 rsi
  00170	49 3b fb	 cmp	 rdi, r11
  00173	7c db		 jl	 SHORT $LL43@ucs4lib_fi
  00175	48 8b 6c 24 58	 mov	 rbp, QWORD PTR w$1$[rsp]
$LN41@ucs4lib_fi:
  0017a	43 8b 4c 9d 00	 mov	 ecx, DWORD PTR [r13+r11*4]
  0017f	83 e1 1f	 and	 ecx, 31
  00182	41 d3 e2	 shl	 r10d, cl
  00185	45 0b f2	 or	 r14d, r10d
  00188	4d 8b d1	 mov	 r10, r9
  0018b	48 85 ed	 test	 rbp, rbp
  0018e	0f 88 6e ff ff
	ff		 js	 $LN66@ucs4lib_fi
  00194	4a 8d 3c a5 00
	00 00 00	 lea	 rdi, QWORD PTR [r12*4]
  0019c	4a 8d 34 bd 00
	00 00 00	 lea	 rsi, QWORD PTR [r15*4]
  001a4	4c 8d 04 1f	 lea	 r8, QWORD PTR [rdi+rbx]
  001a8	49 2b dd	 sub	 rbx, r13
$LN97@ucs4lib_fi:
  001ab	42 8b 44 2f fc	 mov	 eax, DWORD PTR [rdi+r13-4]
  001b0	41 39 40 fc	 cmp	 DWORD PTR [r8-4], eax
  001b4	75 3a		 jne	 SHORT $LN36@ucs4lib_fi
  001b6	49 8b d1	 mov	 rdx, r9
  001b9	4d 85 db	 test	 r11, r11
  001bc	7e 16		 jle	 SHORT $LN95@ucs4lib_fi
  001be	49 8b cd	 mov	 rcx, r13
$LL35@ucs4lib_fi:
  001c1	8b 01		 mov	 eax, DWORD PTR [rcx]
  001c3	39 04 0b	 cmp	 DWORD PTR [rbx+rcx], eax
  001c6	75 0c		 jne	 SHORT $LN95@ucs4lib_fi
  001c8	48 ff c2	 inc	 rdx
  001cb	48 83 c1 04	 add	 rcx, 4
  001cf	49 3b d3	 cmp	 rdx, r11
  001d2	7c ed		 jl	 SHORT $LL35@ucs4lib_fi
$LN95@ucs4lib_fi:
  001d4	49 3b d3	 cmp	 rdx, r11
  001d7	74 42		 je	 SHORT $LN88@ucs4lib_fi
  001d9	41 8b 00	 mov	 eax, DWORD PTR [r8]
  001dc	83 e0 1f	 and	 eax, 31
  001df	41 0f a3 c6	 bt	 r14d, eax
  001e3	73 17		 jae	 SHORT $LN96@ucs4lib_fi
  001e5	4d 03 d7	 add	 r10, r15
  001e8	48 03 de	 add	 rbx, rsi
  001eb	4c 03 c6	 add	 r8, rsi
  001ee	eb 15		 jmp	 SHORT $LN38@ucs4lib_fi
$LN36@ucs4lib_fi:
  001f0	41 8b 00	 mov	 eax, DWORD PTR [r8]
  001f3	83 e0 1f	 and	 eax, 31
  001f6	41 0f a3 c6	 bt	 r14d, eax
  001fa	72 09		 jb	 SHORT $LN38@ucs4lib_fi
$LN96@ucs4lib_fi:
  001fc	4d 03 d4	 add	 r10, r12
  001ff	48 03 df	 add	 rbx, rdi
  00202	4c 03 c7	 add	 r8, rdi
$LN38@ucs4lib_fi:
  00205	49 ff c2	 inc	 r10
  00208	48 83 c3 04	 add	 rbx, 4
  0020c	49 83 c0 04	 add	 r8, 4
  00210	4c 3b d5	 cmp	 r10, rbp
  00213	0f 8f e9 fe ff
	ff		 jg	 $LN66@ucs4lib_fi
  00219	eb 90		 jmp	 SHORT $LN97@ucs4lib_fi
$LN88@ucs4lib_fi:
  0021b	4d 8b ca	 mov	 r9, r10
$LN68@ucs4lib_fi:

; 20   : 
; 21   :     if (pos >= 0)

  0021e	4d 85 c9	 test	 r9, r9
  00221	0f 88 df fe ff
	ff		 js	 $LN1@ucs4lib_fi

; 22   :         pos += offset;

  00227	4c 03 4c 24 70	 add	 r9, QWORD PTR offset$[rsp]
  0022c	e9 d5 fe ff ff	 jmp	 $LN1@ucs4lib_fi
ucs4lib_find ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs4lib_rfind DD imagerel ucs4lib_rfind
	DD	imagerel ucs4lib_rfind+55
	DD	imagerel $unwind$ucs4lib_rfind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ucs4lib_rfind DD imagerel ucs4lib_rfind+55
	DD	imagerel ucs4lib_rfind+167
	DD	imagerel $chain$4$ucs4lib_rfind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$ucs4lib_rfind DD imagerel ucs4lib_rfind+167
	DD	imagerel ucs4lib_rfind+405
	DD	imagerel $chain$6$ucs4lib_rfind
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$ucs4lib_rfind DD 0a0021H
	DD	0e400H
	DD	07d400H
	DD	067400H
	DD	056400H
	DD	045400H
	DD	imagerel ucs4lib_rfind
	DD	imagerel ucs4lib_rfind+55
	DD	imagerel $unwind$ucs4lib_rfind
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ucs4lib_rfind DD 0a1b21H
	DD	0e41bH
	DD	07d417H
	DD	06740fH
	DD	05640aH
	DD	045405H
	DD	imagerel ucs4lib_rfind
	DD	imagerel ucs4lib_rfind+55
	DD	imagerel $unwind$ucs4lib_rfind
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_rfind DD 030801H
	DD	0c0040208H
	DD	03002H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\find.h
xdata	ENDS
;	COMDAT ucs4lib_rfind
_TEXT	SEGMENT
str$ = 32
str_len$ = 40
sub$ = 48
sub_len$ = 56
offset$ = 64
ucs4lib_rfind PROC					; COMDAT

; 31   : {

  00000	40 53		 push	 rbx
  00002	41 54		 push	 r12
  00004	48 83 ec 08	 sub	 rsp, 8
  00008	4d 8b d9	 mov	 r11, r9
  0000b	4d 8b e0	 mov	 r12, r8
  0000e	48 8b d9	 mov	 rbx, rcx

; 32   :     Py_ssize_t pos;
; 33   : 
; 34   :     if (str_len < 0)

  00011	48 85 d2	 test	 rdx, rdx
  00014	79 0c		 jns	 SHORT $LN3@ucs4lib_rf

; 35   :         return -1;

  00016	48 83 c8 ff	 or	 rax, -1

; 43   : 
; 44   :     return pos;
; 45   : }

  0001a	48 83 c4 08	 add	 rsp, 8
  0001e	41 5c		 pop	 r12
  00020	5b		 pop	 rbx
  00021	c3		 ret	 0
$LN3@ucs4lib_rf:

; 36   :     if (sub_len == 0)

  00022	4d 85 c9	 test	 r9, r9
  00025	75 10		 jne	 SHORT $LN2@ucs4lib_rf

; 37   :         return str_len + offset;

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  0002c	48 03 c2	 add	 rax, rdx

; 43   : 
; 44   :     return pos;
; 45   : }

  0002f	48 83 c4 08	 add	 rsp, 8
  00033	41 5c		 pop	 r12
  00035	5b		 pop	 rbx
  00036	c3		 ret	 0
$LN2@ucs4lib_rf:
  00037	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0003c	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  00041	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 38   : 
; 39   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_RSEARCH);

  00046	4c 8b ca	 mov	 r9, rdx
  00049	4c 89 6c 24 38	 mov	 QWORD PTR [rsp+56], r13
  0004e	4c 89 34 24	 mov	 QWORD PTR [rsp], r14
  00052	4d 2b cb	 sub	 r9, r11
  00055	78 2c		 js	 SHORT $LN66@ucs4lib_rf
  00057	49 83 fb 01	 cmp	 r11, 1
  0005b	7f 4a		 jg	 SHORT $LN65@ucs4lib_rf
  0005d	4d 85 db	 test	 r11, r11
  00060	7e 21		 jle	 SHORT $LN66@ucs4lib_rf
  00062	4c 8d 4a ff	 lea	 r9, QWORD PTR [rdx-1]
  00066	49 83 f9 ff	 cmp	 r9, -1
  0006a	7e 17		 jle	 SHORT $LN66@ucs4lib_rf
  0006c	41 8b 00	 mov	 eax, DWORD PTR [r8]
  0006f	90		 npad	 1
$LL48@ucs4lib_rf:
  00070	42 39 04 89	 cmp	 DWORD PTR [rcx+r9*4], eax
  00074	0f 84 02 01 00
	00		 je	 $LN85@ucs4lib_rf
  0007a	49 ff c9	 dec	 r9
  0007d	49 83 f9 ff	 cmp	 r9, -1
  00081	7f ed		 jg	 SHORT $LL48@ucs4lib_rf
$LN66@ucs4lib_rf:
  00083	48 83 c8 ff	 or	 rax, -1
$LN1@ucs4lib_rf:
  00087	4c 8b 34 24	 mov	 r14, QWORD PTR [rsp]
  0008b	4c 8b 6c 24 38	 mov	 r13, QWORD PTR [rsp+56]
  00090	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00095	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  0009a	48 8b 6c 24 20	 mov	 rbp, QWORD PTR [rsp+32]

; 43   : 
; 44   :     return pos;
; 45   : }

  0009f	48 83 c4 08	 add	 rsp, 8
  000a3	41 5c		 pop	 r12
  000a5	5b		 pop	 rbx
  000a6	c3		 ret	 0

; 38   : 
; 39   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_RSEARCH);

$LN65@ucs4lib_rf:
  000a7	45 8b 30	 mov	 r14d, DWORD PTR [r8]
  000aa	49 8d 73 ff	 lea	 rsi, QWORD PTR [r11-1]
  000ae	bd 01 00 00 00	 mov	 ebp, 1
  000b3	41 8b ce	 mov	 ecx, r14d
  000b6	48 8d 7e ff	 lea	 rdi, QWORD PTR [rsi-1]
  000ba	4c 8b d6	 mov	 r10, rsi
  000bd	83 e1 1f	 and	 ecx, 31
  000c0	d3 e5		 shl	 ebp, cl
  000c2	48 85 f6	 test	 rsi, rsi
  000c5	7e 2d		 jle	 SHORT $LN21@ucs4lib_rf
  000c7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL23@ucs4lib_rf:
  000d0	47 8b 04 94	 mov	 r8d, DWORD PTR [r12+r10*4]
  000d4	ba 01 00 00 00	 mov	 edx, 1
  000d9	41 8b c8	 mov	 ecx, r8d
  000dc	83 e1 1f	 and	 ecx, 31
  000df	d3 e2		 shl	 edx, cl
  000e1	0b ea		 or	 ebp, edx
  000e3	45 3b c6	 cmp	 r8d, r14d
  000e6	75 04		 jne	 SHORT $LN22@ucs4lib_rf
  000e8	49 8d 7a ff	 lea	 rdi, QWORD PTR [r10-1]
$LN22@ucs4lib_rf:
  000ec	49 ff ca	 dec	 r10
  000ef	4d 85 d2	 test	 r10, r10
  000f2	7f dc		 jg	 SHORT $LL23@ucs4lib_rf
$LN21@ucs4lib_rf:
  000f4	4a 8d 14 8d 00
	00 00 00	 lea	 rdx, QWORD PTR [r9*4]
  000fc	4e 8d 14 9d 00
	00 00 00	 lea	 r10, QWORD PTR [r11*4]
  00104	4c 8d 2c bd 00
	00 00 00	 lea	 r13, QWORD PTR [rdi*4]
  0010c	49 2b d4	 sub	 rdx, r12
  0010f	48 03 d3	 add	 rdx, rbx
$LL19@ucs4lib_rf:
  00112	46 39 34 8b	 cmp	 DWORD PTR [rbx+r9*4], r14d
  00116	75 3e		 jne	 SHORT $LN16@ucs4lib_rf
  00118	4c 8b c6	 mov	 r8, rsi
  0011b	48 85 f6	 test	 rsi, rsi
  0011e	7e 17		 jle	 SHORT $LN91@ucs4lib_rf
  00120	49 8d 0c b4	 lea	 rcx, QWORD PTR [r12+rsi*4]
$LL15@ucs4lib_rf:
  00124	8b 01		 mov	 eax, DWORD PTR [rcx]
  00126	39 04 0a	 cmp	 DWORD PTR [rdx+rcx], eax
  00129	75 0c		 jne	 SHORT $LN91@ucs4lib_rf
  0012b	49 ff c8	 dec	 r8
  0012e	48 83 e9 04	 sub	 rcx, 4
  00132	4d 85 c0	 test	 r8, r8
  00135	7f ed		 jg	 SHORT $LL15@ucs4lib_rf
$LN91@ucs4lib_rf:
  00137	4d 85 c0	 test	 r8, r8
  0013a	74 40		 je	 SHORT $LN85@ucs4lib_rf
  0013c	4d 85 c9	 test	 r9, r9
  0013f	7e 0d		 jle	 SHORT $LN10@ucs4lib_rf
  00141	42 8b 44 8b fc	 mov	 eax, DWORD PTR [rbx+r9*4-4]
  00146	83 e0 1f	 and	 eax, 31
  00149	0f a3 c5	 bt	 ebp, eax
  0014c	73 1a		 jae	 SHORT $LN92@ucs4lib_rf
$LN10@ucs4lib_rf:
  0014e	4c 2b cf	 sub	 r9, rdi
  00151	49 2b d5	 sub	 rdx, r13
  00154	eb 18		 jmp	 SHORT $LN18@ucs4lib_rf
$LN16@ucs4lib_rf:
  00156	4d 85 c9	 test	 r9, r9
  00159	7e 13		 jle	 SHORT $LN18@ucs4lib_rf
  0015b	42 8b 44 8b fc	 mov	 eax, DWORD PTR [rbx+r9*4-4]
  00160	83 e0 1f	 and	 eax, 31
  00163	0f a3 c5	 bt	 ebp, eax
  00166	72 06		 jb	 SHORT $LN18@ucs4lib_rf
$LN92@ucs4lib_rf:
  00168	4d 2b cb	 sub	 r9, r11
  0016b	49 2b d2	 sub	 rdx, r10
$LN18@ucs4lib_rf:
  0016e	48 83 ea 04	 sub	 rdx, 4
  00172	49 ff c9	 dec	 r9
  00175	79 9b		 jns	 SHORT $LL19@ucs4lib_rf
  00177	e9 07 ff ff ff	 jmp	 $LN66@ucs4lib_rf
$LN85@ucs4lib_rf:
  0017c	49 8b c1	 mov	 rax, r9

; 40   : 
; 41   :     if (pos >= 0)

  0017f	4d 85 c9	 test	 r9, r9
  00182	0f 88 ff fe ff
	ff		 js	 $LN1@ucs4lib_rf

; 42   :         pos += offset;

  00188	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  0018d	49 03 c1	 add	 rax, r9
  00190	e9 f2 fe ff ff	 jmp	 $LN1@ucs4lib_rf
ucs4lib_rfind ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs4lib_find_slice DD imagerel ucs4lib_find_slice
	DD	imagerel ucs4lib_find_slice+76
	DD	imagerel $unwind$ucs4lib_find_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_find_slice DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs4lib_find_slice
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
start$ = 96
end$ = 104
ucs4lib_find_slice PROC					; COMDAT

; 66   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	4c 8b d2	 mov	 r10, rdx

; 67   :     ADJUST_INDICES(start, end, str_len);

  00007	48 8b 54 24 68	 mov	 rdx, QWORD PTR end$[rsp]
  0000c	45 33 db	 xor	 r11d, r11d
  0000f	49 3b d2	 cmp	 rdx, r10
  00012	7e 05		 jle	 SHORT $LN6@ucs4lib_fi@2
  00014	49 8b d2	 mov	 rdx, r10
  00017	eb 0c		 jmp	 SHORT $LN3@ucs4lib_fi@2
$LN6@ucs4lib_fi@2:
  00019	48 85 d2	 test	 rdx, rdx
  0001c	79 07		 jns	 SHORT $LN3@ucs4lib_fi@2
  0001e	49 03 d2	 add	 rdx, r10
  00021	49 0f 48 d3	 cmovs	 rdx, r11
$LN3@ucs4lib_fi@2:
  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0002a	48 85 c0	 test	 rax, rax
  0002d	79 07		 jns	 SHORT $LN1@ucs4lib_fi@2
  0002f	49 03 c2	 add	 rax, r10
  00032	49 0f 48 c3	 cmovs	 rax, r11
$LN1@ucs4lib_fi@2:

; 68   :     return STRINGLIB(find)(str + start, end - start, sub, sub_len, start);

  00036	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  0003a	48 2b d0	 sub	 rdx, rax
  0003d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00042	e8 00 00 00 00	 call	 ucs4lib_find

; 69   : }

  00047	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004b	c3		 ret	 0
ucs4lib_find_slice ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs4lib_rfind_slice DD imagerel ucs4lib_rfind_slice
	DD	imagerel ucs4lib_rfind_slice+76
	DD	imagerel $unwind$ucs4lib_rfind_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_rfind_slice DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs4lib_rfind_slice
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
start$ = 96
end$ = 104
ucs4lib_rfind_slice PROC				; COMDAT

; 75   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	4c 8b d2	 mov	 r10, rdx

; 76   :     ADJUST_INDICES(start, end, str_len);

  00007	48 8b 54 24 68	 mov	 rdx, QWORD PTR end$[rsp]
  0000c	45 33 db	 xor	 r11d, r11d
  0000f	49 3b d2	 cmp	 rdx, r10
  00012	7e 05		 jle	 SHORT $LN6@ucs4lib_rf@2
  00014	49 8b d2	 mov	 rdx, r10
  00017	eb 0c		 jmp	 SHORT $LN3@ucs4lib_rf@2
$LN6@ucs4lib_rf@2:
  00019	48 85 d2	 test	 rdx, rdx
  0001c	79 07		 jns	 SHORT $LN3@ucs4lib_rf@2
  0001e	49 03 d2	 add	 rdx, r10
  00021	49 0f 48 d3	 cmovs	 rdx, r11
$LN3@ucs4lib_rf@2:
  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0002a	48 85 c0	 test	 rax, rax
  0002d	79 07		 jns	 SHORT $LN1@ucs4lib_rf@2
  0002f	49 03 c2	 add	 rax, r10
  00032	49 0f 48 c3	 cmovs	 rax, r11
$LN1@ucs4lib_rf@2:

; 77   :     return STRINGLIB(rfind)(str + start, end - start, sub, sub_len, start);

  00036	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  0003a	48 2b d0	 sub	 rdx, rax
  0003d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00042	e8 00 00 00 00	 call	 ucs4lib_rfind

; 78   : }

  00047	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004b	c3		 ret	 0
ucs4lib_rfind_slice ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\find_max_char.h
_TEXT	ENDS
;	COMDAT ucs4lib_find_max_char
_TEXT	SEGMENT
begin$ = 8
end$ = 16
ucs4lib_find_max_char PROC				; COMDAT

; 60   : #if STRINGLIB_SIZEOF_CHAR == 2
; 61   :     const Py_UCS4 mask_limit = MASK_UCS1;
; 62   :     const Py_UCS4 max_char_limit = MAX_CHAR_UCS2;
; 63   : #elif STRINGLIB_SIZEOF_CHAR == 4
; 64   :     const Py_UCS4 mask_limit = MASK_UCS2;
; 65   :     const Py_UCS4 max_char_limit = MAX_CHAR_UCS4;
; 66   : #else
; 67   : #error Invalid STRINGLIB_SIZEOF_CHAR (must be 1, 2 or 4)
; 68   : #endif
; 69   :     register Py_UCS4 mask;
; 70   :     Py_ssize_t n = end - begin;

  00000	48 8b c2	 mov	 rax, rdx

; 71   :     const STRINGLIB_CHAR *p = begin;
; 72   :     const STRINGLIB_CHAR *unrolled_end = begin + _Py_SIZE_ROUND_DOWN(n, 4);
; 73   :     Py_UCS4 max_char;
; 74   : 
; 75   :     max_char = MAX_CHAR_ASCII;

  00003	41 b9 7f 00 00
	00		 mov	 r9d, 127		; 0000007fH

; 76   :     mask = MASK_ASCII;

  00009	41 b8 80 ff ff
	ff		 mov	 r8d, -128		; ffffff80H
  0000f	48 2b c1	 sub	 rax, rcx
  00012	48 c1 f8 02	 sar	 rax, 2
  00016	48 83 e0 fc	 and	 rax, -4
  0001a	4c 8d 14 81	 lea	 r10, QWORD PTR [rcx+rax*4]
$LN21@ucs4lib_fi@3:

; 77   :     while (p < unrolled_end) {

  0001e	49 3b ca	 cmp	 rcx, r10
  00021	73 47		 jae	 SHORT $LN18@ucs4lib_fi@3

; 78   :         STRINGLIB_CHAR bits = p[0] | p[1] | p[2] | p[3];

  00023	8b 41 0c	 mov	 eax, DWORD PTR [rcx+12]
  00026	0b 41 08	 or	 eax, DWORD PTR [rcx+8]
  00029	0b 41 04	 or	 eax, DWORD PTR [rcx+4]
  0002c	0b 01		 or	 eax, DWORD PTR [rcx]

; 79   :         if (bits & mask) {

  0002e	41 85 c0	 test	 eax, r8d
  00031	74 2b		 je	 SHORT $LN10@ucs4lib_fi@3

; 80   :             if (mask == mask_limit) {

  00033	41 81 f8 00 00
	ff ff		 cmp	 r8d, -65536		; ffff0000H
  0003a	74 28		 je	 SHORT $LN19@ucs4lib_fi@3

; 83   :             }
; 84   :             if (mask == MASK_ASCII) {

  0003c	41 83 f8 80	 cmp	 r8d, -128		; ffffff80H
  00040	75 0e		 jne	 SHORT $LN8@ucs4lib_fi@3

; 85   :                 max_char = MAX_CHAR_UCS1;

  00042	41 b9 ff 00 00
	00		 mov	 r9d, 255		; 000000ffH

; 86   :                 mask = MASK_UCS1;

  00048	41 b8 00 ff ff
	ff		 mov	 r8d, -256		; ffffff00H

; 87   :             }
; 88   :             else {

  0004e	eb ce		 jmp	 SHORT $LN21@ucs4lib_fi@3
$LN8@ucs4lib_fi@3:

; 89   :                 /* mask can't be MASK_UCS2 because of mask_limit above */
; 90   :                 assert(mask == MASK_UCS1);
; 91   :                 max_char = MAX_CHAR_UCS2;

  00050	41 b9 ff ff 00
	00		 mov	 r9d, 65535		; 0000ffffH

; 92   :                 mask = MASK_UCS2;

  00056	41 b8 00 00 ff
	ff		 mov	 r8d, -65536		; ffff0000H

; 93   :             }
; 94   :             /* We check the new mask on the same chars in the next iteration */
; 95   :             continue;

  0005c	eb c0		 jmp	 SHORT $LN21@ucs4lib_fi@3
$LN10@ucs4lib_fi@3:

; 96   :         }
; 97   :         p += 4;

  0005e	48 83 c1 10	 add	 rcx, 16

; 77   :     while (p < unrolled_end) {

  00062	eb ba		 jmp	 SHORT $LN21@ucs4lib_fi@3
$LN19@ucs4lib_fi@3:

; 81   :                 /* Limit reached */
; 82   :                 return max_char_limit;

  00064	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH

; 121  : }

  00069	c3		 ret	 0
$LN18@ucs4lib_fi@3:

; 98   :     }
; 99   :     while (p < end) {

  0006a	48 3b ca	 cmp	 rcx, rdx
  0006d	73 36		 jae	 SHORT $LN24@ucs4lib_fi@3

; 100  :         if (p[0] & mask) {

  0006f	44 85 01	 test	 DWORD PTR [rcx], r8d
  00072	74 2b		 je	 SHORT $LN4@ucs4lib_fi@3

; 101  :             if (mask == mask_limit) {

  00074	41 81 f8 00 00
	ff ff		 cmp	 r8d, -65536		; ffff0000H
  0007b	74 e7		 je	 SHORT $LN19@ucs4lib_fi@3

; 102  :                 /* Limit reached */
; 103  :                 return max_char_limit;
; 104  :             }
; 105  :             if (mask == MASK_ASCII) {

  0007d	41 83 f8 80	 cmp	 r8d, -128		; ffffff80H
  00081	75 0e		 jne	 SHORT $LN2@ucs4lib_fi@3

; 106  :                 max_char = MAX_CHAR_UCS1;

  00083	41 b9 ff 00 00
	00		 mov	 r9d, 255		; 000000ffH

; 107  :                 mask = MASK_UCS1;

  00089	41 b8 00 ff ff
	ff		 mov	 r8d, -256		; ffffff00H

; 108  :             }
; 109  :             else {

  0008f	eb d9		 jmp	 SHORT $LN18@ucs4lib_fi@3
$LN2@ucs4lib_fi@3:

; 110  :                 /* mask can't be MASK_UCS2 because of mask_limit above */
; 111  :                 assert(mask == MASK_UCS1);
; 112  :                 max_char = MAX_CHAR_UCS2;

  00091	41 b9 ff ff 00
	00		 mov	 r9d, 65535		; 0000ffffH

; 113  :                 mask = MASK_UCS2;

  00097	41 b8 00 00 ff
	ff		 mov	 r8d, -65536		; ffff0000H

; 114  :             }
; 115  :             /* We check the new mask on the same chars in the next iteration */
; 116  :             continue;

  0009d	eb cb		 jmp	 SHORT $LN18@ucs4lib_fi@3
$LN4@ucs4lib_fi@3:

; 117  :         }
; 118  :         p++;

  0009f	48 83 c1 04	 add	 rcx, 4

; 98   :     }
; 99   :     while (p < end) {

  000a3	eb c5		 jmp	 SHORT $LN18@ucs4lib_fi@3
$LN24@ucs4lib_fi@3:

; 119  :     }
; 120  :     return max_char;

  000a5	41 8b c1	 mov	 eax, r9d

; 121  : }

  000a8	c3		 ret	 0
ucs4lib_find_max_char ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\localeutil.h
_TEXT	ENDS
;	COMDAT ucs4lib_GroupGenerator_init
_TEXT	SEGMENT
self$ = 8
grouping$ = 16
ucs4lib_GroupGenerator_init PROC			; COMDAT

; 18   :     self->grouping = grouping;

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 19   :     self->i = 0;

  00003	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 20   :     self->previous = 0;

  0000b	c6 41 08 00	 mov	 BYTE PTR [rcx+8], 0

; 21   : }

  0000f	c3		 ret	 0
ucs4lib_GroupGenerator_init ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ucs4lib_GroupGenerator_next
_TEXT	SEGMENT
self$ = 8
ucs4lib_GroupGenerator_next PROC			; COMDAT

; 27   :     /* Note that we don't really do much error checking here. If a
; 28   :        grouping string contains just CHAR_MAX, for example, then just
; 29   :        terminate the generator. That shouldn't happen, but at least we
; 30   :        fail gracefully. */
; 31   :     switch (self->grouping[self->i]) {

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00007	41 0f b6 14 00	 movzx	 edx, BYTE PTR [r8+rax]
  0000c	0f b6 c2	 movzx	 eax, dl
  0000f	84 d2		 test	 dl, dl
  00011	74 17		 je	 SHORT $LN3@ucs4lib_Gr
  00013	3c 7f		 cmp	 al, 127			; 0000007fH
  00015	74 10		 je	 SHORT $LN2@ucs4lib_Gr

; 37   :     default: {
; 38   :         char ch = self->grouping[self->i];
; 39   :         self->previous = ch;
; 40   :         self->i++;

  00017	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]
  0001b	88 51 08	 mov	 BYTE PTR [rcx+8], dl
  0001e	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 41   :         return (Py_ssize_t)ch;

  00022	48 0f be c2	 movsx	 rax, dl

; 42   :     }
; 43   :     }
; 44   : }

  00026	c3		 ret	 0
$LN2@ucs4lib_Gr:

; 34   :     case CHAR_MAX:
; 35   :         /* Stop the generator. */
; 36   :         return 0;

  00027	33 c0		 xor	 eax, eax

; 42   :     }
; 43   :     }
; 44   : }

  00029	c3		 ret	 0
$LN3@ucs4lib_Gr:

; 32   :     case 0:
; 33   :         return self->previous;

  0002a	48 0f be 41 08	 movsx	 rax, BYTE PTR [rcx+8]

; 42   :     }
; 43   :     }
; 44   : }

  0002f	c3		 ret	 0
ucs4lib_GroupGenerator_next ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs4lib_fill DD imagerel ucs4lib_fill
	DD	imagerel ucs4lib_fill+152
	DD	imagerel $unwind$ucs4lib_fill
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_fill DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs4lib_fill
_TEXT	SEGMENT
digits_end$ = 48
buffer_end$ = 56
n_chars$ = 64
n_zeros$ = 72
thousands_sep$ = 80
thousands_sep_len$ = 88
ucs4lib_fill PROC					; COMDAT

; 52   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b da	 mov	 rbx, rdx

; 53   :     Py_ssize_t i;
; 54   : 
; 55   :     if (thousands_sep) {

  00017	48 8b 54 24 50	 mov	 rdx, QWORD PTR thousands_sep$[rsp]
  0001c	49 8b f9	 mov	 rdi, r9
  0001f	49 8b e8	 mov	 rbp, r8
  00022	48 8b f1	 mov	 rsi, rcx
  00025	48 85 d2	 test	 rdx, rdx
  00028	74 18		 je	 SHORT $LN4@ucs4lib_fi@4

; 56   :         *buffer_end -= thousands_sep_len;

  0002a	48 8b 44 24 58	 mov	 rax, QWORD PTR thousands_sep_len$[rsp]
  0002f	4c 8d 04 85 00
	00 00 00	 lea	 r8, QWORD PTR [rax*4]
  00037	4c 29 03	 sub	 QWORD PTR [rbx], r8

; 57   : 
; 58   :         /* Copy the thousands_sep chars into the buffer. */
; 59   :         memcpy(*buffer_end, thousands_sep,
; 60   :                thousands_sep_len * STRINGLIB_SIZEOF_CHAR);

  0003a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0003d	e8 00 00 00 00	 call	 memcpy
$LN4@ucs4lib_fi@4:

; 61   :     }
; 62   : 
; 63   :     *buffer_end -= n_chars;

  00042	4c 8d 04 ad 00
	00 00 00	 lea	 r8, QWORD PTR [rbp*4]
  0004a	4c 29 03	 sub	 QWORD PTR [rbx], r8

; 64   :     *digits_end -= n_chars;

  0004d	4c 29 06	 sub	 QWORD PTR [rsi], r8

; 65   :     memcpy(*buffer_end, *digits_end, n_chars * sizeof(STRINGLIB_CHAR));

  00050	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00053	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00056	e8 00 00 00 00	 call	 memcpy

; 66   : 
; 67   :     *buffer_end -= n_zeros;

  0005b	4c 8b df	 mov	 r11, rdi

; 68   :     for (i = 0; i < n_zeros; i++)

  0005e	33 c9		 xor	 ecx, ecx
  00060	49 f7 db	 neg	 r11
  00063	49 c1 e3 02	 shl	 r11, 2
  00067	4c 01 1b	 add	 QWORD PTR [rbx], r11
  0006a	48 85 ff	 test	 rdi, rdi
  0006d	7e 14		 jle	 SHORT $LN1@ucs4lib_fi@4
  0006f	90		 npad	 1
$LL3@ucs4lib_fi@4:

; 69   :         (*buffer_end)[i] = '0';

  00070	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00073	48 ff c1	 inc	 rcx
  00076	c7 44 88 fc 30
	00 00 00	 mov	 DWORD PTR [rax+rcx*4-4], 48 ; 00000030H
  0007e	48 3b cf	 cmp	 rcx, rdi
  00081	7c ed		 jl	 SHORT $LL3@ucs4lib_fi@4
$LN1@ucs4lib_fi@4:

; 70   : }

  00083	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00088	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0008d	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00092	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
ucs4lib_fill ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs4lib_InsertThousandsGrouping DD imagerel ucs4lib_InsertThousandsGrouping
	DD	imagerel ucs4lib_InsertThousandsGrouping+462
	DD	imagerel $unwind$ucs4lib_InsertThousandsGrouping
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_InsertThousandsGrouping DD 0b7001H
	DD	0a7470H
	DD	013546bH
	DD	0f00fa213H
	DD	0d00be00dH
	DD	06007c009H
	DD	03006H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs4lib_InsertThousandsGrouping
_TEXT	SEGMENT
digits_end$ = 48
groupgen$ = 56
buffer$ = 144
n_buffer$ = 152
digits$ = 160
buffer_end$ = 168
n_digits$ = 168
min_width$ = 176
grouping$ = 184
thousands_sep$ = 192
thousands_sep_len$ = 200
ucs4lib_InsertThousandsGrouping PROC			; COMDAT

; 112  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	56		 push	 rsi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	41 57		 push	 r15
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 113  :     Py_ssize_t count = 0;

  00013	45 33 e4	 xor	 r12d, r12d
  00016	48 8b c2	 mov	 rax, rdx

; 114  :     Py_ssize_t n_zeros;
; 115  :     int loop_broken = 0;
; 116  :     int use_separator = 0; /* First time through, don't append the
; 117  :                               separator. They only go between
; 118  :                               groups. */
; 119  :     STRINGLIB_CHAR *buffer_end = NULL;
; 120  :     STRINGLIB_CHAR *digits_end = NULL;
; 121  :     Py_ssize_t l;
; 122  :     Py_ssize_t n_chars;
; 123  :     Py_ssize_t remaining = n_digits; /* Number of chars remaining to
; 124  :                                         be looked at */
; 125  :     /* A generator that returns all of the grouping widths, until it
; 126  :        returns 0. */
; 127  :     STRINGLIB(GroupGenerator) groupgen;
; 128  :     STRINGLIB(GroupGenerator_init)(&groupgen, grouping);

  00019	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR grouping$[rsp]
  00021	4c 8b d9	 mov	 r11, rcx
  00024	48 8d 4c 24 38	 lea	 rcx, QWORD PTR groupgen$[rsp]
  00029	49 8b f1	 mov	 rsi, r9
  0002c	45 8b fc	 mov	 r15d, r12d
  0002f	45 8b d4	 mov	 r10d, r12d
  00032	4c 89 a4 24 a8
	00 00 00	 mov	 QWORD PTR buffer_end$[rsp], r12
  0003a	4c 89 64 24 30	 mov	 QWORD PTR digits_end$[rsp], r12
  0003f	e8 00 00 00 00	 call	 ucs4lib_GroupGenerator_init

; 129  : 
; 130  :     if (buffer) {

  00044	4d 85 db	 test	 r11, r11
  00047	74 15		 je	 SHORT $LN26@ucs4lib_In

; 131  :         buffer_end = buffer + n_buffer;

  00049	49 8d 04 83	 lea	 rax, QWORD PTR [r11+rax*4]
  0004d	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR buffer_end$[rsp], rax

; 132  :         digits_end = digits + n_digits;

  00055	4b 8d 04 88	 lea	 rax, QWORD PTR [r8+r9*4]
  00059	48 89 44 24 30	 mov	 QWORD PTR digits_end$[rsp], rax
$LN26@ucs4lib_In:

; 133  :     }
; 134  : 
; 135  :     while ((l = STRINGLIB(GroupGenerator_next)(&groupgen)) > 0) {

  0005e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR groupgen$[rsp]
  00063	48 89 ac 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rbp
  0006b	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00070	e8 00 00 00 00	 call	 ucs4lib_GroupGenerator_next
  00075	4c 8b b4 24 c8
	00 00 00	 mov	 r14, QWORD PTR thousands_sep_len$[rsp]
  0007d	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR min_width$[rsp]
  00085	41 bd 01 00 00
	00		 mov	 r13d, 1
$LN35@ucs4lib_In:
  0008b	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR thousands_sep$[rsp]
  00093	48 8b d8	 mov	 rbx, rax
  00096	48 85 c0	 test	 rax, rax
  00099	0f 8e ac 00 00
	00		 jle	 $LN29@ucs4lib_In

; 136  :         l = Py_MIN(l, Py_MAX(Py_MAX(remaining, min_width), 1));

  0009f	48 3b f7	 cmp	 rsi, rdi
  000a2	49 8b c5	 mov	 rax, r13
  000a5	48 8b cf	 mov	 rcx, rdi
  000a8	48 0f 4f ce	 cmovg	 rcx, rsi
  000ac	48 3b c8	 cmp	 rcx, rax
  000af	48 0f 4f c1	 cmovg	 rax, rcx
  000b3	48 3b d8	 cmp	 rbx, rax
  000b6	7e 0a		 jle	 SHORT $LN12@ucs4lib_In
  000b8	49 8b dd	 mov	 rbx, r13
  000bb	48 3b cb	 cmp	 rcx, rbx
  000be	48 0f 4f d9	 cmovg	 rbx, rcx
$LN12@ucs4lib_In:

; 137  :         n_zeros = Py_MAX(0, l - remaining);

  000c2	4c 8b cb	 mov	 r9, rbx

; 138  :         n_chars = Py_MAX(0, Py_MIN(remaining, l));

  000c5	48 8b ee	 mov	 rbp, rsi

; 139  : 
; 140  :         /* Use n_zero zero's and n_chars chars */
; 141  : 
; 142  :         /* Count only, don't do anything. */
; 143  :         count += (use_separator ? thousands_sep_len : 0) + n_zeros + n_chars;

  000c8	49 8b c4	 mov	 rax, r12
  000cb	4c 2b ce	 sub	 r9, rsi
  000ce	4d 0f 48 cc	 cmovs	 r9, r12
  000d2	48 3b f3	 cmp	 rsi, rbx
  000d5	48 0f 4f eb	 cmovg	 rbp, rbx
  000d9	48 85 ed	 test	 rbp, rbp
  000dc	49 0f 48 ec	 cmovs	 rbp, r12
  000e0	45 85 d2	 test	 r10d, r10d
  000e3	49 0f 45 c6	 cmovne	 rax, r14
  000e7	48 03 c5	 add	 rax, rbp
  000ea	49 03 c1	 add	 rax, r9
  000ed	4c 03 f8	 add	 r15, rax

; 144  : 
; 145  :         if (buffer) {

  000f0	4d 85 db	 test	 r11, r11
  000f3	74 31		 je	 SHORT $LN4@ucs4lib_In

; 146  :             /* Copy into the output buffer. */
; 147  :             STRINGLIB(fill)(&digits_end, &buffer_end, n_chars, n_zeros,
; 148  :                  use_separator ? thousands_sep : NULL, thousands_sep_len);

  000f5	45 85 d2	 test	 r10d, r10d
  000f8	49 8b c4	 mov	 rax, r12
  000fb	48 8d 4c 24 30	 lea	 rcx, QWORD PTR digits_end$[rsp]
  00100	48 0f 45 c2	 cmovne	 rax, rdx
  00104	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR buffer_end$[rsp]
  0010c	4c 8b c5	 mov	 r8, rbp
  0010f	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00114	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00119	e8 00 00 00 00	 call	 ucs4lib_fill
  0011e	4c 8b 9c 24 90
	00 00 00	 mov	 r11, QWORD PTR buffer$[rsp]
$LN4@ucs4lib_In:

; 149  :         }
; 150  : 
; 151  :         /* Use a separator next time. */
; 152  :         use_separator = 1;
; 153  : 
; 154  :         remaining -= n_chars;

  00126	48 2b f5	 sub	 rsi, rbp

; 155  :         min_width -= l;

  00129	48 2b fb	 sub	 rdi, rbx
  0012c	45 8b d5	 mov	 r10d, r13d

; 156  : 
; 157  :         if (remaining <= 0 && min_width <= 0) {

  0012f	48 85 f6	 test	 rsi, rsi
  00132	7f 05		 jg	 SHORT $LN3@ucs4lib_In
  00134	48 85 ff	 test	 rdi, rdi
  00137	7e 76		 jle	 SHORT $LN30@ucs4lib_In
$LN3@ucs4lib_In:

; 133  :     }
; 134  : 
; 135  :     while ((l = STRINGLIB(GroupGenerator_next)(&groupgen)) > 0) {

  00139	48 8d 4c 24 38	 lea	 rcx, QWORD PTR groupgen$[rsp]

; 158  :             loop_broken = 1;
; 159  :             break;
; 160  :         }
; 161  :         min_width -= thousands_sep_len;

  0013e	49 2b fe	 sub	 rdi, r14
  00141	e8 00 00 00 00	 call	 ucs4lib_GroupGenerator_next
  00146	e9 40 ff ff ff	 jmp	 $LN35@ucs4lib_In
$LN29@ucs4lib_In:

; 162  :     }
; 163  :     if (!loop_broken) {
; 164  :         /* We left the loop without using a break statement. */
; 165  : 
; 166  :         l = Py_MAX(Py_MAX(remaining, min_width), 1);

  0014b	48 3b f7	 cmp	 rsi, rdi

; 167  :         n_zeros = Py_MAX(0, l - remaining);
; 168  :         n_chars = Py_MAX(0, Py_MIN(remaining, l));
; 169  : 
; 170  :         /* Use n_zero zero's and n_chars chars */
; 171  :         count += (use_separator ? thousands_sep_len : 0) + n_zeros + n_chars;

  0014e	49 8b c4	 mov	 rax, r12
  00151	48 0f 4f fe	 cmovg	 rdi, rsi
  00155	49 3b fd	 cmp	 rdi, r13
  00158	4c 0f 4f ef	 cmovg	 r13, rdi
  0015c	4d 8b cd	 mov	 r9, r13
  0015f	4c 2b ce	 sub	 r9, rsi
  00162	4d 0f 48 cc	 cmovs	 r9, r12
  00166	49 3b f5	 cmp	 rsi, r13
  00169	49 0f 4f f5	 cmovg	 rsi, r13
  0016d	48 85 f6	 test	 rsi, rsi
  00170	49 0f 48 f4	 cmovs	 rsi, r12
  00174	45 85 d2	 test	 r10d, r10d
  00177	49 0f 45 c6	 cmovne	 rax, r14
  0017b	48 03 c6	 add	 rax, rsi
  0017e	49 03 c1	 add	 rax, r9
  00181	4c 03 f8	 add	 r15, rax

; 172  :         if (buffer) {

  00184	4d 85 db	 test	 r11, r11
  00187	74 26		 je	 SHORT $LN30@ucs4lib_In

; 173  :             /* Copy into the output buffer. */
; 174  :             STRINGLIB(fill)(&digits_end, &buffer_end, n_chars, n_zeros,
; 175  :                  use_separator ? thousands_sep : NULL, thousands_sep_len);

  00189	45 85 d2	 test	 r10d, r10d
  0018c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR digits_end$[rsp]
  00191	4c 8b c6	 mov	 r8, rsi
  00194	4c 0f 45 e2	 cmovne	 r12, rdx
  00198	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR buffer_end$[rsp]
  001a0	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  001a5	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  001aa	e8 00 00 00 00	 call	 ucs4lib_fill
$LN30@ucs4lib_In:

; 176  :         }
; 177  :     }
; 178  :     return count;

  001af	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  001b4	48 8b ac 24 98
	00 00 00	 mov	 rbp, QWORD PTR [rsp+152]
  001bc	49 8b c7	 mov	 rax, r15

; 179  : }

  001bf	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001c3	41 5f		 pop	 r15
  001c5	41 5e		 pop	 r14
  001c7	41 5d		 pop	 r13
  001c9	41 5c		 pop	 r12
  001cb	5e		 pop	 rsi
  001cc	5b		 pop	 rbx
  001cd	c3		 ret	 0
ucs4lib_InsertThousandsGrouping ENDP
_TEXT	ENDS
PUBLIC	??_C@_05BBAJLHME@O?$HMOO?3?$AA@			; `string'
EXTRN	_PyEval_SliceIndex:PROC
EXTRN	_PyArg_ParseTuple_SizeT:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\find.h
pdata	SEGMENT
$pdata$stringlib_parse_args_finds DD imagerel stringlib_parse_args_finds
	DD	imagerel stringlib_parse_args_finds+307
	DD	imagerel $unwind$stringlib_parse_args_finds
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_parse_args_finds DD 0b2001H
	DD	0187420H
	DD	0176420H
	DD	0163420H
	DD	0120120H
	DD	0c012d014H
	DD	05010H
xdata	ENDS
;	COMDAT ??_C@_05BBAJLHME@O?$HMOO?3?$AA@
CONST	SEGMENT
??_C@_05BBAJLHME@O?$HMOO?3?$AA@ DB 'O|OO:', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT stringlib_parse_args_finds
_TEXT	SEGMENT
tmp_start$ = 48
tmp_end$ = 56
obj_end$ = 64
obj_start$ = 72
tmp_subobj$ = 80
format$ = 88
function_name$ = 176
args$ = 184
subobj$ = 192
start$ = 200
end$ = 208
stringlib_parse_args_finds PROC				; COMDAT

; 108  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	55		 push	 rbp
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 8d 6c 24 c1	 lea	 rbp, QWORD PTR [rsp-63]
  00019	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 109  :     PyObject *tmp_subobj;
; 110  :     Py_ssize_t tmp_start = 0;
; 111  :     Py_ssize_t tmp_end = PY_SSIZE_T_MAX;

  00020	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0002a	4d 8b e0	 mov	 r12, r8
  0002d	48 8b da	 mov	 rbx, rdx
  00030	48 8b d1	 mov	 rdx, rcx

; 112  :     PyObject *obj_start=Py_None, *obj_end=Py_None;
; 113  :     char format[FORMAT_BUFFER_SIZE] = "O|OO:";
; 114  :     size_t len = strlen(format);

  00033	48 83 c9 ff	 or	 rcx, -1
  00037	48 89 45 e7	 mov	 QWORD PTR tmp_end$[rbp-81], rax
  0003b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@
  00041	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NoneStruct
  00048	48 8d 7d 07	 lea	 rdi, QWORD PTR format$[rbp-81]
  0004c	89 45 07	 mov	 DWORD PTR format$[rbp-81], eax
  0004f	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@+4

; 115  : 
; 116  :     strncpy(format + len, function_name, FORMAT_BUFFER_SIZE - len - 1);

  00056	41 b8 31 00 00
	00		 mov	 r8d, 49			; 00000031H
  0005c	66 89 45 0b	 mov	 WORD PTR format$[rbp-77], ax
  00060	33 c0		 xor	 eax, eax
  00062	49 8b f1	 mov	 rsi, r9
  00065	48 89 45 0d	 mov	 QWORD PTR format$[rbp-75], rax
  00069	48 89 45 15	 mov	 QWORD PTR format$[rbp-67], rax
  0006d	48 89 45 1d	 mov	 QWORD PTR format$[rbp-59], rax
  00071	48 89 45 25	 mov	 QWORD PTR format$[rbp-51], rax
  00075	48 89 45 2d	 mov	 QWORD PTR format$[rbp-43], rax
  00079	89 45 35	 mov	 DWORD PTR format$[rbp-35], eax
  0007c	f2 ae		 repne scasb
  0007e	48 c7 45 df 00
	00 00 00	 mov	 QWORD PTR tmp_start$[rbp-81], 0
  00086	4c 89 6d f7	 mov	 QWORD PTR obj_start$[rbp-81], r13
  0008a	48 f7 d1	 not	 rcx
  0008d	4c 89 6d ef	 mov	 QWORD PTR obj_end$[rbp-81], r13
  00091	48 ff c9	 dec	 rcx
  00094	4c 2b c1	 sub	 r8, rcx
  00097	48 8d 4c 0d 07	 lea	 rcx, QWORD PTR format$[rbp+rcx-81]
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 117  :     format[FORMAT_BUFFER_SIZE - 1] = '\0';
; 118  : 
; 119  :     if (!PyArg_ParseTuple(args, format, &tmp_subobj, &obj_start, &obj_end))

  000a2	48 8d 45 ef	 lea	 rax, QWORD PTR obj_end$[rbp-81]
  000a6	4c 8d 4d f7	 lea	 r9, QWORD PTR obj_start$[rbp-81]
  000aa	4c 8d 45 ff	 lea	 r8, QWORD PTR tmp_subobj$[rbp-81]
  000ae	48 8d 55 07	 lea	 rdx, QWORD PTR format$[rbp-81]
  000b2	48 8b cb	 mov	 rcx, rbx
  000b5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ba	c6 45 38 00	 mov	 BYTE PTR format$[rbp-32], 0
  000be	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000c3	85 c0		 test	 eax, eax
  000c5	75 04		 jne	 SHORT $LN5@stringlib_
$LN8@stringlib_:

; 120  :         return 0;

  000c7	33 c0		 xor	 eax, eax
  000c9	eb 4b		 jmp	 SHORT $LN6@stringlib_
$LN5@stringlib_:

; 121  : 
; 122  :     /* To support None in "start" and "end" arguments, meaning
; 123  :        the same as if they were not passed.
; 124  :     */
; 125  :     if (obj_start != Py_None)

  000cb	48 8b 4d f7	 mov	 rcx, QWORD PTR obj_start$[rbp-81]
  000cf	49 3b cd	 cmp	 rcx, r13
  000d2	74 0d		 je	 SHORT $LN3@stringlib_

; 126  :         if (!_PyEval_SliceIndex(obj_start, &tmp_start))

  000d4	48 8d 55 df	 lea	 rdx, QWORD PTR tmp_start$[rbp-81]
  000d8	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000dd	85 c0		 test	 eax, eax

; 127  :             return 0;

  000df	74 e6		 je	 SHORT $LN8@stringlib_
$LN3@stringlib_:

; 128  :     if (obj_end != Py_None)

  000e1	48 8b 4d ef	 mov	 rcx, QWORD PTR obj_end$[rbp-81]
  000e5	49 3b cd	 cmp	 rcx, r13
  000e8	74 0d		 je	 SHORT $LN1@stringlib_

; 129  :         if (!_PyEval_SliceIndex(obj_end, &tmp_end))

  000ea	48 8d 55 e7	 lea	 rdx, QWORD PTR tmp_end$[rbp-81]
  000ee	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000f3	85 c0		 test	 eax, eax

; 130  :             return 0;

  000f5	74 d0		 je	 SHORT $LN8@stringlib_
$LN1@stringlib_:

; 131  : 
; 132  :     *start = tmp_start;

  000f7	48 8b 45 df	 mov	 rax, QWORD PTR tmp_start$[rbp-81]

; 133  :     *end = tmp_end;

  000fb	48 8b 4d 7f	 mov	 rcx, QWORD PTR end$[rbp-81]
  000ff	48 89 06	 mov	 QWORD PTR [rsi], rax
  00102	48 8b 45 e7	 mov	 rax, QWORD PTR tmp_end$[rbp-81]
  00106	48 89 01	 mov	 QWORD PTR [rcx], rax

; 134  :     *subobj = tmp_subobj;

  00109	48 8b 45 ff	 mov	 rax, QWORD PTR tmp_subobj$[rbp-81]
  0010d	49 89 04 24	 mov	 QWORD PTR [r12], rax

; 135  :     return 1;

  00111	b8 01 00 00 00	 mov	 eax, 1
$LN6@stringlib_:

; 136  : }

  00116	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  0011e	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  00122	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  00126	49 8b 7b 30	 mov	 rdi, QWORD PTR [r11+48]
  0012a	49 8b e3	 mov	 rsp, r11
  0012d	41 5d		 pop	 r13
  0012f	41 5c		 pop	 r12
  00131	5d		 pop	 rbp
  00132	c3		 ret	 0
stringlib_parse_args_finds ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$findchar DD imagerel findchar
	DD	imagerel findchar+592
	DD	imagerel $unwind$findchar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$findchar DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT findchar
_TEXT	SEGMENT
s$ = 64
kind$ = 72
size$ = 80
ch$ = 88
direction$ = 96
findchar PROC						; COMDAT

; 642  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 643  :     int mode = (direction == 1) ? FAST_SEARCH : FAST_RSEARCH;

  0000a	45 33 d2	 xor	 r10d, r10d
  0000d	83 7c 24 60 01	 cmp	 DWORD PTR direction$[rsp], 1
  00012	48 8b d9	 mov	 rbx, rcx
  00015	41 8b ca	 mov	 ecx, r10d
  00018	0f 95 c1	 setne	 cl
  0001b	45 8b d9	 mov	 r11d, r9d
  0001e	ff c1		 inc	 ecx

; 644  : 
; 645  :     switch (kind) {

  00020	ff ca		 dec	 edx
  00022	49 8b f8	 mov	 rdi, r8
  00025	0f 84 5f 01 00
	00		 je	 $LN8@findchar
  0002b	ff ca		 dec	 edx
  0002d	0f 84 9e 00 00
	00		 je	 $LN6@findchar
  00033	83 fa 02	 cmp	 edx, 2

; 664  :     default:
; 665  :         assert(0);
; 666  :         return -1;

  00036	0f 85 05 02 00
	00		 jne	 $LN7@findchar

; 659  :             else
; 660  :                 return -1;
; 661  :         }
; 662  :     case PyUnicode_4BYTE_KIND:
; 663  :         return ucs4lib_fastsearch((Py_UCS4 *) s, size, &ch, 1, 0, mode);

  0003c	49 8d 40 ff	 lea	 rax, QWORD PTR [r8-1]
  00040	48 85 c0	 test	 rax, rax
  00043	78 7a		 js	 SHORT $LN208@findchar
  00045	85 c9		 test	 ecx, ecx
  00047	74 76		 je	 SHORT $LN208@findchar
  00049	49 83 f8 0a	 cmp	 r8, 10
  0004d	7e 2a		 jle	 SHORT $LN204@findchar
  0004f	83 f9 01	 cmp	 ecx, 1
  00052	75 4f		 jne	 SHORT $LN196@findchar
  00054	45 84 c9	 test	 r9b, r9b
  00057	74 25		 je	 SHORT $LN240@findchar
  00059	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0005d	45 8b c1	 mov	 r8d, r9d
  00060	48 8b d7	 mov	 rdx, rdi
  00063	48 8b cb	 mov	 rcx, rbx
  00066	e8 00 00 00 00	 call	 ucs4lib_fastsearch_memchr_1char
  0006b	4c 8b d0	 mov	 r10, rax

; 667  :     }
; 668  : }

  0006e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00073	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0

; 659  :             else
; 660  :                 return -1;
; 661  :         }
; 662  :     case PyUnicode_4BYTE_KIND:
; 663  :         return ucs4lib_fastsearch((Py_UCS4 *) s, size, &ch, 1, 0, mode);

$LN204@findchar:
  00079	83 f9 01	 cmp	 ecx, 1
  0007c	75 25		 jne	 SHORT $LN196@findchar
$LN240@findchar:
  0007e	4d 85 c0	 test	 r8, r8
  00081	7e 3c		 jle	 SHORT $LN208@findchar
$LL195@findchar:
  00083	46 39 0c 93	 cmp	 DWORD PTR [rbx+r10*4], r9d
  00087	74 3a		 je	 SHORT $LN210@findchar
  00089	49 ff c2	 inc	 r10
  0008c	4d 3b d0	 cmp	 r10, r8
  0008f	7c f2		 jl	 SHORT $LL195@findchar
  00091	49 83 ca ff	 or	 r10, -1
  00095	49 8b c2	 mov	 rax, r10

; 667  :     }
; 668  : }

  00098	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a1	5f		 pop	 rdi
  000a2	c3		 ret	 0

; 659  :             else
; 660  :                 return -1;
; 661  :         }
; 662  :     case PyUnicode_4BYTE_KIND:
; 663  :         return ucs4lib_fastsearch((Py_UCS4 *) s, size, &ch, 1, 0, mode);

$LN196@findchar:
  000a3	4c 8b d0	 mov	 r10, rax
  000a6	48 83 f8 ff	 cmp	 rax, -1
  000aa	7e 13		 jle	 SHORT $LN208@findchar
  000ac	0f 1f 40 00	 npad	 4
$LL190@findchar:
  000b0	46 39 0c 93	 cmp	 DWORD PTR [rbx+r10*4], r9d
  000b4	74 0d		 je	 SHORT $LN210@findchar
  000b6	49 ff ca	 dec	 r10
  000b9	49 83 fa ff	 cmp	 r10, -1
  000bd	7f f1		 jg	 SHORT $LL190@findchar
$LN208@findchar:
  000bf	49 83 ca ff	 or	 r10, -1
$LN210@findchar:
  000c3	49 8b c2	 mov	 rax, r10

; 667  :     }
; 668  : }

  000c6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000cb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cf	5f		 pop	 rdi
  000d0	c3		 ret	 0
$LN6@findchar:

; 653  :         }
; 654  :     case PyUnicode_2BYTE_KIND:
; 655  :         {
; 656  :             Py_UCS2 ch2 = (Py_UCS2) ch;
; 657  :             if (ch2 == ch)

  000d1	41 0f b7 c1	 movzx	 eax, r9w
  000d5	41 3b c1	 cmp	 eax, r9d
  000d8	0f 85 63 01 00
	00		 jne	 $LN7@findchar

; 658  :                 return ucs2lib_fastsearch((Py_UCS2 *) s, size, &ch2, 1, 0, mode);

  000de	49 8d 40 ff	 lea	 rax, QWORD PTR [r8-1]
  000e2	48 85 c0	 test	 rax, rax
  000e5	0f 88 44 01 00
	00		 js	 $LN72@findchar
  000eb	85 c9		 test	 ecx, ecx
  000ed	0f 84 3c 01 00
	00		 je	 $LN72@findchar
  000f3	49 83 f8 0a	 cmp	 r8, 10
  000f7	7e 2b		 jle	 SHORT $LN140@findchar
  000f9	83 f9 01	 cmp	 ecx, 1
  000fc	75 59		 jne	 SHORT $LN132@findchar
  000fe	45 84 c9	 test	 r9b, r9b
  00101	74 26		 je	 SHORT $LN241@findchar
  00103	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00107	45 0f b7 c3	 movzx	 r8d, r11w
  0010b	48 8b d7	 mov	 rdx, rdi
  0010e	48 8b cb	 mov	 rcx, rbx
  00111	e8 00 00 00 00	 call	 ucs2lib_fastsearch_memchr_1char
  00116	4c 8b d0	 mov	 r10, rax

; 667  :     }
; 668  : }

  00119	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0011e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00122	5f		 pop	 rdi
  00123	c3		 ret	 0

; 658  :                 return ucs2lib_fastsearch((Py_UCS2 *) s, size, &ch2, 1, 0, mode);

$LN140@findchar:
  00124	83 f9 01	 cmp	 ecx, 1
  00127	75 2e		 jne	 SHORT $LN132@findchar
$LN241@findchar:
  00129	4d 85 c0	 test	 r8, r8
  0012c	0f 8e fd 00 00
	00		 jle	 $LN72@findchar
$LL131@findchar:
  00132	66 46 39 0c 53	 cmp	 WORD PTR [rbx+r10*2], r9w
  00137	0f 84 f6 00 00
	00		 je	 $LN74@findchar
  0013d	49 ff c2	 inc	 r10
  00140	4d 3b d0	 cmp	 r10, r8
  00143	7c ed		 jl	 SHORT $LL131@findchar

; 650  :                 return ucs1lib_fastsearch((Py_UCS1 *) s, size, &ch1, 1, 0, mode);

  00145	49 83 ca ff	 or	 r10, -1
  00149	49 8b c2	 mov	 rax, r10

; 667  :     }
; 668  : }

  0014c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00151	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00155	5f		 pop	 rdi
  00156	c3		 ret	 0

; 658  :                 return ucs2lib_fastsearch((Py_UCS2 *) s, size, &ch2, 1, 0, mode);

$LN132@findchar:
  00157	4c 8b d0	 mov	 r10, rax
  0015a	48 83 f8 ff	 cmp	 rax, -1
  0015e	0f 8e cb 00 00
	00		 jle	 $LN72@findchar
$LL126@findchar:
  00164	66 46 39 0c 53	 cmp	 WORD PTR [rbx+r10*2], r9w
  00169	0f 84 c4 00 00
	00		 je	 $LN74@findchar
  0016f	49 ff ca	 dec	 r10
  00172	49 83 fa ff	 cmp	 r10, -1
  00176	7f ec		 jg	 SHORT $LL126@findchar

; 650  :                 return ucs1lib_fastsearch((Py_UCS1 *) s, size, &ch1, 1, 0, mode);

  00178	49 83 ca ff	 or	 r10, -1
  0017c	49 8b c2	 mov	 rax, r10

; 667  :     }
; 668  : }

  0017f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00184	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00188	5f		 pop	 rdi
  00189	c3		 ret	 0
$LN8@findchar:

; 646  :     case PyUnicode_1BYTE_KIND:
; 647  :         {
; 648  :             Py_UCS1 ch1 = (Py_UCS1) ch;
; 649  :             if (ch1 == ch)

  0018a	41 0f b6 d1	 movzx	 edx, r9b
  0018e	41 3b d1	 cmp	 edx, r9d
  00191	0f 85 aa 00 00
	00		 jne	 $LN7@findchar

; 650  :                 return ucs1lib_fastsearch((Py_UCS1 *) s, size, &ch1, 1, 0, mode);

  00197	49 8d 40 ff	 lea	 rax, QWORD PTR [r8-1]
  0019b	48 85 c0	 test	 rax, rax
  0019e	0f 88 8b 00 00
	00		 js	 $LN72@findchar
  001a4	85 c9		 test	 ecx, ecx
  001a6	0f 84 83 00 00
	00		 je	 $LN72@findchar
  001ac	49 83 f8 0a	 cmp	 r8, 10
  001b0	7e 32		 jle	 SHORT $LN69@findchar
  001b2	83 f9 01	 cmp	 ecx, 1
  001b5	75 59		 jne	 SHORT $LN61@findchar
  001b7	4c 03 c3	 add	 r8, rbx
  001ba	49 3b d8	 cmp	 rbx, r8
  001bd	73 70		 jae	 SHORT $LN72@findchar
  001bf	4c 2b c3	 sub	 r8, rbx
  001c2	48 8b cb	 mov	 rcx, rbx
  001c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  001cb	4c 8b d0	 mov	 r10, rax
  001ce	48 85 c0	 test	 rax, rax
  001d1	74 5c		 je	 SHORT $LN72@findchar
  001d3	4c 2b d3	 sub	 r10, rbx
  001d6	49 8b c2	 mov	 rax, r10

; 667  :     }
; 668  : }

  001d9	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001de	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001e2	5f		 pop	 rdi
  001e3	c3		 ret	 0

; 650  :                 return ucs1lib_fastsearch((Py_UCS1 *) s, size, &ch1, 1, 0, mode);

$LN69@findchar:
  001e4	83 f9 01	 cmp	 ecx, 1
  001e7	75 27		 jne	 SHORT $LN61@findchar
  001e9	4d 85 c0	 test	 r8, r8
  001ec	7e 41		 jle	 SHORT $LN72@findchar
  001ee	66 90		 npad	 2
$LL60@findchar:
  001f0	45 38 0c 1a	 cmp	 BYTE PTR [r10+rbx], r9b
  001f4	74 3d		 je	 SHORT $LN74@findchar
  001f6	49 ff c2	 inc	 r10
  001f9	4d 3b d0	 cmp	 r10, r8
  001fc	7c f2		 jl	 SHORT $LL60@findchar
  001fe	49 83 ca ff	 or	 r10, -1
  00202	49 8b c2	 mov	 rax, r10

; 667  :     }
; 668  : }

  00205	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0020a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0020e	5f		 pop	 rdi
  0020f	c3		 ret	 0

; 650  :                 return ucs1lib_fastsearch((Py_UCS1 *) s, size, &ch1, 1, 0, mode);

$LN61@findchar:
  00210	4c 8b d0	 mov	 r10, rax
  00213	48 83 f8 ff	 cmp	 rax, -1
  00217	7e 16		 jle	 SHORT $LN72@findchar
  00219	0f 1f 80 00 00
	00 00		 npad	 7
$LL55@findchar:
  00220	45 38 0c 1a	 cmp	 BYTE PTR [r10+rbx], r9b
  00224	74 0d		 je	 SHORT $LN74@findchar
  00226	49 ff ca	 dec	 r10
  00229	49 83 fa ff	 cmp	 r10, -1
  0022d	7f f1		 jg	 SHORT $LL55@findchar
$LN72@findchar:
  0022f	49 83 ca ff	 or	 r10, -1
$LN74@findchar:
  00233	49 8b c2	 mov	 rax, r10

; 667  :     }
; 668  : }

  00236	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0023b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0023f	5f		 pop	 rdi
  00240	c3		 ret	 0
$LN7@findchar:

; 651  :             else
; 652  :                 return -1;

  00241	48 83 c8 ff	 or	 rax, -1

; 667  :     }
; 668  : }

  00245	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0024a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0024e	5f		 pop	 rdi
  0024f	c3		 ret	 0
findchar ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@FGJPEFKE@resize_compact?$AA@		; `string'
PUBLIC	??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@ ; `string'
EXTRN	PyObject_Realloc:PROC
EXTRN	_Px_ForgetReference:PROC
EXTRN	PyErr_NoMemory:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$resize_compact DD imagerel resize_compact
	DD	imagerel resize_compact+149
	DD	imagerel $unwind$resize_compact
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$resize_compact DD imagerel resize_compact+149
	DD	imagerel resize_compact+605
	DD	imagerel $chain$0$resize_compact
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$resize_compact DD imagerel resize_compact+605
	DD	imagerel resize_compact+627
	DD	imagerel $chain$1$resize_compact
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$resize_compact DD 021H
	DD	imagerel resize_compact
	DD	imagerel resize_compact+149
	DD	imagerel $unwind$resize_compact
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$resize_compact DD 020521H
	DD	083405H
	DD	imagerel resize_compact
	DD	imagerel resize_compact+149
	DD	imagerel $unwind$resize_compact
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$resize_compact DD 081501H
	DD	0b7415H
	DD	0a6415H
	DD	095415H
	DD	0c0115215H
xdata	ENDS
;	COMDAT ??_C@_0P@FGJPEFKE@resize_compact?$AA@
CONST	SEGMENT
??_C@_0P@FGJPEFKE@resize_compact?$AA@ DB 'resize_compact', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
CONST	SEGMENT
??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@ DB '..\Objects\un'
	DB	'icodeobject.c', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT resize_compact
_TEXT	SEGMENT
unicode$ = 64
length$ = 72
resize_compact PROC					; COMDAT

; 672  : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 673  :     Py_ssize_t char_size;
; 674  :     Py_ssize_t struct_size;
; 675  :     Py_ssize_t new_size;
; 676  :     int share_wstr;
; 677  :     PyObject *new_unicode;
; 678  :     assert(unicode_modifiable(unicode));
; 679  :     assert(PyUnicode_IS_READY(unicode));
; 680  :     assert(PyUnicode_IS_COMPACT(unicode));
; 681  : 
; 682  :     char_size = PyUnicode_KIND(unicode);

  00015	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	48 8b f2	 mov	 rsi, rdx
  0001e	44 8b c0	 mov	 r8d, eax

; 683  :     if (PyUnicode_IS_ASCII(unicode))

  00021	8b c8		 mov	 ecx, eax
  00023	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00028	49 c1 e8 02	 shr	 r8, 2
  0002c	c1 e9 06	 shr	 ecx, 6
  0002f	41 b9 a0 00 00
	00		 mov	 r9d, 160		; 000000a0H
  00035	41 83 e0 07	 and	 r8d, 7
  00039	83 e1 01	 and	 ecx, 1
  0003c	44 0f 45 ca	 cmovne	 r9d, edx

; 684  :         struct_size = sizeof(PyASCIIObject);
; 685  :     else
; 686  :         struct_size = sizeof(PyCompactUnicodeObject);
; 687  :     share_wstr = _PyUnicode_SHARE_WSTR(unicode);

  00040	a8 20		 test	 al, 32			; 00000020H
  00042	74 16		 je	 SHORT $LN26@resize_com
  00044	85 c9		 test	 ecx, ecx
  00046	74 09		 je	 SHORT $LN24@resize_com
  00048	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  0004f	eb 10		 jmp	 SHORT $LN27@resize_com
$LN24@resize_com:
  00051	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  00058	eb 07		 jmp	 SHORT $LN27@resize_com
$LN26@resize_com:
  0005a	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
$LN27@resize_com:
  00061	45 33 e4	 xor	 r12d, r12d
  00064	48 39 47 78	 cmp	 QWORD PTR [rdi+120], rax

; 688  : 
; 689  :     if (length > ((PY_SSIZE_T_MAX - struct_size) / char_size - 1)) {

  00068	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00072	41 8b ec	 mov	 ebp, r12d
  00075	40 0f 94 c5	 sete	 bpl
  00079	49 2b c1	 sub	 rax, r9
  0007c	48 99		 cdq
  0007e	49 f7 f8	 idiv	 r8
  00081	48 ff c8	 dec	 rax
  00084	48 3b f0	 cmp	 rsi, rax
  00087	7e 0c		 jle	 SHORT $LN19@resize_com

; 690  :         PyErr_NoMemory();

  00089	e8 00 00 00 00	 call	 PyErr_NoMemory

; 691  :         return NULL;

  0008e	33 c0		 xor	 eax, eax
  00090	e9 c8 01 00 00	 jmp	 $LN22@resize_com
$LN19@resize_com:
  00095	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 692  :     }
; 693  :     new_size = (struct_size + (length + 1) * char_size);

  0009a	48 8d 5e 01	 lea	 rbx, QWORD PTR [rsi+1]
  0009e	49 0f af d8	 imul	 rbx, r8
  000a2	49 03 d9	 add	 rbx, r9

; 694  : 
; 695  :     _Py_DEC_REFTOTAL;
; 696  :     _Py_ForgetReference(unicode);

  000a5	e8 00 00 00 00	 call	 _Py_PXCTX
  000aa	85 c0		 test	 eax, eax
  000ac	74 08		 je	 SHORT $LN16@resize_com
  000ae	48 8b cf	 mov	 rcx, rdi
  000b1	e8 00 00 00 00	 call	 _Px_ForgetReference
$LN16@resize_com:

; 697  : 
; 698  :     new_unicode = (PyObject *)PyObject_REALLOC((char *)unicode, new_size);

  000b6	48 8b d3	 mov	 rdx, rbx
  000b9	48 8b cf	 mov	 rcx, rdi
  000bc	e8 00 00 00 00	 call	 PyObject_Realloc

; 699  :     if (new_unicode == NULL) {
; 700  :         _Py_NewReference(unicode);

  000c1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  000d0	48 8b d8	 mov	 rbx, rax
  000d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@FGJPEFKE@resize_compact?$AA@
  000da	48 85 c0	 test	 rax, rax
  000dd	75 3a		 jne	 SHORT $LN13@resize_com
  000df	4c 8b cf	 mov	 r9, rdi
  000e2	41 b8 bc 02 00
	00		 mov	 r8d, 700		; 000002bcH
  000e8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ed	85 c0		 test	 eax, eax
  000ef	74 14		 je	 SHORT $LN28@resize_com
  000f1	48 8b cf	 mov	 rcx, rdi
  000f4	e8 00 00 00 00	 call	 _Px_NewReference

; 701  :         PyErr_NoMemory();

  000f9	e8 00 00 00 00	 call	 PyErr_NoMemory

; 702  :         return NULL;

  000fe	33 c0		 xor	 eax, eax
  00100	e9 53 01 00 00	 jmp	 $LN56@resize_com
$LN28@resize_com:

; 699  :     if (new_unicode == NULL) {
; 700  :         _Py_NewReference(unicode);

  00105	48 c7 47 50 01
	00 00 00	 mov	 QWORD PTR [rdi+80], 1

; 701  :         PyErr_NoMemory();

  0010d	e8 00 00 00 00	 call	 PyErr_NoMemory

; 702  :         return NULL;

  00112	33 c0		 xor	 eax, eax
  00114	e9 3f 01 00 00	 jmp	 $LN56@resize_com
$LN13@resize_com:

; 703  :     }
; 704  :     unicode = new_unicode;
; 705  :     _Py_NewReference(unicode);

  00119	4c 8b c8	 mov	 r9, rax
  0011c	41 b8 c1 02 00
	00		 mov	 r8d, 705		; 000002c1H
  00122	e8 00 00 00 00	 call	 _PyParallel_Guard
  00127	85 c0		 test	 eax, eax
  00129	74 0a		 je	 SHORT $LN30@resize_com
  0012b	48 8b cb	 mov	 rcx, rbx
  0012e	e8 00 00 00 00	 call	 _Px_NewReference
  00133	eb 08		 jmp	 SHORT $LN31@resize_com
$LN30@resize_com:
  00135	48 c7 43 50 01
	00 00 00	 mov	 QWORD PTR [rbx+80], 1
$LN31@resize_com:

; 706  : 
; 707  :     _PyUnicode_LENGTH(unicode) = length;

  0013d	48 89 73 60	 mov	 QWORD PTR [rbx+96], rsi

; 708  :     if (share_wstr) {

  00141	85 ed		 test	 ebp, ebp
  00143	74 38		 je	 SHORT $LN12@resize_com

; 709  :         _PyUnicode_WSTR(unicode) = PyUnicode_DATA(unicode);

  00145	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00148	f6 c1 20	 test	 cl, 32			; 00000020H
  0014b	74 17		 je	 SHORT $LN34@resize_com
  0014d	f6 c1 40	 test	 cl, 64			; 00000040H
  00150	74 09		 je	 SHORT $LN32@resize_com
  00152	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00159	eb 10		 jmp	 SHORT $LN35@resize_com
$LN32@resize_com:
  0015b	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00162	eb 07		 jmp	 SHORT $LN35@resize_com
$LN34@resize_com:
  00164	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN35@resize_com:
  0016b	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 710  :         if (!PyUnicode_IS_ASCII(unicode))

  0016f	f6 c1 40	 test	 cl, 64			; 00000040H
  00172	75 48		 jne	 SHORT $LN8@resize_com

; 711  :             _PyUnicode_WSTR_LENGTH(unicode) = length;

  00174	48 89 b3 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rsi

; 712  :     }
; 713  :     else if (_PyUnicode_HAS_WSTR_MEMORY(unicode)) {

  0017b	eb 3f		 jmp	 SHORT $LN8@resize_com
$LN12@resize_com:
  0017d	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  00181	48 85 c9	 test	 rcx, rcx
  00184	74 36		 je	 SHORT $LN8@resize_com
  00186	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00189	84 c0		 test	 al, al
  0018b	79 26		 jns	 SHORT $LN55@resize_com
  0018d	a8 20		 test	 al, 32			; 00000020H
  0018f	74 16		 je	 SHORT $LN38@resize_com
  00191	a8 40		 test	 al, 64			; 00000040H
  00193	74 09		 je	 SHORT $LN36@resize_com
  00195	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  0019c	eb 10		 jmp	 SHORT $LN39@resize_com
$LN36@resize_com:
  0019e	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  001a5	eb 07		 jmp	 SHORT $LN39@resize_com
$LN38@resize_com:
  001a7	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN39@resize_com:
  001ae	48 3b c8	 cmp	 rcx, rax
  001b1	74 09		 je	 SHORT $LN8@resize_com
$LN55@resize_com:

; 714  :         PyObject_DEL(_PyUnicode_WSTR(unicode));

  001b3	e8 00 00 00 00	 call	 PyObject_Free

; 715  :         _PyUnicode_WSTR(unicode) = NULL;

  001b8	4c 89 63 78	 mov	 QWORD PTR [rbx+120], r12
$LN8@resize_com:

; 716  :     }
; 717  :     PyUnicode_WRITE(PyUnicode_KIND(unicode), PyUnicode_DATA(unicode),
; 718  :                     length, 0);

  001bc	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  001bf	8b c8		 mov	 ecx, eax
  001c1	c1 e9 02	 shr	 ecx, 2
  001c4	83 e1 07	 and	 ecx, 7
  001c7	ff c9		 dec	 ecx
  001c9	74 65		 je	 SHORT $LN3@resize_com
  001cb	ff c9		 dec	 ecx
  001cd	74 2f		 je	 SHORT $LN2@resize_com
  001cf	a8 20		 test	 al, 32			; 00000020H
  001d1	74 1e		 je	 SHORT $LN53@resize_com
  001d3	a8 40		 test	 al, 64			; 00000040H
  001d5	74 0d		 je	 SHORT $LN51@resize_com
  001d7	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  001de	44 89 24 b0	 mov	 DWORD PTR [rax+rsi*4], r12d
  001e2	eb 71		 jmp	 SHORT $LN7@resize_com
$LN51@resize_com:
  001e4	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  001eb	44 89 24 b0	 mov	 DWORD PTR [rax+rsi*4], r12d
  001ef	eb 64		 jmp	 SHORT $LN7@resize_com
$LN53@resize_com:
  001f1	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  001f8	44 89 24 b0	 mov	 DWORD PTR [rax+rsi*4], r12d
  001fc	eb 57		 jmp	 SHORT $LN7@resize_com
$LN2@resize_com:
  001fe	a8 20		 test	 al, 32			; 00000020H
  00200	74 20		 je	 SHORT $LN49@resize_com
  00202	a8 40		 test	 al, 64			; 00000040H
  00204	74 0e		 je	 SHORT $LN47@resize_com
  00206	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  0020d	66 44 89 24 70	 mov	 WORD PTR [rax+rsi*2], r12w
  00212	eb 41		 jmp	 SHORT $LN7@resize_com
$LN47@resize_com:
  00214	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  0021b	66 44 89 24 70	 mov	 WORD PTR [rax+rsi*2], r12w
  00220	eb 33		 jmp	 SHORT $LN7@resize_com
$LN49@resize_com:
  00222	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  00229	66 44 89 24 70	 mov	 WORD PTR [rax+rsi*2], r12w
  0022e	eb 25		 jmp	 SHORT $LN7@resize_com
$LN3@resize_com:
  00230	a8 20		 test	 al, 32			; 00000020H
  00232	74 16		 je	 SHORT $LN45@resize_com
  00234	a8 40		 test	 al, 64			; 00000040H
  00236	74 09		 je	 SHORT $LN43@resize_com
  00238	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  0023f	eb 10		 jmp	 SHORT $LN46@resize_com
$LN43@resize_com:
  00241	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00248	eb 07		 jmp	 SHORT $LN46@resize_com
$LN45@resize_com:
  0024a	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN46@resize_com:
  00251	44 88 24 30	 mov	 BYTE PTR [rax+rsi], r12b
$LN7@resize_com:

; 719  :     assert(_PyUnicode_CheckConsistency(unicode, 0));
; 720  :     return unicode;

  00255	48 8b c3	 mov	 rax, rbx
$LN56@resize_com:
  00258	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN22@resize_com:

; 721  : }

  0025d	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00262	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00267	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0026c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00270	41 5c		 pop	 r12
  00272	c3		 ret	 0
resize_compact ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$resize_inplace DD imagerel resize_inplace
	DD	imagerel resize_inplace+194
	DD	imagerel $unwind$resize_inplace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$resize_inplace DD imagerel resize_inplace+194
	DD	imagerel resize_inplace+315
	DD	imagerel $chain$0$resize_inplace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$resize_inplace DD imagerel resize_inplace+315
	DD	imagerel resize_inplace+489
	DD	imagerel $chain$1$resize_inplace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$resize_inplace DD 021H
	DD	imagerel resize_inplace
	DD	imagerel resize_inplace+194
	DD	imagerel $unwind$resize_inplace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$resize_inplace DD 020521H
	DD	0ad405H
	DD	imagerel resize_inplace
	DD	imagerel resize_inplace+194
	DD	imagerel $unwind$resize_inplace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$resize_inplace DD 0a1601H
	DD	0c5416H
	DD	0b3416H
	DD	0f0123216H
	DD	0c00ee010H
	DD	0600b700cH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT resize_inplace
_TEXT	SEGMENT
unicode$ = 80
length$ = 88
resize_inplace PROC					; COMDAT

; 725  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00016	48 8b d9	 mov	 rbx, rcx

; 726  :     wchar_t *wstr;
; 727  :     Py_ssize_t new_size;
; 728  :     assert(!PyUnicode_IS_COMPACT(unicode));
; 729  :     assert(Py_REFCNT(unicode) == 1);
; 730  : 
; 731  :     if (PyUnicode_IS_READY(unicode)) {

  00019	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  0001c	45 33 ff	 xor	 r15d, r15d
  0001f	48 8b fa	 mov	 rdi, rdx
  00022	84 c9		 test	 cl, cl
  00024	0f 89 6c 01 00
	00		 jns	 $LN4@resize_inp

; 732  :         Py_ssize_t char_size;
; 733  :         int share_wstr, share_utf8;
; 734  :         void *data;
; 735  : 
; 736  :         data = _PyUnicode_DATA_ANY(unicode);

  0002a	48 8b ab a0 00
	00 00		 mov	 rbp, QWORD PTR [rbx+160]

; 737  :         char_size = PyUnicode_KIND(unicode);

  00031	44 8b c9	 mov	 r9d, ecx

; 738  :         share_wstr = _PyUnicode_SHARE_WSTR(unicode);

  00034	44 8b c1	 mov	 r8d, ecx
  00037	49 c1 e9 02	 shr	 r9, 2
  0003b	41 c1 e8 05	 shr	 r8d, 5
  0003f	41 83 e1 07	 and	 r9d, 7
  00043	41 83 e0 01	 and	 r8d, 1
  00047	74 17		 je	 SHORT $LN23@resize_inp
  00049	f6 c1 40	 test	 cl, 64			; 00000040H
  0004c	74 09		 je	 SHORT $LN21@resize_inp
  0004e	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00055	eb 0c		 jmp	 SHORT $LN24@resize_inp
$LN21@resize_inp:
  00057	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  0005e	eb 03		 jmp	 SHORT $LN24@resize_inp
$LN23@resize_inp:
  00060	48 8b c5	 mov	 rax, rbp
$LN24@resize_inp:
  00063	48 39 43 78	 cmp	 QWORD PTR [rbx+120], rax
  00067	45 8b e7	 mov	 r12d, r15d
  0006a	41 0f 94 c4	 sete	 r12b

; 739  :         share_utf8 = _PyUnicode_SHARE_UTF8(unicode);

  0006e	45 85 c0	 test	 r8d, r8d
  00071	74 17		 je	 SHORT $LN27@resize_inp
  00073	f6 c1 40	 test	 cl, 64			; 00000040H
  00076	74 09		 je	 SHORT $LN25@resize_inp
  00078	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  0007f	eb 0c		 jmp	 SHORT $LN28@resize_inp
$LN25@resize_inp:
  00081	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00088	eb 03		 jmp	 SHORT $LN28@resize_inp
$LN27@resize_inp:
  0008a	48 8b c5	 mov	 rax, rbp
$LN28@resize_inp:
  0008d	4c 8b 93 88 00
	00 00		 mov	 r10, QWORD PTR [rbx+136]
  00094	45 8b f7	 mov	 r14d, r15d
  00097	4c 3b d0	 cmp	 r10, rax

; 740  : 
; 741  :         if (length > (PY_SSIZE_T_MAX / char_size - 1)) {

  0009a	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000a4	41 0f 94 c6	 sete	 r14b
  000a8	48 99		 cdq
  000aa	49 f7 f9	 idiv	 r9
  000ad	48 ff c8	 dec	 rax
  000b0	48 3b f8	 cmp	 rdi, rax
  000b3	7e 0d		 jle	 SHORT $LN17@resize_inp
$LN37@resize_inp:

; 742  :             PyErr_NoMemory();

  000b5	e8 00 00 00 00	 call	 PyErr_NoMemory

; 743  :             return -1;

  000ba	83 c8 ff	 or	 eax, -1
  000bd	e9 10 01 00 00	 jmp	 $LN19@resize_inp
$LN17@resize_inp:
  000c2	4c 89 6c 24 50	 mov	 QWORD PTR [rsp+80], r13

; 744  :         }
; 745  :         new_size = (length + 1) * char_size;

  000c7	4c 8d 6f 01	 lea	 r13, QWORD PTR [rdi+1]
  000cb	4d 0f af e9	 imul	 r13, r9

; 746  : 
; 747  :         if (!share_utf8 && _PyUnicode_HAS_UTF8_MEMORY(unicode))

  000cf	45 85 f6	 test	 r14d, r14d
  000d2	75 4b		 jne	 SHORT $LN16@resize_inp
  000d4	c1 e9 06	 shr	 ecx, 6
  000d7	83 e1 01	 and	 ecx, 1
  000da	74 05		 je	 SHORT $LN29@resize_inp
  000dc	45 85 c0	 test	 r8d, r8d
  000df	75 3e		 jne	 SHORT $LN16@resize_inp
$LN29@resize_inp:
  000e1	4d 85 d2	 test	 r10, r10
  000e4	74 39		 je	 SHORT $LN16@resize_inp
  000e6	45 85 c0	 test	 r8d, r8d
  000e9	74 16		 je	 SHORT $LN33@resize_inp
  000eb	85 c9		 test	 ecx, ecx
  000ed	74 09		 je	 SHORT $LN31@resize_inp
  000ef	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  000f6	eb 0c		 jmp	 SHORT $LN34@resize_inp
$LN31@resize_inp:
  000f8	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  000ff	eb 03		 jmp	 SHORT $LN34@resize_inp
$LN33@resize_inp:
  00101	48 8b c5	 mov	 rax, rbp
$LN34@resize_inp:
  00104	4c 3b d0	 cmp	 r10, rax
  00107	74 16		 je	 SHORT $LN16@resize_inp

; 748  :         {
; 749  :             PyObject_DEL(_PyUnicode_UTF8(unicode));

  00109	49 8b ca	 mov	 rcx, r10
  0010c	e8 00 00 00 00	 call	 PyObject_Free

; 750  :             _PyUnicode_UTF8(unicode) = NULL;

  00111	4c 89 bb 88 00
	00 00		 mov	 QWORD PTR [rbx+136], r15

; 751  :             _PyUnicode_UTF8_LENGTH(unicode) = 0;

  00118	4c 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], r15
$LN16@resize_inp:

; 752  :         }
; 753  : 
; 754  :         data = (PyObject *)PyObject_REALLOC(data, new_size);

  0011f	49 8b d5	 mov	 rdx, r13
  00122	48 8b cd	 mov	 rcx, rbp
  00125	e8 00 00 00 00	 call	 PyObject_Realloc
  0012a	4c 8b 6c 24 50	 mov	 r13, QWORD PTR [rsp+80]
  0012f	4c 8b d8	 mov	 r11, rax

; 755  :         if (data == NULL) {

  00132	48 85 c0	 test	 rax, rax

; 756  :             PyErr_NoMemory();
; 757  :             return -1;

  00135	0f 84 7a ff ff
	ff		 je	 $LN37@resize_inp

; 758  :         }
; 759  :         _PyUnicode_DATA_ANY(unicode) = data;

  0013b	48 89 83 a0 00
	00 00		 mov	 QWORD PTR [rbx+160], rax

; 760  :         if (share_wstr) {

  00142	45 85 e4	 test	 r12d, r12d
  00145	74 0b		 je	 SHORT $LN14@resize_inp

; 761  :             _PyUnicode_WSTR(unicode) = data;

  00147	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 762  :             _PyUnicode_WSTR_LENGTH(unicode) = length;

  0014b	48 89 bb 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rdi
$LN14@resize_inp:

; 763  :         }
; 764  :         if (share_utf8) {

  00152	45 85 f6	 test	 r14d, r14d
  00155	74 0e		 je	 SHORT $LN13@resize_inp

; 765  :             _PyUnicode_UTF8(unicode) = data;

  00157	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 766  :             _PyUnicode_UTF8_LENGTH(unicode) = length;

  0015e	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi
$LN13@resize_inp:

; 767  :         }
; 768  :         _PyUnicode_LENGTH(unicode) = length;
; 769  :         PyUnicode_WRITE(PyUnicode_KIND(unicode), data, length, 0);

  00165	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00168	48 89 7b 60	 mov	 QWORD PTR [rbx+96], rdi
  0016c	c1 e8 02	 shr	 eax, 2
  0016f	83 e0 07	 and	 eax, 7
  00172	ff c8		 dec	 eax
  00174	74 11		 je	 SHORT $LN7@resize_inp
  00176	ff c8		 dec	 eax
  00178	74 06		 je	 SHORT $LN6@resize_inp
  0017a	45 89 3c bb	 mov	 DWORD PTR [r11+rdi*4], r15d
  0017e	eb 0b		 jmp	 SHORT $LN11@resize_inp
$LN6@resize_inp:
  00180	66 45 89 3c 7b	 mov	 WORD PTR [r11+rdi*2], r15w
  00185	eb 04		 jmp	 SHORT $LN11@resize_inp
$LN7@resize_inp:
  00187	45 88 3c 3b	 mov	 BYTE PTR [r11+rdi], r15b
$LN11@resize_inp:

; 770  :         if (share_wstr || _PyUnicode_WSTR(unicode) == NULL) {

  0018b	45 85 e4	 test	 r12d, r12d
  0018e	75 40		 jne	 SHORT $LN3@resize_inp
  00190	4c 39 7b 78	 cmp	 QWORD PTR [rbx+120], r15

; 771  :             assert(_PyUnicode_CheckConsistency(unicode, 0));
; 772  :             return 0;

  00194	74 3a		 je	 SHORT $LN3@resize_inp
$LN4@resize_inp:

; 773  :         }
; 774  :     }
; 775  :     assert(_PyUnicode_WSTR(unicode) != NULL);
; 776  : 
; 777  :     /* check for integer overflow */
; 778  :     if (length > PY_SSIZE_T_MAX / sizeof(wchar_t) - 1) {

  00196	48 b8 fe ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387902 ; 3ffffffffffffffeH
  001a0	48 3b f8	 cmp	 rdi, rax

; 779  :         PyErr_NoMemory();
; 780  :         return -1;

  001a3	0f 87 0c ff ff
	ff		 ja	 $LN37@resize_inp

; 781  :     }
; 782  :     new_size = sizeof(wchar_t) * (length + 1);
; 783  :     wstr =  _PyUnicode_WSTR(unicode);
; 784  :     wstr = PyObject_REALLOC(wstr, new_size);

  001a9	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  001ad	48 8d 54 3f 02	 lea	 rdx, QWORD PTR [rdi+rdi+2]
  001b2	e8 00 00 00 00	 call	 PyObject_Realloc

; 785  :     if (!wstr) {

  001b7	48 85 c0	 test	 rax, rax

; 786  :         PyErr_NoMemory();
; 787  :         return -1;

  001ba	0f 84 f5 fe ff
	ff		 je	 $LN37@resize_inp

; 788  :     }
; 789  :     _PyUnicode_WSTR(unicode) = wstr;

  001c0	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 790  :     _PyUnicode_WSTR(unicode)[length] = 0;

  001c4	66 44 89 3c 78	 mov	 WORD PTR [rax+rdi*2], r15w

; 791  :     _PyUnicode_WSTR_LENGTH(unicode) = length;

  001c9	48 89 bb 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rdi
$LN3@resize_inp:

; 792  :     assert(_PyUnicode_CheckConsistency(unicode, 0));
; 793  :     return 0;

  001d0	33 c0		 xor	 eax, eax
$LN19@resize_inp:

; 794  : }

  001d2	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  001d7	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  001dc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001e0	41 5f		 pop	 r15
  001e2	41 5e		 pop	 r14
  001e4	41 5c		 pop	 r12
  001e6	5f		 pop	 rdi
  001e7	5e		 pop	 rsi
  001e8	c3		 ret	 0
resize_inplace ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@EPAHIECA@Negative?5size?5passed?5to?5_PyUnico@ ; `string'
EXTRN	PyObject_Malloc:PROC
EXTRN	_PyObject_New:PROC
EXTRN	_PxObject_New:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_SystemError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_PyUnicode_New DD imagerel _PyUnicode_New
	DD	imagerel _PyUnicode_New+333
	DD	imagerel $unwind$_PyUnicode_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_New DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0CH@EPAHIECA@Negative?5size?5passed?5to?5_PyUnico@
CONST	SEGMENT
??_C@_0CH@EPAHIECA@Negative?5size?5passed?5to?5_PyUnico@ DB 'Negative siz'
	DB	'e passed to _PyUnicode_New', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT _PyUnicode_New
_TEXT	SEGMENT
length$ = 64
_PyUnicode_New PROC					; COMDAT

; 839  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 840  :     register PyUnicodeObject *unicode;
; 841  :     size_t new_size;
; 842  : 
; 843  :     /* Optimization for empty strings */
; 844  :     if (length == 0 && unicode_empty != NULL) {

  0000d	48 85 c9	 test	 rcx, rcx
  00010	75 5d		 jne	 SHORT $LN5@PyUnicode_
  00012	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR unicode_empty
  00019	48 85 db	 test	 rbx, rbx
  0001c	0f 84 90 00 00
	00		 je	 $LN3@PyUnicode_

; 845  :         Py_INCREF(unicode_empty);

  00022	e8 00 00 00 00	 call	 _Py_PXCTX
  00027	85 c0		 test	 eax, eax
  00029	75 32		 jne	 SHORT $LN11@PyUnicode_
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00039	4c 8b cb	 mov	 r9, rbx
  0003c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00042	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0004a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004f	85 c0		 test	 eax, eax
  00051	75 06		 jne	 SHORT $LN10@PyUnicode_
  00053	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00057	74 04		 je	 SHORT $LN11@PyUnicode_
$LN10@PyUnicode_:
  00059	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN11@PyUnicode_:

; 846  :         return (PyUnicodeObject*)unicode_empty;

  0005d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 892  : }

  00064	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00069	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
$LN5@PyUnicode_:

; 847  :     }
; 848  : 
; 849  :     /* Ensure we won't overflow the size. */
; 850  :     if (length > ((PY_SSIZE_T_MAX / sizeof(Py_UNICODE)) - 1)) {

  0006f	48 b8 fe ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387902 ; 3ffffffffffffffeH
  00079	48 3b c8	 cmp	 rcx, rax
  0007c	76 0f		 jbe	 SHORT $LN4@PyUnicode_

; 892  : }

  0007e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00083	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00087	5f		 pop	 rdi
  00088	e9 00 00 00 00	 jmp	 PyErr_NoMemory
$LN4@PyUnicode_:

; 851  :         return (PyUnicodeObject *)PyErr_NoMemory();
; 852  :     }
; 853  :     if (length < 0) {

  0008d	48 85 c9	 test	 rcx, rcx
  00090	79 20		 jns	 SHORT $LN3@PyUnicode_

; 854  :         PyErr_SetString(PyExc_SystemError,
; 855  :                         "Negative size passed to _PyUnicode_New");

  00092	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@EPAHIECA@Negative?5size?5passed?5to?5_PyUnico@
  000a0	e8 00 00 00 00	 call	 PyErr_SetString
$LN15@PyUnicode_:

; 856  :         return NULL;

  000a5	33 c0		 xor	 eax, eax

; 892  : }

  000a7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b0	5f		 pop	 rdi
  000b1	c3		 ret	 0
$LN3@PyUnicode_:

; 857  :     }
; 858  : 
; 859  :     unicode = PyObject_New(PyUnicodeObject, &PyUnicode_Type);

  000b2	e8 00 00 00 00	 call	 _Py_PXCTX
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyUnicode_Type
  000be	85 c0		 test	 eax, eax
  000c0	74 07		 je	 SHORT $LN8@PyUnicode_
  000c2	e8 00 00 00 00	 call	 _PxObject_New
  000c7	eb 05		 jmp	 SHORT $LN14@PyUnicode_
$LN8@PyUnicode_:
  000c9	e8 00 00 00 00	 call	 _PyObject_New
$LN14@PyUnicode_:
  000ce	48 8b d8	 mov	 rbx, rax

; 860  :     if (unicode == NULL)

  000d1	48 85 c0	 test	 rax, rax

; 861  :         return NULL;

  000d4	74 cf		 je	 SHORT $LN15@PyUnicode_

; 862  :     new_size = sizeof(Py_UNICODE) * ((size_t)length + 1);

  000d6	48 8d 4c 3f 02	 lea	 rcx, QWORD PTR [rdi+rdi+2]

; 863  :     _PyUnicode_WSTR(unicode) = (Py_UNICODE*) PyObject_MALLOC(new_size);

  000db	e8 00 00 00 00	 call	 PyObject_Malloc
  000e0	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 864  :     if (!_PyUnicode_WSTR(unicode)) {

  000e4	48 85 c0	 test	 rax, rax
  000e7	75 1a		 jne	 SHORT $LN1@PyUnicode_

; 865  :         Py_DECREF(unicode);

  000e9	48 8b cb	 mov	 rcx, rbx
  000ec	e8 00 00 00 00	 call	 _Py_DecRef

; 866  :         PyErr_NoMemory();

  000f1	e8 00 00 00 00	 call	 PyErr_NoMemory

; 867  :         return NULL;

  000f6	33 c0		 xor	 eax, eax

; 892  : }

  000f8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000fd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00101	5f		 pop	 rdi
  00102	c3		 ret	 0
$LN1@PyUnicode_:

; 868  :     }
; 869  : 
; 870  :     /* Initialize the first element to guard against cases where
; 871  :      * the caller fails before initializing str -- unicode_resize()
; 872  :      * reads str[0], and the Keep-Alive optimization can keep memory
; 873  :      * allocated for str alive across a call to unicode_dealloc(unicode).
; 874  :      * We don't want unicode_resize to read uninitialized memory in
; 875  :      * that case.
; 876  :      */
; 877  :     _PyUnicode_WSTR(unicode)[0] = 0;

  00103	33 c9		 xor	 ecx, ecx
  00105	66 89 08	 mov	 WORD PTR [rax], cx

; 878  :     _PyUnicode_WSTR(unicode)[length] = 0;

  00108	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]
  0010c	66 89 0c 78	 mov	 WORD PTR [rax+rdi*2], cx

; 879  :     _PyUnicode_WSTR_LENGTH(unicode) = length;
; 880  :     _PyUnicode_HASH(unicode) = -1;
; 881  :     _PyUnicode_STATE(unicode).interned = 0;
; 882  :     _PyUnicode_STATE(unicode).kind = 0;
; 883  :     _PyUnicode_STATE(unicode).compact = 0;
; 884  :     _PyUnicode_STATE(unicode).ready = 0;
; 885  :     _PyUnicode_STATE(unicode).ascii = 0;

  00110	81 63 70 00 ff
	ff ff		 and	 DWORD PTR [rbx+112], -256 ; ffffff00H
  00117	48 89 bb 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rdi
  0011e	48 c7 43 68 ff
	ff ff ff	 mov	 QWORD PTR [rbx+104], -1

; 886  :     _PyUnicode_DATA_ANY(unicode) = NULL;

  00126	48 89 8b a0 00
	00 00		 mov	 QWORD PTR [rbx+160], rcx

; 887  :     _PyUnicode_LENGTH(unicode) = 0;

  0012d	48 89 4b 60	 mov	 QWORD PTR [rbx+96], rcx

; 888  :     _PyUnicode_UTF8(unicode) = NULL;

  00131	48 89 8b 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rcx

; 889  :     _PyUnicode_UTF8_LENGTH(unicode) = 0;

  00138	48 89 8b 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rcx

; 890  :     assert(_PyUnicode_CheckConsistency((PyObject *)unicode, 0));
; 891  :     return unicode;

  0013f	48 8b c3	 mov	 rax, rbx

; 892  : }

  00142	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00147	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014b	5f		 pop	 rdi
  0014c	c3		 ret	 0
_PyUnicode_New ENDP
_TEXT	ENDS
PUBLIC	??_C@_06CDEFMFPB@latin1?$AA@			; `string'
PUBLIC	??_C@_05OJENGABA@ascii?$AA@			; `string'
PUBLIC	??_C@_04MDAFHLBC@UCS2?$AA@			; `string'
PUBLIC	??_C@_04JFFPNMJE@UCS4?$AA@			; `string'
PUBLIC	??_C@_0BH@KHFFJJFI@?$DMinvalid?5compact?5kind?$DO?$AA@ ; `string'
PUBLIC	??_C@_0O@IIFAHANF@legacy?5latin1?$AA@		; `string'
PUBLIC	??_C@_0N@CNMFBNDP@legacy?5ascii?$AA@		; `string'
PUBLIC	??_C@_0M@CKDCOMOL@legacy?5UCS2?$AA@		; `string'
PUBLIC	??_C@_0M@HMGIELGN@legacy?5UCS4?$AA@		; `string'
PUBLIC	??_C@_0BG@EPDLBLMN@?$DMlegacy?5invalid?5kind?$DO?$AA@ ; `string'
PUBLIC	??_C@_04EFFEOALH@wstr?$AA@			; `string'
;	COMDAT ??_C@_06CDEFMFPB@latin1?$AA@
CONST	SEGMENT
??_C@_06CDEFMFPB@latin1?$AA@ DB 'latin1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OJENGABA@ascii?$AA@
CONST	SEGMENT
??_C@_05OJENGABA@ascii?$AA@ DB 'ascii', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MDAFHLBC@UCS2?$AA@
CONST	SEGMENT
??_C@_04MDAFHLBC@UCS2?$AA@ DB 'UCS2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFFPNMJE@UCS4?$AA@
CONST	SEGMENT
??_C@_04JFFPNMJE@UCS4?$AA@ DB 'UCS4', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KHFFJJFI@?$DMinvalid?5compact?5kind?$DO?$AA@
CONST	SEGMENT
??_C@_0BH@KHFFJJFI@?$DMinvalid?5compact?5kind?$DO?$AA@ DB '<invalid compa'
	DB	'ct kind>', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IIFAHANF@legacy?5latin1?$AA@
CONST	SEGMENT
??_C@_0O@IIFAHANF@legacy?5latin1?$AA@ DB 'legacy latin1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CNMFBNDP@legacy?5ascii?$AA@
CONST	SEGMENT
??_C@_0N@CNMFBNDP@legacy?5ascii?$AA@ DB 'legacy ascii', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CKDCOMOL@legacy?5UCS2?$AA@
CONST	SEGMENT
??_C@_0M@CKDCOMOL@legacy?5UCS2?$AA@ DB 'legacy UCS2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HMGIELGN@legacy?5UCS4?$AA@
CONST	SEGMENT
??_C@_0M@HMGIELGN@legacy?5UCS4?$AA@ DB 'legacy UCS4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EPDLBLMN@?$DMlegacy?5invalid?5kind?$DO?$AA@
CONST	SEGMENT
??_C@_0BG@EPDLBLMN@?$DMlegacy?5invalid?5kind?$DO?$AA@ DB '<legacy invalid'
	DB	' kind>', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04EFFEOALH@wstr?$AA@
CONST	SEGMENT
??_C@_04EFFEOALH@wstr?$AA@ DB 'wstr', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_kind_name
_TEXT	SEGMENT
unicode$ = 8
unicode_kind_name PROC					; COMDAT

; 897  :     /* don't check consistency: unicode_kind_name() is called from
; 898  :        _PyUnicode_Dump() */
; 899  :     if (!PyUnicode_IS_COMPACT(unicode))

  00000	8b 51 70	 mov	 edx, DWORD PTR [rcx+112]
  00003	f6 c2 20	 test	 dl, 32			; 00000020H
  00006	75 4e		 jne	 SHORT $LN15@unicode_ki

; 900  :     {
; 901  :         if (!PyUnicode_IS_READY(unicode))

  00008	84 d2		 test	 dl, dl
  0000a	78 08		 js	 SHORT $LN17@unicode_ki

; 902  :             return "wstr";

  0000c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04EFFEOALH@wstr?$AA@

; 931  :     }
; 932  : }

  00013	c3		 ret	 0
$LN17@unicode_ki:

; 903  :         switch (PyUnicode_KIND(unicode))

  00014	8b c2		 mov	 eax, edx
  00016	c1 e8 02	 shr	 eax, 2
  00019	83 e0 07	 and	 eax, 7
  0001c	ff c8		 dec	 eax
  0001e	74 21		 je	 SHORT $LN14@unicode_ki
  00020	ff c8		 dec	 eax
  00022	74 15		 je	 SHORT $LN12@unicode_ki
  00024	83 f8 02	 cmp	 eax, 2
  00027	74 08		 je	 SHORT $LN10@unicode_ki

; 914  :         default:
; 915  :             return "<legacy invalid kind>";

  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@EPDLBLMN@?$DMlegacy?5invalid?5kind?$DO?$AA@

; 931  :     }
; 932  : }

  00030	c3		 ret	 0
$LN10@unicode_ki:

; 912  :         case PyUnicode_4BYTE_KIND:
; 913  :             return "legacy UCS4";

  00031	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0M@HMGIELGN@legacy?5UCS4?$AA@

; 931  :     }
; 932  : }

  00038	c3		 ret	 0
$LN12@unicode_ki:

; 910  :         case PyUnicode_2BYTE_KIND:
; 911  :             return "legacy UCS2";

  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0M@CKDCOMOL@legacy?5UCS2?$AA@

; 931  :     }
; 932  : }

  00040	c3		 ret	 0
$LN14@unicode_ki:

; 904  :         {
; 905  :         case PyUnicode_1BYTE_KIND:
; 906  :             if (PyUnicode_IS_ASCII(unicode))

  00041	f6 c2 40	 test	 dl, 64			; 00000040H
  00044	74 08		 je	 SHORT $LN13@unicode_ki

; 907  :                 return "legacy ascii";

  00046	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0N@CNMFBNDP@legacy?5ascii?$AA@

; 931  :     }
; 932  : }

  0004d	c3		 ret	 0
$LN13@unicode_ki:

; 908  :             else
; 909  :                 return "legacy latin1";

  0004e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0O@IIFAHANF@legacy?5latin1?$AA@

; 931  :     }
; 932  : }

  00055	c3		 ret	 0
$LN15@unicode_ki:

; 916  :         }
; 917  :     }
; 918  :     assert(PyUnicode_IS_READY(unicode));
; 919  :     switch (PyUnicode_KIND(unicode)) {

  00056	8b c2		 mov	 eax, edx
  00058	c1 e8 02	 shr	 eax, 2
  0005b	83 e0 07	 and	 eax, 7
  0005e	ff c8		 dec	 eax
  00060	74 21		 je	 SHORT $LN6@unicode_ki
  00062	ff c8		 dec	 eax
  00064	74 15		 je	 SHORT $LN4@unicode_ki
  00066	83 f8 02	 cmp	 eax, 2
  00069	74 08		 je	 SHORT $LN2@unicode_ki

; 929  :     default:
; 930  :         return "<invalid compact kind>";

  0006b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@KHFFJJFI@?$DMinvalid?5compact?5kind?$DO?$AA@

; 931  :     }
; 932  : }

  00072	c3		 ret	 0
$LN2@unicode_ki:

; 927  :     case PyUnicode_4BYTE_KIND:
; 928  :         return "UCS4";

  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04JFFPNMJE@UCS4?$AA@

; 931  :     }
; 932  : }

  0007a	c3		 ret	 0
$LN4@unicode_ki:

; 925  :     case PyUnicode_2BYTE_KIND:
; 926  :         return "UCS2";

  0007b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04MDAFHLBC@UCS2?$AA@

; 931  :     }
; 932  : }

  00082	c3		 ret	 0
$LN6@unicode_ki:

; 920  :     case PyUnicode_1BYTE_KIND:
; 921  :         if (PyUnicode_IS_ASCII(unicode))
; 922  :             return "ascii";

  00083	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05OJENGABA@ascii?$AA@
  0008a	f6 c2 40	 test	 dl, 64			; 00000040H
  0008d	75 07		 jne	 SHORT $LN7@unicode_ki

; 923  :         else
; 924  :             return "latin1";

  0008f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06CDEFMFPB@latin1?$AA@
$LN7@unicode_ki:

; 931  :     }
; 932  : }

  00096	f3 c3		 fatret	 0
unicode_kind_name ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@MEMGHDAO@Negative?5size?5passed?5to?5PyUnicod@ ; `string'
PUBLIC	??_C@_0DC@FKABDMKG@invalid?5maximum?5character?5passed@ ; `string'
PUBLIC	PyUnicode_New
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyUnicode_New DD imagerel $LN36
	DD	imagerel $LN36+118
	DD	imagerel $unwind$PyUnicode_New
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyUnicode_New DD imagerel $LN36+118
	DD	imagerel $LN36+491
	DD	imagerel $chain$1$PyUnicode_New
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyUnicode_New DD imagerel $LN36+491
	DD	imagerel $LN36+538
	DD	imagerel $chain$3$PyUnicode_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyUnicode_New DD 040021H
	DD	09c400H
	DD	085400H
	DD	imagerel $LN36
	DD	imagerel $LN36+118
	DD	imagerel $unwind$PyUnicode_New
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyUnicode_New DD 040a21H
	DD	09c40aH
	DD	085405H
	DD	imagerel $LN36
	DD	imagerel $LN36+118
	DD	imagerel $unwind$PyUnicode_New
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_New DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0CG@MEMGHDAO@Negative?5size?5passed?5to?5PyUnicod@
CONST	SEGMENT
??_C@_0CG@MEMGHDAO@Negative?5size?5passed?5to?5PyUnicod@ DB 'Negative siz'
	DB	'e passed to PyUnicode_New', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@FKABDMKG@invalid?5maximum?5character?5passed@
CONST	SEGMENT
??_C@_0DC@FKABDMKG@invalid?5maximum?5character?5passed@ DB 'invalid maxim'
	DB	'um character passed to PyUnicode_New', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT PyUnicode_New
_TEXT	SEGMENT
size$ = 64
maxchar$ = 72
PyUnicode_New PROC					; COMDAT

; 988  : {

$LN36:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b d9	 mov	 rbx, rcx

; 989  :     PyObject *obj;
; 990  :     PyCompactUnicodeObject *unicode;
; 991  :     void *data;
; 992  :     enum PyUnicode_Kind kind;
; 993  :     int is_sharing, is_ascii;
; 994  :     Py_ssize_t char_size;
; 995  :     Py_ssize_t struct_size;
; 996  :     Py_ssize_t alloc_size;
; 997  : 
; 998  :     /* Optimization for empty strings */
; 999  :     if (size == 0 && unicode_empty != NULL) {

  00012	48 85 c9	 test	 rcx, rcx
  00015	75 5f		 jne	 SHORT $LN24@PyUnicode_@2
  00017	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR unicode_empty
  0001e	48 85 ff	 test	 rdi, rdi
  00021	74 53		 je	 SHORT $LN24@PyUnicode_@2

; 1000 :         Py_INCREF(unicode_empty);

  00023	e8 00 00 00 00	 call	 _Py_PXCTX
  00028	85 c0		 test	 eax, eax
  0002a	75 33		 jne	 SHORT $LN28@PyUnicode_@2
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0003a	be 02 00 00 00	 mov	 esi, 2
  0003f	4c 8b cf	 mov	 r9, rdi
  00042	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00048	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  0004c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00051	85 c0		 test	 eax, eax
  00053	75 06		 jne	 SHORT $LN27@PyUnicode_@2
  00055	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00059	74 04		 je	 SHORT $LN28@PyUnicode_@2
$LN27@PyUnicode_@2:
  0005b	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN28@PyUnicode_@2:

; 1001 :         return unicode_empty;

  0005f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 1104 : }

  00066	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0006b	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00070	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00074	5f		 pop	 rdi
  00075	c3		 ret	 0
$LN24@PyUnicode_@2:
  00076	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  0007b	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12

; 1002 :     }
; 1003 : 
; 1004 :     is_ascii = 0;

  00080	45 33 e4	 xor	 r12d, r12d

; 1005 :     is_sharing = 0;
; 1006 :     struct_size = sizeof(PyCompactUnicodeObject);

  00083	41 b9 a0 00 00
	00		 mov	 r9d, 160		; 000000a0H
  00089	41 8b fc	 mov	 edi, r12d
  0008c	41 8b ec	 mov	 ebp, r12d

; 1007 :     if (maxchar < 128) {

  0008f	81 fa 80 00 00
	00		 cmp	 edx, 128		; 00000080H
  00095	73 10		 jae	 SHORT $LN23@PyUnicode_@2

; 1008 :         kind = PyUnicode_1BYTE_KIND;

  00097	be 01 00 00 00	 mov	 esi, 1

; 1009 :         char_size = 1;
; 1010 :         is_ascii = 1;

  0009c	8b fe		 mov	 edi, esi
  0009e	44 8b c6	 mov	 r8d, esi

; 1011 :         struct_size = sizeof(PyASCIIObject);

  000a1	44 8d 4e 7f	 lea	 r9d, QWORD PTR [rsi+127]
  000a5	eb 52		 jmp	 SHORT $LN15@PyUnicode_@2
$LN23@PyUnicode_@2:

; 1012 :     }
; 1013 :     else if (maxchar < 256) {

  000a7	81 fa 00 01 00
	00		 cmp	 edx, 256		; 00000100H
  000ad	73 0a		 jae	 SHORT $LN21@PyUnicode_@2

; 1014 :         kind = PyUnicode_1BYTE_KIND;

  000af	be 01 00 00 00	 mov	 esi, 1

; 1015 :         char_size = 1;

  000b4	44 8b c6	 mov	 r8d, esi
  000b7	eb 40		 jmp	 SHORT $LN15@PyUnicode_@2
$LN21@PyUnicode_@2:

; 1016 :     }
; 1017 :     else if (maxchar < 65536) {

  000b9	81 fa 00 00 01
	00		 cmp	 edx, 65536		; 00010000H
  000bf	73 0d		 jae	 SHORT $LN19@PyUnicode_@2

; 1018 :         kind = PyUnicode_2BYTE_KIND;

  000c1	be 02 00 00 00	 mov	 esi, 2

; 1019 :         char_size = 2;

  000c6	44 8b c6	 mov	 r8d, esi

; 1020 :         if (sizeof(wchar_t) == 2)
; 1021 :             is_sharing = 1;

  000c9	8d 6e ff	 lea	 ebp, QWORD PTR [rsi-1]

; 1022 :     }
; 1023 :     else {

  000cc	eb 2b		 jmp	 SHORT $LN15@PyUnicode_@2
$LN19@PyUnicode_@2:

; 1024 :         if (maxchar > MAX_UNICODE) {

  000ce	81 fa ff ff 10
	00		 cmp	 edx, 1114111		; 0010ffffH
  000d4	76 1a		 jbe	 SHORT $LN16@PyUnicode_@2

; 1025 :             PyErr_SetString(PyExc_SystemError,
; 1026 :                             "invalid maximum character passed to PyUnicode_New");

  000d6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@FKABDMKG@invalid?5maximum?5character?5passed@
  000e4	e8 00 00 00 00	 call	 PyErr_SetString

; 1027 :             return NULL;

  000e9	33 c0		 xor	 eax, eax
  000eb	e9 e1 00 00 00	 jmp	 $LN32@PyUnicode_@2
$LN16@PyUnicode_@2:

; 1028 :         }
; 1029 :         kind = PyUnicode_4BYTE_KIND;

  000f0	41 b8 04 00 00
	00		 mov	 r8d, 4
  000f6	41 8b f0	 mov	 esi, r8d
$LN15@PyUnicode_@2:

; 1030 :         char_size = 4;
; 1031 :         if (sizeof(wchar_t) == 4)
; 1032 :             is_sharing = 1;
; 1033 :     }
; 1034 : 
; 1035 :     /* Ensure we won't overflow the size. */
; 1036 :     if (size < 0) {

  000f9	48 85 c9	 test	 rcx, rcx
  000fc	79 1a		 jns	 SHORT $LN14@PyUnicode_@2

; 1037 :         PyErr_SetString(PyExc_SystemError,
; 1038 :                         "Negative size passed to PyUnicode_New");

  000fe	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00105	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@MEMGHDAO@Negative?5size?5passed?5to?5PyUnicod@
  0010c	e8 00 00 00 00	 call	 PyErr_SetString
$LN34@PyUnicode_@2:

; 1039 :         return NULL;

  00111	33 c0		 xor	 eax, eax
  00113	e9 b9 00 00 00	 jmp	 $LN32@PyUnicode_@2
$LN14@PyUnicode_@2:

; 1040 :     }
; 1041 :     if (size > ((PY_SSIZE_T_MAX - struct_size) / char_size - 1))

  00118	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00122	49 2b c1	 sub	 rax, r9
  00125	48 99		 cdq
  00127	49 f7 f8	 idiv	 r8
  0012a	48 ff c8	 dec	 rax
  0012d	48 3b c8	 cmp	 rcx, rax

; 1042 :         return PyErr_NoMemory();

  00130	7f 14		 jg	 SHORT $LN35@PyUnicode_@2

; 1043 : 
; 1044 :     /* Duplicated allocation code from _PyObject_New() instead of a call to
; 1045 :      * PyObject_New() so we are able to allocate space for the object and
; 1046 :      * it's data buffer.
; 1047 :      */
; 1048 :     alloc_size = struct_size + (size + 1) * char_size;

  00132	48 ff c1	 inc	 rcx
  00135	49 0f af c8	 imul	 rcx, r8
  00139	49 03 c9	 add	 rcx, r9

; 1049 :     obj = (PyObject *) PyObject_MALLOC(alloc_size);

  0013c	e8 00 00 00 00	 call	 PyObject_Malloc

; 1050 :     if (obj == NULL)

  00141	48 85 c0	 test	 rax, rax
  00144	75 0a		 jne	 SHORT $LN12@PyUnicode_@2
$LN35@PyUnicode_@2:

; 1051 :         return PyErr_NoMemory();

  00146	e8 00 00 00 00	 call	 PyErr_NoMemory
  0014b	e9 81 00 00 00	 jmp	 $LN32@PyUnicode_@2
$LN12@PyUnicode_@2:

; 1052 :     obj = PyObject_INIT(obj, &PyUnicode_Type);

  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyUnicode_Type
  00157	48 8b c8	 mov	 rcx, rax
  0015a	e8 00 00 00 00	 call	 PyObject_INIT
  0015f	4c 8b d8	 mov	 r11, rax

; 1053 :     if (obj == NULL)

  00162	48 85 c0	 test	 rax, rax

; 1054 :         return NULL;

  00165	74 aa		 je	 SHORT $LN34@PyUnicode_@2

; 1055 : 
; 1056 :     unicode = (PyCompactUnicodeObject *)obj;
; 1057 :     if (is_ascii)
; 1058 :         data = ((PyASCIIObject*)obj) + 1;

  00167	48 8d 90 80 00
	00 00		 lea	 rdx, QWORD PTR [rax+128]
  0016e	85 ff		 test	 edi, edi
  00170	75 07		 jne	 SHORT $LN9@PyUnicode_@2

; 1059 :     else
; 1060 :         data = unicode + 1;

  00172	48 8d 90 a0 00
	00 00		 lea	 rdx, QWORD PTR [rax+160]
$LN9@PyUnicode_@2:
  00179	83 60 70 a0	 and	 DWORD PTR [rax+112], -96 ; ffffffa0H

; 1061 :     _PyUnicode_LENGTH(unicode) = size;

  0017d	48 89 58 60	 mov	 QWORD PTR [rax+96], rbx

; 1062 :     _PyUnicode_HASH(unicode) = -1;

  00181	48 c7 40 68 ff
	ff ff ff	 mov	 QWORD PTR [rax+104], -1

; 1063 :     _PyUnicode_STATE(unicode).interned = 0;
; 1064 :     _PyUnicode_STATE(unicode).kind = kind;
; 1065 :     _PyUnicode_STATE(unicode).compact = 1;
; 1066 :     _PyUnicode_STATE(unicode).ready = 1;
; 1067 :     _PyUnicode_STATE(unicode).ascii = is_ascii;

  00189	8b cf		 mov	 ecx, edi
  0018b	8b c6		 mov	 eax, esi
  0018d	83 e1 01	 and	 ecx, 1
  00190	83 e0 07	 and	 eax, 7
  00193	c1 e1 04	 shl	 ecx, 4
  00196	0b c8		 or	 ecx, eax
  00198	83 c9 28	 or	 ecx, 40			; 00000028H
  0019b	c1 e1 02	 shl	 ecx, 2
  0019e	41 09 4b 70	 or	 DWORD PTR [r11+112], ecx

; 1068 :     if (is_ascii) {

  001a2	85 ff		 test	 edi, edi
  001a4	74 06		 je	 SHORT $LN8@PyUnicode_@2

; 1069 :         ((char*)data)[size] = 0;

  001a6	44 88 24 1a	 mov	 BYTE PTR [rdx+rbx], r12b

; 1070 :         _PyUnicode_WSTR(unicode) = NULL;

  001aa	eb 1e		 jmp	 SHORT $LN33@PyUnicode_@2
$LN8@PyUnicode_@2:

; 1071 :     }
; 1072 :     else if (kind == PyUnicode_1BYTE_KIND) {

  001ac	83 fe 01	 cmp	 esi, 1
  001af	75 3a		 jne	 SHORT $LN6@PyUnicode_@2

; 1073 :         ((char*)data)[size] = 0;

  001b1	44 88 24 1a	 mov	 BYTE PTR [rdx+rbx], r12b

; 1074 :         _PyUnicode_WSTR(unicode) = NULL;
; 1075 :         _PyUnicode_WSTR_LENGTH(unicode) = 0;
; 1076 :         unicode->utf8 = NULL;

  001b5	4d 89 a3 88 00
	00 00		 mov	 QWORD PTR [r11+136], r12

; 1077 :         unicode->utf8_length = 0;

  001bc	4d 89 a3 80 00
	00 00		 mov	 QWORD PTR [r11+128], r12
$LN2@PyUnicode_@2:

; 1091 :             _PyUnicode_WSTR_LENGTH(unicode) = 0;

  001c3	4d 89 a3 90 00
	00 00		 mov	 QWORD PTR [r11+144], r12
$LN33@PyUnicode_@2:

; 1092 :             _PyUnicode_WSTR(unicode) = NULL;

  001ca	4d 89 63 78	 mov	 QWORD PTR [r11+120], r12
$LN1@PyUnicode_@2:

; 1093 :         }
; 1094 :     }
; 1095 : #ifdef Py_DEBUG
; 1096 :     /* Fill the data with invalid characters to detect bugs earlier.
; 1097 :        _PyUnicode_CheckConsistency(str, 1) detects invalid characters,
; 1098 :        at least for ASCII and UCS-4 strings. U+00FF is invalid in ASCII
; 1099 :        and U+FFFFFFFF is an invalid character in Unicode 6.0. */
; 1100 :     memset(data, 0xff, size * kind);
; 1101 : #endif
; 1102 :     assert(_PyUnicode_CheckConsistency((PyObject*)unicode, 0));
; 1103 :     return obj;

  001ce	49 8b c3	 mov	 rax, r11
$LN32@PyUnicode_@2:
  001d1	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  001d6	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]

; 1104 : }

  001db	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001e0	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  001e5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001e9	5f		 pop	 rdi
  001ea	c3		 ret	 0
$LN6@PyUnicode_@2:

; 1078 :     }
; 1079 :     else {
; 1080 :         unicode->utf8 = NULL;

  001eb	4d 89 a3 88 00
	00 00		 mov	 QWORD PTR [r11+136], r12

; 1081 :         unicode->utf8_length = 0;

  001f2	4d 89 a3 80 00
	00 00		 mov	 QWORD PTR [r11+128], r12

; 1082 :         if (kind == PyUnicode_2BYTE_KIND)

  001f9	83 fe 02	 cmp	 esi, 2
  001fc	75 07		 jne	 SHORT $LN4@PyUnicode_@2

; 1083 :             ((Py_UCS2*)data)[size] = 0;

  001fe	66 44 89 24 5a	 mov	 WORD PTR [rdx+rbx*2], r12w

; 1084 :         else /* kind == PyUnicode_4BYTE_KIND */

  00203	eb 04		 jmp	 SHORT $LN3@PyUnicode_@2
$LN4@PyUnicode_@2:

; 1085 :             ((Py_UCS4*)data)[size] = 0;

  00205	44 89 24 9a	 mov	 DWORD PTR [rdx+rbx*4], r12d
$LN3@PyUnicode_@2:

; 1086 :         if (is_sharing) {

  00209	85 ed		 test	 ebp, ebp
  0020b	74 b6		 je	 SHORT $LN2@PyUnicode_@2

; 1087 :             _PyUnicode_WSTR_LENGTH(unicode) = size;

  0020d	49 89 9b 90 00
	00 00		 mov	 QWORD PTR [r11+144], rbx

; 1088 :             _PyUnicode_WSTR(unicode) = (wchar_t *)data;

  00214	49 89 53 78	 mov	 QWORD PTR [r11+120], rdx

; 1089 :         }
; 1090 :         else {

  00218	eb b4		 jmp	 SHORT $LN1@PyUnicode_@2
PyUnicode_New ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_convert_wchar_to_ucs4 DD imagerel unicode_convert_wchar_to_ucs4
	DD	imagerel unicode_convert_wchar_to_ucs4+50
	DD	imagerel $unwind$unicode_convert_wchar_to_ucs4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$unicode_convert_wchar_to_ucs4 DD imagerel unicode_convert_wchar_to_ucs4+50
	DD	imagerel unicode_convert_wchar_to_ucs4+201
	DD	imagerel $chain$2$unicode_convert_wchar_to_ucs4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$unicode_convert_wchar_to_ucs4 DD imagerel unicode_convert_wchar_to_ucs4+201
	DD	imagerel unicode_convert_wchar_to_ucs4+206
	DD	imagerel $chain$3$unicode_convert_wchar_to_ucs4
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$unicode_convert_wchar_to_ucs4 DD 021H
	DD	imagerel unicode_convert_wchar_to_ucs4
	DD	imagerel unicode_convert_wchar_to_ucs4+50
	DD	imagerel $unwind$unicode_convert_wchar_to_ucs4
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$unicode_convert_wchar_to_ucs4 DD 061321H
	DD	07413H
	DD	03640aH
	DD	023405H
	DD	imagerel unicode_convert_wchar_to_ucs4
	DD	imagerel unicode_convert_wchar_to_ucs4+50
	DD	imagerel $unwind$unicode_convert_wchar_to_ucs4
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_convert_wchar_to_ucs4 DD 010401H
	DD	0204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_convert_wchar_to_ucs4
_TEXT	SEGMENT
begin$ = 16
end$ = 24
unicode$ = 32
unicode_convert_wchar_to_ucs4 PROC			; COMDAT

; 1116 : {

  00000	48 83 ec 08	 sub	 rsp, 8

; 1117 :     const wchar_t *iter;
; 1118 :     Py_UCS4 *ucs4_out;
; 1119 : 
; 1120 :     assert(unicode != NULL);
; 1121 :     assert(_PyUnicode_CHECK(unicode));
; 1122 :     assert(_PyUnicode_KIND(unicode) == PyUnicode_4BYTE_KIND);
; 1123 :     ucs4_out = PyUnicode_4BYTE_DATA(unicode);

  00004	41 8b 40 70	 mov	 eax, DWORD PTR [r8+112]
  00008	4c 8b d2	 mov	 r10, rdx
  0000b	a8 20		 test	 al, 32			; 00000020H
  0000d	74 13		 je	 SHORT $LN9@unicode_co
  0000f	a8 40		 test	 al, 64			; 00000040H
  00011	74 06		 je	 SHORT $LN7@unicode_co
  00013	49 83 e8 80	 sub	 r8, -128		; ffffffffffffff80H
  00017	eb 10		 jmp	 SHORT $LN10@unicode_co
$LN7@unicode_co:
  00019	49 81 c0 a0 00
	00 00		 add	 r8, 160			; 000000a0H
  00020	eb 07		 jmp	 SHORT $LN10@unicode_co
$LN9@unicode_co:
  00022	4d 8b 80 a0 00
	00 00		 mov	 r8, QWORD PTR [r8+160]
$LN10@unicode_co:

; 1124 : 
; 1125 :     for (iter = begin; iter < end; ) {

  00029	48 3b ca	 cmp	 rcx, rdx
  0002c	0f 83 97 00 00
	00		 jae	 $LN3@unicode_co
  00032	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00037	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0003c	bb ff db 00 00	 mov	 ebx, 56319		; 0000dbffH
  00041	48 89 3c 24	 mov	 QWORD PTR [rsp], rdi
  00045	48 8d 51 02	 lea	 rdx, QWORD PTR [rcx+2]
  00049	41 bb 00 d8 00
	00		 mov	 r11d, 55296		; 0000d800H
  0004f	8d 7b 01	 lea	 edi, QWORD PTR [rbx+1]
  00052	be ff df 00 00	 mov	 esi, 57343		; 0000dfffH
$LL4@unicode_co:

; 1126 :         assert(ucs4_out < (PyUnicode_4BYTE_DATA(unicode) +
; 1127 :                            _PyUnicode_GET_LENGTH(unicode)));
; 1128 :         if (Py_UNICODE_IS_HIGH_SURROGATE(iter[0])
; 1129 :             && (iter+1) < end
; 1130 :             && Py_UNICODE_IS_LOW_SURROGATE(iter[1]))

  00057	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  0005a	66 44 3b d8	 cmp	 r11w, ax
  0005e	77 43		 ja	 SHORT $LN2@unicode_co
  00060	66 3b c3	 cmp	 ax, bx
  00063	77 3e		 ja	 SHORT $LN2@unicode_co
  00065	49 3b d2	 cmp	 rdx, r10
  00068	73 39		 jae	 SHORT $LN2@unicode_co
  0006a	44 0f b7 0a	 movzx	 r9d, WORD PTR [rdx]
  0006e	66 41 3b f9	 cmp	 di, r9w
  00072	77 2f		 ja	 SHORT $LN2@unicode_co
  00074	66 44 3b ce	 cmp	 r9w, si
  00078	77 29		 ja	 SHORT $LN2@unicode_co

; 1131 :         {
; 1132 :             *ucs4_out++ = Py_UNICODE_JOIN_SURROGATES(iter[0], iter[1]);

  0007a	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0007f	41 81 e1 ff 03
	00 00		 and	 r9d, 1023		; 000003ffH
  00086	49 83 c0 04	 add	 r8, 4
  0008a	c1 e0 0a	 shl	 eax, 10

; 1133 :             iter += 2;

  0008d	48 83 c1 04	 add	 rcx, 4
  00091	41 0b c1	 or	 eax, r9d
  00094	05 00 00 01 00	 add	 eax, 65536		; 00010000H
  00099	48 83 c2 04	 add	 rdx, 4
  0009d	41 89 40 fc	 mov	 DWORD PTR [r8-4], eax

; 1134 :         }
; 1135 :         else {

  000a1	eb 13		 jmp	 SHORT $LN1@unicode_co
$LN2@unicode_co:

; 1136 :             *ucs4_out++ = *iter;

  000a3	0f b7 c0	 movzx	 eax, ax
  000a6	49 83 c0 04	 add	 r8, 4

; 1137 :             iter++;

  000aa	48 83 c1 02	 add	 rcx, 2
  000ae	41 89 40 fc	 mov	 DWORD PTR [r8-4], eax
  000b2	48 83 c2 02	 add	 rdx, 2
$LN1@unicode_co:

; 1124 : 
; 1125 :     for (iter = begin; iter < end; ) {

  000b6	49 3b ca	 cmp	 rcx, r10
  000b9	72 9c		 jb	 SHORT $LL4@unicode_co
  000bb	48 8b 3c 24	 mov	 rdi, QWORD PTR [rsp]
  000bf	48 8b 74 24 18	 mov	 rsi, QWORD PTR [rsp+24]
  000c4	48 8b 5c 24 10	 mov	 rbx, QWORD PTR [rsp+16]
$LN3@unicode_co:

; 1138 :         }
; 1139 :     }
; 1140 :     assert(ucs4_out == (PyUnicode_4BYTE_DATA(unicode) +
; 1141 :                         _PyUnicode_GET_LENGTH(unicode)));
; 1142 : 
; 1143 : }

  000c9	48 83 c4 08	 add	 rsp, 8
  000cd	c3		 ret	 0
unicode_convert_wchar_to_ucs4 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_copy_characters DD imagerel _copy_characters
	DD	imagerel _copy_characters+43
	DD	imagerel $unwind$_copy_characters
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_copy_characters DD imagerel _copy_characters+43
	DD	imagerel _copy_characters+285
	DD	imagerel $chain$4$_copy_characters
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$_copy_characters DD imagerel _copy_characters+285
	DD	imagerel _copy_characters+2040
	DD	imagerel $chain$6$_copy_characters
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$_copy_characters DD 0a0021H
	DD	04c400H
	DD	057400H
	DD	0c6400H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel _copy_characters
	DD	imagerel _copy_characters+43
	DD	imagerel $unwind$_copy_characters
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_copy_characters DD 0a7421H
	DD	04c474H
	DD	0b546fH
	DD	0a346aH
	DD	0c6439H
	DD	057405H
	DD	imagerel _copy_characters
	DD	imagerel _copy_characters+43
	DD	imagerel $unwind$_copy_characters
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_copy_characters DD 040a01H
	DD	0f006520aH
	DD	0d002e004H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _copy_characters
_TEXT	SEGMENT
to$ = 80
to_start$ = 88
from$ = 96
from_start$ = 104
how_many$ = 112
check_maxchar$ = 120
_copy_characters PROC					; COMDAT

; 1161 : {

  00000	41 55		 push	 r13
  00002	41 56		 push	 r14
  00004	41 57		 push	 r15
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1162 :     unsigned int from_kind, to_kind;
; 1163 :     void *from_data, *to_data;
; 1164 : 
; 1165 :     assert(0 <= how_many);
; 1166 :     assert(0 <= from_start);
; 1167 :     assert(0 <= to_start);
; 1168 :     assert(PyUnicode_Check(from));
; 1169 :     assert(PyUnicode_IS_READY(from));
; 1170 :     assert(from_start + how_many <= PyUnicode_GET_LENGTH(from));
; 1171 : 
; 1172 :     assert(PyUnicode_Check(to));
; 1173 :     assert(PyUnicode_IS_READY(to));
; 1174 :     assert(to_start + how_many <= PyUnicode_GET_LENGTH(to));
; 1175 : 
; 1176 :     if (how_many == 0)

  0000a	4c 8b 7c 24 70	 mov	 r15, QWORD PTR how_many$[rsp]
  0000f	4d 8b e9	 mov	 r13, r9
  00012	4c 8b f2	 mov	 r14, rdx
  00015	4d 85 ff	 test	 r15, r15
  00018	75 0d		 jne	 SHORT $LN81@copy_chara

; 1177 :         return 0;

  0001a	33 c0		 xor	 eax, eax

; 1297 : }

  0001c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00020	41 5f		 pop	 r15
  00022	41 5e		 pop	 r14
  00024	41 5d		 pop	 r13
  00026	c3		 ret	 0
$LN81@copy_chara:

; 1178 : 
; 1179 :     from_kind = PyUnicode_KIND(from);

  00027	41 8b 40 70	 mov	 eax, DWORD PTR [r8+112]
  0002b	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  00030	44 8b c8	 mov	 r9d, eax
  00033	41 c1 e9 02	 shr	 r9d, 2
  00037	41 83 e1 07	 and	 r9d, 7

; 1180 :     from_data = PyUnicode_DATA(from);

  0003b	a8 20		 test	 al, 32			; 00000020H
  0003d	74 16		 je	 SHORT $LN86@copy_chara
  0003f	a8 40		 test	 al, 64			; 00000040H
  00041	74 09		 je	 SHORT $LN84@copy_chara
  00043	49 8d b8 80 00
	00 00		 lea	 rdi, QWORD PTR [r8+128]
  0004a	eb 10		 jmp	 SHORT $LN87@copy_chara
$LN84@copy_chara:
  0004c	49 8d b8 a0 00
	00 00		 lea	 rdi, QWORD PTR [r8+160]
  00053	eb 07		 jmp	 SHORT $LN87@copy_chara
$LN86@copy_chara:
  00055	49 8b b8 a0 00
	00 00		 mov	 rdi, QWORD PTR [r8+160]
$LN87@copy_chara:

; 1181 :     to_kind = PyUnicode_KIND(to);

  0005c	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  0005f	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00064	44 8b d8	 mov	 r11d, eax
  00067	41 c1 eb 02	 shr	 r11d, 2
  0006b	41 83 e3 07	 and	 r11d, 7

; 1182 :     to_data = PyUnicode_DATA(to);

  0006f	a8 20		 test	 al, 32			; 00000020H
  00071	74 16		 je	 SHORT $LN90@copy_chara
  00073	a8 40		 test	 al, 64			; 00000040H
  00075	74 09		 je	 SHORT $LN88@copy_chara
  00077	48 8d b1 80 00
	00 00		 lea	 rsi, QWORD PTR [rcx+128]
  0007e	eb 10		 jmp	 SHORT $LN91@copy_chara
$LN88@copy_chara:
  00080	48 8d b1 a0 00
	00 00		 lea	 rsi, QWORD PTR [rcx+160]
  00087	eb 07		 jmp	 SHORT $LN91@copy_chara
$LN90@copy_chara:
  00089	48 8b b1 a0 00
	00 00		 mov	 rsi, QWORD PTR [rcx+160]
$LN91@copy_chara:
  00090	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00095	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  0009a	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12

; 1183 : 
; 1184 : #ifdef Py_DEBUG
; 1185 :     if (!check_maxchar
; 1186 :         && PyUnicode_MAX_CHAR_VALUE(from) > PyUnicode_MAX_CHAR_VALUE(to))
; 1187 :     {
; 1188 :         const Py_UCS4 to_maxchar = PyUnicode_MAX_CHAR_VALUE(to);
; 1189 :         Py_UCS4 ch;
; 1190 :         Py_ssize_t i;
; 1191 :         for (i=0; i < how_many; i++) {
; 1192 :             ch = PyUnicode_READ(from_kind, from_data, from_start + i);
; 1193 :             assert(ch <= to_maxchar);
; 1194 :         }
; 1195 :     }
; 1196 : #endif
; 1197 : 
; 1198 :     if (from_kind == to_kind) {

  0009f	45 3b cb	 cmp	 r9d, r11d
  000a2	0f 85 99 00 00
	00		 jne	 $LN80@copy_chara

; 1199 :         if (check_maxchar
; 1200 :             && !PyUnicode_IS_ASCII(from) && PyUnicode_IS_ASCII(to))

  000a8	83 7c 24 78 00	 cmp	 DWORD PTR check_maxchar$[rsp], 0
  000ad	74 22		 je	 SHORT $LN77@copy_chara
  000af	41 f6 40 70 40	 test	 BYTE PTR [r8+112], 64	; 00000040H
  000b4	75 1b		 jne	 SHORT $LN77@copy_chara
  000b6	a8 40		 test	 al, 64			; 00000040H
  000b8	74 17		 je	 SHORT $LN77@copy_chara

; 1201 :         {
; 1202 :             /* Writing Latin-1 characters into an ASCII string requires to
; 1203 :                check that all written characters are pure ASCII */
; 1204 :             Py_UCS4 max_char;
; 1205 :             max_char = ucs1lib_find_max_char(from_data,
; 1206 :                                              (Py_UCS1*)from_data + how_many);

  000ba	4a 8d 14 3f	 lea	 rdx, QWORD PTR [rdi+r15]
  000be	48 8b cf	 mov	 rcx, rdi
  000c1	e8 00 00 00 00	 call	 ucs1lib_find_max_char

; 1207 :             if (max_char >= 128)

  000c6	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H

; 1208 :                 return -1;

  000cb	0f 83 1f 07 00
	00		 jae	 $LN186@copy_chara
$LN77@copy_chara:

; 1209 :         }
; 1210 :         Py_MEMCPY((char*)to_data + to_kind * to_start,
; 1211 :                   (char*)from_data + from_kind * from_start,
; 1212 :                   to_kind * how_many);

  000d1	41 8b cb	 mov	 ecx, r11d
  000d4	41 8b d1	 mov	 edx, r9d
  000d7	45 8b c3	 mov	 r8d, r11d
  000da	49 0f af ce	 imul	 rcx, r14
  000de	49 0f af d5	 imul	 rdx, r13
  000e2	4d 0f af c7	 imul	 r8, r15
  000e6	48 03 ce	 add	 rcx, rsi
  000e9	48 03 d7	 add	 rdx, rdi
  000ec	49 83 f8 10	 cmp	 r8, 16
  000f0	72 2b		 jb	 SHORT $LN74@copy_chara
  000f2	e8 00 00 00 00	 call	 memcpy
$LN10@copy_chara:

; 1293 :             }
; 1294 :         }
; 1295 :     }
; 1296 :     return 0;

  000f7	33 c0		 xor	 eax, eax
$LN207@copy_chara:
  000f9	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000fe	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00103	4c 8b 64 24 20	 mov	 r12, QWORD PTR [rsp+32]
  00108	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0010d	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]

; 1297 : }

  00112	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00116	41 5f		 pop	 r15
  00118	41 5e		 pop	 r14
  0011a	41 5d		 pop	 r13
  0011c	c3		 ret	 0
$LN74@copy_chara:

; 1209 :         }
; 1210 :         Py_MEMCPY((char*)to_data + to_kind * to_start,
; 1211 :                   (char*)from_data + from_kind * from_start,
; 1212 :                   to_kind * how_many);

  0011d	4d 85 c0	 test	 r8, r8
  00120	74 d5		 je	 SHORT $LN10@copy_chara
  00122	48 2b d1	 sub	 rdx, rcx
  00125	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL72@copy_chara:
  00130	0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+rcx]
  00134	48 ff c1	 inc	 rcx
  00137	49 ff c8	 dec	 r8
  0013a	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0013d	75 f1		 jne	 SHORT $LL72@copy_chara

; 1213 :     }
; 1214 :     else if (from_kind == PyUnicode_1BYTE_KIND

  0013f	eb b6		 jmp	 SHORT $LN10@copy_chara
$LN80@copy_chara:

; 1215 :              && to_kind == PyUnicode_2BYTE_KIND)

  00141	41 83 f9 01	 cmp	 r9d, 1
  00145	0f 85 ec 01 00
	00		 jne	 $LN59@copy_chara
  0014b	41 83 fb 02	 cmp	 r11d, 2
  0014f	0f 85 f3 00 00
	00		 jne	 $LN201@copy_chara

; 1216 :     {
; 1217 :         _PyUnicode_CONVERT_BYTES(
; 1218 :             Py_UCS1, Py_UCS2,
; 1219 :             PyUnicode_1BYTE_DATA(from) + from_start,
; 1220 :             PyUnicode_1BYTE_DATA(from) + from_start + how_many,
; 1221 :             PyUnicode_2BYTE_DATA(to) + to_start
; 1222 :             );

  00155	a8 20		 test	 al, 32			; 00000020H
  00157	74 13		 je	 SHORT $LN94@copy_chara
  00159	a8 40		 test	 al, 64			; 00000040H
  0015b	74 06		 je	 SHORT $LN92@copy_chara
  0015d	48 83 e9 80	 sub	 rcx, -128		; ffffffffffffff80H
  00161	eb 10		 jmp	 SHORT $LN95@copy_chara
$LN92@copy_chara:
  00163	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  0016a	eb 07		 jmp	 SHORT $LN95@copy_chara
$LN94@copy_chara:
  0016c	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
$LN95@copy_chara:
  00173	45 8b 50 70	 mov	 r10d, DWORD PTR [r8+112]
  00177	48 8d 14 51	 lea	 rdx, QWORD PTR [rcx+rdx*2]
  0017b	45 8b ca	 mov	 r9d, r10d
  0017e	41 c1 e9 05	 shr	 r9d, 5
  00182	41 83 e1 01	 and	 r9d, 1
  00186	74 18		 je	 SHORT $LN98@copy_chara
  00188	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  0018c	74 09		 je	 SHORT $LN96@copy_chara
  0018e	49 8d 80 80 00
	00 00		 lea	 rax, QWORD PTR [r8+128]
  00195	eb 10		 jmp	 SHORT $LN99@copy_chara
$LN96@copy_chara:
  00197	49 8d 80 a0 00
	00 00		 lea	 rax, QWORD PTR [r8+160]
  0019e	eb 07		 jmp	 SHORT $LN99@copy_chara
$LN98@copy_chara:
  001a0	49 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [r8+160]
$LN99@copy_chara:
  001a7	4a 8d 0c 28	 lea	 rcx, QWORD PTR [rax+r13]
  001ab	45 85 c9	 test	 r9d, r9d
  001ae	74 15		 je	 SHORT $LN102@copy_chara
  001b0	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  001b4	74 06		 je	 SHORT $LN100@copy_chara
  001b6	49 83 e8 80	 sub	 r8, -128		; ffffffffffffff80H
  001ba	eb 10		 jmp	 SHORT $LN103@copy_chara
$LN100@copy_chara:
  001bc	49 81 c0 a0 00
	00 00		 add	 r8, 160			; 000000a0H
  001c3	eb 07		 jmp	 SHORT $LN103@copy_chara
$LN102@copy_chara:
  001c5	4d 8b 80 a0 00
	00 00		 mov	 r8, QWORD PTR [r8+160]
$LN103@copy_chara:
  001cc	4f 8d 0c 28	 lea	 r9, QWORD PTR [r8+r13]
  001d0	4d 03 cf	 add	 r9, r15
  001d3	4d 8b c1	 mov	 r8, r9
  001d6	4c 2b c1	 sub	 r8, rcx
  001d9	49 83 e0 fc	 and	 r8, -4
  001dd	4c 03 c1	 add	 r8, rcx
  001e0	49 3b c8	 cmp	 rcx, r8
  001e3	73 37		 jae	 SHORT $LN174@copy_chara
  001e5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL64@copy_chara:
  001f0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  001f3	48 83 c1 04	 add	 rcx, 4
  001f7	48 83 c2 08	 add	 rdx, 8
  001fb	66 89 42 f8	 mov	 WORD PTR [rdx-8], ax
  001ff	0f b6 41 fd	 movzx	 eax, BYTE PTR [rcx-3]
  00203	66 89 42 fa	 mov	 WORD PTR [rdx-6], ax
  00207	0f b6 41 fe	 movzx	 eax, BYTE PTR [rcx-2]
  0020b	66 89 42 fc	 mov	 WORD PTR [rdx-4], ax
  0020f	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]
  00213	66 89 42 fe	 mov	 WORD PTR [rdx-2], ax
  00217	49 3b c8	 cmp	 rcx, r8
  0021a	72 d4		 jb	 SHORT $LL64@copy_chara
$LN174@copy_chara:
  0021c	49 3b c9	 cmp	 rcx, r9
  0021f	0f 83 d2 fe ff
	ff		 jae	 $LN10@copy_chara
  00225	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL62@copy_chara:
  00230	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00233	48 ff c1	 inc	 rcx
  00236	48 83 c2 02	 add	 rdx, 2
  0023a	66 89 42 fe	 mov	 WORD PTR [rdx-2], ax
  0023e	49 3b c9	 cmp	 rcx, r9
  00241	72 ed		 jb	 SHORT $LL62@copy_chara

; 1223 :     }
; 1224 :     else if (from_kind == PyUnicode_1BYTE_KIND

  00243	e9 af fe ff ff	 jmp	 $LN10@copy_chara
$LN201@copy_chara:

; 1225 :              && to_kind == PyUnicode_4BYTE_KIND)

  00248	41 83 fb 04	 cmp	 r11d, 4
  0024c	0f 85 d8 01 00
	00		 jne	 $LN50@copy_chara

; 1226 :     {
; 1227 :         _PyUnicode_CONVERT_BYTES(
; 1228 :             Py_UCS1, Py_UCS4,
; 1229 :             PyUnicode_1BYTE_DATA(from) + from_start,
; 1230 :             PyUnicode_1BYTE_DATA(from) + from_start + how_many,
; 1231 :             PyUnicode_4BYTE_DATA(to) + to_start
; 1232 :             );

  00252	a8 20		 test	 al, 32			; 00000020H
  00254	74 13		 je	 SHORT $LN106@copy_chara
  00256	a8 40		 test	 al, 64			; 00000040H
  00258	74 06		 je	 SHORT $LN104@copy_chara
  0025a	48 83 e9 80	 sub	 rcx, -128		; ffffffffffffff80H
  0025e	eb 10		 jmp	 SHORT $LN107@copy_chara
$LN104@copy_chara:
  00260	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  00267	eb 07		 jmp	 SHORT $LN107@copy_chara
$LN106@copy_chara:
  00269	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
$LN107@copy_chara:
  00270	45 8b 50 70	 mov	 r10d, DWORD PTR [r8+112]
  00274	48 8d 14 91	 lea	 rdx, QWORD PTR [rcx+rdx*4]
  00278	45 8b ca	 mov	 r9d, r10d
  0027b	41 c1 e9 05	 shr	 r9d, 5
  0027f	41 83 e1 01	 and	 r9d, 1
  00283	74 18		 je	 SHORT $LN110@copy_chara
  00285	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  00289	74 09		 je	 SHORT $LN108@copy_chara
  0028b	49 8d 80 80 00
	00 00		 lea	 rax, QWORD PTR [r8+128]
  00292	eb 10		 jmp	 SHORT $LN111@copy_chara
$LN108@copy_chara:
  00294	49 8d 80 a0 00
	00 00		 lea	 rax, QWORD PTR [r8+160]
  0029b	eb 07		 jmp	 SHORT $LN111@copy_chara
$LN110@copy_chara:
  0029d	49 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [r8+160]
$LN111@copy_chara:
  002a4	4a 8d 0c 28	 lea	 rcx, QWORD PTR [rax+r13]
  002a8	45 85 c9	 test	 r9d, r9d
  002ab	74 15		 je	 SHORT $LN114@copy_chara
  002ad	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  002b1	74 06		 je	 SHORT $LN112@copy_chara
  002b3	49 83 e8 80	 sub	 r8, -128		; ffffffffffffff80H
  002b7	eb 10		 jmp	 SHORT $LN115@copy_chara
$LN112@copy_chara:
  002b9	49 81 c0 a0 00
	00 00		 add	 r8, 160			; 000000a0H
  002c0	eb 07		 jmp	 SHORT $LN115@copy_chara
$LN114@copy_chara:
  002c2	4d 8b 80 a0 00
	00 00		 mov	 r8, QWORD PTR [r8+160]
$LN115@copy_chara:
  002c9	4f 8d 0c 28	 lea	 r9, QWORD PTR [r8+r13]
  002cd	4d 03 cf	 add	 r9, r15
  002d0	4d 8b c1	 mov	 r8, r9
  002d3	4c 2b c1	 sub	 r8, rcx
  002d6	49 83 e0 fc	 and	 r8, -4
  002da	4c 03 c1	 add	 r8, rcx
  002dd	49 3b c8	 cmp	 rcx, r8
  002e0	73 28		 jae	 SHORT $LN176@copy_chara
$LL55@copy_chara:
  002e2	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  002e5	48 83 c1 04	 add	 rcx, 4
  002e9	48 83 c2 10	 add	 rdx, 16
  002ed	89 42 f0	 mov	 DWORD PTR [rdx-16], eax
  002f0	0f b6 41 fd	 movzx	 eax, BYTE PTR [rcx-3]
  002f4	89 42 f4	 mov	 DWORD PTR [rdx-12], eax
  002f7	0f b6 41 fe	 movzx	 eax, BYTE PTR [rcx-2]
  002fb	89 42 f8	 mov	 DWORD PTR [rdx-8], eax
  002fe	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]
  00302	89 42 fc	 mov	 DWORD PTR [rdx-4], eax
  00305	49 3b c8	 cmp	 rcx, r8
  00308	72 d8		 jb	 SHORT $LL55@copy_chara
$LN176@copy_chara:
  0030a	49 3b c9	 cmp	 rcx, r9
  0030d	0f 83 e4 fd ff
	ff		 jae	 $LN10@copy_chara
  00313	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL53@copy_chara:
  00320	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00323	48 ff c1	 inc	 rcx
  00326	48 83 c2 04	 add	 rdx, 4
  0032a	89 42 fc	 mov	 DWORD PTR [rdx-4], eax
  0032d	49 3b c9	 cmp	 rcx, r9
  00330	72 ee		 jb	 SHORT $LL53@copy_chara

; 1233 :     }
; 1234 :     else if (from_kind == PyUnicode_2BYTE_KIND

  00332	e9 c0 fd ff ff	 jmp	 $LN10@copy_chara
$LN59@copy_chara:

; 1235 :              && to_kind == PyUnicode_4BYTE_KIND)

  00337	41 83 f9 02	 cmp	 r9d, 2
  0033b	0f 85 e9 00 00
	00		 jne	 $LN50@copy_chara
  00341	41 83 fb 04	 cmp	 r11d, 4
  00345	0f 85 df 00 00
	00		 jne	 $LN50@copy_chara

; 1236 :     {
; 1237 :         _PyUnicode_CONVERT_BYTES(
; 1238 :             Py_UCS2, Py_UCS4,
; 1239 :             PyUnicode_2BYTE_DATA(from) + from_start,
; 1240 :             PyUnicode_2BYTE_DATA(from) + from_start + how_many,
; 1241 :             PyUnicode_4BYTE_DATA(to) + to_start
; 1242 :             );

  0034b	a8 20		 test	 al, 32			; 00000020H
  0034d	74 13		 je	 SHORT $LN118@copy_chara
  0034f	a8 40		 test	 al, 64			; 00000040H
  00351	74 06		 je	 SHORT $LN116@copy_chara
  00353	48 83 e9 80	 sub	 rcx, -128		; ffffffffffffff80H
  00357	eb 10		 jmp	 SHORT $LN119@copy_chara
$LN116@copy_chara:
  00359	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  00360	eb 07		 jmp	 SHORT $LN119@copy_chara
$LN118@copy_chara:
  00362	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
$LN119@copy_chara:
  00369	45 8b 50 70	 mov	 r10d, DWORD PTR [r8+112]
  0036d	48 8d 14 91	 lea	 rdx, QWORD PTR [rcx+rdx*4]
  00371	45 8b ca	 mov	 r9d, r10d
  00374	41 c1 e9 05	 shr	 r9d, 5
  00378	41 83 e1 01	 and	 r9d, 1
  0037c	74 18		 je	 SHORT $LN122@copy_chara
  0037e	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  00382	74 09		 je	 SHORT $LN120@copy_chara
  00384	49 8d 80 80 00
	00 00		 lea	 rax, QWORD PTR [r8+128]
  0038b	eb 10		 jmp	 SHORT $LN123@copy_chara
$LN120@copy_chara:
  0038d	49 8d 80 a0 00
	00 00		 lea	 rax, QWORD PTR [r8+160]
  00394	eb 07		 jmp	 SHORT $LN123@copy_chara
$LN122@copy_chara:
  00396	49 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [r8+160]
$LN123@copy_chara:
  0039d	4a 8d 0c 68	 lea	 rcx, QWORD PTR [rax+r13*2]
  003a1	45 85 c9	 test	 r9d, r9d
  003a4	74 15		 je	 SHORT $LN126@copy_chara
  003a6	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  003aa	74 06		 je	 SHORT $LN124@copy_chara
  003ac	49 83 e8 80	 sub	 r8, -128		; ffffffffffffff80H
  003b0	eb 10		 jmp	 SHORT $LN127@copy_chara
$LN124@copy_chara:
  003b2	49 81 c0 a0 00
	00 00		 add	 r8, 160			; 000000a0H
  003b9	eb 07		 jmp	 SHORT $LN127@copy_chara
$LN126@copy_chara:
  003bb	4d 8b 80 a0 00
	00 00		 mov	 r8, QWORD PTR [r8+160]
$LN127@copy_chara:
  003c2	4b 8d 44 3d 00	 lea	 rax, QWORD PTR [r13+r15]
  003c7	4d 8d 04 40	 lea	 r8, QWORD PTR [r8+rax*2]
  003cb	49 8b c0	 mov	 rax, r8
  003ce	48 2b c1	 sub	 rax, rcx
  003d1	48 d1 f8	 sar	 rax, 1
  003d4	48 83 e0 fc	 and	 rax, -4
  003d8	4c 8d 0c 41	 lea	 r9, QWORD PTR [rcx+rax*2]
  003dc	49 3b c9	 cmp	 rcx, r9
  003df	73 28		 jae	 SHORT $LN178@copy_chara
$LL46@copy_chara:
  003e1	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  003e4	48 83 c1 08	 add	 rcx, 8
  003e8	48 83 c2 10	 add	 rdx, 16
  003ec	89 42 f0	 mov	 DWORD PTR [rdx-16], eax
  003ef	0f b7 41 fa	 movzx	 eax, WORD PTR [rcx-6]
  003f3	89 42 f4	 mov	 DWORD PTR [rdx-12], eax
  003f6	0f b7 41 fc	 movzx	 eax, WORD PTR [rcx-4]
  003fa	89 42 f8	 mov	 DWORD PTR [rdx-8], eax
  003fd	0f b7 41 fe	 movzx	 eax, WORD PTR [rcx-2]
  00401	89 42 fc	 mov	 DWORD PTR [rdx-4], eax
  00404	49 3b c9	 cmp	 rcx, r9
  00407	72 d8		 jb	 SHORT $LL46@copy_chara
$LN178@copy_chara:
  00409	49 3b c8	 cmp	 rcx, r8
  0040c	0f 83 e5 fc ff
	ff		 jae	 $LN10@copy_chara
$LL44@copy_chara:
  00412	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00415	48 83 c1 02	 add	 rcx, 2
  00419	48 83 c2 04	 add	 rdx, 4
  0041d	89 42 fc	 mov	 DWORD PTR [rdx-4], eax
  00420	49 3b c8	 cmp	 rcx, r8
  00423	72 ed		 jb	 SHORT $LL44@copy_chara

; 1243 :     }
; 1244 :     else {

  00425	e9 cd fc ff ff	 jmp	 $LN10@copy_chara
$LN50@copy_chara:

; 1245 :         assert (PyUnicode_MAX_CHAR_VALUE(from) > PyUnicode_MAX_CHAR_VALUE(to));
; 1246 : 
; 1247 :         if (!check_maxchar) {

  0042a	83 7c 24 78 00	 cmp	 DWORD PTR check_maxchar$[rsp], 0
  0042f	0f 85 04 03 00
	00		 jne	 $LN41@copy_chara

; 1248 :             if (from_kind == PyUnicode_2BYTE_KIND
; 1249 :                 && to_kind == PyUnicode_1BYTE_KIND)

  00435	41 83 f9 02	 cmp	 r9d, 2
  00439	0f 85 f8 00 00
	00		 jne	 $LN40@copy_chara
  0043f	41 83 fb 01	 cmp	 r11d, 1
  00443	0f 85 a7 03 00
	00		 jne	 $LN186@copy_chara

; 1250 :             {
; 1251 :                 _PyUnicode_CONVERT_BYTES(
; 1252 :                     Py_UCS2, Py_UCS1,
; 1253 :                     PyUnicode_2BYTE_DATA(from) + from_start,
; 1254 :                     PyUnicode_2BYTE_DATA(from) + from_start + how_many,
; 1255 :                     PyUnicode_1BYTE_DATA(to) + to_start
; 1256 :                     );

  00449	a8 20		 test	 al, 32			; 00000020H
  0044b	74 13		 je	 SHORT $LN130@copy_chara
  0044d	a8 40		 test	 al, 64			; 00000040H
  0044f	74 06		 je	 SHORT $LN128@copy_chara
  00451	48 83 e9 80	 sub	 rcx, -128		; ffffffffffffff80H
  00455	eb 10		 jmp	 SHORT $LN131@copy_chara
$LN128@copy_chara:
  00457	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  0045e	eb 07		 jmp	 SHORT $LN131@copy_chara
$LN130@copy_chara:
  00460	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
$LN131@copy_chara:
  00467	45 8b 50 70	 mov	 r10d, DWORD PTR [r8+112]
  0046b	48 03 d1	 add	 rdx, rcx
  0046e	45 8b ca	 mov	 r9d, r10d
  00471	41 c1 e9 05	 shr	 r9d, 5
  00475	41 83 e1 01	 and	 r9d, 1
  00479	74 18		 je	 SHORT $LN134@copy_chara
  0047b	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  0047f	74 09		 je	 SHORT $LN132@copy_chara
  00481	49 8d 80 80 00
	00 00		 lea	 rax, QWORD PTR [r8+128]
  00488	eb 10		 jmp	 SHORT $LN135@copy_chara
$LN132@copy_chara:
  0048a	49 8d 80 a0 00
	00 00		 lea	 rax, QWORD PTR [r8+160]
  00491	eb 07		 jmp	 SHORT $LN135@copy_chara
$LN134@copy_chara:
  00493	49 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [r8+160]
$LN135@copy_chara:
  0049a	4a 8d 0c 68	 lea	 rcx, QWORD PTR [rax+r13*2]
  0049e	45 85 c9	 test	 r9d, r9d
  004a1	74 15		 je	 SHORT $LN138@copy_chara
  004a3	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  004a7	74 06		 je	 SHORT $LN136@copy_chara
  004a9	49 83 e8 80	 sub	 r8, -128		; ffffffffffffff80H
  004ad	eb 10		 jmp	 SHORT $LN139@copy_chara
$LN136@copy_chara:
  004af	49 81 c0 a0 00
	00 00		 add	 r8, 160			; 000000a0H
  004b6	eb 07		 jmp	 SHORT $LN139@copy_chara
$LN138@copy_chara:
  004b8	4d 8b 80 a0 00
	00 00		 mov	 r8, QWORD PTR [r8+160]
$LN139@copy_chara:
  004bf	4b 8d 44 3d 00	 lea	 rax, QWORD PTR [r13+r15]
  004c4	4d 8d 04 40	 lea	 r8, QWORD PTR [r8+rax*2]
  004c8	49 8b c0	 mov	 rax, r8
  004cb	48 2b c1	 sub	 rax, rcx
  004ce	48 d1 f8	 sar	 rax, 1
  004d1	48 83 e0 fc	 and	 rax, -4
  004d5	4c 8d 0c 41	 lea	 r9, QWORD PTR [rcx+rax*2]
  004d9	49 3b c9	 cmp	 rcx, r9
  004dc	73 2a		 jae	 SHORT $LN180@copy_chara
  004de	66 90		 npad	 2
$LL36@copy_chara:
  004e0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  004e3	48 83 c1 08	 add	 rcx, 8
  004e7	48 83 c2 04	 add	 rdx, 4
  004eb	88 42 fc	 mov	 BYTE PTR [rdx-4], al
  004ee	0f b6 41 fa	 movzx	 eax, BYTE PTR [rcx-6]
  004f2	88 42 fd	 mov	 BYTE PTR [rdx-3], al
  004f5	0f b6 41 fc	 movzx	 eax, BYTE PTR [rcx-4]
  004f9	88 42 fe	 mov	 BYTE PTR [rdx-2], al
  004fc	0f b6 41 fe	 movzx	 eax, BYTE PTR [rcx-2]
  00500	88 42 ff	 mov	 BYTE PTR [rdx-1], al
  00503	49 3b c9	 cmp	 rcx, r9
  00506	72 d8		 jb	 SHORT $LL36@copy_chara
$LN180@copy_chara:
  00508	49 3b c8	 cmp	 rcx, r8
  0050b	0f 83 e6 fb ff
	ff		 jae	 $LN10@copy_chara
  00511	66 66 66 66 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL34@copy_chara:
  00520	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00523	48 83 c1 02	 add	 rcx, 2
  00527	48 ff c2	 inc	 rdx
  0052a	88 42 ff	 mov	 BYTE PTR [rdx-1], al
  0052d	49 3b c8	 cmp	 rcx, r8
  00530	72 ee		 jb	 SHORT $LL34@copy_chara

; 1257 :             }
; 1258 :             else if (from_kind == PyUnicode_4BYTE_KIND

  00532	e9 c0 fb ff ff	 jmp	 $LN10@copy_chara
$LN40@copy_chara:

; 1259 :                      && to_kind == PyUnicode_1BYTE_KIND)

  00537	41 83 f9 04	 cmp	 r9d, 4
  0053b	0f 85 af 02 00
	00		 jne	 $LN186@copy_chara
  00541	41 83 fb 01	 cmp	 r11d, 1
  00545	0f 85 ec 00 00
	00		 jne	 $LN202@copy_chara

; 1260 :             {
; 1261 :                 _PyUnicode_CONVERT_BYTES(
; 1262 :                     Py_UCS4, Py_UCS1,
; 1263 :                     PyUnicode_4BYTE_DATA(from) + from_start,
; 1264 :                     PyUnicode_4BYTE_DATA(from) + from_start + how_many,
; 1265 :                     PyUnicode_1BYTE_DATA(to) + to_start
; 1266 :                     );

  0054b	a8 20		 test	 al, 32			; 00000020H
  0054d	74 13		 je	 SHORT $LN142@copy_chara
  0054f	a8 40		 test	 al, 64			; 00000040H
  00551	74 06		 je	 SHORT $LN140@copy_chara
  00553	48 83 e9 80	 sub	 rcx, -128		; ffffffffffffff80H
  00557	eb 10		 jmp	 SHORT $LN143@copy_chara
$LN140@copy_chara:
  00559	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  00560	eb 07		 jmp	 SHORT $LN143@copy_chara
$LN142@copy_chara:
  00562	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
$LN143@copy_chara:
  00569	45 8b 50 70	 mov	 r10d, DWORD PTR [r8+112]
  0056d	48 03 d1	 add	 rdx, rcx
  00570	45 8b ca	 mov	 r9d, r10d
  00573	41 c1 e9 05	 shr	 r9d, 5
  00577	41 83 e1 01	 and	 r9d, 1
  0057b	74 18		 je	 SHORT $LN146@copy_chara
  0057d	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  00581	74 09		 je	 SHORT $LN144@copy_chara
  00583	49 8d 80 80 00
	00 00		 lea	 rax, QWORD PTR [r8+128]
  0058a	eb 10		 jmp	 SHORT $LN147@copy_chara
$LN144@copy_chara:
  0058c	49 8d 80 a0 00
	00 00		 lea	 rax, QWORD PTR [r8+160]
  00593	eb 07		 jmp	 SHORT $LN147@copy_chara
$LN146@copy_chara:
  00595	49 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [r8+160]
$LN147@copy_chara:
  0059c	4a 8d 0c a8	 lea	 rcx, QWORD PTR [rax+r13*4]
  005a0	45 85 c9	 test	 r9d, r9d
  005a3	74 15		 je	 SHORT $LN150@copy_chara
  005a5	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  005a9	74 06		 je	 SHORT $LN148@copy_chara
  005ab	49 83 e8 80	 sub	 r8, -128		; ffffffffffffff80H
  005af	eb 10		 jmp	 SHORT $LN151@copy_chara
$LN148@copy_chara:
  005b1	49 81 c0 a0 00
	00 00		 add	 r8, 160			; 000000a0H
  005b8	eb 07		 jmp	 SHORT $LN151@copy_chara
$LN150@copy_chara:
  005ba	4d 8b 80 a0 00
	00 00		 mov	 r8, QWORD PTR [r8+160]
$LN151@copy_chara:
  005c1	4b 8d 44 3d 00	 lea	 rax, QWORD PTR [r13+r15]
  005c6	4d 8d 04 80	 lea	 r8, QWORD PTR [r8+rax*4]
  005ca	49 8b c0	 mov	 rax, r8
  005cd	48 2b c1	 sub	 rax, rcx
  005d0	48 c1 f8 02	 sar	 rax, 2
  005d4	48 83 e0 fc	 and	 rax, -4
  005d8	4c 8d 0c 81	 lea	 r9, QWORD PTR [rcx+rax*4]
  005dc	49 3b c9	 cmp	 rcx, r9
  005df	73 28		 jae	 SHORT $LN182@copy_chara
$LL27@copy_chara:
  005e1	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  005e4	48 83 c1 10	 add	 rcx, 16
  005e8	48 83 c2 04	 add	 rdx, 4
  005ec	88 42 fc	 mov	 BYTE PTR [rdx-4], al
  005ef	0f b6 41 f4	 movzx	 eax, BYTE PTR [rcx-12]
  005f3	88 42 fd	 mov	 BYTE PTR [rdx-3], al
  005f6	0f b6 41 f8	 movzx	 eax, BYTE PTR [rcx-8]
  005fa	88 42 fe	 mov	 BYTE PTR [rdx-2], al
  005fd	0f b6 41 fc	 movzx	 eax, BYTE PTR [rcx-4]
  00601	88 42 ff	 mov	 BYTE PTR [rdx-1], al
  00604	49 3b c9	 cmp	 rcx, r9
  00607	72 d8		 jb	 SHORT $LL27@copy_chara
$LN182@copy_chara:
  00609	49 3b c8	 cmp	 rcx, r8
  0060c	0f 83 e5 fa ff
	ff		 jae	 $LN10@copy_chara
  00612	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL25@copy_chara:
  00620	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00623	48 83 c1 04	 add	 rcx, 4
  00627	48 ff c2	 inc	 rdx
  0062a	88 42 ff	 mov	 BYTE PTR [rdx-1], al
  0062d	49 3b c8	 cmp	 rcx, r8
  00630	72 ee		 jb	 SHORT $LL25@copy_chara

; 1267 :             }
; 1268 :             else if (from_kind == PyUnicode_4BYTE_KIND

  00632	e9 c0 fa ff ff	 jmp	 $LN10@copy_chara
$LN202@copy_chara:

; 1269 :                      && to_kind == PyUnicode_2BYTE_KIND)

  00637	41 83 fb 02	 cmp	 r11d, 2
  0063b	0f 85 af 01 00
	00		 jne	 $LN186@copy_chara

; 1270 :             {
; 1271 :                 _PyUnicode_CONVERT_BYTES(
; 1272 :                     Py_UCS4, Py_UCS2,
; 1273 :                     PyUnicode_4BYTE_DATA(from) + from_start,
; 1274 :                     PyUnicode_4BYTE_DATA(from) + from_start + how_many,
; 1275 :                     PyUnicode_2BYTE_DATA(to) + to_start
; 1276 :                     );

  00641	a8 20		 test	 al, 32			; 00000020H
  00643	74 13		 je	 SHORT $LN154@copy_chara
  00645	a8 40		 test	 al, 64			; 00000040H
  00647	74 06		 je	 SHORT $LN152@copy_chara
  00649	48 83 e9 80	 sub	 rcx, -128		; ffffffffffffff80H
  0064d	eb 10		 jmp	 SHORT $LN155@copy_chara
$LN152@copy_chara:
  0064f	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  00656	eb 07		 jmp	 SHORT $LN155@copy_chara
$LN154@copy_chara:
  00658	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
$LN155@copy_chara:
  0065f	45 8b 50 70	 mov	 r10d, DWORD PTR [r8+112]
  00663	48 8d 14 51	 lea	 rdx, QWORD PTR [rcx+rdx*2]
  00667	45 8b ca	 mov	 r9d, r10d
  0066a	41 c1 e9 05	 shr	 r9d, 5
  0066e	41 83 e1 01	 and	 r9d, 1
  00672	74 18		 je	 SHORT $LN158@copy_chara
  00674	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  00678	74 09		 je	 SHORT $LN156@copy_chara
  0067a	49 8d 80 80 00
	00 00		 lea	 rax, QWORD PTR [r8+128]
  00681	eb 10		 jmp	 SHORT $LN159@copy_chara
$LN156@copy_chara:
  00683	49 8d 80 a0 00
	00 00		 lea	 rax, QWORD PTR [r8+160]
  0068a	eb 07		 jmp	 SHORT $LN159@copy_chara
$LN158@copy_chara:
  0068c	49 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [r8+160]
$LN159@copy_chara:
  00693	4a 8d 0c a8	 lea	 rcx, QWORD PTR [rax+r13*4]
  00697	45 85 c9	 test	 r9d, r9d
  0069a	74 15		 je	 SHORT $LN162@copy_chara
  0069c	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  006a0	74 06		 je	 SHORT $LN160@copy_chara
  006a2	49 83 e8 80	 sub	 r8, -128		; ffffffffffffff80H
  006a6	eb 10		 jmp	 SHORT $LN163@copy_chara
$LN160@copy_chara:
  006a8	49 81 c0 a0 00
	00 00		 add	 r8, 160			; 000000a0H
  006af	eb 07		 jmp	 SHORT $LN163@copy_chara
$LN162@copy_chara:
  006b1	4d 8b 80 a0 00
	00 00		 mov	 r8, QWORD PTR [r8+160]
$LN163@copy_chara:
  006b8	4b 8d 44 3d 00	 lea	 rax, QWORD PTR [r13+r15]
  006bd	4d 8d 04 80	 lea	 r8, QWORD PTR [r8+rax*4]
  006c1	49 8b c0	 mov	 rax, r8
  006c4	48 2b c1	 sub	 rax, rcx
  006c7	48 c1 f8 02	 sar	 rax, 2
  006cb	48 83 e0 fc	 and	 rax, -4
  006cf	4c 8d 0c 81	 lea	 r9, QWORD PTR [rcx+rax*4]
  006d3	49 3b c9	 cmp	 rcx, r9
  006d6	73 34		 jae	 SHORT $LN184@copy_chara
  006d8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL18@copy_chara:
  006e0	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  006e3	48 83 c1 10	 add	 rcx, 16
  006e7	48 83 c2 08	 add	 rdx, 8
  006eb	66 89 42 f8	 mov	 WORD PTR [rdx-8], ax
  006ef	0f b7 41 f4	 movzx	 eax, WORD PTR [rcx-12]
  006f3	66 89 42 fa	 mov	 WORD PTR [rdx-6], ax
  006f7	0f b7 41 f8	 movzx	 eax, WORD PTR [rcx-8]
  006fb	66 89 42 fc	 mov	 WORD PTR [rdx-4], ax
  006ff	0f b7 41 fc	 movzx	 eax, WORD PTR [rcx-4]
  00703	66 89 42 fe	 mov	 WORD PTR [rdx-2], ax
  00707	49 3b c9	 cmp	 rcx, r9
  0070a	72 d4		 jb	 SHORT $LL18@copy_chara
$LN184@copy_chara:
  0070c	49 3b c8	 cmp	 rcx, r8
  0070f	0f 83 e2 f9 ff
	ff		 jae	 $LN10@copy_chara
  00715	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL16@copy_chara:
  00720	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00723	48 83 c1 04	 add	 rcx, 4
  00727	48 83 c2 02	 add	 rdx, 2
  0072b	66 89 42 fe	 mov	 WORD PTR [rdx-2], ax
  0072f	49 3b c8	 cmp	 rcx, r8
  00732	72 ec		 jb	 SHORT $LL16@copy_chara

; 1277 :             }
; 1278 :             else {
; 1279 :                 assert(0);
; 1280 :                 return -1;
; 1281 :             }
; 1282 :         }
; 1283 :         else {

  00734	e9 be f9 ff ff	 jmp	 $LN10@copy_chara
$LN41@copy_chara:

; 1284 :             const Py_UCS4 to_maxchar = PyUnicode_MAX_CHAR_VALUE(to);

  00739	a8 40		 test	 al, 64			; 00000040H
  0073b	74 07		 je	 SHORT $LN166@copy_chara
  0073d	bb 7f 00 00 00	 mov	 ebx, 127		; 0000007fH
  00742	eb 22		 jmp	 SHORT $LN165@copy_chara
$LN166@copy_chara:
  00744	c1 e8 02	 shr	 eax, 2
  00747	83 e0 07	 and	 eax, 7
  0074a	83 f8 01	 cmp	 eax, 1
  0074d	75 07		 jne	 SHORT $LN164@copy_chara
  0074f	bb ff 00 00 00	 mov	 ebx, 255		; 000000ffH
  00754	eb 10		 jmp	 SHORT $LN165@copy_chara
$LN164@copy_chara:
  00756	bb ff ff 10 00	 mov	 ebx, 1114111		; 0010ffffH
  0075b	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00760	83 f8 02	 cmp	 eax, 2
  00763	0f 44 d9	 cmove	 ebx, ecx
$LN165@copy_chara:

; 1285 :             Py_UCS4 ch;
; 1286 :             Py_ssize_t i;
; 1287 : 
; 1288 :             for (i=0; i < how_many; i++) {

  00766	33 d2		 xor	 edx, edx
  00768	4d 85 ff	 test	 r15, r15
  0076b	0f 8e 86 f9 ff
	ff		 jle	 $LN10@copy_chara
  00771	49 8b cd	 mov	 rcx, r13
  00774	4e 8d 04 76	 lea	 r8, QWORD PTR [rsi+r14*2]
  00778	4e 8d 14 b6	 lea	 r10, QWORD PTR [rsi+r14*4]
  0077c	49 2b ce	 sub	 rcx, r14
  0077f	48 8d 2c 09	 lea	 rbp, QWORD PTR [rcx+rcx]
  00783	4c 8d 24 8d 00
	00 00 00	 lea	 r12, QWORD PTR [rcx*4]
  0078b	48 2b ee	 sub	 rbp, rsi
  0078e	4c 2b e6	 sub	 r12, rsi
  00791	48 03 ef	 add	 rbp, rdi
  00794	4c 03 e7	 add	 r12, rdi
$LL12@copy_chara:

; 1289 :                 ch = PyUnicode_READ(from_kind, from_data, from_start + i);

  00797	41 83 f9 01	 cmp	 r9d, 1
  0079b	75 0b		 jne	 SHORT $LN170@copy_chara
  0079d	48 8d 04 3a	 lea	 rax, QWORD PTR [rdx+rdi]
  007a1	42 0f b6 0c 28	 movzx	 ecx, BYTE PTR [rax+r13]
  007a6	eb 11		 jmp	 SHORT $LN169@copy_chara
$LN170@copy_chara:
  007a8	41 83 f9 02	 cmp	 r9d, 2
  007ac	75 07		 jne	 SHORT $LN168@copy_chara
  007ae	41 0f b7 0c 28	 movzx	 ecx, WORD PTR [r8+rbp]
  007b3	eb 04		 jmp	 SHORT $LN169@copy_chara
$LN168@copy_chara:
  007b5	43 8b 0c 14	 mov	 ecx, DWORD PTR [r12+r10]
$LN169@copy_chara:

; 1290 :                 if (ch > to_maxchar)

  007b9	3b cb		 cmp	 ecx, ebx
  007bb	77 33		 ja	 SHORT $LN186@copy_chara

; 1292 :                 PyUnicode_WRITE(to_kind, to_data, to_start + i, ch);

  007bd	41 8b c3	 mov	 eax, r11d
  007c0	ff c8		 dec	 eax
  007c2	74 0f		 je	 SHORT $LN3@copy_chara
  007c4	ff c8		 dec	 eax
  007c6	74 05		 je	 SHORT $LN2@copy_chara
  007c8	41 89 0a	 mov	 DWORD PTR [r10], ecx
  007cb	eb 0e		 jmp	 SHORT $LN7@copy_chara
$LN2@copy_chara:
  007cd	66 41 89 08	 mov	 WORD PTR [r8], cx
  007d1	eb 08		 jmp	 SHORT $LN7@copy_chara
$LN3@copy_chara:
  007d3	48 8d 04 32	 lea	 rax, QWORD PTR [rdx+rsi]
  007d7	42 88 0c 30	 mov	 BYTE PTR [rax+r14], cl
$LN7@copy_chara:

; 1285 :             Py_UCS4 ch;
; 1286 :             Py_ssize_t i;
; 1287 : 
; 1288 :             for (i=0; i < how_many; i++) {

  007db	48 ff c2	 inc	 rdx
  007de	49 83 c2 04	 add	 r10, 4
  007e2	49 83 c0 02	 add	 r8, 2
  007e6	49 3b d7	 cmp	 rdx, r15
  007e9	7c ac		 jl	 SHORT $LL12@copy_chara

; 1290 :                 if (ch > to_maxchar)

  007eb	e9 07 f9 ff ff	 jmp	 $LN10@copy_chara
$LN186@copy_chara:

; 1291 :                     return -1;

  007f0	83 c8 ff	 or	 eax, -1
  007f3	e9 01 f9 ff ff	 jmp	 $LN207@copy_chara
_copy_characters ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_FastCopyCharacters
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_FastCopyCharacters DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$_PyUnicode_FastCopyCharacters
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_FastCopyCharacters DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_FastCopyCharacters
_TEXT	SEGMENT
to$ = 64
to_start$ = 72
from$ = 80
from_start$ = 88
how_many$ = 96
_PyUnicode_FastCopyCharacters PROC			; COMDAT

; 1303 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1304 :     (void)_copy_characters(to, to_start, from, from_start, how_many, 0);

  00004	48 8b 44 24 60	 mov	 rax, QWORD PTR how_many$[rsp]
  00009	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00011	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00016	e8 00 00 00 00	 call	 _copy_characters

; 1305 : }

  0001b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001f	c3		 ret	 0
_PyUnicode_FastCopyCharacters ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@ENIBLNEH@character?5U?$CL?$CFx?5is?5not?5in?5range?5?$FL@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$find_maxchar_surrogates DD imagerel find_maxchar_surrogates
	DD	imagerel find_maxchar_surrogates+219
	DD	imagerel $unwind$find_maxchar_surrogates
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$find_maxchar_surrogates DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_0DC@ENIBLNEH@character?5U?$CL?$CFx?5is?5not?5in?5range?5?$FL@
CONST	SEGMENT
??_C@_0DC@ENIBLNEH@character?5U?$CL?$CFx?5is?5not?5in?5range?5?$FL@ DB 'c'
	DB	'haracter U+%x is not in range [U+0000; U+10ffff]', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT find_maxchar_surrogates
_TEXT	SEGMENT
begin$ = 48
end$ = 56
maxchar$ = 64
num_surrogates$ = 72
find_maxchar_surrogates PROC				; COMDAT

; 1367 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1368 :     const wchar_t *iter;
; 1369 :     Py_UCS4 ch;
; 1370 : 
; 1371 :     assert(num_surrogates != NULL && maxchar != NULL);
; 1372 :     *num_surrogates = 0;

  00014	33 c0		 xor	 eax, eax
  00016	4d 8b d8	 mov	 r11, r8
  00019	49 89 01	 mov	 QWORD PTR [r9], rax

; 1373 :     *maxchar = 0;

  0001c	41 89 00	 mov	 DWORD PTR [r8], eax

; 1374 : 
; 1375 :     for (iter = begin; iter < end; ) {

  0001f	48 3b ca	 cmp	 rcx, rdx
  00022	0f 83 84 00 00
	00		 jae	 $LN11@find_maxch

; 1368 :     const wchar_t *iter;
; 1369 :     Py_UCS4 ch;
; 1370 : 
; 1371 :     assert(num_surrogates != NULL && maxchar != NULL);
; 1372 :     *num_surrogates = 0;

  00028	bf ff db 00 00	 mov	 edi, 56319		; 0000dbffH
  0002d	4c 8d 51 02	 lea	 r10, QWORD PTR [rcx+2]
  00031	bb 00 d8 00 00	 mov	 ebx, 55296		; 0000d800H
  00036	8d 77 01	 lea	 esi, QWORD PTR [rdi+1]
  00039	bd ff df 00 00	 mov	 ebp, 57343		; 0000dfffH
  0003e	66 90		 npad	 2
$LL6@find_maxch:

; 1376 : #if SIZEOF_WCHAR_T == 2
; 1377 :         if (Py_UNICODE_IS_HIGH_SURROGATE(iter[0])
; 1378 :             && (iter+1) < end
; 1379 :             && Py_UNICODE_IS_LOW_SURROGATE(iter[1]))

  00040	44 0f b7 01	 movzx	 r8d, WORD PTR [rcx]
  00044	66 41 3b d8	 cmp	 bx, r8w
  00048	77 40		 ja	 SHORT $LN4@find_maxch
  0004a	66 44 3b c7	 cmp	 r8w, di
  0004e	77 3a		 ja	 SHORT $LN4@find_maxch
  00050	4c 3b d2	 cmp	 r10, rdx
  00053	73 35		 jae	 SHORT $LN4@find_maxch
  00055	41 0f b7 02	 movzx	 eax, WORD PTR [r10]
  00059	66 3b f0	 cmp	 si, ax
  0005c	77 2c		 ja	 SHORT $LN4@find_maxch
  0005e	66 3b c5	 cmp	 ax, bp
  00061	77 27		 ja	 SHORT $LN4@find_maxch

; 1380 :         {
; 1381 :             ch = Py_UNICODE_JOIN_SURROGATES(iter[0], iter[1]);
; 1382 :             ++(*num_surrogates);

  00063	49 ff 01	 inc	 QWORD PTR [r9]
  00066	41 81 e0 ff 03
	00 00		 and	 r8d, 1023		; 000003ffH
  0006d	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00072	41 c1 e0 0a	 shl	 r8d, 10

; 1383 :             iter += 2;

  00076	48 83 c1 04	 add	 rcx, 4
  0007a	44 0b c0	 or	 r8d, eax
  0007d	41 81 c0 00 00
	01 00		 add	 r8d, 65536		; 00010000H
  00084	49 83 c2 04	 add	 r10, 4

; 1384 :         }
; 1385 :         else

  00088	eb 0c		 jmp	 SHORT $LN3@find_maxch
$LN4@find_maxch:

; 1386 : #endif
; 1387 :         {
; 1388 :             ch = *iter;
; 1389 :             iter++;

  0008a	48 83 c1 02	 add	 rcx, 2
  0008e	45 0f b7 c0	 movzx	 r8d, r8w
  00092	49 83 c2 02	 add	 r10, 2
$LN3@find_maxch:

; 1390 :         }
; 1391 :         if (ch > *maxchar) {

  00096	45 3b 03	 cmp	 r8d, DWORD PTR [r11]
  00099	76 0c		 jbe	 SHORT $LN1@find_maxch

; 1392 :             *maxchar = ch;

  0009b	45 89 03	 mov	 DWORD PTR [r11], r8d

; 1393 :             if (*maxchar > MAX_UNICODE) {

  0009e	41 81 f8 ff ff
	10 00		 cmp	 r8d, 1114111		; 0010ffffH
  000a5	77 1c		 ja	 SHORT $LN10@find_maxch
$LN1@find_maxch:

; 1374 : 
; 1375 :     for (iter = begin; iter < end; ) {

  000a7	48 3b ca	 cmp	 rcx, rdx
  000aa	72 94		 jb	 SHORT $LL6@find_maxch
$LN11@find_maxch:

; 1398 :             }
; 1399 :         }
; 1400 :     }
; 1401 :     return 0;

  000ac	33 c0		 xor	 eax, eax
$LN7@find_maxch:

; 1402 : }

  000ae	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b3	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000b8	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000bd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0
$LN10@find_maxch:

; 1394 :                 PyErr_Format(PyExc_ValueError,
; 1395 :                              "character U+%x is not in range [U+0000; U+10ffff]",
; 1396 :                              ch);

  000c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@ENIBLNEH@character?5U?$CL?$CFx?5is?5not?5in?5range?5?$FL@
  000d1	e8 00 00 00 00	 call	 PyErr_Format

; 1397 :                 return -1;

  000d6	83 c8 ff	 or	 eax, -1
  000d9	eb d3		 jmp	 SHORT $LN7@find_maxch
find_maxchar_surrogates ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_Ready
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_Ready DD imagerel $LN42
	DD	imagerel $LN42+679
	DD	imagerel $unwind$_PyUnicode_Ready
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_Ready DD 084f01H
	DD	0b744fH
	DD	0a644aH
	DD	0c0053209H
	DD	030025003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_Ready
_TEXT	SEGMENT
maxchar$ = 64
unicode$ = 64
num_surrogates$ = 72
_PyUnicode_Ready PROC					; COMDAT

; 1406 : {

$LN42:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	41 54		 push	 r12
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00009	48 8b d9	 mov	 rbx, rcx

; 1407 :     wchar_t *end;
; 1408 :     Py_UCS4 maxchar = 0;
; 1409 :     Py_ssize_t num_surrogates;
; 1410 : #if SIZEOF_WCHAR_T == 2
; 1411 :     Py_ssize_t length_wo_surrogates;
; 1412 : #endif
; 1413 : 
; 1414 :     /* _PyUnicode_Ready() is only intended for old-style API usage where
; 1415 :        strings were created using _PyObject_New() and where no canonical
; 1416 :        representation (the str field) has been set yet aka strings
; 1417 :        which are not yet ready. */
; 1418 :     assert(_PyUnicode_CHECK(unicode));
; 1419 :     assert(_PyUnicode_KIND(unicode) == PyUnicode_WCHAR_KIND);
; 1420 :     assert(_PyUnicode_WSTR(unicode) != NULL);
; 1421 :     assert(_PyUnicode_DATA_ANY(unicode) == NULL);
; 1422 :     assert(_PyUnicode_UTF8(unicode) == NULL);
; 1423 :     /* Actually, it should neither be interned nor be anything else: */
; 1424 :     assert(_PyUnicode_STATE(unicode).interned == SSTATE_NOT_INTERNED);
; 1425 : 
; 1426 :     end = _PyUnicode_WSTR(unicode) + _PyUnicode_WSTR_LENGTH(unicode);

  0000c	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]

; 1427 :     if (find_maxchar_surrogates(_PyUnicode_WSTR(unicode), end,
; 1428 :                                 &maxchar, &num_surrogates) == -1)

  00010	4c 8d 4c 24 48	 lea	 r9, QWORD PTR num_surrogates$[rsp]
  00015	48 8b 83 90 00
	00 00		 mov	 rax, QWORD PTR [rbx+144]
  0001c	4c 8d 44 24 40	 lea	 r8, QWORD PTR maxchar$[rsp]
  00021	45 33 e4	 xor	 r12d, r12d
  00024	48 8d 2c 41	 lea	 rbp, QWORD PTR [rcx+rax*2]
  00028	44 89 64 24 40	 mov	 DWORD PTR maxchar$[rsp], r12d
  0002d	48 8b d5	 mov	 rdx, rbp
  00030	e8 00 00 00 00	 call	 find_maxchar_surrogates
  00035	83 f8 ff	 cmp	 eax, -1
  00038	75 0b		 jne	 SHORT $LN16@PyUnicode_@3

; 1429 :         return -1;

  0003a	0b c0		 or	 eax, eax

; 1527 : }

  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	41 5c		 pop	 r12
  00042	5d		 pop	 rbp
  00043	5b		 pop	 rbx
  00044	c3		 ret	 0
$LN16@PyUnicode_@3:
  00045	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0004a	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi

; 1430 : 
; 1431 :     if (maxchar < 256) {

  0004f	8b 7c 24 40	 mov	 edi, DWORD PTR maxchar$[rsp]
  00053	81 ff 00 01 00
	00		 cmp	 edi, 256		; 00000100H
  00059	0f 83 3c 01 00
	00		 jae	 $LN15@PyUnicode_@3

; 1432 :         _PyUnicode_DATA_ANY(unicode) = PyObject_MALLOC(_PyUnicode_WSTR_LENGTH(unicode) + 1);

  0005f	48 8b 8b 90 00
	00 00		 mov	 rcx, QWORD PTR [rbx+144]
  00066	48 ff c1	 inc	 rcx
  00069	e8 00 00 00 00	 call	 PyObject_Malloc
  0006e	4c 8b d8	 mov	 r11, rax
  00071	48 89 83 a0 00
	00 00		 mov	 QWORD PTR [rbx+160], rax

; 1433 :         if (!_PyUnicode_DATA_ANY(unicode)) {

  00078	48 85 c0	 test	 rax, rax

; 1434 :             PyErr_NoMemory();
; 1435 :             return -1;

  0007b	0f 84 a3 01 00
	00		 je	 $LN41@PyUnicode_@3

; 1436 :         }
; 1437 :         _PyUnicode_CONVERT_BYTES(wchar_t, unsigned char,
; 1438 :                                 _PyUnicode_WSTR(unicode), end,
; 1439 :                                 PyUnicode_1BYTE_DATA(unicode));

  00081	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00084	a8 20		 test	 al, 32			; 00000020H
  00086	74 12		 je	 SHORT $LN21@PyUnicode_@3
  00088	4c 8d 9b 80 00
	00 00		 lea	 r11, QWORD PTR [rbx+128]
  0008f	a8 40		 test	 al, 64			; 00000040H
  00091	75 07		 jne	 SHORT $LN21@PyUnicode_@3
  00093	4c 8d 9b a0 00
	00 00		 lea	 r11, QWORD PTR [rbx+160]
$LN21@PyUnicode_@3:
  0009a	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  0009e	48 8b c5	 mov	 rax, rbp
  000a1	48 2b c1	 sub	 rax, rcx
  000a4	48 d1 f8	 sar	 rax, 1
  000a7	48 83 e0 fc	 and	 rax, -4
  000ab	48 8d 14 41	 lea	 rdx, QWORD PTR [rcx+rax*2]
  000af	48 3b ca	 cmp	 rcx, rdx
  000b2	73 38		 jae	 SHORT $LN36@PyUnicode_@3
  000b4	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL10@PyUnicode_@3:
  000c0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  000c3	48 83 c1 08	 add	 rcx, 8
  000c7	49 83 c3 04	 add	 r11, 4
  000cb	41 88 43 fc	 mov	 BYTE PTR [r11-4], al
  000cf	0f b6 41 fa	 movzx	 eax, BYTE PTR [rcx-6]
  000d3	41 88 43 fd	 mov	 BYTE PTR [r11-3], al
  000d7	0f b6 41 fc	 movzx	 eax, BYTE PTR [rcx-4]
  000db	41 88 43 fe	 mov	 BYTE PTR [r11-2], al
  000df	0f b6 41 fe	 movzx	 eax, BYTE PTR [rcx-2]
  000e3	41 88 43 ff	 mov	 BYTE PTR [r11-1], al
  000e7	48 3b ca	 cmp	 rcx, rdx
  000ea	72 d4		 jb	 SHORT $LL10@PyUnicode_@3
$LN36@PyUnicode_@3:
  000ec	48 3b cd	 cmp	 rcx, rbp
  000ef	73 13		 jae	 SHORT $LN12@PyUnicode_@3
$LL8@PyUnicode_@3:
  000f1	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  000f4	48 83 c1 02	 add	 rcx, 2
  000f8	49 ff c3	 inc	 r11
  000fb	41 88 43 ff	 mov	 BYTE PTR [r11-1], al
  000ff	48 3b cd	 cmp	 rcx, rbp
  00102	72 ed		 jb	 SHORT $LL8@PyUnicode_@3
$LN12@PyUnicode_@3:

; 1440 :         PyUnicode_1BYTE_DATA(unicode)[_PyUnicode_WSTR_LENGTH(unicode)] = '\0';

  00104	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00107	a8 20		 test	 al, 32			; 00000020H
  00109	74 16		 je	 SHORT $LN25@PyUnicode_@3
  0010b	a8 40		 test	 al, 64			; 00000040H
  0010d	74 09		 je	 SHORT $LN23@PyUnicode_@3
  0010f	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  00116	eb 10		 jmp	 SHORT $LN26@PyUnicode_@3
$LN23@PyUnicode_@3:
  00118	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  0011f	eb 07		 jmp	 SHORT $LN26@PyUnicode_@3
$LN25@PyUnicode_@3:
  00121	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
$LN26@PyUnicode_@3:
  00128	48 8b 83 90 00
	00 00		 mov	 rax, QWORD PTR [rbx+144]
  0012f	44 88 24 01	 mov	 BYTE PTR [rcx+rax], r12b

; 1441 :         _PyUnicode_LENGTH(unicode) = _PyUnicode_WSTR_LENGTH(unicode);
; 1442 :         _PyUnicode_STATE(unicode).kind = PyUnicode_1BYTE_KIND;

  00133	83 63 70 e7	 and	 DWORD PTR [rbx+112], -25 ; ffffffe7H
  00137	83 4b 70 04	 or	 DWORD PTR [rbx+112], 4
  0013b	48 8b 8b 90 00
	00 00		 mov	 rcx, QWORD PTR [rbx+144]
  00142	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00145	48 89 4b 60	 mov	 QWORD PTR [rbx+96], rcx

; 1443 :         if (maxchar < 128) {

  00149	81 ff 80 00 00
	00		 cmp	 edi, 128		; 00000080H
  0014f	73 1d		 jae	 SHORT $LN6@PyUnicode_@3

; 1444 :             _PyUnicode_STATE(unicode).ascii = 1;

  00151	83 c8 40	 or	 eax, 64			; 00000040H

; 1445 :             _PyUnicode_UTF8(unicode) = _PyUnicode_DATA_ANY(unicode);
; 1446 :             _PyUnicode_UTF8_LENGTH(unicode) = _PyUnicode_WSTR_LENGTH(unicode);

  00154	48 89 8b 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rcx
  0015b	89 43 70	 mov	 DWORD PTR [rbx+112], eax
  0015e	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  00165	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 1447 :         }
; 1448 :         else {

  0016c	eb 14		 jmp	 SHORT $LN5@PyUnicode_@3
$LN6@PyUnicode_@3:

; 1449 :             _PyUnicode_STATE(unicode).ascii = 0;

  0016e	83 e0 bf	 and	 eax, -65		; ffffffbfH

; 1450 :             _PyUnicode_UTF8(unicode) = NULL;

  00171	4c 89 a3 88 00
	00 00		 mov	 QWORD PTR [rbx+136], r12

; 1451 :             _PyUnicode_UTF8_LENGTH(unicode) = 0;

  00178	4c 89 a3 80 00
	00 00		 mov	 QWORD PTR [rbx+128], r12
  0017f	89 43 70	 mov	 DWORD PTR [rbx+112], eax
$LN5@PyUnicode_@3:

; 1452 :         }
; 1453 :         PyObject_FREE(_PyUnicode_WSTR(unicode));

  00182	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  00186	e8 00 00 00 00	 call	 PyObject_Free

; 1454 :         _PyUnicode_WSTR(unicode) = NULL;

  0018b	4c 89 63 78	 mov	 QWORD PTR [rbx+120], r12

; 1455 :         _PyUnicode_WSTR_LENGTH(unicode) = 0;

  0018f	4c 89 a3 90 00
	00 00		 mov	 QWORD PTR [rbx+144], r12
  00196	e9 f0 00 00 00	 jmp	 $LN2@PyUnicode_@3
$LN15@PyUnicode_@3:

; 1456 :     }
; 1457 :     /* In this case we might have to convert down from 4-byte native
; 1458 :        wchar_t to 2-byte unicode. */
; 1459 :     else if (maxchar < 65536) {

  0019b	81 ff 00 00 01
	00		 cmp	 edi, 65536		; 00010000H
  001a1	73 59		 jae	 SHORT $LN3@PyUnicode_@3

; 1460 :         assert(num_surrogates == 0 &&
; 1461 :                "FindMaxCharAndNumSurrogatePairs() messed up");
; 1462 : 
; 1463 : #if SIZEOF_WCHAR_T == 2
; 1464 :         /* We can share representations and are done. */
; 1465 :         _PyUnicode_DATA_ANY(unicode) = _PyUnicode_WSTR(unicode);
; 1466 :         PyUnicode_2BYTE_DATA(unicode)[_PyUnicode_WSTR_LENGTH(unicode)] = '\0';

  001a3	8b 53 70	 mov	 edx, DWORD PTR [rbx+112]
  001a6	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]
  001aa	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  001b1	48 89 01	 mov	 QWORD PTR [rcx], rax
  001b4	f6 c2 20	 test	 dl, 32			; 00000020H
  001b7	74 0e		 je	 SHORT $LN29@PyUnicode_@3
  001b9	f6 c2 40	 test	 dl, 64			; 00000040H
  001bc	74 0c		 je	 SHORT $LN30@PyUnicode_@3
  001be	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  001c5	eb 03		 jmp	 SHORT $LN30@PyUnicode_@3
$LN29@PyUnicode_@3:
  001c7	48 8b c8	 mov	 rcx, rax
$LN30@PyUnicode_@3:
  001ca	48 8b 83 90 00
	00 00		 mov	 rax, QWORD PTR [rbx+144]
  001d1	66 44 89 24 41	 mov	 WORD PTR [rcx+rax*2], r12w

; 1467 :         _PyUnicode_LENGTH(unicode) = _PyUnicode_WSTR_LENGTH(unicode);

  001d6	48 8b 83 90 00
	00 00		 mov	 rax, QWORD PTR [rbx+144]

; 1468 :         _PyUnicode_STATE(unicode).kind = PyUnicode_2BYTE_KIND;

  001dd	83 63 70 eb	 and	 DWORD PTR [rbx+112], -21 ; ffffffebH
  001e1	83 4b 70 08	 or	 DWORD PTR [rbx+112], 8
  001e5	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 1469 :         _PyUnicode_UTF8(unicode) = NULL;

  001e9	4c 89 a3 88 00
	00 00		 mov	 QWORD PTR [rbx+136], r12

; 1470 :         _PyUnicode_UTF8_LENGTH(unicode) = 0;

  001f0	4c 89 a3 80 00
	00 00		 mov	 QWORD PTR [rbx+128], r12

; 1471 : #else
; 1472 :         /* sizeof(wchar_t) == 4 */
; 1473 :         _PyUnicode_DATA_ANY(unicode) = PyObject_MALLOC(
; 1474 :             2 * (_PyUnicode_WSTR_LENGTH(unicode) + 1));
; 1475 :         if (!_PyUnicode_DATA_ANY(unicode)) {
; 1476 :             PyErr_NoMemory();
; 1477 :             return -1;
; 1478 :         }
; 1479 :         _PyUnicode_CONVERT_BYTES(wchar_t, Py_UCS2,
; 1480 :                                 _PyUnicode_WSTR(unicode), end,
; 1481 :                                 PyUnicode_2BYTE_DATA(unicode));
; 1482 :         PyUnicode_2BYTE_DATA(unicode)[_PyUnicode_WSTR_LENGTH(unicode)] = '\0';
; 1483 :         _PyUnicode_LENGTH(unicode) = _PyUnicode_WSTR_LENGTH(unicode);
; 1484 :         _PyUnicode_STATE(unicode).kind = PyUnicode_2BYTE_KIND;
; 1485 :         _PyUnicode_UTF8(unicode) = NULL;
; 1486 :         _PyUnicode_UTF8_LENGTH(unicode) = 0;
; 1487 :         PyObject_FREE(_PyUnicode_WSTR(unicode));
; 1488 :         _PyUnicode_WSTR(unicode) = NULL;
; 1489 :         _PyUnicode_WSTR_LENGTH(unicode) = 0;
; 1490 : #endif
; 1491 :     }
; 1492 :     /* maxchar exeeds 16 bit, wee need 4 bytes for unicode characters */
; 1493 :     else {

  001f7	e9 8f 00 00 00	 jmp	 $LN2@PyUnicode_@3
$LN3@PyUnicode_@3:

; 1494 : #if SIZEOF_WCHAR_T == 2
; 1495 :         /* in case the native representation is 2-bytes, we need to allocate a
; 1496 :            new normalized 4-byte version. */
; 1497 :         length_wo_surrogates = _PyUnicode_WSTR_LENGTH(unicode) - num_surrogates;

  001fc	48 8b b3 90 00
	00 00		 mov	 rsi, QWORD PTR [rbx+144]
  00203	48 2b 74 24 48	 sub	 rsi, QWORD PTR num_surrogates$[rsp]

; 1498 :         _PyUnicode_DATA_ANY(unicode) = PyObject_MALLOC(4 * (length_wo_surrogates + 1));

  00208	48 8d 0c b5 04
	00 00 00	 lea	 rcx, QWORD PTR [rsi*4+4]
  00210	e8 00 00 00 00	 call	 PyObject_Malloc
  00215	48 8d bb a0 00
	00 00		 lea	 rdi, QWORD PTR [rbx+160]
  0021c	48 89 07	 mov	 QWORD PTR [rdi], rax

; 1499 :         if (!_PyUnicode_DATA_ANY(unicode)) {

  0021f	48 85 c0	 test	 rax, rax
  00222	75 0a		 jne	 SHORT $LN1@PyUnicode_@3
$LN41@PyUnicode_@3:

; 1500 :             PyErr_NoMemory();

  00224	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1501 :             return -1;

  00229	83 c8 ff	 or	 eax, -1
  0022c	eb 66		 jmp	 SHORT $LN40@PyUnicode_@3
$LN1@PyUnicode_@3:

; 1502 :         }
; 1503 :         _PyUnicode_LENGTH(unicode) = length_wo_surrogates;
; 1504 :         _PyUnicode_STATE(unicode).kind = PyUnicode_4BYTE_KIND;

  0022e	83 63 70 f3	 and	 DWORD PTR [rbx+112], -13 ; fffffff3H

; 1505 :         _PyUnicode_UTF8(unicode) = NULL;
; 1506 :         _PyUnicode_UTF8_LENGTH(unicode) = 0;
; 1507 :         /* unicode_convert_wchar_to_ucs4() requires a ready string */
; 1508 :         _PyUnicode_STATE(unicode).ready = 1;
; 1509 :         unicode_convert_wchar_to_ucs4(_PyUnicode_WSTR(unicode), end, unicode);

  00232	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  00236	81 4b 70 90 00
	00 00		 or	 DWORD PTR [rbx+112], 144 ; 00000090H
  0023d	48 89 73 60	 mov	 QWORD PTR [rbx+96], rsi
  00241	48 8d b3 80 00
	00 00		 lea	 rsi, QWORD PTR [rbx+128]
  00248	4c 8b c3	 mov	 r8, rbx
  0024b	48 8b d5	 mov	 rdx, rbp
  0024e	4c 89 a3 88 00
	00 00		 mov	 QWORD PTR [rbx+136], r12
  00255	4c 89 26	 mov	 QWORD PTR [rsi], r12
  00258	e8 00 00 00 00	 call	 unicode_convert_wchar_to_ucs4

; 1510 :         PyObject_FREE(_PyUnicode_WSTR(unicode));

  0025d	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  00261	e8 00 00 00 00	 call	 PyObject_Free

; 1511 :         _PyUnicode_WSTR(unicode) = NULL;
; 1512 :         _PyUnicode_WSTR_LENGTH(unicode) = 0;
; 1513 : #else
; 1514 :         assert(num_surrogates == 0);
; 1515 : 
; 1516 :         _PyUnicode_DATA_ANY(unicode) = _PyUnicode_WSTR(unicode);
; 1517 :         _PyUnicode_LENGTH(unicode) = _PyUnicode_WSTR_LENGTH(unicode);
; 1518 :         _PyUnicode_UTF8(unicode) = NULL;
; 1519 :         _PyUnicode_UTF8_LENGTH(unicode) = 0;
; 1520 :         _PyUnicode_STATE(unicode).kind = PyUnicode_4BYTE_KIND;
; 1521 : #endif
; 1522 :         PyUnicode_4BYTE_DATA(unicode)[_PyUnicode_LENGTH(unicode)] = '\0';

  00266	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00269	4c 89 63 78	 mov	 QWORD PTR [rbx+120], r12
  0026d	4c 89 a3 90 00
	00 00		 mov	 QWORD PTR [rbx+144], r12
  00274	a8 20		 test	 al, 32			; 00000020H
  00276	74 08		 je	 SHORT $LN33@PyUnicode_@3
  00278	a8 40		 test	 al, 64			; 00000040H
  0027a	48 0f 45 fe	 cmovne	 rdi, rsi
  0027e	eb 03		 jmp	 SHORT $LN34@PyUnicode_@3
$LN33@PyUnicode_@3:
  00280	48 8b 3f	 mov	 rdi, QWORD PTR [rdi]
$LN34@PyUnicode_@3:
  00283	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  00287	44 89 24 87	 mov	 DWORD PTR [rdi+rax*4], r12d
$LN2@PyUnicode_@3:

; 1523 :     }
; 1524 :     _PyUnicode_STATE(unicode).ready = 1;

  0028b	81 4b 70 80 00
	00 00		 or	 DWORD PTR [rbx+112], 128 ; 00000080H

; 1525 :     assert(_PyUnicode_CheckConsistency(unicode, 1));
; 1526 :     return 0;

  00292	33 c0		 xor	 eax, eax
$LN40@PyUnicode_@3:
  00294	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00299	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]

; 1527 : }

  0029e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002a2	41 5c		 pop	 r12
  002a4	5d		 pop	 rbp
  002a5	5b		 pop	 rbx
  002a6	c3		 ret	 0
_PyUnicode_Ready ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@HPDBFNNJ@deletion?5of?5interned?5string?5fail@ ; `string'
PUBLIC	??_C@_0CE@OHLDAHGF@Inconsistent?5interned?5string?5sta@ ; `string'
PUBLIC	??_C@_0BP@EIBHPFBB@Immortal?5interned?5string?5died?4?$AA@ ; `string'
PUBLIC	??_C@_0BA@MGIEGBOI@unicode_dealloc?$AA@		; `string'
EXTRN	PyDict_DelItem:PROC
EXTRN	Py_FatalError:PROC
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_dealloc DD imagerel unicode_dealloc
	DD	imagerel unicode_dealloc+297
	DD	imagerel $unwind$unicode_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_dealloc DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CD@HPDBFNNJ@deletion?5of?5interned?5string?5fail@
CONST	SEGMENT
??_C@_0CD@HPDBFNNJ@deletion?5of?5interned?5string?5fail@ DB 'deletion of '
	DB	'interned string failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OHLDAHGF@Inconsistent?5interned?5string?5sta@
CONST	SEGMENT
??_C@_0CE@OHLDAHGF@Inconsistent?5interned?5string?5sta@ DB 'Inconsistent '
	DB	'interned string state.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EIBHPFBB@Immortal?5interned?5string?5died?4?$AA@
CONST	SEGMENT
??_C@_0BP@EIBHPFBB@Immortal?5interned?5string?5died?4?$AA@ DB 'Immortal i'
	DB	'nterned string died.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MGIEGBOI@unicode_dealloc?$AA@
CONST	SEGMENT
??_C@_0BA@MGIEGBOI@unicode_dealloc?$AA@ DB 'unicode_dealloc', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_dealloc
_TEXT	SEGMENT
unicode$ = 48
unicode_dealloc PROC					; COMDAT

; 1531 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1532 :     Py_GUARD

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 1c		 je	 SHORT $LN11@unicode_de
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MGIEGBOI@unicode_dealloc?$AA@
  00020	45 33 c9	 xor	 r9d, r9d
  00023	41 b8 fc 05 00
	00		 mov	 r8d, 1532		; 000005fcH
  00029	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN11@unicode_de:

; 1533 : 
; 1534 :     switch (PyUnicode_CHECK_INTERNED(unicode)) {

  0002e	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00031	83 e0 03	 and	 eax, 3
  00034	74 44		 je	 SHORT $LN6@unicode_de
  00036	ff c8		 dec	 eax
  00038	74 19		 je	 SHORT $LN7@unicode_de
  0003a	ff c8		 dec	 eax
  0003c	75 0c		 jne	 SHORT $LN4@unicode_de

; 1544 :         break;
; 1545 : 
; 1546 :     case SSTATE_INTERNED_IMMORTAL:
; 1547 :         Py_FatalError("Immortal interned string died.");

  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@EIBHPFBB@Immortal?5interned?5string?5died?4?$AA@
  00045	e8 00 00 00 00	 call	 Py_FatalError
$LN4@unicode_de:

; 1548 : 
; 1549 :     default:
; 1550 :         Py_FatalError("Inconsistent interned string state.");

  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@OHLDAHGF@Inconsistent?5interned?5string?5sta@
  00051	eb 22		 jmp	 SHORT $LN30@unicode_de
$LN7@unicode_de:

; 1535 :     case SSTATE_NOT_INTERNED:
; 1536 :         break;
; 1537 : 
; 1538 :     case SSTATE_INTERNED_MORTAL:
; 1539 :         /* revive dead object temporarily for DelItem */
; 1540 :         Py_REFCNT(unicode) = 3;
; 1541 :         if (PyDict_DelItem(interned, unicode) != 0)

  00053	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR interned
  0005a	48 8b d3	 mov	 rdx, rbx
  0005d	48 c7 43 50 03
	00 00 00	 mov	 QWORD PTR [rbx+80], 3
  00065	e8 00 00 00 00	 call	 PyDict_DelItem
  0006a	85 c0		 test	 eax, eax
  0006c	74 0c		 je	 SHORT $LN6@unicode_de

; 1542 :             Py_FatalError(
; 1543 :                 "deletion of interned string failed");

  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HPDBFNNJ@deletion?5of?5interned?5string?5fail@
$LN30@unicode_de:
  00075	e8 00 00 00 00	 call	 Py_FatalError
$LN6@unicode_de:

; 1551 :     }
; 1552 : 
; 1553 :     if (_PyUnicode_HAS_WSTR_MEMORY(unicode))

  0007a	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  0007e	48 85 c9	 test	 rcx, rcx
  00081	74 32		 je	 SHORT $LN3@unicode_de
  00083	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00086	84 c0		 test	 al, al
  00088	79 26		 jns	 SHORT $LN28@unicode_de
  0008a	a8 20		 test	 al, 32			; 00000020H
  0008c	74 16		 je	 SHORT $LN16@unicode_de
  0008e	a8 40		 test	 al, 64			; 00000040H
  00090	74 09		 je	 SHORT $LN14@unicode_de
  00092	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00099	eb 10		 jmp	 SHORT $LN17@unicode_de
$LN14@unicode_de:
  0009b	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  000a2	eb 07		 jmp	 SHORT $LN17@unicode_de
$LN16@unicode_de:
  000a4	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN17@unicode_de:
  000ab	48 3b c8	 cmp	 rcx, rax
  000ae	74 05		 je	 SHORT $LN3@unicode_de
$LN28@unicode_de:

; 1554 :         PyObject_DEL(_PyUnicode_WSTR(unicode));

  000b0	e8 00 00 00 00	 call	 PyObject_Free
$LN3@unicode_de:

; 1555 :     if (_PyUnicode_HAS_UTF8_MEMORY(unicode))

  000b5	8b 53 70	 mov	 edx, DWORD PTR [rbx+112]
  000b8	8b c2		 mov	 eax, edx
  000ba	c1 e8 06	 shr	 eax, 6
  000bd	83 e0 01	 and	 eax, 1
  000c0	74 05		 je	 SHORT $LN21@unicode_de
  000c2	f6 c2 20	 test	 dl, 32			; 00000020H
  000c5	75 38		 jne	 SHORT $LN2@unicode_de
$LN21@unicode_de:
  000c7	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
  000ce	48 85 c9	 test	 rcx, rcx
  000d1	74 2c		 je	 SHORT $LN2@unicode_de
  000d3	f6 c2 20	 test	 dl, 32			; 00000020H
  000d6	74 16		 je	 SHORT $LN25@unicode_de
  000d8	85 c0		 test	 eax, eax
  000da	74 09		 je	 SHORT $LN23@unicode_de
  000dc	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  000e3	eb 10		 jmp	 SHORT $LN26@unicode_de
$LN23@unicode_de:
  000e5	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  000ec	eb 07		 jmp	 SHORT $LN26@unicode_de
$LN25@unicode_de:
  000ee	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN26@unicode_de:
  000f5	48 3b c8	 cmp	 rcx, rax
  000f8	74 05		 je	 SHORT $LN2@unicode_de

; 1556 :         PyObject_DEL(_PyUnicode_UTF8(unicode));

  000fa	e8 00 00 00 00	 call	 PyObject_Free
$LN2@unicode_de:

; 1557 :     if (!PyUnicode_IS_COMPACT(unicode) && _PyUnicode_DATA_ANY(unicode))

  000ff	f6 43 70 20	 test	 BYTE PTR [rbx+112], 32	; 00000020H
  00103	75 11		 jne	 SHORT $LN1@unicode_de
  00105	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
  0010c	48 85 c9	 test	 rcx, rcx
  0010f	74 05		 je	 SHORT $LN1@unicode_de

; 1558 :         PyObject_DEL(_PyUnicode_DATA_ANY(unicode));

  00111	e8 00 00 00 00	 call	 PyObject_Free
$LN1@unicode_de:

; 1559 : 
; 1560 :     Py_TYPE(unicode)->tp_free(unicode);

  00116	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0011a	48 8b cb	 mov	 rcx, rbx

; 1561 : }

  0011d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00121	5b		 pop	 rbx
  00122	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
unicode_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@JPFLAEHL@unicode_modifiable?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_modifiable DD imagerel unicode_modifiable
	DD	imagerel unicode_modifiable+136
	DD	imagerel $unwind$unicode_modifiable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_modifiable DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0BD@JPFLAEHL@unicode_modifiable?$AA@
CONST	SEGMENT
??_C@_0BD@JPFLAEHL@unicode_modifiable?$AA@ DB 'unicode_modifiable', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_modifiable
_TEXT	SEGMENT
unicode$ = 64
unicode_modifiable PROC					; COMDAT

; 1587 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 1588 :     assert(_PyUnicode_CHECK(unicode));
; 1589 : #ifdef WITH_PARALLEL
; 1590 :     if (Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX

; 1591 :         if (Py_ISPY(unicode))

  0000e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00016	4c 8b cb	 mov	 r9, rbx
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@JPFLAEHL@unicode_modifiable?$AA@
  00027	85 c0		 test	 eax, eax
  00029	74 1a		 je	 SHORT $LN9@unicode_mo
  0002b	41 b8 37 06 00
	00		 mov	 r8d, 1591		; 00000637H
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	33 c9		 xor	 ecx, ecx
  00038	85 c0		 test	 eax, eax

; 1610 :     if (!PyUnicode_CheckExact(unicode))

  0003a	0f 94 c1	 sete	 cl
  0003d	8b c1		 mov	 eax, ecx

; 1611 :         return 0;
; 1612 : #ifdef Py_DEBUG
; 1613 :     /* singleton refcount is greater than 1 */
; 1614 :     assert(!unicode_is_singleton(unicode));
; 1615 : #endif
; 1616 :     return 1;
; 1617 : }

  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	5b		 pop	 rbx
  00044	c3		 ret	 0
$LN9@unicode_mo:

; 1592 :             return 0;
; 1593 :         else {
; 1594 :             assert(Px_TEST_OBJ(unicode));
; 1595 :             return 1;
; 1596 :         }
; 1597 :     } else {
; 1598 :         if (!Py_ISPY(unicode)) {

  00045	41 b8 3e 06 00
	00		 mov	 r8d, 1598		; 0000063eH
  0004b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00050	85 c0		 test	 eax, eax
  00052	75 08		 jne	 SHORT $LN5@unicode_mo
$LN13@unicode_mo:

; 1599 :             assert(Px_TEST_OBJ(unicode));
; 1600 :             return 0;

  00054	33 c0		 xor	 eax, eax

; 1611 :         return 0;
; 1612 : #ifdef Py_DEBUG
; 1613 :     /* singleton refcount is greater than 1 */
; 1614 :     assert(!unicode_is_singleton(unicode));
; 1615 : #endif
; 1616 :     return 1;
; 1617 : }

  00056	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005a	5b		 pop	 rbx
  0005b	c3		 ret	 0
$LN5@unicode_mo:

; 1601 :         }
; 1602 :     }
; 1603 : #endif
; 1604 :     if (Py_REFCNT(unicode) != 1)

  0005c	48 83 7b 50 01	 cmp	 QWORD PTR [rbx+80], 1

; 1605 :         return 0;

  00061	75 f1		 jne	 SHORT $LN13@unicode_mo

; 1606 :     if (_PyUnicode_HASH(unicode) != -1)

  00063	48 83 7b 68 ff	 cmp	 QWORD PTR [rbx+104], -1

; 1607 :         return 0;

  00068	75 ea		 jne	 SHORT $LN13@unicode_mo

; 1608 :     if (PyUnicode_CHECK_INTERNED(unicode))

  0006a	f6 43 70 03	 test	 BYTE PTR [rbx+112], 3

; 1609 :         return 0;

  0006e	75 e4		 jne	 SHORT $LN13@unicode_mo

; 1610 :     if (!PyUnicode_CheckExact(unicode))

  00070	33 c9		 xor	 ecx, ecx
  00072	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00079	48 39 43 58	 cmp	 QWORD PTR [rbx+88], rax
  0007d	0f 94 c1	 sete	 cl
  00080	8b c1		 mov	 eax, ecx

; 1611 :         return 0;
; 1612 : #ifdef Py_DEBUG
; 1613 :     /* singleton refcount is greater than 1 */
; 1614 :     assert(!unicode_is_singleton(unicode));
; 1615 : #endif
; 1616 :     return 1;
; 1617 : }

  00082	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00086	5b		 pop	 rbx
  00087	c3		 ret	 0
unicode_modifiable ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_widen DD imagerel unicode_widen
	DD	imagerel unicode_widen+99
	DD	imagerel $unwind$unicode_widen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_widen DD imagerel unicode_widen+99
	DD	imagerel unicode_widen+136
	DD	imagerel $chain$0$unicode_widen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$unicode_widen DD imagerel unicode_widen+136
	DD	imagerel unicode_widen+186
	DD	imagerel $chain$2$unicode_widen
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$unicode_widen DD 020021H
	DD	083400H
	DD	imagerel unicode_widen
	DD	imagerel unicode_widen+99
	DD	imagerel $unwind$unicode_widen
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_widen DD 020521H
	DD	083405H
	DD	imagerel unicode_widen
	DD	imagerel unicode_widen+99
	DD	imagerel $unwind$unicode_widen
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_widen DD 040a01H
	DD	09640aH
	DD	07006520aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_widen
_TEXT	SEGMENT
p_unicode$ = 64
length$ = 72
maxchar$ = 80
unicode_widen PROC					; COMDAT

; 1687 : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 1688 :     PyObject *result;
; 1689 :     assert(PyUnicode_IS_READY(*p_unicode));
; 1690 :     assert(length <= PyUnicode_GET_LENGTH(*p_unicode));
; 1691 :     if (maxchar <= PyUnicode_MAX_CHAR_VALUE(*p_unicode))

  0000d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00010	48 8b f2	 mov	 rsi, rdx
  00013	44 8b 49 70	 mov	 r9d, DWORD PTR [rcx+112]
  00017	41 f6 c1 40	 test	 r9b, 64			; 00000040H
  0001b	74 07		 je	 SHORT $LN7@unicode_wi
  0001d	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  00022	eb 26		 jmp	 SHORT $LN6@unicode_wi
$LN7@unicode_wi:
  00024	41 c1 e9 02	 shr	 r9d, 2
  00028	41 83 e1 07	 and	 r9d, 7
  0002c	41 83 f9 01	 cmp	 r9d, 1
  00030	75 07		 jne	 SHORT $LN5@unicode_wi
  00032	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00037	eb 11		 jmp	 SHORT $LN6@unicode_wi
$LN5@unicode_wi:
  00039	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH
  0003e	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00043	41 83 f9 02	 cmp	 r9d, 2
  00047	0f 44 c2	 cmove	 eax, edx
$LN6@unicode_wi:
  0004a	44 3b c0	 cmp	 r8d, eax
  0004d	77 0d		 ja	 SHORT $LN2@unicode_wi

; 1692 :         return 0;

  0004f	33 c0		 xor	 eax, eax

; 1699 :     *p_unicode = result;
; 1700 :     return 0;
; 1701 : }

  00051	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00056	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005a	5f		 pop	 rdi
  0005b	c3		 ret	 0
$LN2@unicode_wi:

; 1693 :     result = PyUnicode_New(PyUnicode_GET_LENGTH(*p_unicode),
; 1694 :                            maxchar);

  0005c	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00060	41 8b d0	 mov	 edx, r8d
  00063	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00068	e8 00 00 00 00	 call	 PyUnicode_New
  0006d	48 8b d8	 mov	 rbx, rax

; 1695 :     if (result == NULL)

  00070	48 85 c0	 test	 rax, rax
  00073	75 13		 jne	 SHORT $LN1@unicode_wi

; 1696 :         return -1;

  00075	83 c8 ff	 or	 eax, -1
  00078	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1699 :     *p_unicode = result;
; 1700 :     return 0;
; 1701 : }

  0007d	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00082	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00086	5f		 pop	 rdi
  00087	c3		 ret	 0
$LN1@unicode_wi:

; 1697 :     _PyUnicode_FastCopyCharacters(result, 0, *p_unicode, 0, length);

  00088	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
  0008b	45 33 c9	 xor	 r9d, r9d
  0008e	33 d2		 xor	 edx, edx
  00090	48 8b c8	 mov	 rcx, rax
  00093	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00098	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 1698 :     Py_DECREF(*p_unicode);

  0009d	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  000a0	e8 00 00 00 00	 call	 _Py_DecRef

; 1699 :     *p_unicode = result;
; 1700 :     return 0;
; 1701 : }

  000a5	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000aa	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  000ad	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b2	33 c0		 xor	 eax, eax
  000b4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0
unicode_widen ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_putchar DD imagerel unicode_putchar
	DD	imagerel unicode_putchar+256
	DD	imagerel $unwind$unicode_putchar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_putchar DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_putchar
_TEXT	SEGMENT
p_unicode$ = 48
pos$ = 56
ch$ = 64
unicode_putchar PROC					; COMDAT

; 1706 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b da	 mov	 rbx, rdx

; 1707 :     assert(ch <= MAX_UNICODE);
; 1708 :     if (unicode_widen(p_unicode, *pos, ch) < 0)

  00012	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00015	41 8b f8	 mov	 edi, r8d
  00018	48 8b f1	 mov	 rsi, rcx
  0001b	e8 00 00 00 00	 call	 unicode_widen
  00020	85 c0		 test	 eax, eax
  00022	79 13		 jns	 SHORT $LN8@unicode_pu

; 1709 :         return -1;

  00024	83 c8 ff	 or	 eax, -1

; 1713 :     return 0;
; 1714 : }

  00027	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5f		 pop	 rdi
  00036	c3		 ret	 0
$LN8@unicode_pu:

; 1710 :     PyUnicode_WRITE(PyUnicode_KIND(*p_unicode),
; 1711 :                     PyUnicode_DATA(*p_unicode),
; 1712 :                     (*pos)++, ch);

  00037	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0003a	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  0003d	8b d1		 mov	 edx, ecx
  0003f	c1 ea 02	 shr	 edx, 2
  00042	83 e2 07	 and	 edx, 7
  00045	ff ca		 dec	 edx
  00047	74 78		 je	 SHORT $LN3@unicode_pu
  00049	ff ca		 dec	 edx
  0004b	74 3a		 je	 SHORT $LN2@unicode_pu
  0004d	f6 c1 20	 test	 cl, 32			; 00000020H
  00050	74 26		 je	 SHORT $LN22@unicode_pu
  00052	f6 c1 40	 test	 cl, 64			; 00000040H
  00055	74 12		 je	 SHORT $LN20@unicode_pu
  00057	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  0005e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00061	89 3c 81	 mov	 DWORD PTR [rcx+rax*4], edi
  00064	e9 82 00 00 00	 jmp	 $LN24@unicode_pu
$LN20@unicode_pu:
  00069	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  00070	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00073	89 3c 81	 mov	 DWORD PTR [rcx+rax*4], edi
  00076	eb 73		 jmp	 SHORT $LN24@unicode_pu
$LN22@unicode_pu:
  00078	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  0007f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00082	89 3c 81	 mov	 DWORD PTR [rcx+rax*4], edi
  00085	eb 64		 jmp	 SHORT $LN24@unicode_pu
$LN2@unicode_pu:
  00087	f6 c1 20	 test	 cl, 32			; 00000020H
  0008a	74 25		 je	 SHORT $LN18@unicode_pu
  0008c	f6 c1 40	 test	 cl, 64			; 00000040H
  0008f	74 10		 je	 SHORT $LN16@unicode_pu
  00091	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  00098	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0009b	66 89 3c 41	 mov	 WORD PTR [rcx+rax*2], di
  0009f	eb 4a		 jmp	 SHORT $LN24@unicode_pu
$LN16@unicode_pu:
  000a1	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  000a8	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000ab	66 89 3c 41	 mov	 WORD PTR [rcx+rax*2], di
  000af	eb 3a		 jmp	 SHORT $LN24@unicode_pu
$LN18@unicode_pu:
  000b1	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  000b8	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000bb	66 89 3c 41	 mov	 WORD PTR [rcx+rax*2], di
  000bf	eb 2a		 jmp	 SHORT $LN24@unicode_pu
$LN3@unicode_pu:
  000c1	f6 c1 20	 test	 cl, 32			; 00000020H
  000c4	74 17		 je	 SHORT $LN14@unicode_pu
  000c6	f6 c1 40	 test	 cl, 64			; 00000040H
  000c9	74 09		 je	 SHORT $LN12@unicode_pu
  000cb	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  000d2	eb 10		 jmp	 SHORT $LN15@unicode_pu
$LN12@unicode_pu:
  000d4	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  000db	eb 07		 jmp	 SHORT $LN15@unicode_pu
$LN14@unicode_pu:
  000dd	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
$LN15@unicode_pu:
  000e4	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000e7	40 88 3c 01	 mov	 BYTE PTR [rcx+rax], dil
$LN24@unicode_pu:
  000eb	48 ff 03	 inc	 QWORD PTR [rbx]

; 1713 :     return 0;
; 1714 : }

  000ee	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000f3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000f8	33 c0		 xor	 eax, eax
  000fa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fe	5f		 pop	 rdi
  000ff	c3		 ret	 0
unicode_putchar ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_write_cstr DD imagerel unicode_write_cstr
	DD	imagerel unicode_write_cstr+157
	DD	imagerel $unwind$unicode_write_cstr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_write_cstr DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_write_cstr
_TEXT	SEGMENT
unicode$ = 48
index$ = 56
str$ = 64
len$ = 72
unicode_write_cstr PROC					; COMDAT

; 1724 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1725 :     enum PyUnicode_Kind kind = PyUnicode_KIND(unicode);

  00004	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00007	4d 8b d0	 mov	 r10, r8
  0000a	4c 8b da	 mov	 r11, rdx
  0000d	44 8b c0	 mov	 r8d, eax
  00010	41 c1 e8 02	 shr	 r8d, 2
  00014	41 83 e0 07	 and	 r8d, 7

; 1726 :     void *data = PyUnicode_DATA(unicode);

  00018	a8 20		 test	 al, 32			; 00000020H
  0001a	74 13		 je	 SHORT $LN16@unicode_wr
  0001c	a8 40		 test	 al, 64			; 00000040H
  0001e	74 06		 je	 SHORT $LN14@unicode_wr
  00020	48 83 e9 80	 sub	 rcx, -128		; ffffffffffffff80H
  00024	eb 10		 jmp	 SHORT $LN17@unicode_wr
$LN14@unicode_wr:
  00026	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  0002d	eb 07		 jmp	 SHORT $LN17@unicode_wr
$LN16@unicode_wr:
  0002f	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
$LN17@unicode_wr:

; 1727 :     const char *end = str + len;
; 1728 : 
; 1729 :     switch (kind) {

  00036	41 ff c8	 dec	 r8d
  00039	4b 8d 14 0a	 lea	 rdx, QWORD PTR [r10+r9]
  0003d	74 4b		 je	 SHORT $LN9@unicode_wr
  0003f	41 ff c8	 dec	 r8d
  00042	74 24		 je	 SHORT $LN8@unicode_wr

; 1742 : 
; 1743 :         assert((ucs2 - start) <= PyUnicode_GET_LENGTH(unicode));
; 1744 :         break;
; 1745 :     }
; 1746 :     default: {
; 1747 :         Py_UCS4 *start = (Py_UCS4 *)data + index;

  00044	4a 8d 0c 99	 lea	 rcx, QWORD PTR [rcx+r11*4]

; 1748 :         Py_UCS4 *ucs4 = start;
; 1749 :         assert(kind == PyUnicode_4BYTE_KIND);
; 1750 :         assert(index <= PyUnicode_GET_LENGTH(unicode));
; 1751 : 
; 1752 :         for (; str < end; ++ucs4, ++str)

  00048	4c 3b d2	 cmp	 r10, rdx
  0004b	73 4b		 jae	 SHORT $LN1@unicode_wr
  0004d	0f 1f 00	 npad	 3
$LL3@unicode_wr:

; 1753 :             *ucs4 = (Py_UCS4)*str;

  00050	41 0f be 02	 movsx	 eax, BYTE PTR [r10]
  00054	49 ff c2	 inc	 r10
  00057	48 83 c1 04	 add	 rcx, 4
  0005b	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  0005e	4c 3b d2	 cmp	 r10, rdx
  00061	72 ed		 jb	 SHORT $LL3@unicode_wr

; 1754 : 
; 1755 :         assert((ucs4 - start) <= PyUnicode_GET_LENGTH(unicode));
; 1756 :     }
; 1757 :     }
; 1758 : }

  00063	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00067	c3		 ret	 0
$LN8@unicode_wr:

; 1733 :         break;
; 1734 :     }
; 1735 :     case PyUnicode_2BYTE_KIND: {
; 1736 :         Py_UCS2 *start = (Py_UCS2 *)data + index;

  00068	4a 8d 0c 59	 lea	 rcx, QWORD PTR [rcx+r11*2]

; 1737 :         Py_UCS2 *ucs2 = start;
; 1738 :         assert(index <= PyUnicode_GET_LENGTH(unicode));
; 1739 : 
; 1740 :         for (; str < end; ++ucs2, ++str)

  0006c	4c 3b d2	 cmp	 r10, rdx
  0006f	73 27		 jae	 SHORT $LN1@unicode_wr
$LL7@unicode_wr:

; 1741 :             *ucs2 = (Py_UCS2)*str;

  00071	41 0f be 02	 movsx	 eax, BYTE PTR [r10]
  00075	49 ff c2	 inc	 r10
  00078	48 83 c1 02	 add	 rcx, 2
  0007c	66 89 41 fe	 mov	 WORD PTR [rcx-2], ax
  00080	4c 3b d2	 cmp	 r10, rdx
  00083	72 ec		 jb	 SHORT $LL7@unicode_wr

; 1754 : 
; 1755 :         assert((ucs4 - start) <= PyUnicode_GET_LENGTH(unicode));
; 1756 :     }
; 1757 :     }
; 1758 : }

  00085	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00089	c3		 ret	 0
$LN9@unicode_wr:

; 1730 :     case PyUnicode_1BYTE_KIND: {
; 1731 :         assert(index + len <= PyUnicode_GET_LENGTH(unicode));
; 1732 :         memcpy((char *) data + index, str, len);

  0008a	49 03 cb	 add	 rcx, r11
  0008d	4d 8b c1	 mov	 r8, r9
  00090	49 8b d2	 mov	 rdx, r10
  00093	e8 00 00 00 00	 call	 memcpy
$LN1@unicode_wr:

; 1754 : 
; 1755 :         assert((ucs4 - start) <= PyUnicode_GET_LENGTH(unicode));
; 1756 :     }
; 1757 :     }
; 1758 : }

  00098	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009c	c3		 ret	 0
unicode_write_cstr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@MMNCDMIN@tls_get_latin1_char?$AA@	; `string'
PUBLIC	tls_get_latin1_char
EXTRN	_PyParallel_DisableTLSHeap:PROC
EXTRN	_PyParallel_EnableTLSHeap:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$tls_get_latin1_char DD imagerel $LN10
	DD	imagerel $LN10+204
	DD	imagerel $unwind$tls_get_latin1_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tls_get_latin1_char DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_0BE@MMNCDMIN@tls_get_latin1_char?$AA@
CONST	SEGMENT
??_C@_0BE@MMNCDMIN@tls_get_latin1_char?$AA@ DB 'tls_get_latin1_char', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT tls_get_latin1_char
_TEXT	SEGMENT
ch$ = 48
tls_get_latin1_char PROC				; COMDAT

; 1763 : {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	0f b6 f9	 movzx	 edi, cl

; 1764 :     PyObject *unicode;
; 1765 :     Px_GUARD

  00017	e8 00 00 00 00	 call	 _Py_PXCTX
  0001c	85 c0		 test	 eax, eax
  0001e	75 1d		 jne	 SHORT $LN3@tls_get_la
  00020	44 8d 48 01	 lea	 r9d, QWORD PTR [rax+1]
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@MMNCDMIN@tls_get_latin1_char?$AA@
  00032	41 b8 e5 06 00
	00		 mov	 r8d, 1765		; 000006e5H
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@tls_get_la:

; 1766 :     unicode = tls_unicode_latin1[ch];

  0003d	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00044	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0004d	40 0f b6 d7	 movzx	 edx, dil
  00051	4a 8b 04 c0	 mov	 rax, QWORD PTR [rax+r8*8]
  00055	bd 00 00 00 00	 mov	 ebp, OFFSET FLAT:tls_unicode_latin1
  0005a	48 8d 34 d0	 lea	 rsi, QWORD PTR [rax+rdx*8]
  0005e	48 8b 1c 2e	 mov	 rbx, QWORD PTR [rsi+rbp]

; 1767 :     if (!unicode) {

  00062	48 85 db	 test	 rbx, rbx
  00065	75 4d		 jne	 SHORT $LN2@tls_get_la

; 1768 :         _PyParallel_EnableTLSHeap();

  00067	e8 00 00 00 00	 call	 _PyParallel_EnableTLSHeap

; 1769 :         unicode = PyUnicode_New(1, ch);

  0006c	8d 4b 01	 lea	 ecx, QWORD PTR [rbx+1]
  0006f	40 0f b6 d7	 movzx	 edx, dil
  00073	e8 00 00 00 00	 call	 PyUnicode_New
  00078	48 8b d8	 mov	 rbx, rax

; 1770 :         _PyParallel_DisableTLSHeap();

  0007b	e8 00 00 00 00	 call	 _PyParallel_DisableTLSHeap

; 1771 :         if (!unicode)

  00080	48 85 db	 test	 rbx, rbx
  00083	75 04		 jne	 SHORT $LN1@tls_get_la

; 1772 :             return NULL;

  00085	33 c0		 xor	 eax, eax
  00087	eb 2e		 jmp	 SHORT $LN4@tls_get_la
$LN1@tls_get_la:

; 1773 :         PyUnicode_1BYTE_DATA(unicode)[0] = ch;

  00089	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0008c	a8 20		 test	 al, 32			; 00000020H
  0008e	74 16		 je	 SHORT $LN8@tls_get_la
  00090	a8 40		 test	 al, 64			; 00000040H
  00092	74 09		 je	 SHORT $LN6@tls_get_la
  00094	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  0009b	eb 10		 jmp	 SHORT $LN9@tls_get_la
$LN6@tls_get_la:
  0009d	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  000a4	eb 07		 jmp	 SHORT $LN9@tls_get_la
$LN8@tls_get_la:
  000a6	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN9@tls_get_la:
  000ad	40 88 38	 mov	 BYTE PTR [rax], dil

; 1774 :         assert(_PyUnicode_CheckConsistency(unicode, 1));
; 1775 :         tls_unicode_latin1[ch] = unicode;

  000b0	48 89 1c 2e	 mov	 QWORD PTR [rsi+rbp], rbx
$LN2@tls_get_la:

; 1776 :     }
; 1777 :     return unicode;

  000b4	48 8b c3	 mov	 rax, rbx
$LN4@tls_get_la:

; 1778 : }

  000b7	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000bc	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000c1	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000c6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ca	5f		 pop	 rdi
  000cb	c3		 ret	 0
tls_get_latin1_char ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$get_latin1_char DD imagerel get_latin1_char
	DD	imagerel get_latin1_char+214
	DD	imagerel $unwind$get_latin1_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_latin1_char DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT get_latin1_char
_TEXT	SEGMENT
ch$ = 64
get_latin1_char PROC					; COMDAT

; 1783 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	0f b6 f9	 movzx	 edi, cl

; 1784 :     PyObject *unicode = unicode_latin1[ch];

  00017	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:unicode_latin1
  0001e	48 8b 5c fd 00	 mov	 rbx, QWORD PTR [rbp+rdi*8]
  00023	8b f7		 mov	 esi, edi

; 1785 :     if (!unicode) {

  00025	48 85 db	 test	 rbx, rbx
  00028	75 59		 jne	 SHORT $LN3@get_latin1

; 1786 :         Px_RETURN(tls_get_latin1_char(ch));

  0002a	e8 00 00 00 00	 call	 _Py_PXCTX
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@get_latin1
  00033	40 0f b6 cf	 movzx	 ecx, dil
  00037	e8 00 00 00 00	 call	 tls_get_latin1_char
  0003c	e9 80 00 00 00	 jmp	 $LN4@get_latin1
$LN2@get_latin1:

; 1787 :         unicode = PyUnicode_New(1, ch);

  00041	40 0f b6 d7	 movzx	 edx, dil
  00045	b9 01 00 00 00	 mov	 ecx, 1
  0004a	e8 00 00 00 00	 call	 PyUnicode_New
  0004f	48 8b d8	 mov	 rbx, rax

; 1788 :         if (!unicode)

  00052	48 85 c0	 test	 rax, rax
  00055	74 6a		 je	 SHORT $LN4@get_latin1
$LN1@get_latin1:

; 1789 :             return NULL;
; 1790 :         PyUnicode_1BYTE_DATA(unicode)[0] = ch;

  00057	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0005a	a8 20		 test	 al, 32			; 00000020H
  0005c	74 16		 je	 SHORT $LN8@get_latin1
  0005e	a8 40		 test	 al, 64			; 00000040H
  00060	74 09		 je	 SHORT $LN6@get_latin1
  00062	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00069	eb 10		 jmp	 SHORT $LN9@get_latin1
$LN6@get_latin1:
  0006b	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00072	eb 07		 jmp	 SHORT $LN9@get_latin1
$LN8@get_latin1:
  00074	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN9@get_latin1:
  0007b	40 88 38	 mov	 BYTE PTR [rax], dil

; 1791 :         assert(_PyUnicode_CheckConsistency(unicode, 1));
; 1792 :         unicode_latin1[ch] = unicode;

  0007e	48 89 5c f5 00	 mov	 QWORD PTR [rbp+rsi*8], rbx
$LN3@get_latin1:

; 1793 :     }
; 1794 :     Py_INCREF(unicode);

  00083	e8 00 00 00 00	 call	 _Py_PXCTX
  00088	85 c0		 test	 eax, eax
  0008a	75 32		 jne	 SHORT $LN11@get_latin1
  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0009a	4c 8b cb	 mov	 r9, rbx
  0009d	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a3	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000ab	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b0	85 c0		 test	 eax, eax
  000b2	75 06		 jne	 SHORT $LN10@get_latin1
  000b4	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000b8	74 04		 je	 SHORT $LN11@get_latin1
$LN10@get_latin1:
  000ba	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN11@get_latin1:

; 1795 :     return unicode;

  000be	48 8b c3	 mov	 rax, rbx
$LN4@get_latin1:

; 1796 : }

  000c1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c6	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000cb	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000d0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d4	5f		 pop	 rdi
  000d5	c3		 ret	 0
get_latin1_char ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@OCCJMJBF@_PyUnicode_ClearStaticStrings?$AA@ ; `string'
PUBLIC	_PyUnicode_ClearStaticStrings
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_PyUnicode_ClearStaticStrings DD imagerel $LN24
	DD	imagerel $LN24+66
	DD	imagerel $unwind$_PyUnicode_ClearStaticStrings
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_PyUnicode_ClearStaticStrings DD imagerel $LN24+66
	DD	imagerel $LN24+262
	DD	imagerel $chain$1$_PyUnicode_ClearStaticStrings
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_PyUnicode_ClearStaticStrings DD imagerel $LN24+262
	DD	imagerel $LN24+280
	DD	imagerel $chain$2$_PyUnicode_ClearStaticStrings
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_PyUnicode_ClearStaticStrings DD 021H
	DD	imagerel $LN24
	DD	imagerel $LN24+66
	DD	imagerel $unwind$_PyUnicode_ClearStaticStrings
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_PyUnicode_ClearStaticStrings DD 020521H
	DD	083405H
	DD	imagerel $LN24
	DD	imagerel $LN24+66
	DD	imagerel $unwind$_PyUnicode_ClearStaticStrings
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_ClearStaticStrings DD 043701H
	DD	096437H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_0BO@OCCJMJBF@_PyUnicode_ClearStaticStrings?$AA@
CONST	SEGMENT
??_C@_0BO@OCCJMJBF@_PyUnicode_ClearStaticStrings?$AA@ DB '_PyUnicode_Clea'
	DB	'rStaticStrings', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT _PyUnicode_ClearStaticStrings
_TEXT	SEGMENT
_PyUnicode_ClearStaticStrings PROC			; COMDAT

; 1938 : {

$LN24:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1939 :     _Py_Identifier *tmp, *s;
; 1940 :     Py_GUARD

  00006	e8 00 00 00 00	 call	 _Py_PXCTX
  0000b	85 c0		 test	 eax, eax
  0000d	74 1c		 je	 SHORT $LN7@PyUnicode_@4
  0000f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@OCCJMJBF@_PyUnicode_ClearStaticStrings?$AA@
  0001d	45 33 c9	 xor	 r9d, r9d
  00020	41 b8 94 07 00
	00		 mov	 r8d, 1940		; 00000794H
  00026	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN7@PyUnicode_@4:

; 1941 :     s = static_strings;

  0002b	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR static_strings
  00032	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi

; 1942 :     while (s) {

  00037	33 f6		 xor	 esi, esi
  00039	48 85 ff	 test	 rdi, rdi
  0003c	0f 84 c4 00 00
	00		 je	 $LN23@PyUnicode_@4
  00042	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00047	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL6@PyUnicode_@4:

; 1943 :         Py_CLEAR(s->object);

  00050	4c 8b 4f 10	 mov	 r9, QWORD PTR [rdi+16]
  00054	4d 85 c9	 test	 r9, r9
  00057	0f 84 92 00 00
	00		 je	 $LN3@PyUnicode_@4
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@OCCJMJBF@_PyUnicode_ClearStaticStrings?$AA@
  0006b	41 b8 97 07 00
	00		 mov	 r8d, 1943		; 00000797H
  00071	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00079	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007e	85 c0		 test	 eax, eax
  00080	75 6d		 jne	 SHORT $LN3@PyUnicode_@4
  00082	48 8b 5f 10	 mov	 rbx, QWORD PTR [rdi+16]
  00086	48 89 77 10	 mov	 QWORD PTR [rdi+16], rsi
  0008a	e8 00 00 00 00	 call	 _Py_PXCTX
  0008f	85 c0		 test	 eax, eax
  00091	75 5c		 jne	 SHORT $LN3@PyUnicode_@4
  00093	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00097	a8 20		 test	 al, 32			; 00000020H
  00099	75 4c		 jne	 SHORT $LN14@PyUnicode_@4
  0009b	84 c0		 test	 al, al
  0009d	78 48		 js	 SHORT $LN14@PyUnicode_@4
  0009f	a8 02		 test	 al, 2
  000a1	75 4c		 jne	 SHORT $LN3@PyUnicode_@4
  000a3	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000a7	75 46		 jne	 SHORT $LN3@PyUnicode_@4
  000a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000b7	4c 8b cb	 mov	 r9, rbx
  000ba	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000c0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000c8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000cd	48 8b cb	 mov	 rcx, rbx
  000d0	85 c0		 test	 eax, eax
  000d2	74 07		 je	 SHORT $LN19@PyUnicode_@4
  000d4	e8 00 00 00 00	 call	 _Px_Dealloc
  000d9	eb 14		 jmp	 SHORT $LN3@PyUnicode_@4
$LN19@PyUnicode_@4:
  000db	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000df	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000e5	eb 08		 jmp	 SHORT $LN3@PyUnicode_@4
$LN14@PyUnicode_@4:
  000e7	48 8b cb	 mov	 rcx, rbx
  000ea	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PyUnicode_@4:

; 1944 :         tmp = s->next;

  000ef	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 1945 :         s->next = NULL;

  000f2	48 89 37	 mov	 QWORD PTR [rdi], rsi

; 1946 :         s = tmp;

  000f5	48 8b f8	 mov	 rdi, rax
  000f8	48 85 c0	 test	 rax, rax
  000fb	0f 85 4f ff ff
	ff		 jne	 $LL6@PyUnicode_@4
  00101	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN23@PyUnicode_@4:

; 1947 :     }
; 1948 :     static_strings = NULL;

  00106	48 89 35 00 00
	00 00		 mov	 QWORD PTR static_strings, rsi
  0010d	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 1949 : }

  00112	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00116	5f		 pop	 rdi
  00117	c3		 ret	 0
_PyUnicode_ClearStaticStrings ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_FromASCII
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_FromASCII DD imagerel $LN10
	DD	imagerel $LN10+48
	DD	imagerel $unwind$_PyUnicode_FromASCII
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyUnicode_FromASCII DD imagerel $LN10+48
	DD	imagerel $LN10+82
	DD	imagerel $chain$0$_PyUnicode_FromASCII
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_PyUnicode_FromASCII DD imagerel $LN10+82
	DD	imagerel $LN10+148
	DD	imagerel $chain$2$_PyUnicode_FromASCII
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_PyUnicode_FromASCII DD 020021H
	DD	063400H
	DD	imagerel $LN10
	DD	imagerel $LN10+48
	DD	imagerel $unwind$_PyUnicode_FromASCII
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyUnicode_FromASCII DD 020521H
	DD	063405H
	DD	imagerel $LN10
	DD	imagerel $LN10+48
	DD	imagerel $unwind$_PyUnicode_FromASCII
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_FromASCII DD 040a01H
	DD	07640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_FromASCII
_TEXT	SEGMENT
buffer$ = 48
size$ = 56
_PyUnicode_FromASCII PROC				; COMDAT

; 1955 : {

$LN10:
  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b f1	 mov	 rsi, rcx

; 1956 :     const unsigned char *s = (const unsigned char *)buffer;
; 1957 :     PyObject *unicode;
; 1958 :     if (size == 1) {

  00010	48 83 fa 01	 cmp	 rdx, 1
  00014	75 12		 jne	 SHORT $LN2@PyUnicode_@5

; 1959 : #ifdef Py_DEBUG
; 1960 :         assert((unsigned char)s[0] < 128);
; 1961 : #endif
; 1962 :         return get_latin1_char(s[0]);

  00016	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]

; 1968 :     assert(_PyUnicode_CheckConsistency(unicode, 1));
; 1969 :     return unicode;
; 1970 : }

  00019	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5f		 pop	 rdi
  00023	e9 00 00 00 00	 jmp	 get_latin1_char
$LN2@PyUnicode_@5:

; 1963 :     }
; 1964 :     unicode = PyUnicode_New(size, 127);

  00028	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  0002d	48 8b cf	 mov	 rcx, rdi
  00030	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00035	e8 00 00 00 00	 call	 PyUnicode_New
  0003a	48 8b d8	 mov	 rbx, rax

; 1965 :     if (!unicode)

  0003d	48 85 c0	 test	 rax, rax
  00040	75 10		 jne	 SHORT $LN1@PyUnicode_@5
  00042	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1968 :     assert(_PyUnicode_CheckConsistency(unicode, 1));
; 1969 :     return unicode;
; 1970 : }

  00047	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5f		 pop	 rdi
  00051	c3		 ret	 0
$LN1@PyUnicode_@5:

; 1966 :         return NULL;
; 1967 :     memcpy(PyUnicode_1BYTE_DATA(unicode), s, size);

  00052	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00055	a8 20		 test	 al, 32			; 00000020H
  00057	74 16		 je	 SHORT $LN7@PyUnicode_@5
  00059	a8 40		 test	 al, 64			; 00000040H
  0005b	74 09		 je	 SHORT $LN5@PyUnicode_@5
  0005d	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  00064	eb 10		 jmp	 SHORT $LN8@PyUnicode_@5
$LN5@PyUnicode_@5:
  00066	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  0006d	eb 07		 jmp	 SHORT $LN8@PyUnicode_@5
$LN7@PyUnicode_@5:
  0006f	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
$LN8@PyUnicode_@5:
  00076	4c 8b c7	 mov	 r8, rdi
  00079	48 8b d6	 mov	 rdx, rsi
  0007c	e8 00 00 00 00	 call	 memcpy

; 1968 :     assert(_PyUnicode_CheckConsistency(unicode, 1));
; 1969 :     return unicode;
; 1970 : }

  00081	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00086	48 8b c3	 mov	 rax, rbx
  00089	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00092	5f		 pop	 rdi
  00093	c3		 ret	 0
_PyUnicode_FromASCII ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT kind_maxchar_limit
_TEXT	SEGMENT
kind$ = 8
kind_maxchar_limit PROC					; COMDAT

; 1975 :     switch (kind) {

  00000	ff c9		 dec	 ecx
  00002	74 1b		 je	 SHORT $LN4@kind_maxch
  00004	ff c9		 dec	 ecx
  00006	74 11		 je	 SHORT $LN3@kind_maxch
  00008	83 f9 02	 cmp	 ecx, 2
  0000b	74 06		 je	 SHORT $LN2@kind_maxch

; 1982 :     default:
; 1983 :         assert(0 && "invalid kind");
; 1984 :         return MAX_UNICODE;

  0000d	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH

; 1985 :     }
; 1986 : }

  00012	c3		 ret	 0
$LN2@kind_maxch:

; 1980 :     case PyUnicode_4BYTE_KIND:
; 1981 :         return 0x10000;

  00013	b8 00 00 01 00	 mov	 eax, 65536		; 00010000H

; 1985 :     }
; 1986 : }

  00018	c3		 ret	 0
$LN3@kind_maxch:

; 1978 :     case PyUnicode_2BYTE_KIND:
; 1979 :         return 0x100;

  00019	b8 00 01 00 00	 mov	 eax, 256		; 00000100H

; 1985 :     }
; 1986 : }

  0001e	c3		 ret	 0
$LN4@kind_maxch:

; 1976 :     case PyUnicode_1BYTE_KIND:
; 1977 :         return 0x80;

  0001f	b8 80 00 00 00	 mov	 eax, 128		; 00000080H

; 1985 :     }
; 1986 : }

  00024	c3		 ret	 0
kind_maxchar_limit ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT align_maxchar
_TEXT	SEGMENT
maxchar$ = 8
align_maxchar PROC					; COMDAT

; 1991 :     if (maxchar <= 127)

  00000	83 f9 7f	 cmp	 ecx, 127		; 0000007fH
  00003	77 06		 ja	 SHORT $LN6@align_maxc

; 1992 :         return 127;

  00005	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH

; 1996 :         return 65535;
; 1997 :     else
; 1998 :         return MAX_UNICODE;
; 1999 : }

  0000a	c3		 ret	 0
$LN6@align_maxc:

; 1993 :     else if (maxchar <= 255)

  0000b	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00011	77 06		 ja	 SHORT $LN4@align_maxc

; 1994 :         return 255;

  00013	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH

; 1996 :         return 65535;
; 1997 :     else
; 1998 :         return MAX_UNICODE;
; 1999 : }

  00018	c3		 ret	 0
$LN4@align_maxc:

; 1995 :     else if (maxchar <= 65535)

  00019	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  0001e	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH
  00023	3b ca		 cmp	 ecx, edx
  00025	0f 46 c2	 cmovbe	 eax, edx

; 1996 :         return 65535;
; 1997 :     else
; 1998 :         return MAX_UNICODE;
; 1999 : }

  00028	c3		 ret	 0
align_maxchar ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\find_max_char.h
pdata	SEGMENT
$pdata$_PyUnicode_FromUCS1 DD imagerel _PyUnicode_FromUCS1
	DD	imagerel _PyUnicode_FromUCS1+108
	DD	imagerel $unwind$_PyUnicode_FromUCS1
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyUnicode_FromUCS1 DD imagerel _PyUnicode_FromUCS1+108
	DD	imagerel _PyUnicode_FromUCS1+224
	DD	imagerel $chain$0$_PyUnicode_FromUCS1
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_PyUnicode_FromUCS1 DD imagerel _PyUnicode_FromUCS1+224
	DD	imagerel _PyUnicode_FromUCS1+286
	DD	imagerel $chain$2$_PyUnicode_FromUCS1
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_PyUnicode_FromUCS1 DD imagerel _PyUnicode_FromUCS1+286
	DD	imagerel _PyUnicode_FromUCS1+297
	DD	imagerel $chain$3$_PyUnicode_FromUCS1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_PyUnicode_FromUCS1 DD 021H
	DD	imagerel _PyUnicode_FromUCS1
	DD	imagerel _PyUnicode_FromUCS1+108
	DD	imagerel $unwind$_PyUnicode_FromUCS1
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_PyUnicode_FromUCS1 DD 020021H
	DD	063400H
	DD	imagerel _PyUnicode_FromUCS1
	DD	imagerel _PyUnicode_FromUCS1+108
	DD	imagerel $unwind$_PyUnicode_FromUCS1
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyUnicode_FromUCS1 DD 020521H
	DD	063405H
	DD	imagerel _PyUnicode_FromUCS1
	DD	imagerel _PyUnicode_FromUCS1+108
	DD	imagerel $unwind$_PyUnicode_FromUCS1
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_FromUCS1 DD 040a01H
	DD	07640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT _PyUnicode_FromUCS1
_TEXT	SEGMENT
u$ = 48
size$ = 56
_PyUnicode_FromUCS1 PROC				; COMDAT

; 2003 : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b f1	 mov	 rsi, rcx

; 2004 :     PyObject *res;
; 2005 :     unsigned char max_char;
; 2006 : 
; 2007 :     if (size == 0)

  00010	48 85 d2	 test	 rdx, rdx
  00013	75 3b		 jne	 SHORT $LN9@PyUnicode_@6

; 2008 :         _Py_RETURN_UNICODE_EMPTY();

  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  0001c	48 85 c9	 test	 rcx, rcx
  0001f	75 18		 jne	 SHORT $LN37@PyUnicode_@6
  00021	e8 00 00 00 00	 call	 PyUnicode_New
  00026	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  0002d	48 85 c0	 test	 rax, rax
  00030	0f 84 e8 00 00
	00		 je	 $LN13@PyUnicode_@6
  00036	48 8b c8	 mov	 rcx, rax
$LN37@PyUnicode_@6:
  00039	e8 00 00 00 00	 call	 _Py_IncRef
  0003e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 2020 : }

  00045	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
$LN9@PyUnicode_@6:

; 2009 :     assert(size > 0);
; 2010 :     if (size == 1)

  00050	48 83 fa 01	 cmp	 rdx, 1
  00054	75 12		 jne	 SHORT $LN2@PyUnicode_@6

; 2011 :         return get_latin1_char(u[0]);

  00056	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]

; 2020 : }

  00059	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5f		 pop	 rdi
  00063	e9 00 00 00 00	 jmp	 get_latin1_char
$LN2@PyUnicode_@6:

; 2012 : 
; 2013 :     max_char = ucs1lib_find_max_char(u, u + size);

  00068	4c 8d 04 11	 lea	 r8, QWORD PTR [rcx+rdx]
  0006c	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00071	49 8b d0	 mov	 rdx, r8
  00074	48 83 e2 fc	 and	 rdx, -4
  00078	49 3b f0	 cmp	 rsi, r8
  0007b	73 3b		 jae	 SHORT $LN25@PyUnicode_@6
  0007d	0f 1f 00	 npad	 3
$LL26@PyUnicode_@6:
  00080	f6 c1 03	 test	 cl, 3
  00083	75 24		 jne	 SHORT $LN20@PyUnicode_@6
  00085	48 8b c1	 mov	 rax, rcx
  00088	48 3b ca	 cmp	 rcx, rdx
  0008b	73 14		 jae	 SHORT $LN22@PyUnicode_@6
  0008d	0f 1f 00	 npad	 3
$LL23@PyUnicode_@6:
  00090	f7 00 80 80 80
	80		 test	 DWORD PTR [rax], -2139062144 ; 80808080H
  00096	75 48		 jne	 SHORT $LN31@PyUnicode_@6
  00098	48 83 c0 04	 add	 rax, 4
  0009c	48 3b c2	 cmp	 rax, rdx
  0009f	72 ef		 jb	 SHORT $LL23@PyUnicode_@6
$LN22@PyUnicode_@6:
  000a1	48 8b c8	 mov	 rcx, rax
  000a4	49 3b c0	 cmp	 rax, r8
  000a7	74 0f		 je	 SHORT $LN25@PyUnicode_@6
$LN20@PyUnicode_@6:
  000a9	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  000ac	48 ff c1	 inc	 rcx
  000af	24 80		 and	 al, 128			; 00000080H
  000b1	75 2d		 jne	 SHORT $LN31@PyUnicode_@6
  000b3	49 3b c8	 cmp	 rcx, r8
  000b6	72 c8		 jb	 SHORT $LL26@PyUnicode_@6
$LN25@PyUnicode_@6:
  000b8	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
$LN27@PyUnicode_@6:

; 2014 :     res = PyUnicode_New(size, max_char);

  000bd	0f b6 d0	 movzx	 edx, al
  000c0	48 8b cf	 mov	 rcx, rdi
  000c3	e8 00 00 00 00	 call	 PyUnicode_New
  000c8	48 8b d8	 mov	 rbx, rax

; 2015 :     if (!res)

  000cb	48 85 c0	 test	 rax, rax
  000ce	75 17		 jne	 SHORT $LN1@PyUnicode_@6
  000d0	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 2020 : }

  000d5	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000da	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000de	5f		 pop	 rdi
  000df	c3		 ret	 0
$LN31@PyUnicode_@6:

; 2012 : 
; 2013 :     max_char = ucs1lib_find_max_char(u, u + size);

  000e0	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  000e5	eb d6		 jmp	 SHORT $LN27@PyUnicode_@6
$LN1@PyUnicode_@6:

; 2016 :         return NULL;
; 2017 :     memcpy(PyUnicode_1BYTE_DATA(res), u, size);

  000e7	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000ea	a8 20		 test	 al, 32			; 00000020H
  000ec	74 16		 je	 SHORT $LN17@PyUnicode_@6
  000ee	a8 40		 test	 al, 64			; 00000040H
  000f0	74 09		 je	 SHORT $LN15@PyUnicode_@6
  000f2	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  000f9	eb 10		 jmp	 SHORT $LN18@PyUnicode_@6
$LN15@PyUnicode_@6:
  000fb	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  00102	eb 07		 jmp	 SHORT $LN18@PyUnicode_@6
$LN17@PyUnicode_@6:
  00104	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
$LN18@PyUnicode_@6:
  0010b	4c 8b c7	 mov	 r8, rdi
  0010e	48 8b d6	 mov	 rdx, rsi
  00111	e8 00 00 00 00	 call	 memcpy

; 2018 :     assert(_PyUnicode_CheckConsistency(res, 1));
; 2019 :     return res;

  00116	48 8b c3	 mov	 rax, rbx
  00119	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN13@PyUnicode_@6:

; 2020 : }

  0011e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00123	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00127	5f		 pop	 rdi
  00128	c3		 ret	 0
_PyUnicode_FromUCS1 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_FromUCS2 DD imagerel _PyUnicode_FromUCS2
	DD	imagerel _PyUnicode_FromUCS2+384
	DD	imagerel $unwind$_PyUnicode_FromUCS2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_PyUnicode_FromUCS2 DD imagerel _PyUnicode_FromUCS2+384
	DD	imagerel _PyUnicode_FromUCS2+676
	DD	imagerel $chain$2$_PyUnicode_FromUCS2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_PyUnicode_FromUCS2 DD imagerel _PyUnicode_FromUCS2+676
	DD	imagerel _PyUnicode_FromUCS2+687
	DD	imagerel $chain$3$_PyUnicode_FromUCS2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_PyUnicode_FromUCS2 DD 021H
	DD	imagerel _PyUnicode_FromUCS2
	DD	imagerel _PyUnicode_FromUCS2+384
	DD	imagerel $unwind$_PyUnicode_FromUCS2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_PyUnicode_FromUCS2 DD 060f21H
	DD	08c40fH
	DD	07640aH
	DD	065405H
	DD	imagerel _PyUnicode_FromUCS2
	DD	imagerel _PyUnicode_FromUCS2+384
	DD	imagerel $unwind$_PyUnicode_FromUCS2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_FromUCS2 DD 040a01H
	DD	09340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_FromUCS2
_TEXT	SEGMENT
u$ = 48
size$ = 56
_PyUnicode_FromUCS2 PROC				; COMDAT

; 2024 : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 2025 :     PyObject *res;
; 2026 :     Py_UCS2 max_char;
; 2027 : 
; 2028 :     if (size == 0)

  00010	48 85 d2	 test	 rdx, rdx
  00013	75 3b		 jne	 SHORT $LN28@PyUnicode_@7

; 2029 :         _Py_RETURN_UNICODE_EMPTY();

  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  0001c	48 85 c9	 test	 rcx, rcx
  0001f	75 18		 jne	 SHORT $LN61@PyUnicode_@7
  00021	e8 00 00 00 00	 call	 PyUnicode_New
  00026	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  0002d	48 85 c0	 test	 rax, rax
  00030	0f 84 6e 02 00
	00		 je	 $LN32@PyUnicode_@7
  00036	48 8b c8	 mov	 rcx, rax
$LN61@PyUnicode_@7:
  00039	e8 00 00 00 00	 call	 _Py_IncRef
  0003e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 2056 : }

  00045	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
$LN28@PyUnicode_@7:

; 2030 :     assert(size > 0);
; 2031 :     if (size == 1) {

  00050	48 83 fa 01	 cmp	 rdx, 1
  00054	0f 85 26 01 00
	00		 jne	 $LN21@PyUnicode_@7

; 2032 :         Py_UCS4 ch = u[0];

  0005a	0f b7 19	 movzx	 ebx, WORD PTR [rcx]

; 2033 :         if (ch < 256)

  0005d	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00062	3b d8		 cmp	 ebx, eax
  00064	73 12		 jae	 SHORT $LN20@PyUnicode_@7

; 2034 :             return get_latin1_char((unsigned char)ch);

  00066	0f b6 cb	 movzx	 ecx, bl

; 2056 : }

  00069	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0006e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00072	5f		 pop	 rdi
  00073	e9 00 00 00 00	 jmp	 get_latin1_char
$LN20@PyUnicode_@7:

; 2035 : 
; 2036 :         res = PyUnicode_New(1, ch);

  00078	8b d3		 mov	 edx, ebx
  0007a	b9 01 00 00 00	 mov	 ecx, 1
  0007f	e8 00 00 00 00	 call	 PyUnicode_New

; 2037 :         if (res == NULL)

  00084	48 85 c0	 test	 rax, rax
  00087	75 0b		 jne	 SHORT $LN18@PyUnicode_@7

; 2056 : }

  00089	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0008e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00092	5f		 pop	 rdi
  00093	c3		 ret	 0
$LN18@PyUnicode_@7:

; 2038 :             return NULL;
; 2039 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  00094	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  00097	8b d1		 mov	 edx, ecx
  00099	c1 ea 02	 shr	 edx, 2
  0009c	83 e2 07	 and	 edx, 7
  0009f	ff ca		 dec	 edx
  000a1	0f 84 93 00 00
	00		 je	 $LN13@PyUnicode_@7
  000a7	ff ca		 dec	 edx
  000a9	74 46		 je	 SHORT $LN12@PyUnicode_@7
  000ab	f6 c1 20	 test	 cl, 32			; 00000020H
  000ae	74 2d		 je	 SHORT $LN44@PyUnicode_@7
  000b0	f6 c1 40	 test	 cl, 64			; 00000040H
  000b3	74 14		 je	 SHORT $LN42@PyUnicode_@7
  000b5	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  000bc	89 19		 mov	 DWORD PTR [rcx], ebx

; 2056 : }

  000be	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000c3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c7	5f		 pop	 rdi
  000c8	c3		 ret	 0
$LN42@PyUnicode_@7:

; 2038 :             return NULL;
; 2039 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  000c9	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  000d0	89 19		 mov	 DWORD PTR [rcx], ebx

; 2056 : }

  000d2	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000d7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000db	5f		 pop	 rdi
  000dc	c3		 ret	 0
$LN44@PyUnicode_@7:

; 2038 :             return NULL;
; 2039 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  000dd	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  000e4	89 19		 mov	 DWORD PTR [rcx], ebx

; 2056 : }

  000e6	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000eb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ef	5f		 pop	 rdi
  000f0	c3		 ret	 0
$LN12@PyUnicode_@7:

; 2038 :             return NULL;
; 2039 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  000f1	f6 c1 20	 test	 cl, 32			; 00000020H
  000f4	74 2f		 je	 SHORT $LN40@PyUnicode_@7
  000f6	f6 c1 40	 test	 cl, 64			; 00000040H
  000f9	74 15		 je	 SHORT $LN38@PyUnicode_@7
  000fb	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  00102	66 89 19	 mov	 WORD PTR [rcx], bx

; 2056 : }

  00105	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0010a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010e	5f		 pop	 rdi
  0010f	c3		 ret	 0
$LN38@PyUnicode_@7:

; 2038 :             return NULL;
; 2039 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  00110	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  00117	66 89 19	 mov	 WORD PTR [rcx], bx

; 2056 : }

  0011a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0011f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00123	5f		 pop	 rdi
  00124	c3		 ret	 0
$LN40@PyUnicode_@7:

; 2038 :             return NULL;
; 2039 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  00125	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  0012c	66 89 19	 mov	 WORD PTR [rcx], bx

; 2056 : }

  0012f	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00134	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00138	5f		 pop	 rdi
  00139	c3		 ret	 0
$LN13@PyUnicode_@7:

; 2038 :             return NULL;
; 2039 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  0013a	f6 c1 20	 test	 cl, 32			; 00000020H
  0013d	74 2d		 je	 SHORT $LN36@PyUnicode_@7
  0013f	f6 c1 40	 test	 cl, 64			; 00000040H
  00142	74 14		 je	 SHORT $LN34@PyUnicode_@7
  00144	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  0014b	88 19		 mov	 BYTE PTR [rcx], bl

; 2056 : }

  0014d	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00152	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00156	5f		 pop	 rdi
  00157	c3		 ret	 0
$LN34@PyUnicode_@7:

; 2038 :             return NULL;
; 2039 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  00158	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  0015f	88 19		 mov	 BYTE PTR [rcx], bl

; 2056 : }

  00161	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00166	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016a	5f		 pop	 rdi
  0016b	c3		 ret	 0
$LN36@PyUnicode_@7:

; 2038 :             return NULL;
; 2039 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  0016c	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  00173	88 19		 mov	 BYTE PTR [rcx], bl

; 2056 : }

  00175	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0017a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0017e	5f		 pop	 rdi
  0017f	c3		 ret	 0
$LN21@PyUnicode_@7:
  00180	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00185	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0018a	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12

; 2040 :         assert(_PyUnicode_CheckConsistency(res, 1));
; 2041 :         return res;
; 2042 :     }
; 2043 : 
; 2044 :     max_char = ucs2lib_find_max_char(u, u + size);

  0018f	4c 8d 24 12	 lea	 r12, QWORD PTR [rdx+rdx]
  00193	49 8d 34 0c	 lea	 rsi, QWORD PTR [r12+rcx]
  00197	48 8b d6	 mov	 rdx, rsi
  0019a	e8 00 00 00 00	 call	 ucs2lib_find_max_char

; 2045 :     res = PyUnicode_New(size, max_char);

  0019f	48 8b cf	 mov	 rcx, rdi
  001a2	0f b7 d0	 movzx	 edx, ax
  001a5	8b e8		 mov	 ebp, eax
  001a7	e8 00 00 00 00	 call	 PyUnicode_New
  001ac	48 8b f8	 mov	 rdi, rax

; 2046 :     if (!res)

  001af	48 85 c0	 test	 rax, rax
  001b2	0f 84 dd 00 00
	00		 je	 $LN60@PyUnicode_@7
$LN10@PyUnicode_@7:

; 2047 :         return NULL;
; 2048 :     if (max_char >= 256)

  001b8	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  001bd	66 3b e8	 cmp	 bp, ax

; 2049 :         memcpy(PyUnicode_2BYTE_DATA(res), u, sizeof(Py_UCS2)*size);

  001c0	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  001c3	72 4d		 jb	 SHORT $LN7@PyUnicode_@7
  001c5	a8 20		 test	 al, 32			; 00000020H
  001c7	74 32		 je	 SHORT $LN48@PyUnicode_@7
  001c9	a8 40		 test	 al, 64			; 00000040H
  001cb	74 17		 je	 SHORT $LN46@PyUnicode_@7
  001cd	48 8d 8f 80 00
	00 00		 lea	 rcx, QWORD PTR [rdi+128]
  001d4	4d 8b c4	 mov	 r8, r12
  001d7	48 8b d3	 mov	 rdx, rbx
  001da	e8 00 00 00 00	 call	 memcpy

; 2050 :     else {

  001df	e9 ae 00 00 00	 jmp	 $LN5@PyUnicode_@7
$LN46@PyUnicode_@7:

; 2049 :         memcpy(PyUnicode_2BYTE_DATA(res), u, sizeof(Py_UCS2)*size);

  001e4	48 8d 8f a0 00
	00 00		 lea	 rcx, QWORD PTR [rdi+160]
  001eb	4d 8b c4	 mov	 r8, r12
  001ee	48 8b d3	 mov	 rdx, rbx
  001f1	e8 00 00 00 00	 call	 memcpy

; 2050 :     else {

  001f6	e9 97 00 00 00	 jmp	 $LN5@PyUnicode_@7
$LN48@PyUnicode_@7:

; 2049 :         memcpy(PyUnicode_2BYTE_DATA(res), u, sizeof(Py_UCS2)*size);

  001fb	48 8b 8f a0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+160]
  00202	4d 8b c4	 mov	 r8, r12
  00205	48 8b d3	 mov	 rdx, rbx
  00208	e8 00 00 00 00	 call	 memcpy

; 2050 :     else {

  0020d	e9 80 00 00 00	 jmp	 $LN5@PyUnicode_@7
$LN7@PyUnicode_@7:

; 2051 :         _PyUnicode_CONVERT_BYTES(
; 2052 :             Py_UCS2, Py_UCS1, u, u + size, PyUnicode_1BYTE_DATA(res));

  00212	a8 20		 test	 al, 32			; 00000020H
  00214	74 16		 je	 SHORT $LN52@PyUnicode_@7
  00216	a8 40		 test	 al, 64			; 00000040H
  00218	74 09		 je	 SHORT $LN50@PyUnicode_@7
  0021a	48 8d 8f 80 00
	00 00		 lea	 rcx, QWORD PTR [rdi+128]
  00221	eb 10		 jmp	 SHORT $LN53@PyUnicode_@7
$LN50@PyUnicode_@7:
  00223	48 8d 8f a0 00
	00 00		 lea	 rcx, QWORD PTR [rdi+160]
  0022a	eb 07		 jmp	 SHORT $LN53@PyUnicode_@7
$LN52@PyUnicode_@7:
  0022c	48 8b 8f a0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+160]
$LN53@PyUnicode_@7:
  00233	48 8b c6	 mov	 rax, rsi
  00236	48 2b c3	 sub	 rax, rbx
  00239	48 d1 f8	 sar	 rax, 1
  0023c	48 83 e0 fc	 and	 rax, -4
  00240	48 8d 14 43	 lea	 rdx, QWORD PTR [rbx+rax*2]
  00244	48 3b da	 cmp	 rbx, rdx
  00247	73 2f		 jae	 SHORT $LN55@PyUnicode_@7
  00249	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@PyUnicode_@7:
  00250	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00253	48 83 c3 08	 add	 rbx, 8
  00257	48 83 c1 04	 add	 rcx, 4
  0025b	88 41 fc	 mov	 BYTE PTR [rcx-4], al
  0025e	0f b6 43 fa	 movzx	 eax, BYTE PTR [rbx-6]
  00262	88 41 fd	 mov	 BYTE PTR [rcx-3], al
  00265	0f b6 43 fc	 movzx	 eax, BYTE PTR [rbx-4]
  00269	88 41 fe	 mov	 BYTE PTR [rcx-2], al
  0026c	0f b6 43 fe	 movzx	 eax, BYTE PTR [rbx-2]
  00270	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  00273	48 3b da	 cmp	 rbx, rdx
  00276	72 d8		 jb	 SHORT $LL4@PyUnicode_@7
$LN55@PyUnicode_@7:
  00278	48 3b de	 cmp	 rbx, rsi
  0027b	73 15		 jae	 SHORT $LN5@PyUnicode_@7
  0027d	0f 1f 00	 npad	 3
$LL2@PyUnicode_@7:
  00280	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00283	48 83 c3 02	 add	 rbx, 2
  00287	48 ff c1	 inc	 rcx
  0028a	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0028d	48 3b de	 cmp	 rbx, rsi
  00290	72 ee		 jb	 SHORT $LL2@PyUnicode_@7
$LN5@PyUnicode_@7:

; 2053 :     }
; 2054 :     assert(_PyUnicode_CheckConsistency(res, 1));
; 2055 :     return res;

  00292	48 8b c7	 mov	 rax, rdi
$LN60@PyUnicode_@7:
  00295	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0029a	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0029f	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]
$LN32@PyUnicode_@7:

; 2056 : }

  002a4	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  002a9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002ad	5f		 pop	 rdi
  002ae	c3		 ret	 0
_PyUnicode_FromUCS2 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_FromUCS4 DD imagerel _PyUnicode_FromUCS4
	DD	imagerel _PyUnicode_FromUCS4+314
	DD	imagerel $unwind$_PyUnicode_FromUCS4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_PyUnicode_FromUCS4 DD imagerel _PyUnicode_FromUCS4+314
	DD	imagerel _PyUnicode_FromUCS4+746
	DD	imagerel $chain$3$_PyUnicode_FromUCS4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_PyUnicode_FromUCS4 DD imagerel _PyUnicode_FromUCS4+746
	DD	imagerel _PyUnicode_FromUCS4+752
	DD	imagerel $chain$4$_PyUnicode_FromUCS4
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_PyUnicode_FromUCS4 DD 021H
	DD	imagerel _PyUnicode_FromUCS4
	DD	imagerel _PyUnicode_FromUCS4+314
	DD	imagerel $unwind$_PyUnicode_FromUCS4
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_PyUnicode_FromUCS4 DD 081421H
	DD	09c414H
	DD	08740fH
	DD	07640aH
	DD	065405H
	DD	imagerel _PyUnicode_FromUCS4
	DD	imagerel _PyUnicode_FromUCS4+314
	DD	imagerel $unwind$_PyUnicode_FromUCS4
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_FromUCS4 DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_FromUCS4
_TEXT	SEGMENT
u$ = 48
size$ = 56
_PyUnicode_FromUCS4 PROC				; COMDAT

; 2060 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4c 8b da	 mov	 r11, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 2061 :     PyObject *res;
; 2062 :     Py_UCS4 max_char;
; 2063 : 
; 2064 :     if (size == 0)

  0000c	48 85 d2	 test	 rdx, rdx
  0000f	75 36		 jne	 SHORT $LN37@PyUnicode_@8

; 2065 :         _Py_RETURN_UNICODE_EMPTY();

  00011	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  00018	48 85 c9	 test	 rcx, rcx
  0001b	75 18		 jne	 SHORT $LN79@PyUnicode_@8
  0001d	e8 00 00 00 00	 call	 PyUnicode_New
  00022	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  00029	48 85 c0	 test	 rax, rax
  0002c	0f 84 b8 02 00
	00		 je	 $LN41@PyUnicode_@8
  00032	48 8b c8	 mov	 rcx, rax
$LN79@PyUnicode_@8:
  00035	e8 00 00 00 00	 call	 _Py_IncRef
  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 2094 : }

  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5b		 pop	 rbx
  00046	c3		 ret	 0
$LN37@PyUnicode_@8:

; 2066 :     assert(size > 0);
; 2067 :     if (size == 1) {

  00047	48 83 fa 01	 cmp	 rdx, 1
  0004b	0f 85 e9 00 00
	00		 jne	 $LN30@PyUnicode_@8

; 2068 :         Py_UCS4 ch = u[0];

  00051	8b 19		 mov	 ebx, DWORD PTR [rcx]

; 2069 :         if (ch < 256)

  00053	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  00059	73 0d		 jae	 SHORT $LN29@PyUnicode_@8

; 2070 :             return get_latin1_char((unsigned char)ch);

  0005b	0f b6 cb	 movzx	 ecx, bl

; 2094 : }

  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5b		 pop	 rbx
  00063	e9 00 00 00 00	 jmp	 get_latin1_char
$LN29@PyUnicode_@8:

; 2071 : 
; 2072 :         res = PyUnicode_New(1, ch);

  00068	8b d3		 mov	 edx, ebx
  0006a	b9 01 00 00 00	 mov	 ecx, 1
  0006f	e8 00 00 00 00	 call	 PyUnicode_New

; 2073 :         if (res == NULL)

  00074	48 85 c0	 test	 rax, rax
  00077	75 06		 jne	 SHORT $LN27@PyUnicode_@8

; 2094 : }

  00079	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007d	5b		 pop	 rbx
  0007e	c3		 ret	 0
$LN27@PyUnicode_@8:

; 2074 :             return NULL;
; 2075 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  0007f	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  00082	8b d1		 mov	 edx, ecx
  00084	c1 ea 02	 shr	 edx, 2
  00087	83 e2 07	 and	 edx, 7
  0008a	ff ca		 dec	 edx
  0008c	74 75		 je	 SHORT $LN22@PyUnicode_@8
  0008e	ff ca		 dec	 edx
  00090	74 37		 je	 SHORT $LN21@PyUnicode_@8
  00092	f6 c1 20	 test	 cl, 32			; 00000020H
  00095	74 23		 je	 SHORT $LN53@PyUnicode_@8
  00097	f6 c1 40	 test	 cl, 64			; 00000040H
  0009a	74 0f		 je	 SHORT $LN51@PyUnicode_@8
  0009c	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  000a3	89 19		 mov	 DWORD PTR [rcx], ebx

; 2094 : }

  000a5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a9	5b		 pop	 rbx
  000aa	c3		 ret	 0
$LN51@PyUnicode_@8:

; 2074 :             return NULL;
; 2075 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  000ab	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  000b2	89 19		 mov	 DWORD PTR [rcx], ebx

; 2094 : }

  000b4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b8	5b		 pop	 rbx
  000b9	c3		 ret	 0
$LN53@PyUnicode_@8:

; 2074 :             return NULL;
; 2075 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  000ba	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  000c1	89 19		 mov	 DWORD PTR [rcx], ebx

; 2094 : }

  000c3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c7	5b		 pop	 rbx
  000c8	c3		 ret	 0
$LN21@PyUnicode_@8:

; 2074 :             return NULL;
; 2075 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  000c9	f6 c1 20	 test	 cl, 32			; 00000020H
  000cc	74 25		 je	 SHORT $LN49@PyUnicode_@8
  000ce	f6 c1 40	 test	 cl, 64			; 00000040H
  000d1	74 10		 je	 SHORT $LN47@PyUnicode_@8
  000d3	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  000da	66 89 19	 mov	 WORD PTR [rcx], bx

; 2094 : }

  000dd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e1	5b		 pop	 rbx
  000e2	c3		 ret	 0
$LN47@PyUnicode_@8:

; 2074 :             return NULL;
; 2075 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  000e3	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  000ea	66 89 19	 mov	 WORD PTR [rcx], bx

; 2094 : }

  000ed	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f1	5b		 pop	 rbx
  000f2	c3		 ret	 0
$LN49@PyUnicode_@8:

; 2074 :             return NULL;
; 2075 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  000f3	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  000fa	66 89 19	 mov	 WORD PTR [rcx], bx

; 2094 : }

  000fd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00101	5b		 pop	 rbx
  00102	c3		 ret	 0
$LN22@PyUnicode_@8:

; 2074 :             return NULL;
; 2075 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  00103	f6 c1 20	 test	 cl, 32			; 00000020H
  00106	74 23		 je	 SHORT $LN45@PyUnicode_@8
  00108	f6 c1 40	 test	 cl, 64			; 00000040H
  0010b	74 0f		 je	 SHORT $LN43@PyUnicode_@8
  0010d	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  00114	88 19		 mov	 BYTE PTR [rcx], bl

; 2094 : }

  00116	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011a	5b		 pop	 rbx
  0011b	c3		 ret	 0
$LN43@PyUnicode_@8:

; 2074 :             return NULL;
; 2075 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  0011c	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  00123	88 19		 mov	 BYTE PTR [rcx], bl

; 2094 : }

  00125	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00129	5b		 pop	 rbx
  0012a	c3		 ret	 0
$LN45@PyUnicode_@8:

; 2074 :             return NULL;
; 2075 :         PyUnicode_WRITE(PyUnicode_KIND(res), PyUnicode_DATA(res), 0, ch);

  0012b	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  00132	88 19		 mov	 BYTE PTR [rcx], bl

; 2094 : }

  00134	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00138	5b		 pop	 rbx
  00139	c3		 ret	 0
$LN30@PyUnicode_@8:
  0013a	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0013f	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00144	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00149	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12

; 2076 :         assert(_PyUnicode_CheckConsistency(res, 1));
; 2077 :         return res;
; 2078 :     }
; 2079 : 
; 2080 :     max_char = ucs4lib_find_max_char(u, u + size);

  0014e	4c 8d 24 95 00
	00 00 00	 lea	 r12, QWORD PTR [rdx*4]
  00156	49 8d 34 0c	 lea	 rsi, QWORD PTR [r12+rcx]
  0015a	48 8b d6	 mov	 rdx, rsi
  0015d	e8 00 00 00 00	 call	 ucs4lib_find_max_char

; 2081 :     res = PyUnicode_New(size, max_char);

  00162	49 8b cb	 mov	 rcx, r11
  00165	8b d0		 mov	 edx, eax
  00167	8b e8		 mov	 ebp, eax
  00169	e8 00 00 00 00	 call	 PyUnicode_New
  0016e	48 8b f8	 mov	 rdi, rax

; 2082 :     if (!res)

  00171	48 85 c0	 test	 rax, rax
  00174	0f 84 5c 01 00
	00		 je	 $LN78@PyUnicode_@8
$LN19@PyUnicode_@8:

; 2083 :         return NULL;
; 2084 :     if (max_char < 256)
; 2085 :         _PyUnicode_CONVERT_BYTES(Py_UCS4, Py_UCS1, u, u + size,
; 2086 :                                  PyUnicode_1BYTE_DATA(res));

  0017a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0017d	81 fd 00 01 00
	00		 cmp	 ebp, 256		; 00000100H
  00183	0f 83 8e 00 00
	00		 jae	 $LN18@PyUnicode_@8
  00189	a8 20		 test	 al, 32			; 00000020H
  0018b	74 16		 je	 SHORT $LN57@PyUnicode_@8
  0018d	a8 40		 test	 al, 64			; 00000040H
  0018f	74 09		 je	 SHORT $LN55@PyUnicode_@8
  00191	48 8d 8f 80 00
	00 00		 lea	 rcx, QWORD PTR [rdi+128]
  00198	eb 10		 jmp	 SHORT $LN58@PyUnicode_@8
$LN55@PyUnicode_@8:
  0019a	48 8d 8f a0 00
	00 00		 lea	 rcx, QWORD PTR [rdi+160]
  001a1	eb 07		 jmp	 SHORT $LN58@PyUnicode_@8
$LN57@PyUnicode_@8:
  001a3	48 8b 8f a0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+160]
$LN58@PyUnicode_@8:
  001aa	48 8b c6	 mov	 rax, rsi
  001ad	48 2b c3	 sub	 rax, rbx
  001b0	48 c1 f8 02	 sar	 rax, 2
  001b4	48 83 e0 fc	 and	 rax, -4
  001b8	48 8d 14 83	 lea	 rdx, QWORD PTR [rbx+rax*4]
  001bc	48 3b da	 cmp	 rbx, rdx
  001bf	73 28		 jae	 SHORT $LN68@PyUnicode_@8
$LL14@PyUnicode_@8:
  001c1	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  001c4	48 83 c3 10	 add	 rbx, 16
  001c8	48 83 c1 04	 add	 rcx, 4
  001cc	88 41 fc	 mov	 BYTE PTR [rcx-4], al
  001cf	0f b6 43 f4	 movzx	 eax, BYTE PTR [rbx-12]
  001d3	88 41 fd	 mov	 BYTE PTR [rcx-3], al
  001d6	0f b6 43 f8	 movzx	 eax, BYTE PTR [rbx-8]
  001da	88 41 fe	 mov	 BYTE PTR [rcx-2], al
  001dd	0f b6 43 fc	 movzx	 eax, BYTE PTR [rbx-4]
  001e1	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  001e4	48 3b da	 cmp	 rbx, rdx
  001e7	72 d8		 jb	 SHORT $LL14@PyUnicode_@8
$LN68@PyUnicode_@8:
  001e9	48 3b de	 cmp	 rbx, rsi
  001ec	0f 83 e1 00 00
	00		 jae	 $LN1@PyUnicode_@8
  001f2	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL12@PyUnicode_@8:
  00200	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00203	48 83 c3 04	 add	 rbx, 4
  00207	48 ff c1	 inc	 rcx
  0020a	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0020d	48 3b de	 cmp	 rbx, rsi
  00210	72 ee		 jb	 SHORT $LL12@PyUnicode_@8

; 2087 :     else if (max_char < 0x10000)

  00212	e9 bc 00 00 00	 jmp	 $LN1@PyUnicode_@8
$LN18@PyUnicode_@8:
  00217	81 fd 00 00 01
	00		 cmp	 ebp, 65536		; 00010000H
  0021d	0f 83 84 00 00
	00		 jae	 $LN9@PyUnicode_@8

; 2088 :         _PyUnicode_CONVERT_BYTES(Py_UCS4, Py_UCS2, u, u + size,
; 2089 :                                  PyUnicode_2BYTE_DATA(res));

  00223	a8 20		 test	 al, 32			; 00000020H
  00225	74 16		 je	 SHORT $LN61@PyUnicode_@8
  00227	a8 40		 test	 al, 64			; 00000040H
  00229	74 09		 je	 SHORT $LN59@PyUnicode_@8
  0022b	48 8d 8f 80 00
	00 00		 lea	 rcx, QWORD PTR [rdi+128]
  00232	eb 10		 jmp	 SHORT $LN62@PyUnicode_@8
$LN59@PyUnicode_@8:
  00234	48 8d 8f a0 00
	00 00		 lea	 rcx, QWORD PTR [rdi+160]
  0023b	eb 07		 jmp	 SHORT $LN62@PyUnicode_@8
$LN61@PyUnicode_@8:
  0023d	48 8b 8f a0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+160]
$LN62@PyUnicode_@8:
  00244	48 8b c6	 mov	 rax, rsi
  00247	48 2b c3	 sub	 rax, rbx
  0024a	48 c1 f8 02	 sar	 rax, 2
  0024e	48 83 e0 fc	 and	 rax, -4
  00252	48 8d 14 83	 lea	 rdx, QWORD PTR [rbx+rax*4]
  00256	48 3b da	 cmp	 rbx, rdx
  00259	73 31		 jae	 SHORT $LN70@PyUnicode_@8
  0025b	0f 1f 44 00 00	 npad	 5
$LL5@PyUnicode_@8:
  00260	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00263	48 83 c3 10	 add	 rbx, 16
  00267	48 83 c1 08	 add	 rcx, 8
  0026b	66 89 41 f8	 mov	 WORD PTR [rcx-8], ax
  0026f	0f b7 43 f4	 movzx	 eax, WORD PTR [rbx-12]
  00273	66 89 41 fa	 mov	 WORD PTR [rcx-6], ax
  00277	0f b7 43 f8	 movzx	 eax, WORD PTR [rbx-8]
  0027b	66 89 41 fc	 mov	 WORD PTR [rcx-4], ax
  0027f	0f b7 43 fc	 movzx	 eax, WORD PTR [rbx-4]
  00283	66 89 41 fe	 mov	 WORD PTR [rcx-2], ax
  00287	48 3b da	 cmp	 rbx, rdx
  0028a	72 d4		 jb	 SHORT $LL5@PyUnicode_@8
$LN70@PyUnicode_@8:
  0028c	48 3b de	 cmp	 rbx, rsi
  0028f	73 42		 jae	 SHORT $LN1@PyUnicode_@8
$LL3@PyUnicode_@8:
  00291	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00294	48 83 c3 04	 add	 rbx, 4
  00298	48 83 c1 02	 add	 rcx, 2
  0029c	66 89 41 fe	 mov	 WORD PTR [rcx-2], ax
  002a0	48 3b de	 cmp	 rbx, rsi
  002a3	72 ec		 jb	 SHORT $LL3@PyUnicode_@8

; 2090 :     else

  002a5	eb 2c		 jmp	 SHORT $LN1@PyUnicode_@8
$LN9@PyUnicode_@8:

; 2091 :         memcpy(PyUnicode_4BYTE_DATA(res), u, sizeof(Py_UCS4)*size);

  002a7	a8 20		 test	 al, 32			; 00000020H
  002a9	74 16		 je	 SHORT $LN65@PyUnicode_@8
  002ab	a8 40		 test	 al, 64			; 00000040H
  002ad	74 09		 je	 SHORT $LN63@PyUnicode_@8
  002af	48 8d 8f 80 00
	00 00		 lea	 rcx, QWORD PTR [rdi+128]
  002b6	eb 10		 jmp	 SHORT $LN66@PyUnicode_@8
$LN63@PyUnicode_@8:
  002b8	48 8d 8f a0 00
	00 00		 lea	 rcx, QWORD PTR [rdi+160]
  002bf	eb 07		 jmp	 SHORT $LN66@PyUnicode_@8
$LN65@PyUnicode_@8:
  002c1	48 8b 8f a0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+160]
$LN66@PyUnicode_@8:
  002c8	4d 8b c4	 mov	 r8, r12
  002cb	48 8b d3	 mov	 rdx, rbx
  002ce	e8 00 00 00 00	 call	 memcpy
$LN1@PyUnicode_@8:

; 2092 :     assert(_PyUnicode_CheckConsistency(res, 1));
; 2093 :     return res;

  002d3	48 8b c7	 mov	 rax, rdi
$LN78@PyUnicode_@8:
  002d6	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  002db	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  002e0	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  002e5	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
$LN41@PyUnicode_@8:

; 2094 : }

  002ea	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002ee	5b		 pop	 rbx
  002ef	c3		 ret	 0
_PyUnicode_FromUCS4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@HGIODDJP@invalid?5kind?$AA@		; `string'
PUBLIC	??_C@_0BG@PMMIKIFL@size?5must?5be?5positive?$AA@ ; `string'
PUBLIC	PyUnicode_FromKindAndData
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_FromKindAndData DD imagerel $LN10
	DD	imagerel $LN10+122
	DD	imagerel $unwind$PyUnicode_FromKindAndData
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_FromKindAndData DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0N@HGIODDJP@invalid?5kind?$AA@
CONST	SEGMENT
??_C@_0N@HGIODDJP@invalid?5kind?$AA@ DB 'invalid kind', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PMMIKIFL@size?5must?5be?5positive?$AA@
CONST	SEGMENT
??_C@_0BG@PMMIKIFL@size?5must?5be?5positive?$AA@ DB 'size must be positiv'
	DB	'e', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_FromKindAndData
_TEXT	SEGMENT
kind$ = 48
buffer$ = 56
size$ = 64
PyUnicode_FromKindAndData PROC				; COMDAT

; 2098 : {

$LN10:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b ca	 mov	 r9, rdx

; 2099 :     if (size < 0) {

  00007	4d 85 c0	 test	 r8, r8
  0000a	79 1a		 jns	 SHORT $LN7@PyUnicode_@9

; 2100 :         PyErr_SetString(PyExc_ValueError, "size must be positive");

  0000c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PMMIKIFL@size?5must?5be?5positive?$AA@
  0001a	e8 00 00 00 00	 call	 PyErr_SetString

; 2101 :         return NULL;

  0001f	33 c0		 xor	 eax, eax

; 2113 :     }
; 2114 : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
$LN7@PyUnicode_@9:

; 2102 :     }
; 2103 :     switch (kind) {

  00026	ff c9		 dec	 ecx
  00028	74 41		 je	 SHORT $LN4@PyUnicode_@9
  0002a	ff c9		 dec	 ecx
  0002c	74 2e		 je	 SHORT $LN3@PyUnicode_@9
  0002e	83 f9 02	 cmp	 ecx, 2
  00031	74 1a		 je	 SHORT $LN2@PyUnicode_@9

; 2110 :     default:
; 2111 :         PyErr_SetString(PyExc_SystemError, "invalid kind");

  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@HGIODDJP@invalid?5kind?$AA@
  00041	e8 00 00 00 00	 call	 PyErr_SetString

; 2112 :         return NULL;

  00046	33 c0		 xor	 eax, eax

; 2113 :     }
; 2114 : }

  00048	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004c	c3		 ret	 0
$LN2@PyUnicode_@9:

; 2108 :     case PyUnicode_4BYTE_KIND:
; 2109 :         return _PyUnicode_FromUCS4(buffer, size);

  0004d	49 8b d0	 mov	 rdx, r8
  00050	49 8b c9	 mov	 rcx, r9

; 2113 :     }
; 2114 : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	e9 00 00 00 00	 jmp	 _PyUnicode_FromUCS4
$LN3@PyUnicode_@9:

; 2106 :     case PyUnicode_2BYTE_KIND:
; 2107 :         return _PyUnicode_FromUCS2(buffer, size);

  0005c	49 8b d0	 mov	 rdx, r8
  0005f	49 8b c9	 mov	 rcx, r9

; 2113 :     }
; 2114 : }

  00062	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00066	e9 00 00 00 00	 jmp	 _PyUnicode_FromUCS2
$LN4@PyUnicode_@9:

; 2104 :     case PyUnicode_1BYTE_KIND:
; 2105 :         return _PyUnicode_FromUCS1(buffer, size);

  0006b	49 8b d0	 mov	 rdx, r8
  0006e	49 8b c9	 mov	 rcx, r9

; 2113 :     }
; 2114 : }

  00071	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00075	e9 00 00 00 00	 jmp	 _PyUnicode_FromUCS1
PyUnicode_FromKindAndData ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_FindMaxChar
; Function compile flags: /Ogtpy
;	COMDAT _PyUnicode_FindMaxChar
_TEXT	SEGMENT
unicode$ = 8
start$ = 16
end$ = 24
_PyUnicode_FindMaxChar PROC				; COMDAT

; 2118 : {

  00000	4c 8b d2	 mov	 r10, rdx
  00003	4c 8b c9	 mov	 r9, rcx

; 2119 :     enum PyUnicode_Kind kind;
; 2120 :     void *startptr, *endptr;
; 2121 : 
; 2122 :     assert(PyUnicode_IS_READY(unicode));
; 2123 :     assert(0 <= start);
; 2124 :     assert(end <= PyUnicode_GET_LENGTH(unicode));
; 2125 :     assert(start <= end);
; 2126 : 
; 2127 :     if (start == 0 && end == PyUnicode_GET_LENGTH(unicode))

  00006	48 85 d2	 test	 rdx, rdx
  00009	75 30		 jne	 SHORT $LN9@PyUnicode_@10
  0000b	4c 3b 41 60	 cmp	 r8, QWORD PTR [rcx+96]
  0000f	75 2a		 jne	 SHORT $LN9@PyUnicode_@10

; 2128 :         return PyUnicode_MAX_CHAR_VALUE(unicode);

  00011	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00014	f6 c1 40	 test	 cl, 64			; 00000040H
  00017	75 27		 jne	 SHORT $LN20@PyUnicode_@10
  00019	c1 e9 02	 shr	 ecx, 2
  0001c	83 e1 07	 and	 ecx, 7
  0001f	83 f9 01	 cmp	 ecx, 1
  00022	75 06		 jne	 SHORT $LN12@PyUnicode_@10
  00024	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH

; 2150 :     }
; 2151 : }

  00029	c3		 ret	 0
$LN12@PyUnicode_@10:

; 2128 :         return PyUnicode_MAX_CHAR_VALUE(unicode);

  0002a	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH
  0002f	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00034	83 f9 02	 cmp	 ecx, 2
  00037	0f 44 c2	 cmove	 eax, edx

; 2150 :     }
; 2151 : }

  0003a	c3		 ret	 0
$LN9@PyUnicode_@10:

; 2129 : 
; 2130 :     if (start == end)

  0003b	49 3b d0	 cmp	 rdx, r8
  0003e	75 06		 jne	 SHORT $LN8@PyUnicode_@10
$LN20@PyUnicode_@10:

; 2131 :         return 127;

  00040	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH

; 2150 :     }
; 2151 : }

  00045	c3		 ret	 0
$LN8@PyUnicode_@10:

; 2132 : 
; 2133 :     if (PyUnicode_IS_ASCII(unicode))

  00046	f6 41 70 40	 test	 BYTE PTR [rcx+112], 64	; 00000040H

; 2134 :         return 127;

  0004a	75 f4		 jne	 SHORT $LN20@PyUnicode_@10

; 2135 : 
; 2136 :     kind = PyUnicode_KIND(unicode);

  0004c	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  0004f	8b c8		 mov	 ecx, eax
  00051	c1 e9 02	 shr	 ecx, 2
  00054	83 e1 07	 and	 ecx, 7

; 2137 :     startptr = PyUnicode_DATA(unicode);

  00057	a8 20		 test	 al, 32			; 00000020H
  00059	74 09		 je	 SHORT $LN18@PyUnicode_@10
  0005b	49 81 c1 a0 00
	00 00		 add	 r9, 160			; 000000a0H
  00062	eb 07		 jmp	 SHORT $LN19@PyUnicode_@10
$LN18@PyUnicode_@10:
  00064	4d 8b 89 a0 00
	00 00		 mov	 r9, QWORD PTR [r9+160]
$LN19@PyUnicode_@10:

; 2138 :     endptr = (char *)startptr + end * kind;

  0006b	48 63 c1	 movsxd	 rax, ecx
  0006e	48 8b d0	 mov	 rdx, rax

; 2139 :     startptr = (char *)startptr + start * kind;

  00071	49 0f af c2	 imul	 rax, r10
  00075	49 0f af d0	 imul	 rdx, r8
  00079	49 03 d1	 add	 rdx, r9
  0007c	4c 03 c8	 add	 r9, rax

; 2140 :     switch(kind) {

  0007f	ff c9		 dec	 ecx
  00081	74 1c		 je	 SHORT $LN4@PyUnicode_@10
  00083	ff c9		 dec	 ecx
  00085	74 10		 je	 SHORT $LN3@PyUnicode_@10
  00087	83 f9 02	 cmp	 ecx, 2
  0008a	74 03		 je	 SHORT $LN2@PyUnicode_@10

; 2147 :     default:
; 2148 :         assert(0);
; 2149 :         return 0;

  0008c	33 c0		 xor	 eax, eax

; 2150 :     }
; 2151 : }

  0008e	c3		 ret	 0
$LN2@PyUnicode_@10:

; 2145 :     case PyUnicode_4BYTE_KIND:
; 2146 :         return ucs4lib_find_max_char(startptr, endptr);

  0008f	49 8b c9	 mov	 rcx, r9

; 2150 :     }
; 2151 : }

  00092	e9 00 00 00 00	 jmp	 ucs4lib_find_max_char
$LN3@PyUnicode_@10:

; 2143 :     case PyUnicode_2BYTE_KIND:
; 2144 :         return ucs2lib_find_max_char(startptr, endptr);

  00097	49 8b c9	 mov	 rcx, r9

; 2150 :     }
; 2151 : }

  0009a	e9 00 00 00 00	 jmp	 ucs2lib_find_max_char
$LN4@PyUnicode_@10:

; 2141 :     case PyUnicode_1BYTE_KIND:
; 2142 :         return ucs1lib_find_max_char(startptr, endptr);

  0009f	49 8b c9	 mov	 rcx, r9

; 2150 :     }
; 2151 : }

  000a2	e9 00 00 00 00	 jmp	 ucs1lib_find_max_char
_PyUnicode_FindMaxChar ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\find_max_char.h
pdata	SEGMENT
$pdata$unicode_adjust_maxchar DD imagerel unicode_adjust_maxchar
	DD	imagerel unicode_adjust_maxchar+29
	DD	imagerel $unwind$unicode_adjust_maxchar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_adjust_maxchar DD imagerel unicode_adjust_maxchar+29
	DD	imagerel unicode_adjust_maxchar+215
	DD	imagerel $chain$0$unicode_adjust_maxchar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$unicode_adjust_maxchar DD imagerel unicode_adjust_maxchar+215
	DD	imagerel unicode_adjust_maxchar+270
	DD	imagerel $chain$1$unicode_adjust_maxchar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$unicode_adjust_maxchar DD imagerel unicode_adjust_maxchar+270
	DD	imagerel unicode_adjust_maxchar+275
	DD	imagerel $chain$2$unicode_adjust_maxchar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$unicode_adjust_maxchar DD imagerel unicode_adjust_maxchar+275
	DD	imagerel unicode_adjust_maxchar+286
	DD	imagerel $chain$3$unicode_adjust_maxchar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$unicode_adjust_maxchar DD 021H
	DD	imagerel unicode_adjust_maxchar
	DD	imagerel unicode_adjust_maxchar+29
	DD	imagerel $unwind$unicode_adjust_maxchar
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$unicode_adjust_maxchar DD 021H
	DD	imagerel unicode_adjust_maxchar+29
	DD	imagerel unicode_adjust_maxchar+215
	DD	imagerel $chain$0$unicode_adjust_maxchar
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$unicode_adjust_maxchar DD 020521H
	DD	083405H
	DD	imagerel unicode_adjust_maxchar+29
	DD	imagerel unicode_adjust_maxchar+215
	DD	imagerel $chain$0$unicode_adjust_maxchar
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_adjust_maxchar DD 020521H
	DD	095405H
	DD	imagerel unicode_adjust_maxchar
	DD	imagerel unicode_adjust_maxchar+29
	DD	imagerel $unwind$unicode_adjust_maxchar
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_adjust_maxchar DD 040a01H
	DD	0a640aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT unicode_adjust_maxchar
_TEXT	SEGMENT
p_unicode$ = 64
unicode_adjust_maxchar PROC				; COMDAT

; 2158 : {

  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2159 :     PyObject *unicode, *copy;
; 2160 :     Py_UCS4 max_char;
; 2161 :     Py_ssize_t len;
; 2162 :     unsigned int kind;
; 2163 : 
; 2164 :     assert(p_unicode != NULL);
; 2165 :     unicode = *p_unicode;

  0000a	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
  0000d	48 8b f1	 mov	 rsi, rcx

; 2166 :     assert(PyUnicode_IS_READY(unicode));
; 2167 :     if (PyUnicode_IS_ASCII(unicode))

  00010	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00013	a8 40		 test	 al, 64			; 00000040H
  00015	0f 85 f8 00 00
	00		 jne	 $LN10@unicode_ad

; 2168 :         return;
; 2169 : 
; 2170 :     len = PyUnicode_GET_LENGTH(unicode);
; 2171 :     kind = PyUnicode_KIND(unicode);

  0001b	8b d0		 mov	 edx, eax
  0001d	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  00022	48 8b 6f 60	 mov	 rbp, QWORD PTR [rdi+96]
  00026	c1 ea 02	 shr	 edx, 2

; 2172 :     if (kind == PyUnicode_1BYTE_KIND) {
; 2173 :         const Py_UCS1 *u = PyUnicode_1BYTE_DATA(unicode);

  00029	48 8d 8f a0 00
	00 00		 lea	 rcx, QWORD PTR [rdi+160]
  00030	83 e2 07	 and	 edx, 7
  00033	83 fa 01	 cmp	 edx, 1
  00036	75 5f		 jne	 SHORT $LN8@unicode_ad
  00038	a8 20		 test	 al, 32			; 00000020H
  0003a	75 07		 jne	 SHORT $LN15@unicode_ad
  0003c	48 8b 8f a0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+160]
$LN15@unicode_ad:

; 2174 :         max_char = ucs1lib_find_max_char(u, u + len);

  00043	4c 8d 04 29	 lea	 r8, QWORD PTR [rcx+rbp]
  00047	49 8b d0	 mov	 rdx, r8
  0004a	48 83 e2 fc	 and	 rdx, -4
  0004e	49 3b c8	 cmp	 rcx, r8
  00051	73 3d		 jae	 SHORT $LN30@unicode_ad
$LL31@unicode_ad:
  00053	f6 c1 03	 test	 cl, 3
  00056	75 25		 jne	 SHORT $LN25@unicode_ad
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 3b ca	 cmp	 rcx, rdx
  0005e	73 15		 jae	 SHORT $LN27@unicode_ad
$LL28@unicode_ad:
  00060	f7 00 80 80 80
	80		 test	 DWORD PTR [rax], -2139062144 ; 80808080H
  00066	0f 85 a2 00 00
	00		 jne	 $LN41@unicode_ad
  0006c	48 83 c0 04	 add	 rax, 4
  00070	48 3b c2	 cmp	 rax, rdx
  00073	72 eb		 jb	 SHORT $LL28@unicode_ad
$LN27@unicode_ad:
  00075	48 8b c8	 mov	 rcx, rax
  00078	49 3b c0	 cmp	 rax, r8
  0007b	74 13		 je	 SHORT $LN30@unicode_ad
$LN25@unicode_ad:
  0007d	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00080	48 ff c1	 inc	 rcx
  00083	24 80		 and	 al, 128			; 00000080H
  00085	0f 85 83 00 00
	00		 jne	 $LN41@unicode_ad
  0008b	49 3b c8	 cmp	 rcx, r8
  0008e	72 c3		 jb	 SHORT $LL31@unicode_ad
$LN30@unicode_ad:
  00090	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH

; 2175 :         if (max_char >= 128)
; 2176 :             return;
; 2177 :     }
; 2178 :     else if (kind == PyUnicode_2BYTE_KIND) {

  00095	eb 3b		 jmp	 SHORT $LN2@unicode_ad
$LN8@unicode_ad:
  00097	83 fa 02	 cmp	 edx, 2
  0009a	75 1b		 jne	 SHORT $LN5@unicode_ad

; 2179 :         const Py_UCS2 *u = PyUnicode_2BYTE_DATA(unicode);

  0009c	a8 20		 test	 al, 32			; 00000020H
  0009e	75 07		 jne	 SHORT $LN19@unicode_ad
  000a0	48 8b 8f a0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+160]
$LN19@unicode_ad:

; 2180 :         max_char = ucs2lib_find_max_char(u, u + len);

  000a7	48 8d 14 69	 lea	 rdx, QWORD PTR [rcx+rbp*2]
  000ab	e8 00 00 00 00	 call	 ucs2lib_find_max_char

; 2181 :         if (max_char >= 256)

  000b0	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H

; 2182 :             return;
; 2183 :     }
; 2184 :     else {

  000b5	eb 19		 jmp	 SHORT $LN42@unicode_ad
$LN5@unicode_ad:

; 2185 :         const Py_UCS4 *u = PyUnicode_4BYTE_DATA(unicode);

  000b7	a8 20		 test	 al, 32			; 00000020H
  000b9	75 07		 jne	 SHORT $LN23@unicode_ad
  000bb	48 8b 8f a0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+160]
$LN23@unicode_ad:

; 2186 :         assert(kind == PyUnicode_4BYTE_KIND);
; 2187 :         max_char = ucs4lib_find_max_char(u, u + len);

  000c2	48 8d 14 a9	 lea	 rdx, QWORD PTR [rcx+rbp*4]
  000c6	e8 00 00 00 00	 call	 ucs4lib_find_max_char

; 2188 :         if (max_char >= 0x10000)

  000cb	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
$LN42@unicode_ad:
  000d0	73 3c		 jae	 SHORT $LN41@unicode_ad
$LN2@unicode_ad:

; 2189 :             return;
; 2190 :     }
; 2191 :     copy = PyUnicode_New(len, max_char);

  000d2	8b d0		 mov	 edx, eax
  000d4	48 8b cd	 mov	 rcx, rbp
  000d7	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  000dc	e8 00 00 00 00	 call	 PyUnicode_New
  000e1	48 8b d8	 mov	 rbx, rax

; 2192 :     if (copy != NULL)

  000e4	48 85 c0	 test	 rax, rax
  000e7	74 15		 je	 SHORT $LN1@unicode_ad

; 2193 :         _PyUnicode_FastCopyCharacters(copy, 0, unicode, 0, len);

  000e9	45 33 c9	 xor	 r9d, r9d
  000ec	4c 8b c7	 mov	 r8, rdi
  000ef	33 d2		 xor	 edx, edx
  000f1	48 8b c8	 mov	 rcx, rax
  000f4	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  000f9	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters
$LN1@unicode_ad:

; 2194 :     Py_DECREF(unicode);

  000fe	48 8b cf	 mov	 rcx, rdi
  00101	e8 00 00 00 00	 call	 _Py_DecRef

; 2195 :     *p_unicode = copy;

  00106	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  00109	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN41@unicode_ad:
  0010e	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
$LN10@unicode_ad:

; 2196 : }

  00113	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00118	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011c	5f		 pop	 rdi
  0011d	c3		 ret	 0
unicode_adjust_maxchar ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_Copy
EXTRN	_PyErr_BadInternalCall:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_Copy DD imagerel $LN33
	DD	imagerel $LN33+69
	DD	imagerel $unwind$_PyUnicode_Copy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_PyUnicode_Copy DD imagerel $LN33+69
	DD	imagerel $LN33+160
	DD	imagerel $chain$1$_PyUnicode_Copy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_PyUnicode_Copy DD imagerel $LN33+160
	DD	imagerel $LN33+283
	DD	imagerel $chain$3$_PyUnicode_Copy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$_PyUnicode_Copy DD imagerel $LN33+283
	DD	imagerel $LN33+339
	DD	imagerel $chain$5$_PyUnicode_Copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$_PyUnicode_Copy DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel $LN33
	DD	imagerel $LN33+69
	DD	imagerel $unwind$_PyUnicode_Copy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_PyUnicode_Copy DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel $LN33
	DD	imagerel $LN33+69
	DD	imagerel $unwind$_PyUnicode_Copy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_PyUnicode_Copy DD 040e21H
	DD	07740eH
	DD	066405H
	DD	imagerel $LN33
	DD	imagerel $LN33+69
	DD	imagerel $unwind$_PyUnicode_Copy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_Copy DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_Copy
_TEXT	SEGMENT
unicode$ = 48
_PyUnicode_Copy PROC					; COMDAT

; 2200 : {

$LN33:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2201 :     Py_ssize_t length;
; 2202 :     PyObject *copy;
; 2203 : 
; 2204 :     if (!PyUnicode_Check(unicode)) {

  00006	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00017	75 19		 jne	 SHORT $LN11@PyUnicode_@11

; 2205 :         PyErr_BadInternalCall();

  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00020	ba 9d 08 00 00	 mov	 edx, 2205		; 0000089dH
  00025	e8 00 00 00 00	 call	 _PyErr_BadInternalCall
$LN32@PyUnicode_@11:

; 2206 :         return NULL;

  0002a	33 c0		 xor	 eax, eax

; 2221 : }

  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5b		 pop	 rbx
  00031	c3		 ret	 0
$LN11@PyUnicode_@11:

; 2207 :     }
; 2208 :     if (PyUnicode_READY(unicode) == -1)

  00032	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00036	75 0a		 jne	 SHORT $LN10@PyUnicode_@11
  00038	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0003d	83 f8 ff	 cmp	 eax, -1

; 2209 :         return NULL;

  00040	74 e8		 je	 SHORT $LN32@PyUnicode_@11
$LN10@PyUnicode_@11:

; 2210 : 
; 2211 :     length = PyUnicode_GET_LENGTH(unicode);
; 2212 :     copy = PyUnicode_New(length, PyUnicode_MAX_CHAR_VALUE(unicode));

  00042	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00045	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0004a	48 8b 73 60	 mov	 rsi, QWORD PTR [rbx+96]
  0004e	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00053	a8 40		 test	 al, 64			; 00000040H
  00055	74 07		 je	 SHORT $LN18@PyUnicode_@11
  00057	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  0005c	eb 22		 jmp	 SHORT $LN17@PyUnicode_@11
$LN18@PyUnicode_@11:
  0005e	c1 e8 02	 shr	 eax, 2
  00061	83 e0 07	 and	 eax, 7
  00064	83 f8 01	 cmp	 eax, 1
  00067	75 07		 jne	 SHORT $LN16@PyUnicode_@11
  00069	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  0006e	eb 10		 jmp	 SHORT $LN17@PyUnicode_@11
$LN16@PyUnicode_@11:
  00070	ba ff ff 10 00	 mov	 edx, 1114111		; 0010ffffH
  00075	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0007a	83 f8 02	 cmp	 eax, 2
  0007d	0f 44 d1	 cmove	 edx, ecx
$LN17@PyUnicode_@11:
  00080	48 8b ce	 mov	 rcx, rsi
  00083	e8 00 00 00 00	 call	 PyUnicode_New
  00088	48 8b f8	 mov	 rdi, rax

; 2213 :     if (!copy)

  0008b	48 85 c0	 test	 rax, rax
  0008e	75 10		 jne	 SHORT $LN8@PyUnicode_@11
  00090	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00095	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 2221 : }

  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5b		 pop	 rbx
  0009f	c3		 ret	 0
$LN8@PyUnicode_@11:

; 2214 :         return NULL;
; 2215 :     assert(PyUnicode_KIND(copy) == PyUnicode_KIND(unicode));
; 2216 : 
; 2217 :     Py_MEMCPY(PyUnicode_DATA(copy), PyUnicode_DATA(unicode),
; 2218 :               length * PyUnicode_KIND(unicode));

  000a0	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  000a3	8b 4f 70	 mov	 ecx, DWORD PTR [rdi+112]
  000a6	8b d0		 mov	 edx, eax
  000a8	48 c1 ea 02	 shr	 rdx, 2
  000ac	83 e2 07	 and	 edx, 7
  000af	48 0f af d6	 imul	 rdx, rsi
  000b3	f6 c1 20	 test	 cl, 32			; 00000020H
  000b6	74 17		 je	 SHORT $LN22@PyUnicode_@11
  000b8	f6 c1 40	 test	 cl, 64			; 00000040H
  000bb	74 09		 je	 SHORT $LN20@PyUnicode_@11
  000bd	48 8d 8f 80 00
	00 00		 lea	 rcx, QWORD PTR [rdi+128]
  000c4	eb 10		 jmp	 SHORT $LN23@PyUnicode_@11
$LN20@PyUnicode_@11:
  000c6	48 8d 8f a0 00
	00 00		 lea	 rcx, QWORD PTR [rdi+160]
  000cd	eb 07		 jmp	 SHORT $LN23@PyUnicode_@11
$LN22@PyUnicode_@11:
  000cf	48 8b 8f a0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+160]
$LN23@PyUnicode_@11:
  000d6	a8 20		 test	 al, 32			; 00000020H
  000d8	74 16		 je	 SHORT $LN26@PyUnicode_@11
  000da	a8 40		 test	 al, 64			; 00000040H
  000dc	74 09		 je	 SHORT $LN24@PyUnicode_@11
  000de	4c 8d 8b 80 00
	00 00		 lea	 r9, QWORD PTR [rbx+128]
  000e5	eb 10		 jmp	 SHORT $LN27@PyUnicode_@11
$LN24@PyUnicode_@11:
  000e7	4c 8d 8b a0 00
	00 00		 lea	 r9, QWORD PTR [rbx+160]
  000ee	eb 07		 jmp	 SHORT $LN27@PyUnicode_@11
$LN26@PyUnicode_@11:
  000f0	4c 8b 8b a0 00
	00 00		 mov	 r9, QWORD PTR [rbx+160]
$LN27@PyUnicode_@11:
  000f7	48 83 fa 10	 cmp	 rdx, 16
  000fb	72 1e		 jb	 SHORT $LN5@PyUnicode_@11
  000fd	4c 8b c2	 mov	 r8, rdx
  00100	49 8b d1	 mov	 rdx, r9
  00103	e8 00 00 00 00	 call	 memcpy
  00108	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 2219 :     assert(_PyUnicode_CheckConsistency(copy, 1));
; 2220 :     return copy;

  0010d	48 8b c7	 mov	 rax, rdi
  00110	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 2221 : }

  00115	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00119	5b		 pop	 rbx
  0011a	c3		 ret	 0
$LN5@PyUnicode_@11:

; 2214 :         return NULL;
; 2215 :     assert(PyUnicode_KIND(copy) == PyUnicode_KIND(unicode));
; 2216 : 
; 2217 :     Py_MEMCPY(PyUnicode_DATA(copy), PyUnicode_DATA(unicode),
; 2218 :               length * PyUnicode_KIND(unicode));

  0011b	48 85 d2	 test	 rdx, rdx
  0011e	74 20		 je	 SHORT $LN7@PyUnicode_@11
  00120	4c 2b c9	 sub	 r9, rcx
  00123	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL3@PyUnicode_@11:
  00130	41 0f b6 04 09	 movzx	 eax, BYTE PTR [r9+rcx]
  00135	48 ff c1	 inc	 rcx
  00138	48 ff ca	 dec	 rdx
  0013b	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0013e	75 f0		 jne	 SHORT $LL3@PyUnicode_@11
$LN7@PyUnicode_@11:
  00140	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 2219 :     assert(_PyUnicode_CheckConsistency(copy, 1));
; 2220 :     return copy;

  00145	48 8b c7	 mov	 rax, rdi
  00148	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 2221 : }

  0014d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00151	5b		 pop	 rbx
  00152	c3		 ret	 0
_PyUnicode_Copy ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@ENJAGGLJ@invalid?5widening?5attempt?$AA@ ; `string'
PUBLIC	_PyUnicode_AsKind
EXTRN	PyMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_AsKind DD imagerel $LN76
	DD	imagerel $LN76+780
	DD	imagerel $unwind$_PyUnicode_AsKind
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_AsKind DD 083a01H
	DD	07743aH
	DD	065431H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT ??_C@_0BJ@ENJAGGLJ@invalid?5widening?5attempt?$AA@
CONST	SEGMENT
??_C@_0BJ@ENJAGGLJ@invalid?5widening?5attempt?$AA@ DB 'invalid widening a'
	DB	'ttempt', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyUnicode_AsKind
_TEXT	SEGMENT
s$ = 48
kind$ = 56
_PyUnicode_AsKind PROC					; COMDAT

; 2229 : {

$LN76:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2230 :     Py_ssize_t len;
; 2231 :     void *result;
; 2232 :     unsigned int skind;
; 2233 : 
; 2234 :     if (PyUnicode_READY(s) == -1)

  0000a	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000e	8b f2		 mov	 esi, edx
  00010	48 8b d9	 mov	 rbx, rcx
  00013	75 17		 jne	 SHORT $LN32@PyUnicode_@12
  00015	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0001a	83 f8 ff	 cmp	 eax, -1
  0001d	75 0d		 jne	 SHORT $LN32@PyUnicode_@12

; 2235 :         return NULL;

  0001f	33 c0		 xor	 eax, eax

; 2280 : }

  00021	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5e		 pop	 rsi
  0002b	c3		 ret	 0
$LN32@PyUnicode_@12:
  0002c	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp

; 2236 : 
; 2237 :     len = PyUnicode_GET_LENGTH(s);

  00031	48 8b 6b 60	 mov	 rbp, QWORD PTR [rbx+96]
  00035	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 2238 :     skind = PyUnicode_KIND(s);

  0003a	8b 7b 70	 mov	 edi, DWORD PTR [rbx+112]
  0003d	c1 ef 02	 shr	 edi, 2
  00040	83 e7 07	 and	 edi, 7

; 2239 :     if (skind >= kind) {

  00043	3b fe		 cmp	 edi, esi
  00045	72 1a		 jb	 SHORT $LN31@PyUnicode_@12

; 2240 :         PyErr_SetString(PyExc_SystemError, "invalid widening attempt");

  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@ENJAGGLJ@invalid?5widening?5attempt?$AA@
  00055	e8 00 00 00 00	 call	 PyErr_SetString

; 2241 :         return NULL;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 96 02 00 00	 jmp	 $LN74@PyUnicode_@12
$LN31@PyUnicode_@12:

; 2242 :     }
; 2243 :     switch (kind) {

  00061	83 fe 02	 cmp	 esi, 2
  00064	0f 84 bd 01 00
	00		 je	 $LN28@PyUnicode_@12
  0006a	83 fe 04	 cmp	 esi, 4
  0006d	74 1a		 je	 SHORT $LN19@PyUnicode_@12

; 2275 :     default:
; 2276 :         break;
; 2277 :     }
; 2278 :     PyErr_SetString(PyExc_SystemError, "invalid kind");

  0006f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@HGIODDJP@invalid?5kind?$AA@
  0007d	e8 00 00 00 00	 call	 PyErr_SetString

; 2279 :     return NULL;

  00082	33 c0		 xor	 eax, eax
  00084	e9 6e 02 00 00	 jmp	 $LN74@PyUnicode_@12
$LN19@PyUnicode_@12:

; 2255 :     case PyUnicode_4BYTE_KIND:
; 2256 :         result = PyMem_Malloc(len * sizeof(Py_UCS4));

  00089	48 8d 0c ad 00
	00 00 00	 lea	 rcx, QWORD PTR [rbp*4]
  00091	e8 00 00 00 00	 call	 PyMem_Malloc
  00096	4c 8b d8	 mov	 r11, rax

; 2257 :         if (!result)

  00099	48 85 c0	 test	 rax, rax

; 2258 :             return PyErr_NoMemory();

  0009c	0f 84 97 01 00
	00		 je	 $LN75@PyUnicode_@12

; 2259 :         if (skind == PyUnicode_2BYTE_KIND) {
; 2260 :             _PyUnicode_CONVERT_BYTES(
; 2261 :                 Py_UCS2, Py_UCS4,
; 2262 :                 PyUnicode_2BYTE_DATA(s),
; 2263 :                 PyUnicode_2BYTE_DATA(s) + len,
; 2264 :                 result);

  000a2	44 8b 43 70	 mov	 r8d, DWORD PTR [rbx+112]
  000a6	48 8b d0	 mov	 rdx, rax
  000a9	41 8b c0	 mov	 eax, r8d
  000ac	c1 e8 05	 shr	 eax, 5
  000af	83 ff 02	 cmp	 edi, 2
  000b2	0f 85 b1 00 00
	00		 jne	 $LN8@PyUnicode_@12
  000b8	83 e0 01	 and	 eax, 1
  000bb	74 18		 je	 SHORT $LN47@PyUnicode_@12
  000bd	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  000c1	74 09		 je	 SHORT $LN45@PyUnicode_@12
  000c3	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  000ca	eb 10		 jmp	 SHORT $LN48@PyUnicode_@12
$LN45@PyUnicode_@12:
  000cc	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  000d3	eb 07		 jmp	 SHORT $LN48@PyUnicode_@12
$LN47@PyUnicode_@12:
  000d5	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
$LN48@PyUnicode_@12:
  000dc	85 c0		 test	 eax, eax
  000de	74 15		 je	 SHORT $LN51@PyUnicode_@12
  000e0	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  000e4	74 06		 je	 SHORT $LN49@PyUnicode_@12
  000e6	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  000ea	eb 10		 jmp	 SHORT $LN52@PyUnicode_@12
$LN49@PyUnicode_@12:
  000ec	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  000f3	eb 07		 jmp	 SHORT $LN52@PyUnicode_@12
$LN51@PyUnicode_@12:
  000f5	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
$LN52@PyUnicode_@12:
  000fc	4c 8d 04 6b	 lea	 r8, QWORD PTR [rbx+rbp*2]
  00100	49 8b c0	 mov	 rax, r8
  00103	48 2b c1	 sub	 rax, rcx
  00106	48 d1 f8	 sar	 rax, 1
  00109	48 83 e0 fc	 and	 rax, -4
  0010d	4c 8d 0c 41	 lea	 r9, QWORD PTR [rcx+rax*2]
  00111	49 3b c9	 cmp	 rcx, r9
  00114	73 32		 jae	 SHORT $LN62@PyUnicode_@12
  00116	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL13@PyUnicode_@12:
  00120	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00123	48 83 c1 08	 add	 rcx, 8
  00127	48 83 c2 10	 add	 rdx, 16
  0012b	89 42 f0	 mov	 DWORD PTR [rdx-16], eax
  0012e	0f b7 41 fa	 movzx	 eax, WORD PTR [rcx-6]
  00132	89 42 f4	 mov	 DWORD PTR [rdx-12], eax
  00135	0f b7 41 fc	 movzx	 eax, WORD PTR [rcx-4]
  00139	89 42 f8	 mov	 DWORD PTR [rdx-8], eax
  0013c	0f b7 41 fe	 movzx	 eax, WORD PTR [rcx-2]
  00140	89 42 fc	 mov	 DWORD PTR [rdx-4], eax
  00143	49 3b c9	 cmp	 rcx, r9
  00146	72 d8		 jb	 SHORT $LL13@PyUnicode_@12
$LN62@PyUnicode_@12:
  00148	49 3b c8	 cmp	 rcx, r8
  0014b	0f 83 a3 01 00
	00		 jae	 $LN25@PyUnicode_@12
$LL11@PyUnicode_@12:
  00151	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00154	48 83 c1 02	 add	 rcx, 2
  00158	48 83 c2 04	 add	 rdx, 4
  0015c	89 42 fc	 mov	 DWORD PTR [rdx-4], eax
  0015f	49 3b c8	 cmp	 rcx, r8
  00162	72 ed		 jb	 SHORT $LL11@PyUnicode_@12

; 2265 :         }
; 2266 :         else {

  00164	e9 8b 01 00 00	 jmp	 $LN25@PyUnicode_@12
$LN8@PyUnicode_@12:

; 2267 :             assert(skind == PyUnicode_1BYTE_KIND);
; 2268 :             _PyUnicode_CONVERT_BYTES(
; 2269 :                 Py_UCS1, Py_UCS4,
; 2270 :                 PyUnicode_1BYTE_DATA(s),
; 2271 :                 PyUnicode_1BYTE_DATA(s) + len,
; 2272 :                 result);

  00169	83 e0 01	 and	 eax, 1
  0016c	74 18		 je	 SHORT $LN55@PyUnicode_@12
  0016e	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00172	74 09		 je	 SHORT $LN53@PyUnicode_@12
  00174	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  0017b	eb 10		 jmp	 SHORT $LN56@PyUnicode_@12
$LN53@PyUnicode_@12:
  0017d	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  00184	eb 07		 jmp	 SHORT $LN56@PyUnicode_@12
$LN55@PyUnicode_@12:
  00186	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
$LN56@PyUnicode_@12:
  0018d	85 c0		 test	 eax, eax
  0018f	74 15		 je	 SHORT $LN59@PyUnicode_@12
  00191	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00195	74 06		 je	 SHORT $LN57@PyUnicode_@12
  00197	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  0019b	eb 10		 jmp	 SHORT $LN60@PyUnicode_@12
$LN57@PyUnicode_@12:
  0019d	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  001a4	eb 07		 jmp	 SHORT $LN60@PyUnicode_@12
$LN59@PyUnicode_@12:
  001a6	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
$LN60@PyUnicode_@12:
  001ad	4c 8d 04 2b	 lea	 r8, QWORD PTR [rbx+rbp]
  001b1	4d 8b c8	 mov	 r9, r8
  001b4	4c 2b c9	 sub	 r9, rcx
  001b7	49 83 e1 fc	 and	 r9, -4
  001bb	4c 03 c9	 add	 r9, rcx
  001be	49 3b c9	 cmp	 rcx, r9
  001c1	73 35		 jae	 SHORT $LN64@PyUnicode_@12
  001c3	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL5@PyUnicode_@12:
  001d0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  001d3	48 83 c1 04	 add	 rcx, 4
  001d7	48 83 c2 10	 add	 rdx, 16
  001db	89 42 f0	 mov	 DWORD PTR [rdx-16], eax
  001de	0f b6 41 fd	 movzx	 eax, BYTE PTR [rcx-3]
  001e2	89 42 f4	 mov	 DWORD PTR [rdx-12], eax
  001e5	0f b6 41 fe	 movzx	 eax, BYTE PTR [rcx-2]
  001e9	89 42 f8	 mov	 DWORD PTR [rdx-8], eax
  001ec	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]
  001f0	89 42 fc	 mov	 DWORD PTR [rdx-4], eax
  001f3	49 3b c9	 cmp	 rcx, r9
  001f6	72 d8		 jb	 SHORT $LL5@PyUnicode_@12
$LN64@PyUnicode_@12:
  001f8	49 3b c8	 cmp	 rcx, r8
  001fb	0f 83 f3 00 00
	00		 jae	 $LN25@PyUnicode_@12
  00201	66 66 66 66 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL3@PyUnicode_@12:
  00210	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00213	48 ff c1	 inc	 rcx
  00216	48 83 c2 04	 add	 rdx, 4
  0021a	89 42 fc	 mov	 DWORD PTR [rdx-4], eax
  0021d	49 3b c8	 cmp	 rcx, r8
  00220	72 ee		 jb	 SHORT $LL3@PyUnicode_@12

; 2273 :         }
; 2274 :         return result;

  00222	e9 cd 00 00 00	 jmp	 $LN25@PyUnicode_@12
$LN28@PyUnicode_@12:

; 2244 :     case PyUnicode_2BYTE_KIND:
; 2245 :         result = PyMem_Malloc(len * sizeof(Py_UCS2));

  00227	48 8d 4c 2d 00	 lea	 rcx, QWORD PTR [rbp+rbp]
  0022c	e8 00 00 00 00	 call	 PyMem_Malloc
  00231	4c 8b d8	 mov	 r11, rax

; 2246 :         if (!result)

  00234	48 85 c0	 test	 rax, rax
  00237	75 0a		 jne	 SHORT $LN26@PyUnicode_@12
$LN75@PyUnicode_@12:

; 2247 :             return PyErr_NoMemory();

  00239	e8 00 00 00 00	 call	 PyErr_NoMemory
  0023e	e9 b4 00 00 00	 jmp	 $LN74@PyUnicode_@12
$LN26@PyUnicode_@12:

; 2248 :         assert(skind == PyUnicode_1BYTE_KIND);
; 2249 :         _PyUnicode_CONVERT_BYTES(
; 2250 :             Py_UCS1, Py_UCS2,
; 2251 :             PyUnicode_1BYTE_DATA(s),
; 2252 :             PyUnicode_1BYTE_DATA(s) + len,
; 2253 :             result);

  00243	44 8b 43 70	 mov	 r8d, DWORD PTR [rbx+112]
  00247	48 8b d0	 mov	 rdx, rax
  0024a	41 8b c0	 mov	 eax, r8d
  0024d	c1 e8 05	 shr	 eax, 5
  00250	83 e0 01	 and	 eax, 1
  00253	74 18		 je	 SHORT $LN39@PyUnicode_@12
  00255	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00259	74 09		 je	 SHORT $LN37@PyUnicode_@12
  0025b	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  00262	eb 10		 jmp	 SHORT $LN40@PyUnicode_@12
$LN37@PyUnicode_@12:
  00264	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  0026b	eb 07		 jmp	 SHORT $LN40@PyUnicode_@12
$LN39@PyUnicode_@12:
  0026d	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
$LN40@PyUnicode_@12:
  00274	85 c0		 test	 eax, eax
  00276	74 15		 je	 SHORT $LN43@PyUnicode_@12
  00278	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  0027c	74 06		 je	 SHORT $LN41@PyUnicode_@12
  0027e	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  00282	eb 10		 jmp	 SHORT $LN44@PyUnicode_@12
$LN41@PyUnicode_@12:
  00284	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  0028b	eb 07		 jmp	 SHORT $LN44@PyUnicode_@12
$LN43@PyUnicode_@12:
  0028d	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
$LN44@PyUnicode_@12:
  00294	4c 8d 04 2b	 lea	 r8, QWORD PTR [rbx+rbp]
  00298	4d 8b c8	 mov	 r9, r8
  0029b	4c 2b c9	 sub	 r9, rcx
  0029e	49 83 e1 fc	 and	 r9, -4
  002a2	4c 03 c9	 add	 r9, rcx
  002a5	49 3b c9	 cmp	 rcx, r9
  002a8	73 32		 jae	 SHORT $LN66@PyUnicode_@12
  002aa	66 0f 1f 44 00
	00		 npad	 6
$LL23@PyUnicode_@12:
  002b0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  002b3	48 83 c1 04	 add	 rcx, 4
  002b7	48 83 c2 08	 add	 rdx, 8
  002bb	66 89 42 f8	 mov	 WORD PTR [rdx-8], ax
  002bf	0f b6 41 fd	 movzx	 eax, BYTE PTR [rcx-3]
  002c3	66 89 42 fa	 mov	 WORD PTR [rdx-6], ax
  002c7	0f b6 41 fe	 movzx	 eax, BYTE PTR [rcx-2]
  002cb	66 89 42 fc	 mov	 WORD PTR [rdx-4], ax
  002cf	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]
  002d3	66 89 42 fe	 mov	 WORD PTR [rdx-2], ax
  002d7	49 3b c9	 cmp	 rcx, r9
  002da	72 d4		 jb	 SHORT $LL23@PyUnicode_@12
$LN66@PyUnicode_@12:
  002dc	49 3b c8	 cmp	 rcx, r8
  002df	73 13		 jae	 SHORT $LN25@PyUnicode_@12
$LL21@PyUnicode_@12:
  002e1	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  002e4	48 ff c1	 inc	 rcx
  002e7	48 83 c2 02	 add	 rdx, 2
  002eb	66 89 42 fe	 mov	 WORD PTR [rdx-2], ax
  002ef	49 3b c8	 cmp	 rcx, r8
  002f2	72 ed		 jb	 SHORT $LL21@PyUnicode_@12
$LN25@PyUnicode_@12:

; 2254 :         return result;

  002f4	49 8b c3	 mov	 rax, r11
$LN74@PyUnicode_@12:
  002f7	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  002fc	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 2280 : }

  00301	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00306	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0030a	5e		 pop	 rsi
  0030b	c3		 ret	 0
_PyUnicode_AsKind ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@NCANGEAO@string?5is?5longer?5than?5the?5buffer@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$as_ucs4 DD imagerel as_ucs4
	DD	imagerel as_ucs4+568
	DD	imagerel $unwind$as_ucs4
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$as_ucs4 DD 0a4801H
	DD	096448H
	DD	083443H
	DD	0a540eH
	DD	0d00a320eH
	DD	07006c008H
xdata	ENDS
;	COMDAT ??_C@_0CB@NCANGEAO@string?5is?5longer?5than?5the?5buffer@
CONST	SEGMENT
??_C@_0CB@NCANGEAO@string?5is?5longer?5than?5the?5buffer@ DB 'string is l'
	DB	'onger than the buffer', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT as_ucs4
_TEXT	SEGMENT
string$ = 64
target$ = 72
targetsize$ = 80
copy_null$ = 88
as_ucs4	PROC						; COMDAT

; 2285 : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	57		 push	 rdi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2286 :     int kind;
; 2287 :     void *data;
; 2288 :     Py_ssize_t len, targetlen;
; 2289 :     if (PyUnicode_READY(string) == -1)

  0000e	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00012	45 8b e9	 mov	 r13d, r9d
  00015	4d 8b e0	 mov	 r12, r8
  00018	48 8b ea	 mov	 rbp, rdx
  0001b	48 8b f9	 mov	 rdi, rcx
  0001e	75 1b		 jne	 SHORT $LN35@as_ucs4
  00020	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00025	83 f8 ff	 cmp	 eax, -1
  00028	75 11		 jne	 SHORT $LN35@as_ucs4

; 2290 :         return NULL;

  0002a	33 c0		 xor	 eax, eax

; 2332 : }

  0002c	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	41 5d		 pop	 r13
  00037	41 5c		 pop	 r12
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
$LN35@as_ucs4:

; 2291 :     kind = PyUnicode_KIND(string);

  0003b	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  0003e	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00043	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00048	8b f0		 mov	 esi, eax
  0004a	c1 ee 02	 shr	 esi, 2
  0004d	83 e6 07	 and	 esi, 7

; 2292 :     data = PyUnicode_DATA(string);

  00050	a8 20		 test	 al, 32			; 00000020H
  00052	74 16		 je	 SHORT $LN42@as_ucs4
  00054	a8 40		 test	 al, 64			; 00000040H
  00056	74 09		 je	 SHORT $LN40@as_ucs4
  00058	48 8d 9f 80 00
	00 00		 lea	 rbx, QWORD PTR [rdi+128]
  0005f	eb 10		 jmp	 SHORT $LN43@as_ucs4
$LN40@as_ucs4:
  00061	48 8d 9f a0 00
	00 00		 lea	 rbx, QWORD PTR [rdi+160]
  00068	eb 07		 jmp	 SHORT $LN43@as_ucs4
$LN42@as_ucs4:
  0006a	48 8b 9f a0 00
	00 00		 mov	 rbx, QWORD PTR [rdi+160]
$LN43@as_ucs4:

; 2293 :     len = PyUnicode_GET_LENGTH(string);

  00071	48 8b 7f 60	 mov	 rdi, QWORD PTR [rdi+96]

; 2294 :     targetlen = len;

  00075	48 8b c7	 mov	 rax, rdi

; 2295 :     if (copy_null)

  00078	45 85 ed	 test	 r13d, r13d
  0007b	74 04		 je	 SHORT $LN34@as_ucs4

; 2296 :         targetlen++;

  0007d	48 8d 47 01	 lea	 rax, QWORD PTR [rdi+1]
$LN34@as_ucs4:

; 2297 :     if (!target) {

  00081	48 85 ed	 test	 rbp, rbp
  00084	75 30		 jne	 SHORT $LN33@as_ucs4

; 2298 :         if (PY_SSIZE_T_MAX / sizeof(Py_UCS4) < targetlen) {

  00086	48 b9 ff ff ff
	ff ff ff ff 1f	 mov	 rcx, 2305843009213693951 ; 1fffffffffffffffH
  00090	48 3b c1	 cmp	 rax, rcx

; 2299 :             PyErr_NoMemory();
; 2300 :             return NULL;

  00093	77 15		 ja	 SHORT $LN56@as_ucs4

; 2301 :         }
; 2302 :         target = PyMem_Malloc(targetlen * sizeof(Py_UCS4));

  00095	48 8d 0c 85 00
	00 00 00	 lea	 rcx, QWORD PTR [rax*4]
  0009d	e8 00 00 00 00	 call	 PyMem_Malloc
  000a2	48 8b e8	 mov	 rbp, rax

; 2303 :         if (!target) {

  000a5	48 85 c0	 test	 rax, rax
  000a8	75 3c		 jne	 SHORT $LN29@as_ucs4
$LN56@as_ucs4:

; 2304 :             PyErr_NoMemory();

  000aa	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2305 :             return NULL;

  000af	33 c0		 xor	 eax, eax
  000b1	e9 69 01 00 00	 jmp	 $LN55@as_ucs4
$LN33@as_ucs4:

; 2306 :         }
; 2307 :     }
; 2308 :     else {
; 2309 :         if (targetsize < targetlen) {

  000b6	4c 3b e0	 cmp	 r12, rax
  000b9	7d 2b		 jge	 SHORT $LN29@as_ucs4

; 2310 :             PyErr_Format(PyExc_SystemError,
; 2311 :                          "string is longer than the buffer");

  000bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@NCANGEAO@string?5is?5longer?5than?5the?5buffer@
  000c9	e8 00 00 00 00	 call	 PyErr_Format

; 2312 :             if (copy_null && 0 < targetsize)

  000ce	45 85 ed	 test	 r13d, r13d
  000d1	74 0c		 je	 SHORT $LN28@as_ucs4
  000d3	4d 85 e4	 test	 r12, r12
  000d6	7e 07		 jle	 SHORT $LN28@as_ucs4

; 2313 :                 target[0] = 0;

  000d8	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [rbp], 0
$LN28@as_ucs4:

; 2314 :             return NULL;

  000df	33 c0		 xor	 eax, eax
  000e1	e9 39 01 00 00	 jmp	 $LN55@as_ucs4
$LN29@as_ucs4:

; 2315 :         }
; 2316 :     }
; 2317 :     if (kind == PyUnicode_1BYTE_KIND) {

  000e6	83 fe 01	 cmp	 esi, 1
  000e9	75 7c		 jne	 SHORT $LN27@as_ucs4

; 2318 :         Py_UCS1 *start = (Py_UCS1 *) data;
; 2319 :         _PyUnicode_CONVERT_BYTES(Py_UCS1, Py_UCS4, start, start + len, target);

  000eb	48 8d 14 1f	 lea	 rdx, QWORD PTR [rdi+rbx]
  000ef	48 8b cd	 mov	 rcx, rbp
  000f2	4c 8b c2	 mov	 r8, rdx
  000f5	4c 2b c3	 sub	 r8, rbx
  000f8	49 83 e0 fc	 and	 r8, -4
  000fc	4c 03 c3	 add	 r8, rbx
  000ff	49 3b d8	 cmp	 rbx, r8
  00102	73 34		 jae	 SHORT $LN45@as_ucs4
  00104	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL23@as_ucs4:
  00110	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00113	48 83 c3 04	 add	 rbx, 4
  00117	48 83 c1 10	 add	 rcx, 16
  0011b	89 41 f0	 mov	 DWORD PTR [rcx-16], eax
  0011e	0f b6 43 fd	 movzx	 eax, BYTE PTR [rbx-3]
  00122	89 41 f4	 mov	 DWORD PTR [rcx-12], eax
  00125	0f b6 43 fe	 movzx	 eax, BYTE PTR [rbx-2]
  00129	89 41 f8	 mov	 DWORD PTR [rcx-8], eax
  0012c	0f b6 43 ff	 movzx	 eax, BYTE PTR [rbx-1]
  00130	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  00133	49 3b d8	 cmp	 rbx, r8
  00136	72 d8		 jb	 SHORT $LL23@as_ucs4
$LN45@as_ucs4:
  00138	48 3b da	 cmp	 rbx, rdx
  0013b	0f 83 ce 00 00
	00		 jae	 $LN7@as_ucs4
  00141	66 66 66 66 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL21@as_ucs4:
  00150	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00153	48 ff c3	 inc	 rbx
  00156	48 83 c1 04	 add	 rcx, 4
  0015a	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  0015d	48 3b da	 cmp	 rbx, rdx
  00160	72 ee		 jb	 SHORT $LL21@as_ucs4

; 2320 :     }
; 2321 :     else if (kind == PyUnicode_2BYTE_KIND) {

  00162	e9 a8 00 00 00	 jmp	 $LN7@as_ucs4
$LN27@as_ucs4:
  00167	83 fe 02	 cmp	 esi, 2
  0016a	75 69		 jne	 SHORT $LN9@as_ucs4

; 2322 :         Py_UCS2 *start = (Py_UCS2 *) data;
; 2323 :         _PyUnicode_CONVERT_BYTES(Py_UCS2, Py_UCS4, start, start + len, target);

  0016c	48 8d 14 7b	 lea	 rdx, QWORD PTR [rbx+rdi*2]
  00170	48 8b cd	 mov	 rcx, rbp
  00173	48 8b c2	 mov	 rax, rdx
  00176	48 2b c3	 sub	 rax, rbx
  00179	48 d1 f8	 sar	 rax, 1
  0017c	48 83 e0 fc	 and	 rax, -4
  00180	4c 8d 04 43	 lea	 r8, QWORD PTR [rbx+rax*2]
  00184	49 3b d8	 cmp	 rbx, r8
  00187	73 2f		 jae	 SHORT $LN47@as_ucs4
  00189	0f 1f 80 00 00
	00 00		 npad	 7
$LL14@as_ucs4:
  00190	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00193	48 83 c3 08	 add	 rbx, 8
  00197	48 83 c1 10	 add	 rcx, 16
  0019b	89 41 f0	 mov	 DWORD PTR [rcx-16], eax
  0019e	0f b7 43 fa	 movzx	 eax, WORD PTR [rbx-6]
  001a2	89 41 f4	 mov	 DWORD PTR [rcx-12], eax
  001a5	0f b7 43 fc	 movzx	 eax, WORD PTR [rbx-4]
  001a9	89 41 f8	 mov	 DWORD PTR [rcx-8], eax
  001ac	0f b7 43 fe	 movzx	 eax, WORD PTR [rbx-2]
  001b0	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  001b3	49 3b d8	 cmp	 rbx, r8
  001b6	72 d8		 jb	 SHORT $LL14@as_ucs4
$LN47@as_ucs4:
  001b8	48 3b da	 cmp	 rbx, rdx
  001bb	73 52		 jae	 SHORT $LN7@as_ucs4
  001bd	0f 1f 00	 npad	 3
$LL12@as_ucs4:
  001c0	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  001c3	48 83 c3 02	 add	 rbx, 2
  001c7	48 83 c1 04	 add	 rcx, 4
  001cb	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  001ce	48 3b da	 cmp	 rbx, rdx
  001d1	72 ed		 jb	 SHORT $LL12@as_ucs4

; 2324 :     }
; 2325 :     else {

  001d3	eb 3a		 jmp	 SHORT $LN7@as_ucs4
$LN9@as_ucs4:

; 2326 :         assert(kind == PyUnicode_4BYTE_KIND);
; 2327 :         Py_MEMCPY(target, data, len * sizeof(Py_UCS4));

  001d5	48 8d 14 bd 00
	00 00 00	 lea	 rdx, QWORD PTR [rdi*4]
  001dd	48 83 fa 10	 cmp	 rdx, 16
  001e1	72 10		 jb	 SHORT $LN6@as_ucs4
  001e3	4c 8b c2	 mov	 r8, rdx
  001e6	48 8b cd	 mov	 rcx, rbp
  001e9	48 8b d3	 mov	 rdx, rbx
  001ec	e8 00 00 00 00	 call	 memcpy
  001f1	eb 1c		 jmp	 SHORT $LN7@as_ucs4
$LN6@as_ucs4:
  001f3	48 85 d2	 test	 rdx, rdx
  001f6	74 17		 je	 SHORT $LN7@as_ucs4
  001f8	48 8b cd	 mov	 rcx, rbp
  001fb	48 2b dd	 sub	 rbx, rbp
  001fe	66 90		 npad	 2
$LL4@as_ucs4:
  00200	0f b6 04 0b	 movzx	 eax, BYTE PTR [rbx+rcx]
  00204	48 ff c1	 inc	 rcx
  00207	48 ff ca	 dec	 rdx
  0020a	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0020d	75 f1		 jne	 SHORT $LL4@as_ucs4
$LN7@as_ucs4:

; 2328 :     }
; 2329 :     if (copy_null)

  0020f	45 85 ed	 test	 r13d, r13d
  00212	74 08		 je	 SHORT $LN1@as_ucs4

; 2330 :         target[len] = 0;

  00214	c7 44 bd 00 00
	00 00 00	 mov	 DWORD PTR [rbp+rdi*4], 0
$LN1@as_ucs4:

; 2331 :     return target;

  0021c	48 8b c5	 mov	 rax, rbp
$LN55@as_ucs4:
  0021f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00224	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 2332 : }

  00229	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0022e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00232	41 5d		 pop	 r13
  00234	41 5c		 pop	 r12
  00236	5f		 pop	 rdi
  00237	c3		 ret	 0
as_ucs4	ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsUCS4
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_AsUCS4 DD imagerel $LN5
	DD	imagerel $LN5+47
	DD	imagerel $unwind$PyUnicode_AsUCS4
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_AsUCS4 DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_AsUCS4
_TEXT	SEGMENT
string$ = 48
target$ = 56
targetsize$ = 64
copy_null$ = 72
PyUnicode_AsUCS4 PROC					; COMDAT

; 2337 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2338 :     if (target == NULL || targetsize < 0) {

  00004	48 85 d2	 test	 rdx, rdx
  00007	74 0e		 je	 SHORT $LN1@PyUnicode_@13
  00009	4d 85 c0	 test	 r8, r8
  0000c	78 09		 js	 SHORT $LN1@PyUnicode_@13

; 2341 :     }
; 2342 :     return as_ucs4(string, target, targetsize, copy_null);
; 2343 : }

  0000e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00012	e9 00 00 00 00	 jmp	 as_ucs4
$LN1@PyUnicode_@13:

; 2339 :         PyErr_BadInternalCall();

  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  0001e	ba 23 09 00 00	 mov	 edx, 2339		; 00000923H
  00023	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2340 :         return NULL;

  00028	33 c0		 xor	 eax, eax

; 2341 :     }
; 2342 :     return as_ucs4(string, target, targetsize, copy_null);
; 2343 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
PyUnicode_AsUCS4 ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsUCS4Copy
; Function compile flags: /Ogtpy
;	COMDAT PyUnicode_AsUCS4Copy
_TEXT	SEGMENT
string$ = 8
PyUnicode_AsUCS4Copy PROC				; COMDAT

; 2348 :     return as_ucs4(string, NULL, 0, 1);

  00000	41 b9 01 00 00
	00		 mov	 r9d, 1
  00006	45 33 c0	 xor	 r8d, r8d
  00009	33 d2		 xor	 edx, edx

; 2349 : }

  0000b	e9 00 00 00 00	 jmp	 as_ucs4
PyUnicode_AsUCS4Copy ENDP
_TEXT	ENDS
PUBLIC	??_C@_01JPJNBJEM@I?$AA@				; `string'
PUBLIC	??_C@_03KDGLFNIB@I64?$AA@			; `string'
PUBLIC	??_C@_03KBEBNCEG@?4?$CFd?$AA@			; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
EXTRN	__imp_sprintf:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$makefmt DD imagerel makefmt
	DD	imagerel makefmt+238
	DD	imagerel $unwind$makefmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$makefmt DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_01JPJNBJEM@I?$AA@
CONST	SEGMENT
??_C@_01JPJNBJEM@I?$AA@ DB 'I', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KDGLFNIB@I64?$AA@
CONST	SEGMENT
??_C@_03KDGLFNIB@I64?$AA@ DB 'I64', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KBEBNCEG@?4?$CFd?$AA@
CONST	SEGMENT
??_C@_03KBEBNCEG@?4?$CFd?$AA@ DB '.%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT makefmt
_TEXT	SEGMENT
fmt$ = 48
longflag$ = 56
longlongflag$ = 64
size_tflag$ = 72
zeropad$ = 80
width$ = 88
precision$ = 96
c$ = 104
makefmt	PROC						; COMDAT

; 2375 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	41 8b f0	 mov	 esi, r8d

; 2376 :     *fmt++ = '%';
; 2377 :     if (width) {

  00017	44 8b 44 24 58	 mov	 r8d, DWORD PTR width$[rsp]
  0001c	41 8b f9	 mov	 edi, r9d
  0001f	8b ea		 mov	 ebp, edx
  00021	c6 01 25	 mov	 BYTE PTR [rcx], 37	; 00000025H
  00024	48 8d 59 01	 lea	 rbx, QWORD PTR [rcx+1]
  00028	45 85 c0	 test	 r8d, r8d
  0002b	74 23		 je	 SHORT $LN12@makefmt

; 2378 :         if (zeropad)

  0002d	83 7c 24 50 00	 cmp	 DWORD PTR zeropad$[rsp], 0
  00032	74 06		 je	 SHORT $LN11@makefmt

; 2379 :             *fmt++ = '0';

  00034	c6 03 30	 mov	 BYTE PTR [rbx], 48	; 00000030H
  00037	48 ff c3	 inc	 rbx
$LN11@makefmt:

; 2380 :         fmt += sprintf(fmt, "%d", width);

  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  00041	48 8b cb	 mov	 rcx, rbx
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf
  0004a	48 63 c8	 movsxd	 rcx, eax
  0004d	48 03 d9	 add	 rbx, rcx
$LN12@makefmt:

; 2381 :     }
; 2382 :     if (precision)

  00050	44 8b 44 24 60	 mov	 r8d, DWORD PTR precision$[rsp]
  00055	45 85 c0	 test	 r8d, r8d
  00058	74 16		 je	 SHORT $LN10@makefmt

; 2383 :         fmt += sprintf(fmt, ".%d", precision);

  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03KBEBNCEG@?4?$CFd?$AA@
  00061	48 8b cb	 mov	 rcx, rbx
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf
  0006a	48 63 c8	 movsxd	 rcx, eax
  0006d	48 03 d9	 add	 rbx, rcx
$LN10@makefmt:

; 2384 :     if (longflag)

  00070	85 ed		 test	 ebp, ebp
  00072	74 11		 je	 SHORT $LN9@makefmt

; 2403 :     }
; 2404 :     *fmt++ = c;

  00074	0f b6 44 24 68	 movzx	 eax, BYTE PTR c$[rsp]
  00079	c6 03 6c	 mov	 BYTE PTR [rbx], 108	; 0000006cH
  0007c	88 43 01	 mov	 BYTE PTR [rbx+1], al

; 2405 :     *fmt = '\0';

  0007f	c6 43 02 00	 mov	 BYTE PTR [rbx+2], 0
  00083	eb 54		 jmp	 SHORT $LN1@makefmt
$LN9@makefmt:

; 2385 :         *fmt++ = 'l';
; 2386 :     else if (longlongflag) {

  00085	85 f6		 test	 esi, esi
  00087	74 27		 je	 SHORT $LN7@makefmt

; 2387 :         /* longlongflag should only ever be nonzero on machines with
; 2388 :            HAVE_LONG_LONG defined */
; 2389 : #ifdef HAVE_LONG_LONG
; 2390 :         char *f = PY_FORMAT_LONG_LONG;
; 2391 :         while (*f)

  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03KDGLFNIB@I64?$AA@
  00090	b0 49		 mov	 al, 73			; 00000049H
  00092	48 2b cb	 sub	 rcx, rbx
  00095	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL6@makefmt:

; 2392 :             *fmt++ = *f++;

  000a0	88 03		 mov	 BYTE PTR [rbx], al
  000a2	0f b6 44 19 01	 movzx	 eax, BYTE PTR [rcx+rbx+1]
  000a7	48 ff c3	 inc	 rbx
  000aa	84 c0		 test	 al, al
  000ac	75 f2		 jne	 SHORT $LL6@makefmt

; 2393 : #else
; 2394 :         /* we shouldn't ever get here */
; 2395 :         assert(0);
; 2396 :         *fmt++ = 'l';
; 2397 : #endif
; 2398 :     }
; 2399 :     else if (size_tflag) {

  000ae	eb 1e		 jmp	 SHORT $LN19@makefmt
$LN7@makefmt:
  000b0	85 ff		 test	 edi, edi
  000b2	74 1a		 je	 SHORT $LN19@makefmt

; 2400 :         char *f = PY_FORMAT_SIZE_T;
; 2401 :         while (*f)

  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01JPJNBJEM@I?$AA@
  000bb	b0 49		 mov	 al, 73			; 00000049H
  000bd	48 2b cb	 sub	 rcx, rbx
$LL2@makefmt:

; 2402 :             *fmt++ = *f++;

  000c0	88 03		 mov	 BYTE PTR [rbx], al
  000c2	0f b6 44 19 01	 movzx	 eax, BYTE PTR [rcx+rbx+1]
  000c7	48 ff c3	 inc	 rbx
  000ca	84 c0		 test	 al, al
  000cc	75 f2		 jne	 SHORT $LL2@makefmt
$LN19@makefmt:

; 2403 :     }
; 2404 :     *fmt++ = c;

  000ce	0f b6 44 24 68	 movzx	 eax, BYTE PTR c$[rsp]
  000d3	88 03		 mov	 BYTE PTR [rbx], al

; 2405 :     *fmt = '\0';

  000d5	c6 43 01 00	 mov	 BYTE PTR [rbx+1], 0
$LN1@makefmt:

; 2406 : }

  000d9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000de	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000e3	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000e8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ec	5f		 pop	 rdi
  000ed	c3		 ret	 0
makefmt	ENDP
_TEXT	ENDS
EXTRN	_Py_ctype_table:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$parse_format_flags DD imagerel parse_format_flags
	DD	imagerel parse_format_flags+321
	DD	imagerel $unwind$parse_format_flags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parse_format_flags DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT parse_format_flags
_TEXT	SEGMENT
f$ = 8
p_width$ = 16
p_precision$ = 24
p_longflag$ = 32
p_longlongflag$ = 40
p_size_tflag$ = 48
parse_format_flags PROC					; COMDAT

; 2414 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi

; 2415 :     int width, precision, longflag, longlongflag, size_tflag;
; 2416 : 
; 2417 :     /* parse the width.precision part, e.g. "%2.5s" => width=2, precision=5 */
; 2418 :     f++;
; 2419 :     width = 0;
; 2420 :     while (Py_ISDIGIT((unsigned)*f))

  0000f	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00013	45 33 db	 xor	 r11d, r11d
  00016	4c 8d 51 01	 lea	 r10, QWORD PTR [rcx+1]
  0001a	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_ctype_table
  00021	49 8b f9	 mov	 rdi, r9
  00024	4d 8b c8	 mov	 r9, r8
  00027	f6 04 86 04	 test	 BYTE PTR [rsi+rax*4], 4
  0002b	48 8b da	 mov	 rbx, rdx
  0002e	45 8b c3	 mov	 r8d, r11d
  00031	74 26		 je	 SHORT $LN20@parse_form
  00033	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL21@parse_form:

; 2421 :         width = (width*10) + *f++ - '0';

  00040	0f be c0	 movsx	 eax, al
  00043	49 ff c2	 inc	 r10
  00046	43 8d 0c 80	 lea	 ecx, DWORD PTR [r8+r8*4]
  0004a	44 8d 44 48 d0	 lea	 r8d, DWORD PTR [rax+rcx*2-48]
  0004f	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00053	f6 04 86 04	 test	 BYTE PTR [rsi+rax*4], 4
  00057	75 e7		 jne	 SHORT $LL21@parse_form
$LN20@parse_form:

; 2422 :     precision = 0;
; 2423 :     if (*f == '.') {

  00059	41 80 3a 2e	 cmp	 BYTE PTR [r10], 46	; 0000002eH
  0005d	41 8b c3	 mov	 eax, r11d
  00060	75 2e		 jne	 SHORT $LN16@parse_form

; 2424 :         f++;
; 2425 :         while (Py_ISDIGIT((unsigned)*f))

  00062	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]
  00067	49 ff c2	 inc	 r10
  0006a	f6 04 96 04	 test	 BYTE PTR [rsi+rdx*4], 4
  0006e	74 17		 je	 SHORT $LN17@parse_form
$LL18@parse_form:

; 2426 :             precision = (precision*10) + *f++ - '0';

  00070	49 ff c2	 inc	 r10
  00073	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]
  00076	0f be c2	 movsx	 eax, dl
  00079	41 0f b6 12	 movzx	 edx, BYTE PTR [r10]
  0007d	8d 44 48 d0	 lea	 eax, DWORD PTR [rax+rcx*2-48]
  00081	f6 04 96 04	 test	 BYTE PTR [rsi+rdx*4], 4
  00085	75 e9		 jne	 SHORT $LL18@parse_form
$LN17@parse_form:

; 2427 :         if (*f == '%') {

  00087	41 80 3a 25	 cmp	 BYTE PTR [r10], 37	; 00000025H
  0008b	75 03		 jne	 SHORT $LN16@parse_form

; 2428 :             /* "%.3%s" => f points to "3" */
; 2429 :             f--;

  0008d	49 ff ca	 dec	 r10
$LN16@parse_form:

; 2430 :         }
; 2431 :     }
; 2432 :     if (*f == '\0') {

  00090	45 38 1a	 cmp	 BYTE PTR [r10], r11b
  00093	75 03		 jne	 SHORT $LN15@parse_form

; 2433 :         /* bogus format "%.1" => go backward, f points to "1" */
; 2434 :         f--;

  00095	49 ff ca	 dec	 r10
$LN15@parse_form:

; 2435 :     }
; 2436 :     if (p_width != NULL)

  00098	48 85 db	 test	 rbx, rbx
  0009b	74 03		 je	 SHORT $LN14@parse_form

; 2437 :         *p_width = width;

  0009d	44 89 03	 mov	 DWORD PTR [rbx], r8d
$LN14@parse_form:

; 2438 :     if (p_precision != NULL)

  000a0	4d 85 c9	 test	 r9, r9
  000a3	74 03		 je	 SHORT $LN13@parse_form

; 2439 :         *p_precision = precision;

  000a5	41 89 01	 mov	 DWORD PTR [r9], eax
$LN13@parse_form:

; 2440 : 
; 2441 :     /* Handle %ld, %lu, %lld and %llu. */
; 2442 :     longflag = 0;
; 2443 :     longlongflag = 0;
; 2444 :     size_tflag = 0;
; 2445 : 
; 2446 :     if (*f == 'l') {

  000a8	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  000ac	45 8b c3	 mov	 r8d, r11d
  000af	41 8b d3	 mov	 edx, r11d
  000b2	3c 6c		 cmp	 al, 108			; 0000006cH
  000b4	75 3a		 jne	 SHORT $LN12@parse_form

; 2447 :         if (f[1] == 'd' || f[1] == 'u' || f[1] == 'i') {

  000b6	41 0f b6 42 01	 movzx	 eax, BYTE PTR [r10+1]
  000bb	3c 64		 cmp	 al, 100			; 00000064H
  000bd	74 29		 je	 SHORT $LN10@parse_form
  000bf	3c 75		 cmp	 al, 117			; 00000075H
  000c1	74 25		 je	 SHORT $LN10@parse_form
  000c3	3c 69		 cmp	 al, 105			; 00000069H
  000c5	74 21		 je	 SHORT $LN10@parse_form

; 2449 :             ++f;
; 2450 :         }
; 2451 : #ifdef HAVE_LONG_LONG
; 2452 :         else if (f[1] == 'l' &&
; 2453 :                  (f[2] == 'd' || f[2] == 'u' || f[2] == 'i')) {

  000c7	3c 6c		 cmp	 al, 108			; 0000006cH
  000c9	75 42		 jne	 SHORT $LN5@parse_form
  000cb	41 0f b6 42 02	 movzx	 eax, BYTE PTR [r10+2]
  000d0	3c 64		 cmp	 al, 100			; 00000064H
  000d2	74 08		 je	 SHORT $LN7@parse_form
  000d4	3c 75		 cmp	 al, 117			; 00000075H
  000d6	74 04		 je	 SHORT $LN7@parse_form
  000d8	3c 69		 cmp	 al, 105			; 00000069H
  000da	75 31		 jne	 SHORT $LN5@parse_form
$LN7@parse_form:

; 2454 :             longlongflag = 1;

  000dc	41 b8 01 00 00
	00		 mov	 r8d, 1

; 2455 :             f += 2;

  000e2	49 83 c2 02	 add	 r10, 2
  000e6	eb 25		 jmp	 SHORT $LN5@parse_form
$LN10@parse_form:

; 2448 :             longflag = 1;

  000e8	41 bb 01 00 00
	00		 mov	 r11d, 1

; 2456 :         }

  000ee	eb 1a		 jmp	 SHORT $LN29@parse_form
$LN12@parse_form:

; 2457 : #endif
; 2458 :     }
; 2459 :     /* handle the size_t flag. */
; 2460 :     else if (*f == 'z' && (f[1] == 'd' || f[1] == 'u' || f[1] == 'i')) {

  000f0	3c 7a		 cmp	 al, 122			; 0000007aH
  000f2	75 19		 jne	 SHORT $LN5@parse_form
  000f4	41 0f b6 42 01	 movzx	 eax, BYTE PTR [r10+1]
  000f9	3c 64		 cmp	 al, 100			; 00000064H
  000fb	74 08		 je	 SHORT $LN4@parse_form
  000fd	3c 75		 cmp	 al, 117			; 00000075H
  000ff	74 04		 je	 SHORT $LN4@parse_form
  00101	3c 69		 cmp	 al, 105			; 00000069H
  00103	75 08		 jne	 SHORT $LN5@parse_form
$LN4@parse_form:

; 2461 :         size_tflag = 1;

  00105	ba 01 00 00 00	 mov	 edx, 1
$LN29@parse_form:

; 2462 :         ++f;

  0010a	49 ff c2	 inc	 r10
$LN5@parse_form:

; 2463 :     }
; 2464 :     if (p_longflag != NULL)

  0010d	48 85 ff	 test	 rdi, rdi
  00110	74 03		 je	 SHORT $LN3@parse_form

; 2465 :         *p_longflag = longflag;

  00112	44 89 1f	 mov	 DWORD PTR [rdi], r11d
$LN3@parse_form:

; 2466 :     if (p_longlongflag != NULL)

  00115	48 8b 44 24 28	 mov	 rax, QWORD PTR p_longlongflag$[rsp]
  0011a	48 85 c0	 test	 rax, rax
  0011d	74 03		 je	 SHORT $LN2@parse_form

; 2467 :         *p_longlongflag = longlongflag;

  0011f	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN2@parse_form:

; 2468 :     if (p_size_tflag != NULL)

  00122	48 8b 44 24 30	 mov	 rax, QWORD PTR p_size_tflag$[rsp]
  00127	48 85 c0	 test	 rax, rax
  0012a	74 02		 je	 SHORT $LN28@parse_form

; 2469 :         *p_size_tflag = size_tflag;

  0012c	89 10		 mov	 DWORD PTR [rax], edx
$LN28@parse_form:

; 2470 :     return f;
; 2471 : }

  0012e	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00133	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
  00138	48 8b 7c 24 18	 mov	 rdi, QWORD PTR [rsp+24]
  0013d	49 8b c2	 mov	 rax, r10
  00140	c3		 ret	 0
parse_format_flags ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@LNHKIN@chr?$CI?$CJ?5arg?5not?5in?5range?$CI0x110000?$CJ@ ; `string'
PUBLIC	PyUnicode_FromOrdinal
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_FromOrdinal DD imagerel $LN28
	DD	imagerel $LN28+273
	DD	imagerel $unwind$PyUnicode_FromOrdinal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_FromOrdinal DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CB@LNHKIN@chr?$CI?$CJ?5arg?5not?5in?5range?$CI0x110000?$CJ@
CONST	SEGMENT
??_C@_0CB@LNHKIN@chr?$CI?$CJ?5arg?5not?5in?5range?$CI0x110000?$CJ@ DB 'ch'
	DB	'r() arg not in range(0x110000)', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_FromOrdinal
_TEXT	SEGMENT
ordinal$ = 48
PyUnicode_FromOrdinal PROC				; COMDAT

; 3062 : {

$LN28:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b d9		 mov	 ebx, ecx

; 3063 :     PyObject *v;
; 3064 :     if (ordinal < 0 || ordinal > MAX_UNICODE) {

  00008	81 f9 ff ff 10
	00		 cmp	 ecx, 1114111		; 0010ffffH
  0000e	0f 87 e2 00 00
	00		 ja	 $LN11@PyUnicode_@14

; 3068 :     }
; 3069 : 
; 3070 :     if ((Py_UCS4)ordinal < 256)

  00014	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  0001a	73 0a		 jae	 SHORT $LN10@PyUnicode_@14

; 3077 :     assert(_PyUnicode_CheckConsistency(v, 1));
; 3078 :     return v;
; 3079 : }

  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5b		 pop	 rbx
  00021	e9 00 00 00 00	 jmp	 get_latin1_char
$LN10@PyUnicode_@14:

; 3071 :         return get_latin1_char((unsigned char)ordinal);
; 3072 : 
; 3073 :     v = PyUnicode_New(1, ordinal);

  00026	8b d1		 mov	 edx, ecx
  00028	b9 01 00 00 00	 mov	 ecx, 1
  0002d	e8 00 00 00 00	 call	 PyUnicode_New

; 3074 :     if (v == NULL)

  00032	48 85 c0	 test	 rax, rax

; 3075 :         return NULL;

  00035	0f 84 ce 00 00
	00		 je	 $LN27@PyUnicode_@14

; 3076 :     PyUnicode_WRITE(PyUnicode_KIND(v), PyUnicode_DATA(v), 0, ordinal);

  0003b	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  0003e	8b d1		 mov	 edx, ecx
  00040	c1 ea 02	 shr	 edx, 2
  00043	83 e2 07	 and	 edx, 7
  00046	ff ca		 dec	 edx
  00048	74 75		 je	 SHORT $LN3@PyUnicode_@14
  0004a	ff ca		 dec	 edx
  0004c	74 37		 je	 SHORT $LN2@PyUnicode_@14
  0004e	f6 c1 20	 test	 cl, 32			; 00000020H
  00051	74 23		 je	 SHORT $LN25@PyUnicode_@14
  00053	f6 c1 40	 test	 cl, 64			; 00000040H
  00056	74 0f		 je	 SHORT $LN23@PyUnicode_@14
  00058	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  0005f	89 19		 mov	 DWORD PTR [rcx], ebx

; 3077 :     assert(_PyUnicode_CheckConsistency(v, 1));
; 3078 :     return v;
; 3079 : }

  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5b		 pop	 rbx
  00066	c3		 ret	 0
$LN23@PyUnicode_@14:

; 3076 :     PyUnicode_WRITE(PyUnicode_KIND(v), PyUnicode_DATA(v), 0, ordinal);

  00067	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  0006e	89 19		 mov	 DWORD PTR [rcx], ebx

; 3077 :     assert(_PyUnicode_CheckConsistency(v, 1));
; 3078 :     return v;
; 3079 : }

  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5b		 pop	 rbx
  00075	c3		 ret	 0
$LN25@PyUnicode_@14:

; 3076 :     PyUnicode_WRITE(PyUnicode_KIND(v), PyUnicode_DATA(v), 0, ordinal);

  00076	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  0007d	89 19		 mov	 DWORD PTR [rcx], ebx

; 3077 :     assert(_PyUnicode_CheckConsistency(v, 1));
; 3078 :     return v;
; 3079 : }

  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	5b		 pop	 rbx
  00084	c3		 ret	 0
$LN2@PyUnicode_@14:

; 3076 :     PyUnicode_WRITE(PyUnicode_KIND(v), PyUnicode_DATA(v), 0, ordinal);

  00085	f6 c1 20	 test	 cl, 32			; 00000020H
  00088	74 25		 je	 SHORT $LN21@PyUnicode_@14
  0008a	f6 c1 40	 test	 cl, 64			; 00000040H
  0008d	74 10		 je	 SHORT $LN19@PyUnicode_@14
  0008f	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  00096	66 89 19	 mov	 WORD PTR [rcx], bx

; 3077 :     assert(_PyUnicode_CheckConsistency(v, 1));
; 3078 :     return v;
; 3079 : }

  00099	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009d	5b		 pop	 rbx
  0009e	c3		 ret	 0
$LN19@PyUnicode_@14:

; 3076 :     PyUnicode_WRITE(PyUnicode_KIND(v), PyUnicode_DATA(v), 0, ordinal);

  0009f	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  000a6	66 89 19	 mov	 WORD PTR [rcx], bx

; 3077 :     assert(_PyUnicode_CheckConsistency(v, 1));
; 3078 :     return v;
; 3079 : }

  000a9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ad	5b		 pop	 rbx
  000ae	c3		 ret	 0
$LN21@PyUnicode_@14:

; 3076 :     PyUnicode_WRITE(PyUnicode_KIND(v), PyUnicode_DATA(v), 0, ordinal);

  000af	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  000b6	66 89 19	 mov	 WORD PTR [rcx], bx

; 3077 :     assert(_PyUnicode_CheckConsistency(v, 1));
; 3078 :     return v;
; 3079 : }

  000b9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bd	5b		 pop	 rbx
  000be	c3		 ret	 0
$LN3@PyUnicode_@14:

; 3076 :     PyUnicode_WRITE(PyUnicode_KIND(v), PyUnicode_DATA(v), 0, ordinal);

  000bf	f6 c1 20	 test	 cl, 32			; 00000020H
  000c2	74 23		 je	 SHORT $LN17@PyUnicode_@14
  000c4	f6 c1 40	 test	 cl, 64			; 00000040H
  000c7	74 0f		 je	 SHORT $LN15@PyUnicode_@14
  000c9	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  000d0	88 19		 mov	 BYTE PTR [rcx], bl

; 3077 :     assert(_PyUnicode_CheckConsistency(v, 1));
; 3078 :     return v;
; 3079 : }

  000d2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d6	5b		 pop	 rbx
  000d7	c3		 ret	 0
$LN15@PyUnicode_@14:

; 3076 :     PyUnicode_WRITE(PyUnicode_KIND(v), PyUnicode_DATA(v), 0, ordinal);

  000d8	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  000df	88 19		 mov	 BYTE PTR [rcx], bl

; 3077 :     assert(_PyUnicode_CheckConsistency(v, 1));
; 3078 :     return v;
; 3079 : }

  000e1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e5	5b		 pop	 rbx
  000e6	c3		 ret	 0
$LN17@PyUnicode_@14:

; 3076 :     PyUnicode_WRITE(PyUnicode_KIND(v), PyUnicode_DATA(v), 0, ordinal);

  000e7	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  000ee	88 19		 mov	 BYTE PTR [rcx], bl

; 3077 :     assert(_PyUnicode_CheckConsistency(v, 1));
; 3078 :     return v;
; 3079 : }

  000f0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f4	5b		 pop	 rbx
  000f5	c3		 ret	 0
$LN11@PyUnicode_@14:

; 3065 :         PyErr_SetString(PyExc_ValueError,
; 3066 :                         "chr() arg not in range(0x110000)");

  000f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@LNHKIN@chr?$CI?$CJ?5arg?5not?5in?5range?$CI0x110000?$CJ@
  00104	e8 00 00 00 00	 call	 PyErr_SetString
$LN27@PyUnicode_@14:

; 3067 :         return NULL;

  00109	33 c0		 xor	 eax, eax

; 3077 :     assert(_PyUnicode_CheckConsistency(v, 1));
; 3078 :     return v;
; 3079 : }

  0010b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010f	5b		 pop	 rbx
  00110	c3		 ret	 0
PyUnicode_FromOrdinal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@DMAJCCAK@Can?8t?5convert?5?8?$CF?4100s?8?5object?5to@ ; `string'
PUBLIC	PyUnicode_FromObject
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyUnicode_FromObject DD imagerel $LN13
	DD	imagerel $LN13+163
	DD	imagerel $unwind$PyUnicode_FromObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_FromObject DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0DA@DMAJCCAK@Can?8t?5convert?5?8?$CF?4100s?8?5object?5to@
CONST	SEGMENT
??_C@_0DA@DMAJCCAK@Can?8t?5convert?5?8?$CF?4100s?8?5object?5to@ DB 'Can'''
	DB	't convert ''%.100s'' object to str implicitly', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT PyUnicode_FromObject
_TEXT	SEGMENT
obj$ = 64
PyUnicode_FromObject PROC				; COMDAT

; 3083 : {

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3084 :     /* XXX Perhaps we should make this API an alias of
; 3085 :        PyObject_Str() instead ?! */
; 3086 :     if (PyUnicode_CheckExact(obj)) {

  00006	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00011	48 8b d9	 mov	 rbx, rcx
  00014	4c 3b c0	 cmp	 r8, rax
  00017	75 54		 jne	 SHORT $LN3@PyUnicode_@15

; 3087 :         if (PyUnicode_READY(obj) == -1)

  00019	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0001d	75 0a		 jne	 SHORT $LN2@PyUnicode_@15
  0001f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00024	83 f8 ff	 cmp	 eax, -1

; 3088 :             return NULL;

  00027	74 72		 je	 SHORT $LN12@PyUnicode_@15
$LN2@PyUnicode_@15:

; 3089 :         Py_INCREF(obj);

  00029	e8 00 00 00 00	 call	 _Py_PXCTX
  0002e	85 c0		 test	 eax, eax
  00030	75 32		 jne	 SHORT $LN9@PyUnicode_@15
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00040	4c 8b cb	 mov	 r9, rbx
  00043	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00049	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00051	e8 00 00 00 00	 call	 _PyParallel_Guard
  00056	85 c0		 test	 eax, eax
  00058	75 06		 jne	 SHORT $LN8@PyUnicode_@15
  0005a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0005e	74 04		 je	 SHORT $LN9@PyUnicode_@15
$LN8@PyUnicode_@15:
  00060	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN9@PyUnicode_@15:

; 3090 :         return obj;

  00064	48 8b c3	 mov	 rax, rbx

; 3101 : }

  00067	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006b	5b		 pop	 rbx
  0006c	c3		 ret	 0
$LN3@PyUnicode_@15:

; 3091 :     }
; 3092 :     if (PyUnicode_Check(obj)) {

  0006d	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  00078	74 0a		 je	 SHORT $LN1@PyUnicode_@15

; 3101 : }

  0007a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007e	5b		 pop	 rbx
  0007f	e9 00 00 00 00	 jmp	 _PyUnicode_Copy
$LN1@PyUnicode_@15:

; 3093 :         /* For a Unicode subtype that's not a Unicode object,
; 3094 :            return a true Unicode object with the same data. */
; 3095 :         return _PyUnicode_Copy(obj);
; 3096 :     }
; 3097 :     PyErr_Format(PyExc_TypeError,
; 3098 :                  "Can't convert '%.100s' object to str implicitly",
; 3099 :                  Py_TYPE(obj)->tp_name);

  00084	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00088	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@DMAJCCAK@Can?8t?5convert?5?8?$CF?4100s?8?5object?5to@
  00096	e8 00 00 00 00	 call	 PyErr_Format
$LN12@PyUnicode_@15:

; 3100 :     return NULL;

  0009b	33 c0		 xor	 eax, eax

; 3101 : }

  0009d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a1	5b		 pop	 rbx
  000a2	c3		 ret	 0
PyUnicode_FromObject ENDP
_TEXT	ENDS
PUBLIC	??_C@_05CAMHEFLG@utf?98?$AA@			; `string'
PUBLIC	_Py_normalize_encoding
EXTRN	_Py_ctype_tolower:BYTE
EXTRN	__ImageBase:BYTE
;	COMDAT ??_C@_05CAMHEFLG@utf?98?$AA@
CONST	SEGMENT
??_C@_05CAMHEFLG@utf?98?$AA@ DB 'utf-8', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_normalize_encoding
_TEXT	SEGMENT
encoding$ = 8
lower$ = 16
lower_len$ = 24
_Py_normalize_encoding PROC				; COMDAT

; 3159 :     const char *e;
; 3160 :     char *l;
; 3161 :     char *l_end;
; 3162 : 
; 3163 :     if (encoding == NULL) {

  00000	48 85 c9	 test	 rcx, rcx
  00003	75 17		 jne	 SHORT $LN8@Py_normali

; 3164 :         strcpy(lower, "utf-8");

  00005	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_05CAMHEFLG@utf?98?$AA@
  0000b	89 02		 mov	 DWORD PTR [rdx], eax
  0000d	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05CAMHEFLG@utf?98?$AA@+4
  00014	66 89 42 04	 mov	 WORD PTR [rdx+4], ax

; 3185 :     return 1;

  00018	8d 41 01	 lea	 eax, QWORD PTR [rcx+1]

; 3186 : }

  0001b	c3		 ret	 0
$LN8@Py_normali:

; 3165 :         return 1;
; 3166 :     }
; 3167 :     e = encoding;
; 3168 :     l = lower;
; 3169 :     l_end = &lower[lower_len - 1];
; 3170 :     while (*e) {

  0001c	80 39 00	 cmp	 BYTE PTR [rcx], 0
  0001f	4e 8d 44 02 ff	 lea	 r8, QWORD PTR [rdx+r8-1]
  00024	74 33		 je	 SHORT $LN6@Py_normali
  00026	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:__ImageBase
  0002d	0f 1f 00	 npad	 3
$LL7@Py_normali:

; 3171 :         if (l == l_end)

  00030	49 3b d0	 cmp	 rdx, r8
  00033	74 36		 je	 SHORT $LN12@Py_normali

; 3173 :         if (Py_ISUPPER(*e)) {

  00035	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00038	41 f6 84 81 00
	00 00 00 02	 test	 BYTE PTR _Py_ctype_table[r9+rax*4], 2
  00041	74 1f		 je	 SHORT $LN4@Py_normali

; 3174 :             *l++ = Py_TOLOWER(*e++);

  00043	42 0f b6 84 08
	00 00 00 00	 movzx	 eax, BYTE PTR _Py_ctype_tolower[rax+r9]
$LN2@Py_normali:

; 3181 :             *l++ = *e++;

  0004c	88 02		 mov	 BYTE PTR [rdx], al
$LN14@Py_normali:
  0004e	48 ff c1	 inc	 rcx
  00051	48 ff c2	 inc	 rdx
  00054	80 39 00	 cmp	 BYTE PTR [rcx], 0
  00057	75 d7		 jne	 SHORT $LL7@Py_normali
$LN6@Py_normali:

; 3182 :         }
; 3183 :     }
; 3184 :     *l = '\0';

  00059	c6 02 00	 mov	 BYTE PTR [rdx], 0

; 3185 :     return 1;

  0005c	b8 01 00 00 00	 mov	 eax, 1

; 3186 : }

  00061	c3		 ret	 0
$LN4@Py_normali:

; 3175 :         }
; 3176 :         else if (*e == '_') {

  00062	3c 5f		 cmp	 al, 95			; 0000005fH
  00064	75 e6		 jne	 SHORT $LN2@Py_normali

; 3177 :             *l++ = '-';

  00066	c6 02 2d	 mov	 BYTE PTR [rdx], 45	; 0000002dH

; 3178 :             e++;
; 3179 :         }
; 3180 :         else {

  00069	eb e3		 jmp	 SHORT $LN14@Py_normali
$LN12@Py_normali:

; 3172 :             return 0;

  0006b	33 c0		 xor	 eax, eax

; 3186 : }

  0006d	c3		 ret	 0
_Py_normalize_encoding ENDP
_TEXT	ENDS
EXTRN	__imp_wcstombs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$wcstombs_errorpos DD imagerel wcstombs_errorpos
	DD	imagerel wcstombs_errorpos+190
	DD	imagerel $unwind$wcstombs_errorpos
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wcstombs_errorpos DD 0a1401H
	DD	0e3414H
	DD	0f0103214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT wcstombs_errorpos
_TEXT	SEGMENT
outbuf$ = 96
wstr$ = 96
buf$ = 104
wcstombs_errorpos PROC					; COMDAT

; 3344 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3345 :     size_t len;
; 3346 : #if SIZEOF_WCHAR_T == 2
; 3347 :     wchar_t buf[3];
; 3348 : #else
; 3349 :     wchar_t buf[2];
; 3350 : #endif
; 3351 :     char outbuf[MB_LEN_MAX];
; 3352 :     const wchar_t *start, *previous;
; 3353 : 
; 3354 : #if SIZEOF_WCHAR_T == 2
; 3355 :     buf[2] = 0;
; 3356 : #else
; 3357 :     buf[1] = 0;
; 3358 : #endif
; 3359 :     start = wstr;
; 3360 :     while (*wstr != L'\0')

  00014	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00017	33 ed		 xor	 ebp, ebp
  00019	48 8b d9	 mov	 rbx, rcx
  0001c	66 89 6c 24 6c	 mov	 WORD PTR buf$[rsp+4], bp
  00021	48 8b f1	 mov	 rsi, rcx
  00024	66 85 c0	 test	 ax, ax
  00027	74 73		 je	 SHORT $LN4@wcstombs_e
  00029	41 bd ff db 00
	00		 mov	 r13d, 56319		; 0000dbffH
  0002f	41 bc 00 d8 00
	00		 mov	 r12d, 55296		; 0000d800H
  00035	41 bf ff df 00
	00		 mov	 r15d, 57343		; 0000dfffH
  0003b	45 8d 75 01	 lea	 r14d, QWORD PTR [r13+1]
  0003f	90		 npad	 1
$LL5@wcstombs_e:

; 3361 :     {
; 3362 :         previous = wstr;

  00040	48 8b fb	 mov	 rdi, rbx

; 3363 : #if SIZEOF_WCHAR_T == 2
; 3364 :         if (Py_UNICODE_IS_HIGH_SURROGATE(wstr[0])
; 3365 :             && Py_UNICODE_IS_LOW_SURROGATE(wstr[1]))

  00043	66 44 3b e0	 cmp	 r12w, ax
  00047	77 21		 ja	 SHORT $LN3@wcstombs_e
  00049	66 41 3b c5	 cmp	 ax, r13w
  0004d	77 1b		 ja	 SHORT $LN3@wcstombs_e
  0004f	0f b7 4b 02	 movzx	 ecx, WORD PTR [rbx+2]
  00053	66 44 3b f1	 cmp	 r14w, cx
  00057	77 11		 ja	 SHORT $LN3@wcstombs_e
  00059	66 41 3b cf	 cmp	 cx, r15w
  0005d	77 0b		 ja	 SHORT $LN3@wcstombs_e

; 3366 :         {
; 3367 :             buf[0] = wstr[0];
; 3368 :             buf[1] = wstr[1];

  0005f	66 89 4c 24 6a	 mov	 WORD PTR buf$[rsp+2], cx

; 3369 :             wstr += 2;

  00064	48 83 c3 04	 add	 rbx, 4

; 3370 :         }
; 3371 :         else {

  00068	eb 09		 jmp	 SHORT $LN10@wcstombs_e
$LN3@wcstombs_e:

; 3372 :             buf[0] = *wstr;
; 3373 :             buf[1] = 0;

  0006a	66 89 6c 24 6a	 mov	 WORD PTR buf$[rsp+2], bp

; 3374 :             wstr++;

  0006f	48 83 c3 02	 add	 rbx, 2
$LN10@wcstombs_e:

; 3375 :         }
; 3376 : #else
; 3377 :         buf[0] = *wstr;
; 3378 :         wstr++;
; 3379 : #endif
; 3380 :         len = wcstombs(outbuf, buf, sizeof(outbuf));

  00073	48 8d 54 24 68	 lea	 rdx, QWORD PTR buf$[rsp]
  00078	48 8d 4c 24 60	 lea	 rcx, QWORD PTR outbuf$[rsp]
  0007d	41 b8 05 00 00
	00		 mov	 r8d, 5
  00083	66 89 44 24 68	 mov	 WORD PTR buf$[rsp], ax
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstombs

; 3381 :         if (len == (size_t)-1)

  0008e	48 83 f8 ff	 cmp	 rax, -1
  00092	74 1f		 je	 SHORT $LN9@wcstombs_e

; 3345 :     size_t len;
; 3346 : #if SIZEOF_WCHAR_T == 2
; 3347 :     wchar_t buf[3];
; 3348 : #else
; 3349 :     wchar_t buf[2];
; 3350 : #endif
; 3351 :     char outbuf[MB_LEN_MAX];
; 3352 :     const wchar_t *start, *previous;
; 3353 : 
; 3354 : #if SIZEOF_WCHAR_T == 2
; 3355 :     buf[2] = 0;
; 3356 : #else
; 3357 :     buf[1] = 0;
; 3358 : #endif
; 3359 :     start = wstr;
; 3360 :     while (*wstr != L'\0')

  00094	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00097	66 85 c0	 test	 ax, ax
  0009a	75 a4		 jne	 SHORT $LL5@wcstombs_e
$LN4@wcstombs_e:

; 3383 :     }
; 3384 : 
; 3385 :     /* failed to find the unencodable character */
; 3386 :     return 0;

  0009c	33 c0		 xor	 eax, eax
$LN6@wcstombs_e:

; 3387 : }

  0009e	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  000a3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a7	41 5f		 pop	 r15
  000a9	41 5e		 pop	 r14
  000ab	41 5d		 pop	 r13
  000ad	41 5c		 pop	 r12
  000af	5f		 pop	 rdi
  000b0	5e		 pop	 rsi
  000b1	5d		 pop	 rbp
  000b2	c3		 ret	 0
$LN9@wcstombs_e:

; 3382 :             return previous - start;

  000b3	48 2b fe	 sub	 rdi, rsi
  000b6	48 d1 ff	 sar	 rdi, 1
  000b9	48 8b c7	 mov	 rax, rdi
  000bc	eb e0		 jmp	 SHORT $LN6@wcstombs_e
wcstombs_errorpos ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EL@EPCMLGMP@only?5?8strict?8?5and?5?8surrogateesca@ ; `string'
PUBLIC	??_C@_0BA@GMJLDMKP@surrogateescape?$AA@		; `string'
PUBLIC	??_C@_06OLFOGHEN@strict?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$locale_error_handler DD imagerel locale_error_handler
	DD	imagerel locale_error_handler+21
	DD	imagerel $unwind$locale_error_handler
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$locale_error_handler DD imagerel locale_error_handler+21
	DD	imagerel locale_error_handler+73
	DD	imagerel $chain$1$locale_error_handler
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$locale_error_handler DD imagerel locale_error_handler+73
	DD	imagerel locale_error_handler+115
	DD	imagerel $chain$3$locale_error_handler
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$locale_error_handler DD imagerel locale_error_handler+115
	DD	imagerel locale_error_handler+152
	DD	imagerel $chain$5$locale_error_handler
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$locale_error_handler DD 040021H
	DD	047400H
	DD	066400H
	DD	imagerel locale_error_handler
	DD	imagerel locale_error_handler+21
	DD	imagerel $unwind$locale_error_handler
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$locale_error_handler DD 040021H
	DD	047400H
	DD	066400H
	DD	imagerel locale_error_handler
	DD	imagerel locale_error_handler+21
	DD	imagerel $unwind$locale_error_handler
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$locale_error_handler DD 040a21H
	DD	04740aH
	DD	066405H
	DD	imagerel locale_error_handler
	DD	imagerel locale_error_handler+21
	DD	imagerel $unwind$locale_error_handler
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$locale_error_handler DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0EL@EPCMLGMP@only?5?8strict?8?5and?5?8surrogateesca@
CONST	SEGMENT
??_C@_0EL@EPCMLGMP@only?5?8strict?8?5and?5?8surrogateesca@ DB 'only ''str'
	DB	'ict'' and ''surrogateescape'' error handlers are supported, n'
	DB	'ot ''%s''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
CONST	SEGMENT
??_C@_0BA@GMJLDMKP@surrogateescape?$AA@ DB 'surrogateescape', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OLFOGHEN@strict?$AA@
CONST	SEGMENT
??_C@_06OLFOGHEN@strict?$AA@ DB 'strict', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT locale_error_handler
_TEXT	SEGMENT
errors$ = 48
surrogateescape$ = 56
locale_error_handler PROC				; COMDAT

; 3391 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b c1	 mov	 r8, rcx

; 3392 :     if (errors == NULL) {

  00007	48 85 c9	 test	 rcx, rcx
  0000a	75 09		 jne	 SHORT $LN3@locale_err

; 3393 :         *surrogateescape = 0;

  0000c	89 0a		 mov	 DWORD PTR [rdx], ecx

; 3394 :         return 0;

  0000e	33 c0		 xor	 eax, eax

; 3410 : }

  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
$LN3@locale_err:
  00015	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0001a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi

; 3395 :     }
; 3396 : 
; 3397 :     if (strcmp(errors, "strict") == 0) {

  0001f	48 8b f1	 mov	 rsi, rcx
  00022	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  00029	b9 07 00 00 00	 mov	 ecx, 7
  0002e	f3 a6		 repe cmpsb
  00030	75 17		 jne	 SHORT $LN2@locale_err

; 3398 :         *surrogateescape = 0;

  00032	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00037	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  0003c	c7 02 00 00 00
	00		 mov	 DWORD PTR [rdx], 0

; 3399 :         return 0;

  00042	33 c0		 xor	 eax, eax

; 3410 : }

  00044	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00048	c3		 ret	 0
$LN2@locale_err:

; 3400 :     }
; 3401 :     if (strcmp(errors, "surrogateescape") == 0) {

  00049	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
  00050	49 8b f0	 mov	 rsi, r8
  00053	b9 10 00 00 00	 mov	 ecx, 16
  00058	f3 a6		 repe cmpsb
  0005a	75 17		 jne	 SHORT $LN1@locale_err

; 3402 :         *surrogateescape = 1;

  0005c	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00061	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  00066	c7 02 01 00 00
	00		 mov	 DWORD PTR [rdx], 1

; 3403 :         return 0;

  0006c	33 c0		 xor	 eax, eax

; 3410 : }

  0006e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00072	c3		 ret	 0
$LN1@locale_err:

; 3404 :     }
; 3405 :     PyErr_Format(PyExc_ValueError,
; 3406 :                  "only 'strict' and 'surrogateescape' error handlers "
; 3407 :                  "are supported, not '%s'",
; 3408 :                  errors);

  00073	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0007a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EL@EPCMLGMP@only?5?8strict?8?5and?5?8surrogateesca@
  00081	e8 00 00 00 00	 call	 PyErr_Format
  00086	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0008b	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 3409 :     return -1;

  00090	83 c8 ff	 or	 eax, -1

; 3410 : }

  00093	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00097	c3		 ret	 0
locale_error_handler ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT mbstowcs_errorpos
_TEXT	SEGMENT
mbstowcs_errorpos PROC					; COMDAT

; 3654 : #ifdef HAVE_MBRTOWC
; 3655 :     const char *start = str;
; 3656 :     mbstate_t mbs;
; 3657 :     size_t converted;
; 3658 :     wchar_t ch;
; 3659 : 
; 3660 :     memset(&mbs, 0, sizeof mbs);
; 3661 :     while (len)
; 3662 :     {
; 3663 :         converted = mbrtowc(&ch, (char*)str, len, &mbs);
; 3664 :         if (converted == 0)
; 3665 :             /* Reached end of string */
; 3666 :             break;
; 3667 :         if (converted == (size_t)-1 || converted == (size_t)-2) {
; 3668 :             /* Conversion error or incomplete character */
; 3669 :             return str - start;
; 3670 :         }
; 3671 :         else {
; 3672 :             str += converted;
; 3673 :             len -= converted;
; 3674 :         }
; 3675 :     }
; 3676 :     /* failed to find the undecodable byte sequence */
; 3677 :     return 0;
; 3678 : #endif
; 3679 :     return 0;

  00000	33 c0		 xor	 eax, eax

; 3680 : }

  00002	c3		 ret	 0
mbstowcs_errorpos ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EL@OMFODIE@Impossible?5unicode?5object?5state?0@ ; `string'
PUBLIC	PyUnicode_AsUnicodeAndSize
EXTRN	PyErr_BadArgument:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_AsUnicodeAndSize DD imagerel $LN53
	DD	imagerel $LN53+604
	DD	imagerel $unwind$PyUnicode_AsUnicodeAndSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_AsUnicodeAndSize DD 0a4801H
	DD	087448H
	DD	076443H
	DD	06543eH
	DD	09340bH
	DD	0c007320bH
xdata	ENDS
;	COMDAT ??_C@_0EL@OMFODIE@Impossible?5unicode?5object?5state?0@
CONST	SEGMENT
??_C@_0EL@OMFODIE@Impossible?5unicode?5object?5state?0@ DB 'Impossible un'
	DB	'icode object state, wstr and str should share memory already.'
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_AsUnicodeAndSize
_TEXT	SEGMENT
unicode$ = 48
size$ = 56
PyUnicode_AsUnicodeAndSize PROC				; COMDAT

; 3970 : {

$LN53:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	41 54		 push	 r12
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3971 :     const unsigned char *one_byte;
; 3972 : #if SIZEOF_WCHAR_T == 4
; 3973 :     const Py_UCS2 *two_bytes;
; 3974 : #else
; 3975 :     const Py_UCS4 *four_bytes;
; 3976 :     const Py_UCS4 *ucs4_end;
; 3977 :     Py_ssize_t num_surrogates;
; 3978 : #endif
; 3979 :     wchar_t *w;
; 3980 :     wchar_t *wchar_end;
; 3981 : 
; 3982 :     if (!PyUnicode_Check(unicode)) {

  0000b	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000f	4c 8b e2	 mov	 r12, rdx
  00012	48 8b d9	 mov	 rbx, rcx
  00015	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0001f	75 13		 jne	 SHORT $LN26@PyUnicode_@16

; 3983 :         PyErr_BadArgument();

  00021	e8 00 00 00 00	 call	 PyErr_BadArgument

; 3984 :         return NULL;

  00026	33 c0		 xor	 eax, eax

; 4078 : }

  00028	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	41 5c		 pop	 r12
  00033	c3		 ret	 0
$LN26@PyUnicode_@16:

; 3985 :     }
; 3986 :     if (_PyUnicode_WSTR(unicode) == NULL) {

  00034	48 83 79 78 00	 cmp	 QWORD PTR [rcx+120], 0
  00039	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0003e	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00043	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00048	0f 85 fa 00 00
	00		 jne	 $LN3@PyUnicode_@16

; 3987 :         /* Non-ASCII compact unicode object */
; 3988 :         assert(_PyUnicode_KIND(unicode) != 0);
; 3989 :         assert(PyUnicode_IS_READY(unicode));
; 3990 : 
; 3991 :         if (PyUnicode_KIND(unicode) == PyUnicode_4BYTE_KIND) {

  0004e	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00051	8b c1		 mov	 eax, ecx
  00053	24 1c		 and	 al, 28
  00055	3c 10		 cmp	 al, 16
  00057	0f 85 10 01 00
	00		 jne	 $LN24@PyUnicode_@16

; 3992 : #if SIZEOF_WCHAR_T == 2
; 3993 :             four_bytes = PyUnicode_4BYTE_DATA(unicode);

  0005d	f6 c1 20	 test	 cl, 32			; 00000020H
  00060	74 17		 je	 SHORT $LN31@PyUnicode_@16
  00062	f6 c1 40	 test	 cl, 64			; 00000040H
  00065	74 09		 je	 SHORT $LN29@PyUnicode_@16
  00067	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  0006e	eb 10		 jmp	 SHORT $LN32@PyUnicode_@16
$LN29@PyUnicode_@16:
  00070	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00077	eb 07		 jmp	 SHORT $LN32@PyUnicode_@16
$LN31@PyUnicode_@16:
  00079	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN32@PyUnicode_@16:

; 3994 :             ucs4_end = four_bytes + _PyUnicode_LENGTH(unicode);

  00080	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]

; 3995 :             num_surrogates = 0;

  00084	33 ed		 xor	 ebp, ebp
  00086	48 8d 34 88	 lea	 rsi, QWORD PTR [rax+rcx*4]
  0008a	8b fd		 mov	 edi, ebp

; 3996 : 
; 3997 :             for (; four_bytes < ucs4_end; ++four_bytes) {

  0008c	48 3b c6	 cmp	 rax, rsi
  0008f	73 14		 jae	 SHORT $LN21@PyUnicode_@16
$LL23@PyUnicode_@16:

; 3998 :                 if (*four_bytes > 0xFFFF)

  00091	81 38 ff ff 00
	00		 cmp	 DWORD PTR [rax], 65535	; 0000ffffH
  00097	76 03		 jbe	 SHORT $LN22@PyUnicode_@16

; 3999 :                     ++num_surrogates;

  00099	48 ff c7	 inc	 rdi
$LN22@PyUnicode_@16:

; 3996 : 
; 3997 :             for (; four_bytes < ucs4_end; ++four_bytes) {

  0009c	48 83 c0 04	 add	 rax, 4
  000a0	48 3b c6	 cmp	 rax, rsi
  000a3	72 ec		 jb	 SHORT $LL23@PyUnicode_@16
$LN21@PyUnicode_@16:

; 4000 :             }
; 4001 : 
; 4002 :             _PyUnicode_WSTR(unicode) = (wchar_t *) PyObject_MALLOC(
; 4003 :                     sizeof(wchar_t) * (_PyUnicode_LENGTH(unicode) + 1 + num_surrogates));

  000a5	48 03 cf	 add	 rcx, rdi
  000a8	48 8d 4c 09 02	 lea	 rcx, QWORD PTR [rcx+rcx+2]
  000ad	e8 00 00 00 00	 call	 PyObject_Malloc
  000b2	4c 8b d8	 mov	 r11, rax
  000b5	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 4004 :             if (!_PyUnicode_WSTR(unicode)) {

  000b9	48 85 c0	 test	 rax, rax

; 4005 :                 PyErr_NoMemory();
; 4006 :                 return NULL;

  000bc	0f 84 c5 00 00
	00		 je	 $LN52@PyUnicode_@16

; 4007 :             }
; 4008 :             _PyUnicode_WSTR_LENGTH(unicode) = _PyUnicode_LENGTH(unicode) + num_surrogates;

  000c2	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  000c6	48 8d 0c 07	 lea	 rcx, QWORD PTR [rdi+rax]

; 4009 : 
; 4010 :             w = _PyUnicode_WSTR(unicode);
; 4011 :             wchar_end = w + _PyUnicode_WSTR_LENGTH(unicode);
; 4012 :             four_bytes = PyUnicode_4BYTE_DATA(unicode);

  000ca	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  000cd	48 89 8b 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rcx
  000d4	a8 20		 test	 al, 32			; 00000020H
  000d6	74 16		 je	 SHORT $LN35@PyUnicode_@16
  000d8	a8 40		 test	 al, 64			; 00000040H
  000da	74 09		 je	 SHORT $LN33@PyUnicode_@16
  000dc	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  000e3	eb 10		 jmp	 SHORT $LN36@PyUnicode_@16
$LN33@PyUnicode_@16:
  000e5	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  000ec	eb 07		 jmp	 SHORT $LN36@PyUnicode_@16
$LN35@PyUnicode_@16:
  000ee	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
$LN36@PyUnicode_@16:

; 4013 :             for (; four_bytes < ucs4_end; ++four_bytes, ++w) {

  000f5	48 3b ce	 cmp	 rcx, rsi
  000f8	73 4a		 jae	 SHORT $LN16@PyUnicode_@16
  000fa	ba 40 28 00 00	 mov	 edx, 10304		; 00002840H
  000ff	41 b8 ff 03 00
	00		 mov	 r8d, 1023		; 000003ffH
  00105	41 b9 00 24 00
	00		 mov	 r9d, 9216		; 00002400H
  0010b	0f 1f 44 00 00	 npad	 5
$LL18@PyUnicode_@16:

; 4014 :                 if (*four_bytes > 0xFFFF) {

  00110	8b 01		 mov	 eax, DWORD PTR [rcx]
  00112	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00117	76 1a		 jbe	 SHORT $LN15@PyUnicode_@16

; 4015 :                     assert(*four_bytes <= MAX_UNICODE);
; 4016 :                     /* encode surrogate pair in this case */
; 4017 :                     *w++ = Py_UNICODE_HIGH_SURROGATE(*four_bytes);

  00119	c1 e8 0a	 shr	 eax, 10
  0011c	49 83 c3 02	 add	 r11, 2
  00120	66 2b c2	 sub	 ax, dx
  00123	66 41 89 43 fe	 mov	 WORD PTR [r11-2], ax

; 4018 :                     *w   = Py_UNICODE_LOW_SURROGATE(*four_bytes);

  00128	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  0012b	66 41 23 c0	 and	 ax, r8w
  0012f	66 41 2b c1	 sub	 ax, r9w
$LN15@PyUnicode_@16:

; 4019 :                 }
; 4020 :                 else
; 4021 :                     *w = *four_bytes;

  00133	48 83 c1 04	 add	 rcx, 4
  00137	66 41 89 03	 mov	 WORD PTR [r11], ax
  0013b	49 83 c3 02	 add	 r11, 2
  0013f	48 3b ce	 cmp	 rcx, rsi
  00142	72 cc		 jb	 SHORT $LL18@PyUnicode_@16
$LN16@PyUnicode_@16:

; 4022 : 
; 4023 :                 if (w > wchar_end) {
; 4024 :                     assert(0 && "Miscalculated string end");
; 4025 :                 }
; 4026 :             }
; 4027 :             *w = 0;

  00144	66 41 89 2b	 mov	 WORD PTR [r11], bp
$LN3@PyUnicode_@16:

; 4068 : #endif
; 4069 :             }
; 4070 :             else {
; 4071 :                 assert(0 && "This should never happen.");
; 4072 :             }
; 4073 :         }
; 4074 :     }
; 4075 :     if (size != NULL)

  00148	4d 85 e4	 test	 r12, r12
  0014b	0f 84 ec 00 00
	00		 je	 $LN1@PyUnicode_@16

; 4076 :         *size = PyUnicode_WSTR_LENGTH(unicode);

  00151	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00154	a8 40		 test	 al, 64			; 00000040H
  00156	0f 84 d6 00 00
	00		 je	 $LN41@PyUnicode_@16
  0015c	a8 20		 test	 al, 32			; 00000020H
  0015e	0f 84 ce 00 00
	00		 je	 $LN41@PyUnicode_@16
  00164	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  00168	e9 cc 00 00 00	 jmp	 $LN42@PyUnicode_@16
$LN24@PyUnicode_@16:

; 4028 : #else
; 4029 :             /* sizeof(wchar_t) == 4 */
; 4030 :             Py_FatalError("Impossible unicode object state, wstr and str "
; 4031 :                           "should share memory already.");
; 4032 :             return NULL;
; 4033 : #endif
; 4034 :         }
; 4035 :         else {
; 4036 :             _PyUnicode_WSTR(unicode) = (wchar_t *) PyObject_MALLOC(sizeof(wchar_t) *
; 4037 :                                                   (_PyUnicode_LENGTH(unicode) + 1));

  0016d	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00171	48 8d 4c 09 02	 lea	 rcx, QWORD PTR [rcx+rcx+2]
  00176	e8 00 00 00 00	 call	 PyObject_Malloc
  0017b	48 8b c8	 mov	 rcx, rax
  0017e	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 4038 :             if (!_PyUnicode_WSTR(unicode)) {

  00182	48 85 c0	 test	 rax, rax
  00185	75 0c		 jne	 SHORT $LN11@PyUnicode_@16
$LN52@PyUnicode_@16:

; 4039 :                 PyErr_NoMemory();

  00187	e8 00 00 00 00	 call	 PyErr_NoMemory

; 4040 :                 return NULL;

  0018c	33 c0		 xor	 eax, eax
  0018e	e9 ae 00 00 00	 jmp	 $LN51@PyUnicode_@16
$LN11@PyUnicode_@16:

; 4041 :             }
; 4042 :             if (!PyUnicode_IS_COMPACT_ASCII(unicode))

  00193	44 8b 4b 70	 mov	 r9d, DWORD PTR [rbx+112]
  00197	41 8b d1	 mov	 edx, r9d
  0019a	c1 ea 06	 shr	 edx, 6
  0019d	83 e2 01	 and	 edx, 1
  001a0	74 06		 je	 SHORT $LN9@PyUnicode_@16
  001a2	41 f6 c1 20	 test	 r9b, 32			; 00000020H
  001a6	75 0b		 jne	 SHORT $LN10@PyUnicode_@16
$LN9@PyUnicode_@16:

; 4043 :                 _PyUnicode_WSTR_LENGTH(unicode) = _PyUnicode_LENGTH(unicode);

  001a8	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  001ac	48 89 83 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rax
$LN10@PyUnicode_@16:

; 4044 :             w = _PyUnicode_WSTR(unicode);
; 4045 :             wchar_end = w + _PyUnicode_LENGTH(unicode);

  001b3	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  001b7	4c 8d 04 41	 lea	 r8, QWORD PTR [rcx+rax*2]

; 4046 : 
; 4047 :             if (PyUnicode_KIND(unicode) == PyUnicode_1BYTE_KIND) {

  001bb	41 8b c1	 mov	 eax, r9d
  001be	c1 e8 02	 shr	 eax, 2
  001c1	83 e0 07	 and	 eax, 7
  001c4	83 f8 01	 cmp	 eax, 1
  001c7	75 45		 jne	 SHORT $LN8@PyUnicode_@16

; 4048 :                 one_byte = PyUnicode_1BYTE_DATA(unicode);

  001c9	41 f6 c1 20	 test	 r9b, 32			; 00000020H
  001cd	74 16		 je	 SHORT $LN39@PyUnicode_@16
  001cf	85 d2		 test	 edx, edx
  001d1	74 09		 je	 SHORT $LN37@PyUnicode_@16
  001d3	48 8d 93 80 00
	00 00		 lea	 rdx, QWORD PTR [rbx+128]
  001da	eb 10		 jmp	 SHORT $LN40@PyUnicode_@16
$LN37@PyUnicode_@16:
  001dc	48 8d 93 a0 00
	00 00		 lea	 rdx, QWORD PTR [rbx+160]
  001e3	eb 07		 jmp	 SHORT $LN40@PyUnicode_@16
$LN39@PyUnicode_@16:
  001e5	48 8b 93 a0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+160]
$LN40@PyUnicode_@16:

; 4049 :                 for (; w < wchar_end; ++one_byte, ++w)

  001ec	49 3b c8	 cmp	 rcx, r8
  001ef	73 13		 jae	 SHORT $LN5@PyUnicode_@16
$LL7@PyUnicode_@16:

; 4050 :                     *w = *one_byte;

  001f1	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  001f4	48 83 c1 02	 add	 rcx, 2
  001f8	48 ff c2	 inc	 rdx
  001fb	66 89 41 fe	 mov	 WORD PTR [rcx-2], ax
  001ff	49 3b c8	 cmp	 rcx, r8
  00202	72 ed		 jb	 SHORT $LL7@PyUnicode_@16
$LN5@PyUnicode_@16:

; 4051 :                 /* null-terminate the wstr */
; 4052 :                 *w = 0;

  00204	33 ed		 xor	 ebp, ebp
  00206	66 89 29	 mov	 WORD PTR [rcx], bp
  00209	e9 3a ff ff ff	 jmp	 $LN3@PyUnicode_@16
$LN8@PyUnicode_@16:

; 4053 :             }
; 4054 :             else if (PyUnicode_KIND(unicode) == PyUnicode_2BYTE_KIND) {

  0020e	83 f8 02	 cmp	 eax, 2
  00211	0f 85 31 ff ff
	ff		 jne	 $LN3@PyUnicode_@16

; 4055 : #if SIZEOF_WCHAR_T == 4
; 4056 :                 two_bytes = PyUnicode_2BYTE_DATA(unicode);
; 4057 :                 for (; w < wchar_end; ++two_bytes, ++w)
; 4058 :                     *w = *two_bytes;
; 4059 :                 /* null-terminate the wstr */
; 4060 :                 *w = 0;
; 4061 : #else
; 4062 :                 /* sizeof(wchar_t) == 2 */
; 4063 :                 PyObject_FREE(_PyUnicode_WSTR(unicode));

  00217	e8 00 00 00 00	 call	 PyObject_Free

; 4064 :                 _PyUnicode_WSTR(unicode) = NULL;
; 4065 :                 Py_FatalError("Impossible unicode object state, wstr "
; 4066 :                               "and str should share memory already.");

  0021c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EL@OMFODIE@Impossible?5unicode?5object?5state?0@
  00223	33 ed		 xor	 ebp, ebp
  00225	48 89 6b 78	 mov	 QWORD PTR [rbx+120], rbp
  00229	e8 00 00 00 00	 call	 Py_FatalError

; 4067 :                 return NULL;

  0022e	33 c0		 xor	 eax, eax
  00230	eb 0f		 jmp	 SHORT $LN51@PyUnicode_@16
$LN41@PyUnicode_@16:

; 4076 :         *size = PyUnicode_WSTR_LENGTH(unicode);

  00232	48 8b 83 90 00
	00 00		 mov	 rax, QWORD PTR [rbx+144]
$LN42@PyUnicode_@16:
  00239	49 89 04 24	 mov	 QWORD PTR [r12], rax
$LN1@PyUnicode_@16:

; 4077 :     return _PyUnicode_WSTR(unicode);

  0023d	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]
$LN51@PyUnicode_@16:
  00241	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00246	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0024b	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 4078 : }

  00250	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00255	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00259	41 5c		 pop	 r12
  0025b	c3		 ret	 0
PyUnicode_AsUnicodeAndSize ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsUnicode
; Function compile flags: /Ogtpy
;	COMDAT PyUnicode_AsUnicode
_TEXT	SEGMENT
unicode$ = 8
PyUnicode_AsUnicode PROC				; COMDAT

; 4083 :     return PyUnicode_AsUnicodeAndSize(unicode, NULL);

  00000	33 d2		 xor	 edx, edx

; 4084 : }

  00002	e9 00 00 00 00	 jmp	 PyUnicode_AsUnicodeAndSize
PyUnicode_AsUnicode ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_GetSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_GetSize DD imagerel $LN10
	DD	imagerel $LN10+125
	DD	imagerel $unwind$PyUnicode_GetSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_GetSize DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_GetSize
_TEXT	SEGMENT
unicode$ = 48
PyUnicode_GetSize PROC					; COMDAT

; 4089 : {

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4090 :     if (!PyUnicode_Check(unicode)) {

  00006	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00017	75 0f		 jne	 SHORT $LN1@PyUnicode_@17

; 4091 :         PyErr_BadArgument();

  00019	e8 00 00 00 00	 call	 PyErr_BadArgument
$onError$128945:

; 4095 : 
; 4096 :   onError:
; 4097 :     return -1;

  0001e	48 83 c8 ff	 or	 rax, -1

; 4098 : }

  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5b		 pop	 rbx
  00027	c3		 ret	 0
$LN1@PyUnicode_@17:

; 4092 :         goto onError;
; 4093 :     }
; 4094 :     return PyUnicode_GET_SIZE(unicode);

  00028	48 83 79 78 00	 cmp	 QWORD PTR [rcx+120], 0
  0002d	74 22		 je	 SHORT $LN8@PyUnicode_@17
  0002f	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00032	a8 40		 test	 al, 64			; 00000040H
  00034	74 0e		 je	 SHORT $LN4@PyUnicode_@17
  00036	a8 20		 test	 al, 32			; 00000020H
  00038	74 0a		 je	 SHORT $LN4@PyUnicode_@17
  0003a	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]

; 4098 : }

  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5b		 pop	 rbx
  00043	c3		 ret	 0
$LN4@PyUnicode_@17:

; 4092 :         goto onError;
; 4093 :     }
; 4094 :     return PyUnicode_GET_SIZE(unicode);

  00044	48 8b 81 90 00
	00 00		 mov	 rax, QWORD PTR [rcx+144]

; 4098 : }

  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5b		 pop	 rbx
  00050	c3		 ret	 0
$LN8@PyUnicode_@17:

; 4092 :         goto onError;
; 4093 :     }
; 4094 :     return PyUnicode_GET_SIZE(unicode);

  00051	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  00056	44 8b 5b 70	 mov	 r11d, DWORD PTR [rbx+112]
  0005a	41 f6 c3 40	 test	 r11b, 64		; 00000040H
  0005e	74 10		 je	 SHORT $LN6@PyUnicode_@17
  00060	41 f6 c3 20	 test	 r11b, 32		; 00000020H
  00064	74 0a		 je	 SHORT $LN6@PyUnicode_@17
  00066	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]

; 4098 : }

  0006a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006e	5b		 pop	 rbx
  0006f	c3		 ret	 0
$LN6@PyUnicode_@17:

; 4092 :         goto onError;
; 4093 :     }
; 4094 :     return PyUnicode_GET_SIZE(unicode);

  00070	48 8b 83 90 00
	00 00		 mov	 rax, QWORD PTR [rbx+144]

; 4098 : }

  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	5b		 pop	 rbx
  0007c	c3		 ret	 0
PyUnicode_GetSize ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_GetLength
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_GetLength DD imagerel $LN8
	DD	imagerel $LN8+66
	DD	imagerel $unwind$PyUnicode_GetLength
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_GetLength DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_GetLength
_TEXT	SEGMENT
unicode$ = 48
PyUnicode_GetLength PROC				; COMDAT

; 4102 : {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4103 :     if (!PyUnicode_Check(unicode)) {

  00006	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00017	75 0f		 jne	 SHORT $LN2@PyUnicode_@18

; 4104 :         PyErr_BadArgument();

  00019	e8 00 00 00 00	 call	 PyErr_BadArgument
$LN7@PyUnicode_@18:

; 4105 :         return -1;

  0001e	48 83 c8 ff	 or	 rax, -1

; 4110 : }

  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5b		 pop	 rbx
  00027	c3		 ret	 0
$LN2@PyUnicode_@18:

; 4106 :     }
; 4107 :     if (PyUnicode_READY(unicode) == -1)

  00028	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0002c	75 0a		 jne	 SHORT $LN1@PyUnicode_@18
  0002e	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00033	83 f8 ff	 cmp	 eax, -1

; 4108 :         return -1;

  00036	74 e6		 je	 SHORT $LN7@PyUnicode_@18
$LN1@PyUnicode_@18:

; 4109 :     return PyUnicode_GET_LENGTH(unicode);

  00038	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]

; 4110 : }

  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5b		 pop	 rbx
  00041	c3		 ret	 0
PyUnicode_GetLength ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@DOEPEGBG@string?5index?5out?5of?5range?$AA@ ; `string'
PUBLIC	PyUnicode_ReadChar
EXTRN	PyExc_IndexError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_ReadChar DD imagerel $LN27
	DD	imagerel $LN27+358
	DD	imagerel $unwind$PyUnicode_ReadChar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_ReadChar DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BK@DOEPEGBG@string?5index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BK@DOEPEGBG@string?5index?5out?5of?5range?$AA@ DB 'string index ou'
	DB	't of range', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_ReadChar
_TEXT	SEGMENT
unicode$ = 48
index$ = 56
PyUnicode_ReadChar PROC					; COMDAT

; 4114 : {

$LN27:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4115 :     if (!PyUnicode_Check(unicode) || PyUnicode_READY(unicode) == -1) {

  0000a	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0001e	0f 84 2f 01 00
	00		 je	 $LN3@PyUnicode_@19
  00024	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00028	75 0e		 jne	 SHORT $LN25@PyUnicode_@19
  0002a	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0002f	83 f8 ff	 cmp	 eax, -1
  00032	0f 84 1b 01 00
	00		 je	 $LN3@PyUnicode_@19
$LN25@PyUnicode_@19:

; 4117 :         return (Py_UCS4)-1;
; 4118 :     }
; 4119 :     if (index < 0 || index >= PyUnicode_GET_LENGTH(unicode)) {

  00038	48 85 ff	 test	 rdi, rdi
  0003b	0f 88 f1 00 00
	00		 js	 $LN1@PyUnicode_@19
  00041	48 3b 7b 60	 cmp	 rdi, QWORD PTR [rbx+96]
  00045	0f 8d e7 00 00
	00		 jge	 $LN1@PyUnicode_@19

; 4121 :         return (Py_UCS4)-1;
; 4122 :     }
; 4123 :     return PyUnicode_READ_CHAR(unicode, index);

  0004b	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0004e	8b c8		 mov	 ecx, eax
  00050	c1 e9 02	 shr	 ecx, 2
  00053	83 e1 07	 and	 ecx, 7
  00056	83 f9 01	 cmp	 ecx, 1
  00059	75 47		 jne	 SHORT $LN23@PyUnicode_@19
  0005b	a8 20		 test	 al, 32			; 00000020H
  0005d	74 2d		 je	 SHORT $LN11@PyUnicode_@19
  0005f	a8 40		 test	 al, 64			; 00000040H
  00061	74 13		 je	 SHORT $LN9@PyUnicode_@19
  00063	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  00067	0f b6 04 3b	 movzx	 eax, BYTE PTR [rbx+rdi]

; 4124 : }

  0006b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5f		 pop	 rdi
  00075	c3		 ret	 0
$LN9@PyUnicode_@19:

; 4121 :         return (Py_UCS4)-1;
; 4122 :     }
; 4123 :     return PyUnicode_READ_CHAR(unicode, index);

  00076	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  0007d	0f b6 04 3b	 movzx	 eax, BYTE PTR [rbx+rdi]

; 4124 : }

  00081	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00086	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008a	5f		 pop	 rdi
  0008b	c3		 ret	 0
$LN11@PyUnicode_@19:

; 4121 :         return (Py_UCS4)-1;
; 4122 :     }
; 4123 :     return PyUnicode_READ_CHAR(unicode, index);

  0008c	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
  00093	0f b6 04 3b	 movzx	 eax, BYTE PTR [rbx+rdi]

; 4124 : }

  00097	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a0	5f		 pop	 rdi
  000a1	c3		 ret	 0
$LN23@PyUnicode_@19:

; 4121 :         return (Py_UCS4)-1;
; 4122 :     }
; 4123 :     return PyUnicode_READ_CHAR(unicode, index);

  000a2	83 f9 02	 cmp	 ecx, 2
  000a5	75 47		 jne	 SHORT $LN21@PyUnicode_@19
  000a7	a8 20		 test	 al, 32			; 00000020H
  000a9	74 2d		 je	 SHORT $LN15@PyUnicode_@19
  000ab	a8 40		 test	 al, 64			; 00000040H
  000ad	74 13		 je	 SHORT $LN13@PyUnicode_@19
  000af	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  000b3	0f b7 04 7b	 movzx	 eax, WORD PTR [rbx+rdi*2]

; 4124 : }

  000b7	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000bc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c0	5f		 pop	 rdi
  000c1	c3		 ret	 0
$LN13@PyUnicode_@19:

; 4121 :         return (Py_UCS4)-1;
; 4122 :     }
; 4123 :     return PyUnicode_READ_CHAR(unicode, index);

  000c2	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  000c9	0f b7 04 7b	 movzx	 eax, WORD PTR [rbx+rdi*2]

; 4124 : }

  000cd	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000d2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d6	5f		 pop	 rdi
  000d7	c3		 ret	 0
$LN15@PyUnicode_@19:

; 4121 :         return (Py_UCS4)-1;
; 4122 :     }
; 4123 :     return PyUnicode_READ_CHAR(unicode, index);

  000d8	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
  000df	0f b7 04 7b	 movzx	 eax, WORD PTR [rbx+rdi*2]

; 4124 : }

  000e3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000e8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ec	5f		 pop	 rdi
  000ed	c3		 ret	 0
$LN21@PyUnicode_@19:

; 4121 :         return (Py_UCS4)-1;
; 4122 :     }
; 4123 :     return PyUnicode_READ_CHAR(unicode, index);

  000ee	a8 20		 test	 al, 32			; 00000020H
  000f0	74 2b		 je	 SHORT $LN19@PyUnicode_@19
  000f2	a8 40		 test	 al, 64			; 00000040H
  000f4	74 12		 je	 SHORT $LN17@PyUnicode_@19
  000f6	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  000fa	8b 04 bb	 mov	 eax, DWORD PTR [rbx+rdi*4]

; 4124 : }

  000fd	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00102	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00106	5f		 pop	 rdi
  00107	c3		 ret	 0
$LN17@PyUnicode_@19:

; 4121 :         return (Py_UCS4)-1;
; 4122 :     }
; 4123 :     return PyUnicode_READ_CHAR(unicode, index);

  00108	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  0010f	8b 04 bb	 mov	 eax, DWORD PTR [rbx+rdi*4]

; 4124 : }

  00112	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00117	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011b	5f		 pop	 rdi
  0011c	c3		 ret	 0
$LN19@PyUnicode_@19:

; 4121 :         return (Py_UCS4)-1;
; 4122 :     }
; 4123 :     return PyUnicode_READ_CHAR(unicode, index);

  0011d	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
  00124	8b 04 bb	 mov	 eax, DWORD PTR [rbx+rdi*4]

; 4124 : }

  00127	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0012c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00130	5f		 pop	 rdi
  00131	c3		 ret	 0
$LN1@PyUnicode_@19:

; 4120 :         PyErr_SetString(PyExc_IndexError, "string index out of range");

  00132	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00139	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@DOEPEGBG@string?5index?5out?5of?5range?$AA@
  00140	e8 00 00 00 00	 call	 PyErr_SetString
  00145	83 c8 ff	 or	 eax, -1			; ffffffffH

; 4124 : }

  00148	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0014d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00151	5f		 pop	 rdi
  00152	c3		 ret	 0
$LN3@PyUnicode_@19:

; 4116 :         PyErr_BadArgument();

  00153	e8 00 00 00 00	 call	 PyErr_BadArgument

; 4124 : }

  00158	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0015d	83 c8 ff	 or	 eax, -1			; ffffffffH
  00160	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00164	5f		 pop	 rdi
  00165	c3		 ret	 0
PyUnicode_ReadChar ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_GetDefaultEncoding
; Function compile flags: /Ogtpy
;	COMDAT PyUnicode_GetDefaultEncoding
_TEXT	SEGMENT
PyUnicode_GetDefaultEncoding PROC			; COMDAT

; 4152 :     return "utf-8";

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@

; 4153 : }

  00007	c3		 ret	 0
PyUnicode_GetDefaultEncoding ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@GMOJNECI@make_decode_exception?$AA@	; `string'
EXTRN	PyUnicodeDecodeError_SetReason:PROC
EXTRN	PyUnicodeDecodeError_SetEnd:PROC
EXTRN	PyUnicodeDecodeError_SetStart:PROC
EXTRN	PyUnicodeDecodeError_Create:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$make_decode_exception DD imagerel make_decode_exception
	DD	imagerel make_decode_exception+327
	DD	imagerel $unwind$make_decode_exception
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$make_decode_exception DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0BG@GMOJNECI@make_decode_exception?$AA@
CONST	SEGMENT
??_C@_0BG@GMOJNECI@make_decode_exception?$AA@ DB 'make_decode_exception', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT make_decode_exception
_TEXT	SEGMENT
exceptionObject$ = 64
encoding$ = 72
input$ = 80
length$ = 88
startpos$ = 96
endpos$ = 104
reason$ = 112
make_decode_exception PROC				; COMDAT

; 4162 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 4163 :     if (*exceptionObject == NULL) {

  0000d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00010	4d 8b d1	 mov	 r10, r9
  00013	4d 8b d8	 mov	 r11, r8
  00016	48 8b da	 mov	 rbx, rdx
  00019	48 85 c9	 test	 rcx, rcx
  0001c	75 35		 jne	 SHORT $LN9@make_decod

; 4164 :         *exceptionObject = PyUnicodeDecodeError_Create(
; 4165 :             encoding, input, length, startpos, endpos, reason);

  0001e	48 8b 44 24 70	 mov	 rax, QWORD PTR reason$[rsp]
  00023	4c 8b 4c 24 60	 mov	 r9, QWORD PTR startpos$[rsp]
  00028	4d 8b c2	 mov	 r8, r10
  0002b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00030	48 8b 44 24 68	 mov	 rax, QWORD PTR endpos$[rsp]
  00035	49 8b d3	 mov	 rdx, r11
  00038	48 8b cb	 mov	 rcx, rbx
  0003b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00040	e8 00 00 00 00	 call	 PyUnicodeDecodeError_Create
  00045	48 89 07	 mov	 QWORD PTR [rdi], rax

; 4179 : }

  00048	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0004d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
$LN9@make_decod:

; 4166 :     }
; 4167 :     else {
; 4168 :         if (PyUnicodeDecodeError_SetStart(*exceptionObject, startpos))

  00053	48 8b 54 24 60	 mov	 rdx, QWORD PTR startpos$[rsp]
  00058	e8 00 00 00 00	 call	 PyUnicodeDecodeError_SetStart
  0005d	85 c0		 test	 eax, eax
  0005f	75 26		 jne	 SHORT $onError$129137

; 4169 :             goto onError;
; 4170 :         if (PyUnicodeDecodeError_SetEnd(*exceptionObject, endpos))

  00061	48 8b 54 24 68	 mov	 rdx, QWORD PTR endpos$[rsp]
  00066	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00069	e8 00 00 00 00	 call	 PyUnicodeDecodeError_SetEnd
  0006e	85 c0		 test	 eax, eax
  00070	75 15		 jne	 SHORT $onError$129137

; 4171 :             goto onError;
; 4172 :         if (PyUnicodeDecodeError_SetReason(*exceptionObject, reason))

  00072	48 8b 54 24 70	 mov	 rdx, QWORD PTR reason$[rsp]
  00077	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0007a	e8 00 00 00 00	 call	 PyUnicodeDecodeError_SetReason
  0007f	85 c0		 test	 eax, eax
  00081	0f 84 b5 00 00
	00		 je	 $LN2@make_decod
$onError$129137:

; 4173 :             goto onError;
; 4174 :     }
; 4175 :     return;
; 4176 : 
; 4177 : onError:
; 4178 :     Py_CLEAR(*exceptionObject);

  00087	4c 8b 0f	 mov	 r9, QWORD PTR [rdi]
  0008a	4d 85 c9	 test	 r9, r9
  0008d	0f 84 a9 00 00
	00		 je	 $LN2@make_decod
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@GMOJNECI@make_decode_exception?$AA@
  000a1	41 b8 52 10 00
	00		 mov	 r8d, 4178		; 00001052H
  000a7	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000af	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b4	85 c0		 test	 eax, eax
  000b6	0f 85 80 00 00
	00		 jne	 $LN2@make_decod
  000bc	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  000bf	48 c7 07 00 00
	00 00		 mov	 QWORD PTR [rdi], 0
  000c6	e8 00 00 00 00	 call	 _Py_PXCTX
  000cb	85 c0		 test	 eax, eax
  000cd	75 6d		 jne	 SHORT $LN2@make_decod
  000cf	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000d3	a8 20		 test	 al, 32			; 00000020H
  000d5	75 5d		 jne	 SHORT $LN16@make_decod
  000d7	84 c0		 test	 al, al
  000d9	78 59		 js	 SHORT $LN16@make_decod
  000db	a8 02		 test	 al, 2
  000dd	75 5d		 jne	 SHORT $LN2@make_decod
  000df	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000e3	75 57		 jne	 SHORT $LN2@make_decod
  000e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000f3	4c 8b cb	 mov	 r9, rbx
  000f6	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000fc	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00104	e8 00 00 00 00	 call	 _PyParallel_Guard
  00109	48 8b cb	 mov	 rcx, rbx
  0010c	85 c0		 test	 eax, eax
  0010e	74 0f		 je	 SHORT $LN21@make_decod

; 4179 : }

  00110	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00115	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00119	5f		 pop	 rdi
  0011a	e9 00 00 00 00	 jmp	 _Px_Dealloc

; 4173 :             goto onError;
; 4174 :     }
; 4175 :     return;
; 4176 : 
; 4177 : onError:
; 4178 :     Py_CLEAR(*exceptionObject);

$LN21@make_decod:
  0011f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 4179 : }

  00123	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00128	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0012c	5f		 pop	 rdi
  0012d	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]

; 4173 :             goto onError;
; 4174 :     }
; 4175 :     return;
; 4176 : 
; 4177 : onError:
; 4178 :     Py_CLEAR(*exceptionObject);

$LN16@make_decod:
  00134	48 8b cb	 mov	 rcx, rbx
  00137	e8 00 00 00 00	 call	 Px_DecRef
$LN2@make_decod:

; 4179 : }

  0013c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00141	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00145	5f		 pop	 rdi
  00146	c3		 ret	 0
make_decode_exception ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EB@NFPJKBDG@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef@ ; `string'
PUBLIC	_PyUnicode_EncodeUTF7
EXTRN	_PyBytes_Resize:PROC
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_EncodeUTF7 DD imagerel $LN56
	DD	imagerel $LN56+841
	DD	imagerel $unwind$_PyUnicode_EncodeUTF7
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_EncodeUTF7 DD 0c5401H
	DD	0ec454H
	DD	0d744fH
	DD	0f3411H
	DD	0f00d5211H
	DD	0d009e00bH
	DD	050066007H
xdata	ENDS
;	COMDAT ??_C@_0EB@NFPJKBDG@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef@
CONST	SEGMENT
??_C@_0EB@NFPJKBDG@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef@ DB 'ABCDEFGHIJKLMNOP'
	DB	'QRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyUnicode_EncodeUTF7
_TEXT	SEGMENT
v$ = 32
start$1$ = 40
len$1$ = 96
str$ = 96
base64SetO$ = 104
base64WhiteSpace$ = 112
errors$ = 120
_PyUnicode_EncodeUTF7 PROC				; COMDAT

; 4605 : {

$LN56:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 4606 :     int kind;
; 4607 :     void *data;
; 4608 :     Py_ssize_t len;
; 4609 :     PyObject *v;
; 4610 :     int inShift = 0;

  00011	33 c0		 xor	 eax, eax

; 4611 :     Py_ssize_t i;
; 4612 :     unsigned int base64bits = 0;
; 4613 :     unsigned long base64buffer = 0;
; 4614 :     char * out;
; 4615 :     char * start;
; 4616 : 
; 4617 :     if (PyUnicode_READY(str) == -1)

  00013	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00017	45 8b f0	 mov	 r14d, r8d
  0001a	44 8b fa	 mov	 r15d, edx
  0001d	48 8b d9	 mov	 rbx, rcx
  00020	44 8b e8	 mov	 r13d, eax
  00023	8b f0		 mov	 esi, eax
  00025	8b e8		 mov	 ebp, eax
  00027	75 1e		 jne	 SHORT $LN33@PyUnicode_@20
  00029	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0002e	83 f8 ff	 cmp	 eax, -1
  00031	75 14		 jne	 SHORT $LN33@PyUnicode_@20

; 4618 :         return NULL;

  00033	33 c0		 xor	 eax, eax

; 4698 :         return NULL;
; 4699 :     return v;
; 4700 : }

  00035	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  0003a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003e	41 5f		 pop	 r15
  00040	41 5e		 pop	 r14
  00042	41 5d		 pop	 r13
  00044	5e		 pop	 rsi
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
$LN33@PyUnicode_@20:

; 4619 :     kind = PyUnicode_KIND(str);

  00047	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0004a	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  0004f	4c 89 64 24 70	 mov	 QWORD PTR [rsp+112], r12
  00054	8b f8		 mov	 edi, eax
  00056	c1 ef 02	 shr	 edi, 2
  00059	83 e7 07	 and	 edi, 7

; 4620 :     data = PyUnicode_DATA(str);

  0005c	a8 20		 test	 al, 32			; 00000020H
  0005e	74 16		 je	 SHORT $LN40@PyUnicode_@20
  00060	a8 40		 test	 al, 64			; 00000040H
  00062	74 09		 je	 SHORT $LN38@PyUnicode_@20
  00064	4c 8d a3 80 00
	00 00		 lea	 r12, QWORD PTR [rbx+128]
  0006b	eb 10		 jmp	 SHORT $LN41@PyUnicode_@20
$LN38@PyUnicode_@20:
  0006d	4c 8d a3 a0 00
	00 00		 lea	 r12, QWORD PTR [rbx+160]
  00074	eb 07		 jmp	 SHORT $LN41@PyUnicode_@20
$LN40@PyUnicode_@20:
  00076	4c 8b a3 a0 00
	00 00		 mov	 r12, QWORD PTR [rbx+160]
$LN41@PyUnicode_@20:

; 4621 :     len = PyUnicode_GET_LENGTH(str);

  0007d	48 8b 5b 60	 mov	 rbx, QWORD PTR [rbx+96]
  00081	48 89 5c 24 60	 mov	 QWORD PTR len$1$[rsp], rbx

; 4622 : 
; 4623 :     if (len == 0)

  00086	48 85 db	 test	 rbx, rbx
  00089	75 0e		 jne	 SHORT $LN32@PyUnicode_@20

; 4624 :         return PyBytes_FromStringAndSize(NULL, 0);

  0008b	33 d2		 xor	 edx, edx
  0008d	33 c9		 xor	 ecx, ecx
  0008f	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00094	e9 94 02 00 00	 jmp	 $LN55@PyUnicode_@20
$LN32@PyUnicode_@20:

; 4625 : 
; 4626 :     /* It might be possible to tighten this worst case */
; 4627 :     if (len > PY_SSIZE_T_MAX / 8)

  00099	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  000a3	48 3b d8	 cmp	 rbx, rax
  000a6	7e 0a		 jle	 SHORT $LN31@PyUnicode_@20

; 4628 :         return PyErr_NoMemory();

  000a8	e8 00 00 00 00	 call	 PyErr_NoMemory
  000ad	e9 7b 02 00 00	 jmp	 $LN55@PyUnicode_@20
$LN31@PyUnicode_@20:

; 4629 :     v = PyBytes_FromStringAndSize(NULL, len * 8);

  000b2	48 8d 14 dd 00
	00 00 00	 lea	 rdx, QWORD PTR [rbx*8]
  000ba	33 c9		 xor	 ecx, ecx
  000bc	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000c1	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 4630 :     if (v == NULL)

  000c6	48 85 c0	 test	 rax, rax
  000c9	0f 84 5e 02 00
	00		 je	 $LN55@PyUnicode_@20
$LN30@PyUnicode_@20:

; 4631 :         return NULL;
; 4632 : 
; 4633 :     start = out = PyBytes_AS_STRING(v);

  000cf	4c 8d 40 78	 lea	 r8, QWORD PTR [rax+120]

; 4634 :     for (i = 0; i < len; ++i) {

  000d3	45 33 d2	 xor	 r10d, r10d

; 4635 :         Py_UCS4 ch = PyUnicode_READ(kind, data, i);

  000d6	4c 63 df	 movsxd	 r11, edi
  000d9	4c 89 44 24 28	 mov	 QWORD PTR start$1$[rsp], r8
  000de	48 85 db	 test	 rbx, rbx
  000e1	0f 8e 21 02 00
	00		 jle	 $LN2@PyUnicode_@20

; 4634 :     for (i = 0; i < len; ++i) {

  000e7	41 8d 7a 06	 lea	 edi, QWORD PTR [r10+6]
  000eb	0f 1f 44 00 00	 npad	 5
$LL52@PyUnicode_@20:

; 4621 :     len = PyUnicode_GET_LENGTH(str);

  000f0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:__ImageBase

; 4635 :         Py_UCS4 ch = PyUnicode_READ(kind, data, i);

  000f7	49 83 fb 01	 cmp	 r11, 1
  000fb	75 07		 jne	 SHORT $LN44@PyUnicode_@20
  000fd	43 0f b6 14 22	 movzx	 edx, BYTE PTR [r10+r12]
  00102	eb 11		 jmp	 SHORT $LN43@PyUnicode_@20
$LN44@PyUnicode_@20:
  00104	49 83 fb 02	 cmp	 r11, 2
  00108	75 07		 jne	 SHORT $LN42@PyUnicode_@20
  0010a	43 0f b7 14 54	 movzx	 edx, WORD PTR [r12+r10*2]
  0010f	eb 04		 jmp	 SHORT $LN43@PyUnicode_@20
$LN42@PyUnicode_@20:
  00111	43 8b 14 94	 mov	 edx, DWORD PTR [r12+r10*4]
$LN43@PyUnicode_@20:

; 4636 : 
; 4637 :         if (inShift) {

  00115	45 85 ed	 test	 r13d, r13d
  00118	0f 84 a2 00 00
	00		 je	 $LN26@PyUnicode_@20

; 4638 :             if (ENCODE_DIRECT(ch, !base64SetO, !base64WhiteSpace)) {

  0011e	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  00121	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  00124	0f 87 ed 00 00
	00		 ja	 $encode_char$129488
  0012a	8b c2		 mov	 eax, edx
  0012c	42 0f b6 8c 08
	00 00 00 00	 movzx	 ecx, BYTE PTR utf7_category[rax+r9]
  00135	84 c9		 test	 cl, cl
  00137	74 1c		 je	 SHORT $LN24@PyUnicode_@20
  00139	45 85 f6	 test	 r14d, r14d
  0013c	75 05		 jne	 SHORT $LN23@PyUnicode_@20
  0013e	80 f9 02	 cmp	 cl, 2
  00141	74 12		 je	 SHORT $LN24@PyUnicode_@20
$LN23@PyUnicode_@20:
  00143	45 85 ff	 test	 r15d, r15d
  00146	0f 85 cb 00 00
	00		 jne	 $encode_char$129488
  0014c	80 f9 01	 cmp	 cl, 1
  0014f	0f 85 c2 00 00
	00		 jne	 $encode_char$129488
$LN24@PyUnicode_@20:

; 4639 :                 /* shifting out */
; 4640 :                 if (base64bits) { /* output remaining bits */

  00155	85 f6		 test	 esi, esi
  00157	74 23		 je	 SHORT $LN53@PyUnicode_@20

; 4641 :                     *out++ = TO_BASE64(base64buffer << (6-base64bits));

  00159	8b c5		 mov	 eax, ebp
  0015b	8b cf		 mov	 ecx, edi
  0015d	49 ff c0	 inc	 r8
  00160	2b ce		 sub	 ecx, esi
  00162	d3 e0		 shl	 eax, cl
  00164	83 e0 3f	 and	 eax, 63			; 0000003fH
  00167	42 0f b6 84 08
	00 00 00 00	 movzx	 eax, BYTE PTR ??_C@_0EB@NFPJKBDG@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef@[rax+r9]
  00170	41 88 40 ff	 mov	 BYTE PTR [r8-1], al

; 4642 :                     base64buffer = 0;

  00174	33 c0		 xor	 eax, eax
  00176	8b e8		 mov	 ebp, eax

; 4643 :                     base64bits = 0;

  00178	8b f0		 mov	 esi, eax
  0017a	eb 02		 jmp	 SHORT $LN22@PyUnicode_@20
$LN53@PyUnicode_@20:

; 4621 :     len = PyUnicode_GET_LENGTH(str);

  0017c	33 c0		 xor	 eax, eax
$LN22@PyUnicode_@20:

; 4644 :                 }
; 4645 :                 inShift = 0;

  0017e	44 8b e8	 mov	 r13d, eax

; 4646 :                 /* Characters not in the BASE64 set implicitly unshift the sequence
; 4647 :                    so no '-' is required, except if the character is itself a '-' */
; 4648 :                 if (IS_BASE64(ch) || ch == '-') {

  00181	83 fa 41	 cmp	 edx, 65			; 00000041H
  00184	72 05		 jb	 SHORT $LN19@PyUnicode_@20
  00186	83 fa 5a	 cmp	 edx, 90			; 0000005aH
  00189	76 23		 jbe	 SHORT $LN20@PyUnicode_@20
$LN19@PyUnicode_@20:
  0018b	83 fa 61	 cmp	 edx, 97			; 00000061H
  0018e	72 05		 jb	 SHORT $LN18@PyUnicode_@20
  00190	83 fa 7a	 cmp	 edx, 122		; 0000007aH
  00193	76 19		 jbe	 SHORT $LN20@PyUnicode_@20
$LN18@PyUnicode_@20:
  00195	83 fa 30	 cmp	 edx, 48			; 00000030H
  00198	72 05		 jb	 SHORT $LN17@PyUnicode_@20
  0019a	83 fa 39	 cmp	 edx, 57			; 00000039H
  0019d	76 0f		 jbe	 SHORT $LN20@PyUnicode_@20
$LN17@PyUnicode_@20:
  0019f	83 fa 2b	 cmp	 edx, 43			; 0000002bH
  001a2	74 0a		 je	 SHORT $LN20@PyUnicode_@20
  001a4	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  001a7	74 05		 je	 SHORT $LN20@PyUnicode_@20
  001a9	83 fa 2d	 cmp	 edx, 45			; 0000002dH
  001ac	75 07		 jne	 SHORT $LN21@PyUnicode_@20
$LN20@PyUnicode_@20:

; 4649 :                     *out++ = '-';

  001ae	41 c6 00 2d	 mov	 BYTE PTR [r8], 45	; 0000002dH
  001b2	49 ff c0	 inc	 r8
$LN21@PyUnicode_@20:

; 4650 :                 }
; 4651 :                 *out++ = (char) ch;

  001b5	41 88 10	 mov	 BYTE PTR [r8], dl
  001b8	49 ff c0	 inc	 r8

; 4652 :             }
; 4653 :             else {
; 4654 :                 goto encode_char;
; 4655 :             }
; 4656 :         }
; 4657 :         else { /* not in a shift sequence */

  001bb	e9 09 01 00 00	 jmp	 $LN28@PyUnicode_@20
$LN26@PyUnicode_@20:

; 4658 :             if (ch == '+') {

  001c0	83 fa 2b	 cmp	 edx, 43			; 0000002bH
  001c3	75 0f		 jne	 SHORT $LN14@PyUnicode_@20

; 4659 :                 *out++ = '+';

  001c5	66 41 c7 00 2b
	2d		 mov	 WORD PTR [r8], 11563	; 00002d2bH

; 4660 :                         *out++ = '-';

  001cb	49 83 c0 02	 add	 r8, 2
  001cf	e9 f5 00 00 00	 jmp	 $LN28@PyUnicode_@20
$LN14@PyUnicode_@20:

; 4661 :             }
; 4662 :             else if (ENCODE_DIRECT(ch, !base64SetO, !base64WhiteSpace)) {

  001d4	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  001d7	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  001da	77 2e		 ja	 SHORT $LN12@PyUnicode_@20
  001dc	8b c2		 mov	 eax, edx
  001de	42 0f b6 8c 08
	00 00 00 00	 movzx	 ecx, BYTE PTR utf7_category[rax+r9]
  001e7	84 c9		 test	 cl, cl
  001e9	74 14		 je	 SHORT $LN11@PyUnicode_@20
  001eb	45 85 f6	 test	 r14d, r14d
  001ee	75 05		 jne	 SHORT $LN10@PyUnicode_@20
  001f0	80 f9 02	 cmp	 cl, 2
  001f3	74 0a		 je	 SHORT $LN11@PyUnicode_@20
$LN10@PyUnicode_@20:
  001f5	45 85 ff	 test	 r15d, r15d
  001f8	75 10		 jne	 SHORT $LN12@PyUnicode_@20
  001fa	80 f9 01	 cmp	 cl, 1
  001fd	75 0b		 jne	 SHORT $LN12@PyUnicode_@20
$LN11@PyUnicode_@20:

; 4663 :                 *out++ = (char) ch;

  001ff	41 88 10	 mov	 BYTE PTR [r8], dl
  00202	49 ff c0	 inc	 r8

; 4668 :                 goto encode_char;
; 4669 :             }
; 4670 :         }
; 4671 :         continue;

  00205	e9 bf 00 00 00	 jmp	 $LN28@PyUnicode_@20
$LN12@PyUnicode_@20:

; 4664 :             }
; 4665 :             else {
; 4666 :                 *out++ = '+';

  0020a	41 c6 00 2b	 mov	 BYTE PTR [r8], 43	; 0000002bH
  0020e	49 ff c0	 inc	 r8

; 4667 :                 inShift = 1;

  00211	41 bd 01 00 00
	00		 mov	 r13d, 1
$encode_char$129488:

; 4672 : encode_char:
; 4673 :         if (ch >= 0x10000) {

  00217	81 fa 00 00 01
	00		 cmp	 edx, 65536		; 00010000H
  0021d	72 65		 jb	 SHORT $LN8@PyUnicode_@20

; 4674 :             assert(ch <= MAX_UNICODE);
; 4675 : 
; 4676 :             /* code first surrogate */
; 4677 :             base64bits += 16;
; 4678 :             base64buffer = (base64buffer << 16) | 0xd800 | ((ch-0x10000) >> 10);

  0021f	8b c5		 mov	 eax, ebp
  00221	8d 8a 00 00 ff
	ff		 lea	 ecx, DWORD PTR [rdx-65536]
  00227	83 c6 10	 add	 esi, 16
  0022a	81 c9 00 00 60
	03		 or	 ecx, 56623104		; 03600000H
  00230	c1 e0 10	 shl	 eax, 16
  00233	c1 e9 0a	 shr	 ecx, 10
  00236	8b e9		 mov	 ebp, ecx
  00238	0b e8		 or	 ebp, eax

; 4679 :             while (base64bits >= 6) {

  0023a	3b f7		 cmp	 esi, edi
  0023c	72 3a		 jb	 SHORT $LN6@PyUnicode_@20
  0023e	44 8b cd	 mov	 r9d, ebp
  00241	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:__ImageBase
  00248	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL7@PyUnicode_@20:

; 4680 :                 *out++ = TO_BASE64(base64buffer >> (base64bits-6));

  00250	83 c6 fa	 add	 esi, -6			; fffffffaH
  00253	49 8b c1	 mov	 rax, r9
  00256	49 ff c0	 inc	 r8
  00259	40 0f b6 ce	 movzx	 ecx, sil
  0025d	48 d3 e8	 shr	 rax, cl
  00260	83 e0 3f	 and	 eax, 63			; 0000003fH
  00263	0f b6 84 18 00
	00 00 00	 movzx	 eax, BYTE PTR ??_C@_0EB@NFPJKBDG@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef@[rax+rbx]
  0026b	41 88 40 ff	 mov	 BYTE PTR [r8-1], al
  0026f	3b f7		 cmp	 esi, edi
  00271	73 dd		 jae	 SHORT $LL7@PyUnicode_@20
  00273	48 8b 5c 24 60	 mov	 rbx, QWORD PTR len$1$[rsp]
$LN6@PyUnicode_@20:

; 4681 :                 base64bits -= 6;
; 4682 :             }
; 4683 :             /* prepare second surrogate */
; 4684 :             ch = Py_UNICODE_LOW_SURROGATE(ch);

  00278	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  0027e	81 c2 00 dc 00
	00		 add	 edx, 56320		; 0000dc00H
$LN8@PyUnicode_@20:

; 4685 :         }
; 4686 :         base64bits += 16;
; 4687 :         base64buffer = (base64buffer << 16) | ch;

  00284	c1 e5 10	 shl	 ebp, 16
  00287	83 c6 10	 add	 esi, 16
  0028a	0b ea		 or	 ebp, edx

; 4688 :         while (base64bits >= 6) {

  0028c	3b f7		 cmp	 esi, edi
  0028e	72 39		 jb	 SHORT $LN28@PyUnicode_@20
  00290	44 8b cd	 mov	 r9d, ebp
  00293	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:__ImageBase
  0029a	66 0f 1f 44 00
	00		 npad	 6
$LL5@PyUnicode_@20:

; 4689 :             *out++ = TO_BASE64(base64buffer >> (base64bits-6));

  002a0	8d 56 fa	 lea	 edx, DWORD PTR [rsi-6]
  002a3	49 8b c1	 mov	 rax, r9
  002a6	49 ff c0	 inc	 r8
  002a9	0f b6 ca	 movzx	 ecx, dl

; 4690 :             base64bits -= 6;

  002ac	8b f2		 mov	 esi, edx
  002ae	48 d3 e8	 shr	 rax, cl
  002b1	83 e0 3f	 and	 eax, 63			; 0000003fH
  002b4	0f b6 84 18 00
	00 00 00	 movzx	 eax, BYTE PTR ??_C@_0EB@NFPJKBDG@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef@[rax+rbx]
  002bc	41 88 40 ff	 mov	 BYTE PTR [r8-1], al
  002c0	3b d7		 cmp	 edx, edi
  002c2	73 dc		 jae	 SHORT $LL5@PyUnicode_@20
  002c4	48 8b 5c 24 60	 mov	 rbx, QWORD PTR len$1$[rsp]
$LN28@PyUnicode_@20:

; 4634 :     for (i = 0; i < len; ++i) {

  002c9	49 ff c2	 inc	 r10
  002cc	4c 3b d3	 cmp	 r10, rbx
  002cf	0f 8c 1b fe ff
	ff		 jl	 $LL52@PyUnicode_@20

; 4691 :         }
; 4692 :     }
; 4693 :     if (base64bits)

  002d5	85 f6		 test	 esi, esi
  002d7	74 23		 je	 SHORT $LN3@PyUnicode_@20

; 4694 :         *out++= TO_BASE64(base64buffer << (6-base64bits) );

  002d9	2b fe		 sub	 edi, esi
  002db	8b c5		 mov	 eax, ebp
  002dd	40 0f b6 cf	 movzx	 ecx, dil
  002e1	d3 e0		 shl	 eax, cl
  002e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  002ea	83 e0 3f	 and	 eax, 63			; 0000003fH
  002ed	49 ff c0	 inc	 r8
  002f0	0f b6 84 08 00
	00 00 00	 movzx	 eax, BYTE PTR ??_C@_0EB@NFPJKBDG@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef@[rax+rcx]
  002f8	41 88 40 ff	 mov	 BYTE PTR [r8-1], al
$LN3@PyUnicode_@20:

; 4695 :     if (inShift)

  002fc	45 85 ed	 test	 r13d, r13d
  002ff	74 07		 je	 SHORT $LN2@PyUnicode_@20

; 4696 :         *out++ = '-';

  00301	41 c6 00 2d	 mov	 BYTE PTR [r8], 45	; 0000002dH
  00305	49 ff c0	 inc	 r8
$LN2@PyUnicode_@20:

; 4697 :     if (_PyBytes_Resize(&v, out - start) < 0)

  00308	4c 2b 44 24 28	 sub	 r8, QWORD PTR start$1$[rsp]
  0030d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR v$[rsp]
  00312	49 8b d0	 mov	 rdx, r8
  00315	e8 00 00 00 00	 call	 _PyBytes_Resize
  0031a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0031f	85 c0		 test	 eax, eax
  00321	b8 00 00 00 00	 mov	 eax, 0
  00326	48 0f 48 c8	 cmovs	 rcx, rax
  0032a	48 8b c1	 mov	 rax, rcx
$LN55@PyUnicode_@20:

; 4698 :         return NULL;
; 4699 :     return v;
; 4700 : }

  0032d	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00332	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]
  00337	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  0033c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00340	41 5f		 pop	 r15
  00342	41 5e		 pop	 r14
  00344	41 5d		 pop	 r13
  00346	5e		 pop	 rsi
  00347	5d		 pop	 rbp
  00348	c3		 ret	 0
_PyUnicode_EncodeUTF7 ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\codecs.h
pdata	SEGMENT
$pdata$asciilib_utf8_decode DD imagerel asciilib_utf8_decode
	DD	imagerel asciilib_utf8_decode+716
	DD	imagerel $unwind$asciilib_utf8_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_utf8_decode DD 081401H
	DD	047414H
	DD	03640fH
	DD	02540aH
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT asciilib_utf8_decode
_TEXT	SEGMENT
inptr$ = 8
end$ = 16
dest$ = 24
outpos$ = 32
asciilib_utf8_decode PROC				; COMDAT

; 22   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi

; 23   :     Py_UCS4 ch;
; 24   :     const char *s = *inptr;

  00014	4c 8b 11	 mov	 r10, QWORD PTR [rcx]
  00017	49 8b f9	 mov	 rdi, r9
  0001a	49 8b f0	 mov	 rsi, r8

; 25   :     const char *aligned_end = (const char *) _Py_ALIGN_DOWN(end, SIZEOF_LONG);
; 26   :     STRINGLIB_CHAR *p = dest + *outpos;

  0001d	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00020	4c 8b ca	 mov	 r9, rdx

; 27   : 
; 28   :     while (s < end) {

  00023	33 db		 xor	 ebx, ebx
  00025	49 83 e1 fc	 and	 r9, -4
  00029	4c 8b c2	 mov	 r8, rdx
  0002c	48 8b e9	 mov	 rbp, rcx
  0002f	4c 8d 1c 06	 lea	 r11, QWORD PTR [rsi+rax]
  00033	4c 3b d2	 cmp	 r10, rdx
  00036	0f 83 6f 02 00
	00		 jae	 $Return$129600
  0003c	0f 1f 40 00	 npad	 4
$LL48@asciilib_u:

; 29   :         ch = (unsigned char)*s;

  00040	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]

; 30   : 
; 31   :         if (ch < 0x80) {

  00044	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0004a	73 71		 jae	 SHORT $LN40@asciilib_u

; 32   :             /* Fast path for runs of ASCII characters. Given that common UTF-8
; 33   :                input will consist of an overwhelming majority of ASCII
; 34   :                characters, we try to optimize for this case by checking
; 35   :                as many characters as a C 'long' can contain.
; 36   :                First, check if we can do an aligned read, as most CPUs have
; 37   :                a penalty for unaligned reads.
; 38   :             */
; 39   :             if (_Py_IS_ALIGNED(s, SIZEOF_LONG)) {

  0004c	41 f6 c2 03	 test	 r10b, 3
  00050	75 50		 jne	 SHORT $LN45@asciilib_u

; 40   :                 /* Help register allocation */
; 41   :                 register const char *_s = s;

  00052	49 8b d2	 mov	 rdx, r10

; 42   :                 register STRINGLIB_CHAR *_p = p;
; 43   :                 while (_s < aligned_end) {

  00055	4d 3b d1	 cmp	 r10, r9
  00058	73 39		 jae	 SHORT $LN64@asciilib_u
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL44@asciilib_u:

; 44   :                     /* Read a whole long at a time (either 4 or 8 bytes),
; 45   :                        and do a fast unrolled copy if it only contains ASCII
; 46   :                        characters. */
; 47   :                     unsigned long value = *(unsigned long *) _s;

  00060	8b 0a		 mov	 ecx, DWORD PTR [rdx]

; 48   :                     if (value & ASCII_CHAR_MASK)

  00062	f7 c1 80 80 80
	80		 test	 ecx, -2139062144	; 80808080H
  00068	75 29		 jne	 SHORT $LN64@asciilib_u

; 49   :                         break;
; 50   : #ifdef BYTEORDER_IS_LITTLE_ENDIAN
; 51   :                     _p[0] = (STRINGLIB_CHAR)(value & 0xFFu);
; 52   :                     _p[1] = (STRINGLIB_CHAR)((value >> 8) & 0xFFu);

  0006a	8b c1		 mov	 eax, ecx
  0006c	41 88 0b	 mov	 BYTE PTR [r11], cl

; 53   :                     _p[2] = (STRINGLIB_CHAR)((value >> 16) & 0xFFu);
; 54   :                     _p[3] = (STRINGLIB_CHAR)((value >> 24) & 0xFFu);
; 55   : # if SIZEOF_LONG == 8
; 56   :                     _p[4] = (STRINGLIB_CHAR)((value >> 32) & 0xFFu);
; 57   :                     _p[5] = (STRINGLIB_CHAR)((value >> 40) & 0xFFu);
; 58   :                     _p[6] = (STRINGLIB_CHAR)((value >> 48) & 0xFFu);
; 59   :                     _p[7] = (STRINGLIB_CHAR)((value >> 56) & 0xFFu);
; 60   : # endif
; 61   : #else
; 62   : # if SIZEOF_LONG == 8
; 63   :                     _p[0] = (STRINGLIB_CHAR)((value >> 56) & 0xFFu);
; 64   :                     _p[1] = (STRINGLIB_CHAR)((value >> 48) & 0xFFu);
; 65   :                     _p[2] = (STRINGLIB_CHAR)((value >> 40) & 0xFFu);
; 66   :                     _p[3] = (STRINGLIB_CHAR)((value >> 32) & 0xFFu);
; 67   :                     _p[4] = (STRINGLIB_CHAR)((value >> 24) & 0xFFu);
; 68   :                     _p[5] = (STRINGLIB_CHAR)((value >> 16) & 0xFFu);
; 69   :                     _p[6] = (STRINGLIB_CHAR)((value >> 8) & 0xFFu);
; 70   :                     _p[7] = (STRINGLIB_CHAR)(value & 0xFFu);
; 71   : # else
; 72   :                     _p[0] = (STRINGLIB_CHAR)((value >> 24) & 0xFFu);
; 73   :                     _p[1] = (STRINGLIB_CHAR)((value >> 16) & 0xFFu);
; 74   :                     _p[2] = (STRINGLIB_CHAR)((value >> 8) & 0xFFu);
; 75   :                     _p[3] = (STRINGLIB_CHAR)(value & 0xFFu);
; 76   : # endif
; 77   : #endif
; 78   :                     _s += SIZEOF_LONG;

  0006f	48 83 c2 04	 add	 rdx, 4
  00073	c1 e8 08	 shr	 eax, 8

; 79   :                     _p += SIZEOF_LONG;

  00076	49 83 c3 04	 add	 r11, 4
  0007a	41 88 43 fd	 mov	 BYTE PTR [r11-3], al
  0007e	8b c1		 mov	 eax, ecx
  00080	c1 e9 18	 shr	 ecx, 24
  00083	c1 e8 10	 shr	 eax, 16
  00086	41 88 4b ff	 mov	 BYTE PTR [r11-1], cl
  0008a	41 88 43 fe	 mov	 BYTE PTR [r11-2], al
  0008e	49 3b d1	 cmp	 rdx, r9
  00091	72 cd		 jb	 SHORT $LL44@asciilib_u
$LN64@asciilib_u:

; 80   :                 }
; 81   :                 s = _s;

  00093	4c 8b d2	 mov	 r10, rdx

; 82   :                 p = _p;
; 83   :                 if (s == end)

  00096	49 3b d0	 cmp	 rdx, r8
  00099	0f 84 0c 02 00
	00		 je	 $Return$129600

; 84   :                     break;
; 85   :                 ch = (unsigned char)*s;

  0009f	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
$LN45@asciilib_u:

; 86   :             }
; 87   :             if (ch < 0x80) {

  000a2	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  000a8	73 13		 jae	 SHORT $LN40@asciilib_u

; 88   :                 s++;

  000aa	49 ff c2	 inc	 r10

; 89   :                 *p++ = ch;

  000ad	41 88 0b	 mov	 BYTE PTR [r11], cl
  000b0	49 ff c3	 inc	 r11
  000b3	4d 3b d0	 cmp	 r10, r8
  000b6	72 88		 jb	 SHORT $LL48@asciilib_u

; 82   :                 p = _p;
; 83   :                 if (s == end)

  000b8	e9 ee 01 00 00	 jmp	 $Return$129600
$LN40@asciilib_u:

; 90   :                 continue;
; 91   :             }
; 92   :         }
; 93   : 
; 94   :         if (ch < 0xE0) {

  000bd	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  000c3	73 39		 jae	 SHORT $LN39@asciilib_u

; 95   :             /* \xC2\x80-\xDF\xBF -- 0080-07FF */
; 96   :             Py_UCS4 ch2;
; 97   :             if (ch < 0xC2) {

  000c5	81 f9 c2 00 00
	00		 cmp	 ecx, 194		; 000000c2H
  000cb	0f 82 d5 01 00
	00		 jb	 $InvalidStart$129592

; 98   :                 /* invalid sequence
; 99   :                 \x80-\xBF -- continuation byte
; 100  :                 \xC0-\xC1 -- fake 0000-007F */
; 101  :                 goto InvalidStart;
; 102  :             }
; 103  :             if (end - s < 2) {

  000d1	4d 2b c2	 sub	 r8, r10
  000d4	49 83 f8 02	 cmp	 r8, 2
  000d8	0f 8c cd 01 00
	00		 jl	 $Return$129600

; 104  :                 /* unexpected end of data: the caller will decide whether
; 105  :                    it's an error or not */
; 106  :                 break;
; 107  :             }
; 108  :             ch2 = (unsigned char)s[1];

  000de	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 109  :             if (!IS_CONTINUATION_BYTE(ch2))

  000e3	8d 42 80	 lea	 eax, DWORD PTR [rdx-128]
  000e6	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  000e9	77 62		 ja	 SHORT $InvalidContinuation1$129597

; 110  :                 /* invalid continuation byte */
; 111  :                 goto InvalidContinuation1;
; 112  :             ch = (ch << 6) + ch2 -
; 113  :                  ((0xC0 << 6) + 0x80);

  000eb	c1 e1 06	 shl	 ecx, 6

; 114  :             assert ((ch > 0x007F) && (ch <= 0x07FF));
; 115  :             s += 2;

  000ee	49 83 c2 02	 add	 r10, 2
  000f2	8d 9c 11 80 cf
	ff ff		 lea	 ebx, DWORD PTR [rcx+rdx-12416]

; 116  :             if (STRINGLIB_MAX_CHAR <= 0x007F ||
; 117  :                 (STRINGLIB_MAX_CHAR < 0x07FF && ch > STRINGLIB_MAX_CHAR))
; 118  :                 /* Out-of-range */
; 119  :                 goto Return;

  000f9	e9 ad 01 00 00	 jmp	 $Return$129600
$LN39@asciilib_u:

; 120  :             *p++ = ch;
; 121  :             continue;
; 122  :         }
; 123  : 
; 124  :         if (ch < 0xF0) {

  000fe	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  00104	0f 83 a7 00 00
	00		 jae	 $LN33@asciilib_u

; 125  :             /* \xE0\xA0\x80-\xEF\xBF\xBF -- 0800-FFFF */
; 126  :             Py_UCS4 ch2, ch3;
; 127  :             if (end - s < 3) {

  0010a	4d 2b c2	 sub	 r8, r10
  0010d	49 83 f8 03	 cmp	 r8, 3
  00111	7d 44		 jge	 SHORT $LN32@asciilib_u

; 128  :                 /* unexpected end of data: the caller will decide whether
; 129  :                    it's an error or not */
; 130  :                 if (end - s < 2)

  00113	49 83 f8 02	 cmp	 r8, 2
  00117	0f 8c 8e 01 00
	00		 jl	 $Return$129600

; 131  :                     break;
; 132  :                 ch2 = (unsigned char)s[1];

  0011d	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 133  :                 if (!IS_CONTINUATION_BYTE(ch2) ||
; 134  :                     (ch2 < 0xA0 ? ch == 0xE0 : ch == 0xED))

  00122	8d 42 80	 lea	 eax, DWORD PTR [rdx-128]
  00125	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00128	77 23		 ja	 SHORT $InvalidContinuation1$129597
  0012a	8b c3		 mov	 eax, ebx
  0012c	81 fa a0 00 00
	00		 cmp	 edx, 160		; 000000a0H
  00132	73 08		 jae	 SHORT $LN51@asciilib_u
  00134	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  0013a	eb 06		 jmp	 SHORT $LN65@asciilib_u
$LN51@asciilib_u:
  0013c	81 f9 ed 00 00
	00		 cmp	 ecx, 237		; 000000edH
$LN65@asciilib_u:
  00142	0f 94 c0	 sete	 al
  00145	85 c0		 test	 eax, eax
  00147	0f 84 5e 01 00
	00		 je	 $Return$129600
$InvalidContinuation1$129597:

; 239  :     goto Return;
; 240  : InvalidContinuation1:
; 241  :     ch = 2;

  0014d	bb 02 00 00 00	 mov	 ebx, 2

; 242  :     goto Return;

  00152	e9 54 01 00 00	 jmp	 $Return$129600
$LN32@asciilib_u:

; 135  :                     /* for clarification see comments below */
; 136  :                     goto InvalidContinuation1;
; 137  :                 break;
; 138  :             }
; 139  :             ch2 = (unsigned char)s[1];

  00157	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 140  :             ch3 = (unsigned char)s[2];

  0015c	45 0f b6 42 02	 movzx	 r8d, BYTE PTR [r10+2]

; 141  :             if (!IS_CONTINUATION_BYTE(ch2)) {

  00161	8d 42 80	 lea	 eax, DWORD PTR [rdx-128]
  00164	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00167	77 e4		 ja	 SHORT $InvalidContinuation1$129597

; 142  :                 /* invalid continuation byte */
; 143  :                 goto InvalidContinuation1;
; 144  :             }
; 145  :             if (ch == 0xE0) {

  00169	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  0016f	75 0a		 jne	 SHORT $LN26@asciilib_u

; 146  :                 if (ch2 < 0xA0)

  00171	81 fa a0 00 00
	00		 cmp	 edx, 160		; 000000a0H
  00177	72 d4		 jb	 SHORT $InvalidContinuation1$129597

; 147  :                     /* invalid sequence
; 148  :                        \xE0\x80\x80-\xE0\x9F\xBF -- fake 0000-0800 */
; 149  :                     goto InvalidContinuation1;
; 150  :             } else if (ch == 0xED && ch2 >= 0xA0) {

  00179	eb 10		 jmp	 SHORT $LN23@asciilib_u
$LN26@asciilib_u:
  0017b	81 f9 ed 00 00
	00		 cmp	 ecx, 237		; 000000edH
  00181	75 08		 jne	 SHORT $LN23@asciilib_u
  00183	81 fa a0 00 00
	00		 cmp	 edx, 160		; 000000a0H
  00189	73 c2		 jae	 SHORT $InvalidContinuation1$129597
$LN23@asciilib_u:

; 151  :                 /* Decoding UTF-8 sequences in range \xED\xA0\x80-\xED\xBF\xBF
; 152  :                    will result in surrogates in range D800-DFFF. Surrogates are
; 153  :                    not valid UTF-8 so they are rejected.
; 154  :                    See http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf
; 155  :                    (table 3-7) and http://www.rfc-editor.org/rfc/rfc3629.txt */
; 156  :                 goto InvalidContinuation1;
; 157  :             }
; 158  :             if (!IS_CONTINUATION_BYTE(ch3)) {

  0018b	41 8d 40 80	 lea	 eax, DWORD PTR [r8-128]
  0018f	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00192	0f 87 8d 00 00
	00		 ja	 $InvalidContinuation2$129619

; 159  :                 /* invalid continuation byte */
; 160  :                 goto InvalidContinuation2;
; 161  :             }
; 162  :             ch = (ch << 12) + (ch2 << 6) + ch3 -
; 163  :                  ((0xE0 << 12) + (0x80 << 6) + 0x80);

  00198	c1 e1 06	 shl	 ecx, 6
  0019b	03 ca		 add	 ecx, edx
  0019d	c1 e1 06	 shl	 ecx, 6

; 164  :             assert ((ch > 0x07FF) && (ch <= 0xFFFF));
; 165  :             s += 3;

  001a0	49 83 c2 03	 add	 r10, 3
  001a4	42 8d 9c 01 80
	df f1 ff	 lea	 ebx, DWORD PTR [rcx+r8-925824]

; 166  :             if (STRINGLIB_MAX_CHAR <= 0x07FF ||
; 167  :                 (STRINGLIB_MAX_CHAR < 0xFFFF && ch > STRINGLIB_MAX_CHAR))
; 168  :                 /* Out-of-range */
; 169  :                 goto Return;

  001ac	e9 fa 00 00 00	 jmp	 $Return$129600
$LN33@asciilib_u:

; 170  :             *p++ = ch;
; 171  :             continue;
; 172  :         }
; 173  : 
; 174  :         if (ch < 0xF5) {

  001b1	81 f9 f5 00 00
	00		 cmp	 ecx, 245		; 000000f5H
  001b7	0f 83 e9 00 00
	00		 jae	 $InvalidStart$129592

; 175  :             /* \xF0\x90\x80\x80-\xF4\x8F\xBF\xBF -- 10000-10FFFF */
; 176  :             Py_UCS4 ch2, ch3, ch4;
; 177  :             if (end - s < 4) {

  001bd	4d 2b c2	 sub	 r8, r10
  001c0	49 83 f8 04	 cmp	 r8, 4
  001c4	7d 66		 jge	 SHORT $LN18@asciilib_u

; 178  :                 /* unexpected end of data: the caller will decide whether
; 179  :                    it's an error or not */
; 180  :                 if (end - s < 2)

  001c6	49 83 f8 02	 cmp	 r8, 2
  001ca	0f 8c db 00 00
	00		 jl	 $Return$129600

; 181  :                     break;
; 182  :                 ch2 = (unsigned char)s[1];

  001d0	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 183  :                 if (!IS_CONTINUATION_BYTE(ch2) ||
; 184  :                     (ch2 < 0x90 ? ch == 0xF0 : ch == 0xF4))

  001d5	8d 42 80	 lea	 eax, DWORD PTR [rdx-128]
  001d8	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  001db	0f 87 6c ff ff
	ff		 ja	 $InvalidContinuation1$129597
  001e1	8b c3		 mov	 eax, ebx
  001e3	81 fa 90 00 00
	00		 cmp	 edx, 144		; 00000090H
  001e9	73 08		 jae	 SHORT $LN53@asciilib_u
  001eb	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  001f1	eb 06		 jmp	 SHORT $LN66@asciilib_u
$LN53@asciilib_u:
  001f3	81 f9 f4 00 00
	00		 cmp	 ecx, 244		; 000000f4H
$LN66@asciilib_u:
  001f9	0f 94 c0	 sete	 al
  001fc	85 c0		 test	 eax, eax
  001fe	0f 85 49 ff ff
	ff		 jne	 $InvalidContinuation1$129597

; 185  :                     /* for clarification see comments below */
; 186  :                     goto InvalidContinuation1;
; 187  :                 if (end - s < 3)

  00204	49 83 f8 03	 cmp	 r8, 3
  00208	0f 8c 9d 00 00
	00		 jl	 $Return$129600

; 188  :                     break;
; 189  :                 ch3 = (unsigned char)s[2];

  0020e	41 0f b6 42 02	 movzx	 eax, BYTE PTR [r10+2]

; 190  :                 if (!IS_CONTINUATION_BYTE(ch3))

  00213	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00218	72 0b		 jb	 SHORT $InvalidContinuation2$129619
  0021a	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0021f	0f 82 86 00 00
	00		 jb	 $Return$129600
$InvalidContinuation2$129619:

; 243  : InvalidContinuation2:
; 244  :     ch = 3;

  00225	bb 03 00 00 00	 mov	 ebx, 3

; 245  :     goto Return;

  0022a	eb 7f		 jmp	 SHORT $Return$129600
$LN18@asciilib_u:

; 191  :                     goto InvalidContinuation2;
; 192  :                 break;
; 193  :             }
; 194  :             ch2 = (unsigned char)s[1];

  0022c	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 195  :             ch3 = (unsigned char)s[2];

  00231	45 0f b6 42 02	 movzx	 r8d, BYTE PTR [r10+2]

; 196  :             ch4 = (unsigned char)s[3];

  00236	45 0f b6 4a 03	 movzx	 r9d, BYTE PTR [r10+3]

; 197  :             if (!IS_CONTINUATION_BYTE(ch2)) {

  0023b	8d 42 80	 lea	 eax, DWORD PTR [rdx-128]
  0023e	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00241	0f 87 06 ff ff
	ff		 ja	 $InvalidContinuation1$129597

; 198  :                 /* invalid continuation byte */
; 199  :                 goto InvalidContinuation1;
; 200  :             }
; 201  :             if (ch == 0xF0) {

  00247	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  0024d	75 0e		 jne	 SHORT $LN9@asciilib_u

; 202  :                 if (ch2 < 0x90)

  0024f	81 fa 90 00 00
	00		 cmp	 edx, 144		; 00000090H
  00255	0f 82 f2 fe ff
	ff		 jb	 $InvalidContinuation1$129597

; 203  :                     /* invalid sequence
; 204  :                        \xF0\x80\x80\x80-\xF0\x8F\xBF\xBF -- fake 0000-FFFF */
; 205  :                     goto InvalidContinuation1;
; 206  :             } else if (ch == 0xF4 && ch2 >= 0x90) {

  0025b	eb 14		 jmp	 SHORT $LN6@asciilib_u
$LN9@asciilib_u:
  0025d	81 f9 f4 00 00
	00		 cmp	 ecx, 244		; 000000f4H
  00263	75 0c		 jne	 SHORT $LN6@asciilib_u
  00265	81 fa 90 00 00
	00		 cmp	 edx, 144		; 00000090H
  0026b	0f 83 dc fe ff
	ff		 jae	 $InvalidContinuation1$129597
$LN6@asciilib_u:

; 207  :                 /* invalid sequence
; 208  :                    \xF4\x90\x80\80- -- 110000- overflow */
; 209  :                 goto InvalidContinuation1;
; 210  :             }
; 211  :             if (!IS_CONTINUATION_BYTE(ch3)) {

  00271	41 8d 40 80	 lea	 eax, DWORD PTR [r8-128]
  00275	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00278	77 ab		 ja	 SHORT $InvalidContinuation2$129619

; 212  :                 /* invalid continuation byte */
; 213  :                 goto InvalidContinuation2;
; 214  :             }
; 215  :             if (!IS_CONTINUATION_BYTE(ch4)) {

  0027a	41 8d 41 80	 lea	 eax, DWORD PTR [r9-128]
  0027e	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00281	77 1c		 ja	 SHORT $InvalidContinuation3$129648

; 216  :                 /* invalid continuation byte */
; 217  :                 goto InvalidContinuation3;
; 218  :             }
; 219  :             ch = (ch << 18) + (ch2 << 12) + (ch3 << 6) + ch4 -
; 220  :                  ((0xF0 << 18) + (0x80 << 12) + (0x80 << 6) + 0x80);

  00283	c1 e1 06	 shl	 ecx, 6
  00286	03 ca		 add	 ecx, edx
  00288	c1 e1 06	 shl	 ecx, 6
  0028b	41 03 c8	 add	 ecx, r8d
  0028e	c1 e1 06	 shl	 ecx, 6

; 221  :             assert ((ch > 0xFFFF) && (ch <= 0x10FFFF));
; 222  :             s += 4;

  00291	49 83 c2 04	 add	 r10, 4
  00295	42 8d 9c 09 80
	df 37 fc	 lea	 ebx, DWORD PTR [rcx+r9-63447168]

; 223  :             if (STRINGLIB_MAX_CHAR <= 0xFFFF ||
; 224  :                 (STRINGLIB_MAX_CHAR < 0x10FFFF && ch > STRINGLIB_MAX_CHAR))
; 225  :                 /* Out-of-range */
; 226  :                 goto Return;

  0029d	eb 0c		 jmp	 SHORT $Return$129600
$InvalidContinuation3$129648:

; 246  : InvalidContinuation3:
; 247  :     ch = 4;

  0029f	bb 04 00 00 00	 mov	 ebx, 4

; 248  :     goto Return;

  002a4	eb 05		 jmp	 SHORT $Return$129600
$InvalidStart$129592:

; 236  :     return ch;
; 237  : InvalidStart:
; 238  :     ch = 1;

  002a6	bb 01 00 00 00	 mov	 ebx, 1
$Return$129600:

; 227  :             *p++ = ch;
; 228  :             continue;
; 229  :         }
; 230  :         goto InvalidStart;
; 231  :     }
; 232  :     ch = 0;
; 233  : Return:
; 234  :     *inptr = s;
; 235  :     *outpos = p - dest;

  002ab	4c 2b de	 sub	 r11, rsi

; 249  : }

  002ae	48 8b 74 24 18	 mov	 rsi, QWORD PTR [rsp+24]
  002b3	4c 89 55 00	 mov	 QWORD PTR [rbp], r10
  002b7	48 8b 6c 24 10	 mov	 rbp, QWORD PTR [rsp+16]
  002bc	4c 89 1f	 mov	 QWORD PTR [rdi], r11
  002bf	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  002c4	8b c3		 mov	 eax, ebx
  002c6	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  002cb	c3		 ret	 0
asciilib_utf8_decode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$asciilib_utf16_decode DD imagerel asciilib_utf16_decode
	DD	imagerel asciilib_utf16_decode+340
	DD	imagerel $unwind$asciilib_utf16_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_utf16_decode DD 091601H
	DD	057416H
	DD	046416H
	DD	035416H
	DD	023416H
	DD	0c016H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT asciilib_utf16_decode
_TEXT	SEGMENT
inptr$ = 16
e$ = 24
dest$ = 32
outpos$ = 40
native_ordering$ = 48
asciilib_utf16_decode PROC				; COMDAT

; 482  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12

; 483  :     Py_UCS4 ch;
; 484  :     const unsigned char *aligned_end =
; 485  :             (const unsigned char *) _Py_ALIGN_DOWN(e, SIZEOF_LONG);
; 486  :     const unsigned char *q = *inptr;

  00016	4c 8b 19	 mov	 r11, QWORD PTR [rcx]

; 487  :     STRINGLIB_CHAR *p = dest + *outpos;
; 488  :     /* Offsets from q for retrieving byte pairs in the right order. */
; 489  : #ifdef BYTEORDER_IS_LITTLE_ENDIAN
; 490  :     int ihi = !!native_ordering, ilo = !native_ordering;

  00019	45 33 d2	 xor	 r10d, r10d
  0001c	49 8b e8	 mov	 rbp, r8
  0001f	4c 8b c2	 mov	 r8, rdx

; 491  : #else
; 492  :     int ihi = !native_ordering, ilo = !!native_ordering;
; 493  : #endif
; 494  :     --e;

  00022	48 8d 5a ff	 lea	 rbx, QWORD PTR [rdx-1]
  00026	49 8b 11	 mov	 rdx, QWORD PTR [r9]
  00029	49 83 e0 fc	 and	 r8, -4
  0002d	48 03 d5	 add	 rdx, rbp
  00030	49 8b f1	 mov	 rsi, r9
  00033	44 8b 4c 24 30	 mov	 r9d, DWORD PTR native_ordering$[rsp]
  00038	4c 8b e1	 mov	 r12, rcx
  0003b	45 85 c9	 test	 r9d, r9d
  0003e	41 0f 95 c2	 setne	 r10b
  00042	33 c0		 xor	 eax, eax
  00044	45 85 c9	 test	 r9d, r9d
  00047	0f 94 c0	 sete	 al
  0004a	4d 63 d2	 movsxd	 r10, r10d
  0004d	48 63 f8	 movsxd	 rdi, eax

; 495  : 
; 496  :     while (q < e) {

  00050	4c 3b db	 cmp	 r11, rbx
  00053	73 77		 jae	 SHORT $LN29@asciilib_u@2
$LL18@asciilib_u@2:

; 497  :         Py_UCS4 ch2;
; 498  :         /* First check for possible aligned read of a C 'long'. Unaligned
; 499  :            reads are more expensive, better to defer to another iteration. */
; 500  :         if (_Py_IS_ALIGNED(q, SIZEOF_LONG)) {

  00055	41 f6 c3 03	 test	 r11b, 3
  00059	75 3f		 jne	 SHORT $LN9@asciilib_u@2

; 501  :             /* Fast path for runs of in-range non-surrogate chars. */
; 502  :             register const unsigned char *_q = q;

  0005b	49 8b cb	 mov	 rcx, r11

; 503  :             while (_q < aligned_end) {

  0005e	4d 3b d8	 cmp	 r11, r8
  00061	73 2f		 jae	 SHORT $LN30@asciilib_u@2
$LL15@asciilib_u@2:

; 504  :                 unsigned long block = * (unsigned long *) _q;

  00063	8b 01		 mov	 eax, DWORD PTR [rcx]

; 505  :                 if (native_ordering) {

  00065	45 85 c9	 test	 r9d, r9d
  00068	74 09		 je	 SHORT $LN13@asciilib_u@2

; 506  :                     /* Can use buffer directly */
; 507  :                     if (block & FAST_CHAR_MASK)

  0006a	a9 80 ff 80 ff	 test	 eax, -8323200		; ff80ff80H
  0006f	75 21		 jne	 SHORT $LN30@asciilib_u@2

; 508  :                         break;
; 509  :                 }
; 510  :                 else {

  00071	eb 0a		 jmp	 SHORT $LN11@asciilib_u@2
$LN13@asciilib_u@2:

; 511  :                     /* Need to byte-swap */
; 512  :                     if (block & SWAB(FAST_CHAR_MASK))

  00073	a9 ff 80 ff 80	 test	 eax, -2130738945	; 80ff80ffH
  00078	75 18		 jne	 SHORT $LN30@asciilib_u@2

; 513  :                         break;
; 514  : #if STRINGLIB_SIZEOF_CHAR == 1
; 515  :                     block >>= 8;

  0007a	c1 e8 08	 shr	 eax, 8
$LN11@asciilib_u@2:

; 516  : #else
; 517  :                     block = SWAB(block);
; 518  : #endif
; 519  :                 }
; 520  : #ifdef BYTEORDER_IS_LITTLE_ENDIAN
; 521  : # if SIZEOF_LONG == 4
; 522  :                 p[0] = (STRINGLIB_CHAR)(block & 0xFFFFu);

  0007d	88 02		 mov	 BYTE PTR [rdx], al

; 523  :                 p[1] = (STRINGLIB_CHAR)(block >> 16);

  0007f	c1 e8 10	 shr	 eax, 16

; 524  : # elif SIZEOF_LONG == 8
; 525  :                 p[0] = (STRINGLIB_CHAR)(block & 0xFFFFu);
; 526  :                 p[1] = (STRINGLIB_CHAR)((block >> 16) & 0xFFFFu);
; 527  :                 p[2] = (STRINGLIB_CHAR)((block >> 32) & 0xFFFFu);
; 528  :                 p[3] = (STRINGLIB_CHAR)(block >> 48);
; 529  : # endif
; 530  : #else
; 531  : # if SIZEOF_LONG == 4
; 532  :                 p[0] = (STRINGLIB_CHAR)(block >> 16);
; 533  :                 p[1] = (STRINGLIB_CHAR)(block & 0xFFFFu);
; 534  : # elif SIZEOF_LONG == 8
; 535  :                 p[0] = (STRINGLIB_CHAR)(block >> 48);
; 536  :                 p[1] = (STRINGLIB_CHAR)((block >> 32) & 0xFFFFu);
; 537  :                 p[2] = (STRINGLIB_CHAR)((block >> 16) & 0xFFFFu);
; 538  :                 p[3] = (STRINGLIB_CHAR)(block & 0xFFFFu);
; 539  : # endif
; 540  : #endif
; 541  :                 _q += SIZEOF_LONG;

  00082	48 83 c1 04	 add	 rcx, 4
  00086	88 42 01	 mov	 BYTE PTR [rdx+1], al

; 542  :                 p += SIZEOF_LONG / 2;

  00089	48 83 c2 02	 add	 rdx, 2
  0008d	49 3b c8	 cmp	 rcx, r8
  00090	72 d1		 jb	 SHORT $LL15@asciilib_u@2
$LN30@asciilib_u@2:

; 543  :             }
; 544  :             q = _q;

  00092	4c 8b d9	 mov	 r11, rcx

; 545  :             if (q >= e)

  00095	48 3b cb	 cmp	 rcx, rbx
  00098	73 32		 jae	 SHORT $LN29@asciilib_u@2
$LN9@asciilib_u@2:

; 546  :                 break;
; 547  :         }
; 548  : 
; 549  :         ch = (q[ihi] << 8) | q[ilo];

  0009a	43 0f b6 0c 1a	 movzx	 ecx, BYTE PTR [r10+r11]
  0009f	42 0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+r11]

; 550  :         q += 2;

  000a4	49 83 c3 02	 add	 r11, 2
  000a8	c1 e1 08	 shl	 ecx, 8
  000ab	0b c8		 or	 ecx, eax

; 551  :         if (!Py_UNICODE_IS_SURROGATE(ch)) {

  000ad	81 f9 00 d8 00
	00		 cmp	 ecx, 55296		; 0000d800H
  000b3	72 08		 jb	 SHORT $LN7@asciilib_u@2
  000b5	81 f9 ff df 00
	00		 cmp	 ecx, 57343		; 0000dfffH
  000bb	76 34		 jbe	 SHORT $LN8@asciilib_u@2
$LN7@asciilib_u@2:

; 552  : #if STRINGLIB_SIZEOF_CHAR < 2
; 553  :             if (ch > STRINGLIB_MAX_CHAR)

  000bd	83 f9 7f	 cmp	 ecx, 127		; 0000007fH
  000c0	77 0c		 ja	 SHORT $Return$129748

; 554  :                 /* Out-of-range */
; 555  :                 goto Return;
; 556  : #endif
; 557  :             *p++ = (STRINGLIB_CHAR)ch;

  000c2	88 0a		 mov	 BYTE PTR [rdx], cl
  000c4	48 ff c2	 inc	 rdx
  000c7	4c 3b db	 cmp	 r11, rbx
  000ca	72 89		 jb	 SHORT $LL18@asciilib_u@2
$LN29@asciilib_u@2:

; 574  : #else
; 575  :         *p++ = (STRINGLIB_CHAR)ch;
; 576  : #endif
; 577  :     }
; 578  :     ch = 0;

  000cc	33 c9		 xor	 ecx, ecx
$Return$129748:

; 592  : }

  000ce	48 8b 5c 24 10	 mov	 rbx, QWORD PTR [rsp+16]
  000d3	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]
  000d8	48 2b d5	 sub	 rdx, rbp
  000db	48 8b 6c 24 18	 mov	 rbp, QWORD PTR [rsp+24]
  000e0	4d 89 1c 24	 mov	 QWORD PTR [r12], r11
  000e4	48 89 16	 mov	 QWORD PTR [rsi], rdx
  000e7	48 8b 74 24 20	 mov	 rsi, QWORD PTR [rsp+32]
  000ec	8b c1		 mov	 eax, ecx
  000ee	41 5c		 pop	 r12
  000f0	c3		 ret	 0
$LN8@asciilib_u@2:

; 558  :             continue;
; 559  :         }
; 560  : 
; 561  :         /* UTF-16 code pair: */
; 562  :         if (q >= e)

  000f1	4c 3b db	 cmp	 r11, rbx
  000f4	72 07		 jb	 SHORT $LN5@asciilib_u@2
$UnexpectedEnd$129751:

; 579  : Return:
; 580  :     *inptr = q;
; 581  :     *outpos = p - dest;
; 582  :     return ch;
; 583  : UnexpectedEnd:
; 584  :     ch = 1;

  000f6	b9 01 00 00 00	 mov	 ecx, 1

; 585  :     goto Return;

  000fb	eb d1		 jmp	 SHORT $Return$129748
$LN5@asciilib_u@2:

; 563  :             goto UnexpectedEnd;
; 564  :         if (!Py_UNICODE_IS_HIGH_SURROGATE(ch))

  000fd	81 f9 ff db 00
	00		 cmp	 ecx, 56319		; 0000dbffH
  00103	77 45		 ja	 SHORT $IllegalEncoding$129754

; 565  :             goto IllegalEncoding;
; 566  :         ch2 = (q[ihi] << 8) | q[ilo];

  00105	42 0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+r11]
  0010a	47 0f b6 04 1a	 movzx	 r8d, BYTE PTR [r10+r11]

; 567  :         q += 2;

  0010f	49 83 c3 02	 add	 r11, 2
  00113	41 c1 e0 08	 shl	 r8d, 8
  00117	44 0b c0	 or	 r8d, eax

; 568  :         if (!Py_UNICODE_IS_LOW_SURROGATE(ch2))

  0011a	41 8d 80 00 24
	ff ff		 lea	 eax, DWORD PTR [r8-56320]
  00121	3d ff 03 00 00	 cmp	 eax, 1023		; 000003ffH
  00126	77 1b		 ja	 SHORT $IllegalSurrogate$129757

; 569  :             goto IllegalSurrogate;
; 570  :         ch = Py_UNICODE_JOIN_SURROGATES(ch, ch2);

  00128	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0012e	41 81 e0 ff 03
	00 00		 and	 r8d, 1023		; 000003ffH
  00135	c1 e1 0a	 shl	 ecx, 10
  00138	41 0b c8	 or	 ecx, r8d
  0013b	81 c1 00 00 01
	00		 add	 ecx, 65536		; 00010000H

; 571  : #if STRINGLIB_SIZEOF_CHAR < 4
; 572  :         /* Out-of-range */
; 573  :         goto Return;

  00141	eb 8b		 jmp	 SHORT $Return$129748
$IllegalSurrogate$129757:

; 589  : IllegalSurrogate:
; 590  :     ch = 3;

  00143	b9 03 00 00 00	 mov	 ecx, 3

; 591  :     goto Return;

  00148	eb 84		 jmp	 SHORT $Return$129748
$IllegalEncoding$129754:

; 586  : IllegalEncoding:
; 587  :     ch = 2;

  0014a	b9 02 00 00 00	 mov	 ecx, 2

; 588  :     goto Return;

  0014f	e9 7a ff ff ff	 jmp	 $Return$129748
asciilib_utf16_decode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs1lib_utf8_decode DD imagerel ucs1lib_utf8_decode
	DD	imagerel ucs1lib_utf8_decode+728
	DD	imagerel $unwind$ucs1lib_utf8_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_utf8_decode DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs1lib_utf8_decode
_TEXT	SEGMENT
inptr$ = 8
end$ = 16
dest$ = 24
outpos$ = 32
ucs1lib_utf8_decode PROC				; COMDAT

; 22   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi

; 23   :     Py_UCS4 ch;
; 24   :     const char *s = *inptr;

  0000f	4c 8b 11	 mov	 r10, QWORD PTR [rcx]
  00012	49 8b d9	 mov	 rbx, r9
  00015	49 8b f8	 mov	 rdi, r8

; 25   :     const char *aligned_end = (const char *) _Py_ALIGN_DOWN(end, SIZEOF_LONG);
; 26   :     STRINGLIB_CHAR *p = dest + *outpos;

  00018	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001b	4c 8b ca	 mov	 r9, rdx
  0001e	4c 8b c2	 mov	 r8, rdx
  00021	49 83 e1 fc	 and	 r9, -4
  00025	4c 8d 1c 07	 lea	 r11, QWORD PTR [rdi+rax]
  00029	48 8b f1	 mov	 rsi, rcx

; 27   : 
; 28   :     while (s < end) {

  0002c	4c 3b d2	 cmp	 r10, rdx
  0002f	0f 83 d8 00 00
	00		 jae	 $LN48@ucs1lib_ut
  00035	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL49@ucs1lib_ut:

; 29   :         ch = (unsigned char)*s;

  00040	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]

; 30   : 
; 31   :         if (ch < 0x80) {

  00044	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0004a	73 62		 jae	 SHORT $LN41@ucs1lib_ut

; 32   :             /* Fast path for runs of ASCII characters. Given that common UTF-8
; 33   :                input will consist of an overwhelming majority of ASCII
; 34   :                characters, we try to optimize for this case by checking
; 35   :                as many characters as a C 'long' can contain.
; 36   :                First, check if we can do an aligned read, as most CPUs have
; 37   :                a penalty for unaligned reads.
; 38   :             */
; 39   :             if (_Py_IS_ALIGNED(s, SIZEOF_LONG)) {

  0004c	41 f6 c2 03	 test	 r10b, 3
  00050	75 4c		 jne	 SHORT $LN46@ucs1lib_ut

; 40   :                 /* Help register allocation */
; 41   :                 register const char *_s = s;

  00052	49 8b d2	 mov	 rdx, r10

; 42   :                 register STRINGLIB_CHAR *_p = p;
; 43   :                 while (_s < aligned_end) {

  00055	4d 3b d1	 cmp	 r10, r9
  00058	73 39		 jae	 SHORT $LN69@ucs1lib_ut
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL45@ucs1lib_ut:

; 44   :                     /* Read a whole long at a time (either 4 or 8 bytes),
; 45   :                        and do a fast unrolled copy if it only contains ASCII
; 46   :                        characters. */
; 47   :                     unsigned long value = *(unsigned long *) _s;

  00060	8b 0a		 mov	 ecx, DWORD PTR [rdx]

; 48   :                     if (value & ASCII_CHAR_MASK)

  00062	f7 c1 80 80 80
	80		 test	 ecx, -2139062144	; 80808080H
  00068	75 29		 jne	 SHORT $LN69@ucs1lib_ut

; 49   :                         break;
; 50   : #ifdef BYTEORDER_IS_LITTLE_ENDIAN
; 51   :                     _p[0] = (STRINGLIB_CHAR)(value & 0xFFu);
; 52   :                     _p[1] = (STRINGLIB_CHAR)((value >> 8) & 0xFFu);

  0006a	8b c1		 mov	 eax, ecx
  0006c	41 88 0b	 mov	 BYTE PTR [r11], cl

; 53   :                     _p[2] = (STRINGLIB_CHAR)((value >> 16) & 0xFFu);
; 54   :                     _p[3] = (STRINGLIB_CHAR)((value >> 24) & 0xFFu);
; 55   : # if SIZEOF_LONG == 8
; 56   :                     _p[4] = (STRINGLIB_CHAR)((value >> 32) & 0xFFu);
; 57   :                     _p[5] = (STRINGLIB_CHAR)((value >> 40) & 0xFFu);
; 58   :                     _p[6] = (STRINGLIB_CHAR)((value >> 48) & 0xFFu);
; 59   :                     _p[7] = (STRINGLIB_CHAR)((value >> 56) & 0xFFu);
; 60   : # endif
; 61   : #else
; 62   : # if SIZEOF_LONG == 8
; 63   :                     _p[0] = (STRINGLIB_CHAR)((value >> 56) & 0xFFu);
; 64   :                     _p[1] = (STRINGLIB_CHAR)((value >> 48) & 0xFFu);
; 65   :                     _p[2] = (STRINGLIB_CHAR)((value >> 40) & 0xFFu);
; 66   :                     _p[3] = (STRINGLIB_CHAR)((value >> 32) & 0xFFu);
; 67   :                     _p[4] = (STRINGLIB_CHAR)((value >> 24) & 0xFFu);
; 68   :                     _p[5] = (STRINGLIB_CHAR)((value >> 16) & 0xFFu);
; 69   :                     _p[6] = (STRINGLIB_CHAR)((value >> 8) & 0xFFu);
; 70   :                     _p[7] = (STRINGLIB_CHAR)(value & 0xFFu);
; 71   : # else
; 72   :                     _p[0] = (STRINGLIB_CHAR)((value >> 24) & 0xFFu);
; 73   :                     _p[1] = (STRINGLIB_CHAR)((value >> 16) & 0xFFu);
; 74   :                     _p[2] = (STRINGLIB_CHAR)((value >> 8) & 0xFFu);
; 75   :                     _p[3] = (STRINGLIB_CHAR)(value & 0xFFu);
; 76   : # endif
; 77   : #endif
; 78   :                     _s += SIZEOF_LONG;

  0006f	48 83 c2 04	 add	 rdx, 4
  00073	c1 e8 08	 shr	 eax, 8

; 79   :                     _p += SIZEOF_LONG;

  00076	49 83 c3 04	 add	 r11, 4
  0007a	41 88 43 fd	 mov	 BYTE PTR [r11-3], al
  0007e	8b c1		 mov	 eax, ecx
  00080	c1 e9 18	 shr	 ecx, 24
  00083	c1 e8 10	 shr	 eax, 16
  00086	41 88 4b ff	 mov	 BYTE PTR [r11-1], cl
  0008a	41 88 43 fe	 mov	 BYTE PTR [r11-2], al
  0008e	49 3b d1	 cmp	 rdx, r9
  00091	72 cd		 jb	 SHORT $LL45@ucs1lib_ut
$LN69@ucs1lib_ut:

; 80   :                 }
; 81   :                 s = _s;

  00093	4c 8b d2	 mov	 r10, rdx

; 82   :                 p = _p;
; 83   :                 if (s == end)

  00096	49 3b d0	 cmp	 rdx, r8
  00099	74 72		 je	 SHORT $LN48@ucs1lib_ut

; 84   :                     break;
; 85   :                 ch = (unsigned char)*s;

  0009b	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
$LN46@ucs1lib_ut:

; 86   :             }
; 87   :             if (ch < 0x80) {

  0009e	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  000a4	73 08		 jae	 SHORT $LN41@ucs1lib_ut

; 88   :                 s++;

  000a6	49 ff c2	 inc	 r10

; 89   :                 *p++ = ch;

  000a9	41 88 0b	 mov	 BYTE PTR [r11], cl

; 90   :                 continue;

  000ac	eb 53		 jmp	 SHORT $LN70@ucs1lib_ut
$LN41@ucs1lib_ut:

; 91   :             }
; 92   :         }
; 93   : 
; 94   :         if (ch < 0xE0) {

  000ae	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  000b4	73 72		 jae	 SHORT $LN40@ucs1lib_ut

; 95   :             /* \xC2\x80-\xDF\xBF -- 0080-07FF */
; 96   :             Py_UCS4 ch2;
; 97   :             if (ch < 0xC2) {

  000b6	81 f9 c2 00 00
	00		 cmp	 ecx, 194		; 000000c2H
  000bc	0f 82 0c 02 00
	00		 jb	 $InvalidStart$129861

; 98   :                 /* invalid sequence
; 99   :                 \x80-\xBF -- continuation byte
; 100  :                 \xC0-\xC1 -- fake 0000-007F */
; 101  :                 goto InvalidStart;
; 102  :             }
; 103  :             if (end - s < 2) {

  000c2	49 8b c0	 mov	 rax, r8
  000c5	49 2b c2	 sub	 rax, r10
  000c8	48 83 f8 02	 cmp	 rax, 2
  000cc	7c 3f		 jl	 SHORT $LN48@ucs1lib_ut

; 104  :                 /* unexpected end of data: the caller will decide whether
; 105  :                    it's an error or not */
; 106  :                 break;
; 107  :             }
; 108  :             ch2 = (unsigned char)s[1];

  000ce	41 0f b6 42 01	 movzx	 eax, BYTE PTR [r10+1]

; 109  :             if (!IS_CONTINUATION_BYTE(ch2))

  000d3	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000d8	0f 82 91 00 00
	00		 jb	 $InvalidContinuation1$129866
  000de	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  000e3	0f 83 86 00 00
	00		 jae	 $InvalidContinuation1$129866

; 110  :                 /* invalid continuation byte */
; 111  :                 goto InvalidContinuation1;
; 112  :             ch = (ch << 6) + ch2 -
; 113  :                  ((0xC0 << 6) + 0x80);

  000e9	c1 e1 06	 shl	 ecx, 6

; 114  :             assert ((ch > 0x007F) && (ch <= 0x07FF));
; 115  :             s += 2;

  000ec	49 83 c2 02	 add	 r10, 2
  000f0	8d 84 01 80 cf
	ff ff		 lea	 eax, DWORD PTR [rcx+rax-12416]

; 116  :             if (STRINGLIB_MAX_CHAR <= 0x007F ||
; 117  :                 (STRINGLIB_MAX_CHAR < 0x07FF && ch > STRINGLIB_MAX_CHAR))

  000f7	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000fc	77 11		 ja	 SHORT $Return$129870

; 118  :                 /* Out-of-range */
; 119  :                 goto Return;
; 120  :             *p++ = ch;

  000fe	41 88 03	 mov	 BYTE PTR [r11], al
$LN70@ucs1lib_ut:
  00101	49 ff c3	 inc	 r11
  00104	4d 3b d0	 cmp	 r10, r8
  00107	0f 82 33 ff ff
	ff		 jb	 $LL49@ucs1lib_ut
$LN48@ucs1lib_ut:

; 227  :             *p++ = ch;
; 228  :             continue;
; 229  :         }
; 230  :         goto InvalidStart;
; 231  :     }
; 232  :     ch = 0;

  0010d	33 c0		 xor	 eax, eax
$Return$129870:

; 233  : Return:
; 234  :     *inptr = s;
; 235  :     *outpos = p - dest;

  0010f	4c 2b df	 sub	 r11, rdi

; 249  : }

  00112	48 8b 7c 24 18	 mov	 rdi, QWORD PTR [rsp+24]
  00117	4c 89 16	 mov	 QWORD PTR [rsi], r10
  0011a	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
  0011f	4c 89 1b	 mov	 QWORD PTR [rbx], r11
  00122	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00127	c3		 ret	 0
$LN40@ucs1lib_ut:

; 121  :             continue;
; 122  :         }
; 123  : 
; 124  :         if (ch < 0xF0) {

  00128	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  0012e	0f 83 9c 00 00
	00		 jae	 $LN33@ucs1lib_ut

; 125  :             /* \xE0\xA0\x80-\xEF\xBF\xBF -- 0800-FFFF */
; 126  :             Py_UCS4 ch2, ch3;
; 127  :             if (end - s < 3) {

  00134	4d 2b c2	 sub	 r8, r10
  00137	49 83 f8 03	 cmp	 r8, 3
  0013b	7d 39		 jge	 SHORT $LN32@ucs1lib_ut

; 128  :                 /* unexpected end of data: the caller will decide whether
; 129  :                    it's an error or not */
; 130  :                 if (end - s < 2)

  0013d	49 83 f8 02	 cmp	 r8, 2
  00141	7c ca		 jl	 SHORT $LN48@ucs1lib_ut

; 131  :                     break;
; 132  :                 ch2 = (unsigned char)s[1];

  00143	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 133  :                 if (!IS_CONTINUATION_BYTE(ch2) ||
; 134  :                     (ch2 < 0xA0 ? ch == 0xE0 : ch == 0xED))

  00148	8d 42 80	 lea	 eax, DWORD PTR [rdx-128]
  0014b	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  0014e	77 1f		 ja	 SHORT $InvalidContinuation1$129866
  00150	33 c0		 xor	 eax, eax
  00152	81 fa a0 00 00
	00		 cmp	 edx, 160		; 000000a0H
  00158	73 08		 jae	 SHORT $LN52@ucs1lib_ut
  0015a	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  00160	eb 06		 jmp	 SHORT $LN71@ucs1lib_ut
$LN52@ucs1lib_ut:
  00162	81 f9 ed 00 00
	00		 cmp	 ecx, 237		; 000000edH
$LN71@ucs1lib_ut:
  00168	0f 94 c0	 sete	 al
  0016b	85 c0		 test	 eax, eax
  0016d	74 9e		 je	 SHORT $LN48@ucs1lib_ut
$InvalidContinuation1$129866:

; 240  : InvalidContinuation1:
; 241  :     ch = 2;

  0016f	b8 02 00 00 00	 mov	 eax, 2

; 242  :     goto Return;

  00174	eb 99		 jmp	 SHORT $Return$129870
$LN32@ucs1lib_ut:

; 135  :                     /* for clarification see comments below */
; 136  :                     goto InvalidContinuation1;
; 137  :                 break;
; 138  :             }
; 139  :             ch2 = (unsigned char)s[1];

  00176	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 140  :             ch3 = (unsigned char)s[2];

  0017b	45 0f b6 42 02	 movzx	 r8d, BYTE PTR [r10+2]

; 141  :             if (!IS_CONTINUATION_BYTE(ch2)) {

  00180	8d 42 80	 lea	 eax, DWORD PTR [rdx-128]
  00183	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00186	77 e7		 ja	 SHORT $InvalidContinuation1$129866

; 142  :                 /* invalid continuation byte */
; 143  :                 goto InvalidContinuation1;
; 144  :             }
; 145  :             if (ch == 0xE0) {

  00188	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  0018e	75 0a		 jne	 SHORT $LN26@ucs1lib_ut

; 146  :                 if (ch2 < 0xA0)

  00190	81 fa a0 00 00
	00		 cmp	 edx, 160		; 000000a0H
  00196	72 d7		 jb	 SHORT $InvalidContinuation1$129866

; 147  :                     /* invalid sequence
; 148  :                        \xE0\x80\x80-\xE0\x9F\xBF -- fake 0000-0800 */
; 149  :                     goto InvalidContinuation1;
; 150  :             } else if (ch == 0xED && ch2 >= 0xA0) {

  00198	eb 10		 jmp	 SHORT $LN23@ucs1lib_ut
$LN26@ucs1lib_ut:
  0019a	81 f9 ed 00 00
	00		 cmp	 ecx, 237		; 000000edH
  001a0	75 08		 jne	 SHORT $LN23@ucs1lib_ut
  001a2	81 fa a0 00 00
	00		 cmp	 edx, 160		; 000000a0H
  001a8	73 c5		 jae	 SHORT $InvalidContinuation1$129866
$LN23@ucs1lib_ut:

; 151  :                 /* Decoding UTF-8 sequences in range \xED\xA0\x80-\xED\xBF\xBF
; 152  :                    will result in surrogates in range D800-DFFF. Surrogates are
; 153  :                    not valid UTF-8 so they are rejected.
; 154  :                    See http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf
; 155  :                    (table 3-7) and http://www.rfc-editor.org/rfc/rfc3629.txt */
; 156  :                 goto InvalidContinuation1;
; 157  :             }
; 158  :             if (!IS_CONTINUATION_BYTE(ch3)) {

  001aa	41 8d 40 80	 lea	 eax, DWORD PTR [r8-128]
  001ae	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  001b1	0f 87 8d 00 00
	00		 ja	 $InvalidContinuation2$129889

; 159  :                 /* invalid continuation byte */
; 160  :                 goto InvalidContinuation2;
; 161  :             }
; 162  :             ch = (ch << 12) + (ch2 << 6) + ch3 -
; 163  :                  ((0xE0 << 12) + (0x80 << 6) + 0x80);

  001b7	c1 e1 06	 shl	 ecx, 6
  001ba	03 ca		 add	 ecx, edx
  001bc	c1 e1 06	 shl	 ecx, 6

; 164  :             assert ((ch > 0x07FF) && (ch <= 0xFFFF));
; 165  :             s += 3;

  001bf	49 83 c2 03	 add	 r10, 3
  001c3	42 8d 84 01 80
	df f1 ff	 lea	 eax, DWORD PTR [rcx+r8-925824]

; 166  :             if (STRINGLIB_MAX_CHAR <= 0x07FF ||
; 167  :                 (STRINGLIB_MAX_CHAR < 0xFFFF && ch > STRINGLIB_MAX_CHAR))
; 168  :                 /* Out-of-range */
; 169  :                 goto Return;

  001cb	e9 3f ff ff ff	 jmp	 $Return$129870
$LN33@ucs1lib_ut:

; 170  :             *p++ = ch;
; 171  :             continue;
; 172  :         }
; 173  : 
; 174  :         if (ch < 0xF5) {

  001d0	81 f9 f5 00 00
	00		 cmp	 ecx, 245		; 000000f5H
  001d6	0f 83 f2 00 00
	00		 jae	 $InvalidStart$129861

; 175  :             /* \xF0\x90\x80\x80-\xF4\x8F\xBF\xBF -- 10000-10FFFF */
; 176  :             Py_UCS4 ch2, ch3, ch4;
; 177  :             if (end - s < 4) {

  001dc	4d 2b c2	 sub	 r8, r10
  001df	49 83 f8 04	 cmp	 r8, 4
  001e3	7d 69		 jge	 SHORT $LN18@ucs1lib_ut

; 178  :                 /* unexpected end of data: the caller will decide whether
; 179  :                    it's an error or not */
; 180  :                 if (end - s < 2)

  001e5	49 83 f8 02	 cmp	 r8, 2
  001e9	0f 8c 1e ff ff
	ff		 jl	 $LN48@ucs1lib_ut

; 181  :                     break;
; 182  :                 ch2 = (unsigned char)s[1];

  001ef	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 183  :                 if (!IS_CONTINUATION_BYTE(ch2) ||
; 184  :                     (ch2 < 0x90 ? ch == 0xF0 : ch == 0xF4))

  001f4	8d 42 80	 lea	 eax, DWORD PTR [rdx-128]
  001f7	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  001fa	0f 87 6f ff ff
	ff		 ja	 $InvalidContinuation1$129866
  00200	33 c0		 xor	 eax, eax
  00202	81 fa 90 00 00
	00		 cmp	 edx, 144		; 00000090H
  00208	73 08		 jae	 SHORT $LN54@ucs1lib_ut
  0020a	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  00210	eb 06		 jmp	 SHORT $LN72@ucs1lib_ut
$LN54@ucs1lib_ut:
  00212	81 f9 f4 00 00
	00		 cmp	 ecx, 244		; 000000f4H
$LN72@ucs1lib_ut:
  00218	0f 94 c0	 sete	 al
  0021b	85 c0		 test	 eax, eax
  0021d	0f 85 4c ff ff
	ff		 jne	 $InvalidContinuation1$129866

; 185  :                     /* for clarification see comments below */
; 186  :                     goto InvalidContinuation1;
; 187  :                 if (end - s < 3)

  00223	49 83 f8 03	 cmp	 r8, 3
  00227	0f 8c e0 fe ff
	ff		 jl	 $LN48@ucs1lib_ut

; 188  :                     break;
; 189  :                 ch3 = (unsigned char)s[2];

  0022d	41 0f b6 42 02	 movzx	 eax, BYTE PTR [r10+2]

; 190  :                 if (!IS_CONTINUATION_BYTE(ch3))

  00232	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00237	72 0b		 jb	 SHORT $InvalidContinuation2$129889
  00239	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0023e	0f 82 c9 fe ff
	ff		 jb	 $LN48@ucs1lib_ut
$InvalidContinuation2$129889:

; 243  : InvalidContinuation2:
; 244  :     ch = 3;

  00244	b8 03 00 00 00	 mov	 eax, 3

; 245  :     goto Return;

  00249	e9 c1 fe ff ff	 jmp	 $Return$129870
$LN18@ucs1lib_ut:

; 191  :                     goto InvalidContinuation2;
; 192  :                 break;
; 193  :             }
; 194  :             ch2 = (unsigned char)s[1];

  0024e	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 195  :             ch3 = (unsigned char)s[2];

  00253	45 0f b6 42 02	 movzx	 r8d, BYTE PTR [r10+2]

; 196  :             ch4 = (unsigned char)s[3];

  00258	45 0f b6 4a 03	 movzx	 r9d, BYTE PTR [r10+3]

; 197  :             if (!IS_CONTINUATION_BYTE(ch2)) {

  0025d	8d 42 80	 lea	 eax, DWORD PTR [rdx-128]
  00260	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00263	0f 87 06 ff ff
	ff		 ja	 $InvalidContinuation1$129866

; 198  :                 /* invalid continuation byte */
; 199  :                 goto InvalidContinuation1;
; 200  :             }
; 201  :             if (ch == 0xF0) {

  00269	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  0026f	75 0e		 jne	 SHORT $LN9@ucs1lib_ut

; 202  :                 if (ch2 < 0x90)

  00271	81 fa 90 00 00
	00		 cmp	 edx, 144		; 00000090H
  00277	0f 82 f2 fe ff
	ff		 jb	 $InvalidContinuation1$129866

; 203  :                     /* invalid sequence
; 204  :                        \xF0\x80\x80\x80-\xF0\x8F\xBF\xBF -- fake 0000-FFFF */
; 205  :                     goto InvalidContinuation1;
; 206  :             } else if (ch == 0xF4 && ch2 >= 0x90) {

  0027d	eb 14		 jmp	 SHORT $LN6@ucs1lib_ut
$LN9@ucs1lib_ut:
  0027f	81 f9 f4 00 00
	00		 cmp	 ecx, 244		; 000000f4H
  00285	75 0c		 jne	 SHORT $LN6@ucs1lib_ut
  00287	81 fa 90 00 00
	00		 cmp	 edx, 144		; 00000090H
  0028d	0f 83 dc fe ff
	ff		 jae	 $InvalidContinuation1$129866
$LN6@ucs1lib_ut:

; 207  :                 /* invalid sequence
; 208  :                    \xF4\x90\x80\80- -- 110000- overflow */
; 209  :                 goto InvalidContinuation1;
; 210  :             }
; 211  :             if (!IS_CONTINUATION_BYTE(ch3)) {

  00293	41 8d 40 80	 lea	 eax, DWORD PTR [r8-128]
  00297	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  0029a	77 a8		 ja	 SHORT $InvalidContinuation2$129889

; 212  :                 /* invalid continuation byte */
; 213  :                 goto InvalidContinuation2;
; 214  :             }
; 215  :             if (!IS_CONTINUATION_BYTE(ch4)) {

  0029c	41 8d 41 80	 lea	 eax, DWORD PTR [r9-128]
  002a0	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  002a3	77 1f		 ja	 SHORT $InvalidContinuation3$129918

; 216  :                 /* invalid continuation byte */
; 217  :                 goto InvalidContinuation3;
; 218  :             }
; 219  :             ch = (ch << 18) + (ch2 << 12) + (ch3 << 6) + ch4 -
; 220  :                  ((0xF0 << 18) + (0x80 << 12) + (0x80 << 6) + 0x80);

  002a5	c1 e1 06	 shl	 ecx, 6
  002a8	03 ca		 add	 ecx, edx
  002aa	c1 e1 06	 shl	 ecx, 6
  002ad	41 03 c8	 add	 ecx, r8d
  002b0	c1 e1 06	 shl	 ecx, 6

; 221  :             assert ((ch > 0xFFFF) && (ch <= 0x10FFFF));
; 222  :             s += 4;

  002b3	49 83 c2 04	 add	 r10, 4
  002b7	42 8d 84 09 80
	df 37 fc	 lea	 eax, DWORD PTR [rcx+r9-63447168]

; 223  :             if (STRINGLIB_MAX_CHAR <= 0xFFFF ||
; 224  :                 (STRINGLIB_MAX_CHAR < 0x10FFFF && ch > STRINGLIB_MAX_CHAR))
; 225  :                 /* Out-of-range */
; 226  :                 goto Return;

  002bf	e9 4b fe ff ff	 jmp	 $Return$129870
$InvalidContinuation3$129918:

; 246  : InvalidContinuation3:
; 247  :     ch = 4;

  002c4	b8 04 00 00 00	 mov	 eax, 4

; 248  :     goto Return;

  002c9	e9 41 fe ff ff	 jmp	 $Return$129870
$InvalidStart$129861:

; 236  :     return ch;
; 237  : InvalidStart:
; 238  :     ch = 1;

  002ce	b8 01 00 00 00	 mov	 eax, 1

; 239  :     goto Return;

  002d3	e9 37 fe ff ff	 jmp	 $Return$129870
ucs1lib_utf8_decode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs1lib_utf8_encoder DD imagerel ucs1lib_utf8_encoder
	DD	imagerel ucs1lib_utf8_encoder+244
	DD	imagerel $unwind$ucs1lib_utf8_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_utf8_encoder DD 071201H
	DD	0546412H
	DD	0523412H
	DD	0500112H
	DD	0700bH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs1lib_utf8_encoder
_TEXT	SEGMENT
stackbuf$ = 32
data$ = 656
result$ = 664
size$ = 664
ucs1lib_utf8_encoder PROC				; COMDAT

; 262  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 80 02
	00 00		 sub	 rsp, 640		; 00000280H

; 263  : #define MAX_SHORT_UNICHARS 300  /* largest size we'll do on the stack */
; 264  : 
; 265  :     Py_ssize_t i;                /* index into s of next input byte */
; 266  :     PyObject *result;            /* result string object */
; 267  :     char *p;                     /* next free byte in output buffer */
; 268  :     Py_ssize_t nallocated;      /* number of result bytes allocated */
; 269  :     Py_ssize_t nneeded;            /* number of result bytes needed */
; 270  : #if STRINGLIB_SIZEOF_CHAR > 1
; 271  :     PyObject *errorHandler = NULL;
; 272  :     PyObject *exc = NULL;
; 273  :     PyObject *rep = NULL;
; 274  : #endif
; 275  : #if STRINGLIB_SIZEOF_CHAR == 1
; 276  :     const Py_ssize_t max_char_size = 2;
; 277  :     char stackbuf[MAX_SHORT_UNICHARS * 2];
; 278  : #elif STRINGLIB_SIZEOF_CHAR == 2
; 279  :     const Py_ssize_t max_char_size = 3;
; 280  :     char stackbuf[MAX_SHORT_UNICHARS * 3];
; 281  : #else /*  STRINGLIB_SIZEOF_CHAR == 4 */
; 282  :     const Py_ssize_t max_char_size = 4;
; 283  :     char stackbuf[MAX_SHORT_UNICHARS * 4];
; 284  : #endif
; 285  : 
; 286  :     assert(size >= 0);
; 287  : 
; 288  :     if (size <= MAX_SHORT_UNICHARS) {

  00012	33 db		 xor	 ebx, ebx
  00014	48 8b fa	 mov	 rdi, rdx
  00017	48 8b f1	 mov	 rsi, rcx
  0001a	48 81 fa 2c 01
	00 00		 cmp	 rdx, 300		; 0000012cH
  00021	7f 11		 jg	 SHORT $LN10@ucs1lib_ut@2

; 289  :         /* Write into the stack buffer; nallocated can't overflow.
; 290  :          * At the end, we'll allocate exactly as much heap space as it
; 291  :          * turns out we need.
; 292  :          */
; 293  :         nallocated = Py_SAFE_DOWNCAST(sizeof(stackbuf), size_t, int);
; 294  :         result = NULL;   /* will allocate after we're done */

  00023	8b c3		 mov	 eax, ebx
  00025	48 89 9c 24 98
	02 00 00	 mov	 QWORD PTR result$[rsp], rbx

; 295  :         p = stackbuf;

  0002d	48 8d 54 24 20	 lea	 rdx, QWORD PTR stackbuf$[rsp]

; 296  :     }
; 297  :     else {

  00032	eb 34		 jmp	 SHORT $LN9@ucs1lib_ut@2
$LN10@ucs1lib_ut@2:

; 298  :         if (size > PY_SSIZE_T_MAX / max_char_size) {

  00034	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  0003e	48 3b d0	 cmp	 rdx, rax
  00041	7e 0a		 jle	 SHORT $LN8@ucs1lib_ut@2

; 299  :             /* integer overflow */
; 300  :             return PyErr_NoMemory();

  00043	e8 00 00 00 00	 call	 PyErr_NoMemory
  00048	e9 92 00 00 00	 jmp	 $LN1@ucs1lib_ut@2
$LN8@ucs1lib_ut@2:

; 301  :         }
; 302  :         /* Overallocate on the heap, and give the excess back at the end. */
; 303  :         nallocated = size * max_char_size;

  0004d	48 03 d2	 add	 rdx, rdx

; 304  :         result = PyBytes_FromStringAndSize(NULL, nallocated);

  00050	33 c9		 xor	 ecx, ecx
  00052	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00057	48 89 84 24 98
	02 00 00	 mov	 QWORD PTR result$[rsp], rax

; 305  :         if (result == NULL)

  0005f	48 85 c0	 test	 rax, rax
  00062	74 7b		 je	 SHORT $LN1@ucs1lib_ut@2
$LN7@ucs1lib_ut@2:

; 306  :             return NULL;
; 307  :         p = PyBytes_AS_STRING(result);

  00064	48 8d 50 78	 lea	 rdx, QWORD PTR [rax+120]
$LN9@ucs1lib_ut@2:

; 308  :     }
; 309  : 
; 310  :     for (i = 0; i < size;) {

  00068	48 85 ff	 test	 rdi, rdi
  0006b	7e 3d		 jle	 SHORT $LN5@ucs1lib_ut@2
  0006d	0f 1f 00	 npad	 3
$LL6@ucs1lib_ut@2:

; 311  :         Py_UCS4 ch = data[i++];

  00070	0f b6 0c 33	 movzx	 ecx, BYTE PTR [rbx+rsi]
  00074	48 ff c3	 inc	 rbx

; 312  : 
; 313  :         if (ch < 0x80) {

  00077	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0007d	73 07		 jae	 SHORT $LN4@ucs1lib_ut@2

; 314  :             /* Encode ASCII */
; 315  :             *p++ = (char) ch;

  0007f	88 0a		 mov	 BYTE PTR [rdx], cl
  00081	48 ff c2	 inc	 rdx

; 316  : 
; 317  :         }
; 318  :         else

  00084	eb 17		 jmp	 SHORT $LN3@ucs1lib_ut@2
$LN4@ucs1lib_ut@2:

; 319  : #if STRINGLIB_SIZEOF_CHAR > 1
; 320  :         if (ch < 0x0800)
; 321  : #endif
; 322  :         {
; 323  :             /* Encode Latin-1 */
; 324  :             *p++ = (char)(0xc0 | (ch >> 6));

  00086	8b c1		 mov	 eax, ecx

; 325  :             *p++ = (char)(0x80 | (ch & 0x3f));

  00088	80 e1 3f	 and	 cl, 63			; 0000003fH
  0008b	c1 e8 06	 shr	 eax, 6
  0008e	80 c9 80	 or	 cl, -128		; ffffffffffffff80H
  00091	0c c0		 or	 al, -64			; ffffffffffffffc0H
  00093	48 83 c2 02	 add	 rdx, 2
  00097	88 42 fe	 mov	 BYTE PTR [rdx-2], al
  0009a	88 4a ff	 mov	 BYTE PTR [rdx-1], cl
$LN3@ucs1lib_ut@2:

; 308  :     }
; 309  : 
; 310  :     for (i = 0; i < size;) {

  0009d	48 3b df	 cmp	 rbx, rdi
  000a0	7c ce		 jl	 SHORT $LL6@ucs1lib_ut@2
  000a2	48 8b 84 24 98
	02 00 00	 mov	 rax, QWORD PTR result$[rsp]
$LN5@ucs1lib_ut@2:

; 326  :         }
; 327  : #if STRINGLIB_SIZEOF_CHAR > 1
; 328  :         else if (Py_UNICODE_IS_SURROGATE(ch)) {
; 329  :             Py_ssize_t newpos;
; 330  :             Py_ssize_t repsize, k, startpos;
; 331  :             startpos = i-1;
; 332  :             rep = unicode_encode_call_errorhandler(
; 333  :                   errors, &errorHandler, "utf-8", "surrogates not allowed",
; 334  :                   unicode, &exc, startpos, startpos+1, &newpos);
; 335  :             if (!rep)
; 336  :                 goto error;
; 337  : 
; 338  :             if (PyBytes_Check(rep))
; 339  :                 repsize = PyBytes_GET_SIZE(rep);
; 340  :             else
; 341  :                 repsize = PyUnicode_GET_LENGTH(rep);
; 342  : 
; 343  :             if (repsize > max_char_size) {
; 344  :                 Py_ssize_t offset;
; 345  : 
; 346  :                 if (result == NULL)
; 347  :                     offset = p - stackbuf;
; 348  :                 else
; 349  :                     offset = p - PyBytes_AS_STRING(result);
; 350  : 
; 351  :                 if (nallocated > PY_SSIZE_T_MAX - repsize + max_char_size) {
; 352  :                     /* integer overflow */
; 353  :                     PyErr_NoMemory();
; 354  :                     goto error;
; 355  :                 }
; 356  :                 nallocated += repsize - max_char_size;
; 357  :                 if (result != NULL) {
; 358  :                     if (_PyBytes_Resize(&result, nallocated) < 0)
; 359  :                         goto error;
; 360  :                 } else {
; 361  :                     result = PyBytes_FromStringAndSize(NULL, nallocated);
; 362  :                     if (result == NULL)
; 363  :                         goto error;
; 364  :                     Py_MEMCPY(PyBytes_AS_STRING(result), stackbuf, offset);
; 365  :                 }
; 366  :                 p = PyBytes_AS_STRING(result) + offset;
; 367  :             }
; 368  : 
; 369  :             if (PyBytes_Check(rep)) {
; 370  :                 char *prep = PyBytes_AS_STRING(rep);
; 371  :                 for(k = repsize; k > 0; k--)
; 372  :                     *p++ = *prep++;
; 373  :             } else /* rep is unicode */ {
; 374  :                 enum PyUnicode_Kind repkind;
; 375  :                 void *repdata;
; 376  : 
; 377  :                 if (PyUnicode_READY(rep) < 0)
; 378  :                     goto error;
; 379  :                 repkind = PyUnicode_KIND(rep);
; 380  :                 repdata = PyUnicode_DATA(rep);
; 381  : 
; 382  :                 for(k=0; k<repsize; k++) {
; 383  :                     Py_UCS4 c = PyUnicode_READ(repkind, repdata, k);
; 384  :                     if (0x80 <= c) {
; 385  :                         raise_encode_exception(&exc, "utf-8",
; 386  :                                                unicode,
; 387  :                                                i-1, i,
; 388  :                                                "surrogates not allowed");
; 389  :                         goto error;
; 390  :                     }
; 391  :                     *p++ = (char)c;
; 392  :                 }
; 393  :             }
; 394  :             Py_CLEAR(rep);
; 395  :         }
; 396  :         else
; 397  : #if STRINGLIB_SIZEOF_CHAR > 2
; 398  :         if (ch < 0x10000)
; 399  : #endif
; 400  :         {
; 401  :             *p++ = (char)(0xe0 | (ch >> 12));
; 402  :             *p++ = (char)(0x80 | ((ch >> 6) & 0x3f));
; 403  :             *p++ = (char)(0x80 | (ch & 0x3f));
; 404  :         }
; 405  : #if STRINGLIB_SIZEOF_CHAR > 2
; 406  :         else /* ch >= 0x10000 */
; 407  :         {
; 408  :             assert(ch <= MAX_UNICODE);
; 409  :             /* Encode UCS4 Unicode ordinals */
; 410  :             *p++ = (char)(0xf0 | (ch >> 18));
; 411  :             *p++ = (char)(0x80 | ((ch >> 12) & 0x3f));
; 412  :             *p++ = (char)(0x80 | ((ch >> 6) & 0x3f));
; 413  :             *p++ = (char)(0x80 | (ch & 0x3f));
; 414  :         }
; 415  : #endif /* STRINGLIB_SIZEOF_CHAR > 2 */
; 416  : #endif /* STRINGLIB_SIZEOF_CHAR > 1 */
; 417  :     }
; 418  : 
; 419  :     if (result == NULL) {

  000aa	48 85 c0	 test	 rax, rax
  000ad	75 14		 jne	 SHORT $LN2@ucs1lib_ut@2

; 420  :         /* This was stack allocated. */
; 421  :         nneeded = p - stackbuf;

  000af	48 8d 44 24 20	 lea	 rax, QWORD PTR stackbuf$[rsp]

; 422  :         assert(nneeded <= nallocated);
; 423  :         result = PyBytes_FromStringAndSize(stackbuf, nneeded);

  000b4	48 8d 4c 24 20	 lea	 rcx, QWORD PTR stackbuf$[rsp]
  000b9	48 2b d0	 sub	 rdx, rax
  000bc	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 424  :     }
; 425  :     else {

  000c1	eb 1c		 jmp	 SHORT $LN1@ucs1lib_ut@2
$LN2@ucs1lib_ut@2:

; 426  :         /* Cut back to size actually needed. */
; 427  :         nneeded = p - PyBytes_AS_STRING(result);
; 428  :         assert(nneeded <= nallocated);
; 429  :         _PyBytes_Resize(&result, nneeded);

  000c3	48 2b d0	 sub	 rdx, rax
  000c6	48 8d 8c 24 98
	02 00 00	 lea	 rcx, QWORD PTR result$[rsp]
  000ce	48 83 ea 78	 sub	 rdx, 120		; 00000078H
  000d2	e8 00 00 00 00	 call	 _PyBytes_Resize
  000d7	48 8b 84 24 98
	02 00 00	 mov	 rax, QWORD PTR result$[rsp]
$LN1@ucs1lib_ut@2:

; 430  :     }
; 431  : 
; 432  : #if STRINGLIB_SIZEOF_CHAR > 1
; 433  :     Py_XDECREF(errorHandler);
; 434  :     Py_XDECREF(exc);
; 435  : #endif
; 436  :     return result;
; 437  : 
; 438  : #if STRINGLIB_SIZEOF_CHAR > 1
; 439  :  error:
; 440  :     Py_XDECREF(rep);
; 441  :     Py_XDECREF(errorHandler);
; 442  :     Py_XDECREF(exc);
; 443  :     Py_XDECREF(result);
; 444  :     return NULL;
; 445  : #endif
; 446  : 
; 447  : #undef MAX_SHORT_UNICHARS
; 448  : }

  000df	4c 8d 9c 24 80
	02 00 00	 lea	 r11, QWORD PTR [rsp+640]
  000e7	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000eb	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  000ef	49 8b e3	 mov	 rsp, r11
  000f2	5f		 pop	 rdi
  000f3	c3		 ret	 0
ucs1lib_utf8_encoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs1lib_utf16_decode DD imagerel ucs1lib_utf16_decode
	DD	imagerel ucs1lib_utf16_decode+335
	DD	imagerel $unwind$ucs1lib_utf16_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_utf16_decode DD 091601H
	DD	057416H
	DD	046416H
	DD	035416H
	DD	023416H
	DD	0c016H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs1lib_utf16_decode
_TEXT	SEGMENT
inptr$ = 16
e$ = 24
dest$ = 32
outpos$ = 40
native_ordering$ = 48
ucs1lib_utf16_decode PROC				; COMDAT

; 482  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12

; 483  :     Py_UCS4 ch;
; 484  :     const unsigned char *aligned_end =
; 485  :             (const unsigned char *) _Py_ALIGN_DOWN(e, SIZEOF_LONG);
; 486  :     const unsigned char *q = *inptr;

  00016	4c 8b 19	 mov	 r11, QWORD PTR [rcx]

; 487  :     STRINGLIB_CHAR *p = dest + *outpos;
; 488  :     /* Offsets from q for retrieving byte pairs in the right order. */
; 489  : #ifdef BYTEORDER_IS_LITTLE_ENDIAN
; 490  :     int ihi = !!native_ordering, ilo = !native_ordering;

  00019	45 33 d2	 xor	 r10d, r10d
  0001c	49 8b e8	 mov	 rbp, r8
  0001f	4d 8b 01	 mov	 r8, QWORD PTR [r9]

; 491  : #else
; 492  :     int ihi = !native_ordering, ilo = !!native_ordering;
; 493  : #endif
; 494  :     --e;

  00022	48 8d 5a ff	 lea	 rbx, QWORD PTR [rdx-1]
  00026	48 83 e2 fc	 and	 rdx, -4
  0002a	4c 03 c5	 add	 r8, rbp
  0002d	49 8b f1	 mov	 rsi, r9
  00030	44 8b 4c 24 30	 mov	 r9d, DWORD PTR native_ordering$[rsp]
  00035	45 85 c9	 test	 r9d, r9d
  00038	4c 8b e1	 mov	 r12, rcx
  0003b	41 0f 95 c2	 setne	 r10b
  0003f	33 c0		 xor	 eax, eax
  00041	45 85 c9	 test	 r9d, r9d
  00044	0f 94 c0	 sete	 al
  00047	4d 63 d2	 movsxd	 r10, r10d
  0004a	48 63 f8	 movsxd	 rdi, eax

; 495  : 
; 496  :     while (q < e) {

  0004d	4c 3b db	 cmp	 r11, rbx
  00050	73 7d		 jae	 SHORT $LN29@ucs1lib_ut@3
$LL18@ucs1lib_ut@3:

; 497  :         Py_UCS4 ch2;
; 498  :         /* First check for possible aligned read of a C 'long'. Unaligned
; 499  :            reads are more expensive, better to defer to another iteration. */
; 500  :         if (_Py_IS_ALIGNED(q, SIZEOF_LONG)) {

  00052	41 f6 c3 03	 test	 r11b, 3
  00056	75 41		 jne	 SHORT $LN9@ucs1lib_ut@3

; 501  :             /* Fast path for runs of in-range non-surrogate chars. */
; 502  :             register const unsigned char *_q = q;

  00058	49 8b cb	 mov	 rcx, r11

; 503  :             while (_q < aligned_end) {

  0005b	4c 3b da	 cmp	 r11, rdx
  0005e	73 31		 jae	 SHORT $LN30@ucs1lib_ut@3
$LL15@ucs1lib_ut@3:

; 504  :                 unsigned long block = * (unsigned long *) _q;

  00060	8b 01		 mov	 eax, DWORD PTR [rcx]

; 505  :                 if (native_ordering) {

  00062	45 85 c9	 test	 r9d, r9d
  00065	74 09		 je	 SHORT $LN13@ucs1lib_ut@3

; 506  :                     /* Can use buffer directly */
; 507  :                     if (block & FAST_CHAR_MASK)

  00067	a9 00 ff 00 ff	 test	 eax, -16711936		; ff00ff00H
  0006c	75 23		 jne	 SHORT $LN30@ucs1lib_ut@3

; 508  :                         break;
; 509  :                 }
; 510  :                 else {

  0006e	eb 0a		 jmp	 SHORT $LN11@ucs1lib_ut@3
$LN13@ucs1lib_ut@3:

; 511  :                     /* Need to byte-swap */
; 512  :                     if (block & SWAB(FAST_CHAR_MASK))

  00070	a9 ff 00 ff 00	 test	 eax, 16711935		; 00ff00ffH
  00075	75 1a		 jne	 SHORT $LN30@ucs1lib_ut@3

; 513  :                         break;
; 514  : #if STRINGLIB_SIZEOF_CHAR == 1
; 515  :                     block >>= 8;

  00077	c1 e8 08	 shr	 eax, 8
$LN11@ucs1lib_ut@3:

; 516  : #else
; 517  :                     block = SWAB(block);
; 518  : #endif
; 519  :                 }
; 520  : #ifdef BYTEORDER_IS_LITTLE_ENDIAN
; 521  : # if SIZEOF_LONG == 4
; 522  :                 p[0] = (STRINGLIB_CHAR)(block & 0xFFFFu);

  0007a	41 88 00	 mov	 BYTE PTR [r8], al

; 523  :                 p[1] = (STRINGLIB_CHAR)(block >> 16);

  0007d	c1 e8 10	 shr	 eax, 16

; 524  : # elif SIZEOF_LONG == 8
; 525  :                 p[0] = (STRINGLIB_CHAR)(block & 0xFFFFu);
; 526  :                 p[1] = (STRINGLIB_CHAR)((block >> 16) & 0xFFFFu);
; 527  :                 p[2] = (STRINGLIB_CHAR)((block >> 32) & 0xFFFFu);
; 528  :                 p[3] = (STRINGLIB_CHAR)(block >> 48);
; 529  : # endif
; 530  : #else
; 531  : # if SIZEOF_LONG == 4
; 532  :                 p[0] = (STRINGLIB_CHAR)(block >> 16);
; 533  :                 p[1] = (STRINGLIB_CHAR)(block & 0xFFFFu);
; 534  : # elif SIZEOF_LONG == 8
; 535  :                 p[0] = (STRINGLIB_CHAR)(block >> 48);
; 536  :                 p[1] = (STRINGLIB_CHAR)((block >> 32) & 0xFFFFu);
; 537  :                 p[2] = (STRINGLIB_CHAR)((block >> 16) & 0xFFFFu);
; 538  :                 p[3] = (STRINGLIB_CHAR)(block & 0xFFFFu);
; 539  : # endif
; 540  : #endif
; 541  :                 _q += SIZEOF_LONG;

  00080	48 83 c1 04	 add	 rcx, 4
  00084	41 88 40 01	 mov	 BYTE PTR [r8+1], al

; 542  :                 p += SIZEOF_LONG / 2;

  00088	49 83 c0 02	 add	 r8, 2
  0008c	48 3b ca	 cmp	 rcx, rdx
  0008f	72 cf		 jb	 SHORT $LL15@ucs1lib_ut@3
$LN30@ucs1lib_ut@3:

; 543  :             }
; 544  :             q = _q;

  00091	4c 8b d9	 mov	 r11, rcx

; 545  :             if (q >= e)

  00094	48 3b cb	 cmp	 rcx, rbx
  00097	73 36		 jae	 SHORT $LN29@ucs1lib_ut@3
$LN9@ucs1lib_ut@3:

; 546  :                 break;
; 547  :         }
; 548  : 
; 549  :         ch = (q[ihi] << 8) | q[ilo];

  00099	43 0f b6 0c 1a	 movzx	 ecx, BYTE PTR [r10+r11]
  0009e	42 0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+r11]

; 550  :         q += 2;

  000a3	49 83 c3 02	 add	 r11, 2
  000a7	c1 e1 08	 shl	 ecx, 8
  000aa	0b c8		 or	 ecx, eax

; 551  :         if (!Py_UNICODE_IS_SURROGATE(ch)) {

  000ac	81 f9 00 d8 00
	00		 cmp	 ecx, 55296		; 0000d800H
  000b2	72 08		 jb	 SHORT $LN7@ucs1lib_ut@3
  000b4	81 f9 ff df 00
	00		 cmp	 ecx, 57343		; 0000dfffH
  000ba	76 38		 jbe	 SHORT $LN8@ucs1lib_ut@3
$LN7@ucs1lib_ut@3:

; 552  : #if STRINGLIB_SIZEOF_CHAR < 2
; 553  :             if (ch > STRINGLIB_MAX_CHAR)

  000bc	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  000c2	77 0d		 ja	 SHORT $Return$130018

; 554  :                 /* Out-of-range */
; 555  :                 goto Return;
; 556  : #endif
; 557  :             *p++ = (STRINGLIB_CHAR)ch;

  000c4	41 88 08	 mov	 BYTE PTR [r8], cl
  000c7	49 ff c0	 inc	 r8
  000ca	4c 3b db	 cmp	 r11, rbx
  000cd	72 83		 jb	 SHORT $LL18@ucs1lib_ut@3
$LN29@ucs1lib_ut@3:

; 574  : #else
; 575  :         *p++ = (STRINGLIB_CHAR)ch;
; 576  : #endif
; 577  :     }
; 578  :     ch = 0;

  000cf	33 c9		 xor	 ecx, ecx
$Return$130018:

; 592  : }

  000d1	48 8b 5c 24 10	 mov	 rbx, QWORD PTR [rsp+16]
  000d6	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]
  000db	4c 2b c5	 sub	 r8, rbp
  000de	48 8b 6c 24 18	 mov	 rbp, QWORD PTR [rsp+24]
  000e3	4d 89 1c 24	 mov	 QWORD PTR [r12], r11
  000e7	4c 89 06	 mov	 QWORD PTR [rsi], r8
  000ea	48 8b 74 24 20	 mov	 rsi, QWORD PTR [rsp+32]
  000ef	8b c1		 mov	 eax, ecx
  000f1	41 5c		 pop	 r12
  000f3	c3		 ret	 0
$LN8@ucs1lib_ut@3:

; 558  :             continue;
; 559  :         }
; 560  : 
; 561  :         /* UTF-16 code pair: */
; 562  :         if (q >= e)

  000f4	4c 3b db	 cmp	 r11, rbx
  000f7	72 07		 jb	 SHORT $LN5@ucs1lib_ut@3
$UnexpectedEnd$130021:

; 579  : Return:
; 580  :     *inptr = q;
; 581  :     *outpos = p - dest;
; 582  :     return ch;
; 583  : UnexpectedEnd:
; 584  :     ch = 1;

  000f9	b9 01 00 00 00	 mov	 ecx, 1

; 585  :     goto Return;

  000fe	eb d1		 jmp	 SHORT $Return$130018
$LN5@ucs1lib_ut@3:

; 563  :             goto UnexpectedEnd;
; 564  :         if (!Py_UNICODE_IS_HIGH_SURROGATE(ch))

  00100	81 f9 ff db 00
	00		 cmp	 ecx, 56319		; 0000dbffH
  00106	77 40		 ja	 SHORT $IllegalEncoding$130024

; 565  :             goto IllegalEncoding;
; 566  :         ch2 = (q[ihi] << 8) | q[ilo];

  00108	42 0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+r11]
  0010d	43 0f b6 14 1a	 movzx	 edx, BYTE PTR [r10+r11]

; 567  :         q += 2;

  00112	49 83 c3 02	 add	 r11, 2
  00116	c1 e2 08	 shl	 edx, 8
  00119	0b d0		 or	 edx, eax

; 568  :         if (!Py_UNICODE_IS_LOW_SURROGATE(ch2))

  0011b	8d 82 00 24 ff
	ff		 lea	 eax, DWORD PTR [rdx-56320]
  00121	3d ff 03 00 00	 cmp	 eax, 1023		; 000003ffH
  00126	77 19		 ja	 SHORT $IllegalSurrogate$130027

; 569  :             goto IllegalSurrogate;
; 570  :         ch = Py_UNICODE_JOIN_SURROGATES(ch, ch2);

  00128	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0012e	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00134	c1 e1 0a	 shl	 ecx, 10
  00137	0b ca		 or	 ecx, edx
  00139	81 c1 00 00 01
	00		 add	 ecx, 65536		; 00010000H

; 571  : #if STRINGLIB_SIZEOF_CHAR < 4
; 572  :         /* Out-of-range */
; 573  :         goto Return;

  0013f	eb 90		 jmp	 SHORT $Return$130018
$IllegalSurrogate$130027:

; 589  : IllegalSurrogate:
; 590  :     ch = 3;

  00141	b9 03 00 00 00	 mov	 ecx, 3

; 591  :     goto Return;

  00146	eb 89		 jmp	 SHORT $Return$130018
$IllegalEncoding$130024:

; 586  : IllegalEncoding:
; 587  :     ch = 2;

  00148	b9 02 00 00 00	 mov	 ecx, 2

; 588  :     goto Return;

  0014d	eb 82		 jmp	 SHORT $Return$130018
ucs1lib_utf16_decode ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ucs1lib_utf16_encode
_TEXT	SEGMENT
out$ = 8
in$ = 16
len$ = 24
native_ordering$ = 32
ucs1lib_utf16_encode PROC				; COMDAT

; 605  :     const STRINGLIB_CHAR *end = in + len;

  00000	4e 8d 14 02	 lea	 r10, QWORD PTR [rdx+r8]

; 606  : #if STRINGLIB_SIZEOF_CHAR == 1
; 607  : # define SWAB2(CH)  ((CH) << 8)
; 608  : #else
; 609  : # define SWAB2(CH)  (((CH) << 8) | ((CH) >> 8))
; 610  : #endif
; 611  : #if STRINGLIB_MAX_CHAR < 0x10000
; 612  :     if (native_ordering) {

  00004	45 85 c9	 test	 r9d, r9d
  00007	74 6c		 je	 SHORT $LN13@ucs1lib_ut@4

; 613  : # if STRINGLIB_SIZEOF_CHAR == 2
; 614  :         Py_MEMCPY(out, in, 2 * len);
; 615  : # else
; 616  :         _PyUnicode_CONVERT_BYTES(STRINGLIB_CHAR, unsigned short, in, end, out);

  00009	4d 8b c2	 mov	 r8, r10
  0000c	4c 2b c2	 sub	 r8, rdx
  0000f	49 83 e0 fc	 and	 r8, -4
  00013	4c 03 c2	 add	 r8, rdx
  00016	49 3b d0	 cmp	 rdx, r8
  00019	73 31		 jae	 SHORT $LN17@ucs1lib_ut@4
  0001b	0f 1f 44 00 00	 npad	 5
$LL9@ucs1lib_ut@4:
  00020	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00023	48 83 c2 04	 add	 rdx, 4
  00027	48 83 c1 08	 add	 rcx, 8
  0002b	66 89 41 f8	 mov	 WORD PTR [rcx-8], ax
  0002f	0f b6 42 fd	 movzx	 eax, BYTE PTR [rdx-3]
  00033	66 89 41 fa	 mov	 WORD PTR [rcx-6], ax
  00037	0f b6 42 fe	 movzx	 eax, BYTE PTR [rdx-2]
  0003b	66 89 41 fc	 mov	 WORD PTR [rcx-4], ax
  0003f	0f b6 42 ff	 movzx	 eax, BYTE PTR [rdx-1]
  00043	66 89 41 fe	 mov	 WORD PTR [rcx-2], ax
  00047	49 3b d0	 cmp	 rdx, r8
  0004a	72 d4		 jb	 SHORT $LL9@ucs1lib_ut@4
$LN17@ucs1lib_ut@4:
  0004c	49 3b d2	 cmp	 rdx, r10
  0004f	0f 83 84 00 00
	00		 jae	 $LN1@ucs1lib_ut@4
  00055	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL7@ucs1lib_ut@4:
  00060	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00063	48 ff c2	 inc	 rdx
  00066	48 83 c1 02	 add	 rcx, 2
  0006a	66 89 41 fe	 mov	 WORD PTR [rcx-2], ax
  0006e	49 3b d2	 cmp	 rdx, r10
  00071	72 ed		 jb	 SHORT $LL7@ucs1lib_ut@4

; 630  :         }
; 631  :     }
; 632  : #else
; 633  :     if (native_ordering) {
; 634  :         while (in < end) {
; 635  :             Py_UCS4 ch = *in++;
; 636  :             if (ch < 0x10000)
; 637  :                 *out++ = ch;
; 638  :             else {
; 639  :                 out[0] = Py_UNICODE_HIGH_SURROGATE(ch);
; 640  :                 out[1] = Py_UNICODE_LOW_SURROGATE(ch);
; 641  :                 out += 2;
; 642  :             }
; 643  :         }
; 644  :     } else {
; 645  :         while (in < end) {
; 646  :             Py_UCS4 ch = *in++;
; 647  :             if (ch < 0x10000)
; 648  :                 *out++ = SWAB2((Py_UCS2)ch);
; 649  :             else {
; 650  :                 Py_UCS2 ch1 = Py_UNICODE_HIGH_SURROGATE(ch);
; 651  :                 Py_UCS2 ch2 = Py_UNICODE_LOW_SURROGATE(ch);
; 652  :                 out[0] = SWAB2(ch1);
; 653  :                 out[1] = SWAB2(ch2);
; 654  :                 out += 2;
; 655  :             }
; 656  :         }
; 657  :     }
; 658  : #endif
; 659  : #undef SWAB2
; 660  : }

  00073	f3 c3		 fatret	 0
$LN13@ucs1lib_ut@4:

; 617  : # endif
; 618  :     } else {
; 619  :         const STRINGLIB_CHAR *unrolled_end = in + _Py_SIZE_ROUND_DOWN(len, 4);

  00075	49 83 e0 fc	 and	 r8, -4
  00079	4c 03 c2	 add	 r8, rdx

; 620  :         while (in < unrolled_end) {

  0007c	49 3b d0	 cmp	 rdx, r8
  0007f	73 3c		 jae	 SHORT $LN19@ucs1lib_ut@4
$LL4@ucs1lib_ut@4:

; 621  :             out[0] = SWAB2(in[0]);

  00081	0f b6 02	 movzx	 eax, BYTE PTR [rdx]

; 622  :             out[1] = SWAB2(in[1]);
; 623  :             out[2] = SWAB2(in[2]);
; 624  :             out[3] = SWAB2(in[3]);
; 625  :             in += 4; out += 4;

  00084	48 83 c2 04	 add	 rdx, 4
  00088	48 83 c1 08	 add	 rcx, 8
  0008c	66 c1 e0 08	 shl	 ax, 8
  00090	66 89 41 f8	 mov	 WORD PTR [rcx-8], ax
  00094	0f b6 42 fd	 movzx	 eax, BYTE PTR [rdx-3]
  00098	66 c1 e0 08	 shl	 ax, 8
  0009c	66 89 41 fa	 mov	 WORD PTR [rcx-6], ax
  000a0	0f b6 42 fe	 movzx	 eax, BYTE PTR [rdx-2]
  000a4	66 c1 e0 08	 shl	 ax, 8
  000a8	66 89 41 fc	 mov	 WORD PTR [rcx-4], ax
  000ac	0f b6 42 ff	 movzx	 eax, BYTE PTR [rdx-1]
  000b0	66 c1 e0 08	 shl	 ax, 8
  000b4	66 89 41 fe	 mov	 WORD PTR [rcx-2], ax
  000b8	49 3b d0	 cmp	 rdx, r8
  000bb	72 c4		 jb	 SHORT $LL4@ucs1lib_ut@4
$LN19@ucs1lib_ut@4:

; 626  :         }
; 627  :         while (in < end) {

  000bd	49 3b d2	 cmp	 rdx, r10
  000c0	73 17		 jae	 SHORT $LN1@ucs1lib_ut@4
$LL2@ucs1lib_ut@4:

; 628  :             *out++ = SWAB2(*in);

  000c2	0f b6 02	 movzx	 eax, BYTE PTR [rdx]

; 629  :             ++in;

  000c5	48 ff c2	 inc	 rdx
  000c8	48 83 c1 02	 add	 rcx, 2
  000cc	66 c1 e0 08	 shl	 ax, 8
  000d0	66 89 41 fe	 mov	 WORD PTR [rcx-2], ax
  000d4	49 3b d2	 cmp	 rdx, r10
  000d7	72 e9		 jb	 SHORT $LL2@ucs1lib_ut@4
$LN1@ucs1lib_ut@4:

; 630  :         }
; 631  :     }
; 632  : #else
; 633  :     if (native_ordering) {
; 634  :         while (in < end) {
; 635  :             Py_UCS4 ch = *in++;
; 636  :             if (ch < 0x10000)
; 637  :                 *out++ = ch;
; 638  :             else {
; 639  :                 out[0] = Py_UNICODE_HIGH_SURROGATE(ch);
; 640  :                 out[1] = Py_UNICODE_LOW_SURROGATE(ch);
; 641  :                 out += 2;
; 642  :             }
; 643  :         }
; 644  :     } else {
; 645  :         while (in < end) {
; 646  :             Py_UCS4 ch = *in++;
; 647  :             if (ch < 0x10000)
; 648  :                 *out++ = SWAB2((Py_UCS2)ch);
; 649  :             else {
; 650  :                 Py_UCS2 ch1 = Py_UNICODE_HIGH_SURROGATE(ch);
; 651  :                 Py_UCS2 ch2 = Py_UNICODE_LOW_SURROGATE(ch);
; 652  :                 out[0] = SWAB2(ch1);
; 653  :                 out[1] = SWAB2(ch2);
; 654  :                 out += 2;
; 655  :             }
; 656  :         }
; 657  :     }
; 658  : #endif
; 659  : #undef SWAB2
; 660  : }

  000d9	f3 c3		 fatret	 0
ucs1lib_utf16_encode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs2lib_utf8_decode DD imagerel ucs2lib_utf8_decode
	DD	imagerel ucs2lib_utf8_decode+51
	DD	imagerel $unwind$ucs2lib_utf8_decode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ucs2lib_utf8_decode DD imagerel ucs2lib_utf8_decode+51
	DD	imagerel ucs2lib_utf8_decode+773
	DD	imagerel $chain$2$ucs2lib_utf8_decode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ucs2lib_utf8_decode DD imagerel ucs2lib_utf8_decode+773
	DD	imagerel ucs2lib_utf8_decode+799
	DD	imagerel $chain$3$ucs2lib_utf8_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ucs2lib_utf8_decode DD 021H
	DD	imagerel ucs2lib_utf8_decode
	DD	imagerel ucs2lib_utf8_decode+51
	DD	imagerel $unwind$ucs2lib_utf8_decode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ucs2lib_utf8_decode DD 060f21H
	DD	07f40fH
	DD	06e40aH
	DD	05d405H
	DD	imagerel ucs2lib_utf8_decode
	DD	imagerel ucs2lib_utf8_decode+51
	DD	imagerel $unwind$ucs2lib_utf8_decode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_utf8_decode DD 060a01H
	DD	08340aH
	DD	07008c00aH
	DD	050066007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs2lib_utf8_decode
_TEXT	SEGMENT
inptr$ = 40
end$ = 48
dest$ = 56
outpos$ = 64
ucs2lib_utf8_decode PROC				; COMDAT

; 22   : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12

; 23   :     Py_UCS4 ch;
; 24   :     const char *s = *inptr;

  0000a	4c 8b 11	 mov	 r10, QWORD PTR [rcx]

; 25   :     const char *aligned_end = (const char *) _Py_ALIGN_DOWN(end, SIZEOF_LONG);
; 26   :     STRINGLIB_CHAR *p = dest + *outpos;

  0000d	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00010	49 8b e8	 mov	 rbp, r8
  00013	48 8b fa	 mov	 rdi, rdx

; 27   : 
; 28   :     while (s < end) {

  00016	33 db		 xor	 ebx, ebx
  00018	49 8b f1	 mov	 rsi, r9
  0001b	48 83 e7 fc	 and	 rdi, -4
  0001f	4c 8d 5c 45 00	 lea	 r11, QWORD PTR [rbp+rax*2]
  00024	4c 8b c2	 mov	 r8, rdx
  00027	4c 8b e1	 mov	 r12, rcx
  0002a	4c 3b d2	 cmp	 r10, rdx
  0002d	0f 83 d2 02 00
	00		 jae	 $Return$130139
  00033	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  00038	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  0003d	4c 89 7c 24 38	 mov	 QWORD PTR [rsp+56], r15
  00042	41 bf 80 20 00
	00		 mov	 r15d, 8320		; 00002080H
  00048	41 bd ff 00 00
	00		 mov	 r13d, 255		; 000000ffH
  0004e	41 be 80 30 00
	00		 mov	 r14d, 12416		; 00003080H
$LL48@ucs2lib_ut:

; 29   :         ch = (unsigned char)*s;

  00054	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]

; 30   : 
; 31   :         if (ch < 0x80) {

  00058	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0005e	73 7a		 jae	 SHORT $LN40@ucs2lib_ut

; 32   :             /* Fast path for runs of ASCII characters. Given that common UTF-8
; 33   :                input will consist of an overwhelming majority of ASCII
; 34   :                characters, we try to optimize for this case by checking
; 35   :                as many characters as a C 'long' can contain.
; 36   :                First, check if we can do an aligned read, as most CPUs have
; 37   :                a penalty for unaligned reads.
; 38   :             */
; 39   :             if (_Py_IS_ALIGNED(s, SIZEOF_LONG)) {

  00060	41 f6 c2 03	 test	 r10b, 3
  00064	75 64		 jne	 SHORT $LN45@ucs2lib_ut

; 40   :                 /* Help register allocation */
; 41   :                 register const char *_s = s;

  00066	49 8b d2	 mov	 rdx, r10

; 42   :                 register STRINGLIB_CHAR *_p = p;
; 43   :                 while (_s < aligned_end) {

  00069	4c 3b d7	 cmp	 r10, rdi
  0006c	73 4d		 jae	 SHORT $LN72@ucs2lib_ut
  0006e	66 90		 npad	 2
$LL44@ucs2lib_ut:

; 44   :                     /* Read a whole long at a time (either 4 or 8 bytes),
; 45   :                        and do a fast unrolled copy if it only contains ASCII
; 46   :                        characters. */
; 47   :                     unsigned long value = *(unsigned long *) _s;

  00070	8b 0a		 mov	 ecx, DWORD PTR [rdx]

; 48   :                     if (value & ASCII_CHAR_MASK)

  00072	f7 c1 80 80 80
	80		 test	 ecx, -2139062144	; 80808080H
  00078	75 41		 jne	 SHORT $LN72@ucs2lib_ut

; 49   :                         break;
; 50   : #ifdef BYTEORDER_IS_LITTLE_ENDIAN
; 51   :                     _p[0] = (STRINGLIB_CHAR)(value & 0xFFu);

  0007a	0f b7 c1	 movzx	 eax, cx

; 52   :                     _p[1] = (STRINGLIB_CHAR)((value >> 8) & 0xFFu);
; 53   :                     _p[2] = (STRINGLIB_CHAR)((value >> 16) & 0xFFu);
; 54   :                     _p[3] = (STRINGLIB_CHAR)((value >> 24) & 0xFFu);
; 55   : # if SIZEOF_LONG == 8
; 56   :                     _p[4] = (STRINGLIB_CHAR)((value >> 32) & 0xFFu);
; 57   :                     _p[5] = (STRINGLIB_CHAR)((value >> 40) & 0xFFu);
; 58   :                     _p[6] = (STRINGLIB_CHAR)((value >> 48) & 0xFFu);
; 59   :                     _p[7] = (STRINGLIB_CHAR)((value >> 56) & 0xFFu);
; 60   : # endif
; 61   : #else
; 62   : # if SIZEOF_LONG == 8
; 63   :                     _p[0] = (STRINGLIB_CHAR)((value >> 56) & 0xFFu);
; 64   :                     _p[1] = (STRINGLIB_CHAR)((value >> 48) & 0xFFu);
; 65   :                     _p[2] = (STRINGLIB_CHAR)((value >> 40) & 0xFFu);
; 66   :                     _p[3] = (STRINGLIB_CHAR)((value >> 32) & 0xFFu);
; 67   :                     _p[4] = (STRINGLIB_CHAR)((value >> 24) & 0xFFu);
; 68   :                     _p[5] = (STRINGLIB_CHAR)((value >> 16) & 0xFFu);
; 69   :                     _p[6] = (STRINGLIB_CHAR)((value >> 8) & 0xFFu);
; 70   :                     _p[7] = (STRINGLIB_CHAR)(value & 0xFFu);
; 71   : # else
; 72   :                     _p[0] = (STRINGLIB_CHAR)((value >> 24) & 0xFFu);
; 73   :                     _p[1] = (STRINGLIB_CHAR)((value >> 16) & 0xFFu);
; 74   :                     _p[2] = (STRINGLIB_CHAR)((value >> 8) & 0xFFu);
; 75   :                     _p[3] = (STRINGLIB_CHAR)(value & 0xFFu);
; 76   : # endif
; 77   : #endif
; 78   :                     _s += SIZEOF_LONG;

  0007d	48 83 c2 04	 add	 rdx, 4

; 79   :                     _p += SIZEOF_LONG;

  00081	49 83 c3 08	 add	 r11, 8
  00085	66 41 23 c5	 and	 ax, r13w
  00089	66 41 89 43 f8	 mov	 WORD PTR [r11-8], ax
  0008e	8b c1		 mov	 eax, ecx
  00090	c1 e8 08	 shr	 eax, 8
  00093	66 41 23 c5	 and	 ax, r13w
  00097	66 41 89 43 fa	 mov	 WORD PTR [r11-6], ax
  0009c	8b c1		 mov	 eax, ecx
  0009e	c1 e9 18	 shr	 ecx, 24
  000a1	c1 e8 10	 shr	 eax, 16
  000a4	66 41 23 cd	 and	 cx, r13w
  000a8	66 41 23 c5	 and	 ax, r13w
  000ac	66 41 89 4b fe	 mov	 WORD PTR [r11-2], cx
  000b1	66 41 89 43 fc	 mov	 WORD PTR [r11-4], ax
  000b6	48 3b d7	 cmp	 rdx, rdi
  000b9	72 b5		 jb	 SHORT $LL44@ucs2lib_ut
$LN72@ucs2lib_ut:

; 80   :                 }
; 81   :                 s = _s;

  000bb	4c 8b d2	 mov	 r10, rdx

; 82   :                 p = _p;
; 83   :                 if (s == end)

  000be	49 3b d0	 cmp	 rdx, r8
  000c1	0f 84 2f 02 00
	00		 je	 $LN75@ucs2lib_ut

; 84   :                     break;
; 85   :                 ch = (unsigned char)*s;

  000c7	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
$LN45@ucs2lib_ut:

; 86   :             }
; 87   :             if (ch < 0x80) {

  000ca	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  000d0	73 08		 jae	 SHORT $LN40@ucs2lib_ut

; 88   :                 s++;

  000d2	49 ff c2	 inc	 r10

; 89   :                 *p++ = ch;
; 90   :                 continue;

  000d5	e9 c5 00 00 00	 jmp	 $LN76@ucs2lib_ut
$LN40@ucs2lib_ut:

; 91   :             }
; 92   :         }
; 93   : 
; 94   :         if (ch < 0xE0) {

  000da	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  000e0	73 3d		 jae	 SHORT $LN39@ucs2lib_ut

; 95   :             /* \xC2\x80-\xDF\xBF -- 0080-07FF */
; 96   :             Py_UCS4 ch2;
; 97   :             if (ch < 0xC2) {

  000e2	81 f9 c2 00 00
	00		 cmp	 ecx, 194		; 000000c2H
  000e8	0f 82 03 02 00
	00		 jb	 $InvalidStart$130131

; 98   :                 /* invalid sequence
; 99   :                 \x80-\xBF -- continuation byte
; 100  :                 \xC0-\xC1 -- fake 0000-007F */
; 101  :                 goto InvalidStart;
; 102  :             }
; 103  :             if (end - s < 2) {

  000ee	49 8b c0	 mov	 rax, r8
  000f1	49 2b c2	 sub	 rax, r10
  000f4	48 83 f8 02	 cmp	 rax, 2
  000f8	0f 8c f8 01 00
	00		 jl	 $LN75@ucs2lib_ut

; 104  :                 /* unexpected end of data: the caller will decide whether
; 105  :                    it's an error or not */
; 106  :                 break;
; 107  :             }
; 108  :             ch2 = (unsigned char)s[1];

  000fe	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 109  :             if (!IS_CONTINUATION_BYTE(ch2))

  00103	8d 42 80	 lea	 eax, DWORD PTR [rdx-128]
  00106	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00109	77 56		 ja	 SHORT $InvalidContinuation1$130136

; 110  :                 /* invalid continuation byte */
; 111  :                 goto InvalidContinuation1;
; 112  :             ch = (ch << 6) + ch2 -
; 113  :                  ((0xC0 << 6) + 0x80);

  0010b	66 c1 e1 06	 shl	 cx, 6

; 114  :             assert ((ch > 0x007F) && (ch <= 0x07FF));
; 115  :             s += 2;

  0010f	49 83 c2 02	 add	 r10, 2

; 116  :             if (STRINGLIB_MAX_CHAR <= 0x007F ||
; 117  :                 (STRINGLIB_MAX_CHAR < 0x07FF && ch > STRINGLIB_MAX_CHAR))
; 118  :                 /* Out-of-range */
; 119  :                 goto Return;
; 120  :             *p++ = ch;

  00113	66 03 ca	 add	 cx, dx
  00116	66 41 2b ce	 sub	 cx, r14w

; 121  :             continue;

  0011a	e9 80 00 00 00	 jmp	 $LN76@ucs2lib_ut
$LN39@ucs2lib_ut:

; 122  :         }
; 123  : 
; 124  :         if (ch < 0xF0) {

  0011f	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  00125	0f 83 d1 00 00
	00		 jae	 $LN33@ucs2lib_ut

; 125  :             /* \xE0\xA0\x80-\xEF\xBF\xBF -- 0800-FFFF */
; 126  :             Py_UCS4 ch2, ch3;
; 127  :             if (end - s < 3) {

  0012b	49 8b c0	 mov	 rax, r8
  0012e	49 2b c2	 sub	 rax, r10
  00131	48 83 f8 03	 cmp	 rax, 3
  00135	7c 7e		 jl	 SHORT $LN65@ucs2lib_ut

; 135  :                     /* for clarification see comments below */
; 136  :                     goto InvalidContinuation1;
; 137  :                 break;
; 138  :             }
; 139  :             ch2 = (unsigned char)s[1];

  00137	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 140  :             ch3 = (unsigned char)s[2];

  0013c	45 0f b6 4a 02	 movzx	 r9d, BYTE PTR [r10+2]

; 141  :             if (!IS_CONTINUATION_BYTE(ch2)) {

  00141	81 fa 80 00 00
	00		 cmp	 edx, 128		; 00000080H
  00147	72 18		 jb	 SHORT $InvalidContinuation1$130136
  00149	81 fa c0 00 00
	00		 cmp	 edx, 192		; 000000c0H
  0014f	73 10		 jae	 SHORT $InvalidContinuation1$130136

; 142  :                 /* invalid continuation byte */
; 143  :                 goto InvalidContinuation1;
; 144  :             }
; 145  :             if (ch == 0xE0) {

  00151	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  00157	75 12		 jne	 SHORT $LN26@ucs2lib_ut

; 146  :                 if (ch2 < 0xA0)

  00159	81 fa a0 00 00
	00		 cmp	 edx, 160		; 000000a0H
  0015f	73 1a		 jae	 SHORT $LN23@ucs2lib_ut
$InvalidContinuation1$130136:

; 239  :     goto Return;
; 240  : InvalidContinuation1:
; 241  :     ch = 2;

  00161	bb 02 00 00 00	 mov	 ebx, 2

; 242  :     goto Return;

  00166	e9 8b 01 00 00	 jmp	 $LN75@ucs2lib_ut
$LN26@ucs2lib_ut:

; 147  :                     /* invalid sequence
; 148  :                        \xE0\x80\x80-\xE0\x9F\xBF -- fake 0000-0800 */
; 149  :                     goto InvalidContinuation1;
; 150  :             } else if (ch == 0xED && ch2 >= 0xA0) {

  0016b	81 f9 ed 00 00
	00		 cmp	 ecx, 237		; 000000edH
  00171	75 08		 jne	 SHORT $LN23@ucs2lib_ut
  00173	81 fa a0 00 00
	00		 cmp	 edx, 160		; 000000a0H
  00179	73 e6		 jae	 SHORT $InvalidContinuation1$130136
$LN23@ucs2lib_ut:

; 151  :                 /* Decoding UTF-8 sequences in range \xED\xA0\x80-\xED\xBF\xBF
; 152  :                    will result in surrogates in range D800-DFFF. Surrogates are
; 153  :                    not valid UTF-8 so they are rejected.
; 154  :                    See http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf
; 155  :                    (table 3-7) and http://www.rfc-editor.org/rfc/rfc3629.txt */
; 156  :                 goto InvalidContinuation1;
; 157  :             }
; 158  :             if (!IS_CONTINUATION_BYTE(ch3)) {

  0017b	41 8d 41 80	 lea	 eax, DWORD PTR [r9-128]
  0017f	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00182	0f 87 e8 00 00
	00		 ja	 $InvalidContinuation2$130158

; 159  :                 /* invalid continuation byte */
; 160  :                 goto InvalidContinuation2;
; 161  :             }
; 162  :             ch = (ch << 12) + (ch2 << 6) + ch3 -
; 163  :                  ((0xE0 << 12) + (0x80 << 6) + 0x80);
; 164  :             assert ((ch > 0x07FF) && (ch <= 0xFFFF));
; 165  :             s += 3;
; 166  :             if (STRINGLIB_MAX_CHAR <= 0x07FF ||
; 167  :                 (STRINGLIB_MAX_CHAR < 0xFFFF && ch > STRINGLIB_MAX_CHAR))
; 168  :                 /* Out-of-range */
; 169  :                 goto Return;
; 170  :             *p++ = ch;

  00188	66 c1 e1 06	 shl	 cx, 6
  0018c	49 83 c2 03	 add	 r10, 3
  00190	66 03 ca	 add	 cx, dx
  00193	66 c1 e1 06	 shl	 cx, 6
  00197	66 41 03 c9	 add	 cx, r9w
  0019b	66 41 2b cf	 sub	 cx, r15w
$LN76@ucs2lib_ut:
  0019f	66 41 89 0b	 mov	 WORD PTR [r11], cx
  001a3	49 83 c3 02	 add	 r11, 2
  001a7	4d 3b d0	 cmp	 r10, r8
  001aa	0f 82 a4 fe ff
	ff		 jb	 $LL48@ucs2lib_ut

; 151  :                 /* Decoding UTF-8 sequences in range \xED\xA0\x80-\xED\xBF\xBF
; 152  :                    will result in surrogates in range D800-DFFF. Surrogates are
; 153  :                    not valid UTF-8 so they are rejected.
; 154  :                    See http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf
; 155  :                    (table 3-7) and http://www.rfc-editor.org/rfc/rfc3629.txt */
; 156  :                 goto InvalidContinuation1;
; 157  :             }
; 158  :             if (!IS_CONTINUATION_BYTE(ch3)) {

  001b0	e9 41 01 00 00	 jmp	 $LN75@ucs2lib_ut
$LN65@ucs2lib_ut:

; 128  :                 /* unexpected end of data: the caller will decide whether
; 129  :                    it's an error or not */
; 130  :                 if (end - s < 2)

  001b5	4d 2b c2	 sub	 r8, r10
  001b8	49 83 f8 02	 cmp	 r8, 2
  001bc	0f 8c 34 01 00
	00		 jl	 $LN75@ucs2lib_ut

; 131  :                     break;
; 132  :                 ch2 = (unsigned char)s[1];

  001c2	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 133  :                 if (!IS_CONTINUATION_BYTE(ch2) ||
; 134  :                     (ch2 < 0xA0 ? ch == 0xE0 : ch == 0xED))

  001c7	8d 42 80	 lea	 eax, DWORD PTR [rdx-128]
  001ca	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  001cd	77 92		 ja	 SHORT $InvalidContinuation1$130136
  001cf	8b c3		 mov	 eax, ebx
  001d1	81 fa a0 00 00
	00		 cmp	 edx, 160		; 000000a0H
  001d7	73 08		 jae	 SHORT $LN51@ucs2lib_ut
  001d9	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  001df	eb 06		 jmp	 SHORT $LN77@ucs2lib_ut
$LN51@ucs2lib_ut:
  001e1	81 f9 ed 00 00
	00		 cmp	 ecx, 237		; 000000edH
$LN77@ucs2lib_ut:
  001e7	0f 94 c0	 sete	 al
  001ea	85 c0		 test	 eax, eax
  001ec	0f 84 04 01 00
	00		 je	 $LN75@ucs2lib_ut

; 239  :     goto Return;
; 240  : InvalidContinuation1:
; 241  :     ch = 2;

  001f2	bb 02 00 00 00	 mov	 ebx, 2

; 242  :     goto Return;

  001f7	e9 fa 00 00 00	 jmp	 $LN75@ucs2lib_ut
$LN33@ucs2lib_ut:

; 171  :             continue;
; 172  :         }
; 173  : 
; 174  :         if (ch < 0xF5) {

  001fc	81 f9 f5 00 00
	00		 cmp	 ecx, 245		; 000000f5H
  00202	0f 83 e9 00 00
	00		 jae	 $InvalidStart$130131

; 175  :             /* \xF0\x90\x80\x80-\xF4\x8F\xBF\xBF -- 10000-10FFFF */
; 176  :             Py_UCS4 ch2, ch3, ch4;
; 177  :             if (end - s < 4) {

  00208	4d 2b c2	 sub	 r8, r10
  0020b	49 83 f8 04	 cmp	 r8, 4
  0020f	7d 66		 jge	 SHORT $LN18@ucs2lib_ut

; 178  :                 /* unexpected end of data: the caller will decide whether
; 179  :                    it's an error or not */
; 180  :                 if (end - s < 2)

  00211	49 83 f8 02	 cmp	 r8, 2
  00215	0f 8c db 00 00
	00		 jl	 $LN75@ucs2lib_ut

; 181  :                     break;
; 182  :                 ch2 = (unsigned char)s[1];

  0021b	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 183  :                 if (!IS_CONTINUATION_BYTE(ch2) ||
; 184  :                     (ch2 < 0x90 ? ch == 0xF0 : ch == 0xF4))

  00220	8d 42 80	 lea	 eax, DWORD PTR [rdx-128]
  00223	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00226	0f 87 35 ff ff
	ff		 ja	 $InvalidContinuation1$130136
  0022c	8b c3		 mov	 eax, ebx
  0022e	81 fa 90 00 00
	00		 cmp	 edx, 144		; 00000090H
  00234	73 08		 jae	 SHORT $LN53@ucs2lib_ut
  00236	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  0023c	eb 06		 jmp	 SHORT $LN78@ucs2lib_ut
$LN53@ucs2lib_ut:
  0023e	81 f9 f4 00 00
	00		 cmp	 ecx, 244		; 000000f4H
$LN78@ucs2lib_ut:
  00244	0f 94 c0	 sete	 al
  00247	85 c0		 test	 eax, eax
  00249	0f 85 12 ff ff
	ff		 jne	 $InvalidContinuation1$130136

; 185  :                     /* for clarification see comments below */
; 186  :                     goto InvalidContinuation1;
; 187  :                 if (end - s < 3)

  0024f	49 83 f8 03	 cmp	 r8, 3
  00253	0f 8c 9d 00 00
	00		 jl	 $LN75@ucs2lib_ut

; 188  :                     break;
; 189  :                 ch3 = (unsigned char)s[2];

  00259	41 0f b6 42 02	 movzx	 eax, BYTE PTR [r10+2]

; 190  :                 if (!IS_CONTINUATION_BYTE(ch3))

  0025e	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00263	72 0b		 jb	 SHORT $InvalidContinuation2$130158
  00265	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0026a	0f 82 86 00 00
	00		 jb	 $LN75@ucs2lib_ut
$InvalidContinuation2$130158:

; 243  : InvalidContinuation2:
; 244  :     ch = 3;

  00270	bb 03 00 00 00	 mov	 ebx, 3

; 245  :     goto Return;

  00275	eb 7f		 jmp	 SHORT $LN75@ucs2lib_ut
$LN18@ucs2lib_ut:

; 191  :                     goto InvalidContinuation2;
; 192  :                 break;
; 193  :             }
; 194  :             ch2 = (unsigned char)s[1];

  00277	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 195  :             ch3 = (unsigned char)s[2];

  0027c	45 0f b6 42 02	 movzx	 r8d, BYTE PTR [r10+2]

; 196  :             ch4 = (unsigned char)s[3];

  00281	45 0f b6 4a 03	 movzx	 r9d, BYTE PTR [r10+3]

; 197  :             if (!IS_CONTINUATION_BYTE(ch2)) {

  00286	8d 42 80	 lea	 eax, DWORD PTR [rdx-128]
  00289	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  0028c	0f 87 cf fe ff
	ff		 ja	 $InvalidContinuation1$130136

; 198  :                 /* invalid continuation byte */
; 199  :                 goto InvalidContinuation1;
; 200  :             }
; 201  :             if (ch == 0xF0) {

  00292	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  00298	75 0e		 jne	 SHORT $LN9@ucs2lib_ut

; 202  :                 if (ch2 < 0x90)

  0029a	81 fa 90 00 00
	00		 cmp	 edx, 144		; 00000090H
  002a0	0f 82 bb fe ff
	ff		 jb	 $InvalidContinuation1$130136

; 203  :                     /* invalid sequence
; 204  :                        \xF0\x80\x80\x80-\xF0\x8F\xBF\xBF -- fake 0000-FFFF */
; 205  :                     goto InvalidContinuation1;
; 206  :             } else if (ch == 0xF4 && ch2 >= 0x90) {

  002a6	eb 14		 jmp	 SHORT $LN6@ucs2lib_ut
$LN9@ucs2lib_ut:
  002a8	81 f9 f4 00 00
	00		 cmp	 ecx, 244		; 000000f4H
  002ae	75 0c		 jne	 SHORT $LN6@ucs2lib_ut
  002b0	81 fa 90 00 00
	00		 cmp	 edx, 144		; 00000090H
  002b6	0f 83 a5 fe ff
	ff		 jae	 $InvalidContinuation1$130136
$LN6@ucs2lib_ut:

; 207  :                 /* invalid sequence
; 208  :                    \xF4\x90\x80\80- -- 110000- overflow */
; 209  :                 goto InvalidContinuation1;
; 210  :             }
; 211  :             if (!IS_CONTINUATION_BYTE(ch3)) {

  002bc	41 8d 40 80	 lea	 eax, DWORD PTR [r8-128]
  002c0	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  002c3	77 ab		 ja	 SHORT $InvalidContinuation2$130158

; 212  :                 /* invalid continuation byte */
; 213  :                 goto InvalidContinuation2;
; 214  :             }
; 215  :             if (!IS_CONTINUATION_BYTE(ch4)) {

  002c5	41 8d 41 80	 lea	 eax, DWORD PTR [r9-128]
  002c9	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  002cc	77 1c		 ja	 SHORT $InvalidContinuation3$130187

; 216  :                 /* invalid continuation byte */
; 217  :                 goto InvalidContinuation3;
; 218  :             }
; 219  :             ch = (ch << 18) + (ch2 << 12) + (ch3 << 6) + ch4 -
; 220  :                  ((0xF0 << 18) + (0x80 << 12) + (0x80 << 6) + 0x80);

  002ce	c1 e1 06	 shl	 ecx, 6
  002d1	03 ca		 add	 ecx, edx
  002d3	c1 e1 06	 shl	 ecx, 6
  002d6	41 03 c8	 add	 ecx, r8d
  002d9	c1 e1 06	 shl	 ecx, 6

; 221  :             assert ((ch > 0xFFFF) && (ch <= 0x10FFFF));
; 222  :             s += 4;

  002dc	49 83 c2 04	 add	 r10, 4
  002e0	42 8d 9c 09 80
	df 37 fc	 lea	 ebx, DWORD PTR [rcx+r9-63447168]

; 223  :             if (STRINGLIB_MAX_CHAR <= 0xFFFF ||
; 224  :                 (STRINGLIB_MAX_CHAR < 0x10FFFF && ch > STRINGLIB_MAX_CHAR))
; 225  :                 /* Out-of-range */
; 226  :                 goto Return;

  002e8	eb 0c		 jmp	 SHORT $LN75@ucs2lib_ut
$InvalidContinuation3$130187:

; 246  : InvalidContinuation3:
; 247  :     ch = 4;

  002ea	bb 04 00 00 00	 mov	 ebx, 4

; 248  :     goto Return;

  002ef	eb 05		 jmp	 SHORT $LN75@ucs2lib_ut
$InvalidStart$130131:

; 237  : InvalidStart:
; 238  :     ch = 1;

  002f1	bb 01 00 00 00	 mov	 ebx, 1
$LN75@ucs2lib_ut:
  002f6	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]
  002fb	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]
  00300	4c 8b 7c 24 38	 mov	 r15, QWORD PTR [rsp+56]
$Return$130139:

; 227  :             *p++ = ch;
; 228  :             continue;
; 229  :         }
; 230  :         goto InvalidStart;
; 231  :     }
; 232  :     ch = 0;
; 233  : Return:
; 234  :     *inptr = s;
; 235  :     *outpos = p - dest;

  00305	4c 2b dd	 sub	 r11, rbp
  00308	4d 89 14 24	 mov	 QWORD PTR [r12], r10

; 236  :     return ch;

  0030c	8b c3		 mov	 eax, ebx

; 249  : }

  0030e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00313	49 d1 fb	 sar	 r11, 1
  00316	4c 89 1e	 mov	 QWORD PTR [rsi], r11
  00319	41 5c		 pop	 r12
  0031b	5f		 pop	 rdi
  0031c	5e		 pop	 rsi
  0031d	5d		 pop	 rbp
  0031e	c3		 ret	 0
ucs2lib_utf8_decode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs2lib_utf16_decode DD imagerel ucs2lib_utf16_decode
	DD	imagerel ucs2lib_utf16_decode+392
	DD	imagerel $unwind$ucs2lib_utf16_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_utf16_decode DD 0a1801H
	DD	067418H
	DD	056418H
	DD	045418H
	DD	033418H
	DD	0c016d018H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs2lib_utf16_decode
_TEXT	SEGMENT
inptr$ = 24
e$ = 32
dest$ = 40
outpos$ = 48
native_ordering$ = 56
ucs2lib_utf16_decode PROC				; COMDAT

; 482  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13

; 483  :     Py_UCS4 ch;
; 484  :     const unsigned char *aligned_end =
; 485  :             (const unsigned char *) _Py_ALIGN_DOWN(e, SIZEOF_LONG);
; 486  :     const unsigned char *q = *inptr;
; 487  :     STRINGLIB_CHAR *p = dest + *outpos;
; 488  :     /* Offsets from q for retrieving byte pairs in the right order. */
; 489  : #ifdef BYTEORDER_IS_LITTLE_ENDIAN
; 490  :     int ihi = !!native_ordering, ilo = !native_ordering;

  00018	8b 5c 24 38	 mov	 ebx, DWORD PTR native_ordering$[rsp]
  0001c	45 33 d2	 xor	 r10d, r10d
  0001f	49 8b e9	 mov	 rbp, r9
  00022	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  00026	4c 8b ca	 mov	 r9, rdx

; 491  : #else
; 492  :     int ihi = !native_ordering, ilo = !!native_ordering;
; 493  : #endif
; 494  :     --e;

  00029	48 8d 7a ff	 lea	 rdi, QWORD PTR [rdx-1]
  0002d	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00030	49 83 e1 fc	 and	 r9, -4
  00034	85 db		 test	 ebx, ebx
  00036	41 0f 95 c2	 setne	 r10b
  0003a	4d 8d 1c 40	 lea	 r11, QWORD PTR [r8+rax*2]
  0003e	33 c0		 xor	 eax, eax
  00040	85 db		 test	 ebx, ebx
  00042	4d 8b e0	 mov	 r12, r8
  00045	4c 8b e9	 mov	 r13, rcx
  00048	0f 94 c0	 sete	 al
  0004b	4d 63 d2	 movsxd	 r10, r10d
  0004e	48 63 f0	 movsxd	 rsi, eax

; 495  : 
; 496  :     while (q < e) {

  00051	48 3b d7	 cmp	 rdx, rdi
  00054	0f 83 9e 00 00
	00		 jae	 $LN27@ucs2lib_ut@2
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL17@ucs2lib_ut@2:

; 497  :         Py_UCS4 ch2;
; 498  :         /* First check for possible aligned read of a C 'long'. Unaligned
; 499  :            reads are more expensive, better to defer to another iteration. */
; 500  :         if (_Py_IS_ALIGNED(q, SIZEOF_LONG)) {

  00060	f6 c2 03	 test	 dl, 3
  00063	75 60		 jne	 SHORT $LN8@ucs2lib_ut@2

; 501  :             /* Fast path for runs of in-range non-surrogate chars. */
; 502  :             register const unsigned char *_q = q;

  00065	4c 8b c2	 mov	 r8, rdx

; 503  :             while (_q < aligned_end) {

  00068	49 3b d1	 cmp	 rdx, r9
  0006b	73 50		 jae	 SHORT $LN28@ucs2lib_ut@2
  0006d	0f 1f 00	 npad	 3
$LL14@ucs2lib_ut@2:

; 504  :                 unsigned long block = * (unsigned long *) _q;

  00070	41 8b 10	 mov	 edx, DWORD PTR [r8]

; 505  :                 if (native_ordering) {

  00073	85 db		 test	 ebx, ebx
  00075	74 0a		 je	 SHORT $LN12@ucs2lib_ut@2

; 506  :                     /* Can use buffer directly */
; 507  :                     if (block & FAST_CHAR_MASK)

  00077	f7 c2 00 80 00
	80		 test	 edx, -2147450880	; 80008000H
  0007d	75 3e		 jne	 SHORT $LN28@ucs2lib_ut@2

; 508  :                         break;
; 509  :                 }
; 510  :                 else {

  0007f	eb 23		 jmp	 SHORT $LN10@ucs2lib_ut@2
$LN12@ucs2lib_ut@2:

; 511  :                     /* Need to byte-swap */
; 512  :                     if (block & SWAB(FAST_CHAR_MASK))

  00081	f7 c2 80 00 80
	00		 test	 edx, 8388736		; 00800080H
  00087	75 34		 jne	 SHORT $LN28@ucs2lib_ut@2

; 513  :                         break;
; 514  : #if STRINGLIB_SIZEOF_CHAR == 1
; 515  :                     block >>= 8;
; 516  : #else
; 517  :                     block = SWAB(block);

  00089	8b ca		 mov	 ecx, edx
  0008b	8b c2		 mov	 eax, edx
  0008d	c1 e0 08	 shl	 eax, 8
  00090	c1 e9 08	 shr	 ecx, 8
  00093	33 c8		 xor	 ecx, eax
  00095	8b c2		 mov	 eax, edx
  00097	81 e1 ff 00 ff
	00		 and	 ecx, 16711935		; 00ff00ffH
  0009d	c1 e0 08	 shl	 eax, 8
  000a0	8b d1		 mov	 edx, ecx
  000a2	33 d0		 xor	 edx, eax
$LN10@ucs2lib_ut@2:

; 518  : #endif
; 519  :                 }
; 520  : #ifdef BYTEORDER_IS_LITTLE_ENDIAN
; 521  : # if SIZEOF_LONG == 4
; 522  :                 p[0] = (STRINGLIB_CHAR)(block & 0xFFFFu);

  000a4	66 41 89 13	 mov	 WORD PTR [r11], dx

; 523  :                 p[1] = (STRINGLIB_CHAR)(block >> 16);

  000a8	c1 ea 10	 shr	 edx, 16

; 524  : # elif SIZEOF_LONG == 8
; 525  :                 p[0] = (STRINGLIB_CHAR)(block & 0xFFFFu);
; 526  :                 p[1] = (STRINGLIB_CHAR)((block >> 16) & 0xFFFFu);
; 527  :                 p[2] = (STRINGLIB_CHAR)((block >> 32) & 0xFFFFu);
; 528  :                 p[3] = (STRINGLIB_CHAR)(block >> 48);
; 529  : # endif
; 530  : #else
; 531  : # if SIZEOF_LONG == 4
; 532  :                 p[0] = (STRINGLIB_CHAR)(block >> 16);
; 533  :                 p[1] = (STRINGLIB_CHAR)(block & 0xFFFFu);
; 534  : # elif SIZEOF_LONG == 8
; 535  :                 p[0] = (STRINGLIB_CHAR)(block >> 48);
; 536  :                 p[1] = (STRINGLIB_CHAR)((block >> 32) & 0xFFFFu);
; 537  :                 p[2] = (STRINGLIB_CHAR)((block >> 16) & 0xFFFFu);
; 538  :                 p[3] = (STRINGLIB_CHAR)(block & 0xFFFFu);
; 539  : # endif
; 540  : #endif
; 541  :                 _q += SIZEOF_LONG;

  000ab	49 83 c0 04	 add	 r8, 4
  000af	66 41 89 53 02	 mov	 WORD PTR [r11+2], dx

; 542  :                 p += SIZEOF_LONG / 2;

  000b4	49 83 c3 04	 add	 r11, 4
  000b8	4d 3b c1	 cmp	 r8, r9
  000bb	72 b3		 jb	 SHORT $LL14@ucs2lib_ut@2
$LN28@ucs2lib_ut@2:

; 543  :             }
; 544  :             q = _q;

  000bd	49 8b d0	 mov	 rdx, r8

; 545  :             if (q >= e)

  000c0	4c 3b c7	 cmp	 r8, rdi
  000c3	73 33		 jae	 SHORT $LN27@ucs2lib_ut@2
$LN8@ucs2lib_ut@2:

; 546  :                 break;
; 547  :         }
; 548  : 
; 549  :         ch = (q[ihi] << 8) | q[ilo];

  000c5	41 0f b6 0c 12	 movzx	 ecx, BYTE PTR [r10+rdx]
  000ca	0f b6 04 16	 movzx	 eax, BYTE PTR [rsi+rdx]

; 550  :         q += 2;

  000ce	48 83 c2 02	 add	 rdx, 2
  000d2	c1 e1 08	 shl	 ecx, 8
  000d5	0b c8		 or	 ecx, eax

; 551  :         if (!Py_UNICODE_IS_SURROGATE(ch)) {

  000d7	81 f9 00 d8 00
	00		 cmp	 ecx, 55296		; 0000d800H
  000dd	72 08		 jb	 SHORT $LN6@ucs2lib_ut@2
  000df	81 f9 ff df 00
	00		 cmp	 ecx, 57343		; 0000dfffH
  000e5	76 3c		 jbe	 SHORT $LN7@ucs2lib_ut@2
$LN6@ucs2lib_ut@2:

; 552  : #if STRINGLIB_SIZEOF_CHAR < 2
; 553  :             if (ch > STRINGLIB_MAX_CHAR)
; 554  :                 /* Out-of-range */
; 555  :                 goto Return;
; 556  : #endif
; 557  :             *p++ = (STRINGLIB_CHAR)ch;

  000e7	66 41 89 0b	 mov	 WORD PTR [r11], cx
  000eb	49 83 c3 02	 add	 r11, 2
  000ef	48 3b d7	 cmp	 rdx, rdi
  000f2	0f 82 68 ff ff
	ff		 jb	 $LL17@ucs2lib_ut@2
$LN27@ucs2lib_ut@2:

; 574  : #else
; 575  :         *p++ = (STRINGLIB_CHAR)ch;
; 576  : #endif
; 577  :     }
; 578  :     ch = 0;

  000f8	33 c9		 xor	 ecx, ecx
$Return$130439:

; 592  : }

  000fa	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]
  000ff	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  00104	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00109	4d 2b dc	 sub	 r11, r12
  0010c	49 89 55 00	 mov	 QWORD PTR [r13], rdx
  00110	8b c1		 mov	 eax, ecx
  00112	49 d1 fb	 sar	 r11, 1
  00115	4c 89 5d 00	 mov	 QWORD PTR [rbp], r11
  00119	48 8b 6c 24 20	 mov	 rbp, QWORD PTR [rsp+32]
  0011e	41 5d		 pop	 r13
  00120	41 5c		 pop	 r12
  00122	c3		 ret	 0
$LN7@ucs2lib_ut@2:

; 558  :             continue;
; 559  :         }
; 560  : 
; 561  :         /* UTF-16 code pair: */
; 562  :         if (q >= e)

  00123	48 3b d7	 cmp	 rdx, rdi
  00126	72 07		 jb	 SHORT $LN5@ucs2lib_ut@2
$UnexpectedEnd$130430:

; 579  : Return:
; 580  :     *inptr = q;
; 581  :     *outpos = p - dest;
; 582  :     return ch;
; 583  : UnexpectedEnd:
; 584  :     ch = 1;

  00128	b9 01 00 00 00	 mov	 ecx, 1

; 585  :     goto Return;

  0012d	eb cb		 jmp	 SHORT $Return$130439
$LN5@ucs2lib_ut@2:

; 563  :             goto UnexpectedEnd;
; 564  :         if (!Py_UNICODE_IS_HIGH_SURROGATE(ch))

  0012f	81 f9 ff db 00
	00		 cmp	 ecx, 56319		; 0000dbffH
  00135	77 47		 ja	 SHORT $IllegalEncoding$130433

; 565  :             goto IllegalEncoding;
; 566  :         ch2 = (q[ihi] << 8) | q[ilo];

  00137	0f b6 04 16	 movzx	 eax, BYTE PTR [rsi+rdx]
  0013b	45 0f b6 04 12	 movzx	 r8d, BYTE PTR [r10+rdx]

; 567  :         q += 2;

  00140	48 83 c2 02	 add	 rdx, 2
  00144	41 c1 e0 08	 shl	 r8d, 8
  00148	44 0b c0	 or	 r8d, eax

; 568  :         if (!Py_UNICODE_IS_LOW_SURROGATE(ch2))

  0014b	41 8d 80 00 24
	ff ff		 lea	 eax, DWORD PTR [r8-56320]
  00152	3d ff 03 00 00	 cmp	 eax, 1023		; 000003ffH
  00157	77 1b		 ja	 SHORT $IllegalSurrogate$130436

; 569  :             goto IllegalSurrogate;
; 570  :         ch = Py_UNICODE_JOIN_SURROGATES(ch, ch2);

  00159	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0015f	41 81 e0 ff 03
	00 00		 and	 r8d, 1023		; 000003ffH
  00166	c1 e1 0a	 shl	 ecx, 10
  00169	41 0b c8	 or	 ecx, r8d
  0016c	81 c1 00 00 01
	00		 add	 ecx, 65536		; 00010000H

; 571  : #if STRINGLIB_SIZEOF_CHAR < 4
; 572  :         /* Out-of-range */
; 573  :         goto Return;

  00172	eb 86		 jmp	 SHORT $Return$130439
$IllegalSurrogate$130436:

; 589  : IllegalSurrogate:
; 590  :     ch = 3;

  00174	b9 03 00 00 00	 mov	 ecx, 3

; 591  :     goto Return;

  00179	e9 7c ff ff ff	 jmp	 $Return$130439
$IllegalEncoding$130433:

; 586  : IllegalEncoding:
; 587  :     ch = 2;

  0017e	b9 02 00 00 00	 mov	 ecx, 2

; 588  :     goto Return;

  00183	e9 72 ff ff ff	 jmp	 $Return$130439
ucs2lib_utf16_decode ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ucs2lib_utf16_encode
_TEXT	SEGMENT
out$ = 8
in$ = 16
len$ = 24
native_ordering$ = 32
ucs2lib_utf16_encode PROC				; COMDAT

; 604  : {

  00000	49 8b c0	 mov	 rax, r8

; 605  :     const STRINGLIB_CHAR *end = in + len;

  00003	4d 03 c0	 add	 r8, r8
  00006	4d 8d 14 10	 lea	 r10, QWORD PTR [r8+rdx]

; 606  : #if STRINGLIB_SIZEOF_CHAR == 1
; 607  : # define SWAB2(CH)  ((CH) << 8)
; 608  : #else
; 609  : # define SWAB2(CH)  (((CH) << 8) | ((CH) >> 8))
; 610  : #endif
; 611  : #if STRINGLIB_MAX_CHAR < 0x10000
; 612  :     if (native_ordering) {

  0000a	45 85 c9	 test	 r9d, r9d
  0000d	74 32		 je	 SHORT $LN14@ucs2lib_ut@3

; 613  : # if STRINGLIB_SIZEOF_CHAR == 2
; 614  :         Py_MEMCPY(out, in, 2 * len);

  0000f	49 83 f8 10	 cmp	 r8, 16
  00013	72 05		 jb	 SHORT $LN10@ucs2lib_ut@3

; 630  :         }
; 631  :     }
; 632  : #else
; 633  :     if (native_ordering) {
; 634  :         while (in < end) {
; 635  :             Py_UCS4 ch = *in++;
; 636  :             if (ch < 0x10000)
; 637  :                 *out++ = ch;
; 638  :             else {
; 639  :                 out[0] = Py_UNICODE_HIGH_SURROGATE(ch);
; 640  :                 out[1] = Py_UNICODE_LOW_SURROGATE(ch);
; 641  :                 out += 2;
; 642  :             }
; 643  :         }
; 644  :     } else {
; 645  :         while (in < end) {
; 646  :             Py_UCS4 ch = *in++;
; 647  :             if (ch < 0x10000)
; 648  :                 *out++ = SWAB2((Py_UCS2)ch);
; 649  :             else {
; 650  :                 Py_UCS2 ch1 = Py_UNICODE_HIGH_SURROGATE(ch);
; 651  :                 Py_UCS2 ch2 = Py_UNICODE_LOW_SURROGATE(ch);
; 652  :                 out[0] = SWAB2(ch1);
; 653  :                 out[1] = SWAB2(ch2);
; 654  :                 out += 2;
; 655  :             }
; 656  :         }
; 657  :     }
; 658  : #endif
; 659  : #undef SWAB2
; 660  : }

  00015	e9 00 00 00 00	 jmp	 memcpy
$LN10@ucs2lib_ut@3:

; 613  : # if STRINGLIB_SIZEOF_CHAR == 2
; 614  :         Py_MEMCPY(out, in, 2 * len);

  0001a	4d 85 c0	 test	 r8, r8
  0001d	0f 84 92 00 00
	00		 je	 $LN1@ucs2lib_ut@3
  00023	48 2b d1	 sub	 rdx, rcx
  00026	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL8@ucs2lib_ut@3:
  00030	0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+rcx]
  00034	48 ff c1	 inc	 rcx
  00037	49 ff c8	 dec	 r8
  0003a	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0003d	75 f1		 jne	 SHORT $LL8@ucs2lib_ut@3

; 630  :         }
; 631  :     }
; 632  : #else
; 633  :     if (native_ordering) {
; 634  :         while (in < end) {
; 635  :             Py_UCS4 ch = *in++;
; 636  :             if (ch < 0x10000)
; 637  :                 *out++ = ch;
; 638  :             else {
; 639  :                 out[0] = Py_UNICODE_HIGH_SURROGATE(ch);
; 640  :                 out[1] = Py_UNICODE_LOW_SURROGATE(ch);
; 641  :                 out += 2;
; 642  :             }
; 643  :         }
; 644  :     } else {
; 645  :         while (in < end) {
; 646  :             Py_UCS4 ch = *in++;
; 647  :             if (ch < 0x10000)
; 648  :                 *out++ = SWAB2((Py_UCS2)ch);
; 649  :             else {
; 650  :                 Py_UCS2 ch1 = Py_UNICODE_HIGH_SURROGATE(ch);
; 651  :                 Py_UCS2 ch2 = Py_UNICODE_LOW_SURROGATE(ch);
; 652  :                 out[0] = SWAB2(ch1);
; 653  :                 out[1] = SWAB2(ch2);
; 654  :                 out += 2;
; 655  :             }
; 656  :         }
; 657  :     }
; 658  : #endif
; 659  : #undef SWAB2
; 660  : }

  0003f	f3 c3		 fatret	 0
$LN14@ucs2lib_ut@3:

; 615  : # else
; 616  :         _PyUnicode_CONVERT_BYTES(STRINGLIB_CHAR, unsigned short, in, end, out);
; 617  : # endif
; 618  :     } else {
; 619  :         const STRINGLIB_CHAR *unrolled_end = in + _Py_SIZE_ROUND_DOWN(len, 4);

  00041	48 83 e0 fc	 and	 rax, -4
  00045	4c 8d 04 42	 lea	 r8, QWORD PTR [rdx+rax*2]

; 620  :         while (in < unrolled_end) {

  00049	49 3b d0	 cmp	 rdx, r8
  0004c	73 3e		 jae	 SHORT $LN19@ucs2lib_ut@3
  0004e	66 90		 npad	 2
$LL4@ucs2lib_ut@3:

; 621  :             out[0] = SWAB2(in[0]);

  00050	0f b7 02	 movzx	 eax, WORD PTR [rdx]

; 622  :             out[1] = SWAB2(in[1]);
; 623  :             out[2] = SWAB2(in[2]);
; 624  :             out[3] = SWAB2(in[3]);
; 625  :             in += 4; out += 4;

  00053	48 83 c2 08	 add	 rdx, 8
  00057	48 83 c1 08	 add	 rcx, 8
  0005b	66 c1 c0 08	 rol	 ax, 8
  0005f	66 89 41 f8	 mov	 WORD PTR [rcx-8], ax
  00063	0f b7 42 fa	 movzx	 eax, WORD PTR [rdx-6]
  00067	66 c1 c0 08	 rol	 ax, 8
  0006b	66 89 41 fa	 mov	 WORD PTR [rcx-6], ax
  0006f	0f b7 42 fc	 movzx	 eax, WORD PTR [rdx-4]
  00073	66 c1 c0 08	 rol	 ax, 8
  00077	66 89 41 fc	 mov	 WORD PTR [rcx-4], ax
  0007b	0f b7 42 fe	 movzx	 eax, WORD PTR [rdx-2]
  0007f	66 c1 c0 08	 rol	 ax, 8
  00083	66 89 41 fe	 mov	 WORD PTR [rcx-2], ax
  00087	49 3b d0	 cmp	 rdx, r8
  0008a	72 c4		 jb	 SHORT $LL4@ucs2lib_ut@3
$LN19@ucs2lib_ut@3:

; 626  :         }
; 627  :         while (in < end) {

  0008c	49 3b d2	 cmp	 rdx, r10
  0008f	73 24		 jae	 SHORT $LN1@ucs2lib_ut@3
  00091	48 2b ca	 sub	 rcx, rdx
  00094	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL2@ucs2lib_ut@3:

; 628  :             *out++ = SWAB2(*in);

  000a0	0f b7 02	 movzx	 eax, WORD PTR [rdx]

; 629  :             ++in;

  000a3	48 83 c2 02	 add	 rdx, 2
  000a7	66 c1 c0 08	 rol	 ax, 8
  000ab	66 89 44 11 fe	 mov	 WORD PTR [rcx+rdx-2], ax
  000b0	49 3b d2	 cmp	 rdx, r10
  000b3	72 eb		 jb	 SHORT $LL2@ucs2lib_ut@3
$LN1@ucs2lib_ut@3:

; 630  :         }
; 631  :     }
; 632  : #else
; 633  :     if (native_ordering) {
; 634  :         while (in < end) {
; 635  :             Py_UCS4 ch = *in++;
; 636  :             if (ch < 0x10000)
; 637  :                 *out++ = ch;
; 638  :             else {
; 639  :                 out[0] = Py_UNICODE_HIGH_SURROGATE(ch);
; 640  :                 out[1] = Py_UNICODE_LOW_SURROGATE(ch);
; 641  :                 out += 2;
; 642  :             }
; 643  :         }
; 644  :     } else {
; 645  :         while (in < end) {
; 646  :             Py_UCS4 ch = *in++;
; 647  :             if (ch < 0x10000)
; 648  :                 *out++ = SWAB2((Py_UCS2)ch);
; 649  :             else {
; 650  :                 Py_UCS2 ch1 = Py_UNICODE_HIGH_SURROGATE(ch);
; 651  :                 Py_UCS2 ch2 = Py_UNICODE_LOW_SURROGATE(ch);
; 652  :                 out[0] = SWAB2(ch1);
; 653  :                 out[1] = SWAB2(ch2);
; 654  :                 out += 2;
; 655  :             }
; 656  :         }
; 657  :     }
; 658  : #endif
; 659  : #undef SWAB2
; 660  : }

  000b5	f3 c3		 fatret	 0
ucs2lib_utf16_encode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs4lib_utf8_decode DD imagerel ucs4lib_utf8_decode
	DD	imagerel ucs4lib_utf8_decode+787
	DD	imagerel $unwind$ucs4lib_utf8_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_utf8_decode DD 0a1801H
	DD	067418H
	DD	056418H
	DD	045418H
	DD	033418H
	DD	0c016d018H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs4lib_utf8_decode
_TEXT	SEGMENT
inptr$ = 24
end$ = 32
dest$ = 40
outpos$ = 48
ucs4lib_utf8_decode PROC				; COMDAT

; 22   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13

; 23   :     Py_UCS4 ch;
; 24   :     const char *s = *inptr;

  00018	4c 8b 11	 mov	 r10, QWORD PTR [rcx]

; 25   :     const char *aligned_end = (const char *) _Py_ALIGN_DOWN(end, SIZEOF_LONG);
; 26   :     STRINGLIB_CHAR *p = dest + *outpos;

  0001b	49 8b 01	 mov	 rax, QWORD PTR [r9]
  0001e	48 8b fa	 mov	 rdi, rdx
  00021	48 83 e7 fc	 and	 rdi, -4

; 27   : 
; 28   :     while (s < end) {

  00025	33 f6		 xor	 esi, esi
  00027	49 8b e9	 mov	 rbp, r9
  0002a	4d 8d 1c 80	 lea	 r11, QWORD PTR [r8+rax*4]
  0002e	4d 8b e0	 mov	 r12, r8
  00031	48 8b da	 mov	 rbx, rdx
  00034	4c 8b e9	 mov	 r13, rcx
  00037	4c 3b d2	 cmp	 r10, rdx
  0003a	0f 83 a9 02 00
	00		 jae	 $Return$130541
$LL48@ucs4lib_ut:

; 29   :         ch = (unsigned char)*s;

  00040	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]

; 30   : 
; 31   :         if (ch < 0x80) {

  00044	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0004a	73 73		 jae	 SHORT $LN40@ucs4lib_ut

; 32   :             /* Fast path for runs of ASCII characters. Given that common UTF-8
; 33   :                input will consist of an overwhelming majority of ASCII
; 34   :                characters, we try to optimize for this case by checking
; 35   :                as many characters as a C 'long' can contain.
; 36   :                First, check if we can do an aligned read, as most CPUs have
; 37   :                a penalty for unaligned reads.
; 38   :             */
; 39   :             if (_Py_IS_ALIGNED(s, SIZEOF_LONG)) {

  0004c	41 f6 c2 03	 test	 r10b, 3
  00050	75 5a		 jne	 SHORT $LN45@ucs4lib_ut

; 40   :                 /* Help register allocation */
; 41   :                 register const char *_s = s;

  00052	49 8b d2	 mov	 rdx, r10

; 42   :                 register STRINGLIB_CHAR *_p = p;
; 43   :                 while (_s < aligned_end) {

  00055	4c 3b d7	 cmp	 r10, rdi
  00058	73 43		 jae	 SHORT $LN79@ucs4lib_ut
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL44@ucs4lib_ut:

; 44   :                     /* Read a whole long at a time (either 4 or 8 bytes),
; 45   :                        and do a fast unrolled copy if it only contains ASCII
; 46   :                        characters. */
; 47   :                     unsigned long value = *(unsigned long *) _s;

  00060	8b 0a		 mov	 ecx, DWORD PTR [rdx]

; 48   :                     if (value & ASCII_CHAR_MASK)

  00062	f7 c1 80 80 80
	80		 test	 ecx, -2139062144	; 80808080H
  00068	75 33		 jne	 SHORT $LN79@ucs4lib_ut

; 49   :                         break;
; 50   : #ifdef BYTEORDER_IS_LITTLE_ENDIAN
; 51   :                     _p[0] = (STRINGLIB_CHAR)(value & 0xFFu);

  0006a	0f b6 c1	 movzx	 eax, cl

; 52   :                     _p[1] = (STRINGLIB_CHAR)((value >> 8) & 0xFFu);
; 53   :                     _p[2] = (STRINGLIB_CHAR)((value >> 16) & 0xFFu);
; 54   :                     _p[3] = (STRINGLIB_CHAR)((value >> 24) & 0xFFu);
; 55   : # if SIZEOF_LONG == 8
; 56   :                     _p[4] = (STRINGLIB_CHAR)((value >> 32) & 0xFFu);
; 57   :                     _p[5] = (STRINGLIB_CHAR)((value >> 40) & 0xFFu);
; 58   :                     _p[6] = (STRINGLIB_CHAR)((value >> 48) & 0xFFu);
; 59   :                     _p[7] = (STRINGLIB_CHAR)((value >> 56) & 0xFFu);
; 60   : # endif
; 61   : #else
; 62   : # if SIZEOF_LONG == 8
; 63   :                     _p[0] = (STRINGLIB_CHAR)((value >> 56) & 0xFFu);
; 64   :                     _p[1] = (STRINGLIB_CHAR)((value >> 48) & 0xFFu);
; 65   :                     _p[2] = (STRINGLIB_CHAR)((value >> 40) & 0xFFu);
; 66   :                     _p[3] = (STRINGLIB_CHAR)((value >> 32) & 0xFFu);
; 67   :                     _p[4] = (STRINGLIB_CHAR)((value >> 24) & 0xFFu);
; 68   :                     _p[5] = (STRINGLIB_CHAR)((value >> 16) & 0xFFu);
; 69   :                     _p[6] = (STRINGLIB_CHAR)((value >> 8) & 0xFFu);
; 70   :                     _p[7] = (STRINGLIB_CHAR)(value & 0xFFu);
; 71   : # else
; 72   :                     _p[0] = (STRINGLIB_CHAR)((value >> 24) & 0xFFu);
; 73   :                     _p[1] = (STRINGLIB_CHAR)((value >> 16) & 0xFFu);
; 74   :                     _p[2] = (STRINGLIB_CHAR)((value >> 8) & 0xFFu);
; 75   :                     _p[3] = (STRINGLIB_CHAR)(value & 0xFFu);
; 76   : # endif
; 77   : #endif
; 78   :                     _s += SIZEOF_LONG;

  0006d	48 83 c2 04	 add	 rdx, 4

; 79   :                     _p += SIZEOF_LONG;

  00071	49 83 c3 10	 add	 r11, 16
  00075	41 89 43 f0	 mov	 DWORD PTR [r11-16], eax
  00079	8b c1		 mov	 eax, ecx
  0007b	c1 e8 08	 shr	 eax, 8
  0007e	0f b6 c0	 movzx	 eax, al
  00081	41 89 43 f4	 mov	 DWORD PTR [r11-12], eax
  00085	8b c1		 mov	 eax, ecx
  00087	c1 e9 18	 shr	 ecx, 24
  0008a	c1 e8 10	 shr	 eax, 16
  0008d	41 89 4b fc	 mov	 DWORD PTR [r11-4], ecx
  00091	0f b6 c0	 movzx	 eax, al
  00094	41 89 43 f8	 mov	 DWORD PTR [r11-8], eax
  00098	48 3b d7	 cmp	 rdx, rdi
  0009b	72 c3		 jb	 SHORT $LL44@ucs4lib_ut
$LN79@ucs4lib_ut:

; 80   :                 }
; 81   :                 s = _s;

  0009d	4c 8b d2	 mov	 r10, rdx

; 82   :                 p = _p;
; 83   :                 if (s == end)

  000a0	48 3b d3	 cmp	 rdx, rbx
  000a3	0f 84 40 02 00
	00		 je	 $Return$130541

; 84   :                     break;
; 85   :                 ch = (unsigned char)*s;

  000a9	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
$LN45@ucs4lib_ut:

; 86   :             }
; 87   :             if (ch < 0x80) {

  000ac	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  000b2	73 0b		 jae	 SHORT $LN40@ucs4lib_ut

; 88   :                 s++;

  000b4	49 ff c2	 inc	 r10

; 89   :                 *p++ = ch;

  000b7	41 89 0b	 mov	 DWORD PTR [r11], ecx

; 90   :                 continue;

  000ba	e9 6b 01 00 00	 jmp	 $LN80@ucs4lib_ut
$LN40@ucs4lib_ut:

; 91   :             }
; 92   :         }
; 93   : 
; 94   :         if (ch < 0xE0) {

  000bf	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  000c5	73 3c		 jae	 SHORT $LN39@ucs4lib_ut

; 95   :             /* \xC2\x80-\xDF\xBF -- 0080-07FF */
; 96   :             Py_UCS4 ch2;
; 97   :             if (ch < 0xC2) {

  000c7	81 f9 c2 00 00
	00		 cmp	 ecx, 194		; 000000c2H
  000cd	0f 82 11 02 00
	00		 jb	 $InvalidStart$130533

; 98   :                 /* invalid sequence
; 99   :                 \x80-\xBF -- continuation byte
; 100  :                 \xC0-\xC1 -- fake 0000-007F */
; 101  :                 goto InvalidStart;
; 102  :             }
; 103  :             if (end - s < 2) {

  000d3	48 8b c3	 mov	 rax, rbx
  000d6	49 2b c2	 sub	 rax, r10
  000d9	48 83 f8 02	 cmp	 rax, 2
  000dd	0f 8c 06 02 00
	00		 jl	 $Return$130541

; 104  :                 /* unexpected end of data: the caller will decide whether
; 105  :                    it's an error or not */
; 106  :                 break;
; 107  :             }
; 108  :             ch2 = (unsigned char)s[1];

  000e3	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 109  :             if (!IS_CONTINUATION_BYTE(ch2))

  000e8	8d 42 80	 lea	 eax, DWORD PTR [rdx-128]
  000eb	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  000ee	77 55		 ja	 SHORT $InvalidContinuation1$130538

; 110  :                 /* invalid continuation byte */
; 111  :                 goto InvalidContinuation1;
; 112  :             ch = (ch << 6) + ch2 -
; 113  :                  ((0xC0 << 6) + 0x80);
; 114  :             assert ((ch > 0x007F) && (ch <= 0x07FF));
; 115  :             s += 2;

  000f0	49 83 c2 02	 add	 r10, 2
  000f4	c1 e1 06	 shl	 ecx, 6

; 116  :             if (STRINGLIB_MAX_CHAR <= 0x007F ||
; 117  :                 (STRINGLIB_MAX_CHAR < 0x07FF && ch > STRINGLIB_MAX_CHAR))
; 118  :                 /* Out-of-range */
; 119  :                 goto Return;
; 120  :             *p++ = ch;

  000f7	8d 84 11 80 cf
	ff ff		 lea	 eax, DWORD PTR [rcx+rdx-12416]

; 121  :             continue;

  000fe	e9 24 01 00 00	 jmp	 $LN81@ucs4lib_ut
$LN39@ucs4lib_ut:

; 122  :         }
; 123  : 
; 124  :         if (ch < 0xF0) {

  00103	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  00109	73 7a		 jae	 SHORT $LN33@ucs4lib_ut

; 125  :             /* \xE0\xA0\x80-\xEF\xBF\xBF -- 0800-FFFF */
; 126  :             Py_UCS4 ch2, ch3;
; 127  :             if (end - s < 3) {

  0010b	48 8b c3	 mov	 rax, rbx
  0010e	49 2b c2	 sub	 rax, r10
  00111	48 83 f8 03	 cmp	 rax, 3
  00115	0f 8c 21 01 00
	00		 jl	 $LN65@ucs4lib_ut

; 135  :                     /* for clarification see comments below */
; 136  :                     goto InvalidContinuation1;
; 137  :                 break;
; 138  :             }
; 139  :             ch2 = (unsigned char)s[1];

  0011b	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 140  :             ch3 = (unsigned char)s[2];

  00120	45 0f b6 42 02	 movzx	 r8d, BYTE PTR [r10+2]

; 141  :             if (!IS_CONTINUATION_BYTE(ch2)) {

  00125	81 fa 80 00 00
	00		 cmp	 edx, 128		; 00000080H
  0012b	72 18		 jb	 SHORT $InvalidContinuation1$130538
  0012d	81 fa c0 00 00
	00		 cmp	 edx, 192		; 000000c0H
  00133	73 10		 jae	 SHORT $InvalidContinuation1$130538

; 142  :                 /* invalid continuation byte */
; 143  :                 goto InvalidContinuation1;
; 144  :             }
; 145  :             if (ch == 0xE0) {

  00135	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  0013b	75 12		 jne	 SHORT $LN26@ucs4lib_ut

; 146  :                 if (ch2 < 0xA0)

  0013d	81 fa a0 00 00
	00		 cmp	 edx, 160		; 000000a0H
  00143	73 1a		 jae	 SHORT $LN23@ucs4lib_ut
$InvalidContinuation1$130538:

; 239  :     goto Return;
; 240  : InvalidContinuation1:
; 241  :     ch = 2;

  00145	be 02 00 00 00	 mov	 esi, 2

; 242  :     goto Return;

  0014a	e9 9a 01 00 00	 jmp	 $Return$130541
$LN26@ucs4lib_ut:

; 147  :                     /* invalid sequence
; 148  :                        \xE0\x80\x80-\xE0\x9F\xBF -- fake 0000-0800 */
; 149  :                     goto InvalidContinuation1;
; 150  :             } else if (ch == 0xED && ch2 >= 0xA0) {

  0014f	81 f9 ed 00 00
	00		 cmp	 ecx, 237		; 000000edH
  00155	75 08		 jne	 SHORT $LN23@ucs4lib_ut
  00157	81 fa a0 00 00
	00		 cmp	 edx, 160		; 000000a0H
  0015d	73 e6		 jae	 SHORT $InvalidContinuation1$130538
$LN23@ucs4lib_ut:

; 151  :                 /* Decoding UTF-8 sequences in range \xED\xA0\x80-\xED\xBF\xBF
; 152  :                    will result in surrogates in range D800-DFFF. Surrogates are
; 153  :                    not valid UTF-8 so they are rejected.
; 154  :                    See http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf
; 155  :                    (table 3-7) and http://www.rfc-editor.org/rfc/rfc3629.txt */
; 156  :                 goto InvalidContinuation1;
; 157  :             }
; 158  :             if (!IS_CONTINUATION_BYTE(ch3)) {

  0015f	41 8d 40 80	 lea	 eax, DWORD PTR [r8-128]
  00163	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00166	0f 87 71 01 00
	00		 ja	 $InvalidContinuation2$130560

; 159  :                 /* invalid continuation byte */
; 160  :                 goto InvalidContinuation2;
; 161  :             }
; 162  :             ch = (ch << 12) + (ch2 << 6) + ch3 -
; 163  :                  ((0xE0 << 12) + (0x80 << 6) + 0x80);
; 164  :             assert ((ch > 0x07FF) && (ch <= 0xFFFF));
; 165  :             s += 3;
; 166  :             if (STRINGLIB_MAX_CHAR <= 0x07FF ||
; 167  :                 (STRINGLIB_MAX_CHAR < 0xFFFF && ch > STRINGLIB_MAX_CHAR))
; 168  :                 /* Out-of-range */
; 169  :                 goto Return;
; 170  :             *p++ = ch;

  0016c	c1 e1 06	 shl	 ecx, 6
  0016f	49 83 c2 03	 add	 r10, 3
  00173	03 ca		 add	 ecx, edx
  00175	c1 e1 06	 shl	 ecx, 6
  00178	42 8d 84 01 80
	df f1 ff	 lea	 eax, DWORD PTR [rcx+r8-925824]

; 171  :             continue;

  00180	e9 a2 00 00 00	 jmp	 $LN81@ucs4lib_ut
$LN33@ucs4lib_ut:

; 172  :         }
; 173  : 
; 174  :         if (ch < 0xF5) {

  00185	81 f9 f5 00 00
	00		 cmp	 ecx, 245		; 000000f5H
  0018b	0f 83 53 01 00
	00		 jae	 $InvalidStart$130533

; 175  :             /* \xF0\x90\x80\x80-\xF4\x8F\xBF\xBF -- 10000-10FFFF */
; 176  :             Py_UCS4 ch2, ch3, ch4;
; 177  :             if (end - s < 4) {

  00191	48 8b c3	 mov	 rax, rbx
  00194	49 2b c2	 sub	 rax, r10
  00197	48 83 f8 04	 cmp	 rax, 4
  0019b	0f 8c e6 00 00
	00		 jl	 $LN70@ucs4lib_ut

; 191  :                     goto InvalidContinuation2;
; 192  :                 break;
; 193  :             }
; 194  :             ch2 = (unsigned char)s[1];

  001a1	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 195  :             ch3 = (unsigned char)s[2];

  001a6	45 0f b6 42 02	 movzx	 r8d, BYTE PTR [r10+2]

; 196  :             ch4 = (unsigned char)s[3];

  001ab	45 0f b6 4a 03	 movzx	 r9d, BYTE PTR [r10+3]

; 197  :             if (!IS_CONTINUATION_BYTE(ch2)) {

  001b0	81 fa 80 00 00
	00		 cmp	 edx, 128		; 00000080H
  001b6	72 8d		 jb	 SHORT $InvalidContinuation1$130538
  001b8	81 fa c0 00 00
	00		 cmp	 edx, 192		; 000000c0H
  001be	73 85		 jae	 SHORT $InvalidContinuation1$130538

; 198  :                 /* invalid continuation byte */
; 199  :                 goto InvalidContinuation1;
; 200  :             }
; 201  :             if (ch == 0xF0) {

  001c0	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  001c6	75 0e		 jne	 SHORT $LN9@ucs4lib_ut

; 202  :                 if (ch2 < 0x90)

  001c8	81 fa 90 00 00
	00		 cmp	 edx, 144		; 00000090H
  001ce	0f 82 71 ff ff
	ff		 jb	 $InvalidContinuation1$130538

; 203  :                     /* invalid sequence
; 204  :                        \xF0\x80\x80\x80-\xF0\x8F\xBF\xBF -- fake 0000-FFFF */
; 205  :                     goto InvalidContinuation1;
; 206  :             } else if (ch == 0xF4 && ch2 >= 0x90) {

  001d4	eb 14		 jmp	 SHORT $LN6@ucs4lib_ut
$LN9@ucs4lib_ut:
  001d6	81 f9 f4 00 00
	00		 cmp	 ecx, 244		; 000000f4H
  001dc	75 0c		 jne	 SHORT $LN6@ucs4lib_ut
  001de	81 fa 90 00 00
	00		 cmp	 edx, 144		; 00000090H
  001e4	0f 83 5b ff ff
	ff		 jae	 $InvalidContinuation1$130538
$LN6@ucs4lib_ut:

; 207  :                 /* invalid sequence
; 208  :                    \xF4\x90\x80\80- -- 110000- overflow */
; 209  :                 goto InvalidContinuation1;
; 210  :             }
; 211  :             if (!IS_CONTINUATION_BYTE(ch3)) {

  001ea	41 81 f8 80 00
	00 00		 cmp	 r8d, 128		; 00000080H
  001f1	0f 82 e6 00 00
	00		 jb	 $InvalidContinuation2$130560
  001f7	41 81 f8 c0 00
	00 00		 cmp	 r8d, 192		; 000000c0H
  001fe	0f 83 d9 00 00
	00		 jae	 $InvalidContinuation2$130560

; 212  :                 /* invalid continuation byte */
; 213  :                 goto InvalidContinuation2;
; 214  :             }
; 215  :             if (!IS_CONTINUATION_BYTE(ch4)) {

  00204	41 8d 41 80	 lea	 eax, DWORD PTR [r9-128]
  00208	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  0020b	77 73		 ja	 SHORT $InvalidContinuation3$130589

; 216  :                 /* invalid continuation byte */
; 217  :                 goto InvalidContinuation3;
; 218  :             }
; 219  :             ch = (ch << 18) + (ch2 << 12) + (ch3 << 6) + ch4 -
; 220  :                  ((0xF0 << 18) + (0x80 << 12) + (0x80 << 6) + 0x80);
; 221  :             assert ((ch > 0xFFFF) && (ch <= 0x10FFFF));
; 222  :             s += 4;
; 223  :             if (STRINGLIB_MAX_CHAR <= 0xFFFF ||
; 224  :                 (STRINGLIB_MAX_CHAR < 0x10FFFF && ch > STRINGLIB_MAX_CHAR))
; 225  :                 /* Out-of-range */
; 226  :                 goto Return;
; 227  :             *p++ = ch;

  0020d	c1 e1 06	 shl	 ecx, 6
  00210	49 83 c2 04	 add	 r10, 4
  00214	03 ca		 add	 ecx, edx
  00216	c1 e1 06	 shl	 ecx, 6
  00219	41 03 c8	 add	 ecx, r8d
  0021c	c1 e1 06	 shl	 ecx, 6
  0021f	42 8d 84 09 80
	df 37 fc	 lea	 eax, DWORD PTR [rcx+r9-63447168]
$LN81@ucs4lib_ut:
  00227	41 89 03	 mov	 DWORD PTR [r11], eax
$LN80@ucs4lib_ut:
  0022a	49 83 c3 04	 add	 r11, 4
  0022e	4c 3b d3	 cmp	 r10, rbx
  00231	0f 82 09 fe ff
	ff		 jb	 $LL48@ucs4lib_ut

; 27   : 
; 28   :     while (s < end) {

  00237	e9 ad 00 00 00	 jmp	 $Return$130541
$LN65@ucs4lib_ut:

; 128  :                 /* unexpected end of data: the caller will decide whether
; 129  :                    it's an error or not */
; 130  :                 if (end - s < 2)

  0023c	49 2b da	 sub	 rbx, r10
  0023f	48 83 fb 02	 cmp	 rbx, 2
  00243	0f 8c a0 00 00
	00		 jl	 $Return$130541

; 131  :                     break;
; 132  :                 ch2 = (unsigned char)s[1];

  00249	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 133  :                 if (!IS_CONTINUATION_BYTE(ch2) ||
; 134  :                     (ch2 < 0xA0 ? ch == 0xE0 : ch == 0xED))

  0024e	8d 42 80	 lea	 eax, DWORD PTR [rdx-128]
  00251	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00254	0f 87 eb fe ff
	ff		 ja	 $InvalidContinuation1$130538
  0025a	8b c6		 mov	 eax, esi
  0025c	81 fa a0 00 00
	00		 cmp	 edx, 160		; 000000a0H
  00262	73 08		 jae	 SHORT $LN51@ucs4lib_ut
  00264	81 f9 e0 00 00
	00		 cmp	 ecx, 224		; 000000e0H
  0026a	eb 06		 jmp	 SHORT $LN82@ucs4lib_ut
$LN51@ucs4lib_ut:
  0026c	81 f9 ed 00 00
	00		 cmp	 ecx, 237		; 000000edH
$LN82@ucs4lib_ut:
  00272	0f 94 c0	 sete	 al
  00275	85 c0		 test	 eax, eax
  00277	74 70		 je	 SHORT $Return$130541

; 239  :     goto Return;
; 240  : InvalidContinuation1:
; 241  :     ch = 2;

  00279	be 02 00 00 00	 mov	 esi, 2

; 242  :     goto Return;

  0027e	eb 69		 jmp	 SHORT $Return$130541
$InvalidContinuation3$130589:

; 246  : InvalidContinuation3:
; 247  :     ch = 4;

  00280	be 04 00 00 00	 mov	 esi, 4

; 248  :     goto Return;

  00285	eb 62		 jmp	 SHORT $Return$130541
$LN70@ucs4lib_ut:

; 178  :                 /* unexpected end of data: the caller will decide whether
; 179  :                    it's an error or not */
; 180  :                 if (end - s < 2)

  00287	49 2b da	 sub	 rbx, r10
  0028a	48 83 fb 02	 cmp	 rbx, 2
  0028e	7c 59		 jl	 SHORT $Return$130541

; 181  :                     break;
; 182  :                 ch2 = (unsigned char)s[1];

  00290	41 0f b6 52 01	 movzx	 edx, BYTE PTR [r10+1]

; 183  :                 if (!IS_CONTINUATION_BYTE(ch2) ||
; 184  :                     (ch2 < 0x90 ? ch == 0xF0 : ch == 0xF4))

  00295	8d 42 80	 lea	 eax, DWORD PTR [rdx-128]
  00298	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  0029b	0f 87 a4 fe ff
	ff		 ja	 $InvalidContinuation1$130538
  002a1	8b c6		 mov	 eax, esi
  002a3	81 fa 90 00 00
	00		 cmp	 edx, 144		; 00000090H
  002a9	73 08		 jae	 SHORT $LN53@ucs4lib_ut
  002ab	81 f9 f0 00 00
	00		 cmp	 ecx, 240		; 000000f0H
  002b1	eb 06		 jmp	 SHORT $LN83@ucs4lib_ut
$LN53@ucs4lib_ut:
  002b3	81 f9 f4 00 00
	00		 cmp	 ecx, 244		; 000000f4H
$LN83@ucs4lib_ut:
  002b9	0f 94 c0	 sete	 al
  002bc	85 c0		 test	 eax, eax
  002be	0f 85 81 fe ff
	ff		 jne	 $InvalidContinuation1$130538

; 185  :                     /* for clarification see comments below */
; 186  :                     goto InvalidContinuation1;
; 187  :                 if (end - s < 3)

  002c4	48 83 fb 03	 cmp	 rbx, 3
  002c8	7c 1f		 jl	 SHORT $Return$130541

; 188  :                     break;
; 189  :                 ch3 = (unsigned char)s[2];

  002ca	41 0f b6 42 02	 movzx	 eax, BYTE PTR [r10+2]

; 190  :                 if (!IS_CONTINUATION_BYTE(ch3))

  002cf	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  002d4	72 07		 jb	 SHORT $InvalidContinuation2$130560
  002d6	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  002db	72 0c		 jb	 SHORT $Return$130541
$InvalidContinuation2$130560:

; 243  : InvalidContinuation2:
; 244  :     ch = 3;

  002dd	be 03 00 00 00	 mov	 esi, 3

; 245  :     goto Return;

  002e2	eb 05		 jmp	 SHORT $Return$130541
$InvalidStart$130533:

; 228  :             continue;
; 229  :         }
; 230  :         goto InvalidStart;
; 231  :     }
; 232  :     ch = 0;
; 233  : Return:
; 234  :     *inptr = s;
; 235  :     *outpos = p - dest;
; 236  :     return ch;
; 237  : InvalidStart:
; 238  :     ch = 1;

  002e4	be 01 00 00 00	 mov	 esi, 1
$Return$130541:

; 249  : }

  002e9	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]
  002ee	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  002f3	4d 2b dc	 sub	 r11, r12
  002f6	49 c1 fb 02	 sar	 r11, 2
  002fa	4d 89 55 00	 mov	 QWORD PTR [r13], r10
  002fe	8b c6		 mov	 eax, esi
  00300	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  00305	4c 89 5d 00	 mov	 QWORD PTR [rbp], r11
  00309	48 8b 6c 24 20	 mov	 rbp, QWORD PTR [rsp+32]
  0030e	41 5d		 pop	 r13
  00310	41 5c		 pop	 r12
  00312	c3		 ret	 0
ucs4lib_utf8_decode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs4lib_utf16_decode DD imagerel ucs4lib_utf16_decode
	DD	imagerel ucs4lib_utf16_decode+384
	DD	imagerel $unwind$ucs4lib_utf16_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_utf16_decode DD 0c1c01H
	DD	08741cH
	DD	07641cH
	DD	06541cH
	DD	05341cH
	DD	0e01af01cH
	DD	0c016d018H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs4lib_utf16_decode
_TEXT	SEGMENT
inptr$ = 40
e$ = 48
dest$ = 56
outpos$ = 64
native_ordering$ = 72
ucs4lib_utf16_decode PROC				; COMDAT

; 482  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	41 57		 push	 r15

; 483  :     Py_UCS4 ch;
; 484  :     const unsigned char *aligned_end =
; 485  :             (const unsigned char *) _Py_ALIGN_DOWN(e, SIZEOF_LONG);
; 486  :     const unsigned char *q = *inptr;
; 487  :     STRINGLIB_CHAR *p = dest + *outpos;
; 488  :     /* Offsets from q for retrieving byte pairs in the right order. */
; 489  : #ifdef BYTEORDER_IS_LITTLE_ENDIAN
; 490  :     int ihi = !!native_ordering, ilo = !native_ordering;

  0001c	8b 5c 24 48	 mov	 ebx, DWORD PTR native_ordering$[rsp]
  00020	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00023	4c 8b 19	 mov	 r11, QWORD PTR [rcx]
  00026	33 ed		 xor	 ebp, ebp
  00028	48 8b fa	 mov	 rdi, rdx
  0002b	4d 8b e9	 mov	 r13, r9
  0002e	48 83 e7 fc	 and	 rdi, -4
  00032	85 db		 test	 ebx, ebx
  00034	44 8b d5	 mov	 r10d, ebp
  00037	41 0f 95 c2	 setne	 r10b
  0003b	85 db		 test	 ebx, ebx
  0003d	4d 8d 0c 80	 lea	 r9, QWORD PTR [r8+rax*4]
  00041	8b c5		 mov	 eax, ebp
  00043	0f 94 c0	 sete	 al

; 491  : #else
; 492  :     int ihi = !native_ordering, ilo = !!native_ordering;
; 493  : #endif
; 494  :     --e;

  00046	48 8d 72 ff	 lea	 rsi, QWORD PTR [rdx-1]
  0004a	4d 8b f0	 mov	 r14, r8
  0004d	4c 8b f9	 mov	 r15, rcx
  00050	4d 63 d2	 movsxd	 r10, r10d
  00053	4c 63 e0	 movsxd	 r12, eax

; 495  : 
; 496  :     while (q < e) {

  00056	4c 3b de	 cmp	 r11, rsi
  00059	0f 83 f4 00 00
	00		 jae	 $Return$130847
  0005f	90		 npad	 1
$LL17@ucs4lib_ut@2:

; 497  :         Py_UCS4 ch2;
; 498  :         /* First check for possible aligned read of a C 'long'. Unaligned
; 499  :            reads are more expensive, better to defer to another iteration. */
; 500  :         if (_Py_IS_ALIGNED(q, SIZEOF_LONG)) {

  00060	41 f6 c3 03	 test	 r11b, 3
  00064	75 64		 jne	 SHORT $LN8@ucs4lib_ut@2

; 501  :             /* Fast path for runs of in-range non-surrogate chars. */
; 502  :             register const unsigned char *_q = q;

  00066	4d 8b c3	 mov	 r8, r11

; 503  :             while (_q < aligned_end) {

  00069	4c 3b df	 cmp	 r11, rdi
  0006c	73 50		 jae	 SHORT $LN32@ucs4lib_ut@2
  0006e	66 90		 npad	 2
$LL14@ucs4lib_ut@2:

; 504  :                 unsigned long block = * (unsigned long *) _q;

  00070	41 8b 10	 mov	 edx, DWORD PTR [r8]

; 505  :                 if (native_ordering) {

  00073	85 db		 test	 ebx, ebx
  00075	74 0a		 je	 SHORT $LN12@ucs4lib_ut@2

; 506  :                     /* Can use buffer directly */
; 507  :                     if (block & FAST_CHAR_MASK)

  00077	f7 c2 00 80 00
	80		 test	 edx, -2147450880	; 80008000H
  0007d	75 3f		 jne	 SHORT $LN32@ucs4lib_ut@2

; 508  :                         break;
; 509  :                 }
; 510  :                 else {

  0007f	eb 23		 jmp	 SHORT $LN10@ucs4lib_ut@2
$LN12@ucs4lib_ut@2:

; 511  :                     /* Need to byte-swap */
; 512  :                     if (block & SWAB(FAST_CHAR_MASK))

  00081	f7 c2 80 00 80
	00		 test	 edx, 8388736		; 00800080H
  00087	75 35		 jne	 SHORT $LN32@ucs4lib_ut@2

; 513  :                         break;
; 514  : #if STRINGLIB_SIZEOF_CHAR == 1
; 515  :                     block >>= 8;
; 516  : #else
; 517  :                     block = SWAB(block);

  00089	8b ca		 mov	 ecx, edx
  0008b	8b c2		 mov	 eax, edx
  0008d	c1 e0 08	 shl	 eax, 8
  00090	c1 e9 08	 shr	 ecx, 8
  00093	33 c8		 xor	 ecx, eax
  00095	8b c2		 mov	 eax, edx
  00097	81 e1 ff 00 ff
	00		 and	 ecx, 16711935		; 00ff00ffH
  0009d	c1 e0 08	 shl	 eax, 8
  000a0	8b d1		 mov	 edx, ecx
  000a2	33 d0		 xor	 edx, eax
$LN10@ucs4lib_ut@2:

; 518  : #endif
; 519  :                 }
; 520  : #ifdef BYTEORDER_IS_LITTLE_ENDIAN
; 521  : # if SIZEOF_LONG == 4
; 522  :                 p[0] = (STRINGLIB_CHAR)(block & 0xFFFFu);

  000a4	0f b7 c2	 movzx	 eax, dx

; 523  :                 p[1] = (STRINGLIB_CHAR)(block >> 16);

  000a7	c1 ea 10	 shr	 edx, 16

; 524  : # elif SIZEOF_LONG == 8
; 525  :                 p[0] = (STRINGLIB_CHAR)(block & 0xFFFFu);
; 526  :                 p[1] = (STRINGLIB_CHAR)((block >> 16) & 0xFFFFu);
; 527  :                 p[2] = (STRINGLIB_CHAR)((block >> 32) & 0xFFFFu);
; 528  :                 p[3] = (STRINGLIB_CHAR)(block >> 48);
; 529  : # endif
; 530  : #else
; 531  : # if SIZEOF_LONG == 4
; 532  :                 p[0] = (STRINGLIB_CHAR)(block >> 16);
; 533  :                 p[1] = (STRINGLIB_CHAR)(block & 0xFFFFu);
; 534  : # elif SIZEOF_LONG == 8
; 535  :                 p[0] = (STRINGLIB_CHAR)(block >> 48);
; 536  :                 p[1] = (STRINGLIB_CHAR)((block >> 32) & 0xFFFFu);
; 537  :                 p[2] = (STRINGLIB_CHAR)((block >> 16) & 0xFFFFu);
; 538  :                 p[3] = (STRINGLIB_CHAR)(block & 0xFFFFu);
; 539  : # endif
; 540  : #endif
; 541  :                 _q += SIZEOF_LONG;

  000aa	49 83 c0 04	 add	 r8, 4
  000ae	41 89 51 04	 mov	 DWORD PTR [r9+4], edx
  000b2	41 89 01	 mov	 DWORD PTR [r9], eax

; 542  :                 p += SIZEOF_LONG / 2;

  000b5	49 83 c1 08	 add	 r9, 8
  000b9	4c 3b c7	 cmp	 r8, rdi
  000bc	72 b2		 jb	 SHORT $LL14@ucs4lib_ut@2
$LN32@ucs4lib_ut@2:

; 543  :             }
; 544  :             q = _q;

  000be	4d 8b d8	 mov	 r11, r8

; 545  :             if (q >= e)

  000c1	4c 3b c6	 cmp	 r8, rsi
  000c4	0f 83 89 00 00
	00		 jae	 $Return$130847
$LN8@ucs4lib_ut@2:

; 546  :                 break;
; 547  :         }
; 548  : 
; 549  :         ch = (q[ihi] << 8) | q[ilo];

  000ca	43 0f b6 04 1c	 movzx	 eax, BYTE PTR [r12+r11]
  000cf	43 0f b6 0c 1a	 movzx	 ecx, BYTE PTR [r10+r11]

; 550  :         q += 2;

  000d4	49 83 c3 02	 add	 r11, 2
  000d8	c1 e1 08	 shl	 ecx, 8
  000db	0b c8		 or	 ecx, eax

; 551  :         if (!Py_UNICODE_IS_SURROGATE(ch)) {

  000dd	8d 81 00 28 ff
	ff		 lea	 eax, DWORD PTR [rcx-55296]
  000e3	3d ff 07 00 00	 cmp	 eax, 2047		; 000007ffH
  000e8	77 44		 ja	 SHORT $LN6@ucs4lib_ut@2

; 558  :             continue;
; 559  :         }
; 560  : 
; 561  :         /* UTF-16 code pair: */
; 562  :         if (q >= e)

  000ea	4c 3b de	 cmp	 r11, rsi
  000ed	73 5f		 jae	 SHORT $UnexpectedEnd$130837

; 563  :             goto UnexpectedEnd;
; 564  :         if (!Py_UNICODE_IS_HIGH_SURROGATE(ch))

  000ef	81 f9 ff db 00
	00		 cmp	 ecx, 56319		; 0000dbffH
  000f5	77 50		 ja	 SHORT $IllegalEncoding$130840

; 565  :             goto IllegalEncoding;
; 566  :         ch2 = (q[ihi] << 8) | q[ilo];

  000f7	43 0f b6 04 1c	 movzx	 eax, BYTE PTR [r12+r11]
  000fc	43 0f b6 14 1a	 movzx	 edx, BYTE PTR [r10+r11]

; 567  :         q += 2;

  00101	49 83 c3 02	 add	 r11, 2
  00105	c1 e2 08	 shl	 edx, 8
  00108	0b d0		 or	 edx, eax

; 568  :         if (!Py_UNICODE_IS_LOW_SURROGATE(ch2))

  0010a	8d 82 00 24 ff
	ff		 lea	 eax, DWORD PTR [rdx-56320]
  00110	3d ff 03 00 00	 cmp	 eax, 1023		; 000003ffH
  00115	77 29		 ja	 SHORT $IllegalSurrogate$130843

; 569  :             goto IllegalSurrogate;
; 570  :         ch = Py_UNICODE_JOIN_SURROGATES(ch, ch2);
; 571  : #if STRINGLIB_SIZEOF_CHAR < 4
; 572  :         /* Out-of-range */
; 573  :         goto Return;
; 574  : #else
; 575  :         *p++ = (STRINGLIB_CHAR)ch;

  00117	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0011d	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00123	c1 e1 0a	 shl	 ecx, 10
  00126	0b ca		 or	 ecx, edx
  00128	81 c1 00 00 01
	00		 add	 ecx, 65536		; 00010000H
$LN6@ucs4lib_ut@2:

; 552  : #if STRINGLIB_SIZEOF_CHAR < 2
; 553  :             if (ch > STRINGLIB_MAX_CHAR)
; 554  :                 /* Out-of-range */
; 555  :                 goto Return;
; 556  : #endif
; 557  :             *p++ = (STRINGLIB_CHAR)ch;

  0012e	41 89 09	 mov	 DWORD PTR [r9], ecx
  00131	49 83 c1 04	 add	 r9, 4
  00135	4c 3b de	 cmp	 r11, rsi
  00138	0f 82 22 ff ff
	ff		 jb	 $LL17@ucs4lib_ut@2

; 495  : 
; 496  :     while (q < e) {

  0013e	eb 13		 jmp	 SHORT $Return$130847
$IllegalSurrogate$130843:

; 589  : IllegalSurrogate:
; 590  :     ch = 3;

  00140	bd 03 00 00 00	 mov	 ebp, 3

; 591  :     goto Return;

  00145	eb 0c		 jmp	 SHORT $Return$130847
$IllegalEncoding$130840:

; 585  :     goto Return;
; 586  : IllegalEncoding:
; 587  :     ch = 2;

  00147	bd 02 00 00 00	 mov	 ebp, 2

; 588  :     goto Return;

  0014c	eb 05		 jmp	 SHORT $Return$130847
$UnexpectedEnd$130837:

; 576  : #endif
; 577  :     }
; 578  :     ch = 0;
; 579  : Return:
; 580  :     *inptr = q;
; 581  :     *outpos = p - dest;
; 582  :     return ch;
; 583  : UnexpectedEnd:
; 584  :     ch = 1;

  0014e	bd 01 00 00 00	 mov	 ebp, 1
$Return$130847:

; 592  : }

  00153	48 8b 5c 24 28	 mov	 rbx, QWORD PTR [rsp+40]
  00158	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0015d	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00162	4d 2b ce	 sub	 r9, r14
  00165	4d 89 1f	 mov	 QWORD PTR [r15], r11
  00168	8b c5		 mov	 eax, ebp
  0016a	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0016f	49 c1 f9 02	 sar	 r9, 2
  00173	4d 89 4d 00	 mov	 QWORD PTR [r13], r9
  00177	41 5f		 pop	 r15
  00179	41 5e		 pop	 r14
  0017b	41 5d		 pop	 r13
  0017d	41 5c		 pop	 r12
  0017f	c3		 ret	 0
ucs4lib_utf16_decode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs4lib_utf16_encode DD imagerel ucs4lib_utf16_encode
	DD	imagerel ucs4lib_utf16_encode+227
	DD	imagerel $unwind$ucs4lib_utf16_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_utf16_encode DD 020501H
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ucs4lib_utf16_encode
_TEXT	SEGMENT
out$ = 8
in$ = 16
len$ = 24
native_ordering$ = 32
ucs4lib_utf16_encode PROC				; COMDAT

; 604  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 605  :     const STRINGLIB_CHAR *end = in + len;

  00005	4e 8d 14 82	 lea	 r10, QWORD PTR [rdx+r8*4]

; 606  : #if STRINGLIB_SIZEOF_CHAR == 1
; 607  : # define SWAB2(CH)  ((CH) << 8)
; 608  : #else
; 609  : # define SWAB2(CH)  (((CH) << 8) | ((CH) >> 8))
; 610  : #endif
; 611  : #if STRINGLIB_MAX_CHAR < 0x10000
; 612  :     if (native_ordering) {
; 613  : # if STRINGLIB_SIZEOF_CHAR == 2
; 614  :         Py_MEMCPY(out, in, 2 * len);
; 615  : # else
; 616  :         _PyUnicode_CONVERT_BYTES(STRINGLIB_CHAR, unsigned short, in, end, out);
; 617  : # endif
; 618  :     } else {
; 619  :         const STRINGLIB_CHAR *unrolled_end = in + _Py_SIZE_ROUND_DOWN(len, 4);
; 620  :         while (in < unrolled_end) {
; 621  :             out[0] = SWAB2(in[0]);
; 622  :             out[1] = SWAB2(in[1]);
; 623  :             out[2] = SWAB2(in[2]);
; 624  :             out[3] = SWAB2(in[3]);
; 625  :             in += 4; out += 4;
; 626  :         }
; 627  :         while (in < end) {
; 628  :             *out++ = SWAB2(*in);
; 629  :             ++in;
; 630  :         }
; 631  :     }
; 632  : #else
; 633  :     if (native_ordering) {

  00009	45 85 c9	 test	 r9d, r9d
  0000c	74 66		 je	 SHORT $LN14@ucs4lib_ut@3

; 634  :         while (in < end) {

  0000e	49 3b d2	 cmp	 rdx, r10
  00011	0f 83 c6 00 00
	00		 jae	 $LN3@ucs4lib_ut@3
  00017	bb 00 24 00 00	 mov	 ebx, 9216		; 00002400H
  0001c	41 b9 40 28 00
	00		 mov	 r9d, 10304		; 00002840H
  00022	41 bb ff 03 00
	00		 mov	 r11d, 1023		; 000003ffH
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL9@ucs4lib_ut@3:

; 635  :             Py_UCS4 ch = *in++;

  00030	44 8b 02	 mov	 r8d, DWORD PTR [rdx]
  00033	48 83 c2 04	 add	 rdx, 4

; 636  :             if (ch < 0x10000)

  00037	41 81 f8 00 00
	01 00		 cmp	 r8d, 65536		; 00010000H
  0003e	73 0a		 jae	 SHORT $LN7@ucs4lib_ut@3

; 637  :                 *out++ = ch;

  00040	66 44 89 01	 mov	 WORD PTR [rcx], r8w
  00044	48 83 c1 02	 add	 rcx, 2

; 638  :             else {

  00048	eb 1f		 jmp	 SHORT $LN6@ucs4lib_ut@3
$LN7@ucs4lib_ut@3:

; 639  :                 out[0] = Py_UNICODE_HIGH_SURROGATE(ch);

  0004a	41 8b c0	 mov	 eax, r8d

; 640  :                 out[1] = Py_UNICODE_LOW_SURROGATE(ch);

  0004d	66 45 23 c3	 and	 r8w, r11w
  00051	c1 e8 0a	 shr	 eax, 10
  00054	66 44 2b c3	 sub	 r8w, bx
  00058	66 41 2b c1	 sub	 ax, r9w
  0005c	66 44 89 41 02	 mov	 WORD PTR [rcx+2], r8w

; 641  :                 out += 2;

  00061	48 83 c1 04	 add	 rcx, 4
  00065	66 89 41 fc	 mov	 WORD PTR [rcx-4], ax
$LN6@ucs4lib_ut@3:

; 634  :         while (in < end) {

  00069	49 3b d2	 cmp	 rdx, r10
  0006c	72 c2		 jb	 SHORT $LL9@ucs4lib_ut@3

; 655  :             }
; 656  :         }
; 657  :     }
; 658  : #endif
; 659  : #undef SWAB2
; 660  : }

  0006e	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00073	c3		 ret	 0
$LN14@ucs4lib_ut@3:

; 642  :             }
; 643  :         }
; 644  :     } else {
; 645  :         while (in < end) {

  00074	49 3b d2	 cmp	 rdx, r10
  00077	73 64		 jae	 SHORT $LN3@ucs4lib_ut@3
  00079	bb 00 24 00 00	 mov	 ebx, 9216		; 00002400H
  0007e	41 b9 40 28 00
	00		 mov	 r9d, 10304		; 00002840H
  00084	41 bb ff 03 00
	00		 mov	 r11d, 1023		; 000003ffH
  0008a	66 0f 1f 44 00
	00		 npad	 6
$LL4@ucs4lib_ut@3:

; 646  :             Py_UCS4 ch = *in++;

  00090	44 8b 02	 mov	 r8d, DWORD PTR [rdx]
  00093	48 83 c2 04	 add	 rdx, 4

; 647  :             if (ch < 0x10000)

  00097	41 81 f8 00 00
	01 00		 cmp	 r8d, 65536		; 00010000H
  0009e	73 10		 jae	 SHORT $LN2@ucs4lib_ut@3

; 648  :                 *out++ = SWAB2((Py_UCS2)ch);

  000a0	66 41 c1 c0 08	 rol	 r8w, 8
  000a5	48 83 c1 02	 add	 rcx, 2
  000a9	66 44 89 41 fe	 mov	 WORD PTR [rcx-2], r8w

; 649  :             else {

  000ae	eb 28		 jmp	 SHORT $LN1@ucs4lib_ut@3
$LN2@ucs4lib_ut@3:

; 650  :                 Py_UCS2 ch1 = Py_UNICODE_HIGH_SURROGATE(ch);

  000b0	41 8b c0	 mov	 eax, r8d

; 651  :                 Py_UCS2 ch2 = Py_UNICODE_LOW_SURROGATE(ch);

  000b3	66 45 23 c3	 and	 r8w, r11w
  000b7	c1 e8 0a	 shr	 eax, 10
  000ba	66 44 2b c3	 sub	 r8w, bx
  000be	66 41 2b c1	 sub	 ax, r9w

; 652  :                 out[0] = SWAB2(ch1);

  000c2	66 c1 c0 08	 rol	 ax, 8

; 653  :                 out[1] = SWAB2(ch2);

  000c6	66 41 c1 c0 08	 rol	 r8w, 8

; 654  :                 out += 2;

  000cb	48 83 c1 04	 add	 rcx, 4
  000cf	66 44 89 41 fe	 mov	 WORD PTR [rcx-2], r8w
  000d4	66 89 41 fc	 mov	 WORD PTR [rcx-4], ax
$LN1@ucs4lib_ut@3:

; 642  :             }
; 643  :         }
; 644  :     } else {
; 645  :         while (in < end) {

  000d8	49 3b d2	 cmp	 rdx, r10
  000db	72 b3		 jb	 SHORT $LL4@ucs4lib_ut@3
$LN3@ucs4lib_ut@3:

; 655  :             }
; 656  :         }
; 657  :     }
; 658  : #endif
; 659  : #undef SWAB2
; 660  : }

  000dd	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  000e2	c3		 ret	 0
ucs4lib_utf16_encode ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\unicodeobject.c
pdata	SEGMENT
$pdata$ascii_decode DD imagerel ascii_decode
	DD	imagerel ascii_decode+179
	DD	imagerel $unwind$ascii_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ascii_decode DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ascii_decode
_TEXT	SEGMENT
start$ = 48
end$ = 56
dest$ = 64
ascii_decode PROC					; COMDAT

; 4762 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4763 :     const char *p = start;
; 4764 :     const char *aligned_end = (const char *) _Py_ALIGN_DOWN(end, SIZEOF_LONG);

  00006	4c 8b ca	 mov	 r9, rdx
  00009	4d 8b d0	 mov	 r10, r8
  0000c	4c 8b d9	 mov	 r11, rcx
  0000f	49 83 e1 fc	 and	 r9, -4
  00013	48 8b d9	 mov	 rbx, rcx

; 4765 : 
; 4766 :     /*
; 4767 :      * Issue #17237: m68k is a bit different from most architectures in
; 4768 :      * that objects do not use "natural alignment" - for example, int and
; 4769 :      * long are only aligned at 2-byte boundaries.  Therefore the assert()
; 4770 :      * won't work; also, tests have shown that skipping the "optimised
; 4771 :      * version" will even speed up m68k.
; 4772 :      */
; 4773 : #if !defined(__m68k__)
; 4774 : #if SIZEOF_LONG <= SIZEOF_VOID_P
; 4775 :     assert(_Py_IS_ALIGNED(dest, SIZEOF_LONG));
; 4776 :     if (_Py_IS_ALIGNED(p, SIZEOF_LONG)) {

  00016	f6 c1 03	 test	 cl, 3
  00019	75 46		 jne	 SHORT $LN20@ascii_deco

; 4777 :         /* Fast path, see in STRINGLIB(utf8_decode) for
; 4778 :            an explanation. */
; 4779 :         /* Help register allocation */
; 4780 :         register const char *_p = p;

  0001b	48 8b c1	 mov	 rax, rcx

; 4781 :         register Py_UCS1 * q = dest;
; 4782 :         while (_p < aligned_end) {

  0001e	49 3b c9	 cmp	 rcx, r9
  00021	73 1a		 jae	 SHORT $LN31@ascii_deco
$LL14@ascii_deco:

; 4783 :             unsigned long value = *(const unsigned long *) _p;

  00023	8b 08		 mov	 ecx, DWORD PTR [rax]

; 4784 :             if (value & ASCII_CHAR_MASK)

  00025	f7 c1 80 80 80
	80		 test	 ecx, -2139062144	; 80808080H
  0002b	75 10		 jne	 SHORT $LN31@ascii_deco

; 4785 :                 break;
; 4786 :             *((unsigned long *)q) = value;
; 4787 :             _p += SIZEOF_LONG;

  0002d	48 83 c0 04	 add	 rax, 4
  00031	41 89 0a	 mov	 DWORD PTR [r10], ecx

; 4788 :             q += SIZEOF_LONG;

  00034	49 83 c2 04	 add	 r10, 4
  00038	49 3b c1	 cmp	 rax, r9
  0003b	72 e6		 jb	 SHORT $LL14@ascii_deco
$LN31@ascii_deco:

; 4789 :         }
; 4790 :         p = _p;
; 4791 :         while (p < end) {

  0003d	48 3b c2	 cmp	 rax, rdx
  00040	73 16		 jae	 SHORT $LN32@ascii_deco
  00042	4c 2b d0	 sub	 r10, rax
$LL11@ascii_deco:

; 4792 :             if ((unsigned char)*p & 0x80)

  00045	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00048	84 c9		 test	 cl, cl
  0004a	78 0c		 js	 SHORT $LN32@ascii_deco

; 4793 :                 break;
; 4794 :             *q++ = *p++;

  0004c	41 88 0c 02	 mov	 BYTE PTR [r10+rax], cl
  00050	48 ff c0	 inc	 rax
  00053	48 3b c2	 cmp	 rax, rdx
  00056	72 ed		 jb	 SHORT $LL11@ascii_deco
$LN32@ascii_deco:

; 4795 :         }
; 4796 :         return p - start;

  00058	49 2b c3	 sub	 rax, r11

; 4822 : }

  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5b		 pop	 rbx
  00060	c3		 ret	 0
$LN20@ascii_deco:

; 4797 :     }
; 4798 : #endif
; 4799 : #endif
; 4800 :     while (p < end) {

  00061	48 3b ca	 cmp	 rcx, rdx
  00064	73 33		 jae	 SHORT $LN34@ascii_deco
$LL8@ascii_deco:

; 4801 :         /* Fast path, see in STRINGLIB(utf8_decode) in stringlib/codecs.h
; 4802 :            for an explanation. */
; 4803 :         if (_Py_IS_ALIGNED(p, SIZEOF_LONG)) {

  00066	f6 c3 03	 test	 bl, 3
  00069	75 21		 jne	 SHORT $LN2@ascii_deco

; 4804 :             /* Help register allocation */
; 4805 :             register const char *_p = p;

  0006b	48 8b c3	 mov	 rax, rbx

; 4806 :             while (_p < aligned_end) {

  0006e	49 3b d9	 cmp	 rbx, r9
  00071	73 11		 jae	 SHORT $LN33@ascii_deco
$LL5@ascii_deco:

; 4807 :                 unsigned long value = *(unsigned long *) _p;
; 4808 :                 if (value & ASCII_CHAR_MASK)

  00073	f7 00 80 80 80
	80		 test	 DWORD PTR [rax], -2139062144 ; 80808080H
  00079	75 09		 jne	 SHORT $LN33@ascii_deco

; 4809 :                     break;
; 4810 :                 _p += SIZEOF_LONG;

  0007b	48 83 c0 04	 add	 rax, 4
  0007f	49 3b c1	 cmp	 rax, r9
  00082	72 ef		 jb	 SHORT $LL5@ascii_deco
$LN33@ascii_deco:

; 4811 :             }
; 4812 :             p = _p;

  00084	48 8b d8	 mov	 rbx, rax

; 4813 :             if (_p == end)

  00087	48 3b c2	 cmp	 rax, rdx
  0008a	74 0d		 je	 SHORT $LN34@ascii_deco
$LN2@ascii_deco:

; 4814 :                 break;
; 4815 :         }
; 4816 :         if ((unsigned char)*p & 0x80)

  0008c	f6 03 80	 test	 BYTE PTR [rbx], 128	; 00000080H
  0008f	75 08		 jne	 SHORT $LN34@ascii_deco

; 4817 :             break;
; 4818 :         ++p;

  00091	48 ff c3	 inc	 rbx
  00094	48 3b da	 cmp	 rbx, rdx
  00097	72 cd		 jb	 SHORT $LL8@ascii_deco
$LN34@ascii_deco:

; 4819 :     }
; 4820 :     memcpy(dest, start, p - start);

  00099	48 2b d9	 sub	 rbx, rcx
  0009c	48 8b d1	 mov	 rdx, rcx
  0009f	49 8b ca	 mov	 rcx, r10
  000a2	4c 8b c3	 mov	 r8, rbx
  000a5	e8 00 00 00 00	 call	 memcpy

; 4821 :     return p - start;

  000aa	48 8b c3	 mov	 rax, rbx

; 4822 : }

  000ad	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b1	5b		 pop	 rbx
  000b2	c3		 ret	 0
ascii_decode ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_EncodeUTF32
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_EncodeUTF32 DD imagerel $LN48
	DD	imagerel $LN48+502
	DD	imagerel $unwind$_PyUnicode_EncodeUTF32
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_EncodeUTF32 DD 0c6e01H
	DD	0c646eH
	DD	0b3469H
	DD	0d5412H
	DD	0f00e3212H
	DD	0d00ae00cH
	DD	07006c008H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_EncodeUTF32
_TEXT	SEGMENT
v$1$ = 80
str$ = 80
errors$ = 88
byteorder$ = 96
_PyUnicode_EncodeUTF32 PROC				; COMDAT

; 5208 : {

$LN48:
  00000	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00005	57		 push	 rdi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	41 56		 push	 r14
  0000c	41 57		 push	 r15
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5209 :     int kind;
; 5210 :     void *data;
; 5211 :     Py_ssize_t len;
; 5212 :     PyObject *v;
; 5213 :     unsigned char *p;
; 5214 :     Py_ssize_t nsize, i;
; 5215 :     /* Offsets from p for storing byte pairs in the right order. */
; 5216 : #ifdef BYTEORDER_IS_LITTLE_ENDIAN
; 5217 :     int iorder[] = {0, 1, 2, 3};
; 5218 : #else
; 5219 :     int iorder[] = {3, 2, 1, 0};
; 5220 : #endif
; 5221 : 
; 5222 : #define STORECHAR(CH)                           \
; 5223 :     do {                                        \
; 5224 :         p[iorder[3]] = ((CH) >> 24) & 0xff;     \
; 5225 :         p[iorder[2]] = ((CH) >> 16) & 0xff;     \
; 5226 :         p[iorder[1]] = ((CH) >> 8) & 0xff;      \
; 5227 :         p[iorder[0]] = (CH) & 0xff;             \
; 5228 :         p += 4;                                 \
; 5229 :     } while(0)
; 5230 : 
; 5231 :     if (!PyUnicode_Check(str)) {

  00012	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00016	45 33 f6	 xor	 r14d, r14d
  00019	41 8b e8	 mov	 ebp, r8d
  0001c	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00026	48 8b f9	 mov	 rdi, rcx
  00029	45 8d 7e 01	 lea	 r15d, QWORD PTR [r14+1]
  0002d	45 8d 66 02	 lea	 r12d, QWORD PTR [r14+2]
  00031	45 8d 6e 03	 lea	 r13d, QWORD PTR [r14+3]
  00035	75 1a		 jne	 SHORT $LN18@PyUnicode_@21

; 5232 :         PyErr_BadArgument();

  00037	e8 00 00 00 00	 call	 PyErr_BadArgument
$LN47@PyUnicode_@21:

; 5233 :         return NULL;

  0003c	33 c0		 xor	 eax, eax

; 5271 : 
; 5272 :   done:
; 5273 :     return v;
; 5274 : #undef STORECHAR
; 5275 : }

  0003e	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	41 5f		 pop	 r15
  00049	41 5e		 pop	 r14
  0004b	41 5d		 pop	 r13
  0004d	41 5c		 pop	 r12
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
$LN18@PyUnicode_@21:

; 5234 :     }
; 5235 :     if (PyUnicode_READY(str) == -1)

  00051	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00055	75 0a		 jne	 SHORT $LN17@PyUnicode_@21
  00057	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0005c	83 f8 ff	 cmp	 eax, -1

; 5236 :         return NULL;

  0005f	74 db		 je	 SHORT $LN47@PyUnicode_@21
$LN17@PyUnicode_@21:

; 5237 :     kind = PyUnicode_KIND(str);

  00061	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00064	48 89 5c 24 58	 mov	 QWORD PTR [rsp+88], rbx
  00069	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  0006e	8b f0		 mov	 esi, eax
  00070	c1 ee 02	 shr	 esi, 2
  00073	83 e6 07	 and	 esi, 7

; 5238 :     data = PyUnicode_DATA(str);

  00076	a8 20		 test	 al, 32			; 00000020H
  00078	74 16		 je	 SHORT $LN25@PyUnicode_@21
  0007a	a8 40		 test	 al, 64			; 00000040H
  0007c	74 09		 je	 SHORT $LN23@PyUnicode_@21
  0007e	48 8d 9f 80 00
	00 00		 lea	 rbx, QWORD PTR [rdi+128]
  00085	eb 10		 jmp	 SHORT $LN26@PyUnicode_@21
$LN23@PyUnicode_@21:
  00087	48 8d 9f a0 00
	00 00		 lea	 rbx, QWORD PTR [rdi+160]
  0008e	eb 07		 jmp	 SHORT $LN26@PyUnicode_@21
$LN25@PyUnicode_@21:
  00090	48 8b 9f a0 00
	00 00		 mov	 rbx, QWORD PTR [rdi+160]
$LN26@PyUnicode_@21:

; 5239 :     len = PyUnicode_GET_LENGTH(str);

  00097	48 8b 7f 60	 mov	 rdi, QWORD PTR [rdi+96]

; 5240 : 
; 5241 :     nsize = len + (byteorder == 0);

  0009b	33 d2		 xor	 edx, edx
  0009d	85 ed		 test	 ebp, ebp
  0009f	0f 94 c2	 sete	 dl

; 5242 :     if (nsize > PY_SSIZE_T_MAX / 4)

  000a2	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  000ac	48 03 d7	 add	 rdx, rdi
  000af	48 3b d0	 cmp	 rdx, rax
  000b2	7e 0a		 jle	 SHORT $LN16@PyUnicode_@21

; 5243 :         return PyErr_NoMemory();

  000b4	e8 00 00 00 00	 call	 PyErr_NoMemory
  000b9	e9 1b 01 00 00	 jmp	 $done$131322
$LN16@PyUnicode_@21:

; 5244 :     v = PyBytes_FromStringAndSize(NULL, nsize * 4);

  000be	48 c1 e2 02	 shl	 rdx, 2
  000c2	33 c9		 xor	 ecx, ecx
  000c4	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000c9	48 89 44 24 50	 mov	 QWORD PTR v$1$[rsp], rax

; 5245 :     if (v == NULL)

  000ce	48 85 c0	 test	 rax, rax
  000d1	0f 84 02 01 00
	00		 je	 $done$131322
$LN15@PyUnicode_@21:

; 5246 :         return NULL;
; 5247 : 
; 5248 :     p = (unsigned char *)PyBytes_AS_STRING(v);

  000d7	48 8d 50 78	 lea	 rdx, QWORD PTR [rax+120]

; 5249 :     if (byteorder == 0)

  000db	85 ed		 test	 ebp, ebp
  000dd	75 0e		 jne	 SHORT $LN11@PyUnicode_@21

; 5250 :         STORECHAR(0xFEFF);

  000df	66 44 89 72 02	 mov	 WORD PTR [rdx+2], r14w
  000e4	66 c7 02 ff fe	 mov	 WORD PTR [rdx], 65279	; 0000feffH
  000e9	48 83 c2 04	 add	 rdx, 4
$LN11@PyUnicode_@21:

; 5251 :     if (len == 0)

  000ed	48 85 ff	 test	 rdi, rdi
  000f0	0f 84 e3 00 00
	00		 je	 $done$131322

; 5252 :         goto done;
; 5253 : 
; 5254 :     if (byteorder == -1) {

  000f6	83 fd ff	 cmp	 ebp, -1

; 5255 :         /* force LE */
; 5256 :         iorder[0] = 0;
; 5257 :         iorder[1] = 1;
; 5258 :         iorder[2] = 2;
; 5259 :         iorder[3] = 3;

  000f9	74 14		 je	 SHORT $LN7@PyUnicode_@21

; 5260 :     }
; 5261 :     else if (byteorder == 1) {

  000fb	41 3b ef	 cmp	 ebp, r15d
  000fe	75 0f		 jne	 SHORT $LN7@PyUnicode_@21

; 5262 :         /* force BE */
; 5263 :         iorder[0] = 3;

  00100	45 8b f5	 mov	 r14d, r13d

; 5264 :         iorder[1] = 2;

  00103	45 8b fc	 mov	 r15d, r12d

; 5265 :         iorder[2] = 1;

  00106	41 bc 01 00 00
	00		 mov	 r12d, 1

; 5266 :         iorder[3] = 0;

  0010c	45 33 ed	 xor	 r13d, r13d
$LN7@PyUnicode_@21:

; 5270 :         STORECHAR(PyUnicode_READ(kind, data, i));

  0010f	48 63 ce	 movsxd	 rcx, esi
  00112	48 85 ff	 test	 rdi, rdi
  00115	0f 8e be 00 00
	00		 jle	 $done$131322

; 5267 :     }
; 5268 : 
; 5269 :     for (i = 0; i < len; i++)

  0011b	49 63 c4	 movsxd	 rax, r12d
  0011e	4d 63 dd	 movsxd	 r11, r13d
  00121	49 63 f7	 movsxd	 rsi, r15d
  00124	4d 63 d6	 movsxd	 r10, r14d
  00127	4c 8d 0c 10	 lea	 r9, QWORD PTR [rax+rdx]
  0012b	4c 2b d8	 sub	 r11, rax
  0012e	48 2b f0	 sub	 rsi, rax
  00131	4c 8b c3	 mov	 r8, rbx
  00134	48 8b d3	 mov	 rdx, rbx
  00137	4c 2b d0	 sub	 r10, rax
  0013a	66 0f 1f 44 00
	00		 npad	 6
$LL6@PyUnicode_@21:

; 5270 :         STORECHAR(PyUnicode_READ(kind, data, i));

  00140	48 83 f9 01	 cmp	 rcx, 1
  00144	75 05		 jne	 SHORT $LN29@PyUnicode_@21
  00146	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00149	eb 0e		 jmp	 SHORT $LN28@PyUnicode_@21
$LN29@PyUnicode_@21:
  0014b	48 83 f9 02	 cmp	 rcx, 2
  0014f	75 06		 jne	 SHORT $LN27@PyUnicode_@21
  00151	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
  00155	eb 02		 jmp	 SHORT $LN28@PyUnicode_@21
$LN27@PyUnicode_@21:
  00157	8b 02		 mov	 eax, DWORD PTR [rdx]
$LN28@PyUnicode_@21:
  00159	c1 e8 18	 shr	 eax, 24
  0015c	43 88 04 0b	 mov	 BYTE PTR [r11+r9], al
  00160	48 83 f9 01	 cmp	 rcx, 1
  00164	75 05		 jne	 SHORT $LN33@PyUnicode_@21
  00166	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00169	eb 0e		 jmp	 SHORT $LN32@PyUnicode_@21
$LN33@PyUnicode_@21:
  0016b	48 83 f9 02	 cmp	 rcx, 2
  0016f	75 06		 jne	 SHORT $LN31@PyUnicode_@21
  00171	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
  00175	eb 02		 jmp	 SHORT $LN32@PyUnicode_@21
$LN31@PyUnicode_@21:
  00177	8b 02		 mov	 eax, DWORD PTR [rdx]
$LN32@PyUnicode_@21:
  00179	c1 e8 10	 shr	 eax, 16
  0017c	41 88 01	 mov	 BYTE PTR [r9], al
  0017f	48 83 f9 01	 cmp	 rcx, 1
  00183	75 05		 jne	 SHORT $LN37@PyUnicode_@21
  00185	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00188	eb 0e		 jmp	 SHORT $LN36@PyUnicode_@21
$LN37@PyUnicode_@21:
  0018a	48 83 f9 02	 cmp	 rcx, 2
  0018e	75 06		 jne	 SHORT $LN35@PyUnicode_@21
  00190	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
  00194	eb 02		 jmp	 SHORT $LN36@PyUnicode_@21
$LN35@PyUnicode_@21:
  00196	8b 02		 mov	 eax, DWORD PTR [rdx]
$LN36@PyUnicode_@21:
  00198	c1 e8 08	 shr	 eax, 8
  0019b	42 88 04 0e	 mov	 BYTE PTR [rsi+r9], al
  0019f	48 83 f9 01	 cmp	 rcx, 1
  001a3	75 05		 jne	 SHORT $LN41@PyUnicode_@21
  001a5	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  001a8	eb 0e		 jmp	 SHORT $LN40@PyUnicode_@21
$LN41@PyUnicode_@21:
  001aa	48 83 f9 02	 cmp	 rcx, 2
  001ae	75 06		 jne	 SHORT $LN39@PyUnicode_@21
  001b0	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
  001b4	eb 02		 jmp	 SHORT $LN40@PyUnicode_@21
$LN39@PyUnicode_@21:
  001b6	8b 02		 mov	 eax, DWORD PTR [rdx]
$LN40@PyUnicode_@21:
  001b8	43 88 04 0a	 mov	 BYTE PTR [r10+r9], al
  001bc	49 83 c1 04	 add	 r9, 4
  001c0	48 ff c3	 inc	 rbx
  001c3	49 83 c0 02	 add	 r8, 2
  001c7	48 83 c2 04	 add	 rdx, 4
  001cb	48 ff cf	 dec	 rdi
  001ce	0f 85 6c ff ff
	ff		 jne	 $LL6@PyUnicode_@21
  001d4	48 8b 44 24 50	 mov	 rax, QWORD PTR v$1$[rsp]
$done$131322:
  001d9	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  001de	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]

; 5271 : 
; 5272 :   done:
; 5273 :     return v;
; 5274 : #undef STORECHAR
; 5275 : }

  001e3	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  001e8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001ec	41 5f		 pop	 r15
  001ee	41 5e		 pop	 r14
  001f0	41 5d		 pop	 r13
  001f2	41 5c		 pop	 r12
  001f4	5f		 pop	 rdi
  001f5	c3		 ret	 0
_PyUnicode_EncodeUTF32 ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsUTF32String
; Function compile flags: /Ogtpy
;	COMDAT PyUnicode_AsUTF32String
_TEXT	SEGMENT
unicode$ = 8
PyUnicode_AsUTF32String PROC				; COMDAT

; 5295 :     return _PyUnicode_EncodeUTF32(unicode, NULL, 0);

  00000	45 33 c0	 xor	 r8d, r8d
  00003	33 d2		 xor	 edx, edx

; 5296 : }

  00005	e9 00 00 00 00	 jmp	 _PyUnicode_EncodeUTF32
PyUnicode_AsUTF32String ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_EncodeUTF16
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_EncodeUTF16 DD imagerel $LN29
	DD	imagerel $LN29+370
	DD	imagerel $unwind$_PyUnicode_EncodeUTF16
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_EncodeUTF16 DD 0a6301H
	DD	097463H
	DD	08645eH
	DD	0a340eH
	DD	0d00a320eH
	DD	05006c008H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_EncodeUTF16
_TEXT	SEGMENT
str$ = 64
errors$ = 72
byteorder$ = 80
_PyUnicode_EncodeUTF16 PROC				; COMDAT

; 5470 : {

$LN29:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5471 :     enum PyUnicode_Kind kind;
; 5472 :     const void *data;
; 5473 :     Py_ssize_t len;
; 5474 :     PyObject *v;
; 5475 :     unsigned short *out;
; 5476 :     Py_ssize_t bytesize;
; 5477 :     Py_ssize_t pairs;
; 5478 : #ifdef WORDS_BIGENDIAN
; 5479 :     int native_ordering = byteorder >= 0;
; 5480 : #else
; 5481 :     int native_ordering = byteorder <= 0;
; 5482 : #endif
; 5483 : 
; 5484 :     if (!PyUnicode_Check(str)) {

  0000e	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00012	33 ed		 xor	 ebp, ebp
  00014	45 85 c0	 test	 r8d, r8d
  00017	44 8b ed	 mov	 r13d, ebp
  0001a	41 0f 9e c5	 setle	 r13b
  0001e	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00028	45 8b e0	 mov	 r12d, r8d
  0002b	48 8b d9	 mov	 rbx, rcx
  0002e	75 16		 jne	 SHORT $LN16@PyUnicode_@22

; 5485 :         PyErr_BadArgument();

  00030	e8 00 00 00 00	 call	 PyErr_BadArgument
$LN28@PyUnicode_@22:

; 5486 :         return NULL;

  00035	33 c0		 xor	 eax, eax

; 5536 : }

  00037	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	41 5d		 pop	 r13
  00042	41 5c		 pop	 r12
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
$LN16@PyUnicode_@22:

; 5487 :     }
; 5488 :     if (PyUnicode_READY(str) == -1)

  00046	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0004a	75 0a		 jne	 SHORT $LN15@PyUnicode_@22
  0004c	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00051	83 f8 ff	 cmp	 eax, -1

; 5489 :         return NULL;

  00054	74 df		 je	 SHORT $LN28@PyUnicode_@22
$LN15@PyUnicode_@22:

; 5490 :     kind = PyUnicode_KIND(str);

  00056	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00059	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0005e	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00063	8b f8		 mov	 edi, eax
  00065	c1 ef 02	 shr	 edi, 2
  00068	83 e7 07	 and	 edi, 7

; 5491 :     data = PyUnicode_DATA(str);

  0006b	a8 20		 test	 al, 32			; 00000020H
  0006d	74 16		 je	 SHORT $LN23@PyUnicode_@22
  0006f	a8 40		 test	 al, 64			; 00000040H
  00071	74 09		 je	 SHORT $LN21@PyUnicode_@22
  00073	48 8d b3 80 00
	00 00		 lea	 rsi, QWORD PTR [rbx+128]
  0007a	eb 10		 jmp	 SHORT $LN24@PyUnicode_@22
$LN21@PyUnicode_@22:
  0007c	48 8d b3 a0 00
	00 00		 lea	 rsi, QWORD PTR [rbx+160]
  00083	eb 07		 jmp	 SHORT $LN24@PyUnicode_@22
$LN23@PyUnicode_@22:
  00085	48 8b b3 a0 00
	00 00		 mov	 rsi, QWORD PTR [rbx+160]
$LN24@PyUnicode_@22:

; 5492 :     len = PyUnicode_GET_LENGTH(str);

  0008c	48 8b 5b 60	 mov	 rbx, QWORD PTR [rbx+96]

; 5493 : 
; 5494 :     pairs = 0;

  00090	48 8b d5	 mov	 rdx, rbp

; 5495 :     if (kind == PyUnicode_4BYTE_KIND) {

  00093	83 ff 04	 cmp	 edi, 4
  00096	75 2d		 jne	 SHORT $LN12@PyUnicode_@22

; 5496 :         const Py_UCS4 *in = (const Py_UCS4 *)data;
; 5497 :         const Py_UCS4 *end = in + len;

  00098	4c 8d 04 9e	 lea	 r8, QWORD PTR [rsi+rbx*4]
  0009c	48 8b ce	 mov	 rcx, rsi

; 5498 :         while (in < end)

  0009f	49 3b f0	 cmp	 rsi, r8
  000a2	73 21		 jae	 SHORT $LN12@PyUnicode_@22
  000a4	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL13@PyUnicode_@22:

; 5499 :             if (*in++ >= 0x10000)

  000b0	8b 01		 mov	 eax, DWORD PTR [rcx]
  000b2	48 83 c1 04	 add	 rcx, 4
  000b6	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
  000bb	72 03		 jb	 SHORT $LN11@PyUnicode_@22

; 5500 :                 pairs++;

  000bd	48 ff c2	 inc	 rdx
$LN11@PyUnicode_@22:

; 5498 :         while (in < end)

  000c0	49 3b c8	 cmp	 rcx, r8
  000c3	72 eb		 jb	 SHORT $LL13@PyUnicode_@22
$LN12@PyUnicode_@22:

; 5501 :     }
; 5502 :     if (len > PY_SSIZE_T_MAX / 2 - pairs - (byteorder == 0))

  000c5	45 85 e4	 test	 r12d, r12d
  000c8	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  000d2	40 0f 94 c5	 sete	 bpl
  000d6	48 2b c5	 sub	 rax, rbp
  000d9	48 2b c2	 sub	 rax, rdx
  000dc	48 3b d8	 cmp	 rbx, rax
  000df	7e 07		 jle	 SHORT $LN10@PyUnicode_@22

; 5503 :         return PyErr_NoMemory();

  000e1	e8 00 00 00 00	 call	 PyErr_NoMemory
  000e6	eb 71		 jmp	 SHORT $LN27@PyUnicode_@22
$LN10@PyUnicode_@22:

; 5504 :     bytesize = (len + pairs + (byteorder == 0)) * 2;
; 5505 :     v = PyBytes_FromStringAndSize(NULL, bytesize);

  000e8	48 03 d5	 add	 rdx, rbp
  000eb	33 c9		 xor	 ecx, ecx
  000ed	48 03 d3	 add	 rdx, rbx
  000f0	48 03 d2	 add	 rdx, rdx
  000f3	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000f8	48 8b e8	 mov	 rbp, rax

; 5506 :     if (v == NULL)

  000fb	48 85 c0	 test	 rax, rax
  000fe	74 59		 je	 SHORT $LN27@PyUnicode_@22
$LN9@PyUnicode_@22:

; 5507 :         return NULL;
; 5508 : 
; 5509 :     /* output buffer is 2-bytes aligned */
; 5510 :     assert(_Py_IS_ALIGNED(PyBytes_AS_STRING(v), 2));
; 5511 :     out = (unsigned short *)PyBytes_AS_STRING(v);

  00100	48 8d 48 78	 lea	 rcx, QWORD PTR [rax+120]

; 5512 :     if (byteorder == 0)

  00104	45 85 e4	 test	 r12d, r12d
  00107	75 0d		 jne	 SHORT $LN8@PyUnicode_@22

; 5513 :         *out++ = 0xFEFF;

  00109	b8 ff fe 00 00	 mov	 eax, 65279		; 0000feffH
  0010e	48 83 c1 02	 add	 rcx, 2
  00112	66 89 41 fe	 mov	 WORD PTR [rcx-2], ax
$LN8@PyUnicode_@22:

; 5514 :     if (len == 0)

  00116	48 85 db	 test	 rbx, rbx
  00119	74 3b		 je	 SHORT $done$131607

; 5515 :         goto done;
; 5516 : 
; 5517 :     switch (kind) {

  0011b	ff cf		 dec	 edi
  0011d	74 29		 je	 SHORT $LN4@PyUnicode_@22
  0011f	ff cf		 dec	 edi
  00121	74 15		 je	 SHORT $LN3@PyUnicode_@22
  00123	83 ff 02	 cmp	 edi, 2
  00126	75 2e		 jne	 SHORT $done$131607

; 5525 :     }
; 5526 :     case PyUnicode_4BYTE_KIND: {
; 5527 :         ucs4lib_utf16_encode(out, (const Py_UCS4 *)data, len, native_ordering);

  00128	45 8b cd	 mov	 r9d, r13d
  0012b	4c 8b c3	 mov	 r8, rbx
  0012e	48 8b d6	 mov	 rdx, rsi
  00131	e8 00 00 00 00	 call	 ucs4lib_utf16_encode

; 5528 :         break;

  00136	eb 1e		 jmp	 SHORT $done$131607
$LN3@PyUnicode_@22:

; 5520 :         break;
; 5521 :     }
; 5522 :     case PyUnicode_2BYTE_KIND: {
; 5523 :         ucs2lib_utf16_encode(out, (const Py_UCS2 *)data, len, native_ordering);

  00138	45 8b cd	 mov	 r9d, r13d
  0013b	4c 8b c3	 mov	 r8, rbx
  0013e	48 8b d6	 mov	 rdx, rsi
  00141	e8 00 00 00 00	 call	 ucs2lib_utf16_encode

; 5524 :         break;

  00146	eb 0e		 jmp	 SHORT $done$131607
$LN4@PyUnicode_@22:

; 5518 :     case PyUnicode_1BYTE_KIND: {
; 5519 :         ucs1lib_utf16_encode(out, (const Py_UCS1 *)data, len, native_ordering);

  00148	45 8b cd	 mov	 r9d, r13d
  0014b	4c 8b c3	 mov	 r8, rbx
  0014e	48 8b d6	 mov	 rdx, rsi
  00151	e8 00 00 00 00	 call	 ucs1lib_utf16_encode
$done$131607:

; 5529 :     }
; 5530 :     default:
; 5531 :         assert(0);
; 5532 :     }
; 5533 : 
; 5534 :   done:
; 5535 :     return v;

  00156	48 8b c5	 mov	 rax, rbp
$LN27@PyUnicode_@22:
  00159	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0015e	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 5536 : }

  00163	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00168	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016c	41 5d		 pop	 r13
  0016e	41 5c		 pop	 r12
  00170	5d		 pop	 rbp
  00171	c3		 ret	 0
_PyUnicode_EncodeUTF16 ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsUTF16String
; Function compile flags: /Ogtpy
;	COMDAT PyUnicode_AsUTF16String
_TEXT	SEGMENT
unicode$ = 8
PyUnicode_AsUTF16String PROC				; COMDAT

; 5556 :     return _PyUnicode_EncodeUTF16(unicode, NULL, 0);

  00000	45 33 c0	 xor	 r8d, r8d
  00003	33 d2		 xor	 edx, edx

; 5557 : }

  00005	e9 00 00 00 00	 jmp	 _PyUnicode_EncodeUTF16
PyUnicode_AsUTF16String ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT length_of_escaped_ascii_string
_TEXT	SEGMENT
s$ = 8
size$ = 16
length_of_escaped_ascii_string PROC			; COMDAT

; 5570 :     const unsigned char *p = (const unsigned char *)s;
; 5571 :     const unsigned char *end = p + size;
; 5572 :     Py_ssize_t length = 0;

  00000	45 33 c9	 xor	 r9d, r9d
  00003	4c 8b c1	 mov	 r8, rcx
  00006	4c 8d 14 11	 lea	 r10, QWORD PTR [rcx+rdx]

; 5573 : 
; 5574 :     if (size < 0)

  0000a	48 85 d2	 test	 rdx, rdx
  0000d	79 05		 jns	 SHORT $LN16@length_of_
$LN20@length_of_:

; 5575 :         return -1;

  0000f	48 83 c8 ff	 or	 rax, -1

; 5614 : }

  00013	c3		 ret	 0
$LN16@length_of_:

; 5576 : 
; 5577 :     for (; p < end; ++p) {

  00014	49 3b ca	 cmp	 rcx, r10
  00017	73 5a		 jae	 SHORT $LN13@length_of_
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
$LL15@length_of_:

; 5578 :         if (*p > 127) {

  00020	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00024	3c 7f		 cmp	 al, 127			; 0000007fH
  00026	77 e7		 ja	 SHORT $LN20@length_of_

; 5579 :             /* Non-ASCII */
; 5580 :             return -1;
; 5581 :         }
; 5582 :         else if (*p != '\\') {

  00028	3c 5c		 cmp	 al, 92			; 0000005cH
  0002a	74 05		 je	 SHORT $LN10@length_of_

; 5583 :             /* Normal character */
; 5584 :             ++length;

  0002c	49 ff c1	 inc	 r9

; 5585 :         }
; 5586 :         else {

  0002f	eb 3a		 jmp	 SHORT $LN14@length_of_
$LN10@length_of_:

; 5587 :             /* Backslash-escape, check next char */
; 5588 :             ++p;

  00031	49 ff c0	 inc	 r8

; 5589 :             /* Escape sequence reaches till end of string or
; 5590 :                non-ASCII follow-up. */
; 5591 :             if (p >= end || *p > 127)

  00034	4d 3b c2	 cmp	 r8, r10
  00037	73 d6		 jae	 SHORT $LN20@length_of_
  00039	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  0003d	3c 7f		 cmp	 al, 127			; 0000007fH
  0003f	77 ce		 ja	 SHORT $LN20@length_of_

; 5592 :                 return -1;
; 5593 :             switch (*p) {

  00041	0f b6 c0	 movzx	 eax, al
  00044	83 c0 f6	 add	 eax, -10
  00047	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  0004a	77 1b		 ja	 SHORT $LN1@length_of_
  0004c	48 98		 cdqe
  0004e	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN23@length_of_[rdx+rax]
  00056	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN24@length_of_[rdx+rax*4]
  0005d	48 03 ca	 add	 rcx, rdx
  00060	ff e1		 jmp	 rcx
$LN3@length_of_:

; 5594 :             case '\n':
; 5595 :                 /* backslash + \n result in zero characters */
; 5596 :                 break;
; 5597 :             case '\\': case '\'': case '\"':
; 5598 :             case 'b': case 'f': case 't':
; 5599 :             case 'n': case 'r': case 'v': case 'a':
; 5600 :                 ++length;

  00062	49 ff c1	 inc	 r9

; 5601 :                 break;

  00065	eb 04		 jmp	 SHORT $LN14@length_of_
$LN1@length_of_:

; 5602 :             case '0': case '1': case '2': case '3':
; 5603 :             case '4': case '5': case '6': case '7':
; 5604 :             case 'x': case 'u': case 'U': case 'N':
; 5605 :                 /* these do not guarantee ASCII characters */
; 5606 :                 return -1;
; 5607 :             default:
; 5608 :                 /* count the backslash + the other character */
; 5609 :                 length += 2;

  00067	49 83 c1 02	 add	 r9, 2
$LN14@length_of_:

; 5576 : 
; 5577 :     for (; p < end; ++p) {

  0006b	49 ff c0	 inc	 r8
  0006e	4d 3b c2	 cmp	 r8, r10
  00071	72 ad		 jb	 SHORT $LL15@length_of_
$LN13@length_of_:

; 5610 :             }
; 5611 :         }
; 5612 :     }
; 5613 :     return length;

  00073	49 8b c1	 mov	 rax, r9

; 5614 : }

  00076	c3		 ret	 0
  00077	90		 npad	 1
$LN24@length_of_:
  00078	00 00 00 00	 DD	 $LN14@length_of_
  0007c	00 00 00 00	 DD	 $LN3@length_of_
  00080	00 00 00 00	 DD	 $LN20@length_of_
  00084	00 00 00 00	 DD	 $LN1@length_of_
$LN23@length_of_:
  00088	00		 DB	 0
  00089	03		 DB	 3
  0008a	03		 DB	 3
  0008b	03		 DB	 3
  0008c	03		 DB	 3
  0008d	03		 DB	 3
  0008e	03		 DB	 3
  0008f	03		 DB	 3
  00090	03		 DB	 3
  00091	03		 DB	 3
  00092	03		 DB	 3
  00093	03		 DB	 3
  00094	03		 DB	 3
  00095	03		 DB	 3
  00096	03		 DB	 3
  00097	03		 DB	 3
  00098	03		 DB	 3
  00099	03		 DB	 3
  0009a	03		 DB	 3
  0009b	03		 DB	 3
  0009c	03		 DB	 3
  0009d	03		 DB	 3
  0009e	03		 DB	 3
  0009f	03		 DB	 3
  000a0	01		 DB	 1
  000a1	03		 DB	 3
  000a2	03		 DB	 3
  000a3	03		 DB	 3
  000a4	03		 DB	 3
  000a5	01		 DB	 1
  000a6	03		 DB	 3
  000a7	03		 DB	 3
  000a8	03		 DB	 3
  000a9	03		 DB	 3
  000aa	03		 DB	 3
  000ab	03		 DB	 3
  000ac	03		 DB	 3
  000ad	03		 DB	 3
  000ae	02		 DB	 2
  000af	02		 DB	 2
  000b0	02		 DB	 2
  000b1	02		 DB	 2
  000b2	02		 DB	 2
  000b3	02		 DB	 2
  000b4	02		 DB	 2
  000b5	02		 DB	 2
  000b6	03		 DB	 3
  000b7	03		 DB	 3
  000b8	03		 DB	 3
  000b9	03		 DB	 3
  000ba	03		 DB	 3
  000bb	03		 DB	 3
  000bc	03		 DB	 3
  000bd	03		 DB	 3
  000be	03		 DB	 3
  000bf	03		 DB	 3
  000c0	03		 DB	 3
  000c1	03		 DB	 3
  000c2	03		 DB	 3
  000c3	03		 DB	 3
  000c4	03		 DB	 3
  000c5	03		 DB	 3
  000c6	03		 DB	 3
  000c7	03		 DB	 3
  000c8	03		 DB	 3
  000c9	03		 DB	 3
  000ca	03		 DB	 3
  000cb	03		 DB	 3
  000cc	02		 DB	 2
  000cd	03		 DB	 3
  000ce	03		 DB	 3
  000cf	03		 DB	 3
  000d0	03		 DB	 3
  000d1	03		 DB	 3
  000d2	03		 DB	 3
  000d3	02		 DB	 2
  000d4	03		 DB	 3
  000d5	03		 DB	 3
  000d6	03		 DB	 3
  000d7	03		 DB	 3
  000d8	03		 DB	 3
  000d9	03		 DB	 3
  000da	01		 DB	 1
  000db	03		 DB	 3
  000dc	03		 DB	 3
  000dd	03		 DB	 3
  000de	03		 DB	 3
  000df	01		 DB	 1
  000e0	01		 DB	 1
  000e1	03		 DB	 3
  000e2	03		 DB	 3
  000e3	03		 DB	 3
  000e4	01		 DB	 1
  000e5	03		 DB	 3
  000e6	03		 DB	 3
  000e7	03		 DB	 3
  000e8	03		 DB	 3
  000e9	03		 DB	 3
  000ea	03		 DB	 3
  000eb	03		 DB	 3
  000ec	01		 DB	 1
  000ed	03		 DB	 3
  000ee	03		 DB	 3
  000ef	03		 DB	 3
  000f0	01		 DB	 1
  000f1	03		 DB	 3
  000f2	01		 DB	 1
  000f3	02		 DB	 2
  000f4	01		 DB	 1
  000f5	03		 DB	 3
  000f6	02		 DB	 2
length_of_escaped_ascii_string ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsUnicodeEscapeString
EXTRN	Py_hexdigits:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_AsUnicodeEscapeString DD imagerel $LN46
	DD	imagerel $LN46+812
	DD	imagerel $unwind$PyUnicode_AsUnicodeEscapeString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_AsUnicodeEscapeString DD 085301H
	DD	0a7453H
	DD	09544aH
	DD	0c0053209H
	DD	030026003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_AsUnicodeEscapeString
_TEXT	SEGMENT
repr$ = 64
unicode$ = 64
PyUnicode_AsUnicodeEscapeString PROC			; COMDAT

; 5866 : {

$LN46:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	41 54		 push	 r12
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5867 :     Py_ssize_t i, len;
; 5868 :     PyObject *repr;
; 5869 :     char *p;
; 5870 :     int kind;
; 5871 :     void *data;
; 5872 :     Py_ssize_t expandsize = 0;
; 5873 : 
; 5874 :     /* Initial allocation is based on the longest-possible character
; 5875 :        escape.
; 5876 : 
; 5877 :        For UCS1 strings it's '\xxx', 4 bytes per source character.
; 5878 :        For UCS2 strings it's '\uxxxx', 6 bytes per source character.
; 5879 :        For UCS4 strings it's '\U00xxxxxx', 10 bytes per source character.
; 5880 :     */
; 5881 : 
; 5882 :     if (!PyUnicode_Check(unicode)) {

  00009	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000d	45 33 e4	 xor	 r12d, r12d
  00010	48 8b d9	 mov	 rbx, rcx
  00013	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0001d	41 8b f4	 mov	 esi, r12d
  00020	75 10		 jne	 SHORT $LN28@PyUnicode_@23

; 5883 :         PyErr_BadArgument();

  00022	e8 00 00 00 00	 call	 PyErr_BadArgument
$LN45@PyUnicode_@23:

; 5884 :         return NULL;

  00027	33 c0		 xor	 eax, eax

; 5977 :         return NULL;
; 5978 :     return repr;
; 5979 : }

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	41 5c		 pop	 r12
  0002f	5e		 pop	 rsi
  00030	5b		 pop	 rbx
  00031	c3		 ret	 0
$LN28@PyUnicode_@23:

; 5885 :     }
; 5886 :     if (PyUnicode_READY(unicode) == -1)

  00032	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00036	75 0a		 jne	 SHORT $LN27@PyUnicode_@23
  00038	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0003d	83 f8 ff	 cmp	 eax, -1

; 5887 :         return NULL;

  00040	74 e5		 je	 SHORT $LN45@PyUnicode_@23
$LN27@PyUnicode_@23:

; 5888 :     len = PyUnicode_GET_LENGTH(unicode);
; 5889 :     kind = PyUnicode_KIND(unicode);

  00042	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00045	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  0004a	48 8b 6b 60	 mov	 rbp, QWORD PTR [rbx+96]
  0004e	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00053	8b f8		 mov	 edi, eax
  00055	c1 ef 02	 shr	 edi, 2
  00058	83 e7 07	 and	 edi, 7

; 5890 :     data = PyUnicode_DATA(unicode);

  0005b	a8 20		 test	 al, 32			; 00000020H
  0005d	74 13		 je	 SHORT $LN35@PyUnicode_@23
  0005f	a8 40		 test	 al, 64			; 00000040H
  00061	74 06		 je	 SHORT $LN33@PyUnicode_@23
  00063	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  00067	eb 10		 jmp	 SHORT $LN36@PyUnicode_@23
$LN33@PyUnicode_@23:
  00069	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  00070	eb 07		 jmp	 SHORT $LN36@PyUnicode_@23
$LN35@PyUnicode_@23:
  00072	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
$LN36@PyUnicode_@23:

; 5891 :     switch (kind) {

  00079	8b cf		 mov	 ecx, edi
  0007b	ff c9		 dec	 ecx
  0007d	74 15		 je	 SHORT $LN24@PyUnicode_@23
  0007f	ff c9		 dec	 ecx
  00081	74 0a		 je	 SHORT $LN23@PyUnicode_@23
  00083	83 f9 02	 cmp	 ecx, 2
  00086	75 11		 jne	 SHORT $LN25@PyUnicode_@23

; 5894 :     case PyUnicode_4BYTE_KIND: expandsize = 10; break;

  00088	8d 71 08	 lea	 esi, QWORD PTR [rcx+8]
  0008b	eb 0c		 jmp	 SHORT $LN25@PyUnicode_@23
$LN23@PyUnicode_@23:

; 5893 :     case PyUnicode_2BYTE_KIND: expandsize = 6; break;

  0008d	be 06 00 00 00	 mov	 esi, 6
  00092	eb 05		 jmp	 SHORT $LN25@PyUnicode_@23
$LN24@PyUnicode_@23:

; 5892 :     case PyUnicode_1BYTE_KIND: expandsize = 4; break;

  00094	be 04 00 00 00	 mov	 esi, 4
$LN25@PyUnicode_@23:

; 5895 :     }
; 5896 : 
; 5897 :     if (len == 0)

  00099	48 85 ed	 test	 rbp, rbp
  0009c	75 0e		 jne	 SHORT $LN21@PyUnicode_@23

; 5898 :         return PyBytes_FromStringAndSize(NULL, 0);

  0009e	33 d2		 xor	 edx, edx
  000a0	33 c9		 xor	 ecx, ecx
  000a2	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000a7	e9 6d 02 00 00	 jmp	 $LN44@PyUnicode_@23
$LN21@PyUnicode_@23:

; 5899 : 
; 5900 :     if (len > (PY_SSIZE_T_MAX - 2 - 1) / expandsize)

  000ac	48 b8 fc ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775804 ; 7ffffffffffffffcH
  000b6	48 99		 cdq
  000b8	48 f7 fe	 idiv	 rsi
  000bb	48 3b e8	 cmp	 rbp, rax
  000be	7e 0a		 jle	 SHORT $LN20@PyUnicode_@23

; 5901 :         return PyErr_NoMemory();

  000c0	e8 00 00 00 00	 call	 PyErr_NoMemory
  000c5	e9 4f 02 00 00	 jmp	 $LN44@PyUnicode_@23
$LN20@PyUnicode_@23:

; 5902 : 
; 5903 :     repr = PyBytes_FromStringAndSize(NULL,
; 5904 :                                      2
; 5905 :                                      + expandsize*len
; 5906 :                                      + 1);

  000ca	48 8b d5	 mov	 rdx, rbp
  000cd	33 c9		 xor	 ecx, ecx
  000cf	48 0f af d6	 imul	 rdx, rsi
  000d3	48 83 c2 03	 add	 rdx, 3
  000d7	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000dc	48 89 44 24 40	 mov	 QWORD PTR repr$[rsp], rax

; 5907 :     if (repr == NULL)

  000e1	48 85 c0	 test	 rax, rax
  000e4	0f 84 2f 02 00
	00		 je	 $LN44@PyUnicode_@23
$LN19@PyUnicode_@23:

; 5908 :         return NULL;
; 5909 : 
; 5910 :     p = PyBytes_AS_STRING(repr);

  000ea	4c 8d 40 78	 lea	 r8, QWORD PTR [rax+120]

; 5911 : 
; 5912 :     for (i = 0; i < len; i++) {

  000ee	4d 8b cc	 mov	 r9, r12

; 5913 :         Py_UCS4 ch = PyUnicode_READ(kind, data, i);

  000f1	4c 63 d7	 movsxd	 r10, edi
  000f4	48 85 ed	 test	 rbp, rbp
  000f7	0f 8e fd 01 00
	00		 jle	 $LN16@PyUnicode_@23
  000fd	0f 1f 00	 npad	 3
$LL18@PyUnicode_@23:
  00100	49 83 fa 01	 cmp	 r10, 1
  00104	75 07		 jne	 SHORT $LN39@PyUnicode_@23
  00106	41 0f b6 0c 19	 movzx	 ecx, BYTE PTR [r9+rbx]
  0010b	eb 11		 jmp	 SHORT $LN38@PyUnicode_@23
$LN39@PyUnicode_@23:
  0010d	49 83 fa 02	 cmp	 r10, 2
  00111	75 07		 jne	 SHORT $LN37@PyUnicode_@23
  00113	42 0f b7 0c 4b	 movzx	 ecx, WORD PTR [rbx+r9*2]
  00118	eb 04		 jmp	 SHORT $LN38@PyUnicode_@23
$LN37@PyUnicode_@23:
  0011a	42 8b 0c 8b	 mov	 ecx, DWORD PTR [rbx+r9*4]
$LN38@PyUnicode_@23:

; 5914 : 
; 5915 :         /* Escape backslashes */
; 5916 :         if (ch == '\\') {

  0011e	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  00121	75 0f		 jne	 SHORT $LN15@PyUnicode_@23

; 5917 :             *p++ = '\\';

  00123	66 41 c7 00 5c
	5c		 mov	 WORD PTR [r8], 23644	; 00005c5cH

; 5918 :             *p++ = (char) ch;

  00129	49 83 c0 02	 add	 r8, 2

; 5919 :             continue;

  0012d	e9 b7 01 00 00	 jmp	 $LN17@PyUnicode_@23
$LN15@PyUnicode_@23:

; 5920 :         }
; 5921 : 
; 5922 :         /* Map 21-bit characters to '\U00xxxxxx' */
; 5923 :         else if (ch >= 0x10000) {

  00132	81 f9 00 00 01
	00		 cmp	 ecx, 65536		; 00010000H
  00138	0f 82 c6 00 00
	00		 jb	 $LN13@PyUnicode_@23

; 5924 :             assert(ch <= MAX_UNICODE);
; 5925 :             *p++ = '\\';
; 5926 :             *p++ = 'U';
; 5927 :             *p++ = Py_hexdigits[(ch >> 28) & 0x0000000F];

  0013e	8b d1		 mov	 edx, ecx
  00140	48 c1 e9 1c	 shr	 rcx, 28
  00144	66 41 c7 00 5c
	55		 mov	 WORD PTR [r8], 21852	; 0000555cH
  0014a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00151	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00155	41 88 48 02	 mov	 BYTE PTR [r8+2], cl

; 5928 :             *p++ = Py_hexdigits[(ch >> 24) & 0x0000000F];

  00159	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00160	8b ca		 mov	 ecx, edx
  00162	48 c1 e9 18	 shr	 rcx, 24
  00166	83 e1 0f	 and	 ecx, 15
  00169	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0016d	41 88 48 03	 mov	 BYTE PTR [r8+3], cl

; 5929 :             *p++ = Py_hexdigits[(ch >> 20) & 0x0000000F];

  00171	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00178	8b ca		 mov	 ecx, edx
  0017a	48 c1 e9 14	 shr	 rcx, 20
  0017e	83 e1 0f	 and	 ecx, 15
  00181	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00185	41 88 48 04	 mov	 BYTE PTR [r8+4], cl

; 5930 :             *p++ = Py_hexdigits[(ch >> 16) & 0x0000000F];

  00189	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00190	8b ca		 mov	 ecx, edx
  00192	48 c1 e9 10	 shr	 rcx, 16
  00196	83 e1 0f	 and	 ecx, 15
  00199	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0019d	41 88 48 05	 mov	 BYTE PTR [r8+5], cl

; 5931 :             *p++ = Py_hexdigits[(ch >> 12) & 0x0000000F];

  001a1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  001a8	8b ca		 mov	 ecx, edx
  001aa	48 c1 e9 0c	 shr	 rcx, 12
  001ae	83 e1 0f	 and	 ecx, 15
  001b1	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  001b5	41 88 48 06	 mov	 BYTE PTR [r8+6], cl

; 5932 :             *p++ = Py_hexdigits[(ch >> 8) & 0x0000000F];

  001b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  001c0	8b ca		 mov	 ecx, edx
  001c2	48 c1 e9 08	 shr	 rcx, 8
  001c6	83 e1 0f	 and	 ecx, 15
  001c9	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  001cd	41 88 48 07	 mov	 BYTE PTR [r8+7], cl

; 5933 :             *p++ = Py_hexdigits[(ch >> 4) & 0x0000000F];

  001d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  001d8	8b ca		 mov	 ecx, edx
  001da	48 c1 e9 04	 shr	 rcx, 4

; 5934 :             *p++ = Py_hexdigits[ch & 0x0000000F];

  001de	83 e2 0f	 and	 edx, 15
  001e1	83 e1 0f	 and	 ecx, 15
  001e4	49 83 c0 0a	 add	 r8, 10
  001e8	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  001ec	41 88 48 fe	 mov	 BYTE PTR [r8-2], cl
  001f0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  001f7	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  001fb	41 88 48 ff	 mov	 BYTE PTR [r8-1], cl

; 5935 :             continue;

  001ff	e9 e5 00 00 00	 jmp	 $LN17@PyUnicode_@23
$LN13@PyUnicode_@23:

; 5936 :         }
; 5937 : 
; 5938 :         /* Map 16-bit characters to '\uxxxx' */
; 5939 :         if (ch >= 256) {

  00204	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  0020a	72 66		 jb	 SHORT $LN12@PyUnicode_@23

; 5940 :             *p++ = '\\';

  0020c	66 41 c7 00 5c
	75		 mov	 WORD PTR [r8], 30044	; 0000755cH

; 5941 :             *p++ = 'u';
; 5942 :             *p++ = Py_hexdigits[(ch >> 12) & 0x000F];

  00212	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00219	8b d1		 mov	 edx, ecx
  0021b	48 c1 e9 0c	 shr	 rcx, 12
  0021f	83 e1 0f	 and	 ecx, 15
  00222	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00226	41 88 48 02	 mov	 BYTE PTR [r8+2], cl

; 5943 :             *p++ = Py_hexdigits[(ch >> 8) & 0x000F];

  0022a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00231	8b ca		 mov	 ecx, edx
  00233	48 c1 e9 08	 shr	 rcx, 8
  00237	83 e1 0f	 and	 ecx, 15
  0023a	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0023e	41 88 48 03	 mov	 BYTE PTR [r8+3], cl

; 5944 :             *p++ = Py_hexdigits[(ch >> 4) & 0x000F];

  00242	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00249	8b ca		 mov	 ecx, edx
  0024b	48 c1 e9 04	 shr	 rcx, 4

; 5945 :             *p++ = Py_hexdigits[ch & 0x000F];

  0024f	83 e2 0f	 and	 edx, 15
  00252	83 e1 0f	 and	 ecx, 15
  00255	49 83 c0 06	 add	 r8, 6
  00259	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0025d	41 88 48 fe	 mov	 BYTE PTR [r8-2], cl
  00261	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00268	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  0026c	41 88 48 ff	 mov	 BYTE PTR [r8-1], cl
  00270	eb 77		 jmp	 SHORT $LN17@PyUnicode_@23
$LN12@PyUnicode_@23:

; 5946 :         }
; 5947 : 
; 5948 :         /* Map special whitespace to '\t', \n', '\r' */
; 5949 :         else if (ch == '\t') {

  00272	83 f9 09	 cmp	 ecx, 9
  00275	75 0c		 jne	 SHORT $LN10@PyUnicode_@23

; 5950 :             *p++ = '\\';

  00277	66 41 c7 00 5c
	74		 mov	 WORD PTR [r8], 29788	; 0000745cH

; 5951 :             *p++ = 't';

  0027d	49 83 c0 02	 add	 r8, 2
  00281	eb 66		 jmp	 SHORT $LN17@PyUnicode_@23
$LN10@PyUnicode_@23:

; 5952 :         }
; 5953 :         else if (ch == '\n') {

  00283	83 f9 0a	 cmp	 ecx, 10
  00286	75 0c		 jne	 SHORT $LN8@PyUnicode_@23

; 5954 :             *p++ = '\\';

  00288	66 41 c7 00 5c
	6e		 mov	 WORD PTR [r8], 28252	; 00006e5cH

; 5955 :             *p++ = 'n';

  0028e	49 83 c0 02	 add	 r8, 2
  00292	eb 55		 jmp	 SHORT $LN17@PyUnicode_@23
$LN8@PyUnicode_@23:

; 5956 :         }
; 5957 :         else if (ch == '\r') {

  00294	83 f9 0d	 cmp	 ecx, 13
  00297	75 0c		 jne	 SHORT $LN6@PyUnicode_@23

; 5958 :             *p++ = '\\';

  00299	66 41 c7 00 5c
	72		 mov	 WORD PTR [r8], 29276	; 0000725cH

; 5959 :             *p++ = 'r';

  0029f	49 83 c0 02	 add	 r8, 2
  002a3	eb 44		 jmp	 SHORT $LN17@PyUnicode_@23
$LN6@PyUnicode_@23:

; 5960 :         }
; 5961 : 
; 5962 :         /* Map non-printable US ASCII to '\xhh' */
; 5963 :         else if (ch < ' ' || ch >= 0x7F) {

  002a5	8d 41 e0	 lea	 eax, DWORD PTR [rcx-32]
  002a8	83 f8 5e	 cmp	 eax, 94			; 0000005eH
  002ab	77 08		 ja	 SHORT $LN3@PyUnicode_@23

; 5968 :         }
; 5969 : 
; 5970 :         /* Copy everything else as-is */
; 5971 :         else
; 5972 :             *p++ = (char) ch;

  002ad	41 88 08	 mov	 BYTE PTR [r8], cl
  002b0	49 ff c0	 inc	 r8
  002b3	eb 34		 jmp	 SHORT $LN17@PyUnicode_@23
$LN3@PyUnicode_@23:

; 5964 :             *p++ = '\\';

  002b5	66 41 c7 00 5c
	78		 mov	 WORD PTR [r8], 30812	; 0000785cH

; 5965 :             *p++ = 'x';
; 5966 :             *p++ = Py_hexdigits[(ch >> 4) & 0x000F];

  002bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  002c2	8b d1		 mov	 edx, ecx
  002c4	48 c1 e9 04	 shr	 rcx, 4

; 5967 :             *p++ = Py_hexdigits[ch & 0x000F];

  002c8	83 e2 0f	 and	 edx, 15
  002cb	83 e1 0f	 and	 ecx, 15
  002ce	49 83 c0 04	 add	 r8, 4
  002d2	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  002d6	41 88 48 fe	 mov	 BYTE PTR [r8-2], cl
  002da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  002e1	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  002e5	41 88 48 ff	 mov	 BYTE PTR [r8-1], cl
$LN17@PyUnicode_@23:

; 5911 : 
; 5912 :     for (i = 0; i < len; i++) {

  002e9	49 ff c1	 inc	 r9
  002ec	4c 3b cd	 cmp	 r9, rbp
  002ef	0f 8c 0b fe ff
	ff		 jl	 $LL18@PyUnicode_@23
  002f5	48 8b 44 24 40	 mov	 rax, QWORD PTR repr$[rsp]
$LN16@PyUnicode_@23:

; 5973 :     }
; 5974 : 
; 5975 :     assert(p - PyBytes_AS_STRING(repr) > 0);
; 5976 :     if (_PyBytes_Resize(&repr, p - PyBytes_AS_STRING(repr)) < 0)

  002fa	4c 2b c0	 sub	 r8, rax
  002fd	48 8d 4c 24 40	 lea	 rcx, QWORD PTR repr$[rsp]
  00302	49 8d 50 88	 lea	 rdx, QWORD PTR [r8-120]
  00306	e8 00 00 00 00	 call	 _PyBytes_Resize
  0030b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR repr$[rsp]
  00310	85 c0		 test	 eax, eax
  00312	49 0f 48 cc	 cmovs	 rcx, r12
  00316	48 8b c1	 mov	 rax, rcx
$LN44@PyUnicode_@23:
  00319	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0031e	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 5977 :         return NULL;
; 5978 :     return repr;
; 5979 : }

  00323	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00327	41 5c		 pop	 r12
  00329	5e		 pop	 rsi
  0032a	5b		 pop	 rbx
  0032b	c3		 ret	 0
PyUnicode_AsUnicodeEscapeString ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsRawUnicodeEscapeString
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_AsRawUnicodeEscapeString DD imagerel $LN31
	DD	imagerel $LN31+57
	DD	imagerel $unwind$PyUnicode_AsRawUnicodeEscapeString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyUnicode_AsRawUnicodeEscapeString DD imagerel $LN31+57
	DD	imagerel $LN31+160
	DD	imagerel $chain$1$PyUnicode_AsRawUnicodeEscapeString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyUnicode_AsRawUnicodeEscapeString DD imagerel $LN31+160
	DD	imagerel $LN31+200
	DD	imagerel $chain$3$PyUnicode_AsRawUnicodeEscapeString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyUnicode_AsRawUnicodeEscapeString DD imagerel $LN31+200
	DD	imagerel $LN31+213
	DD	imagerel $chain$5$PyUnicode_AsRawUnicodeEscapeString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$PyUnicode_AsRawUnicodeEscapeString DD imagerel $LN31+213
	DD	imagerel $LN31+642
	DD	imagerel $chain$6$PyUnicode_AsRawUnicodeEscapeString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$PyUnicode_AsRawUnicodeEscapeString DD imagerel $LN31+642
	DD	imagerel $LN31+658
	DD	imagerel $chain$7$PyUnicode_AsRawUnicodeEscapeString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$PyUnicode_AsRawUnicodeEscapeString DD 021H
	DD	imagerel $LN31+200
	DD	imagerel $LN31+213
	DD	imagerel $chain$5$PyUnicode_AsRawUnicodeEscapeString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$PyUnicode_AsRawUnicodeEscapeString DD 020521H
	DD	085405H
	DD	imagerel $LN31+200
	DD	imagerel $LN31+213
	DD	imagerel $chain$5$PyUnicode_AsRawUnicodeEscapeString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyUnicode_AsRawUnicodeEscapeString DD 040021H
	DD	096400H
	DD	073400H
	DD	imagerel $LN31
	DD	imagerel $LN31+57
	DD	imagerel $unwind$PyUnicode_AsRawUnicodeEscapeString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyUnicode_AsRawUnicodeEscapeString DD 040021H
	DD	096400H
	DD	073400H
	DD	imagerel $LN31
	DD	imagerel $LN31+57
	DD	imagerel $unwind$PyUnicode_AsRawUnicodeEscapeString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyUnicode_AsRawUnicodeEscapeString DD 040a21H
	DD	09640aH
	DD	073405H
	DD	imagerel $LN31
	DD	imagerel $LN31+57
	DD	imagerel $unwind$PyUnicode_AsRawUnicodeEscapeString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_AsRawUnicodeEscapeString DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_AsRawUnicodeEscapeString
_TEXT	SEGMENT
repr$ = 48
unicode$ = 48
PyUnicode_AsRawUnicodeEscapeString PROC			; COMDAT

; 6106 : {

$LN31:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 6107 :     PyObject *repr;
; 6108 :     char *p;
; 6109 :     char *q;
; 6110 :     Py_ssize_t expandsize, pos;
; 6111 :     int kind;
; 6112 :     void *data;
; 6113 :     Py_ssize_t len;
; 6114 : 
; 6115 :     if (!PyUnicode_Check(unicode)) {

  00006	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00017	75 0d		 jne	 SHORT $LN13@PyUnicode_@24

; 6116 :         PyErr_BadArgument();

  00019	e8 00 00 00 00	 call	 PyErr_BadArgument
$LN30@PyUnicode_@24:

; 6117 :         return NULL;

  0001e	33 c0		 xor	 eax, eax

; 6170 :         return NULL;
; 6171 :     return repr;
; 6172 : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5f		 pop	 rdi
  00025	c3		 ret	 0
$LN13@PyUnicode_@24:

; 6118 :     }
; 6119 :     if (PyUnicode_READY(unicode) == -1)

  00026	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0002a	75 0a		 jne	 SHORT $LN12@PyUnicode_@24
  0002c	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00031	83 f8 ff	 cmp	 eax, -1

; 6120 :         return NULL;

  00034	74 e8		 je	 SHORT $LN30@PyUnicode_@24
$LN12@PyUnicode_@24:

; 6121 :     kind = PyUnicode_KIND(unicode);

  00036	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00039	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  0003e	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00043	8b f0		 mov	 esi, eax
  00045	c1 ee 02	 shr	 esi, 2
  00048	83 e6 07	 and	 esi, 7

; 6122 :     data = PyUnicode_DATA(unicode);

  0004b	a8 20		 test	 al, 32			; 00000020H
  0004d	74 16		 je	 SHORT $LN20@PyUnicode_@24
  0004f	a8 40		 test	 al, 64			; 00000040H
  00051	74 09		 je	 SHORT $LN18@PyUnicode_@24
  00053	48 8d 9f 80 00
	00 00		 lea	 rbx, QWORD PTR [rdi+128]
  0005a	eb 10		 jmp	 SHORT $LN21@PyUnicode_@24
$LN18@PyUnicode_@24:
  0005c	48 8d 9f a0 00
	00 00		 lea	 rbx, QWORD PTR [rdi+160]
  00063	eb 07		 jmp	 SHORT $LN21@PyUnicode_@24
$LN20@PyUnicode_@24:
  00065	48 8b 9f a0 00
	00 00		 mov	 rbx, QWORD PTR [rdi+160]
$LN21@PyUnicode_@24:

; 6123 :     len = PyUnicode_GET_LENGTH(unicode);

  0006c	48 8b 7f 60	 mov	 rdi, QWORD PTR [rdi+96]

; 6124 :     /* 4 byte characters can take up 10 bytes, 2 byte characters can take up 6
; 6125 :        bytes, and 1 byte characters 4. */
; 6126 :     expandsize = kind * 2 + 2;

  00070	8d 44 36 02	 lea	 eax, DWORD PTR [rsi+rsi+2]
  00074	48 63 c8	 movsxd	 rcx, eax

; 6127 : 
; 6128 :     if (len > PY_SSIZE_T_MAX / expandsize)

  00077	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00081	48 99		 cdq
  00083	48 f7 f9	 idiv	 rcx
  00086	48 3b f8	 cmp	 rdi, rax
  00089	7e 15		 jle	 SHORT $LN11@PyUnicode_@24

; 6129 :         return PyErr_NoMemory();

  0008b	e8 00 00 00 00	 call	 PyErr_NoMemory
  00090	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00095	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 6170 :         return NULL;
; 6171 :     return repr;
; 6172 : }

  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
$LN11@PyUnicode_@24:

; 6130 : 
; 6131 :     repr = PyBytes_FromStringAndSize(NULL, expandsize * len);

  000a0	48 0f af cf	 imul	 rcx, rdi
  000a4	48 8b d1	 mov	 rdx, rcx
  000a7	33 c9		 xor	 ecx, ecx
  000a9	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000ae	48 89 44 24 30	 mov	 QWORD PTR repr$[rsp], rax

; 6132 :     if (repr == NULL)

  000b3	48 85 c0	 test	 rax, rax
  000b6	75 10		 jne	 SHORT $LN10@PyUnicode_@24
  000b8	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000bd	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 6170 :         return NULL;
; 6171 :     return repr;
; 6172 : }

  000c2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c6	5f		 pop	 rdi
  000c7	c3		 ret	 0
$LN10@PyUnicode_@24:

; 6133 :         return NULL;
; 6134 :     if (len == 0)

  000c8	48 85 ff	 test	 rdi, rdi

; 6135 :         return repr;

  000cb	0f 84 b1 01 00
	00		 je	 $LN29@PyUnicode_@24

; 6136 : 
; 6137 :     p = q = PyBytes_AS_STRING(repr);

  000d1	4c 8d 58 78	 lea	 r11, QWORD PTR [rax+120]
  000d5	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp

; 6138 :     for (pos = 0; pos < len; pos++) {

  000da	33 ed		 xor	 ebp, ebp

; 6139 :         Py_UCS4 ch = PyUnicode_READ(kind, data, pos);

  000dc	4c 63 d6	 movsxd	 r10, esi
  000df	4d 8b c3	 mov	 r8, r11
  000e2	44 8b cd	 mov	 r9d, ebp
  000e5	48 85 ff	 test	 rdi, rdi
  000e8	0f 8e 71 01 00
	00		 jle	 $LN6@PyUnicode_@24
  000ee	66 90		 npad	 2
$LL8@PyUnicode_@24:
  000f0	49 83 fa 01	 cmp	 r10, 1
  000f4	75 07		 jne	 SHORT $LN24@PyUnicode_@24
  000f6	41 0f b6 04 19	 movzx	 eax, BYTE PTR [r9+rbx]
  000fb	eb 11		 jmp	 SHORT $LN23@PyUnicode_@24
$LN24@PyUnicode_@24:
  000fd	49 83 fa 02	 cmp	 r10, 2
  00101	75 07		 jne	 SHORT $LN22@PyUnicode_@24
  00103	42 0f b7 04 4b	 movzx	 eax, WORD PTR [rbx+r9*2]
  00108	eb 04		 jmp	 SHORT $LN23@PyUnicode_@24
$LN22@PyUnicode_@24:
  0010a	42 8b 04 8b	 mov	 eax, DWORD PTR [rbx+r9*4]
$LN23@PyUnicode_@24:

; 6140 :         /* Map 32-bit characters to '\Uxxxxxxxx' */
; 6141 :         if (ch >= 0x10000) {

  0010e	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
  00113	0f 82 c5 00 00
	00		 jb	 $LN5@PyUnicode_@24

; 6142 :             assert(ch <= MAX_UNICODE);
; 6143 :             *p++ = '\\';

  00119	66 41 c7 00 5c
	55		 mov	 WORD PTR [r8], 21852	; 0000555cH

; 6144 :             *p++ = 'U';
; 6145 :             *p++ = Py_hexdigits[(ch >> 28) & 0xf];

  0011f	8b d0		 mov	 edx, eax
  00121	8b c8		 mov	 ecx, eax
  00123	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  0012a	48 c1 e9 1c	 shr	 rcx, 28
  0012e	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00132	41 88 48 02	 mov	 BYTE PTR [r8+2], cl

; 6146 :             *p++ = Py_hexdigits[(ch >> 24) & 0xf];

  00136	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  0013d	8b ca		 mov	 ecx, edx
  0013f	48 c1 e9 18	 shr	 rcx, 24
  00143	83 e1 0f	 and	 ecx, 15
  00146	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0014a	41 88 48 03	 mov	 BYTE PTR [r8+3], cl

; 6147 :             *p++ = Py_hexdigits[(ch >> 20) & 0xf];

  0014e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00155	8b ca		 mov	 ecx, edx
  00157	48 c1 e9 14	 shr	 rcx, 20
  0015b	83 e1 0f	 and	 ecx, 15
  0015e	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00162	41 88 48 04	 mov	 BYTE PTR [r8+4], cl

; 6148 :             *p++ = Py_hexdigits[(ch >> 16) & 0xf];

  00166	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  0016d	8b ca		 mov	 ecx, edx
  0016f	48 c1 e9 10	 shr	 rcx, 16
  00173	83 e1 0f	 and	 ecx, 15
  00176	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0017a	41 88 48 05	 mov	 BYTE PTR [r8+5], cl

; 6149 :             *p++ = Py_hexdigits[(ch >> 12) & 0xf];

  0017e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00185	8b ca		 mov	 ecx, edx
  00187	48 c1 e9 0c	 shr	 rcx, 12
  0018b	83 e1 0f	 and	 ecx, 15
  0018e	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00192	41 88 48 06	 mov	 BYTE PTR [r8+6], cl

; 6150 :             *p++ = Py_hexdigits[(ch >> 8) & 0xf];

  00196	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  0019d	8b ca		 mov	 ecx, edx
  0019f	48 c1 e9 08	 shr	 rcx, 8
  001a3	83 e1 0f	 and	 ecx, 15
  001a6	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  001aa	41 88 48 07	 mov	 BYTE PTR [r8+7], cl

; 6151 :             *p++ = Py_hexdigits[(ch >> 4) & 0xf];

  001ae	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  001b5	8b ca		 mov	 ecx, edx
  001b7	48 c1 e9 04	 shr	 rcx, 4

; 6152 :             *p++ = Py_hexdigits[ch & 15];

  001bb	83 e2 0f	 and	 edx, 15
  001be	83 e1 0f	 and	 ecx, 15
  001c1	49 83 c0 0a	 add	 r8, 10
  001c5	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  001c9	41 88 48 fe	 mov	 BYTE PTR [r8-2], cl
  001cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  001d4	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  001d8	41 88 48 ff	 mov	 BYTE PTR [r8-1], cl
  001dc	eb 75		 jmp	 SHORT $LN7@PyUnicode_@24
$LN5@PyUnicode_@24:

; 6153 :         }
; 6154 :         /* Map 16-bit characters to '\uxxxx' */
; 6155 :         else if (ch >= 256) {

  001de	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  001e3	72 68		 jb	 SHORT $LN3@PyUnicode_@24

; 6156 :             *p++ = '\\';

  001e5	66 41 c7 00 5c
	75		 mov	 WORD PTR [r8], 30044	; 0000755cH

; 6157 :             *p++ = 'u';
; 6158 :             *p++ = Py_hexdigits[(ch >> 12) & 0xf];

  001eb	8b d0		 mov	 edx, eax
  001ed	8b c8		 mov	 ecx, eax
  001ef	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  001f6	48 c1 e9 0c	 shr	 rcx, 12
  001fa	83 e1 0f	 and	 ecx, 15
  001fd	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00201	41 88 48 02	 mov	 BYTE PTR [r8+2], cl

; 6159 :             *p++ = Py_hexdigits[(ch >> 8) & 0xf];

  00205	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  0020c	8b ca		 mov	 ecx, edx
  0020e	48 c1 e9 08	 shr	 rcx, 8
  00212	83 e1 0f	 and	 ecx, 15
  00215	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00219	41 88 48 03	 mov	 BYTE PTR [r8+3], cl

; 6160 :             *p++ = Py_hexdigits[(ch >> 4) & 0xf];

  0021d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00224	8b ca		 mov	 ecx, edx
  00226	48 c1 e9 04	 shr	 rcx, 4

; 6161 :             *p++ = Py_hexdigits[ch & 15];

  0022a	83 e2 0f	 and	 edx, 15
  0022d	83 e1 0f	 and	 ecx, 15
  00230	49 83 c0 06	 add	 r8, 6
  00234	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00238	41 88 48 fe	 mov	 BYTE PTR [r8-2], cl
  0023c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00243	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  00247	41 88 48 ff	 mov	 BYTE PTR [r8-1], cl

; 6162 :         }
; 6163 :         /* Copy everything else as-is */
; 6164 :         else

  0024b	eb 06		 jmp	 SHORT $LN7@PyUnicode_@24
$LN3@PyUnicode_@24:

; 6165 :             *p++ = (char) ch;

  0024d	41 88 00	 mov	 BYTE PTR [r8], al
  00250	49 ff c0	 inc	 r8
$LN7@PyUnicode_@24:

; 6138 :     for (pos = 0; pos < len; pos++) {

  00253	49 ff c1	 inc	 r9
  00256	4c 3b cf	 cmp	 r9, rdi
  00259	0f 8c 91 fe ff
	ff		 jl	 $LL8@PyUnicode_@24
$LN6@PyUnicode_@24:

; 6166 :     }
; 6167 : 
; 6168 :     assert(p > q);
; 6169 :     if (_PyBytes_Resize(&repr, p - q) < 0)

  0025f	4d 2b c3	 sub	 r8, r11
  00262	48 8d 4c 24 30	 lea	 rcx, QWORD PTR repr$[rsp]
  00267	49 8b d0	 mov	 rdx, r8
  0026a	e8 00 00 00 00	 call	 _PyBytes_Resize
  0026f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR repr$[rsp]
  00274	85 c0		 test	 eax, eax
  00276	48 0f 48 cd	 cmovs	 rcx, rbp
  0027a	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0027f	48 8b c1	 mov	 rax, rcx
$LN29@PyUnicode_@24:
  00282	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00287	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 6170 :         return NULL;
; 6171 :     return repr;
; 6172 : }

  0028c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00290	5f		 pop	 rdi
  00291	c3		 ret	 0
PyUnicode_AsRawUnicodeEscapeString ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_DecodeLatin1
; Function compile flags: /Ogtpy
;	COMDAT PyUnicode_DecodeLatin1
_TEXT	SEGMENT
s$ = 8
size$ = 16
errors$ = 24
PyUnicode_DecodeLatin1 PROC				; COMDAT

; 6293 :     /* Latin-1 is equivalent to the first 256 ordinals in Unicode. */
; 6294 :     return _PyUnicode_FromUCS1((unsigned char*)s, size);
; 6295 : }

  00000	e9 00 00 00 00	 jmp	 _PyUnicode_FromUCS1
PyUnicode_DecodeLatin1 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@LBJEDENG@make_encode_exception?$AA@	; `string'
PUBLIC	??_C@_05IEIKKCIE@sOnns?$AA@			; `string'
EXTRN	PyUnicodeEncodeError_SetReason:PROC
EXTRN	PyUnicodeEncodeError_SetEnd:PROC
EXTRN	PyUnicodeEncodeError_SetStart:PROC
EXTRN	_PyObject_CallFunction_SizeT:PROC
EXTRN	PyExc_UnicodeEncodeError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$make_encode_exception DD imagerel make_encode_exception
	DD	imagerel make_encode_exception+179
	DD	imagerel $unwind$make_encode_exception
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$make_encode_exception DD imagerel make_encode_exception+179
	DD	imagerel make_encode_exception+283
	DD	imagerel $chain$0$make_encode_exception
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$make_encode_exception DD imagerel make_encode_exception+283
	DD	imagerel make_encode_exception+304
	DD	imagerel $chain$2$make_encode_exception
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$make_encode_exception DD imagerel make_encode_exception+304
	DD	imagerel make_encode_exception+317
	DD	imagerel $chain$4$make_encode_exception
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$make_encode_exception DD imagerel make_encode_exception+317
	DD	imagerel make_encode_exception+323
	DD	imagerel $chain$5$make_encode_exception
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$make_encode_exception DD 021H
	DD	imagerel make_encode_exception
	DD	imagerel make_encode_exception+179
	DD	imagerel $unwind$make_encode_exception
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$make_encode_exception DD 020021H
	DD	0a3400H
	DD	imagerel make_encode_exception
	DD	imagerel make_encode_exception+179
	DD	imagerel $unwind$make_encode_exception
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$make_encode_exception DD 020021H
	DD	0a3400H
	DD	imagerel make_encode_exception
	DD	imagerel make_encode_exception+179
	DD	imagerel $unwind$make_encode_exception
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$make_encode_exception DD 020521H
	DD	0a3405H
	DD	imagerel make_encode_exception
	DD	imagerel make_encode_exception+179
	DD	imagerel $unwind$make_encode_exception
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$make_encode_exception DD 020601H
	DD	070027206H
xdata	ENDS
;	COMDAT ??_C@_0BG@LBJEDENG@make_encode_exception?$AA@
CONST	SEGMENT
??_C@_0BG@LBJEDENG@make_encode_exception?$AA@ DB 'make_encode_exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05IEIKKCIE@sOnns?$AA@
CONST	SEGMENT
??_C@_05IEIKKCIE@sOnns?$AA@ DB 'sOnns', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT make_encode_exception
_TEXT	SEGMENT
exceptionObject$ = 80
encoding$ = 88
unicode$ = 96
startpos$ = 104
endpos$ = 112
reason$ = 120
make_encode_exception PROC				; COMDAT

; 6304 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8b f9	 mov	 rdi, rcx

; 6305 :     if (*exceptionObject == NULL) {

  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	48 85 c9	 test	 rcx, rcx
  0000f	75 3b		 jne	 SHORT $LN9@make_encod

; 6306 :         *exceptionObject = PyObject_CallFunction(
; 6307 :             PyExc_UnicodeEncodeError, "sOnns",
; 6308 :             encoding, unicode, startpos, endpos, reason);

  00011	48 8b 44 24 78	 mov	 rax, QWORD PTR reason$[rsp]
  00016	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnicodeEncodeError
  0001d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00022	48 8b 44 24 70	 mov	 rax, QWORD PTR endpos$[rsp]
  00027	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0002c	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00031	4d 8b c8	 mov	 r9, r8
  00034	4c 8b c2	 mov	 r8, rdx
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05IEIKKCIE@sOnns?$AA@
  0003e	e8 00 00 00 00	 call	 _PyObject_CallFunction_SizeT
  00043	48 89 07	 mov	 QWORD PTR [rdi], rax

; 6320 :     }
; 6321 : }

  00046	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
$LN9@make_encod:

; 6309 :     }
; 6310 :     else {
; 6311 :         if (PyUnicodeEncodeError_SetStart(*exceptionObject, startpos))

  0004c	49 8b d1	 mov	 rdx, r9
  0004f	e8 00 00 00 00	 call	 PyUnicodeEncodeError_SetStart
  00054	85 c0		 test	 eax, eax
  00056	75 26		 jne	 SHORT $onError$132239

; 6312 :             goto onError;
; 6313 :         if (PyUnicodeEncodeError_SetEnd(*exceptionObject, endpos))

  00058	48 8b 54 24 70	 mov	 rdx, QWORD PTR endpos$[rsp]
  0005d	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00060	e8 00 00 00 00	 call	 PyUnicodeEncodeError_SetEnd
  00065	85 c0		 test	 eax, eax
  00067	75 15		 jne	 SHORT $onError$132239

; 6314 :             goto onError;
; 6315 :         if (PyUnicodeEncodeError_SetReason(*exceptionObject, reason))

  00069	48 8b 54 24 78	 mov	 rdx, QWORD PTR reason$[rsp]
  0006e	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00071	e8 00 00 00 00	 call	 PyUnicodeEncodeError_SetReason
  00076	85 c0		 test	 eax, eax
  00078	0f 84 bf 00 00
	00		 je	 $LN2@make_encod
$onError$132239:

; 6316 :             goto onError;
; 6317 :         return;
; 6318 :       onError:
; 6319 :         Py_CLEAR(*exceptionObject);

  0007e	4c 8b 0f	 mov	 r9, QWORD PTR [rdi]
  00081	4d 85 c9	 test	 r9, r9
  00084	0f 84 b3 00 00
	00		 je	 $LN2@make_encod
  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@LBJEDENG@make_encode_exception?$AA@
  00098	41 b8 af 18 00
	00		 mov	 r8d, 6319		; 000018afH
  0009e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000a6	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ab	85 c0		 test	 eax, eax
  000ad	0f 85 8a 00 00
	00		 jne	 $LN2@make_encod
  000b3	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  000b8	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  000bb	48 c7 07 00 00
	00 00		 mov	 QWORD PTR [rdi], 0
  000c2	e8 00 00 00 00	 call	 _Py_PXCTX
  000c7	85 c0		 test	 eax, eax
  000c9	75 6d		 jne	 SHORT $LN23@make_encod
  000cb	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000cf	a8 20		 test	 al, 32			; 00000020H
  000d1	75 5d		 jne	 SHORT $LN16@make_encod
  000d3	84 c0		 test	 al, al
  000d5	78 59		 js	 SHORT $LN16@make_encod
  000d7	a8 02		 test	 al, 2
  000d9	75 5d		 jne	 SHORT $LN23@make_encod
  000db	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000df	75 57		 jne	 SHORT $LN23@make_encod
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000ef	4c 8b cb	 mov	 r9, rbx
  000f2	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000f8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00100	e8 00 00 00 00	 call	 _PyParallel_Guard
  00105	48 8b cb	 mov	 rcx, rbx
  00108	85 c0		 test	 eax, eax
  0010a	74 0f		 je	 SHORT $LN21@make_encod
  0010c	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 6320 :     }
; 6321 : }

  00111	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00115	5f		 pop	 rdi
  00116	e9 00 00 00 00	 jmp	 _Px_Dealloc

; 6316 :             goto onError;
; 6317 :         return;
; 6318 :       onError:
; 6319 :         Py_CLEAR(*exceptionObject);

$LN21@make_encod:
  0011b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0011f	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 6320 :     }
; 6321 : }

  00124	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00128	5f		 pop	 rdi
  00129	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]

; 6316 :             goto onError;
; 6317 :         return;
; 6318 :       onError:
; 6319 :         Py_CLEAR(*exceptionObject);

$LN16@make_encod:
  00130	48 8b cb	 mov	 rcx, rbx
  00133	e8 00 00 00 00	 call	 Px_DecRef
$LN23@make_encod:
  00138	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
$LN2@make_encod:

; 6320 :     }
; 6321 : }

  0013d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00141	5f		 pop	 rdi
  00142	c3		 ret	 0
make_encode_exception ENDP
_TEXT	ENDS
EXTRN	PyCodec_StrictErrors:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$raise_encode_exception DD imagerel raise_encode_exception
	DD	imagerel raise_encode_exception+53
	DD	imagerel $unwind$raise_encode_exception
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$raise_encode_exception DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT raise_encode_exception
_TEXT	SEGMENT
exceptionObject$ = 64
encoding$ = 72
unicode$ = 80
startpos$ = 88
endpos$ = 96
reason$ = 104
raise_encode_exception PROC				; COMDAT

; 6330 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 6331 :     make_encode_exception(exceptionObject,
; 6332 :                           encoding, unicode, startpos, endpos, reason);

  00006	48 8b 44 24 68	 mov	 rax, QWORD PTR reason$[rsp]
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00013	48 8b 44 24 60	 mov	 rax, QWORD PTR endpos$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001d	e8 00 00 00 00	 call	 make_encode_exception

; 6333 :     if (*exceptionObject != NULL)

  00022	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00025	48 85 c9	 test	 rcx, rcx
  00028	74 05		 je	 SHORT $LN1@raise_enco

; 6334 :         PyCodec_StrictErrors(*exceptionObject);

  0002a	e8 00 00 00 00	 call	 PyCodec_StrictErrors
$LN1@raise_enco:

; 6335 : }

  0002f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00033	5b		 pop	 rbx
  00034	c3		 ret	 0
raise_encode_exception ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@NELAFELL@position?5?$CFzd?5from?5error?5handler?5@ ; `string'
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	PyCodec_LookupError:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_encode_call_errorhandler DD imagerel unicode_encode_call_errorhandler
	DD	imagerel unicode_encode_call_errorhandler+46
	DD	imagerel $unwind$unicode_encode_call_errorhandler
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_encode_call_errorhandler DD imagerel unicode_encode_call_errorhandler+46
	DD	imagerel unicode_encode_call_errorhandler+91
	DD	imagerel $chain$0$unicode_encode_call_errorhandler
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$unicode_encode_call_errorhandler DD imagerel unicode_encode_call_errorhandler+91
	DD	imagerel unicode_encode_call_errorhandler+378
	DD	imagerel $chain$3$unicode_encode_call_errorhandler
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$unicode_encode_call_errorhandler DD 041821H
	DD	0c6418H
	DD	0a3400H
	DD	imagerel unicode_encode_call_errorhandler
	DD	imagerel unicode_encode_call_errorhandler+46
	DD	imagerel $unwind$unicode_encode_call_errorhandler
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_encode_call_errorhandler DD 020521H
	DD	0a3405H
	DD	imagerel unicode_encode_call_errorhandler
	DD	imagerel unicode_encode_call_errorhandler+46
	DD	imagerel $unwind$unicode_encode_call_errorhandler
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_encode_call_errorhandler DD 040901H
	DD	0c0055209H
	DD	050027003H
xdata	ENDS
;	COMDAT ??_C@_0CO@NELAFELL@position?5?$CFzd?5from?5error?5handler?5@
CONST	SEGMENT
??_C@_0CO@NELAFELL@position?5?$CFzd?5from?5error?5handler?5@ DB 'position'
	DB	' %zd from error handler out of bounds', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_encode_call_errorhandler
_TEXT	SEGMENT
errors$ = 80
resunicode$ = 88
errorHandler$ = 88
encoding$ = 96
reason$ = 104
unicode$ = 112
exceptionObject$ = 120
startpos$ = 128
endpos$ = 136
newpos$ = 144
unicode_encode_call_errorhandler PROC			; COMDAT

; 6348 : {

  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 6349 :     static char *argparse = "On;encoding error handler must return (str/bytes, int) tuple";
; 6350 :     Py_ssize_t len;
; 6351 :     PyObject *restuple;
; 6352 :     PyObject *resunicode;
; 6353 : 
; 6354 :     if (*errorHandler == NULL) {

  00009	48 83 3a 00	 cmp	 QWORD PTR [rdx], 0
  0000d	49 8b e9	 mov	 rbp, r9
  00010	4d 8b e0	 mov	 r12, r8
  00013	48 8b fa	 mov	 rdi, rdx
  00016	75 16		 jne	 SHORT $LN10@unicode_en

; 6355 :         *errorHandler = PyCodec_LookupError(errors);

  00018	e8 00 00 00 00	 call	 PyCodec_LookupError
  0001d	48 89 07	 mov	 QWORD PTR [rdi], rax

; 6356 :         if (*errorHandler == NULL)

  00020	48 85 c0	 test	 rax, rax
  00023	75 09		 jne	 SHORT $LN10@unicode_en

; 6398 : }

  00025	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00029	41 5c		 pop	 r12
  0002b	5f		 pop	 rdi
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
$LN10@unicode_en:
  0002e	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx

; 6357 :             return NULL;
; 6358 :     }
; 6359 : 
; 6360 :     if (PyUnicode_READY(unicode) == -1)

  00033	48 8b 5c 24 70	 mov	 rbx, QWORD PTR unicode$[rsp]
  00038	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  0003c	75 1d		 jne	 SHORT $LN9@unicode_en
  0003e	48 8b cb	 mov	 rcx, rbx
  00041	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00046	83 f8 ff	 cmp	 eax, -1
  00049	75 10		 jne	 SHORT $LN9@unicode_en

; 6361 :         return NULL;

  0004b	33 c0		 xor	 eax, eax
  0004d	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 6398 : }

  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	41 5c		 pop	 r12
  00058	5f		 pop	 rdi
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
$LN9@unicode_en:

; 6362 :     len = PyUnicode_GET_LENGTH(unicode);
; 6363 : 
; 6364 :     make_encode_exception(exceptionObject,
; 6365 :                           encoding, unicode, startpos, endpos, reason);

  0005b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR endpos$[rsp]
  00063	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR startpos$[rsp]
  0006b	4c 8b c3	 mov	 r8, rbx
  0006e	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00073	48 8b 73 60	 mov	 rsi, QWORD PTR [rbx+96]
  00077	48 8b 5c 24 78	 mov	 rbx, QWORD PTR exceptionObject$[rsp]
  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	49 8b d4	 mov	 rdx, r12
  00082	48 89 6c 24 28	 mov	 QWORD PTR [rsp+40], rbp
  00087	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008c	e8 00 00 00 00	 call	 make_encode_exception

; 6366 :     if (*exceptionObject == NULL)

  00091	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00094	48 85 d2	 test	 rdx, rdx

; 6367 :         return NULL;

  00097	0f 84 c8 00 00
	00		 je	 $LN19@unicode_en

; 6368 : 
; 6369 :     restuple = PyObject_CallFunctionObjArgs(
; 6370 :         *errorHandler, *exceptionObject, NULL);

  0009d	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  000a0	45 33 c0	 xor	 r8d, r8d
  000a3	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  000a8	48 8b d8	 mov	 rbx, rax

; 6371 :     if (restuple == NULL)

  000ab	48 85 c0	 test	 rax, rax

; 6372 :         return NULL;

  000ae	0f 84 b1 00 00
	00		 je	 $LN19@unicode_en

; 6373 :     if (!PyTuple_Check(restuple)) {

  000b4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]

; 6374 :         PyErr_SetString(PyExc_TypeError, &argparse[3]);

  000b8	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?argparse@?1??unicode_encode_call_errorhandler@@9@9
  000bf	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H

; 6375 :         Py_DECREF(restuple);
; 6376 :         return NULL;

  000c9	74 3e		 je	 SHORT $LN21@unicode_en

; 6377 :     }
; 6378 :     if (!PyArg_ParseTuple(restuple, argparse,
; 6379 :                           &resunicode, newpos)) {

  000cb	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR newpos$[rsp]
  000d3	4c 8d 44 24 58	 lea	 r8, QWORD PTR resunicode$[rsp]
  000d8	48 8b cb	 mov	 rcx, rbx
  000db	4c 8b cf	 mov	 r9, rdi
  000de	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000e3	85 c0		 test	 eax, eax

; 6380 :         Py_DECREF(restuple);
; 6381 :         return NULL;

  000e5	74 76		 je	 SHORT $LN20@unicode_en

; 6382 :     }
; 6383 :     if (!PyUnicode_Check(resunicode) && !PyBytes_Check(resunicode)) {

  000e7	48 8b 54 24 58	 mov	 rdx, QWORD PTR resunicode$[rsp]
  000ec	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  000f0	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  000f6	0f ba e1 1c	 bt	 ecx, 28
  000fa	72 1f		 jb	 SHORT $LN4@unicode_en
  000fc	0f ba e1 1b	 bt	 ecx, 27
  00100	72 19		 jb	 SHORT $LN4@unicode_en

; 6384 :         PyErr_SetString(PyExc_TypeError, &argparse[3]);

  00102	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?argparse@?1??unicode_encode_call_errorhandler@@9@9
$LN21@unicode_en:
  00109	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00110	48 83 c2 03	 add	 rdx, 3
  00114	e8 00 00 00 00	 call	 PyErr_SetString

; 6385 :         Py_DECREF(restuple);
; 6386 :         return NULL;

  00119	eb 42		 jmp	 SHORT $LN20@unicode_en
$LN4@unicode_en:

; 6387 :     }
; 6388 :     if (*newpos<0)

  0011b	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0011e	48 85 c0	 test	 rax, rax
  00121	79 08		 jns	 SHORT $LN16@unicode_en

; 6389 :         *newpos = len + *newpos;

  00123	48 03 c6	 add	 rax, rsi
  00126	48 89 07	 mov	 QWORD PTR [rdi], rax

; 6390 :     if (*newpos<0 || *newpos>len) {

  00129	78 1c		 js	 SHORT $LN1@unicode_en
$LN16@unicode_en:
  0012b	48 39 37	 cmp	 QWORD PTR [rdi], rsi
  0012e	7f 17		 jg	 SHORT $LN1@unicode_en

; 6394 :     }
; 6395 :     Py_INCREF(resunicode);

  00130	48 8b ca	 mov	 rcx, rdx
  00133	e8 00 00 00 00	 call	 _Py_IncRef

; 6396 :     Py_DECREF(restuple);

  00138	48 8b cb	 mov	 rcx, rbx
  0013b	e8 00 00 00 00	 call	 _Py_DecRef

; 6397 :     return resunicode;

  00140	48 8b 44 24 58	 mov	 rax, QWORD PTR resunicode$[rsp]
  00145	eb 20		 jmp	 SHORT $LN18@unicode_en
$LN1@unicode_en:

; 6391 :         PyErr_Format(PyExc_IndexError, "position %zd from error handler out of bounds", *newpos);

  00147	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
  0014a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00151	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@NELAFELL@position?5?$CFzd?5from?5error?5handler?5@
  00158	e8 00 00 00 00	 call	 PyErr_Format
$LN20@unicode_en:

; 6392 :         Py_DECREF(restuple);

  0015d	48 8b cb	 mov	 rcx, rbx
  00160	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@unicode_en:

; 6393 :         return NULL;

  00165	33 c0		 xor	 eax, eax
$LN18@unicode_en:
  00167	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0016c	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 6398 : }

  00171	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00175	41 5c		 pop	 r12
  00177	5f		 pop	 rdi
  00178	5d		 pop	 rbp
  00179	c3		 ret	 0
unicode_encode_call_errorhandler ENDP
_TEXT	ENDS
PUBLIC	??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL?$AA@		; `string'
PUBLIC	??_C@_0BC@EBFFMGGH@xmlcharrefreplace?$AA@	; `string'
PUBLIC	??_C@_06GDPEBLPA@ignore?$AA@			; `string'
PUBLIC	??_C@_0BK@JNDPLEJL@ordinal?5not?5in?5range?$CI128?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BK@ENNGNLPI@ordinal?5not?5in?5range?$CI256?$CJ?$AA@ ; `string'
PUBLIC	??_C@_07BJPINKOJ@latin?91?$AA@			; `string'
EXTRN	PyBytes_AsString:PROC
EXTRN	PyBytes_Size:PROC
EXTRN	memset:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$unicode_encode_ucs1 DD imagerel unicode_encode_ucs1
	DD	imagerel unicode_encode_ucs1+259
	DD	imagerel $unwind$unicode_encode_ucs1
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$unicode_encode_ucs1 DD imagerel unicode_encode_ucs1+259
	DD	imagerel unicode_encode_ucs1+1851
	DD	imagerel $chain$2$unicode_encode_ucs1
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$unicode_encode_ucs1 DD imagerel unicode_encode_ucs1+1851
	DD	imagerel unicode_encode_ucs1+1882
	DD	imagerel $chain$3$unicode_encode_ucs1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$unicode_encode_ucs1 DD 021H
	DD	imagerel unicode_encode_ucs1
	DD	imagerel unicode_encode_ucs1+259
	DD	imagerel $unwind$unicode_encode_ucs1
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$unicode_encode_ucs1 DD 020821H
	DD	015f408H
	DD	imagerel unicode_encode_ucs1
	DD	imagerel unicode_encode_ucs1+259
	DD	imagerel $unwind$unicode_encode_ucs1
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_encode_ucs1 DD 0bb101H
	DD	016d4b1H
	DD	01764a7H
	DD	0180122H
	DD	0c014e016H
	DD	030117012H
	DD	05010H
xdata	ENDS
;	COMDAT ??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL?$AA@
CONST	SEGMENT
??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL?$AA@ DB '&#%d;', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EBFFMGGH@xmlcharrefreplace?$AA@
CONST	SEGMENT
??_C@_0BC@EBFFMGGH@xmlcharrefreplace?$AA@ DB 'xmlcharrefreplace', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GDPEBLPA@ignore?$AA@
CONST	SEGMENT
??_C@_06GDPEBLPA@ignore?$AA@ DB 'ignore', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JNDPLEJL@ordinal?5not?5in?5range?$CI128?$CJ?$AA@
CONST	SEGMENT
??_C@_0BK@JNDPLEJL@ordinal?5not?5in?5range?$CI128?$CJ?$AA@ DB 'ordinal no'
	DB	't in range(128)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@ENNGNLPI@ordinal?5not?5in?5range?$CI256?$CJ?$AA@
CONST	SEGMENT
??_C@_0BK@ENNGNLPI@ordinal?5not?5in?5range?$CI256?$CJ?$AA@ DB 'ordinal no'
	DB	't in range(256)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07BJPINKOJ@latin?91?$AA@
CONST	SEGMENT
??_C@_07BJPINKOJ@latin?91?$AA@ DB 'latin-1', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT unicode_encode_ucs1
_TEXT	SEGMENT
res$ = 80
ressize$1$ = 88
exc$ = 96
errorHandler$ = 104
size$1$ = 112
errorHandler$1$ = 120
newpos$132396 = 120
reason$1$ = 128
encoding$1$ = 136
$T151232 = 144
unicode$ = 240
errors$ = 248
limit$ = 256
known_errorHandler$1$ = 264
unicode_encode_ucs1 PROC				; COMDAT

; 6404 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	53		 push	 rbx
  00011	57		 push	 rdi
  00012	41 54		 push	 r12
  00014	41 56		 push	 r14
  00016	48 8d 6c 24 c9	 lea	 rbp, QWORD PTR [rsp-55]
  0001b	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H

; 6405 :     /* input state */
; 6406 :     Py_ssize_t pos=0, size;

  00022	45 33 e4	 xor	 r12d, r12d
  00025	48 8b d9	 mov	 rbx, rcx

; 6407 :     int kind;
; 6408 :     void *data;
; 6409 :     /* output object */
; 6410 :     PyObject *res;
; 6411 :     /* pointer into the output */
; 6412 :     char *str;
; 6413 :     /* current output position */
; 6414 :     Py_ssize_t ressize;
; 6415 :     const char *encoding = (limit == 256) ? "latin-1" : "ascii";

  00028	41 81 f8 00 01
	00 00		 cmp	 r8d, 256		; 00000100H
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07BJPINKOJ@latin?91?$AA@
  00036	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05OJENGABA@ascii?$AA@

; 6416 :     const char *reason = (limit == 256) ? "ordinal not in range(256)" : "ordinal not in range(128)";
; 6417 :     PyObject *errorHandler = NULL;
; 6418 :     PyObject *exc = NULL;
; 6419 :     /* the following variable is used for caching string comparisons
; 6420 :      * -1=not initialized, 0=unknown, 1=strict, 2=replace, 3=ignore, 4=xmlcharrefreplace */
; 6421 :     int known_errorHandler = -1;

  0003d	c7 45 7f ff ff
	ff ff		 mov	 DWORD PTR known_errorHandler$1$[rbp-137], -1
  00044	48 0f 44 c1	 cmove	 rax, rcx
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@ENNGNLPI@ordinal?5not?5in?5range?$CI256?$CJ?$AA@
  0004f	4c 89 65 ef	 mov	 QWORD PTR errorHandler$1$[rbp-137], r12
  00053	48 89 45 ff	 mov	 QWORD PTR encoding$1$[rbp-137], rax
  00057	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@JNDPLEJL@ordinal?5not?5in?5range?$CI128?$CJ?$AA@
  0005e	45 8b f4	 mov	 r14d, r12d
  00061	48 0f 44 c1	 cmove	 rax, rcx

; 6422 : 
; 6423 :     if (PyUnicode_READY(unicode) == -1)

  00065	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00069	4c 89 65 df	 mov	 QWORD PTR errorHandler$[rbp-137], r12
  0006d	48 89 45 f7	 mov	 QWORD PTR reason$1$[rbp-137], rax
  00071	41 8b fc	 mov	 edi, r12d
  00074	4c 89 65 d7	 mov	 QWORD PTR exc$[rbp-137], r12
  00078	75 1e		 jne	 SHORT $LN83@unicode_en@2
  0007a	48 8b cb	 mov	 rcx, rbx
  0007d	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00082	83 f8 ff	 cmp	 eax, -1
  00085	75 11		 jne	 SHORT $LN83@unicode_en@2

; 6424 :         return NULL;

  00087	33 c0		 xor	 eax, eax

; 6593 : }

  00089	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  00090	41 5e		 pop	 r14
  00092	41 5c		 pop	 r12
  00094	5f		 pop	 rdi
  00095	5b		 pop	 rbx
  00096	5d		 pop	 rbp
  00097	c3		 ret	 0
$LN83@unicode_en@2:

; 6425 :     size = PyUnicode_GET_LENGTH(unicode);
; 6426 :     kind = PyUnicode_KIND(unicode);

  00098	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0009b	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  0009f	48 89 b4 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], rsi
  000a7	8b f0		 mov	 esi, eax
  000a9	4c 89 ac 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], r13
  000b1	48 89 55 e7	 mov	 QWORD PTR size$1$[rbp-137], rdx
  000b5	c1 ee 02	 shr	 esi, 2
  000b8	83 e6 07	 and	 esi, 7

; 6427 :     data = PyUnicode_DATA(unicode);

  000bb	a8 20		 test	 al, 32			; 00000020H
  000bd	74 16		 je	 SHORT $LN90@unicode_en@2
  000bf	a8 40		 test	 al, 64			; 00000040H
  000c1	74 09		 je	 SHORT $LN88@unicode_en@2
  000c3	4c 8d ab 80 00
	00 00		 lea	 r13, QWORD PTR [rbx+128]
  000ca	eb 10		 jmp	 SHORT $LN91@unicode_en@2
$LN88@unicode_en@2:
  000cc	4c 8d ab a0 00
	00 00		 lea	 r13, QWORD PTR [rbx+160]
  000d3	eb 07		 jmp	 SHORT $LN91@unicode_en@2
$LN90@unicode_en@2:
  000d5	4c 8b ab a0 00
	00 00		 mov	 r13, QWORD PTR [rbx+160]
$LN91@unicode_en@2:

; 6428 :     /* allocate enough for a simple encoding without
; 6429 :        replacements, if we need more, we'll resize */
; 6430 :     if (size == 0)
; 6431 :         return PyBytes_FromStringAndSize(NULL, 0);

  000dc	33 c9		 xor	 ecx, ecx
  000de	48 85 d2	 test	 rdx, rdx
  000e1	75 0a		 jne	 SHORT $LN82@unicode_en@2
  000e3	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000e8	e9 4e 06 00 00	 jmp	 $LN175@unicode_en@2
$LN82@unicode_en@2:

; 6432 :     res = PyBytes_FromStringAndSize(NULL, size);

  000ed	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000f2	48 89 45 c7	 mov	 QWORD PTR res$[rbp-137], rax

; 6433 :     if (res == NULL)

  000f6	48 85 c0	 test	 rax, rax
  000f9	0f 84 3c 06 00
	00		 je	 $LN175@unicode_en@2
$LN81@unicode_en@2:

; 6434 :         return NULL;
; 6435 :     str = PyBytes_AS_STRING(res);
; 6436 :     ressize = size;

  000ff	4c 8b 4d e7	 mov	 r9, QWORD PTR size$1$[rbp-137]
  00103	4c 89 bc 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], r15
  0010b	4c 8b 7d c7	 mov	 r15, QWORD PTR res$[rbp-137]
  0010f	49 8b d9	 mov	 rbx, r9

; 6439 :         Py_UCS4 c = PyUnicode_READ(kind, data, pos);

  00112	4c 63 c6	 movsxd	 r8, esi
  00115	49 83 c7 78	 add	 r15, 120		; 00000078H
  00119	48 89 5d cf	 mov	 QWORD PTR ressize$1$[rbp-137], rbx
  0011d	4c 89 45 07	 mov	 QWORD PTR $T151232[rbp-137], r8
  00121	4d 85 c9	 test	 r9, r9
  00124	0f 8e b2 04 00
	00		 jle	 $LN79@unicode_en@2
$LN177@unicode_en@2:

; 6437 : 
; 6438 :     while (pos < size) {

  0012a	ba 04 00 00 00	 mov	 edx, 4

; 6439 :         Py_UCS4 c = PyUnicode_READ(kind, data, pos);

  0012f	49 83 f8 01	 cmp	 r8, 1
  00133	75 08		 jne	 SHORT $LN94@unicode_en@2
  00135	43 0f b6 44 35
	00		 movzx	 eax, BYTE PTR [r13+r14]
  0013b	eb 13		 jmp	 SHORT $LN93@unicode_en@2
$LN94@unicode_en@2:
  0013d	49 83 f8 02	 cmp	 r8, 2
  00141	75 08		 jne	 SHORT $LN92@unicode_en@2
  00143	43 0f b7 44 75
	00		 movzx	 eax, WORD PTR [r13+r14*2]
  00149	eb 05		 jmp	 SHORT $LN93@unicode_en@2
$LN92@unicode_en@2:
  0014b	43 8b 44 b5 00	 mov	 eax, DWORD PTR [r13+r14*4]
$LN93@unicode_en@2:

; 6440 : 
; 6441 :         /* can we encode this? */
; 6442 :         if (c<limit) {

  00150	8b 4d 77	 mov	 ecx, DWORD PTR limit$[rbp-137]
  00153	3b c1		 cmp	 eax, ecx
  00155	73 0e		 jae	 SHORT $LN78@unicode_en@2

; 6443 :             /* no overflow check, because we know that the space is enough */
; 6444 :             *str++ = (char)c;

  00157	41 88 07	 mov	 BYTE PTR [r15], al
  0015a	49 ff c7	 inc	 r15

; 6445 :             ++pos;

  0015d	49 ff c6	 inc	 r14

; 6446 :         }
; 6447 :         else {

  00160	e9 25 04 00 00	 jmp	 $LN63@unicode_en@2
$LN78@unicode_en@2:

; 6448 :             Py_ssize_t requiredsize;
; 6449 :             PyObject *repunicode;
; 6450 :             Py_ssize_t repsize, newpos, respos, i;
; 6451 :             /* startpos for collecting unencodable chars */
; 6452 :             Py_ssize_t collstart = pos;
; 6453 :             Py_ssize_t collend = pos;

  00165	49 8b de	 mov	 rbx, r14

; 6454 :             /* find all unecodable characters */
; 6455 :             while ((collend < size) && (PyUnicode_READ(kind, data, collend)>=limit))

  00168	4d 3b f1	 cmp	 r14, r9
  0016b	7d 2f		 jge	 SHORT $LN171@unicode_en@2
  0016d	0f 1f 00	 npad	 3
$LL76@unicode_en@2:
  00170	49 83 f8 01	 cmp	 r8, 1
  00174	75 07		 jne	 SHORT $LN98@unicode_en@2
  00176	42 0f b6 04 2b	 movzx	 eax, BYTE PTR [rbx+r13]
  0017b	eb 13		 jmp	 SHORT $LN97@unicode_en@2
$LN98@unicode_en@2:
  0017d	49 83 f8 02	 cmp	 r8, 2
  00181	75 08		 jne	 SHORT $LN96@unicode_en@2
  00183	41 0f b7 44 5d
	00		 movzx	 eax, WORD PTR [r13+rbx*2]
  00189	eb 05		 jmp	 SHORT $LN97@unicode_en@2
$LN96@unicode_en@2:
  0018b	41 8b 44 9d 00	 mov	 eax, DWORD PTR [r13+rbx*4]
$LN97@unicode_en@2:
  00190	3b c1		 cmp	 eax, ecx
  00192	72 08		 jb	 SHORT $LN171@unicode_en@2

; 6456 :                 ++collend;

  00194	48 ff c3	 inc	 rbx
  00197	49 3b d9	 cmp	 rbx, r9
  0019a	7c d4		 jl	 SHORT $LL76@unicode_en@2
$LN171@unicode_en@2:

; 6457 :             /* cache callback name lookup (if not done yet, i.e. it's the first error) */
; 6458 :             if (known_errorHandler==-1) {

  0019c	8b 4d 7f	 mov	 ecx, DWORD PTR known_errorHandler$1$[rbp-137]

; 6459 :                 if ((errors==NULL) || (!strcmp(errors, "strict")))

  0019f	4c 8b 55 6f	 mov	 r10, QWORD PTR errors$[rbp-137]
  001a3	83 f9 ff	 cmp	 ecx, -1
  001a6	75 6d		 jne	 SHORT $LN65@unicode_en@2
  001a8	4d 85 d2	 test	 r10, r10
  001ab	74 60		 je	 SHORT $LN72@unicode_en@2
  001ad	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  001b4	49 8b f2	 mov	 rsi, r10
  001b7	b9 07 00 00 00	 mov	 ecx, 7
  001bc	f3 a6		 repe cmpsb
  001be	74 4d		 je	 SHORT $LN72@unicode_en@2

; 6461 :                 else if (!strcmp(errors, "replace"))

  001c0	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_07CLEHDIEJ@replace?$AA@
  001c7	49 8b f2	 mov	 rsi, r10
  001ca	b9 08 00 00 00	 mov	 ecx, 8
  001cf	f3 a6		 repe cmpsb
  001d1	75 07		 jne	 SHORT $LN70@unicode_en@2

; 6462 :                     known_errorHandler = 2;

  001d3	b9 02 00 00 00	 mov	 ecx, 2
  001d8	eb 38		 jmp	 SHORT $LN178@unicode_en@2
$LN70@unicode_en@2:

; 6463 :                 else if (!strcmp(errors, "ignore"))

  001da	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06GDPEBLPA@ignore?$AA@
  001e1	49 8b f2	 mov	 rsi, r10
  001e4	b9 07 00 00 00	 mov	 ecx, 7
  001e9	f3 a6		 repe cmpsb
  001eb	75 07		 jne	 SHORT $LN68@unicode_en@2

; 6464 :                     known_errorHandler = 3;

  001ed	b9 03 00 00 00	 mov	 ecx, 3
  001f2	eb 1e		 jmp	 SHORT $LN178@unicode_en@2
$LN68@unicode_en@2:

; 6465 :                 else if (!strcmp(errors, "xmlcharrefreplace"))

  001f4	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0BC@EBFFMGGH@xmlcharrefreplace?$AA@
  001fb	49 8b f2	 mov	 rsi, r10
  001fe	b9 12 00 00 00	 mov	 ecx, 18
  00203	f3 a6		 repe cmpsb
  00205	41 8b cc	 mov	 ecx, r12d
  00208	0f 44 ca	 cmove	 ecx, edx

; 6466 :                     known_errorHandler = 4;
; 6467 :                 else
; 6468 :                     known_errorHandler = 0;

  0020b	eb 05		 jmp	 SHORT $LN178@unicode_en@2
$LN72@unicode_en@2:

; 6460 :                     known_errorHandler = 1;

  0020d	b9 01 00 00 00	 mov	 ecx, 1
$LN178@unicode_en@2:
  00212	89 4d 7f	 mov	 DWORD PTR known_errorHandler$1$[rbp-137], ecx
$LN65@unicode_en@2:

; 6469 :             }
; 6470 :             switch (known_errorHandler) {

  00215	ff c9		 dec	 ecx
  00217	0f 84 0f 04 00
	00		 je	 $LN62@unicode_en@2
  0021d	ff c9		 dec	 ecx
  0021f	0f 84 3f 03 00
	00		 je	 $LN153@unicode_en@2
  00225	ff c9		 dec	 ecx
  00227	0f 84 56 03 00
	00		 je	 $LN60@unicode_en@2
  0022d	ff c9		 dec	 ecx
  0022f	0f 84 18 02 00
	00		 je	 $LN57@unicode_en@2

; 6517 :             default:
; 6518 :                 repunicode = unicode_encode_call_errorhandler(errors, &errorHandler,
; 6519 :                                                               encoding, reason, unicode, &exc,
; 6520 :                                                               collstart, collend, &newpos);

  00235	4c 8b 4d f7	 mov	 r9, QWORD PTR reason$1$[rbp-137]
  00239	4c 8b 45 ff	 mov	 r8, QWORD PTR encoding$1$[rbp-137]
  0023d	48 8d 45 ef	 lea	 rax, QWORD PTR newpos$132396[rbp-137]
  00241	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00246	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  0024b	48 8d 45 d7	 lea	 rax, QWORD PTR exc$[rbp-137]
  0024f	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  00254	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00259	48 8b 45 67	 mov	 rax, QWORD PTR unicode$[rbp-137]
  0025d	48 8d 55 df	 lea	 rdx, QWORD PTR errorHandler$[rbp-137]
  00261	49 8b ca	 mov	 rcx, r10
  00264	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00269	e8 00 00 00 00	 call	 unicode_encode_call_errorhandler
  0026e	48 8b f8	 mov	 rdi, rax

; 6521 :                 if (repunicode == NULL || (PyUnicode_Check(repunicode) &&
; 6522 :                                            PyUnicode_READY(repunicode) == -1))

  00271	48 85 c0	 test	 rax, rax
  00274	0f 84 d4 03 00
	00		 je	 $LN166@unicode_en@2
  0027a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0027e	f7 81 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rcx+256], 268435456 ; 10000000H
  00288	74 17		 je	 SHORT $LN34@unicode_en@2
  0028a	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  0028e	75 11		 jne	 SHORT $LN34@unicode_en@2
  00290	48 8b c8	 mov	 rcx, rax
  00293	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00298	83 f8 ff	 cmp	 eax, -1
  0029b	0f 84 ad 03 00
	00		 je	 $LN166@unicode_en@2
$LN34@unicode_en@2:

; 6523 :                     goto onError;
; 6524 :                 if (PyBytes_Check(repunicode)) {

  002a1	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  002a5	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  002af	74 68		 je	 SHORT $LN32@unicode_en@2

; 6525 :                     /* Directly copy bytes result to output. */
; 6526 :                     repsize = PyBytes_Size(repunicode);

  002b1	48 8b cf	 mov	 rcx, rdi
  002b4	e8 00 00 00 00	 call	 PyBytes_Size

; 6527 :                     if (repsize > 1) {
; 6528 :                         /* Make room for all additional bytes. */
; 6529 :                         respos = str - PyBytes_AS_STRING(res);
; 6530 :                         if (_PyBytes_Resize(&res, ressize+repsize-1)) {

  002b9	48 8b 5d cf	 mov	 rbx, QWORD PTR ressize$1$[rbp-137]
  002bd	48 8b f0	 mov	 rsi, rax
  002c0	48 83 f8 01	 cmp	 rax, 1
  002c4	7e 25		 jle	 SHORT $LN31@unicode_en@2
  002c6	4c 2b 7d c7	 sub	 r15, QWORD PTR res$[rbp-137]
  002ca	48 8d 5c 18 ff	 lea	 rbx, QWORD PTR [rax+rbx-1]
  002cf	48 8d 4d c7	 lea	 rcx, QWORD PTR res$[rbp-137]
  002d3	48 8b d3	 mov	 rdx, rbx
  002d6	48 89 5d cf	 mov	 QWORD PTR ressize$1$[rbp-137], rbx
  002da	e8 00 00 00 00	 call	 _PyBytes_Resize
  002df	85 c0		 test	 eax, eax
  002e1	0f 85 d7 02 00
	00		 jne	 $LN156@unicode_en@2

; 6531 :                             Py_DECREF(repunicode);
; 6532 :                             goto onError;
; 6533 :                         }
; 6534 :                         str = PyBytes_AS_STRING(res) + respos;

  002e7	4c 03 7d c7	 add	 r15, QWORD PTR res$[rbp-137]
$LN31@unicode_en@2:

; 6535 :                         ressize += repsize-1;
; 6536 :                     }
; 6537 :                     memcpy(str, PyBytes_AsString(repunicode), repsize);

  002eb	48 8b cf	 mov	 rcx, rdi
  002ee	e8 00 00 00 00	 call	 PyBytes_AsString
  002f3	4c 8b c6	 mov	 r8, rsi
  002f6	49 8b cf	 mov	 rcx, r15
  002f9	48 8b d0	 mov	 rdx, rax
  002fc	e8 00 00 00 00	 call	 memcpy

; 6538 :                     str += repsize;
; 6539 :                     pos = newpos;

  00301	4c 8b 75 ef	 mov	 r14, QWORD PTR newpos$132396[rbp-137]

; 6540 :                     Py_DECREF(repunicode);

  00305	48 8b cf	 mov	 rcx, rdi
  00308	4c 03 fe	 add	 r15, rsi
  0030b	e8 00 00 00 00	 call	 _Py_DecRef

; 6541 :                     break;

  00310	4c 8b 4d e7	 mov	 r9, QWORD PTR size$1$[rbp-137]
  00314	e9 71 02 00 00	 jmp	 $LN63@unicode_en@2
$LN32@unicode_en@2:

; 6542 :                 }
; 6543 :                 /* need more space? (at least enough for what we
; 6544 :                    have+the replacement+the rest of the string, so
; 6545 :                    we won't have to check space for encodable characters) */
; 6546 :                 respos = str - PyBytes_AS_STRING(res);
; 6547 :                 repsize = PyUnicode_GET_LENGTH(repunicode);

  00319	4c 8b 67 60	 mov	 r12, QWORD PTR [rdi+96]
  0031d	49 8b f7	 mov	 rsi, r15
  00320	48 2b 75 c7	 sub	 rsi, QWORD PTR res$[rbp-137]

; 6548 :                 requiredsize = respos+repsize+(size-collend);

  00324	49 8b cc	 mov	 rcx, r12
  00327	48 2b cb	 sub	 rcx, rbx

; 6549 :                 if (requiredsize > ressize) {

  0032a	48 8b 5d cf	 mov	 rbx, QWORD PTR ressize$1$[rbp-137]
  0032e	48 83 ee 78	 sub	 rsi, 120		; 00000078H
  00332	48 03 ce	 add	 rcx, rsi
  00335	48 03 4d e7	 add	 rcx, QWORD PTR size$1$[rbp-137]
  00339	48 3b cb	 cmp	 rcx, rbx
  0033c	7e 2f		 jle	 SHORT $LN29@unicode_en@2

; 6550 :                     if (requiredsize<2*ressize)

  0033e	48 8d 04 1b	 lea	 rax, QWORD PTR [rbx+rbx]
  00342	48 8b d9	 mov	 rbx, rcx
  00345	48 3b c8	 cmp	 rcx, rax

; 6551 :                         requiredsize = 2*ressize;
; 6552 :                     if (_PyBytes_Resize(&res, requiredsize)) {

  00348	48 8d 4d c7	 lea	 rcx, QWORD PTR res$[rbp-137]
  0034c	48 0f 4c d8	 cmovl	 rbx, rax
  00350	48 8b d3	 mov	 rdx, rbx
  00353	48 89 5d cf	 mov	 QWORD PTR ressize$1$[rbp-137], rbx
  00357	e8 00 00 00 00	 call	 _PyBytes_Resize
  0035c	85 c0		 test	 eax, eax
  0035e	0f 85 5a 02 00
	00		 jne	 $LN156@unicode_en@2

; 6553 :                         Py_DECREF(repunicode);
; 6554 :                         goto onError;
; 6555 :                     }
; 6556 :                     str = PyBytes_AS_STRING(res) + respos;

  00364	48 8b 45 c7	 mov	 rax, QWORD PTR res$[rbp-137]
  00368	4c 8d 7c 06 78	 lea	 r15, QWORD PTR [rsi+rax+120]
$LN29@unicode_en@2:

; 6557 :                     ressize = requiredsize;
; 6558 :                 }
; 6559 :                 /* check if there is anything unencodable in the replacement
; 6560 :                    and copy it to the output */
; 6561 :                 for (i = 0; repsize-->0; ++i, ++str) {

  0036d	33 f6		 xor	 esi, esi
  0036f	8b d6		 mov	 edx, esi
  00371	4d 85 e4	 test	 r12, r12
  00374	0f 8e bb 00 00
	00		 jle	 $LN160@unicode_en@2
  0037a	44 8b 45 77	 mov	 r8d, DWORD PTR limit$[rbp-137]
  0037e	66 90		 npad	 2
$LL26@unicode_en@2:

; 6562 :                     c = PyUnicode_READ_CHAR(repunicode, i);

  00380	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00383	49 ff cc	 dec	 r12
  00386	8b c8		 mov	 ecx, eax
  00388	c1 e9 02	 shr	 ecx, 2
  0038b	83 e1 07	 and	 ecx, 7
  0038e	83 f9 01	 cmp	 ecx, 1
  00391	75 2f		 jne	 SHORT $LN124@unicode_en@2
  00393	a8 20		 test	 al, 32			; 00000020H
  00395	74 1e		 je	 SHORT $LN112@unicode_en@2
  00397	a8 40		 test	 al, 64			; 00000040H
  00399	74 0d		 je	 SHORT $LN110@unicode_en@2
  0039b	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  003a2	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  003a6	eb 72		 jmp	 SHORT $LN123@unicode_en@2
$LN110@unicode_en@2:
  003a8	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  003af	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  003b3	eb 65		 jmp	 SHORT $LN123@unicode_en@2
$LN112@unicode_en@2:
  003b5	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  003bc	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  003c0	eb 58		 jmp	 SHORT $LN123@unicode_en@2
$LN124@unicode_en@2:
  003c2	83 f9 02	 cmp	 ecx, 2
  003c5	75 2f		 jne	 SHORT $LN122@unicode_en@2
  003c7	a8 20		 test	 al, 32			; 00000020H
  003c9	74 1e		 je	 SHORT $LN116@unicode_en@2
  003cb	a8 40		 test	 al, 64			; 00000040H
  003cd	74 0d		 je	 SHORT $LN114@unicode_en@2
  003cf	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  003d6	0f b7 04 50	 movzx	 eax, WORD PTR [rax+rdx*2]
  003da	eb 3e		 jmp	 SHORT $LN123@unicode_en@2
$LN114@unicode_en@2:
  003dc	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  003e3	0f b7 04 50	 movzx	 eax, WORD PTR [rax+rdx*2]
  003e7	eb 31		 jmp	 SHORT $LN123@unicode_en@2
$LN116@unicode_en@2:
  003e9	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  003f0	0f b7 04 50	 movzx	 eax, WORD PTR [rax+rdx*2]
  003f4	eb 24		 jmp	 SHORT $LN123@unicode_en@2
$LN122@unicode_en@2:
  003f6	a8 20		 test	 al, 32			; 00000020H
  003f8	74 16		 je	 SHORT $LN120@unicode_en@2
  003fa	a8 40		 test	 al, 64			; 00000040H
  003fc	74 09		 je	 SHORT $LN118@unicode_en@2
  003fe	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  00405	eb 10		 jmp	 SHORT $LN121@unicode_en@2
$LN118@unicode_en@2:
  00407	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  0040e	eb 07		 jmp	 SHORT $LN121@unicode_en@2
$LN120@unicode_en@2:
  00410	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
$LN121@unicode_en@2:
  00417	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
$LN123@unicode_en@2:

; 6563 :                     if (c >= limit) {

  0041a	41 3b c0	 cmp	 eax, r8d
  0041d	0f 83 75 01 00
	00		 jae	 $LN154@unicode_en@2

; 6568 :                     }
; 6569 :                     *str = (char)c;

  00423	41 88 07	 mov	 BYTE PTR [r15], al
  00426	49 ff c7	 inc	 r15
  00429	48 ff c2	 inc	 rdx
  0042c	4d 85 e4	 test	 r12, r12
  0042f	0f 8f 4b ff ff
	ff		 jg	 $LL26@unicode_en@2
$LN160@unicode_en@2:

; 6570 :                 }
; 6571 :                 pos = newpos;

  00435	4c 8b 75 ef	 mov	 r14, QWORD PTR newpos$132396[rbp-137]

; 6572 :                 Py_DECREF(repunicode);

  00439	48 8b cf	 mov	 rcx, rdi
  0043c	e8 00 00 00 00	 call	 _Py_DecRef
  00441	4c 8b 4d e7	 mov	 r9, QWORD PTR size$1$[rbp-137]
  00445	45 33 e4	 xor	 r12d, r12d
  00448	e9 3d 01 00 00	 jmp	 $LN63@unicode_en@2
$LN57@unicode_en@2:

; 6479 :                 break;
; 6480 :             case 4: /* xmlcharrefreplace */
; 6481 :                 respos = str - PyBytes_AS_STRING(res);

  0044d	49 8b ff	 mov	 rdi, r15

; 6482 :                 /* determine replacement size */
; 6483 :                 for (i = collstart, repsize = 0; i < collend; ++i) {

  00450	49 8b d6	 mov	 rdx, r14
  00453	49 8b cc	 mov	 rcx, r12
  00456	48 2b 7d c7	 sub	 rdi, QWORD PTR res$[rbp-137]
  0045a	48 83 ef 78	 sub	 rdi, 120		; 00000078H
  0045e	4c 3b f3	 cmp	 r14, rbx
  00461	7d 76		 jge	 SHORT $LN54@unicode_en@2
$LL56@unicode_en@2:

; 6484 :                     Py_UCS4 ch = PyUnicode_READ(kind, data, i);

  00463	49 83 f8 01	 cmp	 r8, 1
  00467	75 07		 jne	 SHORT $LN102@unicode_en@2
  00469	42 0f b6 04 2a	 movzx	 eax, BYTE PTR [rdx+r13]
  0046e	eb 13		 jmp	 SHORT $LN101@unicode_en@2
$LN102@unicode_en@2:
  00470	49 83 f8 02	 cmp	 r8, 2
  00474	75 08		 jne	 SHORT $LN100@unicode_en@2
  00476	41 0f b7 44 55
	00		 movzx	 eax, WORD PTR [r13+rdx*2]
  0047c	eb 05		 jmp	 SHORT $LN101@unicode_en@2
$LN100@unicode_en@2:
  0047e	41 8b 44 95 00	 mov	 eax, DWORD PTR [r13+rdx*4]
$LN101@unicode_en@2:

; 6485 :                     if (ch < 10)

  00483	83 f8 0a	 cmp	 eax, 10
  00486	73 06		 jae	 SHORT $LN53@unicode_en@2

; 6486 :                         repsize += 2+1+1;

  00488	48 83 c1 04	 add	 rcx, 4
  0048c	eb 43		 jmp	 SHORT $LN55@unicode_en@2
$LN53@unicode_en@2:

; 6487 :                     else if (ch < 100)

  0048e	83 f8 64	 cmp	 eax, 100		; 00000064H
  00491	73 06		 jae	 SHORT $LN51@unicode_en@2

; 6488 :                         repsize += 2+2+1;

  00493	48 83 c1 05	 add	 rcx, 5
  00497	eb 38		 jmp	 SHORT $LN55@unicode_en@2
$LN51@unicode_en@2:

; 6489 :                     else if (ch < 1000)

  00499	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  0049e	73 06		 jae	 SHORT $LN49@unicode_en@2

; 6490 :                         repsize += 2+3+1;

  004a0	48 83 c1 06	 add	 rcx, 6
  004a4	eb 2b		 jmp	 SHORT $LN55@unicode_en@2
$LN49@unicode_en@2:

; 6491 :                     else if (ch < 10000)

  004a6	3d 10 27 00 00	 cmp	 eax, 10000		; 00002710H
  004ab	73 06		 jae	 SHORT $LN47@unicode_en@2

; 6492 :                         repsize += 2+4+1;

  004ad	48 83 c1 07	 add	 rcx, 7
  004b1	eb 1e		 jmp	 SHORT $LN55@unicode_en@2
$LN47@unicode_en@2:

; 6493 :                     else if (ch < 100000)

  004b3	3d a0 86 01 00	 cmp	 eax, 100000		; 000186a0H
  004b8	73 06		 jae	 SHORT $LN45@unicode_en@2

; 6494 :                         repsize += 2+5+1;

  004ba	48 83 c1 08	 add	 rcx, 8
  004be	eb 11		 jmp	 SHORT $LN55@unicode_en@2
$LN45@unicode_en@2:

; 6495 :                     else if (ch < 1000000)

  004c0	3d 40 42 0f 00	 cmp	 eax, 1000000		; 000f4240H
  004c5	73 06		 jae	 SHORT $LN43@unicode_en@2

; 6496 :                         repsize += 2+6+1;

  004c7	48 83 c1 09	 add	 rcx, 9

; 6497 :                     else {

  004cb	eb 04		 jmp	 SHORT $LN55@unicode_en@2
$LN43@unicode_en@2:

; 6498 :                         assert(ch <= MAX_UNICODE);
; 6499 :                         repsize += 2+7+1;

  004cd	48 83 c1 0a	 add	 rcx, 10
$LN55@unicode_en@2:

; 6482 :                 /* determine replacement size */
; 6483 :                 for (i = collstart, repsize = 0; i < collend; ++i) {

  004d1	48 ff c2	 inc	 rdx
  004d4	48 3b d3	 cmp	 rdx, rbx
  004d7	7c 8a		 jl	 SHORT $LL56@unicode_en@2
$LN54@unicode_en@2:

; 6500 :                     }
; 6501 :                 }
; 6502 :                 requiredsize = respos+repsize+(size-collend);
; 6503 :                 if (requiredsize > ressize) {

  004d9	48 8b 55 cf	 mov	 rdx, QWORD PTR ressize$1$[rbp-137]
  004dd	48 2b cb	 sub	 rcx, rbx
  004e0	48 03 cf	 add	 rcx, rdi
  004e3	49 03 c9	 add	 rcx, r9
  004e6	48 3b ca	 cmp	 rcx, rdx
  004e9	7e 30		 jle	 SHORT $LN41@unicode_en@2

; 6504 :                     if (requiredsize<2*ressize)

  004eb	48 8d 04 12	 lea	 rax, QWORD PTR [rdx+rdx]
  004ef	48 8b d1	 mov	 rdx, rcx
  004f2	48 3b c8	 cmp	 rcx, rax

; 6505 :                         requiredsize = 2*ressize;
; 6506 :                     if (_PyBytes_Resize(&res, requiredsize))

  004f5	48 8d 4d c7	 lea	 rcx, QWORD PTR res$[rbp-137]
  004f9	48 0f 4c d0	 cmovl	 rdx, rax
  004fd	48 89 55 cf	 mov	 QWORD PTR ressize$1$[rbp-137], rdx
  00501	e8 00 00 00 00	 call	 _PyBytes_Resize
  00506	85 c0		 test	 eax, eax
  00508	0f 85 40 01 00
	00		 jne	 $LN166@unicode_en@2

; 6507 :                         goto onError;
; 6508 :                     str = PyBytes_AS_STRING(res) + respos;

  0050e	48 8b 45 c7	 mov	 rax, QWORD PTR res$[rbp-137]
  00512	4c 8b 45 07	 mov	 r8, QWORD PTR $T151232[rbp-137]
  00516	4c 8d 7c 07 78	 lea	 r15, QWORD PTR [rdi+rax+120]
$LN41@unicode_en@2:

; 6509 :                     ressize = requiredsize;
; 6510 :                 }
; 6511 :                 /* generate replacement */
; 6512 :                 for (i = collstart; i < collend; ++i) {

  0051b	4c 3b f3	 cmp	 r14, rbx
  0051e	7d 5f		 jge	 SHORT $LN36@unicode_en@2
$LL38@unicode_en@2:

; 6513 :                     str += sprintf(str, "&#%d;", PyUnicode_READ(kind, data, i));

  00520	49 83 f8 01	 cmp	 r8, 1
  00524	75 07		 jne	 SHORT $LN106@unicode_en@2
  00526	47 0f b6 04 2e	 movzx	 r8d, BYTE PTR [r14+r13]
  0052b	eb 13		 jmp	 SHORT $LN105@unicode_en@2
$LN106@unicode_en@2:
  0052d	49 83 f8 02	 cmp	 r8, 2
  00531	75 08		 jne	 SHORT $LN104@unicode_en@2
  00533	47 0f b7 44 75
	00		 movzx	 r8d, WORD PTR [r13+r14*2]
  00539	eb 05		 jmp	 SHORT $LN105@unicode_en@2
$LN104@unicode_en@2:

; 6509 :                     ressize = requiredsize;
; 6510 :                 }
; 6511 :                 /* generate replacement */
; 6512 :                 for (i = collstart; i < collend; ++i) {

  0053b	47 8b 44 b5 00	 mov	 r8d, DWORD PTR [r13+r14*4]
$LN105@unicode_en@2:

; 6513 :                     str += sprintf(str, "&#%d;", PyUnicode_READ(kind, data, i));

  00540	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL?$AA@
  00547	49 8b cf	 mov	 rcx, r15
  0054a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf
  00550	4c 8b 45 07	 mov	 r8, QWORD PTR $T151232[rbp-137]
  00554	49 ff c6	 inc	 r14
  00557	48 63 c8	 movsxd	 rcx, eax
  0055a	4c 03 f9	 add	 r15, rcx
  0055d	4c 3b f3	 cmp	 r14, rbx
  00560	7c be		 jl	 SHORT $LL38@unicode_en@2

; 6514 :                 }
; 6515 :                 pos = collend;
; 6516 :                 break;

  00562	eb 1b		 jmp	 SHORT $LN36@unicode_en@2
$LN153@unicode_en@2:

; 6474 :             case 2: /* replace */
; 6475 :                 while (collstart++<collend)

  00564	4c 3b f3	 cmp	 r14, rbx
  00567	7d 1a		 jge	 SHORT $LN60@unicode_en@2
  00569	48 8b fb	 mov	 rdi, rbx
  0056c	b2 3f		 mov	 dl, 63			; 0000003fH
  0056e	49 8b cf	 mov	 rcx, r15
  00571	49 2b fe	 sub	 rdi, r14
  00574	4c 8b c7	 mov	 r8, rdi
  00577	e8 00 00 00 00	 call	 memset
  0057c	4c 03 ff	 add	 r15, rdi
$LN36@unicode_en@2:
  0057f	4c 8b 4d e7	 mov	 r9, QWORD PTR size$1$[rbp-137]
$LN60@unicode_en@2:

; 6476 :                     *str++ = '?'; /* fall through */
; 6477 :             case 3: /* ignore */
; 6478 :                 pos = collend;

  00583	4c 8b f3	 mov	 r14, rbx
  00586	48 8b 5d cf	 mov	 rbx, QWORD PTR ressize$1$[rbp-137]
$LN63@unicode_en@2:

; 6437 : 
; 6438 :     while (pos < size) {

  0058a	4d 3b f1	 cmp	 r14, r9
  0058d	7d 41		 jge	 SHORT $LN170@unicode_en@2
  0058f	4c 8b 45 07	 mov	 r8, QWORD PTR $T151232[rbp-137]
  00593	e9 92 fb ff ff	 jmp	 $LN177@unicode_en@2
$LN154@unicode_en@2:

; 6564 :                         raise_encode_exception(&exc, encoding, unicode,
; 6565 :                                                pos, pos+1, reason);

  00598	48 8b 4d f7	 mov	 rcx, QWORD PTR reason$1$[rbp-137]
  0059c	4c 8b 45 67	 mov	 r8, QWORD PTR unicode$[rbp-137]
  005a0	48 8b 55 ff	 mov	 rdx, QWORD PTR encoding$1$[rbp-137]
  005a4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005a9	49 8d 46 01	 lea	 rax, QWORD PTR [r14+1]
  005ad	48 8d 4d d7	 lea	 rcx, QWORD PTR exc$[rbp-137]
  005b1	4d 8b ce	 mov	 r9, r14
  005b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005b9	e8 00 00 00 00	 call	 raise_encode_exception
$LN156@unicode_en@2:

; 6566 :                         Py_DECREF(repunicode);

  005be	48 8b cf	 mov	 rcx, rdi
  005c1	e8 00 00 00 00	 call	 _Py_DecRef

; 6567 :                         goto onError;

  005c6	48 8b 75 df	 mov	 rsi, QWORD PTR errorHandler$[rbp-137]
  005ca	48 8b 7d d7	 mov	 rdi, QWORD PTR exc$[rbp-137]
  005ce	eb 2d		 jmp	 SHORT $onError$132426
$LN170@unicode_en@2:

; 6505 :                         requiredsize = 2*ressize;
; 6506 :                     if (_PyBytes_Resize(&res, requiredsize))

  005d0	4c 8b 65 df	 mov	 r12, QWORD PTR errorHandler$[rbp-137]
  005d4	48 8b 7d d7	 mov	 rdi, QWORD PTR exc$[rbp-137]
  005d8	4c 89 65 ef	 mov	 QWORD PTR errorHandler$1$[rbp-137], r12
$LN79@unicode_en@2:

; 6573 :             }
; 6574 :         }
; 6575 :     }
; 6576 :     /* Resize if we allocated to much */
; 6577 :     size = str - PyBytes_AS_STRING(res);

  005dc	4c 2b 7d c7	 sub	 r15, QWORD PTR res$[rbp-137]
  005e0	49 83 ef 78	 sub	 r15, 120		; 00000078H

; 6578 :     if (size < ressize) { /* If this falls res will be NULL */

  005e4	4c 3b fb	 cmp	 r15, rbx
  005e7	7d 6f		 jge	 SHORT $LN20@unicode_en@2

; 6579 :         assert(size >= 0);
; 6580 :         if (_PyBytes_Resize(&res, size) < 0)

  005e9	48 8d 4d c7	 lea	 rcx, QWORD PTR res$[rbp-137]
  005ed	49 8b d7	 mov	 rdx, r15
  005f0	e8 00 00 00 00	 call	 _PyBytes_Resize
  005f5	85 c0		 test	 eax, eax
  005f7	79 5f		 jns	 SHORT $LN20@unicode_en@2
  005f9	48 8b 75 ef	 mov	 rsi, QWORD PTR errorHandler$1$[rbp-137]
$onError$132426:

; 6587 : 
; 6588 :   onError:
; 6589 :     Py_XDECREF(res);

  005fd	48 8b 4d c7	 mov	 rcx, QWORD PTR res$[rbp-137]
  00601	48 85 c9	 test	 rcx, rcx
  00604	74 05		 je	 SHORT $LN11@unicode_en@2
  00606	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@unicode_en@2:

; 6590 :     Py_XDECREF(errorHandler);

  0060b	48 85 f6	 test	 rsi, rsi
  0060e	74 08		 je	 SHORT $LN7@unicode_en@2
  00610	48 8b ce	 mov	 rcx, rsi
  00613	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@unicode_en@2:

; 6591 :     Py_XDECREF(exc);

  00618	48 85 ff	 test	 rdi, rdi
  0061b	74 08		 je	 SHORT $LN3@unicode_en@2
  0061d	48 8b cf	 mov	 rcx, rdi
  00620	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@unicode_en@2:

; 6592 :     return NULL;

  00625	33 c0		 xor	 eax, eax
  00627	e9 07 01 00 00	 jmp	 $LN176@unicode_en@2
$LN62@unicode_en@2:

; 6471 :             case 1: /* strict */
; 6472 :                 raise_encode_exception(&exc, encoding, unicode, collstart, collend, reason);

  0062c	48 8b 45 f7	 mov	 rax, QWORD PTR reason$1$[rbp-137]
  00630	4c 8b 45 67	 mov	 r8, QWORD PTR unicode$[rbp-137]
  00634	48 8b 55 ff	 mov	 rdx, QWORD PTR encoding$1$[rbp-137]
  00638	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0063d	48 8d 4d d7	 lea	 rcx, QWORD PTR exc$[rbp-137]
  00641	4d 8b ce	 mov	 r9, r14
  00644	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00649	e8 00 00 00 00	 call	 raise_encode_exception
$LN166@unicode_en@2:

; 6473 :                 goto onError;

  0064e	48 8b 75 df	 mov	 rsi, QWORD PTR errorHandler$[rbp-137]
  00652	48 8b 7d d7	 mov	 rdi, QWORD PTR exc$[rbp-137]
  00656	eb a5		 jmp	 SHORT $onError$132426
$LN20@unicode_en@2:

; 6581 :             goto onError;
; 6582 :     }
; 6583 : 
; 6584 :     Py_XDECREF(errorHandler);

  00658	4d 85 e4	 test	 r12, r12
  0065b	74 68		 je	 SHORT $LN19@unicode_en@2
  0065d	e8 00 00 00 00	 call	 _Py_PXCTX
  00662	85 c0		 test	 eax, eax
  00664	75 5f		 jne	 SHORT $LN19@unicode_en@2
  00666	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  0066b	a8 20		 test	 al, 32			; 00000020H
  0066d	75 4e		 jne	 SHORT $LN130@unicode_en@2
  0066f	84 c0		 test	 al, al
  00671	78 4a		 js	 SHORT $LN130@unicode_en@2
  00673	a8 02		 test	 al, 2
  00675	75 4e		 jne	 SHORT $LN19@unicode_en@2
  00677	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  0067c	75 47		 jne	 SHORT $LN19@unicode_en@2
  0067e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00685	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0068c	4d 8b cc	 mov	 r9, r12
  0068f	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00695	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0069d	e8 00 00 00 00	 call	 _PyParallel_Guard
  006a2	49 8b cc	 mov	 rcx, r12
  006a5	85 c0		 test	 eax, eax
  006a7	74 07		 je	 SHORT $LN135@unicode_en@2
  006a9	e8 00 00 00 00	 call	 _Px_Dealloc
  006ae	eb 15		 jmp	 SHORT $LN19@unicode_en@2
$LN135@unicode_en@2:
  006b0	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  006b5	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  006bb	eb 08		 jmp	 SHORT $LN19@unicode_en@2
$LN130@unicode_en@2:
  006bd	49 8b cc	 mov	 rcx, r12
  006c0	e8 00 00 00 00	 call	 Px_DecRef
$LN19@unicode_en@2:

; 6585 :     Py_XDECREF(exc);

  006c5	48 85 ff	 test	 rdi, rdi
  006c8	74 65		 je	 SHORT $LN15@unicode_en@2
  006ca	e8 00 00 00 00	 call	 _Py_PXCTX
  006cf	85 c0		 test	 eax, eax
  006d1	75 5c		 jne	 SHORT $LN15@unicode_en@2
  006d3	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  006d7	a8 20		 test	 al, 32			; 00000020H
  006d9	75 4c		 jne	 SHORT $LN141@unicode_en@2
  006db	84 c0		 test	 al, al
  006dd	78 48		 js	 SHORT $LN141@unicode_en@2
  006df	a8 02		 test	 al, 2
  006e1	75 4c		 jne	 SHORT $LN15@unicode_en@2
  006e3	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  006e7	75 46		 jne	 SHORT $LN15@unicode_en@2
  006e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  006f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  006f7	4c 8b cf	 mov	 r9, rdi
  006fa	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00700	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00708	e8 00 00 00 00	 call	 _PyParallel_Guard
  0070d	48 8b cf	 mov	 rcx, rdi
  00710	85 c0		 test	 eax, eax
  00712	74 07		 je	 SHORT $LN146@unicode_en@2
  00714	e8 00 00 00 00	 call	 _Px_Dealloc
  00719	eb 14		 jmp	 SHORT $LN15@unicode_en@2
$LN146@unicode_en@2:
  0071b	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0071f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00725	eb 08		 jmp	 SHORT $LN15@unicode_en@2
$LN141@unicode_en@2:
  00727	48 8b cf	 mov	 rcx, rdi
  0072a	e8 00 00 00 00	 call	 Px_DecRef
$LN15@unicode_en@2:

; 6586 :     return res;

  0072f	48 8b 45 c7	 mov	 rax, QWORD PTR res$[rbp-137]
$LN176@unicode_en@2:
  00733	4c 8b bc 24 a8
	00 00 00	 mov	 r15, QWORD PTR [rsp+168]
$LN175@unicode_en@2:
  0073b	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+184]
  00743	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR [rsp+176]

; 6593 : }

  0074b	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  00752	41 5e		 pop	 r14
  00754	41 5c		 pop	 r12
  00756	5f		 pop	 rdi
  00757	5b		 pop	 rbx
  00758	5d		 pop	 rbp
  00759	c3		 ret	 0
unicode_encode_ucs1 ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_AsLatin1String
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_AsLatin1String DD imagerel $LN13
	DD	imagerel $LN13+192
	DD	imagerel $unwind$_PyUnicode_AsLatin1String
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_AsLatin1String DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_AsLatin1String
_TEXT	SEGMENT
unicode$ = 48
errors$ = 56
_PyUnicode_AsLatin1String PROC				; COMDAT

; 6612 : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 6613 :     if (!PyUnicode_Check(unicode)) {

  0000a	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0001e	75 12		 jne	 SHORT $LN3@PyUnicode_@25

; 6614 :         PyErr_BadArgument();

  00020	e8 00 00 00 00	 call	 PyErr_BadArgument
$LN12@PyUnicode_@25:

; 6615 :         return NULL;

  00025	33 c0		 xor	 eax, eax

; 6627 : }

  00027	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN3@PyUnicode_@25:

; 6616 :     }
; 6617 :     if (PyUnicode_READY(unicode) == -1)

  00032	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00036	75 0a		 jne	 SHORT $LN2@PyUnicode_@25
  00038	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0003d	83 f8 ff	 cmp	 eax, -1

; 6618 :         return NULL;

  00040	74 e3		 je	 SHORT $LN12@PyUnicode_@25
$LN2@PyUnicode_@25:

; 6619 :     /* Fast path: if it is a one-byte string, construct
; 6620 :        bytes object directly. */
; 6621 :     if (PyUnicode_KIND(unicode) == PyUnicode_1BYTE_KIND)

  00042	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00045	8b c1		 mov	 eax, ecx
  00047	24 1c		 and	 al, 28
  00049	3c 04		 cmp	 al, 4
  0004b	75 58		 jne	 SHORT $LN1@PyUnicode_@25

; 6622 :         return PyBytes_FromStringAndSize(PyUnicode_DATA(unicode),
; 6623 :                                          PyUnicode_GET_LENGTH(unicode));

  0004d	f6 c1 20	 test	 cl, 32			; 00000020H
  00050	74 39		 je	 SHORT $LN10@PyUnicode_@25
  00052	f6 c1 40	 test	 cl, 64			; 00000040H
  00055	74 1a		 je	 SHORT $LN8@PyUnicode_@25
  00057	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  0005b	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]

; 6627 : }

  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5f		 pop	 rdi
  0006c	e9 00 00 00 00	 jmp	 PyBytes_FromStringAndSize
$LN8@PyUnicode_@25:

; 6622 :         return PyBytes_FromStringAndSize(PyUnicode_DATA(unicode),
; 6623 :                                          PyUnicode_GET_LENGTH(unicode));

  00071	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  00075	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]

; 6627 : }

  0007c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00081	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00085	5f		 pop	 rdi
  00086	e9 00 00 00 00	 jmp	 PyBytes_FromStringAndSize
$LN10@PyUnicode_@25:

; 6622 :         return PyBytes_FromStringAndSize(PyUnicode_DATA(unicode),
; 6623 :                                          PyUnicode_GET_LENGTH(unicode));

  0008b	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
  00092	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]

; 6627 : }

  00096	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009f	5f		 pop	 rdi
  000a0	e9 00 00 00 00	 jmp	 PyBytes_FromStringAndSize
$LN1@PyUnicode_@25:

; 6624 :     /* Non-Latin-1 characters present. Defer to above function to
; 6625 :        raise the exception. */
; 6626 :     return unicode_encode_ucs1(unicode, errors, 256);

  000a5	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  000ab	48 8b d7	 mov	 rdx, rdi
  000ae	48 8b cb	 mov	 rcx, rbx

; 6627 : }

  000b1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ba	5f		 pop	 rdi
  000bb	e9 00 00 00 00	 jmp	 unicode_encode_ucs1
_PyUnicode_AsLatin1String ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsLatin1String
; Function compile flags: /Ogtpy
;	COMDAT PyUnicode_AsLatin1String
_TEXT	SEGMENT
unicode$ = 8
PyUnicode_AsLatin1String PROC				; COMDAT

; 6632 :     return _PyUnicode_AsLatin1String(unicode, NULL);

  00000	33 d2		 xor	 edx, edx

; 6633 : }

  00002	e9 00 00 00 00	 jmp	 _PyUnicode_AsLatin1String
PyUnicode_AsLatin1String ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_AsASCIIString
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_AsASCIIString DD imagerel $LN18
	DD	imagerel $LN18+201
	DD	imagerel $unwind$_PyUnicode_AsASCIIString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_AsASCIIString DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_AsASCIIString
_TEXT	SEGMENT
unicode$ = 48
errors$ = 56
_PyUnicode_AsASCIIString PROC				; COMDAT

; 6722 : {

$LN18:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 6723 :     if (!PyUnicode_Check(unicode)) {

  0000a	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0001e	75 12		 jne	 SHORT $LN3@PyUnicode_@26

; 6724 :         PyErr_BadArgument();

  00020	e8 00 00 00 00	 call	 PyErr_BadArgument
$LN17@PyUnicode_@26:

; 6725 :         return NULL;

  00025	33 c0		 xor	 eax, eax

; 6735 : }

  00027	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN3@PyUnicode_@26:

; 6726 :     }
; 6727 :     if (PyUnicode_READY(unicode) == -1)

  00032	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00036	75 0a		 jne	 SHORT $LN2@PyUnicode_@26
  00038	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0003d	83 f8 ff	 cmp	 eax, -1

; 6728 :         return NULL;

  00040	74 e3		 je	 SHORT $LN17@PyUnicode_@26
$LN2@PyUnicode_@26:

; 6729 :     /* Fast path: if it is an ASCII-only string, construct bytes object
; 6730 :        directly. Else defer to above function to raise the exception. */
; 6731 :     if (PyUnicode_MAX_CHAR_VALUE(unicode) < 128)

  00042	44 8b 4b 70	 mov	 r9d, DWORD PTR [rbx+112]
  00046	41 8b c9	 mov	 ecx, r9d
  00049	c1 e9 06	 shr	 ecx, 6
  0004c	83 e1 01	 and	 ecx, 1
  0004f	75 42		 jne	 SHORT $LN16@PyUnicode_@26
  00051	41 8b d1	 mov	 edx, r9d
  00054	c1 ea 02	 shr	 edx, 2
  00057	83 e2 07	 and	 edx, 7
  0005a	83 fa 01	 cmp	 edx, 1
  0005d	74 19		 je	 SHORT $LN1@PyUnicode_@26
  0005f	83 fa 02	 cmp	 edx, 2
  00062	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH
  00067	41 ba ff ff 00
	00		 mov	 r10d, 65535		; 0000ffffH
  0006d	41 0f 44 c2	 cmove	 eax, r10d
  00071	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00076	72 1b		 jb	 SHORT $LN16@PyUnicode_@26
$LN1@PyUnicode_@26:

; 6734 :     return unicode_encode_ucs1(unicode, errors, 128);

  00078	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  0007e	48 8b d7	 mov	 rdx, rdi
  00081	48 8b cb	 mov	 rcx, rbx

; 6735 : }

  00084	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00089	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008d	5f		 pop	 rdi
  0008e	e9 00 00 00 00	 jmp	 unicode_encode_ucs1
$LN16@PyUnicode_@26:

; 6732 :         return PyBytes_FromStringAndSize(PyUnicode_DATA(unicode),
; 6733 :                                          PyUnicode_GET_LENGTH(unicode));

  00093	41 f6 c1 20	 test	 r9b, 32			; 00000020H
  00097	74 16		 je	 SHORT $LN14@PyUnicode_@26
  00099	85 c9		 test	 ecx, ecx
  0009b	74 09		 je	 SHORT $LN12@PyUnicode_@26
  0009d	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  000a4	eb 10		 jmp	 SHORT $LN15@PyUnicode_@26
$LN12@PyUnicode_@26:
  000a6	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  000ad	eb 07		 jmp	 SHORT $LN15@PyUnicode_@26
$LN14@PyUnicode_@26:
  000af	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
$LN15@PyUnicode_@26:
  000b6	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]

; 6735 : }

  000ba	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000bf	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c3	5f		 pop	 rdi
  000c4	e9 00 00 00 00	 jmp	 PyBytes_FromStringAndSize
_PyUnicode_AsASCIIString ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsASCIIString
; Function compile flags: /Ogtpy
;	COMDAT PyUnicode_AsASCIIString
_TEXT	SEGMENT
unicode$ = 8
PyUnicode_AsASCIIString PROC				; COMDAT

; 6740 :     return _PyUnicode_AsASCIIString(unicode, NULL);

  00000	33 d2		 xor	 edx, edx

; 6741 : }

  00002	e9 00 00 00 00	 jmp	 _PyUnicode_AsASCIIString
PyUnicode_AsASCIIString ENDP
_TEXT	ENDS
PUBLIC	??_C@_04OALOKMFL@cp?$CFu?$AA@			; `string'
PUBLIC	??_C@_07DENGCDMK@CP_UTF8?$AA@			; `string'
PUBLIC	??_C@_07LDEODPAF@CP_UTF7?$AA@			; `string'
PUBLIC	??_C@_04IHNDNLNK@mbcs?$AA@			; `string'
EXTRN	PyBytes_FromFormat:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$code_page_name DD imagerel code_page_name
	DD	imagerel code_page_name+113
	DD	imagerel $unwind$code_page_name
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$code_page_name DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_04OALOKMFL@cp?$CFu?$AA@
CONST	SEGMENT
??_C@_04OALOKMFL@cp?$CFu?$AA@ DB 'cp%u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DENGCDMK@CP_UTF8?$AA@
CONST	SEGMENT
??_C@_07DENGCDMK@CP_UTF8?$AA@ DB 'CP_UTF8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LDEODPAF@CP_UTF7?$AA@
CONST	SEGMENT
??_C@_07LDEODPAF@CP_UTF7?$AA@ DB 'CP_UTF7', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IHNDNLNK@mbcs?$AA@
CONST	SEGMENT
??_C@_04IHNDNLNK@mbcs?$AA@ DB 'mbcs', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT code_page_name
_TEXT	SEGMENT
code_page$ = 48
obj$ = 56
code_page_name PROC					; COMDAT

; 6757 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 6758 :     *obj = NULL;

  00009	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0

; 6759 :     if (code_page == CP_ACP)

  00010	85 c9		 test	 ecx, ecx
  00012	75 0d		 jne	 SHORT $LN4@code_page_

; 6760 :         return "mbcs";

  00014	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04IHNDNLNK@mbcs?$AA@

; 6770 : }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
$LN4@code_page_:

; 6761 :     if (code_page == CP_UTF7)

  00021	81 f9 e8 fd 00
	00		 cmp	 ecx, 65000		; 0000fde8H
  00027	75 0d		 jne	 SHORT $LN3@code_page_

; 6762 :         return "CP_UTF7";

  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07LDEODPAF@CP_UTF7?$AA@

; 6770 : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
$LN3@code_page_:

; 6763 :     if (code_page == CP_UTF8)

  00036	81 f9 e9 fd 00
	00		 cmp	 ecx, 65001		; 0000fde9H
  0003c	75 0d		 jne	 SHORT $LN2@code_page_

; 6764 :         return "CP_UTF8";

  0003e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07DENGCDMK@CP_UTF8?$AA@

; 6770 : }

  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
$LN2@code_page_:

; 6765 : 
; 6766 :     *obj = PyBytes_FromFormat("cp%u", code_page);

  0004b	8b d1		 mov	 edx, ecx
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04OALOKMFL@cp?$CFu?$AA@
  00054	e8 00 00 00 00	 call	 PyBytes_FromFormat
  00059	48 89 03	 mov	 QWORD PTR [rbx], rax

; 6767 :     if (*obj == NULL)

  0005c	48 85 c0	 test	 rax, rax
  0005f	75 06		 jne	 SHORT $LN1@code_page_

; 6770 : }

  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5b		 pop	 rbx
  00066	c3		 ret	 0
$LN1@code_page_:

; 6768 :         return NULL;
; 6769 :     return PyBytes_AS_STRING(*obj);

  00067	48 83 c0 78	 add	 rax, 120		; 00000078H

; 6770 : }

  0006b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006f	5b		 pop	 rbx
  00070	c3		 ret	 0
code_page_name ENDP
_TEXT	ENDS
EXTRN	__imp_CharPrevExA:PROC
EXTRN	__imp_IsDBCSLeadByteEx:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$is_dbcs_lead_byte DD imagerel is_dbcs_lead_byte
	DD	imagerel is_dbcs_lead_byte+144
	DD	imagerel $unwind$is_dbcs_lead_byte
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_dbcs_lead_byte DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT is_dbcs_lead_byte
_TEXT	SEGMENT
code_page$ = 48
s$ = 56
offset$ = 64
is_dbcs_lead_byte PROC					; COMDAT

; 6774 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 6775 :     const char *curr = s + offset;

  0000f	49 63 d8	 movsxd	 rbx, r8d
  00012	48 8b f2	 mov	 rsi, rdx
  00015	8b f9		 mov	 edi, ecx
  00017	48 03 da	 add	 rbx, rdx

; 6776 :     const char *prev;
; 6777 : 
; 6778 :     if (!IsDBCSLeadByteEx(code_page, *curr))

  0001a	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDBCSLeadByteEx
  00023	85 c0		 test	 eax, eax
  00025	75 10		 jne	 SHORT $LN4@is_dbcs_le

; 6790 :         return 1;
; 6791 :     return 0;
; 6792 : }

  00027	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5f		 pop	 rdi
  00036	c3		 ret	 0
$LN4@is_dbcs_le:

; 6779 :         return 0;
; 6780 : 
; 6781 :     prev = CharPrevExA(code_page, s, curr, 0);

  00037	45 33 c9	 xor	 r9d, r9d
  0003a	4c 8b c3	 mov	 r8, rbx
  0003d	48 8b d6	 mov	 rdx, rsi
  00040	0f b7 cf	 movzx	 ecx, di
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CharPrevExA

; 6782 :     if (prev == curr)

  00049	48 3b c3	 cmp	 rax, rbx
  0004c	75 15		 jne	 SHORT $LN3@is_dbcs_le
$LN7@is_dbcs_le:

; 6783 :         return 1;

  0004e	b8 01 00 00 00	 mov	 eax, 1

; 6790 :         return 1;
; 6791 :     return 0;
; 6792 : }

  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00058	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
$LN3@is_dbcs_le:

; 6784 :     /* FIXME: This code is limited to "true" double-byte encodings,
; 6785 :        as it assumes an incomplete character consists of a single
; 6786 :        byte. */
; 6787 :     if (curr - prev == 2)

  00063	48 2b d8	 sub	 rbx, rax
  00066	48 83 fb 02	 cmp	 rbx, 2

; 6788 :         return 1;

  0006a	74 e2		 je	 SHORT $LN7@is_dbcs_le

; 6789 :     if (!IsDBCSLeadByteEx(code_page, *prev))

  0006c	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0006f	8b cf		 mov	 ecx, edi
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDBCSLeadByteEx

; 6790 :         return 1;
; 6791 :     return 0;
; 6792 : }

  00077	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00081	33 c9		 xor	 ecx, ecx
  00083	85 c0		 test	 eax, eax
  00085	0f 94 c1	 sete	 cl
  00088	8b c1		 mov	 eax, ecx
  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
is_dbcs_lead_byte ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT decode_code_page_flags
_TEXT	SEGMENT
code_page$ = 8
decode_code_page_flags PROC				; COMDAT

; 6797 :     if (code_page == CP_UTF7) {

  00000	33 d2		 xor	 edx, edx
  00002	b8 08 00 00 00	 mov	 eax, 8
  00007	81 f9 e8 fd 00
	00		 cmp	 ecx, 65000		; 0000fde8H
  0000d	0f 44 c2	 cmove	 eax, edx

; 6798 :         /* The CP_UTF7 decoder only supports flags=0 */
; 6799 :         return 0;
; 6800 :     }
; 6801 :     else
; 6802 :         return MB_ERR_INVALID_CHARS;
; 6803 : }

  00010	c3		 ret	 0
decode_code_page_flags ENDP
_TEXT	ENDS
_BSS	SEGMENT
winver	DB	09cH DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$encode_code_page_flags DD imagerel encode_code_page_flags
	DD	imagerel encode_code_page_flags+54
	DD	imagerel $unwind$encode_code_page_flags
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$encode_code_page_flags DD imagerel encode_code_page_flags+54
	DD	imagerel encode_code_page_flags+91
	DD	imagerel $chain$1$encode_code_page_flags
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$encode_code_page_flags DD imagerel encode_code_page_flags+91
	DD	imagerel encode_code_page_flags+101
	DD	imagerel $chain$2$encode_code_page_flags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$encode_code_page_flags DD 021H
	DD	imagerel encode_code_page_flags
	DD	imagerel encode_code_page_flags+54
	DD	imagerel $unwind$encode_code_page_flags
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$encode_code_page_flags DD 040921H
	DD	07409H
	DD	026405H
	DD	imagerel encode_code_page_flags
	DD	imagerel encode_code_page_flags+54
	DD	imagerel $unwind$encode_code_page_flags
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encode_code_page_flags DD 010401H
	DD	0204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT encode_code_page_flags
_TEXT	SEGMENT
code_page$ = 16
errors$ = 24
encode_code_page_flags PROC				; COMDAT

; 7089 : {

  00000	48 83 ec 08	 sub	 rsp, 8

; 7090 :     if (code_page == CP_UTF8) {

  00004	81 f9 e9 fd 00
	00		 cmp	 ecx, 65001		; 0000fde9H
  0000a	75 16		 jne	 SHORT $LN8@encode_cod

; 7091 :         if (winver.dwMajorVersion >= 6)

  0000c	33 c0		 xor	 eax, eax
  0000e	83 3d 04 00 00
	00 06		 cmp	 DWORD PTR winver+4, 6
  00015	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0001a	0f 43 c1	 cmovae	 eax, ecx

; 7108 :     }
; 7109 : }

  0001d	48 83 c4 08	 add	 rsp, 8
  00021	c3		 ret	 0
$LN8@encode_cod:

; 7092 :             /* CP_UTF8 supports WC_ERR_INVALID_CHARS on Windows Vista
; 7093 :                and later */
; 7094 :             return WC_ERR_INVALID_CHARS;
; 7095 :         else
; 7096 :             /* CP_UTF8 only supports flags=0 on Windows older than Vista */
; 7097 :             return 0;
; 7098 :     }
; 7099 :     else if (code_page == CP_UTF7) {

  00022	81 f9 e8 fd 00
	00		 cmp	 ecx, 65000		; 0000fde8H
  00028	75 07		 jne	 SHORT $LN4@encode_cod
$LN11@encode_cod:

; 7100 :         /* CP_UTF7 only supports flags=0 */
; 7101 :         return 0;

  0002a	33 c0		 xor	 eax, eax

; 7108 :     }
; 7109 : }

  0002c	48 83 c4 08	 add	 rsp, 8
  00030	c3		 ret	 0
$LN4@encode_cod:

; 7102 :     }
; 7103 :     else {
; 7104 :         if (errors != NULL && strcmp(errors, "replace") == 0)

  00031	48 85 d2	 test	 rdx, rdx
  00034	74 25		 je	 SHORT $LN2@encode_cod
  00036	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0003b	48 89 3c 24	 mov	 QWORD PTR [rsp], rdi
  0003f	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_07CLEHDIEJ@replace?$AA@
  00046	48 8b f2	 mov	 rsi, rdx
  00049	b9 08 00 00 00	 mov	 ecx, 8
  0004e	f3 a6		 repe cmpsb
  00050	48 8b 3c 24	 mov	 rdi, QWORD PTR [rsp]
  00054	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]

; 7105 :             return 0;

  00059	74 cf		 je	 SHORT $LN11@encode_cod
$LN2@encode_cod:

; 7106 :         else
; 7107 :             return WC_NO_BEST_FIT_CHARS;

  0005b	b8 00 04 00 00	 mov	 eax, 1024		; 00000400H

; 7108 :     }
; 7109 : }

  00060	48 83 c4 08	 add	 rsp, 8
  00064	c3		 ret	 0
encode_code_page_flags ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@KMLDCHJG@unable?5to?5encode?5error?5handler?5r@ ; `string'
PUBLIC	??_C@_0BC@FAPGBEIN@invalid?5character?$AA@	; `string'
EXTRN	PyErr_SetFromWindowsErr:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_WideCharToMultiByte:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$encode_code_page_errors DD imagerel encode_code_page_errors
	DD	imagerel encode_code_page_errors+128
	DD	imagerel $unwind$encode_code_page_errors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$encode_code_page_errors DD imagerel encode_code_page_errors+128
	DD	imagerel encode_code_page_errors+1303
	DD	imagerel $chain$0$encode_code_page_errors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$encode_code_page_errors DD imagerel encode_code_page_errors+1303
	DD	imagerel encode_code_page_errors+1324
	DD	imagerel $chain$1$encode_code_page_errors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$encode_code_page_errors DD 021H
	DD	imagerel encode_code_page_errors
	DD	imagerel encode_code_page_errors+128
	DD	imagerel $unwind$encode_code_page_errors
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$encode_code_page_errors DD 020821H
	DD	01b7408H
	DD	imagerel encode_code_page_errors
	DD	imagerel encode_code_page_errors+128
	DD	imagerel $unwind$encode_code_page_errors
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encode_code_page_errors DD 091601H
	DD	0120116H
	DD	0e00df00fH
	DD	0c009d00bH
	DD	050066007H
	DD	03005H
xdata	ENDS
;	COMDAT ??_C@_0CP@KMLDCHJG@unable?5to?5encode?5error?5handler?5r@
CONST	SEGMENT
??_C@_0CP@KMLDCHJG@unable?5to?5encode?5error?5handler?5r@ DB 'unable to e'
	DB	'ncode error handler result to ASCII', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FAPGBEIN@invalid?5character?$AA@
CONST	SEGMENT
??_C@_0BC@FAPGBEIN@invalid?5character?$AA@ DB 'invalid character', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT encode_code_page_errors
_TEXT	SEGMENT
flags$1$ = 80
buffer$ = 84
exc$ = 88
encoding_obj$ = 96
endin$1$ = 104
encoding$1$ = 112
errorHandler$ = 120
newpos$ = 128
code_page$ = 208
outbytes$ = 216
unicode$ = 224
usedDefaultChar$ = 232
unicode_offset$ = 232
chars$133312 = 240
insize$ = 240
errors$ = 248
encode_code_page_errors PROC				; COMDAT

; 7219 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	53		 push	 rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	41 57		 push	 r15
  0000f	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 7220 :     const DWORD flags = encode_code_page_flags(code_page, errors);

  00016	48 8b b4 24 f8
	00 00 00	 mov	 rsi, QWORD PTR errors$[rsp]
  0001e	4c 8b f2	 mov	 r14, rdx
  00021	4d 8b e9	 mov	 r13, r9
  00024	48 8b d6	 mov	 rdx, rsi
  00027	4d 8b e0	 mov	 r12, r8
  0002a	44 8b f9	 mov	 r15d, ecx
  0002d	e8 00 00 00 00	 call	 encode_code_page_flags

; 7221 :     Py_ssize_t pos = unicode_offset;
; 7222 :     Py_ssize_t endin = unicode_offset + insize;

  00032	48 8b 9c 24 f0
	00 00 00	 mov	 rbx, QWORD PTR insize$[rsp]

; 7223 :     /* Ideally, we should get reason from FormatMessage. This is the Windows
; 7224 :        2000 English version of the message. */
; 7225 :     const char *reason = "invalid character";
; 7226 :     /* 4=maximum length of a UTF-8 sequence */
; 7227 :     char buffer[4];
; 7228 :     BOOL usedDefaultChar = FALSE, *pusedDefaultChar;
; 7229 :     Py_ssize_t outsize;
; 7230 :     char *out;
; 7231 :     PyObject *errorHandler = NULL;
; 7232 :     PyObject *exc = NULL;
; 7233 :     PyObject *encoding_obj = NULL;
; 7234 :     char *encoding;
; 7235 :     Py_ssize_t newpos, newoutsize;
; 7236 :     PyObject *rep;
; 7237 :     int ret = -1;
; 7238 : 
; 7239 :     assert(insize > 0);
; 7240 : 
; 7241 :     encoding = code_page_name(code_page, &encoding_obj);

  0003a	48 8d 54 24 60	 lea	 rdx, QWORD PTR encoding_obj$[rsp]
  0003f	89 44 24 50	 mov	 DWORD PTR flags$1$[rsp], eax
  00043	49 8d 04 19	 lea	 rax, QWORD PTR [r9+rbx]
  00047	41 8b cf	 mov	 ecx, r15d
  0004a	48 89 44 24 68	 mov	 QWORD PTR endin$1$[rsp], rax
  0004f	33 c0		 xor	 eax, eax
  00051	83 cd ff	 or	 ebp, -1
  00054	89 84 24 e8 00
	00 00		 mov	 DWORD PTR usedDefaultChar$[rsp], eax
  0005b	48 89 44 24 78	 mov	 QWORD PTR errorHandler$[rsp], rax
  00060	48 89 44 24 58	 mov	 QWORD PTR exc$[rsp], rax
  00065	48 89 44 24 60	 mov	 QWORD PTR encoding_obj$[rsp], rax
  0006a	e8 00 00 00 00	 call	 code_page_name
  0006f	48 8b d0	 mov	 rdx, rax
  00072	48 89 44 24 70	 mov	 QWORD PTR encoding$1$[rsp], rax

; 7242 :     if (encoding == NULL)

  00077	48 85 c0	 test	 rax, rax

; 7243 :         return -1;

  0007a	0f 84 97 04 00
	00		 je	 $LN98@encode_cod@2

; 7244 : 
; 7245 :     if (errors == NULL || strcmp(errors, "strict") == 0) {

  00080	48 89 bc 24 d8
	00 00 00	 mov	 QWORD PTR [rsp+216], rdi
  00088	48 85 f6	 test	 rsi, rsi
  0008b	0f 84 32 04 00
	00		 je	 $LN48@encode_cod@2
  00091	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  00098	b9 07 00 00 00	 mov	 ecx, 7
  0009d	f3 a6		 repe cmpsb
  0009f	0f 84 1e 04 00
	00		 je	 $LN48@encode_cod@2

; 7255 :     }
; 7256 : 
; 7257 :     if (code_page != CP_UTF8 && code_page != CP_UTF7)

  000a5	41 81 ff e9 fd
	00 00		 cmp	 r15d, 65001		; 0000fde9H
  000ac	74 13		 je	 SHORT $LN42@encode_cod@2
  000ae	41 81 ff e8 fd
	00 00		 cmp	 r15d, 65000		; 0000fde8H
  000b5	74 0a		 je	 SHORT $LN42@encode_cod@2

; 7258 :         pusedDefaultChar = &usedDefaultChar;

  000b7	4c 8d bc 24 e8
	00 00 00	 lea	 r15, QWORD PTR usedDefaultChar$[rsp]

; 7259 :     else

  000bf	eb 03		 jmp	 SHORT $LN41@encode_cod@2
$LN42@encode_cod@2:

; 7260 :         pusedDefaultChar = NULL;

  000c1	45 33 ff	 xor	 r15d, r15d
$LN41@encode_cod@2:

; 7261 : 
; 7262 :     if (Py_ARRAY_LENGTH(buffer) > PY_SSIZE_T_MAX / insize) {

  000c4	48 bf ff ff ff
	ff ff ff ff 7f	 mov	 rdi, 9223372036854775807 ; 7fffffffffffffffH
  000ce	48 8b c7	 mov	 rax, rdi
  000d1	48 99		 cdq
  000d3	48 f7 fb	 idiv	 rbx
  000d6	48 83 f8 04	 cmp	 rax, 4
  000da	73 0a		 jae	 SHORT $LN40@encode_cod@2

; 7263 :         PyErr_NoMemory();

  000dc	e8 00 00 00 00	 call	 PyErr_NoMemory

; 7264 :         goto error;

  000e1	e9 72 03 00 00	 jmp	 $error$133247
$LN40@encode_cod@2:

; 7265 :     }
; 7266 :     outsize = insize * Py_ARRAY_LENGTH(buffer);
; 7267 : 
; 7268 :     if (*outbytes == NULL) {

  000e6	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  000e9	48 8d 34 9d 00
	00 00 00	 lea	 rsi, QWORD PTR [rbx*4]
  000f1	48 85 c9	 test	 rcx, rcx
  000f4	75 1a		 jne	 SHORT $LN39@encode_cod@2

; 7269 :         /* Create string object */
; 7270 :         *outbytes = PyBytes_FromStringAndSize(NULL, outsize);

  000f6	48 8b d6	 mov	 rdx, rsi
  000f9	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000fe	49 89 06	 mov	 QWORD PTR [r14], rax

; 7271 :         if (*outbytes == NULL)

  00101	48 85 c0	 test	 rax, rax
  00104	0f 84 4e 03 00
	00		 je	 $error$133247

; 7272 :             goto error;
; 7273 :         out = PyBytes_AS_STRING(*outbytes);

  0010a	48 8d 58 78	 lea	 rbx, QWORD PTR [rax+120]

; 7274 :     }
; 7275 :     else {

  0010e	eb 36		 jmp	 SHORT $LN80@encode_cod@2
$LN39@encode_cod@2:

; 7276 :         /* Extend string object */
; 7277 :         Py_ssize_t n = PyBytes_Size(*outbytes);

  00110	e8 00 00 00 00	 call	 PyBytes_Size

; 7278 :         if (n > PY_SSIZE_T_MAX - outsize) {

  00115	48 2b fe	 sub	 rdi, rsi
  00118	48 8b d8	 mov	 rbx, rax
  0011b	48 3b c7	 cmp	 rax, rdi
  0011e	7e 0a		 jle	 SHORT $LN36@encode_cod@2

; 7279 :             PyErr_NoMemory();

  00120	e8 00 00 00 00	 call	 PyErr_NoMemory

; 7280 :             goto error;

  00125	e9 2e 03 00 00	 jmp	 $error$133247
$LN36@encode_cod@2:

; 7281 :         }
; 7282 :         if (_PyBytes_Resize(outbytes, n + outsize) < 0)

  0012a	48 8d 14 30	 lea	 rdx, QWORD PTR [rax+rsi]
  0012e	49 8b ce	 mov	 rcx, r14
  00131	e8 00 00 00 00	 call	 _PyBytes_Resize
  00136	85 c0		 test	 eax, eax
  00138	0f 88 1a 03 00
	00		 js	 $error$133247

; 7283 :             goto error;
; 7284 :         out = PyBytes_AS_STRING(*outbytes) + n;

  0013e	49 8b 06	 mov	 rax, QWORD PTR [r14]
  00141	48 8d 5c 18 78	 lea	 rbx, QWORD PTR [rax+rbx+120]
$LN80@encode_cod@2:

; 7285 :     }
; 7286 : 
; 7287 :     /* Encode the string character per character */
; 7288 :     while (pos < endin)

  00146	4c 3b 6c 24 68	 cmp	 r13, QWORD PTR endin$1$[rsp]
  0014b	0f 8d eb 02 00
	00		 jge	 $LN33@encode_cod@2
  00151	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:??_C@_0BC@FAPGBEIN@invalid?5character?$AA@
$LN94@encode_cod@2:

; 7289 :     {
; 7290 :         Py_UCS4 ch = PyUnicode_READ_CHAR(unicode, pos);

  00158	41 8b 44 24 70	 mov	 eax, DWORD PTR [r12+112]
  0015d	41 b8 00 24 00
	00		 mov	 r8d, 9216		; 00002400H
  00163	bf ff 03 00 00	 mov	 edi, 1023		; 000003ffH
  00168	8b c8		 mov	 ecx, eax
  0016a	ba 00 28 00 00	 mov	 edx, 10240		; 00002800H
  0016f	c1 e9 02	 shr	 ecx, 2
  00172	83 e1 07	 and	 ecx, 7
  00175	83 f9 01	 cmp	 ecx, 1
  00178	75 38		 jne	 SHORT $LN67@encode_cod@2
  0017a	a8 20		 test	 al, 32			; 00000020H
  0017c	74 25		 je	 SHORT $LN55@encode_cod@2
  0017e	a8 40		 test	 al, 64			; 00000040H
  00180	74 12		 je	 SHORT $LN53@encode_cod@2
  00182	49 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR [r12+128]
  0018a	42 0f b6 0c 28	 movzx	 ecx, BYTE PTR [rax+r13]
  0018f	e9 80 00 00 00	 jmp	 $LN66@encode_cod@2
$LN53@encode_cod@2:
  00194	49 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR [r12+160]
  0019c	42 0f b6 0c 28	 movzx	 ecx, BYTE PTR [rax+r13]
  001a1	eb 71		 jmp	 SHORT $LN66@encode_cod@2
$LN55@encode_cod@2:
  001a3	49 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR [r12+160]
  001ab	42 0f b6 0c 28	 movzx	 ecx, BYTE PTR [rax+r13]
  001b0	eb 62		 jmp	 SHORT $LN66@encode_cod@2
$LN67@encode_cod@2:
  001b2	83 f9 02	 cmp	 ecx, 2
  001b5	75 35		 jne	 SHORT $LN65@encode_cod@2
  001b7	a8 20		 test	 al, 32			; 00000020H
  001b9	74 22		 je	 SHORT $LN59@encode_cod@2
  001bb	a8 40		 test	 al, 64			; 00000040H
  001bd	74 0f		 je	 SHORT $LN57@encode_cod@2
  001bf	49 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR [r12+128]
  001c7	42 0f b7 0c 68	 movzx	 ecx, WORD PTR [rax+r13*2]
  001cc	eb 46		 jmp	 SHORT $LN66@encode_cod@2
$LN57@encode_cod@2:
  001ce	49 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR [r12+160]
  001d6	42 0f b7 0c 68	 movzx	 ecx, WORD PTR [rax+r13*2]
  001db	eb 37		 jmp	 SHORT $LN66@encode_cod@2
$LN59@encode_cod@2:
  001dd	49 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR [r12+160]
  001e5	42 0f b7 0c 68	 movzx	 ecx, WORD PTR [rax+r13*2]
  001ea	eb 28		 jmp	 SHORT $LN66@encode_cod@2
$LN65@encode_cod@2:
  001ec	a8 20		 test	 al, 32			; 00000020H
  001ee	74 18		 je	 SHORT $LN63@encode_cod@2
  001f0	a8 40		 test	 al, 64			; 00000040H
  001f2	74 0a		 je	 SHORT $LN61@encode_cod@2
  001f4	49 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR [r12+128]
  001fc	eb 12		 jmp	 SHORT $LN64@encode_cod@2
$LN61@encode_cod@2:
  001fe	49 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR [r12+160]
  00206	eb 08		 jmp	 SHORT $LN64@encode_cod@2
$LN63@encode_cod@2:
  00208	49 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR [r12+160]
$LN64@encode_cod@2:
  00210	42 8b 0c a8	 mov	 ecx, DWORD PTR [rax+r13*4]
$LN66@encode_cod@2:

; 7291 :         wchar_t chars[2];
; 7292 :         int charsize;
; 7293 :         if (ch < 0x10000) {

  00214	81 f9 00 00 01
	00		 cmp	 ecx, 65536		; 00010000H
  0021a	73 10		 jae	 SHORT $LN32@encode_cod@2

; 7294 :             chars[0] = (wchar_t)ch;

  0021c	66 89 8c 24 f0
	00 00 00	 mov	 WORD PTR chars$133312[rsp], cx

; 7295 :             charsize = 1;

  00224	41 b9 01 00 00
	00		 mov	 r9d, 1

; 7296 :         }
; 7297 :         else {

  0022a	eb 2b		 jmp	 SHORT $LN31@encode_cod@2
$LN32@encode_cod@2:

; 7298 :             ch -= 0x10000;

  0022c	81 c1 00 00 ff
	ff		 add	 ecx, -65536		; ffff0000H

; 7299 :             chars[0] = 0xd800 + (ch >> 10);
; 7300 :             chars[1] = 0xdc00 + (ch & 0x3ff);
; 7301 :             charsize = 2;

  00232	41 b9 02 00 00
	00		 mov	 r9d, 2
  00238	8b c1		 mov	 eax, ecx
  0023a	66 23 cf	 and	 cx, di
  0023d	c1 e8 0a	 shr	 eax, 10
  00240	66 2b c2	 sub	 ax, dx
  00243	66 41 2b c8	 sub	 cx, r8w
  00247	66 89 8c 24 f2
	00 00 00	 mov	 WORD PTR chars$133312[rsp+2], cx
  0024f	66 89 84 24 f0
	00 00 00	 mov	 WORD PTR chars$133312[rsp], ax
$LN31@encode_cod@2:

; 7302 :         }
; 7303 : 
; 7304 :         outsize = WideCharToMultiByte(code_page, flags,
; 7305 :                                       chars, charsize,
; 7306 :                                       buffer, Py_ARRAY_LENGTH(buffer),
; 7307 :                                       NULL, pusedDefaultChar);

  00257	8b 54 24 50	 mov	 edx, DWORD PTR flags$1$[rsp]
  0025b	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR code_page$[rsp]
  00262	4c 89 7c 24 38	 mov	 QWORD PTR [rsp+56], r15
  00267	48 8d 44 24 54	 lea	 rax, QWORD PTR buffer$[rsp]
  0026c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00275	4c 8d 84 24 f0
	00 00 00	 lea	 r8, QWORD PTR chars$133312[rsp]
  0027d	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR [rsp+40], 4
  00285	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0028a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WideCharToMultiByte
  00290	48 63 f8	 movsxd	 rdi, eax

; 7308 :         if (outsize > 0) {

  00293	85 c0		 test	 eax, eax
  00295	7e 26		 jle	 SHORT $LN30@encode_cod@2

; 7309 :             if (pusedDefaultChar == NULL || !(*pusedDefaultChar))

  00297	4d 85 ff	 test	 r15, r15
  0029a	74 06		 je	 SHORT $LN28@encode_cod@2
  0029c	41 83 3f 00	 cmp	 DWORD PTR [r15], 0
  002a0	75 2c		 jne	 SHORT $LN26@encode_cod@2
$LN28@encode_cod@2:

; 7310 :             {
; 7311 :                 pos++;
; 7312 :                 memcpy(out, buffer, outsize);

  002a2	48 8d 54 24 54	 lea	 rdx, QWORD PTR buffer$[rsp]
  002a7	4c 8b c7	 mov	 r8, rdi
  002aa	48 8b cb	 mov	 rcx, rbx
  002ad	49 ff c5	 inc	 r13
  002b0	e8 00 00 00 00	 call	 memcpy

; 7313 :                 out += outsize;

  002b5	48 03 df	 add	 rbx, rdi

; 7314 :                 continue;

  002b8	e9 71 01 00 00	 jmp	 $LN89@encode_cod@2
$LN30@encode_cod@2:

; 7315 :             }
; 7316 :         }
; 7317 :         else if (GetLastError() != ERROR_NO_UNICODE_TRANSLATION) {

  002bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  002c3	3d 59 04 00 00	 cmp	 eax, 1113		; 00000459H
  002c8	0f 85 e9 01 00
	00		 jne	 $LN83@encode_cod@2
$LN26@encode_cod@2:

; 7320 :         }
; 7321 : 
; 7322 :         rep = unicode_encode_call_errorhandler(
; 7323 :                   errors, &errorHandler, encoding, reason,
; 7324 :                   unicode, &exc,
; 7325 :                   pos, pos + 1, &newpos);

  002ce	4c 8b 44 24 70	 mov	 r8, QWORD PTR encoding$1$[rsp]
  002d3	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR newpos$[rsp]
  002db	49 8d 45 01	 lea	 rax, QWORD PTR [r13+1]
  002df	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002e4	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR errors$[rsp]
  002ec	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  002f1	48 8d 44 24 58	 lea	 rax, QWORD PTR exc$[rsp]
  002f6	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  002fb	48 8d 54 24 78	 lea	 rdx, QWORD PTR errorHandler$[rsp]
  00300	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00305	4c 8b ce	 mov	 r9, rsi
  00308	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  0030d	e8 00 00 00 00	 call	 unicode_encode_call_errorhandler
  00312	48 8b f0	 mov	 rsi, rax

; 7326 :         if (rep == NULL)

  00315	48 85 c0	 test	 rax, rax
  00318	0f 84 a0 01 00
	00		 je	 $LN91@encode_cod@2

; 7327 :             goto error;
; 7328 :         pos = newpos;
; 7329 : 
; 7330 :         if (PyBytes_Check(rep)) {

  0031e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00322	4c 8b ac 24 80
	00 00 00	 mov	 r13, QWORD PTR newpos$[rsp]
  0032a	f7 81 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rcx+256], 134217728 ; 08000000H
  00334	74 43		 je	 SHORT $LN24@encode_cod@2

; 7331 :             outsize = PyBytes_GET_SIZE(rep);

  00336	48 8b 78 60	 mov	 rdi, QWORD PTR [rax+96]

; 7332 :             if (outsize != 1) {

  0033a	48 83 ff 01	 cmp	 rdi, 1
  0033e	74 22		 je	 SHORT $LN23@encode_cod@2

; 7333 :                 Py_ssize_t offset = out - PyBytes_AS_STRING(*outbytes);

  00340	49 8b 06	 mov	 rax, QWORD PTR [r14]

; 7334 :                 newoutsize = PyBytes_GET_SIZE(*outbytes) + (outsize - 1);
; 7335 :                 if (_PyBytes_Resize(outbytes, newoutsize) < 0) {

  00343	49 8b ce	 mov	 rcx, r14
  00346	48 2b d8	 sub	 rbx, rax
  00349	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0034d	48 8d 54 38 ff	 lea	 rdx, QWORD PTR [rax+rdi-1]
  00352	e8 00 00 00 00	 call	 _PyBytes_Resize
  00357	85 c0		 test	 eax, eax
  00359	0f 88 4b 01 00
	00		 js	 $LN85@encode_cod@2

; 7336 :                     Py_DECREF(rep);
; 7337 :                     goto error;
; 7338 :                 }
; 7339 :                 out = PyBytes_AS_STRING(*outbytes) + offset;

  0035f	49 03 1e	 add	 rbx, QWORD PTR [r14]
$LN23@encode_cod@2:

; 7340 :             }
; 7341 :             memcpy(out, PyBytes_AS_STRING(rep), outsize);

  00362	48 8d 56 78	 lea	 rdx, QWORD PTR [rsi+120]
  00366	4c 8b c7	 mov	 r8, rdi
  00369	48 8b cb	 mov	 rcx, rbx
  0036c	e8 00 00 00 00	 call	 memcpy

; 7342 :             out += outsize;

  00371	48 03 df	 add	 rbx, rdi

; 7343 :         }
; 7344 :         else {

  00374	e9 a6 00 00 00	 jmp	 $LN15@encode_cod@2
$LN24@encode_cod@2:

; 7345 :             Py_ssize_t i;
; 7346 :             enum PyUnicode_Kind kind;
; 7347 :             void *data;
; 7348 : 
; 7349 :             if (PyUnicode_READY(rep) == -1) {

  00379	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  0037d	75 11		 jne	 SHORT $LN90@encode_cod@2
  0037f	48 8b c8	 mov	 rcx, rax
  00382	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00387	83 f8 ff	 cmp	 eax, -1
  0038a	0f 84 1a 01 00
	00		 je	 $LN85@encode_cod@2
$LN90@encode_cod@2:

; 7350 :                 Py_DECREF(rep);
; 7351 :                 goto error;
; 7352 :             }
; 7353 : 
; 7354 :             outsize = PyUnicode_GET_LENGTH(rep);

  00390	48 8b 6e 60	 mov	 rbp, QWORD PTR [rsi+96]

; 7355 :             if (outsize != 1) {

  00394	48 83 fd 01	 cmp	 rbp, 1
  00398	74 22		 je	 SHORT $LN19@encode_cod@2

; 7356 :                 Py_ssize_t offset = out - PyBytes_AS_STRING(*outbytes);

  0039a	49 8b 06	 mov	 rax, QWORD PTR [r14]

; 7357 :                 newoutsize = PyBytes_GET_SIZE(*outbytes) + (outsize - 1);
; 7358 :                 if (_PyBytes_Resize(outbytes, newoutsize) < 0) {

  0039d	49 8b ce	 mov	 rcx, r14
  003a0	48 2b d8	 sub	 rbx, rax
  003a3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  003a7	48 8d 54 28 ff	 lea	 rdx, QWORD PTR [rax+rbp-1]
  003ac	e8 00 00 00 00	 call	 _PyBytes_Resize
  003b1	85 c0		 test	 eax, eax
  003b3	0f 88 f1 00 00
	00		 js	 $LN85@encode_cod@2

; 7359 :                     Py_DECREF(rep);
; 7360 :                     goto error;
; 7361 :                 }
; 7362 :                 out = PyBytes_AS_STRING(*outbytes) + offset;

  003b9	49 03 1e	 add	 rbx, QWORD PTR [r14]
$LN19@encode_cod@2:

; 7363 :             }
; 7364 :             kind = PyUnicode_KIND(rep);

  003bc	8b 46 70	 mov	 eax, DWORD PTR [rsi+112]
  003bf	8b f8		 mov	 edi, eax
  003c1	c1 ef 02	 shr	 edi, 2
  003c4	83 e7 07	 and	 edi, 7

; 7365 :             data = PyUnicode_DATA(rep);

  003c7	a8 20		 test	 al, 32			; 00000020H
  003c9	74 16		 je	 SHORT $LN73@encode_cod@2
  003cb	a8 40		 test	 al, 64			; 00000040H
  003cd	74 09		 je	 SHORT $LN71@encode_cod@2
  003cf	48 8d 96 80 00
	00 00		 lea	 rdx, QWORD PTR [rsi+128]
  003d6	eb 10		 jmp	 SHORT $LN74@encode_cod@2
$LN71@encode_cod@2:
  003d8	48 8d 96 a0 00
	00 00		 lea	 rdx, QWORD PTR [rsi+160]
  003df	eb 07		 jmp	 SHORT $LN74@encode_cod@2
$LN73@encode_cod@2:
  003e1	48 8b 96 a0 00
	00 00		 mov	 rdx, QWORD PTR [rsi+160]
$LN74@encode_cod@2:

; 7366 :             for (i=0; i < outsize; i++) {

  003e8	33 c9		 xor	 ecx, ecx

; 7367 :                 Py_UCS4 ch = PyUnicode_READ(kind, data, i);

  003ea	48 63 ff	 movsxd	 rdi, edi
  003ed	48 85 ed	 test	 rbp, rbp
  003f0	7e 2d		 jle	 SHORT $LN15@encode_cod@2
$LL17@encode_cod@2:
  003f2	48 83 ff 01	 cmp	 rdi, 1
  003f6	75 06		 jne	 SHORT $LN77@encode_cod@2
  003f8	0f b6 04 11	 movzx	 eax, BYTE PTR [rcx+rdx]
  003fc	eb 0f		 jmp	 SHORT $LN76@encode_cod@2
$LN77@encode_cod@2:
  003fe	48 83 ff 02	 cmp	 rdi, 2
  00402	75 06		 jne	 SHORT $LN75@encode_cod@2
  00404	0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+rcx*2]
  00408	eb 03		 jmp	 SHORT $LN76@encode_cod@2
$LN75@encode_cod@2:
  0040a	8b 04 8a	 mov	 eax, DWORD PTR [rdx+rcx*4]
$LN76@encode_cod@2:

; 7368 :                 if (ch > 127) {

  0040d	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00410	77 6e		 ja	 SHORT $LN82@encode_cod@2

; 7375 :                 }
; 7376 :                 *out = (unsigned char)ch;

  00412	48 ff c1	 inc	 rcx
  00415	88 03		 mov	 BYTE PTR [rbx], al

; 7377 :                 out++;

  00417	48 ff c3	 inc	 rbx
  0041a	48 3b cd	 cmp	 rcx, rbp
  0041d	7c d3		 jl	 SHORT $LL17@encode_cod@2
$LN15@encode_cod@2:

; 7378 :             }
; 7379 :         }
; 7380 :         Py_DECREF(rep);

  0041f	48 8b ce	 mov	 rcx, rsi
  00422	e8 00 00 00 00	 call	 _Py_DecRef
  00427	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:??_C@_0BC@FAPGBEIN@invalid?5character?$AA@
$LN89@encode_cod@2:

; 7285 :     }
; 7286 : 
; 7287 :     /* Encode the string character per character */
; 7288 :     while (pos < endin)

  0042e	4c 3b 6c 24 68	 cmp	 r13, QWORD PTR endin$1$[rsp]
  00433	0f 8c 1f fd ff
	ff		 jl	 $LN94@encode_cod@2

; 7357 :                 newoutsize = PyBytes_GET_SIZE(*outbytes) + (outsize - 1);
; 7358 :                 if (_PyBytes_Resize(outbytes, newoutsize) < 0) {

  00439	83 cd ff	 or	 ebp, -1
$LN33@encode_cod@2:

; 7381 :     }
; 7382 :     /* write a NUL byte */
; 7383 :     *out = 0;

  0043c	c6 03 00	 mov	 BYTE PTR [rbx], 0

; 7384 :     outsize = out - PyBytes_AS_STRING(*outbytes);

  0043f	49 2b 1e	 sub	 rbx, QWORD PTR [r14]

; 7385 :     assert(outsize <= PyBytes_GET_SIZE(*outbytes));
; 7386 :     if (_PyBytes_Resize(outbytes, outsize) < 0)

  00442	49 8b ce	 mov	 rcx, r14
  00445	48 8d 53 88	 lea	 rdx, QWORD PTR [rbx-120]
  00449	e8 00 00 00 00	 call	 _PyBytes_Resize
  0044e	85 c0		 test	 eax, eax
  00450	b8 00 00 00 00	 mov	 eax, 0
  00455	0f 49 e8	 cmovns	 ebp, eax
$error$133247:

; 7387 :         goto error;
; 7388 :     ret = 0;
; 7389 : 
; 7390 : error:
; 7391 :     Py_XDECREF(encoding_obj);

  00458	48 8b 4c 24 60	 mov	 rcx, QWORD PTR encoding_obj$[rsp]
  0045d	48 85 c9	 test	 rcx, rcx
  00460	74 05		 je	 SHORT $LN11@encode_cod@2
  00462	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@encode_cod@2:

; 7392 :     Py_XDECREF(errorHandler);

  00467	48 8b 4c 24 78	 mov	 rcx, QWORD PTR errorHandler$[rsp]
  0046c	48 85 c9	 test	 rcx, rcx
  0046f	74 05		 je	 SHORT $LN7@encode_cod@2
  00471	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@encode_cod@2:

; 7393 :     Py_XDECREF(exc);

  00476	48 8b 4c 24 58	 mov	 rcx, QWORD PTR exc$[rsp]

; 7394 :     return ret;

  0047b	e9 85 00 00 00	 jmp	 $LN97@encode_cod@2
$LN82@encode_cod@2:

; 7369 :                     raise_encode_exception(&exc,
; 7370 :                         encoding, unicode,
; 7371 :                         pos, pos + 1,
; 7372 :                         "unable to encode error handler result to ASCII");

  00480	48 8b 54 24 70	 mov	 rdx, QWORD PTR encoding$1$[rsp]
  00485	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CP@KMLDCHJG@unable?5to?5encode?5error?5handler?5r@
  0048c	49 8d 45 01	 lea	 rax, QWORD PTR [r13+1]
  00490	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00495	48 8d 4c 24 58	 lea	 rcx, QWORD PTR exc$[rsp]
  0049a	4d 8b cd	 mov	 r9, r13
  0049d	4d 8b c4	 mov	 r8, r12
  004a0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004a5	e8 00 00 00 00	 call	 raise_encode_exception
$LN85@encode_cod@2:

; 7373 :                     Py_DECREF(rep);

  004aa	48 8b ce	 mov	 rcx, rsi
  004ad	e8 00 00 00 00	 call	 _Py_DecRef

; 7374 :                     goto error;

  004b2	83 cd ff	 or	 ebp, -1
  004b5	eb a1		 jmp	 SHORT $error$133247
$LN83@encode_cod@2:

; 7318 :             PyErr_SetFromWindowsErr(0);

  004b7	33 c9		 xor	 ecx, ecx
  004b9	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
$LN91@encode_cod@2:

; 7319 :             goto error;

  004be	83 cd ff	 or	 ebp, -1
  004c1	eb 95		 jmp	 SHORT $error$133247
$LN48@encode_cod@2:

; 7246 :         /* The last error was ERROR_NO_UNICODE_TRANSLATION,
; 7247 :            then we raise a UnicodeEncodeError. */
; 7248 :         make_encode_exception(&exc, encoding, unicode, 0, 0, reason);

  004c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@FAPGBEIN@invalid?5character?$AA@
  004ca	48 8d 4c 24 58	 lea	 rcx, QWORD PTR exc$[rsp]
  004cf	45 33 c9	 xor	 r9d, r9d
  004d2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004d7	33 c0		 xor	 eax, eax
  004d9	4d 8b c4	 mov	 r8, r12
  004dc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004e1	e8 00 00 00 00	 call	 make_encode_exception

; 7249 :         if (exc != NULL) {

  004e6	48 8b 7c 24 58	 mov	 rdi, QWORD PTR exc$[rsp]
  004eb	48 85 ff	 test	 rdi, rdi
  004ee	74 10		 je	 SHORT $LN46@encode_cod@2

; 7250 :             PyCodec_StrictErrors(exc);

  004f0	48 8b cf	 mov	 rcx, rdi
  004f3	e8 00 00 00 00	 call	 PyCodec_StrictErrors

; 7251 :             Py_DECREF(exc);

  004f8	48 8b cf	 mov	 rcx, rdi
  004fb	e8 00 00 00 00	 call	 _Py_DecRef
$LN46@encode_cod@2:

; 7252 :         }
; 7253 :         Py_XDECREF(encoding_obj);

  00500	48 8b 4c 24 60	 mov	 rcx, QWORD PTR encoding_obj$[rsp]
$LN97@encode_cod@2:
  00505	48 85 c9	 test	 rcx, rcx
  00508	74 05		 je	 SHORT $LN45@encode_cod@2
  0050a	e8 00 00 00 00	 call	 _Py_DecRef
$LN45@encode_cod@2:
  0050f	48 8b bc 24 d8
	00 00 00	 mov	 rdi, QWORD PTR [rsp+216]
$LN98@encode_cod@2:

; 7254 :         return -1;

  00517	8b c5		 mov	 eax, ebp

; 7395 : }

  00519	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  00520	41 5f		 pop	 r15
  00522	41 5e		 pop	 r14
  00524	41 5d		 pop	 r13
  00526	41 5c		 pop	 r12
  00528	5e		 pop	 rsi
  00529	5d		 pop	 rbp
  0052a	5b		 pop	 rbx
  0052b	c3		 ret	 0
encode_code_page_errors ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT encoding_map_size
_TEXT	SEGMENT
obj$ = 8
args$ = 16
encoding_map_size PROC					; COMDAT

; 7722 :     struct encoding_map *map = (struct encoding_map*)obj;
; 7723 :     return PyLong_FromLong(sizeof(*map) - 1 + 16*map->count2 +
; 7724 :                            128*map->count3);

  00000	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [rcx+132]
  00006	8b 81 80 00 00
	00		 mov	 eax, DWORD PTR [rcx+128]
  0000c	8d 0c d0	 lea	 ecx, DWORD PTR [rax+rdx*8]
  0000f	c1 e1 04	 shl	 ecx, 4
  00012	81 c1 8f 00 00
	00		 add	 ecx, 143		; 0000008fH

; 7725 : }

  00018	e9 00 00 00 00	 jmp	 PyLong_FromLong
encoding_map_size ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT encoding_map_dealloc
_TEXT	SEGMENT
o$ = 8
encoding_map_dealloc PROC				; COMDAT

; 7736 :     PyObject_FREE(o);
; 7737 : }

  00000	e9 00 00 00 00	 jmp	 PyObject_Free
encoding_map_dealloc ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_BuildEncodingMap
EXTRN	PyObject_Init:PROC
EXTRN	PyDict_SetItem:PROC
EXTRN	PyDict_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyUnicode_BuildEncodingMap DD imagerel $LN106
	DD	imagerel $LN106+59
	DD	imagerel $unwind$PyUnicode_BuildEncodingMap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyUnicode_BuildEncodingMap DD imagerel $LN106+59
	DD	imagerel $LN106+855
	DD	imagerel $chain$3$PyUnicode_BuildEncodingMap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyUnicode_BuildEncodingMap DD imagerel $LN106+855
	DD	imagerel $LN106+1197
	DD	imagerel $chain$5$PyUnicode_BuildEncodingMap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$PyUnicode_BuildEncodingMap DD imagerel $LN106+1197
	DD	imagerel $LN106+1218
	DD	imagerel $chain$6$PyUnicode_BuildEncodingMap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$PyUnicode_BuildEncodingMap DD 021H
	DD	imagerel $LN106
	DD	imagerel $LN106+59
	DD	imagerel $unwind$PyUnicode_BuildEncodingMap
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyUnicode_BuildEncodingMap DD 080021H
	DD	04af400H
	DD	04bc400H
	DD	04c7400H
	DD	0556400H
	DD	imagerel $LN106
	DD	imagerel $LN106+59
	DD	imagerel $unwind$PyUnicode_BuildEncodingMap
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyUnicode_BuildEncodingMap DD 081321H
	DD	04af413H
	DD	04bc40cH
	DD	04c7408H
	DD	0556404H
	DD	imagerel $LN106
	DD	imagerel $LN106+59
	DD	imagerel $unwind$PyUnicode_BuildEncodingMap
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_BuildEncodingMap DD 061001H
	DD	04d0110H
	DD	0d007e009H
	DD	030045005H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT PyUnicode_BuildEncodingMap
_TEXT	SEGMENT
level1$ = 48
level2$ = 80
mlevel3$1$ = 656
result$1$ = 656
string$ = 656
tv627 = 664
tv628 = 672
PyUnicode_BuildEncodingMap PROC				; COMDAT

; 7785 : {

$LN106:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	55		 push	 rbp
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	48 81 ec 68 02
	00 00		 sub	 rsp, 616		; 00000268H

; 7786 :     PyObject *result;
; 7787 :     struct encoding_map *mresult;
; 7788 :     int i;
; 7789 :     int need_dict = 0;
; 7790 :     unsigned char level1[32];
; 7791 :     unsigned char level2[512];
; 7792 :     unsigned char *mlevel1, *mlevel2, *mlevel3;
; 7793 :     int count2 = 0, count3 = 0;
; 7794 :     int kind;
; 7795 :     void *data;
; 7796 :     Py_ssize_t length;
; 7797 :     Py_UCS4 ch;
; 7798 : 
; 7799 :     if (!PyUnicode_Check(string) || !PyUnicode_GET_LENGTH(string)) {

  00010	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00014	33 db		 xor	 ebx, ebx
  00016	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00020	44 8b eb	 mov	 r13d, ebx
  00023	8b eb		 mov	 ebp, ebx
  00025	0f 84 82 04 00
	00		 je	 $LN34@PyUnicode_@27
  0002b	4c 8b 71 60	 mov	 r14, QWORD PTR [rcx+96]
  0002f	4d 85 f6	 test	 r14, r14
  00032	0f 84 75 04 00
	00		 je	 $LN34@PyUnicode_@27

; 7802 :     }
; 7803 :     kind = PyUnicode_KIND(string);

  00038	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  0003b	49 89 73 20	 mov	 QWORD PTR [r11+32], rsi
  0003f	49 89 7b d8	 mov	 QWORD PTR [r11-40], rdi
  00043	4d 89 63 d0	 mov	 QWORD PTR [r11-48], r12
  00047	44 8b e0	 mov	 r12d, eax
  0004a	4d 89 7b c8	 mov	 QWORD PTR [r11-56], r15
  0004e	41 c1 ec 02	 shr	 r12d, 2
  00052	41 83 e4 07	 and	 r12d, 7

; 7804 :     data = PyUnicode_DATA(string);

  00056	a8 20		 test	 al, 32			; 00000020H
  00058	74 16		 je	 SHORT $LN40@PyUnicode_@27
  0005a	a8 40		 test	 al, 64			; 00000040H
  0005c	74 09		 je	 SHORT $LN38@PyUnicode_@27
  0005e	48 8d b9 80 00
	00 00		 lea	 rdi, QWORD PTR [rcx+128]
  00065	eb 10		 jmp	 SHORT $LN41@PyUnicode_@27
$LN38@PyUnicode_@27:
  00067	48 8d b9 a0 00
	00 00		 lea	 rdi, QWORD PTR [rcx+160]
  0006e	eb 07		 jmp	 SHORT $LN41@PyUnicode_@27
$LN40@PyUnicode_@27:
  00070	48 8b b9 a0 00
	00 00		 mov	 rdi, QWORD PTR [rcx+160]
$LN41@PyUnicode_@27:

; 7805 :     length = PyUnicode_GET_LENGTH(string);
; 7806 :     length = Py_MIN(length, 256);

  00077	b8 00 01 00 00	 mov	 eax, 256		; 00000100H

; 7807 :     memset(level1, 0xFF, sizeof level1);
; 7808 :     memset(level2, 0xFF, sizeof level2);

  0007c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR level2$[rsp]
  00081	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00087	4c 3b f0	 cmp	 r14, rax
  0008a	8d 50 ff	 lea	 edx, QWORD PTR [rax-1]
  0008d	4c 0f 4f f0	 cmovg	 r14, rax
  00091	49 83 cf ff	 or	 r15, -1
  00095	4c 89 7c 24 30	 mov	 QWORD PTR level1$[rsp], r15
  0009a	4c 89 7c 24 38	 mov	 QWORD PTR level1$[rsp+8], r15
  0009f	4c 89 7c 24 40	 mov	 QWORD PTR level1$[rsp+16], r15
  000a4	4c 89 7c 24 48	 mov	 QWORD PTR level1$[rsp+24], r15
  000a9	e8 00 00 00 00	 call	 memset

; 7809 : 
; 7810 :     /* If there isn't a one-to-one mapping of NULL to \0,
; 7811 :        or if there are non-BMP characters, we need to use
; 7812 :        a mapping dictionary. */
; 7813 :     if (PyUnicode_READ(kind, data, 0) != 0)

  000ae	41 83 fc 01	 cmp	 r12d, 1
  000b2	75 05		 jne	 SHORT $LN44@PyUnicode_@27
  000b4	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  000b7	eb 0d		 jmp	 SHORT $LN43@PyUnicode_@27
$LN44@PyUnicode_@27:
  000b9	41 83 fc 02	 cmp	 r12d, 2
  000bd	75 05		 jne	 SHORT $LN42@PyUnicode_@27
  000bf	0f b7 07	 movzx	 eax, WORD PTR [rdi]
  000c2	eb 02		 jmp	 SHORT $LN43@PyUnicode_@27
$LN42@PyUnicode_@27:
  000c4	8b 07		 mov	 eax, DWORD PTR [rdi]
$LN43@PyUnicode_@27:
  000c6	be 01 00 00 00	 mov	 esi, 1
  000cb	85 c0		 test	 eax, eax
  000cd	44 8b cb	 mov	 r9d, ebx

; 7814 :         need_dict = 1;
; 7815 :     for (i = 1; i < length; i++) {

  000d0	8b d6		 mov	 edx, esi
  000d2	44 0f 45 ce	 cmovne	 r9d, esi

; 7816 :         int l1, l2;
; 7817 :         ch = PyUnicode_READ(kind, data, i);

  000d6	4d 63 e4	 movsxd	 r12, r12d
  000d9	4c 3b f2	 cmp	 r14, rdx
  000dc	7e 7d		 jle	 SHORT $LN24@PyUnicode_@27
  000de	66 90		 npad	 2
$LL32@PyUnicode_@27:
  000e0	48 63 c2	 movsxd	 rax, edx
  000e3	4c 3b e6	 cmp	 r12, rsi
  000e6	75 06		 jne	 SHORT $LN48@PyUnicode_@27
  000e8	0f b6 0c 38	 movzx	 ecx, BYTE PTR [rax+rdi]
  000ec	eb 0f		 jmp	 SHORT $LN47@PyUnicode_@27
$LN48@PyUnicode_@27:
  000ee	49 83 fc 02	 cmp	 r12, 2
  000f2	75 06		 jne	 SHORT $LN46@PyUnicode_@27
  000f4	0f b7 0c 47	 movzx	 ecx, WORD PTR [rdi+rax*2]
  000f8	eb 03		 jmp	 SHORT $LN47@PyUnicode_@27
$LN46@PyUnicode_@27:
  000fa	8b 0c 87	 mov	 ecx, DWORD PTR [rdi+rax*4]
$LN47@PyUnicode_@27:

; 7818 :         if (ch == 0 || ch > 0xFFFF) {

  000fd	85 c9		 test	 ecx, ecx
  000ff	74 41		 je	 SHORT $LN94@PyUnicode_@27
  00101	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  00107	77 39		 ja	 SHORT $LN94@PyUnicode_@27

; 7820 :             break;
; 7821 :         }
; 7822 :         if (ch == 0xFFFE)

  00109	81 f9 fe ff 00
	00		 cmp	 ecx, 65534		; 0000fffeH
  0010f	74 25		 je	 SHORT $LN31@PyUnicode_@27

; 7823 :             /* unmapped character */
; 7824 :             continue;
; 7825 :         l1 = ch >> 11;

  00111	8b c1		 mov	 eax, ecx

; 7826 :         l2 = ch >> 7;

  00113	c1 e9 07	 shr	 ecx, 7
  00116	c1 e8 0b	 shr	 eax, 11

; 7827 :         if (level1[l1] == 0xFF)

  00119	80 7c 04 30 ff	 cmp	 BYTE PTR level1$[rsp+rax], 255 ; 000000ffH
  0011e	75 08		 jne	 SHORT $LN26@PyUnicode_@27

; 7828 :             level1[l1] = count2++;

  00120	44 88 6c 04 30	 mov	 BYTE PTR level1$[rsp+rax], r13b
  00125	41 ff c5	 inc	 r13d
$LN26@PyUnicode_@27:

; 7829 :         if (level2[l2] == 0xFF)

  00128	80 7c 0c 50 ff	 cmp	 BYTE PTR level2$[rsp+rcx], 255 ; 000000ffH
  0012d	75 07		 jne	 SHORT $LN31@PyUnicode_@27

; 7830 :             level2[l2] = count3++;

  0012f	40 88 6c 0c 50	 mov	 BYTE PTR level2$[rsp+rcx], bpl
  00134	ff c5		 inc	 ebp
$LN31@PyUnicode_@27:

; 7814 :         need_dict = 1;
; 7815 :     for (i = 1; i < length; i++) {

  00136	ff c2		 inc	 edx
  00138	48 63 c2	 movsxd	 rax, edx
  0013b	49 3b c6	 cmp	 rax, r14
  0013e	7c a0		 jl	 SHORT $LL32@PyUnicode_@27

; 7845 :                 goto failed1;
; 7846 :             if (PyDict_SetItem(result, key, value) == -1)

  00140	eb 03		 jmp	 SHORT $LN30@PyUnicode_@27
$LN94@PyUnicode_@27:

; 7819 :             need_dict = 1;

  00142	44 8b ce	 mov	 r9d, esi
$LN30@PyUnicode_@27:

; 7831 :     }
; 7832 : 
; 7833 :     if (count2 >= 0xFF || count3 >= 0xFF)

  00145	41 81 fd ff 00
	00 00		 cmp	 r13d, 255		; 000000ffH
  0014c	7d 16		 jge	 SHORT $LN101@PyUnicode_@27
  0014e	81 fd ff 00 00
	00		 cmp	 ebp, 255		; 000000ffH

; 7834 :         need_dict = 1;
; 7835 : 
; 7836 :     if (need_dict) {

  00154	7d 0e		 jge	 SHORT $LN101@PyUnicode_@27
  00156	4c 8b 7c 24 30	 mov	 r15, QWORD PTR level1$[rsp]
$LN24@PyUnicode_@27:
  0015b	45 85 c9	 test	 r9d, r9d
  0015e	0f 84 f3 01 00
	00		 je	 $LN22@PyUnicode_@27
$LN101@PyUnicode_@27:

; 7837 :         PyObject *result = PyDict_New();

  00164	e8 00 00 00 00	 call	 PyDict_New
  00169	4c 8b e8	 mov	 r13, rax

; 7838 :         PyObject *key, *value;
; 7839 :         if (!result)

  0016c	48 85 c0	 test	 rax, rax

; 7840 :             return NULL;

  0016f	0f 84 b2 01 00
	00		 je	 $LN90@PyUnicode_@27

; 7841 :         for (i = 0; i < length; i++) {

  00175	4d 85 f6	 test	 r14, r14
  00178	0f 8e 27 03 00
	00		 jle	 $LN3@PyUnicode_@27
  0017e	66 90		 npad	 2
$LL20@PyUnicode_@27:

; 7842 :             key = PyLong_FromLong(PyUnicode_READ(kind, data, i));

  00180	48 63 c3	 movsxd	 rax, ebx
  00183	49 83 fc 01	 cmp	 r12, 1
  00187	75 06		 jne	 SHORT $LN52@PyUnicode_@27
  00189	0f b6 0c 38	 movzx	 ecx, BYTE PTR [rax+rdi]
  0018d	eb 0f		 jmp	 SHORT $LN51@PyUnicode_@27
$LN52@PyUnicode_@27:
  0018f	49 83 fc 02	 cmp	 r12, 2
  00193	75 06		 jne	 SHORT $LN50@PyUnicode_@27
  00195	0f b7 0c 47	 movzx	 ecx, WORD PTR [rdi+rax*2]
  00199	eb 03		 jmp	 SHORT $LN51@PyUnicode_@27
$LN50@PyUnicode_@27:
  0019b	8b 0c 87	 mov	 ecx, DWORD PTR [rdi+rax*4]
$LN51@PyUnicode_@27:
  0019e	e8 00 00 00 00	 call	 PyLong_FromLong

; 7843 :             value = PyLong_FromLong(i);

  001a3	8b cb		 mov	 ecx, ebx
  001a5	48 8b e8	 mov	 rbp, rax
  001a8	e8 00 00 00 00	 call	 PyLong_FromLong
  001ad	48 8b f0	 mov	 rsi, rax

; 7844 :             if (!key || !value)

  001b0	48 85 ed	 test	 rbp, rbp
  001b3	0f 84 9f 00 00
	00		 je	 $LN13@PyUnicode_@27
  001b9	48 85 c0	 test	 rax, rax
  001bc	74 35		 je	 SHORT $failed1$133902

; 7845 :                 goto failed1;
; 7846 :             if (PyDict_SetItem(result, key, value) == -1)

  001be	4c 8b c0	 mov	 r8, rax
  001c1	48 8b d5	 mov	 rdx, rbp
  001c4	49 8b cd	 mov	 rcx, r13
  001c7	e8 00 00 00 00	 call	 PyDict_SetItem
  001cc	83 f8 ff	 cmp	 eax, -1
  001cf	74 22		 je	 SHORT $failed1$133902

; 7847 :                 goto failed1;
; 7848 :             Py_DECREF(key);

  001d1	48 8b cd	 mov	 rcx, rbp
  001d4	e8 00 00 00 00	 call	 _Py_DecRef

; 7849 :             Py_DECREF(value);

  001d9	48 8b ce	 mov	 rcx, rsi
  001dc	e8 00 00 00 00	 call	 _Py_DecRef
  001e1	ff c3		 inc	 ebx
  001e3	48 63 c3	 movsxd	 rax, ebx
  001e6	49 3b c6	 cmp	 rax, r14
  001e9	7c 95		 jl	 SHORT $LL20@PyUnicode_@27

; 7889 :     }
; 7890 :     return result;

  001eb	49 8b c5	 mov	 rax, r13
  001ee	e9 36 01 00 00	 jmp	 $LN105@PyUnicode_@27
$failed1$133902:

; 7850 :         }
; 7851 :         return result;
; 7852 :       failed1:
; 7853 :         Py_XDECREF(key);

  001f3	e8 00 00 00 00	 call	 _Py_PXCTX
  001f8	85 c0		 test	 eax, eax
  001fa	75 5c		 jne	 SHORT $LN13@PyUnicode_@27
  001fc	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  00200	a8 20		 test	 al, 32			; 00000020H
  00202	75 4c		 jne	 SHORT $LN62@PyUnicode_@27
  00204	84 c0		 test	 al, al
  00206	78 48		 js	 SHORT $LN62@PyUnicode_@27
  00208	a8 02		 test	 al, 2
  0020a	75 4c		 jne	 SHORT $LN13@PyUnicode_@27
  0020c	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  00210	75 46		 jne	 SHORT $LN13@PyUnicode_@27
  00212	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00219	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00220	4c 8b cd	 mov	 r9, rbp
  00223	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00229	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00231	e8 00 00 00 00	 call	 _PyParallel_Guard
  00236	48 8b cd	 mov	 rcx, rbp
  00239	85 c0		 test	 eax, eax
  0023b	74 07		 je	 SHORT $LN67@PyUnicode_@27
  0023d	e8 00 00 00 00	 call	 _Px_Dealloc
  00242	eb 14		 jmp	 SHORT $LN13@PyUnicode_@27
$LN67@PyUnicode_@27:
  00244	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  00248	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0024e	eb 08		 jmp	 SHORT $LN13@PyUnicode_@27
$LN62@PyUnicode_@27:
  00250	48 8b cd	 mov	 rcx, rbp
  00253	e8 00 00 00 00	 call	 Px_DecRef
$LN13@PyUnicode_@27:

; 7854 :         Py_XDECREF(value);

  00258	48 85 f6	 test	 rsi, rsi
  0025b	74 65		 je	 SHORT $LN9@PyUnicode_@27
  0025d	e8 00 00 00 00	 call	 _Py_PXCTX
  00262	85 c0		 test	 eax, eax
  00264	75 5c		 jne	 SHORT $LN9@PyUnicode_@27
  00266	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  0026a	a8 20		 test	 al, 32			; 00000020H
  0026c	75 4c		 jne	 SHORT $LN73@PyUnicode_@27
  0026e	84 c0		 test	 al, al
  00270	78 48		 js	 SHORT $LN73@PyUnicode_@27
  00272	a8 02		 test	 al, 2
  00274	75 4c		 jne	 SHORT $LN9@PyUnicode_@27
  00276	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  0027a	75 46		 jne	 SHORT $LN9@PyUnicode_@27
  0027c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00283	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0028a	4c 8b ce	 mov	 r9, rsi
  0028d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00293	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0029b	e8 00 00 00 00	 call	 _PyParallel_Guard
  002a0	48 8b ce	 mov	 rcx, rsi
  002a3	85 c0		 test	 eax, eax
  002a5	74 07		 je	 SHORT $LN78@PyUnicode_@27
  002a7	e8 00 00 00 00	 call	 _Px_Dealloc
  002ac	eb 14		 jmp	 SHORT $LN9@PyUnicode_@27
$LN78@PyUnicode_@27:
  002ae	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  002b2	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002b8	eb 08		 jmp	 SHORT $LN9@PyUnicode_@27
$LN73@PyUnicode_@27:
  002ba	48 8b ce	 mov	 rcx, rsi
  002bd	e8 00 00 00 00	 call	 Px_DecRef
$LN9@PyUnicode_@27:

; 7855 :         Py_DECREF(result);

  002c2	e8 00 00 00 00	 call	 _Py_PXCTX
  002c7	85 c0		 test	 eax, eax
  002c9	75 5c		 jne	 SHORT $LN90@PyUnicode_@27
  002cb	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  002cf	a8 20		 test	 al, 32			; 00000020H
  002d1	75 4c		 jne	 SHORT $LN84@PyUnicode_@27
  002d3	84 c0		 test	 al, al
  002d5	78 48		 js	 SHORT $LN84@PyUnicode_@27
  002d7	a8 02		 test	 al, 2
  002d9	75 4c		 jne	 SHORT $LN90@PyUnicode_@27
  002db	49 ff 4d 50	 dec	 QWORD PTR [r13+80]
  002df	75 46		 jne	 SHORT $LN90@PyUnicode_@27
  002e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  002ef	4d 8b cd	 mov	 r9, r13
  002f2	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  002f8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00300	e8 00 00 00 00	 call	 _PyParallel_Guard
  00305	49 8b cd	 mov	 rcx, r13
  00308	85 c0		 test	 eax, eax
  0030a	74 07		 je	 SHORT $LN89@PyUnicode_@27
  0030c	e8 00 00 00 00	 call	 _Px_Dealloc
  00311	eb 14		 jmp	 SHORT $LN90@PyUnicode_@27
$LN89@PyUnicode_@27:
  00313	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  00317	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0031d	eb 08		 jmp	 SHORT $LN90@PyUnicode_@27
$LN84@PyUnicode_@27:
  0031f	49 8b cd	 mov	 rcx, r13
  00322	e8 00 00 00 00	 call	 Px_DecRef
$LN90@PyUnicode_@27:

; 7856 :         return NULL;

  00327	33 c0		 xor	 eax, eax
$LN105@PyUnicode_@27:
  00329	4c 8b a4 24 58
	02 00 00	 mov	 r12, QWORD PTR [rsp+600]
  00331	48 8b bc 24 60
	02 00 00	 mov	 rdi, QWORD PTR [rsp+608]
  00339	48 8b b4 24 a8
	02 00 00	 mov	 rsi, QWORD PTR [rsp+680]
  00341	4c 8b bc 24 50
	02 00 00	 mov	 r15, QWORD PTR [rsp+592]

; 7891 : }

  00349	48 81 c4 68 02
	00 00		 add	 rsp, 616		; 00000268H
  00350	41 5e		 pop	 r14
  00352	41 5d		 pop	 r13
  00354	5d		 pop	 rbp
  00355	5b		 pop	 rbx
  00356	c3		 ret	 0
$LN22@PyUnicode_@27:

; 7857 :     }
; 7858 : 
; 7859 :     /* Create a three-level trie */
; 7860 :     result = PyObject_MALLOC(sizeof(struct encoding_map) +
; 7861 :                              16*count2 + 128*count3 - 1);

  00357	8b c5		 mov	 eax, ebp
  00359	c1 e0 07	 shl	 eax, 7
  0035c	48 63 c8	 movsxd	 rcx, eax
  0035f	41 8b c5	 mov	 eax, r13d
  00362	c1 e0 04	 shl	 eax, 4
  00365	48 89 8c 24 a0
	02 00 00	 mov	 QWORD PTR tv628[rsp], rcx
  0036d	48 98		 cdqe
  0036f	48 89 84 24 98
	02 00 00	 mov	 QWORD PTR tv627[rsp], rax
  00377	48 8d 8c 08 8f
	00 00 00	 lea	 rcx, QWORD PTR [rax+rcx+143]
  0037f	e8 00 00 00 00	 call	 PyObject_Malloc
  00384	48 89 84 24 90
	02 00 00	 mov	 QWORD PTR result$1$[rsp], rax

; 7862 :     if (!result)

  0038c	48 85 c0	 test	 rax, rax
  0038f	75 07		 jne	 SHORT $LN6@PyUnicode_@27

; 7863 :         return PyErr_NoMemory();

  00391	e8 00 00 00 00	 call	 PyErr_NoMemory
  00396	eb 91		 jmp	 SHORT $LN105@PyUnicode_@27
$LN6@PyUnicode_@27:

; 7864 :     PyObject_Init(result, &EncodingMapType);

  00398	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:EncodingMapType
  0039f	48 8b c8	 mov	 rcx, rax
  003a2	e8 00 00 00 00	 call	 PyObject_Init

; 7865 :     mresult = (struct encoding_map*)result;
; 7866 :     mresult->count2 = count2;

  003a7	4c 8b 9c 24 90
	02 00 00	 mov	 r11, QWORD PTR result$1$[rsp]

; 7867 :     mresult->count3 = count3;
; 7868 :     mlevel1 = mresult->level1;
; 7869 :     mlevel2 = mresult->level23;
; 7870 :     mlevel3 = mresult->level23 + 16*count2;

  003af	4c 8b 84 24 98
	02 00 00	 mov	 r8, QWORD PTR tv627[rsp]
  003b7	45 89 ab 80 00
	00 00		 mov	 DWORD PTR [r11+128], r13d
  003be	41 89 ab 84 00
	00 00		 mov	 DWORD PTR [r11+132], ebp

; 7871 :     memcpy(mlevel1, level1, 32);

  003c5	4d 89 7b 60	 mov	 QWORD PTR [r11+96], r15
  003c9	4b 8d 84 18 88
	00 00 00	 lea	 rax, QWORD PTR [r8+r11+136]

; 7872 :     memset(mlevel2, 0xFF, 16*count2);

  003d1	49 8d 8b 88 00
	00 00		 lea	 rcx, QWORD PTR [r11+136]
  003d8	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  003dd	48 89 84 24 90
	02 00 00	 mov	 QWORD PTR mlevel3$1$[rsp], rax
  003e5	48 8b 44 24 38	 mov	 rax, QWORD PTR level1$[rsp+8]
  003ea	4d 8b eb	 mov	 r13, r11
  003ed	49 89 43 68	 mov	 QWORD PTR [r11+104], rax
  003f1	48 8b 44 24 40	 mov	 rax, QWORD PTR level1$[rsp+16]
  003f6	49 89 43 70	 mov	 QWORD PTR [r11+112], rax
  003fa	48 8b 44 24 48	 mov	 rax, QWORD PTR level1$[rsp+24]
  003ff	49 89 43 78	 mov	 QWORD PTR [r11+120], rax
  00403	e8 00 00 00 00	 call	 memset

; 7873 :     memset(mlevel3, 0, 128*count3);

  00408	4c 8b bc 24 90
	02 00 00	 mov	 r15, QWORD PTR mlevel3$1$[rsp]
  00410	4c 8b 84 24 a0
	02 00 00	 mov	 r8, QWORD PTR tv628[rsp]
  00418	49 8b cf	 mov	 rcx, r15
  0041b	33 d2		 xor	 edx, edx
  0041d	e8 00 00 00 00	 call	 memset

; 7874 :     count3 = 0;
; 7875 :     for (i = 1; i < length; i++) {

  00422	4c 3b f6	 cmp	 r14, rsi
  00425	7e 7e		 jle	 SHORT $LN3@PyUnicode_@27
  00427	48 8b c6	 mov	 rax, rsi
  0042a	66 0f 1f 44 00
	00		 npad	 6
$LL5@PyUnicode_@27:

; 7876 :         int o1, o2, o3, i2, i3;
; 7877 :         Py_UCS4 ch = PyUnicode_READ(kind, data, i);

  00430	49 83 fc 01	 cmp	 r12, 1
  00434	75 06		 jne	 SHORT $LN56@PyUnicode_@27
  00436	0f b6 14 38	 movzx	 edx, BYTE PTR [rax+rdi]
  0043a	eb 0f		 jmp	 SHORT $LN55@PyUnicode_@27
$LN56@PyUnicode_@27:
  0043c	49 83 fc 02	 cmp	 r12, 2
  00440	75 06		 jne	 SHORT $LN54@PyUnicode_@27
  00442	0f b7 14 47	 movzx	 edx, WORD PTR [rdi+rax*2]
  00446	eb 03		 jmp	 SHORT $LN55@PyUnicode_@27
$LN54@PyUnicode_@27:
  00448	8b 14 87	 mov	 edx, DWORD PTR [rdi+rax*4]
$LN55@PyUnicode_@27:

; 7878 :         if (ch == 0xFFFE)

  0044b	81 fa fe ff 00
	00		 cmp	 edx, 65534		; 0000fffeH
  00451	74 48		 je	 SHORT $LN4@PyUnicode_@27

; 7879 :             /* unmapped character */
; 7880 :             continue;
; 7881 :         o1 = ch>>11;

  00453	8b c2		 mov	 eax, edx
  00455	c1 e8 0b	 shr	 eax, 11

; 7882 :         o2 = (ch>>7) & 0xF;
; 7883 :         i2 = 16*mlevel1[o1] + o2;

  00458	42 0f b6 4c 28
	60		 movzx	 ecx, BYTE PTR [rax+r13+96]
  0045e	8b c2		 mov	 eax, edx
  00460	c1 e8 07	 shr	 eax, 7
  00463	c1 e1 04	 shl	 ecx, 4
  00466	83 e0 0f	 and	 eax, 15
  00469	03 c1		 add	 eax, ecx

; 7884 :         if (mlevel2[i2] == 0xFF)

  0046b	48 98		 cdqe
  0046d	42 80 bc 28 88
	00 00 00 ff	 cmp	 BYTE PTR [rax+r13+136], 255 ; 000000ffH
  00476	75 0a		 jne	 SHORT $LN1@PyUnicode_@27

; 7885 :             mlevel2[i2] = count3++;

  00478	42 88 9c 28 88
	00 00 00	 mov	 BYTE PTR [rax+r13+136], bl
  00480	ff c3		 inc	 ebx
$LN1@PyUnicode_@27:

; 7886 :         o3 = ch & 0x7F;
; 7887 :         i3 = 128*mlevel2[i2] + o3;
; 7888 :         mlevel3[i3] = i;

  00482	42 0f b6 84 28
	88 00 00 00	 movzx	 eax, BYTE PTR [rax+r13+136]
  0048b	8b ca		 mov	 ecx, edx
  0048d	83 e1 7f	 and	 ecx, 127		; 0000007fH
  00490	48 c1 e0 07	 shl	 rax, 7
  00494	49 03 c7	 add	 rax, r15
  00497	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
$LN4@PyUnicode_@27:

; 7874 :     count3 = 0;
; 7875 :     for (i = 1; i < length; i++) {

  0049b	ff c6		 inc	 esi
  0049d	48 63 c6	 movsxd	 rax, esi
  004a0	49 3b c6	 cmp	 rax, r14
  004a3	7c 8b		 jl	 SHORT $LL5@PyUnicode_@27
$LN3@PyUnicode_@27:

; 7889 :     }
; 7890 :     return result;

  004a5	49 8b c5	 mov	 rax, r13
  004a8	e9 7c fe ff ff	 jmp	 $LN105@PyUnicode_@27
$LN34@PyUnicode_@27:

; 7800 :         PyErr_BadArgument();

  004ad	e8 00 00 00 00	 call	 PyErr_BadArgument

; 7801 :         return NULL;

  004b2	33 c0		 xor	 eax, eax

; 7891 : }

  004b4	48 81 c4 68 02
	00 00		 add	 rsp, 616		; 00000268H
  004bb	41 5e		 pop	 r14
  004bd	41 5d		 pop	 r13
  004bf	5d		 pop	 rbp
  004c0	5b		 pop	 rbx
  004c1	c3		 ret	 0
PyUnicode_BuildEncodingMap ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT encoding_map_lookup
_TEXT	SEGMENT
c$ = 8
mapping$ = 16
encoding_map_lookup PROC				; COMDAT

; 7895 : {

  00000	4c 8b ca	 mov	 r9, rdx
  00003	44 8b c1	 mov	 r8d, ecx

; 7898 :     int l2 = (c>>7) & 0xF;
; 7899 :     int l3 = c & 0x7F;
; 7900 :     int i;
; 7901 : 
; 7902 :     if (c > 0xFFFF)

  00006	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  0000c	76 04		 jbe	 SHORT $LN5@encoding_m
$LN8@encoding_m:

; 7903 :         return -1;

  0000e	83 c8 ff	 or	 eax, -1

; 7919 :         return -1;
; 7920 :     }
; 7921 :     return i;
; 7922 : }

  00011	c3		 ret	 0
$LN5@encoding_m:

; 7904 :     if (c == 0)

  00012	85 c9		 test	 ecx, ecx
  00014	75 03		 jne	 SHORT $LN4@encoding_m

; 7905 :         return 0;

  00016	33 c0		 xor	 eax, eax

; 7919 :         return -1;
; 7920 :     }
; 7921 :     return i;
; 7922 : }

  00018	c3		 ret	 0
$LN4@encoding_m:

; 7896 :     struct encoding_map *map = (struct encoding_map*)mapping;
; 7897 :     int l1 = c>>11;

  00019	8b c1		 mov	 eax, ecx
  0001b	c1 e8 0b	 shr	 eax, 11

; 7906 :     /* level 1*/
; 7907 :     i = map->level1[l1];

  0001e	0f b6 4c 10 60	 movzx	 ecx, BYTE PTR [rax+rdx+96]

; 7908 :     if (i == 0xFF) {

  00023	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH

; 7909 :         return -1;

  00029	74 e3		 je	 SHORT $LN8@encoding_m

; 7910 :     }
; 7911 :     /* level 2*/
; 7912 :     i = map->level23[16*i+l2];

  0002b	41 8b c0	 mov	 eax, r8d
  0002e	48 03 c9	 add	 rcx, rcx
  00031	c1 e8 07	 shr	 eax, 7
  00034	83 e0 0f	 and	 eax, 15
  00037	48 98		 cdqe
  00039	48 03 c2	 add	 rax, rdx
  0003c	0f b6 94 c8 88
	00 00 00	 movzx	 edx, BYTE PTR [rax+rcx*8+136]

; 7913 :     if (i == 0xFF) {

  00044	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH

; 7914 :         return -1;

  0004a	74 c2		 je	 SHORT $LN8@encoding_m

; 7915 :     }
; 7916 :     /* level 3 */
; 7917 :     i = map->level23[16*map->count2 + 128*i + l3];

  0004c	49 63 89 80 00
	00 00		 movsxd	 rcx, DWORD PTR [r9+128]
  00053	48 8d 14 d1	 lea	 rdx, QWORD PTR [rcx+rdx*8]
  00057	41 8b c8	 mov	 ecx, r8d
  0005a	83 e1 7f	 and	 ecx, 127		; 0000007fH
  0005d	48 03 d2	 add	 rdx, rdx
  00060	49 8d 04 d1	 lea	 rax, QWORD PTR [r9+rdx*8]
  00064	0f b6 84 01 88
	00 00 00	 movzx	 eax, BYTE PTR [rcx+rax+136]

; 7918 :     if (i == 0) {

  0006c	83 c9 ff	 or	 ecx, -1
  0006f	85 c0		 test	 eax, eax
  00071	0f 44 c1	 cmove	 eax, ecx

; 7919 :         return -1;
; 7920 :     }
; 7921 :     return i;
; 7922 : }

  00074	c3		 ret	 0
encoding_map_lookup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EB@EMJFGLDI@character?5mapping?5must?5return?5in@ ; `string'
PUBLIC	??_C@_0CI@HIAFEGOG@character?5mapping?5must?5be?5in?5ran@ ; `string'
EXTRN	PyLong_AsLong:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_LookupError:QWORD
EXTRN	PyObject_GetItem:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$charmapencode_lookup DD imagerel charmapencode_lookup
	DD	imagerel charmapencode_lookup+240
	DD	imagerel $unwind$charmapencode_lookup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$charmapencode_lookup DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0EB@EMJFGLDI@character?5mapping?5must?5return?5in@
CONST	SEGMENT
??_C@_0EB@EMJFGLDI@character?5mapping?5must?5return?5in@ DB 'character ma'
	DB	'pping must return integer, bytes or None, not %.400s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HIAFEGOG@character?5mapping?5must?5be?5in?5ran@
CONST	SEGMENT
??_C@_0CI@HIAFEGOG@character?5mapping?5must?5be?5in?5ran@ DB 'character m'
	DB	'apping must be in range(256)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT charmapencode_lookup
_TEXT	SEGMENT
c$ = 48
mapping$ = 56
charmapencode_lookup PROC				; COMDAT

; 7929 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 7930 :     PyObject *w = PyLong_FromLong((long)c);

  0000d	e8 00 00 00 00	 call	 PyLong_FromLong
  00012	48 8b f8	 mov	 rdi, rax

; 7931 :     PyObject *x;
; 7932 : 
; 7933 :     if (w == NULL)

  00015	48 85 c0	 test	 rax, rax

; 7934 :         return NULL;

  00018	0f 84 c5 00 00
	00		 je	 $LN16@charmapenc

; 7935 :     x = PyObject_GetItem(mapping, w);

  0001e	48 8b d0	 mov	 rdx, rax
  00021	48 8b cb	 mov	 rcx, rbx
  00024	e8 00 00 00 00	 call	 PyObject_GetItem

; 7936 :     Py_DECREF(w);

  00029	48 8b cf	 mov	 rcx, rdi
  0002c	48 8b d8	 mov	 rbx, rax
  0002f	e8 00 00 00 00	 call	 _Py_DecRef

; 7937 :     if (x == NULL) {

  00034	48 85 db	 test	 rbx, rbx
  00037	75 36		 jne	 SHORT $LN12@charmapenc

; 7938 :         if (PyErr_ExceptionMatches(PyExc_LookupError)) {

  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_LookupError
  00040	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00045	85 c0		 test	 eax, eax
  00047	0f 84 96 00 00
	00		 je	 $LN16@charmapenc

; 7939 :             /* No mapping found means: mapping is undefined. */
; 7940 :             PyErr_Clear();

  0004d	e8 00 00 00 00	 call	 PyErr_Clear

; 7941 :             x = Py_None;
; 7942 :             Py_INCREF(x);

  00052	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  00059	48 8b cf	 mov	 rcx, rdi
  0005c	e8 00 00 00 00	 call	 _Py_IncRef

; 7943 :             return x;

  00061	48 8b c7	 mov	 rax, rdi

; 7968 :     }
; 7969 : }

  00064	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00069	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
$LN12@charmapenc:

; 7944 :         } else
; 7945 :             return NULL;
; 7946 :     }
; 7947 :     else if (x == Py_None)

  0006f	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  00076	48 3b df	 cmp	 rbx, rdi
  00079	75 0e		 jne	 SHORT $LN8@charmapenc
$LN18@charmapenc:

; 7948 :         return x;

  0007b	48 8b c3	 mov	 rax, rbx

; 7968 :     }
; 7969 : }

  0007e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00083	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00087	5f		 pop	 rdi
  00088	c3		 ret	 0
$LN8@charmapenc:

; 7949 :     else if (PyLong_Check(x)) {

  00089	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  0008d	41 8b 80 00 01
	00 00		 mov	 eax, DWORD PTR [r8+256]
  00094	0f ba e0 18	 bt	 eax, 24
  00098	73 24		 jae	 SHORT $LN6@charmapenc

; 7950 :         long value = PyLong_AS_LONG(x);

  0009a	48 8b cb	 mov	 rcx, rbx
  0009d	e8 00 00 00 00	 call	 PyLong_AsLong

; 7951 :         if (value < 0 || value > 255) {

  000a2	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH

; 7956 :         }
; 7957 :         return x;

  000a7	76 d2		 jbe	 SHORT $LN18@charmapenc

; 7952 :             PyErr_SetString(PyExc_TypeError,
; 7953 :                             "character mapping must be in range(256)");

  000a9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@HIAFEGOG@character?5mapping?5must?5be?5in?5ran@
  000b7	e8 00 00 00 00	 call	 PyErr_SetString

; 7954 :             Py_DECREF(x);
; 7955 :             return NULL;

  000bc	eb 1d		 jmp	 SHORT $LN17@charmapenc
$LN6@charmapenc:

; 7958 :     }
; 7959 :     else if (PyBytes_Check(x))

  000be	0f ba e0 1b	 bt	 eax, 27

; 7960 :         return x;

  000c2	72 b7		 jb	 SHORT $LN18@charmapenc

; 7961 :     else {
; 7962 :         /* wrong return value */
; 7963 :         PyErr_Format(PyExc_TypeError,
; 7964 :                      "character mapping must return integer, bytes or None, not %.400s",
; 7965 :                      x->ob_type->tp_name);

  000c4	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000c8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EB@EMJFGLDI@character?5mapping?5must?5return?5in@
  000d6	e8 00 00 00 00	 call	 PyErr_Format
$LN17@charmapenc:

; 7966 :         Py_DECREF(x);

  000db	48 8b cb	 mov	 rcx, rbx
  000de	e8 00 00 00 00	 call	 _Py_DecRef
$LN16@charmapenc:

; 7967 :         return NULL;

  000e3	33 c0		 xor	 eax, eax

; 7968 :     }
; 7969 : }

  000e5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ea	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ee	5f		 pop	 rdi
  000ef	c3		 ret	 0
charmapencode_lookup ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$charmapencode_resize DD imagerel charmapencode_resize
	DD	imagerel charmapencode_resize+35
	DD	imagerel $unwind$charmapencode_resize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$charmapencode_resize DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT charmapencode_resize
_TEXT	SEGMENT
outobj$ = 48
requiredsize$ = 56
charmapencode_resize PROC				; COMDAT

; 7973 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 7974 :     Py_ssize_t outsize = PyBytes_GET_SIZE(*outobj);

  00004	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00007	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]

; 7975 :     /* exponentially overallocate to minimize reallocations */
; 7976 :     if (requiredsize < 2*outsize)

  0000b	4d 03 c0	 add	 r8, r8
  0000e	49 3b d0	 cmp	 rdx, r8
  00011	49 0f 4c d0	 cmovl	 rdx, r8

; 7977 :         requiredsize = 2*outsize;
; 7978 :     if (_PyBytes_Resize(outobj, requiredsize))

  00015	e8 00 00 00 00	 call	 _PyBytes_Resize
  0001a	f7 d8		 neg	 eax
  0001c	1b c0		 sbb	 eax, eax

; 7979 :         return -1;
; 7980 :     return 0;
; 7981 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
charmapencode_resize ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$charmapencode_output DD imagerel charmapencode_output
	DD	imagerel charmapencode_output+345
	DD	imagerel $unwind$charmapencode_output
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$charmapencode_output DD 0ab901H
	DD	09d4b9H
	DD	08c4b4H
	DD	0a340cH
	DD	07008320cH
	DD	050066007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT charmapencode_output
_TEXT	SEGMENT
c$ = 64
mapping$ = 72
outobj$ = 80
outpos$ = 88
charmapencode_output PROC				; COMDAT

; 7995 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 7996 :     PyObject *rep;
; 7997 :     char *outstart;
; 7998 :     Py_ssize_t outsize = PyBytes_GET_SIZE(*outobj);

  0000c	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0000f	49 8b f1	 mov	 rsi, r9
  00012	49 8b d8	 mov	 rbx, r8
  00015	48 8b 68 60	 mov	 rbp, QWORD PTR [rax+96]

; 7999 : 
; 8000 :     if (Py_TYPE(mapping) == &EncodingMapType) {

  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:EncodingMapType
  00020	48 39 42 58	 cmp	 QWORD PTR [rdx+88], rax
  00024	75 52		 jne	 SHORT $LN14@charmapenc@2

; 8001 :         int res = encoding_map_lookup(c, mapping);

  00026	e8 00 00 00 00	 call	 encoding_map_lookup

; 8002 :         Py_ssize_t requiredsize = *outpos+1;

  0002b	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  0002e	48 ff c2	 inc	 rdx
  00031	8b f8		 mov	 edi, eax

; 8003 :         if (res == -1)

  00033	83 f8 ff	 cmp	 eax, -1

; 8004 :             return enc_FAILED;

  00036	74 61		 je	 SHORT $LN20@charmapenc@2

; 8005 :         if (outsize<requiredsize)

  00038	48 3b ea	 cmp	 rbp, rdx
  0003b	7d 1e		 jge	 SHORT $LN11@charmapenc@2

; 8006 :             if (charmapencode_resize(outobj, outpos, requiredsize))

  0003d	48 8b cb	 mov	 rcx, rbx
  00040	e8 00 00 00 00	 call	 charmapencode_resize
  00045	85 c0		 test	 eax, eax
  00047	74 12		 je	 SHORT $LN11@charmapenc@2
$LN21@charmapenc@2:

; 8007 :                 return enc_EXCEPTION;

  00049	b8 02 00 00 00	 mov	 eax, 2

; 8046 : }

  0004e	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	5e		 pop	 rsi
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
$LN11@charmapenc@2:

; 8008 :         outstart = PyBytes_AS_STRING(*outobj);
; 8009 :         outstart[(*outpos)++] = (char)res;

  0005b	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0005e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00061	40 88 7c 01 78	 mov	 BYTE PTR [rcx+rax+120], dil
  00066	48 ff 06	 inc	 QWORD PTR [rsi]

; 8010 :         return enc_SUCCESS;

  00069	33 c0		 xor	 eax, eax

; 8046 : }

  0006b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5f		 pop	 rdi
  00075	5e		 pop	 rsi
  00076	5d		 pop	 rbp
  00077	c3		 ret	 0
$LN14@charmapenc@2:

; 8011 :     }
; 8012 : 
; 8013 :     rep = charmapencode_lookup(c, mapping);

  00078	e8 00 00 00 00	 call	 charmapencode_lookup
  0007d	48 8b f8	 mov	 rdi, rax

; 8014 :     if (rep==NULL)

  00080	48 85 c0	 test	 rax, rax

; 8015 :         return enc_EXCEPTION;

  00083	74 c4		 je	 SHORT $LN21@charmapenc@2

; 8016 :     else if (rep==Py_None) {

  00085	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0008c	48 3b f8	 cmp	 rdi, rax
  0008f	75 1a		 jne	 SHORT $LN8@charmapenc@2

; 8017 :         Py_DECREF(rep);

  00091	48 8b cf	 mov	 rcx, rdi
  00094	e8 00 00 00 00	 call	 _Py_DecRef
$LN20@charmapenc@2:

; 8018 :         return enc_FAILED;

  00099	b8 01 00 00 00	 mov	 eax, 1

; 8046 : }

  0009e	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000a3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a7	5f		 pop	 rdi
  000a8	5e		 pop	 rsi
  000a9	5d		 pop	 rbp
  000aa	c3		 ret	 0
$LN8@charmapenc@2:

; 8019 :     } else {
; 8020 :         if (PyLong_Check(rep)) {

  000ab	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  000af	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12
  000b4	4c 89 6c 24 48	 mov	 QWORD PTR [rsp+72], r13
  000b9	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  000c3	74 2e		 je	 SHORT $LN6@charmapenc@2

; 8021 :             Py_ssize_t requiredsize = *outpos+1;

  000c5	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  000c8	48 ff c2	 inc	 rdx

; 8022 :             if (outsize<requiredsize)

  000cb	48 3b ea	 cmp	 rbp, rdx
  000ce	7d 0c		 jge	 SHORT $LN4@charmapenc@2

; 8023 :                 if (charmapencode_resize(outobj, outpos, requiredsize)) {

  000d0	48 8b cb	 mov	 rcx, rbx
  000d3	e8 00 00 00 00	 call	 charmapencode_resize
  000d8	85 c0		 test	 eax, eax

; 8024 :                     Py_DECREF(rep);
; 8025 :                     return enc_EXCEPTION;

  000da	75 33		 jne	 SHORT $LN19@charmapenc@2
$LN4@charmapenc@2:

; 8026 :                 }
; 8027 :             outstart = PyBytes_AS_STRING(*outobj);

  000dc	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]

; 8028 :             outstart[(*outpos)++] = (char)PyLong_AS_LONG(rep);

  000df	48 8b cf	 mov	 rcx, rdi
  000e2	e8 00 00 00 00	 call	 PyLong_AsLong
  000e7	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  000ea	88 44 0b 78	 mov	 BYTE PTR [rbx+rcx+120], al
  000ee	48 ff 06	 inc	 QWORD PTR [rsi]

; 8029 :         }
; 8030 :         else {

  000f1	eb 45		 jmp	 SHORT $LN3@charmapenc@2
$LN6@charmapenc@2:

; 8031 :             const char *repchars = PyBytes_AS_STRING(rep);
; 8032 :             Py_ssize_t repsize = PyBytes_GET_SIZE(rep);

  000f3	4c 8b 67 60	 mov	 r12, QWORD PTR [rdi+96]

; 8033 :             Py_ssize_t requiredsize = *outpos+repsize;

  000f7	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000fa	49 8d 14 04	 lea	 rdx, QWORD PTR [r12+rax]

; 8034 :             if (outsize<requiredsize)

  000fe	48 3b ea	 cmp	 rbp, rdx
  00101	7d 1b		 jge	 SHORT $LN1@charmapenc@2

; 8035 :                 if (charmapencode_resize(outobj, outpos, requiredsize)) {

  00103	48 8b cb	 mov	 rcx, rbx
  00106	e8 00 00 00 00	 call	 charmapencode_resize
  0010b	85 c0		 test	 eax, eax
  0010d	74 0f		 je	 SHORT $LN1@charmapenc@2
$LN19@charmapenc@2:

; 8036 :                     Py_DECREF(rep);

  0010f	48 8b cf	 mov	 rcx, rdi
  00112	e8 00 00 00 00	 call	 _Py_DecRef

; 8037 :                     return enc_EXCEPTION;

  00117	b8 02 00 00 00	 mov	 eax, 2
  0011c	eb 24		 jmp	 SHORT $LN18@charmapenc@2
$LN1@charmapenc@2:

; 8038 :                 }
; 8039 :             outstart = PyBytes_AS_STRING(*outobj);
; 8040 :             memcpy(outstart + *outpos, repchars, repsize);

  0011e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00121	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00124	48 8d 57 78	 lea	 rdx, QWORD PTR [rdi+120]
  00128	48 8d 4c 01 78	 lea	 rcx, QWORD PTR [rcx+rax+120]
  0012d	4d 8b c4	 mov	 r8, r12
  00130	e8 00 00 00 00	 call	 memcpy

; 8041 :             *outpos += repsize;

  00135	4c 01 26	 add	 QWORD PTR [rsi], r12
$LN3@charmapenc@2:

; 8042 :         }
; 8043 :     }
; 8044 :     Py_DECREF(rep);

  00138	48 8b cf	 mov	 rcx, rdi
  0013b	e8 00 00 00 00	 call	 _Py_DecRef

; 8045 :     return enc_SUCCESS;

  00140	33 c0		 xor	 eax, eax
$LN18@charmapenc@2:

; 8046 : }

  00142	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]
  00147	4c 8b 6c 24 48	 mov	 r13, QWORD PTR [rsp+72]
  0014c	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00151	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00155	5f		 pop	 rdi
  00156	5e		 pop	 rsi
  00157	5d		 pop	 rbp
  00158	c3		 ret	 0
charmapencode_output ENDP
_TEXT	ENDS
PUBLIC	??_C@_07JDDMBNCD@charmap?$AA@			; `string'
PUBLIC	??_C@_0BO@BLGNENDK@character?5maps?5to?5?$DMundefined?$DO?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$charmap_encoding_error DD imagerel charmap_encoding_error
	DD	imagerel charmap_encoding_error+1716
	DD	imagerel $unwind$charmap_encoding_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$charmap_encoding_error DD 0d7b01H
	DD	013747bH
	DD	014646fH
	DD	0155467H
	DD	016011fH
	DD	0e016f018H
	DD	0c012d014H
	DD	03010H
xdata	ENDS
;	COMDAT ??_C@_07JDDMBNCD@charmap?$AA@
CONST	SEGMENT
??_C@_07JDDMBNCD@charmap?$AA@ DB 'charmap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BLGNENDK@character?5maps?5to?5?$DMundefined?$DO?$AA@
CONST	SEGMENT
??_C@_0BO@BLGNENDK@character?5maps?5to?5?$DMundefined?$DO?$AA@ DB 'charac'
	DB	'ter maps to <undefined>', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT charmap_encoding_error
_TEXT	SEGMENT
newpos$ = 80
collstartpos$1$ = 88
buffer$134235 = 96
collendpos$1$ = 224
unicode$ = 224
inpos$ = 232
mapping$ = 240
exceptionObject$ = 248
known_errorHandler$ = 256
errorHandler$ = 264
errors$ = 272
res$ = 280
respos$ = 288
charmap_encoding_error PROC				; COMDAT

; 8056 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	53		 push	 rbx
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H

; 8057 :     PyObject *repunicode = NULL; /* initialize to prevent gcc warning */
; 8058 :     Py_ssize_t size, repsize;
; 8059 :     Py_ssize_t newpos;
; 8060 :     enum PyUnicode_Kind kind;
; 8061 :     void *data;
; 8062 :     Py_ssize_t index;
; 8063 :     /* startpos for collecting unencodable chars */
; 8064 :     Py_ssize_t collstartpos = *inpos;
; 8065 :     Py_ssize_t collendpos = *inpos+1;
; 8066 :     Py_ssize_t collpos;
; 8067 :     char *encoding = "charmap";
; 8068 :     char *reason = "character maps to <undefined>";
; 8069 :     charmapencode_result x;
; 8070 :     Py_UCS4 ch;
; 8071 :     int val;
; 8072 : 
; 8073 :     if (PyUnicode_READY(unicode) == -1)

  0001f	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00023	4c 8b 3a	 mov	 r15, QWORD PTR [rdx]
  00026	4d 8b e8	 mov	 r13, r8
  00029	4d 8d 77 01	 lea	 r14, QWORD PTR [r15+1]
  0002d	4c 8b e2	 mov	 r12, rdx
  00030	48 8b d9	 mov	 rbx, rcx
  00033	4c 89 b4 24 e0
	00 00 00	 mov	 QWORD PTR collendpos$1$[rsp], r14
  0003b	4c 89 7c 24 58	 mov	 QWORD PTR collstartpos$1$[rsp], r15
  00040	75 1d		 jne	 SHORT $LN51@charmap_en
  00042	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00047	83 f8 ff	 cmp	 eax, -1
  0004a	75 13		 jne	 SHORT $LN51@charmap_en

; 8074 :         return -1;

  0004c	0b c0		 or	 eax, eax

; 8200 : }

  0004e	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  00055	41 5f		 pop	 r15
  00057	41 5e		 pop	 r14
  00059	41 5d		 pop	 r13
  0005b	41 5c		 pop	 r12
  0005d	5b		 pop	 rbx
  0005e	c3		 ret	 0
$LN51@charmap_en:
  0005f	48 89 ac 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rbp
  00067	48 89 b4 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rsi

; 8075 :     size = PyUnicode_GET_LENGTH(unicode);

  0006f	48 8b 73 60	 mov	 rsi, QWORD PTR [rbx+96]
  00073	48 89 bc 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rdi

; 8076 :     /* find all unencodable characters */
; 8077 :     while (collendpos < size) {

  0007b	4c 3b f6	 cmp	 r14, rsi
  0007e	0f 8d 00 02 00
	00		 jge	 $LN49@charmap_en
  00084	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:EncodingMapType
  0008b	0f 1f 44 00 00	 npad	 5
$LL50@charmap_en:

; 8078 :         PyObject *rep;
; 8079 :         if (Py_TYPE(mapping) == &EncodingMapType) {
; 8080 :             ch = PyUnicode_READ_CHAR(unicode, collendpos);

  00090	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00093	8b c8		 mov	 ecx, eax
  00095	c1 e9 02	 shr	 ecx, 2
  00098	83 e1 07	 and	 ecx, 7
  0009b	49 39 6d 58	 cmp	 QWORD PTR [r13+88], rbp
  0009f	0f 85 a9 00 00
	00		 jne	 $LN48@charmap_en
  000a5	83 f9 01	 cmp	 ecx, 1
  000a8	75 32		 jne	 SHORT $LN70@charmap_en
  000aa	a8 20		 test	 al, 32			; 00000020H
  000ac	74 20		 je	 SHORT $LN58@charmap_en
  000ae	a8 40		 test	 al, 64			; 00000040H
  000b0	74 0e		 je	 SHORT $LN56@charmap_en
  000b2	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  000b9	42 0f b6 0c 30	 movzx	 ecx, BYTE PTR [rax+r14]
  000be	eb 78		 jmp	 SHORT $LN69@charmap_en
$LN56@charmap_en:
  000c0	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  000c7	42 0f b6 0c 30	 movzx	 ecx, BYTE PTR [rax+r14]
  000cc	eb 6a		 jmp	 SHORT $LN69@charmap_en
$LN58@charmap_en:
  000ce	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  000d5	42 0f b6 0c 30	 movzx	 ecx, BYTE PTR [rax+r14]
  000da	eb 5c		 jmp	 SHORT $LN69@charmap_en
$LN70@charmap_en:
  000dc	83 f9 02	 cmp	 ecx, 2
  000df	75 32		 jne	 SHORT $LN68@charmap_en
  000e1	a8 20		 test	 al, 32			; 00000020H
  000e3	74 20		 je	 SHORT $LN62@charmap_en
  000e5	a8 40		 test	 al, 64			; 00000040H
  000e7	74 0e		 je	 SHORT $LN60@charmap_en
  000e9	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  000f0	42 0f b7 0c 70	 movzx	 ecx, WORD PTR [rax+r14*2]
  000f5	eb 41		 jmp	 SHORT $LN69@charmap_en
$LN60@charmap_en:
  000f7	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  000fe	42 0f b7 0c 70	 movzx	 ecx, WORD PTR [rax+r14*2]
  00103	eb 33		 jmp	 SHORT $LN69@charmap_en
$LN62@charmap_en:
  00105	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  0010c	42 0f b7 0c 70	 movzx	 ecx, WORD PTR [rax+r14*2]
  00111	eb 25		 jmp	 SHORT $LN69@charmap_en
$LN68@charmap_en:
  00113	a8 20		 test	 al, 32			; 00000020H
  00115	74 16		 je	 SHORT $LN66@charmap_en
  00117	a8 40		 test	 al, 64			; 00000040H
  00119	74 09		 je	 SHORT $LN64@charmap_en
  0011b	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00122	eb 10		 jmp	 SHORT $LN67@charmap_en
$LN64@charmap_en:
  00124	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  0012b	eb 07		 jmp	 SHORT $LN67@charmap_en
$LN66@charmap_en:
  0012d	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN67@charmap_en:
  00134	42 8b 0c b0	 mov	 ecx, DWORD PTR [rax+r14*4]
$LN69@charmap_en:

; 8081 :             val = encoding_map_lookup(ch, mapping);

  00138	49 8b d5	 mov	 rdx, r13
  0013b	e8 00 00 00 00	 call	 encoding_map_lookup

; 8082 :             if (val != -1)

  00140	83 f8 ff	 cmp	 eax, -1
  00143	0f 85 3b 01 00
	00		 jne	 $LN49@charmap_en

; 8083 :                 break;
; 8084 :             ++collendpos;
; 8085 :             continue;

  00149	e9 18 01 00 00	 jmp	 $LN124@charmap_en
$LN48@charmap_en:

; 8086 :         }
; 8087 : 
; 8088 :         ch = PyUnicode_READ_CHAR(unicode, collendpos);

  0014e	83 f9 01	 cmp	 ecx, 1
  00151	75 32		 jne	 SHORT $LN86@charmap_en
  00153	a8 20		 test	 al, 32			; 00000020H
  00155	74 20		 je	 SHORT $LN74@charmap_en
  00157	a8 40		 test	 al, 64			; 00000040H
  00159	74 0e		 je	 SHORT $LN72@charmap_en
  0015b	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00162	42 0f b6 0c 30	 movzx	 ecx, BYTE PTR [rax+r14]
  00167	eb 78		 jmp	 SHORT $LN85@charmap_en
$LN72@charmap_en:
  00169	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00170	42 0f b6 0c 30	 movzx	 ecx, BYTE PTR [rax+r14]
  00175	eb 6a		 jmp	 SHORT $LN85@charmap_en
$LN74@charmap_en:
  00177	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  0017e	42 0f b6 0c 30	 movzx	 ecx, BYTE PTR [rax+r14]
  00183	eb 5c		 jmp	 SHORT $LN85@charmap_en
$LN86@charmap_en:
  00185	83 f9 02	 cmp	 ecx, 2
  00188	75 32		 jne	 SHORT $LN84@charmap_en
  0018a	a8 20		 test	 al, 32			; 00000020H
  0018c	74 20		 je	 SHORT $LN78@charmap_en
  0018e	a8 40		 test	 al, 64			; 00000040H
  00190	74 0e		 je	 SHORT $LN76@charmap_en
  00192	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00199	42 0f b7 0c 70	 movzx	 ecx, WORD PTR [rax+r14*2]
  0019e	eb 41		 jmp	 SHORT $LN85@charmap_en
$LN76@charmap_en:
  001a0	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  001a7	42 0f b7 0c 70	 movzx	 ecx, WORD PTR [rax+r14*2]
  001ac	eb 33		 jmp	 SHORT $LN85@charmap_en
$LN78@charmap_en:
  001ae	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  001b5	42 0f b7 0c 70	 movzx	 ecx, WORD PTR [rax+r14*2]
  001ba	eb 25		 jmp	 SHORT $LN85@charmap_en
$LN84@charmap_en:
  001bc	a8 20		 test	 al, 32			; 00000020H
  001be	74 16		 je	 SHORT $LN82@charmap_en
  001c0	a8 40		 test	 al, 64			; 00000040H
  001c2	74 09		 je	 SHORT $LN80@charmap_en
  001c4	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  001cb	eb 10		 jmp	 SHORT $LN83@charmap_en
$LN80@charmap_en:
  001cd	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  001d4	eb 07		 jmp	 SHORT $LN83@charmap_en
$LN82@charmap_en:
  001d6	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN83@charmap_en:
  001dd	42 8b 0c b0	 mov	 ecx, DWORD PTR [rax+r14*4]
$LN85@charmap_en:

; 8089 :         rep = charmapencode_lookup(ch, mapping);

  001e1	49 8b d5	 mov	 rdx, r13
  001e4	e8 00 00 00 00	 call	 charmapencode_lookup
  001e9	48 8b f8	 mov	 rdi, rax

; 8090 :         if (rep==NULL)

  001ec	48 85 c0	 test	 rax, rax
  001ef	0f 84 93 04 00
	00		 je	 $LN132@charmap_en

; 8091 :             return -1;
; 8092 :         else if (rep!=Py_None) {

  001f5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  001fc	48 3b f8	 cmp	 rdi, rax
  001ff	75 7b		 jne	 SHORT $LN133@charmap_en

; 8094 :             break;
; 8095 :         }
; 8096 :         Py_DECREF(rep);

  00201	e8 00 00 00 00	 call	 _Py_PXCTX
  00206	85 c0		 test	 eax, eax
  00208	75 5c		 jne	 SHORT $LN124@charmap_en
  0020a	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0020e	a8 20		 test	 al, 32			; 00000020H
  00210	75 4c		 jne	 SHORT $LN118@charmap_en
  00212	84 c0		 test	 al, al
  00214	78 48		 js	 SHORT $LN118@charmap_en
  00216	a8 02		 test	 al, 2
  00218	75 4c		 jne	 SHORT $LN124@charmap_en
  0021a	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0021e	75 46		 jne	 SHORT $LN124@charmap_en
  00220	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00227	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0022e	4c 8b cf	 mov	 r9, rdi
  00231	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00237	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0023f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00244	48 8b cf	 mov	 rcx, rdi
  00247	85 c0		 test	 eax, eax
  00249	74 07		 je	 SHORT $LN123@charmap_en
  0024b	e8 00 00 00 00	 call	 _Px_Dealloc
  00250	eb 14		 jmp	 SHORT $LN124@charmap_en
$LN123@charmap_en:
  00252	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00256	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0025c	eb 08		 jmp	 SHORT $LN124@charmap_en
$LN118@charmap_en:
  0025e	48 8b cf	 mov	 rcx, rdi
  00261	e8 00 00 00 00	 call	 Px_DecRef
$LN124@charmap_en:

; 8097 :         ++collendpos;

  00266	49 ff c6	 inc	 r14
  00269	4c 89 b4 24 e0
	00 00 00	 mov	 QWORD PTR collendpos$1$[rsp], r14
  00271	4c 3b f6	 cmp	 r14, rsi
  00274	0f 8c 16 fe ff
	ff		 jl	 $LL50@charmap_en

; 8121 :                 return -1;
; 8122 :             }
; 8123 :             else if (x==enc_FAILED) {

  0027a	eb 08		 jmp	 SHORT $LN49@charmap_en
$LN133@charmap_en:

; 8093 :             Py_DECREF(rep);

  0027c	48 8b cf	 mov	 rcx, rdi
  0027f	e8 00 00 00 00	 call	 _Py_DecRef
$LN49@charmap_en:

; 8098 :     }
; 8099 :     /* cache callback name lookup
; 8100 :      * (if not done yet, i.e. it's the first error) */
; 8101 :     if (*known_errorHandler==-1) {

  00284	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR known_errorHandler$[rsp]
  0028c	4c 8b 94 24 10
	01 00 00	 mov	 r10, QWORD PTR errors$[rsp]
  00294	33 ed		 xor	 ebp, ebp
  00296	83 3a ff	 cmp	 DWORD PTR [rdx], -1
  00299	75 73		 jne	 SHORT $LN34@charmap_en

; 8102 :         if ((errors==NULL) || (!strcmp(errors, "strict")))

  0029b	4d 85 d2	 test	 r10, r10
  0029e	74 68		 je	 SHORT $LN41@charmap_en
  002a0	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  002a7	49 8b f2	 mov	 rsi, r10
  002aa	b9 07 00 00 00	 mov	 ecx, 7
  002af	f3 a6		 repe cmpsb
  002b1	74 55		 je	 SHORT $LN41@charmap_en

; 8104 :         else if (!strcmp(errors, "replace"))

  002b3	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_07CLEHDIEJ@replace?$AA@
  002ba	49 8b f2	 mov	 rsi, r10
  002bd	b9 08 00 00 00	 mov	 ecx, 8
  002c2	f3 a6		 repe cmpsb
  002c4	75 08		 jne	 SHORT $LN39@charmap_en

; 8105 :             *known_errorHandler = 2;

  002c6	c7 02 02 00 00
	00		 mov	 DWORD PTR [rdx], 2
  002cc	eb 40		 jmp	 SHORT $LN34@charmap_en
$LN39@charmap_en:

; 8106 :         else if (!strcmp(errors, "ignore"))

  002ce	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06GDPEBLPA@ignore?$AA@
  002d5	49 8b f2	 mov	 rsi, r10
  002d8	b9 07 00 00 00	 mov	 ecx, 7
  002dd	f3 a6		 repe cmpsb
  002df	75 08		 jne	 SHORT $LN37@charmap_en

; 8107 :             *known_errorHandler = 3;

  002e1	c7 02 03 00 00
	00		 mov	 DWORD PTR [rdx], 3
  002e7	eb 25		 jmp	 SHORT $LN34@charmap_en
$LN37@charmap_en:

; 8108 :         else if (!strcmp(errors, "xmlcharrefreplace"))

  002e9	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0BC@EBFFMGGH@xmlcharrefreplace?$AA@
  002f0	49 8b f2	 mov	 rsi, r10
  002f3	b9 12 00 00 00	 mov	 ecx, 18
  002f8	f3 a6		 repe cmpsb
  002fa	8b c5		 mov	 eax, ebp
  002fc	b9 04 00 00 00	 mov	 ecx, 4
  00301	0f 44 c1	 cmove	 eax, ecx
  00304	89 02		 mov	 DWORD PTR [rdx], eax

; 8109 :             *known_errorHandler = 4;
; 8110 :         else
; 8111 :             *known_errorHandler = 0;

  00306	eb 06		 jmp	 SHORT $LN34@charmap_en
$LN41@charmap_en:

; 8103 :             *known_errorHandler = 1;

  00308	c7 02 01 00 00
	00		 mov	 DWORD PTR [rdx], 1
$LN34@charmap_en:

; 8112 :     }
; 8113 :     switch (*known_errorHandler) {

  0030e	8b 12		 mov	 edx, DWORD PTR [rdx]
  00310	ff ca		 dec	 edx
  00312	0f 84 45 03 00
	00		 je	 $LN31@charmap_en
  00318	ff ca		 dec	 edx
  0031a	0f 84 f3 02 00
	00		 je	 $LN30@charmap_en
  00320	ff ca		 dec	 edx
  00322	0f 84 2d 03 00
	00		 je	 $LN27@charmap_en
  00328	ff ca		 dec	 edx
  0032a	0f 84 c2 01 00
	00		 je	 $LN22@charmap_en

; 8143 :                     raise_encode_exception(exceptionObject, encoding, unicode, collstartpos, collendpos, reason);
; 8144 :                     return -1;
; 8145 :                 }
; 8146 :             }
; 8147 :         }
; 8148 :         *inpos = collendpos;
; 8149 :         break;
; 8150 :     default:
; 8151 :         repunicode = unicode_encode_call_errorhandler(errors, errorHandler,
; 8152 :                                                       encoding, reason, unicode, exceptionObject,
; 8153 :                                                       collstartpos, collendpos, &newpos);

  00330	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR errorHandler$[rsp]
  00338	48 8d 44 24 50	 lea	 rax, QWORD PTR newpos$[rsp]
  0033d	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:??_C@_0BO@BLGNENDK@character?5maps?5to?5?$DMundefined?$DO?$AA@
  00344	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00349	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR exceptionObject$[rsp]
  00351	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  00356	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  0035b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00360	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07JDDMBNCD@charmap?$AA@
  00367	4d 8b cd	 mov	 r9, r13
  0036a	49 8b ca	 mov	 rcx, r10
  0036d	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00372	e8 00 00 00 00	 call	 unicode_encode_call_errorhandler
  00377	48 8b f0	 mov	 rsi, rax

; 8154 :         if (repunicode == NULL)

  0037a	48 85 c0	 test	 rax, rax

; 8155 :             return -1;

  0037d	0f 84 05 03 00
	00		 je	 $LN132@charmap_en

; 8156 :         if (PyBytes_Check(repunicode)) {

  00383	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00387	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  00391	0f 84 94 00 00
	00		 je	 $LN10@charmap_en

; 8157 :             /* Directly copy bytes result to output. */
; 8158 :             Py_ssize_t outsize = PyBytes_Size(*res);

  00397	48 8b 9c 24 18
	01 00 00	 mov	 rbx, QWORD PTR res$[rsp]
  0039f	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  003a2	e8 00 00 00 00	 call	 PyBytes_Size

; 8159 :             Py_ssize_t requiredsize;
; 8160 :             repsize = PyBytes_Size(repunicode);

  003a7	48 8b ce	 mov	 rcx, rsi
  003aa	48 8b f8	 mov	 rdi, rax
  003ad	e8 00 00 00 00	 call	 PyBytes_Size

; 8161 :             requiredsize = *respos + repsize;

  003b2	48 8b ac 24 20
	01 00 00	 mov	 rbp, QWORD PTR respos$[rsp]
  003ba	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
  003be	4c 8b e0	 mov	 r12, rax
  003c1	48 8d 14 08	 lea	 rdx, QWORD PTR [rax+rcx]

; 8162 :             if (requiredsize > outsize)

  003c5	48 3b d7	 cmp	 rdx, rdi
  003c8	7e 19		 jle	 SHORT $LN8@charmap_en

; 8163 :                 /* Make room for all additional bytes. */
; 8164 :                 if (charmapencode_resize(res, respos, requiredsize)) {

  003ca	48 8b cb	 mov	 rcx, rbx
  003cd	e8 00 00 00 00	 call	 charmapencode_resize
  003d2	85 c0		 test	 eax, eax
  003d4	74 0d		 je	 SHORT $LN8@charmap_en
$LN151@charmap_en:

; 8165 :                     Py_DECREF(repunicode);

  003d6	48 8b ce	 mov	 rcx, rsi
  003d9	e8 00 00 00 00	 call	 _Py_DecRef

; 8166 :                     return -1;

  003de	e9 a5 02 00 00	 jmp	 $LN132@charmap_en
$LN8@charmap_en:

; 8167 :                 }
; 8168 :             memcpy(PyBytes_AsString(*res) + *respos,
; 8169 :                    PyBytes_AsString(repunicode),  repsize);

  003e3	48 8b ce	 mov	 rcx, rsi
  003e6	e8 00 00 00 00	 call	 PyBytes_AsString
  003eb	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  003ee	48 8b f8	 mov	 rdi, rax
  003f1	e8 00 00 00 00	 call	 PyBytes_AsString
  003f6	4d 8b c4	 mov	 r8, r12
  003f9	48 03 45 00	 add	 rax, QWORD PTR [rbp]
  003fd	48 8b d7	 mov	 rdx, rdi
  00400	48 8b c8	 mov	 rcx, rax
  00403	e8 00 00 00 00	 call	 memcpy

; 8170 :             *respos += repsize;

  00408	4c 01 65 00	 add	 QWORD PTR [rbp], r12
$LN4@charmap_en:

; 8171 :             *inpos = newpos;

  0040c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR inpos$[rsp]
  00414	48 8b 44 24 50	 mov	 rax, QWORD PTR newpos$[rsp]
  00419	48 89 01	 mov	 QWORD PTR [rcx], rax

; 8172 :             Py_DECREF(repunicode);

  0041c	48 8b ce	 mov	 rcx, rsi
  0041f	e8 00 00 00 00	 call	 _Py_DecRef

; 8194 :             }
; 8195 :         }
; 8196 :         *inpos = newpos;
; 8197 :         Py_DECREF(repunicode);
; 8198 :     }
; 8199 :     return 0;

  00424	33 c0		 xor	 eax, eax
  00426	e9 60 02 00 00	 jmp	 $LN149@charmap_en
$LN10@charmap_en:

; 8173 :             break;
; 8174 :         }
; 8175 :         /* generate replacement  */
; 8176 :         if (PyUnicode_READY(repunicode) == -1) {

  0042b	f6 46 70 80	 test	 BYTE PTR [rsi+112], 128	; 00000080H
  0042f	75 0d		 jne	 SHORT $LN7@charmap_en
  00431	48 8b ce	 mov	 rcx, rsi
  00434	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00439	83 f8 ff	 cmp	 eax, -1

; 8177 :             Py_DECREF(repunicode);
; 8178 :             return -1;

  0043c	74 98		 je	 SHORT $LN151@charmap_en
$LN7@charmap_en:

; 8179 :         }
; 8180 :         repsize = PyUnicode_GET_LENGTH(repunicode);
; 8181 :         data = PyUnicode_DATA(repunicode);

  0043e	8b 46 70	 mov	 eax, DWORD PTR [rsi+112]
  00441	4c 8b 76 60	 mov	 r14, QWORD PTR [rsi+96]
  00445	a8 20		 test	 al, 32			; 00000020H
  00447	74 16		 je	 SHORT $LN108@charmap_en
  00449	a8 40		 test	 al, 64			; 00000040H
  0044b	74 09		 je	 SHORT $LN106@charmap_en
  0044d	48 8d be 80 00
	00 00		 lea	 rdi, QWORD PTR [rsi+128]
  00454	eb 10		 jmp	 SHORT $LN109@charmap_en
$LN106@charmap_en:
  00456	48 8d be a0 00
	00 00		 lea	 rdi, QWORD PTR [rsi+160]
  0045d	eb 07		 jmp	 SHORT $LN109@charmap_en
$LN108@charmap_en:
  0045f	48 8b be a0 00
	00 00		 mov	 rdi, QWORD PTR [rsi+160]
$LN109@charmap_en:

; 8182 :         kind = PyUnicode_KIND(repunicode);

  00466	c1 e8 02	 shr	 eax, 2
  00469	83 e0 07	 and	 eax, 7

; 8184 :             Py_UCS4 repch = PyUnicode_READ(kind, data, index);

  0046c	4c 63 e0	 movsxd	 r12, eax
  0046f	4d 85 f6	 test	 r14, r14
  00472	7e 98		 jle	 SHORT $LN4@charmap_en

; 8183 :         for (index = 0; index < repsize; index++) {

  00474	4c 8b bc 24 20
	01 00 00	 mov	 r15, QWORD PTR respos$[rsp]
  0047c	0f 1f 40 00	 npad	 4
$LL6@charmap_en:

; 8184 :             Py_UCS4 repch = PyUnicode_READ(kind, data, index);

  00480	49 83 fc 01	 cmp	 r12, 1
  00484	75 06		 jne	 SHORT $LN112@charmap_en
  00486	0f b6 0c 2f	 movzx	 ecx, BYTE PTR [rdi+rbp]
  0048a	eb 0f		 jmp	 SHORT $LN111@charmap_en
$LN112@charmap_en:
  0048c	49 83 fc 02	 cmp	 r12, 2
  00490	75 06		 jne	 SHORT $LN110@charmap_en
  00492	0f b7 0c 6f	 movzx	 ecx, WORD PTR [rdi+rbp*2]
  00496	eb 03		 jmp	 SHORT $LN111@charmap_en
$LN110@charmap_en:
  00498	8b 0c af	 mov	 ecx, DWORD PTR [rdi+rbp*4]
$LN111@charmap_en:

; 8185 :             x = charmapencode_output(repch, mapping, res, respos);

  0049b	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR res$[rsp]
  004a3	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR mapping$[rsp]
  004ab	4d 8b cf	 mov	 r9, r15
  004ae	e8 00 00 00 00	 call	 charmapencode_output

; 8186 :             if (x==enc_EXCEPTION) {

  004b3	83 f8 02	 cmp	 eax, 2
  004b6	0f 84 1a ff ff
	ff		 je	 $LN151@charmap_en

; 8187 :                 Py_DECREF(repunicode);
; 8188 :                 return -1;
; 8189 :             }
; 8190 :             else if (x==enc_FAILED) {

  004bc	83 f8 01	 cmp	 eax, 1
  004bf	74 0d		 je	 SHORT $LN135@charmap_en

; 8183 :         for (index = 0; index < repsize; index++) {

  004c1	48 ff c5	 inc	 rbp
  004c4	49 3b ee	 cmp	 rbp, r14
  004c7	7c b7		 jl	 SHORT $LL6@charmap_en

; 8121 :                 return -1;
; 8122 :             }
; 8123 :             else if (x==enc_FAILED) {

  004c9	e9 3e ff ff ff	 jmp	 $LN4@charmap_en
$LN135@charmap_en:

; 8191 :                 Py_DECREF(repunicode);

  004ce	48 8b ce	 mov	 rcx, rsi
  004d1	e8 00 00 00 00	 call	 _Py_DecRef

; 8192 :                 raise_encode_exception(exceptionObject, encoding, unicode, collstartpos, collendpos, reason);

  004d6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR collendpos$1$[rsp]
  004de	4c 8b 4c 24 58	 mov	 r9, QWORD PTR collstartpos$1$[rsp]
  004e3	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  004e8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax

; 8193 :                 return -1;

  004ed	e9 7f 01 00 00	 jmp	 $LN150@charmap_en
$LN22@charmap_en:

; 8131 :         break;
; 8132 :     case 4: /* xmlcharrefreplace */
; 8133 :         /* generate replacement (temporarily (mis)uses p) */
; 8134 :         for (collpos = collstartpos; collpos < collendpos; ++collpos) {

  004f2	49 8b f7	 mov	 rsi, r15
  004f5	4d 3b fe	 cmp	 r15, r14
  004f8	0f 8d 57 01 00
	00		 jge	 $LN27@charmap_en
  004fe	48 8b ac 24 20
	01 00 00	 mov	 rbp, QWORD PTR respos$[rsp]
  00506	4c 8b a4 24 18
	01 00 00	 mov	 r12, QWORD PTR res$[rsp]
  0050e	66 90		 npad	 2
$LL21@charmap_en:

; 8135 :             char buffer[2+29+1+1];
; 8136 :             char *cp;
; 8137 :             sprintf(buffer, "&#%d;", (int)PyUnicode_READ_CHAR(unicode, collpos));

  00510	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00513	8b c8		 mov	 ecx, eax
  00515	c1 e9 02	 shr	 ecx, 2
  00518	83 e1 07	 and	 ecx, 7
  0051b	83 f9 01	 cmp	 ecx, 1
  0051e	75 32		 jne	 SHORT $LN102@charmap_en
  00520	a8 20		 test	 al, 32			; 00000020H
  00522	74 20		 je	 SHORT $LN90@charmap_en
  00524	a8 40		 test	 al, 64			; 00000040H
  00526	74 0e		 je	 SHORT $LN88@charmap_en
  00528	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  0052f	44 0f b6 04 30	 movzx	 r8d, BYTE PTR [rax+rsi]
  00534	eb 78		 jmp	 SHORT $LN101@charmap_en
$LN88@charmap_en:
  00536	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  0053d	44 0f b6 04 30	 movzx	 r8d, BYTE PTR [rax+rsi]
  00542	eb 6a		 jmp	 SHORT $LN101@charmap_en
$LN90@charmap_en:
  00544	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  0054b	44 0f b6 04 30	 movzx	 r8d, BYTE PTR [rax+rsi]
  00550	eb 5c		 jmp	 SHORT $LN101@charmap_en
$LN102@charmap_en:
  00552	83 f9 02	 cmp	 ecx, 2
  00555	75 32		 jne	 SHORT $LN100@charmap_en
  00557	a8 20		 test	 al, 32			; 00000020H
  00559	74 20		 je	 SHORT $LN94@charmap_en
  0055b	a8 40		 test	 al, 64			; 00000040H
  0055d	74 0e		 je	 SHORT $LN92@charmap_en
  0055f	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00566	44 0f b7 04 70	 movzx	 r8d, WORD PTR [rax+rsi*2]
  0056b	eb 41		 jmp	 SHORT $LN101@charmap_en
$LN92@charmap_en:
  0056d	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00574	44 0f b7 04 70	 movzx	 r8d, WORD PTR [rax+rsi*2]
  00579	eb 33		 jmp	 SHORT $LN101@charmap_en
$LN94@charmap_en:
  0057b	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  00582	44 0f b7 04 70	 movzx	 r8d, WORD PTR [rax+rsi*2]
  00587	eb 25		 jmp	 SHORT $LN101@charmap_en
$LN100@charmap_en:
  00589	a8 20		 test	 al, 32			; 00000020H
  0058b	74 16		 je	 SHORT $LN98@charmap_en
  0058d	a8 40		 test	 al, 64			; 00000040H
  0058f	74 09		 je	 SHORT $LN96@charmap_en
  00591	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00598	eb 10		 jmp	 SHORT $LN99@charmap_en
$LN96@charmap_en:
  0059a	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  005a1	eb 07		 jmp	 SHORT $LN99@charmap_en
$LN98@charmap_en:
  005a3	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN99@charmap_en:
  005aa	44 8b 04 b0	 mov	 r8d, DWORD PTR [rax+rsi*4]
$LN101@charmap_en:
  005ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL?$AA@
  005b5	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buffer$134235[rsp]
  005ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 8138 :             for (cp = buffer; *cp; ++cp) {

  005c0	80 7c 24 60 00	 cmp	 BYTE PTR buffer$134235[rsp], 0
  005c5	48 8d 7c 24 60	 lea	 rdi, QWORD PTR buffer$134235[rsp]
  005ca	74 2b		 je	 SHORT $LN20@charmap_en
  005cc	0f 1f 40 00	 npad	 4
$LL18@charmap_en:

; 8139 :                 x = charmapencode_output(*cp, mapping, res, respos);

  005d0	0f be 0f	 movsx	 ecx, BYTE PTR [rdi]
  005d3	4c 8b cd	 mov	 r9, rbp
  005d6	4d 8b c4	 mov	 r8, r12
  005d9	49 8b d5	 mov	 rdx, r13
  005dc	e8 00 00 00 00	 call	 charmapencode_output

; 8140 :                 if (x==enc_EXCEPTION)

  005e1	83 f8 02	 cmp	 eax, 2
  005e4	0f 84 9e 00 00
	00		 je	 $LN132@charmap_en

; 8141 :                     return -1;
; 8142 :                 else if (x==enc_FAILED) {

  005ea	83 f8 01	 cmp	 eax, 1
  005ed	74 6e		 je	 SHORT $LN31@charmap_en

; 8138 :             for (cp = buffer; *cp; ++cp) {

  005ef	48 ff c7	 inc	 rdi
  005f2	80 3f 00	 cmp	 BYTE PTR [rdi], 0
  005f5	75 d9		 jne	 SHORT $LL18@charmap_en
$LN20@charmap_en:

; 8131 :         break;
; 8132 :     case 4: /* xmlcharrefreplace */
; 8133 :         /* generate replacement (temporarily (mis)uses p) */
; 8134 :         for (collpos = collstartpos; collpos < collendpos; ++collpos) {

  005f7	48 ff c6	 inc	 rsi
  005fa	49 3b f6	 cmp	 rsi, r14
  005fd	0f 8c 0d ff ff
	ff		 jl	 $LL21@charmap_en

; 8194 :             }
; 8195 :         }
; 8196 :         *inpos = newpos;
; 8197 :         Py_DECREF(repunicode);
; 8198 :     }
; 8199 :     return 0;

  00603	4c 8b a4 24 e8
	00 00 00	 mov	 r12, QWORD PTR inpos$[rsp]
  0060b	33 c0		 xor	 eax, eax
  0060d	4d 89 34 24	 mov	 QWORD PTR [r12], r14
  00611	eb 78		 jmp	 SHORT $LN149@charmap_en
$LN30@charmap_en:

; 8117 :     case 2: /* replace */
; 8118 :         for (collpos = collstartpos; collpos<collendpos; ++collpos) {

  00613	49 8b ff	 mov	 rdi, r15
  00616	4d 3b fe	 cmp	 r15, r14
  00619	7d 3a		 jge	 SHORT $LN27@charmap_en
  0061b	48 8b b4 24 20
	01 00 00	 mov	 rsi, QWORD PTR respos$[rsp]
  00623	48 8b ac 24 18
	01 00 00	 mov	 rbp, QWORD PTR res$[rsp]
  0062b	0f 1f 44 00 00	 npad	 5
$LL29@charmap_en:

; 8119 :             x = charmapencode_output('?', mapping, res, respos);

  00630	4c 8b ce	 mov	 r9, rsi
  00633	4c 8b c5	 mov	 r8, rbp
  00636	49 8b d5	 mov	 rdx, r13
  00639	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  0063e	e8 00 00 00 00	 call	 charmapencode_output

; 8120 :             if (x==enc_EXCEPTION) {

  00643	83 f8 02	 cmp	 eax, 2
  00646	74 40		 je	 SHORT $LN132@charmap_en

; 8121 :                 return -1;
; 8122 :             }
; 8123 :             else if (x==enc_FAILED) {

  00648	83 f8 01	 cmp	 eax, 1
  0064b	74 10		 je	 SHORT $LN31@charmap_en

; 8117 :     case 2: /* replace */
; 8118 :         for (collpos = collstartpos; collpos<collendpos; ++collpos) {

  0064d	48 ff c7	 inc	 rdi
  00650	49 3b fe	 cmp	 rdi, r14
  00653	7c db		 jl	 SHORT $LL29@charmap_en
$LN27@charmap_en:

; 8124 :                 raise_encode_exception(exceptionObject, encoding, unicode, collstartpos, collendpos, reason);
; 8125 :                 return -1;
; 8126 :             }
; 8127 :         }
; 8128 :         /* fall through */
; 8129 :     case 3: /* ignore */
; 8130 :         *inpos = collendpos;

  00655	4d 89 34 24	 mov	 QWORD PTR [r12], r14

; 8194 :             }
; 8195 :         }
; 8196 :         *inpos = newpos;
; 8197 :         Py_DECREF(repunicode);
; 8198 :     }
; 8199 :     return 0;

  00659	33 c0		 xor	 eax, eax
  0065b	eb 2e		 jmp	 SHORT $LN149@charmap_en
$LN31@charmap_en:

; 8114 :     case 1: /* strict */
; 8115 :         raise_encode_exception(exceptionObject, encoding, unicode, collstartpos, collendpos, reason);

  0065d	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:??_C@_0BO@BLGNENDK@character?5maps?5to?5?$DMundefined?$DO?$AA@
  00664	4d 8b cf	 mov	 r9, r15
  00667	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  0066c	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
$LN150@charmap_en:
  00671	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR exceptionObject$[rsp]
  00679	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07JDDMBNCD@charmap?$AA@
  00680	4c 8b c3	 mov	 r8, rbx
  00683	e8 00 00 00 00	 call	 raise_encode_exception
$LN132@charmap_en:

; 8116 :         return -1;

  00688	83 c8 ff	 or	 eax, -1
$LN149@charmap_en:
  0068b	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+160]
  00693	48 8b ac 24 a8
	00 00 00	 mov	 rbp, QWORD PTR [rsp+168]
  0069b	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR [rsp+152]

; 8200 : }

  006a3	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  006aa	41 5f		 pop	 r15
  006ac	41 5e		 pop	 r14
  006ae	41 5d		 pop	 r13
  006b0	41 5c		 pop	 r12
  006b2	5b		 pop	 rbx
  006b3	c3		 ret	 0
charmap_encoding_error ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_EncodeCharmap
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_EncodeCharmap DD imagerel $LN59
	DD	imagerel $LN59+94
	DD	imagerel $unwind$_PyUnicode_EncodeCharmap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyUnicode_EncodeCharmap DD imagerel $LN59+94
	DD	imagerel $LN59+546
	DD	imagerel $chain$0$_PyUnicode_EncodeCharmap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_PyUnicode_EncodeCharmap DD imagerel $LN59+546
	DD	imagerel $LN59+596
	DD	imagerel $chain$2$_PyUnicode_EncodeCharmap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_PyUnicode_EncodeCharmap DD 020021H
	DD	017d400H
	DD	imagerel $LN59
	DD	imagerel $LN59+94
	DD	imagerel $unwind$_PyUnicode_EncodeCharmap
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyUnicode_EncodeCharmap DD 020821H
	DD	017d408H
	DD	imagerel $LN59
	DD	imagerel $LN59+94
	DD	imagerel $unwind$_PyUnicode_EncodeCharmap
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_EncodeCharmap DD 081201H
	DD	0f00bd212H
	DD	0c007e009H
	DD	060047005H
	DD	050023003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_EncodeCharmap
_TEXT	SEGMENT
inpos$ = 80
respos$ = 88
errorHandler$ = 96
exc$ = 104
known_errorHandler$ = 176
unicode$ = 176
mapping$ = 184
errors$ = 192
res$ = 200
_PyUnicode_EncodeCharmap PROC				; COMDAT

; 8206 : {

$LN59:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 56		 push	 r14
  00009	41 57		 push	 r15
  0000b	48 8b ec	 mov	 rbp, rsp
  0000e	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 8207 :     /* output object */
; 8208 :     PyObject *res = NULL;

  00012	33 ff		 xor	 edi, edi

; 8209 :     /* current input position */
; 8210 :     Py_ssize_t inpos = 0;
; 8211 :     Py_ssize_t size;
; 8212 :     /* current output position */
; 8213 :     Py_ssize_t respos = 0;
; 8214 :     PyObject *errorHandler = NULL;
; 8215 :     PyObject *exc = NULL;
; 8216 :     /* the following variable is used for caching string comparisons
; 8217 :      * -1=not initialized, 0=unknown, 1=strict, 2=replace,
; 8218 :      * 3=ignore, 4=xmlcharrefreplace */
; 8219 :     int known_errorHandler = -1;
; 8220 : 
; 8221 :     if (PyUnicode_READY(unicode) == -1)

  00014	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00018	4d 8b f8	 mov	 r15, r8
  0001b	4c 8b f2	 mov	 r14, rdx
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	c7 45 40 ff ff
	ff ff		 mov	 DWORD PTR known_errorHandler$[rbp-112], -1
  00028	48 89 7d 58	 mov	 QWORD PTR res$[rbp-112], rdi
  0002c	48 89 7d e0	 mov	 QWORD PTR inpos$[rbp-112], rdi
  00030	48 89 7d e8	 mov	 QWORD PTR respos$[rbp-112], rdi
  00034	8b f7		 mov	 esi, edi
  00036	48 89 7d f0	 mov	 QWORD PTR errorHandler$[rbp-112], rdi
  0003a	44 8b e7	 mov	 r12d, edi
  0003d	48 89 7d f8	 mov	 QWORD PTR exc$[rbp-112], rdi
  00041	75 1b		 jne	 SHORT $LN32@PyUnicode_@28
  00043	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00048	83 f8 ff	 cmp	 eax, -1
  0004b	75 11		 jne	 SHORT $LN32@PyUnicode_@28

; 8222 :         return NULL;

  0004d	33 c0		 xor	 eax, eax

; 8270 : }

  0004f	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00053	41 5f		 pop	 r15
  00055	41 5e		 pop	 r14
  00057	41 5c		 pop	 r12
  00059	5f		 pop	 rdi
  0005a	5e		 pop	 rsi
  0005b	5b		 pop	 rbx
  0005c	5d		 pop	 rbp
  0005d	c3		 ret	 0
$LN32@PyUnicode_@28:
  0005e	4c 89 ac 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], r13

; 8223 :     size = PyUnicode_GET_LENGTH(unicode);

  00066	4c 8b 6b 60	 mov	 r13, QWORD PTR [rbx+96]

; 8224 : 
; 8225 :     /* Default to Latin-1 */
; 8226 :     if (mapping == NULL)

  0006a	4d 85 f6	 test	 r14, r14
  0006d	75 16		 jne	 SHORT $LN31@PyUnicode_@28

; 8227 :         return unicode_encode_ucs1(unicode, errors, 256);

  0006f	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00075	49 8b d7	 mov	 rdx, r15
  00078	48 8b cb	 mov	 rcx, rbx
  0007b	e8 00 00 00 00	 call	 unicode_encode_ucs1
  00080	e9 86 01 00 00	 jmp	 $LN58@PyUnicode_@28
$LN31@PyUnicode_@28:

; 8228 : 
; 8229 :     /* allocate enough for a simple encoding without
; 8230 :        replacements, if we need more, we'll resize */
; 8231 :     res = PyBytes_FromStringAndSize(NULL, size);

  00085	49 8b d5	 mov	 rdx, r13
  00088	33 c9		 xor	 ecx, ecx
  0008a	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0008f	48 89 45 58	 mov	 QWORD PTR res$[rbp-112], rax

; 8232 :     if (res == NULL)

  00093	48 85 c0	 test	 rax, rax
  00096	0f 84 6d 01 00
	00		 je	 $LN3@PyUnicode_@28

; 8233 :         goto onError;
; 8234 :     if (size == 0)

  0009c	4d 85 ed	 test	 r13, r13

; 8235 :         return res;

  0009f	0f 84 66 01 00
	00		 je	 $LN58@PyUnicode_@28

; 8236 : 
; 8237 :     while (inpos<size) {

  000a5	0f 8e 20 01 00
	00		 jle	 $LN27@PyUnicode_@28
  000ab	0f 1f 44 00 00	 npad	 5
$LL28@PyUnicode_@28:

; 8238 :         Py_UCS4 ch = PyUnicode_READ_CHAR(unicode, inpos);

  000b0	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  000b3	8b c8		 mov	 ecx, eax
  000b5	c1 e9 02	 shr	 ecx, 2
  000b8	83 e1 07	 and	 ecx, 7
  000bb	83 f9 01	 cmp	 ecx, 1
  000be	75 2f		 jne	 SHORT $LN51@PyUnicode_@28
  000c0	a8 20		 test	 al, 32			; 00000020H
  000c2	74 1e		 je	 SHORT $LN39@PyUnicode_@28
  000c4	a8 40		 test	 al, 64			; 00000040H
  000c6	74 0d		 je	 SHORT $LN37@PyUnicode_@28
  000c8	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  000cf	0f b6 0c 38	 movzx	 ecx, BYTE PTR [rax+rdi]
  000d3	eb 72		 jmp	 SHORT $LN50@PyUnicode_@28
$LN37@PyUnicode_@28:
  000d5	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  000dc	0f b6 0c 38	 movzx	 ecx, BYTE PTR [rax+rdi]
  000e0	eb 65		 jmp	 SHORT $LN50@PyUnicode_@28
$LN39@PyUnicode_@28:
  000e2	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  000e9	0f b6 0c 38	 movzx	 ecx, BYTE PTR [rax+rdi]
  000ed	eb 58		 jmp	 SHORT $LN50@PyUnicode_@28
$LN51@PyUnicode_@28:
  000ef	83 f9 02	 cmp	 ecx, 2
  000f2	75 2f		 jne	 SHORT $LN49@PyUnicode_@28
  000f4	a8 20		 test	 al, 32			; 00000020H
  000f6	74 1e		 je	 SHORT $LN43@PyUnicode_@28
  000f8	a8 40		 test	 al, 64			; 00000040H
  000fa	74 0d		 je	 SHORT $LN41@PyUnicode_@28
  000fc	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00103	0f b7 0c 78	 movzx	 ecx, WORD PTR [rax+rdi*2]
  00107	eb 3e		 jmp	 SHORT $LN50@PyUnicode_@28
$LN41@PyUnicode_@28:
  00109	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00110	0f b7 0c 78	 movzx	 ecx, WORD PTR [rax+rdi*2]
  00114	eb 31		 jmp	 SHORT $LN50@PyUnicode_@28
$LN43@PyUnicode_@28:
  00116	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  0011d	0f b7 0c 78	 movzx	 ecx, WORD PTR [rax+rdi*2]
  00121	eb 24		 jmp	 SHORT $LN50@PyUnicode_@28
$LN49@PyUnicode_@28:
  00123	a8 20		 test	 al, 32			; 00000020H
  00125	74 16		 je	 SHORT $LN47@PyUnicode_@28
  00127	a8 40		 test	 al, 64			; 00000040H
  00129	74 09		 je	 SHORT $LN45@PyUnicode_@28
  0012b	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00132	eb 10		 jmp	 SHORT $LN48@PyUnicode_@28
$LN45@PyUnicode_@28:
  00134	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  0013b	eb 07		 jmp	 SHORT $LN48@PyUnicode_@28
$LN47@PyUnicode_@28:
  0013d	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN48@PyUnicode_@28:
  00144	8b 0c b8	 mov	 ecx, DWORD PTR [rax+rdi*4]
$LN50@PyUnicode_@28:

; 8239 :         /* try to encode it */
; 8240 :         charmapencode_result x = charmapencode_output(ch, mapping, &res, &respos);

  00147	4c 8d 4d e8	 lea	 r9, QWORD PTR respos$[rbp-112]
  0014b	4c 8d 45 58	 lea	 r8, QWORD PTR res$[rbp-112]
  0014f	49 8b d6	 mov	 rdx, r14
  00152	e8 00 00 00 00	 call	 charmapencode_output

; 8241 :         if (x==enc_EXCEPTION) /* error */

  00157	83 f8 02	 cmp	 eax, 2
  0015a	0f 84 c2 00 00
	00		 je	 $LN56@PyUnicode_@28

; 8242 :             goto onError;
; 8243 :         if (x==enc_FAILED) { /* unencodable character */

  00160	83 f8 01	 cmp	 eax, 1
  00163	75 46		 jne	 SHORT $LN25@PyUnicode_@28

; 8244 :             if (charmap_encoding_error(unicode, &inpos, mapping,
; 8245 :                                        &exc,
; 8246 :                                        &known_errorHandler, &errorHandler, errors,
; 8247 :                                        &res, &respos)) {

  00165	48 8d 45 e8	 lea	 rax, QWORD PTR respos$[rbp-112]
  00169	4c 8d 4d f8	 lea	 r9, QWORD PTR exc$[rbp-112]
  0016d	48 8d 55 e0	 lea	 rdx, QWORD PTR inpos$[rbp-112]
  00171	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00176	48 8d 45 58	 lea	 rax, QWORD PTR res$[rbp-112]
  0017a	4d 8b c6	 mov	 r8, r14
  0017d	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00182	48 8d 45 f0	 lea	 rax, QWORD PTR errorHandler$[rbp-112]
  00186	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  0018b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00190	48 8d 45 40	 lea	 rax, QWORD PTR known_errorHandler$[rbp-112]
  00194	48 8b cb	 mov	 rcx, rbx
  00197	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019c	e8 00 00 00 00	 call	 charmap_encoding_error
  001a1	85 c0		 test	 eax, eax
  001a3	75 7d		 jne	 SHORT $LN56@PyUnicode_@28

; 8248 :                 goto onError;
; 8249 :             }
; 8250 :         }
; 8251 :         else

  001a5	48 8b 7d e0	 mov	 rdi, QWORD PTR inpos$[rbp-112]
  001a9	eb 07		 jmp	 SHORT $LN23@PyUnicode_@28
$LN25@PyUnicode_@28:

; 8252 :             /* done with this character => adjust input position */
; 8253 :             ++inpos;

  001ab	48 ff c7	 inc	 rdi
  001ae	48 89 7d e0	 mov	 QWORD PTR inpos$[rbp-112], rdi
$LN23@PyUnicode_@28:

; 8236 : 
; 8237 :     while (inpos<size) {

  001b2	49 3b fd	 cmp	 rdi, r13
  001b5	0f 8c f5 fe ff
	ff		 jl	 $LL28@PyUnicode_@28
  001bb	48 8b 45 58	 mov	 rax, QWORD PTR res$[rbp-112]
  001bf	48 8b 7d e8	 mov	 rdi, QWORD PTR respos$[rbp-112]
  001c3	48 8b 75 f0	 mov	 rsi, QWORD PTR errorHandler$[rbp-112]
  001c7	4c 8b 65 f8	 mov	 r12, QWORD PTR exc$[rbp-112]
$LN27@PyUnicode_@28:

; 8254 :     }
; 8255 : 
; 8256 :     /* Resize if we allocated to much */
; 8257 :     if (respos<PyBytes_GET_SIZE(res))

  001cb	48 3b 78 60	 cmp	 rdi, QWORD PTR [rax+96]
  001cf	7d 5f		 jge	 SHORT $LN20@PyUnicode_@28

; 8258 :         if (_PyBytes_Resize(&res, respos) < 0)

  001d1	48 8d 4d 58	 lea	 rcx, QWORD PTR res$[rbp-112]
  001d5	48 8b d7	 mov	 rdx, rdi
  001d8	e8 00 00 00 00	 call	 _PyBytes_Resize
  001dd	85 c0		 test	 eax, eax
  001df	79 4b		 jns	 SHORT $LN57@PyUnicode_@28
$onError$134364:

; 8264 : 
; 8265 :   onError:
; 8266 :     Py_XDECREF(res);

  001e1	48 8b 4d 58	 mov	 rcx, QWORD PTR res$[rbp-112]
  001e5	48 85 c9	 test	 rcx, rcx
  001e8	74 05		 je	 SHORT $LN11@PyUnicode_@28
  001ea	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@PyUnicode_@28:

; 8267 :     Py_XDECREF(exc);

  001ef	4d 85 e4	 test	 r12, r12
  001f2	74 08		 je	 SHORT $LN7@PyUnicode_@28
  001f4	49 8b cc	 mov	 rcx, r12
  001f7	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@PyUnicode_@28:

; 8268 :     Py_XDECREF(errorHandler);

  001fc	48 85 f6	 test	 rsi, rsi
  001ff	74 08		 je	 SHORT $LN3@PyUnicode_@28
  00201	48 8b ce	 mov	 rcx, rsi
  00204	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyUnicode_@28:

; 8269 :     return NULL;

  00209	33 c0		 xor	 eax, eax
$LN58@PyUnicode_@28:
  0020b	4c 8b ac 24 b8
	00 00 00	 mov	 r13, QWORD PTR [rsp+184]

; 8270 : }

  00213	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00217	41 5f		 pop	 r15
  00219	41 5e		 pop	 r14
  0021b	41 5c		 pop	 r12
  0021d	5f		 pop	 rdi
  0021e	5e		 pop	 rsi
  0021f	5b		 pop	 rbx
  00220	5d		 pop	 rbp
  00221	c3		 ret	 0
$LN56@PyUnicode_@28:

; 8258 :         if (_PyBytes_Resize(&res, respos) < 0)

  00222	48 8b 75 f0	 mov	 rsi, QWORD PTR errorHandler$[rbp-112]
  00226	4c 8b 65 f8	 mov	 r12, QWORD PTR exc$[rbp-112]
  0022a	eb b5		 jmp	 SHORT $onError$134364
$LN57@PyUnicode_@28:

; 8269 :     return NULL;

  0022c	48 8b 45 58	 mov	 rax, QWORD PTR res$[rbp-112]
$LN20@PyUnicode_@28:

; 8259 :             goto onError;
; 8260 : 
; 8261 :     Py_XDECREF(exc);

  00230	4d 85 e4	 test	 r12, r12
  00233	74 0c		 je	 SHORT $LN19@PyUnicode_@28
  00235	49 8b cc	 mov	 rcx, r12
  00238	e8 00 00 00 00	 call	 _Py_DecRef
  0023d	48 8b 45 58	 mov	 rax, QWORD PTR res$[rbp-112]
$LN19@PyUnicode_@28:

; 8262 :     Py_XDECREF(errorHandler);

  00241	48 85 f6	 test	 rsi, rsi
  00244	74 c5		 je	 SHORT $LN58@PyUnicode_@28
  00246	48 8b ce	 mov	 rcx, rsi
  00249	e8 00 00 00 00	 call	 _Py_DecRef
  0024e	48 8b 45 58	 mov	 rax, QWORD PTR res$[rbp-112]

; 8263 :     return res;

  00252	eb b7		 jmp	 SHORT $LN58@PyUnicode_@28
_PyUnicode_EncodeCharmap ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsCharmapString
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_AsCharmapString DD imagerel $LN5
	DD	imagerel $LN5+49
	DD	imagerel $unwind$PyUnicode_AsCharmapString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_AsCharmapString DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_AsCharmapString
_TEXT	SEGMENT
unicode$ = 48
mapping$ = 56
PyUnicode_AsCharmapString PROC				; COMDAT

; 8291 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 8292 :     if (!PyUnicode_Check(unicode) || mapping == NULL) {

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00012	74 11		 je	 SHORT $LN1@PyUnicode_@29
  00014	48 85 d2	 test	 rdx, rdx
  00017	74 0c		 je	 SHORT $LN1@PyUnicode_@29

; 8295 :     }
; 8296 :     return _PyUnicode_EncodeCharmap(unicode, mapping, NULL);

  00019	45 33 c0	 xor	 r8d, r8d

; 8297 : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	e9 00 00 00 00	 jmp	 _PyUnicode_EncodeCharmap
$LN1@PyUnicode_@29:

; 8293 :         PyErr_BadArgument();

  00025	e8 00 00 00 00	 call	 PyErr_BadArgument

; 8294 :         return NULL;

  0002a	33 c0		 xor	 eax, eax

; 8297 : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
PyUnicode_AsCharmapString ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@MJKOMBPP@make_translate_exception?$AA@ ; `string'
EXTRN	PyUnicodeTranslateError_SetReason:PROC
EXTRN	PyUnicodeTranslateError_SetEnd:PROC
EXTRN	PyUnicodeTranslateError_SetStart:PROC
EXTRN	_PyUnicodeTranslateError_Create:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$make_translate_exception DD imagerel make_translate_exception
	DD	imagerel make_translate_exception+300
	DD	imagerel $unwind$make_translate_exception
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$make_translate_exception DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0BJ@MJKOMBPP@make_translate_exception?$AA@
CONST	SEGMENT
??_C@_0BJ@MJKOMBPP@make_translate_exception?$AA@ DB 'make_translate_excep'
	DB	'tion', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT make_translate_exception
_TEXT	SEGMENT
exceptionObject$ = 64
unicode$ = 72
startpos$ = 80
endpos$ = 88
reason$ = 96
make_translate_exception PROC				; COMDAT

; 8305 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 8306 :     if (*exceptionObject == NULL) {

  0000d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00010	49 8b c0	 mov	 rax, r8
  00013	4c 8b d2	 mov	 r10, rdx
  00016	49 8b d9	 mov	 rbx, r9

; 8307 :         *exceptionObject = _PyUnicodeTranslateError_Create(
; 8308 :             unicode, startpos, endpos, reason);

  00019	48 8b d0	 mov	 rdx, rax
  0001c	48 85 c9	 test	 rcx, rcx
  0001f	75 1e		 jne	 SHORT $LN9@make_trans
  00021	4c 8b 4c 24 60	 mov	 r9, QWORD PTR reason$[rsp]
  00026	4c 8b c3	 mov	 r8, rbx
  00029	49 8b ca	 mov	 rcx, r10
  0002c	e8 00 00 00 00	 call	 _PyUnicodeTranslateError_Create
  00031	48 89 07	 mov	 QWORD PTR [rdi], rax

; 8320 :     }
; 8321 : }

  00034	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00039	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
$LN9@make_trans:

; 8309 :     }
; 8310 :     else {
; 8311 :         if (PyUnicodeTranslateError_SetStart(*exceptionObject, startpos))

  0003f	e8 00 00 00 00	 call	 PyUnicodeTranslateError_SetStart
  00044	85 c0		 test	 eax, eax
  00046	75 24		 jne	 SHORT $onError$134492

; 8312 :             goto onError;
; 8313 :         if (PyUnicodeTranslateError_SetEnd(*exceptionObject, endpos))

  00048	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0004b	48 8b d3	 mov	 rdx, rbx
  0004e	e8 00 00 00 00	 call	 PyUnicodeTranslateError_SetEnd
  00053	85 c0		 test	 eax, eax
  00055	75 15		 jne	 SHORT $onError$134492

; 8314 :             goto onError;
; 8315 :         if (PyUnicodeTranslateError_SetReason(*exceptionObject, reason))

  00057	48 8b 54 24 60	 mov	 rdx, QWORD PTR reason$[rsp]
  0005c	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0005f	e8 00 00 00 00	 call	 PyUnicodeTranslateError_SetReason
  00064	85 c0		 test	 eax, eax
  00066	0f 84 b5 00 00
	00		 je	 $LN2@make_trans
$onError$134492:

; 8316 :             goto onError;
; 8317 :         return;
; 8318 :       onError:
; 8319 :         Py_CLEAR(*exceptionObject);

  0006c	4c 8b 0f	 mov	 r9, QWORD PTR [rdi]
  0006f	4d 85 c9	 test	 r9, r9
  00072	0f 84 a9 00 00
	00		 je	 $LN2@make_trans
  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@MJKOMBPP@make_translate_exception?$AA@
  00086	41 b8 7f 20 00
	00		 mov	 r8d, 8319		; 0000207fH
  0008c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00094	e8 00 00 00 00	 call	 _PyParallel_Guard
  00099	85 c0		 test	 eax, eax
  0009b	0f 85 80 00 00
	00		 jne	 $LN2@make_trans
  000a1	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  000a4	48 c7 07 00 00
	00 00		 mov	 QWORD PTR [rdi], 0
  000ab	e8 00 00 00 00	 call	 _Py_PXCTX
  000b0	85 c0		 test	 eax, eax
  000b2	75 6d		 jne	 SHORT $LN2@make_trans
  000b4	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000b8	a8 20		 test	 al, 32			; 00000020H
  000ba	75 5d		 jne	 SHORT $LN16@make_trans
  000bc	84 c0		 test	 al, al
  000be	78 59		 js	 SHORT $LN16@make_trans
  000c0	a8 02		 test	 al, 2
  000c2	75 5d		 jne	 SHORT $LN2@make_trans
  000c4	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000c8	75 57		 jne	 SHORT $LN2@make_trans
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000d8	4c 8b cb	 mov	 r9, rbx
  000db	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000e1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000e9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ee	48 8b cb	 mov	 rcx, rbx
  000f1	85 c0		 test	 eax, eax
  000f3	74 0f		 je	 SHORT $LN21@make_trans

; 8320 :     }
; 8321 : }

  000f5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000fa	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fe	5f		 pop	 rdi
  000ff	e9 00 00 00 00	 jmp	 _Px_Dealloc

; 8316 :             goto onError;
; 8317 :         return;
; 8318 :       onError:
; 8319 :         Py_CLEAR(*exceptionObject);

$LN21@make_trans:
  00104	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 8320 :     }
; 8321 : }

  00108	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0010d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00111	5f		 pop	 rdi
  00112	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]

; 8316 :             goto onError;
; 8317 :         return;
; 8318 :       onError:
; 8319 :         Py_CLEAR(*exceptionObject);

$LN16@make_trans:
  00119	48 8b cb	 mov	 rcx, rbx
  0011c	e8 00 00 00 00	 call	 Px_DecRef
$LN2@make_trans:

; 8320 :     }
; 8321 : }

  00121	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00126	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0012a	5f		 pop	 rdi
  0012b	c3		 ret	 0
make_translate_exception ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$raise_translate_exception DD imagerel raise_translate_exception
	DD	imagerel raise_translate_exception+43
	DD	imagerel $unwind$raise_translate_exception
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$raise_translate_exception DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT raise_translate_exception
_TEXT	SEGMENT
exceptionObject$ = 64
unicode$ = 72
startpos$ = 80
endpos$ = 88
reason$ = 96
raise_translate_exception PROC				; COMDAT

; 8329 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 8330 :     make_translate_exception(exceptionObject,
; 8331 :                              unicode, startpos, endpos, reason);

  00006	48 8b 44 24 60	 mov	 rax, QWORD PTR reason$[rsp]
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00013	e8 00 00 00 00	 call	 make_translate_exception

; 8332 :     if (*exceptionObject != NULL)

  00018	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0001b	48 85 c9	 test	 rcx, rcx
  0001e	74 05		 je	 SHORT $LN1@raise_tran

; 8333 :         PyCodec_StrictErrors(*exceptionObject);

  00020	e8 00 00 00 00	 call	 PyCodec_StrictErrors
$LN1@raise_tran:

; 8334 : }

  00025	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00029	5b		 pop	 rbx
  0002a	c3		 ret	 0
raise_translate_exception ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_translate_call_errorhandler DD imagerel unicode_translate_call_errorhandler
	DD	imagerel unicode_translate_call_errorhandler+317
	DD	imagerel $unwind$unicode_translate_call_errorhandler
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_translate_call_errorhandler DD 060f01H
	DD	0c640fH
	DD	0a340fH
	DD	0700b720fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_translate_call_errorhandler
_TEXT	SEGMENT
i_newpos$ = 48
errors$ = 80
resunicode$ = 88
errorHandler$ = 88
reason$ = 96
unicode$ = 104
exceptionObject$ = 112
startpos$ = 120
endpos$ = 128
newpos$ = 136
unicode_translate_call_errorhandler PROC		; COMDAT

; 8347 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 8348 :     static char *argparse = "O!n;translating error handler must return (str, int) tuple";
; 8349 : 
; 8350 :     Py_ssize_t i_newpos;
; 8351 :     PyObject *restuple;
; 8352 :     PyObject *resunicode;
; 8353 : 
; 8354 :     if (*errorHandler == NULL) {

  0000f	48 83 3a 00	 cmp	 QWORD PTR [rdx], 0
  00013	49 8b f9	 mov	 rdi, r9
  00016	49 8b d8	 mov	 rbx, r8
  00019	48 8b f2	 mov	 rsi, rdx
  0001c	75 11		 jne	 SHORT $LN9@unicode_tr

; 8355 :         *errorHandler = PyCodec_LookupError(errors);

  0001e	e8 00 00 00 00	 call	 PyCodec_LookupError
  00023	48 89 06	 mov	 QWORD PTR [rsi], rax

; 8356 :         if (*errorHandler == NULL)

  00026	48 85 c0	 test	 rax, rax

; 8357 :             return NULL;

  00029	0f 84 fc 00 00
	00		 je	 $LN13@unicode_tr
$LN9@unicode_tr:

; 8358 :     }
; 8359 : 
; 8360 :     make_translate_exception(exceptionObject,
; 8361 :                              unicode, startpos, endpos, reason);

  0002f	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR endpos$[rsp]
  00037	4c 8b 44 24 78	 mov	 r8, QWORD PTR startpos$[rsp]
  0003c	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00041	48 8b 5c 24 70	 mov	 rbx, QWORD PTR exceptionObject$[rsp]
  00046	48 8b d7	 mov	 rdx, rdi
  00049	48 8b cb	 mov	 rcx, rbx
  0004c	e8 00 00 00 00	 call	 make_translate_exception

; 8362 :     if (*exceptionObject == NULL)

  00051	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00054	48 85 d2	 test	 rdx, rdx

; 8363 :         return NULL;

  00057	0f 84 ce 00 00
	00		 je	 $LN13@unicode_tr

; 8364 : 
; 8365 :     restuple = PyObject_CallFunctionObjArgs(
; 8366 :         *errorHandler, *exceptionObject, NULL);

  0005d	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00060	45 33 c0	 xor	 r8d, r8d
  00063	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  00068	48 8b d8	 mov	 rbx, rax

; 8367 :     if (restuple == NULL)

  0006b	48 85 c0	 test	 rax, rax

; 8368 :         return NULL;

  0006e	0f 84 b7 00 00
	00		 je	 $LN13@unicode_tr

; 8369 :     if (!PyTuple_Check(restuple)) {

  00074	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]

; 8370 :         PyErr_SetString(PyExc_TypeError, &argparse[4]);

  00078	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?argparse@?1??unicode_translate_call_errorhandler@@9@9
  0007f	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00089	75 15		 jne	 SHORT $LN6@unicode_tr
  0008b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00092	48 83 c2 04	 add	 rdx, 4
  00096	e8 00 00 00 00	 call	 PyErr_SetString

; 8371 :         Py_DECREF(restuple);
; 8372 :         return NULL;

  0009b	e9 83 00 00 00	 jmp	 $LN14@unicode_tr
$LN6@unicode_tr:

; 8373 :     }
; 8374 :     if (!PyArg_ParseTuple(restuple, argparse, &PyUnicode_Type,
; 8375 :                           &resunicode, &i_newpos)) {

  000a0	48 8d 44 24 30	 lea	 rax, QWORD PTR i_newpos$[rsp]
  000a5	4c 8d 4c 24 58	 lea	 r9, QWORD PTR resunicode$[rsp]
  000aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyUnicode_Type
  000b1	48 8b cb	 mov	 rcx, rbx
  000b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b9	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000be	85 c0		 test	 eax, eax

; 8376 :         Py_DECREF(restuple);
; 8377 :         return NULL;

  000c0	74 61		 je	 SHORT $LN14@unicode_tr

; 8378 :     }
; 8379 :     if (i_newpos<0)

  000c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i_newpos$[rsp]

; 8380 :         *newpos = PyUnicode_GET_LENGTH(unicode)+i_newpos;

  000c7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR newpos$[rsp]
  000cf	48 85 c9	 test	 rcx, rcx
  000d2	79 04		 jns	 SHORT $LN4@unicode_tr
  000d4	48 03 4f 60	 add	 rcx, QWORD PTR [rdi+96]
$LN4@unicode_tr:

; 8381 :     else
; 8382 :         *newpos = i_newpos;

  000d8	48 89 08	 mov	 QWORD PTR [rax], rcx

; 8383 :     if (*newpos<0 || *newpos>PyUnicode_GET_LENGTH(unicode)) {

  000db	4c 8b c1	 mov	 r8, rcx
  000de	48 85 c9	 test	 rcx, rcx
  000e1	78 2d		 js	 SHORT $LN1@unicode_tr
  000e3	48 3b 4f 60	 cmp	 rcx, QWORD PTR [rdi+96]
  000e7	7f 27		 jg	 SHORT $LN1@unicode_tr

; 8386 :         return NULL;
; 8387 :     }
; 8388 :     Py_INCREF(resunicode);

  000e9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR resunicode$[rsp]
  000ee	e8 00 00 00 00	 call	 _Py_IncRef

; 8389 :     Py_DECREF(restuple);

  000f3	48 8b cb	 mov	 rcx, rbx
  000f6	e8 00 00 00 00	 call	 _Py_DecRef

; 8390 :     return resunicode;

  000fb	48 8b 44 24 58	 mov	 rax, QWORD PTR resunicode$[rsp]

; 8391 : }

  00100	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00105	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0010a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0010e	5f		 pop	 rdi
  0010f	c3		 ret	 0
$LN1@unicode_tr:

; 8384 :         PyErr_Format(PyExc_IndexError, "position %zd from error handler out of bounds", *newpos);

  00110	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00117	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@NELAFELL@position?5?$CFzd?5from?5error?5handler?5@
  0011e	e8 00 00 00 00	 call	 PyErr_Format
$LN14@unicode_tr:

; 8385 :         Py_DECREF(restuple);

  00123	48 8b cb	 mov	 rcx, rbx
  00126	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@unicode_tr:

; 8391 : }

  0012b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00130	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00135	33 c0		 xor	 eax, eax
  00137	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0013b	5f		 pop	 rdi
  0013c	c3		 ret	 0
unicode_translate_call_errorhandler ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@HGMALEBD@character?5mapping?5must?5return?5in@ ; `string'
PUBLIC	??_C@_0CJ@MPCOFMOF@character?5mapping?5must?5be?5in?5ran@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$charmaptranslate_lookup DD imagerel charmaptranslate_lookup
	DD	imagerel charmaptranslate_lookup+266
	DD	imagerel $unwind$charmaptranslate_lookup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$charmaptranslate_lookup DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0DD@HGMALEBD@character?5mapping?5must?5return?5in@
CONST	SEGMENT
??_C@_0DD@HGMALEBD@character?5mapping?5must?5return?5in@ DB 'character ma'
	DB	'pping must return integer, None or str', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MPCOFMOF@character?5mapping?5must?5be?5in?5ran@
CONST	SEGMENT
??_C@_0CJ@MPCOFMOF@character?5mapping?5must?5be?5in?5ran@ DB 'character m'
	DB	'apping must be in range(0x%x)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT charmaptranslate_lookup
_TEXT	SEGMENT
c$ = 48
mapping$ = 56
result$ = 64
charmaptranslate_lookup PROC				; COMDAT

; 8398 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b da	 mov	 rbx, rdx

; 8399 :     PyObject *w = PyLong_FromLong((long)c);

  00015	e8 00 00 00 00	 call	 PyLong_FromLong
  0001a	48 8b f0	 mov	 rsi, rax

; 8400 :     PyObject *x;
; 8401 : 
; 8402 :     if (w == NULL)

  0001d	48 85 c0	 test	 rax, rax

; 8403 :         return -1;

  00020	0f 84 d1 00 00
	00		 je	 $LN16@charmaptra

; 8404 :     x = PyObject_GetItem(mapping, w);

  00026	48 8b d0	 mov	 rdx, rax
  00029	48 8b cb	 mov	 rcx, rbx
  0002c	e8 00 00 00 00	 call	 PyObject_GetItem

; 8405 :     Py_DECREF(w);

  00031	48 8b ce	 mov	 rcx, rsi
  00034	48 8b d8	 mov	 rbx, rax
  00037	e8 00 00 00 00	 call	 _Py_DecRef

; 8406 :     if (x == NULL) {

  0003c	48 85 db	 test	 rbx, rbx
  0003f	75 2e		 jne	 SHORT $LN12@charmaptra

; 8407 :         if (PyErr_ExceptionMatches(PyExc_LookupError)) {

  00041	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_LookupError
  00048	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0004d	85 c0		 test	 eax, eax
  0004f	0f 84 a2 00 00
	00		 je	 $LN16@charmaptra

; 8408 :             /* No mapping found means: use 1:1 mapping. */
; 8409 :             PyErr_Clear();

  00055	e8 00 00 00 00	 call	 PyErr_Clear

; 8410 :             *result = NULL;

  0005a	48 89 1f	 mov	 QWORD PTR [rdi], rbx

; 8411 :             return 0;

  0005d	33 c0		 xor	 eax, eax

; 8440 :         return -1;
; 8441 :     }
; 8442 : }

  0005f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00064	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00069	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
$LN12@charmaptra:

; 8412 :         } else
; 8413 :             return -1;
; 8414 :     }
; 8415 :     else if (x == Py_None) {

  0006f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00076	48 3b d8	 cmp	 rbx, rax
  00079	75 15		 jne	 SHORT $LN8@charmaptra
$LN18@charmaptra:

; 8416 :         *result = x;

  0007b	48 89 1f	 mov	 QWORD PTR [rdi], rbx

; 8417 :         return 0;

  0007e	33 c0		 xor	 eax, eax

; 8440 :         return -1;
; 8441 :     }
; 8442 : }

  00080	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00085	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
$LN8@charmaptra:

; 8418 :     }
; 8419 :     else if (PyLong_Check(x)) {

  00090	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00094	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  0009a	0f ba e1 18	 bt	 ecx, 24
  0009e	73 36		 jae	 SHORT $LN6@charmaptra

; 8420 :         long value = PyLong_AS_LONG(x);

  000a0	48 8b cb	 mov	 rcx, rbx
  000a3	e8 00 00 00 00	 call	 PyLong_AsLong
  000a8	44 8b d8	 mov	 r11d, eax

; 8421 :         long max = PyUnicode_GetMax();

  000ab	e8 00 00 00 00	 call	 PyUnicode_GetMax
  000b0	44 0f b7 c0	 movzx	 r8d, ax

; 8422 :         if (value < 0 || value > max) {

  000b4	45 85 db	 test	 r11d, r11d
  000b7	78 05		 js	 SHORT $LN4@charmaptra
  000b9	45 3b d8	 cmp	 r11d, r8d

; 8427 :         }
; 8428 :         *result = x;
; 8429 :         return 0;

  000bc	7e bd		 jle	 SHORT $LN18@charmaptra
$LN4@charmaptra:

; 8423 :             PyErr_Format(PyExc_TypeError,
; 8424 :                          "character mapping must be in range(0x%x)", max+1);

  000be	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@MPCOFMOF@character?5mapping?5must?5be?5in?5ran@
  000cc	41 ff c0	 inc	 r8d
  000cf	e8 00 00 00 00	 call	 PyErr_Format

; 8425 :             Py_DECREF(x);
; 8426 :             return -1;

  000d4	eb 19		 jmp	 SHORT $LN17@charmaptra
$LN6@charmaptra:

; 8430 :     }
; 8431 :     else if (PyUnicode_Check(x)) {

  000d6	0f ba e1 1c	 bt	 ecx, 28

; 8432 :         *result = x;
; 8433 :         return 0;

  000da	72 9f		 jb	 SHORT $LN18@charmaptra

; 8434 :     }
; 8435 :     else {
; 8436 :         /* wrong return value */
; 8437 :         PyErr_SetString(PyExc_TypeError,
; 8438 :                         "character mapping must return integer, None or str");

  000dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@HGMALEBD@character?5mapping?5must?5return?5in@
  000ea	e8 00 00 00 00	 call	 PyErr_SetString
$LN17@charmaptra:

; 8439 :         Py_DECREF(x);

  000ef	48 8b cb	 mov	 rcx, rbx
  000f2	e8 00 00 00 00	 call	 _Py_DecRef
$LN16@charmaptra:

; 8440 :         return -1;
; 8441 :     }
; 8442 : }

  000f7	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000fc	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00101	83 c8 ff	 or	 eax, -1
  00104	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00108	5f		 pop	 rdi
  00109	c3		 ret	 0
charmaptranslate_lookup ENDP
_TEXT	ENDS
EXTRN	PyMem_Realloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$charmaptranslate_makespace DD imagerel charmaptranslate_makespace
	DD	imagerel charmaptranslate_makespace+106
	DD	imagerel $unwind$charmaptranslate_makespace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$charmaptranslate_makespace DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT charmaptranslate_makespace
_TEXT	SEGMENT
outobj$ = 48
psize$ = 56
requiredsize$ = 64
charmaptranslate_makespace PROC				; COMDAT

; 8449 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 8450 :     Py_ssize_t oldsize = *psize;

  0000f	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00012	49 8b d8	 mov	 rbx, r8
  00015	48 8b fa	 mov	 rdi, rdx
  00018	48 8b f1	 mov	 rsi, rcx

; 8451 :     Py_UCS4 *new_outobj;
; 8452 :     if (requiredsize > oldsize) {

  0001b	4c 3b c0	 cmp	 r8, rax
  0001e	7e 38		 jle	 SHORT $LN3@charmaptra@2

; 8453 :         /* exponentially overallocate to minimize reallocations */
; 8454 :         if (requiredsize < 2 * oldsize)
; 8455 :             requiredsize = 2 * oldsize;
; 8456 :         new_outobj = PyMem_Realloc(*outobj, requiredsize * sizeof(Py_UCS4));

  00020	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00023	48 03 c0	 add	 rax, rax
  00026	48 3b d8	 cmp	 rbx, rax
  00029	48 0f 4c d8	 cmovl	 rbx, rax
  0002d	48 8d 14 9d 00
	00 00 00	 lea	 rdx, QWORD PTR [rbx*4]
  00035	e8 00 00 00 00	 call	 PyMem_Realloc

; 8457 :         if (new_outobj == 0)

  0003a	48 85 c0	 test	 rax, rax
  0003d	75 13		 jne	 SHORT $LN1@charmaptra@2

; 8458 :             return -1;

  0003f	83 c8 ff	 or	 eax, -1

; 8461 :     }
; 8462 :     return 0;
; 8463 : }

  00042	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00047	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5f		 pop	 rdi
  00051	c3		 ret	 0
$LN1@charmaptra@2:

; 8459 :         *outobj = new_outobj;

  00052	48 89 06	 mov	 QWORD PTR [rsi], rax

; 8460 :         *psize = requiredsize;

  00055	48 89 1f	 mov	 QWORD PTR [rdi], rbx
$LN3@charmaptra@2:

; 8461 :     }
; 8462 :     return 0;
; 8463 : }

  00058	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00062	33 c0		 xor	 eax, eax
  00064	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00068	5f		 pop	 rdi
  00069	c3		 ret	 0
charmaptranslate_makespace ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$charmaptranslate_output DD imagerel charmaptranslate_output
	DD	imagerel charmaptranslate_output+906
	DD	imagerel $unwind$charmaptranslate_output
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$charmaptranslate_output DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT charmaptranslate_output
_TEXT	SEGMENT
input$ = 48
ipos$ = 56
mapping$ = 64
output$ = 72
osize$ = 80
opos$ = 88
res$ = 96
charmaptranslate_output PROC				; COMDAT

; 8475 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 8476 :     Py_UCS4 curinp = PyUnicode_READ_CHAR(input, ipos);

  0001a	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  0001d	48 8b d9	 mov	 rbx, rcx
  00020	4d 8b e1	 mov	 r12, r9
  00023	8b c8		 mov	 ecx, eax
  00025	4d 8b d0	 mov	 r10, r8
  00028	48 8b f2	 mov	 rsi, rdx
  0002b	c1 e9 02	 shr	 ecx, 2
  0002e	83 e1 07	 and	 ecx, 7
  00031	83 f9 01	 cmp	 ecx, 1
  00034	75 2f		 jne	 SHORT $LN34@charmaptra@3
  00036	a8 20		 test	 al, 32			; 00000020H
  00038	74 1e		 je	 SHORT $LN22@charmaptra@3
  0003a	a8 40		 test	 al, 64			; 00000040H
  0003c	74 0d		 je	 SHORT $LN20@charmaptra@3
  0003e	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00045	0f b6 3c 10	 movzx	 edi, BYTE PTR [rax+rdx]
  00049	eb 72		 jmp	 SHORT $LN33@charmaptra@3
$LN20@charmaptra@3:
  0004b	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00052	0f b6 3c 10	 movzx	 edi, BYTE PTR [rax+rdx]
  00056	eb 65		 jmp	 SHORT $LN33@charmaptra@3
$LN22@charmaptra@3:
  00058	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  0005f	0f b6 3c 10	 movzx	 edi, BYTE PTR [rax+rdx]
  00063	eb 58		 jmp	 SHORT $LN33@charmaptra@3
$LN34@charmaptra@3:
  00065	83 f9 02	 cmp	 ecx, 2
  00068	75 2f		 jne	 SHORT $LN32@charmaptra@3
  0006a	a8 20		 test	 al, 32			; 00000020H
  0006c	74 1e		 je	 SHORT $LN26@charmaptra@3
  0006e	a8 40		 test	 al, 64			; 00000040H
  00070	74 0d		 je	 SHORT $LN24@charmaptra@3
  00072	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00079	0f b7 3c 50	 movzx	 edi, WORD PTR [rax+rdx*2]
  0007d	eb 3e		 jmp	 SHORT $LN33@charmaptra@3
$LN24@charmaptra@3:
  0007f	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00086	0f b7 3c 50	 movzx	 edi, WORD PTR [rax+rdx*2]
  0008a	eb 31		 jmp	 SHORT $LN33@charmaptra@3
$LN26@charmaptra@3:
  0008c	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  00093	0f b7 3c 50	 movzx	 edi, WORD PTR [rax+rdx*2]
  00097	eb 24		 jmp	 SHORT $LN33@charmaptra@3
$LN32@charmaptra@3:
  00099	a8 20		 test	 al, 32			; 00000020H
  0009b	74 16		 je	 SHORT $LN30@charmaptra@3
  0009d	a8 40		 test	 al, 64			; 00000040H
  0009f	74 09		 je	 SHORT $LN28@charmaptra@3
  000a1	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  000a8	eb 10		 jmp	 SHORT $LN31@charmaptra@3
$LN28@charmaptra@3:
  000aa	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  000b1	eb 07		 jmp	 SHORT $LN31@charmaptra@3
$LN30@charmaptra@3:
  000b3	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN31@charmaptra@3:
  000ba	8b 3c 90	 mov	 edi, DWORD PTR [rax+rdx*4]
$LN33@charmaptra@3:

; 8477 :     if (charmaptranslate_lookup(curinp, mapping, res))

  000bd	48 8b 6c 24 60	 mov	 rbp, QWORD PTR res$[rsp]
  000c2	49 8b d2	 mov	 rdx, r10
  000c5	8b cf		 mov	 ecx, edi
  000c7	4c 8b c5	 mov	 r8, rbp
  000ca	e8 00 00 00 00	 call	 charmaptranslate_lookup
  000cf	85 c0		 test	 eax, eax
  000d1	74 05		 je	 SHORT $LN17@charmaptra@3
$LN73@charmaptra@3:

; 8478 :         return -1;

  000d3	83 c8 ff	 or	 eax, -1
  000d6	eb 1d		 jmp	 SHORT $LN18@charmaptra@3
$LN17@charmaptra@3:

; 8479 :     if (*res==NULL) {

  000d8	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
  000dc	48 85 c9	 test	 rcx, rcx
  000df	75 2f		 jne	 SHORT $LN16@charmaptra@3

; 8480 :         /* not found => default to 1:1 mapping */
; 8481 :         (*output)[(*opos)++] = curinp;

  000e1	48 8b 54 24 58	 mov	 rdx, QWORD PTR opos$[rsp]
  000e6	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  000ea	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  000ed	89 3c 88	 mov	 DWORD PTR [rax+rcx*4], edi
$LN72@charmaptra@3:
  000f0	48 ff 02	 inc	 QWORD PTR [rdx]
$LN2@charmaptra@3:

; 8508 :         }
; 8509 :     }
; 8510 :     else
; 8511 :         return -1;
; 8512 :     return 0;

  000f3	33 c0		 xor	 eax, eax
$LN18@charmaptra@3:

; 8513 : }

  000f5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000fa	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000ff	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00104	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00109	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010d	41 5c		 pop	 r12
  0010f	c3		 ret	 0
$LN16@charmaptra@3:

; 8482 :     }
; 8483 :     else if (*res==Py_None)

  00110	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00117	48 3b c8	 cmp	 rcx, rax
  0011a	74 d7		 je	 SHORT $LN2@charmaptra@3

; 8484 :         ;
; 8485 :     else if (PyLong_Check(*res)) {

  0011c	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00120	8b 90 00 01 00
	00		 mov	 edx, DWORD PTR [rax+256]
  00126	0f ba e2 18	 bt	 edx, 24
  0012a	73 19		 jae	 SHORT $LN12@charmaptra@3

; 8486 :         /* no overflow check, because we know that the space is enough */
; 8487 :         (*output)[(*opos)++] = (Py_UCS4)PyLong_AS_LONG(*res);

  0012c	e8 00 00 00 00	 call	 PyLong_AsLong
  00131	4c 8b 44 24 58	 mov	 r8, QWORD PTR opos$[rsp]
  00136	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  0013a	49 8b 10	 mov	 rdx, QWORD PTR [r8]
  0013d	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax
  00140	49 ff 00	 inc	 QWORD PTR [r8]
  00143	eb ae		 jmp	 SHORT $LN2@charmaptra@3
$LN12@charmaptra@3:

; 8488 :     }
; 8489 :     else if (PyUnicode_Check(*res)) {

  00145	0f ba e2 1c	 bt	 edx, 28
  00149	73 88		 jae	 SHORT $LN73@charmaptra@3

; 8490 :         Py_ssize_t repsize;
; 8491 :         if (PyUnicode_READY(*res) == -1)

  0014b	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0014f	75 0e		 jne	 SHORT $LN9@charmaptra@3
  00151	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00156	83 f8 ff	 cmp	 eax, -1

; 8492 :             return -1;

  00159	0f 84 74 ff ff
	ff		 je	 $LN73@charmaptra@3
$LN9@charmaptra@3:

; 8493 :         repsize = PyUnicode_GET_LENGTH(*res);

  0015f	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  00163	48 8b 78 60	 mov	 rdi, QWORD PTR [rax+96]

; 8494 :         if (repsize==1) {

  00167	48 83 ff 01	 cmp	 rdi, 1
  0016b	0f 85 17 01 00
	00		 jne	 $LN8@charmaptra@3

; 8495 :             /* no overflow check, because we know that the space is enough */
; 8496 :             (*output)[(*opos)++] = PyUnicode_READ_CHAR(*res, 0);

  00171	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  00174	8b d1		 mov	 edx, ecx
  00176	c1 ea 02	 shr	 edx, 2
  00179	83 e2 07	 and	 edx, 7
  0017c	3b d7		 cmp	 edx, edi
  0017e	75 66		 jne	 SHORT $LN52@charmaptra@3
  00180	f6 c1 20	 test	 cl, 32			; 00000020H
  00183	74 41		 je	 SHORT $LN40@charmaptra@3
  00185	f6 c1 40	 test	 cl, 64			; 00000040H
  00188	74 1d		 je	 SHORT $LN38@charmaptra@3
  0018a	48 8b 54 24 58	 mov	 rdx, QWORD PTR opos$[rsp]
  0018f	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  00193	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  00197	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  0019a	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  0019e	44 89 04 88	 mov	 DWORD PTR [rax+rcx*4], r8d
  001a2	e9 49 ff ff ff	 jmp	 $LN72@charmaptra@3
$LN38@charmaptra@3:
  001a7	48 8b 54 24 58	 mov	 rdx, QWORD PTR opos$[rsp]
  001ac	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  001b2	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  001b6	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  001b9	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  001bd	44 89 04 88	 mov	 DWORD PTR [rax+rcx*4], r8d
  001c1	e9 2a ff ff ff	 jmp	 $LN72@charmaptra@3
$LN40@charmaptra@3:
  001c6	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  001cd	48 8b 54 24 58	 mov	 rdx, QWORD PTR opos$[rsp]
  001d2	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  001d6	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  001da	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  001dd	44 89 04 88	 mov	 DWORD PTR [rax+rcx*4], r8d
  001e1	e9 0a ff ff ff	 jmp	 $LN72@charmaptra@3
$LN52@charmaptra@3:
  001e6	83 fa 02	 cmp	 edx, 2
  001e9	75 66		 jne	 SHORT $LN50@charmaptra@3
  001eb	f6 c1 20	 test	 cl, 32			; 00000020H
  001ee	74 41		 je	 SHORT $LN44@charmaptra@3
  001f0	f6 c1 40	 test	 cl, 64			; 00000040H
  001f3	74 1d		 je	 SHORT $LN42@charmaptra@3
  001f5	48 8b 54 24 58	 mov	 rdx, QWORD PTR opos$[rsp]
  001fa	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  001fe	44 0f b7 00	 movzx	 r8d, WORD PTR [rax]
  00202	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00205	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  00209	44 89 04 88	 mov	 DWORD PTR [rax+rcx*4], r8d
  0020d	e9 de fe ff ff	 jmp	 $LN72@charmaptra@3
$LN42@charmaptra@3:
  00212	48 8b 54 24 58	 mov	 rdx, QWORD PTR opos$[rsp]
  00217	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  0021d	44 0f b7 00	 movzx	 r8d, WORD PTR [rax]
  00221	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00224	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  00228	44 89 04 88	 mov	 DWORD PTR [rax+rcx*4], r8d
  0022c	e9 bf fe ff ff	 jmp	 $LN72@charmaptra@3
$LN44@charmaptra@3:
  00231	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00238	48 8b 54 24 58	 mov	 rdx, QWORD PTR opos$[rsp]
  0023d	44 0f b7 00	 movzx	 r8d, WORD PTR [rax]
  00241	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  00245	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00248	44 89 04 88	 mov	 DWORD PTR [rax+rcx*4], r8d
  0024c	e9 9f fe ff ff	 jmp	 $LN72@charmaptra@3
$LN50@charmaptra@3:
  00251	f6 c1 20	 test	 cl, 32			; 00000020H
  00254	74 13		 je	 SHORT $LN48@charmaptra@3
  00256	f6 c1 40	 test	 cl, 64			; 00000040H
  00259	74 06		 je	 SHORT $LN46@charmaptra@3
  0025b	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  0025f	eb 0f		 jmp	 SHORT $LN49@charmaptra@3
$LN46@charmaptra@3:
  00261	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00267	eb 07		 jmp	 SHORT $LN49@charmaptra@3
$LN48@charmaptra@3:
  00269	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
$LN49@charmaptra@3:
  00270	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00273	48 8b 54 24 58	 mov	 rdx, QWORD PTR opos$[rsp]
  00278	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  0027c	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  0027f	44 89 04 88	 mov	 DWORD PTR [rax+rcx*4], r8d
  00283	e9 68 fe ff ff	 jmp	 $LN72@charmaptra@3
$LN8@charmaptra@3:

; 8497 :         }
; 8498 :         else if (repsize!=0) {

  00288	48 85 ff	 test	 rdi, rdi
  0028b	0f 84 62 fe ff
	ff		 je	 $LN2@charmaptra@3

; 8499 :             /* more than one character */
; 8500 :             Py_ssize_t requiredsize = *opos +
; 8501 :                 (PyUnicode_GET_LENGTH(input) - ipos) +
; 8502 :                 repsize - 1;

  00291	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  00295	48 8b 5c 24 58	 mov	 rbx, QWORD PTR opos$[rsp]

; 8503 :             Py_ssize_t i;
; 8504 :             if (charmaptranslate_makespace(output, osize, requiredsize))

  0029a	48 8b 54 24 50	 mov	 rdx, QWORD PTR osize$[rsp]
  0029f	48 2b c6	 sub	 rax, rsi
  002a2	49 8b cc	 mov	 rcx, r12
  002a5	48 03 03	 add	 rax, QWORD PTR [rbx]
  002a8	4c 8d 44 38 ff	 lea	 r8, QWORD PTR [rax+rdi-1]
  002ad	e8 00 00 00 00	 call	 charmaptranslate_makespace
  002b2	85 c0		 test	 eax, eax

; 8505 :                 return -1;

  002b4	0f 85 19 fe ff
	ff		 jne	 $LN73@charmaptra@3

; 8506 :             for(i = 0; i < repsize; i++)

  002ba	45 33 c0	 xor	 r8d, r8d
  002bd	48 85 ff	 test	 rdi, rdi
  002c0	0f 8e 2d fe ff
	ff		 jle	 $LN2@charmaptra@3
  002c6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@charmaptra@3:

; 8507 :                 (*output)[(*opos)++] = PyUnicode_READ_CHAR(*res, i);

  002d0	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  002d4	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  002d7	8b d1		 mov	 edx, ecx
  002d9	c1 ea 02	 shr	 edx, 2
  002dc	83 e2 07	 and	 edx, 7
  002df	83 fa 01	 cmp	 edx, 1
  002e2	75 30		 jne	 SHORT $LN68@charmaptra@3
  002e4	f6 c1 20	 test	 cl, 32			; 00000020H
  002e7	74 1d		 je	 SHORT $LN56@charmaptra@3
  002e9	f6 c1 40	 test	 cl, 64			; 00000040H
  002ec	74 0b		 je	 SHORT $LN54@charmaptra@3
  002ee	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  002f2	42 0f b6 14 00	 movzx	 edx, BYTE PTR [rax+r8]
  002f7	eb 73		 jmp	 SHORT $LN67@charmaptra@3
$LN54@charmaptra@3:
  002f9	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  002ff	42 0f b6 14 00	 movzx	 edx, BYTE PTR [rax+r8]
  00304	eb 66		 jmp	 SHORT $LN67@charmaptra@3
$LN56@charmaptra@3:
  00306	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0030d	42 0f b6 14 00	 movzx	 edx, BYTE PTR [rax+r8]
  00312	eb 58		 jmp	 SHORT $LN67@charmaptra@3
$LN68@charmaptra@3:
  00314	83 fa 02	 cmp	 edx, 2
  00317	75 30		 jne	 SHORT $LN66@charmaptra@3
  00319	f6 c1 20	 test	 cl, 32			; 00000020H
  0031c	74 1d		 je	 SHORT $LN60@charmaptra@3
  0031e	f6 c1 40	 test	 cl, 64			; 00000040H
  00321	74 0b		 je	 SHORT $LN58@charmaptra@3
  00323	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  00327	42 0f b7 14 40	 movzx	 edx, WORD PTR [rax+r8*2]
  0032c	eb 3e		 jmp	 SHORT $LN67@charmaptra@3
$LN58@charmaptra@3:
  0032e	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00334	42 0f b7 14 40	 movzx	 edx, WORD PTR [rax+r8*2]
  00339	eb 31		 jmp	 SHORT $LN67@charmaptra@3
$LN60@charmaptra@3:
  0033b	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00342	42 0f b7 14 40	 movzx	 edx, WORD PTR [rax+r8*2]
  00347	eb 23		 jmp	 SHORT $LN67@charmaptra@3
$LN66@charmaptra@3:
  00349	f6 c1 20	 test	 cl, 32			; 00000020H
  0034c	74 13		 je	 SHORT $LN64@charmaptra@3
  0034e	f6 c1 40	 test	 cl, 64			; 00000040H
  00351	74 06		 je	 SHORT $LN62@charmaptra@3
  00353	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  00357	eb 0f		 jmp	 SHORT $LN65@charmaptra@3
$LN62@charmaptra@3:
  00359	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  0035f	eb 07		 jmp	 SHORT $LN65@charmaptra@3
$LN64@charmaptra@3:
  00361	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
$LN65@charmaptra@3:
  00368	42 8b 14 80	 mov	 edx, DWORD PTR [rax+r8*4]
$LN67@charmaptra@3:
  0036c	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0036f	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  00373	49 ff c0	 inc	 r8
  00376	89 14 88	 mov	 DWORD PTR [rax+rcx*4], edx
  00379	48 ff 03	 inc	 QWORD PTR [rbx]
  0037c	4c 3b c7	 cmp	 r8, rdi
  0037f	0f 8c 4b ff ff
	ff		 jl	 $LL4@charmaptra@3

; 8506 :             for(i = 0; i < repsize; i++)

  00385	e9 69 fd ff ff	 jmp	 $LN2@charmaptra@3
charmaptranslate_output ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_TranslateCharmap
EXTRN	PyMem_Free:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_PyUnicode_TranslateCharmap DD imagerel $LN177
	DD	imagerel $LN177+205
	DD	imagerel $unwind$_PyUnicode_TranslateCharmap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_PyUnicode_TranslateCharmap DD imagerel $LN177+205
	DD	imagerel $LN177+1728
	DD	imagerel $chain$3$_PyUnicode_TranslateCharmap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_PyUnicode_TranslateCharmap DD imagerel $LN177+1728
	DD	imagerel $LN177+1765
	DD	imagerel $chain$4$_PyUnicode_TranslateCharmap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_PyUnicode_TranslateCharmap DD 021H
	DD	imagerel $LN177
	DD	imagerel $LN177+205
	DD	imagerel $unwind$_PyUnicode_TranslateCharmap
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_PyUnicode_TranslateCharmap DD 020821H
	DD	018d408H
	DD	imagerel $LN177
	DD	imagerel $LN177+205
	DD	imagerel $unwind$_PyUnicode_TranslateCharmap
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_TranslateCharmap DD 0c7c01H
	DD	017e47cH
	DD	019c474H
	DD	01a3469H
	DD	01b0120H
	DD	07012f014H
	DD	050106011H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT _PyUnicode_TranslateCharmap
_TEXT	SEGMENT
output$ = 64
opos$ = 72
exc$ = 80
errorHandler$ = 88
size$1$ = 96
x$134865 = 104
osize$ = 112
newpos$134883 = 120
buffer$134927 = 128
input$ = 256
mapping$ = 264
errors$ = 272
known_errorHandler$1$ = 280
_PyUnicode_TranslateCharmap PROC			; COMDAT

; 8519 : {

$LN177:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 57		 push	 r15
  00014	48 8d 6c 24 c1	 lea	 rbp, QWORD PTR [rsp-63]
  00019	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 8520 :     /* input object */
; 8521 :     char *idata;
; 8522 :     Py_ssize_t size, i;
; 8523 :     int kind;
; 8524 :     /* output buffer */
; 8525 :     Py_UCS4 *output = NULL;
; 8526 :     Py_ssize_t osize;
; 8527 :     PyObject *res;
; 8528 :     /* current output position */
; 8529 :     Py_ssize_t opos;
; 8530 :     char *reason = "character maps to <undefined>";
; 8531 :     PyObject *errorHandler = NULL;

  00020	45 33 ff	 xor	 r15d, r15d
  00023	48 8b f1	 mov	 rsi, rcx

; 8532 :     PyObject *exc = NULL;
; 8533 :     /* the following variable is used for caching string comparisons
; 8534 :      * -1=not initialized, 0=unknown, 1=strict, 2=replace,
; 8535 :      * 3=ignore, 4=xmlcharrefreplace */
; 8536 :     int known_errorHandler = -1;

  00026	c7 45 7f ff ff
	ff ff		 mov	 DWORD PTR known_errorHandler$1$[rbp-153], -1
  0002d	4c 89 7d bf	 mov	 QWORD PTR errorHandler$[rbp-153], r15
  00031	41 8b ff	 mov	 edi, r15d
  00034	4c 89 7d b7	 mov	 QWORD PTR exc$[rbp-153], r15

; 8537 : 
; 8538 :     if (mapping == NULL) {

  00038	48 85 d2	 test	 rdx, rdx
  0003b	75 14		 jne	 SHORT $LN75@PyUnicode_@30

; 8539 :         PyErr_BadArgument();

  0003d	e8 00 00 00 00	 call	 PyErr_BadArgument
$LN175@PyUnicode_@30:

; 8540 :         return NULL;

  00042	33 c0		 xor	 eax, eax

; 8673 : }

  00044	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0004b	41 5f		 pop	 r15
  0004d	5f		 pop	 rdi
  0004e	5e		 pop	 rsi
  0004f	5d		 pop	 rbp
  00050	c3		 ret	 0
$LN75@PyUnicode_@30:

; 8541 :     }
; 8542 : 
; 8543 :     if (PyUnicode_READY(input) == -1)

  00051	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00055	75 0a		 jne	 SHORT $LN74@PyUnicode_@30
  00057	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0005c	83 f8 ff	 cmp	 eax, -1

; 8544 :         return NULL;

  0005f	74 e1		 je	 SHORT $LN175@PyUnicode_@30
$LN74@PyUnicode_@30:
  00061	48 89 9c 24 d0
	00 00 00	 mov	 QWORD PTR [rsp+208], rbx

; 8545 :     idata = (char*)PyUnicode_DATA(input);

  00069	8b 5e 70	 mov	 ebx, DWORD PTR [rsi+112]
  0006c	4c 89 a4 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], r12
  00074	4c 89 b4 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], r14
  0007c	f6 c3 20	 test	 bl, 32			; 00000020H
  0007f	74 17		 je	 SHORT $LN82@PyUnicode_@30
  00081	f6 c3 40	 test	 bl, 64			; 00000040H
  00084	74 09		 je	 SHORT $LN80@PyUnicode_@30
  00086	4c 8d b6 80 00
	00 00		 lea	 r14, QWORD PTR [rsi+128]
  0008d	eb 10		 jmp	 SHORT $LN83@PyUnicode_@30
$LN80@PyUnicode_@30:
  0008f	4c 8d b6 a0 00
	00 00		 lea	 r14, QWORD PTR [rsi+160]
  00096	eb 07		 jmp	 SHORT $LN83@PyUnicode_@30
$LN82@PyUnicode_@30:
  00098	4c 8b b6 a0 00
	00 00		 mov	 r14, QWORD PTR [rsi+160]
$LN83@PyUnicode_@30:

; 8546 :     kind = PyUnicode_KIND(input);
; 8547 :     size = PyUnicode_GET_LENGTH(input);

  0009f	48 8b 46 60	 mov	 rax, QWORD PTR [rsi+96]
  000a3	c1 eb 02	 shr	 ebx, 2

; 8548 :     i = 0;

  000a6	4d 8b e7	 mov	 r12, r15
  000a9	83 e3 07	 and	 ebx, 7
  000ac	48 89 45 c7	 mov	 QWORD PTR size$1$[rbp-153], rax

; 8549 : 
; 8550 :     if (size == 0) {

  000b0	48 85 c0	 test	 rax, rax
  000b3	75 10		 jne	 SHORT $LN73@PyUnicode_@30

; 8551 :         Py_INCREF(input);

  000b5	48 8b ce	 mov	 rcx, rsi
  000b8	e8 00 00 00 00	 call	 _Py_IncRef

; 8552 :         return input;

  000bd	48 8b c6	 mov	 rax, rsi
  000c0	e9 fb 05 00 00	 jmp	 $LN171@PyUnicode_@30
$LN73@PyUnicode_@30:

; 8553 :     }
; 8554 : 
; 8555 :     /* allocate enough for a simple 1:1 translation without
; 8556 :        replacements, if we need more, we'll resize */
; 8557 :     osize = size;
; 8558 :     output = PyMem_Malloc(osize * sizeof(Py_UCS4));

  000c5	48 8d 0c 85 00
	00 00 00	 lea	 rcx, QWORD PTR [rax*4]
  000cd	4c 89 ac 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], r13
  000d5	48 89 45 d7	 mov	 QWORD PTR osize$[rbp-153], rax
  000d9	e8 00 00 00 00	 call	 PyMem_Malloc

; 8559 :     opos = 0;

  000de	49 8b f7	 mov	 rsi, r15
  000e1	4c 89 7d af	 mov	 QWORD PTR opos$[rbp-153], r15
  000e5	4c 8b e8	 mov	 r13, rax
  000e8	48 89 45 a7	 mov	 QWORD PTR output$[rbp-153], rax

; 8560 :     if (output == NULL) {

  000ec	48 85 c0	 test	 rax, rax
  000ef	75 0a		 jne	 SHORT $LN143@PyUnicode_@30

; 8561 :         PyErr_NoMemory();

  000f1	e8 00 00 00 00	 call	 PyErr_NoMemory

; 8562 :         goto onError;

  000f6	e9 b4 04 00 00	 jmp	 $onError$134861
$LN143@PyUnicode_@30:

; 8588 :                 if (charmaptranslate_lookup(PyUnicode_READ(kind,idata, collend), mapping, &x))

  000fb	4c 63 fb	 movsxd	 r15, ebx
  000fe	bb 04 00 00 00	 mov	 ebx, 4
  00103	48 39 75 c7	 cmp	 QWORD PTR size$1$[rbp-153], rsi
  00107	0f 8e 86 04 00
	00		 jle	 $LN167@PyUnicode_@30
$LN173@PyUnicode_@30:

; 8566 :         /* try to encode it */
; 8567 :         PyObject *x = NULL;
; 8568 :         if (charmaptranslate_output(input, i, mapping,
; 8569 :                                     &output, &osize, &opos, &x)) {

  0010d	4c 8b 45 6f	 mov	 r8, QWORD PTR mapping$[rbp-153]
  00111	48 8b 4d 67	 mov	 rcx, QWORD PTR input$[rbp-153]
  00115	48 8d 45 cf	 lea	 rax, QWORD PTR x$134865[rbp-153]
  00119	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0011e	48 8d 45 af	 lea	 rax, QWORD PTR opos$[rbp-153]
  00122	4c 8d 4d a7	 lea	 r9, QWORD PTR output$[rbp-153]
  00126	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0012b	48 8d 45 d7	 lea	 rax, QWORD PTR osize$[rbp-153]
  0012f	45 33 ed	 xor	 r13d, r13d
  00132	49 8b d4	 mov	 rdx, r12
  00135	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  0013c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00141	4c 89 6d cf	 mov	 QWORD PTR x$134865[rbp-153], r13
  00145	e8 00 00 00 00	 call	 charmaptranslate_output
  0014a	85 c0		 test	 eax, eax
  0014c	0f 85 25 04 00
	00		 jne	 $LN152@PyUnicode_@30

; 8572 :         }
; 8573 :         Py_XDECREF(x);

  00152	48 8b 7d cf	 mov	 rdi, QWORD PTR x$134865[rbp-153]
  00156	48 85 ff	 test	 rdi, rdi
  00159	74 08		 je	 SHORT $LN63@PyUnicode_@30
  0015b	48 8b cf	 mov	 rcx, rdi
  0015e	e8 00 00 00 00	 call	 _Py_DecRef
$LN63@PyUnicode_@30:

; 8574 :         if (x!=Py_None) /* it worked => adjust input pointer */

  00163	48 3b fe	 cmp	 rdi, rsi
  00166	74 10		 je	 SHORT $LN60@PyUnicode_@30

; 8575 :             ++i;
; 8576 :         else { /* untranslatable character */

  00168	4c 8b 6d a7	 mov	 r13, QWORD PTR output$[rbp-153]
  0016c	48 8b 75 af	 mov	 rsi, QWORD PTR opos$[rbp-153]
  00170	49 ff c4	 inc	 r12
  00173	e9 b4 03 00 00	 jmp	 $LN39@PyUnicode_@30
$LN60@PyUnicode_@30:

; 8577 :             PyObject *repunicode = NULL; /* initialize to prevent gcc warning */
; 8578 :             Py_ssize_t repsize;
; 8579 :             Py_ssize_t newpos;
; 8580 :             Py_ssize_t uni2;
; 8581 :             /* startpos for collecting untranslatable chars */
; 8582 :             Py_ssize_t collstart = i;
; 8583 :             Py_ssize_t collend = i+1;
; 8584 :             Py_ssize_t coll;
; 8585 : 
; 8586 :             /* find all untranslatable characters */
; 8587 :             while (collend < size) {

  00178	48 8b 75 c7	 mov	 rsi, QWORD PTR size$1$[rbp-153]
  0017c	49 8d 5c 24 01	 lea	 rbx, QWORD PTR [r12+1]
  00181	48 3b de	 cmp	 rbx, rsi
  00184	0f 8d bf 00 00
	00		 jge	 $LN150@PyUnicode_@30
  0018a	66 0f 1f 44 00
	00		 npad	 6
$LL58@PyUnicode_@30:

; 8588 :                 if (charmaptranslate_lookup(PyUnicode_READ(kind,idata, collend), mapping, &x))

  00190	49 83 ff 01	 cmp	 r15, 1
  00194	75 07		 jne	 SHORT $LN86@PyUnicode_@30
  00196	42 0f b6 0c 33	 movzx	 ecx, BYTE PTR [rbx+r14]
  0019b	eb 11		 jmp	 SHORT $LN85@PyUnicode_@30
$LN86@PyUnicode_@30:
  0019d	49 83 ff 02	 cmp	 r15, 2
  001a1	75 07		 jne	 SHORT $LN84@PyUnicode_@30
  001a3	41 0f b7 0c 5e	 movzx	 ecx, WORD PTR [r14+rbx*2]
  001a8	eb 04		 jmp	 SHORT $LN85@PyUnicode_@30
$LN84@PyUnicode_@30:

; 8577 :             PyObject *repunicode = NULL; /* initialize to prevent gcc warning */
; 8578 :             Py_ssize_t repsize;
; 8579 :             Py_ssize_t newpos;
; 8580 :             Py_ssize_t uni2;
; 8581 :             /* startpos for collecting untranslatable chars */
; 8582 :             Py_ssize_t collstart = i;
; 8583 :             Py_ssize_t collend = i+1;
; 8584 :             Py_ssize_t coll;
; 8585 : 
; 8586 :             /* find all untranslatable characters */
; 8587 :             while (collend < size) {

  001aa	41 8b 0c 9e	 mov	 ecx, DWORD PTR [r14+rbx*4]
$LN85@PyUnicode_@30:

; 8588 :                 if (charmaptranslate_lookup(PyUnicode_READ(kind,idata, collend), mapping, &x))

  001ae	48 8b 55 6f	 mov	 rdx, QWORD PTR mapping$[rbp-153]
  001b2	4c 8d 45 cf	 lea	 r8, QWORD PTR x$134865[rbp-153]
  001b6	e8 00 00 00 00	 call	 charmaptranslate_lookup
  001bb	85 c0		 test	 eax, eax
  001bd	0f 85 c2 03 00
	00		 jne	 $LN165@PyUnicode_@30

; 8589 :                     goto onError;
; 8590 :                 Py_XDECREF(x);

  001c3	48 8b 7d cf	 mov	 rdi, QWORD PTR x$134865[rbp-153]
  001c7	48 85 ff	 test	 rdi, rdi
  001ca	74 65		 je	 SHORT $LN54@PyUnicode_@30
  001cc	e8 00 00 00 00	 call	 _Py_PXCTX
  001d1	85 c0		 test	 eax, eax
  001d3	75 5c		 jne	 SHORT $LN54@PyUnicode_@30
  001d5	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  001d9	a8 20		 test	 al, 32			; 00000020H
  001db	75 4c		 jne	 SHORT $LN114@PyUnicode_@30
  001dd	84 c0		 test	 al, al
  001df	78 48		 js	 SHORT $LN114@PyUnicode_@30
  001e1	a8 02		 test	 al, 2
  001e3	75 4c		 jne	 SHORT $LN54@PyUnicode_@30
  001e5	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  001e9	75 46		 jne	 SHORT $LN54@PyUnicode_@30
  001eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001f9	4c 8b cf	 mov	 r9, rdi
  001fc	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00202	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0020a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0020f	48 8b cf	 mov	 rcx, rdi
  00212	85 c0		 test	 eax, eax
  00214	74 07		 je	 SHORT $LN119@PyUnicode_@30
  00216	e8 00 00 00 00	 call	 _Px_Dealloc
  0021b	eb 14		 jmp	 SHORT $LN54@PyUnicode_@30
$LN119@PyUnicode_@30:
  0021d	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00221	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00227	eb 08		 jmp	 SHORT $LN54@PyUnicode_@30
$LN114@PyUnicode_@30:
  00229	48 8b cf	 mov	 rcx, rdi
  0022c	e8 00 00 00 00	 call	 Px_DecRef
$LN54@PyUnicode_@30:

; 8591 :                 if (x!=Py_None)

  00231	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00238	48 3b f8	 cmp	 rdi, rax
  0023b	75 0c		 jne	 SHORT $LN150@PyUnicode_@30

; 8592 :                     break;
; 8593 :                 ++collend;

  0023d	48 ff c3	 inc	 rbx
  00240	48 3b de	 cmp	 rbx, rsi
  00243	0f 8c 47 ff ff
	ff		 jl	 $LL58@PyUnicode_@30
$LN150@PyUnicode_@30:

; 8594 :             }
; 8595 :             /* cache callback name lookup
; 8596 :              * (if not done yet, i.e. it's the first error) */
; 8597 :             if (known_errorHandler==-1) {

  00249	8b 4d 7f	 mov	 ecx, DWORD PTR known_errorHandler$1$[rbp-153]

; 8598 :                 if ((errors==NULL) || (!strcmp(errors, "strict")))

  0024c	4c 8b 55 77	 mov	 r10, QWORD PTR errors$[rbp-153]
  00250	83 f9 ff	 cmp	 ecx, -1
  00253	75 72		 jne	 SHORT $LN41@PyUnicode_@30
  00255	4d 85 d2	 test	 r10, r10
  00258	74 65		 je	 SHORT $LN48@PyUnicode_@30
  0025a	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  00261	49 8b f2	 mov	 rsi, r10
  00264	b9 07 00 00 00	 mov	 ecx, 7
  00269	f3 a6		 repe cmpsb
  0026b	74 52		 je	 SHORT $LN48@PyUnicode_@30

; 8600 :                 else if (!strcmp(errors, "replace"))

  0026d	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_07CLEHDIEJ@replace?$AA@
  00274	49 8b f2	 mov	 rsi, r10
  00277	b9 08 00 00 00	 mov	 ecx, 8
  0027c	f3 a6		 repe cmpsb
  0027e	75 07		 jne	 SHORT $LN46@PyUnicode_@30

; 8601 :                     known_errorHandler = 2;

  00280	b9 02 00 00 00	 mov	 ecx, 2
  00285	eb 3d		 jmp	 SHORT $LN176@PyUnicode_@30
$LN46@PyUnicode_@30:

; 8602 :                 else if (!strcmp(errors, "ignore"))

  00287	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06GDPEBLPA@ignore?$AA@
  0028e	49 8b f2	 mov	 rsi, r10
  00291	b9 07 00 00 00	 mov	 ecx, 7
  00296	f3 a6		 repe cmpsb
  00298	75 07		 jne	 SHORT $LN44@PyUnicode_@30

; 8603 :                     known_errorHandler = 3;

  0029a	b9 03 00 00 00	 mov	 ecx, 3
  0029f	eb 23		 jmp	 SHORT $LN176@PyUnicode_@30
$LN44@PyUnicode_@30:

; 8604 :                 else if (!strcmp(errors, "xmlcharrefreplace"))

  002a1	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0BC@EBFFMGGH@xmlcharrefreplace?$AA@
  002a8	49 8b f2	 mov	 rsi, r10
  002ab	b9 12 00 00 00	 mov	 ecx, 18
  002b0	f3 a6		 repe cmpsb
  002b2	41 8b cd	 mov	 ecx, r13d
  002b5	b8 04 00 00 00	 mov	 eax, 4
  002ba	0f 44 c8	 cmove	 ecx, eax

; 8605 :                     known_errorHandler = 4;
; 8606 :                 else
; 8607 :                     known_errorHandler = 0;

  002bd	eb 05		 jmp	 SHORT $LN176@PyUnicode_@30
$LN48@PyUnicode_@30:

; 8599 :                     known_errorHandler = 1;

  002bf	b9 01 00 00 00	 mov	 ecx, 1
$LN176@PyUnicode_@30:
  002c4	89 4d 7f	 mov	 DWORD PTR known_errorHandler$1$[rbp-153], ecx
$LN41@PyUnicode_@30:

; 8608 :             }
; 8609 :             switch (known_errorHandler) {

  002c7	ff c9		 dec	 ecx
  002c9	0f 84 7b 02 00
	00		 je	 $LN38@PyUnicode_@30
  002cf	ff c9		 dec	 ecx
  002d1	4c 8b 6d a7	 mov	 r13, QWORD PTR output$[rbp-153]
  002d5	0f 84 23 02 00
	00		 je	 $LN37@PyUnicode_@30
  002db	ff c9		 dec	 ecx
  002dd	0f 84 42 02 00
	00		 je	 $LN164@PyUnicode_@30
  002e3	ff c9		 dec	 ecx
  002e5	0f 84 58 01 00
	00		 je	 $LN32@PyUnicode_@30

; 8636 :             default:
; 8637 :                 repunicode = unicode_translate_call_errorhandler(errors, &errorHandler,
; 8638 :                                                                  reason, input, &exc,
; 8639 :                                                                  collstart, collend, &newpos);

  002eb	4c 8b 4d 67	 mov	 r9, QWORD PTR input$[rbp-153]
  002ef	48 8d 45 df	 lea	 rax, QWORD PTR newpos$134883[rbp-153]
  002f3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BO@BLGNENDK@character?5maps?5to?5?$DMundefined?$DO?$AA@
  002fa	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  002ff	48 8d 45 b7	 lea	 rax, QWORD PTR exc$[rbp-153]
  00303	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00308	48 8d 55 bf	 lea	 rdx, QWORD PTR errorHandler$[rbp-153]
  0030c	49 8b ca	 mov	 rcx, r10
  0030f	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  00314	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00319	e8 00 00 00 00	 call	 unicode_translate_call_errorhandler
  0031e	48 8b f8	 mov	 rdi, rax

; 8640 :                 if (repunicode == NULL)

  00321	48 85 c0	 test	 rax, rax
  00324	0f 84 5b 02 00
	00		 je	 $LN165@PyUnicode_@30

; 8641 :                     goto onError;
; 8642 :                 if (PyUnicode_READY(repunicode) == -1) {

  0032a	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  0032e	75 11		 jne	 SHORT $LN162@PyUnicode_@30
  00330	48 8b c8	 mov	 rcx, rax
  00333	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00338	83 f8 ff	 cmp	 eax, -1
  0033b	0f 84 04 02 00
	00		 je	 $LN154@PyUnicode_@30
$LN162@PyUnicode_@30:

; 8645 :                 }
; 8646 :                 /* generate replacement  */
; 8647 :                 repsize = PyUnicode_GET_LENGTH(repunicode);

  00341	4c 8b 67 60	 mov	 r12, QWORD PTR [rdi+96]

; 8648 :                 if (charmaptranslate_makespace(&output, &osize,
; 8649 :                                                opos+repsize+(size-collend))) {

  00345	48 8b 75 af	 mov	 rsi, QWORD PTR opos$[rbp-153]
  00349	48 8d 55 d7	 lea	 rdx, QWORD PTR osize$[rbp-153]
  0034d	4d 8b c4	 mov	 r8, r12
  00350	48 8d 4d a7	 lea	 rcx, QWORD PTR output$[rbp-153]
  00354	4c 2b c3	 sub	 r8, rbx
  00357	4c 03 c6	 add	 r8, rsi
  0035a	4c 03 45 c7	 add	 r8, QWORD PTR size$1$[rbp-153]
  0035e	e8 00 00 00 00	 call	 charmaptranslate_makespace
  00363	85 c0		 test	 eax, eax
  00365	0f 85 da 01 00
	00		 jne	 $LN154@PyUnicode_@30

; 8650 :                     Py_DECREF(repunicode);
; 8651 :                     goto onError;
; 8652 :                 }
; 8653 :                 for (uni2 = 0; repsize-->0; ++uni2)

  0036b	4c 8b 6d a7	 mov	 r13, QWORD PTR output$[rbp-153]
  0036f	33 d2		 xor	 edx, edx
  00371	4d 85 e4	 test	 r12, r12
  00374	0f 8e b8 00 00
	00		 jle	 $LN157@PyUnicode_@30
  0037a	66 0f 1f 44 00
	00		 npad	 6
$LL20@PyUnicode_@30:

; 8654 :                     output[opos++] = PyUnicode_READ_CHAR(repunicode, uni2);

  00380	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00383	49 ff cc	 dec	 r12
  00386	8b c8		 mov	 ecx, eax
  00388	c1 e9 02	 shr	 ecx, 2
  0038b	83 e1 07	 and	 ecx, 7
  0038e	83 f9 01	 cmp	 ecx, 1
  00391	75 2f		 jne	 SHORT $LN108@PyUnicode_@30
  00393	a8 20		 test	 al, 32			; 00000020H
  00395	74 1e		 je	 SHORT $LN96@PyUnicode_@30
  00397	a8 40		 test	 al, 64			; 00000040H
  00399	74 0d		 je	 SHORT $LN94@PyUnicode_@30
  0039b	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  003a2	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]
  003a6	eb 72		 jmp	 SHORT $LN107@PyUnicode_@30
$LN94@PyUnicode_@30:
  003a8	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  003af	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]
  003b3	eb 65		 jmp	 SHORT $LN107@PyUnicode_@30
$LN96@PyUnicode_@30:
  003b5	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  003bc	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]
  003c0	eb 58		 jmp	 SHORT $LN107@PyUnicode_@30
$LN108@PyUnicode_@30:
  003c2	83 f9 02	 cmp	 ecx, 2
  003c5	75 2f		 jne	 SHORT $LN106@PyUnicode_@30
  003c7	a8 20		 test	 al, 32			; 00000020H
  003c9	74 1e		 je	 SHORT $LN100@PyUnicode_@30
  003cb	a8 40		 test	 al, 64			; 00000040H
  003cd	74 0d		 je	 SHORT $LN98@PyUnicode_@30
  003cf	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  003d6	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  003da	eb 3e		 jmp	 SHORT $LN107@PyUnicode_@30
$LN98@PyUnicode_@30:
  003dc	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  003e3	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  003e7	eb 31		 jmp	 SHORT $LN107@PyUnicode_@30
$LN100@PyUnicode_@30:
  003e9	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  003f0	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  003f4	eb 24		 jmp	 SHORT $LN107@PyUnicode_@30
$LN106@PyUnicode_@30:
  003f6	a8 20		 test	 al, 32			; 00000020H
  003f8	74 16		 je	 SHORT $LN104@PyUnicode_@30
  003fa	a8 40		 test	 al, 64			; 00000040H
  003fc	74 09		 je	 SHORT $LN102@PyUnicode_@30
  003fe	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  00405	eb 10		 jmp	 SHORT $LN105@PyUnicode_@30
$LN102@PyUnicode_@30:
  00407	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  0040e	eb 07		 jmp	 SHORT $LN105@PyUnicode_@30
$LN104@PyUnicode_@30:
  00410	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
$LN105@PyUnicode_@30:
  00417	8b 0c 90	 mov	 ecx, DWORD PTR [rax+rdx*4]
$LN107@PyUnicode_@30:
  0041a	41 89 4c b5 00	 mov	 DWORD PTR [r13+rsi*4], ecx
  0041f	48 ff c6	 inc	 rsi
  00422	48 ff c2	 inc	 rdx
  00425	4d 85 e4	 test	 r12, r12
  00428	0f 8f 52 ff ff
	ff		 jg	 $LL20@PyUnicode_@30
  0042e	48 89 75 af	 mov	 QWORD PTR opos$[rbp-153], rsi
$LN157@PyUnicode_@30:

; 8655 :                 i = newpos;

  00432	4c 8b 65 df	 mov	 r12, QWORD PTR newpos$134883[rbp-153]

; 8656 :                 Py_DECREF(repunicode);

  00436	48 8b cf	 mov	 rcx, rdi
  00439	e8 00 00 00 00	 call	 _Py_DecRef
  0043e	e9 e9 00 00 00	 jmp	 $LN39@PyUnicode_@30
$LN32@PyUnicode_@30:

; 8621 :                 break;
; 8622 :             case 4: /* xmlcharrefreplace */
; 8623 :                 /* generate replacement (temporarily (mis)uses i) */
; 8624 :                 for (i = collstart; i < collend; ++i) {

  00443	48 8b 75 af	 mov	 rsi, QWORD PTR opos$[rbp-153]
  00447	4c 3b e3	 cmp	 r12, rbx
  0044a	0f 8d a8 00 00
	00		 jge	 $LN163@PyUnicode_@30
$LL31@PyUnicode_@30:

; 8625 :                     char buffer[2+29+1+1];
; 8626 :                     char *cp;
; 8627 :                     sprintf(buffer, "&#%d;", PyUnicode_READ(kind, idata, i));

  00450	49 83 ff 01	 cmp	 r15, 1
  00454	75 07		 jne	 SHORT $LN90@PyUnicode_@30
  00456	47 0f b6 04 34	 movzx	 r8d, BYTE PTR [r12+r14]
  0045b	eb 11		 jmp	 SHORT $LN89@PyUnicode_@30
$LN90@PyUnicode_@30:
  0045d	49 83 ff 02	 cmp	 r15, 2
  00461	75 07		 jne	 SHORT $LN88@PyUnicode_@30
  00463	47 0f b7 04 66	 movzx	 r8d, WORD PTR [r14+r12*2]
  00468	eb 04		 jmp	 SHORT $LN89@PyUnicode_@30
$LN88@PyUnicode_@30:

; 8621 :                 break;
; 8622 :             case 4: /* xmlcharrefreplace */
; 8623 :                 /* generate replacement (temporarily (mis)uses i) */
; 8624 :                 for (i = collstart; i < collend; ++i) {

  0046a	47 8b 04 a6	 mov	 r8d, DWORD PTR [r14+r12*4]
$LN89@PyUnicode_@30:

; 8625 :                     char buffer[2+29+1+1];
; 8626 :                     char *cp;
; 8627 :                     sprintf(buffer, "&#%d;", PyUnicode_READ(kind, idata, i));

  0046e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05PNCJDOGL@?$CG?$CD?$CFd?$DL?$AA@
  00475	48 8d 4d e7	 lea	 rcx, QWORD PTR buffer$134927[rbp-153]
  00479	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 8628 :                     if (charmaptranslate_makespace(&output, &osize,
; 8629 :                                                    opos+strlen(buffer)+(size-collend)))

  0047f	48 83 c9 ff	 or	 rcx, -1
  00483	33 c0		 xor	 eax, eax
  00485	48 8d 7d e7	 lea	 rdi, QWORD PTR buffer$134927[rbp-153]
  00489	4c 8b c6	 mov	 r8, rsi
  0048c	48 8d 55 d7	 lea	 rdx, QWORD PTR osize$[rbp-153]
  00490	f2 ae		 repne scasb
  00492	48 8b 45 c7	 mov	 rax, QWORD PTR size$1$[rbp-153]
  00496	4c 2b c3	 sub	 r8, rbx
  00499	48 f7 d1	 not	 rcx
  0049c	48 ff c9	 dec	 rcx
  0049f	48 03 c1	 add	 rax, rcx
  004a2	48 8d 4d a7	 lea	 rcx, QWORD PTR output$[rbp-153]
  004a6	4c 03 c0	 add	 r8, rax
  004a9	e8 00 00 00 00	 call	 charmaptranslate_makespace
  004ae	85 c0		 test	 eax, eax
  004b0	0f 85 cf 00 00
	00		 jne	 $LN165@PyUnicode_@30

; 8630 :                         goto onError;
; 8631 :                     for (cp = buffer; *cp; ++cp)

  004b6	0f b6 4d e7	 movzx	 ecx, BYTE PTR buffer$134927[rbp-153]
  004ba	4c 8b 6d a7	 mov	 r13, QWORD PTR output$[rbp-153]
  004be	84 c9		 test	 cl, cl
  004c0	74 28		 je	 SHORT $LN30@PyUnicode_@30
  004c2	48 8d 55 e7	 lea	 rdx, QWORD PTR buffer$134927[rbp-153]
  004c6	48 2b d6	 sub	 rdx, rsi
  004c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL27@PyUnicode_@30:

; 8632 :                         output[opos++] = *cp;

  004d0	0f be c1	 movsx	 eax, cl
  004d3	48 ff c6	 inc	 rsi
  004d6	41 89 44 b5 fc	 mov	 DWORD PTR [r13+rsi*4-4], eax
  004db	0f b6 04 32	 movzx	 eax, BYTE PTR [rdx+rsi]
  004df	0f b6 c8	 movzx	 ecx, al
  004e2	84 c0		 test	 al, al
  004e4	75 ea		 jne	 SHORT $LL27@PyUnicode_@30
  004e6	48 89 75 af	 mov	 QWORD PTR opos$[rbp-153], rsi
$LN30@PyUnicode_@30:

; 8621 :                 break;
; 8622 :             case 4: /* xmlcharrefreplace */
; 8623 :                 /* generate replacement (temporarily (mis)uses i) */
; 8624 :                 for (i = collstart; i < collend; ++i) {

  004ea	49 ff c4	 inc	 r12
  004ed	4c 3b e3	 cmp	 r12, rbx
  004f0	0f 8c 5a ff ff
	ff		 jl	 $LL31@PyUnicode_@30
  004f6	eb 31		 jmp	 SHORT $LN36@PyUnicode_@30
$LN163@PyUnicode_@30:
  004f8	4c 8b 6d a7	 mov	 r13, QWORD PTR output$[rbp-153]

; 8633 :                 }
; 8634 :                 i = collend;
; 8635 :                 break;

  004fc	eb 2b		 jmp	 SHORT $LN36@PyUnicode_@30
$LN37@PyUnicode_@30:

; 8614 :             case 2: /* replace */
; 8615 :                 /* No need to check for space, this is a 1:1 replacement */
; 8616 :                 for (coll = collstart; coll<collend; coll++)

  004fe	4c 3b e3	 cmp	 r12, rbx
  00501	7d 22		 jge	 SHORT $LN164@PyUnicode_@30
  00503	48 8b 75 af	 mov	 rsi, QWORD PTR opos$[rbp-153]
  00507	48 8b d3	 mov	 rdx, rbx
  0050a	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  0050f	49 2b d4	 sub	 rdx, r12
  00512	49 8d 7c b5 00	 lea	 rdi, QWORD PTR [r13+rsi*4]
  00517	48 8b ca	 mov	 rcx, rdx
  0051a	48 03 f2	 add	 rsi, rdx
  0051d	f3 ab		 rep stosd
  0051f	48 89 75 af	 mov	 QWORD PTR opos$[rbp-153], rsi
  00523	eb 04		 jmp	 SHORT $LN36@PyUnicode_@30
$LN164@PyUnicode_@30:
  00525	48 8b 75 af	 mov	 rsi, QWORD PTR opos$[rbp-153]
$LN36@PyUnicode_@30:

; 8617 :                     output[opos++] = '?';
; 8618 :                 /* fall through */
; 8619 :             case 3: /* ignore */
; 8620 :                 i = collend;

  00529	4c 8b e3	 mov	 r12, rbx
$LN39@PyUnicode_@30:

; 8563 :     }
; 8564 : 
; 8565 :     while (i<size) {

  0052c	4c 3b 65 c7	 cmp	 r12, QWORD PTR size$1$[rbp-153]
  00530	0f 8c d7 fb ff
	ff		 jl	 $LN173@PyUnicode_@30

; 8648 :                 if (charmaptranslate_makespace(&output, &osize,
; 8649 :                                                opos+repsize+(size-collend))) {

  00536	4c 8b 7d bf	 mov	 r15, QWORD PTR errorHandler$[rbp-153]
  0053a	48 8b 7d b7	 mov	 rdi, QWORD PTR exc$[rbp-153]
  0053e	bb 04 00 00 00	 mov	 ebx, 4
  00543	eb 51		 jmp	 SHORT $LN70@PyUnicode_@30
$LN154@PyUnicode_@30:

; 8643 :                     Py_DECREF(repunicode);

  00545	48 8b cf	 mov	 rcx, rdi

; 8644 :                     goto onError;

  00548	eb 36		 jmp	 SHORT $LN174@PyUnicode_@30
$LN38@PyUnicode_@30:

; 8610 :             case 1: /* strict */
; 8611 :                 raise_translate_exception(&exc, input, collstart,
; 8612 :                                           collend, reason);

  0054a	48 8b 55 67	 mov	 rdx, QWORD PTR input$[rbp-153]
  0054e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@BLGNENDK@character?5maps?5to?5?$DMundefined?$DO?$AA@
  00555	48 8d 4d b7	 lea	 rcx, QWORD PTR exc$[rbp-153]
  00559	4c 8b cb	 mov	 r9, rbx
  0055c	4d 8b c4	 mov	 r8, r12
  0055f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00564	e8 00 00 00 00	 call	 raise_translate_exception

; 8613 :                 goto onError;

  00569	4c 8b 6d a7	 mov	 r13, QWORD PTR output$[rbp-153]
  0056d	4c 8b 7d bf	 mov	 r15, QWORD PTR errorHandler$[rbp-153]
  00571	48 8b 7d b7	 mov	 rdi, QWORD PTR exc$[rbp-153]
  00575	eb 38		 jmp	 SHORT $onError$134861
$LN152@PyUnicode_@30:

; 8570 :             Py_XDECREF(x);

  00577	48 8b 4d cf	 mov	 rcx, QWORD PTR x$134865[rbp-153]
  0057b	48 85 c9	 test	 rcx, rcx
  0057e	74 05		 je	 SHORT $LN165@PyUnicode_@30
$LN174@PyUnicode_@30:
  00580	e8 00 00 00 00	 call	 _Py_DecRef
$LN165@PyUnicode_@30:

; 8571 :             goto onError;

  00585	4c 8b 6d a7	 mov	 r13, QWORD PTR output$[rbp-153]
  00589	4c 8b 7d bf	 mov	 r15, QWORD PTR errorHandler$[rbp-153]
  0058d	48 8b 7d b7	 mov	 rdi, QWORD PTR exc$[rbp-153]
  00591	eb 1c		 jmp	 SHORT $onError$134861
$LN167@PyUnicode_@30:

; 8575 :             ++i;
; 8576 :         else { /* untranslatable character */

  00593	45 33 ff	 xor	 r15d, r15d
$LN70@PyUnicode_@30:

; 8657 :             }
; 8658 :         }
; 8659 :     }
; 8660 :     res = PyUnicode_FromKindAndData(PyUnicode_4BYTE_KIND, output, opos);

  00596	4c 8b c6	 mov	 r8, rsi
  00599	49 8b d5	 mov	 rdx, r13
  0059c	8b cb		 mov	 ecx, ebx
  0059e	e8 00 00 00 00	 call	 PyUnicode_FromKindAndData
  005a3	48 8b f0	 mov	 rsi, rax

; 8661 :     if (!res)

  005a6	48 85 c0	 test	 rax, rax
  005a9	0f 85 e4 00 00
	00		 jne	 $LN17@PyUnicode_@30
$onError$134861:

; 8667 : 
; 8668 :   onError:
; 8669 :     PyMem_Free(output);

  005af	49 8b cd	 mov	 rcx, r13
  005b2	e8 00 00 00 00	 call	 PyMem_Free

; 8670 :     Py_XDECREF(exc);

  005b7	48 85 ff	 test	 rdi, rdi
  005ba	74 65		 je	 SHORT $LN7@PyUnicode_@30
  005bc	e8 00 00 00 00	 call	 _Py_PXCTX
  005c1	85 c0		 test	 eax, eax
  005c3	75 5c		 jne	 SHORT $LN7@PyUnicode_@30
  005c5	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  005c9	a8 20		 test	 al, 32			; 00000020H
  005cb	75 4c		 jne	 SHORT $LN125@PyUnicode_@30
  005cd	84 c0		 test	 al, al
  005cf	78 48		 js	 SHORT $LN125@PyUnicode_@30
  005d1	a8 02		 test	 al, 2
  005d3	75 4c		 jne	 SHORT $LN7@PyUnicode_@30
  005d5	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  005d9	75 46		 jne	 SHORT $LN7@PyUnicode_@30
  005db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  005e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  005e9	4c 8b cf	 mov	 r9, rdi
  005ec	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  005f2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  005fa	e8 00 00 00 00	 call	 _PyParallel_Guard
  005ff	48 8b cf	 mov	 rcx, rdi
  00602	85 c0		 test	 eax, eax
  00604	74 07		 je	 SHORT $LN130@PyUnicode_@30
  00606	e8 00 00 00 00	 call	 _Px_Dealloc
  0060b	eb 14		 jmp	 SHORT $LN7@PyUnicode_@30
$LN130@PyUnicode_@30:
  0060d	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00611	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00617	eb 08		 jmp	 SHORT $LN7@PyUnicode_@30
$LN125@PyUnicode_@30:
  00619	48 8b cf	 mov	 rcx, rdi
  0061c	e8 00 00 00 00	 call	 Px_DecRef
$LN7@PyUnicode_@30:

; 8671 :     Py_XDECREF(errorHandler);

  00621	4d 85 ff	 test	 r15, r15
  00624	74 69		 je	 SHORT $LN3@PyUnicode_@30
  00626	e8 00 00 00 00	 call	 _Py_PXCTX
  0062b	85 c0		 test	 eax, eax
  0062d	75 60		 jne	 SHORT $LN3@PyUnicode_@30
  0062f	49 8b 47 20	 mov	 rax, QWORD PTR [r15+32]
  00633	a8 20		 test	 al, 32			; 00000020H
  00635	75 50		 jne	 SHORT $LN136@PyUnicode_@30
  00637	84 c0		 test	 al, al
  00639	78 4c		 js	 SHORT $LN136@PyUnicode_@30
  0063b	a8 02		 test	 al, 2
  0063d	75 50		 jne	 SHORT $LN3@PyUnicode_@30
  0063f	49 ff 4f 50	 dec	 QWORD PTR [r15+80]
  00643	75 4a		 jne	 SHORT $LN3@PyUnicode_@30
  00645	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0064c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00653	4d 8b cf	 mov	 r9, r15
  00656	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0065c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00664	e8 00 00 00 00	 call	 _PyParallel_Guard
  00669	49 8b cf	 mov	 rcx, r15
  0066c	85 c0		 test	 eax, eax
  0066e	74 09		 je	 SHORT $LN141@PyUnicode_@30
  00670	e8 00 00 00 00	 call	 _Px_Dealloc

; 8672 :     return NULL;

  00675	33 c0		 xor	 eax, eax
  00677	eb 3f		 jmp	 SHORT $LN172@PyUnicode_@30

; 8671 :     Py_XDECREF(errorHandler);

$LN141@PyUnicode_@30:
  00679	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  0067d	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 8672 :     return NULL;

  00683	33 c0		 xor	 eax, eax
  00685	eb 31		 jmp	 SHORT $LN172@PyUnicode_@30

; 8671 :     Py_XDECREF(errorHandler);

$LN136@PyUnicode_@30:
  00687	49 8b cf	 mov	 rcx, r15
  0068a	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PyUnicode_@30:

; 8672 :     return NULL;

  0068f	33 c0		 xor	 eax, eax
  00691	eb 25		 jmp	 SHORT $LN172@PyUnicode_@30
$LN17@PyUnicode_@30:

; 8662 :         goto onError;
; 8663 :     PyMem_Free(output);

  00693	49 8b cd	 mov	 rcx, r13
  00696	e8 00 00 00 00	 call	 PyMem_Free

; 8664 :     Py_XDECREF(exc);

  0069b	48 85 ff	 test	 rdi, rdi
  0069e	74 08		 je	 SHORT $LN15@PyUnicode_@30
  006a0	48 8b cf	 mov	 rcx, rdi
  006a3	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@PyUnicode_@30:

; 8665 :     Py_XDECREF(errorHandler);

  006a8	4d 85 ff	 test	 r15, r15
  006ab	74 08		 je	 SHORT $LN11@PyUnicode_@30
  006ad	49 8b cf	 mov	 rcx, r15
  006b0	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@PyUnicode_@30:

; 8666 :     return res;

  006b5	48 8b c6	 mov	 rax, rsi
$LN172@PyUnicode_@30:
  006b8	4c 8b ac 24 c0
	00 00 00	 mov	 r13, QWORD PTR [rsp+192]
$LN171@PyUnicode_@30:
  006c0	4c 8b a4 24 c8
	00 00 00	 mov	 r12, QWORD PTR [rsp+200]
  006c8	48 8b 9c 24 d0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+208]
  006d0	4c 8b b4 24 b8
	00 00 00	 mov	 r14, QWORD PTR [rsp+184]

; 8673 : }

  006d8	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  006df	41 5f		 pop	 r15
  006e1	5f		 pop	 rdi
  006e2	5e		 pop	 rsi
  006e3	5d		 pop	 rbp
  006e4	c3		 ret	 0
_PyUnicode_TranslateCharmap ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_Translate
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_Translate DD imagerel $LN4
	DD	imagerel $LN4+94
	DD	imagerel $unwind$PyUnicode_Translate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Translate DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_Translate
_TEXT	SEGMENT
str$ = 48
mapping$ = 56
errors$ = 64
PyUnicode_Translate PROC				; COMDAT

; 8695 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b d8	 mov	 rbx, r8
  00012	48 8b f2	 mov	 rsi, rdx

; 8696 :     PyObject *result;
; 8697 : 
; 8698 :     str = PyUnicode_FromObject(str);

  00015	e8 00 00 00 00	 call	 PyUnicode_FromObject
  0001a	48 8b f8	 mov	 rdi, rax

; 8699 :     if (str == NULL)

  0001d	48 85 c0	 test	 rax, rax
  00020	75 10		 jne	 SHORT $LN1@PyUnicode_@31

; 8703 :     return result;
; 8704 : }

  00022	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00027	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN1@PyUnicode_@31:

; 8700 :         return NULL;
; 8701 :     result = _PyUnicode_TranslateCharmap(str, mapping, errors);

  00032	4c 8b c3	 mov	 r8, rbx
  00035	48 8b d6	 mov	 rdx, rsi
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 _PyUnicode_TranslateCharmap

; 8702 :     Py_DECREF(str);

  00040	48 8b cf	 mov	 rcx, rdi
  00043	48 8b d8	 mov	 rbx, rax
  00046	e8 00 00 00 00	 call	 _Py_DecRef

; 8703 :     return result;
; 8704 : }

  0004b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00050	48 8b c3	 mov	 rax, rbx
  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
PyUnicode_Translate ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_ToDecimalDigit:PROC
EXTRN	_PyUnicode_IsWhitespace:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fix_decimal_and_space_to_ascii DD imagerel fix_decimal_and_space_to_ascii
	DD	imagerel fix_decimal_and_space_to_ascii+87
	DD	imagerel $unwind$fix_decimal_and_space_to_ascii
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$fix_decimal_and_space_to_ascii DD imagerel fix_decimal_and_space_to_ascii+87
	DD	imagerel fix_decimal_and_space_to_ascii+300
	DD	imagerel $chain$2$fix_decimal_and_space_to_ascii
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$fix_decimal_and_space_to_ascii DD imagerel fix_decimal_and_space_to_ascii+300
	DD	imagerel fix_decimal_and_space_to_ascii+323
	DD	imagerel $chain$3$fix_decimal_and_space_to_ascii
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$fix_decimal_and_space_to_ascii DD 021H
	DD	imagerel fix_decimal_and_space_to_ascii
	DD	imagerel fix_decimal_and_space_to_ascii+87
	DD	imagerel $unwind$fix_decimal_and_space_to_ascii
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$fix_decimal_and_space_to_ascii DD 060f21H
	DD	0dc40fH
	DD	0c540aH
	DD	0b3405H
	DD	imagerel fix_decimal_and_space_to_ascii
	DD	imagerel fix_decimal_and_space_to_ascii+87
	DD	imagerel $unwind$fix_decimal_and_space_to_ascii
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fix_decimal_and_space_to_ascii DD 060d01H
	DD	0f009320dH
	DD	0d005e007H
	DD	060027003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT fix_decimal_and_space_to_ascii
_TEXT	SEGMENT
modified$1$ = 80
self$ = 80
fix_decimal_and_space_to_ascii PROC			; COMDAT

; 8708 : {

  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 55		 push	 r13
  00005	41 56		 push	 r14
  00007	41 57		 push	 r15
  00009	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 8709 :     /* No need to call PyUnicode_READY(self) because this function is only
; 8710 :        called as a callback from fixup() which does it already. */
; 8711 :     const Py_ssize_t len = PyUnicode_GET_LENGTH(self);
; 8712 :     const int kind = PyUnicode_KIND(self);

  0000d	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00010	4c 8b 71 60	 mov	 r14, QWORD PTR [rcx+96]
  00014	8b f0		 mov	 esi, eax
  00016	c1 ee 02	 shr	 esi, 2
  00019	83 e6 07	 and	 esi, 7

; 8713 :     void *data = PyUnicode_DATA(self);

  0001c	a8 20		 test	 al, 32			; 00000020H
  0001e	74 16		 je	 SHORT $LN22@fix_decima
  00020	a8 40		 test	 al, 64			; 00000040H
  00022	74 09		 je	 SHORT $LN20@fix_decima
  00024	48 8d b9 80 00
	00 00		 lea	 rdi, QWORD PTR [rcx+128]
  0002b	eb 10		 jmp	 SHORT $LN23@fix_decima
$LN20@fix_decima:
  0002d	48 8d b9 a0 00
	00 00		 lea	 rdi, QWORD PTR [rcx+160]
  00034	eb 07		 jmp	 SHORT $LN23@fix_decima
$LN22@fix_decima:
  00036	48 8b b9 a0 00
	00 00		 mov	 rdi, QWORD PTR [rcx+160]
$LN23@fix_decima:

; 8715 :     int modified = 0;

  0003d	45 33 ff	 xor	 r15d, r15d
  00040	41 bd 7f 00 00
	00		 mov	 r13d, 127		; 0000007fH
  00046	45 8b c7	 mov	 r8d, r15d
  00049	44 89 7c 24 50	 mov	 DWORD PTR modified$1$[rsp], r15d

; 8716 :     Py_ssize_t i;
; 8717 : 
; 8718 :     for (i = 0; i < len; ++i) {

  0004e	4d 85 f6	 test	 r14, r14
  00051	0f 8e d5 00 00
	00		 jle	 $LN15@fix_decima

; 8714 :     Py_UCS4 maxchar = 127, ch, fixed;

  00057	48 89 5c 24 58	 mov	 QWORD PTR [rsp+88], rbx
  0005c	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  00061	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  00066	4c 8b e7	 mov	 r12, rdi
  00069	48 8b ef	 mov	 rbp, rdi
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
$LL17@fix_decima:

; 8719 :         ch = PyUnicode_READ(kind, data, i);

  00073	83 fe 01	 cmp	 esi, 1
  00076	75 05		 jne	 SHORT $LN26@fix_decima
  00078	0f b6 1f	 movzx	 ebx, BYTE PTR [rdi]
  0007b	eb 0f		 jmp	 SHORT $LN25@fix_decima
$LN26@fix_decima:
  0007d	83 fe 02	 cmp	 esi, 2
  00080	75 06		 jne	 SHORT $LN24@fix_decima
  00082	0f b7 5d 00	 movzx	 ebx, WORD PTR [rbp]
  00086	eb 04		 jmp	 SHORT $LN25@fix_decima
$LN24@fix_decima:
  00088	41 8b 1c 24	 mov	 ebx, DWORD PTR [r12]
$LN25@fix_decima:

; 8720 :         fixed = 0;
; 8721 :         if (ch > 127) {

  0008c	83 fb 7f	 cmp	 ebx, 127		; 0000007fH
  0008f	76 73		 jbe	 SHORT $LN16@fix_decima

; 8722 :             if (Py_UNICODE_ISSPACE(ch))

  00091	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  00097	73 08		 jae	 SHORT $LN28@fix_decima
  00099	8b c3		 mov	 eax, ebx
  0009b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0009f	eb 07		 jmp	 SHORT $LN29@fix_decima
$LN28@fix_decima:
  000a1	8b cb		 mov	 ecx, ebx
  000a3	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
$LN29@fix_decima:
  000a8	85 c0		 test	 eax, eax
  000aa	74 07		 je	 SHORT $LN13@fix_decima

; 8723 :                 fixed = ' ';

  000ac	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H

; 8724 :             else {

  000b1	eb 12		 jmp	 SHORT $LN32@fix_decima
$LN13@fix_decima:

; 8725 :                 const int decimal = Py_UNICODE_TODECIMAL(ch);

  000b3	8b cb		 mov	 ecx, ebx
  000b5	e8 00 00 00 00	 call	 _PyUnicode_ToDecimalDigit

; 8726 :                 if (decimal >= 0)

  000ba	85 c0		 test	 eax, eax
  000bc	78 35		 js	 SHORT $LN10@fix_decima

; 8727 :                     fixed = '0' + decimal;

  000be	8d 48 30	 lea	 ecx, DWORD PTR [rax+48]

; 8728 :             }
; 8729 :             if (fixed != 0) {

  000c1	85 c9		 test	 ecx, ecx
  000c3	74 2e		 je	 SHORT $LN10@fix_decima
$LN32@fix_decima:

; 8730 :                 modified = 1;
; 8731 :                 maxchar = Py_MAX(maxchar, fixed);

  000c5	44 3b e9	 cmp	 r13d, ecx
  000c8	8b c1		 mov	 eax, ecx

; 8732 :                 PyUnicode_WRITE(kind, data, i, fixed);

  000ca	8b d6		 mov	 edx, esi
  000cc	41 0f 47 c5	 cmova	 eax, r13d
  000d0	ff ca		 dec	 edx
  000d2	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR modified$1$[rsp], 1
  000da	44 8b e8	 mov	 r13d, eax
  000dd	74 10		 je	 SHORT $LN4@fix_decima
  000df	ff ca		 dec	 edx
  000e1	74 06		 je	 SHORT $LN3@fix_decima
  000e3	41 89 0c 24	 mov	 DWORD PTR [r12], ecx
  000e7	eb 14		 jmp	 SHORT $LN33@fix_decima
$LN3@fix_decima:
  000e9	66 89 4d 00	 mov	 WORD PTR [rbp], cx
  000ed	eb 0e		 jmp	 SHORT $LN33@fix_decima
$LN4@fix_decima:
  000ef	88 0f		 mov	 BYTE PTR [rdi], cl

; 8733 :             }
; 8734 :             else

  000f1	eb 0a		 jmp	 SHORT $LN33@fix_decima
$LN10@fix_decima:

; 8735 :                 maxchar = Py_MAX(maxchar, ch);

  000f3	44 3b eb	 cmp	 r13d, ebx
  000f6	41 0f 47 dd	 cmova	 ebx, r13d
  000fa	44 8b eb	 mov	 r13d, ebx
$LN33@fix_decima:
  000fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
$LN16@fix_decima:

; 8716 :     Py_ssize_t i;
; 8717 : 
; 8718 :     for (i = 0; i < len; ++i) {

  00104	49 83 c4 04	 add	 r12, 4
  00108	48 83 c5 02	 add	 rbp, 2
  0010c	48 ff c7	 inc	 rdi
  0010f	49 ff ce	 dec	 r14
  00112	0f 85 5b ff ff
	ff		 jne	 $LL17@fix_decima
  00118	44 8b 44 24 50	 mov	 r8d, DWORD PTR modified$1$[rsp]
  0011d	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  00122	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00127	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
$LN15@fix_decima:

; 8736 :         }
; 8737 :     }
; 8738 : 
; 8739 :     return (modified) ? maxchar : 0;

  0012c	45 85 c0	 test	 r8d, r8d
  0012f	45 0f 45 fd	 cmovne	 r15d, r13d
  00133	41 8b c7	 mov	 eax, r15d

; 8740 : }

  00136	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013a	41 5f		 pop	 r15
  0013c	41 5e		 pop	 r14
  0013e	41 5d		 pop	 r13
  00140	5f		 pop	 rdi
  00141	5e		 pop	 rsi
  00142	c3		 ret	 0
fix_decimal_and_space_to_ascii ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\find.h
pdata	SEGMENT
$pdata$any_find_slice DD imagerel any_find_slice
	DD	imagerel any_find_slice+1072
	DD	imagerel $unwind$any_find_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$any_find_slice DD 0c7201H
	DD	0cc472H
	DD	0f5416H
	DD	0e3416H
	DD	0f0125216H
	DD	0d00ee010H
	DD	0600b700cH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT any_find_slice
_TEXT	SEGMENT
direction$ = 96
kind2$1$ = 104
s1$ = 104
s2$ = 112
start$ = 120
end$ = 128
any_find_slice PROC					; COMDAT

; 8873 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 55		 push	 r13
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 8874 :     int kind1, kind2, kind;
; 8875 :     void *buf1, *buf2;
; 8876 :     Py_ssize_t len1, len2, result;
; 8877 : 
; 8878 :     kind1 = PyUnicode_KIND(s1);
; 8879 :     kind2 = PyUnicode_KIND(s2);

  00016	41 8b 40 70	 mov	 eax, DWORD PTR [r8+112]
  0001a	44 8b f1	 mov	 r14d, ecx
  0001d	48 8b fa	 mov	 rdi, rdx
  00020	8b 52 70	 mov	 edx, DWORD PTR [rdx+112]
  00023	8b c8		 mov	 ecx, eax
  00025	49 8b d9	 mov	 rbx, r9
  00028	c1 e9 02	 shr	 ecx, 2
  0002b	44 8b fa	 mov	 r15d, edx
  0002e	49 8b f0	 mov	 rsi, r8
  00031	83 e1 07	 and	 ecx, 7
  00034	41 c1 ef 02	 shr	 r15d, 2
  00038	41 83 e7 07	 and	 r15d, 7

; 8880 :     kind = kind1 > kind2 ? kind1 : kind2;

  0003c	44 8b e9	 mov	 r13d, ecx
  0003f	89 4c 24 68	 mov	 DWORD PTR kind2$1$[rsp], ecx
  00043	44 3b f9	 cmp	 r15d, ecx
  00046	45 0f 4f ef	 cmovg	 r13d, r15d

; 8881 :     buf1 = PyUnicode_DATA(s1);

  0004a	f6 c2 20	 test	 dl, 32			; 00000020H
  0004d	74 17		 je	 SHORT $LN30@any_find_s
  0004f	f6 c2 40	 test	 dl, 64			; 00000040H
  00052	74 09		 je	 SHORT $LN28@any_find_s
  00054	48 8d af 80 00
	00 00		 lea	 rbp, QWORD PTR [rdi+128]
  0005b	eb 10		 jmp	 SHORT $LN31@any_find_s
$LN28@any_find_s:
  0005d	48 8d af a0 00
	00 00		 lea	 rbp, QWORD PTR [rdi+160]
  00064	eb 07		 jmp	 SHORT $LN31@any_find_s
$LN30@any_find_s:
  00066	48 8b af a0 00
	00 00		 mov	 rbp, QWORD PTR [rdi+160]
$LN31@any_find_s:
  0006d	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12

; 8882 :     buf2 = PyUnicode_DATA(s2);

  00072	a8 20		 test	 al, 32			; 00000020H
  00074	74 16		 je	 SHORT $LN34@any_find_s
  00076	a8 40		 test	 al, 64			; 00000040H
  00078	74 09		 je	 SHORT $LN32@any_find_s
  0007a	4d 8d a0 80 00
	00 00		 lea	 r12, QWORD PTR [r8+128]
  00081	eb 10		 jmp	 SHORT $LN35@any_find_s
$LN32@any_find_s:
  00083	4d 8d a0 a0 00
	00 00		 lea	 r12, QWORD PTR [r8+160]
  0008a	eb 07		 jmp	 SHORT $LN35@any_find_s
$LN34@any_find_s:
  0008c	4d 8b a0 a0 00
	00 00		 mov	 r12, QWORD PTR [r8+160]
$LN35@any_find_s:

; 8883 :     if (kind1 != kind)

  00093	45 3b fd	 cmp	 r15d, r13d
  00096	74 12		 je	 SHORT $LN25@any_find_s

; 8884 :         buf1 = _PyUnicode_AsKind(s1, kind);

  00098	41 8b d5	 mov	 edx, r13d
  0009b	48 8b cf	 mov	 rcx, rdi
  0009e	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  000a3	8b 4c 24 68	 mov	 ecx, DWORD PTR kind2$1$[rsp]
  000a7	48 8b e8	 mov	 rbp, rax
$LN25@any_find_s:

; 8885 :     if (!buf1)

  000aa	48 85 ed	 test	 rbp, rbp

; 8886 :         return -2;

  000ad	74 25		 je	 SHORT $LN21@any_find_s

; 8887 :     if (kind2 != kind)

  000af	41 3b cd	 cmp	 ecx, r13d
  000b2	74 0e		 je	 SHORT $LN23@any_find_s

; 8888 :         buf2 = _PyUnicode_AsKind(s2, kind);

  000b4	41 8b d5	 mov	 edx, r13d
  000b7	48 8b ce	 mov	 rcx, rsi
  000ba	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  000bf	4c 8b e0	 mov	 r12, rax
$LN23@any_find_s:

; 8889 :     if (!buf2) {

  000c2	4d 85 e4	 test	 r12, r12
  000c5	75 19		 jne	 SHORT $LN22@any_find_s

; 8890 :         if (kind1 != kind) PyMem_Free(buf1);

  000c7	45 3b fd	 cmp	 r15d, r13d
  000ca	74 08		 je	 SHORT $LN21@any_find_s
  000cc	48 8b cd	 mov	 rcx, rbp
  000cf	e8 00 00 00 00	 call	 PyMem_Free
$LN21@any_find_s:

; 8891 :         return -2;

  000d4	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  000db	e9 34 03 00 00	 jmp	 $LN26@any_find_s
$LN22@any_find_s:

; 8892 :     }
; 8893 :     len1 = PyUnicode_GET_LENGTH(s1);

  000e0	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]

; 8894 :     len2 = PyUnicode_GET_LENGTH(s2);

  000e4	4c 8b 4e 60	 mov	 r9, QWORD PTR [rsi+96]

; 8895 : 
; 8896 :     if (direction > 0) {
; 8897 :         switch (kind) {

  000e8	41 8b d5	 mov	 edx, r13d
  000eb	45 85 f6	 test	 r14d, r14d
  000ee	0f 8e 83 01 00
	00		 jle	 $LN20@any_find_s
  000f4	ff ca		 dec	 edx
  000f6	0f 84 c3 00 00
	00		 je	 $LN17@any_find_s
  000fc	ff ca		 dec	 edx
  000fe	74 68		 je	 SHORT $LN14@any_find_s
  00100	83 fa 02	 cmp	 edx, 2
  00103	74 0c		 je	 SHORT $LN13@any_find_s

; 8910 :         default:
; 8911 :             assert(0); result = -2;

  00105	48 c7 c3 fe ff
	ff ff		 mov	 rbx, -2
  0010c	e9 e4 02 00 00	 jmp	 $LN6@any_find_s
$LN13@any_find_s:

; 8907 :         case PyUnicode_4BYTE_KIND:
; 8908 :             result = ucs4lib_find_slice(buf1, len1, buf2, len2, start, end);

  00111	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR end$[rsp]
  00119	33 d2		 xor	 edx, edx
  0011b	4c 3b d1	 cmp	 r10, rcx
  0011e	7e 05		 jle	 SHORT $LN65@any_find_s
  00120	4c 8b d1	 mov	 r10, rcx
  00123	eb 13		 jmp	 SHORT $LN62@any_find_s
$LN65@any_find_s:
  00125	4d 85 d2	 test	 r10, r10
  00128	79 0e		 jns	 SHORT $LN62@any_find_s
  0012a	4a 8d 04 11	 lea	 rax, QWORD PTR [rcx+r10]
  0012e	4c 8b d0	 mov	 r10, rax
  00131	48 85 c0	 test	 rax, rax
  00134	4c 0f 48 d2	 cmovs	 r10, rdx
$LN62@any_find_s:
  00138	48 85 db	 test	 rbx, rbx
  0013b	79 0e		 jns	 SHORT $LN60@any_find_s
  0013d	48 8d 04 19	 lea	 rax, QWORD PTR [rcx+rbx]
  00141	48 8b d8	 mov	 rbx, rax
  00144	48 85 c0	 test	 rax, rax
  00147	48 0f 48 da	 cmovs	 rbx, rdx
$LN60@any_find_s:
  0014b	4c 2b d3	 sub	 r10, rbx
  0014e	48 8d 4c 9d 00	 lea	 rcx, QWORD PTR [rbp+rbx*4]
  00153	4d 8b c4	 mov	 r8, r12
  00156	49 8b d2	 mov	 rdx, r10
  00159	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0015e	e8 00 00 00 00	 call	 ucs4lib_find

; 8909 :             break;

  00163	e9 8a 02 00 00	 jmp	 $LN100@any_find_s
$LN14@any_find_s:

; 8903 :             break;
; 8904 :         case PyUnicode_2BYTE_KIND:
; 8905 :             result = ucs2lib_find_slice(buf1, len1, buf2, len2, start, end);

  00168	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR end$[rsp]
  00170	33 d2		 xor	 edx, edx
  00172	4c 3b d1	 cmp	 r10, rcx
  00175	7e 05		 jle	 SHORT $LN57@any_find_s
  00177	4c 8b d1	 mov	 r10, rcx
  0017a	eb 13		 jmp	 SHORT $LN54@any_find_s
$LN57@any_find_s:
  0017c	4d 85 d2	 test	 r10, r10
  0017f	79 0e		 jns	 SHORT $LN54@any_find_s
  00181	4a 8d 04 11	 lea	 rax, QWORD PTR [rcx+r10]
  00185	4c 8b d0	 mov	 r10, rax
  00188	48 85 c0	 test	 rax, rax
  0018b	4c 0f 48 d2	 cmovs	 r10, rdx
$LN54@any_find_s:
  0018f	48 85 db	 test	 rbx, rbx
  00192	79 0e		 jns	 SHORT $LN52@any_find_s
  00194	48 8d 04 19	 lea	 rax, QWORD PTR [rcx+rbx]
  00198	48 8b d8	 mov	 rbx, rax
  0019b	48 85 c0	 test	 rax, rax
  0019e	48 0f 48 da	 cmovs	 rbx, rdx
$LN52@any_find_s:
  001a2	4c 2b d3	 sub	 r10, rbx
  001a5	48 8d 4c 5d 00	 lea	 rcx, QWORD PTR [rbp+rbx*2]
  001aa	4d 8b c4	 mov	 r8, r12
  001ad	49 8b d2	 mov	 rdx, r10
  001b0	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  001b5	e8 00 00 00 00	 call	 ucs2lib_find

; 8906 :             break;

  001ba	e9 33 02 00 00	 jmp	 $LN100@any_find_s
$LN17@any_find_s:

; 8898 :         case PyUnicode_1BYTE_KIND:
; 8899 :             if (PyUnicode_IS_ASCII(s1) && PyUnicode_IS_ASCII(s2))

  001bf	f6 47 70 40	 test	 BYTE PTR [rdi+112], 64	; 00000040H
  001c3	74 5c		 je	 SHORT $LN16@any_find_s
  001c5	f6 46 70 40	 test	 BYTE PTR [rsi+112], 64	; 00000040H
  001c9	74 56		 je	 SHORT $LN16@any_find_s

; 8900 :                 result = asciilib_find_slice(buf1, len1, buf2, len2, start, end);

  001cb	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR end$[rsp]
  001d3	33 d2		 xor	 edx, edx
  001d5	4c 3b d1	 cmp	 r10, rcx
  001d8	7e 05		 jle	 SHORT $LN41@any_find_s
  001da	4c 8b d1	 mov	 r10, rcx
  001dd	eb 13		 jmp	 SHORT $LN38@any_find_s
$LN41@any_find_s:
  001df	4d 85 d2	 test	 r10, r10
  001e2	79 0e		 jns	 SHORT $LN38@any_find_s
  001e4	4a 8d 04 11	 lea	 rax, QWORD PTR [rcx+r10]
  001e8	4c 8b d0	 mov	 r10, rax
  001eb	48 85 c0	 test	 rax, rax
  001ee	4c 0f 48 d2	 cmovs	 r10, rdx
$LN38@any_find_s:
  001f2	48 85 db	 test	 rbx, rbx
  001f5	79 0e		 jns	 SHORT $LN36@any_find_s
  001f7	48 8d 04 19	 lea	 rax, QWORD PTR [rcx+rbx]
  001fb	48 8b d8	 mov	 rbx, rax
  001fe	48 85 c0	 test	 rax, rax
  00201	48 0f 48 da	 cmovs	 rbx, rdx
$LN36@any_find_s:
  00205	4c 2b d3	 sub	 r10, rbx
  00208	48 8d 0c 2b	 lea	 rcx, QWORD PTR [rbx+rbp]
  0020c	4d 8b c4	 mov	 r8, r12
  0020f	49 8b d2	 mov	 rdx, r10
  00212	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00217	e8 00 00 00 00	 call	 asciilib_find

; 8901 :             else

  0021c	e9 d1 01 00 00	 jmp	 $LN100@any_find_s
$LN16@any_find_s:

; 8902 :                 result = ucs1lib_find_slice(buf1, len1, buf2, len2, start, end);

  00221	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR end$[rsp]
  00229	33 d2		 xor	 edx, edx
  0022b	4c 3b d1	 cmp	 r10, rcx
  0022e	7e 05		 jle	 SHORT $LN49@any_find_s
  00230	4c 8b d1	 mov	 r10, rcx
  00233	eb 13		 jmp	 SHORT $LN46@any_find_s
$LN49@any_find_s:
  00235	4d 85 d2	 test	 r10, r10
  00238	79 0e		 jns	 SHORT $LN46@any_find_s
  0023a	4a 8d 04 11	 lea	 rax, QWORD PTR [rcx+r10]
  0023e	4c 8b d0	 mov	 r10, rax
  00241	48 85 c0	 test	 rax, rax
  00244	4c 0f 48 d2	 cmovs	 r10, rdx
$LN46@any_find_s:
  00248	48 85 db	 test	 rbx, rbx
  0024b	79 0e		 jns	 SHORT $LN44@any_find_s
  0024d	48 8d 04 19	 lea	 rax, QWORD PTR [rcx+rbx]
  00251	48 8b d8	 mov	 rbx, rax
  00254	48 85 c0	 test	 rax, rax
  00257	48 0f 48 da	 cmovs	 rbx, rdx
$LN44@any_find_s:
  0025b	4c 2b d3	 sub	 r10, rbx
  0025e	48 8d 0c 2b	 lea	 rcx, QWORD PTR [rbx+rbp]
  00262	4d 8b c4	 mov	 r8, r12
  00265	49 8b d2	 mov	 rdx, r10
  00268	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0026d	e8 00 00 00 00	 call	 ucs1lib_find

; 8912 :         }
; 8913 :     }
; 8914 :     else {

  00272	e9 7b 01 00 00	 jmp	 $LN100@any_find_s
$LN20@any_find_s:

; 8915 :         switch (kind) {

  00277	ff ca		 dec	 edx
  00279	0f 84 c3 00 00
	00		 je	 $LN8@any_find_s
  0027f	ff ca		 dec	 edx
  00281	74 68		 je	 SHORT $LN5@any_find_s
  00283	83 fa 02	 cmp	 edx, 2
  00286	74 0c		 je	 SHORT $LN4@any_find_s

; 8928 :         default:
; 8929 :             assert(0); result = -2;

  00288	48 c7 c3 fe ff
	ff ff		 mov	 rbx, -2
  0028f	e9 61 01 00 00	 jmp	 $LN6@any_find_s
$LN4@any_find_s:

; 8925 :         case PyUnicode_4BYTE_KIND:
; 8926 :             result = ucs4lib_rfind_slice(buf1, len1, buf2, len2, start, end);

  00294	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR end$[rsp]
  0029c	33 d2		 xor	 edx, edx
  0029e	4c 3b d1	 cmp	 r10, rcx
  002a1	7e 05		 jle	 SHORT $LN97@any_find_s
  002a3	4c 8b d1	 mov	 r10, rcx
  002a6	eb 13		 jmp	 SHORT $LN94@any_find_s
$LN97@any_find_s:
  002a8	4d 85 d2	 test	 r10, r10
  002ab	79 0e		 jns	 SHORT $LN94@any_find_s
  002ad	4a 8d 04 11	 lea	 rax, QWORD PTR [rcx+r10]
  002b1	4c 8b d0	 mov	 r10, rax
  002b4	48 85 c0	 test	 rax, rax
  002b7	4c 0f 48 d2	 cmovs	 r10, rdx
$LN94@any_find_s:
  002bb	48 85 db	 test	 rbx, rbx
  002be	79 0e		 jns	 SHORT $LN92@any_find_s
  002c0	48 8d 04 19	 lea	 rax, QWORD PTR [rcx+rbx]
  002c4	48 8b d8	 mov	 rbx, rax
  002c7	48 85 c0	 test	 rax, rax
  002ca	48 0f 48 da	 cmovs	 rbx, rdx
$LN92@any_find_s:
  002ce	4c 2b d3	 sub	 r10, rbx
  002d1	48 8d 4c 9d 00	 lea	 rcx, QWORD PTR [rbp+rbx*4]
  002d6	4d 8b c4	 mov	 r8, r12
  002d9	49 8b d2	 mov	 rdx, r10
  002dc	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  002e1	e8 00 00 00 00	 call	 ucs4lib_rfind

; 8927 :             break;

  002e6	e9 07 01 00 00	 jmp	 $LN100@any_find_s
$LN5@any_find_s:

; 8921 :             break;
; 8922 :         case PyUnicode_2BYTE_KIND:
; 8923 :             result = ucs2lib_rfind_slice(buf1, len1, buf2, len2, start, end);

  002eb	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR end$[rsp]
  002f3	33 d2		 xor	 edx, edx
  002f5	4c 3b d1	 cmp	 r10, rcx
  002f8	7e 05		 jle	 SHORT $LN89@any_find_s
  002fa	4c 8b d1	 mov	 r10, rcx
  002fd	eb 13		 jmp	 SHORT $LN86@any_find_s
$LN89@any_find_s:
  002ff	4d 85 d2	 test	 r10, r10
  00302	79 0e		 jns	 SHORT $LN86@any_find_s
  00304	4a 8d 04 11	 lea	 rax, QWORD PTR [rcx+r10]
  00308	4c 8b d0	 mov	 r10, rax
  0030b	48 85 c0	 test	 rax, rax
  0030e	4c 0f 48 d2	 cmovs	 r10, rdx
$LN86@any_find_s:
  00312	48 85 db	 test	 rbx, rbx
  00315	79 0e		 jns	 SHORT $LN84@any_find_s
  00317	48 8d 04 19	 lea	 rax, QWORD PTR [rcx+rbx]
  0031b	48 8b d8	 mov	 rbx, rax
  0031e	48 85 c0	 test	 rax, rax
  00321	48 0f 48 da	 cmovs	 rbx, rdx
$LN84@any_find_s:
  00325	4c 2b d3	 sub	 r10, rbx
  00328	48 8d 4c 5d 00	 lea	 rcx, QWORD PTR [rbp+rbx*2]
  0032d	4d 8b c4	 mov	 r8, r12
  00330	49 8b d2	 mov	 rdx, r10
  00333	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00338	e8 00 00 00 00	 call	 ucs2lib_rfind

; 8924 :             break;

  0033d	e9 b0 00 00 00	 jmp	 $LN100@any_find_s
$LN8@any_find_s:

; 8916 :         case PyUnicode_1BYTE_KIND:
; 8917 :             if (PyUnicode_IS_ASCII(s1) && PyUnicode_IS_ASCII(s2))

  00342	f6 47 70 40	 test	 BYTE PTR [rdi+112], 64	; 00000040H
  00346	74 59		 je	 SHORT $LN7@any_find_s
  00348	f6 46 70 40	 test	 BYTE PTR [rsi+112], 64	; 00000040H
  0034c	74 53		 je	 SHORT $LN7@any_find_s

; 8918 :                 result = asciilib_rfind_slice(buf1, len1, buf2, len2, start, end);

  0034e	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR end$[rsp]
  00356	33 d2		 xor	 edx, edx
  00358	4c 3b d1	 cmp	 r10, rcx
  0035b	7e 05		 jle	 SHORT $LN73@any_find_s
  0035d	4c 8b d1	 mov	 r10, rcx
  00360	eb 13		 jmp	 SHORT $LN70@any_find_s
$LN73@any_find_s:
  00362	4d 85 d2	 test	 r10, r10
  00365	79 0e		 jns	 SHORT $LN70@any_find_s
  00367	4a 8d 04 11	 lea	 rax, QWORD PTR [rcx+r10]
  0036b	4c 8b d0	 mov	 r10, rax
  0036e	48 85 c0	 test	 rax, rax
  00371	4c 0f 48 d2	 cmovs	 r10, rdx
$LN70@any_find_s:
  00375	48 85 db	 test	 rbx, rbx
  00378	79 0e		 jns	 SHORT $LN68@any_find_s
  0037a	48 8d 04 19	 lea	 rax, QWORD PTR [rcx+rbx]
  0037e	48 8b d8	 mov	 rbx, rax
  00381	48 85 c0	 test	 rax, rax
  00384	48 0f 48 da	 cmovs	 rbx, rdx
$LN68@any_find_s:
  00388	4c 2b d3	 sub	 r10, rbx
  0038b	48 8d 0c 2b	 lea	 rcx, QWORD PTR [rbx+rbp]
  0038f	4d 8b c4	 mov	 r8, r12
  00392	49 8b d2	 mov	 rdx, r10
  00395	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0039a	e8 00 00 00 00	 call	 asciilib_rfind

; 8919 :             else

  0039f	eb 51		 jmp	 SHORT $LN100@any_find_s
$LN7@any_find_s:

; 8920 :                 result = ucs1lib_rfind_slice(buf1, len1, buf2, len2, start, end);

  003a1	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR end$[rsp]
  003a9	33 d2		 xor	 edx, edx
  003ab	4c 3b d1	 cmp	 r10, rcx
  003ae	7e 05		 jle	 SHORT $LN81@any_find_s
  003b0	4c 8b d1	 mov	 r10, rcx
  003b3	eb 13		 jmp	 SHORT $LN78@any_find_s
$LN81@any_find_s:
  003b5	4d 85 d2	 test	 r10, r10
  003b8	79 0e		 jns	 SHORT $LN78@any_find_s
  003ba	4a 8d 04 11	 lea	 rax, QWORD PTR [rcx+r10]
  003be	4c 8b d0	 mov	 r10, rax
  003c1	48 85 c0	 test	 rax, rax
  003c4	4c 0f 48 d2	 cmovs	 r10, rdx
$LN78@any_find_s:
  003c8	48 85 db	 test	 rbx, rbx
  003cb	79 0e		 jns	 SHORT $LN76@any_find_s
  003cd	48 8d 04 19	 lea	 rax, QWORD PTR [rcx+rbx]
  003d1	48 8b d8	 mov	 rbx, rax
  003d4	48 85 c0	 test	 rax, rax
  003d7	48 0f 48 da	 cmovs	 rbx, rdx
$LN76@any_find_s:
  003db	4c 2b d3	 sub	 r10, rbx
  003de	48 8d 0c 2b	 lea	 rcx, QWORD PTR [rbx+rbp]
  003e2	4d 8b c4	 mov	 r8, r12
  003e5	49 8b d2	 mov	 rdx, r10
  003e8	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  003ed	e8 00 00 00 00	 call	 ucs1lib_rfind
$LN100@any_find_s:
  003f2	48 8b d8	 mov	 rbx, rax
$LN6@any_find_s:

; 8930 :         }
; 8931 :     }
; 8932 : 
; 8933 :     if (kind1 != kind)

  003f5	45 3b fd	 cmp	 r15d, r13d
  003f8	74 08		 je	 SHORT $LN2@any_find_s

; 8934 :         PyMem_Free(buf1);

  003fa	48 8b cd	 mov	 rcx, rbp
  003fd	e8 00 00 00 00	 call	 PyMem_Free
$LN2@any_find_s:

; 8935 :     if (kind2 != kind)

  00402	44 39 6c 24 68	 cmp	 DWORD PTR kind2$1$[rsp], r13d
  00407	74 08		 je	 SHORT $LN1@any_find_s

; 8936 :         PyMem_Free(buf2);

  00409	49 8b cc	 mov	 rcx, r12
  0040c	e8 00 00 00 00	 call	 PyMem_Free
$LN1@any_find_s:

; 8937 : 
; 8938 :     return result;

  00411	48 8b c3	 mov	 rax, rbx
$LN26@any_find_s:
  00414	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]

; 8939 : }

  00419	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0041e	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  00423	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00427	41 5f		 pop	 r15
  00429	41 5e		 pop	 r14
  0042b	41 5d		 pop	 r13
  0042d	5f		 pop	 rdi
  0042e	5e		 pop	 rsi
  0042f	c3		 ret	 0
any_find_slice ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_InsertThousandsGrouping
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_InsertThousandsGrouping DD imagerel $LN46
	DD	imagerel $LN46+266
	DD	imagerel $unwind$_PyUnicode_InsertThousandsGrouping
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_PyUnicode_InsertThousandsGrouping DD imagerel $LN46+266
	DD	imagerel $LN46+727
	DD	imagerel $chain$1$_PyUnicode_InsertThousandsGrouping
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_PyUnicode_InsertThousandsGrouping DD imagerel $LN46+727
	DD	imagerel $LN46+748
	DD	imagerel $chain$2$_PyUnicode_InsertThousandsGrouping
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_PyUnicode_InsertThousandsGrouping DD 021H
	DD	imagerel $LN46
	DD	imagerel $LN46+266
	DD	imagerel $unwind$_PyUnicode_InsertThousandsGrouping
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_PyUnicode_InsertThousandsGrouping DD 020521H
	DD	08f405H
	DD	imagerel $LN46
	DD	imagerel $LN46+266
	DD	imagerel $unwind$_PyUnicode_InsertThousandsGrouping
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_InsertThousandsGrouping DD 098401H
	DD	010d484H
	DD	0e0128216H
	DD	0700ec010H
	DD	0500c600dH
	DD	0300bH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_InsertThousandsGrouping
_TEXT	SEGMENT
unicode$ = 128
index$ = 136
n_buffer$ = 144
digits$ = 152
n_digits$ = 160
min_width$ = 168
grouping$ = 176
thousands_sep$ = 184
maxchar$ = 192
_PyUnicode_InsertThousandsGrouping PROC			; COMDAT

; 8949 : {

$LN46:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	41 54		 push	 r12
  00010	41 56		 push	 r14
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00016	4d 8b d1	 mov	 r10, r9
  00019	4d 8b d8	 mov	 r11, r8
  0001c	48 8b d9	 mov	 rbx, rcx

; 8950 :     unsigned int kind, thousands_sep_kind;
; 8951 :     char *data, *thousands_sep_data;
; 8952 :     Py_ssize_t thousands_sep_len;
; 8953 :     Py_ssize_t len;
; 8954 : 
; 8955 :     if (unicode != NULL) {

  0001f	48 85 c9	 test	 rcx, rcx
  00022	74 49		 je	 SHORT $LN20@PyUnicode_@32

; 8956 :         kind = PyUnicode_KIND(unicode);

  00024	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00027	8b f8		 mov	 edi, eax
  00029	c1 ef 02	 shr	 edi, 2
  0002c	83 e7 07	 and	 edi, 7

; 8957 :         data = (char *) PyUnicode_DATA(unicode) + index * kind;

  0002f	a8 20		 test	 al, 32			; 00000020H
  00031	74 28		 je	 SHORT $LN25@PyUnicode_@32
  00033	a8 40		 test	 al, 64			; 00000040H
  00035	74 12		 je	 SHORT $LN23@PyUnicode_@32
  00037	8b f7		 mov	 esi, edi
  00039	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  00040	48 0f af f2	 imul	 rsi, rdx
  00044	48 03 f0	 add	 rsi, rax

; 8958 :     }
; 8959 :     else {

  00047	eb 2b		 jmp	 SHORT $LN19@PyUnicode_@32
$LN23@PyUnicode_@32:

; 8957 :         data = (char *) PyUnicode_DATA(unicode) + index * kind;

  00049	8b f7		 mov	 esi, edi
  0004b	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  00052	48 0f af f2	 imul	 rsi, rdx
  00056	48 03 f0	 add	 rsi, rax

; 8958 :     }
; 8959 :     else {

  00059	eb 19		 jmp	 SHORT $LN19@PyUnicode_@32
$LN25@PyUnicode_@32:

; 8957 :         data = (char *) PyUnicode_DATA(unicode) + index * kind;

  0005b	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
  00062	8b f7		 mov	 esi, edi
  00064	48 0f af f2	 imul	 rsi, rdx
  00068	48 03 f0	 add	 rsi, rax

; 8958 :     }
; 8959 :     else {

  0006b	eb 07		 jmp	 SHORT $LN19@PyUnicode_@32
$LN20@PyUnicode_@32:

; 8960 :         kind = PyUnicode_1BYTE_KIND;

  0006d	bf 01 00 00 00	 mov	 edi, 1

; 8961 :         data = NULL;

  00072	33 f6		 xor	 esi, esi
$LN19@PyUnicode_@32:

; 8962 :     }
; 8963 :     thousands_sep_kind = PyUnicode_KIND(thousands_sep);

  00074	4c 8b a4 24 b8
	00 00 00	 mov	 r12, QWORD PTR thousands_sep$[rsp]
  0007c	4c 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r13
  00084	41 8b 44 24 70	 mov	 eax, DWORD PTR [r12+112]
  00089	8b e8		 mov	 ebp, eax
  0008b	c1 ed 02	 shr	 ebp, 2
  0008e	83 e5 07	 and	 ebp, 7

; 8964 :     thousands_sep_data = PyUnicode_DATA(thousands_sep);

  00091	a8 20		 test	 al, 32			; 00000020H
  00093	74 18		 je	 SHORT $LN29@PyUnicode_@32
  00095	a8 40		 test	 al, 64			; 00000040H
  00097	74 0a		 je	 SHORT $LN27@PyUnicode_@32
  00099	4d 8d ac 24 80
	00 00 00	 lea	 r13, QWORD PTR [r12+128]
  000a1	eb 12		 jmp	 SHORT $LN30@PyUnicode_@32
$LN27@PyUnicode_@32:
  000a3	4d 8d ac 24 a0
	00 00 00	 lea	 r13, QWORD PTR [r12+160]
  000ab	eb 08		 jmp	 SHORT $LN30@PyUnicode_@32
$LN29@PyUnicode_@32:
  000ad	4d 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR [r12+160]
$LN30@PyUnicode_@32:

; 8965 :     thousands_sep_len = PyUnicode_GET_LENGTH(thousands_sep);

  000b5	4d 8b 74 24 60	 mov	 r14, QWORD PTR [r12+96]

; 8966 :     if (unicode != NULL && thousands_sep_kind != kind) {

  000ba	48 85 c9	 test	 rcx, rcx
  000bd	74 49		 je	 SHORT $LN14@PyUnicode_@32
  000bf	3b ef		 cmp	 ebp, edi
  000c1	74 45		 je	 SHORT $LN14@PyUnicode_@32

; 8967 :         if (thousands_sep_kind < kind) {

  000c3	73 1b		 jae	 SHORT $LN17@PyUnicode_@32

; 8968 :             thousands_sep_data = _PyUnicode_AsKind(thousands_sep, kind);

  000c5	8b d7		 mov	 edx, edi
  000c7	49 8b cc	 mov	 rcx, r12
  000ca	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  000cf	4c 8b e8	 mov	 r13, rax

; 8969 :             if (!thousands_sep_data)

  000d2	48 85 c0	 test	 rax, rax
  000d5	75 21		 jne	 SHORT $LN43@PyUnicode_@32

; 8970 :                 return -1;

  000d7	48 83 c8 ff	 or	 rax, -1
  000db	e9 f7 01 00 00	 jmp	 $LN21@PyUnicode_@32
$LN17@PyUnicode_@32:

; 8971 :         }
; 8972 :         else {
; 8973 :             data = _PyUnicode_AsKind(unicode, thousands_sep_kind);

  000e0	8b d5		 mov	 edx, ebp
  000e2	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  000e7	48 8b f0	 mov	 rsi, rax

; 8974 :             if (!data)

  000ea	48 85 c0	 test	 rax, rax
  000ed	75 09		 jne	 SHORT $LN43@PyUnicode_@32

; 8975 :                 return -1;

  000ef	48 83 c8 ff	 or	 rax, -1
  000f3	e9 df 01 00 00	 jmp	 $LN21@PyUnicode_@32
$LN43@PyUnicode_@32:

; 8949 : {

  000f8	4c 8b 9c 24 90
	00 00 00	 mov	 r11, QWORD PTR n_buffer$[rsp]
  00100	4c 8b 94 24 98
	00 00 00	 mov	 r10, QWORD PTR digits$[rsp]
$LN14@PyUnicode_@32:

; 8976 :         }
; 8977 :     }
; 8978 : 
; 8979 :     switch (kind) {

  00108	8b c7		 mov	 eax, edi
  0010a	4c 89 7c 24 40	 mov	 QWORD PTR [rsp+64], r15
  0010f	ff c8		 dec	 eax
  00111	0f 84 96 00 00
	00		 je	 $LN11@PyUnicode_@32
  00117	ff c8		 dec	 eax
  00119	74 50		 je	 SHORT $LN8@PyUnicode_@32
  0011b	83 f8 02	 cmp	 eax, 2
  0011e	74 09		 je	 SHORT $LN7@PyUnicode_@32

; 9004 :     default:
; 9005 :         assert(0);
; 9006 :         return -1;

  00120	48 83 c8 ff	 or	 rax, -1
  00124	e9 a9 01 00 00	 jmp	 $LN44@PyUnicode_@32
$LN7@PyUnicode_@32:

; 8998 :     case PyUnicode_4BYTE_KIND:
; 8999 :         len = ucs4lib_InsertThousandsGrouping(
; 9000 :             (Py_UCS4 *) data, n_buffer, (Py_UCS4 *) digits, n_digits,
; 9001 :             min_width, grouping,
; 9002 :             (Py_UCS4 *) thousands_sep_data, thousands_sep_len);

  00129	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR grouping$[rsp]
  00131	4c 8b bc 24 a0
	00 00 00	 mov	 r15, QWORD PTR n_digits$[rsp]
  00139	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  0013e	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  00143	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00148	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR min_width$[rsp]
  00150	4d 8b cf	 mov	 r9, r15
  00153	4d 8b c2	 mov	 r8, r10
  00156	49 8b d3	 mov	 rdx, r11
  00159	48 8b ce	 mov	 rcx, rsi
  0015c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00161	e8 00 00 00 00	 call	 ucs4lib_InsertThousandsGrouping

; 9003 :         break;

  00166	e9 c9 00 00 00	 jmp	 $LN45@PyUnicode_@32
$LN8@PyUnicode_@32:

; 8991 :         break;
; 8992 :     case PyUnicode_2BYTE_KIND:
; 8993 :         len = ucs2lib_InsertThousandsGrouping(
; 8994 :             (Py_UCS2 *) data, n_buffer, (Py_UCS2 *) digits, n_digits,
; 8995 :             min_width, grouping,
; 8996 :             (Py_UCS2 *) thousands_sep_data, thousands_sep_len);

  0016b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR grouping$[rsp]
  00173	4c 8b bc 24 a0
	00 00 00	 mov	 r15, QWORD PTR n_digits$[rsp]
  0017b	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  00180	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  00185	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0018a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR min_width$[rsp]
  00192	4d 8b cf	 mov	 r9, r15
  00195	4d 8b c2	 mov	 r8, r10
  00198	49 8b d3	 mov	 rdx, r11
  0019b	48 8b ce	 mov	 rcx, rsi
  0019e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a3	e8 00 00 00 00	 call	 ucs2lib_InsertThousandsGrouping

; 8997 :         break;

  001a8	e9 87 00 00 00	 jmp	 $LN45@PyUnicode_@32
$LN11@PyUnicode_@32:

; 8980 :     case PyUnicode_1BYTE_KIND:
; 8981 :         if (unicode != NULL && PyUnicode_IS_ASCII(unicode))

  001ad	48 85 db	 test	 rbx, rbx
  001b0	74 45		 je	 SHORT $LN10@PyUnicode_@32
  001b2	f6 43 70 40	 test	 BYTE PTR [rbx+112], 64	; 00000040H
  001b6	74 3f		 je	 SHORT $LN10@PyUnicode_@32

; 8982 :             len = asciilib_InsertThousandsGrouping(
; 8983 :                 (Py_UCS1 *) data, n_buffer, (Py_UCS1 *) digits, n_digits,
; 8984 :                 min_width, grouping,
; 8985 :                 (Py_UCS1 *) thousands_sep_data, thousands_sep_len);

  001b8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR grouping$[rsp]
  001c0	4c 8b bc 24 a0
	00 00 00	 mov	 r15, QWORD PTR n_digits$[rsp]
  001c8	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  001cd	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  001d2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001d7	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR min_width$[rsp]
  001df	4d 8b cf	 mov	 r9, r15
  001e2	4d 8b c2	 mov	 r8, r10
  001e5	49 8b d3	 mov	 rdx, r11
  001e8	48 8b ce	 mov	 rcx, rsi
  001eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f0	e8 00 00 00 00	 call	 asciilib_InsertThousandsGrouping

; 8986 :         else

  001f5	eb 3d		 jmp	 SHORT $LN45@PyUnicode_@32
$LN10@PyUnicode_@32:

; 8987 :             len = ucs1lib_InsertThousandsGrouping(
; 8988 :                 (Py_UCS1*)data, n_buffer, (Py_UCS1*)digits, n_digits,
; 8989 :                 min_width, grouping,
; 8990 :                 (Py_UCS1 *) thousands_sep_data, thousands_sep_len);

  001f7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR grouping$[rsp]
  001ff	4c 8b bc 24 a0
	00 00 00	 mov	 r15, QWORD PTR n_digits$[rsp]
  00207	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  0020c	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  00211	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00216	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR min_width$[rsp]
  0021e	4d 8b cf	 mov	 r9, r15
  00221	4d 8b c2	 mov	 r8, r10
  00224	49 8b d3	 mov	 rdx, r11
  00227	48 8b ce	 mov	 rcx, rsi
  0022a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022f	e8 00 00 00 00	 call	 ucs1lib_InsertThousandsGrouping
$LN45@PyUnicode_@32:
  00234	4c 8b f0	 mov	 r14, rax

; 9007 :     }
; 9008 :     if (unicode != NULL && thousands_sep_kind != kind) {

  00237	48 85 db	 test	 rbx, rbx
  0023a	74 1e		 je	 SHORT $LN41@PyUnicode_@32
  0023c	3b ef		 cmp	 ebp, edi
  0023e	0f 84 8b 00 00
	00		 je	 $LN1@PyUnicode_@32

; 9009 :         if (thousands_sep_kind < kind)

  00244	73 0a		 jae	 SHORT $LN4@PyUnicode_@32

; 9010 :             PyMem_Free(thousands_sep_data);

  00246	49 8b cd	 mov	 rcx, r13
  00249	e8 00 00 00 00	 call	 PyMem_Free

; 9011 :         else

  0024e	eb 7f		 jmp	 SHORT $LN1@PyUnicode_@32
$LN4@PyUnicode_@32:

; 9012 :             PyMem_Free(data);

  00250	48 8b ce	 mov	 rcx, rsi
  00253	e8 00 00 00 00	 call	 PyMem_Free

; 9013 :     }
; 9014 :     if (unicode == NULL) {

  00258	eb 75		 jmp	 SHORT $LN1@PyUnicode_@32
$LN41@PyUnicode_@32:

; 9015 :         *maxchar = 127;

  0025a	4c 8b 94 24 c0
	00 00 00	 mov	 r10, QWORD PTR maxchar$[rsp]
  00262	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00267	41 89 0a	 mov	 DWORD PTR [r10], ecx

; 9016 :         if (len != n_digits) {

  0026a	4d 3b f7	 cmp	 r14, r15
  0026d	74 60		 je	 SHORT $LN1@PyUnicode_@32

; 9017 :             *maxchar = Py_MAX(*maxchar,
; 9018 :                                    PyUnicode_MAX_CHAR_VALUE(thousands_sep));

  0026f	41 8b 54 24 70	 mov	 edx, DWORD PTR [r12+112]
  00274	41 bb ff ff 00
	00		 mov	 r11d, 65535		; 0000ffffH
  0027a	44 8b ca	 mov	 r9d, edx
  0027d	41 c1 e9 06	 shr	 r9d, 6
  00281	41 83 e1 01	 and	 r9d, 1
  00285	75 22		 jne	 SHORT $LN39@PyUnicode_@32
  00287	44 8b c2	 mov	 r8d, edx
  0028a	41 c1 e8 02	 shr	 r8d, 2
  0028e	41 83 e0 07	 and	 r8d, 7
  00292	41 83 f8 01	 cmp	 r8d, 1
  00296	74 11		 je	 SHORT $LN39@PyUnicode_@32
  00298	41 83 f8 02	 cmp	 r8d, 2
  0029c	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH
  002a1	41 0f 44 c3	 cmove	 eax, r11d
  002a5	3b c1		 cmp	 eax, ecx
  002a7	72 23		 jb	 SHORT $LN36@PyUnicode_@32
$LN39@PyUnicode_@32:
  002a9	45 85 c9	 test	 r9d, r9d
  002ac	75 1e		 jne	 SHORT $LN36@PyUnicode_@32
  002ae	c1 ea 02	 shr	 edx, 2
  002b1	83 e2 07	 and	 edx, 7
  002b4	83 fa 01	 cmp	 edx, 1
  002b7	75 07		 jne	 SHORT $LN35@PyUnicode_@32
  002b9	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  002be	eb 0c		 jmp	 SHORT $LN36@PyUnicode_@32
$LN35@PyUnicode_@32:
  002c0	b9 ff ff 10 00	 mov	 ecx, 1114111		; 0010ffffH
  002c5	83 fa 02	 cmp	 edx, 2
  002c8	41 0f 44 cb	 cmove	 ecx, r11d
$LN36@PyUnicode_@32:
  002cc	41 89 0a	 mov	 DWORD PTR [r10], ecx
$LN1@PyUnicode_@32:

; 9019 :         }
; 9020 :     }
; 9021 :     return len;

  002cf	49 8b c6	 mov	 rax, r14
$LN44@PyUnicode_@32:
  002d2	4c 8b 7c 24 40	 mov	 r15, QWORD PTR [rsp+64]
$LN21@PyUnicode_@32:
  002d7	4c 8b ac 24 80
	00 00 00	 mov	 r13, QWORD PTR [rsp+128]

; 9022 : }

  002df	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002e3	41 5e		 pop	 r14
  002e5	41 5c		 pop	 r12
  002e7	5f		 pop	 rdi
  002e8	5e		 pop	 rsi
  002e9	5d		 pop	 rbp
  002ea	5b		 pop	 rbx
  002eb	c3		 ret	 0
_PyUnicode_InsertThousandsGrouping ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_Count
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_Count DD imagerel $LN47
	DD	imagerel $LN47+309
	DD	imagerel $unwind$PyUnicode_Count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyUnicode_Count DD imagerel $LN47+309
	DD	imagerel $LN47+587
	DD	imagerel $chain$3$PyUnicode_Count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyUnicode_Count DD imagerel $LN47+587
	DD	imagerel $LN47+613
	DD	imagerel $chain$4$PyUnicode_Count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyUnicode_Count DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+309
	DD	imagerel $unwind$PyUnicode_Count
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyUnicode_Count DD 020821H
	DD	010c408H
	DD	imagerel $LN47
	DD	imagerel $LN47+309
	DD	imagerel $unwind$PyUnicode_Count
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Count DD 0bc401H
	DD	0f64c4H
	DD	08e486H
	DD	0e5481H
	DD	0f007820bH
	DD	07003d005H
	DD	03002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_Count
_TEXT	SEGMENT
buf1$1$ = 48
str$ = 112
substr$ = 120
start$ = 128
end$ = 136
PyUnicode_Count PROC					; COMDAT

; 9045 : {

$LN47:
  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 55		 push	 r13
  00005	41 57		 push	 r15
  00007	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  0000b	4d 8b e9	 mov	 r13, r9
  0000e	4d 8b f8	 mov	 r15, r8
  00011	48 8b fa	 mov	 rdi, rdx

; 9046 :     Py_ssize_t result;
; 9047 :     PyObject* str_obj;
; 9048 :     PyObject* sub_obj;
; 9049 :     int kind1, kind2, kind;
; 9050 :     void *buf1 = NULL, *buf2 = NULL;
; 9051 :     Py_ssize_t len1, len2;
; 9052 : 
; 9053 :     str_obj = PyUnicode_FromObject(str);

  00014	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00019	48 8b d8	 mov	 rbx, rax

; 9054 :     if (!str_obj)

  0001c	48 85 c0	 test	 rax, rax

; 9055 :         return -1;

  0001f	74 46		 je	 SHORT $LN45@PyUnicode_@33

; 9056 :     sub_obj = PyUnicode_FromObject(substr);

  00021	48 8b cf	 mov	 rcx, rdi
  00024	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00029	48 8b f8	 mov	 rdi, rax

; 9057 :     if (!sub_obj) {

  0002c	48 85 c0	 test	 rax, rax

; 9058 :         Py_DECREF(str_obj);
; 9059 :         return -1;

  0002f	74 2e		 je	 SHORT $LN46@PyUnicode_@33

; 9060 :     }
; 9061 :     if (PyUnicode_READY(sub_obj) == -1 || PyUnicode_READY(str_obj) == -1) {

  00031	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  00035	75 0d		 jne	 SHORT $LN38@PyUnicode_@33
  00037	48 8b c8	 mov	 rcx, rax
  0003a	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0003f	83 f8 ff	 cmp	 eax, -1
  00042	74 13		 je	 SHORT $LN20@PyUnicode_@33
$LN38@PyUnicode_@33:
  00044	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00048	75 2c		 jne	 SHORT $LN39@PyUnicode_@33
  0004a	48 8b cb	 mov	 rcx, rbx
  0004d	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00052	83 f8 ff	 cmp	 eax, -1
  00055	75 1f		 jne	 SHORT $LN39@PyUnicode_@33
$LN20@PyUnicode_@33:

; 9062 :         Py_DECREF(sub_obj);

  00057	48 8b cf	 mov	 rcx, rdi
  0005a	e8 00 00 00 00	 call	 _Py_DecRef
$LN46@PyUnicode_@33:

; 9063 :         Py_DECREF(str_obj);

  0005f	48 8b cb	 mov	 rcx, rbx
  00062	e8 00 00 00 00	 call	 _Py_DecRef
$LN45@PyUnicode_@33:

; 9064 :         return -1;

  00067	48 83 c8 ff	 or	 rax, -1

; 9128 : }

  0006b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006f	41 5f		 pop	 r15
  00071	41 5d		 pop	 r13
  00073	5f		 pop	 rdi
  00074	5b		 pop	 rbx
  00075	c3		 ret	 0
$LN39@PyUnicode_@33:

; 9065 :     }
; 9066 : 
; 9067 :     kind1 = PyUnicode_KIND(str_obj);

  00076	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]

; 9068 :     kind2 = PyUnicode_KIND(sub_obj);

  00079	8b 4f 70	 mov	 ecx, DWORD PTR [rdi+112]
  0007c	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  00081	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14

; 9069 :     kind = kind1;

  00086	8b e8		 mov	 ebp, eax
  00088	44 8b f1	 mov	 r14d, ecx
  0008b	41 c1 ee 02	 shr	 r14d, 2
  0008f	c1 ed 02	 shr	 ebp, 2
  00092	41 83 e6 07	 and	 r14d, 7
  00096	83 e5 07	 and	 ebp, 7

; 9070 :     buf1 = PyUnicode_DATA(str_obj);

  00099	a8 20		 test	 al, 32			; 00000020H
  0009b	74 16		 je	 SHORT $LN32@PyUnicode_@33
  0009d	a8 40		 test	 al, 64			; 00000040H
  0009f	74 09		 je	 SHORT $LN30@PyUnicode_@33
  000a1	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  000a8	eb 10		 jmp	 SHORT $LN43@PyUnicode_@33
$LN30@PyUnicode_@33:
  000aa	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  000b1	eb 07		 jmp	 SHORT $LN43@PyUnicode_@33
$LN32@PyUnicode_@33:
  000b3	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN43@PyUnicode_@33:
  000ba	48 89 44 24 30	 mov	 QWORD PTR buf1$1$[rsp], rax
  000bf	48 89 74 24 78	 mov	 QWORD PTR [rsp+120], rsi

; 9071 :     buf2 = PyUnicode_DATA(sub_obj);

  000c4	f6 c1 20	 test	 cl, 32			; 00000020H
  000c7	74 17		 je	 SHORT $LN36@PyUnicode_@33
  000c9	f6 c1 40	 test	 cl, 64			; 00000040H
  000cc	74 09		 je	 SHORT $LN34@PyUnicode_@33
  000ce	48 8d b7 80 00
	00 00		 lea	 rsi, QWORD PTR [rdi+128]
  000d5	eb 10		 jmp	 SHORT $LN37@PyUnicode_@33
$LN34@PyUnicode_@33:
  000d7	48 8d b7 a0 00
	00 00		 lea	 rsi, QWORD PTR [rdi+160]
  000de	eb 07		 jmp	 SHORT $LN37@PyUnicode_@33
$LN36@PyUnicode_@33:
  000e0	48 8b b7 a0 00
	00 00		 mov	 rsi, QWORD PTR [rdi+160]
$LN37@PyUnicode_@33:

; 9072 :     if (kind2 != kind) {

  000e7	44 3b f5	 cmp	 r14d, ebp
  000ea	74 23		 je	 SHORT $LN19@PyUnicode_@33

; 9074 :             Py_DECREF(sub_obj);

  000ec	48 8b cf	 mov	 rcx, rdi

; 9073 :         if (kind2 > kind) {

  000ef	7e 14		 jle	 SHORT $LN18@PyUnicode_@33

; 9074 :             Py_DECREF(sub_obj);

  000f1	e8 00 00 00 00	 call	 _Py_DecRef

; 9075 :             Py_DECREF(str_obj);

  000f6	48 8b cb	 mov	 rcx, rbx
  000f9	e8 00 00 00 00	 call	 _Py_DecRef

; 9076 :             return 0;

  000fe	33 c0		 xor	 eax, eax
  00100	e9 46 01 00 00	 jmp	 $LN42@PyUnicode_@33
$LN18@PyUnicode_@33:

; 9077 :         }
; 9078 :         buf2 = _PyUnicode_AsKind(sub_obj, kind);

  00105	8b d5		 mov	 edx, ebp
  00107	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  0010c	48 8b f0	 mov	 rsi, rax
$LN19@PyUnicode_@33:

; 9079 :     }
; 9080 :     if (!buf2)

  0010f	48 85 f6	 test	 rsi, rsi
  00112	75 19		 jne	 SHORT $LN17@PyUnicode_@33

; 9122 :   onError:
; 9123 :     Py_DECREF(sub_obj);

  00114	48 8b cf	 mov	 rcx, rdi
$onError$135528:
  00117	e8 00 00 00 00	 call	 _Py_DecRef

; 9124 :     Py_DECREF(str_obj);

  0011c	48 8b cb	 mov	 rcx, rbx
  0011f	e8 00 00 00 00	 call	 _Py_DecRef

; 9125 :     if (kind2 != kind && buf2)
; 9126 :         PyMem_Free(buf2);
; 9127 :     return -1;

  00124	48 83 c8 ff	 or	 rax, -1
  00128	e9 1e 01 00 00	 jmp	 $LN42@PyUnicode_@33
$LN17@PyUnicode_@33:

; 9081 :         goto onError;
; 9082 :     len1 = PyUnicode_GET_LENGTH(str_obj);

  0012d	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]

; 9083 :     len2 = PyUnicode_GET_LENGTH(sub_obj);

  00131	4c 8b 4f 60	 mov	 r9, QWORD PTR [rdi+96]
  00135	4c 89 a4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r12

; 9084 : 
; 9085 :     ADJUST_INDICES(start, end, len1);

  0013d	45 33 e4	 xor	 r12d, r12d
  00140	4c 3b e8	 cmp	 r13, rax
  00143	7e 05		 jle	 SHORT $LN16@PyUnicode_@33
  00145	4c 8b e8	 mov	 r13, rax
  00148	eb 0c		 jmp	 SHORT $LN13@PyUnicode_@33
$LN16@PyUnicode_@33:
  0014a	4d 85 ed	 test	 r13, r13
  0014d	79 07		 jns	 SHORT $LN13@PyUnicode_@33
  0014f	4c 03 e8	 add	 r13, rax
  00152	4d 0f 48 ec	 cmovs	 r13, r12
$LN13@PyUnicode_@33:
  00156	4d 85 ff	 test	 r15, r15
  00159	79 07		 jns	 SHORT $LN11@PyUnicode_@33
  0015b	4c 03 f8	 add	 r15, rax
  0015e	4d 0f 48 fc	 cmovs	 r15, r12
$LN11@PyUnicode_@33:

; 9086 :     switch (kind) {

  00162	8b cd		 mov	 ecx, ebp
  00164	ff c9		 dec	 ecx
  00166	74 60		 je	 SHORT $LN8@PyUnicode_@33
  00168	ff c9		 dec	 ecx
  0016a	74 34		 je	 SHORT $LN5@PyUnicode_@33
  0016c	83 f9 02	 cmp	 ecx, 2
  0016f	0f 85 ae 00 00
	00		 jne	 $LN6@PyUnicode_@33

; 9105 :     case PyUnicode_4BYTE_KIND:
; 9106 :         result = ucs4lib_count(
; 9107 :             ((Py_UCS4*)buf1) + start, end - start,
; 9108 :             buf2, len2, PY_SSIZE_T_MAX
; 9109 :             );

  00175	48 8b 44 24 30	 mov	 rax, QWORD PTR buf1$1$[rsp]
  0017a	4d 2b ef	 sub	 r13, r15
  0017d	4c 8b c6	 mov	 r8, rsi
  00180	4a 8d 0c b8	 lea	 rcx, QWORD PTR [rax+r15*4]
  00184	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0018e	49 8b d5	 mov	 rdx, r13
  00191	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00196	e8 00 00 00 00	 call	 ucs4lib_count

; 9110 :         break;

  0019b	e9 80 00 00 00	 jmp	 $LN44@PyUnicode_@33
$LN5@PyUnicode_@33:

; 9098 :         break;
; 9099 :     case PyUnicode_2BYTE_KIND:
; 9100 :         result = ucs2lib_count(
; 9101 :             ((Py_UCS2*)buf1) + start, end - start,
; 9102 :             buf2, len2, PY_SSIZE_T_MAX
; 9103 :             );

  001a0	48 8b 44 24 30	 mov	 rax, QWORD PTR buf1$1$[rsp]
  001a5	4d 2b ef	 sub	 r13, r15
  001a8	4c 8b c6	 mov	 r8, rsi
  001ab	4a 8d 0c 78	 lea	 rcx, QWORD PTR [rax+r15*2]
  001af	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  001b9	49 8b d5	 mov	 rdx, r13
  001bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c1	e8 00 00 00 00	 call	 ucs2lib_count

; 9104 :         break;

  001c6	eb 58		 jmp	 SHORT $LN44@PyUnicode_@33
$LN8@PyUnicode_@33:

; 9087 :     case PyUnicode_1BYTE_KIND:
; 9088 :         if (PyUnicode_IS_ASCII(str_obj) && PyUnicode_IS_ASCII(sub_obj))

  001c8	f6 43 70 40	 test	 BYTE PTR [rbx+112], 64	; 00000040H
  001cc	74 2d		 je	 SHORT $LN7@PyUnicode_@33
  001ce	f6 47 70 40	 test	 BYTE PTR [rdi+112], 64	; 00000040H
  001d2	74 27		 je	 SHORT $LN7@PyUnicode_@33

; 9089 :             result = asciilib_count(
; 9090 :                 ((Py_UCS1*)buf1) + start, end - start,
; 9091 :                 buf2, len2, PY_SSIZE_T_MAX
; 9092 :                 );

  001d4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buf1$1$[rsp]
  001d9	4d 2b ef	 sub	 r13, r15
  001dc	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  001e6	49 03 cf	 add	 rcx, r15
  001e9	4c 8b c6	 mov	 r8, rsi
  001ec	49 8b d5	 mov	 rdx, r13
  001ef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f4	e8 00 00 00 00	 call	 asciilib_count

; 9093 :         else

  001f9	eb 25		 jmp	 SHORT $LN44@PyUnicode_@33
$LN7@PyUnicode_@33:

; 9094 :             result = ucs1lib_count(
; 9095 :                 ((Py_UCS1*)buf1) + start, end - start,
; 9096 :                 buf2, len2, PY_SSIZE_T_MAX
; 9097 :                 );

  001fb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buf1$1$[rsp]
  00200	4d 2b ef	 sub	 r13, r15
  00203	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0020d	49 03 cf	 add	 rcx, r15
  00210	4c 8b c6	 mov	 r8, rsi
  00213	49 8b d5	 mov	 rdx, r13
  00216	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0021b	e8 00 00 00 00	 call	 ucs1lib_count
$LN44@PyUnicode_@33:
  00220	4c 8b e0	 mov	 r12, rax
$LN6@PyUnicode_@33:

; 9111 :     default:
; 9112 :         assert(0); result = 0;
; 9113 :     }
; 9114 : 
; 9115 :     Py_DECREF(sub_obj);

  00223	48 8b cf	 mov	 rcx, rdi
  00226	e8 00 00 00 00	 call	 _Py_DecRef

; 9116 :     Py_DECREF(str_obj);

  0022b	48 8b cb	 mov	 rcx, rbx
  0022e	e8 00 00 00 00	 call	 _Py_DecRef

; 9117 : 
; 9118 :     if (kind2 != kind)

  00233	44 3b f5	 cmp	 r14d, ebp
  00236	74 08		 je	 SHORT $LN2@PyUnicode_@33

; 9119 :         PyMem_Free(buf2);

  00238	48 8b ce	 mov	 rcx, rsi
  0023b	e8 00 00 00 00	 call	 PyMem_Free
$LN2@PyUnicode_@33:

; 9120 : 
; 9121 :     return result;

  00240	49 8b c4	 mov	 rax, r12
  00243	4c 8b a4 24 80
	00 00 00	 mov	 r12, QWORD PTR [rsp+128]
$LN42@PyUnicode_@33:
  0024b	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00250	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00255	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]

; 9128 : }

  0025a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0025e	41 5f		 pop	 r15
  00260	41 5d		 pop	 r13
  00262	5f		 pop	 rdi
  00263	5b		 pop	 rbx
  00264	c3		 ret	 0
PyUnicode_Count ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_Find
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_Find DD imagerel $LN15
	DD	imagerel $LN15+55
	DD	imagerel $unwind$PyUnicode_Find
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyUnicode_Find DD imagerel $LN15+55
	DD	imagerel $LN15+186
	DD	imagerel $chain$0$PyUnicode_Find
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyUnicode_Find DD imagerel $LN15+186
	DD	imagerel $LN15+208
	DD	imagerel $chain$1$PyUnicode_Find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyUnicode_Find DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+55
	DD	imagerel $unwind$PyUnicode_Find
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyUnicode_Find DD 020521H
	DD	086405H
	DD	imagerel $LN15
	DD	imagerel $LN15+55
	DD	imagerel $unwind$PyUnicode_Find
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Find DD 081501H
	DD	0b7415H
	DD	0a5415H
	DD	093415H
	DD	0c0115215H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_Find
_TEXT	SEGMENT
str$ = 64
sub$ = 72
start$ = 80
end$ = 88
direction$ = 96
PyUnicode_Find PROC					; COMDAT

; 9136 : {

$LN15:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00015	49 8b e9	 mov	 rbp, r9
  00018	4d 8b e0	 mov	 r12, r8
  0001b	48 8b da	 mov	 rbx, rdx

; 9137 :     Py_ssize_t result;
; 9138 : 
; 9139 :     str = PyUnicode_FromObject(str);

  0001e	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00023	48 8b f8	 mov	 rdi, rax

; 9140 :     if (!str)

  00026	48 85 c0	 test	 rax, rax
  00029	75 09		 jne	 SHORT $LN4@PyUnicode_@34

; 9141 :         return -2;

  0002b	48 8d 47 fe	 lea	 rax, QWORD PTR [rdi-2]
  0002f	e9 86 00 00 00	 jmp	 $LN5@PyUnicode_@34
$LN4@PyUnicode_@34:

; 9142 :     sub = PyUnicode_FromObject(sub);

  00034	48 8b cb	 mov	 rcx, rbx
  00037	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0003c	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00041	48 8b f0	 mov	 rsi, rax

; 9143 :     if (!sub) {

  00044	48 85 c0	 test	 rax, rax

; 9144 :         Py_DECREF(str);
; 9145 :         return -2;

  00047	74 2e		 je	 SHORT $LN14@PyUnicode_@34

; 9146 :     }
; 9147 :     if (PyUnicode_READY(sub) == -1 || PyUnicode_READY(str) == -1) {

  00049	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  0004d	75 0d		 jne	 SHORT $LN11@PyUnicode_@34
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00057	83 f8 ff	 cmp	 eax, -1
  0005a	74 13		 je	 SHORT $LN1@PyUnicode_@34
$LN11@PyUnicode_@34:
  0005c	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  00060	75 26		 jne	 SHORT $LN12@PyUnicode_@34
  00062	48 8b cf	 mov	 rcx, rdi
  00065	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0006a	83 f8 ff	 cmp	 eax, -1
  0006d	75 19		 jne	 SHORT $LN12@PyUnicode_@34
$LN1@PyUnicode_@34:

; 9148 :         Py_DECREF(sub);

  0006f	48 8b ce	 mov	 rcx, rsi
  00072	e8 00 00 00 00	 call	 _Py_DecRef
$LN14@PyUnicode_@34:

; 9149 :         Py_DECREF(str);

  00077	48 8b cf	 mov	 rcx, rdi
  0007a	e8 00 00 00 00	 call	 _Py_DecRef

; 9150 :         return -2;

  0007f	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  00086	eb 2d		 jmp	 SHORT $LN13@PyUnicode_@34
$LN12@PyUnicode_@34:

; 9151 :     }
; 9152 : 
; 9153 :     result = any_find_slice(direction,
; 9154 :         str, sub, start, end
; 9155 :         );

  00088	8b 4c 24 60	 mov	 ecx, DWORD PTR direction$[rsp]
  0008c	4d 8b cc	 mov	 r9, r12
  0008f	4c 8b c6	 mov	 r8, rsi
  00092	48 8b d7	 mov	 rdx, rdi
  00095	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0009a	e8 00 00 00 00	 call	 any_find_slice

; 9156 : 
; 9157 :     Py_DECREF(str);

  0009f	48 8b cf	 mov	 rcx, rdi
  000a2	48 8b d8	 mov	 rbx, rax
  000a5	e8 00 00 00 00	 call	 _Py_DecRef

; 9158 :     Py_DECREF(sub);

  000aa	48 8b ce	 mov	 rcx, rsi
  000ad	e8 00 00 00 00	 call	 _Py_DecRef

; 9159 : 
; 9160 :     return result;

  000b2	48 8b c3	 mov	 rax, rbx
$LN13@PyUnicode_@34:
  000b5	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
$LN5@PyUnicode_@34:

; 9161 : }

  000ba	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000bf	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000c4	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000c9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cd	41 5c		 pop	 r12
  000cf	c3		 ret	 0
PyUnicode_Find ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_FindChar
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_FindChar DD imagerel $LN16
	DD	imagerel $LN16+208
	DD	imagerel $unwind$PyUnicode_FindChar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_FindChar DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_FindChar
_TEXT	SEGMENT
str$ = 64
ch$ = 72
start$ = 80
end$ = 88
direction$ = 96
PyUnicode_FindChar PROC					; COMDAT

; 9167 : {

$LN16:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 9168 :     int kind;
; 9169 :     Py_ssize_t result;
; 9170 :     if (PyUnicode_READY(str) == -1)

  00014	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00018	49 8b f1	 mov	 rsi, r9
  0001b	49 8b f8	 mov	 rdi, r8
  0001e	8b ea		 mov	 ebp, edx
  00020	48 8b d9	 mov	 rbx, rcx
  00023	75 0e		 jne	 SHORT $LN6@PyUnicode_@35
  00025	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0002a	83 f8 ff	 cmp	 eax, -1

; 9171 :         return -2;

  0002d	0f 84 81 00 00
	00		 je	 $LN15@PyUnicode_@35
$LN6@PyUnicode_@35:

; 9172 :     if (start < 0 || end < 0) {

  00033	48 85 ff	 test	 rdi, rdi
  00036	78 69		 js	 SHORT $LN4@PyUnicode_@35
  00038	48 85 f6	 test	 rsi, rsi
  0003b	78 64		 js	 SHORT $LN4@PyUnicode_@35

; 9175 :     }
; 9176 :     if (end > PyUnicode_GET_LENGTH(str))

  0003d	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  00041	48 3b f0	 cmp	 rsi, rax
  00044	48 0f 4f f0	 cmovg	 rsi, rax

; 9177 :         end = PyUnicode_GET_LENGTH(str);
; 9178 :     kind = PyUnicode_KIND(str);

  00048	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0004b	8b d0		 mov	 edx, eax
  0004d	c1 ea 02	 shr	 edx, 2
  00050	83 e2 07	 and	 edx, 7

; 9179 :     result = findchar(PyUnicode_1BYTE_DATA(str) + kind*start,
; 9180 :                       kind, end-start, ch, direction);

  00053	a8 20		 test	 al, 32			; 00000020H
  00055	74 13		 je	 SHORT $LN13@PyUnicode_@35
  00057	a8 40		 test	 al, 64			; 00000040H
  00059	74 06		 je	 SHORT $LN11@PyUnicode_@35
  0005b	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  0005f	eb 10		 jmp	 SHORT $LN14@PyUnicode_@35
$LN11@PyUnicode_@35:
  00061	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  00068	eb 07		 jmp	 SHORT $LN14@PyUnicode_@35
$LN13@PyUnicode_@35:
  0006a	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
$LN14@PyUnicode_@35:
  00071	8b 44 24 60	 mov	 eax, DWORD PTR direction$[rsp]
  00075	48 63 ca	 movsxd	 rcx, edx
  00078	48 2b f7	 sub	 rsi, rdi
  0007b	44 8b cd	 mov	 r9d, ebp
  0007e	4c 8b c6	 mov	 r8, rsi
  00081	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00085	48 0f af cf	 imul	 rcx, rdi
  00089	48 03 cb	 add	 rcx, rbx
  0008c	e8 00 00 00 00	 call	 findchar

; 9181 :     if (result == -1)

  00091	48 83 f8 ff	 cmp	 rax, -1
  00095	75 05		 jne	 SHORT $LN2@PyUnicode_@35

; 9182 :         return -1;

  00097	48 0b c0	 or	 rax, rax
  0009a	eb 1f		 jmp	 SHORT $LN1@PyUnicode_@35
$LN2@PyUnicode_@35:

; 9183 :     else
; 9184 :         return start + result;

  0009c	48 03 c7	 add	 rax, rdi
  0009f	eb 1a		 jmp	 SHORT $LN1@PyUnicode_@35
$LN4@PyUnicode_@35:

; 9173 :         PyErr_SetString(PyExc_IndexError, "string index out of range");

  000a1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@DOEPEGBG@string?5index?5out?5of?5range?$AA@
  000af	e8 00 00 00 00	 call	 PyErr_SetString
$LN15@PyUnicode_@35:

; 9174 :         return -2;

  000b4	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
$LN1@PyUnicode_@35:

; 9185 : }

  000bb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c0	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000c5	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000ca	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ce	5f		 pop	 rdi
  000cf	c3		 ret	 0
PyUnicode_FindChar ENDP
_TEXT	ENDS
EXTRN	memcmp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$tailmatch DD imagerel tailmatch
	DD	imagerel tailmatch+164
	DD	imagerel $unwind$tailmatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$tailmatch DD imagerel tailmatch+164
	DD	imagerel tailmatch+592
	DD	imagerel $chain$1$tailmatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$tailmatch DD imagerel tailmatch+592
	DD	imagerel tailmatch+610
	DD	imagerel $chain$2$tailmatch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$tailmatch DD 021H
	DD	imagerel tailmatch
	DD	imagerel tailmatch+164
	DD	imagerel $unwind$tailmatch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$tailmatch DD 020521H
	DD	08c405H
	DD	imagerel tailmatch
	DD	imagerel tailmatch+164
	DD	imagerel $unwind$tailmatch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tailmatch DD 086d01H
	DD	09d46dH
	DD	0a340cH
	DD	07008320cH
	DD	050066007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT tailmatch
_TEXT	SEGMENT
self$ = 64
substring$ = 72
start$ = 80
end$ = 88
direction$ = 96
tailmatch PROC						; COMDAT

; 9193 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 9194 :     int kind_self;
; 9195 :     int kind_sub;
; 9196 :     void *data_self;
; 9197 :     void *data_sub;
; 9198 :     Py_ssize_t offset;
; 9199 :     Py_ssize_t i;
; 9200 :     Py_ssize_t end_sub;
; 9201 : 
; 9202 :     if (PyUnicode_READY(self) == -1 ||
; 9203 :         PyUnicode_READY(substring) == -1)

  0000c	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00010	49 8b d9	 mov	 rbx, r9
  00013	49 8b f0	 mov	 rsi, r8
  00016	48 8b ea	 mov	 rbp, rdx
  00019	48 8b f9	 mov	 rdi, rcx
  0001c	75 0a		 jne	 SHORT $LN61@tailmatch
  0001e	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00023	83 f8 ff	 cmp	 eax, -1
  00026	74 13		 je	 SHORT $LN18@tailmatch
$LN61@tailmatch:
  00028	f6 45 70 80	 test	 BYTE PTR [rbp+112], 128	; 00000080H
  0002c	75 1c		 jne	 SHORT $LN62@tailmatch
  0002e	48 8b cd	 mov	 rcx, rbp
  00031	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00036	83 f8 ff	 cmp	 eax, -1
  00039	75 0f		 jne	 SHORT $LN62@tailmatch
$LN18@tailmatch:

; 9204 :         return 0;

  0003b	33 c0		 xor	 eax, eax

; 9253 : }

  0003d	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	5e		 pop	 rsi
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
$LN62@tailmatch:

; 9205 : 
; 9206 :     if (PyUnicode_GET_LENGTH(substring) == 0)

  0004a	4c 8b 4d 60	 mov	 r9, QWORD PTR [rbp+96]
  0004e	4d 85 c9	 test	 r9, r9
  00051	75 11		 jne	 SHORT $LN17@tailmatch

; 9207 :         return 1;

  00053	41 8d 41 01	 lea	 eax, QWORD PTR [r9+1]

; 9253 : }

  00057	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5f		 pop	 rdi
  00061	5e		 pop	 rsi
  00062	5d		 pop	 rbp
  00063	c3		 ret	 0
$LN17@tailmatch:

; 9208 : 
; 9209 :     ADJUST_INDICES(start, end, PyUnicode_GET_LENGTH(self));

  00064	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00068	4c 89 6c 24 48	 mov	 QWORD PTR [rsp+72], r13
  0006d	45 33 ed	 xor	 r13d, r13d
  00070	48 3b d8	 cmp	 rbx, rax
  00073	7e 05		 jle	 SHORT $LN16@tailmatch
  00075	48 8b d8	 mov	 rbx, rax
  00078	eb 0c		 jmp	 SHORT $LN13@tailmatch
$LN16@tailmatch:
  0007a	48 85 db	 test	 rbx, rbx
  0007d	79 07		 jns	 SHORT $LN13@tailmatch
  0007f	48 03 d8	 add	 rbx, rax
  00082	49 0f 48 dd	 cmovs	 rbx, r13
$LN13@tailmatch:
  00086	48 85 f6	 test	 rsi, rsi
  00089	79 07		 jns	 SHORT $LN11@tailmatch
  0008b	48 03 f0	 add	 rsi, rax
  0008e	49 0f 48 f5	 cmovs	 rsi, r13
$LN11@tailmatch:

; 9210 :     end -= PyUnicode_GET_LENGTH(substring);

  00092	49 2b d9	 sub	 rbx, r9

; 9211 :     if (end < start)

  00095	48 3b de	 cmp	 rbx, rsi
  00098	7d 07		 jge	 SHORT $LN10@tailmatch

; 9212 :         return 0;

  0009a	33 c0		 xor	 eax, eax
  0009c	e9 af 01 00 00	 jmp	 $LN63@tailmatch
$LN10@tailmatch:

; 9213 : 
; 9214 :     kind_self = PyUnicode_KIND(self);

  000a1	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  000a4	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12
  000a9	44 8b c0	 mov	 r8d, eax
  000ac	41 c1 e8 02	 shr	 r8d, 2
  000b0	41 83 e0 07	 and	 r8d, 7

; 9215 :     data_self = PyUnicode_DATA(self);

  000b4	a8 20		 test	 al, 32			; 00000020H
  000b6	74 13		 je	 SHORT $LN28@tailmatch
  000b8	a8 40		 test	 al, 64			; 00000040H
  000ba	74 06		 je	 SHORT $LN26@tailmatch
  000bc	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  000c0	eb 10		 jmp	 SHORT $LN29@tailmatch
$LN26@tailmatch:
  000c2	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  000c9	eb 07		 jmp	 SHORT $LN29@tailmatch
$LN28@tailmatch:
  000cb	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
$LN29@tailmatch:

; 9216 :     kind_sub = PyUnicode_KIND(substring);

  000d2	8b 45 70	 mov	 eax, DWORD PTR [rbp+112]
  000d5	8b d0		 mov	 edx, eax
  000d7	c1 ea 02	 shr	 edx, 2
  000da	83 e2 07	 and	 edx, 7

; 9217 :     data_sub = PyUnicode_DATA(substring);

  000dd	a8 20		 test	 al, 32			; 00000020H
  000df	74 16		 je	 SHORT $LN32@tailmatch
  000e1	a8 40		 test	 al, 64			; 00000040H
  000e3	74 09		 je	 SHORT $LN30@tailmatch
  000e5	4c 8d 95 80 00
	00 00		 lea	 r10, QWORD PTR [rbp+128]
  000ec	eb 10		 jmp	 SHORT $LN33@tailmatch
$LN30@tailmatch:
  000ee	4c 8d 95 a0 00
	00 00		 lea	 r10, QWORD PTR [rbp+160]
  000f5	eb 07		 jmp	 SHORT $LN33@tailmatch
$LN32@tailmatch:
  000f7	4c 8b 95 a0 00
	00 00		 mov	 r10, QWORD PTR [rbp+160]
$LN33@tailmatch:

; 9218 :     end_sub = PyUnicode_GET_LENGTH(substring) - 1;
; 9219 : 
; 9220 :     if (direction > 0)

  000fe	44 39 6c 24 60	 cmp	 DWORD PTR direction$[rsp], r13d
  00103	4d 8d 61 ff	 lea	 r12, QWORD PTR [r9-1]
  00107	48 0f 4f f3	 cmovg	 rsi, rbx

; 9221 :         offset = end;
; 9222 :     else
; 9223 :         offset = start;
; 9224 : 
; 9225 :     if (PyUnicode_READ(kind_self, data_self, offset) ==
; 9226 :         PyUnicode_READ(kind_sub, data_sub, 0) &&
; 9227 :         PyUnicode_READ(kind_self, data_self, offset + end_sub) ==
; 9228 :         PyUnicode_READ(kind_sub, data_sub, end_sub)) {

  0010b	41 83 f8 01	 cmp	 r8d, 1
  0010f	75 06		 jne	 SHORT $LN36@tailmatch
  00111	0f b6 0c 3e	 movzx	 ecx, BYTE PTR [rsi+rdi]
  00115	eb 0f		 jmp	 SHORT $LN35@tailmatch
$LN36@tailmatch:
  00117	41 83 f8 02	 cmp	 r8d, 2
  0011b	75 06		 jne	 SHORT $LN34@tailmatch
  0011d	0f b7 0c 77	 movzx	 ecx, WORD PTR [rdi+rsi*2]
  00121	eb 03		 jmp	 SHORT $LN35@tailmatch
$LN34@tailmatch:
  00123	8b 0c b7	 mov	 ecx, DWORD PTR [rdi+rsi*4]
$LN35@tailmatch:
  00126	83 fa 01	 cmp	 edx, 1
  00129	75 06		 jne	 SHORT $LN40@tailmatch
  0012b	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  0012f	eb 0e		 jmp	 SHORT $LN39@tailmatch
$LN40@tailmatch:
  00131	83 fa 02	 cmp	 edx, 2
  00134	75 06		 jne	 SHORT $LN38@tailmatch
  00136	41 0f b7 02	 movzx	 eax, WORD PTR [r10]
  0013a	eb 03		 jmp	 SHORT $LN39@tailmatch
$LN38@tailmatch:
  0013c	41 8b 02	 mov	 eax, DWORD PTR [r10]
$LN39@tailmatch:
  0013f	3b c8		 cmp	 ecx, eax
  00141	0f 85 02 01 00
	00		 jne	 $LN5@tailmatch
  00147	4a 8d 04 26	 lea	 rax, QWORD PTR [rsi+r12]
  0014b	41 83 f8 01	 cmp	 r8d, 1
  0014f	75 06		 jne	 SHORT $LN44@tailmatch
  00151	0f b6 0c 38	 movzx	 ecx, BYTE PTR [rax+rdi]
  00155	eb 0f		 jmp	 SHORT $LN43@tailmatch
$LN44@tailmatch:
  00157	41 83 f8 02	 cmp	 r8d, 2
  0015b	75 06		 jne	 SHORT $LN42@tailmatch
  0015d	0f b7 0c 47	 movzx	 ecx, WORD PTR [rdi+rax*2]
  00161	eb 03		 jmp	 SHORT $LN43@tailmatch
$LN42@tailmatch:
  00163	8b 0c 87	 mov	 ecx, DWORD PTR [rdi+rax*4]
$LN43@tailmatch:
  00166	83 fa 01	 cmp	 edx, 1
  00169	75 07		 jne	 SHORT $LN48@tailmatch
  0016b	43 0f b6 04 14	 movzx	 eax, BYTE PTR [r12+r10]
  00170	eb 10		 jmp	 SHORT $LN47@tailmatch
$LN48@tailmatch:
  00172	83 fa 02	 cmp	 edx, 2
  00175	75 07		 jne	 SHORT $LN46@tailmatch
  00177	43 0f b7 04 62	 movzx	 eax, WORD PTR [r10+r12*2]
  0017c	eb 04		 jmp	 SHORT $LN47@tailmatch
$LN46@tailmatch:
  0017e	43 8b 04 a2	 mov	 eax, DWORD PTR [r10+r12*4]
$LN47@tailmatch:
  00182	3b c8		 cmp	 ecx, eax
  00184	0f 85 bf 00 00
	00		 jne	 $LN5@tailmatch

; 9229 :         /* If both are of the same kind, memcmp is sufficient */
; 9230 :         if (kind_self == kind_sub) {

  0018a	44 3b c2	 cmp	 r8d, edx
  0018d	75 2e		 jne	 SHORT $LN6@tailmatch

; 9231 :             return ! memcmp((char *)data_self +
; 9232 :                                 (offset * PyUnicode_KIND(substring)),
; 9233 :                             data_sub,
; 9234 :                             PyUnicode_GET_LENGTH(substring) *
; 9235 :                                 PyUnicode_KIND(substring));

  0018f	8b 4d 70	 mov	 ecx, DWORD PTR [rbp+112]
  00192	49 8b d2	 mov	 rdx, r10
  00195	48 c1 e9 02	 shr	 rcx, 2
  00199	83 e1 07	 and	 ecx, 7
  0019c	44 8b c1	 mov	 r8d, ecx
  0019f	48 0f af ce	 imul	 rcx, rsi
  001a3	4d 0f af c1	 imul	 r8, r9
  001a7	48 03 cf	 add	 rcx, rdi
  001aa	e8 00 00 00 00	 call	 memcmp
  001af	85 c0		 test	 eax, eax
  001b1	41 0f 94 c5	 sete	 r13b
  001b5	41 8b c5	 mov	 eax, r13d
  001b8	e9 8e 00 00 00	 jmp	 $LN64@tailmatch
$LN6@tailmatch:

; 9236 :         }
; 9237 :         /* otherwise we have to compare each character by first accesing it */
; 9238 :         else {
; 9239 :             /* We do not need to compare 0 and len(substring)-1 because
; 9240 :                the if statement above ensured already that they are equal
; 9241 :                when we end up here. */
; 9242 :             /* TODO: honor direction and do a forward or backwards search */
; 9243 :             for (i = 1; i < end_sub; ++i) {

  001bd	b9 01 00 00 00	 mov	 ecx, 1

; 9244 :                 if (PyUnicode_READ(kind_self, data_self, offset + i) !=
; 9245 :                     PyUnicode_READ(kind_sub, data_sub, i))

  001c2	4d 63 d8	 movsxd	 r11, r8d
  001c5	48 63 da	 movsxd	 rbx, edx
  001c8	49 3b cc	 cmp	 rcx, r12
  001cb	7d 75		 jge	 SHORT $LN2@tailmatch

; 9236 :         }
; 9237 :         /* otherwise we have to compare each character by first accesing it */
; 9238 :         else {
; 9239 :             /* We do not need to compare 0 and len(substring)-1 because
; 9240 :                the if statement above ensured already that they are equal
; 9241 :                when we end up here. */
; 9242 :             /* TODO: honor direction and do a forward or backwards search */
; 9243 :             for (i = 1; i < end_sub; ++i) {

  001cd	48 8d 2c 36	 lea	 rbp, QWORD PTR [rsi+rsi]
  001d1	4c 8d 2c b5 00
	00 00 00	 lea	 r13, QWORD PTR [rsi*4]
  001d9	4d 8d 42 04	 lea	 r8, QWORD PTR [r10+4]
  001dd	49 2b ea	 sub	 rbp, r10
  001e0	4d 2b ea	 sub	 r13, r10
  001e3	4d 8d 4a 02	 lea	 r9, QWORD PTR [r10+2]
  001e7	48 03 ef	 add	 rbp, rdi
  001ea	4c 03 ef	 add	 r13, rdi
  001ed	0f 1f 00	 npad	 3
$LL4@tailmatch:

; 9244 :                 if (PyUnicode_READ(kind_self, data_self, offset + i) !=
; 9245 :                     PyUnicode_READ(kind_sub, data_sub, i))

  001f0	49 83 fb 01	 cmp	 r11, 1
  001f4	75 0a		 jne	 SHORT $LN52@tailmatch
  001f6	48 8d 04 31	 lea	 rax, QWORD PTR [rcx+rsi]
  001fa	0f b6 14 38	 movzx	 edx, BYTE PTR [rax+rdi]
  001fe	eb 12		 jmp	 SHORT $LN51@tailmatch
$LN52@tailmatch:
  00200	49 83 fb 02	 cmp	 r11, 2
  00204	75 07		 jne	 SHORT $LN50@tailmatch
  00206	41 0f b7 14 29	 movzx	 edx, WORD PTR [r9+rbp]
  0020b	eb 05		 jmp	 SHORT $LN51@tailmatch
$LN50@tailmatch:
  0020d	43 8b 54 05 00	 mov	 edx, DWORD PTR [r13+r8]
$LN51@tailmatch:
  00212	48 83 fb 01	 cmp	 rbx, 1
  00216	75 07		 jne	 SHORT $LN56@tailmatch
  00218	42 0f b6 04 11	 movzx	 eax, BYTE PTR [rcx+r10]
  0021d	eb 0f		 jmp	 SHORT $LN55@tailmatch
$LN56@tailmatch:
  0021f	48 83 fb 02	 cmp	 rbx, 2
  00223	75 06		 jne	 SHORT $LN54@tailmatch
  00225	41 0f b7 01	 movzx	 eax, WORD PTR [r9]
  00229	eb 03		 jmp	 SHORT $LN55@tailmatch
$LN54@tailmatch:
  0022b	41 8b 00	 mov	 eax, DWORD PTR [r8]
$LN55@tailmatch:
  0022e	3b d0		 cmp	 edx, eax
  00230	75 17		 jne	 SHORT $LN5@tailmatch

; 9236 :         }
; 9237 :         /* otherwise we have to compare each character by first accesing it */
; 9238 :         else {
; 9239 :             /* We do not need to compare 0 and len(substring)-1 because
; 9240 :                the if statement above ensured already that they are equal
; 9241 :                when we end up here. */
; 9242 :             /* TODO: honor direction and do a forward or backwards search */
; 9243 :             for (i = 1; i < end_sub; ++i) {

  00232	48 ff c1	 inc	 rcx
  00235	49 83 c1 02	 add	 r9, 2
  00239	49 83 c0 04	 add	 r8, 4
  0023d	49 3b cc	 cmp	 rcx, r12
  00240	7c ae		 jl	 SHORT $LL4@tailmatch
$LN2@tailmatch:

; 9246 :                     return 0;
; 9247 :             }
; 9248 :             return 1;

  00242	b8 01 00 00 00	 mov	 eax, 1
  00247	eb 02		 jmp	 SHORT $LN64@tailmatch
$LN5@tailmatch:

; 9249 :         }
; 9250 :     }
; 9251 : 
; 9252 :     return 0;

  00249	33 c0		 xor	 eax, eax
$LN64@tailmatch:
  0024b	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]
$LN63@tailmatch:
  00250	4c 8b 6c 24 48	 mov	 r13, QWORD PTR [rsp+72]

; 9253 : }

  00255	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0025a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0025e	5f		 pop	 rdi
  0025f	5e		 pop	 rsi
  00260	5d		 pop	 rbp
  00261	c3		 ret	 0
tailmatch ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_Tailmatch
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_Tailmatch DD imagerel $LN6
	DD	imagerel $LN6+52
	DD	imagerel $unwind$PyUnicode_Tailmatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyUnicode_Tailmatch DD imagerel $LN6+52
	DD	imagerel $LN6+133
	DD	imagerel $chain$0$PyUnicode_Tailmatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyUnicode_Tailmatch DD imagerel $LN6+133
	DD	imagerel $LN6+155
	DD	imagerel $chain$1$PyUnicode_Tailmatch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyUnicode_Tailmatch DD 021H
	DD	imagerel $LN6
	DD	imagerel $LN6+52
	DD	imagerel $unwind$PyUnicode_Tailmatch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyUnicode_Tailmatch DD 020521H
	DD	086405H
	DD	imagerel $LN6
	DD	imagerel $LN6+52
	DD	imagerel $unwind$PyUnicode_Tailmatch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Tailmatch DD 081501H
	DD	0b7415H
	DD	0a5415H
	DD	093415H
	DD	0c0115215H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_Tailmatch
_TEXT	SEGMENT
str$ = 64
substr$ = 72
start$ = 80
end$ = 88
direction$ = 96
PyUnicode_Tailmatch PROC				; COMDAT

; 9261 : {

$LN6:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00015	49 8b e9	 mov	 rbp, r9
  00018	4d 8b e0	 mov	 r12, r8
  0001b	48 8b da	 mov	 rbx, rdx

; 9262 :     Py_ssize_t result;
; 9263 : 
; 9264 :     str = PyUnicode_FromObject(str);

  0001e	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00023	48 8b f8	 mov	 rdi, rax

; 9265 :     if (str == NULL)

  00026	48 85 c0	 test	 rax, rax
  00029	75 06		 jne	 SHORT $LN2@PyUnicode_@36

; 9266 :         return -1;

  0002b	48 83 c8 ff	 or	 rax, -1
  0002f	eb 54		 jmp	 SHORT $LN3@PyUnicode_@36
$LN2@PyUnicode_@36:

; 9267 :     substr = PyUnicode_FromObject(substr);

  00031	48 8b cb	 mov	 rcx, rbx
  00034	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00039	e8 00 00 00 00	 call	 PyUnicode_FromObject

; 9268 :     if (substr == NULL) {
; 9269 :         Py_DECREF(str);

  0003e	48 8b cf	 mov	 rcx, rdi
  00041	48 8b f0	 mov	 rsi, rax
  00044	48 85 c0	 test	 rax, rax
  00047	75 0b		 jne	 SHORT $LN1@PyUnicode_@36
  00049	e8 00 00 00 00	 call	 _Py_DecRef

; 9270 :         return -1;

  0004e	48 83 c8 ff	 or	 rax, -1
  00052	eb 2c		 jmp	 SHORT $LN5@PyUnicode_@36
$LN1@PyUnicode_@36:

; 9271 :     }
; 9272 : 
; 9273 :     result = tailmatch(str, substr,
; 9274 :                        start, end, direction);

  00054	8b 44 24 60	 mov	 eax, DWORD PTR direction$[rsp]
  00058	4c 8b cd	 mov	 r9, rbp
  0005b	4d 8b c4	 mov	 r8, r12
  0005e	48 8b d6	 mov	 rdx, rsi
  00061	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00065	e8 00 00 00 00	 call	 tailmatch

; 9275 :     Py_DECREF(str);

  0006a	48 8b cf	 mov	 rcx, rdi
  0006d	48 63 d8	 movsxd	 rbx, eax
  00070	e8 00 00 00 00	 call	 _Py_DecRef

; 9276 :     Py_DECREF(substr);

  00075	48 8b ce	 mov	 rcx, rsi
  00078	e8 00 00 00 00	 call	 _Py_DecRef

; 9277 :     return result;

  0007d	48 8b c3	 mov	 rax, rbx
$LN5@PyUnicode_@36:
  00080	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
$LN3@PyUnicode_@36:

; 9278 : }

  00085	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0008a	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0008f	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00094	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00098	41 5c		 pop	 r12
  0009a	c3		 ret	 0
PyUnicode_Tailmatch ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fixup DD	imagerel fixup
	DD	imagerel fixup+300
	DD	imagerel $unwind$fixup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fixup DD 0a3701H
	DD	0cc437H
	DD	0b6432H
	DD	0a542dH
	DD	0d0055209H
	DD	030027003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT fixup
_TEXT	SEGMENT
self$ = 80
fixfct$ = 88
fixup	PROC						; COMDAT

; 9286 : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 55		 push	 r13
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	4c 8b ea	 mov	 r13, rdx
  0000c	48 8b f9	 mov	 rdi, rcx

; 9287 :     PyObject *u;
; 9288 :     Py_UCS4 maxchar_old, maxchar_new = 0;
; 9289 :     PyObject *v;
; 9290 : 
; 9291 :     u = _PyUnicode_Copy(self);

  0000f	e8 00 00 00 00	 call	 _PyUnicode_Copy
  00014	48 8b d8	 mov	 rbx, rax

; 9292 :     if (u == NULL)

  00017	48 85 c0	 test	 rax, rax
  0001a	75 09		 jne	 SHORT $LN8@fixup

; 9341 : }

  0001c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00020	41 5d		 pop	 r13
  00022	5f		 pop	 rdi
  00023	5b		 pop	 rbx
  00024	c3		 ret	 0
$LN8@fixup:

; 9293 :         return NULL;
; 9294 :     maxchar_old = PyUnicode_MAX_CHAR_VALUE(u);

  00025	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00028	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0002d	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  00032	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  00037	be 7f 00 00 00	 mov	 esi, 127		; 0000007fH
  0003c	bd ff ff 00 00	 mov	 ebp, 65535		; 0000ffffH
  00041	a8 40		 test	 al, 64			; 00000040H
  00043	74 05		 je	 SHORT $LN13@fixup
  00045	44 8b e6	 mov	 r12d, esi
  00048	eb 20		 jmp	 SHORT $LN12@fixup
$LN13@fixup:
  0004a	c1 e8 02	 shr	 eax, 2
  0004d	83 e0 07	 and	 eax, 7
  00050	83 f8 01	 cmp	 eax, 1
  00053	75 08		 jne	 SHORT $LN11@fixup
  00055	41 bc ff 00 00
	00		 mov	 r12d, 255		; 000000ffH
  0005b	eb 0d		 jmp	 SHORT $LN12@fixup
$LN11@fixup:
  0005d	41 bc ff ff 10
	00		 mov	 r12d, 1114111		; 0010ffffH
  00063	83 f8 02	 cmp	 eax, 2
  00066	44 0f 44 e5	 cmove	 r12d, ebp
$LN12@fixup:

; 9295 : 
; 9296 :     /* fix functions return the new maximum character in a string,
; 9297 :        if the kind of the resulting unicode object does not change,
; 9298 :        everything is fine.  Otherwise we need to change the string kind
; 9299 :        and re-run the fix function. */
; 9300 :     maxchar_new = fixfct(u);

  0006a	48 8b cb	 mov	 rcx, rbx
  0006d	41 ff d5	 call	 r13

; 9301 : 
; 9302 :     if (maxchar_new == 0) {

  00070	85 c0		 test	 eax, eax
  00072	75 22		 jne	 SHORT $LN5@fixup

; 9303 :         /* no changes */;
; 9304 :         if (PyUnicode_CheckExact(self)) {

  00074	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  0007b	48 39 47 58	 cmp	 QWORD PTR [rdi+88], rax
  0007f	75 36		 jne	 SHORT $LN6@fixup

; 9305 :             Py_DECREF(u);

  00081	48 8b cb	 mov	 rcx, rbx
  00084	e8 00 00 00 00	 call	 _Py_DecRef

; 9306 :             Py_INCREF(self);

  00089	48 8b cf	 mov	 rcx, rdi
  0008c	e8 00 00 00 00	 call	 _Py_IncRef

; 9307 :             return self;

  00091	48 8b c7	 mov	 rax, rdi
  00094	eb 7e		 jmp	 SHORT $LN25@fixup
$LN5@fixup:

; 9308 :         }
; 9309 :         else
; 9310 :             return u;
; 9311 :     }
; 9312 : 
; 9313 :     maxchar_new = align_maxchar(maxchar_new);

  00096	3b c6		 cmp	 eax, esi
  00098	76 18		 jbe	 SHORT $LN16@fixup
  0009a	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0009f	77 07		 ja	 SHORT $LN18@fixup
  000a1	be ff 00 00 00	 mov	 esi, 255		; 000000ffH
  000a6	eb 0a		 jmp	 SHORT $LN16@fixup
$LN18@fixup:
  000a8	be ff ff 10 00	 mov	 esi, 1114111		; 0010ffffH
  000ad	3b c5		 cmp	 eax, ebp
  000af	0f 46 f5	 cmovbe	 esi, ebp
$LN16@fixup:

; 9314 : 
; 9315 :     if (maxchar_new == maxchar_old)

  000b2	41 3b f4	 cmp	 esi, r12d
  000b5	75 05		 jne	 SHORT $LN4@fixup
$LN6@fixup:

; 9316 :         return u;

  000b7	48 8b c3	 mov	 rax, rbx
  000ba	eb 58		 jmp	 SHORT $LN25@fixup
$LN4@fixup:

; 9317 : 
; 9318 :     /* In case the maximum character changed, we need to
; 9319 :        convert the string to the new category. */
; 9320 :     v = PyUnicode_New(PyUnicode_GET_LENGTH(self), maxchar_new);

  000bc	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  000c0	8b d6		 mov	 edx, esi
  000c2	e8 00 00 00 00	 call	 PyUnicode_New
  000c7	48 8b e8	 mov	 rbp, rax

; 9321 :     if (v == NULL) {

  000ca	48 85 c0	 test	 rax, rax
  000cd	75 0c		 jne	 SHORT $LN3@fixup

; 9322 :         Py_DECREF(u);

  000cf	48 8b cb	 mov	 rcx, rbx
  000d2	e8 00 00 00 00	 call	 _Py_DecRef

; 9323 :         return NULL;

  000d7	33 c0		 xor	 eax, eax
  000d9	eb 39		 jmp	 SHORT $LN25@fixup
$LN3@fixup:

; 9324 :     }
; 9325 :     if (maxchar_new > maxchar_old) {
; 9326 :         /* If the maxchar increased so that the kind changed, not all
; 9327 :            characters are representable anymore and we need to fix the
; 9328 :            string again. This only happens in very few cases. */
; 9329 :         _PyUnicode_FastCopyCharacters(v, 0,
; 9330 :                                       self, 0, PyUnicode_GET_LENGTH(self));

  000db	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  000df	45 33 c9	 xor	 r9d, r9d
  000e2	33 d2		 xor	 edx, edx
  000e4	48 8b cd	 mov	 rcx, rbp
  000e7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ec	41 3b f4	 cmp	 esi, r12d
  000ef	76 10		 jbe	 SHORT $LN2@fixup
  000f1	4c 8b c7	 mov	 r8, rdi
  000f4	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 9331 :         maxchar_old = fixfct(v);

  000f9	48 8b cd	 mov	 rcx, rbp
  000fc	41 ff d5	 call	 r13

; 9332 :         assert(maxchar_old > 0 && maxchar_old <= maxchar_new);
; 9333 :     }
; 9334 :     else {

  000ff	eb 08		 jmp	 SHORT $LN1@fixup
$LN2@fixup:

; 9335 :         _PyUnicode_FastCopyCharacters(v, 0,
; 9336 :                                       u, 0, PyUnicode_GET_LENGTH(self));

  00101	4c 8b c3	 mov	 r8, rbx
  00104	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters
$LN1@fixup:

; 9337 :     }
; 9338 :     Py_DECREF(u);

  00109	48 8b cb	 mov	 rcx, rbx
  0010c	e8 00 00 00 00	 call	 _Py_DecRef

; 9339 :     assert(_PyUnicode_CheckConsistency(v, 1));
; 9340 :     return v;

  00111	48 8b c5	 mov	 rax, rbp
$LN25@fixup:
  00114	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00119	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0011e	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]

; 9341 : }

  00123	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00127	41 5d		 pop	 r13
  00129	5f		 pop	 rdi
  0012a	5b		 pop	 rbx
  0012b	c3		 ret	 0
fixup	ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_upper:PROC
EXTRN	_Py_bytes_lower:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ascii_upper_or_lower DD imagerel ascii_upper_or_lower
	DD	imagerel ascii_upper_or_lower+165
	DD	imagerel $unwind$ascii_upper_or_lower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ascii_upper_or_lower DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ascii_upper_or_lower
_TEXT	SEGMENT
self$ = 48
lower$ = 56
ascii_upper_or_lower PROC				; COMDAT

; 9345 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 9346 :     Py_ssize_t len = PyUnicode_GET_LENGTH(self);
; 9347 :     char *resdata, *data = PyUnicode_DATA(self);

  00014	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00017	48 8b 71 60	 mov	 rsi, QWORD PTR [rcx+96]
  0001b	8b ea		 mov	 ebp, edx
  0001d	a8 20		 test	 al, 32			; 00000020H
  0001f	74 16		 je	 SHORT $LN8@ascii_uppe
  00021	a8 40		 test	 al, 64			; 00000040H
  00023	74 09		 je	 SHORT $LN6@ascii_uppe
  00025	48 8d b9 80 00
	00 00		 lea	 rdi, QWORD PTR [rcx+128]
  0002c	eb 10		 jmp	 SHORT $LN9@ascii_uppe
$LN6@ascii_uppe:
  0002e	48 8d b9 a0 00
	00 00		 lea	 rdi, QWORD PTR [rcx+160]
  00035	eb 07		 jmp	 SHORT $LN9@ascii_uppe
$LN8@ascii_uppe:
  00037	48 8b b9 a0 00
	00 00		 mov	 rdi, QWORD PTR [rcx+160]
$LN9@ascii_uppe:

; 9348 :     PyObject *res;
; 9349 : 
; 9350 :     res = PyUnicode_New(len, 127);

  0003e	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00043	48 8b ce	 mov	 rcx, rsi
  00046	e8 00 00 00 00	 call	 PyUnicode_New
  0004b	48 8b d8	 mov	 rbx, rax

; 9351 :     if (res == NULL)

  0004e	48 85 c0	 test	 rax, rax
  00051	74 3d		 je	 SHORT $LN4@ascii_uppe
$LN3@ascii_uppe:

; 9352 :         return NULL;
; 9353 :     resdata = PyUnicode_DATA(res);

  00053	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00056	a8 20		 test	 al, 32			; 00000020H
  00058	74 16		 je	 SHORT $LN12@ascii_uppe
  0005a	a8 40		 test	 al, 64			; 00000040H
  0005c	74 09		 je	 SHORT $LN10@ascii_uppe
  0005e	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  00065	eb 10		 jmp	 SHORT $LN13@ascii_uppe
$LN10@ascii_uppe:
  00067	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  0006e	eb 07		 jmp	 SHORT $LN13@ascii_uppe
$LN12@ascii_uppe:
  00070	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
$LN13@ascii_uppe:

; 9354 :     if (lower)
; 9355 :         _Py_bytes_lower(resdata, data, len);

  00077	4c 8b c6	 mov	 r8, rsi
  0007a	48 8b d7	 mov	 rdx, rdi
  0007d	85 ed		 test	 ebp, ebp
  0007f	74 07		 je	 SHORT $LN2@ascii_uppe
  00081	e8 00 00 00 00	 call	 _Py_bytes_lower

; 9356 :     else

  00086	eb 05		 jmp	 SHORT $LN1@ascii_uppe
$LN2@ascii_uppe:

; 9357 :         _Py_bytes_upper(resdata, data, len);

  00088	e8 00 00 00 00	 call	 _Py_bytes_upper
$LN1@ascii_uppe:

; 9358 :     return res;

  0008d	48 8b c3	 mov	 rax, rbx
$LN4@ascii_uppe:

; 9359 : }

  00090	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00095	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0009a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a3	5f		 pop	 rdi
  000a4	c3		 ret	 0
ascii_upper_or_lower ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_IsCased:PROC
EXTRN	_PyUnicode_IsCaseIgnorable:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$handle_capital_sigma DD imagerel handle_capital_sigma
	DD	imagerel handle_capital_sigma+217
	DD	imagerel $unwind$handle_capital_sigma
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$handle_capital_sigma DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0d0143218H
	DD	07010c012H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT handle_capital_sigma
_TEXT	SEGMENT
kind$ = 64
data$ = 72
length$ = 80
i$ = 88
handle_capital_sigma PROC				; COMDAT

; 9363 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 9364 :     Py_ssize_t j;
; 9365 :     int final_sigma;
; 9366 :     Py_UCS4 c;
; 9367 :     /* U+03A3 is in the Final_Sigma context when, it is found like this:
; 9368 : 
; 9369 :      \p{cased}\p{case-ignorable}*U+03A3!(\p{case-ignorable}*\p{cased})
; 9370 : 
; 9371 :     where ! is a negation and \p{xxx} is a character with property xxx.
; 9372 :     */
; 9373 :     for (j = i - 1; j >= 0; j--) {

  00018	49 8d 59 ff	 lea	 rbx, QWORD PTR [r9-1]
  0001c	4d 8b e9	 mov	 r13, r9
  0001f	4d 8b e0	 mov	 r12, r8
  00022	48 8b f2	 mov	 rsi, rdx
  00025	8b e9		 mov	 ebp, ecx
  00027	48 85 db	 test	 rbx, rbx
  0002a	78 2d		 js	 SHORT $LN16@handle_cap
  0002c	0f 1f 40 00	 npad	 4
$LL9@handle_cap:

; 9374 :         c = PyUnicode_READ(kind, data, j);

  00030	83 fd 01	 cmp	 ebp, 1
  00033	75 06		 jne	 SHORT $LN14@handle_cap
  00035	0f b6 3c 33	 movzx	 edi, BYTE PTR [rbx+rsi]
  00039	eb 0e		 jmp	 SHORT $LN13@handle_cap
$LN14@handle_cap:
  0003b	83 fd 02	 cmp	 ebp, 2
  0003e	75 06		 jne	 SHORT $LN12@handle_cap
  00040	0f b7 3c 5e	 movzx	 edi, WORD PTR [rsi+rbx*2]
  00044	eb 03		 jmp	 SHORT $LN13@handle_cap
$LN12@handle_cap:
  00046	8b 3c 9e	 mov	 edi, DWORD PTR [rsi+rbx*4]
$LN13@handle_cap:

; 9375 :         if (!_PyUnicode_IsCaseIgnorable(c))

  00049	8b cf		 mov	 ecx, edi
  0004b	e8 00 00 00 00	 call	 _PyUnicode_IsCaseIgnorable
  00050	85 c0		 test	 eax, eax
  00052	74 29		 je	 SHORT $LN26@handle_cap

; 9364 :     Py_ssize_t j;
; 9365 :     int final_sigma;
; 9366 :     Py_UCS4 c;
; 9367 :     /* U+03A3 is in the Final_Sigma context when, it is found like this:
; 9368 : 
; 9369 :      \p{cased}\p{case-ignorable}*U+03A3!(\p{case-ignorable}*\p{cased})
; 9370 : 
; 9371 :     where ! is a negation and \p{xxx} is a character with property xxx.
; 9372 :     */
; 9373 :     for (j = i - 1; j >= 0; j--) {

  00054	48 ff cb	 dec	 rbx
  00057	79 d7		 jns	 SHORT $LL9@handle_cap
$LN16@handle_cap:

; 9376 :             break;
; 9377 :     }
; 9378 :     final_sigma = j >= 0 && _PyUnicode_IsCased(c);

  00059	33 c0		 xor	 eax, eax
$LN23@handle_cap:

; 9386 :     }
; 9387 :     return (final_sigma) ? 0x3C2 : 0x3C3;
; 9388 : }

  0005b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00060	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00065	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0006a	f7 d8		 neg	 eax
  0006c	1b c0		 sbb	 eax, eax
  0006e	05 c3 03 00 00	 add	 eax, 963		; 000003c3H
  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	41 5d		 pop	 r13
  00079	41 5c		 pop	 r12
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
$LN26@handle_cap:

; 9376 :             break;
; 9377 :     }
; 9378 :     final_sigma = j >= 0 && _PyUnicode_IsCased(c);

  0007d	48 85 db	 test	 rbx, rbx
  00080	78 d7		 js	 SHORT $LN16@handle_cap
  00082	8b cf		 mov	 ecx, edi
  00084	e8 00 00 00 00	 call	 _PyUnicode_IsCased
  00089	85 c0		 test	 eax, eax
  0008b	74 cc		 je	 SHORT $LN16@handle_cap

; 9379 :     if (final_sigma) {
; 9380 :         for (j = i + 1; j < length; j++) {

  0008d	49 8d 5d 01	 lea	 rbx, QWORD PTR [r13+1]
  00091	49 3b dc	 cmp	 rbx, r12
  00094	7d 2f		 jge	 SHORT $LN32@handle_cap
$LL4@handle_cap:

; 9381 :             c = PyUnicode_READ(kind, data, j);

  00096	83 fd 01	 cmp	 ebp, 1
  00099	75 06		 jne	 SHORT $LN20@handle_cap
  0009b	0f b6 3c 33	 movzx	 edi, BYTE PTR [rbx+rsi]
  0009f	eb 0e		 jmp	 SHORT $LN19@handle_cap
$LN20@handle_cap:
  000a1	83 fd 02	 cmp	 ebp, 2
  000a4	75 06		 jne	 SHORT $LN18@handle_cap
  000a6	0f b7 3c 5e	 movzx	 edi, WORD PTR [rsi+rbx*2]
  000aa	eb 03		 jmp	 SHORT $LN19@handle_cap
$LN18@handle_cap:
  000ac	8b 3c 9e	 mov	 edi, DWORD PTR [rsi+rbx*4]
$LN19@handle_cap:

; 9382 :             if (!_PyUnicode_IsCaseIgnorable(c))

  000af	8b cf		 mov	 ecx, edi
  000b1	e8 00 00 00 00	 call	 _PyUnicode_IsCaseIgnorable
  000b6	85 c0		 test	 eax, eax
  000b8	74 08		 je	 SHORT $LN31@handle_cap

; 9379 :     if (final_sigma) {
; 9380 :         for (j = i + 1; j < length; j++) {

  000ba	48 ff c3	 inc	 rbx
  000bd	49 3b dc	 cmp	 rbx, r12
  000c0	7c d4		 jl	 SHORT $LL4@handle_cap
$LN31@handle_cap:

; 9383 :                 break;
; 9384 :         }
; 9385 :         final_sigma = j == length || !_PyUnicode_IsCased(c);

  000c2	49 3b dc	 cmp	 rbx, r12
$LN32@handle_cap:
  000c5	74 0b		 je	 SHORT $LN22@handle_cap
  000c7	8b cf		 mov	 ecx, edi
  000c9	e8 00 00 00 00	 call	 _PyUnicode_IsCased
  000ce	85 c0		 test	 eax, eax
  000d0	75 87		 jne	 SHORT $LN16@handle_cap
$LN22@handle_cap:
  000d2	b8 01 00 00 00	 mov	 eax, 1
  000d7	eb 82		 jmp	 SHORT $LN23@handle_cap
handle_capital_sigma ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_ToLowerFull:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$lower_ucs4 DD imagerel lower_ucs4
	DD	imagerel lower_ucs4+56
	DD	imagerel $unwind$lower_ucs4
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lower_ucs4 DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT lower_ucs4
_TEXT	SEGMENT
kind$ = 48
data$ = 56
length$ = 64
i$ = 72
c$ = 80
mapped$ = 88
lower_ucs4 PROC						; COMDAT

; 9393 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	8b c1		 mov	 eax, ecx

; 9394 :     /* Obscure special case. */
; 9395 :     if (c == 0x3A3) {

  00006	8b 4c 24 50	 mov	 ecx, DWORD PTR c$[rsp]
  0000a	81 f9 a3 03 00
	00		 cmp	 ecx, 931		; 000003a3H
  00010	75 18		 jne	 SHORT $LN1@lower_ucs4

; 9396 :         mapped[0] = handle_capital_sigma(kind, data, length, i);

  00012	8b c8		 mov	 ecx, eax
  00014	e8 00 00 00 00	 call	 handle_capital_sigma
  00019	48 8b 4c 24 58	 mov	 rcx, QWORD PTR mapped$[rsp]
  0001e	89 01		 mov	 DWORD PTR [rcx], eax

; 9397 :         return 1;

  00020	b8 01 00 00 00	 mov	 eax, 1

; 9400 : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
$LN1@lower_ucs4:

; 9398 :     }
; 9399 :     return _PyUnicode_ToLowerFull(c, mapped);

  0002a	48 8b 54 24 58	 mov	 rdx, QWORD PTR mapped$[rsp]

; 9400 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	e9 00 00 00 00	 jmp	 _PyUnicode_ToLowerFull
lower_ucs4 ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_ToUpperFull:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_capitalize DD imagerel do_capitalize
	DD	imagerel do_capitalize+298
	DD	imagerel $unwind$do_capitalize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_capitalize DD 0c1e01H
	DD	0f741eH
	DD	0e641eH
	DD	0d541eH
	DD	0c341eH
	DD	0e01a721eH
	DD	0c016d018H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT do_capitalize
_TEXT	SEGMENT
mapped$ = 48
kind$ = 96
data$ = 104
length$ = 112
res$ = 120
maxchar$ = 128
do_capitalize PROC					; COMDAT

; 9404 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 9405 :     Py_ssize_t i, k = 0;

  0001e	33 ff		 xor	 edi, edi
  00020	4d 8b e9	 mov	 r13, r9
  00023	4d 8b f0	 mov	 r14, r8
  00026	48 8b ea	 mov	 rbp, rdx
  00029	44 8b e1	 mov	 r12d, ecx

; 9406 :     int n_res, j;
; 9407 :     Py_UCS4 c, mapped[3];
; 9408 : 
; 9409 :     c = PyUnicode_READ(kind, data, 0);

  0002c	83 f9 01	 cmp	 ecx, 1
  0002f	75 05		 jne	 SHORT $LN14@do_capital
  00031	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
  00034	eb 0c		 jmp	 SHORT $LN13@do_capital
$LN14@do_capital:
  00036	83 f9 02	 cmp	 ecx, 2
  00039	75 05		 jne	 SHORT $LN12@do_capital
  0003b	0f b7 0a	 movzx	 ecx, WORD PTR [rdx]
  0003e	eb 02		 jmp	 SHORT $LN13@do_capital
$LN12@do_capital:
  00040	8b 0a		 mov	 ecx, DWORD PTR [rdx]
$LN13@do_capital:

; 9410 :     n_res = _PyUnicode_ToUpperFull(c, mapped);

  00042	48 8d 54 24 30	 lea	 rdx, QWORD PTR mapped$[rsp]
  00047	e8 00 00 00 00	 call	 _PyUnicode_ToUpperFull

; 9411 :     for (j = 0; j < n_res; j++) {

  0004c	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR maxchar$[rsp]
  00054	4c 63 c8	 movsxd	 r9, eax
  00057	85 c0		 test	 eax, eax
  00059	7e 31		 jle	 SHORT $LN7@do_capital
  0005b	4c 8d 54 24 30	 lea	 r10, QWORD PTR mapped$[rsp]
  00060	4d 8b c5	 mov	 r8, r13
  00063	49 8b f9	 mov	 rdi, r9
  00066	4d 2b d5	 sub	 r10, r13
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@do_capital:

; 9412 :         *maxchar = Py_MAX(*maxchar, mapped[j]);

  00070	8b 06		 mov	 eax, DWORD PTR [rsi]
  00072	43 8b 14 02	 mov	 edx, DWORD PTR [r10+r8]
  00076	3b c2		 cmp	 eax, edx
  00078	8b ca		 mov	 ecx, edx
  0007a	0f 47 c8	 cmova	 ecx, eax

; 9413 :         res[k++] = mapped[j];

  0007d	49 83 c0 04	 add	 r8, 4
  00081	49 ff c9	 dec	 r9
  00084	89 0e		 mov	 DWORD PTR [rsi], ecx
  00086	41 89 50 fc	 mov	 DWORD PTR [r8-4], edx
  0008a	75 e4		 jne	 SHORT $LL9@do_capital
$LN7@do_capital:

; 9414 :     }
; 9415 :     for (i = 1; i < length; i++) {

  0008c	bb 01 00 00 00	 mov	 ebx, 1
  00091	49 3b de	 cmp	 rbx, r14
  00094	7d 72		 jge	 SHORT $LN30@do_capital
$LL6@do_capital:

; 9416 :         c = PyUnicode_READ(kind, data, i);

  00096	41 83 fc 01	 cmp	 r12d, 1
  0009a	75 06		 jne	 SHORT $LN20@do_capital
  0009c	0f b6 04 2b	 movzx	 eax, BYTE PTR [rbx+rbp]
  000a0	eb 11		 jmp	 SHORT $LN19@do_capital
$LN20@do_capital:
  000a2	41 83 fc 02	 cmp	 r12d, 2
  000a6	75 07		 jne	 SHORT $LN18@do_capital
  000a8	0f b7 44 5d 00	 movzx	 eax, WORD PTR [rbp+rbx*2]
  000ad	eb 04		 jmp	 SHORT $LN19@do_capital
$LN18@do_capital:
  000af	8b 44 9d 00	 mov	 eax, DWORD PTR [rbp+rbx*4]
$LN19@do_capital:

; 9417 :         n_res = lower_ucs4(kind, data, length, i, c, mapped);

  000b3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR mapped$[rsp]
  000b8	4c 8b cb	 mov	 r9, rbx
  000bb	4d 8b c6	 mov	 r8, r14
  000be	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000c3	41 8b cc	 mov	 ecx, r12d
  000c6	48 8b d5	 mov	 rdx, rbp
  000c9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000cd	e8 00 00 00 00	 call	 lower_ucs4

; 9418 :         for (j = 0; j < n_res; j++) {

  000d2	45 33 c0	 xor	 r8d, r8d
  000d5	4c 63 c8	 movsxd	 r9, eax
  000d8	85 c0		 test	 eax, eax
  000da	7e 24		 jle	 SHORT $LN5@do_capital
  000dc	0f 1f 40 00	 npad	 4
$LL3@do_capital:

; 9419 :             *maxchar = Py_MAX(*maxchar, mapped[j]);

  000e0	8b 06		 mov	 eax, DWORD PTR [rsi]
  000e2	42 8b 54 84 30	 mov	 edx, DWORD PTR mapped$[rsp+r8*4]
  000e7	3b c2		 cmp	 eax, edx
  000e9	8b ca		 mov	 ecx, edx
  000eb	0f 47 c8	 cmova	 ecx, eax
  000ee	49 ff c0	 inc	 r8

; 9420 :             res[k++] = mapped[j];

  000f1	48 ff c7	 inc	 rdi
  000f4	89 0e		 mov	 DWORD PTR [rsi], ecx
  000f6	41 89 54 bd fc	 mov	 DWORD PTR [r13+rdi*4-4], edx
  000fb	4d 3b c1	 cmp	 r8, r9
  000fe	7c e0		 jl	 SHORT $LL3@do_capital
$LN5@do_capital:

; 9414 :     }
; 9415 :     for (i = 1; i < length; i++) {

  00100	48 ff c3	 inc	 rbx
  00103	49 3b de	 cmp	 rbx, r14
  00106	7c 8e		 jl	 SHORT $LL6@do_capital
$LN30@do_capital:

; 9421 :         }
; 9422 :     }
; 9423 :     return k;
; 9424 : }

  00108	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0010d	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00112	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  00117	48 8b c7	 mov	 rax, rdi
  0011a	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]
  0011f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00123	41 5e		 pop	 r14
  00125	41 5d		 pop	 r13
  00127	41 5c		 pop	 r12
  00129	c3		 ret	 0
do_capitalize ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_IsLowercase:PROC
EXTRN	_PyUnicode_IsUppercase:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_swapcase DD imagerel do_swapcase
	DD	imagerel do_swapcase+42
	DD	imagerel $unwind$do_swapcase
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$do_swapcase DD imagerel do_swapcase+42
	DD	imagerel do_swapcase+250
	DD	imagerel $chain$1$do_swapcase
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$do_swapcase DD imagerel do_swapcase+250
	DD	imagerel do_swapcase+274
	DD	imagerel $chain$2$do_swapcase
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$do_swapcase DD 021H
	DD	imagerel do_swapcase
	DD	imagerel do_swapcase+42
	DD	imagerel $unwind$do_swapcase
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$do_swapcase DD 040a21H
	DD	0fc40aH
	DD	0e3405H
	DD	imagerel do_swapcase
	DD	imagerel do_swapcase+42
	DD	imagerel $unwind$do_swapcase
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_swapcase DD 081101H
	DD	0105411H
	DD	0f00d7211H
	DD	0d009e00bH
	DD	060067007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT do_swapcase
_TEXT	SEGMENT
mapped$135978 = 48
kind$ = 112
data$ = 120
length$ = 128
res$ = 136
maxchar$ = 144
do_swapcase PROC					; COMDAT

; 9427 : do_swapcase(int kind, void *data, Py_ssize_t length, Py_UCS4 *res, Py_UCS4 *maxchar) {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 9428 :     Py_ssize_t i, k = 0;

  00011	33 f6		 xor	 esi, esi

; 9429 : 
; 9430 :     for (i = 0; i < length; i++) {

  00013	33 ff		 xor	 edi, edi
  00015	4d 8b f1	 mov	 r14, r9
  00018	4d 8b f8	 mov	 r15, r8
  0001b	48 8b ea	 mov	 rbp, rdx
  0001e	44 8b e9	 mov	 r13d, ecx
  00021	4d 85 c0	 test	 r8, r8
  00024	0f 8e d0 00 00
	00		 jle	 $LN23@do_swapcas
  0002a	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx
  0002f	4c 89 64 24 78	 mov	 QWORD PTR [rsp+120], r12
  00034	4c 8b a4 24 90
	00 00 00	 mov	 r12, QWORD PTR maxchar$[rsp]
  0003c	0f 1f 40 00	 npad	 4
$LL10@do_swapcas:

; 9431 :         Py_UCS4 c = PyUnicode_READ(kind, data, i), mapped[3];

  00040	41 83 fd 01	 cmp	 r13d, 1
  00044	75 06		 jne	 SHORT $LN15@do_swapcas
  00046	0f b6 1c 2f	 movzx	 ebx, BYTE PTR [rdi+rbp]
  0004a	eb 11		 jmp	 SHORT $LN14@do_swapcas
$LN15@do_swapcas:
  0004c	41 83 fd 02	 cmp	 r13d, 2
  00050	75 07		 jne	 SHORT $LN13@do_swapcas
  00052	0f b7 5c 7d 00	 movzx	 ebx, WORD PTR [rbp+rdi*2]
  00057	eb 04		 jmp	 SHORT $LN14@do_swapcas
$LN13@do_swapcas:
  00059	8b 5c bd 00	 mov	 ebx, DWORD PTR [rbp+rdi*4]
$LN14@do_swapcas:

; 9432 :         int n_res, j;
; 9433 :         if (Py_UNICODE_ISUPPER(c)) {

  0005d	8b cb		 mov	 ecx, ebx
  0005f	e8 00 00 00 00	 call	 _PyUnicode_IsUppercase
  00064	85 c0		 test	 eax, eax
  00066	74 21		 je	 SHORT $LN7@do_swapcas

; 9434 :             n_res = lower_ucs4(kind, data, length, i, c, mapped);

  00068	48 8d 44 24 30	 lea	 rax, QWORD PTR mapped$135978[rsp]
  0006d	4c 8b cf	 mov	 r9, rdi
  00070	4d 8b c7	 mov	 r8, r15
  00073	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00078	48 8b d5	 mov	 rdx, rbp
  0007b	41 8b cd	 mov	 ecx, r13d
  0007e	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  00082	e8 00 00 00 00	 call	 lower_ucs4
  00087	eb 22		 jmp	 SHORT $LN4@do_swapcas
$LN7@do_swapcas:

; 9435 :         }
; 9436 :         else if (Py_UNICODE_ISLOWER(c)) {

  00089	8b cb		 mov	 ecx, ebx
  0008b	e8 00 00 00 00	 call	 _PyUnicode_IsLowercase
  00090	85 c0		 test	 eax, eax
  00092	74 0e		 je	 SHORT $LN5@do_swapcas

; 9437 :             n_res = _PyUnicode_ToUpperFull(c, mapped);

  00094	48 8d 54 24 30	 lea	 rdx, QWORD PTR mapped$135978[rsp]
  00099	8b cb		 mov	 ecx, ebx
  0009b	e8 00 00 00 00	 call	 _PyUnicode_ToUpperFull

; 9438 :         }
; 9439 :         else {

  000a0	eb 09		 jmp	 SHORT $LN4@do_swapcas
$LN5@do_swapcas:

; 9440 :             n_res = 1;

  000a2	b8 01 00 00 00	 mov	 eax, 1

; 9441 :             mapped[0] = c;

  000a7	89 5c 24 30	 mov	 DWORD PTR mapped$135978[rsp], ebx
$LN4@do_swapcas:

; 9442 :         }
; 9443 :         for (j = 0; j < n_res; j++) {

  000ab	45 33 c0	 xor	 r8d, r8d
  000ae	4c 63 c8	 movsxd	 r9, eax
  000b1	85 c0		 test	 eax, eax
  000b3	7e 2f		 jle	 SHORT $LN9@do_swapcas
  000b5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL3@do_swapcas:

; 9444 :             *maxchar = Py_MAX(*maxchar, mapped[j]);

  000c0	41 8b 04 24	 mov	 eax, DWORD PTR [r12]
  000c4	42 8b 54 84 30	 mov	 edx, DWORD PTR mapped$135978[rsp+r8*4]
  000c9	3b c2		 cmp	 eax, edx
  000cb	8b ca		 mov	 ecx, edx
  000cd	0f 47 c8	 cmova	 ecx, eax
  000d0	49 ff c0	 inc	 r8

; 9445 :             res[k++] = mapped[j];

  000d3	48 ff c6	 inc	 rsi
  000d6	41 89 0c 24	 mov	 DWORD PTR [r12], ecx
  000da	41 89 54 b6 fc	 mov	 DWORD PTR [r14+rsi*4-4], edx
  000df	4d 3b c1	 cmp	 r8, r9
  000e2	7c dc		 jl	 SHORT $LL3@do_swapcas
$LN9@do_swapcas:

; 9429 : 
; 9430 :     for (i = 0; i < length; i++) {

  000e4	48 ff c7	 inc	 rdi
  000e7	49 3b ff	 cmp	 rdi, r15
  000ea	0f 8c 50 ff ff
	ff		 jl	 $LL10@do_swapcas
  000f0	4c 8b 64 24 78	 mov	 r12, QWORD PTR [rsp+120]
  000f5	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
$LN23@do_swapcas:

; 9446 :         }
; 9447 :     }
; 9448 :     return k;

  000fa	48 8b c6	 mov	 rax, rsi

; 9449 : }

  000fd	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]
  00105	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00109	41 5f		 pop	 r15
  0010b	41 5e		 pop	 r14
  0010d	41 5d		 pop	 r13
  0010f	5f		 pop	 rdi
  00110	5e		 pop	 rsi
  00111	c3		 ret	 0
do_swapcase ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_upper_or_lower DD imagerel do_upper_or_lower
	DD	imagerel do_upper_or_lower+42
	DD	imagerel $unwind$do_upper_or_lower
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$do_upper_or_lower DD imagerel do_upper_or_lower+42
	DD	imagerel do_upper_or_lower+216
	DD	imagerel $chain$1$do_upper_or_lower
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$do_upper_or_lower DD imagerel do_upper_or_lower+216
	DD	imagerel do_upper_or_lower+240
	DD	imagerel $chain$2$do_upper_or_lower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$do_upper_or_lower DD 021H
	DD	imagerel do_upper_or_lower
	DD	imagerel do_upper_or_lower+42
	DD	imagerel $unwind$do_upper_or_lower
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$do_upper_or_lower DD 041221H
	DD	0ff412H
	DD	0e5405H
	DD	imagerel do_upper_or_lower
	DD	imagerel do_upper_or_lower+42
	DD	imagerel $unwind$do_upper_or_lower
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_upper_or_lower DD 081101H
	DD	0103411H
	DD	0e00d7211H
	DD	0c009d00bH
	DD	060067007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT do_upper_or_lower
_TEXT	SEGMENT
mapped$136012 = 48
kind$ = 112
data$ = 120
length$ = 128
res$ = 136
maxchar$ = 144
lower$ = 152
do_upper_or_lower PROC					; COMDAT

; 9454 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 9455 :     Py_ssize_t i, k = 0;

  00011	33 ff		 xor	 edi, edi

; 9456 : 
; 9457 :     for (i = 0; i < length; i++) {

  00013	33 db		 xor	 ebx, ebx
  00015	4d 8b e9	 mov	 r13, r9
  00018	4d 8b f0	 mov	 r14, r8
  0001b	48 8b f2	 mov	 rsi, rdx
  0001e	44 8b e1	 mov	 r12d, ecx
  00021	4d 85 c0	 test	 r8, r8
  00024	0f 8e ae 00 00
	00		 jle	 $LN21@do_upper_o
  0002a	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  0002f	48 8b ac 24 90
	00 00 00	 mov	 rbp, QWORD PTR maxchar$[rsp]
  00037	4c 89 7c 24 78	 mov	 QWORD PTR [rsp+120], r15
  0003c	44 8b bc 24 98
	00 00 00	 mov	 r15d, DWORD PTR lower$[rsp]
$LL8@do_upper_o:

; 9458 :         Py_UCS4 c = PyUnicode_READ(kind, data, i), mapped[3];

  00044	41 83 fc 01	 cmp	 r12d, 1
  00048	75 06		 jne	 SHORT $LN13@do_upper_o
  0004a	0f b6 0c 33	 movzx	 ecx, BYTE PTR [rbx+rsi]
  0004e	eb 0f		 jmp	 SHORT $LN12@do_upper_o
$LN13@do_upper_o:
  00050	41 83 fc 02	 cmp	 r12d, 2
  00054	75 06		 jne	 SHORT $LN11@do_upper_o
  00056	0f b7 0c 5e	 movzx	 ecx, WORD PTR [rsi+rbx*2]
  0005a	eb 03		 jmp	 SHORT $LN12@do_upper_o
$LN11@do_upper_o:
  0005c	8b 0c 9e	 mov	 ecx, DWORD PTR [rsi+rbx*4]
$LN12@do_upper_o:

; 9459 :         int n_res, j;
; 9460 :         if (lower)

  0005f	45 85 ff	 test	 r15d, r15d
  00062	74 21		 je	 SHORT $LN5@do_upper_o

; 9461 :             n_res = lower_ucs4(kind, data, length, i, c, mapped);

  00064	48 8d 44 24 30	 lea	 rax, QWORD PTR mapped$136012[rsp]
  00069	4c 8b cb	 mov	 r9, rbx
  0006c	4d 8b c6	 mov	 r8, r14
  0006f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00074	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00078	41 8b cc	 mov	 ecx, r12d
  0007b	48 8b d6	 mov	 rdx, rsi
  0007e	e8 00 00 00 00	 call	 lower_ucs4

; 9462 :         else

  00083	eb 0a		 jmp	 SHORT $LN4@do_upper_o
$LN5@do_upper_o:

; 9463 :             n_res = _PyUnicode_ToUpperFull(c, mapped);

  00085	48 8d 54 24 30	 lea	 rdx, QWORD PTR mapped$136012[rsp]
  0008a	e8 00 00 00 00	 call	 _PyUnicode_ToUpperFull
$LN4@do_upper_o:

; 9464 :         for (j = 0; j < n_res; j++) {

  0008f	45 33 c0	 xor	 r8d, r8d
  00092	4c 63 c8	 movsxd	 r9, eax
  00095	85 c0		 test	 eax, eax
  00097	7e 29		 jle	 SHORT $LN7@do_upper_o
  00099	0f 1f 80 00 00
	00 00		 npad	 7
$LL3@do_upper_o:

; 9465 :             *maxchar = Py_MAX(*maxchar, mapped[j]);

  000a0	8b 45 00	 mov	 eax, DWORD PTR [rbp]
  000a3	42 8b 54 84 30	 mov	 edx, DWORD PTR mapped$136012[rsp+r8*4]
  000a8	3b c2		 cmp	 eax, edx
  000aa	8b ca		 mov	 ecx, edx
  000ac	0f 47 c8	 cmova	 ecx, eax
  000af	49 ff c0	 inc	 r8

; 9466 :             res[k++] = mapped[j];

  000b2	48 ff c7	 inc	 rdi
  000b5	89 4d 00	 mov	 DWORD PTR [rbp], ecx
  000b8	41 89 54 bd fc	 mov	 DWORD PTR [r13+rdi*4-4], edx
  000bd	4d 3b c1	 cmp	 r8, r9
  000c0	7c de		 jl	 SHORT $LL3@do_upper_o
$LN7@do_upper_o:

; 9456 : 
; 9457 :     for (i = 0; i < length; i++) {

  000c2	48 ff c3	 inc	 rbx
  000c5	49 3b de	 cmp	 rbx, r14
  000c8	0f 8c 76 ff ff
	ff		 jl	 $LL8@do_upper_o
  000ce	4c 8b 7c 24 78	 mov	 r15, QWORD PTR [rsp+120]
  000d3	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
$LN21@do_upper_o:

; 9467 :         }
; 9468 :     }
; 9469 :     return k;

  000d8	48 8b c7	 mov	 rax, rdi

; 9470 : }

  000db	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  000e3	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000e7	41 5e		 pop	 r14
  000e9	41 5d		 pop	 r13
  000eb	41 5c		 pop	 r12
  000ed	5f		 pop	 rdi
  000ee	5e		 pop	 rsi
  000ef	c3		 ret	 0
do_upper_or_lower ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_upper DD imagerel do_upper
	DD	imagerel do_upper+32
	DD	imagerel $unwind$do_upper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_upper DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT do_upper
_TEXT	SEGMENT
kind$ = 64
data$ = 72
length$ = 80
res$ = 88
maxchar$ = 96
do_upper PROC						; COMDAT

; 9474 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 9475 :     return do_upper_or_lower(kind, data, length, res, maxchar, 0);

  00004	48 8b 44 24 60	 mov	 rax, QWORD PTR maxchar$[rsp]
  00009	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00011	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00016	e8 00 00 00 00	 call	 do_upper_or_lower

; 9476 : }

  0001b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001f	c3		 ret	 0
do_upper ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_lower DD imagerel do_lower
	DD	imagerel do_lower+32
	DD	imagerel $unwind$do_lower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_lower DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT do_lower
_TEXT	SEGMENT
kind$ = 64
data$ = 72
length$ = 80
res$ = 88
maxchar$ = 96
do_lower PROC						; COMDAT

; 9480 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 9481 :     return do_upper_or_lower(kind, data, length, res, maxchar, 1);

  00004	48 8b 44 24 60	 mov	 rax, QWORD PTR maxchar$[rsp]
  00009	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  00011	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00016	e8 00 00 00 00	 call	 do_upper_or_lower

; 9482 : }

  0001b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001f	c3		 ret	 0
do_lower ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_ToFoldedFull:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_casefold DD imagerel do_casefold
	DD	imagerel do_casefold+44
	DD	imagerel $unwind$do_casefold
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$do_casefold DD imagerel do_casefold+44
	DD	imagerel do_casefold+161
	DD	imagerel $chain$0$do_casefold
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$do_casefold DD imagerel do_casefold+161
	DD	imagerel do_casefold+189
	DD	imagerel $chain$1$do_casefold
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$do_casefold DD 021H
	DD	imagerel do_casefold
	DD	imagerel do_casefold+44
	DD	imagerel $unwind$do_casefold
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$do_casefold DD 020521H
	DD	0ac405H
	DD	imagerel do_casefold
	DD	imagerel do_casefold+44
	DD	imagerel $unwind$do_casefold
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_casefold DD 0a1801H
	DD	0d6418H
	DD	0c5418H
	DD	0b3418H
	DD	0e0145218H
	DD	07010d012H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT do_casefold
_TEXT	SEGMENT
mapped$136066 = 32
kind$ = 80
data$ = 88
length$ = 96
res$ = 104
maxchar$ = 112
do_casefold PROC					; COMDAT

; 9486 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 55		 push	 r13
  00012	41 56		 push	 r14
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 9487 :     Py_ssize_t i, k = 0;

  00018	33 ff		 xor	 edi, edi

; 9488 : 
; 9489 :     for (i = 0; i < length; i++) {

  0001a	33 db		 xor	 ebx, ebx
  0001c	4d 8b e9	 mov	 r13, r9
  0001f	4d 8b f0	 mov	 r14, r8
  00022	48 8b f2	 mov	 rsi, rdx
  00025	8b e9		 mov	 ebp, ecx
  00027	4d 85 c0	 test	 r8, r8
  0002a	7e 75		 jle	 SHORT $LN19@do_casefol
  0002c	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  00031	4c 8b 64 24 70	 mov	 r12, QWORD PTR maxchar$[rsp]
$LL6@do_casefol:

; 9490 :         Py_UCS4 c = PyUnicode_READ(kind, data, i);

  00036	83 fd 01	 cmp	 ebp, 1
  00039	75 06		 jne	 SHORT $LN11@do_casefol
  0003b	0f b6 0c 33	 movzx	 ecx, BYTE PTR [rbx+rsi]
  0003f	eb 0e		 jmp	 SHORT $LN10@do_casefol
$LN11@do_casefol:
  00041	83 fd 02	 cmp	 ebp, 2
  00044	75 06		 jne	 SHORT $LN9@do_casefol
  00046	0f b7 0c 5e	 movzx	 ecx, WORD PTR [rsi+rbx*2]
  0004a	eb 03		 jmp	 SHORT $LN10@do_casefol
$LN9@do_casefol:
  0004c	8b 0c 9e	 mov	 ecx, DWORD PTR [rsi+rbx*4]
$LN10@do_casefol:

; 9491 :         Py_UCS4 mapped[3];
; 9492 :         int j, n_res = _PyUnicode_ToFoldedFull(c, mapped);

  0004f	48 8d 54 24 20	 lea	 rdx, QWORD PTR mapped$136066[rsp]
  00054	e8 00 00 00 00	 call	 _PyUnicode_ToFoldedFull

; 9493 :         for (j = 0; j < n_res; j++) {

  00059	45 33 c0	 xor	 r8d, r8d
  0005c	4c 63 c8	 movsxd	 r9, eax
  0005f	85 c0		 test	 eax, eax
  00061	7e 31		 jle	 SHORT $LN5@do_casefol
  00063	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL3@do_casefol:

; 9494 :             *maxchar = Py_MAX(*maxchar, mapped[j]);

  00070	41 8b 04 24	 mov	 eax, DWORD PTR [r12]
  00074	42 8b 54 84 20	 mov	 edx, DWORD PTR mapped$136066[rsp+r8*4]
  00079	3b c2		 cmp	 eax, edx
  0007b	8b ca		 mov	 ecx, edx
  0007d	0f 47 c8	 cmova	 ecx, eax
  00080	49 ff c0	 inc	 r8

; 9495 :             res[k++] = mapped[j];

  00083	48 ff c7	 inc	 rdi
  00086	41 89 0c 24	 mov	 DWORD PTR [r12], ecx
  0008a	41 89 54 bd fc	 mov	 DWORD PTR [r13+rdi*4-4], edx
  0008f	4d 3b c1	 cmp	 r8, r9
  00092	7c dc		 jl	 SHORT $LL3@do_casefol
$LN5@do_casefol:

; 9488 : 
; 9489 :     for (i = 0; i < length; i++) {

  00094	48 ff c3	 inc	 rbx
  00097	49 3b de	 cmp	 rbx, r14
  0009a	7c 9a		 jl	 SHORT $LL6@do_casefol
  0009c	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
$LN19@do_casefol:

; 9496 :         }
; 9497 :     }
; 9498 :     return k;
; 9499 : }

  000a1	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000a6	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  000ab	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  000b0	48 8b c7	 mov	 rax, rdi
  000b3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b7	41 5e		 pop	 r14
  000b9	41 5d		 pop	 r13
  000bb	5f		 pop	 rdi
  000bc	c3		 ret	 0
do_casefold ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_ToTitleFull:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_title DD imagerel do_title
	DD	imagerel do_title+44
	DD	imagerel $unwind$do_title
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$do_title DD imagerel do_title+44
	DD	imagerel do_title+230
	DD	imagerel $chain$1$do_title
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$do_title DD imagerel do_title+230
	DD	imagerel do_title+251
	DD	imagerel $chain$2$do_title
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$do_title DD 021H
	DD	imagerel do_title
	DD	imagerel do_title+44
	DD	imagerel $unwind$do_title
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$do_title DD 040a21H
	DD	0fd40aH
	DD	0e7405H
	DD	imagerel do_title
	DD	imagerel do_title+44
	DD	imagerel $unwind$do_title
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_title DD 081101H
	DD	0103411H
	DD	0f00d7211H
	DD	0c009e00bH
	DD	050066007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT do_title
_TEXT	SEGMENT
mapped$136095 = 48
kind$ = 112
data$ = 120
length$ = 128
res$ = 136
maxchar$ = 144
do_title PROC						; COMDAT

; 9503 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 54		 push	 r12
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 9504 :     Py_ssize_t i, k = 0;

  00011	33 f6		 xor	 esi, esi

; 9505 :     int previous_is_cased;
; 9506 : 
; 9507 :     previous_is_cased = 0;

  00013	33 c0		 xor	 eax, eax

; 9508 :     for (i = 0; i < length; i++) {

  00015	33 db		 xor	 ebx, ebx
  00017	4d 8b f1	 mov	 r14, r9
  0001a	4d 8b f8	 mov	 r15, r8
  0001d	48 8b ea	 mov	 rbp, rdx
  00020	44 8b e1	 mov	 r12d, ecx
  00023	4d 85 c0	 test	 r8, r8
  00026	0f 8e ba 00 00
	00		 jle	 $LN6@do_title
  0002c	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi
  00031	4c 89 6c 24 78	 mov	 QWORD PTR [rsp+120], r13
  00036	4c 8b ac 24 90
	00 00 00	 mov	 r13, QWORD PTR maxchar$[rsp]
  0003e	66 90		 npad	 2
$LL8@do_title:

; 9509 :         const Py_UCS4 c = PyUnicode_READ(kind, data, i);

  00040	41 83 fc 01	 cmp	 r12d, 1
  00044	75 06		 jne	 SHORT $LN13@do_title
  00046	0f b6 3c 2b	 movzx	 edi, BYTE PTR [rbx+rbp]
  0004a	eb 11		 jmp	 SHORT $LN12@do_title
$LN13@do_title:
  0004c	41 83 fc 02	 cmp	 r12d, 2
  00050	75 07		 jne	 SHORT $LN11@do_title
  00052	0f b7 7c 5d 00	 movzx	 edi, WORD PTR [rbp+rbx*2]
  00057	eb 04		 jmp	 SHORT $LN12@do_title
$LN11@do_title:
  00059	8b 7c 9d 00	 mov	 edi, DWORD PTR [rbp+rbx*4]
$LN12@do_title:

; 9510 :         Py_UCS4 mapped[3];
; 9511 :         int n_res, j;
; 9512 : 
; 9513 :         if (previous_is_cased)

  0005d	85 c0		 test	 eax, eax
  0005f	74 21		 je	 SHORT $LN5@do_title

; 9514 :             n_res = lower_ucs4(kind, data, length, i, c, mapped);

  00061	48 8d 44 24 30	 lea	 rax, QWORD PTR mapped$136095[rsp]
  00066	4c 8b cb	 mov	 r9, rbx
  00069	4d 8b c7	 mov	 r8, r15
  0006c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00071	48 8b d5	 mov	 rdx, rbp
  00074	41 8b cc	 mov	 ecx, r12d
  00077	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  0007b	e8 00 00 00 00	 call	 lower_ucs4

; 9515 :         else

  00080	eb 0c		 jmp	 SHORT $LN4@do_title
$LN5@do_title:

; 9516 :             n_res = _PyUnicode_ToTitleFull(c, mapped);

  00082	48 8d 54 24 30	 lea	 rdx, QWORD PTR mapped$136095[rsp]
  00087	8b cf		 mov	 ecx, edi
  00089	e8 00 00 00 00	 call	 _PyUnicode_ToTitleFull
$LN4@do_title:

; 9517 : 
; 9518 :         for (j = 0; j < n_res; j++) {

  0008e	45 33 c9	 xor	 r9d, r9d
  00091	48 63 c8	 movsxd	 rcx, eax
  00094	85 c0		 test	 eax, eax
  00096	7e 2e		 jle	 SHORT $LN1@do_title
  00098	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL3@do_title:

; 9519 :             *maxchar = Py_MAX(*maxchar, mapped[j]);

  000a0	41 8b 45 00	 mov	 eax, DWORD PTR [r13]
  000a4	46 8b 44 8c 30	 mov	 r8d, DWORD PTR mapped$136095[rsp+r9*4]
  000a9	41 3b c0	 cmp	 eax, r8d
  000ac	41 8b d0	 mov	 edx, r8d
  000af	0f 47 d0	 cmova	 edx, eax
  000b2	49 ff c1	 inc	 r9

; 9520 :             res[k++] = mapped[j];

  000b5	48 ff c6	 inc	 rsi
  000b8	41 89 55 00	 mov	 DWORD PTR [r13], edx
  000bc	45 89 44 b6 fc	 mov	 DWORD PTR [r14+rsi*4-4], r8d
  000c1	4c 3b c9	 cmp	 r9, rcx
  000c4	7c da		 jl	 SHORT $LL3@do_title
$LN1@do_title:

; 9521 :         }
; 9522 : 
; 9523 :         previous_is_cased = _PyUnicode_IsCased(c);

  000c6	8b cf		 mov	 ecx, edi
  000c8	e8 00 00 00 00	 call	 _PyUnicode_IsCased
  000cd	48 ff c3	 inc	 rbx
  000d0	49 3b df	 cmp	 rbx, r15
  000d3	0f 8c 67 ff ff
	ff		 jl	 $LL8@do_title

; 9524 :     }
; 9525 :     return k;

  000d9	4c 8b 6c 24 78	 mov	 r13, QWORD PTR [rsp+120]
  000de	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
  000e3	48 8b c6	 mov	 rax, rsi
$LN6@do_title:

; 9526 : }

  000e6	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  000ee	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000f2	41 5f		 pop	 r15
  000f4	41 5e		 pop	 r14
  000f6	41 5c		 pop	 r12
  000f8	5e		 pop	 rsi
  000f9	5d		 pop	 rbp
  000fa	c3		 ret	 0
do_title ENDP
_TEXT	ENDS
EXTRN	__imp_free:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_PxMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$case_operation DD imagerel case_operation
	DD	imagerel case_operation+555
	DD	imagerel $unwind$case_operation
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$case_operation DD 084d01H
	DD	0b344dH
	DD	0c540dH
	DD	0c009520dH
	DD	060067007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT case_operation
_TEXT	SEGMENT
maxchar$ = 80
self$ = 80
perform$ = 88
case_operation PROC					; COMDAT

; 9531 : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 9532 :     PyObject *res = NULL;
; 9533 :     Py_ssize_t length, newlength = 0;
; 9534 :     int kind, outkind;
; 9535 :     void *data, *outdata;
; 9536 :     Py_UCS4 maxchar = 0, *tmp, *tmpend;
; 9537 : 
; 9538 :     assert(PyUnicode_IS_READY(self));
; 9539 : 
; 9540 :     kind = PyUnicode_KIND(self);

  0000d	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00010	4c 8b e2	 mov	 r12, rdx
  00013	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR maxchar$[rsp], 0
  0001b	8b e8		 mov	 ebp, eax
  0001d	c1 ed 02	 shr	 ebp, 2
  00020	83 e5 07	 and	 ebp, 7

; 9541 :     data = PyUnicode_DATA(self);

  00023	a8 20		 test	 al, 32			; 00000020H
  00025	74 16		 je	 SHORT $LN27@case_opera
  00027	a8 40		 test	 al, 64			; 00000040H
  00029	74 09		 je	 SHORT $LN25@case_opera
  0002b	48 8d b1 80 00
	00 00		 lea	 rsi, QWORD PTR [rcx+128]
  00032	eb 10		 jmp	 SHORT $LN28@case_opera
$LN25@case_opera:
  00034	48 8d b1 a0 00
	00 00		 lea	 rsi, QWORD PTR [rcx+160]
  0003b	eb 07		 jmp	 SHORT $LN28@case_opera
$LN27@case_opera:
  0003d	48 8b b1 a0 00
	00 00		 mov	 rsi, QWORD PTR [rcx+160]
$LN28@case_opera:

; 9542 :     length = PyUnicode_GET_LENGTH(self);

  00044	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]
  00048	48 89 5c 24 58	 mov	 QWORD PTR [rsp+88], rbx

; 9543 :     tmp = PyMem_MALLOC(sizeof(Py_UCS4) * 3 * length);

  0004d	e8 00 00 00 00	 call	 _Py_PXCTX
  00052	85 c0		 test	 eax, eax
  00054	74 0f		 je	 SHORT $LN33@case_opera
  00056	48 8d 0c 7f	 lea	 rcx, QWORD PTR [rdi+rdi*2]
  0005a	48 c1 e1 02	 shl	 rcx, 2
  0005e	e8 00 00 00 00	 call	 _PxMem_Malloc
  00063	eb 2d		 jmp	 SHORT $LN50@case_opera
$LN33@case_opera:
  00065	48 8d 04 7f	 lea	 rax, QWORD PTR [rdi+rdi*2]
  00069	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00073	48 c1 e0 02	 shl	 rax, 2
  00077	48 3b c1	 cmp	 rax, rcx
  0007a	0f 87 93 01 00
	00		 ja	 $LN49@case_opera
  00080	48 85 c0	 test	 rax, rax
  00083	b9 01 00 00 00	 mov	 ecx, 1
  00088	48 0f 45 c8	 cmovne	 rcx, rax
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN50@case_opera:
  00092	48 8b d8	 mov	 rbx, rax

; 9544 :     if (tmp == NULL)

  00095	48 85 c0	 test	 rax, rax
  00098	0f 84 75 01 00
	00		 je	 $LN49@case_opera

; 9546 :     newlength = perform(kind, data, length, tmp, &maxchar);

  0009e	48 8d 44 24 50	 lea	 rax, QWORD PTR maxchar$[rsp]
  000a3	4c 8b cb	 mov	 r9, rbx
  000a6	4c 8b c7	 mov	 r8, rdi
  000a9	48 8b d6	 mov	 rdx, rsi
  000ac	8b cd		 mov	 ecx, ebp
  000ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b3	41 ff d4	 call	 r12

; 9547 :     res = PyUnicode_New(newlength, maxchar);

  000b6	8b 54 24 50	 mov	 edx, DWORD PTR maxchar$[rsp]
  000ba	48 8b c8	 mov	 rcx, rax
  000bd	48 8b f0	 mov	 rsi, rax
  000c0	e8 00 00 00 00	 call	 PyUnicode_New
  000c5	48 8b f8	 mov	 rdi, rax

; 9548 :     if (res == NULL)

  000c8	48 85 c0	 test	 rax, rax
  000cb	0f 84 21 01 00
	00		 je	 $leave$136160

; 9549 :         goto leave;
; 9550 :     tmpend = tmp + newlength;
; 9551 :     outdata = PyUnicode_DATA(res);

  000d1	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  000d4	4c 8d 0c b5 00
	00 00 00	 lea	 r9, QWORD PTR [rsi*4]
  000dc	4d 8d 04 19	 lea	 r8, QWORD PTR [r9+rbx]
  000e0	f6 c2 20	 test	 dl, 32			; 00000020H
  000e3	74 17		 je	 SHORT $LN37@case_opera
  000e5	f6 c2 40	 test	 dl, 64			; 00000040H
  000e8	74 09		 je	 SHORT $LN35@case_opera
  000ea	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  000f1	eb 10		 jmp	 SHORT $LN38@case_opera
$LN35@case_opera:
  000f3	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  000fa	eb 07		 jmp	 SHORT $LN38@case_opera
$LN37@case_opera:
  000fc	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
$LN38@case_opera:

; 9552 :     outkind = PyUnicode_KIND(res);
; 9553 :     switch (outkind) {

  00103	c1 ea 02	 shr	 edx, 2
  00106	83 e2 07	 and	 edx, 7
  00109	ff ca		 dec	 edx
  0010b	0f 84 86 00 00
	00		 je	 $LN17@case_opera
  00111	ff ca		 dec	 edx
  00113	74 19		 je	 SHORT $LN9@case_opera
  00115	83 fa 02	 cmp	 edx, 2
  00118	0f 85 d4 00 00
	00		 jne	 $leave$136160

; 9560 :     case PyUnicode_4BYTE_KIND:
; 9561 :         memcpy(outdata, tmp, sizeof(Py_UCS4) * newlength);

  0011e	4d 8b c1	 mov	 r8, r9
  00121	48 8b d3	 mov	 rdx, rbx
  00124	e8 00 00 00 00	 call	 memcpy

; 9562 :         break;

  00129	e9 c4 00 00 00	 jmp	 $leave$136160
$LN9@case_opera:

; 9556 :         break;
; 9557 :     case PyUnicode_2BYTE_KIND:
; 9558 :         _PyUnicode_CONVERT_BYTES(Py_UCS4, Py_UCS2, tmp, tmpend, outdata);

  0012e	49 8b c0	 mov	 rax, r8
  00131	48 8b d3	 mov	 rdx, rbx
  00134	48 2b c3	 sub	 rax, rbx
  00137	48 c1 f8 02	 sar	 rax, 2
  0013b	48 83 e0 fc	 and	 rax, -4
  0013f	4c 8d 0c 83	 lea	 r9, QWORD PTR [rbx+rax*4]
  00143	49 3b d9	 cmp	 rbx, r9
  00146	73 34		 jae	 SHORT $LN42@case_opera
  00148	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL6@case_opera:
  00150	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  00153	48 83 c2 10	 add	 rdx, 16
  00157	48 83 c1 08	 add	 rcx, 8
  0015b	66 89 41 f8	 mov	 WORD PTR [rcx-8], ax
  0015f	0f b7 42 f4	 movzx	 eax, WORD PTR [rdx-12]
  00163	66 89 41 fa	 mov	 WORD PTR [rcx-6], ax
  00167	0f b7 42 f8	 movzx	 eax, WORD PTR [rdx-8]
  0016b	66 89 41 fc	 mov	 WORD PTR [rcx-4], ax
  0016f	0f b7 42 fc	 movzx	 eax, WORD PTR [rdx-4]
  00173	66 89 41 fe	 mov	 WORD PTR [rcx-2], ax
  00177	49 3b d1	 cmp	 rdx, r9
  0017a	72 d4		 jb	 SHORT $LL6@case_opera
$LN42@case_opera:
  0017c	49 3b d0	 cmp	 rdx, r8
  0017f	73 71		 jae	 SHORT $leave$136160
$LL4@case_opera:
  00181	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  00184	48 83 c2 04	 add	 rdx, 4
  00188	48 83 c1 02	 add	 rcx, 2
  0018c	66 89 41 fe	 mov	 WORD PTR [rcx-2], ax
  00190	49 3b d0	 cmp	 rdx, r8
  00193	72 ec		 jb	 SHORT $LL4@case_opera

; 9559 :         break;

  00195	eb 5b		 jmp	 SHORT $leave$136160
$LN17@case_opera:

; 9554 :     case PyUnicode_1BYTE_KIND:
; 9555 :         _PyUnicode_CONVERT_BYTES(Py_UCS4, Py_UCS1, tmp, tmpend, outdata);

  00197	49 8b c0	 mov	 rax, r8
  0019a	48 8b d3	 mov	 rdx, rbx
  0019d	48 2b c3	 sub	 rax, rbx
  001a0	48 c1 f8 02	 sar	 rax, 2
  001a4	48 83 e0 fc	 and	 rax, -4
  001a8	4c 8d 0c 83	 lea	 r9, QWORD PTR [rbx+rax*4]
  001ac	49 3b d9	 cmp	 rbx, r9
  001af	73 28		 jae	 SHORT $LN44@case_opera
$LL14@case_opera:
  001b1	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  001b4	48 83 c2 10	 add	 rdx, 16
  001b8	48 83 c1 04	 add	 rcx, 4
  001bc	88 41 fc	 mov	 BYTE PTR [rcx-4], al
  001bf	0f b6 42 f4	 movzx	 eax, BYTE PTR [rdx-12]
  001c3	88 41 fd	 mov	 BYTE PTR [rcx-3], al
  001c6	0f b6 42 f8	 movzx	 eax, BYTE PTR [rdx-8]
  001ca	88 41 fe	 mov	 BYTE PTR [rcx-2], al
  001cd	0f b6 42 fc	 movzx	 eax, BYTE PTR [rdx-4]
  001d1	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  001d4	49 3b d1	 cmp	 rdx, r9
  001d7	72 d8		 jb	 SHORT $LL14@case_opera
$LN44@case_opera:
  001d9	49 3b d0	 cmp	 rdx, r8
  001dc	73 14		 jae	 SHORT $leave$136160
  001de	66 90		 npad	 2
$LL12@case_opera:
  001e0	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  001e3	48 83 c2 04	 add	 rdx, 4
  001e7	48 ff c1	 inc	 rcx
  001ea	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  001ed	49 3b d0	 cmp	 rdx, r8
  001f0	72 ee		 jb	 SHORT $LL12@case_opera
$leave$136160:

; 9563 :     default:
; 9564 :         assert(0);
; 9565 :         break;
; 9566 :     }
; 9567 :   leave:
; 9568 :     PyMem_FREE(tmp);

  001f2	e8 00 00 00 00	 call	 _Py_PXCTX
  001f7	48 8b cb	 mov	 rcx, rbx
  001fa	85 c0		 test	 eax, eax
  001fc	74 0a		 je	 SHORT $LN39@case_opera
  001fe	e8 00 00 00 00	 call	 _PxMem_Free

; 9569 :     return res;

  00203	48 8b c7	 mov	 rax, rdi
  00206	eb 10		 jmp	 SHORT $LN23@case_opera
$LN39@case_opera:

; 9563 :     default:
; 9564 :         assert(0);
; 9565 :         break;
; 9566 :     }
; 9567 :   leave:
; 9568 :     PyMem_FREE(tmp);

  00208	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 9569 :     return res;

  0020e	48 8b c7	 mov	 rax, rdi
  00211	eb 05		 jmp	 SHORT $LN23@case_opera
$LN49@case_opera:

; 9545 :         return PyErr_NoMemory();

  00213	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN23@case_opera:
  00218	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]

; 9570 : }

  0021d	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00222	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00226	41 5c		 pop	 r12
  00228	5f		 pop	 rdi
  00229	5e		 pop	 rsi
  0022a	c3		 ret	 0
case_operation ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@EMEJONJL@sequence?5item?5?$CFzd?3?5expected?5str?5@ ; `string'
PUBLIC	??_C@_0CO@OAOBIHEE@join?$CI?$CJ?5result?5is?5too?5long?5for?5a?5@ ; `string'
PUBLIC	??_C@_0CO@PFBLIHO@separator?3?5expected?5str?5instance@ ; `string'
PUBLIC	??_C@_0BK@DFNCEILI@can?5only?5join?5an?5iterable?$AA@ ; `string'
PUBLIC	PyUnicode_Join
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PySequence_Fast:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyUnicode_Join DD imagerel $LN159
	DD	imagerel $LN159+189
	DD	imagerel $unwind$PyUnicode_Join
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyUnicode_Join DD imagerel $LN159+189
	DD	imagerel $LN159+1773
	DD	imagerel $chain$2$PyUnicode_Join
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyUnicode_Join DD imagerel $LN159+1773
	DD	imagerel $LN159+1788
	DD	imagerel $chain$3$PyUnicode_Join
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyUnicode_Join DD 021H
	DD	imagerel $LN159
	DD	imagerel $LN159+189
	DD	imagerel $unwind$PyUnicode_Join
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyUnicode_Join DD 062e21H
	DD	016642eH
	DD	0ef40aH
	DD	0fd405H
	DD	imagerel $LN159
	DD	imagerel $LN159+189
	DD	imagerel $unwind$PyUnicode_Join
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Join DD 060f01H
	DD	0e008f20fH
	DD	07004c006H
	DD	030025003H
xdata	ENDS
;	COMDAT ??_C@_0DG@EMEJONJL@sequence?5item?5?$CFzd?3?5expected?5str?5@
CONST	SEGMENT
??_C@_0DG@EMEJONJL@sequence?5item?5?$CFzd?3?5expected?5str?5@ DB 'sequenc'
	DB	'e item %zd: expected str instance, %.80s found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@OAOBIHEE@join?$CI?$CJ?5result?5is?5too?5long?5for?5a?5@
CONST	SEGMENT
??_C@_0CO@OAOBIHEE@join?$CI?$CJ?5result?5is?5too?5long?5for?5a?5@ DB 'joi'
	DB	'n() result is too long for a Python string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@PFBLIHO@separator?3?5expected?5str?5instance@
CONST	SEGMENT
??_C@_0CO@PFBLIHO@separator?3?5expected?5str?5instance@ DB 'separator: ex'
	DB	'pected str instance, %.80s found', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DFNCEILI@can?5only?5join?5an?5iterable?$AA@
CONST	SEGMENT
??_C@_0BK@DFNCEILI@can?5only?5join?5an?5iterable?$AA@ DB 'can only join a'
	DB	'n iterable', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT PyUnicode_Join
_TEXT	SEGMENT
res$1$ = 48
seplen$1$ = 56
sep_data$1$ = 64
seqlen$1$ = 72
items$1$ = 80
tv849 = 88
fseq$1$ = 96
separator$ = 176
seq$ = 184
maxchar$1$ = 192
kind$1$ = 200
PyUnicode_Join PROC					; COMDAT

; 9574 : {

$LN159:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	41 56		 push	 r14
  00008	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 9575 :     PyObject *sep = NULL;

  0000f	45 33 f6	 xor	 r14d, r14d
  00012	48 8b c2	 mov	 rax, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 9576 :     Py_ssize_t seplen;
; 9577 :     PyObject *res = NULL; /* the result */
; 9578 :     PyObject *fseq;          /* PySequence_Fast(seq) */
; 9579 :     Py_ssize_t seqlen;       /* len(fseq) -- number of items in sequence */
; 9580 :     PyObject **items;
; 9581 :     PyObject *item;
; 9582 :     Py_ssize_t sz, i, res_offset;
; 9583 :     Py_UCS4 maxchar;
; 9584 :     Py_UCS4 item_maxchar;
; 9585 :     int use_memcpy;
; 9586 :     unsigned char *res_data = NULL, *sep_data = NULL;
; 9587 :     PyObject *last_obj;
; 9588 :     unsigned int kind = 0;
; 9589 : 
; 9590 :     fseq = PySequence_Fast(seq, "can only join an iterable");

  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@DFNCEILI@can?5only?5join?5an?5iterable?$AA@
  0001f	48 8b c8	 mov	 rcx, rax
  00022	45 8b e6	 mov	 r12d, r14d
  00025	41 8b ee	 mov	 ebp, r14d
  00028	4c 89 74 24 40	 mov	 QWORD PTR sep_data$1$[rsp], r14
  0002d	44 89 b4 24 c8
	00 00 00	 mov	 DWORD PTR kind$1$[rsp], r14d
  00035	e8 00 00 00 00	 call	 PySequence_Fast
  0003a	48 8b f8	 mov	 rdi, rax
  0003d	48 89 44 24 60	 mov	 QWORD PTR fseq$1$[rsp], rax

; 9591 :     if (fseq == NULL) {

  00042	48 85 c0	 test	 rax, rax
  00045	75 0f		 jne	 SHORT $LN71@PyUnicode_@37

; 9750 : }

  00047	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0004e	41 5e		 pop	 r14
  00050	41 5c		 pop	 r12
  00052	5f		 pop	 rdi
  00053	5d		 pop	 rbp
  00054	5b		 pop	 rbx
  00055	c3		 ret	 0
$LN71@PyUnicode_@37:

; 9592 :         return NULL;
; 9593 :     }
; 9594 : 
; 9595 :     /* NOTE: the following code can't call back into Python code,
; 9596 :      * so we are sure that fseq won't be mutated.
; 9597 :      */
; 9598 : 
; 9599 :     seqlen = PySequence_Fast_GET_SIZE(fseq);

  00056	4c 8b 47 60	 mov	 r8, QWORD PTR [rdi+96]
  0005a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005e	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  00064	4c 89 44 24 48	 mov	 QWORD PTR seqlen$1$[rsp], r8
  00069	81 e1 00 00 00
	02		 and	 ecx, 33554432		; 02000000H

; 9600 :     /* If empty sequence, return u"". */
; 9601 :     if (seqlen == 0) {

  0006f	4d 85 c0	 test	 r8, r8
  00072	75 49		 jne	 SHORT $LN67@PyUnicode_@37

; 9602 :         Py_DECREF(fseq);

  00074	48 8b cf	 mov	 rcx, rdi
  00077	e8 00 00 00 00	 call	 _Py_DecRef

; 9603 :         _Py_RETURN_UNICODE_EMPTY();

  0007c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  00083	48 85 c9	 test	 rcx, rcx
  00086	75 1a		 jne	 SHORT $LN156@PyUnicode_@37
  00088	33 d2		 xor	 edx, edx
  0008a	e8 00 00 00 00	 call	 PyUnicode_New
  0008f	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  00096	48 85 c0	 test	 rax, rax
  00099	0f 84 4e 06 00
	00		 je	 $LN72@PyUnicode_@37
  0009f	48 8b c8	 mov	 rcx, rax
$LN156@PyUnicode_@37:
  000a2	e8 00 00 00 00	 call	 _Py_IncRef
  000a7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 9750 : }

  000ae	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000b5	41 5e		 pop	 r14
  000b7	41 5c		 pop	 r12
  000b9	5f		 pop	 rdi
  000ba	5d		 pop	 rbp
  000bb	5b		 pop	 rbx
  000bc	c3		 ret	 0
$LN67@PyUnicode_@37:
  000bd	4c 89 6c 24 78	 mov	 QWORD PTR [rsp+120], r13
  000c2	4c 89 7c 24 70	 mov	 QWORD PTR [rsp+112], r15

; 9604 :     }
; 9605 : 
; 9606 :     /* If singleton sequence with an exact Unicode, return that. */
; 9607 :     last_obj = NULL;

  000c7	4d 8b fe	 mov	 r15, r14

; 9608 :     items = PySequence_Fast_ITEMS(fseq);

  000ca	85 c9		 test	 ecx, ecx
  000cc	74 06		 je	 SHORT $LN76@PyUnicode_@37
  000ce	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  000d2	eb 04		 jmp	 SHORT $LN157@PyUnicode_@37
$LN76@PyUnicode_@37:
  000d4	48 8d 47 70	 lea	 rax, QWORD PTR [rdi+112]
$LN157@PyUnicode_@37:

; 9609 :     if (seqlen == 1) {

  000d8	41 bd 01 00 00
	00		 mov	 r13d, 1
  000de	48 89 44 24 50	 mov	 QWORD PTR items$1$[rsp], rax
  000e3	48 89 b4 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rsi
  000eb	4c 89 6c 24 58	 mov	 QWORD PTR tv849[rsp], r13
  000f0	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  000f5	4d 3b c5	 cmp	 r8, r13
  000f8	75 39		 jne	 SHORT $LN60@PyUnicode_@37

; 9610 :         if (PyUnicode_CheckExact(items[0])) {

  000fa	48 8b 18	 mov	 rbx, QWORD PTR [rax]
  000fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyUnicode_Type
  00104	48 39 4b 58	 cmp	 QWORD PTR [rbx+88], rcx
  00108	75 15		 jne	 SHORT $LN59@PyUnicode_@37

; 9611 :             res = items[0];
; 9612 :             Py_INCREF(res);

  0010a	48 8b cb	 mov	 rcx, rbx
  0010d	e8 00 00 00 00	 call	 _Py_IncRef

; 9613 :             Py_DECREF(fseq);

  00112	48 8b cf	 mov	 rcx, rdi
  00115	e8 00 00 00 00	 call	 _Py_DecRef

; 9614 :             return res;

  0011a	e9 b9 05 00 00	 jmp	 $LN11@PyUnicode_@37
$LN59@PyUnicode_@37:

; 9615 :         }
; 9616 :         seplen = 0;
; 9617 :         maxchar = 0;

  0011f	41 8b ce	 mov	 ecx, r14d
  00122	4c 89 74 24 38	 mov	 QWORD PTR seplen$1$[rsp], r14
  00127	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR maxchar$1$[rsp], ecx

; 9618 :     }
; 9619 :     else {

  0012e	e9 59 01 00 00	 jmp	 $LN58@PyUnicode_@37
$LN60@PyUnicode_@37:

; 9620 :         /* Set up sep and seplen */
; 9621 :         if (separator == NULL) {

  00133	48 85 db	 test	 rbx, rbx
  00136	75 23		 jne	 SHORT $LN57@PyUnicode_@37

; 9622 :             /* fall back to a blank space separator */
; 9623 :             sep = PyUnicode_FromOrdinal(' ');

  00138	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0013d	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR maxchar$1$[rsp], ecx
  00144	e8 00 00 00 00	 call	 PyUnicode_FromOrdinal
  00149	4c 8b e0	 mov	 r12, rax

; 9624 :             if (!sep)

  0014c	48 85 c0	 test	 rax, rax
  0014f	74 36		 je	 SHORT $LN150@PyUnicode_@37

; 9625 :                 goto onError;
; 9626 :             seplen = 1;

  00151	4c 89 6c 24 38	 mov	 QWORD PTR seplen$1$[rsp], r13

; 9627 :             maxchar = 32;
; 9628 :         }
; 9629 :         else {

  00156	e9 1d 01 00 00	 jmp	 $LN55@PyUnicode_@37
$LN57@PyUnicode_@37:

; 9630 :             if (!PyUnicode_Check(separator)) {

  0015b	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  0015f	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  0016a	0f 85 9b 00 00
	00		 jne	 $LN54@PyUnicode_@37

; 9631 :                 PyErr_Format(PyExc_TypeError,
; 9632 :                              "separator: expected str instance,"
; 9633 :                              " %.80s found",
; 9634 :                              Py_TYPE(separator)->tp_name);

  00170	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00174	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0017b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@PFBLIHO@separator?3?5expected?5str?5instance@
  00182	e8 00 00 00 00	 call	 PyErr_Format
$LN150@PyUnicode_@37:

; 9702 :     }
; 9703 : #endif
; 9704 :     for (i = 0, res_offset = 0; i < seqlen; ++i) {

  00187	48 8b dd	 mov	 rbx, rbp
$onError$136291:

; 9744 : 
; 9745 :   onError:
; 9746 :     Py_DECREF(fseq);

  0018a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fseq$1$[rsp]
  0018f	e8 00 00 00 00	 call	 _Py_DecRef

; 9747 :     Py_XDECREF(sep);

  00194	4d 85 e4	 test	 r12, r12
  00197	0f 84 6b 02 00
	00		 je	 $LN7@PyUnicode_@37
  0019d	e8 00 00 00 00	 call	 _Py_PXCTX
  001a2	85 c0		 test	 eax, eax
  001a4	0f 85 5e 02 00
	00		 jne	 $LN7@PyUnicode_@37
  001aa	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  001af	a8 20		 test	 al, 32			; 00000020H
  001b1	0f 85 49 02 00
	00		 jne	 $LN117@PyUnicode_@37
  001b7	84 c0		 test	 al, al
  001b9	0f 88 41 02 00
	00		 js	 $LN117@PyUnicode_@37
  001bf	a8 02		 test	 al, 2
  001c1	0f 85 41 02 00
	00		 jne	 $LN7@PyUnicode_@37
  001c7	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  001cc	0f 85 36 02 00
	00		 jne	 $LN7@PyUnicode_@37
  001d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001e0	4d 8b cc	 mov	 r9, r12
  001e3	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001e9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001f1	e8 00 00 00 00	 call	 _PyParallel_Guard
  001f6	49 8b cc	 mov	 rcx, r12
  001f9	85 c0		 test	 eax, eax
  001fb	0f 84 f2 01 00
	00		 je	 $LN122@PyUnicode_@37
  00201	e8 00 00 00 00	 call	 _Px_Dealloc
  00206	e9 fd 01 00 00	 jmp	 $LN7@PyUnicode_@37
$LN54@PyUnicode_@37:

; 9635 :                 goto onError;
; 9636 :             }
; 9637 :             if (PyUnicode_READY(separator))

  0020b	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  0020f	75 15		 jne	 SHORT $LN146@PyUnicode_@37
  00211	48 8b cb	 mov	 rcx, rbx
  00214	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00219	85 c0		 test	 eax, eax
  0021b	0f 85 66 ff ff
	ff		 jne	 $LN150@PyUnicode_@37
  00221	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
$LN146@PyUnicode_@37:

; 9638 :                 goto onError;
; 9639 :             sep = separator;
; 9640 :             seplen = PyUnicode_GET_LENGTH(separator);

  00226	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  0022a	4c 8b e3	 mov	 r12, rbx
  0022d	48 89 44 24 38	 mov	 QWORD PTR seplen$1$[rsp], rax

; 9641 :             maxchar = PyUnicode_MAX_CHAR_VALUE(separator);

  00232	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00235	a8 40		 test	 al, 64			; 00000040H
  00237	74 0d		 je	 SHORT $LN82@PyUnicode_@37
  00239	c7 84 24 c0 00
	00 00 7f 00 00
	00		 mov	 DWORD PTR maxchar$1$[rsp], 127 ; 0000007fH
  00244	eb 2a		 jmp	 SHORT $LN81@PyUnicode_@37
$LN82@PyUnicode_@37:
  00246	c1 e8 02	 shr	 eax, 2
  00249	83 e0 07	 and	 eax, 7
  0024c	41 3b c5	 cmp	 eax, r13d
  0024f	75 0d		 jne	 SHORT $LN80@PyUnicode_@37
  00251	c7 84 24 c0 00
	00 00 ff 00 00
	00		 mov	 DWORD PTR maxchar$1$[rsp], 255 ; 000000ffH
  0025c	eb 12		 jmp	 SHORT $LN81@PyUnicode_@37
$LN80@PyUnicode_@37:
  0025e	b9 ff ff 10 00	 mov	 ecx, 1114111		; 0010ffffH
  00263	83 f8 02	 cmp	 eax, 2
  00266	0f 44 ca	 cmove	 ecx, edx
  00269	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR maxchar$1$[rsp], ecx
$LN81@PyUnicode_@37:

; 9642 :             /* inc refcount to keep this code path symmetric with the
; 9643 :                above case of a blank separator */
; 9644 :             Py_INCREF(sep);

  00270	48 8b cb	 mov	 rcx, rbx
  00273	e8 00 00 00 00	 call	 _Py_IncRef
$LN55@PyUnicode_@37:

; 9645 :         }
; 9646 :         last_obj = sep;

  00278	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR maxchar$1$[rsp]
  0027f	4c 8b 44 24 48	 mov	 r8, QWORD PTR seqlen$1$[rsp]
  00284	48 8b 44 24 50	 mov	 rax, QWORD PTR items$1$[rsp]
  00289	4d 8b fc	 mov	 r15, r12
$LN58@PyUnicode_@37:

; 9647 :     }
; 9648 : 
; 9649 :     /* There are at least two things to join, or else we have a subclass
; 9650 :      * of str in the sequence.
; 9651 :      * Do a pre-pass to figure out the total amount of space we'll
; 9652 :      * need (sz), and see whether all argument are strings.
; 9653 :      */
; 9654 :     sz = 0;

  0028c	49 8b de	 mov	 rbx, r14

; 9655 : #ifdef Py_DEBUG
; 9656 :     use_memcpy = 0;
; 9657 : #else
; 9658 :     use_memcpy = 1;
; 9659 : #endif
; 9660 :     for (i = 0; i < seqlen; i++) {

  0028f	49 8b f6	 mov	 rsi, r14
  00292	4d 85 c0	 test	 r8, r8
  00295	0f 8e de 00 00
	00		 jle	 $LN50@PyUnicode_@37
  0029b	49 b9 ff ff ff
	ff ff ff ff 7f	 mov	 r9, 9223372036854775807	; 7fffffffffffffffH
$LL52@PyUnicode_@37:

; 9661 :         const Py_ssize_t old_sz = sz;
; 9662 :         item = items[i];

  002a5	48 8b 3c f0	 mov	 rdi, QWORD PTR [rax+rsi*8]
  002a9	4c 8b eb	 mov	 r13, rbx

; 9663 :         if (!PyUnicode_Check(item)) {

  002ac	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  002b0	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  002ba	0f 84 14 01 00
	00		 je	 $LN139@PyUnicode_@37

; 9669 :         }
; 9670 :         if (PyUnicode_READY(item) == -1)

  002c0	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  002c4	75 20		 jne	 SHORT $LN147@PyUnicode_@37
  002c6	48 8b cf	 mov	 rcx, rdi
  002c9	e8 00 00 00 00	 call	 _PyUnicode_Ready
  002ce	83 f8 ff	 cmp	 eax, -1
  002d1	0f 84 b0 fe ff
	ff		 je	 $LN150@PyUnicode_@37
  002d7	4c 8b 44 24 48	 mov	 r8, QWORD PTR seqlen$1$[rsp]
  002dc	49 b9 ff ff ff
	ff ff ff ff 7f	 mov	 r9, 9223372036854775807	; 7fffffffffffffffH
$LN147@PyUnicode_@37:

; 9671 :             goto onError;
; 9672 :         sz += PyUnicode_GET_LENGTH(item);
; 9673 :         item_maxchar = PyUnicode_MAX_CHAR_VALUE(item);

  002e6	8b 57 70	 mov	 edx, DWORD PTR [rdi+112]
  002e9	48 03 5f 60	 add	 rbx, QWORD PTR [rdi+96]
  002ed	f6 c2 40	 test	 dl, 64			; 00000040H
  002f0	74 07		 je	 SHORT $LN88@PyUnicode_@37
  002f2	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  002f7	eb 24		 jmp	 SHORT $LN87@PyUnicode_@37
$LN88@PyUnicode_@37:
  002f9	8b ca		 mov	 ecx, edx
  002fb	c1 e9 02	 shr	 ecx, 2
  002fe	83 e1 07	 and	 ecx, 7
  00301	83 f9 01	 cmp	 ecx, 1
  00304	75 07		 jne	 SHORT $LN86@PyUnicode_@37
  00306	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0030b	eb 10		 jmp	 SHORT $LN87@PyUnicode_@37
$LN86@PyUnicode_@37:
  0030d	83 f9 02	 cmp	 ecx, 2
  00310	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH
  00315	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0031a	0f 44 c1	 cmove	 eax, ecx
$LN87@PyUnicode_@37:

; 9674 :         maxchar = Py_MAX(maxchar, item_maxchar);

  0031d	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR maxchar$1$[rsp]
  00324	3b c8		 cmp	 ecx, eax
  00326	0f 47 c1	 cmova	 eax, ecx
  00329	8b c8		 mov	 ecx, eax
  0032b	89 84 24 c0 00
	00 00		 mov	 DWORD PTR maxchar$1$[rsp], eax

; 9675 :         if (i != 0)

  00332	48 85 f6	 test	 rsi, rsi
  00335	74 05		 je	 SHORT $LN47@PyUnicode_@37

; 9676 :             sz += seplen;

  00337	48 03 5c 24 38	 add	 rbx, QWORD PTR seplen$1$[rsp]
$LN47@PyUnicode_@37:

; 9677 :         if (sz < old_sz || sz > PY_SSIZE_T_MAX) {

  0033c	49 3b dd	 cmp	 rbx, r13
  0033f	7c 7b		 jl	 SHORT $LN141@PyUnicode_@37
  00341	49 3b d9	 cmp	 rbx, r9
  00344	7f 76		 jg	 SHORT $LN141@PyUnicode_@37

; 9681 :         }
; 9682 :         if (use_memcpy && last_obj != NULL) {

  00346	4c 8b 6c 24 58	 mov	 r13, QWORD PTR tv849[rsp]
  0034b	45 85 ed	 test	 r13d, r13d
  0034e	74 15		 je	 SHORT $LN43@PyUnicode_@37
  00350	4d 85 ff	 test	 r15, r15
  00353	74 10		 je	 SHORT $LN43@PyUnicode_@37

; 9683 :             if (PyUnicode_KIND(last_obj) != PyUnicode_KIND(item))

  00355	41 32 57 70	 xor	 dl, BYTE PTR [r15+112]
  00359	f6 c2 1c	 test	 dl, 28
  0035c	45 0f 45 ee	 cmovne	 r13d, r14d
  00360	4c 89 6c 24 58	 mov	 QWORD PTR tv849[rsp], r13
$LN43@PyUnicode_@37:

; 9655 : #ifdef Py_DEBUG
; 9656 :     use_memcpy = 0;
; 9657 : #else
; 9658 :     use_memcpy = 1;
; 9659 : #endif
; 9660 :     for (i = 0; i < seqlen; i++) {

  00365	48 8b 44 24 50	 mov	 rax, QWORD PTR items$1$[rsp]
  0036a	48 ff c6	 inc	 rsi

; 9684 :                 use_memcpy = 0;
; 9685 :         }
; 9686 :         last_obj = item;

  0036d	4c 8b ff	 mov	 r15, rdi
  00370	49 3b f0	 cmp	 rsi, r8
  00373	0f 8c 2c ff ff
	ff		 jl	 $LL52@PyUnicode_@37
$LN50@PyUnicode_@37:

; 9687 :     }
; 9688 : 
; 9689 :     res = PyUnicode_New(sz, maxchar);

  00379	8b d1		 mov	 edx, ecx
  0037b	48 8b cb	 mov	 rcx, rbx
  0037e	e8 00 00 00 00	 call	 PyUnicode_New
  00383	48 8b d8	 mov	 rbx, rax
  00386	48 89 44 24 30	 mov	 QWORD PTR res$1$[rsp], rax

; 9690 :     if (res == NULL)

  0038b	48 85 c0	 test	 rax, rax
  0038e	0f 84 f6 fd ff
	ff		 je	 $onError$136291

; 9691 :         goto onError;
; 9692 : 
; 9693 :     /* Catenate everything. */
; 9694 : #ifdef Py_DEBUG
; 9695 :     use_memcpy = 0;
; 9696 : #else
; 9697 :     if (use_memcpy) {

  00394	45 85 ed	 test	 r13d, r13d
  00397	0f 84 55 01 00
	00		 je	 $LN151@PyUnicode_@37

; 9698 :         res_data = PyUnicode_1BYTE_DATA(res);

  0039d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  003a0	a8 20		 test	 al, 32			; 00000020H
  003a2	0f 84 e4 00 00
	00		 je	 $LN92@PyUnicode_@37
  003a8	a8 40		 test	 al, 64			; 00000040H
  003aa	0f 84 d3 00 00
	00		 je	 $LN90@PyUnicode_@37
  003b0	48 8d ab 80 00
	00 00		 lea	 rbp, QWORD PTR [rbx+128]
  003b7	e9 d7 00 00 00	 jmp	 $LN93@PyUnicode_@37
$LN141@PyUnicode_@37:

; 9678 :             PyErr_SetString(PyExc_OverflowError,
; 9679 :                             "join() result is too long for a Python string");

  003bc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  003c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@OAOBIHEE@join?$CI?$CJ?5result?5is?5too?5long?5for?5a?5@
  003ca	e8 00 00 00 00	 call	 PyErr_SetString

; 9680 :             goto onError;

  003cf	e9 b3 fd ff ff	 jmp	 $LN150@PyUnicode_@37
$LN139@PyUnicode_@37:

; 9664 :             PyErr_Format(PyExc_TypeError,
; 9665 :                          "sequence item %zd: expected str instance,"
; 9666 :                          " %.80s found",
; 9667 :                          i, Py_TYPE(item)->tp_name);

  003d4	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  003d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  003df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@EMEJONJL@sequence?5item?5?$CFzd?3?5expected?5str?5@
  003e6	4c 8b c6	 mov	 r8, rsi
  003e9	e8 00 00 00 00	 call	 PyErr_Format

; 9668 :             goto onError;

  003ee	e9 94 fd ff ff	 jmp	 $LN150@PyUnicode_@37

; 9747 :     Py_XDECREF(sep);

$LN122@PyUnicode_@37:
  003f3	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  003f8	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  003fe	eb 08		 jmp	 SHORT $LN7@PyUnicode_@37
$LN117@PyUnicode_@37:
  00400	49 8b cc	 mov	 rcx, r12
  00403	e8 00 00 00 00	 call	 Px_DecRef
$LN7@PyUnicode_@37:

; 9748 :     Py_XDECREF(res);

  00408	48 85 db	 test	 rbx, rbx
  0040b	74 6f		 je	 SHORT $LN3@PyUnicode_@37
  0040d	e8 00 00 00 00	 call	 _Py_PXCTX
  00412	85 c0		 test	 eax, eax
  00414	75 66		 jne	 SHORT $LN3@PyUnicode_@37
  00416	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0041a	a8 20		 test	 al, 32			; 00000020H
  0041c	75 56		 jne	 SHORT $LN128@PyUnicode_@37
  0041e	84 c0		 test	 al, al
  00420	78 52		 js	 SHORT $LN128@PyUnicode_@37
  00422	a8 02		 test	 al, 2
  00424	75 56		 jne	 SHORT $LN3@PyUnicode_@37
  00426	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0042a	75 50		 jne	 SHORT $LN3@PyUnicode_@37
  0042c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00433	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0043a	4c 8b cb	 mov	 r9, rbx
  0043d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00443	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0044b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00450	48 8b cb	 mov	 rcx, rbx
  00453	85 c0		 test	 eax, eax
  00455	74 0c		 je	 SHORT $LN133@PyUnicode_@37
  00457	e8 00 00 00 00	 call	 _Px_Dealloc

; 9749 :     return NULL;

  0045c	33 c0		 xor	 eax, eax
  0045e	e9 78 02 00 00	 jmp	 $LN155@PyUnicode_@37

; 9748 :     Py_XDECREF(res);

$LN133@PyUnicode_@37:
  00463	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00467	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 9749 :     return NULL;

  0046d	33 c0		 xor	 eax, eax
  0046f	e9 67 02 00 00	 jmp	 $LN155@PyUnicode_@37

; 9748 :     Py_XDECREF(res);

$LN128@PyUnicode_@37:
  00474	48 8b cb	 mov	 rcx, rbx
  00477	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PyUnicode_@37:

; 9749 :     return NULL;

  0047c	33 c0		 xor	 eax, eax
  0047e	e9 58 02 00 00	 jmp	 $LN155@PyUnicode_@37
$LN90@PyUnicode_@37:

; 9698 :         res_data = PyUnicode_1BYTE_DATA(res);

  00483	48 8d ab a0 00
	00 00		 lea	 rbp, QWORD PTR [rbx+160]
  0048a	eb 07		 jmp	 SHORT $LN93@PyUnicode_@37
$LN92@PyUnicode_@37:
  0048c	48 8b ab a0 00
	00 00		 mov	 rbp, QWORD PTR [rbx+160]
$LN93@PyUnicode_@37:

; 9699 :         kind = PyUnicode_KIND(res);
; 9700 :         if (seplen != 0)

  00493	48 8b 7c 24 38	 mov	 rdi, QWORD PTR seplen$1$[rsp]
  00498	c1 e8 02	 shr	 eax, 2
  0049b	83 e0 07	 and	 eax, 7
  0049e	89 84 24 c8 00
	00 00		 mov	 DWORD PTR kind$1$[rsp], eax
  004a5	48 85 ff	 test	 rdi, rdi
  004a8	74 59		 je	 SHORT $LN152@PyUnicode_@37

; 9701 :             sep_data = PyUnicode_1BYTE_DATA(sep);

  004aa	41 8b 44 24 70	 mov	 eax, DWORD PTR [r12+112]
  004af	a8 20		 test	 al, 32			; 00000020H
  004b1	74 29		 je	 SHORT $LN96@PyUnicode_@37
  004b3	a8 40		 test	 al, 64			; 00000040H
  004b5	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR kind$1$[rsp]
  004bc	74 0f		 je	 SHORT $LN94@PyUnicode_@37
  004be	49 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR [r12+128]
  004c6	48 89 54 24 40	 mov	 QWORD PTR sep_data$1$[rsp], rdx
  004cb	eb 39		 jmp	 SHORT $LN97@PyUnicode_@37
$LN94@PyUnicode_@37:
  004cd	49 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR [r12+160]
  004d5	48 89 54 24 40	 mov	 QWORD PTR sep_data$1$[rsp], rdx
  004da	eb 2a		 jmp	 SHORT $LN97@PyUnicode_@37
$LN96@PyUnicode_@37:
  004dc	49 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR [r12+160]
  004e4	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR kind$1$[rsp]
  004eb	48 89 54 24 40	 mov	 QWORD PTR sep_data$1$[rsp], rdx
  004f0	eb 14		 jmp	 SHORT $LN97@PyUnicode_@37
$LN151@PyUnicode_@37:

; 9702 :     }
; 9703 : #endif
; 9704 :     for (i = 0, res_offset = 0; i < seqlen; ++i) {

  004f2	48 8b 7c 24 38	 mov	 rdi, QWORD PTR seplen$1$[rsp]
  004f7	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR kind$1$[rsp]
  004fe	48 8b d5	 mov	 rdx, rbp
  00501	eb 03		 jmp	 SHORT $LN97@PyUnicode_@37
$LN152@PyUnicode_@37:
  00503	49 8b d6	 mov	 rdx, r14
$LN97@PyUnicode_@37:

; 9709 :             if (use_memcpy) {

  00506	4c 63 7c 24 58	 movsxd	 r15, DWORD PTR tv849[rsp]
  0050b	4d 8b ee	 mov	 r13, r14
  0050e	4c 39 74 24 48	 cmp	 QWORD PTR seqlen$1$[rsp], r14
  00513	0f 8e 48 01 00
	00		 jle	 $LN37@PyUnicode_@37
  00519	0f 1f 80 00 00
	00 00		 npad	 7
$LL39@PyUnicode_@37:

; 9705 :         Py_ssize_t itemlen;
; 9706 :         item = items[i];

  00520	48 8b 4c 24 50	 mov	 rcx, QWORD PTR items$1$[rsp]
  00525	4a 8b 34 f1	 mov	 rsi, QWORD PTR [rcx+r14*8]

; 9707 :         /* Copy item, and maybe the separator. */
; 9708 :         if (i && seplen != 0) {

  00529	4d 85 f6	 test	 r14, r14
  0052c	74 75		 je	 SHORT $LN26@PyUnicode_@37
  0052e	48 85 ff	 test	 rdi, rdi
  00531	74 70		 je	 SHORT $LN26@PyUnicode_@37

; 9709 :             if (use_memcpy) {

  00533	4d 85 ff	 test	 r15, r15
  00536	74 52		 je	 SHORT $LN35@PyUnicode_@37

; 9710 :                 Py_MEMCPY(res_data,
; 9711 :                           sep_data,
; 9712 :                           kind * seplen);

  00538	8b d8		 mov	 ebx, eax
  0053a	48 0f af df	 imul	 rbx, rdi
  0053e	48 83 fb 10	 cmp	 rbx, 16
  00542	72 15		 jb	 SHORT $LN31@PyUnicode_@37
  00544	4c 8b c3	 mov	 r8, rbx
  00547	48 8b cd	 mov	 rcx, rbp
  0054a	e8 00 00 00 00	 call	 memcpy

; 9713 :                 res_data += kind * seplen;

  0054f	48 03 eb	 add	 rbp, rbx

; 9714 :             }
; 9715 :             else {

  00552	48 8b 5c 24 30	 mov	 rbx, QWORD PTR res$1$[rsp]
  00557	eb 4a		 jmp	 SHORT $LN26@PyUnicode_@37
$LN31@PyUnicode_@37:

; 9710 :                 Py_MEMCPY(res_data,
; 9711 :                           sep_data,
; 9712 :                           kind * seplen);

  00559	48 85 db	 test	 rbx, rbx
  0055c	74 22		 je	 SHORT $LN33@PyUnicode_@37
  0055e	4c 8b c2	 mov	 r8, rdx
  00561	48 8b cd	 mov	 rcx, rbp
  00564	48 8b d3	 mov	 rdx, rbx
  00567	4c 2b c5	 sub	 r8, rbp
  0056a	66 0f 1f 44 00
	00		 npad	 6
$LL29@PyUnicode_@37:
  00570	41 0f b6 04 08	 movzx	 eax, BYTE PTR [r8+rcx]
  00575	48 ff c1	 inc	 rcx
  00578	48 ff ca	 dec	 rdx
  0057b	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0057e	75 f0		 jne	 SHORT $LL29@PyUnicode_@37
$LN33@PyUnicode_@37:

; 9713 :                 res_data += kind * seplen;

  00580	48 03 eb	 add	 rbp, rbx

; 9714 :             }
; 9715 :             else {

  00583	48 8b 5c 24 30	 mov	 rbx, QWORD PTR res$1$[rsp]
  00588	eb 19		 jmp	 SHORT $LN26@PyUnicode_@37
$LN35@PyUnicode_@37:

; 9716 :                 _PyUnicode_FastCopyCharacters(res, res_offset, sep, 0, seplen);

  0058a	45 33 c9	 xor	 r9d, r9d
  0058d	4d 8b c4	 mov	 r8, r12
  00590	49 8b d5	 mov	 rdx, r13
  00593	48 8b cb	 mov	 rcx, rbx
  00596	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0059b	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 9717 :                 res_offset += seplen;

  005a0	4c 03 ef	 add	 r13, rdi
$LN26@PyUnicode_@37:

; 9718 :             }
; 9719 :         }
; 9720 :         itemlen = PyUnicode_GET_LENGTH(item);

  005a3	48 8b 7e 60	 mov	 rdi, QWORD PTR [rsi+96]

; 9721 :         if (itemlen != 0) {

  005a7	48 85 ff	 test	 rdi, rdi
  005aa	0f 84 8d 00 00
	00		 je	 $LN38@PyUnicode_@37

; 9722 :             if (use_memcpy) {

  005b0	4d 85 ff	 test	 r15, r15
  005b3	74 6f		 je	 SHORT $LN24@PyUnicode_@37

; 9723 :                 Py_MEMCPY(res_data,
; 9724 :                           PyUnicode_DATA(item),
; 9725 :                           kind * itemlen);

  005b5	8b 9c 24 c8 00
	00 00		 mov	 ebx, DWORD PTR kind$1$[rsp]
  005bc	8b 46 70	 mov	 eax, DWORD PTR [rsi+112]
  005bf	48 0f af df	 imul	 rbx, rdi
  005c3	a8 20		 test	 al, 32			; 00000020H
  005c5	74 16		 je	 SHORT $LN100@PyUnicode_@37
  005c7	a8 40		 test	 al, 64			; 00000040H
  005c9	74 09		 je	 SHORT $LN98@PyUnicode_@37
  005cb	48 8d 96 80 00
	00 00		 lea	 rdx, QWORD PTR [rsi+128]
  005d2	eb 10		 jmp	 SHORT $LN101@PyUnicode_@37
$LN98@PyUnicode_@37:
  005d4	48 8d 96 a0 00
	00 00		 lea	 rdx, QWORD PTR [rsi+160]
  005db	eb 07		 jmp	 SHORT $LN101@PyUnicode_@37
$LN100@PyUnicode_@37:
  005dd	48 8b 96 a0 00
	00 00		 mov	 rdx, QWORD PTR [rsi+160]
$LN101@PyUnicode_@37:
  005e4	48 83 fb 10	 cmp	 rbx, 16
  005e8	72 10		 jb	 SHORT $LN20@PyUnicode_@37
  005ea	4c 8b c3	 mov	 r8, rbx
  005ed	48 8b cd	 mov	 rcx, rbp
  005f0	e8 00 00 00 00	 call	 memcpy

; 9726 :                 res_data += kind * itemlen;

  005f5	48 03 eb	 add	 rbp, rbx

; 9727 :             }
; 9728 :             else {

  005f8	eb 43		 jmp	 SHORT $LN38@PyUnicode_@37
$LN20@PyUnicode_@37:

; 9723 :                 Py_MEMCPY(res_data,
; 9724 :                           PyUnicode_DATA(item),
; 9725 :                           kind * itemlen);

  005fa	48 85 db	 test	 rbx, rbx
  005fd	74 20		 je	 SHORT $LN22@PyUnicode_@37
  005ff	48 8b cd	 mov	 rcx, rbp
  00602	48 2b d5	 sub	 rdx, rbp
  00605	4c 8b c3	 mov	 r8, rbx
  00608	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL18@PyUnicode_@37:
  00610	0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+rcx]
  00614	48 ff c1	 inc	 rcx
  00617	49 ff c8	 dec	 r8
  0061a	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0061d	75 f1		 jne	 SHORT $LL18@PyUnicode_@37
$LN22@PyUnicode_@37:

; 9726 :                 res_data += kind * itemlen;

  0061f	48 03 eb	 add	 rbp, rbx

; 9727 :             }
; 9728 :             else {

  00622	eb 19		 jmp	 SHORT $LN38@PyUnicode_@37
$LN24@PyUnicode_@37:

; 9729 :                 _PyUnicode_FastCopyCharacters(res, res_offset, item, 0, itemlen);

  00624	45 33 c9	 xor	 r9d, r9d
  00627	4c 8b c6	 mov	 r8, rsi
  0062a	49 8b d5	 mov	 rdx, r13
  0062d	48 8b cb	 mov	 rcx, rbx
  00630	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00635	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 9730 :                 res_offset += itemlen;

  0063a	4c 03 ef	 add	 r13, rdi
$LN38@PyUnicode_@37:

; 9702 :     }
; 9703 : #endif
; 9704 :     for (i = 0, res_offset = 0; i < seqlen; ++i) {

  0063d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR res$1$[rsp]
  00642	48 8b 7c 24 38	 mov	 rdi, QWORD PTR seplen$1$[rsp]
  00647	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR kind$1$[rsp]
  0064e	48 8b 54 24 40	 mov	 rdx, QWORD PTR sep_data$1$[rsp]
  00653	49 ff c6	 inc	 r14
  00656	4c 3b 74 24 48	 cmp	 r14, QWORD PTR seqlen$1$[rsp]
  0065b	0f 8c bf fe ff
	ff		 jl	 $LL39@PyUnicode_@37
$LN37@PyUnicode_@37:

; 9731 :             }
; 9732 :         }
; 9733 :     }
; 9734 :     if (use_memcpy)
; 9735 :         assert(res_data == PyUnicode_1BYTE_DATA(res)
; 9736 :                            + kind * PyUnicode_GET_LENGTH(res));
; 9737 :     else
; 9738 :         assert(res_offset == PyUnicode_GET_LENGTH(res));
; 9739 : 
; 9740 :     Py_DECREF(fseq);

  00661	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fseq$1$[rsp]
  00666	e8 00 00 00 00	 call	 _Py_DecRef

; 9741 :     Py_XDECREF(sep);

  0066b	4d 85 e4	 test	 r12, r12
  0066e	74 68		 je	 SHORT $LN11@PyUnicode_@37
  00670	e8 00 00 00 00	 call	 _Py_PXCTX
  00675	85 c0		 test	 eax, eax
  00677	75 5f		 jne	 SHORT $LN11@PyUnicode_@37
  00679	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  0067e	a8 20		 test	 al, 32			; 00000020H
  00680	75 4e		 jne	 SHORT $LN106@PyUnicode_@37
  00682	84 c0		 test	 al, al
  00684	78 4a		 js	 SHORT $LN106@PyUnicode_@37
  00686	a8 02		 test	 al, 2
  00688	75 4e		 jne	 SHORT $LN11@PyUnicode_@37
  0068a	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  0068f	75 47		 jne	 SHORT $LN11@PyUnicode_@37
  00691	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00698	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0069f	4d 8b cc	 mov	 r9, r12
  006a2	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  006a8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  006b0	e8 00 00 00 00	 call	 _PyParallel_Guard
  006b5	49 8b cc	 mov	 rcx, r12
  006b8	85 c0		 test	 eax, eax
  006ba	74 07		 je	 SHORT $LN111@PyUnicode_@37
  006bc	e8 00 00 00 00	 call	 _Px_Dealloc
  006c1	eb 15		 jmp	 SHORT $LN11@PyUnicode_@37
$LN111@PyUnicode_@37:
  006c3	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  006c8	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  006ce	eb 08		 jmp	 SHORT $LN11@PyUnicode_@37
$LN106@PyUnicode_@37:
  006d0	49 8b cc	 mov	 rcx, r12
  006d3	e8 00 00 00 00	 call	 Px_DecRef
$LN11@PyUnicode_@37:

; 9742 :     assert(_PyUnicode_CheckConsistency(res, 1));
; 9743 :     return res;

  006d8	48 8b c3	 mov	 rax, rbx
$LN155@PyUnicode_@37:
  006db	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+176]
  006e3	4c 8b 6c 24 78	 mov	 r13, QWORD PTR [rsp+120]
  006e8	4c 8b 7c 24 70	 mov	 r15, QWORD PTR [rsp+112]
$LN72@PyUnicode_@37:

; 9750 : }

  006ed	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  006f4	41 5e		 pop	 r14
  006f6	41 5c		 pop	 r12
  006f8	5f		 pop	 rdi
  006f9	5d		 pop	 rbp
  006fa	5b		 pop	 rbx
  006fb	c3		 ret	 0
PyUnicode_Join ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_FastFill
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_FastFill DD imagerel $LN26
	DD	imagerel $LN26+133
	DD	imagerel $unwind$_PyUnicode_FastFill
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_FastFill DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_FastFill
_TEXT	SEGMENT
unicode$ = 48
start$ = 56
length$ = 64
fill_char$ = 72
_PyUnicode_FastFill PROC				; COMDAT

; 9779 : {

$LN26:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 9780 :     const enum PyUnicode_Kind kind = PyUnicode_KIND(unicode);

  00006	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00009	48 8b f9	 mov	 rdi, rcx
  0000c	4c 8b d2	 mov	 r10, rdx
  0000f	8b c8		 mov	 ecx, eax
  00011	c1 e9 02	 shr	 ecx, 2
  00014	83 e1 07	 and	 ecx, 7

; 9781 :     const void *data = PyUnicode_DATA(unicode);

  00017	a8 20		 test	 al, 32			; 00000020H
  00019	74 13		 je	 SHORT $LN20@PyUnicode_@38
  0001b	a8 40		 test	 al, 64			; 00000040H
  0001d	74 06		 je	 SHORT $LN18@PyUnicode_@38
  0001f	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  00023	eb 10		 jmp	 SHORT $LN21@PyUnicode_@38
$LN18@PyUnicode_@38:
  00025	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  0002c	eb 07		 jmp	 SHORT $LN21@PyUnicode_@38
$LN20@PyUnicode_@38:
  0002e	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
$LN21@PyUnicode_@38:

; 9782 :     assert(PyUnicode_IS_READY(unicode));
; 9783 :     assert(unicode_modifiable(unicode));
; 9784 :     assert(fill_char <= PyUnicode_MAX_CHAR_VALUE(unicode));
; 9785 :     assert(start >= 0);
; 9786 :     assert(start + length <= PyUnicode_GET_LENGTH(unicode));
; 9787 :     FILL(kind, data, fill_char, start, length);

  00035	ff c9		 dec	 ecx
  00037	74 39		 je	 SHORT $LN10@PyUnicode_@38
  00039	ff c9		 dec	 ecx
  0003b	74 1c		 je	 SHORT $LN9@PyUnicode_@38
  0003d	83 f9 02	 cmp	 ecx, 2
  00040	75 3d		 jne	 SHORT $LN14@PyUnicode_@38
  00042	48 8d 3c 97	 lea	 rdi, QWORD PTR [rdi+rdx*4]
  00046	4d 85 c0	 test	 r8, r8
  00049	7e 34		 jle	 SHORT $LN14@PyUnicode_@38
  0004b	41 8b c1	 mov	 eax, r9d
  0004e	49 8b c8	 mov	 rcx, r8
  00051	f3 ab		 rep stosd

; 9788 : }

  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
$LN9@PyUnicode_@38:

; 9782 :     assert(PyUnicode_IS_READY(unicode));
; 9783 :     assert(unicode_modifiable(unicode));
; 9784 :     assert(fill_char <= PyUnicode_MAX_CHAR_VALUE(unicode));
; 9785 :     assert(start >= 0);
; 9786 :     assert(start + length <= PyUnicode_GET_LENGTH(unicode));
; 9787 :     FILL(kind, data, fill_char, start, length);

  00059	48 8d 3c 57	 lea	 rdi, QWORD PTR [rdi+rdx*2]
  0005d	4d 85 c0	 test	 r8, r8
  00060	7e 1d		 jle	 SHORT $LN14@PyUnicode_@38
  00062	41 0f b7 c1	 movzx	 eax, r9w
  00066	49 8b c8	 mov	 rcx, r8
  00069	66 f3 ab	 rep stosw

; 9788 : }

  0006c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00070	5f		 pop	 rdi
  00071	c3		 ret	 0
$LN10@PyUnicode_@38:

; 9782 :     assert(PyUnicode_IS_READY(unicode));
; 9783 :     assert(unicode_modifiable(unicode));
; 9784 :     assert(fill_char <= PyUnicode_MAX_CHAR_VALUE(unicode));
; 9785 :     assert(start >= 0);
; 9786 :     assert(start + length <= PyUnicode_GET_LENGTH(unicode));
; 9787 :     FILL(kind, data, fill_char, start, length);

  00072	4a 8d 0c 17	 lea	 rcx, QWORD PTR [rdi+r10]
  00076	41 0f b6 d1	 movzx	 edx, r9b
  0007a	e8 00 00 00 00	 call	 memset
$LN14@PyUnicode_@38:

; 9788 : }

  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
_PyUnicode_FastFill ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$anylib_find DD imagerel anylib_find
	DD	imagerel anylib_find+193
	DD	imagerel $unwind$anylib_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$anylib_find DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT anylib_find
_TEXT	SEGMENT
kind$ = 64
str1$ = 72
buf1$ = 80
len1$ = 88
str2$ = 96
buf2$ = 104
len2$ = 112
offset$ = 120
anylib_find PROC					; COMDAT

; 10095: {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 10096:     switch (kind) {

  00004	ff c9		 dec	 ecx
  00006	4d 8b d1	 mov	 r10, r9
  00009	4d 8b d8	 mov	 r11, r8
  0000c	74 5a		 je	 SHORT $LN5@anylib_fin
  0000e	ff c9		 dec	 ecx
  00010	74 32		 je	 SHORT $LN3@anylib_fin
  00012	83 f9 02	 cmp	 ecx, 2
  00015	74 09		 je	 SHORT $LN1@anylib_fin

; 10106:     }
; 10107:     assert(0);
; 10108:     return -1;

  00017	48 83 c8 ff	 or	 rax, -1

; 10109: }

  0001b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001f	c3		 ret	 0
$LN1@anylib_fin:

; 10104:     case PyUnicode_4BYTE_KIND:
; 10105:         return ucs4lib_find(buf1, len1, buf2, len2, offset);

  00020	48 8b 44 24 78	 mov	 rax, QWORD PTR offset$[rsp]
  00025	4c 8b 4c 24 70	 mov	 r9, QWORD PTR len2$[rsp]
  0002a	4c 8b 44 24 68	 mov	 r8, QWORD PTR buf2$[rsp]
  0002f	49 8b d2	 mov	 rdx, r10
  00032	49 8b cb	 mov	 rcx, r11
  00035	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003a	e8 00 00 00 00	 call	 ucs4lib_find

; 10109: }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
$LN3@anylib_fin:

; 10102:     case PyUnicode_2BYTE_KIND:
; 10103:         return ucs2lib_find(buf1, len1, buf2, len2, offset);

  00044	48 8b 44 24 78	 mov	 rax, QWORD PTR offset$[rsp]
  00049	4c 8b 4c 24 70	 mov	 r9, QWORD PTR len2$[rsp]
  0004e	4c 8b 44 24 68	 mov	 r8, QWORD PTR buf2$[rsp]
  00053	49 8b d2	 mov	 rdx, r10
  00056	49 8b cb	 mov	 rcx, r11
  00059	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005e	e8 00 00 00 00	 call	 ucs2lib_find

; 10109: }

  00063	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00067	c3		 ret	 0
$LN5@anylib_fin:

; 10097:     case PyUnicode_1BYTE_KIND:
; 10098:         if (PyUnicode_IS_ASCII(str1) && PyUnicode_IS_ASCII(str2))

  00068	f6 42 70 40	 test	 BYTE PTR [rdx+112], 64	; 00000040H
  0006c	74 2f		 je	 SHORT $LN4@anylib_fin
  0006e	48 8b 44 24 60	 mov	 rax, QWORD PTR str2$[rsp]
  00073	f6 40 70 40	 test	 BYTE PTR [rax+112], 64	; 00000040H
  00077	74 24		 je	 SHORT $LN4@anylib_fin

; 10099:             return asciilib_find(buf1, len1, buf2, len2, offset);

  00079	48 8b 44 24 78	 mov	 rax, QWORD PTR offset$[rsp]
  0007e	4c 8b 4c 24 70	 mov	 r9, QWORD PTR len2$[rsp]
  00083	4c 8b 44 24 68	 mov	 r8, QWORD PTR buf2$[rsp]
  00088	49 8b d2	 mov	 rdx, r10
  0008b	49 8b cb	 mov	 rcx, r11
  0008e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00093	e8 00 00 00 00	 call	 asciilib_find

; 10109: }

  00098	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009c	c3		 ret	 0
$LN4@anylib_fin:

; 10100:         else
; 10101:             return ucs1lib_find(buf1, len1, buf2, len2, offset);

  0009d	48 8b 44 24 78	 mov	 rax, QWORD PTR offset$[rsp]
  000a2	4c 8b 4c 24 70	 mov	 r9, QWORD PTR len2$[rsp]
  000a7	4c 8b 44 24 68	 mov	 r8, QWORD PTR buf2$[rsp]
  000ac	49 8b d2	 mov	 rdx, r10
  000af	49 8b cb	 mov	 rcx, r11
  000b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b7	e8 00 00 00 00	 call	 ucs1lib_find

; 10109: }

  000bc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c0	c3		 ret	 0
anylib_find ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\count.h
pdata	SEGMENT
$pdata$anylib_count DD imagerel anylib_count
	DD	imagerel anylib_count+324
	DD	imagerel $unwind$anylib_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$anylib_count DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT anylib_count
_TEXT	SEGMENT
kind$ = 64
sstr$ = 72
sbuf$ = 80
slen$ = 88
str1$ = 96
buf1$ = 104
len1$ = 112
maxcount$ = 120
anylib_count PROC					; COMDAT

; 10114: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 10115:     switch (kind) {

  00006	ff c9		 dec	 ecx
  00008	4d 8b d1	 mov	 r10, r9
  0000b	4d 8b d8	 mov	 r11, r8
  0000e	0f 84 97 00 00
	00		 je	 $LN5@anylib_cou
  00014	ff c9		 dec	 ecx
  00016	74 54		 je	 SHORT $LN3@anylib_cou
  00018	83 f9 02	 cmp	 ecx, 2
  0001b	74 08		 je	 SHORT $LN1@anylib_cou

; 10125:     }
; 10126:     assert(0);
; 10127:     return 0;

  0001d	33 c0		 xor	 eax, eax

; 10128: }

  0001f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00023	5b		 pop	 rbx
  00024	c3		 ret	 0
$LN1@anylib_cou:

; 10123:     case PyUnicode_4BYTE_KIND:
; 10124:         return ucs4lib_count(sbuf, slen, buf1, len1, maxcount);

  00025	4d 85 c9	 test	 r9, r9
  00028	0f 88 b8 00 00
	00		 js	 $LN32@anylib_cou
  0002e	4c 8b 4c 24 70	 mov	 r9, QWORD PTR len1$[rsp]
  00033	4d 85 c9	 test	 r9, r9
  00036	0f 84 be 00 00
	00		 je	 $LN33@anylib_cou
  0003c	48 8b 44 24 78	 mov	 rax, QWORD PTR maxcount$[rsp]
  00041	4c 8b 44 24 68	 mov	 r8, QWORD PTR buf1$[rsp]
  00046	33 db		 xor	 ebx, ebx
  00048	49 8b d2	 mov	 rdx, r10
  0004b	49 8b cb	 mov	 rcx, r11
  0004e	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  00052	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00057	e8 00 00 00 00	 call	 ucs4lib_fastsearch
  0005c	48 85 c0	 test	 rax, rax
  0005f	48 0f 48 c3	 cmovs	 rax, rbx
  00063	48 8b d8	 mov	 rbx, rax

; 10128: }

  00066	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006a	5b		 pop	 rbx
  0006b	c3		 ret	 0
$LN3@anylib_cou:

; 10121:     case PyUnicode_2BYTE_KIND:
; 10122:         return ucs2lib_count(sbuf, slen, buf1, len1, maxcount);

  0006c	4d 85 c9	 test	 r9, r9
  0006f	78 75		 js	 SHORT $LN32@anylib_cou
  00071	4c 8b 4c 24 70	 mov	 r9, QWORD PTR len1$[rsp]
  00076	4d 85 c9	 test	 r9, r9
  00079	74 7f		 je	 SHORT $LN33@anylib_cou
  0007b	48 8b 44 24 78	 mov	 rax, QWORD PTR maxcount$[rsp]
  00080	4c 8b 44 24 68	 mov	 r8, QWORD PTR buf1$[rsp]
  00085	33 db		 xor	 ebx, ebx
  00087	49 8b d2	 mov	 rdx, r10
  0008a	49 8b cb	 mov	 rcx, r11
  0008d	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  00091	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00096	e8 00 00 00 00	 call	 ucs2lib_fastsearch
  0009b	48 85 c0	 test	 rax, rax
  0009e	48 0f 48 c3	 cmovs	 rax, rbx
  000a2	48 8b d8	 mov	 rbx, rax

; 10128: }

  000a5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a9	5b		 pop	 rbx
  000aa	c3		 ret	 0
$LN5@anylib_cou:

; 10116:     case PyUnicode_1BYTE_KIND:
; 10117:         if (PyUnicode_IS_ASCII(sstr) && PyUnicode_IS_ASCII(str1))

  000ab	f6 42 70 40	 test	 BYTE PTR [rdx+112], 64	; 00000040H
  000af	74 30		 je	 SHORT $LN4@anylib_cou
  000b1	48 8b 44 24 60	 mov	 rax, QWORD PTR str1$[rsp]
  000b6	f6 40 70 40	 test	 BYTE PTR [rax+112], 64	; 00000040H
  000ba	74 25		 je	 SHORT $LN4@anylib_cou

; 10118:             return asciilib_count(sbuf, slen, buf1, len1, maxcount);

  000bc	48 8b 44 24 78	 mov	 rax, QWORD PTR maxcount$[rsp]
  000c1	4c 8b 4c 24 70	 mov	 r9, QWORD PTR len1$[rsp]
  000c6	4c 8b 44 24 68	 mov	 r8, QWORD PTR buf1$[rsp]
  000cb	49 8b d2	 mov	 rdx, r10
  000ce	49 8b cb	 mov	 rcx, r11
  000d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d6	e8 00 00 00 00	 call	 asciilib_count

; 10128: }

  000db	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000df	5b		 pop	 rbx
  000e0	c3		 ret	 0
$LN4@anylib_cou:

; 10119:         else
; 10120:             return ucs1lib_count(sbuf, slen, buf1, len1, maxcount);

  000e1	4d 85 c9	 test	 r9, r9
  000e4	79 0a		 jns	 SHORT $LN12@anylib_cou
$LN32@anylib_cou:
  000e6	33 db		 xor	 ebx, ebx
  000e8	8b c3		 mov	 eax, ebx

; 10128: }

  000ea	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ee	5b		 pop	 rbx
  000ef	c3		 ret	 0

; 10119:         else
; 10120:             return ucs1lib_count(sbuf, slen, buf1, len1, maxcount);

$LN12@anylib_cou:
  000f0	4c 8b 4c 24 70	 mov	 r9, QWORD PTR len1$[rsp]
  000f5	4d 85 c9	 test	 r9, r9
  000f8	75 17		 jne	 SHORT $LN11@anylib_cou
$LN33@anylib_cou:
  000fa	48 8b 5c 24 78	 mov	 rbx, QWORD PTR maxcount$[rsp]
  000ff	4c 3b d3	 cmp	 r10, rbx
  00102	7d 37		 jge	 SHORT $LN10@anylib_cou
  00104	49 8d 5a 01	 lea	 rbx, QWORD PTR [r10+1]
  00108	48 8b c3	 mov	 rax, rbx

; 10128: }

  0010b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010f	5b		 pop	 rbx
  00110	c3		 ret	 0

; 10119:         else
; 10120:             return ucs1lib_count(sbuf, slen, buf1, len1, maxcount);

$LN11@anylib_cou:
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR maxcount$[rsp]
  00116	4c 8b 44 24 68	 mov	 r8, QWORD PTR buf1$[rsp]
  0011b	33 db		 xor	 ebx, ebx
  0011d	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  00121	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00126	49 8b d2	 mov	 rdx, r10
  00129	49 8b cb	 mov	 rcx, r11
  0012c	e8 00 00 00 00	 call	 ucs1lib_fastsearch
  00131	48 85 c0	 test	 rax, rax
  00134	48 0f 48 c3	 cmovs	 rax, rbx
  00138	48 8b d8	 mov	 rbx, rax
$LN10@anylib_cou:
  0013b	48 8b c3	 mov	 rax, rbx

; 10128: }

  0013e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00142	5b		 pop	 rbx
  00143	c3		 ret	 0
anylib_count ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_title DD imagerel unicode_title
	DD	imagerel unicode_title+53
	DD	imagerel $unwind$unicode_title
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_title DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_title
_TEXT	SEGMENT
self$ = 48
unicode_title PROC					; COMDAT

; 10417: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 10418:     if (PyUnicode_READY(self) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	75 12		 jne	 SHORT $LN1@unicode_ti
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN1@unicode_ti

; 10419:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 10421: }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
$LN1@unicode_ti:

; 10420:     return case_operation(self, do_title);

  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:do_title
  00028	48 8b cb	 mov	 rcx, rbx

; 10421: }

  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx
  00030	e9 00 00 00 00	 jmp	 case_operation
unicode_title ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_casefold DD imagerel unicode_casefold
	DD	imagerel unicode_casefold+74
	DD	imagerel $unwind$unicode_casefold
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_casefold DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_casefold
_TEXT	SEGMENT
self$ = 48
unicode_casefold PROC					; COMDAT

; 10446: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 10447:     if (PyUnicode_READY(self) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	75 12		 jne	 SHORT $LN2@unicode_ca
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN2@unicode_ca

; 10448:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 10452: }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
$LN2@unicode_ca:

; 10449:     if (PyUnicode_IS_ASCII(self))

  00021	f6 43 70 40	 test	 BYTE PTR [rbx+112], 64	; 00000040H

; 10450:         return ascii_upper_or_lower(self, 1);

  00025	48 8b cb	 mov	 rcx, rbx
  00028	74 0f		 je	 SHORT $LN1@unicode_ca
  0002a	ba 01 00 00 00	 mov	 edx, 1

; 10452: }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5b		 pop	 rbx
  00034	e9 00 00 00 00	 jmp	 ascii_upper_or_lower
$LN1@unicode_ca:

; 10451:     return case_operation(self, do_casefold);

  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:do_casefold

; 10452: }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5b		 pop	 rbx
  00045	e9 00 00 00 00	 jmp	 case_operation
unicode_casefold ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@OADGGAPL@The?5fill?5character?5must?5be?5exact@ ; `string'
PUBLIC	??_C@_0DC@MLCBFGIM@The?5fill?5character?5cannot?5be?5con@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$convert_uc DD imagerel convert_uc
	DD	imagerel convert_uc+275
	DD	imagerel $unwind$convert_uc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$convert_uc DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0DG@OADGGAPL@The?5fill?5character?5must?5be?5exact@
CONST	SEGMENT
??_C@_0DG@OADGGAPL@The?5fill?5character?5must?5be?5exact@ DB 'The fill ch'
	DB	'aracter must be exactly one character long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@MLCBFGIM@The?5fill?5character?5cannot?5be?5con@
CONST	SEGMENT
??_C@_0DC@MLCBFGIM@The?5fill?5character?5cannot?5be?5con@ DB 'The fill ch'
	DB	'aracter cannot be converted to Unicode', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT convert_uc
_TEXT	SEGMENT
obj$ = 48
addr$ = 56
convert_uc PROC						; COMDAT

; 10459: {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx

; 10460:     Py_UCS4 *fillcharloc = (Py_UCS4 *)addr;
; 10461:     PyObject *uniobj;
; 10462: 
; 10463:     uniobj = PyUnicode_FromObject(obj);

  0000d	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00012	48 8b d8	 mov	 rbx, rax

; 10464:     if (uniobj == NULL) {

  00015	48 85 c0	 test	 rax, rax
  00018	75 20		 jne	 SHORT $LN2@convert_uc

; 10465:         PyErr_SetString(PyExc_TypeError,
; 10466:                         "The fill character cannot be converted to Unicode");

  0001a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@MLCBFGIM@The?5fill?5character?5cannot?5be?5con@
  00028	e8 00 00 00 00	 call	 PyErr_SetString

; 10467:         return 0;

  0002d	33 c0		 xor	 eax, eax

; 10477:     return 1;
; 10478: }

  0002f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5f		 pop	 rdi
  00039	c3		 ret	 0
$LN2@convert_uc:

; 10468:     }
; 10469:     if (PyUnicode_GET_LENGTH(uniobj) != 1) {

  0003a	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  0003f	74 28		 je	 SHORT $LN1@convert_uc

; 10470:         PyErr_SetString(PyExc_TypeError,
; 10471:                         "The fill character must be exactly one character long");

  00041	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@OADGGAPL@The?5fill?5character?5must?5be?5exact@
  0004f	e8 00 00 00 00	 call	 PyErr_SetString

; 10472:         Py_DECREF(uniobj);

  00054	48 8b cb	 mov	 rcx, rbx
  00057	e8 00 00 00 00	 call	 _Py_DecRef

; 10473:         return 0;

  0005c	33 c0		 xor	 eax, eax

; 10477:     return 1;
; 10478: }

  0005e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
$LN1@convert_uc:

; 10474:     }
; 10475:     *fillcharloc = PyUnicode_READ_CHAR(uniobj, 0);

  00069	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0006c	8b c8		 mov	 ecx, eax
  0006e	c1 e9 02	 shr	 ecx, 2
  00071	83 e1 07	 and	 ecx, 7
  00074	83 f9 01	 cmp	 ecx, 1
  00077	75 2c		 jne	 SHORT $LN19@convert_uc
  00079	a8 20		 test	 al, 32			; 00000020H
  0007b	74 1c		 je	 SHORT $LN7@convert_uc
  0007d	a8 40		 test	 al, 64			; 00000040H
  0007f	74 0c		 je	 SHORT $LN5@convert_uc
  00081	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00088	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0008b	eb 6c		 jmp	 SHORT $LN18@convert_uc
$LN5@convert_uc:
  0008d	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00094	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00097	eb 60		 jmp	 SHORT $LN18@convert_uc
$LN7@convert_uc:
  00099	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  000a0	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000a3	eb 54		 jmp	 SHORT $LN18@convert_uc
$LN19@convert_uc:
  000a5	83 f9 02	 cmp	 ecx, 2
  000a8	75 2c		 jne	 SHORT $LN17@convert_uc
  000aa	a8 20		 test	 al, 32			; 00000020H
  000ac	74 1c		 je	 SHORT $LN11@convert_uc
  000ae	a8 40		 test	 al, 64			; 00000040H
  000b0	74 0c		 je	 SHORT $LN9@convert_uc
  000b2	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  000b9	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  000bc	eb 3b		 jmp	 SHORT $LN18@convert_uc
$LN9@convert_uc:
  000be	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  000c5	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  000c8	eb 2f		 jmp	 SHORT $LN18@convert_uc
$LN11@convert_uc:
  000ca	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  000d1	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  000d4	eb 23		 jmp	 SHORT $LN18@convert_uc
$LN17@convert_uc:
  000d6	a8 20		 test	 al, 32			; 00000020H
  000d8	74 16		 je	 SHORT $LN15@convert_uc
  000da	a8 40		 test	 al, 64			; 00000040H
  000dc	74 09		 je	 SHORT $LN13@convert_uc
  000de	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  000e5	eb 10		 jmp	 SHORT $LN16@convert_uc
$LN13@convert_uc:
  000e7	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  000ee	eb 07		 jmp	 SHORT $LN16@convert_uc
$LN15@convert_uc:
  000f0	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN16@convert_uc:
  000f7	8b 08		 mov	 ecx, DWORD PTR [rax]
$LN18@convert_uc:
  000f9	89 0f		 mov	 DWORD PTR [rdi], ecx

; 10476:     Py_DECREF(uniobj);

  000fb	48 8b cb	 mov	 rcx, rbx
  000fe	e8 00 00 00 00	 call	 _Py_DecRef

; 10477:     return 1;
; 10478: }

  00103	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00108	b8 01 00 00 00	 mov	 eax, 1
  0010d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00111	5f		 pop	 rdi
  00112	c3		 ret	 0
convert_uc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_compare DD imagerel unicode_compare
	DD	imagerel unicode_compare+304
	DD	imagerel $unwind$unicode_compare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_compare DD 0a5601H
	DD	033456H
	DD	067413H
	DD	056413H
	DD	045413H
	DD	0c011d013H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_compare
_TEXT	SEGMENT
str1$ = 24
str2$ = 32
unicode_compare PROC					; COMDAT

; 10512: {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	41 55		 push	 r13

; 10513:     int kind1, kind2;
; 10514:     void *data1, *data2;
; 10515:     Py_ssize_t len1, len2, i;
; 10516: 
; 10517:     kind1 = PyUnicode_KIND(str1);

  00013	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]

; 10518:     kind2 = PyUnicode_KIND(str2);

  00016	44 8b 42 70	 mov	 r8d, DWORD PTR [rdx+112]
  0001a	44 8b d0	 mov	 r10d, eax
  0001d	45 8b d8	 mov	 r11d, r8d
  00020	41 c1 ea 02	 shr	 r10d, 2
  00024	41 c1 eb 02	 shr	 r11d, 2
  00028	41 83 e2 07	 and	 r10d, 7
  0002c	41 83 e3 07	 and	 r11d, 7

; 10519:     data1 = PyUnicode_DATA(str1);

  00030	a8 20		 test	 al, 32			; 00000020H
  00032	74 16		 je	 SHORT $LN9@unicode_co@2
  00034	a8 40		 test	 al, 64			; 00000040H
  00036	74 09		 je	 SHORT $LN7@unicode_co@2
  00038	4c 8d 89 80 00
	00 00		 lea	 r9, QWORD PTR [rcx+128]
  0003f	eb 10		 jmp	 SHORT $LN10@unicode_co@2
$LN7@unicode_co@2:
  00041	4c 8d 89 a0 00
	00 00		 lea	 r9, QWORD PTR [rcx+160]
  00048	eb 07		 jmp	 SHORT $LN10@unicode_co@2
$LN9@unicode_co@2:
  0004a	4c 8b 89 a0 00
	00 00		 mov	 r9, QWORD PTR [rcx+160]
$LN10@unicode_co@2:
  00051	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx

; 10520:     data2 = PyUnicode_DATA(str2);

  00056	41 f6 c0 20	 test	 r8b, 32			; 00000020H
  0005a	74 18		 je	 SHORT $LN13@unicode_co@2
  0005c	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00060	74 09		 je	 SHORT $LN11@unicode_co@2
  00062	48 8d 9a 80 00
	00 00		 lea	 rbx, QWORD PTR [rdx+128]
  00069	eb 10		 jmp	 SHORT $LN14@unicode_co@2
$LN11@unicode_co@2:
  0006b	48 8d 9a a0 00
	00 00		 lea	 rbx, QWORD PTR [rdx+160]
  00072	eb 07		 jmp	 SHORT $LN14@unicode_co@2
$LN13@unicode_co@2:
  00074	48 8b 9a a0 00
	00 00		 mov	 rbx, QWORD PTR [rdx+160]
$LN14@unicode_co@2:

; 10521:     len1 = PyUnicode_GET_LENGTH(str1);

  0007b	48 8b 69 60	 mov	 rbp, QWORD PTR [rcx+96]

; 10522:     len2 = PyUnicode_GET_LENGTH(str2);

  0007f	4c 8b 62 60	 mov	 r12, QWORD PTR [rdx+96]

; 10523: 
; 10524:     for (i = 0; i < len1 && i < len2; ++i) {

  00083	33 ff		 xor	 edi, edi
  00085	8b d7		 mov	 edx, edi

; 10525:         Py_UCS4 c1, c2;
; 10526:         c1 = PyUnicode_READ(kind1, data1, i);

  00087	49 63 f2	 movsxd	 rsi, r10d

; 10527:         c2 = PyUnicode_READ(kind2, data2, i);

  0008a	4d 63 eb	 movsxd	 r13, r11d
  0008d	48 85 ed	 test	 rbp, rbp
  00090	7e 65		 jle	 SHORT $LN2@unicode_co@2

; 10521:     len1 = PyUnicode_GET_LENGTH(str1);

  00092	4c 8b d3	 mov	 r10, rbx
  00095	4c 8b db	 mov	 r11, rbx

; 10523: 
; 10524:     for (i = 0; i < len1 && i < len2; ++i) {

  00098	4c 2b cb	 sub	 r9, rbx
  0009b	0f 1f 44 00 00	 npad	 5
$LL4@unicode_co@2:
  000a0	49 3b d4	 cmp	 rdx, r12
  000a3	7d 52		 jge	 SHORT $LN2@unicode_co@2

; 10525:         Py_UCS4 c1, c2;
; 10526:         c1 = PyUnicode_READ(kind1, data1, i);

  000a5	48 83 fe 01	 cmp	 rsi, 1
  000a9	75 0b		 jne	 SHORT $LN17@unicode_co@2
  000ab	49 8d 04 11	 lea	 rax, QWORD PTR [r9+rdx]
  000af	44 0f b6 04 18	 movzx	 r8d, BYTE PTR [rax+rbx]
  000b4	eb 11		 jmp	 SHORT $LN16@unicode_co@2
$LN17@unicode_co@2:
  000b6	48 83 fe 02	 cmp	 rsi, 2
  000ba	75 07		 jne	 SHORT $LN15@unicode_co@2
  000bc	47 0f b7 04 19	 movzx	 r8d, WORD PTR [r9+r11]
  000c1	eb 04		 jmp	 SHORT $LN16@unicode_co@2
$LN15@unicode_co@2:
  000c3	47 8b 04 11	 mov	 r8d, DWORD PTR [r9+r10]
$LN16@unicode_co@2:

; 10527:         c2 = PyUnicode_READ(kind2, data2, i);

  000c7	49 83 fd 01	 cmp	 r13, 1
  000cb	75 06		 jne	 SHORT $LN21@unicode_co@2
  000cd	0f b6 0c 1a	 movzx	 ecx, BYTE PTR [rdx+rbx]
  000d1	eb 0f		 jmp	 SHORT $LN20@unicode_co@2
$LN21@unicode_co@2:
  000d3	49 83 fd 02	 cmp	 r13, 2
  000d7	75 06		 jne	 SHORT $LN19@unicode_co@2
  000d9	41 0f b7 0b	 movzx	 ecx, WORD PTR [r11]
  000dd	eb 03		 jmp	 SHORT $LN20@unicode_co@2
$LN19@unicode_co@2:
  000df	41 8b 0a	 mov	 ecx, DWORD PTR [r10]
$LN20@unicode_co@2:

; 10528: 
; 10529:         if (c1 != c2)

  000e2	44 3b c1	 cmp	 r8d, ecx
  000e5	75 1a		 jne	 SHORT $LN26@unicode_co@2

; 10523: 
; 10524:     for (i = 0; i < len1 && i < len2; ++i) {

  000e7	48 ff c2	 inc	 rdx
  000ea	49 83 c3 02	 add	 r11, 2
  000ee	49 83 c2 04	 add	 r10, 4
  000f2	48 3b d5	 cmp	 rdx, rbp
  000f5	7c a9		 jl	 SHORT $LL4@unicode_co@2
$LN2@unicode_co@2:

; 10531:     }
; 10532: 
; 10533:     return (len1 < len2) ? -1 : (len1 != len2);

  000f7	49 3b ec	 cmp	 rbp, r12
  000fa	7d 15		 jge	 SHORT $LN28@unicode_co@2
  000fc	83 cf ff	 or	 edi, -1
  000ff	eb 14		 jmp	 SHORT $LN24@unicode_co@2
$LN26@unicode_co@2:

; 10530:             return (c1 < c2) ? -1 : 1;

  00101	83 cf ff	 or	 edi, -1
  00104	b8 01 00 00 00	 mov	 eax, 1
  00109	44 3b c1	 cmp	 r8d, ecx
  0010c	0f 42 c7	 cmovb	 eax, edi
  0010f	eb 06		 jmp	 SHORT $LN5@unicode_co@2
$LN28@unicode_co@2:

; 10531:     }
; 10532: 
; 10533:     return (len1 < len2) ? -1 : (len1 != len2);

  00111	40 0f 95 c7	 setne	 dil
$LN24@unicode_co@2:
  00115	8b c7		 mov	 eax, edi
$LN5@unicode_co@2:
  00117	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]

; 10534: }

  0011c	48 8b 6c 24 20	 mov	 rbp, QWORD PTR [rsp+32]
  00121	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  00126	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  0012b	41 5d		 pop	 r13
  0012d	41 5c		 pop	 r12
  0012f	c3		 ret	 0
unicode_compare ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@HOPNFHBM@Can?8t?5compare?5?$CF?4100s?5and?5?$CF?4100s?$AA@ ; `string'
PUBLIC	PyUnicode_Compare
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_Compare DD imagerel $LN12
	DD	imagerel $LN12+150
	DD	imagerel $unwind$PyUnicode_Compare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Compare DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0CA@HOPNFHBM@Can?8t?5compare?5?$CF?4100s?5and?5?$CF?4100s?$AA@
CONST	SEGMENT
??_C@_0CA@HOPNFHBM@Can?8t?5compare?5?$CF?4100s?5and?5?$CF?4100s?$AA@ DB 'C'
	DB	'an''t compare %.100s and %.100s', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_Compare
_TEXT	SEGMENT
left$ = 48
right$ = 56
PyUnicode_Compare PROC					; COMDAT

; 10538: {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 10539:     if (PyUnicode_Check(left) && PyUnicode_Check(right)) {

  0000a	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  0000e	48 8b da	 mov	 rbx, rdx
  00011	48 8b f9	 mov	 rdi, rcx
  00014	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  0001f	74 48		 je	 SHORT $LN3@PyUnicode_@39
  00021	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00025	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0002f	74 38		 je	 SHORT $LN3@PyUnicode_@39

; 10540:         if (PyUnicode_READY(left) == -1 ||
; 10541:             PyUnicode_READY(right) == -1)

  00031	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00035	75 0a		 jne	 SHORT $LN10@PyUnicode_@39
  00037	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0003c	83 f8 ff	 cmp	 eax, -1
  0003f	74 47		 je	 SHORT $LN1@PyUnicode_@39
$LN10@PyUnicode_@39:
  00041	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00045	75 0d		 jne	 SHORT $LN11@PyUnicode_@39
  00047	48 8b cb	 mov	 rcx, rbx
  0004a	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0004f	83 f8 ff	 cmp	 eax, -1

; 10542:             return -1;

  00052	74 34		 je	 SHORT $LN1@PyUnicode_@39
$LN11@PyUnicode_@39:

; 10543:         return unicode_compare(left, right);

  00054	48 8b d3	 mov	 rdx, rbx
  00057	48 8b cf	 mov	 rcx, rdi

; 10550: }

  0005a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00063	5f		 pop	 rdi
  00064	e9 00 00 00 00	 jmp	 unicode_compare
$LN3@PyUnicode_@39:

; 10544:     }
; 10545:     PyErr_Format(PyExc_TypeError,
; 10546:                  "Can't compare %.100s and %.100s",
; 10547:                  left->ob_type->tp_name,
; 10548:                  right->ob_type->tp_name);

  00069	4c 8b 4a 58	 mov	 r9, QWORD PTR [rdx+88]
  0006d	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00071	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00078	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@HOPNFHBM@Can?8t?5compare?5?$CF?4100s?5and?5?$CF?4100s?$AA@
  00083	e8 00 00 00 00	 call	 PyErr_Format
$LN1@PyUnicode_@39:

; 10549:     return -1;

  00088	83 c8 ff	 or	 eax, -1

; 10550: }

  0008b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00090	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00094	5f		 pop	 rdi
  00095	c3		 ret	 0
PyUnicode_Compare ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_CompareWithASCIIString
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_CompareWithASCIIString DD imagerel $LN23
	DD	imagerel $LN23+235
	DD	imagerel $unwind$PyUnicode_CompareWithASCIIString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_CompareWithASCIIString DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_CompareWithASCIIString
_TEXT	SEGMENT
uni$ = 48
str$ = 56
PyUnicode_CompareWithASCIIString PROC			; COMDAT

; 10554: {

$LN23:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 10555:     Py_ssize_t i;
; 10556:     int kind;
; 10557:     void *data;
; 10558:     Py_UCS4 chr;
; 10559: 
; 10560:     assert(_PyUnicode_CHECK(uni));
; 10561:     if (PyUnicode_READY(uni) == -1)

  0000a	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	75 17		 jne	 SHORT $LN8@PyUnicode_@40
  00016	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0001b	83 f8 ff	 cmp	 eax, -1
  0001e	75 0d		 jne	 SHORT $LN8@PyUnicode_@40

; 10562:         return -1;

  00020	0b c0		 or	 eax, eax

; 10574:         return -1; /* str is longer */
; 10575:     return 0;
; 10576: }

  00022	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5f		 pop	 rdi
  0002c	c3		 ret	 0
$LN8@PyUnicode_@40:

; 10563:     kind = PyUnicode_KIND(uni);

  0002d	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00030	8b d0		 mov	 edx, eax
  00032	c1 ea 02	 shr	 edx, 2
  00035	83 e2 07	 and	 edx, 7

; 10564:     data = PyUnicode_DATA(uni);

  00038	a8 20		 test	 al, 32			; 00000020H
  0003a	74 16		 je	 SHORT $LN15@PyUnicode_@40
  0003c	a8 40		 test	 al, 64			; 00000040H
  0003e	74 09		 je	 SHORT $LN13@PyUnicode_@40
  00040	4c 8d 8b 80 00
	00 00		 lea	 r9, QWORD PTR [rbx+128]
  00047	eb 10		 jmp	 SHORT $LN16@PyUnicode_@40
$LN13@PyUnicode_@40:
  00049	4c 8d 8b a0 00
	00 00		 lea	 r9, QWORD PTR [rbx+160]
  00050	eb 07		 jmp	 SHORT $LN16@PyUnicode_@40
$LN15@PyUnicode_@40:
  00052	4c 8b 8b a0 00
	00 00		 mov	 r9, QWORD PTR [rbx+160]
$LN16@PyUnicode_@40:

; 10565:     /* Compare Unicode string and source character set string */
; 10566:     for (i = 0; (chr = PyUnicode_READ(kind, data, i)) && str[i]; i++)

  00059	4d 8b d9	 mov	 r11, r9
  0005c	33 c9		 xor	 ecx, ecx
  0005e	4c 63 d2	 movsxd	 r10, edx
  00061	4c 2b df	 sub	 r11, rdi
  00064	4c 8b c7	 mov	 r8, rdi
$LL7@PyUnicode_@40:
  00067	49 83 fa 01	 cmp	 r10, 1
  0006b	75 07		 jne	 SHORT $LN19@PyUnicode_@40
  0006d	43 0f b6 14 03	 movzx	 edx, BYTE PTR [r11+r8]
  00072	eb 11		 jmp	 SHORT $LN18@PyUnicode_@40
$LN19@PyUnicode_@40:
  00074	49 83 fa 02	 cmp	 r10, 2
  00078	75 07		 jne	 SHORT $LN17@PyUnicode_@40
  0007a	41 0f b7 14 49	 movzx	 edx, WORD PTR [r9+rcx*2]
  0007f	eb 04		 jmp	 SHORT $LN18@PyUnicode_@40
$LN17@PyUnicode_@40:
  00081	41 8b 14 89	 mov	 edx, DWORD PTR [r9+rcx*4]
$LN18@PyUnicode_@40:
  00085	85 d2		 test	 edx, edx
  00087	74 35		 je	 SHORT $LN5@PyUnicode_@40
  00089	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  0008d	84 c0		 test	 al, al
  0008f	74 2d		 je	 SHORT $LN5@PyUnicode_@40

; 10567:         if (chr != str[i])

  00091	0f be c0	 movsx	 eax, al
  00094	3b d0		 cmp	 edx, eax
  00096	75 08		 jne	 SHORT $LN22@PyUnicode_@40

; 10565:     /* Compare Unicode string and source character set string */
; 10566:     for (i = 0; (chr = PyUnicode_READ(kind, data, i)) && str[i]; i++)

  00098	48 ff c1	 inc	 rcx
  0009b	49 ff c0	 inc	 r8
  0009e	eb c7		 jmp	 SHORT $LL7@PyUnicode_@40
$LN22@PyUnicode_@40:

; 10568:             return (chr < (unsigned char)(str[i])) ? -1 : 1;

  000a0	0f b6 0c 39	 movzx	 ecx, BYTE PTR [rcx+rdi]
  000a4	41 83 c8 ff	 or	 r8d, -1
  000a8	b8 01 00 00 00	 mov	 eax, 1
  000ad	3b d1		 cmp	 edx, ecx
  000af	41 0f 42 c0	 cmovb	 eax, r8d

; 10574:         return -1; /* str is longer */
; 10575:     return 0;
; 10576: }

  000b3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bc	5f		 pop	 rdi
  000bd	c3		 ret	 0
$LN5@PyUnicode_@40:

; 10569:     /* This check keeps Python strings that end in '\0' from comparing equal
; 10570:      to C strings identical up to that point. */
; 10571:     if (PyUnicode_GET_LENGTH(uni) != i || chr)

  000be	48 39 4b 60	 cmp	 QWORD PTR [rbx+96], rcx
  000c2	75 17		 jne	 SHORT $LN2@PyUnicode_@40
  000c4	85 d2		 test	 edx, edx
  000c6	75 13		 jne	 SHORT $LN2@PyUnicode_@40

; 10573:     if (str[i])

  000c8	0f b6 04 39	 movzx	 eax, BYTE PTR [rcx+rdi]
  000cc	f6 d8		 neg	 al
  000ce	1b c0		 sbb	 eax, eax

; 10574:         return -1; /* str is longer */
; 10575:     return 0;
; 10576: }

  000d0	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000d5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
$LN2@PyUnicode_@40:

; 10572:         return 1; /* uni is longer */

  000db	b8 01 00 00 00	 mov	 eax, 1

; 10574:         return -1; /* str is longer */
; 10575:     return 0;
; 10576: }

  000e0	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000e5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e9	5f		 pop	 rdi
  000ea	c3		 ret	 0
PyUnicode_CompareWithASCIIString ENDP
_TEXT	ENDS
EXTRN	_Py_NotImplementedStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_Py_FalseStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyUnicode_RichCompare DD imagerel $LN33
	DD	imagerel $LN33+596
	DD	imagerel $unwind$PyUnicode_RichCompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_RichCompare DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT PyUnicode_RichCompare
_TEXT	SEGMENT
left$ = 64
right$ = 72
op$ = 80
PyUnicode_RichCompare PROC				; COMDAT

; 10584: {

$LN33:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 10585:     int result;
; 10586: 
; 10587:     if (PyUnicode_Check(left) && PyUnicode_Check(right)) {

  0000f	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00013	49 63 f0	 movsxd	 rsi, r8d
  00016	48 8b da	 mov	 rbx, rdx
  00019	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00023	48 8b f9	 mov	 rdi, rcx
  00026	0f 84 b2 01 00
	00		 je	 $LN18@PyUnicode_@41
  0002c	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00030	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0003a	0f 84 9e 01 00
	00		 je	 $LN18@PyUnicode_@41

; 10588:         PyObject *v;
; 10589:         if (PyUnicode_READY(left) == -1 ||
; 10590:             PyUnicode_READY(right) == -1)

  00040	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00044	75 0e		 jne	 SHORT $LN29@PyUnicode_@41
  00046	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0004b	83 f8 ff	 cmp	 eax, -1
  0004e	0f 84 78 01 00
	00		 je	 $LN16@PyUnicode_@41
$LN29@PyUnicode_@41:
  00054	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00058	75 11		 jne	 SHORT $LN30@PyUnicode_@41
  0005a	48 8b cb	 mov	 rcx, rbx
  0005d	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00062	83 f8 ff	 cmp	 eax, -1

; 10591:             return NULL;

  00065	0f 84 61 01 00
	00		 je	 $LN16@PyUnicode_@41
$LN30@PyUnicode_@41:

; 10592:         if (PyUnicode_GET_LENGTH(left) != PyUnicode_GET_LENGTH(right) ||
; 10593:             PyUnicode_KIND(left) != PyUnicode_KIND(right)) {

  0006b	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  0006f	48 39 47 60	 cmp	 QWORD PTR [rdi+96], rax
  00073	75 0a		 jne	 SHORT $LN14@PyUnicode_@41
  00075	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00078	33 47 70	 xor	 eax, DWORD PTR [rdi+112]
  0007b	a8 1c		 test	 al, 28
  0007d	74 4e		 je	 SHORT $LN12@PyUnicode_@41
$LN14@PyUnicode_@41:

; 10594:             if (op == Py_EQ) {

  0007f	83 fe 02	 cmp	 esi, 2
  00082	75 22		 jne	 SHORT $LN13@PyUnicode_@41

; 10595:                 Py_INCREF(Py_False);

  00084	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  0008b	48 8b cb	 mov	 rcx, rbx
  0008e	e8 00 00 00 00	 call	 _Py_IncRef

; 10596:                 return Py_False;

  00093	48 8b c3	 mov	 rax, rbx

; 10637: }

  00096	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009b	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000a0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a4	5f		 pop	 rdi
  000a5	c3		 ret	 0
$LN13@PyUnicode_@41:

; 10597:             }
; 10598:             if (op == Py_NE) {

  000a6	83 fe 03	 cmp	 esi, 3
  000a9	75 22		 jne	 SHORT $LN12@PyUnicode_@41

; 10599:                 Py_INCREF(Py_True);

  000ab	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_TrueStruct
  000b2	48 8b cf	 mov	 rcx, rdi
  000b5	e8 00 00 00 00	 call	 _Py_IncRef

; 10600:                 return Py_True;

  000ba	48 8b c7	 mov	 rax, rdi

; 10637: }

  000bd	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c2	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000c7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cb	5f		 pop	 rdi
  000cc	c3		 ret	 0
$LN12@PyUnicode_@41:

; 10601:             }
; 10602:         }
; 10603:         if (left == right)

  000cd	48 3b fb	 cmp	 rdi, rbx
  000d0	75 04		 jne	 SHORT $LN11@PyUnicode_@41

; 10604:             result = 0;

  000d2	33 c0		 xor	 eax, eax

; 10605:         else

  000d4	eb 0b		 jmp	 SHORT $LN10@PyUnicode_@41
$LN11@PyUnicode_@41:

; 10606:             result = unicode_compare(left, right);

  000d6	48 8b d3	 mov	 rdx, rbx
  000d9	48 8b cf	 mov	 rcx, rdi
  000dc	e8 00 00 00 00	 call	 unicode_compare
$LN10@PyUnicode_@41:

; 10607: 
; 10608:         /* Convert the return value to a Boolean */
; 10609:         switch (op) {

  000e1	83 fe 05	 cmp	 esi, 5
  000e4	0f 87 dd 00 00
	00		 ja	 $LN1@PyUnicode_@41
  000ea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  000f1	41 8b 94 b0 00
	00 00 00	 mov	 edx, DWORD PTR $LN31@PyUnicode_@41[r8+rsi*4]
  000f9	49 03 d0	 add	 rdx, r8
  000fc	ff e2		 jmp	 rdx
$LN7@PyUnicode_@41:

; 10610:         case Py_EQ:
; 10611:             v = TEST_COND(result == 0);

  000fe	85 c0		 test	 eax, eax

; 10612:             break;

  00100	e9 95 00 00 00	 jmp	 $LN32@PyUnicode_@41
$LN6@PyUnicode_@41:

; 10613:         case Py_NE:
; 10614:             v = TEST_COND(result != 0);

  00105	85 c0		 test	 eax, eax
  00107	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_TrueStruct
  0010e	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  00115	48 0f 45 df	 cmovne	 rbx, rdi

; 10631:         }
; 10632:         Py_INCREF(v);

  00119	48 8b cb	 mov	 rcx, rbx
  0011c	e8 00 00 00 00	 call	 _Py_IncRef

; 10633:         return v;

  00121	48 8b c3	 mov	 rax, rbx

; 10637: }

  00124	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00129	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0012e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00132	5f		 pop	 rdi
  00133	c3		 ret	 0
$LN5@PyUnicode_@41:

; 10615:             break;
; 10616:         case Py_LE:
; 10617:             v = TEST_COND(result <= 0);

  00134	85 c0		 test	 eax, eax
  00136	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_TrueStruct
  0013d	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  00144	48 0f 4e df	 cmovle	 rbx, rdi

; 10631:         }
; 10632:         Py_INCREF(v);

  00148	48 8b cb	 mov	 rcx, rbx
  0014b	e8 00 00 00 00	 call	 _Py_IncRef

; 10633:         return v;

  00150	48 8b c3	 mov	 rax, rbx

; 10637: }

  00153	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00158	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0015d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00161	5f		 pop	 rdi
  00162	c3		 ret	 0
$LN4@PyUnicode_@41:

; 10618:             break;
; 10619:         case Py_GE:
; 10620:             v = TEST_COND(result >= 0);

  00163	85 c0		 test	 eax, eax
  00165	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_TrueStruct
  0016c	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  00173	48 0f 49 df	 cmovns	 rbx, rdi

; 10631:         }
; 10632:         Py_INCREF(v);

  00177	48 8b cb	 mov	 rcx, rbx
  0017a	e8 00 00 00 00	 call	 _Py_IncRef

; 10633:         return v;

  0017f	48 8b c3	 mov	 rax, rbx

; 10637: }

  00182	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00187	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0018c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00190	5f		 pop	 rdi
  00191	c3		 ret	 0
$LN3@PyUnicode_@41:

; 10621:             break;
; 10622:         case Py_LT:
; 10623:             v = TEST_COND(result == -1);

  00192	83 f8 ff	 cmp	 eax, -1

; 10624:             break;

  00195	eb 03		 jmp	 SHORT $LN32@PyUnicode_@41
$LN2@PyUnicode_@41:

; 10625:         case Py_GT:
; 10626:             v = TEST_COND(result == 1);

  00197	83 f8 01	 cmp	 eax, 1
$LN32@PyUnicode_@41:
  0019a	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  001a1	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_TrueStruct
  001a8	48 0f 44 df	 cmove	 rbx, rdi

; 10631:         }
; 10632:         Py_INCREF(v);

  001ac	48 8b cb	 mov	 rcx, rbx
  001af	e8 00 00 00 00	 call	 _Py_IncRef

; 10633:         return v;

  001b4	48 8b c3	 mov	 rax, rbx

; 10637: }

  001b7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001bc	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  001c1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001c5	5f		 pop	 rdi
  001c6	c3		 ret	 0
$LN1@PyUnicode_@41:

; 10627:             break;
; 10628:         default:
; 10629:             PyErr_BadArgument();

  001c7	e8 00 00 00 00	 call	 PyErr_BadArgument
$LN16@PyUnicode_@41:

; 10630:             return NULL;

  001cc	33 c0		 xor	 eax, eax

; 10637: }

  001ce	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001d3	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  001d8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001dc	5f		 pop	 rdi
  001dd	c3		 ret	 0
$LN18@PyUnicode_@41:

; 10634:     }
; 10635: 
; 10636:     Py_RETURN_NOTIMPLEMENTED;

  001de	e8 00 00 00 00	 call	 _Py_PXCTX
  001e3	85 c0		 test	 eax, eax
  001e5	75 3c		 jne	 SHORT $LN26@PyUnicode_@41
  001e7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  001ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  001fc	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00202	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0020a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0020f	85 c0		 test	 eax, eax
  00211	75 09		 jne	 SHORT $LN25@PyUnicode_@41
  00213	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0021a	74 07		 je	 SHORT $LN26@PyUnicode_@41
$LN25@PyUnicode_@41:
  0021c	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN26@PyUnicode_@41:

; 10637: }

  00223	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00228	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0022d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00234	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00238	5f		 pop	 rdi
  00239	c3		 ret	 0
  0023a	66 90		 npad	 2
$LN31@PyUnicode_@41:
  0023c	00 00 00 00	 DD	 $LN3@PyUnicode_@41
  00240	00 00 00 00	 DD	 $LN5@PyUnicode_@41
  00244	00 00 00 00	 DD	 $LN7@PyUnicode_@41
  00248	00 00 00 00	 DD	 $LN6@PyUnicode_@41
  0024c	00 00 00 00	 DD	 $LN2@PyUnicode_@41
  00250	00 00 00 00	 DD	 $LN4@PyUnicode_@41
PyUnicode_RichCompare ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@DGPLHPLF@?8in?5?$DMstring?$DO?8?5requires?5string?5as@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_Contains DD imagerel $LN35
	DD	imagerel $LN35+489
	DD	imagerel $unwind$PyUnicode_Contains
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Contains DD 0ceb01H
	DD	0bc4ebH
	DD	0de4b2H
	DD	0cd475H
	DD	0a5470H
	DD	070045208H
	DD	030026003H
xdata	ENDS
;	COMDAT ??_C@_0DG@DGPLHPLF@?8in?5?$DMstring?$DO?8?5requires?5string?5as@
CONST	SEGMENT
??_C@_0DG@DGPLHPLF@?8in?5?$DMstring?$DO?8?5requires?5string?5as@ DB '''in'
	DB	' <string>'' requires string as left operand, not %s', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_Contains
_TEXT	SEGMENT
container$ = 80
element$ = 88
PyUnicode_Contains PROC					; COMDAT

; 10641: {

$LN35:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00008	48 8b f1	 mov	 rsi, rcx

; 10642:     PyObject *str, *sub;
; 10643:     int kind1, kind2, kind;
; 10644:     void *buf1, *buf2;
; 10645:     Py_ssize_t len1, len2;
; 10646:     int result;
; 10647: 
; 10648:     /* Coerce the two arguments */
; 10649:     sub = PyUnicode_FromObject(element);

  0000b	48 8b ca	 mov	 rcx, rdx
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00016	48 8b d8	 mov	 rbx, rax

; 10650:     if (!sub) {

  00019	48 85 c0	 test	 rax, rax
  0001c	75 26		 jne	 SHORT $LN14@PyUnicode_@42

; 10651:         PyErr_Format(PyExc_TypeError,
; 10652:                      "'in <string>' requires string as left operand, not %s",
; 10653:                      element->ob_type->tp_name);

  0001e	4c 8b 47 58	 mov	 r8, QWORD PTR [rdi+88]
  00022	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@DGPLHPLF@?8in?5?$DMstring?$DO?8?5requires?5string?5as@
  00030	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00034	e8 00 00 00 00	 call	 PyErr_Format

; 10654:         return -1;

  00039	83 c8 ff	 or	 eax, -1

; 10710: }

  0003c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00040	5f		 pop	 rdi
  00041	5e		 pop	 rsi
  00042	5b		 pop	 rbx
  00043	c3		 ret	 0
$LN14@PyUnicode_@42:

; 10655:     }
; 10656: 
; 10657:     str = PyUnicode_FromObject(container);

  00044	48 8b ce	 mov	 rcx, rsi
  00047	e8 00 00 00 00	 call	 PyUnicode_FromObject
  0004c	48 8b f8	 mov	 rdi, rax

; 10658:     if (!str) {

  0004f	48 85 c0	 test	 rax, rax
  00052	75 13		 jne	 SHORT $LN13@PyUnicode_@42

; 10659:         Py_DECREF(sub);

  00054	48 8b cb	 mov	 rcx, rbx
  00057	e8 00 00 00 00	 call	 _Py_DecRef

; 10660:         return -1;

  0005c	83 c8 ff	 or	 eax, -1

; 10710: }

  0005f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00063	5f		 pop	 rdi
  00064	5e		 pop	 rsi
  00065	5b		 pop	 rbx
  00066	c3		 ret	 0
$LN13@PyUnicode_@42:

; 10661:     }
; 10662:     if (PyUnicode_READY(sub) == -1 || PyUnicode_READY(str) == -1) {

  00067	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  0006b	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00070	4c 89 6c 24 60	 mov	 QWORD PTR [rsp+96], r13
  00075	75 0d		 jne	 SHORT $LN29@PyUnicode_@42
  00077	48 8b cb	 mov	 rcx, rbx
  0007a	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0007f	83 f8 ff	 cmp	 eax, -1
  00082	74 13		 je	 SHORT $LN11@PyUnicode_@42
$LN29@PyUnicode_@42:
  00084	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  00088	75 1d		 jne	 SHORT $LN12@PyUnicode_@42
  0008a	48 8b cf	 mov	 rcx, rdi
  0008d	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00092	83 f8 ff	 cmp	 eax, -1
  00095	75 10		 jne	 SHORT $LN12@PyUnicode_@42
$LN11@PyUnicode_@42:

; 10663:         Py_DECREF(sub);

  00097	48 8b cb	 mov	 rcx, rbx
  0009a	e8 00 00 00 00	 call	 _Py_DecRef

; 10664:         Py_DECREF(str);

  0009f	48 8b cf	 mov	 rcx, rdi
  000a2	e8 00 00 00 00	 call	 _Py_DecRef
$LN12@PyUnicode_@42:

; 10665:     }
; 10666: 
; 10667:     kind1 = PyUnicode_KIND(str);

  000a7	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]

; 10668:     kind2 = PyUnicode_KIND(sub);

  000aa	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  000ad	4c 89 74 24 68	 mov	 QWORD PTR [rsp+104], r14
  000b2	44 8b e9	 mov	 r13d, ecx

; 10669:     kind = kind1;

  000b5	8b e8		 mov	 ebp, eax
  000b7	41 c1 ed 02	 shr	 r13d, 2
  000bb	c1 ed 02	 shr	 ebp, 2
  000be	41 83 e5 07	 and	 r13d, 7
  000c2	83 e5 07	 and	 ebp, 7

; 10670:     buf1 = PyUnicode_DATA(str);

  000c5	a8 20		 test	 al, 32			; 00000020H
  000c7	74 16		 je	 SHORT $LN23@PyUnicode_@42
  000c9	a8 40		 test	 al, 64			; 00000040H
  000cb	74 09		 je	 SHORT $LN21@PyUnicode_@42
  000cd	4c 8d b7 80 00
	00 00		 lea	 r14, QWORD PTR [rdi+128]
  000d4	eb 10		 jmp	 SHORT $LN24@PyUnicode_@42
$LN21@PyUnicode_@42:
  000d6	4c 8d b7 a0 00
	00 00		 lea	 r14, QWORD PTR [rdi+160]
  000dd	eb 07		 jmp	 SHORT $LN24@PyUnicode_@42
$LN23@PyUnicode_@42:
  000df	4c 8b b7 a0 00
	00 00		 mov	 r14, QWORD PTR [rdi+160]
$LN24@PyUnicode_@42:
  000e6	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12

; 10671:     buf2 = PyUnicode_DATA(sub);

  000eb	f6 c1 20	 test	 cl, 32			; 00000020H
  000ee	74 17		 je	 SHORT $LN27@PyUnicode_@42
  000f0	f6 c1 40	 test	 cl, 64			; 00000040H
  000f3	74 09		 je	 SHORT $LN25@PyUnicode_@42
  000f5	4c 8d a3 80 00
	00 00		 lea	 r12, QWORD PTR [rbx+128]
  000fc	eb 10		 jmp	 SHORT $LN28@PyUnicode_@42
$LN25@PyUnicode_@42:
  000fe	4c 8d a3 a0 00
	00 00		 lea	 r12, QWORD PTR [rbx+160]
  00105	eb 07		 jmp	 SHORT $LN28@PyUnicode_@42
$LN27@PyUnicode_@42:
  00107	4c 8b a3 a0 00
	00 00		 mov	 r12, QWORD PTR [rbx+160]
$LN28@PyUnicode_@42:

; 10672:     if (kind2 != kind) {

  0010e	44 3b ed	 cmp	 r13d, ebp
  00111	74 23		 je	 SHORT $LN10@PyUnicode_@42

; 10674:             Py_DECREF(sub);

  00113	48 8b cb	 mov	 rcx, rbx

; 10673:         if (kind2 > kind) {

  00116	7e 14		 jle	 SHORT $LN9@PyUnicode_@42

; 10674:             Py_DECREF(sub);

  00118	e8 00 00 00 00	 call	 _Py_DecRef

; 10675:             Py_DECREF(str);

  0011d	48 8b cf	 mov	 rcx, rdi
  00120	e8 00 00 00 00	 call	 _Py_DecRef

; 10676:             return 0;

  00125	33 c0		 xor	 eax, eax
  00127	e9 a1 00 00 00	 jmp	 $LN33@PyUnicode_@42
$LN9@PyUnicode_@42:

; 10677:         }
; 10678:         buf2 = _PyUnicode_AsKind(sub, kind);

  0012c	8b d5		 mov	 edx, ebp
  0012e	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  00133	4c 8b e0	 mov	 r12, rax
$LN10@PyUnicode_@42:

; 10679:     }
; 10680:     if (!buf2) {

  00136	4d 85 e4	 test	 r12, r12
  00139	75 15		 jne	 SHORT $LN8@PyUnicode_@42

; 10681:         Py_DECREF(sub);

  0013b	48 8b cb	 mov	 rcx, rbx
  0013e	e8 00 00 00 00	 call	 _Py_DecRef

; 10682:         Py_DECREF(str);

  00143	48 8b cf	 mov	 rcx, rdi
  00146	e8 00 00 00 00	 call	 _Py_DecRef

; 10683:         return -1;

  0014b	83 c8 ff	 or	 eax, -1
  0014e	eb 7d		 jmp	 SHORT $LN33@PyUnicode_@42
$LN8@PyUnicode_@42:

; 10684:     }
; 10685:     len1 = PyUnicode_GET_LENGTH(str);

  00150	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]

; 10686:     len2 = PyUnicode_GET_LENGTH(sub);

  00154	4c 8b 4b 60	 mov	 r9, QWORD PTR [rbx+96]

; 10687: 
; 10688:     switch (kind) {

  00158	8b cd		 mov	 ecx, ebp
  0015a	ff c9		 dec	 ecx
  0015c	74 36		 je	 SHORT $LN5@PyUnicode_@42
  0015e	ff c9		 dec	 ecx
  00160	74 1e		 je	 SHORT $LN4@PyUnicode_@42
  00162	83 f9 02	 cmp	 ecx, 2
  00165	74 05		 je	 SHORT $LN3@PyUnicode_@42

; 10698:     default:
; 10699:         result = -1;

  00167	83 ce ff	 or	 esi, -1
  0016a	eb 42		 jmp	 SHORT $LN6@PyUnicode_@42
$LN3@PyUnicode_@42:

; 10695:     case PyUnicode_4BYTE_KIND:
; 10696:         result = ucs4lib_find(buf1, len1, buf2, len2, 0) != -1;

  0016c	33 f6		 xor	 esi, esi
  0016e	4d 8b c4	 mov	 r8, r12
  00171	49 8b ce	 mov	 rcx, r14
  00174	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00179	e8 00 00 00 00	 call	 ucs4lib_find

; 10697:         break;

  0017e	eb 26		 jmp	 SHORT $LN34@PyUnicode_@42
$LN4@PyUnicode_@42:

; 10691:         break;
; 10692:     case PyUnicode_2BYTE_KIND:
; 10693:         result = ucs2lib_find(buf1, len1, buf2, len2, 0) != -1;

  00180	33 f6		 xor	 esi, esi
  00182	4d 8b c4	 mov	 r8, r12
  00185	49 8b ce	 mov	 rcx, r14
  00188	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0018d	e8 00 00 00 00	 call	 ucs2lib_find

; 10694:         break;

  00192	eb 12		 jmp	 SHORT $LN34@PyUnicode_@42
$LN5@PyUnicode_@42:

; 10689:     case PyUnicode_1BYTE_KIND:
; 10690:         result = ucs1lib_find(buf1, len1, buf2, len2, 0) != -1;

  00194	33 f6		 xor	 esi, esi
  00196	4d 8b c4	 mov	 r8, r12
  00199	49 8b ce	 mov	 rcx, r14
  0019c	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  001a1	e8 00 00 00 00	 call	 ucs1lib_find
$LN34@PyUnicode_@42:
  001a6	48 83 f8 ff	 cmp	 rax, -1
  001aa	40 0f 95 c6	 setne	 sil
$LN6@PyUnicode_@42:

; 10700:         assert(0);
; 10701:     }
; 10702: 
; 10703:     Py_DECREF(str);

  001ae	48 8b cf	 mov	 rcx, rdi
  001b1	e8 00 00 00 00	 call	 _Py_DecRef

; 10704:     Py_DECREF(sub);

  001b6	48 8b cb	 mov	 rcx, rbx
  001b9	e8 00 00 00 00	 call	 _Py_DecRef

; 10705: 
; 10706:     if (kind2 != kind)

  001be	44 3b ed	 cmp	 r13d, ebp
  001c1	74 08		 je	 SHORT $LN1@PyUnicode_@42

; 10707:         PyMem_Free(buf2);

  001c3	49 8b cc	 mov	 rcx, r12
  001c6	e8 00 00 00 00	 call	 PyMem_Free
$LN1@PyUnicode_@42:

; 10708: 
; 10709:     return result;

  001cb	8b c6		 mov	 eax, esi
$LN33@PyUnicode_@42:
  001cd	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]
  001d2	4c 8b 74 24 68	 mov	 r14, QWORD PTR [rsp+104]
  001d7	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  001dc	4c 8b 6c 24 60	 mov	 r13, QWORD PTR [rsp+96]

; 10710: }

  001e1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001e5	5f		 pop	 rdi
  001e6	5e		 pop	 rsi
  001e7	5b		 pop	 rbx
  001e8	c3		 ret	 0
PyUnicode_Contains ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@FKPHENKO@strings?5are?5too?5large?5to?5concat?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyUnicode_Concat DD imagerel $LN47
	DD	imagerel $LN47+604
	DD	imagerel $unwind$PyUnicode_Concat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Concat DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
xdata	ENDS
;	COMDAT ??_C@_0CA@FKPHENKO@strings?5are?5too?5large?5to?5concat?$AA@
CONST	SEGMENT
??_C@_0CA@FKPHENKO@strings?5are?5too?5large?5to?5concat?$AA@ DB 'strings '
	DB	'are too large to concat', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT PyUnicode_Concat
_TEXT	SEGMENT
left$ = 64
right$ = 72
PyUnicode_Concat PROC					; COMDAT

; 10716: {

$LN47:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001a	48 8b da	 mov	 rbx, rdx

; 10717:     PyObject *u = NULL, *v = NULL, *w;
; 10718:     Py_UCS4 maxchar, maxchar2;
; 10719:     Py_ssize_t u_len, v_len, new_len;
; 10720: 
; 10721:     /* Coerce the two arguments */
; 10722:     u = PyUnicode_FromObject(left);

  0001d	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00022	48 8b f8	 mov	 rdi, rax

; 10723:     if (u == NULL)

  00025	48 85 c0	 test	 rax, rax
  00028	0f 84 11 02 00
	00		 je	 $LN3@PyUnicode_@43

; 10724:         goto onError;
; 10725:     v = PyUnicode_FromObject(right);

  0002e	48 8b cb	 mov	 rcx, rbx
  00031	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00036	48 8b d8	 mov	 rbx, rax

; 10726:     if (v == NULL)

  00039	48 85 c0	 test	 rax, rax
  0003c	74 5e		 je	 SHORT $onError$138003

; 10727:         goto onError;
; 10728: 
; 10729:     /* Shortcuts */
; 10730:     if (v == unicode_empty) {

  0003e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty
  00045	48 3b d8	 cmp	 rbx, rax
  00048	75 10		 jne	 SHORT $LN12@PyUnicode_@43

; 10731:         Py_DECREF(v);

  0004a	48 8b cb	 mov	 rcx, rbx
  0004d	e8 00 00 00 00	 call	 _Py_DecRef

; 10732:         return u;

  00052	48 8b c7	 mov	 rax, rdi
  00055	e9 e7 01 00 00	 jmp	 $LN15@PyUnicode_@43
$LN12@PyUnicode_@43:

; 10733:     }
; 10734:     if (u == unicode_empty) {

  0005a	48 3b f8	 cmp	 rdi, rax
  0005d	75 10		 jne	 SHORT $LN11@PyUnicode_@43

; 10735:         Py_DECREF(u);

  0005f	48 8b cf	 mov	 rcx, rdi
  00062	e8 00 00 00 00	 call	 _Py_DecRef

; 10736:         return v;

  00067	48 8b c3	 mov	 rax, rbx
  0006a	e9 d2 01 00 00	 jmp	 $LN15@PyUnicode_@43
$LN11@PyUnicode_@43:

; 10737:     }
; 10738: 
; 10739:     u_len = PyUnicode_GET_LENGTH(u);
; 10740:     v_len = PyUnicode_GET_LENGTH(v);

  0006f	48 8b 6b 60	 mov	 rbp, QWORD PTR [rbx+96]
  00073	48 8b 77 60	 mov	 rsi, QWORD PTR [rdi+96]

; 10741:     if (u_len > PY_SSIZE_T_MAX - v_len) {

  00077	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00081	48 2b c5	 sub	 rax, rbp
  00084	48 3b f0	 cmp	 rsi, rax
  00087	7e 7f		 jle	 SHORT $LN10@PyUnicode_@43

; 10742:         PyErr_SetString(PyExc_OverflowError,
; 10743:                         "strings are too large to concat");

  00089	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@FKPHENKO@strings?5are?5too?5large?5to?5concat?$AA@
  00097	e8 00 00 00 00	 call	 PyErr_SetString
$onError$138003:

; 10762: 
; 10763:   onError:
; 10764:     Py_XDECREF(u);

  0009c	e8 00 00 00 00	 call	 _Py_PXCTX
  000a1	85 c0		 test	 eax, eax
  000a3	0f 85 2c 01 00
	00		 jne	 $LN7@PyUnicode_@43
  000a9	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000ad	a8 20		 test	 al, 32			; 00000020H
  000af	0f 85 18 01 00
	00		 jne	 $LN29@PyUnicode_@43
  000b5	84 c0		 test	 al, al
  000b7	0f 88 10 01 00
	00		 js	 $LN29@PyUnicode_@43
  000bd	a8 02		 test	 al, 2
  000bf	0f 85 10 01 00
	00		 jne	 $LN7@PyUnicode_@43
  000c5	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000c9	0f 85 06 01 00
	00		 jne	 $LN7@PyUnicode_@43
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000dd	4c 8b cf	 mov	 r9, rdi
  000e0	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000e6	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ee	e8 00 00 00 00	 call	 _PyParallel_Guard
  000f3	48 8b cf	 mov	 rcx, rdi
  000f6	85 c0		 test	 eax, eax
  000f8	0f 84 c3 00 00
	00		 je	 $LN34@PyUnicode_@43
  000fe	e8 00 00 00 00	 call	 _Px_Dealloc
  00103	e9 cd 00 00 00	 jmp	 $LN7@PyUnicode_@43
$LN10@PyUnicode_@43:

; 10744:         goto onError;
; 10745:     }
; 10746:     new_len = u_len + v_len;
; 10747: 
; 10748:     maxchar = PyUnicode_MAX_CHAR_VALUE(u);

  00108	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  0010b	4c 8d 04 2e	 lea	 r8, QWORD PTR [rsi+rbp]
  0010f	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00114	41 b9 ff ff 00
	00		 mov	 r9d, 65535		; 0000ffffH
  0011a	a8 40		 test	 al, 64			; 00000040H
  0011c	74 04		 je	 SHORT $LN19@PyUnicode_@43
  0011e	8b ca		 mov	 ecx, edx
  00120	eb 1e		 jmp	 SHORT $LN18@PyUnicode_@43
$LN19@PyUnicode_@43:
  00122	c1 e8 02	 shr	 eax, 2
  00125	83 e0 07	 and	 eax, 7
  00128	83 f8 01	 cmp	 eax, 1
  0012b	75 07		 jne	 SHORT $LN17@PyUnicode_@43
  0012d	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00132	eb 0c		 jmp	 SHORT $LN18@PyUnicode_@43
$LN17@PyUnicode_@43:
  00134	b9 ff ff 10 00	 mov	 ecx, 1114111		; 0010ffffH
  00139	83 f8 02	 cmp	 eax, 2
  0013c	41 0f 44 c9	 cmove	 ecx, r9d
$LN18@PyUnicode_@43:

; 10749:     maxchar2 = PyUnicode_MAX_CHAR_VALUE(v);

  00140	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00143	a8 40		 test	 al, 64			; 00000040H
  00145	75 1e		 jne	 SHORT $LN22@PyUnicode_@43
  00147	c1 e8 02	 shr	 eax, 2
  0014a	83 e0 07	 and	 eax, 7
  0014d	83 f8 01	 cmp	 eax, 1
  00150	75 07		 jne	 SHORT $LN21@PyUnicode_@43
  00152	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  00157	eb 0c		 jmp	 SHORT $LN22@PyUnicode_@43
$LN21@PyUnicode_@43:
  00159	ba ff ff 10 00	 mov	 edx, 1114111		; 0010ffffH
  0015e	83 f8 02	 cmp	 eax, 2
  00161	41 0f 44 d1	 cmove	 edx, r9d
$LN22@PyUnicode_@43:

; 10750:     maxchar = Py_MAX(maxchar, maxchar2);

  00165	3b ca		 cmp	 ecx, edx
  00167	0f 47 d1	 cmova	 edx, ecx

; 10751: 
; 10752:     /* Concat the two Unicode strings */
; 10753:     w = PyUnicode_New(new_len, maxchar);

  0016a	49 8b c8	 mov	 rcx, r8
  0016d	e8 00 00 00 00	 call	 PyUnicode_New
  00172	4c 8b e0	 mov	 r12, rax

; 10754:     if (w == NULL)

  00175	48 85 c0	 test	 rax, rax
  00178	0f 84 1e ff ff
	ff		 je	 $onError$138003

; 10755:         goto onError;
; 10756:     _PyUnicode_FastCopyCharacters(w, 0, u, 0, u_len);

  0017e	45 33 c9	 xor	 r9d, r9d
  00181	4c 8b c7	 mov	 r8, rdi
  00184	33 d2		 xor	 edx, edx
  00186	48 8b c8	 mov	 rcx, rax
  00189	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0018e	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 10757:     _PyUnicode_FastCopyCharacters(w, u_len, v, 0, v_len);

  00193	45 33 c9	 xor	 r9d, r9d
  00196	4c 8b c3	 mov	 r8, rbx
  00199	48 8b d6	 mov	 rdx, rsi
  0019c	49 8b cc	 mov	 rcx, r12
  0019f	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  001a4	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 10758:     Py_DECREF(u);

  001a9	48 8b cf	 mov	 rcx, rdi
  001ac	e8 00 00 00 00	 call	 _Py_DecRef

; 10759:     Py_DECREF(v);

  001b1	48 8b cb	 mov	 rcx, rbx
  001b4	e8 00 00 00 00	 call	 _Py_DecRef

; 10760:     assert(_PyUnicode_CheckConsistency(w, 1));
; 10761:     return w;

  001b9	49 8b c4	 mov	 rax, r12
  001bc	e9 80 00 00 00	 jmp	 $LN15@PyUnicode_@43

; 10762: 
; 10763:   onError:
; 10764:     Py_XDECREF(u);

$LN34@PyUnicode_@43:
  001c1	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001c5	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001cb	eb 08		 jmp	 SHORT $LN7@PyUnicode_@43
$LN29@PyUnicode_@43:
  001cd	48 8b cf	 mov	 rcx, rdi
  001d0	e8 00 00 00 00	 call	 Px_DecRef
$LN7@PyUnicode_@43:

; 10765:     Py_XDECREF(v);

  001d5	48 85 db	 test	 rbx, rbx
  001d8	74 65		 je	 SHORT $LN3@PyUnicode_@43
  001da	e8 00 00 00 00	 call	 _Py_PXCTX
  001df	85 c0		 test	 eax, eax
  001e1	75 5c		 jne	 SHORT $LN3@PyUnicode_@43
  001e3	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001e7	a8 20		 test	 al, 32			; 00000020H
  001e9	75 4c		 jne	 SHORT $LN40@PyUnicode_@43
  001eb	84 c0		 test	 al, al
  001ed	78 48		 js	 SHORT $LN40@PyUnicode_@43
  001ef	a8 02		 test	 al, 2
  001f1	75 4c		 jne	 SHORT $LN3@PyUnicode_@43
  001f3	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001f7	75 46		 jne	 SHORT $LN3@PyUnicode_@43
  001f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00200	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00207	4c 8b cb	 mov	 r9, rbx
  0020a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00210	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00218	e8 00 00 00 00	 call	 _PyParallel_Guard
  0021d	48 8b cb	 mov	 rcx, rbx
  00220	85 c0		 test	 eax, eax
  00222	74 07		 je	 SHORT $LN45@PyUnicode_@43
  00224	e8 00 00 00 00	 call	 _Px_Dealloc
  00229	eb 14		 jmp	 SHORT $LN3@PyUnicode_@43
$LN45@PyUnicode_@43:
  0022b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0022f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00235	eb 08		 jmp	 SHORT $LN3@PyUnicode_@43
$LN40@PyUnicode_@43:
  00237	48 8b cb	 mov	 rcx, rbx
  0023a	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PyUnicode_@43:

; 10766:     return NULL;

  0023f	33 c0		 xor	 eax, eax
$LN15@PyUnicode_@43:

; 10767: }

  00241	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00246	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0024b	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00250	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00255	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00259	41 5c		 pop	 r12
  0025b	c3		 ret	 0
PyUnicode_Concat ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_getitem DD imagerel unicode_getitem
	DD	imagerel unicode_getitem+342
	DD	imagerel $unwind$unicode_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_getitem DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_getitem
_TEXT	SEGMENT
self$ = 48
index$ = 56
unicode_getitem PROC					; COMDAT

; 11082: {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 11083:     void *data;
; 11084:     enum PyUnicode_Kind kind;
; 11085:     Py_UCS4 ch;
; 11086:     PyObject *res;
; 11087: 
; 11088:     if (!PyUnicode_Check(self) || PyUnicode_READY(self) == -1) {

  0000a	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0001e	0f 84 20 01 00
	00		 je	 $LN13@unicode_ge
  00024	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00028	75 0e		 jne	 SHORT $LN31@unicode_ge
  0002a	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0002f	83 f8 ff	 cmp	 eax, -1
  00032	0f 84 0c 01 00
	00		 je	 $LN13@unicode_ge
$LN31@unicode_ge:

; 11091:     }
; 11092:     if (index < 0 || index >= PyUnicode_GET_LENGTH(self)) {

  00038	48 85 ff	 test	 rdi, rdi
  0003b	0f 88 e3 00 00
	00		 js	 $LN11@unicode_ge
  00041	48 3b 7b 60	 cmp	 rdi, QWORD PTR [rbx+96]
  00045	0f 8d d9 00 00
	00		 jge	 $LN11@unicode_ge

; 11094:         return NULL;
; 11095:     }
; 11096:     kind = PyUnicode_KIND(self);

  0004b	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0004e	8b c8		 mov	 ecx, eax
  00050	c1 e9 02	 shr	 ecx, 2
  00053	83 e1 07	 and	 ecx, 7

; 11097:     data = PyUnicode_DATA(self);

  00056	a8 20		 test	 al, 32			; 00000020H
  00058	74 13		 je	 SHORT $LN21@unicode_ge
  0005a	a8 40		 test	 al, 64			; 00000040H
  0005c	74 06		 je	 SHORT $LN19@unicode_ge
  0005e	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  00062	eb 10		 jmp	 SHORT $LN22@unicode_ge
$LN19@unicode_ge:
  00064	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  0006b	eb 07		 jmp	 SHORT $LN22@unicode_ge
$LN21@unicode_ge:
  0006d	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
$LN22@unicode_ge:

; 11098:     ch = PyUnicode_READ(kind, data, index);

  00074	83 f9 01	 cmp	 ecx, 1
  00077	75 06		 jne	 SHORT $LN25@unicode_ge
  00079	0f b6 1c 3b	 movzx	 ebx, BYTE PTR [rbx+rdi]
  0007d	eb 0e		 jmp	 SHORT $LN24@unicode_ge
$LN25@unicode_ge:
  0007f	83 f9 02	 cmp	 ecx, 2
  00082	75 06		 jne	 SHORT $LN23@unicode_ge
  00084	0f b7 1c 7b	 movzx	 ebx, WORD PTR [rbx+rdi*2]
  00088	eb 03		 jmp	 SHORT $LN24@unicode_ge
$LN23@unicode_ge:
  0008a	8b 1c bb	 mov	 ebx, DWORD PTR [rbx+rdi*4]
$LN24@unicode_ge:

; 11099:     if (ch < 256)

  0008d	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  00093	73 12		 jae	 SHORT $LN10@unicode_ge

; 11100:         return get_latin1_char(ch);

  00095	0f b6 cb	 movzx	 ecx, bl

; 11110: }

  00098	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a1	5f		 pop	 rdi
  000a2	e9 00 00 00 00	 jmp	 get_latin1_char
$LN10@unicode_ge:

; 11101: 
; 11102:     res = PyUnicode_New(1, ch);

  000a7	8b d3		 mov	 edx, ebx
  000a9	b9 01 00 00 00	 mov	 ecx, 1
  000ae	e8 00 00 00 00	 call	 PyUnicode_New
  000b3	4c 8b d8	 mov	 r11, rax

; 11103:     if (res == NULL)

  000b6	48 85 c0	 test	 rax, rax

; 11104:         return NULL;

  000b9	0f 84 8a 00 00
	00		 je	 $LN32@unicode_ge

; 11105:     kind = PyUnicode_KIND(res);

  000bf	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000c2	8b d0		 mov	 edx, eax
  000c4	c1 ea 02	 shr	 edx, 2
  000c7	83 e2 07	 and	 edx, 7

; 11106:     data = PyUnicode_DATA(res);

  000ca	a8 20		 test	 al, 32			; 00000020H
  000cc	74 16		 je	 SHORT $LN29@unicode_ge
  000ce	a8 40		 test	 al, 64			; 00000040H
  000d0	74 09		 je	 SHORT $LN27@unicode_ge
  000d2	49 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [r11+128]
  000d9	eb 10		 jmp	 SHORT $LN30@unicode_ge
$LN27@unicode_ge:
  000db	49 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [r11+160]
  000e2	eb 07		 jmp	 SHORT $LN30@unicode_ge
$LN29@unicode_ge:
  000e4	49 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [r11+160]
$LN30@unicode_ge:

; 11107:     PyUnicode_WRITE(kind, data, 0, ch);

  000eb	ff ca		 dec	 edx
  000ed	74 25		 je	 SHORT $LN3@unicode_ge
  000ef	ff ca		 dec	 edx
  000f1	74 10		 je	 SHORT $LN2@unicode_ge
  000f3	89 19		 mov	 DWORD PTR [rcx], ebx

; 11108:     assert(_PyUnicode_CheckConsistency(res, 1));
; 11109:     return res;

  000f5	49 8b c3	 mov	 rax, r11

; 11110: }

  000f8	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000fd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00101	5f		 pop	 rdi
  00102	c3		 ret	 0
$LN2@unicode_ge:

; 11107:     PyUnicode_WRITE(kind, data, 0, ch);

  00103	66 89 19	 mov	 WORD PTR [rcx], bx

; 11108:     assert(_PyUnicode_CheckConsistency(res, 1));
; 11109:     return res;

  00106	49 8b c3	 mov	 rax, r11

; 11110: }

  00109	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0010e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00112	5f		 pop	 rdi
  00113	c3		 ret	 0
$LN3@unicode_ge:

; 11107:     PyUnicode_WRITE(kind, data, 0, ch);

  00114	88 19		 mov	 BYTE PTR [rcx], bl

; 11108:     assert(_PyUnicode_CheckConsistency(res, 1));
; 11109:     return res;

  00116	49 8b c3	 mov	 rax, r11

; 11110: }

  00119	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0011e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00122	5f		 pop	 rdi
  00123	c3		 ret	 0
$LN11@unicode_ge:

; 11093:         PyErr_SetString(PyExc_IndexError, "string index out of range");

  00124	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0012b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@DOEPEGBG@string?5index?5out?5of?5range?$AA@
  00132	e8 00 00 00 00	 call	 PyErr_SetString
  00137	33 c0		 xor	 eax, eax

; 11110: }

  00139	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0013e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00142	5f		 pop	 rdi
  00143	c3		 ret	 0
$LN13@unicode_ge:

; 11089:         PyErr_BadArgument();

  00144	e8 00 00 00 00	 call	 PyErr_BadArgument
$LN32@unicode_ge:

; 11090:         return NULL;

  00149	33 c0		 xor	 eax, eax

; 11110: }

  0014b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00150	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00154	5f		 pop	 rdi
  00155	c3		 ret	 0
unicode_getitem ENDP
_TEXT	ENDS
EXTRN	_Py_HashSecret:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_hash DD imagerel unicode_hash
	DD	imagerel unicode_hash+380
	DD	imagerel $unwind$unicode_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_hash DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_hash
_TEXT	SEGMENT
self$ = 48
unicode_hash PROC					; COMDAT

; 11116: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 11117:     Py_ssize_t len;
; 11118:     Py_uhash_t x;  /* Unsigned for defined overflow behavior. */
; 11119: 
; 11120: #ifdef Py_DEBUG
; 11121:     assert(_Py_HashSecret_Initialized);
; 11122: #endif
; 11123:     if (_PyUnicode_HASH(self) != -1)

  00006	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	48 83 f8 ff	 cmp	 rax, -1

; 11124:         return _PyUnicode_HASH(self);

  00011	0f 85 5f 01 00
	00		 jne	 $LN16@unicode_ha

; 11125:     if (PyUnicode_READY(self) == -1)

  00017	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0001b	75 14		 jne	 SHORT $LN14@unicode_ha
  0001d	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00022	83 f8 ff	 cmp	 eax, -1
  00025	75 0a		 jne	 SHORT $LN14@unicode_ha

; 11126:         return -1;

  00027	48 83 c8 ff	 or	 rax, -1

; 11171: }

  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx
  00030	c3		 ret	 0
$LN14@unicode_ha:

; 11127:     len = PyUnicode_GET_LENGTH(self);

  00031	4c 8b 4b 60	 mov	 r9, QWORD PTR [rbx+96]
  00035	49 8b d1	 mov	 rdx, r9

; 11128:     /*
; 11129:       We make the hash of the empty string be 0, rather than using
; 11130:       (prefix ^ suffix), since this slightly obfuscates the hash secret
; 11131:     */
; 11132:     if (len == 0) {

  00038	4d 85 c9	 test	 r9, r9
  0003b	75 0c		 jne	 SHORT $LN13@unicode_ha

; 11133:         _PyUnicode_HASH(self) = 0;

  0003d	4c 89 4b 68	 mov	 QWORD PTR [rbx+104], r9

; 11134:         return 0;

  00041	33 c0		 xor	 eax, eax

; 11171: }

  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5b		 pop	 rbx
  00048	c3		 ret	 0
$LN13@unicode_ha:

; 11135:     }
; 11136: 
; 11137:     /* The hash function as a macro, gets expanded three times below. */
; 11138: #define HASH(P)                                            \
; 11139:     x ^= (Py_uhash_t) *P << 7;                             \
; 11140:     while (--len >= 0)                                     \
; 11141:         x = (_PyHASH_MULTIPLIER * x) ^ (Py_uhash_t) *P++;  \
; 11142: 
; 11143:     x = (Py_uhash_t) _Py_HashSecret.prefix;
; 11144:     switch (PyUnicode_KIND(self)) {

  00049	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0004c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _Py_HashSecret
  00053	44 8b c0	 mov	 r8d, eax
  00056	41 c1 e8 02	 shr	 r8d, 2
  0005a	41 83 e0 07	 and	 r8d, 7
  0005e	41 ff c8	 dec	 r8d
  00061	0f 84 a2 00 00
	00		 je	 $LN10@unicode_ha
  00067	41 ff c8	 dec	 r8d
  0006a	74 4f		 je	 SHORT $LN7@unicode_ha

; 11154:     }
; 11155:     default: {
; 11156:         Py_UCS4 *l;
; 11157:         assert(PyUnicode_KIND(self) == PyUnicode_4BYTE_KIND &&
; 11158:                "Impossible switch case in unicode_hash");
; 11159:         l = PyUnicode_4BYTE_DATA(self);

  0006c	a8 20		 test	 al, 32			; 00000020H
  0006e	74 16		 je	 SHORT $LN30@unicode_ha
  00070	a8 40		 test	 al, 64			; 00000040H
  00072	74 09		 je	 SHORT $LN28@unicode_ha
  00074	4c 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [rbx+128]
  0007b	eb 10		 jmp	 SHORT $LN31@unicode_ha
$LN28@unicode_ha:
  0007d	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  00084	eb 07		 jmp	 SHORT $LN31@unicode_ha
$LN30@unicode_ha:
  00086	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
$LN31@unicode_ha:

; 11160:         HASH(l);

  0008d	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00090	48 c1 e0 07	 shl	 rax, 7
  00094	48 33 c8	 xor	 rcx, rax
  00097	48 ff ca	 dec	 rdx
  0009a	0f 88 b6 00 00
	00		 js	 $LN8@unicode_ha
$LL3@unicode_ha:
  000a0	41 8b 00	 mov	 eax, DWORD PTR [r8]
  000a3	48 69 c9 43 42
	0f 00		 imul	 rcx, 1000003		; 000f4243H
  000aa	49 83 c0 04	 add	 r8, 4
  000ae	48 33 c8	 xor	 rcx, rax
  000b1	48 ff ca	 dec	 rdx
  000b4	79 ea		 jns	 SHORT $LL3@unicode_ha

; 11161:         break;

  000b6	e9 9b 00 00 00	 jmp	 $LN8@unicode_ha
$LN7@unicode_ha:

; 11148:         break;
; 11149:     }
; 11150:     case PyUnicode_2BYTE_KIND: {
; 11151:         const Py_UCS2 *s = PyUnicode_2BYTE_DATA(self);

  000bb	a8 20		 test	 al, 32			; 00000020H
  000bd	74 16		 je	 SHORT $LN26@unicode_ha
  000bf	a8 40		 test	 al, 64			; 00000040H
  000c1	74 09		 je	 SHORT $LN24@unicode_ha
  000c3	4c 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [rbx+128]
  000ca	eb 10		 jmp	 SHORT $LN27@unicode_ha
$LN24@unicode_ha:
  000cc	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  000d3	eb 07		 jmp	 SHORT $LN27@unicode_ha
$LN26@unicode_ha:
  000d5	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
$LN27@unicode_ha:

; 11152:         HASH(s);

  000dc	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
  000e0	48 c1 e0 07	 shl	 rax, 7
  000e4	48 33 c8	 xor	 rcx, rax
  000e7	48 ff ca	 dec	 rdx
  000ea	78 6a		 js	 SHORT $LN8@unicode_ha
  000ec	0f 1f 40 00	 npad	 4
$LL6@unicode_ha:
  000f0	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
  000f4	48 69 c9 43 42
	0f 00		 imul	 rcx, 1000003		; 000f4243H
  000fb	49 83 c0 02	 add	 r8, 2
  000ff	48 33 c8	 xor	 rcx, rax
  00102	48 ff ca	 dec	 rdx
  00105	79 e9		 jns	 SHORT $LL6@unicode_ha

; 11153:         break;

  00107	eb 4d		 jmp	 SHORT $LN8@unicode_ha
$LN10@unicode_ha:

; 11145:     case PyUnicode_1BYTE_KIND: {
; 11146:         const unsigned char *c = PyUnicode_1BYTE_DATA(self);

  00109	a8 20		 test	 al, 32			; 00000020H
  0010b	74 16		 je	 SHORT $LN22@unicode_ha
  0010d	a8 40		 test	 al, 64			; 00000040H
  0010f	74 09		 je	 SHORT $LN20@unicode_ha
  00111	4c 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [rbx+128]
  00118	eb 10		 jmp	 SHORT $LN23@unicode_ha
$LN20@unicode_ha:
  0011a	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  00121	eb 07		 jmp	 SHORT $LN23@unicode_ha
$LN22@unicode_ha:
  00123	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
$LN23@unicode_ha:

; 11147:         HASH(c);

  0012a	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  0012e	48 c1 e0 07	 shl	 rax, 7
  00132	48 33 c8	 xor	 rcx, rax
  00135	48 ff ca	 dec	 rdx
  00138	78 1c		 js	 SHORT $LN8@unicode_ha
  0013a	66 0f 1f 44 00
	00		 npad	 6
$LL9@unicode_ha:
  00140	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00144	48 69 c9 43 42
	0f 00		 imul	 rcx, 1000003		; 000f4243H
  0014b	49 ff c0	 inc	 r8
  0014e	48 33 c8	 xor	 rcx, rax
  00151	48 ff ca	 dec	 rdx
  00154	79 ea		 jns	 SHORT $LL9@unicode_ha
$LN8@unicode_ha:

; 11162:     }
; 11163:     }
; 11164:     x ^= (Py_uhash_t) PyUnicode_GET_LENGTH(self);
; 11165:     x ^= (Py_uhash_t) _Py_HashSecret.suffix;

  00156	4c 33 0d 08 00
	00 00		 xor	 r9, QWORD PTR _Py_HashSecret+8

; 11166: 
; 11167:     if (x == -1)

  0015d	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  00164	49 33 c9	 xor	 rcx, r9
  00167	48 83 f9 ff	 cmp	 rcx, -1
  0016b	48 0f 44 c8	 cmove	 rcx, rax

; 11168:         x = -2;
; 11169:     _PyUnicode_HASH(self) = x;

  0016f	48 89 4b 68	 mov	 QWORD PTR [rbx+104], rcx

; 11170:     return x;

  00173	48 8b c1	 mov	 rax, rcx
$LN16@unicode_ha:

; 11171: }

  00176	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0017a	5b		 pop	 rbx
  0017b	c3		 ret	 0
unicode_hash ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_IsTitlecase:PROC
EXTRN	PyBool_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_islower DD imagerel unicode_islower
	DD	imagerel unicode_islower+36
	DD	imagerel $unwind$unicode_islower
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_islower DD imagerel unicode_islower+36
	DD	imagerel unicode_islower+119
	DD	imagerel $chain$0$unicode_islower
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$unicode_islower DD imagerel unicode_islower+119
	DD	imagerel unicode_islower+149
	DD	imagerel $chain$2$unicode_islower
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$unicode_islower DD imagerel unicode_islower+149
	DD	imagerel unicode_islower+173
	DD	imagerel $chain$4$unicode_islower
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$unicode_islower DD imagerel unicode_islower+173
	DD	imagerel unicode_islower+195
	DD	imagerel $chain$6$unicode_islower
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$unicode_islower DD imagerel unicode_islower+195
	DD	imagerel unicode_islower+355
	DD	imagerel $chain$13$unicode_islower
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$unicode_islower DD imagerel unicode_islower+355
	DD	imagerel unicode_islower+359
	DD	imagerel $chain$15$unicode_islower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$unicode_islower DD 0c0021H
	DD	04e400H
	DD	05d400H
	DD	0bc400H
	DD	0a6400H
	DD	095400H
	DD	083400H
	DD	imagerel unicode_islower
	DD	imagerel unicode_islower+36
	DD	imagerel $unwind$unicode_islower
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$unicode_islower DD 0c1d21H
	DD	04e41dH
	DD	0bc416H
	DD	0a6411H
	DD	09540aH
	DD	083405H
	DD	05d400H
	DD	imagerel unicode_islower
	DD	imagerel unicode_islower+36
	DD	imagerel $unwind$unicode_islower
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$unicode_islower DD 020021H
	DD	05d400H
	DD	imagerel unicode_islower
	DD	imagerel unicode_islower+36
	DD	imagerel $unwind$unicode_islower
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$unicode_islower DD 020021H
	DD	05d400H
	DD	imagerel unicode_islower
	DD	imagerel unicode_islower+36
	DD	imagerel $unwind$unicode_islower
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$unicode_islower DD 020021H
	DD	05d400H
	DD	imagerel unicode_islower
	DD	imagerel unicode_islower+36
	DD	imagerel $unwind$unicode_islower
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_islower DD 020521H
	DD	05d405H
	DD	imagerel unicode_islower
	DD	imagerel unicode_islower+36
	DD	imagerel $unwind$unicode_islower
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_islower DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_islower
_TEXT	SEGMENT
self$ = 64
unicode_islower PROC					; COMDAT

; 11219: {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 11220:     Py_ssize_t i, length;
; 11221:     int kind;
; 11222:     void *data;
; 11223:     int cased;
; 11224: 
; 11225:     if (PyUnicode_READY(self) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	75 12		 jne	 SHORT $LN10@unicode_is
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN10@unicode_is

; 11226:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 11250: }

  0001b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001f	5f		 pop	 rdi
  00020	c3		 ret	 0
$LN10@unicode_is:

; 11227:     length = PyUnicode_GET_LENGTH(self);
; 11228:     kind = PyUnicode_KIND(self);

  00021	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00024	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  00029	4c 8b 6f 60	 mov	 r13, QWORD PTR [rdi+96]
  0002d	8b c8		 mov	 ecx, eax
  0002f	c1 e9 02	 shr	 ecx, 2
  00032	83 e1 07	 and	 ecx, 7

; 11229:     data = PyUnicode_DATA(self);

  00035	a8 20		 test	 al, 32			; 00000020H
  00037	74 13		 je	 SHORT $LN17@unicode_is
  00039	a8 40		 test	 al, 64			; 00000040H
  0003b	74 06		 je	 SHORT $LN15@unicode_is
  0003d	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  00041	eb 10		 jmp	 SHORT $LN18@unicode_is
$LN15@unicode_is:
  00043	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  0004a	eb 07		 jmp	 SHORT $LN18@unicode_is
$LN17@unicode_is:
  0004c	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
$LN18@unicode_is:

; 11230: 
; 11231:     /* Shortcut for single character strings */
; 11232:     if (length == 1)

  00053	49 83 fd 01	 cmp	 r13, 1
  00057	75 54		 jne	 SHORT $LN9@unicode_is

; 11233:         return PyBool_FromLong(
; 11234:             Py_UNICODE_ISLOWER(PyUnicode_READ(kind, data, 0)));

  00059	41 3b cd	 cmp	 ecx, r13d
  0005c	75 19		 jne	 SHORT $LN21@unicode_is
  0005e	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00061	e8 00 00 00 00	 call	 _PyUnicode_IsLowercase
  00066	8b c8		 mov	 ecx, eax
  00068	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]

; 11250: }

  0006d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00071	5f		 pop	 rdi
  00072	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN21@unicode_is:

; 11233:         return PyBool_FromLong(
; 11234:             Py_UNICODE_ISLOWER(PyUnicode_READ(kind, data, 0)));

  00077	83 f9 02	 cmp	 ecx, 2
  0007a	75 19		 jne	 SHORT $LN19@unicode_is
  0007c	0f b7 0f	 movzx	 ecx, WORD PTR [rdi]
  0007f	e8 00 00 00 00	 call	 _PyUnicode_IsLowercase
  00084	8b c8		 mov	 ecx, eax
  00086	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]

; 11250: }

  0008b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008f	5f		 pop	 rdi
  00090	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN19@unicode_is:

; 11233:         return PyBool_FromLong(
; 11234:             Py_UNICODE_ISLOWER(PyUnicode_READ(kind, data, 0)));

  00095	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00097	e8 00 00 00 00	 call	 _PyUnicode_IsLowercase
  0009c	8b c8		 mov	 ecx, eax
  0009e	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]

; 11250: }

  000a3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a7	5f		 pop	 rdi
  000a8	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN9@unicode_is:

; 11235: 
; 11236:     /* Special case for empty strings */
; 11237:     if (length == 0)

  000ad	4d 85 ed	 test	 r13, r13
  000b0	75 11		 jne	 SHORT $LN8@unicode_is

; 11238:         return PyBool_FromLong(0);

  000b2	33 c9		 xor	 ecx, ecx
  000b4	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]

; 11250: }

  000b9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000bd	5f		 pop	 rdi
  000be	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN8@unicode_is:
  000c3	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  000c8	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp

; 11239: 
; 11240:     cased = 0;

  000cd	33 ed		 xor	 ebp, ebp
  000cf	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  000d4	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12

; 11241:     for (i = 0; i < length; i++) {

  000d9	8b dd		 mov	 ebx, ebp
  000db	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14

; 11242:         const Py_UCS4 ch = PyUnicode_READ(kind, data, i);

  000e0	4c 63 e1	 movsxd	 r12, ecx
  000e3	4d 85 ed	 test	 r13, r13
  000e6	7e 51		 jle	 SHORT $LN5@unicode_is

; 11241:     for (i = 0; i < length; i++) {

  000e8	41 be 01 00 00
	00		 mov	 r14d, 1
  000ee	66 90		 npad	 2
$LL7@unicode_is:

; 11242:         const Py_UCS4 ch = PyUnicode_READ(kind, data, i);

  000f0	4d 3b e6	 cmp	 r12, r14
  000f3	75 06		 jne	 SHORT $LN25@unicode_is
  000f5	0f b6 34 3b	 movzx	 esi, BYTE PTR [rbx+rdi]
  000f9	eb 0f		 jmp	 SHORT $LN24@unicode_is
$LN25@unicode_is:
  000fb	49 83 fc 02	 cmp	 r12, 2
  000ff	75 06		 jne	 SHORT $LN23@unicode_is
  00101	0f b7 34 5f	 movzx	 esi, WORD PTR [rdi+rbx*2]
  00105	eb 03		 jmp	 SHORT $LN24@unicode_is
$LN23@unicode_is:
  00107	8b 34 9f	 mov	 esi, DWORD PTR [rdi+rbx*4]
$LN24@unicode_is:

; 11243: 
; 11244:         if (Py_UNICODE_ISUPPER(ch) || Py_UNICODE_ISTITLE(ch))

  0010a	8b ce		 mov	 ecx, esi
  0010c	e8 00 00 00 00	 call	 _PyUnicode_IsUppercase
  00111	85 c0		 test	 eax, eax
  00113	75 4e		 jne	 SHORT $LN28@unicode_is
  00115	8b ce		 mov	 ecx, esi
  00117	e8 00 00 00 00	 call	 _PyUnicode_IsTitlecase
  0011c	85 c0		 test	 eax, eax
  0011e	75 43		 jne	 SHORT $LN28@unicode_is

; 11246:         else if (!cased && Py_UNICODE_ISLOWER(ch))

  00120	85 ed		 test	 ebp, ebp
  00122	75 0d		 jne	 SHORT $LN6@unicode_is
  00124	8b ce		 mov	 ecx, esi
  00126	e8 00 00 00 00	 call	 _PyUnicode_IsLowercase
  0012b	85 c0		 test	 eax, eax
  0012d	41 0f 45 ee	 cmovne	 ebp, r14d
$LN6@unicode_is:

; 11241:     for (i = 0; i < length; i++) {

  00131	48 ff c3	 inc	 rbx
  00134	49 3b dd	 cmp	 rbx, r13
  00137	7c b7		 jl	 SHORT $LL7@unicode_is
$LN5@unicode_is:

; 11247:             cased = 1;
; 11248:     }
; 11249:     return PyBool_FromLong(cased);

  00139	8b cd		 mov	 ecx, ebp
$LN36@unicode_is:
  0013b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00140	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]
  00145	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0014a	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0014f	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
  00154	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]

; 11250: }

  00159	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0015d	5f		 pop	 rdi
  0015e	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN28@unicode_is:

; 11245:             return PyBool_FromLong(0);

  00163	33 c9		 xor	 ecx, ecx
  00165	eb d4		 jmp	 SHORT $LN36@unicode_is
unicode_islower ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_isupper DD imagerel unicode_isupper
	DD	imagerel unicode_isupper+36
	DD	imagerel $unwind$unicode_isupper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$unicode_isupper DD imagerel unicode_isupper+36
	DD	imagerel unicode_isupper+151
	DD	imagerel $chain$1$unicode_isupper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$unicode_isupper DD imagerel unicode_isupper+151
	DD	imagerel unicode_isupper+178
	DD	imagerel $chain$3$unicode_isupper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$unicode_isupper DD imagerel unicode_isupper+178
	DD	imagerel unicode_isupper+331
	DD	imagerel $chain$9$unicode_isupper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$unicode_isupper DD imagerel unicode_isupper+331
	DD	imagerel unicode_isupper+335
	DD	imagerel $chain$11$unicode_isupper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$unicode_isupper DD 0c0021H
	DD	04e400H
	DD	05d400H
	DD	0bc400H
	DD	0a6400H
	DD	095400H
	DD	083400H
	DD	imagerel unicode_isupper
	DD	imagerel unicode_isupper+36
	DD	imagerel $unwind$unicode_isupper
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$unicode_isupper DD 0c1621H
	DD	04e416H
	DD	0bc411H
	DD	0a640cH
	DD	083405H
	DD	05d400H
	DD	095400H
	DD	imagerel unicode_isupper
	DD	imagerel unicode_isupper+36
	DD	imagerel $unwind$unicode_isupper
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$unicode_isupper DD 040021H
	DD	05d400H
	DD	095400H
	DD	imagerel unicode_isupper
	DD	imagerel unicode_isupper+36
	DD	imagerel $unwind$unicode_isupper
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$unicode_isupper DD 043421H
	DD	095434H
	DD	05d405H
	DD	imagerel unicode_isupper
	DD	imagerel unicode_isupper+36
	DD	imagerel $unwind$unicode_isupper
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_isupper DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_isupper
_TEXT	SEGMENT
self$ = 64
unicode_isupper PROC					; COMDAT

; 11260: {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 11261:     Py_ssize_t i, length;
; 11262:     int kind;
; 11263:     void *data;
; 11264:     int cased;
; 11265: 
; 11266:     if (PyUnicode_READY(self) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	75 12		 jne	 SHORT $LN10@unicode_is@2
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN10@unicode_is@2

; 11267:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 11291: }

  0001b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001f	5f		 pop	 rdi
  00020	c3		 ret	 0
$LN10@unicode_is@2:

; 11268:     length = PyUnicode_GET_LENGTH(self);
; 11269:     kind = PyUnicode_KIND(self);

  00021	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00024	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  00029	4c 8b 6f 60	 mov	 r13, QWORD PTR [rdi+96]
  0002d	8b c8		 mov	 ecx, eax
  0002f	c1 e9 02	 shr	 ecx, 2
  00032	83 e1 07	 and	 ecx, 7

; 11270:     data = PyUnicode_DATA(self);

  00035	a8 20		 test	 al, 32			; 00000020H
  00037	74 13		 je	 SHORT $LN17@unicode_is@2
  00039	a8 40		 test	 al, 64			; 00000040H
  0003b	74 06		 je	 SHORT $LN15@unicode_is@2
  0003d	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  00041	eb 10		 jmp	 SHORT $LN18@unicode_is@2
$LN15@unicode_is@2:
  00043	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  0004a	eb 07		 jmp	 SHORT $LN18@unicode_is@2
$LN17@unicode_is@2:
  0004c	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
$LN18@unicode_is@2:
  00053	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp

; 11271: 
; 11272:     /* Shortcut for single character strings */
; 11273:     if (length == 1)

  00058	49 83 fd 01	 cmp	 r13, 1
  0005c	75 39		 jne	 SHORT $LN9@unicode_is@2

; 11274:         return PyBool_FromLong(
; 11275:             Py_UNICODE_ISUPPER(PyUnicode_READ(kind, data, 0)) != 0);

  0005e	41 3b cd	 cmp	 ecx, r13d
  00061	75 05		 jne	 SHORT $LN21@unicode_is@2
  00063	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00066	eb 0c		 jmp	 SHORT $LN20@unicode_is@2
$LN21@unicode_is@2:
  00068	83 f9 02	 cmp	 ecx, 2
  0006b	75 05		 jne	 SHORT $LN19@unicode_is@2
  0006d	0f b7 0f	 movzx	 ecx, WORD PTR [rdi]
  00070	eb 02		 jmp	 SHORT $LN20@unicode_is@2
$LN19@unicode_is@2:
  00072	8b 0f		 mov	 ecx, DWORD PTR [rdi]
$LN20@unicode_is@2:
  00074	e8 00 00 00 00	 call	 _PyUnicode_IsUppercase
  00079	33 ed		 xor	 ebp, ebp
  0007b	85 c0		 test	 eax, eax
  0007d	40 0f 95 c5	 setne	 bpl
  00081	8b cd		 mov	 ecx, ebp
  00083	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00088	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]

; 11291: }

  0008d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00091	5f		 pop	 rdi
  00092	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN9@unicode_is@2:

; 11276: 
; 11277:     /* Special case for empty strings */
; 11278:     if (length == 0)

  00097	4d 85 ed	 test	 r13, r13
  0009a	75 16		 jne	 SHORT $LN8@unicode_is@2

; 11279:         return PyBool_FromLong(0);

  0009c	33 c9		 xor	 ecx, ecx
  0009e	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000a3	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]

; 11291: }

  000a8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ac	5f		 pop	 rdi
  000ad	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN8@unicode_is@2:
  000b2	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 11280: 
; 11281:     cased = 0;

  000b7	33 ed		 xor	 ebp, ebp
  000b9	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  000be	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12
  000c3	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14

; 11282:     for (i = 0; i < length; i++) {

  000c8	8b dd		 mov	 ebx, ebp

; 11283:         const Py_UCS4 ch = PyUnicode_READ(kind, data, i);

  000ca	4c 63 e1	 movsxd	 r12, ecx
  000cd	4d 85 ed	 test	 r13, r13
  000d0	7e 4f		 jle	 SHORT $LN5@unicode_is@2

; 11282:     for (i = 0; i < length; i++) {

  000d2	41 be 01 00 00
	00		 mov	 r14d, 1
$LL7@unicode_is@2:

; 11283:         const Py_UCS4 ch = PyUnicode_READ(kind, data, i);

  000d8	4d 3b e6	 cmp	 r12, r14
  000db	75 06		 jne	 SHORT $LN25@unicode_is@2
  000dd	0f b6 34 3b	 movzx	 esi, BYTE PTR [rbx+rdi]
  000e1	eb 0f		 jmp	 SHORT $LN24@unicode_is@2
$LN25@unicode_is@2:
  000e3	49 83 fc 02	 cmp	 r12, 2
  000e7	75 06		 jne	 SHORT $LN23@unicode_is@2
  000e9	0f b7 34 5f	 movzx	 esi, WORD PTR [rdi+rbx*2]
  000ed	eb 03		 jmp	 SHORT $LN24@unicode_is@2
$LN23@unicode_is@2:
  000ef	8b 34 9f	 mov	 esi, DWORD PTR [rdi+rbx*4]
$LN24@unicode_is@2:

; 11284: 
; 11285:         if (Py_UNICODE_ISLOWER(ch) || Py_UNICODE_ISTITLE(ch))

  000f2	8b ce		 mov	 ecx, esi
  000f4	e8 00 00 00 00	 call	 _PyUnicode_IsLowercase
  000f9	85 c0		 test	 eax, eax
  000fb	75 4e		 jne	 SHORT $LN28@unicode_is@2
  000fd	8b ce		 mov	 ecx, esi
  000ff	e8 00 00 00 00	 call	 _PyUnicode_IsTitlecase
  00104	85 c0		 test	 eax, eax
  00106	75 43		 jne	 SHORT $LN28@unicode_is@2

; 11287:         else if (!cased && Py_UNICODE_ISUPPER(ch))

  00108	85 ed		 test	 ebp, ebp
  0010a	75 0d		 jne	 SHORT $LN6@unicode_is@2
  0010c	8b ce		 mov	 ecx, esi
  0010e	e8 00 00 00 00	 call	 _PyUnicode_IsUppercase
  00113	85 c0		 test	 eax, eax
  00115	41 0f 45 ee	 cmovne	 ebp, r14d
$LN6@unicode_is@2:

; 11282:     for (i = 0; i < length; i++) {

  00119	48 ff c3	 inc	 rbx
  0011c	49 3b dd	 cmp	 rbx, r13
  0011f	7c b7		 jl	 SHORT $LL7@unicode_is@2
$LN5@unicode_is@2:

; 11288:             cased = 1;
; 11289:     }
; 11290:     return PyBool_FromLong(cased);

  00121	8b cd		 mov	 ecx, ebp
$LN36@unicode_is@2:
  00123	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00128	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]
  0012d	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00132	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
  00137	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0013c	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]

; 11291: }

  00141	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00145	5f		 pop	 rdi
  00146	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN28@unicode_is@2:

; 11286:             return PyBool_FromLong(0);

  0014b	33 c9		 xor	 ecx, ecx
  0014d	eb d4		 jmp	 SHORT $LN36@unicode_is@2
unicode_isupper ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_istitle DD imagerel unicode_istitle
	DD	imagerel unicode_istitle+204
	DD	imagerel $unwind$unicode_istitle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$unicode_istitle DD imagerel unicode_istitle+204
	DD	imagerel unicode_istitle+364
	DD	imagerel $chain$6$unicode_istitle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$unicode_istitle DD imagerel unicode_istitle+364
	DD	imagerel unicode_istitle+385
	DD	imagerel $chain$7$unicode_istitle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$unicode_istitle DD 021H
	DD	imagerel unicode_istitle
	DD	imagerel unicode_istitle+204
	DD	imagerel $unwind$unicode_istitle
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$unicode_istitle DD 081421H
	DD	05e414H
	DD	06d40fH
	DD	0c740aH
	DD	0b6405H
	DD	imagerel unicode_istitle
	DD	imagerel unicode_istitle+204
	DD	imagerel $unwind$unicode_istitle
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_istitle DD 086001H
	DD	07c460H
	DD	04f42eH
	DD	0a5429H
	DD	030027206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_istitle
_TEXT	SEGMENT
self$ = 80
unicode_istitle PROC					; COMDAT

; 11303: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 11304:     Py_ssize_t i, length;
; 11305:     int kind;
; 11306:     void *data;
; 11307:     int cased, previous_is_cased;
; 11308: 
; 11309:     if (PyUnicode_READY(self) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	75 12		 jne	 SHORT $LN13@unicode_is@3
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN13@unicode_is@3

; 11310:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 11347: }

  0001b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
$LN13@unicode_is@3:

; 11311:     length = PyUnicode_GET_LENGTH(self);
; 11312:     kind = PyUnicode_KIND(self);

  00021	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00024	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00029	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  0002e	4c 8b 7b 60	 mov	 r15, QWORD PTR [rbx+96]
  00032	8b c8		 mov	 ecx, eax
  00034	c1 e9 02	 shr	 ecx, 2
  00037	83 e1 07	 and	 ecx, 7

; 11313:     data = PyUnicode_DATA(self);

  0003a	a8 20		 test	 al, 32			; 00000020H
  0003c	74 16		 je	 SHORT $LN20@unicode_is@3
  0003e	a8 40		 test	 al, 64			; 00000040H
  00040	74 09		 je	 SHORT $LN18@unicode_is@3
  00042	48 8d ab 80 00
	00 00		 lea	 rbp, QWORD PTR [rbx+128]
  00049	eb 10		 jmp	 SHORT $LN21@unicode_is@3
$LN18@unicode_is@3:
  0004b	48 8d ab a0 00
	00 00		 lea	 rbp, QWORD PTR [rbx+160]
  00052	eb 07		 jmp	 SHORT $LN21@unicode_is@3
$LN20@unicode_is@3:
  00054	48 8b ab a0 00
	00 00		 mov	 rbp, QWORD PTR [rbx+160]
$LN21@unicode_is@3:
  0005b	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12

; 11314: 
; 11315:     /* Shortcut for single character strings */
; 11316:     if (length == 1) {

  00060	49 83 ff 01	 cmp	 r15, 1
  00064	75 52		 jne	 SHORT $LN12@unicode_is@3

; 11317:         Py_UCS4 ch = PyUnicode_READ(kind, data, 0);

  00066	41 3b cf	 cmp	 ecx, r15d
  00069	75 06		 jne	 SHORT $LN24@unicode_is@3
  0006b	0f b6 5d 00	 movzx	 ebx, BYTE PTR [rbp]
  0006f	eb 0e		 jmp	 SHORT $LN23@unicode_is@3
$LN24@unicode_is@3:
  00071	83 f9 02	 cmp	 ecx, 2
  00074	75 06		 jne	 SHORT $LN22@unicode_is@3
  00076	0f b7 5d 00	 movzx	 ebx, WORD PTR [rbp]
  0007a	eb 03		 jmp	 SHORT $LN23@unicode_is@3
$LN22@unicode_is@3:
  0007c	8b 5d 00	 mov	 ebx, DWORD PTR [rbp]
$LN23@unicode_is@3:

; 11318:         return PyBool_FromLong((Py_UNICODE_ISTITLE(ch) != 0) ||
; 11319:                                (Py_UNICODE_ISUPPER(ch) != 0));

  0007f	8b cb		 mov	 ecx, ebx
  00081	e8 00 00 00 00	 call	 _PyUnicode_IsTitlecase
  00086	85 c0		 test	 eax, eax
  00088	75 1b		 jne	 SHORT $LN26@unicode_is@3
  0008a	8b cb		 mov	 ecx, ebx
  0008c	e8 00 00 00 00	 call	 _PyUnicode_IsUppercase
  00091	85 c0		 test	 eax, eax
  00093	75 10		 jne	 SHORT $LN26@unicode_is@3
  00095	45 33 e4	 xor	 r12d, r12d
  00098	41 8b cc	 mov	 ecx, r12d
  0009b	e8 00 00 00 00	 call	 PyBool_FromLong
  000a0	e9 c7 00 00 00	 jmp	 $LN39@unicode_is@3
$LN26@unicode_is@3:
  000a5	41 bc 01 00 00
	00		 mov	 r12d, 1
  000ab	41 8b cc	 mov	 ecx, r12d
  000ae	e8 00 00 00 00	 call	 PyBool_FromLong
  000b3	e9 b4 00 00 00	 jmp	 $LN39@unicode_is@3
$LN12@unicode_is@3:

; 11320:     }
; 11321: 
; 11322:     /* Special case for empty strings */
; 11323:     if (length == 0)

  000b8	4d 85 ff	 test	 r15, r15
  000bb	75 0c		 jne	 SHORT $LN11@unicode_is@3

; 11324:         return PyBool_FromLong(0);

  000bd	33 c9		 xor	 ecx, ecx
  000bf	e8 00 00 00 00	 call	 PyBool_FromLong
  000c4	e9 a3 00 00 00	 jmp	 $LN39@unicode_is@3
$LN11@unicode_is@3:

; 11325: 
; 11326:     cased = 0;

  000c9	45 33 e4	 xor	 r12d, r12d
  000cc	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  000d1	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  000d6	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  000db	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14

; 11329:         const Py_UCS4 ch = PyUnicode_READ(kind, data, i);

  000e0	4c 63 f1	 movsxd	 r14, ecx
  000e3	45 8b ec	 mov	 r13d, r12d
  000e6	41 8b dc	 mov	 ebx, r12d
  000e9	41 8b fc	 mov	 edi, r12d
  000ec	4d 85 ff	 test	 r15, r15
  000ef	7e 5f		 jle	 SHORT $LN8@unicode_is@3
$LL10@unicode_is@3:
  000f1	49 83 fe 01	 cmp	 r14, 1
  000f5	75 06		 jne	 SHORT $LN30@unicode_is@3
  000f7	0f b6 34 2f	 movzx	 esi, BYTE PTR [rdi+rbp]
  000fb	eb 11		 jmp	 SHORT $LN29@unicode_is@3
$LN30@unicode_is@3:
  000fd	49 83 fe 02	 cmp	 r14, 2
  00101	75 07		 jne	 SHORT $LN28@unicode_is@3
  00103	0f b7 74 7d 00	 movzx	 esi, WORD PTR [rbp+rdi*2]
  00108	eb 04		 jmp	 SHORT $LN29@unicode_is@3
$LN28@unicode_is@3:
  0010a	8b 74 bd 00	 mov	 esi, DWORD PTR [rbp+rdi*4]
$LN29@unicode_is@3:

; 11330: 
; 11331:         if (Py_UNICODE_ISUPPER(ch) || Py_UNICODE_ISTITLE(ch)) {

  0010e	8b ce		 mov	 ecx, esi
  00110	e8 00 00 00 00	 call	 _PyUnicode_IsUppercase
  00115	85 c0		 test	 eax, eax
  00117	75 23		 jne	 SHORT $LN6@unicode_is@3
  00119	8b ce		 mov	 ecx, esi
  0011b	e8 00 00 00 00	 call	 _PyUnicode_IsTitlecase
  00120	85 c0		 test	 eax, eax
  00122	75 18		 jne	 SHORT $LN6@unicode_is@3

; 11336:         }
; 11337:         else if (Py_UNICODE_ISLOWER(ch)) {

  00124	8b ce		 mov	 ecx, esi
  00126	e8 00 00 00 00	 call	 _PyUnicode_IsLowercase
  0012b	85 c0		 test	 eax, eax
  0012d	74 08		 je	 SHORT $LN3@unicode_is@3

; 11338:             if (!previous_is_cased)

  0012f	85 db		 test	 ebx, ebx
  00131	75 0d		 jne	 SHORT $LN44@unicode_is@3
$LN33@unicode_is@3:

; 11339:                 return PyBool_FromLong(0);

  00133	33 c9		 xor	 ecx, ecx
  00135	eb 1c		 jmp	 SHORT $LN45@unicode_is@3
$LN3@unicode_is@3:

; 11340:             previous_is_cased = 1;
; 11341:             cased = 1;
; 11342:         }
; 11343:         else
; 11344:             previous_is_cased = 0;

  00137	41 8b dc	 mov	 ebx, r12d
  0013a	eb 0c		 jmp	 SHORT $LN9@unicode_is@3
$LN6@unicode_is@3:

; 11332:             if (previous_is_cased)

  0013c	85 db		 test	 ebx, ebx
  0013e	75 f3		 jne	 SHORT $LN33@unicode_is@3
$LN44@unicode_is@3:

; 11333:                 return PyBool_FromLong(0);
; 11334:             previous_is_cased = 1;

  00140	bb 01 00 00 00	 mov	 ebx, 1

; 11335:             cased = 1;

  00145	44 8b eb	 mov	 r13d, ebx
$LN9@unicode_is@3:

; 11327:     previous_is_cased = 0;
; 11328:     for (i = 0; i < length; i++) {

  00148	48 ff c7	 inc	 rdi
  0014b	49 3b ff	 cmp	 rdi, r15
  0014e	7c a1		 jl	 SHORT $LL10@unicode_is@3
$LN8@unicode_is@3:

; 11345:     }
; 11346:     return PyBool_FromLong(cased);

  00150	41 8b cd	 mov	 ecx, r13d
$LN45@unicode_is@3:
  00153	e8 00 00 00 00	 call	 PyBool_FromLong
  00158	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]
  0015d	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]
  00162	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00167	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
$LN39@unicode_is@3:
  0016c	4c 8b 64 24 38	 mov	 r12, QWORD PTR [rsp+56]
  00171	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00176	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]

; 11347: }

  0017b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0017f	5b		 pop	 rbx
  00180	c3		 ret	 0
unicode_istitle ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_isspace DD imagerel unicode_isspace
	DD	imagerel unicode_isspace+36
	DD	imagerel $unwind$unicode_isspace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$unicode_isspace DD imagerel unicode_isspace+36
	DD	imagerel unicode_isspace+168
	DD	imagerel $chain$1$unicode_isspace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$unicode_isspace DD imagerel unicode_isspace+168
	DD	imagerel unicode_isspace+210
	DD	imagerel $chain$3$unicode_isspace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$unicode_isspace DD imagerel unicode_isspace+210
	DD	imagerel unicode_isspace+246
	DD	imagerel $chain$5$unicode_isspace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$unicode_isspace DD imagerel unicode_isspace+246
	DD	imagerel unicode_isspace+281
	DD	imagerel $chain$7$unicode_isspace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$unicode_isspace DD imagerel unicode_isspace+281
	DD	imagerel unicode_isspace+316
	DD	imagerel $chain$9$unicode_isspace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$unicode_isspace DD imagerel unicode_isspace+316
	DD	imagerel unicode_isspace+345
	DD	imagerel $chain$11$unicode_isspace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$unicode_isspace DD imagerel unicode_isspace+345
	DD	imagerel unicode_isspace+372
	DD	imagerel $chain$13$unicode_isspace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$17$unicode_isspace DD imagerel unicode_isspace+372
	DD	imagerel unicode_isspace+496
	DD	imagerel $chain$17$unicode_isspace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$19$unicode_isspace DD imagerel unicode_isspace+496
	DD	imagerel unicode_isspace+500
	DD	imagerel $chain$19$unicode_isspace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$19$unicode_isspace DD 080021H
	DD	09c400H
	DD	087400H
	DD	076400H
	DD	065400H
	DD	imagerel unicode_isspace
	DD	imagerel unicode_isspace+36
	DD	imagerel $unwind$unicode_isspace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$17$unicode_isspace DD 080a21H
	DD	08740aH
	DD	076405H
	DD	09c400H
	DD	065400H
	DD	imagerel unicode_isspace
	DD	imagerel unicode_isspace+36
	DD	imagerel $unwind$unicode_isspace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$unicode_isspace DD 040021H
	DD	09c400H
	DD	065400H
	DD	imagerel unicode_isspace
	DD	imagerel unicode_isspace+36
	DD	imagerel $unwind$unicode_isspace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$unicode_isspace DD 040021H
	DD	09c400H
	DD	065400H
	DD	imagerel unicode_isspace
	DD	imagerel unicode_isspace+36
	DD	imagerel $unwind$unicode_isspace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$unicode_isspace DD 040021H
	DD	09c400H
	DD	065400H
	DD	imagerel unicode_isspace
	DD	imagerel unicode_isspace+36
	DD	imagerel $unwind$unicode_isspace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$unicode_isspace DD 040021H
	DD	09c400H
	DD	065400H
	DD	imagerel unicode_isspace
	DD	imagerel unicode_isspace+36
	DD	imagerel $unwind$unicode_isspace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$unicode_isspace DD 040021H
	DD	09c400H
	DD	065400H
	DD	imagerel unicode_isspace
	DD	imagerel unicode_isspace+36
	DD	imagerel $unwind$unicode_isspace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$unicode_isspace DD 040021H
	DD	09c400H
	DD	065400H
	DD	imagerel unicode_isspace
	DD	imagerel unicode_isspace+36
	DD	imagerel $unwind$unicode_isspace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$unicode_isspace DD 043421H
	DD	09c434H
	DD	065405H
	DD	imagerel unicode_isspace
	DD	imagerel unicode_isspace+36
	DD	imagerel $unwind$unicode_isspace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_isspace DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_isspace
_TEXT	SEGMENT
self$ = 48
unicode_isspace PROC					; COMDAT

; 11357: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 11358:     Py_ssize_t i, length;
; 11359:     int kind;
; 11360:     void *data;
; 11361: 
; 11362:     if (PyUnicode_READY(self) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	75 12		 jne	 SHORT $LN7@unicode_is@4
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN7@unicode_is@4

; 11363:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 11383: }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
$LN7@unicode_is@4:

; 11364:     length = PyUnicode_GET_LENGTH(self);
; 11365:     kind = PyUnicode_KIND(self);

  00021	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00024	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00029	48 8b 6b 60	 mov	 rbp, QWORD PTR [rbx+96]
  0002d	8b c8		 mov	 ecx, eax
  0002f	c1 e9 02	 shr	 ecx, 2
  00032	83 e1 07	 and	 ecx, 7

; 11366:     data = PyUnicode_DATA(self);

  00035	a8 20		 test	 al, 32			; 00000020H
  00037	74 13		 je	 SHORT $LN14@unicode_is@4
  00039	a8 40		 test	 al, 64			; 00000040H
  0003b	74 06		 je	 SHORT $LN12@unicode_is@4
  0003d	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  00041	eb 10		 jmp	 SHORT $LN15@unicode_is@4
$LN12@unicode_is@4:
  00043	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  0004a	eb 07		 jmp	 SHORT $LN15@unicode_is@4
$LN14@unicode_is@4:
  0004c	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
$LN15@unicode_is@4:
  00053	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12

; 11367: 
; 11368:     /* Shortcut for single character strings */
; 11369:     if (length == 1)

  00058	48 83 fd 01	 cmp	 rbp, 1
  0005c	0f 85 f7 00 00
	00		 jne	 $LN6@unicode_is@4

; 11370:         return PyBool_FromLong(
; 11371:             Py_UNICODE_ISSPACE(PyUnicode_READ(kind, data, 0)));

  00062	3b cd		 cmp	 ecx, ebp
  00064	75 05		 jne	 SHORT $LN18@unicode_is@4
  00066	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00069	eb 0c		 jmp	 SHORT $LN17@unicode_is@4
$LN18@unicode_is@4:
  0006b	83 f9 02	 cmp	 ecx, 2
  0006e	75 05		 jne	 SHORT $LN16@unicode_is@4
  00070	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00073	eb 02		 jmp	 SHORT $LN17@unicode_is@4
$LN16@unicode_is@4:
  00075	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN17@unicode_is@4:
  00077	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0007c	73 78		 jae	 SHORT $LN28@unicode_is@4
  0007e	83 f9 01	 cmp	 ecx, 1
  00081	75 25		 jne	 SHORT $LN22@unicode_is@4
  00083	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00086	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_ascii_whitespace
  0008d	42 0f b6 04 20	 movzx	 eax, BYTE PTR [rax+r12]
  00092	8b c8		 mov	 ecx, eax
  00094	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  00099	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 11383: }

  0009e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a2	5b		 pop	 rbx
  000a3	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN22@unicode_is@4:

; 11370:         return PyBool_FromLong(
; 11371:             Py_UNICODE_ISSPACE(PyUnicode_READ(kind, data, 0)));

  000a8	83 f9 02	 cmp	 ecx, 2
  000ab	75 25		 jne	 SHORT $LN20@unicode_is@4
  000ad	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  000b0	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_ascii_whitespace
  000b7	42 0f b6 04 20	 movzx	 eax, BYTE PTR [rax+r12]
  000bc	8b c8		 mov	 ecx, eax
  000be	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  000c3	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 11383: }

  000c8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cc	5b		 pop	 rbx
  000cd	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN20@unicode_is@4:

; 11370:         return PyBool_FromLong(
; 11371:             Py_UNICODE_ISSPACE(PyUnicode_READ(kind, data, 0)));

  000d2	8b 03		 mov	 eax, DWORD PTR [rbx]
  000d4	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_ascii_whitespace
  000db	42 0f b6 04 20	 movzx	 eax, BYTE PTR [rax+r12]
  000e0	8b c8		 mov	 ecx, eax
  000e2	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  000e7	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 11383: }

  000ec	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f0	5b		 pop	 rbx
  000f1	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN28@unicode_is@4:

; 11370:         return PyBool_FromLong(
; 11371:             Py_UNICODE_ISSPACE(PyUnicode_READ(kind, data, 0)));

  000f6	83 f9 01	 cmp	 ecx, 1
  000f9	75 1e		 jne	 SHORT $LN26@unicode_is@4
  000fb	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  000fe	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  00103	8b c8		 mov	 ecx, eax
  00105	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  0010a	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 11383: }

  0010f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00113	5b		 pop	 rbx
  00114	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN26@unicode_is@4:

; 11370:         return PyBool_FromLong(
; 11371:             Py_UNICODE_ISSPACE(PyUnicode_READ(kind, data, 0)));

  00119	83 f9 02	 cmp	 ecx, 2
  0011c	75 1e		 jne	 SHORT $LN24@unicode_is@4
  0011e	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00121	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  00126	8b c8		 mov	 ecx, eax
  00128	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  0012d	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 11383: }

  00132	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00136	5b		 pop	 rbx
  00137	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN24@unicode_is@4:

; 11370:         return PyBool_FromLong(
; 11371:             Py_UNICODE_ISSPACE(PyUnicode_READ(kind, data, 0)));

  0013c	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  0013e	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  00143	8b c8		 mov	 ecx, eax
  00145	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  0014a	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 11383: }

  0014f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00153	5b		 pop	 rbx
  00154	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN6@unicode_is@4:

; 11372: 
; 11373:     /* Special case for empty strings */
; 11374:     if (length == 0)

  00159	48 85 ed	 test	 rbp, rbp
  0015c	75 16		 jne	 SHORT $LN5@unicode_is@4

; 11375:         return PyBool_FromLong(0);

  0015e	33 c9		 xor	 ecx, ecx
  00160	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  00165	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 11383: }

  0016a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016e	5b		 pop	 rbx
  0016f	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN5@unicode_is@4:
  00174	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00179	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 11376: 
; 11377:     for (i = 0; i < length; i++) {

  0017e	33 ff		 xor	 edi, edi

; 11378:         const Py_UCS4 ch = PyUnicode_READ(kind, data, i);

  00180	48 63 f1	 movsxd	 rsi, ecx
  00183	48 85 ed	 test	 rbp, rbp
  00186	7e 45		 jle	 SHORT $LN2@unicode_is@4

; 11376: 
; 11377:     for (i = 0; i < length; i++) {

  00188	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_ascii_whitespace
  0018f	90		 npad	 1
$LL4@unicode_is@4:

; 11378:         const Py_UCS4 ch = PyUnicode_READ(kind, data, i);

  00190	48 83 fe 01	 cmp	 rsi, 1
  00194	75 06		 jne	 SHORT $LN32@unicode_is@4
  00196	0f b6 0c 1f	 movzx	 ecx, BYTE PTR [rdi+rbx]
  0019a	eb 0f		 jmp	 SHORT $LN31@unicode_is@4
$LN32@unicode_is@4:
  0019c	48 83 fe 02	 cmp	 rsi, 2
  001a0	75 06		 jne	 SHORT $LN30@unicode_is@4
  001a2	0f b7 0c 7b	 movzx	 ecx, WORD PTR [rbx+rdi*2]
  001a6	eb 03		 jmp	 SHORT $LN31@unicode_is@4
$LN30@unicode_is@4:
  001a8	8b 0c bb	 mov	 ecx, DWORD PTR [rbx+rdi*4]
$LN31@unicode_is@4:

; 11379:         if (!Py_UNICODE_ISSPACE(ch))

  001ab	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  001b1	73 09		 jae	 SHORT $LN34@unicode_is@4
  001b3	8b c1		 mov	 eax, ecx
  001b5	42 0f b6 04 20	 movzx	 eax, BYTE PTR [rax+r12]
  001ba	eb 05		 jmp	 SHORT $LN35@unicode_is@4
$LN34@unicode_is@4:
  001bc	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
$LN35@unicode_is@4:
  001c1	85 c0		 test	 eax, eax
  001c3	74 2b		 je	 SHORT $LN37@unicode_is@4

; 11376: 
; 11377:     for (i = 0; i < length; i++) {

  001c5	48 ff c7	 inc	 rdi
  001c8	48 3b fd	 cmp	 rdi, rbp
  001cb	7c c3		 jl	 SHORT $LL4@unicode_is@4
$LN2@unicode_is@4:

; 11381:     }
; 11382:     return PyBool_FromLong(1);

  001cd	b9 01 00 00 00	 mov	 ecx, 1
$LN43@unicode_is@4:
  001d2	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  001d7	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001dc	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  001e1	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 11383: }

  001e6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001ea	5b		 pop	 rbx
  001eb	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN37@unicode_is@4:

; 11380:             return PyBool_FromLong(0);

  001f0	33 c9		 xor	 ecx, ecx
  001f2	eb de		 jmp	 SHORT $LN43@unicode_is@4
unicode_isspace ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_IsAlpha:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_isalpha DD imagerel unicode_isalpha
	DD	imagerel unicode_isalpha+36
	DD	imagerel $unwind$unicode_isalpha
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_isalpha DD imagerel unicode_isalpha+36
	DD	imagerel unicode_isalpha+118
	DD	imagerel $chain$0$unicode_isalpha
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$unicode_isalpha DD imagerel unicode_isalpha+118
	DD	imagerel unicode_isalpha+148
	DD	imagerel $chain$2$unicode_isalpha
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$unicode_isalpha DD imagerel unicode_isalpha+148
	DD	imagerel unicode_isalpha+172
	DD	imagerel $chain$4$unicode_isalpha
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$unicode_isalpha DD imagerel unicode_isalpha+172
	DD	imagerel unicode_isalpha+194
	DD	imagerel $chain$6$unicode_isalpha
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$unicode_isalpha DD imagerel unicode_isalpha+194
	DD	imagerel unicode_isalpha+288
	DD	imagerel $chain$10$unicode_isalpha
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$unicode_isalpha DD imagerel unicode_isalpha+288
	DD	imagerel unicode_isalpha+292
	DD	imagerel $chain$12$unicode_isalpha
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$unicode_isalpha DD 060021H
	DD	086400H
	DD	075400H
	DD	063400H
	DD	imagerel unicode_isalpha
	DD	imagerel unicode_isalpha+36
	DD	imagerel $unwind$unicode_isalpha
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$unicode_isalpha DD 060c21H
	DD	08640cH
	DD	063405H
	DD	075400H
	DD	imagerel unicode_isalpha
	DD	imagerel unicode_isalpha+36
	DD	imagerel $unwind$unicode_isalpha
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$unicode_isalpha DD 020021H
	DD	075400H
	DD	imagerel unicode_isalpha
	DD	imagerel unicode_isalpha+36
	DD	imagerel $unwind$unicode_isalpha
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$unicode_isalpha DD 020021H
	DD	075400H
	DD	imagerel unicode_isalpha
	DD	imagerel unicode_isalpha+36
	DD	imagerel $unwind$unicode_isalpha
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$unicode_isalpha DD 020021H
	DD	075400H
	DD	imagerel unicode_isalpha
	DD	imagerel unicode_isalpha+36
	DD	imagerel $unwind$unicode_isalpha
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_isalpha DD 020521H
	DD	075405H
	DD	imagerel unicode_isalpha
	DD	imagerel unicode_isalpha+36
	DD	imagerel $unwind$unicode_isalpha
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_isalpha DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_isalpha
_TEXT	SEGMENT
self$ = 48
unicode_isalpha PROC					; COMDAT

; 11393: {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 11394:     Py_ssize_t i, length;
; 11395:     int kind;
; 11396:     void *data;
; 11397: 
; 11398:     if (PyUnicode_READY(self) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	75 12		 jne	 SHORT $LN7@unicode_is@5
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN7@unicode_is@5

; 11399:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 11418: }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5f		 pop	 rdi
  00020	c3		 ret	 0
$LN7@unicode_is@5:

; 11400:     length = PyUnicode_GET_LENGTH(self);
; 11401:     kind = PyUnicode_KIND(self);

  00021	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00024	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00029	48 8b 6f 60	 mov	 rbp, QWORD PTR [rdi+96]
  0002d	8b c8		 mov	 ecx, eax
  0002f	c1 e9 02	 shr	 ecx, 2
  00032	83 e1 07	 and	 ecx, 7

; 11402:     data = PyUnicode_DATA(self);

  00035	a8 20		 test	 al, 32			; 00000020H
  00037	74 13		 je	 SHORT $LN14@unicode_is@5
  00039	a8 40		 test	 al, 64			; 00000040H
  0003b	74 06		 je	 SHORT $LN12@unicode_is@5
  0003d	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  00041	eb 10		 jmp	 SHORT $LN15@unicode_is@5
$LN12@unicode_is@5:
  00043	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  0004a	eb 07		 jmp	 SHORT $LN15@unicode_is@5
$LN14@unicode_is@5:
  0004c	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
$LN15@unicode_is@5:

; 11403: 
; 11404:     /* Shortcut for single character strings */
; 11405:     if (length == 1)

  00053	48 83 fd 01	 cmp	 rbp, 1
  00057	75 53		 jne	 SHORT $LN6@unicode_is@5

; 11406:         return PyBool_FromLong(
; 11407:             Py_UNICODE_ISALPHA(PyUnicode_READ(kind, data, 0)));

  00059	3b cd		 cmp	 ecx, ebp
  0005b	75 19		 jne	 SHORT $LN18@unicode_is@5
  0005d	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00060	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  00065	8b c8		 mov	 ecx, eax
  00067	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11418: }

  0006c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00070	5f		 pop	 rdi
  00071	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN18@unicode_is@5:

; 11406:         return PyBool_FromLong(
; 11407:             Py_UNICODE_ISALPHA(PyUnicode_READ(kind, data, 0)));

  00076	83 f9 02	 cmp	 ecx, 2
  00079	75 19		 jne	 SHORT $LN16@unicode_is@5
  0007b	0f b7 0f	 movzx	 ecx, WORD PTR [rdi]
  0007e	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  00083	8b c8		 mov	 ecx, eax
  00085	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11418: }

  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5f		 pop	 rdi
  0008f	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN16@unicode_is@5:

; 11406:         return PyBool_FromLong(
; 11407:             Py_UNICODE_ISALPHA(PyUnicode_READ(kind, data, 0)));

  00094	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00096	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  0009b	8b c8		 mov	 ecx, eax
  0009d	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11418: }

  000a2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a6	5f		 pop	 rdi
  000a7	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN6@unicode_is@5:

; 11408: 
; 11409:     /* Special case for empty strings */
; 11410:     if (length == 0)

  000ac	48 85 ed	 test	 rbp, rbp
  000af	75 11		 jne	 SHORT $LN5@unicode_is@5

; 11411:         return PyBool_FromLong(0);

  000b1	33 c9		 xor	 ecx, ecx
  000b3	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11418: }

  000b8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bc	5f		 pop	 rdi
  000bd	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN5@unicode_is@5:
  000c2	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 11412: 
; 11413:     for (i = 0; i < length; i++) {

  000c7	33 db		 xor	 ebx, ebx
  000c9	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi

; 11414:         if (!Py_UNICODE_ISALPHA(PyUnicode_READ(kind, data, i)))

  000ce	48 63 f1	 movsxd	 rsi, ecx
  000d1	48 85 ed	 test	 rbp, rbp
  000d4	7e 2c		 jle	 SHORT $LN2@unicode_is@5
$LL4@unicode_is@5:
  000d6	48 83 fe 01	 cmp	 rsi, 1
  000da	75 06		 jne	 SHORT $LN22@unicode_is@5
  000dc	0f b6 0c 3b	 movzx	 ecx, BYTE PTR [rbx+rdi]
  000e0	eb 0f		 jmp	 SHORT $LN21@unicode_is@5
$LN22@unicode_is@5:
  000e2	48 83 fe 02	 cmp	 rsi, 2
  000e6	75 06		 jne	 SHORT $LN20@unicode_is@5
  000e8	0f b7 0c 5f	 movzx	 ecx, WORD PTR [rdi+rbx*2]
  000ec	eb 03		 jmp	 SHORT $LN21@unicode_is@5
$LN20@unicode_is@5:

; 11412: 
; 11413:     for (i = 0; i < length; i++) {

  000ee	8b 0c 9f	 mov	 ecx, DWORD PTR [rdi+rbx*4]
$LN21@unicode_is@5:

; 11414:         if (!Py_UNICODE_ISALPHA(PyUnicode_READ(kind, data, i)))

  000f1	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  000f6	85 c0		 test	 eax, eax
  000f8	74 26		 je	 SHORT $LN25@unicode_is@5

; 11412: 
; 11413:     for (i = 0; i < length; i++) {

  000fa	48 ff c3	 inc	 rbx
  000fd	48 3b dd	 cmp	 rbx, rbp
  00100	7c d4		 jl	 SHORT $LL4@unicode_is@5
$LN2@unicode_is@5:

; 11416:     }
; 11417:     return PyBool_FromLong(1);

  00102	b9 01 00 00 00	 mov	 ecx, 1
$LN30@unicode_is@5:
  00107	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0010c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00111	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11418: }

  00116	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011a	5f		 pop	 rdi
  0011b	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN25@unicode_is@5:

; 11415:             return PyBool_FromLong(0);

  00120	33 c9		 xor	 ecx, ecx
  00122	eb e3		 jmp	 SHORT $LN30@unicode_is@5
unicode_isalpha ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_IsNumeric:PROC
EXTRN	_PyUnicode_IsDigit:PROC
EXTRN	_PyUnicode_IsDecimalDigit:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_isalnum DD imagerel unicode_isalnum
	DD	imagerel unicode_isalnum+36
	DD	imagerel $unwind$unicode_isalnum
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$unicode_isalnum DD imagerel unicode_isalnum+36
	DD	imagerel unicode_isalnum+187
	DD	imagerel $chain$1$unicode_isalnum
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$unicode_isalnum DD imagerel unicode_isalnum+187
	DD	imagerel unicode_isalnum+214
	DD	imagerel $chain$3$unicode_isalnum
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$unicode_isalnum DD imagerel unicode_isalnum+214
	DD	imagerel unicode_isalnum+241
	DD	imagerel $chain$5$unicode_isalnum
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$unicode_isalnum DD imagerel unicode_isalnum+241
	DD	imagerel unicode_isalnum+375
	DD	imagerel $chain$9$unicode_isalnum
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$unicode_isalnum DD imagerel unicode_isalnum+375
	DD	imagerel unicode_isalnum+379
	DD	imagerel $chain$11$unicode_isalnum
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$unicode_isalnum DD 080021H
	DD	09c400H
	DD	087400H
	DD	076400H
	DD	065400H
	DD	imagerel unicode_isalnum
	DD	imagerel unicode_isalnum+36
	DD	imagerel $unwind$unicode_isalnum
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$unicode_isalnum DD 080c21H
	DD	08740cH
	DD	065405H
	DD	09c400H
	DD	076400H
	DD	imagerel unicode_isalnum
	DD	imagerel unicode_isalnum+36
	DD	imagerel $unwind$unicode_isalnum
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$unicode_isalnum DD 040021H
	DD	09c400H
	DD	076400H
	DD	imagerel unicode_isalnum
	DD	imagerel unicode_isalnum+36
	DD	imagerel $unwind$unicode_isalnum
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$unicode_isalnum DD 040021H
	DD	09c400H
	DD	076400H
	DD	imagerel unicode_isalnum
	DD	imagerel unicode_isalnum+36
	DD	imagerel $unwind$unicode_isalnum
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$unicode_isalnum DD 040a21H
	DD	09c40aH
	DD	076405H
	DD	imagerel unicode_isalnum
	DD	imagerel unicode_isalnum+36
	DD	imagerel $unwind$unicode_isalnum
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_isalnum DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_isalnum
_TEXT	SEGMENT
self$ = 48
unicode_isalnum PROC					; COMDAT

; 11428: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 11429:     int kind;
; 11430:     void *data;
; 11431:     Py_ssize_t len, i;
; 11432: 
; 11433:     if (PyUnicode_READY(self) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	75 12		 jne	 SHORT $LN7@unicode_is@6
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN7@unicode_is@6

; 11434:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 11456: }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
$LN7@unicode_is@6:

; 11435: 
; 11436:     kind = PyUnicode_KIND(self);

  00021	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00024	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00029	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  0002e	8b c8		 mov	 ecx, eax
  00030	c1 e9 02	 shr	 ecx, 2
  00033	83 e1 07	 and	 ecx, 7

; 11437:     data = PyUnicode_DATA(self);

  00036	a8 20		 test	 al, 32			; 00000020H
  00038	74 16		 je	 SHORT $LN14@unicode_is@6
  0003a	a8 40		 test	 al, 64			; 00000040H
  0003c	74 09		 je	 SHORT $LN12@unicode_is@6
  0003e	48 8d b3 80 00
	00 00		 lea	 rsi, QWORD PTR [rbx+128]
  00045	eb 10		 jmp	 SHORT $LN15@unicode_is@6
$LN12@unicode_is@6:
  00047	48 8d b3 a0 00
	00 00		 lea	 rsi, QWORD PTR [rbx+160]
  0004e	eb 07		 jmp	 SHORT $LN15@unicode_is@6
$LN14@unicode_is@6:
  00050	48 8b b3 a0 00
	00 00		 mov	 rsi, QWORD PTR [rbx+160]
$LN15@unicode_is@6:

; 11438:     len = PyUnicode_GET_LENGTH(self);

  00057	4c 8b 63 60	 mov	 r12, QWORD PTR [rbx+96]

; 11439: 
; 11440:     /* Shortcut for single character strings */
; 11441:     if (len == 1) {

  0005b	49 83 fc 01	 cmp	 r12, 1
  0005f	75 75		 jne	 SHORT $LN6@unicode_is@6

; 11442:         const Py_UCS4 ch = PyUnicode_READ(kind, data, 0);

  00061	41 3b cc	 cmp	 ecx, r12d
  00064	75 05		 jne	 SHORT $LN18@unicode_is@6
  00066	0f b6 1e	 movzx	 ebx, BYTE PTR [rsi]
  00069	eb 0c		 jmp	 SHORT $LN17@unicode_is@6
$LN18@unicode_is@6:
  0006b	83 f9 02	 cmp	 ecx, 2
  0006e	75 05		 jne	 SHORT $LN16@unicode_is@6
  00070	0f b7 1e	 movzx	 ebx, WORD PTR [rsi]
  00073	eb 02		 jmp	 SHORT $LN17@unicode_is@6
$LN16@unicode_is@6:
  00075	8b 1e		 mov	 ebx, DWORD PTR [rsi]
$LN17@unicode_is@6:

; 11443:         return PyBool_FromLong(Py_UNICODE_ISALNUM(ch));

  00077	8b cb		 mov	 ecx, ebx
  00079	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  0007e	85 c0		 test	 eax, eax
  00080	75 39		 jne	 SHORT $LN20@unicode_is@6
  00082	8b cb		 mov	 ecx, ebx
  00084	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  00089	85 c0		 test	 eax, eax
  0008b	75 2e		 jne	 SHORT $LN20@unicode_is@6
  0008d	8b cb		 mov	 ecx, ebx
  0008f	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  00094	85 c0		 test	 eax, eax
  00096	75 23		 jne	 SHORT $LN20@unicode_is@6
  00098	8b cb		 mov	 ecx, ebx
  0009a	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  0009f	85 c0		 test	 eax, eax
  000a1	75 18		 jne	 SHORT $LN20@unicode_is@6
  000a3	33 db		 xor	 ebx, ebx
  000a5	8b cb		 mov	 ecx, ebx
  000a7	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000ac	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]

; 11456: }

  000b1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b5	5b		 pop	 rbx
  000b6	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN20@unicode_is@6:

; 11443:         return PyBool_FromLong(Py_UNICODE_ISALNUM(ch));

  000bb	bb 01 00 00 00	 mov	 ebx, 1
  000c0	8b cb		 mov	 ecx, ebx
  000c2	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000c7	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]

; 11456: }

  000cc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d0	5b		 pop	 rbx
  000d1	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN6@unicode_is@6:

; 11444:     }
; 11445: 
; 11446:     /* Special case for empty strings */
; 11447:     if (len == 0)

  000d6	4d 85 e4	 test	 r12, r12
  000d9	75 16		 jne	 SHORT $LN5@unicode_is@6

; 11448:         return PyBool_FromLong(0);

  000db	33 c9		 xor	 ecx, ecx
  000dd	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000e2	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]

; 11456: }

  000e7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000eb	5b		 pop	 rbx
  000ec	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN5@unicode_is@6:
  000f1	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp

; 11449: 
; 11450:     for (i = 0; i < len; i++) {

  000f6	33 db		 xor	 ebx, ebx
  000f8	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 11451:         const Py_UCS4 ch = PyUnicode_READ(kind, data, i);

  000fd	48 63 e9	 movsxd	 rbp, ecx
  00100	4d 85 e4	 test	 r12, r12
  00103	7e 4f		 jle	 SHORT $LN29@unicode_is@6
$LL4@unicode_is@6:
  00105	48 83 fd 01	 cmp	 rbp, 1
  00109	75 06		 jne	 SHORT $LN24@unicode_is@6
  0010b	0f b6 3c 33	 movzx	 edi, BYTE PTR [rbx+rsi]
  0010f	eb 0f		 jmp	 SHORT $LN23@unicode_is@6
$LN24@unicode_is@6:
  00111	48 83 fd 02	 cmp	 rbp, 2
  00115	75 06		 jne	 SHORT $LN22@unicode_is@6
  00117	0f b7 3c 5e	 movzx	 edi, WORD PTR [rsi+rbx*2]
  0011b	eb 03		 jmp	 SHORT $LN23@unicode_is@6
$LN22@unicode_is@6:
  0011d	8b 3c 9e	 mov	 edi, DWORD PTR [rsi+rbx*4]
$LN23@unicode_is@6:

; 11452:         if (!Py_UNICODE_ISALNUM(ch))

  00120	8b cf		 mov	 ecx, edi
  00122	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  00127	85 c0		 test	 eax, eax
  00129	75 21		 jne	 SHORT $LN3@unicode_is@6
  0012b	8b cf		 mov	 ecx, edi
  0012d	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  00132	85 c0		 test	 eax, eax
  00134	75 16		 jne	 SHORT $LN3@unicode_is@6
  00136	8b cf		 mov	 ecx, edi
  00138	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  0013d	85 c0		 test	 eax, eax
  0013f	75 0b		 jne	 SHORT $LN3@unicode_is@6
  00141	8b cf		 mov	 ecx, edi
  00143	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  00148	85 c0		 test	 eax, eax
  0014a	74 2b		 je	 SHORT $LN27@unicode_is@6
$LN3@unicode_is@6:

; 11449: 
; 11450:     for (i = 0; i < len; i++) {

  0014c	48 ff c3	 inc	 rbx
  0014f	49 3b dc	 cmp	 rbx, r12
  00152	7c b1		 jl	 SHORT $LL4@unicode_is@6
$LN29@unicode_is@6:

; 11454:     }
; 11455:     return PyBool_FromLong(1);

  00154	b9 01 00 00 00	 mov	 ecx, 1
$LN34@unicode_is@6:
  00159	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  0015e	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  00163	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00168	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]

; 11456: }

  0016d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00171	5b		 pop	 rbx
  00172	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN27@unicode_is@6:

; 11453:             return PyBool_FromLong(0);

  00177	33 c9		 xor	 ecx, ecx
  00179	eb de		 jmp	 SHORT $LN34@unicode_is@6
unicode_isalnum ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_isdecimal DD imagerel unicode_isdecimal
	DD	imagerel unicode_isdecimal+36
	DD	imagerel $unwind$unicode_isdecimal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_isdecimal DD imagerel unicode_isdecimal+36
	DD	imagerel unicode_isdecimal+118
	DD	imagerel $chain$0$unicode_isdecimal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$unicode_isdecimal DD imagerel unicode_isdecimal+118
	DD	imagerel unicode_isdecimal+148
	DD	imagerel $chain$2$unicode_isdecimal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$unicode_isdecimal DD imagerel unicode_isdecimal+148
	DD	imagerel unicode_isdecimal+172
	DD	imagerel $chain$4$unicode_isdecimal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$unicode_isdecimal DD imagerel unicode_isdecimal+172
	DD	imagerel unicode_isdecimal+194
	DD	imagerel $chain$6$unicode_isdecimal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$unicode_isdecimal DD imagerel unicode_isdecimal+194
	DD	imagerel unicode_isdecimal+288
	DD	imagerel $chain$10$unicode_isdecimal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$unicode_isdecimal DD imagerel unicode_isdecimal+288
	DD	imagerel unicode_isdecimal+292
	DD	imagerel $chain$12$unicode_isdecimal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$unicode_isdecimal DD 060021H
	DD	086400H
	DD	075400H
	DD	063400H
	DD	imagerel unicode_isdecimal
	DD	imagerel unicode_isdecimal+36
	DD	imagerel $unwind$unicode_isdecimal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$unicode_isdecimal DD 060c21H
	DD	08640cH
	DD	063405H
	DD	075400H
	DD	imagerel unicode_isdecimal
	DD	imagerel unicode_isdecimal+36
	DD	imagerel $unwind$unicode_isdecimal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$unicode_isdecimal DD 020021H
	DD	075400H
	DD	imagerel unicode_isdecimal
	DD	imagerel unicode_isdecimal+36
	DD	imagerel $unwind$unicode_isdecimal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$unicode_isdecimal DD 020021H
	DD	075400H
	DD	imagerel unicode_isdecimal
	DD	imagerel unicode_isdecimal+36
	DD	imagerel $unwind$unicode_isdecimal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$unicode_isdecimal DD 020021H
	DD	075400H
	DD	imagerel unicode_isdecimal
	DD	imagerel unicode_isdecimal+36
	DD	imagerel $unwind$unicode_isdecimal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_isdecimal DD 020521H
	DD	075405H
	DD	imagerel unicode_isdecimal
	DD	imagerel unicode_isdecimal+36
	DD	imagerel $unwind$unicode_isdecimal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_isdecimal DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_isdecimal
_TEXT	SEGMENT
self$ = 48
unicode_isdecimal PROC					; COMDAT

; 11466: {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 11467:     Py_ssize_t i, length;
; 11468:     int kind;
; 11469:     void *data;
; 11470: 
; 11471:     if (PyUnicode_READY(self) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	75 12		 jne	 SHORT $LN7@unicode_is@7
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN7@unicode_is@7

; 11472:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 11491: }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5f		 pop	 rdi
  00020	c3		 ret	 0
$LN7@unicode_is@7:

; 11473:     length = PyUnicode_GET_LENGTH(self);
; 11474:     kind = PyUnicode_KIND(self);

  00021	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00024	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00029	48 8b 6f 60	 mov	 rbp, QWORD PTR [rdi+96]
  0002d	8b c8		 mov	 ecx, eax
  0002f	c1 e9 02	 shr	 ecx, 2
  00032	83 e1 07	 and	 ecx, 7

; 11475:     data = PyUnicode_DATA(self);

  00035	a8 20		 test	 al, 32			; 00000020H
  00037	74 13		 je	 SHORT $LN14@unicode_is@7
  00039	a8 40		 test	 al, 64			; 00000040H
  0003b	74 06		 je	 SHORT $LN12@unicode_is@7
  0003d	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  00041	eb 10		 jmp	 SHORT $LN15@unicode_is@7
$LN12@unicode_is@7:
  00043	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  0004a	eb 07		 jmp	 SHORT $LN15@unicode_is@7
$LN14@unicode_is@7:
  0004c	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
$LN15@unicode_is@7:

; 11476: 
; 11477:     /* Shortcut for single character strings */
; 11478:     if (length == 1)

  00053	48 83 fd 01	 cmp	 rbp, 1
  00057	75 53		 jne	 SHORT $LN6@unicode_is@7

; 11479:         return PyBool_FromLong(
; 11480:             Py_UNICODE_ISDECIMAL(PyUnicode_READ(kind, data, 0)));

  00059	3b cd		 cmp	 ecx, ebp
  0005b	75 19		 jne	 SHORT $LN18@unicode_is@7
  0005d	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00060	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  00065	8b c8		 mov	 ecx, eax
  00067	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11491: }

  0006c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00070	5f		 pop	 rdi
  00071	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN18@unicode_is@7:

; 11479:         return PyBool_FromLong(
; 11480:             Py_UNICODE_ISDECIMAL(PyUnicode_READ(kind, data, 0)));

  00076	83 f9 02	 cmp	 ecx, 2
  00079	75 19		 jne	 SHORT $LN16@unicode_is@7
  0007b	0f b7 0f	 movzx	 ecx, WORD PTR [rdi]
  0007e	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  00083	8b c8		 mov	 ecx, eax
  00085	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11491: }

  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5f		 pop	 rdi
  0008f	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN16@unicode_is@7:

; 11479:         return PyBool_FromLong(
; 11480:             Py_UNICODE_ISDECIMAL(PyUnicode_READ(kind, data, 0)));

  00094	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00096	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  0009b	8b c8		 mov	 ecx, eax
  0009d	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11491: }

  000a2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a6	5f		 pop	 rdi
  000a7	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN6@unicode_is@7:

; 11481: 
; 11482:     /* Special case for empty strings */
; 11483:     if (length == 0)

  000ac	48 85 ed	 test	 rbp, rbp
  000af	75 11		 jne	 SHORT $LN5@unicode_is@7

; 11484:         return PyBool_FromLong(0);

  000b1	33 c9		 xor	 ecx, ecx
  000b3	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11491: }

  000b8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bc	5f		 pop	 rdi
  000bd	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN5@unicode_is@7:
  000c2	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 11485: 
; 11486:     for (i = 0; i < length; i++) {

  000c7	33 db		 xor	 ebx, ebx
  000c9	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi

; 11487:         if (!Py_UNICODE_ISDECIMAL(PyUnicode_READ(kind, data, i)))

  000ce	48 63 f1	 movsxd	 rsi, ecx
  000d1	48 85 ed	 test	 rbp, rbp
  000d4	7e 2c		 jle	 SHORT $LN2@unicode_is@7
$LL4@unicode_is@7:
  000d6	48 83 fe 01	 cmp	 rsi, 1
  000da	75 06		 jne	 SHORT $LN22@unicode_is@7
  000dc	0f b6 0c 3b	 movzx	 ecx, BYTE PTR [rbx+rdi]
  000e0	eb 0f		 jmp	 SHORT $LN21@unicode_is@7
$LN22@unicode_is@7:
  000e2	48 83 fe 02	 cmp	 rsi, 2
  000e6	75 06		 jne	 SHORT $LN20@unicode_is@7
  000e8	0f b7 0c 5f	 movzx	 ecx, WORD PTR [rdi+rbx*2]
  000ec	eb 03		 jmp	 SHORT $LN21@unicode_is@7
$LN20@unicode_is@7:

; 11485: 
; 11486:     for (i = 0; i < length; i++) {

  000ee	8b 0c 9f	 mov	 ecx, DWORD PTR [rdi+rbx*4]
$LN21@unicode_is@7:

; 11487:         if (!Py_UNICODE_ISDECIMAL(PyUnicode_READ(kind, data, i)))

  000f1	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  000f6	85 c0		 test	 eax, eax
  000f8	74 26		 je	 SHORT $LN25@unicode_is@7

; 11485: 
; 11486:     for (i = 0; i < length; i++) {

  000fa	48 ff c3	 inc	 rbx
  000fd	48 3b dd	 cmp	 rbx, rbp
  00100	7c d4		 jl	 SHORT $LL4@unicode_is@7
$LN2@unicode_is@7:

; 11489:     }
; 11490:     return PyBool_FromLong(1);

  00102	b9 01 00 00 00	 mov	 ecx, 1
$LN30@unicode_is@7:
  00107	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0010c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00111	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11491: }

  00116	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011a	5f		 pop	 rdi
  0011b	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN25@unicode_is@7:

; 11488:             return PyBool_FromLong(0);

  00120	33 c9		 xor	 ecx, ecx
  00122	eb e3		 jmp	 SHORT $LN30@unicode_is@7
unicode_isdecimal ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_isdigit DD imagerel unicode_isdigit
	DD	imagerel unicode_isdigit+36
	DD	imagerel $unwind$unicode_isdigit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_isdigit DD imagerel unicode_isdigit+36
	DD	imagerel unicode_isdigit+118
	DD	imagerel $chain$0$unicode_isdigit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$unicode_isdigit DD imagerel unicode_isdigit+118
	DD	imagerel unicode_isdigit+148
	DD	imagerel $chain$2$unicode_isdigit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$unicode_isdigit DD imagerel unicode_isdigit+148
	DD	imagerel unicode_isdigit+172
	DD	imagerel $chain$4$unicode_isdigit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$unicode_isdigit DD imagerel unicode_isdigit+172
	DD	imagerel unicode_isdigit+194
	DD	imagerel $chain$6$unicode_isdigit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$unicode_isdigit DD imagerel unicode_isdigit+194
	DD	imagerel unicode_isdigit+288
	DD	imagerel $chain$10$unicode_isdigit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$unicode_isdigit DD imagerel unicode_isdigit+288
	DD	imagerel unicode_isdigit+292
	DD	imagerel $chain$12$unicode_isdigit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$unicode_isdigit DD 060021H
	DD	086400H
	DD	075400H
	DD	063400H
	DD	imagerel unicode_isdigit
	DD	imagerel unicode_isdigit+36
	DD	imagerel $unwind$unicode_isdigit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$unicode_isdigit DD 060c21H
	DD	08640cH
	DD	063405H
	DD	075400H
	DD	imagerel unicode_isdigit
	DD	imagerel unicode_isdigit+36
	DD	imagerel $unwind$unicode_isdigit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$unicode_isdigit DD 020021H
	DD	075400H
	DD	imagerel unicode_isdigit
	DD	imagerel unicode_isdigit+36
	DD	imagerel $unwind$unicode_isdigit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$unicode_isdigit DD 020021H
	DD	075400H
	DD	imagerel unicode_isdigit
	DD	imagerel unicode_isdigit+36
	DD	imagerel $unwind$unicode_isdigit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$unicode_isdigit DD 020021H
	DD	075400H
	DD	imagerel unicode_isdigit
	DD	imagerel unicode_isdigit+36
	DD	imagerel $unwind$unicode_isdigit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_isdigit DD 020521H
	DD	075405H
	DD	imagerel unicode_isdigit
	DD	imagerel unicode_isdigit+36
	DD	imagerel $unwind$unicode_isdigit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_isdigit DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_isdigit
_TEXT	SEGMENT
self$ = 48
unicode_isdigit PROC					; COMDAT

; 11501: {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 11502:     Py_ssize_t i, length;
; 11503:     int kind;
; 11504:     void *data;
; 11505: 
; 11506:     if (PyUnicode_READY(self) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	75 12		 jne	 SHORT $LN7@unicode_is@8
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN7@unicode_is@8

; 11507:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 11527: }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5f		 pop	 rdi
  00020	c3		 ret	 0
$LN7@unicode_is@8:

; 11508:     length = PyUnicode_GET_LENGTH(self);
; 11509:     kind = PyUnicode_KIND(self);

  00021	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00024	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00029	48 8b 6f 60	 mov	 rbp, QWORD PTR [rdi+96]
  0002d	8b c8		 mov	 ecx, eax
  0002f	c1 e9 02	 shr	 ecx, 2
  00032	83 e1 07	 and	 ecx, 7

; 11510:     data = PyUnicode_DATA(self);

  00035	a8 20		 test	 al, 32			; 00000020H
  00037	74 13		 je	 SHORT $LN14@unicode_is@8
  00039	a8 40		 test	 al, 64			; 00000040H
  0003b	74 06		 je	 SHORT $LN12@unicode_is@8
  0003d	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  00041	eb 10		 jmp	 SHORT $LN15@unicode_is@8
$LN12@unicode_is@8:
  00043	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  0004a	eb 07		 jmp	 SHORT $LN15@unicode_is@8
$LN14@unicode_is@8:
  0004c	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
$LN15@unicode_is@8:

; 11511: 
; 11512:     /* Shortcut for single character strings */
; 11513:     if (length == 1) {

  00053	48 83 fd 01	 cmp	 rbp, 1
  00057	75 53		 jne	 SHORT $LN6@unicode_is@8

; 11514:         const Py_UCS4 ch = PyUnicode_READ(kind, data, 0);

  00059	3b cd		 cmp	 ecx, ebp
  0005b	75 19		 jne	 SHORT $LN18@unicode_is@8
  0005d	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]

; 11515:         return PyBool_FromLong(Py_UNICODE_ISDIGIT(ch));

  00060	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  00065	8b c8		 mov	 ecx, eax
  00067	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11527: }

  0006c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00070	5f		 pop	 rdi
  00071	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN18@unicode_is@8:

; 11514:         const Py_UCS4 ch = PyUnicode_READ(kind, data, 0);

  00076	83 f9 02	 cmp	 ecx, 2
  00079	75 19		 jne	 SHORT $LN16@unicode_is@8
  0007b	0f b7 0f	 movzx	 ecx, WORD PTR [rdi]

; 11515:         return PyBool_FromLong(Py_UNICODE_ISDIGIT(ch));

  0007e	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  00083	8b c8		 mov	 ecx, eax
  00085	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11527: }

  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5f		 pop	 rdi
  0008f	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN16@unicode_is@8:

; 11514:         const Py_UCS4 ch = PyUnicode_READ(kind, data, 0);

  00094	8b 0f		 mov	 ecx, DWORD PTR [rdi]

; 11515:         return PyBool_FromLong(Py_UNICODE_ISDIGIT(ch));

  00096	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  0009b	8b c8		 mov	 ecx, eax
  0009d	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11527: }

  000a2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a6	5f		 pop	 rdi
  000a7	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN6@unicode_is@8:

; 11516:     }
; 11517: 
; 11518:     /* Special case for empty strings */
; 11519:     if (length == 0)

  000ac	48 85 ed	 test	 rbp, rbp
  000af	75 11		 jne	 SHORT $LN5@unicode_is@8

; 11520:         return PyBool_FromLong(0);

  000b1	33 c9		 xor	 ecx, ecx
  000b3	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11527: }

  000b8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bc	5f		 pop	 rdi
  000bd	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN5@unicode_is@8:
  000c2	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 11521: 
; 11522:     for (i = 0; i < length; i++) {

  000c7	33 db		 xor	 ebx, ebx
  000c9	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi

; 11523:         if (!Py_UNICODE_ISDIGIT(PyUnicode_READ(kind, data, i)))

  000ce	48 63 f1	 movsxd	 rsi, ecx
  000d1	48 85 ed	 test	 rbp, rbp
  000d4	7e 2c		 jle	 SHORT $LN2@unicode_is@8
$LL4@unicode_is@8:
  000d6	48 83 fe 01	 cmp	 rsi, 1
  000da	75 06		 jne	 SHORT $LN22@unicode_is@8
  000dc	0f b6 0c 3b	 movzx	 ecx, BYTE PTR [rbx+rdi]
  000e0	eb 0f		 jmp	 SHORT $LN21@unicode_is@8
$LN22@unicode_is@8:
  000e2	48 83 fe 02	 cmp	 rsi, 2
  000e6	75 06		 jne	 SHORT $LN20@unicode_is@8
  000e8	0f b7 0c 5f	 movzx	 ecx, WORD PTR [rdi+rbx*2]
  000ec	eb 03		 jmp	 SHORT $LN21@unicode_is@8
$LN20@unicode_is@8:

; 11521: 
; 11522:     for (i = 0; i < length; i++) {

  000ee	8b 0c 9f	 mov	 ecx, DWORD PTR [rdi+rbx*4]
$LN21@unicode_is@8:

; 11523:         if (!Py_UNICODE_ISDIGIT(PyUnicode_READ(kind, data, i)))

  000f1	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  000f6	85 c0		 test	 eax, eax
  000f8	74 26		 je	 SHORT $LN25@unicode_is@8

; 11521: 
; 11522:     for (i = 0; i < length; i++) {

  000fa	48 ff c3	 inc	 rbx
  000fd	48 3b dd	 cmp	 rbx, rbp
  00100	7c d4		 jl	 SHORT $LL4@unicode_is@8
$LN2@unicode_is@8:

; 11525:     }
; 11526:     return PyBool_FromLong(1);

  00102	b9 01 00 00 00	 mov	 ecx, 1
$LN30@unicode_is@8:
  00107	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0010c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00111	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11527: }

  00116	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011a	5f		 pop	 rdi
  0011b	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN25@unicode_is@8:

; 11524:             return PyBool_FromLong(0);

  00120	33 c9		 xor	 ecx, ecx
  00122	eb e3		 jmp	 SHORT $LN30@unicode_is@8
unicode_isdigit ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_isnumeric DD imagerel unicode_isnumeric
	DD	imagerel unicode_isnumeric+36
	DD	imagerel $unwind$unicode_isnumeric
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_isnumeric DD imagerel unicode_isnumeric+36
	DD	imagerel unicode_isnumeric+118
	DD	imagerel $chain$0$unicode_isnumeric
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$unicode_isnumeric DD imagerel unicode_isnumeric+118
	DD	imagerel unicode_isnumeric+148
	DD	imagerel $chain$2$unicode_isnumeric
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$unicode_isnumeric DD imagerel unicode_isnumeric+148
	DD	imagerel unicode_isnumeric+172
	DD	imagerel $chain$4$unicode_isnumeric
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$unicode_isnumeric DD imagerel unicode_isnumeric+172
	DD	imagerel unicode_isnumeric+194
	DD	imagerel $chain$6$unicode_isnumeric
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$unicode_isnumeric DD imagerel unicode_isnumeric+194
	DD	imagerel unicode_isnumeric+288
	DD	imagerel $chain$10$unicode_isnumeric
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$unicode_isnumeric DD imagerel unicode_isnumeric+288
	DD	imagerel unicode_isnumeric+292
	DD	imagerel $chain$12$unicode_isnumeric
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$unicode_isnumeric DD 060021H
	DD	086400H
	DD	075400H
	DD	063400H
	DD	imagerel unicode_isnumeric
	DD	imagerel unicode_isnumeric+36
	DD	imagerel $unwind$unicode_isnumeric
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$unicode_isnumeric DD 060c21H
	DD	08640cH
	DD	063405H
	DD	075400H
	DD	imagerel unicode_isnumeric
	DD	imagerel unicode_isnumeric+36
	DD	imagerel $unwind$unicode_isnumeric
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$unicode_isnumeric DD 020021H
	DD	075400H
	DD	imagerel unicode_isnumeric
	DD	imagerel unicode_isnumeric+36
	DD	imagerel $unwind$unicode_isnumeric
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$unicode_isnumeric DD 020021H
	DD	075400H
	DD	imagerel unicode_isnumeric
	DD	imagerel unicode_isnumeric+36
	DD	imagerel $unwind$unicode_isnumeric
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$unicode_isnumeric DD 020021H
	DD	075400H
	DD	imagerel unicode_isnumeric
	DD	imagerel unicode_isnumeric+36
	DD	imagerel $unwind$unicode_isnumeric
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_isnumeric DD 020521H
	DD	075405H
	DD	imagerel unicode_isnumeric
	DD	imagerel unicode_isnumeric+36
	DD	imagerel $unwind$unicode_isnumeric
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_isnumeric DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_isnumeric
_TEXT	SEGMENT
self$ = 48
unicode_isnumeric PROC					; COMDAT

; 11537: {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 11538:     Py_ssize_t i, length;
; 11539:     int kind;
; 11540:     void *data;
; 11541: 
; 11542:     if (PyUnicode_READY(self) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	75 12		 jne	 SHORT $LN7@unicode_is@9
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN7@unicode_is@9

; 11543:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 11562: }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5f		 pop	 rdi
  00020	c3		 ret	 0
$LN7@unicode_is@9:

; 11544:     length = PyUnicode_GET_LENGTH(self);
; 11545:     kind = PyUnicode_KIND(self);

  00021	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00024	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00029	48 8b 6f 60	 mov	 rbp, QWORD PTR [rdi+96]
  0002d	8b c8		 mov	 ecx, eax
  0002f	c1 e9 02	 shr	 ecx, 2
  00032	83 e1 07	 and	 ecx, 7

; 11546:     data = PyUnicode_DATA(self);

  00035	a8 20		 test	 al, 32			; 00000020H
  00037	74 13		 je	 SHORT $LN14@unicode_is@9
  00039	a8 40		 test	 al, 64			; 00000040H
  0003b	74 06		 je	 SHORT $LN12@unicode_is@9
  0003d	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  00041	eb 10		 jmp	 SHORT $LN15@unicode_is@9
$LN12@unicode_is@9:
  00043	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  0004a	eb 07		 jmp	 SHORT $LN15@unicode_is@9
$LN14@unicode_is@9:
  0004c	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
$LN15@unicode_is@9:

; 11547: 
; 11548:     /* Shortcut for single character strings */
; 11549:     if (length == 1)

  00053	48 83 fd 01	 cmp	 rbp, 1
  00057	75 53		 jne	 SHORT $LN6@unicode_is@9

; 11550:         return PyBool_FromLong(
; 11551:             Py_UNICODE_ISNUMERIC(PyUnicode_READ(kind, data, 0)));

  00059	3b cd		 cmp	 ecx, ebp
  0005b	75 19		 jne	 SHORT $LN18@unicode_is@9
  0005d	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00060	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  00065	8b c8		 mov	 ecx, eax
  00067	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11562: }

  0006c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00070	5f		 pop	 rdi
  00071	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN18@unicode_is@9:

; 11550:         return PyBool_FromLong(
; 11551:             Py_UNICODE_ISNUMERIC(PyUnicode_READ(kind, data, 0)));

  00076	83 f9 02	 cmp	 ecx, 2
  00079	75 19		 jne	 SHORT $LN16@unicode_is@9
  0007b	0f b7 0f	 movzx	 ecx, WORD PTR [rdi]
  0007e	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  00083	8b c8		 mov	 ecx, eax
  00085	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11562: }

  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5f		 pop	 rdi
  0008f	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN16@unicode_is@9:

; 11550:         return PyBool_FromLong(
; 11551:             Py_UNICODE_ISNUMERIC(PyUnicode_READ(kind, data, 0)));

  00094	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00096	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  0009b	8b c8		 mov	 ecx, eax
  0009d	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11562: }

  000a2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a6	5f		 pop	 rdi
  000a7	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN6@unicode_is@9:

; 11552: 
; 11553:     /* Special case for empty strings */
; 11554:     if (length == 0)

  000ac	48 85 ed	 test	 rbp, rbp
  000af	75 11		 jne	 SHORT $LN5@unicode_is@9

; 11555:         return PyBool_FromLong(0);

  000b1	33 c9		 xor	 ecx, ecx
  000b3	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11562: }

  000b8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bc	5f		 pop	 rdi
  000bd	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN5@unicode_is@9:
  000c2	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 11556: 
; 11557:     for (i = 0; i < length; i++) {

  000c7	33 db		 xor	 ebx, ebx
  000c9	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi

; 11558:         if (!Py_UNICODE_ISNUMERIC(PyUnicode_READ(kind, data, i)))

  000ce	48 63 f1	 movsxd	 rsi, ecx
  000d1	48 85 ed	 test	 rbp, rbp
  000d4	7e 2c		 jle	 SHORT $LN2@unicode_is@9
$LL4@unicode_is@9:
  000d6	48 83 fe 01	 cmp	 rsi, 1
  000da	75 06		 jne	 SHORT $LN22@unicode_is@9
  000dc	0f b6 0c 3b	 movzx	 ecx, BYTE PTR [rbx+rdi]
  000e0	eb 0f		 jmp	 SHORT $LN21@unicode_is@9
$LN22@unicode_is@9:
  000e2	48 83 fe 02	 cmp	 rsi, 2
  000e6	75 06		 jne	 SHORT $LN20@unicode_is@9
  000e8	0f b7 0c 5f	 movzx	 ecx, WORD PTR [rdi+rbx*2]
  000ec	eb 03		 jmp	 SHORT $LN21@unicode_is@9
$LN20@unicode_is@9:

; 11556: 
; 11557:     for (i = 0; i < length; i++) {

  000ee	8b 0c 9f	 mov	 ecx, DWORD PTR [rdi+rbx*4]
$LN21@unicode_is@9:

; 11558:         if (!Py_UNICODE_ISNUMERIC(PyUnicode_READ(kind, data, i)))

  000f1	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  000f6	85 c0		 test	 eax, eax
  000f8	74 26		 je	 SHORT $LN25@unicode_is@9

; 11556: 
; 11557:     for (i = 0; i < length; i++) {

  000fa	48 ff c3	 inc	 rbx
  000fd	48 3b dd	 cmp	 rbx, rbp
  00100	7c d4		 jl	 SHORT $LL4@unicode_is@9
$LN2@unicode_is@9:

; 11560:     }
; 11561:     return PyBool_FromLong(1);

  00102	b9 01 00 00 00	 mov	 ecx, 1
$LN30@unicode_is@9:
  00107	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0010c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00111	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 11562: }

  00116	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011a	5f		 pop	 rdi
  0011b	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN25@unicode_is@9:

; 11559:             return PyBool_FromLong(0);

  00120	33 c9		 xor	 ecx, ecx
  00122	eb e3		 jmp	 SHORT $LN30@unicode_is@9
unicode_isnumeric ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@MPNJMFFA@identifier?5not?5ready?$AA@	; `string'
PUBLIC	PyUnicode_IsIdentifier
EXTRN	_PyUnicode_IsXidContinue:PROC
EXTRN	_PyUnicode_IsXidStart:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_IsIdentifier DD imagerel $LN31
	DD	imagerel $LN31+55
	DD	imagerel $unwind$PyUnicode_IsIdentifier
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyUnicode_IsIdentifier DD imagerel $LN31+55
	DD	imagerel $LN31+234
	DD	imagerel $chain$2$PyUnicode_IsIdentifier
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyUnicode_IsIdentifier DD imagerel $LN31+234
	DD	imagerel $LN31+238
	DD	imagerel $chain$4$PyUnicode_IsIdentifier
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyUnicode_IsIdentifier DD 060021H
	DD	087400H
	DD	075400H
	DD	063400H
	DD	imagerel $LN31
	DD	imagerel $LN31+55
	DD	imagerel $unwind$PyUnicode_IsIdentifier
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyUnicode_IsIdentifier DD 061121H
	DD	087411H
	DD	07540aH
	DD	063405H
	DD	imagerel $LN31
	DD	imagerel $LN31+55
	DD	imagerel $unwind$PyUnicode_IsIdentifier
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_IsIdentifier DD 020601H
	DD	060023206H
xdata	ENDS
;	COMDAT ??_C@_0BF@MPNJMFFA@identifier?5not?5ready?$AA@
CONST	SEGMENT
??_C@_0BF@MPNJMFFA@identifier?5not?5ready?$AA@ DB 'identifier not ready', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_IsIdentifier
_TEXT	SEGMENT
self$ = 48
PyUnicode_IsIdentifier PROC				; COMDAT

; 11566: {

$LN31:
  00000	40 56		 push	 rsi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 11567:     int kind;
; 11568:     void *data;
; 11569:     Py_ssize_t i;
; 11570:     Py_UCS4 first;
; 11571: 
; 11572:     if (PyUnicode_READY(self) == -1) {

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b f1	 mov	 rsi, rcx
  0000d	75 1e		 jne	 SHORT $LN7@PyUnicode_@44
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 14		 jne	 SHORT $LN7@PyUnicode_@44

; 11573:         Py_FatalError("identifier not ready");

  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@MPNJMFFA@identifier?5not?5ready?$AA@
  00020	e8 00 00 00 00	 call	 Py_FatalError
$LN30@PyUnicode_@44:

; 11574:         return 0;

  00025	33 c0		 xor	 eax, eax

; 11599: }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5e		 pop	 rsi
  0002c	c3		 ret	 0
$LN7@PyUnicode_@44:

; 11575:     }
; 11576: 
; 11577:     /* Special case for empty strings */
; 11578:     if (PyUnicode_GET_LENGTH(self) == 0)

  0002d	48 83 7e 60 00	 cmp	 QWORD PTR [rsi+96], 0

; 11579:         return 0;

  00032	74 f1		 je	 SHORT $LN30@PyUnicode_@44

; 11580:     kind = PyUnicode_KIND(self);

  00034	8b 46 70	 mov	 eax, DWORD PTR [rsi+112]
  00037	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0003c	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00041	8b e8		 mov	 ebp, eax
  00043	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00048	c1 ed 02	 shr	 ebp, 2
  0004b	83 e5 07	 and	 ebp, 7

; 11581:     data = PyUnicode_DATA(self);

  0004e	a8 20		 test	 al, 32			; 00000020H
  00050	74 16		 je	 SHORT $LN14@PyUnicode_@44
  00052	a8 40		 test	 al, 64			; 00000040H
  00054	74 09		 je	 SHORT $LN12@PyUnicode_@44
  00056	48 8d be 80 00
	00 00		 lea	 rdi, QWORD PTR [rsi+128]
  0005d	eb 10		 jmp	 SHORT $LN15@PyUnicode_@44
$LN12@PyUnicode_@44:
  0005f	48 8d be a0 00
	00 00		 lea	 rdi, QWORD PTR [rsi+160]
  00066	eb 07		 jmp	 SHORT $LN15@PyUnicode_@44
$LN14@PyUnicode_@44:
  00068	48 8b be a0 00
	00 00		 mov	 rdi, QWORD PTR [rsi+160]
$LN15@PyUnicode_@44:

; 11582: 
; 11583:     /* PEP 3131 says that the first character must be in
; 11584:        XID_Start and subsequent characters in XID_Continue,
; 11585:        and for the ASCII range, the 2.x rules apply (i.e
; 11586:        start with letters and underscore, continue with
; 11587:        letters, digits, underscore). However, given the current
; 11588:        definition of XID_Start and XID_Continue, it is sufficient
; 11589:        to check just for these, except that _ must be allowed
; 11590:        as starting an identifier.  */
; 11591:     first = PyUnicode_READ(kind, data, 0);

  0006f	83 fd 01	 cmp	 ebp, 1
  00072	75 05		 jne	 SHORT $LN18@PyUnicode_@44
  00074	0f b6 1f	 movzx	 ebx, BYTE PTR [rdi]
  00077	eb 0c		 jmp	 SHORT $LN17@PyUnicode_@44
$LN18@PyUnicode_@44:
  00079	83 fd 02	 cmp	 ebp, 2
  0007c	75 05		 jne	 SHORT $LN16@PyUnicode_@44
  0007e	0f b7 1f	 movzx	 ebx, WORD PTR [rdi]
  00081	eb 02		 jmp	 SHORT $LN17@PyUnicode_@44
$LN16@PyUnicode_@44:
  00083	8b 1f		 mov	 ebx, DWORD PTR [rdi]
$LN17@PyUnicode_@44:

; 11592:     if (!_PyUnicode_IsXidStart(first) && first != 0x5F /* LOW LINE */)

  00085	8b cb		 mov	 ecx, ebx
  00087	e8 00 00 00 00	 call	 _PyUnicode_IsXidStart
  0008c	85 c0		 test	 eax, eax
  0008e	75 05		 jne	 SHORT $LN5@PyUnicode_@44
  00090	83 fb 5f	 cmp	 ebx, 95			; 0000005fH

; 11593:         return 0;

  00093	75 55		 jne	 SHORT $LN25@PyUnicode_@44
$LN5@PyUnicode_@44:

; 11594: 
; 11595:     for (i = 1; i < PyUnicode_GET_LENGTH(self); i++)

  00095	bb 01 00 00 00	 mov	 ebx, 1

; 11596:         if (!_PyUnicode_IsXidContinue(PyUnicode_READ(kind, data, i)))

  0009a	48 63 ed	 movsxd	 rbp, ebp
  0009d	48 3b 5e 60	 cmp	 rbx, QWORD PTR [rsi+96]
  000a1	7d 2d		 jge	 SHORT $LN2@PyUnicode_@44
$LL4@PyUnicode_@44:
  000a3	48 83 fd 01	 cmp	 rbp, 1
  000a7	75 06		 jne	 SHORT $LN22@PyUnicode_@44
  000a9	0f b6 0c 3b	 movzx	 ecx, BYTE PTR [rbx+rdi]
  000ad	eb 0f		 jmp	 SHORT $LN21@PyUnicode_@44
$LN22@PyUnicode_@44:
  000af	48 83 fd 02	 cmp	 rbp, 2
  000b3	75 06		 jne	 SHORT $LN20@PyUnicode_@44
  000b5	0f b7 0c 5f	 movzx	 ecx, WORD PTR [rdi+rbx*2]
  000b9	eb 03		 jmp	 SHORT $LN21@PyUnicode_@44
$LN20@PyUnicode_@44:

; 11594: 
; 11595:     for (i = 1; i < PyUnicode_GET_LENGTH(self); i++)

  000bb	8b 0c 9f	 mov	 ecx, DWORD PTR [rdi+rbx*4]
$LN21@PyUnicode_@44:

; 11596:         if (!_PyUnicode_IsXidContinue(PyUnicode_READ(kind, data, i)))

  000be	e8 00 00 00 00	 call	 _PyUnicode_IsXidContinue
  000c3	85 c0		 test	 eax, eax
  000c5	74 23		 je	 SHORT $LN25@PyUnicode_@44

; 11594: 
; 11595:     for (i = 1; i < PyUnicode_GET_LENGTH(self); i++)

  000c7	48 ff c3	 inc	 rbx
  000ca	48 3b 5e 60	 cmp	 rbx, QWORD PTR [rsi+96]
  000ce	7c d3		 jl	 SHORT $LL4@PyUnicode_@44
$LN2@PyUnicode_@44:

; 11598:     return 1;

  000d0	b8 01 00 00 00	 mov	 eax, 1
$LN29@PyUnicode_@44:
  000d5	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000da	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000df	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 11599: }

  000e4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e8	5e		 pop	 rsi
  000e9	c3		 ret	 0
$LN25@PyUnicode_@44:

; 11597:             return 0;

  000ea	33 c0		 xor	 eax, eax
  000ec	eb e7		 jmp	 SHORT $LN29@PyUnicode_@44
PyUnicode_IsIdentifier ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_isidentifier DD imagerel unicode_isidentifier
	DD	imagerel unicode_isidentifier+20
	DD	imagerel $unwind$unicode_isidentifier
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_isidentifier DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_isidentifier
_TEXT	SEGMENT
self$ = 48
unicode_isidentifier PROC				; COMDAT

; 11612: {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 11613:     return PyBool_FromLong(PyUnicode_IsIdentifier(self));

  00004	e8 00 00 00 00	 call	 PyUnicode_IsIdentifier
  00009	8b c8		 mov	 ecx, eax

; 11614: }

  0000b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000f	e9 00 00 00 00	 jmp	 PyBool_FromLong
unicode_isidentifier ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_IsPrintable:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$unicode_isprintable DD imagerel unicode_isprintable
	DD	imagerel unicode_isprintable+36
	DD	imagerel $unwind$unicode_isprintable
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_isprintable DD imagerel unicode_isprintable+36
	DD	imagerel unicode_isprintable+118
	DD	imagerel $chain$0$unicode_isprintable
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$unicode_isprintable DD imagerel unicode_isprintable+118
	DD	imagerel unicode_isprintable+148
	DD	imagerel $chain$2$unicode_isprintable
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$unicode_isprintable DD imagerel unicode_isprintable+148
	DD	imagerel unicode_isprintable+172
	DD	imagerel $chain$4$unicode_isprintable
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$unicode_isprintable DD imagerel unicode_isprintable+172
	DD	imagerel unicode_isprintable+333
	DD	imagerel $chain$8$unicode_isprintable
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$unicode_isprintable DD imagerel unicode_isprintable+333
	DD	imagerel unicode_isprintable+411
	DD	imagerel $chain$10$unicode_isprintable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$unicode_isprintable DD 060021H
	DD	0a6400H
	DD	095400H
	DD	083400H
	DD	imagerel unicode_isprintable
	DD	imagerel unicode_isprintable+36
	DD	imagerel $unwind$unicode_isprintable
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$unicode_isprintable DD 060c21H
	DD	0a640cH
	DD	083405H
	DD	095400H
	DD	imagerel unicode_isprintable
	DD	imagerel unicode_isprintable+36
	DD	imagerel $unwind$unicode_isprintable
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$unicode_isprintable DD 020021H
	DD	095400H
	DD	imagerel unicode_isprintable
	DD	imagerel unicode_isprintable+36
	DD	imagerel $unwind$unicode_isprintable
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$unicode_isprintable DD 020021H
	DD	095400H
	DD	imagerel unicode_isprintable
	DD	imagerel unicode_isprintable+36
	DD	imagerel $unwind$unicode_isprintable
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_isprintable DD 020521H
	DD	095405H
	DD	imagerel unicode_isprintable
	DD	imagerel unicode_isprintable+36
	DD	imagerel $unwind$unicode_isprintable
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_isprintable DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT unicode_isprintable
_TEXT	SEGMENT
self$ = 64
unicode_isprintable PROC				; COMDAT

; 11624: {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 11625:     Py_ssize_t i, length;
; 11626:     int kind;
; 11627:     void *data;
; 11628: 
; 11629:     if (PyUnicode_READY(self) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	75 12		 jne	 SHORT $LN6@unicode_is@10
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN6@unicode_is@10

; 11630:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 11646: }

  0001b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001f	5f		 pop	 rdi
  00020	c3		 ret	 0
$LN6@unicode_is@10:

; 11631:     length = PyUnicode_GET_LENGTH(self);
; 11632:     kind = PyUnicode_KIND(self);

  00021	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00024	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  00029	48 8b 6f 60	 mov	 rbp, QWORD PTR [rdi+96]
  0002d	8b c8		 mov	 ecx, eax
  0002f	c1 e9 02	 shr	 ecx, 2
  00032	83 e1 07	 and	 ecx, 7

; 11633:     data = PyUnicode_DATA(self);

  00035	a8 20		 test	 al, 32			; 00000020H
  00037	74 13		 je	 SHORT $LN13@unicode_is@10
  00039	a8 40		 test	 al, 64			; 00000040H
  0003b	74 06		 je	 SHORT $LN11@unicode_is@10
  0003d	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  00041	eb 10		 jmp	 SHORT $LN14@unicode_is@10
$LN11@unicode_is@10:
  00043	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  0004a	eb 07		 jmp	 SHORT $LN14@unicode_is@10
$LN13@unicode_is@10:
  0004c	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
$LN14@unicode_is@10:

; 11634: 
; 11635:     /* Shortcut for single character strings */
; 11636:     if (length == 1)

  00053	48 83 fd 01	 cmp	 rbp, 1
  00057	75 53		 jne	 SHORT $LN5@unicode_is@10

; 11637:         return PyBool_FromLong(
; 11638:             Py_UNICODE_ISPRINTABLE(PyUnicode_READ(kind, data, 0)));

  00059	3b cd		 cmp	 ecx, ebp
  0005b	75 19		 jne	 SHORT $LN17@unicode_is@10
  0005d	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00060	e8 00 00 00 00	 call	 _PyUnicode_IsPrintable
  00065	8b c8		 mov	 ecx, eax
  00067	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 11646: }

  0006c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00070	5f		 pop	 rdi
  00071	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN17@unicode_is@10:

; 11637:         return PyBool_FromLong(
; 11638:             Py_UNICODE_ISPRINTABLE(PyUnicode_READ(kind, data, 0)));

  00076	83 f9 02	 cmp	 ecx, 2
  00079	75 19		 jne	 SHORT $LN15@unicode_is@10
  0007b	0f b7 0f	 movzx	 ecx, WORD PTR [rdi]
  0007e	e8 00 00 00 00	 call	 _PyUnicode_IsPrintable
  00083	8b c8		 mov	 ecx, eax
  00085	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 11646: }

  0008a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008e	5f		 pop	 rdi
  0008f	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN15@unicode_is@10:

; 11637:         return PyBool_FromLong(
; 11638:             Py_UNICODE_ISPRINTABLE(PyUnicode_READ(kind, data, 0)));

  00094	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00096	e8 00 00 00 00	 call	 _PyUnicode_IsPrintable
  0009b	8b c8		 mov	 ecx, eax
  0009d	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 11646: }

  000a2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a6	5f		 pop	 rdi
  000a7	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN5@unicode_is@10:
  000ac	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 11639: 
; 11640:     for (i = 0; i < length; i++) {

  000b1	33 db		 xor	 ebx, ebx
  000b3	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi

; 11641:         if (!Py_UNICODE_ISPRINTABLE(PyUnicode_READ(kind, data, i))) {

  000b8	48 63 f1	 movsxd	 rsi, ecx
  000bb	48 85 ed	 test	 rbp, rbp
  000be	7e 2c		 jle	 SHORT $LN2@unicode_is@10
$LL4@unicode_is@10:
  000c0	48 83 fe 01	 cmp	 rsi, 1
  000c4	75 06		 jne	 SHORT $LN21@unicode_is@10
  000c6	0f b6 0c 3b	 movzx	 ecx, BYTE PTR [rbx+rdi]
  000ca	eb 0f		 jmp	 SHORT $LN20@unicode_is@10
$LN21@unicode_is@10:
  000cc	48 83 fe 02	 cmp	 rsi, 2
  000d0	75 06		 jne	 SHORT $LN19@unicode_is@10
  000d2	0f b7 0c 5f	 movzx	 ecx, WORD PTR [rdi+rbx*2]
  000d6	eb 03		 jmp	 SHORT $LN20@unicode_is@10
$LN19@unicode_is@10:

; 11639: 
; 11640:     for (i = 0; i < length; i++) {

  000d8	8b 0c 9f	 mov	 ecx, DWORD PTR [rdi+rbx*4]
$LN20@unicode_is@10:

; 11641:         if (!Py_UNICODE_ISPRINTABLE(PyUnicode_READ(kind, data, i))) {

  000db	e8 00 00 00 00	 call	 _PyUnicode_IsPrintable
  000e0	85 c0		 test	 eax, eax
  000e2	74 69		 je	 SHORT $LN32@unicode_is@10

; 11639: 
; 11640:     for (i = 0; i < length; i++) {

  000e4	48 ff c3	 inc	 rbx
  000e7	48 3b dd	 cmp	 rbx, rbp
  000ea	7c d4		 jl	 SHORT $LL4@unicode_is@10
$LN2@unicode_is@10:

; 11643:         }
; 11644:     }
; 11645:     Py_RETURN_TRUE;

  000ec	e8 00 00 00 00	 call	 _Py_PXCTX
  000f1	85 c0		 test	 eax, eax
  000f3	75 3c		 jne	 SHORT $LN28@unicode_is@10
  000f5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_TrueStruct
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0010a	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00110	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00118	e8 00 00 00 00	 call	 _PyParallel_Guard
  0011d	85 c0		 test	 eax, eax
  0011f	75 09		 jne	 SHORT $LN27@unicode_is@10
  00121	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  00128	74 07		 je	 SHORT $LN28@unicode_is@10
$LN27@unicode_is@10:
  0012a	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80
$LN28@unicode_is@10:
  00131	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
$LN36@unicode_is@10:
  00138	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0013d	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00142	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 11646: }

  00147	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014b	5f		 pop	 rdi
  0014c	c3		 ret	 0
$LN32@unicode_is@10:

; 11642:             Py_RETURN_FALSE;

  0014d	e8 00 00 00 00	 call	 _Py_PXCTX
  00152	85 c0		 test	 eax, eax
  00154	75 3c		 jne	 SHORT $LN24@unicode_is@10
  00156	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  0015d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00164	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0016b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00171	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00179	e8 00 00 00 00	 call	 _PyParallel_Guard
  0017e	85 c0		 test	 eax, eax
  00180	75 09		 jne	 SHORT $LN23@unicode_is@10
  00182	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  00189	74 07		 je	 SHORT $LN24@unicode_is@10
$LN23@unicode_is@10:
  0018b	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN24@unicode_is@10:
  00192	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00199	eb 9d		 jmp	 SHORT $LN36@unicode_is@10
unicode_isprintable ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT unicode_join
_TEXT	SEGMENT
self$ = 8
data$ = 16
unicode_join PROC					; COMDAT

; 11657:     return PyUnicode_Join(self, data);
; 11658: }

  00000	e9 00 00 00 00	 jmp	 PyUnicode_Join
unicode_join ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_length DD imagerel unicode_length
	DD	imagerel unicode_length+45
	DD	imagerel $unwind$unicode_length
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_length DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_length
_TEXT	SEGMENT
self$ = 48
unicode_length PROC					; COMDAT

; 11662: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 11663:     if (PyUnicode_READY(self) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	75 14		 jne	 SHORT $LN1@unicode_le
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 0a		 jne	 SHORT $LN1@unicode_le

; 11664:         return -1;

  00019	48 83 c8 ff	 or	 rax, -1

; 11666: }

  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5b		 pop	 rbx
  00022	c3		 ret	 0
$LN1@unicode_le:

; 11665:     return PyUnicode_GET_LENGTH(self);

  00023	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]

; 11666: }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx
  0002c	c3		 ret	 0
unicode_length ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_lower DD imagerel unicode_lower
	DD	imagerel unicode_lower+74
	DD	imagerel $unwind$unicode_lower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_lower DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_lower
_TEXT	SEGMENT
self$ = 48
unicode_lower PROC					; COMDAT

; 11699: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 11700:     if (PyUnicode_READY(self) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	75 12		 jne	 SHORT $LN2@unicode_lo
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN2@unicode_lo

; 11701:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 11705: }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
$LN2@unicode_lo:

; 11702:     if (PyUnicode_IS_ASCII(self))

  00021	f6 43 70 40	 test	 BYTE PTR [rbx+112], 64	; 00000040H

; 11703:         return ascii_upper_or_lower(self, 1);

  00025	48 8b cb	 mov	 rcx, rbx
  00028	74 0f		 je	 SHORT $LN1@unicode_lo
  0002a	ba 01 00 00 00	 mov	 edx, 1

; 11705: }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5b		 pop	 rbx
  00034	e9 00 00 00 00	 jmp	 ascii_upper_or_lower
$LN1@unicode_lo:

; 11704:     return case_operation(self, do_lower);

  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:do_lower

; 11705: }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5b		 pop	 rbx
  00045	e9 00 00 00 00	 jmp	 case_operation
unicode_lower ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_repr DD imagerel unicode_repr
	DD	imagerel unicode_repr+36
	DD	imagerel $unwind$unicode_repr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$unicode_repr DD imagerel unicode_repr+36
	DD	imagerel unicode_repr+2028
	DD	imagerel $chain$6$unicode_repr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$unicode_repr DD imagerel unicode_repr+2028
	DD	imagerel unicode_repr+2128
	DD	imagerel $chain$8$unicode_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$unicode_repr DD 0e0021H
	DD	04f400H
	DD	05e400H
	DD	06d400H
	DD	07c400H
	DD	087400H
	DD	096400H
	DD	0f5400H
	DD	imagerel unicode_repr
	DD	imagerel unicode_repr+36
	DD	imagerel $unwind$unicode_repr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$unicode_repr DD 0e5a21H
	DD	08745aH
	DD	04f41eH
	DD	05e419H
	DD	06d414H
	DD	07c40fH
	DD	09640aH
	DD	0f5405H
	DD	imagerel unicode_repr
	DD	imagerel unicode_repr+36
	DD	imagerel $unwind$unicode_repr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_repr DD 020601H
	DD	030029206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_repr
_TEXT	SEGMENT
$T154323 = 96
unicode$ = 96
isize$1$ = 104
repr$1$ = 112
unicode_repr PROC					; COMDAT

; 12037: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 12038:     PyObject *repr;
; 12039:     Py_ssize_t isize;
; 12040:     Py_ssize_t osize, squote, dquote, i, o;
; 12041:     Py_UCS4 max, quote;
; 12042:     int ikind, okind;
; 12043:     void *idata, *odata;
; 12044: 
; 12045:     if (PyUnicode_READY(unicode) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	75 12		 jne	 SHORT $LN319@unicode_re
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN319@unicode_re

; 12046:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 12182: }

  0001b	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
$LN319@unicode_re:

; 12047: 
; 12048:     isize = PyUnicode_GET_LENGTH(unicode);
; 12049:     idata = PyUnicode_DATA(unicode);

  00021	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00024	48 89 6c 24 78	 mov	 QWORD PTR [rsp+120], rbp
  00029	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  0002e	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  00033	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  00038	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  0003d	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00042	4c 8b 7b 60	 mov	 r15, QWORD PTR [rbx+96]
  00046	4c 89 7c 24 68	 mov	 QWORD PTR isize$1$[rsp], r15
  0004b	a8 20		 test	 al, 32			; 00000020H
  0004d	74 16		 je	 SHORT $LN326@unicode_re
  0004f	a8 40		 test	 al, 64			; 00000040H
  00051	74 09		 je	 SHORT $LN324@unicode_re
  00053	4c 8d b3 80 00
	00 00		 lea	 r14, QWORD PTR [rbx+128]
  0005a	eb 10		 jmp	 SHORT $LN327@unicode_re
$LN324@unicode_re:
  0005c	4c 8d b3 a0 00
	00 00		 lea	 r14, QWORD PTR [rbx+160]
  00063	eb 07		 jmp	 SHORT $LN327@unicode_re
$LN326@unicode_re:
  00065	4c 8b b3 a0 00
	00 00		 mov	 r14, QWORD PTR [rbx+160]
$LN327@unicode_re:

; 12050: 
; 12051:     /* Compute length of output, quote characters, and
; 12052:        maximum character */
; 12053:     osize = 2; /* quotes */
; 12054:     max = 127;
; 12055:     squote = dquote = 0;
; 12056:     ikind = PyUnicode_KIND(unicode);

  0006c	c1 e8 02	 shr	 eax, 2
  0006f	33 f6		 xor	 esi, esi
  00071	bb 02 00 00 00	 mov	 ebx, 2
  00076	83 e0 07	 and	 eax, 7
  00079	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0007e	8d 6b 7d	 lea	 ebp, QWORD PTR [rbx+125]

; 12058:         Py_UCS4 ch = PyUnicode_READ(ikind, idata, i);

  00081	48 98		 cdqe
  00083	44 8b ee	 mov	 r13d, esi
  00086	44 8b e6	 mov	 r12d, esi
  00089	48 89 44 24 60	 mov	 QWORD PTR $T154323[rsp], rax
  0008e	4d 85 ff	 test	 r15, r15
  00091	0f 8e b7 00 00
	00		 jle	 $LN316@unicode_re

; 12057:     for (i = 0; i < isize; i++) {

  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  0009e	66 90		 npad	 2
$LL318@unicode_re:

; 12058:         Py_UCS4 ch = PyUnicode_READ(ikind, idata, i);

  000a0	48 83 f8 01	 cmp	 rax, 1
  000a4	75 07		 jne	 SHORT $LN330@unicode_re
  000a6	42 0f b6 3c 36	 movzx	 edi, BYTE PTR [rsi+r14]
  000ab	eb 11		 jmp	 SHORT $LN329@unicode_re
$LN330@unicode_re:
  000ad	48 83 f8 02	 cmp	 rax, 2
  000b1	75 07		 jne	 SHORT $LN328@unicode_re
  000b3	41 0f b7 3c 76	 movzx	 edi, WORD PTR [r14+rsi*2]
  000b8	eb 04		 jmp	 SHORT $LN329@unicode_re
$LN328@unicode_re:
  000ba	41 8b 3c b6	 mov	 edi, DWORD PTR [r14+rsi*4]
$LN329@unicode_re:

; 12059:         switch (ch) {

  000be	8d 47 f7	 lea	 eax, DWORD PTR [rdi-9]
  000c1	83 f8 53	 cmp	 eax, 83			; 00000053H
  000c4	77 2a		 ja	 SHORT $LN310@unicode_re
  000c6	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN344@unicode_re[rdx+rax]
  000ce	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN345@unicode_re[rdx+rax*4]
  000d5	48 03 ca	 add	 rcx, rdx
  000d8	ff e1		 jmp	 rcx
$LN313@unicode_re:

; 12060:         case '\'': squote++; osize++; break;

  000da	49 ff c4	 inc	 r12
  000dd	48 ff c3	 inc	 rbx
  000e0	eb 5b		 jmp	 SHORT $LN317@unicode_re
$LN312@unicode_re:

; 12061:         case '"':  dquote++; osize++; break;

  000e2	49 ff c5	 inc	 r13
  000e5	48 ff c3	 inc	 rbx
  000e8	eb 53		 jmp	 SHORT $LN317@unicode_re
$LN311@unicode_re:

; 12062:         case '\\': case '\t': case '\r': case '\n':
; 12063:             osize += 2; break;

  000ea	48 83 c3 02	 add	 rbx, 2
  000ee	eb 4d		 jmp	 SHORT $LN317@unicode_re
$LN310@unicode_re:

; 12064:         default:
; 12065:             /* Fast-path ASCII */
; 12066:             if (ch < ' ' || ch == 0x7f)

  000f0	83 ff 20	 cmp	 edi, 32			; 00000020H
  000f3	72 44		 jb	 SHORT $LN308@unicode_re
  000f5	83 ff 7f	 cmp	 edi, 127		; 0000007fH
  000f8	74 3f		 je	 SHORT $LN308@unicode_re

; 12068:             else if (ch < 0x7f)

  000fa	73 05		 jae	 SHORT $LN306@unicode_re

; 12069:                 osize++;

  000fc	48 ff c3	 inc	 rbx
  000ff	eb 3c		 jmp	 SHORT $LN317@unicode_re
$LN306@unicode_re:

; 12070:             else if (Py_UNICODE_ISPRINTABLE(ch)) {

  00101	8b cf		 mov	 ecx, edi
  00103	e8 00 00 00 00	 call	 _PyUnicode_IsPrintable

; 12071:                 osize++;
; 12072:                 max = ch > max ? ch : max;

  00108	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  0010f	85 c0		 test	 eax, eax
  00111	74 0a		 je	 SHORT $LN304@unicode_re
  00113	48 ff c3	 inc	 rbx
  00116	3b fd		 cmp	 edi, ebp
  00118	0f 47 ef	 cmova	 ebp, edi
  0011b	eb 20		 jmp	 SHORT $LN317@unicode_re
$LN304@unicode_re:

; 12073:             }
; 12074:             else if (ch < 0x100)

  0011d	81 ff 00 01 00
	00		 cmp	 edi, 256		; 00000100H

; 12075:                 osize += 4; /* \xHH */

  00123	72 14		 jb	 SHORT $LN308@unicode_re

; 12076:             else if (ch < 0x10000)

  00125	81 ff 00 00 01
	00		 cmp	 edi, 65536		; 00010000H
  0012b	73 06		 jae	 SHORT $LN300@unicode_re

; 12077:                 osize += 6; /* \uHHHH */

  0012d	48 83 c3 06	 add	 rbx, 6

; 12078:             else

  00131	eb 0a		 jmp	 SHORT $LN317@unicode_re
$LN300@unicode_re:

; 12079:                 osize += 10; /* \uHHHHHHHH */

  00133	48 83 c3 0a	 add	 rbx, 10
  00137	eb 04		 jmp	 SHORT $LN317@unicode_re
$LN308@unicode_re:

; 12067:                 osize += 4; /* \xHH */

  00139	48 83 c3 04	 add	 rbx, 4
$LN317@unicode_re:

; 12057:     for (i = 0; i < isize; i++) {

  0013d	48 8b 44 24 60	 mov	 rax, QWORD PTR $T154323[rsp]
  00142	48 ff c6	 inc	 rsi
  00145	49 3b f7	 cmp	 rsi, r15
  00148	0f 8c 52 ff ff
	ff		 jl	 $LL318@unicode_re
$LN316@unicode_re:

; 12080:         }
; 12081:     }
; 12082: 
; 12083:     quote = '\'';

  0014e	41 bf 27 00 00
	00		 mov	 r15d, 39		; 00000027H

; 12084:     if (squote) {

  00154	4d 85 e4	 test	 r12, r12
  00157	74 10		 je	 SHORT $LN296@unicode_re

; 12085:         if (dquote)

  00159	4d 85 ed	 test	 r13, r13
  0015c	74 05		 je	 SHORT $LN297@unicode_re

; 12086:             /* Both squote and dquote present. Use squote,
; 12087:                and escape them */
; 12088:             osize += squote;

  0015e	49 03 dc	 add	 rbx, r12

; 12089:         else

  00161	eb 06		 jmp	 SHORT $LN296@unicode_re
$LN297@unicode_re:

; 12090:             quote = '"';

  00163	41 bf 22 00 00
	00		 mov	 r15d, 34		; 00000022H
$LN296@unicode_re:

; 12091:     }
; 12092: 
; 12093:     repr = PyUnicode_New(osize, max);

  00169	8b d5		 mov	 edx, ebp
  0016b	48 8b cb	 mov	 rcx, rbx
  0016e	e8 00 00 00 00	 call	 PyUnicode_New
  00173	4c 8b e0	 mov	 r12, rax
  00176	48 89 44 24 70	 mov	 QWORD PTR repr$1$[rsp], rax

; 12094:     if (repr == NULL)

  0017b	48 85 c0	 test	 rax, rax
  0017e	0f 84 3c 06 00
	00		 je	 $LN352@unicode_re
$LN295@unicode_re:

; 12095:         return NULL;
; 12096:     okind = PyUnicode_KIND(repr);

  00184	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00187	8b e8		 mov	 ebp, eax
  00189	c1 ed 02	 shr	 ebp, 2
  0018c	83 e5 07	 and	 ebp, 7

; 12097:     odata = PyUnicode_DATA(repr);

  0018f	a8 20		 test	 al, 32			; 00000020H
  00191	74 18		 je	 SHORT $LN334@unicode_re
  00193	a8 40		 test	 al, 64			; 00000040H
  00195	74 0a		 je	 SHORT $LN332@unicode_re
  00197	49 8d bc 24 80
	00 00 00	 lea	 rdi, QWORD PTR [r12+128]
  0019f	eb 12		 jmp	 SHORT $LN335@unicode_re
$LN332@unicode_re:
  001a1	49 8d bc 24 a0
	00 00 00	 lea	 rdi, QWORD PTR [r12+160]
  001a9	eb 08		 jmp	 SHORT $LN335@unicode_re
$LN334@unicode_re:
  001ab	49 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR [r12+160]
$LN335@unicode_re:

; 12098: 
; 12099:     PyUnicode_WRITE(okind, odata, 0, quote);

  001b3	8b cd		 mov	 ecx, ebp
  001b5	ff c9		 dec	 ecx
  001b7	74 0f		 je	 SHORT $LN289@unicode_re
  001b9	ff c9		 dec	 ecx
  001bb	74 05		 je	 SHORT $LN288@unicode_re
  001bd	44 89 3f	 mov	 DWORD PTR [rdi], r15d
  001c0	eb 09		 jmp	 SHORT $LN293@unicode_re
$LN288@unicode_re:
  001c2	66 44 89 3f	 mov	 WORD PTR [rdi], r15w
  001c6	eb 03		 jmp	 SHORT $LN293@unicode_re
$LN289@unicode_re:
  001c8	44 88 3f	 mov	 BYTE PTR [rdi], r15b
$LN293@unicode_re:

; 12100:     PyUnicode_WRITE(okind, odata, osize-1, quote);

  001cb	8b cd		 mov	 ecx, ebp
  001cd	ff c9		 dec	 ecx
  001cf	74 13		 je	 SHORT $LN281@unicode_re
  001d1	ff c9		 dec	 ecx
  001d3	74 07		 je	 SHORT $LN280@unicode_re
  001d5	44 89 7c 9f fc	 mov	 DWORD PTR [rdi+rbx*4-4], r15d
  001da	eb 0d		 jmp	 SHORT $LN285@unicode_re
$LN280@unicode_re:
  001dc	66 44 89 7c 5f
	fe		 mov	 WORD PTR [rdi+rbx*2-2], r15w
  001e2	eb 05		 jmp	 SHORT $LN285@unicode_re
$LN281@unicode_re:
  001e4	44 88 7c 1f ff	 mov	 BYTE PTR [rdi+rbx-1], r15b
$LN285@unicode_re:

; 12101: 
; 12102:     for (i = 0, o = 1; i < isize; i++) {

  001e9	48 83 7c 24 68
	00		 cmp	 QWORD PTR isize$1$[rsp], 0
  001ef	bb 01 00 00 00	 mov	 ebx, 1
  001f4	0f 8e c3 05 00
	00		 jle	 $LN276@unicode_re
  001fa	4c 8b 64 24 60	 mov	 r12, QWORD PTR $T154323[rsp]
  001ff	8d 53 5b	 lea	 edx, QWORD PTR [rbx+91]
  00202	44 8d 4b 73	 lea	 r9d, QWORD PTR [rbx+115]
  00206	44 8d 53 6d	 lea	 r10d, QWORD PTR [rbx+109]
  0020a	44 8d 5b 71	 lea	 r11d, QWORD PTR [rbx+113]
  0020e	44 8d 43 77	 lea	 r8d, QWORD PTR [rbx+119]
  00212	45 33 ed	 xor	 r13d, r13d
$LL278@unicode_re:

; 12103:         Py_UCS4 ch = PyUnicode_READ(ikind, idata, i);

  00215	49 83 fc 01	 cmp	 r12, 1
  00219	75 08		 jne	 SHORT $LN338@unicode_re
  0021b	43 0f b6 74 35
	00		 movzx	 esi, BYTE PTR [r13+r14]
  00221	eb 11		 jmp	 SHORT $LN337@unicode_re
$LN338@unicode_re:
  00223	49 83 fc 02	 cmp	 r12, 2
  00227	75 07		 jne	 SHORT $LN336@unicode_re
  00229	43 0f b7 34 6e	 movzx	 esi, WORD PTR [r14+r13*2]
  0022e	eb 04		 jmp	 SHORT $LN337@unicode_re
$LN336@unicode_re:
  00230	43 8b 34 ae	 mov	 esi, DWORD PTR [r14+r13*4]
$LN337@unicode_re:

; 12104: 
; 12105:         /* Escape quotes and backslashes */
; 12106:         if ((ch == quote) || (ch == '\\')) {

  00234	41 3b f7	 cmp	 esi, r15d
  00237	0f 84 39 05 00
	00		 je	 $LN273@unicode_re
  0023d	83 fe 5c	 cmp	 esi, 92			; 0000005cH
  00240	0f 84 30 05 00
	00		 je	 $LN273@unicode_re

; 12109:             continue;
; 12110:         }
; 12111: 
; 12112:         /* Map special whitespace to '\t', \n', '\r' */
; 12113:         if (ch == '\t') {

  00246	83 fe 09	 cmp	 esi, 9
  00249	75 42		 jne	 SHORT $LN257@unicode_re

; 12114:             PyUnicode_WRITE(okind, odata, o++, '\\');

  0024b	8b cd		 mov	 ecx, ebp
  0024d	ff c9		 dec	 ecx
  0024f	74 0f		 je	 SHORT $LN251@unicode_re
  00251	ff c9		 dec	 ecx
  00253	74 05		 je	 SHORT $LN250@unicode_re
  00255	89 14 9f	 mov	 DWORD PTR [rdi+rbx*4], edx
  00258	eb 0a		 jmp	 SHORT $LN353@unicode_re
$LN250@unicode_re:
  0025a	66 89 14 5f	 mov	 WORD PTR [rdi+rbx*2], dx
  0025e	eb 04		 jmp	 SHORT $LN353@unicode_re
$LN251@unicode_re:
  00260	c6 04 3b 5c	 mov	 BYTE PTR [rbx+rdi], 92	; 0000005cH
$LN353@unicode_re:

; 12115:             PyUnicode_WRITE(okind, odata, o++, 't');

  00264	8b cd		 mov	 ecx, ebp
  00266	48 ff c3	 inc	 rbx
  00269	ff c9		 dec	 ecx
  0026b	74 17		 je	 SHORT $LN243@unicode_re
  0026d	ff c9		 dec	 ecx
  0026f	74 09		 je	 SHORT $LN242@unicode_re
  00271	44 89 0c 9f	 mov	 DWORD PTR [rdi+rbx*4], r9d
  00275	e9 2d 05 00 00	 jmp	 $LN354@unicode_re
$LN242@unicode_re:
  0027a	66 44 89 0c 5f	 mov	 WORD PTR [rdi+rbx*2], r9w
  0027f	e9 23 05 00 00	 jmp	 $LN354@unicode_re
$LN243@unicode_re:
  00284	c6 04 3b 74	 mov	 BYTE PTR [rbx+rdi], 116	; 00000074H

; 12116:         }
; 12117:         else if (ch == '\n') {

  00288	e9 1a 05 00 00	 jmp	 $LN354@unicode_re
$LN257@unicode_re:
  0028d	83 fe 0a	 cmp	 esi, 10
  00290	75 42		 jne	 SHORT $LN239@unicode_re

; 12118:             PyUnicode_WRITE(okind, odata, o++, '\\');

  00292	8b cd		 mov	 ecx, ebp
  00294	ff c9		 dec	 ecx
  00296	74 0f		 je	 SHORT $LN233@unicode_re
  00298	ff c9		 dec	 ecx
  0029a	74 05		 je	 SHORT $LN232@unicode_re
  0029c	89 14 9f	 mov	 DWORD PTR [rdi+rbx*4], edx
  0029f	eb 0a		 jmp	 SHORT $LN355@unicode_re
$LN232@unicode_re:
  002a1	66 89 14 5f	 mov	 WORD PTR [rdi+rbx*2], dx
  002a5	eb 04		 jmp	 SHORT $LN355@unicode_re
$LN233@unicode_re:
  002a7	c6 04 3b 5c	 mov	 BYTE PTR [rbx+rdi], 92	; 0000005cH
$LN355@unicode_re:

; 12119:             PyUnicode_WRITE(okind, odata, o++, 'n');

  002ab	8b cd		 mov	 ecx, ebp
  002ad	48 ff c3	 inc	 rbx
  002b0	ff c9		 dec	 ecx
  002b2	74 17		 je	 SHORT $LN225@unicode_re
  002b4	ff c9		 dec	 ecx
  002b6	74 09		 je	 SHORT $LN224@unicode_re
  002b8	44 89 14 9f	 mov	 DWORD PTR [rdi+rbx*4], r10d
  002bc	e9 e6 04 00 00	 jmp	 $LN354@unicode_re
$LN224@unicode_re:
  002c1	66 44 89 14 5f	 mov	 WORD PTR [rdi+rbx*2], r10w
  002c6	e9 dc 04 00 00	 jmp	 $LN354@unicode_re
$LN225@unicode_re:
  002cb	c6 04 3b 6e	 mov	 BYTE PTR [rbx+rdi], 110	; 0000006eH

; 12120:         }
; 12121:         else if (ch == '\r') {

  002cf	e9 d3 04 00 00	 jmp	 $LN354@unicode_re
$LN239@unicode_re:
  002d4	83 fe 0d	 cmp	 esi, 13
  002d7	75 42		 jne	 SHORT $LN221@unicode_re

; 12122:             PyUnicode_WRITE(okind, odata, o++, '\\');

  002d9	8b cd		 mov	 ecx, ebp
  002db	ff c9		 dec	 ecx
  002dd	74 0f		 je	 SHORT $LN215@unicode_re
  002df	ff c9		 dec	 ecx
  002e1	74 05		 je	 SHORT $LN214@unicode_re
  002e3	89 14 9f	 mov	 DWORD PTR [rdi+rbx*4], edx
  002e6	eb 0a		 jmp	 SHORT $LN356@unicode_re
$LN214@unicode_re:
  002e8	66 89 14 5f	 mov	 WORD PTR [rdi+rbx*2], dx
  002ec	eb 04		 jmp	 SHORT $LN356@unicode_re
$LN215@unicode_re:
  002ee	c6 04 3b 5c	 mov	 BYTE PTR [rbx+rdi], 92	; 0000005cH
$LN356@unicode_re:

; 12123:             PyUnicode_WRITE(okind, odata, o++, 'r');

  002f2	8b cd		 mov	 ecx, ebp
  002f4	48 ff c3	 inc	 rbx
  002f7	ff c9		 dec	 ecx
  002f9	74 17		 je	 SHORT $LN207@unicode_re
  002fb	ff c9		 dec	 ecx
  002fd	74 09		 je	 SHORT $LN206@unicode_re
  002ff	44 89 1c 9f	 mov	 DWORD PTR [rdi+rbx*4], r11d
  00303	e9 9f 04 00 00	 jmp	 $LN354@unicode_re
$LN206@unicode_re:
  00308	66 44 89 1c 5f	 mov	 WORD PTR [rdi+rbx*2], r11w
  0030d	e9 95 04 00 00	 jmp	 $LN354@unicode_re
$LN207@unicode_re:
  00312	c6 04 3b 72	 mov	 BYTE PTR [rbx+rdi], 114	; 00000072H

; 12124:         }
; 12125: 
; 12126:         /* Map non-printable US ASCII to '\xhh' */
; 12127:         else if (ch < ' ' || ch == 0x7F) {

  00316	e9 8c 04 00 00	 jmp	 $LN354@unicode_re
$LN221@unicode_re:
  0031b	83 fe 20	 cmp	 esi, 32			; 00000020H
  0031e	0f 82 c7 03 00
	00		 jb	 $LN201@unicode_re
  00324	83 fe 7f	 cmp	 esi, 127		; 0000007fH
  00327	0f 84 be 03 00
	00		 je	 $LN201@unicode_re

; 12132:         }
; 12133: 
; 12134:         /* Copy ASCII characters as-is */
; 12135:         else if (ch < 0x7F) {

  0032d	73 1f		 jae	 SHORT $LN168@unicode_re
$LN377@unicode_re:

; 12136:             PyUnicode_WRITE(okind, odata, o++, ch);

  0032f	8b cd		 mov	 ecx, ebp
$LN378@unicode_re:
  00331	ff c9		 dec	 ecx
  00333	0f 84 6a 04 00
	00		 je	 $LN260@unicode_re
  00339	ff c9		 dec	 ecx
  0033b	74 08		 je	 SHORT $LN161@unicode_re
  0033d	89 34 9f	 mov	 DWORD PTR [rdi+rbx*4], esi
  00340	e9 62 04 00 00	 jmp	 $LN354@unicode_re
$LN161@unicode_re:
  00345	66 89 34 5f	 mov	 WORD PTR [rdi+rbx*2], si
  00349	e9 59 04 00 00	 jmp	 $LN354@unicode_re
$LN168@unicode_re:

; 12137:         }
; 12138: 
; 12139:         /* Non-ASCII characters */
; 12140:         else {
; 12141:             /* Map Unicode whitespace and control characters
; 12142:                (categories Z* and C* except ASCII space)
; 12143:             */
; 12144:             if (!Py_UNICODE_ISPRINTABLE(ch)) {

  0034e	8b ce		 mov	 ecx, esi
  00350	e8 00 00 00 00	 call	 _PyUnicode_IsPrintable

; 12145:                 PyUnicode_WRITE(okind, odata, o++, '\\');

  00355	8b cd		 mov	 ecx, ebp
  00357	85 c0		 test	 eax, eax
  00359	0f 85 72 03 00
	00		 jne	 $LN8@unicode_re
  0035f	ff c9		 dec	 ecx
  00361	74 14		 je	 SHORT $LN152@unicode_re
  00363	ff c9		 dec	 ecx
  00365	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH
  0036a	74 05		 je	 SHORT $LN151@unicode_re
  0036c	89 04 9f	 mov	 DWORD PTR [rdi+rbx*4], eax
  0036f	eb 0a		 jmp	 SHORT $LN357@unicode_re
$LN151@unicode_re:
  00371	66 89 04 5f	 mov	 WORD PTR [rdi+rbx*2], ax
  00375	eb 04		 jmp	 SHORT $LN357@unicode_re
$LN152@unicode_re:
  00377	c6 04 3b 5c	 mov	 BYTE PTR [rbx+rdi], 92	; 0000005cH
$LN357@unicode_re:
  0037b	48 ff c3	 inc	 rbx

; 12146:                 /* Map 8-bit characters to '\xhh' */
; 12147:                 if (ch <= 0xff) {
; 12148:                     PyUnicode_WRITE(okind, odata, o++, 'x');

  0037e	8b cd		 mov	 ecx, ebp
  00380	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  00386	0f 87 b8 00 00
	00		 ja	 $LN149@unicode_re
  0038c	ff c9		 dec	 ecx
  0038e	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  00394	74 11		 je	 SHORT $LN143@unicode_re
  00396	ff c9		 dec	 ecx
  00398	74 06		 je	 SHORT $LN142@unicode_re
  0039a	44 89 04 9f	 mov	 DWORD PTR [rdi+rbx*4], r8d
  0039e	eb 0b		 jmp	 SHORT $LN358@unicode_re
$LN142@unicode_re:
  003a0	66 44 89 04 5f	 mov	 WORD PTR [rdi+rbx*2], r8w
  003a5	eb 04		 jmp	 SHORT $LN358@unicode_re
$LN143@unicode_re:
  003a7	c6 04 3b 78	 mov	 BYTE PTR [rbx+rdi], 120	; 00000078H
$LN358@unicode_re:

; 12149:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[(ch >> 4) & 0x000F]);

  003ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  003b2	8b cd		 mov	 ecx, ebp
  003b4	48 ff c3	 inc	 rbx
  003b7	ff c9		 dec	 ecx
  003b9	8b d6		 mov	 edx, esi
  003bb	74 27		 je	 SHORT $LN135@unicode_re
  003bd	ff c9		 dec	 ecx
  003bf	8b ce		 mov	 ecx, esi
  003c1	74 10		 je	 SHORT $LN134@unicode_re
  003c3	48 c1 e9 04	 shr	 rcx, 4
  003c7	83 e1 0f	 and	 ecx, 15
  003ca	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  003ce	89 0c 9f	 mov	 DWORD PTR [rdi+rbx*4], ecx
  003d1	eb 21		 jmp	 SHORT $LN359@unicode_re
$LN134@unicode_re:
  003d3	48 c1 e9 04	 shr	 rcx, 4
  003d7	83 e1 0f	 and	 ecx, 15
  003da	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  003de	66 89 0c 5f	 mov	 WORD PTR [rdi+rbx*2], cx
  003e2	eb 10		 jmp	 SHORT $LN359@unicode_re
$LN135@unicode_re:
  003e4	8b ce		 mov	 ecx, esi
  003e6	48 c1 e9 04	 shr	 rcx, 4
  003ea	83 e1 0f	 and	 ecx, 15
  003ed	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  003f1	88 0c 3b	 mov	 BYTE PTR [rbx+rdi], cl
$LN359@unicode_re:

; 12150:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[ch & 0x000F]);

  003f4	41 b9 74 00 00
	00		 mov	 r9d, 116		; 00000074H
  003fa	45 8d 59 fe	 lea	 r11d, QWORD PTR [r9-2]
  003fe	45 8d 51 fa	 lea	 r10d, QWORD PTR [r9-6]
$LN374@unicode_re:
  00402	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00409	8b cd		 mov	 ecx, ebp
  0040b	48 ff c3	 inc	 rbx
  0040e	83 e2 0f	 and	 edx, 15
  00411	ff c9		 dec	 ecx
  00413	74 1e		 je	 SHORT $LN127@unicode_re
  00415	ff c9		 dec	 ecx
  00417	0f be 0c 02	 movsx	 ecx, BYTE PTR [rdx+rax]
  0041b	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  00420	74 08		 je	 SHORT $LN126@unicode_re
  00422	89 0c 9f	 mov	 DWORD PTR [rdi+rbx*4], ecx
  00425	e9 7d 03 00 00	 jmp	 $LN354@unicode_re
$LN126@unicode_re:
  0042a	66 89 0c 5f	 mov	 WORD PTR [rdi+rbx*2], cx
  0042e	e9 74 03 00 00	 jmp	 $LN354@unicode_re
$LN127@unicode_re:
  00433	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]

; 12151:                 }
; 12152:                 /* Map 16-bit characters to '\uxxxx' */
; 12153:                 else if (ch <= 0xffff) {

  00437	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  0043c	88 0c 3b	 mov	 BYTE PTR [rbx+rdi], cl
  0043f	e9 63 03 00 00	 jmp	 $LN354@unicode_re
$LN149@unicode_re:
  00444	81 fe ff ff 00
	00		 cmp	 esi, 65535		; 0000ffffH
  0044a	0f 87 14 01 00
	00		 ja	 $LN81@unicode_re

; 12154:                     PyUnicode_WRITE(okind, odata, o++, 'u');

  00450	ff c9		 dec	 ecx
  00452	74 14		 je	 SHORT $LN117@unicode_re
  00454	ff c9		 dec	 ecx
  00456	b8 75 00 00 00	 mov	 eax, 117		; 00000075H
  0045b	74 05		 je	 SHORT $LN116@unicode_re
  0045d	89 04 9f	 mov	 DWORD PTR [rdi+rbx*4], eax
  00460	eb 0a		 jmp	 SHORT $LN360@unicode_re
$LN116@unicode_re:
  00462	66 89 04 5f	 mov	 WORD PTR [rdi+rbx*2], ax
  00466	eb 04		 jmp	 SHORT $LN360@unicode_re
$LN117@unicode_re:
  00468	c6 04 3b 75	 mov	 BYTE PTR [rbx+rdi], 117	; 00000075H
$LN360@unicode_re:

; 12155:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[(ch >> 12) & 0xF]);

  0046c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00473	8b cd		 mov	 ecx, ebp
  00475	48 ff c3	 inc	 rbx
  00478	ff c9		 dec	 ecx
  0047a	8b d6		 mov	 edx, esi
  0047c	74 27		 je	 SHORT $LN109@unicode_re
  0047e	ff c9		 dec	 ecx
  00480	8b ce		 mov	 ecx, esi
  00482	74 10		 je	 SHORT $LN108@unicode_re
  00484	48 c1 e9 0c	 shr	 rcx, 12
  00488	83 e1 0f	 and	 ecx, 15
  0048b	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  0048f	89 0c 9f	 mov	 DWORD PTR [rdi+rbx*4], ecx
  00492	eb 21		 jmp	 SHORT $LN361@unicode_re
$LN108@unicode_re:
  00494	48 c1 e9 0c	 shr	 rcx, 12
  00498	83 e1 0f	 and	 ecx, 15
  0049b	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  0049f	66 89 0c 5f	 mov	 WORD PTR [rdi+rbx*2], cx
  004a3	eb 10		 jmp	 SHORT $LN361@unicode_re
$LN109@unicode_re:
  004a5	8b ce		 mov	 ecx, esi
$LN379@unicode_re:
  004a7	48 c1 e9 0c	 shr	 rcx, 12
  004ab	83 e1 0f	 and	 ecx, 15
  004ae	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  004b2	88 0c 3b	 mov	 BYTE PTR [rbx+rdi], cl
$LN361@unicode_re:

; 12156:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[(ch >> 8) & 0xF]);

  004b5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  004bc	8b cd		 mov	 ecx, ebp
  004be	48 ff c3	 inc	 rbx
  004c1	ff c9		 dec	 ecx
  004c3	74 28		 je	 SHORT $LN101@unicode_re
  004c5	ff c9		 dec	 ecx
  004c7	48 8b ca	 mov	 rcx, rdx
  004ca	74 10		 je	 SHORT $LN100@unicode_re
  004cc	48 c1 e9 08	 shr	 rcx, 8
  004d0	83 e1 0f	 and	 ecx, 15
  004d3	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  004d7	89 0c 9f	 mov	 DWORD PTR [rdi+rbx*4], ecx
  004da	eb 22		 jmp	 SHORT $LN362@unicode_re
$LN100@unicode_re:
  004dc	48 c1 e9 08	 shr	 rcx, 8
  004e0	83 e1 0f	 and	 ecx, 15
  004e3	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  004e7	66 89 0c 5f	 mov	 WORD PTR [rdi+rbx*2], cx
  004eb	eb 11		 jmp	 SHORT $LN362@unicode_re
$LN101@unicode_re:
  004ed	48 8b ca	 mov	 rcx, rdx
  004f0	48 c1 e9 08	 shr	 rcx, 8
  004f4	83 e1 0f	 and	 ecx, 15
  004f7	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  004fb	88 0c 3b	 mov	 BYTE PTR [rbx+rdi], cl
$LN362@unicode_re:

; 12157:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[(ch >> 4) & 0xF]);

  004fe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00505	8b cd		 mov	 ecx, ebp
  00507	48 ff c3	 inc	 rbx
  0050a	ff c9		 dec	 ecx
  0050c	74 3a		 je	 SHORT $LN93@unicode_re
  0050e	ff c9		 dec	 ecx
  00510	48 8b ca	 mov	 rcx, rdx
  00513	74 19		 je	 SHORT $LN92@unicode_re
  00515	48 c1 e9 04	 shr	 rcx, 4

; 12158:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[ch & 0xF]);

  00519	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  0051f	83 e1 0f	 and	 ecx, 15
  00522	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  00526	89 0c 9f	 mov	 DWORD PTR [rdi+rbx*4], ecx
  00529	e9 c6 fe ff ff	 jmp	 $LN359@unicode_re
$LN92@unicode_re:

; 12157:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[(ch >> 4) & 0xF]);

  0052e	48 c1 e9 04	 shr	 rcx, 4

; 12158:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[ch & 0xF]);

  00532	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  00538	83 e1 0f	 and	 ecx, 15
  0053b	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  0053f	66 89 0c 5f	 mov	 WORD PTR [rdi+rbx*2], cx
  00543	e9 ac fe ff ff	 jmp	 $LN359@unicode_re
$LN93@unicode_re:

; 12157:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[(ch >> 4) & 0xF]);

  00548	48 8b ca	 mov	 rcx, rdx

; 12158:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[ch & 0xF]);

  0054b	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  00551	48 c1 e9 04	 shr	 rcx, 4
  00555	83 e1 0f	 and	 ecx, 15
  00558	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0055c	88 0c 3b	 mov	 BYTE PTR [rbx+rdi], cl
  0055f	e9 90 fe ff ff	 jmp	 $LN359@unicode_re
$LN81@unicode_re:

; 12159:                 }
; 12160:                 /* Map 21-bit characters to '\U00xxxxxx' */
; 12161:                 else {
; 12162:                     PyUnicode_WRITE(okind, odata, o++, 'U');

  00564	ff c9		 dec	 ecx
  00566	74 14		 je	 SHORT $LN76@unicode_re
  00568	ff c9		 dec	 ecx
  0056a	b8 55 00 00 00	 mov	 eax, 85			; 00000055H
  0056f	74 05		 je	 SHORT $LN75@unicode_re
  00571	89 04 9f	 mov	 DWORD PTR [rdi+rbx*4], eax
  00574	eb 0a		 jmp	 SHORT $LN364@unicode_re
$LN75@unicode_re:
  00576	66 89 04 5f	 mov	 WORD PTR [rdi+rbx*2], ax
  0057a	eb 04		 jmp	 SHORT $LN364@unicode_re
$LN76@unicode_re:
  0057c	c6 04 3b 55	 mov	 BYTE PTR [rbx+rdi], 85	; 00000055H
$LN364@unicode_re:

; 12163:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[(ch >> 28) & 0xF]);

  00580	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00587	8b cd		 mov	 ecx, ebp
  00589	48 ff c3	 inc	 rbx
  0058c	ff c9		 dec	 ecx
  0058e	8b d6		 mov	 edx, esi
  00590	74 21		 je	 SHORT $LN68@unicode_re
  00592	ff c9		 dec	 ecx
  00594	8b ce		 mov	 ecx, esi
  00596	74 0d		 je	 SHORT $LN67@unicode_re
  00598	48 c1 e9 1c	 shr	 rcx, 28
  0059c	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  005a0	89 0c 9f	 mov	 DWORD PTR [rdi+rbx*4], ecx
  005a3	eb 1b		 jmp	 SHORT $LN365@unicode_re
$LN67@unicode_re:
  005a5	48 c1 e9 1c	 shr	 rcx, 28
  005a9	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  005ad	66 89 0c 5f	 mov	 WORD PTR [rdi+rbx*2], cx
  005b1	eb 0d		 jmp	 SHORT $LN365@unicode_re
$LN68@unicode_re:
  005b3	8b ce		 mov	 ecx, esi
  005b5	48 c1 e9 1c	 shr	 rcx, 28
  005b9	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  005bd	88 0c 3b	 mov	 BYTE PTR [rbx+rdi], cl
$LN365@unicode_re:

; 12164:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[(ch >> 24) & 0xF]);

  005c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  005c7	8b cd		 mov	 ecx, ebp
  005c9	48 ff c3	 inc	 rbx
  005cc	ff c9		 dec	 ecx
  005ce	74 28		 je	 SHORT $LN60@unicode_re
  005d0	ff c9		 dec	 ecx
  005d2	48 8b ca	 mov	 rcx, rdx
  005d5	74 10		 je	 SHORT $LN59@unicode_re
  005d7	48 c1 e9 18	 shr	 rcx, 24
  005db	83 e1 0f	 and	 ecx, 15
  005de	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  005e2	89 0c 9f	 mov	 DWORD PTR [rdi+rbx*4], ecx
  005e5	eb 22		 jmp	 SHORT $LN366@unicode_re
$LN59@unicode_re:
  005e7	48 c1 e9 18	 shr	 rcx, 24
  005eb	83 e1 0f	 and	 ecx, 15
  005ee	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  005f2	66 89 0c 5f	 mov	 WORD PTR [rdi+rbx*2], cx
  005f6	eb 11		 jmp	 SHORT $LN366@unicode_re
$LN60@unicode_re:
  005f8	48 8b ca	 mov	 rcx, rdx
  005fb	48 c1 e9 18	 shr	 rcx, 24
  005ff	83 e1 0f	 and	 ecx, 15
  00602	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00606	88 0c 3b	 mov	 BYTE PTR [rbx+rdi], cl
$LN366@unicode_re:

; 12165:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[(ch >> 20) & 0xF]);

  00609	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00610	8b cd		 mov	 ecx, ebp
  00612	48 ff c3	 inc	 rbx
  00615	ff c9		 dec	 ecx
  00617	74 28		 je	 SHORT $LN52@unicode_re
  00619	ff c9		 dec	 ecx
  0061b	48 8b ca	 mov	 rcx, rdx
  0061e	74 10		 je	 SHORT $LN51@unicode_re
  00620	48 c1 e9 14	 shr	 rcx, 20
  00624	83 e1 0f	 and	 ecx, 15
  00627	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  0062b	89 0c 9f	 mov	 DWORD PTR [rdi+rbx*4], ecx
  0062e	eb 22		 jmp	 SHORT $LN367@unicode_re
$LN51@unicode_re:
  00630	48 c1 e9 14	 shr	 rcx, 20
  00634	83 e1 0f	 and	 ecx, 15
  00637	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  0063b	66 89 0c 5f	 mov	 WORD PTR [rdi+rbx*2], cx
  0063f	eb 11		 jmp	 SHORT $LN367@unicode_re
$LN52@unicode_re:
  00641	48 8b ca	 mov	 rcx, rdx
  00644	48 c1 e9 14	 shr	 rcx, 20
  00648	83 e1 0f	 and	 ecx, 15
  0064b	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0064f	88 0c 3b	 mov	 BYTE PTR [rbx+rdi], cl
$LN367@unicode_re:

; 12166:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[(ch >> 16) & 0xF]);

  00652	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00659	8b cd		 mov	 ecx, ebp
  0065b	48 ff c3	 inc	 rbx
  0065e	ff c9		 dec	 ecx
  00660	74 28		 je	 SHORT $LN44@unicode_re
  00662	ff c9		 dec	 ecx
  00664	48 8b ca	 mov	 rcx, rdx
  00667	74 10		 je	 SHORT $LN43@unicode_re
  00669	48 c1 e9 10	 shr	 rcx, 16
  0066d	83 e1 0f	 and	 ecx, 15
  00670	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  00674	89 0c 9f	 mov	 DWORD PTR [rdi+rbx*4], ecx
  00677	eb 22		 jmp	 SHORT $LN368@unicode_re
$LN43@unicode_re:
  00679	48 c1 e9 10	 shr	 rcx, 16
  0067d	83 e1 0f	 and	 ecx, 15
  00680	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  00684	66 89 0c 5f	 mov	 WORD PTR [rdi+rbx*2], cx
  00688	eb 11		 jmp	 SHORT $LN368@unicode_re
$LN44@unicode_re:
  0068a	48 8b ca	 mov	 rcx, rdx
  0068d	48 c1 e9 10	 shr	 rcx, 16
  00691	83 e1 0f	 and	 ecx, 15
  00694	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00698	88 0c 3b	 mov	 BYTE PTR [rbx+rdi], cl
$LN368@unicode_re:

; 12167:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[(ch >> 12) & 0xF]);

  0069b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  006a2	8b cd		 mov	 ecx, ebp
  006a4	48 ff c3	 inc	 rbx
  006a7	ff c9		 dec	 ecx
  006a9	74 1e		 je	 SHORT $LN36@unicode_re
  006ab	ff c9		 dec	 ecx
  006ad	48 8b ca	 mov	 rcx, rdx
  006b0	0f 84 de fd ff
	ff		 je	 $LN108@unicode_re
  006b6	48 c1 e9 0c	 shr	 rcx, 12
  006ba	83 e1 0f	 and	 ecx, 15
  006bd	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  006c1	89 0c 9f	 mov	 DWORD PTR [rdi+rbx*4], ecx
  006c4	e9 ec fd ff ff	 jmp	 $LN361@unicode_re
$LN36@unicode_re:
  006c9	48 8b ca	 mov	 rcx, rdx

; 12168:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[(ch >> 8) & 0xF]);

  006cc	e9 d6 fd ff ff	 jmp	 $LN379@unicode_re
$LN8@unicode_re:

; 12169:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[(ch >> 4) & 0xF]);
; 12170:                     PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[ch & 0xF]);
; 12171:                 }
; 12172:             }
; 12173:             /* Copy characters as-is */
; 12174:             else {
; 12175:                 PyUnicode_WRITE(okind, odata, o++, ch);

  006d1	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  006d6	44 8d 42 1c	 lea	 r8d, QWORD PTR [rdx+28]
  006da	44 8d 4a 18	 lea	 r9d, QWORD PTR [rdx+24]
  006de	44 8d 52 12	 lea	 r10d, QWORD PTR [rdx+18]
  006e2	44 8d 5a 16	 lea	 r11d, QWORD PTR [rdx+22]
  006e6	e9 46 fc ff ff	 jmp	 $LN378@unicode_re
$LN201@unicode_re:

; 12128:             PyUnicode_WRITE(okind, odata, o++, '\\');

  006eb	8b cd		 mov	 ecx, ebp
  006ed	ff c9		 dec	 ecx
  006ef	74 0f		 je	 SHORT $LN196@unicode_re
  006f1	ff c9		 dec	 ecx
  006f3	74 05		 je	 SHORT $LN195@unicode_re
  006f5	89 14 9f	 mov	 DWORD PTR [rdi+rbx*4], edx
  006f8	eb 0a		 jmp	 SHORT $LN372@unicode_re
$LN195@unicode_re:
  006fa	66 89 14 5f	 mov	 WORD PTR [rdi+rbx*2], dx
  006fe	eb 04		 jmp	 SHORT $LN372@unicode_re
$LN196@unicode_re:
  00700	c6 04 3b 5c	 mov	 BYTE PTR [rbx+rdi], 92	; 0000005cH
$LN372@unicode_re:

; 12129:             PyUnicode_WRITE(okind, odata, o++, 'x');

  00704	8b cd		 mov	 ecx, ebp
  00706	48 ff c3	 inc	 rbx
  00709	ff c9		 dec	 ecx
  0070b	74 11		 je	 SHORT $LN188@unicode_re
  0070d	ff c9		 dec	 ecx
  0070f	74 06		 je	 SHORT $LN187@unicode_re
  00711	44 89 04 9f	 mov	 DWORD PTR [rdi+rbx*4], r8d
  00715	eb 0b		 jmp	 SHORT $LN373@unicode_re
$LN187@unicode_re:
  00717	66 44 89 04 5f	 mov	 WORD PTR [rdi+rbx*2], r8w
  0071c	eb 04		 jmp	 SHORT $LN373@unicode_re
$LN188@unicode_re:
  0071e	c6 04 3b 78	 mov	 BYTE PTR [rbx+rdi], 120	; 00000078H
$LN373@unicode_re:

; 12130:             PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[(ch >> 4) & 0x000F]);

  00722	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00729	8b cd		 mov	 ecx, ebp
  0072b	48 ff c3	 inc	 rbx
  0072e	ff c9		 dec	 ecx
  00730	8b d6		 mov	 edx, esi
  00732	74 2d		 je	 SHORT $LN180@unicode_re
  00734	ff c9		 dec	 ecx
  00736	8b ce		 mov	 ecx, esi
  00738	74 13		 je	 SHORT $LN179@unicode_re
  0073a	48 c1 e9 04	 shr	 rcx, 4
  0073e	83 e1 0f	 and	 ecx, 15
  00741	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  00745	89 0c 9f	 mov	 DWORD PTR [rdi+rbx*4], ecx
  00748	e9 b5 fc ff ff	 jmp	 $LN374@unicode_re
$LN179@unicode_re:
  0074d	48 c1 e9 04	 shr	 rcx, 4
  00751	83 e1 0f	 and	 ecx, 15
  00754	0f be 0c 01	 movsx	 ecx, BYTE PTR [rcx+rax]
  00758	66 89 0c 5f	 mov	 WORD PTR [rdi+rbx*2], cx
  0075c	e9 a1 fc ff ff	 jmp	 $LN374@unicode_re
$LN180@unicode_re:
  00761	8b ce		 mov	 ecx, esi
  00763	48 c1 e9 04	 shr	 rcx, 4
  00767	83 e1 0f	 and	 ecx, 15
  0076a	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0076e	88 0c 3b	 mov	 BYTE PTR [rbx+rdi], cl

; 12131:             PyUnicode_WRITE(okind, odata, o++, Py_hexdigits[ch & 0x000F]);

  00771	e9 8c fc ff ff	 jmp	 $LN374@unicode_re
$LN273@unicode_re:

; 12107:             PyUnicode_WRITE(okind, odata, o++, '\\');

  00776	8b cd		 mov	 ecx, ebp
  00778	ff c9		 dec	 ecx
  0077a	74 1b		 je	 SHORT $LN268@unicode_re
  0077c	ff c9		 dec	 ecx
  0077e	74 0b		 je	 SHORT $LN267@unicode_re
  00780	89 14 9f	 mov	 DWORD PTR [rdi+rbx*4], edx
  00783	48 ff c3	 inc	 rbx

; 12108:             PyUnicode_WRITE(okind, odata, o++, ch);

  00786	e9 a4 fb ff ff	 jmp	 $LN377@unicode_re
$LN267@unicode_re:

; 12107:             PyUnicode_WRITE(okind, odata, o++, '\\');

  0078b	66 89 14 5f	 mov	 WORD PTR [rdi+rbx*2], dx
  0078f	48 ff c3	 inc	 rbx

; 12108:             PyUnicode_WRITE(okind, odata, o++, ch);

  00792	e9 98 fb ff ff	 jmp	 $LN377@unicode_re
$LN268@unicode_re:

; 12107:             PyUnicode_WRITE(okind, odata, o++, '\\');

  00797	c6 04 3b 5c	 mov	 BYTE PTR [rbx+rdi], 92	; 0000005cH
  0079b	48 ff c3	 inc	 rbx

; 12108:             PyUnicode_WRITE(okind, odata, o++, ch);

  0079e	e9 8c fb ff ff	 jmp	 $LN377@unicode_re
$LN260@unicode_re:
  007a3	40 88 34 3b	 mov	 BYTE PTR [rbx+rdi], sil
$LN354@unicode_re:

; 12101: 
; 12102:     for (i = 0, o = 1; i < isize; i++) {

  007a7	49 ff c5	 inc	 r13

; 12108:             PyUnicode_WRITE(okind, odata, o++, ch);

  007aa	48 ff c3	 inc	 rbx
  007ad	4c 3b 6c 24 68	 cmp	 r13, QWORD PTR isize$1$[rsp]
  007b2	0f 8c 5d fa ff
	ff		 jl	 $LL278@unicode_re
  007b8	4c 8b 64 24 70	 mov	 r12, QWORD PTR repr$1$[rsp]
$LN276@unicode_re:

; 12176:             }
; 12177:         }
; 12178:     }
; 12179:     /* Closing quote already added at the beginning */
; 12180:     assert(_PyUnicode_CheckConsistency(repr, 1));
; 12181:     return repr;

  007bd	49 8b c4	 mov	 rax, r12
$LN352@unicode_re:
  007c0	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  007c5	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]
  007ca	4c 8b 64 24 38	 mov	 r12, QWORD PTR [rsp+56]
  007cf	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]
  007d4	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  007d9	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  007de	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]

; 12182: }

  007e3	48 83 c4 50	 add	 rsp, 80			; 00000050H
  007e7	5b		 pop	 rbx
  007e8	c3		 ret	 0
  007e9	0f 1f 00	 npad	 3
$LN345@unicode_re:
  007ec	00 00 00 00	 DD	 $LN311@unicode_re
  007f0	00 00 00 00	 DD	 $LN312@unicode_re
  007f4	00 00 00 00	 DD	 $LN313@unicode_re
  007f8	00 00 00 00	 DD	 $LN310@unicode_re
$LN344@unicode_re:
  007fc	00		 DB	 0
  007fd	00		 DB	 0
  007fe	03		 DB	 3
  007ff	03		 DB	 3
  00800	00		 DB	 0
  00801	03		 DB	 3
  00802	03		 DB	 3
  00803	03		 DB	 3
  00804	03		 DB	 3
  00805	03		 DB	 3
  00806	03		 DB	 3
  00807	03		 DB	 3
  00808	03		 DB	 3
  00809	03		 DB	 3
  0080a	03		 DB	 3
  0080b	03		 DB	 3
  0080c	03		 DB	 3
  0080d	03		 DB	 3
  0080e	03		 DB	 3
  0080f	03		 DB	 3
  00810	03		 DB	 3
  00811	03		 DB	 3
  00812	03		 DB	 3
  00813	03		 DB	 3
  00814	03		 DB	 3
  00815	01		 DB	 1
  00816	03		 DB	 3
  00817	03		 DB	 3
  00818	03		 DB	 3
  00819	03		 DB	 3
  0081a	02		 DB	 2
  0081b	03		 DB	 3
  0081c	03		 DB	 3
  0081d	03		 DB	 3
  0081e	03		 DB	 3
  0081f	03		 DB	 3
  00820	03		 DB	 3
  00821	03		 DB	 3
  00822	03		 DB	 3
  00823	03		 DB	 3
  00824	03		 DB	 3
  00825	03		 DB	 3
  00826	03		 DB	 3
  00827	03		 DB	 3
  00828	03		 DB	 3
  00829	03		 DB	 3
  0082a	03		 DB	 3
  0082b	03		 DB	 3
  0082c	03		 DB	 3
  0082d	03		 DB	 3
  0082e	03		 DB	 3
  0082f	03		 DB	 3
  00830	03		 DB	 3
  00831	03		 DB	 3
  00832	03		 DB	 3
  00833	03		 DB	 3
  00834	03		 DB	 3
  00835	03		 DB	 3
  00836	03		 DB	 3
  00837	03		 DB	 3
  00838	03		 DB	 3
  00839	03		 DB	 3
  0083a	03		 DB	 3
  0083b	03		 DB	 3
  0083c	03		 DB	 3
  0083d	03		 DB	 3
  0083e	03		 DB	 3
  0083f	03		 DB	 3
  00840	03		 DB	 3
  00841	03		 DB	 3
  00842	03		 DB	 3
  00843	03		 DB	 3
  00844	03		 DB	 3
  00845	03		 DB	 3
  00846	03		 DB	 3
  00847	03		 DB	 3
  00848	03		 DB	 3
  00849	03		 DB	 3
  0084a	03		 DB	 3
  0084b	03		 DB	 3
  0084c	03		 DB	 3
  0084d	03		 DB	 3
  0084e	03		 DB	 3
  0084f	00		 DB	 0
unicode_repr ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_swapcase DD imagerel unicode_swapcase
	DD	imagerel unicode_swapcase+53
	DD	imagerel $unwind$unicode_swapcase
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_swapcase DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_swapcase
_TEXT	SEGMENT
self$ = 48
unicode_swapcase PROC					; COMDAT

; 12591: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 12592:     if (PyUnicode_READY(self) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	75 12		 jne	 SHORT $LN1@unicode_sw
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN1@unicode_sw

; 12593:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 12595: }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
$LN1@unicode_sw:

; 12594:     return case_operation(self, do_swapcase);

  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:do_swapcase
  00028	48 8b cb	 mov	 rcx, rbx

; 12595: }

  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx
  00030	e9 00 00 00 00	 jmp	 case_operation
unicode_swapcase ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@BJAPICGP@keys?5in?5translate?5table?5must?5be?5@ ; `string'
PUBLIC	??_C@_0DD@CFDKOGOA@string?5keys?5in?5translate?5table?5m@ ; `string'
PUBLIC	??_C@_0DN@JOACEDJG@if?5you?5give?5only?5one?5argument?5to@ ; `string'
PUBLIC	??_C@_0DJ@NPFHOBLF@the?5first?5two?5maketrans?5argument@ ; `string'
PUBLIC	??_C@_0EI@FCCHHGHL@first?5maketrans?5argument?5must?5be@ ; `string'
PUBLIC	??_C@_0P@OBBDLJPP@O?$HMUU?3maketrans?$AA@	; `string'
EXTRN	PyDict_Next:PROC
EXTRN	PyDict_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_maketrans DD imagerel unicode_maketrans
	DD	imagerel unicode_maketrans+72
	DD	imagerel $unwind$unicode_maketrans
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_maketrans DD imagerel unicode_maketrans+72
	DD	imagerel unicode_maketrans+102
	DD	imagerel $chain$0$unicode_maketrans
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$unicode_maketrans DD imagerel unicode_maketrans+102
	DD	imagerel unicode_maketrans+722
	DD	imagerel $chain$7$unicode_maketrans
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$unicode_maketrans DD imagerel unicode_maketrans+722
	DD	imagerel unicode_maketrans+1026
	DD	imagerel $chain$9$unicode_maketrans
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$unicode_maketrans DD 0c0021H
	DD	0af400H
	DD	0be400H
	DD	0cd400H
	DD	0dc400H
	DD	0e6400H
	DD	0123400H
	DD	imagerel unicode_maketrans
	DD	imagerel unicode_maketrans+72
	DD	imagerel $unwind$unicode_maketrans
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$unicode_maketrans DD 0c2021H
	DD	0be420H
	DD	0cd41bH
	DD	0dc416H
	DD	0e640dH
	DD	0123408H
	DD	0af400H
	DD	imagerel unicode_maketrans
	DD	imagerel unicode_maketrans+72
	DD	imagerel $unwind$unicode_maketrans
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_maketrans DD 020521H
	DD	0af405H
	DD	imagerel unicode_maketrans
	DD	imagerel unicode_maketrans+72
	DD	imagerel $unwind$unicode_maketrans
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_maketrans DD 030a01H
	DD	07003e20aH
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0DE@BJAPICGP@keys?5in?5translate?5table?5must?5be?5@
CONST	SEGMENT
??_C@_0DE@BJAPICGP@keys?5in?5translate?5table?5must?5be?5@ DB 'keys in tr'
	DB	'anslate table must be strings or integers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@CFDKOGOA@string?5keys?5in?5translate?5table?5m@
CONST	SEGMENT
??_C@_0DD@CFDKOGOA@string?5keys?5in?5translate?5table?5m@ DB 'string keys'
	DB	' in translate table must be of length 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@JOACEDJG@if?5you?5give?5only?5one?5argument?5to@
CONST	SEGMENT
??_C@_0DN@JOACEDJG@if?5you?5give?5only?5one?5argument?5to@ DB 'if you giv'
	DB	'e only one argument to maketrans it must be a dict', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@NPFHOBLF@the?5first?5two?5maketrans?5argument@
CONST	SEGMENT
??_C@_0DJ@NPFHOBLF@the?5first?5two?5maketrans?5argument@ DB 'the first tw'
	DB	'o maketrans arguments must have equal length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@FCCHHGHL@first?5maketrans?5argument?5must?5be@
CONST	SEGMENT
??_C@_0EI@FCCHHGHL@first?5maketrans?5argument?5must?5be@ DB 'first maketr'
	DB	'ans argument must be a string if there is a second argument', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OBBDLJPP@O?$HMUU?3maketrans?$AA@
CONST	SEGMENT
??_C@_0P@OBBDLJPP@O?$HMUU?3maketrans?$AA@ DB 'O|UU:maketrans', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_maketrans
_TEXT	SEGMENT
value$ = 48
x$ = 56
z$ = 64
y$ = 72
null$ = 144
args$ = 152
i$ = 160
key$ = 168
unicode_maketrans PROC					; COMDAT

; 12611: {

  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 8b ec	 mov	 rbp, rsp
  00006	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000a	48 8b c2	 mov	 rax, rdx

; 12612:     PyObject *x, *y = NULL, *z = NULL;

  0000d	33 ff		 xor	 edi, edi

; 12613:     PyObject *new = NULL, *key, *value;
; 12614:     Py_ssize_t i = 0;
; 12615:     int res;
; 12616: 
; 12617:     if (!PyArg_ParseTuple(args, "O|UU:maketrans", &x, &y, &z))

  0000f	48 8d 4d c8	 lea	 rcx, QWORD PTR z$[rbp-120]
  00013	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00018	4c 8d 4d d0	 lea	 r9, QWORD PTR y$[rbp-120]
  0001c	4c 8d 45 c0	 lea	 r8, QWORD PTR x$[rbp-120]
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@OBBDLJPP@O?$HMUU?3maketrans?$AA@
  00027	48 8b c8	 mov	 rcx, rax
  0002a	48 89 7d d0	 mov	 QWORD PTR y$[rbp-120], rdi
  0002e	48 89 7d c8	 mov	 QWORD PTR z$[rbp-120], rdi
  00032	48 89 7d 28	 mov	 QWORD PTR i$[rbp-120], rdi
  00036	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003b	85 c0		 test	 eax, eax
  0003d	75 09		 jne	 SHORT $LN29@unicode_ma

; 12618:         return NULL;

  0003f	33 c0		 xor	 eax, eax

; 12715: }

  00041	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00045	5f		 pop	 rdi
  00046	5d		 pop	 rbp
  00047	c3		 ret	 0
$LN29@unicode_ma:
  00048	4c 89 7c 24 50	 mov	 QWORD PTR [rsp+80], r15

; 12619:     new = PyDict_New();

  0004d	e8 00 00 00 00	 call	 PyDict_New
  00052	4c 8b f8	 mov	 r15, rax

; 12620:     if (!new)

  00055	48 85 c0	 test	 rax, rax
  00058	75 0c		 jne	 SHORT $LN28@unicode_ma
  0005a	4c 8b 7c 24 50	 mov	 r15, QWORD PTR [rsp+80]

; 12715: }

  0005f	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00063	5f		 pop	 rdi
  00064	5d		 pop	 rbp
  00065	c3		 ret	 0
$LN28@unicode_ma:
  00066	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx
  0006e	48 89 74 24 70	 mov	 QWORD PTR [rsp+112], rsi

; 12621:         return NULL;
; 12622:     if (y != NULL) {

  00073	48 8b 75 d0	 mov	 rsi, QWORD PTR y$[rbp-120]
  00077	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  0007c	4c 89 6c 24 60	 mov	 QWORD PTR [rsp+96], r13
  00081	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14
  00086	48 85 f6	 test	 rsi, rsi
  00089	0f 84 43 02 00
	00		 je	 $LN27@unicode_ma

; 12623:         int x_kind, y_kind, z_kind;
; 12624:         void *x_data, *y_data, *z_data;
; 12625: 
; 12626:         /* x must be a string too, of equal length */
; 12627:         if (!PyUnicode_Check(x)) {

  0008f	48 8b 55 c0	 mov	 rdx, QWORD PTR x$[rbp-120]
  00093	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00097	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  000a1	75 0c		 jne	 SHORT $LN26@unicode_ma

; 12628:             PyErr_SetString(PyExc_TypeError, "first maketrans argument must "
; 12629:                             "be a string if there is a second argument");

  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EI@FCCHHGHL@first?5maketrans?5argument?5must?5be@

; 12630:             goto err;

  000aa	e9 38 03 00 00	 jmp	 $LN85@unicode_ma
$LN26@unicode_ma:

; 12631:         }
; 12632:         if (PyUnicode_GET_LENGTH(x) != PyUnicode_GET_LENGTH(y)) {

  000af	48 8b 46 60	 mov	 rax, QWORD PTR [rsi+96]
  000b3	48 39 42 60	 cmp	 QWORD PTR [rdx+96], rax
  000b7	74 13		 je	 SHORT $LN25@unicode_ma

; 12633:             PyErr_SetString(PyExc_ValueError, "the first two maketrans "
; 12634:                             "arguments must have equal length");

  000b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DJ@NPFHOBLF@the?5first?5two?5maketrans?5argument@

; 12635:             goto err;

  000c7	e9 22 03 00 00	 jmp	 $LN86@unicode_ma
$LN25@unicode_ma:

; 12636:         }
; 12637:         /* create entries for translating chars in x to those in y */
; 12638:         x_kind = PyUnicode_KIND(x);

  000cc	8b 42 70	 mov	 eax, DWORD PTR [rdx+112]

; 12639:         y_kind = PyUnicode_KIND(y);

  000cf	8b 4e 70	 mov	 ecx, DWORD PTR [rsi+112]
  000d2	44 8b c0	 mov	 r8d, eax
  000d5	44 8b c9	 mov	 r9d, ecx
  000d8	41 c1 e8 02	 shr	 r8d, 2
  000dc	41 c1 e9 02	 shr	 r9d, 2
  000e0	41 83 e0 07	 and	 r8d, 7
  000e4	41 83 e1 07	 and	 r9d, 7

; 12640:         x_data = PyUnicode_DATA(x);

  000e8	a8 20		 test	 al, 32			; 00000020H
  000ea	74 16		 je	 SHORT $LN34@unicode_ma
  000ec	a8 40		 test	 al, 64			; 00000040H
  000ee	74 09		 je	 SHORT $LN32@unicode_ma
  000f0	4c 8d a2 80 00
	00 00		 lea	 r12, QWORD PTR [rdx+128]
  000f7	eb 10		 jmp	 SHORT $LN35@unicode_ma
$LN32@unicode_ma:
  000f9	4c 8d a2 a0 00
	00 00		 lea	 r12, QWORD PTR [rdx+160]
  00100	eb 07		 jmp	 SHORT $LN35@unicode_ma
$LN34@unicode_ma:
  00102	4c 8b a2 a0 00
	00 00		 mov	 r12, QWORD PTR [rdx+160]
$LN35@unicode_ma:

; 12641:         y_data = PyUnicode_DATA(y);

  00109	f6 c1 20	 test	 cl, 32			; 00000020H
  0010c	74 14		 je	 SHORT $LN38@unicode_ma
  0010e	f6 c1 40	 test	 cl, 64			; 00000040H
  00111	74 06		 je	 SHORT $LN36@unicode_ma
  00113	48 83 ee 80	 sub	 rsi, -128		; ffffffffffffff80H
  00117	eb 10		 jmp	 SHORT $LN39@unicode_ma
$LN36@unicode_ma:
  00119	48 81 c6 a0 00
	00 00		 add	 rsi, 160		; 000000a0H
  00120	eb 07		 jmp	 SHORT $LN39@unicode_ma
$LN38@unicode_ma:
  00122	48 8b b6 a0 00
	00 00		 mov	 rsi, QWORD PTR [rsi+160]
$LN39@unicode_ma:

; 12642:         for (i = 0; i < PyUnicode_GET_LENGTH(x); i++) {

  00129	48 8b cf	 mov	 rcx, rdi

; 12643:             key = PyLong_FromLong(PyUnicode_READ(x_kind, x_data, i));

  0012c	4d 63 f0	 movsxd	 r14, r8d

; 12645:                 goto err;
; 12646:             value = PyLong_FromLong(PyUnicode_READ(y_kind, y_data, i));

  0012f	4d 63 e9	 movsxd	 r13, r9d
  00132	48 89 4d 28	 mov	 QWORD PTR i$[rbp-120], rcx
  00136	48 39 4a 60	 cmp	 QWORD PTR [rdx+96], rcx
  0013a	0f 8e a1 00 00
	00		 jle	 $LN22@unicode_ma
$LL24@unicode_ma:

; 12643:             key = PyLong_FromLong(PyUnicode_READ(x_kind, x_data, i));

  00140	49 83 fe 01	 cmp	 r14, 1
  00144	75 07		 jne	 SHORT $LN42@unicode_ma
  00146	41 0f b6 0c 0c	 movzx	 ecx, BYTE PTR [r12+rcx]
  0014b	eb 11		 jmp	 SHORT $LN41@unicode_ma
$LN42@unicode_ma:
  0014d	49 83 fe 02	 cmp	 r14, 2
  00151	75 07		 jne	 SHORT $LN40@unicode_ma
  00153	41 0f b7 0c 4c	 movzx	 ecx, WORD PTR [r12+rcx*2]
  00158	eb 04		 jmp	 SHORT $LN41@unicode_ma
$LN40@unicode_ma:
  0015a	41 8b 0c 8c	 mov	 ecx, DWORD PTR [r12+rcx*4]
$LN41@unicode_ma:
  0015e	e8 00 00 00 00	 call	 PyLong_FromLong
  00163	48 89 45 30	 mov	 QWORD PTR key$[rbp-120], rax

; 12644:             if (!key)

  00167	48 85 c0	 test	 rax, rax
  0016a	0f 84 83 02 00
	00		 je	 $err$140904

; 12645:                 goto err;
; 12646:             value = PyLong_FromLong(PyUnicode_READ(y_kind, y_data, i));

  00170	48 8b 45 28	 mov	 rax, QWORD PTR i$[rbp-120]
  00174	49 83 fd 01	 cmp	 r13, 1
  00178	75 06		 jne	 SHORT $LN46@unicode_ma
  0017a	0f b6 0c 06	 movzx	 ecx, BYTE PTR [rsi+rax]
  0017e	eb 0f		 jmp	 SHORT $LN45@unicode_ma
$LN46@unicode_ma:
  00180	49 83 fd 02	 cmp	 r13, 2
  00184	75 06		 jne	 SHORT $LN44@unicode_ma
  00186	0f b7 0c 46	 movzx	 ecx, WORD PTR [rsi+rax*2]
  0018a	eb 03		 jmp	 SHORT $LN45@unicode_ma
$LN44@unicode_ma:
  0018c	8b 0c 86	 mov	 ecx, DWORD PTR [rsi+rax*4]
$LN45@unicode_ma:
  0018f	e8 00 00 00 00	 call	 PyLong_FromLong
  00194	48 89 45 b8	 mov	 QWORD PTR value$[rbp-120], rax

; 12647:             if (!value) {

  00198	48 85 c0	 test	 rax, rax
  0019b	74 6d		 je	 SHORT $LN68@unicode_ma

; 12649:                 goto err;
; 12650:             }
; 12651:             res = PyDict_SetItem(new, key, value);

  0019d	48 8b 55 30	 mov	 rdx, QWORD PTR key$[rbp-120]
  001a1	4c 8b c0	 mov	 r8, rax
  001a4	49 8b cf	 mov	 rcx, r15
  001a7	e8 00 00 00 00	 call	 PyDict_SetItem

; 12652:             Py_DECREF(key);

  001ac	48 8b 4d 30	 mov	 rcx, QWORD PTR key$[rbp-120]
  001b0	8b d8		 mov	 ebx, eax
  001b2	e8 00 00 00 00	 call	 _Py_DecRef

; 12653:             Py_DECREF(value);

  001b7	48 8b 4d b8	 mov	 rcx, QWORD PTR value$[rbp-120]
  001bb	e8 00 00 00 00	 call	 _Py_DecRef

; 12654:             if (res < 0)

  001c0	85 db		 test	 ebx, ebx
  001c2	0f 88 2b 02 00
	00		 js	 $err$140904

; 12642:         for (i = 0; i < PyUnicode_GET_LENGTH(x); i++) {

  001c8	48 8b 4d 28	 mov	 rcx, QWORD PTR i$[rbp-120]
  001cc	48 8b 45 c0	 mov	 rax, QWORD PTR x$[rbp-120]
  001d0	48 ff c1	 inc	 rcx
  001d3	48 89 4d 28	 mov	 QWORD PTR i$[rbp-120], rcx
  001d7	48 3b 48 60	 cmp	 rcx, QWORD PTR [rax+96]
  001db	0f 8c 5f ff ff
	ff		 jl	 $LL24@unicode_ma
$LN22@unicode_ma:

; 12655:                 goto err;
; 12656:         }
; 12657:         /* create entries for deleting chars in z */
; 12658:         if (z != NULL) {

  001e1	48 8b 4d c8	 mov	 rcx, QWORD PTR z$[rbp-120]
  001e5	48 85 c9	 test	 rcx, rcx
  001e8	0f 84 b9 00 00
	00		 je	 $LN9@unicode_ma

; 12659:             z_kind = PyUnicode_KIND(z);

  001ee	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  001f1	8b d0		 mov	 edx, eax
  001f3	c1 ea 02	 shr	 edx, 2
  001f6	83 e2 07	 and	 edx, 7

; 12660:             z_data = PyUnicode_DATA(z);

  001f9	a8 20		 test	 al, 32			; 00000020H
  001fb	74 2e		 je	 SHORT $LN50@unicode_ma
  001fd	a8 40		 test	 al, 64			; 00000040H
  001ff	74 21		 je	 SHORT $LN48@unicode_ma
  00201	48 8d b1 80 00
	00 00		 lea	 rsi, QWORD PTR [rcx+128]
  00208	eb 28		 jmp	 SHORT $LN51@unicode_ma
$LN68@unicode_ma:

; 12648:                 Py_DECREF(key);

  0020a	48 8b 4d 30	 mov	 rcx, QWORD PTR key$[rbp-120]
  0020e	e8 00 00 00 00	 call	 _Py_DecRef

; 12712:   err:
; 12713:     Py_DECREF(new);

  00213	49 8b cf	 mov	 rcx, r15
  00216	e8 00 00 00 00	 call	 _Py_DecRef

; 12714:     return NULL;

  0021b	33 c0		 xor	 eax, eax
  0021d	e9 88 00 00 00	 jmp	 $LN84@unicode_ma
$LN48@unicode_ma:

; 12660:             z_data = PyUnicode_DATA(z);

  00222	48 8d b1 a0 00
	00 00		 lea	 rsi, QWORD PTR [rcx+160]
  00229	eb 07		 jmp	 SHORT $LN51@unicode_ma
$LN50@unicode_ma:
  0022b	48 8b b1 a0 00
	00 00		 mov	 rsi, QWORD PTR [rcx+160]
$LN51@unicode_ma:

; 12661:             for (i = 0; i < PyUnicode_GET_LENGTH(z); i++) {

  00232	48 89 7d 28	 mov	 QWORD PTR i$[rbp-120], rdi

; 12662:                 key = PyLong_FromLong(PyUnicode_READ(z_kind, z_data, i));

  00236	4c 63 e2	 movsxd	 r12, edx
  00239	48 39 79 60	 cmp	 QWORD PTR [rcx+96], rdi
  0023d	7e 68		 jle	 SHORT $LN9@unicode_ma
  0023f	90		 npad	 1
$LL17@unicode_ma:
  00240	49 83 fc 01	 cmp	 r12, 1
  00244	75 06		 jne	 SHORT $LN54@unicode_ma
  00246	0f b6 0c 3e	 movzx	 ecx, BYTE PTR [rsi+rdi]
  0024a	eb 0f		 jmp	 SHORT $LN53@unicode_ma
$LN54@unicode_ma:
  0024c	49 83 fc 02	 cmp	 r12, 2
  00250	75 06		 jne	 SHORT $LN52@unicode_ma
  00252	0f b7 0c 7e	 movzx	 ecx, WORD PTR [rsi+rdi*2]
  00256	eb 03		 jmp	 SHORT $LN53@unicode_ma
$LN52@unicode_ma:
  00258	8b 0c be	 mov	 ecx, DWORD PTR [rsi+rdi*4]
$LN53@unicode_ma:
  0025b	e8 00 00 00 00	 call	 PyLong_FromLong
  00260	48 89 45 30	 mov	 QWORD PTR key$[rbp-120], rax

; 12663:                 if (!key)

  00264	48 85 c0	 test	 rax, rax
  00267	0f 84 86 01 00
	00		 je	 $err$140904

; 12664:                     goto err;
; 12665:                 res = PyDict_SetItem(new, key, Py_None);

  0026d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  00274	48 8b d0	 mov	 rdx, rax
  00277	49 8b cf	 mov	 rcx, r15
  0027a	e8 00 00 00 00	 call	 PyDict_SetItem

; 12666:                 Py_DECREF(key);

  0027f	48 8b 4d 30	 mov	 rcx, QWORD PTR key$[rbp-120]
  00283	8b d8		 mov	 ebx, eax
  00285	e8 00 00 00 00	 call	 _Py_DecRef

; 12667:                 if (res < 0)

  0028a	85 db		 test	 ebx, ebx
  0028c	0f 88 61 01 00
	00		 js	 $err$140904

; 12661:             for (i = 0; i < PyUnicode_GET_LENGTH(z); i++) {

  00292	48 8b 7d 28	 mov	 rdi, QWORD PTR i$[rbp-120]
  00296	48 8b 45 c8	 mov	 rax, QWORD PTR z$[rbp-120]
  0029a	48 ff c7	 inc	 rdi
  0029d	48 89 7d 28	 mov	 QWORD PTR i$[rbp-120], rdi
  002a1	48 3b 78 60	 cmp	 rdi, QWORD PTR [rax+96]
  002a5	7c 99		 jl	 SHORT $LL17@unicode_ma
$LN9@unicode_ma:

; 12707:                 goto err;
; 12708:             }
; 12709:         }
; 12710:     }
; 12711:     return new;

  002a7	49 8b c7	 mov	 rax, r15
$LN84@unicode_ma:
  002aa	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  002af	4c 8b 6c 24 60	 mov	 r13, QWORD PTR [rsp+96]
  002b4	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  002b9	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  002be	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  002c6	4c 8b 7c 24 50	 mov	 r15, QWORD PTR [rsp+80]

; 12715: }

  002cb	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002cf	5f		 pop	 rdi
  002d0	5d		 pop	 rbp
  002d1	c3		 ret	 0
$LN27@unicode_ma:

; 12668:                     goto err;
; 12669:             }
; 12670:         }
; 12671:     } else {
; 12672:         int kind;
; 12673:         void *data;
; 12674: 
; 12675:         /* x must be a dict */
; 12676:         if (!PyDict_CheckExact(x)) {

  002d2	48 8b 4d c0	 mov	 rcx, QWORD PTR x$[rbp-120]
  002d6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  002dd	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  002e1	74 12		 je	 SHORT $LN66@unicode_ma
  002e3	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  002e7	74 0c		 je	 SHORT $LN66@unicode_ma

; 12677:             PyErr_SetString(PyExc_TypeError, "if you give only one argument "
; 12678:                             "to maketrans it must be a dict");

  002e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@JOACEDJG@if?5you?5give?5only?5one?5argument?5to@

; 12679:             goto err;

  002f0	e9 f2 00 00 00	 jmp	 $LN85@unicode_ma
$LN66@unicode_ma:

; 12680:         }
; 12681:         /* copy entries into the new dict, converting string keys to int keys */
; 12682:         while (PyDict_Next(x, &i, &key, &value)) {

  002f5	4c 8d 4d b8	 lea	 r9, QWORD PTR value$[rbp-120]
  002f9	4c 8d 45 30	 lea	 r8, QWORD PTR key$[rbp-120]
  002fd	48 8d 55 28	 lea	 rdx, QWORD PTR i$[rbp-120]
  00301	e8 00 00 00 00	 call	 PyDict_Next
  00306	85 c0		 test	 eax, eax
  00308	74 9d		 je	 SHORT $LN9@unicode_ma
  0030a	66 0f 1f 44 00
	00		 npad	 6
$LL10@unicode_ma:

; 12683:             if (PyUnicode_Check(key)) {

  00310	48 8b 55 30	 mov	 rdx, QWORD PTR key$[rbp-120]
  00314	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00318	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  0031e	0f ba e1 1c	 bt	 ecx, 28
  00322	73 74		 jae	 SHORT $LN8@unicode_ma

; 12684:                 /* convert string keys to integer keys */
; 12685:                 PyObject *newkey;
; 12686:                 if (PyUnicode_GET_LENGTH(key) != 1) {

  00324	48 83 7a 60 01	 cmp	 QWORD PTR [rdx+96], 1
  00329	0f 85 a1 00 00
	00		 jne	 $LN72@unicode_ma

; 12690:                 }
; 12691:                 kind = PyUnicode_KIND(key);

  0032f	8b 42 70	 mov	 eax, DWORD PTR [rdx+112]
  00332	8b c8		 mov	 ecx, eax
  00334	c1 e9 02	 shr	 ecx, 2
  00337	83 e1 07	 and	 ecx, 7

; 12692:                 data = PyUnicode_DATA(key);

  0033a	a8 20		 test	 al, 32			; 00000020H
  0033c	74 13		 je	 SHORT $LN58@unicode_ma
  0033e	a8 40		 test	 al, 64			; 00000040H
  00340	74 06		 je	 SHORT $LN56@unicode_ma
  00342	48 83 ea 80	 sub	 rdx, -128		; ffffffffffffff80H
  00346	eb 10		 jmp	 SHORT $LN59@unicode_ma
$LN56@unicode_ma:
  00348	48 81 c2 a0 00
	00 00		 add	 rdx, 160		; 000000a0H
  0034f	eb 07		 jmp	 SHORT $LN59@unicode_ma
$LN58@unicode_ma:
  00351	48 8b 92 a0 00
	00 00		 mov	 rdx, QWORD PTR [rdx+160]
$LN59@unicode_ma:

; 12693:                 newkey = PyLong_FromLong(PyUnicode_READ(kind, data, 0));

  00358	83 f9 01	 cmp	 ecx, 1
  0035b	75 05		 jne	 SHORT $LN62@unicode_ma
  0035d	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
  00360	eb 0c		 jmp	 SHORT $LN61@unicode_ma
$LN62@unicode_ma:
  00362	83 f9 02	 cmp	 ecx, 2
  00365	75 05		 jne	 SHORT $LN60@unicode_ma
  00367	0f b7 0a	 movzx	 ecx, WORD PTR [rdx]
  0036a	eb 02		 jmp	 SHORT $LN61@unicode_ma
$LN60@unicode_ma:
  0036c	8b 0a		 mov	 ecx, DWORD PTR [rdx]
$LN61@unicode_ma:
  0036e	e8 00 00 00 00	 call	 PyLong_FromLong
  00373	48 8b f8	 mov	 rdi, rax

; 12694:                 if (!newkey)

  00376	48 85 c0	 test	 rax, rax
  00379	74 78		 je	 SHORT $err$140904

; 12695:                     goto err;
; 12696:                 res = PyDict_SetItem(new, newkey, value);

  0037b	4c 8b 45 b8	 mov	 r8, QWORD PTR value$[rbp-120]
  0037f	48 8b d0	 mov	 rdx, rax
  00382	49 8b cf	 mov	 rcx, r15
  00385	e8 00 00 00 00	 call	 PyDict_SetItem

; 12697:                 Py_DECREF(newkey);

  0038a	48 8b cf	 mov	 rcx, rdi
  0038d	8b d8		 mov	 ebx, eax
  0038f	e8 00 00 00 00	 call	 _Py_DecRef

; 12698:                 if (res < 0)

  00394	85 db		 test	 ebx, ebx

; 12699:                     goto err;
; 12700:             } else if (PyLong_Check(key)) {

  00396	eb 14		 jmp	 SHORT $LN87@unicode_ma
$LN8@unicode_ma:
  00398	0f ba e1 18	 bt	 ecx, 24
  0039c	73 42		 jae	 SHORT $LN3@unicode_ma

; 12701:                 /* just keep integer keys */
; 12702:                 if (PyDict_SetItem(new, key, value) < 0)

  0039e	4c 8b 45 b8	 mov	 r8, QWORD PTR value$[rbp-120]
  003a2	49 8b cf	 mov	 rcx, r15
  003a5	e8 00 00 00 00	 call	 PyDict_SetItem
  003aa	85 c0		 test	 eax, eax
$LN87@unicode_ma:
  003ac	78 45		 js	 SHORT $err$140904

; 12680:         }
; 12681:         /* copy entries into the new dict, converting string keys to int keys */
; 12682:         while (PyDict_Next(x, &i, &key, &value)) {

  003ae	48 8b 4d c0	 mov	 rcx, QWORD PTR x$[rbp-120]
  003b2	4c 8d 4d b8	 lea	 r9, QWORD PTR value$[rbp-120]
  003b6	4c 8d 45 30	 lea	 r8, QWORD PTR key$[rbp-120]
  003ba	48 8d 55 28	 lea	 rdx, QWORD PTR i$[rbp-120]
  003be	e8 00 00 00 00	 call	 PyDict_Next
  003c3	85 c0		 test	 eax, eax
  003c5	0f 85 45 ff ff
	ff		 jne	 $LL10@unicode_ma
  003cb	e9 d7 fe ff ff	 jmp	 $LN9@unicode_ma
$LN72@unicode_ma:

; 12687:                     PyErr_SetString(PyExc_ValueError, "string keys in translate "
; 12688:                                     "table must be of length 1");

  003d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  003d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@CFDKOGOA@string?5keys?5in?5translate?5table?5m@

; 12689:                     goto err;

  003de	eb 0e		 jmp	 SHORT $LN86@unicode_ma
$LN3@unicode_ma:

; 12703:                     goto err;
; 12704:             } else {
; 12705:                 PyErr_SetString(PyExc_TypeError, "keys in translate table must "
; 12706:                                 "be strings or integers");

  003e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@BJAPICGP@keys?5in?5translate?5table?5must?5be?5@
$LN85@unicode_ma:
  003e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
$LN86@unicode_ma:
  003ee	e8 00 00 00 00	 call	 PyErr_SetString
$err$140904:

; 12712:   err:
; 12713:     Py_DECREF(new);

  003f3	49 8b cf	 mov	 rcx, r15
  003f6	e8 00 00 00 00	 call	 _Py_DecRef

; 12714:     return NULL;

  003fb	33 c0		 xor	 eax, eax
  003fd	e9 a8 fe ff ff	 jmp	 $LN84@unicode_ma
unicode_maketrans ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT unicode_translate
_TEXT	SEGMENT
self$ = 8
table$ = 16
unicode_translate PROC					; COMDAT

; 12729:     return _PyUnicode_TranslateCharmap(self, table, "ignore");

  00000	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06GDPEBLPA@ignore?$AA@

; 12730: }

  00007	e9 00 00 00 00	 jmp	 _PyUnicode_TranslateCharmap
unicode_translate ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_upper DD imagerel unicode_upper
	DD	imagerel unicode_upper+71
	DD	imagerel $unwind$unicode_upper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_upper DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_upper
_TEXT	SEGMENT
self$ = 48
unicode_upper PROC					; COMDAT

; 12739: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 12740:     if (PyUnicode_READY(self) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	75 12		 jne	 SHORT $LN2@unicode_up
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN2@unicode_up

; 12741:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 12745: }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
$LN2@unicode_up:

; 12742:     if (PyUnicode_IS_ASCII(self))

  00021	f6 43 70 40	 test	 BYTE PTR [rbx+112], 64	; 00000040H

; 12743:         return ascii_upper_or_lower(self, 0);

  00025	48 8b cb	 mov	 rcx, rbx
  00028	74 0c		 je	 SHORT $LN1@unicode_up
  0002a	33 d2		 xor	 edx, edx

; 12745: }

  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5b		 pop	 rbx
  00031	e9 00 00 00 00	 jmp	 ascii_upper_or_lower
$LN1@unicode_up:

; 12744:     return case_operation(self, do_upper);

  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:do_upper

; 12745: }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5b		 pop	 rbx
  00042	e9 00 00 00 00	 jmp	 case_operation
unicode_upper ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DL@GJELKLOF@startswith?5first?5arg?5must?5be?5str@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$unicode_startswith DD imagerel unicode_startswith
	DD	imagerel unicode_startswith+252
	DD	imagerel $unwind$unicode_startswith
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$unicode_startswith DD imagerel unicode_startswith+252
	DD	imagerel unicode_startswith+487
	DD	imagerel $chain$1$unicode_startswith
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$unicode_startswith DD imagerel unicode_startswith+487
	DD	imagerel unicode_startswith+678
	DD	imagerel $chain$3$unicode_startswith
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$unicode_startswith DD imagerel unicode_startswith+678
	DD	imagerel unicode_startswith+696
	DD	imagerel $chain$4$unicode_startswith
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$unicode_startswith DD 021H
	DD	imagerel unicode_startswith
	DD	imagerel unicode_startswith+252
	DD	imagerel $unwind$unicode_startswith
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$unicode_startswith DD 040021H
	DD	010f400H
	DD	019e400H
	DD	imagerel unicode_startswith
	DD	imagerel unicode_startswith+252
	DD	imagerel $unwind$unicode_startswith
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$unicode_startswith DD 041821H
	DD	010f418H
	DD	019e408H
	DD	imagerel unicode_startswith
	DD	imagerel unicode_startswith+252
	DD	imagerel $unwind$unicode_startswith
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_startswith DD 081901H
	DD	0110119H
	DD	0c00bd00dH
	DD	060087009H
	DD	050063007H
xdata	ENDS
;	COMDAT ??_C@_0DL@GJELKLOF@startswith?5first?5arg?5must?5be?5str@
CONST	SEGMENT
??_C@_0DL@GJELKLOF@startswith?5first?5arg?5must?5be?5str@ DB 'startswith '
	DB	'first arg must be str or a tuple of str, not %s', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT unicode_startswith
_TEXT	SEGMENT
tmp_start$154514 = 48
tmp_end$154515 = 56
tmp_subobj$154513 = 64
format$154518 = 72
self$ = 192
args$ = 200
obj_start$154516 = 208
obj_end$154517 = 216
unicode_startswith PROC					; COMDAT

; 12812: {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	53		 push	 rbx
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	48 8d 6c 24 d1	 lea	 rbp, QWORD PTR [rsp-47]
  00012	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00019	48 8b f1	 mov	 rsi, rcx

; 12813:     PyObject *subobj;
; 12814:     PyObject *substring;
; 12815:     Py_ssize_t start = 0;
; 12816:     Py_ssize_t end = PY_SSIZE_T_MAX;
; 12817:     int result;
; 12818: 
; 12819:     if (!stringlib_parse_args_finds("startswith", args, &subobj, &start, &end))

  0001c	48 83 c9 ff	 or	 rcx, -1
  00020	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0002a	48 89 45 df	 mov	 QWORD PTR tmp_end$154515[rbp-89], rax
  0002e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@
  00034	48 8b da	 mov	 rbx, rdx
  00037	89 45 ef	 mov	 DWORD PTR format$154518[rbp-89], eax
  0003a	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@+4
  00041	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NoneStruct
  00048	66 89 45 f3	 mov	 WORD PTR format$154518[rbp-85], ax
  0004c	33 c0		 xor	 eax, eax
  0004e	48 8d 7d ef	 lea	 rdi, QWORD PTR format$154518[rbp-89]
  00052	48 89 45 f5	 mov	 QWORD PTR format$154518[rbp-83], rax
  00056	48 89 45 fd	 mov	 QWORD PTR format$154518[rbp-75], rax
  0005a	48 89 45 05	 mov	 QWORD PTR format$154518[rbp-67], rax
  0005e	48 89 45 0d	 mov	 QWORD PTR format$154518[rbp-59], rax
  00062	48 89 45 15	 mov	 QWORD PTR format$154518[rbp-51], rax
  00066	89 45 1d	 mov	 DWORD PTR format$154518[rbp-43], eax
  00069	f2 ae		 repne scasb
  0006b	41 b8 31 00 00
	00		 mov	 r8d, 49			; 00000031H
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@MPOGHCCL@startswith?$AA@
  00078	48 f7 d1	 not	 rcx
  0007b	45 33 e4	 xor	 r12d, r12d
  0007e	4c 89 6d 77	 mov	 QWORD PTR obj_start$154516[rbp-89], r13
  00082	48 ff c9	 dec	 rcx
  00085	4c 89 65 d7	 mov	 QWORD PTR tmp_start$154514[rbp-89], r12
  00089	4c 89 6d 7f	 mov	 QWORD PTR obj_end$154517[rbp-89], r13
  0008d	4c 2b c1	 sub	 r8, rcx
  00090	48 8d 4c 0d ef	 lea	 rcx, QWORD PTR format$154518[rbp+rcx-89]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
  0009b	48 8d 45 7f	 lea	 rax, QWORD PTR obj_end$154517[rbp-89]
  0009f	4c 8d 4d 77	 lea	 r9, QWORD PTR obj_start$154516[rbp-89]
  000a3	4c 8d 45 e7	 lea	 r8, QWORD PTR tmp_subobj$154513[rbp-89]
  000a7	48 8d 55 ef	 lea	 rdx, QWORD PTR format$154518[rbp-89]
  000ab	48 8b cb	 mov	 rcx, rbx
  000ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b3	44 88 65 20	 mov	 BYTE PTR format$154518[rbp-40], r12b
  000b7	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000bc	85 c0		 test	 eax, eax
  000be	0f 84 e2 01 00
	00		 je	 $LN31@unicode_st
  000c4	48 8b 4d 77	 mov	 rcx, QWORD PTR obj_start$154516[rbp-89]
  000c8	49 3b cd	 cmp	 rcx, r13
  000cb	74 11		 je	 SHORT $LN14@unicode_st
  000cd	48 8d 55 d7	 lea	 rdx, QWORD PTR tmp_start$154514[rbp-89]
  000d1	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000d6	85 c0		 test	 eax, eax
  000d8	0f 84 c8 01 00
	00		 je	 $LN31@unicode_st
$LN14@unicode_st:
  000de	48 8b 4d 7f	 mov	 rcx, QWORD PTR obj_end$154517[rbp-89]
  000e2	49 3b cd	 cmp	 rcx, r13
  000e5	74 11		 je	 SHORT $LN12@unicode_st
  000e7	48 8d 55 df	 lea	 rdx, QWORD PTR tmp_end$154515[rbp-89]
  000eb	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000f0	85 c0		 test	 eax, eax
  000f2	0f 84 ae 01 00
	00		 je	 $LN31@unicode_st
$LN12@unicode_st:

; 12821:     if (PyTuple_Check(subobj)) {

  000f8	4c 8b 6d e7	 mov	 r13, QWORD PTR tmp_subobj$154513[rbp-89]
  000fc	4c 89 b4 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], r14
  00104	4c 8b 75 d7	 mov	 r14, QWORD PTR tmp_start$154514[rbp-89]
  00108	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  0010c	4c 89 bc 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r15
  00114	4c 8b 7d df	 mov	 r15, QWORD PTR tmp_end$154515[rbp-89]
  00118	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00122	0f 84 0d 01 00
	00		 je	 $LN8@unicode_st

; 12822:         Py_ssize_t i;
; 12823:         for (i = 0; i < PyTuple_GET_SIZE(subobj); i++) {

  00128	4d 39 65 60	 cmp	 QWORD PTR [r13+96], r12
  0012c	7e 4d		 jle	 SHORT $LN5@unicode_st
  0012e	49 8d 5d 70	 lea	 rbx, QWORD PTR [r13+112]
$LL7@unicode_st:

; 12824:             substring = PyUnicode_FromObject(PyTuple_GET_ITEM(subobj, i));

  00132	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00135	e8 00 00 00 00	 call	 PyUnicode_FromObject
  0013a	48 8b f0	 mov	 rsi, rax

; 12825:             if (substring == NULL)

  0013d	48 85 c0	 test	 rax, rax
  00140	0f 84 2a 01 00
	00		 je	 $LN1@unicode_st

; 12826:                 return NULL;
; 12827:             result = tailmatch(self, substring, start, end, -1);

  00146	48 8b 4d 67	 mov	 rcx, QWORD PTR self$[rbp-89]
  0014a	4d 8b cf	 mov	 r9, r15
  0014d	4d 8b c6	 mov	 r8, r14
  00150	48 8b d0	 mov	 rdx, rax
  00153	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  0015b	e8 00 00 00 00	 call	 tailmatch

; 12828:             Py_DECREF(substring);

  00160	48 8b ce	 mov	 rcx, rsi
  00163	8b f8		 mov	 edi, eax
  00165	e8 00 00 00 00	 call	 _Py_DecRef

; 12829:             if (result) {

  0016a	85 ff		 test	 edi, edi
  0016c	75 79		 jne	 SHORT $LN29@unicode_st

; 12822:         Py_ssize_t i;
; 12823:         for (i = 0; i < PyTuple_GET_SIZE(subobj); i++) {

  0016e	49 ff c4	 inc	 r12
  00171	48 83 c3 08	 add	 rbx, 8
  00175	4d 3b 65 60	 cmp	 r12, QWORD PTR [r13+96]
  00179	7c b7		 jl	 SHORT $LL7@unicode_st
$LN5@unicode_st:

; 12831:             }
; 12832:         }
; 12833:         /* nothing matched */
; 12834:         Py_RETURN_FALSE;

  0017b	e8 00 00 00 00	 call	 _Py_PXCTX
  00180	85 c0		 test	 eax, eax
  00182	75 3c		 jne	 SHORT $LN24@unicode_st
  00184	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  0018b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00192	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00199	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0019f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001a7	e8 00 00 00 00	 call	 _PyParallel_Guard
  001ac	85 c0		 test	 eax, eax
  001ae	75 09		 jne	 SHORT $LN23@unicode_st
  001b0	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  001b7	74 07		 je	 SHORT $LN24@unicode_st
$LN23@unicode_st:
  001b9	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN24@unicode_st:
  001c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
$LN33@unicode_st:
  001c7	4c 8b b4 24 c8
	00 00 00	 mov	 r14, QWORD PTR [rsp+200]
  001cf	4c 8b bc 24 80
	00 00 00	 mov	 r15, QWORD PTR [rsp+128]

; 12846: }

  001d7	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001de	41 5d		 pop	 r13
  001e0	41 5c		 pop	 r12
  001e2	5f		 pop	 rdi
  001e3	5e		 pop	 rsi
  001e4	5b		 pop	 rbx
  001e5	5d		 pop	 rbp
  001e6	c3		 ret	 0
$LN29@unicode_st:

; 12830:                 Py_RETURN_TRUE;

  001e7	e8 00 00 00 00	 call	 _Py_PXCTX
  001ec	85 c0		 test	 eax, eax
  001ee	75 3c		 jne	 SHORT $LN20@unicode_st
  001f0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_TrueStruct
  001f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00205	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0020b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00213	e8 00 00 00 00	 call	 _PyParallel_Guard
  00218	85 c0		 test	 eax, eax
  0021a	75 09		 jne	 SHORT $LN19@unicode_st
  0021c	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  00223	74 07		 je	 SHORT $LN20@unicode_st
$LN19@unicode_st:
  00225	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80
$LN20@unicode_st:
  0022c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00233	eb 92		 jmp	 SHORT $LN33@unicode_st
$LN8@unicode_st:

; 12835:     }
; 12836:     substring = PyUnicode_FromObject(subobj);

  00235	49 8b cd	 mov	 rcx, r13
  00238	e8 00 00 00 00	 call	 PyUnicode_FromObject
  0023d	48 8b d8	 mov	 rbx, rax

; 12837:     if (substring == NULL) {

  00240	48 85 c0	 test	 rax, rax
  00243	75 32		 jne	 SHORT $LN2@unicode_st

; 12838:         if (PyErr_ExceptionMatches(PyExc_TypeError))

  00245	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0024c	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00251	85 c0		 test	 eax, eax
  00253	74 1b		 je	 SHORT $LN1@unicode_st

; 12839:             PyErr_Format(PyExc_TypeError, "startswith first arg must be str or "
; 12840:                          "a tuple of str, not %s", Py_TYPE(subobj)->tp_name);

  00255	4d 8b 45 58	 mov	 r8, QWORD PTR [r13+88]
  00259	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00260	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@GJELKLOF@startswith?5first?5arg?5must?5be?5str@
  00267	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0026b	e8 00 00 00 00	 call	 PyErr_Format
$LN1@unicode_st:

; 12841:         return NULL;

  00270	33 c0		 xor	 eax, eax
  00272	e9 50 ff ff ff	 jmp	 $LN33@unicode_st
$LN2@unicode_st:

; 12842:     }
; 12843:     result = tailmatch(self, substring, start, end, -1);

  00277	4d 8b cf	 mov	 r9, r15
  0027a	4d 8b c6	 mov	 r8, r14
  0027d	48 8b d0	 mov	 rdx, rax
  00280	48 8b ce	 mov	 rcx, rsi
  00283	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  0028b	e8 00 00 00 00	 call	 tailmatch

; 12844:     Py_DECREF(substring);

  00290	48 8b cb	 mov	 rcx, rbx
  00293	8b f8		 mov	 edi, eax
  00295	e8 00 00 00 00	 call	 _Py_DecRef

; 12845:     return PyBool_FromLong(result);

  0029a	8b cf		 mov	 ecx, edi
  0029c	e8 00 00 00 00	 call	 PyBool_FromLong
  002a1	e9 21 ff ff ff	 jmp	 $LN33@unicode_st
$LN31@unicode_st:

; 12820:         return NULL;

  002a6	33 c0		 xor	 eax, eax

; 12846: }

  002a8	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002af	41 5d		 pop	 r13
  002b1	41 5c		 pop	 r12
  002b3	5f		 pop	 rdi
  002b4	5e		 pop	 rsi
  002b5	5b		 pop	 rbx
  002b6	5d		 pop	 rbp
  002b7	c3		 ret	 0
unicode_startswith ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DJ@POKCPGCJ@endswith?5first?5arg?5must?5be?5str?5o@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$unicode_endswith DD imagerel unicode_endswith
	DD	imagerel unicode_endswith+252
	DD	imagerel $unwind$unicode_endswith
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$unicode_endswith DD imagerel unicode_endswith+252
	DD	imagerel unicode_endswith+487
	DD	imagerel $chain$1$unicode_endswith
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$unicode_endswith DD imagerel unicode_endswith+487
	DD	imagerel unicode_endswith+678
	DD	imagerel $chain$3$unicode_endswith
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$unicode_endswith DD imagerel unicode_endswith+678
	DD	imagerel unicode_endswith+696
	DD	imagerel $chain$4$unicode_endswith
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$unicode_endswith DD 021H
	DD	imagerel unicode_endswith
	DD	imagerel unicode_endswith+252
	DD	imagerel $unwind$unicode_endswith
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$unicode_endswith DD 040021H
	DD	010f400H
	DD	019e400H
	DD	imagerel unicode_endswith
	DD	imagerel unicode_endswith+252
	DD	imagerel $unwind$unicode_endswith
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$unicode_endswith DD 041821H
	DD	010f418H
	DD	019e408H
	DD	imagerel unicode_endswith
	DD	imagerel unicode_endswith+252
	DD	imagerel $unwind$unicode_endswith
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_endswith DD 081901H
	DD	0110119H
	DD	0c00bd00dH
	DD	060087009H
	DD	050063007H
xdata	ENDS
;	COMDAT ??_C@_0DJ@POKCPGCJ@endswith?5first?5arg?5must?5be?5str?5o@
CONST	SEGMENT
??_C@_0DJ@POKCPGCJ@endswith?5first?5arg?5must?5be?5str?5o@ DB 'endswith f'
	DB	'irst arg must be str or a tuple of str, not %s', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT unicode_endswith
_TEXT	SEGMENT
tmp_start$154582 = 48
tmp_end$154583 = 56
tmp_subobj$154581 = 64
format$154586 = 72
self$ = 192
args$ = 200
obj_start$154584 = 208
obj_end$154585 = 216
unicode_endswith PROC					; COMDAT

; 12860: {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	53		 push	 rbx
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	48 8d 6c 24 d1	 lea	 rbp, QWORD PTR [rsp-47]
  00012	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00019	48 8b f1	 mov	 rsi, rcx

; 12861:     PyObject *subobj;
; 12862:     PyObject *substring;
; 12863:     Py_ssize_t start = 0;
; 12864:     Py_ssize_t end = PY_SSIZE_T_MAX;
; 12865:     int result;
; 12866: 
; 12867:     if (!stringlib_parse_args_finds("endswith", args, &subobj, &start, &end))

  0001c	48 83 c9 ff	 or	 rcx, -1
  00020	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0002a	48 89 45 df	 mov	 QWORD PTR tmp_end$154583[rbp-89], rax
  0002e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@
  00034	48 8b da	 mov	 rbx, rdx
  00037	89 45 ef	 mov	 DWORD PTR format$154586[rbp-89], eax
  0003a	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@+4
  00041	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NoneStruct
  00048	66 89 45 f3	 mov	 WORD PTR format$154586[rbp-85], ax
  0004c	33 c0		 xor	 eax, eax
  0004e	48 8d 7d ef	 lea	 rdi, QWORD PTR format$154586[rbp-89]
  00052	48 89 45 f5	 mov	 QWORD PTR format$154586[rbp-83], rax
  00056	48 89 45 fd	 mov	 QWORD PTR format$154586[rbp-75], rax
  0005a	48 89 45 05	 mov	 QWORD PTR format$154586[rbp-67], rax
  0005e	48 89 45 0d	 mov	 QWORD PTR format$154586[rbp-59], rax
  00062	48 89 45 15	 mov	 QWORD PTR format$154586[rbp-51], rax
  00066	89 45 1d	 mov	 DWORD PTR format$154586[rbp-43], eax
  00069	f2 ae		 repne scasb
  0006b	41 b8 31 00 00
	00		 mov	 r8d, 49			; 00000031H
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08MLCMCPNP@endswith?$AA@
  00078	48 f7 d1	 not	 rcx
  0007b	45 33 e4	 xor	 r12d, r12d
  0007e	4c 89 6d 77	 mov	 QWORD PTR obj_start$154584[rbp-89], r13
  00082	48 ff c9	 dec	 rcx
  00085	4c 89 65 d7	 mov	 QWORD PTR tmp_start$154582[rbp-89], r12
  00089	4c 89 6d 7f	 mov	 QWORD PTR obj_end$154585[rbp-89], r13
  0008d	4c 2b c1	 sub	 r8, rcx
  00090	48 8d 4c 0d ef	 lea	 rcx, QWORD PTR format$154586[rbp+rcx-89]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
  0009b	48 8d 45 7f	 lea	 rax, QWORD PTR obj_end$154585[rbp-89]
  0009f	4c 8d 4d 77	 lea	 r9, QWORD PTR obj_start$154584[rbp-89]
  000a3	4c 8d 45 e7	 lea	 r8, QWORD PTR tmp_subobj$154581[rbp-89]
  000a7	48 8d 55 ef	 lea	 rdx, QWORD PTR format$154586[rbp-89]
  000ab	48 8b cb	 mov	 rcx, rbx
  000ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b3	44 88 65 20	 mov	 BYTE PTR format$154586[rbp-40], r12b
  000b7	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000bc	85 c0		 test	 eax, eax
  000be	0f 84 e2 01 00
	00		 je	 $LN31@unicode_en@3
  000c4	48 8b 4d 77	 mov	 rcx, QWORD PTR obj_start$154584[rbp-89]
  000c8	49 3b cd	 cmp	 rcx, r13
  000cb	74 11		 je	 SHORT $LN14@unicode_en@3
  000cd	48 8d 55 d7	 lea	 rdx, QWORD PTR tmp_start$154582[rbp-89]
  000d1	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000d6	85 c0		 test	 eax, eax
  000d8	0f 84 c8 01 00
	00		 je	 $LN31@unicode_en@3
$LN14@unicode_en@3:
  000de	48 8b 4d 7f	 mov	 rcx, QWORD PTR obj_end$154585[rbp-89]
  000e2	49 3b cd	 cmp	 rcx, r13
  000e5	74 11		 je	 SHORT $LN12@unicode_en@3
  000e7	48 8d 55 df	 lea	 rdx, QWORD PTR tmp_end$154583[rbp-89]
  000eb	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000f0	85 c0		 test	 eax, eax
  000f2	0f 84 ae 01 00
	00		 je	 $LN31@unicode_en@3
$LN12@unicode_en@3:

; 12869:     if (PyTuple_Check(subobj)) {

  000f8	4c 8b 6d e7	 mov	 r13, QWORD PTR tmp_subobj$154581[rbp-89]
  000fc	4c 89 b4 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], r14
  00104	4c 8b 75 d7	 mov	 r14, QWORD PTR tmp_start$154582[rbp-89]
  00108	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  0010c	4c 89 bc 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r15
  00114	4c 8b 7d df	 mov	 r15, QWORD PTR tmp_end$154583[rbp-89]
  00118	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00122	0f 84 0d 01 00
	00		 je	 $LN8@unicode_en@3

; 12870:         Py_ssize_t i;
; 12871:         for (i = 0; i < PyTuple_GET_SIZE(subobj); i++) {

  00128	4d 39 65 60	 cmp	 QWORD PTR [r13+96], r12
  0012c	7e 4d		 jle	 SHORT $LN5@unicode_en@3
  0012e	49 8d 5d 70	 lea	 rbx, QWORD PTR [r13+112]
$LL7@unicode_en@3:

; 12872:             substring = PyUnicode_FromObject(
; 12873:                 PyTuple_GET_ITEM(subobj, i));

  00132	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00135	e8 00 00 00 00	 call	 PyUnicode_FromObject
  0013a	48 8b f0	 mov	 rsi, rax

; 12874:             if (substring == NULL)

  0013d	48 85 c0	 test	 rax, rax
  00140	0f 84 2a 01 00
	00		 je	 $LN1@unicode_en@3

; 12875:                 return NULL;
; 12876:             result = tailmatch(self, substring, start, end, +1);

  00146	48 8b 4d 67	 mov	 rcx, QWORD PTR self$[rbp-89]
  0014a	4d 8b cf	 mov	 r9, r15
  0014d	4d 8b c6	 mov	 r8, r14
  00150	48 8b d0	 mov	 rdx, rax
  00153	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0015b	e8 00 00 00 00	 call	 tailmatch

; 12877:             Py_DECREF(substring);

  00160	48 8b ce	 mov	 rcx, rsi
  00163	8b f8		 mov	 edi, eax
  00165	e8 00 00 00 00	 call	 _Py_DecRef

; 12878:             if (result) {

  0016a	85 ff		 test	 edi, edi
  0016c	75 79		 jne	 SHORT $LN29@unicode_en@3

; 12870:         Py_ssize_t i;
; 12871:         for (i = 0; i < PyTuple_GET_SIZE(subobj); i++) {

  0016e	49 ff c4	 inc	 r12
  00171	48 83 c3 08	 add	 rbx, 8
  00175	4d 3b 65 60	 cmp	 r12, QWORD PTR [r13+96]
  00179	7c b7		 jl	 SHORT $LL7@unicode_en@3
$LN5@unicode_en@3:

; 12880:             }
; 12881:         }
; 12882:         Py_RETURN_FALSE;

  0017b	e8 00 00 00 00	 call	 _Py_PXCTX
  00180	85 c0		 test	 eax, eax
  00182	75 3c		 jne	 SHORT $LN24@unicode_en@3
  00184	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  0018b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00192	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00199	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0019f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001a7	e8 00 00 00 00	 call	 _PyParallel_Guard
  001ac	85 c0		 test	 eax, eax
  001ae	75 09		 jne	 SHORT $LN23@unicode_en@3
  001b0	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  001b7	74 07		 je	 SHORT $LN24@unicode_en@3
$LN23@unicode_en@3:
  001b9	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN24@unicode_en@3:
  001c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
$LN33@unicode_en@3:
  001c7	4c 8b b4 24 c8
	00 00 00	 mov	 r14, QWORD PTR [rsp+200]
  001cf	4c 8b bc 24 80
	00 00 00	 mov	 r15, QWORD PTR [rsp+128]

; 12894: }

  001d7	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001de	41 5d		 pop	 r13
  001e0	41 5c		 pop	 r12
  001e2	5f		 pop	 rdi
  001e3	5e		 pop	 rsi
  001e4	5b		 pop	 rbx
  001e5	5d		 pop	 rbp
  001e6	c3		 ret	 0
$LN29@unicode_en@3:

; 12879:                 Py_RETURN_TRUE;

  001e7	e8 00 00 00 00	 call	 _Py_PXCTX
  001ec	85 c0		 test	 eax, eax
  001ee	75 3c		 jne	 SHORT $LN20@unicode_en@3
  001f0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_TrueStruct
  001f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00205	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0020b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00213	e8 00 00 00 00	 call	 _PyParallel_Guard
  00218	85 c0		 test	 eax, eax
  0021a	75 09		 jne	 SHORT $LN19@unicode_en@3
  0021c	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  00223	74 07		 je	 SHORT $LN20@unicode_en@3
$LN19@unicode_en@3:
  00225	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80
$LN20@unicode_en@3:
  0022c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00233	eb 92		 jmp	 SHORT $LN33@unicode_en@3
$LN8@unicode_en@3:

; 12883:     }
; 12884:     substring = PyUnicode_FromObject(subobj);

  00235	49 8b cd	 mov	 rcx, r13
  00238	e8 00 00 00 00	 call	 PyUnicode_FromObject
  0023d	48 8b d8	 mov	 rbx, rax

; 12885:     if (substring == NULL) {

  00240	48 85 c0	 test	 rax, rax
  00243	75 32		 jne	 SHORT $LN2@unicode_en@3

; 12886:         if (PyErr_ExceptionMatches(PyExc_TypeError))

  00245	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0024c	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00251	85 c0		 test	 eax, eax
  00253	74 1b		 je	 SHORT $LN1@unicode_en@3

; 12887:             PyErr_Format(PyExc_TypeError, "endswith first arg must be str or "
; 12888:                          "a tuple of str, not %s", Py_TYPE(subobj)->tp_name);

  00255	4d 8b 45 58	 mov	 r8, QWORD PTR [r13+88]
  00259	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00260	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DJ@POKCPGCJ@endswith?5first?5arg?5must?5be?5str?5o@
  00267	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0026b	e8 00 00 00 00	 call	 PyErr_Format
$LN1@unicode_en@3:

; 12889:         return NULL;

  00270	33 c0		 xor	 eax, eax
  00272	e9 50 ff ff ff	 jmp	 $LN33@unicode_en@3
$LN2@unicode_en@3:

; 12890:     }
; 12891:     result = tailmatch(self, substring, start, end, +1);

  00277	4d 8b cf	 mov	 r9, r15
  0027a	4d 8b c6	 mov	 r8, r14
  0027d	48 8b d0	 mov	 rdx, rax
  00280	48 8b ce	 mov	 rcx, rsi
  00283	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0028b	e8 00 00 00 00	 call	 tailmatch

; 12892:     Py_DECREF(substring);

  00290	48 8b cb	 mov	 rcx, rbx
  00293	8b f8		 mov	 edi, eax
  00295	e8 00 00 00 00	 call	 _Py_DecRef

; 12893:     return PyBool_FromLong(result);

  0029a	8b cf		 mov	 ecx, edi
  0029c	e8 00 00 00 00	 call	 PyBool_FromLong
  002a1	e9 21 ff ff ff	 jmp	 $LN33@unicode_en@3
$LN31@unicode_en@3:

; 12868:         return NULL;

  002a6	33 c0		 xor	 eax, eax

; 12894: }

  002a8	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002af	41 5d		 pop	 r13
  002b1	41 5c		 pop	 r12
  002b3	5f		 pop	 rdi
  002b4	5e		 pop	 rsi
  002b5	5b		 pop	 rbx
  002b6	5d		 pop	 rbp
  002b7	c3		 ret	 0
unicode_endswith ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _PyUnicodeWriter_Update
_TEXT	SEGMENT
writer$ = 8
_PyUnicodeWriter_Update PROC				; COMDAT

; 12899:     writer->size = PyUnicode_GET_LENGTH(writer->buffer);

  00000	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00003	48 8b 42 60	 mov	 rax, QWORD PTR [rdx+96]
  00007	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 12900:     writer->maxchar = PyUnicode_MAX_CHAR_VALUE(writer->buffer);

  0000b	44 8b 42 70	 mov	 r8d, DWORD PTR [rdx+112]
  0000f	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00013	74 07		 je	 SHORT $LN5@PyUnicodeW
  00015	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  0001a	eb 28		 jmp	 SHORT $LN4@PyUnicodeW
$LN5@PyUnicodeW:
  0001c	41 c1 e8 02	 shr	 r8d, 2
  00020	41 83 e0 07	 and	 r8d, 7
  00024	41 83 f8 01	 cmp	 r8d, 1
  00028	75 07		 jne	 SHORT $LN3@PyUnicodeW
  0002a	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0002f	eb 13		 jmp	 SHORT $LN4@PyUnicodeW
$LN3@PyUnicodeW:
  00031	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH
  00036	41 b9 ff ff 00
	00		 mov	 r9d, 65535		; 0000ffffH
  0003c	41 83 f8 02	 cmp	 r8d, 2
  00040	41 0f 44 c1	 cmove	 eax, r9d
$LN4@PyUnicodeW:
  00044	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 12901:     writer->data = PyUnicode_DATA(writer->buffer);

  00047	8b 42 70	 mov	 eax, DWORD PTR [rdx+112]
  0004a	a8 20		 test	 al, 32			; 00000020H
  0004c	74 34		 je	 SHORT $LN9@PyUnicodeW
  0004e	a8 40		 test	 al, 64			; 00000040H
  00050	74 18		 je	 SHORT $LN7@PyUnicodeW
  00052	48 8d 82 80 00
	00 00		 lea	 rax, QWORD PTR [rdx+128]
  00059	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 12902:     writer->kind = PyUnicode_KIND(writer->buffer);

  0005d	8b 42 70	 mov	 eax, DWORD PTR [rdx+112]
  00060	c1 e8 02	 shr	 eax, 2
  00063	83 e0 07	 and	 eax, 7
  00066	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 12903: }

  00069	c3		 ret	 0
$LN7@PyUnicodeW:

; 12901:     writer->data = PyUnicode_DATA(writer->buffer);

  0006a	48 8d 82 a0 00
	00 00		 lea	 rax, QWORD PTR [rdx+160]
  00071	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 12902:     writer->kind = PyUnicode_KIND(writer->buffer);

  00075	8b 42 70	 mov	 eax, DWORD PTR [rdx+112]
  00078	c1 e8 02	 shr	 eax, 2
  0007b	83 e0 07	 and	 eax, 7
  0007e	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 12903: }

  00081	c3		 ret	 0
$LN9@PyUnicodeW:

; 12901:     writer->data = PyUnicode_DATA(writer->buffer);

  00082	48 8b 82 a0 00
	00 00		 mov	 rax, QWORD PTR [rdx+160]
  00089	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 12902:     writer->kind = PyUnicode_KIND(writer->buffer);

  0008d	8b 42 70	 mov	 eax, DWORD PTR [rdx+112]
  00090	c1 e8 02	 shr	 eax, 2
  00093	83 e0 07	 and	 eax, 7
  00096	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 12903: }

  00099	c3		 ret	 0
_PyUnicodeWriter_Update ENDP
_TEXT	ENDS
PUBLIC	_PyUnicodeWriter_Init
; Function compile flags: /Ogtpy
;	COMDAT _PyUnicodeWriter_Init
_TEXT	SEGMENT
writer$ = 8
min_length$ = 16
_PyUnicodeWriter_Init PROC				; COMDAT

; 12908:     memset(writer, 0, sizeof(*writer));

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  0000d	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  00011	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
  00015	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 12909: #ifdef Py_DEBUG
; 12910:     writer->kind = 5;    /* invalid kind */
; 12911: #endif
; 12912:     writer->min_length = Py_MAX(min_length, 100);

  00019	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  0001e	48 3b d0	 cmp	 rdx, rax
  00021	48 0f 4f c2	 cmovg	 rax, rdx

; 12913:     writer->overallocate = (min_length > 0);

  00025	48 85 d2	 test	 rdx, rdx
  00028	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
  0002c	0f 9f c0	 setg	 al
  0002f	88 41 30	 mov	 BYTE PTR [rcx+48], al

; 12914: }

  00032	c3		 ret	 0
_PyUnicodeWriter_Init ENDP
_TEXT	ENDS
PUBLIC	_PyUnicodeWriter_PrepareInternal
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicodeWriter_PrepareInternal DD imagerel $LN24
	DD	imagerel $LN24+138
	DD	imagerel $unwind$_PyUnicodeWriter_PrepareInternal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyUnicodeWriter_PrepareInternal DD imagerel $LN24+138
	DD	imagerel $LN24+240
	DD	imagerel $chain$0$_PyUnicodeWriter_PrepareInternal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_PyUnicodeWriter_PrepareInternal DD imagerel $LN24+240
	DD	imagerel $LN24+377
	DD	imagerel $chain$2$_PyUnicodeWriter_PrepareInternal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_PyUnicodeWriter_PrepareInternal DD 020021H
	DD	087400H
	DD	imagerel $LN24
	DD	imagerel $LN24+138
	DD	imagerel $unwind$_PyUnicodeWriter_PrepareInternal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyUnicodeWriter_PrepareInternal DD 020521H
	DD	087405H
	DD	imagerel $LN24
	DD	imagerel $LN24+138
	DD	imagerel $unwind$_PyUnicodeWriter_PrepareInternal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicodeWriter_PrepareInternal DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicodeWriter_PrepareInternal
_TEXT	SEGMENT
writer$ = 64
length$ = 72
maxchar$ = 80
_PyUnicodeWriter_PrepareInternal PROC			; COMDAT

; 12919: {

$LN24:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 12920:     Py_ssize_t newlen;
; 12921:     PyObject *newbuffer;
; 12922: 
; 12923:     assert(length > 0);
; 12924: 
; 12925:     if (length > PY_SSIZE_T_MAX - writer->pos) {

  00009	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0000d	49 b9 ff ff ff
	ff ff ff ff 7f	 mov	 r9, 9223372036854775807	; 7fffffffffffffffH
  00017	49 8b c1	 mov	 rax, r9
  0001a	48 2b c1	 sub	 rax, rcx
  0001d	48 3b d0	 cmp	 rdx, rax
  00020	7e 0e		 jle	 SHORT $LN18@PyUnicodeW@2

; 12926:         PyErr_NoMemory();

  00022	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN23@PyUnicodeW@2:

; 12927:         return -1;

  00027	83 c8 ff	 or	 eax, -1

; 12985: }

  0002a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002e	5b		 pop	 rbx
  0002f	c3		 ret	 0
$LN18@PyUnicodeW@2:

; 12928:     }
; 12929:     newlen = writer->pos + length;
; 12930: 
; 12931:     if (writer->buffer == NULL) {

  00030	4c 8b 13	 mov	 r10, QWORD PTR [rbx]
  00033	48 03 ca	 add	 rcx, rdx
  00036	4d 85 d2	 test	 r10, r10
  00039	75 4b		 jne	 SHORT $LN17@PyUnicodeW@2

; 12932:         if (writer->overallocate) {

  0003b	44 38 53 30	 cmp	 BYTE PTR [rbx+48], r10b
  0003f	74 25		 je	 SHORT $LN14@PyUnicodeW@2

; 12933:             /* overallocate 25% to limit the number of resize */
; 12934:             if (newlen <= (PY_SSIZE_T_MAX - newlen / 4))

  00041	48 8b c1	 mov	 rax, rcx
  00044	48 99		 cdq
  00046	83 e2 03	 and	 edx, 3
  00049	48 03 c2	 add	 rax, rdx
  0004c	48 c1 f8 02	 sar	 rax, 2
  00050	4c 2b c8	 sub	 r9, rax
  00053	49 3b c9	 cmp	 rcx, r9
  00056	7f 03		 jg	 SHORT $LN15@PyUnicodeW@2

; 12935:                 newlen += newlen / 4;

  00058	48 03 c8	 add	 rcx, rax
$LN15@PyUnicodeW@2:

; 12936:             if (newlen < writer->min_length)

  0005b	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  0005f	48 3b c8	 cmp	 rcx, rax
  00062	48 0f 4c c8	 cmovl	 rcx, rax
$LN14@PyUnicodeW@2:

; 12937:                 newlen = writer->min_length;
; 12938:         }
; 12939:         writer->buffer = PyUnicode_New(newlen, maxchar);

  00066	41 8b d0	 mov	 edx, r8d
  00069	e8 00 00 00 00	 call	 PyUnicode_New
  0006e	48 89 03	 mov	 QWORD PTR [rbx], rax

; 12940:         if (writer->buffer == NULL)

  00071	48 85 c0	 test	 rax, rax

; 12941:             return -1;

  00074	74 b1		 je	 SHORT $LN23@PyUnicodeW@2

; 12942:         _PyUnicodeWriter_Update(writer);

  00076	48 8b cb	 mov	 rcx, rbx
  00079	e8 00 00 00 00	 call	 _PyUnicodeWriter_Update

; 12943:         return 0;

  0007e	33 c0		 xor	 eax, eax

; 12985: }

  00080	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00084	5b		 pop	 rbx
  00085	c3		 ret	 0
$LN17@PyUnicodeW@2:

; 12944:     }
; 12945: 
; 12946:     if (newlen > writer->size) {

  00086	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  0008a	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0008f	48 3b c8	 cmp	 rcx, rax
  00092	0f 8e 8f 00 00
	00		 jle	 $LN12@PyUnicodeW@2

; 12947:         if (writer->overallocate) {

  00098	80 7b 30 00	 cmp	 BYTE PTR [rbx+48], 0
  0009c	74 25		 je	 SHORT $LN9@PyUnicodeW@2

; 12948:             /* overallocate 25% to limit the number of resize */
; 12949:             if (newlen <= (PY_SSIZE_T_MAX - newlen / 4))

  0009e	48 8b c1	 mov	 rax, rcx
  000a1	48 99		 cdq
  000a3	83 e2 03	 and	 edx, 3
  000a6	48 03 c2	 add	 rax, rdx
  000a9	48 c1 f8 02	 sar	 rax, 2
  000ad	4c 2b c8	 sub	 r9, rax
  000b0	49 3b c9	 cmp	 rcx, r9
  000b3	7f 03		 jg	 SHORT $LN10@PyUnicodeW@2

; 12950:                 newlen += newlen / 4;

  000b5	48 03 c8	 add	 rcx, rax
$LN10@PyUnicodeW@2:

; 12951:             if (newlen < writer->min_length)

  000b8	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  000bc	48 3b c8	 cmp	 rcx, rax
  000bf	48 0f 4c c8	 cmovl	 rcx, rax
$LN9@PyUnicodeW@2:

; 12952:                 newlen = writer->min_length;
; 12953:         }
; 12954: 
; 12955:         if (maxchar > writer->maxchar || writer->readonly) {

  000c3	44 3b 43 14	 cmp	 r8d, DWORD PTR [rbx+20]
  000c7	77 27		 ja	 SHORT $LN7@PyUnicodeW@2
  000c9	80 7b 31 00	 cmp	 BYTE PTR [rbx+49], 0
  000cd	75 21		 jne	 SHORT $LN7@PyUnicodeW@2

; 12964:         }
; 12965:         else {
; 12966:             newbuffer = resize_compact(writer->buffer, newlen);

  000cf	48 8b d1	 mov	 rdx, rcx
  000d2	49 8b ca	 mov	 rcx, r10
  000d5	e8 00 00 00 00	 call	 resize_compact
  000da	48 8b f8	 mov	 rdi, rax

; 12967:             if (newbuffer == NULL)

  000dd	48 85 c0	 test	 rax, rax
  000e0	75 7f		 jne	 SHORT $LN4@PyUnicodeW@2
$LN22@PyUnicodeW@2:

; 12968:                 return -1;

  000e2	83 c8 ff	 or	 eax, -1
  000e5	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 12985: }

  000ea	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ee	5b		 pop	 rbx
  000ef	c3		 ret	 0
$LN7@PyUnicodeW@2:

; 12956:             /* resize + widen */
; 12957:             newbuffer = PyUnicode_New(newlen, maxchar);

  000f0	41 8b d0	 mov	 edx, r8d
  000f3	e8 00 00 00 00	 call	 PyUnicode_New
  000f8	48 8b f8	 mov	 rdi, rax

; 12958:             if (newbuffer == NULL)

  000fb	48 85 c0	 test	 rax, rax

; 12959:                 return -1;

  000fe	74 e2		 je	 SHORT $LN22@PyUnicodeW@2

; 12960:             _PyUnicode_FastCopyCharacters(newbuffer, 0,
; 12961:                                           writer->buffer, 0, writer->pos);

  00100	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00104	4c 8b 03	 mov	 r8, QWORD PTR [rbx]
  00107	45 33 c9	 xor	 r9d, r9d
  0010a	33 d2		 xor	 edx, edx
  0010c	48 8b cf	 mov	 rcx, rdi
  0010f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00114	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 12962:             Py_DECREF(writer->buffer);

  00119	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0011c	e8 00 00 00 00	 call	 _Py_DecRef

; 12963:             writer->readonly = 0;

  00121	c6 43 31 00	 mov	 BYTE PTR [rbx+49], 0

; 12969:         }
; 12970:         writer->buffer = newbuffer;
; 12971:         _PyUnicodeWriter_Update(writer);

  00125	eb 3a		 jmp	 SHORT $LN4@PyUnicodeW@2
$LN12@PyUnicodeW@2:

; 12972:     }
; 12973:     else if (maxchar > writer->maxchar) {

  00127	44 3b 43 14	 cmp	 r8d, DWORD PTR [rbx+20]
  0012b	76 3f		 jbe	 SHORT $LN2@PyUnicodeW@2

; 12974:         assert(!writer->readonly);
; 12975:         newbuffer = PyUnicode_New(writer->size, maxchar);

  0012d	41 8b d0	 mov	 edx, r8d
  00130	48 8b c8	 mov	 rcx, rax
  00133	e8 00 00 00 00	 call	 PyUnicode_New
  00138	48 8b f8	 mov	 rdi, rax

; 12976:         if (newbuffer == NULL)

  0013b	48 85 c0	 test	 rax, rax

; 12977:             return -1;

  0013e	74 a2		 je	 SHORT $LN22@PyUnicodeW@2

; 12978:         _PyUnicode_FastCopyCharacters(newbuffer, 0,
; 12979:                                       writer->buffer, 0, writer->pos);

  00140	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00144	4c 8b 03	 mov	 r8, QWORD PTR [rbx]
  00147	45 33 c9	 xor	 r9d, r9d
  0014a	33 d2		 xor	 edx, edx
  0014c	48 8b cf	 mov	 rcx, rdi
  0014f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00154	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 12980:         Py_DECREF(writer->buffer);

  00159	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0015c	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@PyUnicodeW@2:

; 12981:         writer->buffer = newbuffer;
; 12982:         _PyUnicodeWriter_Update(writer);

  00161	48 8b cb	 mov	 rcx, rbx
  00164	48 89 3b	 mov	 QWORD PTR [rbx], rdi
  00167	e8 00 00 00 00	 call	 _PyUnicodeWriter_Update
$LN2@PyUnicodeW@2:

; 12983:     }
; 12984:     return 0;

  0016c	33 c0		 xor	 eax, eax
  0016e	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 12985: }

  00173	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00177	5b		 pop	 rbx
  00178	c3		 ret	 0
_PyUnicodeWriter_PrepareInternal ENDP
_TEXT	ENDS
PUBLIC	_PyUnicodeWriter_WriteStr
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicodeWriter_WriteStr DD imagerel $LN18
	DD	imagerel $LN18+48
	DD	imagerel $unwind$_PyUnicodeWriter_WriteStr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyUnicodeWriter_WriteStr DD imagerel $LN18+48
	DD	imagerel $LN18+216
	DD	imagerel $chain$0$_PyUnicodeWriter_WriteStr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_PyUnicodeWriter_WriteStr DD imagerel $LN18+216
	DD	imagerel $LN18+261
	DD	imagerel $chain$2$_PyUnicodeWriter_WriteStr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_PyUnicodeWriter_WriteStr DD 020021H
	DD	086400H
	DD	imagerel $LN18
	DD	imagerel $LN18+48
	DD	imagerel $unwind$_PyUnicodeWriter_WriteStr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyUnicodeWriter_WriteStr DD 020521H
	DD	086405H
	DD	imagerel $LN18
	DD	imagerel $LN18+48
	DD	imagerel $unwind$_PyUnicodeWriter_WriteStr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicodeWriter_WriteStr DD 040a01H
	DD	09340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicodeWriter_WriteStr
_TEXT	SEGMENT
writer$ = 64
str$ = 72
_PyUnicodeWriter_WriteStr PROC				; COMDAT

; 12989: {

$LN18:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 12990:     Py_UCS4 maxchar;
; 12991:     Py_ssize_t len;
; 12992: 
; 12993:     if (PyUnicode_READY(str) == -1)

  0000a	f6 42 70 80	 test	 BYTE PTR [rdx+112], 128	; 00000080H
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	75 1a		 jne	 SHORT $LN6@PyUnicodeW@3
  00016	48 8b ca	 mov	 rcx, rdx
  00019	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0001e	83 f8 ff	 cmp	 eax, -1
  00021	75 0d		 jne	 SHORT $LN6@PyUnicodeW@3

; 12994:         return -1;

  00023	0b c0		 or	 eax, eax

; 13015:     return 0;
; 13016: }

  00025	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0002a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
$LN6@PyUnicodeW@3:
  00030	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi

; 12995:     len = PyUnicode_GET_LENGTH(str);

  00035	48 8b 77 60	 mov	 rsi, QWORD PTR [rdi+96]

; 12996:     if (len == 0)

  00039	48 85 f6	 test	 rsi, rsi

; 12997:         return 0;

  0003c	0f 84 b1 00 00
	00		 je	 $LN16@PyUnicodeW@3

; 12998:     maxchar = PyUnicode_MAX_CHAR_VALUE(str);

  00042	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00045	a8 40		 test	 al, 64			; 00000040H
  00047	74 08		 je	 SHORT $LN13@PyUnicodeW@3
  00049	41 b8 7f 00 00
	00		 mov	 r8d, 127		; 0000007fH
  0004f	eb 25		 jmp	 SHORT $LN12@PyUnicodeW@3
$LN13@PyUnicodeW@3:
  00051	c1 e8 02	 shr	 eax, 2
  00054	83 e0 07	 and	 eax, 7
  00057	83 f8 01	 cmp	 eax, 1
  0005a	75 08		 jne	 SHORT $LN11@PyUnicodeW@3
  0005c	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  00062	eb 12		 jmp	 SHORT $LN12@PyUnicodeW@3
$LN11@PyUnicodeW@3:
  00064	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00069	41 b8 ff ff 10
	00		 mov	 r8d, 1114111		; 0010ffffH
  0006f	83 f8 02	 cmp	 eax, 2
  00072	44 0f 44 c1	 cmove	 r8d, ecx
$LN12@PyUnicodeW@3:

; 12999:     if (maxchar > writer->maxchar || len > writer->size - writer->pos) {

  00076	44 3b 43 14	 cmp	 r8d, DWORD PTR [rbx+20]
  0007a	77 0d		 ja	 SHORT $LN3@PyUnicodeW@3
  0007c	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  00080	48 2b 43 20	 sub	 rax, QWORD PTR [rbx+32]
  00084	48 3b f0	 cmp	 rsi, rax
  00087	7e 4f		 jle	 SHORT $LN1@PyUnicodeW@3
$LN3@PyUnicodeW@3:

; 13000:         if (writer->buffer == NULL && !writer->overallocate) {

  00089	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  0008d	75 27		 jne	 SHORT $LN2@PyUnicodeW@3
  0008f	80 7b 30 00	 cmp	 BYTE PTR [rbx+48], 0
  00093	75 21		 jne	 SHORT $LN2@PyUnicodeW@3

; 13001:             Py_INCREF(str);

  00095	48 8b cf	 mov	 rcx, rdi
  00098	e8 00 00 00 00	 call	 _Py_IncRef

; 13002:             writer->buffer = str;
; 13003:             _PyUnicodeWriter_Update(writer);

  0009d	48 8b cb	 mov	 rcx, rbx
  000a0	48 89 3b	 mov	 QWORD PTR [rbx], rdi
  000a3	e8 00 00 00 00	 call	 _PyUnicodeWriter_Update

; 13004:             writer->readonly = 1;

  000a8	c6 43 31 01	 mov	 BYTE PTR [rbx+49], 1

; 13005:             writer->size = 0;

  000ac	48 c7 43 18 00
	00 00 00	 mov	 QWORD PTR [rbx+24], 0

; 13006:             writer->pos += len;
; 13007:             return 0;

  000b4	eb 39		 jmp	 SHORT $LN17@PyUnicodeW@3
$LN2@PyUnicodeW@3:

; 13008:         }
; 13009:         if (_PyUnicodeWriter_PrepareInternal(writer, len, maxchar) == -1)

  000b6	48 8b d6	 mov	 rdx, rsi
  000b9	48 8b cb	 mov	 rcx, rbx
  000bc	e8 00 00 00 00	 call	 _PyUnicodeWriter_PrepareInternal
  000c1	83 f8 ff	 cmp	 eax, -1
  000c4	75 12		 jne	 SHORT $LN1@PyUnicodeW@3

; 13010:             return -1;

  000c6	0b c0		 or	 eax, eax
  000c8	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 13015:     return 0;
; 13016: }

  000cd	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000d2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d6	5f		 pop	 rdi
  000d7	c3		 ret	 0
$LN1@PyUnicodeW@3:

; 13011:     }
; 13012:     _PyUnicode_FastCopyCharacters(writer->buffer, writer->pos,
; 13013:                                   str, 0, len);

  000d8	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  000dc	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000df	45 33 c9	 xor	 r9d, r9d
  000e2	4c 8b c7	 mov	 r8, rdi
  000e5	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  000ea	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters
$LN17@PyUnicodeW@3:

; 13014:     writer->pos += len;

  000ef	48 01 73 20	 add	 QWORD PTR [rbx+32], rsi
$LN16@PyUnicodeW@3:
  000f3	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 13015:     return 0;
; 13016: }

  000f8	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000fd	33 c0		 xor	 eax, eax
  000ff	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00103	5f		 pop	 rdi
  00104	c3		 ret	 0
_PyUnicodeWriter_WriteStr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@FPHLCIAM@_PyUnicodeWriter_Dealloc?$AA@ ; `string'
PUBLIC	_PyUnicodeWriter_Dealloc
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_PyUnicodeWriter_Dealloc DD imagerel $LN19
	DD	imagerel $LN19+62
	DD	imagerel $unwind$_PyUnicodeWriter_Dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyUnicodeWriter_Dealloc DD imagerel $LN19+62
	DD	imagerel $LN19+166
	DD	imagerel $chain$0$_PyUnicodeWriter_Dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_PyUnicodeWriter_Dealloc DD imagerel $LN19+166
	DD	imagerel $LN19+187
	DD	imagerel $chain$2$_PyUnicodeWriter_Dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_PyUnicodeWriter_Dealloc DD imagerel $LN19+187
	DD	imagerel $LN19+200
	DD	imagerel $chain$4$_PyUnicodeWriter_Dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$_PyUnicodeWriter_Dealloc DD imagerel $LN19+200
	DD	imagerel $LN19+206
	DD	imagerel $chain$5$_PyUnicodeWriter_Dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$_PyUnicodeWriter_Dealloc DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+62
	DD	imagerel $unwind$_PyUnicodeWriter_Dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_PyUnicodeWriter_Dealloc DD 020021H
	DD	083400H
	DD	imagerel $LN19
	DD	imagerel $LN19+62
	DD	imagerel $unwind$_PyUnicodeWriter_Dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_PyUnicodeWriter_Dealloc DD 020021H
	DD	083400H
	DD	imagerel $LN19
	DD	imagerel $LN19+62
	DD	imagerel $unwind$_PyUnicodeWriter_Dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyUnicodeWriter_Dealloc DD 020521H
	DD	083405H
	DD	imagerel $LN19
	DD	imagerel $LN19+62
	DD	imagerel $unwind$_PyUnicodeWriter_Dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicodeWriter_Dealloc DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_0BJ@FPHLCIAM@_PyUnicodeWriter_Dealloc?$AA@
CONST	SEGMENT
??_C@_0BJ@FPHLCIAM@_PyUnicodeWriter_Dealloc?$AA@ DB '_PyUnicodeWriter_Dea'
	DB	'lloc', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT _PyUnicodeWriter_Dealloc
_TEXT	SEGMENT
writer$ = 64
_PyUnicodeWriter_Dealloc PROC				; COMDAT

; 13044: {

$LN19:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 13045:     Py_CLEAR(writer->buffer);

  00006	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00009	48 8b f9	 mov	 rdi, rcx
  0000c	4d 85 c9	 test	 r9, r9
  0000f	0f 84 b3 00 00
	00		 je	 $LN3@PyUnicodeW@4
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@FPHLCIAM@_PyUnicodeWriter_Dealloc?$AA@
  00023	41 b8 f5 32 00
	00		 mov	 r8d, 13045		; 000032f5H
  00029	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	0f 85 8a 00 00
	00		 jne	 $LN3@PyUnicodeW@4
  0003e	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00043	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00046	48 c7 07 00 00
	00 00		 mov	 QWORD PTR [rdi], 0
  0004d	e8 00 00 00 00	 call	 _Py_PXCTX
  00052	85 c0		 test	 eax, eax
  00054	75 6d		 jne	 SHORT $LN18@PyUnicodeW@4
  00056	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0005a	a8 20		 test	 al, 32			; 00000020H
  0005c	75 5d		 jne	 SHORT $LN11@PyUnicodeW@4
  0005e	84 c0		 test	 al, al
  00060	78 59		 js	 SHORT $LN11@PyUnicodeW@4
  00062	a8 02		 test	 al, 2
  00064	75 5d		 jne	 SHORT $LN18@PyUnicodeW@4
  00066	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0006a	75 57		 jne	 SHORT $LN18@PyUnicodeW@4
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0007a	4c 8b cb	 mov	 r9, rbx
  0007d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00083	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0008b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00090	48 8b cb	 mov	 rcx, rbx
  00093	85 c0		 test	 eax, eax
  00095	74 0f		 je	 SHORT $LN16@PyUnicodeW@4
  00097	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 13046: }

  0009c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a0	5f		 pop	 rdi
  000a1	e9 00 00 00 00	 jmp	 _Px_Dealloc

; 13045:     Py_CLEAR(writer->buffer);

$LN16@PyUnicodeW@4:
  000a6	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000aa	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 13046: }

  000af	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b3	5f		 pop	 rdi
  000b4	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]

; 13045:     Py_CLEAR(writer->buffer);

$LN11@PyUnicodeW@4:
  000bb	48 8b cb	 mov	 rcx, rbx
  000be	e8 00 00 00 00	 call	 Px_DecRef
$LN18@PyUnicodeW@4:
  000c3	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN3@PyUnicodeW@4:

; 13046: }

  000c8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cc	5f		 pop	 rdi
  000cd	c3		 ret	 0
_PyUnicodeWriter_Dealloc ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\unicode_format.h
_TEXT	ENDS
;	COMDAT AutoNumber_Init
_TEXT	SEGMENT
auto_number$ = 8
AutoNumber_Init PROC					; COMDAT

; 46   :     auto_number->an_state = ANS_INIT;

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 47   :     auto_number->an_field_number = 0;
; 48   : }

  00005	c3		 ret	 0
AutoNumber_Init ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT SubString_init
_TEXT	SEGMENT
str$ = 8
s$ = 16
start$ = 24
end$ = 32
SubString_init PROC					; COMDAT

; 54   :     str->str = s;

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 55   :     str->start = start;

  00003	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 56   :     str->end = end;

  00007	4c 89 49 10	 mov	 QWORD PTR [rcx+16], r9

; 57   : }

  0000b	c3		 ret	 0
SubString_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EL@GLOCAILF@cannot?5switch?5from?5automatic?5fie@ ; `string'
PUBLIC	??_C@_0EL@IAPGHBBB@cannot?5switch?5from?5manual?5field?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$autonumber_state_error DD imagerel autonumber_state_error
	DD	imagerel autonumber_state_error+62
	DD	imagerel $unwind$autonumber_state_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$autonumber_state_error DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0EL@GLOCAILF@cannot?5switch?5from?5automatic?5fie@
CONST	SEGMENT
??_C@_0EL@GLOCAILF@cannot?5switch?5from?5automatic?5fie@ DB 'cannot switc'
	DB	'h from automatic field numbering to manual field specificatio'
	DB	'n', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@IAPGHBBB@cannot?5switch?5from?5manual?5field?5@
CONST	SEGMENT
??_C@_0EL@IAPGHBBB@cannot?5switch?5from?5manual?5field?5@ DB 'cannot swit'
	DB	'ch from manual field specification to automatic field numberi'
	DB	'ng', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT autonumber_state_error
_TEXT	SEGMENT
state$ = 48
field_name_is_empty$ = 56
autonumber_state_error PROC				; COMDAT

; 85   : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 86   :     if (state == ANS_MANUAL) {

  00004	83 f9 02	 cmp	 ecx, 2
  00007	75 21		 jne	 SHORT $LN4@autonumber

; 87   :         if (field_name_is_empty) {

  00009	85 d2		 test	 edx, edx
  0000b	74 2a		 je	 SHORT $LN1@autonumber

; 88   :             PyErr_SetString(PyExc_ValueError, "cannot switch from "
; 89   :                             "manual field specification to "
; 90   :                             "automatic field numbering");

  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EL@IAPGHBBB@cannot?5switch?5from?5manual?5field?5@
$LN7@autonumber:
  00014	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0001b	e8 00 00 00 00	 call	 PyErr_SetString

; 91   :             return 1;

  00020	b8 01 00 00 00	 mov	 eax, 1

; 103  : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
$LN4@autonumber:

; 92   :         }
; 93   :     }
; 94   :     else {
; 95   :         if (!field_name_is_empty) {

  0002a	85 d2		 test	 edx, edx
  0002c	75 09		 jne	 SHORT $LN1@autonumber

; 96   :             PyErr_SetString(PyExc_ValueError, "cannot switch from "
; 97   :                             "automatic field numbering to "
; 98   :                             "manual field specification");

  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EL@GLOCAILF@cannot?5switch?5from?5automatic?5fie@

; 99   :             return 1;

  00035	eb dd		 jmp	 SHORT $LN7@autonumber
$LN1@autonumber:

; 100  :         }
; 101  :     }
; 102  :     return 0;

  00037	33 c0		 xor	 eax, eax

; 103  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
autonumber_state_error ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@BALCLOM@Too?5many?5decimal?5digits?5in?5forma@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_integer DD imagerel get_integer
	DD	imagerel get_integer+346
	DD	imagerel $unwind$get_integer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_integer DD 0a3c01H
	DD	07c43cH
	DD	065437H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CJ@BALCLOM@Too?5many?5decimal?5digits?5in?5forma@
CONST	SEGMENT
??_C@_0CJ@BALCLOM@Too?5many?5decimal?5digits?5in?5forma@ DB 'Too many dec'
	DB	'imal digits in format string', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT get_integer
_TEXT	SEGMENT
str$ = 48
get_integer PROC					; COMDAT

; 112  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 113  :     Py_ssize_t accumulator = 0;
; 114  :     Py_ssize_t digitval;
; 115  :     Py_ssize_t i;
; 116  : 
; 117  :     /* empty string is an error */
; 118  :     if (str->start >= str->end)

  0000f	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  00013	33 ff		 xor	 edi, edi
  00015	48 8b f1	 mov	 rsi, rcx
  00018	48 3b 59 10	 cmp	 rbx, QWORD PTR [rcx+16]
  0001c	7c 14		 jl	 SHORT $LN6@get_intege

; 119  :         return -1;

  0001e	48 83 c8 ff	 or	 rax, -1

; 139  : }

  00022	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00027	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN6@get_intege:
  00032	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00037	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12

; 120  : 
; 121  :     for (i = str->start; i < str->end; i++) {

  0003c	49 bc 67 66 66
	66 66 66 66 66	 mov	 r12, 7378697629483820647 ; 6666666666666667H
  00046	48 bd ff ff ff
	ff ff ff ff 7f	 mov	 rbp, 9223372036854775807 ; 7fffffffffffffffH
$LL5@get_intege:

; 122  :         digitval = Py_UNICODE_TODECIMAL(PyUnicode_READ_CHAR(str->str, i));

  00050	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00053	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  00056	8b d1		 mov	 edx, ecx
  00058	c1 ea 02	 shr	 edx, 2
  0005b	83 e2 07	 and	 edx, 7
  0005e	83 fa 01	 cmp	 edx, 1
  00061	75 2d		 jne	 SHORT $LN23@get_intege
  00063	f6 c1 20	 test	 cl, 32			; 00000020H
  00066	74 1b		 je	 SHORT $LN11@get_intege
  00068	f6 c1 40	 test	 cl, 64			; 00000040H
  0006b	74 0a		 je	 SHORT $LN9@get_intege
  0006d	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  00071	0f b6 0c 18	 movzx	 ecx, BYTE PTR [rax+rbx]
  00075	eb 6d		 jmp	 SHORT $LN22@get_intege
$LN9@get_intege:
  00077	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  0007d	0f b6 0c 18	 movzx	 ecx, BYTE PTR [rax+rbx]
  00081	eb 61		 jmp	 SHORT $LN22@get_intege
$LN11@get_intege:
  00083	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0008a	0f b6 0c 18	 movzx	 ecx, BYTE PTR [rax+rbx]
  0008e	eb 54		 jmp	 SHORT $LN22@get_intege
$LN23@get_intege:
  00090	83 fa 02	 cmp	 edx, 2
  00093	75 2d		 jne	 SHORT $LN21@get_intege
  00095	f6 c1 20	 test	 cl, 32			; 00000020H
  00098	74 1b		 je	 SHORT $LN15@get_intege
  0009a	f6 c1 40	 test	 cl, 64			; 00000040H
  0009d	74 0a		 je	 SHORT $LN13@get_intege
  0009f	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  000a3	0f b7 0c 58	 movzx	 ecx, WORD PTR [rax+rbx*2]
  000a7	eb 3b		 jmp	 SHORT $LN22@get_intege
$LN13@get_intege:
  000a9	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  000af	0f b7 0c 58	 movzx	 ecx, WORD PTR [rax+rbx*2]
  000b3	eb 2f		 jmp	 SHORT $LN22@get_intege
$LN15@get_intege:
  000b5	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  000bc	0f b7 0c 58	 movzx	 ecx, WORD PTR [rax+rbx*2]
  000c0	eb 22		 jmp	 SHORT $LN22@get_intege
$LN21@get_intege:
  000c2	f6 c1 20	 test	 cl, 32			; 00000020H
  000c5	74 13		 je	 SHORT $LN19@get_intege
  000c7	f6 c1 40	 test	 cl, 64			; 00000040H
  000ca	74 06		 je	 SHORT $LN17@get_intege
  000cc	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  000d0	eb 0f		 jmp	 SHORT $LN20@get_intege
$LN17@get_intege:
  000d2	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  000d8	eb 07		 jmp	 SHORT $LN20@get_intege
$LN19@get_intege:
  000da	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
$LN20@get_intege:
  000e1	8b 0c 98	 mov	 ecx, DWORD PTR [rax+rbx*4]
$LN22@get_intege:
  000e4	e8 00 00 00 00	 call	 _PyUnicode_ToDecimalDigit
  000e9	4c 63 c0	 movsxd	 r8, eax

; 123  :         if (digitval < 0)

  000ec	85 c0		 test	 eax, eax
  000ee	78 4c		 js	 SHORT $LN26@get_intege

; 125  :         /*
; 126  :            Detect possible overflow before it happens:
; 127  : 
; 128  :               accumulator * 10 + digitval > PY_SSIZE_T_MAX if and only if
; 129  :               accumulator > (PY_SSIZE_T_MAX - digitval) / 10.
; 130  :         */
; 131  :         if (accumulator > (PY_SSIZE_T_MAX - digitval) / 10) {

  000f0	48 8b cd	 mov	 rcx, rbp
  000f3	49 8b c4	 mov	 rax, r12
  000f6	49 2b c8	 sub	 rcx, r8
  000f9	48 f7 e9	 imul	 rcx
  000fc	48 c1 fa 02	 sar	 rdx, 2
  00100	48 8b ca	 mov	 rcx, rdx
  00103	48 c1 e9 3f	 shr	 rcx, 63			; 0000003fH
  00107	48 03 d1	 add	 rdx, rcx
  0010a	48 3b fa	 cmp	 rdi, rdx
  0010d	7f 1a		 jg	 SHORT $LN27@get_intege

; 134  :             return -1;
; 135  :         }
; 136  :         accumulator = accumulator * 10 + digitval;

  0010f	48 8d 0c bf	 lea	 rcx, QWORD PTR [rdi+rdi*4]
  00113	48 ff c3	 inc	 rbx
  00116	49 8d 3c 48	 lea	 rdi, QWORD PTR [r8+rcx*2]
  0011a	48 3b 5e 10	 cmp	 rbx, QWORD PTR [rsi+16]
  0011e	0f 8c 2c ff ff
	ff		 jl	 $LL5@get_intege

; 137  :     }
; 138  :     return accumulator;

  00124	48 8b c7	 mov	 rax, rdi
  00127	eb 17		 jmp	 SHORT $LN30@get_intege
$LN27@get_intege:

; 132  :             PyErr_Format(PyExc_ValueError,
; 133  :                          "Too many decimal digits in format string");

  00129	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00130	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@BALCLOM@Too?5many?5decimal?5digits?5in?5forma@
  00137	e8 00 00 00 00	 call	 PyErr_Format
$LN26@get_intege:

; 124  :             return -1;

  0013c	48 83 c8 ff	 or	 rax, -1
$LN30@get_intege:
  00140	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  00145	4c 8b 64 24 38	 mov	 r12, QWORD PTR [rsp+56]

; 139  : }

  0014a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0014f	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00154	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00158	5f		 pop	 rdi
  00159	c3		 ret	 0
get_integer ENDP
_TEXT	ENDS
EXTRN	PySequence_GetItem:PROC
; Function compile flags: /Ogtpy
;	COMDAT getitem_sequence
_TEXT	SEGMENT
obj$ = 8
idx$ = 16
getitem_sequence PROC					; COMDAT

; 162  :     return PySequence_GetItem(obj, idx);
; 163  : }

  00000	e9 00 00 00 00	 jmp	 PySequence_GetItem
getitem_sequence ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$getitem_idx DD imagerel getitem_idx
	DD	imagerel getitem_idx+76
	DD	imagerel $unwind$getitem_idx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getitem_idx DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT getitem_idx
_TEXT	SEGMENT
obj$ = 48
idx$ = 56
getitem_idx PROC					; COMDAT

; 168  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 169  :     PyObject *newobj;
; 170  :     PyObject *idx_obj = PyLong_FromSsize_t(idx);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00015	48 8b f8	 mov	 rdi, rax

; 171  :     if (idx_obj == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0b		 jne	 SHORT $LN1@getitem_id

; 176  : }

  0001d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN1@getitem_id:

; 172  :         return NULL;
; 173  :     newobj = PyObject_GetItem(obj, idx_obj);

  00028	48 8b d0	 mov	 rdx, rax
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	e8 00 00 00 00	 call	 PyObject_GetItem

; 174  :     Py_DECREF(idx_obj);

  00033	48 8b cf	 mov	 rcx, rdi
  00036	48 8b d8	 mov	 rbx, rax
  00039	e8 00 00 00 00	 call	 _Py_DecRef

; 175  :     return newobj;

  0003e	48 8b c3	 mov	 rax, rbx

; 176  : }

  00041	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
getitem_idx ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT FieldNameIterator_init
_TEXT	SEGMENT
self$ = 8
s$ = 16
start$ = 24
end$ = 32
FieldNameIterator_init PROC				; COMDAT

; 206  :     SubString_init(&self->str, s, start, end);

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00003	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8
  00007	4c 89 49 10	 mov	 QWORD PTR [rcx+16], r9

; 207  :     self->index = start;

  0000b	4c 89 41 18	 mov	 QWORD PTR [rcx+24], r8

; 208  :     return 1;

  0000f	b8 01 00 00 00	 mov	 eax, 1

; 209  : }

  00014	c3		 ret	 0
FieldNameIterator_init ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _FieldNameIterator_attr
_TEXT	SEGMENT
self$ = 8
name$ = 16
_FieldNameIterator_attr PROC				; COMDAT

; 214  :     Py_UCS4 c;
; 215  : 
; 216  :     name->str = self->str.str;

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	4c 8b d2	 mov	 r10, rdx
  00006	4c 8b c9	 mov	 r9, rcx
  00009	48 89 02	 mov	 QWORD PTR [rdx], rax

; 217  :     name->start = self->index;

  0000c	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00010	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 218  : 
; 219  :     /* return everything until '.' or '[' */
; 220  :     while (self->index < self->str.end) {

  00014	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00018	48 39 41 18	 cmp	 QWORD PTR [rcx+24], rax
  0001c	0f 8d f9 00 00
	00		 jge	 $LN3@FieldNameI
  00022	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00025	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL6@FieldNameI:

; 221  :         c = PyUnicode_READ_CHAR(self->str.str, self->index++);

  00030	41 8b 40 70	 mov	 eax, DWORD PTR [r8+112]
  00034	8b c8		 mov	 ecx, eax
  00036	c1 e9 02	 shr	 ecx, 2
  00039	83 e1 07	 and	 ecx, 7
  0003c	83 f9 01	 cmp	 ecx, 1
  0003f	75 3e		 jne	 SHORT $LN23@FieldNameI
  00041	a8 20		 test	 al, 32			; 00000020H
  00043	74 29		 je	 SHORT $LN11@FieldNameI
  00045	a8 40		 test	 al, 64			; 00000040H
  00047	74 14		 je	 SHORT $LN9@FieldNameI
  00049	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  0004d	49 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [r8+128]
  00054	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00058	e9 8a 00 00 00	 jmp	 $LN26@FieldNameI
$LN9@FieldNameI:
  0005d	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  00061	49 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [r8+160]
  00068	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0006c	eb 79		 jmp	 SHORT $LN26@FieldNameI
$LN11@FieldNameI:
  0006e	49 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [r8+160]
  00075	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  00079	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0007d	eb 68		 jmp	 SHORT $LN26@FieldNameI
$LN23@FieldNameI:
  0007f	83 f9 02	 cmp	 ecx, 2
  00082	75 3b		 jne	 SHORT $LN21@FieldNameI
  00084	a8 20		 test	 al, 32			; 00000020H
  00086	74 26		 je	 SHORT $LN15@FieldNameI
  00088	a8 40		 test	 al, 64			; 00000040H
  0008a	74 11		 je	 SHORT $LN13@FieldNameI
  0008c	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  00090	49 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [r8+128]
  00097	0f b7 14 41	 movzx	 edx, WORD PTR [rcx+rax*2]
  0009b	eb 4a		 jmp	 SHORT $LN26@FieldNameI
$LN13@FieldNameI:
  0009d	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  000a1	49 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [r8+160]
  000a8	0f b7 14 41	 movzx	 edx, WORD PTR [rcx+rax*2]
  000ac	eb 39		 jmp	 SHORT $LN26@FieldNameI
$LN15@FieldNameI:
  000ae	49 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [r8+160]
  000b5	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  000b9	0f b7 14 41	 movzx	 edx, WORD PTR [rcx+rax*2]
  000bd	eb 28		 jmp	 SHORT $LN26@FieldNameI
$LN21@FieldNameI:
  000bf	a8 20		 test	 al, 32			; 00000020H
  000c1	74 16		 je	 SHORT $LN19@FieldNameI
  000c3	a8 40		 test	 al, 64			; 00000040H
  000c5	74 09		 je	 SHORT $LN17@FieldNameI
  000c7	49 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [r8+128]
  000ce	eb 10		 jmp	 SHORT $LN20@FieldNameI
$LN17@FieldNameI:
  000d0	49 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [r8+160]
  000d7	eb 07		 jmp	 SHORT $LN20@FieldNameI
$LN19@FieldNameI:
  000d9	49 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [r8+160]
$LN20@FieldNameI:
  000e0	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  000e4	8b 14 81	 mov	 edx, DWORD PTR [rcx+rax*4]
$LN26@FieldNameI:
  000e7	48 ff c0	 inc	 rax
  000ea	49 89 41 18	 mov	 QWORD PTR [r9+24], rax

; 222  :         switch (c) {

  000ee	83 fa 2e	 cmp	 edx, 46			; 0000002eH
  000f1	74 21		 je	 SHORT $LN2@FieldNameI
  000f3	83 fa 5b	 cmp	 edx, 91			; 0000005bH
  000f6	74 1c		 je	 SHORT $LN2@FieldNameI

; 218  : 
; 219  :     /* return everything until '.' or '[' */
; 220  :     while (self->index < self->str.end) {

  000f8	49 8b 41 10	 mov	 rax, QWORD PTR [r9+16]
  000fc	49 39 41 18	 cmp	 QWORD PTR [r9+24], rax
  00100	0f 8c 2a ff ff
	ff		 jl	 $LL6@FieldNameI

; 227  :             break;
; 228  :         default:
; 229  :             continue;
; 230  :         }
; 231  :         break;
; 232  :     }
; 233  :     /* end of string is okay */
; 234  :     name->end = self->index;

  00106	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  0010a	49 89 42 10	 mov	 QWORD PTR [r10+16], rax

; 235  :     return 1;

  0010e	b8 01 00 00 00	 mov	 eax, 1

; 236  : }

  00113	c3		 ret	 0
$LN2@FieldNameI:

; 223  :         case '[':
; 224  :         case '.':
; 225  :             /* backup so that we this character will be seen next time */
; 226  :             self->index--;

  00114	48 ff c8	 dec	 rax
  00117	49 89 41 18	 mov	 QWORD PTR [r9+24], rax
$LN3@FieldNameI:

; 227  :             break;
; 228  :         default:
; 229  :             continue;
; 230  :         }
; 231  :         break;
; 232  :     }
; 233  :     /* end of string is okay */
; 234  :     name->end = self->index;

  0011b	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  0011f	49 89 42 10	 mov	 QWORD PTR [r10+16], rax

; 235  :     return 1;

  00123	b8 01 00 00 00	 mov	 eax, 1

; 236  : }

  00128	c3		 ret	 0
_FieldNameIterator_attr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@MFMHEKHD@Missing?5?8?$FN?8?5in?5format?5string?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_FieldNameIterator_item DD imagerel _FieldNameIterator_item
	DD	imagerel _FieldNameIterator_item+300
	DD	imagerel $unwind$_FieldNameIterator_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_FieldNameIterator_item DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BN@MFMHEKHD@Missing?5?8?$FN?8?5in?5format?5string?$AA@
CONST	SEGMENT
??_C@_0BN@MFMHEKHD@Missing?5?8?$FN?8?5in?5format?5string?$AA@ DB 'Missing'
	DB	' '']'' in format string', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _FieldNameIterator_item
_TEXT	SEGMENT
self$ = 48
name$ = 56
_FieldNameIterator_item PROC				; COMDAT

; 240  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 241  :     int bracket_seen = 0;
; 242  :     Py_UCS4 c;
; 243  : 
; 244  :     name->str = self->str.str;

  00004	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00007	4c 8b d2	 mov	 r10, rdx
  0000a	4c 8b c9	 mov	 r9, rcx
  0000d	48 89 02	 mov	 QWORD PTR [rdx], rax

; 245  :     name->start = self->index;

  00010	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00014	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 246  : 
; 247  :     /* return everything until ']' */
; 248  :     while (self->index < self->str.end) {

  00018	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0001c	48 39 41 18	 cmp	 QWORD PTR [rcx+24], rax
  00020	0f 8d db 00 00
	00		 jge	 $LN27@FieldNameI@2
  00026	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@FieldNameI@2:

; 249  :         c = PyUnicode_READ_CHAR(self->str.str, self->index++);

  00030	41 8b 40 70	 mov	 eax, DWORD PTR [r8+112]
  00034	8b c8		 mov	 ecx, eax
  00036	c1 e9 02	 shr	 ecx, 2
  00039	83 e1 07	 and	 ecx, 7
  0003c	83 f9 01	 cmp	 ecx, 1
  0003f	75 3e		 jne	 SHORT $LN24@FieldNameI@2
  00041	a8 20		 test	 al, 32			; 00000020H
  00043	74 29		 je	 SHORT $LN12@FieldNameI@2
  00045	a8 40		 test	 al, 64			; 00000040H
  00047	74 14		 je	 SHORT $LN10@FieldNameI@2
  00049	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  0004d	49 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [r8+128]
  00054	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00058	e9 8a 00 00 00	 jmp	 $LN28@FieldNameI@2
$LN10@FieldNameI@2:
  0005d	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  00061	49 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [r8+160]
  00068	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0006c	eb 79		 jmp	 SHORT $LN28@FieldNameI@2
$LN12@FieldNameI@2:
  0006e	49 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [r8+160]
  00075	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  00079	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0007d	eb 68		 jmp	 SHORT $LN28@FieldNameI@2
$LN24@FieldNameI@2:
  0007f	83 f9 02	 cmp	 ecx, 2
  00082	75 3b		 jne	 SHORT $LN22@FieldNameI@2
  00084	a8 20		 test	 al, 32			; 00000020H
  00086	74 26		 je	 SHORT $LN16@FieldNameI@2
  00088	a8 40		 test	 al, 64			; 00000040H
  0008a	74 11		 je	 SHORT $LN14@FieldNameI@2
  0008c	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  00090	49 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [r8+128]
  00097	0f b7 14 41	 movzx	 edx, WORD PTR [rcx+rax*2]
  0009b	eb 4a		 jmp	 SHORT $LN28@FieldNameI@2
$LN14@FieldNameI@2:
  0009d	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  000a1	49 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [r8+160]
  000a8	0f b7 14 41	 movzx	 edx, WORD PTR [rcx+rax*2]
  000ac	eb 39		 jmp	 SHORT $LN28@FieldNameI@2
$LN16@FieldNameI@2:
  000ae	49 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [r8+160]
  000b5	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  000b9	0f b7 14 41	 movzx	 edx, WORD PTR [rcx+rax*2]
  000bd	eb 28		 jmp	 SHORT $LN28@FieldNameI@2
$LN22@FieldNameI@2:
  000bf	a8 20		 test	 al, 32			; 00000020H
  000c1	74 16		 je	 SHORT $LN20@FieldNameI@2
  000c3	a8 40		 test	 al, 64			; 00000040H
  000c5	74 09		 je	 SHORT $LN18@FieldNameI@2
  000c7	49 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [r8+128]
  000ce	eb 10		 jmp	 SHORT $LN21@FieldNameI@2
$LN18@FieldNameI@2:
  000d0	49 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [r8+160]
  000d7	eb 07		 jmp	 SHORT $LN21@FieldNameI@2
$LN20@FieldNameI@2:
  000d9	49 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [r8+160]
$LN21@FieldNameI@2:
  000e0	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  000e4	8b 14 81	 mov	 edx, DWORD PTR [rcx+rax*4]
$LN28@FieldNameI@2:
  000e7	48 ff c0	 inc	 rax
  000ea	49 89 41 18	 mov	 QWORD PTR [r9+24], rax

; 250  :         switch (c) {

  000ee	83 fa 5d	 cmp	 edx, 93			; 0000005dH
  000f1	74 28		 je	 SHORT $LN1@FieldNameI@2

; 246  : 
; 247  :     /* return everything until ']' */
; 248  :     while (self->index < self->str.end) {

  000f3	49 8b 41 10	 mov	 rax, QWORD PTR [r9+16]
  000f7	49 39 41 18	 cmp	 QWORD PTR [r9+24], rax
  000fb	0f 8c 2f ff ff
	ff		 jl	 $LL7@FieldNameI@2
$LN27@FieldNameI@2:

; 251  :         case ']':
; 252  :             bracket_seen = 1;
; 253  :             break;
; 254  :         default:
; 255  :             continue;
; 256  :         }
; 257  :         break;
; 258  :     }
; 259  :     /* make sure we ended with a ']' */
; 260  :     if (!bracket_seen) {
; 261  :         PyErr_SetString(PyExc_ValueError, "Missing ']' in format string");

  00101	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00108	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@MFMHEKHD@Missing?5?8?$FN?8?5in?5format?5string?$AA@
  0010f	e8 00 00 00 00	 call	 PyErr_SetString

; 262  :         return 0;

  00114	33 c0		 xor	 eax, eax

; 269  : }

  00116	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0011a	c3		 ret	 0
$LN1@FieldNameI@2:

; 263  :     }
; 264  : 
; 265  :     /* end of string is okay */
; 266  :     /* don't include the ']' */
; 267  :     name->end = self->index-1;

  0011b	48 ff c8	 dec	 rax
  0011e	49 89 42 10	 mov	 QWORD PTR [r10+16], rax

; 268  :     return 1;

  00122	b8 01 00 00 00	 mov	 eax, 1

; 269  : }

  00127	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0012b	c3		 ret	 0
_FieldNameIterator_item ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@GAIAJIKF@Empty?5attribute?5in?5format?5string@ ; `string'
PUBLIC	??_C@_0DJ@CODDJGMC@Only?5?8?4?8?5or?5?8?$FL?8?5may?5follow?5?8?$FN?8?5i@ ; `string'
EXTRN	PyErr_Occurred:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$FieldNameIterator_next DD imagerel FieldNameIterator_next
	DD	imagerel FieldNameIterator_next+402
	DD	imagerel $unwind$FieldNameIterator_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$FieldNameIterator_next DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0CB@GAIAJIKF@Empty?5attribute?5in?5format?5string@
CONST	SEGMENT
??_C@_0CB@GAIAJIKF@Empty?5attribute?5in?5format?5string@ DB 'Empty attrib'
	DB	'ute in format string', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@CODDJGMC@Only?5?8?4?8?5or?5?8?$FL?8?5may?5follow?5?8?$FN?8?5i@
CONST	SEGMENT
??_C@_0DJ@CODDJGMC@Only?5?8?4?8?5or?5?8?$FL?8?5may?5follow?5?8?$FN?8?5i@ DB 'O'
	DB	'nly ''.'' or ''['' may follow '']'' in format field specifier'
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT FieldNameIterator_next
_TEXT	SEGMENT
self$ = 48
is_attribute$ = 56
name_idx$ = 64
name$ = 72
FieldNameIterator_next PROC				; COMDAT

; 275  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 276  :     /* check at end of input */
; 277  :     if (self->index >= self->str.end)

  0000a	4c 8b 51 18	 mov	 r10, QWORD PTR [rcx+24]
  0000e	49 8b d9	 mov	 rbx, r9
  00011	49 8b f8	 mov	 rdi, r8
  00014	4c 8b c2	 mov	 r8, rdx
  00017	4c 8b c9	 mov	 r9, rcx
  0001a	4c 3b 51 10	 cmp	 r10, QWORD PTR [rcx+16]
  0001e	7c 10		 jl	 SHORT $LN10@FieldNameI@3

; 278  :         return 1;

  00020	b8 01 00 00 00	 mov	 eax, 1

; 309  : }

  00025	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
$LN10@FieldNameI@3:

; 279  : 
; 280  :     switch (PyUnicode_READ_CHAR(self->str.str, self->index++)) {

  00030	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00033	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  00036	8b d1		 mov	 edx, ecx
  00038	c1 ea 02	 shr	 edx, 2
  0003b	83 e2 07	 and	 edx, 7
  0003e	83 fa 01	 cmp	 edx, 1
  00041	75 30		 jne	 SHORT $LN27@FieldNameI@3
  00043	f6 c1 20	 test	 cl, 32			; 00000020H
  00046	74 1d		 je	 SHORT $LN15@FieldNameI@3
  00048	f6 c1 40	 test	 cl, 64			; 00000040H
  0004b	74 0b		 je	 SHORT $LN13@FieldNameI@3
  0004d	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  00051	41 0f b6 0c 02	 movzx	 ecx, BYTE PTR [r10+rax]
  00056	eb 73		 jmp	 SHORT $LN29@FieldNameI@3
$LN13@FieldNameI@3:
  00058	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  0005e	41 0f b6 0c 02	 movzx	 ecx, BYTE PTR [r10+rax]
  00063	eb 66		 jmp	 SHORT $LN29@FieldNameI@3
$LN15@FieldNameI@3:
  00065	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0006c	41 0f b6 0c 02	 movzx	 ecx, BYTE PTR [r10+rax]
  00071	eb 58		 jmp	 SHORT $LN29@FieldNameI@3
$LN27@FieldNameI@3:
  00073	83 fa 02	 cmp	 edx, 2
  00076	75 30		 jne	 SHORT $LN25@FieldNameI@3
  00078	f6 c1 20	 test	 cl, 32			; 00000020H
  0007b	74 1d		 je	 SHORT $LN19@FieldNameI@3
  0007d	f6 c1 40	 test	 cl, 64			; 00000040H
  00080	74 0b		 je	 SHORT $LN17@FieldNameI@3
  00082	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  00086	42 0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+r10*2]
  0008b	eb 3e		 jmp	 SHORT $LN29@FieldNameI@3
$LN17@FieldNameI@3:
  0008d	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00093	42 0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+r10*2]
  00098	eb 31		 jmp	 SHORT $LN29@FieldNameI@3
$LN19@FieldNameI@3:
  0009a	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  000a1	42 0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+r10*2]
  000a6	eb 23		 jmp	 SHORT $LN29@FieldNameI@3
$LN25@FieldNameI@3:
  000a8	f6 c1 20	 test	 cl, 32			; 00000020H
  000ab	74 13		 je	 SHORT $LN23@FieldNameI@3
  000ad	f6 c1 40	 test	 cl, 64			; 00000040H
  000b0	74 06		 je	 SHORT $LN21@FieldNameI@3
  000b2	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  000b6	eb 0f		 jmp	 SHORT $LN24@FieldNameI@3
$LN21@FieldNameI@3:
  000b8	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  000be	eb 07		 jmp	 SHORT $LN24@FieldNameI@3
$LN23@FieldNameI@3:
  000c0	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
$LN24@FieldNameI@3:
  000c7	42 8b 0c 90	 mov	 ecx, DWORD PTR [rax+r10*4]
$LN29@FieldNameI@3:
  000cb	49 8d 42 01	 lea	 rax, QWORD PTR [r10+1]
  000cf	49 89 41 18	 mov	 QWORD PTR [r9+24], rax
  000d3	83 f9 2e	 cmp	 ecx, 46			; 0000002eH
  000d6	74 63		 je	 SHORT $LN7@FieldNameI@3
  000d8	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  000db	74 20		 je	 SHORT $LN5@FieldNameI@3

; 294  :         break;
; 295  :     default:
; 296  :         /* Invalid character follows ']' */
; 297  :         PyErr_SetString(PyExc_ValueError, "Only '.' or '[' may "
; 298  :                         "follow ']' in format field specifier");

  000dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DJ@CODDJGMC@Only?5?8?4?8?5or?5?8?$FL?8?5may?5follow?5?8?$FN?8?5i@
  000eb	e8 00 00 00 00	 call	 PyErr_SetString

; 299  :         return 0;

  000f0	33 c0		 xor	 eax, eax

; 309  : }

  000f2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000f7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fb	5f		 pop	 rdi
  000fc	c3		 ret	 0
$LN5@FieldNameI@3:

; 286  :         break;
; 287  :     case '[':
; 288  :         *is_attribute = 0;
; 289  :         if (_FieldNameIterator_item(self, name) == 0)

  000fd	48 8b d3	 mov	 rdx, rbx
  00100	49 8b c9	 mov	 rcx, r9
  00103	41 c7 00 00 00
	00 00		 mov	 DWORD PTR [r8], 0
  0010a	e8 00 00 00 00	 call	 _FieldNameIterator_item
  0010f	85 c0		 test	 eax, eax

; 290  :             return 0;

  00111	74 1b		 je	 SHORT $LN30@FieldNameI@3

; 291  :         *name_idx = get_integer(name);

  00113	48 8b cb	 mov	 rcx, rbx
  00116	e8 00 00 00 00	 call	 get_integer
  0011b	48 89 07	 mov	 QWORD PTR [rdi], rax

; 292  :         if (*name_idx == -1 && PyErr_Occurred())

  0011e	48 83 f8 ff	 cmp	 rax, -1
  00122	75 34		 jne	 SHORT $LN8@FieldNameI@3
  00124	e8 00 00 00 00	 call	 PyErr_Occurred
  00129	48 85 c0	 test	 rax, rax
  0012c	74 2a		 je	 SHORT $LN8@FieldNameI@3
$LN30@FieldNameI@3:

; 293  :             return 0;

  0012e	33 c0		 xor	 eax, eax

; 309  : }

  00130	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00135	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00139	5f		 pop	 rdi
  0013a	c3		 ret	 0
$LN7@FieldNameI@3:

; 281  :     case '.':
; 282  :         *is_attribute = 1;
; 283  :         if (_FieldNameIterator_attr(self, name) == 0)

  0013b	48 8b d3	 mov	 rdx, rbx
  0013e	49 8b c9	 mov	 rcx, r9
  00141	41 c7 00 01 00
	00 00		 mov	 DWORD PTR [r8], 1
  00148	e8 00 00 00 00	 call	 _FieldNameIterator_attr
  0014d	85 c0		 test	 eax, eax

; 284  :             return 0;

  0014f	74 dd		 je	 SHORT $LN30@FieldNameI@3

; 285  :         *name_idx = -1;

  00151	48 c7 07 ff ff
	ff ff		 mov	 QWORD PTR [rdi], -1
$LN8@FieldNameI@3:

; 300  :     }
; 301  : 
; 302  :     /* empty string is an error */
; 303  :     if (name->start == name->end) {

  00158	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0015c	48 39 43 08	 cmp	 QWORD PTR [rbx+8], rax
  00160	75 20		 jne	 SHORT $LN1@FieldNameI@3

; 304  :         PyErr_SetString(PyExc_ValueError, "Empty attribute in format string");

  00162	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00169	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@GAIAJIKF@Empty?5attribute?5in?5format?5string@
  00170	e8 00 00 00 00	 call	 PyErr_SetString

; 305  :         return 0;

  00175	33 c0		 xor	 eax, eax

; 309  : }

  00177	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0017c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00180	5f		 pop	 rdi
  00181	c3		 ret	 0
$LN1@FieldNameI@3:

; 306  :     }
; 307  : 
; 308  :     return 2;

  00182	b8 02 00 00 00	 mov	 eax, 2

; 309  : }

  00187	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0018c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00190	5f		 pop	 rdi
  00191	c3		 ret	 0
FieldNameIterator_next ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$field_name_split DD imagerel field_name_split
	DD	imagerel field_name_split+314
	DD	imagerel $unwind$field_name_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$field_name_split DD imagerel field_name_split+314
	DD	imagerel field_name_split+409
	DD	imagerel $chain$0$field_name_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$field_name_split DD imagerel field_name_split+409
	DD	imagerel field_name_split+444
	DD	imagerel $chain$2$field_name_split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$field_name_split DD 020021H
	DD	067400H
	DD	imagerel field_name_split
	DD	imagerel field_name_split+314
	DD	imagerel $unwind$field_name_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$field_name_split DD 020521H
	DD	067405H
	DD	imagerel field_name_split
	DD	imagerel field_name_split+314
	DD	imagerel $unwind$field_name_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$field_name_split DD 040a01H
	DD	07340aH
	DD	06006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT field_name_split
_TEXT	SEGMENT
str$ = 48
start$ = 56
end$ = 64
first$ = 72
first_idx$ = 80
rest$ = 88
auto_number$ = 96
field_name_split PROC					; COMDAT

; 322  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b d9	 mov	 rbx, r9
  0000d	4d 8b c8	 mov	 r9, r8

; 323  :     Py_UCS4 c;
; 324  :     Py_ssize_t i = start;

  00010	4c 8b c2	 mov	 r8, rdx

; 325  :     int field_name_is_empty;
; 326  :     int using_numeric_index;
; 327  : 
; 328  :     /* find the part up until the first '.' or '[' */
; 329  :     while (i < end) {

  00013	49 3b d1	 cmp	 rdx, r9
  00016	0f 8d d3 00 00
	00		 jge	 $LN9@field_name
  0001c	44 8b 51 70	 mov	 r10d, DWORD PTR [rcx+112]
  00020	45 8b da	 mov	 r11d, r10d
  00023	41 c1 eb 02	 shr	 r11d, 2
  00027	41 83 e3 07	 and	 r11d, 7
  0002b	0f 1f 44 00 00	 npad	 5
$LL12@field_name:

; 330  :         switch (c = PyUnicode_READ_CHAR(str, i++)) {

  00030	41 83 fb 01	 cmp	 r11d, 1
  00034	75 39		 jne	 SHORT $LN29@field_name
  00036	41 f6 c2 20	 test	 r10b, 32		; 00000020H
  0003a	74 25		 je	 SHORT $LN17@field_name
  0003c	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  00040	74 11		 je	 SHORT $LN15@field_name
  00042	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  00049	42 0f b6 04 00	 movzx	 eax, BYTE PTR [rax+r8]
  0004e	e9 81 00 00 00	 jmp	 $LN37@field_name
$LN15@field_name:
  00053	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  0005a	42 0f b6 04 00	 movzx	 eax, BYTE PTR [rax+r8]
  0005f	eb 73		 jmp	 SHORT $LN37@field_name
$LN17@field_name:
  00061	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
  00068	42 0f b6 04 00	 movzx	 eax, BYTE PTR [rax+r8]
  0006d	eb 65		 jmp	 SHORT $LN37@field_name
$LN29@field_name:
  0006f	41 83 fb 02	 cmp	 r11d, 2
  00073	75 36		 jne	 SHORT $LN27@field_name
  00075	41 f6 c2 20	 test	 r10b, 32		; 00000020H
  00079	74 22		 je	 SHORT $LN21@field_name
  0007b	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  0007f	74 0e		 je	 SHORT $LN19@field_name
  00081	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  00088	42 0f b7 04 40	 movzx	 eax, WORD PTR [rax+r8*2]
  0008d	eb 45		 jmp	 SHORT $LN37@field_name
$LN19@field_name:
  0008f	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  00096	42 0f b7 04 40	 movzx	 eax, WORD PTR [rax+r8*2]
  0009b	eb 37		 jmp	 SHORT $LN37@field_name
$LN21@field_name:
  0009d	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
  000a4	42 0f b7 04 40	 movzx	 eax, WORD PTR [rax+r8*2]
  000a9	eb 29		 jmp	 SHORT $LN37@field_name
$LN27@field_name:
  000ab	41 f6 c2 20	 test	 r10b, 32		; 00000020H
  000af	74 18		 je	 SHORT $LN25@field_name
  000b1	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  000b5	74 09		 je	 SHORT $LN23@field_name
  000b7	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  000be	eb 10		 jmp	 SHORT $LN26@field_name
$LN23@field_name:
  000c0	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  000c7	eb 07		 jmp	 SHORT $LN26@field_name
$LN25@field_name:
  000c9	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
$LN26@field_name:
  000d0	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
$LN37@field_name:
  000d4	49 ff c0	 inc	 r8
  000d7	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  000da	74 10		 je	 SHORT $LN8@field_name
  000dc	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  000df	74 0b		 je	 SHORT $LN8@field_name

; 325  :     int field_name_is_empty;
; 326  :     int using_numeric_index;
; 327  : 
; 328  :     /* find the part up until the first '.' or '[' */
; 329  :     while (i < end) {

  000e1	4d 3b c1	 cmp	 r8, r9
  000e4	0f 8c 46 ff ff
	ff		 jl	 $LL12@field_name
  000ea	eb 03		 jmp	 SHORT $LN9@field_name
$LN8@field_name:

; 331  :         case '[':
; 332  :         case '.':
; 333  :             /* backup so that we this character is available to the
; 334  :                "rest" iterator */
; 335  :             i--;

  000ec	49 ff c8	 dec	 r8
$LN9@field_name:

; 336  :             break;
; 337  :         default:
; 338  :             continue;
; 339  :         }
; 340  :         break;
; 341  :     }
; 342  : 
; 343  :     /* set up the return values */
; 344  :     SubString_init(first, str, start, i);

  000ef	48 89 53 08	 mov	 QWORD PTR [rbx+8], rdx
  000f3	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 345  :     FieldNameIterator_init(rest, str, i, end);

  000f6	48 8b d1	 mov	 rdx, rcx
  000f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rest$[rsp]
  000fe	4c 89 43 10	 mov	 QWORD PTR [rbx+16], r8
  00102	e8 00 00 00 00	 call	 FieldNameIterator_init

; 346  : 
; 347  :     /* see if "first" is an integer, in which case it's used as an index */
; 348  :     *first_idx = get_integer(first);

  00107	48 8b cb	 mov	 rcx, rbx
  0010a	e8 00 00 00 00	 call	 get_integer
  0010f	48 8b 74 24 50	 mov	 rsi, QWORD PTR first_idx$[rsp]
  00114	48 89 06	 mov	 QWORD PTR [rsi], rax

; 349  :     if (*first_idx == -1 && PyErr_Occurred())

  00117	48 83 f8 ff	 cmp	 rax, -1
  0011b	75 17		 jne	 SHORT $LN6@field_name
  0011d	e8 00 00 00 00	 call	 PyErr_Occurred
  00122	48 85 c0	 test	 rax, rax
  00125	74 0d		 je	 SHORT $LN6@field_name

; 350  :         return 0;

  00127	33 c0		 xor	 eax, eax

; 384  :     }
; 385  : 
; 386  :     return 1;
; 387  : }

  00129	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0012e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00132	5e		 pop	 rsi
  00133	c3		 ret	 0
$LN6@field_name:

; 351  : 
; 352  :     field_name_is_empty = first->start >= first->end;

  00134	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00138	33 d2		 xor	 edx, edx
  0013a	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0013f	48 39 43 08	 cmp	 QWORD PTR [rbx+8], rax
  00143	8b fa		 mov	 edi, edx
  00145	40 0f 9d c7	 setge	 dil

; 353  : 
; 354  :     /* If the field name is omitted or if we have a numeric index
; 355  :        specified, then we're doing numeric indexing into args. */
; 356  :     using_numeric_index = field_name_is_empty || *first_idx != -1;

  00149	85 ff		 test	 edi, edi
  0014b	75 06		 jne	 SHORT $LN31@field_name
  0014d	48 83 3e ff	 cmp	 QWORD PTR [rsi], -1
  00151	74 05		 je	 SHORT $LN32@field_name
$LN31@field_name:
  00153	ba 01 00 00 00	 mov	 edx, 1
$LN32@field_name:

; 357  : 
; 358  :     /* We always get here exactly one time for each field we're
; 359  :        processing. And we get here in field order (counting by left
; 360  :        braces). So this is the perfect place to handle automatic field
; 361  :        numbering if the field name is omitted. */
; 362  : 
; 363  :     /* Check if we need to do the auto-numbering. It's not needed if
; 364  :        we're called from string.Format routines, because it's handled
; 365  :        in that class by itself. */
; 366  :     if (auto_number) {

  00158	48 8b 5c 24 60	 mov	 rbx, QWORD PTR auto_number$[rsp]
  0015d	48 85 db	 test	 rbx, rbx
  00160	74 45		 je	 SHORT $LN1@field_name

; 367  :         /* Initialize our auto numbering state if this is the first
; 368  :            time we're either auto-numbering or manually numbering. */
; 369  :         if (auto_number->an_state == ANS_INIT && using_numeric_index)

  00162	83 3b 00	 cmp	 DWORD PTR [rbx], 0
  00165	75 0f		 jne	 SHORT $LN4@field_name
  00167	85 d2		 test	 edx, edx
  00169	74 2e		 je	 SHORT $LN2@field_name

; 370  :             auto_number->an_state = field_name_is_empty ?
; 371  :                 ANS_AUTO : ANS_MANUAL;

  0016b	8b c7		 mov	 eax, edi
  0016d	f7 d8		 neg	 eax
  0016f	1b c9		 sbb	 ecx, ecx
  00171	83 c1 02	 add	 ecx, 2
  00174	89 0b		 mov	 DWORD PTR [rbx], ecx
$LN4@field_name:

; 372  : 
; 373  :         /* Make sure our state is consistent with what we're doing
; 374  :            this time through. Only check if we're using a numeric
; 375  :            index. */
; 376  :         if (using_numeric_index)

  00176	85 d2		 test	 edx, edx
  00178	74 1f		 je	 SHORT $LN2@field_name

; 377  :             if (autonumber_state_error(auto_number->an_state,
; 378  :                                        field_name_is_empty))

  0017a	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  0017c	8b d7		 mov	 edx, edi
  0017e	e8 00 00 00 00	 call	 autonumber_state_error
  00183	85 c0		 test	 eax, eax
  00185	74 12		 je	 SHORT $LN2@field_name

; 379  :                 return 0;

  00187	33 c0		 xor	 eax, eax
  00189	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 384  :     }
; 385  : 
; 386  :     return 1;
; 387  : }

  0018e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00193	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00197	5e		 pop	 rsi
  00198	c3		 ret	 0
$LN2@field_name:

; 380  :         /* Zero length field means we want to do auto-numbering of the
; 381  :            fields. */
; 382  :         if (field_name_is_empty)

  00199	85 ff		 test	 edi, edi
  0019b	74 0a		 je	 SHORT $LN1@field_name

; 383  :             *first_idx = (auto_number->an_field_number)++;

  0019d	48 63 4b 04	 movsxd	 rcx, DWORD PTR [rbx+4]
  001a1	48 89 0e	 mov	 QWORD PTR [rsi], rcx
  001a4	ff 43 04	 inc	 DWORD PTR [rbx+4]
$LN1@field_name:

; 384  :     }
; 385  : 
; 386  :     return 1;
; 387  : }

  001a7	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  001ac	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  001b1	b8 01 00 00 00	 mov	 eax, 1
  001b6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001ba	5e		 pop	 rsi
  001bb	c3		 ret	 0
field_name_split ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@MBPIFJIB@expected?5?8?3?8?5after?5format?5specif@ ; `string'
PUBLIC	??_C@_0DF@ELLFBNEN@end?5of?5format?5while?5looking?5for?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$parse_field DD imagerel parse_field
	DD	imagerel parse_field+760
	DD	imagerel $unwind$parse_field
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parse_field DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CE@MBPIFJIB@expected?5?8?3?8?5after?5format?5specif@
CONST	SEGMENT
??_C@_0CE@MBPIFJIB@expected?5?8?3?8?5after?5format?5specif@ DB 'expected '
	DB	''':'' after format specifier', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@ELLFBNEN@end?5of?5format?5while?5looking?5for?5@
CONST	SEGMENT
??_C@_0DF@ELLFBNEN@end?5of?5format?5while?5looking?5for?5@ DB 'end of for'
	DB	'mat while looking for conversion specifier', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT parse_field
_TEXT	SEGMENT
str$ = 48
field_name$ = 56
format_spec$ = 64
conversion$ = 72
parse_field PROC					; COMDAT

; 547  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 548  :     /* Note this function works if the field name is zero length,
; 549  :        which is good.  Zero length field names are handled later, in
; 550  :        field_name_split. */
; 551  : 
; 552  :     Py_UCS4 c = 0;
; 553  : 
; 554  :     /* initialize these, as they may be empty */
; 555  :     *conversion = '\0';

  00006	33 c0		 xor	 eax, eax
  00008	49 8b d9	 mov	 rbx, r9
  0000b	4d 8b d8	 mov	 r11, r8
  0000e	89 03		 mov	 DWORD PTR [rbx], eax

; 556  :     SubString_init(format_spec, NULL, 0, 0);

  00010	49 89 00	 mov	 QWORD PTR [r8], rax
  00013	49 89 40 08	 mov	 QWORD PTR [r8+8], rax
  00017	49 89 40 10	 mov	 QWORD PTR [r8+16], rax

; 557  : 
; 558  :     /* Search for the field name.  it's terminated by the end of
; 559  :        the string, or a ':' or '!' */
; 560  :     field_name->str = str->str;

  0001b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0001e	4c 8b ca	 mov	 r9, rdx
  00021	48 89 02	 mov	 QWORD PTR [rdx], rax

; 561  :     field_name->start = str->start;

  00024	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00028	4c 8b d1	 mov	 r10, rcx
  0002b	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 562  :     while (str->start < str->end) {

  0002f	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00033	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  00037	0f 8d a8 02 00
	00		 jge	 $LN68@parse_fiel
  0003d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LL13@parse_fiel:

; 563  :         switch ((c = PyUnicode_READ_CHAR(str->str, str->start++))) {

  00040	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00043	8b d0		 mov	 edx, eax
  00045	c1 ea 02	 shr	 edx, 2
  00048	83 e2 07	 and	 edx, 7
  0004b	83 fa 01	 cmp	 edx, 1
  0004e	75 44		 jne	 SHORT $LN30@parse_fiel
  00050	a8 20		 test	 al, 32			; 00000020H
  00052	74 2e		 je	 SHORT $LN18@parse_fiel
  00054	a8 40		 test	 al, 64			; 00000040H
  00056	74 15		 je	 SHORT $LN16@parse_fiel
  00058	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  0005c	48 8d 91 80 00
	00 00		 lea	 rdx, QWORD PTR [rcx+128]
  00063	44 0f b6 04 10	 movzx	 r8d, BYTE PTR [rax+rdx]
  00068	e9 93 00 00 00	 jmp	 $LN69@parse_fiel
$LN16@parse_fiel:
  0006d	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  00071	48 8d 91 a0 00
	00 00		 lea	 rdx, QWORD PTR [rcx+160]
  00078	44 0f b6 04 10	 movzx	 r8d, BYTE PTR [rax+rdx]
  0007d	e9 7e 00 00 00	 jmp	 $LN69@parse_fiel
$LN18@parse_fiel:
  00082	48 8b 91 a0 00
	00 00		 mov	 rdx, QWORD PTR [rcx+160]
  00089	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  0008d	44 0f b6 04 10	 movzx	 r8d, BYTE PTR [rax+rdx]
  00092	eb 6c		 jmp	 SHORT $LN69@parse_fiel
$LN30@parse_fiel:
  00094	83 fa 02	 cmp	 edx, 2
  00097	75 3e		 jne	 SHORT $LN28@parse_fiel
  00099	a8 20		 test	 al, 32			; 00000020H
  0009b	74 28		 je	 SHORT $LN22@parse_fiel
  0009d	a8 40		 test	 al, 64			; 00000040H
  0009f	74 12		 je	 SHORT $LN20@parse_fiel
  000a1	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  000a5	48 8d 91 80 00
	00 00		 lea	 rdx, QWORD PTR [rcx+128]
  000ac	44 0f b7 04 42	 movzx	 r8d, WORD PTR [rdx+rax*2]
  000b1	eb 4d		 jmp	 SHORT $LN69@parse_fiel
$LN20@parse_fiel:
  000b3	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  000b7	48 8d 91 a0 00
	00 00		 lea	 rdx, QWORD PTR [rcx+160]
  000be	44 0f b7 04 42	 movzx	 r8d, WORD PTR [rdx+rax*2]
  000c3	eb 3b		 jmp	 SHORT $LN69@parse_fiel
$LN22@parse_fiel:
  000c5	48 8b 91 a0 00
	00 00		 mov	 rdx, QWORD PTR [rcx+160]
  000cc	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  000d0	44 0f b7 04 42	 movzx	 r8d, WORD PTR [rdx+rax*2]
  000d5	eb 29		 jmp	 SHORT $LN69@parse_fiel
$LN28@parse_fiel:
  000d7	a8 20		 test	 al, 32			; 00000020H
  000d9	74 16		 je	 SHORT $LN26@parse_fiel
  000db	a8 40		 test	 al, 64			; 00000040H
  000dd	74 09		 je	 SHORT $LN24@parse_fiel
  000df	48 8d 91 80 00
	00 00		 lea	 rdx, QWORD PTR [rcx+128]
  000e6	eb 10		 jmp	 SHORT $LN27@parse_fiel
$LN24@parse_fiel:
  000e8	48 8d 91 a0 00
	00 00		 lea	 rdx, QWORD PTR [rcx+160]
  000ef	eb 07		 jmp	 SHORT $LN27@parse_fiel
$LN26@parse_fiel:
  000f1	48 8b 91 a0 00
	00 00		 mov	 rdx, QWORD PTR [rcx+160]
$LN27@parse_fiel:
  000f8	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  000fc	44 8b 04 82	 mov	 r8d, DWORD PTR [rdx+rax*4]
$LN69@parse_fiel:
  00100	48 8d 50 01	 lea	 rdx, QWORD PTR [rax+1]
  00104	49 89 52 08	 mov	 QWORD PTR [r10+8], rdx
  00108	41 83 f8 21	 cmp	 r8d, 33			; 00000021H
  0010c	74 1d		 je	 SHORT $LN6@parse_fiel
  0010e	41 83 f8 3a	 cmp	 r8d, 58			; 0000003aH
  00112	74 17		 je	 SHORT $LN6@parse_fiel

; 562  :     while (str->start < str->end) {

  00114	49 8b 42 10	 mov	 rax, QWORD PTR [r10+16]
  00118	48 3b d0	 cmp	 rdx, rax
  0011b	0f 8c 1f ff ff
	ff		 jl	 $LL13@parse_fiel

; 564  :         case ':':
; 565  :         case '!':
; 566  :             break;
; 567  :         default:
; 568  :             continue;
; 569  :         }
; 570  :         break;
; 571  :     }
; 572  : 
; 573  :     if (c == '!' || c == ':') {

  00121	41 83 f8 3a	 cmp	 r8d, 58			; 0000003aH
  00125	0f 85 ba 01 00
	00		 jne	 $LN68@parse_fiel
$LN6@parse_fiel:

; 574  :         /* we have a format specifier and/or a conversion */
; 575  :         /* don't include the last character */
; 576  :         field_name->end = str->start-1;

  0012b	48 8d 42 ff	 lea	 rax, QWORD PTR [rdx-1]
  0012f	49 89 41 10	 mov	 QWORD PTR [r9+16], rax

; 577  : 
; 578  :         /* the format specifier is the rest of the string */
; 579  :         format_spec->str = str->str;

  00133	49 8b 02	 mov	 rax, QWORD PTR [r10]
  00136	49 89 03	 mov	 QWORD PTR [r11], rax

; 580  :         format_spec->start = str->start;

  00139	49 8b 52 08	 mov	 rdx, QWORD PTR [r10+8]
  0013d	49 89 53 08	 mov	 QWORD PTR [r11+8], rdx

; 581  :         format_spec->end = str->end;

  00141	49 8b 42 10	 mov	 rax, QWORD PTR [r10+16]
  00145	49 89 43 10	 mov	 QWORD PTR [r11+16], rax

; 582  : 
; 583  :         /* see if there's a conversion specifier */
; 584  :         if (c == '!') {

  00149	41 83 f8 21	 cmp	 r8d, 33			; 00000021H
  0014d	0f 85 9a 01 00
	00		 jne	 $LN2@parse_fiel

; 585  :             /* there must be another character present */
; 586  :             if (format_spec->start >= format_spec->end) {

  00153	48 3b d0	 cmp	 rdx, rax
  00156	7c 1b		 jl	 SHORT $LN4@parse_fiel

; 587  :                 PyErr_SetString(PyExc_ValueError,
; 588  :                                 "end of format while looking for conversion "
; 589  :                                 "specifier");

  00158	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0015f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@ELLFBNEN@end?5of?5format?5while?5looking?5for?5@
  00166	e8 00 00 00 00	 call	 PyErr_SetString

; 590  :                 return 0;

  0016b	33 c0		 xor	 eax, eax

; 610  : }

  0016d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00171	5b		 pop	 rbx
  00172	c3		 ret	 0
$LN4@parse_fiel:

; 591  :             }
; 592  :             *conversion = PyUnicode_READ_CHAR(format_spec->str, format_spec->start++);

  00173	49 8b 03	 mov	 rax, QWORD PTR [r11]
  00176	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  00179	44 8b c1	 mov	 r8d, ecx
  0017c	41 c1 e8 02	 shr	 r8d, 2
  00180	41 83 e0 07	 and	 r8d, 7
  00184	41 83 f8 01	 cmp	 r8d, 1
  00188	75 2d		 jne	 SHORT $LN46@parse_fiel
  0018a	f6 c1 20	 test	 cl, 32			; 00000020H
  0018d	74 1b		 je	 SHORT $LN34@parse_fiel
  0018f	f6 c1 40	 test	 cl, 64			; 00000040H
  00192	74 0a		 je	 SHORT $LN32@parse_fiel
  00194	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  00198	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  0019c	eb 6e		 jmp	 SHORT $LN70@parse_fiel
$LN32@parse_fiel:
  0019e	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  001a4	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  001a8	eb 62		 jmp	 SHORT $LN70@parse_fiel
$LN34@parse_fiel:
  001aa	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  001b1	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  001b5	eb 55		 jmp	 SHORT $LN70@parse_fiel
$LN46@parse_fiel:
  001b7	41 83 f8 02	 cmp	 r8d, 2
  001bb	75 2d		 jne	 SHORT $LN44@parse_fiel
  001bd	f6 c1 20	 test	 cl, 32			; 00000020H
  001c0	74 1b		 je	 SHORT $LN38@parse_fiel
  001c2	f6 c1 40	 test	 cl, 64			; 00000040H
  001c5	74 0a		 je	 SHORT $LN36@parse_fiel
  001c7	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  001cb	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  001cf	eb 3b		 jmp	 SHORT $LN70@parse_fiel
$LN36@parse_fiel:
  001d1	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  001d7	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  001db	eb 2f		 jmp	 SHORT $LN70@parse_fiel
$LN38@parse_fiel:
  001dd	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  001e4	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  001e8	eb 22		 jmp	 SHORT $LN70@parse_fiel
$LN44@parse_fiel:
  001ea	f6 c1 20	 test	 cl, 32			; 00000020H
  001ed	74 13		 je	 SHORT $LN42@parse_fiel
  001ef	f6 c1 40	 test	 cl, 64			; 00000040H
  001f2	74 06		 je	 SHORT $LN40@parse_fiel
  001f4	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  001f8	eb 0f		 jmp	 SHORT $LN43@parse_fiel
$LN40@parse_fiel:
  001fa	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00200	eb 07		 jmp	 SHORT $LN43@parse_fiel
$LN42@parse_fiel:
  00202	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
$LN43@parse_fiel:
  00209	8b 0c 90	 mov	 ecx, DWORD PTR [rax+rdx*4]
$LN70@parse_fiel:
  0020c	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  00210	49 89 43 08	 mov	 QWORD PTR [r11+8], rax
  00214	89 0b		 mov	 DWORD PTR [rbx], ecx

; 593  : 
; 594  :             /* if there is another character, it must be a colon */
; 595  :             if (format_spec->start < format_spec->end) {

  00216	49 8b 53 08	 mov	 rdx, QWORD PTR [r11+8]
  0021a	49 3b 53 10	 cmp	 rdx, QWORD PTR [r11+16]
  0021e	0f 8d c9 00 00
	00		 jge	 $LN2@parse_fiel

; 596  :                 c = PyUnicode_READ_CHAR(format_spec->str, format_spec->start++);

  00224	49 8b 03	 mov	 rax, QWORD PTR [r11]
  00227	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  0022a	44 8b c1	 mov	 r8d, ecx
  0022d	41 c1 e8 02	 shr	 r8d, 2
  00231	41 83 e0 07	 and	 r8d, 7
  00235	41 83 f8 01	 cmp	 r8d, 1
  00239	75 2d		 jne	 SHORT $LN62@parse_fiel
  0023b	f6 c1 20	 test	 cl, 32			; 00000020H
  0023e	74 1b		 je	 SHORT $LN50@parse_fiel
  00240	f6 c1 40	 test	 cl, 64			; 00000040H
  00243	74 0a		 je	 SHORT $LN48@parse_fiel
  00245	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  00249	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  0024d	eb 6e		 jmp	 SHORT $LN71@parse_fiel
$LN48@parse_fiel:
  0024f	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00255	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  00259	eb 62		 jmp	 SHORT $LN71@parse_fiel
$LN50@parse_fiel:
  0025b	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00262	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  00266	eb 55		 jmp	 SHORT $LN71@parse_fiel
$LN62@parse_fiel:
  00268	41 83 f8 02	 cmp	 r8d, 2
  0026c	75 2d		 jne	 SHORT $LN60@parse_fiel
  0026e	f6 c1 20	 test	 cl, 32			; 00000020H
  00271	74 1b		 je	 SHORT $LN54@parse_fiel
  00273	f6 c1 40	 test	 cl, 64			; 00000040H
  00276	74 0a		 je	 SHORT $LN52@parse_fiel
  00278	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  0027c	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  00280	eb 3b		 jmp	 SHORT $LN71@parse_fiel
$LN52@parse_fiel:
  00282	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00288	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  0028c	eb 2f		 jmp	 SHORT $LN71@parse_fiel
$LN54@parse_fiel:
  0028e	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00295	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  00299	eb 22		 jmp	 SHORT $LN71@parse_fiel
$LN60@parse_fiel:
  0029b	f6 c1 20	 test	 cl, 32			; 00000020H
  0029e	74 13		 je	 SHORT $LN58@parse_fiel
  002a0	f6 c1 40	 test	 cl, 64			; 00000040H
  002a3	74 06		 je	 SHORT $LN56@parse_fiel
  002a5	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  002a9	eb 0f		 jmp	 SHORT $LN59@parse_fiel
$LN56@parse_fiel:
  002ab	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  002b1	eb 07		 jmp	 SHORT $LN59@parse_fiel
$LN58@parse_fiel:
  002b3	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
$LN59@parse_fiel:
  002ba	8b 0c 90	 mov	 ecx, DWORD PTR [rax+rdx*4]
$LN71@parse_fiel:
  002bd	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  002c1	49 89 43 08	 mov	 QWORD PTR [r11+8], rax

; 597  :                 if (c != ':') {

  002c5	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  002c8	74 23		 je	 SHORT $LN2@parse_fiel

; 598  :                     PyErr_SetString(PyExc_ValueError,
; 599  :                                     "expected ':' after format specifier");

  002ca	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  002d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@MBPIFJIB@expected?5?8?3?8?5after?5format?5specif@
  002d8	e8 00 00 00 00	 call	 PyErr_SetString

; 600  :                     return 0;

  002dd	33 c0		 xor	 eax, eax

; 610  : }

  002df	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002e3	5b		 pop	 rbx
  002e4	c3		 ret	 0
$LN68@parse_fiel:

; 601  :                 }
; 602  :             }
; 603  :         }
; 604  :     }
; 605  :     else
; 606  :         /* end of string, there's no format_spec or conversion */
; 607  :         field_name->end = str->start;

  002e5	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  002e9	49 89 41 10	 mov	 QWORD PTR [r9+16], rax
$LN2@parse_fiel:

; 608  : 
; 609  :     return 1;

  002ed	b8 01 00 00 00	 mov	 eax, 1

; 610  : }

  002f2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002f6	5b		 pop	 rbx
  002f7	c3		 ret	 0
parse_field ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT MarkupIterator_init
_TEXT	SEGMENT
self$ = 8
str$ = 16
start$ = 24
end$ = 32
MarkupIterator_init PROC				; COMDAT

; 629  :     SubString_init(&self->str, str, start, end);

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00003	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8
  00007	4c 89 49 10	 mov	 QWORD PTR [rcx+16], r9

; 630  :     return 1;

  0000b	b8 01 00 00 00	 mov	 eax, 1

; 631  : }

  00010	c3		 ret	 0
MarkupIterator_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@OIABGKOH@unmatched?5?8?$HL?8?5in?5format?$AA@ ; `string'
PUBLIC	??_C@_0CI@JIPCNBCB@Single?5?8?$HL?8?5encountered?5in?5format@ ; `string'
PUBLIC	??_C@_0CI@NBLNMGBO@Single?5?8?$HN?8?5encountered?5in?5format@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$MarkupIterator_next DD imagerel MarkupIterator_next
	DD	imagerel MarkupIterator_next+1221
	DD	imagerel $unwind$MarkupIterator_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MarkupIterator_next DD 0c1c01H
	DD	010641cH
	DD	0f541cH
	DD	0e341cH
	DD	0f018721cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT ??_C@_0BI@OIABGKOH@unmatched?5?8?$HL?8?5in?5format?$AA@
CONST	SEGMENT
??_C@_0BI@OIABGKOH@unmatched?5?8?$HL?8?5in?5format?$AA@ DB 'unmatched ''{'
	DB	''' in format', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JIPCNBCB@Single?5?8?$HL?8?5encountered?5in?5format@
CONST	SEGMENT
??_C@_0CI@JIPCNBCB@Single?5?8?$HL?8?5encountered?5in?5format@ DB 'Single '
	DB	'''{'' encountered in format string', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NBLNMGBO@Single?5?8?$HN?8?5encountered?5in?5format@
CONST	SEGMENT
??_C@_0CI@NBLNMGBO@Single?5?8?$HN?8?5encountered?5in?5format@ DB 'Single '
	DB	'''}'' encountered in format string', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT MarkupIterator_next
_TEXT	SEGMENT
s$142363 = 32
self$ = 112
literal$ = 120
field_present$ = 128
field_name$ = 136
format_spec$ = 144
conversion$ = 152
format_spec_needs_expanding$ = 160
MarkupIterator_next PROC				; COMDAT

; 640  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 641  :     int at_end, hit_format_spec;
; 642  :     Py_UCS4 c = 0;
; 643  :     Py_ssize_t start;
; 644  :     int count;
; 645  :     Py_ssize_t len;
; 646  :     int markup_follows = 0;
; 647  : 
; 648  :     /* initialize all of the output variables */
; 649  :     SubString_init(literal, NULL, 0, 0);
; 650  :     SubString_init(field_name, NULL, 0, 0);
; 651  :     SubString_init(format_spec, NULL, 0, 0);

  0001c	4c 8b bc 24 90
	00 00 00	 mov	 r15, QWORD PTR format_spec$[rsp]

; 652  :     *conversion = '\0';

  00024	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR conversion$[rsp]

; 653  :     *format_spec_needs_expanding = 0;

  0002c	4c 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR format_spec_needs_expanding$[rsp]
  00034	33 db		 xor	 ebx, ebx
  00036	4d 8b f1	 mov	 r14, r9
  00039	4d 8b e0	 mov	 r12, r8
  0003c	48 89 1a	 mov	 QWORD PTR [rdx], rbx
  0003f	48 89 5a 08	 mov	 QWORD PTR [rdx+8], rbx
  00043	48 89 5a 10	 mov	 QWORD PTR [rdx+16], rbx
  00047	49 89 19	 mov	 QWORD PTR [r9], rbx
  0004a	49 89 59 08	 mov	 QWORD PTR [r9+8], rbx
  0004e	49 89 59 10	 mov	 QWORD PTR [r9+16], rbx
  00052	49 89 1f	 mov	 QWORD PTR [r15], rbx
  00055	49 89 5f 08	 mov	 QWORD PTR [r15+8], rbx
  00059	49 89 5f 10	 mov	 QWORD PTR [r15+16], rbx
  0005d	89 18		 mov	 DWORD PTR [rax], ebx
  0005f	41 89 5d 00	 mov	 DWORD PTR [r13], ebx

; 654  :     *field_present = 0;

  00063	41 89 18	 mov	 DWORD PTR [r8], ebx

; 655  : 
; 656  :     /* No more input, end of iterator.  This is the normal exit
; 657  :        path. */
; 658  :     if (self->str.start >= self->str.end)

  00066	48 8b 71 08	 mov	 rsi, QWORD PTR [rcx+8]
  0006a	4c 8b 59 10	 mov	 r11, QWORD PTR [rcx+16]
  0006e	48 8b fa	 mov	 rdi, rdx
  00071	4c 8b d1	 mov	 r10, rcx
  00074	8b eb		 mov	 ebp, ebx
  00076	49 3b f3	 cmp	 rsi, r11
  00079	7c 08		 jl	 SHORT $LN25@MarkupIter

; 659  :         return 1;

  0007b	8d 43 01	 lea	 eax, QWORD PTR [rbx+1]
  0007e	e9 22 04 00 00	 jmp	 $LN26@MarkupIter
$LN25@MarkupIter:
  00083	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00086	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL24@MarkupIter:

; 671  :         switch (c = PyUnicode_READ_CHAR(self->str.str, self->str.start++)) {

  00090	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00093	8b d0		 mov	 edx, eax
  00095	c1 ea 02	 shr	 edx, 2
  00098	83 e2 07	 and	 edx, 7
  0009b	83 fa 01	 cmp	 edx, 1
  0009e	75 41		 jne	 SHORT $LN42@MarkupIter
  000a0	a8 20		 test	 al, 32			; 00000020H
  000a2	74 2b		 je	 SHORT $LN30@MarkupIter
  000a4	a8 40		 test	 al, 64			; 00000040H
  000a6	74 15		 je	 SHORT $LN28@MarkupIter
  000a8	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  000ac	48 8d 91 80 00
	00 00		 lea	 rdx, QWORD PTR [rcx+128]
  000b3	44 0f b6 0c 10	 movzx	 r9d, BYTE PTR [rax+rdx]
  000b8	e9 90 00 00 00	 jmp	 $LN105@MarkupIter
$LN28@MarkupIter:
  000bd	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  000c1	48 8d 91 a0 00
	00 00		 lea	 rdx, QWORD PTR [rcx+160]
  000c8	44 0f b6 0c 10	 movzx	 r9d, BYTE PTR [rax+rdx]
  000cd	eb 7e		 jmp	 SHORT $LN105@MarkupIter
$LN30@MarkupIter:
  000cf	48 8b 91 a0 00
	00 00		 mov	 rdx, QWORD PTR [rcx+160]
  000d6	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  000da	44 0f b6 0c 10	 movzx	 r9d, BYTE PTR [rax+rdx]
  000df	eb 6c		 jmp	 SHORT $LN105@MarkupIter
$LN42@MarkupIter:
  000e1	83 fa 02	 cmp	 edx, 2
  000e4	75 3e		 jne	 SHORT $LN40@MarkupIter
  000e6	a8 20		 test	 al, 32			; 00000020H
  000e8	74 28		 je	 SHORT $LN34@MarkupIter
  000ea	a8 40		 test	 al, 64			; 00000040H
  000ec	74 12		 je	 SHORT $LN32@MarkupIter
  000ee	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  000f2	48 8d 91 80 00
	00 00		 lea	 rdx, QWORD PTR [rcx+128]
  000f9	44 0f b7 0c 42	 movzx	 r9d, WORD PTR [rdx+rax*2]
  000fe	eb 4d		 jmp	 SHORT $LN105@MarkupIter
$LN32@MarkupIter:
  00100	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  00104	48 8d 91 a0 00
	00 00		 lea	 rdx, QWORD PTR [rcx+160]
  0010b	44 0f b7 0c 42	 movzx	 r9d, WORD PTR [rdx+rax*2]
  00110	eb 3b		 jmp	 SHORT $LN105@MarkupIter
$LN34@MarkupIter:
  00112	48 8b 91 a0 00
	00 00		 mov	 rdx, QWORD PTR [rcx+160]
  00119	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  0011d	44 0f b7 0c 42	 movzx	 r9d, WORD PTR [rdx+rax*2]
  00122	eb 29		 jmp	 SHORT $LN105@MarkupIter
$LN40@MarkupIter:
  00124	a8 20		 test	 al, 32			; 00000020H
  00126	74 16		 je	 SHORT $LN38@MarkupIter
  00128	a8 40		 test	 al, 64			; 00000040H
  0012a	74 09		 je	 SHORT $LN36@MarkupIter
  0012c	48 8d 91 80 00
	00 00		 lea	 rdx, QWORD PTR [rcx+128]
  00133	eb 10		 jmp	 SHORT $LN39@MarkupIter
$LN36@MarkupIter:
  00135	48 8d 91 a0 00
	00 00		 lea	 rdx, QWORD PTR [rcx+160]
  0013c	eb 07		 jmp	 SHORT $LN39@MarkupIter
$LN38@MarkupIter:
  0013e	48 8b 91 a0 00
	00 00		 mov	 rdx, QWORD PTR [rcx+160]
$LN39@MarkupIter:
  00145	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  00149	44 8b 0c 82	 mov	 r9d, DWORD PTR [rdx+rax*4]
$LN105@MarkupIter:
  0014d	4c 8d 40 01	 lea	 r8, QWORD PTR [rax+1]
  00151	4d 89 42 08	 mov	 QWORD PTR [r10+8], r8
  00155	41 83 f9 7b	 cmp	 r9d, 123		; 0000007bH
  00159	74 11		 je	 SHORT $LN20@MarkupIter
  0015b	41 83 f9 7d	 cmp	 r9d, 125		; 0000007dH
  0015f	74 0b		 je	 SHORT $LN20@MarkupIter

; 660  : 
; 661  :     start = self->str.start;
; 662  : 
; 663  :     /* First read any literal text. Read until the end of string, an
; 664  :        escaped '{' or '}', or an unescaped '{'.  In order to never
; 665  :        allocate memory and so I can just pass pointers around, if
; 666  :        there's an escaped '{' or '}' then we'll return the literal
; 667  :        including the brace, but no format object.  The next time
; 668  :        through, we'll return the rest of the literal, skipping past
; 669  :        the second consecutive brace. */
; 670  :     while (self->str.start < self->str.end) {

  00161	4d 3b c3	 cmp	 r8, r11
  00164	0f 8c 26 ff ff
	ff		 jl	 $LL24@MarkupIter

; 744  :             if (count <= 0) {

  0016a	eb 05		 jmp	 SHORT $LN21@MarkupIter
$LN20@MarkupIter:

; 672  :         case '{':
; 673  :         case '}':
; 674  :             markup_follows = 1;

  0016c	bd 01 00 00 00	 mov	 ebp, 1
$LN21@MarkupIter:

; 675  :             break;
; 676  :         default:
; 677  :             continue;
; 678  :         }
; 679  :         break;
; 680  :     }
; 681  : 
; 682  :     at_end = self->str.start >= self->str.end;

  00171	4d 3b c3	 cmp	 r8, r11

; 683  :     len = self->str.start - start;

  00174	4d 8b d8	 mov	 r11, r8
  00177	8b c3		 mov	 eax, ebx
  00179	0f 9d c0	 setge	 al
  0017c	4c 2b de	 sub	 r11, rsi

; 684  : 
; 685  :     if ((c == '}') && (at_end ||
; 686  :                        (c != PyUnicode_READ_CHAR(self->str.str,
; 687  :                                                  self->str.start)))) {

  0017f	41 83 f9 7d	 cmp	 r9d, 125		; 0000007dH
  00183	0f 85 b7 00 00
	00		 jne	 $LN18@MarkupIter
  00189	85 c0		 test	 eax, eax
  0018b	0f 85 a3 00 00
	00		 jne	 $LN17@MarkupIter
  00191	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00194	8b d0		 mov	 edx, eax
  00196	c1 ea 02	 shr	 edx, 2
  00199	83 e2 07	 and	 edx, 7
  0019c	83 fa 01	 cmp	 edx, 1
  0019f	75 32		 jne	 SHORT $LN58@MarkupIter
  001a1	a8 20		 test	 al, 32			; 00000020H
  001a3	74 20		 je	 SHORT $LN46@MarkupIter
  001a5	a8 40		 test	 al, 64			; 00000040H
  001a7	74 0e		 je	 SHORT $LN44@MarkupIter
  001a9	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  001b0	41 0f b6 14 00	 movzx	 edx, BYTE PTR [r8+rax]
  001b5	eb 78		 jmp	 SHORT $LN57@MarkupIter
$LN44@MarkupIter:
  001b7	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  001be	41 0f b6 14 00	 movzx	 edx, BYTE PTR [r8+rax]
  001c3	eb 6a		 jmp	 SHORT $LN57@MarkupIter
$LN46@MarkupIter:
  001c5	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
  001cc	41 0f b6 14 00	 movzx	 edx, BYTE PTR [r8+rax]
  001d1	eb 5c		 jmp	 SHORT $LN57@MarkupIter
$LN58@MarkupIter:
  001d3	83 fa 02	 cmp	 edx, 2
  001d6	75 32		 jne	 SHORT $LN56@MarkupIter
  001d8	a8 20		 test	 al, 32			; 00000020H
  001da	74 20		 je	 SHORT $LN50@MarkupIter
  001dc	a8 40		 test	 al, 64			; 00000040H
  001de	74 0e		 je	 SHORT $LN48@MarkupIter
  001e0	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  001e7	42 0f b7 14 40	 movzx	 edx, WORD PTR [rax+r8*2]
  001ec	eb 41		 jmp	 SHORT $LN57@MarkupIter
$LN48@MarkupIter:
  001ee	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  001f5	42 0f b7 14 40	 movzx	 edx, WORD PTR [rax+r8*2]
  001fa	eb 33		 jmp	 SHORT $LN57@MarkupIter
$LN50@MarkupIter:
  001fc	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
  00203	42 0f b7 14 40	 movzx	 edx, WORD PTR [rax+r8*2]
  00208	eb 25		 jmp	 SHORT $LN57@MarkupIter
$LN56@MarkupIter:
  0020a	a8 20		 test	 al, 32			; 00000020H
  0020c	74 16		 je	 SHORT $LN54@MarkupIter
  0020e	a8 40		 test	 al, 64			; 00000040H
  00210	74 09		 je	 SHORT $LN52@MarkupIter
  00212	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  00219	eb 10		 jmp	 SHORT $LN55@MarkupIter
$LN52@MarkupIter:
  0021b	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  00222	eb 07		 jmp	 SHORT $LN55@MarkupIter
$LN54@MarkupIter:
  00224	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
$LN55@MarkupIter:
  0022b	42 8b 14 80	 mov	 edx, DWORD PTR [rax+r8*4]
$LN57@MarkupIter:
  0022f	83 fa 7d	 cmp	 edx, 125		; 0000007dH
  00232	74 26		 je	 SHORT $LN103@MarkupIter
$LN17@MarkupIter:

; 688  :         PyErr_SetString(PyExc_ValueError, "Single '}' encountered "
; 689  :                         "in format string");

  00234	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@NBLNMGBO@Single?5?8?$HN?8?5encountered?5in?5format@

; 690  :         return 0;

  0023b	e9 57 02 00 00	 jmp	 $LN106@MarkupIter
$LN18@MarkupIter:

; 691  :     }
; 692  :     if (at_end && c == '{') {

  00240	85 c0		 test	 eax, eax
  00242	74 16		 je	 SHORT $LN103@MarkupIter
  00244	41 83 f9 7b	 cmp	 r9d, 123		; 0000007bH
  00248	0f 85 be 00 00
	00		 jne	 $LN13@MarkupIter

; 693  :         PyErr_SetString(PyExc_ValueError, "Single '{' encountered "
; 694  :                         "in format string");

  0024e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@JIPCNBCB@Single?5?8?$HL?8?5encountered?5in?5format@

; 695  :         return 0;

  00255	e9 3d 02 00 00	 jmp	 $LN106@MarkupIter
$LN103@MarkupIter:

; 696  :     }
; 697  :     if (!at_end) {
; 698  :         if (c == PyUnicode_READ_CHAR(self->str.str, self->str.start)) {

  0025a	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  0025d	8b d0		 mov	 edx, eax
  0025f	c1 ea 02	 shr	 edx, 2
  00262	83 e2 07	 and	 edx, 7
  00265	83 fa 01	 cmp	 edx, 1
  00268	75 32		 jne	 SHORT $LN74@MarkupIter
  0026a	a8 20		 test	 al, 32			; 00000020H
  0026c	74 20		 je	 SHORT $LN62@MarkupIter
  0026e	a8 40		 test	 al, 64			; 00000040H
  00270	74 0e		 je	 SHORT $LN60@MarkupIter
  00272	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  00279	41 0f b6 14 00	 movzx	 edx, BYTE PTR [r8+rax]
  0027e	eb 78		 jmp	 SHORT $LN73@MarkupIter
$LN60@MarkupIter:
  00280	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  00287	41 0f b6 14 00	 movzx	 edx, BYTE PTR [r8+rax]
  0028c	eb 6a		 jmp	 SHORT $LN73@MarkupIter
$LN62@MarkupIter:
  0028e	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
  00295	41 0f b6 14 00	 movzx	 edx, BYTE PTR [r8+rax]
  0029a	eb 5c		 jmp	 SHORT $LN73@MarkupIter
$LN74@MarkupIter:
  0029c	83 fa 02	 cmp	 edx, 2
  0029f	75 32		 jne	 SHORT $LN72@MarkupIter
  002a1	a8 20		 test	 al, 32			; 00000020H
  002a3	74 20		 je	 SHORT $LN66@MarkupIter
  002a5	a8 40		 test	 al, 64			; 00000040H
  002a7	74 0e		 je	 SHORT $LN64@MarkupIter
  002a9	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  002b0	42 0f b7 14 40	 movzx	 edx, WORD PTR [rax+r8*2]
  002b5	eb 41		 jmp	 SHORT $LN73@MarkupIter
$LN64@MarkupIter:
  002b7	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  002be	42 0f b7 14 40	 movzx	 edx, WORD PTR [rax+r8*2]
  002c3	eb 33		 jmp	 SHORT $LN73@MarkupIter
$LN66@MarkupIter:
  002c5	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
  002cc	42 0f b7 14 40	 movzx	 edx, WORD PTR [rax+r8*2]
  002d1	eb 25		 jmp	 SHORT $LN73@MarkupIter
$LN72@MarkupIter:
  002d3	a8 20		 test	 al, 32			; 00000020H
  002d5	74 16		 je	 SHORT $LN70@MarkupIter
  002d7	a8 40		 test	 al, 64			; 00000040H
  002d9	74 09		 je	 SHORT $LN68@MarkupIter
  002db	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  002e2	eb 10		 jmp	 SHORT $LN71@MarkupIter
$LN68@MarkupIter:
  002e4	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  002eb	eb 07		 jmp	 SHORT $LN71@MarkupIter
$LN70@MarkupIter:
  002ed	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
$LN71@MarkupIter:
  002f4	42 8b 14 80	 mov	 edx, DWORD PTR [rax+r8*4]
$LN73@MarkupIter:
  002f8	44 3b ca	 cmp	 r9d, edx
  002fb	75 0c		 jne	 SHORT $LN14@MarkupIter

; 699  :             /* escaped } or {, skip it in the input.  there is no
; 700  :                markup object following us, just this literal text */
; 701  :             self->str.start++;

  002fd	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]

; 702  :             markup_follows = 0;

  00301	8b eb		 mov	 ebp, ebx
  00303	49 89 42 08	 mov	 QWORD PTR [r10+8], rax

; 703  :         }
; 704  :         else

  00307	eb 03		 jmp	 SHORT $LN13@MarkupIter
$LN14@MarkupIter:

; 705  :             len--;

  00309	49 ff cb	 dec	 r11
$LN13@MarkupIter:

; 706  :     }
; 707  : 
; 708  :     /* record the literal text */
; 709  :     literal->str = self->str.str;
; 710  :     literal->start = start;
; 711  :     literal->end = start + len;

  0030c	49 8d 04 33	 lea	 rax, QWORD PTR [r11+rsi]
  00310	48 89 0f	 mov	 QWORD PTR [rdi], rcx
  00313	48 89 77 08	 mov	 QWORD PTR [rdi+8], rsi
  00317	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 712  : 
; 713  :     if (!markup_follows)

  0031b	85 ed		 test	 ebp, ebp
  0031d	75 08		 jne	 SHORT $LN12@MarkupIter

; 714  :         return 2;

  0031f	8d 45 02	 lea	 eax, QWORD PTR [rbp+2]
  00322	e9 7e 01 00 00	 jmp	 $LN26@MarkupIter
$LN12@MarkupIter:

; 715  : 
; 716  :     /* this is markup, find the end of the string by counting nested
; 717  :        braces.  note that this prohibits escaped braces, so that
; 718  :        format_specs cannot have braces in them. */
; 719  :     *field_present = 1;

  00327	41 c7 04 24 01
	00 00 00	 mov	 DWORD PTR [r12], 1

; 720  :     count = 1;
; 721  : 
; 722  :     start = self->str.start;

  0032f	4d 8b 4a 08	 mov	 r9, QWORD PTR [r10+8]
  00333	41 b8 01 00 00
	00		 mov	 r8d, 1

; 723  : 
; 724  :     /* we know we can't have a zero length string, so don't worry
; 725  :        about that case */
; 726  :     hit_format_spec = 0;
; 727  :     while (self->str.start < self->str.end) {

  00339	4d 3b 4a 10	 cmp	 r9, QWORD PTR [r10+16]
  0033d	0f 8d 4d 01 00
	00		 jge	 $LN104@MarkupIter
  00343	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL11@MarkupIter:

; 728  :         switch (c = PyUnicode_READ_CHAR(self->str.str, self->str.start++)) {

  00350	49 8b 02	 mov	 rax, QWORD PTR [r10]
  00353	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  00356	8b d1		 mov	 edx, ecx
  00358	c1 ea 02	 shr	 edx, 2
  0035b	83 e2 07	 and	 edx, 7
  0035e	83 fa 01	 cmp	 edx, 1
  00361	75 40		 jne	 SHORT $LN90@MarkupIter
  00363	f6 c1 20	 test	 cl, 32			; 00000020H
  00366	74 2a		 je	 SHORT $LN78@MarkupIter
  00368	f6 c1 40	 test	 cl, 64			; 00000040H
  0036b	74 14		 je	 SHORT $LN76@MarkupIter
  0036d	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  00374	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  00378	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  0037c	e9 8e 00 00 00	 jmp	 $LN107@MarkupIter
$LN76@MarkupIter:
  00381	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  00388	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  0038c	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00390	eb 7d		 jmp	 SHORT $LN107@MarkupIter
$LN78@MarkupIter:
  00392	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  00399	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  0039d	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  003a1	eb 6c		 jmp	 SHORT $LN107@MarkupIter
$LN90@MarkupIter:
  003a3	83 fa 02	 cmp	 edx, 2
  003a6	75 3d		 jne	 SHORT $LN88@MarkupIter
  003a8	f6 c1 20	 test	 cl, 32			; 00000020H
  003ab	74 27		 je	 SHORT $LN82@MarkupIter
  003ad	f6 c1 40	 test	 cl, 64			; 00000040H
  003b0	74 11		 je	 SHORT $LN80@MarkupIter
  003b2	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  003b9	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  003bd	0f b7 0c 41	 movzx	 ecx, WORD PTR [rcx+rax*2]
  003c1	eb 4c		 jmp	 SHORT $LN107@MarkupIter
$LN80@MarkupIter:
  003c3	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  003ca	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  003ce	0f b7 0c 41	 movzx	 ecx, WORD PTR [rcx+rax*2]
  003d2	eb 3b		 jmp	 SHORT $LN107@MarkupIter
$LN82@MarkupIter:
  003d4	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  003db	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  003df	0f b7 0c 41	 movzx	 ecx, WORD PTR [rcx+rax*2]
  003e3	eb 2a		 jmp	 SHORT $LN107@MarkupIter
$LN88@MarkupIter:
  003e5	f6 c1 20	 test	 cl, 32			; 00000020H
  003e8	74 17		 je	 SHORT $LN86@MarkupIter
  003ea	f6 c1 40	 test	 cl, 64			; 00000040H
  003ed	74 09		 je	 SHORT $LN84@MarkupIter
  003ef	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  003f6	eb 10		 jmp	 SHORT $LN87@MarkupIter
$LN84@MarkupIter:
  003f8	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  003ff	eb 07		 jmp	 SHORT $LN87@MarkupIter
$LN86@MarkupIter:
  00401	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
$LN87@MarkupIter:
  00408	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  0040c	8b 0c 81	 mov	 ecx, DWORD PTR [rcx+rax*4]
$LN107@MarkupIter:
  0040f	48 8d 50 01	 lea	 rdx, QWORD PTR [rax+1]
  00413	49 89 52 08	 mov	 QWORD PTR [r10+8], rdx
  00417	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  0041a	74 5a		 je	 SHORT $LN7@MarkupIter
  0041c	83 f9 7b	 cmp	 ecx, 123		; 0000007bH
  0041f	74 44		 je	 SHORT $LN5@MarkupIter
  00421	83 f9 7d	 cmp	 ecx, 125		; 0000007dH
  00424	75 5c		 jne	 SHORT $LN6@MarkupIter

; 742  :         case '}':
; 743  :             count--;

  00426	41 ff c8	 dec	 r8d

; 744  :             if (count <= 0) {

  00429	45 85 c0	 test	 r8d, r8d
  0042c	7f 54		 jg	 SHORT $LN6@MarkupIter

; 745  :                 /* we're done.  parse and get out */
; 746  :                 SubString s;
; 747  : 
; 748  :                 SubString_init(&s, self->str.str, start, self->str.start - 1);

  0042e	49 8b 02	 mov	 rax, QWORD PTR [r10]
  00431	4c 89 4c 24 28	 mov	 QWORD PTR s$142363[rsp+8], r9

; 749  :                 if (parse_field(&s, field_name, format_spec, conversion) == 0)

  00436	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR conversion$[rsp]
  0043e	48 89 44 24 20	 mov	 QWORD PTR s$142363[rsp], rax
  00443	48 8d 42 ff	 lea	 rax, QWORD PTR [rdx-1]
  00447	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$142363[rsp]
  0044c	4d 8b c7	 mov	 r8, r15
  0044f	49 8b d6	 mov	 rdx, r14
  00452	48 89 44 24 30	 mov	 QWORD PTR s$142363[rsp+16], rax
  00457	e8 00 00 00 00	 call	 parse_field
  0045c	f7 d8		 neg	 eax
  0045e	1b c0		 sbb	 eax, eax
  00460	83 e0 02	 and	 eax, 2

; 750  :                     return 0;
; 751  : 
; 752  :                 /* success */
; 753  :                 return 2;

  00463	eb 40		 jmp	 SHORT $LN26@MarkupIter
$LN5@MarkupIter:

; 733  :             }
; 734  :             break;
; 735  :         case '{':
; 736  :             /* the format spec needs to be recursively expanded.
; 737  :                this is an optimization, and not strictly needed */
; 738  :             if (hit_format_spec)

  00465	85 db		 test	 ebx, ebx
  00467	74 08		 je	 SHORT $LN4@MarkupIter

; 739  :                 *format_spec_needs_expanding = 1;

  00469	41 c7 45 00 01
	00 00 00	 mov	 DWORD PTR [r13], 1
$LN4@MarkupIter:

; 740  :             count++;

  00471	41 ff c0	 inc	 r8d

; 741  :             break;

  00474	eb 0c		 jmp	 SHORT $LN6@MarkupIter
$LN7@MarkupIter:

; 729  :         case ':':
; 730  :             if (!hit_format_spec) {

  00476	85 db		 test	 ebx, ebx
  00478	75 08		 jne	 SHORT $LN6@MarkupIter

; 731  :                 count = 1;
; 732  :                 hit_format_spec = 1;

  0047a	bb 01 00 00 00	 mov	 ebx, 1
  0047f	44 8b c3	 mov	 r8d, ebx
$LN6@MarkupIter:

; 723  : 
; 724  :     /* we know we can't have a zero length string, so don't worry
; 725  :        about that case */
; 726  :     hit_format_spec = 0;
; 727  :     while (self->str.start < self->str.end) {

  00482	49 8b 42 10	 mov	 rax, QWORD PTR [r10+16]
  00486	49 39 42 08	 cmp	 QWORD PTR [r10+8], rax
  0048a	0f 8c c0 fe ff
	ff		 jl	 $LL11@MarkupIter
$LN104@MarkupIter:

; 754  :             }
; 755  :             break;
; 756  :         }
; 757  :     }
; 758  : 
; 759  :     /* end of string while searching for matching '}' */
; 760  :     PyErr_SetString(PyExc_ValueError, "unmatched '{' in format");

  00490	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@OIABGKOH@unmatched?5?8?$HL?8?5in?5format?$AA@
$LN106@MarkupIter:
  00497	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0049e	e8 00 00 00 00	 call	 PyErr_SetString

; 761  :     return 0;

  004a3	33 c0		 xor	 eax, eax
$LN26@MarkupIter:

; 762  : }

  004a5	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  004aa	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  004af	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  004b7	48 83 c4 40	 add	 rsp, 64			; 00000040H
  004bb	41 5f		 pop	 r15
  004bd	41 5e		 pop	 r14
  004bf	41 5d		 pop	 r13
  004c1	41 5c		 pop	 r12
  004c3	5f		 pop	 rdi
  004c4	c3		 ret	 0
MarkupIterator_next ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@FGJDIPMO@Unknown?5conversion?5specifier?5?2x?$CF@ ; `string'
PUBLIC	??_C@_0CA@JNHKMKAP@Unknown?5conversion?5specifier?5?$CFc?$AA@ ; `string'
EXTRN	PyObject_ASCII:PROC
EXTRN	PyObject_Repr:PROC
EXTRN	PyObject_Str:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_conversion DD imagerel do_conversion
	DD	imagerel do_conversion+107
	DD	imagerel $unwind$do_conversion
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_conversion DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CC@FGJDIPMO@Unknown?5conversion?5specifier?5?2x?$CF@
CONST	SEGMENT
??_C@_0CC@FGJDIPMO@Unknown?5conversion?5specifier?5?2x?$CF@ DB 'Unknown c'
	DB	'onversion specifier \x%x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JNHKMKAP@Unknown?5conversion?5specifier?5?$CFc?$AA@
CONST	SEGMENT
??_C@_0CA@JNHKMKAP@Unknown?5conversion?5specifier?5?$CFc?$AA@ DB 'Unknown'
	DB	' conversion specifier %c', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT do_conversion
_TEXT	SEGMENT
obj$ = 48
conversion$ = 56
do_conversion PROC					; COMDAT

; 768  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 769  :     /* XXX in pre-3.0, do we need to convert this to unicode, since it
; 770  :        might have returned a string? */
; 771  :     switch (conversion) {

  00004	8b c2		 mov	 eax, edx
  00006	83 e8 61	 sub	 eax, 97			; 00000061H
  00009	74 57		 je	 SHORT $LN4@do_convers
  0000b	83 e8 11	 sub	 eax, 17
  0000e	74 49		 je	 SHORT $LN6@do_convers
  00010	ff c8		 dec	 eax
  00012	74 3c		 je	 SHORT $LN5@do_convers

; 772  :     case 'r':
; 773  :         return PyObject_Repr(obj);
; 774  :     case 's':
; 775  :         return PyObject_Str(obj);
; 776  :     case 'a':
; 777  :         return PyObject_ASCII(obj);
; 778  :     default:
; 779  :         if (conversion > 32 && conversion < 127) {
; 780  :                 /* It's the ASCII subrange; casting to char is safe
; 781  :                    (assuming the execution character set is an ASCII
; 782  :                    superset). */
; 783  :                 PyErr_Format(PyExc_ValueError,
; 784  :                      "Unknown conversion specifier %c",
; 785  :                      (char)conversion);

  00014	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0001b	8d 42 df	 lea	 eax, DWORD PTR [rdx-33]
  0001e	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  00021	77 17		 ja	 SHORT $LN2@do_convers
  00023	44 0f be c2	 movsx	 r8d, dl
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@JNHKMKAP@Unknown?5conversion?5specifier?5?$CFc?$AA@

; 786  :         } else
; 787  :                 PyErr_Format(PyExc_ValueError,
; 788  :                      "Unknown conversion specifier \\x%x",
; 789  :                      (unsigned int)conversion);

  0002e	e8 00 00 00 00	 call	 PyErr_Format

; 790  :         return NULL;

  00033	33 c0		 xor	 eax, eax

; 791  :     }
; 792  : }

  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
$LN2@do_convers:

; 786  :         } else
; 787  :                 PyErr_Format(PyExc_ValueError,
; 788  :                      "Unknown conversion specifier \\x%x",
; 789  :                      (unsigned int)conversion);

  0003a	44 8b c2	 mov	 r8d, edx
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@FGJDIPMO@Unknown?5conversion?5specifier?5?2x?$CF@
  00044	e8 00 00 00 00	 call	 PyErr_Format

; 790  :         return NULL;

  00049	33 c0		 xor	 eax, eax

; 791  :     }
; 792  : }

  0004b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004f	c3		 ret	 0
$LN5@do_convers:
  00050	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00054	e9 00 00 00 00	 jmp	 PyObject_Str
$LN6@do_convers:
  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	e9 00 00 00 00	 jmp	 PyObject_Repr
$LN4@do_convers:
  00062	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00066	e9 00 00 00 00	 jmp	 PyObject_ASCII
do_conversion ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$formatteriter_dealloc DD imagerel formatteriter_dealloc
	DD	imagerel formatteriter_dealloc+177
	DD	imagerel $unwind$formatteriter_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$formatteriter_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\unicode_format.h
xdata	ENDS
;	COMDAT formatteriter_dealloc
_TEXT	SEGMENT
it$ = 64
formatteriter_dealloc PROC				; COMDAT

; 994  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 995  :     Py_XDECREF(it->str);

  0000a	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 85 db	 test	 rbx, rbx
  00014	0f 84 85 00 00
	00		 je	 $LN3@formatteri
  0001a	e8 00 00 00 00	 call	 _Py_PXCTX
  0001f	85 c0		 test	 eax, eax
  00021	75 7c		 jne	 SHORT $LN3@formatteri
  00023	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00027	a8 20		 test	 al, 32			; 00000020H
  00029	75 6c		 jne	 SHORT $LN11@formatteri
  0002b	84 c0		 test	 al, al
  0002d	78 68		 js	 SHORT $LN11@formatteri
  0002f	a8 02		 test	 al, 2
  00031	75 6c		 jne	 SHORT $LN3@formatteri
  00033	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00037	75 66		 jne	 SHORT $LN3@formatteri
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00047	4c 8b cb	 mov	 r9, rbx
  0004a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00050	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00058	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005d	48 8b cb	 mov	 rcx, rbx
  00060	85 c0		 test	 eax, eax
  00062	74 17		 je	 SHORT $LN16@formatteri
  00064	e8 00 00 00 00	 call	 _Px_Dealloc

; 996  :     PyObject_FREE(it);

  00069	48 8b cf	 mov	 rcx, rdi

; 997  : }

  0006c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00071	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00075	5f		 pop	 rdi
  00076	e9 00 00 00 00	 jmp	 PyObject_Free

; 995  :     Py_XDECREF(it->str);

$LN16@formatteri:
  0007b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0007f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 996  :     PyObject_FREE(it);

  00085	48 8b cf	 mov	 rcx, rdi

; 997  : }

  00088	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0008d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00091	5f		 pop	 rdi
  00092	e9 00 00 00 00	 jmp	 PyObject_Free

; 995  :     Py_XDECREF(it->str);

$LN11@formatteri:
  00097	48 8b cb	 mov	 rcx, rbx
  0009a	e8 00 00 00 00	 call	 Px_DecRef
$LN3@formatteri:

; 996  :     PyObject_FREE(it);

  0009f	48 8b cf	 mov	 rcx, rdi

; 997  : }

  000a2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ab	5f		 pop	 rdi
  000ac	e9 00 00 00 00	 jmp	 PyObject_Free
formatteriter_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@FGOOKPBC@expected?5str?0?5got?5?$CFs?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$formatter_parser DD imagerel formatter_parser
	DD	imagerel formatter_parser+76
	DD	imagerel $unwind$formatter_parser
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$formatter_parser DD imagerel formatter_parser+76
	DD	imagerel formatter_parser+128
	DD	imagerel $chain$0$formatter_parser
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$formatter_parser DD imagerel formatter_parser+128
	DD	imagerel formatter_parser+173
	DD	imagerel $chain$2$formatter_parser
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$formatter_parser DD 020021H
	DD	067400H
	DD	imagerel formatter_parser
	DD	imagerel formatter_parser+76
	DD	imagerel $unwind$formatter_parser
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$formatter_parser DD 020521H
	DD	067405H
	DD	imagerel formatter_parser
	DD	imagerel formatter_parser+76
	DD	imagerel $unwind$formatter_parser
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$formatter_parser DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BF@FGOOKPBC@expected?5str?0?5got?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BF@FGOOKPBC@expected?5str?0?5got?5?$CFs?$AA@ DB 'expected str, got'
	DB	' %s', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT formatter_parser
_TEXT	SEGMENT
ignored$ = 48
self$ = 56
formatter_parser PROC					; COMDAT

; 1116 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1117 :     formatteriterobject *it;
; 1118 : 
; 1119 :     if (!PyUnicode_Check(self)) {

  00006	4c 8b 42 58	 mov	 r8, QWORD PTR [rdx+88]
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  00018	75 1f		 jne	 SHORT $LN3@formatter_

; 1120 :         PyErr_Format(PyExc_TypeError, "expected str, got %s", Py_TYPE(self)->tp_name);

  0001a	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0001e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@FGOOKPBC@expected?5str?0?5got?5?$CFs?$AA@
  0002c	e8 00 00 00 00	 call	 PyErr_Format
$LN12@formatter_:

; 1121 :         return NULL;

  00031	33 c0		 xor	 eax, eax

; 1138 : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5b		 pop	 rbx
  00038	c3		 ret	 0
$LN3@formatter_:

; 1122 :     }
; 1123 : 
; 1124 :     if (PyUnicode_READY(self) == -1)

  00039	f6 42 70 80	 test	 BYTE PTR [rdx+112], 128	; 00000080H
  0003d	75 0d		 jne	 SHORT $LN2@formatter_
  0003f	48 8b ca	 mov	 rcx, rdx
  00042	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00047	83 f8 ff	 cmp	 eax, -1

; 1125 :         return NULL;

  0004a	74 e5		 je	 SHORT $LN12@formatter_
$LN2@formatter_:
  0004c	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 1126 : 
; 1127 :     it = PyObject_New(formatteriterobject, &PyFormatterIter_Type);

  00051	e8 00 00 00 00	 call	 _Py_PXCTX
  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFormatterIter_Type
  0005d	85 c0		 test	 eax, eax
  0005f	74 07		 je	 SHORT $LN8@formatter_
  00061	e8 00 00 00 00	 call	 _PxObject_New
  00066	eb 05		 jmp	 SHORT $LN11@formatter_
$LN8@formatter_:
  00068	e8 00 00 00 00	 call	 _PyObject_New
$LN11@formatter_:
  0006d	48 8b f8	 mov	 rdi, rax

; 1128 :     if (it == NULL)

  00070	48 85 c0	 test	 rax, rax
  00073	75 0b		 jne	 SHORT $LN1@formatter_
  00075	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1138 : }

  0007a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007e	5b		 pop	 rbx
  0007f	c3		 ret	 0
$LN1@formatter_:

; 1129 :         return NULL;
; 1130 : 
; 1131 :     /* take ownership, give the object to the iterator */
; 1132 :     Py_INCREF(self);

  00080	48 8b cb	 mov	 rcx, rbx
  00083	e8 00 00 00 00	 call	 _Py_IncRef

; 1133 :     it->str = self;

  00088	48 89 5f 60	 mov	 QWORD PTR [rdi+96], rbx

; 1134 : 
; 1135 :     /* initialize the contained MarkupIterator */
; 1136 :     MarkupIterator_init(&it->it_markup, (PyObject*)self, 0, PyUnicode_GET_LENGTH(self));

  0008c	4c 8b 4b 60	 mov	 r9, QWORD PTR [rbx+96]
  00090	48 8d 4f 68	 lea	 rcx, QWORD PTR [rdi+104]
  00094	45 33 c0	 xor	 r8d, r8d
  00097	48 8b d3	 mov	 rdx, rbx
  0009a	e8 00 00 00 00	 call	 MarkupIterator_init

; 1137 :     return (PyObject *)it;

  0009f	48 8b c7	 mov	 rax, rdi
  000a2	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1138 : }

  000a7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ab	5b		 pop	 rbx
  000ac	c3		 ret	 0
formatter_parser ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$fieldnameiter_dealloc DD imagerel fieldnameiter_dealloc
	DD	imagerel fieldnameiter_dealloc+177
	DD	imagerel $unwind$fieldnameiter_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fieldnameiter_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\unicode_format.h
xdata	ENDS
;	COMDAT fieldnameiter_dealloc
_TEXT	SEGMENT
it$ = 64
fieldnameiter_dealloc PROC				; COMDAT

; 1158 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1159 :     Py_XDECREF(it->str);

  0000a	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 85 db	 test	 rbx, rbx
  00014	0f 84 85 00 00
	00		 je	 $LN3@fieldnamei
  0001a	e8 00 00 00 00	 call	 _Py_PXCTX
  0001f	85 c0		 test	 eax, eax
  00021	75 7c		 jne	 SHORT $LN3@fieldnamei
  00023	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00027	a8 20		 test	 al, 32			; 00000020H
  00029	75 6c		 jne	 SHORT $LN11@fieldnamei
  0002b	84 c0		 test	 al, al
  0002d	78 68		 js	 SHORT $LN11@fieldnamei
  0002f	a8 02		 test	 al, 2
  00031	75 6c		 jne	 SHORT $LN3@fieldnamei
  00033	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00037	75 66		 jne	 SHORT $LN3@fieldnamei
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00047	4c 8b cb	 mov	 r9, rbx
  0004a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00050	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00058	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005d	48 8b cb	 mov	 rcx, rbx
  00060	85 c0		 test	 eax, eax
  00062	74 17		 je	 SHORT $LN16@fieldnamei
  00064	e8 00 00 00 00	 call	 _Px_Dealloc

; 1160 :     PyObject_FREE(it);

  00069	48 8b cf	 mov	 rcx, rdi

; 1161 : }

  0006c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00071	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00075	5f		 pop	 rdi
  00076	e9 00 00 00 00	 jmp	 PyObject_Free

; 1159 :     Py_XDECREF(it->str);

$LN16@fieldnamei:
  0007b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0007f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 1160 :     PyObject_FREE(it);

  00085	48 8b cf	 mov	 rcx, rdi

; 1161 : }

  00088	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0008d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00091	5f		 pop	 rdi
  00092	e9 00 00 00 00	 jmp	 PyObject_Free

; 1159 :     Py_XDECREF(it->str);

$LN11@fieldnamei:
  00097	48 8b cb	 mov	 rcx, rbx
  0009a	e8 00 00 00 00	 call	 Px_DecRef
$LN3@fieldnamei:

; 1160 :     PyObject_FREE(it);

  0009f	48 8b cf	 mov	 rcx, rdi

; 1161 : }

  000a2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ab	5f		 pop	 rdi
  000ac	e9 00 00 00 00	 jmp	 PyObject_Free
fieldnameiter_dealloc ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
_TEXT	ENDS
;	COMDAT unicode__sizeof__
_TEXT	SEGMENT
v$ = 8
unicode__sizeof__ PROC					; COMDAT

; 13093:     Py_ssize_t size;
; 13094: 
; 13095:     /* If it's a compact object, account for base structure +
; 13096:        character data. */
; 13097:     if (PyUnicode_IS_COMPACT_ASCII(v))

  00000	44 8b 59 70	 mov	 r11d, DWORD PTR [rcx+112]
  00004	48 8b d1	 mov	 rdx, rcx
  00007	45 8b d3	 mov	 r10d, r11d
  0000a	41 c1 ea 06	 shr	 r10d, 6
  0000e	41 83 e2 01	 and	 r10d, 1
  00012	74 1a		 je	 SHORT $LN7@unicode__s
  00014	45 8b c3	 mov	 r8d, r11d
  00017	41 c1 e8 05	 shr	 r8d, 5
  0001b	41 83 e0 01	 and	 r8d, 1
  0001f	74 0d		 je	 SHORT $LN7@unicode__s

; 13098:         size = sizeof(PyASCIIObject) + PyUnicode_GET_LENGTH(v) + 1;

  00021	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  00025	49 81 c1 81 00
	00 00		 add	 r9, 129			; 00000081H
  0002c	eb 54		 jmp	 SHORT $LN3@unicode__s
$LN7@unicode__s:

; 13099:     else if (PyUnicode_IS_COMPACT(v))

  0002e	45 8b c3	 mov	 r8d, r11d
  00031	41 c1 e8 05	 shr	 r8d, 5
  00035	41 83 e0 01	 and	 r8d, 1
  00039	74 1f		 je	 SHORT $LN5@unicode__s

; 13100:         size = sizeof(PyCompactUnicodeObject) +
; 13101:             (PyUnicode_GET_LENGTH(v) + 1) * PyUnicode_KIND(v);

  0003b	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  0003f	4d 8b cb	 mov	 r9, r11
  00042	49 c1 e9 02	 shr	 r9, 2
  00046	48 ff c0	 inc	 rax
  00049	41 83 e1 07	 and	 r9d, 7
  0004d	4c 0f af c8	 imul	 r9, rax
  00051	49 81 c1 a0 00
	00 00		 add	 r9, 160			; 000000a0H

; 13102:     else {

  00058	eb 28		 jmp	 SHORT $LN3@unicode__s
$LN5@unicode__s:

; 13103:         /* If it is a two-block object, account for base object, and
; 13104:            for character block if present. */
; 13105:         size = sizeof(PyUnicodeObject);
; 13106:         if (_PyUnicode_DATA_ANY(v))

  0005a	48 83 b9 a0 00
	00 00 00	 cmp	 QWORD PTR [rcx+160], 0
  00062	41 b9 b0 00 00
	00		 mov	 r9d, 176		; 000000b0H
  00068	74 18		 je	 SHORT $LN3@unicode__s

; 13107:             size += (PyUnicode_GET_LENGTH(v) + 1) *
; 13108:                 PyUnicode_KIND(v);

  0006a	48 8b 42 60	 mov	 rax, QWORD PTR [rdx+96]
  0006e	49 8b cb	 mov	 rcx, r11
  00071	48 c1 e9 02	 shr	 rcx, 2
  00075	48 ff c0	 inc	 rax
  00078	83 e1 07	 and	 ecx, 7
  0007b	48 0f af c8	 imul	 rcx, rax
  0007f	4c 03 c9	 add	 r9, rcx
$LN3@unicode__s:

; 13109:     }
; 13110:     /* If the wstr pointer is present, account for it unless it is shared
; 13111:        with the data pointer. Check if the data is not shared. */
; 13112:     if (_PyUnicode_HAS_WSTR_MEMORY(v))

  00082	48 8b 4a 78	 mov	 rcx, QWORD PTR [rdx+120]
  00086	48 85 c9	 test	 rcx, rcx
  00089	74 49		 je	 SHORT $LN2@unicode__s
  0008b	45 84 db	 test	 r11b, r11b
  0008e	79 28		 jns	 SHORT $LN28@unicode__s
  00090	45 85 c0	 test	 r8d, r8d
  00093	74 17		 je	 SHORT $LN12@unicode__s
  00095	45 85 d2	 test	 r10d, r10d
  00098	74 09		 je	 SHORT $LN10@unicode__s
  0009a	48 8d 82 80 00
	00 00		 lea	 rax, QWORD PTR [rdx+128]
  000a1	eb 10		 jmp	 SHORT $LN13@unicode__s
$LN10@unicode__s:
  000a3	48 8d 82 a0 00
	00 00		 lea	 rax, QWORD PTR [rdx+160]
  000aa	eb 07		 jmp	 SHORT $LN13@unicode__s
$LN12@unicode__s:
  000ac	48 8b 82 a0 00
	00 00		 mov	 rax, QWORD PTR [rdx+160]
$LN13@unicode__s:
  000b3	48 3b c8	 cmp	 rcx, rax
  000b6	74 1c		 je	 SHORT $LN2@unicode__s
$LN28@unicode__s:

; 13113:         size += (PyUnicode_WSTR_LENGTH(v) + 1) * sizeof(wchar_t);

  000b8	45 85 d2	 test	 r10d, r10d
  000bb	74 0b		 je	 SHORT $LN17@unicode__s
  000bd	45 85 c0	 test	 r8d, r8d
  000c0	74 06		 je	 SHORT $LN17@unicode__s
  000c2	48 8b 42 60	 mov	 rax, QWORD PTR [rdx+96]
  000c6	eb 07		 jmp	 SHORT $LN18@unicode__s
$LN17@unicode__s:
  000c8	48 8b 82 90 00
	00 00		 mov	 rax, QWORD PTR [rdx+144]
$LN18@unicode__s:
  000cf	4d 8d 4c 41 02	 lea	 r9, QWORD PTR [r9+rax*2+2]
$LN2@unicode__s:

; 13114:     if (_PyUnicode_HAS_UTF8_MEMORY(v))

  000d4	45 85 d2	 test	 r10d, r10d
  000d7	74 05		 je	 SHORT $LN19@unicode__s
  000d9	45 85 c0	 test	 r8d, r8d
  000dc	75 5b		 jne	 SHORT $LN1@unicode__s
$LN19@unicode__s:
  000de	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR [rdx+136]
  000e5	48 85 c9	 test	 rcx, rcx
  000e8	74 4f		 je	 SHORT $LN1@unicode__s
  000ea	45 85 c0	 test	 r8d, r8d
  000ed	74 17		 je	 SHORT $LN23@unicode__s
  000ef	45 85 d2	 test	 r10d, r10d
  000f2	74 09		 je	 SHORT $LN21@unicode__s
  000f4	48 8d 82 80 00
	00 00		 lea	 rax, QWORD PTR [rdx+128]
  000fb	eb 10		 jmp	 SHORT $LN24@unicode__s
$LN21@unicode__s:
  000fd	48 8d 82 a0 00
	00 00		 lea	 rax, QWORD PTR [rdx+160]
  00104	eb 07		 jmp	 SHORT $LN24@unicode__s
$LN23@unicode__s:
  00106	48 8b 82 a0 00
	00 00		 mov	 rax, QWORD PTR [rdx+160]
$LN24@unicode__s:
  0010d	48 3b c8	 cmp	 rcx, rax
  00110	74 27		 je	 SHORT $LN1@unicode__s

; 13115:         size += PyUnicode_UTF8_LENGTH(v) + 1;

  00112	45 85 d2	 test	 r10d, r10d
  00115	74 16		 je	 SHORT $LN26@unicode__s
  00117	45 85 c0	 test	 r8d, r8d
  0011a	74 11		 je	 SHORT $LN26@unicode__s
  0011c	48 8b 42 60	 mov	 rax, QWORD PTR [rdx+96]
  00120	4d 8d 4c 01 01	 lea	 r9, QWORD PTR [r9+rax+1]

; 13116: 
; 13117:     return PyLong_FromSsize_t(size);

  00125	49 8b c9	 mov	 rcx, r9

; 13118: }

  00128	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
$LN26@unicode__s:

; 13115:         size += PyUnicode_UTF8_LENGTH(v) + 1;

  0012d	48 8b 82 80 00
	00 00		 mov	 rax, QWORD PTR [rdx+128]
  00134	4d 8d 4c 01 01	 lea	 r9, QWORD PTR [r9+rax+1]
$LN1@unicode__s:

; 13116: 
; 13117:     return PyLong_FromSsize_t(size);

  00139	49 8b c9	 mov	 rcx, r9

; 13118: }

  0013c	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
unicode__sizeof__ ENDP
_TEXT	ENDS
PUBLIC	??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@			; `string'
EXTRN	_Py_BuildValue_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_getnewargs DD imagerel unicode_getnewargs
	DD	imagerel unicode_getnewargs+38
	DD	imagerel $unwind$unicode_getnewargs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_getnewargs DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@
CONST	SEGMENT
??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@ DB '(N)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_getnewargs
_TEXT	SEGMENT
v$ = 48
unicode_getnewargs PROC					; COMDAT

; 13125: {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 13126:     PyObject *copy = _PyUnicode_Copy(v);

  00004	e8 00 00 00 00	 call	 _PyUnicode_Copy

; 13127:     if (!copy)

  00009	48 85 c0	 test	 rax, rax
  0000c	75 05		 jne	 SHORT $LN1@unicode_ge@2

; 13130: }

  0000e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00012	c3		 ret	 0
$LN1@unicode_ge@2:

; 13128:         return NULL;
; 13129:     return Py_BuildValue("(N)", copy);

  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@
  0001a	48 8b d0	 mov	 rdx, rax

; 13130: }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	e9 00 00 00 00	 jmp	 _Py_BuildValue_SizeT
unicode_getnewargs ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@DEFPBIOL@not?5enough?5arguments?5for?5format?5@ ; `string'
EXTRN	PyTuple_GetItem:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$getnextarg DD imagerel getnextarg
	DD	imagerel getnextarg+70
	DD	imagerel $unwind$getnextarg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getnextarg DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CH@DEFPBIOL@not?5enough?5arguments?5for?5format?5@
CONST	SEGMENT
??_C@_0CH@DEFPBIOL@not?5enough?5arguments?5for?5format?5@ DB 'not enough '
	DB	'arguments for format string', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT getnextarg
_TEXT	SEGMENT
args$ = 48
arglen$ = 56
p_argidx$ = 64
getnextarg PROC						; COMDAT

; 13295: {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b ca	 mov	 r9, rdx

; 13296:     Py_ssize_t argidx = *p_argidx;

  00007	49 8b 10	 mov	 rdx, QWORD PTR [r8]

; 13297:     if (argidx < arglen) {

  0000a	49 3b d1	 cmp	 rdx, r9
  0000d	7d 1d		 jge	 SHORT $LN1@getnextarg

; 13298:         (*p_argidx)++;

  0000f	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  00013	49 89 00	 mov	 QWORD PTR [r8], rax

; 13299:         if (arglen < 0)

  00016	4d 85 c9	 test	 r9, r9
  00019	79 08		 jns	 SHORT $LN2@getnextarg

; 13300:             return args;

  0001b	48 8b c1	 mov	 rax, rcx

; 13307: }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
$LN2@getnextarg:
  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	e9 00 00 00 00	 jmp	 PyTuple_GetItem
$LN1@getnextarg:

; 13301:         else
; 13302:             return PyTuple_GetItem(args, argidx);
; 13303:     }
; 13304:     PyErr_SetString(PyExc_TypeError,
; 13305:                     "not enough arguments for format string");

  0002c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@DEFPBIOL@not?5enough?5arguments?5for?5format?5@
  0003a	e8 00 00 00 00	 call	 PyErr_SetString

; 13306:     return NULL;

  0003f	33 c0		 xor	 eax, eax

; 13307: }

  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
getnextarg ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
EXTRN	PyOS_double_to_string:PROC
EXTRN	PyFloat_AsDouble:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$formatfloat DD imagerel formatfloat
	DD	imagerel formatfloat+277
	DD	imagerel $unwind$formatfloat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$formatfloat DD 081401H
	DD	036814H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT formatfloat
_TEXT	SEGMENT
v$ = 80
flags$ = 88
prec$ = 96
type$ = 104
p_output$ = 112
writer$ = 120
formatfloat PROC					; COMDAT

; 13314: {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6
  00014	41 8b f1	 mov	 esi, r9d
  00017	41 8b d8	 mov	 ebx, r8d
  0001a	8b fa		 mov	 edi, edx

; 13315:     char *p;
; 13316:     double x;
; 13317:     Py_ssize_t len;
; 13318: 
; 13319:     x = PyFloat_AsDouble(v);

  0001c	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 13320:     if (x == -1.0 && PyErr_Occurred())

  00021	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00029	66 0f 28 f0	 movapd	 xmm6, xmm0
  0002d	7a 10		 jp	 SHORT $LN6@formatfloa
  0002f	75 0e		 jne	 SHORT $LN6@formatfloa
  00031	e8 00 00 00 00	 call	 PyErr_Occurred
  00036	48 85 c0	 test	 rax, rax

; 13321:         return -1;

  00039	0f 85 87 00 00
	00		 jne	 $LN13@formatfloa
$LN6@formatfloa:

; 13322: 
; 13323:     if (prec < 0)

  0003f	b8 06 00 00 00	 mov	 eax, 6
  00044	85 db		 test	 ebx, ebx

; 13324:         prec = 6;
; 13325: 
; 13326:     p = PyOS_double_to_string(x, type, prec,
; 13327:                               (flags & F_ALT) ? Py_DTSF_ALT : 0, NULL);

  00046	66 0f 28 c6	 movapd	 xmm0, xmm6
  0004a	0f 48 d8	 cmovs	 ebx, eax
  0004d	d1 ef		 shr	 edi, 1
  0004f	40 0f b6 d6	 movzx	 edx, sil
  00053	83 e7 04	 and	 edi, 4
  00056	44 8b c3	 mov	 r8d, ebx
  00059	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00062	44 8b cf	 mov	 r9d, edi
  00065	e8 00 00 00 00	 call	 PyOS_double_to_string
  0006a	48 8b f0	 mov	 rsi, rax

; 13328:     if (p == NULL)

  0006d	48 85 c0	 test	 rax, rax

; 13329:         return -1;

  00070	74 54		 je	 SHORT $LN13@formatfloa

; 13330:     len = strlen(p);

  00072	48 83 c9 ff	 or	 rcx, -1
  00076	33 c0		 xor	 eax, eax
  00078	48 8b fe	 mov	 rdi, rsi
  0007b	f2 ae		 repne scasb

; 13331:     if (writer) {

  0007d	48 8b 7c 24 78	 mov	 rdi, QWORD PTR writer$[rsp]
  00082	48 f7 d1	 not	 rcx
  00085	48 ff c9	 dec	 rcx
  00088	48 8b d9	 mov	 rbx, rcx
  0008b	48 85 ff	 test	 rdi, rdi
  0008e	74 53		 je	 SHORT $LN3@formatfloa

; 13332:         if (_PyUnicodeWriter_Prepare(writer, len, 127) == -1) {

  00090	83 7f 14 7f	 cmp	 DWORD PTR [rdi+20], 127	; 0000007fH
  00094	72 0d		 jb	 SHORT $LN9@formatfloa
  00096	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  0009a	48 2b 47 20	 sub	 rax, QWORD PTR [rdi+32]
  0009e	48 3b c8	 cmp	 rcx, rax
  000a1	7e 28		 jle	 SHORT $LN2@formatfloa
$LN9@formatfloa:
  000a3	48 85 c9	 test	 rcx, rcx
  000a6	74 23		 je	 SHORT $LN2@formatfloa
  000a8	48 8b d1	 mov	 rdx, rcx
  000ab	41 b8 7f 00 00
	00		 mov	 r8d, 127		; 0000007fH
  000b1	48 8b cf	 mov	 rcx, rdi
  000b4	e8 00 00 00 00	 call	 _PyUnicodeWriter_PrepareInternal
  000b9	83 f8 ff	 cmp	 eax, -1
  000bc	75 0d		 jne	 SHORT $LN2@formatfloa

; 13333:             PyMem_Free(p);

  000be	48 8b ce	 mov	 rcx, rsi
  000c1	e8 00 00 00 00	 call	 PyMem_Free
$LN13@formatfloa:

; 13334:             return -1;

  000c6	83 c8 ff	 or	 eax, -1
  000c9	eb 35		 jmp	 SHORT $LN7@formatfloa
$LN2@formatfloa:

; 13335:         }
; 13336:         unicode_write_cstr(writer->buffer, writer->pos, p, len);

  000cb	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  000cf	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  000d2	4c 8b cb	 mov	 r9, rbx
  000d5	4c 8b c6	 mov	 r8, rsi
  000d8	e8 00 00 00 00	 call	 unicode_write_cstr

; 13337:         writer->pos += len;

  000dd	48 01 5f 20	 add	 QWORD PTR [rdi+32], rbx

; 13338:     }
; 13339:     else

  000e1	eb 13		 jmp	 SHORT $LN1@formatfloa
$LN3@formatfloa:

; 13340:         *p_output = _PyUnicode_FromASCII(p, len);

  000e3	48 8b d1	 mov	 rdx, rcx
  000e6	48 8b ce	 mov	 rcx, rsi
  000e9	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  000ee	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p_output$[rsp]
  000f3	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN1@formatfloa:

; 13341:     PyMem_Free(p);

  000f6	48 8b ce	 mov	 rcx, rsi
  000f9	e8 00 00 00 00	 call	 PyMem_Free

; 13342:     return 0;

  000fe	33 c0		 xor	 eax, eax
$LN7@formatfloa:

; 13343: }

  00100	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00105	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0010a	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  0010f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00113	5f		 pop	 rdi
  00114	c3		 ret	 0
formatfloat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@OMLIIOLF@string?5too?5large?5in?5_PyBytes_For@ ; `string'
PUBLIC	??_C@_0BE@FKHOBKGP@precision?5too?5large?$AA@	; `string'
EXTRN	PyBool_Type:BYTE
EXTRN	PyNumber_ToBase:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$formatlong DD imagerel formatlong
	DD	imagerel formatlong+70
	DD	imagerel $unwind$formatlong
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$formatlong DD imagerel formatlong+70
	DD	imagerel formatlong+173
	DD	imagerel $chain$0$formatlong
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$formatlong DD imagerel formatlong+173
	DD	imagerel formatlong+294
	DD	imagerel $chain$3$formatlong
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$formatlong DD imagerel formatlong+294
	DD	imagerel formatlong+710
	DD	imagerel $chain$4$formatlong
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$formatlong DD imagerel formatlong+710
	DD	imagerel formatlong+733
	DD	imagerel $chain$5$formatlong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$formatlong DD 021H
	DD	imagerel formatlong+173
	DD	imagerel formatlong+294
	DD	imagerel $chain$3$formatlong
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$formatlong DD 020521H
	DD	0fd405H
	DD	imagerel formatlong+173
	DD	imagerel formatlong+294
	DD	imagerel $chain$3$formatlong
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$formatlong DD 042e21H
	DD	0d642eH
	DD	0c3400H
	DD	imagerel formatlong
	DD	imagerel formatlong+70
	DD	imagerel $unwind$formatlong
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$formatlong DD 020521H
	DD	0c3405H
	DD	imagerel formatlong
	DD	imagerel formatlong+70
	DD	imagerel $unwind$formatlong
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$formatlong DD 060d01H
	DD	0f009520dH
	DD	0c005e007H
	DD	050027003H
xdata	ENDS
;	COMDAT ??_C@_0CI@OMLIIOLF@string?5too?5large?5in?5_PyBytes_For@
CONST	SEGMENT
??_C@_0CI@OMLIIOLF@string?5too?5large?5in?5_PyBytes_For@ DB 'string too l'
	DB	'arge in _PyBytes_FormatLong', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FKHOBKGP@precision?5too?5large?$AA@
CONST	SEGMENT
??_C@_0BE@FKHOBKGP@precision?5too?5large?$AA@ DB 'precision too large', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT formatlong
_TEXT	SEGMENT
val$ = 96
flags$ = 104
tv639 = 112
prec$ = 112
type$ = 120
formatlong PROC						; COMDAT

; 13365: {

  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 56		 push	 r14
  00007	41 57		 push	 r15
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 13366:     PyObject *result = NULL;
; 13367:     char *buf;
; 13368:     Py_ssize_t i;
; 13369:     int sign;           /* 1 if '-', else 0 */
; 13370:     int len;            /* number of characters */
; 13371:     Py_ssize_t llen;
; 13372:     int numdigits;      /* len == numnondigits + numdigits */
; 13373:     int numnondigits = 0;

  0000d	33 ff		 xor	 edi, edi
  0000f	41 8b e9	 mov	 ebp, r9d
  00012	45 8b f0	 mov	 r14d, r8d
  00015	44 8b fa	 mov	 r15d, edx
  00018	44 8b e7	 mov	 r12d, edi

; 13374: 
; 13375:     /* Avoid exceeding SSIZE_T_MAX */
; 13376:     if (prec > INT_MAX-3) {

  0001b	41 81 f8 fc ff
	ff 7f		 cmp	 r8d, 2147483644		; 7ffffffcH
  00022	7e 22		 jle	 SHORT $LN33@formatlong

; 13377:         PyErr_SetString(PyExc_OverflowError,
; 13378:                         "precision too large");

  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@FKHOBKGP@precision?5too?5large?$AA@
  00032	e8 00 00 00 00	 call	 PyErr_SetString

; 13379:         return NULL;

  00037	33 c0		 xor	 eax, eax

; 13483: }

  00039	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003d	41 5f		 pop	 r15
  0003f	41 5e		 pop	 r14
  00041	41 5c		 pop	 r12
  00043	5f		 pop	 rdi
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
$LN33@formatlong:
  00046	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx

; 13380:     }
; 13381: 
; 13382:     assert(PyLong_Check(val));
; 13383: 
; 13384:     switch (type) {

  0004b	41 83 f9 58	 cmp	 r9d, 88			; 00000058H
  0004f	74 18		 je	 SHORT $LN26@formatlong
  00051	41 83 f9 64	 cmp	 r9d, 100		; 00000064H
  00055	74 5d		 je	 SHORT $LN30@formatlong
  00057	41 83 f9 6f	 cmp	 r9d, 111		; 0000006fH
  0005b	74 50		 je	 SHORT $LN27@formatlong
  0005d	41 83 f9 75	 cmp	 r9d, 117		; 00000075H
  00061	74 51		 je	 SHORT $LN30@formatlong
  00063	41 83 f9 78	 cmp	 r9d, 120		; 00000078H
  00067	75 30		 jne	 SHORT $LN59@formatlong
$LN26@formatlong:

; 13400:         result = PyNumber_ToBase(val, 16);

  00069	ba 10 00 00 00	 mov	 edx, 16
$LN63@formatlong:

; 13397:     case 'x':
; 13398:     case 'X':
; 13399:         numnondigits = 2;

  0006e	41 bc 02 00 00
	00		 mov	 r12d, 2
$LN64@formatlong:

; 13400:         result = PyNumber_ToBase(val, 16);

  00074	e8 00 00 00 00	 call	 PyNumber_ToBase
$LN65@formatlong:
  00079	48 8b d8	 mov	 rbx, rax

; 13401:         break;
; 13402:     default:
; 13403:         assert(!"'type' not in [duoxX]");
; 13404:     }
; 13405:     if (!result)

  0007c	48 85 c0	 test	 rax, rax

; 13406:         return NULL;

  0007f	74 18		 je	 SHORT $LN59@formatlong

; 13407: 
; 13408:     assert(unicode_modifiable(result));
; 13409:     assert(PyUnicode_IS_READY(result));
; 13410:     assert(PyUnicode_IS_ASCII(result));
; 13411: 
; 13412:     /* To modify the string in-place, there can only be one reference. */
; 13413:     if (Py_REFCNT(result) != 1) {

  00081	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  00086	74 4b		 je	 SHORT $LN23@formatlong

; 13414:         PyErr_BadInternalCall();

  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  0008f	ba 66 34 00 00	 mov	 edx, 13414		; 00003466H
  00094	e8 00 00 00 00	 call	 _PyErr_BadInternalCall
$LN59@formatlong:

; 13415:         return NULL;

  00099	33 c0		 xor	 eax, eax
  0009b	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 13483: }

  000a0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a4	41 5f		 pop	 r15
  000a6	41 5e		 pop	 r14
  000a8	41 5c		 pop	 r12
  000aa	5f		 pop	 rdi
  000ab	5d		 pop	 rbp
  000ac	c3		 ret	 0
$LN27@formatlong:

; 13393:     case 'o':
; 13394:         numnondigits = 2;
; 13395:         result = PyNumber_ToBase(val, 8);

  000ad	ba 08 00 00 00	 mov	 edx, 8

; 13396:         break;

  000b2	eb ba		 jmp	 SHORT $LN63@formatlong
$LN30@formatlong:

; 13385:     case 'd':
; 13386:     case 'u':
; 13387:         /* Special-case boolean: we want 0/1 */
; 13388:         if (PyBool_Check(val))

  000b4	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  000b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyBool_Type
  000bf	48 3b c2	 cmp	 rax, rdx
  000c2	75 07		 jne	 SHORT $LN29@formatlong

; 13389:             result = PyNumber_ToBase(val, 10);

  000c4	ba 0a 00 00 00	 mov	 edx, 10

; 13390:         else

  000c9	eb a9		 jmp	 SHORT $LN64@formatlong
$LN29@formatlong:

; 13391:             result = Py_TYPE(val)->tp_str(val);

  000cb	ff 90 e0 00 00
	00		 call	 QWORD PTR [rax+224]

; 13392:         break;

  000d1	eb a6		 jmp	 SHORT $LN65@formatlong
$LN23@formatlong:

; 13416:     }
; 13417:     buf = PyUnicode_DATA(result);

  000d3	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  000d6	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  000db	a8 20		 test	 al, 32			; 00000020H
  000dd	74 16		 je	 SHORT $LN38@formatlong
  000df	a8 40		 test	 al, 64			; 00000040H
  000e1	74 09		 je	 SHORT $LN36@formatlong
  000e3	48 8d b3 80 00
	00 00		 lea	 rsi, QWORD PTR [rbx+128]
  000ea	eb 10		 jmp	 SHORT $LN39@formatlong
$LN36@formatlong:
  000ec	48 8d b3 a0 00
	00 00		 lea	 rsi, QWORD PTR [rbx+160]
  000f3	eb 07		 jmp	 SHORT $LN39@formatlong
$LN38@formatlong:
  000f5	48 8b b3 a0 00
	00 00		 mov	 rsi, QWORD PTR [rbx+160]
$LN39@formatlong:

; 13418:     llen = PyUnicode_GET_LENGTH(result);

  000fc	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]

; 13419:     if (llen > INT_MAX) {

  00100	49 81 f8 ff ff
	ff 7f		 cmp	 r8, 2147483647		; 7fffffffH
  00107	7e 1a		 jle	 SHORT $LN22@formatlong

; 13420:         PyErr_SetString(PyExc_ValueError,
; 13421:                         "string too large in _PyBytes_FormatLong");

  00109	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00110	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@OMLIIOLF@string?5too?5large?5in?5_PyBytes_For@
  00117	e8 00 00 00 00	 call	 PyErr_SetString

; 13422:         return NULL;

  0011c	33 c0		 xor	 eax, eax
  0011e	e9 a3 01 00 00	 jmp	 $LN61@formatlong
$LN22@formatlong:

; 13423:     }
; 13424:     len = (int)llen;
; 13425:     sign = buf[0] == '-';

  00123	80 3e 2d	 cmp	 BYTE PTR [rsi], 45	; 0000002dH
  00126	4c 89 6c 24 78	 mov	 QWORD PTR [rsp+120], r13

; 13426:     numnondigits += sign;
; 13427:     numdigits = len - numnondigits;

  0012b	45 8b e8	 mov	 r13d, r8d
  0012e	40 0f 94 c7	 sete	 dil
  00132	44 03 e7	 add	 r12d, edi
  00135	45 2b ec	 sub	 r13d, r12d

; 13428:     assert(numdigits > 0);
; 13429: 
; 13430:     /* Get rid of base marker unless F_ALT */
; 13431:     if (((flags & F_ALT) == 0 &&
; 13432:         (type == 'o' || type == 'x' || type == 'X'))) {

  00138	41 f6 c7 08	 test	 r15b, 8
  0013c	75 22		 jne	 SHORT $LN19@formatlong
  0013e	83 fd 6f	 cmp	 ebp, 111		; 0000006fH
  00141	74 0a		 je	 SHORT $LN20@formatlong
  00143	83 fd 78	 cmp	 ebp, 120		; 00000078H
  00146	74 05		 je	 SHORT $LN20@formatlong
  00148	83 fd 58	 cmp	 ebp, 88			; 00000058H
  0014b	75 13		 jne	 SHORT $LN19@formatlong
$LN20@formatlong:

; 13433:         assert(buf[sign] == '0');
; 13434:         assert(buf[sign+1] == 'x' || buf[sign+1] == 'X' ||
; 13435:                buf[sign+1] == 'o');
; 13436:         numnondigits -= 2;

  0014d	41 83 ec 02	 sub	 r12d, 2

; 13437:         buf += 2;

  00151	48 83 c6 02	 add	 rsi, 2

; 13438:         len -= 2;

  00155	41 83 c0 fe	 add	 r8d, -2

; 13439:         if (sign)

  00159	85 ff		 test	 edi, edi
  0015b	74 03		 je	 SHORT $LN19@formatlong

; 13440:             buf[0] = '-';

  0015d	c6 06 2d	 mov	 BYTE PTR [rsi], 45	; 0000002dH
$LN19@formatlong:

; 13441:         assert(len == numnondigits + numdigits);
; 13442:         assert(numdigits > 0);
; 13443:     }
; 13444: 
; 13445:     /* Fill with leading zeroes to meet minimum width. */
; 13446:     if (prec > numdigits) {

  00160	45 3b f5	 cmp	 r14d, r13d
  00163	0f 8e 9d 00 00
	00		 jle	 $LN18@formatlong

; 13447:         PyObject *r1 = PyBytes_FromStringAndSize(NULL,
; 13448:                                 numnondigits + prec);

  00169	43 8d 04 34	 lea	 eax, DWORD PTR [r12+r14]
  0016d	33 c9		 xor	 ecx, ecx
  0016f	48 63 d0	 movsxd	 rdx, eax
  00172	89 44 24 70	 mov	 DWORD PTR tv639[rsp], eax
  00176	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0017b	4c 8b f8	 mov	 r15, rax

; 13449:         char *b1;
; 13450:         if (!r1) {

  0017e	48 85 c0	 test	 rax, rax
  00181	75 0f		 jne	 SHORT $LN17@formatlong

; 13451:             Py_DECREF(result);

  00183	48 8b cb	 mov	 rcx, rbx
  00186	e8 00 00 00 00	 call	 _Py_DecRef

; 13452:             return NULL;

  0018b	33 c0		 xor	 eax, eax
  0018d	e9 2f 01 00 00	 jmp	 $LN62@formatlong
$LN17@formatlong:

; 13453:         }
; 13454:         b1 = PyBytes_AS_STRING(r1);

  00192	48 83 c0 78	 add	 rax, 120		; 00000078H

; 13455:         for (i = 0; i < numnondigits; ++i)

  00196	49 63 cc	 movsxd	 rcx, r12d
  00199	48 8b f8	 mov	 rdi, rax
  0019c	45 85 e4	 test	 r12d, r12d
  0019f	7e 11		 jle	 SHORT $LN14@formatlong
$LL16@formatlong:

; 13456:             *b1++ = *buf++;

  001a1	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  001a4	48 ff c7	 inc	 rdi
  001a7	48 ff c6	 inc	 rsi
  001aa	48 ff c9	 dec	 rcx
  001ad	88 47 ff	 mov	 BYTE PTR [rdi-1], al
  001b0	75 ef		 jne	 SHORT $LL16@formatlong
$LN14@formatlong:

; 13457:         for (i = 0; i < prec - numdigits; i++)

  001b2	45 2b f5	 sub	 r14d, r13d
  001b5	4d 63 e6	 movsxd	 r12, r14d
  001b8	45 85 f6	 test	 r14d, r14d
  001bb	7e 10		 jle	 SHORT $LN13@formatlong
  001bd	4d 8b c4	 mov	 r8, r12
  001c0	b2 30		 mov	 dl, 48			; 00000030H
  001c2	48 8b cf	 mov	 rcx, rdi
  001c5	e8 00 00 00 00	 call	 memset
  001ca	49 03 fc	 add	 rdi, r12
$LN13@formatlong:

; 13458:             *b1++ = '0';
; 13459:         for (i = 0; i < numdigits; i++)

  001cd	49 63 cd	 movsxd	 rcx, r13d
  001d0	45 85 ed	 test	 r13d, r13d
  001d3	7e 1a		 jle	 SHORT $LN8@formatlong
  001d5	48 2b f7	 sub	 rsi, rdi
  001d8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL10@formatlong:

; 13460:             *b1++ = *buf++;

  001e0	0f b6 04 3e	 movzx	 eax, BYTE PTR [rsi+rdi]
  001e4	48 ff c7	 inc	 rdi
  001e7	48 ff c9	 dec	 rcx
  001ea	88 47 ff	 mov	 BYTE PTR [rdi-1], al
  001ed	75 f1		 jne	 SHORT $LL10@formatlong
$LN8@formatlong:

; 13461:         *b1 = '\0';
; 13462:         Py_DECREF(result);

  001ef	48 8b cb	 mov	 rcx, rbx
  001f2	c6 07 00	 mov	 BYTE PTR [rdi], 0
  001f5	e8 00 00 00 00	 call	 _Py_DecRef

; 13463:         result = r1;
; 13464:         buf = PyBytes_AS_STRING(result);
; 13465:         len = numnondigits + prec;

  001fa	44 8b 44 24 70	 mov	 r8d, DWORD PTR tv639[rsp]
  001ff	49 8b df	 mov	 rbx, r15
  00202	49 8d 77 78	 lea	 rsi, QWORD PTR [r15+120]
$LN18@formatlong:

; 13466:     }
; 13467: 
; 13468:     /* Fix up case for hex conversions. */
; 13469:     if (type == 'X') {

  00206	83 fd 58	 cmp	 ebp, 88			; 00000058H
  00209	75 22		 jne	 SHORT $LN4@formatlong

; 13470:         /* Need to convert all lower case letters to upper case.
; 13471:            and need to convert 0x to 0X (and -0x to -0X). */
; 13472:         for (i = 0; i < len; i++)

  0020b	49 63 d0	 movsxd	 rdx, r8d
  0020e	45 85 c0	 test	 r8d, r8d
  00211	7e 1a		 jle	 SHORT $LN4@formatlong
  00213	48 8b ce	 mov	 rcx, rsi
$LL6@formatlong:

; 13473:             if (buf[i] >= 'a' && buf[i] <= 'x')

  00216	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00219	3c 61		 cmp	 al, 97			; 00000061H
  0021b	7c 08		 jl	 SHORT $LN5@formatlong
  0021d	3c 78		 cmp	 al, 120			; 00000078H
  0021f	7f 04		 jg	 SHORT $LN5@formatlong

; 13474:                 buf[i] -= 'a'-'A';

  00221	2c 20		 sub	 al, 32			; 00000020H
  00223	88 01		 mov	 BYTE PTR [rcx], al
$LN5@formatlong:

; 13470:         /* Need to convert all lower case letters to upper case.
; 13471:            and need to convert 0x to 0X (and -0x to -0X). */
; 13472:         for (i = 0; i < len; i++)

  00225	48 ff c1	 inc	 rcx
  00228	48 ff ca	 dec	 rdx
  0022b	75 e9		 jne	 SHORT $LL6@formatlong
$LN4@formatlong:

; 13475:     }
; 13476:     if (!PyUnicode_Check(result) || len != PyUnicode_GET_LENGTH(result)) {

  0022d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00231	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0023b	74 09		 je	 SHORT $LN1@formatlong
  0023d	49 63 c0	 movsxd	 rax, r8d
  00240	48 3b 43 60	 cmp	 rax, QWORD PTR [rbx+96]
  00244	74 78		 je	 SHORT $LN2@formatlong
$LN1@formatlong:

; 13477:         PyObject *unicode;
; 13478:         unicode = _PyUnicode_FromASCII(buf, len);

  00246	49 63 d0	 movsxd	 rdx, r8d
  00249	48 8b ce	 mov	 rcx, rsi
  0024c	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  00251	48 8b f8	 mov	 rdi, rax

; 13479:         Py_DECREF(result);

  00254	e8 00 00 00 00	 call	 _Py_PXCTX
  00259	85 c0		 test	 eax, eax
  0025b	75 5e		 jne	 SHORT $LN50@formatlong
  0025d	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00261	f6 c1 20	 test	 cl, 32			; 00000020H
  00264	75 4d		 jne	 SHORT $LN44@formatlong
  00266	84 c9		 test	 cl, cl
  00268	78 49		 js	 SHORT $LN44@formatlong
  0026a	f6 c1 02	 test	 cl, 2
  0026d	75 4c		 jne	 SHORT $LN50@formatlong
  0026f	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00273	75 46		 jne	 SHORT $LN50@formatlong
  00275	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0027c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00283	4c 8b cb	 mov	 r9, rbx
  00286	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0028c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00294	e8 00 00 00 00	 call	 _PyParallel_Guard
  00299	48 8b cb	 mov	 rcx, rbx
  0029c	85 c0		 test	 eax, eax
  0029e	74 07		 je	 SHORT $LN49@formatlong
  002a0	e8 00 00 00 00	 call	 _Px_Dealloc
  002a5	eb 14		 jmp	 SHORT $LN50@formatlong
$LN49@formatlong:
  002a7	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  002ab	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002b1	eb 08		 jmp	 SHORT $LN50@formatlong
$LN44@formatlong:
  002b3	48 8b cb	 mov	 rcx, rbx
  002b6	e8 00 00 00 00	 call	 Px_DecRef
$LN50@formatlong:

; 13480:         result = unicode;

  002bb	48 8b df	 mov	 rbx, rdi
$LN2@formatlong:

; 13481:     }
; 13482:     return result;

  002be	48 8b c3	 mov	 rax, rbx
$LN62@formatlong:
  002c1	4c 8b 6c 24 78	 mov	 r13, QWORD PTR [rsp+120]
$LN61@formatlong:
  002c6	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  002cb	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 13483: }

  002d0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002d4	41 5f		 pop	 r15
  002d6	41 5e		 pop	 r14
  002d8	41 5c		 pop	 r12
  002da	5f		 pop	 rdi
  002db	5d		 pop	 rbp
  002dc	c3		 ret	 0
formatlong ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@CEOKNOOI@?$CFc?5arg?5not?5in?5range?$CI0x110000?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BI@CMHNDAIN@?$CFc?5requires?5int?5or?5char?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$formatchar DD imagerel formatchar
	DD	imagerel formatchar+284
	DD	imagerel $unwind$formatchar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$formatchar DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BO@CEOKNOOI@?$CFc?5arg?5not?5in?5range?$CI0x110000?$CJ?$AA@
CONST	SEGMENT
??_C@_0BO@CEOKNOOI@?$CFc?5arg?5not?5in?5range?$CI0x110000?$CJ?$AA@ DB '%c'
	DB	' arg not in range(0x110000)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CMHNDAIN@?$CFc?5requires?5int?5or?5char?$AA@
CONST	SEGMENT
??_C@_0BI@CMHNDAIN@?$CFc?5requires?5int?5or?5char?$AA@ DB '%c requires in'
	DB	't or char', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT formatchar
_TEXT	SEGMENT
v$ = 48
formatchar PROC						; COMDAT

; 13487: {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 13488:     /* presume that the buffer is at least 3 characters long */
; 13489:     if (PyUnicode_Check(v)) {

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00012	0f 84 b3 00 00
	00		 je	 $LN6@formatchar

; 13490:         if (PyUnicode_GET_LENGTH(v) == 1) {

  00018	48 83 79 60 01	 cmp	 QWORD PTR [rcx+96], 1
  0001d	0f 85 bc 00 00
	00		 jne	 $onError$143313

; 13491:             return PyUnicode_READ_CHAR(v, 0);

  00023	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00026	8b d0		 mov	 edx, eax
  00028	c1 ea 02	 shr	 edx, 2
  0002b	83 e2 07	 and	 edx, 7
  0002e	83 fa 01	 cmp	 edx, 1
  00031	75 32		 jne	 SHORT $LN23@formatchar
  00033	a8 20		 test	 al, 32			; 00000020H
  00035	74 1f		 je	 SHORT $LN11@formatchar
  00037	a8 40		 test	 al, 64			; 00000040H
  00039	74 0c		 je	 SHORT $LN9@formatchar
  0003b	48 83 e9 80	 sub	 rcx, -128		; ffffffffffffff80H
  0003f	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 13514:     return (Py_UCS4) -1;
; 13515: }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
$LN9@formatchar:

; 13491:             return PyUnicode_READ_CHAR(v, 0);

  00047	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  0004e	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 13514:     return (Py_UCS4) -1;
; 13515: }

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
$LN11@formatchar:

; 13491:             return PyUnicode_READ_CHAR(v, 0);

  00056	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  0005d	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 13514:     return (Py_UCS4) -1;
; 13515: }

  00060	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00064	c3		 ret	 0
$LN23@formatchar:

; 13491:             return PyUnicode_READ_CHAR(v, 0);

  00065	83 fa 02	 cmp	 edx, 2
  00068	75 32		 jne	 SHORT $LN21@formatchar
  0006a	a8 20		 test	 al, 32			; 00000020H
  0006c	74 1f		 je	 SHORT $LN15@formatchar
  0006e	a8 40		 test	 al, 64			; 00000040H
  00070	74 0c		 je	 SHORT $LN13@formatchar
  00072	48 83 e9 80	 sub	 rcx, -128		; ffffffffffffff80H
  00076	0f b7 01	 movzx	 eax, WORD PTR [rcx]

; 13514:     return (Py_UCS4) -1;
; 13515: }

  00079	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007d	c3		 ret	 0
$LN13@formatchar:

; 13491:             return PyUnicode_READ_CHAR(v, 0);

  0007e	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  00085	0f b7 01	 movzx	 eax, WORD PTR [rcx]

; 13514:     return (Py_UCS4) -1;
; 13515: }

  00088	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008c	c3		 ret	 0
$LN15@formatchar:

; 13491:             return PyUnicode_READ_CHAR(v, 0);

  0008d	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00094	0f b7 01	 movzx	 eax, WORD PTR [rcx]

; 13514:     return (Py_UCS4) -1;
; 13515: }

  00097	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009b	c3		 ret	 0
$LN21@formatchar:

; 13491:             return PyUnicode_READ_CHAR(v, 0);

  0009c	a8 20		 test	 al, 32			; 00000020H
  0009e	74 1d		 je	 SHORT $LN19@formatchar
  000a0	a8 40		 test	 al, 64			; 00000040H
  000a2	74 0b		 je	 SHORT $LN17@formatchar
  000a4	48 83 e9 80	 sub	 rcx, -128		; ffffffffffffff80H
  000a8	8b 01		 mov	 eax, DWORD PTR [rcx]

; 13514:     return (Py_UCS4) -1;
; 13515: }

  000aa	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ae	c3		 ret	 0
$LN17@formatchar:

; 13491:             return PyUnicode_READ_CHAR(v, 0);

  000af	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  000b6	8b 01		 mov	 eax, DWORD PTR [rcx]

; 13514:     return (Py_UCS4) -1;
; 13515: }

  000b8	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000bc	c3		 ret	 0
$LN19@formatchar:

; 13491:             return PyUnicode_READ_CHAR(v, 0);

  000bd	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  000c4	8b 01		 mov	 eax, DWORD PTR [rcx]

; 13514:     return (Py_UCS4) -1;
; 13515: }

  000c6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ca	c3		 ret	 0
$LN6@formatchar:

; 13492:         }
; 13493:         goto onError;
; 13494:     }
; 13495:     else {
; 13496:         /* Integer input truncated to a character */
; 13497:         long x;
; 13498:         x = PyLong_AsLong(v);

  000cb	e8 00 00 00 00	 call	 PyLong_AsLong

; 13499:         if (x == -1 && PyErr_Occurred())

  000d0	83 f8 ff	 cmp	 eax, -1
  000d3	75 25		 jne	 SHORT $LN3@formatchar
  000d5	e8 00 00 00 00	 call	 PyErr_Occurred
  000da	48 85 c0	 test	 rax, rax
  000dd	74 22		 je	 SHORT $LN1@formatchar
$onError$143313:

; 13509:     }
; 13510: 
; 13511:   onError:
; 13512:     PyErr_SetString(PyExc_TypeError,
; 13513:                     "%c requires int or char");

  000df	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@CMHNDAIN@?$CFc?5requires?5int?5or?5char?$AA@
  000ed	e8 00 00 00 00	 call	 PyErr_SetString
  000f2	83 c8 ff	 or	 eax, -1			; ffffffffH

; 13514:     return (Py_UCS4) -1;
; 13515: }

  000f5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000f9	c3		 ret	 0
$LN3@formatchar:

; 13500:             goto onError;
; 13501: 
; 13502:         if (x < 0 || x > MAX_UNICODE) {

  000fa	3d ff ff 10 00	 cmp	 eax, 1114111		; 0010ffffH

; 13506:         }
; 13507: 
; 13508:         return (Py_UCS4) x;

  000ff	76 16		 jbe	 SHORT $LN7@formatchar
$LN1@formatchar:

; 13503:             PyErr_SetString(PyExc_OverflowError,
; 13504:                             "%c arg not in range(0x110000)");

  00101	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00108	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@CEOKNOOI@?$CFc?5arg?5not?5in?5range?$CI0x110000?$CJ?$AA@
  0010f	e8 00 00 00 00	 call	 PyErr_SetString

; 13505:             return (Py_UCS4) -1;

  00114	83 c8 ff	 or	 eax, -1			; ffffffffH
$LN7@formatchar:

; 13514:     return (Py_UCS4) -1;
; 13515: }

  00117	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0011b	c3		 ret	 0
formatchar ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@KCHHFMED@Can?8t?5initialize?5formatter?5iter?5@ ; `string'
PUBLIC	??_C@_0CK@EPLIEDHB@Can?8t?5initialize?5field?5name?5iter@ ; `string'
PUBLIC	??_C@_0CD@NBFEECLM@Can?8t?5initialize?5encoding?5map?5ty@ ; `string'
PUBLIC	??_C@_0BL@KCEILKNO@Can?8t?5initialize?5?8unicode?8?$AA@ ; `string'
PUBLIC	??_C@_0BK@LDNJPBM@Can?8t?5create?5empty?5string?$AA@ ; `string'
PUBLIC	??_C@_0BA@CKLKFAHI@_PyUnicode_Init?$AA@		; `string'
PUBLIC	_PyUnicode_Init
EXTRN	__imp_GetVersionExA:PROC
EXTRN	PyType_Ready:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_Init DD imagerel $LN49
	DD	imagerel $LN49+347
	DD	imagerel $unwind$_PyUnicode_Init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_Init DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0CF@KCHHFMED@Can?8t?5initialize?5formatter?5iter?5@
CONST	SEGMENT
??_C@_0CF@KCHHFMED@Can?8t?5initialize?5formatter?5iter?5@ DB 'Can''t init'
	DB	'ialize formatter iter type', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@EPLIEDHB@Can?8t?5initialize?5field?5name?5iter@
CONST	SEGMENT
??_C@_0CK@EPLIEDHB@Can?8t?5initialize?5field?5name?5iter@ DB 'Can''t init'
	DB	'ialize field name iterator type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NBFEECLM@Can?8t?5initialize?5encoding?5map?5ty@
CONST	SEGMENT
??_C@_0CD@NBFEECLM@Can?8t?5initialize?5encoding?5map?5ty@ DB 'Can''t init'
	DB	'ialize encoding map type', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KCEILKNO@Can?8t?5initialize?5?8unicode?8?$AA@
CONST	SEGMENT
??_C@_0BL@KCEILKNO@Can?8t?5initialize?5?8unicode?8?$AA@ DB 'Can''t initia'
	DB	'lize ''unicode''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LDNJPBM@Can?8t?5create?5empty?5string?$AA@
CONST	SEGMENT
??_C@_0BK@LDNJPBM@Can?8t?5create?5empty?5string?$AA@ DB 'Can''t create em'
	DB	'pty string', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CKLKFAHI@_PyUnicode_Init?$AA@
CONST	SEGMENT
??_C@_0BA@CKLKFAHI@_PyUnicode_Init?$AA@ DB '_PyUnicode_Init', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyUnicode_Init
_TEXT	SEGMENT
_PyUnicode_Init PROC					; COMDAT

; 14240: {

$LN49:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 14241:     /* XXX - move this array to unicodectype.c ? */
; 14242:     Py_UCS2 linebreak[] = {
; 14243:         0x000A, /* LINE FEED */
; 14244:         0x000D, /* CARRIAGE RETURN */
; 14245:         0x001C, /* FILE SEPARATOR */
; 14246:         0x001D, /* GROUP SEPARATOR */
; 14247:         0x001E, /* RECORD SEPARATOR */
; 14248:         0x0085, /* NEXT LINE */
; 14249:         0x2028, /* LINE SEPARATOR */
; 14250:         0x2029, /* PARAGRAPH SEPARATOR */
; 14251:     };
; 14252: 
; 14253:     Py_GUARD

  00006	e8 00 00 00 00	 call	 _Py_PXCTX
  0000b	85 c0		 test	 eax, eax
  0000d	74 1c		 je	 SHORT $LN12@PyUnicode_@45
  0000f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@CKLKFAHI@_PyUnicode_Init?$AA@
  0001d	45 33 c9	 xor	 r9d, r9d
  00020	41 b8 ad 37 00
	00		 mov	 r8d, 14253		; 000037adH
  00026	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN12@PyUnicode_@45:

; 14254: 
; 14255:     /* Init the implementation */
; 14256:     _Py_INCREF_UNICODE_EMPTY();

  0002b	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR unicode_empty
  00032	48 85 db	 test	 rbx, rbx
  00035	75 18		 jne	 SHORT $LN48@PyUnicode_@45
  00037	33 d2		 xor	 edx, edx
  00039	33 c9		 xor	 ecx, ecx
  0003b	e8 00 00 00 00	 call	 PyUnicode_New
  00040	48 8b d8	 mov	 rbx, rax
  00043	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  0004a	48 85 c0	 test	 rax, rax
  0004d	74 47		 je	 SHORT $LN44@PyUnicode_@45
$LN48@PyUnicode_@45:
  0004f	e8 00 00 00 00	 call	 _Py_PXCTX
  00054	85 c0		 test	 eax, eax
  00056	75 32		 jne	 SHORT $LN11@PyUnicode_@45
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00066	4c 8b cb	 mov	 r9, rbx
  00069	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0006f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00077	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007c	85 c0		 test	 eax, eax
  0007e	75 06		 jne	 SHORT $LN20@PyUnicode_@45
  00080	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00084	74 04		 je	 SHORT $LN11@PyUnicode_@45
$LN20@PyUnicode_@45:
  00086	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN11@PyUnicode_@45:

; 14257:     if (!unicode_empty)

  0008a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  00091	48 85 c9	 test	 rcx, rcx
  00094	75 13		 jne	 SHORT $LN6@PyUnicode_@45
$LN44@PyUnicode_@45:

; 14258:         Py_FatalError("Can't create empty string");

  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@LDNJPBM@Can?8t?5create?5empty?5string?$AA@
  0009d	e8 00 00 00 00	 call	 Py_FatalError
  000a2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
$LN6@PyUnicode_@45:

; 14259:     Py_DECREF(unicode_empty);

  000a9	e8 00 00 00 00	 call	 _Py_DecRef

; 14260: 
; 14261:     if (PyType_Ready(&PyUnicode_Type) < 0)

  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyUnicode_Type
  000b5	e8 00 00 00 00	 call	 PyType_Ready
  000ba	85 c0		 test	 eax, eax
  000bc	79 0c		 jns	 SHORT $LN5@PyUnicode_@45

; 14262:         Py_FatalError("Can't initialize 'unicode'");

  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@KCEILKNO@Can?8t?5initialize?5?8unicode?8?$AA@
  000c5	e8 00 00 00 00	 call	 Py_FatalError
$LN5@PyUnicode_@45:

; 14263: 
; 14264:     /* initialize the linebreak bloom filter */
; 14265:     bloom_linebreak = make_bloom_mask(
; 14266:         PyUnicode_2BYTE_KIND, linebreak,
; 14267:         Py_ARRAY_LENGTH(linebreak));
; 14268: 
; 14269:     if (PyType_Ready(&EncodingMapType) < 0)

  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:EncodingMapType
  000d1	c7 05 00 00 00
	00 20 27 00 70	 mov	 DWORD PTR bloom_linebreak, 1879058208 ; 70002720H
  000db	e8 00 00 00 00	 call	 PyType_Ready
  000e0	85 c0		 test	 eax, eax
  000e2	79 0c		 jns	 SHORT $LN4@PyUnicode_@45

; 14270:          Py_FatalError("Can't initialize encoding map type");

  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@NBFEECLM@Can?8t?5initialize?5encoding?5map?5ty@
  000eb	e8 00 00 00 00	 call	 Py_FatalError
$LN4@PyUnicode_@45:

; 14271: 
; 14272:     if (PyType_Ready(&PyFieldNameIter_Type) < 0)

  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFieldNameIter_Type
  000f7	e8 00 00 00 00	 call	 PyType_Ready
  000fc	85 c0		 test	 eax, eax
  000fe	79 0c		 jns	 SHORT $LN3@PyUnicode_@45

; 14273:         Py_FatalError("Can't initialize field name iterator type");

  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CK@EPLIEDHB@Can?8t?5initialize?5field?5name?5iter@
  00107	e8 00 00 00 00	 call	 Py_FatalError
$LN3@PyUnicode_@45:

; 14274: 
; 14275:     if (PyType_Ready(&PyFormatterIter_Type) < 0)

  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFormatterIter_Type
  00113	e8 00 00 00 00	 call	 PyType_Ready
  00118	85 c0		 test	 eax, eax
  0011a	79 0c		 jns	 SHORT $LN2@PyUnicode_@45

; 14276:         Py_FatalError("Can't initialize formatter iter type");

  0011c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@KCHHFMED@Can?8t?5initialize?5formatter?5iter?5@
  00123	e8 00 00 00 00	 call	 Py_FatalError
$LN2@PyUnicode_@45:

; 14277: 
; 14278: #ifdef HAVE_MBCS
; 14279:     winver.dwOSVersionInfoSize = sizeof(winver);
; 14280:     if (!GetVersionEx((OSVERSIONINFO*)&winver)) {

  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:winver
  0012f	c7 05 00 00 00
	00 9c 00 00 00	 mov	 DWORD PTR winver, 156	; 0000009cH
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetVersionExA
  0013f	85 c0		 test	 eax, eax
  00141	75 10		 jne	 SHORT $LN1@PyUnicode_@45

; 14281:         PyErr_SetFromWindowsErr(0);

  00143	33 c9		 xor	 ecx, ecx
  00145	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr

; 14282:         return -1;

  0014a	83 c8 ff	 or	 eax, -1

; 14286: }

  0014d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00151	5b		 pop	 rbx
  00152	c3		 ret	 0
$LN1@PyUnicode_@45:

; 14283:     }
; 14284: #endif
; 14285:     return 0;

  00153	33 c0		 xor	 eax, eax

; 14286: }

  00155	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00159	5b		 pop	 rbx
  0015a	c3		 ret	 0
_PyUnicode_Init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@OJPPNKBO@PyUnicode_ClearFreeList?$AA@	; `string'
PUBLIC	PyUnicode_ClearFreeList
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_ClearFreeList DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$PyUnicode_ClearFreeList
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_ClearFreeList DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BI@OJPPNKBO@PyUnicode_ClearFreeList?$AA@
CONST	SEGMENT
??_C@_0BI@OJPPNKBO@PyUnicode_ClearFreeList?$AA@ DB 'PyUnicode_ClearFreeLi'
	DB	'st', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_ClearFreeList
_TEXT	SEGMENT
PyUnicode_ClearFreeList PROC				; COMDAT

; 14292: {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 14293:     Py_GUARD

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 1c		 je	 SHORT $LN4@PyUnicode_@46
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@OJPPNKBO@PyUnicode_ClearFreeList?$AA@
  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	41 b8 d5 37 00
	00		 mov	 r8d, 14293		; 000037d5H
  00024	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN4@PyUnicode_@46:

; 14294:     return 0;

  00029	33 c0		 xor	 eax, eax

; 14295: }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
PyUnicode_ClearFreeList ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@MPBOIFIJ@_PyUnicode_Fini?$AA@		; `string'
PUBLIC	_PyUnicode_Fini
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_PyUnicode_Fini DD imagerel $LN39
	DD	imagerel $LN39+439
	DD	imagerel $unwind$_PyUnicode_Fini
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_Fini DD 084201H
	DD	083442H
	DD	0a640fH
	DD	09540fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0BA@MPBOIFIJ@_PyUnicode_Fini?$AA@
CONST	SEGMENT
??_C@_0BA@MPBOIFIJ@_PyUnicode_Fini?$AA@ DB '_PyUnicode_Fini', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT _PyUnicode_Fini
_TEXT	SEGMENT
_PyUnicode_Fini PROC					; COMDAT

; 14299: {

$LN39:
  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 14300:     int i;
; 14301:     Py_GUARD

  0000f	e8 00 00 00 00	 call	 _Py_PXCTX
  00014	85 c0		 test	 eax, eax
  00016	74 1c		 je	 SHORT $LN11@PyUnicode_@47
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MPBOIFIJ@_PyUnicode_Fini?$AA@
  00026	45 33 c9	 xor	 r9d, r9d
  00029	41 b8 dd 37 00
	00		 mov	 r8d, 14301		; 000037ddH
  0002f	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN11@PyUnicode_@47:

; 14302: 
; 14303:     Py_CLEAR(unicode_empty);

  00034	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR unicode_empty
  0003b	33 ed		 xor	 ebp, ebp
  0003d	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00042	4d 85 c9	 test	 r9, r9
  00045	0f 84 98 00 00
	00		 je	 $LN10@PyUnicode_@47
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MPBOIFIJ@_PyUnicode_Fini?$AA@
  00059	41 b8 df 37 00
	00		 mov	 r8d, 14303		; 000037dfH
  0005f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00067	e8 00 00 00 00	 call	 _PyParallel_Guard
  0006c	85 c0		 test	 eax, eax
  0006e	75 73		 jne	 SHORT $LN10@PyUnicode_@47
  00070	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR unicode_empty
  00077	48 89 2d 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rbp
  0007e	e8 00 00 00 00	 call	 _Py_PXCTX
  00083	85 c0		 test	 eax, eax
  00085	75 5c		 jne	 SHORT $LN10@PyUnicode_@47
  00087	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0008b	a8 20		 test	 al, 32			; 00000020H
  0008d	75 4c		 jne	 SHORT $LN19@PyUnicode_@47
  0008f	84 c0		 test	 al, al
  00091	78 48		 js	 SHORT $LN19@PyUnicode_@47
  00093	a8 02		 test	 al, 2
  00095	75 4c		 jne	 SHORT $LN10@PyUnicode_@47
  00097	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0009b	75 46		 jne	 SHORT $LN10@PyUnicode_@47
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000ab	4c 8b cb	 mov	 r9, rbx
  000ae	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000b4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000bc	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c1	48 8b cb	 mov	 rcx, rbx
  000c4	85 c0		 test	 eax, eax
  000c6	74 07		 je	 SHORT $LN24@PyUnicode_@47
  000c8	e8 00 00 00 00	 call	 _Px_Dealloc
  000cd	eb 14		 jmp	 SHORT $LN10@PyUnicode_@47
$LN24@PyUnicode_@47:
  000cf	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000d3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000d9	eb 08		 jmp	 SHORT $LN10@PyUnicode_@47
$LN19@PyUnicode_@47:
  000db	48 8b cb	 mov	 rcx, rbx
  000de	e8 00 00 00 00	 call	 Px_DecRef
$LN10@PyUnicode_@47:

; 14304: 
; 14305:     for (i = 0; i < 256; i++)

  000e3	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:unicode_latin1
  000ea	be 00 01 00 00	 mov	 esi, 256		; 00000100H
  000ef	90		 npad	 1
$LL7@PyUnicode_@47:

; 14306:         Py_CLEAR(unicode_latin1[i]);

  000f0	4c 8b 0f	 mov	 r9, QWORD PTR [rdi]
  000f3	4d 85 c9	 test	 r9, r9
  000f6	0f 84 90 00 00
	00		 je	 $LN3@PyUnicode_@47
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MPBOIFIJ@_PyUnicode_Fini?$AA@
  0010a	41 b8 e2 37 00
	00		 mov	 r8d, 14306		; 000037e2H
  00110	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00118	e8 00 00 00 00	 call	 _PyParallel_Guard
  0011d	85 c0		 test	 eax, eax
  0011f	75 6b		 jne	 SHORT $LN3@PyUnicode_@47
  00121	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00124	48 89 2f	 mov	 QWORD PTR [rdi], rbp
  00127	e8 00 00 00 00	 call	 _Py_PXCTX
  0012c	85 c0		 test	 eax, eax
  0012e	75 5c		 jne	 SHORT $LN3@PyUnicode_@47
  00130	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00134	a8 20		 test	 al, 32			; 00000020H
  00136	75 4c		 jne	 SHORT $LN30@PyUnicode_@47
  00138	84 c0		 test	 al, al
  0013a	78 48		 js	 SHORT $LN30@PyUnicode_@47
  0013c	a8 02		 test	 al, 2
  0013e	75 4c		 jne	 SHORT $LN3@PyUnicode_@47
  00140	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00144	75 46		 jne	 SHORT $LN3@PyUnicode_@47
  00146	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0014d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00154	4c 8b cb	 mov	 r9, rbx
  00157	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0015d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00165	e8 00 00 00 00	 call	 _PyParallel_Guard
  0016a	48 8b cb	 mov	 rcx, rbx
  0016d	85 c0		 test	 eax, eax
  0016f	74 07		 je	 SHORT $LN35@PyUnicode_@47
  00171	e8 00 00 00 00	 call	 _Px_Dealloc
  00176	eb 14		 jmp	 SHORT $LN3@PyUnicode_@47
$LN35@PyUnicode_@47:
  00178	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0017c	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00182	eb 08		 jmp	 SHORT $LN3@PyUnicode_@47
$LN30@PyUnicode_@47:
  00184	48 8b cb	 mov	 rcx, rbx
  00187	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PyUnicode_@47:

; 14304: 
; 14305:     for (i = 0; i < 256; i++)

  0018c	48 83 c7 08	 add	 rdi, 8
  00190	48 ff ce	 dec	 rsi
  00193	0f 85 57 ff ff
	ff		 jne	 $LL7@PyUnicode_@47

; 14307:     _PyUnicode_ClearStaticStrings();

  00199	e8 00 00 00 00	 call	 _PyUnicode_ClearStaticStrings

; 14308:     (void)PyUnicode_ClearFreeList();

  0019e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 14309: }

  001a3	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001a8	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001ad	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b1	5f		 pop	 rdi
  001b2	e9 00 00 00 00	 jmp	 PyUnicode_ClearFreeList
_PyUnicode_Fini ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@MJEHNCHI@_PyParallelUnicode_InternInPlace@ ; `string'
PUBLIC	_PyParallelUnicode_InternInPlace
EXTRN	PyDict_GetItem:PROC
EXTRN	_PyThreadState_Current:QWORD
EXTRN	_PyParallel_GetThreadState:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyParallelUnicode_InternInPlace DD imagerel $LN30
	DD	imagerel $LN30+282
	DD	imagerel $unwind$_PyParallelUnicode_InternInPlace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_PyParallelUnicode_InternInPlace DD imagerel $LN30+282
	DD	imagerel $LN30+404
	DD	imagerel $chain$3$_PyParallelUnicode_InternInPlace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_PyParallelUnicode_InternInPlace DD imagerel $LN30+404
	DD	imagerel $LN30+493
	DD	imagerel $chain$4$_PyParallelUnicode_InternInPlace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_PyParallelUnicode_InternInPlace DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+282
	DD	imagerel $unwind$_PyParallelUnicode_InternInPlace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_PyParallelUnicode_InternInPlace DD 020521H
	DD	0ac405H
	DD	imagerel $LN30
	DD	imagerel $LN30+282
	DD	imagerel $unwind$_PyParallelUnicode_InternInPlace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyParallelUnicode_InternInPlace DD 09e501H
	DD	04d4e5H
	DD	095445H
	DD	083440H
	DD	070034207H
	DD	06002H
xdata	ENDS
;	COMDAT ??_C@_0CB@MJEHNCHI@_PyParallelUnicode_InternInPlace@
CONST	SEGMENT
??_C@_0CB@MJEHNCHI@_PyParallelUnicode_InternInPlace@ DB '_PyParallelUnico'
	DB	'de_InternInPlace', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyParallelUnicode_InternInPlace
_TEXT	SEGMENT
p$ = 64
_PyParallelUnicode_InternInPlace PROC			; COMDAT

; 14314: {

$LN30:
  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 14315:     PyObject *s = *p;

  00007	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
  0000a	48 8b f1	 mov	 rsi, rcx

; 14316:     PyObject *t;
; 14317:     PyThreadState *tstate;
; 14318:     int failed;
; 14319: 
; 14320:     Px_GUARD

  0000d	e8 00 00 00 00	 call	 _Py_PXCTX
  00012	85 c0		 test	 eax, eax
  00014	75 1d		 jne	 SHORT $LN14@PyParallel
  00016	44 8d 48 01	 lea	 r9d, QWORD PTR [rax+1]
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@MJEHNCHI@_PyParallelUnicode_InternInPlace@
  00028	41 b8 f0 37 00
	00		 mov	 r8d, 14320		; 000037f0H
  0002e	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN14@PyParallel:

; 14321: 
; 14322:     if (interned) {

  00033	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR interned, 0
  0003b	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00040	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  00045	0f 84 86 00 00
	00		 je	 $LN9@PyParallel

; 14323:         _PyParallel_EnableTLSHeap();

  0004b	e8 00 00 00 00	 call	 _PyParallel_EnableTLSHeap

; 14324:         Py_ALLOW_RECURSION

  00050	e8 00 00 00 00	 call	 _Py_PXCTX
  00055	85 c0		 test	 eax, eax
  00057	74 07		 je	 SHORT $LN17@PyParallel
  00059	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0005e	eb 07		 jmp	 SHORT $LN18@PyParallel
$LN17@PyParallel:
  00060	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN18@PyParallel:
  00067	0f b6 68 1d	 movzx	 ebp, BYTE PTR [rax+29]
  0006b	e8 00 00 00 00	 call	 _Py_PXCTX
  00070	85 c0		 test	 eax, eax
  00072	74 07		 je	 SHORT $LN19@PyParallel
  00074	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00079	eb 07		 jmp	 SHORT $LN20@PyParallel
$LN19@PyParallel:
  0007b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN20@PyParallel:

; 14325:         t = PyDict_GetItem(interned, s);

  00082	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR interned
  00089	48 8b d7	 mov	 rdx, rdi
  0008c	c6 40 1d 01	 mov	 BYTE PTR [rax+29], 1
  00090	e8 00 00 00 00	 call	 PyDict_GetItem
  00095	48 8b d8	 mov	 rbx, rax

; 14326:         Py_END_ALLOW_RECURSION

  00098	e8 00 00 00 00	 call	 _Py_PXCTX
  0009d	85 c0		 test	 eax, eax
  0009f	74 07		 je	 SHORT $LN21@PyParallel
  000a1	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  000a6	eb 07		 jmp	 SHORT $LN22@PyParallel
$LN21@PyParallel:
  000a8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN22@PyParallel:
  000af	40 88 68 1d	 mov	 BYTE PTR [rax+29], bpl

; 14327:         _PyParallel_DisableTLSHeap();

  000b3	e8 00 00 00 00	 call	 _PyParallel_DisableTLSHeap

; 14328:         if (t) {

  000b8	48 85 db	 test	 rbx, rbx
  000bb	74 14		 je	 SHORT $LN9@PyParallel

; 14329:             *p = t;

  000bd	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  000c0	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000c5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 14370: }

  000ca	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ce	5f		 pop	 rdi
  000cf	5e		 pop	 rsi
  000d0	c3		 ret	 0
$LN9@PyParallel:

; 14330:             return;
; 14331:         }
; 14332:     }
; 14333: 
; 14334:     if (!tls_interned) {

  000d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000d7	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000e0	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  000e5	48 8b 1c c8	 mov	 rbx, QWORD PTR [rax+rcx*8]
  000e9	41 bd 00 00 00
	00		 mov	 r13d, OFFSET FLAT:tls_interned
  000ef	4a 83 3c 2b 00	 cmp	 QWORD PTR [rbx+r13], 0
  000f4	75 24		 jne	 SHORT $LN6@PyParallel

; 14335:         _PyParallel_EnableTLSHeap();

  000f6	e8 00 00 00 00	 call	 _PyParallel_EnableTLSHeap

; 14336:         tls_interned = PyDict_New();

  000fb	e8 00 00 00 00	 call	 PyDict_New
  00100	4a 89 04 2b	 mov	 QWORD PTR [rbx+r13], rax

; 14337:         _PyParallel_DisableTLSHeap();

  00104	e8 00 00 00 00	 call	 _PyParallel_DisableTLSHeap

; 14338:         if (!tls_interned) {

  00109	4a 83 3c 2b 00	 cmp	 QWORD PTR [rbx+r13], 0
  0010e	75 0a		 jne	 SHORT $LN6@PyParallel

; 14339:             PyErr_Clear(); /* Don't leave an exception */

  00110	e8 00 00 00 00	 call	 PyErr_Clear

; 14340:             return;

  00115	e9 bd 00 00 00	 jmp	 $LN29@PyParallel
$LN6@PyParallel:
  0011a	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12

; 14341:         }
; 14342:     }
; 14343:     /* It might be that the GetItem call fails even
; 14344:        though the key is present in the dictionary,
; 14345:        namely when this happens during a stack overflow. */
; 14346:     Py_ALLOW_RECURSION

  0011f	e8 00 00 00 00	 call	 _Py_PXCTX
  00124	85 c0		 test	 eax, eax
  00126	74 07		 je	 SHORT $LN23@PyParallel
  00128	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0012d	eb 07		 jmp	 SHORT $LN24@PyParallel
$LN23@PyParallel:
  0012f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN24@PyParallel:
  00136	44 0f b6 60 1d	 movzx	 r12d, BYTE PTR [rax+29]
  0013b	e8 00 00 00 00	 call	 _Py_PXCTX
  00140	85 c0		 test	 eax, eax
  00142	74 07		 je	 SHORT $LN25@PyParallel
  00144	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00149	eb 07		 jmp	 SHORT $LN26@PyParallel
$LN25@PyParallel:
  0014b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN26@PyParallel:
  00152	c6 40 1d 01	 mov	 BYTE PTR [rax+29], 1

; 14347:     _PyParallel_EnableTLSHeap();

  00156	e8 00 00 00 00	 call	 _PyParallel_EnableTLSHeap

; 14348:     t = PyDict_GetItem(tls_interned, s);

  0015b	4a 8b 0c 2b	 mov	 rcx, QWORD PTR [rbx+r13]
  0015f	48 8b d7	 mov	 rdx, rdi
  00162	e8 00 00 00 00	 call	 PyDict_GetItem
  00167	48 8b e8	 mov	 rbp, rax

; 14349:     _PyParallel_DisableTLSHeap();

  0016a	e8 00 00 00 00	 call	 _PyParallel_DisableTLSHeap

; 14350:     Py_END_ALLOW_RECURSION

  0016f	e8 00 00 00 00	 call	 _Py_PXCTX
  00174	85 c0		 test	 eax, eax
  00176	74 07		 je	 SHORT $LN27@PyParallel
  00178	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0017d	eb 07		 jmp	 SHORT $LN28@PyParallel
$LN27@PyParallel:
  0017f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN28@PyParallel:
  00186	44 88 60 1d	 mov	 BYTE PTR [rax+29], r12b
  0018a	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]

; 14351: 
; 14352:     if (t) {

  0018f	48 85 ed	 test	 rbp, rbp
  00192	74 05		 je	 SHORT $LN3@PyParallel

; 14353:         *p = t;

  00194	48 89 2e	 mov	 QWORD PTR [rsi], rbp

; 14354:         return;

  00197	eb 3e		 jmp	 SHORT $LN29@PyParallel
$LN3@PyParallel:

; 14355:     }
; 14356: 
; 14357:     tstate = _PyParallel_GetThreadState();

  00199	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0019e	48 8b f0	 mov	 rsi, rax

; 14358:     tstate->recursion_critical = 1;

  001a1	c6 40 1d 01	 mov	 BYTE PTR [rax+29], 1

; 14359: 
; 14360:     _PyParallel_EnableTLSHeap();

  001a5	e8 00 00 00 00	 call	 _PyParallel_EnableTLSHeap

; 14361:     failed = PyDict_SetItem(tls_interned, s, s);

  001aa	4a 8b 0c 2b	 mov	 rcx, QWORD PTR [rbx+r13]
  001ae	4c 8b c7	 mov	 r8, rdi
  001b1	48 8b d7	 mov	 rdx, rdi
  001b4	e8 00 00 00 00	 call	 PyDict_SetItem
  001b9	8b d8		 mov	 ebx, eax

; 14362:     _PyParallel_DisableTLSHeap();

  001bb	e8 00 00 00 00	 call	 _PyParallel_DisableTLSHeap

; 14363: 
; 14364:     if (failed)

  001c0	85 db		 test	 ebx, ebx
  001c2	74 07		 je	 SHORT $LN2@PyParallel

; 14365:         PyErr_Clear();

  001c4	e8 00 00 00 00	 call	 PyErr_Clear

; 14366:     else

  001c9	eb 08		 jmp	 SHORT $LN1@PyParallel
$LN2@PyParallel:

; 14367:         _PyUnicode_STATE(s).interned = SSTATE_INTERNED_MORTAL;

  001cb	83 67 70 fd	 and	 DWORD PTR [rdi+112], -3	; fffffffdH
  001cf	83 4f 70 01	 or	 DWORD PTR [rdi+112], 1
$LN1@PyParallel:

; 14368: 
; 14369:     tstate->recursion_critical = 0;

  001d3	c6 46 1d 00	 mov	 BYTE PTR [rsi+29], 0
$LN29@PyParallel:
  001d7	4c 8b 6c 24 20	 mov	 r13, QWORD PTR [rsp+32]
  001dc	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001e1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 14370: }

  001e6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001ea	5f		 pop	 rdi
  001eb	5e		 pop	 rsi
  001ec	c3		 ret	 0
_PyParallelUnicode_InternInPlace ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FF@OJJGJEBP@PyUnicode_InternInPlace?$CI?$CJ?5attemp@ ; `string'
PUBLIC	??_C@_0BI@IAEEENCA@PyUnicode_InternInPlace?$AA@	; `string'
PUBLIC	PyUnicode_InternInPlace
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_InternInPlace DD imagerel $LN28
	DD	imagerel $LN28+164
	DD	imagerel $unwind$PyUnicode_InternInPlace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyUnicode_InternInPlace DD imagerel $LN28+164
	DD	imagerel $LN28+283
	DD	imagerel $chain$1$PyUnicode_InternInPlace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyUnicode_InternInPlace DD imagerel $LN28+283
	DD	imagerel $LN28+318
	DD	imagerel $chain$2$PyUnicode_InternInPlace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyUnicode_InternInPlace DD imagerel $LN28+318
	DD	imagerel $LN28+406
	DD	imagerel $chain$4$PyUnicode_InternInPlace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$PyUnicode_InternInPlace DD imagerel $LN28+406
	DD	imagerel $LN28+433
	DD	imagerel $chain$6$PyUnicode_InternInPlace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$PyUnicode_InternInPlace DD imagerel $LN28+433
	DD	imagerel $LN28+497
	DD	imagerel $chain$8$PyUnicode_InternInPlace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$PyUnicode_InternInPlace DD imagerel $LN28+497
	DD	imagerel $LN28+508
	DD	imagerel $chain$9$PyUnicode_InternInPlace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$PyUnicode_InternInPlace DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+164
	DD	imagerel $unwind$PyUnicode_InternInPlace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$PyUnicode_InternInPlace DD 020021H
	DD	096400H
	DD	imagerel $LN28
	DD	imagerel $LN28+164
	DD	imagerel $unwind$PyUnicode_InternInPlace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$PyUnicode_InternInPlace DD 020021H
	DD	096400H
	DD	imagerel $LN28
	DD	imagerel $LN28+164
	DD	imagerel $unwind$PyUnicode_InternInPlace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyUnicode_InternInPlace DD 020021H
	DD	096400H
	DD	imagerel $LN28
	DD	imagerel $LN28+164
	DD	imagerel $unwind$PyUnicode_InternInPlace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyUnicode_InternInPlace DD 020021H
	DD	096400H
	DD	imagerel $LN28
	DD	imagerel $LN28+164
	DD	imagerel $unwind$PyUnicode_InternInPlace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyUnicode_InternInPlace DD 040a21H
	DD	09640aH
	DD	085405H
	DD	imagerel $LN28
	DD	imagerel $LN28+164
	DD	imagerel $unwind$PyUnicode_InternInPlace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_InternInPlace DD 040a01H
	DD	0a340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0FF@OJJGJEBP@PyUnicode_InternInPlace?$CI?$CJ?5attemp@
CONST	SEGMENT
??_C@_0FF@OJJGJEBP@PyUnicode_InternInPlace?$CI?$CJ?5attemp@ DB 'PyUnicode'
	DB	'_InternInPlace() attempted to intern a parallel object from t'
	DB	'he main thread', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IAEEENCA@PyUnicode_InternInPlace?$AA@
CONST	SEGMENT
??_C@_0BI@IAEEENCA@PyUnicode_InternInPlace?$AA@ DB 'PyUnicode_InternInPla'
	DB	'ce', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_InternInPlace
_TEXT	SEGMENT
p$ = 64
PyUnicode_InternInPlace PROC				; COMDAT

; 14377: {

$LN28:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 14378:     register PyObject *s = *p;

  0000a	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
  0000d	48 8b f9	 mov	 rdi, rcx

; 14379:     PyObject *t;
; 14380: #ifdef Py_DEBUG
; 14381:     assert(s != NULL);
; 14382:     assert(_PyUnicode_CHECK(s));
; 14383: #else
; 14384:     if (s == NULL || !PyUnicode_Check(s))

  00010	48 85 db	 test	 rbx, rbx
  00013	0f 84 d8 01 00
	00		 je	 $LN11@PyUnicode_@48
  00019	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0001d	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00027	0f 84 c4 01 00
	00		 je	 $LN11@PyUnicode_@48

; 14385:         return;
; 14386: #endif
; 14387:     /* If it's a subclass, we don't really know what putting
; 14388:        it in the interned dict might do. */
; 14389:     if (!PyUnicode_CheckExact(s))

  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyUnicode_Type
  00034	48 3b c1	 cmp	 rax, rcx
  00037	0f 85 b4 01 00
	00		 jne	 $LN11@PyUnicode_@48

; 14390:         return;
; 14391:     if (PyUnicode_CHECK_INTERNED(s))

  0003d	f6 43 70 03	 test	 BYTE PTR [rbx+112], 3
  00041	0f 85 aa 01 00
	00		 jne	 $LN11@PyUnicode_@48

; 14392:         return;
; 14393: 
; 14394: #ifdef WITH_PARALLEL
; 14395:     Px_RETURN_VOID(_PyParallelUnicode_InternInPlace(p));

  00047	e8 00 00 00 00	 call	 _Py_PXCTX
  0004c	85 c0		 test	 eax, eax
  0004e	74 12		 je	 SHORT $LN8@PyUnicode_@48
  00050	48 8b cf	 mov	 rcx, rdi

; 14432: }

  00053	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00058	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005c	5f		 pop	 rdi
  0005d	e9 00 00 00 00	 jmp	 _PyParallelUnicode_InternInPlace
$LN8@PyUnicode_@48:

; 14396: 
; 14397:     if (Py_ISPX(s))

  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@IAEEENCA@PyUnicode_InternInPlace?$AA@
  00070	4c 8b cb	 mov	 r9, rbx
  00073	41 b8 3d 38 00
	00		 mov	 r8d, 14397		; 0000383dH
  00079	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00081	e8 00 00 00 00	 call	 _PyParallel_Guard
  00086	85 c0		 test	 eax, eax
  00088	74 0c		 je	 SHORT $LN7@PyUnicode_@48

; 14398:         Py_FatalError("PyUnicode_InternInPlace() attempted to intern "
; 14399:                       "a parallel object from the main thread");

  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0FF@OJJGJEBP@PyUnicode_InternInPlace?$CI?$CJ?5attemp@
  00091	e8 00 00 00 00	 call	 Py_FatalError
$LN7@PyUnicode_@48:

; 14400: #endif
; 14401: 
; 14402:     if (!interned)

  00096	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR interned, 0
  0009e	0f 84 4d 01 00
	00		 je	 $LN11@PyUnicode_@48

; 14403:         /* interned dict hasn't been initialized yet */
; 14404:         return;
; 14405: 
; 14406:     /* It might be that the GetItem call fails even
; 14407:        though the key is present in the dictionary,
; 14408:        namely when this happens during a stack overflow. */
; 14409:     Py_ALLOW_RECURSION

  000a4	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  000a9	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  000ae	e8 00 00 00 00	 call	 _Py_PXCTX
  000b3	85 c0		 test	 eax, eax
  000b5	74 07		 je	 SHORT $LN15@PyUnicode_@48
  000b7	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  000bc	eb 07		 jmp	 SHORT $LN16@PyUnicode_@48
$LN15@PyUnicode_@48:
  000be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN16@PyUnicode_@48:
  000c5	0f b6 68 1d	 movzx	 ebp, BYTE PTR [rax+29]
  000c9	e8 00 00 00 00	 call	 _Py_PXCTX
  000ce	85 c0		 test	 eax, eax
  000d0	74 07		 je	 SHORT $LN17@PyUnicode_@48
  000d2	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  000d7	eb 07		 jmp	 SHORT $LN18@PyUnicode_@48
$LN17@PyUnicode_@48:
  000d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN18@PyUnicode_@48:

; 14410:     t = PyDict_GetItem(interned, s);

  000e0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR interned
  000e7	48 8b d3	 mov	 rdx, rbx
  000ea	c6 40 1d 01	 mov	 BYTE PTR [rax+29], 1
  000ee	e8 00 00 00 00	 call	 PyDict_GetItem
  000f3	48 8b f0	 mov	 rsi, rax

; 14411:     Py_END_ALLOW_RECURSION

  000f6	e8 00 00 00 00	 call	 _Py_PXCTX
  000fb	85 c0		 test	 eax, eax
  000fd	74 07		 je	 SHORT $LN19@PyUnicode_@48
  000ff	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00104	eb 07		 jmp	 SHORT $LN20@PyUnicode_@48
$LN19@PyUnicode_@48:
  00106	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN20@PyUnicode_@48:
  0010d	40 88 68 1d	 mov	 BYTE PTR [rax+29], bpl
  00111	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 14412: 
; 14413:         if (t) {

  00116	48 85 f6	 test	 rsi, rsi
  00119	74 23		 je	 SHORT $LN2@PyUnicode_@48

; 14414:             Py_INCREF(t);

  0011b	48 8b ce	 mov	 rcx, rsi
  0011e	e8 00 00 00 00	 call	 _Py_IncRef

; 14415:             Py_DECREF(*p);

  00123	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00126	e8 00 00 00 00	 call	 _Py_DecRef

; 14416:             *p = t;

  0012b	48 89 37	 mov	 QWORD PTR [rdi], rsi
  0012e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 14432: }

  00133	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00138	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0013c	5f		 pop	 rdi
  0013d	c3		 ret	 0
$LN2@PyUnicode_@48:

; 14417:             return;
; 14418:         }
; 14419: 
; 14420:     PyThreadState_GET()->recursion_critical = 1;

  0013e	e8 00 00 00 00	 call	 _Py_PXCTX
  00143	85 c0		 test	 eax, eax
  00145	74 07		 je	 SHORT $LN21@PyUnicode_@48
  00147	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0014c	eb 07		 jmp	 SHORT $LN22@PyUnicode_@48
$LN21@PyUnicode_@48:
  0014e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN22@PyUnicode_@48:

; 14421:     if (PyDict_SetItem(interned, s, s) < 0) {

  00155	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR interned
  0015c	4c 8b c3	 mov	 r8, rbx
  0015f	48 8b d3	 mov	 rdx, rbx
  00162	c6 40 1d 01	 mov	 BYTE PTR [rax+29], 1
  00166	e8 00 00 00 00	 call	 PyDict_SetItem
  0016b	85 c0		 test	 eax, eax
  0016d	79 42		 jns	 SHORT $LN1@PyUnicode_@48

; 14422:         PyErr_Clear();

  0016f	e8 00 00 00 00	 call	 PyErr_Clear

; 14423:         PyThreadState_GET()->recursion_critical = 0;

  00174	e8 00 00 00 00	 call	 _Py_PXCTX
  00179	85 c0		 test	 eax, eax
  0017b	74 19		 je	 SHORT $LN23@PyUnicode_@48
  0017d	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00182	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00187	c6 40 1d 00	 mov	 BYTE PTR [rax+29], 0

; 14432: }

  0018b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00190	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00194	5f		 pop	 rdi
  00195	c3		 ret	 0
$LN23@PyUnicode_@48:

; 14423:         PyThreadState_GET()->recursion_critical = 0;

  00196	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
  0019d	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  001a2	c6 40 1d 00	 mov	 BYTE PTR [rax+29], 0

; 14432: }

  001a6	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001ab	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001af	5f		 pop	 rdi
  001b0	c3		 ret	 0
$LN1@PyUnicode_@48:

; 14424:         return;
; 14425:     }
; 14426:     PyThreadState_GET()->recursion_critical = 0;

  001b1	e8 00 00 00 00	 call	 _Py_PXCTX
  001b6	85 c0		 test	 eax, eax
  001b8	74 07		 je	 SHORT $LN25@PyUnicode_@48
  001ba	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  001bf	eb 07		 jmp	 SHORT $LN26@PyUnicode_@48
$LN25@PyUnicode_@48:
  001c1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN26@PyUnicode_@48:

; 14427:     /* The two references in interned are not counted by refcnt.
; 14428:        The deallocator will take care of this */
; 14429:     Py_DECREF(s);

  001c8	48 8b cb	 mov	 rcx, rbx
  001cb	c6 40 1d 00	 mov	 BYTE PTR [rax+29], 0
  001cf	e8 00 00 00 00	 call	 _Py_DecRef

; 14430:     Py_DECREF(s);

  001d4	48 8b cb	 mov	 rcx, rbx
  001d7	e8 00 00 00 00	 call	 _Py_DecRef

; 14431:     _PyUnicode_STATE(s).interned = SSTATE_INTERNED_MORTAL;

  001dc	44 8b 5b 70	 mov	 r11d, DWORD PTR [rbx+112]
  001e0	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  001e5	41 83 e3 fd	 and	 r11d, -3		; fffffffdH
  001e9	41 83 cb 01	 or	 r11d, 1
  001ed	44 89 5b 70	 mov	 DWORD PTR [rbx+112], r11d
$LN11@PyUnicode_@48:

; 14432: }

  001f1	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001f6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001fa	5f		 pop	 rdi
  001fb	c3		 ret	 0
PyUnicode_InternInPlace ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_InternImmortal
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyUnicode_InternImmortal DD imagerel $LN8
	DD	imagerel $LN8+105
	DD	imagerel $unwind$PyUnicode_InternImmortal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_InternImmortal DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT PyUnicode_InternImmortal
_TEXT	SEGMENT
p$ = 64
PyUnicode_InternImmortal PROC				; COMDAT

; 14436: {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 14437:     PyUnicode_InternInPlace(p);

  00009	e8 00 00 00 00	 call	 PyUnicode_InternInPlace

; 14438:     if (PyUnicode_CHECK_INTERNED(*p) != SSTATE_INTERNED_IMMORTAL) {

  0000e	4c 8b 1b	 mov	 r11, QWORD PTR [rbx]
  00011	41 8b 43 70	 mov	 eax, DWORD PTR [r11+112]
  00015	24 03		 and	 al, 3
  00017	3c 02		 cmp	 al, 2
  00019	74 48		 je	 SHORT $LN5@PyUnicode_@49

; 14439:         _PyUnicode_STATE(*p).interned = SSTATE_INTERNED_IMMORTAL;

  0001b	41 83 63 70 fe	 and	 DWORD PTR [r11+112], -2	; fffffffeH
  00020	41 83 4b 70 02	 or	 DWORD PTR [r11+112], 2

; 14440:         Py_INCREF(*p);

  00025	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
  00028	e8 00 00 00 00	 call	 _Py_PXCTX
  0002d	85 c0		 test	 eax, eax
  0002f	75 32		 jne	 SHORT $LN5@PyUnicode_@49
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0003f	4c 8b cb	 mov	 r9, rbx
  00042	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00048	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00050	e8 00 00 00 00	 call	 _PyParallel_Guard
  00055	85 c0		 test	 eax, eax
  00057	75 06		 jne	 SHORT $LN4@PyUnicode_@49
  00059	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0005d	74 04		 je	 SHORT $LN5@PyUnicode_@49
$LN4@PyUnicode_@49:
  0005f	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN5@PyUnicode_@49:

; 14441:     }
; 14442: }

  00063	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00067	5b		 pop	 rbx
  00068	c3		 ret	 0
PyUnicode_InternImmortal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@MBHELLPB@total?5size?5of?5all?5interned?5strin@ ; `string'
PUBLIC	??_C@_0BI@JBMCLEAA@could?5not?5ready?5string?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@GDFEBIA@releasing?5?$CFId?5interned?5strings?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@NHODKJIO@_Py_ReleaseInternedUnicodeString@ ; `string'
PUBLIC	_Py_ReleaseInternedUnicodeStrings
EXTRN	PyDict_Clear:PROC
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
EXTRN	PyDict_Keys:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_ReleaseInternedUnicodeStrings DD imagerel $LN27
	DD	imagerel $LN27+87
	DD	imagerel $unwind$_Py_ReleaseInternedUnicodeStrings
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_Py_ReleaseInternedUnicodeStrings DD imagerel $LN27+87
	DD	imagerel $LN27+129
	DD	imagerel $chain$0$_Py_ReleaseInternedUnicodeStrings
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_Py_ReleaseInternedUnicodeStrings DD imagerel $LN27+129
	DD	imagerel $LN27+180
	DD	imagerel $chain$2$_Py_ReleaseInternedUnicodeStrings
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_Py_ReleaseInternedUnicodeStrings DD imagerel $LN27+180
	DD	imagerel $LN27+323
	DD	imagerel $chain$3$_Py_ReleaseInternedUnicodeStrings
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_Py_ReleaseInternedUnicodeStrings DD imagerel $LN27+323
	DD	imagerel $LN27+394
	DD	imagerel $chain$4$_Py_ReleaseInternedUnicodeStrings
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$_Py_ReleaseInternedUnicodeStrings DD imagerel $LN27+394
	DD	imagerel $LN27+467
	DD	imagerel $chain$5$_Py_ReleaseInternedUnicodeStrings
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$_Py_ReleaseInternedUnicodeStrings DD imagerel $LN27+467
	DD	imagerel $LN27+477
	DD	imagerel $chain$7$_Py_ReleaseInternedUnicodeStrings
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$_Py_ReleaseInternedUnicodeStrings DD imagerel $LN27+477
	DD	imagerel $LN27+486
	DD	imagerel $chain$8$_Py_ReleaseInternedUnicodeStrings
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$_Py_ReleaseInternedUnicodeStrings DD 021H
	DD	imagerel $LN27
	DD	imagerel $LN27+87
	DD	imagerel $unwind$_Py_ReleaseInternedUnicodeStrings
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$_Py_ReleaseInternedUnicodeStrings DD 020021H
	DD	0c6400H
	DD	imagerel $LN27
	DD	imagerel $LN27+87
	DD	imagerel $unwind$_Py_ReleaseInternedUnicodeStrings
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$_Py_ReleaseInternedUnicodeStrings DD 021H
	DD	imagerel $LN27+87
	DD	imagerel $LN27+129
	DD	imagerel $chain$0$_Py_ReleaseInternedUnicodeStrings
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_Py_ReleaseInternedUnicodeStrings DD 021H
	DD	imagerel $LN27+129
	DD	imagerel $LN27+180
	DD	imagerel $chain$2$_Py_ReleaseInternedUnicodeStrings
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_Py_ReleaseInternedUnicodeStrings DD 020521H
	DD	0a3405H
	DD	imagerel $LN27+129
	DD	imagerel $LN27+180
	DD	imagerel $chain$2$_Py_ReleaseInternedUnicodeStrings
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_Py_ReleaseInternedUnicodeStrings DD 040e21H
	DD	06740eH
	DD	0b5405H
	DD	imagerel $LN27+87
	DD	imagerel $LN27+129
	DD	imagerel $chain$0$_Py_ReleaseInternedUnicodeStrings
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_Py_ReleaseInternedUnicodeStrings DD 020521H
	DD	0c6405H
	DD	imagerel $LN27
	DD	imagerel $LN27+87
	DD	imagerel $unwind$_Py_ReleaseInternedUnicodeStrings
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_ReleaseInternedUnicodeStrings DD 030801H
	DD	0d0046208H
	DD	0c002H
xdata	ENDS
;	COMDAT ??_C@_0DN@MBHELLPB@total?5size?5of?5all?5interned?5strin@
CONST	SEGMENT
??_C@_0DN@MBHELLPB@total?5size?5of?5all?5interned?5strin@ DB 'total size '
	DB	'of all interned strings: %Id/%Id mortal/immortal', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JBMCLEAA@could?5not?5ready?5string?6?$AA@
CONST	SEGMENT
??_C@_0BI@JBMCLEAA@could?5not?5ready?5string?6?$AA@ DB 'could not ready s'
	DB	'tring', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GDFEBIA@releasing?5?$CFId?5interned?5strings?6?$AA@
CONST	SEGMENT
??_C@_0CA@GDFEBIA@releasing?5?$CFId?5interned?5strings?6?$AA@ DB 'releasi'
	DB	'ng %Id interned strings', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NHODKJIO@_Py_ReleaseInternedUnicodeString@
CONST	SEGMENT
??_C@_0CC@NHODKJIO@_Py_ReleaseInternedUnicodeString@ DB '_Py_ReleaseInter'
	DB	'nedUnicodeStrings', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_ReleaseInternedUnicodeStrings
_TEXT	SEGMENT
_Py_ReleaseInternedUnicodeStrings PROC			; COMDAT

; 14460: {

$LN27:
  00000	41 54		 push	 r12
  00002	41 55		 push	 r13
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 14461:     PyObject *keys;
; 14462:     PyObject *s;
; 14463:     Py_ssize_t i, n;
; 14464:     Py_ssize_t immortal_size = 0, mortal_size = 0;

  00008	45 33 e4	 xor	 r12d, r12d
  0000b	45 33 ed	 xor	 r13d, r13d

; 14465:     Py_GUARD

  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	85 c0		 test	 eax, eax
  00015	74 1c		 je	 SHORT $LN19@Py_Release
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@NHODKJIO@_Py_ReleaseInternedUnicodeString@
  00025	45 33 c9	 xor	 r9d, r9d
  00028	41 b8 81 38 00
	00		 mov	 r8d, 14465		; 00003881H
  0002e	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN19@Py_Release:

; 14466: 
; 14467:     if (interned == NULL || !PyDict_Check(interned))

  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR interned
  0003a	48 85 c9	 test	 rcx, rcx
  0003d	0f 84 9a 01 00
	00		 je	 $LN2@Py_Release
  00043	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00047	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  00051	0f 84 86 01 00
	00		 je	 $LN2@Py_Release

; 14468:         return;
; 14469:     keys = PyDict_Keys(interned);

  00057	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  0005c	e8 00 00 00 00	 call	 PyDict_Keys
  00061	48 8b f0	 mov	 rsi, rax

; 14470:     if (keys == NULL || !PyList_Check(keys)) {

  00064	48 85 c0	 test	 rax, rax
  00067	0f 84 66 01 00
	00		 je	 $LN15@Py_Release
  0006d	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00071	f7 81 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rcx+256], 33554432 ; 02000000H
  0007b	0f 84 52 01 00
	00		 je	 $LN15@Py_Release

; 14472:         return;
; 14473:     }
; 14474: 
; 14475:     /* Since _Py_ReleaseInternedUnicodeStrings() is intended to help a leak
; 14476:        detector, interned unicode strings are not forcibly deallocated;
; 14477:        rather, we give them their stolen references back, and then clear
; 14478:        and DECREF the interned dict. */
; 14479: 
; 14480:     n = PyList_GET_SIZE(keys);

  00081	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  00086	48 8b 68 60	 mov	 rbp, QWORD PTR [rax+96]
  0008a	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 14481:     fprintf(stderr, "releasing %" PY_FORMAT_SIZE_T "d interned strings\n",
; 14482:             n);

  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@GDFEBIA@releasing?5?$CFId?5interned?5strings?6?$AA@
  0009c	4c 8b c5	 mov	 r8, rbp
  0009f	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 14483:     for (i = 0; i < n; i++) {

  000a9	33 ff		 xor	 edi, edi
  000ab	48 85 ed	 test	 rbp, rbp
  000ae	0f 8e 8f 00 00
	00		 jle	 $LN12@Py_Release
  000b4	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  000b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL14@Py_Release:

; 14484:         s = PyList_GET_ITEM(keys, i);

  000c0	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  000c4	48 8b 1c f8	 mov	 rbx, QWORD PTR [rax+rdi*8]

; 14485:         if (PyUnicode_READY(s) == -1) {

  000c8	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  000cc	75 24		 jne	 SHORT $LN11@Py_Release
  000ce	48 8b cb	 mov	 rcx, rbx
  000d1	e8 00 00 00 00	 call	 _PyUnicode_Ready
  000d6	83 f8 ff	 cmp	 eax, -1
  000d9	75 17		 jne	 SHORT $LN11@Py_Release

; 14486:             assert(0 && "could not ready string");
; 14487:             fprintf(stderr, "could not ready string\n");

  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@JBMCLEAA@could?5not?5ready?5string?6?$AA@
  000e8	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf
$LN11@Py_Release:

; 14488:         }
; 14489:         switch (PyUnicode_CHECK_INTERNED(s)) {

  000f2	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  000f5	83 e0 03	 and	 eax, 3
  000f8	74 38		 je	 SHORT $LN8@Py_Release
  000fa	ff c8		 dec	 eax
  000fc	74 20		 je	 SHORT $LN6@Py_Release
  000fe	ff c8		 dec	 eax
  00100	74 0e		 je	 SHORT $LN7@Py_Release

; 14501:             break;
; 14502:         default:
; 14503:             Py_FatalError("Inconsistent interned string state.");

  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@OHLDAHGF@Inconsistent?5interned?5string?5sta@
  00109	e8 00 00 00 00	 call	 Py_FatalError
  0010e	eb 22		 jmp	 SHORT $LN8@Py_Release
$LN7@Py_Release:

; 14490:         case SSTATE_NOT_INTERNED:
; 14491:             /* XXX Shouldn't happen */
; 14492:             break;
; 14493:         case SSTATE_INTERNED_IMMORTAL:
; 14494:             Py_INCREF(s);

  00110	48 8b cb	 mov	 rcx, rbx
  00113	e8 00 00 00 00	 call	 _Py_IncRef

; 14495:             immortal_size += PyUnicode_GET_LENGTH(s);

  00118	4c 03 63 60	 add	 r12, QWORD PTR [rbx+96]

; 14496:             break;

  0011c	eb 14		 jmp	 SHORT $LN8@Py_Release
$LN6@Py_Release:

; 14497:         case SSTATE_INTERNED_MORTAL:
; 14498:             Py_INCREF(s);

  0011e	48 8b cb	 mov	 rcx, rbx
  00121	e8 00 00 00 00	 call	 _Py_IncRef

; 14499:             Py_INCREF(s);

  00126	48 8b cb	 mov	 rcx, rbx
  00129	e8 00 00 00 00	 call	 _Py_IncRef

; 14500:             mortal_size += PyUnicode_GET_LENGTH(s);

  0012e	4c 03 6b 60	 add	 r13, QWORD PTR [rbx+96]
$LN8@Py_Release:

; 14504:         }
; 14505:         _PyUnicode_STATE(s).interned = SSTATE_NOT_INTERNED;

  00132	83 63 70 fc	 and	 DWORD PTR [rbx+112], -4	; fffffffcH
  00136	48 ff c7	 inc	 rdi
  00139	48 3b fd	 cmp	 rdi, rbp
  0013c	7c 82		 jl	 SHORT $LL14@Py_Release
  0013e	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
$LN12@Py_Release:

; 14506:     }
; 14507:     fprintf(stderr, "total size of all interned strings: "
; 14508:             "%" PY_FORMAT_SIZE_T "d/%" PY_FORMAT_SIZE_T "d "
; 14509:             "mortal/immortal\n", mortal_size, immortal_size);

  00143	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00149	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@MBHELLPB@total?5size?5of?5all?5interned?5strin@
  00150	4d 8b cc	 mov	 r9, r12
  00153	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00157	4d 8b c5	 mov	 r8, r13
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 14510:     Py_DECREF(keys);

  00160	48 8b ce	 mov	 rcx, rsi
  00163	e8 00 00 00 00	 call	 _Py_DecRef

; 14511:     PyDict_Clear(interned);

  00168	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR interned
  0016f	e8 00 00 00 00	 call	 PyDict_Clear

; 14512:     Py_CLEAR(interned);

  00174	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR interned
  0017b	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00180	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00185	4d 85 c9	 test	 r9, r9
  00188	74 4e		 je	 SHORT $LN26@Py_Release
  0018a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00191	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@NHODKJIO@_Py_ReleaseInternedUnicodeString@
  00198	41 b8 b0 38 00
	00		 mov	 r8d, 14512		; 000038b0H
  0019e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001a6	e8 00 00 00 00	 call	 _PyParallel_Guard
  001ab	85 c0		 test	 eax, eax
  001ad	75 29		 jne	 SHORT $LN26@Py_Release
  001af	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR interned
  001b6	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR interned, 0
  001c1	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]

; 14513: }

  001c6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001ca	41 5d		 pop	 r13
  001cc	41 5c		 pop	 r12
  001ce	e9 00 00 00 00	 jmp	 _Py_DecRef
$LN15@Py_Release:

; 14471:         PyErr_Clear();

  001d3	e8 00 00 00 00	 call	 PyErr_Clear
$LN26@Py_Release:
  001d8	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
$LN2@Py_Release:

; 14513: }

  001dd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001e1	41 5d		 pop	 r13
  001e3	41 5c		 pop	 r12
  001e5	c3		 ret	 0
_Py_ReleaseInternedUnicodeStrings ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@BNKDGIIG@unicodeiter_dealloc?$AA@	; `string'
EXTRN	PyObject_GC_Del:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$unicodeiter_dealloc DD imagerel unicodeiter_dealloc
	DD	imagerel unicodeiter_dealloc+338
	DD	imagerel $unwind$unicodeiter_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicodeiter_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0BE@BNKDGIIG@unicodeiter_dealloc?$AA@
CONST	SEGMENT
??_C@_0BE@BNKDGIIG@unicodeiter_dealloc?$AA@ DB 'unicodeiter_dealloc', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT unicodeiter_dealloc
_TEXT	SEGMENT
it$ = 64
unicodeiter_dealloc PROC				; COMDAT

; 14526: {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 14527:     Py_GUARD

  0000d	e8 00 00 00 00	 call	 _Py_PXCTX
  00012	85 c0		 test	 eax, eax
  00014	74 1c		 je	 SHORT $LN9@unicodeite
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@BNKDGIIG@unicodeiter_dealloc?$AA@
  00024	45 33 c9	 xor	 r9d, r9d
  00027	41 b8 bf 38 00
	00		 mov	 r8d, 14527		; 000038bfH
  0002d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@unicodeite:

; 14528:     _PyObject_GC_UNTRACK(it);

  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@BNKDGIIG@unicodeiter_dealloc?$AA@
  00040	4c 8b cf	 mov	 r9, rdi
  00043	41 b8 c0 38 00
	00		 mov	 r8d, 14528		; 000038c0H
  00049	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00051	e8 00 00 00 00	 call	 _PyParallel_Guard
  00056	85 c0		 test	 eax, eax
  00058	75 54		 jne	 SHORT $LN5@unicodeite
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@BNKDGIIG@unicodeiter_dealloc?$AA@
  00068	4c 8b cf	 mov	 r9, rdi
  0006b	41 b8 c0 38 00
	00		 mov	 r8d, 14528		; 000038c0H
  00071	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00079	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007e	85 c0		 test	 eax, eax
  00080	74 04		 je	 SHORT $LN12@unicodeite
  00082	33 d2		 xor	 edx, edx
  00084	eb 04		 jmp	 SHORT $LN13@unicodeite
$LN12@unicodeite:
  00086	48 8d 57 e8	 lea	 rdx, QWORD PTR [rdi-24]
$LN13@unicodeite:
  0008a	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0008d	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  00091	48 c7 42 10 fe
	ff ff ff	 mov	 QWORD PTR [rdx+16], -2
  00099	48 89 01	 mov	 QWORD PTR [rcx], rax
  0009c	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  0009f	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  000a3	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  000a7	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0
$LN5@unicodeite:

; 14529:     Py_XDECREF(it->it_seq);

  000ae	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
  000b2	48 85 db	 test	 rbx, rbx
  000b5	0f 84 85 00 00
	00		 je	 $LN3@unicodeite
  000bb	e8 00 00 00 00	 call	 _Py_PXCTX
  000c0	85 c0		 test	 eax, eax
  000c2	75 7c		 jne	 SHORT $LN3@unicodeite
  000c4	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000c8	a8 20		 test	 al, 32			; 00000020H
  000ca	75 6c		 jne	 SHORT $LN18@unicodeite
  000cc	84 c0		 test	 al, al
  000ce	78 68		 js	 SHORT $LN18@unicodeite
  000d0	a8 02		 test	 al, 2
  000d2	75 6c		 jne	 SHORT $LN3@unicodeite
  000d4	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000d8	75 66		 jne	 SHORT $LN3@unicodeite
  000da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000e8	4c 8b cb	 mov	 r9, rbx
  000eb	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000f1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000f9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000fe	48 8b cb	 mov	 rcx, rbx
  00101	85 c0		 test	 eax, eax
  00103	74 17		 je	 SHORT $LN23@unicodeite
  00105	e8 00 00 00 00	 call	 _Px_Dealloc

; 14530:     PyObject_GC_Del(it);

  0010a	48 8b cf	 mov	 rcx, rdi

; 14531: }

  0010d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00112	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00116	5f		 pop	 rdi
  00117	e9 00 00 00 00	 jmp	 PyObject_GC_Del

; 14529:     Py_XDECREF(it->it_seq);

$LN23@unicodeite:
  0011c	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00120	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 14530:     PyObject_GC_Del(it);

  00126	48 8b cf	 mov	 rcx, rdi

; 14531: }

  00129	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0012e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00132	5f		 pop	 rdi
  00133	e9 00 00 00 00	 jmp	 PyObject_GC_Del

; 14529:     Py_XDECREF(it->it_seq);

$LN18@unicodeite:
  00138	48 8b cb	 mov	 rcx, rbx
  0013b	e8 00 00 00 00	 call	 Px_DecRef
$LN3@unicodeite:

; 14530:     PyObject_GC_Del(it);

  00140	48 8b cf	 mov	 rcx, rdi

; 14531: }

  00143	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00148	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014c	5f		 pop	 rdi
  0014d	e9 00 00 00 00	 jmp	 PyObject_GC_Del
unicodeiter_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@NHPKAPGC@unicodeiter_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicodeiter_traverse DD imagerel unicodeiter_traverse
	DD	imagerel unicodeiter_traverse+134
	DD	imagerel $unwind$unicodeiter_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicodeiter_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BF@NHPKAPGC@unicodeiter_traverse?$AA@
CONST	SEGMENT
??_C@_0BF@NHPKAPGC@unicodeiter_traverse?$AA@ DB 'unicodeiter_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicodeiter_traverse
_TEXT	SEGMENT
it$ = 48
visit$ = 56
arg$ = 64
unicodeiter_traverse PROC				; COMDAT

; 14535: {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 14536:     Py_GUARD

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN6@unicodeite@2
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@NHPKAPGC@unicodeiter_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 c8 38 00
	00		 mov	 r8d, 14536		; 000038c8H
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN6@unicodeite@2:

; 14537:     Py_VISIT(it->it_seq);

  0003d	e8 00 00 00 00	 call	 _Py_PXCTX
  00042	85 c0		 test	 eax, eax
  00044	74 1c		 je	 SHORT $LN3@unicodeite@2
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@NHPKAPGC@unicodeiter_traverse?$AA@
  00054	45 33 c9	 xor	 r9d, r9d
  00057	41 b8 c9 38 00
	00		 mov	 r8d, 14537		; 000038c9H
  0005d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@unicodeite@2:
  00062	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00066	48 85 c9	 test	 rcx, rcx
  00069	74 09		 je	 SHORT $LN5@unicodeite@2
  0006b	48 8b d7	 mov	 rdx, rdi
  0006e	ff d6		 call	 rsi
  00070	85 c0		 test	 eax, eax
  00072	75 02		 jne	 SHORT $LN8@unicodeite@2
$LN5@unicodeite@2:

; 14538:     return 0;

  00074	33 c0		 xor	 eax, eax
$LN8@unicodeite@2:

; 14539: }

  00076	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00080	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00084	5f		 pop	 rdi
  00085	c3		 ret	 0
unicodeiter_traverse ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicodeiter_next DD imagerel unicodeiter_next
	DD	imagerel unicodeiter_next+140
	DD	imagerel $unwind$unicodeiter_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicodeiter_next DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicodeiter_next
_TEXT	SEGMENT
it$ = 48
unicodeiter_next PROC					; COMDAT

; 14543: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 14544:     PyObject *seq, *item;
; 14545: 
; 14546:     assert(it != NULL);
; 14547:     seq = it->it_seq;

  00009	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]

; 14548:     if (seq == NULL)

  0000d	48 85 c9	 test	 rcx, rcx

; 14549:         return NULL;

  00010	74 72		 je	 SHORT $LN14@unicodeite@3

; 14550:     assert(_PyUnicode_CHECK(seq));
; 14551: 
; 14552:     if (it->it_index < PyUnicode_GET_LENGTH(seq)) {

  00012	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  00016	48 3b 51 60	 cmp	 rdx, QWORD PTR [rcx+96]
  0001a	7d 5b		 jge	 SHORT $LN2@unicodeite@3

; 14553:         int kind = PyUnicode_KIND(seq);

  0001c	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  0001f	44 8b c0	 mov	 r8d, eax
  00022	41 c1 e8 02	 shr	 r8d, 2
  00026	41 83 e0 07	 and	 r8d, 7

; 14554:         void *data = PyUnicode_DATA(seq);

  0002a	a8 20		 test	 al, 32			; 00000020H
  0002c	74 13		 je	 SHORT $LN8@unicodeite@3
  0002e	a8 40		 test	 al, 64			; 00000040H
  00030	74 06		 je	 SHORT $LN6@unicodeite@3
  00032	48 83 e9 80	 sub	 rcx, -128		; ffffffffffffff80H
  00036	eb 10		 jmp	 SHORT $LN9@unicodeite@3
$LN6@unicodeite@3:
  00038	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  0003f	eb 07		 jmp	 SHORT $LN9@unicodeite@3
$LN8@unicodeite@3:
  00041	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
$LN9@unicodeite@3:

; 14555:         Py_UCS4 chr = PyUnicode_READ(kind, data, it->it_index);

  00048	41 83 f8 01	 cmp	 r8d, 1
  0004c	75 06		 jne	 SHORT $LN12@unicodeite@3
  0004e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00052	eb 0f		 jmp	 SHORT $LN11@unicodeite@3
$LN12@unicodeite@3:
  00054	41 83 f8 02	 cmp	 r8d, 2
  00058	75 06		 jne	 SHORT $LN10@unicodeite@3
  0005a	0f b7 0c 51	 movzx	 ecx, WORD PTR [rcx+rdx*2]
  0005e	eb 03		 jmp	 SHORT $LN11@unicodeite@3
$LN10@unicodeite@3:
  00060	8b 0c 91	 mov	 ecx, DWORD PTR [rcx+rdx*4]
$LN11@unicodeite@3:

; 14556:         item = PyUnicode_FromOrdinal(chr);

  00063	e8 00 00 00 00	 call	 PyUnicode_FromOrdinal

; 14557:         if (item != NULL)

  00068	48 85 c0	 test	 rax, rax
  0006b	74 19		 je	 SHORT $LN4@unicodeite@3

; 14558:             ++it->it_index;

  0006d	48 ff 43 60	 inc	 QWORD PTR [rbx+96]

; 14565: }

  00071	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00075	5b		 pop	 rbx
  00076	c3		 ret	 0
$LN2@unicodeite@3:

; 14559:         return item;
; 14560:     }
; 14561: 
; 14562:     Py_DECREF(seq);

  00077	e8 00 00 00 00	 call	 _Py_DecRef

; 14563:     it->it_seq = NULL;

  0007c	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0
$LN14@unicodeite@3:

; 14564:     return NULL;

  00084	33 c0		 xor	 eax, eax
$LN4@unicodeite@3:

; 14565: }

  00086	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008a	5b		 pop	 rbx
  0008b	c3		 ret	 0
unicodeiter_next ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT unicodeiter_len
_TEXT	SEGMENT
it$ = 8
unicodeiter_len PROC					; COMDAT

; 14569: {

  00000	48 8b c1	 mov	 rax, rcx

; 14570:     Py_ssize_t len = 0;

  00003	33 c9		 xor	 ecx, ecx

; 14571:     if (it->it_seq)

  00005	48 8b 50 68	 mov	 rdx, QWORD PTR [rax+104]
  00009	48 85 d2	 test	 rdx, rdx
  0000c	74 08		 je	 SHORT $LN1@unicodeite@4

; 14572:         len = PyUnicode_GET_LENGTH(it->it_seq) - it->it_index;

  0000e	48 8b 4a 60	 mov	 rcx, QWORD PTR [rdx+96]
  00012	48 2b 48 60	 sub	 rcx, QWORD PTR [rax+96]
$LN1@unicodeite@4:

; 14573:     return PyLong_FromSsize_t(len);
; 14574: }

  00016	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
unicodeiter_len ENDP
_TEXT	ENDS
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$unicodeiter_setstate DD imagerel unicodeiter_setstate
	DD	imagerel unicodeiter_setstate+134
	DD	imagerel $unwind$unicodeiter_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicodeiter_setstate DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT unicodeiter_setstate
_TEXT	SEGMENT
it$ = 64
state$ = 72
unicodeiter_setstate PROC				; COMDAT

; 14596: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 14597:     Py_ssize_t index = PyLong_AsSsize_t(state);

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	e8 00 00 00 00	 call	 PyLong_AsSsize_t

; 14598:     if (index == -1 && PyErr_Occurred())

  00011	48 83 f8 ff	 cmp	 rax, -1
  00015	75 12		 jne	 SHORT $LN2@unicodeite@5
  00017	e8 00 00 00 00	 call	 PyErr_Occurred
  0001c	48 85 c0	 test	 rax, rax
  0001f	74 0d		 je	 SHORT $LN9@unicodeite@5

; 14599:         return NULL;

  00021	33 c0		 xor	 eax, eax

; 14604: }

  00023	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
$LN2@unicodeite@5:

; 14600:     if (index < 0)

  00029	48 85 c0	 test	 rax, rax
  0002c	79 02		 jns	 SHORT $LN1@unicodeite@5
$LN9@unicodeite@5:

; 14601:         index = 0;

  0002e	33 c0		 xor	 eax, eax
$LN1@unicodeite@5:

; 14602:     it->it_index = index;

  00030	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 14603:     Py_RETURN_NONE;

  00034	e8 00 00 00 00	 call	 _Py_PXCTX
  00039	85 c0		 test	 eax, eax
  0003b	75 3c		 jne	 SHORT $LN6@unicodeite@5
  0003d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00052	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00058	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00060	e8 00 00 00 00	 call	 _PyParallel_Guard
  00065	85 c0		 test	 eax, eax
  00067	75 09		 jne	 SHORT $LN5@unicodeite@5
  00069	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00070	74 07		 je	 SHORT $LN6@unicodeite@5
$LN5@unicodeite@5:
  00072	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN6@unicodeite@5:
  00079	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 14604: }

  00080	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00084	5b		 pop	 rbx
  00085	c3		 ret	 0
unicodeiter_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ ; `string'
PUBLIC	??_C@_0N@FHDNNHCO@unicode_iter?$AA@		; `string'
EXTRN	_PyGC_generation0:QWORD
EXTRN	_PyObject_GC_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_iter DD imagerel unicode_iter
	DD	imagerel unicode_iter+66
	DD	imagerel $unwind$unicode_iter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_iter DD imagerel unicode_iter+66
	DD	imagerel unicode_iter+118
	DD	imagerel $chain$0$unicode_iter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$unicode_iter DD imagerel unicode_iter+118
	DD	imagerel unicode_iter+310
	DD	imagerel $chain$3$unicode_iter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$unicode_iter DD 040521H
	DD	083405H
	DD	097400H
	DD	imagerel unicode_iter
	DD	imagerel unicode_iter+66
	DD	imagerel $unwind$unicode_iter
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_iter DD 020521H
	DD	097405H
	DD	imagerel unicode_iter
	DD	imagerel unicode_iter+66
	DD	imagerel $unwind$unicode_iter
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_iter DD 020601H
	DD	060025206H
xdata	ENDS
;	COMDAT ??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
CONST	SEGMENT
??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ DB 'GC object alread'
	DB	'y tracked', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FHDNNHCO@unicode_iter?$AA@
CONST	SEGMENT
??_C@_0N@FHDNNHCO@unicode_iter?$AA@ DB 'unicode_iter', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_iter
_TEXT	SEGMENT
seq$ = 64
unicode_iter PROC					; COMDAT

; 14653: {

  00000	40 56		 push	 rsi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 14654:     unicodeiterobject *it;
; 14655: 
; 14656:     if (!PyUnicode_Check(seq)) {

  00006	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000a	48 8b f1	 mov	 rsi, rcx
  0000d	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00017	75 19		 jne	 SHORT $LN8@unicode_it

; 14657:         PyErr_BadInternalCall();

  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00020	ba 41 39 00 00	 mov	 edx, 14657		; 00003941H
  00025	e8 00 00 00 00	 call	 _PyErr_BadInternalCall
$LN19@unicode_it:

; 14658:         return NULL;

  0002a	33 c0		 xor	 eax, eax

; 14670: }

  0002c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00030	5e		 pop	 rsi
  00031	c3		 ret	 0
$LN8@unicode_it:

; 14659:     }
; 14660:     if (PyUnicode_READY(seq) == -1)

  00032	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00036	75 0a		 jne	 SHORT $LN7@unicode_it
  00038	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0003d	83 f8 ff	 cmp	 eax, -1

; 14661:         return NULL;

  00040	74 e8		 je	 SHORT $LN19@unicode_it
$LN7@unicode_it:
  00042	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 14662:     it = PyObject_GC_New(unicodeiterobject, &PyUnicodeIter_Type);

  00047	e8 00 00 00 00	 call	 _Py_PXCTX
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyUnicodeIter_Type
  00053	85 c0		 test	 eax, eax
  00055	74 07		 je	 SHORT $LN13@unicode_it
  00057	e8 00 00 00 00	 call	 _PxObject_New
  0005c	eb 05		 jmp	 SHORT $LN18@unicode_it
$LN13@unicode_it:
  0005e	e8 00 00 00 00	 call	 _PyObject_GC_New
$LN18@unicode_it:
  00063	48 8b f8	 mov	 rdi, rax

; 14663:     if (it == NULL)

  00066	48 85 c0	 test	 rax, rax
  00069	75 0b		 jne	 SHORT $LN6@unicode_it
  0006b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 14670: }

  00070	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00074	5e		 pop	 rsi
  00075	c3		 ret	 0
$LN6@unicode_it:
  00076	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 14664:         return NULL;
; 14665:     it->it_index = 0;

  0007b	33 db		 xor	 ebx, ebx

; 14666:     Py_INCREF(seq);

  0007d	48 8b ce	 mov	 rcx, rsi
  00080	48 89 5f 60	 mov	 QWORD PTR [rdi+96], rbx
  00084	e8 00 00 00 00	 call	 _Py_IncRef

; 14667:     it->it_seq = seq;
; 14668:     _PyObject_GC_TRACK(it);

  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@FHDNNHCO@unicode_iter?$AA@
  00097	4c 8b cf	 mov	 r9, rdi
  0009a	41 b8 4c 39 00
	00		 mov	 r8d, 14668		; 0000394cH
  000a0	48 89 77 68	 mov	 QWORD PTR [rdi+104], rsi
  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b1	85 c0		 test	 eax, eax
  000b3	75 6e		 jne	 SHORT $LN2@unicode_it
  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@FHDNNHCO@unicode_iter?$AA@
  000c3	4c 8b cf	 mov	 r9, rdi
  000c6	41 b8 4c 39 00
	00		 mov	 r8d, 14668		; 0000394cH
  000cc	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d4	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d9	85 c0		 test	 eax, eax
  000db	75 04		 jne	 SHORT $LN16@unicode_it
  000dd	48 8d 5f e8	 lea	 rbx, QWORD PTR [rdi-24]
$LN16@unicode_it:
  000e1	48 83 7b 10 fe	 cmp	 QWORD PTR [rbx+16], -2
  000e6	74 0c		 je	 SHORT $LN1@unicode_it
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
  000ef	e8 00 00 00 00	 call	 Py_FatalError
$LN1@unicode_it:
  000f4	48 c7 43 10 fd
	ff ff ff	 mov	 QWORD PTR [rbx+16], -3
  000fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  00103	48 89 03	 mov	 QWORD PTR [rbx], rax
  00106	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  0010d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00111	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx
  00115	48 89 19	 mov	 QWORD PTR [rcx], rbx
  00118	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  0011f	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
$LN2@unicode_it:

; 14669:     return (PyObject *)it;

  00123	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00128	48 8b c7	 mov	 rax, rdi
  0012b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 14670: }

  00130	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00134	5e		 pop	 rsi
  00135	c3		 ret	 0
unicode_iter ENDP
_TEXT	ENDS
PUBLIC	Py_UNICODE_strlen
; Function compile flags: /Ogtpy
;	COMDAT Py_UNICODE_strlen
_TEXT	SEGMENT
u$ = 8
Py_UNICODE_strlen PROC					; COMDAT

; 14676:     int res = 0;

  00000	33 c0		 xor	 eax, eax

; 14677:     while(*u++)

  00002	66 39 01	 cmp	 WORD PTR [rcx], ax
  00005	74 15		 je	 SHORT $LN8@Py_UNICODE
  00007	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@Py_UNICODE:
  00010	48 83 c1 02	 add	 rcx, 2

; 14678:         res++;

  00014	ff c0		 inc	 eax
  00016	66 83 39 00	 cmp	 WORD PTR [rcx], 0
  0001a	75 f4		 jne	 SHORT $LL2@Py_UNICODE
$LN8@Py_UNICODE:

; 14679:     return res;

  0001c	48 98		 cdqe

; 14680: }

  0001e	c3		 ret	 0
Py_UNICODE_strlen ENDP
_TEXT	ENDS
PUBLIC	Py_UNICODE_strcpy
; Function compile flags: /Ogtpy
;	COMDAT Py_UNICODE_strcpy
_TEXT	SEGMENT
s1$ = 8
s2$ = 16
Py_UNICODE_strcpy PROC					; COMDAT

; 14685:     Py_UNICODE *u = s1;
; 14686:     while ((*u++ = *s2++));

  00000	4c 8b c1	 mov	 r8, rcx
  00003	4c 2b c2	 sub	 r8, rdx
  00006	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL2@Py_UNICODE@2:
  00010	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  00013	48 83 c2 02	 add	 rdx, 2
  00017	66 41 89 44 10
	fe		 mov	 WORD PTR [r8+rdx-2], ax
  0001d	66 85 c0	 test	 ax, ax
  00020	75 ee		 jne	 SHORT $LL2@Py_UNICODE@2

; 14687:     return s1;

  00022	48 8b c1	 mov	 rax, rcx

; 14688: }

  00025	c3		 ret	 0
Py_UNICODE_strcpy ENDP
_TEXT	ENDS
PUBLIC	Py_UNICODE_strncpy
; Function compile flags: /Ogtpy
;	COMDAT Py_UNICODE_strncpy
_TEXT	SEGMENT
s1$ = 8
s2$ = 16
n$ = 24
Py_UNICODE_strncpy PROC					; COMDAT

; 14693:     Py_UNICODE *u = s1;
; 14694:     while ((*u++ = *s2++))

  00000	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  00003	66 89 01	 mov	 WORD PTR [rcx], ax
  00006	66 85 c0	 test	 ax, ax
  00009	74 22		 je	 SHORT $LN10@Py_UNICODE@3
  0000b	4c 8b c9	 mov	 r9, rcx
  0000e	4c 2b ca	 sub	 r9, rdx
$LL3@Py_UNICODE@3:

; 14695:         if (n-- == 0)

  00011	49 8b c0	 mov	 rax, r8
  00014	48 83 c2 02	 add	 rdx, 2
  00018	49 ff c8	 dec	 r8
  0001b	48 85 c0	 test	 rax, rax
  0001e	74 0d		 je	 SHORT $LN10@Py_UNICODE@3

; 14693:     Py_UNICODE *u = s1;
; 14694:     while ((*u++ = *s2++))

  00020	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  00023	66 41 89 04 11	 mov	 WORD PTR [r9+rdx], ax
  00028	66 85 c0	 test	 ax, ax
  0002b	75 e4		 jne	 SHORT $LL3@Py_UNICODE@3
$LN10@Py_UNICODE@3:

; 14696:             break;
; 14697:     return s1;

  0002d	48 8b c1	 mov	 rax, rcx

; 14698: }

  00030	c3		 ret	 0
Py_UNICODE_strncpy ENDP
_TEXT	ENDS
PUBLIC	Py_UNICODE_strcat
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_UNICODE_strcat DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$Py_UNICODE_strcat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_UNICODE_strcat DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT Py_UNICODE_strcat
_TEXT	SEGMENT
s1$ = 48
s2$ = 56
Py_UNICODE_strcat PROC					; COMDAT

; 14702: {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b c9	 mov	 r9, rcx

; 14703:     Py_UNICODE *u1 = s1;
; 14704:     u1 += Py_UNICODE_strlen(u1);

  00007	e8 00 00 00 00	 call	 Py_UNICODE_strlen
  0000c	49 8d 0c 41	 lea	 rcx, QWORD PTR [r9+rax*2]

; 14705:     Py_UNICODE_strcpy(u1, s2);

  00010	e8 00 00 00 00	 call	 Py_UNICODE_strcpy

; 14706:     return s1;

  00015	49 8b c1	 mov	 rax, r9

; 14707: }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
Py_UNICODE_strcat ENDP
_TEXT	ENDS
PUBLIC	Py_UNICODE_strcmp
; Function compile flags: /Ogtpy
;	COMDAT Py_UNICODE_strcmp
_TEXT	SEGMENT
s1$ = 8
s2$ = 16
Py_UNICODE_strcmp PROC					; COMDAT

; 14712:     while (*s1 && *s2 && *s1 == *s2)

  00000	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00003	66 85 c0	 test	 ax, ax
  00006	74 29		 je	 SHORT $LN2@Py_UNICODE@4
  00008	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@Py_UNICODE@4:
  00010	44 0f b7 02	 movzx	 r8d, WORD PTR [rdx]
  00014	66 45 85 c0	 test	 r8w, r8w
  00018	74 21		 je	 SHORT $LN4@Py_UNICODE@4
  0001a	66 41 3b c0	 cmp	 ax, r8w
  0001e	75 1b		 jne	 SHORT $LN4@Py_UNICODE@4
  00020	0f b7 41 02	 movzx	 eax, WORD PTR [rcx+2]

; 14713:         s1++, s2++;

  00024	48 83 c1 02	 add	 rcx, 2
  00028	48 83 c2 02	 add	 rdx, 2
  0002c	66 85 c0	 test	 ax, ax
  0002f	75 df		 jne	 SHORT $LL5@Py_UNICODE@4
$LN2@Py_UNICODE@4:

; 14716:     if (*s1)
; 14717:         return 1;
; 14718:     if (*s2)

  00031	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  00034	66 f7 d8	 neg	 ax
  00037	1b c0		 sbb	 eax, eax
$LN1@Py_UNICODE@4:

; 14719:         return -1;
; 14720:     return 0;
; 14721: }

  00039	f3 c3		 fatret	 0
$LN4@Py_UNICODE@4:

; 14714:     if (*s1 && *s2)

  0003b	44 0f b7 01	 movzx	 r8d, WORD PTR [rcx]
  0003f	66 45 85 c0	 test	 r8w, r8w
  00043	74 ec		 je	 SHORT $LN2@Py_UNICODE@4
  00045	0f b7 0a	 movzx	 ecx, WORD PTR [rdx]

; 14715:         return (*s1 < *s2) ? -1 : +1;

  00048	b8 01 00 00 00	 mov	 eax, 1
  0004d	66 85 c9	 test	 cx, cx
  00050	74 e7		 je	 SHORT $LN1@Py_UNICODE@4
  00052	83 ca ff	 or	 edx, -1
  00055	66 44 3b c1	 cmp	 r8w, cx
  00059	0f 42 c2	 cmovb	 eax, edx

; 14719:         return -1;
; 14720:     return 0;
; 14721: }

  0005c	c3		 ret	 0
Py_UNICODE_strcmp ENDP
_TEXT	ENDS
PUBLIC	Py_UNICODE_strncmp
; Function compile flags: /Ogtpy
;	COMDAT Py_UNICODE_strncmp
_TEXT	SEGMENT
s1$ = 8
s2$ = 16
n$ = 24
Py_UNICODE_strncmp PROC					; COMDAT

; 14726:     register Py_UNICODE u1, u2;
; 14727:     for (; n != 0; n--) {

  00000	4d 85 c0	 test	 r8, r8
  00003	74 29		 je	 SHORT $LN3@Py_UNICODE@5
  00005	48 2b ca	 sub	 rcx, rdx
  00008	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@Py_UNICODE@5:

; 14728:         u1 = *s1;

  00010	44 0f b7 0c 11	 movzx	 r9d, WORD PTR [rcx+rdx]

; 14729:         u2 = *s2;

  00015	44 0f b7 12	 movzx	 r10d, WORD PTR [rdx]

; 14730:         if (u1 != u2)

  00019	66 45 3b ca	 cmp	 r9w, r10w
  0001d	75 12		 jne	 SHORT $LN9@Py_UNICODE@5

; 14732:         if (u1 == '\0')

  0001f	66 45 85 c9	 test	 r9w, r9w
  00023	74 09		 je	 SHORT $LN3@Py_UNICODE@5

; 14733:             return 0;
; 14734:         s1++;
; 14735:         s2++;

  00025	48 83 c2 02	 add	 rdx, 2
  00029	49 ff c8	 dec	 r8
  0002c	75 e2		 jne	 SHORT $LL5@Py_UNICODE@5
$LN3@Py_UNICODE@5:

; 14736:     }
; 14737:     return 0;

  0002e	33 c0		 xor	 eax, eax

; 14738: }

  00030	c3		 ret	 0
$LN9@Py_UNICODE@5:

; 14731:             return (u1 < u2) ? -1 : +1;

  00031	83 c9 ff	 or	 ecx, -1
  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	66 45 3b ca	 cmp	 r9w, r10w
  0003d	0f 42 c1	 cmovb	 eax, ecx

; 14738: }

  00040	c3		 ret	 0
Py_UNICODE_strncmp ENDP
_TEXT	ENDS
PUBLIC	Py_UNICODE_strchr
; Function compile flags: /Ogtpy
;	COMDAT Py_UNICODE_strchr
_TEXT	SEGMENT
s$ = 8
c$ = 16
Py_UNICODE_strchr PROC					; COMDAT

; 14743:     const Py_UNICODE *p;
; 14744:     for (p = s; *p; p++)

  00000	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00003	66 85 c0	 test	 ax, ax
  00006	74 12		 je	 SHORT $LN2@Py_UNICODE@6
$LL4@Py_UNICODE@6:

; 14745:         if (*p == c)

  00008	66 3b c2	 cmp	 ax, dx
  0000b	74 10		 je	 SHORT $LN8@Py_UNICODE@6

; 14743:     const Py_UNICODE *p;
; 14744:     for (p = s; *p; p++)

  0000d	0f b7 41 02	 movzx	 eax, WORD PTR [rcx+2]
  00011	48 83 c1 02	 add	 rcx, 2
  00015	66 85 c0	 test	 ax, ax
  00018	75 ee		 jne	 SHORT $LL4@Py_UNICODE@6
$LN2@Py_UNICODE@6:

; 14747:     return NULL;

  0001a	33 c0		 xor	 eax, eax

; 14748: }

  0001c	c3		 ret	 0
$LN8@Py_UNICODE@6:

; 14746:             return (Py_UNICODE*)p;

  0001d	48 8b c1	 mov	 rax, rcx

; 14748: }

  00020	c3		 ret	 0
Py_UNICODE_strchr ENDP
_TEXT	ENDS
PUBLIC	Py_UNICODE_strrchr
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_UNICODE_strrchr DD imagerel $LN8
	DD	imagerel $LN8+42
	DD	imagerel $unwind$Py_UNICODE_strrchr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_UNICODE_strrchr DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT Py_UNICODE_strrchr
_TEXT	SEGMENT
s$ = 48
c$ = 56
Py_UNICODE_strrchr PROC					; COMDAT

; 14752: {

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b c1	 mov	 r8, rcx

; 14753:     const Py_UNICODE *p;
; 14754:     p = s + Py_UNICODE_strlen(s);

  00007	e8 00 00 00 00	 call	 Py_UNICODE_strlen
  0000c	49 8d 04 40	 lea	 rax, QWORD PTR [r8+rax*2]

; 14755:     while (p != s) {

  00010	49 3b c0	 cmp	 rax, r8
  00013	74 0e		 je	 SHORT $LN2@Py_UNICODE@7
$LL3@Py_UNICODE@7:

; 14756:         p--;

  00015	48 83 e8 02	 sub	 rax, 2

; 14757:         if (*p == c)

  00019	66 39 10	 cmp	 WORD PTR [rax], dx
  0001c	74 07		 je	 SHORT $LN4@Py_UNICODE@7

; 14755:     while (p != s) {

  0001e	49 3b c0	 cmp	 rax, r8
  00021	75 f2		 jne	 SHORT $LL3@Py_UNICODE@7
$LN2@Py_UNICODE@7:

; 14758:             return (Py_UNICODE*)p;
; 14759:     }
; 14760:     return NULL;

  00023	33 c0		 xor	 eax, eax
$LN4@Py_UNICODE@7:

; 14761: }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
Py_UNICODE_strrchr ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsUnicodeCopy
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_AsUnicodeCopy DD imagerel $LN11
	DD	imagerel $LN11+37
	DD	imagerel $unwind$PyUnicode_AsUnicodeCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyUnicode_AsUnicodeCopy DD imagerel $LN11+37
	DD	imagerel $LN11+92
	DD	imagerel $chain$0$PyUnicode_AsUnicodeCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyUnicode_AsUnicodeCopy DD imagerel $LN11+92
	DD	imagerel $LN11+150
	DD	imagerel $chain$4$PyUnicode_AsUnicodeCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$PyUnicode_AsUnicodeCopy DD imagerel $LN11+150
	DD	imagerel $LN11+187
	DD	imagerel $chain$6$PyUnicode_AsUnicodeCopy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$PyUnicode_AsUnicodeCopy DD 060021H
	DD	047400H
	DD	086400H
	DD	073400H
	DD	imagerel $LN11
	DD	imagerel $LN11+37
	DD	imagerel $unwind$PyUnicode_AsUnicodeCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyUnicode_AsUnicodeCopy DD 060a21H
	DD	08640aH
	DD	073405H
	DD	047400H
	DD	imagerel $LN11
	DD	imagerel $LN11+37
	DD	imagerel $unwind$PyUnicode_AsUnicodeCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyUnicode_AsUnicodeCopy DD 020521H
	DD	047405H
	DD	imagerel $LN11
	DD	imagerel $LN11+37
	DD	imagerel $unwind$PyUnicode_AsUnicodeCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_AsUnicodeCopy DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_AsUnicodeCopy
_TEXT	SEGMENT
len$ = 48
unicode$ = 48
PyUnicode_AsUnicodeCopy PROC				; COMDAT

; 14765: {

$LN11:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 14766:     Py_UNICODE *u, *copy;
; 14767:     Py_ssize_t len, size;
; 14768: 
; 14769:     if (!PyUnicode_Check(unicode)) {

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00012	75 0c		 jne	 SHORT $LN4@PyUnicode_@50

; 14770:         PyErr_BadArgument();

  00014	e8 00 00 00 00	 call	 PyErr_BadArgument

; 14771:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 14790: }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
$LN4@PyUnicode_@50:

; 14772:     }
; 14773:     u = PyUnicode_AsUnicodeAndSize(unicode, &len);

  00020	48 8d 54 24 30	 lea	 rdx, QWORD PTR len$[rsp]
  00025	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0002a	e8 00 00 00 00	 call	 PyUnicode_AsUnicodeAndSize
  0002f	48 8b f8	 mov	 rdi, rax

; 14774:     if (u == NULL)

  00032	48 85 c0	 test	 rax, rax

; 14775:         return NULL;

  00035	74 19		 je	 SHORT $LN10@PyUnicode_@50

; 14776:     /* Ensure we won't overflow the size. */
; 14777:     if (len > ((PY_SSIZE_T_MAX / sizeof(Py_UNICODE)) - 1)) {

  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  0003c	48 b9 fe ff ff
	ff ff ff ff 3f	 mov	 rcx, 4611686018427387902 ; 3ffffffffffffffeH
  00046	48 3b c1	 cmp	 rax, rcx
  00049	76 11		 jbe	 SHORT $LN2@PyUnicode_@50

; 14778:         PyErr_NoMemory();

  0004b	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN10@PyUnicode_@50:

; 14779:         return NULL;

  00050	33 c0		 xor	 eax, eax
  00052	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 14790: }

  00057	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005b	c3		 ret	 0
$LN2@PyUnicode_@50:
  0005c	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  00061	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi

; 14780:     }
; 14781:     size = len + 1; /* copy the null character */
; 14782:     size *= sizeof(Py_UNICODE);

  00066	48 8d 74 00 02	 lea	 rsi, QWORD PTR [rax+rax+2]

; 14783:     copy = PyMem_Malloc(size);

  0006b	48 8b ce	 mov	 rcx, rsi
  0006e	e8 00 00 00 00	 call	 PyMem_Malloc
  00073	48 8b d8	 mov	 rbx, rax

; 14784:     if (copy == NULL) {

  00076	48 85 c0	 test	 rax, rax
  00079	75 1b		 jne	 SHORT $LN1@PyUnicode_@50

; 14785:         PyErr_NoMemory();

  0007b	e8 00 00 00 00	 call	 PyErr_NoMemory
  00080	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00085	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0008a	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 14786:         return NULL;

  0008f	33 c0		 xor	 eax, eax

; 14790: }

  00091	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00095	c3		 ret	 0
$LN1@PyUnicode_@50:

; 14787:     }
; 14788:     memcpy(copy, u, size);

  00096	4c 8b c6	 mov	 r8, rsi
  00099	48 8b d7	 mov	 rdx, rdi
  0009c	48 8b c8	 mov	 rcx, rax
  0009f	e8 00 00 00 00	 call	 memcpy
  000a4	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000a9	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 14789:     return copy;

  000ae	48 8b c3	 mov	 rax, rbx
  000b1	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]

; 14790: }

  000b6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ba	c3		 ret	 0
PyUnicode_AsUnicodeCopy ENDP
_TEXT	ENDS
PUBLIC	PyInit__string
EXTRN	PyModule_Create2:PROC
; Function compile flags: /Ogtpy
;	COMDAT PyInit__string
_TEXT	SEGMENT
PyInit__string PROC					; COMDAT

; 14818:     return PyModule_Create(&_string_module);

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_string_module
  00007	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H

; 14819: }

  0000c	e9 00 00 00 00	 jmp	 PyModule_Create2
PyInit__string ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_result_wchar DD imagerel unicode_result_wchar
	DD	imagerel unicode_result_wchar+101
	DD	imagerel $unwind$unicode_result_wchar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_result_wchar DD imagerel unicode_result_wchar+101
	DD	imagerel unicode_result_wchar+136
	DD	imagerel $chain$0$unicode_result_wchar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$unicode_result_wchar DD imagerel unicode_result_wchar+136
	DD	imagerel unicode_result_wchar+173
	DD	imagerel $chain$1$unicode_result_wchar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$unicode_result_wchar DD 021H
	DD	imagerel unicode_result_wchar
	DD	imagerel unicode_result_wchar+101
	DD	imagerel $unwind$unicode_result_wchar
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_result_wchar DD 020521H
	DD	063405H
	DD	imagerel unicode_result_wchar
	DD	imagerel unicode_result_wchar+101
	DD	imagerel $unwind$unicode_result_wchar
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_result_wchar DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_result_wchar
_TEXT	SEGMENT
unicode$ = 48
unicode_result_wchar PROC				; COMDAT

; 432  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 433  : #ifndef Py_DEBUG
; 434  :     Py_ssize_t len;
; 435  : 
; 436  :     assert(Py_REFCNT(unicode) == 1);
; 437  : 
; 438  :     len = _PyUnicode_WSTR_LENGTH(unicode);

  00006	48 8b 81 90 00
	00 00		 mov	 rax, QWORD PTR [rcx+144]
  0000d	48 8b f9	 mov	 rdi, rcx

; 439  :     if (len == 0) {

  00010	48 85 c0	 test	 rax, rax
  00013	75 39		 jne	 SHORT $LN14@unicode_re@2

; 440  :         Py_DECREF(unicode);

  00015	e8 00 00 00 00	 call	 _Py_DecRef

; 441  :         _Py_RETURN_UNICODE_EMPTY();

  0001a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  00021	48 85 c9	 test	 rcx, rcx
  00024	75 16		 jne	 SHORT $LN20@unicode_re@2
  00026	33 d2		 xor	 edx, edx
  00028	e8 00 00 00 00	 call	 PyUnicode_New
  0002d	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  00034	48 85 c0	 test	 rax, rax
  00037	74 6e		 je	 SHORT $LN18@unicode_re@2
  00039	48 8b c8	 mov	 rcx, rax
$LN20@unicode_re@2:
  0003c	e8 00 00 00 00	 call	 _Py_IncRef
  00041	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 463  : }

  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5f		 pop	 rdi
  0004d	c3		 ret	 0
$LN14@unicode_re@2:

; 442  :     }
; 443  : 
; 444  :     if (len == 1) {

  0004e	48 83 f8 01	 cmp	 rax, 1
  00052	75 34		 jne	 SHORT $LN6@unicode_re@2

; 445  :         wchar_t ch = _PyUnicode_WSTR(unicode)[0];

  00054	48 8b 41 78	 mov	 rax, QWORD PTR [rcx+120]
  00058	0f b7 08	 movzx	 ecx, WORD PTR [rax]

; 446  :         if ((Py_UCS4)ch < 256) {

  0005b	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00060	66 3b c8	 cmp	 cx, ax
  00063	73 23		 jae	 SHORT $LN6@unicode_re@2

; 447  :             PyObject *latin1_char = get_latin1_char((unsigned char)ch);

  00065	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0006a	e8 00 00 00 00	 call	 get_latin1_char

; 448  :             Py_DECREF(unicode);

  0006f	48 8b cf	 mov	 rcx, rdi
  00072	48 8b d8	 mov	 rbx, rax
  00075	e8 00 00 00 00	 call	 _Py_DecRef

; 449  :             return latin1_char;

  0007a	48 8b c3	 mov	 rax, rbx
  0007d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 463  : }

  00082	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00086	5f		 pop	 rdi
  00087	c3		 ret	 0
$LN6@unicode_re@2:

; 450  :         }
; 451  :     }
; 452  : 
; 453  :     if (_PyUnicode_Ready(unicode) < 0) {

  00088	48 8b cf	 mov	 rcx, rdi
  0008b	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00090	85 c0		 test	 eax, eax
  00092	79 10		 jns	 SHORT $LN5@unicode_re@2

; 454  :         Py_XDECREF(unicode);

  00094	48 8b cf	 mov	 rcx, rdi
  00097	e8 00 00 00 00	 call	 _Py_DecRef

; 455  :         return NULL;

  0009c	33 c0		 xor	 eax, eax

; 463  : }

  0009e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a2	5f		 pop	 rdi
  000a3	c3		 ret	 0
$LN5@unicode_re@2:

; 456  :     }
; 457  : #else
; 458  :     /* don't make the result ready in debug mode to ensure that the caller
; 459  :        makes the string ready before using it */
; 460  :     assert(_PyUnicode_CheckConsistency(unicode, 1));
; 461  : #endif
; 462  :     return unicode;

  000a4	48 8b c7	 mov	 rax, rdi
$LN18@unicode_re@2:

; 463  : }

  000a7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ab	5f		 pop	 rdi
  000ac	c3		 ret	 0
unicode_result_wchar ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_result_ready DD imagerel unicode_result_ready
	DD	imagerel unicode_result_ready+257
	DD	imagerel $unwind$unicode_result_ready
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_result_ready DD imagerel unicode_result_ready+257
	DD	imagerel unicode_result_ready+310
	DD	imagerel $chain$0$unicode_result_ready
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$unicode_result_ready DD imagerel unicode_result_ready+310
	DD	imagerel unicode_result_ready+316
	DD	imagerel $chain$1$unicode_result_ready
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$unicode_result_ready DD imagerel unicode_result_ready+316
	DD	imagerel unicode_result_ready+358
	DD	imagerel $chain$2$unicode_result_ready
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$unicode_result_ready DD imagerel unicode_result_ready+358
	DD	imagerel unicode_result_ready+367
	DD	imagerel $chain$3$unicode_result_ready
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$unicode_result_ready DD 021H
	DD	imagerel unicode_result_ready
	DD	imagerel unicode_result_ready+257
	DD	imagerel $unwind$unicode_result_ready
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$unicode_result_ready DD 020021H
	DD	067400H
	DD	imagerel unicode_result_ready
	DD	imagerel unicode_result_ready+257
	DD	imagerel $unwind$unicode_result_ready
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$unicode_result_ready DD 021H
	DD	imagerel unicode_result_ready
	DD	imagerel unicode_result_ready+257
	DD	imagerel $unwind$unicode_result_ready
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_result_ready DD 020521H
	DD	067405H
	DD	imagerel unicode_result_ready
	DD	imagerel unicode_result_ready+257
	DD	imagerel $unwind$unicode_result_ready
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_result_ready DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_result_ready
_TEXT	SEGMENT
unicode$ = 48
unicode_result_ready PROC				; COMDAT

; 467  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 468  :     Py_ssize_t length;
; 469  : 
; 470  :     length = PyUnicode_GET_LENGTH(unicode);

  00006	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  0000a	48 8b d9	 mov	 rbx, rcx

; 471  :     if (length == 0) {

  0000d	48 85 c0	 test	 rax, rax
  00010	75 4d		 jne	 SHORT $LN16@unicode_re@3

; 472  :         if (unicode != unicode_empty) {

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty
  00019	48 3b c8	 cmp	 rcx, rax
  0001c	0f 84 14 01 00
	00		 je	 $LN17@unicode_re@3

; 473  :             Py_DECREF(unicode);

  00022	e8 00 00 00 00	 call	 _Py_DecRef

; 474  :             _Py_RETURN_UNICODE_EMPTY();

  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  0002e	48 85 c9	 test	 rcx, rcx
  00031	75 1a		 jne	 SHORT $LN36@unicode_re@3
  00033	33 d2		 xor	 edx, edx
  00035	e8 00 00 00 00	 call	 PyUnicode_New
  0003a	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  00041	48 85 c0	 test	 rax, rax
  00044	0f 84 ec 00 00
	00		 je	 $LN17@unicode_re@3
  0004a	48 8b c8	 mov	 rcx, rax
$LN36@unicode_re@3:
  0004d	e8 00 00 00 00	 call	 _Py_IncRef
  00052	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 508  : }

  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5b		 pop	 rbx
  0005e	c3		 ret	 0
$LN16@unicode_re@3:

; 475  :         }
; 476  :         return unicode_empty;
; 477  :     }
; 478  : 
; 479  :     if (length == 1) {

  0005f	48 83 f8 01	 cmp	 rax, 1
  00063	0f 85 fd 00 00
	00		 jne	 $LN1@unicode_re@3

; 480  :         Py_UCS4 ch = PyUnicode_READ_CHAR(unicode, 0);

  00069	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  0006c	8b c8		 mov	 ecx, eax
  0006e	c1 e9 02	 shr	 ecx, 2
  00071	83 e1 07	 and	 ecx, 7
  00074	83 f9 01	 cmp	 ecx, 1
  00077	75 2c		 jne	 SHORT $LN33@unicode_re@3
  00079	a8 20		 test	 al, 32			; 00000020H
  0007b	74 1c		 je	 SHORT $LN21@unicode_re@3
  0007d	a8 40		 test	 al, 64			; 00000040H
  0007f	74 0c		 je	 SHORT $LN19@unicode_re@3
  00081	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00088	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0008b	eb 6c		 jmp	 SHORT $LN32@unicode_re@3
$LN19@unicode_re@3:
  0008d	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00094	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00097	eb 60		 jmp	 SHORT $LN32@unicode_re@3
$LN21@unicode_re@3:
  00099	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  000a0	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000a3	eb 54		 jmp	 SHORT $LN32@unicode_re@3
$LN33@unicode_re@3:
  000a5	83 f9 02	 cmp	 ecx, 2
  000a8	75 2c		 jne	 SHORT $LN31@unicode_re@3
  000aa	a8 20		 test	 al, 32			; 00000020H
  000ac	74 1c		 je	 SHORT $LN25@unicode_re@3
  000ae	a8 40		 test	 al, 64			; 00000040H
  000b0	74 0c		 je	 SHORT $LN23@unicode_re@3
  000b2	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  000b9	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  000bc	eb 3b		 jmp	 SHORT $LN32@unicode_re@3
$LN23@unicode_re@3:
  000be	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  000c5	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  000c8	eb 2f		 jmp	 SHORT $LN32@unicode_re@3
$LN25@unicode_re@3:
  000ca	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  000d1	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  000d4	eb 23		 jmp	 SHORT $LN32@unicode_re@3
$LN31@unicode_re@3:
  000d6	a8 20		 test	 al, 32			; 00000020H
  000d8	74 16		 je	 SHORT $LN29@unicode_re@3
  000da	a8 40		 test	 al, 64			; 00000040H
  000dc	74 09		 je	 SHORT $LN27@unicode_re@3
  000de	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  000e5	eb 10		 jmp	 SHORT $LN30@unicode_re@3
$LN27@unicode_re@3:
  000e7	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  000ee	eb 07		 jmp	 SHORT $LN30@unicode_re@3
$LN29@unicode_re@3:
  000f0	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN30@unicode_re@3:
  000f7	8b 08		 mov	 ecx, DWORD PTR [rax]
$LN32@unicode_re@3:

; 481  :         if (ch < 256) {

  000f9	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  000ff	73 65		 jae	 SHORT $LN1@unicode_re@3

; 482  :             PyObject *latin1_char = unicode_latin1[ch];

  00101	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00106	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:unicode_latin1
  0010d	44 8b c1	 mov	 r8d, ecx
  00110	4a 8b 3c c7	 mov	 rdi, QWORD PTR [rdi+r8*8]

; 483  :             if (latin1_char != NULL) {

  00114	48 85 ff	 test	 rdi, rdi
  00117	74 23		 je	 SHORT $LN3@unicode_re@3

; 484  : #ifdef WITH_PARALLEL
; 485  :                 assert(Py_ISPY(latin1_char));
; 486  : #endif
; 487  :                 if (unicode != latin1_char) {

  00119	48 3b df	 cmp	 rbx, rdi
  0011c	74 10		 je	 SHORT $LN2@unicode_re@3

; 488  :                     Py_INCREF(latin1_char);

  0011e	48 8b cf	 mov	 rcx, rdi
  00121	e8 00 00 00 00	 call	 _Py_IncRef

; 489  :                     Py_DECREF(unicode);

  00126	48 8b cb	 mov	 rcx, rbx
  00129	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@unicode_re@3:

; 490  :                 }
; 491  :                 return latin1_char;

  0012e	48 8b c7	 mov	 rax, rdi
  00131	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN17@unicode_re@3:

; 508  : }

  00136	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013a	5b		 pop	 rbx
  0013b	c3		 ret	 0
$LN3@unicode_re@3:

; 492  :             }
; 493  :             else {
; 494  :                 assert(_PyUnicode_CheckConsistency(unicode, 1));
; 495  : #ifdef WITH_PARALLEL
; 496  :                 tls_unicode_latin1[ch] = unicode;

  0013c	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00145	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  0014b	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00150	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:tls_unicode_latin1
  00155	48 03 0c d0	 add	 rcx, QWORD PTR [rax+rdx*8]

; 497  : #else
; 498  :                 Py_INCREF(unicode);
; 499  :                 unicode_latin1[ch] = unicode;
; 500  : #endif
; 501  :                 return unicode;

  00159	48 8b c3	 mov	 rax, rbx
  0015c	4a 89 1c c1	 mov	 QWORD PTR [rcx+r8*8], rbx

; 508  : }

  00160	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00164	5b		 pop	 rbx
  00165	c3		 ret	 0
$LN1@unicode_re@3:

; 502  :             }
; 503  :         }
; 504  :     }
; 505  : 
; 506  :     assert(_PyUnicode_CheckConsistency(unicode, 1));
; 507  :     return unicode;

  00166	48 8b c3	 mov	 rax, rbx

; 508  : }

  00169	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016d	5b		 pop	 rbx
  0016e	c3		 ret	 0
unicode_result_ready ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT unicode_result
_TEXT	SEGMENT
unicode$ = 8
unicode_result PROC					; COMDAT

; 513  :     assert(_PyUnicode_CHECK(unicode));
; 514  :     if (PyUnicode_IS_READY(unicode))

  00000	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00004	74 05		 je	 SHORT $LN2@unicode_re@4

; 515  :         return unicode_result_ready(unicode);
; 516  :     else
; 517  :         return unicode_result_wchar(unicode);
; 518  : }

  00006	e9 00 00 00 00	 jmp	 unicode_result_ready
$LN2@unicode_re@4:
  0000b	e9 00 00 00 00	 jmp	 unicode_result_wchar
unicode_result ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$unicode_result_unchanged DD imagerel unicode_result_unchanged
	DD	imagerel unicode_result_unchanged+124
	DD	imagerel $unwind$unicode_result_unchanged
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_result_unchanged DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT unicode_result_unchanged
_TEXT	SEGMENT
unicode$ = 64
unicode_result_unchanged PROC				; COMDAT

; 522  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 523  :     if (PyUnicode_CheckExact(unicode)) {

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00014	75 5c		 jne	 SHORT $LN3@unicode_re@5

; 524  :         if (PyUnicode_READY(unicode) == -1)

  00016	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0001a	75 12		 jne	 SHORT $LN2@unicode_re@5
  0001c	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00021	83 f8 ff	 cmp	 eax, -1
  00024	75 08		 jne	 SHORT $LN2@unicode_re@5

; 525  :             return NULL;

  00026	33 c0		 xor	 eax, eax

; 528  :     }
; 529  :     else
; 530  :         /* Subtype -- return genuine unicode string with the same value. */
; 531  :         return _PyUnicode_Copy(unicode);
; 532  : }

  00028	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002c	5b		 pop	 rbx
  0002d	c3		 ret	 0
$LN2@unicode_re@5:

; 526  :         Py_INCREF(unicode);

  0002e	e8 00 00 00 00	 call	 _Py_PXCTX
  00033	85 c0		 test	 eax, eax
  00035	75 32		 jne	 SHORT $LN9@unicode_re@5
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00045	4c 8b cb	 mov	 r9, rbx
  00048	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0004e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00056	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005b	85 c0		 test	 eax, eax
  0005d	75 06		 jne	 SHORT $LN8@unicode_re@5
  0005f	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00063	74 04		 je	 SHORT $LN9@unicode_re@5
$LN8@unicode_re@5:
  00065	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN9@unicode_re@5:

; 527  :         return unicode;

  00069	48 8b c3	 mov	 rax, rbx

; 528  :     }
; 529  :     else
; 530  :         /* Subtype -- return genuine unicode string with the same value. */
; 531  :         return _PyUnicode_Copy(unicode);
; 532  : }

  0006c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00070	5b		 pop	 rbx
  00071	c3		 ret	 0
$LN3@unicode_re@5:
  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5b		 pop	 rbx
  00077	e9 00 00 00 00	 jmp	 _PyUnicode_Copy
unicode_result_unchanged ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@JDENDMBF@empty?5separator?$AA@	; `string'
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$asciilib_partition DD imagerel asciilib_partition
	DD	imagerel asciilib_partition+81
	DD	imagerel $unwind$asciilib_partition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$asciilib_partition DD imagerel asciilib_partition+81
	DD	imagerel asciilib_partition+116
	DD	imagerel $chain$0$asciilib_partition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$asciilib_partition DD imagerel asciilib_partition+116
	DD	imagerel asciilib_partition+361
	DD	imagerel $chain$5$asciilib_partition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$asciilib_partition DD imagerel asciilib_partition+361
	DD	imagerel asciilib_partition+736
	DD	imagerel $chain$7$asciilib_partition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$asciilib_partition DD 080021H
	DD	08f400H
	DD	096400H
	DD	0a5400H
	DD	0113400H
	DD	imagerel asciilib_partition
	DD	imagerel asciilib_partition+81
	DD	imagerel $unwind$asciilib_partition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$asciilib_partition DD 081221H
	DD	096412H
	DD	0a540dH
	DD	0113408H
	DD	08f400H
	DD	imagerel asciilib_partition
	DD	imagerel asciilib_partition+81
	DD	imagerel $unwind$asciilib_partition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$asciilib_partition DD 020521H
	DD	08f405H
	DD	imagerel asciilib_partition
	DD	imagerel asciilib_partition+81
	DD	imagerel $unwind$asciilib_partition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_partition DD 051501H
	DD	0e011a215H
	DD	0c00dd00fH
	DD	0700bH
xdata	ENDS
;	COMDAT ??_C@_0BA@JDENDMBF@empty?5separator?$AA@
CONST	SEGMENT
??_C@_0BA@JDENDMBF@empty?5separator?$AA@ DB 'empty separator', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\partition.h
CONST	ENDS
;	COMDAT asciilib_partition
_TEXT	SEGMENT
mask$1$ = 32
skip$1$ = 40
mlast$1$ = 48
w$1$ = 56
str_obj$ = 128
str$ = 136
str_len$ = 144
sep_obj$ = 152
sep$ = 160
sep_len$ = 168
asciilib_partition PROC					; COMDAT

; 12   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 13   :     PyObject* out;
; 14   :     Py_ssize_t pos;
; 15   : 
; 16   :     if (sep_len == 0) {

  00015	4c 8b ac 24 a8
	00 00 00	 mov	 r13, QWORD PTR sep_len$[rsp]
  0001d	49 8b f9	 mov	 rdi, r9
  00020	4d 8b f0	 mov	 r14, r8
  00023	4c 8b e2	 mov	 r12, rdx
  00026	4d 85 ed	 test	 r13, r13
  00029	75 21		 jne	 SHORT $LN4@asciilib_p

; 17   :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00039	e8 00 00 00 00	 call	 PyErr_SetString

; 18   :         return NULL;

  0003e	33 c0		 xor	 eax, eax

; 52   :     }
; 53   : 
; 54   :     return out;
; 55   : }

  00040	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00044	41 5e		 pop	 r14
  00046	41 5d		 pop	 r13
  00048	41 5c		 pop	 r12
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
$LN4@asciilib_p:

; 19   :     }
; 20   : 
; 21   :     out = PyTuple_New(3);

  0004c	b9 03 00 00 00	 mov	 ecx, 3
  00051	4c 89 7c 24 40	 mov	 QWORD PTR [rsp+64], r15
  00056	e8 00 00 00 00	 call	 PyTuple_New
  0005b	4c 8b f8	 mov	 r15, rax

; 22   :     if (!out)

  0005e	48 85 c0	 test	 rax, rax
  00061	75 11		 jne	 SHORT $LN3@asciilib_p
  00063	4c 8b 7c 24 40	 mov	 r15, QWORD PTR [rsp+64]

; 52   :     }
; 53   : 
; 54   :     return out;
; 55   : }

  00068	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0006c	41 5e		 pop	 r14
  0006e	41 5d		 pop	 r13
  00070	41 5c		 pop	 r12
  00072	5f		 pop	 rdi
  00073	c3		 ret	 0
$LN3@asciilib_p:
  00074	48 89 9c 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbx
  0007c	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00081	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi

; 23   :         return NULL;
; 24   : 
; 25   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_SEARCH);

  00086	49 8b f6	 mov	 rsi, r14
  00089	49 2b f5	 sub	 rsi, r13
  0008c	48 89 74 24 38	 mov	 QWORD PTR w$1$[rsp], rsi
  00091	78 72		 js	 SHORT $LN90@asciilib_p
  00093	49 83 fd 01	 cmp	 r13, 1
  00097	0f 8f cc 00 00
	00		 jg	 $LN65@asciilib_p
  0009d	4d 85 ed	 test	 r13, r13
  000a0	7e 63		 jle	 SHORT $LN90@asciilib_p
  000a2	49 83 fe 0a	 cmp	 r14, 10
  000a6	7e 39		 jle	 SHORT $LN63@asciilib_p
  000a8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  000b0	4f 8d 04 34	 lea	 r8, QWORD PTR [r12+r14]
  000b4	4d 3b e0	 cmp	 r12, r8
  000b7	73 17		 jae	 SHORT $LN73@asciilib_p
  000b9	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  000bc	4d 2b c4	 sub	 r8, r12
  000bf	49 8b cc	 mov	 rcx, r12
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000c8	48 8b d8	 mov	 rbx, rax
  000cb	48 85 c0	 test	 rax, rax
  000ce	75 09		 jne	 SHORT $LN72@asciilib_p
$LN73@asciilib_p:
  000d0	48 83 cb ff	 or	 rbx, -1
  000d4	e9 ad 01 00 00	 jmp	 $LN68@asciilib_p
$LN72@asciilib_p:
  000d9	49 2b dc	 sub	 rbx, r12
  000dc	e9 a5 01 00 00	 jmp	 $LN68@asciilib_p
$LN63@asciilib_p:
  000e1	33 db		 xor	 ebx, ebx
  000e3	4d 85 f6	 test	 r14, r14
  000e6	7e 1d		 jle	 SHORT $LN90@asciilib_p
  000e8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  000f0	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
$LL54@asciilib_p:
  000f3	42 38 0c 23	 cmp	 BYTE PTR [rbx+r12], cl
  000f7	0f 84 89 01 00
	00		 je	 $LN68@asciilib_p
  000fd	48 ff c3	 inc	 rbx
  00100	49 3b de	 cmp	 rbx, r14
  00103	7c ee		 jl	 SHORT $LL54@asciilib_p
$LN90@asciilib_p:

; 28   : #if STRINGLIB_MUTABLE
; 29   :         PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, str_len));
; 30   :         PyTuple_SET_ITEM(out, 1, STRINGLIB_NEW(NULL, 0));
; 31   :         PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(NULL, 0));
; 32   : #else
; 33   :         Py_INCREF(str_obj);

  00105	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR str_obj$[rsp]
  0010d	48 8b cb	 mov	 rcx, rbx
  00110	e8 00 00 00 00	 call	 _Py_IncRef

; 34   :         PyTuple_SET_ITEM(out, 0, (PyObject*) str_obj);
; 35   :         Py_INCREF(STRINGLIB_EMPTY);

  00115	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  0011c	49 89 5f 70	 mov	 QWORD PTR [r15+112], rbx
  00120	e8 00 00 00 00	 call	 _Py_IncRef

; 36   :         PyTuple_SET_ITEM(out, 1, (PyObject*) STRINGLIB_EMPTY);

  00125	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  0012c	49 89 4f 78	 mov	 QWORD PTR [r15+120], rcx

; 37   :         Py_INCREF(STRINGLIB_EMPTY);

  00130	e8 00 00 00 00	 call	 _Py_IncRef

; 38   :         PyTuple_SET_ITEM(out, 2, (PyObject*) STRINGLIB_EMPTY);

  00135	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR unicode_empty
  0013c	4d 89 9f 80 00
	00 00		 mov	 QWORD PTR [r15+128], r11
$LN1@asciilib_p:

; 39   : #endif
; 40   :         return out;

  00143	49 8b c7	 mov	 rax, r15
$LN95@asciilib_p:
  00146	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0014b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00150	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR [rsp+136]
  00158	4c 8b 7c 24 40	 mov	 r15, QWORD PTR [rsp+64]

; 52   :     }
; 53   : 
; 54   :     return out;
; 55   : }

  0015d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00161	41 5e		 pop	 r14
  00163	41 5d		 pop	 r13
  00165	41 5c		 pop	 r12
  00167	5f		 pop	 rdi
  00168	c3		 ret	 0

; 23   :         return NULL;
; 24   : 
; 25   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_SEARCH);

$LN65@asciilib_p:
  00169	4d 8d 4d ff	 lea	 r9, QWORD PTR [r13-1]
  0016d	33 db		 xor	 ebx, ebx
  0016f	49 8d 41 ff	 lea	 rax, QWORD PTR [r9-1]
  00173	4c 89 4c 24 30	 mov	 QWORD PTR mlast$1$[rsp], r9
  00178	8b fb		 mov	 edi, ebx
  0017a	44 8d 53 01	 lea	 r10d, QWORD PTR [rbx+1]
  0017e	48 89 44 24 28	 mov	 QWORD PTR skip$1$[rsp], rax
  00183	4d 85 c9	 test	 r9, r9
  00186	7e 5d		 jle	 SHORT $LN42@asciilib_p
  00188	4c 8b 9c 24 a0
	00 00 00	 mov	 r11, QWORD PTR sep$[rsp]
  00190	49 8b f1	 mov	 rsi, r9
  00193	48 8b f8	 mov	 rdi, rax
  00196	43 0f b6 2c 19	 movzx	 ebp, BYTE PTR [r9+r11]
  0019b	4c 8b c8	 mov	 r9, rax
  0019e	44 8b eb	 mov	 r13d, ebx
$LL44@asciilib_p:
  001a1	45 0f b6 03	 movzx	 r8d, BYTE PTR [r11]
  001a5	41 8b d2	 mov	 edx, r10d
  001a8	41 8b c8	 mov	 ecx, r8d
  001ab	83 e1 1f	 and	 ecx, 31
  001ae	d3 e2		 shl	 edx, cl
  001b0	44 0b ea	 or	 r13d, edx
  001b3	44 3a c5	 cmp	 r8b, bpl
  001b6	4c 0f 44 cf	 cmove	 r9, rdi
  001ba	49 ff c3	 inc	 r11
  001bd	48 ff cf	 dec	 rdi
  001c0	48 ff ce	 dec	 rsi
  001c3	75 dc		 jne	 SHORT $LL44@asciilib_p
  001c5	48 8b 74 24 38	 mov	 rsi, QWORD PTR w$1$[rsp]
  001ca	44 89 6c 24 20	 mov	 DWORD PTR mask$1$[rsp], r13d
  001cf	4c 8b ac 24 a8
	00 00 00	 mov	 r13, QWORD PTR sep_len$[rsp]
  001d7	8b 7c 24 20	 mov	 edi, DWORD PTR mask$1$[rsp]
  001db	4c 89 4c 24 28	 mov	 QWORD PTR skip$1$[rsp], r9
  001e0	4c 8b 4c 24 30	 mov	 r9, QWORD PTR mlast$1$[rsp]
$LN42@asciilib_p:
  001e5	48 8b ac 24 a0
	00 00 00	 mov	 rbp, QWORD PTR sep$[rsp]
  001ed	48 8b d3	 mov	 rdx, rbx
  001f0	41 0f b6 04 29	 movzx	 eax, BYTE PTR [r9+rbp]
  001f5	83 e0 1f	 and	 eax, 31
  001f8	0f b6 c8	 movzx	 ecx, al
  001fb	41 d3 e2	 shl	 r10d, cl
  001fe	41 0b fa	 or	 edi, r10d
  00201	48 85 f6	 test	 rsi, rsi
  00204	0f 88 fb fe ff
	ff		 js	 $LN90@asciilib_p
  0020a	4f 8d 1c 2c	 lea	 r11, QWORD PTR [r12+r13]
$LN97@asciilib_p:
  0020e	41 0f b6 44 2d
	ff		 movzx	 eax, BYTE PTR [r13+rbp-1]
  00214	41 38 44 13 ff	 cmp	 BYTE PTR [r11+rdx-1], al
  00219	75 42		 jne	 SHORT $LN37@asciilib_p
  0021b	4c 8b c3	 mov	 r8, rbx
  0021e	4d 85 c9	 test	 r9, r9
  00221	7e 21		 jle	 SHORT $LN91@asciilib_p
  00223	4c 8b d2	 mov	 r10, rdx
  00226	48 8b cd	 mov	 rcx, rbp
  00229	4c 2b d5	 sub	 r10, rbp
  0022c	4d 03 d4	 add	 r10, r12
  0022f	90		 npad	 1
$LL36@asciilib_p:
  00230	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00233	41 38 04 0a	 cmp	 BYTE PTR [r10+rcx], al
  00237	75 0b		 jne	 SHORT $LN91@asciilib_p
  00239	49 ff c0	 inc	 r8
  0023c	48 ff c1	 inc	 rcx
  0023f	4d 3b c1	 cmp	 r8, r9
  00242	7c ec		 jl	 SHORT $LL36@asciilib_p
$LN91@asciilib_p:
  00244	4d 3b c1	 cmp	 r8, r9
  00247	74 32		 je	 SHORT $LN84@asciilib_p
  00249	41 0f b6 04 13	 movzx	 eax, BYTE PTR [r11+rdx]
  0024e	83 e0 1f	 and	 eax, 31
  00251	0f a3 c7	 bt	 edi, eax
  00254	73 14		 jae	 SHORT $LN96@asciilib_p
  00256	48 03 54 24 28	 add	 rdx, QWORD PTR skip$1$[rsp]
  0025b	eb 10		 jmp	 SHORT $LN39@asciilib_p
$LN37@asciilib_p:
  0025d	41 0f b6 04 13	 movzx	 eax, BYTE PTR [r11+rdx]
  00262	83 e0 1f	 and	 eax, 31
  00265	0f a3 c7	 bt	 edi, eax
  00268	72 03		 jb	 SHORT $LN39@asciilib_p
$LN96@asciilib_p:
  0026a	49 03 d5	 add	 rdx, r13
$LN39@asciilib_p:
  0026d	48 ff c2	 inc	 rdx
  00270	48 3b d6	 cmp	 rdx, rsi
  00273	0f 8f 8c fe ff
	ff		 jg	 $LN90@asciilib_p
  00279	eb 93		 jmp	 SHORT $LN97@asciilib_p
$LN84@asciilib_p:
  0027b	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR sep_obj$[rsp]
  00283	48 8b da	 mov	 rbx, rdx
$LN68@asciilib_p:

; 26   : 
; 27   :     if (pos < 0) {

  00286	48 85 db	 test	 rbx, rbx
  00289	0f 88 76 fe ff
	ff		 js	 $LN90@asciilib_p

; 41   :     }
; 42   : 
; 43   :     PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, pos));

  0028f	48 8b d3	 mov	 rdx, rbx
  00292	49 8b cc	 mov	 rcx, r12
  00295	e8 00 00 00 00	 call	 _PyUnicode_FromASCII

; 44   :     Py_INCREF(sep_obj);

  0029a	48 8b cf	 mov	 rcx, rdi
  0029d	49 89 47 70	 mov	 QWORD PTR [r15+112], rax
  002a1	e8 00 00 00 00	 call	 _Py_IncRef

; 45   :     PyTuple_SET_ITEM(out, 1, sep_obj);
; 46   :     pos += sep_len;

  002a6	49 03 dd	 add	 rbx, r13

; 47   :     PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str + pos, str_len - pos));

  002a9	4c 2b f3	 sub	 r14, rbx
  002ac	4a 8d 0c 23	 lea	 rcx, QWORD PTR [rbx+r12]
  002b0	49 89 7f 78	 mov	 QWORD PTR [r15+120], rdi
  002b4	49 8b d6	 mov	 rdx, r14
  002b7	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  002bc	49 89 87 80 00
	00 00		 mov	 QWORD PTR [r15+128], rax

; 48   : 
; 49   :     if (PyErr_Occurred()) {

  002c3	e8 00 00 00 00	 call	 PyErr_Occurred
  002c8	48 85 c0	 test	 rax, rax
  002cb	0f 84 72 fe ff
	ff		 je	 $LN1@asciilib_p

; 50   :         Py_DECREF(out);

  002d1	49 8b cf	 mov	 rcx, r15
  002d4	e8 00 00 00 00	 call	 _Py_DecRef

; 51   :         return NULL;

  002d9	33 c0		 xor	 eax, eax
  002db	e9 66 fe ff ff	 jmp	 $LN95@asciilib_p
asciilib_partition ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$asciilib_rpartition DD imagerel asciilib_rpartition
	DD	imagerel asciilib_rpartition+82
	DD	imagerel $unwind$asciilib_rpartition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$asciilib_rpartition DD imagerel asciilib_rpartition+82
	DD	imagerel asciilib_rpartition+115
	DD	imagerel $chain$0$asciilib_rpartition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$asciilib_rpartition DD imagerel asciilib_rpartition+115
	DD	imagerel asciilib_rpartition+289
	DD	imagerel $chain$5$asciilib_rpartition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$asciilib_rpartition DD imagerel asciilib_rpartition+289
	DD	imagerel asciilib_rpartition+626
	DD	imagerel $chain$7$asciilib_rpartition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$asciilib_rpartition DD 080021H
	DD	04f400H
	DD	05e400H
	DD	06c400H
	DD	0d3400H
	DD	imagerel asciilib_rpartition
	DD	imagerel asciilib_rpartition+82
	DD	imagerel $unwind$asciilib_rpartition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$asciilib_rpartition DD 081521H
	DD	04f415H
	DD	05e40dH
	DD	0d3405H
	DD	06c400H
	DD	imagerel asciilib_rpartition
	DD	imagerel asciilib_rpartition+82
	DD	imagerel $unwind$asciilib_rpartition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$asciilib_rpartition DD 020521H
	DD	06c405H
	DD	imagerel asciilib_rpartition
	DD	imagerel asciilib_rpartition+82
	DD	imagerel $unwind$asciilib_rpartition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_rpartition DD 051801H
	DD	0d0146218H
	DD	060117012H
	DD	05010H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\partition.h
xdata	ENDS
;	COMDAT asciilib_rpartition
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
sep_obj$ = 120
sep$ = 128
sep_len$ = 136
asciilib_rpartition PROC				; COMDAT

; 62   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 55		 push	 r13
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 63   :     PyObject* out;
; 64   :     Py_ssize_t pos;
; 65   : 
; 66   :     if (sep_len == 0) {

  00018	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR sep_len$[rsp]
  00020	4d 8b e9	 mov	 r13, r9
  00023	49 8b e8	 mov	 rbp, r8
  00026	48 8b f2	 mov	 rsi, rdx
  00029	48 85 ff	 test	 rdi, rdi
  0002c	75 1f		 jne	 SHORT $LN4@asciilib_r@3

; 67   :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0002e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  0003c	e8 00 00 00 00	 call	 PyErr_SetString

; 68   :         return NULL;

  00041	33 c0		 xor	 eax, eax

; 102  :     }
; 103  : 
; 104  :     return out;
; 105  : }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	41 5d		 pop	 r13
  00049	5f		 pop	 rdi
  0004a	5e		 pop	 rsi
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
$LN4@asciilib_r@3:

; 69   :     }
; 70   : 
; 71   :     out = PyTuple_New(3);

  0004d	b9 03 00 00 00	 mov	 ecx, 3
  00052	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  00057	e8 00 00 00 00	 call	 PyTuple_New
  0005c	4c 8b e0	 mov	 r12, rax

; 72   :     if (!out)

  0005f	48 85 c0	 test	 rax, rax
  00062	75 0f		 jne	 SHORT $LN3@asciilib_r@3
  00064	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]

; 102  :     }
; 103  : 
; 104  :     return out;
; 105  : }

  00069	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006d	41 5d		 pop	 r13
  0006f	5f		 pop	 rdi
  00070	5e		 pop	 rsi
  00071	5d		 pop	 rbp
  00072	c3		 ret	 0
$LN3@asciilib_r@3:
  00073	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx

; 73   :         return NULL;
; 74   : 
; 75   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_RSEARCH);

  00078	48 8b dd	 mov	 rbx, rbp
  0007b	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00080	48 2b df	 sub	 rbx, rdi
  00083	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00088	78 38		 js	 SHORT $LN90@asciilib_r@3
  0008a	48 83 ff 01	 cmp	 rdi, 1
  0008e	0f 8f 8d 00 00
	00		 jg	 $LN65@asciilib_r@3
  00094	48 85 ff	 test	 rdi, rdi
  00097	7e 29		 jle	 SHORT $LN90@asciilib_r@3
  00099	48 8d 5d ff	 lea	 rbx, QWORD PTR [rbp-1]
  0009d	48 83 fb ff	 cmp	 rbx, -1
  000a1	7e 1f		 jle	 SHORT $LN90@asciilib_r@3
  000a3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  000ab	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000ae	66 90		 npad	 2
$LL49@asciilib_r@3:
  000b0	38 0c 33	 cmp	 BYTE PTR [rbx+rsi], cl
  000b3	0f 84 5b 01 00
	00		 je	 $LN68@asciilib_r@3
  000b9	48 ff cb	 dec	 rbx
  000bc	48 83 fb ff	 cmp	 rbx, -1
  000c0	7f ee		 jg	 SHORT $LL49@asciilib_r@3
$LN90@asciilib_r@3:

; 78   : #if STRINGLIB_MUTABLE
; 79   :         PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(NULL, 0));
; 80   :         PyTuple_SET_ITEM(out, 1, STRINGLIB_NEW(NULL, 0));
; 81   :         PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str, str_len));
; 82   : #else
; 83   :         Py_INCREF(STRINGLIB_EMPTY);

  000c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  000c9	e8 00 00 00 00	 call	 _Py_IncRef

; 84   :         PyTuple_SET_ITEM(out, 0, (PyObject*) STRINGLIB_EMPTY);

  000ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  000d5	49 89 4c 24 70	 mov	 QWORD PTR [r12+112], rcx

; 85   :         Py_INCREF(STRINGLIB_EMPTY);

  000da	e8 00 00 00 00	 call	 _Py_IncRef

; 86   :         PyTuple_SET_ITEM(out, 1, (PyObject*) STRINGLIB_EMPTY);

  000df	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR unicode_empty

; 87   :         Py_INCREF(str_obj);

  000e6	48 8b 5c 24 60	 mov	 rbx, QWORD PTR str_obj$[rsp]
  000eb	4d 89 5c 24 78	 mov	 QWORD PTR [r12+120], r11
  000f0	48 8b cb	 mov	 rcx, rbx
  000f3	e8 00 00 00 00	 call	 _Py_IncRef

; 88   :         PyTuple_SET_ITEM(out, 2, (PyObject*) str_obj);

  000f8	49 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [r12+128], rbx
$LN1@asciilib_r@3:

; 89   : #endif
; 90   :         return out;

  00100	49 8b c4	 mov	 rax, r12
$LN96@asciilib_r@3:
  00103	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]
  00108	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  0010d	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  00112	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]

; 102  :     }
; 103  : 
; 104  :     return out;
; 105  : }

  00117	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011b	41 5d		 pop	 r13
  0011d	5f		 pop	 rdi
  0011e	5e		 pop	 rsi
  0011f	5d		 pop	 rbp
  00120	c3		 ret	 0

; 73   :         return NULL;
; 74   : 
; 75   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_RSEARCH);

$LN65@asciilib_r@3:
  00121	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR sep$[rsp]
  00129	48 8d 6f ff	 lea	 rbp, QWORD PTR [rdi-1]
  0012d	41 be 01 00 00
	00		 mov	 r14d, 1
  00133	45 0f b6 3a	 movzx	 r15d, BYTE PTR [r10]
  00137	4c 8d 6d ff	 lea	 r13, QWORD PTR [rbp-1]
  0013b	41 8b cf	 mov	 ecx, r15d
  0013e	83 e1 1f	 and	 ecx, 31
  00141	41 d3 e6	 shl	 r14d, cl
  00144	48 85 ed	 test	 rbp, rbp
  00147	7e 44		 jle	 SHORT $LN22@asciilib_r@3
  00149	49 83 cb ff	 or	 r11, -1
  0014d	4d 8d 0c 2a	 lea	 r9, QWORD PTR [r10+rbp]
  00151	4d 2b da	 sub	 r11, r10
  00154	4c 8b d5	 mov	 r10, rbp
  00157	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL24@asciilib_r@3:
  00160	45 0f b6 01	 movzx	 r8d, BYTE PTR [r9]
  00164	ba 01 00 00 00	 mov	 edx, 1
  00169	41 8b c8	 mov	 ecx, r8d
  0016c	83 e1 1f	 and	 ecx, 31
  0016f	d3 e2		 shl	 edx, cl
  00171	44 0b f2	 or	 r14d, edx
  00174	45 3a c7	 cmp	 r8b, r15b
  00177	75 04		 jne	 SHORT $LN23@asciilib_r@3
  00179	4f 8d 2c 0b	 lea	 r13, QWORD PTR [r11+r9]
$LN23@asciilib_r@3:
  0017d	49 ff c9	 dec	 r9
  00180	49 ff ca	 dec	 r10
  00183	75 db		 jne	 SHORT $LL24@asciilib_r@3
  00185	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR sep$[rsp]
$LN22@asciilib_r@3:
  0018d	4c 8b c3	 mov	 r8, rbx
  00190	4d 2b c2	 sub	 r8, r10
  00193	4c 03 c6	 add	 r8, rsi
$LL20@asciilib_r@3:
  00196	44 38 3c 33	 cmp	 BYTE PTR [rbx+rsi], r15b
  0019a	75 48		 jne	 SHORT $LN17@asciilib_r@3
  0019c	48 8b d5	 mov	 rdx, rbp
  0019f	48 85 ed	 test	 rbp, rbp
  001a2	7e 20		 jle	 SHORT $LN91@asciilib_r@3
  001a4	49 8d 0c 2a	 lea	 rcx, QWORD PTR [r10+rbp]
  001a8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL16@asciilib_r@3:
  001b0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  001b3	41 38 04 08	 cmp	 BYTE PTR [r8+rcx], al
  001b7	75 0b		 jne	 SHORT $LN91@asciilib_r@3
  001b9	48 ff ca	 dec	 rdx
  001bc	48 ff c9	 dec	 rcx
  001bf	48 85 d2	 test	 rdx, rdx
  001c2	7f ec		 jg	 SHORT $LL16@asciilib_r@3
$LN91@asciilib_r@3:
  001c4	48 85 d2	 test	 rdx, rdx
  001c7	74 41		 je	 SHORT $LN92@asciilib_r@3
  001c9	48 85 db	 test	 rbx, rbx
  001cc	7e 0e		 jle	 SHORT $LN11@asciilib_r@3
  001ce	0f b6 44 33 ff	 movzx	 eax, BYTE PTR [rbx+rsi-1]
  001d3	83 e0 1f	 and	 eax, 31
  001d6	41 0f a3 c6	 bt	 r14d, eax
  001da	73 1b		 jae	 SHORT $LN97@asciilib_r@3
$LN11@asciilib_r@3:
  001dc	49 2b dd	 sub	 rbx, r13
  001df	4d 2b c5	 sub	 r8, r13
  001e2	eb 19		 jmp	 SHORT $LN19@asciilib_r@3
$LN17@asciilib_r@3:
  001e4	48 85 db	 test	 rbx, rbx
  001e7	7e 14		 jle	 SHORT $LN19@asciilib_r@3
  001e9	0f b6 44 33 ff	 movzx	 eax, BYTE PTR [rbx+rsi-1]
  001ee	83 e0 1f	 and	 eax, 31
  001f1	41 0f a3 c6	 bt	 r14d, eax
  001f5	72 06		 jb	 SHORT $LN19@asciilib_r@3
$LN97@asciilib_r@3:
  001f7	48 2b df	 sub	 rbx, rdi
  001fa	4c 2b c7	 sub	 r8, rdi
$LN19@asciilib_r@3:
  001fd	49 ff c8	 dec	 r8
  00200	48 ff cb	 dec	 rbx
  00203	79 91		 jns	 SHORT $LL20@asciilib_r@3
  00205	e9 b8 fe ff ff	 jmp	 $LN90@asciilib_r@3
$LN92@asciilib_r@3:

; 62   : {

  0020a	48 8b 6c 24 70	 mov	 rbp, QWORD PTR str_len$[rsp]
  0020f	4c 8b 6c 24 78	 mov	 r13, QWORD PTR sep_obj$[rsp]

; 73   :         return NULL;
; 74   : 
; 75   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_RSEARCH);

$LN68@asciilib_r@3:

; 76   : 
; 77   :     if (pos < 0) {

  00214	48 85 db	 test	 rbx, rbx
  00217	0f 88 a5 fe ff
	ff		 js	 $LN90@asciilib_r@3

; 91   :     }
; 92   : 
; 93   :     PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, pos));

  0021d	48 8b d3	 mov	 rdx, rbx
  00220	48 8b ce	 mov	 rcx, rsi
  00223	e8 00 00 00 00	 call	 _PyUnicode_FromASCII

; 94   :     Py_INCREF(sep_obj);

  00228	49 8b cd	 mov	 rcx, r13
  0022b	49 89 44 24 70	 mov	 QWORD PTR [r12+112], rax
  00230	e8 00 00 00 00	 call	 _Py_IncRef

; 95   :     PyTuple_SET_ITEM(out, 1, sep_obj);
; 96   :     pos += sep_len;

  00235	48 8d 04 3b	 lea	 rax, QWORD PTR [rbx+rdi]

; 97   :     PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str + pos, str_len - pos));

  00239	48 2b e8	 sub	 rbp, rax
  0023c	48 8d 0c 30	 lea	 rcx, QWORD PTR [rax+rsi]
  00240	4d 89 6c 24 78	 mov	 QWORD PTR [r12+120], r13
  00245	48 8b d5	 mov	 rdx, rbp
  00248	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  0024d	49 89 84 24 80
	00 00 00	 mov	 QWORD PTR [r12+128], rax

; 98   : 
; 99   :     if (PyErr_Occurred()) {

  00255	e8 00 00 00 00	 call	 PyErr_Occurred
  0025a	48 85 c0	 test	 rax, rax
  0025d	0f 84 9d fe ff
	ff		 je	 $LN1@asciilib_r@3

; 100  :         Py_DECREF(out);

  00263	49 8b cc	 mov	 rcx, r12
  00266	e8 00 00 00 00	 call	 _Py_DecRef

; 101  :         return NULL;

  0026b	33 c0		 xor	 eax, eax
  0026d	e9 91 fe ff ff	 jmp	 $LN96@asciilib_r@3
asciilib_rpartition ENDP
_TEXT	ENDS
EXTRN	PyList_Append:PROC
EXTRN	PyList_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$asciilib_split_whitespace DD imagerel asciilib_split_whitespace
	DD	imagerel asciilib_split_whitespace+639
	DD	imagerel $unwind$asciilib_split_whitespace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_split_whitespace DD 0c6101H
	DD	0d7461H
	DD	0c3455H
	DD	0e5412H
	DD	0f00e5212H
	DD	0d00ae00cH
	DD	06006c008H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT asciilib_split_whitespace
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
maxcount$ = 120
asciilib_split_whitespace PROC				; COMDAT

; 57   : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	41 56		 push	 r14
  0000c	41 57		 push	 r15
  0000e	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 58   :     Py_ssize_t i, j, count=0;

  00012	45 33 e4	 xor	 r12d, r12d
  00015	4c 8b f9	 mov	 r15, rcx
  00018	4d 8b e9	 mov	 r13, r9
  0001b	49 8b f0	 mov	 rsi, r8
  0001e	48 8b ea	 mov	 rbp, rdx

; 59   :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00021	41 8d 4c 24 0c	 lea	 ecx, QWORD PTR [r12+12]
  00026	49 83 f9 0c	 cmp	 r9, 12
  0002a	7d 04		 jge	 SHORT $LN27@asciilib_s
  0002c	49 8d 49 01	 lea	 rcx, QWORD PTR [r9+1]
$LN27@asciilib_s:
  00030	e8 00 00 00 00	 call	 PyList_New
  00035	4c 8b f0	 mov	 r14, rax

; 60   :     PyObject *sub;
; 61   : 
; 62   :     if (list == NULL)

  00038	48 85 c0	 test	 rax, rax
  0003b	75 13		 jne	 SHORT $LN23@asciilib_s

; 99   : }

  0003d	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00042	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00046	41 5f		 pop	 r15
  00048	41 5e		 pop	 r14
  0004a	41 5d		 pop	 r13
  0004c	41 5c		 pop	 r12
  0004e	5e		 pop	 rsi
  0004f	c3		 ret	 0
$LN23@asciilib_s:
  00050	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx

; 63   :         return NULL;
; 64   : 
; 65   :     i = j = 0;
; 66   :     while (maxcount-- > 0) {

  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
  0005c	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  00061	49 8b dc	 mov	 rbx, r12
  00064	4d 85 ed	 test	 r13, r13
  00067	0f 8e 5b 01 00
	00		 jle	 $LN55@asciilib_s
  0006d	0f 1f 00	 npad	 3
$LL22@asciilib_s:
  00070	49 ff cd	 dec	 r13

; 67   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  00073	48 3b de	 cmp	 rbx, rsi
  00076	7d 2f		 jge	 SHORT $LN65@asciilib_s
$LL20@asciilib_s:
  00078	0f b6 04 2b	 movzx	 eax, BYTE PTR [rbx+rbp]
  0007c	3c 80		 cmp	 al, 128			; 00000080H
  0007e	73 09		 jae	 SHORT $LN28@asciilib_s
  00080	0f b6 c0	 movzx	 eax, al
  00083	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00087	eb 0f		 jmp	 SHORT $LN29@asciilib_s
$LN28@asciilib_s:
  00089	0f b6 c8	 movzx	 ecx, al
  0008c	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
$LN29@asciilib_s:
  00098	85 c0		 test	 eax, eax
  0009a	74 08		 je	 SHORT $LN61@asciilib_s

; 68   :             i++;

  0009c	48 ff c3	 inc	 rbx
  0009f	48 3b de	 cmp	 rbx, rsi
  000a2	7c d4		 jl	 SHORT $LL20@asciilib_s
$LN61@asciilib_s:

; 69   :         if (i == str_len) break;

  000a4	48 3b de	 cmp	 rbx, rsi
$LN65@asciilib_s:
  000a7	0f 84 1b 01 00
	00		 je	 $LN55@asciilib_s

; 70   :         j = i; i++;

  000ad	48 8b fb	 mov	 rdi, rbx
  000b0	48 ff c3	 inc	 rbx

; 71   :         while (i < str_len && !STRINGLIB_ISSPACE(str[i]))

  000b3	48 3b de	 cmp	 rbx, rsi
  000b6	7d 2c		 jge	 SHORT $LN62@asciilib_s
$LL17@asciilib_s:
  000b8	0f b6 04 2b	 movzx	 eax, BYTE PTR [rbx+rbp]
  000bc	3c 80		 cmp	 al, 128			; 00000080H
  000be	73 09		 jae	 SHORT $LN30@asciilib_s
  000c0	0f b6 c0	 movzx	 eax, al
  000c3	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000c7	eb 0f		 jmp	 SHORT $LN31@asciilib_s
$LN30@asciilib_s:
  000c9	0f b6 c8	 movzx	 ecx, al
  000cc	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
$LN31@asciilib_s:
  000d8	85 c0		 test	 eax, eax
  000da	75 08		 jne	 SHORT $LN62@asciilib_s

; 72   :             i++;

  000dc	48 ff c3	 inc	 rbx
  000df	48 3b de	 cmp	 rbx, rsi
  000e2	7c d4		 jl	 SHORT $LL17@asciilib_s
$LN62@asciilib_s:

; 73   : #ifndef STRINGLIB_MUTABLE
; 74   :         if (j == 0 && i == str_len && STRINGLIB_CHECK_EXACT(str_obj)) {

  000e4	48 85 ff	 test	 rdi, rdi
  000e7	75 16		 jne	 SHORT $LN15@asciilib_s
  000e9	48 3b de	 cmp	 rbx, rsi
  000ec	75 11		 jne	 SHORT $LN15@asciilib_s
  000ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  000f5	49 39 47 58	 cmp	 QWORD PTR [r15+88], rax
  000f9	0f 84 b7 00 00
	00		 je	 $LN50@asciilib_s
$LN15@asciilib_s:

; 79   :             break;
; 80   :         }
; 81   : #endif
; 82   :         SPLIT_ADD(str, j, i);

  000ff	48 8b d3	 mov	 rdx, rbx
  00102	48 8d 0c 2f	 lea	 rcx, QWORD PTR [rdi+rbp]
  00106	48 2b d7	 sub	 rdx, rdi
  00109	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  0010e	48 8b f8	 mov	 rdi, rax
  00111	48 85 c0	 test	 rax, rax
  00114	0f 84 d7 00 00
	00		 je	 $onError$120940
  0011a	49 83 fc 0c	 cmp	 r12, 12
  0011e	7d 0a		 jge	 SHORT $LN13@asciilib_s
  00120	49 8b 4e 70	 mov	 rcx, QWORD PTR [r14+112]
  00124	4a 89 04 e1	 mov	 QWORD PTR [rcx+r12*8], rax
  00128	eb 78		 jmp	 SHORT $LN44@asciilib_s
$LN13@asciilib_s:
  0012a	48 8b d0	 mov	 rdx, rax
  0012d	49 8b ce	 mov	 rcx, r14
  00130	e8 00 00 00 00	 call	 PyList_Append
  00135	85 c0		 test	 eax, eax
  00137	0f 85 ac 00 00
	00		 jne	 $LN52@asciilib_s
  0013d	e8 00 00 00 00	 call	 _Py_PXCTX
  00142	85 c0		 test	 eax, eax
  00144	75 5c		 jne	 SHORT $LN44@asciilib_s
  00146	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0014a	a8 20		 test	 al, 32			; 00000020H
  0014c	75 4c		 jne	 SHORT $LN38@asciilib_s
  0014e	84 c0		 test	 al, al
  00150	78 48		 js	 SHORT $LN38@asciilib_s
  00152	a8 02		 test	 al, 2
  00154	75 4c		 jne	 SHORT $LN44@asciilib_s
  00156	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0015a	75 46		 jne	 SHORT $LN44@asciilib_s
  0015c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00163	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0016a	4c 8b cf	 mov	 r9, rdi
  0016d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00173	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0017b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00180	48 8b cf	 mov	 rcx, rdi
  00183	85 c0		 test	 eax, eax
  00185	74 07		 je	 SHORT $LN43@asciilib_s
  00187	e8 00 00 00 00	 call	 _Px_Dealloc
  0018c	eb 14		 jmp	 SHORT $LN44@asciilib_s
$LN43@asciilib_s:
  0018e	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00192	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00198	eb 08		 jmp	 SHORT $LN44@asciilib_s
$LN38@asciilib_s:
  0019a	48 8b cf	 mov	 rcx, rdi
  0019d	e8 00 00 00 00	 call	 Px_DecRef
$LN44@asciilib_s:
  001a2	49 ff c4	 inc	 r12
  001a5	4d 85 ed	 test	 r13, r13
  001a8	7e 1e		 jle	 SHORT $LN55@asciilib_s

; 63   :         return NULL;
; 64   : 
; 65   :     i = j = 0;
; 66   :     while (maxcount-- > 0) {

  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
  001b1	e9 ba fe ff ff	 jmp	 $LL22@asciilib_s
$LN50@asciilib_s:

; 75   :             /* No whitespace in str_obj, so just use it as list[0] */
; 76   :             Py_INCREF(str_obj);

  001b6	49 8b cf	 mov	 rcx, r15
  001b9	e8 00 00 00 00	 call	 _Py_IncRef

; 77   :             PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  001be	4d 8b 5e 70	 mov	 r11, QWORD PTR [r14+112]

; 78   :             count++;

  001c2	49 ff c4	 inc	 r12
  001c5	4d 89 3b	 mov	 QWORD PTR [r11], r15
$LN55@asciilib_s:

; 83   :     }
; 84   : 
; 85   :     if (i < str_len) {

  001c8	48 3b de	 cmp	 rbx, rsi
  001cb	0f 8d 8a 00 00
	00		 jge	 $LN6@asciilib_s
  001d1	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_ascii_whitespace
$LL8@asciilib_s:

; 86   :         /* Only occurs when maxcount was reached */
; 87   :         /* Skip any remaining whitespace and copy to end of string */
; 88   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  001d8	0f b6 04 2b	 movzx	 eax, BYTE PTR [rbx+rbp]
  001dc	3c 80		 cmp	 al, 128			; 00000080H
  001de	73 1d		 jae	 SHORT $LN32@asciilib_s
  001e0	0f b6 c0	 movzx	 eax, al
  001e3	0f b6 04 38	 movzx	 eax, BYTE PTR [rax+rdi]
  001e7	eb 1c		 jmp	 SHORT $LN33@asciilib_s
$LN52@asciilib_s:

; 79   :             break;
; 80   :         }
; 81   : #endif
; 82   :         SPLIT_ADD(str, j, i);

  001e9	48 8b cf	 mov	 rcx, rdi
$LN66@asciilib_s:
  001ec	e8 00 00 00 00	 call	 _Py_DecRef
$onError$120940:

; 95   : 
; 96   :   onError:
; 97   :     Py_DECREF(list);

  001f1	49 8b ce	 mov	 rcx, r14
  001f4	e8 00 00 00 00	 call	 _Py_DecRef

; 98   :     return NULL;

  001f9	33 c0		 xor	 eax, eax
  001fb	eb 65		 jmp	 SHORT $LN64@asciilib_s
$LN32@asciilib_s:

; 86   :         /* Only occurs when maxcount was reached */
; 87   :         /* Skip any remaining whitespace and copy to end of string */
; 88   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  001fd	0f b6 c8	 movzx	 ecx, al
  00200	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
$LN33@asciilib_s:
  00205	85 c0		 test	 eax, eax
  00207	74 08		 je	 SHORT $LN7@asciilib_s

; 89   :             i++;

  00209	48 ff c3	 inc	 rbx
  0020c	48 3b de	 cmp	 rbx, rsi
  0020f	7c c7		 jl	 SHORT $LL8@asciilib_s
$LN7@asciilib_s:

; 90   :         if (i != str_len)

  00211	48 3b de	 cmp	 rbx, rsi
  00214	74 45		 je	 SHORT $LN6@asciilib_s

; 91   :             SPLIT_ADD(str, i, str_len);

  00216	48 2b f3	 sub	 rsi, rbx
  00219	48 8d 0c 2b	 lea	 rcx, QWORD PTR [rbx+rbp]
  0021d	48 8b d6	 mov	 rdx, rsi
  00220	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  00225	48 8b d8	 mov	 rbx, rax
  00228	48 85 c0	 test	 rax, rax
  0022b	74 c4		 je	 SHORT $onError$120940
  0022d	49 83 fc 0c	 cmp	 r12, 12
  00231	7d 0e		 jge	 SHORT $LN4@asciilib_s
  00233	49 8b 4e 70	 mov	 rcx, QWORD PTR [r14+112]
  00237	49 ff c4	 inc	 r12
  0023a	4a 89 44 e1 f8	 mov	 QWORD PTR [rcx+r12*8-8], rax
  0023f	eb 1a		 jmp	 SHORT $LN6@asciilib_s
$LN4@asciilib_s:
  00241	48 8b d0	 mov	 rdx, rax
  00244	49 8b ce	 mov	 rcx, r14
  00247	e8 00 00 00 00	 call	 PyList_Append
  0024c	48 8b cb	 mov	 rcx, rbx
  0024f	85 c0		 test	 eax, eax
  00251	75 99		 jne	 SHORT $LN66@asciilib_s
  00253	e8 00 00 00 00	 call	 _Py_DecRef
  00258	49 ff c4	 inc	 r12
$LN6@asciilib_s:

; 92   :     }
; 93   :     FIX_PREALLOC_SIZE(list);

  0025b	4d 89 66 60	 mov	 QWORD PTR [r14+96], r12

; 94   :     return list;

  0025f	49 8b c6	 mov	 rax, r14
$LN64@asciilib_s:

; 99   : }

  00262	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00267	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  0026c	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00271	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00275	41 5f		 pop	 r15
  00277	41 5e		 pop	 r14
  00279	41 5d		 pop	 r13
  0027b	41 5c		 pop	 r12
  0027d	5e		 pop	 rsi
  0027e	c3		 ret	 0
asciilib_split_whitespace ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$asciilib_split_char DD imagerel asciilib_split_char
	DD	imagerel asciilib_split_char+81
	DD	imagerel $unwind$asciilib_split_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$asciilib_split_char DD imagerel asciilib_split_char+81
	DD	imagerel asciilib_split_char+330
	DD	imagerel $chain$0$asciilib_split_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$asciilib_split_char DD imagerel asciilib_split_char+330
	DD	imagerel asciilib_split_char+354
	DD	imagerel $chain$1$asciilib_split_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$asciilib_split_char DD imagerel asciilib_split_char+354
	DD	imagerel asciilib_split_char+555
	DD	imagerel $chain$2$asciilib_split_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$asciilib_split_char DD 020021H
	DD	0d3400H
	DD	imagerel asciilib_split_char
	DD	imagerel asciilib_split_char+81
	DD	imagerel $unwind$asciilib_split_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$asciilib_split_char DD 021H
	DD	imagerel asciilib_split_char
	DD	imagerel asciilib_split_char+81
	DD	imagerel $unwind$asciilib_split_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$asciilib_split_char DD 020521H
	DD	0d3405H
	DD	imagerel asciilib_split_char
	DD	imagerel asciilib_split_char+81
	DD	imagerel $unwind$asciilib_split_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_split_char DD 0a1c01H
	DD	0f641cH
	DD	0e541cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT asciilib_split_char
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
ch$ = 120
maxcount$ = 128
asciilib_split_char PROC				; COMDAT

; 106  : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 107  :     Py_ssize_t i, j, count=0;
; 108  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  0001c	4c 8b bc 24 80
	00 00 00	 mov	 r15, QWORD PTR maxcount$[rsp]
  00024	33 f6		 xor	 esi, esi
  00026	4c 8b e1	 mov	 r12, rcx
  00029	45 0f b6 f1	 movzx	 r14d, r9b
  0002d	49 8b f8	 mov	 rdi, r8
  00030	4c 8b ea	 mov	 r13, rdx
  00033	8d 4e 0c	 lea	 ecx, QWORD PTR [rsi+12]
  00036	49 83 ff 0c	 cmp	 r15, 12
  0003a	7d 04		 jge	 SHORT $LN24@asciilib_s@2
  0003c	49 8d 4f 01	 lea	 rcx, QWORD PTR [r15+1]
$LN24@asciilib_s@2:
  00040	e8 00 00 00 00	 call	 PyList_New
  00045	48 8b e8	 mov	 rbp, rax

; 109  :     PyObject *sub;
; 110  : 
; 111  :     if (list == NULL)

  00048	48 85 c0	 test	 rax, rax
  0004b	0f 84 f9 00 00
	00		 je	 $LN21@asciilib_s@2
$LN20@asciilib_s@2:
  00051	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx

; 112  :         return NULL;
; 113  : 
; 114  :     i = j = 0;

  00056	48 8b ce	 mov	 rcx, rsi
  00059	48 8b de	 mov	 rbx, rsi

; 115  :     while ((j < str_len) && (maxcount-- > 0)) {

  0005c	48 85 ff	 test	 rdi, rdi
  0005f	0f 8e 81 00 00
	00		 jle	 $LN48@asciilib_s@2
$LL19@asciilib_s@2:
  00065	49 8b c7	 mov	 rax, r15
  00068	49 ff cf	 dec	 r15
  0006b	48 85 c0	 test	 rax, rax
  0006e	7e 68		 jle	 SHORT $LN18@asciilib_s@2

; 116  :         for(; j < str_len; j++) {

  00070	48 3b df	 cmp	 rbx, rdi
  00073	7d 63		 jge	 SHORT $LN18@asciilib_s@2
$LL17@asciilib_s@2:

; 117  :             /* I found that using memchr makes no difference */
; 118  :             if (str[j] == ch) {

  00075	46 38 34 2b	 cmp	 BYTE PTR [rbx+r13], r14b
  00079	74 0a		 je	 SHORT $LN42@asciilib_s@2

; 116  :         for(; j < str_len; j++) {

  0007b	48 ff c3	 inc	 rbx
  0007e	48 3b df	 cmp	 rbx, rdi
  00081	7c f2		 jl	 SHORT $LL17@asciilib_s@2
  00083	eb 53		 jmp	 SHORT $LN18@asciilib_s@2
$LN42@asciilib_s@2:

; 119  :                 SPLIT_ADD(str, i, j);

  00085	48 8b d3	 mov	 rdx, rbx
  00088	48 2b d1	 sub	 rdx, rcx
  0008b	49 03 cd	 add	 rcx, r13
  0008e	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  00093	4c 8b e0	 mov	 r12, rax
  00096	48 85 c0	 test	 rax, rax
  00099	0f 84 09 01 00
	00		 je	 $onError$120996
  0009f	48 83 fe 0c	 cmp	 rsi, 12
  000a3	7d 0a		 jge	 SHORT $LN12@asciilib_s@2
  000a5	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  000a9	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  000ad	eb 1b		 jmp	 SHORT $LN9@asciilib_s@2
$LN12@asciilib_s@2:
  000af	48 8b d0	 mov	 rdx, rax
  000b2	48 8b cd	 mov	 rcx, rbp
  000b5	e8 00 00 00 00	 call	 PyList_Append
  000ba	49 8b cc	 mov	 rcx, r12
  000bd	85 c0		 test	 eax, eax
  000bf	0f 85 de 00 00
	00		 jne	 $LN44@asciilib_s@2
  000c5	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@asciilib_s@2:

; 120  :                 i = j = j + 1;

  000ca	48 ff c3	 inc	 rbx
  000cd	48 ff c6	 inc	 rsi
  000d0	48 8b cb	 mov	 rcx, rbx
  000d3	48 3b df	 cmp	 rbx, rdi
  000d6	7c 8d		 jl	 SHORT $LL19@asciilib_s@2
$LN18@asciilib_s@2:

; 121  :                 break;
; 122  :             }
; 123  :         }
; 124  :     }
; 125  : #ifndef STRINGLIB_MUTABLE
; 126  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  000d8	48 85 f6	 test	 rsi, rsi
  000db	0f 85 81 00 00
	00		 jne	 $LN8@asciilib_s@2
  000e1	4c 8b 64 24 60	 mov	 r12, QWORD PTR str_obj$[rsp]
$LN48@asciilib_s@2:
  000e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  000ed	49 39 44 24 58	 cmp	 QWORD PTR [r12+88], rax
  000f2	75 6e		 jne	 SHORT $LN8@asciilib_s@2

; 127  :         /* ch not in str_obj, so just use str_obj as list[0] */
; 128  :         Py_INCREF(str_obj);

  000f4	e8 00 00 00 00	 call	 _Py_PXCTX
  000f9	85 c0		 test	 eax, eax
  000fb	75 35		 jne	 SHORT $LN26@asciilib_s@2
  000fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0010b	4d 8b cc	 mov	 r9, r12
  0010e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00114	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0011c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00121	85 c0		 test	 eax, eax
  00123	75 08		 jne	 SHORT $LN25@asciilib_s@2
  00125	41 f6 44 24 20
	20		 test	 BYTE PTR [r12+32], 32	; 00000020H
  0012b	74 05		 je	 SHORT $LN26@asciilib_s@2
$LN25@asciilib_s@2:
  0012d	49 ff 44 24 50	 inc	 QWORD PTR [r12+80]
$LN26@asciilib_s@2:

; 129  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  00132	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]

; 130  :         count++;

  00136	be 01 00 00 00	 mov	 esi, 1
  0013b	4c 89 20	 mov	 QWORD PTR [rax], r12
$LN6@asciilib_s@2:

; 135  :     }
; 136  :     FIX_PREALLOC_SIZE(list);

  0013e	48 89 75 60	 mov	 QWORD PTR [rbp+96], rsi

; 137  :     return list;

  00142	48 8b c5	 mov	 rax, rbp
$LN49@asciilib_s@2:
  00145	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
$LN21@asciilib_s@2:

; 142  : }

  0014a	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  0014f	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00154	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00158	41 5f		 pop	 r15
  0015a	41 5e		 pop	 r14
  0015c	41 5d		 pop	 r13
  0015e	41 5c		 pop	 r12
  00160	5f		 pop	 rdi
  00161	c3		 ret	 0
$LN8@asciilib_s@2:

; 131  :     } else
; 132  : #endif
; 133  :     if (i <= str_len) {

  00162	48 3b cf	 cmp	 rcx, rdi
  00165	7f d7		 jg	 SHORT $LN6@asciilib_s@2

; 134  :         SPLIT_ADD(str, i, str_len);

  00167	48 2b f9	 sub	 rdi, rcx
  0016a	49 03 cd	 add	 rcx, r13
  0016d	48 8b d7	 mov	 rdx, rdi
  00170	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  00175	48 8b d8	 mov	 rbx, rax
  00178	48 85 c0	 test	 rax, rax
  0017b	74 2b		 je	 SHORT $onError$120996
  0017d	48 83 fe 0c	 cmp	 rsi, 12
  00181	7d 0e		 jge	 SHORT $LN4@asciilib_s@2
  00183	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  00187	48 ff c6	 inc	 rsi
  0018a	48 89 44 f1 f8	 mov	 QWORD PTR [rcx+rsi*8-8], rax
  0018f	eb ad		 jmp	 SHORT $LN6@asciilib_s@2
$LN4@asciilib_s@2:
  00191	48 8b d0	 mov	 rdx, rax
  00194	48 8b cd	 mov	 rcx, rbp
  00197	e8 00 00 00 00	 call	 PyList_Append
  0019c	48 8b cb	 mov	 rcx, rbx
  0019f	85 c0		 test	 eax, eax
  001a1	74 5b		 je	 SHORT $LN2@asciilib_s@2
$LN44@asciilib_s@2:
  001a3	e8 00 00 00 00	 call	 _Py_DecRef
$onError$120996:

; 138  : 
; 139  :   onError:
; 140  :     Py_DECREF(list);

  001a8	e8 00 00 00 00	 call	 _Py_PXCTX
  001ad	85 c0		 test	 eax, eax
  001af	75 73		 jne	 SHORT $LN39@asciilib_s@2
  001b1	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  001b5	a8 20		 test	 al, 32			; 00000020H
  001b7	75 63		 jne	 SHORT $LN33@asciilib_s@2
  001b9	84 c0		 test	 al, al
  001bb	78 5f		 js	 SHORT $LN33@asciilib_s@2
  001bd	a8 02		 test	 al, 2
  001bf	75 63		 jne	 SHORT $LN39@asciilib_s@2
  001c1	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  001c5	75 5d		 jne	 SHORT $LN39@asciilib_s@2
  001c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001d5	4c 8b cd	 mov	 r9, rbp
  001d8	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001de	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001e6	e8 00 00 00 00	 call	 _PyParallel_Guard
  001eb	48 8b cd	 mov	 rcx, rbp
  001ee	85 c0		 test	 eax, eax
  001f0	74 19		 je	 SHORT $LN38@asciilib_s@2
  001f2	e8 00 00 00 00	 call	 _Px_Dealloc

; 141  :     return NULL;

  001f7	33 c0		 xor	 eax, eax
  001f9	e9 47 ff ff ff	 jmp	 $LN49@asciilib_s@2
$LN2@asciilib_s@2:

; 134  :         SPLIT_ADD(str, i, str_len);

  001fe	e8 00 00 00 00	 call	 _Py_DecRef
  00203	48 ff c6	 inc	 rsi
  00206	e9 33 ff ff ff	 jmp	 $LN6@asciilib_s@2

; 138  : 
; 139  :   onError:
; 140  :     Py_DECREF(list);

$LN38@asciilib_s@2:
  0020b	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  0020f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 141  :     return NULL;

  00215	33 c0		 xor	 eax, eax
  00217	e9 29 ff ff ff	 jmp	 $LN49@asciilib_s@2

; 138  : 
; 139  :   onError:
; 140  :     Py_DECREF(list);

$LN33@asciilib_s@2:
  0021c	48 8b cd	 mov	 rcx, rbp
  0021f	e8 00 00 00 00	 call	 Px_DecRef
$LN39@asciilib_s@2:

; 141  :     return NULL;

  00224	33 c0		 xor	 eax, eax
  00226	e9 1a ff ff ff	 jmp	 $LN49@asciilib_s@2
asciilib_split_char ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$asciilib_split DD imagerel asciilib_split
	DD	imagerel asciilib_split+132
	DD	imagerel $unwind$asciilib_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$asciilib_split DD imagerel asciilib_split+132
	DD	imagerel asciilib_split+190
	DD	imagerel $chain$1$asciilib_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$asciilib_split DD imagerel asciilib_split+190
	DD	imagerel asciilib_split+824
	DD	imagerel $chain$2$asciilib_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$asciilib_split DD imagerel asciilib_split+824
	DD	imagerel asciilib_split+847
	DD	imagerel $chain$3$asciilib_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$asciilib_split DD imagerel asciilib_split+847
	DD	imagerel asciilib_split+960
	DD	imagerel $chain$5$asciilib_split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$asciilib_split DD 060021H
	DD	0ad400H
	DD	0b7400H
	DD	0153400H
	DD	imagerel asciilib_split
	DD	imagerel asciilib_split+132
	DD	imagerel $unwind$asciilib_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$asciilib_split DD 021H
	DD	imagerel asciilib_split+132
	DD	imagerel asciilib_split+190
	DD	imagerel $chain$1$asciilib_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$asciilib_split DD 020821H
	DD	0153408H
	DD	imagerel asciilib_split+132
	DD	imagerel asciilib_split+190
	DD	imagerel $chain$1$asciilib_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$asciilib_split DD 041721H
	DD	0ad417H
	DD	0b7405H
	DD	imagerel asciilib_split
	DD	imagerel asciilib_split+132
	DD	imagerel $unwind$asciilib_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_split DD 061b01H
	DD	0f017b21bH
	DD	0c013e015H
	DD	050106011H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT asciilib_split
_TEXT	SEGMENT
count$1$ = 48
i$1$ = 56
maxcount$1$ = 64
str_obj$ = 144
str$ = 152
str_len$ = 160
sep$ = 168
list$1$ = 176
sep_len$ = 176
maxcount$ = 184
asciilib_split PROC					; COMDAT

; 149  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	41 54		 push	 r12
  00013	41 56		 push	 r14
  00015	41 57		 push	 r15
  00017	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 150  :     Py_ssize_t i, j, pos, count=0;
; 151  :     PyObject *list, *sub;
; 152  : 
; 153  :     if (sep_len == 0) {

  0001b	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR sep_len$[rsp]
  00023	45 33 e4	 xor	 r12d, r12d
  00026	4d 8b f9	 mov	 r15, r9
  00029	49 8b e8	 mov	 rbp, r8
  0002c	4c 8b f2	 mov	 r14, rdx
  0002f	4c 89 64 24 30	 mov	 QWORD PTR count$1$[rsp], r12
  00034	48 85 f6	 test	 rsi, rsi
  00037	75 22		 jne	 SHORT $LN19@asciilib_s@3

; 154  :         PyErr_SetString(PyExc_ValueError, "empty separator");

  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00047	e8 00 00 00 00	 call	 PyErr_SetString

; 155  :         return NULL;

  0004c	33 c0		 xor	 eax, eax

; 190  : }

  0004e	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00052	41 5f		 pop	 r15
  00054	41 5e		 pop	 r14
  00056	41 5c		 pop	 r12
  00058	5e		 pop	 rsi
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
$LN19@asciilib_s@3:

; 156  :     }
; 157  :     else if (sep_len == 1)

  0005b	48 83 fe 01	 cmp	 rsi, 1
  0005f	75 23		 jne	 SHORT $LN17@asciilib_s@3

; 158  :         return STRINGLIB(split_char)(str_obj, str, str_len, sep[0], maxcount);

  00061	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00069	45 0f b6 09	 movzx	 r9d, BYTE PTR [r9]
  0006d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00072	e8 00 00 00 00	 call	 asciilib_split_char

; 190  : }

  00077	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0007b	41 5f		 pop	 r15
  0007d	41 5e		 pop	 r14
  0007f	41 5c		 pop	 r12
  00081	5e		 pop	 rsi
  00082	5d		 pop	 rbp
  00083	c3		 ret	 0
$LN17@asciilib_s@3:
  00084	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi

; 159  : 
; 160  :     list = PyList_New(PREALLOC_SIZE(maxcount));

  00089	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR maxcount$[rsp]
  00091	b9 0c 00 00 00	 mov	 ecx, 12
  00096	4c 89 6c 24 50	 mov	 QWORD PTR [rsp+80], r13
  0009b	48 83 ff 0c	 cmp	 rdi, 12
  0009f	7d 04		 jge	 SHORT $LN23@asciilib_s@3
  000a1	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
$LN23@asciilib_s@3:
  000a5	e8 00 00 00 00	 call	 PyList_New
  000aa	4c 8b e8	 mov	 r13, rax
  000ad	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR list$1$[rsp], rax

; 161  :     if (list == NULL)

  000b5	48 85 c0	 test	 rax, rax
  000b8	0f 84 7a 02 00
	00		 je	 $LN122@asciilib_s@3
$LN16@asciilib_s@3:
  000be	48 89 9c 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rbx

; 162  :         return NULL;
; 163  : 
; 164  :     i = j = 0;

  000c6	33 db		 xor	 ebx, ebx
  000c8	48 89 5c 24 38	 mov	 QWORD PTR i$1$[rsp], rbx

; 165  :     while (maxcount-- > 0) {

  000cd	48 85 ff	 test	 rdi, rdi
  000d0	0f 8e 85 01 00
	00		 jle	 $LN112@asciilib_s@3
  000d6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL15@asciilib_s@3:

; 166  :         pos = FASTSEARCH(str+i, str_len-i, sep, sep_len, -1, FAST_SEARCH);

  000e0	48 8b c5	 mov	 rax, rbp
  000e3	4a 8d 2c 33	 lea	 rbp, QWORD PTR [rbx+r14]
  000e7	48 ff cf	 dec	 rdi
  000ea	48 2b c3	 sub	 rax, rbx
  000ed	48 89 7c 24 40	 mov	 QWORD PTR maxcount$1$[rsp], rdi
  000f2	4c 8b f0	 mov	 r14, rax
  000f5	4c 2b f6	 sub	 r14, rsi
  000f8	0f 88 4c 01 00
	00		 js	 $LN110@asciilib_s@3
  000fe	48 83 fe 01	 cmp	 rsi, 1
  00102	7f 68		 jg	 SHORT $LN82@asciilib_s@3
  00104	48 85 f6	 test	 rsi, rsi
  00107	0f 8e 3d 01 00
	00		 jle	 $LN110@asciilib_s@3
  0010d	48 83 f8 0a	 cmp	 rax, 10
  00111	7e 32		 jle	 SHORT $LN80@asciilib_s@3
  00113	4c 8d 04 28	 lea	 r8, QWORD PTR [rax+rbp]
  00117	49 3b e8	 cmp	 rbp, r8
  0011a	73 18		 jae	 SHORT $LN90@asciilib_s@3
  0011c	41 0f b6 17	 movzx	 edx, BYTE PTR [r15]
  00120	4c 2b c5	 sub	 r8, rbp
  00123	48 8b cd	 mov	 rcx, rbp
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0012c	4c 8b d8	 mov	 r11, rax
  0012f	48 85 c0	 test	 rax, rax
  00132	75 09		 jne	 SHORT $LN89@asciilib_s@3
$LN90@asciilib_s@3:
  00134	49 83 cb ff	 or	 r11, -1
  00138	e9 65 01 00 00	 jmp	 $LN85@asciilib_s@3
$LN89@asciilib_s@3:
  0013d	4c 2b dd	 sub	 r11, rbp
  00140	e9 5d 01 00 00	 jmp	 $LN85@asciilib_s@3
$LN80@asciilib_s@3:
  00145	45 33 db	 xor	 r11d, r11d
  00148	48 85 c0	 test	 rax, rax
  0014b	0f 8e f9 00 00
	00		 jle	 $LN110@asciilib_s@3
  00151	41 0f b6 0f	 movzx	 ecx, BYTE PTR [r15]
$LL71@asciilib_s@3:
  00155	41 38 0c 2b	 cmp	 BYTE PTR [r11+rbp], cl
  00159	0f 84 43 01 00
	00		 je	 $LN85@asciilib_s@3
  0015f	49 ff c3	 inc	 r11
  00162	4c 3b d8	 cmp	 r11, rax
  00165	7c ee		 jl	 SHORT $LL71@asciilib_s@3
  00167	e9 de 00 00 00	 jmp	 $LN110@asciilib_s@3
$LN82@asciilib_s@3:
  0016c	48 8d 7e ff	 lea	 rdi, QWORD PTR [rsi-1]
  00170	45 33 e4	 xor	 r12d, r12d
  00173	4c 8d 6f ff	 lea	 r13, QWORD PTR [rdi-1]
  00177	48 85 ff	 test	 rdi, rdi
  0017a	7e 3f		 jle	 SHORT $LN59@asciilib_s@3
  0017c	42 0f b6 1c 3f	 movzx	 ebx, BYTE PTR [rdi+r15]
  00181	4d 8b cf	 mov	 r9, r15
  00184	4d 8b d5	 mov	 r10, r13
  00187	4c 8b df	 mov	 r11, rdi
  0018a	66 0f 1f 44 00
	00		 npad	 6
$LL61@asciilib_s@3:
  00190	45 0f b6 01	 movzx	 r8d, BYTE PTR [r9]
  00194	ba 01 00 00 00	 mov	 edx, 1
  00199	41 8b c8	 mov	 ecx, r8d
  0019c	83 e1 1f	 and	 ecx, 31
  0019f	d3 e2		 shl	 edx, cl
  001a1	44 0b e2	 or	 r12d, edx
  001a4	44 3a c3	 cmp	 r8b, bl
  001a7	4d 0f 44 ea	 cmove	 r13, r10
  001ab	49 ff c1	 inc	 r9
  001ae	49 ff ca	 dec	 r10
  001b1	49 ff cb	 dec	 r11
  001b4	75 da		 jne	 SHORT $LL61@asciilib_s@3
  001b6	48 8b 5c 24 38	 mov	 rbx, QWORD PTR i$1$[rsp]
$LN59@asciilib_s@3:
  001bb	42 0f b6 0c 3f	 movzx	 ecx, BYTE PTR [rdi+r15]
  001c0	ba 01 00 00 00	 mov	 edx, 1
  001c5	45 33 db	 xor	 r11d, r11d
  001c8	83 e1 1f	 and	 ecx, 31
  001cb	d3 e2		 shl	 edx, cl
  001cd	44 0b e2	 or	 r12d, edx
  001d0	4d 85 f6	 test	 r14, r14
  001d3	78 70		 js	 SHORT $LN120@asciilib_s@3
  001d5	45 0f b6 54 37
	ff		 movzx	 r10d, BYTE PTR [r15+rsi-1]
  001db	4c 8d 0c 2e	 lea	 r9, QWORD PTR [rsi+rbp]
  001df	90		 npad	 1
$LL57@asciilib_s@3:
  001e0	47 38 54 19 ff	 cmp	 BYTE PTR [r9+r11-1], r10b
  001e5	75 45		 jne	 SHORT $LN54@asciilib_s@3
  001e7	33 d2		 xor	 edx, edx
  001e9	48 85 ff	 test	 rdi, rdi
  001ec	7e 26		 jle	 SHORT $LN118@asciilib_s@3
  001ee	4c 8b c5	 mov	 r8, rbp
  001f1	49 8b cf	 mov	 rcx, r15
  001f4	4d 2b c7	 sub	 r8, r15
  001f7	4d 03 c3	 add	 r8, r11
  001fa	66 0f 1f 44 00
	00		 npad	 6
$LL53@asciilib_s@3:
  00200	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00203	41 38 04 08	 cmp	 BYTE PTR [r8+rcx], al
  00207	75 0b		 jne	 SHORT $LN118@asciilib_s@3
  00209	48 ff c2	 inc	 rdx
  0020c	48 ff c1	 inc	 rcx
  0020f	48 3b d7	 cmp	 rdx, rdi
  00212	7c ec		 jl	 SHORT $LL53@asciilib_s@3
$LN118@asciilib_s@3:
  00214	48 3b d7	 cmp	 rdx, rdi
  00217	74 7c		 je	 SHORT $LN102@asciilib_s@3
  00219	43 0f b6 04 19	 movzx	 eax, BYTE PTR [r9+r11]
  0021e	83 e0 1f	 and	 eax, 31
  00221	41 0f a3 c4	 bt	 r12d, eax
  00225	73 13		 jae	 SHORT $LN124@asciilib_s@3
  00227	4d 03 dd	 add	 r11, r13
  0022a	eb 11		 jmp	 SHORT $LN56@asciilib_s@3
$LN54@asciilib_s@3:
  0022c	43 0f b6 04 19	 movzx	 eax, BYTE PTR [r9+r11]
  00231	83 e0 1f	 and	 eax, 31
  00234	41 0f a3 c4	 bt	 r12d, eax
  00238	72 03		 jb	 SHORT $LN56@asciilib_s@3
$LN124@asciilib_s@3:
  0023a	4c 03 de	 add	 r11, rsi
$LN56@asciilib_s@3:
  0023d	49 ff c3	 inc	 r11
  00240	4d 3b de	 cmp	 r11, r14
  00243	7e 9b		 jle	 SHORT $LL57@asciilib_s@3
$LN120@asciilib_s@3:

; 170  :         SPLIT_ADD(str, i, j);

  00245	4c 8b 64 24 30	 mov	 r12, QWORD PTR count$1$[rsp]
$LN110@asciilib_s@3:

; 172  :     }
; 173  : #ifndef STRINGLIB_MUTABLE
; 174  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  0024a	4d 85 e4	 test	 r12, r12
  0024d	0f 85 fc 00 00
	00		 jne	 $LN7@asciilib_s@3
  00253	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]
$LN112@asciilib_s@3:
  0025b	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR str_obj$[rsp]
  00263	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  0026a	48 39 47 58	 cmp	 QWORD PTR [rdi+88], rax
  0026e	0f 85 db 00 00
	00		 jne	 $LN7@asciilib_s@3

; 175  :         /* No match in str_obj, so just use it as list[0] */
; 176  :         Py_INCREF(str_obj);

  00274	48 8b cf	 mov	 rcx, rdi
  00277	e8 00 00 00 00	 call	 _Py_IncRef

; 177  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  0027c	4d 8b 5d 70	 mov	 r11, QWORD PTR [r13+112]

; 178  :         count++;

  00280	41 bc 01 00 00
	00		 mov	 r12d, 1
  00286	49 89 3b	 mov	 QWORD PTR [r11], rdi

; 183  :     }
; 184  :     FIX_PREALLOC_SIZE(list);

  00289	4d 89 65 60	 mov	 QWORD PTR [r13+96], r12

; 185  :     return list;

  0028d	49 8b c5	 mov	 rax, r13
  00290	e9 9b 00 00 00	 jmp	 $LN123@asciilib_s@3
$LN102@asciilib_s@3:
  00295	4c 8b 64 24 30	 mov	 r12, QWORD PTR count$1$[rsp]
  0029a	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]

; 166  :         pos = FASTSEARCH(str+i, str_len-i, sep, sep_len, -1, FAST_SEARCH);

$LN85@asciilib_s@3:

; 167  :         if (pos < 0)

  002a2	4d 85 db	 test	 r11, r11
  002a5	78 a3		 js	 SHORT $LN110@asciilib_s@3

; 168  :             break;
; 169  :         j = i + pos;

  002a7	49 8d 3c 1b	 lea	 rdi, QWORD PTR [r11+rbx]

; 170  :         SPLIT_ADD(str, i, j);

  002ab	48 8b cd	 mov	 rcx, rbp
  002ae	48 8b d7	 mov	 rdx, rdi
  002b1	48 2b d3	 sub	 rdx, rbx
  002b4	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  002b9	48 8b d8	 mov	 rbx, rax
  002bc	48 85 c0	 test	 rax, rax
  002bf	74 60		 je	 SHORT $onError$121058
  002c1	49 83 fc 0c	 cmp	 r12, 12
  002c5	7d 0a		 jge	 SHORT $LN11@asciilib_s@3
  002c7	49 8b 4d 70	 mov	 rcx, QWORD PTR [r13+112]
  002cb	4a 89 04 e1	 mov	 QWORD PTR [rcx+r12*8], rax
  002cf	eb 17		 jmp	 SHORT $LN8@asciilib_s@3
$LN11@asciilib_s@3:
  002d1	48 8b d0	 mov	 rdx, rax
  002d4	49 8b cd	 mov	 rcx, r13
  002d7	e8 00 00 00 00	 call	 PyList_Append
  002dc	48 8b cb	 mov	 rcx, rbx
  002df	85 c0		 test	 eax, eax
  002e1	75 39		 jne	 SHORT $LN105@asciilib_s@3
  002e3	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@asciilib_s@3:

; 171  :         i = j + sep_len;

  002e8	48 8d 1c 37	 lea	 rbx, QWORD PTR [rdi+rsi]
  002ec	48 8b 7c 24 40	 mov	 rdi, QWORD PTR maxcount$1$[rsp]
  002f1	49 ff c4	 inc	 r12
  002f4	4c 89 64 24 30	 mov	 QWORD PTR count$1$[rsp], r12
  002f9	48 89 5c 24 38	 mov	 QWORD PTR i$1$[rsp], rbx
  002fe	48 85 ff	 test	 rdi, rdi
  00301	0f 8e 43 ff ff
	ff		 jle	 $LN110@asciilib_s@3

; 179  :     } else
; 180  : #endif
; 181  :     {
; 182  :         SPLIT_ADD(str, i, str_len);

  00307	48 8b ac 24 a0
	00 00 00	 mov	 rbp, QWORD PTR str_len$[rsp]
  0030f	4c 8b b4 24 98
	00 00 00	 mov	 r14, QWORD PTR str$[rsp]
  00317	e9 c4 fd ff ff	 jmp	 $LL15@asciilib_s@3
$LN105@asciilib_s@3:

; 170  :         SPLIT_ADD(str, i, j);

  0031c	e8 00 00 00 00	 call	 _Py_DecRef
$onError$121058:

; 186  : 
; 187  :   onError:
; 188  :     Py_DECREF(list);

  00321	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR list$1$[rsp]
  00329	e8 00 00 00 00	 call	 _Py_DecRef

; 189  :     return NULL;

  0032e	33 c0		 xor	 eax, eax
$LN123@asciilib_s@3:
  00330	48 8b 9c 24 a8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+168]
$LN122@asciilib_s@3:
  00338	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0033d	4c 8b 6c 24 50	 mov	 r13, QWORD PTR [rsp+80]

; 190  : }

  00342	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00346	41 5f		 pop	 r15
  00348	41 5e		 pop	 r14
  0034a	41 5c		 pop	 r12
  0034c	5e		 pop	 rsi
  0034d	5d		 pop	 rbp
  0034e	c3		 ret	 0
$LN7@asciilib_s@3:

; 179  :     } else
; 180  : #endif
; 181  :     {
; 182  :         SPLIT_ADD(str, i, str_len);

  0034f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00357	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR str_len$[rsp]
  0035f	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
  00363	48 2b d3	 sub	 rdx, rbx
  00366	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  0036b	48 8b d8	 mov	 rbx, rax
  0036e	48 85 c0	 test	 rax, rax
  00371	74 ae		 je	 SHORT $onError$121058
  00373	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]
  0037b	49 83 fc 0c	 cmp	 r12, 12
  0037f	7d 15		 jge	 SHORT $LN4@asciilib_s@3
  00381	49 8b 4d 70	 mov	 rcx, QWORD PTR [r13+112]
  00385	49 ff c4	 inc	 r12
  00388	4a 89 44 e1 f8	 mov	 QWORD PTR [rcx+r12*8-8], rax

; 183  :     }
; 184  :     FIX_PREALLOC_SIZE(list);

  0038d	4d 89 65 60	 mov	 QWORD PTR [r13+96], r12

; 185  :     return list;

  00391	49 8b c5	 mov	 rax, r13
  00394	eb 9a		 jmp	 SHORT $LN123@asciilib_s@3
$LN4@asciilib_s@3:

; 179  :     } else
; 180  : #endif
; 181  :     {
; 182  :         SPLIT_ADD(str, i, str_len);

  00396	48 8b d0	 mov	 rdx, rax
  00399	49 8b cd	 mov	 rcx, r13
  0039c	e8 00 00 00 00	 call	 PyList_Append
  003a1	48 8b cb	 mov	 rcx, rbx
  003a4	85 c0		 test	 eax, eax
  003a6	0f 85 70 ff ff
	ff		 jne	 $LN105@asciilib_s@3
  003ac	e8 00 00 00 00	 call	 _Py_DecRef
  003b1	49 ff c4	 inc	 r12

; 185  :     return list;

  003b4	49 8b c5	 mov	 rax, r13
  003b7	4d 89 65 60	 mov	 QWORD PTR [r13+96], r12
  003bb	e9 70 ff ff ff	 jmp	 $LN123@asciilib_s@3
asciilib_split ENDP
_TEXT	ENDS
EXTRN	PyList_Reverse:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$asciilib_rsplit_whitespace DD imagerel asciilib_rsplit_whitespace
	DD	imagerel asciilib_rsplit_whitespace+671
	DD	imagerel $unwind$asciilib_rsplit_whitespace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_rsplit_whitespace DD 0c5501H
	DD	0df455H
	DD	0c7450H
	DD	0e3411H
	DD	0e00d5211H
	DD	0c009d00bH
	DD	050066007H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT asciilib_rsplit_whitespace
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
maxcount$ = 120
asciilib_rsplit_whitespace PROC				; COMDAT

; 196  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 197  :     Py_ssize_t i, j, count=0;

  00011	33 ed		 xor	 ebp, ebp
  00013	4c 8b f1	 mov	 r14, rcx
  00016	4d 8b e9	 mov	 r13, r9
  00019	49 8b d8	 mov	 rbx, r8
  0001c	48 8b f2	 mov	 rsi, rdx

; 198  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  0001f	8d 4d 0c	 lea	 ecx, QWORD PTR [rbp+12]
  00022	49 83 f9 0c	 cmp	 r9, 12
  00026	7d 04		 jge	 SHORT $LN28@asciilib_r@4
  00028	49 8d 49 01	 lea	 rcx, QWORD PTR [r9+1]
$LN28@asciilib_r@4:
  0002c	e8 00 00 00 00	 call	 PyList_New
  00031	4c 8b e0	 mov	 r12, rax

; 199  :     PyObject *sub;
; 200  : 
; 201  :     if (list == NULL)

  00034	48 85 c0	 test	 rax, rax
  00037	75 12		 jne	 SHORT $LN24@asciilib_r@4

; 240  : }

  00039	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	41 5e		 pop	 r14
  00044	41 5d		 pop	 r13
  00046	41 5c		 pop	 r12
  00048	5e		 pop	 rsi
  00049	5d		 pop	 rbp
  0004a	c3		 ret	 0
$LN24@asciilib_r@4:
  0004b	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00050	4c 89 7c 24 68	 mov	 QWORD PTR [rsp+104], r15

; 202  :         return NULL;
; 203  : 
; 204  :     i = j = str_len - 1;

  00055	4c 8d 7b ff	 lea	 r15, QWORD PTR [rbx-1]
  00059	49 8b df	 mov	 rbx, r15
$LN68@asciilib_r@4:

; 205  :     while (maxcount-- > 0) {

  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
  00063	4d 85 ed	 test	 r13, r13
  00066	0f 8e 69 01 00
	00		 jle	 $LN56@asciilib_r@4
  0006c	49 ff cd	 dec	 r13

; 206  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  0006f	48 85 db	 test	 rbx, rbx
  00072	0f 88 eb 01 00
	00		 js	 $LN7@asciilib_r@4
$LL21@asciilib_r@4:
  00078	0f b6 04 33	 movzx	 eax, BYTE PTR [rbx+rsi]
  0007c	3c 80		 cmp	 al, 128			; 00000080H
  0007e	73 09		 jae	 SHORT $LN29@asciilib_r@4
  00080	0f b6 c0	 movzx	 eax, al
  00083	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00087	eb 0f		 jmp	 SHORT $LN30@asciilib_r@4
$LN29@asciilib_r@4:
  00089	0f b6 c8	 movzx	 ecx, al
  0008c	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
$LN30@asciilib_r@4:
  00098	85 c0		 test	 eax, eax
  0009a	74 0a		 je	 SHORT $LN20@asciilib_r@4

; 207  :             i--;

  0009c	48 ff cb	 dec	 rbx

; 206  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  0009f	79 d7		 jns	 SHORT $LL21@asciilib_r@4
  000a1	e9 bd 01 00 00	 jmp	 $LN7@asciilib_r@4
$LN20@asciilib_r@4:

; 208  :         if (i < 0) break;

  000a6	48 85 db	 test	 rbx, rbx
  000a9	0f 88 b4 01 00
	00		 js	 $LN7@asciilib_r@4

; 209  :         j = i; i--;

  000af	48 8b fb	 mov	 rdi, rbx
  000b2	48 ff cb	 dec	 rbx

; 210  :         while (i >= 0 && !STRINGLIB_ISSPACE(str[i]))

  000b5	78 29		 js	 SHORT $LN63@asciilib_r@4
$LL18@asciilib_r@4:
  000b7	0f b6 04 33	 movzx	 eax, BYTE PTR [rbx+rsi]
  000bb	3c 80		 cmp	 al, 128			; 00000080H
  000bd	73 09		 jae	 SHORT $LN31@asciilib_r@4
  000bf	0f b6 c0	 movzx	 eax, al
  000c2	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000c6	eb 0f		 jmp	 SHORT $LN32@asciilib_r@4
$LN31@asciilib_r@4:
  000c8	0f b6 c8	 movzx	 ecx, al
  000cb	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
$LN32@asciilib_r@4:
  000d7	85 c0		 test	 eax, eax
  000d9	75 05		 jne	 SHORT $LN63@asciilib_r@4

; 211  :             i--;

  000db	48 ff cb	 dec	 rbx

; 210  :         while (i >= 0 && !STRINGLIB_ISSPACE(str[i]))

  000de	79 d7		 jns	 SHORT $LL18@asciilib_r@4
$LN63@asciilib_r@4:

; 212  : #ifndef STRINGLIB_MUTABLE
; 213  :         if (j == str_len - 1 && i < 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  000e0	49 3b ff	 cmp	 rdi, r15
  000e3	75 16		 jne	 SHORT $LN16@asciilib_r@4
  000e5	48 85 db	 test	 rbx, rbx
  000e8	79 11		 jns	 SHORT $LN16@asciilib_r@4
  000ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  000f1	49 39 46 58	 cmp	 QWORD PTR [r14+88], rax
  000f5	0f 84 c0 00 00
	00		 je	 $LN51@asciilib_r@4
$LN16@asciilib_r@4:

; 219  :         }
; 220  : #endif
; 221  :         SPLIT_ADD(str, i + 1, j + 1);

  000fb	48 2b fb	 sub	 rdi, rbx
  000fe	48 8d 4c 33 01	 lea	 rcx, QWORD PTR [rbx+rsi+1]
  00103	48 8b d7	 mov	 rdx, rdi
  00106	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  0010b	48 8b f8	 mov	 rdi, rax
  0010e	48 85 c0	 test	 rax, rax
  00111	0f 84 5d 01 00
	00		 je	 $onError$121121
  00117	48 83 fd 0c	 cmp	 rbp, 12
  0011b	7d 12		 jge	 SHORT $LN14@asciilib_r@4
  0011d	49 8b 4c 24 70	 mov	 rcx, QWORD PTR [r12+112]
  00122	48 ff c5	 inc	 rbp
  00125	48 89 44 e9 f8	 mov	 QWORD PTR [rcx+rbp*8-8], rax
  0012a	e9 2d ff ff ff	 jmp	 $LN68@asciilib_r@4
$LN14@asciilib_r@4:
  0012f	48 8b d0	 mov	 rdx, rax
  00132	49 8b cc	 mov	 rcx, r12
  00135	e8 00 00 00 00	 call	 PyList_Append
  0013a	85 c0		 test	 eax, eax
  0013c	0f 85 af 00 00
	00		 jne	 $LN53@asciilib_r@4
  00142	e8 00 00 00 00	 call	 _Py_PXCTX
  00147	85 c0		 test	 eax, eax
  00149	75 68		 jne	 SHORT $LN45@asciilib_r@4
  0014b	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0014f	a8 20		 test	 al, 32			; 00000020H
  00151	75 58		 jne	 SHORT $LN39@asciilib_r@4
  00153	84 c0		 test	 al, al
  00155	78 54		 js	 SHORT $LN39@asciilib_r@4
  00157	a8 02		 test	 al, 2
  00159	75 58		 jne	 SHORT $LN45@asciilib_r@4
  0015b	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0015f	75 52		 jne	 SHORT $LN45@asciilib_r@4
  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00168	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0016f	4c 8b cf	 mov	 r9, rdi
  00172	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00178	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00180	e8 00 00 00 00	 call	 _PyParallel_Guard
  00185	48 8b cf	 mov	 rcx, rdi
  00188	85 c0		 test	 eax, eax
  0018a	74 0d		 je	 SHORT $LN44@asciilib_r@4
  0018c	e8 00 00 00 00	 call	 _Px_Dealloc
  00191	48 ff c5	 inc	 rbp
  00194	e9 c3 fe ff ff	 jmp	 $LN68@asciilib_r@4
$LN44@asciilib_r@4:
  00199	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0019d	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001a3	48 ff c5	 inc	 rbp
  001a6	e9 b1 fe ff ff	 jmp	 $LN68@asciilib_r@4
$LN39@asciilib_r@4:
  001ab	48 8b cf	 mov	 rcx, rdi
  001ae	e8 00 00 00 00	 call	 Px_DecRef
$LN45@asciilib_r@4:
  001b3	48 ff c5	 inc	 rbp

; 205  :     while (maxcount-- > 0) {

  001b6	e9 a1 fe ff ff	 jmp	 $LN68@asciilib_r@4
$LN51@asciilib_r@4:

; 214  :             /* No whitespace in str_obj, so just use it as list[0] */
; 215  :             Py_INCREF(str_obj);

  001bb	49 8b ce	 mov	 rcx, r14
  001be	e8 00 00 00 00	 call	 _Py_IncRef

; 216  :             PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  001c3	4d 8b 5c 24 70	 mov	 r11, QWORD PTR [r12+112]

; 217  :             count++;

  001c8	48 ff c5	 inc	 rbp
  001cb	4d 89 33	 mov	 QWORD PTR [r11], r14

; 218  :             break;

  001ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
$LN56@asciilib_r@4:

; 222  :     }
; 223  : 
; 224  :     if (i >= 0) {

  001d5	48 85 db	 test	 rbx, rbx
  001d8	0f 88 85 00 00
	00		 js	 $LN7@asciilib_r@4
  001de	66 90		 npad	 2
$LL9@asciilib_r@4:

; 225  :         /* Only occurs when maxcount was reached */
; 226  :         /* Skip any remaining whitespace and copy to beginning of string */
; 227  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  001e0	0f b6 04 33	 movzx	 eax, BYTE PTR [rbx+rsi]
  001e4	3c 80		 cmp	 al, 128			; 00000080H
  001e6	73 1d		 jae	 SHORT $LN33@asciilib_r@4
  001e8	0f b6 c0	 movzx	 eax, al
  001eb	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  001ef	eb 23		 jmp	 SHORT $LN34@asciilib_r@4
$LN53@asciilib_r@4:

; 219  :         }
; 220  : #endif
; 221  :         SPLIT_ADD(str, i + 1, j + 1);

  001f1	48 8b cf	 mov	 rcx, rdi
$LN69@asciilib_r@4:
  001f4	e8 00 00 00 00	 call	 _Py_DecRef

; 236  : 
; 237  :   onError:
; 238  :     Py_DECREF(list);

  001f9	49 8b cc	 mov	 rcx, r12
  001fc	e8 00 00 00 00	 call	 _Py_DecRef

; 239  :     return NULL;

  00201	33 c0		 xor	 eax, eax
  00203	eb 7e		 jmp	 SHORT $LN66@asciilib_r@4
$LN33@asciilib_r@4:

; 225  :         /* Only occurs when maxcount was reached */
; 226  :         /* Skip any remaining whitespace and copy to beginning of string */
; 227  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  00205	0f b6 c8	 movzx	 ecx, al
  00208	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  0020d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
$LN34@asciilib_r@4:
  00214	85 c0		 test	 eax, eax
  00216	74 07		 je	 SHORT $LN8@asciilib_r@4

; 228  :             i--;

  00218	48 ff cb	 dec	 rbx

; 225  :         /* Only occurs when maxcount was reached */
; 226  :         /* Skip any remaining whitespace and copy to beginning of string */
; 227  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  0021b	79 c3		 jns	 SHORT $LL9@asciilib_r@4

; 229  :         if (i >= 0)

  0021d	eb 44		 jmp	 SHORT $LN7@asciilib_r@4
$LN8@asciilib_r@4:
  0021f	48 85 db	 test	 rbx, rbx
  00222	78 3f		 js	 SHORT $LN7@asciilib_r@4

; 230  :             SPLIT_ADD(str, 0, i + 1);

  00224	48 8d 53 01	 lea	 rdx, QWORD PTR [rbx+1]
  00228	48 8b ce	 mov	 rcx, rsi
  0022b	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  00230	48 8b d8	 mov	 rbx, rax
  00233	48 85 c0	 test	 rax, rax
  00236	74 3c		 je	 SHORT $onError$121121
  00238	48 83 fd 0c	 cmp	 rbp, 12
  0023c	7d 0b		 jge	 SHORT $LN5@asciilib_r@4
  0023e	49 8b 4c 24 70	 mov	 rcx, QWORD PTR [r12+112]
  00243	48 89 04 e9	 mov	 QWORD PTR [rcx+rbp*8], rax
  00247	eb 17		 jmp	 SHORT $LN2@asciilib_r@4
$LN5@asciilib_r@4:
  00249	48 8b d0	 mov	 rdx, rax
  0024c	49 8b cc	 mov	 rcx, r12
  0024f	e8 00 00 00 00	 call	 PyList_Append
  00254	48 8b cb	 mov	 rcx, rbx
  00257	85 c0		 test	 eax, eax
  00259	75 99		 jne	 SHORT $LN69@asciilib_r@4
  0025b	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@asciilib_r@4:
  00260	48 ff c5	 inc	 rbp
$LN7@asciilib_r@4:

; 231  :     }
; 232  :     FIX_PREALLOC_SIZE(list);
; 233  :     if (PyList_Reverse(list) < 0)

  00263	49 8b cc	 mov	 rcx, r12
  00266	49 89 6c 24 60	 mov	 QWORD PTR [r12+96], rbp
  0026b	e8 00 00 00 00	 call	 PyList_Reverse
  00270	85 c0		 test	 eax, eax
  00272	79 0c		 jns	 SHORT $LN1@asciilib_r@4
$onError$121121:

; 236  : 
; 237  :   onError:
; 238  :     Py_DECREF(list);

  00274	49 8b cc	 mov	 rcx, r12
  00277	e8 00 00 00 00	 call	 _Py_DecRef

; 239  :     return NULL;

  0027c	33 c0		 xor	 eax, eax
  0027e	eb 03		 jmp	 SHORT $LN66@asciilib_r@4
$LN1@asciilib_r@4:

; 234  :         goto onError;
; 235  :     return list;

  00280	49 8b c4	 mov	 rax, r12
$LN66@asciilib_r@4:
  00283	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00288	4c 8b 7c 24 68	 mov	 r15, QWORD PTR [rsp+104]

; 240  : }

  0028d	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00292	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00296	41 5e		 pop	 r14
  00298	41 5d		 pop	 r13
  0029a	41 5c		 pop	 r12
  0029c	5e		 pop	 rsi
  0029d	5d		 pop	 rbp
  0029e	c3		 ret	 0
asciilib_rsplit_whitespace ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$asciilib_rsplit_char DD imagerel asciilib_rsplit_char
	DD	imagerel asciilib_rsplit_char+80
	DD	imagerel $unwind$asciilib_rsplit_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$asciilib_rsplit_char DD imagerel asciilib_rsplit_char+80
	DD	imagerel asciilib_rsplit_char+503
	DD	imagerel $chain$0$asciilib_rsplit_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$asciilib_rsplit_char DD imagerel asciilib_rsplit_char+503
	DD	imagerel asciilib_rsplit_char+527
	DD	imagerel $chain$1$asciilib_rsplit_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$asciilib_rsplit_char DD 021H
	DD	imagerel asciilib_rsplit_char
	DD	imagerel asciilib_rsplit_char+80
	DD	imagerel $unwind$asciilib_rsplit_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$asciilib_rsplit_char DD 020521H
	DD	0c5405H
	DD	imagerel asciilib_rsplit_char
	DD	imagerel asciilib_rsplit_char+80
	DD	imagerel $unwind$asciilib_rsplit_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_rsplit_char DD 0a1701H
	DD	0e6417H
	DD	0d3417H
	DD	0f0135217H
	DD	0d00fe011H
	DD	0700bc00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT asciilib_rsplit_char
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
ch$ = 120
maxcount$ = 128
asciilib_rsplit_char PROC				; COMDAT

; 247  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 248  :     Py_ssize_t i, j, count=0;
; 249  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00017	4c 8b b4 24 80
	00 00 00	 mov	 r14, QWORD PTR maxcount$[rsp]
  0001f	33 f6		 xor	 esi, esi
  00021	4c 8b f9	 mov	 r15, rcx
  00024	45 0f b6 e9	 movzx	 r13d, r9b
  00028	49 8b d8	 mov	 rbx, r8
  0002b	4c 8b e2	 mov	 r12, rdx
  0002e	8d 4e 0c	 lea	 ecx, QWORD PTR [rsi+12]
  00031	49 83 fe 0c	 cmp	 r14, 12
  00035	7d 04		 jge	 SHORT $LN25@asciilib_r@5
  00037	49 8d 4e 01	 lea	 rcx, QWORD PTR [r14+1]
$LN25@asciilib_r@5:
  0003b	e8 00 00 00 00	 call	 PyList_New
  00040	48 8b f8	 mov	 rdi, rax

; 250  :     PyObject *sub;
; 251  : 
; 252  :     if (list == NULL)

  00043	48 85 c0	 test	 rax, rax
  00046	0f 84 ab 01 00
	00		 je	 $LN22@asciilib_r@5
$LN21@asciilib_r@5:

; 253  :         return NULL;
; 254  : 
; 255  :     i = j = str_len - 1;

  0004c	48 8d 53 ff	 lea	 rdx, QWORD PTR [rbx-1]
  00050	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  00055	48 8b da	 mov	 rbx, rdx

; 256  :     while ((i >= 0) && (maxcount-- > 0)) {

  00058	48 85 d2	 test	 rdx, rdx
  0005b	78 74		 js	 SHORT $LN49@asciilib_r@5
  0005d	0f 1f 00	 npad	 3
$LL20@asciilib_r@5:
  00060	49 8b c6	 mov	 rax, r14
  00063	49 ff ce	 dec	 r14
  00066	48 85 c0	 test	 rax, rax
  00069	7e 61		 jle	 SHORT $LN19@asciilib_r@5

; 257  :         for(; i >= 0; i--) {

  0006b	48 85 db	 test	 rbx, rbx
  0006e	78 5c		 js	 SHORT $LN19@asciilib_r@5
$LL18@asciilib_r@5:

; 258  :             if (str[i] == ch) {

  00070	46 38 2c 23	 cmp	 BYTE PTR [rbx+r12], r13b
  00074	74 07		 je	 SHORT $LN43@asciilib_r@5

; 257  :         for(; i >= 0; i--) {

  00076	48 ff cb	 dec	 rbx
  00079	79 f5		 jns	 SHORT $LL18@asciilib_r@5
  0007b	eb 4f		 jmp	 SHORT $LN19@asciilib_r@5
$LN43@asciilib_r@5:

; 259  :                 SPLIT_ADD(str, i + 1, j + 1);

  0007d	4a 8d 4c 23 01	 lea	 rcx, QWORD PTR [rbx+r12+1]
  00082	48 2b d3	 sub	 rdx, rbx
  00085	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  0008a	48 8b e8	 mov	 rbp, rax
  0008d	48 85 c0	 test	 rax, rax
  00090	0f 84 ec 00 00
	00		 je	 $onError$121178
  00096	48 83 fe 0c	 cmp	 rsi, 12
  0009a	7d 0a		 jge	 SHORT $LN13@asciilib_r@5
  0009c	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  000a0	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  000a4	eb 1b		 jmp	 SHORT $LN10@asciilib_r@5
$LN13@asciilib_r@5:
  000a6	48 8b d0	 mov	 rdx, rax
  000a9	48 8b cf	 mov	 rcx, rdi
  000ac	e8 00 00 00 00	 call	 PyList_Append
  000b1	48 8b cd	 mov	 rcx, rbp
  000b4	85 c0		 test	 eax, eax
  000b6	0f 85 a7 00 00
	00		 jne	 $LN45@asciilib_r@5
  000bc	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@asciilib_r@5:
  000c1	48 ff c6	 inc	 rsi

; 260  :                 j = i = i - 1;

  000c4	48 ff cb	 dec	 rbx
  000c7	48 8b d3	 mov	 rdx, rbx
  000ca	79 94		 jns	 SHORT $LL20@asciilib_r@5
$LN19@asciilib_r@5:

; 261  :                 break;
; 262  :             }
; 263  :         }
; 264  :     }
; 265  : #ifndef STRINGLIB_MUTABLE
; 266  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  000cc	48 85 f6	 test	 rsi, rsi
  000cf	75 57		 jne	 SHORT $LN9@asciilib_r@5
$LN49@asciilib_r@5:
  000d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  000d8	49 39 47 58	 cmp	 QWORD PTR [r15+88], rax
  000dc	75 4a		 jne	 SHORT $LN9@asciilib_r@5

; 267  :         /* ch not in str_obj, so just use str_obj as list[0] */
; 268  :         Py_INCREF(str_obj);

  000de	e8 00 00 00 00	 call	 _Py_PXCTX
  000e3	85 c0		 test	 eax, eax
  000e5	75 33		 jne	 SHORT $LN27@asciilib_r@5
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000f5	4d 8b cf	 mov	 r9, r15
  000f8	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000fe	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00106	e8 00 00 00 00	 call	 _PyParallel_Guard
  0010b	85 c0		 test	 eax, eax
  0010d	75 07		 jne	 SHORT $LN26@asciilib_r@5
  0010f	41 f6 47 20 20	 test	 BYTE PTR [r15+32], 32	; 00000020H
  00114	74 04		 je	 SHORT $LN27@asciilib_r@5
$LN26@asciilib_r@5:
  00116	49 ff 47 50	 inc	 QWORD PTR [r15+80]
$LN27@asciilib_r@5:

; 269  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  0011a	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]

; 270  :         count++;

  0011e	be 01 00 00 00	 mov	 esi, 1
  00123	4c 89 38	 mov	 QWORD PTR [rax], r15

; 271  :     } else

  00126	eb 4a		 jmp	 SHORT $LN7@asciilib_r@5
$LN9@asciilib_r@5:

; 272  : #endif
; 273  :     if (j >= -1) {

  00128	48 83 fa ff	 cmp	 rdx, -1
  0012c	7c 44		 jl	 SHORT $LN7@asciilib_r@5

; 274  :         SPLIT_ADD(str, 0, j + 1);

  0012e	48 ff c2	 inc	 rdx
  00131	49 8b cc	 mov	 rcx, r12
  00134	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  00139	48 8b d8	 mov	 rbx, rax
  0013c	48 85 c0	 test	 rax, rax
  0013f	74 41		 je	 SHORT $onError$121178
  00141	48 83 fe 0c	 cmp	 rsi, 12
  00145	7d 0a		 jge	 SHORT $LN5@asciilib_r@5
  00147	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  0014b	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  0014f	eb 1e		 jmp	 SHORT $LN2@asciilib_r@5
$LN5@asciilib_r@5:
  00151	48 8b d0	 mov	 rdx, rax
  00154	48 8b cf	 mov	 rcx, rdi
  00157	e8 00 00 00 00	 call	 PyList_Append
  0015c	48 8b cb	 mov	 rcx, rbx
  0015f	85 c0		 test	 eax, eax
  00161	74 07		 je	 SHORT $LN3@asciilib_r@5
$LN45@asciilib_r@5:
  00163	e8 00 00 00 00	 call	 _Py_DecRef
  00168	eb 18		 jmp	 SHORT $onError$121178
$LN3@asciilib_r@5:
  0016a	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@asciilib_r@5:
  0016f	48 ff c6	 inc	 rsi
$LN7@asciilib_r@5:

; 275  :     }
; 276  :     FIX_PREALLOC_SIZE(list);
; 277  :     if (PyList_Reverse(list) < 0)

  00172	48 8b cf	 mov	 rcx, rdi
  00175	48 89 77 60	 mov	 QWORD PTR [rdi+96], rsi
  00179	e8 00 00 00 00	 call	 PyList_Reverse
  0017e	85 c0		 test	 eax, eax
  00180	79 6d		 jns	 SHORT $LN1@asciilib_r@5
$onError$121178:

; 280  : 
; 281  :   onError:
; 282  :     Py_DECREF(list);

  00182	e8 00 00 00 00	 call	 _Py_PXCTX
  00187	85 c0		 test	 eax, eax
  00189	75 60		 jne	 SHORT $LN40@asciilib_r@5
  0018b	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0018f	a8 20		 test	 al, 32			; 00000020H
  00191	75 50		 jne	 SHORT $LN34@asciilib_r@5
  00193	84 c0		 test	 al, al
  00195	78 4c		 js	 SHORT $LN34@asciilib_r@5
  00197	a8 02		 test	 al, 2
  00199	75 50		 jne	 SHORT $LN40@asciilib_r@5
  0019b	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0019f	75 4a		 jne	 SHORT $LN40@asciilib_r@5
  001a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001af	4c 8b cf	 mov	 r9, rdi
  001b2	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001b8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001c0	e8 00 00 00 00	 call	 _PyParallel_Guard
  001c5	48 8b cf	 mov	 rcx, rdi
  001c8	85 c0		 test	 eax, eax
  001ca	74 09		 je	 SHORT $LN39@asciilib_r@5
  001cc	e8 00 00 00 00	 call	 _Px_Dealloc

; 283  :     return NULL;

  001d1	33 c0		 xor	 eax, eax
  001d3	eb 1d		 jmp	 SHORT $LN50@asciilib_r@5

; 280  : 
; 281  :   onError:
; 282  :     Py_DECREF(list);

$LN39@asciilib_r@5:
  001d5	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001d9	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 283  :     return NULL;

  001df	33 c0		 xor	 eax, eax
  001e1	eb 0f		 jmp	 SHORT $LN50@asciilib_r@5

; 280  : 
; 281  :   onError:
; 282  :     Py_DECREF(list);

$LN34@asciilib_r@5:
  001e3	48 8b cf	 mov	 rcx, rdi
  001e6	e8 00 00 00 00	 call	 Px_DecRef
$LN40@asciilib_r@5:

; 283  :     return NULL;

  001eb	33 c0		 xor	 eax, eax
  001ed	eb 03		 jmp	 SHORT $LN50@asciilib_r@5
$LN1@asciilib_r@5:

; 278  :         goto onError;
; 279  :     return list;

  001ef	48 8b c7	 mov	 rax, rdi
$LN50@asciilib_r@5:
  001f2	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
$LN22@asciilib_r@5:

; 284  : }

  001f7	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  001fc	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  00201	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00205	41 5f		 pop	 r15
  00207	41 5e		 pop	 r14
  00209	41 5d		 pop	 r13
  0020b	41 5c		 pop	 r12
  0020d	5f		 pop	 rdi
  0020e	c3		 ret	 0
asciilib_rsplit_char ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$asciilib_rsplit DD imagerel asciilib_rsplit
	DD	imagerel asciilib_rsplit+130
	DD	imagerel $unwind$asciilib_rsplit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$asciilib_rsplit DD imagerel asciilib_rsplit+130
	DD	imagerel asciilib_rsplit+744
	DD	imagerel $chain$1$asciilib_rsplit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$asciilib_rsplit DD imagerel asciilib_rsplit+744
	DD	imagerel asciilib_rsplit+836
	DD	imagerel $chain$3$asciilib_rsplit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$asciilib_rsplit DD 040021H
	DD	08e400H
	DD	011d400H
	DD	imagerel asciilib_rsplit
	DD	imagerel asciilib_rsplit+130
	DD	imagerel $unwind$asciilib_rsplit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$asciilib_rsplit DD 040d21H
	DD	08e40dH
	DD	011d408H
	DD	imagerel asciilib_rsplit
	DD	imagerel asciilib_rsplit+130
	DD	imagerel $unwind$asciilib_rsplit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_rsplit DD 071601H
	DD	0f0128216H
	DD	0700ec010H
	DD	0500c600dH
	DD	0300bH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT asciilib_rsplit
_TEXT	SEGMENT
j$1$ = 48
maxcount$1$ = 56
str_obj$ = 128
str$ = 136
str_len$ = 144
sep$ = 152
list$1$ = 160
sep_len$ = 160
maxcount$ = 168
asciilib_rsplit PROC					; COMDAT

; 291  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	41 54		 push	 r12
  00010	41 57		 push	 r15
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 292  :     Py_ssize_t j, pos, count=0;
; 293  :     PyObject *list, *sub;
; 294  : 
; 295  :     if (sep_len == 0) {

  00016	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR sep_len$[rsp]
  0001e	45 33 ff	 xor	 r15d, r15d
  00021	4d 8b e1	 mov	 r12, r9
  00024	49 8b f8	 mov	 rdi, r8
  00027	4c 89 44 24 30	 mov	 QWORD PTR j$1$[rsp], r8
  0002c	48 8b ea	 mov	 rbp, rdx
  0002f	48 8b d9	 mov	 rbx, rcx
  00032	48 85 f6	 test	 rsi, rsi
  00035	75 22		 jne	 SHORT $LN20@asciilib_r@6

; 296  :         PyErr_SetString(PyExc_ValueError, "empty separator");

  00037	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00045	e8 00 00 00 00	 call	 PyErr_SetString

; 297  :         return NULL;

  0004a	33 c0		 xor	 eax, eax

; 333  : }

  0004c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00050	41 5f		 pop	 r15
  00052	41 5c		 pop	 r12
  00054	5f		 pop	 rdi
  00055	5e		 pop	 rsi
  00056	5d		 pop	 rbp
  00057	5b		 pop	 rbx
  00058	c3		 ret	 0
$LN20@asciilib_r@6:

; 298  :     }
; 299  :     else if (sep_len == 1)

  00059	48 83 fe 01	 cmp	 rsi, 1
  0005d	75 23		 jne	 SHORT $LN18@asciilib_r@6

; 300  :         return STRINGLIB(rsplit_char)(str_obj, str, str_len, sep[0], maxcount);

  0005f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00067	45 0f b6 09	 movzx	 r9d, BYTE PTR [r9]
  0006b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00070	e8 00 00 00 00	 call	 asciilib_rsplit_char

; 333  : }

  00075	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00079	41 5f		 pop	 r15
  0007b	41 5c		 pop	 r12
  0007d	5f		 pop	 rdi
  0007e	5e		 pop	 rsi
  0007f	5d		 pop	 rbp
  00080	5b		 pop	 rbx
  00081	c3		 ret	 0
$LN18@asciilib_r@6:
  00082	4c 89 ac 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], r13
  0008a	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14

; 301  : 
; 302  :     list = PyList_New(PREALLOC_SIZE(maxcount));

  0008f	4c 8b b4 24 a8
	00 00 00	 mov	 r14, QWORD PTR maxcount$[rsp]
  00097	b9 0c 00 00 00	 mov	 ecx, 12
  0009c	49 83 fe 0c	 cmp	 r14, 12
  000a0	7d 04		 jge	 SHORT $LN24@asciilib_r@6
  000a2	49 8d 4e 01	 lea	 rcx, QWORD PTR [r14+1]
$LN24@asciilib_r@6:
  000a6	e8 00 00 00 00	 call	 PyList_New
  000ab	4c 8b e8	 mov	 r13, rax
  000ae	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR list$1$[rsp], rax

; 303  :     if (list == NULL)

  000b6	48 85 c0	 test	 rax, rax

; 304  :         return NULL;

  000b9	0f 84 0d 02 00
	00		 je	 $LN123@asciilib_r@6

; 305  : 
; 306  :     j = str_len;
; 307  :     while (maxcount-- > 0) {

  000bf	4d 85 f6	 test	 r14, r14
  000c2	7e 67		 jle	 SHORT $LN113@asciilib_r@6
  000c4	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL16@asciilib_r@6:
  000d0	49 ff ce	 dec	 r14

; 308  :         pos = FASTSEARCH(str, j, sep, sep_len, -1, FAST_RSEARCH);

  000d3	48 8b df	 mov	 rbx, rdi
  000d6	48 2b de	 sub	 rbx, rsi
  000d9	4c 89 74 24 38	 mov	 QWORD PTR maxcount$1$[rsp], r14
  000de	78 32		 js	 SHORT $LN111@asciilib_r@6
  000e0	48 83 fe 01	 cmp	 rsi, 1
  000e4	7f 70		 jg	 SHORT $LN83@asciilib_r@6
  000e6	48 85 f6	 test	 rsi, rsi
  000e9	7e 27		 jle	 SHORT $LN111@asciilib_r@6
  000eb	48 8d 5f ff	 lea	 rbx, QWORD PTR [rdi-1]
  000ef	48 83 fb ff	 cmp	 rbx, -1
  000f3	7e 1d		 jle	 SHORT $LN111@asciilib_r@6
  000f5	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  000fa	66 0f 1f 44 00
	00		 npad	 6
$LL67@asciilib_r@6:
  00100	38 04 2b	 cmp	 BYTE PTR [rbx+rbp], al
  00103	0f 84 4b 01 00
	00		 je	 $LN103@asciilib_r@6
  00109	48 ff cb	 dec	 rbx
  0010c	48 83 fb ff	 cmp	 rbx, -1
  00110	7f ee		 jg	 SHORT $LL67@asciilib_r@6
$LN111@asciilib_r@6:

; 313  :     }
; 314  : #ifndef STRINGLIB_MUTABLE
; 315  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  00112	4d 85 ff	 test	 r15, r15
  00115	0f 85 cd 01 00
	00		 jne	 $LN8@asciilib_r@6
  0011b	4c 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]
  00123	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR str_obj$[rsp]
$LN113@asciilib_r@6:
  0012b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00132	48 39 43 58	 cmp	 QWORD PTR [rbx+88], rax
  00136	0f 85 ac 01 00
	00		 jne	 $LN8@asciilib_r@6

; 316  :         /* No match in str_obj, so just use it as list[0] */
; 317  :         Py_INCREF(str_obj);

  0013c	48 8b cb	 mov	 rcx, rbx
  0013f	e8 00 00 00 00	 call	 _Py_IncRef

; 318  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  00144	4d 8b 5d 70	 mov	 r11, QWORD PTR [r13+112]

; 319  :         count++;

  00148	41 bf 01 00 00
	00		 mov	 r15d, 1
  0014e	49 89 1b	 mov	 QWORD PTR [r11], rbx

; 320  :     } else

  00151	e9 d9 01 00 00	 jmp	 $LN7@asciilib_r@6

; 308  :         pos = FASTSEARCH(str, j, sep, sep_len, -1, FAST_RSEARCH);

$LN83@asciilib_r@6:
  00156	4c 8b 94 24 98
	00 00 00	 mov	 r10, QWORD PTR sep$[rsp]
  0015e	48 8d 7e ff	 lea	 rdi, QWORD PTR [rsi-1]
  00162	41 bd 01 00 00
	00		 mov	 r13d, 1
  00168	45 0f b6 32	 movzx	 r14d, BYTE PTR [r10]
  0016c	4c 8d 67 ff	 lea	 r12, QWORD PTR [rdi-1]
  00170	41 8b ce	 mov	 ecx, r14d
  00173	83 e1 1f	 and	 ecx, 31
  00176	41 d3 e5	 shl	 r13d, cl
  00179	48 85 ff	 test	 rdi, rdi
  0017c	7e 3f		 jle	 SHORT $LN40@asciilib_r@6
  0017e	49 83 cb ff	 or	 r11, -1
  00182	4e 8d 0c 17	 lea	 r9, QWORD PTR [rdi+r10]
  00186	4d 2b da	 sub	 r11, r10
  00189	4c 8b d7	 mov	 r10, rdi
  0018c	0f 1f 40 00	 npad	 4
$LL42@asciilib_r@6:
  00190	45 0f b6 01	 movzx	 r8d, BYTE PTR [r9]
  00194	ba 01 00 00 00	 mov	 edx, 1
  00199	41 8b c8	 mov	 ecx, r8d
  0019c	83 e1 1f	 and	 ecx, 31
  0019f	d3 e2		 shl	 edx, cl
  001a1	44 0b ea	 or	 r13d, edx
  001a4	45 3a c6	 cmp	 r8b, r14b
  001a7	75 04		 jne	 SHORT $LN41@asciilib_r@6
  001a9	4f 8d 24 0b	 lea	 r12, QWORD PTR [r11+r9]
$LN41@asciilib_r@6:
  001ad	49 ff c9	 dec	 r9
  001b0	49 ff ca	 dec	 r10
  001b3	75 db		 jne	 SHORT $LL42@asciilib_r@6
  001b5	4c 8b 94 24 98
	00 00 00	 mov	 r10, QWORD PTR sep$[rsp]
$LN40@asciilib_r@6:
  001bd	4c 8b c3	 mov	 r8, rbx
  001c0	4d 2b c2	 sub	 r8, r10
  001c3	4c 03 c5	 add	 r8, rbp
$LL38@asciilib_r@6:
  001c6	44 38 34 2b	 cmp	 BYTE PTR [rbx+rbp], r14b
  001ca	75 48		 jne	 SHORT $LN35@asciilib_r@6
  001cc	48 8b d7	 mov	 rdx, rdi
  001cf	48 85 ff	 test	 rdi, rdi
  001d2	7e 20		 jle	 SHORT $LN119@asciilib_r@6
  001d4	4a 8d 0c 17	 lea	 rcx, QWORD PTR [rdi+r10]
  001d8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL34@asciilib_r@6:
  001e0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  001e3	41 38 04 08	 cmp	 BYTE PTR [r8+rcx], al
  001e7	75 0b		 jne	 SHORT $LN119@asciilib_r@6
  001e9	48 ff ca	 dec	 rdx
  001ec	48 ff c9	 dec	 rcx
  001ef	48 85 d2	 test	 rdx, rdx
  001f2	7f ec		 jg	 SHORT $LL34@asciilib_r@6
$LN119@asciilib_r@6:
  001f4	48 85 d2	 test	 rdx, rdx
  001f7	74 41		 je	 SHORT $LN120@asciilib_r@6
  001f9	48 85 db	 test	 rbx, rbx
  001fc	7e 0e		 jle	 SHORT $LN29@asciilib_r@6
  001fe	0f b6 44 2b ff	 movzx	 eax, BYTE PTR [rbx+rbp-1]
  00203	83 e0 1f	 and	 eax, 31
  00206	41 0f a3 c5	 bt	 r13d, eax
  0020a	73 1b		 jae	 SHORT $LN124@asciilib_r@6
$LN29@asciilib_r@6:
  0020c	49 2b dc	 sub	 rbx, r12
  0020f	4d 2b c4	 sub	 r8, r12
  00212	eb 19		 jmp	 SHORT $LN37@asciilib_r@6
$LN35@asciilib_r@6:
  00214	48 85 db	 test	 rbx, rbx
  00217	7e 14		 jle	 SHORT $LN37@asciilib_r@6
  00219	0f b6 44 2b ff	 movzx	 eax, BYTE PTR [rbx+rbp-1]
  0021e	83 e0 1f	 and	 eax, 31
  00221	41 0f a3 c5	 bt	 r13d, eax
  00225	72 06		 jb	 SHORT $LN37@asciilib_r@6
$LN124@asciilib_r@6:
  00227	48 2b de	 sub	 rbx, rsi
  0022a	4c 2b c6	 sub	 r8, rsi
$LN37@asciilib_r@6:
  0022d	49 ff c8	 dec	 r8
  00230	48 ff cb	 dec	 rbx
  00233	79 91		 jns	 SHORT $LL38@asciilib_r@6
  00235	e9 d8 fe ff ff	 jmp	 $LN111@asciilib_r@6
$LN120@asciilib_r@6:

; 312  :         j = pos;

  0023a	48 8b 7c 24 30	 mov	 rdi, QWORD PTR j$1$[rsp]
  0023f	4c 8b a4 24 98
	00 00 00	 mov	 r12, QWORD PTR sep$[rsp]
  00247	4c 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]
  0024f	4c 8b 74 24 38	 mov	 r14, QWORD PTR maxcount$1$[rsp]
$LN103@asciilib_r@6:

; 309  :         if (pos < 0)

  00254	48 85 db	 test	 rbx, rbx
  00257	0f 88 b5 fe ff
	ff		 js	 $LN111@asciilib_r@6

; 310  :             break;
; 311  :         SPLIT_ADD(str, pos + sep_len, j);

  0025d	48 2b fb	 sub	 rdi, rbx
  00260	48 8d 0c 2b	 lea	 rcx, QWORD PTR [rbx+rbp]
  00264	48 2b fe	 sub	 rdi, rsi
  00267	48 03 ce	 add	 rcx, rsi
  0026a	48 8b d7	 mov	 rdx, rdi
  0026d	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  00272	48 8b f8	 mov	 rdi, rax
  00275	48 85 c0	 test	 rax, rax
  00278	74 45		 je	 SHORT $onError$121240
  0027a	49 83 ff 0c	 cmp	 r15, 12
  0027e	7d 0a		 jge	 SHORT $LN12@asciilib_r@6
  00280	49 8b 4d 70	 mov	 rcx, QWORD PTR [r13+112]
  00284	4a 89 04 f9	 mov	 QWORD PTR [rcx+r15*8], rax
  00288	eb 17		 jmp	 SHORT $LN9@asciilib_r@6
$LN12@asciilib_r@6:
  0028a	48 8b d0	 mov	 rdx, rax
  0028d	49 8b cd	 mov	 rcx, r13
  00290	e8 00 00 00 00	 call	 PyList_Append
  00295	48 8b cf	 mov	 rcx, rdi
  00298	85 c0		 test	 eax, eax
  0029a	75 1e		 jne	 SHORT $LN106@asciilib_r@6
  0029c	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@asciilib_r@6:
  002a1	49 ff c7	 inc	 r15

; 312  :         j = pos;

  002a4	48 8b fb	 mov	 rdi, rbx
  002a7	48 89 5c 24 30	 mov	 QWORD PTR j$1$[rsp], rbx
  002ac	4d 85 f6	 test	 r14, r14
  002af	0f 8f 1b fe ff
	ff		 jg	 $LL16@asciilib_r@6

; 324  :     }
; 325  :     FIX_PREALLOC_SIZE(list);
; 326  :     if (PyList_Reverse(list) < 0)

  002b5	e9 58 fe ff ff	 jmp	 $LN111@asciilib_r@6
$LN106@asciilib_r@6:

; 310  :             break;
; 311  :         SPLIT_ADD(str, pos + sep_len, j);

  002ba	e8 00 00 00 00	 call	 _Py_DecRef
$onError$121240:

; 329  : 
; 330  :   onError:
; 331  :     Py_DECREF(list);

  002bf	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR list$1$[rsp]
  002c7	e8 00 00 00 00	 call	 _Py_DecRef
$LN123@asciilib_r@6:

; 332  :     return NULL;

  002cc	33 c0		 xor	 eax, eax
$LN122@asciilib_r@6:
  002ce	4c 8b ac 24 88
	00 00 00	 mov	 r13, QWORD PTR [rsp+136]
  002d6	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]

; 333  : }

  002db	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002df	41 5f		 pop	 r15
  002e1	41 5c		 pop	 r12
  002e3	5f		 pop	 rdi
  002e4	5e		 pop	 rsi
  002e5	5d		 pop	 rbp
  002e6	5b		 pop	 rbx
  002e7	c3		 ret	 0
$LN8@asciilib_r@6:

; 321  : #endif
; 322  :     {
; 323  :         SPLIT_ADD(str, 0, j);

  002e8	48 8b 54 24 30	 mov	 rdx, QWORD PTR j$1$[rsp]
  002ed	48 8b cd	 mov	 rcx, rbp
  002f0	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  002f5	48 8b d8	 mov	 rbx, rax
  002f8	48 85 c0	 test	 rax, rax
  002fb	74 c2		 je	 SHORT $onError$121240
  002fd	4c 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]
  00305	49 83 ff 0c	 cmp	 r15, 12
  00309	7d 0a		 jge	 SHORT $LN5@asciilib_r@6
  0030b	49 8b 4d 70	 mov	 rcx, QWORD PTR [r13+112]
  0030f	4a 89 04 f9	 mov	 QWORD PTR [rcx+r15*8], rax
  00313	eb 17		 jmp	 SHORT $LN2@asciilib_r@6
$LN5@asciilib_r@6:
  00315	48 8b d0	 mov	 rdx, rax
  00318	49 8b cd	 mov	 rcx, r13
  0031b	e8 00 00 00 00	 call	 PyList_Append
  00320	48 8b cb	 mov	 rcx, rbx
  00323	85 c0		 test	 eax, eax
  00325	75 93		 jne	 SHORT $LN106@asciilib_r@6
  00327	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@asciilib_r@6:
  0032c	49 ff c7	 inc	 r15
$LN7@asciilib_r@6:

; 324  :     }
; 325  :     FIX_PREALLOC_SIZE(list);
; 326  :     if (PyList_Reverse(list) < 0)

  0032f	49 8b cd	 mov	 rcx, r13
  00332	4d 89 7d 60	 mov	 QWORD PTR [r13+96], r15
  00336	e8 00 00 00 00	 call	 PyList_Reverse
  0033b	85 c0		 test	 eax, eax
  0033d	78 80		 js	 SHORT $onError$121240

; 327  :         goto onError;
; 328  :     return list;

  0033f	49 8b c5	 mov	 rax, r13
  00342	eb 8a		 jmp	 SHORT $LN122@asciilib_r@6
asciilib_rsplit ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_IsLinebreak:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$asciilib_splitlines DD imagerel asciilib_splitlines
	DD	imagerel asciilib_splitlines+53
	DD	imagerel $unwind$asciilib_splitlines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$asciilib_splitlines DD imagerel asciilib_splitlines+53
	DD	imagerel asciilib_splitlines+414
	DD	imagerel $chain$2$asciilib_splitlines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$asciilib_splitlines DD imagerel asciilib_splitlines+414
	DD	imagerel asciilib_splitlines+451
	DD	imagerel $chain$4$asciilib_splitlines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$asciilib_splitlines DD 060021H
	DD	0ef400H
	DD	0d7400H
	DD	0c3400H
	DD	imagerel asciilib_splitlines
	DD	imagerel asciilib_splitlines+53
	DD	imagerel $unwind$asciilib_splitlines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$asciilib_splitlines DD 061121H
	DD	0ef411H
	DD	0d740aH
	DD	0c3405H
	DD	imagerel asciilib_splitlines
	DD	imagerel asciilib_splitlines+53
	DD	imagerel $unwind$asciilib_splitlines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$asciilib_splitlines DD 060d01H
	DD	0e009520dH
	DD	0c005d007H
	DD	050026003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT asciilib_splitlines
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
keepends$ = 120
asciilib_splitlines PROC				; COMDAT

; 339  : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000d	4c 8b e9	 mov	 r13, rcx

; 340  :     /* This does not use the preallocated list because splitlines is
; 341  :        usually run with hundreds of newlines.  The overhead of
; 342  :        switching between PyList_SET_ITEM and append causes about a
; 343  :        2-3% slowdown for that common case.  A smarter implementation
; 344  :        could move the if check out, so the SET_ITEMs are done first
; 345  :        and the appends only done when the prealloc buffer is full.
; 346  :        That's too much work for little gain.*/
; 347  : 
; 348  :     register Py_ssize_t i;
; 349  :     register Py_ssize_t j;
; 350  :     PyObject *list = PyList_New(0);

  00010	33 c9		 xor	 ecx, ecx
  00012	45 8b f1	 mov	 r14d, r9d
  00015	49 8b f0	 mov	 rsi, r8
  00018	48 8b ea	 mov	 rbp, rdx
  0001b	e8 00 00 00 00	 call	 PyList_New
  00020	4c 8b e0	 mov	 r12, rax

; 351  :     PyObject *sub;
; 352  : 
; 353  :     if (list == NULL)

  00023	48 85 c0	 test	 rax, rax
  00026	75 0d		 jne	 SHORT $LN14@asciilib_s@4

; 389  : }

  00028	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002c	41 5e		 pop	 r14
  0002e	41 5d		 pop	 r13
  00030	41 5c		 pop	 r12
  00032	5e		 pop	 rsi
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
$LN14@asciilib_s@4:
  00035	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  0003a	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi

; 354  :         return NULL;
; 355  : 
; 356  :     for (i = j = 0; i < str_len; ) {

  0003f	33 ff		 xor	 edi, edi
  00041	4c 89 7c 24 70	 mov	 QWORD PTR [rsp+112], r15
  00046	8b df		 mov	 ebx, edi
  00048	48 85 f6	 test	 rsi, rsi
  0004b	0f 8e 2e 01 00
	00		 jle	 $LN12@asciilib_s@4
  00051	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:ascii_linebreak
$LN48@asciilib_s@4:
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyUnicode_Type

; 357  :         Py_ssize_t eol;
; 358  : 
; 359  :         /* Find a line and append it */
; 360  :         while (i < str_len && !STRINGLIB_ISLINEBREAK(str[i]))

  0005f	48 3b de	 cmp	 rbx, rsi
  00062	7d 3d		 jge	 SHORT $LN40@asciilib_s@4
$LL11@asciilib_s@4:
  00064	0f b6 04 2b	 movzx	 eax, BYTE PTR [rbx+rbp]
  00068	3c 80		 cmp	 al, 128			; 00000080H
  0006a	73 0a		 jae	 SHORT $LN19@asciilib_s@4
  0006c	0f b6 c0	 movzx	 eax, al
  0006f	42 0f b6 04 38	 movzx	 eax, BYTE PTR [rax+r15]
  00074	eb 18		 jmp	 SHORT $LN47@asciilib_s@4
$LN19@asciilib_s@4:
  00076	0f b6 c8	 movzx	 ecx, al
  00079	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR bloom_linebreak
  0007f	8b d1		 mov	 edx, ecx
  00081	83 e2 1f	 and	 edx, 31
  00084	0f a3 d0	 bt	 eax, edx
  00087	73 09		 jae	 SHORT $LN39@asciilib_s@4
  00089	e8 00 00 00 00	 call	 _PyUnicode_IsLinebreak
$LN47@asciilib_s@4:
  0008e	85 c0		 test	 eax, eax
  00090	75 08		 jne	 SHORT $LN42@asciilib_s@4
$LN39@asciilib_s@4:

; 361  :             i++;

  00092	48 ff c3	 inc	 rbx
  00095	48 3b de	 cmp	 rbx, rsi
  00098	7c ca		 jl	 SHORT $LL11@asciilib_s@4
$LN42@asciilib_s@4:
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyUnicode_Type
$LN40@asciilib_s@4:

; 362  : 
; 363  :         /* Skip the line break reading CRLF as one line break */
; 364  :         eol = i;

  000a1	48 8b d3	 mov	 rdx, rbx

; 365  :         if (i < str_len) {

  000a4	48 3b de	 cmp	 rbx, rsi
  000a7	7d 26		 jge	 SHORT $LN6@asciilib_s@4

; 366  :             if (str[i] == '\r' && i + 1 < str_len && str[i+1] == '\n')

  000a9	80 3c 2b 0d	 cmp	 BYTE PTR [rbx+rbp], 13
  000ad	75 16		 jne	 SHORT $LN8@asciilib_s@4
  000af	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
  000b3	48 3b c6	 cmp	 rax, rsi
  000b6	7d 0d		 jge	 SHORT $LN8@asciilib_s@4
  000b8	80 7c 2b 01 0a	 cmp	 BYTE PTR [rbx+rbp+1], 10
  000bd	75 06		 jne	 SHORT $LN8@asciilib_s@4

; 367  :                 i += 2;

  000bf	48 83 c3 02	 add	 rbx, 2

; 368  :             else

  000c3	eb 03		 jmp	 SHORT $LN7@asciilib_s@4
$LN8@asciilib_s@4:

; 369  :                 i++;

  000c5	48 ff c3	 inc	 rbx
$LN7@asciilib_s@4:

; 370  :             if (keepends)

  000c8	45 85 f6	 test	 r14d, r14d
  000cb	48 0f 45 d3	 cmovne	 rdx, rbx
$LN6@asciilib_s@4:

; 371  :                 eol = i;
; 372  :         }
; 373  : #ifndef STRINGLIB_MUTABLE
; 374  :         if (j == 0 && eol == str_len && STRINGLIB_CHECK_EXACT(str_obj)) {

  000cf	48 85 ff	 test	 rdi, rdi
  000d2	75 0f		 jne	 SHORT $LN5@asciilib_s@4
  000d4	48 3b d6	 cmp	 rdx, rsi
  000d7	75 0a		 jne	 SHORT $LN5@asciilib_s@4
  000d9	49 39 4d 58	 cmp	 QWORD PTR [r13+88], rcx
  000dd	0f 84 bb 00 00
	00		 je	 $LN34@asciilib_s@4
$LN5@asciilib_s@4:

; 379  :         }
; 380  : #endif
; 381  :         SPLIT_APPEND(str, j, eol);

  000e3	48 8d 0c 2f	 lea	 rcx, QWORD PTR [rdi+rbp]
  000e7	48 2b d7	 sub	 rdx, rdi
  000ea	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  000ef	48 8b f8	 mov	 rdi, rax
  000f2	48 85 c0	 test	 rax, rax
  000f5	0f 84 bc 00 00
	00		 je	 $onError$121299
  000fb	48 8b d0	 mov	 rdx, rax
  000fe	49 8b cc	 mov	 rcx, r12
  00101	e8 00 00 00 00	 call	 PyList_Append
  00106	85 c0		 test	 eax, eax
  00108	0f 85 a1 00 00
	00		 jne	 $LN36@asciilib_s@4
  0010e	e8 00 00 00 00	 call	 _Py_PXCTX
  00113	85 c0		 test	 eax, eax
  00115	75 5c		 jne	 SHORT $LN31@asciilib_s@4
  00117	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0011b	a8 20		 test	 al, 32			; 00000020H
  0011d	75 4c		 jne	 SHORT $LN25@asciilib_s@4
  0011f	84 c0		 test	 al, al
  00121	78 48		 js	 SHORT $LN25@asciilib_s@4
  00123	a8 02		 test	 al, 2
  00125	75 4c		 jne	 SHORT $LN31@asciilib_s@4
  00127	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0012b	75 46		 jne	 SHORT $LN31@asciilib_s@4
  0012d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0013b	4c 8b cf	 mov	 r9, rdi
  0013e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00144	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0014c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00151	48 8b cf	 mov	 rcx, rdi
  00154	85 c0		 test	 eax, eax
  00156	74 07		 je	 SHORT $LN30@asciilib_s@4
  00158	e8 00 00 00 00	 call	 _Px_Dealloc
  0015d	eb 14		 jmp	 SHORT $LN31@asciilib_s@4
$LN30@asciilib_s@4:
  0015f	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00163	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00169	eb 08		 jmp	 SHORT $LN31@asciilib_s@4
$LN25@asciilib_s@4:
  0016b	48 8b cf	 mov	 rcx, rdi
  0016e	e8 00 00 00 00	 call	 Px_DecRef
$LN31@asciilib_s@4:

; 382  :         j = i;

  00173	48 8b fb	 mov	 rdi, rbx
  00176	48 3b de	 cmp	 rbx, rsi
  00179	0f 8c d9 fe ff
	ff		 jl	 $LN48@asciilib_s@4
$LN12@asciilib_s@4:

; 383  :     }
; 384  :     return list;

  0017f	49 8b c4	 mov	 rax, r12
$LN45@asciilib_s@4:
  00182	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00187	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0018c	4c 8b 7c 24 70	 mov	 r15, QWORD PTR [rsp+112]

; 389  : }

  00191	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00195	41 5e		 pop	 r14
  00197	41 5d		 pop	 r13
  00199	41 5c		 pop	 r12
  0019b	5e		 pop	 rsi
  0019c	5d		 pop	 rbp
  0019d	c3		 ret	 0
$LN34@asciilib_s@4:

; 375  :             /* No linebreak in str_obj, so just use it as list[0] */
; 376  :             if (PyList_Append(list, str_obj))

  0019e	49 8b d5	 mov	 rdx, r13
  001a1	49 8b cc	 mov	 rcx, r12
  001a4	e8 00 00 00 00	 call	 PyList_Append
  001a9	85 c0		 test	 eax, eax
  001ab	75 0a		 jne	 SHORT $onError$121299

; 377  :                 goto onError;
; 378  :             break;

  001ad	eb d0		 jmp	 SHORT $LN12@asciilib_s@4
$LN36@asciilib_s@4:

; 379  :         }
; 380  : #endif
; 381  :         SPLIT_APPEND(str, j, eol);

  001af	48 8b cf	 mov	 rcx, rdi
  001b2	e8 00 00 00 00	 call	 _Py_DecRef
$onError$121299:

; 385  : 
; 386  :   onError:
; 387  :     Py_DECREF(list);

  001b7	49 8b cc	 mov	 rcx, r12
  001ba	e8 00 00 00 00	 call	 _Py_DecRef

; 388  :     return NULL;

  001bf	33 c0		 xor	 eax, eax
  001c1	eb bf		 jmp	 SHORT $LN45@asciilib_s@4
asciilib_splitlines ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs1lib_partition DD imagerel ucs1lib_partition
	DD	imagerel ucs1lib_partition+81
	DD	imagerel $unwind$ucs1lib_partition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ucs1lib_partition DD imagerel ucs1lib_partition+81
	DD	imagerel ucs1lib_partition+116
	DD	imagerel $chain$0$ucs1lib_partition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$ucs1lib_partition DD imagerel ucs1lib_partition+116
	DD	imagerel ucs1lib_partition+361
	DD	imagerel $chain$5$ucs1lib_partition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$ucs1lib_partition DD imagerel ucs1lib_partition+361
	DD	imagerel ucs1lib_partition+736
	DD	imagerel $chain$7$ucs1lib_partition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$ucs1lib_partition DD 080021H
	DD	08f400H
	DD	096400H
	DD	0a5400H
	DD	0113400H
	DD	imagerel ucs1lib_partition
	DD	imagerel ucs1lib_partition+81
	DD	imagerel $unwind$ucs1lib_partition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$ucs1lib_partition DD 081221H
	DD	096412H
	DD	0a540dH
	DD	0113408H
	DD	08f400H
	DD	imagerel ucs1lib_partition
	DD	imagerel ucs1lib_partition+81
	DD	imagerel $unwind$ucs1lib_partition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ucs1lib_partition DD 020521H
	DD	08f405H
	DD	imagerel ucs1lib_partition
	DD	imagerel ucs1lib_partition+81
	DD	imagerel $unwind$ucs1lib_partition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_partition DD 051501H
	DD	0e011a215H
	DD	0c00dd00fH
	DD	0700bH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\partition.h
xdata	ENDS
;	COMDAT ucs1lib_partition
_TEXT	SEGMENT
mask$1$ = 32
skip$1$ = 40
mlast$1$ = 48
w$1$ = 56
str_obj$ = 128
str$ = 136
str_len$ = 144
sep_obj$ = 152
sep$ = 160
sep_len$ = 168
ucs1lib_partition PROC					; COMDAT

; 12   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 13   :     PyObject* out;
; 14   :     Py_ssize_t pos;
; 15   : 
; 16   :     if (sep_len == 0) {

  00015	4c 8b ac 24 a8
	00 00 00	 mov	 r13, QWORD PTR sep_len$[rsp]
  0001d	49 8b f9	 mov	 rdi, r9
  00020	4d 8b f0	 mov	 r14, r8
  00023	4c 8b e2	 mov	 r12, rdx
  00026	4d 85 ed	 test	 r13, r13
  00029	75 21		 jne	 SHORT $LN4@ucs1lib_pa

; 17   :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00039	e8 00 00 00 00	 call	 PyErr_SetString

; 18   :         return NULL;

  0003e	33 c0		 xor	 eax, eax

; 52   :     }
; 53   : 
; 54   :     return out;
; 55   : }

  00040	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00044	41 5e		 pop	 r14
  00046	41 5d		 pop	 r13
  00048	41 5c		 pop	 r12
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
$LN4@ucs1lib_pa:

; 19   :     }
; 20   : 
; 21   :     out = PyTuple_New(3);

  0004c	b9 03 00 00 00	 mov	 ecx, 3
  00051	4c 89 7c 24 40	 mov	 QWORD PTR [rsp+64], r15
  00056	e8 00 00 00 00	 call	 PyTuple_New
  0005b	4c 8b f8	 mov	 r15, rax

; 22   :     if (!out)

  0005e	48 85 c0	 test	 rax, rax
  00061	75 11		 jne	 SHORT $LN3@ucs1lib_pa
  00063	4c 8b 7c 24 40	 mov	 r15, QWORD PTR [rsp+64]

; 52   :     }
; 53   : 
; 54   :     return out;
; 55   : }

  00068	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0006c	41 5e		 pop	 r14
  0006e	41 5d		 pop	 r13
  00070	41 5c		 pop	 r12
  00072	5f		 pop	 rdi
  00073	c3		 ret	 0
$LN3@ucs1lib_pa:
  00074	48 89 9c 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbx
  0007c	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00081	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi

; 23   :         return NULL;
; 24   : 
; 25   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_SEARCH);

  00086	49 8b f6	 mov	 rsi, r14
  00089	49 2b f5	 sub	 rsi, r13
  0008c	48 89 74 24 38	 mov	 QWORD PTR w$1$[rsp], rsi
  00091	78 72		 js	 SHORT $LN90@ucs1lib_pa
  00093	49 83 fd 01	 cmp	 r13, 1
  00097	0f 8f cc 00 00
	00		 jg	 $LN65@ucs1lib_pa
  0009d	4d 85 ed	 test	 r13, r13
  000a0	7e 63		 jle	 SHORT $LN90@ucs1lib_pa
  000a2	49 83 fe 0a	 cmp	 r14, 10
  000a6	7e 39		 jle	 SHORT $LN63@ucs1lib_pa
  000a8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  000b0	4f 8d 04 34	 lea	 r8, QWORD PTR [r12+r14]
  000b4	4d 3b e0	 cmp	 r12, r8
  000b7	73 17		 jae	 SHORT $LN73@ucs1lib_pa
  000b9	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  000bc	4d 2b c4	 sub	 r8, r12
  000bf	49 8b cc	 mov	 rcx, r12
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000c8	48 8b d8	 mov	 rbx, rax
  000cb	48 85 c0	 test	 rax, rax
  000ce	75 09		 jne	 SHORT $LN72@ucs1lib_pa
$LN73@ucs1lib_pa:
  000d0	48 83 cb ff	 or	 rbx, -1
  000d4	e9 ad 01 00 00	 jmp	 $LN68@ucs1lib_pa
$LN72@ucs1lib_pa:
  000d9	49 2b dc	 sub	 rbx, r12
  000dc	e9 a5 01 00 00	 jmp	 $LN68@ucs1lib_pa
$LN63@ucs1lib_pa:
  000e1	33 db		 xor	 ebx, ebx
  000e3	4d 85 f6	 test	 r14, r14
  000e6	7e 1d		 jle	 SHORT $LN90@ucs1lib_pa
  000e8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  000f0	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
$LL54@ucs1lib_pa:
  000f3	42 38 0c 23	 cmp	 BYTE PTR [rbx+r12], cl
  000f7	0f 84 89 01 00
	00		 je	 $LN68@ucs1lib_pa
  000fd	48 ff c3	 inc	 rbx
  00100	49 3b de	 cmp	 rbx, r14
  00103	7c ee		 jl	 SHORT $LL54@ucs1lib_pa
$LN90@ucs1lib_pa:

; 28   : #if STRINGLIB_MUTABLE
; 29   :         PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, str_len));
; 30   :         PyTuple_SET_ITEM(out, 1, STRINGLIB_NEW(NULL, 0));
; 31   :         PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(NULL, 0));
; 32   : #else
; 33   :         Py_INCREF(str_obj);

  00105	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR str_obj$[rsp]
  0010d	48 8b cb	 mov	 rcx, rbx
  00110	e8 00 00 00 00	 call	 _Py_IncRef

; 34   :         PyTuple_SET_ITEM(out, 0, (PyObject*) str_obj);
; 35   :         Py_INCREF(STRINGLIB_EMPTY);

  00115	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  0011c	49 89 5f 70	 mov	 QWORD PTR [r15+112], rbx
  00120	e8 00 00 00 00	 call	 _Py_IncRef

; 36   :         PyTuple_SET_ITEM(out, 1, (PyObject*) STRINGLIB_EMPTY);

  00125	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  0012c	49 89 4f 78	 mov	 QWORD PTR [r15+120], rcx

; 37   :         Py_INCREF(STRINGLIB_EMPTY);

  00130	e8 00 00 00 00	 call	 _Py_IncRef

; 38   :         PyTuple_SET_ITEM(out, 2, (PyObject*) STRINGLIB_EMPTY);

  00135	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR unicode_empty
  0013c	4d 89 9f 80 00
	00 00		 mov	 QWORD PTR [r15+128], r11
$LN1@ucs1lib_pa:

; 39   : #endif
; 40   :         return out;

  00143	49 8b c7	 mov	 rax, r15
$LN95@ucs1lib_pa:
  00146	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0014b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00150	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR [rsp+136]
  00158	4c 8b 7c 24 40	 mov	 r15, QWORD PTR [rsp+64]

; 52   :     }
; 53   : 
; 54   :     return out;
; 55   : }

  0015d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00161	41 5e		 pop	 r14
  00163	41 5d		 pop	 r13
  00165	41 5c		 pop	 r12
  00167	5f		 pop	 rdi
  00168	c3		 ret	 0

; 23   :         return NULL;
; 24   : 
; 25   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_SEARCH);

$LN65@ucs1lib_pa:
  00169	4d 8d 4d ff	 lea	 r9, QWORD PTR [r13-1]
  0016d	33 db		 xor	 ebx, ebx
  0016f	49 8d 41 ff	 lea	 rax, QWORD PTR [r9-1]
  00173	4c 89 4c 24 30	 mov	 QWORD PTR mlast$1$[rsp], r9
  00178	8b fb		 mov	 edi, ebx
  0017a	44 8d 53 01	 lea	 r10d, QWORD PTR [rbx+1]
  0017e	48 89 44 24 28	 mov	 QWORD PTR skip$1$[rsp], rax
  00183	4d 85 c9	 test	 r9, r9
  00186	7e 5d		 jle	 SHORT $LN42@ucs1lib_pa
  00188	4c 8b 9c 24 a0
	00 00 00	 mov	 r11, QWORD PTR sep$[rsp]
  00190	49 8b f1	 mov	 rsi, r9
  00193	48 8b f8	 mov	 rdi, rax
  00196	43 0f b6 2c 19	 movzx	 ebp, BYTE PTR [r9+r11]
  0019b	4c 8b c8	 mov	 r9, rax
  0019e	44 8b eb	 mov	 r13d, ebx
$LL44@ucs1lib_pa:
  001a1	45 0f b6 03	 movzx	 r8d, BYTE PTR [r11]
  001a5	41 8b d2	 mov	 edx, r10d
  001a8	41 8b c8	 mov	 ecx, r8d
  001ab	83 e1 1f	 and	 ecx, 31
  001ae	d3 e2		 shl	 edx, cl
  001b0	44 0b ea	 or	 r13d, edx
  001b3	44 3a c5	 cmp	 r8b, bpl
  001b6	4c 0f 44 cf	 cmove	 r9, rdi
  001ba	49 ff c3	 inc	 r11
  001bd	48 ff cf	 dec	 rdi
  001c0	48 ff ce	 dec	 rsi
  001c3	75 dc		 jne	 SHORT $LL44@ucs1lib_pa
  001c5	48 8b 74 24 38	 mov	 rsi, QWORD PTR w$1$[rsp]
  001ca	44 89 6c 24 20	 mov	 DWORD PTR mask$1$[rsp], r13d
  001cf	4c 8b ac 24 a8
	00 00 00	 mov	 r13, QWORD PTR sep_len$[rsp]
  001d7	8b 7c 24 20	 mov	 edi, DWORD PTR mask$1$[rsp]
  001db	4c 89 4c 24 28	 mov	 QWORD PTR skip$1$[rsp], r9
  001e0	4c 8b 4c 24 30	 mov	 r9, QWORD PTR mlast$1$[rsp]
$LN42@ucs1lib_pa:
  001e5	48 8b ac 24 a0
	00 00 00	 mov	 rbp, QWORD PTR sep$[rsp]
  001ed	48 8b d3	 mov	 rdx, rbx
  001f0	41 0f b6 04 29	 movzx	 eax, BYTE PTR [r9+rbp]
  001f5	83 e0 1f	 and	 eax, 31
  001f8	0f b6 c8	 movzx	 ecx, al
  001fb	41 d3 e2	 shl	 r10d, cl
  001fe	41 0b fa	 or	 edi, r10d
  00201	48 85 f6	 test	 rsi, rsi
  00204	0f 88 fb fe ff
	ff		 js	 $LN90@ucs1lib_pa
  0020a	4f 8d 1c 2c	 lea	 r11, QWORD PTR [r12+r13]
$LN97@ucs1lib_pa:
  0020e	41 0f b6 44 2d
	ff		 movzx	 eax, BYTE PTR [r13+rbp-1]
  00214	41 38 44 13 ff	 cmp	 BYTE PTR [r11+rdx-1], al
  00219	75 42		 jne	 SHORT $LN37@ucs1lib_pa
  0021b	4c 8b c3	 mov	 r8, rbx
  0021e	4d 85 c9	 test	 r9, r9
  00221	7e 21		 jle	 SHORT $LN91@ucs1lib_pa
  00223	4c 8b d2	 mov	 r10, rdx
  00226	48 8b cd	 mov	 rcx, rbp
  00229	4c 2b d5	 sub	 r10, rbp
  0022c	4d 03 d4	 add	 r10, r12
  0022f	90		 npad	 1
$LL36@ucs1lib_pa:
  00230	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00233	41 38 04 0a	 cmp	 BYTE PTR [r10+rcx], al
  00237	75 0b		 jne	 SHORT $LN91@ucs1lib_pa
  00239	49 ff c0	 inc	 r8
  0023c	48 ff c1	 inc	 rcx
  0023f	4d 3b c1	 cmp	 r8, r9
  00242	7c ec		 jl	 SHORT $LL36@ucs1lib_pa
$LN91@ucs1lib_pa:
  00244	4d 3b c1	 cmp	 r8, r9
  00247	74 32		 je	 SHORT $LN84@ucs1lib_pa
  00249	41 0f b6 04 13	 movzx	 eax, BYTE PTR [r11+rdx]
  0024e	83 e0 1f	 and	 eax, 31
  00251	0f a3 c7	 bt	 edi, eax
  00254	73 14		 jae	 SHORT $LN96@ucs1lib_pa
  00256	48 03 54 24 28	 add	 rdx, QWORD PTR skip$1$[rsp]
  0025b	eb 10		 jmp	 SHORT $LN39@ucs1lib_pa
$LN37@ucs1lib_pa:
  0025d	41 0f b6 04 13	 movzx	 eax, BYTE PTR [r11+rdx]
  00262	83 e0 1f	 and	 eax, 31
  00265	0f a3 c7	 bt	 edi, eax
  00268	72 03		 jb	 SHORT $LN39@ucs1lib_pa
$LN96@ucs1lib_pa:
  0026a	49 03 d5	 add	 rdx, r13
$LN39@ucs1lib_pa:
  0026d	48 ff c2	 inc	 rdx
  00270	48 3b d6	 cmp	 rdx, rsi
  00273	0f 8f 8c fe ff
	ff		 jg	 $LN90@ucs1lib_pa
  00279	eb 93		 jmp	 SHORT $LN97@ucs1lib_pa
$LN84@ucs1lib_pa:
  0027b	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR sep_obj$[rsp]
  00283	48 8b da	 mov	 rbx, rdx
$LN68@ucs1lib_pa:

; 26   : 
; 27   :     if (pos < 0) {

  00286	48 85 db	 test	 rbx, rbx
  00289	0f 88 76 fe ff
	ff		 js	 $LN90@ucs1lib_pa

; 41   :     }
; 42   : 
; 43   :     PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, pos));

  0028f	48 8b d3	 mov	 rdx, rbx
  00292	49 8b cc	 mov	 rcx, r12
  00295	e8 00 00 00 00	 call	 _PyUnicode_FromUCS1

; 44   :     Py_INCREF(sep_obj);

  0029a	48 8b cf	 mov	 rcx, rdi
  0029d	49 89 47 70	 mov	 QWORD PTR [r15+112], rax
  002a1	e8 00 00 00 00	 call	 _Py_IncRef

; 45   :     PyTuple_SET_ITEM(out, 1, sep_obj);
; 46   :     pos += sep_len;

  002a6	49 03 dd	 add	 rbx, r13

; 47   :     PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str + pos, str_len - pos));

  002a9	4c 2b f3	 sub	 r14, rbx
  002ac	4a 8d 0c 23	 lea	 rcx, QWORD PTR [rbx+r12]
  002b0	49 89 7f 78	 mov	 QWORD PTR [r15+120], rdi
  002b4	49 8b d6	 mov	 rdx, r14
  002b7	e8 00 00 00 00	 call	 _PyUnicode_FromUCS1
  002bc	49 89 87 80 00
	00 00		 mov	 QWORD PTR [r15+128], rax

; 48   : 
; 49   :     if (PyErr_Occurred()) {

  002c3	e8 00 00 00 00	 call	 PyErr_Occurred
  002c8	48 85 c0	 test	 rax, rax
  002cb	0f 84 72 fe ff
	ff		 je	 $LN1@ucs1lib_pa

; 50   :         Py_DECREF(out);

  002d1	49 8b cf	 mov	 rcx, r15
  002d4	e8 00 00 00 00	 call	 _Py_DecRef

; 51   :         return NULL;

  002d9	33 c0		 xor	 eax, eax
  002db	e9 66 fe ff ff	 jmp	 $LN95@ucs1lib_pa
ucs1lib_partition ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs1lib_rpartition DD imagerel ucs1lib_rpartition
	DD	imagerel ucs1lib_rpartition+82
	DD	imagerel $unwind$ucs1lib_rpartition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ucs1lib_rpartition DD imagerel ucs1lib_rpartition+82
	DD	imagerel ucs1lib_rpartition+115
	DD	imagerel $chain$0$ucs1lib_rpartition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$ucs1lib_rpartition DD imagerel ucs1lib_rpartition+115
	DD	imagerel ucs1lib_rpartition+289
	DD	imagerel $chain$5$ucs1lib_rpartition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$ucs1lib_rpartition DD imagerel ucs1lib_rpartition+289
	DD	imagerel ucs1lib_rpartition+626
	DD	imagerel $chain$7$ucs1lib_rpartition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$ucs1lib_rpartition DD 080021H
	DD	04f400H
	DD	05e400H
	DD	06c400H
	DD	0d3400H
	DD	imagerel ucs1lib_rpartition
	DD	imagerel ucs1lib_rpartition+82
	DD	imagerel $unwind$ucs1lib_rpartition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$ucs1lib_rpartition DD 081521H
	DD	04f415H
	DD	05e40dH
	DD	0d3405H
	DD	06c400H
	DD	imagerel ucs1lib_rpartition
	DD	imagerel ucs1lib_rpartition+82
	DD	imagerel $unwind$ucs1lib_rpartition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ucs1lib_rpartition DD 020521H
	DD	06c405H
	DD	imagerel ucs1lib_rpartition
	DD	imagerel ucs1lib_rpartition+82
	DD	imagerel $unwind$ucs1lib_rpartition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_rpartition DD 051801H
	DD	0d0146218H
	DD	060117012H
	DD	05010H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\partition.h
xdata	ENDS
;	COMDAT ucs1lib_rpartition
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
sep_obj$ = 120
sep$ = 128
sep_len$ = 136
ucs1lib_rpartition PROC					; COMDAT

; 62   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 55		 push	 r13
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 63   :     PyObject* out;
; 64   :     Py_ssize_t pos;
; 65   : 
; 66   :     if (sep_len == 0) {

  00018	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR sep_len$[rsp]
  00020	4d 8b e9	 mov	 r13, r9
  00023	49 8b e8	 mov	 rbp, r8
  00026	48 8b f2	 mov	 rsi, rdx
  00029	48 85 ff	 test	 rdi, rdi
  0002c	75 1f		 jne	 SHORT $LN4@ucs1lib_rp

; 67   :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0002e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  0003c	e8 00 00 00 00	 call	 PyErr_SetString

; 68   :         return NULL;

  00041	33 c0		 xor	 eax, eax

; 102  :     }
; 103  : 
; 104  :     return out;
; 105  : }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	41 5d		 pop	 r13
  00049	5f		 pop	 rdi
  0004a	5e		 pop	 rsi
  0004b	5d		 pop	 rbp
  0004c	c3		 ret	 0
$LN4@ucs1lib_rp:

; 69   :     }
; 70   : 
; 71   :     out = PyTuple_New(3);

  0004d	b9 03 00 00 00	 mov	 ecx, 3
  00052	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  00057	e8 00 00 00 00	 call	 PyTuple_New
  0005c	4c 8b e0	 mov	 r12, rax

; 72   :     if (!out)

  0005f	48 85 c0	 test	 rax, rax
  00062	75 0f		 jne	 SHORT $LN3@ucs1lib_rp
  00064	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]

; 102  :     }
; 103  : 
; 104  :     return out;
; 105  : }

  00069	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006d	41 5d		 pop	 r13
  0006f	5f		 pop	 rdi
  00070	5e		 pop	 rsi
  00071	5d		 pop	 rbp
  00072	c3		 ret	 0
$LN3@ucs1lib_rp:
  00073	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx

; 73   :         return NULL;
; 74   : 
; 75   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_RSEARCH);

  00078	48 8b dd	 mov	 rbx, rbp
  0007b	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00080	48 2b df	 sub	 rbx, rdi
  00083	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00088	78 38		 js	 SHORT $LN90@ucs1lib_rp
  0008a	48 83 ff 01	 cmp	 rdi, 1
  0008e	0f 8f 8d 00 00
	00		 jg	 $LN65@ucs1lib_rp
  00094	48 85 ff	 test	 rdi, rdi
  00097	7e 29		 jle	 SHORT $LN90@ucs1lib_rp
  00099	48 8d 5d ff	 lea	 rbx, QWORD PTR [rbp-1]
  0009d	48 83 fb ff	 cmp	 rbx, -1
  000a1	7e 1f		 jle	 SHORT $LN90@ucs1lib_rp
  000a3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  000ab	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000ae	66 90		 npad	 2
$LL49@ucs1lib_rp:
  000b0	38 0c 33	 cmp	 BYTE PTR [rbx+rsi], cl
  000b3	0f 84 5b 01 00
	00		 je	 $LN68@ucs1lib_rp
  000b9	48 ff cb	 dec	 rbx
  000bc	48 83 fb ff	 cmp	 rbx, -1
  000c0	7f ee		 jg	 SHORT $LL49@ucs1lib_rp
$LN90@ucs1lib_rp:

; 78   : #if STRINGLIB_MUTABLE
; 79   :         PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(NULL, 0));
; 80   :         PyTuple_SET_ITEM(out, 1, STRINGLIB_NEW(NULL, 0));
; 81   :         PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str, str_len));
; 82   : #else
; 83   :         Py_INCREF(STRINGLIB_EMPTY);

  000c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  000c9	e8 00 00 00 00	 call	 _Py_IncRef

; 84   :         PyTuple_SET_ITEM(out, 0, (PyObject*) STRINGLIB_EMPTY);

  000ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  000d5	49 89 4c 24 70	 mov	 QWORD PTR [r12+112], rcx

; 85   :         Py_INCREF(STRINGLIB_EMPTY);

  000da	e8 00 00 00 00	 call	 _Py_IncRef

; 86   :         PyTuple_SET_ITEM(out, 1, (PyObject*) STRINGLIB_EMPTY);

  000df	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR unicode_empty

; 87   :         Py_INCREF(str_obj);

  000e6	48 8b 5c 24 60	 mov	 rbx, QWORD PTR str_obj$[rsp]
  000eb	4d 89 5c 24 78	 mov	 QWORD PTR [r12+120], r11
  000f0	48 8b cb	 mov	 rcx, rbx
  000f3	e8 00 00 00 00	 call	 _Py_IncRef

; 88   :         PyTuple_SET_ITEM(out, 2, (PyObject*) str_obj);

  000f8	49 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [r12+128], rbx
$LN1@ucs1lib_rp:

; 89   : #endif
; 90   :         return out;

  00100	49 8b c4	 mov	 rax, r12
$LN96@ucs1lib_rp:
  00103	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]
  00108	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  0010d	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  00112	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]

; 102  :     }
; 103  : 
; 104  :     return out;
; 105  : }

  00117	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011b	41 5d		 pop	 r13
  0011d	5f		 pop	 rdi
  0011e	5e		 pop	 rsi
  0011f	5d		 pop	 rbp
  00120	c3		 ret	 0

; 73   :         return NULL;
; 74   : 
; 75   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_RSEARCH);

$LN65@ucs1lib_rp:
  00121	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR sep$[rsp]
  00129	48 8d 6f ff	 lea	 rbp, QWORD PTR [rdi-1]
  0012d	41 be 01 00 00
	00		 mov	 r14d, 1
  00133	45 0f b6 3a	 movzx	 r15d, BYTE PTR [r10]
  00137	4c 8d 6d ff	 lea	 r13, QWORD PTR [rbp-1]
  0013b	41 8b cf	 mov	 ecx, r15d
  0013e	83 e1 1f	 and	 ecx, 31
  00141	41 d3 e6	 shl	 r14d, cl
  00144	48 85 ed	 test	 rbp, rbp
  00147	7e 44		 jle	 SHORT $LN22@ucs1lib_rp
  00149	49 83 cb ff	 or	 r11, -1
  0014d	4d 8d 0c 2a	 lea	 r9, QWORD PTR [r10+rbp]
  00151	4d 2b da	 sub	 r11, r10
  00154	4c 8b d5	 mov	 r10, rbp
  00157	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL24@ucs1lib_rp:
  00160	45 0f b6 01	 movzx	 r8d, BYTE PTR [r9]
  00164	ba 01 00 00 00	 mov	 edx, 1
  00169	41 8b c8	 mov	 ecx, r8d
  0016c	83 e1 1f	 and	 ecx, 31
  0016f	d3 e2		 shl	 edx, cl
  00171	44 0b f2	 or	 r14d, edx
  00174	45 3a c7	 cmp	 r8b, r15b
  00177	75 04		 jne	 SHORT $LN23@ucs1lib_rp
  00179	4f 8d 2c 0b	 lea	 r13, QWORD PTR [r11+r9]
$LN23@ucs1lib_rp:
  0017d	49 ff c9	 dec	 r9
  00180	49 ff ca	 dec	 r10
  00183	75 db		 jne	 SHORT $LL24@ucs1lib_rp
  00185	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR sep$[rsp]
$LN22@ucs1lib_rp:
  0018d	4c 8b c3	 mov	 r8, rbx
  00190	4d 2b c2	 sub	 r8, r10
  00193	4c 03 c6	 add	 r8, rsi
$LL20@ucs1lib_rp:
  00196	44 38 3c 33	 cmp	 BYTE PTR [rbx+rsi], r15b
  0019a	75 48		 jne	 SHORT $LN17@ucs1lib_rp
  0019c	48 8b d5	 mov	 rdx, rbp
  0019f	48 85 ed	 test	 rbp, rbp
  001a2	7e 20		 jle	 SHORT $LN91@ucs1lib_rp
  001a4	49 8d 0c 2a	 lea	 rcx, QWORD PTR [r10+rbp]
  001a8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL16@ucs1lib_rp:
  001b0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  001b3	41 38 04 08	 cmp	 BYTE PTR [r8+rcx], al
  001b7	75 0b		 jne	 SHORT $LN91@ucs1lib_rp
  001b9	48 ff ca	 dec	 rdx
  001bc	48 ff c9	 dec	 rcx
  001bf	48 85 d2	 test	 rdx, rdx
  001c2	7f ec		 jg	 SHORT $LL16@ucs1lib_rp
$LN91@ucs1lib_rp:
  001c4	48 85 d2	 test	 rdx, rdx
  001c7	74 41		 je	 SHORT $LN92@ucs1lib_rp
  001c9	48 85 db	 test	 rbx, rbx
  001cc	7e 0e		 jle	 SHORT $LN11@ucs1lib_rp
  001ce	0f b6 44 33 ff	 movzx	 eax, BYTE PTR [rbx+rsi-1]
  001d3	83 e0 1f	 and	 eax, 31
  001d6	41 0f a3 c6	 bt	 r14d, eax
  001da	73 1b		 jae	 SHORT $LN97@ucs1lib_rp
$LN11@ucs1lib_rp:
  001dc	49 2b dd	 sub	 rbx, r13
  001df	4d 2b c5	 sub	 r8, r13
  001e2	eb 19		 jmp	 SHORT $LN19@ucs1lib_rp
$LN17@ucs1lib_rp:
  001e4	48 85 db	 test	 rbx, rbx
  001e7	7e 14		 jle	 SHORT $LN19@ucs1lib_rp
  001e9	0f b6 44 33 ff	 movzx	 eax, BYTE PTR [rbx+rsi-1]
  001ee	83 e0 1f	 and	 eax, 31
  001f1	41 0f a3 c6	 bt	 r14d, eax
  001f5	72 06		 jb	 SHORT $LN19@ucs1lib_rp
$LN97@ucs1lib_rp:
  001f7	48 2b df	 sub	 rbx, rdi
  001fa	4c 2b c7	 sub	 r8, rdi
$LN19@ucs1lib_rp:
  001fd	49 ff c8	 dec	 r8
  00200	48 ff cb	 dec	 rbx
  00203	79 91		 jns	 SHORT $LL20@ucs1lib_rp
  00205	e9 b8 fe ff ff	 jmp	 $LN90@ucs1lib_rp
$LN92@ucs1lib_rp:

; 62   : {

  0020a	48 8b 6c 24 70	 mov	 rbp, QWORD PTR str_len$[rsp]
  0020f	4c 8b 6c 24 78	 mov	 r13, QWORD PTR sep_obj$[rsp]

; 73   :         return NULL;
; 74   : 
; 75   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_RSEARCH);

$LN68@ucs1lib_rp:

; 76   : 
; 77   :     if (pos < 0) {

  00214	48 85 db	 test	 rbx, rbx
  00217	0f 88 a5 fe ff
	ff		 js	 $LN90@ucs1lib_rp

; 91   :     }
; 92   : 
; 93   :     PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, pos));

  0021d	48 8b d3	 mov	 rdx, rbx
  00220	48 8b ce	 mov	 rcx, rsi
  00223	e8 00 00 00 00	 call	 _PyUnicode_FromUCS1

; 94   :     Py_INCREF(sep_obj);

  00228	49 8b cd	 mov	 rcx, r13
  0022b	49 89 44 24 70	 mov	 QWORD PTR [r12+112], rax
  00230	e8 00 00 00 00	 call	 _Py_IncRef

; 95   :     PyTuple_SET_ITEM(out, 1, sep_obj);
; 96   :     pos += sep_len;

  00235	48 8d 04 3b	 lea	 rax, QWORD PTR [rbx+rdi]

; 97   :     PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str + pos, str_len - pos));

  00239	48 2b e8	 sub	 rbp, rax
  0023c	48 8d 0c 30	 lea	 rcx, QWORD PTR [rax+rsi]
  00240	4d 89 6c 24 78	 mov	 QWORD PTR [r12+120], r13
  00245	48 8b d5	 mov	 rdx, rbp
  00248	e8 00 00 00 00	 call	 _PyUnicode_FromUCS1
  0024d	49 89 84 24 80
	00 00 00	 mov	 QWORD PTR [r12+128], rax

; 98   : 
; 99   :     if (PyErr_Occurred()) {

  00255	e8 00 00 00 00	 call	 PyErr_Occurred
  0025a	48 85 c0	 test	 rax, rax
  0025d	0f 84 9d fe ff
	ff		 je	 $LN1@ucs1lib_rp

; 100  :         Py_DECREF(out);

  00263	49 8b cc	 mov	 rcx, r12
  00266	e8 00 00 00 00	 call	 _Py_DecRef

; 101  :         return NULL;

  0026b	33 c0		 xor	 eax, eax
  0026d	e9 91 fe ff ff	 jmp	 $LN96@ucs1lib_rp
ucs1lib_rpartition ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ucs1lib_split_whitespace DD imagerel ucs1lib_split_whitespace
	DD	imagerel ucs1lib_split_whitespace+639
	DD	imagerel $unwind$ucs1lib_split_whitespace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_split_whitespace DD 0c6101H
	DD	0d7461H
	DD	0c3455H
	DD	0e5412H
	DD	0f00e5212H
	DD	0d00ae00cH
	DD	06006c008H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs1lib_split_whitespace
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
maxcount$ = 120
ucs1lib_split_whitespace PROC				; COMDAT

; 57   : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	41 56		 push	 r14
  0000c	41 57		 push	 r15
  0000e	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 58   :     Py_ssize_t i, j, count=0;

  00012	45 33 e4	 xor	 r12d, r12d
  00015	4c 8b f9	 mov	 r15, rcx
  00018	4d 8b e9	 mov	 r13, r9
  0001b	49 8b f0	 mov	 rsi, r8
  0001e	48 8b ea	 mov	 rbp, rdx

; 59   :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00021	41 8d 4c 24 0c	 lea	 ecx, QWORD PTR [r12+12]
  00026	49 83 f9 0c	 cmp	 r9, 12
  0002a	7d 04		 jge	 SHORT $LN27@ucs1lib_sp
  0002c	49 8d 49 01	 lea	 rcx, QWORD PTR [r9+1]
$LN27@ucs1lib_sp:
  00030	e8 00 00 00 00	 call	 PyList_New
  00035	4c 8b f0	 mov	 r14, rax

; 60   :     PyObject *sub;
; 61   : 
; 62   :     if (list == NULL)

  00038	48 85 c0	 test	 rax, rax
  0003b	75 13		 jne	 SHORT $LN23@ucs1lib_sp

; 99   : }

  0003d	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00042	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00046	41 5f		 pop	 r15
  00048	41 5e		 pop	 r14
  0004a	41 5d		 pop	 r13
  0004c	41 5c		 pop	 r12
  0004e	5e		 pop	 rsi
  0004f	c3		 ret	 0
$LN23@ucs1lib_sp:
  00050	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx

; 63   :         return NULL;
; 64   : 
; 65   :     i = j = 0;
; 66   :     while (maxcount-- > 0) {

  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
  0005c	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  00061	49 8b dc	 mov	 rbx, r12
  00064	4d 85 ed	 test	 r13, r13
  00067	0f 8e 5b 01 00
	00		 jle	 $LN55@ucs1lib_sp
  0006d	0f 1f 00	 npad	 3
$LL22@ucs1lib_sp:
  00070	49 ff cd	 dec	 r13

; 67   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  00073	48 3b de	 cmp	 rbx, rsi
  00076	7d 2f		 jge	 SHORT $LN65@ucs1lib_sp
$LL20@ucs1lib_sp:
  00078	0f b6 04 2b	 movzx	 eax, BYTE PTR [rbx+rbp]
  0007c	3c 80		 cmp	 al, 128			; 00000080H
  0007e	73 09		 jae	 SHORT $LN28@ucs1lib_sp
  00080	0f b6 c0	 movzx	 eax, al
  00083	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00087	eb 0f		 jmp	 SHORT $LN29@ucs1lib_sp
$LN28@ucs1lib_sp:
  00089	0f b6 c8	 movzx	 ecx, al
  0008c	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
$LN29@ucs1lib_sp:
  00098	85 c0		 test	 eax, eax
  0009a	74 08		 je	 SHORT $LN61@ucs1lib_sp

; 68   :             i++;

  0009c	48 ff c3	 inc	 rbx
  0009f	48 3b de	 cmp	 rbx, rsi
  000a2	7c d4		 jl	 SHORT $LL20@ucs1lib_sp
$LN61@ucs1lib_sp:

; 69   :         if (i == str_len) break;

  000a4	48 3b de	 cmp	 rbx, rsi
$LN65@ucs1lib_sp:
  000a7	0f 84 1b 01 00
	00		 je	 $LN55@ucs1lib_sp

; 70   :         j = i; i++;

  000ad	48 8b fb	 mov	 rdi, rbx
  000b0	48 ff c3	 inc	 rbx

; 71   :         while (i < str_len && !STRINGLIB_ISSPACE(str[i]))

  000b3	48 3b de	 cmp	 rbx, rsi
  000b6	7d 2c		 jge	 SHORT $LN62@ucs1lib_sp
$LL17@ucs1lib_sp:
  000b8	0f b6 04 2b	 movzx	 eax, BYTE PTR [rbx+rbp]
  000bc	3c 80		 cmp	 al, 128			; 00000080H
  000be	73 09		 jae	 SHORT $LN30@ucs1lib_sp
  000c0	0f b6 c0	 movzx	 eax, al
  000c3	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000c7	eb 0f		 jmp	 SHORT $LN31@ucs1lib_sp
$LN30@ucs1lib_sp:
  000c9	0f b6 c8	 movzx	 ecx, al
  000cc	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
$LN31@ucs1lib_sp:
  000d8	85 c0		 test	 eax, eax
  000da	75 08		 jne	 SHORT $LN62@ucs1lib_sp

; 72   :             i++;

  000dc	48 ff c3	 inc	 rbx
  000df	48 3b de	 cmp	 rbx, rsi
  000e2	7c d4		 jl	 SHORT $LL17@ucs1lib_sp
$LN62@ucs1lib_sp:

; 73   : #ifndef STRINGLIB_MUTABLE
; 74   :         if (j == 0 && i == str_len && STRINGLIB_CHECK_EXACT(str_obj)) {

  000e4	48 85 ff	 test	 rdi, rdi
  000e7	75 16		 jne	 SHORT $LN15@ucs1lib_sp
  000e9	48 3b de	 cmp	 rbx, rsi
  000ec	75 11		 jne	 SHORT $LN15@ucs1lib_sp
  000ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  000f5	49 39 47 58	 cmp	 QWORD PTR [r15+88], rax
  000f9	0f 84 b7 00 00
	00		 je	 $LN50@ucs1lib_sp
$LN15@ucs1lib_sp:

; 79   :             break;
; 80   :         }
; 81   : #endif
; 82   :         SPLIT_ADD(str, j, i);

  000ff	48 8b d3	 mov	 rdx, rbx
  00102	48 8d 0c 2f	 lea	 rcx, QWORD PTR [rdi+rbp]
  00106	48 2b d7	 sub	 rdx, rdi
  00109	e8 00 00 00 00	 call	 _PyUnicode_FromUCS1
  0010e	48 8b f8	 mov	 rdi, rax
  00111	48 85 c0	 test	 rax, rax
  00114	0f 84 d7 00 00
	00		 je	 $onError$121871
  0011a	49 83 fc 0c	 cmp	 r12, 12
  0011e	7d 0a		 jge	 SHORT $LN13@ucs1lib_sp
  00120	49 8b 4e 70	 mov	 rcx, QWORD PTR [r14+112]
  00124	4a 89 04 e1	 mov	 QWORD PTR [rcx+r12*8], rax
  00128	eb 78		 jmp	 SHORT $LN44@ucs1lib_sp
$LN13@ucs1lib_sp:
  0012a	48 8b d0	 mov	 rdx, rax
  0012d	49 8b ce	 mov	 rcx, r14
  00130	e8 00 00 00 00	 call	 PyList_Append
  00135	85 c0		 test	 eax, eax
  00137	0f 85 ac 00 00
	00		 jne	 $LN52@ucs1lib_sp
  0013d	e8 00 00 00 00	 call	 _Py_PXCTX
  00142	85 c0		 test	 eax, eax
  00144	75 5c		 jne	 SHORT $LN44@ucs1lib_sp
  00146	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0014a	a8 20		 test	 al, 32			; 00000020H
  0014c	75 4c		 jne	 SHORT $LN38@ucs1lib_sp
  0014e	84 c0		 test	 al, al
  00150	78 48		 js	 SHORT $LN38@ucs1lib_sp
  00152	a8 02		 test	 al, 2
  00154	75 4c		 jne	 SHORT $LN44@ucs1lib_sp
  00156	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0015a	75 46		 jne	 SHORT $LN44@ucs1lib_sp
  0015c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00163	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0016a	4c 8b cf	 mov	 r9, rdi
  0016d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00173	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0017b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00180	48 8b cf	 mov	 rcx, rdi
  00183	85 c0		 test	 eax, eax
  00185	74 07		 je	 SHORT $LN43@ucs1lib_sp
  00187	e8 00 00 00 00	 call	 _Px_Dealloc
  0018c	eb 14		 jmp	 SHORT $LN44@ucs1lib_sp
$LN43@ucs1lib_sp:
  0018e	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00192	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00198	eb 08		 jmp	 SHORT $LN44@ucs1lib_sp
$LN38@ucs1lib_sp:
  0019a	48 8b cf	 mov	 rcx, rdi
  0019d	e8 00 00 00 00	 call	 Px_DecRef
$LN44@ucs1lib_sp:
  001a2	49 ff c4	 inc	 r12
  001a5	4d 85 ed	 test	 r13, r13
  001a8	7e 1e		 jle	 SHORT $LN55@ucs1lib_sp

; 63   :         return NULL;
; 64   : 
; 65   :     i = j = 0;
; 66   :     while (maxcount-- > 0) {

  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
  001b1	e9 ba fe ff ff	 jmp	 $LL22@ucs1lib_sp
$LN50@ucs1lib_sp:

; 75   :             /* No whitespace in str_obj, so just use it as list[0] */
; 76   :             Py_INCREF(str_obj);

  001b6	49 8b cf	 mov	 rcx, r15
  001b9	e8 00 00 00 00	 call	 _Py_IncRef

; 77   :             PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  001be	4d 8b 5e 70	 mov	 r11, QWORD PTR [r14+112]

; 78   :             count++;

  001c2	49 ff c4	 inc	 r12
  001c5	4d 89 3b	 mov	 QWORD PTR [r11], r15
$LN55@ucs1lib_sp:

; 83   :     }
; 84   : 
; 85   :     if (i < str_len) {

  001c8	48 3b de	 cmp	 rbx, rsi
  001cb	0f 8d 8a 00 00
	00		 jge	 $LN6@ucs1lib_sp
  001d1	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_ascii_whitespace
$LL8@ucs1lib_sp:

; 86   :         /* Only occurs when maxcount was reached */
; 87   :         /* Skip any remaining whitespace and copy to end of string */
; 88   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  001d8	0f b6 04 2b	 movzx	 eax, BYTE PTR [rbx+rbp]
  001dc	3c 80		 cmp	 al, 128			; 00000080H
  001de	73 1d		 jae	 SHORT $LN32@ucs1lib_sp
  001e0	0f b6 c0	 movzx	 eax, al
  001e3	0f b6 04 38	 movzx	 eax, BYTE PTR [rax+rdi]
  001e7	eb 1c		 jmp	 SHORT $LN33@ucs1lib_sp
$LN52@ucs1lib_sp:

; 79   :             break;
; 80   :         }
; 81   : #endif
; 82   :         SPLIT_ADD(str, j, i);

  001e9	48 8b cf	 mov	 rcx, rdi
$LN66@ucs1lib_sp:
  001ec	e8 00 00 00 00	 call	 _Py_DecRef
$onError$121871:

; 95   : 
; 96   :   onError:
; 97   :     Py_DECREF(list);

  001f1	49 8b ce	 mov	 rcx, r14
  001f4	e8 00 00 00 00	 call	 _Py_DecRef

; 98   :     return NULL;

  001f9	33 c0		 xor	 eax, eax
  001fb	eb 65		 jmp	 SHORT $LN64@ucs1lib_sp
$LN32@ucs1lib_sp:

; 86   :         /* Only occurs when maxcount was reached */
; 87   :         /* Skip any remaining whitespace and copy to end of string */
; 88   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  001fd	0f b6 c8	 movzx	 ecx, al
  00200	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
$LN33@ucs1lib_sp:
  00205	85 c0		 test	 eax, eax
  00207	74 08		 je	 SHORT $LN7@ucs1lib_sp

; 89   :             i++;

  00209	48 ff c3	 inc	 rbx
  0020c	48 3b de	 cmp	 rbx, rsi
  0020f	7c c7		 jl	 SHORT $LL8@ucs1lib_sp
$LN7@ucs1lib_sp:

; 90   :         if (i != str_len)

  00211	48 3b de	 cmp	 rbx, rsi
  00214	74 45		 je	 SHORT $LN6@ucs1lib_sp

; 91   :             SPLIT_ADD(str, i, str_len);

  00216	48 2b f3	 sub	 rsi, rbx
  00219	48 8d 0c 2b	 lea	 rcx, QWORD PTR [rbx+rbp]
  0021d	48 8b d6	 mov	 rdx, rsi
  00220	e8 00 00 00 00	 call	 _PyUnicode_FromUCS1
  00225	48 8b d8	 mov	 rbx, rax
  00228	48 85 c0	 test	 rax, rax
  0022b	74 c4		 je	 SHORT $onError$121871
  0022d	49 83 fc 0c	 cmp	 r12, 12
  00231	7d 0e		 jge	 SHORT $LN4@ucs1lib_sp
  00233	49 8b 4e 70	 mov	 rcx, QWORD PTR [r14+112]
  00237	49 ff c4	 inc	 r12
  0023a	4a 89 44 e1 f8	 mov	 QWORD PTR [rcx+r12*8-8], rax
  0023f	eb 1a		 jmp	 SHORT $LN6@ucs1lib_sp
$LN4@ucs1lib_sp:
  00241	48 8b d0	 mov	 rdx, rax
  00244	49 8b ce	 mov	 rcx, r14
  00247	e8 00 00 00 00	 call	 PyList_Append
  0024c	48 8b cb	 mov	 rcx, rbx
  0024f	85 c0		 test	 eax, eax
  00251	75 99		 jne	 SHORT $LN66@ucs1lib_sp
  00253	e8 00 00 00 00	 call	 _Py_DecRef
  00258	49 ff c4	 inc	 r12
$LN6@ucs1lib_sp:

; 92   :     }
; 93   :     FIX_PREALLOC_SIZE(list);

  0025b	4d 89 66 60	 mov	 QWORD PTR [r14+96], r12

; 94   :     return list;

  0025f	49 8b c6	 mov	 rax, r14
$LN64@ucs1lib_sp:

; 99   : }

  00262	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00267	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  0026c	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00271	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00275	41 5f		 pop	 r15
  00277	41 5e		 pop	 r14
  00279	41 5d		 pop	 r13
  0027b	41 5c		 pop	 r12
  0027d	5e		 pop	 rsi
  0027e	c3		 ret	 0
ucs1lib_split_whitespace ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ucs1lib_split_char DD imagerel ucs1lib_split_char
	DD	imagerel ucs1lib_split_char+81
	DD	imagerel $unwind$ucs1lib_split_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ucs1lib_split_char DD imagerel ucs1lib_split_char+81
	DD	imagerel ucs1lib_split_char+330
	DD	imagerel $chain$0$ucs1lib_split_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ucs1lib_split_char DD imagerel ucs1lib_split_char+330
	DD	imagerel ucs1lib_split_char+354
	DD	imagerel $chain$1$ucs1lib_split_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ucs1lib_split_char DD imagerel ucs1lib_split_char+354
	DD	imagerel ucs1lib_split_char+555
	DD	imagerel $chain$2$ucs1lib_split_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ucs1lib_split_char DD 020021H
	DD	0d3400H
	DD	imagerel ucs1lib_split_char
	DD	imagerel ucs1lib_split_char+81
	DD	imagerel $unwind$ucs1lib_split_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ucs1lib_split_char DD 021H
	DD	imagerel ucs1lib_split_char
	DD	imagerel ucs1lib_split_char+81
	DD	imagerel $unwind$ucs1lib_split_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ucs1lib_split_char DD 020521H
	DD	0d3405H
	DD	imagerel ucs1lib_split_char
	DD	imagerel ucs1lib_split_char+81
	DD	imagerel $unwind$ucs1lib_split_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_split_char DD 0a1c01H
	DD	0f641cH
	DD	0e541cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs1lib_split_char
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
ch$ = 120
maxcount$ = 128
ucs1lib_split_char PROC					; COMDAT

; 106  : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 107  :     Py_ssize_t i, j, count=0;
; 108  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  0001c	4c 8b bc 24 80
	00 00 00	 mov	 r15, QWORD PTR maxcount$[rsp]
  00024	33 f6		 xor	 esi, esi
  00026	4c 8b e1	 mov	 r12, rcx
  00029	45 0f b6 f1	 movzx	 r14d, r9b
  0002d	49 8b f8	 mov	 rdi, r8
  00030	4c 8b ea	 mov	 r13, rdx
  00033	8d 4e 0c	 lea	 ecx, QWORD PTR [rsi+12]
  00036	49 83 ff 0c	 cmp	 r15, 12
  0003a	7d 04		 jge	 SHORT $LN24@ucs1lib_sp@2
  0003c	49 8d 4f 01	 lea	 rcx, QWORD PTR [r15+1]
$LN24@ucs1lib_sp@2:
  00040	e8 00 00 00 00	 call	 PyList_New
  00045	48 8b e8	 mov	 rbp, rax

; 109  :     PyObject *sub;
; 110  : 
; 111  :     if (list == NULL)

  00048	48 85 c0	 test	 rax, rax
  0004b	0f 84 f9 00 00
	00		 je	 $LN21@ucs1lib_sp@2
$LN20@ucs1lib_sp@2:
  00051	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx

; 112  :         return NULL;
; 113  : 
; 114  :     i = j = 0;

  00056	48 8b ce	 mov	 rcx, rsi
  00059	48 8b de	 mov	 rbx, rsi

; 115  :     while ((j < str_len) && (maxcount-- > 0)) {

  0005c	48 85 ff	 test	 rdi, rdi
  0005f	0f 8e 81 00 00
	00		 jle	 $LN48@ucs1lib_sp@2
$LL19@ucs1lib_sp@2:
  00065	49 8b c7	 mov	 rax, r15
  00068	49 ff cf	 dec	 r15
  0006b	48 85 c0	 test	 rax, rax
  0006e	7e 68		 jle	 SHORT $LN18@ucs1lib_sp@2

; 116  :         for(; j < str_len; j++) {

  00070	48 3b df	 cmp	 rbx, rdi
  00073	7d 63		 jge	 SHORT $LN18@ucs1lib_sp@2
$LL17@ucs1lib_sp@2:

; 117  :             /* I found that using memchr makes no difference */
; 118  :             if (str[j] == ch) {

  00075	46 38 34 2b	 cmp	 BYTE PTR [rbx+r13], r14b
  00079	74 0a		 je	 SHORT $LN42@ucs1lib_sp@2

; 116  :         for(; j < str_len; j++) {

  0007b	48 ff c3	 inc	 rbx
  0007e	48 3b df	 cmp	 rbx, rdi
  00081	7c f2		 jl	 SHORT $LL17@ucs1lib_sp@2
  00083	eb 53		 jmp	 SHORT $LN18@ucs1lib_sp@2
$LN42@ucs1lib_sp@2:

; 119  :                 SPLIT_ADD(str, i, j);

  00085	48 8b d3	 mov	 rdx, rbx
  00088	48 2b d1	 sub	 rdx, rcx
  0008b	49 03 cd	 add	 rcx, r13
  0008e	e8 00 00 00 00	 call	 _PyUnicode_FromUCS1
  00093	4c 8b e0	 mov	 r12, rax
  00096	48 85 c0	 test	 rax, rax
  00099	0f 84 09 01 00
	00		 je	 $onError$121925
  0009f	48 83 fe 0c	 cmp	 rsi, 12
  000a3	7d 0a		 jge	 SHORT $LN12@ucs1lib_sp@2
  000a5	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  000a9	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  000ad	eb 1b		 jmp	 SHORT $LN9@ucs1lib_sp@2
$LN12@ucs1lib_sp@2:
  000af	48 8b d0	 mov	 rdx, rax
  000b2	48 8b cd	 mov	 rcx, rbp
  000b5	e8 00 00 00 00	 call	 PyList_Append
  000ba	49 8b cc	 mov	 rcx, r12
  000bd	85 c0		 test	 eax, eax
  000bf	0f 85 de 00 00
	00		 jne	 $LN44@ucs1lib_sp@2
  000c5	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@ucs1lib_sp@2:

; 120  :                 i = j = j + 1;

  000ca	48 ff c3	 inc	 rbx
  000cd	48 ff c6	 inc	 rsi
  000d0	48 8b cb	 mov	 rcx, rbx
  000d3	48 3b df	 cmp	 rbx, rdi
  000d6	7c 8d		 jl	 SHORT $LL19@ucs1lib_sp@2
$LN18@ucs1lib_sp@2:

; 121  :                 break;
; 122  :             }
; 123  :         }
; 124  :     }
; 125  : #ifndef STRINGLIB_MUTABLE
; 126  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  000d8	48 85 f6	 test	 rsi, rsi
  000db	0f 85 81 00 00
	00		 jne	 $LN8@ucs1lib_sp@2
  000e1	4c 8b 64 24 60	 mov	 r12, QWORD PTR str_obj$[rsp]
$LN48@ucs1lib_sp@2:
  000e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  000ed	49 39 44 24 58	 cmp	 QWORD PTR [r12+88], rax
  000f2	75 6e		 jne	 SHORT $LN8@ucs1lib_sp@2

; 127  :         /* ch not in str_obj, so just use str_obj as list[0] */
; 128  :         Py_INCREF(str_obj);

  000f4	e8 00 00 00 00	 call	 _Py_PXCTX
  000f9	85 c0		 test	 eax, eax
  000fb	75 35		 jne	 SHORT $LN26@ucs1lib_sp@2
  000fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0010b	4d 8b cc	 mov	 r9, r12
  0010e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00114	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0011c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00121	85 c0		 test	 eax, eax
  00123	75 08		 jne	 SHORT $LN25@ucs1lib_sp@2
  00125	41 f6 44 24 20
	20		 test	 BYTE PTR [r12+32], 32	; 00000020H
  0012b	74 05		 je	 SHORT $LN26@ucs1lib_sp@2
$LN25@ucs1lib_sp@2:
  0012d	49 ff 44 24 50	 inc	 QWORD PTR [r12+80]
$LN26@ucs1lib_sp@2:

; 129  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  00132	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]

; 130  :         count++;

  00136	be 01 00 00 00	 mov	 esi, 1
  0013b	4c 89 20	 mov	 QWORD PTR [rax], r12
$LN6@ucs1lib_sp@2:

; 135  :     }
; 136  :     FIX_PREALLOC_SIZE(list);

  0013e	48 89 75 60	 mov	 QWORD PTR [rbp+96], rsi

; 137  :     return list;

  00142	48 8b c5	 mov	 rax, rbp
$LN49@ucs1lib_sp@2:
  00145	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
$LN21@ucs1lib_sp@2:

; 142  : }

  0014a	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  0014f	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00154	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00158	41 5f		 pop	 r15
  0015a	41 5e		 pop	 r14
  0015c	41 5d		 pop	 r13
  0015e	41 5c		 pop	 r12
  00160	5f		 pop	 rdi
  00161	c3		 ret	 0
$LN8@ucs1lib_sp@2:

; 131  :     } else
; 132  : #endif
; 133  :     if (i <= str_len) {

  00162	48 3b cf	 cmp	 rcx, rdi
  00165	7f d7		 jg	 SHORT $LN6@ucs1lib_sp@2

; 134  :         SPLIT_ADD(str, i, str_len);

  00167	48 2b f9	 sub	 rdi, rcx
  0016a	49 03 cd	 add	 rcx, r13
  0016d	48 8b d7	 mov	 rdx, rdi
  00170	e8 00 00 00 00	 call	 _PyUnicode_FromUCS1
  00175	48 8b d8	 mov	 rbx, rax
  00178	48 85 c0	 test	 rax, rax
  0017b	74 2b		 je	 SHORT $onError$121925
  0017d	48 83 fe 0c	 cmp	 rsi, 12
  00181	7d 0e		 jge	 SHORT $LN4@ucs1lib_sp@2
  00183	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  00187	48 ff c6	 inc	 rsi
  0018a	48 89 44 f1 f8	 mov	 QWORD PTR [rcx+rsi*8-8], rax
  0018f	eb ad		 jmp	 SHORT $LN6@ucs1lib_sp@2
$LN4@ucs1lib_sp@2:
  00191	48 8b d0	 mov	 rdx, rax
  00194	48 8b cd	 mov	 rcx, rbp
  00197	e8 00 00 00 00	 call	 PyList_Append
  0019c	48 8b cb	 mov	 rcx, rbx
  0019f	85 c0		 test	 eax, eax
  001a1	74 5b		 je	 SHORT $LN2@ucs1lib_sp@2
$LN44@ucs1lib_sp@2:
  001a3	e8 00 00 00 00	 call	 _Py_DecRef
$onError$121925:

; 138  : 
; 139  :   onError:
; 140  :     Py_DECREF(list);

  001a8	e8 00 00 00 00	 call	 _Py_PXCTX
  001ad	85 c0		 test	 eax, eax
  001af	75 73		 jne	 SHORT $LN39@ucs1lib_sp@2
  001b1	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  001b5	a8 20		 test	 al, 32			; 00000020H
  001b7	75 63		 jne	 SHORT $LN33@ucs1lib_sp@2
  001b9	84 c0		 test	 al, al
  001bb	78 5f		 js	 SHORT $LN33@ucs1lib_sp@2
  001bd	a8 02		 test	 al, 2
  001bf	75 63		 jne	 SHORT $LN39@ucs1lib_sp@2
  001c1	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  001c5	75 5d		 jne	 SHORT $LN39@ucs1lib_sp@2
  001c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001d5	4c 8b cd	 mov	 r9, rbp
  001d8	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001de	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001e6	e8 00 00 00 00	 call	 _PyParallel_Guard
  001eb	48 8b cd	 mov	 rcx, rbp
  001ee	85 c0		 test	 eax, eax
  001f0	74 19		 je	 SHORT $LN38@ucs1lib_sp@2
  001f2	e8 00 00 00 00	 call	 _Px_Dealloc

; 141  :     return NULL;

  001f7	33 c0		 xor	 eax, eax
  001f9	e9 47 ff ff ff	 jmp	 $LN49@ucs1lib_sp@2
$LN2@ucs1lib_sp@2:

; 134  :         SPLIT_ADD(str, i, str_len);

  001fe	e8 00 00 00 00	 call	 _Py_DecRef
  00203	48 ff c6	 inc	 rsi
  00206	e9 33 ff ff ff	 jmp	 $LN6@ucs1lib_sp@2

; 138  : 
; 139  :   onError:
; 140  :     Py_DECREF(list);

$LN38@ucs1lib_sp@2:
  0020b	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  0020f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 141  :     return NULL;

  00215	33 c0		 xor	 eax, eax
  00217	e9 29 ff ff ff	 jmp	 $LN49@ucs1lib_sp@2

; 138  : 
; 139  :   onError:
; 140  :     Py_DECREF(list);

$LN33@ucs1lib_sp@2:
  0021c	48 8b cd	 mov	 rcx, rbp
  0021f	e8 00 00 00 00	 call	 Px_DecRef
$LN39@ucs1lib_sp@2:

; 141  :     return NULL;

  00224	33 c0		 xor	 eax, eax
  00226	e9 1a ff ff ff	 jmp	 $LN49@ucs1lib_sp@2
ucs1lib_split_char ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs1lib_split DD imagerel ucs1lib_split
	DD	imagerel ucs1lib_split+132
	DD	imagerel $unwind$ucs1lib_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ucs1lib_split DD imagerel ucs1lib_split+132
	DD	imagerel ucs1lib_split+190
	DD	imagerel $chain$1$ucs1lib_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ucs1lib_split DD imagerel ucs1lib_split+190
	DD	imagerel ucs1lib_split+824
	DD	imagerel $chain$2$ucs1lib_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ucs1lib_split DD imagerel ucs1lib_split+824
	DD	imagerel ucs1lib_split+847
	DD	imagerel $chain$3$ucs1lib_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$ucs1lib_split DD imagerel ucs1lib_split+847
	DD	imagerel ucs1lib_split+960
	DD	imagerel $chain$5$ucs1lib_split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$ucs1lib_split DD 060021H
	DD	0ad400H
	DD	0b7400H
	DD	0153400H
	DD	imagerel ucs1lib_split
	DD	imagerel ucs1lib_split+132
	DD	imagerel $unwind$ucs1lib_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ucs1lib_split DD 021H
	DD	imagerel ucs1lib_split+132
	DD	imagerel ucs1lib_split+190
	DD	imagerel $chain$1$ucs1lib_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ucs1lib_split DD 020821H
	DD	0153408H
	DD	imagerel ucs1lib_split+132
	DD	imagerel ucs1lib_split+190
	DD	imagerel $chain$1$ucs1lib_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ucs1lib_split DD 041721H
	DD	0ad417H
	DD	0b7405H
	DD	imagerel ucs1lib_split
	DD	imagerel ucs1lib_split+132
	DD	imagerel $unwind$ucs1lib_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_split DD 061b01H
	DD	0f017b21bH
	DD	0c013e015H
	DD	050106011H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs1lib_split
_TEXT	SEGMENT
count$1$ = 48
i$1$ = 56
maxcount$1$ = 64
str_obj$ = 144
str$ = 152
str_len$ = 160
sep$ = 168
list$1$ = 176
sep_len$ = 176
maxcount$ = 184
ucs1lib_split PROC					; COMDAT

; 149  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	41 54		 push	 r12
  00013	41 56		 push	 r14
  00015	41 57		 push	 r15
  00017	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 150  :     Py_ssize_t i, j, pos, count=0;
; 151  :     PyObject *list, *sub;
; 152  : 
; 153  :     if (sep_len == 0) {

  0001b	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR sep_len$[rsp]
  00023	45 33 e4	 xor	 r12d, r12d
  00026	4d 8b f9	 mov	 r15, r9
  00029	49 8b e8	 mov	 rbp, r8
  0002c	4c 8b f2	 mov	 r14, rdx
  0002f	4c 89 64 24 30	 mov	 QWORD PTR count$1$[rsp], r12
  00034	48 85 f6	 test	 rsi, rsi
  00037	75 22		 jne	 SHORT $LN19@ucs1lib_sp@3

; 154  :         PyErr_SetString(PyExc_ValueError, "empty separator");

  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00047	e8 00 00 00 00	 call	 PyErr_SetString

; 155  :         return NULL;

  0004c	33 c0		 xor	 eax, eax

; 190  : }

  0004e	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00052	41 5f		 pop	 r15
  00054	41 5e		 pop	 r14
  00056	41 5c		 pop	 r12
  00058	5e		 pop	 rsi
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
$LN19@ucs1lib_sp@3:

; 156  :     }
; 157  :     else if (sep_len == 1)

  0005b	48 83 fe 01	 cmp	 rsi, 1
  0005f	75 23		 jne	 SHORT $LN17@ucs1lib_sp@3

; 158  :         return STRINGLIB(split_char)(str_obj, str, str_len, sep[0], maxcount);

  00061	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00069	45 0f b6 09	 movzx	 r9d, BYTE PTR [r9]
  0006d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00072	e8 00 00 00 00	 call	 ucs1lib_split_char

; 190  : }

  00077	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0007b	41 5f		 pop	 r15
  0007d	41 5e		 pop	 r14
  0007f	41 5c		 pop	 r12
  00081	5e		 pop	 rsi
  00082	5d		 pop	 rbp
  00083	c3		 ret	 0
$LN17@ucs1lib_sp@3:
  00084	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi

; 159  : 
; 160  :     list = PyList_New(PREALLOC_SIZE(maxcount));

  00089	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR maxcount$[rsp]
  00091	b9 0c 00 00 00	 mov	 ecx, 12
  00096	4c 89 6c 24 50	 mov	 QWORD PTR [rsp+80], r13
  0009b	48 83 ff 0c	 cmp	 rdi, 12
  0009f	7d 04		 jge	 SHORT $LN23@ucs1lib_sp@3
  000a1	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
$LN23@ucs1lib_sp@3:
  000a5	e8 00 00 00 00	 call	 PyList_New
  000aa	4c 8b e8	 mov	 r13, rax
  000ad	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR list$1$[rsp], rax

; 161  :     if (list == NULL)

  000b5	48 85 c0	 test	 rax, rax
  000b8	0f 84 7a 02 00
	00		 je	 $LN122@ucs1lib_sp@3
$LN16@ucs1lib_sp@3:
  000be	48 89 9c 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rbx

; 162  :         return NULL;
; 163  : 
; 164  :     i = j = 0;

  000c6	33 db		 xor	 ebx, ebx
  000c8	48 89 5c 24 38	 mov	 QWORD PTR i$1$[rsp], rbx

; 165  :     while (maxcount-- > 0) {

  000cd	48 85 ff	 test	 rdi, rdi
  000d0	0f 8e 85 01 00
	00		 jle	 $LN112@ucs1lib_sp@3
  000d6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL15@ucs1lib_sp@3:

; 166  :         pos = FASTSEARCH(str+i, str_len-i, sep, sep_len, -1, FAST_SEARCH);

  000e0	48 8b c5	 mov	 rax, rbp
  000e3	4a 8d 2c 33	 lea	 rbp, QWORD PTR [rbx+r14]
  000e7	48 ff cf	 dec	 rdi
  000ea	48 2b c3	 sub	 rax, rbx
  000ed	48 89 7c 24 40	 mov	 QWORD PTR maxcount$1$[rsp], rdi
  000f2	4c 8b f0	 mov	 r14, rax
  000f5	4c 2b f6	 sub	 r14, rsi
  000f8	0f 88 4c 01 00
	00		 js	 $LN110@ucs1lib_sp@3
  000fe	48 83 fe 01	 cmp	 rsi, 1
  00102	7f 68		 jg	 SHORT $LN82@ucs1lib_sp@3
  00104	48 85 f6	 test	 rsi, rsi
  00107	0f 8e 3d 01 00
	00		 jle	 $LN110@ucs1lib_sp@3
  0010d	48 83 f8 0a	 cmp	 rax, 10
  00111	7e 32		 jle	 SHORT $LN80@ucs1lib_sp@3
  00113	4c 8d 04 28	 lea	 r8, QWORD PTR [rax+rbp]
  00117	49 3b e8	 cmp	 rbp, r8
  0011a	73 18		 jae	 SHORT $LN90@ucs1lib_sp@3
  0011c	41 0f b6 17	 movzx	 edx, BYTE PTR [r15]
  00120	4c 2b c5	 sub	 r8, rbp
  00123	48 8b cd	 mov	 rcx, rbp
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0012c	4c 8b d8	 mov	 r11, rax
  0012f	48 85 c0	 test	 rax, rax
  00132	75 09		 jne	 SHORT $LN89@ucs1lib_sp@3
$LN90@ucs1lib_sp@3:
  00134	49 83 cb ff	 or	 r11, -1
  00138	e9 65 01 00 00	 jmp	 $LN85@ucs1lib_sp@3
$LN89@ucs1lib_sp@3:
  0013d	4c 2b dd	 sub	 r11, rbp
  00140	e9 5d 01 00 00	 jmp	 $LN85@ucs1lib_sp@3
$LN80@ucs1lib_sp@3:
  00145	45 33 db	 xor	 r11d, r11d
  00148	48 85 c0	 test	 rax, rax
  0014b	0f 8e f9 00 00
	00		 jle	 $LN110@ucs1lib_sp@3
  00151	41 0f b6 0f	 movzx	 ecx, BYTE PTR [r15]
$LL71@ucs1lib_sp@3:
  00155	41 38 0c 2b	 cmp	 BYTE PTR [r11+rbp], cl
  00159	0f 84 43 01 00
	00		 je	 $LN85@ucs1lib_sp@3
  0015f	49 ff c3	 inc	 r11
  00162	4c 3b d8	 cmp	 r11, rax
  00165	7c ee		 jl	 SHORT $LL71@ucs1lib_sp@3
  00167	e9 de 00 00 00	 jmp	 $LN110@ucs1lib_sp@3
$LN82@ucs1lib_sp@3:
  0016c	48 8d 7e ff	 lea	 rdi, QWORD PTR [rsi-1]
  00170	45 33 e4	 xor	 r12d, r12d
  00173	4c 8d 6f ff	 lea	 r13, QWORD PTR [rdi-1]
  00177	48 85 ff	 test	 rdi, rdi
  0017a	7e 3f		 jle	 SHORT $LN59@ucs1lib_sp@3
  0017c	42 0f b6 1c 3f	 movzx	 ebx, BYTE PTR [rdi+r15]
  00181	4d 8b cf	 mov	 r9, r15
  00184	4d 8b d5	 mov	 r10, r13
  00187	4c 8b df	 mov	 r11, rdi
  0018a	66 0f 1f 44 00
	00		 npad	 6
$LL61@ucs1lib_sp@3:
  00190	45 0f b6 01	 movzx	 r8d, BYTE PTR [r9]
  00194	ba 01 00 00 00	 mov	 edx, 1
  00199	41 8b c8	 mov	 ecx, r8d
  0019c	83 e1 1f	 and	 ecx, 31
  0019f	d3 e2		 shl	 edx, cl
  001a1	44 0b e2	 or	 r12d, edx
  001a4	44 3a c3	 cmp	 r8b, bl
  001a7	4d 0f 44 ea	 cmove	 r13, r10
  001ab	49 ff c1	 inc	 r9
  001ae	49 ff ca	 dec	 r10
  001b1	49 ff cb	 dec	 r11
  001b4	75 da		 jne	 SHORT $LL61@ucs1lib_sp@3
  001b6	48 8b 5c 24 38	 mov	 rbx, QWORD PTR i$1$[rsp]
$LN59@ucs1lib_sp@3:
  001bb	42 0f b6 0c 3f	 movzx	 ecx, BYTE PTR [rdi+r15]
  001c0	ba 01 00 00 00	 mov	 edx, 1
  001c5	45 33 db	 xor	 r11d, r11d
  001c8	83 e1 1f	 and	 ecx, 31
  001cb	d3 e2		 shl	 edx, cl
  001cd	44 0b e2	 or	 r12d, edx
  001d0	4d 85 f6	 test	 r14, r14
  001d3	78 70		 js	 SHORT $LN120@ucs1lib_sp@3
  001d5	45 0f b6 54 37
	ff		 movzx	 r10d, BYTE PTR [r15+rsi-1]
  001db	4c 8d 0c 2e	 lea	 r9, QWORD PTR [rsi+rbp]
  001df	90		 npad	 1
$LL57@ucs1lib_sp@3:
  001e0	47 38 54 19 ff	 cmp	 BYTE PTR [r9+r11-1], r10b
  001e5	75 45		 jne	 SHORT $LN54@ucs1lib_sp@3
  001e7	33 d2		 xor	 edx, edx
  001e9	48 85 ff	 test	 rdi, rdi
  001ec	7e 26		 jle	 SHORT $LN118@ucs1lib_sp@3
  001ee	4c 8b c5	 mov	 r8, rbp
  001f1	49 8b cf	 mov	 rcx, r15
  001f4	4d 2b c7	 sub	 r8, r15
  001f7	4d 03 c3	 add	 r8, r11
  001fa	66 0f 1f 44 00
	00		 npad	 6
$LL53@ucs1lib_sp@3:
  00200	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00203	41 38 04 08	 cmp	 BYTE PTR [r8+rcx], al
  00207	75 0b		 jne	 SHORT $LN118@ucs1lib_sp@3
  00209	48 ff c2	 inc	 rdx
  0020c	48 ff c1	 inc	 rcx
  0020f	48 3b d7	 cmp	 rdx, rdi
  00212	7c ec		 jl	 SHORT $LL53@ucs1lib_sp@3
$LN118@ucs1lib_sp@3:
  00214	48 3b d7	 cmp	 rdx, rdi
  00217	74 7c		 je	 SHORT $LN102@ucs1lib_sp@3
  00219	43 0f b6 04 19	 movzx	 eax, BYTE PTR [r9+r11]
  0021e	83 e0 1f	 and	 eax, 31
  00221	41 0f a3 c4	 bt	 r12d, eax
  00225	73 13		 jae	 SHORT $LN124@ucs1lib_sp@3
  00227	4d 03 dd	 add	 r11, r13
  0022a	eb 11		 jmp	 SHORT $LN56@ucs1lib_sp@3
$LN54@ucs1lib_sp@3:
  0022c	43 0f b6 04 19	 movzx	 eax, BYTE PTR [r9+r11]
  00231	83 e0 1f	 and	 eax, 31
  00234	41 0f a3 c4	 bt	 r12d, eax
  00238	72 03		 jb	 SHORT $LN56@ucs1lib_sp@3
$LN124@ucs1lib_sp@3:
  0023a	4c 03 de	 add	 r11, rsi
$LN56@ucs1lib_sp@3:
  0023d	49 ff c3	 inc	 r11
  00240	4d 3b de	 cmp	 r11, r14
  00243	7e 9b		 jle	 SHORT $LL57@ucs1lib_sp@3
$LN120@ucs1lib_sp@3:

; 170  :         SPLIT_ADD(str, i, j);

  00245	4c 8b 64 24 30	 mov	 r12, QWORD PTR count$1$[rsp]
$LN110@ucs1lib_sp@3:

; 172  :     }
; 173  : #ifndef STRINGLIB_MUTABLE
; 174  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  0024a	4d 85 e4	 test	 r12, r12
  0024d	0f 85 fc 00 00
	00		 jne	 $LN7@ucs1lib_sp@3
  00253	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]
$LN112@ucs1lib_sp@3:
  0025b	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR str_obj$[rsp]
  00263	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  0026a	48 39 47 58	 cmp	 QWORD PTR [rdi+88], rax
  0026e	0f 85 db 00 00
	00		 jne	 $LN7@ucs1lib_sp@3

; 175  :         /* No match in str_obj, so just use it as list[0] */
; 176  :         Py_INCREF(str_obj);

  00274	48 8b cf	 mov	 rcx, rdi
  00277	e8 00 00 00 00	 call	 _Py_IncRef

; 177  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  0027c	4d 8b 5d 70	 mov	 r11, QWORD PTR [r13+112]

; 178  :         count++;

  00280	41 bc 01 00 00
	00		 mov	 r12d, 1
  00286	49 89 3b	 mov	 QWORD PTR [r11], rdi

; 183  :     }
; 184  :     FIX_PREALLOC_SIZE(list);

  00289	4d 89 65 60	 mov	 QWORD PTR [r13+96], r12

; 185  :     return list;

  0028d	49 8b c5	 mov	 rax, r13
  00290	e9 9b 00 00 00	 jmp	 $LN123@ucs1lib_sp@3
$LN102@ucs1lib_sp@3:
  00295	4c 8b 64 24 30	 mov	 r12, QWORD PTR count$1$[rsp]
  0029a	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]

; 166  :         pos = FASTSEARCH(str+i, str_len-i, sep, sep_len, -1, FAST_SEARCH);

$LN85@ucs1lib_sp@3:

; 167  :         if (pos < 0)

  002a2	4d 85 db	 test	 r11, r11
  002a5	78 a3		 js	 SHORT $LN110@ucs1lib_sp@3

; 168  :             break;
; 169  :         j = i + pos;

  002a7	49 8d 3c 1b	 lea	 rdi, QWORD PTR [r11+rbx]

; 170  :         SPLIT_ADD(str, i, j);

  002ab	48 8b cd	 mov	 rcx, rbp
  002ae	48 8b d7	 mov	 rdx, rdi
  002b1	48 2b d3	 sub	 rdx, rbx
  002b4	e8 00 00 00 00	 call	 _PyUnicode_FromUCS1
  002b9	48 8b d8	 mov	 rbx, rax
  002bc	48 85 c0	 test	 rax, rax
  002bf	74 60		 je	 SHORT $onError$121985
  002c1	49 83 fc 0c	 cmp	 r12, 12
  002c5	7d 0a		 jge	 SHORT $LN11@ucs1lib_sp@3
  002c7	49 8b 4d 70	 mov	 rcx, QWORD PTR [r13+112]
  002cb	4a 89 04 e1	 mov	 QWORD PTR [rcx+r12*8], rax
  002cf	eb 17		 jmp	 SHORT $LN8@ucs1lib_sp@3
$LN11@ucs1lib_sp@3:
  002d1	48 8b d0	 mov	 rdx, rax
  002d4	49 8b cd	 mov	 rcx, r13
  002d7	e8 00 00 00 00	 call	 PyList_Append
  002dc	48 8b cb	 mov	 rcx, rbx
  002df	85 c0		 test	 eax, eax
  002e1	75 39		 jne	 SHORT $LN105@ucs1lib_sp@3
  002e3	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@ucs1lib_sp@3:

; 171  :         i = j + sep_len;

  002e8	48 8d 1c 37	 lea	 rbx, QWORD PTR [rdi+rsi]
  002ec	48 8b 7c 24 40	 mov	 rdi, QWORD PTR maxcount$1$[rsp]
  002f1	49 ff c4	 inc	 r12
  002f4	4c 89 64 24 30	 mov	 QWORD PTR count$1$[rsp], r12
  002f9	48 89 5c 24 38	 mov	 QWORD PTR i$1$[rsp], rbx
  002fe	48 85 ff	 test	 rdi, rdi
  00301	0f 8e 43 ff ff
	ff		 jle	 $LN110@ucs1lib_sp@3

; 179  :     } else
; 180  : #endif
; 181  :     {
; 182  :         SPLIT_ADD(str, i, str_len);

  00307	48 8b ac 24 a0
	00 00 00	 mov	 rbp, QWORD PTR str_len$[rsp]
  0030f	4c 8b b4 24 98
	00 00 00	 mov	 r14, QWORD PTR str$[rsp]
  00317	e9 c4 fd ff ff	 jmp	 $LL15@ucs1lib_sp@3
$LN105@ucs1lib_sp@3:

; 170  :         SPLIT_ADD(str, i, j);

  0031c	e8 00 00 00 00	 call	 _Py_DecRef
$onError$121985:

; 186  : 
; 187  :   onError:
; 188  :     Py_DECREF(list);

  00321	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR list$1$[rsp]
  00329	e8 00 00 00 00	 call	 _Py_DecRef

; 189  :     return NULL;

  0032e	33 c0		 xor	 eax, eax
$LN123@ucs1lib_sp@3:
  00330	48 8b 9c 24 a8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+168]
$LN122@ucs1lib_sp@3:
  00338	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0033d	4c 8b 6c 24 50	 mov	 r13, QWORD PTR [rsp+80]

; 190  : }

  00342	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00346	41 5f		 pop	 r15
  00348	41 5e		 pop	 r14
  0034a	41 5c		 pop	 r12
  0034c	5e		 pop	 rsi
  0034d	5d		 pop	 rbp
  0034e	c3		 ret	 0
$LN7@ucs1lib_sp@3:

; 179  :     } else
; 180  : #endif
; 181  :     {
; 182  :         SPLIT_ADD(str, i, str_len);

  0034f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00357	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR str_len$[rsp]
  0035f	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
  00363	48 2b d3	 sub	 rdx, rbx
  00366	e8 00 00 00 00	 call	 _PyUnicode_FromUCS1
  0036b	48 8b d8	 mov	 rbx, rax
  0036e	48 85 c0	 test	 rax, rax
  00371	74 ae		 je	 SHORT $onError$121985
  00373	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]
  0037b	49 83 fc 0c	 cmp	 r12, 12
  0037f	7d 15		 jge	 SHORT $LN4@ucs1lib_sp@3
  00381	49 8b 4d 70	 mov	 rcx, QWORD PTR [r13+112]
  00385	49 ff c4	 inc	 r12
  00388	4a 89 44 e1 f8	 mov	 QWORD PTR [rcx+r12*8-8], rax

; 183  :     }
; 184  :     FIX_PREALLOC_SIZE(list);

  0038d	4d 89 65 60	 mov	 QWORD PTR [r13+96], r12

; 185  :     return list;

  00391	49 8b c5	 mov	 rax, r13
  00394	eb 9a		 jmp	 SHORT $LN123@ucs1lib_sp@3
$LN4@ucs1lib_sp@3:

; 179  :     } else
; 180  : #endif
; 181  :     {
; 182  :         SPLIT_ADD(str, i, str_len);

  00396	48 8b d0	 mov	 rdx, rax
  00399	49 8b cd	 mov	 rcx, r13
  0039c	e8 00 00 00 00	 call	 PyList_Append
  003a1	48 8b cb	 mov	 rcx, rbx
  003a4	85 c0		 test	 eax, eax
  003a6	0f 85 70 ff ff
	ff		 jne	 $LN105@ucs1lib_sp@3
  003ac	e8 00 00 00 00	 call	 _Py_DecRef
  003b1	49 ff c4	 inc	 r12

; 185  :     return list;

  003b4	49 8b c5	 mov	 rax, r13
  003b7	4d 89 65 60	 mov	 QWORD PTR [r13+96], r12
  003bb	e9 70 ff ff ff	 jmp	 $LN123@ucs1lib_sp@3
ucs1lib_split ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ucs1lib_rsplit_whitespace DD imagerel ucs1lib_rsplit_whitespace
	DD	imagerel ucs1lib_rsplit_whitespace+671
	DD	imagerel $unwind$ucs1lib_rsplit_whitespace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_rsplit_whitespace DD 0c5501H
	DD	0df455H
	DD	0c7450H
	DD	0e3411H
	DD	0e00d5211H
	DD	0c009d00bH
	DD	050066007H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs1lib_rsplit_whitespace
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
maxcount$ = 120
ucs1lib_rsplit_whitespace PROC				; COMDAT

; 196  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 197  :     Py_ssize_t i, j, count=0;

  00011	33 ed		 xor	 ebp, ebp
  00013	4c 8b f1	 mov	 r14, rcx
  00016	4d 8b e9	 mov	 r13, r9
  00019	49 8b d8	 mov	 rbx, r8
  0001c	48 8b f2	 mov	 rsi, rdx

; 198  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  0001f	8d 4d 0c	 lea	 ecx, QWORD PTR [rbp+12]
  00022	49 83 f9 0c	 cmp	 r9, 12
  00026	7d 04		 jge	 SHORT $LN28@ucs1lib_rs
  00028	49 8d 49 01	 lea	 rcx, QWORD PTR [r9+1]
$LN28@ucs1lib_rs:
  0002c	e8 00 00 00 00	 call	 PyList_New
  00031	4c 8b e0	 mov	 r12, rax

; 199  :     PyObject *sub;
; 200  : 
; 201  :     if (list == NULL)

  00034	48 85 c0	 test	 rax, rax
  00037	75 12		 jne	 SHORT $LN24@ucs1lib_rs

; 240  : }

  00039	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	41 5e		 pop	 r14
  00044	41 5d		 pop	 r13
  00046	41 5c		 pop	 r12
  00048	5e		 pop	 rsi
  00049	5d		 pop	 rbp
  0004a	c3		 ret	 0
$LN24@ucs1lib_rs:
  0004b	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00050	4c 89 7c 24 68	 mov	 QWORD PTR [rsp+104], r15

; 202  :         return NULL;
; 203  : 
; 204  :     i = j = str_len - 1;

  00055	4c 8d 7b ff	 lea	 r15, QWORD PTR [rbx-1]
  00059	49 8b df	 mov	 rbx, r15
$LN68@ucs1lib_rs:

; 205  :     while (maxcount-- > 0) {

  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
  00063	4d 85 ed	 test	 r13, r13
  00066	0f 8e 69 01 00
	00		 jle	 $LN56@ucs1lib_rs
  0006c	49 ff cd	 dec	 r13

; 206  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  0006f	48 85 db	 test	 rbx, rbx
  00072	0f 88 eb 01 00
	00		 js	 $LN7@ucs1lib_rs
$LL21@ucs1lib_rs:
  00078	0f b6 04 33	 movzx	 eax, BYTE PTR [rbx+rsi]
  0007c	3c 80		 cmp	 al, 128			; 00000080H
  0007e	73 09		 jae	 SHORT $LN29@ucs1lib_rs
  00080	0f b6 c0	 movzx	 eax, al
  00083	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00087	eb 0f		 jmp	 SHORT $LN30@ucs1lib_rs
$LN29@ucs1lib_rs:
  00089	0f b6 c8	 movzx	 ecx, al
  0008c	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
$LN30@ucs1lib_rs:
  00098	85 c0		 test	 eax, eax
  0009a	74 0a		 je	 SHORT $LN20@ucs1lib_rs

; 207  :             i--;

  0009c	48 ff cb	 dec	 rbx

; 206  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  0009f	79 d7		 jns	 SHORT $LL21@ucs1lib_rs
  000a1	e9 bd 01 00 00	 jmp	 $LN7@ucs1lib_rs
$LN20@ucs1lib_rs:

; 208  :         if (i < 0) break;

  000a6	48 85 db	 test	 rbx, rbx
  000a9	0f 88 b4 01 00
	00		 js	 $LN7@ucs1lib_rs

; 209  :         j = i; i--;

  000af	48 8b fb	 mov	 rdi, rbx
  000b2	48 ff cb	 dec	 rbx

; 210  :         while (i >= 0 && !STRINGLIB_ISSPACE(str[i]))

  000b5	78 29		 js	 SHORT $LN63@ucs1lib_rs
$LL18@ucs1lib_rs:
  000b7	0f b6 04 33	 movzx	 eax, BYTE PTR [rbx+rsi]
  000bb	3c 80		 cmp	 al, 128			; 00000080H
  000bd	73 09		 jae	 SHORT $LN31@ucs1lib_rs
  000bf	0f b6 c0	 movzx	 eax, al
  000c2	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000c6	eb 0f		 jmp	 SHORT $LN32@ucs1lib_rs
$LN31@ucs1lib_rs:
  000c8	0f b6 c8	 movzx	 ecx, al
  000cb	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
$LN32@ucs1lib_rs:
  000d7	85 c0		 test	 eax, eax
  000d9	75 05		 jne	 SHORT $LN63@ucs1lib_rs

; 211  :             i--;

  000db	48 ff cb	 dec	 rbx

; 210  :         while (i >= 0 && !STRINGLIB_ISSPACE(str[i]))

  000de	79 d7		 jns	 SHORT $LL18@ucs1lib_rs
$LN63@ucs1lib_rs:

; 212  : #ifndef STRINGLIB_MUTABLE
; 213  :         if (j == str_len - 1 && i < 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  000e0	49 3b ff	 cmp	 rdi, r15
  000e3	75 16		 jne	 SHORT $LN16@ucs1lib_rs
  000e5	48 85 db	 test	 rbx, rbx
  000e8	79 11		 jns	 SHORT $LN16@ucs1lib_rs
  000ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  000f1	49 39 46 58	 cmp	 QWORD PTR [r14+88], rax
  000f5	0f 84 c0 00 00
	00		 je	 $LN51@ucs1lib_rs
$LN16@ucs1lib_rs:

; 219  :         }
; 220  : #endif
; 221  :         SPLIT_ADD(str, i + 1, j + 1);

  000fb	48 2b fb	 sub	 rdi, rbx
  000fe	48 8d 4c 33 01	 lea	 rcx, QWORD PTR [rbx+rsi+1]
  00103	48 8b d7	 mov	 rdx, rdi
  00106	e8 00 00 00 00	 call	 _PyUnicode_FromUCS1
  0010b	48 8b f8	 mov	 rdi, rax
  0010e	48 85 c0	 test	 rax, rax
  00111	0f 84 5d 01 00
	00		 je	 $onError$122046
  00117	48 83 fd 0c	 cmp	 rbp, 12
  0011b	7d 12		 jge	 SHORT $LN14@ucs1lib_rs
  0011d	49 8b 4c 24 70	 mov	 rcx, QWORD PTR [r12+112]
  00122	48 ff c5	 inc	 rbp
  00125	48 89 44 e9 f8	 mov	 QWORD PTR [rcx+rbp*8-8], rax
  0012a	e9 2d ff ff ff	 jmp	 $LN68@ucs1lib_rs
$LN14@ucs1lib_rs:
  0012f	48 8b d0	 mov	 rdx, rax
  00132	49 8b cc	 mov	 rcx, r12
  00135	e8 00 00 00 00	 call	 PyList_Append
  0013a	85 c0		 test	 eax, eax
  0013c	0f 85 af 00 00
	00		 jne	 $LN53@ucs1lib_rs
  00142	e8 00 00 00 00	 call	 _Py_PXCTX
  00147	85 c0		 test	 eax, eax
  00149	75 68		 jne	 SHORT $LN45@ucs1lib_rs
  0014b	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0014f	a8 20		 test	 al, 32			; 00000020H
  00151	75 58		 jne	 SHORT $LN39@ucs1lib_rs
  00153	84 c0		 test	 al, al
  00155	78 54		 js	 SHORT $LN39@ucs1lib_rs
  00157	a8 02		 test	 al, 2
  00159	75 58		 jne	 SHORT $LN45@ucs1lib_rs
  0015b	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0015f	75 52		 jne	 SHORT $LN45@ucs1lib_rs
  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00168	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0016f	4c 8b cf	 mov	 r9, rdi
  00172	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00178	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00180	e8 00 00 00 00	 call	 _PyParallel_Guard
  00185	48 8b cf	 mov	 rcx, rdi
  00188	85 c0		 test	 eax, eax
  0018a	74 0d		 je	 SHORT $LN44@ucs1lib_rs
  0018c	e8 00 00 00 00	 call	 _Px_Dealloc
  00191	48 ff c5	 inc	 rbp
  00194	e9 c3 fe ff ff	 jmp	 $LN68@ucs1lib_rs
$LN44@ucs1lib_rs:
  00199	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0019d	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001a3	48 ff c5	 inc	 rbp
  001a6	e9 b1 fe ff ff	 jmp	 $LN68@ucs1lib_rs
$LN39@ucs1lib_rs:
  001ab	48 8b cf	 mov	 rcx, rdi
  001ae	e8 00 00 00 00	 call	 Px_DecRef
$LN45@ucs1lib_rs:
  001b3	48 ff c5	 inc	 rbp

; 205  :     while (maxcount-- > 0) {

  001b6	e9 a1 fe ff ff	 jmp	 $LN68@ucs1lib_rs
$LN51@ucs1lib_rs:

; 214  :             /* No whitespace in str_obj, so just use it as list[0] */
; 215  :             Py_INCREF(str_obj);

  001bb	49 8b ce	 mov	 rcx, r14
  001be	e8 00 00 00 00	 call	 _Py_IncRef

; 216  :             PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  001c3	4d 8b 5c 24 70	 mov	 r11, QWORD PTR [r12+112]

; 217  :             count++;

  001c8	48 ff c5	 inc	 rbp
  001cb	4d 89 33	 mov	 QWORD PTR [r11], r14

; 218  :             break;

  001ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
$LN56@ucs1lib_rs:

; 222  :     }
; 223  : 
; 224  :     if (i >= 0) {

  001d5	48 85 db	 test	 rbx, rbx
  001d8	0f 88 85 00 00
	00		 js	 $LN7@ucs1lib_rs
  001de	66 90		 npad	 2
$LL9@ucs1lib_rs:

; 225  :         /* Only occurs when maxcount was reached */
; 226  :         /* Skip any remaining whitespace and copy to beginning of string */
; 227  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  001e0	0f b6 04 33	 movzx	 eax, BYTE PTR [rbx+rsi]
  001e4	3c 80		 cmp	 al, 128			; 00000080H
  001e6	73 1d		 jae	 SHORT $LN33@ucs1lib_rs
  001e8	0f b6 c0	 movzx	 eax, al
  001eb	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  001ef	eb 23		 jmp	 SHORT $LN34@ucs1lib_rs
$LN53@ucs1lib_rs:

; 219  :         }
; 220  : #endif
; 221  :         SPLIT_ADD(str, i + 1, j + 1);

  001f1	48 8b cf	 mov	 rcx, rdi
$LN69@ucs1lib_rs:
  001f4	e8 00 00 00 00	 call	 _Py_DecRef

; 236  : 
; 237  :   onError:
; 238  :     Py_DECREF(list);

  001f9	49 8b cc	 mov	 rcx, r12
  001fc	e8 00 00 00 00	 call	 _Py_DecRef

; 239  :     return NULL;

  00201	33 c0		 xor	 eax, eax
  00203	eb 7e		 jmp	 SHORT $LN66@ucs1lib_rs
$LN33@ucs1lib_rs:

; 225  :         /* Only occurs when maxcount was reached */
; 226  :         /* Skip any remaining whitespace and copy to beginning of string */
; 227  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  00205	0f b6 c8	 movzx	 ecx, al
  00208	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  0020d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ascii_whitespace
$LN34@ucs1lib_rs:
  00214	85 c0		 test	 eax, eax
  00216	74 07		 je	 SHORT $LN8@ucs1lib_rs

; 228  :             i--;

  00218	48 ff cb	 dec	 rbx

; 225  :         /* Only occurs when maxcount was reached */
; 226  :         /* Skip any remaining whitespace and copy to beginning of string */
; 227  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  0021b	79 c3		 jns	 SHORT $LL9@ucs1lib_rs

; 229  :         if (i >= 0)

  0021d	eb 44		 jmp	 SHORT $LN7@ucs1lib_rs
$LN8@ucs1lib_rs:
  0021f	48 85 db	 test	 rbx, rbx
  00222	78 3f		 js	 SHORT $LN7@ucs1lib_rs

; 230  :             SPLIT_ADD(str, 0, i + 1);

  00224	48 8d 53 01	 lea	 rdx, QWORD PTR [rbx+1]
  00228	48 8b ce	 mov	 rcx, rsi
  0022b	e8 00 00 00 00	 call	 _PyUnicode_FromUCS1
  00230	48 8b d8	 mov	 rbx, rax
  00233	48 85 c0	 test	 rax, rax
  00236	74 3c		 je	 SHORT $onError$122046
  00238	48 83 fd 0c	 cmp	 rbp, 12
  0023c	7d 0b		 jge	 SHORT $LN5@ucs1lib_rs
  0023e	49 8b 4c 24 70	 mov	 rcx, QWORD PTR [r12+112]
  00243	48 89 04 e9	 mov	 QWORD PTR [rcx+rbp*8], rax
  00247	eb 17		 jmp	 SHORT $LN2@ucs1lib_rs
$LN5@ucs1lib_rs:
  00249	48 8b d0	 mov	 rdx, rax
  0024c	49 8b cc	 mov	 rcx, r12
  0024f	e8 00 00 00 00	 call	 PyList_Append
  00254	48 8b cb	 mov	 rcx, rbx
  00257	85 c0		 test	 eax, eax
  00259	75 99		 jne	 SHORT $LN69@ucs1lib_rs
  0025b	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@ucs1lib_rs:
  00260	48 ff c5	 inc	 rbp
$LN7@ucs1lib_rs:

; 231  :     }
; 232  :     FIX_PREALLOC_SIZE(list);
; 233  :     if (PyList_Reverse(list) < 0)

  00263	49 8b cc	 mov	 rcx, r12
  00266	49 89 6c 24 60	 mov	 QWORD PTR [r12+96], rbp
  0026b	e8 00 00 00 00	 call	 PyList_Reverse
  00270	85 c0		 test	 eax, eax
  00272	79 0c		 jns	 SHORT $LN1@ucs1lib_rs
$onError$122046:

; 236  : 
; 237  :   onError:
; 238  :     Py_DECREF(list);

  00274	49 8b cc	 mov	 rcx, r12
  00277	e8 00 00 00 00	 call	 _Py_DecRef

; 239  :     return NULL;

  0027c	33 c0		 xor	 eax, eax
  0027e	eb 03		 jmp	 SHORT $LN66@ucs1lib_rs
$LN1@ucs1lib_rs:

; 234  :         goto onError;
; 235  :     return list;

  00280	49 8b c4	 mov	 rax, r12
$LN66@ucs1lib_rs:
  00283	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00288	4c 8b 7c 24 68	 mov	 r15, QWORD PTR [rsp+104]

; 240  : }

  0028d	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00292	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00296	41 5e		 pop	 r14
  00298	41 5d		 pop	 r13
  0029a	41 5c		 pop	 r12
  0029c	5e		 pop	 rsi
  0029d	5d		 pop	 rbp
  0029e	c3		 ret	 0
ucs1lib_rsplit_whitespace ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ucs1lib_rsplit_char DD imagerel ucs1lib_rsplit_char
	DD	imagerel ucs1lib_rsplit_char+80
	DD	imagerel $unwind$ucs1lib_rsplit_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ucs1lib_rsplit_char DD imagerel ucs1lib_rsplit_char+80
	DD	imagerel ucs1lib_rsplit_char+503
	DD	imagerel $chain$0$ucs1lib_rsplit_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ucs1lib_rsplit_char DD imagerel ucs1lib_rsplit_char+503
	DD	imagerel ucs1lib_rsplit_char+527
	DD	imagerel $chain$1$ucs1lib_rsplit_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ucs1lib_rsplit_char DD 021H
	DD	imagerel ucs1lib_rsplit_char
	DD	imagerel ucs1lib_rsplit_char+80
	DD	imagerel $unwind$ucs1lib_rsplit_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ucs1lib_rsplit_char DD 020521H
	DD	0c5405H
	DD	imagerel ucs1lib_rsplit_char
	DD	imagerel ucs1lib_rsplit_char+80
	DD	imagerel $unwind$ucs1lib_rsplit_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_rsplit_char DD 0a1701H
	DD	0e6417H
	DD	0d3417H
	DD	0f0135217H
	DD	0d00fe011H
	DD	0700bc00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs1lib_rsplit_char
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
ch$ = 120
maxcount$ = 128
ucs1lib_rsplit_char PROC				; COMDAT

; 247  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 248  :     Py_ssize_t i, j, count=0;
; 249  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00017	4c 8b b4 24 80
	00 00 00	 mov	 r14, QWORD PTR maxcount$[rsp]
  0001f	33 f6		 xor	 esi, esi
  00021	4c 8b f9	 mov	 r15, rcx
  00024	45 0f b6 e9	 movzx	 r13d, r9b
  00028	49 8b d8	 mov	 rbx, r8
  0002b	4c 8b e2	 mov	 r12, rdx
  0002e	8d 4e 0c	 lea	 ecx, QWORD PTR [rsi+12]
  00031	49 83 fe 0c	 cmp	 r14, 12
  00035	7d 04		 jge	 SHORT $LN25@ucs1lib_rs@2
  00037	49 8d 4e 01	 lea	 rcx, QWORD PTR [r14+1]
$LN25@ucs1lib_rs@2:
  0003b	e8 00 00 00 00	 call	 PyList_New
  00040	48 8b f8	 mov	 rdi, rax

; 250  :     PyObject *sub;
; 251  : 
; 252  :     if (list == NULL)

  00043	48 85 c0	 test	 rax, rax
  00046	0f 84 ab 01 00
	00		 je	 $LN22@ucs1lib_rs@2
$LN21@ucs1lib_rs@2:

; 253  :         return NULL;
; 254  : 
; 255  :     i = j = str_len - 1;

  0004c	48 8d 53 ff	 lea	 rdx, QWORD PTR [rbx-1]
  00050	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  00055	48 8b da	 mov	 rbx, rdx

; 256  :     while ((i >= 0) && (maxcount-- > 0)) {

  00058	48 85 d2	 test	 rdx, rdx
  0005b	78 74		 js	 SHORT $LN49@ucs1lib_rs@2
  0005d	0f 1f 00	 npad	 3
$LL20@ucs1lib_rs@2:
  00060	49 8b c6	 mov	 rax, r14
  00063	49 ff ce	 dec	 r14
  00066	48 85 c0	 test	 rax, rax
  00069	7e 61		 jle	 SHORT $LN19@ucs1lib_rs@2

; 257  :         for(; i >= 0; i--) {

  0006b	48 85 db	 test	 rbx, rbx
  0006e	78 5c		 js	 SHORT $LN19@ucs1lib_rs@2
$LL18@ucs1lib_rs@2:

; 258  :             if (str[i] == ch) {

  00070	46 38 2c 23	 cmp	 BYTE PTR [rbx+r12], r13b
  00074	74 07		 je	 SHORT $LN43@ucs1lib_rs@2

; 257  :         for(; i >= 0; i--) {

  00076	48 ff cb	 dec	 rbx
  00079	79 f5		 jns	 SHORT $LL18@ucs1lib_rs@2
  0007b	eb 4f		 jmp	 SHORT $LN19@ucs1lib_rs@2
$LN43@ucs1lib_rs@2:

; 259  :                 SPLIT_ADD(str, i + 1, j + 1);

  0007d	4a 8d 4c 23 01	 lea	 rcx, QWORD PTR [rbx+r12+1]
  00082	48 2b d3	 sub	 rdx, rbx
  00085	e8 00 00 00 00	 call	 _PyUnicode_FromUCS1
  0008a	48 8b e8	 mov	 rbp, rax
  0008d	48 85 c0	 test	 rax, rax
  00090	0f 84 ec 00 00
	00		 je	 $onError$122101
  00096	48 83 fe 0c	 cmp	 rsi, 12
  0009a	7d 0a		 jge	 SHORT $LN13@ucs1lib_rs@2
  0009c	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  000a0	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  000a4	eb 1b		 jmp	 SHORT $LN10@ucs1lib_rs@2
$LN13@ucs1lib_rs@2:
  000a6	48 8b d0	 mov	 rdx, rax
  000a9	48 8b cf	 mov	 rcx, rdi
  000ac	e8 00 00 00 00	 call	 PyList_Append
  000b1	48 8b cd	 mov	 rcx, rbp
  000b4	85 c0		 test	 eax, eax
  000b6	0f 85 a7 00 00
	00		 jne	 $LN45@ucs1lib_rs@2
  000bc	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@ucs1lib_rs@2:
  000c1	48 ff c6	 inc	 rsi

; 260  :                 j = i = i - 1;

  000c4	48 ff cb	 dec	 rbx
  000c7	48 8b d3	 mov	 rdx, rbx
  000ca	79 94		 jns	 SHORT $LL20@ucs1lib_rs@2
$LN19@ucs1lib_rs@2:

; 261  :                 break;
; 262  :             }
; 263  :         }
; 264  :     }
; 265  : #ifndef STRINGLIB_MUTABLE
; 266  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  000cc	48 85 f6	 test	 rsi, rsi
  000cf	75 57		 jne	 SHORT $LN9@ucs1lib_rs@2
$LN49@ucs1lib_rs@2:
  000d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  000d8	49 39 47 58	 cmp	 QWORD PTR [r15+88], rax
  000dc	75 4a		 jne	 SHORT $LN9@ucs1lib_rs@2

; 267  :         /* ch not in str_obj, so just use str_obj as list[0] */
; 268  :         Py_INCREF(str_obj);

  000de	e8 00 00 00 00	 call	 _Py_PXCTX
  000e3	85 c0		 test	 eax, eax
  000e5	75 33		 jne	 SHORT $LN27@ucs1lib_rs@2
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000f5	4d 8b cf	 mov	 r9, r15
  000f8	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000fe	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00106	e8 00 00 00 00	 call	 _PyParallel_Guard
  0010b	85 c0		 test	 eax, eax
  0010d	75 07		 jne	 SHORT $LN26@ucs1lib_rs@2
  0010f	41 f6 47 20 20	 test	 BYTE PTR [r15+32], 32	; 00000020H
  00114	74 04		 je	 SHORT $LN27@ucs1lib_rs@2
$LN26@ucs1lib_rs@2:
  00116	49 ff 47 50	 inc	 QWORD PTR [r15+80]
$LN27@ucs1lib_rs@2:

; 269  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  0011a	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]

; 270  :         count++;

  0011e	be 01 00 00 00	 mov	 esi, 1
  00123	4c 89 38	 mov	 QWORD PTR [rax], r15

; 271  :     } else

  00126	eb 4a		 jmp	 SHORT $LN7@ucs1lib_rs@2
$LN9@ucs1lib_rs@2:

; 272  : #endif
; 273  :     if (j >= -1) {

  00128	48 83 fa ff	 cmp	 rdx, -1
  0012c	7c 44		 jl	 SHORT $LN7@ucs1lib_rs@2

; 274  :         SPLIT_ADD(str, 0, j + 1);

  0012e	48 ff c2	 inc	 rdx
  00131	49 8b cc	 mov	 rcx, r12
  00134	e8 00 00 00 00	 call	 _PyUnicode_FromUCS1
  00139	48 8b d8	 mov	 rbx, rax
  0013c	48 85 c0	 test	 rax, rax
  0013f	74 41		 je	 SHORT $onError$122101
  00141	48 83 fe 0c	 cmp	 rsi, 12
  00145	7d 0a		 jge	 SHORT $LN5@ucs1lib_rs@2
  00147	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  0014b	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  0014f	eb 1e		 jmp	 SHORT $LN2@ucs1lib_rs@2
$LN5@ucs1lib_rs@2:
  00151	48 8b d0	 mov	 rdx, rax
  00154	48 8b cf	 mov	 rcx, rdi
  00157	e8 00 00 00 00	 call	 PyList_Append
  0015c	48 8b cb	 mov	 rcx, rbx
  0015f	85 c0		 test	 eax, eax
  00161	74 07		 je	 SHORT $LN3@ucs1lib_rs@2
$LN45@ucs1lib_rs@2:
  00163	e8 00 00 00 00	 call	 _Py_DecRef
  00168	eb 18		 jmp	 SHORT $onError$122101
$LN3@ucs1lib_rs@2:
  0016a	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@ucs1lib_rs@2:
  0016f	48 ff c6	 inc	 rsi
$LN7@ucs1lib_rs@2:

; 275  :     }
; 276  :     FIX_PREALLOC_SIZE(list);
; 277  :     if (PyList_Reverse(list) < 0)

  00172	48 8b cf	 mov	 rcx, rdi
  00175	48 89 77 60	 mov	 QWORD PTR [rdi+96], rsi
  00179	e8 00 00 00 00	 call	 PyList_Reverse
  0017e	85 c0		 test	 eax, eax
  00180	79 6d		 jns	 SHORT $LN1@ucs1lib_rs@2
$onError$122101:

; 280  : 
; 281  :   onError:
; 282  :     Py_DECREF(list);

  00182	e8 00 00 00 00	 call	 _Py_PXCTX
  00187	85 c0		 test	 eax, eax
  00189	75 60		 jne	 SHORT $LN40@ucs1lib_rs@2
  0018b	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0018f	a8 20		 test	 al, 32			; 00000020H
  00191	75 50		 jne	 SHORT $LN34@ucs1lib_rs@2
  00193	84 c0		 test	 al, al
  00195	78 4c		 js	 SHORT $LN34@ucs1lib_rs@2
  00197	a8 02		 test	 al, 2
  00199	75 50		 jne	 SHORT $LN40@ucs1lib_rs@2
  0019b	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0019f	75 4a		 jne	 SHORT $LN40@ucs1lib_rs@2
  001a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001af	4c 8b cf	 mov	 r9, rdi
  001b2	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001b8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001c0	e8 00 00 00 00	 call	 _PyParallel_Guard
  001c5	48 8b cf	 mov	 rcx, rdi
  001c8	85 c0		 test	 eax, eax
  001ca	74 09		 je	 SHORT $LN39@ucs1lib_rs@2
  001cc	e8 00 00 00 00	 call	 _Px_Dealloc

; 283  :     return NULL;

  001d1	33 c0		 xor	 eax, eax
  001d3	eb 1d		 jmp	 SHORT $LN50@ucs1lib_rs@2

; 280  : 
; 281  :   onError:
; 282  :     Py_DECREF(list);

$LN39@ucs1lib_rs@2:
  001d5	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001d9	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 283  :     return NULL;

  001df	33 c0		 xor	 eax, eax
  001e1	eb 0f		 jmp	 SHORT $LN50@ucs1lib_rs@2

; 280  : 
; 281  :   onError:
; 282  :     Py_DECREF(list);

$LN34@ucs1lib_rs@2:
  001e3	48 8b cf	 mov	 rcx, rdi
  001e6	e8 00 00 00 00	 call	 Px_DecRef
$LN40@ucs1lib_rs@2:

; 283  :     return NULL;

  001eb	33 c0		 xor	 eax, eax
  001ed	eb 03		 jmp	 SHORT $LN50@ucs1lib_rs@2
$LN1@ucs1lib_rs@2:

; 278  :         goto onError;
; 279  :     return list;

  001ef	48 8b c7	 mov	 rax, rdi
$LN50@ucs1lib_rs@2:
  001f2	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
$LN22@ucs1lib_rs@2:

; 284  : }

  001f7	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  001fc	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  00201	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00205	41 5f		 pop	 r15
  00207	41 5e		 pop	 r14
  00209	41 5d		 pop	 r13
  0020b	41 5c		 pop	 r12
  0020d	5f		 pop	 rdi
  0020e	c3		 ret	 0
ucs1lib_rsplit_char ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs1lib_rsplit DD imagerel ucs1lib_rsplit
	DD	imagerel ucs1lib_rsplit+130
	DD	imagerel $unwind$ucs1lib_rsplit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ucs1lib_rsplit DD imagerel ucs1lib_rsplit+130
	DD	imagerel ucs1lib_rsplit+744
	DD	imagerel $chain$1$ucs1lib_rsplit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ucs1lib_rsplit DD imagerel ucs1lib_rsplit+744
	DD	imagerel ucs1lib_rsplit+836
	DD	imagerel $chain$3$ucs1lib_rsplit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ucs1lib_rsplit DD 040021H
	DD	08e400H
	DD	011d400H
	DD	imagerel ucs1lib_rsplit
	DD	imagerel ucs1lib_rsplit+130
	DD	imagerel $unwind$ucs1lib_rsplit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ucs1lib_rsplit DD 040d21H
	DD	08e40dH
	DD	011d408H
	DD	imagerel ucs1lib_rsplit
	DD	imagerel ucs1lib_rsplit+130
	DD	imagerel $unwind$ucs1lib_rsplit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_rsplit DD 071601H
	DD	0f0128216H
	DD	0700ec010H
	DD	0500c600dH
	DD	0300bH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs1lib_rsplit
_TEXT	SEGMENT
j$1$ = 48
maxcount$1$ = 56
str_obj$ = 128
str$ = 136
str_len$ = 144
sep$ = 152
list$1$ = 160
sep_len$ = 160
maxcount$ = 168
ucs1lib_rsplit PROC					; COMDAT

; 291  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	41 54		 push	 r12
  00010	41 57		 push	 r15
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 292  :     Py_ssize_t j, pos, count=0;
; 293  :     PyObject *list, *sub;
; 294  : 
; 295  :     if (sep_len == 0) {

  00016	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR sep_len$[rsp]
  0001e	45 33 ff	 xor	 r15d, r15d
  00021	4d 8b e1	 mov	 r12, r9
  00024	49 8b f8	 mov	 rdi, r8
  00027	4c 89 44 24 30	 mov	 QWORD PTR j$1$[rsp], r8
  0002c	48 8b ea	 mov	 rbp, rdx
  0002f	48 8b d9	 mov	 rbx, rcx
  00032	48 85 f6	 test	 rsi, rsi
  00035	75 22		 jne	 SHORT $LN20@ucs1lib_rs@3

; 296  :         PyErr_SetString(PyExc_ValueError, "empty separator");

  00037	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00045	e8 00 00 00 00	 call	 PyErr_SetString

; 297  :         return NULL;

  0004a	33 c0		 xor	 eax, eax

; 333  : }

  0004c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00050	41 5f		 pop	 r15
  00052	41 5c		 pop	 r12
  00054	5f		 pop	 rdi
  00055	5e		 pop	 rsi
  00056	5d		 pop	 rbp
  00057	5b		 pop	 rbx
  00058	c3		 ret	 0
$LN20@ucs1lib_rs@3:

; 298  :     }
; 299  :     else if (sep_len == 1)

  00059	48 83 fe 01	 cmp	 rsi, 1
  0005d	75 23		 jne	 SHORT $LN18@ucs1lib_rs@3

; 300  :         return STRINGLIB(rsplit_char)(str_obj, str, str_len, sep[0], maxcount);

  0005f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00067	45 0f b6 09	 movzx	 r9d, BYTE PTR [r9]
  0006b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00070	e8 00 00 00 00	 call	 ucs1lib_rsplit_char

; 333  : }

  00075	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00079	41 5f		 pop	 r15
  0007b	41 5c		 pop	 r12
  0007d	5f		 pop	 rdi
  0007e	5e		 pop	 rsi
  0007f	5d		 pop	 rbp
  00080	5b		 pop	 rbx
  00081	c3		 ret	 0
$LN18@ucs1lib_rs@3:
  00082	4c 89 ac 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], r13
  0008a	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14

; 301  : 
; 302  :     list = PyList_New(PREALLOC_SIZE(maxcount));

  0008f	4c 8b b4 24 a8
	00 00 00	 mov	 r14, QWORD PTR maxcount$[rsp]
  00097	b9 0c 00 00 00	 mov	 ecx, 12
  0009c	49 83 fe 0c	 cmp	 r14, 12
  000a0	7d 04		 jge	 SHORT $LN24@ucs1lib_rs@3
  000a2	49 8d 4e 01	 lea	 rcx, QWORD PTR [r14+1]
$LN24@ucs1lib_rs@3:
  000a6	e8 00 00 00 00	 call	 PyList_New
  000ab	4c 8b e8	 mov	 r13, rax
  000ae	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR list$1$[rsp], rax

; 303  :     if (list == NULL)

  000b6	48 85 c0	 test	 rax, rax

; 304  :         return NULL;

  000b9	0f 84 0d 02 00
	00		 je	 $LN123@ucs1lib_rs@3

; 305  : 
; 306  :     j = str_len;
; 307  :     while (maxcount-- > 0) {

  000bf	4d 85 f6	 test	 r14, r14
  000c2	7e 67		 jle	 SHORT $LN113@ucs1lib_rs@3
  000c4	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL16@ucs1lib_rs@3:
  000d0	49 ff ce	 dec	 r14

; 308  :         pos = FASTSEARCH(str, j, sep, sep_len, -1, FAST_RSEARCH);

  000d3	48 8b df	 mov	 rbx, rdi
  000d6	48 2b de	 sub	 rbx, rsi
  000d9	4c 89 74 24 38	 mov	 QWORD PTR maxcount$1$[rsp], r14
  000de	78 32		 js	 SHORT $LN111@ucs1lib_rs@3
  000e0	48 83 fe 01	 cmp	 rsi, 1
  000e4	7f 70		 jg	 SHORT $LN83@ucs1lib_rs@3
  000e6	48 85 f6	 test	 rsi, rsi
  000e9	7e 27		 jle	 SHORT $LN111@ucs1lib_rs@3
  000eb	48 8d 5f ff	 lea	 rbx, QWORD PTR [rdi-1]
  000ef	48 83 fb ff	 cmp	 rbx, -1
  000f3	7e 1d		 jle	 SHORT $LN111@ucs1lib_rs@3
  000f5	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  000fa	66 0f 1f 44 00
	00		 npad	 6
$LL67@ucs1lib_rs@3:
  00100	38 04 2b	 cmp	 BYTE PTR [rbx+rbp], al
  00103	0f 84 4b 01 00
	00		 je	 $LN103@ucs1lib_rs@3
  00109	48 ff cb	 dec	 rbx
  0010c	48 83 fb ff	 cmp	 rbx, -1
  00110	7f ee		 jg	 SHORT $LL67@ucs1lib_rs@3
$LN111@ucs1lib_rs@3:

; 313  :     }
; 314  : #ifndef STRINGLIB_MUTABLE
; 315  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  00112	4d 85 ff	 test	 r15, r15
  00115	0f 85 cd 01 00
	00		 jne	 $LN8@ucs1lib_rs@3
  0011b	4c 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]
  00123	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR str_obj$[rsp]
$LN113@ucs1lib_rs@3:
  0012b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00132	48 39 43 58	 cmp	 QWORD PTR [rbx+88], rax
  00136	0f 85 ac 01 00
	00		 jne	 $LN8@ucs1lib_rs@3

; 316  :         /* No match in str_obj, so just use it as list[0] */
; 317  :         Py_INCREF(str_obj);

  0013c	48 8b cb	 mov	 rcx, rbx
  0013f	e8 00 00 00 00	 call	 _Py_IncRef

; 318  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  00144	4d 8b 5d 70	 mov	 r11, QWORD PTR [r13+112]

; 319  :         count++;

  00148	41 bf 01 00 00
	00		 mov	 r15d, 1
  0014e	49 89 1b	 mov	 QWORD PTR [r11], rbx

; 320  :     } else

  00151	e9 d9 01 00 00	 jmp	 $LN7@ucs1lib_rs@3

; 308  :         pos = FASTSEARCH(str, j, sep, sep_len, -1, FAST_RSEARCH);

$LN83@ucs1lib_rs@3:
  00156	4c 8b 94 24 98
	00 00 00	 mov	 r10, QWORD PTR sep$[rsp]
  0015e	48 8d 7e ff	 lea	 rdi, QWORD PTR [rsi-1]
  00162	41 bd 01 00 00
	00		 mov	 r13d, 1
  00168	45 0f b6 32	 movzx	 r14d, BYTE PTR [r10]
  0016c	4c 8d 67 ff	 lea	 r12, QWORD PTR [rdi-1]
  00170	41 8b ce	 mov	 ecx, r14d
  00173	83 e1 1f	 and	 ecx, 31
  00176	41 d3 e5	 shl	 r13d, cl
  00179	48 85 ff	 test	 rdi, rdi
  0017c	7e 3f		 jle	 SHORT $LN40@ucs1lib_rs@3
  0017e	49 83 cb ff	 or	 r11, -1
  00182	4e 8d 0c 17	 lea	 r9, QWORD PTR [rdi+r10]
  00186	4d 2b da	 sub	 r11, r10
  00189	4c 8b d7	 mov	 r10, rdi
  0018c	0f 1f 40 00	 npad	 4
$LL42@ucs1lib_rs@3:
  00190	45 0f b6 01	 movzx	 r8d, BYTE PTR [r9]
  00194	ba 01 00 00 00	 mov	 edx, 1
  00199	41 8b c8	 mov	 ecx, r8d
  0019c	83 e1 1f	 and	 ecx, 31
  0019f	d3 e2		 shl	 edx, cl
  001a1	44 0b ea	 or	 r13d, edx
  001a4	45 3a c6	 cmp	 r8b, r14b
  001a7	75 04		 jne	 SHORT $LN41@ucs1lib_rs@3
  001a9	4f 8d 24 0b	 lea	 r12, QWORD PTR [r11+r9]
$LN41@ucs1lib_rs@3:
  001ad	49 ff c9	 dec	 r9
  001b0	49 ff ca	 dec	 r10
  001b3	75 db		 jne	 SHORT $LL42@ucs1lib_rs@3
  001b5	4c 8b 94 24 98
	00 00 00	 mov	 r10, QWORD PTR sep$[rsp]
$LN40@ucs1lib_rs@3:
  001bd	4c 8b c3	 mov	 r8, rbx
  001c0	4d 2b c2	 sub	 r8, r10
  001c3	4c 03 c5	 add	 r8, rbp
$LL38@ucs1lib_rs@3:
  001c6	44 38 34 2b	 cmp	 BYTE PTR [rbx+rbp], r14b
  001ca	75 48		 jne	 SHORT $LN35@ucs1lib_rs@3
  001cc	48 8b d7	 mov	 rdx, rdi
  001cf	48 85 ff	 test	 rdi, rdi
  001d2	7e 20		 jle	 SHORT $LN119@ucs1lib_rs@3
  001d4	4a 8d 0c 17	 lea	 rcx, QWORD PTR [rdi+r10]
  001d8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL34@ucs1lib_rs@3:
  001e0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  001e3	41 38 04 08	 cmp	 BYTE PTR [r8+rcx], al
  001e7	75 0b		 jne	 SHORT $LN119@ucs1lib_rs@3
  001e9	48 ff ca	 dec	 rdx
  001ec	48 ff c9	 dec	 rcx
  001ef	48 85 d2	 test	 rdx, rdx
  001f2	7f ec		 jg	 SHORT $LL34@ucs1lib_rs@3
$LN119@ucs1lib_rs@3:
  001f4	48 85 d2	 test	 rdx, rdx
  001f7	74 41		 je	 SHORT $LN120@ucs1lib_rs@3
  001f9	48 85 db	 test	 rbx, rbx
  001fc	7e 0e		 jle	 SHORT $LN29@ucs1lib_rs@3
  001fe	0f b6 44 2b ff	 movzx	 eax, BYTE PTR [rbx+rbp-1]
  00203	83 e0 1f	 and	 eax, 31
  00206	41 0f a3 c5	 bt	 r13d, eax
  0020a	73 1b		 jae	 SHORT $LN124@ucs1lib_rs@3
$LN29@ucs1lib_rs@3:
  0020c	49 2b dc	 sub	 rbx, r12
  0020f	4d 2b c4	 sub	 r8, r12
  00212	eb 19		 jmp	 SHORT $LN37@ucs1lib_rs@3
$LN35@ucs1lib_rs@3:
  00214	48 85 db	 test	 rbx, rbx
  00217	7e 14		 jle	 SHORT $LN37@ucs1lib_rs@3
  00219	0f b6 44 2b ff	 movzx	 eax, BYTE PTR [rbx+rbp-1]
  0021e	83 e0 1f	 and	 eax, 31
  00221	41 0f a3 c5	 bt	 r13d, eax
  00225	72 06		 jb	 SHORT $LN37@ucs1lib_rs@3
$LN124@ucs1lib_rs@3:
  00227	48 2b de	 sub	 rbx, rsi
  0022a	4c 2b c6	 sub	 r8, rsi
$LN37@ucs1lib_rs@3:
  0022d	49 ff c8	 dec	 r8
  00230	48 ff cb	 dec	 rbx
  00233	79 91		 jns	 SHORT $LL38@ucs1lib_rs@3
  00235	e9 d8 fe ff ff	 jmp	 $LN111@ucs1lib_rs@3
$LN120@ucs1lib_rs@3:

; 312  :         j = pos;

  0023a	48 8b 7c 24 30	 mov	 rdi, QWORD PTR j$1$[rsp]
  0023f	4c 8b a4 24 98
	00 00 00	 mov	 r12, QWORD PTR sep$[rsp]
  00247	4c 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]
  0024f	4c 8b 74 24 38	 mov	 r14, QWORD PTR maxcount$1$[rsp]
$LN103@ucs1lib_rs@3:

; 309  :         if (pos < 0)

  00254	48 85 db	 test	 rbx, rbx
  00257	0f 88 b5 fe ff
	ff		 js	 $LN111@ucs1lib_rs@3

; 310  :             break;
; 311  :         SPLIT_ADD(str, pos + sep_len, j);

  0025d	48 2b fb	 sub	 rdi, rbx
  00260	48 8d 0c 2b	 lea	 rcx, QWORD PTR [rbx+rbp]
  00264	48 2b fe	 sub	 rdi, rsi
  00267	48 03 ce	 add	 rcx, rsi
  0026a	48 8b d7	 mov	 rdx, rdi
  0026d	e8 00 00 00 00	 call	 _PyUnicode_FromUCS1
  00272	48 8b f8	 mov	 rdi, rax
  00275	48 85 c0	 test	 rax, rax
  00278	74 45		 je	 SHORT $onError$122161
  0027a	49 83 ff 0c	 cmp	 r15, 12
  0027e	7d 0a		 jge	 SHORT $LN12@ucs1lib_rs@3
  00280	49 8b 4d 70	 mov	 rcx, QWORD PTR [r13+112]
  00284	4a 89 04 f9	 mov	 QWORD PTR [rcx+r15*8], rax
  00288	eb 17		 jmp	 SHORT $LN9@ucs1lib_rs@3
$LN12@ucs1lib_rs@3:
  0028a	48 8b d0	 mov	 rdx, rax
  0028d	49 8b cd	 mov	 rcx, r13
  00290	e8 00 00 00 00	 call	 PyList_Append
  00295	48 8b cf	 mov	 rcx, rdi
  00298	85 c0		 test	 eax, eax
  0029a	75 1e		 jne	 SHORT $LN106@ucs1lib_rs@3
  0029c	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@ucs1lib_rs@3:
  002a1	49 ff c7	 inc	 r15

; 312  :         j = pos;

  002a4	48 8b fb	 mov	 rdi, rbx
  002a7	48 89 5c 24 30	 mov	 QWORD PTR j$1$[rsp], rbx
  002ac	4d 85 f6	 test	 r14, r14
  002af	0f 8f 1b fe ff
	ff		 jg	 $LL16@ucs1lib_rs@3

; 324  :     }
; 325  :     FIX_PREALLOC_SIZE(list);
; 326  :     if (PyList_Reverse(list) < 0)

  002b5	e9 58 fe ff ff	 jmp	 $LN111@ucs1lib_rs@3
$LN106@ucs1lib_rs@3:

; 310  :             break;
; 311  :         SPLIT_ADD(str, pos + sep_len, j);

  002ba	e8 00 00 00 00	 call	 _Py_DecRef
$onError$122161:

; 329  : 
; 330  :   onError:
; 331  :     Py_DECREF(list);

  002bf	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR list$1$[rsp]
  002c7	e8 00 00 00 00	 call	 _Py_DecRef
$LN123@ucs1lib_rs@3:

; 332  :     return NULL;

  002cc	33 c0		 xor	 eax, eax
$LN122@ucs1lib_rs@3:
  002ce	4c 8b ac 24 88
	00 00 00	 mov	 r13, QWORD PTR [rsp+136]
  002d6	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]

; 333  : }

  002db	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002df	41 5f		 pop	 r15
  002e1	41 5c		 pop	 r12
  002e3	5f		 pop	 rdi
  002e4	5e		 pop	 rsi
  002e5	5d		 pop	 rbp
  002e6	5b		 pop	 rbx
  002e7	c3		 ret	 0
$LN8@ucs1lib_rs@3:

; 321  : #endif
; 322  :     {
; 323  :         SPLIT_ADD(str, 0, j);

  002e8	48 8b 54 24 30	 mov	 rdx, QWORD PTR j$1$[rsp]
  002ed	48 8b cd	 mov	 rcx, rbp
  002f0	e8 00 00 00 00	 call	 _PyUnicode_FromUCS1
  002f5	48 8b d8	 mov	 rbx, rax
  002f8	48 85 c0	 test	 rax, rax
  002fb	74 c2		 je	 SHORT $onError$122161
  002fd	4c 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]
  00305	49 83 ff 0c	 cmp	 r15, 12
  00309	7d 0a		 jge	 SHORT $LN5@ucs1lib_rs@3
  0030b	49 8b 4d 70	 mov	 rcx, QWORD PTR [r13+112]
  0030f	4a 89 04 f9	 mov	 QWORD PTR [rcx+r15*8], rax
  00313	eb 17		 jmp	 SHORT $LN2@ucs1lib_rs@3
$LN5@ucs1lib_rs@3:
  00315	48 8b d0	 mov	 rdx, rax
  00318	49 8b cd	 mov	 rcx, r13
  0031b	e8 00 00 00 00	 call	 PyList_Append
  00320	48 8b cb	 mov	 rcx, rbx
  00323	85 c0		 test	 eax, eax
  00325	75 93		 jne	 SHORT $LN106@ucs1lib_rs@3
  00327	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@ucs1lib_rs@3:
  0032c	49 ff c7	 inc	 r15
$LN7@ucs1lib_rs@3:

; 324  :     }
; 325  :     FIX_PREALLOC_SIZE(list);
; 326  :     if (PyList_Reverse(list) < 0)

  0032f	49 8b cd	 mov	 rcx, r13
  00332	4d 89 7d 60	 mov	 QWORD PTR [r13+96], r15
  00336	e8 00 00 00 00	 call	 PyList_Reverse
  0033b	85 c0		 test	 eax, eax
  0033d	78 80		 js	 SHORT $onError$122161

; 327  :         goto onError;
; 328  :     return list;

  0033f	49 8b c5	 mov	 rax, r13
  00342	eb 8a		 jmp	 SHORT $LN122@ucs1lib_rs@3
ucs1lib_rsplit ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ucs1lib_splitlines DD imagerel ucs1lib_splitlines
	DD	imagerel ucs1lib_splitlines+53
	DD	imagerel $unwind$ucs1lib_splitlines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ucs1lib_splitlines DD imagerel ucs1lib_splitlines+53
	DD	imagerel ucs1lib_splitlines+414
	DD	imagerel $chain$2$ucs1lib_splitlines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ucs1lib_splitlines DD imagerel ucs1lib_splitlines+414
	DD	imagerel ucs1lib_splitlines+451
	DD	imagerel $chain$4$ucs1lib_splitlines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ucs1lib_splitlines DD 060021H
	DD	0ef400H
	DD	0d7400H
	DD	0c3400H
	DD	imagerel ucs1lib_splitlines
	DD	imagerel ucs1lib_splitlines+53
	DD	imagerel $unwind$ucs1lib_splitlines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ucs1lib_splitlines DD 061121H
	DD	0ef411H
	DD	0d740aH
	DD	0c3405H
	DD	imagerel ucs1lib_splitlines
	DD	imagerel ucs1lib_splitlines+53
	DD	imagerel $unwind$ucs1lib_splitlines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs1lib_splitlines DD 060d01H
	DD	0e009520dH
	DD	0c005d007H
	DD	050026003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs1lib_splitlines
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
keepends$ = 120
ucs1lib_splitlines PROC					; COMDAT

; 339  : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000d	4c 8b e9	 mov	 r13, rcx

; 340  :     /* This does not use the preallocated list because splitlines is
; 341  :        usually run with hundreds of newlines.  The overhead of
; 342  :        switching between PyList_SET_ITEM and append causes about a
; 343  :        2-3% slowdown for that common case.  A smarter implementation
; 344  :        could move the if check out, so the SET_ITEMs are done first
; 345  :        and the appends only done when the prealloc buffer is full.
; 346  :        That's too much work for little gain.*/
; 347  : 
; 348  :     register Py_ssize_t i;
; 349  :     register Py_ssize_t j;
; 350  :     PyObject *list = PyList_New(0);

  00010	33 c9		 xor	 ecx, ecx
  00012	45 8b f1	 mov	 r14d, r9d
  00015	49 8b f0	 mov	 rsi, r8
  00018	48 8b ea	 mov	 rbp, rdx
  0001b	e8 00 00 00 00	 call	 PyList_New
  00020	4c 8b e0	 mov	 r12, rax

; 351  :     PyObject *sub;
; 352  : 
; 353  :     if (list == NULL)

  00023	48 85 c0	 test	 rax, rax
  00026	75 0d		 jne	 SHORT $LN14@ucs1lib_sp@4

; 389  : }

  00028	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002c	41 5e		 pop	 r14
  0002e	41 5d		 pop	 r13
  00030	41 5c		 pop	 r12
  00032	5e		 pop	 rsi
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
$LN14@ucs1lib_sp@4:
  00035	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  0003a	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi

; 354  :         return NULL;
; 355  : 
; 356  :     for (i = j = 0; i < str_len; ) {

  0003f	33 ff		 xor	 edi, edi
  00041	4c 89 7c 24 70	 mov	 QWORD PTR [rsp+112], r15
  00046	8b df		 mov	 ebx, edi
  00048	48 85 f6	 test	 rsi, rsi
  0004b	0f 8e 2e 01 00
	00		 jle	 $LN12@ucs1lib_sp@4
  00051	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:ascii_linebreak
$LN48@ucs1lib_sp@4:
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyUnicode_Type

; 357  :         Py_ssize_t eol;
; 358  : 
; 359  :         /* Find a line and append it */
; 360  :         while (i < str_len && !STRINGLIB_ISLINEBREAK(str[i]))

  0005f	48 3b de	 cmp	 rbx, rsi
  00062	7d 3d		 jge	 SHORT $LN40@ucs1lib_sp@4
$LL11@ucs1lib_sp@4:
  00064	0f b6 04 2b	 movzx	 eax, BYTE PTR [rbx+rbp]
  00068	3c 80		 cmp	 al, 128			; 00000080H
  0006a	73 0a		 jae	 SHORT $LN19@ucs1lib_sp@4
  0006c	0f b6 c0	 movzx	 eax, al
  0006f	42 0f b6 04 38	 movzx	 eax, BYTE PTR [rax+r15]
  00074	eb 18		 jmp	 SHORT $LN47@ucs1lib_sp@4
$LN19@ucs1lib_sp@4:
  00076	0f b6 c8	 movzx	 ecx, al
  00079	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR bloom_linebreak
  0007f	8b d1		 mov	 edx, ecx
  00081	83 e2 1f	 and	 edx, 31
  00084	0f a3 d0	 bt	 eax, edx
  00087	73 09		 jae	 SHORT $LN39@ucs1lib_sp@4
  00089	e8 00 00 00 00	 call	 _PyUnicode_IsLinebreak
$LN47@ucs1lib_sp@4:
  0008e	85 c0		 test	 eax, eax
  00090	75 08		 jne	 SHORT $LN42@ucs1lib_sp@4
$LN39@ucs1lib_sp@4:

; 361  :             i++;

  00092	48 ff c3	 inc	 rbx
  00095	48 3b de	 cmp	 rbx, rsi
  00098	7c ca		 jl	 SHORT $LL11@ucs1lib_sp@4
$LN42@ucs1lib_sp@4:
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyUnicode_Type
$LN40@ucs1lib_sp@4:

; 362  : 
; 363  :         /* Skip the line break reading CRLF as one line break */
; 364  :         eol = i;

  000a1	48 8b d3	 mov	 rdx, rbx

; 365  :         if (i < str_len) {

  000a4	48 3b de	 cmp	 rbx, rsi
  000a7	7d 26		 jge	 SHORT $LN6@ucs1lib_sp@4

; 366  :             if (str[i] == '\r' && i + 1 < str_len && str[i+1] == '\n')

  000a9	80 3c 2b 0d	 cmp	 BYTE PTR [rbx+rbp], 13
  000ad	75 16		 jne	 SHORT $LN8@ucs1lib_sp@4
  000af	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
  000b3	48 3b c6	 cmp	 rax, rsi
  000b6	7d 0d		 jge	 SHORT $LN8@ucs1lib_sp@4
  000b8	80 7c 2b 01 0a	 cmp	 BYTE PTR [rbx+rbp+1], 10
  000bd	75 06		 jne	 SHORT $LN8@ucs1lib_sp@4

; 367  :                 i += 2;

  000bf	48 83 c3 02	 add	 rbx, 2

; 368  :             else

  000c3	eb 03		 jmp	 SHORT $LN7@ucs1lib_sp@4
$LN8@ucs1lib_sp@4:

; 369  :                 i++;

  000c5	48 ff c3	 inc	 rbx
$LN7@ucs1lib_sp@4:

; 370  :             if (keepends)

  000c8	45 85 f6	 test	 r14d, r14d
  000cb	48 0f 45 d3	 cmovne	 rdx, rbx
$LN6@ucs1lib_sp@4:

; 371  :                 eol = i;
; 372  :         }
; 373  : #ifndef STRINGLIB_MUTABLE
; 374  :         if (j == 0 && eol == str_len && STRINGLIB_CHECK_EXACT(str_obj)) {

  000cf	48 85 ff	 test	 rdi, rdi
  000d2	75 0f		 jne	 SHORT $LN5@ucs1lib_sp@4
  000d4	48 3b d6	 cmp	 rdx, rsi
  000d7	75 0a		 jne	 SHORT $LN5@ucs1lib_sp@4
  000d9	49 39 4d 58	 cmp	 QWORD PTR [r13+88], rcx
  000dd	0f 84 bb 00 00
	00		 je	 $LN34@ucs1lib_sp@4
$LN5@ucs1lib_sp@4:

; 379  :         }
; 380  : #endif
; 381  :         SPLIT_APPEND(str, j, eol);

  000e3	48 8d 0c 2f	 lea	 rcx, QWORD PTR [rdi+rbp]
  000e7	48 2b d7	 sub	 rdx, rdi
  000ea	e8 00 00 00 00	 call	 _PyUnicode_FromUCS1
  000ef	48 8b f8	 mov	 rdi, rax
  000f2	48 85 c0	 test	 rax, rax
  000f5	0f 84 bc 00 00
	00		 je	 $onError$122219
  000fb	48 8b d0	 mov	 rdx, rax
  000fe	49 8b cc	 mov	 rcx, r12
  00101	e8 00 00 00 00	 call	 PyList_Append
  00106	85 c0		 test	 eax, eax
  00108	0f 85 a1 00 00
	00		 jne	 $LN36@ucs1lib_sp@4
  0010e	e8 00 00 00 00	 call	 _Py_PXCTX
  00113	85 c0		 test	 eax, eax
  00115	75 5c		 jne	 SHORT $LN31@ucs1lib_sp@4
  00117	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0011b	a8 20		 test	 al, 32			; 00000020H
  0011d	75 4c		 jne	 SHORT $LN25@ucs1lib_sp@4
  0011f	84 c0		 test	 al, al
  00121	78 48		 js	 SHORT $LN25@ucs1lib_sp@4
  00123	a8 02		 test	 al, 2
  00125	75 4c		 jne	 SHORT $LN31@ucs1lib_sp@4
  00127	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0012b	75 46		 jne	 SHORT $LN31@ucs1lib_sp@4
  0012d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0013b	4c 8b cf	 mov	 r9, rdi
  0013e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00144	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0014c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00151	48 8b cf	 mov	 rcx, rdi
  00154	85 c0		 test	 eax, eax
  00156	74 07		 je	 SHORT $LN30@ucs1lib_sp@4
  00158	e8 00 00 00 00	 call	 _Px_Dealloc
  0015d	eb 14		 jmp	 SHORT $LN31@ucs1lib_sp@4
$LN30@ucs1lib_sp@4:
  0015f	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00163	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00169	eb 08		 jmp	 SHORT $LN31@ucs1lib_sp@4
$LN25@ucs1lib_sp@4:
  0016b	48 8b cf	 mov	 rcx, rdi
  0016e	e8 00 00 00 00	 call	 Px_DecRef
$LN31@ucs1lib_sp@4:

; 382  :         j = i;

  00173	48 8b fb	 mov	 rdi, rbx
  00176	48 3b de	 cmp	 rbx, rsi
  00179	0f 8c d9 fe ff
	ff		 jl	 $LN48@ucs1lib_sp@4
$LN12@ucs1lib_sp@4:

; 383  :     }
; 384  :     return list;

  0017f	49 8b c4	 mov	 rax, r12
$LN45@ucs1lib_sp@4:
  00182	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00187	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0018c	4c 8b 7c 24 70	 mov	 r15, QWORD PTR [rsp+112]

; 389  : }

  00191	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00195	41 5e		 pop	 r14
  00197	41 5d		 pop	 r13
  00199	41 5c		 pop	 r12
  0019b	5e		 pop	 rsi
  0019c	5d		 pop	 rbp
  0019d	c3		 ret	 0
$LN34@ucs1lib_sp@4:

; 375  :             /* No linebreak in str_obj, so just use it as list[0] */
; 376  :             if (PyList_Append(list, str_obj))

  0019e	49 8b d5	 mov	 rdx, r13
  001a1	49 8b cc	 mov	 rcx, r12
  001a4	e8 00 00 00 00	 call	 PyList_Append
  001a9	85 c0		 test	 eax, eax
  001ab	75 0a		 jne	 SHORT $onError$122219

; 377  :                 goto onError;
; 378  :             break;

  001ad	eb d0		 jmp	 SHORT $LN12@ucs1lib_sp@4
$LN36@ucs1lib_sp@4:

; 379  :         }
; 380  : #endif
; 381  :         SPLIT_APPEND(str, j, eol);

  001af	48 8b cf	 mov	 rcx, rdi
  001b2	e8 00 00 00 00	 call	 _Py_DecRef
$onError$122219:

; 385  : 
; 386  :   onError:
; 387  :     Py_DECREF(list);

  001b7	49 8b cc	 mov	 rcx, r12
  001ba	e8 00 00 00 00	 call	 _Py_DecRef

; 388  :     return NULL;

  001bf	33 c0		 xor	 eax, eax
  001c1	eb bf		 jmp	 SHORT $LN45@ucs1lib_sp@4
ucs1lib_splitlines ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs2lib_partition DD imagerel ucs2lib_partition
	DD	imagerel ucs2lib_partition+81
	DD	imagerel $unwind$ucs2lib_partition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ucs2lib_partition DD imagerel ucs2lib_partition+81
	DD	imagerel ucs2lib_partition+116
	DD	imagerel $chain$0$ucs2lib_partition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$ucs2lib_partition DD imagerel ucs2lib_partition+116
	DD	imagerel ucs2lib_partition+407
	DD	imagerel $chain$5$ucs2lib_partition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$ucs2lib_partition DD imagerel ucs2lib_partition+407
	DD	imagerel ucs2lib_partition+832
	DD	imagerel $chain$7$ucs2lib_partition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$ucs2lib_partition DD 080021H
	DD	08e400H
	DD	097400H
	DD	0a5400H
	DD	0113400H
	DD	imagerel ucs2lib_partition
	DD	imagerel ucs2lib_partition+81
	DD	imagerel $unwind$ucs2lib_partition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$ucs2lib_partition DD 081221H
	DD	097412H
	DD	0a540dH
	DD	0113408H
	DD	08e400H
	DD	imagerel ucs2lib_partition
	DD	imagerel ucs2lib_partition+81
	DD	imagerel $unwind$ucs2lib_partition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ucs2lib_partition DD 020521H
	DD	08e405H
	DD	imagerel ucs2lib_partition
	DD	imagerel ucs2lib_partition+81
	DD	imagerel $unwind$ucs2lib_partition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_partition DD 051501H
	DD	0f011a215H
	DD	0c00dd00fH
	DD	0600bH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\partition.h
xdata	ENDS
;	COMDAT ucs2lib_partition
_TEXT	SEGMENT
skip$1$ = 32
w$1$ = 48
str_obj$ = 128
str$ = 136
str_len$ = 144
sep_obj$ = 152
sep$ = 160
tv827 = 168
sep_len$ = 168
ucs2lib_partition PROC					; COMDAT

; 12   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 57		 push	 r15
  00011	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 13   :     PyObject* out;
; 14   :     Py_ssize_t pos;
; 15   : 
; 16   :     if (sep_len == 0) {

  00015	4c 8b a4 24 a8
	00 00 00	 mov	 r12, QWORD PTR sep_len$[rsp]
  0001d	49 8b f1	 mov	 rsi, r9
  00020	4d 8b e8	 mov	 r13, r8
  00023	4c 8b fa	 mov	 r15, rdx
  00026	4d 85 e4	 test	 r12, r12
  00029	75 21		 jne	 SHORT $LN4@ucs2lib_pa

; 17   :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00039	e8 00 00 00 00	 call	 PyErr_SetString

; 18   :         return NULL;

  0003e	33 c0		 xor	 eax, eax

; 52   :     }
; 53   : 
; 54   :     return out;
; 55   : }

  00040	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00044	41 5f		 pop	 r15
  00046	41 5d		 pop	 r13
  00048	41 5c		 pop	 r12
  0004a	5e		 pop	 rsi
  0004b	c3		 ret	 0
$LN4@ucs2lib_pa:

; 19   :     }
; 20   : 
; 21   :     out = PyTuple_New(3);

  0004c	b9 03 00 00 00	 mov	 ecx, 3
  00051	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  00056	e8 00 00 00 00	 call	 PyTuple_New
  0005b	4c 8b f0	 mov	 r14, rax

; 22   :     if (!out)

  0005e	48 85 c0	 test	 rax, rax
  00061	75 11		 jne	 SHORT $LN3@ucs2lib_pa
  00063	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]

; 52   :     }
; 53   : 
; 54   :     return out;
; 55   : }

  00068	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0006c	41 5f		 pop	 r15
  0006e	41 5d		 pop	 r13
  00070	41 5c		 pop	 r12
  00072	5e		 pop	 rsi
  00073	c3		 ret	 0
$LN3@ucs2lib_pa:
  00074	48 89 9c 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbx
  0007c	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00081	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 23   :         return NULL;
; 24   : 
; 25   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_SEARCH);

  00086	49 8b fd	 mov	 rdi, r13
  00089	49 2b fc	 sub	 rdi, r12
  0008c	48 89 7c 24 30	 mov	 QWORD PTR w$1$[rsp], rdi
  00091	0f 88 9c 00 00
	00		 js	 $LN96@ucs2lib_pa
  00097	49 83 fc 01	 cmp	 r12, 1
  0009b	0f 8f f6 00 00
	00		 jg	 $LN66@ucs2lib_pa
  000a1	4d 85 e4	 test	 r12, r12
  000a4	0f 8e 89 00 00
	00		 jle	 $LN96@ucs2lib_pa
  000aa	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  000b2	49 83 fd 0a	 cmp	 r13, 10
  000b6	7e 5e		 jle	 SHORT $LN63@ucs2lib_pa
  000b8	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000bb	84 c9		 test	 cl, cl
  000bd	74 57		 je	 SHORT $LN63@ucs2lib_pa
  000bf	0f b7 30	 movzx	 esi, WORD PTR [rax]
  000c2	4b 8d 3c 6f	 lea	 rdi, QWORD PTR [r15+r13*2]
  000c6	49 8b df	 mov	 rbx, r15
  000c9	4c 3b ff	 cmp	 r15, rdi
  000cc	73 34		 jae	 SHORT $LN75@ucs2lib_pa
  000ce	0f b6 e9	 movzx	 ebp, cl
$LL76@ucs2lib_pa:
  000d1	4c 8b c7	 mov	 r8, rdi
  000d4	8b d5		 mov	 edx, ebp
  000d6	48 8b cb	 mov	 rcx, rbx
  000d9	4c 2b c3	 sub	 r8, rbx
  000dc	49 d1 f8	 sar	 r8, 1
  000df	4d 03 c0	 add	 r8, r8
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000e8	48 8b d8	 mov	 rbx, rax
  000eb	48 85 c0	 test	 rax, rax
  000ee	74 12		 je	 SHORT $LN75@ucs2lib_pa
  000f0	48 83 e3 fe	 and	 rbx, -2
  000f4	66 39 33	 cmp	 WORD PTR [rbx], si
  000f7	74 12		 je	 SHORT $LN86@ucs2lib_pa
  000f9	48 83 c3 02	 add	 rbx, 2
  000fd	48 3b df	 cmp	 rbx, rdi
  00100	72 cf		 jb	 SHORT $LL76@ucs2lib_pa
$LN75@ucs2lib_pa:
  00102	48 83 cb ff	 or	 rbx, -1
  00106	e9 d3 01 00 00	 jmp	 $LN71@ucs2lib_pa
$LN86@ucs2lib_pa:
  0010b	49 2b df	 sub	 rbx, r15
  0010e	48 d1 fb	 sar	 rbx, 1
  00111	e9 c8 01 00 00	 jmp	 $LN71@ucs2lib_pa
$LN63@ucs2lib_pa:
  00116	33 db		 xor	 ebx, ebx
  00118	4d 85 ed	 test	 r13, r13
  0011b	7e 16		 jle	 SHORT $LN96@ucs2lib_pa
  0011d	0f b7 00	 movzx	 eax, WORD PTR [rax]
$LL54@ucs2lib_pa:
  00120	66 41 39 04 5f	 cmp	 WORD PTR [r15+rbx*2], ax
  00125	0f 84 bb 01 00
	00		 je	 $LN69@ucs2lib_pa
  0012b	48 ff c3	 inc	 rbx
  0012e	49 3b dd	 cmp	 rbx, r13
  00131	7c ed		 jl	 SHORT $LL54@ucs2lib_pa
$LN96@ucs2lib_pa:

; 28   : #if STRINGLIB_MUTABLE
; 29   :         PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, str_len));
; 30   :         PyTuple_SET_ITEM(out, 1, STRINGLIB_NEW(NULL, 0));
; 31   :         PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(NULL, 0));
; 32   : #else
; 33   :         Py_INCREF(str_obj);

  00133	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR str_obj$[rsp]
  0013b	48 8b cb	 mov	 rcx, rbx
  0013e	e8 00 00 00 00	 call	 _Py_IncRef

; 34   :         PyTuple_SET_ITEM(out, 0, (PyObject*) str_obj);
; 35   :         Py_INCREF(STRINGLIB_EMPTY);

  00143	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  0014a	49 89 5e 70	 mov	 QWORD PTR [r14+112], rbx
  0014e	e8 00 00 00 00	 call	 _Py_IncRef

; 36   :         PyTuple_SET_ITEM(out, 1, (PyObject*) STRINGLIB_EMPTY);

  00153	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  0015a	49 89 4e 78	 mov	 QWORD PTR [r14+120], rcx

; 37   :         Py_INCREF(STRINGLIB_EMPTY);

  0015e	e8 00 00 00 00	 call	 _Py_IncRef

; 38   :         PyTuple_SET_ITEM(out, 2, (PyObject*) STRINGLIB_EMPTY);

  00163	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR unicode_empty
  0016a	4d 89 9e 80 00
	00 00		 mov	 QWORD PTR [r14+128], r11
$LN1@ucs2lib_pa:

; 39   : #endif
; 40   :         return out;

  00171	49 8b c6	 mov	 rax, r14
$LN101@ucs2lib_pa:
  00174	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00179	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0017e	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR [rsp+136]
  00186	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]

; 52   :     }
; 53   : 
; 54   :     return out;
; 55   : }

  0018b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0018f	41 5f		 pop	 r15
  00191	41 5d		 pop	 r13
  00193	41 5c		 pop	 r12
  00195	5e		 pop	 rsi
  00196	c3		 ret	 0

; 23   :         return NULL;
; 24   : 
; 25   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_SEARCH);

$LN66@ucs2lib_pa:
  00197	33 db		 xor	 ebx, ebx
  00199	49 8d 74 24 ff	 lea	 rsi, QWORD PTR [r12-1]
  0019e	48 8d 56 ff	 lea	 rdx, QWORD PTR [rsi-1]
  001a2	8b eb		 mov	 ebp, ebx
  001a4	44 8b d3	 mov	 r10d, ebx
  001a7	44 8d 4b 01	 lea	 r9d, QWORD PTR [rbx+1]
  001ab	48 89 54 24 20	 mov	 QWORD PTR skip$1$[rsp], rdx
  001b0	48 85 f6	 test	 rsi, rsi
  001b3	7e 55		 jle	 SHORT $LN42@ucs2lib_pa
  001b5	4c 8b b4 24 a0
	00 00 00	 mov	 r14, QWORD PTR sep$[rsp]
  001bd	4c 8d 66 ff	 lea	 r12, QWORD PTR [rsi-1]
  001c1	41 0f b7 3c 76	 movzx	 edi, WORD PTR [r14+rsi*2]
  001c6	4d 8b dc	 mov	 r11, r12
  001c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL44@ucs2lib_pa:
  001d0	47 0f b7 04 56	 movzx	 r8d, WORD PTR [r14+r10*2]
  001d5	41 8b d1	 mov	 edx, r9d
  001d8	41 8b c8	 mov	 ecx, r8d
  001db	83 e1 1f	 and	 ecx, 31
  001de	d3 e2		 shl	 edx, cl
  001e0	0b ea		 or	 ebp, edx
  001e2	66 44 3b c7	 cmp	 r8w, di
  001e6	4d 0f 44 e3	 cmove	 r12, r11
  001ea	49 ff c2	 inc	 r10
  001ed	49 ff cb	 dec	 r11
  001f0	4c 3b d6	 cmp	 r10, rsi
  001f3	7c db		 jl	 SHORT $LL44@ucs2lib_pa
  001f5	48 8b 7c 24 30	 mov	 rdi, QWORD PTR w$1$[rsp]
  001fa	4c 89 64 24 20	 mov	 QWORD PTR skip$1$[rsp], r12
  001ff	4c 8b a4 24 a8
	00 00 00	 mov	 r12, QWORD PTR sep_len$[rsp]
  00207	4c 8b f0	 mov	 r14, rax
$LN42@ucs2lib_pa:
  0020a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  00212	4c 8b d3	 mov	 r10, rbx
  00215	0f b7 0c 70	 movzx	 ecx, WORD PTR [rax+rsi*2]
  00219	83 e1 1f	 and	 ecx, 31
  0021c	41 d3 e1	 shl	 r9d, cl
  0021f	41 0b e9	 or	 ebp, r9d
  00222	48 85 ff	 test	 rdi, rdi
  00225	0f 88 08 ff ff
	ff		 js	 $LN96@ucs2lib_pa
  0022b	4f 8d 1c 24	 lea	 r11, QWORD PTR [r12+r12]
  0022f	4d 8b c7	 mov	 r8, r15
  00232	41 0f b7 4c 03
	fe		 movzx	 ecx, WORD PTR [r11+rax-2]
  00238	4f 8d 0c 3b	 lea	 r9, QWORD PTR [r11+r15]
  0023c	4c 2b c0	 sub	 r8, rax
  0023f	66 89 8c 24 a8
	00 00 00	 mov	 WORD PTR tv827[rsp], cx
$LL40@ucs2lib_pa:
  00247	66 41 39 49 fe	 cmp	 WORD PTR [r9-2], cx
  0024c	75 4d		 jne	 SHORT $LN37@ucs2lib_pa
  0024e	48 8b d3	 mov	 rdx, rbx
  00251	48 85 f6	 test	 rsi, rsi
  00254	7e 20		 jle	 SHORT $LN97@ucs2lib_pa
  00256	48 8b c8	 mov	 rcx, rax
  00259	0f 1f 80 00 00
	00 00		 npad	 7
$LL36@ucs2lib_pa:
  00260	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00263	66 41 39 04 08	 cmp	 WORD PTR [r8+rcx], ax
  00268	75 0c		 jne	 SHORT $LN97@ucs2lib_pa
  0026a	48 ff c2	 inc	 rdx
  0026d	48 83 c1 02	 add	 rcx, 2
  00271	48 3b d6	 cmp	 rdx, rsi
  00274	7c ea		 jl	 SHORT $LL36@ucs2lib_pa
$LN97@ucs2lib_pa:
  00276	48 3b d6	 cmp	 rdx, rsi
  00279	74 60		 je	 SHORT $LN89@ucs2lib_pa
  0027b	41 0f b7 01	 movzx	 eax, WORD PTR [r9]
  0027f	83 e0 1f	 and	 eax, 31
  00282	0f a3 c5	 bt	 ebp, eax
  00285	8b c8		 mov	 ecx, eax
  00287	73 20		 jae	 SHORT $LN102@ucs2lib_pa
  00289	48 8b 54 24 20	 mov	 rdx, QWORD PTR skip$1$[rsp]
  0028e	4c 03 d2	 add	 r10, rdx
  00291	4d 8d 04 50	 lea	 r8, QWORD PTR [r8+rdx*2]
  00295	4d 8d 0c 51	 lea	 r9, QWORD PTR [r9+rdx*2]
  00299	eb 17		 jmp	 SHORT $LN39@ucs2lib_pa
$LN37@ucs2lib_pa:
  0029b	41 0f b7 01	 movzx	 eax, WORD PTR [r9]
  0029f	83 e0 1f	 and	 eax, 31
  002a2	0f a3 c5	 bt	 ebp, eax
  002a5	8b c8		 mov	 ecx, eax
  002a7	72 09		 jb	 SHORT $LN39@ucs2lib_pa
$LN102@ucs2lib_pa:
  002a9	4d 03 d4	 add	 r10, r12
  002ac	4d 03 c3	 add	 r8, r11
  002af	4d 03 cb	 add	 r9, r11
$LN39@ucs2lib_pa:
  002b2	49 ff c2	 inc	 r10
  002b5	49 83 c0 02	 add	 r8, 2
  002b9	49 83 c1 02	 add	 r9, 2
  002bd	4c 3b d7	 cmp	 r10, rdi
  002c0	0f 8f 6d fe ff
	ff		 jg	 $LN96@ucs2lib_pa
  002c6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  002ce	0f b7 8c 24 a8
	00 00 00	 movzx	 ecx, WORD PTR tv827[rsp]
  002d6	e9 6c ff ff ff	 jmp	 $LL40@ucs2lib_pa
$LN89@ucs2lib_pa:
  002db	49 8b da	 mov	 rbx, r10
$LN71@ucs2lib_pa:
  002de	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR sep_obj$[rsp]
$LN69@ucs2lib_pa:

; 26   : 
; 27   :     if (pos < 0) {

  002e6	48 85 db	 test	 rbx, rbx
  002e9	0f 88 44 fe ff
	ff		 js	 $LN96@ucs2lib_pa

; 41   :     }
; 42   : 
; 43   :     PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, pos));

  002ef	48 8b d3	 mov	 rdx, rbx
  002f2	49 8b cf	 mov	 rcx, r15
  002f5	e8 00 00 00 00	 call	 _PyUnicode_FromUCS2

; 44   :     Py_INCREF(sep_obj);

  002fa	48 8b ce	 mov	 rcx, rsi
  002fd	49 89 46 70	 mov	 QWORD PTR [r14+112], rax
  00301	e8 00 00 00 00	 call	 _Py_IncRef

; 45   :     PyTuple_SET_ITEM(out, 1, sep_obj);
; 46   :     pos += sep_len;

  00306	49 03 dc	 add	 rbx, r12

; 47   :     PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str + pos, str_len - pos));

  00309	4c 2b eb	 sub	 r13, rbx
  0030c	49 8d 0c 5f	 lea	 rcx, QWORD PTR [r15+rbx*2]
  00310	49 89 76 78	 mov	 QWORD PTR [r14+120], rsi
  00314	49 8b d5	 mov	 rdx, r13
  00317	e8 00 00 00 00	 call	 _PyUnicode_FromUCS2
  0031c	49 89 86 80 00
	00 00		 mov	 QWORD PTR [r14+128], rax

; 48   : 
; 49   :     if (PyErr_Occurred()) {

  00323	e8 00 00 00 00	 call	 PyErr_Occurred
  00328	48 85 c0	 test	 rax, rax
  0032b	0f 84 40 fe ff
	ff		 je	 $LN1@ucs2lib_pa

; 50   :         Py_DECREF(out);

  00331	49 8b ce	 mov	 rcx, r14
  00334	e8 00 00 00 00	 call	 _Py_DecRef

; 51   :         return NULL;

  00339	33 c0		 xor	 eax, eax
  0033b	e9 34 fe ff ff	 jmp	 $LN101@ucs2lib_pa
ucs2lib_partition ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs2lib_rpartition DD imagerel ucs2lib_rpartition
	DD	imagerel ucs2lib_rpartition+84
	DD	imagerel $unwind$ucs2lib_rpartition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ucs2lib_rpartition DD imagerel ucs2lib_rpartition+84
	DD	imagerel ucs2lib_rpartition+118
	DD	imagerel $chain$0$ucs2lib_rpartition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$ucs2lib_rpartition DD imagerel ucs2lib_rpartition+118
	DD	imagerel ucs2lib_rpartition+290
	DD	imagerel $chain$5$ucs2lib_rpartition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$ucs2lib_rpartition DD imagerel ucs2lib_rpartition+290
	DD	imagerel ucs2lib_rpartition+613
	DD	imagerel $chain$7$ucs2lib_rpartition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$ucs2lib_rpartition DD 080021H
	DD	04f400H
	DD	05e400H
	DD	065400H
	DD	0d3400H
	DD	imagerel ucs2lib_rpartition
	DD	imagerel ucs2lib_rpartition+84
	DD	imagerel $unwind$ucs2lib_rpartition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$ucs2lib_rpartition DD 081521H
	DD	04f415H
	DD	05e40dH
	DD	0d3405H
	DD	065400H
	DD	imagerel ucs2lib_rpartition
	DD	imagerel ucs2lib_rpartition+84
	DD	imagerel $unwind$ucs2lib_rpartition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ucs2lib_rpartition DD 020521H
	DD	065405H
	DD	imagerel ucs2lib_rpartition
	DD	imagerel ucs2lib_rpartition+84
	DD	imagerel $unwind$ucs2lib_rpartition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_rpartition DD 051901H
	DD	0d0156219H
	DD	07011c013H
	DD	06010H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\partition.h
xdata	ENDS
;	COMDAT ucs2lib_rpartition
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
sep_obj$ = 120
sep$ = 128
sep_len$ = 136
ucs2lib_rpartition PROC					; COMDAT

; 62   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	41 54		 push	 r12
  00013	41 55		 push	 r13
  00015	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 63   :     PyObject* out;
; 64   :     Py_ssize_t pos;
; 65   : 
; 66   :     if (sep_len == 0) {

  00019	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR sep_len$[rsp]
  00021	4d 8b e9	 mov	 r13, r9
  00024	4d 8b e0	 mov	 r12, r8
  00027	48 8b f2	 mov	 rsi, rdx
  0002a	48 85 ff	 test	 rdi, rdi
  0002d	75 20		 jne	 SHORT $LN4@ucs2lib_rp

; 67   :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0002f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  0003d	e8 00 00 00 00	 call	 PyErr_SetString

; 68   :         return NULL;

  00042	33 c0		 xor	 eax, eax

; 102  :     }
; 103  : 
; 104  :     return out;
; 105  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	41 5d		 pop	 r13
  0004a	41 5c		 pop	 r12
  0004c	5f		 pop	 rdi
  0004d	5e		 pop	 rsi
  0004e	c3		 ret	 0
$LN4@ucs2lib_rp:

; 69   :     }
; 70   : 
; 71   :     out = PyTuple_New(3);

  0004f	b9 03 00 00 00	 mov	 ecx, 3
  00054	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00059	e8 00 00 00 00	 call	 PyTuple_New
  0005e	48 8b e8	 mov	 rbp, rax

; 72   :     if (!out)

  00061	48 85 c0	 test	 rax, rax
  00064	75 10		 jne	 SHORT $LN3@ucs2lib_rp
  00066	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 102  :     }
; 103  : 
; 104  :     return out;
; 105  : }

  0006b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006f	41 5d		 pop	 r13
  00071	41 5c		 pop	 r12
  00073	5f		 pop	 rdi
  00074	5e		 pop	 rsi
  00075	c3		 ret	 0
$LN3@ucs2lib_rp:
  00076	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx

; 73   :         return NULL;
; 74   : 
; 75   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_RSEARCH);

  0007b	49 8b dc	 mov	 rbx, r12
  0007e	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00083	48 2b df	 sub	 rbx, rdi
  00086	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  0008b	78 38		 js	 SHORT $LN92@ucs2lib_rp
  0008d	48 83 ff 01	 cmp	 rdi, 1
  00091	0f 8f 8b 00 00
	00		 jg	 $LN66@ucs2lib_rp
  00097	48 85 ff	 test	 rdi, rdi
  0009a	7e 29		 jle	 SHORT $LN92@ucs2lib_rp
  0009c	49 8d 5c 24 ff	 lea	 rbx, QWORD PTR [r12-1]
  000a1	48 83 fb ff	 cmp	 rbx, -1
  000a5	7e 1e		 jle	 SHORT $LN92@ucs2lib_rp
  000a7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  000af	0f b7 08	 movzx	 ecx, WORD PTR [rax]
$LL49@ucs2lib_rp:
  000b2	66 39 0c 5e	 cmp	 WORD PTR [rsi+rbx*2], cx
  000b6	0f 84 4e 01 00
	00		 je	 $LN69@ucs2lib_rp
  000bc	48 ff cb	 dec	 rbx
  000bf	48 83 fb ff	 cmp	 rbx, -1
  000c3	7f ed		 jg	 SHORT $LL49@ucs2lib_rp
$LN92@ucs2lib_rp:

; 78   : #if STRINGLIB_MUTABLE
; 79   :         PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(NULL, 0));
; 80   :         PyTuple_SET_ITEM(out, 1, STRINGLIB_NEW(NULL, 0));
; 81   :         PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str, str_len));
; 82   : #else
; 83   :         Py_INCREF(STRINGLIB_EMPTY);

  000c5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  000cc	e8 00 00 00 00	 call	 _Py_IncRef

; 84   :         PyTuple_SET_ITEM(out, 0, (PyObject*) STRINGLIB_EMPTY);

  000d1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  000d8	48 89 4d 70	 mov	 QWORD PTR [rbp+112], rcx

; 85   :         Py_INCREF(STRINGLIB_EMPTY);

  000dc	e8 00 00 00 00	 call	 _Py_IncRef

; 86   :         PyTuple_SET_ITEM(out, 1, (PyObject*) STRINGLIB_EMPTY);

  000e1	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR unicode_empty

; 87   :         Py_INCREF(str_obj);

  000e8	48 8b 5c 24 60	 mov	 rbx, QWORD PTR str_obj$[rsp]
  000ed	4c 89 5d 78	 mov	 QWORD PTR [rbp+120], r11
  000f1	48 8b cb	 mov	 rcx, rbx
  000f4	e8 00 00 00 00	 call	 _Py_IncRef

; 88   :         PyTuple_SET_ITEM(out, 2, (PyObject*) str_obj);

  000f9	48 89 9d 80 00
	00 00		 mov	 QWORD PTR [rbp+128], rbx
$LN1@ucs2lib_rp:

; 89   : #endif
; 90   :         return out;

  00100	48 8b c5	 mov	 rax, rbp
$LN98@ucs2lib_rp:
  00103	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]
  00108	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  0010d	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  00112	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 102  :     }
; 103  : 
; 104  :     return out;
; 105  : }

  00117	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011b	41 5d		 pop	 r13
  0011d	41 5c		 pop	 r12
  0011f	5f		 pop	 rdi
  00120	5e		 pop	 rsi
  00121	c3		 ret	 0

; 73   :         return NULL;
; 74   : 
; 75   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_RSEARCH);

$LN66@ucs2lib_rp:
  00122	4c 8b bc 24 80
	00 00 00	 mov	 r15, QWORD PTR sep$[rsp]
  0012a	4c 8d 5f ff	 lea	 r11, QWORD PTR [rdi-1]
  0012e	41 bc 01 00 00
	00		 mov	 r12d, 1
  00134	45 0f b7 37	 movzx	 r14d, WORD PTR [r15]
  00138	4d 8d 53 ff	 lea	 r10, QWORD PTR [r11-1]
  0013c	4d 8b cb	 mov	 r9, r11
  0013f	41 8b ce	 mov	 ecx, r14d
  00142	83 e1 1f	 and	 ecx, 31
  00145	41 d3 e4	 shl	 r12d, cl
  00148	4d 85 db	 test	 r11, r11
  0014b	7e 2a		 jle	 SHORT $LN22@ucs2lib_rp
  0014d	0f 1f 00	 npad	 3
$LL24@ucs2lib_rp:
  00150	47 0f b7 04 4f	 movzx	 r8d, WORD PTR [r15+r9*2]
  00155	ba 01 00 00 00	 mov	 edx, 1
  0015a	41 8b c8	 mov	 ecx, r8d
  0015d	83 e1 1f	 and	 ecx, 31
  00160	d3 e2		 shl	 edx, cl
  00162	44 0b e2	 or	 r12d, edx
  00165	66 45 3b c6	 cmp	 r8w, r14w
  00169	75 04		 jne	 SHORT $LN23@ucs2lib_rp
  0016b	4d 8d 51 ff	 lea	 r10, QWORD PTR [r9-1]
$LN23@ucs2lib_rp:
  0016f	49 ff c9	 dec	 r9
  00172	4d 85 c9	 test	 r9, r9
  00175	7f d9		 jg	 SHORT $LL24@ucs2lib_rp
$LN22@ucs2lib_rp:
  00177	4c 8d 04 1b	 lea	 r8, QWORD PTR [rbx+rbx]
  0017b	4c 8d 0c 3f	 lea	 r9, QWORD PTR [rdi+rdi]
  0017f	4f 8d 2c 12	 lea	 r13, QWORD PTR [r10+r10]
  00183	4d 2b c7	 sub	 r8, r15
  00186	4c 03 c6	 add	 r8, rsi
  00189	0f 1f 80 00 00
	00 00		 npad	 7
$LL20@ucs2lib_rp:
  00190	66 44 39 34 5e	 cmp	 WORD PTR [rsi+rbx*2], r14w
  00195	75 42		 jne	 SHORT $LN17@ucs2lib_rp
  00197	49 8b d3	 mov	 rdx, r11
  0019a	4d 85 db	 test	 r11, r11
  0019d	7e 1a		 jle	 SHORT $LN93@ucs2lib_rp
  0019f	4b 8d 0c 5f	 lea	 rcx, QWORD PTR [r15+r11*2]
$LL16@ucs2lib_rp:
  001a3	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  001a6	66 41 39 04 08	 cmp	 WORD PTR [r8+rcx], ax
  001ab	75 0c		 jne	 SHORT $LN93@ucs2lib_rp
  001ad	48 ff ca	 dec	 rdx
  001b0	48 83 e9 02	 sub	 rcx, 2
  001b4	48 85 d2	 test	 rdx, rdx
  001b7	7f ea		 jg	 SHORT $LL16@ucs2lib_rp
$LN93@ucs2lib_rp:
  001b9	48 85 d2	 test	 rdx, rdx
  001bc	74 42		 je	 SHORT $LN94@ucs2lib_rp
  001be	48 85 db	 test	 rbx, rbx
  001c1	7e 0e		 jle	 SHORT $LN11@ucs2lib_rp
  001c3	0f b7 44 5e fe	 movzx	 eax, WORD PTR [rsi+rbx*2-2]
  001c8	83 e0 1f	 and	 eax, 31
  001cb	41 0f a3 c4	 bt	 r12d, eax
  001cf	73 1b		 jae	 SHORT $LN99@ucs2lib_rp
$LN11@ucs2lib_rp:
  001d1	49 2b da	 sub	 rbx, r10
  001d4	4d 2b c5	 sub	 r8, r13
  001d7	eb 19		 jmp	 SHORT $LN19@ucs2lib_rp
$LN17@ucs2lib_rp:
  001d9	48 85 db	 test	 rbx, rbx
  001dc	7e 14		 jle	 SHORT $LN19@ucs2lib_rp
  001de	0f b7 44 5e fe	 movzx	 eax, WORD PTR [rsi+rbx*2-2]
  001e3	83 e0 1f	 and	 eax, 31
  001e6	41 0f a3 c4	 bt	 r12d, eax
  001ea	72 06		 jb	 SHORT $LN19@ucs2lib_rp
$LN99@ucs2lib_rp:
  001ec	48 2b df	 sub	 rbx, rdi
  001ef	4d 2b c1	 sub	 r8, r9
$LN19@ucs2lib_rp:
  001f2	49 83 e8 02	 sub	 r8, 2
  001f6	48 ff cb	 dec	 rbx
  001f9	79 95		 jns	 SHORT $LL20@ucs2lib_rp
  001fb	e9 c5 fe ff ff	 jmp	 $LN92@ucs2lib_rp
$LN94@ucs2lib_rp:

; 62   : {

  00200	4c 8b 64 24 70	 mov	 r12, QWORD PTR str_len$[rsp]
  00205	4c 8b 6c 24 78	 mov	 r13, QWORD PTR sep_obj$[rsp]

; 73   :         return NULL;
; 74   : 
; 75   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_RSEARCH);

$LN69@ucs2lib_rp:

; 76   : 
; 77   :     if (pos < 0) {

  0020a	48 85 db	 test	 rbx, rbx
  0020d	0f 88 b2 fe ff
	ff		 js	 $LN92@ucs2lib_rp

; 91   :     }
; 92   : 
; 93   :     PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, pos));

  00213	48 8b d3	 mov	 rdx, rbx
  00216	48 8b ce	 mov	 rcx, rsi
  00219	e8 00 00 00 00	 call	 _PyUnicode_FromUCS2

; 94   :     Py_INCREF(sep_obj);

  0021e	49 8b cd	 mov	 rcx, r13
  00221	48 89 45 70	 mov	 QWORD PTR [rbp+112], rax
  00225	e8 00 00 00 00	 call	 _Py_IncRef

; 95   :     PyTuple_SET_ITEM(out, 1, sep_obj);
; 96   :     pos += sep_len;

  0022a	48 8d 04 3b	 lea	 rax, QWORD PTR [rbx+rdi]

; 97   :     PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str + pos, str_len - pos));

  0022e	4c 2b e0	 sub	 r12, rax
  00231	48 8d 0c 46	 lea	 rcx, QWORD PTR [rsi+rax*2]
  00235	4c 89 6d 78	 mov	 QWORD PTR [rbp+120], r13
  00239	49 8b d4	 mov	 rdx, r12
  0023c	e8 00 00 00 00	 call	 _PyUnicode_FromUCS2
  00241	48 89 85 80 00
	00 00		 mov	 QWORD PTR [rbp+128], rax

; 98   : 
; 99   :     if (PyErr_Occurred()) {

  00248	e8 00 00 00 00	 call	 PyErr_Occurred
  0024d	48 85 c0	 test	 rax, rax
  00250	0f 84 aa fe ff
	ff		 je	 $LN1@ucs2lib_rp

; 100  :         Py_DECREF(out);

  00256	48 8b cd	 mov	 rcx, rbp
  00259	e8 00 00 00 00	 call	 _Py_DecRef

; 101  :         return NULL;

  0025e	33 c0		 xor	 eax, eax
  00260	e9 9e fe ff ff	 jmp	 $LN98@ucs2lib_rp
ucs2lib_rpartition ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ucs2lib_split_whitespace DD imagerel ucs2lib_split_whitespace
	DD	imagerel ucs2lib_split_whitespace+685
	DD	imagerel $unwind$ucs2lib_split_whitespace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_split_whitespace DD 0c6601H
	DD	0d7466H
	DD	0c3455H
	DD	0e5412H
	DD	0f00e5212H
	DD	0d00ae00cH
	DD	06006c008H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs2lib_split_whitespace
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
maxcount$ = 120
ucs2lib_split_whitespace PROC				; COMDAT

; 57   : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	41 56		 push	 r14
  0000c	41 57		 push	 r15
  0000e	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 58   :     Py_ssize_t i, j, count=0;

  00012	45 33 e4	 xor	 r12d, r12d
  00015	4c 8b f9	 mov	 r15, rcx
  00018	4d 8b e9	 mov	 r13, r9
  0001b	49 8b f0	 mov	 rsi, r8
  0001e	48 8b ea	 mov	 rbp, rdx

; 59   :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00021	41 8d 4c 24 0c	 lea	 ecx, QWORD PTR [r12+12]
  00026	49 83 f9 0c	 cmp	 r9, 12
  0002a	7d 04		 jge	 SHORT $LN27@ucs2lib_sp
  0002c	49 8d 49 01	 lea	 rcx, QWORD PTR [r9+1]
$LN27@ucs2lib_sp:
  00030	e8 00 00 00 00	 call	 PyList_New
  00035	4c 8b f0	 mov	 r14, rax

; 60   :     PyObject *sub;
; 61   : 
; 62   :     if (list == NULL)

  00038	48 85 c0	 test	 rax, rax
  0003b	75 13		 jne	 SHORT $LN23@ucs2lib_sp

; 99   : }

  0003d	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00042	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00046	41 5f		 pop	 r15
  00048	41 5e		 pop	 r14
  0004a	41 5d		 pop	 r13
  0004c	41 5c		 pop	 r12
  0004e	5e		 pop	 rsi
  0004f	c3		 ret	 0
$LN23@ucs2lib_sp:
  00050	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx

; 63   :         return NULL;
; 64   : 
; 65   :     i = j = 0;
; 66   :     while (maxcount-- > 0) {

  00055	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
  00061	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  00066	49 8b dc	 mov	 rbx, r12
  00069	4d 85 ed	 test	 r13, r13
  0006c	0f 8e 7b 01 00
	00		 jle	 $LN55@ucs2lib_sp
$LL22@ucs2lib_sp:
  00072	49 ff cd	 dec	 r13

; 67   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  00075	48 3b de	 cmp	 rbx, rsi
  00078	7d 3c		 jge	 SHORT $LN65@ucs2lib_sp
  0007a	66 0f 1f 44 00
	00		 npad	 6
$LL20@ucs2lib_sp:
  00080	0f b7 44 5d 00	 movzx	 eax, WORD PTR [rbp+rbx*2]
  00085	66 3b c1	 cmp	 ax, cx
  00088	73 09		 jae	 SHORT $LN28@ucs2lib_sp
  0008a	0f b7 c0	 movzx	 eax, ax
  0008d	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  00091	eb 14		 jmp	 SHORT $LN29@ucs2lib_sp
$LN28@ucs2lib_sp:
  00093	0f b7 c8	 movzx	 ecx, ax
  00096	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  0009b	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
$LN29@ucs2lib_sp:
  000a7	85 c0		 test	 eax, eax
  000a9	74 08		 je	 SHORT $LN61@ucs2lib_sp

; 68   :             i++;

  000ab	48 ff c3	 inc	 rbx
  000ae	48 3b de	 cmp	 rbx, rsi
  000b1	7c cd		 jl	 SHORT $LL20@ucs2lib_sp
$LN61@ucs2lib_sp:

; 69   :         if (i == str_len) break;

  000b3	48 3b de	 cmp	 rbx, rsi
$LN65@ucs2lib_sp:
  000b6	0f 84 31 01 00
	00		 je	 $LN55@ucs2lib_sp

; 70   :         j = i; i++;

  000bc	48 8b fb	 mov	 rdi, rbx
  000bf	48 ff c3	 inc	 rbx

; 71   :         while (i < str_len && !STRINGLIB_ISSPACE(str[i]))

  000c2	48 3b de	 cmp	 rbx, rsi
  000c5	7d 3c		 jge	 SHORT $LN62@ucs2lib_sp
  000c7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL17@ucs2lib_sp:
  000d0	0f b7 44 5d 00	 movzx	 eax, WORD PTR [rbp+rbx*2]
  000d5	66 3b c1	 cmp	 ax, cx
  000d8	73 09		 jae	 SHORT $LN30@ucs2lib_sp
  000da	0f b7 c0	 movzx	 eax, ax
  000dd	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  000e1	eb 14		 jmp	 SHORT $LN31@ucs2lib_sp
$LN30@ucs2lib_sp:
  000e3	0f b7 c8	 movzx	 ecx, ax
  000e6	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  000eb	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  000f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
$LN31@ucs2lib_sp:
  000f7	85 c0		 test	 eax, eax
  000f9	75 08		 jne	 SHORT $LN62@ucs2lib_sp

; 72   :             i++;

  000fb	48 ff c3	 inc	 rbx
  000fe	48 3b de	 cmp	 rbx, rsi
  00101	7c cd		 jl	 SHORT $LL17@ucs2lib_sp
$LN62@ucs2lib_sp:

; 73   : #ifndef STRINGLIB_MUTABLE
; 74   :         if (j == 0 && i == str_len && STRINGLIB_CHECK_EXACT(str_obj)) {

  00103	48 85 ff	 test	 rdi, rdi
  00106	75 16		 jne	 SHORT $LN15@ucs2lib_sp
  00108	48 3b de	 cmp	 rbx, rsi
  0010b	75 11		 jne	 SHORT $LN15@ucs2lib_sp
  0010d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00114	49 39 47 58	 cmp	 QWORD PTR [r15+88], rax
  00118	0f 84 bd 00 00
	00		 je	 $LN50@ucs2lib_sp
$LN15@ucs2lib_sp:

; 79   :             break;
; 80   :         }
; 81   : #endif
; 82   :         SPLIT_ADD(str, j, i);

  0011e	48 8b d3	 mov	 rdx, rbx
  00121	48 8d 4c 7d 00	 lea	 rcx, QWORD PTR [rbp+rdi*2]
  00126	48 2b d7	 sub	 rdx, rdi
  00129	e8 00 00 00 00	 call	 _PyUnicode_FromUCS2
  0012e	48 8b f8	 mov	 rdi, rax
  00131	48 85 c0	 test	 rax, rax
  00134	0f 84 e4 00 00
	00		 je	 $onError$122710
  0013a	49 83 fc 0c	 cmp	 r12, 12
  0013e	7d 0a		 jge	 SHORT $LN13@ucs2lib_sp
  00140	49 8b 4e 70	 mov	 rcx, QWORD PTR [r14+112]
  00144	4a 89 04 e1	 mov	 QWORD PTR [rcx+r12*8], rax
  00148	eb 78		 jmp	 SHORT $LN44@ucs2lib_sp
$LN13@ucs2lib_sp:
  0014a	48 8b d0	 mov	 rdx, rax
  0014d	49 8b ce	 mov	 rcx, r14
  00150	e8 00 00 00 00	 call	 PyList_Append
  00155	85 c0		 test	 eax, eax
  00157	0f 85 b9 00 00
	00		 jne	 $LN52@ucs2lib_sp
  0015d	e8 00 00 00 00	 call	 _Py_PXCTX
  00162	85 c0		 test	 eax, eax
  00164	75 5c		 jne	 SHORT $LN44@ucs2lib_sp
  00166	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0016a	a8 20		 test	 al, 32			; 00000020H
  0016c	75 4c		 jne	 SHORT $LN38@ucs2lib_sp
  0016e	84 c0		 test	 al, al
  00170	78 48		 js	 SHORT $LN38@ucs2lib_sp
  00172	a8 02		 test	 al, 2
  00174	75 4c		 jne	 SHORT $LN44@ucs2lib_sp
  00176	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0017a	75 46		 jne	 SHORT $LN44@ucs2lib_sp
  0017c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00183	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0018a	4c 8b cf	 mov	 r9, rdi
  0018d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00193	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0019b	e8 00 00 00 00	 call	 _PyParallel_Guard
  001a0	48 8b cf	 mov	 rcx, rdi
  001a3	85 c0		 test	 eax, eax
  001a5	74 07		 je	 SHORT $LN43@ucs2lib_sp
  001a7	e8 00 00 00 00	 call	 _Px_Dealloc
  001ac	eb 14		 jmp	 SHORT $LN44@ucs2lib_sp
$LN43@ucs2lib_sp:
  001ae	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001b2	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001b8	eb 08		 jmp	 SHORT $LN44@ucs2lib_sp
$LN38@ucs2lib_sp:
  001ba	48 8b cf	 mov	 rcx, rdi
  001bd	e8 00 00 00 00	 call	 Px_DecRef
$LN44@ucs2lib_sp:
  001c2	49 ff c4	 inc	 r12
  001c5	4d 85 ed	 test	 r13, r13
  001c8	7e 23		 jle	 SHORT $LN55@ucs2lib_sp

; 63   :         return NULL;
; 64   : 
; 65   :     i = j = 0;
; 66   :     while (maxcount-- > 0) {

  001ca	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  001cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
  001d6	e9 97 fe ff ff	 jmp	 $LL22@ucs2lib_sp
$LN50@ucs2lib_sp:

; 75   :             /* No whitespace in str_obj, so just use it as list[0] */
; 76   :             Py_INCREF(str_obj);

  001db	49 8b cf	 mov	 rcx, r15
  001de	e8 00 00 00 00	 call	 _Py_IncRef

; 77   :             PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  001e3	4d 8b 5e 70	 mov	 r11, QWORD PTR [r14+112]

; 78   :             count++;

  001e7	49 ff c4	 inc	 r12
  001ea	4d 89 3b	 mov	 QWORD PTR [r11], r15
$LN55@ucs2lib_sp:

; 83   :     }
; 84   : 
; 85   :     if (i < str_len) {

  001ed	48 3b de	 cmp	 rbx, rsi
  001f0	0f 8d 93 00 00
	00		 jge	 $LN6@ucs2lib_sp
  001f6	bf 80 00 00 00	 mov	 edi, 128		; 00000080H
  001fb	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_ascii_whitespace
$LL8@ucs2lib_sp:

; 86   :         /* Only occurs when maxcount was reached */
; 87   :         /* Skip any remaining whitespace and copy to end of string */
; 88   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  00202	0f b7 44 5d 00	 movzx	 eax, WORD PTR [rbp+rbx*2]
  00207	66 3b c7	 cmp	 ax, di
  0020a	73 1e		 jae	 SHORT $LN32@ucs2lib_sp
  0020c	0f b7 c0	 movzx	 eax, ax
  0020f	42 0f b6 04 28	 movzx	 eax, BYTE PTR [rax+r13]
  00214	eb 1c		 jmp	 SHORT $LN33@ucs2lib_sp
$LN52@ucs2lib_sp:

; 79   :             break;
; 80   :         }
; 81   : #endif
; 82   :         SPLIT_ADD(str, j, i);

  00216	48 8b cf	 mov	 rcx, rdi
$LN66@ucs2lib_sp:
  00219	e8 00 00 00 00	 call	 _Py_DecRef
$onError$122710:

; 95   : 
; 96   :   onError:
; 97   :     Py_DECREF(list);

  0021e	49 8b ce	 mov	 rcx, r14
  00221	e8 00 00 00 00	 call	 _Py_DecRef

; 98   :     return NULL;

  00226	33 c0		 xor	 eax, eax
  00228	eb 66		 jmp	 SHORT $LN64@ucs2lib_sp
$LN32@ucs2lib_sp:

; 86   :         /* Only occurs when maxcount was reached */
; 87   :         /* Skip any remaining whitespace and copy to end of string */
; 88   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  0022a	0f b7 c8	 movzx	 ecx, ax
  0022d	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
$LN33@ucs2lib_sp:
  00232	85 c0		 test	 eax, eax
  00234	74 08		 je	 SHORT $LN7@ucs2lib_sp

; 89   :             i++;

  00236	48 ff c3	 inc	 rbx
  00239	48 3b de	 cmp	 rbx, rsi
  0023c	7c c4		 jl	 SHORT $LL8@ucs2lib_sp
$LN7@ucs2lib_sp:

; 90   :         if (i != str_len)

  0023e	48 3b de	 cmp	 rbx, rsi
  00241	74 46		 je	 SHORT $LN6@ucs2lib_sp

; 91   :             SPLIT_ADD(str, i, str_len);

  00243	48 2b f3	 sub	 rsi, rbx
  00246	48 8d 4c 5d 00	 lea	 rcx, QWORD PTR [rbp+rbx*2]
  0024b	48 8b d6	 mov	 rdx, rsi
  0024e	e8 00 00 00 00	 call	 _PyUnicode_FromUCS2
  00253	48 8b d8	 mov	 rbx, rax
  00256	48 85 c0	 test	 rax, rax
  00259	74 c3		 je	 SHORT $onError$122710
  0025b	49 83 fc 0c	 cmp	 r12, 12
  0025f	7d 0e		 jge	 SHORT $LN4@ucs2lib_sp
  00261	49 8b 4e 70	 mov	 rcx, QWORD PTR [r14+112]
  00265	49 ff c4	 inc	 r12
  00268	4a 89 44 e1 f8	 mov	 QWORD PTR [rcx+r12*8-8], rax
  0026d	eb 1a		 jmp	 SHORT $LN6@ucs2lib_sp
$LN4@ucs2lib_sp:
  0026f	48 8b d0	 mov	 rdx, rax
  00272	49 8b ce	 mov	 rcx, r14
  00275	e8 00 00 00 00	 call	 PyList_Append
  0027a	48 8b cb	 mov	 rcx, rbx
  0027d	85 c0		 test	 eax, eax
  0027f	75 98		 jne	 SHORT $LN66@ucs2lib_sp
  00281	e8 00 00 00 00	 call	 _Py_DecRef
  00286	49 ff c4	 inc	 r12
$LN6@ucs2lib_sp:

; 92   :     }
; 93   :     FIX_PREALLOC_SIZE(list);

  00289	4d 89 66 60	 mov	 QWORD PTR [r14+96], r12

; 94   :     return list;

  0028d	49 8b c6	 mov	 rax, r14
$LN64@ucs2lib_sp:

; 99   : }

  00290	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00295	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  0029a	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  0029f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002a3	41 5f		 pop	 r15
  002a5	41 5e		 pop	 r14
  002a7	41 5d		 pop	 r13
  002a9	41 5c		 pop	 r12
  002ab	5e		 pop	 rsi
  002ac	c3		 ret	 0
ucs2lib_split_whitespace ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ucs2lib_split_char DD imagerel ucs2lib_split_char
	DD	imagerel ucs2lib_split_char+81
	DD	imagerel $unwind$ucs2lib_split_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ucs2lib_split_char DD imagerel ucs2lib_split_char+81
	DD	imagerel ucs2lib_split_char+334
	DD	imagerel $chain$0$ucs2lib_split_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ucs2lib_split_char DD imagerel ucs2lib_split_char+334
	DD	imagerel ucs2lib_split_char+358
	DD	imagerel $chain$1$ucs2lib_split_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ucs2lib_split_char DD imagerel ucs2lib_split_char+358
	DD	imagerel ucs2lib_split_char+561
	DD	imagerel $chain$2$ucs2lib_split_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ucs2lib_split_char DD 020021H
	DD	0d3400H
	DD	imagerel ucs2lib_split_char
	DD	imagerel ucs2lib_split_char+81
	DD	imagerel $unwind$ucs2lib_split_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ucs2lib_split_char DD 021H
	DD	imagerel ucs2lib_split_char
	DD	imagerel ucs2lib_split_char+81
	DD	imagerel $unwind$ucs2lib_split_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ucs2lib_split_char DD 020521H
	DD	0d3405H
	DD	imagerel ucs2lib_split_char
	DD	imagerel ucs2lib_split_char+81
	DD	imagerel $unwind$ucs2lib_split_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_split_char DD 0a1c01H
	DD	0f641cH
	DD	0e541cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs2lib_split_char
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
ch$ = 120
maxcount$ = 128
ucs2lib_split_char PROC					; COMDAT

; 106  : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 107  :     Py_ssize_t i, j, count=0;
; 108  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  0001c	4c 8b bc 24 80
	00 00 00	 mov	 r15, QWORD PTR maxcount$[rsp]
  00024	33 f6		 xor	 esi, esi
  00026	4c 8b e1	 mov	 r12, rcx
  00029	45 0f b7 f1	 movzx	 r14d, r9w
  0002d	49 8b f8	 mov	 rdi, r8
  00030	4c 8b ea	 mov	 r13, rdx
  00033	8d 4e 0c	 lea	 ecx, QWORD PTR [rsi+12]
  00036	49 83 ff 0c	 cmp	 r15, 12
  0003a	7d 04		 jge	 SHORT $LN24@ucs2lib_sp@2
  0003c	49 8d 4f 01	 lea	 rcx, QWORD PTR [r15+1]
$LN24@ucs2lib_sp@2:
  00040	e8 00 00 00 00	 call	 PyList_New
  00045	48 8b e8	 mov	 rbp, rax

; 109  :     PyObject *sub;
; 110  : 
; 111  :     if (list == NULL)

  00048	48 85 c0	 test	 rax, rax
  0004b	0f 84 fd 00 00
	00		 je	 $LN21@ucs2lib_sp@2
$LN20@ucs2lib_sp@2:
  00051	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx

; 112  :         return NULL;
; 113  : 
; 114  :     i = j = 0;

  00056	48 8b ce	 mov	 rcx, rsi
  00059	48 8b de	 mov	 rbx, rsi

; 115  :     while ((j < str_len) && (maxcount-- > 0)) {

  0005c	48 85 ff	 test	 rdi, rdi
  0005f	0f 8e 85 00 00
	00		 jle	 $LN48@ucs2lib_sp@2
$LL19@ucs2lib_sp@2:
  00065	49 8b c7	 mov	 rax, r15
  00068	49 ff cf	 dec	 r15
  0006b	48 85 c0	 test	 rax, rax
  0006e	7e 6c		 jle	 SHORT $LN18@ucs2lib_sp@2

; 116  :         for(; j < str_len; j++) {

  00070	48 3b df	 cmp	 rbx, rdi
  00073	7d 67		 jge	 SHORT $LN18@ucs2lib_sp@2
$LL17@ucs2lib_sp@2:

; 117  :             /* I found that using memchr makes no difference */
; 118  :             if (str[j] == ch) {

  00075	66 45 39 74 5d
	00		 cmp	 WORD PTR [r13+rbx*2], r14w
  0007b	74 0a		 je	 SHORT $LN42@ucs2lib_sp@2

; 116  :         for(; j < str_len; j++) {

  0007d	48 ff c3	 inc	 rbx
  00080	48 3b df	 cmp	 rbx, rdi
  00083	7c f0		 jl	 SHORT $LL17@ucs2lib_sp@2
  00085	eb 55		 jmp	 SHORT $LN18@ucs2lib_sp@2
$LN42@ucs2lib_sp@2:

; 119  :                 SPLIT_ADD(str, i, j);

  00087	48 8b d3	 mov	 rdx, rbx
  0008a	48 2b d1	 sub	 rdx, rcx
  0008d	49 8d 4c 4d 00	 lea	 rcx, QWORD PTR [r13+rcx*2]
  00092	e8 00 00 00 00	 call	 _PyUnicode_FromUCS2
  00097	4c 8b e0	 mov	 r12, rax
  0009a	48 85 c0	 test	 rax, rax
  0009d	0f 84 0b 01 00
	00		 je	 $onError$122764
  000a3	48 83 fe 0c	 cmp	 rsi, 12
  000a7	7d 0a		 jge	 SHORT $LN12@ucs2lib_sp@2
  000a9	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  000ad	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  000b1	eb 1b		 jmp	 SHORT $LN9@ucs2lib_sp@2
$LN12@ucs2lib_sp@2:
  000b3	48 8b d0	 mov	 rdx, rax
  000b6	48 8b cd	 mov	 rcx, rbp
  000b9	e8 00 00 00 00	 call	 PyList_Append
  000be	49 8b cc	 mov	 rcx, r12
  000c1	85 c0		 test	 eax, eax
  000c3	0f 85 e0 00 00
	00		 jne	 $LN44@ucs2lib_sp@2
  000c9	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@ucs2lib_sp@2:

; 120  :                 i = j = j + 1;

  000ce	48 ff c3	 inc	 rbx
  000d1	48 ff c6	 inc	 rsi
  000d4	48 8b cb	 mov	 rcx, rbx
  000d7	48 3b df	 cmp	 rbx, rdi
  000da	7c 89		 jl	 SHORT $LL19@ucs2lib_sp@2
$LN18@ucs2lib_sp@2:

; 121  :                 break;
; 122  :             }
; 123  :         }
; 124  :     }
; 125  : #ifndef STRINGLIB_MUTABLE
; 126  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  000dc	48 85 f6	 test	 rsi, rsi
  000df	0f 85 81 00 00
	00		 jne	 $LN8@ucs2lib_sp@2
  000e5	4c 8b 64 24 60	 mov	 r12, QWORD PTR str_obj$[rsp]
$LN48@ucs2lib_sp@2:
  000ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  000f1	49 39 44 24 58	 cmp	 QWORD PTR [r12+88], rax
  000f6	75 6e		 jne	 SHORT $LN8@ucs2lib_sp@2

; 127  :         /* ch not in str_obj, so just use str_obj as list[0] */
; 128  :         Py_INCREF(str_obj);

  000f8	e8 00 00 00 00	 call	 _Py_PXCTX
  000fd	85 c0		 test	 eax, eax
  000ff	75 35		 jne	 SHORT $LN26@ucs2lib_sp@2
  00101	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00108	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0010f	4d 8b cc	 mov	 r9, r12
  00112	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00118	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00120	e8 00 00 00 00	 call	 _PyParallel_Guard
  00125	85 c0		 test	 eax, eax
  00127	75 08		 jne	 SHORT $LN25@ucs2lib_sp@2
  00129	41 f6 44 24 20
	20		 test	 BYTE PTR [r12+32], 32	; 00000020H
  0012f	74 05		 je	 SHORT $LN26@ucs2lib_sp@2
$LN25@ucs2lib_sp@2:
  00131	49 ff 44 24 50	 inc	 QWORD PTR [r12+80]
$LN26@ucs2lib_sp@2:

; 129  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  00136	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]

; 130  :         count++;

  0013a	be 01 00 00 00	 mov	 esi, 1
  0013f	4c 89 20	 mov	 QWORD PTR [rax], r12
$LN6@ucs2lib_sp@2:

; 135  :     }
; 136  :     FIX_PREALLOC_SIZE(list);

  00142	48 89 75 60	 mov	 QWORD PTR [rbp+96], rsi

; 137  :     return list;

  00146	48 8b c5	 mov	 rax, rbp
$LN49@ucs2lib_sp@2:
  00149	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
$LN21@ucs2lib_sp@2:

; 142  : }

  0014e	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00153	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00158	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0015c	41 5f		 pop	 r15
  0015e	41 5e		 pop	 r14
  00160	41 5d		 pop	 r13
  00162	41 5c		 pop	 r12
  00164	5f		 pop	 rdi
  00165	c3		 ret	 0
$LN8@ucs2lib_sp@2:

; 131  :     } else
; 132  : #endif
; 133  :     if (i <= str_len) {

  00166	48 3b cf	 cmp	 rcx, rdi
  00169	7f d7		 jg	 SHORT $LN6@ucs2lib_sp@2

; 134  :         SPLIT_ADD(str, i, str_len);

  0016b	48 2b f9	 sub	 rdi, rcx
  0016e	49 8d 4c 4d 00	 lea	 rcx, QWORD PTR [r13+rcx*2]
  00173	48 8b d7	 mov	 rdx, rdi
  00176	e8 00 00 00 00	 call	 _PyUnicode_FromUCS2
  0017b	48 8b d8	 mov	 rbx, rax
  0017e	48 85 c0	 test	 rax, rax
  00181	74 2b		 je	 SHORT $onError$122764
  00183	48 83 fe 0c	 cmp	 rsi, 12
  00187	7d 0e		 jge	 SHORT $LN4@ucs2lib_sp@2
  00189	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  0018d	48 ff c6	 inc	 rsi
  00190	48 89 44 f1 f8	 mov	 QWORD PTR [rcx+rsi*8-8], rax
  00195	eb ab		 jmp	 SHORT $LN6@ucs2lib_sp@2
$LN4@ucs2lib_sp@2:
  00197	48 8b d0	 mov	 rdx, rax
  0019a	48 8b cd	 mov	 rcx, rbp
  0019d	e8 00 00 00 00	 call	 PyList_Append
  001a2	48 8b cb	 mov	 rcx, rbx
  001a5	85 c0		 test	 eax, eax
  001a7	74 5b		 je	 SHORT $LN2@ucs2lib_sp@2
$LN44@ucs2lib_sp@2:
  001a9	e8 00 00 00 00	 call	 _Py_DecRef
$onError$122764:

; 138  : 
; 139  :   onError:
; 140  :     Py_DECREF(list);

  001ae	e8 00 00 00 00	 call	 _Py_PXCTX
  001b3	85 c0		 test	 eax, eax
  001b5	75 73		 jne	 SHORT $LN39@ucs2lib_sp@2
  001b7	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  001bb	a8 20		 test	 al, 32			; 00000020H
  001bd	75 63		 jne	 SHORT $LN33@ucs2lib_sp@2
  001bf	84 c0		 test	 al, al
  001c1	78 5f		 js	 SHORT $LN33@ucs2lib_sp@2
  001c3	a8 02		 test	 al, 2
  001c5	75 63		 jne	 SHORT $LN39@ucs2lib_sp@2
  001c7	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  001cb	75 5d		 jne	 SHORT $LN39@ucs2lib_sp@2
  001cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001db	4c 8b cd	 mov	 r9, rbp
  001de	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001e4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001ec	e8 00 00 00 00	 call	 _PyParallel_Guard
  001f1	48 8b cd	 mov	 rcx, rbp
  001f4	85 c0		 test	 eax, eax
  001f6	74 19		 je	 SHORT $LN38@ucs2lib_sp@2
  001f8	e8 00 00 00 00	 call	 _Px_Dealloc

; 141  :     return NULL;

  001fd	33 c0		 xor	 eax, eax
  001ff	e9 45 ff ff ff	 jmp	 $LN49@ucs2lib_sp@2
$LN2@ucs2lib_sp@2:

; 134  :         SPLIT_ADD(str, i, str_len);

  00204	e8 00 00 00 00	 call	 _Py_DecRef
  00209	48 ff c6	 inc	 rsi
  0020c	e9 31 ff ff ff	 jmp	 $LN6@ucs2lib_sp@2

; 138  : 
; 139  :   onError:
; 140  :     Py_DECREF(list);

$LN38@ucs2lib_sp@2:
  00211	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  00215	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 141  :     return NULL;

  0021b	33 c0		 xor	 eax, eax
  0021d	e9 27 ff ff ff	 jmp	 $LN49@ucs2lib_sp@2

; 138  : 
; 139  :   onError:
; 140  :     Py_DECREF(list);

$LN33@ucs2lib_sp@2:
  00222	48 8b cd	 mov	 rcx, rbp
  00225	e8 00 00 00 00	 call	 Px_DecRef
$LN39@ucs2lib_sp@2:

; 141  :     return NULL;

  0022a	33 c0		 xor	 eax, eax
  0022c	e9 18 ff ff ff	 jmp	 $LN49@ucs2lib_sp@2
ucs2lib_split_char ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs2lib_split DD imagerel ucs2lib_split
	DD	imagerel ucs2lib_split+137
	DD	imagerel $unwind$ucs2lib_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ucs2lib_split DD imagerel ucs2lib_split+137
	DD	imagerel ucs2lib_split+967
	DD	imagerel $chain$1$ucs2lib_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ucs2lib_split DD imagerel ucs2lib_split+967
	DD	imagerel ucs2lib_split+1082
	DD	imagerel $chain$3$ucs2lib_split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ucs2lib_split DD 040021H
	DD	0ad400H
	DD	0155400H
	DD	imagerel ucs2lib_split
	DD	imagerel ucs2lib_split+137
	DD	imagerel $unwind$ucs2lib_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ucs2lib_split DD 040d21H
	DD	0ad40dH
	DD	0155408H
	DD	imagerel ucs2lib_split
	DD	imagerel ucs2lib_split+137
	DD	imagerel $unwind$ucs2lib_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_split DD 071c01H
	DD	0f018a21cH
	DD	0c014e016H
	DD	060117012H
	DD	03010H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs2lib_split
_TEXT	SEGMENT
count$1$ = 48
list$1$ = 56
i$1$ = 64
maxcount$1$ = 72
str_obj$ = 144
str$ = 152
str_len$ = 160
sep$ = 168
tv886 = 176
sep_len$ = 176
maxcount$ = 184
ucs2lib_split PROC					; COMDAT

; 149  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	53		 push	 rbx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 54		 push	 r12
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 150  :     Py_ssize_t i, j, pos, count=0;
; 151  :     PyObject *list, *sub;
; 152  : 
; 153  :     if (sep_len == 0) {

  0001c	4c 8b b4 24 b0
	00 00 00	 mov	 r14, QWORD PTR sep_len$[rsp]
  00024	33 f6		 xor	 esi, esi
  00026	4d 8b f9	 mov	 r15, r9
  00029	49 8b d8	 mov	 rbx, r8
  0002c	48 8b fa	 mov	 rdi, rdx
  0002f	4c 8b e1	 mov	 r12, rcx
  00032	48 89 74 24 30	 mov	 QWORD PTR count$1$[rsp], rsi
  00037	4d 85 f6	 test	 r14, r14
  0003a	75 23		 jne	 SHORT $LN19@ucs2lib_sp@3

; 154  :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0003c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  0004a	e8 00 00 00 00	 call	 PyErr_SetString

; 155  :         return NULL;

  0004f	33 c0		 xor	 eax, eax

; 190  : }

  00051	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00055	41 5f		 pop	 r15
  00057	41 5e		 pop	 r14
  00059	41 5c		 pop	 r12
  0005b	5f		 pop	 rdi
  0005c	5e		 pop	 rsi
  0005d	5b		 pop	 rbx
  0005e	c3		 ret	 0
$LN19@ucs2lib_sp@3:

; 156  :     }
; 157  :     else if (sep_len == 1)

  0005f	49 83 fe 01	 cmp	 r14, 1
  00063	75 24		 jne	 SHORT $LN17@ucs2lib_sp@3

; 158  :         return STRINGLIB(split_char)(str_obj, str, str_len, sep[0], maxcount);

  00065	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  0006d	45 0f b7 09	 movzx	 r9d, WORD PTR [r9]
  00071	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00076	e8 00 00 00 00	 call	 ucs2lib_split_char

; 190  : }

  0007b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007f	41 5f		 pop	 r15
  00081	41 5e		 pop	 r14
  00083	41 5c		 pop	 r12
  00085	5f		 pop	 rdi
  00086	5e		 pop	 rsi
  00087	5b		 pop	 rbx
  00088	c3		 ret	 0
$LN17@ucs2lib_sp@3:
  00089	48 89 ac 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rbp
  00091	4c 89 6c 24 50	 mov	 QWORD PTR [rsp+80], r13

; 159  : 
; 160  :     list = PyList_New(PREALLOC_SIZE(maxcount));

  00096	4c 8b ac 24 b8
	00 00 00	 mov	 r13, QWORD PTR maxcount$[rsp]
  0009e	b9 0c 00 00 00	 mov	 ecx, 12
  000a3	49 83 fd 0c	 cmp	 r13, 12
  000a7	7d 04		 jge	 SHORT $LN23@ucs2lib_sp@3
  000a9	49 8d 4d 01	 lea	 rcx, QWORD PTR [r13+1]
$LN23@ucs2lib_sp@3:
  000ad	e8 00 00 00 00	 call	 PyList_New
  000b2	48 8b e8	 mov	 rbp, rax
  000b5	48 89 44 24 38	 mov	 QWORD PTR list$1$[rsp], rax

; 161  :     if (list == NULL)

  000ba	48 85 c0	 test	 rax, rax

; 162  :         return NULL;

  000bd	0f 84 e7 02 00
	00		 je	 $LN129@ucs2lib_sp@3

; 163  : 
; 164  :     i = j = 0;

  000c3	45 33 d2	 xor	 r10d, r10d
  000c6	4c 89 54 24 40	 mov	 QWORD PTR i$1$[rsp], r10

; 165  :     while (maxcount-- > 0) {

  000cb	4d 85 ed	 test	 r13, r13
  000ce	0f 8e 04 02 00
	00		 jle	 $LN118@ucs2lib_sp@3
  000d4	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL15@ucs2lib_sp@3:
  000e0	49 ff cd	 dec	 r13

; 166  :         pos = FASTSEARCH(str+i, str_len-i, sep, sep_len, -1, FAST_SEARCH);

  000e3	48 8b cb	 mov	 rcx, rbx
  000e6	4e 8d 04 57	 lea	 r8, QWORD PTR [rdi+r10*2]
  000ea	49 2b ca	 sub	 rcx, r10
  000ed	4c 89 6c 24 48	 mov	 QWORD PTR maxcount$1$[rsp], r13
  000f2	4c 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv886[rsp], r8
  000fa	4c 8b e1	 mov	 r12, rcx
  000fd	4d 2b e6	 sub	 r12, r14
  00100	0f 88 bc 01 00
	00		 js	 $LN116@ucs2lib_sp@3
  00106	49 83 fe 01	 cmp	 r14, 1
  0010a	0f 8f ba 00 00
	00		 jg	 $LN83@ucs2lib_sp@3
  00110	4d 85 f6	 test	 r14, r14
  00113	0f 8e a9 01 00
	00		 jle	 $LN116@ucs2lib_sp@3
  00119	48 83 f9 0a	 cmp	 rcx, 10
  0011d	7e 77		 jle	 SHORT $LN80@ucs2lib_sp@3
  0011f	41 0f b6 07	 movzx	 eax, BYTE PTR [r15]
  00123	84 c0		 test	 al, al
  00125	74 6f		 je	 SHORT $LN80@ucs2lib_sp@3
  00127	41 0f b7 3f	 movzx	 edi, WORD PTR [r15]
  0012b	49 8d 1c 48	 lea	 rbx, QWORD PTR [r8+rcx*2]
  0012f	4d 8b c8	 mov	 r9, r8
  00132	4c 3b c3	 cmp	 r8, rbx
  00135	73 43		 jae	 SHORT $LN92@ucs2lib_sp@3
  00137	0f b6 f0	 movzx	 esi, al
  0013a	66 0f 1f 44 00
	00		 npad	 6
$LL93@ucs2lib_sp@3:
  00140	4c 8b c3	 mov	 r8, rbx
  00143	8b d6		 mov	 edx, esi
  00145	49 8b c9	 mov	 rcx, r9
  00148	4d 2b c1	 sub	 r8, r9
  0014b	49 d1 f8	 sar	 r8, 1
  0014e	4d 03 c0	 add	 r8, r8
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00157	4c 8b c8	 mov	 r9, rax
  0015a	48 85 c0	 test	 rax, rax
  0015d	74 13		 je	 SHORT $LN103@ucs2lib_sp@3
  0015f	49 83 e1 fe	 and	 r9, -2
  00163	66 41 39 39	 cmp	 WORD PTR [r9], di
  00167	74 1a		 je	 SHORT $LN104@ucs2lib_sp@3
  00169	49 83 c1 02	 add	 r9, 2
  0016d	4c 3b cb	 cmp	 r9, rbx
  00170	72 ce		 jb	 SHORT $LL93@ucs2lib_sp@3
$LN103@ucs2lib_sp@3:
  00172	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR tv886[rsp]
$LN92@ucs2lib_sp@3:
  0017a	49 83 c9 ff	 or	 r9, -1
  0017e	e9 99 01 00 00	 jmp	 $LN88@ucs2lib_sp@3
$LN104@ucs2lib_sp@3:
  00183	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR tv886[rsp]
  0018b	4d 2b c8	 sub	 r9, r8
  0018e	49 d1 f9	 sar	 r9, 1
  00191	e9 86 01 00 00	 jmp	 $LN88@ucs2lib_sp@3
$LN80@ucs2lib_sp@3:
  00196	45 33 c9	 xor	 r9d, r9d
  00199	48 85 c9	 test	 rcx, rcx
  0019c	0f 8e 20 01 00
	00		 jle	 $LN116@ucs2lib_sp@3
  001a2	41 0f b7 17	 movzx	 edx, WORD PTR [r15]
  001a6	49 8b c0	 mov	 rax, r8
  001a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL71@ucs2lib_sp@3:
  001b0	66 39 10	 cmp	 WORD PTR [rax], dx
  001b3	0f 84 6d 01 00
	00		 je	 $LN86@ucs2lib_sp@3
  001b9	49 ff c1	 inc	 r9
  001bc	48 83 c0 02	 add	 rax, 2
  001c0	4c 3b c9	 cmp	 r9, rcx
  001c3	7c eb		 jl	 SHORT $LL71@ucs2lib_sp@3
  001c5	e9 f8 00 00 00	 jmp	 $LN116@ucs2lib_sp@3
$LN83@ucs2lib_sp@3:
  001ca	49 8d 5e ff	 lea	 rbx, QWORD PTR [r14-1]
  001ce	33 ff		 xor	 edi, edi
  001d0	45 33 c9	 xor	 r9d, r9d
  001d3	48 8d 73 ff	 lea	 rsi, QWORD PTR [rbx-1]
  001d7	48 85 db	 test	 rbx, rbx
  001da	7e 43		 jle	 SHORT $LN59@ucs2lib_sp@3
  001dc	45 0f b7 1c 5f	 movzx	 r11d, WORD PTR [r15+rbx*2]
  001e1	4c 8b d6	 mov	 r10, rsi
  001e4	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL61@ucs2lib_sp@3:
  001f0	47 0f b7 04 4f	 movzx	 r8d, WORD PTR [r15+r9*2]
  001f5	ba 01 00 00 00	 mov	 edx, 1
  001fa	41 8b c8	 mov	 ecx, r8d
  001fd	83 e1 1f	 and	 ecx, 31
  00200	d3 e2		 shl	 edx, cl
  00202	0b fa		 or	 edi, edx
  00204	66 45 3b c3	 cmp	 r8w, r11w
  00208	49 0f 44 f2	 cmove	 rsi, r10
  0020c	49 ff c1	 inc	 r9
  0020f	49 ff ca	 dec	 r10
  00212	4c 3b cb	 cmp	 r9, rbx
  00215	7c d9		 jl	 SHORT $LL61@ucs2lib_sp@3
  00217	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR tv886[rsp]
$LN59@ucs2lib_sp@3:
  0021f	41 0f b7 0c 5f	 movzx	 ecx, WORD PTR [r15+rbx*2]
  00224	ba 01 00 00 00	 mov	 edx, 1
  00229	45 33 c9	 xor	 r9d, r9d
  0022c	83 e1 1f	 and	 ecx, 31
  0022f	d3 e2		 shl	 edx, cl
  00231	0b fa		 or	 edi, edx
  00233	4d 85 e4	 test	 r12, r12
  00236	0f 88 81 00 00
	00		 js	 $LN126@ucs2lib_sp@3
  0023c	4f 8d 1c 36	 lea	 r11, QWORD PTR [r14+r14]
  00240	48 8d 2c 36	 lea	 rbp, QWORD PTR [rsi+rsi]
  00244	47 0f b7 6c 3b
	fe		 movzx	 r13d, WORD PTR [r11+r15-2]
  0024a	4f 8d 14 03	 lea	 r10, QWORD PTR [r11+r8]
  0024e	4d 2b c7	 sub	 r8, r15
$LL57@ucs2lib_sp@3:
  00251	66 45 39 6a fe	 cmp	 WORD PTR [r10-2], r13w
  00256	75 40		 jne	 SHORT $LN54@ucs2lib_sp@3
  00258	33 d2		 xor	 edx, edx
  0025a	48 85 db	 test	 rbx, rbx
  0025d	7e 19		 jle	 SHORT $LN124@ucs2lib_sp@3
  0025f	49 8b cf	 mov	 rcx, r15
$LL53@ucs2lib_sp@3:
  00262	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00265	66 41 39 04 08	 cmp	 WORD PTR [r8+rcx], ax
  0026a	75 0c		 jne	 SHORT $LN124@ucs2lib_sp@3
  0026c	48 ff c2	 inc	 rdx
  0026f	48 83 c1 02	 add	 rcx, 2
  00273	48 3b d3	 cmp	 rdx, rbx
  00276	7c ea		 jl	 SHORT $LL53@ucs2lib_sp@3
$LN124@ucs2lib_sp@3:
  00278	48 3b d3	 cmp	 rdx, rbx
  0027b	0f 84 89 00 00
	00		 je	 $LN107@ucs2lib_sp@3
  00281	41 0f b7 02	 movzx	 eax, WORD PTR [r10]
  00285	83 e0 1f	 and	 eax, 31
  00288	0f a3 c7	 bt	 edi, eax
  0028b	73 17		 jae	 SHORT $LN130@ucs2lib_sp@3
  0028d	4c 03 ce	 add	 r9, rsi
  00290	4c 03 c5	 add	 r8, rbp
  00293	4c 03 d5	 add	 r10, rbp
  00296	eb 15		 jmp	 SHORT $LN56@ucs2lib_sp@3
$LN54@ucs2lib_sp@3:
  00298	41 0f b7 02	 movzx	 eax, WORD PTR [r10]
  0029c	83 e0 1f	 and	 eax, 31
  0029f	0f a3 c7	 bt	 edi, eax
  002a2	72 09		 jb	 SHORT $LN56@ucs2lib_sp@3
$LN130@ucs2lib_sp@3:
  002a4	4d 03 ce	 add	 r9, r14
  002a7	4d 03 c3	 add	 r8, r11
  002aa	4d 03 d3	 add	 r10, r11
$LN56@ucs2lib_sp@3:
  002ad	49 ff c1	 inc	 r9
  002b0	49 83 c0 02	 add	 r8, 2
  002b4	49 83 c2 02	 add	 r10, 2
  002b8	4d 3b cc	 cmp	 r9, r12
  002bb	7e 94		 jle	 SHORT $LL57@ucs2lib_sp@3
$LN126@ucs2lib_sp@3:

; 170  :         SPLIT_ADD(str, i, j);

  002bd	48 8b 74 24 30	 mov	 rsi, QWORD PTR count$1$[rsp]
$LN116@ucs2lib_sp@3:

; 172  :     }
; 173  : #ifndef STRINGLIB_MUTABLE
; 174  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  002c2	48 85 f6	 test	 rsi, rsi
  002c5	0f 85 fc 00 00
	00		 jne	 $LN7@ucs2lib_sp@3
  002cb	48 8b 6c 24 38	 mov	 rbp, QWORD PTR list$1$[rsp]
  002d0	4c 8b a4 24 90
	00 00 00	 mov	 r12, QWORD PTR str_obj$[rsp]
$LN118@ucs2lib_sp@3:
  002d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  002df	49 39 44 24 58	 cmp	 QWORD PTR [r12+88], rax
  002e4	0f 85 dd 00 00
	00		 jne	 $LN7@ucs2lib_sp@3

; 175  :         /* No match in str_obj, so just use it as list[0] */
; 176  :         Py_INCREF(str_obj);

  002ea	49 8b cc	 mov	 rcx, r12
  002ed	e8 00 00 00 00	 call	 _Py_IncRef

; 177  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  002f2	4c 8b 5d 70	 mov	 r11, QWORD PTR [rbp+112]

; 178  :         count++;

  002f6	be 01 00 00 00	 mov	 esi, 1
  002fb	4d 89 23	 mov	 QWORD PTR [r11], r12

; 183  :     }
; 184  :     FIX_PREALLOC_SIZE(list);

  002fe	48 89 75 60	 mov	 QWORD PTR [rbp+96], rsi

; 185  :     return list;

  00302	48 8b c5	 mov	 rax, rbp
  00305	e9 a2 00 00 00	 jmp	 $LN128@ucs2lib_sp@3
$LN107@ucs2lib_sp@3:
  0030a	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR tv886[rsp]
  00312	48 8b 6c 24 38	 mov	 rbp, QWORD PTR list$1$[rsp]
  00317	4c 8b 6c 24 48	 mov	 r13, QWORD PTR maxcount$1$[rsp]

; 166  :         pos = FASTSEARCH(str+i, str_len-i, sep, sep_len, -1, FAST_SEARCH);

$LN88@ucs2lib_sp@3:
  0031c	4c 8b 54 24 40	 mov	 r10, QWORD PTR i$1$[rsp]
  00321	48 8b 74 24 30	 mov	 rsi, QWORD PTR count$1$[rsp]
$LN86@ucs2lib_sp@3:

; 167  :         if (pos < 0)

  00326	4d 85 c9	 test	 r9, r9
  00329	78 97		 js	 SHORT $LN116@ucs2lib_sp@3

; 168  :             break;
; 169  :         j = i + pos;

  0032b	4b 8d 3c 11	 lea	 rdi, QWORD PTR [r9+r10]

; 170  :         SPLIT_ADD(str, i, j);

  0032f	49 8b c8	 mov	 rcx, r8
  00332	48 8b d7	 mov	 rdx, rdi
  00335	49 2b d2	 sub	 rdx, r10
  00338	e8 00 00 00 00	 call	 _PyUnicode_FromUCS2
  0033d	48 8b d8	 mov	 rbx, rax
  00340	48 85 c0	 test	 rax, rax
  00343	74 5b		 je	 SHORT $onError$122824
  00345	48 83 fe 0c	 cmp	 rsi, 12
  00349	7d 0a		 jge	 SHORT $LN11@ucs2lib_sp@3
  0034b	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  0034f	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  00353	eb 17		 jmp	 SHORT $LN8@ucs2lib_sp@3
$LN11@ucs2lib_sp@3:
  00355	48 8b d0	 mov	 rdx, rax
  00358	48 8b cd	 mov	 rcx, rbp
  0035b	e8 00 00 00 00	 call	 PyList_Append
  00360	48 8b cb	 mov	 rcx, rbx
  00363	85 c0		 test	 eax, eax
  00365	75 34		 jne	 SHORT $LN110@ucs2lib_sp@3
  00367	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@ucs2lib_sp@3:
  0036c	48 ff c6	 inc	 rsi

; 171  :         i = j + sep_len;

  0036f	4e 8d 14 37	 lea	 r10, QWORD PTR [rdi+r14]
  00373	4c 89 54 24 40	 mov	 QWORD PTR i$1$[rsp], r10
  00378	48 89 74 24 30	 mov	 QWORD PTR count$1$[rsp], rsi
  0037d	4d 85 ed	 test	 r13, r13
  00380	0f 8e 3c ff ff
	ff		 jle	 $LN116@ucs2lib_sp@3

; 179  :     } else
; 180  : #endif
; 181  :     {
; 182  :         SPLIT_ADD(str, i, str_len);

  00386	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR str_len$[rsp]
  0038e	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR str$[rsp]
  00396	e9 45 fd ff ff	 jmp	 $LL15@ucs2lib_sp@3
$LN110@ucs2lib_sp@3:

; 170  :         SPLIT_ADD(str, i, j);

  0039b	e8 00 00 00 00	 call	 _Py_DecRef
$onError$122824:

; 186  : 
; 187  :   onError:
; 188  :     Py_DECREF(list);

  003a0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR list$1$[rsp]
  003a5	e8 00 00 00 00	 call	 _Py_DecRef
$LN129@ucs2lib_sp@3:

; 189  :     return NULL;

  003aa	33 c0		 xor	 eax, eax
$LN128@ucs2lib_sp@3:
  003ac	48 8b ac 24 a8
	00 00 00	 mov	 rbp, QWORD PTR [rsp+168]
  003b4	4c 8b 6c 24 50	 mov	 r13, QWORD PTR [rsp+80]

; 190  : }

  003b9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003bd	41 5f		 pop	 r15
  003bf	41 5e		 pop	 r14
  003c1	41 5c		 pop	 r12
  003c3	5f		 pop	 rdi
  003c4	5e		 pop	 rsi
  003c5	5b		 pop	 rbx
  003c6	c3		 ret	 0
$LN7@ucs2lib_sp@3:

; 179  :     } else
; 180  : #endif
; 181  :     {
; 182  :         SPLIT_ADD(str, i, str_len);

  003c7	48 8b 44 24 40	 mov	 rax, QWORD PTR i$1$[rsp]
  003cc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  003d4	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR str_len$[rsp]
  003dc	48 8d 0c 41	 lea	 rcx, QWORD PTR [rcx+rax*2]
  003e0	48 2b d0	 sub	 rdx, rax
  003e3	e8 00 00 00 00	 call	 _PyUnicode_FromUCS2
  003e8	48 8b d8	 mov	 rbx, rax
  003eb	48 85 c0	 test	 rax, rax
  003ee	74 b0		 je	 SHORT $onError$122824
  003f0	48 8b 6c 24 38	 mov	 rbp, QWORD PTR list$1$[rsp]
  003f5	48 83 fe 0c	 cmp	 rsi, 12
  003f9	7d 15		 jge	 SHORT $LN4@ucs2lib_sp@3
  003fb	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  003ff	48 ff c6	 inc	 rsi
  00402	48 89 44 f1 f8	 mov	 QWORD PTR [rcx+rsi*8-8], rax

; 183  :     }
; 184  :     FIX_PREALLOC_SIZE(list);

  00407	48 89 75 60	 mov	 QWORD PTR [rbp+96], rsi

; 185  :     return list;

  0040b	48 8b c5	 mov	 rax, rbp
  0040e	eb 9c		 jmp	 SHORT $LN128@ucs2lib_sp@3
$LN4@ucs2lib_sp@3:

; 179  :     } else
; 180  : #endif
; 181  :     {
; 182  :         SPLIT_ADD(str, i, str_len);

  00410	48 8b d0	 mov	 rdx, rax
  00413	48 8b cd	 mov	 rcx, rbp
  00416	e8 00 00 00 00	 call	 PyList_Append
  0041b	48 8b cb	 mov	 rcx, rbx
  0041e	85 c0		 test	 eax, eax
  00420	0f 85 75 ff ff
	ff		 jne	 $LN110@ucs2lib_sp@3
  00426	e8 00 00 00 00	 call	 _Py_DecRef
  0042b	48 ff c6	 inc	 rsi

; 185  :     return list;

  0042e	48 8b c5	 mov	 rax, rbp
  00431	48 89 75 60	 mov	 QWORD PTR [rbp+96], rsi
  00435	e9 72 ff ff ff	 jmp	 $LN128@ucs2lib_sp@3
ucs2lib_split ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ucs2lib_rsplit_whitespace DD imagerel ucs2lib_rsplit_whitespace
	DD	imagerel ucs2lib_rsplit_whitespace+703
	DD	imagerel $unwind$ucs2lib_rsplit_whitespace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_rsplit_whitespace DD 0c5501H
	DD	0df455H
	DD	0c7450H
	DD	0e3411H
	DD	0e00d5211H
	DD	0c009d00bH
	DD	050066007H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs2lib_rsplit_whitespace
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
maxcount$ = 120
ucs2lib_rsplit_whitespace PROC				; COMDAT

; 196  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 197  :     Py_ssize_t i, j, count=0;

  00011	33 ed		 xor	 ebp, ebp
  00013	4c 8b f1	 mov	 r14, rcx
  00016	4d 8b e9	 mov	 r13, r9
  00019	49 8b d8	 mov	 rbx, r8
  0001c	48 8b f2	 mov	 rsi, rdx

; 198  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  0001f	8d 4d 0c	 lea	 ecx, QWORD PTR [rbp+12]
  00022	49 83 f9 0c	 cmp	 r9, 12
  00026	7d 04		 jge	 SHORT $LN28@ucs2lib_rs
  00028	49 8d 49 01	 lea	 rcx, QWORD PTR [r9+1]
$LN28@ucs2lib_rs:
  0002c	e8 00 00 00 00	 call	 PyList_New
  00031	4c 8b e0	 mov	 r12, rax

; 199  :     PyObject *sub;
; 200  : 
; 201  :     if (list == NULL)

  00034	48 85 c0	 test	 rax, rax
  00037	75 12		 jne	 SHORT $LN24@ucs2lib_rs

; 240  : }

  00039	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	41 5e		 pop	 r14
  00044	41 5d		 pop	 r13
  00046	41 5c		 pop	 r12
  00048	5e		 pop	 rsi
  00049	5d		 pop	 rbp
  0004a	c3		 ret	 0
$LN24@ucs2lib_rs:
  0004b	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00050	4c 89 7c 24 68	 mov	 QWORD PTR [rsp+104], r15

; 202  :         return NULL;
; 203  : 
; 204  :     i = j = str_len - 1;

  00055	4c 8d 7b ff	 lea	 r15, QWORD PTR [rbx-1]
  00059	49 8b df	 mov	 rbx, r15
$LN68@ucs2lib_rs:

; 205  :     while (maxcount-- > 0) {

  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
  00063	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00068	4d 85 ed	 test	 r13, r13
  0006b	0f 8e 7d 01 00
	00		 jle	 $LN56@ucs2lib_rs
  00071	49 ff cd	 dec	 r13

; 206  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  00074	48 85 db	 test	 rbx, rbx
  00077	0f 88 06 02 00
	00		 js	 $LN7@ucs2lib_rs
  0007d	0f 1f 00	 npad	 3
$LL21@ucs2lib_rs:
  00080	0f b7 04 5e	 movzx	 eax, WORD PTR [rsi+rbx*2]
  00084	66 3b c1	 cmp	 ax, cx
  00087	73 09		 jae	 SHORT $LN29@ucs2lib_rs
  00089	0f b7 c0	 movzx	 eax, ax
  0008c	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  00090	eb 14		 jmp	 SHORT $LN30@ucs2lib_rs
$LN29@ucs2lib_rs:
  00092	0f b7 c8	 movzx	 ecx, ax
  00095	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  0009a	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
$LN30@ucs2lib_rs:
  000a6	85 c0		 test	 eax, eax
  000a8	74 0a		 je	 SHORT $LN20@ucs2lib_rs

; 207  :             i--;

  000aa	48 ff cb	 dec	 rbx

; 206  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  000ad	79 d1		 jns	 SHORT $LL21@ucs2lib_rs
  000af	e9 cf 01 00 00	 jmp	 $LN7@ucs2lib_rs
$LN20@ucs2lib_rs:

; 208  :         if (i < 0) break;

  000b4	48 85 db	 test	 rbx, rbx
  000b7	0f 88 c6 01 00
	00		 js	 $LN7@ucs2lib_rs

; 209  :         j = i; i--;

  000bd	48 8b fb	 mov	 rdi, rbx
  000c0	48 ff cb	 dec	 rbx

; 210  :         while (i >= 0 && !STRINGLIB_ISSPACE(str[i]))

  000c3	78 2f		 js	 SHORT $LN63@ucs2lib_rs
$LL18@ucs2lib_rs:
  000c5	0f b7 04 5e	 movzx	 eax, WORD PTR [rsi+rbx*2]
  000c9	66 3b c1	 cmp	 ax, cx
  000cc	73 09		 jae	 SHORT $LN31@ucs2lib_rs
  000ce	0f b7 c0	 movzx	 eax, ax
  000d1	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  000d5	eb 14		 jmp	 SHORT $LN32@ucs2lib_rs
$LN31@ucs2lib_rs:
  000d7	0f b7 c8	 movzx	 ecx, ax
  000da	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  000df	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
$LN32@ucs2lib_rs:
  000eb	85 c0		 test	 eax, eax
  000ed	75 05		 jne	 SHORT $LN63@ucs2lib_rs

; 211  :             i--;

  000ef	48 ff cb	 dec	 rbx

; 210  :         while (i >= 0 && !STRINGLIB_ISSPACE(str[i]))

  000f2	79 d1		 jns	 SHORT $LL18@ucs2lib_rs
$LN63@ucs2lib_rs:

; 212  : #ifndef STRINGLIB_MUTABLE
; 213  :         if (j == str_len - 1 && i < 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  000f4	49 3b ff	 cmp	 rdi, r15
  000f7	75 16		 jne	 SHORT $LN16@ucs2lib_rs
  000f9	48 85 db	 test	 rbx, rbx
  000fc	79 11		 jns	 SHORT $LN16@ucs2lib_rs
  000fe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00105	49 39 46 58	 cmp	 QWORD PTR [r14+88], rax
  00109	0f 84 c0 00 00
	00		 je	 $LN51@ucs2lib_rs
$LN16@ucs2lib_rs:

; 219  :         }
; 220  : #endif
; 221  :         SPLIT_ADD(str, i + 1, j + 1);

  0010f	48 2b fb	 sub	 rdi, rbx
  00112	48 8d 4c 5e 02	 lea	 rcx, QWORD PTR [rsi+rbx*2+2]
  00117	48 8b d7	 mov	 rdx, rdi
  0011a	e8 00 00 00 00	 call	 _PyUnicode_FromUCS2
  0011f	48 8b f8	 mov	 rdi, rax
  00122	48 85 c0	 test	 rax, rax
  00125	0f 84 69 01 00
	00		 je	 $onError$122885
  0012b	48 83 fd 0c	 cmp	 rbp, 12
  0012f	7d 12		 jge	 SHORT $LN14@ucs2lib_rs
  00131	49 8b 4c 24 70	 mov	 rcx, QWORD PTR [r12+112]
  00136	48 ff c5	 inc	 rbp
  00139	48 89 44 e9 f8	 mov	 QWORD PTR [rcx+rbp*8-8], rax
  0013e	e9 19 ff ff ff	 jmp	 $LN68@ucs2lib_rs
$LN14@ucs2lib_rs:
  00143	48 8b d0	 mov	 rdx, rax
  00146	49 8b cc	 mov	 rcx, r12
  00149	e8 00 00 00 00	 call	 PyList_Append
  0014e	85 c0		 test	 eax, eax
  00150	0f 85 b3 00 00
	00		 jne	 $LN53@ucs2lib_rs
  00156	e8 00 00 00 00	 call	 _Py_PXCTX
  0015b	85 c0		 test	 eax, eax
  0015d	75 68		 jne	 SHORT $LN45@ucs2lib_rs
  0015f	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00163	a8 20		 test	 al, 32			; 00000020H
  00165	75 58		 jne	 SHORT $LN39@ucs2lib_rs
  00167	84 c0		 test	 al, al
  00169	78 54		 js	 SHORT $LN39@ucs2lib_rs
  0016b	a8 02		 test	 al, 2
  0016d	75 58		 jne	 SHORT $LN45@ucs2lib_rs
  0016f	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00173	75 52		 jne	 SHORT $LN45@ucs2lib_rs
  00175	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0017c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00183	4c 8b cf	 mov	 r9, rdi
  00186	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0018c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00194	e8 00 00 00 00	 call	 _PyParallel_Guard
  00199	48 8b cf	 mov	 rcx, rdi
  0019c	85 c0		 test	 eax, eax
  0019e	74 0d		 je	 SHORT $LN44@ucs2lib_rs
  001a0	e8 00 00 00 00	 call	 _Px_Dealloc
  001a5	48 ff c5	 inc	 rbp
  001a8	e9 af fe ff ff	 jmp	 $LN68@ucs2lib_rs
$LN44@ucs2lib_rs:
  001ad	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001b1	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001b7	48 ff c5	 inc	 rbp
  001ba	e9 9d fe ff ff	 jmp	 $LN68@ucs2lib_rs
$LN39@ucs2lib_rs:
  001bf	48 8b cf	 mov	 rcx, rdi
  001c2	e8 00 00 00 00	 call	 Px_DecRef
$LN45@ucs2lib_rs:
  001c7	48 ff c5	 inc	 rbp

; 205  :     while (maxcount-- > 0) {

  001ca	e9 8d fe ff ff	 jmp	 $LN68@ucs2lib_rs
$LN51@ucs2lib_rs:

; 214  :             /* No whitespace in str_obj, so just use it as list[0] */
; 215  :             Py_INCREF(str_obj);

  001cf	49 8b ce	 mov	 rcx, r14
  001d2	e8 00 00 00 00	 call	 _Py_IncRef

; 216  :             PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  001d7	4d 8b 5c 24 70	 mov	 r11, QWORD PTR [r12+112]

; 217  :             count++;

  001dc	48 ff c5	 inc	 rbp

; 218  :             break;

  001df	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  001e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
  001eb	4d 89 33	 mov	 QWORD PTR [r11], r14
$LN56@ucs2lib_rs:

; 222  :     }
; 223  : 
; 224  :     if (i >= 0) {

  001ee	48 85 db	 test	 rbx, rbx
  001f1	0f 88 8c 00 00
	00		 js	 $LN7@ucs2lib_rs
$LL9@ucs2lib_rs:

; 225  :         /* Only occurs when maxcount was reached */
; 226  :         /* Skip any remaining whitespace and copy to beginning of string */
; 227  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  001f7	0f b7 04 5e	 movzx	 eax, WORD PTR [rsi+rbx*2]
  001fb	66 3b c1	 cmp	 ax, cx
  001fe	73 20		 jae	 SHORT $LN33@ucs2lib_rs
  00200	0f b7 c0	 movzx	 eax, ax
  00203	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  00207	eb 2b		 jmp	 SHORT $LN34@ucs2lib_rs
$LN53@ucs2lib_rs:

; 219  :         }
; 220  : #endif
; 221  :         SPLIT_ADD(str, i + 1, j + 1);

  00209	48 8b cf	 mov	 rcx, rdi
$LN69@ucs2lib_rs:
  0020c	e8 00 00 00 00	 call	 _Py_DecRef

; 236  : 
; 237  :   onError:
; 238  :     Py_DECREF(list);

  00211	49 8b cc	 mov	 rcx, r12
  00214	e8 00 00 00 00	 call	 _Py_DecRef

; 239  :     return NULL;

  00219	33 c0		 xor	 eax, eax
  0021b	e9 83 00 00 00	 jmp	 $LN66@ucs2lib_rs
$LN33@ucs2lib_rs:

; 225  :         /* Only occurs when maxcount was reached */
; 226  :         /* Skip any remaining whitespace and copy to beginning of string */
; 227  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  00220	0f b7 c8	 movzx	 ecx, ax
  00223	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  00228	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0022d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
$LN34@ucs2lib_rs:
  00234	85 c0		 test	 eax, eax
  00236	74 07		 je	 SHORT $LN8@ucs2lib_rs

; 228  :             i--;

  00238	48 ff cb	 dec	 rbx

; 225  :         /* Only occurs when maxcount was reached */
; 226  :         /* Skip any remaining whitespace and copy to beginning of string */
; 227  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  0023b	79 ba		 jns	 SHORT $LL9@ucs2lib_rs

; 229  :         if (i >= 0)

  0023d	eb 44		 jmp	 SHORT $LN7@ucs2lib_rs
$LN8@ucs2lib_rs:
  0023f	48 85 db	 test	 rbx, rbx
  00242	78 3f		 js	 SHORT $LN7@ucs2lib_rs

; 230  :             SPLIT_ADD(str, 0, i + 1);

  00244	48 8d 53 01	 lea	 rdx, QWORD PTR [rbx+1]
  00248	48 8b ce	 mov	 rcx, rsi
  0024b	e8 00 00 00 00	 call	 _PyUnicode_FromUCS2
  00250	48 8b d8	 mov	 rbx, rax
  00253	48 85 c0	 test	 rax, rax
  00256	74 3c		 je	 SHORT $onError$122885
  00258	48 83 fd 0c	 cmp	 rbp, 12
  0025c	7d 0b		 jge	 SHORT $LN5@ucs2lib_rs
  0025e	49 8b 4c 24 70	 mov	 rcx, QWORD PTR [r12+112]
  00263	48 89 04 e9	 mov	 QWORD PTR [rcx+rbp*8], rax
  00267	eb 17		 jmp	 SHORT $LN2@ucs2lib_rs
$LN5@ucs2lib_rs:
  00269	48 8b d0	 mov	 rdx, rax
  0026c	49 8b cc	 mov	 rcx, r12
  0026f	e8 00 00 00 00	 call	 PyList_Append
  00274	48 8b cb	 mov	 rcx, rbx
  00277	85 c0		 test	 eax, eax
  00279	75 91		 jne	 SHORT $LN69@ucs2lib_rs
  0027b	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@ucs2lib_rs:
  00280	48 ff c5	 inc	 rbp
$LN7@ucs2lib_rs:

; 231  :     }
; 232  :     FIX_PREALLOC_SIZE(list);
; 233  :     if (PyList_Reverse(list) < 0)

  00283	49 8b cc	 mov	 rcx, r12
  00286	49 89 6c 24 60	 mov	 QWORD PTR [r12+96], rbp
  0028b	e8 00 00 00 00	 call	 PyList_Reverse
  00290	85 c0		 test	 eax, eax
  00292	79 0c		 jns	 SHORT $LN1@ucs2lib_rs
$onError$122885:

; 236  : 
; 237  :   onError:
; 238  :     Py_DECREF(list);

  00294	49 8b cc	 mov	 rcx, r12
  00297	e8 00 00 00 00	 call	 _Py_DecRef

; 239  :     return NULL;

  0029c	33 c0		 xor	 eax, eax
  0029e	eb 03		 jmp	 SHORT $LN66@ucs2lib_rs
$LN1@ucs2lib_rs:

; 234  :         goto onError;
; 235  :     return list;

  002a0	49 8b c4	 mov	 rax, r12
$LN66@ucs2lib_rs:
  002a3	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  002a8	4c 8b 7c 24 68	 mov	 r15, QWORD PTR [rsp+104]

; 240  : }

  002ad	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  002b2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002b6	41 5e		 pop	 r14
  002b8	41 5d		 pop	 r13
  002ba	41 5c		 pop	 r12
  002bc	5e		 pop	 rsi
  002bd	5d		 pop	 rbp
  002be	c3		 ret	 0
ucs2lib_rsplit_whitespace ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ucs2lib_rsplit_char DD imagerel ucs2lib_rsplit_char
	DD	imagerel ucs2lib_rsplit_char+80
	DD	imagerel $unwind$ucs2lib_rsplit_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ucs2lib_rsplit_char DD imagerel ucs2lib_rsplit_char+80
	DD	imagerel ucs2lib_rsplit_char+504
	DD	imagerel $chain$0$ucs2lib_rsplit_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ucs2lib_rsplit_char DD imagerel ucs2lib_rsplit_char+504
	DD	imagerel ucs2lib_rsplit_char+528
	DD	imagerel $chain$1$ucs2lib_rsplit_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ucs2lib_rsplit_char DD 021H
	DD	imagerel ucs2lib_rsplit_char
	DD	imagerel ucs2lib_rsplit_char+80
	DD	imagerel $unwind$ucs2lib_rsplit_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ucs2lib_rsplit_char DD 020521H
	DD	0c5405H
	DD	imagerel ucs2lib_rsplit_char
	DD	imagerel ucs2lib_rsplit_char+80
	DD	imagerel $unwind$ucs2lib_rsplit_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_rsplit_char DD 0a1701H
	DD	0e6417H
	DD	0d3417H
	DD	0f0135217H
	DD	0d00fe011H
	DD	0700bc00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs2lib_rsplit_char
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
ch$ = 120
maxcount$ = 128
ucs2lib_rsplit_char PROC				; COMDAT

; 247  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 248  :     Py_ssize_t i, j, count=0;
; 249  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00017	4c 8b b4 24 80
	00 00 00	 mov	 r14, QWORD PTR maxcount$[rsp]
  0001f	33 f6		 xor	 esi, esi
  00021	4c 8b f9	 mov	 r15, rcx
  00024	45 0f b7 e9	 movzx	 r13d, r9w
  00028	49 8b d8	 mov	 rbx, r8
  0002b	4c 8b e2	 mov	 r12, rdx
  0002e	8d 4e 0c	 lea	 ecx, QWORD PTR [rsi+12]
  00031	49 83 fe 0c	 cmp	 r14, 12
  00035	7d 04		 jge	 SHORT $LN25@ucs2lib_rs@2
  00037	49 8d 4e 01	 lea	 rcx, QWORD PTR [r14+1]
$LN25@ucs2lib_rs@2:
  0003b	e8 00 00 00 00	 call	 PyList_New
  00040	48 8b f8	 mov	 rdi, rax

; 250  :     PyObject *sub;
; 251  : 
; 252  :     if (list == NULL)

  00043	48 85 c0	 test	 rax, rax
  00046	0f 84 ac 01 00
	00		 je	 $LN22@ucs2lib_rs@2
$LN21@ucs2lib_rs@2:

; 253  :         return NULL;
; 254  : 
; 255  :     i = j = str_len - 1;

  0004c	48 8d 53 ff	 lea	 rdx, QWORD PTR [rbx-1]
  00050	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  00055	48 8b da	 mov	 rbx, rdx

; 256  :     while ((i >= 0) && (maxcount-- > 0)) {

  00058	48 85 d2	 test	 rdx, rdx
  0005b	78 75		 js	 SHORT $LN49@ucs2lib_rs@2
  0005d	0f 1f 00	 npad	 3
$LL20@ucs2lib_rs@2:
  00060	49 8b c6	 mov	 rax, r14
  00063	49 ff ce	 dec	 r14
  00066	48 85 c0	 test	 rax, rax
  00069	7e 62		 jle	 SHORT $LN19@ucs2lib_rs@2

; 257  :         for(; i >= 0; i--) {

  0006b	48 85 db	 test	 rbx, rbx
  0006e	78 5d		 js	 SHORT $LN19@ucs2lib_rs@2
$LL18@ucs2lib_rs@2:

; 258  :             if (str[i] == ch) {

  00070	66 45 39 2c 5c	 cmp	 WORD PTR [r12+rbx*2], r13w
  00075	74 07		 je	 SHORT $LN43@ucs2lib_rs@2

; 257  :         for(; i >= 0; i--) {

  00077	48 ff cb	 dec	 rbx
  0007a	79 f4		 jns	 SHORT $LL18@ucs2lib_rs@2
  0007c	eb 4f		 jmp	 SHORT $LN19@ucs2lib_rs@2
$LN43@ucs2lib_rs@2:

; 259  :                 SPLIT_ADD(str, i + 1, j + 1);

  0007e	49 8d 4c 5c 02	 lea	 rcx, QWORD PTR [r12+rbx*2+2]
  00083	48 2b d3	 sub	 rdx, rbx
  00086	e8 00 00 00 00	 call	 _PyUnicode_FromUCS2
  0008b	48 8b e8	 mov	 rbp, rax
  0008e	48 85 c0	 test	 rax, rax
  00091	0f 84 ec 00 00
	00		 je	 $onError$122940
  00097	48 83 fe 0c	 cmp	 rsi, 12
  0009b	7d 0a		 jge	 SHORT $LN13@ucs2lib_rs@2
  0009d	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  000a1	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  000a5	eb 1b		 jmp	 SHORT $LN10@ucs2lib_rs@2
$LN13@ucs2lib_rs@2:
  000a7	48 8b d0	 mov	 rdx, rax
  000aa	48 8b cf	 mov	 rcx, rdi
  000ad	e8 00 00 00 00	 call	 PyList_Append
  000b2	48 8b cd	 mov	 rcx, rbp
  000b5	85 c0		 test	 eax, eax
  000b7	0f 85 a7 00 00
	00		 jne	 $LN45@ucs2lib_rs@2
  000bd	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@ucs2lib_rs@2:
  000c2	48 ff c6	 inc	 rsi

; 260  :                 j = i = i - 1;

  000c5	48 ff cb	 dec	 rbx
  000c8	48 8b d3	 mov	 rdx, rbx
  000cb	79 93		 jns	 SHORT $LL20@ucs2lib_rs@2
$LN19@ucs2lib_rs@2:

; 261  :                 break;
; 262  :             }
; 263  :         }
; 264  :     }
; 265  : #ifndef STRINGLIB_MUTABLE
; 266  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  000cd	48 85 f6	 test	 rsi, rsi
  000d0	75 57		 jne	 SHORT $LN9@ucs2lib_rs@2
$LN49@ucs2lib_rs@2:
  000d2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  000d9	49 39 47 58	 cmp	 QWORD PTR [r15+88], rax
  000dd	75 4a		 jne	 SHORT $LN9@ucs2lib_rs@2

; 267  :         /* ch not in str_obj, so just use str_obj as list[0] */
; 268  :         Py_INCREF(str_obj);

  000df	e8 00 00 00 00	 call	 _Py_PXCTX
  000e4	85 c0		 test	 eax, eax
  000e6	75 33		 jne	 SHORT $LN27@ucs2lib_rs@2
  000e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000f6	4d 8b cf	 mov	 r9, r15
  000f9	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000ff	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00107	e8 00 00 00 00	 call	 _PyParallel_Guard
  0010c	85 c0		 test	 eax, eax
  0010e	75 07		 jne	 SHORT $LN26@ucs2lib_rs@2
  00110	41 f6 47 20 20	 test	 BYTE PTR [r15+32], 32	; 00000020H
  00115	74 04		 je	 SHORT $LN27@ucs2lib_rs@2
$LN26@ucs2lib_rs@2:
  00117	49 ff 47 50	 inc	 QWORD PTR [r15+80]
$LN27@ucs2lib_rs@2:

; 269  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  0011b	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]

; 270  :         count++;

  0011f	be 01 00 00 00	 mov	 esi, 1
  00124	4c 89 38	 mov	 QWORD PTR [rax], r15

; 271  :     } else

  00127	eb 4a		 jmp	 SHORT $LN7@ucs2lib_rs@2
$LN9@ucs2lib_rs@2:

; 272  : #endif
; 273  :     if (j >= -1) {

  00129	48 83 fa ff	 cmp	 rdx, -1
  0012d	7c 44		 jl	 SHORT $LN7@ucs2lib_rs@2

; 274  :         SPLIT_ADD(str, 0, j + 1);

  0012f	48 ff c2	 inc	 rdx
  00132	49 8b cc	 mov	 rcx, r12
  00135	e8 00 00 00 00	 call	 _PyUnicode_FromUCS2
  0013a	48 8b d8	 mov	 rbx, rax
  0013d	48 85 c0	 test	 rax, rax
  00140	74 41		 je	 SHORT $onError$122940
  00142	48 83 fe 0c	 cmp	 rsi, 12
  00146	7d 0a		 jge	 SHORT $LN5@ucs2lib_rs@2
  00148	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  0014c	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  00150	eb 1e		 jmp	 SHORT $LN2@ucs2lib_rs@2
$LN5@ucs2lib_rs@2:
  00152	48 8b d0	 mov	 rdx, rax
  00155	48 8b cf	 mov	 rcx, rdi
  00158	e8 00 00 00 00	 call	 PyList_Append
  0015d	48 8b cb	 mov	 rcx, rbx
  00160	85 c0		 test	 eax, eax
  00162	74 07		 je	 SHORT $LN3@ucs2lib_rs@2
$LN45@ucs2lib_rs@2:
  00164	e8 00 00 00 00	 call	 _Py_DecRef
  00169	eb 18		 jmp	 SHORT $onError$122940
$LN3@ucs2lib_rs@2:
  0016b	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@ucs2lib_rs@2:
  00170	48 ff c6	 inc	 rsi
$LN7@ucs2lib_rs@2:

; 275  :     }
; 276  :     FIX_PREALLOC_SIZE(list);
; 277  :     if (PyList_Reverse(list) < 0)

  00173	48 8b cf	 mov	 rcx, rdi
  00176	48 89 77 60	 mov	 QWORD PTR [rdi+96], rsi
  0017a	e8 00 00 00 00	 call	 PyList_Reverse
  0017f	85 c0		 test	 eax, eax
  00181	79 6d		 jns	 SHORT $LN1@ucs2lib_rs@2
$onError$122940:

; 280  : 
; 281  :   onError:
; 282  :     Py_DECREF(list);

  00183	e8 00 00 00 00	 call	 _Py_PXCTX
  00188	85 c0		 test	 eax, eax
  0018a	75 60		 jne	 SHORT $LN40@ucs2lib_rs@2
  0018c	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00190	a8 20		 test	 al, 32			; 00000020H
  00192	75 50		 jne	 SHORT $LN34@ucs2lib_rs@2
  00194	84 c0		 test	 al, al
  00196	78 4c		 js	 SHORT $LN34@ucs2lib_rs@2
  00198	a8 02		 test	 al, 2
  0019a	75 50		 jne	 SHORT $LN40@ucs2lib_rs@2
  0019c	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  001a0	75 4a		 jne	 SHORT $LN40@ucs2lib_rs@2
  001a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001b0	4c 8b cf	 mov	 r9, rdi
  001b3	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001b9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001c1	e8 00 00 00 00	 call	 _PyParallel_Guard
  001c6	48 8b cf	 mov	 rcx, rdi
  001c9	85 c0		 test	 eax, eax
  001cb	74 09		 je	 SHORT $LN39@ucs2lib_rs@2
  001cd	e8 00 00 00 00	 call	 _Px_Dealloc

; 283  :     return NULL;

  001d2	33 c0		 xor	 eax, eax
  001d4	eb 1d		 jmp	 SHORT $LN50@ucs2lib_rs@2

; 280  : 
; 281  :   onError:
; 282  :     Py_DECREF(list);

$LN39@ucs2lib_rs@2:
  001d6	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001da	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 283  :     return NULL;

  001e0	33 c0		 xor	 eax, eax
  001e2	eb 0f		 jmp	 SHORT $LN50@ucs2lib_rs@2

; 280  : 
; 281  :   onError:
; 282  :     Py_DECREF(list);

$LN34@ucs2lib_rs@2:
  001e4	48 8b cf	 mov	 rcx, rdi
  001e7	e8 00 00 00 00	 call	 Px_DecRef
$LN40@ucs2lib_rs@2:

; 283  :     return NULL;

  001ec	33 c0		 xor	 eax, eax
  001ee	eb 03		 jmp	 SHORT $LN50@ucs2lib_rs@2
$LN1@ucs2lib_rs@2:

; 278  :         goto onError;
; 279  :     return list;

  001f0	48 8b c7	 mov	 rax, rdi
$LN50@ucs2lib_rs@2:
  001f3	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
$LN22@ucs2lib_rs@2:

; 284  : }

  001f8	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  001fd	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  00202	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00206	41 5f		 pop	 r15
  00208	41 5e		 pop	 r14
  0020a	41 5d		 pop	 r13
  0020c	41 5c		 pop	 r12
  0020e	5f		 pop	 rdi
  0020f	c3		 ret	 0
ucs2lib_rsplit_char ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs2lib_rsplit DD imagerel ucs2lib_rsplit
	DD	imagerel ucs2lib_rsplit+128
	DD	imagerel $unwind$ucs2lib_rsplit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ucs2lib_rsplit DD imagerel ucs2lib_rsplit+128
	DD	imagerel ucs2lib_rsplit+737
	DD	imagerel $chain$1$ucs2lib_rsplit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ucs2lib_rsplit DD imagerel ucs2lib_rsplit+737
	DD	imagerel ucs2lib_rsplit+827
	DD	imagerel $chain$3$ucs2lib_rsplit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ucs2lib_rsplit DD 040021H
	DD	08d400H
	DD	0113400H
	DD	imagerel ucs2lib_rsplit
	DD	imagerel ucs2lib_rsplit+128
	DD	imagerel $unwind$ucs2lib_rsplit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ucs2lib_rsplit DD 041a21H
	DD	08d41aH
	DD	0113408H
	DD	imagerel ucs2lib_rsplit
	DD	imagerel ucs2lib_rsplit+128
	DD	imagerel $unwind$ucs2lib_rsplit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_rsplit DD 071701H
	DD	0f0138217H
	DD	0c00fe011H
	DD	0600c700dH
	DD	0500bH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs2lib_rsplit
_TEXT	SEGMENT
maxcount$1$ = 48
str_obj$ = 128
str$ = 136
str_len$ = 144
sep$ = 152
list$1$ = 160
sep_len$ = 160
maxcount$ = 168
ucs2lib_rsplit PROC					; COMDAT

; 291  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 292  :     Py_ssize_t j, pos, count=0;
; 293  :     PyObject *list, *sub;
; 294  : 
; 295  :     if (sep_len == 0) {

  00017	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR sep_len$[rsp]
  0001f	45 33 f6	 xor	 r14d, r14d
  00022	4d 8b e1	 mov	 r12, r9
  00025	4d 8b f8	 mov	 r15, r8
  00028	48 8b ea	 mov	 rbp, rdx
  0002b	48 8b f9	 mov	 rdi, rcx
  0002e	48 85 f6	 test	 rsi, rsi
  00031	75 23		 jne	 SHORT $LN20@ucs2lib_rs@3

; 296  :         PyErr_SetString(PyExc_ValueError, "empty separator");

  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00041	e8 00 00 00 00	 call	 PyErr_SetString

; 297  :         return NULL;

  00046	33 c0		 xor	 eax, eax

; 333  : }

  00048	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004c	41 5f		 pop	 r15
  0004e	41 5e		 pop	 r14
  00050	41 5c		 pop	 r12
  00052	5f		 pop	 rdi
  00053	5e		 pop	 rsi
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
$LN20@ucs2lib_rs@3:

; 298  :     }
; 299  :     else if (sep_len == 1)

  00056	48 83 fe 01	 cmp	 rsi, 1
  0005a	75 24		 jne	 SHORT $LN18@ucs2lib_rs@3

; 300  :         return STRINGLIB(rsplit_char)(str_obj, str, str_len, sep[0], maxcount);

  0005c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00064	45 0f b7 09	 movzx	 r9d, WORD PTR [r9]
  00068	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006d	e8 00 00 00 00	 call	 ucs2lib_rsplit_char

; 333  : }

  00072	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00076	41 5f		 pop	 r15
  00078	41 5e		 pop	 r14
  0007a	41 5c		 pop	 r12
  0007c	5f		 pop	 rdi
  0007d	5e		 pop	 rsi
  0007e	5d		 pop	 rbp
  0007f	c3		 ret	 0
$LN18@ucs2lib_rs@3:
  00080	48 89 9c 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbx

; 301  : 
; 302  :     list = PyList_New(PREALLOC_SIZE(maxcount));

  00088	48 8b 9c 24 a8
	00 00 00	 mov	 rbx, QWORD PTR maxcount$[rsp]
  00090	b9 0c 00 00 00	 mov	 ecx, 12
  00095	4c 89 6c 24 40	 mov	 QWORD PTR [rsp+64], r13
  0009a	48 83 fb 0c	 cmp	 rbx, 12
  0009e	7d 04		 jge	 SHORT $LN24@ucs2lib_rs@3
  000a0	48 8d 4b 01	 lea	 rcx, QWORD PTR [rbx+1]
$LN24@ucs2lib_rs@3:
  000a4	e8 00 00 00 00	 call	 PyList_New
  000a9	4c 8b e8	 mov	 r13, rax
  000ac	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR list$1$[rsp], rax

; 303  :     if (list == NULL)

  000b4	48 85 c0	 test	 rax, rax

; 304  :         return NULL;

  000b7	0f 84 07 02 00
	00		 je	 $LN126@ucs2lib_rs@3

; 305  : 
; 306  :     j = str_len;
; 307  :     while (maxcount-- > 0) {

  000bd	48 85 db	 test	 rbx, rbx
  000c0	7e 6b		 jle	 SHORT $LN115@ucs2lib_rs@3
  000c2	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL16@ucs2lib_rs@3:
  000d0	48 ff cb	 dec	 rbx
  000d3	48 89 5c 24 30	 mov	 QWORD PTR maxcount$1$[rsp], rbx

; 308  :         pos = FASTSEARCH(str, j, sep, sep_len, -1, FAST_RSEARCH);

  000d8	49 8b df	 mov	 rbx, r15
  000db	48 2b de	 sub	 rbx, rsi
  000de	78 34		 js	 SHORT $LN113@ucs2lib_rs@3
  000e0	48 83 fe 01	 cmp	 rsi, 1
  000e4	7f 72		 jg	 SHORT $LN84@ucs2lib_rs@3
  000e6	48 85 f6	 test	 rsi, rsi
  000e9	7e 29		 jle	 SHORT $LN113@ucs2lib_rs@3
  000eb	49 8d 5f ff	 lea	 rbx, QWORD PTR [r15-1]
  000ef	48 83 fb ff	 cmp	 rbx, -1
  000f3	7e 1f		 jle	 SHORT $LN113@ucs2lib_rs@3
  000f5	41 0f b7 04 24	 movzx	 eax, WORD PTR [r12]
  000fa	66 0f 1f 44 00
	00		 npad	 6
$LL67@ucs2lib_rs@3:
  00100	66 39 44 5d 00	 cmp	 WORD PTR [rbp+rbx*2], ax
  00105	0f 84 3f 01 00
	00		 je	 $LN105@ucs2lib_rs@3
  0010b	48 ff cb	 dec	 rbx
  0010e	48 83 fb ff	 cmp	 rbx, -1
  00112	7f ec		 jg	 SHORT $LL67@ucs2lib_rs@3
$LN113@ucs2lib_rs@3:

; 313  :     }
; 314  : #ifndef STRINGLIB_MUTABLE
; 315  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  00114	4d 85 f6	 test	 r14, r14
  00117	0f 85 c4 01 00
	00		 jne	 $LN8@ucs2lib_rs@3
  0011d	4c 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]
  00125	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR str_obj$[rsp]
$LN115@ucs2lib_rs@3:
  0012d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00134	48 39 47 58	 cmp	 QWORD PTR [rdi+88], rax
  00138	0f 85 a3 01 00
	00		 jne	 $LN8@ucs2lib_rs@3

; 316  :         /* No match in str_obj, so just use it as list[0] */
; 317  :         Py_INCREF(str_obj);

  0013e	48 8b cf	 mov	 rcx, rdi
  00141	e8 00 00 00 00	 call	 _Py_IncRef

; 318  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  00146	4d 8b 5d 70	 mov	 r11, QWORD PTR [r13+112]

; 319  :         count++;

  0014a	41 be 01 00 00
	00		 mov	 r14d, 1
  00150	49 89 3b	 mov	 QWORD PTR [r11], rdi

; 320  :     } else

  00153	e9 ce 01 00 00	 jmp	 $LN7@ucs2lib_rs@3

; 308  :         pos = FASTSEARCH(str, j, sep, sep_len, -1, FAST_RSEARCH);

$LN84@ucs2lib_rs@3:
  00158	45 0f b7 2c 24	 movzx	 r13d, WORD PTR [r12]
  0015d	48 8d 7e ff	 lea	 rdi, QWORD PTR [rsi-1]
  00161	41 ba 01 00 00
	00		 mov	 r10d, 1
  00167	41 8b cd	 mov	 ecx, r13d
  0016a	4c 8d 5f ff	 lea	 r11, QWORD PTR [rdi-1]
  0016e	4c 8b cf	 mov	 r9, rdi
  00171	83 e1 1f	 and	 ecx, 31
  00174	41 d3 e2	 shl	 r10d, cl
  00177	48 85 ff	 test	 rdi, rdi
  0017a	7e 2b		 jle	 SHORT $LN40@ucs2lib_rs@3
  0017c	0f 1f 40 00	 npad	 4
$LL42@ucs2lib_rs@3:
  00180	47 0f b7 04 4c	 movzx	 r8d, WORD PTR [r12+r9*2]
  00185	ba 01 00 00 00	 mov	 edx, 1
  0018a	41 8b c8	 mov	 ecx, r8d
  0018d	83 e1 1f	 and	 ecx, 31
  00190	d3 e2		 shl	 edx, cl
  00192	44 0b d2	 or	 r10d, edx
  00195	66 45 3b c5	 cmp	 r8w, r13w
  00199	75 04		 jne	 SHORT $LN41@ucs2lib_rs@3
  0019b	4d 8d 59 ff	 lea	 r11, QWORD PTR [r9-1]
$LN41@ucs2lib_rs@3:
  0019f	49 ff c9	 dec	 r9
  001a2	4d 85 c9	 test	 r9, r9
  001a5	7f d9		 jg	 SHORT $LL42@ucs2lib_rs@3
$LN40@ucs2lib_rs@3:
  001a7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  001af	4c 8d 04 1b	 lea	 r8, QWORD PTR [rbx+rbx]
  001b3	4c 8d 0c 36	 lea	 r9, QWORD PTR [rsi+rsi]
  001b7	4c 2b c0	 sub	 r8, rax
  001ba	4f 8d 24 1b	 lea	 r12, QWORD PTR [r11+r11]
  001be	4c 03 c5	 add	 r8, rbp
$LL38@ucs2lib_rs@3:
  001c1	66 44 39 6c 5d
	00		 cmp	 WORD PTR [rbp+rbx*2], r13w
  001c7	75 42		 jne	 SHORT $LN35@ucs2lib_rs@3
  001c9	48 8b d7	 mov	 rdx, rdi
  001cc	48 85 ff	 test	 rdi, rdi
  001cf	7e 1a		 jle	 SHORT $LN121@ucs2lib_rs@3
  001d1	48 8d 0c 78	 lea	 rcx, QWORD PTR [rax+rdi*2]
$LL34@ucs2lib_rs@3:
  001d5	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  001d8	66 41 39 04 08	 cmp	 WORD PTR [r8+rcx], ax
  001dd	75 0c		 jne	 SHORT $LN121@ucs2lib_rs@3
  001df	48 ff ca	 dec	 rdx
  001e2	48 83 e9 02	 sub	 rcx, 2
  001e6	48 85 d2	 test	 rdx, rdx
  001e9	7f ea		 jg	 SHORT $LL34@ucs2lib_rs@3
$LN121@ucs2lib_rs@3:
  001eb	48 85 d2	 test	 rdx, rdx
  001ee	74 4a		 je	 SHORT $LN123@ucs2lib_rs@3
  001f0	48 85 db	 test	 rbx, rbx
  001f3	7e 0e		 jle	 SHORT $LN29@ucs2lib_rs@3
  001f5	0f b7 44 5d fe	 movzx	 eax, WORD PTR [rbp+rbx*2-2]
  001fa	83 e0 1f	 and	 eax, 31
  001fd	41 0f a3 c2	 bt	 r10d, eax
  00201	73 1b		 jae	 SHORT $LN127@ucs2lib_rs@3
$LN29@ucs2lib_rs@3:
  00203	49 2b db	 sub	 rbx, r11
  00206	4d 2b c4	 sub	 r8, r12
  00209	eb 19		 jmp	 SHORT $LN122@ucs2lib_rs@3
$LN35@ucs2lib_rs@3:
  0020b	48 85 db	 test	 rbx, rbx
  0020e	7e 1c		 jle	 SHORT $LN37@ucs2lib_rs@3
  00210	0f b7 44 5d fe	 movzx	 eax, WORD PTR [rbp+rbx*2-2]
  00215	83 e0 1f	 and	 eax, 31
  00218	41 0f a3 c2	 bt	 r10d, eax
  0021c	72 06		 jb	 SHORT $LN122@ucs2lib_rs@3
$LN127@ucs2lib_rs@3:
  0021e	48 2b de	 sub	 rbx, rsi
  00221	4d 2b c1	 sub	 r8, r9
$LN122@ucs2lib_rs@3:
  00224	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
$LN37@ucs2lib_rs@3:
  0022c	49 83 e8 02	 sub	 r8, 2
  00230	48 ff cb	 dec	 rbx
  00233	79 8c		 jns	 SHORT $LL38@ucs2lib_rs@3
  00235	e9 da fe ff ff	 jmp	 $LN113@ucs2lib_rs@3
$LN123@ucs2lib_rs@3:

; 291  : {

  0023a	4c 8b a4 24 98
	00 00 00	 mov	 r12, QWORD PTR sep$[rsp]
  00242	4c 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]
$LN105@ucs2lib_rs@3:

; 309  :         if (pos < 0)

  0024a	48 85 db	 test	 rbx, rbx
  0024d	0f 88 c1 fe ff
	ff		 js	 $LN113@ucs2lib_rs@3

; 310  :             break;
; 311  :         SPLIT_ADD(str, pos + sep_len, j);

  00253	48 8d 04 33	 lea	 rax, QWORD PTR [rbx+rsi]
  00257	4c 2b fb	 sub	 r15, rbx
  0025a	4c 2b fe	 sub	 r15, rsi
  0025d	48 8d 4c 45 00	 lea	 rcx, QWORD PTR [rbp+rax*2]
  00262	49 8b d7	 mov	 rdx, r15
  00265	e8 00 00 00 00	 call	 _PyUnicode_FromUCS2
  0026a	48 8b f8	 mov	 rdi, rax
  0026d	48 85 c0	 test	 rax, rax
  00270	74 45		 je	 SHORT $onError$123000
  00272	49 83 fe 0c	 cmp	 r14, 12
  00276	7d 0a		 jge	 SHORT $LN12@ucs2lib_rs@3
  00278	49 8b 4d 70	 mov	 rcx, QWORD PTR [r13+112]
  0027c	4a 89 04 f1	 mov	 QWORD PTR [rcx+r14*8], rax
  00280	eb 17		 jmp	 SHORT $LN9@ucs2lib_rs@3
$LN12@ucs2lib_rs@3:
  00282	48 8b d0	 mov	 rdx, rax
  00285	49 8b cd	 mov	 rcx, r13
  00288	e8 00 00 00 00	 call	 PyList_Append
  0028d	48 8b cf	 mov	 rcx, rdi
  00290	85 c0		 test	 eax, eax
  00292	75 1e		 jne	 SHORT $LN108@ucs2lib_rs@3
  00294	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@ucs2lib_rs@3:

; 312  :         j = pos;

  00299	4c 8b fb	 mov	 r15, rbx
  0029c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR maxcount$1$[rsp]
  002a1	49 ff c6	 inc	 r14
  002a4	48 85 db	 test	 rbx, rbx
  002a7	0f 8f 23 fe ff
	ff		 jg	 $LL16@ucs2lib_rs@3

; 324  :     }
; 325  :     FIX_PREALLOC_SIZE(list);
; 326  :     if (PyList_Reverse(list) < 0)

  002ad	e9 62 fe ff ff	 jmp	 $LN113@ucs2lib_rs@3
$LN108@ucs2lib_rs@3:

; 310  :             break;
; 311  :         SPLIT_ADD(str, pos + sep_len, j);

  002b2	e8 00 00 00 00	 call	 _Py_DecRef
$onError$123000:

; 329  : 
; 330  :   onError:
; 331  :     Py_DECREF(list);

  002b7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR list$1$[rsp]
  002bf	e8 00 00 00 00	 call	 _Py_DecRef
$LN126@ucs2lib_rs@3:

; 332  :     return NULL;

  002c4	33 c0		 xor	 eax, eax
$LN125@ucs2lib_rs@3:
  002c6	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR [rsp+136]
  002ce	4c 8b 6c 24 40	 mov	 r13, QWORD PTR [rsp+64]

; 333  : }

  002d3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002d7	41 5f		 pop	 r15
  002d9	41 5e		 pop	 r14
  002db	41 5c		 pop	 r12
  002dd	5f		 pop	 rdi
  002de	5e		 pop	 rsi
  002df	5d		 pop	 rbp
  002e0	c3		 ret	 0
$LN8@ucs2lib_rs@3:

; 321  : #endif
; 322  :     {
; 323  :         SPLIT_ADD(str, 0, j);

  002e1	49 8b d7	 mov	 rdx, r15
  002e4	48 8b cd	 mov	 rcx, rbp
  002e7	e8 00 00 00 00	 call	 _PyUnicode_FromUCS2
  002ec	48 8b d8	 mov	 rbx, rax
  002ef	48 85 c0	 test	 rax, rax
  002f2	74 c3		 je	 SHORT $onError$123000
  002f4	4c 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]
  002fc	49 83 fe 0c	 cmp	 r14, 12
  00300	7d 0a		 jge	 SHORT $LN5@ucs2lib_rs@3
  00302	49 8b 4d 70	 mov	 rcx, QWORD PTR [r13+112]
  00306	4a 89 04 f1	 mov	 QWORD PTR [rcx+r14*8], rax
  0030a	eb 17		 jmp	 SHORT $LN2@ucs2lib_rs@3
$LN5@ucs2lib_rs@3:
  0030c	48 8b d0	 mov	 rdx, rax
  0030f	49 8b cd	 mov	 rcx, r13
  00312	e8 00 00 00 00	 call	 PyList_Append
  00317	48 8b cb	 mov	 rcx, rbx
  0031a	85 c0		 test	 eax, eax
  0031c	75 94		 jne	 SHORT $LN108@ucs2lib_rs@3
  0031e	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@ucs2lib_rs@3:
  00323	49 ff c6	 inc	 r14
$LN7@ucs2lib_rs@3:

; 324  :     }
; 325  :     FIX_PREALLOC_SIZE(list);
; 326  :     if (PyList_Reverse(list) < 0)

  00326	49 8b cd	 mov	 rcx, r13
  00329	4d 89 75 60	 mov	 QWORD PTR [r13+96], r14
  0032d	e8 00 00 00 00	 call	 PyList_Reverse
  00332	85 c0		 test	 eax, eax
  00334	78 81		 js	 SHORT $onError$123000

; 327  :         goto onError;
; 328  :     return list;

  00336	49 8b c5	 mov	 rax, r13
  00339	eb 8b		 jmp	 SHORT $LN125@ucs2lib_rs@3
ucs2lib_rsplit ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ucs2lib_splitlines DD imagerel ucs2lib_splitlines
	DD	imagerel ucs2lib_splitlines+53
	DD	imagerel $unwind$ucs2lib_splitlines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ucs2lib_splitlines DD imagerel ucs2lib_splitlines+53
	DD	imagerel ucs2lib_splitlines+443
	DD	imagerel $chain$2$ucs2lib_splitlines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ucs2lib_splitlines DD imagerel ucs2lib_splitlines+443
	DD	imagerel ucs2lib_splitlines+480
	DD	imagerel $chain$4$ucs2lib_splitlines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ucs2lib_splitlines DD 060021H
	DD	0ef400H
	DD	0d7400H
	DD	0c3400H
	DD	imagerel ucs2lib_splitlines
	DD	imagerel ucs2lib_splitlines+53
	DD	imagerel $unwind$ucs2lib_splitlines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ucs2lib_splitlines DD 061121H
	DD	0ef411H
	DD	0d740aH
	DD	0c3405H
	DD	imagerel ucs2lib_splitlines
	DD	imagerel ucs2lib_splitlines+53
	DD	imagerel $unwind$ucs2lib_splitlines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_splitlines DD 060d01H
	DD	0e009520dH
	DD	0c005d007H
	DD	050026003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs2lib_splitlines
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
keepends$ = 120
ucs2lib_splitlines PROC					; COMDAT

; 339  : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000d	4c 8b e9	 mov	 r13, rcx

; 340  :     /* This does not use the preallocated list because splitlines is
; 341  :        usually run with hundreds of newlines.  The overhead of
; 342  :        switching between PyList_SET_ITEM and append causes about a
; 343  :        2-3% slowdown for that common case.  A smarter implementation
; 344  :        could move the if check out, so the SET_ITEMs are done first
; 345  :        and the appends only done when the prealloc buffer is full.
; 346  :        That's too much work for little gain.*/
; 347  : 
; 348  :     register Py_ssize_t i;
; 349  :     register Py_ssize_t j;
; 350  :     PyObject *list = PyList_New(0);

  00010	33 c9		 xor	 ecx, ecx
  00012	45 8b f1	 mov	 r14d, r9d
  00015	49 8b f0	 mov	 rsi, r8
  00018	48 8b ea	 mov	 rbp, rdx
  0001b	e8 00 00 00 00	 call	 PyList_New
  00020	4c 8b e0	 mov	 r12, rax

; 351  :     PyObject *sub;
; 352  : 
; 353  :     if (list == NULL)

  00023	48 85 c0	 test	 rax, rax
  00026	75 0d		 jne	 SHORT $LN14@ucs2lib_sp@4

; 389  : }

  00028	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002c	41 5e		 pop	 r14
  0002e	41 5d		 pop	 r13
  00030	41 5c		 pop	 r12
  00032	5e		 pop	 rsi
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
$LN14@ucs2lib_sp@4:
  00035	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  0003a	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi

; 354  :         return NULL;
; 355  : 
; 356  :     for (i = j = 0; i < str_len; ) {

  0003f	33 ff		 xor	 edi, edi
  00041	4c 89 7c 24 70	 mov	 QWORD PTR [rsp+112], r15
  00046	8b df		 mov	 ebx, edi
  00048	48 85 f6	 test	 rsi, rsi
  0004b	0f 8e 4b 01 00
	00		 jle	 $LN12@ucs2lib_sp@4
  00051	41 bf 80 00 00
	00		 mov	 r15d, 128		; 00000080H
$LN48@ucs2lib_sp@4:
  00057	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyUnicode_Type
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ascii_linebreak

; 357  :         Py_ssize_t eol;
; 358  : 
; 359  :         /* Find a line and append it */
; 360  :         while (i < str_len && !STRINGLIB_ISLINEBREAK(str[i]))

  00065	48 3b de	 cmp	 rbx, rsi
  00068	7d 50		 jge	 SHORT $LN40@ucs2lib_sp@4
  0006a	66 0f 1f 44 00
	00		 npad	 6
$LL11@ucs2lib_sp@4:
  00070	0f b7 44 5d 00	 movzx	 eax, WORD PTR [rbp+rbx*2]
  00075	66 41 3b c7	 cmp	 ax, r15w
  00079	73 0d		 jae	 SHORT $LN19@ucs2lib_sp@4
  0007b	0f b7 c0	 movzx	 eax, ax
  0007e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00082	85 c0		 test	 eax, eax
  00084	75 2d		 jne	 SHORT $LN42@ucs2lib_sp@4
  00086	eb 23		 jmp	 SHORT $LN39@ucs2lib_sp@4
$LN19@ucs2lib_sp@4:
  00088	0f b7 c8	 movzx	 ecx, ax
  0008b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR bloom_linebreak
  00091	8b d1		 mov	 edx, ecx
  00093	83 e2 1f	 and	 edx, 31
  00096	0f a3 d0	 bt	 eax, edx
  00099	73 09		 jae	 SHORT $LN44@ucs2lib_sp@4
  0009b	e8 00 00 00 00	 call	 _PyUnicode_IsLinebreak
  000a0	85 c0		 test	 eax, eax
  000a2	75 0f		 jne	 SHORT $LN42@ucs2lib_sp@4
$LN44@ucs2lib_sp@4:
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ascii_linebreak
$LN39@ucs2lib_sp@4:

; 361  :             i++;

  000ab	48 ff c3	 inc	 rbx
  000ae	48 3b de	 cmp	 rbx, rsi
  000b1	7c bd		 jl	 SHORT $LL11@ucs2lib_sp@4
$LN42@ucs2lib_sp@4:
  000b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyUnicode_Type
$LN40@ucs2lib_sp@4:

; 362  : 
; 363  :         /* Skip the line break reading CRLF as one line break */
; 364  :         eol = i;

  000ba	48 8b d3	 mov	 rdx, rbx

; 365  :         if (i < str_len) {

  000bd	48 3b de	 cmp	 rbx, rsi
  000c0	7d 29		 jge	 SHORT $LN6@ucs2lib_sp@4

; 366  :             if (str[i] == '\r' && i + 1 < str_len && str[i+1] == '\n')

  000c2	66 83 7c 5d 00
	0d		 cmp	 WORD PTR [rbp+rbx*2], 13
  000c8	75 17		 jne	 SHORT $LN8@ucs2lib_sp@4
  000ca	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
  000ce	48 3b c6	 cmp	 rax, rsi
  000d1	7d 0e		 jge	 SHORT $LN8@ucs2lib_sp@4
  000d3	66 83 7c 5d 02
	0a		 cmp	 WORD PTR [rbp+rbx*2+2], 10
  000d9	75 06		 jne	 SHORT $LN8@ucs2lib_sp@4

; 367  :                 i += 2;

  000db	48 83 c3 02	 add	 rbx, 2

; 368  :             else

  000df	eb 03		 jmp	 SHORT $LN7@ucs2lib_sp@4
$LN8@ucs2lib_sp@4:

; 369  :                 i++;

  000e1	48 ff c3	 inc	 rbx
$LN7@ucs2lib_sp@4:

; 370  :             if (keepends)

  000e4	45 85 f6	 test	 r14d, r14d
  000e7	48 0f 45 d3	 cmovne	 rdx, rbx
$LN6@ucs2lib_sp@4:

; 371  :                 eol = i;
; 372  :         }
; 373  : #ifndef STRINGLIB_MUTABLE
; 374  :         if (j == 0 && eol == str_len && STRINGLIB_CHECK_EXACT(str_obj)) {

  000eb	48 85 ff	 test	 rdi, rdi
  000ee	75 0f		 jne	 SHORT $LN5@ucs2lib_sp@4
  000f0	48 3b d6	 cmp	 rdx, rsi
  000f3	75 0a		 jne	 SHORT $LN5@ucs2lib_sp@4
  000f5	4d 39 45 58	 cmp	 QWORD PTR [r13+88], r8
  000f9	0f 84 bc 00 00
	00		 je	 $LN34@ucs2lib_sp@4
$LN5@ucs2lib_sp@4:

; 379  :         }
; 380  : #endif
; 381  :         SPLIT_APPEND(str, j, eol);

  000ff	48 8d 4c 7d 00	 lea	 rcx, QWORD PTR [rbp+rdi*2]
  00104	48 2b d7	 sub	 rdx, rdi
  00107	e8 00 00 00 00	 call	 _PyUnicode_FromUCS2
  0010c	48 8b f8	 mov	 rdi, rax
  0010f	48 85 c0	 test	 rax, rax
  00112	0f 84 bc 00 00
	00		 je	 $onError$123058
  00118	48 8b d0	 mov	 rdx, rax
  0011b	49 8b cc	 mov	 rcx, r12
  0011e	e8 00 00 00 00	 call	 PyList_Append
  00123	85 c0		 test	 eax, eax
  00125	0f 85 a1 00 00
	00		 jne	 $LN36@ucs2lib_sp@4
  0012b	e8 00 00 00 00	 call	 _Py_PXCTX
  00130	85 c0		 test	 eax, eax
  00132	75 5c		 jne	 SHORT $LN31@ucs2lib_sp@4
  00134	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00138	a8 20		 test	 al, 32			; 00000020H
  0013a	75 4c		 jne	 SHORT $LN25@ucs2lib_sp@4
  0013c	84 c0		 test	 al, al
  0013e	78 48		 js	 SHORT $LN25@ucs2lib_sp@4
  00140	a8 02		 test	 al, 2
  00142	75 4c		 jne	 SHORT $LN31@ucs2lib_sp@4
  00144	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00148	75 46		 jne	 SHORT $LN31@ucs2lib_sp@4
  0014a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00151	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00158	4c 8b cf	 mov	 r9, rdi
  0015b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00161	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00169	e8 00 00 00 00	 call	 _PyParallel_Guard
  0016e	48 8b cf	 mov	 rcx, rdi
  00171	85 c0		 test	 eax, eax
  00173	74 07		 je	 SHORT $LN30@ucs2lib_sp@4
  00175	e8 00 00 00 00	 call	 _Px_Dealloc
  0017a	eb 14		 jmp	 SHORT $LN31@ucs2lib_sp@4
$LN30@ucs2lib_sp@4:
  0017c	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00180	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00186	eb 08		 jmp	 SHORT $LN31@ucs2lib_sp@4
$LN25@ucs2lib_sp@4:
  00188	48 8b cf	 mov	 rcx, rdi
  0018b	e8 00 00 00 00	 call	 Px_DecRef
$LN31@ucs2lib_sp@4:

; 382  :         j = i;

  00190	48 8b fb	 mov	 rdi, rbx
  00193	48 3b de	 cmp	 rbx, rsi
  00196	0f 8c bb fe ff
	ff		 jl	 $LN48@ucs2lib_sp@4
$LN12@ucs2lib_sp@4:

; 383  :     }
; 384  :     return list;

  0019c	49 8b c4	 mov	 rax, r12
$LN47@ucs2lib_sp@4:
  0019f	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  001a4	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  001a9	4c 8b 7c 24 70	 mov	 r15, QWORD PTR [rsp+112]

; 389  : }

  001ae	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b2	41 5e		 pop	 r14
  001b4	41 5d		 pop	 r13
  001b6	41 5c		 pop	 r12
  001b8	5e		 pop	 rsi
  001b9	5d		 pop	 rbp
  001ba	c3		 ret	 0
$LN34@ucs2lib_sp@4:

; 375  :             /* No linebreak in str_obj, so just use it as list[0] */
; 376  :             if (PyList_Append(list, str_obj))

  001bb	49 8b d5	 mov	 rdx, r13
  001be	49 8b cc	 mov	 rcx, r12
  001c1	e8 00 00 00 00	 call	 PyList_Append
  001c6	85 c0		 test	 eax, eax
  001c8	75 0a		 jne	 SHORT $onError$123058

; 377  :                 goto onError;
; 378  :             break;

  001ca	eb d0		 jmp	 SHORT $LN12@ucs2lib_sp@4
$LN36@ucs2lib_sp@4:

; 379  :         }
; 380  : #endif
; 381  :         SPLIT_APPEND(str, j, eol);

  001cc	48 8b cf	 mov	 rcx, rdi
  001cf	e8 00 00 00 00	 call	 _Py_DecRef
$onError$123058:

; 385  : 
; 386  :   onError:
; 387  :     Py_DECREF(list);

  001d4	49 8b cc	 mov	 rcx, r12
  001d7	e8 00 00 00 00	 call	 _Py_DecRef

; 388  :     return NULL;

  001dc	33 c0		 xor	 eax, eax
  001de	eb bf		 jmp	 SHORT $LN47@ucs2lib_sp@4
ucs2lib_splitlines ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs4lib_partition DD imagerel ucs4lib_partition
	DD	imagerel ucs4lib_partition+81
	DD	imagerel $unwind$ucs4lib_partition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ucs4lib_partition DD imagerel ucs4lib_partition+81
	DD	imagerel ucs4lib_partition+116
	DD	imagerel $chain$0$ucs4lib_partition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$ucs4lib_partition DD imagerel ucs4lib_partition+116
	DD	imagerel ucs4lib_partition+406
	DD	imagerel $chain$5$ucs4lib_partition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$ucs4lib_partition DD imagerel ucs4lib_partition+406
	DD	imagerel ucs4lib_partition+820
	DD	imagerel $chain$7$ucs4lib_partition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$ucs4lib_partition DD 080021H
	DD	08e400H
	DD	097400H
	DD	0a5400H
	DD	0113400H
	DD	imagerel ucs4lib_partition
	DD	imagerel ucs4lib_partition+81
	DD	imagerel $unwind$ucs4lib_partition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$ucs4lib_partition DD 081221H
	DD	097412H
	DD	0a540dH
	DD	0113408H
	DD	08e400H
	DD	imagerel ucs4lib_partition
	DD	imagerel ucs4lib_partition+81
	DD	imagerel $unwind$ucs4lib_partition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ucs4lib_partition DD 020521H
	DD	08e405H
	DD	imagerel ucs4lib_partition
	DD	imagerel ucs4lib_partition+81
	DD	imagerel $unwind$ucs4lib_partition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_partition DD 051501H
	DD	0f011a215H
	DD	0c00dd00fH
	DD	0600bH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\partition.h
xdata	ENDS
;	COMDAT ucs4lib_partition
_TEXT	SEGMENT
skip$1$ = 32
w$1$ = 48
str_obj$ = 128
str$ = 136
str_len$ = 144
sep_obj$ = 152
sep$ = 160
tv689 = 168
sep_len$ = 168
ucs4lib_partition PROC					; COMDAT

; 12   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 57		 push	 r15
  00011	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 13   :     PyObject* out;
; 14   :     Py_ssize_t pos;
; 15   : 
; 16   :     if (sep_len == 0) {

  00015	4c 8b a4 24 a8
	00 00 00	 mov	 r12, QWORD PTR sep_len$[rsp]
  0001d	49 8b f1	 mov	 rsi, r9
  00020	4d 8b e8	 mov	 r13, r8
  00023	4c 8b fa	 mov	 r15, rdx
  00026	4d 85 e4	 test	 r12, r12
  00029	75 21		 jne	 SHORT $LN4@ucs4lib_pa

; 17   :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00039	e8 00 00 00 00	 call	 PyErr_SetString

; 18   :         return NULL;

  0003e	33 c0		 xor	 eax, eax

; 52   :     }
; 53   : 
; 54   :     return out;
; 55   : }

  00040	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00044	41 5f		 pop	 r15
  00046	41 5d		 pop	 r13
  00048	41 5c		 pop	 r12
  0004a	5e		 pop	 rsi
  0004b	c3		 ret	 0
$LN4@ucs4lib_pa:

; 19   :     }
; 20   : 
; 21   :     out = PyTuple_New(3);

  0004c	b9 03 00 00 00	 mov	 ecx, 3
  00051	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  00056	e8 00 00 00 00	 call	 PyTuple_New
  0005b	4c 8b f0	 mov	 r14, rax

; 22   :     if (!out)

  0005e	48 85 c0	 test	 rax, rax
  00061	75 11		 jne	 SHORT $LN3@ucs4lib_pa
  00063	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]

; 52   :     }
; 53   : 
; 54   :     return out;
; 55   : }

  00068	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0006c	41 5f		 pop	 r15
  0006e	41 5d		 pop	 r13
  00070	41 5c		 pop	 r12
  00072	5e		 pop	 rsi
  00073	c3		 ret	 0
$LN3@ucs4lib_pa:
  00074	48 89 9c 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbx
  0007c	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00081	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 23   :         return NULL;
; 24   : 
; 25   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_SEARCH);

  00086	49 8b fd	 mov	 rdi, r13
  00089	49 2b fc	 sub	 rdi, r12
  0008c	48 89 7c 24 30	 mov	 QWORD PTR w$1$[rsp], rdi
  00091	0f 88 9b 00 00
	00		 js	 $LN96@ucs4lib_pa
  00097	49 83 fc 01	 cmp	 r12, 1
  0009b	0f 8f f5 00 00
	00		 jg	 $LN66@ucs4lib_pa
  000a1	4d 85 e4	 test	 r12, r12
  000a4	0f 8e 88 00 00
	00		 jle	 $LN96@ucs4lib_pa
  000aa	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  000b2	49 83 fd 0a	 cmp	 r13, 10
  000b6	7e 5b		 jle	 SHORT $LN63@ucs4lib_pa
  000b8	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000bb	84 c9		 test	 cl, cl
  000bd	74 54		 je	 SHORT $LN63@ucs4lib_pa
  000bf	8b 30		 mov	 esi, DWORD PTR [rax]
  000c1	4b 8d 3c af	 lea	 rdi, QWORD PTR [r15+r13*4]
  000c5	49 8b df	 mov	 rbx, r15
  000c8	4c 3b ff	 cmp	 r15, rdi
  000cb	73 31		 jae	 SHORT $LN75@ucs4lib_pa
  000cd	0f b6 e9	 movzx	 ebp, cl
$LL76@ucs4lib_pa:
  000d0	4c 8b c7	 mov	 r8, rdi
  000d3	8b d5		 mov	 edx, ebp
  000d5	48 8b cb	 mov	 rcx, rbx
  000d8	4c 2b c3	 sub	 r8, rbx
  000db	49 83 e0 fc	 and	 r8, -4
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000e5	48 8b d8	 mov	 rbx, rax
  000e8	48 85 c0	 test	 rax, rax
  000eb	74 11		 je	 SHORT $LN75@ucs4lib_pa
  000ed	48 83 e3 fc	 and	 rbx, -4
  000f1	39 33		 cmp	 DWORD PTR [rbx], esi
  000f3	74 12		 je	 SHORT $LN86@ucs4lib_pa
  000f5	48 83 c3 04	 add	 rbx, 4
  000f9	48 3b df	 cmp	 rbx, rdi
  000fc	72 d2		 jb	 SHORT $LL76@ucs4lib_pa
$LN75@ucs4lib_pa:
  000fe	48 83 cb ff	 or	 rbx, -1
  00102	e9 cb 01 00 00	 jmp	 $LN71@ucs4lib_pa
$LN86@ucs4lib_pa:
  00107	49 2b df	 sub	 rbx, r15
  0010a	48 c1 fb 02	 sar	 rbx, 2
  0010e	e9 bf 01 00 00	 jmp	 $LN71@ucs4lib_pa
$LN63@ucs4lib_pa:
  00113	33 db		 xor	 ebx, ebx
  00115	4d 85 ed	 test	 r13, r13
  00118	7e 18		 jle	 SHORT $LN96@ucs4lib_pa
  0011a	8b 00		 mov	 eax, DWORD PTR [rax]
  0011c	0f 1f 40 00	 npad	 4
$LL54@ucs4lib_pa:
  00120	41 39 04 9f	 cmp	 DWORD PTR [r15+rbx*4], eax
  00124	0f 84 b0 01 00
	00		 je	 $LN69@ucs4lib_pa
  0012a	48 ff c3	 inc	 rbx
  0012d	49 3b dd	 cmp	 rbx, r13
  00130	7c ee		 jl	 SHORT $LL54@ucs4lib_pa
$LN96@ucs4lib_pa:

; 28   : #if STRINGLIB_MUTABLE
; 29   :         PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, str_len));
; 30   :         PyTuple_SET_ITEM(out, 1, STRINGLIB_NEW(NULL, 0));
; 31   :         PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(NULL, 0));
; 32   : #else
; 33   :         Py_INCREF(str_obj);

  00132	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR str_obj$[rsp]
  0013a	48 8b cb	 mov	 rcx, rbx
  0013d	e8 00 00 00 00	 call	 _Py_IncRef

; 34   :         PyTuple_SET_ITEM(out, 0, (PyObject*) str_obj);
; 35   :         Py_INCREF(STRINGLIB_EMPTY);

  00142	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  00149	49 89 5e 70	 mov	 QWORD PTR [r14+112], rbx
  0014d	e8 00 00 00 00	 call	 _Py_IncRef

; 36   :         PyTuple_SET_ITEM(out, 1, (PyObject*) STRINGLIB_EMPTY);

  00152	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  00159	49 89 4e 78	 mov	 QWORD PTR [r14+120], rcx

; 37   :         Py_INCREF(STRINGLIB_EMPTY);

  0015d	e8 00 00 00 00	 call	 _Py_IncRef

; 38   :         PyTuple_SET_ITEM(out, 2, (PyObject*) STRINGLIB_EMPTY);

  00162	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR unicode_empty
  00169	4d 89 9e 80 00
	00 00		 mov	 QWORD PTR [r14+128], r11
$LN1@ucs4lib_pa:

; 39   : #endif
; 40   :         return out;

  00170	49 8b c6	 mov	 rax, r14
$LN101@ucs4lib_pa:
  00173	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00178	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0017d	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR [rsp+136]
  00185	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]

; 52   :     }
; 53   : 
; 54   :     return out;
; 55   : }

  0018a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0018e	41 5f		 pop	 r15
  00190	41 5d		 pop	 r13
  00192	41 5c		 pop	 r12
  00194	5e		 pop	 rsi
  00195	c3		 ret	 0

; 23   :         return NULL;
; 24   : 
; 25   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_SEARCH);

$LN66@ucs4lib_pa:
  00196	33 db		 xor	 ebx, ebx
  00198	49 8d 74 24 ff	 lea	 rsi, QWORD PTR [r12-1]
  0019d	48 8d 56 ff	 lea	 rdx, QWORD PTR [rsi-1]
  001a1	8b eb		 mov	 ebp, ebx
  001a3	44 8b d3	 mov	 r10d, ebx
  001a6	44 8d 4b 01	 lea	 r9d, QWORD PTR [rbx+1]
  001aa	48 89 54 24 20	 mov	 QWORD PTR skip$1$[rsp], rdx
  001af	48 85 f6	 test	 rsi, rsi
  001b2	7e 54		 jle	 SHORT $LN42@ucs4lib_pa
  001b4	4c 8b b4 24 a0
	00 00 00	 mov	 r14, QWORD PTR sep$[rsp]
  001bc	4c 8d 66 ff	 lea	 r12, QWORD PTR [rsi-1]
  001c0	41 8b 3c b6	 mov	 edi, DWORD PTR [r14+rsi*4]
  001c4	4d 8b dc	 mov	 r11, r12
  001c7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL44@ucs4lib_pa:
  001d0	47 8b 04 96	 mov	 r8d, DWORD PTR [r14+r10*4]
  001d4	41 8b d1	 mov	 edx, r9d
  001d7	41 8b c8	 mov	 ecx, r8d
  001da	83 e1 1f	 and	 ecx, 31
  001dd	d3 e2		 shl	 edx, cl
  001df	0b ea		 or	 ebp, edx
  001e1	44 3b c7	 cmp	 r8d, edi
  001e4	4d 0f 44 e3	 cmove	 r12, r11
  001e8	49 ff c2	 inc	 r10
  001eb	49 ff cb	 dec	 r11
  001ee	4c 3b d6	 cmp	 r10, rsi
  001f1	7c dd		 jl	 SHORT $LL44@ucs4lib_pa
  001f3	48 8b 7c 24 30	 mov	 rdi, QWORD PTR w$1$[rsp]
  001f8	4c 89 64 24 20	 mov	 QWORD PTR skip$1$[rsp], r12
  001fd	4c 8b a4 24 a8
	00 00 00	 mov	 r12, QWORD PTR sep_len$[rsp]
  00205	4c 8b f0	 mov	 r14, rax
$LN42@ucs4lib_pa:
  00208	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  00210	4c 8b d3	 mov	 r10, rbx
  00213	8b 0c b0	 mov	 ecx, DWORD PTR [rax+rsi*4]
  00216	83 e1 1f	 and	 ecx, 31
  00219	41 d3 e1	 shl	 r9d, cl
  0021c	41 0b e9	 or	 ebp, r9d
  0021f	48 85 ff	 test	 rdi, rdi
  00222	0f 88 0a ff ff
	ff		 js	 $LN96@ucs4lib_pa
  00228	4e 8d 1c a5 00
	00 00 00	 lea	 r11, QWORD PTR [r12*4]
  00230	4d 8b c7	 mov	 r8, r15
  00233	41 8b 4c 03 fc	 mov	 ecx, DWORD PTR [r11+rax-4]
  00238	4f 8d 0c 3b	 lea	 r9, QWORD PTR [r11+r15]
  0023c	4c 2b c0	 sub	 r8, rax
  0023f	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv689[rsp], ecx
$LL40@ucs4lib_pa:
  00246	41 39 49 fc	 cmp	 DWORD PTR [r9-4], ecx
  0024a	75 47		 jne	 SHORT $LN37@ucs4lib_pa
  0024c	48 8b d3	 mov	 rdx, rbx
  0024f	48 85 f6	 test	 rsi, rsi
  00252	7e 17		 jle	 SHORT $LN97@ucs4lib_pa
  00254	48 8b c8	 mov	 rcx, rax
$LL36@ucs4lib_pa:
  00257	8b 01		 mov	 eax, DWORD PTR [rcx]
  00259	41 39 04 08	 cmp	 DWORD PTR [r8+rcx], eax
  0025d	75 0c		 jne	 SHORT $LN97@ucs4lib_pa
  0025f	48 ff c2	 inc	 rdx
  00262	48 83 c1 04	 add	 rcx, 4
  00266	48 3b d6	 cmp	 rdx, rsi
  00269	7c ec		 jl	 SHORT $LL36@ucs4lib_pa
$LN97@ucs4lib_pa:
  0026b	48 3b d6	 cmp	 rdx, rsi
  0026e	74 5f		 je	 SHORT $LN89@ucs4lib_pa
  00270	41 8b 01	 mov	 eax, DWORD PTR [r9]
  00273	83 e0 1f	 and	 eax, 31
  00276	0f a3 c5	 bt	 ebp, eax
  00279	73 23		 jae	 SHORT $LN102@ucs4lib_pa
  0027b	48 8b 54 24 20	 mov	 rdx, QWORD PTR skip$1$[rsp]
  00280	4c 03 d2	 add	 r10, rdx
  00283	48 8d 04 95 00
	00 00 00	 lea	 rax, QWORD PTR [rdx*4]
  0028b	4c 03 c0	 add	 r8, rax
  0028e	4c 03 c8	 add	 r9, rax
  00291	eb 14		 jmp	 SHORT $LN39@ucs4lib_pa
$LN37@ucs4lib_pa:
  00293	41 8b 01	 mov	 eax, DWORD PTR [r9]
  00296	83 e0 1f	 and	 eax, 31
  00299	0f a3 c5	 bt	 ebp, eax
  0029c	72 09		 jb	 SHORT $LN39@ucs4lib_pa
$LN102@ucs4lib_pa:
  0029e	4d 03 d4	 add	 r10, r12
  002a1	4d 03 c3	 add	 r8, r11
  002a4	4d 03 cb	 add	 r9, r11
$LN39@ucs4lib_pa:
  002a7	49 ff c2	 inc	 r10
  002aa	49 83 c0 04	 add	 r8, 4
  002ae	49 83 c1 04	 add	 r9, 4
  002b2	4c 3b d7	 cmp	 r10, rdi
  002b5	0f 8f 77 fe ff
	ff		 jg	 $LN96@ucs4lib_pa
  002bb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  002c3	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv689[rsp]
  002ca	e9 77 ff ff ff	 jmp	 $LL40@ucs4lib_pa
$LN89@ucs4lib_pa:
  002cf	49 8b da	 mov	 rbx, r10
$LN71@ucs4lib_pa:
  002d2	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR sep_obj$[rsp]
$LN69@ucs4lib_pa:

; 26   : 
; 27   :     if (pos < 0) {

  002da	48 85 db	 test	 rbx, rbx
  002dd	0f 88 4f fe ff
	ff		 js	 $LN96@ucs4lib_pa

; 41   :     }
; 42   : 
; 43   :     PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, pos));

  002e3	48 8b d3	 mov	 rdx, rbx
  002e6	49 8b cf	 mov	 rcx, r15
  002e9	e8 00 00 00 00	 call	 _PyUnicode_FromUCS4

; 44   :     Py_INCREF(sep_obj);

  002ee	48 8b ce	 mov	 rcx, rsi
  002f1	49 89 46 70	 mov	 QWORD PTR [r14+112], rax
  002f5	e8 00 00 00 00	 call	 _Py_IncRef

; 45   :     PyTuple_SET_ITEM(out, 1, sep_obj);
; 46   :     pos += sep_len;

  002fa	49 03 dc	 add	 rbx, r12

; 47   :     PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str + pos, str_len - pos));

  002fd	4c 2b eb	 sub	 r13, rbx
  00300	49 8d 0c 9f	 lea	 rcx, QWORD PTR [r15+rbx*4]
  00304	49 89 76 78	 mov	 QWORD PTR [r14+120], rsi
  00308	49 8b d5	 mov	 rdx, r13
  0030b	e8 00 00 00 00	 call	 _PyUnicode_FromUCS4
  00310	49 89 86 80 00
	00 00		 mov	 QWORD PTR [r14+128], rax

; 48   : 
; 49   :     if (PyErr_Occurred()) {

  00317	e8 00 00 00 00	 call	 PyErr_Occurred
  0031c	48 85 c0	 test	 rax, rax
  0031f	0f 84 4b fe ff
	ff		 je	 $LN1@ucs4lib_pa

; 50   :         Py_DECREF(out);

  00325	49 8b ce	 mov	 rcx, r14
  00328	e8 00 00 00 00	 call	 _Py_DecRef

; 51   :         return NULL;

  0032d	33 c0		 xor	 eax, eax
  0032f	e9 3f fe ff ff	 jmp	 $LN101@ucs4lib_pa
ucs4lib_partition ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs4lib_rpartition DD imagerel ucs4lib_rpartition
	DD	imagerel ucs4lib_rpartition+84
	DD	imagerel $unwind$ucs4lib_rpartition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ucs4lib_rpartition DD imagerel ucs4lib_rpartition+84
	DD	imagerel ucs4lib_rpartition+118
	DD	imagerel $chain$0$ucs4lib_rpartition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$ucs4lib_rpartition DD imagerel ucs4lib_rpartition+118
	DD	imagerel ucs4lib_rpartition+288
	DD	imagerel $chain$5$ucs4lib_rpartition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$ucs4lib_rpartition DD imagerel ucs4lib_rpartition+288
	DD	imagerel ucs4lib_rpartition+611
	DD	imagerel $chain$7$ucs4lib_rpartition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$ucs4lib_rpartition DD 080021H
	DD	04f400H
	DD	05e400H
	DD	065400H
	DD	0d3400H
	DD	imagerel ucs4lib_rpartition
	DD	imagerel ucs4lib_rpartition+84
	DD	imagerel $unwind$ucs4lib_rpartition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$ucs4lib_rpartition DD 081521H
	DD	04f415H
	DD	05e40dH
	DD	0d3405H
	DD	065400H
	DD	imagerel ucs4lib_rpartition
	DD	imagerel ucs4lib_rpartition+84
	DD	imagerel $unwind$ucs4lib_rpartition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ucs4lib_rpartition DD 020521H
	DD	065405H
	DD	imagerel ucs4lib_rpartition
	DD	imagerel ucs4lib_rpartition+84
	DD	imagerel $unwind$ucs4lib_rpartition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_rpartition DD 051901H
	DD	0d0156219H
	DD	07011c013H
	DD	06010H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\partition.h
xdata	ENDS
;	COMDAT ucs4lib_rpartition
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
sep_obj$ = 120
sep$ = 128
sep_len$ = 136
ucs4lib_rpartition PROC					; COMDAT

; 62   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	41 54		 push	 r12
  00013	41 55		 push	 r13
  00015	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 63   :     PyObject* out;
; 64   :     Py_ssize_t pos;
; 65   : 
; 66   :     if (sep_len == 0) {

  00019	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR sep_len$[rsp]
  00021	4d 8b e9	 mov	 r13, r9
  00024	4d 8b e0	 mov	 r12, r8
  00027	48 8b f2	 mov	 rsi, rdx
  0002a	48 85 ff	 test	 rdi, rdi
  0002d	75 20		 jne	 SHORT $LN4@ucs4lib_rp

; 67   :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0002f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  0003d	e8 00 00 00 00	 call	 PyErr_SetString

; 68   :         return NULL;

  00042	33 c0		 xor	 eax, eax

; 102  :     }
; 103  : 
; 104  :     return out;
; 105  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	41 5d		 pop	 r13
  0004a	41 5c		 pop	 r12
  0004c	5f		 pop	 rdi
  0004d	5e		 pop	 rsi
  0004e	c3		 ret	 0
$LN4@ucs4lib_rp:

; 69   :     }
; 70   : 
; 71   :     out = PyTuple_New(3);

  0004f	b9 03 00 00 00	 mov	 ecx, 3
  00054	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00059	e8 00 00 00 00	 call	 PyTuple_New
  0005e	48 8b e8	 mov	 rbp, rax

; 72   :     if (!out)

  00061	48 85 c0	 test	 rax, rax
  00064	75 10		 jne	 SHORT $LN3@ucs4lib_rp
  00066	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 102  :     }
; 103  : 
; 104  :     return out;
; 105  : }

  0006b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006f	41 5d		 pop	 r13
  00071	41 5c		 pop	 r12
  00073	5f		 pop	 rdi
  00074	5e		 pop	 rsi
  00075	c3		 ret	 0
$LN3@ucs4lib_rp:
  00076	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx

; 73   :         return NULL;
; 74   : 
; 75   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_RSEARCH);

  0007b	49 8b dc	 mov	 rbx, r12
  0007e	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00083	48 2b df	 sub	 rbx, rdi
  00086	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  0008b	78 36		 js	 SHORT $LN92@ucs4lib_rp
  0008d	48 83 ff 01	 cmp	 rdi, 1
  00091	0f 8f 89 00 00
	00		 jg	 $LN66@ucs4lib_rp
  00097	48 85 ff	 test	 rdi, rdi
  0009a	7e 27		 jle	 SHORT $LN92@ucs4lib_rp
  0009c	49 8d 5c 24 ff	 lea	 rbx, QWORD PTR [r12-1]
  000a1	48 83 fb ff	 cmp	 rbx, -1
  000a5	7e 1c		 jle	 SHORT $LN92@ucs4lib_rp
  000a7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  000af	8b 08		 mov	 ecx, DWORD PTR [rax]
$LL49@ucs4lib_rp:
  000b1	39 0c 9e	 cmp	 DWORD PTR [rsi+rbx*4], ecx
  000b4	0f 84 4e 01 00
	00		 je	 $LN69@ucs4lib_rp
  000ba	48 ff cb	 dec	 rbx
  000bd	48 83 fb ff	 cmp	 rbx, -1
  000c1	7f ee		 jg	 SHORT $LL49@ucs4lib_rp
$LN92@ucs4lib_rp:

; 78   : #if STRINGLIB_MUTABLE
; 79   :         PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(NULL, 0));
; 80   :         PyTuple_SET_ITEM(out, 1, STRINGLIB_NEW(NULL, 0));
; 81   :         PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str, str_len));
; 82   : #else
; 83   :         Py_INCREF(STRINGLIB_EMPTY);

  000c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  000ca	e8 00 00 00 00	 call	 _Py_IncRef

; 84   :         PyTuple_SET_ITEM(out, 0, (PyObject*) STRINGLIB_EMPTY);

  000cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  000d6	48 89 4d 70	 mov	 QWORD PTR [rbp+112], rcx

; 85   :         Py_INCREF(STRINGLIB_EMPTY);

  000da	e8 00 00 00 00	 call	 _Py_IncRef

; 86   :         PyTuple_SET_ITEM(out, 1, (PyObject*) STRINGLIB_EMPTY);

  000df	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR unicode_empty

; 87   :         Py_INCREF(str_obj);

  000e6	48 8b 5c 24 60	 mov	 rbx, QWORD PTR str_obj$[rsp]
  000eb	4c 89 5d 78	 mov	 QWORD PTR [rbp+120], r11
  000ef	48 8b cb	 mov	 rcx, rbx
  000f2	e8 00 00 00 00	 call	 _Py_IncRef

; 88   :         PyTuple_SET_ITEM(out, 2, (PyObject*) str_obj);

  000f7	48 89 9d 80 00
	00 00		 mov	 QWORD PTR [rbp+128], rbx
$LN1@ucs4lib_rp:

; 89   : #endif
; 90   :         return out;

  000fe	48 8b c5	 mov	 rax, rbp
$LN98@ucs4lib_rp:
  00101	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]
  00106	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  0010b	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  00110	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 102  :     }
; 103  : 
; 104  :     return out;
; 105  : }

  00115	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00119	41 5d		 pop	 r13
  0011b	41 5c		 pop	 r12
  0011d	5f		 pop	 rdi
  0011e	5e		 pop	 rsi
  0011f	c3		 ret	 0

; 73   :         return NULL;
; 74   : 
; 75   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_RSEARCH);

$LN66@ucs4lib_rp:
  00120	4c 8b bc 24 80
	00 00 00	 mov	 r15, QWORD PTR sep$[rsp]
  00128	4c 8d 5f ff	 lea	 r11, QWORD PTR [rdi-1]
  0012c	41 bc 01 00 00
	00		 mov	 r12d, 1
  00132	45 8b 37	 mov	 r14d, DWORD PTR [r15]
  00135	4d 8d 53 ff	 lea	 r10, QWORD PTR [r11-1]
  00139	4d 8b cb	 mov	 r9, r11
  0013c	41 8b ce	 mov	 ecx, r14d
  0013f	83 e1 1f	 and	 ecx, 31
  00142	41 d3 e4	 shl	 r12d, cl
  00145	4d 85 db	 test	 r11, r11
  00148	7e 2b		 jle	 SHORT $LN22@ucs4lib_rp
  0014a	66 0f 1f 44 00
	00		 npad	 6
$LL24@ucs4lib_rp:
  00150	47 8b 04 8f	 mov	 r8d, DWORD PTR [r15+r9*4]
  00154	ba 01 00 00 00	 mov	 edx, 1
  00159	41 8b c8	 mov	 ecx, r8d
  0015c	83 e1 1f	 and	 ecx, 31
  0015f	d3 e2		 shl	 edx, cl
  00161	44 0b e2	 or	 r12d, edx
  00164	45 3b c6	 cmp	 r8d, r14d
  00167	75 04		 jne	 SHORT $LN23@ucs4lib_rp
  00169	4d 8d 51 ff	 lea	 r10, QWORD PTR [r9-1]
$LN23@ucs4lib_rp:
  0016d	49 ff c9	 dec	 r9
  00170	4d 85 c9	 test	 r9, r9
  00173	7f db		 jg	 SHORT $LL24@ucs4lib_rp
$LN22@ucs4lib_rp:
  00175	4c 8d 04 9d 00
	00 00 00	 lea	 r8, QWORD PTR [rbx*4]
  0017d	4c 8d 0c bd 00
	00 00 00	 lea	 r9, QWORD PTR [rdi*4]
  00185	4e 8d 2c 95 00
	00 00 00	 lea	 r13, QWORD PTR [r10*4]
  0018d	4d 2b c7	 sub	 r8, r15
  00190	4c 03 c6	 add	 r8, rsi
$LL20@ucs4lib_rp:
  00193	44 39 34 9e	 cmp	 DWORD PTR [rsi+rbx*4], r14d
  00197	75 3f		 jne	 SHORT $LN17@ucs4lib_rp
  00199	49 8b d3	 mov	 rdx, r11
  0019c	4d 85 db	 test	 r11, r11
  0019f	7e 18		 jle	 SHORT $LN93@ucs4lib_rp
  001a1	4b 8d 0c 9f	 lea	 rcx, QWORD PTR [r15+r11*4]
$LL16@ucs4lib_rp:
  001a5	8b 01		 mov	 eax, DWORD PTR [rcx]
  001a7	41 39 04 08	 cmp	 DWORD PTR [r8+rcx], eax
  001ab	75 0c		 jne	 SHORT $LN93@ucs4lib_rp
  001ad	48 ff ca	 dec	 rdx
  001b0	48 83 e9 04	 sub	 rcx, 4
  001b4	48 85 d2	 test	 rdx, rdx
  001b7	7f ec		 jg	 SHORT $LL16@ucs4lib_rp
$LN93@ucs4lib_rp:
  001b9	48 85 d2	 test	 rdx, rdx
  001bc	74 40		 je	 SHORT $LN94@ucs4lib_rp
  001be	48 85 db	 test	 rbx, rbx
  001c1	7e 0d		 jle	 SHORT $LN11@ucs4lib_rp
  001c3	8b 44 9e fc	 mov	 eax, DWORD PTR [rsi+rbx*4-4]
  001c7	83 e0 1f	 and	 eax, 31
  001ca	41 0f a3 c4	 bt	 r12d, eax
  001ce	73 1a		 jae	 SHORT $LN99@ucs4lib_rp
$LN11@ucs4lib_rp:
  001d0	49 2b da	 sub	 rbx, r10
  001d3	4d 2b c5	 sub	 r8, r13
  001d6	eb 18		 jmp	 SHORT $LN19@ucs4lib_rp
$LN17@ucs4lib_rp:
  001d8	48 85 db	 test	 rbx, rbx
  001db	7e 13		 jle	 SHORT $LN19@ucs4lib_rp
  001dd	8b 44 9e fc	 mov	 eax, DWORD PTR [rsi+rbx*4-4]
  001e1	83 e0 1f	 and	 eax, 31
  001e4	41 0f a3 c4	 bt	 r12d, eax
  001e8	72 06		 jb	 SHORT $LN19@ucs4lib_rp
$LN99@ucs4lib_rp:
  001ea	48 2b df	 sub	 rbx, rdi
  001ed	4d 2b c1	 sub	 r8, r9
$LN19@ucs4lib_rp:
  001f0	49 83 e8 04	 sub	 r8, 4
  001f4	48 ff cb	 dec	 rbx
  001f7	79 9a		 jns	 SHORT $LL20@ucs4lib_rp
  001f9	e9 c5 fe ff ff	 jmp	 $LN92@ucs4lib_rp
$LN94@ucs4lib_rp:

; 62   : {

  001fe	4c 8b 64 24 70	 mov	 r12, QWORD PTR str_len$[rsp]
  00203	4c 8b 6c 24 78	 mov	 r13, QWORD PTR sep_obj$[rsp]

; 73   :         return NULL;
; 74   : 
; 75   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_RSEARCH);

$LN69@ucs4lib_rp:

; 76   : 
; 77   :     if (pos < 0) {

  00208	48 85 db	 test	 rbx, rbx
  0020b	0f 88 b2 fe ff
	ff		 js	 $LN92@ucs4lib_rp

; 91   :     }
; 92   : 
; 93   :     PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, pos));

  00211	48 8b d3	 mov	 rdx, rbx
  00214	48 8b ce	 mov	 rcx, rsi
  00217	e8 00 00 00 00	 call	 _PyUnicode_FromUCS4

; 94   :     Py_INCREF(sep_obj);

  0021c	49 8b cd	 mov	 rcx, r13
  0021f	48 89 45 70	 mov	 QWORD PTR [rbp+112], rax
  00223	e8 00 00 00 00	 call	 _Py_IncRef

; 95   :     PyTuple_SET_ITEM(out, 1, sep_obj);
; 96   :     pos += sep_len;

  00228	48 8d 04 3b	 lea	 rax, QWORD PTR [rbx+rdi]

; 97   :     PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str + pos, str_len - pos));

  0022c	4c 2b e0	 sub	 r12, rax
  0022f	48 8d 0c 86	 lea	 rcx, QWORD PTR [rsi+rax*4]
  00233	4c 89 6d 78	 mov	 QWORD PTR [rbp+120], r13
  00237	49 8b d4	 mov	 rdx, r12
  0023a	e8 00 00 00 00	 call	 _PyUnicode_FromUCS4
  0023f	48 89 85 80 00
	00 00		 mov	 QWORD PTR [rbp+128], rax

; 98   : 
; 99   :     if (PyErr_Occurred()) {

  00246	e8 00 00 00 00	 call	 PyErr_Occurred
  0024b	48 85 c0	 test	 rax, rax
  0024e	0f 84 aa fe ff
	ff		 je	 $LN1@ucs4lib_rp

; 100  :         Py_DECREF(out);

  00254	48 8b cd	 mov	 rcx, rbp
  00257	e8 00 00 00 00	 call	 _Py_DecRef

; 101  :         return NULL;

  0025c	33 c0		 xor	 eax, eax
  0025e	e9 9e fe ff ff	 jmp	 $LN98@ucs4lib_rp
ucs4lib_rpartition ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ucs4lib_split_whitespace DD imagerel ucs4lib_split_whitespace
	DD	imagerel ucs4lib_split_whitespace+646
	DD	imagerel $unwind$ucs4lib_split_whitespace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_split_whitespace DD 0c6101H
	DD	0d7461H
	DD	0c3455H
	DD	0e5412H
	DD	0f00e5212H
	DD	0d00ae00cH
	DD	06006c008H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs4lib_split_whitespace
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
maxcount$ = 120
ucs4lib_split_whitespace PROC				; COMDAT

; 57   : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	41 56		 push	 r14
  0000c	41 57		 push	 r15
  0000e	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 58   :     Py_ssize_t i, j, count=0;

  00012	45 33 e4	 xor	 r12d, r12d
  00015	4c 8b f9	 mov	 r15, rcx
  00018	4d 8b e9	 mov	 r13, r9
  0001b	49 8b f0	 mov	 rsi, r8
  0001e	48 8b ea	 mov	 rbp, rdx

; 59   :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00021	41 8d 4c 24 0c	 lea	 ecx, QWORD PTR [r12+12]
  00026	49 83 f9 0c	 cmp	 r9, 12
  0002a	7d 04		 jge	 SHORT $LN27@ucs4lib_sp
  0002c	49 8d 49 01	 lea	 rcx, QWORD PTR [r9+1]
$LN27@ucs4lib_sp:
  00030	e8 00 00 00 00	 call	 PyList_New
  00035	4c 8b f0	 mov	 r14, rax

; 60   :     PyObject *sub;
; 61   : 
; 62   :     if (list == NULL)

  00038	48 85 c0	 test	 rax, rax
  0003b	75 13		 jne	 SHORT $LN23@ucs4lib_sp

; 99   : }

  0003d	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00042	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00046	41 5f		 pop	 r15
  00048	41 5e		 pop	 r14
  0004a	41 5d		 pop	 r13
  0004c	41 5c		 pop	 r12
  0004e	5e		 pop	 rsi
  0004f	c3		 ret	 0
$LN23@ucs4lib_sp:
  00050	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx

; 63   :         return NULL;
; 64   : 
; 65   :     i = j = 0;
; 66   :     while (maxcount-- > 0) {

  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
  0005c	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  00061	49 8b dc	 mov	 rbx, r12
  00064	4d 85 ed	 test	 r13, r13
  00067	0f 8e 62 01 00
	00		 jle	 $LN55@ucs4lib_sp
  0006d	0f 1f 00	 npad	 3
$LL22@ucs4lib_sp:
  00070	49 ff cd	 dec	 r13

; 67   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  00073	48 3b de	 cmp	 rbx, rsi
  00076	7d 35		 jge	 SHORT $LN65@ucs4lib_sp
  00078	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL20@ucs4lib_sp:
  00080	8b 4c 9d 00	 mov	 ecx, DWORD PTR [rbp+rbx*4]
  00084	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0008a	73 06		 jae	 SHORT $LN28@ucs4lib_sp
  0008c	0f b6 04 11	 movzx	 eax, BYTE PTR [rcx+rdx]
  00090	eb 0c		 jmp	 SHORT $LN29@ucs4lib_sp
$LN28@ucs4lib_sp:
  00092	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
$LN29@ucs4lib_sp:
  0009e	85 c0		 test	 eax, eax
  000a0	74 08		 je	 SHORT $LN61@ucs4lib_sp

; 68   :             i++;

  000a2	48 ff c3	 inc	 rbx
  000a5	48 3b de	 cmp	 rbx, rsi
  000a8	7c d6		 jl	 SHORT $LL20@ucs4lib_sp
$LN61@ucs4lib_sp:

; 69   :         if (i == str_len) break;

  000aa	48 3b de	 cmp	 rbx, rsi
$LN65@ucs4lib_sp:
  000ad	0f 84 1c 01 00
	00		 je	 $LN55@ucs4lib_sp

; 70   :         j = i; i++;

  000b3	48 8b fb	 mov	 rdi, rbx
  000b6	48 ff c3	 inc	 rbx

; 71   :         while (i < str_len && !STRINGLIB_ISSPACE(str[i]))

  000b9	48 3b de	 cmp	 rbx, rsi
  000bc	7d 2c		 jge	 SHORT $LN62@ucs4lib_sp
  000be	66 90		 npad	 2
$LL17@ucs4lib_sp:
  000c0	8b 4c 9d 00	 mov	 ecx, DWORD PTR [rbp+rbx*4]
  000c4	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  000ca	73 06		 jae	 SHORT $LN30@ucs4lib_sp
  000cc	0f b6 04 11	 movzx	 eax, BYTE PTR [rcx+rdx]
  000d0	eb 0c		 jmp	 SHORT $LN31@ucs4lib_sp
$LN30@ucs4lib_sp:
  000d2	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
$LN31@ucs4lib_sp:
  000de	85 c0		 test	 eax, eax
  000e0	75 08		 jne	 SHORT $LN62@ucs4lib_sp

; 72   :             i++;

  000e2	48 ff c3	 inc	 rbx
  000e5	48 3b de	 cmp	 rbx, rsi
  000e8	7c d6		 jl	 SHORT $LL17@ucs4lib_sp
$LN62@ucs4lib_sp:

; 73   : #ifndef STRINGLIB_MUTABLE
; 74   :         if (j == 0 && i == str_len && STRINGLIB_CHECK_EXACT(str_obj)) {

  000ea	48 85 ff	 test	 rdi, rdi
  000ed	75 16		 jne	 SHORT $LN15@ucs4lib_sp
  000ef	48 3b de	 cmp	 rbx, rsi
  000f2	75 11		 jne	 SHORT $LN15@ucs4lib_sp
  000f4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  000fb	49 39 47 58	 cmp	 QWORD PTR [r15+88], rax
  000ff	0f 84 b8 00 00
	00		 je	 $LN50@ucs4lib_sp
$LN15@ucs4lib_sp:

; 79   :             break;
; 80   :         }
; 81   : #endif
; 82   :         SPLIT_ADD(str, j, i);

  00105	48 8b d3	 mov	 rdx, rbx
  00108	48 8d 4c bd 00	 lea	 rcx, QWORD PTR [rbp+rdi*4]
  0010d	48 2b d7	 sub	 rdx, rdi
  00110	e8 00 00 00 00	 call	 _PyUnicode_FromUCS4
  00115	48 8b f8	 mov	 rdi, rax
  00118	48 85 c0	 test	 rax, rax
  0011b	0f 84 d9 00 00
	00		 je	 $onError$123560
  00121	49 83 fc 0c	 cmp	 r12, 12
  00125	7d 0a		 jge	 SHORT $LN13@ucs4lib_sp
  00127	49 8b 4e 70	 mov	 rcx, QWORD PTR [r14+112]
  0012b	4a 89 04 e1	 mov	 QWORD PTR [rcx+r12*8], rax
  0012f	eb 78		 jmp	 SHORT $LN44@ucs4lib_sp
$LN13@ucs4lib_sp:
  00131	48 8b d0	 mov	 rdx, rax
  00134	49 8b ce	 mov	 rcx, r14
  00137	e8 00 00 00 00	 call	 PyList_Append
  0013c	85 c0		 test	 eax, eax
  0013e	0f 85 ae 00 00
	00		 jne	 $LN52@ucs4lib_sp
  00144	e8 00 00 00 00	 call	 _Py_PXCTX
  00149	85 c0		 test	 eax, eax
  0014b	75 5c		 jne	 SHORT $LN44@ucs4lib_sp
  0014d	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00151	a8 20		 test	 al, 32			; 00000020H
  00153	75 4c		 jne	 SHORT $LN38@ucs4lib_sp
  00155	84 c0		 test	 al, al
  00157	78 48		 js	 SHORT $LN38@ucs4lib_sp
  00159	a8 02		 test	 al, 2
  0015b	75 4c		 jne	 SHORT $LN44@ucs4lib_sp
  0015d	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00161	75 46		 jne	 SHORT $LN44@ucs4lib_sp
  00163	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0016a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00171	4c 8b cf	 mov	 r9, rdi
  00174	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0017a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00182	e8 00 00 00 00	 call	 _PyParallel_Guard
  00187	48 8b cf	 mov	 rcx, rdi
  0018a	85 c0		 test	 eax, eax
  0018c	74 07		 je	 SHORT $LN43@ucs4lib_sp
  0018e	e8 00 00 00 00	 call	 _Px_Dealloc
  00193	eb 14		 jmp	 SHORT $LN44@ucs4lib_sp
$LN43@ucs4lib_sp:
  00195	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00199	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0019f	eb 08		 jmp	 SHORT $LN44@ucs4lib_sp
$LN38@ucs4lib_sp:
  001a1	48 8b cf	 mov	 rcx, rdi
  001a4	e8 00 00 00 00	 call	 Px_DecRef
$LN44@ucs4lib_sp:
  001a9	49 ff c4	 inc	 r12
  001ac	4d 85 ed	 test	 r13, r13
  001af	7e 1e		 jle	 SHORT $LN55@ucs4lib_sp

; 63   :         return NULL;
; 64   : 
; 65   :     i = j = 0;
; 66   :     while (maxcount-- > 0) {

  001b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
  001b8	e9 b3 fe ff ff	 jmp	 $LL22@ucs4lib_sp
$LN50@ucs4lib_sp:

; 75   :             /* No whitespace in str_obj, so just use it as list[0] */
; 76   :             Py_INCREF(str_obj);

  001bd	49 8b cf	 mov	 rcx, r15
  001c0	e8 00 00 00 00	 call	 _Py_IncRef

; 77   :             PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  001c5	4d 8b 5e 70	 mov	 r11, QWORD PTR [r14+112]

; 78   :             count++;

  001c9	49 ff c4	 inc	 r12
  001cc	4d 89 3b	 mov	 QWORD PTR [r11], r15
$LN55@ucs4lib_sp:

; 83   :     }
; 84   : 
; 85   :     if (i < str_len) {

  001cf	48 3b de	 cmp	 rbx, rsi
  001d2	0f 8d 8a 00 00
	00		 jge	 $LN6@ucs4lib_sp
  001d8	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_ascii_whitespace
  001df	90		 npad	 1
$LL8@ucs4lib_sp:

; 86   :         /* Only occurs when maxcount was reached */
; 87   :         /* Skip any remaining whitespace and copy to end of string */
; 88   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  001e0	8b 4c 9d 00	 mov	 ecx, DWORD PTR [rbp+rbx*4]
  001e4	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  001ea	73 1a		 jae	 SHORT $LN32@ucs4lib_sp
  001ec	0f b6 04 39	 movzx	 eax, BYTE PTR [rcx+rdi]
  001f0	eb 19		 jmp	 SHORT $LN33@ucs4lib_sp
$LN52@ucs4lib_sp:

; 79   :             break;
; 80   :         }
; 81   : #endif
; 82   :         SPLIT_ADD(str, j, i);

  001f2	48 8b cf	 mov	 rcx, rdi
$LN66@ucs4lib_sp:
  001f5	e8 00 00 00 00	 call	 _Py_DecRef
$onError$123560:

; 95   : 
; 96   :   onError:
; 97   :     Py_DECREF(list);

  001fa	49 8b ce	 mov	 rcx, r14
  001fd	e8 00 00 00 00	 call	 _Py_DecRef

; 98   :     return NULL;

  00202	33 c0		 xor	 eax, eax
  00204	eb 63		 jmp	 SHORT $LN64@ucs4lib_sp
$LN32@ucs4lib_sp:

; 86   :         /* Only occurs when maxcount was reached */
; 87   :         /* Skip any remaining whitespace and copy to end of string */
; 88   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  00206	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
$LN33@ucs4lib_sp:
  0020b	85 c0		 test	 eax, eax
  0020d	74 08		 je	 SHORT $LN7@ucs4lib_sp

; 89   :             i++;

  0020f	48 ff c3	 inc	 rbx
  00212	48 3b de	 cmp	 rbx, rsi
  00215	7c c9		 jl	 SHORT $LL8@ucs4lib_sp
$LN7@ucs4lib_sp:

; 90   :         if (i != str_len)

  00217	48 3b de	 cmp	 rbx, rsi
  0021a	74 46		 je	 SHORT $LN6@ucs4lib_sp

; 91   :             SPLIT_ADD(str, i, str_len);

  0021c	48 2b f3	 sub	 rsi, rbx
  0021f	48 8d 4c 9d 00	 lea	 rcx, QWORD PTR [rbp+rbx*4]
  00224	48 8b d6	 mov	 rdx, rsi
  00227	e8 00 00 00 00	 call	 _PyUnicode_FromUCS4
  0022c	48 8b d8	 mov	 rbx, rax
  0022f	48 85 c0	 test	 rax, rax
  00232	74 c6		 je	 SHORT $onError$123560
  00234	49 83 fc 0c	 cmp	 r12, 12
  00238	7d 0e		 jge	 SHORT $LN4@ucs4lib_sp
  0023a	49 8b 4e 70	 mov	 rcx, QWORD PTR [r14+112]
  0023e	49 ff c4	 inc	 r12
  00241	4a 89 44 e1 f8	 mov	 QWORD PTR [rcx+r12*8-8], rax
  00246	eb 1a		 jmp	 SHORT $LN6@ucs4lib_sp
$LN4@ucs4lib_sp:
  00248	48 8b d0	 mov	 rdx, rax
  0024b	49 8b ce	 mov	 rcx, r14
  0024e	e8 00 00 00 00	 call	 PyList_Append
  00253	48 8b cb	 mov	 rcx, rbx
  00256	85 c0		 test	 eax, eax
  00258	75 9b		 jne	 SHORT $LN66@ucs4lib_sp
  0025a	e8 00 00 00 00	 call	 _Py_DecRef
  0025f	49 ff c4	 inc	 r12
$LN6@ucs4lib_sp:

; 92   :     }
; 93   :     FIX_PREALLOC_SIZE(list);

  00262	4d 89 66 60	 mov	 QWORD PTR [r14+96], r12

; 94   :     return list;

  00266	49 8b c6	 mov	 rax, r14
$LN64@ucs4lib_sp:

; 99   : }

  00269	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0026e	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00273	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00278	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0027c	41 5f		 pop	 r15
  0027e	41 5e		 pop	 r14
  00280	41 5d		 pop	 r13
  00282	41 5c		 pop	 r12
  00284	5e		 pop	 rsi
  00285	c3		 ret	 0
ucs4lib_split_whitespace ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ucs4lib_split_char DD imagerel ucs4lib_split_char
	DD	imagerel ucs4lib_split_char+80
	DD	imagerel $unwind$ucs4lib_split_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ucs4lib_split_char DD imagerel ucs4lib_split_char+80
	DD	imagerel ucs4lib_split_char+332
	DD	imagerel $chain$0$ucs4lib_split_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ucs4lib_split_char DD imagerel ucs4lib_split_char+332
	DD	imagerel ucs4lib_split_char+356
	DD	imagerel $chain$1$ucs4lib_split_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ucs4lib_split_char DD imagerel ucs4lib_split_char+356
	DD	imagerel ucs4lib_split_char+559
	DD	imagerel $chain$2$ucs4lib_split_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ucs4lib_split_char DD 020021H
	DD	0d3400H
	DD	imagerel ucs4lib_split_char
	DD	imagerel ucs4lib_split_char+80
	DD	imagerel $unwind$ucs4lib_split_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ucs4lib_split_char DD 021H
	DD	imagerel ucs4lib_split_char
	DD	imagerel ucs4lib_split_char+80
	DD	imagerel $unwind$ucs4lib_split_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ucs4lib_split_char DD 020521H
	DD	0d3405H
	DD	imagerel ucs4lib_split_char
	DD	imagerel ucs4lib_split_char+80
	DD	imagerel $unwind$ucs4lib_split_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_split_char DD 0a1c01H
	DD	0f641cH
	DD	0e541cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs4lib_split_char
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
ch$ = 120
maxcount$ = 128
ucs4lib_split_char PROC					; COMDAT

; 106  : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 107  :     Py_ssize_t i, j, count=0;
; 108  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  0001c	4c 8b bc 24 80
	00 00 00	 mov	 r15, QWORD PTR maxcount$[rsp]
  00024	33 f6		 xor	 esi, esi
  00026	4c 8b e1	 mov	 r12, rcx
  00029	45 8b f1	 mov	 r14d, r9d
  0002c	49 8b f8	 mov	 rdi, r8
  0002f	4c 8b ea	 mov	 r13, rdx
  00032	8d 4e 0c	 lea	 ecx, QWORD PTR [rsi+12]
  00035	49 83 ff 0c	 cmp	 r15, 12
  00039	7d 04		 jge	 SHORT $LN24@ucs4lib_sp@2
  0003b	49 8d 4f 01	 lea	 rcx, QWORD PTR [r15+1]
$LN24@ucs4lib_sp@2:
  0003f	e8 00 00 00 00	 call	 PyList_New
  00044	48 8b e8	 mov	 rbp, rax

; 109  :     PyObject *sub;
; 110  : 
; 111  :     if (list == NULL)

  00047	48 85 c0	 test	 rax, rax
  0004a	0f 84 fc 00 00
	00		 je	 $LN21@ucs4lib_sp@2
$LN20@ucs4lib_sp@2:
  00050	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx

; 112  :         return NULL;
; 113  : 
; 114  :     i = j = 0;

  00055	48 8b ce	 mov	 rcx, rsi
  00058	48 8b de	 mov	 rbx, rsi

; 115  :     while ((j < str_len) && (maxcount-- > 0)) {

  0005b	48 85 ff	 test	 rdi, rdi
  0005e	0f 8e 84 00 00
	00		 jle	 $LN48@ucs4lib_sp@2
$LL19@ucs4lib_sp@2:
  00064	49 8b c7	 mov	 rax, r15
  00067	49 ff cf	 dec	 r15
  0006a	48 85 c0	 test	 rax, rax
  0006d	7e 6b		 jle	 SHORT $LN18@ucs4lib_sp@2

; 116  :         for(; j < str_len; j++) {

  0006f	48 3b df	 cmp	 rbx, rdi
  00072	7d 66		 jge	 SHORT $LN18@ucs4lib_sp@2
$LL17@ucs4lib_sp@2:

; 117  :             /* I found that using memchr makes no difference */
; 118  :             if (str[j] == ch) {

  00074	45 39 74 9d 00	 cmp	 DWORD PTR [r13+rbx*4], r14d
  00079	74 0a		 je	 SHORT $LN42@ucs4lib_sp@2

; 116  :         for(; j < str_len; j++) {

  0007b	48 ff c3	 inc	 rbx
  0007e	48 3b df	 cmp	 rbx, rdi
  00081	7c f1		 jl	 SHORT $LL17@ucs4lib_sp@2
  00083	eb 55		 jmp	 SHORT $LN18@ucs4lib_sp@2
$LN42@ucs4lib_sp@2:

; 119  :                 SPLIT_ADD(str, i, j);

  00085	48 8b d3	 mov	 rdx, rbx
  00088	48 2b d1	 sub	 rdx, rcx
  0008b	49 8d 4c 8d 00	 lea	 rcx, QWORD PTR [r13+rcx*4]
  00090	e8 00 00 00 00	 call	 _PyUnicode_FromUCS4
  00095	4c 8b e0	 mov	 r12, rax
  00098	48 85 c0	 test	 rax, rax
  0009b	0f 84 0b 01 00
	00		 je	 $onError$123614
  000a1	48 83 fe 0c	 cmp	 rsi, 12
  000a5	7d 0a		 jge	 SHORT $LN12@ucs4lib_sp@2
  000a7	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  000ab	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  000af	eb 1b		 jmp	 SHORT $LN9@ucs4lib_sp@2
$LN12@ucs4lib_sp@2:
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	48 8b cd	 mov	 rcx, rbp
  000b7	e8 00 00 00 00	 call	 PyList_Append
  000bc	49 8b cc	 mov	 rcx, r12
  000bf	85 c0		 test	 eax, eax
  000c1	0f 85 e0 00 00
	00		 jne	 $LN44@ucs4lib_sp@2
  000c7	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@ucs4lib_sp@2:

; 120  :                 i = j = j + 1;

  000cc	48 ff c3	 inc	 rbx
  000cf	48 ff c6	 inc	 rsi
  000d2	48 8b cb	 mov	 rcx, rbx
  000d5	48 3b df	 cmp	 rbx, rdi
  000d8	7c 8a		 jl	 SHORT $LL19@ucs4lib_sp@2
$LN18@ucs4lib_sp@2:

; 121  :                 break;
; 122  :             }
; 123  :         }
; 124  :     }
; 125  : #ifndef STRINGLIB_MUTABLE
; 126  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  000da	48 85 f6	 test	 rsi, rsi
  000dd	0f 85 81 00 00
	00		 jne	 $LN8@ucs4lib_sp@2
  000e3	4c 8b 64 24 60	 mov	 r12, QWORD PTR str_obj$[rsp]
$LN48@ucs4lib_sp@2:
  000e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  000ef	49 39 44 24 58	 cmp	 QWORD PTR [r12+88], rax
  000f4	75 6e		 jne	 SHORT $LN8@ucs4lib_sp@2

; 127  :         /* ch not in str_obj, so just use str_obj as list[0] */
; 128  :         Py_INCREF(str_obj);

  000f6	e8 00 00 00 00	 call	 _Py_PXCTX
  000fb	85 c0		 test	 eax, eax
  000fd	75 35		 jne	 SHORT $LN26@ucs4lib_sp@2
  000ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0010d	4d 8b cc	 mov	 r9, r12
  00110	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00116	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0011e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00123	85 c0		 test	 eax, eax
  00125	75 08		 jne	 SHORT $LN25@ucs4lib_sp@2
  00127	41 f6 44 24 20
	20		 test	 BYTE PTR [r12+32], 32	; 00000020H
  0012d	74 05		 je	 SHORT $LN26@ucs4lib_sp@2
$LN25@ucs4lib_sp@2:
  0012f	49 ff 44 24 50	 inc	 QWORD PTR [r12+80]
$LN26@ucs4lib_sp@2:

; 129  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  00134	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]

; 130  :         count++;

  00138	be 01 00 00 00	 mov	 esi, 1
  0013d	4c 89 20	 mov	 QWORD PTR [rax], r12
$LN6@ucs4lib_sp@2:

; 135  :     }
; 136  :     FIX_PREALLOC_SIZE(list);

  00140	48 89 75 60	 mov	 QWORD PTR [rbp+96], rsi

; 137  :     return list;

  00144	48 8b c5	 mov	 rax, rbp
$LN49@ucs4lib_sp@2:
  00147	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
$LN21@ucs4lib_sp@2:

; 142  : }

  0014c	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00151	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00156	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0015a	41 5f		 pop	 r15
  0015c	41 5e		 pop	 r14
  0015e	41 5d		 pop	 r13
  00160	41 5c		 pop	 r12
  00162	5f		 pop	 rdi
  00163	c3		 ret	 0
$LN8@ucs4lib_sp@2:

; 131  :     } else
; 132  : #endif
; 133  :     if (i <= str_len) {

  00164	48 3b cf	 cmp	 rcx, rdi
  00167	7f d7		 jg	 SHORT $LN6@ucs4lib_sp@2

; 134  :         SPLIT_ADD(str, i, str_len);

  00169	48 2b f9	 sub	 rdi, rcx
  0016c	49 8d 4c 8d 00	 lea	 rcx, QWORD PTR [r13+rcx*4]
  00171	48 8b d7	 mov	 rdx, rdi
  00174	e8 00 00 00 00	 call	 _PyUnicode_FromUCS4
  00179	48 8b d8	 mov	 rbx, rax
  0017c	48 85 c0	 test	 rax, rax
  0017f	74 2b		 je	 SHORT $onError$123614
  00181	48 83 fe 0c	 cmp	 rsi, 12
  00185	7d 0e		 jge	 SHORT $LN4@ucs4lib_sp@2
  00187	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  0018b	48 ff c6	 inc	 rsi
  0018e	48 89 44 f1 f8	 mov	 QWORD PTR [rcx+rsi*8-8], rax
  00193	eb ab		 jmp	 SHORT $LN6@ucs4lib_sp@2
$LN4@ucs4lib_sp@2:
  00195	48 8b d0	 mov	 rdx, rax
  00198	48 8b cd	 mov	 rcx, rbp
  0019b	e8 00 00 00 00	 call	 PyList_Append
  001a0	48 8b cb	 mov	 rcx, rbx
  001a3	85 c0		 test	 eax, eax
  001a5	74 5b		 je	 SHORT $LN2@ucs4lib_sp@2
$LN44@ucs4lib_sp@2:
  001a7	e8 00 00 00 00	 call	 _Py_DecRef
$onError$123614:

; 138  : 
; 139  :   onError:
; 140  :     Py_DECREF(list);

  001ac	e8 00 00 00 00	 call	 _Py_PXCTX
  001b1	85 c0		 test	 eax, eax
  001b3	75 73		 jne	 SHORT $LN39@ucs4lib_sp@2
  001b5	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  001b9	a8 20		 test	 al, 32			; 00000020H
  001bb	75 63		 jne	 SHORT $LN33@ucs4lib_sp@2
  001bd	84 c0		 test	 al, al
  001bf	78 5f		 js	 SHORT $LN33@ucs4lib_sp@2
  001c1	a8 02		 test	 al, 2
  001c3	75 63		 jne	 SHORT $LN39@ucs4lib_sp@2
  001c5	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  001c9	75 5d		 jne	 SHORT $LN39@ucs4lib_sp@2
  001cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001d9	4c 8b cd	 mov	 r9, rbp
  001dc	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001e2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001ea	e8 00 00 00 00	 call	 _PyParallel_Guard
  001ef	48 8b cd	 mov	 rcx, rbp
  001f2	85 c0		 test	 eax, eax
  001f4	74 19		 je	 SHORT $LN38@ucs4lib_sp@2
  001f6	e8 00 00 00 00	 call	 _Px_Dealloc

; 141  :     return NULL;

  001fb	33 c0		 xor	 eax, eax
  001fd	e9 45 ff ff ff	 jmp	 $LN49@ucs4lib_sp@2
$LN2@ucs4lib_sp@2:

; 134  :         SPLIT_ADD(str, i, str_len);

  00202	e8 00 00 00 00	 call	 _Py_DecRef
  00207	48 ff c6	 inc	 rsi
  0020a	e9 31 ff ff ff	 jmp	 $LN6@ucs4lib_sp@2

; 138  : 
; 139  :   onError:
; 140  :     Py_DECREF(list);

$LN38@ucs4lib_sp@2:
  0020f	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  00213	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 141  :     return NULL;

  00219	33 c0		 xor	 eax, eax
  0021b	e9 27 ff ff ff	 jmp	 $LN49@ucs4lib_sp@2

; 138  : 
; 139  :   onError:
; 140  :     Py_DECREF(list);

$LN33@ucs4lib_sp@2:
  00220	48 8b cd	 mov	 rcx, rbp
  00223	e8 00 00 00 00	 call	 Px_DecRef
$LN39@ucs4lib_sp@2:

; 141  :     return NULL;

  00228	33 c0		 xor	 eax, eax
  0022a	e9 18 ff ff ff	 jmp	 $LN49@ucs4lib_sp@2
ucs4lib_split_char ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs4lib_split DD imagerel ucs4lib_split
	DD	imagerel ucs4lib_split+136
	DD	imagerel $unwind$ucs4lib_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ucs4lib_split DD imagerel ucs4lib_split+136
	DD	imagerel ucs4lib_split+934
	DD	imagerel $chain$1$ucs4lib_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ucs4lib_split DD imagerel ucs4lib_split+934
	DD	imagerel ucs4lib_split+1049
	DD	imagerel $chain$3$ucs4lib_split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ucs4lib_split DD 040021H
	DD	0ad400H
	DD	0155400H
	DD	imagerel ucs4lib_split
	DD	imagerel ucs4lib_split+136
	DD	imagerel $unwind$ucs4lib_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ucs4lib_split DD 040d21H
	DD	0ad40dH
	DD	0155408H
	DD	imagerel ucs4lib_split
	DD	imagerel ucs4lib_split+136
	DD	imagerel $unwind$ucs4lib_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_split DD 071c01H
	DD	0f018a21cH
	DD	0c014e016H
	DD	060117012H
	DD	03010H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs4lib_split
_TEXT	SEGMENT
count$1$ = 48
list$1$ = 56
i$1$ = 64
maxcount$1$ = 72
str_obj$ = 144
str$ = 152
str_len$ = 160
sep$ = 168
tv834 = 176
sep_len$ = 176
maxcount$ = 184
ucs4lib_split PROC					; COMDAT

; 149  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	53		 push	 rbx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 54		 push	 r12
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 150  :     Py_ssize_t i, j, pos, count=0;
; 151  :     PyObject *list, *sub;
; 152  : 
; 153  :     if (sep_len == 0) {

  0001c	4c 8b b4 24 b0
	00 00 00	 mov	 r14, QWORD PTR sep_len$[rsp]
  00024	33 f6		 xor	 esi, esi
  00026	4d 8b f9	 mov	 r15, r9
  00029	49 8b d8	 mov	 rbx, r8
  0002c	48 8b fa	 mov	 rdi, rdx
  0002f	4c 8b e1	 mov	 r12, rcx
  00032	48 89 74 24 30	 mov	 QWORD PTR count$1$[rsp], rsi
  00037	4d 85 f6	 test	 r14, r14
  0003a	75 23		 jne	 SHORT $LN19@ucs4lib_sp@3

; 154  :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0003c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  0004a	e8 00 00 00 00	 call	 PyErr_SetString

; 155  :         return NULL;

  0004f	33 c0		 xor	 eax, eax

; 190  : }

  00051	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00055	41 5f		 pop	 r15
  00057	41 5e		 pop	 r14
  00059	41 5c		 pop	 r12
  0005b	5f		 pop	 rdi
  0005c	5e		 pop	 rsi
  0005d	5b		 pop	 rbx
  0005e	c3		 ret	 0
$LN19@ucs4lib_sp@3:

; 156  :     }
; 157  :     else if (sep_len == 1)

  0005f	49 83 fe 01	 cmp	 r14, 1
  00063	75 23		 jne	 SHORT $LN17@ucs4lib_sp@3

; 158  :         return STRINGLIB(split_char)(str_obj, str, str_len, sep[0], maxcount);

  00065	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  0006d	45 8b 09	 mov	 r9d, DWORD PTR [r9]
  00070	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00075	e8 00 00 00 00	 call	 ucs4lib_split_char

; 190  : }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	41 5f		 pop	 r15
  00080	41 5e		 pop	 r14
  00082	41 5c		 pop	 r12
  00084	5f		 pop	 rdi
  00085	5e		 pop	 rsi
  00086	5b		 pop	 rbx
  00087	c3		 ret	 0
$LN17@ucs4lib_sp@3:
  00088	48 89 ac 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rbp
  00090	4c 89 6c 24 50	 mov	 QWORD PTR [rsp+80], r13

; 159  : 
; 160  :     list = PyList_New(PREALLOC_SIZE(maxcount));

  00095	4c 8b ac 24 b8
	00 00 00	 mov	 r13, QWORD PTR maxcount$[rsp]
  0009d	b9 0c 00 00 00	 mov	 ecx, 12
  000a2	49 83 fd 0c	 cmp	 r13, 12
  000a6	7d 04		 jge	 SHORT $LN23@ucs4lib_sp@3
  000a8	49 8d 4d 01	 lea	 rcx, QWORD PTR [r13+1]
$LN23@ucs4lib_sp@3:
  000ac	e8 00 00 00 00	 call	 PyList_New
  000b1	48 8b e8	 mov	 rbp, rax
  000b4	48 89 44 24 38	 mov	 QWORD PTR list$1$[rsp], rax

; 161  :     if (list == NULL)

  000b9	48 85 c0	 test	 rax, rax

; 162  :         return NULL;

  000bc	0f 84 c7 02 00
	00		 je	 $LN129@ucs4lib_sp@3

; 163  : 
; 164  :     i = j = 0;

  000c2	45 33 d2	 xor	 r10d, r10d
  000c5	4c 89 54 24 40	 mov	 QWORD PTR i$1$[rsp], r10

; 165  :     while (maxcount-- > 0) {

  000ca	4d 85 ed	 test	 r13, r13
  000cd	0f 8e e4 01 00
	00		 jle	 $LN118@ucs4lib_sp@3
$LL15@ucs4lib_sp@3:
  000d3	49 ff cd	 dec	 r13

; 166  :         pos = FASTSEARCH(str+i, str_len-i, sep, sep_len, -1, FAST_SEARCH);

  000d6	48 8b cb	 mov	 rcx, rbx
  000d9	4e 8d 04 97	 lea	 r8, QWORD PTR [rdi+r10*4]
  000dd	49 2b ca	 sub	 rcx, r10
  000e0	4c 89 6c 24 48	 mov	 QWORD PTR maxcount$1$[rsp], r13
  000e5	4c 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv834[rsp], r8
  000ed	4c 8b e1	 mov	 r12, rcx
  000f0	4d 2b e6	 sub	 r12, r14
  000f3	0f 88 a8 01 00
	00		 js	 $LN116@ucs4lib_sp@3
  000f9	49 83 fe 01	 cmp	 r14, 1
  000fd	0f 8f ac 00 00
	00		 jg	 $LN83@ucs4lib_sp@3
  00103	4d 85 f6	 test	 r14, r14
  00106	0f 8e 95 01 00
	00		 jle	 $LN116@ucs4lib_sp@3
  0010c	48 83 f9 0a	 cmp	 rcx, 10
  00110	7e 72		 jle	 SHORT $LN80@ucs4lib_sp@3
  00112	41 0f b6 07	 movzx	 eax, BYTE PTR [r15]
  00116	84 c0		 test	 al, al
  00118	74 6a		 je	 SHORT $LN80@ucs4lib_sp@3
  0011a	41 8b 3f	 mov	 edi, DWORD PTR [r15]
  0011d	49 8d 1c 88	 lea	 rbx, QWORD PTR [r8+rcx*4]
  00121	4d 8b c8	 mov	 r9, r8
  00124	4c 3b c3	 cmp	 r8, rbx
  00127	73 3e		 jae	 SHORT $LN92@ucs4lib_sp@3
  00129	0f b6 f0	 movzx	 esi, al
  0012c	0f 1f 40 00	 npad	 4
$LL93@ucs4lib_sp@3:
  00130	4c 8b c3	 mov	 r8, rbx
  00133	8b d6		 mov	 edx, esi
  00135	49 8b c9	 mov	 rcx, r9
  00138	4d 2b c1	 sub	 r8, r9
  0013b	49 83 e0 fc	 and	 r8, -4
  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00145	4c 8b c8	 mov	 r9, rax
  00148	48 85 c0	 test	 rax, rax
  0014b	74 12		 je	 SHORT $LN103@ucs4lib_sp@3
  0014d	49 83 e1 fc	 and	 r9, -4
  00151	41 39 39	 cmp	 DWORD PTR [r9], edi
  00154	74 1a		 je	 SHORT $LN104@ucs4lib_sp@3
  00156	49 83 c1 04	 add	 r9, 4
  0015a	4c 3b cb	 cmp	 r9, rbx
  0015d	72 d1		 jb	 SHORT $LL93@ucs4lib_sp@3
$LN103@ucs4lib_sp@3:
  0015f	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR tv834[rsp]
$LN92@ucs4lib_sp@3:
  00167	49 83 c9 ff	 or	 r9, -1
  0016b	e9 8b 01 00 00	 jmp	 $LN88@ucs4lib_sp@3
$LN104@ucs4lib_sp@3:
  00170	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR tv834[rsp]
  00178	4d 2b c8	 sub	 r9, r8
  0017b	49 c1 f9 02	 sar	 r9, 2
  0017f	e9 77 01 00 00	 jmp	 $LN88@ucs4lib_sp@3
$LN80@ucs4lib_sp@3:
  00184	45 33 c9	 xor	 r9d, r9d
  00187	48 85 c9	 test	 rcx, rcx
  0018a	0f 8e 11 01 00
	00		 jle	 $LN116@ucs4lib_sp@3
  00190	41 8b 17	 mov	 edx, DWORD PTR [r15]
  00193	49 8b c0	 mov	 rax, r8
$LL71@ucs4lib_sp@3:
  00196	39 10		 cmp	 DWORD PTR [rax], edx
  00198	0f 84 67 01 00
	00		 je	 $LN86@ucs4lib_sp@3
  0019e	49 ff c1	 inc	 r9
  001a1	48 83 c0 04	 add	 rax, 4
  001a5	4c 3b c9	 cmp	 r9, rcx
  001a8	7c ec		 jl	 SHORT $LL71@ucs4lib_sp@3
  001aa	e9 f2 00 00 00	 jmp	 $LN116@ucs4lib_sp@3
$LN83@ucs4lib_sp@3:
  001af	49 8d 5e ff	 lea	 rbx, QWORD PTR [r14-1]
  001b3	33 ff		 xor	 edi, edi
  001b5	45 33 c9	 xor	 r9d, r9d
  001b8	48 8d 73 ff	 lea	 rsi, QWORD PTR [rbx-1]
  001bc	48 85 db	 test	 rbx, rbx
  001bf	7e 3c		 jle	 SHORT $LN59@ucs4lib_sp@3
  001c1	45 8b 1c 9f	 mov	 r11d, DWORD PTR [r15+rbx*4]
  001c5	4c 8b d6	 mov	 r10, rsi
  001c8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL61@ucs4lib_sp@3:
  001d0	47 8b 04 8f	 mov	 r8d, DWORD PTR [r15+r9*4]
  001d4	ba 01 00 00 00	 mov	 edx, 1
  001d9	41 8b c8	 mov	 ecx, r8d
  001dc	83 e1 1f	 and	 ecx, 31
  001df	d3 e2		 shl	 edx, cl
  001e1	0b fa		 or	 edi, edx
  001e3	45 3b c3	 cmp	 r8d, r11d
  001e6	49 0f 44 f2	 cmove	 rsi, r10
  001ea	49 ff c1	 inc	 r9
  001ed	49 ff ca	 dec	 r10
  001f0	4c 3b cb	 cmp	 r9, rbx
  001f3	7c db		 jl	 SHORT $LL61@ucs4lib_sp@3
  001f5	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR tv834[rsp]
$LN59@ucs4lib_sp@3:
  001fd	41 8b 0c 9f	 mov	 ecx, DWORD PTR [r15+rbx*4]
  00201	ba 01 00 00 00	 mov	 edx, 1
  00206	45 33 c9	 xor	 r9d, r9d
  00209	83 e1 1f	 and	 ecx, 31
  0020c	d3 e2		 shl	 edx, cl
  0020e	0b fa		 or	 edi, edx
  00210	4d 85 e4	 test	 r12, r12
  00213	0f 88 83 00 00
	00		 js	 $LN126@ucs4lib_sp@3
  00219	4e 8d 1c b5 00
	00 00 00	 lea	 r11, QWORD PTR [r14*4]
  00221	48 8d 2c b5 00
	00 00 00	 lea	 rbp, QWORD PTR [rsi*4]
  00229	47 8b 6c 3b fc	 mov	 r13d, DWORD PTR [r11+r15-4]
  0022e	4f 8d 14 03	 lea	 r10, QWORD PTR [r11+r8]
  00232	4d 2b c7	 sub	 r8, r15
$LL57@ucs4lib_sp@3:
  00235	45 39 6a fc	 cmp	 DWORD PTR [r10-4], r13d
  00239	75 3d		 jne	 SHORT $LN54@ucs4lib_sp@3
  0023b	33 d2		 xor	 edx, edx
  0023d	48 85 db	 test	 rbx, rbx
  00240	7e 17		 jle	 SHORT $LN124@ucs4lib_sp@3
  00242	49 8b cf	 mov	 rcx, r15
$LL53@ucs4lib_sp@3:
  00245	8b 01		 mov	 eax, DWORD PTR [rcx]
  00247	41 39 04 08	 cmp	 DWORD PTR [r8+rcx], eax
  0024b	75 0c		 jne	 SHORT $LN124@ucs4lib_sp@3
  0024d	48 ff c2	 inc	 rdx
  00250	48 83 c1 04	 add	 rcx, 4
  00254	48 3b d3	 cmp	 rdx, rbx
  00257	7c ec		 jl	 SHORT $LL53@ucs4lib_sp@3
$LN124@ucs4lib_sp@3:
  00259	48 3b d3	 cmp	 rdx, rbx
  0025c	0f 84 87 00 00
	00		 je	 $LN107@ucs4lib_sp@3
  00262	41 8b 02	 mov	 eax, DWORD PTR [r10]
  00265	83 e0 1f	 and	 eax, 31
  00268	0f a3 c7	 bt	 edi, eax
  0026b	73 16		 jae	 SHORT $LN130@ucs4lib_sp@3
  0026d	4c 03 ce	 add	 r9, rsi
  00270	4c 03 c5	 add	 r8, rbp
  00273	4c 03 d5	 add	 r10, rbp
  00276	eb 14		 jmp	 SHORT $LN56@ucs4lib_sp@3
$LN54@ucs4lib_sp@3:
  00278	41 8b 02	 mov	 eax, DWORD PTR [r10]
  0027b	83 e0 1f	 and	 eax, 31
  0027e	0f a3 c7	 bt	 edi, eax
  00281	72 09		 jb	 SHORT $LN56@ucs4lib_sp@3
$LN130@ucs4lib_sp@3:
  00283	4d 03 ce	 add	 r9, r14
  00286	4d 03 c3	 add	 r8, r11
  00289	4d 03 d3	 add	 r10, r11
$LN56@ucs4lib_sp@3:
  0028c	49 ff c1	 inc	 r9
  0028f	49 83 c0 04	 add	 r8, 4
  00293	49 83 c2 04	 add	 r10, 4
  00297	4d 3b cc	 cmp	 r9, r12
  0029a	7e 99		 jle	 SHORT $LL57@ucs4lib_sp@3
$LN126@ucs4lib_sp@3:

; 170  :         SPLIT_ADD(str, i, j);

  0029c	48 8b 74 24 30	 mov	 rsi, QWORD PTR count$1$[rsp]
$LN116@ucs4lib_sp@3:

; 172  :     }
; 173  : #ifndef STRINGLIB_MUTABLE
; 174  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  002a1	48 85 f6	 test	 rsi, rsi
  002a4	0f 85 fc 00 00
	00		 jne	 $LN7@ucs4lib_sp@3
  002aa	48 8b 6c 24 38	 mov	 rbp, QWORD PTR list$1$[rsp]
  002af	4c 8b a4 24 90
	00 00 00	 mov	 r12, QWORD PTR str_obj$[rsp]
$LN118@ucs4lib_sp@3:
  002b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  002be	49 39 44 24 58	 cmp	 QWORD PTR [r12+88], rax
  002c3	0f 85 dd 00 00
	00		 jne	 $LN7@ucs4lib_sp@3

; 175  :         /* No match in str_obj, so just use it as list[0] */
; 176  :         Py_INCREF(str_obj);

  002c9	49 8b cc	 mov	 rcx, r12
  002cc	e8 00 00 00 00	 call	 _Py_IncRef

; 177  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  002d1	4c 8b 5d 70	 mov	 r11, QWORD PTR [rbp+112]

; 178  :         count++;

  002d5	be 01 00 00 00	 mov	 esi, 1
  002da	4d 89 23	 mov	 QWORD PTR [r11], r12

; 183  :     }
; 184  :     FIX_PREALLOC_SIZE(list);

  002dd	48 89 75 60	 mov	 QWORD PTR [rbp+96], rsi

; 185  :     return list;

  002e1	48 8b c5	 mov	 rax, rbp
  002e4	e9 a2 00 00 00	 jmp	 $LN128@ucs4lib_sp@3
$LN107@ucs4lib_sp@3:
  002e9	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR tv834[rsp]
  002f1	48 8b 6c 24 38	 mov	 rbp, QWORD PTR list$1$[rsp]
  002f6	4c 8b 6c 24 48	 mov	 r13, QWORD PTR maxcount$1$[rsp]

; 166  :         pos = FASTSEARCH(str+i, str_len-i, sep, sep_len, -1, FAST_SEARCH);

$LN88@ucs4lib_sp@3:
  002fb	4c 8b 54 24 40	 mov	 r10, QWORD PTR i$1$[rsp]
  00300	48 8b 74 24 30	 mov	 rsi, QWORD PTR count$1$[rsp]
$LN86@ucs4lib_sp@3:

; 167  :         if (pos < 0)

  00305	4d 85 c9	 test	 r9, r9
  00308	78 97		 js	 SHORT $LN116@ucs4lib_sp@3

; 168  :             break;
; 169  :         j = i + pos;

  0030a	4b 8d 3c 11	 lea	 rdi, QWORD PTR [r9+r10]

; 170  :         SPLIT_ADD(str, i, j);

  0030e	49 8b c8	 mov	 rcx, r8
  00311	48 8b d7	 mov	 rdx, rdi
  00314	49 2b d2	 sub	 rdx, r10
  00317	e8 00 00 00 00	 call	 _PyUnicode_FromUCS4
  0031c	48 8b d8	 mov	 rbx, rax
  0031f	48 85 c0	 test	 rax, rax
  00322	74 5b		 je	 SHORT $onError$123674
  00324	48 83 fe 0c	 cmp	 rsi, 12
  00328	7d 0a		 jge	 SHORT $LN11@ucs4lib_sp@3
  0032a	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  0032e	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  00332	eb 17		 jmp	 SHORT $LN8@ucs4lib_sp@3
$LN11@ucs4lib_sp@3:
  00334	48 8b d0	 mov	 rdx, rax
  00337	48 8b cd	 mov	 rcx, rbp
  0033a	e8 00 00 00 00	 call	 PyList_Append
  0033f	48 8b cb	 mov	 rcx, rbx
  00342	85 c0		 test	 eax, eax
  00344	75 34		 jne	 SHORT $LN110@ucs4lib_sp@3
  00346	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@ucs4lib_sp@3:
  0034b	48 ff c6	 inc	 rsi

; 171  :         i = j + sep_len;

  0034e	4e 8d 14 37	 lea	 r10, QWORD PTR [rdi+r14]
  00352	4c 89 54 24 40	 mov	 QWORD PTR i$1$[rsp], r10
  00357	48 89 74 24 30	 mov	 QWORD PTR count$1$[rsp], rsi
  0035c	4d 85 ed	 test	 r13, r13
  0035f	0f 8e 3c ff ff
	ff		 jle	 $LN116@ucs4lib_sp@3

; 179  :     } else
; 180  : #endif
; 181  :     {
; 182  :         SPLIT_ADD(str, i, str_len);

  00365	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR str_len$[rsp]
  0036d	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR str$[rsp]
  00375	e9 59 fd ff ff	 jmp	 $LL15@ucs4lib_sp@3
$LN110@ucs4lib_sp@3:

; 170  :         SPLIT_ADD(str, i, j);

  0037a	e8 00 00 00 00	 call	 _Py_DecRef
$onError$123674:

; 186  : 
; 187  :   onError:
; 188  :     Py_DECREF(list);

  0037f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR list$1$[rsp]
  00384	e8 00 00 00 00	 call	 _Py_DecRef
$LN129@ucs4lib_sp@3:

; 189  :     return NULL;

  00389	33 c0		 xor	 eax, eax
$LN128@ucs4lib_sp@3:
  0038b	48 8b ac 24 a8
	00 00 00	 mov	 rbp, QWORD PTR [rsp+168]
  00393	4c 8b 6c 24 50	 mov	 r13, QWORD PTR [rsp+80]

; 190  : }

  00398	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0039c	41 5f		 pop	 r15
  0039e	41 5e		 pop	 r14
  003a0	41 5c		 pop	 r12
  003a2	5f		 pop	 rdi
  003a3	5e		 pop	 rsi
  003a4	5b		 pop	 rbx
  003a5	c3		 ret	 0
$LN7@ucs4lib_sp@3:

; 179  :     } else
; 180  : #endif
; 181  :     {
; 182  :         SPLIT_ADD(str, i, str_len);

  003a6	48 8b 44 24 40	 mov	 rax, QWORD PTR i$1$[rsp]
  003ab	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  003b3	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR str_len$[rsp]
  003bb	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  003bf	48 2b d0	 sub	 rdx, rax
  003c2	e8 00 00 00 00	 call	 _PyUnicode_FromUCS4
  003c7	48 8b d8	 mov	 rbx, rax
  003ca	48 85 c0	 test	 rax, rax
  003cd	74 b0		 je	 SHORT $onError$123674
  003cf	48 8b 6c 24 38	 mov	 rbp, QWORD PTR list$1$[rsp]
  003d4	48 83 fe 0c	 cmp	 rsi, 12
  003d8	7d 15		 jge	 SHORT $LN4@ucs4lib_sp@3
  003da	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  003de	48 ff c6	 inc	 rsi
  003e1	48 89 44 f1 f8	 mov	 QWORD PTR [rcx+rsi*8-8], rax

; 183  :     }
; 184  :     FIX_PREALLOC_SIZE(list);

  003e6	48 89 75 60	 mov	 QWORD PTR [rbp+96], rsi

; 185  :     return list;

  003ea	48 8b c5	 mov	 rax, rbp
  003ed	eb 9c		 jmp	 SHORT $LN128@ucs4lib_sp@3
$LN4@ucs4lib_sp@3:

; 179  :     } else
; 180  : #endif
; 181  :     {
; 182  :         SPLIT_ADD(str, i, str_len);

  003ef	48 8b d0	 mov	 rdx, rax
  003f2	48 8b cd	 mov	 rcx, rbp
  003f5	e8 00 00 00 00	 call	 PyList_Append
  003fa	48 8b cb	 mov	 rcx, rbx
  003fd	85 c0		 test	 eax, eax
  003ff	0f 85 75 ff ff
	ff		 jne	 $LN110@ucs4lib_sp@3
  00405	e8 00 00 00 00	 call	 _Py_DecRef
  0040a	48 ff c6	 inc	 rsi

; 185  :     return list;

  0040d	48 8b c5	 mov	 rax, rbp
  00410	48 89 75 60	 mov	 QWORD PTR [rbp+96], rsi
  00414	e9 72 ff ff ff	 jmp	 $LN128@ucs4lib_sp@3
ucs4lib_split ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ucs4lib_rsplit_whitespace DD imagerel ucs4lib_rsplit_whitespace
	DD	imagerel ucs4lib_rsplit_whitespace+672
	DD	imagerel $unwind$ucs4lib_rsplit_whitespace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_rsplit_whitespace DD 0c5501H
	DD	0df455H
	DD	0c7450H
	DD	0e3411H
	DD	0e00d5211H
	DD	0c009d00bH
	DD	050066007H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs4lib_rsplit_whitespace
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
maxcount$ = 120
ucs4lib_rsplit_whitespace PROC				; COMDAT

; 196  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 197  :     Py_ssize_t i, j, count=0;

  00011	33 ed		 xor	 ebp, ebp
  00013	4c 8b f1	 mov	 r14, rcx
  00016	4d 8b e9	 mov	 r13, r9
  00019	49 8b d8	 mov	 rbx, r8
  0001c	48 8b f2	 mov	 rsi, rdx

; 198  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  0001f	8d 4d 0c	 lea	 ecx, QWORD PTR [rbp+12]
  00022	49 83 f9 0c	 cmp	 r9, 12
  00026	7d 04		 jge	 SHORT $LN28@ucs4lib_rs
  00028	49 8d 49 01	 lea	 rcx, QWORD PTR [r9+1]
$LN28@ucs4lib_rs:
  0002c	e8 00 00 00 00	 call	 PyList_New
  00031	4c 8b e0	 mov	 r12, rax

; 199  :     PyObject *sub;
; 200  : 
; 201  :     if (list == NULL)

  00034	48 85 c0	 test	 rax, rax
  00037	75 12		 jne	 SHORT $LN24@ucs4lib_rs

; 240  : }

  00039	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	41 5e		 pop	 r14
  00044	41 5d		 pop	 r13
  00046	41 5c		 pop	 r12
  00048	5e		 pop	 rsi
  00049	5d		 pop	 rbp
  0004a	c3		 ret	 0
$LN24@ucs4lib_rs:
  0004b	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00050	4c 89 7c 24 68	 mov	 QWORD PTR [rsp+104], r15

; 202  :         return NULL;
; 203  : 
; 204  :     i = j = str_len - 1;

  00055	4c 8d 7b ff	 lea	 r15, QWORD PTR [rbx-1]
  00059	49 8b df	 mov	 rbx, r15
$LN68@ucs4lib_rs:

; 205  :     while (maxcount-- > 0) {

  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
  00063	4d 85 ed	 test	 r13, r13
  00066	0f 8e 6f 01 00
	00		 jle	 $LN56@ucs4lib_rs
  0006c	49 ff cd	 dec	 r13

; 206  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  0006f	48 85 db	 test	 rbx, rbx
  00072	0f 88 ec 01 00
	00		 js	 $LN7@ucs4lib_rs
  00078	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL21@ucs4lib_rs:
  00080	8b 0c 9e	 mov	 ecx, DWORD PTR [rsi+rbx*4]
  00083	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  00089	73 06		 jae	 SHORT $LN29@ucs4lib_rs
  0008b	0f b6 04 11	 movzx	 eax, BYTE PTR [rcx+rdx]
  0008f	eb 0c		 jmp	 SHORT $LN30@ucs4lib_rs
$LN29@ucs4lib_rs:
  00091	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
$LN30@ucs4lib_rs:
  0009d	85 c0		 test	 eax, eax
  0009f	74 0a		 je	 SHORT $LN20@ucs4lib_rs

; 207  :             i--;

  000a1	48 ff cb	 dec	 rbx

; 206  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  000a4	79 da		 jns	 SHORT $LL21@ucs4lib_rs
  000a6	e9 b9 01 00 00	 jmp	 $LN7@ucs4lib_rs
$LN20@ucs4lib_rs:

; 208  :         if (i < 0) break;

  000ab	48 85 db	 test	 rbx, rbx
  000ae	0f 88 b0 01 00
	00		 js	 $LN7@ucs4lib_rs

; 209  :         j = i; i--;

  000b4	48 8b fb	 mov	 rdi, rbx
  000b7	48 ff cb	 dec	 rbx

; 210  :         while (i >= 0 && !STRINGLIB_ISSPACE(str[i]))

  000ba	78 2a		 js	 SHORT $LN63@ucs4lib_rs
  000bc	0f 1f 40 00	 npad	 4
$LL18@ucs4lib_rs:
  000c0	8b 0c 9e	 mov	 ecx, DWORD PTR [rsi+rbx*4]
  000c3	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  000c9	73 06		 jae	 SHORT $LN31@ucs4lib_rs
  000cb	0f b6 04 11	 movzx	 eax, BYTE PTR [rcx+rdx]
  000cf	eb 0c		 jmp	 SHORT $LN32@ucs4lib_rs
$LN31@ucs4lib_rs:
  000d1	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
$LN32@ucs4lib_rs:
  000dd	85 c0		 test	 eax, eax
  000df	75 05		 jne	 SHORT $LN63@ucs4lib_rs

; 211  :             i--;

  000e1	48 ff cb	 dec	 rbx

; 210  :         while (i >= 0 && !STRINGLIB_ISSPACE(str[i]))

  000e4	79 da		 jns	 SHORT $LL18@ucs4lib_rs
$LN63@ucs4lib_rs:

; 212  : #ifndef STRINGLIB_MUTABLE
; 213  :         if (j == str_len - 1 && i < 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  000e6	49 3b ff	 cmp	 rdi, r15
  000e9	75 16		 jne	 SHORT $LN16@ucs4lib_rs
  000eb	48 85 db	 test	 rbx, rbx
  000ee	79 11		 jns	 SHORT $LN16@ucs4lib_rs
  000f0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  000f7	49 39 46 58	 cmp	 QWORD PTR [r14+88], rax
  000fb	0f 84 c0 00 00
	00		 je	 $LN51@ucs4lib_rs
$LN16@ucs4lib_rs:

; 219  :         }
; 220  : #endif
; 221  :         SPLIT_ADD(str, i + 1, j + 1);

  00101	48 2b fb	 sub	 rdi, rbx
  00104	48 8d 4c 9e 04	 lea	 rcx, QWORD PTR [rsi+rbx*4+4]
  00109	48 8b d7	 mov	 rdx, rdi
  0010c	e8 00 00 00 00	 call	 _PyUnicode_FromUCS4
  00111	48 8b f8	 mov	 rdi, rax
  00114	48 85 c0	 test	 rax, rax
  00117	0f 84 58 01 00
	00		 je	 $onError$123735
  0011d	48 83 fd 0c	 cmp	 rbp, 12
  00121	7d 12		 jge	 SHORT $LN14@ucs4lib_rs
  00123	49 8b 4c 24 70	 mov	 rcx, QWORD PTR [r12+112]
  00128	48 ff c5	 inc	 rbp
  0012b	48 89 44 e9 f8	 mov	 QWORD PTR [rcx+rbp*8-8], rax
  00130	e9 27 ff ff ff	 jmp	 $LN68@ucs4lib_rs
$LN14@ucs4lib_rs:
  00135	48 8b d0	 mov	 rdx, rax
  00138	49 8b cc	 mov	 rcx, r12
  0013b	e8 00 00 00 00	 call	 PyList_Append
  00140	85 c0		 test	 eax, eax
  00142	0f 85 ad 00 00
	00		 jne	 $LN53@ucs4lib_rs
  00148	e8 00 00 00 00	 call	 _Py_PXCTX
  0014d	85 c0		 test	 eax, eax
  0014f	75 68		 jne	 SHORT $LN45@ucs4lib_rs
  00151	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00155	a8 20		 test	 al, 32			; 00000020H
  00157	75 58		 jne	 SHORT $LN39@ucs4lib_rs
  00159	84 c0		 test	 al, al
  0015b	78 54		 js	 SHORT $LN39@ucs4lib_rs
  0015d	a8 02		 test	 al, 2
  0015f	75 58		 jne	 SHORT $LN45@ucs4lib_rs
  00161	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00165	75 52		 jne	 SHORT $LN45@ucs4lib_rs
  00167	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0016e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00175	4c 8b cf	 mov	 r9, rdi
  00178	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0017e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00186	e8 00 00 00 00	 call	 _PyParallel_Guard
  0018b	48 8b cf	 mov	 rcx, rdi
  0018e	85 c0		 test	 eax, eax
  00190	74 0d		 je	 SHORT $LN44@ucs4lib_rs
  00192	e8 00 00 00 00	 call	 _Px_Dealloc
  00197	48 ff c5	 inc	 rbp
  0019a	e9 bd fe ff ff	 jmp	 $LN68@ucs4lib_rs
$LN44@ucs4lib_rs:
  0019f	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001a3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001a9	48 ff c5	 inc	 rbp
  001ac	e9 ab fe ff ff	 jmp	 $LN68@ucs4lib_rs
$LN39@ucs4lib_rs:
  001b1	48 8b cf	 mov	 rcx, rdi
  001b4	e8 00 00 00 00	 call	 Px_DecRef
$LN45@ucs4lib_rs:
  001b9	48 ff c5	 inc	 rbp

; 205  :     while (maxcount-- > 0) {

  001bc	e9 9b fe ff ff	 jmp	 $LN68@ucs4lib_rs
$LN51@ucs4lib_rs:

; 214  :             /* No whitespace in str_obj, so just use it as list[0] */
; 215  :             Py_INCREF(str_obj);

  001c1	49 8b ce	 mov	 rcx, r14
  001c4	e8 00 00 00 00	 call	 _Py_IncRef

; 216  :             PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  001c9	4d 8b 5c 24 70	 mov	 r11, QWORD PTR [r12+112]

; 217  :             count++;

  001ce	48 ff c5	 inc	 rbp
  001d1	4d 89 33	 mov	 QWORD PTR [r11], r14

; 218  :             break;

  001d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
$LN56@ucs4lib_rs:

; 222  :     }
; 223  : 
; 224  :     if (i >= 0) {

  001db	48 85 db	 test	 rbx, rbx
  001de	0f 88 80 00 00
	00		 js	 $LN7@ucs4lib_rs
$LL9@ucs4lib_rs:

; 225  :         /* Only occurs when maxcount was reached */
; 226  :         /* Skip any remaining whitespace and copy to beginning of string */
; 227  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  001e4	8b 0c 9e	 mov	 ecx, DWORD PTR [rsi+rbx*4]
  001e7	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  001ed	73 1a		 jae	 SHORT $LN33@ucs4lib_rs
  001ef	0f b6 04 11	 movzx	 eax, BYTE PTR [rcx+rdx]
  001f3	eb 20		 jmp	 SHORT $LN34@ucs4lib_rs
$LN53@ucs4lib_rs:

; 219  :         }
; 220  : #endif
; 221  :         SPLIT_ADD(str, i + 1, j + 1);

  001f5	48 8b cf	 mov	 rcx, rdi
$LN69@ucs4lib_rs:
  001f8	e8 00 00 00 00	 call	 _Py_DecRef

; 236  : 
; 237  :   onError:
; 238  :     Py_DECREF(list);

  001fd	49 8b cc	 mov	 rcx, r12
  00200	e8 00 00 00 00	 call	 _Py_DecRef

; 239  :     return NULL;

  00205	33 c0		 xor	 eax, eax
  00207	eb 7b		 jmp	 SHORT $LN66@ucs4lib_rs
$LN33@ucs4lib_rs:

; 225  :         /* Only occurs when maxcount was reached */
; 226  :         /* Skip any remaining whitespace and copy to beginning of string */
; 227  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  00209	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  0020e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ascii_whitespace
$LN34@ucs4lib_rs:
  00215	85 c0		 test	 eax, eax
  00217	74 07		 je	 SHORT $LN8@ucs4lib_rs

; 228  :             i--;

  00219	48 ff cb	 dec	 rbx

; 225  :         /* Only occurs when maxcount was reached */
; 226  :         /* Skip any remaining whitespace and copy to beginning of string */
; 227  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  0021c	79 c6		 jns	 SHORT $LL9@ucs4lib_rs

; 229  :         if (i >= 0)

  0021e	eb 44		 jmp	 SHORT $LN7@ucs4lib_rs
$LN8@ucs4lib_rs:
  00220	48 85 db	 test	 rbx, rbx
  00223	78 3f		 js	 SHORT $LN7@ucs4lib_rs

; 230  :             SPLIT_ADD(str, 0, i + 1);

  00225	48 8d 53 01	 lea	 rdx, QWORD PTR [rbx+1]
  00229	48 8b ce	 mov	 rcx, rsi
  0022c	e8 00 00 00 00	 call	 _PyUnicode_FromUCS4
  00231	48 8b d8	 mov	 rbx, rax
  00234	48 85 c0	 test	 rax, rax
  00237	74 3c		 je	 SHORT $onError$123735
  00239	48 83 fd 0c	 cmp	 rbp, 12
  0023d	7d 0b		 jge	 SHORT $LN5@ucs4lib_rs
  0023f	49 8b 4c 24 70	 mov	 rcx, QWORD PTR [r12+112]
  00244	48 89 04 e9	 mov	 QWORD PTR [rcx+rbp*8], rax
  00248	eb 17		 jmp	 SHORT $LN2@ucs4lib_rs
$LN5@ucs4lib_rs:
  0024a	48 8b d0	 mov	 rdx, rax
  0024d	49 8b cc	 mov	 rcx, r12
  00250	e8 00 00 00 00	 call	 PyList_Append
  00255	48 8b cb	 mov	 rcx, rbx
  00258	85 c0		 test	 eax, eax
  0025a	75 9c		 jne	 SHORT $LN69@ucs4lib_rs
  0025c	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@ucs4lib_rs:
  00261	48 ff c5	 inc	 rbp
$LN7@ucs4lib_rs:

; 231  :     }
; 232  :     FIX_PREALLOC_SIZE(list);
; 233  :     if (PyList_Reverse(list) < 0)

  00264	49 8b cc	 mov	 rcx, r12
  00267	49 89 6c 24 60	 mov	 QWORD PTR [r12+96], rbp
  0026c	e8 00 00 00 00	 call	 PyList_Reverse
  00271	85 c0		 test	 eax, eax
  00273	79 0c		 jns	 SHORT $LN1@ucs4lib_rs
$onError$123735:

; 236  : 
; 237  :   onError:
; 238  :     Py_DECREF(list);

  00275	49 8b cc	 mov	 rcx, r12
  00278	e8 00 00 00 00	 call	 _Py_DecRef

; 239  :     return NULL;

  0027d	33 c0		 xor	 eax, eax
  0027f	eb 03		 jmp	 SHORT $LN66@ucs4lib_rs
$LN1@ucs4lib_rs:

; 234  :         goto onError;
; 235  :     return list;

  00281	49 8b c4	 mov	 rax, r12
$LN66@ucs4lib_rs:
  00284	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00289	4c 8b 7c 24 68	 mov	 r15, QWORD PTR [rsp+104]

; 240  : }

  0028e	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00293	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00297	41 5e		 pop	 r14
  00299	41 5d		 pop	 r13
  0029b	41 5c		 pop	 r12
  0029d	5e		 pop	 rsi
  0029e	5d		 pop	 rbp
  0029f	c3		 ret	 0
ucs4lib_rsplit_whitespace ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ucs4lib_rsplit_char DD imagerel ucs4lib_rsplit_char
	DD	imagerel ucs4lib_rsplit_char+79
	DD	imagerel $unwind$ucs4lib_rsplit_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ucs4lib_rsplit_char DD imagerel ucs4lib_rsplit_char+79
	DD	imagerel ucs4lib_rsplit_char+503
	DD	imagerel $chain$0$ucs4lib_rsplit_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ucs4lib_rsplit_char DD imagerel ucs4lib_rsplit_char+503
	DD	imagerel ucs4lib_rsplit_char+527
	DD	imagerel $chain$1$ucs4lib_rsplit_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ucs4lib_rsplit_char DD 021H
	DD	imagerel ucs4lib_rsplit_char
	DD	imagerel ucs4lib_rsplit_char+79
	DD	imagerel $unwind$ucs4lib_rsplit_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ucs4lib_rsplit_char DD 020521H
	DD	0c5405H
	DD	imagerel ucs4lib_rsplit_char
	DD	imagerel ucs4lib_rsplit_char+79
	DD	imagerel $unwind$ucs4lib_rsplit_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_rsplit_char DD 0a1701H
	DD	0e6417H
	DD	0d3417H
	DD	0f0135217H
	DD	0d00fe011H
	DD	0700bc00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs4lib_rsplit_char
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
ch$ = 120
maxcount$ = 128
ucs4lib_rsplit_char PROC				; COMDAT

; 247  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 248  :     Py_ssize_t i, j, count=0;
; 249  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00017	4c 8b b4 24 80
	00 00 00	 mov	 r14, QWORD PTR maxcount$[rsp]
  0001f	33 f6		 xor	 esi, esi
  00021	4c 8b f9	 mov	 r15, rcx
  00024	45 8b e9	 mov	 r13d, r9d
  00027	49 8b d8	 mov	 rbx, r8
  0002a	4c 8b e2	 mov	 r12, rdx
  0002d	8d 4e 0c	 lea	 ecx, QWORD PTR [rsi+12]
  00030	49 83 fe 0c	 cmp	 r14, 12
  00034	7d 04		 jge	 SHORT $LN25@ucs4lib_rs@2
  00036	49 8d 4e 01	 lea	 rcx, QWORD PTR [r14+1]
$LN25@ucs4lib_rs@2:
  0003a	e8 00 00 00 00	 call	 PyList_New
  0003f	48 8b f8	 mov	 rdi, rax

; 250  :     PyObject *sub;
; 251  : 
; 252  :     if (list == NULL)

  00042	48 85 c0	 test	 rax, rax
  00045	0f 84 ac 01 00
	00		 je	 $LN22@ucs4lib_rs@2
$LN21@ucs4lib_rs@2:

; 253  :         return NULL;
; 254  : 
; 255  :     i = j = str_len - 1;

  0004b	48 8d 53 ff	 lea	 rdx, QWORD PTR [rbx-1]
  0004f	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  00054	48 8b da	 mov	 rbx, rdx

; 256  :     while ((i >= 0) && (maxcount-- > 0)) {

  00057	48 85 d2	 test	 rdx, rdx
  0005a	78 75		 js	 SHORT $LN49@ucs4lib_rs@2
  0005c	0f 1f 40 00	 npad	 4
$LL20@ucs4lib_rs@2:
  00060	49 8b c6	 mov	 rax, r14
  00063	49 ff ce	 dec	 r14
  00066	48 85 c0	 test	 rax, rax
  00069	7e 61		 jle	 SHORT $LN19@ucs4lib_rs@2

; 257  :         for(; i >= 0; i--) {

  0006b	48 85 db	 test	 rbx, rbx
  0006e	78 5c		 js	 SHORT $LN19@ucs4lib_rs@2
$LL18@ucs4lib_rs@2:

; 258  :             if (str[i] == ch) {

  00070	45 39 2c 9c	 cmp	 DWORD PTR [r12+rbx*4], r13d
  00074	74 07		 je	 SHORT $LN43@ucs4lib_rs@2

; 257  :         for(; i >= 0; i--) {

  00076	48 ff cb	 dec	 rbx
  00079	79 f5		 jns	 SHORT $LL18@ucs4lib_rs@2
  0007b	eb 4f		 jmp	 SHORT $LN19@ucs4lib_rs@2
$LN43@ucs4lib_rs@2:

; 259  :                 SPLIT_ADD(str, i + 1, j + 1);

  0007d	49 8d 4c 9c 04	 lea	 rcx, QWORD PTR [r12+rbx*4+4]
  00082	48 2b d3	 sub	 rdx, rbx
  00085	e8 00 00 00 00	 call	 _PyUnicode_FromUCS4
  0008a	48 8b e8	 mov	 rbp, rax
  0008d	48 85 c0	 test	 rax, rax
  00090	0f 84 ec 00 00
	00		 je	 $onError$123790
  00096	48 83 fe 0c	 cmp	 rsi, 12
  0009a	7d 0a		 jge	 SHORT $LN13@ucs4lib_rs@2
  0009c	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  000a0	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  000a4	eb 1b		 jmp	 SHORT $LN10@ucs4lib_rs@2
$LN13@ucs4lib_rs@2:
  000a6	48 8b d0	 mov	 rdx, rax
  000a9	48 8b cf	 mov	 rcx, rdi
  000ac	e8 00 00 00 00	 call	 PyList_Append
  000b1	48 8b cd	 mov	 rcx, rbp
  000b4	85 c0		 test	 eax, eax
  000b6	0f 85 a7 00 00
	00		 jne	 $LN45@ucs4lib_rs@2
  000bc	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@ucs4lib_rs@2:
  000c1	48 ff c6	 inc	 rsi

; 260  :                 j = i = i - 1;

  000c4	48 ff cb	 dec	 rbx
  000c7	48 8b d3	 mov	 rdx, rbx
  000ca	79 94		 jns	 SHORT $LL20@ucs4lib_rs@2
$LN19@ucs4lib_rs@2:

; 261  :                 break;
; 262  :             }
; 263  :         }
; 264  :     }
; 265  : #ifndef STRINGLIB_MUTABLE
; 266  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  000cc	48 85 f6	 test	 rsi, rsi
  000cf	75 57		 jne	 SHORT $LN9@ucs4lib_rs@2
$LN49@ucs4lib_rs@2:
  000d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  000d8	49 39 47 58	 cmp	 QWORD PTR [r15+88], rax
  000dc	75 4a		 jne	 SHORT $LN9@ucs4lib_rs@2

; 267  :         /* ch not in str_obj, so just use str_obj as list[0] */
; 268  :         Py_INCREF(str_obj);

  000de	e8 00 00 00 00	 call	 _Py_PXCTX
  000e3	85 c0		 test	 eax, eax
  000e5	75 33		 jne	 SHORT $LN27@ucs4lib_rs@2
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000f5	4d 8b cf	 mov	 r9, r15
  000f8	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000fe	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00106	e8 00 00 00 00	 call	 _PyParallel_Guard
  0010b	85 c0		 test	 eax, eax
  0010d	75 07		 jne	 SHORT $LN26@ucs4lib_rs@2
  0010f	41 f6 47 20 20	 test	 BYTE PTR [r15+32], 32	; 00000020H
  00114	74 04		 je	 SHORT $LN27@ucs4lib_rs@2
$LN26@ucs4lib_rs@2:
  00116	49 ff 47 50	 inc	 QWORD PTR [r15+80]
$LN27@ucs4lib_rs@2:

; 269  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  0011a	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]

; 270  :         count++;

  0011e	be 01 00 00 00	 mov	 esi, 1
  00123	4c 89 38	 mov	 QWORD PTR [rax], r15

; 271  :     } else

  00126	eb 4a		 jmp	 SHORT $LN7@ucs4lib_rs@2
$LN9@ucs4lib_rs@2:

; 272  : #endif
; 273  :     if (j >= -1) {

  00128	48 83 fa ff	 cmp	 rdx, -1
  0012c	7c 44		 jl	 SHORT $LN7@ucs4lib_rs@2

; 274  :         SPLIT_ADD(str, 0, j + 1);

  0012e	48 ff c2	 inc	 rdx
  00131	49 8b cc	 mov	 rcx, r12
  00134	e8 00 00 00 00	 call	 _PyUnicode_FromUCS4
  00139	48 8b d8	 mov	 rbx, rax
  0013c	48 85 c0	 test	 rax, rax
  0013f	74 41		 je	 SHORT $onError$123790
  00141	48 83 fe 0c	 cmp	 rsi, 12
  00145	7d 0a		 jge	 SHORT $LN5@ucs4lib_rs@2
  00147	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  0014b	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  0014f	eb 1e		 jmp	 SHORT $LN2@ucs4lib_rs@2
$LN5@ucs4lib_rs@2:
  00151	48 8b d0	 mov	 rdx, rax
  00154	48 8b cf	 mov	 rcx, rdi
  00157	e8 00 00 00 00	 call	 PyList_Append
  0015c	48 8b cb	 mov	 rcx, rbx
  0015f	85 c0		 test	 eax, eax
  00161	74 07		 je	 SHORT $LN3@ucs4lib_rs@2
$LN45@ucs4lib_rs@2:
  00163	e8 00 00 00 00	 call	 _Py_DecRef
  00168	eb 18		 jmp	 SHORT $onError$123790
$LN3@ucs4lib_rs@2:
  0016a	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@ucs4lib_rs@2:
  0016f	48 ff c6	 inc	 rsi
$LN7@ucs4lib_rs@2:

; 275  :     }
; 276  :     FIX_PREALLOC_SIZE(list);
; 277  :     if (PyList_Reverse(list) < 0)

  00172	48 8b cf	 mov	 rcx, rdi
  00175	48 89 77 60	 mov	 QWORD PTR [rdi+96], rsi
  00179	e8 00 00 00 00	 call	 PyList_Reverse
  0017e	85 c0		 test	 eax, eax
  00180	79 6d		 jns	 SHORT $LN1@ucs4lib_rs@2
$onError$123790:

; 280  : 
; 281  :   onError:
; 282  :     Py_DECREF(list);

  00182	e8 00 00 00 00	 call	 _Py_PXCTX
  00187	85 c0		 test	 eax, eax
  00189	75 60		 jne	 SHORT $LN40@ucs4lib_rs@2
  0018b	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0018f	a8 20		 test	 al, 32			; 00000020H
  00191	75 50		 jne	 SHORT $LN34@ucs4lib_rs@2
  00193	84 c0		 test	 al, al
  00195	78 4c		 js	 SHORT $LN34@ucs4lib_rs@2
  00197	a8 02		 test	 al, 2
  00199	75 50		 jne	 SHORT $LN40@ucs4lib_rs@2
  0019b	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0019f	75 4a		 jne	 SHORT $LN40@ucs4lib_rs@2
  001a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001af	4c 8b cf	 mov	 r9, rdi
  001b2	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001b8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001c0	e8 00 00 00 00	 call	 _PyParallel_Guard
  001c5	48 8b cf	 mov	 rcx, rdi
  001c8	85 c0		 test	 eax, eax
  001ca	74 09		 je	 SHORT $LN39@ucs4lib_rs@2
  001cc	e8 00 00 00 00	 call	 _Px_Dealloc

; 283  :     return NULL;

  001d1	33 c0		 xor	 eax, eax
  001d3	eb 1d		 jmp	 SHORT $LN50@ucs4lib_rs@2

; 280  : 
; 281  :   onError:
; 282  :     Py_DECREF(list);

$LN39@ucs4lib_rs@2:
  001d5	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001d9	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 283  :     return NULL;

  001df	33 c0		 xor	 eax, eax
  001e1	eb 0f		 jmp	 SHORT $LN50@ucs4lib_rs@2

; 280  : 
; 281  :   onError:
; 282  :     Py_DECREF(list);

$LN34@ucs4lib_rs@2:
  001e3	48 8b cf	 mov	 rcx, rdi
  001e6	e8 00 00 00 00	 call	 Px_DecRef
$LN40@ucs4lib_rs@2:

; 283  :     return NULL;

  001eb	33 c0		 xor	 eax, eax
  001ed	eb 03		 jmp	 SHORT $LN50@ucs4lib_rs@2
$LN1@ucs4lib_rs@2:

; 278  :         goto onError;
; 279  :     return list;

  001ef	48 8b c7	 mov	 rax, rdi
$LN50@ucs4lib_rs@2:
  001f2	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
$LN22@ucs4lib_rs@2:

; 284  : }

  001f7	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  001fc	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  00201	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00205	41 5f		 pop	 r15
  00207	41 5e		 pop	 r14
  00209	41 5d		 pop	 r13
  0020b	41 5c		 pop	 r12
  0020d	5f		 pop	 rdi
  0020e	c3		 ret	 0
ucs4lib_rsplit_char ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$ucs4lib_rsplit DD imagerel ucs4lib_rsplit
	DD	imagerel ucs4lib_rsplit+127
	DD	imagerel $unwind$ucs4lib_rsplit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ucs4lib_rsplit DD imagerel ucs4lib_rsplit+127
	DD	imagerel ucs4lib_rsplit+747
	DD	imagerel $chain$1$ucs4lib_rsplit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ucs4lib_rsplit DD imagerel ucs4lib_rsplit+747
	DD	imagerel ucs4lib_rsplit+837
	DD	imagerel $chain$3$ucs4lib_rsplit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ucs4lib_rsplit DD 040021H
	DD	08d400H
	DD	0113400H
	DD	imagerel ucs4lib_rsplit
	DD	imagerel ucs4lib_rsplit+127
	DD	imagerel $unwind$ucs4lib_rsplit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ucs4lib_rsplit DD 041a21H
	DD	08d41aH
	DD	0113408H
	DD	imagerel ucs4lib_rsplit
	DD	imagerel ucs4lib_rsplit+127
	DD	imagerel $unwind$ucs4lib_rsplit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_rsplit DD 071701H
	DD	0f0138217H
	DD	0c00fe011H
	DD	0600c700dH
	DD	0500bH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs4lib_rsplit
_TEXT	SEGMENT
maxcount$1$ = 48
str_obj$ = 128
str$ = 136
str_len$ = 144
sep$ = 152
list$1$ = 160
sep_len$ = 160
maxcount$ = 168
ucs4lib_rsplit PROC					; COMDAT

; 291  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 292  :     Py_ssize_t j, pos, count=0;
; 293  :     PyObject *list, *sub;
; 294  : 
; 295  :     if (sep_len == 0) {

  00017	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR sep_len$[rsp]
  0001f	45 33 f6	 xor	 r14d, r14d
  00022	4d 8b e1	 mov	 r12, r9
  00025	4d 8b f8	 mov	 r15, r8
  00028	48 8b ea	 mov	 rbp, rdx
  0002b	48 8b f9	 mov	 rdi, rcx
  0002e	48 85 f6	 test	 rsi, rsi
  00031	75 23		 jne	 SHORT $LN20@ucs4lib_rs@3

; 296  :         PyErr_SetString(PyExc_ValueError, "empty separator");

  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00041	e8 00 00 00 00	 call	 PyErr_SetString

; 297  :         return NULL;

  00046	33 c0		 xor	 eax, eax

; 333  : }

  00048	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004c	41 5f		 pop	 r15
  0004e	41 5e		 pop	 r14
  00050	41 5c		 pop	 r12
  00052	5f		 pop	 rdi
  00053	5e		 pop	 rsi
  00054	5d		 pop	 rbp
  00055	c3		 ret	 0
$LN20@ucs4lib_rs@3:

; 298  :     }
; 299  :     else if (sep_len == 1)

  00056	48 83 fe 01	 cmp	 rsi, 1
  0005a	75 23		 jne	 SHORT $LN18@ucs4lib_rs@3

; 300  :         return STRINGLIB(rsplit_char)(str_obj, str, str_len, sep[0], maxcount);

  0005c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00064	45 8b 09	 mov	 r9d, DWORD PTR [r9]
  00067	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006c	e8 00 00 00 00	 call	 ucs4lib_rsplit_char

; 333  : }

  00071	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00075	41 5f		 pop	 r15
  00077	41 5e		 pop	 r14
  00079	41 5c		 pop	 r12
  0007b	5f		 pop	 rdi
  0007c	5e		 pop	 rsi
  0007d	5d		 pop	 rbp
  0007e	c3		 ret	 0
$LN18@ucs4lib_rs@3:
  0007f	48 89 9c 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbx

; 301  : 
; 302  :     list = PyList_New(PREALLOC_SIZE(maxcount));

  00087	48 8b 9c 24 a8
	00 00 00	 mov	 rbx, QWORD PTR maxcount$[rsp]
  0008f	b9 0c 00 00 00	 mov	 ecx, 12
  00094	4c 89 6c 24 40	 mov	 QWORD PTR [rsp+64], r13
  00099	48 83 fb 0c	 cmp	 rbx, 12
  0009d	7d 04		 jge	 SHORT $LN24@ucs4lib_rs@3
  0009f	48 8d 4b 01	 lea	 rcx, QWORD PTR [rbx+1]
$LN24@ucs4lib_rs@3:
  000a3	e8 00 00 00 00	 call	 PyList_New
  000a8	4c 8b e8	 mov	 r13, rax
  000ab	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR list$1$[rsp], rax

; 303  :     if (list == NULL)

  000b3	48 85 c0	 test	 rax, rax

; 304  :         return NULL;

  000b6	0f 84 12 02 00
	00		 je	 $LN126@ucs4lib_rs@3

; 305  : 
; 306  :     j = str_len;
; 307  :     while (maxcount-- > 0) {

  000bc	48 85 db	 test	 rbx, rbx
  000bf	7e 6b		 jle	 SHORT $LN115@ucs4lib_rs@3
  000c1	66 66 66 66 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL16@ucs4lib_rs@3:
  000d0	48 ff cb	 dec	 rbx
  000d3	48 89 5c 24 30	 mov	 QWORD PTR maxcount$1$[rsp], rbx

; 308  :         pos = FASTSEARCH(str, j, sep, sep_len, -1, FAST_RSEARCH);

  000d8	49 8b df	 mov	 rbx, r15
  000db	48 2b de	 sub	 rbx, rsi
  000de	78 33		 js	 SHORT $LN113@ucs4lib_rs@3
  000e0	48 83 fe 01	 cmp	 rsi, 1
  000e4	7f 71		 jg	 SHORT $LN84@ucs4lib_rs@3
  000e6	48 85 f6	 test	 rsi, rsi
  000e9	7e 28		 jle	 SHORT $LN113@ucs4lib_rs@3
  000eb	49 8d 5f ff	 lea	 rbx, QWORD PTR [r15-1]
  000ef	48 83 fb ff	 cmp	 rbx, -1
  000f3	7e 1e		 jle	 SHORT $LN113@ucs4lib_rs@3
  000f5	41 8b 04 24	 mov	 eax, DWORD PTR [r12]
  000f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL67@ucs4lib_rs@3:
  00100	39 44 9d 00	 cmp	 DWORD PTR [rbp+rbx*4], eax
  00104	0f 84 4a 01 00
	00		 je	 $LN105@ucs4lib_rs@3
  0010a	48 ff cb	 dec	 rbx
  0010d	48 83 fb ff	 cmp	 rbx, -1
  00111	7f ed		 jg	 SHORT $LL67@ucs4lib_rs@3
$LN113@ucs4lib_rs@3:

; 313  :     }
; 314  : #ifndef STRINGLIB_MUTABLE
; 315  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {

  00113	4d 85 f6	 test	 r14, r14
  00116	0f 85 cf 01 00
	00		 jne	 $LN8@ucs4lib_rs@3
  0011c	4c 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]
  00124	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR str_obj$[rsp]
$LN115@ucs4lib_rs@3:
  0012c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00133	48 39 47 58	 cmp	 QWORD PTR [rdi+88], rax
  00137	0f 85 ae 01 00
	00		 jne	 $LN8@ucs4lib_rs@3

; 316  :         /* No match in str_obj, so just use it as list[0] */
; 317  :         Py_INCREF(str_obj);

  0013d	48 8b cf	 mov	 rcx, rdi
  00140	e8 00 00 00 00	 call	 _Py_IncRef

; 318  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);

  00145	4d 8b 5d 70	 mov	 r11, QWORD PTR [r13+112]

; 319  :         count++;

  00149	41 be 01 00 00
	00		 mov	 r14d, 1
  0014f	49 89 3b	 mov	 QWORD PTR [r11], rdi

; 320  :     } else

  00152	e9 d9 01 00 00	 jmp	 $LN7@ucs4lib_rs@3

; 308  :         pos = FASTSEARCH(str, j, sep, sep_len, -1, FAST_RSEARCH);

$LN84@ucs4lib_rs@3:
  00157	45 8b 2c 24	 mov	 r13d, DWORD PTR [r12]
  0015b	48 8d 7e ff	 lea	 rdi, QWORD PTR [rsi-1]
  0015f	41 ba 01 00 00
	00		 mov	 r10d, 1
  00165	41 8b cd	 mov	 ecx, r13d
  00168	4c 8d 5f ff	 lea	 r11, QWORD PTR [rdi-1]
  0016c	4c 8b cf	 mov	 r9, rdi
  0016f	83 e1 1f	 and	 ecx, 31
  00172	41 d3 e2	 shl	 r10d, cl
  00175	48 85 ff	 test	 rdi, rdi
  00178	7e 2b		 jle	 SHORT $LN40@ucs4lib_rs@3
  0017a	66 0f 1f 44 00
	00		 npad	 6
$LL42@ucs4lib_rs@3:
  00180	47 8b 04 8c	 mov	 r8d, DWORD PTR [r12+r9*4]
  00184	ba 01 00 00 00	 mov	 edx, 1
  00189	41 8b c8	 mov	 ecx, r8d
  0018c	83 e1 1f	 and	 ecx, 31
  0018f	d3 e2		 shl	 edx, cl
  00191	44 0b d2	 or	 r10d, edx
  00194	45 3b c5	 cmp	 r8d, r13d
  00197	75 04		 jne	 SHORT $LN41@ucs4lib_rs@3
  00199	4d 8d 59 ff	 lea	 r11, QWORD PTR [r9-1]
$LN41@ucs4lib_rs@3:
  0019d	49 ff c9	 dec	 r9
  001a0	4d 85 c9	 test	 r9, r9
  001a3	7f db		 jg	 SHORT $LL42@ucs4lib_rs@3
$LN40@ucs4lib_rs@3:
  001a5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
  001ad	4c 8d 04 9d 00
	00 00 00	 lea	 r8, QWORD PTR [rbx*4]
  001b5	4c 8d 0c b5 00
	00 00 00	 lea	 r9, QWORD PTR [rsi*4]
  001bd	4c 2b c0	 sub	 r8, rax
  001c0	4e 8d 24 9d 00
	00 00 00	 lea	 r12, QWORD PTR [r11*4]
  001c8	4c 03 c5	 add	 r8, rbp
  001cb	0f 1f 44 00 00	 npad	 5
$LL38@ucs4lib_rs@3:
  001d0	44 39 6c 9d 00	 cmp	 DWORD PTR [rbp+rbx*4], r13d
  001d5	75 3f		 jne	 SHORT $LN35@ucs4lib_rs@3
  001d7	48 8b d7	 mov	 rdx, rdi
  001da	48 85 ff	 test	 rdi, rdi
  001dd	7e 18		 jle	 SHORT $LN121@ucs4lib_rs@3
  001df	48 8d 0c b8	 lea	 rcx, QWORD PTR [rax+rdi*4]
$LL34@ucs4lib_rs@3:
  001e3	8b 01		 mov	 eax, DWORD PTR [rcx]
  001e5	41 39 04 08	 cmp	 DWORD PTR [r8+rcx], eax
  001e9	75 0c		 jne	 SHORT $LN121@ucs4lib_rs@3
  001eb	48 ff ca	 dec	 rdx
  001ee	48 83 e9 04	 sub	 rcx, 4
  001f2	48 85 d2	 test	 rdx, rdx
  001f5	7f ec		 jg	 SHORT $LL34@ucs4lib_rs@3
$LN121@ucs4lib_rs@3:
  001f7	48 85 d2	 test	 rdx, rdx
  001fa	74 48		 je	 SHORT $LN123@ucs4lib_rs@3
  001fc	48 85 db	 test	 rbx, rbx
  001ff	7e 0d		 jle	 SHORT $LN29@ucs4lib_rs@3
  00201	8b 44 9d fc	 mov	 eax, DWORD PTR [rbp+rbx*4-4]
  00205	83 e0 1f	 and	 eax, 31
  00208	41 0f a3 c2	 bt	 r10d, eax
  0020c	73 1a		 jae	 SHORT $LN127@ucs4lib_rs@3
$LN29@ucs4lib_rs@3:
  0020e	49 2b db	 sub	 rbx, r11
  00211	4d 2b c4	 sub	 r8, r12
  00214	eb 18		 jmp	 SHORT $LN122@ucs4lib_rs@3
$LN35@ucs4lib_rs@3:
  00216	48 85 db	 test	 rbx, rbx
  00219	7e 1b		 jle	 SHORT $LN37@ucs4lib_rs@3
  0021b	8b 44 9d fc	 mov	 eax, DWORD PTR [rbp+rbx*4-4]
  0021f	83 e0 1f	 and	 eax, 31
  00222	41 0f a3 c2	 bt	 r10d, eax
  00226	72 06		 jb	 SHORT $LN122@ucs4lib_rs@3
$LN127@ucs4lib_rs@3:
  00228	48 2b de	 sub	 rbx, rsi
  0022b	4d 2b c1	 sub	 r8, r9
$LN122@ucs4lib_rs@3:
  0022e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR sep$[rsp]
$LN37@ucs4lib_rs@3:
  00236	49 83 e8 04	 sub	 r8, 4
  0023a	48 ff cb	 dec	 rbx
  0023d	79 91		 jns	 SHORT $LL38@ucs4lib_rs@3
  0023f	e9 cf fe ff ff	 jmp	 $LN113@ucs4lib_rs@3
$LN123@ucs4lib_rs@3:

; 291  : {

  00244	4c 8b a4 24 98
	00 00 00	 mov	 r12, QWORD PTR sep$[rsp]
  0024c	4c 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]
$LN105@ucs4lib_rs@3:

; 309  :         if (pos < 0)

  00254	48 85 db	 test	 rbx, rbx
  00257	0f 88 b6 fe ff
	ff		 js	 $LN113@ucs4lib_rs@3

; 310  :             break;
; 311  :         SPLIT_ADD(str, pos + sep_len, j);

  0025d	48 8d 04 33	 lea	 rax, QWORD PTR [rbx+rsi]
  00261	4c 2b fb	 sub	 r15, rbx
  00264	4c 2b fe	 sub	 r15, rsi
  00267	48 8d 4c 85 00	 lea	 rcx, QWORD PTR [rbp+rax*4]
  0026c	49 8b d7	 mov	 rdx, r15
  0026f	e8 00 00 00 00	 call	 _PyUnicode_FromUCS4
  00274	48 8b f8	 mov	 rdi, rax
  00277	48 85 c0	 test	 rax, rax
  0027a	74 45		 je	 SHORT $onError$123850
  0027c	49 83 fe 0c	 cmp	 r14, 12
  00280	7d 0a		 jge	 SHORT $LN12@ucs4lib_rs@3
  00282	49 8b 4d 70	 mov	 rcx, QWORD PTR [r13+112]
  00286	4a 89 04 f1	 mov	 QWORD PTR [rcx+r14*8], rax
  0028a	eb 17		 jmp	 SHORT $LN9@ucs4lib_rs@3
$LN12@ucs4lib_rs@3:
  0028c	48 8b d0	 mov	 rdx, rax
  0028f	49 8b cd	 mov	 rcx, r13
  00292	e8 00 00 00 00	 call	 PyList_Append
  00297	48 8b cf	 mov	 rcx, rdi
  0029a	85 c0		 test	 eax, eax
  0029c	75 1e		 jne	 SHORT $LN108@ucs4lib_rs@3
  0029e	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@ucs4lib_rs@3:

; 312  :         j = pos;

  002a3	4c 8b fb	 mov	 r15, rbx
  002a6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR maxcount$1$[rsp]
  002ab	49 ff c6	 inc	 r14
  002ae	48 85 db	 test	 rbx, rbx
  002b1	0f 8f 19 fe ff
	ff		 jg	 $LL16@ucs4lib_rs@3

; 324  :     }
; 325  :     FIX_PREALLOC_SIZE(list);
; 326  :     if (PyList_Reverse(list) < 0)

  002b7	e9 57 fe ff ff	 jmp	 $LN113@ucs4lib_rs@3
$LN108@ucs4lib_rs@3:

; 310  :             break;
; 311  :         SPLIT_ADD(str, pos + sep_len, j);

  002bc	e8 00 00 00 00	 call	 _Py_DecRef
$onError$123850:

; 329  : 
; 330  :   onError:
; 331  :     Py_DECREF(list);

  002c1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR list$1$[rsp]
  002c9	e8 00 00 00 00	 call	 _Py_DecRef
$LN126@ucs4lib_rs@3:

; 332  :     return NULL;

  002ce	33 c0		 xor	 eax, eax
$LN125@ucs4lib_rs@3:
  002d0	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR [rsp+136]
  002d8	4c 8b 6c 24 40	 mov	 r13, QWORD PTR [rsp+64]

; 333  : }

  002dd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002e1	41 5f		 pop	 r15
  002e3	41 5e		 pop	 r14
  002e5	41 5c		 pop	 r12
  002e7	5f		 pop	 rdi
  002e8	5e		 pop	 rsi
  002e9	5d		 pop	 rbp
  002ea	c3		 ret	 0
$LN8@ucs4lib_rs@3:

; 321  : #endif
; 322  :     {
; 323  :         SPLIT_ADD(str, 0, j);

  002eb	49 8b d7	 mov	 rdx, r15
  002ee	48 8b cd	 mov	 rcx, rbp
  002f1	e8 00 00 00 00	 call	 _PyUnicode_FromUCS4
  002f6	48 8b d8	 mov	 rbx, rax
  002f9	48 85 c0	 test	 rax, rax
  002fc	74 c3		 je	 SHORT $onError$123850
  002fe	4c 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]
  00306	49 83 fe 0c	 cmp	 r14, 12
  0030a	7d 0a		 jge	 SHORT $LN5@ucs4lib_rs@3
  0030c	49 8b 4d 70	 mov	 rcx, QWORD PTR [r13+112]
  00310	4a 89 04 f1	 mov	 QWORD PTR [rcx+r14*8], rax
  00314	eb 17		 jmp	 SHORT $LN2@ucs4lib_rs@3
$LN5@ucs4lib_rs@3:
  00316	48 8b d0	 mov	 rdx, rax
  00319	49 8b cd	 mov	 rcx, r13
  0031c	e8 00 00 00 00	 call	 PyList_Append
  00321	48 8b cb	 mov	 rcx, rbx
  00324	85 c0		 test	 eax, eax
  00326	75 94		 jne	 SHORT $LN108@ucs4lib_rs@3
  00328	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@ucs4lib_rs@3:
  0032d	49 ff c6	 inc	 r14
$LN7@ucs4lib_rs@3:

; 324  :     }
; 325  :     FIX_PREALLOC_SIZE(list);
; 326  :     if (PyList_Reverse(list) < 0)

  00330	49 8b cd	 mov	 rcx, r13
  00333	4d 89 75 60	 mov	 QWORD PTR [r13+96], r14
  00337	e8 00 00 00 00	 call	 PyList_Reverse
  0033c	85 c0		 test	 eax, eax
  0033e	78 81		 js	 SHORT $onError$123850

; 327  :         goto onError;
; 328  :     return list;

  00340	49 8b c5	 mov	 rax, r13
  00343	eb 8b		 jmp	 SHORT $LN125@ucs4lib_rs@3
ucs4lib_rsplit ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ucs4lib_splitlines DD imagerel ucs4lib_splitlines
	DD	imagerel ucs4lib_splitlines+53
	DD	imagerel $unwind$ucs4lib_splitlines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ucs4lib_splitlines DD imagerel ucs4lib_splitlines+53
	DD	imagerel ucs4lib_splitlines+414
	DD	imagerel $chain$2$ucs4lib_splitlines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ucs4lib_splitlines DD imagerel ucs4lib_splitlines+414
	DD	imagerel ucs4lib_splitlines+451
	DD	imagerel $chain$4$ucs4lib_splitlines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ucs4lib_splitlines DD 060021H
	DD	0ef400H
	DD	0d7400H
	DD	0c3400H
	DD	imagerel ucs4lib_splitlines
	DD	imagerel ucs4lib_splitlines+53
	DD	imagerel $unwind$ucs4lib_splitlines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ucs4lib_splitlines DD 061121H
	DD	0ef411H
	DD	0d740aH
	DD	0c3405H
	DD	imagerel ucs4lib_splitlines
	DD	imagerel ucs4lib_splitlines+53
	DD	imagerel $unwind$ucs4lib_splitlines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_splitlines DD 060d01H
	DD	0e009520dH
	DD	0c005d007H
	DD	050026003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT ucs4lib_splitlines
_TEXT	SEGMENT
str_obj$ = 96
str$ = 104
str_len$ = 112
keepends$ = 120
ucs4lib_splitlines PROC					; COMDAT

; 339  : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000d	4c 8b e9	 mov	 r13, rcx

; 340  :     /* This does not use the preallocated list because splitlines is
; 341  :        usually run with hundreds of newlines.  The overhead of
; 342  :        switching between PyList_SET_ITEM and append causes about a
; 343  :        2-3% slowdown for that common case.  A smarter implementation
; 344  :        could move the if check out, so the SET_ITEMs are done first
; 345  :        and the appends only done when the prealloc buffer is full.
; 346  :        That's too much work for little gain.*/
; 347  : 
; 348  :     register Py_ssize_t i;
; 349  :     register Py_ssize_t j;
; 350  :     PyObject *list = PyList_New(0);

  00010	33 c9		 xor	 ecx, ecx
  00012	45 8b f1	 mov	 r14d, r9d
  00015	49 8b f0	 mov	 rsi, r8
  00018	48 8b ea	 mov	 rbp, rdx
  0001b	e8 00 00 00 00	 call	 PyList_New
  00020	4c 8b e0	 mov	 r12, rax

; 351  :     PyObject *sub;
; 352  : 
; 353  :     if (list == NULL)

  00023	48 85 c0	 test	 rax, rax
  00026	75 0d		 jne	 SHORT $LN14@ucs4lib_sp@4

; 389  : }

  00028	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002c	41 5e		 pop	 r14
  0002e	41 5d		 pop	 r13
  00030	41 5c		 pop	 r12
  00032	5e		 pop	 rsi
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
$LN14@ucs4lib_sp@4:
  00035	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  0003a	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi

; 354  :         return NULL;
; 355  : 
; 356  :     for (i = j = 0; i < str_len; ) {

  0003f	33 ff		 xor	 edi, edi
  00041	4c 89 7c 24 70	 mov	 QWORD PTR [rsp+112], r15
  00046	8b df		 mov	 ebx, edi
  00048	48 85 f6	 test	 rsi, rsi
  0004b	0f 8e 2e 01 00
	00		 jle	 $LN12@ucs4lib_sp@4
  00051	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:ascii_linebreak
$LN48@ucs4lib_sp@4:
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyUnicode_Type

; 357  :         Py_ssize_t eol;
; 358  : 
; 359  :         /* Find a line and append it */
; 360  :         while (i < str_len && !STRINGLIB_ISLINEBREAK(str[i]))

  0005f	48 3b de	 cmp	 rbx, rsi
  00062	7d 3b		 jge	 SHORT $LN40@ucs4lib_sp@4
$LL11@ucs4lib_sp@4:
  00064	8b 4c 9d 00	 mov	 ecx, DWORD PTR [rbp+rbx*4]
  00068	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0006e	73 07		 jae	 SHORT $LN19@ucs4lib_sp@4
  00070	42 0f b6 04 39	 movzx	 eax, BYTE PTR [rcx+r15]
  00075	eb 15		 jmp	 SHORT $LN47@ucs4lib_sp@4
$LN19@ucs4lib_sp@4:
  00077	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR bloom_linebreak
  0007d	8b d1		 mov	 edx, ecx
  0007f	83 e2 1f	 and	 edx, 31
  00082	0f a3 d0	 bt	 eax, edx
  00085	73 09		 jae	 SHORT $LN39@ucs4lib_sp@4
  00087	e8 00 00 00 00	 call	 _PyUnicode_IsLinebreak
$LN47@ucs4lib_sp@4:
  0008c	85 c0		 test	 eax, eax
  0008e	75 08		 jne	 SHORT $LN42@ucs4lib_sp@4
$LN39@ucs4lib_sp@4:

; 361  :             i++;

  00090	48 ff c3	 inc	 rbx
  00093	48 3b de	 cmp	 rbx, rsi
  00096	7c cc		 jl	 SHORT $LL11@ucs4lib_sp@4
$LN42@ucs4lib_sp@4:
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyUnicode_Type
$LN40@ucs4lib_sp@4:

; 362  : 
; 363  :         /* Skip the line break reading CRLF as one line break */
; 364  :         eol = i;

  0009f	48 8b d3	 mov	 rdx, rbx

; 365  :         if (i < str_len) {

  000a2	48 3b de	 cmp	 rbx, rsi
  000a5	7d 27		 jge	 SHORT $LN6@ucs4lib_sp@4

; 366  :             if (str[i] == '\r' && i + 1 < str_len && str[i+1] == '\n')

  000a7	83 7c 9d 00 0d	 cmp	 DWORD PTR [rbp+rbx*4], 13
  000ac	75 16		 jne	 SHORT $LN8@ucs4lib_sp@4
  000ae	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
  000b2	48 3b c6	 cmp	 rax, rsi
  000b5	7d 0d		 jge	 SHORT $LN8@ucs4lib_sp@4
  000b7	83 7c 9d 04 0a	 cmp	 DWORD PTR [rbp+rbx*4+4], 10
  000bc	75 06		 jne	 SHORT $LN8@ucs4lib_sp@4

; 367  :                 i += 2;

  000be	48 83 c3 02	 add	 rbx, 2

; 368  :             else

  000c2	eb 03		 jmp	 SHORT $LN7@ucs4lib_sp@4
$LN8@ucs4lib_sp@4:

; 369  :                 i++;

  000c4	48 ff c3	 inc	 rbx
$LN7@ucs4lib_sp@4:

; 370  :             if (keepends)

  000c7	45 85 f6	 test	 r14d, r14d
  000ca	48 0f 45 d3	 cmovne	 rdx, rbx
$LN6@ucs4lib_sp@4:

; 371  :                 eol = i;
; 372  :         }
; 373  : #ifndef STRINGLIB_MUTABLE
; 374  :         if (j == 0 && eol == str_len && STRINGLIB_CHECK_EXACT(str_obj)) {

  000ce	48 85 ff	 test	 rdi, rdi
  000d1	75 0f		 jne	 SHORT $LN5@ucs4lib_sp@4
  000d3	48 3b d6	 cmp	 rdx, rsi
  000d6	75 0a		 jne	 SHORT $LN5@ucs4lib_sp@4
  000d8	49 39 4d 58	 cmp	 QWORD PTR [r13+88], rcx
  000dc	0f 84 bc 00 00
	00		 je	 $LN34@ucs4lib_sp@4
$LN5@ucs4lib_sp@4:

; 379  :         }
; 380  : #endif
; 381  :         SPLIT_APPEND(str, j, eol);

  000e2	48 8d 4c bd 00	 lea	 rcx, QWORD PTR [rbp+rdi*4]
  000e7	48 2b d7	 sub	 rdx, rdi
  000ea	e8 00 00 00 00	 call	 _PyUnicode_FromUCS4
  000ef	48 8b f8	 mov	 rdi, rax
  000f2	48 85 c0	 test	 rax, rax
  000f5	0f 84 bc 00 00
	00		 je	 $onError$123908
  000fb	48 8b d0	 mov	 rdx, rax
  000fe	49 8b cc	 mov	 rcx, r12
  00101	e8 00 00 00 00	 call	 PyList_Append
  00106	85 c0		 test	 eax, eax
  00108	0f 85 a1 00 00
	00		 jne	 $LN36@ucs4lib_sp@4
  0010e	e8 00 00 00 00	 call	 _Py_PXCTX
  00113	85 c0		 test	 eax, eax
  00115	75 5c		 jne	 SHORT $LN31@ucs4lib_sp@4
  00117	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0011b	a8 20		 test	 al, 32			; 00000020H
  0011d	75 4c		 jne	 SHORT $LN25@ucs4lib_sp@4
  0011f	84 c0		 test	 al, al
  00121	78 48		 js	 SHORT $LN25@ucs4lib_sp@4
  00123	a8 02		 test	 al, 2
  00125	75 4c		 jne	 SHORT $LN31@ucs4lib_sp@4
  00127	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0012b	75 46		 jne	 SHORT $LN31@ucs4lib_sp@4
  0012d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0013b	4c 8b cf	 mov	 r9, rdi
  0013e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00144	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0014c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00151	48 8b cf	 mov	 rcx, rdi
  00154	85 c0		 test	 eax, eax
  00156	74 07		 je	 SHORT $LN30@ucs4lib_sp@4
  00158	e8 00 00 00 00	 call	 _Px_Dealloc
  0015d	eb 14		 jmp	 SHORT $LN31@ucs4lib_sp@4
$LN30@ucs4lib_sp@4:
  0015f	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00163	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00169	eb 08		 jmp	 SHORT $LN31@ucs4lib_sp@4
$LN25@ucs4lib_sp@4:
  0016b	48 8b cf	 mov	 rcx, rdi
  0016e	e8 00 00 00 00	 call	 Px_DecRef
$LN31@ucs4lib_sp@4:

; 382  :         j = i;

  00173	48 8b fb	 mov	 rdi, rbx
  00176	48 3b de	 cmp	 rbx, rsi
  00179	0f 8c d9 fe ff
	ff		 jl	 $LN48@ucs4lib_sp@4
$LN12@ucs4lib_sp@4:

; 383  :     }
; 384  :     return list;

  0017f	49 8b c4	 mov	 rax, r12
$LN45@ucs4lib_sp@4:
  00182	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00187	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0018c	4c 8b 7c 24 70	 mov	 r15, QWORD PTR [rsp+112]

; 389  : }

  00191	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00195	41 5e		 pop	 r14
  00197	41 5d		 pop	 r13
  00199	41 5c		 pop	 r12
  0019b	5e		 pop	 rsi
  0019c	5d		 pop	 rbp
  0019d	c3		 ret	 0
$LN34@ucs4lib_sp@4:

; 375  :             /* No linebreak in str_obj, so just use it as list[0] */
; 376  :             if (PyList_Append(list, str_obj))

  0019e	49 8b d5	 mov	 rdx, r13
  001a1	49 8b cc	 mov	 rcx, r12
  001a4	e8 00 00 00 00	 call	 PyList_Append
  001a9	85 c0		 test	 eax, eax
  001ab	75 0a		 jne	 SHORT $onError$123908

; 377  :                 goto onError;
; 378  :             break;

  001ad	eb d0		 jmp	 SHORT $LN12@ucs4lib_sp@4
$LN36@ucs4lib_sp@4:

; 379  :         }
; 380  : #endif
; 381  :         SPLIT_APPEND(str, j, eol);

  001af	48 8b cf	 mov	 rcx, rdi
  001b2	e8 00 00 00 00	 call	 _Py_DecRef
$onError$123908:

; 385  : 
; 386  :   onError:
; 387  :     Py_DECREF(list);

  001b7	49 8b cc	 mov	 rcx, r12
  001ba	e8 00 00 00 00	 call	 _Py_DecRef

; 388  :     return NULL;

  001bf	33 c0		 xor	 eax, eax
  001c1	eb bf		 jmp	 SHORT $LN45@ucs4lib_sp@4
ucs4lib_splitlines ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\find.h
pdata	SEGMENT
$pdata$stringlib_parse_args_finds_unicode DD imagerel stringlib_parse_args_finds_unicode
	DD	imagerel stringlib_parse_args_finds_unicode+70
	DD	imagerel $unwind$stringlib_parse_args_finds_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_parse_args_finds_unicode DD 020601H
	DD	030027206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT stringlib_parse_args_finds_unicode
_TEXT	SEGMENT
tmp_substring$ = 48
function_name$ = 80
args$ = 88
substring$ = 96
start$ = 104
end$ = 112
stringlib_parse_args_finds_unicode PROC			; COMDAT

; 156  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 157  :     PyObject *tmp_substring;
; 158  : 
; 159  :     if(STRINGLIB(parse_args_finds)(function_name, args, &tmp_substring,
; 160  :                                   start, end)) {

  00006	48 8b 44 24 70	 mov	 rax, QWORD PTR end$[rsp]
  0000b	49 8b d8	 mov	 rbx, r8
  0000e	4c 8d 44 24 30	 lea	 r8, QWORD PTR tmp_substring$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00018	e8 00 00 00 00	 call	 stringlib_parse_args_finds
  0001d	85 c0		 test	 eax, eax
  0001f	74 1d		 je	 SHORT $LN2@stringlib_@2

; 161  :         tmp_substring = PyUnicode_FromObject(tmp_substring);

  00021	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tmp_substring$[rsp]
  00026	e8 00 00 00 00	 call	 PyUnicode_FromObject

; 162  :         if (!tmp_substring)

  0002b	48 85 c0	 test	 rax, rax

; 163  :             return 0;

  0002e	74 0e		 je	 SHORT $LN2@stringlib_@2

; 164  :         *substring = tmp_substring;

  00030	48 89 03	 mov	 QWORD PTR [rbx], rax

; 165  :         return 1;

  00033	b8 01 00 00 00	 mov	 eax, 1

; 168  : }

  00038	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0003c	5b		 pop	 rbx
  0003d	c3		 ret	 0
$LN2@stringlib_@2:

; 166  :     }
; 167  :     return 0;

  0003e	33 c0		 xor	 eax, eax

; 168  : }

  00040	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00044	5b		 pop	 rbx
  00045	c3		 ret	 0
stringlib_parse_args_finds_unicode ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\unicodeobject.c
pdata	SEGMENT
$pdata$resize_copy DD imagerel resize_copy
	DD	imagerel resize_copy+306
	DD	imagerel $unwind$resize_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$resize_copy DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT resize_copy
_TEXT	SEGMENT
unicode$ = 64
length$ = 72
resize_copy PROC					; COMDAT

; 798  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 799  :     Py_ssize_t copy_length;
; 800  :     if (_PyUnicode_KIND(unicode) != PyUnicode_WCHAR_KIND) {

  0000f	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx
  00018	a8 1c		 test	 al, 28
  0001a	0f 84 93 00 00
	00		 je	 $LN13@resize_cop

; 801  :         PyObject *copy;
; 802  : 
; 803  :         if (PyUnicode_READY(unicode) == -1)

  00020	84 c0		 test	 al, al
  00022	78 1c		 js	 SHORT $LN12@resize_cop
  00024	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00029	83 f8 ff	 cmp	 eax, -1
  0002c	75 12		 jne	 SHORT $LN12@resize_cop
$LN26@resize_cop:

; 804  :             return NULL;

  0002e	33 c0		 xor	 eax, eax

; 825  :     }
; 826  : }

  00030	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00035	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0003a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003e	5f		 pop	 rdi
  0003f	c3		 ret	 0
$LN12@resize_cop:

; 805  : 
; 806  :         copy = PyUnicode_New(length, PyUnicode_MAX_CHAR_VALUE(unicode));

  00040	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00043	a8 40		 test	 al, 64			; 00000040H
  00045	74 07		 je	 SHORT $LN20@resize_cop
  00047	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  0004c	eb 22		 jmp	 SHORT $LN19@resize_cop
$LN20@resize_cop:
  0004e	c1 e8 02	 shr	 eax, 2
  00051	83 e0 07	 and	 eax, 7
  00054	83 f8 01	 cmp	 eax, 1
  00057	75 07		 jne	 SHORT $LN18@resize_cop
  00059	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  0005e	eb 10		 jmp	 SHORT $LN19@resize_cop
$LN18@resize_cop:
  00060	ba ff ff 10 00	 mov	 edx, 1114111		; 0010ffffH
  00065	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0006a	83 f8 02	 cmp	 eax, 2
  0006d	0f 44 d1	 cmove	 edx, ecx
$LN19@resize_cop:
  00070	48 8b ce	 mov	 rcx, rsi
  00073	e8 00 00 00 00	 call	 PyUnicode_New
  00078	48 8b f8	 mov	 rdi, rax

; 807  :         if (copy == NULL)

  0007b	48 85 c0	 test	 rax, rax

; 808  :             return NULL;

  0007e	74 ae		 je	 SHORT $LN26@resize_cop

; 809  : 
; 810  :         copy_length = Py_MIN(length, PyUnicode_GET_LENGTH(unicode));

  00080	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]

; 811  :         _PyUnicode_FastCopyCharacters(copy, 0, unicode, 0, copy_length);

  00084	4c 8b c3	 mov	 r8, rbx
  00087	48 8b cf	 mov	 rcx, rdi
  0008a	48 3b f0	 cmp	 rsi, rax
  0008d	48 0f 4f f0	 cmovg	 rsi, rax
  00091	45 33 c9	 xor	 r9d, r9d
  00094	33 d2		 xor	 edx, edx
  00096	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0009b	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 824  :         return w;

  000a0	48 8b c7	 mov	 rax, rdi

; 825  :     }
; 826  : }

  000a3	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a8	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000ad	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b1	5f		 pop	 rdi
  000b2	c3		 ret	 0
$LN13@resize_cop:

; 812  :         return copy;
; 813  :     }
; 814  :     else {
; 815  :         PyObject *w;
; 816  : 
; 817  :         w = (PyObject*)_PyUnicode_New(length);

  000b3	48 8b ca	 mov	 rcx, rdx
  000b6	e8 00 00 00 00	 call	 _PyUnicode_New
  000bb	48 8b f8	 mov	 rdi, rax

; 818  :         if (w == NULL)

  000be	48 85 c0	 test	 rax, rax

; 819  :             return NULL;

  000c1	0f 84 67 ff ff
	ff		 je	 $LN26@resize_cop

; 820  :         copy_length = _PyUnicode_WSTR_LENGTH(unicode);

  000c7	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]

; 821  :         copy_length = Py_MIN(copy_length, length);
; 822  :         Py_UNICODE_COPY(_PyUnicode_WSTR(w), _PyUnicode_WSTR(unicode),
; 823  :                         copy_length);

  000ce	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  000d2	48 8b 53 78	 mov	 rdx, QWORD PTR [rbx+120]
  000d6	4c 3b c6	 cmp	 r8, rsi
  000d9	4c 0f 4f c6	 cmovg	 r8, rsi
  000dd	4d 03 c0	 add	 r8, r8
  000e0	49 83 f8 10	 cmp	 r8, 16
  000e4	72 18		 jb	 SHORT $LN5@resize_cop
  000e6	e8 00 00 00 00	 call	 memcpy

; 824  :         return w;

  000eb	48 8b c7	 mov	 rax, rdi

; 825  :     }
; 826  : }

  000ee	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000f3	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000f8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fc	5f		 pop	 rdi
  000fd	c3		 ret	 0
$LN5@resize_cop:

; 821  :         copy_length = Py_MIN(copy_length, length);
; 822  :         Py_UNICODE_COPY(_PyUnicode_WSTR(w), _PyUnicode_WSTR(unicode),
; 823  :                         copy_length);

  000fe	4d 85 c0	 test	 r8, r8
  00101	74 1c		 je	 SHORT $LN7@resize_cop
  00103	48 2b d1	 sub	 rdx, rcx
  00106	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL3@resize_cop:
  00110	0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+rcx]
  00114	48 ff c1	 inc	 rcx
  00117	49 ff c8	 dec	 r8
  0011a	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0011d	75 f1		 jne	 SHORT $LL3@resize_cop
$LN7@resize_cop:

; 825  :     }
; 826  : }

  0011f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00124	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00129	48 8b c7	 mov	 rax, rdi
  0012c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00130	5f		 pop	 rdi
  00131	c3		 ret	 0
resize_copy ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@MAINDIAD@Cannot?5modify?5a?5string?5currently@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_check_modifiable DD imagerel unicode_check_modifiable
	DD	imagerel unicode_check_modifiable+47
	DD	imagerel $unwind$unicode_check_modifiable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_check_modifiable DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CG@MAINDIAD@Cannot?5modify?5a?5string?5currently@
CONST	SEGMENT
??_C@_0CG@MAINDIAD@Cannot?5modify?5a?5string?5currently@ DB 'Cannot modif'
	DB	'y a string currently used', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_check_modifiable
_TEXT	SEGMENT
unicode$ = 48
unicode_check_modifiable PROC				; COMDAT

; 1148 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1149 :     if (!unicode_modifiable(unicode)) {

  00004	e8 00 00 00 00	 call	 unicode_modifiable
  00009	85 c0		 test	 eax, eax
  0000b	75 1b		 jne	 SHORT $LN1@unicode_ch

; 1150 :         PyErr_SetString(PyExc_SystemError,
; 1151 :                         "Cannot modify a string currently used");

  0000d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@MAINDIAD@Cannot?5modify?5a?5string?5currently@
  0001b	e8 00 00 00 00	 call	 PyErr_SetString

; 1152 :         return -1;

  00020	83 c8 ff	 or	 eax, -1

; 1155 : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
$LN1@unicode_ch:

; 1153 :     }
; 1154 :     return 0;

  00028	33 c0		 xor	 eax, eax

; 1155 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
unicode_check_modifiable ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DJ@PCJNDPNP@Cannot?5copy?5?$CFs?5characters?5into?5a@ ; `string'
PUBLIC	??_C@_0EB@LBIJHODI@Cannot?5write?5?$CFzi?5characters?5at?5?$CF@ ; `string'
PUBLIC	PyUnicode_CopyCharacters
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_CopyCharacters DD imagerel $LN23
	DD	imagerel $LN23+155
	DD	imagerel $unwind$PyUnicode_CopyCharacters
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyUnicode_CopyCharacters DD imagerel $LN23+155
	DD	imagerel $LN23+220
	DD	imagerel $chain$0$PyUnicode_CopyCharacters
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyUnicode_CopyCharacters DD imagerel $LN23+220
	DD	imagerel $LN23+242
	DD	imagerel $chain$1$PyUnicode_CopyCharacters
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyUnicode_CopyCharacters DD imagerel $LN23+242
	DD	imagerel $LN23+351
	DD	imagerel $chain$2$PyUnicode_CopyCharacters
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyUnicode_CopyCharacters DD imagerel $LN23+351
	DD	imagerel $LN23+377
	DD	imagerel $chain$3$PyUnicode_CopyCharacters
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyUnicode_CopyCharacters DD 021H
	DD	imagerel $LN23
	DD	imagerel $LN23+155
	DD	imagerel $unwind$PyUnicode_CopyCharacters
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyUnicode_CopyCharacters DD 020021H
	DD	083400H
	DD	imagerel $LN23
	DD	imagerel $LN23+155
	DD	imagerel $unwind$PyUnicode_CopyCharacters
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyUnicode_CopyCharacters DD 021H
	DD	imagerel $LN23
	DD	imagerel $LN23+155
	DD	imagerel $unwind$PyUnicode_CopyCharacters
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyUnicode_CopyCharacters DD 020521H
	DD	083405H
	DD	imagerel $LN23
	DD	imagerel $LN23+155
	DD	imagerel $unwind$PyUnicode_CopyCharacters
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_CopyCharacters DD 081501H
	DD	0b7415H
	DD	0a6415H
	DD	095415H
	DD	0c0115215H
xdata	ENDS
;	COMDAT ??_C@_0DJ@PCJNDPNP@Cannot?5copy?5?$CFs?5characters?5into?5a@
CONST	SEGMENT
??_C@_0DJ@PCJNDPNP@Cannot?5copy?5?$CFs?5characters?5into?5a@ DB 'Cannot c'
	DB	'opy %s characters into a string of %s characters', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@LBIJHODI@Cannot?5write?5?$CFzi?5characters?5at?5?$CF@
CONST	SEGMENT
??_C@_0EB@LBIJHODI@Cannot?5write?5?$CFzi?5characters?5at?5?$CF@ DB 'Canno'
	DB	't write %zi characters at %zi in a string of %zi characters', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_CopyCharacters
_TEXT	SEGMENT
to$ = 64
to_start$ = 72
from$ = 80
from_start$ = 88
how_many$ = 96
PyUnicode_CopyCharacters PROC				; COMDAT

; 1311 : {

$LN23:
  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1312 :     int err;
; 1313 : 
; 1314 :     if (!PyUnicode_Check(from) || !PyUnicode_Check(to)) {

  00015	49 8b 40 58	 mov	 rax, QWORD PTR [r8+88]
  00019	4d 8b e1	 mov	 r12, r9
  0001c	49 8b f0	 mov	 rsi, r8
  0001f	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00029	48 8b ea	 mov	 rbp, rdx
  0002c	48 8b f9	 mov	 rdi, rcx
  0002f	0f 84 2a 01 00
	00		 je	 $LN9@PyUnicode_@51
  00035	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00039	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00043	0f 84 16 01 00
	00		 je	 $LN9@PyUnicode_@51

; 1317 :     }
; 1318 : 
; 1319 :     if (PyUnicode_READY(from) == -1)

  00049	41 f6 40 70 80	 test	 BYTE PTR [r8+112], 128	; 00000080H
  0004e	75 0d		 jne	 SHORT $LN8@PyUnicode_@51
  00050	49 8b c8	 mov	 rcx, r8
  00053	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00058	83 f8 ff	 cmp	 eax, -1

; 1320 :         return -1;

  0005b	74 2b		 je	 SHORT $LN21@PyUnicode_@51
$LN8@PyUnicode_@51:

; 1321 :     if (PyUnicode_READY(to) == -1)

  0005d	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  00061	75 0d		 jne	 SHORT $LN7@PyUnicode_@51
  00063	48 8b cf	 mov	 rcx, rdi
  00066	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0006b	83 f8 ff	 cmp	 eax, -1

; 1322 :         return -1;

  0006e	74 18		 je	 SHORT $LN21@PyUnicode_@51
$LN7@PyUnicode_@51:

; 1323 : 
; 1324 :     if (from_start < 0) {

  00070	4d 85 e4	 test	 r12, r12
  00073	79 19		 jns	 SHORT $LN6@PyUnicode_@51
$LN22@PyUnicode_@51:

; 1325 :         PyErr_SetString(PyExc_IndexError, "string index out of range");

  00075	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@DOEPEGBG@string?5index?5out?5of?5range?$AA@
  00083	e8 00 00 00 00	 call	 PyErr_SetString
$LN21@PyUnicode_@51:

; 1326 :         return -1;

  00088	48 83 c8 ff	 or	 rax, -1
  0008c	eb 4e		 jmp	 SHORT $LN11@PyUnicode_@51
$LN6@PyUnicode_@51:

; 1327 :     }
; 1328 :     if (to_start < 0) {

  0008e	48 85 ed	 test	 rbp, rbp

; 1329 :         PyErr_SetString(PyExc_IndexError, "string index out of range");
; 1330 :         return -1;

  00091	78 e2		 js	 SHORT $LN22@PyUnicode_@51

; 1331 :     }
; 1332 :     how_many = Py_MIN(PyUnicode_GET_LENGTH(from), how_many);

  00093	48 8b 46 60	 mov	 rax, QWORD PTR [rsi+96]

; 1333 :     if (to_start + how_many > PyUnicode_GET_LENGTH(to)) {

  00097	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  0009b	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  000a0	48 8b 5c 24 60	 mov	 rbx, QWORD PTR how_many$[rsp]
  000a5	48 3b c3	 cmp	 rax, rbx
  000a8	48 0f 4e d8	 cmovle	 rbx, rax
  000ac	48 8d 04 2b	 lea	 rax, QWORD PTR [rbx+rbp]
  000b0	48 3b c1	 cmp	 rax, rcx
  000b3	7e 3d		 jle	 SHORT $LN4@PyUnicode_@51

; 1334 :         PyErr_Format(PyExc_SystemError,
; 1335 :                      "Cannot write %zi characters at %zi "
; 1336 :                      "in a string of %zi characters",
; 1337 :                      how_many, to_start, PyUnicode_GET_LENGTH(to));

  000b5	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000ba	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EB@LBIJHODI@Cannot?5write?5?$CFzi?5characters?5at?5?$CF@
  000c8	4c 8b cd	 mov	 r9, rbp
  000cb	4c 8b c3	 mov	 r8, rbx
  000ce	e8 00 00 00 00	 call	 PyErr_Format
$LN20@PyUnicode_@51:

; 1338 :         return -1;

  000d3	48 83 c8 ff	 or	 rax, -1
$LN19@PyUnicode_@51:
  000d7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN11@PyUnicode_@51:

; 1357 : }

  000dc	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000e1	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000e6	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000eb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ef	41 5c		 pop	 r12
  000f1	c3		 ret	 0
$LN4@PyUnicode_@51:

; 1339 :     }
; 1340 : 
; 1341 :     if (how_many == 0)

  000f2	48 85 db	 test	 rbx, rbx
  000f5	75 04		 jne	 SHORT $LN3@PyUnicode_@51

; 1342 :         return 0;

  000f7	33 c0		 xor	 eax, eax
  000f9	eb dc		 jmp	 SHORT $LN19@PyUnicode_@51
$LN3@PyUnicode_@51:

; 1343 : 
; 1344 :     if (unicode_check_modifiable(to))

  000fb	48 8b cf	 mov	 rcx, rdi
  000fe	e8 00 00 00 00	 call	 unicode_check_modifiable
  00103	85 c0		 test	 eax, eax

; 1345 :         return -1;

  00105	75 cc		 jne	 SHORT $LN20@PyUnicode_@51

; 1346 : 
; 1347 :     err = _copy_characters(to, to_start, from, from_start, how_many, 1);

  00107	4d 8b cc	 mov	 r9, r12
  0010a	4c 8b c6	 mov	 r8, rsi
  0010d	48 8b d5	 mov	 rdx, rbp
  00110	48 8b cf	 mov	 rcx, rdi
  00113	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  0011b	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00120	e8 00 00 00 00	 call	 _copy_characters

; 1348 :     if (err) {

  00125	85 c0		 test	 eax, eax
  00127	74 2e		 je	 SHORT $LN1@PyUnicode_@51

; 1349 :         PyErr_Format(PyExc_SystemError,
; 1350 :                      "Cannot copy %s characters "
; 1351 :                      "into a string of %s characters",
; 1352 :                      unicode_kind_name(from),
; 1353 :                      unicode_kind_name(to));

  00129	48 8b cf	 mov	 rcx, rdi
  0012c	e8 00 00 00 00	 call	 unicode_kind_name
  00131	48 8b ce	 mov	 rcx, rsi
  00134	4c 8b c8	 mov	 r9, rax
  00137	e8 00 00 00 00	 call	 unicode_kind_name
  0013c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DJ@PCJNDPNP@Cannot?5copy?5?$CFs?5characters?5into?5a@
  0014a	4c 8b c0	 mov	 r8, rax
  0014d	e8 00 00 00 00	 call	 PyErr_Format

; 1354 :         return -1;

  00152	e9 7c ff ff ff	 jmp	 $LN20@PyUnicode_@51
$LN1@PyUnicode_@51:

; 1355 :     }
; 1356 :     return how_many;

  00157	48 8b c3	 mov	 rax, rbx
  0015a	e9 78 ff ff ff	 jmp	 $LN19@PyUnicode_@51
$LN9@PyUnicode_@51:

; 1315 :         PyErr_BadInternalCall();

  0015f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00166	ba 23 05 00 00	 mov	 edx, 1315		; 00000523H
  0016b	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1316 :         return -1;

  00170	48 83 c8 ff	 or	 rax, -1
  00174	e9 63 ff ff ff	 jmp	 $LN11@PyUnicode_@51
PyUnicode_CopyCharacters ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$unicode_resize DD imagerel unicode_resize
	DD	imagerel unicode_resize+345
	DD	imagerel $unwind$unicode_resize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_resize DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT unicode_resize
_TEXT	SEGMENT
p_unicode$ = 64
length$ = 72
unicode_resize PROC					; COMDAT

; 1621 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1622 :     PyObject *unicode;
; 1623 :     Py_ssize_t old_length;
; 1624 : 
; 1625 :     assert(p_unicode != NULL);
; 1626 :     unicode = *p_unicode;

  0000f	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b f9	 mov	 rdi, rcx

; 1627 : 
; 1628 :     assert(unicode != NULL);
; 1629 :     assert(PyUnicode_Check(unicode));
; 1630 :     assert(0 <= length);
; 1631 : 
; 1632 :     if (_PyUnicode_KIND(unicode) == PyUnicode_WCHAR_KIND)

  00018	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0001b	a8 1c		 test	 al, 28
  0001d	75 11		 jne	 SHORT $LN15@unicode_re@6

; 1633 :         old_length = PyUnicode_WSTR_LENGTH(unicode);

  0001f	a8 40		 test	 al, 64			; 00000040H
  00021	74 04		 je	 SHORT $LN18@unicode_re@6
  00023	a8 20		 test	 al, 32			; 00000020H
  00025	75 09		 jne	 SHORT $LN15@unicode_re@6
$LN18@unicode_re@6:
  00027	48 8b 83 90 00
	00 00		 mov	 rax, QWORD PTR [rbx+144]

; 1634 :     else

  0002e	eb 04		 jmp	 SHORT $LN14@unicode_re@6
$LN15@unicode_re@6:

; 1635 :         old_length = PyUnicode_GET_LENGTH(unicode);

  00030	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
$LN14@unicode_re@6:

; 1636 :     if (old_length == length)

  00034	48 3b c2	 cmp	 rax, rdx

; 1637 :         return 0;

  00037	0f 84 82 00 00
	00		 je	 $LN33@unicode_re@6

; 1638 : 
; 1639 :     if (length == 0) {

  0003d	48 85 d2	 test	 rdx, rdx
  00040	0f 85 9e 00 00
	00		 jne	 $LN12@unicode_re@6

; 1640 :         _Py_INCREF_UNICODE_EMPTY();

  00046	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR unicode_empty
  0004d	48 85 db	 test	 rbx, rbx
  00050	75 16		 jne	 SHORT $LN32@unicode_re@6
  00052	33 c9		 xor	 ecx, ecx
  00054	e8 00 00 00 00	 call	 PyUnicode_New
  00059	48 8b d8	 mov	 rbx, rax
  0005c	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  00063	48 85 c0	 test	 rax, rax
  00066	74 69		 je	 SHORT $LN28@unicode_re@6
$LN32@unicode_re@6:
  00068	e8 00 00 00 00	 call	 _Py_PXCTX
  0006d	85 c0		 test	 eax, eax
  0006f	75 32		 jne	 SHORT $LN10@unicode_re@6
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0007f	4c 8b cb	 mov	 r9, rbx
  00082	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00088	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00090	e8 00 00 00 00	 call	 _PyParallel_Guard
  00095	85 c0		 test	 eax, eax
  00097	75 06		 jne	 SHORT $LN24@unicode_re@6
  00099	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0009d	74 04		 je	 SHORT $LN10@unicode_re@6
$LN24@unicode_re@6:
  0009f	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN10@unicode_re@6:

; 1641 :         if (!unicode_empty)

  000a3	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR unicode_empty, 0
  000ab	74 24		 je	 SHORT $LN28@unicode_re@6

; 1643 :         Py_DECREF(*p_unicode);

  000ad	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  000b0	e8 00 00 00 00	 call	 _Py_DecRef

; 1644 :         *p_unicode = unicode_empty;

  000b5	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR unicode_empty
  000bc	4c 89 1f	 mov	 QWORD PTR [rdi], r11
$LN33@unicode_re@6:

; 1645 :         return 0;

  000bf	33 c0		 xor	 eax, eax

; 1663 :     }
; 1664 :     return resize_inplace(unicode, length);
; 1665 : }

  000c1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c6	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000cb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cf	5f		 pop	 rdi
  000d0	c3		 ret	 0
$LN28@unicode_re@6:

; 1642 :             return -1;

  000d1	83 c8 ff	 or	 eax, -1

; 1663 :     }
; 1664 :     return resize_inplace(unicode, length);
; 1665 : }

  000d4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d9	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000de	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e2	5f		 pop	 rdi
  000e3	c3		 ret	 0
$LN12@unicode_re@6:

; 1646 :     }
; 1647 : 
; 1648 :     if (!unicode_modifiable(unicode)) {

  000e4	48 8b cb	 mov	 rcx, rbx
  000e7	e8 00 00 00 00	 call	 unicode_modifiable

; 1649 :         PyObject *copy = resize_copy(unicode, length);

  000ec	48 8b d6	 mov	 rdx, rsi
  000ef	48 8b cb	 mov	 rcx, rbx
  000f2	85 c0		 test	 eax, eax
  000f4	75 2a		 jne	 SHORT $LN4@unicode_re@6
  000f6	e8 00 00 00 00	 call	 resize_copy
  000fb	48 8b d8	 mov	 rbx, rax

; 1650 :         if (copy == NULL)

  000fe	48 85 c0	 test	 rax, rax

; 1651 :             return -1;

  00101	74 ce		 je	 SHORT $LN28@unicode_re@6

; 1652 :         Py_DECREF(*p_unicode);

  00103	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00106	e8 00 00 00 00	 call	 _Py_DecRef

; 1653 :         *p_unicode = copy;

  0010b	48 89 1f	 mov	 QWORD PTR [rdi], rbx

; 1654 :         return 0;

  0010e	33 c0		 xor	 eax, eax

; 1663 :     }
; 1664 :     return resize_inplace(unicode, length);
; 1665 : }

  00110	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00115	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0011a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011e	5f		 pop	 rdi
  0011f	c3		 ret	 0
$LN4@unicode_re@6:

; 1655 :     }
; 1656 : 
; 1657 :     if (PyUnicode_IS_COMPACT(unicode)) {

  00120	f6 43 70 20	 test	 BYTE PTR [rbx+112], 32	; 00000020H
  00124	74 1f		 je	 SHORT $LN2@unicode_re@6

; 1658 :         PyObject *new_unicode = resize_compact(unicode, length);

  00126	e8 00 00 00 00	 call	 resize_compact

; 1659 :         if (new_unicode == NULL)

  0012b	48 85 c0	 test	 rax, rax

; 1660 :             return -1;

  0012e	74 a1		 je	 SHORT $LN28@unicode_re@6

; 1661 :         *p_unicode = new_unicode;

  00130	48 89 07	 mov	 QWORD PTR [rdi], rax

; 1662 :         return 0;

  00133	33 c0		 xor	 eax, eax

; 1663 :     }
; 1664 :     return resize_inplace(unicode, length);
; 1665 : }

  00135	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0013a	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0013f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00143	5f		 pop	 rdi
  00144	c3		 ret	 0
$LN2@unicode_re@6:
  00145	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0014a	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0014f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00153	5f		 pop	 rdi
  00154	e9 00 00 00 00	 jmp	 resize_inplace
unicode_resize ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_Resize
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_Resize DD imagerel $LN7
	DD	imagerel $LN7+97
	DD	imagerel $unwind$PyUnicode_Resize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Resize DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_Resize
_TEXT	SEGMENT
p_unicode$ = 48
length$ = 56
PyUnicode_Resize PROC					; COMDAT

; 1669 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1670 :     PyObject *unicode;
; 1671 :     if (p_unicode == NULL) {

  00004	48 85 c9	 test	 rcx, rcx
  00007	75 19		 jne	 SHORT $LN3@PyUnicode_@52

; 1677 :     {
; 1678 :         PyErr_BadInternalCall();

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00010	ba 88 06 00 00	 mov	 edx, 1672		; 00000688H
  00015	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1679 :         return -1;

  0001a	83 c8 ff	 or	 eax, -1

; 1680 :     }
; 1681 :     return unicode_resize(p_unicode, length);
; 1682 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
$LN3@PyUnicode_@52:

; 1672 :         PyErr_BadInternalCall();
; 1673 :         return -1;
; 1674 :     }
; 1675 :     unicode = *p_unicode;

  00022	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1676 :     if (unicode == NULL || !PyUnicode_Check(unicode) || length < 0)

  00025	48 85 c0	 test	 rax, rax
  00028	74 1e		 je	 SHORT $LN1@PyUnicode_@52
  0002a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002e	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00038	74 0e		 je	 SHORT $LN1@PyUnicode_@52
  0003a	48 85 d2	 test	 rdx, rdx
  0003d	78 09		 js	 SHORT $LN1@PyUnicode_@52

; 1680 :     }
; 1681 :     return unicode_resize(p_unicode, length);
; 1682 : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	e9 00 00 00 00	 jmp	 unicode_resize
$LN1@PyUnicode_@52:

; 1677 :     {
; 1678 :         PyErr_BadInternalCall();

  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  0004f	ba 8e 06 00 00	 mov	 edx, 1678		; 0000068eH
  00054	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1679 :         return -1;

  00059	83 c8 ff	 or	 eax, -1

; 1680 :     }
; 1681 :     return unicode_resize(p_unicode, length);
; 1682 : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
PyUnicode_Resize ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_FromUnicode
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_FromUnicode DD imagerel $LN56
	DD	imagerel $LN56+130
	DD	imagerel $unwind$PyUnicode_FromUnicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyUnicode_FromUnicode DD imagerel $LN56+130
	DD	imagerel $LN56+215
	DD	imagerel $chain$1$PyUnicode_FromUnicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyUnicode_FromUnicode DD imagerel $LN56+215
	DD	imagerel $LN56+500
	DD	imagerel $chain$3$PyUnicode_FromUnicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyUnicode_FromUnicode DD imagerel $LN56+500
	DD	imagerel $LN56+507
	DD	imagerel $chain$4$PyUnicode_FromUnicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyUnicode_FromUnicode DD 021H
	DD	imagerel $LN56
	DD	imagerel $LN56+130
	DD	imagerel $unwind$PyUnicode_FromUnicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyUnicode_FromUnicode DD 040021H
	DD	047400H
	DD	095400H
	DD	imagerel $LN56
	DD	imagerel $LN56+130
	DD	imagerel $unwind$PyUnicode_FromUnicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyUnicode_FromUnicode DD 040a21H
	DD	04740aH
	DD	095405H
	DD	imagerel $LN56
	DD	imagerel $LN56+130
	DD	imagerel $unwind$PyUnicode_FromUnicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_FromUnicode DD 030701H
	DD	060034207H
	DD	03002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_FromUnicode
_TEXT	SEGMENT
maxchar$ = 64
u$ = 64
size$ = 72
num_surrogates$ = 80
PyUnicode_FromUnicode PROC				; COMDAT

; 1800 : {

$LN56:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00007	48 8b f2	 mov	 rsi, rdx
  0000a	48 8b d9	 mov	 rbx, rcx

; 1801 :     PyObject *unicode;
; 1802 :     Py_UCS4 maxchar = 0;

  0000d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR maxchar$[rsp], 0

; 1803 :     Py_ssize_t num_surrogates;
; 1804 : 
; 1805 :     if (u == NULL)

  00015	48 85 c9	 test	 rcx, rcx
  00018	75 0e		 jne	 SHORT $LN35@PyUnicode_@53

; 1806 :         return (PyObject*)_PyUnicode_New(size);

  0001a	48 8b ca	 mov	 rcx, rdx

; 1858 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	5e		 pop	 rsi
  00022	5b		 pop	 rbx
  00023	e9 00 00 00 00	 jmp	 _PyUnicode_New
$LN35@PyUnicode_@53:

; 1807 : 
; 1808 :     /* If the Unicode data is known at construction time, we can apply
; 1809 :        some optimizations which share commonly used objects. */
; 1810 : 
; 1811 :     /* Optimization for empty strings */
; 1812 :     if (size == 0)

  00028	48 85 d2	 test	 rdx, rdx
  0002b	75 37		 jne	 SHORT $LN31@PyUnicode_@53

; 1813 :         _Py_RETURN_UNICODE_EMPTY();

  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  00034	48 85 c9	 test	 rcx, rcx
  00037	75 18		 jne	 SHORT $LN54@PyUnicode_@53
  00039	e8 00 00 00 00	 call	 PyUnicode_New
  0003e	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  00045	48 85 c0	 test	 rax, rax
  00048	0f 84 a6 01 00
	00		 je	 $LN36@PyUnicode_@53
  0004e	48 8b c8	 mov	 rcx, rax
$LN54@PyUnicode_@53:
  00051	e8 00 00 00 00	 call	 _Py_IncRef
  00056	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 1858 : }

  0005d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00061	5e		 pop	 rsi
  00062	5b		 pop	 rbx
  00063	c3		 ret	 0
$LN31@PyUnicode_@53:

; 1814 : 
; 1815 :     /* Single character Unicode objects in the Latin-1 range are
; 1816 :        shared when using this constructor */
; 1817 :     if (size == 1 && (Py_UCS4)*u < 256)

  00064	48 83 fa 01	 cmp	 rdx, 1
  00068	75 18		 jne	 SHORT $LN24@PyUnicode_@53
  0006a	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0006f	66 39 01	 cmp	 WORD PTR [rcx], ax
  00072	73 0e		 jae	 SHORT $LN24@PyUnicode_@53

; 1818 :         return get_latin1_char((unsigned char)*u);

  00074	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]

; 1858 : }

  00077	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007b	5e		 pop	 rsi
  0007c	5b		 pop	 rbx
  0007d	e9 00 00 00 00	 jmp	 get_latin1_char
$LN24@PyUnicode_@53:
  00082	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  00087	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi

; 1819 : 
; 1820 :     /* If not empty and not single character, copy the Unicode data
; 1821 :        into the new object */
; 1822 :     if (find_maxchar_surrogates(u, u + size,
; 1823 :                                 &maxchar, &num_surrogates) == -1)

  0008c	48 8d 3c 12	 lea	 rdi, QWORD PTR [rdx+rdx]
  00090	48 8d 2c 0f	 lea	 rbp, QWORD PTR [rdi+rcx]
  00094	4c 8d 4c 24 50	 lea	 r9, QWORD PTR num_surrogates$[rsp]
  00099	4c 8d 44 24 40	 lea	 r8, QWORD PTR maxchar$[rsp]
  0009e	48 8b d5	 mov	 rdx, rbp
  000a1	e8 00 00 00 00	 call	 find_maxchar_surrogates
  000a6	83 f8 ff	 cmp	 eax, -1

; 1824 :         return NULL;

  000a9	74 19		 je	 SHORT $LN55@PyUnicode_@53

; 1825 : 
; 1826 :     unicode = PyUnicode_New(size - num_surrogates, maxchar);

  000ab	48 2b 74 24 50	 sub	 rsi, QWORD PTR num_surrogates$[rsp]
  000b0	8b 54 24 40	 mov	 edx, DWORD PTR maxchar$[rsp]
  000b4	48 8b ce	 mov	 rcx, rsi
  000b7	e8 00 00 00 00	 call	 PyUnicode_New
  000bc	48 8b f0	 mov	 rsi, rax

; 1827 :     if (!unicode)

  000bf	48 85 c0	 test	 rax, rax
  000c2	75 13		 jne	 SHORT $LN22@PyUnicode_@53
$LN55@PyUnicode_@53:
  000c4	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000c9	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 1828 :         return NULL;

  000ce	33 c0		 xor	 eax, eax

; 1858 : }

  000d0	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d4	5e		 pop	 rsi
  000d5	5b		 pop	 rbx
  000d6	c3		 ret	 0
$LN22@PyUnicode_@53:

; 1829 : 
; 1830 :     switch (PyUnicode_KIND(unicode)) {

  000d7	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  000da	8b c1		 mov	 eax, ecx
  000dc	c1 e8 02	 shr	 eax, 2
  000df	83 e0 07	 and	 eax, 7
  000e2	ff c8		 dec	 eax
  000e4	74 7e		 je	 SHORT $LN18@PyUnicode_@53
  000e6	ff c8		 dec	 eax
  000e8	74 1c		 je	 SHORT $LN10@PyUnicode_@53
  000ea	83 f8 02	 cmp	 eax, 2
  000ed	0f 85 ef 00 00
	00		 jne	 $LN17@PyUnicode_@53

; 1843 :     case PyUnicode_4BYTE_KIND:
; 1844 : #if SIZEOF_WCHAR_T == 2
; 1845 :         /* This is the only case which has to process surrogates, thus
; 1846 :            a simple copy loop is not enough and we need a function. */
; 1847 :         unicode_convert_wchar_to_ucs4(u, u + size, unicode);

  000f3	4c 8b c6	 mov	 r8, rsi
  000f6	48 8b d5	 mov	 rdx, rbp
  000f9	48 8b cb	 mov	 rcx, rbx
  000fc	e8 00 00 00 00	 call	 unicode_convert_wchar_to_ucs4

; 1848 : #else
; 1849 :         assert(num_surrogates == 0);
; 1850 :         Py_MEMCPY(PyUnicode_4BYTE_DATA(unicode), u, size * 4);
; 1851 : #endif
; 1852 :         break;

  00101	e9 dc 00 00 00	 jmp	 $LN17@PyUnicode_@53
$LN10@PyUnicode_@53:

; 1834 :         break;
; 1835 :     case PyUnicode_2BYTE_KIND:
; 1836 : #if Py_UNICODE_SIZE == 2
; 1837 :         Py_MEMCPY(PyUnicode_2BYTE_DATA(unicode), u, size * 2);

  00106	f6 c1 20	 test	 cl, 32			; 00000020H
  00109	74 17		 je	 SHORT $LN44@PyUnicode_@53
  0010b	f6 c1 40	 test	 cl, 64			; 00000040H
  0010e	74 09		 je	 SHORT $LN42@PyUnicode_@53
  00110	48 8d 8e 80 00
	00 00		 lea	 rcx, QWORD PTR [rsi+128]
  00117	eb 10		 jmp	 SHORT $LN45@PyUnicode_@53
$LN42@PyUnicode_@53:
  00119	48 8d 8e a0 00
	00 00		 lea	 rcx, QWORD PTR [rsi+160]
  00120	eb 07		 jmp	 SHORT $LN45@PyUnicode_@53
$LN44@PyUnicode_@53:
  00122	48 8b 8e a0 00
	00 00		 mov	 rcx, QWORD PTR [rsi+160]
$LN45@PyUnicode_@53:
  00129	48 83 ff 10	 cmp	 rdi, 16
  0012d	72 10		 jb	 SHORT $LN7@PyUnicode_@53
  0012f	4c 8b c7	 mov	 r8, rdi
  00132	48 8b d3	 mov	 rdx, rbx
  00135	e8 00 00 00 00	 call	 memcpy
  0013a	e9 a3 00 00 00	 jmp	 $LN17@PyUnicode_@53
$LN7@PyUnicode_@53:
  0013f	48 85 ff	 test	 rdi, rdi
  00142	0f 84 9a 00 00
	00		 je	 $LN17@PyUnicode_@53
  00148	48 2b d9	 sub	 rbx, rcx
  0014b	0f 1f 44 00 00	 npad	 5
$LL5@PyUnicode_@53:
  00150	0f b6 04 0b	 movzx	 eax, BYTE PTR [rbx+rcx]
  00154	48 ff c1	 inc	 rcx
  00157	48 ff cf	 dec	 rdi
  0015a	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0015d	75 f1		 jne	 SHORT $LL5@PyUnicode_@53

; 1838 : #else
; 1839 :         _PyUnicode_CONVERT_BYTES(Py_UNICODE, Py_UCS2,
; 1840 :                                 u, u + size, PyUnicode_2BYTE_DATA(unicode));
; 1841 : #endif
; 1842 :         break;

  0015f	e9 7e 00 00 00	 jmp	 $LN17@PyUnicode_@53
$LN18@PyUnicode_@53:

; 1831 :     case PyUnicode_1BYTE_KIND:
; 1832 :         _PyUnicode_CONVERT_BYTES(Py_UNICODE, unsigned char,
; 1833 :                                 u, u + size, PyUnicode_1BYTE_DATA(unicode));

  00164	f6 c1 20	 test	 cl, 32			; 00000020H
  00167	74 17		 je	 SHORT $LN40@PyUnicode_@53
  00169	f6 c1 40	 test	 cl, 64			; 00000040H
  0016c	74 09		 je	 SHORT $LN38@PyUnicode_@53
  0016e	48 8d 8e 80 00
	00 00		 lea	 rcx, QWORD PTR [rsi+128]
  00175	eb 10		 jmp	 SHORT $LN41@PyUnicode_@53
$LN38@PyUnicode_@53:
  00177	48 8d 8e a0 00
	00 00		 lea	 rcx, QWORD PTR [rsi+160]
  0017e	eb 07		 jmp	 SHORT $LN41@PyUnicode_@53
$LN40@PyUnicode_@53:
  00180	48 8b 8e a0 00
	00 00		 mov	 rcx, QWORD PTR [rsi+160]
$LN41@PyUnicode_@53:
  00187	48 8b c5	 mov	 rax, rbp
  0018a	48 2b c3	 sub	 rax, rbx
  0018d	48 d1 f8	 sar	 rax, 1
  00190	48 83 e0 fc	 and	 rax, -4
  00194	48 8d 14 43	 lea	 rdx, QWORD PTR [rbx+rax*2]
  00198	48 3b da	 cmp	 rbx, rdx
  0019b	73 2b		 jae	 SHORT $LN48@PyUnicode_@53
  0019d	0f 1f 00	 npad	 3
$LL15@PyUnicode_@53:
  001a0	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  001a3	48 83 c3 08	 add	 rbx, 8
  001a7	48 83 c1 04	 add	 rcx, 4
  001ab	88 41 fc	 mov	 BYTE PTR [rcx-4], al
  001ae	0f b6 43 fa	 movzx	 eax, BYTE PTR [rbx-6]
  001b2	88 41 fd	 mov	 BYTE PTR [rcx-3], al
  001b5	0f b6 43 fc	 movzx	 eax, BYTE PTR [rbx-4]
  001b9	88 41 fe	 mov	 BYTE PTR [rcx-2], al
  001bc	0f b6 43 fe	 movzx	 eax, BYTE PTR [rbx-2]
  001c0	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  001c3	48 3b da	 cmp	 rbx, rdx
  001c6	72 d8		 jb	 SHORT $LL15@PyUnicode_@53
$LN48@PyUnicode_@53:
  001c8	48 3b dd	 cmp	 rbx, rbp
  001cb	73 15		 jae	 SHORT $LN17@PyUnicode_@53
  001cd	0f 1f 00	 npad	 3
$LL13@PyUnicode_@53:
  001d0	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  001d3	48 83 c3 02	 add	 rbx, 2
  001d7	48 ff c1	 inc	 rcx
  001da	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  001dd	48 3b dd	 cmp	 rbx, rbp
  001e0	72 ee		 jb	 SHORT $LL13@PyUnicode_@53
$LN17@PyUnicode_@53:

; 1853 :     default:
; 1854 :         assert(0 && "Impossible state");
; 1855 :     }
; 1856 : 
; 1857 :     return unicode_result(unicode);

  001e2	48 8b ce	 mov	 rcx, rsi
  001e5	e8 00 00 00 00	 call	 unicode_result
  001ea	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001ef	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
$LN36@PyUnicode_@53:

; 1858 : }

  001f4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001f8	5e		 pop	 rsi
  001f9	5b		 pop	 rbx
  001fa	c3		 ret	 0
PyUnicode_FromUnicode ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_FromWideChar
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_FromWideChar DD imagerel $LN16
	DD	imagerel $LN16+96
	DD	imagerel $unwind$PyUnicode_FromWideChar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyUnicode_FromWideChar DD imagerel $LN16+96
	DD	imagerel $LN16+124
	DD	imagerel $chain$0$PyUnicode_FromWideChar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyUnicode_FromWideChar DD imagerel $LN16+124
	DD	imagerel $LN16+137
	DD	imagerel $chain$1$PyUnicode_FromWideChar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyUnicode_FromWideChar DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+96
	DD	imagerel $unwind$PyUnicode_FromWideChar
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyUnicode_FromWideChar DD 020521H
	DD	047405H
	DD	imagerel $LN16
	DD	imagerel $LN16+96
	DD	imagerel $unwind$PyUnicode_FromWideChar
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_FromWideChar DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_FromWideChar
_TEXT	SEGMENT
w$ = 48
size$ = 56
PyUnicode_FromWideChar PROC				; COMDAT

; 2355 : {

$LN16:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b c1	 mov	 r8, rcx

; 2356 :     if (w == NULL) {

  00007	48 85 c9	 test	 rcx, rcx
  0000a	75 4e		 jne	 SHORT $LN12@PyUnicode_@54

; 2357 :         if (size == 0)

  0000c	48 85 d2	 test	 rdx, rdx
  0000f	75 31		 jne	 SHORT $LN8@PyUnicode_@54

; 2358 :             _Py_RETURN_UNICODE_EMPTY();

  00011	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  00018	48 85 c9	 test	 rcx, rcx
  0001b	75 14		 jne	 SHORT $LN15@PyUnicode_@54
  0001d	e8 00 00 00 00	 call	 PyUnicode_New
  00022	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  00029	48 85 c0	 test	 rax, rax
  0002c	74 56		 je	 SHORT $LN13@PyUnicode_@54
  0002e	48 8b c8	 mov	 rcx, rax
$LN15@PyUnicode_@54:
  00031	e8 00 00 00 00	 call	 _Py_IncRef
  00036	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 2368 : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
$LN8@PyUnicode_@54:

; 2359 :         PyErr_BadInternalCall();

  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00049	ba 37 09 00 00	 mov	 edx, 2359		; 00000937H
  0004e	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2360 :         return NULL;

  00053	33 c0		 xor	 eax, eax

; 2368 : }

  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	c3		 ret	 0
$LN12@PyUnicode_@54:

; 2361 :     }
; 2362 : 
; 2363 :     if (size == -1) {

  0005a	48 83 fa ff	 cmp	 rdx, -1
  0005e	75 1c		 jne	 SHORT $LN1@PyUnicode_@54

; 2364 :         size = wcslen(w);

  00060	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00065	48 0b ca	 or	 rcx, rdx
  00068	33 c0		 xor	 eax, eax
  0006a	49 8b f8	 mov	 rdi, r8
  0006d	66 f2 af	 repne scasw
  00070	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  00075	48 f7 d1	 not	 rcx
  00078	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
$LN1@PyUnicode_@54:

; 2365 :     }
; 2366 : 
; 2367 :     return PyUnicode_FromUnicode(w, size);

  0007c	49 8b c8	 mov	 rcx, r8
  0007f	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
$LN13@PyUnicode_@54:

; 2368 : }

  00084	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00088	c3		 ret	 0
PyUnicode_FromWideChar ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_aswidechar DD imagerel unicode_aswidechar
	DD	imagerel unicode_aswidechar+54
	DD	imagerel $unwind$unicode_aswidechar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_aswidechar DD imagerel unicode_aswidechar+54
	DD	imagerel unicode_aswidechar+121
	DD	imagerel $chain$0$unicode_aswidechar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$unicode_aswidechar DD imagerel unicode_aswidechar+121
	DD	imagerel unicode_aswidechar+179
	DD	imagerel $chain$2$unicode_aswidechar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$unicode_aswidechar DD imagerel unicode_aswidechar+179
	DD	imagerel unicode_aswidechar+198
	DD	imagerel $chain$3$unicode_aswidechar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$unicode_aswidechar DD 021H
	DD	imagerel unicode_aswidechar
	DD	imagerel unicode_aswidechar+54
	DD	imagerel $unwind$unicode_aswidechar
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$unicode_aswidechar DD 020021H
	DD	067400H
	DD	imagerel unicode_aswidechar
	DD	imagerel unicode_aswidechar+54
	DD	imagerel $unwind$unicode_aswidechar
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_aswidechar DD 020521H
	DD	067405H
	DD	imagerel unicode_aswidechar
	DD	imagerel unicode_aswidechar+54
	DD	imagerel $unwind$unicode_aswidechar
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_aswidechar DD 040a01H
	DD	07340aH
	DD	06006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_aswidechar
_TEXT	SEGMENT
unicode$ = 48
w$ = 56
size$ = 64
res$ = 72
unicode_aswidechar PROC					; COMDAT

; 2991 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 2992 :     Py_ssize_t res;
; 2993 :     const wchar_t *wstr;
; 2994 : 
; 2995 :     wstr = PyUnicode_AsUnicodeAndSize(unicode, &res);

  0000d	48 8d 54 24 48	 lea	 rdx, QWORD PTR res$[rsp]
  00012	49 8b f0	 mov	 rsi, r8
  00015	e8 00 00 00 00	 call	 PyUnicode_AsUnicodeAndSize
  0001a	4c 8b d8	 mov	 r11, rax

; 2996 :     if (wstr == NULL)

  0001d	48 85 c0	 test	 rax, rax
  00020	75 0f		 jne	 SHORT $LN13@unicode_as

; 2997 :         return -1;

  00022	48 83 c8 ff	 or	 rax, -1

; 3009 : }

  00026	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5e		 pop	 rsi
  00030	c3		 ret	 0
$LN13@unicode_as:

; 2998 : 
; 2999 :     if (w != NULL) {

  00031	48 85 db	 test	 rbx, rbx
  00034	74 7d		 je	 SHORT $LN12@unicode_as

; 3000 :         if (size > res)

  00036	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0003b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR res$[rsp]
  00040	48 3b f7	 cmp	 rsi, rdi
  00043	7e 06		 jle	 SHORT $LN11@unicode_as

; 3001 :             size = res + 1;

  00045	48 8d 77 01	 lea	 rsi, QWORD PTR [rdi+1]

; 3002 :         else

  00049	eb 03		 jmp	 SHORT $LN9@unicode_as
$LN11@unicode_as:

; 3003 :             res = size;

  0004b	48 8b fe	 mov	 rdi, rsi
$LN9@unicode_as:

; 3004 :         Py_MEMCPY(w, wstr, size * sizeof(wchar_t));

  0004e	48 8d 04 36	 lea	 rax, QWORD PTR [rsi+rsi]
  00052	48 83 f8 10	 cmp	 rax, 16
  00056	72 21		 jb	 SHORT $LN6@unicode_as
  00058	4c 8b c0	 mov	 r8, rax
  0005b	49 8b d3	 mov	 rdx, r11
  0005e	48 8b cb	 mov	 rcx, rbx
  00061	e8 00 00 00 00	 call	 memcpy

; 3005 :         return res;

  00066	48 8b c7	 mov	 rax, rdi
  00069	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 3009 : }

  0006e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5e		 pop	 rsi
  00078	c3		 ret	 0
$LN6@unicode_as:

; 3004 :         Py_MEMCPY(w, wstr, size * sizeof(wchar_t));

  00079	48 85 c0	 test	 rax, rax
  0007c	74 22		 je	 SHORT $LN8@unicode_as
  0007e	4c 2b db	 sub	 r11, rbx
  00081	66 66 66 66 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL4@unicode_as:
  00090	41 0f b6 0c 1b	 movzx	 ecx, BYTE PTR [r11+rbx]
  00095	48 ff c3	 inc	 rbx
  00098	48 ff c8	 dec	 rax
  0009b	88 4b ff	 mov	 BYTE PTR [rbx-1], cl
  0009e	75 f0		 jne	 SHORT $LL4@unicode_as
$LN8@unicode_as:

; 3005 :         return res;

  000a0	48 8b c7	 mov	 rax, rdi
  000a3	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 3009 : }

  000a8	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000ad	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b1	5e		 pop	 rsi
  000b2	c3		 ret	 0
$LN12@unicode_as:

; 3006 :     }
; 3007 :     else
; 3008 :         return res + 1;

  000b3	48 8b 44 24 48	 mov	 rax, QWORD PTR res$[rsp]

; 3009 : }

  000b8	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000bd	48 ff c0	 inc	 rax
  000c0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c4	5e		 pop	 rsi
  000c5	c3		 ret	 0
unicode_aswidechar ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsWideChar
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_AsWideChar DD imagerel $LN4
	DD	imagerel $LN4+44
	DD	imagerel $unwind$PyUnicode_AsWideChar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_AsWideChar DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_AsWideChar
_TEXT	SEGMENT
unicode$ = 48
w$ = 56
size$ = 64
PyUnicode_AsWideChar PROC				; COMDAT

; 3015 : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3016 :     if (unicode == NULL) {

  00004	48 85 c9	 test	 rcx, rcx
  00007	75 1a		 jne	 SHORT $LN1@PyUnicode_@55

; 3017 :         PyErr_BadInternalCall();

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00010	ba c9 0b 00 00	 mov	 edx, 3017		; 00000bc9H
  00015	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 3018 :         return -1;

  0001a	48 83 c8 ff	 or	 rax, -1

; 3019 :     }
; 3020 :     return unicode_aswidechar(unicode, w, size);
; 3021 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
$LN1@PyUnicode_@55:
  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	e9 00 00 00 00	 jmp	 unicode_aswidechar
PyUnicode_AsWideChar ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsWideCharString
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_AsWideCharString DD imagerel $LN22
	DD	imagerel $LN22+56
	DD	imagerel $unwind$PyUnicode_AsWideCharString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyUnicode_AsWideCharString DD imagerel $LN22+56
	DD	imagerel $LN22+113
	DD	imagerel $chain$0$PyUnicode_AsWideCharString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyUnicode_AsWideCharString DD imagerel $LN22+113
	DD	imagerel $LN22+271
	DD	imagerel $chain$3$PyUnicode_AsWideCharString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyUnicode_AsWideCharString DD 040521H
	DD	063405H
	DD	077400H
	DD	imagerel $LN22
	DD	imagerel $LN22+56
	DD	imagerel $unwind$PyUnicode_AsWideCharString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyUnicode_AsWideCharString DD 020521H
	DD	077405H
	DD	imagerel $LN22
	DD	imagerel $LN22+56
	DD	imagerel $unwind$PyUnicode_AsWideCharString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_AsWideCharString DD 040a01H
	DD	08540aH
	DD	06006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_AsWideCharString
_TEXT	SEGMENT
unicode$ = 48
size$ = 56
PyUnicode_AsWideCharString PROC				; COMDAT

; 3026 : {

$LN22:
  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f2	 mov	 rsi, rdx
  0000d	48 8b e9	 mov	 rbp, rcx

; 3027 :     wchar_t* buffer;
; 3028 :     Py_ssize_t buflen;
; 3029 : 
; 3030 :     if (unicode == NULL) {

  00010	48 85 c9	 test	 rcx, rcx
  00013	75 1e		 jne	 SHORT $LN6@PyUnicode_@56

; 3031 :         PyErr_BadInternalCall();

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  0001c	ba d7 0b 00 00	 mov	 edx, 3031		; 00000bd7H
  00021	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 3032 :         return NULL;

  00026	33 c0		 xor	 eax, eax

; 3056 : }

  00028	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5e		 pop	 rsi
  00032	c3		 ret	 0
$LN6@PyUnicode_@56:

; 3033 :     }
; 3034 : 
; 3035 :     buflen = unicode_aswidechar(unicode, NULL, 0);

  00033	45 33 c0	 xor	 r8d, r8d
  00036	33 d2		 xor	 edx, edx
  00038	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0003d	e8 00 00 00 00	 call	 unicode_aswidechar
  00042	48 8b f8	 mov	 rdi, rax

; 3036 :     if (buflen == -1)

  00045	48 83 f8 ff	 cmp	 rax, -1

; 3037 :         return NULL;

  00049	74 14		 je	 SHORT $LN21@PyUnicode_@56

; 3038 :     if (PY_SSIZE_T_MAX / sizeof(wchar_t) < buflen) {

  0004b	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  00055	48 3b f8	 cmp	 rdi, rax
  00058	76 17		 jbe	 SHORT $LN4@PyUnicode_@56

; 3039 :         PyErr_NoMemory();

  0005a	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN21@PyUnicode_@56:

; 3040 :         return NULL;

  0005f	33 c0		 xor	 eax, eax
  00061	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 3056 : }

  00066	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0006b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006f	5e		 pop	 rsi
  00070	c3		 ret	 0
$LN4@PyUnicode_@56:
  00071	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 3041 :     }
; 3042 : 
; 3043 :     buffer = PyMem_MALLOC(buflen * sizeof(wchar_t));

  00076	e8 00 00 00 00	 call	 _Py_PXCTX
  0007b	85 c0		 test	 eax, eax
  0007d	74 0b		 je	 SHORT $LN13@PyUnicode_@56
  0007f	48 8d 0c 3f	 lea	 rcx, QWORD PTR [rdi+rdi]
  00083	e8 00 00 00 00	 call	 _PxMem_Malloc
  00088	eb 25		 jmp	 SHORT $LN20@PyUnicode_@56
$LN13@PyUnicode_@56:
  0008a	48 8d 04 3f	 lea	 rax, QWORD PTR [rdi+rdi]
  0008e	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00098	48 3b c1	 cmp	 rax, rcx
  0009b	77 56		 ja	 SHORT $LN17@PyUnicode_@56
  0009d	48 85 c0	 test	 rax, rax
  000a0	b9 01 00 00 00	 mov	 ecx, 1
  000a5	48 0f 45 c8	 cmovne	 rcx, rax
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN20@PyUnicode_@56:
  000af	48 8b d8	 mov	 rbx, rax

; 3044 :     if (buffer == NULL) {

  000b2	48 85 c0	 test	 rax, rax
  000b5	74 3c		 je	 SHORT $LN17@PyUnicode_@56

; 3047 :     }
; 3048 :     buflen = unicode_aswidechar(unicode, buffer, buflen);

  000b7	4c 8b c7	 mov	 r8, rdi
  000ba	48 8b d0	 mov	 rdx, rax
  000bd	48 8b cd	 mov	 rcx, rbp
  000c0	e8 00 00 00 00	 call	 unicode_aswidechar

; 3049 :     if (buflen == -1) {

  000c5	48 83 f8 ff	 cmp	 rax, -1
  000c9	75 1b		 jne	 SHORT $LN2@PyUnicode_@56

; 3050 :         PyMem_FREE(buffer);

  000cb	e8 00 00 00 00	 call	 _Py_PXCTX
  000d0	48 8b cb	 mov	 rcx, rbx
  000d3	85 c0		 test	 eax, eax
  000d5	74 07		 je	 SHORT $LN15@PyUnicode_@56
  000d7	e8 00 00 00 00	 call	 _PxMem_Free
  000dc	eb 1a		 jmp	 SHORT $LN16@PyUnicode_@56
$LN15@PyUnicode_@56:
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3051 :         return NULL;

  000e4	eb 12		 jmp	 SHORT $LN16@PyUnicode_@56
$LN2@PyUnicode_@56:

; 3052 :     }
; 3053 :     if (size != NULL)

  000e6	48 85 f6	 test	 rsi, rsi
  000e9	74 03		 je	 SHORT $LN1@PyUnicode_@56

; 3054 :         *size = buflen;

  000eb	48 89 06	 mov	 QWORD PTR [rsi], rax
$LN1@PyUnicode_@56:

; 3055 :     return buffer;

  000ee	48 8b c3	 mov	 rax, rbx
  000f1	eb 07		 jmp	 SHORT $LN19@PyUnicode_@56
$LN17@PyUnicode_@56:

; 3045 :         PyErr_NoMemory();

  000f3	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN16@PyUnicode_@56:

; 3046 :         return NULL;

  000f8	33 c0		 xor	 eax, eax
$LN19@PyUnicode_@56:
  000fa	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ff	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 3056 : }

  00104	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00109	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010d	5e		 pop	 rsi
  0010e	c3		 ret	 0
PyUnicode_AsWideCharString ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsDecodedObject
EXTRN	PyCodec_Decode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_AsDecodedObject DD imagerel $LN6
	DD	imagerel $LN6+72
	DD	imagerel $unwind$PyUnicode_AsDecodedObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_AsDecodedObject DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_AsDecodedObject
_TEXT	SEGMENT
unicode$ = 48
encoding$ = 56
errors$ = 64
PyUnicode_AsDecodedObject PROC				; COMDAT

; 3248 : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3249 :     PyObject *v;
; 3250 : 
; 3251 :     if (!PyUnicode_Check(unicode)) {

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00012	75 0c		 jne	 SHORT $LN3@PyUnicode_@57

; 3252 :         PyErr_BadArgument();

  00014	e8 00 00 00 00	 call	 PyErr_BadArgument

; 3264 : 
; 3265 :   onError:
; 3266 :     return NULL;

  00019	33 c0		 xor	 eax, eax

; 3267 : }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
$LN3@PyUnicode_@57:

; 3253 :         goto onError;
; 3254 :     }
; 3255 : 
; 3256 :     if (encoding == NULL)

  00020	48 85 d2	 test	 rdx, rdx
  00023	75 08		 jne	 SHORT $LN2@PyUnicode_@57

; 3257 :         encoding = PyUnicode_GetDefaultEncoding();

  00025	e8 00 00 00 00	 call	 PyUnicode_GetDefaultEncoding
  0002a	48 8b d0	 mov	 rdx, rax
$LN2@PyUnicode_@57:

; 3258 : 
; 3259 :     /* Decode via the codec registry */
; 3260 :     v = PyCodec_Decode(unicode, encoding, errors);

  0002d	e8 00 00 00 00	 call	 PyCodec_Decode

; 3261 :     if (v == NULL)

  00032	48 85 c0	 test	 rax, rax
  00035	75 05		 jne	 SHORT $LN1@PyUnicode_@57
$onError$128298:

; 3267 : }

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
$LN1@PyUnicode_@57:

; 3262 :         goto onError;
; 3263 :     return unicode_result(v);

  0003c	48 8b c8	 mov	 rcx, rax

; 3267 : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	e9 00 00 00 00	 jmp	 unicode_result
PyUnicode_AsDecodedObject ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@PNAMKIJE@decoder?5did?5not?5return?5a?5str?5obj@ ; `string'
PUBLIC	PyUnicode_AsDecodedUnicode
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_AsDecodedUnicode DD imagerel $LN7
	DD	imagerel $LN7+130
	DD	imagerel $unwind$PyUnicode_AsDecodedUnicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_AsDecodedUnicode DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0DC@PNAMKIJE@decoder?5did?5not?5return?5a?5str?5obj@
CONST	SEGMENT
??_C@_0DC@PNAMKIJE@decoder?5did?5not?5return?5a?5str?5obj@ DB 'decoder di'
	DB	'd not return a str object (type=%.400s)', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_AsDecodedUnicode
_TEXT	SEGMENT
unicode$ = 48
encoding$ = 56
errors$ = 64
PyUnicode_AsDecodedUnicode PROC				; COMDAT

; 3273 : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3274 :     PyObject *v;
; 3275 : 
; 3276 :     if (!PyUnicode_Check(unicode)) {

  00006	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000a	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00014	75 0d		 jne	 SHORT $LN4@PyUnicode_@58

; 3277 :         PyErr_BadArgument();

  00016	e8 00 00 00 00	 call	 PyErr_BadArgument
$onError$128314:

; 3296 : 
; 3297 :   onError:
; 3298 :     return NULL;

  0001b	33 c0		 xor	 eax, eax

; 3299 : }

  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5b		 pop	 rbx
  00022	c3		 ret	 0
$LN4@PyUnicode_@58:

; 3278 :         goto onError;
; 3279 :     }
; 3280 : 
; 3281 :     if (encoding == NULL)

  00023	48 85 d2	 test	 rdx, rdx
  00026	75 08		 jne	 SHORT $LN3@PyUnicode_@58

; 3282 :         encoding = PyUnicode_GetDefaultEncoding();

  00028	e8 00 00 00 00	 call	 PyUnicode_GetDefaultEncoding
  0002d	48 8b d0	 mov	 rdx, rax
$LN3@PyUnicode_@58:

; 3283 : 
; 3284 :     /* Decode via the codec registry */
; 3285 :     v = PyCodec_Decode(unicode, encoding, errors);

  00030	e8 00 00 00 00	 call	 PyCodec_Decode
  00035	48 8b d8	 mov	 rbx, rax

; 3286 :     if (v == NULL)

  00038	48 85 c0	 test	 rax, rax
  0003b	74 de		 je	 SHORT $onError$128314

; 3287 :         goto onError;
; 3288 :     if (!PyUnicode_Check(v)) {

  0003d	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00041	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  0004c	75 27		 jne	 SHORT $LN1@PyUnicode_@58

; 3289 :         PyErr_Format(PyExc_TypeError,
; 3290 :                      "decoder did not return a str object (type=%.400s)",
; 3291 :                      Py_TYPE(v)->tp_name);

  0004e	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00052	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@PNAMKIJE@decoder?5did?5not?5return?5a?5str?5obj@
  00060	e8 00 00 00 00	 call	 PyErr_Format

; 3292 :         Py_DECREF(v);

  00065	48 8b cb	 mov	 rcx, rbx
  00068	e8 00 00 00 00	 call	 _Py_DecRef

; 3296 : 
; 3297 :   onError:
; 3298 :     return NULL;

  0006d	33 c0		 xor	 eax, eax

; 3299 : }

  0006f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00073	5b		 pop	 rbx
  00074	c3		 ret	 0
$LN1@PyUnicode_@58:

; 3293 :         goto onError;
; 3294 :     }
; 3295 :     return unicode_result(v);

  00075	48 8b c8	 mov	 rcx, rax

; 3299 : }

  00078	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007c	5b		 pop	 rbx
  0007d	e9 00 00 00 00	 jmp	 unicode_result
PyUnicode_AsDecodedUnicode ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsEncodedObject
EXTRN	PyCodec_Encode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_AsEncodedObject DD imagerel $LN6
	DD	imagerel $LN6+60
	DD	imagerel $unwind$PyUnicode_AsEncodedObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_AsEncodedObject DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_AsEncodedObject
_TEXT	SEGMENT
unicode$ = 48
encoding$ = 56
errors$ = 64
PyUnicode_AsEncodedObject PROC				; COMDAT

; 3321 : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3322 :     PyObject *v;
; 3323 : 
; 3324 :     if (!PyUnicode_Check(unicode)) {

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00012	75 0c		 jne	 SHORT $LN3@PyUnicode_@59

; 3325 :         PyErr_BadArgument();

  00014	e8 00 00 00 00	 call	 PyErr_BadArgument

; 3335 :         goto onError;
; 3336 :     return v;
; 3337 : 
; 3338 :   onError:
; 3339 :     return NULL;

  00019	33 c0		 xor	 eax, eax

; 3340 : }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
$LN3@PyUnicode_@59:

; 3326 :         goto onError;
; 3327 :     }
; 3328 : 
; 3329 :     if (encoding == NULL)

  00020	48 85 d2	 test	 rdx, rdx
  00023	75 08		 jne	 SHORT $LN2@PyUnicode_@59

; 3330 :         encoding = PyUnicode_GetDefaultEncoding();

  00025	e8 00 00 00 00	 call	 PyUnicode_GetDefaultEncoding
  0002a	48 8b d0	 mov	 rdx, rax
$LN2@PyUnicode_@59:

; 3331 : 
; 3332 :     /* Encode via the codec registry */
; 3333 :     v = PyCodec_Encode(unicode, encoding, errors);

  0002d	e8 00 00 00 00	 call	 PyCodec_Encode

; 3334 :     if (v == NULL)

  00032	48 85 c0	 test	 rax, rax
  00035	75 00		 jne	 SHORT $LN1@PyUnicode_@59
$onError$128349:
$LN1@PyUnicode_@59:

; 3340 : }

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
PyUnicode_AsEncodedObject ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@NBEOLJEO@encoder?5did?5not?5return?5an?5str?5ob@ ; `string'
PUBLIC	PyUnicode_AsEncodedUnicode
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_AsEncodedUnicode DD imagerel $LN7
	DD	imagerel $LN7+117
	DD	imagerel $unwind$PyUnicode_AsEncodedUnicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_AsEncodedUnicode DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0DD@NBEOLJEO@encoder?5did?5not?5return?5an?5str?5ob@
CONST	SEGMENT
??_C@_0DD@NBEOLJEO@encoder?5did?5not?5return?5an?5str?5ob@ DB 'encoder di'
	DB	'd not return an str object (type=%.400s)', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_AsEncodedUnicode
_TEXT	SEGMENT
unicode$ = 48
encoding$ = 56
errors$ = 64
PyUnicode_AsEncodedUnicode PROC				; COMDAT

; 3623 : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3624 :     PyObject *v;
; 3625 : 
; 3626 :     if (!PyUnicode_Check(unicode)) {

  00006	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000a	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00014	75 0d		 jne	 SHORT $LN4@PyUnicode_@60

; 3627 :         PyErr_BadArgument();

  00016	e8 00 00 00 00	 call	 PyErr_BadArgument

; 3643 :         goto onError;
; 3644 :     }
; 3645 :     return v;
; 3646 : 
; 3647 :   onError:
; 3648 :     return NULL;

  0001b	33 c0		 xor	 eax, eax

; 3649 : }

  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5b		 pop	 rbx
  00022	c3		 ret	 0
$LN4@PyUnicode_@60:

; 3628 :         goto onError;
; 3629 :     }
; 3630 : 
; 3631 :     if (encoding == NULL)

  00023	48 85 d2	 test	 rdx, rdx
  00026	75 08		 jne	 SHORT $LN3@PyUnicode_@60

; 3632 :         encoding = PyUnicode_GetDefaultEncoding();

  00028	e8 00 00 00 00	 call	 PyUnicode_GetDefaultEncoding
  0002d	48 8b d0	 mov	 rdx, rax
$LN3@PyUnicode_@60:

; 3633 : 
; 3634 :     /* Encode via the codec registry */
; 3635 :     v = PyCodec_Encode(unicode, encoding, errors);

  00030	e8 00 00 00 00	 call	 PyCodec_Encode
  00035	48 8b d8	 mov	 rbx, rax

; 3636 :     if (v == NULL)

  00038	48 85 c0	 test	 rax, rax
  0003b	74 30		 je	 SHORT $onError$128533

; 3637 :         goto onError;
; 3638 :     if (!PyUnicode_Check(v)) {

  0003d	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00041	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  0004c	75 21		 jne	 SHORT $LN5@PyUnicode_@60

; 3639 :         PyErr_Format(PyExc_TypeError,
; 3640 :                      "encoder did not return an str object (type=%.400s)",
; 3641 :                      Py_TYPE(v)->tp_name);

  0004e	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00052	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@NBEOLJEO@encoder?5did?5not?5return?5an?5str?5ob@
  00060	e8 00 00 00 00	 call	 PyErr_Format

; 3642 :         Py_DECREF(v);

  00065	48 8b cb	 mov	 rcx, rbx
  00068	e8 00 00 00 00	 call	 _Py_DecRef
$onError$128533:

; 3643 :         goto onError;
; 3644 :     }
; 3645 :     return v;
; 3646 : 
; 3647 :   onError:
; 3648 :     return NULL;

  0006d	33 c0		 xor	 eax, eax
$LN5@PyUnicode_@60:

; 3649 : }

  0006f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00073	5b		 pop	 rbx
  00074	c3		 ret	 0
PyUnicode_AsEncodedUnicode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@NKLNDGAM@character?5out?5of?5range?$AA@ ; `string'
PUBLIC	PyUnicode_WriteChar
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_WriteChar DD imagerel $LN34
	DD	imagerel $LN34+549
	DD	imagerel $unwind$PyUnicode_WriteChar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_WriteChar DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BH@NKLNDGAM@character?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BH@NKLNDGAM@character?5out?5of?5range?$AA@ DB 'character out of ra'
	DB	'nge', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_WriteChar
_TEXT	SEGMENT
unicode$ = 48
index$ = 56
ch$ = 64
PyUnicode_WriteChar PROC				; COMDAT

; 4128 : {

$LN34:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4129 :     if (!PyUnicode_Check(unicode) || !PyUnicode_IS_COMPACT(unicode)) {

  0000f	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00013	41 8b f0	 mov	 esi, r8d
  00016	48 8b fa	 mov	 rdi, rdx
  00019	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00023	48 8b d9	 mov	 rbx, rcx
  00026	0f 84 e1 01 00
	00		 je	 $LN13@PyUnicode_@61
  0002c	f6 41 70 20	 test	 BYTE PTR [rcx+112], 32	; 00000020H
  00030	0f 84 d7 01 00
	00		 je	 $LN13@PyUnicode_@61

; 4131 :         return -1;
; 4132 :     }
; 4133 :     assert(PyUnicode_IS_READY(unicode));
; 4134 :     if (index < 0 || index >= PyUnicode_GET_LENGTH(unicode)) {

  00036	48 85 d2	 test	 rdx, rdx
  00039	0f 88 a8 01 00
	00		 js	 $LN11@PyUnicode_@61
  0003f	48 3b 51 60	 cmp	 rdx, QWORD PTR [rcx+96]
  00043	0f 8d 9e 01 00
	00		 jge	 $LN11@PyUnicode_@61

; 4136 :         return -1;
; 4137 :     }
; 4138 :     if (unicode_check_modifiable(unicode))

  00049	e8 00 00 00 00	 call	 unicode_check_modifiable
  0004e	85 c0		 test	 eax, eax

; 4139 :         return -1;

  00050	0f 85 bc 01 00
	00		 jne	 $LN33@PyUnicode_@61

; 4140 :     if (ch > PyUnicode_MAX_CHAR_VALUE(unicode)) {

  00056	8b 53 70	 mov	 edx, DWORD PTR [rbx+112]
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 06	 shr	 eax, 6
  0005e	83 e0 01	 and	 eax, 1
  00061	74 07		 je	 SHORT $LN19@PyUnicode_@61
  00063	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00068	eb 2b		 jmp	 SHORT $LN18@PyUnicode_@61
$LN19@PyUnicode_@61:
  0006a	44 8b c2	 mov	 r8d, edx
  0006d	41 c1 e8 02	 shr	 r8d, 2
  00071	41 83 e0 07	 and	 r8d, 7
  00075	41 83 f8 01	 cmp	 r8d, 1
  00079	75 07		 jne	 SHORT $LN17@PyUnicode_@61
  0007b	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00080	eb 13		 jmp	 SHORT $LN18@PyUnicode_@61
$LN17@PyUnicode_@61:
  00082	b9 ff ff 10 00	 mov	 ecx, 1114111		; 0010ffffH
  00087	41 b9 ff ff 00
	00		 mov	 r9d, 65535		; 0000ffffH
  0008d	41 83 f8 02	 cmp	 r8d, 2
  00091	41 0f 44 c9	 cmove	 ecx, r9d
$LN18@PyUnicode_@61:
  00095	3b f1		 cmp	 esi, ecx
  00097	76 26		 jbe	 SHORT $LN8@PyUnicode_@61

; 4141 :         PyErr_SetString(PyExc_ValueError, "character out of range");

  00099	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@NKLNDGAM@character?5out?5of?5range?$AA@
  000a7	e8 00 00 00 00	 call	 PyErr_SetString
  000ac	83 c8 ff	 or	 eax, -1

; 4147 : }

  000af	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b4	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bd	5f		 pop	 rdi
  000be	c3		 ret	 0
$LN8@PyUnicode_@61:

; 4142 :         return -1;
; 4143 :     }
; 4144 :     PyUnicode_WRITE(PyUnicode_KIND(unicode), PyUnicode_DATA(unicode),
; 4145 :                     index, ch);

  000bf	8b ca		 mov	 ecx, edx
  000c1	c1 e9 02	 shr	 ecx, 2
  000c4	83 e1 07	 and	 ecx, 7
  000c7	ff c9		 dec	 ecx
  000c9	0f 84 bb 00 00
	00		 je	 $LN3@PyUnicode_@61
  000cf	ff c9		 dec	 ecx
  000d1	74 5a		 je	 SHORT $LN2@PyUnicode_@61
  000d3	f6 c2 20	 test	 dl, 32			; 00000020H
  000d6	74 39		 je	 SHORT $LN31@PyUnicode_@61
  000d8	85 c0		 test	 eax, eax
  000da	74 19		 je	 SHORT $LN29@PyUnicode_@61
  000dc	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H

; 4146 :     return 0;

  000e0	33 c0		 xor	 eax, eax
  000e2	89 34 bb	 mov	 DWORD PTR [rbx+rdi*4], esi

; 4147 : }

  000e5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ea	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000ef	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f3	5f		 pop	 rdi
  000f4	c3		 ret	 0
$LN29@PyUnicode_@61:

; 4142 :         return -1;
; 4143 :     }
; 4144 :     PyUnicode_WRITE(PyUnicode_KIND(unicode), PyUnicode_DATA(unicode),
; 4145 :                     index, ch);

  000f5	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H

; 4146 :     return 0;

  000fc	33 c0		 xor	 eax, eax
  000fe	89 34 bb	 mov	 DWORD PTR [rbx+rdi*4], esi

; 4147 : }

  00101	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00106	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0010b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010f	5f		 pop	 rdi
  00110	c3		 ret	 0
$LN31@PyUnicode_@61:

; 4142 :         return -1;
; 4143 :     }
; 4144 :     PyUnicode_WRITE(PyUnicode_KIND(unicode), PyUnicode_DATA(unicode),
; 4145 :                     index, ch);

  00111	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]

; 4146 :     return 0;

  00118	33 c0		 xor	 eax, eax
  0011a	89 34 bb	 mov	 DWORD PTR [rbx+rdi*4], esi

; 4147 : }

  0011d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00122	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00127	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0012b	5f		 pop	 rdi
  0012c	c3		 ret	 0
$LN2@PyUnicode_@61:

; 4142 :         return -1;
; 4143 :     }
; 4144 :     PyUnicode_WRITE(PyUnicode_KIND(unicode), PyUnicode_DATA(unicode),
; 4145 :                     index, ch);

  0012d	f6 c2 20	 test	 dl, 32			; 00000020H
  00130	74 3b		 je	 SHORT $LN27@PyUnicode_@61
  00132	85 c0		 test	 eax, eax
  00134	74 1a		 je	 SHORT $LN25@PyUnicode_@61
  00136	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H

; 4146 :     return 0;

  0013a	33 c0		 xor	 eax, eax
  0013c	66 89 34 7b	 mov	 WORD PTR [rbx+rdi*2], si

; 4147 : }

  00140	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00145	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0014a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0014e	5f		 pop	 rdi
  0014f	c3		 ret	 0
$LN25@PyUnicode_@61:

; 4142 :         return -1;
; 4143 :     }
; 4144 :     PyUnicode_WRITE(PyUnicode_KIND(unicode), PyUnicode_DATA(unicode),
; 4145 :                     index, ch);

  00150	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H

; 4146 :     return 0;

  00157	33 c0		 xor	 eax, eax
  00159	66 89 34 7b	 mov	 WORD PTR [rbx+rdi*2], si

; 4147 : }

  0015d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00162	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00167	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016b	5f		 pop	 rdi
  0016c	c3		 ret	 0
$LN27@PyUnicode_@61:

; 4142 :         return -1;
; 4143 :     }
; 4144 :     PyUnicode_WRITE(PyUnicode_KIND(unicode), PyUnicode_DATA(unicode),
; 4145 :                     index, ch);

  0016d	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]

; 4146 :     return 0;

  00174	33 c0		 xor	 eax, eax
  00176	66 89 34 7b	 mov	 WORD PTR [rbx+rdi*2], si

; 4147 : }

  0017a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0017f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00184	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00188	5f		 pop	 rdi
  00189	c3		 ret	 0
$LN3@PyUnicode_@61:

; 4142 :         return -1;
; 4143 :     }
; 4144 :     PyUnicode_WRITE(PyUnicode_KIND(unicode), PyUnicode_DATA(unicode),
; 4145 :                     index, ch);

  0018a	f6 c2 20	 test	 dl, 32			; 00000020H
  0018d	74 3b		 je	 SHORT $LN23@PyUnicode_@61
  0018f	85 c0		 test	 eax, eax
  00191	74 1a		 je	 SHORT $LN21@PyUnicode_@61
  00193	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H

; 4146 :     return 0;

  00197	33 c0		 xor	 eax, eax
  00199	40 88 34 3b	 mov	 BYTE PTR [rbx+rdi], sil

; 4147 : }

  0019d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001a2	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001a7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001ab	5f		 pop	 rdi
  001ac	c3		 ret	 0
$LN21@PyUnicode_@61:

; 4142 :         return -1;
; 4143 :     }
; 4144 :     PyUnicode_WRITE(PyUnicode_KIND(unicode), PyUnicode_DATA(unicode),
; 4145 :                     index, ch);

  001ad	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H

; 4146 :     return 0;

  001b4	33 c0		 xor	 eax, eax
  001b6	40 88 34 3b	 mov	 BYTE PTR [rbx+rdi], sil

; 4147 : }

  001ba	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001bf	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001c4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001c8	5f		 pop	 rdi
  001c9	c3		 ret	 0
$LN23@PyUnicode_@61:

; 4142 :         return -1;
; 4143 :     }
; 4144 :     PyUnicode_WRITE(PyUnicode_KIND(unicode), PyUnicode_DATA(unicode),
; 4145 :                     index, ch);

  001ca	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]

; 4146 :     return 0;

  001d1	33 c0		 xor	 eax, eax
  001d3	40 88 34 3b	 mov	 BYTE PTR [rbx+rdi], sil

; 4147 : }

  001d7	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001dc	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001e1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001e5	5f		 pop	 rdi
  001e6	c3		 ret	 0
$LN11@PyUnicode_@61:

; 4135 :         PyErr_SetString(PyExc_IndexError, "string index out of range");

  001e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  001ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@DOEPEGBG@string?5index?5out?5of?5range?$AA@
  001f5	e8 00 00 00 00	 call	 PyErr_SetString
  001fa	83 c8 ff	 or	 eax, -1

; 4147 : }

  001fd	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00202	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00207	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0020b	5f		 pop	 rdi
  0020c	c3		 ret	 0
$LN13@PyUnicode_@61:

; 4130 :         PyErr_BadArgument();

  0020d	e8 00 00 00 00	 call	 PyErr_BadArgument
$LN33@PyUnicode_@61:

; 4147 : }

  00212	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00217	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0021c	83 c8 ff	 or	 eax, -1
  0021f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00223	5f		 pop	 rdi
  00224	c3		 ret	 0
PyUnicode_WriteChar ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@BHJCGFGN@exception?5attribute?5object?5must?5@ ; `string'
EXTRN	__imp_wcsncpy:PROC
EXTRN	PyUnicodeDecodeError_GetObject:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$unicode_decode_call_errorhandler DD imagerel unicode_decode_call_errorhandler
	DD	imagerel unicode_decode_call_errorhandler+120
	DD	imagerel $unwind$unicode_decode_call_errorhandler
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$unicode_decode_call_errorhandler DD imagerel unicode_decode_call_errorhandler+120
	DD	imagerel unicode_decode_call_errorhandler+956
	DD	imagerel $chain$1$unicode_decode_call_errorhandler
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$unicode_decode_call_errorhandler DD imagerel unicode_decode_call_errorhandler+956
	DD	imagerel unicode_decode_call_errorhandler+980
	DD	imagerel $chain$2$unicode_decode_call_errorhandler
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$unicode_decode_call_errorhandler DD 021H
	DD	imagerel unicode_decode_call_errorhandler
	DD	imagerel unicode_decode_call_errorhandler+120
	DD	imagerel $unwind$unicode_decode_call_errorhandler
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$unicode_decode_call_errorhandler DD 042c21H
	DD	012c42cH
	DD	0105408H
	DD	imagerel unicode_decode_call_errorhandler
	DD	imagerel unicode_decode_call_errorhandler+120
	DD	imagerel $unwind$unicode_decode_call_errorhandler
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_decode_call_errorhandler DD 081101H
	DD	0133411H
	DD	0f00d9211H
	DD	0d009e00bH
	DD	060067007H
xdata	ENDS
;	COMDAT ??_C@_0CJ@BHJCGFGN@exception?5attribute?5object?5must?5@
CONST	SEGMENT
??_C@_0CJ@BHJCGFGN@exception?5attribute?5object?5must?5@ DB 'exception at'
	DB	'tribute object must be bytes', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT unicode_decode_call_errorhandler
_TEXT	SEGMENT
repwlen$129249 = 64
errors$ = 128
repunicode$ = 136
errorHandler$ = 136
encoding$ = 144
reason$ = 152
input$ = 160
inend$ = 168
startinpos$ = 176
endinpos$ = 184
exceptionObject$ = 192
inptr$ = 200
newpos$ = 208
output$ = 208
outpos$ = 216
unicode_decode_call_errorhandler PROC			; COMDAT

; 4194 : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 4195 :     static char *argparse = "O!n;decoding error handler must return (str, int) tuple";
; 4196 : 
; 4197 :     PyObject *restuple = NULL;
; 4198 :     PyObject *repunicode = NULL;
; 4199 :     Py_ssize_t outsize;
; 4200 :     Py_ssize_t insize;
; 4201 :     Py_ssize_t requiredsize;
; 4202 :     Py_ssize_t newpos;
; 4203 :     PyObject *inputobj = NULL;
; 4204 :     int res = -1;
; 4205 : 
; 4206 :     if (_PyUnicode_KIND(*output) != PyUnicode_WCHAR_KIND)

  00011	4c 8b ac 24 d0
	00 00 00	 mov	 r13, QWORD PTR output$[rsp]
  00019	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR repunicode$[rsp], 0
  00025	41 83 cf ff	 or	 r15d, -1
  00029	49 8b 45 00	 mov	 rax, QWORD PTR [r13]
  0002d	49 8b f9	 mov	 rdi, r9
  00030	49 8b f0	 mov	 rsi, r8
  00033	f6 40 70 1c	 test	 BYTE PTR [rax+112], 28
  00037	48 8b da	 mov	 rbx, rdx
  0003a	74 06		 je	 SHORT $LN28@unicode_de@2

; 4207 :         outsize = PyUnicode_GET_LENGTH(*output);

  0003c	4c 8b 70 60	 mov	 r14, QWORD PTR [rax+96]

; 4208 :     else

  00040	eb 07		 jmp	 SHORT $LN27@unicode_de@2
$LN28@unicode_de@2:

; 4209 :         outsize = _PyUnicode_WSTR_LENGTH(*output);

  00042	4c 8b b0 90 00
	00 00		 mov	 r14, QWORD PTR [rax+144]
$LN27@unicode_de@2:

; 4210 : 
; 4211 :     if (*errorHandler == NULL) {

  00049	48 83 3a 00	 cmp	 QWORD PTR [rdx], 0
  0004d	75 11		 jne	 SHORT $LN25@unicode_de@2

; 4212 :         *errorHandler = PyCodec_LookupError(errors);

  0004f	e8 00 00 00 00	 call	 PyCodec_LookupError
  00054	48 89 03	 mov	 QWORD PTR [rbx], rax

; 4213 :         if (*errorHandler == NULL)

  00057	48 85 c0	 test	 rax, rax
  0005a	0f 84 5c 03 00
	00		 je	 $LN3@unicode_de@2
$LN25@unicode_de@2:

; 4214 :             goto onError;
; 4215 :     }
; 4216 : 
; 4217 :     make_decode_exception(exceptionObject,
; 4218 :         encoding,
; 4219 :         *input, *inend - *input,
; 4220 :         *startinpos, *endinpos,
; 4221 :         reason);

  00060	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR endinpos$[rsp]
  00068	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0006d	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR exceptionObject$[rsp]
  00075	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00078	48 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbp
  00080	48 8b ac 24 a8
	00 00 00	 mov	 rbp, QWORD PTR inend$[rsp]
  00088	4c 8b 4d 00	 mov	 r9, QWORD PTR [rbp]
  0008c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00091	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR startinpos$[rsp]
  00099	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0009c	4c 89 a4 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], r12
  000a4	4c 8b a4 24 a0
	00 00 00	 mov	 r12, QWORD PTR input$[rsp]
  000ac	4d 8b 04 24	 mov	 r8, QWORD PTR [r12]
  000b0	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000b5	48 8b d6	 mov	 rdx, rsi
  000b8	48 8b cf	 mov	 rcx, rdi
  000bb	4d 2b c8	 sub	 r9, r8
  000be	e8 00 00 00 00	 call	 make_decode_exception

; 4222 :     if (*exceptionObject == NULL)

  000c3	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  000c6	48 85 d2	 test	 rdx, rdx
  000c9	0f 84 dd 02 00
	00		 je	 $LN51@unicode_de@2

; 4223 :         goto onError;
; 4224 : 
; 4225 :     restuple = PyObject_CallFunctionObjArgs(*errorHandler, *exceptionObject, NULL);

  000cf	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000d2	45 33 c0	 xor	 r8d, r8d
  000d5	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  000da	48 8b d8	 mov	 rbx, rax

; 4226 :     if (restuple == NULL)

  000dd	48 85 c0	 test	 rax, rax
  000e0	0f 84 c6 02 00
	00		 je	 $LN51@unicode_de@2

; 4227 :         goto onError;
; 4228 :     if (!PyTuple_Check(restuple)) {

  000e6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]

; 4229 :         PyErr_SetString(PyExc_TypeError, &argparse[4]);

  000ea	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?argparse@?1??unicode_decode_call_errorhandler@@9@9
  000f1	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  000fb	75 15		 jne	 SHORT $LN22@unicode_de@2
  000fd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00104	48 83 c2 04	 add	 rdx, 4
  00108	e8 00 00 00 00	 call	 PyErr_SetString

; 4230 :         goto onError;

  0010d	e9 35 02 00 00	 jmp	 $onError$129201
$LN22@unicode_de@2:

; 4231 :     }
; 4232 :     if (!PyArg_ParseTuple(restuple, argparse, &PyUnicode_Type, &repunicode, &newpos))

  00112	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR newpos$[rsp]
  0011a	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR repunicode$[rsp]
  00122	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyUnicode_Type
  00129	48 8b cb	 mov	 rcx, rbx
  0012c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00131	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00136	85 c0		 test	 eax, eax
  00138	0f 84 09 02 00
	00		 je	 $onError$129201

; 4233 :         goto onError;
; 4234 :     if (PyUnicode_READY(repunicode) == -1)

  0013e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR repunicode$[rsp]
  00146	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0014a	75 0e		 jne	 SHORT $LN49@unicode_de@2
  0014c	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00151	83 f8 ff	 cmp	 eax, -1
  00154	0f 84 ed 01 00
	00		 je	 $onError$129201
$LN49@unicode_de@2:

; 4235 :         goto onError;
; 4236 : 
; 4237 :     /* Copy back the bytes variables, which might have been modified by the
; 4238 :        callback */
; 4239 :     inputobj = PyUnicodeDecodeError_GetObject(*exceptionObject);

  0015a	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0015d	e8 00 00 00 00	 call	 PyUnicodeDecodeError_GetObject
  00162	48 8b f8	 mov	 rdi, rax

; 4240 :     if (!inputobj)

  00165	48 85 c0	 test	 rax, rax
  00168	0f 84 d9 01 00
	00		 je	 $onError$129201

; 4241 :         goto onError;
; 4242 :     if (!PyBytes_Check(inputobj)) {

  0016e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00172	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  0017c	75 13		 jne	 SHORT $LN18@unicode_de@2

; 4243 :         PyErr_Format(PyExc_TypeError, "exception attribute object must be bytes");

  0017e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00185	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@BHJCGFGN@exception?5attribute?5object?5must?5@
  0018c	e8 00 00 00 00	 call	 PyErr_Format
$LN18@unicode_de@2:

; 4244 :     }
; 4245 :     *input = PyBytes_AS_STRING(inputobj);

  00191	48 8d 4f 78	 lea	 rcx, QWORD PTR [rdi+120]
  00195	49 89 0c 24	 mov	 QWORD PTR [r12], rcx

; 4246 :     insize = PyBytes_GET_SIZE(inputobj);

  00199	48 8b 77 60	 mov	 rsi, QWORD PTR [rdi+96]

; 4247 :     *inend = *input + insize;

  0019d	48 8d 04 31	 lea	 rax, QWORD PTR [rcx+rsi]

; 4248 :     /* we can DECREF safely, as the exception has another reference,
; 4249 :        so the object won't go away. */
; 4250 :     Py_DECREF(inputobj);

  001a1	48 8b cf	 mov	 rcx, rdi
  001a4	48 89 45 00	 mov	 QWORD PTR [rbp], rax
  001a8	e8 00 00 00 00	 call	 _Py_DecRef

; 4251 : 
; 4252 :     if (newpos<0)

  001ad	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR newpos$[rsp]
  001b5	4d 85 c0	 test	 r8, r8
  001b8	79 11		 jns	 SHORT $LN48@unicode_de@2

; 4253 :         newpos = insize+newpos;

  001ba	4c 03 c6	 add	 r8, rsi
  001bd	4c 89 84 24 d0
	00 00 00	 mov	 QWORD PTR newpos$[rsp], r8

; 4254 :     if (newpos<0 || newpos>insize) {

  001c5	0f 88 69 01 00
	00		 js	 $LN15@unicode_de@2
$LN48@unicode_de@2:
  001cb	4c 3b c6	 cmp	 r8, rsi
  001ce	0f 8f 60 01 00
	00		 jg	 $LN15@unicode_de@2

; 4256 :         goto onError;
; 4257 :     }
; 4258 : 
; 4259 :     if (_PyUnicode_KIND(*output) != PyUnicode_WCHAR_KIND) {

  001d4	49 8b 45 00	 mov	 rax, QWORD PTR [r13]
  001d8	f6 40 70 1c	 test	 BYTE PTR [rax+112], 28
  001dc	0f 84 ad 00 00
	00		 je	 $LN14@unicode_de@2

; 4260 :         /* need more space? (at least enough for what we
; 4261 :            have+the replacement+the rest of the string (starting
; 4262 :            at the new input position), so we won't have to check space
; 4263 :            when there are no errors in the rest of the string) */
; 4264 :         Py_ssize_t replen = PyUnicode_GET_LENGTH(repunicode);
; 4265 :         requiredsize = *outpos + replen + insize-newpos;

  001e2	48 8b bc 24 d8
	00 00 00	 mov	 rdi, QWORD PTR outpos$[rsp]
  001ea	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR repunicode$[rsp]
  001f2	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  001f5	48 8b 68 60	 mov	 rbp, QWORD PTR [rax+96]
  001f9	49 2b d0	 sub	 rdx, r8
  001fc	48 03 d5	 add	 rdx, rbp
  001ff	48 03 d6	 add	 rdx, rsi

; 4266 :         if (requiredsize > outsize) {

  00202	49 3b d6	 cmp	 rdx, r14
  00205	7e 23		 jle	 SHORT $LN11@unicode_de@2

; 4267 :             if (requiredsize<2*outsize)

  00207	4b 8d 04 36	 lea	 rax, QWORD PTR [r14+r14]

; 4268 :                 requiredsize = 2*outsize;
; 4269 :             if (unicode_resize(output, requiredsize) < 0)

  0020b	49 8b cd	 mov	 rcx, r13
  0020e	48 3b d0	 cmp	 rdx, rax
  00211	48 0f 4c d0	 cmovl	 rdx, rax
  00215	e8 00 00 00 00	 call	 unicode_resize
  0021a	85 c0		 test	 eax, eax
  0021c	0f 88 25 01 00
	00		 js	 $onError$129201
  00222	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR repunicode$[rsp]
$LN11@unicode_de@2:

; 4270 :                 goto onError;
; 4271 :         }
; 4272 :         if (unicode_widen(output, *outpos,
; 4273 :                           PyUnicode_MAX_CHAR_VALUE(repunicode)) < 0)

  0022a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0022d	a8 40		 test	 al, 64			; 00000040H
  0022f	74 08		 je	 SHORT $LN35@unicode_de@2
  00231	41 b8 7f 00 00
	00		 mov	 r8d, 127		; 0000007fH
  00237	eb 25		 jmp	 SHORT $LN34@unicode_de@2
$LN35@unicode_de@2:
  00239	c1 e8 02	 shr	 eax, 2
  0023c	83 e0 07	 and	 eax, 7
  0023f	83 f8 01	 cmp	 eax, 1
  00242	75 08		 jne	 SHORT $LN33@unicode_de@2
  00244	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  0024a	eb 12		 jmp	 SHORT $LN34@unicode_de@2
$LN33@unicode_de@2:
  0024c	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00251	41 b8 ff ff 10
	00		 mov	 r8d, 1114111		; 0010ffffH
  00257	83 f8 02	 cmp	 eax, 2
  0025a	44 0f 44 c1	 cmove	 r8d, ecx
$LN34@unicode_de@2:
  0025e	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00261	49 8b cd	 mov	 rcx, r13
  00264	e8 00 00 00 00	 call	 unicode_widen
  00269	85 c0		 test	 eax, eax
  0026b	0f 88 d6 00 00
	00		 js	 $onError$129201

; 4274 :             goto onError;
; 4275 :         _PyUnicode_FastCopyCharacters(*output, *outpos, repunicode, 0, replen);

  00271	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR repunicode$[rsp]
  00279	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  0027c	49 8b 4d 00	 mov	 rcx, QWORD PTR [r13]
  00280	45 33 c9	 xor	 r9d, r9d
  00283	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00288	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 4276 :         *outpos += replen;
; 4277 :     }
; 4278 :     else {

  0028d	eb 7b		 jmp	 SHORT $LN52@unicode_de@2
$LN14@unicode_de@2:

; 4279 :         wchar_t *repwstr;
; 4280 :         Py_ssize_t repwlen;
; 4281 :         repwstr = PyUnicode_AsUnicodeAndSize(repunicode, &repwlen);

  0028f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR repunicode$[rsp]
  00297	48 8d 54 24 40	 lea	 rdx, QWORD PTR repwlen$129249[rsp]
  0029c	e8 00 00 00 00	 call	 PyUnicode_AsUnicodeAndSize
  002a1	4c 8b e0	 mov	 r12, rax

; 4282 :         if (repwstr == NULL)

  002a4	48 85 c0	 test	 rax, rax
  002a7	0f 84 9a 00 00
	00		 je	 $onError$129201

; 4283 :             goto onError;
; 4284 :         /* need more space? (at least enough for what we
; 4285 :            have+the replacement+the rest of the string (starting
; 4286 :            at the new input position), so we won't have to check space
; 4287 :            when there are no errors in the rest of the string) */
; 4288 :         requiredsize = *outpos + repwlen + insize-newpos;

  002ad	48 8b bc 24 d8
	00 00 00	 mov	 rdi, QWORD PTR outpos$[rsp]
  002b5	48 8b 6c 24 40	 mov	 rbp, QWORD PTR repwlen$129249[rsp]
  002ba	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  002bd	48 2b 94 24 d0
	00 00 00	 sub	 rdx, QWORD PTR newpos$[rsp]
  002c5	48 03 d5	 add	 rdx, rbp
  002c8	48 03 d6	 add	 rdx, rsi

; 4289 :         if (requiredsize > outsize) {

  002cb	49 3b d6	 cmp	 rdx, r14
  002ce	7e 17		 jle	 SHORT $LN5@unicode_de@2

; 4290 :             if (requiredsize < 2*outsize)

  002d0	4b 8d 04 36	 lea	 rax, QWORD PTR [r14+r14]

; 4291 :                 requiredsize = 2*outsize;
; 4292 :             if (unicode_resize(output, requiredsize) < 0)

  002d4	49 8b cd	 mov	 rcx, r13
  002d7	48 3b d0	 cmp	 rdx, rax
  002da	48 0f 4c d0	 cmovl	 rdx, rax
  002de	e8 00 00 00 00	 call	 unicode_resize
  002e3	85 c0		 test	 eax, eax
  002e5	78 60		 js	 SHORT $onError$129201
$LN5@unicode_de@2:

; 4293 :                 goto onError;
; 4294 :         }
; 4295 :         wcsncpy(_PyUnicode_WSTR(*output) + *outpos, repwstr, repwlen);

  002e7	49 8b 45 00	 mov	 rax, QWORD PTR [r13]
  002eb	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  002ee	4c 8b c5	 mov	 r8, rbp
  002f1	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  002f5	49 8b d4	 mov	 rdx, r12
  002f8	48 8d 0c 48	 lea	 rcx, QWORD PTR [rax+rcx*2]
  002fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy
  00302	4c 8b a4 24 a0
	00 00 00	 mov	 r12, QWORD PTR input$[rsp]
$LN52@unicode_de@2:

; 4296 :         *outpos += repwlen;

  0030a	48 01 2f	 add	 QWORD PTR [rdi], rbp

; 4297 :     }
; 4298 :     *endinpos = newpos;

  0030d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR endinpos$[rsp]
  00315	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR newpos$[rsp]
  0031d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4299 :     *inptr = *input + newpos;

  00320	49 03 0c 24	 add	 rcx, QWORD PTR [r12]
  00324	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR inptr$[rsp]
  0032c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4300 : 
; 4301 :     /* we made it! */
; 4302 :     res = 0;

  0032f	45 33 ff	 xor	 r15d, r15d
  00332	eb 13		 jmp	 SHORT $onError$129201
$LN15@unicode_de@2:

; 4255 :         PyErr_Format(PyExc_IndexError, "position %zd from error handler out of bounds", newpos);

  00334	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0033b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@NELAFELL@position?5?$CFzd?5from?5error?5handler?5@
  00342	e8 00 00 00 00	 call	 PyErr_Format
$onError$129201:

; 4303 : 
; 4304 :   onError:
; 4305 :     Py_XDECREF(restuple);

  00347	e8 00 00 00 00	 call	 _Py_PXCTX
  0034c	85 c0		 test	 eax, eax
  0034e	75 5c		 jne	 SHORT $LN51@unicode_de@2
  00350	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00354	a8 20		 test	 al, 32			; 00000020H
  00356	75 4c		 jne	 SHORT $LN41@unicode_de@2
  00358	84 c0		 test	 al, al
  0035a	78 48		 js	 SHORT $LN41@unicode_de@2
  0035c	a8 02		 test	 al, 2
  0035e	75 4c		 jne	 SHORT $LN51@unicode_de@2
  00360	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00364	75 46		 jne	 SHORT $LN51@unicode_de@2
  00366	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0036d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00374	4c 8b cb	 mov	 r9, rbx
  00377	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0037d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00385	e8 00 00 00 00	 call	 _PyParallel_Guard
  0038a	48 8b cb	 mov	 rcx, rbx
  0038d	85 c0		 test	 eax, eax
  0038f	74 07		 je	 SHORT $LN46@unicode_de@2
  00391	e8 00 00 00 00	 call	 _Px_Dealloc
  00396	eb 14		 jmp	 SHORT $LN51@unicode_de@2
$LN46@unicode_de@2:
  00398	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0039c	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  003a2	eb 08		 jmp	 SHORT $LN51@unicode_de@2
$LN41@unicode_de@2:
  003a4	48 8b cb	 mov	 rcx, rbx
  003a7	e8 00 00 00 00	 call	 Px_DecRef
$LN51@unicode_de@2:
  003ac	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]
  003b4	4c 8b a4 24 90
	00 00 00	 mov	 r12, QWORD PTR [rsp+144]
$LN3@unicode_de@2:

; 4306 :     return res;

  003bc	41 8b c7	 mov	 eax, r15d

; 4307 : }

  003bf	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  003c7	48 83 c4 50	 add	 rsp, 80			; 00000050H
  003cb	41 5f		 pop	 r15
  003cd	41 5e		 pop	 r14
  003cf	41 5d		 pop	 r13
  003d1	5f		 pop	 rdi
  003d2	5e		 pop	 rsi
  003d3	c3		 ret	 0
unicode_decode_call_errorhandler ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@BOIOHCO@unexpected?5special?5character?$AA@ ; `string'
PUBLIC	??_C@_0CI@ILNBGPFL@non?9zero?5padding?5bits?5in?5shift?5s@ ; `string'
PUBLIC	??_C@_0CE@KACJLACL@partial?5character?5in?5shift?5seque@ ; `string'
PUBLIC	??_C@_04DAOPEHDA@utf7?$AA@			; `string'
PUBLIC	??_C@_0BM@MIGJLBDF@unterminated?5shift?5sequence?$AA@ ; `string'
PUBLIC	PyUnicode_DecodeUTF7Stateful
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_DecodeUTF7Stateful DD imagerel $LN101
	DD	imagerel $LN101+1326
	DD	imagerel $unwind$PyUnicode_DecodeUTF7Stateful
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_DecodeUTF7Stateful DD 0a2c01H
	DD	017012cH
	DD	0e01ef020H
	DD	0c01ad01cH
	DD	060177018H
	DD	050153016H
xdata	ENDS
;	COMDAT ??_C@_0BN@BOIOHCO@unexpected?5special?5character?$AA@
CONST	SEGMENT
??_C@_0BN@BOIOHCO@unexpected?5special?5character?$AA@ DB 'unexpected spec'
	DB	'ial character', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@ILNBGPFL@non?9zero?5padding?5bits?5in?5shift?5s@
CONST	SEGMENT
??_C@_0CI@ILNBGPFL@non?9zero?5padding?5bits?5in?5shift?5s@ DB 'non-zero p'
	DB	'adding bits in shift sequence', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KACJLACL@partial?5character?5in?5shift?5seque@
CONST	SEGMENT
??_C@_0CE@KACJLACL@partial?5character?5in?5shift?5seque@ DB 'partial char'
	DB	'acter in shift sequence', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DAOPEHDA@utf7?$AA@
CONST	SEGMENT
??_C@_04DAOPEHDA@utf7?$AA@ DB 'utf7', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MIGJLBDF@unterminated?5shift?5sequence?$AA@
CONST	SEGMENT
??_C@_0BM@MIGJLBDF@unterminated?5shift?5sequence?$AA@ DB 'unterminated sh'
	DB	'ift sequence', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_DecodeUTF7Stateful
_TEXT	SEGMENT
inShift$1$ = 96
starts$ = 104
unicode$ = 112
outpos$ = 120
startinpos$ = 128
exc$ = 136
e$ = 144
errorHandler$ = 152
endinpos$ = 160
shiftOutStart$1$ = 168
s$ = 256
size$ = 264
errors$ = 272
consumed$ = 280
PyUnicode_DecodeUTF7Stateful PROC			; COMDAT

; 4410 : {

$LN101:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	53		 push	 rbx
  00016	56		 push	 rsi
  00017	57		 push	 rdi
  00018	41 54		 push	 r12
  0001a	41 55		 push	 r13
  0001c	41 56		 push	 r14
  0001e	41 57		 push	 r15
  00020	48 8d 6c 24 e1	 lea	 rbp, QWORD PTR [rsp-31]
  00025	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 4411 :     const char *starts = s;
; 4412 :     Py_ssize_t startinpos;
; 4413 :     Py_ssize_t endinpos;
; 4414 :     Py_ssize_t outpos;
; 4415 :     const char *e;
; 4416 :     PyObject *unicode;
; 4417 :     const char *errmsg = "";
; 4418 :     int inShift = 0;

  0002c	45 33 ff	 xor	 r15d, r15d
  0002f	48 8b c2	 mov	 rax, rdx
  00032	48 8b d9	 mov	 rbx, rcx
  00035	48 8b f9	 mov	 rdi, rcx
  00038	48 89 4d cf	 mov	 QWORD PTR starts$[rbp-153], rcx

; 4419 :     Py_ssize_t shiftOutStart;
; 4420 :     unsigned int base64bits = 0;
; 4421 :     unsigned long base64buffer = 0;
; 4422 :     Py_UCS4 surrogate = 0;
; 4423 :     PyObject *errorHandler = NULL;
; 4424 :     PyObject *exc = NULL;
; 4425 : 
; 4426 :     /* Start off assuming it's all ASCII. Widen later as necessary. */
; 4427 :     unicode = PyUnicode_New(size, 127);

  0003c	41 8d 57 7f	 lea	 edx, QWORD PTR [r15+127]
  00040	48 8b c8	 mov	 rcx, rax
  00043	4d 8b f1	 mov	 r14, r9
  00046	44 89 7d c7	 mov	 DWORD PTR inShift$1$[rbp-153], r15d
  0004a	45 8b e7	 mov	 r12d, r15d
  0004d	45 8b ef	 mov	 r13d, r15d
  00050	41 8b f7	 mov	 esi, r15d
  00053	4c 89 7d ff	 mov	 QWORD PTR errorHandler$[rbp-153], r15
  00057	4c 89 7d ef	 mov	 QWORD PTR exc$[rbp-153], r15
  0005b	e8 00 00 00 00	 call	 PyUnicode_New
  00060	48 89 45 d7	 mov	 QWORD PTR unicode$[rbp-153], rax

; 4428 :     if (!unicode)

  00064	48 85 c0	 test	 rax, rax

; 4429 :         return NULL;

  00067	0f 84 f1 01 00
	00		 je	 $LN99@PyUnicode_@62

; 4430 :     if (size == 0) {

  0006d	48 8b 55 6f	 mov	 rdx, QWORD PTR size$[rbp-153]
  00071	48 85 d2	 test	 rdx, rdx
  00074	75 11		 jne	 SHORT $LN64@PyUnicode_@62

; 4431 :         if (consumed)

  00076	4d 85 f6	 test	 r14, r14
  00079	0f 84 e1 01 00
	00		 je	 $LN66@PyUnicode_@62

; 4432 :             *consumed = 0;

  0007f	4d 89 3e	 mov	 QWORD PTR [r14], r15

; 4433 :         return unicode;

  00082	e9 d9 01 00 00	 jmp	 $LN66@PyUnicode_@62
$LN64@PyUnicode_@62:

; 4434 :     }
; 4435 : 
; 4436 :     shiftOutStart = outpos = 0;
; 4437 :     e = s + size;

  00087	4c 8b 75 e7	 mov	 r14, QWORD PTR startinpos$[rbp-153]
  0008b	4c 8d 3c 13	 lea	 r15, QWORD PTR [rbx+rdx]
  0008f	48 89 75 df	 mov	 QWORD PTR outpos$[rbp-153], rsi
  00093	4c 89 7d f7	 mov	 QWORD PTR e$[rbp-153], r15
  00097	48 89 75 0f	 mov	 QWORD PTR shiftOutStart$1$[rbp-153], rsi

; 4511 :             startinpos = s-starts;

  0009b	8b ce		 mov	 ecx, esi
  0009d	eb 15		 jmp	 SHORT $LL62@PyUnicode_@62
$LN100@PyUnicode_@62:

; 4462 :                             continue;

  0009f	48 8b 55 6f	 mov	 rdx, QWORD PTR size$[rbp-153]
  000a3	8b 4d c7	 mov	 ecx, DWORD PTR inShift$1$[rbp-153]
  000a6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL97@PyUnicode_@62:

; 4511 :             startinpos = s-starts;

  000b0	48 8b 7d cf	 mov	 rdi, QWORD PTR starts$[rbp-153]
$LL62@PyUnicode_@62:

; 4438 : 
; 4439 :     while (s < e) {

  000b4	49 3b df	 cmp	 rbx, r15
  000b7	0f 82 b8 00 00
	00		 jb	 $restart$129309

; 4546 : 
; 4547 :     /* end of string */
; 4548 : 
; 4549 :     if (inShift && !consumed) { /* in shift sequence, no more to follow */

  000bd	48 8b 45 7f	 mov	 rax, QWORD PTR consumed$[rbp-153]
  000c1	85 c9		 test	 ecx, ecx
  000c3	0f 84 1b 04 00
	00		 je	 $LN22@PyUnicode_@62
  000c9	48 85 c0	 test	 rax, rax
  000cc	0f 85 a0 03 00
	00		 jne	 $LN94@PyUnicode_@62

; 4550 :         /* if we're in an inconsistent state, that's an error */
; 4551 :         if (surrogate ||
; 4552 :                 (base64bits >= 6) ||
; 4553 :                 (base64bits > 0 && base64buffer != 0)) {

  000d2	85 f6		 test	 esi, esi
  000d4	75 18		 jne	 SHORT $LN24@PyUnicode_@62
  000d6	41 83 fc 06	 cmp	 r12d, 6
  000da	73 12		 jae	 SHORT $LN24@PyUnicode_@62
  000dc	45 85 e4	 test	 r12d, r12d
  000df	0f 84 0a 04 00
	00		 je	 $LN18@PyUnicode_@62
  000e5	45 85 ed	 test	 r13d, r13d
  000e8	0f 84 01 04 00
	00		 je	 $LN18@PyUnicode_@62
$LN24@PyUnicode_@62:

; 4554 :             endinpos = size;
; 4555 :             if (unicode_decode_call_errorhandler(
; 4556 :                     errors, &errorHandler,
; 4557 :                     "utf7", "unterminated shift sequence",
; 4558 :                     &starts, &e, &startinpos, &endinpos, &exc, &s,
; 4559 :                     &unicode, &outpos))

  000ee	48 8b 4d 77	 mov	 rcx, QWORD PTR errors$[rbp-153]
  000f2	48 8d 45 df	 lea	 rax, QWORD PTR outpos$[rbp-153]
  000f6	48 89 55 07	 mov	 QWORD PTR endinpos$[rbp-153], rdx
  000fa	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  000ff	48 8d 45 d7	 lea	 rax, QWORD PTR unicode$[rbp-153]
  00103	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BM@MIGJLBDF@unterminated?5shift?5sequence?$AA@
  0010a	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0010f	48 8d 45 67	 lea	 rax, QWORD PTR s$[rbp-153]
  00113	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04DAOPEHDA@utf7?$AA@
  0011a	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0011f	48 8d 45 ef	 lea	 rax, QWORD PTR exc$[rbp-153]
  00123	48 8d 55 ff	 lea	 rdx, QWORD PTR errorHandler$[rbp-153]
  00127	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0012c	48 8d 45 07	 lea	 rax, QWORD PTR endinpos$[rbp-153]
  00130	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00135	48 8d 45 e7	 lea	 rax, QWORD PTR startinpos$[rbp-153]
  00139	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0013e	48 8d 45 f7	 lea	 rax, QWORD PTR e$[rbp-153]
  00142	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00147	48 8d 45 cf	 lea	 rax, QWORD PTR starts$[rbp-153]
  0014b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00150	e8 00 00 00 00	 call	 unicode_decode_call_errorhandler
  00155	85 c0		 test	 eax, eax
  00157	0f 85 dc 00 00
	00		 jne	 $onError$129327

; 4560 :                 goto onError;
; 4561 :             if (s < e)

  0015d	48 8b 5d 67	 mov	 rbx, QWORD PTR s$[rbp-153]
  00161	4c 8b 7d f7	 mov	 r15, QWORD PTR e$[rbp-153]
  00165	49 3b df	 cmp	 rbx, r15
  00168	0f 83 81 03 00
	00		 jae	 $LN18@PyUnicode_@62
  0016e	8b 4d c7	 mov	 ecx, DWORD PTR inShift$1$[rbp-153]
  00171	48 8b 55 6f	 mov	 rdx, QWORD PTR size$[rbp-153]
$restart$129309:

; 4440 :         Py_UCS4 ch;
; 4441 :       restart:
; 4442 :         ch = (unsigned char) *s;

  00175	0f b6 3b	 movzx	 edi, BYTE PTR [rbx]

; 4443 : 
; 4444 :         if (inShift) { /* in a base-64 section */

  00178	85 c9		 test	 ecx, ecx
  0017a	0f 84 c8 01 00
	00		 je	 $LN60@PyUnicode_@62

; 4445 :             if (IS_BASE64(ch)) { /* consume a base-64 character */

  00180	83 ff 41	 cmp	 edi, 65			; 00000041H
  00183	72 09		 jb	 SHORT $LN57@PyUnicode_@62
  00185	83 ff 5a	 cmp	 edi, 90			; 0000005aH
  00188	0f 86 e6 00 00
	00		 jbe	 $LN58@PyUnicode_@62
$LN57@PyUnicode_@62:
  0018e	83 ff 61	 cmp	 edi, 97			; 00000061H
  00191	72 09		 jb	 SHORT $LN56@PyUnicode_@62
  00193	83 ff 7a	 cmp	 edi, 122		; 0000007aH
  00196	0f 86 d8 00 00
	00		 jbe	 $LN58@PyUnicode_@62
$LN56@PyUnicode_@62:
  0019c	83 ff 30	 cmp	 edi, 48			; 00000030H
  0019f	72 09		 jb	 SHORT $LN55@PyUnicode_@62
  001a1	83 ff 39	 cmp	 edi, 57			; 00000039H
  001a4	0f 86 ca 00 00
	00		 jbe	 $LN58@PyUnicode_@62
$LN55@PyUnicode_@62:
  001aa	83 ff 2b	 cmp	 edi, 43			; 0000002bH
  001ad	0f 84 c1 00 00
	00		 je	 $LN58@PyUnicode_@62
  001b3	83 ff 2f	 cmp	 edi, 47			; 0000002fH
  001b6	0f 84 b8 00 00
	00		 je	 $LN58@PyUnicode_@62

; 4475 :                         if (unicode_putchar(&unicode, &outpos, outCh) < 0)
; 4476 :                             goto onError;
; 4477 :                     }
; 4478 :                 }
; 4479 :             }
; 4480 :             else { /* now leaving a base-64 section */
; 4481 :                 inShift = 0;

  001bc	33 c9		 xor	 ecx, ecx

; 4482 :                 s++;

  001be	48 ff c3	 inc	 rbx
  001c1	89 4d c7	 mov	 DWORD PTR inShift$1$[rbp-153], ecx
  001c4	48 89 5d 67	 mov	 QWORD PTR s$[rbp-153], rbx

; 4483 :                 if (surrogate) {

  001c8	85 f6		 test	 esi, esi
  001ca	74 18		 je	 SHORT $LN44@PyUnicode_@62

; 4484 :                     if (unicode_putchar(&unicode, &outpos, surrogate) < 0)

  001cc	48 8d 55 df	 lea	 rdx, QWORD PTR outpos$[rbp-153]
  001d0	48 8d 4d d7	 lea	 rcx, QWORD PTR unicode$[rbp-153]
  001d4	44 8b c6	 mov	 r8d, esi
  001d7	e8 00 00 00 00	 call	 unicode_putchar
  001dc	85 c0		 test	 eax, eax
  001de	78 59		 js	 SHORT $onError$129327

; 4485 :                         goto onError;
; 4486 :                     surrogate = 0;

  001e0	33 f6		 xor	 esi, esi
  001e2	8b ce		 mov	 ecx, esi
$LN44@PyUnicode_@62:

; 4487 :                 }
; 4488 :                 if (base64bits > 0) { /* left-over bits */

  001e4	45 85 e4	 test	 r12d, r12d
  001e7	74 2b		 je	 SHORT $LN39@PyUnicode_@62

; 4489 :                     if (base64bits >= 6) {

  001e9	41 83 fc 06	 cmp	 r12d, 6
  001ed	72 10		 jb	 SHORT $LN41@PyUnicode_@62

; 4490 :                         /* We've seen at least one base-64 character */
; 4491 :                         errmsg = "partial character in shift sequence";
; 4492 :                         goto utf7Error;

  001ef	48 8b 45 cf	 mov	 rax, QWORD PTR starts$[rbp-153]
  001f3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0CE@KACJLACL@partial?5character?5in?5shift?5seque@
  001fa	e9 fb 01 00 00	 jmp	 $utf7Error$129339
$LN41@PyUnicode_@62:

; 4493 :                     }
; 4494 :                     else {
; 4495 :                         /* Some bits remain; they should be zero */
; 4496 :                         if (base64buffer != 0) {

  001ff	45 85 ed	 test	 r13d, r13d
  00202	74 10		 je	 SHORT $LN39@PyUnicode_@62

; 4497 :                             errmsg = "non-zero padding bits in shift sequence";
; 4498 :                             goto utf7Error;

  00204	48 8b 45 cf	 mov	 rax, QWORD PTR starts$[rbp-153]
  00208	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0CI@ILNBGPFL@non?9zero?5padding?5bits?5in?5shift?5s@
  0020f	e9 e6 01 00 00	 jmp	 $utf7Error$129339
$LN39@PyUnicode_@62:

; 4499 :                         }
; 4500 :                     }
; 4501 :                 }
; 4502 :                 if (ch != '-') {

  00214	48 8b 55 6f	 mov	 rdx, QWORD PTR size$[rbp-153]
  00218	83 ff 2d	 cmp	 edi, 45			; 0000002dH
  0021b	0f 84 8f fe ff
	ff		 je	 $LL97@PyUnicode_@62
$LN48@PyUnicode_@62:

; 4503 :                     /* '-' is absorbed; other terminating
; 4504 :                        characters are preserved */
; 4505 :                     if (unicode_putchar(&unicode, &outpos, ch) < 0)

  00221	48 8d 55 df	 lea	 rdx, QWORD PTR outpos$[rbp-153]
  00225	48 8d 4d d7	 lea	 rcx, QWORD PTR unicode$[rbp-153]
  00229	44 8b c7	 mov	 r8d, edi
  0022c	e8 00 00 00 00	 call	 unicode_putchar
  00231	85 c0		 test	 eax, eax
  00233	0f 89 66 fe ff
	ff		 jns	 $LN100@PyUnicode_@62
$onError$129327:

; 4591 : 
; 4592 :   onError:
; 4593 :     Py_XDECREF(errorHandler);

  00239	48 8b 4d ff	 mov	 rcx, QWORD PTR errorHandler$[rbp-153]
  0023d	48 85 c9	 test	 rcx, rcx
  00240	74 05		 je	 SHORT $LN7@PyUnicode_@62
  00242	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@PyUnicode_@62:

; 4594 :     Py_XDECREF(exc);

  00247	48 8b 4d ef	 mov	 rcx, QWORD PTR exc$[rbp-153]
  0024b	48 85 c9	 test	 rcx, rcx
  0024e	74 05		 je	 SHORT $LN3@PyUnicode_@62
  00250	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyUnicode_@62:

; 4595 :     Py_DECREF(unicode);

  00255	48 8b 4d d7	 mov	 rcx, QWORD PTR unicode$[rbp-153]
  00259	e8 00 00 00 00	 call	 _Py_DecRef
$LN99@PyUnicode_@62:

; 4596 :     return NULL;

  0025e	33 c0		 xor	 eax, eax
$LN66@PyUnicode_@62:

; 4597 : }

  00260	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00267	41 5f		 pop	 r15
  00269	41 5e		 pop	 r14
  0026b	41 5d		 pop	 r13
  0026d	41 5c		 pop	 r12
  0026f	5f		 pop	 rdi
  00270	5e		 pop	 rsi
  00271	5b		 pop	 rbx
  00272	5d		 pop	 rbp
  00273	c3		 ret	 0
$LN58@PyUnicode_@62:

; 4446 :                 base64buffer = (base64buffer << 6) | FROM_BASE64(ch);

  00274	8d 47 bf	 lea	 eax, DWORD PTR [rdi-65]
  00277	83 f8 19	 cmp	 eax, 25
  0027a	76 25		 jbe	 SHORT $LN71@PyUnicode_@62
  0027c	8d 47 9f	 lea	 eax, DWORD PTR [rdi-97]
  0027f	83 f8 19	 cmp	 eax, 25
  00282	77 05		 ja	 SHORT $LN69@PyUnicode_@62
  00284	8d 47 b9	 lea	 eax, DWORD PTR [rdi-71]
  00287	eb 18		 jmp	 SHORT $LN71@PyUnicode_@62
$LN69@PyUnicode_@62:
  00289	8d 47 d0	 lea	 eax, DWORD PTR [rdi-48]
  0028c	83 f8 09	 cmp	 eax, 9
  0028f	77 05		 ja	 SHORT $LN70@PyUnicode_@62
  00291	8d 47 04	 lea	 eax, DWORD PTR [rdi+4]
  00294	eb 0b		 jmp	 SHORT $LN71@PyUnicode_@62
$LN70@PyUnicode_@62:
  00296	33 c0		 xor	 eax, eax
  00298	83 ff 2b	 cmp	 edi, 43			; 0000002bH
  0029b	0f 95 c0	 setne	 al
  0029e	83 c0 3e	 add	 eax, 62			; 0000003eH
$LN71@PyUnicode_@62:

; 4447 :                 base64bits += 6;
; 4448 :                 s++;
; 4449 :                 if (base64bits >= 16) {

  002a1	48 8b 7d cf	 mov	 rdi, QWORD PTR starts$[rbp-153]
  002a5	41 c1 e5 06	 shl	 r13d, 6
  002a9	48 ff c3	 inc	 rbx
  002ac	41 83 c4 06	 add	 r12d, 6
  002b0	44 0b e8	 or	 r13d, eax
  002b3	48 89 5d 67	 mov	 QWORD PTR s$[rbp-153], rbx
  002b7	41 83 fc 10	 cmp	 r12d, 16
  002bb	0f 82 f3 fd ff
	ff		 jb	 $LL62@PyUnicode_@62

; 4450 :                     /* we have enough bits for a UTF-16 value */
; 4451 :                     Py_UCS4 outCh = (Py_UCS4)(base64buffer >> (base64bits-16));

  002c1	41 83 c4 f0	 add	 r12d, -16		; fffffff0H
  002c5	41 8b fd	 mov	 edi, r13d

; 4452 :                     base64bits -= 16;
; 4453 :                     base64buffer &= (1 << base64bits) - 1; /* clear high bits */

  002c8	b8 01 00 00 00	 mov	 eax, 1
  002cd	41 8b cc	 mov	 ecx, r12d
  002d0	d3 e0		 shl	 eax, cl
  002d2	d3 ef		 shr	 edi, cl
  002d4	ff c8		 dec	 eax
  002d6	44 23 e8	 and	 r13d, eax

; 4454 :                     assert(outCh <= 0xffff);
; 4455 :                     if (surrogate) {

  002d9	85 f6		 test	 esi, esi
  002db	74 53		 je	 SHORT $LN50@PyUnicode_@62

; 4456 :                         /* expecting a second surrogate */
; 4457 :                         if (Py_UNICODE_IS_LOW_SURROGATE(outCh)) {

  002dd	8d 87 00 24 ff
	ff		 lea	 eax, DWORD PTR [rdi-56320]

; 4458 :                             Py_UCS4 ch2 = Py_UNICODE_JOIN_SURROGATES(surrogate, outCh);
; 4459 :                             if (unicode_putchar(&unicode, &outpos, ch2) < 0)

  002e3	48 8d 55 df	 lea	 rdx, QWORD PTR outpos$[rbp-153]
  002e7	48 8d 4d d7	 lea	 rcx, QWORD PTR unicode$[rbp-153]
  002eb	3d ff 03 00 00	 cmp	 eax, 1023		; 000003ffH
  002f0	77 2c		 ja	 SHORT $LN52@PyUnicode_@62
  002f2	81 e6 ff 03 00
	00		 and	 esi, 1023		; 000003ffH
  002f8	81 e7 ff 03 00
	00		 and	 edi, 1023		; 000003ffH
  002fe	c1 e6 0a	 shl	 esi, 10
  00301	0b f7		 or	 esi, edi
  00303	44 8d 86 00 00
	01 00		 lea	 r8d, DWORD PTR [rsi+65536]
  0030a	e8 00 00 00 00	 call	 unicode_putchar
  0030f	85 c0		 test	 eax, eax
  00311	0f 88 22 ff ff
	ff		 js	 $onError$129327

; 4460 :                                 goto onError;
; 4461 :                             surrogate = 0;

  00317	33 f6		 xor	 esi, esi

; 4462 :                             continue;

  00319	e9 81 fd ff ff	 jmp	 $LN100@PyUnicode_@62
$LN52@PyUnicode_@62:

; 4463 :                         }
; 4464 :                         else {
; 4465 :                             if (unicode_putchar(&unicode, &outpos, surrogate) < 0)

  0031e	44 8b c6	 mov	 r8d, esi
  00321	e8 00 00 00 00	 call	 unicode_putchar
  00326	85 c0		 test	 eax, eax
  00328	0f 88 0b ff ff
	ff		 js	 $onError$129327

; 4466 :                                 goto onError;
; 4467 :                             surrogate = 0;

  0032e	33 f6		 xor	 esi, esi
$LN50@PyUnicode_@62:

; 4468 :                         }
; 4469 :                     }
; 4470 :                     if (Py_UNICODE_IS_HIGH_SURROGATE(outCh)) {

  00330	8d 87 00 28 ff
	ff		 lea	 eax, DWORD PTR [rdi-55296]
  00336	3d ff 03 00 00	 cmp	 eax, 1023		; 000003ffH
  0033b	0f 87 e0 fe ff
	ff		 ja	 $LN48@PyUnicode_@62

; 4471 :                         /* first surrogate */
; 4472 :                         surrogate = outCh;

  00341	8b f7		 mov	 esi, edi

; 4473 :                     }
; 4474 :                     else {

  00343	e9 57 fd ff ff	 jmp	 $LN100@PyUnicode_@62
$LN60@PyUnicode_@62:

; 4506 :                         goto onError;
; 4507 :                 }
; 4508 :             }
; 4509 :         }
; 4510 :         else if ( ch == '+' ) {

  00348	83 ff 2b	 cmp	 edi, 43			; 0000002bH
  0034b	75 68		 jne	 SHORT $LN35@PyUnicode_@62

; 4511 :             startinpos = s-starts;

  0034d	48 8b 7d cf	 mov	 rdi, QWORD PTR starts$[rbp-153]
  00351	4c 8b f3	 mov	 r14, rbx

; 4512 :             s++; /* consume '+' */

  00354	48 ff c3	 inc	 rbx
  00357	4c 2b f7	 sub	 r14, rdi
  0035a	48 89 5d 67	 mov	 QWORD PTR s$[rbp-153], rbx
  0035e	4c 89 75 e7	 mov	 QWORD PTR startinpos$[rbp-153], r14

; 4513 :             if (s < e && *s == '-') { /* '+-' encodes '+' */

  00362	49 3b df	 cmp	 rbx, r15
  00365	73 33		 jae	 SHORT $LN34@PyUnicode_@62
  00367	80 3b 2d	 cmp	 BYTE PTR [rbx], 45	; 0000002dH
  0036a	75 2e		 jne	 SHORT $LN34@PyUnicode_@62

; 4514 :                 s++;
; 4515 :                 if (unicode_putchar(&unicode, &outpos, '+') < 0)

  0036c	48 8d 55 df	 lea	 rdx, QWORD PTR outpos$[rbp-153]
  00370	48 8d 4d d7	 lea	 rcx, QWORD PTR unicode$[rbp-153]
  00374	48 ff c3	 inc	 rbx
  00377	41 b8 2b 00 00
	00		 mov	 r8d, 43			; 0000002bH
  0037d	48 89 5d 67	 mov	 QWORD PTR s$[rbp-153], rbx
  00381	e8 00 00 00 00	 call	 unicode_putchar
  00386	85 c0		 test	 eax, eax
  00388	0f 88 ab fe ff
	ff		 js	 $onError$129327

; 4516 :                     goto onError;
; 4517 :             }
; 4518 :             else { /* begin base64-encoded section */

  0038e	8b 4d c7	 mov	 ecx, DWORD PTR inShift$1$[rbp-153]
  00391	48 8b 55 6f	 mov	 rdx, QWORD PTR size$[rbp-153]
  00395	e9 1a fd ff ff	 jmp	 $LL62@PyUnicode_@62
$LN34@PyUnicode_@62:

; 4519 :                 inShift = 1;
; 4520 :                 shiftOutStart = outpos;

  0039a	4c 8b 45 df	 mov	 r8, QWORD PTR outpos$[rbp-153]
  0039e	b9 01 00 00 00	 mov	 ecx, 1

; 4521 :                 base64bits = 0;

  003a3	45 33 e4	 xor	 r12d, r12d
  003a6	4c 89 45 0f	 mov	 QWORD PTR shiftOutStart$1$[rbp-153], r8
  003aa	89 4d c7	 mov	 DWORD PTR inShift$1$[rbp-153], ecx

; 4522 :                 base64buffer = 0;

  003ad	45 33 ed	 xor	 r13d, r13d

; 4523 :             }

  003b0	e9 ff fc ff ff	 jmp	 $LL62@PyUnicode_@62
$LN35@PyUnicode_@62:

; 4524 :         }
; 4525 :         else if (DECODE_DIRECT(ch)) { /* character decodes as itself */

  003b5	83 ff 7f	 cmp	 edi, 127		; 0000007fH
  003b8	77 24		 ja	 SHORT $LN30@PyUnicode_@62

; 4526 :             if (unicode_putchar(&unicode, &outpos, ch) < 0)

  003ba	48 8d 55 df	 lea	 rdx, QWORD PTR outpos$[rbp-153]
  003be	48 8d 4d d7	 lea	 rcx, QWORD PTR unicode$[rbp-153]
  003c2	44 8b c7	 mov	 r8d, edi
  003c5	e8 00 00 00 00	 call	 unicode_putchar
  003ca	85 c0		 test	 eax, eax
  003cc	0f 88 67 fe ff
	ff		 js	 $onError$129327

; 4527 :                 goto onError;
; 4528 :             s++;

  003d2	48 ff c3	 inc	 rbx
  003d5	48 89 5d 67	 mov	 QWORD PTR s$[rbp-153], rbx

; 4534 :             goto utf7Error;
; 4535 :         }
; 4536 :         continue;

  003d9	e9 c1 fc ff ff	 jmp	 $LN100@PyUnicode_@62
$LN30@PyUnicode_@62:

; 4529 :         }
; 4530 :         else {
; 4531 :             startinpos = s-starts;

  003de	48 8b 45 cf	 mov	 rax, QWORD PTR starts$[rbp-153]
  003e2	4c 8b f3	 mov	 r14, rbx

; 4532 :             s++;
; 4533 :             errmsg = "unexpected special character";

  003e5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BN@BOIOHCO@unexpected?5special?5character?$AA@
  003ec	4c 2b f0	 sub	 r14, rax
  003ef	48 ff c3	 inc	 rbx
  003f2	48 89 5d 67	 mov	 QWORD PTR s$[rbp-153], rbx
  003f6	4c 89 75 e7	 mov	 QWORD PTR startinpos$[rbp-153], r14
$utf7Error$129339:

; 4537 : utf7Error:
; 4538 :         endinpos = s-starts;
; 4539 :         if (unicode_decode_call_errorhandler(
; 4540 :                 errors, &errorHandler,
; 4541 :                 "utf7", errmsg,
; 4542 :                 &starts, &e, &startinpos, &endinpos, &exc, &s,
; 4543 :                 &unicode, &outpos))

  003fa	48 8b 4d 77	 mov	 rcx, QWORD PTR errors$[rbp-153]
  003fe	48 2b d8	 sub	 rbx, rax
  00401	48 8d 45 df	 lea	 rax, QWORD PTR outpos$[rbp-153]
  00405	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  0040a	48 8d 45 d7	 lea	 rax, QWORD PTR unicode$[rbp-153]
  0040e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04DAOPEHDA@utf7?$AA@
  00415	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0041a	48 8d 45 67	 lea	 rax, QWORD PTR s$[rbp-153]
  0041e	48 8d 55 ff	 lea	 rdx, QWORD PTR errorHandler$[rbp-153]
  00422	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00427	48 8d 45 ef	 lea	 rax, QWORD PTR exc$[rbp-153]
  0042b	48 89 5d 07	 mov	 QWORD PTR endinpos$[rbp-153], rbx
  0042f	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00434	48 8d 45 07	 lea	 rax, QWORD PTR endinpos$[rbp-153]
  00438	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0043d	48 8d 45 e7	 lea	 rax, QWORD PTR startinpos$[rbp-153]
  00441	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00446	48 8d 45 f7	 lea	 rax, QWORD PTR e$[rbp-153]
  0044a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0044f	48 8d 45 cf	 lea	 rax, QWORD PTR starts$[rbp-153]
  00453	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00458	e8 00 00 00 00	 call	 unicode_decode_call_errorhandler
  0045d	85 c0		 test	 eax, eax
  0045f	0f 85 d4 fd ff
	ff		 jne	 $onError$129327

; 4544 :             goto onError;
; 4545 :     }

  00465	48 8b 5d 67	 mov	 rbx, QWORD PTR s$[rbp-153]
  00469	4c 8b 7d f7	 mov	 r15, QWORD PTR e$[rbp-153]
  0046d	e9 2d fc ff ff	 jmp	 $LN100@PyUnicode_@62
$LN94@PyUnicode_@62:

; 4568 :         if (inShift) {

  00472	85 c9		 test	 ecx, ecx
  00474	74 73		 je	 SHORT $LN20@PyUnicode_@62

; 4569 :             *consumed = startinpos;
; 4570 :             if (outpos != shiftOutStart &&
; 4571 :                 PyUnicode_MAX_CHAR_VALUE(unicode) > 127) {

  00476	4c 8b 45 0f	 mov	 r8, QWORD PTR shiftOutStart$1$[rbp-153]
  0047a	4c 89 30	 mov	 QWORD PTR [rax], r14
  0047d	4c 39 45 df	 cmp	 QWORD PTR outpos$[rbp-153], r8
  00481	74 5b		 je	 SHORT $LN19@PyUnicode_@62
  00483	48 8b 7d d7	 mov	 rdi, QWORD PTR unicode$[rbp-153]
  00487	8b 57 70	 mov	 edx, DWORD PTR [rdi+112]
  0048a	f6 c2 40	 test	 dl, 64			; 00000040H
  0048d	75 4f		 jne	 SHORT $LN19@PyUnicode_@62
  0048f	8b ca		 mov	 ecx, edx
  00491	c1 e9 02	 shr	 ecx, 2
  00494	83 e1 07	 and	 ecx, 7
  00497	83 f9 01	 cmp	 ecx, 1
  0049a	74 17		 je	 SHORT $LN95@PyUnicode_@62
  0049c	83 f9 02	 cmp	 ecx, 2
  0049f	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH
  004a4	41 b9 ff ff 00
	00		 mov	 r9d, 65535		; 0000ffffH
  004aa	41 0f 44 c1	 cmove	 eax, r9d
  004ae	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  004b1	76 2b		 jbe	 SHORT $LN19@PyUnicode_@62
$LN95@PyUnicode_@62:

; 4572 :                 PyObject *result = PyUnicode_FromKindAndData(
; 4573 :                         PyUnicode_KIND(unicode), PyUnicode_DATA(unicode),
; 4574 :                         shiftOutStart);

  004b3	f6 c2 20	 test	 dl, 32			; 00000020H
  004b6	48 8d 97 a0 00
	00 00		 lea	 rdx, QWORD PTR [rdi+160]
  004bd	75 07		 jne	 SHORT $LN81@PyUnicode_@62
  004bf	48 8b 97 a0 00
	00 00		 mov	 rdx, QWORD PTR [rdi+160]
$LN81@PyUnicode_@62:
  004c6	e8 00 00 00 00	 call	 PyUnicode_FromKindAndData

; 4575 :                 Py_DECREF(unicode);

  004cb	48 8b cf	 mov	 rcx, rdi
  004ce	48 8b d8	 mov	 rbx, rax
  004d1	e8 00 00 00 00	 call	 _Py_DecRef
  004d6	4c 8b 45 0f	 mov	 r8, QWORD PTR shiftOutStart$1$[rbp-153]

; 4576 :                 unicode = result;

  004da	48 89 5d d7	 mov	 QWORD PTR unicode$[rbp-153], rbx
$LN19@PyUnicode_@62:

; 4577 :             }
; 4578 :             outpos = shiftOutStart; /* back off output */

  004de	4c 89 45 df	 mov	 QWORD PTR outpos$[rbp-153], r8

; 4579 :         }
; 4580 :         else {

  004e2	eb 0b		 jmp	 SHORT $LN18@PyUnicode_@62
$LN22@PyUnicode_@62:

; 4562 :                 goto restart;
; 4563 :         }
; 4564 :     }
; 4565 : 
; 4566 :     /* return state */
; 4567 :     if (consumed) {

  004e4	48 85 c0	 test	 rax, rax
  004e7	74 06		 je	 SHORT $LN18@PyUnicode_@62
$LN20@PyUnicode_@62:

; 4581 :             *consumed = s-starts;

  004e9	48 2b df	 sub	 rbx, rdi
  004ec	48 89 18	 mov	 QWORD PTR [rax], rbx
$LN18@PyUnicode_@62:

; 4582 :         }
; 4583 :     }
; 4584 : 
; 4585 :     if (unicode_resize(&unicode, outpos) < 0)

  004ef	48 8b 55 df	 mov	 rdx, QWORD PTR outpos$[rbp-153]
  004f3	48 8d 4d d7	 lea	 rcx, QWORD PTR unicode$[rbp-153]
  004f7	e8 00 00 00 00	 call	 unicode_resize
  004fc	85 c0		 test	 eax, eax
  004fe	0f 88 35 fd ff
	ff		 js	 $onError$129327

; 4586 :         goto onError;
; 4587 : 
; 4588 :     Py_XDECREF(errorHandler);

  00504	48 8b 4d ff	 mov	 rcx, QWORD PTR errorHandler$[rbp-153]
  00508	48 85 c9	 test	 rcx, rcx
  0050b	74 05		 je	 SHORT $LN15@PyUnicode_@62
  0050d	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@PyUnicode_@62:

; 4589 :     Py_XDECREF(exc);

  00512	48 8b 4d ef	 mov	 rcx, QWORD PTR exc$[rbp-153]
  00516	48 85 c9	 test	 rcx, rcx
  00519	74 05		 je	 SHORT $LN11@PyUnicode_@62
  0051b	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@PyUnicode_@62:

; 4590 :     return unicode_result(unicode);

  00520	48 8b 4d d7	 mov	 rcx, QWORD PTR unicode$[rbp-153]
  00524	e8 00 00 00 00	 call	 unicode_result
  00529	e9 32 fd ff ff	 jmp	 $LN66@PyUnicode_@62
PyUnicode_DecodeUTF7Stateful ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_EncodeUTF7
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_EncodeUTF7 DD imagerel $LN4
	DD	imagerel $LN4+98
	DD	imagerel $unwind$PyUnicode_EncodeUTF7
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_EncodeUTF7 DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_EncodeUTF7
_TEXT	SEGMENT
s$ = 48
size$ = 56
base64SetO$ = 64
base64WhiteSpace$ = 72
errors$ = 80
PyUnicode_EncodeUTF7 PROC				; COMDAT

; 4707 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	41 8b d9	 mov	 ebx, r9d
  00012	41 8b f0	 mov	 esi, r8d

; 4708 :     PyObject *result;
; 4709 :     PyObject *tmp = PyUnicode_FromUnicode(s, size);

  00015	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  0001a	48 8b f8	 mov	 rdi, rax

; 4710 :     if (tmp == NULL)

  0001d	48 85 c0	 test	 rax, rax
  00020	75 10		 jne	 SHORT $LN1@PyUnicode_@63

; 4715 :     return result;
; 4716 : }

  00022	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00027	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN1@PyUnicode_@63:

; 4711 :         return NULL;
; 4712 :     result = _PyUnicode_EncodeUTF7(tmp, base64SetO,
; 4713 :                                    base64WhiteSpace, errors);

  00032	4c 8b 4c 24 50	 mov	 r9, QWORD PTR errors$[rsp]
  00037	44 8b c3	 mov	 r8d, ebx
  0003a	8b d6		 mov	 edx, esi
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	e8 00 00 00 00	 call	 _PyUnicode_EncodeUTF7

; 4714 :     Py_DECREF(tmp);

  00044	48 8b cf	 mov	 rcx, rdi
  00047	48 8b d8	 mov	 rbx, rax
  0004a	e8 00 00 00 00	 call	 _Py_DecRef

; 4715 :     return result;
; 4716 : }

  0004f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00054	48 8b c3	 mov	 rax, rbx
  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5f		 pop	 rdi
  00061	c3		 ret	 0
PyUnicode_EncodeUTF7 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@HABJPGIA@ucs2lib_utf8_encoder?$AA@	; `string'
PUBLIC	??_C@_0CN@CCHPJPJC@c?3?2src?2pyparallel?2objects?2string@ ; `string'
PUBLIC	??_C@_0BH@ODBMEMBA@surrogates?5not?5allowed?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ucs2lib_utf8_encoder DD imagerel ucs2lib_utf8_encoder
	DD	imagerel ucs2lib_utf8_encoder+1345
	DD	imagerel $unwind$ucs2lib_utf8_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2lib_utf8_encoder DD 0cd901H
	DD	081d4d9H
	DD	08264d1H
	DD	0830127H
	DD	0e016f018H
	DD	07012c014H
	DD	050103011H
xdata	ENDS
;	COMDAT ??_C@_0BF@HABJPGIA@ucs2lib_utf8_encoder?$AA@
CONST	SEGMENT
??_C@_0BF@HABJPGIA@ucs2lib_utf8_encoder?$AA@ DB 'ucs2lib_utf8_encoder', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CCHPJPJC@c?3?2src?2pyparallel?2objects?2string@
CONST	SEGMENT
??_C@_0CN@CCHPJPJC@c?3?2src?2pyparallel?2objects?2string@ DB 'c:\src\pypa'
	DB	'rallel\objects\stringlib/codecs.h', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ODBMEMBA@surrogates?5not?5allowed?$AA@
CONST	SEGMENT
??_C@_0BH@ODBMEMBA@surrogates?5not?5allowed?$AA@ DB 'surrogates not allow'
	DB	'ed', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\codecs.h
CONST	ENDS
;	COMDAT ucs2lib_utf8_encoder
_TEXT	SEGMENT
exc$ = 80
errorHandler$ = 88
newpos$130240 = 96
stackbuf$ = 112
unicode$ = 1104
data$ = 1112
result$ = 1120
size$ = 1120
errors$ = 1128
ucs2lib_utf8_encoder PROC				; COMDAT

; 262  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	53		 push	 rbx
  00011	57		 push	 rdi
  00012	41 54		 push	 r12
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 8d ac 24 e8
	fc ff ff	 lea	 rbp, QWORD PTR [rsp-792]
  00020	48 81 ec 18 04
	00 00		 sub	 rsp, 1048		; 00000418H

; 263  : #define MAX_SHORT_UNICHARS 300  /* largest size we'll do on the stack */
; 264  : 
; 265  :     Py_ssize_t i;                /* index into s of next input byte */
; 266  :     PyObject *result;            /* result string object */
; 267  :     char *p;                     /* next free byte in output buffer */
; 268  :     Py_ssize_t nallocated;      /* number of result bytes allocated */
; 269  :     Py_ssize_t nneeded;            /* number of result bytes needed */
; 270  : #if STRINGLIB_SIZEOF_CHAR > 1
; 271  :     PyObject *errorHandler = NULL;

  00027	45 33 e4	 xor	 r12d, r12d
  0002a	4d 8b f8	 mov	 r15, r8
  0002d	4d 8b d1	 mov	 r10, r9
  00030	4c 8b c1	 mov	 r8, rcx
  00033	4c 89 64 24 58	 mov	 QWORD PTR errorHandler$[rsp], r12

; 272  :     PyObject *exc = NULL;

  00038	41 8b fc	 mov	 edi, r12d
  0003b	4c 89 64 24 50	 mov	 QWORD PTR exc$[rsp], r12

; 273  :     PyObject *rep = NULL;
; 274  : #endif
; 275  : #if STRINGLIB_SIZEOF_CHAR == 1
; 276  :     const Py_ssize_t max_char_size = 2;
; 277  :     char stackbuf[MAX_SHORT_UNICHARS * 2];
; 278  : #elif STRINGLIB_SIZEOF_CHAR == 2
; 279  :     const Py_ssize_t max_char_size = 3;
; 280  :     char stackbuf[MAX_SHORT_UNICHARS * 3];
; 281  : #else /*  STRINGLIB_SIZEOF_CHAR == 4 */
; 282  :     const Py_ssize_t max_char_size = 4;
; 283  :     char stackbuf[MAX_SHORT_UNICHARS * 4];
; 284  : #endif
; 285  : 
; 286  :     assert(size >= 0);
; 287  : 
; 288  :     if (size <= MAX_SHORT_UNICHARS) {

  00040	49 81 ff 2c 01
	00 00		 cmp	 r15, 300		; 0000012cH
  00047	7f 17		 jg	 SHORT $LN71@ucs2lib_ut@4

; 289  :         /* Write into the stack buffer; nallocated can't overflow.
; 290  :          * At the end, we'll allocate exactly as much heap space as it
; 291  :          * turns out we need.
; 292  :          */
; 293  :         nallocated = Py_SAFE_DOWNCAST(sizeof(stackbuf), size_t, int);
; 294  :         result = NULL;   /* will allocate after we're done */

  00049	41 8b c4	 mov	 eax, r12d
  0004c	41 be 84 03 00
	00		 mov	 r14d, 900		; 00000384H

; 295  :         p = stackbuf;

  00052	48 8d 5c 24 70	 lea	 rbx, QWORD PTR stackbuf$[rsp]
  00057	48 89 85 60 03
	00 00		 mov	 QWORD PTR result$[rbp-256], rax

; 296  :     }
; 297  :     else {

  0005e	eb 69		 jmp	 SHORT $LN70@ucs2lib_ut@4
$LN71@ucs2lib_ut@4:

; 298  :         if (size > PY_SSIZE_T_MAX / max_char_size) {

  00060	48 b8 aa aa aa
	aa aa aa aa 2a	 mov	 rax, 3074457345618258602 ; 2aaaaaaaaaaaaaaaH
  0006a	4c 3b f8	 cmp	 r15, rax
  0006d	7e 16		 jle	 SHORT $LN69@ucs2lib_ut@4

; 299  :             /* integer overflow */
; 300  :             return PyErr_NoMemory();

  0006f	e8 00 00 00 00	 call	 PyErr_NoMemory

; 445  : #endif
; 446  : 
; 447  : #undef MAX_SHORT_UNICHARS
; 448  : }

  00074	48 81 c4 18 04
	00 00		 add	 rsp, 1048		; 00000418H
  0007b	41 5f		 pop	 r15
  0007d	41 5e		 pop	 r14
  0007f	41 5c		 pop	 r12
  00081	5f		 pop	 rdi
  00082	5b		 pop	 rbx
  00083	5d		 pop	 rbp
  00084	c3		 ret	 0
$LN69@ucs2lib_ut@4:

; 301  :         }
; 302  :         /* Overallocate on the heap, and give the excess back at the end. */
; 303  :         nallocated = size * max_char_size;

  00085	4f 8d 34 7f	 lea	 r14, QWORD PTR [r15+r15*2]

; 304  :         result = PyBytes_FromStringAndSize(NULL, nallocated);

  00089	33 c9		 xor	 ecx, ecx
  0008b	49 8b d6	 mov	 rdx, r14
  0008e	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00093	48 89 85 60 03
	00 00		 mov	 QWORD PTR result$[rbp-256], rax

; 305  :         if (result == NULL)

  0009a	48 85 c0	 test	 rax, rax
  0009d	75 11		 jne	 SHORT $LN68@ucs2lib_ut@4

; 445  : #endif
; 446  : 
; 447  : #undef MAX_SHORT_UNICHARS
; 448  : }

  0009f	48 81 c4 18 04
	00 00		 add	 rsp, 1048		; 00000418H
  000a6	41 5f		 pop	 r15
  000a8	41 5e		 pop	 r14
  000aa	41 5c		 pop	 r12
  000ac	5f		 pop	 rdi
  000ad	5b		 pop	 rbx
  000ae	5d		 pop	 rbp
  000af	c3		 ret	 0
$LN68@ucs2lib_ut@4:
  000b0	48 8b 95 58 03
	00 00		 mov	 rdx, QWORD PTR data$[rbp-256]
  000b7	4c 8b 85 50 03
	00 00		 mov	 r8, QWORD PTR unicode$[rbp-256]
  000be	4c 8b 95 68 03
	00 00		 mov	 r10, QWORD PTR errors$[rbp-256]

; 306  :             return NULL;
; 307  :         p = PyBytes_AS_STRING(result);

  000c5	48 8d 58 78	 lea	 rbx, QWORD PTR [rax+120]
$LN70@ucs2lib_ut@4:

; 308  :     }
; 309  : 
; 310  :     for (i = 0; i < size;) {

  000c9	48 89 b4 24 10
	04 00 00	 mov	 QWORD PTR [rsp+1040], rsi
  000d1	4c 89 ac 24 08
	04 00 00	 mov	 QWORD PTR [rsp+1032], r13
  000d9	4d 8b ec	 mov	 r13, r12
  000dc	4d 85 ff	 test	 r15, r15
  000df	0f 8e 27 03 00
	00		 jle	 $LN66@ucs2lib_ut@4
  000e5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BH@ODBMEMBA@surrogates?5not?5allowed?$AA@
  000ec	0f 1f 40 00	 npad	 4
$LL67@ucs2lib_ut@4:

; 311  :         Py_UCS4 ch = data[i++];

  000f0	42 0f b7 0c 6a	 movzx	 ecx, WORD PTR [rdx+r13*2]
  000f5	49 ff c5	 inc	 r13

; 312  : 
; 313  :         if (ch < 0x80) {

  000f8	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  000fe	73 0a		 jae	 SHORT $LN65@ucs2lib_ut@4

; 314  :             /* Encode ASCII */
; 315  :             *p++ = (char) ch;

  00100	88 0b		 mov	 BYTE PTR [rbx], cl
  00102	48 ff c3	 inc	 rbx

; 316  : 
; 317  :         }
; 318  :         else

  00105	e9 3f 02 00 00	 jmp	 $LN27@ucs2lib_ut@4
$LN65@ucs2lib_ut@4:

; 319  : #if STRINGLIB_SIZEOF_CHAR > 1
; 320  :         if (ch < 0x0800)

  0010a	81 f9 00 08 00
	00		 cmp	 ecx, 2048		; 00000800H
  00110	73 1c		 jae	 SHORT $LN63@ucs2lib_ut@4

; 321  : #endif
; 322  :         {
; 323  :             /* Encode Latin-1 */
; 324  :             *p++ = (char)(0xc0 | (ch >> 6));

  00112	8b c1		 mov	 eax, ecx

; 325  :             *p++ = (char)(0x80 | (ch & 0x3f));

  00114	80 e1 3f	 and	 cl, 63			; 0000003fH
  00117	c1 e8 06	 shr	 eax, 6
  0011a	80 c9 80	 or	 cl, -128		; ffffffffffffff80H
  0011d	0c c0		 or	 al, -64			; ffffffffffffffc0H
  0011f	48 83 c3 02	 add	 rbx, 2
  00123	88 43 fe	 mov	 BYTE PTR [rbx-2], al
  00126	88 4b ff	 mov	 BYTE PTR [rbx-1], cl
  00129	e9 1b 02 00 00	 jmp	 $LN27@ucs2lib_ut@4
$LN63@ucs2lib_ut@4:

; 326  :         }
; 327  : #if STRINGLIB_SIZEOF_CHAR > 1
; 328  :         else if (Py_UNICODE_IS_SURROGATE(ch)) {

  0012e	8d 81 00 28 ff
	ff		 lea	 eax, DWORD PTR [rcx-55296]
  00134	3d ff 07 00 00	 cmp	 eax, 2047		; 000007ffH
  00139	0f 87 26 02 00
	00		 ja	 $LN61@ucs2lib_ut@4

; 329  :             Py_ssize_t newpos;
; 330  :             Py_ssize_t repsize, k, startpos;
; 331  :             startpos = i-1;
; 332  :             rep = unicode_encode_call_errorhandler(
; 333  :                   errors, &errorHandler, "utf-8", "surrogates not allowed",
; 334  :                   unicode, &exc, startpos, startpos+1, &newpos);

  0013f	48 8d 4c 24 60	 lea	 rcx, QWORD PTR newpos$130240[rsp]
  00144	49 8d 45 ff	 lea	 rax, QWORD PTR [r13-1]
  00148	48 8d 54 24 58	 lea	 rdx, QWORD PTR errorHandler$[rsp]
  0014d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00152	4c 89 6c 24 38	 mov	 QWORD PTR [rsp+56], r13
  00157	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0015c	48 8d 44 24 50	 lea	 rax, QWORD PTR exc$[rsp]
  00161	49 8b ca	 mov	 rcx, r10
  00164	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00169	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  0016e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  00175	e8 00 00 00 00	 call	 unicode_encode_call_errorhandler
  0017a	48 8b f0	 mov	 rsi, rax

; 335  :             if (!rep)

  0017d	48 85 c0	 test	 rax, rax
  00180	0f 84 3f 02 00
	00		 je	 $LN15@ucs2lib_ut@4

; 336  :                 goto error;
; 337  : 
; 338  :             if (PyBytes_Check(rep))
; 339  :                 repsize = PyBytes_GET_SIZE(rep);

  00186	48 8b 78 60	 mov	 rdi, QWORD PTR [rax+96]
  0018a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]

; 340  :             else
; 341  :                 repsize = PyUnicode_GET_LENGTH(rep);
; 342  : 
; 343  :             if (repsize > max_char_size) {

  0018e	48 83 ff 03	 cmp	 rdi, 3
  00192	0f 8e b4 00 00
	00		 jle	 $LN57@ucs2lib_ut@4

; 344  :                 Py_ssize_t offset;
; 345  : 
; 346  :                 if (result == NULL)

  00198	48 8b 8d 60 03
	00 00		 mov	 rcx, QWORD PTR result$[rbp-256]
  0019f	48 85 c9	 test	 rcx, rcx
  001a2	75 0a		 jne	 SHORT $LN56@ucs2lib_ut@4

; 347  :                     offset = p - stackbuf;

  001a4	48 8d 44 24 70	 lea	 rax, QWORD PTR stackbuf$[rsp]
  001a9	48 2b d8	 sub	 rbx, rax

; 348  :                 else

  001ac	eb 07		 jmp	 SHORT $LN55@ucs2lib_ut@4
$LN56@ucs2lib_ut@4:

; 349  :                     offset = p - PyBytes_AS_STRING(result);

  001ae	48 2b d9	 sub	 rbx, rcx
  001b1	48 83 eb 78	 sub	 rbx, 120		; 00000078H
$LN55@ucs2lib_ut@4:

; 350  : 
; 351  :                 if (nallocated > PY_SSIZE_T_MAX - repsize + max_char_size) {

  001b5	48 b8 02 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775806 ; 8000000000000002H
  001bf	48 2b c7	 sub	 rax, rdi
  001c2	4c 3b f0	 cmp	 r14, rax
  001c5	0f 8f be 01 00
	00		 jg	 $LN112@ucs2lib_ut@4

; 355  :                 }
; 356  :                 nallocated += repsize - max_char_size;

  001cb	4d 8d 74 3e fd	 lea	 r14, QWORD PTR [r14+rdi-3]

; 357  :                 if (result != NULL) {
; 358  :                     if (_PyBytes_Resize(&result, nallocated) < 0)

  001d0	49 8b d6	 mov	 rdx, r14
  001d3	48 85 c9	 test	 rcx, rcx
  001d6	74 16		 je	 SHORT $LN53@ucs2lib_ut@4
  001d8	48 8d 8d 60 03
	00 00		 lea	 rcx, QWORD PTR result$[rbp-256]
  001df	e8 00 00 00 00	 call	 _PyBytes_Resize
  001e4	85 c0		 test	 eax, eax
  001e6	0f 88 d1 01 00
	00		 js	 $error$130246

; 359  :                         goto error;
; 360  :                 } else {

  001ec	eb 52		 jmp	 SHORT $LN126@ucs2lib_ut@4
$LN53@ucs2lib_ut@4:

; 361  :                     result = PyBytes_FromStringAndSize(NULL, nallocated);

  001ee	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  001f3	48 89 85 60 03
	00 00		 mov	 QWORD PTR result$[rbp-256], rax

; 362  :                     if (result == NULL)

  001fa	48 85 c0	 test	 rax, rax
  001fd	0f 84 ba 01 00
	00		 je	 $error$130246

; 363  :                         goto error;
; 364  :                     Py_MEMCPY(PyBytes_AS_STRING(result), stackbuf, offset);

  00203	48 8d 48 78	 lea	 rcx, QWORD PTR [rax+120]
  00207	48 83 fb 10	 cmp	 rbx, 16
  0020b	72 0f		 jb	 SHORT $LN46@ucs2lib_ut@4
  0020d	48 8d 54 24 70	 lea	 rdx, QWORD PTR stackbuf$[rsp]
  00212	4c 8b c3	 mov	 r8, rbx
  00215	e8 00 00 00 00	 call	 memcpy
  0021a	eb 24		 jmp	 SHORT $LN126@ucs2lib_ut@4
$LN46@ucs2lib_ut@4:
  0021c	48 85 db	 test	 rbx, rbx
  0021f	74 26		 je	 SHORT $LN47@ucs2lib_ut@4
  00221	4c 8d 44 24 70	 lea	 r8, QWORD PTR stackbuf$[rsp]
  00226	48 8b d3	 mov	 rdx, rbx
  00229	4c 2b c1	 sub	 r8, rcx
  0022c	0f 1f 40 00	 npad	 4
$LL44@ucs2lib_ut@4:
  00230	41 0f b6 04 08	 movzx	 eax, BYTE PTR [r8+rcx]
  00235	48 ff c1	 inc	 rcx
  00238	48 ff ca	 dec	 rdx
  0023b	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0023e	75 f0		 jne	 SHORT $LL44@ucs2lib_ut@4
$LN126@ucs2lib_ut@4:
  00240	48 8b 85 60 03
	00 00		 mov	 rax, QWORD PTR result$[rbp-256]
$LN47@ucs2lib_ut@4:

; 365  :                 }
; 366  :                 p = PyBytes_AS_STRING(result) + offset;

  00247	48 8d 5c 03 78	 lea	 rbx, QWORD PTR [rbx+rax+120]
$LN57@ucs2lib_ut@4:

; 367  :             }
; 368  : 
; 369  :             if (PyBytes_Check(rep)) {

  0024c	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00250	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  0025a	74 2c		 je	 SHORT $LN41@ucs2lib_ut@4

; 370  :                 char *prep = PyBytes_AS_STRING(rep);
; 371  :                 for(k = repsize; k > 0; k--)

  0025c	48 85 ff	 test	 rdi, rdi
  0025f	0f 8e a6 00 00
	00		 jle	 $LN31@ucs2lib_ut@4
  00265	48 8b ce	 mov	 rcx, rsi
  00268	48 2b cb	 sub	 rcx, rbx
  0026b	0f 1f 44 00 00	 npad	 5
$LL40@ucs2lib_ut@4:

; 372  :                     *p++ = *prep++;

  00270	0f b6 44 19 78	 movzx	 eax, BYTE PTR [rcx+rbx+120]
  00275	48 ff cf	 dec	 rdi
  00278	48 ff c3	 inc	 rbx
  0027b	88 43 ff	 mov	 BYTE PTR [rbx-1], al
  0027e	48 85 ff	 test	 rdi, rdi
  00281	7f ed		 jg	 SHORT $LL40@ucs2lib_ut@4

; 373  :             } else /* rep is unicode */ {

  00283	e9 83 00 00 00	 jmp	 $LN31@ucs2lib_ut@4
$LN41@ucs2lib_ut@4:

; 374  :                 enum PyUnicode_Kind repkind;
; 375  :                 void *repdata;
; 376  : 
; 377  :                 if (PyUnicode_READY(rep) < 0)

  00288	f6 46 70 80	 test	 BYTE PTR [rsi+112], 128	; 00000080H
  0028c	75 10		 jne	 SHORT $LN119@ucs2lib_ut@4
  0028e	48 8b ce	 mov	 rcx, rsi
  00291	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00296	85 c0		 test	 eax, eax
  00298	0f 88 1f 01 00
	00		 js	 $error$130246
$LN119@ucs2lib_ut@4:

; 378  :                     goto error;
; 379  :                 repkind = PyUnicode_KIND(rep);

  0029e	8b 46 70	 mov	 eax, DWORD PTR [rsi+112]
  002a1	44 8b c0	 mov	 r8d, eax
  002a4	41 c1 e8 02	 shr	 r8d, 2
  002a8	41 83 e0 07	 and	 r8d, 7

; 380  :                 repdata = PyUnicode_DATA(rep);

  002ac	a8 20		 test	 al, 32			; 00000020H
  002ae	74 16		 je	 SHORT $LN78@ucs2lib_ut@4
  002b0	a8 40		 test	 al, 64			; 00000040H
  002b2	74 09		 je	 SHORT $LN76@ucs2lib_ut@4
  002b4	48 8d 96 80 00
	00 00		 lea	 rdx, QWORD PTR [rsi+128]
  002bb	eb 10		 jmp	 SHORT $LN79@ucs2lib_ut@4
$LN76@ucs2lib_ut@4:
  002bd	48 8d 96 a0 00
	00 00		 lea	 rdx, QWORD PTR [rsi+160]
  002c4	eb 07		 jmp	 SHORT $LN79@ucs2lib_ut@4
$LN78@ucs2lib_ut@4:
  002c6	48 8b 96 a0 00
	00 00		 mov	 rdx, QWORD PTR [rsi+160]
$LN79@ucs2lib_ut@4:

; 381  : 
; 382  :                 for(k=0; k<repsize; k++) {

  002cd	49 8b cc	 mov	 rcx, r12

; 383  :                     Py_UCS4 c = PyUnicode_READ(repkind, repdata, k);

  002d0	4d 63 c8	 movsxd	 r9, r8d
  002d3	48 85 ff	 test	 rdi, rdi
  002d6	7e 33		 jle	 SHORT $LN31@ucs2lib_ut@4
$LL35@ucs2lib_ut@4:
  002d8	49 83 f9 01	 cmp	 r9, 1
  002dc	75 06		 jne	 SHORT $LN82@ucs2lib_ut@4
  002de	0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+rcx]
  002e2	eb 0f		 jmp	 SHORT $LN81@ucs2lib_ut@4
$LN82@ucs2lib_ut@4:
  002e4	49 83 f9 02	 cmp	 r9, 2
  002e8	75 06		 jne	 SHORT $LN80@ucs2lib_ut@4
  002ea	0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+rcx*2]
  002ee	eb 03		 jmp	 SHORT $LN81@ucs2lib_ut@4
$LN80@ucs2lib_ut@4:
  002f0	8b 04 8a	 mov	 eax, DWORD PTR [rdx+rcx*4]
$LN81@ucs2lib_ut@4:

; 384  :                     if (0x80 <= c) {

  002f3	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  002f8	0f 83 92 00 00
	00		 jae	 $LN110@ucs2lib_ut@4

; 389  :                         goto error;
; 390  :                     }
; 391  :                     *p++ = (char)c;

  002fe	48 ff c1	 inc	 rcx
  00301	88 03		 mov	 BYTE PTR [rbx], al
  00303	48 ff c3	 inc	 rbx
  00306	48 3b cf	 cmp	 rcx, rdi
  00309	7c cd		 jl	 SHORT $LL35@ucs2lib_ut@4
$LN31@ucs2lib_ut@4:

; 392  :                 }
; 393  :             }
; 394  :             Py_CLEAR(rep);

  0030b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@CCHPJPJC@c?3?2src?2pyparallel?2objects?2string@
  00312	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@HABJPGIA@ucs2lib_utf8_encoder?$AA@
  00319	4c 8b ce	 mov	 r9, rsi
  0031c	41 b8 8a 01 00
	00		 mov	 r8d, 394		; 0000018aH
  00322	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0032a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0032f	85 c0		 test	 eax, eax
  00331	75 08		 jne	 SHORT $LN123@ucs2lib_ut@4
  00333	48 8b ce	 mov	 rcx, rsi
  00336	e8 00 00 00 00	 call	 _Py_DecRef
$LN123@ucs2lib_ut@4:

; 262  : {

  0033b	48 8b 95 58 03
	00 00		 mov	 rdx, QWORD PTR data$[rbp-256]
  00342	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BH@ODBMEMBA@surrogates?5not?5allowed?$AA@
$LN27@ucs2lib_ut@4:

; 308  :     }
; 309  : 
; 310  :     for (i = 0; i < size;) {

  00349	4d 3b ef	 cmp	 r13, r15
  0034c	0f 8d a9 00 00
	00		 jge	 $LN122@ucs2lib_ut@4
  00352	4c 8b 85 50 03
	00 00		 mov	 r8, QWORD PTR unicode$[rbp-256]
  00359	4c 8b 95 68 03
	00 00		 mov	 r10, QWORD PTR errors$[rbp-256]
  00360	e9 8b fd ff ff	 jmp	 $LL67@ucs2lib_ut@4
$LN61@ucs2lib_ut@4:

; 395  :         }
; 396  :         else
; 397  : #if STRINGLIB_SIZEOF_CHAR > 2
; 398  :         if (ch < 0x10000)
; 399  : #endif
; 400  :         {
; 401  :             *p++ = (char)(0xe0 | (ch >> 12));

  00365	8b c1		 mov	 eax, ecx
  00367	c1 e8 0c	 shr	 eax, 12
  0036a	0c e0		 or	 al, -32			; ffffffffffffffe0H
  0036c	88 03		 mov	 BYTE PTR [rbx], al

; 402  :             *p++ = (char)(0x80 | ((ch >> 6) & 0x3f));

  0036e	8b c1		 mov	 eax, ecx

; 403  :             *p++ = (char)(0x80 | (ch & 0x3f));

  00370	80 e1 3f	 and	 cl, 63			; 0000003fH
  00373	c1 e8 06	 shr	 eax, 6
  00376	80 c9 80	 or	 cl, -128		; ffffffffffffff80H
  00379	24 3f		 and	 al, 63			; 0000003fH
  0037b	0c 80		 or	 al, -128		; ffffffffffffff80H
  0037d	48 83 c3 03	 add	 rbx, 3
  00381	88 43 fe	 mov	 BYTE PTR [rbx-2], al
  00384	88 4b ff	 mov	 BYTE PTR [rbx-1], cl
  00387	eb c0		 jmp	 SHORT $LN27@ucs2lib_ut@4
$LN112@ucs2lib_ut@4:

; 352  :                     /* integer overflow */
; 353  :                     PyErr_NoMemory();

  00389	e8 00 00 00 00	 call	 PyErr_NoMemory

; 354  :                     goto error;

  0038e	eb 2d		 jmp	 SHORT $error$130246
$LN110@ucs2lib_ut@4:

; 385  :                         raise_encode_exception(&exc, "utf-8",
; 386  :                                                unicode,
; 387  :                                                i-1, i,
; 388  :                                                "surrogates not allowed");

  00390	4c 8b 85 50 03
	00 00		 mov	 r8, QWORD PTR unicode$[rbp-256]
  00397	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@ODBMEMBA@surrogates?5not?5allowed?$AA@
  0039e	4d 8d 4d ff	 lea	 r9, QWORD PTR [r13-1]
  003a2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  003ae	48 8d 4c 24 50	 lea	 rcx, QWORD PTR exc$[rsp]
  003b3	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  003b8	e8 00 00 00 00	 call	 raise_encode_exception
$error$130246:

; 437  : 
; 438  : #if STRINGLIB_SIZEOF_CHAR > 1
; 439  :  error:
; 440  :     Py_XDECREF(rep);

  003bd	48 8b ce	 mov	 rcx, rsi
  003c0	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@ucs2lib_ut@4:

; 441  :     Py_XDECREF(errorHandler);

  003c5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR errorHandler$[rsp]
  003ca	48 85 c9	 test	 rcx, rcx
  003cd	74 05		 je	 SHORT $LN11@ucs2lib_ut@4
  003cf	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@ucs2lib_ut@4:

; 442  :     Py_XDECREF(exc);

  003d4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR exc$[rsp]
  003d9	48 85 c9	 test	 rcx, rcx
  003dc	74 05		 je	 SHORT $LN7@ucs2lib_ut@4
  003de	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@ucs2lib_ut@4:

; 443  :     Py_XDECREF(result);

  003e3	48 8b 8d 60 03
	00 00		 mov	 rcx, QWORD PTR result$[rbp-256]
  003ea	48 85 c9	 test	 rcx, rcx
  003ed	74 05		 je	 SHORT $LN3@ucs2lib_ut@4
  003ef	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@ucs2lib_ut@4:

; 444  :     return NULL;

  003f4	33 c0		 xor	 eax, eax
  003f6	e9 25 01 00 00	 jmp	 $LN125@ucs2lib_ut@4
$LN122@ucs2lib_ut@4:

; 374  :                 enum PyUnicode_Kind repkind;
; 375  :                 void *repdata;
; 376  : 
; 377  :                 if (PyUnicode_READY(rep) < 0)

  003fb	4c 8b 64 24 58	 mov	 r12, QWORD PTR errorHandler$[rsp]
  00400	48 8b 7c 24 50	 mov	 rdi, QWORD PTR exc$[rsp]
  00405	48 8b 85 60 03
	00 00		 mov	 rax, QWORD PTR result$[rbp-256]
$LN66@ucs2lib_ut@4:

; 404  :         }
; 405  : #if STRINGLIB_SIZEOF_CHAR > 2
; 406  :         else /* ch >= 0x10000 */
; 407  :         {
; 408  :             assert(ch <= MAX_UNICODE);
; 409  :             /* Encode UCS4 Unicode ordinals */
; 410  :             *p++ = (char)(0xf0 | (ch >> 18));
; 411  :             *p++ = (char)(0x80 | ((ch >> 12) & 0x3f));
; 412  :             *p++ = (char)(0x80 | ((ch >> 6) & 0x3f));
; 413  :             *p++ = (char)(0x80 | (ch & 0x3f));
; 414  :         }
; 415  : #endif /* STRINGLIB_SIZEOF_CHAR > 2 */
; 416  : #endif /* STRINGLIB_SIZEOF_CHAR > 1 */
; 417  :     }
; 418  : 
; 419  :     if (result == NULL) {

  0040c	48 85 c0	 test	 rax, rax
  0040f	75 1e		 jne	 SHORT $LN26@ucs2lib_ut@4

; 420  :         /* This was stack allocated. */
; 421  :         nneeded = p - stackbuf;

  00411	48 8d 44 24 70	 lea	 rax, QWORD PTR stackbuf$[rsp]

; 422  :         assert(nneeded <= nallocated);
; 423  :         result = PyBytes_FromStringAndSize(stackbuf, nneeded);

  00416	48 8d 4c 24 70	 lea	 rcx, QWORD PTR stackbuf$[rsp]
  0041b	48 2b d8	 sub	 rbx, rax
  0041e	48 8b d3	 mov	 rdx, rbx
  00421	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00426	48 89 85 60 03
	00 00		 mov	 QWORD PTR result$[rbp-256], rax

; 424  :     }
; 425  :     else {

  0042d	eb 13		 jmp	 SHORT $LN24@ucs2lib_ut@4
$LN26@ucs2lib_ut@4:

; 426  :         /* Cut back to size actually needed. */
; 427  :         nneeded = p - PyBytes_AS_STRING(result);
; 428  :         assert(nneeded <= nallocated);
; 429  :         _PyBytes_Resize(&result, nneeded);

  0042f	48 2b d8	 sub	 rbx, rax
  00432	48 8d 8d 60 03
	00 00		 lea	 rcx, QWORD PTR result$[rbp-256]
  00439	48 8d 53 88	 lea	 rdx, QWORD PTR [rbx-120]
  0043d	e8 00 00 00 00	 call	 _PyBytes_Resize
$LN24@ucs2lib_ut@4:

; 430  :     }
; 431  : 
; 432  : #if STRINGLIB_SIZEOF_CHAR > 1
; 433  :     Py_XDECREF(errorHandler);

  00442	4d 85 e4	 test	 r12, r12
  00445	74 68		 je	 SHORT $LN23@ucs2lib_ut@4
  00447	e8 00 00 00 00	 call	 _Py_PXCTX
  0044c	85 c0		 test	 eax, eax
  0044e	75 5f		 jne	 SHORT $LN23@ucs2lib_ut@4
  00450	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  00455	a8 20		 test	 al, 32			; 00000020H
  00457	75 4e		 jne	 SHORT $LN88@ucs2lib_ut@4
  00459	84 c0		 test	 al, al
  0045b	78 4a		 js	 SHORT $LN88@ucs2lib_ut@4
  0045d	a8 02		 test	 al, 2
  0045f	75 4e		 jne	 SHORT $LN23@ucs2lib_ut@4
  00461	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  00466	75 47		 jne	 SHORT $LN23@ucs2lib_ut@4
  00468	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0046f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00476	4d 8b cc	 mov	 r9, r12
  00479	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0047f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00487	e8 00 00 00 00	 call	 _PyParallel_Guard
  0048c	49 8b cc	 mov	 rcx, r12
  0048f	85 c0		 test	 eax, eax
  00491	74 07		 je	 SHORT $LN93@ucs2lib_ut@4
  00493	e8 00 00 00 00	 call	 _Px_Dealloc
  00498	eb 15		 jmp	 SHORT $LN23@ucs2lib_ut@4
$LN93@ucs2lib_ut@4:
  0049a	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  0049f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  004a5	eb 08		 jmp	 SHORT $LN23@ucs2lib_ut@4
$LN88@ucs2lib_ut@4:
  004a7	49 8b cc	 mov	 rcx, r12
  004aa	e8 00 00 00 00	 call	 Px_DecRef
$LN23@ucs2lib_ut@4:

; 434  :     Py_XDECREF(exc);

  004af	48 85 ff	 test	 rdi, rdi
  004b2	74 65		 je	 SHORT $LN19@ucs2lib_ut@4
  004b4	e8 00 00 00 00	 call	 _Py_PXCTX
  004b9	85 c0		 test	 eax, eax
  004bb	75 5c		 jne	 SHORT $LN19@ucs2lib_ut@4
  004bd	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  004c1	a8 20		 test	 al, 32			; 00000020H
  004c3	75 4c		 jne	 SHORT $LN99@ucs2lib_ut@4
  004c5	84 c0		 test	 al, al
  004c7	78 48		 js	 SHORT $LN99@ucs2lib_ut@4
  004c9	a8 02		 test	 al, 2
  004cb	75 4c		 jne	 SHORT $LN19@ucs2lib_ut@4
  004cd	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  004d1	75 46		 jne	 SHORT $LN19@ucs2lib_ut@4
  004d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  004da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  004e1	4c 8b cf	 mov	 r9, rdi
  004e4	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  004ea	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004f2	e8 00 00 00 00	 call	 _PyParallel_Guard
  004f7	48 8b cf	 mov	 rcx, rdi
  004fa	85 c0		 test	 eax, eax
  004fc	74 07		 je	 SHORT $LN104@ucs2lib_ut@4
  004fe	e8 00 00 00 00	 call	 _Px_Dealloc
  00503	eb 14		 jmp	 SHORT $LN19@ucs2lib_ut@4
$LN104@ucs2lib_ut@4:
  00505	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00509	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0050f	eb 08		 jmp	 SHORT $LN19@ucs2lib_ut@4
$LN99@ucs2lib_ut@4:
  00511	48 8b cf	 mov	 rcx, rdi
  00514	e8 00 00 00 00	 call	 Px_DecRef
$LN19@ucs2lib_ut@4:

; 435  : #endif
; 436  :     return result;

  00519	48 8b 85 60 03
	00 00		 mov	 rax, QWORD PTR result$[rbp-256]
$LN125@ucs2lib_ut@4:
  00520	48 8b b4 24 10
	04 00 00	 mov	 rsi, QWORD PTR [rsp+1040]
  00528	4c 8b ac 24 08
	04 00 00	 mov	 r13, QWORD PTR [rsp+1032]

; 445  : #endif
; 446  : 
; 447  : #undef MAX_SHORT_UNICHARS
; 448  : }

  00530	48 81 c4 18 04
	00 00		 add	 rsp, 1048		; 00000418H
  00537	41 5f		 pop	 r15
  00539	41 5e		 pop	 r14
  0053b	41 5c		 pop	 r12
  0053d	5f		 pop	 rdi
  0053e	5b		 pop	 rbx
  0053f	5d		 pop	 rbp
  00540	c3		 ret	 0
ucs2lib_utf8_encoder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@HOGFEKAF@ucs4lib_utf8_encoder?$AA@	; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ucs4lib_utf8_encoder DD imagerel ucs4lib_utf8_encoder
	DD	imagerel ucs4lib_utf8_encoder+1399
	DD	imagerel $unwind$ucs4lib_utf8_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs4lib_utf8_encoder DD 0cdd01H
	DD	0a5d4ddH
	DD	0a664d5H
	DD	0a70127H
	DD	0e016f018H
	DD	07012c014H
	DD	050103011H
xdata	ENDS
;	COMDAT ??_C@_0BF@HOGFEKAF@ucs4lib_utf8_encoder?$AA@
CONST	SEGMENT
??_C@_0BF@HOGFEKAF@ucs4lib_utf8_encoder?$AA@ DB 'ucs4lib_utf8_encoder', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\codecs.h
CONST	ENDS
;	COMDAT ucs4lib_utf8_encoder
_TEXT	SEGMENT
exc$ = 80
errorHandler$ = 88
newpos$130642 = 96
stackbuf$ = 112
unicode$ = 1392
data$ = 1400
result$ = 1408
size$ = 1408
errors$ = 1416
ucs4lib_utf8_encoder PROC				; COMDAT

; 262  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	53		 push	 rbx
  00011	57		 push	 rdi
  00012	41 54		 push	 r12
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 8d ac 24 c8
	fb ff ff	 lea	 rbp, QWORD PTR [rsp-1080]
  00020	48 81 ec 38 05
	00 00		 sub	 rsp, 1336		; 00000538H

; 263  : #define MAX_SHORT_UNICHARS 300  /* largest size we'll do on the stack */
; 264  : 
; 265  :     Py_ssize_t i;                /* index into s of next input byte */
; 266  :     PyObject *result;            /* result string object */
; 267  :     char *p;                     /* next free byte in output buffer */
; 268  :     Py_ssize_t nallocated;      /* number of result bytes allocated */
; 269  :     Py_ssize_t nneeded;            /* number of result bytes needed */
; 270  : #if STRINGLIB_SIZEOF_CHAR > 1
; 271  :     PyObject *errorHandler = NULL;

  00027	45 33 e4	 xor	 r12d, r12d
  0002a	4d 8b f8	 mov	 r15, r8
  0002d	4d 8b d1	 mov	 r10, r9
  00030	4c 8b c1	 mov	 r8, rcx
  00033	4c 89 64 24 58	 mov	 QWORD PTR errorHandler$[rsp], r12

; 272  :     PyObject *exc = NULL;

  00038	41 8b fc	 mov	 edi, r12d
  0003b	4c 89 64 24 50	 mov	 QWORD PTR exc$[rsp], r12

; 273  :     PyObject *rep = NULL;
; 274  : #endif
; 275  : #if STRINGLIB_SIZEOF_CHAR == 1
; 276  :     const Py_ssize_t max_char_size = 2;
; 277  :     char stackbuf[MAX_SHORT_UNICHARS * 2];
; 278  : #elif STRINGLIB_SIZEOF_CHAR == 2
; 279  :     const Py_ssize_t max_char_size = 3;
; 280  :     char stackbuf[MAX_SHORT_UNICHARS * 3];
; 281  : #else /*  STRINGLIB_SIZEOF_CHAR == 4 */
; 282  :     const Py_ssize_t max_char_size = 4;
; 283  :     char stackbuf[MAX_SHORT_UNICHARS * 4];
; 284  : #endif
; 285  : 
; 286  :     assert(size >= 0);
; 287  : 
; 288  :     if (size <= MAX_SHORT_UNICHARS) {

  00040	49 81 ff 2c 01
	00 00		 cmp	 r15, 300		; 0000012cH
  00047	7f 17		 jg	 SHORT $LN73@ucs4lib_ut@4

; 289  :         /* Write into the stack buffer; nallocated can't overflow.
; 290  :          * At the end, we'll allocate exactly as much heap space as it
; 291  :          * turns out we need.
; 292  :          */
; 293  :         nallocated = Py_SAFE_DOWNCAST(sizeof(stackbuf), size_t, int);
; 294  :         result = NULL;   /* will allocate after we're done */

  00049	41 8b c4	 mov	 eax, r12d
  0004c	41 be b0 04 00
	00		 mov	 r14d, 1200		; 000004b0H

; 295  :         p = stackbuf;

  00052	48 8d 5c 24 70	 lea	 rbx, QWORD PTR stackbuf$[rsp]
  00057	48 89 85 80 04
	00 00		 mov	 QWORD PTR result$[rbp-256], rax

; 296  :     }
; 297  :     else {

  0005e	eb 6d		 jmp	 SHORT $LN72@ucs4lib_ut@4
$LN73@ucs4lib_ut@4:

; 298  :         if (size > PY_SSIZE_T_MAX / max_char_size) {

  00060	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  0006a	4c 3b f8	 cmp	 r15, rax
  0006d	7e 16		 jle	 SHORT $LN71@ucs4lib_ut@4

; 299  :             /* integer overflow */
; 300  :             return PyErr_NoMemory();

  0006f	e8 00 00 00 00	 call	 PyErr_NoMemory

; 445  : #endif
; 446  : 
; 447  : #undef MAX_SHORT_UNICHARS
; 448  : }

  00074	48 81 c4 38 05
	00 00		 add	 rsp, 1336		; 00000538H
  0007b	41 5f		 pop	 r15
  0007d	41 5e		 pop	 r14
  0007f	41 5c		 pop	 r12
  00081	5f		 pop	 rdi
  00082	5b		 pop	 rbx
  00083	5d		 pop	 rbp
  00084	c3		 ret	 0
$LN71@ucs4lib_ut@4:

; 301  :         }
; 302  :         /* Overallocate on the heap, and give the excess back at the end. */
; 303  :         nallocated = size * max_char_size;

  00085	4e 8d 34 bd 00
	00 00 00	 lea	 r14, QWORD PTR [r15*4]

; 304  :         result = PyBytes_FromStringAndSize(NULL, nallocated);

  0008d	33 c9		 xor	 ecx, ecx
  0008f	49 8b d6	 mov	 rdx, r14
  00092	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00097	48 89 85 80 04
	00 00		 mov	 QWORD PTR result$[rbp-256], rax

; 305  :         if (result == NULL)

  0009e	48 85 c0	 test	 rax, rax
  000a1	75 11		 jne	 SHORT $LN70@ucs4lib_ut@4

; 445  : #endif
; 446  : 
; 447  : #undef MAX_SHORT_UNICHARS
; 448  : }

  000a3	48 81 c4 38 05
	00 00		 add	 rsp, 1336		; 00000538H
  000aa	41 5f		 pop	 r15
  000ac	41 5e		 pop	 r14
  000ae	41 5c		 pop	 r12
  000b0	5f		 pop	 rdi
  000b1	5b		 pop	 rbx
  000b2	5d		 pop	 rbp
  000b3	c3		 ret	 0
$LN70@ucs4lib_ut@4:
  000b4	48 8b 95 78 04
	00 00		 mov	 rdx, QWORD PTR data$[rbp-256]
  000bb	4c 8b 85 70 04
	00 00		 mov	 r8, QWORD PTR unicode$[rbp-256]
  000c2	4c 8b 95 88 04
	00 00		 mov	 r10, QWORD PTR errors$[rbp-256]

; 306  :             return NULL;
; 307  :         p = PyBytes_AS_STRING(result);

  000c9	48 8d 58 78	 lea	 rbx, QWORD PTR [rax+120]
$LN72@ucs4lib_ut@4:

; 308  :     }
; 309  : 
; 310  :     for (i = 0; i < size;) {

  000cd	48 89 b4 24 30
	05 00 00	 mov	 QWORD PTR [rsp+1328], rsi
  000d5	4c 89 ac 24 28
	05 00 00	 mov	 QWORD PTR [rsp+1320], r13
  000dd	4d 8b ec	 mov	 r13, r12
  000e0	4d 85 ff	 test	 r15, r15
  000e3	0f 8e 59 03 00
	00		 jle	 $LN68@ucs4lib_ut@4
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BH@ODBMEMBA@surrogates?5not?5allowed?$AA@
$LL69@ucs4lib_ut@4:

; 311  :         Py_UCS4 ch = data[i++];

  000f0	42 8b 0c aa	 mov	 ecx, DWORD PTR [rdx+r13*4]
  000f4	49 ff c5	 inc	 r13

; 312  : 
; 313  :         if (ch < 0x80) {

  000f7	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  000fd	73 0a		 jae	 SHORT $LN67@ucs4lib_ut@4

; 314  :             /* Encode ASCII */
; 315  :             *p++ = (char) ch;

  000ff	88 0b		 mov	 BYTE PTR [rbx], cl
  00101	48 ff c3	 inc	 rbx

; 316  : 
; 317  :         }
; 318  :         else

  00104	e9 40 02 00 00	 jmp	 $LN27@ucs4lib_ut@4
$LN67@ucs4lib_ut@4:

; 319  : #if STRINGLIB_SIZEOF_CHAR > 1
; 320  :         if (ch < 0x0800)

  00109	81 f9 00 08 00
	00		 cmp	 ecx, 2048		; 00000800H
  0010f	73 1c		 jae	 SHORT $LN65@ucs4lib_ut@4

; 321  : #endif
; 322  :         {
; 323  :             /* Encode Latin-1 */
; 324  :             *p++ = (char)(0xc0 | (ch >> 6));

  00111	8b c1		 mov	 eax, ecx

; 325  :             *p++ = (char)(0x80 | (ch & 0x3f));

  00113	80 e1 3f	 and	 cl, 63			; 0000003fH
  00116	c1 e8 06	 shr	 eax, 6
  00119	80 c9 80	 or	 cl, -128		; ffffffffffffff80H
  0011c	0c c0		 or	 al, -64			; ffffffffffffffc0H
  0011e	48 83 c3 02	 add	 rbx, 2
  00122	88 43 fe	 mov	 BYTE PTR [rbx-2], al
  00125	88 4b ff	 mov	 BYTE PTR [rbx-1], cl
  00128	e9 1c 02 00 00	 jmp	 $LN27@ucs4lib_ut@4
$LN65@ucs4lib_ut@4:

; 326  :         }
; 327  : #if STRINGLIB_SIZEOF_CHAR > 1
; 328  :         else if (Py_UNICODE_IS_SURROGATE(ch)) {

  0012d	8d 81 00 28 ff
	ff		 lea	 eax, DWORD PTR [rcx-55296]
  00133	3d ff 07 00 00	 cmp	 eax, 2047		; 000007ffH
  00138	0f 87 27 02 00
	00		 ja	 $LN63@ucs4lib_ut@4

; 329  :             Py_ssize_t newpos;
; 330  :             Py_ssize_t repsize, k, startpos;
; 331  :             startpos = i-1;
; 332  :             rep = unicode_encode_call_errorhandler(
; 333  :                   errors, &errorHandler, "utf-8", "surrogates not allowed",
; 334  :                   unicode, &exc, startpos, startpos+1, &newpos);

  0013e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR newpos$130642[rsp]
  00143	49 8d 45 ff	 lea	 rax, QWORD PTR [r13-1]
  00147	48 8d 54 24 58	 lea	 rdx, QWORD PTR errorHandler$[rsp]
  0014c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00151	4c 89 6c 24 38	 mov	 QWORD PTR [rsp+56], r13
  00156	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0015b	48 8d 44 24 50	 lea	 rax, QWORD PTR exc$[rsp]
  00160	49 8b ca	 mov	 rcx, r10
  00163	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00168	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  0016d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  00174	e8 00 00 00 00	 call	 unicode_encode_call_errorhandler
  00179	48 8b f0	 mov	 rsi, rax

; 335  :             if (!rep)

  0017c	48 85 c0	 test	 rax, rax
  0017f	0f 84 76 02 00
	00		 je	 $LN15@ucs4lib_ut@4

; 336  :                 goto error;
; 337  : 
; 338  :             if (PyBytes_Check(rep))
; 339  :                 repsize = PyBytes_GET_SIZE(rep);

  00185	48 8b 78 60	 mov	 rdi, QWORD PTR [rax+96]
  00189	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]

; 340  :             else
; 341  :                 repsize = PyUnicode_GET_LENGTH(rep);
; 342  : 
; 343  :             if (repsize > max_char_size) {

  0018d	48 83 ff 04	 cmp	 rdi, 4
  00191	0f 8e b5 00 00
	00		 jle	 $LN59@ucs4lib_ut@4

; 344  :                 Py_ssize_t offset;
; 345  : 
; 346  :                 if (result == NULL)

  00197	48 8b 8d 80 04
	00 00		 mov	 rcx, QWORD PTR result$[rbp-256]
  0019e	48 85 c9	 test	 rcx, rcx
  001a1	75 0a		 jne	 SHORT $LN58@ucs4lib_ut@4

; 347  :                     offset = p - stackbuf;

  001a3	48 8d 44 24 70	 lea	 rax, QWORD PTR stackbuf$[rsp]
  001a8	48 2b d8	 sub	 rbx, rax

; 348  :                 else

  001ab	eb 07		 jmp	 SHORT $LN57@ucs4lib_ut@4
$LN58@ucs4lib_ut@4:

; 349  :                     offset = p - PyBytes_AS_STRING(result);

  001ad	48 2b d9	 sub	 rbx, rcx
  001b0	48 83 eb 78	 sub	 rbx, 120		; 00000078H
$LN57@ucs4lib_ut@4:

; 350  : 
; 351  :                 if (nallocated > PY_SSIZE_T_MAX - repsize + max_char_size) {

  001b4	48 b8 03 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775805 ; 8000000000000003H
  001be	48 2b c7	 sub	 rax, rdi
  001c1	4c 3b f0	 cmp	 r14, rax
  001c4	0f 8f f5 01 00
	00		 jg	 $LN114@ucs4lib_ut@4

; 355  :                 }
; 356  :                 nallocated += repsize - max_char_size;

  001ca	4d 8d 74 3e fc	 lea	 r14, QWORD PTR [r14+rdi-4]

; 357  :                 if (result != NULL) {
; 358  :                     if (_PyBytes_Resize(&result, nallocated) < 0)

  001cf	49 8b d6	 mov	 rdx, r14
  001d2	48 85 c9	 test	 rcx, rcx
  001d5	74 16		 je	 SHORT $LN55@ucs4lib_ut@4
  001d7	48 8d 8d 80 04
	00 00		 lea	 rcx, QWORD PTR result$[rbp-256]
  001de	e8 00 00 00 00	 call	 _PyBytes_Resize
  001e3	85 c0		 test	 eax, eax
  001e5	0f 88 08 02 00
	00		 js	 $error$130647

; 359  :                         goto error;
; 360  :                 } else {

  001eb	eb 53		 jmp	 SHORT $LN128@ucs4lib_ut@4
$LN55@ucs4lib_ut@4:

; 361  :                     result = PyBytes_FromStringAndSize(NULL, nallocated);

  001ed	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  001f2	48 89 85 80 04
	00 00		 mov	 QWORD PTR result$[rbp-256], rax

; 362  :                     if (result == NULL)

  001f9	48 85 c0	 test	 rax, rax
  001fc	0f 84 f1 01 00
	00		 je	 $error$130647

; 363  :                         goto error;
; 364  :                     Py_MEMCPY(PyBytes_AS_STRING(result), stackbuf, offset);

  00202	48 8d 48 78	 lea	 rcx, QWORD PTR [rax+120]
  00206	48 83 fb 10	 cmp	 rbx, 16
  0020a	72 0f		 jb	 SHORT $LN48@ucs4lib_ut@4
  0020c	48 8d 54 24 70	 lea	 rdx, QWORD PTR stackbuf$[rsp]
  00211	4c 8b c3	 mov	 r8, rbx
  00214	e8 00 00 00 00	 call	 memcpy
  00219	eb 25		 jmp	 SHORT $LN128@ucs4lib_ut@4
$LN48@ucs4lib_ut@4:
  0021b	48 85 db	 test	 rbx, rbx
  0021e	74 27		 je	 SHORT $LN49@ucs4lib_ut@4
  00220	4c 8d 44 24 70	 lea	 r8, QWORD PTR stackbuf$[rsp]
  00225	48 8b d3	 mov	 rdx, rbx
  00228	4c 2b c1	 sub	 r8, rcx
  0022b	0f 1f 44 00 00	 npad	 5
$LL46@ucs4lib_ut@4:
  00230	42 0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+r8]
  00235	48 ff c1	 inc	 rcx
  00238	48 ff ca	 dec	 rdx
  0023b	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0023e	75 f0		 jne	 SHORT $LL46@ucs4lib_ut@4
$LN128@ucs4lib_ut@4:
  00240	48 8b 85 80 04
	00 00		 mov	 rax, QWORD PTR result$[rbp-256]
$LN49@ucs4lib_ut@4:

; 365  :                 }
; 366  :                 p = PyBytes_AS_STRING(result) + offset;

  00247	48 8d 5c 03 78	 lea	 rbx, QWORD PTR [rbx+rax+120]
$LN59@ucs4lib_ut@4:

; 367  :             }
; 368  : 
; 369  :             if (PyBytes_Check(rep)) {

  0024c	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00250	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  0025a	74 2c		 je	 SHORT $LN43@ucs4lib_ut@4

; 370  :                 char *prep = PyBytes_AS_STRING(rep);
; 371  :                 for(k = repsize; k > 0; k--)

  0025c	48 85 ff	 test	 rdi, rdi
  0025f	0f 8e a6 00 00
	00		 jle	 $LN33@ucs4lib_ut@4
  00265	48 8b ce	 mov	 rcx, rsi
  00268	48 2b cb	 sub	 rcx, rbx
  0026b	0f 1f 44 00 00	 npad	 5
$LL42@ucs4lib_ut@4:

; 372  :                     *p++ = *prep++;

  00270	0f b6 44 19 78	 movzx	 eax, BYTE PTR [rcx+rbx+120]
  00275	48 ff cf	 dec	 rdi
  00278	48 ff c3	 inc	 rbx
  0027b	88 43 ff	 mov	 BYTE PTR [rbx-1], al
  0027e	48 85 ff	 test	 rdi, rdi
  00281	7f ed		 jg	 SHORT $LL42@ucs4lib_ut@4

; 373  :             } else /* rep is unicode */ {

  00283	e9 83 00 00 00	 jmp	 $LN33@ucs4lib_ut@4
$LN43@ucs4lib_ut@4:

; 374  :                 enum PyUnicode_Kind repkind;
; 375  :                 void *repdata;
; 376  : 
; 377  :                 if (PyUnicode_READY(rep) < 0)

  00288	f6 46 70 80	 test	 BYTE PTR [rsi+112], 128	; 00000080H
  0028c	75 10		 jne	 SHORT $LN121@ucs4lib_ut@4
  0028e	48 8b ce	 mov	 rcx, rsi
  00291	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00296	85 c0		 test	 eax, eax
  00298	0f 88 55 01 00
	00		 js	 $error$130647
$LN121@ucs4lib_ut@4:

; 378  :                     goto error;
; 379  :                 repkind = PyUnicode_KIND(rep);

  0029e	8b 46 70	 mov	 eax, DWORD PTR [rsi+112]
  002a1	44 8b c0	 mov	 r8d, eax
  002a4	41 c1 e8 02	 shr	 r8d, 2
  002a8	41 83 e0 07	 and	 r8d, 7

; 380  :                 repdata = PyUnicode_DATA(rep);

  002ac	a8 20		 test	 al, 32			; 00000020H
  002ae	74 16		 je	 SHORT $LN80@ucs4lib_ut@4
  002b0	a8 40		 test	 al, 64			; 00000040H
  002b2	74 09		 je	 SHORT $LN78@ucs4lib_ut@4
  002b4	48 8d 96 80 00
	00 00		 lea	 rdx, QWORD PTR [rsi+128]
  002bb	eb 10		 jmp	 SHORT $LN81@ucs4lib_ut@4
$LN78@ucs4lib_ut@4:
  002bd	48 8d 96 a0 00
	00 00		 lea	 rdx, QWORD PTR [rsi+160]
  002c4	eb 07		 jmp	 SHORT $LN81@ucs4lib_ut@4
$LN80@ucs4lib_ut@4:
  002c6	48 8b 96 a0 00
	00 00		 mov	 rdx, QWORD PTR [rsi+160]
$LN81@ucs4lib_ut@4:

; 381  : 
; 382  :                 for(k=0; k<repsize; k++) {

  002cd	49 8b cc	 mov	 rcx, r12

; 383  :                     Py_UCS4 c = PyUnicode_READ(repkind, repdata, k);

  002d0	4d 63 c8	 movsxd	 r9, r8d
  002d3	48 85 ff	 test	 rdi, rdi
  002d6	7e 33		 jle	 SHORT $LN33@ucs4lib_ut@4
$LL37@ucs4lib_ut@4:
  002d8	49 83 f9 01	 cmp	 r9, 1
  002dc	75 06		 jne	 SHORT $LN84@ucs4lib_ut@4
  002de	0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+rcx]
  002e2	eb 0f		 jmp	 SHORT $LN83@ucs4lib_ut@4
$LN84@ucs4lib_ut@4:
  002e4	49 83 f9 02	 cmp	 r9, 2
  002e8	75 06		 jne	 SHORT $LN82@ucs4lib_ut@4
  002ea	0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+rcx*2]
  002ee	eb 03		 jmp	 SHORT $LN83@ucs4lib_ut@4
$LN82@ucs4lib_ut@4:
  002f0	8b 04 8a	 mov	 eax, DWORD PTR [rdx+rcx*4]
$LN83@ucs4lib_ut@4:

; 384  :                     if (0x80 <= c) {

  002f3	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  002f8	0f 83 c8 00 00
	00		 jae	 $LN112@ucs4lib_ut@4

; 389  :                         goto error;
; 390  :                     }
; 391  :                     *p++ = (char)c;

  002fe	48 ff c1	 inc	 rcx
  00301	88 03		 mov	 BYTE PTR [rbx], al
  00303	48 ff c3	 inc	 rbx
  00306	48 3b cf	 cmp	 rcx, rdi
  00309	7c cd		 jl	 SHORT $LL37@ucs4lib_ut@4
$LN33@ucs4lib_ut@4:

; 392  :                 }
; 393  :             }
; 394  :             Py_CLEAR(rep);

  0030b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@CCHPJPJC@c?3?2src?2pyparallel?2objects?2string@
  00312	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@HOGFEKAF@ucs4lib_utf8_encoder?$AA@
  00319	4c 8b ce	 mov	 r9, rsi
  0031c	41 b8 8a 01 00
	00		 mov	 r8d, 394		; 0000018aH
  00322	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0032a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0032f	85 c0		 test	 eax, eax
  00331	75 08		 jne	 SHORT $LN125@ucs4lib_ut@4
  00333	48 8b ce	 mov	 rcx, rsi
  00336	e8 00 00 00 00	 call	 _Py_DecRef
$LN125@ucs4lib_ut@4:

; 262  : {

  0033b	48 8b 95 78 04
	00 00		 mov	 rdx, QWORD PTR data$[rbp-256]
  00342	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BH@ODBMEMBA@surrogates?5not?5allowed?$AA@
$LN27@ucs4lib_ut@4:

; 308  :     }
; 309  : 
; 310  :     for (i = 0; i < size;) {

  00349	4d 3b ef	 cmp	 r13, r15
  0034c	0f 8d df 00 00
	00		 jge	 $LN124@ucs4lib_ut@4
  00352	4c 8b 85 70 04
	00 00		 mov	 r8, QWORD PTR unicode$[rbp-256]
  00359	4c 8b 95 88 04
	00 00		 mov	 r10, QWORD PTR errors$[rbp-256]
  00360	e9 8b fd ff ff	 jmp	 $LL69@ucs4lib_ut@4
$LN63@ucs4lib_ut@4:

; 395  :         }
; 396  :         else
; 397  : #if STRINGLIB_SIZEOF_CHAR > 2
; 398  :         if (ch < 0x10000)
; 399  : #endif
; 400  :         {
; 401  :             *p++ = (char)(0xe0 | (ch >> 12));

  00365	8b c1		 mov	 eax, ecx
  00367	81 f9 00 00 01
	00		 cmp	 ecx, 65536		; 00010000H
  0036d	73 22		 jae	 SHORT $LN28@ucs4lib_ut@4
  0036f	c1 e8 0c	 shr	 eax, 12
  00372	0c e0		 or	 al, -32			; ffffffffffffffe0H
  00374	88 03		 mov	 BYTE PTR [rbx], al

; 402  :             *p++ = (char)(0x80 | ((ch >> 6) & 0x3f));

  00376	8b c1		 mov	 eax, ecx

; 403  :             *p++ = (char)(0x80 | (ch & 0x3f));

  00378	80 e1 3f	 and	 cl, 63			; 0000003fH
  0037b	c1 e8 06	 shr	 eax, 6
  0037e	80 c9 80	 or	 cl, -128		; ffffffffffffff80H
  00381	24 3f		 and	 al, 63			; 0000003fH
  00383	0c 80		 or	 al, -128		; ffffffffffffff80H
  00385	48 83 c3 03	 add	 rbx, 3
  00389	88 43 fe	 mov	 BYTE PTR [rbx-2], al
  0038c	88 4b ff	 mov	 BYTE PTR [rbx-1], cl

; 404  :         }
; 405  : #if STRINGLIB_SIZEOF_CHAR > 2
; 406  :         else /* ch >= 0x10000 */

  0038f	eb b8		 jmp	 SHORT $LN27@ucs4lib_ut@4
$LN28@ucs4lib_ut@4:

; 407  :         {
; 408  :             assert(ch <= MAX_UNICODE);
; 409  :             /* Encode UCS4 Unicode ordinals */
; 410  :             *p++ = (char)(0xf0 | (ch >> 18));

  00391	c1 e8 12	 shr	 eax, 18
  00394	0c f0		 or	 al, -16
  00396	88 03		 mov	 BYTE PTR [rbx], al

; 411  :             *p++ = (char)(0x80 | ((ch >> 12) & 0x3f));

  00398	8b c1		 mov	 eax, ecx
  0039a	c1 e8 0c	 shr	 eax, 12
  0039d	24 3f		 and	 al, 63			; 0000003fH
  0039f	0c 80		 or	 al, -128		; ffffffffffffff80H
  003a1	88 43 01	 mov	 BYTE PTR [rbx+1], al

; 412  :             *p++ = (char)(0x80 | ((ch >> 6) & 0x3f));

  003a4	8b c1		 mov	 eax, ecx

; 413  :             *p++ = (char)(0x80 | (ch & 0x3f));

  003a6	80 e1 3f	 and	 cl, 63			; 0000003fH
  003a9	c1 e8 06	 shr	 eax, 6
  003ac	80 c9 80	 or	 cl, -128		; ffffffffffffff80H
  003af	24 3f		 and	 al, 63			; 0000003fH
  003b1	0c 80		 or	 al, -128		; ffffffffffffff80H
  003b3	48 83 c3 04	 add	 rbx, 4
  003b7	88 43 fe	 mov	 BYTE PTR [rbx-2], al
  003ba	88 4b ff	 mov	 BYTE PTR [rbx-1], cl
  003bd	eb 8a		 jmp	 SHORT $LN27@ucs4lib_ut@4
$LN114@ucs4lib_ut@4:

; 352  :                     /* integer overflow */
; 353  :                     PyErr_NoMemory();

  003bf	e8 00 00 00 00	 call	 PyErr_NoMemory

; 354  :                     goto error;

  003c4	eb 2d		 jmp	 SHORT $error$130647
$LN112@ucs4lib_ut@4:

; 385  :                         raise_encode_exception(&exc, "utf-8",
; 386  :                                                unicode,
; 387  :                                                i-1, i,
; 388  :                                                "surrogates not allowed");

  003c6	4c 8b 85 70 04
	00 00		 mov	 r8, QWORD PTR unicode$[rbp-256]
  003cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@ODBMEMBA@surrogates?5not?5allowed?$AA@
  003d4	4d 8d 4d ff	 lea	 r9, QWORD PTR [r13-1]
  003d8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  003e4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR exc$[rsp]
  003e9	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  003ee	e8 00 00 00 00	 call	 raise_encode_exception
$error$130647:

; 437  : 
; 438  : #if STRINGLIB_SIZEOF_CHAR > 1
; 439  :  error:
; 440  :     Py_XDECREF(rep);

  003f3	48 8b ce	 mov	 rcx, rsi
  003f6	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@ucs4lib_ut@4:

; 441  :     Py_XDECREF(errorHandler);

  003fb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR errorHandler$[rsp]
  00400	48 85 c9	 test	 rcx, rcx
  00403	74 05		 je	 SHORT $LN11@ucs4lib_ut@4
  00405	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@ucs4lib_ut@4:

; 442  :     Py_XDECREF(exc);

  0040a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR exc$[rsp]
  0040f	48 85 c9	 test	 rcx, rcx
  00412	74 05		 je	 SHORT $LN7@ucs4lib_ut@4
  00414	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@ucs4lib_ut@4:

; 443  :     Py_XDECREF(result);

  00419	48 8b 8d 80 04
	00 00		 mov	 rcx, QWORD PTR result$[rbp-256]
  00420	48 85 c9	 test	 rcx, rcx
  00423	74 05		 je	 SHORT $LN3@ucs4lib_ut@4
  00425	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@ucs4lib_ut@4:

; 444  :     return NULL;

  0042a	33 c0		 xor	 eax, eax
  0042c	e9 25 01 00 00	 jmp	 $LN127@ucs4lib_ut@4
$LN124@ucs4lib_ut@4:

; 374  :                 enum PyUnicode_Kind repkind;
; 375  :                 void *repdata;
; 376  : 
; 377  :                 if (PyUnicode_READY(rep) < 0)

  00431	4c 8b 64 24 58	 mov	 r12, QWORD PTR errorHandler$[rsp]
  00436	48 8b 7c 24 50	 mov	 rdi, QWORD PTR exc$[rsp]
  0043b	48 8b 85 80 04
	00 00		 mov	 rax, QWORD PTR result$[rbp-256]
$LN68@ucs4lib_ut@4:

; 414  :         }
; 415  : #endif /* STRINGLIB_SIZEOF_CHAR > 2 */
; 416  : #endif /* STRINGLIB_SIZEOF_CHAR > 1 */
; 417  :     }
; 418  : 
; 419  :     if (result == NULL) {

  00442	48 85 c0	 test	 rax, rax
  00445	75 1e		 jne	 SHORT $LN26@ucs4lib_ut@4

; 420  :         /* This was stack allocated. */
; 421  :         nneeded = p - stackbuf;

  00447	48 8d 44 24 70	 lea	 rax, QWORD PTR stackbuf$[rsp]

; 422  :         assert(nneeded <= nallocated);
; 423  :         result = PyBytes_FromStringAndSize(stackbuf, nneeded);

  0044c	48 8d 4c 24 70	 lea	 rcx, QWORD PTR stackbuf$[rsp]
  00451	48 2b d8	 sub	 rbx, rax
  00454	48 8b d3	 mov	 rdx, rbx
  00457	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0045c	48 89 85 80 04
	00 00		 mov	 QWORD PTR result$[rbp-256], rax

; 424  :     }
; 425  :     else {

  00463	eb 13		 jmp	 SHORT $LN24@ucs4lib_ut@4
$LN26@ucs4lib_ut@4:

; 426  :         /* Cut back to size actually needed. */
; 427  :         nneeded = p - PyBytes_AS_STRING(result);
; 428  :         assert(nneeded <= nallocated);
; 429  :         _PyBytes_Resize(&result, nneeded);

  00465	48 2b d8	 sub	 rbx, rax
  00468	48 8d 8d 80 04
	00 00		 lea	 rcx, QWORD PTR result$[rbp-256]
  0046f	48 8d 53 88	 lea	 rdx, QWORD PTR [rbx-120]
  00473	e8 00 00 00 00	 call	 _PyBytes_Resize
$LN24@ucs4lib_ut@4:

; 430  :     }
; 431  : 
; 432  : #if STRINGLIB_SIZEOF_CHAR > 1
; 433  :     Py_XDECREF(errorHandler);

  00478	4d 85 e4	 test	 r12, r12
  0047b	74 68		 je	 SHORT $LN23@ucs4lib_ut@4
  0047d	e8 00 00 00 00	 call	 _Py_PXCTX
  00482	85 c0		 test	 eax, eax
  00484	75 5f		 jne	 SHORT $LN23@ucs4lib_ut@4
  00486	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  0048b	a8 20		 test	 al, 32			; 00000020H
  0048d	75 4e		 jne	 SHORT $LN90@ucs4lib_ut@4
  0048f	84 c0		 test	 al, al
  00491	78 4a		 js	 SHORT $LN90@ucs4lib_ut@4
  00493	a8 02		 test	 al, 2
  00495	75 4e		 jne	 SHORT $LN23@ucs4lib_ut@4
  00497	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  0049c	75 47		 jne	 SHORT $LN23@ucs4lib_ut@4
  0049e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  004a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  004ac	4d 8b cc	 mov	 r9, r12
  004af	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  004b5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004bd	e8 00 00 00 00	 call	 _PyParallel_Guard
  004c2	49 8b cc	 mov	 rcx, r12
  004c5	85 c0		 test	 eax, eax
  004c7	74 07		 je	 SHORT $LN95@ucs4lib_ut@4
  004c9	e8 00 00 00 00	 call	 _Px_Dealloc
  004ce	eb 15		 jmp	 SHORT $LN23@ucs4lib_ut@4
$LN95@ucs4lib_ut@4:
  004d0	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  004d5	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  004db	eb 08		 jmp	 SHORT $LN23@ucs4lib_ut@4
$LN90@ucs4lib_ut@4:
  004dd	49 8b cc	 mov	 rcx, r12
  004e0	e8 00 00 00 00	 call	 Px_DecRef
$LN23@ucs4lib_ut@4:

; 434  :     Py_XDECREF(exc);

  004e5	48 85 ff	 test	 rdi, rdi
  004e8	74 65		 je	 SHORT $LN19@ucs4lib_ut@4
  004ea	e8 00 00 00 00	 call	 _Py_PXCTX
  004ef	85 c0		 test	 eax, eax
  004f1	75 5c		 jne	 SHORT $LN19@ucs4lib_ut@4
  004f3	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  004f7	a8 20		 test	 al, 32			; 00000020H
  004f9	75 4c		 jne	 SHORT $LN101@ucs4lib_ut@4
  004fb	84 c0		 test	 al, al
  004fd	78 48		 js	 SHORT $LN101@ucs4lib_ut@4
  004ff	a8 02		 test	 al, 2
  00501	75 4c		 jne	 SHORT $LN19@ucs4lib_ut@4
  00503	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00507	75 46		 jne	 SHORT $LN19@ucs4lib_ut@4
  00509	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00510	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00517	4c 8b cf	 mov	 r9, rdi
  0051a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00520	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00528	e8 00 00 00 00	 call	 _PyParallel_Guard
  0052d	48 8b cf	 mov	 rcx, rdi
  00530	85 c0		 test	 eax, eax
  00532	74 07		 je	 SHORT $LN106@ucs4lib_ut@4
  00534	e8 00 00 00 00	 call	 _Px_Dealloc
  00539	eb 14		 jmp	 SHORT $LN19@ucs4lib_ut@4
$LN106@ucs4lib_ut@4:
  0053b	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0053f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00545	eb 08		 jmp	 SHORT $LN19@ucs4lib_ut@4
$LN101@ucs4lib_ut@4:
  00547	48 8b cf	 mov	 rcx, rdi
  0054a	e8 00 00 00 00	 call	 Px_DecRef
$LN19@ucs4lib_ut@4:

; 435  : #endif
; 436  :     return result;

  0054f	48 8b 85 80 04
	00 00		 mov	 rax, QWORD PTR result$[rbp-256]
$LN127@ucs4lib_ut@4:
  00556	48 8b b4 24 30
	05 00 00	 mov	 rsi, QWORD PTR [rsp+1328]
  0055e	4c 8b ac 24 28
	05 00 00	 mov	 r13, QWORD PTR [rsp+1320]

; 445  : #endif
; 446  : 
; 447  : #undef MAX_SHORT_UNICHARS
; 448  : }

  00566	48 81 c4 38 05
	00 00		 add	 rsp, 1336		; 00000538H
  0056d	41 5f		 pop	 r15
  0056f	41 5e		 pop	 r14
  00571	41 5c		 pop	 r12
  00573	5f		 pop	 rdi
  00574	5b		 pop	 rbx
  00575	5d		 pop	 rbp
  00576	c3		 ret	 0
ucs4lib_utf8_encoder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@OMKFHCNA@unexpected?5end?5of?5data?$AA@ ; `string'
PUBLIC	??_C@_0BD@FFHPAONK@invalid?5start?5byte?$AA@	; `string'
PUBLIC	??_C@_0BK@OFHLMAEL@invalid?5continuation?5byte?$AA@ ; `string'
PUBLIC	PyUnicode_DecodeUTF8Stateful
;	COMDAT pdata
; File c:\src\pyparallel\objects\unicodeobject.c
pdata	SEGMENT
$pdata$PyUnicode_DecodeUTF8Stateful DD imagerel $LN91
	DD	imagerel $LN91+174
	DD	imagerel $unwind$PyUnicode_DecodeUTF8Stateful
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyUnicode_DecodeUTF8Stateful DD imagerel $LN91+174
	DD	imagerel $LN91+876
	DD	imagerel $chain$0$PyUnicode_DecodeUTF8Stateful
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyUnicode_DecodeUTF8Stateful DD imagerel $LN91+876
	DD	imagerel $LN91+895
	DD	imagerel $chain$1$PyUnicode_DecodeUTF8Stateful
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyUnicode_DecodeUTF8Stateful DD 021H
	DD	imagerel $LN91
	DD	imagerel $LN91+174
	DD	imagerel $unwind$PyUnicode_DecodeUTF8Stateful
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyUnicode_DecodeUTF8Stateful DD 020821H
	DD	01f3408H
	DD	imagerel $LN91
	DD	imagerel $LN91+174
	DD	imagerel $unwind$PyUnicode_DecodeUTF8Stateful
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_DecodeUTF8Stateful DD 091c01H
	DD	014011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT ??_C@_0BH@OMKFHCNA@unexpected?5end?5of?5data?$AA@
CONST	SEGMENT
??_C@_0BH@OMKFHCNA@unexpected?5end?5of?5data?$AA@ DB 'unexpected end of d'
	DB	'ata', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FFHPAONK@invalid?5start?5byte?$AA@
CONST	SEGMENT
??_C@_0BD@FFHPAONK@invalid?5start?5byte?$AA@ DB 'invalid start byte', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OFHLMAEL@invalid?5continuation?5byte?$AA@
CONST	SEGMENT
??_C@_0BK@OFHLMAEL@invalid?5continuation?5byte?$AA@ DB 'invalid continuat'
	DB	'ion byte', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_DecodeUTF8Stateful
_TEXT	SEGMENT
unicode$ = 96
endinpos$ = 104
startinpos$ = 112
errorHandler$ = 120
exc$ = 128
starts$ = 136
end$ = 144
s$ = 224
outpos$ = 232
size$ = 232
errors$ = 240
consumed$ = 248
PyUnicode_DecodeUTF8Stateful PROC			; COMDAT

; 4829 : {

$LN91:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 8d 6c 24 d9	 lea	 rbp, QWORD PTR [rsp-39]
  00015	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 4830 :     PyObject *unicode;
; 4831 :     const char *starts = s;
; 4832 :     const char *end = s + size;
; 4833 :     Py_ssize_t outpos;
; 4834 : 
; 4835 :     Py_ssize_t startinpos;
; 4836 :     Py_ssize_t endinpos;
; 4837 :     const char *errmsg = "";
; 4838 :     PyObject *errorHandler = NULL;

  0001c	45 33 e4	 xor	 r12d, r12d
  0001f	48 8d 34 11	 lea	 rsi, QWORD PTR [rcx+rdx]
  00023	4d 8b f9	 mov	 r15, r9
  00026	48 8b c2	 mov	 rax, rdx
  00029	48 8b f9	 mov	 rdi, rcx
  0002c	4c 8b f1	 mov	 r14, rcx
  0002f	48 89 75 17	 mov	 QWORD PTR end$[rbp-121], rsi
  00033	48 89 4d 0f	 mov	 QWORD PTR starts$[rbp-121], rcx
  00037	4c 89 65 ff	 mov	 QWORD PTR errorHandler$[rbp-121], r12

; 4839 :     PyObject *exc = NULL;

  0003b	45 8b ec	 mov	 r13d, r12d
  0003e	4c 89 65 07	 mov	 QWORD PTR exc$[rbp-121], r12

; 4840 : 
; 4841 :     if (size == 0) {

  00042	48 85 d2	 test	 rdx, rdx
  00045	75 3f		 jne	 SHORT $LN50@PyUnicode_@64

; 4842 :         if (consumed)

  00047	4d 85 c9	 test	 r9, r9
  0004a	74 03		 je	 SHORT $LN52@PyUnicode_@64

; 4843 :             *consumed = 0;

  0004c	4d 89 21	 mov	 QWORD PTR [r9], r12
$LN52@PyUnicode_@64:

; 4844 :         _Py_RETURN_UNICODE_EMPTY();

  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  00056	48 85 c9	 test	 rcx, rcx
  00059	75 1a		 jne	 SHORT $LN89@PyUnicode_@64
  0005b	33 d2		 xor	 edx, edx
  0005d	e8 00 00 00 00	 call	 PyUnicode_New
  00062	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  00069	48 85 c0	 test	 rax, rax
  0006c	0f 84 fa 02 00
	00		 je	 $LN55@PyUnicode_@64
  00072	48 8b c8	 mov	 rcx, rax
$LN89@PyUnicode_@64:
  00075	e8 00 00 00 00	 call	 _Py_IncRef
  0007a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty
  00081	e9 e6 02 00 00	 jmp	 $LN55@PyUnicode_@64
$LN50@PyUnicode_@64:

; 4845 :     }
; 4846 : 
; 4847 :     /* ASCII is equivalent to the first 128 ordinals in Unicode. */
; 4848 :     if (size == 1 && (unsigned char)s[0] < 128) {

  00086	48 83 f8 01	 cmp	 rax, 1
  0008a	75 1a		 jne	 SHORT $LN43@PyUnicode_@64
  0008c	80 39 80	 cmp	 BYTE PTR [rcx], 128	; 00000080H
  0008f	73 15		 jae	 SHORT $LN43@PyUnicode_@64

; 4849 :         if (consumed)

  00091	4d 85 c9	 test	 r9, r9
  00094	74 03		 je	 SHORT $LN42@PyUnicode_@64

; 4850 :             *consumed = 1;

  00096	49 89 01	 mov	 QWORD PTR [r9], rax
$LN42@PyUnicode_@64:

; 4851 :         return get_latin1_char((unsigned char)s[0]);

  00099	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0009c	e8 00 00 00 00	 call	 get_latin1_char
  000a1	e9 c6 02 00 00	 jmp	 $LN55@PyUnicode_@64
$LN43@PyUnicode_@64:

; 4852 :     }
; 4853 : 
; 4854 :     unicode = PyUnicode_New(size, 127);

  000a6	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	48 89 9c 24 f8
	00 00 00	 mov	 QWORD PTR [rsp+248], rbx
  000b6	e8 00 00 00 00	 call	 PyUnicode_New
  000bb	48 8b d8	 mov	 rbx, rax
  000be	48 89 45 e7	 mov	 QWORD PTR unicode$[rbp-121], rax

; 4855 :     if (!unicode)

  000c2	48 85 c0	 test	 rax, rax

; 4856 :         return NULL;

  000c5	0f 84 6c 02 00
	00		 je	 $LN3@PyUnicode_@64

; 4857 : 
; 4858 :     outpos = ascii_decode(s, end, PyUnicode_1BYTE_DATA(unicode));

  000cb	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000ce	a8 20		 test	 al, 32			; 00000020H
  000d0	74 16		 je	 SHORT $LN59@PyUnicode_@64
  000d2	a8 40		 test	 al, 64			; 00000040H
  000d4	74 09		 je	 SHORT $LN57@PyUnicode_@64
  000d6	4c 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [rbx+128]
  000dd	eb 10		 jmp	 SHORT $LN60@PyUnicode_@64
$LN57@PyUnicode_@64:
  000df	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  000e6	eb 07		 jmp	 SHORT $LN60@PyUnicode_@64
$LN59@PyUnicode_@64:
  000e8	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
$LN60@PyUnicode_@64:
  000ef	48 8b d6	 mov	 rdx, rsi
  000f2	48 8b cf	 mov	 rcx, rdi
  000f5	e8 00 00 00 00	 call	 ascii_decode

; 4859 :     s += outpos;

  000fa	48 03 f8	 add	 rdi, rax
  000fd	48 89 45 6f	 mov	 QWORD PTR outpos$[rbp-121], rax
  00101	48 89 7d 67	 mov	 QWORD PTR s$[rbp-121], rdi

; 4860 :     while (s < end) {

  00105	48 3b fe	 cmp	 rdi, rsi
  00108	0f 83 f1 01 00
	00		 jae	 $End$131054
  0010e	4c 8b 65 77	 mov	 r12, QWORD PTR errors$[rbp-121]
$LL40@PyUnicode_@64:

; 4861 :         Py_UCS4 ch;
; 4862 :         int kind = PyUnicode_KIND(unicode);

  00112	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00115	8b c8		 mov	 ecx, eax
  00117	c1 e9 02	 shr	 ecx, 2
  0011a	83 e1 07	 and	 ecx, 7

; 4863 :         if (kind == PyUnicode_1BYTE_KIND) {

  0011d	83 f9 01	 cmp	 ecx, 1
  00120	75 4f		 jne	 SHORT $LN38@PyUnicode_@64

; 4864 :             if (PyUnicode_IS_ASCII(unicode))

  00122	a8 40		 test	 al, 64			; 00000040H
  00124	74 27		 je	 SHORT $LN37@PyUnicode_@64

; 4865 :                 ch = asciilib_utf8_decode(&s, end,
; 4866 :                         PyUnicode_1BYTE_DATA(unicode), &outpos);

  00126	4c 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [rbx+128]
  0012d	a8 20		 test	 al, 32			; 00000020H
  0012f	75 07		 jne	 SHORT $LN64@PyUnicode_@64
  00131	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
$LN64@PyUnicode_@64:
  00138	4c 8d 4d 6f	 lea	 r9, QWORD PTR outpos$[rbp-121]
  0013c	48 8d 4d 67	 lea	 rcx, QWORD PTR s$[rbp-121]
  00140	48 8b d6	 mov	 rdx, rsi
  00143	e8 00 00 00 00	 call	 asciilib_utf8_decode

; 4867 :             else

  00148	e9 8d 00 00 00	 jmp	 $LN90@PyUnicode_@64
$LN37@PyUnicode_@64:

; 4868 :                 ch = ucs1lib_utf8_decode(&s, end,
; 4869 :                         PyUnicode_1BYTE_DATA(unicode), &outpos);

  0014d	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  00154	a8 20		 test	 al, 32			; 00000020H
  00156	75 07		 jne	 SHORT $LN68@PyUnicode_@64
  00158	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
$LN68@PyUnicode_@64:
  0015f	4c 8d 4d 6f	 lea	 r9, QWORD PTR outpos$[rbp-121]
  00163	48 8d 4d 67	 lea	 rcx, QWORD PTR s$[rbp-121]
  00167	48 8b d6	 mov	 rdx, rsi
  0016a	e8 00 00 00 00	 call	 ucs1lib_utf8_decode

; 4870 :         } else if (kind == PyUnicode_2BYTE_KIND) {

  0016f	eb 69		 jmp	 SHORT $LN90@PyUnicode_@64
$LN38@PyUnicode_@64:
  00171	83 f9 02	 cmp	 ecx, 2
  00174	75 33		 jne	 SHORT $LN34@PyUnicode_@64

; 4871 :             ch = ucs2lib_utf8_decode(&s, end,
; 4872 :                     PyUnicode_2BYTE_DATA(unicode), &outpos);

  00176	a8 20		 test	 al, 32			; 00000020H
  00178	74 16		 je	 SHORT $LN71@PyUnicode_@64
  0017a	a8 40		 test	 al, 64			; 00000040H
  0017c	74 09		 je	 SHORT $LN69@PyUnicode_@64
  0017e	4c 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [rbx+128]
  00185	eb 10		 jmp	 SHORT $LN72@PyUnicode_@64
$LN69@PyUnicode_@64:
  00187	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  0018e	eb 07		 jmp	 SHORT $LN72@PyUnicode_@64
$LN71@PyUnicode_@64:
  00190	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
$LN72@PyUnicode_@64:
  00197	4c 8d 4d 6f	 lea	 r9, QWORD PTR outpos$[rbp-121]
  0019b	48 8d 4d 67	 lea	 rcx, QWORD PTR s$[rbp-121]
  0019f	48 8b d6	 mov	 rdx, rsi
  001a2	e8 00 00 00 00	 call	 ucs2lib_utf8_decode

; 4873 :         } else {

  001a7	eb 31		 jmp	 SHORT $LN90@PyUnicode_@64
$LN34@PyUnicode_@64:

; 4874 :             assert(kind == PyUnicode_4BYTE_KIND);
; 4875 :             ch = ucs4lib_utf8_decode(&s, end,
; 4876 :                     PyUnicode_4BYTE_DATA(unicode), &outpos);

  001a9	a8 20		 test	 al, 32			; 00000020H
  001ab	74 16		 je	 SHORT $LN75@PyUnicode_@64
  001ad	a8 40		 test	 al, 64			; 00000040H
  001af	74 09		 je	 SHORT $LN73@PyUnicode_@64
  001b1	4c 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [rbx+128]
  001b8	eb 10		 jmp	 SHORT $LN76@PyUnicode_@64
$LN73@PyUnicode_@64:
  001ba	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  001c1	eb 07		 jmp	 SHORT $LN76@PyUnicode_@64
$LN75@PyUnicode_@64:
  001c3	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
$LN76@PyUnicode_@64:
  001ca	4c 8d 4d 6f	 lea	 r9, QWORD PTR outpos$[rbp-121]
  001ce	48 8d 4d 67	 lea	 rcx, QWORD PTR s$[rbp-121]
  001d2	48 8b d6	 mov	 rdx, rsi
  001d5	e8 00 00 00 00	 call	 ucs4lib_utf8_decode
$LN90@PyUnicode_@64:
  001da	44 8b c0	 mov	 r8d, eax

; 4877 :         }
; 4878 : 
; 4879 :         switch (ch) {

  001dd	85 c0		 test	 eax, eax
  001df	74 6a		 je	 SHORT $LN30@PyUnicode_@64
  001e1	83 f8 01	 cmp	 eax, 1
  001e4	74 4a		 je	 SHORT $LN27@PyUnicode_@64
  001e6	8d 40 fe	 lea	 eax, DWORD PTR [rax-2]
  001e9	83 f8 02	 cmp	 eax, 2
  001ec	77 20		 ja	 SHORT $LN25@PyUnicode_@64

; 4892 :         case 2:
; 4893 :         case 3:
; 4894 :         case 4:
; 4895 :             errmsg = "invalid continuation byte";
; 4896 :             startinpos = s - starts;

  001ee	48 8b 4d 67	 mov	 rcx, QWORD PTR s$[rbp-121]

; 4897 :             endinpos = startinpos + ch - 1;

  001f2	41 8b c0	 mov	 eax, r8d
  001f5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BK@OFHLMAEL@invalid?5continuation?5byte?$AA@
  001fc	49 2b ce	 sub	 rcx, r14
  001ff	48 89 4d f7	 mov	 QWORD PTR startinpos$[rbp-121], rcx
  00203	48 8d 4c 08 ff	 lea	 rcx, QWORD PTR [rax+rcx-1]
  00208	48 89 4d ef	 mov	 QWORD PTR endinpos$[rbp-121], rcx

; 4898 :             break;

  0020c	eb 68		 jmp	 SHORT $LN31@PyUnicode_@64
$LN25@PyUnicode_@64:

; 4899 :         default:
; 4900 :             if (unicode_putchar(&unicode, &outpos, ch) < 0)

  0020e	48 8d 55 6f	 lea	 rdx, QWORD PTR outpos$[rbp-121]
  00212	48 8d 4d e7	 lea	 rcx, QWORD PTR unicode$[rbp-121]
  00216	e8 00 00 00 00	 call	 unicode_putchar
  0021b	85 c0		 test	 eax, eax
  0021d	0f 89 be 00 00
	00		 jns	 $LN23@PyUnicode_@64
$LN84@PyUnicode_@64:

; 4910 :             goto onError;
; 4911 :     }
; 4912 : 
; 4913 : End:
; 4914 :     if (unicode_resize(&unicode, outpos) < 0)

  00223	4c 8b 65 ff	 mov	 r12, QWORD PTR errorHandler$[rbp-121]
  00227	4c 8b 6d 07	 mov	 r13, QWORD PTR exc$[rbp-121]
  0022b	e9 df 00 00 00	 jmp	 $onError$131062
$LN27@PyUnicode_@64:

; 4886 :             break;
; 4887 :         case 1:
; 4888 :             errmsg = "invalid start byte";
; 4889 :             startinpos = s - starts;

  00230	48 8b 45 67	 mov	 rax, QWORD PTR s$[rbp-121]
  00234	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BD@FFHPAONK@invalid?5start?5byte?$AA@
  0023b	49 2b c6	 sub	 rax, r14
  0023e	48 89 45 f7	 mov	 QWORD PTR startinpos$[rbp-121], rax

; 4890 :             endinpos = startinpos + 1;

  00242	48 ff c0	 inc	 rax
  00245	48 89 45 ef	 mov	 QWORD PTR endinpos$[rbp-121], rax

; 4891 :             break;

  00249	eb 2b		 jmp	 SHORT $LN31@PyUnicode_@64
$LN30@PyUnicode_@64:

; 4880 :         case 0:
; 4881 :             if (s == end || consumed)

  0024b	48 8b 7d 67	 mov	 rdi, QWORD PTR s$[rbp-121]
  0024f	48 3b fe	 cmp	 rdi, rsi
  00252	0f 84 9b 00 00
	00		 je	 $LN83@PyUnicode_@64
  00258	4d 85 ff	 test	 r15, r15
  0025b	0f 85 92 00 00
	00		 jne	 $LN83@PyUnicode_@64

; 4882 :                 goto End;
; 4883 :             errmsg = "unexpected end of data";
; 4884 :             startinpos = s - starts;

  00261	49 2b fe	 sub	 rdi, r14

; 4885 :             endinpos = end - starts;

  00264	49 2b f6	 sub	 rsi, r14
  00267	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BH@OMKFHCNA@unexpected?5end?5of?5data?$AA@
  0026e	48 89 75 ef	 mov	 QWORD PTR endinpos$[rbp-121], rsi
  00272	48 89 7d f7	 mov	 QWORD PTR startinpos$[rbp-121], rdi
$LN31@PyUnicode_@64:

; 4901 :                 goto onError;
; 4902 :             continue;
; 4903 :         }
; 4904 : 
; 4905 :         if (unicode_decode_call_errorhandler(
; 4906 :                 errors, &errorHandler,
; 4907 :                 "utf-8", errmsg,
; 4908 :                 &starts, &end, &startinpos, &endinpos, &exc, &s,
; 4909 :                 &unicode, &outpos))

  00276	48 8d 45 6f	 lea	 rax, QWORD PTR outpos$[rbp-121]
  0027a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  00281	48 8d 55 ff	 lea	 rdx, QWORD PTR errorHandler$[rbp-121]
  00285	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  0028a	48 8d 45 e7	 lea	 rax, QWORD PTR unicode$[rbp-121]
  0028e	49 8b cc	 mov	 rcx, r12
  00291	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00296	48 8d 45 67	 lea	 rax, QWORD PTR s$[rbp-121]
  0029a	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0029f	48 8d 45 07	 lea	 rax, QWORD PTR exc$[rbp-121]
  002a3	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  002a8	48 8d 45 ef	 lea	 rax, QWORD PTR endinpos$[rbp-121]
  002ac	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  002b1	48 8d 45 f7	 lea	 rax, QWORD PTR startinpos$[rbp-121]
  002b5	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  002ba	48 8d 45 17	 lea	 rax, QWORD PTR end$[rbp-121]
  002be	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002c3	48 8d 45 0f	 lea	 rax, QWORD PTR starts$[rbp-121]
  002c7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002cc	e8 00 00 00 00	 call	 unicode_decode_call_errorhandler
  002d1	85 c0		 test	 eax, eax
  002d3	0f 85 4a ff ff
	ff		 jne	 $LN84@PyUnicode_@64
  002d9	4c 8b 75 0f	 mov	 r14, QWORD PTR starts$[rbp-121]
  002dd	48 8b 75 17	 mov	 rsi, QWORD PTR end$[rbp-121]
$LN23@PyUnicode_@64:

; 4860 :     while (s < end) {

  002e1	48 8b 7d 67	 mov	 rdi, QWORD PTR s$[rbp-121]
  002e5	48 3b fe	 cmp	 rdi, rsi
  002e8	73 09		 jae	 SHORT $LN83@PyUnicode_@64
  002ea	48 8b 5d e7	 mov	 rbx, QWORD PTR unicode$[rbp-121]
  002ee	e9 1f fe ff ff	 jmp	 $LL40@PyUnicode_@64
$LN83@PyUnicode_@64:
  002f3	4c 8b 65 ff	 mov	 r12, QWORD PTR errorHandler$[rbp-121]
  002f7	4c 8b 6d 07	 mov	 r13, QWORD PTR exc$[rbp-121]
  002fb	48 8b 45 6f	 mov	 rax, QWORD PTR outpos$[rbp-121]
$End$131054:

; 4910 :             goto onError;
; 4911 :     }
; 4912 : 
; 4913 : End:
; 4914 :     if (unicode_resize(&unicode, outpos) < 0)

  002ff	48 8d 4d e7	 lea	 rcx, QWORD PTR unicode$[rbp-121]
  00303	48 8b d0	 mov	 rdx, rax
  00306	e8 00 00 00 00	 call	 unicode_resize
  0030b	85 c0		 test	 eax, eax
  0030d	79 2c		 jns	 SHORT $LN22@PyUnicode_@64
$onError$131062:

; 4924 : 
; 4925 : onError:
; 4926 :     Py_XDECREF(errorHandler);

  0030f	4d 85 e4	 test	 r12, r12
  00312	74 08		 je	 SHORT $LN11@PyUnicode_@64
  00314	49 8b cc	 mov	 rcx, r12
  00317	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@PyUnicode_@64:

; 4927 :     Py_XDECREF(exc);

  0031c	4d 85 ed	 test	 r13, r13
  0031f	74 08		 je	 SHORT $LN7@PyUnicode_@64
  00321	49 8b cd	 mov	 rcx, r13
  00324	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@PyUnicode_@64:

; 4928 :     Py_XDECREF(unicode);

  00329	48 8b 4d e7	 mov	 rcx, QWORD PTR unicode$[rbp-121]
  0032d	48 85 c9	 test	 rcx, rcx
  00330	74 05		 je	 SHORT $LN3@PyUnicode_@64
  00332	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyUnicode_@64:

; 4929 :     return NULL;

  00337	33 c0		 xor	 eax, eax
  00339	eb 29		 jmp	 SHORT $LN88@PyUnicode_@64
$LN22@PyUnicode_@64:

; 4915 :         goto onError;
; 4916 : 
; 4917 :     if (consumed)

  0033b	4d 85 ff	 test	 r15, r15
  0033e	74 06		 je	 SHORT $LN20@PyUnicode_@64

; 4918 :         *consumed = s - starts;

  00340	49 2b fe	 sub	 rdi, r14
  00343	49 89 3f	 mov	 QWORD PTR [r15], rdi
$LN20@PyUnicode_@64:

; 4919 : 
; 4920 :     Py_XDECREF(errorHandler);

  00346	4d 85 e4	 test	 r12, r12
  00349	74 08		 je	 SHORT $LN19@PyUnicode_@64
  0034b	49 8b cc	 mov	 rcx, r12
  0034e	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@PyUnicode_@64:

; 4921 :     Py_XDECREF(exc);

  00353	4d 85 ed	 test	 r13, r13
  00356	74 08		 je	 SHORT $LN15@PyUnicode_@64
  00358	49 8b cd	 mov	 rcx, r13
  0035b	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@PyUnicode_@64:

; 4922 :     assert(_PyUnicode_CheckConsistency(unicode, 1));
; 4923 :     return unicode;

  00360	48 8b 45 e7	 mov	 rax, QWORD PTR unicode$[rbp-121]
$LN88@PyUnicode_@64:
  00364	48 8b 9c 24 f8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+248]
$LN55@PyUnicode_@64:

; 4930 : }

  0036c	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00373	41 5f		 pop	 r15
  00375	41 5e		 pop	 r14
  00377	41 5d		 pop	 r13
  00379	41 5c		 pop	 r12
  0037b	5f		 pop	 rdi
  0037c	5e		 pop	 rsi
  0037d	5d		 pop	 rbp
  0037e	c3		 ret	 0
PyUnicode_DecodeUTF8Stateful ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_AsUTF8String
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_AsUTF8String DD imagerel $LN25
	DD	imagerel $LN25+293
	DD	imagerel $unwind$_PyUnicode_AsUTF8String
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_AsUTF8String DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_AsUTF8String
_TEXT	SEGMENT
unicode$ = 48
errors$ = 56
_PyUnicode_AsUTF8String PROC				; COMDAT

; 4997 : {

$LN25:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4998 :     enum PyUnicode_Kind kind;
; 4999 :     void *data;
; 5000 :     Py_ssize_t size;
; 5001 : 
; 5002 :     if (!PyUnicode_Check(unicode)) {

  0000a	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0001e	75 12		 jne	 SHORT $LN9@PyUnicode_@65

; 5003 :         PyErr_BadArgument();

  00020	e8 00 00 00 00	 call	 PyErr_BadArgument
$LN24@PyUnicode_@65:

; 5004 :         return NULL;

  00025	33 c0		 xor	 eax, eax

; 5029 :     }
; 5030 : }

  00027	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN9@PyUnicode_@65:

; 5005 :     }
; 5006 : 
; 5007 :     if (PyUnicode_READY(unicode) == -1)

  00032	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00036	75 0a		 jne	 SHORT $LN8@PyUnicode_@65
  00038	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0003d	83 f8 ff	 cmp	 eax, -1

; 5008 :         return NULL;

  00040	74 e3		 je	 SHORT $LN24@PyUnicode_@65
$LN8@PyUnicode_@65:

; 5009 : 
; 5010 :     if (PyUnicode_UTF8(unicode))

  00042	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00045	8b d0		 mov	 edx, eax
  00047	c1 ea 06	 shr	 edx, 6
  0004a	83 e2 01	 and	 edx, 1
  0004d	74 0b		 je	 SHORT $LN14@PyUnicode_@65
  0004f	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  00056	a8 20		 test	 al, 32			; 00000020H
  00058	75 07		 jne	 SHORT $LN15@PyUnicode_@65
$LN14@PyUnicode_@65:
  0005a	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
$LN15@PyUnicode_@65:
  00061	48 85 c9	 test	 rcx, rcx
  00064	74 3d		 je	 SHORT $LN7@PyUnicode_@65

; 5011 :         return PyBytes_FromStringAndSize(PyUnicode_UTF8(unicode),
; 5012 :                                          PyUnicode_UTF8_LENGTH(unicode));

  00066	85 d2		 test	 edx, edx
  00068	74 0a		 je	 SHORT $LN16@PyUnicode_@65
  0006a	a8 20		 test	 al, 32			; 00000020H
  0006c	74 06		 je	 SHORT $LN16@PyUnicode_@65
  0006e	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  00072	eb 07		 jmp	 SHORT $LN17@PyUnicode_@65
$LN16@PyUnicode_@65:
  00074	4c 8b 83 80 00
	00 00		 mov	 r8, QWORD PTR [rbx+128]
$LN17@PyUnicode_@65:
  0007b	85 d2		 test	 edx, edx
  0007d	74 0b		 je	 SHORT $LN18@PyUnicode_@65
  0007f	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  00086	a8 20		 test	 al, 32			; 00000020H
  00088	75 07		 jne	 SHORT $LN19@PyUnicode_@65
$LN18@PyUnicode_@65:
  0008a	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
$LN19@PyUnicode_@65:
  00091	49 8b d0	 mov	 rdx, r8

; 5029 :     }
; 5030 : }

  00094	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00099	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009d	5f		 pop	 rdi
  0009e	e9 00 00 00 00	 jmp	 PyBytes_FromStringAndSize
$LN7@PyUnicode_@65:

; 5013 : 
; 5014 :     kind = PyUnicode_KIND(unicode);

  000a3	8b c8		 mov	 ecx, eax
  000a5	c1 e9 02	 shr	 ecx, 2
  000a8	83 e1 07	 and	 ecx, 7

; 5015 :     data = PyUnicode_DATA(unicode);

  000ab	a8 20		 test	 al, 32			; 00000020H
  000ad	74 16		 je	 SHORT $LN22@PyUnicode_@65
  000af	85 d2		 test	 edx, edx
  000b1	74 09		 je	 SHORT $LN20@PyUnicode_@65
  000b3	4c 8d 93 80 00
	00 00		 lea	 r10, QWORD PTR [rbx+128]
  000ba	eb 10		 jmp	 SHORT $LN23@PyUnicode_@65
$LN20@PyUnicode_@65:
  000bc	4c 8d 93 a0 00
	00 00		 lea	 r10, QWORD PTR [rbx+160]
  000c3	eb 07		 jmp	 SHORT $LN23@PyUnicode_@65
$LN22@PyUnicode_@65:
  000c5	4c 8b 93 a0 00
	00 00		 mov	 r10, QWORD PTR [rbx+160]
$LN23@PyUnicode_@65:

; 5016 :     size = PyUnicode_GET_LENGTH(unicode);
; 5017 : 
; 5018 :     switch (kind) {

  000cc	ff c9		 dec	 ecx
  000ce	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  000d2	74 3f		 je	 SHORT $LN4@PyUnicode_@65
  000d4	ff c9		 dec	 ecx
  000d6	74 20		 je	 SHORT $LN2@PyUnicode_@65
  000d8	83 f9 02	 cmp	 ecx, 2
  000db	75 36		 jne	 SHORT $LN4@PyUnicode_@65

; 5027 :     case PyUnicode_4BYTE_KIND:
; 5028 :         return ucs4lib_utf8_encoder(unicode, data, size, errors);

  000dd	4c 8b c2	 mov	 r8, rdx
  000e0	4c 8b cf	 mov	 r9, rdi
  000e3	48 8b cb	 mov	 rcx, rbx
  000e6	49 8b d2	 mov	 rdx, r10

; 5029 :     }
; 5030 : }

  000e9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ee	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f2	5f		 pop	 rdi
  000f3	e9 00 00 00 00	 jmp	 ucs4lib_utf8_encoder
$LN2@PyUnicode_@65:

; 5025 :     case PyUnicode_2BYTE_KIND:
; 5026 :         return ucs2lib_utf8_encoder(unicode, data, size, errors);

  000f8	4c 8b c2	 mov	 r8, rdx
  000fb	4c 8b cf	 mov	 r9, rdi
  000fe	48 8b cb	 mov	 rcx, rbx
  00101	49 8b d2	 mov	 rdx, r10

; 5029 :     }
; 5030 : }

  00104	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00109	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010d	5f		 pop	 rdi
  0010e	e9 00 00 00 00	 jmp	 ucs2lib_utf8_encoder
$LN4@PyUnicode_@65:

; 5019 :     default:
; 5020 :         assert(0);
; 5021 :     case PyUnicode_1BYTE_KIND:
; 5022 :         /* the string cannot be ASCII, or PyUnicode_UTF8() would be set */
; 5023 :         assert(!PyUnicode_IS_ASCII(unicode));
; 5024 :         return ucs1lib_utf8_encoder(unicode, data, size, errors);

  00113	49 8b ca	 mov	 rcx, r10

; 5029 :     }
; 5030 : }

  00116	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0011b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011f	5f		 pop	 rdi
  00120	e9 00 00 00 00	 jmp	 ucs1lib_utf8_encoder
_PyUnicode_AsUTF8String ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_EncodeUTF8
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_EncodeUTF8 DD imagerel $LN4
	DD	imagerel $LN4+73
	DD	imagerel $unwind$PyUnicode_EncodeUTF8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_EncodeUTF8 DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_EncodeUTF8
_TEXT	SEGMENT
s$ = 48
size$ = 56
errors$ = 64
PyUnicode_EncodeUTF8 PROC				; COMDAT

; 5036 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b d8	 mov	 rbx, r8

; 5037 :     PyObject *v, *unicode;
; 5038 : 
; 5039 :     unicode = PyUnicode_FromUnicode(s, size);

  0000d	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  00012	48 8b f8	 mov	 rdi, rax

; 5040 :     if (unicode == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0b		 jne	 SHORT $LN1@PyUnicode_@66

; 5045 : }

  0001a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
$LN1@PyUnicode_@66:

; 5041 :         return NULL;
; 5042 :     v = _PyUnicode_AsUTF8String(unicode, errors);

  00025	48 8b d3	 mov	 rdx, rbx
  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 _PyUnicode_AsUTF8String

; 5043 :     Py_DECREF(unicode);

  00030	48 8b cf	 mov	 rcx, rdi
  00033	48 8b d8	 mov	 rbx, rax
  00036	e8 00 00 00 00	 call	 _Py_DecRef

; 5044 :     return v;

  0003b	48 8b c3	 mov	 rax, rbx

; 5045 : }

  0003e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
PyUnicode_EncodeUTF8 ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsUTF8String
; Function compile flags: /Ogtpy
;	COMDAT PyUnicode_AsUTF8String
_TEXT	SEGMENT
unicode$ = 8
PyUnicode_AsUTF8String PROC				; COMDAT

; 5050 :     return _PyUnicode_AsUTF8String(unicode, NULL);

  00000	33 d2		 xor	 edx, edx

; 5051 : }

  00002	e9 00 00 00 00	 jmp	 _PyUnicode_AsUTF8String
PyUnicode_AsUTF8String ENDP
_TEXT	ENDS
PUBLIC	??_C@_05MMJACDEG@utf32?$AA@			; `string'
PUBLIC	??_C@_0CB@LOLOEEIM@codepoint?5not?5in?5range?$CI0x110000?$CJ@ ; `string'
PUBLIC	??_C@_0P@LDIBFBIO@truncated?5data?$AA@		; `string'
PUBLIC	PyUnicode_DecodeUTF32Stateful
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_DecodeUTF32Stateful DD imagerel $LN52
	DD	imagerel $LN52+759
	DD	imagerel $unwind$PyUnicode_DecodeUTF32Stateful
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_DecodeUTF32Stateful DD 0a2201H
	DD	0150122H
	DD	0e014f016H
	DD	0c010d012H
	DD	0600d700eH
	DD	0500b300cH
xdata	ENDS
;	COMDAT ??_C@_05MMJACDEG@utf32?$AA@
CONST	SEGMENT
??_C@_05MMJACDEG@utf32?$AA@ DB 'utf32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LOLOEEIM@codepoint?5not?5in?5range?$CI0x110000?$CJ@
CONST	SEGMENT
??_C@_0CB@LOLOEEIM@codepoint?5not?5in?5range?$CI0x110000?$CJ@ DB 'codepoi'
	DB	'nt not in range(0x110000)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LDIBFBIO@truncated?5data?$AA@
CONST	SEGMENT
??_C@_0P@LDIBFBIO@truncated?5data?$AA@ DB 'truncated data', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_DecodeUTF32Stateful
_TEXT	SEGMENT
iorder$1$ = 96
iorder$2$ = 100
q$ = 104
unicode$ = 112
outpos$ = 120
exc$ = 128
errorHandler$ = 136
starts$ = 144
e$ = 152
iorder$3$ = 240
endinpos$ = 240
s$ = 240
iorder$4$ = 248
startinpos$ = 248
size$ = 248
errors$ = 256
byteorder$ = 264
consumed$ = 272
PyUnicode_DecodeUTF32Stateful PROC			; COMDAT

; 5070 : {

$LN52:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	55		 push	 rbp
  0000b	53		 push	 rbx
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	41 54		 push	 r12
  00010	41 55		 push	 r13
  00012	41 56		 push	 r14
  00014	41 57		 push	 r15
  00016	48 8d 6c 24 e9	 lea	 rbp, QWORD PTR [rsp-23]
  0001b	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 5071 :     const char *starts = s;
; 5072 :     Py_ssize_t startinpos;
; 5073 :     Py_ssize_t endinpos;
; 5074 :     Py_ssize_t outpos;
; 5075 :     PyObject *unicode;
; 5076 :     const unsigned char *q, *e;
; 5077 :     int bo = 0;       /* assume native ordering by default */

  00022	45 33 e4	 xor	 r12d, r12d
  00025	4c 8b f2	 mov	 r14, rdx

; 5078 :     const char *errmsg = "";
; 5079 :     /* Offsets from q for retrieving bytes in the right order. */
; 5080 : #ifdef BYTEORDER_IS_LITTLE_ENDIAN
; 5081 :     int iorder[] = {0, 1, 2, 3};

  00028	41 b8 03 00 00
	00		 mov	 r8d, 3

; 5082 : #else
; 5083 :     int iorder[] = {3, 2, 1, 0};
; 5084 : #endif
; 5085 :     PyObject *errorHandler = NULL;
; 5086 :     PyObject *exc = NULL;
; 5087 : 
; 5088 :     q = (unsigned char *)s;
; 5089 :     e = q + size;

  0002e	4a 8d 3c 31	 lea	 rdi, QWORD PTR [rcx+r14]
  00032	ba 02 00 00 00	 mov	 edx, 2
  00037	48 8b f1	 mov	 rsi, rcx
  0003a	48 89 4d ff	 mov	 QWORD PTR starts$[rbp-145], rcx
  0003e	45 8b fc	 mov	 r15d, r12d
  00041	44 89 65 cf	 mov	 DWORD PTR iorder$1$[rbp-145], r12d
  00045	48 89 7d 07	 mov	 QWORD PTR e$[rbp-145], rdi
  00049	c7 45 d3 01 00
	00 00		 mov	 DWORD PTR iorder$2$[rbp-145], 1
  00050	89 55 5f	 mov	 DWORD PTR iorder$3$[rbp-145], edx
  00053	44 89 45 67	 mov	 DWORD PTR iorder$4$[rbp-145], r8d
  00057	4c 89 65 f7	 mov	 QWORD PTR errorHandler$[rbp-145], r12
  0005b	45 8b ec	 mov	 r13d, r12d
  0005e	4c 89 65 ef	 mov	 QWORD PTR exc$[rbp-145], r12
  00062	48 8b d9	 mov	 rbx, rcx
  00065	48 89 4d d7	 mov	 QWORD PTR q$[rbp-145], rcx

; 5090 : 
; 5091 :     if (byteorder)

  00069	4d 85 c9	 test	 r9, r9
  0006c	74 16		 je	 SHORT $LN46@PyUnicode_@67

; 5092 :         bo = *byteorder;

  0006e	45 8b 39	 mov	 r15d, DWORD PTR [r9]

; 5093 : 
; 5094 :     /* Check for BOM marks (U+FEFF) in the input and adjust current
; 5095 :        byte order setting accordingly. In native mode, the leading BOM
; 5096 :        mark is skipped, in all other modes, it is copied to the output
; 5097 :        stream as-is (giving a ZWNBSP character). */
; 5098 :     if (bo == 0) {

  00071	45 85 ff	 test	 r15d, r15d
  00074	74 0e		 je	 SHORT $LN46@PyUnicode_@67

; 5110 :             }
; 5111 : #else
; 5112 :             if (bom == 0x0000FEFF) {
; 5113 :                 q += 4;
; 5114 :                 bo = 1;
; 5115 :             }
; 5116 :             else if (bom == 0xFFFE0000) {
; 5117 :                 q += 4;
; 5118 :                 bo = -1;
; 5119 :             }
; 5120 : #endif
; 5121 :         }
; 5122 :     }
; 5123 : 
; 5124 :     if (bo == -1) {

  00076	41 83 ff ff	 cmp	 r15d, -1
  0007a	74 40		 je	 SHORT $LN47@PyUnicode_@67

; 5130 :     }
; 5131 :     else if (bo == 1) {

  0007c	41 83 ff 01	 cmp	 r15d, 1
  00080	75 76		 jne	 SHORT $LN29@PyUnicode_@67
  00082	eb 62		 jmp	 SHORT $LN48@PyUnicode_@67
$LN46@PyUnicode_@67:

; 5099 :         if (size >= 4) {

  00084	49 83 fe 04	 cmp	 r14, 4
  00088	7c 6e		 jl	 SHORT $LN29@PyUnicode_@67

; 5100 :             const Py_UCS4 bom = (q[iorder[3]] << 24) | (q[iorder[2]] << 16) |
; 5101 :                 (q[iorder[1]] << 8) | q[iorder[0]];

  0008a	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  0008e	0f b6 46 02	 movzx	 eax, BYTE PTR [rsi+2]
  00092	c1 e1 08	 shl	 ecx, 8
  00095	0b c8		 or	 ecx, eax
  00097	0f b6 46 01	 movzx	 eax, BYTE PTR [rsi+1]
  0009b	c1 e1 08	 shl	 ecx, 8
  0009e	0b c8		 or	 ecx, eax
  000a0	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  000a3	c1 e1 08	 shl	 ecx, 8
  000a6	0b c8		 or	 ecx, eax

; 5102 : #ifdef BYTEORDER_IS_LITTLE_ENDIAN
; 5103 :             if (bom == 0x0000FEFF) {

  000a8	81 f9 ff fe 00
	00		 cmp	 ecx, 65279		; 0000feffH
  000ae	75 20		 jne	 SHORT $LN34@PyUnicode_@67

; 5104 :                 q += 4;

  000b0	48 8d 5e 04	 lea	 rbx, QWORD PTR [rsi+4]

; 5105 :                 bo = -1;

  000b4	41 83 cf ff	 or	 r15d, -1
  000b8	48 89 5d d7	 mov	 QWORD PTR q$[rbp-145], rbx
$LN47@PyUnicode_@67:

; 5125 :         /* force LE */
; 5126 :         iorder[0] = 0;

  000bc	44 89 65 cf	 mov	 DWORD PTR iorder$1$[rbp-145], r12d

; 5127 :         iorder[1] = 1;

  000c0	c7 45 d3 01 00
	00 00		 mov	 DWORD PTR iorder$2$[rbp-145], 1

; 5128 :         iorder[2] = 2;

  000c7	89 55 5f	 mov	 DWORD PTR iorder$3$[rbp-145], edx

; 5129 :         iorder[3] = 3;

  000ca	44 89 45 67	 mov	 DWORD PTR iorder$4$[rbp-145], r8d
  000ce	eb 28		 jmp	 SHORT $LN29@PyUnicode_@67
$LN34@PyUnicode_@67:

; 5106 :             }
; 5107 :             else if (bom == 0xFFFE0000) {

  000d0	81 f9 00 00 fe
	ff		 cmp	 ecx, -131072		; fffe0000H
  000d6	75 20		 jne	 SHORT $LN29@PyUnicode_@67

; 5108 :                 q += 4;

  000d8	48 8d 5e 04	 lea	 rbx, QWORD PTR [rsi+4]

; 5109 :                 bo = 1;

  000dc	41 bf 01 00 00
	00		 mov	 r15d, 1
  000e2	48 89 5d d7	 mov	 QWORD PTR q$[rbp-145], rbx
$LN48@PyUnicode_@67:

; 5132 :         /* force BE */
; 5133 :         iorder[0] = 3;

  000e6	44 89 45 cf	 mov	 DWORD PTR iorder$1$[rbp-145], r8d

; 5134 :         iorder[1] = 2;

  000ea	89 55 d3	 mov	 DWORD PTR iorder$2$[rbp-145], edx

; 5135 :         iorder[2] = 1;

  000ed	c7 45 5f 01 00
	00 00		 mov	 DWORD PTR iorder$3$[rbp-145], 1

; 5136 :         iorder[3] = 0;

  000f4	44 89 65 67	 mov	 DWORD PTR iorder$4$[rbp-145], r12d
$LN29@PyUnicode_@67:

; 5137 :     }
; 5138 : 
; 5139 :     /* This might be one to much, because of a BOM */
; 5140 :     unicode = PyUnicode_New((size+3)/4, 127);

  000f8	49 8d 46 03	 lea	 rax, QWORD PTR [r14+3]
  000fc	48 99		 cdq
  000fe	41 23 d0	 and	 edx, r8d
  00101	48 8d 0c 02	 lea	 rcx, QWORD PTR [rdx+rax]
  00105	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  0010a	48 c1 f9 02	 sar	 rcx, 2
  0010e	e8 00 00 00 00	 call	 PyUnicode_New
  00113	48 89 45 df	 mov	 QWORD PTR unicode$[rbp-145], rax

; 5141 :     if (!unicode)

  00117	48 85 c0	 test	 rax, rax

; 5142 :         return NULL;

  0011a	0f 84 92 01 00
	00		 je	 $LN3@PyUnicode_@67

; 5143 :     if (size == 0)

  00120	4d 85 f6	 test	 r14, r14

; 5144 :         return unicode;

  00123	0f 84 ba 01 00
	00		 je	 $LN38@PyUnicode_@67

; 5145 :     outpos = 0;
; 5146 : 
; 5147 :     while (q < e) {

  00129	4c 8b 75 7f	 mov	 r14, QWORD PTR consumed$[rbp-145]
  0012d	49 8b d4	 mov	 rdx, r12
  00130	48 89 55 e7	 mov	 QWORD PTR outpos$[rbp-145], rdx
  00134	48 3b df	 cmp	 rbx, rdi
  00137	0f 83 2e 01 00
	00		 jae	 $LN25@PyUnicode_@67
  0013d	4c 63 65 5f	 movsxd	 r12, DWORD PTR iorder$3$[rbp-145]
  00141	4c 63 6d 67	 movsxd	 r13, DWORD PTR iorder$4$[rbp-145]
  00145	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL26@PyUnicode_@67:

; 5148 :         Py_UCS4 ch;
; 5149 :         /* remaining bytes at the end? (size should be divisible by 4) */
; 5150 :         if (e-q<4) {

  00150	48 8b c7	 mov	 rax, rdi
  00153	48 2b c3	 sub	 rax, rbx
  00156	48 83 f8 04	 cmp	 rax, 4
  0015a	7d 1c		 jge	 SHORT $LN24@PyUnicode_@67

; 5151 :             if (consumed)

  0015c	4d 85 f6	 test	 r14, r14
  0015f	0f 85 fa 00 00
	00		 jne	 $LN49@PyUnicode_@67

; 5152 :                 break;
; 5153 :             errmsg = "truncated data";
; 5154 :             startinpos = ((const char *)q)-starts;

  00165	48 2b de	 sub	 rbx, rsi

; 5155 :             endinpos = ((const char *)e)-starts;

  00168	48 2b fe	 sub	 rdi, rsi
  0016b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0P@LDIBFBIO@truncated?5data?$AA@
  00172	48 89 7d 5f	 mov	 QWORD PTR endinpos$[rbp-145], rdi

; 5156 :             goto utf32Error;

  00176	eb 4f		 jmp	 SHORT $LN51@PyUnicode_@67
$LN24@PyUnicode_@67:

; 5157 :             /* The remaining input chars are ignored if the callback
; 5158 :                chooses to skip the input */
; 5159 :         }
; 5160 :         ch = (q[iorder[3]] << 24) | (q[iorder[2]] << 16) |
; 5161 :             (q[iorder[1]] << 8) | q[iorder[0]];

  00178	41 0f b6 0c 1c	 movzx	 ecx, BYTE PTR [r12+rbx]
  0017d	48 63 45 d3	 movsxd	 rax, DWORD PTR iorder$2$[rbp-145]
  00181	45 0f b6 44 1d
	00		 movzx	 r8d, BYTE PTR [r13+rbx]
  00187	41 c1 e0 08	 shl	 r8d, 8
  0018b	44 0b c1	 or	 r8d, ecx
  0018e	0f b6 0c 18	 movzx	 ecx, BYTE PTR [rax+rbx]
  00192	48 63 45 cf	 movsxd	 rax, DWORD PTR iorder$1$[rbp-145]
  00196	41 c1 e0 08	 shl	 r8d, 8
  0019a	44 0b c1	 or	 r8d, ecx
  0019d	0f b6 0c 18	 movzx	 ecx, BYTE PTR [rax+rbx]
  001a1	41 c1 e0 08	 shl	 r8d, 8
  001a5	44 0b c1	 or	 r8d, ecx

; 5162 : 
; 5163 :         if (ch >= 0x110000)

  001a8	41 81 f8 00 00
	11 00		 cmp	 r8d, 1114112		; 00110000H
  001af	0f 82 88 00 00
	00		 jb	 $LN22@PyUnicode_@67

; 5164 :         {
; 5165 :             errmsg = "codepoint not in range(0x110000)";
; 5166 :             startinpos = ((const char *)q)-starts;

  001b5	48 2b de	 sub	 rbx, rsi
  001b8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0CB@LOLOEEIM@codepoint?5not?5in?5range?$CI0x110000?$CJ@

; 5167 :             endinpos = startinpos+4;

  001bf	48 8d 43 04	 lea	 rax, QWORD PTR [rbx+4]
  001c3	48 89 45 5f	 mov	 QWORD PTR endinpos$[rbp-145], rax
$LN51@PyUnicode_@67:

; 5173 :         continue;
; 5174 :       utf32Error:
; 5175 :         if (unicode_decode_call_errorhandler(
; 5176 :                 errors, &errorHandler,
; 5177 :                 "utf32", errmsg,
; 5178 :                 &starts, (const char **)&e, &startinpos, &endinpos, &exc, (const char **)&q,
; 5179 :                 &unicode, &outpos))

  001c7	48 8b 4d 6f	 mov	 rcx, QWORD PTR errors$[rbp-145]
  001cb	48 8d 45 e7	 lea	 rax, QWORD PTR outpos$[rbp-145]
  001cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05MMJACDEG@utf32?$AA@
  001d6	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  001db	48 8d 45 df	 lea	 rax, QWORD PTR unicode$[rbp-145]
  001df	48 8d 55 f7	 lea	 rdx, QWORD PTR errorHandler$[rbp-145]
  001e3	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  001e8	48 8d 45 d7	 lea	 rax, QWORD PTR q$[rbp-145]
  001ec	48 89 5d 67	 mov	 QWORD PTR startinpos$[rbp-145], rbx
  001f0	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  001f5	48 8d 45 ef	 lea	 rax, QWORD PTR exc$[rbp-145]
$utf32Error$131231:
  001f9	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  001fe	48 8d 45 5f	 lea	 rax, QWORD PTR endinpos$[rbp-145]
  00202	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00207	48 8d 45 67	 lea	 rax, QWORD PTR startinpos$[rbp-145]
  0020b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00210	48 8d 45 07	 lea	 rax, QWORD PTR e$[rbp-145]
  00214	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00219	48 8d 45 ff	 lea	 rax, QWORD PTR starts$[rbp-145]
  0021d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00222	e8 00 00 00 00	 call	 unicode_decode_call_errorhandler
  00227	85 c0		 test	 eax, eax
  00229	0f 85 87 00 00
	00		 jne	 $LN50@PyUnicode_@67

; 5180 :             goto onError;
; 5181 :     }

  0022f	48 8b 75 ff	 mov	 rsi, QWORD PTR starts$[rbp-145]
  00233	48 8b 5d d7	 mov	 rbx, QWORD PTR q$[rbp-145]
  00237	48 8b 7d 07	 mov	 rdi, QWORD PTR e$[rbp-145]
  0023b	eb 19		 jmp	 SHORT $LN45@PyUnicode_@67
$LN22@PyUnicode_@67:

; 5168 :             goto utf32Error;
; 5169 :         }
; 5170 :         if (unicode_putchar(&unicode, &outpos, ch) < 0)

  0023d	48 8d 55 e7	 lea	 rdx, QWORD PTR outpos$[rbp-145]
  00241	48 8d 4d df	 lea	 rcx, QWORD PTR unicode$[rbp-145]
  00245	e8 00 00 00 00	 call	 unicode_putchar
  0024a	85 c0		 test	 eax, eax
  0024c	78 68		 js	 SHORT $LN50@PyUnicode_@67

; 5171 :             goto onError;
; 5172 :         q += 4;

  0024e	48 83 c3 04	 add	 rbx, 4
  00252	48 89 5d d7	 mov	 QWORD PTR q$[rbp-145], rbx
$LN45@PyUnicode_@67:

; 5145 :     outpos = 0;
; 5146 : 
; 5147 :     while (q < e) {

  00256	48 3b df	 cmp	 rbx, rdi
  00259	0f 82 f1 fe ff
	ff		 jb	 $LL26@PyUnicode_@67
$LN49@PyUnicode_@67:
  0025f	4c 8b 65 f7	 mov	 r12, QWORD PTR errorHandler$[rbp-145]
  00263	4c 8b 6d ef	 mov	 r13, QWORD PTR exc$[rbp-145]
  00267	48 8b 55 e7	 mov	 rdx, QWORD PTR outpos$[rbp-145]
$LN25@PyUnicode_@67:

; 5182 : 
; 5183 :     if (byteorder)

  0026b	48 8b 45 77	 mov	 rax, QWORD PTR byteorder$[rbp-145]
  0026f	48 85 c0	 test	 rax, rax
  00272	74 03		 je	 SHORT $LN19@PyUnicode_@67

; 5184 :         *byteorder = bo;

  00274	44 89 38	 mov	 DWORD PTR [rax], r15d
$LN19@PyUnicode_@67:

; 5185 : 
; 5186 :     if (consumed)

  00277	4d 85 f6	 test	 r14, r14
  0027a	74 06		 je	 SHORT $LN18@PyUnicode_@67

; 5187 :         *consumed = (const char *)q-starts;

  0027c	48 2b de	 sub	 rbx, rsi
  0027f	49 89 1e	 mov	 QWORD PTR [r14], rbx
$LN18@PyUnicode_@67:

; 5188 : 
; 5189 :     /* Adjust length */
; 5190 :     if (unicode_resize(&unicode, outpos) < 0)

  00282	48 8d 4d df	 lea	 rcx, QWORD PTR unicode$[rbp-145]
  00286	e8 00 00 00 00	 call	 unicode_resize
  0028b	85 c0		 test	 eax, eax
  0028d	79 31		 jns	 SHORT $LN16@PyUnicode_@67
$onError$131236:

; 5196 : 
; 5197 :   onError:
; 5198 :     Py_DECREF(unicode);

  0028f	48 8b 4d df	 mov	 rcx, QWORD PTR unicode$[rbp-145]
  00293	e8 00 00 00 00	 call	 _Py_DecRef

; 5199 :     Py_XDECREF(errorHandler);

  00298	4d 85 e4	 test	 r12, r12
  0029b	74 08		 je	 SHORT $LN7@PyUnicode_@67
  0029d	49 8b cc	 mov	 rcx, r12
  002a0	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@PyUnicode_@67:

; 5200 :     Py_XDECREF(exc);

  002a5	4d 85 ed	 test	 r13, r13
  002a8	74 08		 je	 SHORT $LN3@PyUnicode_@67
  002aa	49 8b cd	 mov	 rcx, r13
  002ad	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyUnicode_@67:

; 5201 :     return NULL;

  002b2	33 c0		 xor	 eax, eax
  002b4	eb 2d		 jmp	 SHORT $LN38@PyUnicode_@67
$LN50@PyUnicode_@67:

; 5188 : 
; 5189 :     /* Adjust length */
; 5190 :     if (unicode_resize(&unicode, outpos) < 0)

  002b6	4c 8b 65 f7	 mov	 r12, QWORD PTR errorHandler$[rbp-145]
  002ba	4c 8b 6d ef	 mov	 r13, QWORD PTR exc$[rbp-145]
  002be	eb cf		 jmp	 SHORT $onError$131236
$LN16@PyUnicode_@67:

; 5191 :         goto onError;
; 5192 : 
; 5193 :     Py_XDECREF(errorHandler);

  002c0	4d 85 e4	 test	 r12, r12
  002c3	74 08		 je	 SHORT $LN15@PyUnicode_@67
  002c5	49 8b cc	 mov	 rcx, r12
  002c8	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@PyUnicode_@67:

; 5194 :     Py_XDECREF(exc);

  002cd	4d 85 ed	 test	 r13, r13
  002d0	74 08		 je	 SHORT $LN11@PyUnicode_@67
  002d2	49 8b cd	 mov	 rcx, r13
  002d5	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@PyUnicode_@67:

; 5195 :     return unicode_result(unicode);

  002da	48 8b 4d df	 mov	 rcx, QWORD PTR unicode$[rbp-145]
  002de	e8 00 00 00 00	 call	 unicode_result
$LN38@PyUnicode_@67:

; 5202 : }

  002e3	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002ea	41 5f		 pop	 r15
  002ec	41 5e		 pop	 r14
  002ee	41 5d		 pop	 r13
  002f0	41 5c		 pop	 r12
  002f2	5f		 pop	 rdi
  002f3	5e		 pop	 rsi
  002f4	5b		 pop	 rbx
  002f5	5d		 pop	 rbp
  002f6	c3		 ret	 0
PyUnicode_DecodeUTF32Stateful ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_EncodeUTF32
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_EncodeUTF32 DD imagerel $LN4
	DD	imagerel $LN4+94
	DD	imagerel $unwind$PyUnicode_EncodeUTF32
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_EncodeUTF32 DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_EncodeUTF32
_TEXT	SEGMENT
s$ = 48
size$ = 56
errors$ = 64
byteorder$ = 72
PyUnicode_EncodeUTF32 PROC				; COMDAT

; 5282 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	41 8b d9	 mov	 ebx, r9d
  00012	49 8b f0	 mov	 rsi, r8

; 5283 :     PyObject *result;
; 5284 :     PyObject *tmp = PyUnicode_FromUnicode(s, size);

  00015	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  0001a	48 8b f8	 mov	 rdi, rax

; 5285 :     if (tmp == NULL)

  0001d	48 85 c0	 test	 rax, rax
  00020	75 10		 jne	 SHORT $LN1@PyUnicode_@68

; 5289 :     return result;
; 5290 : }

  00022	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00027	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN1@PyUnicode_@68:

; 5286 :         return NULL;
; 5287 :     result = _PyUnicode_EncodeUTF32(tmp, errors, byteorder);

  00032	44 8b c3	 mov	 r8d, ebx
  00035	48 8b d6	 mov	 rdx, rsi
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 _PyUnicode_EncodeUTF32

; 5288 :     Py_DECREF(tmp);

  00040	48 8b cf	 mov	 rcx, rdi
  00043	48 8b d8	 mov	 rbx, rax
  00046	e8 00 00 00 00	 call	 _Py_DecRef

; 5289 :     return result;
; 5290 : }

  0004b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00050	48 8b c3	 mov	 rax, rbx
  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
PyUnicode_EncodeUTF32 ENDP
_TEXT	ENDS
PUBLIC	??_C@_05KLHIDCCM@utf16?$AA@			; `string'
PUBLIC	??_C@_0BB@LCHBJKAI@illegal?5encoding?$AA@	; `string'
PUBLIC	??_C@_0BJ@NADHAKBN@illegal?5UTF?916?5surrogate?$AA@ ; `string'
PUBLIC	PyUnicode_DecodeUTF16Stateful
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_DecodeUTF16Stateful DD imagerel $LN91
	DD	imagerel $LN91+210
	DD	imagerel $unwind$PyUnicode_DecodeUTF16Stateful
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyUnicode_DecodeUTF16Stateful DD imagerel $LN91+210
	DD	imagerel $LN91+273
	DD	imagerel $chain$0$PyUnicode_DecodeUTF16Stateful
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyUnicode_DecodeUTF16Stateful DD imagerel $LN91+273
	DD	imagerel $LN91+945
	DD	imagerel $chain$1$PyUnicode_DecodeUTF16Stateful
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyUnicode_DecodeUTF16Stateful DD imagerel $LN91+945
	DD	imagerel $LN91+953
	DD	imagerel $chain$2$PyUnicode_DecodeUTF16Stateful
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyUnicode_DecodeUTF16Stateful DD imagerel $LN91+953
	DD	imagerel $LN91+967
	DD	imagerel $chain$3$PyUnicode_DecodeUTF16Stateful
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyUnicode_DecodeUTF16Stateful DD 021H
	DD	imagerel $LN91
	DD	imagerel $LN91+210
	DD	imagerel $unwind$PyUnicode_DecodeUTF16Stateful
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyUnicode_DecodeUTF16Stateful DD 021H
	DD	imagerel $LN91+210
	DD	imagerel $LN91+273
	DD	imagerel $chain$0$PyUnicode_DecodeUTF16Stateful
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyUnicode_DecodeUTF16Stateful DD 020821H
	DD	013c408H
	DD	imagerel $LN91+210
	DD	imagerel $LN91+273
	DD	imagerel $chain$0$PyUnicode_DecodeUTF16Stateful
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyUnicode_DecodeUTF16Stateful DD 020821H
	DD	012d408H
	DD	imagerel $LN91
	DD	imagerel $LN91+210
	DD	imagerel $unwind$PyUnicode_DecodeUTF16Stateful
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_DecodeUTF16Stateful DD 071301H
	DD	0140113H
	DD	07005e007H
	DD	030036004H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_05KLHIDCCM@utf16?$AA@
CONST	SEGMENT
??_C@_05KLHIDCCM@utf16?$AA@ DB 'utf16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LCHBJKAI@illegal?5encoding?$AA@
CONST	SEGMENT
??_C@_0BB@LCHBJKAI@illegal?5encoding?$AA@ DB 'illegal encoding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NADHAKBN@illegal?5UTF?916?5surrogate?$AA@
CONST	SEGMENT
??_C@_0BJ@NADHAKBN@illegal?5UTF?916?5surrogate?$AA@ DB 'illegal UTF-16 su'
	DB	'rrogate', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_DecodeUTF16Stateful
_TEXT	SEGMENT
endinpos$ = 96
startinpos$ = 104
errorHandler$ = 112
exc$ = 120
starts$ = 128
e$ = 136
q$ = 208
s$ = 208
outpos$ = 216
size$ = 216
errors$ = 224
unicode$ = 232
byteorder$ = 232
consumed$ = 240
PyUnicode_DecodeUTF16Stateful PROC			; COMDAT

; 5315 : {

$LN91:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 56		 push	 r14
  00007	48 8d 6c 24 d1	 lea	 rbp, QWORD PTR [rsp-47]
  0000c	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00013	48 8b f1	 mov	 rsi, rcx

; 5316 :     const char *starts = s;

  00016	48 89 4d 0f	 mov	 QWORD PTR starts$[rbp-113], rcx

; 5317 :     Py_ssize_t startinpos;
; 5318 :     Py_ssize_t endinpos;
; 5319 :     Py_ssize_t outpos;
; 5320 :     PyObject *unicode;
; 5321 :     const unsigned char *q, *e;
; 5322 :     int bo = 0;       /* assume native ordering by default */

  0001a	33 c9		 xor	 ecx, ecx

; 5323 :     int native_ordering;
; 5324 :     const char *errmsg = "";
; 5325 :     PyObject *errorHandler = NULL;
; 5326 :     PyObject *exc = NULL;
; 5327 : 
; 5328 :     q = (unsigned char *)s;
; 5329 :     e = q + size;

  0001c	48 8d 3c 16	 lea	 rdi, QWORD PTR [rsi+rdx]
  00020	48 8b de	 mov	 rbx, rsi
  00023	4d 8b f0	 mov	 r14, r8
  00026	4c 8b d2	 mov	 r10, rdx
  00029	48 89 4d ff	 mov	 QWORD PTR errorHandler$[rbp-113], rcx
  0002d	48 89 4d 07	 mov	 QWORD PTR exc$[rbp-113], rcx
  00031	48 89 7d 17	 mov	 QWORD PTR e$[rbp-113], rdi
  00035	48 89 5d 5f	 mov	 QWORD PTR q$[rbp-113], rbx

; 5330 : 
; 5331 :     if (byteorder)

  00039	4d 85 c9	 test	 r9, r9
  0003c	74 07		 je	 SHORT $LN83@PyUnicode_@69

; 5332 :         bo = *byteorder;

  0003e	41 8b 09	 mov	 ecx, DWORD PTR [r9]

; 5333 : 
; 5334 :     /* Check for BOM marks (U+FEFF) in the input and adjust current
; 5335 :        byte order setting accordingly. In native mode, the leading BOM
; 5336 :        mark is skipped, in all other modes, it is copied to the output
; 5337 :        stream as-is (giving a ZWNBSP character). */
; 5338 :     if (bo == 0 && size >= 2) {

  00041	85 c9		 test	 ecx, ecx
  00043	75 3c		 jne	 SHORT $LN52@PyUnicode_@69
$LN83@PyUnicode_@69:
  00045	48 83 fa 02	 cmp	 rdx, 2
  00049	7c 36		 jl	 SHORT $LN52@PyUnicode_@69

; 5339 :         const Py_UCS4 bom = (q[1] << 8) | q[0];

  0004b	0f b6 56 01	 movzx	 edx, BYTE PTR [rsi+1]
  0004f	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00052	c1 e2 08	 shl	 edx, 8
  00055	0b d0		 or	 edx, eax

; 5340 :         if (bom == 0xFEFF) {

  00057	81 fa ff fe 00
	00		 cmp	 edx, 65279		; 0000feffH
  0005d	75 05		 jne	 SHORT $LN55@PyUnicode_@69

; 5341 :             q += 2;
; 5342 :             bo = -1;

  0005f	83 c9 ff	 or	 ecx, -1
  00062	eb 0d		 jmp	 SHORT $LN86@PyUnicode_@69
$LN55@PyUnicode_@69:

; 5343 :         }
; 5344 :         else if (bom == 0xFFFE) {

  00064	81 fa fe ff 00
	00		 cmp	 edx, 65534		; 0000fffeH
  0006a	75 0d		 jne	 SHORT $LN53@PyUnicode_@69

; 5346 :             bo = 1;

  0006c	b9 01 00 00 00	 mov	 ecx, 1
$LN86@PyUnicode_@69:

; 5345 :             q += 2;

  00071	48 8d 5e 02	 lea	 rbx, QWORD PTR [rsi+2]
  00075	48 89 5d 5f	 mov	 QWORD PTR q$[rbp-113], rbx
$LN53@PyUnicode_@69:

; 5347 :         }
; 5348 :         if (byteorder)

  00079	4d 85 c9	 test	 r9, r9
  0007c	74 03		 je	 SHORT $LN52@PyUnicode_@69

; 5349 :             *byteorder = bo;

  0007e	41 89 09	 mov	 DWORD PTR [r9], ecx
$LN52@PyUnicode_@69:

; 5350 :     }
; 5351 : 
; 5352 :     if (q == e) {

  00081	48 3b df	 cmp	 rbx, rdi
  00084	75 4c		 jne	 SHORT $LN47@PyUnicode_@69

; 5353 :         if (consumed)

  00086	48 8b 45 7f	 mov	 rax, QWORD PTR consumed$[rbp-113]
  0008a	48 85 c0	 test	 rax, rax
  0008d	74 03		 je	 SHORT $LN49@PyUnicode_@69

; 5354 :             *consumed = size;

  0008f	4c 89 10	 mov	 QWORD PTR [rax], r10
$LN49@PyUnicode_@69:

; 5355 :         _Py_RETURN_UNICODE_EMPTY();

  00092	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  00099	48 85 c9	 test	 rcx, rcx
  0009c	75 1a		 jne	 SHORT $LN87@PyUnicode_@69
  0009e	33 d2		 xor	 edx, edx
  000a0	e8 00 00 00 00	 call	 PyUnicode_New
  000a5	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  000ac	48 85 c0	 test	 rax, rax
  000af	0f 84 04 03 00
	00		 je	 $LN58@PyUnicode_@69
  000b5	48 8b c8	 mov	 rcx, rax
$LN87@PyUnicode_@69:
  000b8	e8 00 00 00 00	 call	 _Py_IncRef
  000bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 5464 : }

  000c4	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  000cb	41 5e		 pop	 r14
  000cd	5f		 pop	 rdi
  000ce	5e		 pop	 rsi
  000cf	5b		 pop	 rbx
  000d0	5d		 pop	 rbp
  000d1	c3		 ret	 0
$LN47@PyUnicode_@69:
  000d2	4c 89 ac 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], r13

; 5356 :     }
; 5357 : 
; 5358 : #ifdef BYTEORDER_IS_LITTLE_ENDIAN
; 5359 :     native_ordering = bo <= 0;

  000da	45 33 ed	 xor	 r13d, r13d
  000dd	85 c9		 test	 ecx, ecx
  000df	41 0f 9e c5	 setle	 r13b

; 5360 : #else
; 5361 :     native_ordering = bo >= 0;
; 5362 : #endif
; 5363 : 
; 5364 :     /* Note: size will always be longer than the resulting Unicode
; 5365 :        character count */
; 5366 :     unicode = PyUnicode_New((e - q + 1) / 2, 127);

  000e3	48 8b c7	 mov	 rax, rdi
  000e6	48 2b c3	 sub	 rax, rbx
  000e9	48 ff c0	 inc	 rax
  000ec	48 99		 cdq
  000ee	48 2b c2	 sub	 rax, rdx
  000f1	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  000f6	48 d1 f8	 sar	 rax, 1
  000f9	48 8b c8	 mov	 rcx, rax
  000fc	e8 00 00 00 00	 call	 PyUnicode_New
  00101	4c 8b d8	 mov	 r11, rax
  00104	48 89 45 77	 mov	 QWORD PTR unicode$[rbp-113], rax

; 5367 :     if (!unicode)

  00108	48 85 c0	 test	 rax, rax
  0010b	0f 84 a0 02 00
	00		 je	 $LN84@PyUnicode_@69
$LN40@PyUnicode_@69:
  00111	4c 89 a4 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], r12

; 5368 :         return NULL;
; 5369 : 
; 5370 :     outpos = 0;

  00119	4c 8b 65 7f	 mov	 r12, QWORD PTR consumed$[rbp-113]
  0011d	48 c7 45 67 00
	00 00 00	 mov	 QWORD PTR outpos$[rbp-113], 0
  00125	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL39@PyUnicode_@69:

; 5371 :     while (1) {
; 5372 :         Py_UCS4 ch = 0;
; 5373 :         if (e - q >= 2) {

  00130	48 8b c7	 mov	 rax, rdi
  00133	45 33 c0	 xor	 r8d, r8d
  00136	48 2b c3	 sub	 rax, rbx
  00139	48 83 f8 02	 cmp	 rax, 2
  0013d	0f 8c e4 00 00
	00		 jl	 $LN31@PyUnicode_@69

; 5374 :             int kind = PyUnicode_KIND(unicode);

  00143	41 8b 43 70	 mov	 eax, DWORD PTR [r11+112]
  00147	8b c8		 mov	 ecx, eax
  00149	c1 e9 02	 shr	 ecx, 2
  0014c	83 e1 07	 and	 ecx, 7

; 5375 :             if (kind == PyUnicode_1BYTE_KIND) {

  0014f	83 f9 01	 cmp	 ecx, 1
  00152	75 59		 jne	 SHORT $LN36@PyUnicode_@69

; 5376 :                 if (PyUnicode_IS_ASCII(unicode))

  00154	a8 40		 test	 al, 64			; 00000040H
  00156	74 2c		 je	 SHORT $LN35@PyUnicode_@69

; 5377 :                     ch = asciilib_utf16_decode(&q, e,
; 5378 :                             PyUnicode_1BYTE_DATA(unicode), &outpos,
; 5379 :                             native_ordering);

  00158	4d 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [r11+128]
  0015f	a8 20		 test	 al, 32			; 00000020H
  00161	75 07		 jne	 SHORT $LN63@PyUnicode_@69
  00163	4d 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [r11+160]
$LN63@PyUnicode_@69:
  0016a	4c 8d 4d 67	 lea	 r9, QWORD PTR outpos$[rbp-113]
  0016e	48 8d 4d 5f	 lea	 rcx, QWORD PTR q$[rbp-113]
  00172	48 8b d7	 mov	 rdx, rdi
  00175	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  0017a	e8 00 00 00 00	 call	 asciilib_utf16_decode

; 5380 :                 else

  0017f	e9 9c 00 00 00	 jmp	 $LN88@PyUnicode_@69
$LN35@PyUnicode_@69:

; 5381 :                     ch = ucs1lib_utf16_decode(&q, e,
; 5382 :                             PyUnicode_1BYTE_DATA(unicode), &outpos,
; 5383 :                             native_ordering);

  00184	4d 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [r11+160]
  0018b	a8 20		 test	 al, 32			; 00000020H
  0018d	75 07		 jne	 SHORT $LN67@PyUnicode_@69
  0018f	4d 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [r11+160]
$LN67@PyUnicode_@69:
  00196	4c 8d 4d 67	 lea	 r9, QWORD PTR outpos$[rbp-113]
  0019a	48 8d 4d 5f	 lea	 rcx, QWORD PTR q$[rbp-113]
  0019e	48 8b d7	 mov	 rdx, rdi
  001a1	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  001a6	e8 00 00 00 00	 call	 ucs1lib_utf16_decode

; 5384 :             } else if (kind == PyUnicode_2BYTE_KIND) {

  001ab	eb 73		 jmp	 SHORT $LN88@PyUnicode_@69
$LN36@PyUnicode_@69:
  001ad	83 f9 02	 cmp	 ecx, 2
  001b0	75 38		 jne	 SHORT $LN32@PyUnicode_@69

; 5385 :                 ch = ucs2lib_utf16_decode(&q, e,
; 5386 :                         PyUnicode_2BYTE_DATA(unicode), &outpos,
; 5387 :                         native_ordering);

  001b2	a8 20		 test	 al, 32			; 00000020H
  001b4	74 16		 je	 SHORT $LN70@PyUnicode_@69
  001b6	a8 40		 test	 al, 64			; 00000040H
  001b8	74 09		 je	 SHORT $LN68@PyUnicode_@69
  001ba	4d 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [r11+128]
  001c1	eb 10		 jmp	 SHORT $LN71@PyUnicode_@69
$LN68@PyUnicode_@69:
  001c3	4d 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [r11+160]
  001ca	eb 07		 jmp	 SHORT $LN71@PyUnicode_@69
$LN70@PyUnicode_@69:
  001cc	4d 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [r11+160]
$LN71@PyUnicode_@69:
  001d3	4c 8d 4d 67	 lea	 r9, QWORD PTR outpos$[rbp-113]
  001d7	48 8d 4d 5f	 lea	 rcx, QWORD PTR q$[rbp-113]
  001db	48 8b d7	 mov	 rdx, rdi
  001de	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  001e3	e8 00 00 00 00	 call	 ucs2lib_utf16_decode

; 5388 :             } else {

  001e8	eb 36		 jmp	 SHORT $LN88@PyUnicode_@69
$LN32@PyUnicode_@69:

; 5389 :                 assert(kind == PyUnicode_4BYTE_KIND);
; 5390 :                 ch = ucs4lib_utf16_decode(&q, e,
; 5391 :                         PyUnicode_4BYTE_DATA(unicode), &outpos,
; 5392 :                         native_ordering);

  001ea	a8 20		 test	 al, 32			; 00000020H
  001ec	74 16		 je	 SHORT $LN74@PyUnicode_@69
  001ee	a8 40		 test	 al, 64			; 00000040H
  001f0	74 09		 je	 SHORT $LN72@PyUnicode_@69
  001f2	4d 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [r11+128]
  001f9	eb 10		 jmp	 SHORT $LN75@PyUnicode_@69
$LN72@PyUnicode_@69:
  001fb	4d 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [r11+160]
  00202	eb 07		 jmp	 SHORT $LN75@PyUnicode_@69
$LN74@PyUnicode_@69:
  00204	4d 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [r11+160]
$LN75@PyUnicode_@69:
  0020b	4c 8d 4d 67	 lea	 r9, QWORD PTR outpos$[rbp-113]
  0020f	48 8d 4d 5f	 lea	 rcx, QWORD PTR q$[rbp-113]
  00213	48 8b d7	 mov	 rdx, rdi
  00216	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  0021b	e8 00 00 00 00	 call	 ucs4lib_utf16_decode
$LN88@PyUnicode_@69:
  00220	48 8b 5d 5f	 mov	 rbx, QWORD PTR q$[rbp-113]
  00224	44 8b c0	 mov	 r8d, eax
$LN31@PyUnicode_@69:

; 5393 :             }
; 5394 :         }
; 5395 : 
; 5396 :         switch (ch)

  00227	41 8b c0	 mov	 eax, r8d
  0022a	45 85 c0	 test	 r8d, r8d
  0022d	74 74		 je	 SHORT $LN28@PyUnicode_@69
  0022f	ff c8		 dec	 eax
  00231	74 56		 je	 SHORT $LN25@PyUnicode_@69
  00233	ff c8		 dec	 eax
  00235	74 3a		 je	 SHORT $LN23@PyUnicode_@69
  00237	ff c8		 dec	 eax
  00239	74 1e		 je	 SHORT $LN22@PyUnicode_@69

; 5426 :         default:
; 5427 :             if (unicode_putchar(&unicode, &outpos, ch) < 0)

  0023b	48 8d 55 67	 lea	 rdx, QWORD PTR outpos$[rbp-113]
  0023f	48 8d 4d 77	 lea	 rcx, QWORD PTR unicode$[rbp-113]
  00243	e8 00 00 00 00	 call	 unicode_putchar
  00248	85 c0		 test	 eax, eax
  0024a	0f 88 0b 01 00
	00		 js	 $onError$131517

; 5428 :                 goto onError;
; 5429 :             continue;

  00250	4c 8b 5d 77	 mov	 r11, QWORD PTR unicode$[rbp-113]
  00254	e9 d7 fe ff ff	 jmp	 $LL39@PyUnicode_@69
$LN22@PyUnicode_@69:

; 5421 :         case 3:
; 5422 :             errmsg = "illegal UTF-16 surrogate";
; 5423 :             startinpos = ((const char *)q) - 4 - starts;

  00259	48 2b de	 sub	 rbx, rsi
  0025c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BJ@NADHAKBN@illegal?5UTF?916?5surrogate?$AA@
  00263	48 83 eb 04	 sub	 rbx, 4

; 5424 :             endinpos = startinpos + 2;

  00267	48 8d 43 02	 lea	 rax, QWORD PTR [rbx+2]
  0026b	48 89 45 ef	 mov	 QWORD PTR endinpos$[rbp-113], rax

; 5425 :             break;

  0026f	eb 55		 jmp	 SHORT $LN89@PyUnicode_@69
$LN23@PyUnicode_@69:

; 5416 :         case 2:
; 5417 :             errmsg = "illegal encoding";
; 5418 :             startinpos = ((const char *)q) - 2 - starts;

  00271	48 2b de	 sub	 rbx, rsi
  00274	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BB@LCHBJKAI@illegal?5encoding?$AA@
  0027b	48 83 eb 02	 sub	 rbx, 2

; 5419 :             endinpos = startinpos + 2;

  0027f	48 8d 43 02	 lea	 rax, QWORD PTR [rbx+2]
  00283	48 89 45 ef	 mov	 QWORD PTR endinpos$[rbp-113], rax

; 5420 :             break;

  00287	eb 3d		 jmp	 SHORT $LN89@PyUnicode_@69
$LN25@PyUnicode_@69:

; 5405 :             break;
; 5406 :             /* The remaining input chars are ignored if the callback
; 5407 :                chooses to skip the input */
; 5408 :         case 1:
; 5409 :             q -= 2;

  00289	48 83 eb 02	 sub	 rbx, 2
  0028d	48 89 5d 5f	 mov	 QWORD PTR q$[rbp-113], rbx

; 5410 :             if (consumed)

  00291	4d 85 e4	 test	 r12, r12
  00294	0f 85 a9 00 00
	00		 jne	 $LN82@PyUnicode_@69

; 5411 :                 goto End;
; 5412 :             errmsg = "unexpected end of data";

  0029a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BH@OMKFHCNA@unexpected?5end?5of?5data?$AA@

; 5413 :             startinpos = ((const char *)q) - starts;
; 5414 :             endinpos = ((const char *)e) - starts;
; 5415 :             break;

  002a1	eb 19		 jmp	 SHORT $LN90@PyUnicode_@69
$LN28@PyUnicode_@69:

; 5397 :         {
; 5398 :         case 0:
; 5399 :             /* remaining byte at the end? (size should be even) */
; 5400 :             if (q == e || consumed)

  002a3	48 3b df	 cmp	 rbx, rdi
  002a6	0f 84 92 00 00
	00		 je	 $End$131502
  002ac	4d 85 e4	 test	 r12, r12
  002af	0f 85 8e 00 00
	00		 jne	 $LN82@PyUnicode_@69

; 5401 :                 goto End;
; 5402 :             errmsg = "truncated data";

  002b5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0P@LDIBFBIO@truncated?5data?$AA@
$LN90@PyUnicode_@69:

; 5403 :             startinpos = ((const char *)q) - starts;

  002bc	48 2b de	 sub	 rbx, rsi

; 5404 :             endinpos = ((const char *)e) - starts;

  002bf	48 2b fe	 sub	 rdi, rsi
  002c2	48 89 7d ef	 mov	 QWORD PTR endinpos$[rbp-113], rdi
$LN89@PyUnicode_@69:

; 5430 :         }
; 5431 : 
; 5432 :         if (unicode_decode_call_errorhandler(
; 5433 :                 errors,
; 5434 :                 &errorHandler,
; 5435 :                 "utf16", errmsg,
; 5436 :                 &starts,
; 5437 :                 (const char **)&e,
; 5438 :                 &startinpos,
; 5439 :                 &endinpos,
; 5440 :                 &exc,
; 5441 :                 (const char **)&q,
; 5442 :                 &unicode,
; 5443 :                 &outpos))

  002c6	48 8d 45 67	 lea	 rax, QWORD PTR outpos$[rbp-113]
  002ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05KLHIDCCM@utf16?$AA@
  002d1	48 8d 55 ff	 lea	 rdx, QWORD PTR errorHandler$[rbp-113]
  002d5	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  002da	48 8d 45 77	 lea	 rax, QWORD PTR unicode$[rbp-113]
  002de	49 8b ce	 mov	 rcx, r14
  002e1	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  002e6	48 8d 45 5f	 lea	 rax, QWORD PTR q$[rbp-113]
  002ea	48 89 5d f7	 mov	 QWORD PTR startinpos$[rbp-113], rbx
  002ee	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  002f3	48 8d 45 07	 lea	 rax, QWORD PTR exc$[rbp-113]
  002f7	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  002fc	48 8d 45 ef	 lea	 rax, QWORD PTR endinpos$[rbp-113]
  00300	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00305	48 8d 45 f7	 lea	 rax, QWORD PTR startinpos$[rbp-113]
  00309	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0030e	48 8d 45 17	 lea	 rax, QWORD PTR e$[rbp-113]
  00312	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00317	48 8d 45 0f	 lea	 rax, QWORD PTR starts$[rbp-113]
  0031b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00320	e8 00 00 00 00	 call	 unicode_decode_call_errorhandler
  00325	85 c0		 test	 eax, eax
  00327	75 32		 jne	 SHORT $onError$131517

; 5444 :             goto onError;
; 5445 :     }

  00329	48 8b 75 0f	 mov	 rsi, QWORD PTR starts$[rbp-113]
  0032d	48 8b 5d 5f	 mov	 rbx, QWORD PTR q$[rbp-113]
  00331	48 8b 7d 17	 mov	 rdi, QWORD PTR e$[rbp-113]
  00335	4c 8b 5d 77	 mov	 r11, QWORD PTR unicode$[rbp-113]
  00339	e9 f2 fd ff ff	 jmp	 $LL39@PyUnicode_@69
$End$131502:

; 5446 : 
; 5447 : End:
; 5448 :     if (consumed)

  0033e	4d 85 e4	 test	 r12, r12
  00341	74 07		 je	 SHORT $LN18@PyUnicode_@69
$LN82@PyUnicode_@69:

; 5449 :         *consumed = (const char *)q-starts;

  00343	48 2b de	 sub	 rbx, rsi
  00346	49 89 1c 24	 mov	 QWORD PTR [r12], rbx
$LN18@PyUnicode_@69:

; 5450 : 
; 5451 :     /* Adjust length */
; 5452 :     if (unicode_resize(&unicode, outpos) < 0)

  0034a	48 8b 55 67	 mov	 rdx, QWORD PTR outpos$[rbp-113]
  0034e	48 8d 4d 77	 lea	 rcx, QWORD PTR unicode$[rbp-113]
  00352	e8 00 00 00 00	 call	 unicode_resize
  00357	85 c0		 test	 eax, eax
  00359	79 29		 jns	 SHORT $LN16@PyUnicode_@69
$onError$131517:

; 5458 : 
; 5459 :   onError:
; 5460 :     Py_DECREF(unicode);

  0035b	48 8b 4d 77	 mov	 rcx, QWORD PTR unicode$[rbp-113]
  0035f	e8 00 00 00 00	 call	 _Py_DecRef

; 5461 :     Py_XDECREF(errorHandler);

  00364	48 8b 4d ff	 mov	 rcx, QWORD PTR errorHandler$[rbp-113]
  00368	48 85 c9	 test	 rcx, rcx
  0036b	74 05		 je	 SHORT $LN7@PyUnicode_@69
  0036d	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@PyUnicode_@69:

; 5462 :     Py_XDECREF(exc);

  00372	48 8b 4d 07	 mov	 rcx, QWORD PTR exc$[rbp-113]
  00376	48 85 c9	 test	 rcx, rcx
  00379	74 05		 je	 SHORT $LN3@PyUnicode_@69
  0037b	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyUnicode_@69:

; 5463 :     return NULL;

  00380	33 c0		 xor	 eax, eax
  00382	eb 25		 jmp	 SHORT $LN85@PyUnicode_@69
$LN16@PyUnicode_@69:

; 5453 :         goto onError;
; 5454 : 
; 5455 :     Py_XDECREF(errorHandler);

  00384	48 8b 4d ff	 mov	 rcx, QWORD PTR errorHandler$[rbp-113]
  00388	48 85 c9	 test	 rcx, rcx
  0038b	74 05		 je	 SHORT $LN15@PyUnicode_@69
  0038d	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@PyUnicode_@69:

; 5456 :     Py_XDECREF(exc);

  00392	48 8b 4d 07	 mov	 rcx, QWORD PTR exc$[rbp-113]
  00396	48 85 c9	 test	 rcx, rcx
  00399	74 05		 je	 SHORT $LN11@PyUnicode_@69
  0039b	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@PyUnicode_@69:

; 5457 :     return unicode_result(unicode);

  003a0	48 8b 4d 77	 mov	 rcx, QWORD PTR unicode$[rbp-113]
  003a4	e8 00 00 00 00	 call	 unicode_result
$LN85@PyUnicode_@69:
  003a9	4c 8b a4 24 98
	00 00 00	 mov	 r12, QWORD PTR [rsp+152]
$LN84@PyUnicode_@69:
  003b1	4c 8b ac 24 90
	00 00 00	 mov	 r13, QWORD PTR [rsp+144]
$LN58@PyUnicode_@69:

; 5464 : }

  003b9	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  003c0	41 5e		 pop	 r14
  003c2	5f		 pop	 rdi
  003c3	5e		 pop	 rsi
  003c4	5b		 pop	 rbx
  003c5	5d		 pop	 rbp
  003c6	c3		 ret	 0
PyUnicode_DecodeUTF16Stateful ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_EncodeUTF16
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_EncodeUTF16 DD imagerel $LN4
	DD	imagerel $LN4+94
	DD	imagerel $unwind$PyUnicode_EncodeUTF16
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_EncodeUTF16 DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_EncodeUTF16
_TEXT	SEGMENT
s$ = 48
size$ = 56
errors$ = 64
byteorder$ = 72
PyUnicode_EncodeUTF16 PROC				; COMDAT

; 5543 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	41 8b d9	 mov	 ebx, r9d
  00012	49 8b f0	 mov	 rsi, r8

; 5544 :     PyObject *result;
; 5545 :     PyObject *tmp = PyUnicode_FromUnicode(s, size);

  00015	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  0001a	48 8b f8	 mov	 rdi, rax

; 5546 :     if (tmp == NULL)

  0001d	48 85 c0	 test	 rax, rax
  00020	75 10		 jne	 SHORT $LN1@PyUnicode_@70

; 5550 :     return result;
; 5551 : }

  00022	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00027	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN1@PyUnicode_@70:

; 5547 :         return NULL;
; 5548 :     result = _PyUnicode_EncodeUTF16(tmp, errors, byteorder);

  00032	44 8b c3	 mov	 r8d, ebx
  00035	48 8b d6	 mov	 rdx, rsi
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 _PyUnicode_EncodeUTF16

; 5549 :     Py_DECREF(tmp);

  00040	48 8b cf	 mov	 rcx, rdi
  00043	48 8b d8	 mov	 rbx, rax
  00046	e8 00 00 00 00	 call	 _Py_DecRef

; 5550 :     return result;
; 5551 : }

  0004b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00050	48 8b c3	 mov	 rax, rbx
  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
PyUnicode_EncodeUTF16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DJ@LGKNJMG@?2N?5escapes?5not?5supported?5?$CIcan?8t?5@ ; `string'
PUBLIC	??_C@_0O@DEHDHMLA@unicodeescape?$AA@		; `string'
PUBLIC	??_C@_0BD@PGFJKLCK@?2?5at?5end?5of?5string?$AA@	; `string'
PUBLIC	??_C@_0BK@EMHMGOCP@illegal?5Unicode?5character?$AA@ ; `string'
PUBLIC	??_C@_0BP@IDJOAMJF@unknown?5Unicode?5character?5name?$AA@ ; `string'
PUBLIC	??_C@_0BJ@NGMFMDDO@unicodedata?4ucnhash_CAPI?$AA@ ; `string'
PUBLIC	??_C@_0BO@LPKHHNEG@malformed?5?2N?5character?5escape?$AA@ ; `string'
PUBLIC	??_C@_0BM@GKNPCNAC@truncated?5?2UXXXXXXXX?5escape?$AA@ ; `string'
PUBLIC	??_C@_0BI@PIHNOMNG@truncated?5?2uXXXX?5escape?$AA@ ; `string'
PUBLIC	??_C@_0BG@DAOKAJPK@truncated?5?2xXX?5escape?$AA@ ; `string'
PUBLIC	PyUnicode_DecodeUnicodeEscape
EXTRN	PyExc_UnicodeError:QWORD
EXTRN	PyCapsule_Import:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_DecodeUnicodeEscape DD imagerel $LN188
	DD	imagerel $LN188+1451
	DD	imagerel $unwind$PyUnicode_DecodeUnicodeEscape
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_DecodeUnicodeEscape DD 0b1c01H
	DD	01d341cH
	DD	014011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT ??_C@_0DJ@LGKNJMG@?2N?5escapes?5not?5supported?5?$CIcan?8t?5@
CONST	SEGMENT
??_C@_0DJ@LGKNJMG@?2N?5escapes?5not?5supported?5?$CIcan?8t?5@ DB '\N esca'
	DB	'pes not supported (can''t load unicodedata module)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DEHDHMLA@unicodeescape?$AA@
CONST	SEGMENT
??_C@_0O@DEHDHMLA@unicodeescape?$AA@ DB 'unicodeescape', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PGFJKLCK@?2?5at?5end?5of?5string?$AA@
CONST	SEGMENT
??_C@_0BD@PGFJKLCK@?2?5at?5end?5of?5string?$AA@ DB '\ at end of string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EMHMGOCP@illegal?5Unicode?5character?$AA@
CONST	SEGMENT
??_C@_0BK@EMHMGOCP@illegal?5Unicode?5character?$AA@ DB 'illegal Unicode c'
	DB	'haracter', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IDJOAMJF@unknown?5Unicode?5character?5name?$AA@
CONST	SEGMENT
??_C@_0BP@IDJOAMJF@unknown?5Unicode?5character?5name?$AA@ DB 'unknown Uni'
	DB	'code character name', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NGMFMDDO@unicodedata?4ucnhash_CAPI?$AA@
CONST	SEGMENT
??_C@_0BJ@NGMFMDDO@unicodedata?4ucnhash_CAPI?$AA@ DB 'unicodedata.ucnhash'
	DB	'_CAPI', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@LPKHHNEG@malformed?5?2N?5character?5escape?$AA@
CONST	SEGMENT
??_C@_0BO@LPKHHNEG@malformed?5?2N?5character?5escape?$AA@ DB 'malformed \'
	DB	'N character escape', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GKNPCNAC@truncated?5?2UXXXXXXXX?5escape?$AA@
CONST	SEGMENT
??_C@_0BM@GKNPCNAC@truncated?5?2UXXXXXXXX?5escape?$AA@ DB 'truncated \UXX'
	DB	'XXXXXX escape', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PIHNOMNG@truncated?5?2uXXXX?5escape?$AA@
CONST	SEGMENT
??_C@_0BI@PIHNOMNG@truncated?5?2uXXXX?5escape?$AA@ DB 'truncated \uXXXX e'
	DB	'scape', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DAOKAJPK@truncated?5?2xXX?5escape?$AA@
CONST	SEGMENT
??_C@_0BG@DAOKAJPK@truncated?5?2xXX?5escape?$AA@ DB 'truncated \xXX escap'
	DB	'e', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_DecodeUnicodeEscape
_TEXT	SEGMENT
v$ = 96
i$ = 104
errorHandler$ = 112
exc$ = 120
starts$ = 128
end$ = 136
endinpos$ = 144
startinpos$ = 152
s$ = 224
size$ = 232
errors$ = 240
chr$ = 248
PyUnicode_DecodeUnicodeEscape PROC			; COMDAT

; 5622 : {

$LN188:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 8d 6c 24 d9	 lea	 rbp, QWORD PTR [rsp-39]
  00015	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 5623 :     const char *starts = s;
; 5624 :     Py_ssize_t startinpos;
; 5625 :     Py_ssize_t endinpos;
; 5626 :     PyObject *v;
; 5627 :     const char *end;
; 5628 :     char* message;
; 5629 :     Py_UCS4 chr = 0xffffffff; /* in case 'getcode' messes up */
; 5630 :     PyObject *errorHandler = NULL;

  0001c	45 33 e4	 xor	 r12d, r12d
  0001f	4d 8b f0	 mov	 r14, r8
  00022	48 8b f2	 mov	 rsi, rdx
  00025	48 8b d9	 mov	 rbx, rcx
  00028	4c 8b e9	 mov	 r13, rcx
  0002b	48 89 4d 07	 mov	 QWORD PTR starts$[rbp-121], rcx
  0002f	4c 89 65 f7	 mov	 QWORD PTR errorHandler$[rbp-121], r12

; 5631 :     PyObject *exc = NULL;

  00033	41 8b fc	 mov	 edi, r12d
  00036	4c 89 65 ff	 mov	 QWORD PTR exc$[rbp-121], r12
  0003a	c7 45 7f ff ff
	ff ff		 mov	 DWORD PTR chr$[rbp-121], -1 ; ffffffffH

; 5632 :     Py_ssize_t len;
; 5633 :     Py_ssize_t i;
; 5634 : 
; 5635 :     len = length_of_escaped_ascii_string(s, size);

  00041	e8 00 00 00 00	 call	 length_of_escaped_ascii_string

; 5636 : 
; 5637 :     /* After length_of_escaped_ascii_string() there are two alternatives,
; 5638 :        either the string is pure ASCII with named escapes like \n, etc.
; 5639 :        and we determined it's exact size (common case)
; 5640 :        or it contains \x, \u, ... escape sequences.  then we create a
; 5641 :        legacy wchar string and resize it at the end of this function. */
; 5642 :     if (len >= 0) {
; 5643 :         v = PyUnicode_New(len, 127);

  00046	41 8d 54 24 7f	 lea	 edx, QWORD PTR [r12+127]
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	48 85 c0	 test	 rax, rax
  00051	79 03		 jns	 SHORT $LN183@PyUnicode_@71

; 5644 :         if (!v)
; 5645 :             goto onError;
; 5646 :         assert(PyUnicode_KIND(v) == PyUnicode_1BYTE_KIND);
; 5647 :     }
; 5648 :     else {
; 5649 :         /* Escaped strings will always be longer than the resulting
; 5650 :            Unicode string, so we start with size here and then reduce the
; 5651 :            length after conversion to the true value.
; 5652 :            (but if the error callback returns a long replacement string
; 5653 :            we'll have to allocate more space) */
; 5654 :         v = PyUnicode_New(size, 127);

  00053	48 8b ce	 mov	 rcx, rsi
$LN183@PyUnicode_@71:
  00056	e8 00 00 00 00	 call	 PyUnicode_New
  0005b	48 89 45 e7	 mov	 QWORD PTR v$[rbp-121], rax

; 5655 :         if (!v)

  0005f	48 85 c0	 test	 rax, rax
  00062	0f 84 01 04 00
	00		 je	 $LN3@PyUnicode_@71

; 5656 :             goto onError;
; 5657 :         len = size;
; 5658 :     }
; 5659 : 
; 5660 :     if (size == 0)

  00068	48 85 f6	 test	 rsi, rsi

; 5661 :         return v;

  0006b	0f 84 fa 03 00
	00		 je	 $LN146@PyUnicode_@71

; 5662 :     i = 0;
; 5663 :     end = s + size;

  00071	48 03 f3	 add	 rsi, rbx
  00074	49 8b d4	 mov	 rdx, r12
  00077	48 89 55 ef	 mov	 QWORD PTR i$[rbp-121], rdx
  0007b	48 89 75 0f	 mov	 QWORD PTR end$[rbp-121], rsi

; 5664 : 
; 5665 :     while (s < end) {

  0007f	48 3b de	 cmp	 rbx, rsi
  00082	0f 83 a8 03 00
	00		 jae	 $LN139@PyUnicode_@71
  00088	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:__ImageBase
  0008f	90		 npad	 1
$LL140@PyUnicode_@71:

; 5666 :         unsigned char c;
; 5667 :         Py_UCS4 x;
; 5668 :         int digits;
; 5669 : 
; 5670 :         /* The only case in which i == ascii_length is a backslash
; 5671 :            followed by a newline. */
; 5672 :         assert(i <= len);
; 5673 : 
; 5674 :         /* Non-escape characters are interpreted as Unicode ordinals */
; 5675 :         if (*s != '\\') {

  00090	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00093	3c 5c		 cmp	 al, 92			; 0000005cH
  00095	74 0c		 je	 SHORT $LN138@PyUnicode_@71

; 5676 :             if (unicode_putchar(&v, &i, (unsigned char) *s++) < 0)

  00097	44 0f b6 c0	 movzx	 r8d, al
  0009b	48 ff c3	 inc	 rbx

; 5677 :                 goto onError;
; 5678 :             continue;

  0009e	e9 63 03 00 00	 jmp	 $LN185@PyUnicode_@71
$LN138@PyUnicode_@71:

; 5679 :         }
; 5680 : 
; 5681 :         startinpos = s-starts;
; 5682 :         /* \ - Escapes */
; 5683 :         s++;
; 5684 :         c = *s++;

  000a3	0f b6 4b 01	 movzx	 ecx, BYTE PTR [rbx+1]
  000a7	48 8b c3	 mov	 rax, rbx
  000aa	48 83 c3 02	 add	 rbx, 2
  000ae	49 2b c5	 sub	 rax, r13

; 5685 :         if (s > end)

  000b1	48 3b de	 cmp	 rbx, rsi
  000b4	48 89 5d 67	 mov	 QWORD PTR s$[rbp-121], rbx
  000b8	41 0f 47 cc	 cmova	 ecx, r12d
  000bc	48 89 45 1f	 mov	 QWORD PTR startinpos$[rbp-121], rax

; 5686 :             c = '\0'; /* Invalid after \ */
; 5687 : 
; 5688 :         /* The only case in which i == ascii_length is a backslash
; 5689 :            followed by a newline. */
; 5690 :         assert(i < len || (i == len && c == '\n'));
; 5691 : 
; 5692 :         switch (c) {

  000c0	0f b6 c1	 movzx	 eax, cl
  000c3	83 c0 f6	 add	 eax, -10
  000c6	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  000c9	0f 87 85 02 00
	00		 ja	 $LN45@PyUnicode_@71
  000cf	48 98		 cdqe
  000d1	41 0f b6 84 07
	00 00 00 00	 movzx	 eax, BYTE PTR $LN177@PyUnicode_@71[r15+rax]
  000da	41 8b 8c 87 00
	00 00 00	 mov	 ecx, DWORD PTR $LN178@PyUnicode_@71[r15+rax*4]
  000e2	49 03 cf	 add	 rcx, r15
  000e5	ff e1		 jmp	 rcx
$LN131@PyUnicode_@71:

; 5693 : 
; 5694 :             /* \x escapes */
; 5695 : #define WRITECHAR(ch)                                   \
; 5696 :             do {                                        \
; 5697 :                 if (unicode_putchar(&v, &i, ch) < 0)    \
; 5698 :                     goto onError;                       \
; 5699 :             }while(0)
; 5700 : 
; 5701 :         case '\n': break;
; 5702 :         case '\\': WRITECHAR('\\'); break;

  000e7	41 b8 5c 00 00
	00		 mov	 r8d, 92			; 0000005cH
  000ed	e9 14 03 00 00	 jmp	 $LN185@PyUnicode_@71
$LN126@PyUnicode_@71:

; 5703 :         case '\'': WRITECHAR('\''); break;

  000f2	41 b8 27 00 00
	00		 mov	 r8d, 39			; 00000027H
  000f8	e9 09 03 00 00	 jmp	 $LN185@PyUnicode_@71
$LN121@PyUnicode_@71:

; 5704 :         case '\"': WRITECHAR('\"'); break;

  000fd	41 b8 22 00 00
	00		 mov	 r8d, 34			; 00000022H
  00103	e9 fe 02 00 00	 jmp	 $LN185@PyUnicode_@71
$LN116@PyUnicode_@71:

; 5705 :         case 'b': WRITECHAR('\b'); break;

  00108	41 b8 08 00 00
	00		 mov	 r8d, 8
  0010e	e9 f3 02 00 00	 jmp	 $LN185@PyUnicode_@71
$LN111@PyUnicode_@71:

; 5706 :         /* FF */
; 5707 :         case 'f': WRITECHAR('\014'); break;

  00113	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00119	e9 e8 02 00 00	 jmp	 $LN185@PyUnicode_@71
$LN106@PyUnicode_@71:

; 5708 :         case 't': WRITECHAR('\t'); break;

  0011e	41 b8 09 00 00
	00		 mov	 r8d, 9
  00124	e9 dd 02 00 00	 jmp	 $LN185@PyUnicode_@71
$LN101@PyUnicode_@71:

; 5709 :         case 'n': WRITECHAR('\n'); break;

  00129	41 b8 0a 00 00
	00		 mov	 r8d, 10
  0012f	e9 d2 02 00 00	 jmp	 $LN185@PyUnicode_@71
$LN96@PyUnicode_@71:

; 5710 :         case 'r': WRITECHAR('\r'); break;

  00134	41 b8 0d 00 00
	00		 mov	 r8d, 13
  0013a	e9 c7 02 00 00	 jmp	 $LN185@PyUnicode_@71
$LN91@PyUnicode_@71:

; 5711 :         /* VT */
; 5712 :         case 'v': WRITECHAR('\013'); break;

  0013f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00145	e9 bc 02 00 00	 jmp	 $LN185@PyUnicode_@71
$LN86@PyUnicode_@71:

; 5713 :         /* BEL, not classic C */
; 5714 :         case 'a': WRITECHAR('\007'); break;

  0014a	41 b8 07 00 00
	00		 mov	 r8d, 7
  00150	e9 b1 02 00 00	 jmp	 $LN185@PyUnicode_@71
$LN82@PyUnicode_@71:

; 5715 : 
; 5716 :             /* \OOO (octal) escapes */
; 5717 :         case '0': case '1': case '2': case '3':
; 5718 :         case '4': case '5': case '6': case '7':
; 5719 :             x = s[-1] - '0';

  00155	44 0f be 43 ff	 movsx	 r8d, BYTE PTR [rbx-1]
  0015a	41 83 e8 30	 sub	 r8d, 48			; 00000030H

; 5720 :             if (s < end && '0' <= *s && *s <= '7') {

  0015e	48 3b de	 cmp	 rbx, rsi
  00161	0f 83 9f 02 00
	00		 jae	 $LN185@PyUnicode_@71
  00167	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  0016a	3c 30		 cmp	 al, 48			; 00000030H
  0016c	0f 8c 94 02 00
	00		 jl	 $LN185@PyUnicode_@71
  00172	3c 37		 cmp	 al, 55			; 00000037H
  00174	0f 8f 8c 02 00
	00		 jg	 $LN185@PyUnicode_@71

; 5721 :                 x = (x<<3) + *s++ - '0';

  0017a	0f be c0	 movsx	 eax, al
  0017d	48 ff c3	 inc	 rbx
  00180	46 8d 44 c0 d0	 lea	 r8d, DWORD PTR [rax+r8*8-48]

; 5722 :                 if (s < end && '0' <= *s && *s <= '7')

  00185	48 3b de	 cmp	 rbx, rsi
  00188	0f 83 78 02 00
	00		 jae	 $LN185@PyUnicode_@71
  0018e	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00191	3c 30		 cmp	 al, 48			; 00000030H
  00193	0f 8c 6d 02 00
	00		 jl	 $LN185@PyUnicode_@71
  00199	3c 37		 cmp	 al, 55			; 00000037H
  0019b	0f 8f 65 02 00
	00		 jg	 $LN185@PyUnicode_@71

; 5723 :                     x = (x<<3) + *s++ - '0';

  001a1	0f be c0	 movsx	 eax, al
  001a4	48 ff c3	 inc	 rbx
  001a7	46 8d 44 c0 d0	 lea	 r8d, DWORD PTR [rax+r8*8-48]

; 5724 :             }
; 5725 :             WRITECHAR(x);
; 5726 :             break;

  001ac	e9 55 02 00 00	 jmp	 $LN185@PyUnicode_@71
$LN75@PyUnicode_@71:

; 5727 : 
; 5728 :             /* hex escapes */
; 5729 :             /* \xXX */
; 5730 :         case 'x':
; 5731 :             digits = 2;

  001b1	ba 02 00 00 00	 mov	 edx, 2

; 5732 :             message = "truncated \\xXX escape";

  001b6	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0BG@DAOKAJPK@truncated?5?2xXX?5escape?$AA@

; 5733 :             goto hexescape;

  001bd	eb 1a		 jmp	 SHORT $hexescape$131773
$LN74@PyUnicode_@71:

; 5734 : 
; 5735 :             /* \uXXXX */
; 5736 :         case 'u':
; 5737 :             digits = 4;

  001bf	ba 04 00 00 00	 mov	 edx, 4

; 5738 :             message = "truncated \\uXXXX escape";

  001c4	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0BI@PIHNOMNG@truncated?5?2uXXXX?5escape?$AA@

; 5739 :             goto hexescape;

  001cb	eb 0c		 jmp	 SHORT $hexescape$131773
$LN73@PyUnicode_@71:

; 5740 : 
; 5741 :             /* \UXXXXXXXX */
; 5742 :         case 'U':
; 5743 :             digits = 8;

  001cd	ba 08 00 00 00	 mov	 edx, 8

; 5744 :             message = "truncated \\UXXXXXXXX escape";

  001d2	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0BM@GKNPCNAC@truncated?5?2UXXXXXXXX?5escape?$AA@
$hexescape$131773:

; 5745 :         hexescape:
; 5746 :             chr = 0;
; 5747 :             if (end - s < digits) {

  001d9	48 8b ce	 mov	 rcx, rsi
  001dc	48 63 c2	 movsxd	 rax, edx
  001df	45 8b c4	 mov	 r8d, r12d
  001e2	48 2b cb	 sub	 rcx, rbx
  001e5	44 89 65 7f	 mov	 DWORD PTR chr$[rbp-121], r12d
  001e9	48 3b c8	 cmp	 rcx, rax
  001ec	7d 35		 jge	 SHORT $LN72@PyUnicode_@71

; 5748 :                 /* count only hex digits */
; 5749 :                 for (; s < end; ++s) {

  001ee	48 3b de	 cmp	 rbx, rsi
  001f1	0f 83 74 01 00
	00		 jae	 $error$131785
  001f7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL71@PyUnicode_@71:

; 5750 :                     c = (unsigned char)*s;
; 5751 :                     if (!Py_ISXDIGIT(c))

  00200	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00203	41 f6 84 87 00
	00 00 00 10	 test	 BYTE PTR _Py_ctype_table[r15+rax*4], 16
  0020c	0f 84 59 01 00
	00		 je	 $error$131785

; 5748 :                 /* count only hex digits */
; 5749 :                 for (; s < end; ++s) {

  00212	48 ff c3	 inc	 rbx
  00215	48 89 5d 67	 mov	 QWORD PTR s$[rbp-121], rbx
  00219	48 3b de	 cmp	 rbx, rsi
  0021c	72 e2		 jb	 SHORT $LL71@PyUnicode_@71

; 5815 :                 WRITECHAR((unsigned char)s[-1]);

  0021e	e9 48 01 00 00	 jmp	 $error$131785
$LN72@PyUnicode_@71:

; 5752 :                         goto error;
; 5753 :                 }
; 5754 :                 goto error;
; 5755 :             }
; 5756 :             for (; digits--; ++s) {

  00223	85 d2		 test	 edx, edx
  00225	0f 84 14 01 00
	00		 je	 $store$131797
  0022b	0f 1f 44 00 00	 npad	 5
$LL67@PyUnicode_@71:

; 5757 :                 c = (unsigned char)*s;

  00230	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00233	ff ca		 dec	 edx

; 5758 :                 if (!Py_ISXDIGIT(c))

  00235	41 f6 84 8f 00
	00 00 00 10	 test	 BYTE PTR _Py_ctype_table[r15+rcx*4], 16
  0023e	0f 84 27 01 00
	00		 je	 $error$131785

; 5759 :                     goto error;
; 5760 :                 chr = (chr<<4) & ~0xF;
; 5761 :                 if (c >= '0' && c <= '9')

  00244	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  00247	45 03 c0	 add	 r8d, r8d
  0024a	3c 09		 cmp	 al, 9
  0024c	77 0a		 ja	 SHORT $LN63@PyUnicode_@71

; 5762 :                     chr += c - '0';

  0024e	0f b6 c1	 movzx	 eax, cl
  00251	46 8d 44 c0 d0	 lea	 r8d, DWORD PTR [rax+r8*8-48]
  00256	eb 16		 jmp	 SHORT $LN186@PyUnicode_@71
$LN63@PyUnicode_@71:

; 5763 :                 else if (c >= 'a' && c <= 'f')

  00258	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  0025b	3c 05		 cmp	 al, 5

; 5764 :                     chr += 10 + c - 'a';

  0025d	0f b6 c1	 movzx	 eax, cl
  00260	77 07		 ja	 SHORT $LN61@PyUnicode_@71
  00262	46 8d 44 c0 a9	 lea	 r8d, DWORD PTR [rax+r8*8-87]

; 5765 :                 else

  00267	eb 05		 jmp	 SHORT $LN186@PyUnicode_@71
$LN61@PyUnicode_@71:

; 5766 :                     chr += 10 + c - 'A';

  00269	46 8d 44 c0 c9	 lea	 r8d, DWORD PTR [rax+r8*8-55]
$LN186@PyUnicode_@71:

; 5752 :                         goto error;
; 5753 :                 }
; 5754 :                 goto error;
; 5755 :             }
; 5756 :             for (; digits--; ++s) {

  0026e	48 ff c3	 inc	 rbx

; 5766 :                     chr += 10 + c - 'A';

  00271	44 89 45 7f	 mov	 DWORD PTR chr$[rbp-121], r8d
  00275	48 89 5d 67	 mov	 QWORD PTR s$[rbp-121], rbx
  00279	85 d2		 test	 edx, edx
  0027b	75 b3		 jne	 SHORT $LL67@PyUnicode_@71

; 5767 :             }
; 5768 :             if (chr == 0xffffffff && PyErr_Occurred())

  0027d	41 83 f8 ff	 cmp	 r8d, -1			; ffffffffH
  00281	0f 85 b8 00 00
	00		 jne	 $store$131797
  00287	e8 00 00 00 00	 call	 PyErr_Occurred
  0028c	48 85 c0	 test	 rax, rax
  0028f	0f 84 a6 00 00
	00		 je	 $LN179@PyUnicode_@71

; 5769 :                 /* _decoding_error will have already written into the
; 5770 :                    target buffer. */
; 5771 :                 break;

  00295	e9 81 01 00 00	 jmp	 $LN36@PyUnicode_@71
$LN53@PyUnicode_@71:

; 5779 : 
; 5780 :             /* \N{name} */
; 5781 :         case 'N':
; 5782 :             message = "malformed \\N character escape";
; 5783 :             if (ucnhash_CAPI == NULL) {

  0029a	4c 8b 15 00 00
	00 00		 mov	 r10, QWORD PTR ucnhash_CAPI
  002a1	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0BO@LPKHHNEG@malformed?5?2N?5character?5escape?$AA@
  002a8	4d 85 d2	 test	 r10, r10
  002ab	75 23		 jne	 SHORT $LN51@PyUnicode_@71

; 5784 :                 /* load the unicode data module */
; 5785 :                 ucnhash_CAPI = (_PyUnicode_Name_CAPI *)PyCapsule_Import(
; 5786 :                                                 PyUnicodeData_CAPSULE_NAME, 1);

  002ad	41 8d 52 01	 lea	 edx, QWORD PTR [r10+1]
  002b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@NGMFMDDO@unicodedata?4ucnhash_CAPI?$AA@
  002b8	e8 00 00 00 00	 call	 PyCapsule_Import
  002bd	4c 8b d0	 mov	 r10, rax
  002c0	48 89 05 00 00
	00 00		 mov	 QWORD PTR ucnhash_CAPI, rax

; 5787 :                 if (ucnhash_CAPI == NULL)

  002c7	48 85 c0	 test	 rax, rax
  002ca	0f 84 b6 01 00
	00		 je	 $ucnhashError$131812
$LN51@PyUnicode_@71:

; 5788 :                     goto ucnhashError;
; 5789 :             }
; 5790 :             if (*s == '{') {

  002d0	80 3b 7b	 cmp	 BYTE PTR [rbx], 123	; 0000007bH
  002d3	0f 85 92 00 00
	00		 jne	 $error$131785

; 5791 :                 const char *start = s+1;

  002d9	48 8d 53 01	 lea	 rdx, QWORD PTR [rbx+1]
  002dd	0f 1f 00	 npad	 3
$LL49@PyUnicode_@71:

; 5792 :                 /* look for the closing brace */
; 5793 :                 while (*s != '}' && s < end)

  002e0	48 3b de	 cmp	 rbx, rsi
  002e3	73 0c		 jae	 SHORT $LN48@PyUnicode_@71

; 5794 :                     s++;

  002e5	48 ff c3	 inc	 rbx
  002e8	48 89 5d 67	 mov	 QWORD PTR s$[rbp-121], rbx
  002ec	80 3b 7d	 cmp	 BYTE PTR [rbx], 125	; 0000007dH
  002ef	75 ef		 jne	 SHORT $LL49@PyUnicode_@71
$LN48@PyUnicode_@71:

; 5795 :                 if (s > start && s < end && *s == '}') {

  002f1	48 3b da	 cmp	 rbx, rdx
  002f4	76 75		 jbe	 SHORT $error$131785
  002f6	48 3b de	 cmp	 rbx, rsi
  002f9	73 70		 jae	 SHORT $error$131785
  002fb	80 3b 7d	 cmp	 BYTE PTR [rbx], 125	; 0000007dH
  002fe	75 6b		 jne	 SHORT $error$131785

; 5796 :                     /* found a name.  look it up in the unicode database */
; 5797 :                     message = "unknown Unicode character name";
; 5798 :                     s++;

  00300	48 ff c3	 inc	 rbx
  00303	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0BP@IDJOAMJF@unknown?5Unicode?5character?5name?$AA@

; 5799 :                     if (s - start - 1 <= INT_MAX &&
; 5800 :                         ucnhash_CAPI->getcode(NULL, start, (int)(s-start-1),
; 5801 :                                               &chr, 0))

  0030a	48 8b c3	 mov	 rax, rbx
  0030d	48 89 5d 67	 mov	 QWORD PTR s$[rbp-121], rbx
  00311	48 2b c2	 sub	 rax, rdx
  00314	48 ff c8	 dec	 rax
  00317	48 3d ff ff ff
	7f		 cmp	 rax, 2147483647		; 7fffffffH
  0031d	7f 4c		 jg	 SHORT $error$131785
  0031f	44 8b c3	 mov	 r8d, ebx
  00322	4c 8d 4d 7f	 lea	 r9, QWORD PTR chr$[rbp-121]
  00326	33 c9		 xor	 ecx, ecx
  00328	44 2b c2	 sub	 r8d, edx
  0032b	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  00330	41 ff c8	 dec	 r8d
  00333	41 ff 52 10	 call	 QWORD PTR [r10+16]
  00337	85 c0		 test	 eax, eax
  00339	74 30		 je	 SHORT $error$131785
$LN179@PyUnicode_@71:
  0033b	44 8b 45 7f	 mov	 r8d, DWORD PTR chr$[rbp-121]
$store$131797:

; 5772 :         store:
; 5773 :             /* when we get here, chr is a 32-bit unicode character */
; 5774 :             message = "illegal Unicode character";

  0033f	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0BK@EMHMGOCP@illegal?5Unicode?5character?$AA@

; 5775 :             if (chr > MAX_UNICODE)

  00346	41 81 f8 ff ff
	10 00		 cmp	 r8d, 1114111		; 0010ffffH
  0034d	77 1c		 ja	 SHORT $error$131785

; 5776 :                 goto error;
; 5777 :             WRITECHAR(chr);
; 5778 :             break;

  0034f	e9 b2 00 00 00	 jmp	 $LN185@PyUnicode_@71
$LN45@PyUnicode_@71:

; 5802 :                         goto store;
; 5803 :                 }
; 5804 :             }
; 5805 :             goto error;
; 5806 : 
; 5807 :         default:
; 5808 :             if (s > end) {

  00354	48 3b de	 cmp	 rbx, rsi
  00357	0f 86 89 00 00
	00		 jbe	 $LN42@PyUnicode_@71

; 5809 :                 message = "\\ at end of string";
; 5810 :                 s--;

  0035d	48 ff cb	 dec	 rbx
  00360	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0BD@PGFJKLCK@?2?5at?5end?5of?5string?$AA@
  00367	48 89 5d 67	 mov	 QWORD PTR s$[rbp-121], rbx
$error$131785:

; 5816 :             }
; 5817 :             break;
; 5818 :         }
; 5819 :         continue;
; 5820 : 
; 5821 :       error:
; 5822 :         endinpos = s-starts;
; 5823 :         if (unicode_decode_call_errorhandler(
; 5824 :                 errors, &errorHandler,
; 5825 :                 "unicodeescape", message,
; 5826 :                 &starts, &end, &startinpos, &endinpos, &exc, &s,
; 5827 :                 &v, &i))

  0036b	48 8d 45 ef	 lea	 rax, QWORD PTR i$[rbp-121]
  0036f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@DEHDHMLA@unicodeescape?$AA@
  00376	48 8d 55 f7	 lea	 rdx, QWORD PTR errorHandler$[rbp-121]
  0037a	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  0037f	48 8d 45 e7	 lea	 rax, QWORD PTR v$[rbp-121]
  00383	49 2b dd	 sub	 rbx, r13
  00386	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0038b	48 8d 45 67	 lea	 rax, QWORD PTR s$[rbp-121]
  0038f	4c 8b cf	 mov	 r9, rdi
  00392	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00397	48 8d 45 ff	 lea	 rax, QWORD PTR exc$[rbp-121]
  0039b	49 8b ce	 mov	 rcx, r14
  0039e	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  003a3	48 8d 45 17	 lea	 rax, QWORD PTR endinpos$[rbp-121]
  003a7	48 89 5d 17	 mov	 QWORD PTR endinpos$[rbp-121], rbx
  003ab	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  003b0	48 8d 45 1f	 lea	 rax, QWORD PTR startinpos$[rbp-121]
  003b4	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  003b9	48 8d 45 0f	 lea	 rax, QWORD PTR end$[rbp-121]
  003bd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003c2	48 8d 45 07	 lea	 rax, QWORD PTR starts$[rbp-121]
  003c6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003cb	e8 00 00 00 00	 call	 unicode_decode_call_errorhandler
  003d0	85 c0		 test	 eax, eax
  003d2	0f 85 e8 00 00
	00		 jne	 $LN180@PyUnicode_@71

; 5828 :             goto onError;
; 5829 :         len = PyUnicode_GET_LENGTH(v);
; 5830 :         continue;

  003d8	48 8b 5d 67	 mov	 rbx, QWORD PTR s$[rbp-121]
  003dc	4c 8b 6d 07	 mov	 r13, QWORD PTR starts$[rbp-121]
  003e0	48 8b 75 0f	 mov	 rsi, QWORD PTR end$[rbp-121]
  003e4	eb 35		 jmp	 SHORT $LN36@PyUnicode_@71
$LN42@PyUnicode_@71:

; 5811 :                 goto error;
; 5812 :             }
; 5813 :             else {
; 5814 :                 WRITECHAR('\\');

  003e6	48 8d 55 ef	 lea	 rdx, QWORD PTR i$[rbp-121]
  003ea	48 8d 4d e7	 lea	 rcx, QWORD PTR v$[rbp-121]
  003ee	41 b8 5c 00 00
	00		 mov	 r8d, 92			; 0000005cH
  003f4	e8 00 00 00 00	 call	 unicode_putchar
  003f9	85 c0		 test	 eax, eax
  003fb	0f 88 bf 00 00
	00		 js	 $LN180@PyUnicode_@71

; 5815 :                 WRITECHAR((unsigned char)s[-1]);

  00401	44 0f b6 43 ff	 movzx	 r8d, BYTE PTR [rbx-1]
$LN185@PyUnicode_@71:
  00406	48 8d 55 ef	 lea	 rdx, QWORD PTR i$[rbp-121]
  0040a	48 8d 4d e7	 lea	 rcx, QWORD PTR v$[rbp-121]
  0040e	e8 00 00 00 00	 call	 unicode_putchar
  00413	85 c0		 test	 eax, eax
  00415	0f 88 a5 00 00
	00		 js	 $LN180@PyUnicode_@71
$LN36@PyUnicode_@71:

; 5664 : 
; 5665 :     while (s < end) {

  0041b	48 3b de	 cmp	 rbx, rsi
  0041e	0f 82 6c fc ff
	ff		 jb	 $LL140@PyUnicode_@71

; 5815 :                 WRITECHAR((unsigned char)s[-1]);

  00424	4c 8b 65 f7	 mov	 r12, QWORD PTR errorHandler$[rbp-121]
  00428	48 8b 7d ff	 mov	 rdi, QWORD PTR exc$[rbp-121]
  0042c	48 8b 55 ef	 mov	 rdx, QWORD PTR i$[rbp-121]
$LN139@PyUnicode_@71:

; 5831 :     }
; 5832 : #undef WRITECHAR
; 5833 : 
; 5834 :     if (unicode_resize(&v, i) < 0)

  00430	48 8d 4d e7	 lea	 rcx, QWORD PTR v$[rbp-121]
  00434	e8 00 00 00 00	 call	 unicode_resize
  00439	85 c0		 test	 eax, eax
  0043b	0f 89 8c 00 00
	00		 jns	 $LN32@PyUnicode_@71
$onError$131691:

; 5849 : 
; 5850 :   onError:
; 5851 :     Py_XDECREF(v);

  00441	48 8b 4d e7	 mov	 rcx, QWORD PTR v$[rbp-121]
  00445	48 85 c9	 test	 rcx, rcx
  00448	74 05		 je	 SHORT $LN11@PyUnicode_@71
  0044a	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@PyUnicode_@71:

; 5852 :     Py_XDECREF(errorHandler);

  0044f	4d 85 e4	 test	 r12, r12
  00452	74 08		 je	 SHORT $LN7@PyUnicode_@71
  00454	49 8b cc	 mov	 rcx, r12
  00457	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@PyUnicode_@71:

; 5853 :     Py_XDECREF(exc);

  0045c	48 85 ff	 test	 rdi, rdi
  0045f	74 08		 je	 SHORT $LN3@PyUnicode_@71
  00461	48 8b cf	 mov	 rcx, rdi
$LN187@PyUnicode_@71:

; 5847 :     Py_XDECREF(exc);

  00464	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyUnicode_@71:

; 5854 :     return NULL;

  00469	33 c0		 xor	 eax, eax
$LN146@PyUnicode_@71:

; 5855 : }

  0046b	48 8b 9c 24 e8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+232]
  00473	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  0047a	41 5f		 pop	 r15
  0047c	41 5e		 pop	 r14
  0047e	41 5d		 pop	 r13
  00480	41 5c		 pop	 r12
  00482	5f		 pop	 rdi
  00483	5e		 pop	 rsi
  00484	5d		 pop	 rbp
  00485	c3		 ret	 0
$ucnhashError$131812:

; 5839 : 
; 5840 :   ucnhashError:
; 5841 :     PyErr_SetString(
; 5842 :         PyExc_UnicodeError,
; 5843 :         "\\N escapes not supported (can't load unicodedata module)"
; 5844 :         );

  00486	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnicodeError
  0048d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DJ@LGKNJMG@?2N?5escapes?5not?5supported?5?$CIcan?8t?5@
  00494	e8 00 00 00 00	 call	 PyErr_SetString

; 5845 :     Py_XDECREF(v);

  00499	48 8b 4d e7	 mov	 rcx, QWORD PTR v$[rbp-121]
  0049d	48 85 c9	 test	 rcx, rcx
  004a0	74 05		 je	 SHORT $LN23@PyUnicode_@71
  004a2	e8 00 00 00 00	 call	 _Py_DecRef
$LN23@PyUnicode_@71:

; 5846 :     Py_XDECREF(errorHandler);

  004a7	48 8b 4d f7	 mov	 rcx, QWORD PTR errorHandler$[rbp-121]
  004ab	48 85 c9	 test	 rcx, rcx
  004ae	74 05		 je	 SHORT $LN19@PyUnicode_@71
  004b0	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@PyUnicode_@71:

; 5847 :     Py_XDECREF(exc);

  004b5	48 8b 4d ff	 mov	 rcx, QWORD PTR exc$[rbp-121]
  004b9	48 85 c9	 test	 rcx, rcx
  004bc	74 ab		 je	 SHORT $LN3@PyUnicode_@71

; 5848 :     return NULL;

  004be	eb a4		 jmp	 SHORT $LN187@PyUnicode_@71
$LN180@PyUnicode_@71:

; 5831 :     }
; 5832 : #undef WRITECHAR
; 5833 : 
; 5834 :     if (unicode_resize(&v, i) < 0)

  004c0	4c 8b 65 f7	 mov	 r12, QWORD PTR errorHandler$[rbp-121]
  004c4	48 8b 7d ff	 mov	 rdi, QWORD PTR exc$[rbp-121]
  004c8	e9 74 ff ff ff	 jmp	 $onError$131691
$LN32@PyUnicode_@71:

; 5835 :         goto onError;
; 5836 :     Py_XDECREF(errorHandler);

  004cd	4d 85 e4	 test	 r12, r12
  004d0	74 08		 je	 SHORT $LN31@PyUnicode_@71
  004d2	49 8b cc	 mov	 rcx, r12
  004d5	e8 00 00 00 00	 call	 _Py_DecRef
$LN31@PyUnicode_@71:

; 5837 :     Py_XDECREF(exc);

  004da	48 85 ff	 test	 rdi, rdi
  004dd	74 08		 je	 SHORT $LN27@PyUnicode_@71
  004df	48 8b cf	 mov	 rcx, rdi
  004e2	e8 00 00 00 00	 call	 _Py_DecRef
$LN27@PyUnicode_@71:

; 5838 :     return unicode_result(v);

  004e7	48 8b 4d e7	 mov	 rcx, QWORD PTR v$[rbp-121]
  004eb	e8 00 00 00 00	 call	 unicode_result
  004f0	e9 76 ff ff ff	 jmp	 $LN146@PyUnicode_@71
  004f5	0f 1f 00	 npad	 3
$LN178@PyUnicode_@71:

; 5855 : }

  004f8	00 00 00 00	 DD	 $LN36@PyUnicode_@71
  004fc	00 00 00 00	 DD	 $LN121@PyUnicode_@71
  00500	00 00 00 00	 DD	 $LN126@PyUnicode_@71
  00504	00 00 00 00	 DD	 $LN82@PyUnicode_@71
  00508	00 00 00 00	 DD	 $LN53@PyUnicode_@71
  0050c	00 00 00 00	 DD	 $LN73@PyUnicode_@71
  00510	00 00 00 00	 DD	 $LN131@PyUnicode_@71
  00514	00 00 00 00	 DD	 $LN86@PyUnicode_@71
  00518	00 00 00 00	 DD	 $LN116@PyUnicode_@71
  0051c	00 00 00 00	 DD	 $LN111@PyUnicode_@71
  00520	00 00 00 00	 DD	 $LN101@PyUnicode_@71
  00524	00 00 00 00	 DD	 $LN96@PyUnicode_@71
  00528	00 00 00 00	 DD	 $LN106@PyUnicode_@71
  0052c	00 00 00 00	 DD	 $LN74@PyUnicode_@71
  00530	00 00 00 00	 DD	 $LN91@PyUnicode_@71
  00534	00 00 00 00	 DD	 $LN75@PyUnicode_@71
  00538	00 00 00 00	 DD	 $LN45@PyUnicode_@71
$LN177@PyUnicode_@71:
  0053c	00		 DB	 0
  0053d	10		 DB	 16
  0053e	10		 DB	 16
  0053f	10		 DB	 16
  00540	10		 DB	 16
  00541	10		 DB	 16
  00542	10		 DB	 16
  00543	10		 DB	 16
  00544	10		 DB	 16
  00545	10		 DB	 16
  00546	10		 DB	 16
  00547	10		 DB	 16
  00548	10		 DB	 16
  00549	10		 DB	 16
  0054a	10		 DB	 16
  0054b	10		 DB	 16
  0054c	10		 DB	 16
  0054d	10		 DB	 16
  0054e	10		 DB	 16
  0054f	10		 DB	 16
  00550	10		 DB	 16
  00551	10		 DB	 16
  00552	10		 DB	 16
  00553	10		 DB	 16
  00554	01		 DB	 1
  00555	10		 DB	 16
  00556	10		 DB	 16
  00557	10		 DB	 16
  00558	10		 DB	 16
  00559	02		 DB	 2
  0055a	10		 DB	 16
  0055b	10		 DB	 16
  0055c	10		 DB	 16
  0055d	10		 DB	 16
  0055e	10		 DB	 16
  0055f	10		 DB	 16
  00560	10		 DB	 16
  00561	10		 DB	 16
  00562	03		 DB	 3
  00563	03		 DB	 3
  00564	03		 DB	 3
  00565	03		 DB	 3
  00566	03		 DB	 3
  00567	03		 DB	 3
  00568	03		 DB	 3
  00569	03		 DB	 3
  0056a	10		 DB	 16
  0056b	10		 DB	 16
  0056c	10		 DB	 16
  0056d	10		 DB	 16
  0056e	10		 DB	 16
  0056f	10		 DB	 16
  00570	10		 DB	 16
  00571	10		 DB	 16
  00572	10		 DB	 16
  00573	10		 DB	 16
  00574	10		 DB	 16
  00575	10		 DB	 16
  00576	10		 DB	 16
  00577	10		 DB	 16
  00578	10		 DB	 16
  00579	10		 DB	 16
  0057a	10		 DB	 16
  0057b	10		 DB	 16
  0057c	10		 DB	 16
  0057d	10		 DB	 16
  0057e	10		 DB	 16
  0057f	10		 DB	 16
  00580	04		 DB	 4
  00581	10		 DB	 16
  00582	10		 DB	 16
  00583	10		 DB	 16
  00584	10		 DB	 16
  00585	10		 DB	 16
  00586	10		 DB	 16
  00587	05		 DB	 5
  00588	10		 DB	 16
  00589	10		 DB	 16
  0058a	10		 DB	 16
  0058b	10		 DB	 16
  0058c	10		 DB	 16
  0058d	10		 DB	 16
  0058e	06		 DB	 6
  0058f	10		 DB	 16
  00590	10		 DB	 16
  00591	10		 DB	 16
  00592	10		 DB	 16
  00593	07		 DB	 7
  00594	08		 DB	 8
  00595	10		 DB	 16
  00596	10		 DB	 16
  00597	10		 DB	 16
  00598	09		 DB	 9
  00599	10		 DB	 16
  0059a	10		 DB	 16
  0059b	10		 DB	 16
  0059c	10		 DB	 16
  0059d	10		 DB	 16
  0059e	10		 DB	 16
  0059f	10		 DB	 16
  005a0	0a		 DB	 10
  005a1	10		 DB	 16
  005a2	10		 DB	 16
  005a3	10		 DB	 16
  005a4	0b		 DB	 11
  005a5	10		 DB	 16
  005a6	0c		 DB	 12
  005a7	0d		 DB	 13
  005a8	0e		 DB	 14
  005a9	10		 DB	 16
  005aa	0f		 DB	 15
PyUnicode_DecodeUnicodeEscape ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_EncodeUnicodeEscape
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_EncodeUnicodeEscape DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$PyUnicode_EncodeUnicodeEscape
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_EncodeUnicodeEscape DD 042101H
	DD	063421H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_EncodeUnicodeEscape
_TEXT	SEGMENT
s$ = 48
size$ = 56
PyUnicode_EncodeUnicodeEscape PROC			; COMDAT

; 5984 : {

$LN4:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5985 :     PyObject *result;
; 5986 :     PyObject *tmp = PyUnicode_FromUnicode(s, size);

  00006	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  0000b	48 8b f8	 mov	 rdi, rax

; 5987 :     if (tmp == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 06		 jne	 SHORT $LN1@PyUnicode_@72

; 5992 : }

  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5f		 pop	 rdi
  00018	c3		 ret	 0
$LN1@PyUnicode_@72:

; 5988 :         return NULL;
; 5989 :     result = PyUnicode_AsUnicodeEscapeString(tmp);

  00019	48 8b c8	 mov	 rcx, rax
  0001c	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00021	e8 00 00 00 00	 call	 PyUnicode_AsUnicodeEscapeString

; 5990 :     Py_DECREF(tmp);

  00026	48 8b cf	 mov	 rcx, rdi
  00029	48 8b d8	 mov	 rbx, rax
  0002c	e8 00 00 00 00	 call	 _Py_DecRef

; 5991 :     return result;

  00031	48 8b c3	 mov	 rax, rbx
  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 5992 : }

  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
PyUnicode_EncodeUnicodeEscape ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@JGNLGDNO@rawunicodeescape?$AA@	; `string'
PUBLIC	??_C@_0BB@CDHIBBOE@truncated?5?2uXXXX?$AA@	; `string'
PUBLIC	??_C@_0BI@LBMJFPF@?2Uxxxxxxxx?5out?5of?5range?$AA@ ; `string'
PUBLIC	PyUnicode_DecodeRawUnicodeEscape
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyUnicode_DecodeRawUnicodeEscape DD imagerel $LN128
	DD	imagerel $LN128+1208
	DD	imagerel $unwind$PyUnicode_DecodeRawUnicodeEscape
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_DecodeRawUnicodeEscape DD 0b1c01H
	DD	01d341cH
	DD	014011cH
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT ??_C@_0BB@JGNLGDNO@rawunicodeescape?$AA@
CONST	SEGMENT
??_C@_0BB@JGNLGDNO@rawunicodeescape?$AA@ DB 'rawunicodeescape', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CDHIBBOE@truncated?5?2uXXXX?$AA@
CONST	SEGMENT
??_C@_0BB@CDHIBBOE@truncated?5?2uXXXX?$AA@ DB 'truncated \uXXXX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LBMJFPF@?2Uxxxxxxxx?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BI@LBMJFPF@?2Uxxxxxxxx?5out?5of?5range?$AA@ DB '\Uxxxxxxxx out of '
	DB	'range', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT PyUnicode_DecodeRawUnicodeEscape
_TEXT	SEGMENT
v$ = 96
starts$ = 104
end$ = 112
errorHandler$ = 120
exc$ = 128
endinpos$ = 136
startinpos$ = 144
s$ = 224
size$ = 232
errors$ = 240
outpos$ = 248
PyUnicode_DecodeRawUnicodeEscape PROC			; COMDAT

; 6000 : {

$LN128:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 8d 6c 24 d9	 lea	 rbp, QWORD PTR [rsp-39]
  00015	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 6001 :     const char *starts = s;
; 6002 :     Py_ssize_t startinpos;
; 6003 :     Py_ssize_t endinpos;
; 6004 :     Py_ssize_t outpos;
; 6005 :     PyObject *v;
; 6006 :     const char *end;
; 6007 :     const char *bs;
; 6008 :     PyObject *errorHandler = NULL;

  0001c	45 33 e4	 xor	 r12d, r12d
  0001f	48 8b f2	 mov	 rsi, rdx
  00022	48 8b d9	 mov	 rbx, rcx
  00025	4c 8b e9	 mov	 r13, rcx
  00028	48 89 4d ef	 mov	 QWORD PTR starts$[rbp-121], rcx

; 6009 :     PyObject *exc = NULL;
; 6010 : 
; 6011 :     /* Escaped strings will always be longer than the resulting
; 6012 :        Unicode string, so we start with size here and then reduce the
; 6013 :        length after conversion to the true value. (But decoding error
; 6014 :        handler might have to resize the string) */
; 6015 :     v = PyUnicode_New(size, 127);

  0002c	41 8d 54 24 7f	 lea	 edx, QWORD PTR [r12+127]
  00031	48 8b ce	 mov	 rcx, rsi
  00034	4d 8b f0	 mov	 r14, r8
  00037	4c 89 65 ff	 mov	 QWORD PTR errorHandler$[rbp-121], r12
  0003b	41 8b fc	 mov	 edi, r12d
  0003e	4c 89 65 07	 mov	 QWORD PTR exc$[rbp-121], r12
  00042	e8 00 00 00 00	 call	 PyUnicode_New
  00047	48 89 45 e7	 mov	 QWORD PTR v$[rbp-121], rax

; 6016 :     if (v == NULL)

  0004b	48 85 c0	 test	 rax, rax
  0004e	0f 84 34 03 00
	00		 je	 $LN3@PyUnicode_@73

; 6017 :         goto onError;
; 6018 :     if (size == 0)

  00054	48 85 f6	 test	 rsi, rsi

; 6019 :         return v;

  00057	0f 84 2d 03 00
	00		 je	 $LN47@PyUnicode_@73

; 6020 :     outpos = 0;
; 6021 :     end = s + size;

  0005d	48 03 f3	 add	 rsi, rbx
  00060	4c 89 65 7f	 mov	 QWORD PTR outpos$[rbp-121], r12
  00064	48 89 75 f7	 mov	 QWORD PTR end$[rbp-121], rsi

; 6022 :     while (s < end) {

  00068	48 3b de	 cmp	 rbx, rsi
  0006b	73 40		 jae	 SHORT $LN43@PyUnicode_@73
  0006d	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:_Py_ctype_table
$LN126@PyUnicode_@73:

; 6023 :         unsigned char c;
; 6024 :         Py_UCS4 x;
; 6025 :         int i;
; 6026 :         int count;
; 6027 : 
; 6028 :         /* Non-escape characters are interpreted as Unicode ordinals */
; 6029 :         if (*s != '\\') {

  00074	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00077	b9 04 00 00 00	 mov	 ecx, 4
  0007c	3c 5c		 cmp	 al, 92			; 0000005cH
  0007e	0f 84 b7 00 00
	00		 je	 $LN42@PyUnicode_@73

; 6030 :             if (unicode_putchar(&v, &outpos, (unsigned char)*s++) < 0)

  00084	44 0f b6 c0	 movzx	 r8d, al
  00088	48 ff c3	 inc	 rbx
$LN118@PyUnicode_@73:

; 6076 :             if (unicode_putchar(&v, &outpos, x) < 0)

  0008b	48 8d 55 7f	 lea	 rdx, QWORD PTR outpos$[rbp-121]
  0008f	48 8d 4d e7	 lea	 rcx, QWORD PTR v$[rbp-121]
  00093	e8 00 00 00 00	 call	 unicode_putchar
  00098	85 c0		 test	 eax, eax
  0009a	0f 88 06 02 00
	00		 js	 $LN121@PyUnicode_@73
$nextByte$132027:

; 6022 :     while (s < end) {

  000a0	48 3b de	 cmp	 rbx, rsi
  000a3	72 cf		 jb	 SHORT $LN126@PyUnicode_@73
$LN122@PyUnicode_@73:
  000a5	4c 8b 65 ff	 mov	 r12, QWORD PTR errorHandler$[rbp-121]
  000a9	48 8b 7d 07	 mov	 rdi, QWORD PTR exc$[rbp-121]
$LN43@PyUnicode_@73:

; 6085 :                 goto onError;
; 6086 :         }
; 6087 :       nextByte:
; 6088 :         ;
; 6089 :     }
; 6090 :     if (unicode_resize(&v, outpos) < 0)

  000ad	48 8b 55 7f	 mov	 rdx, QWORD PTR outpos$[rbp-121]
  000b1	48 8d 4d e7	 lea	 rcx, QWORD PTR v$[rbp-121]
  000b5	e8 00 00 00 00	 call	 unicode_resize
  000ba	85 c0		 test	 eax, eax
  000bc	0f 89 f9 02 00
	00		 jns	 $LN20@PyUnicode_@73
$onError$131998:

; 6095 : 
; 6096 :   onError:
; 6097 :     Py_XDECREF(v);

  000c2	48 8b 5d e7	 mov	 rbx, QWORD PTR v$[rbp-121]
  000c6	48 85 db	 test	 rbx, rbx
  000c9	0f 84 f8 01 00
	00		 je	 $LN11@PyUnicode_@73
  000cf	e8 00 00 00 00	 call	 _Py_PXCTX
  000d4	85 c0		 test	 eax, eax
  000d6	0f 85 eb 01 00
	00		 jne	 $LN11@PyUnicode_@73
  000dc	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000e0	a8 20		 test	 al, 32			; 00000020H
  000e2	0f 85 d7 01 00
	00		 jne	 $LN75@PyUnicode_@73
  000e8	84 c0		 test	 al, al
  000ea	0f 88 cf 01 00
	00		 js	 $LN75@PyUnicode_@73
  000f0	a8 02		 test	 al, 2
  000f2	0f 85 cf 01 00
	00		 jne	 $LN11@PyUnicode_@73
  000f8	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000fc	0f 85 c5 01 00
	00		 jne	 $LN11@PyUnicode_@73
  00102	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00110	4c 8b cb	 mov	 r9, rbx
  00113	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00119	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00121	e8 00 00 00 00	 call	 _PyParallel_Guard
  00126	48 8b cb	 mov	 rcx, rbx
  00129	85 c0		 test	 eax, eax
  0012b	0f 84 82 01 00
	00		 je	 $LN80@PyUnicode_@73
  00131	e8 00 00 00 00	 call	 _Px_Dealloc
  00136	e9 8c 01 00 00	 jmp	 $LN11@PyUnicode_@73
$LN42@PyUnicode_@73:

; 6031 :                 goto onError;
; 6032 :             continue;
; 6033 :         }
; 6034 :         startinpos = s-starts;

  0013b	48 8b c3	 mov	 rax, rbx

; 6035 : 
; 6036 :         /* \u-escapes are only interpreted iff the number of leading
; 6037 :            backslashes if odd */
; 6038 :         bs = s;

  0013e	48 8b fb	 mov	 rdi, rbx
  00141	49 2b c5	 sub	 rax, r13
  00144	48 89 45 17	 mov	 QWORD PTR startinpos$[rbp-121], rax

; 6039 :         for (;s < end;) {

  00148	48 3b de	 cmp	 rbx, rsi
  0014b	73 30		 jae	 SHORT $LN119@PyUnicode_@73
  0014d	0f 1f 00	 npad	 3
$LL40@PyUnicode_@73:

; 6040 :             if (*s != '\\')

  00150	80 3b 5c	 cmp	 BYTE PTR [rbx], 92	; 0000005cH
  00153	75 23		 jne	 SHORT $LN123@PyUnicode_@73

; 6041 :                 break;
; 6042 :             if (unicode_putchar(&v, &outpos, (unsigned char)*s++) < 0)

  00155	48 8d 55 7f	 lea	 rdx, QWORD PTR outpos$[rbp-121]
  00159	48 8d 4d e7	 lea	 rcx, QWORD PTR v$[rbp-121]
  0015d	41 b8 5c 00 00
	00		 mov	 r8d, 92			; 0000005cH
  00163	48 ff c3	 inc	 rbx
  00166	e8 00 00 00 00	 call	 unicode_putchar
  0016b	85 c0		 test	 eax, eax
  0016d	0f 88 33 01 00
	00		 js	 $LN121@PyUnicode_@73

; 6039 :         for (;s < end;) {

  00173	48 3b de	 cmp	 rbx, rsi
  00176	72 d8		 jb	 SHORT $LL40@PyUnicode_@73
$LN123@PyUnicode_@73:

; 6077 :                 goto onError;
; 6078 :         } else {
; 6079 :             endinpos = s-starts;
; 6080 :             if (unicode_decode_call_errorhandler(
; 6081 :                     errors, &errorHandler,
; 6082 :                     "rawunicodeescape", "\\Uxxxxxxxx out of range",
; 6083 :                     &starts, &end, &startinpos, &endinpos, &exc, &s,
; 6084 :                     &v, &outpos))

  00178	b9 04 00 00 00	 mov	 ecx, 4
$LN119@PyUnicode_@73:

; 6043 :                 goto onError;
; 6044 :         }
; 6045 :         if (((s - bs) & 1) == 0 ||
; 6046 :             s >= end ||
; 6047 :             (*s != 'u' && *s != 'U')) {

  0017d	0f b6 c3	 movzx	 eax, bl
  00180	40 2a c7	 sub	 al, dil
  00183	a8 01		 test	 al, 1
  00185	0f 84 15 ff ff
	ff		 je	 $nextByte$132027
  0018b	48 3b de	 cmp	 rbx, rsi
  0018e	0f 83 11 ff ff
	ff		 jae	 $LN122@PyUnicode_@73
  00194	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00197	3c 75		 cmp	 al, 117			; 00000075H
  00199	74 08		 je	 SHORT $LN36@PyUnicode_@73
  0019b	3c 55		 cmp	 al, 85			; 00000055H
  0019d	0f 85 fd fe ff
	ff		 jne	 $nextByte$132027
$LN36@PyUnicode_@73:

; 6048 :             continue;
; 6049 :         }
; 6050 :         outpos--;

  001a3	48 ff 4d 7f	 dec	 QWORD PTR outpos$[rbp-121]

; 6051 :         count = *s=='u' ? 4 : 8;

  001a7	3c 75		 cmp	 al, 117			; 00000075H
  001a9	41 b9 08 00 00
	00		 mov	 r9d, 8
  001af	44 0f 44 c9	 cmove	 r9d, ecx

; 6052 :         s++;

  001b3	48 ff c3	 inc	 rbx

; 6053 : 
; 6054 :         /* \uXXXX with 4 hex digits, \Uxxxxxxxx with 8 */
; 6055 :         for (x = 0, i = 0; i < count; ++i, ++s) {

  001b6	45 8b c4	 mov	 r8d, r12d
  001b9	48 89 5d 67	 mov	 QWORD PTR s$[rbp-121], rbx
  001bd	41 8b d4	 mov	 edx, r12d
  001c0	45 85 c9	 test	 r9d, r9d
  001c3	0f 8e c2 fe ff
	ff		 jle	 $LN118@PyUnicode_@73
  001c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL34@PyUnicode_@73:

; 6056 :             c = (unsigned char)*s;

  001d0	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]

; 6057 :             if (!Py_ISXDIGIT(c)) {

  001d3	41 f6 04 8f 10	 test	 BYTE PTR [r15+rcx*4], 16
  001d8	74 4e		 je	 SHORT $LN111@PyUnicode_@73

; 6066 :             }
; 6067 :             x = (x<<4) & ~0xF;
; 6068 :             if (c >= '0' && c <= '9')

  001da	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  001dd	45 03 c0	 add	 r8d, r8d
  001e0	3c 09		 cmp	 al, 9
  001e2	77 0a		 ja	 SHORT $LN29@PyUnicode_@73

; 6069 :                 x += c - '0';

  001e4	0f b6 c1	 movzx	 eax, cl
  001e7	46 8d 44 c0 d0	 lea	 r8d, DWORD PTR [rax+r8*8-48]
  001ec	eb 16		 jmp	 SHORT $LN33@PyUnicode_@73
$LN29@PyUnicode_@73:

; 6070 :             else if (c >= 'a' && c <= 'f')

  001ee	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  001f1	3c 05		 cmp	 al, 5

; 6071 :                 x += 10 + c - 'a';

  001f3	0f b6 c1	 movzx	 eax, cl
  001f6	77 07		 ja	 SHORT $LN27@PyUnicode_@73
  001f8	46 8d 44 c0 a9	 lea	 r8d, DWORD PTR [rax+r8*8-87]

; 6072 :             else

  001fd	eb 05		 jmp	 SHORT $LN33@PyUnicode_@73
$LN27@PyUnicode_@73:

; 6073 :                 x += 10 + c - 'A';

  001ff	46 8d 44 c0 c9	 lea	 r8d, DWORD PTR [rax+r8*8-55]
$LN33@PyUnicode_@73:

; 6053 : 
; 6054 :         /* \uXXXX with 4 hex digits, \Uxxxxxxxx with 8 */
; 6055 :         for (x = 0, i = 0; i < count; ++i, ++s) {

  00204	48 ff c3	 inc	 rbx
  00207	ff c2		 inc	 edx
  00209	48 89 5d 67	 mov	 QWORD PTR s$[rbp-121], rbx
  0020d	41 3b d1	 cmp	 edx, r9d
  00210	7c be		 jl	 SHORT $LL34@PyUnicode_@73

; 6074 :         }
; 6075 :         if (x <= MAX_UNICODE) {

  00212	41 81 f8 ff ff
	10 00		 cmp	 r8d, 1114111		; 0010ffffH
  00219	0f 86 6c fe ff
	ff		 jbe	 $LN118@PyUnicode_@73

; 6077 :                 goto onError;
; 6078 :         } else {
; 6079 :             endinpos = s-starts;
; 6080 :             if (unicode_decode_call_errorhandler(
; 6081 :                     errors, &errorHandler,
; 6082 :                     "rawunicodeescape", "\\Uxxxxxxxx out of range",
; 6083 :                     &starts, &end, &startinpos, &endinpos, &exc, &s,
; 6084 :                     &v, &outpos))

  0021f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BI@LBMJFPF@?2Uxxxxxxxx?5out?5of?5range?$AA@
  00226	eb 07		 jmp	 SHORT $LN127@PyUnicode_@73
$LN111@PyUnicode_@73:

; 6058 :                 endinpos = s-starts;
; 6059 :                 if (unicode_decode_call_errorhandler(
; 6060 :                         errors, &errorHandler,
; 6061 :                         "rawunicodeescape", "truncated \\uXXXX",
; 6062 :                         &starts, &end, &startinpos, &endinpos, &exc, &s,
; 6063 :                         &v, &outpos))

  00228	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BB@CDHIBBOE@truncated?5?2uXXXX?$AA@
$LN127@PyUnicode_@73:
  0022f	48 8d 45 7f	 lea	 rax, QWORD PTR outpos$[rbp-121]
  00233	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BB@JGNLGDNO@rawunicodeescape?$AA@
  0023a	48 8d 55 ff	 lea	 rdx, QWORD PTR errorHandler$[rbp-121]
  0023e	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00243	48 8d 45 e7	 lea	 rax, QWORD PTR v$[rbp-121]
  00247	49 2b dd	 sub	 rbx, r13
  0024a	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0024f	48 8d 45 67	 lea	 rax, QWORD PTR s$[rbp-121]
  00253	49 8b ce	 mov	 rcx, r14
  00256	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0025b	48 8d 45 07	 lea	 rax, QWORD PTR exc$[rbp-121]
  0025f	48 89 5d 0f	 mov	 QWORD PTR endinpos$[rbp-121], rbx
  00263	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00268	48 8d 45 0f	 lea	 rax, QWORD PTR endinpos$[rbp-121]
  0026c	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00271	48 8d 45 17	 lea	 rax, QWORD PTR startinpos$[rbp-121]
  00275	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0027a	48 8d 45 f7	 lea	 rax, QWORD PTR end$[rbp-121]
  0027e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00283	48 8d 45 ef	 lea	 rax, QWORD PTR starts$[rbp-121]
  00287	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0028c	e8 00 00 00 00	 call	 unicode_decode_call_errorhandler
  00291	85 c0		 test	 eax, eax
  00293	75 11		 jne	 SHORT $LN121@PyUnicode_@73

; 6064 :                     goto onError;
; 6065 :                 goto nextByte;

  00295	48 8b 5d 67	 mov	 rbx, QWORD PTR s$[rbp-121]
  00299	4c 8b 6d ef	 mov	 r13, QWORD PTR starts$[rbp-121]
  0029d	48 8b 75 f7	 mov	 rsi, QWORD PTR end$[rbp-121]
  002a1	e9 fa fd ff ff	 jmp	 $nextByte$132027
$LN121@PyUnicode_@73:

; 6085 :                 goto onError;
; 6086 :         }
; 6087 :       nextByte:
; 6088 :         ;
; 6089 :     }
; 6090 :     if (unicode_resize(&v, outpos) < 0)

  002a6	4c 8b 65 ff	 mov	 r12, QWORD PTR errorHandler$[rbp-121]
  002aa	48 8b 7d 07	 mov	 rdi, QWORD PTR exc$[rbp-121]
  002ae	e9 0f fe ff ff	 jmp	 $onError$131998

; 6095 : 
; 6096 :   onError:
; 6097 :     Py_XDECREF(v);

$LN80@PyUnicode_@73:
  002b3	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  002b7	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002bd	eb 08		 jmp	 SHORT $LN11@PyUnicode_@73
$LN75@PyUnicode_@73:
  002bf	48 8b cb	 mov	 rcx, rbx
  002c2	e8 00 00 00 00	 call	 Px_DecRef
$LN11@PyUnicode_@73:

; 6098 :     Py_XDECREF(errorHandler);

  002c7	4d 85 e4	 test	 r12, r12
  002ca	74 68		 je	 SHORT $LN7@PyUnicode_@73
  002cc	e8 00 00 00 00	 call	 _Py_PXCTX
  002d1	85 c0		 test	 eax, eax
  002d3	75 5f		 jne	 SHORT $LN7@PyUnicode_@73
  002d5	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  002da	a8 20		 test	 al, 32			; 00000020H
  002dc	75 4e		 jne	 SHORT $LN86@PyUnicode_@73
  002de	84 c0		 test	 al, al
  002e0	78 4a		 js	 SHORT $LN86@PyUnicode_@73
  002e2	a8 02		 test	 al, 2
  002e4	75 4e		 jne	 SHORT $LN7@PyUnicode_@73
  002e6	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  002eb	75 47		 jne	 SHORT $LN7@PyUnicode_@73
  002ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  002fb	4d 8b cc	 mov	 r9, r12
  002fe	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00304	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0030c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00311	49 8b cc	 mov	 rcx, r12
  00314	85 c0		 test	 eax, eax
  00316	74 07		 je	 SHORT $LN91@PyUnicode_@73
  00318	e8 00 00 00 00	 call	 _Px_Dealloc
  0031d	eb 15		 jmp	 SHORT $LN7@PyUnicode_@73
$LN91@PyUnicode_@73:
  0031f	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  00324	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0032a	eb 08		 jmp	 SHORT $LN7@PyUnicode_@73
$LN86@PyUnicode_@73:
  0032c	49 8b cc	 mov	 rcx, r12
  0032f	e8 00 00 00 00	 call	 Px_DecRef
$LN7@PyUnicode_@73:

; 6099 :     Py_XDECREF(exc);

  00334	48 85 ff	 test	 rdi, rdi
  00337	74 4f		 je	 SHORT $LN3@PyUnicode_@73
  00339	e8 00 00 00 00	 call	 _Py_PXCTX
  0033e	85 c0		 test	 eax, eax
  00340	75 46		 jne	 SHORT $LN3@PyUnicode_@73
  00342	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00346	a8 20		 test	 al, 32			; 00000020H
  00348	75 67		 jne	 SHORT $LN97@PyUnicode_@73
  0034a	84 c0		 test	 al, al
  0034c	78 63		 js	 SHORT $LN97@PyUnicode_@73
  0034e	a8 02		 test	 al, 2
  00350	75 36		 jne	 SHORT $LN3@PyUnicode_@73
  00352	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00356	75 30		 jne	 SHORT $LN3@PyUnicode_@73
  00358	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0035f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00366	4c 8b cf	 mov	 r9, rdi
  00369	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0036f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00377	e8 00 00 00 00	 call	 _PyParallel_Guard
  0037c	48 8b cf	 mov	 rcx, rdi
  0037f	85 c0		 test	 eax, eax
  00381	74 22		 je	 SHORT $LN102@PyUnicode_@73
  00383	e8 00 00 00 00	 call	 _Px_Dealloc
$LN3@PyUnicode_@73:

; 6100 :     return NULL;

  00388	33 c0		 xor	 eax, eax
$LN47@PyUnicode_@73:

; 6101 : }

  0038a	48 8b 9c 24 e8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+232]
  00392	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00399	41 5f		 pop	 r15
  0039b	41 5e		 pop	 r14
  0039d	41 5d		 pop	 r13
  0039f	41 5c		 pop	 r12
  003a1	5f		 pop	 rdi
  003a2	5e		 pop	 rsi
  003a3	5d		 pop	 rbp
  003a4	c3		 ret	 0

; 6099 :     Py_XDECREF(exc);

$LN102@PyUnicode_@73:
  003a5	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  003a9	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  003af	eb d7		 jmp	 SHORT $LN3@PyUnicode_@73
$LN97@PyUnicode_@73:
  003b1	48 8b cf	 mov	 rcx, rdi
  003b4	e8 00 00 00 00	 call	 Px_DecRef
  003b9	eb cd		 jmp	 SHORT $LN3@PyUnicode_@73
$LN20@PyUnicode_@73:

; 6091 :         goto onError;
; 6092 :     Py_XDECREF(errorHandler);

  003bb	4d 85 e4	 test	 r12, r12
  003be	74 68		 je	 SHORT $LN19@PyUnicode_@73
  003c0	e8 00 00 00 00	 call	 _Py_PXCTX
  003c5	85 c0		 test	 eax, eax
  003c7	75 5f		 jne	 SHORT $LN19@PyUnicode_@73
  003c9	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  003ce	a8 20		 test	 al, 32			; 00000020H
  003d0	75 4e		 jne	 SHORT $LN53@PyUnicode_@73
  003d2	84 c0		 test	 al, al
  003d4	78 4a		 js	 SHORT $LN53@PyUnicode_@73
  003d6	a8 02		 test	 al, 2
  003d8	75 4e		 jne	 SHORT $LN19@PyUnicode_@73
  003da	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  003df	75 47		 jne	 SHORT $LN19@PyUnicode_@73
  003e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  003ef	4d 8b cc	 mov	 r9, r12
  003f2	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  003f8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00400	e8 00 00 00 00	 call	 _PyParallel_Guard
  00405	49 8b cc	 mov	 rcx, r12
  00408	85 c0		 test	 eax, eax
  0040a	74 07		 je	 SHORT $LN58@PyUnicode_@73
  0040c	e8 00 00 00 00	 call	 _Px_Dealloc
  00411	eb 15		 jmp	 SHORT $LN19@PyUnicode_@73
$LN58@PyUnicode_@73:
  00413	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  00418	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0041e	eb 08		 jmp	 SHORT $LN19@PyUnicode_@73
$LN53@PyUnicode_@73:
  00420	49 8b cc	 mov	 rcx, r12
  00423	e8 00 00 00 00	 call	 Px_DecRef
$LN19@PyUnicode_@73:

; 6093 :     Py_XDECREF(exc);

  00428	48 85 ff	 test	 rdi, rdi
  0042b	74 7d		 je	 SHORT $LN15@PyUnicode_@73
  0042d	e8 00 00 00 00	 call	 _Py_PXCTX
  00432	85 c0		 test	 eax, eax
  00434	75 74		 jne	 SHORT $LN15@PyUnicode_@73
  00436	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0043a	a8 20		 test	 al, 32			; 00000020H
  0043c	75 64		 jne	 SHORT $LN64@PyUnicode_@73
  0043e	84 c0		 test	 al, al
  00440	78 60		 js	 SHORT $LN64@PyUnicode_@73
  00442	a8 02		 test	 al, 2
  00444	75 64		 jne	 SHORT $LN15@PyUnicode_@73
  00446	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0044a	75 5e		 jne	 SHORT $LN15@PyUnicode_@73
  0044c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00453	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0045a	4c 8b cf	 mov	 r9, rdi
  0045d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00463	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0046b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00470	48 8b cf	 mov	 rcx, rdi
  00473	85 c0		 test	 eax, eax
  00475	74 13		 je	 SHORT $LN69@PyUnicode_@73
  00477	e8 00 00 00 00	 call	 _Px_Dealloc

; 6094 :     return unicode_result(v);

  0047c	48 8b 4d e7	 mov	 rcx, QWORD PTR v$[rbp-121]
  00480	e8 00 00 00 00	 call	 unicode_result
  00485	e9 00 ff ff ff	 jmp	 $LN47@PyUnicode_@73

; 6093 :     Py_XDECREF(exc);

$LN69@PyUnicode_@73:
  0048a	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0048e	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 6094 :     return unicode_result(v);

  00494	48 8b 4d e7	 mov	 rcx, QWORD PTR v$[rbp-121]
  00498	e8 00 00 00 00	 call	 unicode_result
  0049d	e9 e8 fe ff ff	 jmp	 $LN47@PyUnicode_@73

; 6093 :     Py_XDECREF(exc);

$LN64@PyUnicode_@73:
  004a2	48 8b cf	 mov	 rcx, rdi
  004a5	e8 00 00 00 00	 call	 Px_DecRef
$LN15@PyUnicode_@73:

; 6094 :     return unicode_result(v);

  004aa	48 8b 4d e7	 mov	 rcx, QWORD PTR v$[rbp-121]
  004ae	e8 00 00 00 00	 call	 unicode_result
  004b3	e9 d2 fe ff ff	 jmp	 $LN47@PyUnicode_@73
PyUnicode_DecodeRawUnicodeEscape ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_EncodeRawUnicodeEscape
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_EncodeRawUnicodeEscape DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$PyUnicode_EncodeRawUnicodeEscape
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_EncodeRawUnicodeEscape DD 042101H
	DD	063421H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_EncodeRawUnicodeEscape
_TEXT	SEGMENT
s$ = 48
size$ = 56
PyUnicode_EncodeRawUnicodeEscape PROC			; COMDAT

; 6177 : {

$LN4:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 6178 :     PyObject *result;
; 6179 :     PyObject *tmp = PyUnicode_FromUnicode(s, size);

  00006	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  0000b	48 8b f8	 mov	 rdi, rax

; 6180 :     if (tmp == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 06		 jne	 SHORT $LN1@PyUnicode_@74

; 6185 : }

  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5f		 pop	 rdi
  00018	c3		 ret	 0
$LN1@PyUnicode_@74:

; 6181 :         return NULL;
; 6182 :     result = PyUnicode_AsRawUnicodeEscapeString(tmp);

  00019	48 8b c8	 mov	 rcx, rax
  0001c	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00021	e8 00 00 00 00	 call	 PyUnicode_AsRawUnicodeEscapeString

; 6183 :     Py_DECREF(tmp);

  00026	48 8b cf	 mov	 rcx, rdi
  00029	48 8b d8	 mov	 rbx, rax
  0002c	e8 00 00 00 00	 call	 _Py_DecRef

; 6184 :     return result;

  00031	48 8b c3	 mov	 rax, rbx
  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 6185 : }

  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
PyUnicode_EncodeRawUnicodeEscape ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@LNHLEJMI@unicode_internal?$AA@	; `string'
PUBLIC	??_C@_0BA@OLGDILHA@truncated?5input?$AA@	; `string'
PUBLIC	??_C@_0CL@NLHPDIOL@unicode_internal?5codec?5has?5been?5@ ; `string'
PUBLIC	_PyUnicode_DecodeUnicodeInternal
EXTRN	PyErr_WarnEx:PROC
EXTRN	PyExc_DeprecationWarning:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_DecodeUnicodeInternal DD imagerel $LN39
	DD	imagerel $LN39+602
	DD	imagerel $unwind$_PyUnicode_DecodeUnicodeInternal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_DecodeUnicodeInternal DD 0b2301H
	DD	01e6423H
	DD	01d3423H
	DD	0160123H
	DD	0d015e017H
	DD	07011c013H
	DD	05010H
xdata	ENDS
;	COMDAT ??_C@_0BB@LNHLEJMI@unicode_internal?$AA@
CONST	SEGMENT
??_C@_0BB@LNHLEJMI@unicode_internal?$AA@ DB 'unicode_internal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OLGDILHA@truncated?5input?$AA@
CONST	SEGMENT
??_C@_0BA@OLGDILHA@truncated?5input?$AA@ DB 'truncated input', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NLHPDIOL@unicode_internal?5codec?5has?5been?5@
CONST	SEGMENT
??_C@_0CL@NLHPDIOL@unicode_internal?5codec?5has?5been?5@ DB 'unicode_inte'
	DB	'rnal codec has been deprecated', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyUnicode_DecodeUnicodeInternal
_TEXT	SEGMENT
uch2$132176 = 96
v$ = 104
exc$ = 112
errorHandler$ = 120
outpos$ = 128
starts$ = 136
end$ = 144
endinpos$ = 152
startinpos$ = 160
s$ = 224
size$ = 232
errors$ = 240
uch$132168 = 248
_PyUnicode_DecodeUnicodeInternal PROC			; COMDAT

; 6193 : {

$LN39:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	41 54		 push	 r12
  00013	41 55		 push	 r13
  00015	41 56		 push	 r14
  00017	48 8d 6c 24 c9	 lea	 rbp, QWORD PTR [rsp-55]
  0001c	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H

; 6194 :     const char *starts = s;
; 6195 :     Py_ssize_t startinpos;
; 6196 :     Py_ssize_t endinpos;
; 6197 :     Py_ssize_t outpos;
; 6198 :     PyObject *v;
; 6199 :     const char *end;
; 6200 :     const char *reason;
; 6201 :     PyObject *errorHandler = NULL;

  00023	33 f6		 xor	 esi, esi
  00025	48 8b d9	 mov	 rbx, rcx
  00028	4c 8b e9	 mov	 r13, rcx
  0002b	48 89 4d 0f	 mov	 QWORD PTR starts$[rbp-121], rcx

; 6202 :     PyObject *exc = NULL;
; 6203 : 
; 6204 :     if (PyErr_WarnEx(PyExc_DeprecationWarning,
; 6205 :                      "unicode_internal codec has been deprecated",
; 6206 :                      1))

  0002f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_DeprecationWarning
  00036	4d 8b f0	 mov	 r14, r8
  00039	48 8b fa	 mov	 rdi, rdx
  0003c	44 8d 46 01	 lea	 r8d, QWORD PTR [rsi+1]
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@NLHPDIOL@unicode_internal?5codec?5has?5been?5@
  00047	48 89 75 ff	 mov	 QWORD PTR errorHandler$[rbp-121], rsi
  0004b	44 8b e6	 mov	 r12d, esi
  0004e	48 89 75 f7	 mov	 QWORD PTR exc$[rbp-121], rsi
  00052	e8 00 00 00 00	 call	 PyErr_WarnEx
  00057	85 c0		 test	 eax, eax

; 6207 :         return NULL;

  00059	0f 85 ae 01 00
	00		 jne	 $LN3@PyUnicode_@75

; 6208 : 
; 6209 :     /* XXX overflow detection missing */
; 6210 :     v = PyUnicode_New((size+Py_UNICODE_SIZE-1)/ Py_UNICODE_SIZE, 127);

  0005f	48 8d 47 01	 lea	 rax, QWORD PTR [rdi+1]
  00063	48 99		 cdq
  00065	48 2b c2	 sub	 rax, rdx
  00068	8d 56 7f	 lea	 edx, QWORD PTR [rsi+127]
  0006b	48 d1 f8	 sar	 rax, 1
  0006e	48 8b c8	 mov	 rcx, rax
  00071	e8 00 00 00 00	 call	 PyUnicode_New
  00076	48 89 45 ef	 mov	 QWORD PTR v$[rbp-121], rax

; 6211 :     if (v == NULL)

  0007a	48 85 c0	 test	 rax, rax
  0007d	0f 84 8a 01 00
	00		 je	 $LN3@PyUnicode_@75

; 6212 :         goto onError;
; 6213 :     if (PyUnicode_GET_LENGTH(v) == 0)

  00083	48 39 70 60	 cmp	 QWORD PTR [rax+96], rsi

; 6214 :         return v;

  00087	0f 84 82 01 00
	00		 je	 $LN32@PyUnicode_@75

; 6215 :     outpos = 0;
; 6216 :     end = s + size;

  0008d	48 03 fb	 add	 rdi, rbx
  00090	8b d6		 mov	 edx, esi
  00092	48 89 55 07	 mov	 QWORD PTR outpos$[rbp-121], rdx
  00096	48 89 7d 17	 mov	 QWORD PTR end$[rbp-121], rdi

; 6217 : 
; 6218 :     while (s < end) {

  0009a	48 3b df	 cmp	 rbx, rdi
  0009d	0f 83 35 01 00
	00		 jae	 $LN27@PyUnicode_@75
  000a3	be ff 03 00 00	 mov	 esi, 1023		; 000003ffH
  000a8	41 bc 00 24 00
	00		 mov	 r12d, 9216		; 00002400H
  000ae	66 90		 npad	 2
$LL28@PyUnicode_@75:

; 6219 :         Py_UNICODE uch;
; 6220 :         Py_UCS4 ch;
; 6221 :         if (end - s < Py_UNICODE_SIZE) {

  000b0	48 8b c7	 mov	 rax, rdi
  000b3	48 2b c3	 sub	 rax, rbx
  000b6	48 83 f8 02	 cmp	 rax, 2
  000ba	0f 8d 86 00 00
	00		 jge	 $LN26@PyUnicode_@75

; 6260 :             goto onError;
; 6261 :         continue;
; 6262 : 
; 6263 :   error:
; 6264 :         startinpos = s - starts;
; 6265 :         if (unicode_decode_call_errorhandler(
; 6266 :                 errors, &errorHandler,
; 6267 :                 "unicode_internal", reason,
; 6268 :                 &starts, &end, &startinpos, &endinpos, &exc, &s,
; 6269 :                 &v, &outpos))

  000c0	48 8d 45 07	 lea	 rax, QWORD PTR outpos$[rbp-121]
  000c4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BA@OLGDILHA@truncated?5input?$AA@
  000cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BB@LNHLEJMI@unicode_internal?$AA@
  000d2	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  000d7	48 8d 45 ef	 lea	 rax, QWORD PTR v$[rbp-121]
  000db	48 8d 55 ff	 lea	 rdx, QWORD PTR errorHandler$[rbp-121]
  000df	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  000e4	48 8d 45 67	 lea	 rax, QWORD PTR s$[rbp-121]
  000e8	49 2b fd	 sub	 rdi, r13
  000eb	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  000f0	48 8d 45 f7	 lea	 rax, QWORD PTR exc$[rbp-121]
  000f4	49 2b dd	 sub	 rbx, r13
  000f7	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000fc	48 8d 45 1f	 lea	 rax, QWORD PTR endinpos$[rbp-121]
  00100	49 8b ce	 mov	 rcx, r14
  00103	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00108	48 8d 45 27	 lea	 rax, QWORD PTR startinpos$[rbp-121]
  0010c	48 89 7d 1f	 mov	 QWORD PTR endinpos$[rbp-121], rdi
  00110	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00115	48 8d 45 17	 lea	 rax, QWORD PTR end$[rbp-121]
$error$132172:
  00119	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0011e	48 8d 45 0f	 lea	 rax, QWORD PTR starts$[rbp-121]
  00122	48 89 5d 27	 mov	 QWORD PTR startinpos$[rbp-121], rbx
  00126	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012b	e8 00 00 00 00	 call	 unicode_decode_call_errorhandler
  00130	85 c0		 test	 eax, eax
  00132	0f 85 f3 00 00
	00		 jne	 $LN38@PyUnicode_@75

; 6270 :             goto onError;
; 6271 :     }

  00138	48 8b 5d 67	 mov	 rbx, QWORD PTR s$[rbp-121]
  0013c	4c 8b 6d 0f	 mov	 r13, QWORD PTR starts$[rbp-121]
  00140	48 8b 7d 17	 mov	 rdi, QWORD PTR end$[rbp-121]
  00144	eb 7d		 jmp	 SHORT $LN23@PyUnicode_@75
$LN26@PyUnicode_@75:

; 6222 :             endinpos = end-starts;
; 6223 :             reason = "truncated input";
; 6224 :             goto error;
; 6225 :         }
; 6226 :         /* We copy the raw representation one byte at a time because the
; 6227 :            pointer may be unaligned (see test_codeccallbacks). */
; 6228 :         ((char *) &uch)[0] = s[0];

  00146	0f b6 03	 movzx	 eax, BYTE PTR [rbx]

; 6229 :         ((char *) &uch)[1] = s[1];
; 6230 : #ifdef Py_UNICODE_WIDE
; 6231 :         ((char *) &uch)[2] = s[2];
; 6232 :         ((char *) &uch)[3] = s[3];
; 6233 : #endif
; 6234 :         ch = uch;
; 6235 : #ifdef Py_UNICODE_WIDE
; 6236 :         /* We have to sanity check the raw data, otherwise doom looms for
; 6237 :            some malformed UCS-4 data. */
; 6238 :         if (ch > 0x10ffff) {
; 6239 :             endinpos = s - starts + Py_UNICODE_SIZE;
; 6240 :             reason = "illegal code point (> 0x10FFFF)";
; 6241 :             goto error;
; 6242 :         }
; 6243 : #endif
; 6244 :         s += Py_UNICODE_SIZE;

  00149	48 83 c3 02	 add	 rbx, 2
  0014d	88 45 7f	 mov	 BYTE PTR uch$132168[rbp-121], al
  00150	0f b6 43 ff	 movzx	 eax, BYTE PTR [rbx-1]
  00154	48 89 5d 67	 mov	 QWORD PTR s$[rbp-121], rbx
  00158	88 85 80 00 00
	00		 mov	 BYTE PTR uch$132168[rbp-120], al
  0015e	44 0f b7 45 7f	 movzx	 r8d, WORD PTR uch$132168[rbp-121]

; 6245 : #ifndef Py_UNICODE_WIDE
; 6246 :         if (Py_UNICODE_IS_HIGH_SURROGATE(ch) && end - s >= Py_UNICODE_SIZE)

  00163	41 8d 80 00 28
	ff ff		 lea	 eax, DWORD PTR [r8-55296]
  0016a	3b c6		 cmp	 eax, esi
  0016c	77 44		 ja	 SHORT $LN24@PyUnicode_@75
  0016e	48 8b c7	 mov	 rax, rdi
  00171	48 2b c3	 sub	 rax, rbx
  00174	48 83 f8 02	 cmp	 rax, 2
  00178	7c 38		 jl	 SHORT $LN24@PyUnicode_@75

; 6247 :         {
; 6248 :             Py_UNICODE uch2;
; 6249 :             ((char *) &uch2)[0] = s[0];

  0017a	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  0017d	88 45 e7	 mov	 BYTE PTR uch2$132176[rbp-121], al

; 6250 :             ((char *) &uch2)[1] = s[1];

  00180	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]
  00184	88 45 e8	 mov	 BYTE PTR uch2$132176[rbp-120], al

; 6251 :             if (Py_UNICODE_IS_LOW_SURROGATE(uch2))

  00187	0f b7 4d e7	 movzx	 ecx, WORD PTR uch2$132176[rbp-121]
  0018b	41 8d 04 0c	 lea	 eax, DWORD PTR [r12+rcx]
  0018f	66 3b c6	 cmp	 ax, si
  00192	77 1e		 ja	 SHORT $LN24@PyUnicode_@75

; 6252 :             {
; 6253 :                 ch = Py_UNICODE_JOIN_SURROGATES(uch, uch2);

  00194	44 23 c6	 and	 r8d, esi
  00197	0f b7 c1	 movzx	 eax, cx
  0019a	41 c1 e0 0a	 shl	 r8d, 10
  0019e	23 c6		 and	 eax, esi
  001a0	44 0b c0	 or	 r8d, eax
  001a3	41 81 c0 00 00
	01 00		 add	 r8d, 65536		; 00010000H

; 6254 :                 s += Py_UNICODE_SIZE;

  001aa	48 83 c3 02	 add	 rbx, 2
  001ae	48 89 5d 67	 mov	 QWORD PTR s$[rbp-121], rbx
$LN24@PyUnicode_@75:

; 6255 :             }
; 6256 :         }
; 6257 : #endif
; 6258 : 
; 6259 :         if (unicode_putchar(&v, &outpos, ch) < 0)

  001b2	48 8d 55 07	 lea	 rdx, QWORD PTR outpos$[rbp-121]
  001b6	48 8d 4d ef	 lea	 rcx, QWORD PTR v$[rbp-121]
  001ba	e8 00 00 00 00	 call	 unicode_putchar
  001bf	85 c0		 test	 eax, eax
  001c1	78 68		 js	 SHORT $LN38@PyUnicode_@75
$LN23@PyUnicode_@75:

; 6217 : 
; 6218 :     while (s < end) {

  001c3	48 3b df	 cmp	 rbx, rdi
  001c6	0f 82 e4 fe ff
	ff		 jb	 $LL28@PyUnicode_@75
  001cc	48 8b 75 ff	 mov	 rsi, QWORD PTR errorHandler$[rbp-121]
  001d0	4c 8b 65 f7	 mov	 r12, QWORD PTR exc$[rbp-121]
  001d4	48 8b 55 07	 mov	 rdx, QWORD PTR outpos$[rbp-121]
$LN27@PyUnicode_@75:

; 6272 : 
; 6273 :     if (unicode_resize(&v, outpos) < 0)

  001d8	48 8d 4d ef	 lea	 rcx, QWORD PTR v$[rbp-121]
  001dc	e8 00 00 00 00	 call	 unicode_resize
  001e1	85 c0		 test	 eax, eax
  001e3	79 50		 jns	 SHORT $LN20@PyUnicode_@75
$onError$132160:

; 6278 : 
; 6279 :   onError:
; 6280 :     Py_XDECREF(v);

  001e5	48 8b 4d ef	 mov	 rcx, QWORD PTR v$[rbp-121]
  001e9	48 85 c9	 test	 rcx, rcx
  001ec	74 05		 je	 SHORT $LN11@PyUnicode_@75
  001ee	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@PyUnicode_@75:

; 6281 :     Py_XDECREF(errorHandler);

  001f3	48 85 f6	 test	 rsi, rsi
  001f6	74 08		 je	 SHORT $LN7@PyUnicode_@75
  001f8	48 8b ce	 mov	 rcx, rsi
  001fb	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@PyUnicode_@75:

; 6282 :     Py_XDECREF(exc);

  00200	4d 85 e4	 test	 r12, r12
  00203	74 08		 je	 SHORT $LN3@PyUnicode_@75
  00205	49 8b cc	 mov	 rcx, r12
  00208	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyUnicode_@75:

; 6283 :     return NULL;

  0020d	33 c0		 xor	 eax, eax
$LN32@PyUnicode_@75:

; 6284 : }

  0020f	4c 8d 9c 24 b0
	00 00 00	 lea	 r11, QWORD PTR [rsp+176]
  00217	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  0021b	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  0021f	49 8b e3	 mov	 rsp, r11
  00222	41 5e		 pop	 r14
  00224	41 5d		 pop	 r13
  00226	41 5c		 pop	 r12
  00228	5f		 pop	 rdi
  00229	5d		 pop	 rbp
  0022a	c3		 ret	 0
$LN38@PyUnicode_@75:

; 6272 : 
; 6273 :     if (unicode_resize(&v, outpos) < 0)

  0022b	48 8b 75 ff	 mov	 rsi, QWORD PTR errorHandler$[rbp-121]
  0022f	4c 8b 65 f7	 mov	 r12, QWORD PTR exc$[rbp-121]
  00233	eb b0		 jmp	 SHORT $onError$132160
$LN20@PyUnicode_@75:

; 6274 :         goto onError;
; 6275 :     Py_XDECREF(errorHandler);

  00235	48 85 f6	 test	 rsi, rsi
  00238	74 08		 je	 SHORT $LN19@PyUnicode_@75
  0023a	48 8b ce	 mov	 rcx, rsi
  0023d	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@PyUnicode_@75:

; 6276 :     Py_XDECREF(exc);

  00242	4d 85 e4	 test	 r12, r12
  00245	74 08		 je	 SHORT $LN15@PyUnicode_@75
  00247	49 8b cc	 mov	 rcx, r12
  0024a	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@PyUnicode_@75:

; 6277 :     return unicode_result(v);

  0024f	48 8b 4d ef	 mov	 rcx, QWORD PTR v$[rbp-121]
  00253	e8 00 00 00 00	 call	 unicode_result
  00258	eb b5		 jmp	 SHORT $LN32@PyUnicode_@75
_PyUnicode_DecodeUnicodeInternal ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_EncodeLatin1
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_EncodeLatin1 DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$PyUnicode_EncodeLatin1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_EncodeLatin1 DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_EncodeLatin1
_TEXT	SEGMENT
p$ = 48
size$ = 56
errors$ = 64
PyUnicode_EncodeLatin1 PROC				; COMDAT

; 6600 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b d8	 mov	 rbx, r8

; 6601 :     PyObject *result;
; 6602 :     PyObject *unicode = PyUnicode_FromUnicode(p, size);

  0000d	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  00012	48 8b f8	 mov	 rdi, rax

; 6603 :     if (unicode == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0b		 jne	 SHORT $LN1@PyUnicode_@76

; 6608 : }

  0001a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
$LN1@PyUnicode_@76:

; 6604 :         return NULL;
; 6605 :     result = unicode_encode_ucs1(unicode, errors, 256);

  00025	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0002b	48 8b d3	 mov	 rdx, rbx
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 unicode_encode_ucs1

; 6606 :     Py_DECREF(unicode);

  00036	48 8b cf	 mov	 rcx, rdi
  00039	48 8b d8	 mov	 rbx, rax
  0003c	e8 00 00 00 00	 call	 _Py_DecRef

; 6607 :     return result;

  00041	48 8b c3	 mov	 rax, rbx

; 6608 : }

  00044	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
PyUnicode_EncodeLatin1 ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_DecodeASCII
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_DecodeASCII DD imagerel $LN65
	DD	imagerel $LN65+161
	DD	imagerel $unwind$PyUnicode_DecodeASCII
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyUnicode_DecodeASCII DD imagerel $LN65+161
	DD	imagerel $LN65+663
	DD	imagerel $chain$1$PyUnicode_DecodeASCII
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyUnicode_DecodeASCII DD imagerel $LN65+663
	DD	imagerel $LN65+680
	DD	imagerel $chain$2$PyUnicode_DecodeASCII
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyUnicode_DecodeASCII DD imagerel $LN65+680
	DD	imagerel $LN65+722
	DD	imagerel $chain$3$PyUnicode_DecodeASCII
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyUnicode_DecodeASCII DD 040021H
	DD	012d400H
	DD	01c7400H
	DD	imagerel $LN65
	DD	imagerel $LN65+161
	DD	imagerel $unwind$PyUnicode_DecodeASCII
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyUnicode_DecodeASCII DD 021H
	DD	imagerel $LN65
	DD	imagerel $LN65+161
	DD	imagerel $unwind$PyUnicode_DecodeASCII
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyUnicode_DecodeASCII DD 041021H
	DD	012d410H
	DD	01c7408H
	DD	imagerel $LN65
	DD	imagerel $LN65+161
	DD	imagerel $unwind$PyUnicode_DecodeASCII
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_DecodeASCII DD 081601H
	DD	0130116H
	DD	0e008f00aH
	DD	06004c006H
	DD	050023003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_DecodeASCII
_TEXT	SEGMENT
e$ = 96
errorHandler$ = 104
exc$ = 112
starts$ = 120
endinpos$ = 128
startinpos$ = 136
s$ = 208
outpos$ = 216
size$ = 216
errors$ = 224
unicode$ = 232
PyUnicode_DecodeASCII PROC				; COMDAT

; 6641 : {

$LN65:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	56		 push	 rsi
  00004	41 54		 push	 r12
  00006	41 56		 push	 r14
  00008	41 57		 push	 r15
  0000a	48 8d 6c 24 d1	 lea	 rbp, QWORD PTR [rsp-47]
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 6642 :     const char *starts = s;
; 6643 :     PyObject *unicode;
; 6644 :     int kind;
; 6645 :     void *data;
; 6646 :     Py_ssize_t startinpos;
; 6647 :     Py_ssize_t endinpos;
; 6648 :     Py_ssize_t outpos;
; 6649 :     const char *e;
; 6650 :     PyObject *errorHandler = NULL;

  00016	33 f6		 xor	 esi, esi
  00018	4d 8b f8	 mov	 r15, r8
  0001b	4c 8b f2	 mov	 r14, rdx
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	48 89 4d 0f	 mov	 QWORD PTR starts$[rbp-105], rcx
  00025	48 89 75 ff	 mov	 QWORD PTR errorHandler$[rbp-105], rsi

; 6651 :     PyObject *exc = NULL;

  00029	44 8b e6	 mov	 r12d, esi
  0002c	48 89 75 07	 mov	 QWORD PTR exc$[rbp-105], rsi

; 6652 : 
; 6653 :     if (size == 0)

  00030	48 85 d2	 test	 rdx, rdx
  00033	75 41		 jne	 SHORT $LN44@PyUnicode_@77

; 6654 :         _Py_RETURN_UNICODE_EMPTY();

  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  0003c	48 85 c9	 test	 rcx, rcx
  0003f	75 18		 jne	 SHORT $LN63@PyUnicode_@77
  00041	e8 00 00 00 00	 call	 PyUnicode_New
  00046	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  0004d	48 85 c0	 test	 rax, rax
  00050	0f 84 41 02 00
	00		 je	 $LN48@PyUnicode_@77
  00056	48 8b c8	 mov	 rcx, rax
$LN63@PyUnicode_@77:
  00059	e8 00 00 00 00	 call	 _Py_IncRef
  0005e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 6703 : }

  00065	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0006c	41 5f		 pop	 r15
  0006e	41 5e		 pop	 r14
  00070	41 5c		 pop	 r12
  00072	5e		 pop	 rsi
  00073	5b		 pop	 rbx
  00074	5d		 pop	 rbp
  00075	c3		 ret	 0
$LN44@PyUnicode_@77:

; 6655 : 
; 6656 :     /* ASCII is equivalent to the first 128 ordinals in Unicode. */
; 6657 :     if (size == 1 && (unsigned char)s[0] < 128)

  00076	48 83 fa 01	 cmp	 rdx, 1
  0007a	75 1d		 jne	 SHORT $LN37@PyUnicode_@77
  0007c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0007f	80 f9 80	 cmp	 cl, 128			; 00000080H
  00082	73 15		 jae	 SHORT $LN37@PyUnicode_@77

; 6703 : }

  00084	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0008b	41 5f		 pop	 r15
  0008d	41 5e		 pop	 r14
  0008f	41 5c		 pop	 r12
  00091	5e		 pop	 rsi
  00092	5b		 pop	 rbx
  00093	5d		 pop	 rbp
  00094	e9 00 00 00 00	 jmp	 get_latin1_char
$LN37@PyUnicode_@77:

; 6658 :         return get_latin1_char((unsigned char)s[0]);
; 6659 : 
; 6660 :     unicode = PyUnicode_New(size, 127);

  00099	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  0009e	49 8b ce	 mov	 rcx, r14
  000a1	48 89 bc 24 e0
	00 00 00	 mov	 QWORD PTR [rsp+224], rdi
  000a9	4c 89 ac 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], r13
  000b1	e8 00 00 00 00	 call	 PyUnicode_New
  000b6	4c 8b e8	 mov	 r13, rax
  000b9	48 89 45 7f	 mov	 QWORD PTR unicode$[rbp-105], rax

; 6661 :     if (unicode == NULL)

  000bd	48 85 c0	 test	 rax, rax
  000c0	0f 84 bf 01 00
	00		 je	 $LN3@PyUnicode_@77

; 6662 :         goto onError;
; 6663 : 
; 6664 :     e = s + size;
; 6665 :     data = PyUnicode_1BYTE_DATA(unicode);

  000c6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000c9	4a 8d 0c 33	 lea	 rcx, QWORD PTR [rbx+r14]
  000cd	48 89 4d f7	 mov	 QWORD PTR e$[rbp-105], rcx
  000d1	a8 20		 test	 al, 32			; 00000020H
  000d3	74 16		 je	 SHORT $LN52@PyUnicode_@77
  000d5	a8 40		 test	 al, 64			; 00000040H
  000d7	74 09		 je	 SHORT $LN50@PyUnicode_@77
  000d9	49 8d bd 80 00
	00 00		 lea	 rdi, QWORD PTR [r13+128]
  000e0	eb 10		 jmp	 SHORT $LN53@PyUnicode_@77
$LN50@PyUnicode_@77:
  000e2	49 8d bd a0 00
	00 00		 lea	 rdi, QWORD PTR [r13+160]
  000e9	eb 07		 jmp	 SHORT $LN53@PyUnicode_@77
$LN52@PyUnicode_@77:
  000eb	49 8b bd a0 00
	00 00		 mov	 rdi, QWORD PTR [r13+160]
$LN53@PyUnicode_@77:

; 6666 :     outpos = ascii_decode(s, e, (Py_UCS1 *)data);

  000f2	48 8b 55 f7	 mov	 rdx, QWORD PTR e$[rbp-105]
  000f6	4c 8b c7	 mov	 r8, rdi
  000f9	48 8b cb	 mov	 rcx, rbx
  000fc	e8 00 00 00 00	 call	 ascii_decode
  00101	48 8b d0	 mov	 rdx, rax
  00104	48 89 45 6f	 mov	 QWORD PTR outpos$[rbp-105], rax

; 6667 :     if (outpos == size)

  00108	49 3b c6	 cmp	 rax, r14
  0010b	75 08		 jne	 SHORT $LN35@PyUnicode_@77

; 6668 :         return unicode;

  0010d	49 8b c5	 mov	 rax, r13
  00110	e9 72 01 00 00	 jmp	 $LN62@PyUnicode_@77
$LN35@PyUnicode_@77:

; 6669 : 
; 6670 :     s += outpos;

  00115	48 03 d8	 add	 rbx, rax

; 6671 :     kind = PyUnicode_1BYTE_KIND;

  00118	b9 01 00 00 00	 mov	 ecx, 1
  0011d	48 89 5d 67	 mov	 QWORD PTR s$[rbp-105], rbx

; 6672 :     while (s < e) {

  00121	48 3b 5d f7	 cmp	 rbx, QWORD PTR e$[rbp-105]
  00125	0f 83 25 01 00
	00		 jae	 $LN33@PyUnicode_@77
  0012b	0f 1f 44 00 00	 npad	 5
$LL34@PyUnicode_@77:

; 6673 :         register unsigned char c = (unsigned char)*s;

  00130	44 0f b6 0b	 movzx	 r9d, BYTE PTR [rbx]

; 6674 :         if (c < 128) {

  00134	41 80 f9 80	 cmp	 r9b, 128		; 00000080H
  00138	73 55		 jae	 SHORT $LN32@PyUnicode_@77

; 6675 :             PyUnicode_WRITE(kind, data, outpos++, c);

  0013a	44 8b c1	 mov	 r8d, ecx
  0013d	41 ff c8	 dec	 r8d
  00140	74 36		 je	 SHORT $LN26@PyUnicode_@77
  00142	41 ff c8	 dec	 r8d
  00145	41 0f b6 c1	 movzx	 eax, r9b
  00149	74 16		 je	 SHORT $LN25@PyUnicode_@77
  0014b	89 04 97	 mov	 DWORD PTR [rdi+rdx*4], eax
  0014e	48 ff c2	 inc	 rdx

; 6676 :             ++s;

  00151	48 ff c3	 inc	 rbx
  00154	48 89 5d 67	 mov	 QWORD PTR s$[rbp-105], rbx
  00158	48 89 55 6f	 mov	 QWORD PTR outpos$[rbp-105], rdx

; 6677 :         }
; 6678 :         else {

  0015c	e9 dd 00 00 00	 jmp	 $LN57@PyUnicode_@77
$LN25@PyUnicode_@77:

; 6675 :             PyUnicode_WRITE(kind, data, outpos++, c);

  00161	66 89 04 57	 mov	 WORD PTR [rdi+rdx*2], ax
  00165	48 ff c2	 inc	 rdx

; 6676 :             ++s;

  00168	48 ff c3	 inc	 rbx
  0016b	48 89 5d 67	 mov	 QWORD PTR s$[rbp-105], rbx
  0016f	48 89 55 6f	 mov	 QWORD PTR outpos$[rbp-105], rdx

; 6677 :         }
; 6678 :         else {

  00173	e9 c6 00 00 00	 jmp	 $LN57@PyUnicode_@77
$LN26@PyUnicode_@77:

; 6675 :             PyUnicode_WRITE(kind, data, outpos++, c);

  00178	44 88 0c 3a	 mov	 BYTE PTR [rdx+rdi], r9b
  0017c	48 ff c2	 inc	 rdx

; 6676 :             ++s;

  0017f	48 ff c3	 inc	 rbx
  00182	48 89 5d 67	 mov	 QWORD PTR s$[rbp-105], rbx
  00186	48 89 55 6f	 mov	 QWORD PTR outpos$[rbp-105], rdx

; 6677 :         }
; 6678 :         else {

  0018a	e9 af 00 00 00	 jmp	 $LN57@PyUnicode_@77
$LN32@PyUnicode_@77:

; 6679 :             startinpos = s-starts;

  0018f	48 2b 5d 0f	 sub	 rbx, QWORD PTR starts$[rbp-105]

; 6680 :             endinpos = startinpos + 1;
; 6681 :             if (unicode_decode_call_errorhandler(
; 6682 :                     errors, &errorHandler,
; 6683 :                     "ascii", "ordinal not in range(128)",
; 6684 :                     &starts, &e, &startinpos, &endinpos, &exc, &s,
; 6685 :                     &unicode, &outpos))

  00193	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BK@JNDPLEJL@ordinal?5not?5in?5range?$CI128?$CJ?$AA@
  0019a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05OJENGABA@ascii?$AA@
  001a1	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
  001a5	48 8d 55 ff	 lea	 rdx, QWORD PTR errorHandler$[rbp-105]
  001a9	49 8b cf	 mov	 rcx, r15
  001ac	48 89 45 17	 mov	 QWORD PTR endinpos$[rbp-105], rax
  001b0	48 8d 45 6f	 lea	 rax, QWORD PTR outpos$[rbp-105]
  001b4	48 89 5d 1f	 mov	 QWORD PTR startinpos$[rbp-105], rbx
  001b8	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  001bd	48 8d 45 7f	 lea	 rax, QWORD PTR unicode$[rbp-105]
  001c1	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  001c6	48 8d 45 67	 lea	 rax, QWORD PTR s$[rbp-105]
  001ca	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  001cf	48 8d 45 07	 lea	 rax, QWORD PTR exc$[rbp-105]
  001d3	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  001d8	48 8d 45 17	 lea	 rax, QWORD PTR endinpos$[rbp-105]
  001dc	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  001e1	48 8d 45 1f	 lea	 rax, QWORD PTR startinpos$[rbp-105]
  001e5	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001ea	48 8d 45 f7	 lea	 rax, QWORD PTR e$[rbp-105]
  001ee	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001f3	48 8d 45 0f	 lea	 rax, QWORD PTR starts$[rbp-105]
  001f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fc	e8 00 00 00 00	 call	 unicode_decode_call_errorhandler
  00201	85 c0		 test	 eax, eax
  00203	0f 85 9f 00 00
	00		 jne	 $LN60@PyUnicode_@77

; 6686 :                 goto onError;
; 6687 :             kind = PyUnicode_KIND(unicode);

  00209	48 8b 7d 7f	 mov	 rdi, QWORD PTR unicode$[rbp-105]

; 6688 :             data = PyUnicode_DATA(unicode);

  0020d	48 8b 5d 67	 mov	 rbx, QWORD PTR s$[rbp-105]
  00211	48 8b 55 6f	 mov	 rdx, QWORD PTR outpos$[rbp-105]
  00215	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00218	8b c8		 mov	 ecx, eax
  0021a	c1 e9 02	 shr	 ecx, 2
  0021d	83 e1 07	 and	 ecx, 7
  00220	a8 20		 test	 al, 32			; 00000020H
  00222	74 13		 je	 SHORT $LN56@PyUnicode_@77
  00224	a8 40		 test	 al, 64			; 00000040H
  00226	74 06		 je	 SHORT $LN54@PyUnicode_@77
  00228	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  0022c	eb 10		 jmp	 SHORT $LN57@PyUnicode_@77
$LN54@PyUnicode_@77:
  0022e	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  00235	eb 07		 jmp	 SHORT $LN57@PyUnicode_@77
$LN56@PyUnicode_@77:
  00237	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
$LN57@PyUnicode_@77:

; 6672 :     while (s < e) {

  0023e	48 3b 5d f7	 cmp	 rbx, QWORD PTR e$[rbp-105]
  00242	0f 82 e8 fe ff
	ff		 jb	 $LL34@PyUnicode_@77
  00248	48 8b 75 ff	 mov	 rsi, QWORD PTR errorHandler$[rbp-105]
  0024c	4c 8b 65 07	 mov	 r12, QWORD PTR exc$[rbp-105]
$LN33@PyUnicode_@77:

; 6689 :         }
; 6690 :     }
; 6691 :     if (unicode_resize(&unicode, outpos) < 0)

  00250	48 8d 4d 7f	 lea	 rcx, QWORD PTR unicode$[rbp-105]
  00254	e8 00 00 00 00	 call	 unicode_resize
  00259	85 c0		 test	 eax, eax
  0025b	79 55		 jns	 SHORT $LN20@PyUnicode_@77
$onError$132666:

; 6697 : 
; 6698 :   onError:
; 6699 :     Py_XDECREF(unicode);

  0025d	48 8b 4d 7f	 mov	 rcx, QWORD PTR unicode$[rbp-105]
  00261	48 85 c9	 test	 rcx, rcx
  00264	74 05		 je	 SHORT $LN11@PyUnicode_@77
  00266	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@PyUnicode_@77:

; 6700 :     Py_XDECREF(errorHandler);

  0026b	48 85 f6	 test	 rsi, rsi
  0026e	74 08		 je	 SHORT $LN7@PyUnicode_@77
  00270	48 8b ce	 mov	 rcx, rsi
  00273	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@PyUnicode_@77:

; 6701 :     Py_XDECREF(exc);

  00278	4d 85 e4	 test	 r12, r12
  0027b	74 08		 je	 SHORT $LN3@PyUnicode_@77
  0027d	49 8b cc	 mov	 rcx, r12
  00280	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyUnicode_@77:

; 6702 :     return NULL;

  00285	33 c0		 xor	 eax, eax
$LN62@PyUnicode_@77:
  00287	48 8b bc 24 e0
	00 00 00	 mov	 rdi, QWORD PTR [rsp+224]
  0028f	4c 8b ac 24 90
	00 00 00	 mov	 r13, QWORD PTR [rsp+144]
$LN48@PyUnicode_@77:

; 6703 : }

  00297	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0029e	41 5f		 pop	 r15
  002a0	41 5e		 pop	 r14
  002a2	41 5c		 pop	 r12
  002a4	5e		 pop	 rsi
  002a5	5b		 pop	 rbx
  002a6	5d		 pop	 rbp
  002a7	c3		 ret	 0
$LN60@PyUnicode_@77:

; 6689 :         }
; 6690 :     }
; 6691 :     if (unicode_resize(&unicode, outpos) < 0)

  002a8	48 8b 75 ff	 mov	 rsi, QWORD PTR errorHandler$[rbp-105]
  002ac	4c 8b 65 07	 mov	 r12, QWORD PTR exc$[rbp-105]
  002b0	eb ab		 jmp	 SHORT $onError$132666
$LN20@PyUnicode_@77:

; 6692 :         goto onError;
; 6693 :     Py_XDECREF(errorHandler);

  002b2	48 85 f6	 test	 rsi, rsi
  002b5	74 08		 je	 SHORT $LN19@PyUnicode_@77
  002b7	48 8b ce	 mov	 rcx, rsi
  002ba	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@PyUnicode_@77:

; 6694 :     Py_XDECREF(exc);

  002bf	4d 85 e4	 test	 r12, r12
  002c2	74 08		 je	 SHORT $LN15@PyUnicode_@77
  002c4	49 8b cc	 mov	 rcx, r12
  002c7	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@PyUnicode_@77:

; 6695 :     assert(_PyUnicode_CheckConsistency(unicode, 1));
; 6696 :     return unicode;

  002cc	48 8b 45 7f	 mov	 rax, QWORD PTR unicode$[rbp-105]
  002d0	eb b5		 jmp	 SHORT $LN62@PyUnicode_@77
PyUnicode_DecodeASCII ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_EncodeASCII
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_EncodeASCII DD imagerel $LN4
	DD	imagerel $LN4+79
	DD	imagerel $unwind$PyUnicode_EncodeASCII
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_EncodeASCII DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_EncodeASCII
_TEXT	SEGMENT
p$ = 48
size$ = 56
errors$ = 64
PyUnicode_EncodeASCII PROC				; COMDAT

; 6710 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b d8	 mov	 rbx, r8

; 6711 :     PyObject *result;
; 6712 :     PyObject *unicode = PyUnicode_FromUnicode(p, size);

  0000d	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  00012	48 8b f8	 mov	 rdi, rax

; 6713 :     if (unicode == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0b		 jne	 SHORT $LN1@PyUnicode_@78

; 6718 : }

  0001a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
$LN1@PyUnicode_@78:

; 6714 :         return NULL;
; 6715 :     result = unicode_encode_ucs1(unicode, errors, 128);

  00025	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  0002b	48 8b d3	 mov	 rdx, rbx
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 unicode_encode_ucs1

; 6716 :     Py_DECREF(unicode);

  00036	48 8b cf	 mov	 rcx, rdi
  00039	48 8b d8	 mov	 rbx, rax
  0003c	e8 00 00 00 00	 call	 _Py_DecRef

; 6717 :     return result;

  00041	48 8b c3	 mov	 rax, rbx

; 6718 : }

  00044	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
PyUnicode_EncodeASCII ENDP
_TEXT	ENDS
EXTRN	__imp_MultiByteToWideChar:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$decode_code_page_strict DD imagerel decode_code_page_strict
	DD	imagerel decode_code_page_strict+327
	DD	imagerel $unwind$decode_code_page_strict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$decode_code_page_strict DD 0c1e01H
	DD	0d741eH
	DD	0c641eH
	DD	0b541eH
	DD	0a341eH
	DD	0e01a521eH
	DD	0c016d018H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT decode_code_page_strict
_TEXT	SEGMENT
code_page$ = 80
v$ = 88
in$ = 96
insize$ = 104
decode_code_page_strict PROC				; COMDAT

; 6817 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001e	41 8b e9	 mov	 ebp, r9d
  00021	4d 8b e8	 mov	 r13, r8
  00024	48 8b fa	 mov	 rdi, rdx
  00027	44 8b e1	 mov	 r12d, ecx

; 6818 :     const DWORD flags = decode_code_page_flags(code_page);

  0002a	e8 00 00 00 00	 call	 decode_code_page_flags
  0002f	44 8b f0	 mov	 r14d, eax

; 6819 :     wchar_t *out;
; 6820 :     DWORD outsize;
; 6821 : 
; 6822 :     /* First get the size of the result */
; 6823 :     assert(insize > 0);
; 6824 :     outsize = MultiByteToWideChar(code_page, flags, in, insize, NULL, 0);

  00032	33 c0		 xor	 eax, eax
  00034	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00038	41 8b d6	 mov	 edx, r14d
  0003b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MultiByteToWideChar
  00046	8b f0		 mov	 esi, eax

; 6825 :     if (outsize <= 0)

  00048	85 c0		 test	 eax, eax
  0004a	0f 84 ba 00 00
	00		 je	 $error$132857

; 6826 :         goto error;
; 6827 : 
; 6828 :     if (*v == NULL) {

  00050	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00053	48 85 c9	 test	 rcx, rcx
  00056	75 29		 jne	 SHORT $LN6@decode_cod

; 6829 :         /* Create unicode object */
; 6830 :         /* FIXME: don't use _PyUnicode_New(), but allocate a wchar_t* buffer */
; 6831 :         *v = (PyObject*)_PyUnicode_New(outsize);

  00058	8b ce		 mov	 ecx, esi
  0005a	e8 00 00 00 00	 call	 _PyUnicode_New
  0005f	48 89 07	 mov	 QWORD PTR [rdi], rax

; 6832 :         if (*v == NULL)

  00062	48 85 c0	 test	 rax, rax

; 6833 :             return -1;

  00065	0f 84 ba 00 00
	00		 je	 $LN20@decode_cod

; 6834 :         out = PyUnicode_AS_UNICODE(*v);

  0006b	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  0006f	48 85 c9	 test	 rcx, rcx
  00072	75 73		 jne	 SHORT $LN4@decode_cod
  00074	48 8b c8	 mov	 rcx, rax
  00077	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  0007c	48 8b c8	 mov	 rcx, rax

; 6835 :     }
; 6836 :     else {

  0007f	eb 66		 jmp	 SHORT $LN4@decode_cod
$LN6@decode_cod:

; 6837 :         /* Extend unicode object */
; 6838 :         Py_ssize_t n = PyUnicode_GET_SIZE(*v);

  00081	48 83 79 78 00	 cmp	 QWORD PTR [rcx+120], 0
  00086	74 1a		 je	 SHORT $LN16@decode_cod
  00088	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  0008b	a8 40		 test	 al, 64			; 00000040H
  0008d	74 0a		 je	 SHORT $LN12@decode_cod
  0008f	a8 20		 test	 al, 32			; 00000020H
  00091	74 06		 je	 SHORT $LN12@decode_cod
  00093	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  00097	eb 29		 jmp	 SHORT $LN15@decode_cod
$LN12@decode_cod:
  00099	48 8b 99 90 00
	00 00		 mov	 rbx, QWORD PTR [rcx+144]
  000a0	eb 20		 jmp	 SHORT $LN15@decode_cod
$LN16@decode_cod:
  000a2	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  000a7	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  000aa	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  000ad	a8 40		 test	 al, 64			; 00000040H
  000af	74 0a		 je	 SHORT $LN14@decode_cod
  000b1	a8 20		 test	 al, 32			; 00000020H
  000b3	74 06		 je	 SHORT $LN14@decode_cod
  000b5	48 8b 5b 60	 mov	 rbx, QWORD PTR [rbx+96]
  000b9	eb 07		 jmp	 SHORT $LN15@decode_cod
$LN14@decode_cod:
  000bb	48 8b 9b 90 00
	00 00		 mov	 rbx, QWORD PTR [rbx+144]
$LN15@decode_cod:

; 6839 :         if (unicode_resize(v, n + outsize) < 0)

  000c2	48 8d 14 33	 lea	 rdx, QWORD PTR [rbx+rsi]
  000c6	48 8b cf	 mov	 rcx, rdi
  000c9	e8 00 00 00 00	 call	 unicode_resize
  000ce	85 c0		 test	 eax, eax

; 6840 :             return -1;

  000d0	78 53		 js	 SHORT $LN20@decode_cod

; 6841 :         out = PyUnicode_AS_UNICODE(*v) + n;

  000d2	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  000d5	48 8b 41 78	 mov	 rax, QWORD PTR [rcx+120]
  000d9	48 85 c0	 test	 rax, rax
  000dc	75 05		 jne	 SHORT $LN19@decode_cod
  000de	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
$LN19@decode_cod:
  000e3	48 8d 0c 58	 lea	 rcx, QWORD PTR [rax+rbx*2]
$LN4@decode_cod:

; 6842 :     }
; 6843 : 
; 6844 :     /* Do the conversion */
; 6845 :     outsize = MultiByteToWideChar(code_page, flags, in, insize, out, outsize);

  000e7	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  000eb	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000f0	44 8b cd	 mov	 r9d, ebp
  000f3	41 8b cc	 mov	 ecx, r12d
  000f6	4d 8b c5	 mov	 r8, r13
  000f9	41 8b d6	 mov	 edx, r14d
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MultiByteToWideChar

; 6846 :     if (outsize <= 0)

  00102	85 c0		 test	 eax, eax
  00104	74 04		 je	 SHORT $error$132857

; 6847 :         goto error;
; 6848 :     return insize;

  00106	8b c5		 mov	 eax, ebp
  00108	eb 1e		 jmp	 SHORT $LN8@decode_cod
$error$132857:

; 6849 : 
; 6850 : error:
; 6851 :     if (GetLastError() == ERROR_NO_UNICODE_TRANSLATION)

  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00110	3d 59 04 00 00	 cmp	 eax, 1113		; 00000459H
  00115	75 07		 jne	 SHORT $LN1@decode_cod

; 6852 :         return -2;

  00117	b8 fe ff ff ff	 mov	 eax, -2
  0011c	eb 0a		 jmp	 SHORT $LN8@decode_cod
$LN1@decode_cod:

; 6853 :     PyErr_SetFromWindowsErr(0);

  0011e	33 c9		 xor	 ecx, ecx
  00120	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
$LN20@decode_cod:

; 6854 :     return -1;

  00125	83 c8 ff	 or	 eax, -1
$LN8@decode_cod:

; 6855 : }

  00128	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0012d	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00132	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00137	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  0013c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00140	41 5e		 pop	 r14
  00142	41 5d		 pop	 r13
  00144	41 5c		 pop	 r12
  00146	c3		 ret	 0
decode_code_page_strict ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@DKIGLEHL@decode_code_page_errors?$AA@	; `string'
PUBLIC	??_C@_0EF@CGLJCOFL@No?5mapping?5for?5the?5Unicode?5chara@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$decode_code_page_errors DD imagerel decode_code_page_errors
	DD	imagerel decode_code_page_errors+124
	DD	imagerel $unwind$decode_code_page_errors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$decode_code_page_errors DD imagerel decode_code_page_errors+124
	DD	imagerel decode_code_page_errors+1264
	DD	imagerel $chain$0$decode_code_page_errors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$decode_code_page_errors DD imagerel decode_code_page_errors+1264
	DD	imagerel decode_code_page_errors+1283
	DD	imagerel $chain$1$decode_code_page_errors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$decode_code_page_errors DD 021H
	DD	imagerel decode_code_page_errors
	DD	imagerel decode_code_page_errors+124
	DD	imagerel $unwind$decode_code_page_errors
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$decode_code_page_errors DD 020821H
	DD	0196408H
	DD	imagerel decode_code_page_errors
	DD	imagerel decode_code_page_errors+124
	DD	imagerel $unwind$decode_code_page_errors
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$decode_code_page_errors DD 092a01H
	DD	01a012aH
	DD	0e01cf01eH
	DD	0c018d01aH
	DD	030157016H
	DD	05014H
xdata	ENDS
;	COMDAT ??_C@_0BI@DKIGLEHL@decode_code_page_errors?$AA@
CONST	SEGMENT
??_C@_0BI@DKIGLEHL@decode_code_page_errors?$AA@ DB 'decode_code_page_erro'
	DB	'rs', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@CGLJCOFL@No?5mapping?5for?5the?5Unicode?5chara@
CONST	SEGMENT
??_C@_0EF@CGLJCOFL@No?5mapping?5for?5the?5Unicode?5chara@ DB 'No mapping '
	DB	'for the Unicode character exists in the target code page.', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT decode_code_page_errors
_TEXT	SEGMENT
exc$ = 96
flags$1$ = 104
outpos$132987 = 104
errorHandler$ = 112
buffer$ = 120
startout$1$ = 128
startin$ = 136
endin$ = 144
encoding_obj$ = 152
endinpos$132986 = 160
startinpos$132985 = 168
encoding$1$ = 176
code_page$ = 272
v$ = 280
in$ = 288
size$ = 296
errors$ = 304
decode_code_page_errors PROC				; COMDAT

; 6869 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	55		 push	 rbp
  00014	53		 push	 rbx
  00015	57		 push	 rdi
  00016	41 54		 push	 r12
  00018	41 55		 push	 r13
  0001a	41 56		 push	 r14
  0001c	41 57		 push	 r15
  0001e	48 8d 6c 24 e1	 lea	 rbp, QWORD PTR [rsp-31]
  00023	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  0002a	49 63 c1	 movsxd	 rax, r9d
  0002d	49 8b d8	 mov	 rbx, r8

; 6870 :     const char *startin = in;
; 6871 :     const char *endin = in + size;

  00030	4e 8d 3c 00	 lea	 r15, QWORD PTR [rax+r8]
  00034	48 89 5d d7	 mov	 QWORD PTR startin$[rbp-177], rbx
  00038	4c 8b f0	 mov	 r14, rax
  0003b	4c 89 7d df	 mov	 QWORD PTR endin$[rbp-177], r15

; 6872 :     const DWORD flags = decode_code_page_flags(code_page);

  0003f	e8 00 00 00 00	 call	 decode_code_page_flags

; 6873 :     /* Ideally, we should get reason from FormatMessage. This is the Windows
; 6874 :        2000 English version of the message. */
; 6875 :     const char *reason = "No mapping for the Unicode character exists "
; 6876 :                          "in the target code page.";
; 6877 :     /* each step cannot decode more than 1 character, but a character can be
; 6878 :        represented as a surrogate pair */
; 6879 :     wchar_t buffer[2], *startout, *out;
; 6880 :     int insize, outsize;
; 6881 :     PyObject *errorHandler = NULL;

  00044	33 ff		 xor	 edi, edi

; 6882 :     PyObject *exc = NULL;
; 6883 :     PyObject *encoding_obj = NULL;
; 6884 :     char *encoding;
; 6885 :     DWORD err;
; 6886 :     int ret = -1;
; 6887 : 
; 6888 :     assert(size > 0);
; 6889 : 
; 6890 :     encoding = code_page_name(code_page, &encoding_obj);

  00046	48 8d 55 e7	 lea	 rdx, QWORD PTR encoding_obj$[rbp-177]
  0004a	44 8b ef	 mov	 r13d, edi
  0004d	48 89 7d bf	 mov	 QWORD PTR errorHandler$[rbp-177], rdi
  00051	89 45 b7	 mov	 DWORD PTR flags$1$[rbp-177], eax
  00054	44 8b e7	 mov	 r12d, edi
  00057	48 89 7d af	 mov	 QWORD PTR exc$[rbp-177], rdi
  0005b	48 89 7d e7	 mov	 QWORD PTR encoding_obj$[rbp-177], rdi
  0005f	e8 00 00 00 00	 call	 code_page_name
  00064	48 8b d0	 mov	 rdx, rax
  00067	48 89 45 ff	 mov	 QWORD PTR encoding$1$[rbp-177], rax

; 6891 :     if (encoding == NULL)

  0006b	48 85 c0	 test	 rax, rax
  0006e	75 08		 jne	 SHORT $LN38@decode_cod@2

; 6892 :         return -1;

  00070	83 c8 ff	 or	 eax, -1
  00073	e9 78 04 00 00	 jmp	 $LN39@decode_cod@2
$LN38@decode_cod@2:

; 6893 : 
; 6894 :     if (errors == NULL || strcmp(errors, "strict") == 0) {

  00078	48 8b 45 7f	 mov	 rax, QWORD PTR errors$[rbp-177]
  0007c	48 89 b4 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], rsi
  00084	48 85 c0	 test	 rax, rax
  00087	0f 84 a8 02 00
	00		 je	 $LN36@decode_cod@2
  0008d	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  00094	48 8b f0	 mov	 rsi, rax
  00097	b9 07 00 00 00	 mov	 ecx, 7
  0009c	f3 a6		 repe cmpsb
  0009e	0f 84 8f 02 00
	00		 je	 $LN98@decode_cod@2

; 6901 :         }
; 6902 :         goto error;
; 6903 :     }
; 6904 : 
; 6905 :     if (*v == NULL) {

  000a4	48 8b 7d 67	 mov	 rdi, QWORD PTR v$[rbp-177]
  000a8	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  000ab	48 85 c9	 test	 rcx, rcx
  000ae	75 57		 jne	 SHORT $LN30@decode_cod@2

; 6906 :         /* Create unicode object */
; 6907 :         if (size > PY_SSIZE_T_MAX / (Py_ssize_t)Py_ARRAY_LENGTH(buffer)) {

  000b0	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  000ba	4c 3b f0	 cmp	 r14, rax
  000bd	7e 0a		 jle	 SHORT $LN29@decode_cod@2

; 6908 :             PyErr_NoMemory();

  000bf	e8 00 00 00 00	 call	 PyErr_NoMemory

; 6909 :             goto error;

  000c4	e9 d5 02 00 00	 jmp	 $LN97@decode_cod@2
$LN29@decode_cod@2:

; 6910 :         }
; 6911 :         /* FIXME: don't use _PyUnicode_New(), but allocate a wchar_t* buffer */
; 6912 :         *v = (PyObject*)_PyUnicode_New(size * Py_ARRAY_LENGTH(buffer));

  000c9	4b 8d 0c 36	 lea	 rcx, QWORD PTR [r14+r14]
  000cd	e8 00 00 00 00	 call	 _PyUnicode_New
  000d2	4c 8b 75 67	 mov	 r14, QWORD PTR v$[rbp-177]
  000d6	49 89 06	 mov	 QWORD PTR [r14], rax

; 6913 :         if (*v == NULL)

  000d9	48 85 c0	 test	 rax, rax
  000dc	0f 84 bc 02 00
	00		 je	 $LN97@decode_cod@2

; 6914 :             goto error;
; 6915 :         startout = PyUnicode_AS_UNICODE(*v);

  000e2	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  000e6	48 89 4d cf	 mov	 QWORD PTR startout$1$[rbp-177], rcx
  000ea	48 85 c9	 test	 rcx, rcx
  000ed	0f 85 a9 00 00
	00		 jne	 $LN27@decode_cod@2
  000f3	48 8b c8	 mov	 rcx, rax
  000f6	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  000fb	48 8b c8	 mov	 rcx, rax
  000fe	48 89 45 cf	 mov	 QWORD PTR startout$1$[rbp-177], rax

; 6916 :     }
; 6917 :     else {

  00102	e9 95 00 00 00	 jmp	 $LN27@decode_cod@2
$LN30@decode_cod@2:

; 6918 :         /* Extend unicode object */
; 6919 :         Py_ssize_t n = PyUnicode_GET_SIZE(*v);

  00107	4c 39 61 78	 cmp	 QWORD PTR [rcx+120], r12
  0010b	74 1a		 je	 SHORT $LN47@decode_cod@2
  0010d	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00110	a8 40		 test	 al, 64			; 00000040H
  00112	74 0a		 je	 SHORT $LN43@decode_cod@2
  00114	a8 20		 test	 al, 32			; 00000020H
  00116	74 06		 je	 SHORT $LN43@decode_cod@2
  00118	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]
  0011c	eb 29		 jmp	 SHORT $LN46@decode_cod@2
$LN43@decode_cod@2:
  0011e	48 8b b9 90 00
	00 00		 mov	 rdi, QWORD PTR [rcx+144]
  00125	eb 20		 jmp	 SHORT $LN46@decode_cod@2
$LN47@decode_cod@2:
  00127	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  0012c	48 8b 3f	 mov	 rdi, QWORD PTR [rdi]
  0012f	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00132	a8 40		 test	 al, 64			; 00000040H
  00134	74 0a		 je	 SHORT $LN45@decode_cod@2
  00136	a8 20		 test	 al, 32			; 00000020H
  00138	74 06		 je	 SHORT $LN45@decode_cod@2
  0013a	48 8b 7f 60	 mov	 rdi, QWORD PTR [rdi+96]
  0013e	eb 07		 jmp	 SHORT $LN46@decode_cod@2
$LN45@decode_cod@2:
  00140	48 8b bf 90 00
	00 00		 mov	 rdi, QWORD PTR [rdi+144]
$LN46@decode_cod@2:

; 6920 :         if (size > (PY_SSIZE_T_MAX - n) / (Py_ssize_t)Py_ARRAY_LENGTH(buffer)) {

  00147	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00151	48 2b c7	 sub	 rax, rdi
  00154	48 99		 cdq
  00156	48 2b c2	 sub	 rax, rdx
  00159	48 d1 f8	 sar	 rax, 1
  0015c	4c 3b f0	 cmp	 r14, rax
  0015f	7e 0a		 jle	 SHORT $LN26@decode_cod@2

; 6921 :             PyErr_NoMemory();

  00161	e8 00 00 00 00	 call	 PyErr_NoMemory

; 6922 :             goto error;

  00166	e9 33 02 00 00	 jmp	 $LN97@decode_cod@2
$LN26@decode_cod@2:

; 6923 :         }
; 6924 :         if (unicode_resize(v, n + size * Py_ARRAY_LENGTH(buffer)) < 0)

  0016b	4a 8d 14 77	 lea	 rdx, QWORD PTR [rdi+r14*2]
  0016f	4c 8b 75 67	 mov	 r14, QWORD PTR v$[rbp-177]
  00173	49 8b ce	 mov	 rcx, r14
  00176	e8 00 00 00 00	 call	 unicode_resize
  0017b	85 c0		 test	 eax, eax
  0017d	0f 88 1b 02 00
	00		 js	 $LN97@decode_cod@2

; 6925 :             goto error;
; 6926 :         startout = PyUnicode_AS_UNICODE(*v) + n;

  00183	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  00186	48 8b 41 78	 mov	 rax, QWORD PTR [rcx+120]
  0018a	48 85 c0	 test	 rax, rax
  0018d	75 05		 jne	 SHORT $LN50@decode_cod@2
  0018f	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
$LN50@decode_cod@2:
  00194	48 8d 0c 78	 lea	 rcx, QWORD PTR [rax+rdi*2]
  00198	48 89 4d cf	 mov	 QWORD PTR startout$1$[rbp-177], rcx
$LN27@decode_cod@2:

; 6927 :     }
; 6928 : 
; 6929 :     /* Decode the byte string character per character */
; 6930 :     out = startout;

  0019c	48 8b f1	 mov	 rsi, rcx

; 6931 :     while (in < endin)

  0019f	49 3b df	 cmp	 rbx, r15
  001a2	0f 83 57 01 00
	00		 jae	 $LN23@decode_cod@2
  001a8	44 8b 65 5f	 mov	 r12d, DWORD PTR code_page$[rbp-177]
  001ac	44 8b 6d b7	 mov	 r13d, DWORD PTR flags$1$[rbp-177]
$LL24@decode_cod@2:

; 6932 :     {
; 6933 :         /* Decode a character */
; 6934 :         insize = 1;

  001b0	bf 01 00 00 00	 mov	 edi, 1
  001b5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL22@decode_cod@2:

; 6935 :         do
; 6936 :         {
; 6937 :             outsize = MultiByteToWideChar(code_page, flags,
; 6938 :                                           in, insize,
; 6939 :                                           buffer, Py_ARRAY_LENGTH(buffer));

  001c0	48 8d 45 c7	 lea	 rax, QWORD PTR buffer$[rbp-177]
  001c4	44 8b cf	 mov	 r9d, edi
  001c7	4c 8b c3	 mov	 r8, rbx
  001ca	41 8b d5	 mov	 edx, r13d
  001cd	41 8b cc	 mov	 ecx, r12d
  001d0	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR [rsp+40], 2
  001d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MultiByteToWideChar
  001e3	48 63 d0	 movsxd	 rdx, eax

; 6940 :             if (outsize > 0)

  001e6	85 c0		 test	 eax, eax
  001e8	0f 8f da 00 00
	00		 jg	 $LN16@decode_cod@2

; 6941 :                 break;
; 6942 :             err = GetLastError();

  001ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 6943 :             if (err != ERROR_NO_UNICODE_TRANSLATION
; 6944 :                 && err != ERROR_INSUFFICIENT_BUFFER)

  001f4	3d 59 04 00 00	 cmp	 eax, 1113		; 00000459H
  001f9	74 09		 je	 SHORT $LN18@decode_cod@2
  001fb	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  001fe	0f 85 1e 01 00
	00		 jne	 $LN91@decode_cod@2
$LN18@decode_cod@2:

; 6948 :             }
; 6949 :             insize++;

  00204	ff c7		 inc	 edi

; 6950 :         }
; 6951 :         /* 4=maximum length of a UTF-8 sequence */
; 6952 :         while (insize <= 4 && (in + insize) <= endin);

  00206	83 ff 04	 cmp	 edi, 4
  00209	7f 0b		 jg	 SHORT $LN17@decode_cod@2
  0020b	48 63 c7	 movsxd	 rax, edi
  0020e	48 03 c3	 add	 rax, rbx
  00211	49 3b c7	 cmp	 rax, r15
  00214	76 aa		 jbe	 SHORT $LL22@decode_cod@2
$LN17@decode_cod@2:

; 6953 : 
; 6954 :         if (outsize <= 0) {
; 6955 :             Py_ssize_t startinpos, endinpos, outpos;
; 6956 : 
; 6957 :             startinpos = in - startin;

  00216	48 2b 5d d7	 sub	 rbx, QWORD PTR startin$[rbp-177]

; 6958 :             endinpos = startinpos + 1;
; 6959 :             outpos = out - PyUnicode_AS_UNICODE(*v);

  0021a	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  0021d	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
  00221	48 89 5d f7	 mov	 QWORD PTR startinpos$132985[rbp-177], rbx
  00225	48 89 45 ef	 mov	 QWORD PTR endinpos$132986[rbp-177], rax
  00229	48 8b 41 78	 mov	 rax, QWORD PTR [rcx+120]
  0022d	48 85 c0	 test	 rax, rax
  00230	75 05		 jne	 SHORT $LN52@decode_cod@2
  00232	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
$LN52@decode_cod@2:

; 6960 :             if (unicode_decode_call_errorhandler(
; 6961 :                     errors, &errorHandler,
; 6962 :                     encoding, reason,
; 6963 :                     &startin, &endin, &startinpos, &endinpos, &exc, &in,
; 6964 :                     v, &outpos))

  00237	4c 8b 45 ff	 mov	 r8, QWORD PTR encoding$1$[rbp-177]
  0023b	48 8b 4d 7f	 mov	 rcx, QWORD PTR errors$[rbp-177]
  0023f	48 2b f0	 sub	 rsi, rax
  00242	48 8d 45 b7	 lea	 rax, QWORD PTR outpos$132987[rbp-177]
  00246	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0EF@CGLJCOFL@No?5mapping?5for?5the?5Unicode?5chara@
  0024d	48 8d 55 bf	 lea	 rdx, QWORD PTR errorHandler$[rbp-177]
  00251	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00256	4c 89 74 24 50	 mov	 QWORD PTR [rsp+80], r14
  0025b	48 8d 45 6f	 lea	 rax, QWORD PTR in$[rbp-177]
  0025f	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00264	48 8d 45 af	 lea	 rax, QWORD PTR exc$[rbp-177]
  00268	48 d1 fe	 sar	 rsi, 1
  0026b	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00270	48 8d 45 ef	 lea	 rax, QWORD PTR endinpos$132986[rbp-177]
  00274	48 89 75 b7	 mov	 QWORD PTR outpos$132987[rbp-177], rsi
  00278	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0027d	48 8d 45 f7	 lea	 rax, QWORD PTR startinpos$132985[rbp-177]
  00281	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00286	48 8d 45 df	 lea	 rax, QWORD PTR endin$[rbp-177]
  0028a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0028f	48 8d 45 d7	 lea	 rax, QWORD PTR startin$[rbp-177]
  00293	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00298	e8 00 00 00 00	 call	 unicode_decode_call_errorhandler
  0029d	85 c0		 test	 eax, eax
  0029f	0f 85 84 00 00
	00		 jne	 $LN93@decode_cod@2

; 6965 :             {
; 6966 :                 goto error;
; 6967 :             }
; 6968 :             out = PyUnicode_AS_UNICODE(*v) + outpos;

  002a5	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  002a8	48 8b 41 78	 mov	 rax, QWORD PTR [rcx+120]
  002ac	48 85 c0	 test	 rax, rax
  002af	75 05		 jne	 SHORT $LN54@decode_cod@2
  002b1	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
$LN54@decode_cod@2:
  002b6	48 8b 4d b7	 mov	 rcx, QWORD PTR outpos$132987[rbp-177]

; 6969 :         }
; 6970 :         else {

  002ba	48 8b 5d 6f	 mov	 rbx, QWORD PTR in$[rbp-177]
  002be	4c 8b 7d df	 mov	 r15, QWORD PTR endin$[rbp-177]
  002c2	48 8d 34 48	 lea	 rsi, QWORD PTR [rax+rcx*2]
  002c6	eb 22		 jmp	 SHORT $LN14@decode_cod@2
$LN16@decode_cod@2:

; 6971 :             in += insize;

  002c8	48 63 c7	 movsxd	 rax, edi

; 6972 :             memcpy(out, buffer, outsize * sizeof(wchar_t));

  002cb	48 8b fa	 mov	 rdi, rdx
  002ce	48 8d 55 c7	 lea	 rdx, QWORD PTR buffer$[rbp-177]
  002d2	48 03 d8	 add	 rbx, rax
  002d5	48 03 ff	 add	 rdi, rdi
  002d8	48 8b ce	 mov	 rcx, rsi
  002db	4c 8b c7	 mov	 r8, rdi
  002de	48 89 5d 6f	 mov	 QWORD PTR in$[rbp-177], rbx
  002e2	e8 00 00 00 00	 call	 memcpy

; 6973 :             out += outsize;

  002e7	48 03 f7	 add	 rsi, rdi
$LN14@decode_cod@2:

; 6931 :     while (in < endin)

  002ea	49 3b df	 cmp	 rbx, r15
  002ed	0f 82 bd fe ff
	ff		 jb	 $LL24@decode_cod@2

; 6960 :             if (unicode_decode_call_errorhandler(
; 6961 :                     errors, &errorHandler,
; 6962 :                     encoding, reason,
; 6963 :                     &startin, &endin, &startinpos, &endinpos, &exc, &in,
; 6964 :                     v, &outpos))

  002f3	4c 8b 6d bf	 mov	 r13, QWORD PTR errorHandler$[rbp-177]
  002f7	4c 8b 65 af	 mov	 r12, QWORD PTR exc$[rbp-177]
  002fb	48 8b 4d cf	 mov	 rcx, QWORD PTR startout$1$[rbp-177]
$LN23@decode_cod@2:

; 6974 :         }
; 6975 :     }
; 6976 : 
; 6977 :     /* write a NUL character at the end */
; 6978 :     *out = 0;

  002ff	33 c0		 xor	 eax, eax
  00301	66 89 06	 mov	 WORD PTR [rsi], ax

; 6979 : 
; 6980 :     /* Extend unicode object */
; 6981 :     outsize = out - startout;

  00304	48 2b f1	 sub	 rsi, rcx

; 6982 :     assert(outsize <= PyUnicode_WSTR_LENGTH(*v));
; 6983 :     if (unicode_resize(v, outsize) < 0)

  00307	49 8b ce	 mov	 rcx, r14
  0030a	48 d1 fe	 sar	 rsi, 1
  0030d	48 63 d6	 movsxd	 rdx, esi
  00310	e8 00 00 00 00	 call	 unicode_resize
  00315	85 c0		 test	 eax, eax
  00317	0f 88 81 00 00
	00		 js	 $LN97@decode_cod@2

; 6984 :         goto error;
; 6985 :     ret = size;

  0031d	8b 75 77	 mov	 esi, DWORD PTR size$[rbp-177]
  00320	eb 7f		 jmp	 SHORT $error$132937
$LN91@decode_cod@2:

; 6945 :             {
; 6946 :                 PyErr_SetFromWindowsErr(0);

  00322	33 c9		 xor	 ecx, ecx
  00324	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
$LN93@decode_cod@2:

; 6947 :                 goto error;

  00329	4c 8b 6d bf	 mov	 r13, QWORD PTR errorHandler$[rbp-177]
  0032d	4c 8b 65 af	 mov	 r12, QWORD PTR exc$[rbp-177]
  00331	eb 6b		 jmp	 SHORT $LN97@decode_cod@2
$LN98@decode_cod@2:

; 6869 : {

  00333	33 ff		 xor	 edi, edi
$LN36@decode_cod@2:

; 6895 :         /* The last error was ERROR_NO_UNICODE_TRANSLATION, then we raise a
; 6896 :            UnicodeDecodeError. */
; 6897 :         make_decode_exception(&exc, encoding, in, size, 0, 0, reason);

  00335	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0EF@CGLJCOFL@No?5mapping?5for?5the?5Unicode?5chara@
  0033c	48 8d 4d af	 lea	 rcx, QWORD PTR exc$[rbp-177]
  00340	4d 8b ce	 mov	 r9, r14
  00343	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00348	4c 8b c3	 mov	 r8, rbx
  0034b	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  00350	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00355	e8 00 00 00 00	 call	 make_decode_exception

; 6898 :         if (exc != NULL) {

  0035a	4c 8b 65 af	 mov	 r12, QWORD PTR exc$[rbp-177]
  0035e	4d 85 e4	 test	 r12, r12
  00361	74 3b		 je	 SHORT $LN97@decode_cod@2

; 6899 :             PyCodec_StrictErrors(exc);

  00363	49 8b cc	 mov	 rcx, r12
  00366	e8 00 00 00 00	 call	 PyCodec_StrictErrors

; 6900 :             Py_CLEAR(exc);

  0036b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00372	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DKIGLEHL@decode_code_page_errors?$AA@
  00379	4d 8b cc	 mov	 r9, r12
  0037c	41 b8 f4 1a 00
	00		 mov	 r8d, 6900		; 00001af4H
  00382	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0038a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0038f	85 c0		 test	 eax, eax
  00391	75 0b		 jne	 SHORT $LN97@decode_cod@2
  00393	49 8b cc	 mov	 rcx, r12
  00396	4c 8b e7	 mov	 r12, rdi
  00399	e8 00 00 00 00	 call	 _Py_DecRef
$LN97@decode_cod@2:

; 6925 :             goto error;
; 6926 :         startout = PyUnicode_AS_UNICODE(*v) + n;

  0039e	83 ce ff	 or	 esi, -1
$error$132937:

; 6986 : 
; 6987 : error:
; 6988 :     Py_XDECREF(encoding_obj);

  003a1	48 8b 7d e7	 mov	 rdi, QWORD PTR encoding_obj$[rbp-177]
  003a5	48 85 ff	 test	 rdi, rdi
  003a8	74 65		 je	 SHORT $LN11@decode_cod@2
  003aa	e8 00 00 00 00	 call	 _Py_PXCTX
  003af	85 c0		 test	 eax, eax
  003b1	75 5c		 jne	 SHORT $LN11@decode_cod@2
  003b3	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  003b7	a8 20		 test	 al, 32			; 00000020H
  003b9	75 4c		 jne	 SHORT $LN59@decode_cod@2
  003bb	84 c0		 test	 al, al
  003bd	78 48		 js	 SHORT $LN59@decode_cod@2
  003bf	a8 02		 test	 al, 2
  003c1	75 4c		 jne	 SHORT $LN11@decode_cod@2
  003c3	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  003c7	75 46		 jne	 SHORT $LN11@decode_cod@2
  003c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  003d7	4c 8b cf	 mov	 r9, rdi
  003da	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  003e0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003e8	e8 00 00 00 00	 call	 _PyParallel_Guard
  003ed	48 8b cf	 mov	 rcx, rdi
  003f0	85 c0		 test	 eax, eax
  003f2	74 07		 je	 SHORT $LN64@decode_cod@2
  003f4	e8 00 00 00 00	 call	 _Px_Dealloc
  003f9	eb 14		 jmp	 SHORT $LN11@decode_cod@2
$LN64@decode_cod@2:
  003fb	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  003ff	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00405	eb 08		 jmp	 SHORT $LN11@decode_cod@2
$LN59@decode_cod@2:
  00407	48 8b cf	 mov	 rcx, rdi
  0040a	e8 00 00 00 00	 call	 Px_DecRef
$LN11@decode_cod@2:

; 6989 :     Py_XDECREF(errorHandler);

  0040f	4d 85 ed	 test	 r13, r13
  00412	74 65		 je	 SHORT $LN7@decode_cod@2
  00414	e8 00 00 00 00	 call	 _Py_PXCTX
  00419	85 c0		 test	 eax, eax
  0041b	75 5c		 jne	 SHORT $LN7@decode_cod@2
  0041d	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  00421	a8 20		 test	 al, 32			; 00000020H
  00423	75 4c		 jne	 SHORT $LN70@decode_cod@2
  00425	84 c0		 test	 al, al
  00427	78 48		 js	 SHORT $LN70@decode_cod@2
  00429	a8 02		 test	 al, 2
  0042b	75 4c		 jne	 SHORT $LN7@decode_cod@2
  0042d	49 ff 4d 50	 dec	 QWORD PTR [r13+80]
  00431	75 46		 jne	 SHORT $LN7@decode_cod@2
  00433	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0043a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00441	4d 8b cd	 mov	 r9, r13
  00444	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0044a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00452	e8 00 00 00 00	 call	 _PyParallel_Guard
  00457	49 8b cd	 mov	 rcx, r13
  0045a	85 c0		 test	 eax, eax
  0045c	74 07		 je	 SHORT $LN75@decode_cod@2
  0045e	e8 00 00 00 00	 call	 _Px_Dealloc
  00463	eb 14		 jmp	 SHORT $LN7@decode_cod@2
$LN75@decode_cod@2:
  00465	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  00469	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0046f	eb 08		 jmp	 SHORT $LN7@decode_cod@2
$LN70@decode_cod@2:
  00471	49 8b cd	 mov	 rcx, r13
  00474	e8 00 00 00 00	 call	 Px_DecRef
$LN7@decode_cod@2:

; 6990 :     Py_XDECREF(exc);

  00479	4d 85 e4	 test	 r12, r12
  0047c	74 68		 je	 SHORT $LN3@decode_cod@2
  0047e	e8 00 00 00 00	 call	 _Py_PXCTX
  00483	85 c0		 test	 eax, eax
  00485	75 5f		 jne	 SHORT $LN3@decode_cod@2
  00487	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  0048c	a8 20		 test	 al, 32			; 00000020H
  0048e	75 4e		 jne	 SHORT $LN81@decode_cod@2
  00490	84 c0		 test	 al, al
  00492	78 4a		 js	 SHORT $LN81@decode_cod@2
  00494	a8 02		 test	 al, 2
  00496	75 4e		 jne	 SHORT $LN3@decode_cod@2
  00498	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  0049d	75 47		 jne	 SHORT $LN3@decode_cod@2
  0049f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  004a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  004ad	4d 8b cc	 mov	 r9, r12
  004b0	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  004b6	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004be	e8 00 00 00 00	 call	 _PyParallel_Guard
  004c3	49 8b cc	 mov	 rcx, r12
  004c6	85 c0		 test	 eax, eax
  004c8	74 07		 je	 SHORT $LN86@decode_cod@2
  004ca	e8 00 00 00 00	 call	 _Px_Dealloc
  004cf	eb 15		 jmp	 SHORT $LN3@decode_cod@2
$LN86@decode_cod@2:
  004d1	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  004d6	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  004dc	eb 08		 jmp	 SHORT $LN3@decode_cod@2
$LN81@decode_cod@2:
  004de	49 8b cc	 mov	 rcx, r12
  004e1	e8 00 00 00 00	 call	 Px_DecRef
$LN3@decode_cod@2:

; 6991 :     return ret;

  004e6	8b c6		 mov	 eax, esi
  004e8	48 8b b4 24 c8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+200]
$LN39@decode_cod@2:

; 6992 : }

  004f0	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  004f7	41 5f		 pop	 r15
  004f9	41 5e		 pop	 r14
  004fb	41 5d		 pop	 r13
  004fd	41 5c		 pop	 r12
  004ff	5f		 pop	 rdi
  00500	5b		 pop	 rbx
  00501	5d		 pop	 rbp
  00502	c3		 ret	 0
decode_code_page_errors ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@GCBOAGML@invalid?5code?5page?5number?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$decode_code_page_stateful DD imagerel decode_code_page_stateful
	DD	imagerel decode_code_page_stateful+392
	DD	imagerel $unwind$decode_code_page_stateful
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$decode_code_page_stateful DD 0d7201H
	DD	0f5472H
	DD	0e346dH
	DD	08745cH
	DD	010644fH
	DD	0f008820cH
	DD	0d004e006H
	DD	0c002H
xdata	ENDS
;	COMDAT ??_C@_0BJ@GCBOAGML@invalid?5code?5page?5number?$AA@
CONST	SEGMENT
??_C@_0BJ@GCBOAGML@invalid?5code?5page?5number?$AA@ DB 'invalid code page'
	DB	' number', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT decode_code_page_stateful
_TEXT	SEGMENT
v$ = 48
code_page$ = 112
s$ = 120
size$ = 128
errors$ = 136
consumed$ = 144
decode_code_page_stateful PROC				; COMDAT

; 6998 : {

  00000	41 54		 push	 r12
  00002	41 55		 push	 r13
  00004	41 56		 push	 r14
  00006	41 57		 push	 r15
  00008	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  0000c	4d 8b f9	 mov	 r15, r9
  0000f	4d 8b e0	 mov	 r12, r8
  00012	4c 8b ea	 mov	 r13, rdx
  00015	44 8b f1	 mov	 r14d, ecx

; 6999 :     PyObject *v = NULL;

  00018	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR v$[rsp], 0

; 7000 :     int chunk_size, final, converted, done;
; 7001 : 
; 7002 :     if (code_page < 0) {

  00021	85 c9		 test	 ecx, ecx
  00023	79 22		 jns	 SHORT $LN26@decode_cod@3

; 7003 :         PyErr_SetString(PyExc_ValueError, "invalid code page number");

  00025	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@GCBOAGML@invalid?5code?5page?5number?$AA@
  00033	e8 00 00 00 00	 call	 PyErr_SetString

; 7004 :         return NULL;

  00038	33 c0		 xor	 eax, eax

; 7058 : }

  0003a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0003e	41 5f		 pop	 r15
  00040	41 5e		 pop	 r14
  00042	41 5d		 pop	 r13
  00044	41 5c		 pop	 r12
  00046	c3		 ret	 0
$LN26@decode_cod@3:
  00047	48 89 b4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rsi

; 7005 :     }
; 7006 : 
; 7007 :     if (consumed)

  0004f	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR consumed$[rsp]
  00057	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0005c	48 85 f6	 test	 rsi, rsi
  0005f	74 07		 je	 SHORT $LN36@decode_cod@3

; 7008 :         *consumed = 0;

  00061	48 c7 06 00 00
	00 00		 mov	 QWORD PTR [rsi], 0
$LN36@decode_cod@3:
  00068	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx
  0006d	48 89 6c 24 78	 mov	 QWORD PTR [rsp+120], rbp
$LL24@decode_cod@3:

; 7009 : 
; 7010 :     do
; 7011 :     {
; 7012 : #ifdef NEED_RETRY
; 7013 :         if (size > INT_MAX) {

  00072	49 81 fc ff ff
	ff 7f		 cmp	 r12, 2147483647		; 7fffffffH
  00079	7e 09		 jle	 SHORT $LN21@decode_cod@3

; 7014 :             chunk_size = INT_MAX;

  0007b	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH

; 7015 :             final = 0;
; 7016 :             done = 0;

  00080	33 ed		 xor	 ebp, ebp

; 7017 :         }
; 7018 :         else

  00082	eb 14		 jmp	 SHORT $LN32@decode_cod@3
$LN21@decode_cod@3:

; 7019 : #endif
; 7020 :         {
; 7021 :             chunk_size = (int)size;
; 7022 :             final = (consumed == NULL);

  00084	33 c0		 xor	 eax, eax
  00086	48 85 f6	 test	 rsi, rsi
  00089	41 8b fc	 mov	 edi, r12d
  0008c	0f 94 c0	 sete	 al

; 7023 :             done = 1;

  0008f	bd 01 00 00 00	 mov	 ebp, 1

; 7024 :         }
; 7025 : 
; 7026 :         /* Skip trailing lead-byte unless 'final' is set */
; 7027 :         if (!final && is_dbcs_lead_byte(code_page, s, chunk_size - 1))

  00094	85 c0		 test	 eax, eax
  00096	75 16		 jne	 SHORT $LN19@decode_cod@3
$LN32@decode_cod@3:
  00098	8d 5f ff	 lea	 ebx, DWORD PTR [rdi-1]
  0009b	49 8b d5	 mov	 rdx, r13
  0009e	41 8b ce	 mov	 ecx, r14d
  000a1	44 8b c3	 mov	 r8d, ebx
  000a4	e8 00 00 00 00	 call	 is_dbcs_lead_byte
  000a9	85 c0		 test	 eax, eax
  000ab	0f 45 fb	 cmovne	 edi, ebx
$LN19@decode_cod@3:

; 7028 :             --chunk_size;
; 7029 : 
; 7030 :         if (chunk_size == 0 && done) {

  000ae	85 ff		 test	 edi, edi
  000b0	75 04		 jne	 SHORT $LN14@decode_cod@3
  000b2	85 ed		 test	 ebp, ebp
  000b4	75 63		 jne	 SHORT $LN30@decode_cod@3
$LN14@decode_cod@3:

; 7034 :         }
; 7035 : 
; 7036 : 
; 7037 :         converted = decode_code_page_strict(code_page, &v,
; 7038 :                                             s, chunk_size);

  000b6	48 8d 54 24 30	 lea	 rdx, QWORD PTR v$[rsp]
  000bb	44 8b cf	 mov	 r9d, edi
  000be	4d 8b c5	 mov	 r8, r13
  000c1	41 8b ce	 mov	 ecx, r14d
  000c4	e8 00 00 00 00	 call	 decode_code_page_strict
  000c9	44 8b d8	 mov	 r11d, eax

; 7039 :         if (converted == -2)

  000cc	83 f8 fe	 cmp	 eax, -2
  000cf	75 1b		 jne	 SHORT $LN7@decode_cod@3

; 7040 :             converted = decode_code_page_errors(code_page, &v,
; 7041 :                                                 s, chunk_size,
; 7042 :                                                 errors);

  000d1	48 8d 54 24 30	 lea	 rdx, QWORD PTR v$[rsp]
  000d6	44 8b cf	 mov	 r9d, edi
  000d9	4d 8b c5	 mov	 r8, r13
  000dc	41 8b ce	 mov	 ecx, r14d
  000df	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  000e4	e8 00 00 00 00	 call	 decode_code_page_errors
  000e9	44 8b d8	 mov	 r11d, eax
$LN7@decode_cod@3:

; 7043 :         assert(converted != 0);
; 7044 : 
; 7045 :         if (converted < 0) {

  000ec	45 85 db	 test	 r11d, r11d
  000ef	78 62		 js	 SHORT $LN31@decode_cod@3

; 7048 :         }
; 7049 : 
; 7050 :         if (consumed)

  000f1	48 85 f6	 test	 rsi, rsi
  000f4	74 06		 je	 SHORT $LN1@decode_cod@3

; 7051 :             *consumed += converted;

  000f6	49 63 c3	 movsxd	 rax, r11d
  000f9	48 01 06	 add	 QWORD PTR [rsi], rax
$LN1@decode_cod@3:

; 7052 : 
; 7053 :         s += converted;

  000fc	49 63 c3	 movsxd	 rax, r11d
  000ff	4c 03 e8	 add	 r13, rax

; 7054 :         size -= converted;

  00102	4c 2b e0	 sub	 r12, rax

; 7055 :     } while (!done);

  00105	85 ed		 test	 ebp, ebp
  00107	0f 84 65 ff ff
	ff		 je	 $LL24@decode_cod@3

; 7047 :             return NULL;

  0010d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
$LN22@decode_cod@3:

; 7056 : 
; 7057 :     return unicode_result(v);

  00112	e8 00 00 00 00	 call	 unicode_result
  00117	eb 4b		 jmp	 SHORT $LN40@decode_cod@3
$LN30@decode_cod@3:

; 7031 :             if (v != NULL)

  00119	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  0011e	48 85 c9	 test	 rcx, rcx
  00121	75 ef		 jne	 SHORT $LN22@decode_cod@3

; 7032 :                 break;
; 7033 :             _Py_RETURN_UNICODE_EMPTY();

  00123	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  0012a	48 85 c9	 test	 rcx, rcx
  0012d	75 16		 jne	 SHORT $LN41@decode_cod@3
  0012f	33 d2		 xor	 edx, edx
  00131	e8 00 00 00 00	 call	 PyUnicode_New
  00136	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  0013d	48 85 c0	 test	 rax, rax
  00140	74 22		 je	 SHORT $LN40@decode_cod@3
  00142	48 8b c8	 mov	 rcx, rax
$LN41@decode_cod@3:
  00145	e8 00 00 00 00	 call	 _Py_IncRef
  0014a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty
  00151	eb 11		 jmp	 SHORT $LN40@decode_cod@3
$LN31@decode_cod@3:

; 7046 :             Py_XDECREF(v);

  00153	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00158	48 85 c9	 test	 rcx, rcx
  0015b	74 05		 je	 SHORT $LN4@decode_cod@3
  0015d	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@decode_cod@3:

; 7047 :             return NULL;

  00162	33 c0		 xor	 eax, eax
$LN40@decode_cod@3:
  00164	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  00169	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0016e	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  00176	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 7058 : }

  0017b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0017f	41 5f		 pop	 r15
  00181	41 5e		 pop	 r14
  00183	41 5d		 pop	 r13
  00185	41 5c		 pop	 r12
  00187	c3		 ret	 0
decode_code_page_stateful ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_DecodeCodePageStateful
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_DecodeCodePageStateful DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$PyUnicode_DecodeCodePageStateful
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_DecodeCodePageStateful DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_DecodeCodePageStateful
_TEXT	SEGMENT
code_page$ = 64
s$ = 72
size$ = 80
errors$ = 88
consumed$ = 96
PyUnicode_DecodeCodePageStateful PROC			; COMDAT

; 7066 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7067 :     return decode_code_page_stateful(code_page, s, size, errors, consumed);

  00004	48 8b 44 24 60	 mov	 rax, QWORD PTR consumed$[rsp]
  00009	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0000e	e8 00 00 00 00	 call	 decode_code_page_stateful

; 7068 : }

  00013	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00017	c3		 ret	 0
PyUnicode_DecodeCodePageStateful ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_DecodeMBCSStateful
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_DecodeMBCSStateful DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$PyUnicode_DecodeMBCSStateful
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_DecodeMBCSStateful DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_DecodeMBCSStateful
_TEXT	SEGMENT
s$ = 64
size$ = 72
errors$ = 80
consumed$ = 88
PyUnicode_DecodeMBCSStateful PROC			; COMDAT

; 7075 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7076 :     return decode_code_page_stateful(CP_ACP, s, size, errors, consumed);

  00004	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00009	4d 8b c8	 mov	 r9, r8
  0000c	4c 8b c2	 mov	 r8, rdx
  0000f	48 8b d1	 mov	 rdx, rcx
  00012	33 c9		 xor	 ecx, ecx
  00014	e8 00 00 00 00	 call	 decode_code_page_stateful

; 7077 : }

  00019	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001d	c3		 ret	 0
PyUnicode_DecodeMBCSStateful ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_DecodeMBCS
; Function compile flags: /Ogtpy
;	COMDAT PyUnicode_DecodeMBCS
_TEXT	SEGMENT
s$ = 8
size$ = 16
errors$ = 24
PyUnicode_DecodeMBCS PROC				; COMDAT

; 7084 :     return PyUnicode_DecodeMBCSStateful(s, size, errors, NULL);

  00000	45 33 c9	 xor	 r9d, r9d

; 7085 : }

  00003	e9 00 00 00 00	 jmp	 PyUnicode_DecodeMBCSStateful
PyUnicode_DecodeMBCS ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@CGOMCDAP@character?5mapping?5must?5be?5in?5ran@ ; `string'
PUBLIC	PyUnicode_DecodeCharmap
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyUnicode_DecodeCharmap DD imagerel $LN204
	DD	imagerel $LN204+78
	DD	imagerel $unwind$PyUnicode_DecodeCharmap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyUnicode_DecodeCharmap DD imagerel $LN204+78
	DD	imagerel $LN204+1778
	DD	imagerel $chain$3$PyUnicode_DecodeCharmap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyUnicode_DecodeCharmap DD imagerel $LN204+1778
	DD	imagerel $LN204+1817
	DD	imagerel $chain$5$PyUnicode_DecodeCharmap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyUnicode_DecodeCharmap DD 080021H
	DD	014e400H
	DD	015d400H
	DD	016c400H
	DD	01d7400H
	DD	imagerel $LN204
	DD	imagerel $LN204+78
	DD	imagerel $unwind$PyUnicode_DecodeCharmap
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyUnicode_DecodeCharmap DD 082821H
	DD	014e428H
	DD	015d420H
	DD	016c410H
	DD	01d7408H
	DD	imagerel $LN204
	DD	imagerel $LN204+78
	DD	imagerel $unwind$PyUnicode_DecodeCharmap
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_DecodeCharmap DD 062001H
	DD	0170120H
	DD	06012f014H
	DD	050103011H
xdata	ENDS
;	COMDAT ??_C@_0CK@CGOMCDAP@character?5mapping?5must?5be?5in?5ran@
CONST	SEGMENT
??_C@_0CK@CGOMCDAP@character?5mapping?5must?5be?5in?5ran@ DB 'character m'
	DB	'apping must be in range(0x%lx)', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT PyUnicode_DecodeCharmap
_TEXT	SEGMENT
v$ = 96
outpos$ = 104
starts$ = 112
e$ = 120
errorHandler$ = 128
exc$ = 136
endinpos$ = 144
startinpos$ = 152
s$ = 224
size$ = 232
mapping$ = 240
errors$ = 248
PyUnicode_DecodeCharmap PROC				; COMDAT

; 7498 : {

$LN204:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	53		 push	 rbx
  00011	56		 push	 rsi
  00012	41 57		 push	 r15
  00014	48 8d 6c 24 c1	 lea	 rbp, QWORD PTR [rsp-63]
  00019	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 7499 :     const char *starts = s;
; 7500 :     Py_ssize_t startinpos;
; 7501 :     Py_ssize_t endinpos;
; 7502 :     Py_ssize_t outpos;
; 7503 :     const char *e;
; 7504 :     PyObject *v;
; 7505 :     Py_ssize_t extrachars = 0;

  00020	45 33 ff	 xor	 r15d, r15d
  00023	48 8b f2	 mov	 rsi, rdx
  00026	48 8b d9	 mov	 rbx, rcx
  00029	48 89 4d f7	 mov	 QWORD PTR starts$[rbp-121], rcx

; 7506 :     PyObject *errorHandler = NULL;

  0002d	4c 89 7d 07	 mov	 QWORD PTR errorHandler$[rbp-121], r15

; 7507 :     PyObject *exc = NULL;

  00031	4c 89 7d 0f	 mov	 QWORD PTR exc$[rbp-121], r15

; 7508 : 
; 7509 :     /* Default to Latin-1 */
; 7510 :     if (mapping == NULL)

  00035	4d 85 c0	 test	 r8, r8
  00038	75 14		 jne	 SHORT $LN89@PyUnicode_@79

; 7511 :         return PyUnicode_DecodeLatin1(s, size, errors);

  0003a	4d 8b c1	 mov	 r8, r9

; 7708 : }

  0003d	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00044	41 5f		 pop	 r15
  00046	5e		 pop	 rsi
  00047	5b		 pop	 rbx
  00048	5d		 pop	 rbp
  00049	e9 00 00 00 00	 jmp	 PyUnicode_DecodeLatin1
$LN89@PyUnicode_@79:
  0004e	48 89 bc 24 e8
	00 00 00	 mov	 QWORD PTR [rsp+232], rdi
  00056	4c 89 a4 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], r12

; 7512 : 
; 7513 :     v = PyUnicode_New(size, 127);

  0005e	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00063	48 8b ce	 mov	 rcx, rsi
  00066	4c 89 ac 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], r13
  0006e	4c 89 b4 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], r14
  00076	e8 00 00 00 00	 call	 PyUnicode_New
  0007b	4c 8b e0	 mov	 r12, rax
  0007e	48 89 45 e7	 mov	 QWORD PTR v$[rbp-121], rax

; 7514 :     if (v == NULL)

  00082	48 85 c0	 test	 rax, rax
  00085	0f 84 38 06 00
	00		 je	 $LN3@PyUnicode_@79

; 7515 :         goto onError;
; 7516 :     if (size == 0)

  0008b	48 85 f6	 test	 rsi, rsi

; 7517 :         return v;

  0008e	0f 84 31 06 00
	00		 je	 $LN200@PyUnicode_@79

; 7518 :     outpos = 0;
; 7519 :     e = s + size;

  00094	4c 8d 34 33	 lea	 r14, QWORD PTR [rbx+rsi]

; 7520 :     if (PyUnicode_CheckExact(mapping)) {

  00098	48 8b 75 77	 mov	 rsi, QWORD PTR mapping$[rbp-121]
  0009c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  000a3	49 8b ff	 mov	 rdi, r15
  000a6	4c 89 7d ef	 mov	 QWORD PTR outpos$[rbp-121], r15
  000aa	4c 89 75 ff	 mov	 QWORD PTR e$[rbp-121], r14
  000ae	48 39 46 58	 cmp	 QWORD PTR [rsi+88], rax
  000b2	0f 85 32 02 00
	00		 jne	 $LN152@PyUnicode_@79

; 7521 :         Py_ssize_t maplen;
; 7522 :         enum PyUnicode_Kind mapkind;
; 7523 :         void *mapdata;
; 7524 :         Py_UCS4 x;
; 7525 : 
; 7526 :         if (PyUnicode_READY(mapping) == -1)

  000b8	f6 46 70 80	 test	 BYTE PTR [rsi+112], 128	; 00000080H
  000bc	75 11		 jne	 SHORT $LN85@PyUnicode_@79
  000be	48 8b ce	 mov	 rcx, rsi
  000c1	e8 00 00 00 00	 call	 _PyUnicode_Ready
  000c6	83 f8 ff	 cmp	 eax, -1

; 7527 :             return NULL;

  000c9	0f 84 f4 05 00
	00		 je	 $LN3@PyUnicode_@79
$LN85@PyUnicode_@79:

; 7528 : 
; 7529 :         maplen = PyUnicode_GET_LENGTH(mapping);
; 7530 :         mapdata = PyUnicode_DATA(mapping);

  000cf	8b 46 70	 mov	 eax, DWORD PTR [rsi+112]
  000d2	4c 8b 7e 60	 mov	 r15, QWORD PTR [rsi+96]
  000d6	a8 20		 test	 al, 32			; 00000020H
  000d8	74 13		 je	 SHORT $LN96@PyUnicode_@79
  000da	a8 40		 test	 al, 64			; 00000040H
  000dc	74 06		 je	 SHORT $LN94@PyUnicode_@79
  000de	48 83 ee 80	 sub	 rsi, -128		; ffffffffffffff80H
  000e2	eb 10		 jmp	 SHORT $LN97@PyUnicode_@79
$LN94@PyUnicode_@79:
  000e4	48 81 c6 a0 00
	00 00		 add	 rsi, 160		; 000000a0H
  000eb	eb 07		 jmp	 SHORT $LN97@PyUnicode_@79
$LN96@PyUnicode_@79:
  000ed	48 8b b6 a0 00
	00 00		 mov	 rsi, QWORD PTR [rsi+160]
$LN97@PyUnicode_@79:

; 7531 :         mapkind = PyUnicode_KIND(mapping);

  000f4	c1 e8 02	 shr	 eax, 2
  000f7	83 e0 07	 and	 eax, 7

; 7533 :             unsigned char ch;
; 7534 :             if (mapkind == PyUnicode_2BYTE_KIND && maplen >= 256) {

  000fa	4c 63 e8	 movsxd	 r13, eax
  000fd	49 3b de	 cmp	 rbx, r14
  00100	0f 83 80 05 00
	00		 jae	 $LN49@PyUnicode_@79
$LN201@PyUnicode_@79:

; 7532 :         while (s < e) {

  00106	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH

; 7533 :             unsigned char ch;
; 7534 :             if (mapkind == PyUnicode_2BYTE_KIND && maplen >= 256) {

  0010b	49 83 fd 02	 cmp	 r13, 2
  0010f	0f 85 ec 00 00
	00		 jne	 $LN68@PyUnicode_@79
  00115	49 81 ff 00 01
	00 00		 cmp	 r15, 256		; 00000100H
  0011c	0f 8c df 00 00
	00		 jl	 $LN68@PyUnicode_@79

; 7535 :                 enum PyUnicode_Kind outkind = PyUnicode_KIND(v);

  00122	41 8b 4c 24 70	 mov	 ecx, DWORD PTR [r12+112]
  00127	8b c1		 mov	 eax, ecx
  00129	c1 e8 02	 shr	 eax, 2
  0012c	83 e0 07	 and	 eax, 7

; 7536 :                 if (outkind == PyUnicode_1BYTE_KIND) {

  0012f	83 f8 01	 cmp	 eax, 1
  00132	75 7a		 jne	 SHORT $LN81@PyUnicode_@79

; 7537 :                     void *outdata = PyUnicode_DATA(v);

  00134	f6 c1 20	 test	 cl, 32			; 00000020H
  00137	74 14		 je	 SHORT $LN100@PyUnicode_@79
  00139	f6 c1 40	 test	 cl, 64			; 00000040H
  0013c	74 06		 je	 SHORT $LN98@PyUnicode_@79
  0013e	49 83 ec 80	 sub	 r12, -128		; ffffffffffffff80H
  00142	eb 11		 jmp	 SHORT $LN101@PyUnicode_@79
$LN98@PyUnicode_@79:
  00144	49 81 c4 a0 00
	00 00		 add	 r12, 160		; 000000a0H
  0014b	eb 08		 jmp	 SHORT $LN101@PyUnicode_@79
$LN100@PyUnicode_@79:
  0014d	4d 8b a4 24 a0
	00 00 00	 mov	 r12, QWORD PTR [r12+160]
$LN101@PyUnicode_@79:

; 7538 :                     Py_UCS4 maxchar = PyUnicode_MAX_CHAR_VALUE(v);

  00155	f6 c1 40	 test	 cl, 64			; 00000040H
  00158	74 07		 je	 SHORT $LN104@PyUnicode_@79
  0015a	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  0015f	eb 1f		 jmp	 SHORT $LL80@PyUnicode_@79
$LN104@PyUnicode_@79:
  00161	83 f8 01	 cmp	 eax, 1
  00164	75 07		 jne	 SHORT $LN102@PyUnicode_@79
  00166	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  0016b	eb 13		 jmp	 SHORT $LL80@PyUnicode_@79
$LN102@PyUnicode_@79:
  0016d	b9 ff ff 10 00	 mov	 ecx, 1114111		; 0010ffffH
  00172	83 f8 02	 cmp	 eax, 2
  00175	0f 44 ca	 cmove	 ecx, edx
  00178	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL80@PyUnicode_@79:

; 7539 :                     while (s < e) {

  00180	49 3b de	 cmp	 rbx, r14
  00183	0f 83 fd 04 00
	00		 jae	 $LN49@PyUnicode_@79

; 7540 :                         unsigned char ch = *s;
; 7541 :                         x = PyUnicode_READ(PyUnicode_2BYTE_KIND, mapdata, ch);

  00189	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  0018c	44 0f b7 04 46	 movzx	 r8d, WORD PTR [rsi+rax*2]

; 7542 :                         if (x > maxchar)

  00191	44 3b c1	 cmp	 r8d, ecx
  00194	0f 87 8d 00 00
	00		 ja	 $Error$133571

; 7543 :                             goto Error;
; 7544 :                         PyUnicode_WRITE(PyUnicode_1BYTE_KIND, outdata, outpos++, x);

  0019a	45 88 04 3c	 mov	 BYTE PTR [r12+rdi], r8b
  0019e	48 ff c7	 inc	 rdi

; 7545 :                         ++s;

  001a1	48 ff c3	 inc	 rbx
  001a4	48 89 5d 67	 mov	 QWORD PTR s$[rbp-121], rbx
  001a8	48 89 7d ef	 mov	 QWORD PTR outpos$[rbp-121], rdi

; 7546 :                     }

  001ac	eb d2		 jmp	 SHORT $LL80@PyUnicode_@79
$LN81@PyUnicode_@79:

; 7547 :                     break;
; 7548 :                 }
; 7549 :                 else if (outkind == PyUnicode_2BYTE_KIND) {

  001ae	83 f8 02	 cmp	 eax, 2
  001b1	75 4e		 jne	 SHORT $LN68@PyUnicode_@79

; 7550 :                     void *outdata = PyUnicode_DATA(v);

  001b3	f6 c1 20	 test	 cl, 32			; 00000020H
  001b6	74 14		 je	 SHORT $LN108@PyUnicode_@79
  001b8	f6 c1 40	 test	 cl, 64			; 00000040H
  001bb	74 06		 je	 SHORT $LN106@PyUnicode_@79
  001bd	49 83 ec 80	 sub	 r12, -128		; ffffffffffffff80H
  001c1	eb 11		 jmp	 SHORT $LL67@PyUnicode_@79
$LN106@PyUnicode_@79:
  001c3	49 81 c4 a0 00
	00 00		 add	 r12, 160		; 000000a0H
  001ca	eb 08		 jmp	 SHORT $LL67@PyUnicode_@79
$LN108@PyUnicode_@79:
  001cc	4d 8b a4 24 a0
	00 00 00	 mov	 r12, QWORD PTR [r12+160]
$LL67@PyUnicode_@79:

; 7551 :                     while (s < e) {

  001d4	49 3b de	 cmp	 rbx, r14
  001d7	0f 83 a9 04 00
	00		 jae	 $LN49@PyUnicode_@79

; 7552 :                         unsigned char ch = *s;
; 7553 :                         x = PyUnicode_READ(PyUnicode_2BYTE_KIND, mapdata, ch);

  001dd	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  001e0	0f b7 0c 46	 movzx	 ecx, WORD PTR [rsi+rax*2]

; 7554 :                         if (x == 0xFFFE)

  001e4	81 f9 fe ff 00
	00		 cmp	 ecx, 65534		; 0000fffeH
  001ea	74 65		 je	 SHORT $LN167@PyUnicode_@79

; 7555 :                             goto Error;
; 7556 :                         PyUnicode_WRITE(PyUnicode_2BYTE_KIND, outdata, outpos++, x);

  001ec	66 41 89 0c 7c	 mov	 WORD PTR [r12+rdi*2], cx
  001f1	48 ff c7	 inc	 rdi

; 7557 :                         ++s;

  001f4	48 ff c3	 inc	 rbx
  001f7	48 89 5d 67	 mov	 QWORD PTR s$[rbp-121], rbx
  001fb	48 89 7d ef	 mov	 QWORD PTR outpos$[rbp-121], rdi

; 7558 :                     }

  001ff	eb d3		 jmp	 SHORT $LL67@PyUnicode_@79
$LN68@PyUnicode_@79:

; 7559 :                     break;
; 7560 :                 }
; 7561 :             }
; 7562 :             ch = *s;
; 7563 : 
; 7564 :             if (ch < maplen)

  00201	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00204	49 3b c7	 cmp	 rax, r15
  00207	7d 48		 jge	 SHORT $LN167@PyUnicode_@79

; 7565 :                 x = PyUnicode_READ(mapkind, mapdata, ch);

  00209	49 83 fd 01	 cmp	 r13, 1
  0020d	75 07		 jne	 SHORT $LN112@PyUnicode_@79
  0020f	44 0f b6 04 30	 movzx	 r8d, BYTE PTR [rax+rsi]
  00214	eb 11		 jmp	 SHORT $Error$133571
$LN112@PyUnicode_@79:
  00216	49 83 fd 02	 cmp	 r13, 2
  0021a	75 07		 jne	 SHORT $LN110@PyUnicode_@79
  0021c	44 0f b7 04 46	 movzx	 r8d, WORD PTR [rsi+rax*2]
  00221	eb 04		 jmp	 SHORT $Error$133571
$LN110@PyUnicode_@79:
  00223	44 8b 04 86	 mov	 r8d, DWORD PTR [rsi+rax*4]
$Error$133571:

; 7566 :             else
; 7567 :                 x = 0xfffe; /* invalid value */
; 7568 : Error:
; 7569 :             if (x == 0xfffe)

  00227	41 81 f8 fe ff
	00 00		 cmp	 r8d, 65534		; 0000fffeH
  0022e	74 21		 je	 SHORT $LN167@PyUnicode_@79

; 7582 :             }
; 7583 : 
; 7584 :             if (unicode_putchar(&v, &outpos, x) < 0)

  00230	48 8d 55 ef	 lea	 rdx, QWORD PTR outpos$[rbp-121]
  00234	48 8d 4d e7	 lea	 rcx, QWORD PTR v$[rbp-121]
  00238	e8 00 00 00 00	 call	 unicode_putchar
  0023d	85 c0		 test	 eax, eax
  0023f	0f 88 51 04 00
	00		 js	 $LN183@PyUnicode_@79

; 7585 :                 goto onError;
; 7586 :             ++s;

  00245	48 ff c3	 inc	 rbx
  00248	48 89 5d 67	 mov	 QWORD PTR s$[rbp-121], rbx
  0024c	e9 83 00 00 00	 jmp	 $LN165@PyUnicode_@79
$LN167@PyUnicode_@79:

; 7570 :             {
; 7571 :                 /* undefined mapping */
; 7572 :                 startinpos = s-starts;

  00251	48 2b 5d f7	 sub	 rbx, QWORD PTR starts$[rbp-121]

; 7573 :                 endinpos = startinpos+1;
; 7574 :                 if (unicode_decode_call_errorhandler(
; 7575 :                         errors, &errorHandler,
; 7576 :                         "charmap", "character maps to <undefined>",
; 7577 :                         &starts, &e, &startinpos, &endinpos, &exc, &s,
; 7578 :                         &v, &outpos)) {

  00255	48 8b 4d 7f	 mov	 rcx, QWORD PTR errors$[rbp-121]
  00259	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BO@BLGNENDK@character?5maps?5to?5?$DMundefined?$DO?$AA@
  00260	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
  00264	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07JDDMBNCD@charmap?$AA@
  0026b	48 8d 55 07	 lea	 rdx, QWORD PTR errorHandler$[rbp-121]
  0026f	48 89 45 17	 mov	 QWORD PTR endinpos$[rbp-121], rax
  00273	48 8d 45 ef	 lea	 rax, QWORD PTR outpos$[rbp-121]
  00277	48 89 5d 1f	 mov	 QWORD PTR startinpos$[rbp-121], rbx
  0027b	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00280	48 8d 45 e7	 lea	 rax, QWORD PTR v$[rbp-121]
  00284	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00289	48 8d 45 67	 lea	 rax, QWORD PTR s$[rbp-121]
  0028d	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00292	48 8d 45 0f	 lea	 rax, QWORD PTR exc$[rbp-121]
  00296	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0029b	48 8d 45 17	 lea	 rax, QWORD PTR endinpos$[rbp-121]
  0029f	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  002a4	48 8d 45 1f	 lea	 rax, QWORD PTR startinpos$[rbp-121]
  002a8	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  002ad	48 8d 45 ff	 lea	 rax, QWORD PTR e$[rbp-121]
  002b1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002b6	48 8d 45 f7	 lea	 rax, QWORD PTR starts$[rbp-121]
  002ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002bf	e8 00 00 00 00	 call	 unicode_decode_call_errorhandler
  002c4	85 c0		 test	 eax, eax
  002c6	0f 85 ca 03 00
	00		 jne	 $LN183@PyUnicode_@79

; 7579 :                     goto onError;
; 7580 :                 }
; 7581 :                 continue;

  002cc	48 8b 5d 67	 mov	 rbx, QWORD PTR s$[rbp-121]
  002d0	4c 8b 75 ff	 mov	 r14, QWORD PTR e$[rbp-121]
$LN165@PyUnicode_@79:

; 7532 :         while (s < e) {

  002d4	48 8b 7d ef	 mov	 rdi, QWORD PTR outpos$[rbp-121]
  002d8	49 3b de	 cmp	 rbx, r14
  002db	0f 83 a5 03 00
	00		 jae	 $LN49@PyUnicode_@79
  002e1	4c 8b 65 e7	 mov	 r12, QWORD PTR v$[rbp-121]
  002e5	e9 1c fe ff ff	 jmp	 $LN201@PyUnicode_@79
$LN152@PyUnicode_@79:

; 7587 :         }
; 7588 :     }
; 7589 :     else {
; 7590 :         while (s < e) {

  002ea	49 3b de	 cmp	 rbx, r14
  002ed	0f 83 93 03 00
	00		 jae	 $LN49@PyUnicode_@79
$LL50@PyUnicode_@79:

; 7591 :             unsigned char ch = *s;
; 7592 :             PyObject *w, *x;
; 7593 : 
; 7594 :             /* Get mapping (char ordinal -> integer, Unicode char or None) */
; 7595 :             w = PyLong_FromLong((long)ch);

  002f3	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  002f6	e8 00 00 00 00	 call	 PyLong_FromLong
  002fb	4c 8b e8	 mov	 r13, rax

; 7596 :             if (w == NULL)

  002fe	48 85 c0	 test	 rax, rax
  00301	0f 84 93 03 00
	00		 je	 $onError$133500

; 7597 :                 goto onError;
; 7598 :             x = PyObject_GetItem(mapping, w);

  00307	48 8b d0	 mov	 rdx, rax
  0030a	48 8b ce	 mov	 rcx, rsi
  0030d	e8 00 00 00 00	 call	 PyObject_GetItem

; 7599 :             Py_DECREF(w);

  00312	49 8b cd	 mov	 rcx, r13
  00315	48 8b f0	 mov	 rsi, rax
  00318	e8 00 00 00 00	 call	 _Py_DecRef

; 7600 :             if (x == NULL) {

  0031d	48 85 f6	 test	 rsi, rsi
  00320	75 1e		 jne	 SHORT $LN45@PyUnicode_@79

; 7601 :                 if (PyErr_ExceptionMatches(PyExc_LookupError)) {

  00322	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_LookupError
  00329	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0032e	85 c0		 test	 eax, eax
  00330	0f 84 64 03 00
	00		 je	 $onError$133500

; 7602 :                     /* No mapping found means: mapping is undefined. */
; 7603 :                     PyErr_Clear();

  00336	e8 00 00 00 00	 call	 PyErr_Clear

; 7604 :                     goto Undefined;

  0033b	e9 67 02 00 00	 jmp	 $LN25@PyUnicode_@79
$LN45@PyUnicode_@79:

; 7605 :                 } else
; 7606 :                     goto onError;
; 7607 :             }
; 7608 : 
; 7609 :             /* Apply mapping */
; 7610 :             if (x == Py_None)

  00340	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00347	48 3b f0	 cmp	 rsi, rax
  0034a	0f 84 f2 01 00
	00		 je	 $Undefined$133654

; 7611 :                 goto Undefined;
; 7612 :             if (PyLong_Check(x)) {

  00350	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00354	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  0035a	0f ba e1 18	 bt	 ecx, 24
  0035e	73 2e		 jae	 SHORT $LN43@PyUnicode_@79

; 7613 :                 long value = PyLong_AS_LONG(x);

  00360	48 8b ce	 mov	 rcx, rsi
  00363	e8 00 00 00 00	 call	 PyLong_AsLong

; 7614 :                 if (value == 0xFFFE)

  00368	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  0036d	0f 84 cf 01 00
	00		 je	 $Undefined$133654

; 7615 :                     goto Undefined;
; 7616 :                 if (value < 0 || value > MAX_UNICODE) {

  00373	85 c0		 test	 eax, eax
  00375	0f 88 cb 02 00
	00		 js	 $LN40@PyUnicode_@79
  0037b	3d ff ff 10 00	 cmp	 eax, 1114111		; 0010ffffH
  00380	0f 8f c0 02 00
	00		 jg	 $LN40@PyUnicode_@79

; 7622 :                 }
; 7623 :                 if (unicode_putchar(&v, &outpos, value) < 0) {

  00386	44 8b c0	 mov	 r8d, eax

; 7626 :                 }

  00389	e9 d3 00 00 00	 jmp	 $LN203@PyUnicode_@79
$LN43@PyUnicode_@79:

; 7627 :             }
; 7628 :             else if (PyUnicode_Check(x)) {

  0038e	0f ba e1 1c	 bt	 ecx, 28
  00392	0f 83 d1 02 00
	00		 jae	 $LN37@PyUnicode_@79

; 7629 :                 Py_ssize_t targetsize;
; 7630 : 
; 7631 :                 if (PyUnicode_READY(x) == -1) {

  00398	f6 46 70 80	 test	 BYTE PTR [rsi+112], 128	; 00000080H
  0039c	75 11		 jne	 SHORT $LN171@PyUnicode_@79
  0039e	48 8b ce	 mov	 rcx, rsi
  003a1	e8 00 00 00 00	 call	 _PyUnicode_Ready
  003a6	83 f8 ff	 cmp	 eax, -1
  003a9	0f 84 b0 02 00
	00		 je	 $LN160@PyUnicode_@79
$LN171@PyUnicode_@79:

; 7632 :                     Py_DECREF(x);
; 7633 :                     goto onError;
; 7634 :                 }
; 7635 :                 targetsize = PyUnicode_GET_LENGTH(x);

  003af	4c 8b 6e 60	 mov	 r13, QWORD PTR [rsi+96]

; 7636 : 
; 7637 :                 if (targetsize == 1) {

  003b3	49 83 fd 01	 cmp	 r13, 1
  003b7	0f 85 d5 00 00
	00		 jne	 $LN202@PyUnicode_@79

; 7638 :                     /* 1-1 mapping */
; 7639 :                     Py_UCS4 value = PyUnicode_READ_CHAR(x, 0);

  003bd	8b 46 70	 mov	 eax, DWORD PTR [rsi+112]
  003c0	8b c8		 mov	 ecx, eax
  003c2	c1 e9 02	 shr	 ecx, 2
  003c5	83 e1 07	 and	 ecx, 7
  003c8	41 3b cd	 cmp	 ecx, r13d
  003cb	75 2f		 jne	 SHORT $LN130@PyUnicode_@79
  003cd	a8 20		 test	 al, 32			; 00000020H
  003cf	74 1e		 je	 SHORT $LN118@PyUnicode_@79
  003d1	a8 40		 test	 al, 64			; 00000040H
  003d3	74 0d		 je	 SHORT $LN116@PyUnicode_@79
  003d5	48 8d 86 80 00
	00 00		 lea	 rax, QWORD PTR [rsi+128]
  003dc	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  003e0	eb 72		 jmp	 SHORT $LN129@PyUnicode_@79
$LN116@PyUnicode_@79:
  003e2	48 8d 86 a0 00
	00 00		 lea	 rax, QWORD PTR [rsi+160]
  003e9	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  003ed	eb 65		 jmp	 SHORT $LN129@PyUnicode_@79
$LN118@PyUnicode_@79:
  003ef	48 8b 86 a0 00
	00 00		 mov	 rax, QWORD PTR [rsi+160]
  003f6	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  003fa	eb 58		 jmp	 SHORT $LN129@PyUnicode_@79
$LN130@PyUnicode_@79:
  003fc	83 f9 02	 cmp	 ecx, 2
  003ff	75 2f		 jne	 SHORT $LN128@PyUnicode_@79
  00401	a8 20		 test	 al, 32			; 00000020H
  00403	74 1e		 je	 SHORT $LN122@PyUnicode_@79
  00405	a8 40		 test	 al, 64			; 00000040H
  00407	74 0d		 je	 SHORT $LN120@PyUnicode_@79
  00409	48 8d 86 80 00
	00 00		 lea	 rax, QWORD PTR [rsi+128]
  00410	44 0f b7 00	 movzx	 r8d, WORD PTR [rax]
  00414	eb 3e		 jmp	 SHORT $LN129@PyUnicode_@79
$LN120@PyUnicode_@79:
  00416	48 8d 86 a0 00
	00 00		 lea	 rax, QWORD PTR [rsi+160]
  0041d	44 0f b7 00	 movzx	 r8d, WORD PTR [rax]
  00421	eb 31		 jmp	 SHORT $LN129@PyUnicode_@79
$LN122@PyUnicode_@79:
  00423	48 8b 86 a0 00
	00 00		 mov	 rax, QWORD PTR [rsi+160]
  0042a	44 0f b7 00	 movzx	 r8d, WORD PTR [rax]
  0042e	eb 24		 jmp	 SHORT $LN129@PyUnicode_@79
$LN128@PyUnicode_@79:
  00430	a8 20		 test	 al, 32			; 00000020H
  00432	74 16		 je	 SHORT $LN126@PyUnicode_@79
  00434	a8 40		 test	 al, 64			; 00000040H
  00436	74 09		 je	 SHORT $LN124@PyUnicode_@79
  00438	48 8d 86 80 00
	00 00		 lea	 rax, QWORD PTR [rsi+128]
  0043f	eb 10		 jmp	 SHORT $LN127@PyUnicode_@79
$LN124@PyUnicode_@79:
  00441	48 8d 86 a0 00
	00 00		 lea	 rax, QWORD PTR [rsi+160]
  00448	eb 07		 jmp	 SHORT $LN127@PyUnicode_@79
$LN126@PyUnicode_@79:
  0044a	48 8b 86 a0 00
	00 00		 mov	 rax, QWORD PTR [rsi+160]
$LN127@PyUnicode_@79:
  00451	44 8b 00	 mov	 r8d, DWORD PTR [rax]
$LN129@PyUnicode_@79:

; 7640 :                     if (value == 0xFFFE)

  00454	41 81 f8 fe ff
	00 00		 cmp	 r8d, 65534		; 0000fffeH
  0045b	0f 84 e1 00 00
	00		 je	 $Undefined$133654
$LN203@PyUnicode_@79:

; 7641 :                         goto Undefined;
; 7642 :                     if (unicode_putchar(&v, &outpos, value) < 0) {

  00461	48 8d 55 ef	 lea	 rdx, QWORD PTR outpos$[rbp-121]
  00465	48 8d 4d e7	 lea	 rcx, QWORD PTR v$[rbp-121]
  00469	e8 00 00 00 00	 call	 unicode_putchar
  0046e	85 c0		 test	 eax, eax
  00470	0f 88 c6 01 00
	00		 js	 $LN159@PyUnicode_@79

; 7643 :                         Py_DECREF(x);
; 7644 :                         goto onError;
; 7645 :                     }

  00476	4c 8b 65 e7	 mov	 r12, QWORD PTR v$[rbp-121]
  0047a	48 8b 7d ef	 mov	 rdi, QWORD PTR outpos$[rbp-121]

; 7679 :             }
; 7680 :             Py_DECREF(x);

  0047e	48 8b ce	 mov	 rcx, rsi
  00481	e8 00 00 00 00	 call	 _Py_DecRef

; 7681 :             ++s;

  00486	48 ff c3	 inc	 rbx
  00489	48 89 5d 67	 mov	 QWORD PTR s$[rbp-121], rbx
  0048d	e9 9c 01 00 00	 jmp	 $LN166@PyUnicode_@79
$LN202@PyUnicode_@79:

; 7646 :                 }
; 7647 :                 else if (targetsize > 1) {

  00492	0f 8e 96 00 00
	00		 jle	 $LN31@PyUnicode_@79

; 7648 :                     /* 1-n mapping */
; 7649 :                     if (targetsize > extrachars) {

  00498	4d 3b ef	 cmp	 r13, r15
  0049b	7e 25		 jle	 SHORT $LN29@PyUnicode_@79

; 7650 :                         /* resize first */
; 7651 :                         Py_ssize_t needed = (targetsize - extrachars) + \
; 7652 :                             (targetsize << 2);
; 7653 :                         extrachars += needed;
; 7654 :                         /* XXX overflow detection missing */
; 7655 :                         if (unicode_resize(&v,
; 7656 :                                            PyUnicode_GET_LENGTH(v) + needed) < 0)

  0049d	49 8b 44 24 60	 mov	 rax, QWORD PTR [r12+96]
  004a2	4b 8d 4c ad 00	 lea	 rcx, QWORD PTR [r13+r13*4]
  004a7	49 2b cf	 sub	 rcx, r15
  004aa	4c 03 f9	 add	 r15, rcx
  004ad	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  004b1	48 8d 4d e7	 lea	 rcx, QWORD PTR v$[rbp-121]
  004b5	e8 00 00 00 00	 call	 unicode_resize
  004ba	85 c0		 test	 eax, eax
  004bc	0f 88 7a 01 00
	00		 js	 $LN159@PyUnicode_@79
$LN29@PyUnicode_@79:

; 7657 :                         {
; 7658 :                             Py_DECREF(x);
; 7659 :                             goto onError;
; 7660 :                         }
; 7661 :                     }
; 7662 :                     if (unicode_widen(&v, outpos,
; 7663 :                                       PyUnicode_MAX_CHAR_VALUE(x)) < 0) {

  004c2	8b 46 70	 mov	 eax, DWORD PTR [rsi+112]
  004c5	a8 40		 test	 al, 64			; 00000040H
  004c7	74 08		 je	 SHORT $LN134@PyUnicode_@79
  004c9	41 b8 7f 00 00
	00		 mov	 r8d, 127		; 0000007fH
  004cf	eb 25		 jmp	 SHORT $LN133@PyUnicode_@79
$LN134@PyUnicode_@79:
  004d1	c1 e8 02	 shr	 eax, 2
  004d4	83 e0 07	 and	 eax, 7
  004d7	83 f8 01	 cmp	 eax, 1
  004da	75 08		 jne	 SHORT $LN132@PyUnicode_@79
  004dc	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  004e2	eb 12		 jmp	 SHORT $LN133@PyUnicode_@79
$LN132@PyUnicode_@79:
  004e4	83 f8 02	 cmp	 eax, 2
  004e7	41 b8 ff ff 10
	00		 mov	 r8d, 1114111		; 0010ffffH
  004ed	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  004f2	44 0f 44 c0	 cmove	 r8d, eax
$LN133@PyUnicode_@79:
  004f6	48 8d 4d e7	 lea	 rcx, QWORD PTR v$[rbp-121]
  004fa	48 8b d7	 mov	 rdx, rdi
  004fd	e8 00 00 00 00	 call	 unicode_widen
  00502	85 c0		 test	 eax, eax
  00504	0f 88 32 01 00
	00		 js	 $LN159@PyUnicode_@79

; 7664 :                         Py_DECREF(x);
; 7665 :                         goto onError;
; 7666 :                     }
; 7667 :                     PyUnicode_CopyCharacters(v, outpos, x, 0, targetsize);

  0050a	4c 8b 65 e7	 mov	 r12, QWORD PTR v$[rbp-121]
  0050e	45 33 c9	 xor	 r9d, r9d
  00511	4c 8b c6	 mov	 r8, rsi
  00514	48 8b d7	 mov	 rdx, rdi
  00517	49 8b cc	 mov	 rcx, r12
  0051a	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  0051f	e8 00 00 00 00	 call	 PyUnicode_CopyCharacters

; 7668 :                     outpos += targetsize;

  00524	49 03 fd	 add	 rdi, r13

; 7669 :                     extrachars -= targetsize;

  00527	4d 2b fd	 sub	 r15, r13
  0052a	48 89 7d ef	 mov	 QWORD PTR outpos$[rbp-121], rdi
$LN31@PyUnicode_@79:

; 7679 :             }
; 7680 :             Py_DECREF(x);

  0052e	48 8b ce	 mov	 rcx, rsi
  00531	e8 00 00 00 00	 call	 _Py_DecRef

; 7681 :             ++s;

  00536	48 ff c3	 inc	 rbx
  00539	48 89 5d 67	 mov	 QWORD PTR s$[rbp-121], rbx
  0053d	e9 ec 00 00 00	 jmp	 $LN166@PyUnicode_@79
$Undefined$133654:

; 7682 :             continue;
; 7683 : Undefined:
; 7684 :             /* undefined mapping */
; 7685 :             Py_XDECREF(x);

  00542	e8 00 00 00 00	 call	 _Py_PXCTX
  00547	85 c0		 test	 eax, eax
  00549	75 5c		 jne	 SHORT $LN25@PyUnicode_@79
  0054b	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  0054f	a8 20		 test	 al, 32			; 00000020H
  00551	75 4c		 jne	 SHORT $LN140@PyUnicode_@79
  00553	84 c0		 test	 al, al
  00555	78 48		 js	 SHORT $LN140@PyUnicode_@79
  00557	a8 02		 test	 al, 2
  00559	75 4c		 jne	 SHORT $LN25@PyUnicode_@79
  0055b	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  0055f	75 46		 jne	 SHORT $LN25@PyUnicode_@79
  00561	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00568	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0056f	4c 8b ce	 mov	 r9, rsi
  00572	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00578	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00580	e8 00 00 00 00	 call	 _PyParallel_Guard
  00585	48 8b ce	 mov	 rcx, rsi
  00588	85 c0		 test	 eax, eax
  0058a	74 07		 je	 SHORT $LN145@PyUnicode_@79
  0058c	e8 00 00 00 00	 call	 _Px_Dealloc
  00591	eb 14		 jmp	 SHORT $LN25@PyUnicode_@79
$LN145@PyUnicode_@79:
  00593	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00597	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0059d	eb 08		 jmp	 SHORT $LN25@PyUnicode_@79
$LN140@PyUnicode_@79:
  0059f	48 8b ce	 mov	 rcx, rsi
  005a2	e8 00 00 00 00	 call	 Px_DecRef
$LN25@PyUnicode_@79:

; 7686 :             startinpos = s-starts;

  005a7	48 2b 5d f7	 sub	 rbx, QWORD PTR starts$[rbp-121]

; 7687 :             endinpos = startinpos+1;
; 7688 :             if (unicode_decode_call_errorhandler(
; 7689 :                     errors, &errorHandler,
; 7690 :                     "charmap", "character maps to <undefined>",
; 7691 :                     &starts, &e, &startinpos, &endinpos, &exc, &s,
; 7692 :                     &v, &outpos)) {

  005ab	48 8b 4d 7f	 mov	 rcx, QWORD PTR errors$[rbp-121]
  005af	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0BO@BLGNENDK@character?5maps?5to?5?$DMundefined?$DO?$AA@
  005b6	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
  005ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07JDDMBNCD@charmap?$AA@
  005c1	48 8d 55 07	 lea	 rdx, QWORD PTR errorHandler$[rbp-121]
  005c5	48 89 45 17	 mov	 QWORD PTR endinpos$[rbp-121], rax
  005c9	48 8d 45 ef	 lea	 rax, QWORD PTR outpos$[rbp-121]
  005cd	48 89 5d 1f	 mov	 QWORD PTR startinpos$[rbp-121], rbx
  005d1	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  005d6	48 8d 45 e7	 lea	 rax, QWORD PTR v$[rbp-121]
  005da	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  005df	48 8d 45 67	 lea	 rax, QWORD PTR s$[rbp-121]
  005e3	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  005e8	48 8d 45 0f	 lea	 rax, QWORD PTR exc$[rbp-121]
  005ec	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  005f1	48 8d 45 17	 lea	 rax, QWORD PTR endinpos$[rbp-121]
  005f5	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  005fa	48 8d 45 1f	 lea	 rax, QWORD PTR startinpos$[rbp-121]
  005fe	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00603	48 8d 45 ff	 lea	 rax, QWORD PTR e$[rbp-121]
  00607	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0060c	48 8d 45 f7	 lea	 rax, QWORD PTR starts$[rbp-121]
  00610	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00615	e8 00 00 00 00	 call	 unicode_decode_call_errorhandler

; 7693 :                 goto onError;
; 7694 :             }
; 7695 :         }

  0061a	4c 8b 65 e7	 mov	 r12, QWORD PTR v$[rbp-121]
  0061e	85 c0		 test	 eax, eax
  00620	75 78		 jne	 SHORT $onError$133500
  00622	48 8b 5d 67	 mov	 rbx, QWORD PTR s$[rbp-121]
  00626	48 8b 7d ef	 mov	 rdi, QWORD PTR outpos$[rbp-121]
  0062a	4c 8b 75 ff	 mov	 r14, QWORD PTR e$[rbp-121]
$LN166@PyUnicode_@79:

; 7587 :         }
; 7588 :     }
; 7589 :     else {
; 7590 :         while (s < e) {

  0062e	49 3b de	 cmp	 rbx, r14
  00631	73 53		 jae	 SHORT $LN49@PyUnicode_@79
  00633	48 8b 75 77	 mov	 rsi, QWORD PTR mapping$[rbp-121]
  00637	e9 b7 fc ff ff	 jmp	 $LL50@PyUnicode_@79
$LN159@PyUnicode_@79:

; 7624 :                     Py_DECREF(x);

  0063c	48 8b ce	 mov	 rcx, rsi
  0063f	e8 00 00 00 00	 call	 _Py_DecRef

; 7625 :                     goto onError;

  00644	eb 50		 jmp	 SHORT $LN183@PyUnicode_@79
$LN40@PyUnicode_@79:

; 7617 :                     PyErr_Format(PyExc_TypeError,
; 7618 :                                  "character mapping must be in range(0x%lx)",
; 7619 :                                  (unsigned long)MAX_UNICODE + 1);

  00646	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0064d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@CGOMCDAP@character?5mapping?5must?5be?5in?5ran@
  00654	41 b8 00 00 11
	00		 mov	 r8d, 1114112		; 00110000H
  0065a	e8 00 00 00 00	 call	 PyErr_Format
$LN160@PyUnicode_@79:

; 7620 :                     Py_DECREF(x);

  0065f	48 8b ce	 mov	 rcx, rsi
  00662	e8 00 00 00 00	 call	 _Py_DecRef

; 7621 :                     goto onError;

  00667	eb 31		 jmp	 SHORT $onError$133500
$LN37@PyUnicode_@79:

; 7670 :                 }
; 7671 :                 /* 1-0 mapping: skip the character */
; 7672 :             }
; 7673 :             else {
; 7674 :                 /* wrong return value */
; 7675 :                 PyErr_SetString(PyExc_TypeError,
; 7676 :                                 "character mapping must return integer, None or str");

  00669	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00670	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@HGMALEBD@character?5mapping?5must?5return?5in@
  00677	e8 00 00 00 00	 call	 PyErr_SetString

; 7677 :                 Py_DECREF(x);

  0067c	48 8b ce	 mov	 rcx, rsi
  0067f	e8 00 00 00 00	 call	 _Py_DecRef

; 7678 :                 goto onError;

  00684	eb 14		 jmp	 SHORT $onError$133500
$LN49@PyUnicode_@79:

; 7696 :     }
; 7697 :     if (unicode_resize(&v, outpos) < 0)

  00686	48 8d 4d e7	 lea	 rcx, QWORD PTR v$[rbp-121]
  0068a	48 8b d7	 mov	 rdx, rdi
  0068d	e8 00 00 00 00	 call	 unicode_resize
  00692	85 c0		 test	 eax, eax
  00694	79 5c		 jns	 SHORT $LN20@PyUnicode_@79
$LN183@PyUnicode_@79:

; 7678 :                 goto onError;

  00696	4c 8b 65 e7	 mov	 r12, QWORD PTR v$[rbp-121]
$onError$133500:

; 7702 : 
; 7703 :   onError:
; 7704 :     Py_XDECREF(errorHandler);

  0069a	48 8b 4d 07	 mov	 rcx, QWORD PTR errorHandler$[rbp-121]
  0069e	48 85 c9	 test	 rcx, rcx
  006a1	74 05		 je	 SHORT $LN11@PyUnicode_@79
  006a3	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@PyUnicode_@79:

; 7705 :     Py_XDECREF(exc);

  006a8	48 8b 4d 0f	 mov	 rcx, QWORD PTR exc$[rbp-121]
  006ac	48 85 c9	 test	 rcx, rcx
  006af	74 05		 je	 SHORT $LN7@PyUnicode_@79
  006b1	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@PyUnicode_@79:

; 7706 :     Py_XDECREF(v);

  006b6	4d 85 e4	 test	 r12, r12
  006b9	74 08		 je	 SHORT $LN3@PyUnicode_@79
  006bb	49 8b cc	 mov	 rcx, r12
  006be	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyUnicode_@79:

; 7707 :     return NULL;

  006c3	33 c0		 xor	 eax, eax
$LN200@PyUnicode_@79:
  006c5	4c 8b ac 24 a8
	00 00 00	 mov	 r13, QWORD PTR [rsp+168]
  006cd	4c 8b a4 24 b0
	00 00 00	 mov	 r12, QWORD PTR [rsp+176]
  006d5	48 8b bc 24 e8
	00 00 00	 mov	 rdi, QWORD PTR [rsp+232]
  006dd	4c 8b b4 24 a0
	00 00 00	 mov	 r14, QWORD PTR [rsp+160]

; 7708 : }

  006e5	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  006ec	41 5f		 pop	 r15
  006ee	5e		 pop	 rsi
  006ef	5b		 pop	 rbx
  006f0	5d		 pop	 rbp
  006f1	c3		 ret	 0
$LN20@PyUnicode_@79:

; 7698 :         goto onError;
; 7699 :     Py_XDECREF(errorHandler);

  006f2	48 8b 4d 07	 mov	 rcx, QWORD PTR errorHandler$[rbp-121]
  006f6	48 85 c9	 test	 rcx, rcx
  006f9	74 05		 je	 SHORT $LN19@PyUnicode_@79
  006fb	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@PyUnicode_@79:

; 7700 :     Py_XDECREF(exc);

  00700	48 8b 4d 0f	 mov	 rcx, QWORD PTR exc$[rbp-121]
  00704	48 85 c9	 test	 rcx, rcx
  00707	74 05		 je	 SHORT $LN15@PyUnicode_@79
  00709	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@PyUnicode_@79:

; 7701 :     return unicode_result(v);

  0070e	48 8b 4d e7	 mov	 rcx, QWORD PTR v$[rbp-121]
  00712	e8 00 00 00 00	 call	 unicode_result
  00717	eb ac		 jmp	 SHORT $LN200@PyUnicode_@79
PyUnicode_DecodeCharmap ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_EncodeCharmap
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_EncodeCharmap DD imagerel $LN4
	DD	imagerel $LN4+94
	DD	imagerel $unwind$PyUnicode_EncodeCharmap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_EncodeCharmap DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_EncodeCharmap
_TEXT	SEGMENT
p$ = 48
size$ = 56
mapping$ = 64
errors$ = 72
PyUnicode_EncodeCharmap PROC				; COMDAT

; 8278 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b d9	 mov	 rbx, r9
  00012	49 8b f0	 mov	 rsi, r8

; 8279 :     PyObject *result;
; 8280 :     PyObject *unicode = PyUnicode_FromUnicode(p, size);

  00015	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  0001a	48 8b f8	 mov	 rdi, rax

; 8281 :     if (unicode == NULL)

  0001d	48 85 c0	 test	 rax, rax
  00020	75 10		 jne	 SHORT $LN1@PyUnicode_@80

; 8285 :     return result;
; 8286 : }

  00022	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00027	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN1@PyUnicode_@80:

; 8282 :         return NULL;
; 8283 :     result = _PyUnicode_EncodeCharmap(unicode, mapping, errors);

  00032	4c 8b c3	 mov	 r8, rbx
  00035	48 8b d6	 mov	 rdx, rsi
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 _PyUnicode_EncodeCharmap

; 8284 :     Py_DECREF(unicode);

  00040	48 8b cf	 mov	 rcx, rdi
  00043	48 8b d8	 mov	 rbx, rax
  00046	e8 00 00 00 00	 call	 _Py_DecRef

; 8285 :     return result;
; 8286 : }

  0004b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00050	48 8b c3	 mov	 rax, rbx
  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
PyUnicode_EncodeCharmap ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_TranslateCharmap
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_TranslateCharmap DD imagerel $LN4
	DD	imagerel $LN4+94
	DD	imagerel $unwind$PyUnicode_TranslateCharmap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_TranslateCharmap DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_TranslateCharmap
_TEXT	SEGMENT
p$ = 48
size$ = 56
mapping$ = 64
errors$ = 72
PyUnicode_TranslateCharmap PROC				; COMDAT

; 8681 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b d9	 mov	 rbx, r9
  00012	49 8b f0	 mov	 rsi, r8

; 8682 :     PyObject *result;
; 8683 :     PyObject *unicode = PyUnicode_FromUnicode(p, size);

  00015	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  0001a	48 8b f8	 mov	 rdi, rax

; 8684 :     if (!unicode)

  0001d	48 85 c0	 test	 rax, rax
  00020	75 10		 jne	 SHORT $LN1@PyUnicode_@81

; 8688 :     return result;
; 8689 : }

  00022	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00027	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN1@PyUnicode_@81:

; 8685 :         return NULL;
; 8686 :     result = _PyUnicode_TranslateCharmap(unicode, mapping, errors);

  00032	4c 8b c3	 mov	 r8, rbx
  00035	48 8b d6	 mov	 rdx, rsi
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 _PyUnicode_TranslateCharmap

; 8687 :     Py_DECREF(unicode);

  00040	48 8b cf	 mov	 rcx, rdi
  00043	48 8b d8	 mov	 rbx, rax
  00046	e8 00 00 00 00	 call	 _Py_DecRef

; 8688 :     return result;
; 8689 : }

  0004b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00050	48 8b c3	 mov	 rax, rbx
  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
PyUnicode_TranslateCharmap ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_TransformDecimalAndSpaceToASCII
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_TransformDecimalAndSpaceToASCII DD imagerel $LN14
	DD	imagerel $LN14+143
	DD	imagerel $unwind$_PyUnicode_TransformDecimalAndSpaceToASCII
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_TransformDecimalAndSpaceToASCII DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_TransformDecimalAndSpaceToASCII
_TEXT	SEGMENT
unicode$ = 48
_PyUnicode_TransformDecimalAndSpaceToASCII PROC		; COMDAT

; 8744 : {

$LN14:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 8745 :     if (!PyUnicode_Check(unicode)) {

  00006	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00017	75 19		 jne	 SHORT $LN3@PyUnicode_@82

; 8746 :         PyErr_BadInternalCall();

  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00020	ba 2a 22 00 00	 mov	 edx, 8746		; 0000222aH
  00025	e8 00 00 00 00	 call	 _PyErr_BadInternalCall
$LN13@PyUnicode_@82:

; 8747 :         return NULL;

  0002a	33 c0		 xor	 eax, eax

; 8757 : }

  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5b		 pop	 rbx
  00031	c3		 ret	 0
$LN3@PyUnicode_@82:

; 8748 :     }
; 8749 :     if (PyUnicode_READY(unicode) == -1)

  00032	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00036	75 0a		 jne	 SHORT $LN2@PyUnicode_@82
  00038	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0003d	83 f8 ff	 cmp	 eax, -1

; 8750 :         return NULL;

  00040	74 e8		 je	 SHORT $LN13@PyUnicode_@82
$LN2@PyUnicode_@82:

; 8751 :     if (PyUnicode_MAX_CHAR_VALUE(unicode) <= 127) {

  00042	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00045	f6 c1 40	 test	 cl, 64			; 00000040H
  00048	75 34		 jne	 SHORT $LN12@PyUnicode_@82
  0004a	c1 e9 02	 shr	 ecx, 2
  0004d	83 e1 07	 and	 ecx, 7
  00050	83 f9 01	 cmp	 ecx, 1
  00053	74 15		 je	 SHORT $LN1@PyUnicode_@82
  00055	83 f9 02	 cmp	 ecx, 2
  00058	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH
  0005d	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00062	0f 44 c2	 cmove	 eax, edx
  00065	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00068	76 14		 jbe	 SHORT $LN12@PyUnicode_@82
$LN1@PyUnicode_@82:

; 8755 :     }
; 8756 :     return fixup(unicode, fix_decimal_and_space_to_ascii);

  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fix_decimal_and_space_to_ascii
  00071	48 8b cb	 mov	 rcx, rbx

; 8757 : }

  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5b		 pop	 rbx
  00079	e9 00 00 00 00	 jmp	 fixup
$LN12@PyUnicode_@82:

; 8752 :         /* If the string is already ASCII, just return the same string */
; 8753 :         Py_INCREF(unicode);

  0007e	48 8b cb	 mov	 rcx, rbx
  00081	e8 00 00 00 00	 call	 _Py_IncRef

; 8754 :         return unicode;

  00086	48 8b c3	 mov	 rax, rbx

; 8757 : }

  00089	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008d	5b		 pop	 rbx
  0008e	c3		 ret	 0
_PyUnicode_TransformDecimalAndSpaceToASCII ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_TransformDecimalToASCII
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_TransformDecimalToASCII DD imagerel $LN32
	DD	imagerel $LN32+115
	DD	imagerel $unwind$PyUnicode_TransformDecimalToASCII
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyUnicode_TransformDecimalToASCII DD imagerel $LN32+115
	DD	imagerel $LN32+255
	DD	imagerel $chain$0$PyUnicode_TransformDecimalToASCII
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyUnicode_TransformDecimalToASCII DD imagerel $LN32+255
	DD	imagerel $LN32+278
	DD	imagerel $chain$1$PyUnicode_TransformDecimalToASCII
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyUnicode_TransformDecimalToASCII DD 021H
	DD	imagerel $LN32
	DD	imagerel $LN32+115
	DD	imagerel $unwind$PyUnicode_TransformDecimalToASCII
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyUnicode_TransformDecimalToASCII DD 020521H
	DD	0ae405H
	DD	imagerel $LN32
	DD	imagerel $LN32+115
	DD	imagerel $unwind$PyUnicode_TransformDecimalToASCII
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_TransformDecimalToASCII DD 0a1601H
	DD	0c5416H
	DD	0b3416H
	DD	0f0123216H
	DD	0c00ed010H
	DD	0600b700cH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_TransformDecimalToASCII
_TEXT	SEGMENT
s$ = 80
length$ = 88
PyUnicode_TransformDecimalToASCII PROC			; COMDAT

; 8762 : {

$LN32:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 57		 push	 r15
  00012	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 8763 :     PyObject *decimal;
; 8764 :     Py_ssize_t i;
; 8765 :     Py_UCS4 maxchar;
; 8766 :     enum PyUnicode_Kind kind;
; 8767 :     void *data;
; 8768 : 
; 8769 :     maxchar = 127;
; 8770 :     for (i = 0; i < length; i++) {

  00016	33 f6		 xor	 esi, esi
  00018	4c 8b e2	 mov	 r12, rdx
  0001b	4c 8b f9	 mov	 r15, rcx
  0001e	bd 7f 00 00 00	 mov	 ebp, 127		; 0000007fH
  00023	8b fe		 mov	 edi, esi
  00025	48 85 d2	 test	 rdx, rdx
  00028	7e 30		 jle	 SHORT $LN17@PyUnicode_@83
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL19@PyUnicode_@83:

; 8771 :         Py_UNICODE ch = s[i];

  00030	41 0f b7 1c 7f	 movzx	 ebx, WORD PTR [r15+rdi*2]

; 8772 :         if (ch > 127) {

  00035	66 83 fb 7f	 cmp	 bx, 127			; 0000007fH
  00039	76 17		 jbe	 SHORT $LN18@PyUnicode_@83

; 8773 :             int decimal = Py_UNICODE_TODECIMAL(ch);

  0003b	0f b7 cb	 movzx	 ecx, bx
  0003e	e8 00 00 00 00	 call	 _PyUnicode_ToDecimalDigit

; 8774 :             if (decimal >= 0)

  00043	85 c0		 test	 eax, eax
  00045	78 03		 js	 SHORT $LN15@PyUnicode_@83

; 8775 :                 ch = '0' + decimal;

  00047	8d 58 30	 lea	 ebx, DWORD PTR [rax+48]
$LN15@PyUnicode_@83:

; 8776 :             maxchar = Py_MAX(maxchar, ch);

  0004a	0f b7 c3	 movzx	 eax, bx
  0004d	3b e8		 cmp	 ebp, eax
  0004f	0f 46 e8	 cmovbe	 ebp, eax
$LN18@PyUnicode_@83:

; 8763 :     PyObject *decimal;
; 8764 :     Py_ssize_t i;
; 8765 :     Py_UCS4 maxchar;
; 8766 :     enum PyUnicode_Kind kind;
; 8767 :     void *data;
; 8768 : 
; 8769 :     maxchar = 127;
; 8770 :     for (i = 0; i < length; i++) {

  00052	48 ff c7	 inc	 rdi
  00055	49 3b fc	 cmp	 rdi, r12
  00058	7c d6		 jl	 SHORT $LL19@PyUnicode_@83
$LN17@PyUnicode_@83:

; 8777 :         }
; 8778 :     }
; 8779 : 
; 8780 :     /* Copy to a new string */
; 8781 :     decimal = PyUnicode_New(length, maxchar);

  0005a	8b d5		 mov	 edx, ebp
  0005c	49 8b cc	 mov	 rcx, r12
  0005f	e8 00 00 00 00	 call	 PyUnicode_New
  00064	4c 8b e8	 mov	 r13, rax

; 8782 :     if (decimal == NULL)

  00067	48 85 c0	 test	 rax, rax
  0006a	0f 84 8f 00 00
	00		 je	 $LN20@PyUnicode_@83
$LN14@PyUnicode_@83:

; 8783 :         return decimal;
; 8784 :     kind = PyUnicode_KIND(decimal);

  00070	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00073	4c 89 74 24 50	 mov	 QWORD PTR [rsp+80], r14
  00078	44 8b f0	 mov	 r14d, eax
  0007b	41 c1 ee 02	 shr	 r14d, 2
  0007f	41 83 e6 07	 and	 r14d, 7

; 8785 :     data = PyUnicode_DATA(decimal);

  00083	a8 20		 test	 al, 32			; 00000020H
  00085	74 16		 je	 SHORT $LN26@PyUnicode_@83
  00087	a8 40		 test	 al, 64			; 00000040H
  00089	74 09		 je	 SHORT $LN24@PyUnicode_@83
  0008b	49 8d ad 80 00
	00 00		 lea	 rbp, QWORD PTR [r13+128]
  00092	eb 10		 jmp	 SHORT $LN27@PyUnicode_@83
$LN24@PyUnicode_@83:
  00094	49 8d ad a0 00
	00 00		 lea	 rbp, QWORD PTR [r13+160]
  0009b	eb 07		 jmp	 SHORT $LN27@PyUnicode_@83
$LN26@PyUnicode_@83:
  0009d	49 8b ad a0 00
	00 00		 mov	 rbp, QWORD PTR [r13+160]
$LN27@PyUnicode_@83:

; 8786 :     /* Iterate over code points */
; 8787 :     for (i = 0; i < length; i++) {

  000a4	4d 85 e4	 test	 r12, r12
  000a7	7e 49		 jle	 SHORT $LN11@PyUnicode_@83
  000a9	48 8b fd	 mov	 rdi, rbp
  000ac	4c 2b fd	 sub	 r15, rbp
  000af	90		 npad	 1
$LL13@PyUnicode_@83:

; 8788 :         Py_UNICODE ch = s[i];

  000b0	41 0f b7 1c 3f	 movzx	 ebx, WORD PTR [r15+rdi]

; 8789 :         if (ch > 127) {

  000b5	66 83 fb 7f	 cmp	 bx, 127			; 0000007fH
  000b9	76 0f		 jbe	 SHORT $LN8@PyUnicode_@83

; 8790 :             int decimal = Py_UNICODE_TODECIMAL(ch);

  000bb	0f b7 cb	 movzx	 ecx, bx
  000be	e8 00 00 00 00	 call	 _PyUnicode_ToDecimalDigit

; 8791 :             if (decimal >= 0)

  000c3	85 c0		 test	 eax, eax
  000c5	78 03		 js	 SHORT $LN8@PyUnicode_@83

; 8792 :                 ch = '0' + decimal;

  000c7	8d 58 30	 lea	 ebx, DWORD PTR [rax+48]
$LN8@PyUnicode_@83:

; 8793 :         }
; 8794 :         PyUnicode_WRITE(kind, data, i, ch);

  000ca	41 8b ce	 mov	 ecx, r14d
  000cd	ff c9		 dec	 ecx
  000cf	74 12		 je	 SHORT $LN3@PyUnicode_@83
  000d1	ff c9		 dec	 ecx
  000d3	74 09		 je	 SHORT $LN2@PyUnicode_@83
  000d5	0f b7 c3	 movzx	 eax, bx
  000d8	89 44 b5 00	 mov	 DWORD PTR [rbp+rsi*4], eax
  000dc	eb 08		 jmp	 SHORT $LN7@PyUnicode_@83
$LN2@PyUnicode_@83:
  000de	66 89 1f	 mov	 WORD PTR [rdi], bx
  000e1	eb 03		 jmp	 SHORT $LN7@PyUnicode_@83
$LN3@PyUnicode_@83:
  000e3	88 1c 2e	 mov	 BYTE PTR [rsi+rbp], bl
$LN7@PyUnicode_@83:

; 8786 :     /* Iterate over code points */
; 8787 :     for (i = 0; i < length; i++) {

  000e6	48 ff c6	 inc	 rsi
  000e9	48 83 c7 02	 add	 rdi, 2
  000ed	49 3b f4	 cmp	 rsi, r12
  000f0	7c be		 jl	 SHORT $LL13@PyUnicode_@83
$LN11@PyUnicode_@83:

; 8795 :     }
; 8796 :     return unicode_result(decimal);

  000f2	49 8b cd	 mov	 rcx, r13
  000f5	e8 00 00 00 00	 call	 unicode_result
  000fa	4c 8b 74 24 50	 mov	 r14, QWORD PTR [rsp+80]
$LN20@PyUnicode_@83:

; 8797 : }

  000ff	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00104	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00109	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010d	41 5f		 pop	 r15
  0010f	41 5d		 pop	 r13
  00111	41 5c		 pop	 r12
  00113	5f		 pop	 rdi
  00114	5e		 pop	 rsi
  00115	c3		 ret	 0
PyUnicode_TransformDecimalToASCII ENDP
_TEXT	ENDS
PUBLIC	??_C@_07EEKBCPDP@decimal?$AA@			; `string'
PUBLIC	??_C@_0BP@FEDCDGAP@invalid?5decimal?5Unicode?5string?$AA@ ; `string'
PUBLIC	PyUnicode_EncodeDecimal
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_EncodeDecimal DD imagerel $LN39
	DD	imagerel $LN39+35
	DD	imagerel $unwind$PyUnicode_EncodeDecimal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyUnicode_EncodeDecimal DD imagerel $LN39+35
	DD	imagerel $LN39+96
	DD	imagerel $chain$0$PyUnicode_EncodeDecimal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$PyUnicode_EncodeDecimal DD imagerel $LN39+96
	DD	imagerel $LN39+337
	DD	imagerel $chain$7$PyUnicode_EncodeDecimal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$PyUnicode_EncodeDecimal DD imagerel $LN39+337
	DD	imagerel $LN39+418
	DD	imagerel $chain$9$PyUnicode_EncodeDecimal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$PyUnicode_EncodeDecimal DD 0c0021H
	DD	06f400H
	DD	07d400H
	DD	08c400H
	DD	0f7400H
	DD	0d5400H
	DD	0c3400H
	DD	imagerel $LN39
	DD	imagerel $LN39+35
	DD	imagerel $unwind$PyUnicode_EncodeDecimal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$PyUnicode_EncodeDecimal DD 0c4a21H
	DD	06f44aH
	DD	0f7442H
	DD	07d414H
	DD	08c40dH
	DD	0c3408H
	DD	0d5400H
	DD	imagerel $LN39
	DD	imagerel $LN39+35
	DD	imagerel $unwind$PyUnicode_EncodeDecimal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyUnicode_EncodeDecimal DD 020521H
	DD	0d5405H
	DD	imagerel $LN39
	DD	imagerel $LN39+35
	DD	imagerel $unwind$PyUnicode_EncodeDecimal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_EncodeDecimal DD 030801H
	DD	0e0048208H
	DD	06002H
xdata	ENDS
;	COMDAT ??_C@_07EEKBCPDP@decimal?$AA@
CONST	SEGMENT
??_C@_07EEKBCPDP@decimal?$AA@ DB 'decimal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FEDCDGAP@invalid?5decimal?5Unicode?5string?$AA@
CONST	SEGMENT
??_C@_0BP@FEDCDGAP@invalid?5decimal?5Unicode?5string?$AA@ DB 'invalid dec'
	DB	'imal Unicode string', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_EncodeDecimal
_TEXT	SEGMENT
s$ = 96
length$ = 104
exc$135223 = 112
output$ = 112
errors$ = 120
PyUnicode_EncodeDecimal PROC				; COMDAT

; 8805 : {

$LN39:
  00000	40 56		 push	 rsi
  00002	41 56		 push	 r14
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00008	49 8b f0	 mov	 rsi, r8
  0000b	4c 8b f2	 mov	 r14, rdx

; 8806 :     PyObject *unicode;
; 8807 :     Py_ssize_t i;
; 8808 :     enum PyUnicode_Kind kind;
; 8809 :     void *data;
; 8810 : 
; 8811 :     if (output == NULL) {

  0000e	4d 85 c0	 test	 r8, r8
  00011	75 10		 jne	 SHORT $LN12@PyUnicode_@84

; 8812 :         PyErr_BadArgument();

  00013	e8 00 00 00 00	 call	 PyErr_BadArgument

; 8813 :         return -1;

  00018	83 c8 ff	 or	 eax, -1

; 8865 : }

  0001b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0001f	41 5e		 pop	 r14
  00021	5e		 pop	 rsi
  00022	c3		 ret	 0
$LN12@PyUnicode_@84:
  00023	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp

; 8814 :     }
; 8815 : 
; 8816 :     unicode = PyUnicode_FromUnicode(s, length);

  00028	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  0002d	48 8b e8	 mov	 rbp, rax

; 8817 :     if (unicode == NULL)

  00030	48 85 c0	 test	 rax, rax

; 8818 :         return -1;

  00033	74 1b		 je	 SHORT $LN38@PyUnicode_@84

; 8819 : 
; 8820 :     if (PyUnicode_READY(unicode) == -1) {

  00035	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  00039	75 25		 jne	 SHORT $LN10@PyUnicode_@84
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00043	83 f8 ff	 cmp	 eax, -1
  00046	75 18		 jne	 SHORT $LN10@PyUnicode_@84

; 8821 :         Py_DECREF(unicode);

  00048	48 8b cd	 mov	 rcx, rbp
  0004b	e8 00 00 00 00	 call	 _Py_DecRef
$LN38@PyUnicode_@84:

; 8822 :         return -1;

  00050	83 c8 ff	 or	 eax, -1
  00053	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]

; 8865 : }

  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	41 5e		 pop	 r14
  0005e	5e		 pop	 rsi
  0005f	c3		 ret	 0
$LN10@PyUnicode_@84:

; 8823 :     }
; 8824 :     kind = PyUnicode_KIND(unicode);

  00060	8b 45 70	 mov	 eax, DWORD PTR [rbp+112]
  00063	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00068	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12
  0006d	8b c8		 mov	 ecx, eax
  0006f	4c 89 6c 24 38	 mov	 QWORD PTR [rsp+56], r13
  00074	c1 e9 02	 shr	 ecx, 2
  00077	83 e1 07	 and	 ecx, 7

; 8825 :     data = PyUnicode_DATA(unicode);

  0007a	a8 20		 test	 al, 32			; 00000020H
  0007c	74 16		 je	 SHORT $LN19@PyUnicode_@84
  0007e	a8 40		 test	 al, 64			; 00000040H
  00080	74 09		 je	 SHORT $LN17@PyUnicode_@84
  00082	4c 8d a5 80 00
	00 00		 lea	 r12, QWORD PTR [rbp+128]
  00089	eb 10		 jmp	 SHORT $LN20@PyUnicode_@84
$LN17@PyUnicode_@84:
  0008b	4c 8d a5 a0 00
	00 00		 lea	 r12, QWORD PTR [rbp+160]
  00092	eb 07		 jmp	 SHORT $LN20@PyUnicode_@84
$LN19@PyUnicode_@84:
  00094	4c 8b a5 a0 00
	00 00		 mov	 r12, QWORD PTR [rbp+160]
$LN20@PyUnicode_@84:

; 8826 : 
; 8827 :     for (i=0; i < length; ) {

  0009b	33 db		 xor	 ebx, ebx
  0009d	48 89 7c 24 78	 mov	 QWORD PTR [rsp+120], rdi

; 8828 :         PyObject *exc;
; 8829 :         Py_UCS4 ch;
; 8830 :         int decimal;
; 8831 :         Py_ssize_t startpos;
; 8832 : 
; 8833 :         ch = PyUnicode_READ(kind, data, i);

  000a2	4c 63 e9	 movsxd	 r13, ecx
  000a5	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  000aa	4d 85 f6	 test	 r14, r14
  000ad	7e 6f		 jle	 SHORT $LN8@PyUnicode_@84

; 8826 : 
; 8827 :     for (i=0; i < length; ) {

  000af	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:_Py_ascii_whitespace
$LL9@PyUnicode_@84:

; 8828 :         PyObject *exc;
; 8829 :         Py_UCS4 ch;
; 8830 :         int decimal;
; 8831 :         Py_ssize_t startpos;
; 8832 : 
; 8833 :         ch = PyUnicode_READ(kind, data, i);

  000b6	49 83 fd 01	 cmp	 r13, 1
  000ba	75 07		 jne	 SHORT $LN23@PyUnicode_@84
  000bc	42 0f b6 3c 23	 movzx	 edi, BYTE PTR [rbx+r12]
  000c1	eb 11		 jmp	 SHORT $LN22@PyUnicode_@84
$LN23@PyUnicode_@84:
  000c3	49 83 fd 02	 cmp	 r13, 2
  000c7	75 07		 jne	 SHORT $LN21@PyUnicode_@84
  000c9	41 0f b7 3c 5c	 movzx	 edi, WORD PTR [r12+rbx*2]
  000ce	eb 04		 jmp	 SHORT $LN22@PyUnicode_@84
$LN21@PyUnicode_@84:
  000d0	41 8b 3c 9c	 mov	 edi, DWORD PTR [r12+rbx*4]
$LN22@PyUnicode_@84:

; 8834 : 
; 8835 :         if (Py_UNICODE_ISSPACE(ch)) {

  000d4	81 ff 80 00 00
	00		 cmp	 edi, 128		; 00000080H
  000da	73 09		 jae	 SHORT $LN25@PyUnicode_@84
  000dc	8b c7		 mov	 eax, edi
  000de	42 0f b6 04 38	 movzx	 eax, BYTE PTR [rax+r15]
  000e3	eb 07		 jmp	 SHORT $LN26@PyUnicode_@84
$LN25@PyUnicode_@84:
  000e5	8b cf		 mov	 ecx, edi
  000e7	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
$LN26@PyUnicode_@84:
  000ec	85 c0		 test	 eax, eax
  000ee	74 05		 je	 SHORT $LN7@PyUnicode_@84

; 8836 :             *output++ = ' ';

  000f0	c6 06 20	 mov	 BYTE PTR [rsi], 32	; 00000020H

; 8837 :             i++;
; 8838 :             continue;

  000f3	eb 1e		 jmp	 SHORT $LN37@PyUnicode_@84
$LN7@PyUnicode_@84:

; 8839 :         }
; 8840 :         decimal = Py_UNICODE_TODECIMAL(ch);

  000f5	8b cf		 mov	 ecx, edi
  000f7	e8 00 00 00 00	 call	 _PyUnicode_ToDecimalDigit

; 8841 :         if (decimal >= 0) {

  000fc	85 c0		 test	 eax, eax
  000fe	78 06		 js	 SHORT $LN6@PyUnicode_@84

; 8842 :             *output++ = '0' + decimal;

  00100	04 30		 add	 al, 48			; 00000030H
  00102	88 06		 mov	 BYTE PTR [rsi], al

; 8843 :             i++;
; 8844 :             continue;

  00104	eb 0d		 jmp	 SHORT $LN37@PyUnicode_@84
$LN6@PyUnicode_@84:

; 8845 :         }
; 8846 :         if (0 < ch && ch < 256) {

  00106	8d 47 ff	 lea	 eax, DWORD PTR [rdi-1]
  00109	3d fe 00 00 00	 cmp	 eax, 254		; 000000feH
  0010e	77 41		 ja	 SHORT $LN5@PyUnicode_@84

; 8847 :             *output++ = (char)ch;

  00110	40 88 3e	 mov	 BYTE PTR [rsi], dil
$LN37@PyUnicode_@84:

; 8848 :             i++;

  00113	48 ff c3	 inc	 rbx
  00116	48 ff c6	 inc	 rsi
  00119	49 3b de	 cmp	 rbx, r14
  0011c	7c 98		 jl	 SHORT $LL9@PyUnicode_@84
$LN8@PyUnicode_@84:

; 8860 :     }
; 8861 :     /* 0-terminate the output string */
; 8862 :     *output++ = '\0';
; 8863 :     Py_DECREF(unicode);

  0011e	48 8b cd	 mov	 rcx, rbp
  00121	c6 06 00	 mov	 BYTE PTR [rsi], 0
  00124	e8 00 00 00 00	 call	 _Py_DecRef

; 8864 :     return 0;

  00129	33 c0		 xor	 eax, eax
$LN36@PyUnicode_@84:
  0012b	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]
  00130	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]
  00135	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]
  0013a	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0013f	4c 8b 6c 24 38	 mov	 r13, QWORD PTR [rsp+56]
  00144	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]

; 8865 : }

  00149	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0014d	41 5e		 pop	 r14
  0014f	5e		 pop	 rsi
  00150	c3		 ret	 0
$LN5@PyUnicode_@84:

; 8849 :             continue;
; 8850 :         }
; 8851 : 
; 8852 :         startpos = i;
; 8853 :         exc = NULL;
; 8854 :         raise_encode_exception(&exc, "decimal", unicode,
; 8855 :                                startpos, startpos+1,
; 8856 :                                "invalid decimal Unicode string");

  00151	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@FEDCDGAP@invalid?5decimal?5Unicode?5string?$AA@
  00158	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
  0015c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07EEKBCPDP@decimal?$AA@
  00163	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00168	48 8d 4c 24 70	 lea	 rcx, QWORD PTR exc$135223[rsp]
  0016d	4c 8b cb	 mov	 r9, rbx
  00170	4c 8b c5	 mov	 r8, rbp
  00173	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR exc$135223[rsp], 0
  0017c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00181	e8 00 00 00 00	 call	 raise_encode_exception

; 8857 :         Py_XDECREF(exc);

  00186	48 8b 4c 24 70	 mov	 rcx, QWORD PTR exc$135223[rsp]
  0018b	48 85 c9	 test	 rcx, rcx
  0018e	74 05		 je	 SHORT $LN3@PyUnicode_@84
  00190	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyUnicode_@84:

; 8858 :         Py_DECREF(unicode);

  00195	48 8b cd	 mov	 rcx, rbp
  00198	e8 00 00 00 00	 call	 _Py_DecRef

; 8859 :         return -1;

  0019d	83 c8 ff	 or	 eax, -1
  001a0	eb 89		 jmp	 SHORT $LN36@PyUnicode_@84
PyUnicode_EncodeDecimal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DL@DFFBPONN@fill?5character?5is?5bigger?5than?5th@ ; `string'
PUBLIC	PyUnicode_Fill
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_Fill DD imagerel $LN17
	DD	imagerel $LN17+214
	DD	imagerel $unwind$PyUnicode_Fill
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyUnicode_Fill DD imagerel $LN17+214
	DD	imagerel $LN17+267
	DD	imagerel $chain$0$PyUnicode_Fill
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyUnicode_Fill DD imagerel $LN17+267
	DD	imagerel $LN17+289
	DD	imagerel $chain$1$PyUnicode_Fill
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyUnicode_Fill DD 021H
	DD	imagerel $LN17
	DD	imagerel $LN17+214
	DD	imagerel $unwind$PyUnicode_Fill
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyUnicode_Fill DD 020521H
	DD	063405H
	DD	imagerel $LN17
	DD	imagerel $LN17+214
	DD	imagerel $unwind$PyUnicode_Fill
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Fill DD 081501H
	DD	097415H
	DD	086415H
	DD	075415H
	DD	0c0113215H
xdata	ENDS
;	COMDAT ??_C@_0DL@DFFBPONN@fill?5character?5is?5bigger?5than?5th@
CONST	SEGMENT
??_C@_0DL@DFFBPONN@fill?5character?5is?5bigger?5than?5th@ DB 'fill charac'
	DB	'ter is bigger than the string maximum character', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_Fill
_TEXT	SEGMENT
unicode$ = 48
start$ = 56
length$ = 64
fill_char$ = 72
PyUnicode_Fill PROC					; COMDAT

; 9793 : {

$LN17:
  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 9794 :     Py_ssize_t maxlen;
; 9795 : 
; 9796 :     if (!PyUnicode_Check(unicode)) {

  00015	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00019	41 8b e9	 mov	 ebp, r9d
  0001c	4d 8b e0	 mov	 r12, r8
  0001f	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00029	48 8b f2	 mov	 rsi, rdx
  0002c	48 8b f9	 mov	 rdi, rcx
  0002f	75 1a		 jne	 SHORT $LN6@PyUnicode_@85

; 9797 :         PyErr_BadInternalCall();

  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00038	ba 45 26 00 00	 mov	 edx, 9797		; 00002645H
  0003d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall
$LN16@PyUnicode_@85:

; 9798 :         return -1;

  00042	48 83 c8 ff	 or	 rax, -1
  00046	e9 c0 00 00 00	 jmp	 $LN7@PyUnicode_@85
$LN6@PyUnicode_@85:

; 9799 :     }
; 9800 :     if (PyUnicode_READY(unicode) == -1)

  0004b	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0004f	75 0a		 jne	 SHORT $LN5@PyUnicode_@85
  00051	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00056	83 f8 ff	 cmp	 eax, -1

; 9801 :         return -1;

  00059	74 e7		 je	 SHORT $LN16@PyUnicode_@85
$LN5@PyUnicode_@85:

; 9802 :     if (unicode_check_modifiable(unicode))

  0005b	48 8b cf	 mov	 rcx, rdi
  0005e	e8 00 00 00 00	 call	 unicode_check_modifiable
  00063	85 c0		 test	 eax, eax

; 9803 :         return -1;

  00065	75 db		 jne	 SHORT $LN16@PyUnicode_@85

; 9804 : 
; 9805 :     if (start < 0) {

  00067	48 85 f6	 test	 rsi, rsi
  0006a	79 1c		 jns	 SHORT $LN3@PyUnicode_@85

; 9806 :         PyErr_SetString(PyExc_IndexError, "string index out of range");

  0006c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@DOEPEGBG@string?5index?5out?5of?5range?$AA@
  0007a	e8 00 00 00 00	 call	 PyErr_SetString

; 9807 :         return -1;

  0007f	48 83 c8 ff	 or	 rax, -1
  00083	e9 83 00 00 00	 jmp	 $LN7@PyUnicode_@85
$LN3@PyUnicode_@85:

; 9808 :     }
; 9809 :     if (fill_char > PyUnicode_MAX_CHAR_VALUE(unicode)) {

  00088	8b 4f 70	 mov	 ecx, DWORD PTR [rdi+112]
  0008b	f6 c1 40	 test	 cl, 64			; 00000040H
  0008e	74 07		 je	 SHORT $LN13@PyUnicode_@85
  00090	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  00095	eb 22		 jmp	 SHORT $LN12@PyUnicode_@85
$LN13@PyUnicode_@85:
  00097	c1 e9 02	 shr	 ecx, 2
  0009a	83 e1 07	 and	 ecx, 7
  0009d	83 f9 01	 cmp	 ecx, 1
  000a0	75 07		 jne	 SHORT $LN11@PyUnicode_@85
  000a2	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  000a7	eb 10		 jmp	 SHORT $LN12@PyUnicode_@85
$LN11@PyUnicode_@85:
  000a9	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH
  000ae	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  000b3	83 f9 02	 cmp	 ecx, 2
  000b6	0f 44 c2	 cmove	 eax, edx
$LN12@PyUnicode_@85:
  000b9	3b e8		 cmp	 ebp, eax
  000bb	76 19		 jbe	 SHORT $LN2@PyUnicode_@85

; 9810 :         PyErr_SetString(PyExc_ValueError,
; 9811 :                          "fill character is bigger than "
; 9812 :                          "the string maximum character");

  000bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@DFFBPONN@fill?5character?5is?5bigger?5than?5th@
  000cb	e8 00 00 00 00	 call	 PyErr_SetString

; 9813 :         return -1;

  000d0	48 83 c8 ff	 or	 rax, -1
  000d4	eb 35		 jmp	 SHORT $LN7@PyUnicode_@85
$LN2@PyUnicode_@85:
  000d6	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 9814 :     }
; 9815 : 
; 9816 :     maxlen = PyUnicode_GET_LENGTH(unicode) - start;

  000db	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  000df	48 2b de	 sub	 rbx, rsi

; 9817 :     length = Py_MIN(maxlen, length);

  000e2	49 3b dc	 cmp	 rbx, r12
  000e5	49 0f 4f dc	 cmovg	 rbx, r12

; 9818 :     if (length <= 0)

  000e9	48 85 db	 test	 rbx, rbx
  000ec	7f 04		 jg	 SHORT $LN1@PyUnicode_@85

; 9819 :         return 0;

  000ee	33 c0		 xor	 eax, eax
  000f0	eb 14		 jmp	 SHORT $LN15@PyUnicode_@85
$LN1@PyUnicode_@85:

; 9820 : 
; 9821 :     _PyUnicode_FastFill(unicode, start, length, fill_char);

  000f2	44 8b cd	 mov	 r9d, ebp
  000f5	4c 8b c3	 mov	 r8, rbx
  000f8	48 8b d6	 mov	 rdx, rsi
  000fb	48 8b cf	 mov	 rcx, rdi
  000fe	e8 00 00 00 00	 call	 _PyUnicode_FastFill

; 9822 :     return length;

  00103	48 8b c3	 mov	 rax, rbx
$LN15@PyUnicode_@85:
  00106	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN7@PyUnicode_@85:

; 9823 : }

  0010b	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00110	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00115	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0011a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011e	41 5c		 pop	 r12
  00120	c3		 ret	 0
PyUnicode_Fill ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@GHMGEIFA@padded?5string?5is?5too?5long?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pad DD	imagerel pad
	DD	imagerel pad+66
	DD	imagerel $unwind$pad
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$pad DD	imagerel pad+66
	DD	imagerel pad+213
	DD	imagerel $chain$1$pad
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$pad DD	imagerel pad+213
	DD	imagerel pad+216
	DD	imagerel $chain$3$pad
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$pad DD	imagerel pad+216
	DD	imagerel pad+480
	DD	imagerel $chain$5$pad
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$pad DD	imagerel pad+480
	DD	imagerel pad+518
	DD	imagerel $chain$7$pad
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$pad DD	020021H
	DD	0e7400H
	DD	imagerel pad
	DD	imagerel pad+66
	DD	imagerel $unwind$pad
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$pad DD	040a21H
	DD	0d540aH
	DD	0c3405H
	DD	imagerel pad+213
	DD	imagerel pad+216
	DD	imagerel $chain$3$pad
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$pad DD	040021H
	DD	06d400H
	DD	0e7400H
	DD	imagerel pad
	DD	imagerel pad+66
	DD	imagerel $unwind$pad
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$pad DD	043321H
	DD	06d433H
	DD	0e7405H
	DD	imagerel pad
	DD	imagerel pad+66
	DD	imagerel $unwind$pad
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pad DD	050c01H
	DD	0f008620cH
	DD	0c004e006H
	DD	06002H
xdata	ENDS
;	COMDAT ??_C@_0BK@GHMGEIFA@padded?5string?5is?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BK@GHMGEIFA@padded?5string?5is?5too?5long?$AA@ DB 'padded string i'
	DB	's too long', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT pad
_TEXT	SEGMENT
self$ = 96
left$ = 104
right$ = 112
fill$ = 120
pad	PROC						; COMDAT

; 9830 : {

  00000	40 56		 push	 rsi
  00002	41 54		 push	 r12
  00004	41 56		 push	 r14
  00006	41 57		 push	 r15
  00008	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 9831 :     PyObject *u;
; 9832 :     Py_UCS4 maxchar;
; 9833 :     int kind;
; 9834 :     void *data;
; 9835 : 
; 9836 :     if (left < 0)

  0000c	33 c0		 xor	 eax, eax
  0000e	48 85 d2	 test	 rdx, rdx
  00011	48 8b f2	 mov	 rsi, rdx
  00014	48 0f 48 f0	 cmovs	 rsi, rax

; 9837 :         left = 0;
; 9838 :     if (right < 0)

  00018	4d 85 c0	 test	 r8, r8
  0001b	4d 8b e0	 mov	 r12, r8
  0001e	4c 0f 48 e0	 cmovs	 r12, rax
  00022	45 8b f9	 mov	 r15d, r9d
  00025	4c 8b f1	 mov	 r14, rcx

; 9839 :         right = 0;
; 9840 : 
; 9841 :     if (left == 0 && right == 0)

  00028	48 85 f6	 test	 rsi, rsi
  0002b	75 15		 jne	 SHORT $LN36@pad
  0002d	4d 85 e4	 test	 r12, r12
  00030	75 10		 jne	 SHORT $LN36@pad

; 9864 : }

  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	41 5f		 pop	 r15
  00038	41 5e		 pop	 r14
  0003a	41 5c		 pop	 r12
  0003c	5e		 pop	 rsi
  0003d	e9 00 00 00 00	 jmp	 unicode_result_unchanged
$LN36@pad:
  00042	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi

; 9842 :         return unicode_result_unchanged(self);
; 9843 : 
; 9844 :     if (left > PY_SSIZE_T_MAX - _PyUnicode_LENGTH(self) ||
; 9845 :         right > PY_SSIZE_T_MAX - (left + _PyUnicode_LENGTH(self))) {

  00047	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]
  0004b	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00055	48 2b c7	 sub	 rax, rdi
  00058	48 3b f0	 cmp	 rsi, rax
  0005b	0f 8f 7f 01 00
	00		 jg	 $LN34@pad
  00061	48 2b c6	 sub	 rax, rsi
  00064	4c 3b e0	 cmp	 r12, rax
  00067	0f 8f 73 01 00
	00		 jg	 $LN34@pad

; 9848 :     }
; 9849 :     maxchar = PyUnicode_MAX_CHAR_VALUE(self);

  0006d	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00070	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  00075	a8 40		 test	 al, 64			; 00000040H
  00077	74 07		 je	 SHORT $LN43@pad
  00079	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  0007e	eb 22		 jmp	 SHORT $LN42@pad
$LN43@pad:
  00080	c1 e8 02	 shr	 eax, 2
  00083	83 e0 07	 and	 eax, 7
  00086	83 f8 01	 cmp	 eax, 1
  00089	75 07		 jne	 SHORT $LN41@pad
  0008b	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00090	eb 10		 jmp	 SHORT $LN42@pad
$LN41@pad:
  00092	b9 ff ff 10 00	 mov	 ecx, 1114111		; 0010ffffH
  00097	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  0009c	83 f8 02	 cmp	 eax, 2
  0009f	0f 44 ca	 cmove	 ecx, edx
$LN42@pad:

; 9850 :     maxchar = Py_MAX(maxchar, fill);

  000a2	41 3b cf	 cmp	 ecx, r15d
  000a5	41 8b d7	 mov	 edx, r15d
  000a8	0f 47 d1	 cmova	 edx, ecx

; 9851 :     u = PyUnicode_New(left + _PyUnicode_LENGTH(self) + right, maxchar);

  000ab	48 8d 0c 37	 lea	 rcx, QWORD PTR [rdi+rsi]
  000af	49 03 cc	 add	 rcx, r12
  000b2	e8 00 00 00 00	 call	 PyUnicode_New
  000b7	4c 8b e8	 mov	 r13, rax

; 9852 :     if (!u)

  000ba	48 85 c0	 test	 rax, rax
  000bd	75 16		 jne	 SHORT $LN33@pad
$LN58@pad:
  000bf	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]
  000c4	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]

; 9864 : }

  000c9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cd	41 5f		 pop	 r15
  000cf	41 5e		 pop	 r14
  000d1	41 5c		 pop	 r12
  000d3	5e		 pop	 rsi
  000d4	c3		 ret	 0
$LN33@pad:

; 9853 :         return NULL;
; 9854 : 
; 9855 :     kind = PyUnicode_KIND(u);

  000d5	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000d8	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  000dd	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp
  000e2	8b d8		 mov	 ebx, eax
  000e4	c1 eb 02	 shr	 ebx, 2
  000e7	83 e3 07	 and	 ebx, 7

; 9856 :     data = PyUnicode_DATA(u);

  000ea	a8 20		 test	 al, 32			; 00000020H
  000ec	74 16		 je	 SHORT $LN47@pad
  000ee	a8 40		 test	 al, 64			; 00000040H
  000f0	74 09		 je	 SHORT $LN45@pad
  000f2	49 8d ad 80 00
	00 00		 lea	 rbp, QWORD PTR [r13+128]
  000f9	eb 10		 jmp	 SHORT $LN48@pad
$LN45@pad:
  000fb	49 8d ad a0 00
	00 00		 lea	 rbp, QWORD PTR [r13+160]
  00102	eb 07		 jmp	 SHORT $LN48@pad
$LN47@pad:
  00104	49 8b ad a0 00
	00 00		 mov	 rbp, QWORD PTR [r13+160]
$LN48@pad:

; 9857 :     if (left)

  0010b	48 85 f6	 test	 rsi, rsi
  0010e	74 44		 je	 SHORT $LN29@pad

; 9858 :         FILL(kind, data, fill, 0, left);

  00110	8b cb		 mov	 ecx, ebx
  00112	ff c9		 dec	 ecx
  00114	74 2f		 je	 SHORT $LN26@pad
  00116	ff c9		 dec	 ecx
  00118	74 17		 je	 SHORT $LN25@pad
  0011a	83 f9 02	 cmp	 ecx, 2
  0011d	75 35		 jne	 SHORT $LN29@pad
  0011f	48 85 f6	 test	 rsi, rsi
  00122	7e 30		 jle	 SHORT $LN29@pad
  00124	49 8b c7	 mov	 rax, r15
  00127	48 8b fd	 mov	 rdi, rbp
  0012a	48 8b ce	 mov	 rcx, rsi
  0012d	f3 ab		 rep stosd
  0012f	eb 23		 jmp	 SHORT $LN29@pad
$LN25@pad:
  00131	48 85 f6	 test	 rsi, rsi
  00134	7e 1e		 jle	 SHORT $LN29@pad
  00136	41 0f b7 c7	 movzx	 eax, r15w
  0013a	48 8b fd	 mov	 rdi, rbp
  0013d	48 8b ce	 mov	 rcx, rsi
  00140	66 f3 ab	 rep stosw
  00143	eb 0f		 jmp	 SHORT $LN29@pad
$LN26@pad:
  00145	41 0f b6 d7	 movzx	 edx, r15b
  00149	4c 8b c6	 mov	 r8, rsi
  0014c	48 8b cd	 mov	 rcx, rbp
  0014f	e8 00 00 00 00	 call	 memset
$LN29@pad:

; 9859 :     if (right)

  00154	4d 85 e4	 test	 r12, r12
  00157	74 5b		 je	 SHORT $LN13@pad

; 9860 :         FILL(kind, data, fill, left + _PyUnicode_LENGTH(self), right);

  00159	ff cb		 dec	 ebx
  0015b	74 43		 je	 SHORT $LN10@pad
  0015d	ff cb		 dec	 ebx
  0015f	74 21		 je	 SHORT $LN9@pad
  00161	83 fb 02	 cmp	 ebx, 2
  00164	75 4e		 jne	 SHORT $LN13@pad
  00166	49 8b 46 60	 mov	 rax, QWORD PTR [r14+96]
  0016a	48 8d 14 06	 lea	 rdx, QWORD PTR [rsi+rax]
  0016e	48 8d 7c 95 00	 lea	 rdi, QWORD PTR [rbp+rdx*4]
  00173	4d 85 e4	 test	 r12, r12
  00176	7e 3c		 jle	 SHORT $LN13@pad
  00178	49 8b c7	 mov	 rax, r15
  0017b	49 8b cc	 mov	 rcx, r12
  0017e	f3 ab		 rep stosd
  00180	eb 32		 jmp	 SHORT $LN13@pad
$LN9@pad:
  00182	49 8b 46 60	 mov	 rax, QWORD PTR [r14+96]
  00186	48 8d 0c 06	 lea	 rcx, QWORD PTR [rsi+rax]
  0018a	48 8d 7c 4d 00	 lea	 rdi, QWORD PTR [rbp+rcx*2]
  0018f	4d 85 e4	 test	 r12, r12
  00192	7e 20		 jle	 SHORT $LN13@pad
  00194	41 0f b7 c7	 movzx	 eax, r15w
  00198	49 8b cc	 mov	 rcx, r12
  0019b	66 f3 ab	 rep stosw
  0019e	eb 14		 jmp	 SHORT $LN13@pad
$LN10@pad:
  001a0	48 8d 0c 2e	 lea	 rcx, QWORD PTR [rsi+rbp]
  001a4	41 0f b6 d7	 movzx	 edx, r15b
  001a8	4d 8b c4	 mov	 r8, r12
  001ab	49 03 4e 60	 add	 rcx, QWORD PTR [r14+96]
  001af	e8 00 00 00 00	 call	 memset
$LN13@pad:

; 9861 :     _PyUnicode_FastCopyCharacters(u, left, self, 0, _PyUnicode_LENGTH(self));

  001b4	49 8b 46 60	 mov	 rax, QWORD PTR [r14+96]
  001b8	45 33 c9	 xor	 r9d, r9d
  001bb	4d 8b c6	 mov	 r8, r14
  001be	48 8b d6	 mov	 rdx, rsi
  001c1	49 8b cd	 mov	 rcx, r13
  001c4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c9	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters
  001ce	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  001d3	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 9862 :     assert(_PyUnicode_CheckConsistency(u, 1));
; 9863 :     return u;

  001d8	49 8b c5	 mov	 rax, r13
  001db	e9 df fe ff ff	 jmp	 $LN58@pad
$LN34@pad:

; 9846 :         PyErr_SetString(PyExc_OverflowError, "padded string is too long");

  001e0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  001e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GHMGEIFA@padded?5string?5is?5too?5long?$AA@
  001ee	e8 00 00 00 00	 call	 PyErr_SetString
  001f3	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]

; 9847 :         return NULL;

  001f8	33 c0		 xor	 eax, eax

; 9864 : }

  001fa	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001fe	41 5f		 pop	 r15
  00200	41 5e		 pop	 r14
  00202	41 5c		 pop	 r12
  00204	5e		 pop	 rsi
  00205	c3		 ret	 0
pad	ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_Splitlines
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_Splitlines DD imagerel $LN33
	DD	imagerel $LN33+366
	DD	imagerel $unwind$PyUnicode_Splitlines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Splitlines DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_Splitlines
_TEXT	SEGMENT
string$ = 48
keepends$ = 56
PyUnicode_Splitlines PROC				; COMDAT

; 9868 : {

$LN33:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b fa		 mov	 edi, edx

; 9869 :     PyObject *list;
; 9870 : 
; 9871 :     string = PyUnicode_FromObject(string);

  0000c	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00011	48 8b d8	 mov	 rbx, rax

; 9872 :     if (string == NULL)

  00014	48 85 c0	 test	 rax, rax

; 9873 :         return NULL;

  00017	74 1b		 je	 SHORT $LN32@PyUnicode_@86

; 9874 :     if (PyUnicode_READY(string) == -1) {

  00019	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  0001d	75 22		 jne	 SHORT $LN9@PyUnicode_@86
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00027	83 f8 ff	 cmp	 eax, -1
  0002a	75 15		 jne	 SHORT $LN9@PyUnicode_@86

; 9875 :         Py_DECREF(string);

  0002c	48 8b cb	 mov	 rcx, rbx
  0002f	e8 00 00 00 00	 call	 _Py_DecRef
$LN32@PyUnicode_@86:

; 9876 :         return NULL;

  00034	33 c0		 xor	 eax, eax

; 9905 :     return list;
; 9906 : }

  00036	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
$LN9@PyUnicode_@86:

; 9877 :     }
; 9878 : 
; 9879 :     switch (PyUnicode_KIND(string)) {

  00041	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00044	8b c8		 mov	 ecx, eax
  00046	c1 e9 02	 shr	 ecx, 2
  00049	83 e1 07	 and	 ecx, 7
  0004c	ff c9		 dec	 ecx
  0004e	0f 84 b9 00 00
	00		 je	 $LN6@PyUnicode_@86
  00054	ff c9		 dec	 ecx
  00056	74 65		 je	 SHORT $LN3@PyUnicode_@86
  00058	83 f9 02	 cmp	 ecx, 2
  0005b	74 07		 je	 SHORT $LN2@PyUnicode_@86

; 9900 :     default:
; 9901 :         assert(0);
; 9902 :         list = 0;

  0005d	33 ff		 xor	 edi, edi
  0005f	e9 f4 00 00 00	 jmp	 $LN4@PyUnicode_@86
$LN2@PyUnicode_@86:

; 9895 :     case PyUnicode_4BYTE_KIND:
; 9896 :         list = ucs4lib_splitlines(
; 9897 :             string, PyUnicode_4BYTE_DATA(string),
; 9898 :             PyUnicode_GET_LENGTH(string), keepends);

  00064	a8 20		 test	 al, 32			; 00000020H
  00066	74 3a		 je	 SHORT $LN29@PyUnicode_@86
  00068	a8 40		 test	 al, 64			; 00000040H
  0006a	74 1b		 je	 SHORT $LN27@PyUnicode_@86
  0006c	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  00070	48 8d 93 80 00
	00 00		 lea	 rdx, QWORD PTR [rbx+128]
  00077	44 8b cf	 mov	 r9d, edi
  0007a	48 8b cb	 mov	 rcx, rbx
  0007d	e8 00 00 00 00	 call	 ucs4lib_splitlines

; 9899 :         break;

  00082	e9 ce 00 00 00	 jmp	 $LN31@PyUnicode_@86
$LN27@PyUnicode_@86:

; 9895 :     case PyUnicode_4BYTE_KIND:
; 9896 :         list = ucs4lib_splitlines(
; 9897 :             string, PyUnicode_4BYTE_DATA(string),
; 9898 :             PyUnicode_GET_LENGTH(string), keepends);

  00087	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  0008b	48 8d 93 a0 00
	00 00		 lea	 rdx, QWORD PTR [rbx+160]
  00092	44 8b cf	 mov	 r9d, edi
  00095	48 8b cb	 mov	 rcx, rbx
  00098	e8 00 00 00 00	 call	 ucs4lib_splitlines

; 9899 :         break;

  0009d	e9 b3 00 00 00	 jmp	 $LN31@PyUnicode_@86
$LN29@PyUnicode_@86:

; 9895 :     case PyUnicode_4BYTE_KIND:
; 9896 :         list = ucs4lib_splitlines(
; 9897 :             string, PyUnicode_4BYTE_DATA(string),
; 9898 :             PyUnicode_GET_LENGTH(string), keepends);

  000a2	48 8b 93 a0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+160]
  000a9	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  000ad	44 8b cf	 mov	 r9d, edi
  000b0	48 8b cb	 mov	 rcx, rbx
  000b3	e8 00 00 00 00	 call	 ucs4lib_splitlines

; 9899 :         break;

  000b8	e9 98 00 00 00	 jmp	 $LN31@PyUnicode_@86
$LN3@PyUnicode_@86:

; 9889 :         break;
; 9890 :     case PyUnicode_2BYTE_KIND:
; 9891 :         list = ucs2lib_splitlines(
; 9892 :             string, PyUnicode_2BYTE_DATA(string),
; 9893 :             PyUnicode_GET_LENGTH(string), keepends);

  000bd	a8 20		 test	 al, 32			; 00000020H
  000bf	74 34		 je	 SHORT $LN25@PyUnicode_@86
  000c1	a8 40		 test	 al, 64			; 00000040H
  000c3	74 18		 je	 SHORT $LN23@PyUnicode_@86
  000c5	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  000c9	48 8d 93 80 00
	00 00		 lea	 rdx, QWORD PTR [rbx+128]
  000d0	44 8b cf	 mov	 r9d, edi
  000d3	48 8b cb	 mov	 rcx, rbx
  000d6	e8 00 00 00 00	 call	 ucs2lib_splitlines

; 9894 :         break;

  000db	eb 78		 jmp	 SHORT $LN31@PyUnicode_@86
$LN23@PyUnicode_@86:

; 9889 :         break;
; 9890 :     case PyUnicode_2BYTE_KIND:
; 9891 :         list = ucs2lib_splitlines(
; 9892 :             string, PyUnicode_2BYTE_DATA(string),
; 9893 :             PyUnicode_GET_LENGTH(string), keepends);

  000dd	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  000e1	48 8d 93 a0 00
	00 00		 lea	 rdx, QWORD PTR [rbx+160]
  000e8	44 8b cf	 mov	 r9d, edi
  000eb	48 8b cb	 mov	 rcx, rbx
  000ee	e8 00 00 00 00	 call	 ucs2lib_splitlines

; 9894 :         break;

  000f3	eb 60		 jmp	 SHORT $LN31@PyUnicode_@86
$LN25@PyUnicode_@86:

; 9889 :         break;
; 9890 :     case PyUnicode_2BYTE_KIND:
; 9891 :         list = ucs2lib_splitlines(
; 9892 :             string, PyUnicode_2BYTE_DATA(string),
; 9893 :             PyUnicode_GET_LENGTH(string), keepends);

  000f5	48 8b 93 a0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+160]
  000fc	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  00100	44 8b cf	 mov	 r9d, edi
  00103	48 8b cb	 mov	 rcx, rbx
  00106	e8 00 00 00 00	 call	 ucs2lib_splitlines

; 9894 :         break;

  0010b	eb 48		 jmp	 SHORT $LN31@PyUnicode_@86
$LN6@PyUnicode_@86:

; 9880 :     case PyUnicode_1BYTE_KIND:
; 9881 :         if (PyUnicode_IS_ASCII(string))

  0010d	a8 40		 test	 al, 64			; 00000040H
  0010f	74 23		 je	 SHORT $LN5@PyUnicode_@86

; 9882 :             list = asciilib_splitlines(
; 9883 :                 string, PyUnicode_1BYTE_DATA(string),
; 9884 :                 PyUnicode_GET_LENGTH(string), keepends);

  00111	48 8d 93 80 00
	00 00		 lea	 rdx, QWORD PTR [rbx+128]
  00118	a8 20		 test	 al, 32			; 00000020H
  0011a	75 07		 jne	 SHORT $LN18@PyUnicode_@86
  0011c	48 8b 93 a0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+160]
$LN18@PyUnicode_@86:
  00123	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  00127	44 8b cf	 mov	 r9d, edi
  0012a	48 8b cb	 mov	 rcx, rbx
  0012d	e8 00 00 00 00	 call	 asciilib_splitlines

; 9885 :         else

  00132	eb 21		 jmp	 SHORT $LN31@PyUnicode_@86
$LN5@PyUnicode_@86:

; 9886 :             list = ucs1lib_splitlines(
; 9887 :                 string, PyUnicode_1BYTE_DATA(string),
; 9888 :                 PyUnicode_GET_LENGTH(string), keepends);

  00134	48 8d 93 a0 00
	00 00		 lea	 rdx, QWORD PTR [rbx+160]
  0013b	a8 20		 test	 al, 32			; 00000020H
  0013d	75 07		 jne	 SHORT $LN22@PyUnicode_@86
  0013f	48 8b 93 a0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+160]
$LN22@PyUnicode_@86:
  00146	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  0014a	44 8b cf	 mov	 r9d, edi
  0014d	48 8b cb	 mov	 rcx, rbx
  00150	e8 00 00 00 00	 call	 ucs1lib_splitlines
$LN31@PyUnicode_@86:
  00155	48 8b f8	 mov	 rdi, rax
$LN4@PyUnicode_@86:

; 9903 :     }
; 9904 :     Py_DECREF(string);

  00158	48 8b cb	 mov	 rcx, rbx
  0015b	e8 00 00 00 00	 call	 _Py_DecRef

; 9905 :     return list;
; 9906 : }

  00160	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00165	48 8b c7	 mov	 rax, rdi
  00168	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016c	5f		 pop	 rdi
  0016d	c3		 ret	 0
PyUnicode_Splitlines ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$split DD	imagerel split
	DD	imagerel split+417
	DD	imagerel $unwind$split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$split DD imagerel split+417
	DD	imagerel split+815
	DD	imagerel $chain$4$split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$split DD 0a5c21H
	DD	0ec45cH
	DD	06f414H
	DD	07e40fH
	DD	0d640aH
	DD	0c5405H
	DD	imagerel split
	DD	imagerel split+417
	DD	imagerel $unwind$split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$split DD 040901H
	DD	0d0057209H
	DD	030027003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT split
_TEXT	SEGMENT
self$ = 96
substring$ = 104
maxcount$ = 112
split	PROC						; COMDAT

; 9912 : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 55		 push	 r13
  00005	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 9913 :     int kind1, kind2, kind;
; 9914 :     void *buf1, *buf2;
; 9915 :     Py_ssize_t len1, len2;
; 9916 :     PyObject* out;
; 9917 : 
; 9918 :     if (maxcount < 0)

  00009	4d 85 c0	 test	 r8, r8
  0000c	4d 8b e8	 mov	 r13, r8
  0000f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00019	4c 0f 48 e8	 cmovs	 r13, rax

; 9919 :         maxcount = PY_SSIZE_T_MAX;
; 9920 : 
; 9921 :     if (PyUnicode_READY(self) == -1)

  0001d	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00021	48 8b fa	 mov	 rdi, rdx
  00024	48 8b d9	 mov	 rbx, rcx
  00027	75 15		 jne	 SHORT $LN26@split
  00029	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0002e	83 f8 ff	 cmp	 eax, -1
  00031	75 0b		 jne	 SHORT $LN26@split
$LN64@split:

; 9922 :         return NULL;

  00033	33 c0		 xor	 eax, eax

; 9998 : }

  00035	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00039	41 5d		 pop	 r13
  0003b	5f		 pop	 rdi
  0003c	5b		 pop	 rbx
  0003d	c3		 ret	 0
$LN26@split:

; 9923 : 
; 9924 :     if (substring == NULL)

  0003e	48 85 ff	 test	 rdi, rdi
  00041	0f 85 3d 01 00
	00		 jne	 $LN23@split

; 9925 :         switch (PyUnicode_KIND(self)) {

  00047	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  0004a	8b c1		 mov	 eax, ecx
  0004c	c1 e8 02	 shr	 eax, 2
  0004f	83 e0 07	 and	 eax, 7
  00052	ff c8		 dec	 eax
  00054	0f 84 d1 00 00
	00		 je	 $LN22@split
  0005a	ff c8		 dec	 eax
  0005c	74 69		 je	 SHORT $LN20@split
  0005e	83 f8 02	 cmp	 eax, 2

; 9947 :         default:
; 9948 :             assert(0);
; 9949 :             return NULL;

  00061	75 d0		 jne	 SHORT $LN64@split

; 9942 :         case PyUnicode_4BYTE_KIND:
; 9943 :             return ucs4lib_split_whitespace(
; 9944 :                 self,  PyUnicode_4BYTE_DATA(self),
; 9945 :                 PyUnicode_GET_LENGTH(self), maxcount
; 9946 :                 );

  00063	f6 c1 20	 test	 cl, 32			; 00000020H
  00066	74 41		 je	 SHORT $LN46@split
  00068	f6 c1 40	 test	 cl, 64			; 00000040H
  0006b	74 1e		 je	 SHORT $LN44@split
  0006d	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  00071	48 8d 93 80 00
	00 00		 lea	 rdx, QWORD PTR [rbx+128]
  00078	4d 8b cd	 mov	 r9, r13
  0007b	48 8b cb	 mov	 rcx, rbx

; 9998 : }

  0007e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00082	41 5d		 pop	 r13
  00084	5f		 pop	 rdi
  00085	5b		 pop	 rbx
  00086	e9 00 00 00 00	 jmp	 ucs4lib_split_whitespace
$LN44@split:

; 9942 :         case PyUnicode_4BYTE_KIND:
; 9943 :             return ucs4lib_split_whitespace(
; 9944 :                 self,  PyUnicode_4BYTE_DATA(self),
; 9945 :                 PyUnicode_GET_LENGTH(self), maxcount
; 9946 :                 );

  0008b	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  0008f	48 8d 93 a0 00
	00 00		 lea	 rdx, QWORD PTR [rbx+160]
  00096	4d 8b cd	 mov	 r9, r13
  00099	48 8b cb	 mov	 rcx, rbx

; 9998 : }

  0009c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000a0	41 5d		 pop	 r13
  000a2	5f		 pop	 rdi
  000a3	5b		 pop	 rbx
  000a4	e9 00 00 00 00	 jmp	 ucs4lib_split_whitespace
$LN46@split:

; 9942 :         case PyUnicode_4BYTE_KIND:
; 9943 :             return ucs4lib_split_whitespace(
; 9944 :                 self,  PyUnicode_4BYTE_DATA(self),
; 9945 :                 PyUnicode_GET_LENGTH(self), maxcount
; 9946 :                 );

  000a9	48 8b 93 a0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+160]
  000b0	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  000b4	4d 8b cd	 mov	 r9, r13
  000b7	48 8b cb	 mov	 rcx, rbx

; 9998 : }

  000ba	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000be	41 5d		 pop	 r13
  000c0	5f		 pop	 rdi
  000c1	5b		 pop	 rbx
  000c2	e9 00 00 00 00	 jmp	 ucs4lib_split_whitespace
$LN20@split:

; 9937 :         case PyUnicode_2BYTE_KIND:
; 9938 :             return ucs2lib_split_whitespace(
; 9939 :                 self,  PyUnicode_2BYTE_DATA(self),
; 9940 :                 PyUnicode_GET_LENGTH(self), maxcount
; 9941 :                 );

  000c7	f6 c1 20	 test	 cl, 32			; 00000020H
  000ca	74 41		 je	 SHORT $LN42@split
  000cc	f6 c1 40	 test	 cl, 64			; 00000040H
  000cf	74 1e		 je	 SHORT $LN40@split
  000d1	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  000d5	48 8d 93 80 00
	00 00		 lea	 rdx, QWORD PTR [rbx+128]
  000dc	4d 8b cd	 mov	 r9, r13
  000df	48 8b cb	 mov	 rcx, rbx

; 9998 : }

  000e2	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000e6	41 5d		 pop	 r13
  000e8	5f		 pop	 rdi
  000e9	5b		 pop	 rbx
  000ea	e9 00 00 00 00	 jmp	 ucs2lib_split_whitespace
$LN40@split:

; 9937 :         case PyUnicode_2BYTE_KIND:
; 9938 :             return ucs2lib_split_whitespace(
; 9939 :                 self,  PyUnicode_2BYTE_DATA(self),
; 9940 :                 PyUnicode_GET_LENGTH(self), maxcount
; 9941 :                 );

  000ef	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  000f3	48 8d 93 a0 00
	00 00		 lea	 rdx, QWORD PTR [rbx+160]
  000fa	4d 8b cd	 mov	 r9, r13
  000fd	48 8b cb	 mov	 rcx, rbx

; 9998 : }

  00100	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00104	41 5d		 pop	 r13
  00106	5f		 pop	 rdi
  00107	5b		 pop	 rbx
  00108	e9 00 00 00 00	 jmp	 ucs2lib_split_whitespace
$LN42@split:

; 9937 :         case PyUnicode_2BYTE_KIND:
; 9938 :             return ucs2lib_split_whitespace(
; 9939 :                 self,  PyUnicode_2BYTE_DATA(self),
; 9940 :                 PyUnicode_GET_LENGTH(self), maxcount
; 9941 :                 );

  0010d	48 8b 93 a0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+160]
  00114	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  00118	4d 8b cd	 mov	 r9, r13
  0011b	48 8b cb	 mov	 rcx, rbx

; 9998 : }

  0011e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00122	41 5d		 pop	 r13
  00124	5f		 pop	 rdi
  00125	5b		 pop	 rbx
  00126	e9 00 00 00 00	 jmp	 ucs2lib_split_whitespace
$LN22@split:

; 9926 :         case PyUnicode_1BYTE_KIND:
; 9927 :             if (PyUnicode_IS_ASCII(self))

  0012b	f6 c1 40	 test	 cl, 64			; 00000040H
  0012e	74 2a		 je	 SHORT $LN21@split

; 9928 :                 return asciilib_split_whitespace(
; 9929 :                     self,  PyUnicode_1BYTE_DATA(self),
; 9930 :                     PyUnicode_GET_LENGTH(self), maxcount
; 9931 :                     );

  00130	48 8d 93 80 00
	00 00		 lea	 rdx, QWORD PTR [rbx+128]
  00137	f6 c1 20	 test	 cl, 32			; 00000020H
  0013a	75 07		 jne	 SHORT $LN35@split
  0013c	48 8b 93 a0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+160]
$LN35@split:
  00143	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  00147	4d 8b cd	 mov	 r9, r13
  0014a	48 8b cb	 mov	 rcx, rbx

; 9998 : }

  0014d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00151	41 5d		 pop	 r13
  00153	5f		 pop	 rdi
  00154	5b		 pop	 rbx
  00155	e9 00 00 00 00	 jmp	 asciilib_split_whitespace
$LN21@split:

; 9932 :             else
; 9933 :                 return ucs1lib_split_whitespace(
; 9934 :                     self,  PyUnicode_1BYTE_DATA(self),
; 9935 :                     PyUnicode_GET_LENGTH(self), maxcount
; 9936 :                     );

  0015a	48 8d 93 a0 00
	00 00		 lea	 rdx, QWORD PTR [rbx+160]
  00161	f6 c1 20	 test	 cl, 32			; 00000020H
  00164	75 07		 jne	 SHORT $LN39@split
  00166	48 8b 93 a0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+160]
$LN39@split:
  0016d	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  00171	4d 8b cd	 mov	 r9, r13
  00174	48 8b cb	 mov	 rcx, rbx

; 9998 : }

  00177	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0017b	41 5d		 pop	 r13
  0017d	5f		 pop	 rdi
  0017e	5b		 pop	 rbx
  0017f	e9 00 00 00 00	 jmp	 ucs1lib_split_whitespace
$LN23@split:

; 9950 :         }
; 9951 : 
; 9952 :     if (PyUnicode_READY(substring) == -1)

  00184	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  00188	75 11		 jne	 SHORT $LN16@split
  0018a	48 8b cf	 mov	 rcx, rdi
  0018d	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00192	83 f8 ff	 cmp	 eax, -1

; 9953 :         return NULL;

  00195	0f 84 98 fe ff
	ff		 je	 $LN64@split
$LN16@split:

; 9954 : 
; 9955 :     kind1 = PyUnicode_KIND(self);

  0019b	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]

; 9956 :     kind2 = PyUnicode_KIND(substring);

  0019e	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  001a1	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  001a6	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  001ab	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  001b0	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  001b5	44 8b f1	 mov	 r14d, ecx
  001b8	44 8b f8	 mov	 r15d, eax
  001bb	41 c1 ee 02	 shr	 r14d, 2
  001bf	41 c1 ef 02	 shr	 r15d, 2
  001c3	41 83 e6 07	 and	 r14d, 7
  001c7	41 83 e7 07	 and	 r15d, 7

; 9957 :     kind = kind1 > kind2 ? kind1 : kind2;

  001cb	45 3b f7	 cmp	 r14d, r15d
  001ce	41 8b ef	 mov	 ebp, r15d
  001d1	41 0f 4f ee	 cmovg	 ebp, r14d

; 9958 :     buf1 = PyUnicode_DATA(self);

  001d5	f6 c1 20	 test	 cl, 32			; 00000020H
  001d8	74 17		 je	 SHORT $LN52@split
  001da	f6 c1 40	 test	 cl, 64			; 00000040H
  001dd	74 09		 je	 SHORT $LN50@split
  001df	48 8d b3 80 00
	00 00		 lea	 rsi, QWORD PTR [rbx+128]
  001e6	eb 10		 jmp	 SHORT $LN53@split
$LN50@split:
  001e8	48 8d b3 a0 00
	00 00		 lea	 rsi, QWORD PTR [rbx+160]
  001ef	eb 07		 jmp	 SHORT $LN53@split
$LN52@split:
  001f1	48 8b b3 a0 00
	00 00		 mov	 rsi, QWORD PTR [rbx+160]
$LN53@split:
  001f8	4c 89 64 24 70	 mov	 QWORD PTR [rsp+112], r12

; 9959 :     buf2 = PyUnicode_DATA(substring);

  001fd	a8 20		 test	 al, 32			; 00000020H
  001ff	74 16		 je	 SHORT $LN56@split
  00201	a8 40		 test	 al, 64			; 00000040H
  00203	74 09		 je	 SHORT $LN54@split
  00205	4c 8d a7 80 00
	00 00		 lea	 r12, QWORD PTR [rdi+128]
  0020c	eb 10		 jmp	 SHORT $LN57@split
$LN54@split:
  0020e	4c 8d a7 a0 00
	00 00		 lea	 r12, QWORD PTR [rdi+160]
  00215	eb 07		 jmp	 SHORT $LN57@split
$LN56@split:
  00217	4c 8b a7 a0 00
	00 00		 mov	 r12, QWORD PTR [rdi+160]
$LN57@split:

; 9960 :     if (kind1 != kind)

  0021e	44 3b f5	 cmp	 r14d, ebp
  00221	74 0d		 je	 SHORT $LN15@split

; 9961 :         buf1 = _PyUnicode_AsKind(self, kind);

  00223	8b d5		 mov	 edx, ebp
  00225	48 8b cb	 mov	 rcx, rbx
  00228	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  0022d	48 8b f0	 mov	 rsi, rax
$LN15@split:

; 9962 :     if (!buf1)

  00230	48 85 f6	 test	 rsi, rsi

; 9963 :         return NULL;

  00233	74 24		 je	 SHORT $LN11@split

; 9964 :     if (kind2 != kind)

  00235	44 3b fd	 cmp	 r15d, ebp
  00238	74 0d		 je	 SHORT $LN13@split

; 9965 :         buf2 = _PyUnicode_AsKind(substring, kind);

  0023a	8b d5		 mov	 edx, ebp
  0023c	48 8b cf	 mov	 rcx, rdi
  0023f	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  00244	4c 8b e0	 mov	 r12, rax
$LN13@split:

; 9966 :     if (!buf2) {

  00247	4d 85 e4	 test	 r12, r12
  0024a	75 14		 jne	 SHORT $LN12@split

; 9967 :         if (kind1 != kind) PyMem_Free(buf1);

  0024c	44 3b f5	 cmp	 r14d, ebp
  0024f	74 08		 je	 SHORT $LN11@split
  00251	48 8b ce	 mov	 rcx, rsi
  00254	e8 00 00 00 00	 call	 PyMem_Free
$LN11@split:

; 9968 :         return NULL;

  00259	33 c0		 xor	 eax, eax
  0025b	e9 ad 00 00 00	 jmp	 $LN62@split
$LN12@split:

; 9969 :     }
; 9970 :     len1 = PyUnicode_GET_LENGTH(self);

  00260	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]

; 9971 :     len2 = PyUnicode_GET_LENGTH(substring);

  00264	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]

; 9972 : 
; 9973 :     switch (kind) {

  00268	8b cd		 mov	 ecx, ebp
  0026a	ff c9		 dec	 ecx
  0026c	74 41		 je	 SHORT $LN8@split
  0026e	ff c9		 dec	 ecx
  00270	74 23		 je	 SHORT $LN5@split
  00272	83 f9 02	 cmp	 ecx, 2
  00275	74 04		 je	 SHORT $LN4@split

; 9990 :     default:
; 9991 :         out = NULL;

  00277	33 db		 xor	 ebx, ebx
  00279	eb 75		 jmp	 SHORT $LN6@split
$LN4@split:

; 9986 :     case PyUnicode_4BYTE_KIND:
; 9987 :         out = ucs4lib_split(
; 9988 :             self,  buf1, len1, buf2, len2, maxcount);

  0027b	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  00280	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00285	4d 8b cc	 mov	 r9, r12
  00288	48 8b d6	 mov	 rdx, rsi
  0028b	48 8b cb	 mov	 rcx, rbx
  0028e	e8 00 00 00 00	 call	 ucs4lib_split

; 9989 :         break;

  00293	eb 58		 jmp	 SHORT $LN63@split
$LN5@split:

; 9981 :         break;
; 9982 :     case PyUnicode_2BYTE_KIND:
; 9983 :         out = ucs2lib_split(
; 9984 :             self,  buf1, len1, buf2, len2, maxcount);

  00295	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  0029a	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0029f	4d 8b cc	 mov	 r9, r12
  002a2	48 8b d6	 mov	 rdx, rsi
  002a5	48 8b cb	 mov	 rcx, rbx
  002a8	e8 00 00 00 00	 call	 ucs2lib_split

; 9985 :         break;

  002ad	eb 3e		 jmp	 SHORT $LN63@split
$LN8@split:

; 9974 :     case PyUnicode_1BYTE_KIND:
; 9975 :         if (PyUnicode_IS_ASCII(self) && PyUnicode_IS_ASCII(substring))

  002af	f6 43 70 40	 test	 BYTE PTR [rbx+112], 64	; 00000040H
  002b3	74 20		 je	 SHORT $LN7@split
  002b5	f6 47 70 40	 test	 BYTE PTR [rdi+112], 64	; 00000040H
  002b9	74 1a		 je	 SHORT $LN7@split

; 9976 :             out = asciilib_split(
; 9977 :                 self,  buf1, len1, buf2, len2, maxcount);

  002bb	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  002c0	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002c5	4d 8b cc	 mov	 r9, r12
  002c8	48 8b d6	 mov	 rdx, rsi
  002cb	48 8b cb	 mov	 rcx, rbx
  002ce	e8 00 00 00 00	 call	 asciilib_split

; 9978 :         else

  002d3	eb 18		 jmp	 SHORT $LN63@split
$LN7@split:

; 9979 :             out = ucs1lib_split(
; 9980 :                 self,  buf1, len1, buf2, len2, maxcount);

  002d5	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  002da	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002df	4d 8b cc	 mov	 r9, r12
  002e2	48 8b d6	 mov	 rdx, rsi
  002e5	48 8b cb	 mov	 rcx, rbx
  002e8	e8 00 00 00 00	 call	 ucs1lib_split
$LN63@split:
  002ed	48 8b d8	 mov	 rbx, rax
$LN6@split:

; 9992 :     }
; 9993 :     if (kind1 != kind)

  002f0	44 3b f5	 cmp	 r14d, ebp
  002f3	74 08		 je	 SHORT $LN2@split

; 9994 :         PyMem_Free(buf1);

  002f5	48 8b ce	 mov	 rcx, rsi
  002f8	e8 00 00 00 00	 call	 PyMem_Free
$LN2@split:

; 9995 :     if (kind2 != kind)

  002fd	44 3b fd	 cmp	 r15d, ebp
  00300	74 08		 je	 SHORT $LN1@split

; 9996 :         PyMem_Free(buf2);

  00302	49 8b cc	 mov	 rcx, r12
  00305	e8 00 00 00 00	 call	 PyMem_Free
$LN1@split:

; 9997 :     return out;

  0030a	48 8b c3	 mov	 rax, rbx
$LN62@split:
  0030d	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]
  00312	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]
  00317	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  0031c	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00321	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]

; 9998 : }

  00326	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0032a	41 5d		 pop	 r13
  0032c	5f		 pop	 rdi
  0032d	5b		 pop	 rbx
  0032e	c3		 ret	 0
split	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rsplit DD imagerel rsplit
	DD	imagerel rsplit+417
	DD	imagerel $unwind$rsplit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$rsplit DD imagerel rsplit+417
	DD	imagerel rsplit+815
	DD	imagerel $chain$4$rsplit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$rsplit DD 0a5c21H
	DD	0ec45cH
	DD	06f414H
	DD	07e40fH
	DD	0d640aH
	DD	0c5405H
	DD	imagerel rsplit
	DD	imagerel rsplit+417
	DD	imagerel $unwind$rsplit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rsplit DD 040901H
	DD	0d0057209H
	DD	030027003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT rsplit
_TEXT	SEGMENT
self$ = 96
substring$ = 104
maxcount$ = 112
rsplit	PROC						; COMDAT

; 10004: {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 55		 push	 r13
  00005	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 10005:     int kind1, kind2, kind;
; 10006:     void *buf1, *buf2;
; 10007:     Py_ssize_t len1, len2;
; 10008:     PyObject* out;
; 10009: 
; 10010:     if (maxcount < 0)

  00009	4d 85 c0	 test	 r8, r8
  0000c	4d 8b e8	 mov	 r13, r8
  0000f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00019	4c 0f 48 e8	 cmovs	 r13, rax

; 10011:         maxcount = PY_SSIZE_T_MAX;
; 10012: 
; 10013:     if (PyUnicode_READY(self) == -1)

  0001d	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00021	48 8b fa	 mov	 rdi, rdx
  00024	48 8b d9	 mov	 rbx, rcx
  00027	75 15		 jne	 SHORT $LN26@rsplit
  00029	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0002e	83 f8 ff	 cmp	 eax, -1
  00031	75 0b		 jne	 SHORT $LN26@rsplit
$LN64@rsplit:

; 10014:         return NULL;

  00033	33 c0		 xor	 eax, eax

; 10090: }

  00035	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00039	41 5d		 pop	 r13
  0003b	5f		 pop	 rdi
  0003c	5b		 pop	 rbx
  0003d	c3		 ret	 0
$LN26@rsplit:

; 10015: 
; 10016:     if (substring == NULL)

  0003e	48 85 ff	 test	 rdi, rdi
  00041	0f 85 3d 01 00
	00		 jne	 $LN23@rsplit

; 10017:         switch (PyUnicode_KIND(self)) {

  00047	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  0004a	8b c1		 mov	 eax, ecx
  0004c	c1 e8 02	 shr	 eax, 2
  0004f	83 e0 07	 and	 eax, 7
  00052	ff c8		 dec	 eax
  00054	0f 84 d1 00 00
	00		 je	 $LN22@rsplit
  0005a	ff c8		 dec	 eax
  0005c	74 69		 je	 SHORT $LN20@rsplit
  0005e	83 f8 02	 cmp	 eax, 2

; 10039:         default:
; 10040:             assert(0);
; 10041:             return NULL;

  00061	75 d0		 jne	 SHORT $LN64@rsplit

; 10034:         case PyUnicode_4BYTE_KIND:
; 10035:             return ucs4lib_rsplit_whitespace(
; 10036:                 self,  PyUnicode_4BYTE_DATA(self),
; 10037:                 PyUnicode_GET_LENGTH(self), maxcount
; 10038:                 );

  00063	f6 c1 20	 test	 cl, 32			; 00000020H
  00066	74 41		 je	 SHORT $LN46@rsplit
  00068	f6 c1 40	 test	 cl, 64			; 00000040H
  0006b	74 1e		 je	 SHORT $LN44@rsplit
  0006d	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  00071	48 8d 93 80 00
	00 00		 lea	 rdx, QWORD PTR [rbx+128]
  00078	4d 8b cd	 mov	 r9, r13
  0007b	48 8b cb	 mov	 rcx, rbx

; 10090: }

  0007e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00082	41 5d		 pop	 r13
  00084	5f		 pop	 rdi
  00085	5b		 pop	 rbx
  00086	e9 00 00 00 00	 jmp	 ucs4lib_rsplit_whitespace
$LN44@rsplit:

; 10034:         case PyUnicode_4BYTE_KIND:
; 10035:             return ucs4lib_rsplit_whitespace(
; 10036:                 self,  PyUnicode_4BYTE_DATA(self),
; 10037:                 PyUnicode_GET_LENGTH(self), maxcount
; 10038:                 );

  0008b	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  0008f	48 8d 93 a0 00
	00 00		 lea	 rdx, QWORD PTR [rbx+160]
  00096	4d 8b cd	 mov	 r9, r13
  00099	48 8b cb	 mov	 rcx, rbx

; 10090: }

  0009c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000a0	41 5d		 pop	 r13
  000a2	5f		 pop	 rdi
  000a3	5b		 pop	 rbx
  000a4	e9 00 00 00 00	 jmp	 ucs4lib_rsplit_whitespace
$LN46@rsplit:

; 10034:         case PyUnicode_4BYTE_KIND:
; 10035:             return ucs4lib_rsplit_whitespace(
; 10036:                 self,  PyUnicode_4BYTE_DATA(self),
; 10037:                 PyUnicode_GET_LENGTH(self), maxcount
; 10038:                 );

  000a9	48 8b 93 a0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+160]
  000b0	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  000b4	4d 8b cd	 mov	 r9, r13
  000b7	48 8b cb	 mov	 rcx, rbx

; 10090: }

  000ba	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000be	41 5d		 pop	 r13
  000c0	5f		 pop	 rdi
  000c1	5b		 pop	 rbx
  000c2	e9 00 00 00 00	 jmp	 ucs4lib_rsplit_whitespace
$LN20@rsplit:

; 10029:         case PyUnicode_2BYTE_KIND:
; 10030:             return ucs2lib_rsplit_whitespace(
; 10031:                 self,  PyUnicode_2BYTE_DATA(self),
; 10032:                 PyUnicode_GET_LENGTH(self), maxcount
; 10033:                 );

  000c7	f6 c1 20	 test	 cl, 32			; 00000020H
  000ca	74 41		 je	 SHORT $LN42@rsplit
  000cc	f6 c1 40	 test	 cl, 64			; 00000040H
  000cf	74 1e		 je	 SHORT $LN40@rsplit
  000d1	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  000d5	48 8d 93 80 00
	00 00		 lea	 rdx, QWORD PTR [rbx+128]
  000dc	4d 8b cd	 mov	 r9, r13
  000df	48 8b cb	 mov	 rcx, rbx

; 10090: }

  000e2	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000e6	41 5d		 pop	 r13
  000e8	5f		 pop	 rdi
  000e9	5b		 pop	 rbx
  000ea	e9 00 00 00 00	 jmp	 ucs2lib_rsplit_whitespace
$LN40@rsplit:

; 10029:         case PyUnicode_2BYTE_KIND:
; 10030:             return ucs2lib_rsplit_whitespace(
; 10031:                 self,  PyUnicode_2BYTE_DATA(self),
; 10032:                 PyUnicode_GET_LENGTH(self), maxcount
; 10033:                 );

  000ef	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  000f3	48 8d 93 a0 00
	00 00		 lea	 rdx, QWORD PTR [rbx+160]
  000fa	4d 8b cd	 mov	 r9, r13
  000fd	48 8b cb	 mov	 rcx, rbx

; 10090: }

  00100	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00104	41 5d		 pop	 r13
  00106	5f		 pop	 rdi
  00107	5b		 pop	 rbx
  00108	e9 00 00 00 00	 jmp	 ucs2lib_rsplit_whitespace
$LN42@rsplit:

; 10029:         case PyUnicode_2BYTE_KIND:
; 10030:             return ucs2lib_rsplit_whitespace(
; 10031:                 self,  PyUnicode_2BYTE_DATA(self),
; 10032:                 PyUnicode_GET_LENGTH(self), maxcount
; 10033:                 );

  0010d	48 8b 93 a0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+160]
  00114	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  00118	4d 8b cd	 mov	 r9, r13
  0011b	48 8b cb	 mov	 rcx, rbx

; 10090: }

  0011e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00122	41 5d		 pop	 r13
  00124	5f		 pop	 rdi
  00125	5b		 pop	 rbx
  00126	e9 00 00 00 00	 jmp	 ucs2lib_rsplit_whitespace
$LN22@rsplit:

; 10018:         case PyUnicode_1BYTE_KIND:
; 10019:             if (PyUnicode_IS_ASCII(self))

  0012b	f6 c1 40	 test	 cl, 64			; 00000040H
  0012e	74 2a		 je	 SHORT $LN21@rsplit

; 10020:                 return asciilib_rsplit_whitespace(
; 10021:                     self,  PyUnicode_1BYTE_DATA(self),
; 10022:                     PyUnicode_GET_LENGTH(self), maxcount
; 10023:                     );

  00130	48 8d 93 80 00
	00 00		 lea	 rdx, QWORD PTR [rbx+128]
  00137	f6 c1 20	 test	 cl, 32			; 00000020H
  0013a	75 07		 jne	 SHORT $LN35@rsplit
  0013c	48 8b 93 a0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+160]
$LN35@rsplit:
  00143	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  00147	4d 8b cd	 mov	 r9, r13
  0014a	48 8b cb	 mov	 rcx, rbx

; 10090: }

  0014d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00151	41 5d		 pop	 r13
  00153	5f		 pop	 rdi
  00154	5b		 pop	 rbx
  00155	e9 00 00 00 00	 jmp	 asciilib_rsplit_whitespace
$LN21@rsplit:

; 10024:             else
; 10025:                 return ucs1lib_rsplit_whitespace(
; 10026:                     self,  PyUnicode_1BYTE_DATA(self),
; 10027:                     PyUnicode_GET_LENGTH(self), maxcount
; 10028:                     );

  0015a	48 8d 93 a0 00
	00 00		 lea	 rdx, QWORD PTR [rbx+160]
  00161	f6 c1 20	 test	 cl, 32			; 00000020H
  00164	75 07		 jne	 SHORT $LN39@rsplit
  00166	48 8b 93 a0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+160]
$LN39@rsplit:
  0016d	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  00171	4d 8b cd	 mov	 r9, r13
  00174	48 8b cb	 mov	 rcx, rbx

; 10090: }

  00177	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0017b	41 5d		 pop	 r13
  0017d	5f		 pop	 rdi
  0017e	5b		 pop	 rbx
  0017f	e9 00 00 00 00	 jmp	 ucs1lib_rsplit_whitespace
$LN23@rsplit:

; 10042:         }
; 10043: 
; 10044:     if (PyUnicode_READY(substring) == -1)

  00184	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  00188	75 11		 jne	 SHORT $LN16@rsplit
  0018a	48 8b cf	 mov	 rcx, rdi
  0018d	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00192	83 f8 ff	 cmp	 eax, -1

; 10045:         return NULL;

  00195	0f 84 98 fe ff
	ff		 je	 $LN64@rsplit
$LN16@rsplit:

; 10046: 
; 10047:     kind1 = PyUnicode_KIND(self);

  0019b	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]

; 10048:     kind2 = PyUnicode_KIND(substring);

  0019e	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  001a1	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  001a6	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  001ab	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  001b0	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  001b5	44 8b f1	 mov	 r14d, ecx
  001b8	44 8b f8	 mov	 r15d, eax
  001bb	41 c1 ee 02	 shr	 r14d, 2
  001bf	41 c1 ef 02	 shr	 r15d, 2
  001c3	41 83 e6 07	 and	 r14d, 7
  001c7	41 83 e7 07	 and	 r15d, 7

; 10049:     kind = kind1 > kind2 ? kind1 : kind2;

  001cb	45 3b f7	 cmp	 r14d, r15d
  001ce	41 8b ef	 mov	 ebp, r15d
  001d1	41 0f 4f ee	 cmovg	 ebp, r14d

; 10050:     buf1 = PyUnicode_DATA(self);

  001d5	f6 c1 20	 test	 cl, 32			; 00000020H
  001d8	74 17		 je	 SHORT $LN52@rsplit
  001da	f6 c1 40	 test	 cl, 64			; 00000040H
  001dd	74 09		 je	 SHORT $LN50@rsplit
  001df	48 8d b3 80 00
	00 00		 lea	 rsi, QWORD PTR [rbx+128]
  001e6	eb 10		 jmp	 SHORT $LN53@rsplit
$LN50@rsplit:
  001e8	48 8d b3 a0 00
	00 00		 lea	 rsi, QWORD PTR [rbx+160]
  001ef	eb 07		 jmp	 SHORT $LN53@rsplit
$LN52@rsplit:
  001f1	48 8b b3 a0 00
	00 00		 mov	 rsi, QWORD PTR [rbx+160]
$LN53@rsplit:
  001f8	4c 89 64 24 70	 mov	 QWORD PTR [rsp+112], r12

; 10051:     buf2 = PyUnicode_DATA(substring);

  001fd	a8 20		 test	 al, 32			; 00000020H
  001ff	74 16		 je	 SHORT $LN56@rsplit
  00201	a8 40		 test	 al, 64			; 00000040H
  00203	74 09		 je	 SHORT $LN54@rsplit
  00205	4c 8d a7 80 00
	00 00		 lea	 r12, QWORD PTR [rdi+128]
  0020c	eb 10		 jmp	 SHORT $LN57@rsplit
$LN54@rsplit:
  0020e	4c 8d a7 a0 00
	00 00		 lea	 r12, QWORD PTR [rdi+160]
  00215	eb 07		 jmp	 SHORT $LN57@rsplit
$LN56@rsplit:
  00217	4c 8b a7 a0 00
	00 00		 mov	 r12, QWORD PTR [rdi+160]
$LN57@rsplit:

; 10052:     if (kind1 != kind)

  0021e	44 3b f5	 cmp	 r14d, ebp
  00221	74 0d		 je	 SHORT $LN15@rsplit

; 10053:         buf1 = _PyUnicode_AsKind(self, kind);

  00223	8b d5		 mov	 edx, ebp
  00225	48 8b cb	 mov	 rcx, rbx
  00228	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  0022d	48 8b f0	 mov	 rsi, rax
$LN15@rsplit:

; 10054:     if (!buf1)

  00230	48 85 f6	 test	 rsi, rsi

; 10055:         return NULL;

  00233	74 24		 je	 SHORT $LN11@rsplit

; 10056:     if (kind2 != kind)

  00235	44 3b fd	 cmp	 r15d, ebp
  00238	74 0d		 je	 SHORT $LN13@rsplit

; 10057:         buf2 = _PyUnicode_AsKind(substring, kind);

  0023a	8b d5		 mov	 edx, ebp
  0023c	48 8b cf	 mov	 rcx, rdi
  0023f	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  00244	4c 8b e0	 mov	 r12, rax
$LN13@rsplit:

; 10058:     if (!buf2) {

  00247	4d 85 e4	 test	 r12, r12
  0024a	75 14		 jne	 SHORT $LN12@rsplit

; 10059:         if (kind1 != kind) PyMem_Free(buf1);

  0024c	44 3b f5	 cmp	 r14d, ebp
  0024f	74 08		 je	 SHORT $LN11@rsplit
  00251	48 8b ce	 mov	 rcx, rsi
  00254	e8 00 00 00 00	 call	 PyMem_Free
$LN11@rsplit:

; 10060:         return NULL;

  00259	33 c0		 xor	 eax, eax
  0025b	e9 ad 00 00 00	 jmp	 $LN62@rsplit
$LN12@rsplit:

; 10061:     }
; 10062:     len1 = PyUnicode_GET_LENGTH(self);

  00260	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]

; 10063:     len2 = PyUnicode_GET_LENGTH(substring);

  00264	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]

; 10064: 
; 10065:     switch (kind) {

  00268	8b cd		 mov	 ecx, ebp
  0026a	ff c9		 dec	 ecx
  0026c	74 41		 je	 SHORT $LN8@rsplit
  0026e	ff c9		 dec	 ecx
  00270	74 23		 je	 SHORT $LN5@rsplit
  00272	83 f9 02	 cmp	 ecx, 2
  00275	74 04		 je	 SHORT $LN4@rsplit

; 10082:     default:
; 10083:         out = NULL;

  00277	33 db		 xor	 ebx, ebx
  00279	eb 75		 jmp	 SHORT $LN6@rsplit
$LN4@rsplit:

; 10078:     case PyUnicode_4BYTE_KIND:
; 10079:         out = ucs4lib_rsplit(
; 10080:             self,  buf1, len1, buf2, len2, maxcount);

  0027b	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  00280	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00285	4d 8b cc	 mov	 r9, r12
  00288	48 8b d6	 mov	 rdx, rsi
  0028b	48 8b cb	 mov	 rcx, rbx
  0028e	e8 00 00 00 00	 call	 ucs4lib_rsplit

; 10081:         break;

  00293	eb 58		 jmp	 SHORT $LN63@rsplit
$LN5@rsplit:

; 10073:         break;
; 10074:     case PyUnicode_2BYTE_KIND:
; 10075:         out = ucs2lib_rsplit(
; 10076:             self,  buf1, len1, buf2, len2, maxcount);

  00295	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  0029a	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0029f	4d 8b cc	 mov	 r9, r12
  002a2	48 8b d6	 mov	 rdx, rsi
  002a5	48 8b cb	 mov	 rcx, rbx
  002a8	e8 00 00 00 00	 call	 ucs2lib_rsplit

; 10077:         break;

  002ad	eb 3e		 jmp	 SHORT $LN63@rsplit
$LN8@rsplit:

; 10066:     case PyUnicode_1BYTE_KIND:
; 10067:         if (PyUnicode_IS_ASCII(self) && PyUnicode_IS_ASCII(substring))

  002af	f6 43 70 40	 test	 BYTE PTR [rbx+112], 64	; 00000040H
  002b3	74 20		 je	 SHORT $LN7@rsplit
  002b5	f6 47 70 40	 test	 BYTE PTR [rdi+112], 64	; 00000040H
  002b9	74 1a		 je	 SHORT $LN7@rsplit

; 10068:             out = asciilib_rsplit(
; 10069:                 self,  buf1, len1, buf2, len2, maxcount);

  002bb	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  002c0	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002c5	4d 8b cc	 mov	 r9, r12
  002c8	48 8b d6	 mov	 rdx, rsi
  002cb	48 8b cb	 mov	 rcx, rbx
  002ce	e8 00 00 00 00	 call	 asciilib_rsplit

; 10070:         else

  002d3	eb 18		 jmp	 SHORT $LN63@rsplit
$LN7@rsplit:

; 10071:             out = ucs1lib_rsplit(
; 10072:                 self,  buf1, len1, buf2, len2, maxcount);

  002d5	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  002da	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002df	4d 8b cc	 mov	 r9, r12
  002e2	48 8b d6	 mov	 rdx, rsi
  002e5	48 8b cb	 mov	 rcx, rbx
  002e8	e8 00 00 00 00	 call	 ucs1lib_rsplit
$LN63@rsplit:
  002ed	48 8b d8	 mov	 rbx, rax
$LN6@rsplit:

; 10084:     }
; 10085:     if (kind1 != kind)

  002f0	44 3b f5	 cmp	 r14d, ebp
  002f3	74 08		 je	 SHORT $LN2@rsplit

; 10086:         PyMem_Free(buf1);

  002f5	48 8b ce	 mov	 rcx, rsi
  002f8	e8 00 00 00 00	 call	 PyMem_Free
$LN2@rsplit:

; 10087:     if (kind2 != kind)

  002fd	44 3b fd	 cmp	 r15d, ebp
  00300	74 08		 je	 SHORT $LN1@rsplit

; 10088:         PyMem_Free(buf2);

  00302	49 8b cc	 mov	 rcx, r12
  00305	e8 00 00 00 00	 call	 PyMem_Free
$LN1@rsplit:

; 10089:     return out;

  0030a	48 8b c3	 mov	 rax, rbx
$LN62@rsplit:
  0030d	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]
  00312	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]
  00317	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  0031c	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00321	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]

; 10090: }

  00326	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0032a	41 5d		 pop	 r13
  0032c	5f		 pop	 rdi
  0032d	5b		 pop	 rbx
  0032e	c3		 ret	 0
rsplit	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@HBDILGAP@replace?5string?5is?5too?5long?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace DD imagerel replace
	DD	imagerel replace+3160
	DD	imagerel $unwind$replace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace DD 0a1d01H
	DD	015011dH
	DD	0e014f016H
	DD	0c010d012H
	DD	0600d700eH
	DD	0300b500cH
xdata	ENDS
;	COMDAT ??_C@_0BL@HBDILGAP@replace?5string?5is?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BL@HBDILGAP@replace?5string?5is?5too?5long?$AA@ DB 'replace string'
	DB	' is too long', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT replace
_TEXT	SEGMENT
buf1$1$ = 64
sbuf$1$ = 72
buf2$1$ = 80
slen$1$ = 88
srelease$1$ = 96
release2$1$ = 100
maxchar$2$ = 104
u$ = 104
mayshrink$1$ = 112
len2$1$ = 120
len1$1$ = 128
u$1$ = 136
tv1014 = 144
self$ = 240
release1$1$ = 248
str1$ = 248
rkind$1$ = 256
u1$1$ = 256
str2$ = 256
res$1$ = 264
maxcount$ = 264
replace	PROC						; COMDAT

; 10133: {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	41 54		 push	 r12
  00010	41 55		 push	 r13
  00012	41 56		 push	 r14
  00014	41 57		 push	 r15
  00016	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0001d	4c 8b f2	 mov	 r14, rdx

; 10134:     PyObject *u;
; 10135:     char *sbuf = PyUnicode_DATA(self);

  00020	8b 51 70	 mov	 edx, DWORD PTR [rcx+112]
  00023	4d 8b d9	 mov	 r11, r9
  00026	49 8b f8	 mov	 rdi, r8
  00029	4c 8b d1	 mov	 r10, rcx
  0002c	f6 c2 20	 test	 dl, 32			; 00000020H
  0002f	74 21		 je	 SHORT $LN95@replace
  00031	f6 c2 40	 test	 dl, 64			; 00000040H
  00034	74 0e		 je	 SHORT $LN93@replace
  00036	4c 8d 81 80 00
	00 00		 lea	 r8, QWORD PTR [rcx+128]
  0003d	4c 89 44 24 48	 mov	 QWORD PTR sbuf$1$[rsp], r8
  00042	eb 1a		 jmp	 SHORT $LN96@replace
$LN93@replace:
  00044	4c 8d 81 a0 00
	00 00		 lea	 r8, QWORD PTR [rcx+160]
  0004b	4c 89 44 24 48	 mov	 QWORD PTR sbuf$1$[rsp], r8
  00050	eb 0c		 jmp	 SHORT $LN96@replace
$LN95@replace:
  00052	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
  00059	48 89 44 24 48	 mov	 QWORD PTR sbuf$1$[rsp], rax
$LN96@replace:

; 10136:     char *buf1 = PyUnicode_DATA(str1);

  0005e	41 8b 4e 70	 mov	 ecx, DWORD PTR [r14+112]
  00062	8b c1		 mov	 eax, ecx
  00064	c1 e8 05	 shr	 eax, 5
  00067	83 e0 01	 and	 eax, 1
  0006a	74 21		 je	 SHORT $LN99@replace
  0006c	f6 c1 40	 test	 cl, 64			; 00000040H
  0006f	74 0e		 je	 SHORT $LN97@replace
  00071	4d 8d 8e 80 00
	00 00		 lea	 r9, QWORD PTR [r14+128]
  00078	4c 89 4c 24 40	 mov	 QWORD PTR buf1$1$[rsp], r9
  0007d	eb 1a		 jmp	 SHORT $LN100@replace
$LN97@replace:
  0007f	4d 8d 8e a0 00
	00 00		 lea	 r9, QWORD PTR [r14+160]
  00086	4c 89 4c 24 40	 mov	 QWORD PTR buf1$1$[rsp], r9
  0008b	eb 0c		 jmp	 SHORT $LN100@replace
$LN99@replace:
  0008d	4d 8b 86 a0 00
	00 00		 mov	 r8, QWORD PTR [r14+160]
  00094	4c 89 44 24 40	 mov	 QWORD PTR buf1$1$[rsp], r8
$LN100@replace:

; 10137:     char *buf2 = PyUnicode_DATA(str2);

  00099	44 8b 47 70	 mov	 r8d, DWORD PTR [rdi+112]
  0009d	41 f6 c0 20	 test	 r8b, 32			; 00000020H
  000a1	74 22		 je	 SHORT $LN103@replace
  000a3	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  000a7	74 0e		 je	 SHORT $LN101@replace
  000a9	48 8d af 80 00
	00 00		 lea	 rbp, QWORD PTR [rdi+128]
  000b0	48 89 6c 24 50	 mov	 QWORD PTR buf2$1$[rsp], rbp
  000b5	eb 1a		 jmp	 SHORT $LN104@replace
$LN101@replace:
  000b7	48 8d af a0 00
	00 00		 lea	 rbp, QWORD PTR [rdi+160]
  000be	48 89 6c 24 50	 mov	 QWORD PTR buf2$1$[rsp], rbp
  000c3	eb 0c		 jmp	 SHORT $LN104@replace
$LN103@replace:
  000c5	4c 8b 8f a0 00
	00 00		 mov	 r9, QWORD PTR [rdi+160]
  000cc	4c 89 4c 24 50	 mov	 QWORD PTR buf2$1$[rsp], r9
$LN104@replace:

; 10138:     int srelease = 0, release1 = 0, release2 = 0;
; 10139:     int skind = PyUnicode_KIND(self);
; 10140:     int kind1 = PyUnicode_KIND(str1);
; 10141:     int kind2 = PyUnicode_KIND(str2);
; 10142:     Py_ssize_t slen = PyUnicode_GET_LENGTH(self);

  000d1	49 8b 6a 60	 mov	 rbp, QWORD PTR [r10+96]

; 10143:     Py_ssize_t len1 = PyUnicode_GET_LENGTH(str1);

  000d5	4d 8b 6e 60	 mov	 r13, QWORD PTR [r14+96]

; 10144:     Py_ssize_t len2 = PyUnicode_GET_LENGTH(str2);

  000d9	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  000dd	45 33 e4	 xor	 r12d, r12d
  000e0	44 8b fa	 mov	 r15d, edx
  000e3	44 8b c9	 mov	 r9d, ecx
  000e6	41 c1 ef 02	 shr	 r15d, 2
  000ea	41 c1 e9 02	 shr	 r9d, 2
  000ee	41 8b f0	 mov	 esi, r8d
  000f1	c1 ee 02	 shr	 esi, 2
  000f4	41 83 e7 07	 and	 r15d, 7
  000f8	41 83 e1 07	 and	 r9d, 7
  000fc	83 e6 07	 and	 esi, 7
  000ff	44 89 64 24 60	 mov	 DWORD PTR srelease$1$[rsp], r12d
  00104	44 89 a4 24 f8
	00 00 00	 mov	 DWORD PTR release1$1$[rsp], r12d
  0010c	44 89 bc 24 00
	01 00 00	 mov	 DWORD PTR rkind$1$[rsp], r15d
  00114	44 89 64 24 64	 mov	 DWORD PTR release2$1$[rsp], r12d
  00119	48 89 6c 24 58	 mov	 QWORD PTR slen$1$[rsp], rbp
  0011e	4c 89 ac 24 80
	00 00 00	 mov	 QWORD PTR len1$1$[rsp], r13
  00126	48 89 5c 24 78	 mov	 QWORD PTR len2$1$[rsp], rbx

; 10145:     int mayshrink;
; 10146:     Py_UCS4 maxchar, maxchar_str2;
; 10147: 
; 10148:     if (maxcount < 0)

  0012b	49 ba ff ff ff
	ff ff ff ff 7f	 mov	 r10, 9223372036854775807 ; 7fffffffffffffffH
  00135	4d 85 db	 test	 r11, r11
  00138	79 0a		 jns	 SHORT $LN216@replace

; 10149:         maxcount = PY_SSIZE_T_MAX;

  0013a	4c 89 94 24 08
	01 00 00	 mov	 QWORD PTR maxcount$[rsp], r10
  00142	eb 0f		 jmp	 SHORT $LN88@replace
$LN216@replace:

; 10150:     else if (maxcount == 0 || slen == 0)

  00144	0f 84 ed 0a 00
	00		 je	 $LN188@replace
  0014a	48 85 ed	 test	 rbp, rbp
  0014d	0f 84 e4 0a 00
	00		 je	 $LN188@replace
$LN88@replace:

; 10151:         goto nothing;
; 10152: 
; 10153:     if (str1 == str2)

  00153	4c 3b f7	 cmp	 r14, rdi
  00156	0f 84 db 0a 00
	00		 je	 $LN188@replace

; 10154:         goto nothing;
; 10155:     if (skind < kind1)

  0015c	45 3b f9	 cmp	 r15d, r9d
  0015f	0f 8c d2 0a 00
	00		 jl	 $LN188@replace

; 10156:         /* substring too wide to be present */
; 10157:         goto nothing;
; 10158: 
; 10159:     maxchar = PyUnicode_MAX_CHAR_VALUE(self);

  00165	bd 7f 00 00 00	 mov	 ebp, 127		; 0000007fH
  0016a	41 ba ff ff 00
	00		 mov	 r10d, 65535		; 0000ffffH
  00170	f6 c2 40	 test	 dl, 64			; 00000040H
  00173	74 04		 je	 SHORT $LN107@replace
  00175	8b d5		 mov	 edx, ebp
  00177	eb 1a		 jmp	 SHORT $LN106@replace
$LN107@replace:
  00179	41 83 ff 01	 cmp	 r15d, 1
  0017d	75 07		 jne	 SHORT $LN105@replace
  0017f	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  00184	eb 0d		 jmp	 SHORT $LN106@replace
$LN105@replace:
  00186	ba ff ff 10 00	 mov	 edx, 1114111		; 0010ffffH
  0018b	41 83 ff 02	 cmp	 r15d, 2
  0018f	41 0f 44 d2	 cmove	 edx, r10d
$LN106@replace:

; 10160:     maxchar_str2 = PyUnicode_MAX_CHAR_VALUE(str2);

  00193	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00197	75 18		 jne	 SHORT $LN110@replace
  00199	83 fe 01	 cmp	 esi, 1
  0019c	75 07		 jne	 SHORT $LN109@replace
  0019e	bd ff 00 00 00	 mov	 ebp, 255		; 000000ffH
  001a3	eb 0c		 jmp	 SHORT $LN110@replace
$LN109@replace:
  001a5	bd ff ff 10 00	 mov	 ebp, 1114111		; 0010ffffH
  001aa	83 fe 02	 cmp	 esi, 2
  001ad	41 0f 44 ea	 cmove	 ebp, r10d
$LN110@replace:

; 10161:     /* Replacing str1 with str2 may cause a maxchar reduction in the
; 10162:        result string. */
; 10163:     mayshrink = (maxchar_str2 < maxchar);

  001b1	3b ea		 cmp	 ebp, edx
  001b3	45 8b c4	 mov	 r8d, r12d
  001b6	41 0f 92 c0	 setb	 r8b

; 10164:     maxchar = Py_MAX(maxchar, maxchar_str2);

  001ba	3b d5		 cmp	 edx, ebp
  001bc	0f 47 ea	 cmova	 ebp, edx
  001bf	44 89 44 24 70	 mov	 DWORD PTR mayshrink$1$[rsp], r8d
  001c4	89 6c 24 68	 mov	 DWORD PTR maxchar$2$[rsp], ebp

; 10165: 
; 10166:     if (len1 == len2) {

  001c8	4c 3b eb	 cmp	 r13, rbx
  001cb	0f 85 70 05 00
	00		 jne	 $LN84@replace

; 10167:         /* same length */
; 10168:         if (len1 == 0)

  001d1	4d 85 ed	 test	 r13, r13
  001d4	0f 84 5d 0a 00
	00		 je	 $LN188@replace

; 10169:             goto nothing;
; 10170:         if (len1 == 1) {

  001da	49 83 fd 01	 cmp	 r13, 1
  001de	0f 85 3e 03 00
	00		 jne	 $LN82@replace

; 10171:             /* replace characters */
; 10172:             Py_UCS4 u1, u2;
; 10173:             int rkind;
; 10174:             Py_ssize_t index, pos;
; 10175:             char *src;
; 10176: 
; 10177:             u1 = PyUnicode_READ_CHAR(str1, 0);

  001e4	45 3b cd	 cmp	 r9d, r13d
  001e7	75 2d		 jne	 SHORT $LN127@replace
  001e9	85 c0		 test	 eax, eax
  001eb	74 1c		 je	 SHORT $LN115@replace
  001ed	f6 c1 40	 test	 cl, 64			; 00000040H
  001f0	74 0a		 je	 SHORT $LN113@replace
  001f2	49 83 ee 80	 sub	 r14, -128		; ffffffffffffff80H
  001f6	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  001fa	eb 6f		 jmp	 SHORT $LN217@replace
$LN113@replace:
  001fc	49 81 c6 a0 00
	00 00		 add	 r14, 160		; 000000a0H
  00203	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00207	eb 62		 jmp	 SHORT $LN217@replace
$LN115@replace:
  00209	4d 8b b6 a0 00
	00 00		 mov	 r14, QWORD PTR [r14+160]
  00210	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00214	eb 55		 jmp	 SHORT $LN217@replace
$LN127@replace:
  00216	41 83 f9 02	 cmp	 r9d, 2
  0021a	75 2d		 jne	 SHORT $LN125@replace
  0021c	85 c0		 test	 eax, eax
  0021e	74 1c		 je	 SHORT $LN119@replace
  00220	f6 c1 40	 test	 cl, 64			; 00000040H
  00223	74 0a		 je	 SHORT $LN117@replace
  00225	49 83 ee 80	 sub	 r14, -128		; ffffffffffffff80H
  00229	41 0f b7 06	 movzx	 eax, WORD PTR [r14]
  0022d	eb 3c		 jmp	 SHORT $LN217@replace
$LN117@replace:
  0022f	49 81 c6 a0 00
	00 00		 add	 r14, 160		; 000000a0H
  00236	41 0f b7 06	 movzx	 eax, WORD PTR [r14]
  0023a	eb 2f		 jmp	 SHORT $LN217@replace
$LN119@replace:
  0023c	4d 8b b6 a0 00
	00 00		 mov	 r14, QWORD PTR [r14+160]
  00243	41 0f b7 06	 movzx	 eax, WORD PTR [r14]
  00247	eb 22		 jmp	 SHORT $LN217@replace
$LN125@replace:
  00249	85 c0		 test	 eax, eax
  0024b	74 14		 je	 SHORT $LN123@replace
  0024d	f6 c1 40	 test	 cl, 64			; 00000040H
  00250	74 06		 je	 SHORT $LN121@replace
  00252	49 83 ee 80	 sub	 r14, -128		; ffffffffffffff80H
  00256	eb 10		 jmp	 SHORT $LN124@replace
$LN121@replace:
  00258	49 81 c6 a0 00
	00 00		 add	 r14, 160		; 000000a0H
  0025f	eb 07		 jmp	 SHORT $LN124@replace
$LN123@replace:
  00261	4d 8b b6 a0 00
	00 00		 mov	 r14, QWORD PTR [r14+160]
$LN124@replace:
  00268	41 8b 06	 mov	 eax, DWORD PTR [r14]
$LN217@replace:

; 10178:             pos = findchar(sbuf, PyUnicode_KIND(self), slen, u1, 1);

  0026b	4c 8b 74 24 58	 mov	 r14, QWORD PTR slen$1$[rsp]
  00270	4c 8b 6c 24 48	 mov	 r13, QWORD PTR sbuf$1$[rsp]
  00275	44 8b c8	 mov	 r9d, eax
  00278	41 8b d7	 mov	 edx, r15d
  0027b	4d 8b c6	 mov	 r8, r14
  0027e	49 8b cd	 mov	 rcx, r13
  00281	89 84 24 00 01
	00 00		 mov	 DWORD PTR u1$1$[rsp], eax
  00288	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00290	e8 00 00 00 00	 call	 findchar
  00295	48 8b d8	 mov	 rbx, rax

; 10179:             if (pos < 0)

  00298	48 85 c0	 test	 rax, rax
  0029b	0f 88 96 09 00
	00		 js	 $LN188@replace

; 10180:                 goto nothing;
; 10181:             u2 = PyUnicode_READ_CHAR(str2, 0);

  002a1	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  002a4	8b c8		 mov	 ecx, eax
  002a6	c1 e9 02	 shr	 ecx, 2
  002a9	83 e1 07	 and	 ecx, 7
  002ac	83 f9 01	 cmp	 ecx, 1
  002af	75 29		 jne	 SHORT $LN143@replace
  002b1	a8 20		 test	 al, 32			; 00000020H
  002b3	74 19		 je	 SHORT $LN131@replace
  002b5	a8 40		 test	 al, 64			; 00000040H
  002b7	74 09		 je	 SHORT $LN129@replace
  002b9	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  002bd	0f b6 37	 movzx	 esi, BYTE PTR [rdi]
  002c0	eb 66		 jmp	 SHORT $LN142@replace
$LN129@replace:
  002c2	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  002c9	0f b6 37	 movzx	 esi, BYTE PTR [rdi]
  002cc	eb 5a		 jmp	 SHORT $LN142@replace
$LN131@replace:
  002ce	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
  002d5	0f b6 37	 movzx	 esi, BYTE PTR [rdi]
  002d8	eb 4e		 jmp	 SHORT $LN142@replace
$LN143@replace:
  002da	83 f9 02	 cmp	 ecx, 2
  002dd	75 29		 jne	 SHORT $LN141@replace
  002df	a8 20		 test	 al, 32			; 00000020H
  002e1	74 19		 je	 SHORT $LN135@replace
  002e3	a8 40		 test	 al, 64			; 00000040H
  002e5	74 09		 je	 SHORT $LN133@replace
  002e7	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  002eb	0f b7 37	 movzx	 esi, WORD PTR [rdi]
  002ee	eb 38		 jmp	 SHORT $LN142@replace
$LN133@replace:
  002f0	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  002f7	0f b7 37	 movzx	 esi, WORD PTR [rdi]
  002fa	eb 2c		 jmp	 SHORT $LN142@replace
$LN135@replace:
  002fc	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
  00303	0f b7 37	 movzx	 esi, WORD PTR [rdi]
  00306	eb 20		 jmp	 SHORT $LN142@replace
$LN141@replace:
  00308	a8 20		 test	 al, 32			; 00000020H
  0030a	74 13		 je	 SHORT $LN139@replace
  0030c	a8 40		 test	 al, 64			; 00000040H
  0030e	74 06		 je	 SHORT $LN137@replace
  00310	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  00314	eb 10		 jmp	 SHORT $LN140@replace
$LN137@replace:
  00316	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  0031d	eb 07		 jmp	 SHORT $LN140@replace
$LN139@replace:
  0031f	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
$LN140@replace:
  00326	8b 37		 mov	 esi, DWORD PTR [rdi]
$LN142@replace:

; 10182:             u = PyUnicode_New(slen, maxchar);

  00328	8b d5		 mov	 edx, ebp
  0032a	49 8b ce	 mov	 rcx, r14
  0032d	e8 00 00 00 00	 call	 PyUnicode_New
  00332	48 8b f8	 mov	 rdi, rax
  00335	48 89 44 24 68	 mov	 QWORD PTR u$[rsp], rax

; 10183:             if (!u)

  0033a	48 85 c0	 test	 rax, rax
  0033d	0f 84 cb 08 00
	00		 je	 $LN194@replace

; 10184:                 goto error;
; 10185:             _PyUnicode_FastCopyCharacters(u, 0, self, 0, slen);

  00343	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR self$[rsp]
  0034b	45 33 c9	 xor	 r9d, r9d
  0034e	33 d2		 xor	 edx, edx
  00350	48 8b c8	 mov	 rcx, rax
  00353	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00358	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 10186:             rkind = PyUnicode_KIND(u);

  0035d	8b 4f 70	 mov	 ecx, DWORD PTR [rdi+112]
  00360	8b e9		 mov	 ebp, ecx
  00362	c1 ed 02	 shr	 ebp, 2
  00365	83 e5 07	 and	 ebp, 7

; 10187: 
; 10188:             PyUnicode_WRITE(rkind, PyUnicode_DATA(u), pos, u2);

  00368	8b d5		 mov	 edx, ebp
  0036a	ff ca		 dec	 edx
  0036c	74 63		 je	 SHORT $LN74@replace
  0036e	ff ca		 dec	 edx
  00370	74 2e		 je	 SHORT $LN73@replace
  00372	f6 c1 20	 test	 cl, 32			; 00000020H
  00375	74 1d		 je	 SHORT $LN155@replace
  00377	f6 c1 40	 test	 cl, 64			; 00000040H
  0037a	74 0c		 je	 SHORT $LN153@replace
  0037c	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  00383	89 34 98	 mov	 DWORD PTR [rax+rbx*4], esi
  00386	eb 70		 jmp	 SHORT $LN78@replace
$LN153@replace:
  00388	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  0038f	89 34 98	 mov	 DWORD PTR [rax+rbx*4], esi
  00392	eb 64		 jmp	 SHORT $LN78@replace
$LN155@replace:
  00394	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  0039b	89 34 98	 mov	 DWORD PTR [rax+rbx*4], esi
  0039e	eb 58		 jmp	 SHORT $LN78@replace
$LN73@replace:
  003a0	f6 c1 20	 test	 cl, 32			; 00000020H
  003a3	74 1f		 je	 SHORT $LN151@replace
  003a5	f6 c1 40	 test	 cl, 64			; 00000040H
  003a8	74 0d		 je	 SHORT $LN149@replace
  003aa	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  003b1	66 89 34 58	 mov	 WORD PTR [rax+rbx*2], si
  003b5	eb 41		 jmp	 SHORT $LN78@replace
$LN149@replace:
  003b7	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  003be	66 89 34 58	 mov	 WORD PTR [rax+rbx*2], si
  003c2	eb 34		 jmp	 SHORT $LN78@replace
$LN151@replace:
  003c4	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  003cb	66 89 34 58	 mov	 WORD PTR [rax+rbx*2], si
  003cf	eb 27		 jmp	 SHORT $LN78@replace
$LN74@replace:
  003d1	f6 c1 20	 test	 cl, 32			; 00000020H
  003d4	74 17		 je	 SHORT $LN147@replace
  003d6	f6 c1 40	 test	 cl, 64			; 00000040H
  003d9	74 09		 je	 SHORT $LN145@replace
  003db	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  003e2	eb 10		 jmp	 SHORT $LN148@replace
$LN145@replace:
  003e4	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  003eb	eb 07		 jmp	 SHORT $LN148@replace
$LN147@replace:
  003ed	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
$LN148@replace:
  003f4	40 88 34 18	 mov	 BYTE PTR [rax+rbx], sil
$LN78@replace:

; 10189:             index = 0;
; 10190:             src = sbuf;
; 10191:             while (--maxcount)

  003f8	4c 8b b4 24 08
	01 00 00	 mov	 r14, QWORD PTR maxcount$[rsp]
  00400	49 ff ce	 dec	 r14
  00403	0f 84 10 07 00
	00		 je	 $LN15@replace
  00409	44 8b bc 24 00
	01 00 00	 mov	 r15d, DWORD PTR u1$1$[rsp]
$LL71@replace:

; 10192:             {
; 10193:                 pos++;
; 10194:                 src += pos * PyUnicode_KIND(self);

  00411	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00419	48 ff c3	 inc	 rbx

; 10195:                 slen -= pos;
; 10196:                 index += pos;
; 10197:                 pos = findchar(src, PyUnicode_KIND(self), slen, u1, 1);

  0041c	45 8b cf	 mov	 r9d, r15d
  0041f	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  00422	4c 03 e3	 add	 r12, rbx
  00425	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0042d	8b c1		 mov	 eax, ecx
  0042f	c1 e9 02	 shr	 ecx, 2
  00432	48 c1 e8 02	 shr	 rax, 2
  00436	83 e1 07	 and	 ecx, 7
  00439	83 e0 07	 and	 eax, 7
  0043c	8b d1		 mov	 edx, ecx
  0043e	48 0f af c3	 imul	 rax, rbx
  00442	4c 03 e8	 add	 r13, rax
  00445	48 8b 44 24 58	 mov	 rax, QWORD PTR slen$1$[rsp]
  0044a	48 2b c3	 sub	 rax, rbx
  0044d	49 8b cd	 mov	 rcx, r13
  00450	4c 8b c0	 mov	 r8, rax
  00453	48 89 44 24 58	 mov	 QWORD PTR slen$1$[rsp], rax
  00458	e8 00 00 00 00	 call	 findchar
  0045d	48 8b d8	 mov	 rbx, rax

; 10198:                 if (pos < 0)

  00460	48 85 c0	 test	 rax, rax
  00463	0f 88 b0 06 00
	00		 js	 $LN15@replace

; 10199:                     break;
; 10200:                 PyUnicode_WRITE(rkind, PyUnicode_DATA(u), index + pos, u2);

  00469	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  0046c	8b cd		 mov	 ecx, ebp
  0046e	ff c9		 dec	 ecx
  00470	74 7a		 je	 SHORT $LN63@replace
  00472	ff c9		 dec	 ecx
  00474	74 3b		 je	 SHORT $LN62@replace
  00476	a8 20		 test	 al, 32			; 00000020H
  00478	74 27		 je	 SHORT $LN167@replace
  0047a	a8 40		 test	 al, 64			; 00000040H
  0047c	74 13		 je	 SHORT $LN165@replace
  0047e	48 8d 8f 80 00
	00 00		 lea	 rcx, QWORD PTR [rdi+128]
  00485	49 8d 04 1c	 lea	 rax, QWORD PTR [r12+rbx]
  00489	89 34 81	 mov	 DWORD PTR [rcx+rax*4], esi
  0048c	e9 83 00 00 00	 jmp	 $LN67@replace
$LN165@replace:
  00491	48 8d 8f a0 00
	00 00		 lea	 rcx, QWORD PTR [rdi+160]
  00498	49 8d 04 1c	 lea	 rax, QWORD PTR [r12+rbx]
  0049c	89 34 81	 mov	 DWORD PTR [rcx+rax*4], esi
  0049f	eb 73		 jmp	 SHORT $LN67@replace
$LN167@replace:
  004a1	48 8b 8f a0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+160]
  004a8	49 8d 04 1c	 lea	 rax, QWORD PTR [r12+rbx]
  004ac	89 34 81	 mov	 DWORD PTR [rcx+rax*4], esi
  004af	eb 63		 jmp	 SHORT $LN67@replace
$LN62@replace:
  004b1	a8 20		 test	 al, 32			; 00000020H
  004b3	74 26		 je	 SHORT $LN163@replace
  004b5	a8 40		 test	 al, 64			; 00000040H
  004b7	74 11		 je	 SHORT $LN161@replace
  004b9	48 8d 8f 80 00
	00 00		 lea	 rcx, QWORD PTR [rdi+128]
  004c0	49 8d 04 1c	 lea	 rax, QWORD PTR [r12+rbx]
  004c4	66 89 34 41	 mov	 WORD PTR [rcx+rax*2], si
  004c8	eb 4a		 jmp	 SHORT $LN67@replace
$LN161@replace:
  004ca	48 8d 8f a0 00
	00 00		 lea	 rcx, QWORD PTR [rdi+160]
  004d1	49 8d 04 1c	 lea	 rax, QWORD PTR [r12+rbx]
  004d5	66 89 34 41	 mov	 WORD PTR [rcx+rax*2], si
  004d9	eb 39		 jmp	 SHORT $LN67@replace
$LN163@replace:
  004db	48 8b 8f a0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+160]
  004e2	49 8d 04 1c	 lea	 rax, QWORD PTR [r12+rbx]
  004e6	66 89 34 41	 mov	 WORD PTR [rcx+rax*2], si
  004ea	eb 28		 jmp	 SHORT $LN67@replace
$LN63@replace:
  004ec	a8 20		 test	 al, 32			; 00000020H
  004ee	74 16		 je	 SHORT $LN159@replace
  004f0	a8 40		 test	 al, 64			; 00000040H
  004f2	74 09		 je	 SHORT $LN157@replace
  004f4	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  004fb	eb 10		 jmp	 SHORT $LN160@replace
$LN157@replace:
  004fd	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  00504	eb 07		 jmp	 SHORT $LN160@replace
$LN159@replace:
  00506	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
$LN160@replace:
  0050d	49 03 c4	 add	 rax, r12
  00510	40 88 34 18	 mov	 BYTE PTR [rax+rbx], sil
$LN67@replace:

; 10189:             index = 0;
; 10190:             src = sbuf;
; 10191:             while (--maxcount)

  00514	49 ff ce	 dec	 r14
  00517	0f 85 f4 fe ff
	ff		 jne	 $LL71@replace

; 10201:             }
; 10202:         }
; 10203:         else {

  0051d	e9 f7 05 00 00	 jmp	 $LN15@replace
$LN82@replace:

; 10204:             int rkind = skind;
; 10205:             char *res;
; 10206:             Py_ssize_t i;
; 10207: 
; 10208:             if (kind1 < rkind) {

  00522	45 3b cf	 cmp	 r9d, r15d
  00525	7d 26		 jge	 SHORT $LN212@replace

; 10209:                 /* widen substring */
; 10210:                 buf1 = _PyUnicode_AsKind(str1, rkind);

  00527	41 8b d7	 mov	 edx, r15d
  0052a	49 8b ce	 mov	 rcx, r14
  0052d	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  00532	48 89 44 24 40	 mov	 QWORD PTR buf1$1$[rsp], rax

; 10211:                 if (!buf1) goto error;

  00537	48 85 c0	 test	 rax, rax
  0053a	0f 84 ce 06 00
	00		 je	 $LN194@replace

; 10212:                 release1 = 1;

  00540	c7 84 24 f8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR release1$1$[rsp], 1
  0054b	eb 05		 jmp	 SHORT $LN59@replace
$LN212@replace:

; 10209:                 /* widen substring */
; 10210:                 buf1 = _PyUnicode_AsKind(str1, rkind);

  0054d	48 8b 44 24 40	 mov	 rax, QWORD PTR buf1$1$[rsp]
$LN59@replace:

; 10213:             }
; 10214:             i = anylib_find(rkind, self, sbuf, slen, str1, buf1, len1, 0);

  00552	4c 8b 4c 24 58	 mov	 r9, QWORD PTR slen$1$[rsp]
  00557	4c 8b 44 24 48	 mov	 r8, QWORD PTR sbuf$1$[rsp]
  0055c	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  00564	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  00569	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  0056e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00573	41 8b cf	 mov	 ecx, r15d
  00576	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  0057b	e8 00 00 00 00	 call	 anylib_find
  00580	48 8b d8	 mov	 rbx, rax

; 10215:             if (i < 0)

  00583	48 85 c0	 test	 rax, rax
  00586	0f 88 86 06 00
	00		 js	 $LN184@replace

; 10216:                 goto nothing;
; 10217:             if (rkind > kind2) {

  0058c	44 3b fe	 cmp	 r15d, esi
  0058f	7e 26		 jle	 SHORT $LN218@replace

; 10218:                 /* widen replacement */
; 10219:                 buf2 = _PyUnicode_AsKind(str2, rkind);

  00591	41 8b d7	 mov	 edx, r15d
  00594	48 8b cf	 mov	 rcx, rdi
  00597	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  0059c	48 8b f8	 mov	 rdi, rax
  0059f	48 89 44 24 50	 mov	 QWORD PTR buf2$1$[rsp], rax

; 10220:                 if (!buf2) goto error;

  005a4	48 85 c0	 test	 rax, rax
  005a7	0f 84 0d 06 00
	00		 je	 $LN190@replace

; 10221:                 release2 = 1;

  005ad	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR release2$1$[rsp], 1
  005b5	eb 6c		 jmp	 SHORT $LN53@replace
$LN218@replace:

; 10222:             }
; 10223:             else if (rkind < kind2) {

  005b7	7d 6a		 jge	 SHORT $LN53@replace

; 10224:                 /* widen self and buf1 */
; 10225:                 rkind = kind2;

  005b9	44 8b fe	 mov	 r15d, esi

; 10226:                 if (release1) PyMem_Free(buf1);

  005bc	44 39 a4 24 f8
	00 00 00	 cmp	 DWORD PTR release1$1$[rsp], r12d
  005c4	74 0a		 je	 SHORT $LN52@replace
  005c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buf1$1$[rsp]
  005cb	e8 00 00 00 00	 call	 PyMem_Free
$LN52@replace:

; 10227:                 release1 = 0;
; 10228:                 sbuf = _PyUnicode_AsKind(self, rkind);

  005d0	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  005d8	8b d6		 mov	 edx, esi
  005da	44 89 a4 24 f8
	00 00 00	 mov	 DWORD PTR release1$1$[rsp], r12d
  005e2	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  005e7	48 8b f8	 mov	 rdi, rax
  005ea	48 89 44 24 48	 mov	 QWORD PTR sbuf$1$[rsp], rax

; 10229:                 if (!sbuf) goto error;

  005ef	48 85 c0	 test	 rax, rax
  005f2	0f 84 16 06 00
	00		 je	 $LN194@replace

; 10230:                 srelease = 1;
; 10231:                 buf1 = _PyUnicode_AsKind(str1, rkind);

  005f8	8b d6		 mov	 edx, esi
  005fa	49 8b ce	 mov	 rcx, r14
  005fd	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR srelease$1$[rsp], 1
  00605	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  0060a	48 89 44 24 40	 mov	 QWORD PTR buf1$1$[rsp], rax

; 10232:                 if (!buf1) goto error;

  0060f	48 85 c0	 test	 rax, rax
  00612	0f 84 80 02 00
	00		 je	 $LN207@replace

; 10233:                 release1 = 1;

  00618	c7 84 24 f8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR release1$1$[rsp], 1
$LN53@replace:

; 10234:             }
; 10235:             u = PyUnicode_New(slen, maxchar);

  00623	4c 8b 64 24 58	 mov	 r12, QWORD PTR slen$1$[rsp]
  00628	8b d5		 mov	 edx, ebp
  0062a	49 8b cc	 mov	 rcx, r12
  0062d	e8 00 00 00 00	 call	 PyUnicode_New
  00632	48 8b f8	 mov	 rdi, rax
  00635	48 89 44 24 68	 mov	 QWORD PTR u$[rsp], rax

; 10236:             if (!u)

  0063a	48 85 c0	 test	 rax, rax
  0063d	0f 84 45 02 00
	00		 je	 $error$137369

; 10237:                 goto error;
; 10238:             assert(PyUnicode_KIND(u) == rkind);
; 10239:             res = PyUnicode_DATA(u);

  00643	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00646	a8 20		 test	 al, 32			; 00000020H
  00648	74 16		 je	 SHORT $LN171@replace
  0064a	a8 40		 test	 al, 64			; 00000040H
  0064c	74 09		 je	 SHORT $LN169@replace
  0064e	48 8d af 80 00
	00 00		 lea	 rbp, QWORD PTR [rdi+128]
  00655	eb 10		 jmp	 SHORT $LN172@replace
$LN169@replace:
  00657	48 8d af a0 00
	00 00		 lea	 rbp, QWORD PTR [rdi+160]
  0065e	eb 07		 jmp	 SHORT $LN172@replace
$LN171@replace:
  00660	48 8b af a0 00
	00 00		 mov	 rbp, QWORD PTR [rdi+160]
$LN172@replace:

; 10240: 
; 10241:             memcpy(res, sbuf, rkind * slen);

  00667	48 8b 54 24 48	 mov	 rdx, QWORD PTR sbuf$1$[rsp]
  0066c	49 63 f7	 movsxd	 rsi, r15d
  0066f	48 8b cd	 mov	 rcx, rbp
  00672	4c 8b c6	 mov	 r8, rsi
  00675	4d 0f af c4	 imul	 r8, r12
  00679	e8 00 00 00 00	 call	 memcpy

; 10242:             /* change everything in-place, starting with this one */
; 10243:             memcpy(res + rkind * i,
; 10244:                    buf2,
; 10245:                    rkind * len2);

  0067e	48 8b 54 24 50	 mov	 rdx, QWORD PTR buf2$1$[rsp]
  00683	4c 8b e6	 mov	 r12, rsi
  00686	4c 0f af 64 24
	78		 imul	 r12, QWORD PTR len2$1$[rsp]
  0068c	48 8b ce	 mov	 rcx, rsi
  0068f	4d 8b c4	 mov	 r8, r12
  00692	48 0f af cb	 imul	 rcx, rbx
  00696	48 03 cd	 add	 rcx, rbp
  00699	e8 00 00 00 00	 call	 memcpy

; 10246:             i += len1;
; 10247: 
; 10248:             while ( --maxcount > 0) {

  0069e	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  006a6	49 03 dd	 add	 rbx, r13
  006a9	48 ff c8	 dec	 rax
  006ac	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR maxcount$[rsp], rax
  006b4	48 85 c0	 test	 rax, rax
  006b7	0f 8e 5c 04 00
	00		 jle	 $LN15@replace
  006bd	0f 1f 00	 npad	 3
$LL48@replace:

; 10249:                 i = anylib_find(rkind, self,
; 10250:                                 sbuf+rkind*i, slen-i,
; 10251:                                 str1, buf1, len1, i);

  006c0	48 8b 44 24 40	 mov	 rax, QWORD PTR buf1$1$[rsp]
  006c5	4c 8b 4c 24 58	 mov	 r9, QWORD PTR slen$1$[rsp]
  006ca	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  006d2	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  006d7	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  006dc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  006e1	4c 8b c6	 mov	 r8, rsi
  006e4	4c 2b cb	 sub	 r9, rbx
  006e7	41 8b cf	 mov	 ecx, r15d
  006ea	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  006ef	4c 0f af c3	 imul	 r8, rbx
  006f3	4c 03 44 24 48	 add	 r8, QWORD PTR sbuf$1$[rsp]
  006f8	e8 00 00 00 00	 call	 anylib_find
  006fd	48 8b d8	 mov	 rbx, rax

; 10252:                 if (i == -1)

  00700	48 83 f8 ff	 cmp	 rax, -1
  00704	0f 84 0f 04 00
	00		 je	 $LN15@replace

; 10253:                     break;
; 10254:                 memcpy(res + rkind * i,
; 10255:                        buf2,
; 10256:                        rkind * len2);

  0070a	48 8b 54 24 50	 mov	 rdx, QWORD PTR buf2$1$[rsp]
  0070f	48 8b ce	 mov	 rcx, rsi
  00712	4d 8b c4	 mov	 r8, r12
  00715	48 0f af cb	 imul	 rcx, rbx
  00719	48 03 cd	 add	 rcx, rbp
  0071c	e8 00 00 00 00	 call	 memcpy
  00721	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]

; 10257:                 i += len1;

  00729	49 03 dd	 add	 rbx, r13
  0072c	48 ff c8	 dec	 rax
  0072f	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR maxcount$[rsp], rax
  00737	48 85 c0	 test	 rax, rax
  0073a	7f 84		 jg	 SHORT $LL48@replace

; 10258:             }
; 10259:         }
; 10260:     }
; 10261:     else {

  0073c	e9 d8 03 00 00	 jmp	 $LN15@replace
$LN84@replace:

; 10262:         Py_ssize_t n, i, j, ires;
; 10263:         Py_ssize_t new_size;
; 10264:         int rkind = skind;
; 10265:         char *res;
; 10266: 
; 10267:         if (kind1 < rkind) {

  00741	45 3b cf	 cmp	 r9d, r15d
  00744	7d 24		 jge	 SHORT $LN44@replace

; 10268:             /* widen substring */
; 10269:             buf1 = _PyUnicode_AsKind(str1, rkind);

  00746	41 8b d7	 mov	 edx, r15d
  00749	49 8b ce	 mov	 rcx, r14
  0074c	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  00751	48 89 44 24 40	 mov	 QWORD PTR buf1$1$[rsp], rax

; 10270:             if (!buf1) goto error;

  00756	48 85 c0	 test	 rax, rax
  00759	0f 84 af 04 00
	00		 je	 $LN194@replace

; 10271:             release1 = 1;

  0075f	c7 84 24 f8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR release1$1$[rsp], 1
$LN44@replace:

; 10272:         }
; 10273:         n = anylib_count(rkind, self, sbuf, slen, str1, buf1, len1, maxcount);

  0076a	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00772	4c 8b 4c 24 58	 mov	 r9, QWORD PTR slen$1$[rsp]
  00777	4c 8b 44 24 48	 mov	 r8, QWORD PTR sbuf$1$[rsp]
  0077c	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  00784	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00789	48 8b 44 24 40	 mov	 rax, QWORD PTR buf1$1$[rsp]
  0078e	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  00793	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00798	41 8b cf	 mov	 ecx, r15d
  0079b	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  007a0	e8 00 00 00 00	 call	 anylib_count
  007a5	48 8b e8	 mov	 rbp, rax

; 10274:         if (n == 0)

  007a8	48 85 c0	 test	 rax, rax
  007ab	0f 84 61 04 00
	00		 je	 $LN184@replace

; 10275:             goto nothing;
; 10276:         if (kind2 < rkind) {

  007b1	41 3b f7	 cmp	 esi, r15d
  007b4	7d 26		 jge	 SHORT $LN219@replace

; 10277:             /* widen replacement */
; 10278:             buf2 = _PyUnicode_AsKind(str2, rkind);

  007b6	41 8b d7	 mov	 edx, r15d
  007b9	48 8b cf	 mov	 rcx, rdi
  007bc	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  007c1	48 8b f8	 mov	 rdi, rax
  007c4	48 89 44 24 50	 mov	 QWORD PTR buf2$1$[rsp], rax

; 10279:             if (!buf2) goto error;

  007c9	48 85 c0	 test	 rax, rax
  007cc	0f 84 e8 03 00
	00		 je	 $LN190@replace

; 10280:             release2 = 1;

  007d2	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR release2$1$[rsp], 1
  007da	eb 6f		 jmp	 SHORT $LN38@replace
$LN219@replace:

; 10281:         }
; 10282:         else if (kind2 > rkind) {

  007dc	7e 6d		 jle	 SHORT $LN38@replace

; 10283:             /* widen self and buf1 */
; 10284:             rkind = kind2;
; 10285:             sbuf = _PyUnicode_AsKind(self, rkind);

  007de	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  007e6	8b d6		 mov	 edx, esi
  007e8	44 8b fe	 mov	 r15d, esi
  007eb	89 b4 24 00 01
	00 00		 mov	 DWORD PTR rkind$1$[rsp], esi
  007f2	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  007f7	48 8b f8	 mov	 rdi, rax
  007fa	48 89 44 24 48	 mov	 QWORD PTR sbuf$1$[rsp], rax

; 10286:             if (!sbuf) goto error;

  007ff	48 85 c0	 test	 rax, rax
  00802	0f 84 ad 03 00
	00		 je	 $LN215@replace

; 10287:             srelease = 1;

  00808	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR srelease$1$[rsp], 1

; 10288:             if (release1) PyMem_Free(buf1);

  00810	44 39 a4 24 f8
	00 00 00	 cmp	 DWORD PTR release1$1$[rsp], r12d
  00818	74 0a		 je	 SHORT $LN36@replace
  0081a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buf1$1$[rsp]
  0081f	e8 00 00 00 00	 call	 PyMem_Free
$LN36@replace:

; 10289:             release1 = 0;
; 10290:             buf1 = _PyUnicode_AsKind(str1, rkind);

  00824	8b d6		 mov	 edx, esi
  00826	49 8b ce	 mov	 rcx, r14
  00829	44 89 a4 24 f8
	00 00 00	 mov	 DWORD PTR release1$1$[rsp], r12d
  00831	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  00836	48 89 44 24 40	 mov	 QWORD PTR buf1$1$[rsp], rax

; 10291:             if (!buf1) goto error;

  0083b	48 85 c0	 test	 rax, rax
  0083e	74 58		 je	 SHORT $LN207@replace

; 10292:             release1 = 1;

  00840	c7 84 24 f8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR release1$1$[rsp], 1
$LN38@replace:

; 10293:         }
; 10294:         /* new_size = PyUnicode_GET_LENGTH(self) + n * (PyUnicode_GET_LENGTH(str2) -
; 10295:            PyUnicode_GET_LENGTH(str1))); */
; 10296:         if (len2 > len1 && len2 - len1 > (PY_SSIZE_T_MAX - slen) / n) {

  0084b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR slen$1$[rsp]
  00850	49 b8 ff ff ff
	ff ff ff ff 7f	 mov	 r8, 9223372036854775807	; 7fffffffffffffffH
  0085a	49 3b dd	 cmp	 rbx, r13
  0085d	7e 5c		 jle	 SHORT $LN34@replace
  0085f	49 8b c0	 mov	 rax, r8
  00862	48 8b cb	 mov	 rcx, rbx
  00865	49 2b c1	 sub	 rax, r9
  00868	49 2b cd	 sub	 rcx, r13
  0086b	48 99		 cdq
  0086d	48 f7 fd	 idiv	 rbp
  00870	48 3b c8	 cmp	 rcx, rax
  00873	7e 46		 jle	 SHORT $LN34@replace
$LN225@replace:

; 10297:                 PyErr_SetString(PyExc_OverflowError,
; 10298:                                 "replace string is too long");

  00875	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0087c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@HBDILGAP@replace?5string?5is?5too?5long?$AA@
  00883	e8 00 00 00 00	 call	 PyErr_SetString
$error$137369:

; 10396: 
; 10397:   error:
; 10398:     if (srelease && sbuf)

  00888	83 7c 24 60 00	 cmp	 DWORD PTR srelease$1$[rsp], 0
  0088d	0f 84 22 03 00
	00		 je	 $LN215@replace
  00893	48 8b 7c 24 48	 mov	 rdi, QWORD PTR sbuf$1$[rsp]
$LN207@replace:
  00898	48 85 ff	 test	 rdi, rdi
  0089b	0f 84 14 03 00
	00		 je	 $LN215@replace

; 10399:         PyMem_FREE(sbuf);

  008a1	e8 00 00 00 00	 call	 _Py_PXCTX
  008a6	48 8b cf	 mov	 rcx, rdi
  008a9	85 c0		 test	 eax, eax
  008ab	0f 84 fe 02 00
	00		 je	 $LN189@replace
  008b1	e8 00 00 00 00	 call	 _PxMem_Free
  008b6	e9 fa 02 00 00	 jmp	 $LN215@replace
$LN34@replace:

; 10299:                 goto error;
; 10300:         }
; 10301:         new_size = slen + n * (len2 - len1);

  008bb	48 8b c3	 mov	 rax, rbx
  008be	49 2b c5	 sub	 rax, r13
  008c1	48 0f af c5	 imul	 rax, rbp
  008c5	49 03 c1	 add	 rax, r9

; 10302:         if (new_size == 0) {

  008c8	75 33		 jne	 SHORT $LN33@replace

; 10303:             _Py_INCREF_UNICODE_EMPTY();

  008ca	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  008d1	48 85 c9	 test	 rcx, rcx
  008d4	75 16		 jne	 SHORT $LN220@replace
  008d6	33 d2		 xor	 edx, edx
  008d8	e8 00 00 00 00	 call	 PyUnicode_New
  008dd	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  008e4	48 85 c0	 test	 rax, rax
  008e7	74 9f		 je	 SHORT $error$137369
  008e9	48 8b c8	 mov	 rcx, rax
$LN220@replace:
  008ec	e8 00 00 00 00	 call	 _Py_IncRef

; 10304:             if (!unicode_empty)

  008f1	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR unicode_empty

; 10305:                 goto error;
; 10306:             u = unicode_empty;
; 10307:             goto done;

  008f8	e9 32 02 00 00	 jmp	 $LN222@replace
$LN33@replace:

; 10308:         }
; 10309:         if (new_size > (PY_SSIZE_T_MAX >> (rkind-1))) {

  008fd	41 8d 4f ff	 lea	 ecx, DWORD PTR [r15-1]
  00901	49 d3 f8	 sar	 r8, cl
  00904	49 3b c0	 cmp	 rax, r8

; 10310:             PyErr_SetString(PyExc_OverflowError,
; 10311:                             "replace string is too long");
; 10312:             goto error;

  00907	0f 8f 68 ff ff
	ff		 jg	 $LN225@replace

; 10313:         }
; 10314:         u = PyUnicode_New(new_size, maxchar);

  0090d	8b 54 24 68	 mov	 edx, DWORD PTR maxchar$2$[rsp]
  00911	48 8b c8	 mov	 rcx, rax
  00914	e8 00 00 00 00	 call	 PyUnicode_New
  00919	48 8b f8	 mov	 rdi, rax
  0091c	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR u$1$[rsp], rax
  00924	48 89 44 24 68	 mov	 QWORD PTR u$[rsp], rax

; 10315:         if (!u)

  00929	48 85 c0	 test	 rax, rax
  0092c	0f 84 56 ff ff
	ff		 je	 $error$137369

; 10316:             goto error;
; 10317:         assert(PyUnicode_KIND(u) == rkind);
; 10318:         res = PyUnicode_DATA(u);

  00932	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00935	a8 20		 test	 al, 32			; 00000020H
  00937	74 16		 je	 SHORT $LN175@replace
  00939	a8 40		 test	 al, 64			; 00000040H
  0093b	74 09		 je	 SHORT $LN173@replace
  0093d	48 8d 9f 80 00
	00 00		 lea	 rbx, QWORD PTR [rdi+128]
  00944	eb 10		 jmp	 SHORT $LN223@replace
$LN173@replace:
  00946	48 8d 9f a0 00
	00 00		 lea	 rbx, QWORD PTR [rdi+160]
  0094d	eb 07		 jmp	 SHORT $LN223@replace
$LN175@replace:
  0094f	48 8b 9f a0 00
	00 00		 mov	 rbx, QWORD PTR [rdi+160]
$LN223@replace:
  00956	48 89 9c 24 08
	01 00 00	 mov	 QWORD PTR res$1$[rsp], rbx

; 10319:         ires = i = 0;

  0095e	49 8b f4	 mov	 rsi, r12

; 10320:         if (len1 > 0) {

  00961	4d 85 ed	 test	 r13, r13
  00964	0f 8e 1a 01 00
	00		 jle	 $LN198@replace

; 10321:             while (n-- > 0) {

  0096a	48 85 ed	 test	 rbp, rbp
  0096d	0f 8e ea 00 00
	00		 jle	 $LN201@replace
  00973	8b bc 24 00 01
	00 00		 mov	 edi, DWORD PTR rkind$1$[rsp]
  0097a	4d 63 ff	 movsxd	 r15, r15d
  0097d	0f 1f 00	 npad	 3
$LL22@replace:

; 10322:                 /* look for next match */
; 10323:                 j = anylib_find(rkind, self,
; 10324:                                 sbuf + rkind * i, slen-i,
; 10325:                                 str1, buf1, len1, i);

  00980	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buf1$1$[rsp]
  00985	4c 8b 4c 24 58	 mov	 r9, QWORD PTR slen$1$[rsp]
  0098a	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  00992	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  00997	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  0099c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009a1	49 8b c4	 mov	 rax, r12
  009a4	4d 2b cc	 sub	 r9, r12
  009a7	8b cf		 mov	 ecx, edi
  009a9	48 ff cd	 dec	 rbp
  009ac	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  009b1	49 0f af c7	 imul	 rax, r15
  009b5	48 03 44 24 48	 add	 rax, QWORD PTR sbuf$1$[rsp]
  009ba	4c 8b c0	 mov	 r8, rax
  009bd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv1014[rsp], rax
  009c5	e8 00 00 00 00	 call	 anylib_find
  009ca	4c 8b e8	 mov	 r13, rax

; 10326:                 if (j == -1)

  009cd	48 83 f8 ff	 cmp	 rax, -1
  009d1	74 7a		 je	 SHORT $LN208@replace

; 10327:                     break;
; 10328:                 else if (j > i) {

  009d3	49 3b c4	 cmp	 rax, r12
  009d6	7e 2c		 jle	 SHORT $LN18@replace

; 10329:                     /* copy unchanged part [i:j] */
; 10330:                     memcpy(res + rkind * ires,
; 10331:                            sbuf + rkind * i,
; 10332:                            rkind * (j-i));

  009d8	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv1014[rsp]
  009e0	48 8b d8	 mov	 rbx, rax
  009e3	48 8b ce	 mov	 rcx, rsi
  009e6	49 2b dc	 sub	 rbx, r12
  009e9	49 0f af cf	 imul	 rcx, r15
  009ed	48 03 8c 24 08
	01 00 00	 add	 rcx, QWORD PTR res$1$[rsp]
  009f5	4c 8b c3	 mov	 r8, rbx
  009f8	4d 0f af c7	 imul	 r8, r15
  009fc	e8 00 00 00 00	 call	 memcpy

; 10333:                     ires += j - i;

  00a01	48 03 f3	 add	 rsi, rbx
$LN18@replace:

; 10334:                 }
; 10335:                 /* copy substitution string */
; 10336:                 if (len2 > 0) {

  00a04	4c 8b 64 24 78	 mov	 r12, QWORD PTR len2$1$[rsp]

; 10337:                     memcpy(res + rkind * ires,
; 10338:                            buf2,
; 10339:                            rkind * len2);

  00a09	48 8b 9c 24 08
	01 00 00	 mov	 rbx, QWORD PTR res$1$[rsp]
  00a11	4d 85 e4	 test	 r12, r12
  00a14	7e 1e		 jle	 SHORT $LN17@replace
  00a16	48 8b 54 24 50	 mov	 rdx, QWORD PTR buf2$1$[rsp]
  00a1b	48 8b ce	 mov	 rcx, rsi
  00a1e	4d 8b c7	 mov	 r8, r15
  00a21	49 0f af cf	 imul	 rcx, r15
  00a25	4d 0f af c4	 imul	 r8, r12
  00a29	48 03 cb	 add	 rcx, rbx
  00a2c	e8 00 00 00 00	 call	 memcpy

; 10340:                     ires += len2;

  00a31	49 03 f4	 add	 rsi, r12
$LN17@replace:

; 10341:                 }
; 10342:                 i = j + len1;

  00a34	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR len1$1$[rsp]
  00a3c	4d 8d 64 05 00	 lea	 r12, QWORD PTR [r13+rax]
  00a41	4c 8b e8	 mov	 r13, rax
  00a44	48 85 ed	 test	 rbp, rbp
  00a47	0f 8f 33 ff ff
	ff		 jg	 $LL22@replace
$LN208@replace:
  00a4d	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR u$1$[rsp]
  00a55	44 8b bc 24 00
	01 00 00	 mov	 r15d, DWORD PTR rkind$1$[rsp]
$LN201@replace:

; 10343:             }
; 10344:             if (i < slen)

  00a5d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR slen$1$[rsp]
  00a62	4c 3b e1	 cmp	 r12, rcx
  00a65	0f 8d ae 00 00
	00		 jge	 $LN15@replace

; 10345:                 /* copy tail [i:] */
; 10346:                 memcpy(res + rkind * ires,
; 10347:                        sbuf + rkind * i,
; 10348:                        rkind * (slen-i));

  00a6b	49 63 c7	 movsxd	 rax, r15d
  00a6e	49 2b cc	 sub	 rcx, r12
  00a71	48 0f af c8	 imul	 rcx, rax
  00a75	48 0f af f0	 imul	 rsi, rax
  00a79	48 03 f3	 add	 rsi, rbx
  00a7c	4c 8b c1	 mov	 r8, rcx

; 10349:         }
; 10350:         else {

  00a7f	e9 81 00 00 00	 jmp	 $LN224@replace
$LN198@replace:

; 10351:             /* interleave */
; 10352:             while (n > 0) {

  00a84	48 85 ed	 test	 rbp, rbp
  00a87	7e 61		 jle	 SHORT $LN202@replace
  00a89	48 8b 7c 24 78	 mov	 rdi, QWORD PTR len2$1$[rsp]
  00a8e	4c 8b 74 24 48	 mov	 r14, QWORD PTR sbuf$1$[rsp]
  00a93	4d 63 ef	 movsxd	 r13, r15d
  00a96	4d 8b fd	 mov	 r15, r13
  00a99	4c 0f af ff	 imul	 r15, rdi
  00a9d	0f 1f 00	 npad	 3
$LL14@replace:

; 10353:                 memcpy(res + rkind * ires,
; 10354:                        buf2,
; 10355:                        rkind * len2);

  00aa0	48 8b 54 24 50	 mov	 rdx, QWORD PTR buf2$1$[rsp]
  00aa5	4d 8b c7	 mov	 r8, r15
  00aa8	48 8b cb	 mov	 rcx, rbx
  00aab	e8 00 00 00 00	 call	 memcpy

; 10356:                 ires += len2;
; 10357:                 if (--n <= 0)

  00ab0	48 ff cd	 dec	 rbp
  00ab3	48 03 f7	 add	 rsi, rdi
  00ab6	49 03 df	 add	 rbx, r15
  00ab9	48 85 ed	 test	 rbp, rbp
  00abc	7e 1c		 jle	 SHORT $LN209@replace

; 10358:                     break;
; 10359:                 memcpy(res + rkind * ires,
; 10360:                        sbuf + rkind * i,
; 10361:                        rkind);

  00abe	4d 8b c5	 mov	 r8, r13
  00ac1	49 8b d6	 mov	 rdx, r14
  00ac4	48 8b cb	 mov	 rcx, rbx
  00ac7	e8 00 00 00 00	 call	 memcpy

; 10362:                 ires++;

  00acc	48 ff c6	 inc	 rsi
  00acf	49 03 dd	 add	 rbx, r13

; 10363:                 i++;

  00ad2	49 ff c4	 inc	 r12
  00ad5	4d 03 f5	 add	 r14, r13
  00ad8	eb c6		 jmp	 SHORT $LL14@replace
$LN209@replace:
  00ada	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR u$1$[rsp]
  00ae2	44 8b bc 24 00
	01 00 00	 mov	 r15d, DWORD PTR rkind$1$[rsp]
$LN202@replace:

; 10364:             }
; 10365:             memcpy(res + rkind * ires,
; 10366:                    sbuf + rkind * i,
; 10367:                    rkind * (slen-i));

  00aea	4c 8b 44 24 58	 mov	 r8, QWORD PTR slen$1$[rsp]
  00aef	49 63 c7	 movsxd	 rax, r15d
  00af2	4d 2b c4	 sub	 r8, r12
  00af5	48 0f af f0	 imul	 rsi, rax
  00af9	4c 0f af c0	 imul	 r8, rax
  00afd	48 03 b4 24 08
	01 00 00	 add	 rsi, QWORD PTR res$1$[rsp]
$LN224@replace:
  00b05	4c 0f af e0	 imul	 r12, rax
  00b09	48 8b ce	 mov	 rcx, rsi
  00b0c	4c 03 64 24 48	 add	 r12, QWORD PTR sbuf$1$[rsp]
  00b11	49 8b d4	 mov	 rdx, r12
  00b14	e8 00 00 00 00	 call	 memcpy
$LN15@replace:

; 10368:         }
; 10369:     }
; 10370: 
; 10371:     if (mayshrink) {

  00b19	83 7c 24 70 00	 cmp	 DWORD PTR mayshrink$1$[rsp], 0
  00b1e	74 18		 je	 SHORT $done$137549

; 10372:         unicode_adjust_maxchar(&u);

  00b20	48 8d 4c 24 68	 lea	 rcx, QWORD PTR u$[rsp]
  00b25	e8 00 00 00 00	 call	 unicode_adjust_maxchar

; 10373:         if (u == NULL)

  00b2a	48 8b 7c 24 68	 mov	 rdi, QWORD PTR u$[rsp]
$LN222@replace:
  00b2f	48 85 ff	 test	 rdi, rdi
  00b32	0f 84 50 fd ff
	ff		 je	 $error$137369
$done$137549:

; 10374:             goto error;
; 10375:     }
; 10376: 
; 10377:   done:
; 10378:     if (srelease)

  00b38	83 7c 24 60 00	 cmp	 DWORD PTR srelease$1$[rsp], 0
  00b3d	74 1b		 je	 SHORT $LN178@replace

; 10379:         PyMem_FREE(sbuf);

  00b3f	e8 00 00 00 00	 call	 _Py_PXCTX
  00b44	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sbuf$1$[rsp]
  00b49	85 c0		 test	 eax, eax
  00b4b	74 07		 je	 SHORT $LN177@replace
  00b4d	e8 00 00 00 00	 call	 _PxMem_Free
  00b52	eb 06		 jmp	 SHORT $LN178@replace
$LN177@replace:
  00b54	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN178@replace:

; 10380:     if (release1)

  00b5a	83 bc 24 f8 00
	00 00 00	 cmp	 DWORD PTR release1$1$[rsp], 0
  00b62	74 1b		 je	 SHORT $LN180@replace

; 10381:         PyMem_FREE(buf1);

  00b64	e8 00 00 00 00	 call	 _Py_PXCTX
  00b69	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buf1$1$[rsp]
  00b6e	85 c0		 test	 eax, eax
  00b70	74 07		 je	 SHORT $LN179@replace
  00b72	e8 00 00 00 00	 call	 _PxMem_Free
  00b77	eb 06		 jmp	 SHORT $LN180@replace
$LN179@replace:
  00b79	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN180@replace:

; 10382:     if (release2)

  00b7f	83 7c 24 64 00	 cmp	 DWORD PTR release2$1$[rsp], 0
  00b84	74 21		 je	 SHORT $LN182@replace

; 10383:         PyMem_FREE(buf2);

  00b86	e8 00 00 00 00	 call	 _Py_PXCTX
  00b8b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buf2$1$[rsp]
  00b90	85 c0		 test	 eax, eax
  00b92	74 0d		 je	 SHORT $LN181@replace
  00b94	e8 00 00 00 00	 call	 _PxMem_Free

; 10384:     assert(_PyUnicode_CheckConsistency(u, 1));
; 10385:     return u;

  00b99	48 8b c7	 mov	 rax, rdi
  00b9c	e9 a3 00 00 00	 jmp	 $LN91@replace
$LN181@replace:

; 10383:         PyMem_FREE(buf2);

  00ba1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN182@replace:

; 10384:     assert(_PyUnicode_CheckConsistency(u, 1));
; 10385:     return u;

  00ba7	48 8b c7	 mov	 rax, rdi
  00baa	e9 95 00 00 00	 jmp	 $LN91@replace
$LN189@replace:

; 10399:         PyMem_FREE(sbuf);

  00baf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN215@replace:

; 10277:             /* widen replacement */
; 10278:             buf2 = _PyUnicode_AsKind(str2, rkind);

  00bb5	48 8b 7c 24 50	 mov	 rdi, QWORD PTR buf2$1$[rsp]
$LN190@replace:

; 10400:     if (release1 && buf1)

  00bba	83 bc 24 f8 00
	00 00 00	 cmp	 DWORD PTR release1$1$[rsp], 0
  00bc2	74 23		 je	 SHORT $LN192@replace
  00bc4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR buf1$1$[rsp]
  00bc9	48 85 db	 test	 rbx, rbx
  00bcc	74 19		 je	 SHORT $LN192@replace

; 10401:         PyMem_FREE(buf1);

  00bce	e8 00 00 00 00	 call	 _Py_PXCTX
  00bd3	48 8b cb	 mov	 rcx, rbx
  00bd6	85 c0		 test	 eax, eax
  00bd8	74 07		 je	 SHORT $LN191@replace
  00bda	e8 00 00 00 00	 call	 _PxMem_Free
  00bdf	eb 06		 jmp	 SHORT $LN192@replace
$LN191@replace:
  00be1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN192@replace:

; 10402:     if (release2 && buf2)

  00be7	83 7c 24 64 00	 cmp	 DWORD PTR release2$1$[rsp], 0
  00bec	74 20		 je	 SHORT $LN194@replace
  00bee	48 85 ff	 test	 rdi, rdi
  00bf1	74 1b		 je	 SHORT $LN194@replace

; 10403:         PyMem_FREE(buf2);

  00bf3	e8 00 00 00 00	 call	 _Py_PXCTX
  00bf8	48 8b cf	 mov	 rcx, rdi
  00bfb	85 c0		 test	 eax, eax
  00bfd	74 09		 je	 SHORT $LN193@replace
  00bff	e8 00 00 00 00	 call	 _PxMem_Free

; 10404:     return NULL;

  00c04	33 c0		 xor	 eax, eax
  00c06	eb 3c		 jmp	 SHORT $LN91@replace
$LN193@replace:

; 10403:         PyMem_FREE(buf2);

  00c08	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN194@replace:

; 10404:     return NULL;

  00c0e	33 c0		 xor	 eax, eax
  00c10	eb 32		 jmp	 SHORT $LN91@replace
$LN184@replace:

; 10386: 
; 10387:   nothing:
; 10388:     /* nothing to replace; return original string (when possible) */
; 10389:     if (srelease)
; 10390:         PyMem_FREE(sbuf);
; 10391:     if (release1)

  00c12	44 39 a4 24 f8
	00 00 00	 cmp	 DWORD PTR release1$1$[rsp], r12d
  00c1a	74 1b		 je	 SHORT $LN188@replace

; 10392:         PyMem_FREE(buf1);

  00c1c	e8 00 00 00 00	 call	 _Py_PXCTX
  00c21	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buf1$1$[rsp]
  00c26	85 c0		 test	 eax, eax
  00c28	74 07		 je	 SHORT $LN185@replace
  00c2a	e8 00 00 00 00	 call	 _PxMem_Free
  00c2f	eb 06		 jmp	 SHORT $LN188@replace
$LN185@replace:
  00c31	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN188@replace:

; 10393:     if (release2)
; 10394:         PyMem_FREE(buf2);
; 10395:     return unicode_result_unchanged(self);

  00c37	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00c3f	e8 00 00 00 00	 call	 unicode_result_unchanged
$LN91@replace:

; 10405: }

  00c44	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00c4b	41 5f		 pop	 r15
  00c4d	41 5e		 pop	 r14
  00c4f	41 5d		 pop	 r13
  00c51	41 5c		 pop	 r12
  00c53	5f		 pop	 rdi
  00c54	5e		 pop	 rsi
  00c55	5d		 pop	 rbp
  00c56	5b		 pop	 rbx
  00c57	c3		 ret	 0
replace	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_capitalize DD imagerel unicode_capitalize
	DD	imagerel unicode_capitalize+70
	DD	imagerel $unwind$unicode_capitalize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_capitalize DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_capitalize
_TEXT	SEGMENT
self$ = 48
unicode_capitalize PROC					; COMDAT

; 10431: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 10432:     if (PyUnicode_READY(self) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	75 12		 jne	 SHORT $LN2@unicode_ca@2
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN2@unicode_ca@2

; 10433:         return NULL;

  00019	33 c0		 xor	 eax, eax

; 10437: }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
$LN2@unicode_ca@2:

; 10434:     if (PyUnicode_GET_LENGTH(self) == 0)

  00021	48 83 7b 60 00	 cmp	 QWORD PTR [rbx+96], 0

; 10435:         return unicode_result_unchanged(self);

  00026	48 8b cb	 mov	 rcx, rbx
  00029	75 0a		 jne	 SHORT $LN1@unicode_ca@2

; 10437: }

  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx
  00030	e9 00 00 00 00	 jmp	 unicode_result_unchanged
$LN1@unicode_ca@2:

; 10436:     return case_operation(self, do_capitalize);

  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:do_capitalize

; 10437: }

  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5b		 pop	 rbx
  00041	e9 00 00 00 00	 jmp	 case_operation
unicode_capitalize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@EIALIKMK@n?$HMO?$CG?3center?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_center DD imagerel unicode_center
	DD	imagerel unicode_center+170
	DD	imagerel $unwind$unicode_center
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_center DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0M@EIALIKMK@n?$HMO?$CG?3center?$AA@
CONST	SEGMENT
??_C@_0M@EIALIKMK@n?$HMO?$CG?3center?$AA@ DB 'n|O&:center', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_center
_TEXT	SEGMENT
self$ = 64
args$ = 72
fillchar$ = 80
width$ = 88
unicode_center PROC					; COMDAT

; 10488: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 10489:     Py_ssize_t marg, left;
; 10490:     Py_ssize_t width;
; 10491:     Py_UCS4 fillchar = ' ';
; 10492: 
; 10493:     if (!PyArg_ParseTuple(args, "n|O&:center", &width, convert_uc, &fillchar))

  0000c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR fillchar$[rsp]
  00011	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00016	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:convert_uc
  0001d	4c 8d 44 24 58	 lea	 r8, QWORD PTR width$[rsp]
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@EIALIKMK@n?$HMO?$CG?3center?$AA@
  00029	48 8b c8	 mov	 rcx, rax
  0002c	c7 44 24 50 20
	00 00 00	 mov	 DWORD PTR fillchar$[rsp], 32 ; 00000020H
  00034	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00039	85 c0		 test	 eax, eax
  0003b	75 08		 jne	 SHORT $LN3@unicode_ce
$LN8@unicode_ce:

; 10494:         return NULL;

  0003d	33 c0		 xor	 eax, eax

; 10506: }

  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	5b		 pop	 rbx
  00044	c3		 ret	 0
$LN3@unicode_ce:

; 10495: 
; 10496:     if (PyUnicode_READY(self) == -1)

  00045	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00049	75 0d		 jne	 SHORT $LN2@unicode_ce
  0004b	48 8b cb	 mov	 rcx, rbx
  0004e	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00053	83 f8 ff	 cmp	 eax, -1

; 10497:         return NULL;

  00056	74 e5		 je	 SHORT $LN8@unicode_ce
$LN2@unicode_ce:

; 10498: 
; 10499:     if (PyUnicode_GET_LENGTH(self) >= width)

  00058	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  0005c	48 8b 44 24 58	 mov	 rax, QWORD PTR width$[rsp]
  00061	48 3b c8	 cmp	 rcx, rax
  00064	7c 0e		 jl	 SHORT $LN1@unicode_ce

; 10500:         return unicode_result_unchanged(self);

  00066	48 8b cb	 mov	 rcx, rbx
  00069	e8 00 00 00 00	 call	 unicode_result_unchanged

; 10506: }

  0006e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00072	5b		 pop	 rbx
  00073	c3		 ret	 0
$LN1@unicode_ce:

; 10501: 
; 10502:     marg = width - PyUnicode_GET_LENGTH(self);
; 10503:     left = marg / 2 + (marg & width & 1);
; 10504: 
; 10505:     return pad(self, left, marg - left, fillchar);

  00074	44 8b 4c 24 50	 mov	 r9d, DWORD PTR fillchar$[rsp]
  00079	4c 8b c0	 mov	 r8, rax
  0007c	4c 2b c1	 sub	 r8, rcx
  0007f	49 8b c8	 mov	 rcx, r8
  00082	48 23 c8	 and	 rcx, rax
  00085	49 8b c0	 mov	 rax, r8
  00088	48 99		 cdq
  0008a	83 e1 01	 and	 ecx, 1
  0008d	48 2b c2	 sub	 rax, rdx
  00090	48 d1 f8	 sar	 rax, 1
  00093	48 03 c8	 add	 rcx, rax
  00096	4c 2b c1	 sub	 r8, rcx
  00099	48 8b d1	 mov	 rdx, rcx
  0009c	48 8b cb	 mov	 rcx, rbx
  0009f	e8 00 00 00 00	 call	 pad

; 10506: }

  000a4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a8	5b		 pop	 rbx
  000a9	c3		 ret	 0
unicode_center ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@IMJGJOFM@PyUnicode_Append?$AA@	; `string'
PUBLIC	PyUnicode_Append
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_Append DD imagerel $LN40
	DD	imagerel $LN40+55
	DD	imagerel $unwind$PyUnicode_Append
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyUnicode_Append DD imagerel $LN40+55
	DD	imagerel $LN40+642
	DD	imagerel $chain$3$PyUnicode_Append
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyUnicode_Append DD imagerel $LN40+642
	DD	imagerel $LN40+649
	DD	imagerel $chain$4$PyUnicode_Append
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyUnicode_Append DD 021H
	DD	imagerel $LN40
	DD	imagerel $LN40+55
	DD	imagerel $unwind$PyUnicode_Append
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyUnicode_Append DD 081721H
	DD	06d417H
	DD	0cc412H
	DD	0b740aH
	DD	0a5405H
	DD	imagerel $LN40
	DD	imagerel $LN40+55
	DD	imagerel $unwind$PyUnicode_Append
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Append DD 030701H
	DD	060036207H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_0BB@IMJGJOFM@PyUnicode_Append?$AA@
CONST	SEGMENT
??_C@_0BB@IMJGJOFM@PyUnicode_Append?$AA@ DB 'PyUnicode_Append', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_Append
_TEXT	SEGMENT
p_left$ = 80
right$ = 88
PyUnicode_Append PROC					; COMDAT

; 10771: {

$LN40:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00007	48 8b da	 mov	 rbx, rdx
  0000a	48 8b f1	 mov	 rsi, rcx

; 10772:     PyObject *left, *res;
; 10773:     Py_UCS4 maxchar, maxchar2;
; 10774:     Py_ssize_t left_len, right_len, new_len;
; 10775: 
; 10776:     if (p_left == NULL) {

  0000d	48 85 c9	 test	 rcx, rcx
  00010	75 25		 jne	 SHORT $LN19@PyUnicode_@87

; 10777:         if (!PyErr_Occurred())

  00012	e8 00 00 00 00	 call	 PyErr_Occurred
  00017	48 85 c0	 test	 rax, rax
  0001a	0f 85 62 02 00
	00		 jne	 $LN2@PyUnicode_@87

; 10778:             PyErr_BadInternalCall();

  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00027	ba 1a 2a 00 00	 mov	 edx, 10778		; 00002a1aH

; 10853: }

  0002c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00030	5e		 pop	 rsi
  00031	5b		 pop	 rbx
  00032	e9 00 00 00 00	 jmp	 _PyErr_BadInternalCall
$LN19@PyUnicode_@87:
  00037	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0003c	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi

; 10779:         return;
; 10780:     }
; 10781:     left = *p_left;

  00041	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
  00044	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  00049	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13

; 10782:     if (right == NULL || left == NULL || !PyUnicode_Check(left)) {

  0004e	48 85 d2	 test	 rdx, rdx
  00051	0f 84 c0 01 00
	00		 je	 $LN16@PyUnicode_@87
  00057	48 85 ff	 test	 rdi, rdi
  0005a	0f 84 b7 01 00
	00		 je	 $LN16@PyUnicode_@87
  00060	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00064	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0006e	0f 84 a3 01 00
	00		 je	 $LN16@PyUnicode_@87

; 10785:         goto error;
; 10786:     }
; 10787: 
; 10788:     if (PyUnicode_READY(left) == -1)

  00074	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  00078	75 11		 jne	 SHORT $LN34@PyUnicode_@87
  0007a	48 8b cf	 mov	 rcx, rdi
  0007d	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00082	83 f8 ff	 cmp	 eax, -1
  00085	0f 84 a7 01 00
	00		 je	 $error$138077
$LN34@PyUnicode_@87:

; 10789:         goto error;
; 10790:     if (PyUnicode_READY(right) == -1)

  0008b	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  0008f	75 11		 jne	 SHORT $LN35@PyUnicode_@87
  00091	48 8b cb	 mov	 rcx, rbx
  00094	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00099	83 f8 ff	 cmp	 eax, -1
  0009c	0f 84 90 01 00
	00		 je	 $error$138077
$LN35@PyUnicode_@87:

; 10791:         goto error;
; 10792: 
; 10793:     /* Shortcuts */
; 10794:     if (left == unicode_empty) {

  000a2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty
  000a9	48 3b f8	 cmp	 rdi, rax
  000ac	75 18		 jne	 SHORT $LN12@PyUnicode_@87

; 10795:         Py_DECREF(left);

  000ae	48 8b cf	 mov	 rcx, rdi
  000b1	e8 00 00 00 00	 call	 _Py_DecRef

; 10796:         Py_INCREF(right);

  000b6	48 8b cb	 mov	 rcx, rbx
  000b9	e8 00 00 00 00	 call	 _Py_IncRef

; 10797:         *p_left = right;

  000be	48 89 1e	 mov	 QWORD PTR [rsi], rbx

; 10798:         return;

  000c1	e9 a8 01 00 00	 jmp	 $LN39@PyUnicode_@87
$LN12@PyUnicode_@87:

; 10799:     }
; 10800:     if (right == unicode_empty)

  000c6	48 3b d8	 cmp	 rbx, rax
  000c9	0f 84 9f 01 00
	00		 je	 $LN39@PyUnicode_@87

; 10801:         return;
; 10802: 
; 10803:     left_len = PyUnicode_GET_LENGTH(left);
; 10804:     right_len = PyUnicode_GET_LENGTH(right);

  000cf	4c 8b 6b 60	 mov	 r13, QWORD PTR [rbx+96]
  000d3	4c 8b 67 60	 mov	 r12, QWORD PTR [rdi+96]

; 10805:     if (left_len > PY_SSIZE_T_MAX - right_len) {

  000d7	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000e1	49 2b c5	 sub	 rax, r13
  000e4	4c 3b e0	 cmp	 r12, rax
  000e7	7e 18		 jle	 SHORT $LN10@PyUnicode_@87

; 10806:         PyErr_SetString(PyExc_OverflowError,
; 10807:                         "strings are too large to concat");

  000e9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@FKPHENKO@strings?5are?5too?5large?5to?5concat?$AA@
  000f7	e8 00 00 00 00	 call	 PyErr_SetString

; 10808:         goto error;

  000fc	e9 31 01 00 00	 jmp	 $error$138077
$LN10@PyUnicode_@87:

; 10809:     }
; 10810:     new_len = left_len + right_len;
; 10811: 
; 10812:     if (unicode_modifiable(left)
; 10813:         && PyUnicode_CheckExact(right)
; 10814:         && PyUnicode_KIND(right) <= PyUnicode_KIND(left)
; 10815:         /* Don't resize for ascii += latin1. Convert ascii to latin1 requires
; 10816:            to change the structure size, but characters are stored just after
; 10817:            the structure, and so it requires to move all characters which is
; 10818:            not so different than duplicating the string. */
; 10819:         && !(PyUnicode_IS_ASCII(left) && !PyUnicode_IS_ASCII(right)))

  00101	48 8b cf	 mov	 rcx, rdi
  00104	4b 8d 6c 25 00	 lea	 rbp, QWORD PTR [r13+r12]
  00109	e8 00 00 00 00	 call	 unicode_modifiable
  0010e	85 c0		 test	 eax, eax
  00110	74 5f		 je	 SHORT $LN9@PyUnicode_@87
  00112	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00119	48 39 43 58	 cmp	 QWORD PTR [rbx+88], rax
  0011d	75 52		 jne	 SHORT $LN9@PyUnicode_@87
  0011f	44 8b 47 70	 mov	 r8d, DWORD PTR [rdi+112]
  00123	44 8b 4b 70	 mov	 r9d, DWORD PTR [rbx+112]
  00127	41 8b c9	 mov	 ecx, r9d
  0012a	41 8b c0	 mov	 eax, r8d
  0012d	83 e1 1c	 and	 ecx, 28
  00130	83 e0 1c	 and	 eax, 28
  00133	3a c8		 cmp	 cl, al
  00135	77 3a		 ja	 SHORT $LN9@PyUnicode_@87
  00137	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  0013b	74 06		 je	 SHORT $LN8@PyUnicode_@87
  0013d	41 f6 c1 40	 test	 r9b, 64			; 00000040H
  00141	74 2e		 je	 SHORT $LN9@PyUnicode_@87
$LN8@PyUnicode_@87:

; 10820:     {
; 10821:         /* append inplace */
; 10822:         if (unicode_resize(p_left, new_len) != 0) {

  00143	48 8b d5	 mov	 rdx, rbp
  00146	48 8b ce	 mov	 rcx, rsi
  00149	e8 00 00 00 00	 call	 unicode_resize
  0014e	85 c0		 test	 eax, eax
  00150	0f 85 dc 00 00
	00		 jne	 $error$138077

; 10823:             /* XXX if _PyUnicode_Resize() fails, 'left' has been
; 10824:              * deallocated so it cannot be put back into
; 10825:              * 'variable'.  The MemoryError is raised when there
; 10826:              * is no value in 'variable', which might (very
; 10827:              * remotely) be a cause of incompatibilities.
; 10828:              */
; 10829:             goto error;
; 10830:         }
; 10831:         /* copy 'right' into the newly allocated area of 'left' */
; 10832:         _PyUnicode_FastCopyCharacters(*p_left, left_len, right, 0, right_len);

  00156	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00159	45 33 c9	 xor	 r9d, r9d
  0015c	4c 8b c3	 mov	 r8, rbx
  0015f	49 8b d4	 mov	 rdx, r12
  00162	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00167	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 10833:     }
; 10834:     else {

  0016c	e9 fd 00 00 00	 jmp	 $LN39@PyUnicode_@87
$LN9@PyUnicode_@87:

; 10835:         maxchar = PyUnicode_MAX_CHAR_VALUE(left);

  00171	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00174	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00179	41 b8 ff ff 00
	00		 mov	 r8d, 65535		; 0000ffffH
  0017f	a8 40		 test	 al, 64			; 00000040H
  00181	74 04		 je	 SHORT $LN28@PyUnicode_@87
  00183	8b ca		 mov	 ecx, edx
  00185	eb 1e		 jmp	 SHORT $LN27@PyUnicode_@87
$LN28@PyUnicode_@87:
  00187	c1 e8 02	 shr	 eax, 2
  0018a	83 e0 07	 and	 eax, 7
  0018d	83 f8 01	 cmp	 eax, 1
  00190	75 07		 jne	 SHORT $LN26@PyUnicode_@87
  00192	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00197	eb 0c		 jmp	 SHORT $LN27@PyUnicode_@87
$LN26@PyUnicode_@87:
  00199	b9 ff ff 10 00	 mov	 ecx, 1114111		; 0010ffffH
  0019e	83 f8 02	 cmp	 eax, 2
  001a1	41 0f 44 c8	 cmove	 ecx, r8d
$LN27@PyUnicode_@87:

; 10836:         maxchar2 = PyUnicode_MAX_CHAR_VALUE(right);

  001a5	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  001a8	a8 40		 test	 al, 64			; 00000040H
  001aa	75 1e		 jne	 SHORT $LN31@PyUnicode_@87
  001ac	c1 e8 02	 shr	 eax, 2
  001af	83 e0 07	 and	 eax, 7
  001b2	83 f8 01	 cmp	 eax, 1
  001b5	75 07		 jne	 SHORT $LN30@PyUnicode_@87
  001b7	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  001bc	eb 0c		 jmp	 SHORT $LN31@PyUnicode_@87
$LN30@PyUnicode_@87:
  001be	ba ff ff 10 00	 mov	 edx, 1114111		; 0010ffffH
  001c3	83 f8 02	 cmp	 eax, 2
  001c6	41 0f 44 d0	 cmove	 edx, r8d
$LN31@PyUnicode_@87:

; 10837:         maxchar = Py_MAX(maxchar, maxchar2);

  001ca	3b ca		 cmp	 ecx, edx
  001cc	0f 47 d1	 cmova	 edx, ecx

; 10838: 
; 10839:         /* Concat the two Unicode strings */
; 10840:         res = PyUnicode_New(new_len, maxchar);

  001cf	48 8b cd	 mov	 rcx, rbp
  001d2	e8 00 00 00 00	 call	 PyUnicode_New
  001d7	48 8b e8	 mov	 rbp, rax

; 10841:         if (res == NULL)

  001da	48 85 c0	 test	 rax, rax
  001dd	74 53		 je	 SHORT $error$138077

; 10842:             goto error;
; 10843:         _PyUnicode_FastCopyCharacters(res, 0, left, 0, left_len);

  001df	45 33 c9	 xor	 r9d, r9d
  001e2	4c 8b c7	 mov	 r8, rdi
  001e5	33 d2		 xor	 edx, edx
  001e7	48 8b c8	 mov	 rcx, rax
  001ea	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  001ef	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 10844:         _PyUnicode_FastCopyCharacters(res, left_len, right, 0, right_len);

  001f4	45 33 c9	 xor	 r9d, r9d
  001f7	4c 8b c3	 mov	 r8, rbx
  001fa	49 8b d4	 mov	 rdx, r12
  001fd	48 8b cd	 mov	 rcx, rbp
  00200	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00205	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 10845:         Py_DECREF(left);

  0020a	48 8b cf	 mov	 rcx, rdi
  0020d	e8 00 00 00 00	 call	 _Py_DecRef

; 10846:         *p_left = res;

  00212	48 89 2e	 mov	 QWORD PTR [rsi], rbp

; 10847:     }
; 10848:     assert(_PyUnicode_CheckConsistency(*p_left, 1));
; 10849:     return;

  00215	eb 57		 jmp	 SHORT $LN39@PyUnicode_@87
$LN16@PyUnicode_@87:

; 10783:         if (!PyErr_Occurred())

  00217	e8 00 00 00 00	 call	 PyErr_Occurred
  0021c	48 85 c0	 test	 rax, rax
  0021f	75 11		 jne	 SHORT $error$138077

; 10784:             PyErr_BadInternalCall();

  00221	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00228	ba 20 2a 00 00	 mov	 edx, 10784		; 00002a20H
  0022d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall
$error$138077:

; 10850: 
; 10851: error:
; 10852:     Py_CLEAR(*p_left);

  00232	4c 8b 0e	 mov	 r9, QWORD PTR [rsi]
  00235	4d 85 c9	 test	 r9, r9
  00238	74 34		 je	 SHORT $LN39@PyUnicode_@87
  0023a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00241	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@IMJGJOFM@PyUnicode_Append?$AA@
  00248	41 b8 64 2a 00
	00		 mov	 r8d, 10852		; 00002a64H
  0024e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00256	e8 00 00 00 00	 call	 _PyParallel_Guard
  0025b	85 c0		 test	 eax, eax
  0025d	75 0f		 jne	 SHORT $LN39@PyUnicode_@87
  0025f	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00262	48 c7 06 00 00
	00 00		 mov	 QWORD PTR [rsi], 0
  00269	e8 00 00 00 00	 call	 _Py_DecRef
$LN39@PyUnicode_@87:
  0026e	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]
  00273	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00278	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0027d	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]
$LN2@PyUnicode_@87:

; 10853: }

  00282	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00286	5e		 pop	 rsi
  00287	5b		 pop	 rbx
  00288	c3		 ret	 0
PyUnicode_Append ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AppendAndDel
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyUnicode_AppendAndDel DD imagerel $LN18
	DD	imagerel $LN18+133
	DD	imagerel $unwind$PyUnicode_AppendAndDel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_AppendAndDel DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT PyUnicode_AppendAndDel
_TEXT	SEGMENT
pleft$ = 64
right$ = 72
PyUnicode_AppendAndDel PROC				; COMDAT

; 10857: {

$LN18:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b da	 mov	 rbx, rdx

; 10858:     PyUnicode_Append(pleft, right);

  00009	e8 00 00 00 00	 call	 PyUnicode_Append

; 10859:     Py_XDECREF(right);

  0000e	48 85 db	 test	 rbx, rbx
  00011	74 6c		 je	 SHORT $LN3@PyUnicode_@88
  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	75 63		 jne	 SHORT $LN3@PyUnicode_@88
  0001c	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00020	a8 20		 test	 al, 32			; 00000020H
  00022	75 53		 jne	 SHORT $LN11@PyUnicode_@88
  00024	84 c0		 test	 al, al
  00026	78 4f		 js	 SHORT $LN11@PyUnicode_@88
  00028	a8 02		 test	 al, 2
  0002a	75 53		 jne	 SHORT $LN3@PyUnicode_@88
  0002c	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00030	75 4d		 jne	 SHORT $LN3@PyUnicode_@88
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00040	4c 8b cb	 mov	 r9, rbx
  00043	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00049	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00051	e8 00 00 00 00	 call	 _PyParallel_Guard
  00056	48 8b cb	 mov	 rcx, rbx
  00059	85 c0		 test	 eax, eax
  0005b	74 0a		 je	 SHORT $LN16@PyUnicode_@88

; 10860: }

  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5b		 pop	 rbx
  00062	e9 00 00 00 00	 jmp	 _Px_Dealloc

; 10859:     Py_XDECREF(right);

$LN16@PyUnicode_@88:
  00067	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 10860: }

  0006b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006f	5b		 pop	 rbx
  00070	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]

; 10859:     Py_XDECREF(right);

$LN11@PyUnicode_@88:
  00077	48 8b cb	 mov	 rcx, rbx
  0007a	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PyUnicode_@88:

; 10860: }

  0007f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00083	5b		 pop	 rbx
  00084	c3		 ret	 0
PyUnicode_AppendAndDel ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\find.h
pdata	SEGMENT
$pdata$unicode_count DD imagerel unicode_count
	DD	imagerel unicode_count+279
	DD	imagerel $unwind$unicode_count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$unicode_count DD imagerel unicode_count+279
	DD	imagerel unicode_count+331
	DD	imagerel $chain$1$unicode_count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$unicode_count DD imagerel unicode_count+331
	DD	imagerel unicode_count+453
	DD	imagerel $chain$2$unicode_count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$unicode_count DD imagerel unicode_count+453
	DD	imagerel unicode_count+483
	DD	imagerel $chain$3$unicode_count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$unicode_count DD imagerel unicode_count+483
	DD	imagerel unicode_count+709
	DD	imagerel $chain$5$unicode_count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$unicode_count DD imagerel unicode_count+709
	DD	imagerel unicode_count+725
	DD	imagerel $chain$6$unicode_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$unicode_count DD 021H
	DD	imagerel unicode_count
	DD	imagerel unicode_count+279
	DD	imagerel $unwind$unicode_count
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$unicode_count DD 060021H
	DD	012e400H
	DD	013d400H
	DD	01ac400H
	DD	imagerel unicode_count
	DD	imagerel unicode_count+279
	DD	imagerel $unwind$unicode_count
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$unicode_count DD 021H
	DD	imagerel unicode_count+279
	DD	imagerel unicode_count+331
	DD	imagerel $chain$1$unicode_count
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$unicode_count DD 020821H
	DD	013d408H
	DD	imagerel unicode_count+279
	DD	imagerel unicode_count+331
	DD	imagerel $chain$1$unicode_count
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$unicode_count DD 041021H
	DD	012e410H
	DD	01ac408H
	DD	imagerel unicode_count
	DD	imagerel unicode_count+279
	DD	imagerel $unwind$unicode_count
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_count DD 071301H
	DD	0140113H
	DD	07005f007H
	DD	030036004H
	DD	05002H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT unicode_count
_TEXT	SEGMENT
obj_end$162132 = 48
tmp_start$162129 = 56
tmp_end$162130 = 64
tmp_subobj$162128 = 72
format$162133 = 80
self$ = 208
args$ = 216
buf1$1$ = 224
obj_start$162131 = 232
unicode_count PROC					; COMDAT

; 10871: {

  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 57		 push	 r15
  00007	48 8d 6c 24 c9	 lea	 rbp, QWORD PTR [rsp-55]
  0000c	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00013	4c 8b f9	 mov	 r15, rcx

; 10872:     PyObject *substring;
; 10873:     Py_ssize_t start = 0;
; 10874:     Py_ssize_t end = PY_SSIZE_T_MAX;
; 10875:     PyObject *result;
; 10876:     int kind1, kind2, kind;
; 10877:     void *buf1, *buf2;
; 10878:     Py_ssize_t len1, len2, iresult;
; 10879: 
; 10880:     if (!stringlib_parse_args_finds_unicode("count", args, &substring,
; 10881:                                             &start, &end))

  00016	48 83 c9 ff	 or	 rcx, -1
  0001a	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00024	48 89 45 d7	 mov	 QWORD PTR tmp_end$162130[rbp-105], rax
  00028	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@
  0002e	48 8b da	 mov	 rbx, rdx
  00031	89 45 e7	 mov	 DWORD PTR format$162133[rbp-105], eax
  00034	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@+4
  0003b	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  00042	66 89 45 eb	 mov	 WORD PTR format$162133[rbp-101], ax
  00046	33 c0		 xor	 eax, eax
  00048	48 8d 7d e7	 lea	 rdi, QWORD PTR format$162133[rbp-105]
  0004c	48 89 45 ed	 mov	 QWORD PTR format$162133[rbp-99], rax
  00050	48 89 45 f5	 mov	 QWORD PTR format$162133[rbp-91], rax
  00054	48 89 45 fd	 mov	 QWORD PTR format$162133[rbp-83], rax
  00058	48 89 45 05	 mov	 QWORD PTR format$162133[rbp-75], rax
  0005c	48 89 45 0d	 mov	 QWORD PTR format$162133[rbp-67], rax
  00060	89 45 15	 mov	 DWORD PTR format$162133[rbp-59], eax
  00063	f2 ae		 repne scasb
  00065	41 b8 31 00 00
	00		 mov	 r8d, 49			; 00000031H
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05IOMEMJEC@count?$AA@
  00072	48 f7 d1	 not	 rcx
  00075	48 c7 45 cf 00
	00 00 00	 mov	 QWORD PTR tmp_start$162129[rbp-105], 0
  0007d	48 89 75 7f	 mov	 QWORD PTR obj_start$162131[rbp-105], rsi
  00081	48 ff c9	 dec	 rcx
  00084	48 89 75 c7	 mov	 QWORD PTR obj_end$162132[rbp-105], rsi
  00088	4c 2b c1	 sub	 r8, rcx
  0008b	48 8d 4c 0d e7	 lea	 rcx, QWORD PTR format$162133[rbp+rcx-105]
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
  00096	48 8d 45 c7	 lea	 rax, QWORD PTR obj_end$162132[rbp-105]
  0009a	4c 8d 4d 7f	 lea	 r9, QWORD PTR obj_start$162131[rbp-105]
  0009e	4c 8d 45 df	 lea	 r8, QWORD PTR tmp_subobj$162128[rbp-105]
  000a2	48 8d 55 e7	 lea	 rdx, QWORD PTR format$162133[rbp-105]
  000a6	48 8b cb	 mov	 rcx, rbx
  000a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ae	c6 45 18 00	 mov	 BYTE PTR format$162133[rbp-56], 0
  000b2	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000b7	85 c0		 test	 eax, eax
  000b9	0f 84 06 02 00
	00		 je	 $LN29@unicode_co@3
  000bf	48 8b 4d 7f	 mov	 rcx, QWORD PTR obj_start$162131[rbp-105]
  000c3	48 3b ce	 cmp	 rcx, rsi
  000c6	74 11		 je	 SHORT $LN34@unicode_co@3
  000c8	48 8d 55 cf	 lea	 rdx, QWORD PTR tmp_start$162129[rbp-105]
  000cc	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000d1	85 c0		 test	 eax, eax
  000d3	0f 84 ec 01 00
	00		 je	 $LN29@unicode_co@3
$LN34@unicode_co@3:
  000d9	48 8b 4d c7	 mov	 rcx, QWORD PTR obj_end$162132[rbp-105]
  000dd	48 3b ce	 cmp	 rcx, rsi
  000e0	74 11		 je	 SHORT $LN32@unicode_co@3
  000e2	48 8d 55 d7	 lea	 rdx, QWORD PTR tmp_end$162130[rbp-105]
  000e6	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000eb	85 c0		 test	 eax, eax
  000ed	0f 84 d2 01 00
	00		 je	 $LN29@unicode_co@3
$LN32@unicode_co@3:
  000f3	48 8b 4d df	 mov	 rcx, QWORD PTR tmp_subobj$162128[rbp-105]
  000f7	48 8b 75 cf	 mov	 rsi, QWORD PTR tmp_start$162129[rbp-105]
  000fb	48 8b 7d d7	 mov	 rdi, QWORD PTR tmp_end$162130[rbp-105]
  000ff	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00104	48 8b d8	 mov	 rbx, rax
  00107	48 85 c0	 test	 rax, rax
  0010a	0f 84 b5 01 00
	00		 je	 $LN29@unicode_co@3

; 10883: 
; 10884:     kind1 = PyUnicode_KIND(self);

  00110	41 8b 47 70	 mov	 eax, DWORD PTR [r15+112]

; 10885:     kind2 = PyUnicode_KIND(substring);

  00114	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00117	4c 89 a4 24 d0
	00 00 00	 mov	 QWORD PTR [rsp+208], r12
  0011f	4c 89 b4 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], r14
  00127	44 8b e0	 mov	 r12d, eax
  0012a	44 8b f1	 mov	 r14d, ecx
  0012d	41 c1 ec 02	 shr	 r12d, 2
  00131	41 c1 ee 02	 shr	 r14d, 2
  00135	41 83 e4 07	 and	 r12d, 7
  00139	41 83 e6 07	 and	 r14d, 7

; 10886:     if (kind2 > kind1)

  0013d	45 3b f4	 cmp	 r14d, r12d
  00140	7e 09		 jle	 SHORT $LN16@unicode_co@3

; 10887:         return PyLong_FromLong(0);

  00142	33 c9		 xor	 ecx, ecx
  00144	e8 00 00 00 00	 call	 PyLong_FromLong
  00149	eb 7a		 jmp	 SHORT $LN43@unicode_co@3
$LN16@unicode_co@3:
  0014b	4c 89 ac 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], r13

; 10888:     kind = kind1;
; 10889:     buf1 = PyUnicode_DATA(self);

  00153	a8 20		 test	 al, 32			; 00000020H
  00155	74 16		 je	 SHORT $LN22@unicode_co@3
  00157	a8 40		 test	 al, 64			; 00000040H
  00159	74 09		 je	 SHORT $LN20@unicode_co@3
  0015b	49 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [r15+128]
  00162	eb 10		 jmp	 SHORT $LN45@unicode_co@3
$LN20@unicode_co@3:
  00164	49 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [r15+160]
  0016b	eb 07		 jmp	 SHORT $LN45@unicode_co@3
$LN22@unicode_co@3:
  0016d	49 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [r15+160]
$LN45@unicode_co@3:
  00174	48 89 45 77	 mov	 QWORD PTR buf1$1$[rbp-105], rax

; 10890:     buf2 = PyUnicode_DATA(substring);

  00178	f6 c1 20	 test	 cl, 32			; 00000020H
  0017b	74 17		 je	 SHORT $LN26@unicode_co@3
  0017d	f6 c1 40	 test	 cl, 64			; 00000040H
  00180	74 09		 je	 SHORT $LN24@unicode_co@3
  00182	4c 8d ab 80 00
	00 00		 lea	 r13, QWORD PTR [rbx+128]
  00189	eb 10		 jmp	 SHORT $LN27@unicode_co@3
$LN24@unicode_co@3:
  0018b	4c 8d ab a0 00
	00 00		 lea	 r13, QWORD PTR [rbx+160]
  00192	eb 07		 jmp	 SHORT $LN27@unicode_co@3
$LN26@unicode_co@3:
  00194	4c 8b ab a0 00
	00 00		 mov	 r13, QWORD PTR [rbx+160]
$LN27@unicode_co@3:

; 10891:     if (kind2 != kind)

  0019b	45 3b f4	 cmp	 r14d, r12d
  0019e	74 0e		 je	 SHORT $LN15@unicode_co@3

; 10892:         buf2 = _PyUnicode_AsKind(substring, kind);

  001a0	41 8b d4	 mov	 edx, r12d
  001a3	48 8b cb	 mov	 rcx, rbx
  001a6	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  001ab	4c 8b e8	 mov	 r13, rax
$LN15@unicode_co@3:

; 10893:     if (!buf2) {

  001ae	4d 85 ed	 test	 r13, r13
  001b1	75 30		 jne	 SHORT $LN14@unicode_co@3

; 10894:         Py_DECREF(substring);

  001b3	48 8b cb	 mov	 rcx, rbx
  001b6	e8 00 00 00 00	 call	 _Py_DecRef

; 10895:         return NULL;

  001bb	33 c0		 xor	 eax, eax
$LN44@unicode_co@3:
  001bd	4c 8b ac 24 98
	00 00 00	 mov	 r13, QWORD PTR [rsp+152]
$LN43@unicode_co@3:
  001c5	4c 8b a4 24 d0
	00 00 00	 mov	 r12, QWORD PTR [rsp+208]
  001cd	4c 8b b4 24 90
	00 00 00	 mov	 r14, QWORD PTR [rsp+144]

; 10932: }

  001d5	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  001dc	41 5f		 pop	 r15
  001de	5f		 pop	 rdi
  001df	5e		 pop	 rsi
  001e0	5b		 pop	 rbx
  001e1	5d		 pop	 rbp
  001e2	c3		 ret	 0
$LN14@unicode_co@3:

; 10896:     }
; 10897:     len1 = PyUnicode_GET_LENGTH(self);

  001e3	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]

; 10898:     len2 = PyUnicode_GET_LENGTH(substring);

  001e7	4c 8b 4b 60	 mov	 r9, QWORD PTR [rbx+96]

; 10899: 
; 10900:     ADJUST_INDICES(start, end, len1);

  001eb	48 3b f8	 cmp	 rdi, rax
  001ee	7e 4c		 jle	 SHORT $LN13@unicode_co@3
  001f0	48 8b f8	 mov	 rdi, rax
$LN41@unicode_co@3:

; 10888:     kind = kind1;
; 10889:     buf1 = PyUnicode_DATA(self);

  001f3	33 d2		 xor	 edx, edx
$LN10@unicode_co@3:

; 10899: 
; 10900:     ADJUST_INDICES(start, end, len1);

  001f5	48 85 f6	 test	 rsi, rsi
  001f8	79 07		 jns	 SHORT $LN8@unicode_co@3
  001fa	48 03 f0	 add	 rsi, rax
  001fd	48 0f 48 f2	 cmovs	 rsi, rdx
$LN8@unicode_co@3:

; 10901:     switch (kind) {

  00201	41 8b cc	 mov	 ecx, r12d
  00204	ff c9		 dec	 ecx
  00206	74 6e		 je	 SHORT $LN5@unicode_co@3
  00208	ff c9		 dec	 ecx
  0020a	74 43		 je	 SHORT $LN4@unicode_co@3
  0020c	83 f9 02	 cmp	 ecx, 2
  0020f	0f 85 88 00 00
	00		 jne	 $LN6@unicode_co@3

; 10914:     case PyUnicode_4BYTE_KIND:
; 10915:         iresult = ucs4lib_count(
; 10916:             ((Py_UCS4*)buf1) + start, end - start,
; 10917:             buf2, len2, PY_SSIZE_T_MAX
; 10918:             );

  00215	48 8b 45 77	 mov	 rax, QWORD PTR buf1$1$[rbp-105]
  00219	48 2b fe	 sub	 rdi, rsi
  0021c	4d 8b c5	 mov	 r8, r13
  0021f	48 8d 0c b0	 lea	 rcx, QWORD PTR [rax+rsi*4]
  00223	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0022d	48 8b d7	 mov	 rdx, rdi
  00230	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00235	e8 00 00 00 00	 call	 ucs4lib_count

; 10919:         break;

  0023a	eb 5e		 jmp	 SHORT $LN46@unicode_co@3
$LN13@unicode_co@3:

; 10899: 
; 10900:     ADJUST_INDICES(start, end, len1);

  0023c	48 85 ff	 test	 rdi, rdi
  0023f	79 b2		 jns	 SHORT $LN41@unicode_co@3
  00241	48 03 f8	 add	 rdi, rax
  00244	ba 00 00 00 00	 mov	 edx, 0
  00249	48 0f 48 fa	 cmovs	 rdi, rdx
  0024d	eb a6		 jmp	 SHORT $LN10@unicode_co@3
$LN4@unicode_co@3:

; 10907:         break;
; 10908:     case PyUnicode_2BYTE_KIND:
; 10909:         iresult = ucs2lib_count(
; 10910:             ((Py_UCS2*)buf1) + start, end - start,
; 10911:             buf2, len2, PY_SSIZE_T_MAX
; 10912:             );

  0024f	48 8b 45 77	 mov	 rax, QWORD PTR buf1$1$[rbp-105]
  00253	48 2b fe	 sub	 rdi, rsi
  00256	4d 8b c5	 mov	 r8, r13
  00259	48 8d 0c 70	 lea	 rcx, QWORD PTR [rax+rsi*2]
  0025d	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00267	48 8b d7	 mov	 rdx, rdi
  0026a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0026f	e8 00 00 00 00	 call	 ucs2lib_count

; 10913:         break;

  00274	eb 24		 jmp	 SHORT $LN46@unicode_co@3
$LN5@unicode_co@3:

; 10902:     case PyUnicode_1BYTE_KIND:
; 10903:         iresult = ucs1lib_count(
; 10904:             ((Py_UCS1*)buf1) + start, end - start,
; 10905:             buf2, len2, PY_SSIZE_T_MAX
; 10906:             );

  00276	48 8b 4d 77	 mov	 rcx, QWORD PTR buf1$1$[rbp-105]
  0027a	48 2b fe	 sub	 rdi, rsi
  0027d	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00287	48 03 ce	 add	 rcx, rsi
  0028a	4d 8b c5	 mov	 r8, r13
  0028d	48 8b d7	 mov	 rdx, rdi
  00290	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00295	e8 00 00 00 00	 call	 ucs1lib_count
$LN46@unicode_co@3:
  0029a	48 8b d0	 mov	 rdx, rax
$LN6@unicode_co@3:

; 10920:     default:
; 10921:         assert(0); iresult = 0;
; 10922:     }
; 10923: 
; 10924:     result = PyLong_FromSsize_t(iresult);

  0029d	48 8b ca	 mov	 rcx, rdx
  002a0	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  002a5	48 8b f8	 mov	 rdi, rax

; 10925: 
; 10926:     if (kind2 != kind)

  002a8	45 3b f4	 cmp	 r14d, r12d
  002ab	74 08		 je	 SHORT $LN1@unicode_co@3

; 10927:         PyMem_Free(buf2);

  002ad	49 8b cd	 mov	 rcx, r13
  002b0	e8 00 00 00 00	 call	 PyMem_Free
$LN1@unicode_co@3:

; 10928: 
; 10929:     Py_DECREF(substring);

  002b5	48 8b cb	 mov	 rcx, rbx
  002b8	e8 00 00 00 00	 call	 _Py_DecRef

; 10930: 
; 10931:     return result;

  002bd	48 8b c7	 mov	 rax, rdi
  002c0	e9 f8 fe ff ff	 jmp	 $LN44@unicode_co@3

; 10872:     PyObject *substring;
; 10873:     Py_ssize_t start = 0;
; 10874:     Py_ssize_t end = PY_SSIZE_T_MAX;
; 10875:     PyObject *result;
; 10876:     int kind1, kind2, kind;
; 10877:     void *buf1, *buf2;
; 10878:     Py_ssize_t len1, len2, iresult;
; 10879: 
; 10880:     if (!stringlib_parse_args_finds_unicode("count", args, &substring,
; 10881:                                             &start, &end))

$LN29@unicode_co@3:

; 10882:         return NULL;

  002c5	33 c0		 xor	 eax, eax

; 10932: }

  002c7	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  002ce	41 5f		 pop	 r15
  002d0	5f		 pop	 rdi
  002d1	5e		 pop	 rsi
  002d2	5b		 pop	 rbx
  002d3	5d		 pop	 rbp
  002d4	c3		 ret	 0
unicode_count ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@JJIGIBLH@new?5string?5is?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0O@DJDMKPID@?$HMi?3expandtabs?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_expandtabs DD imagerel unicode_expandtabs
	DD	imagerel unicode_expandtabs+769
	DD	imagerel $unwind$unicode_expandtabs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_expandtabs DD 010b001H
	DD	08d4b0H
	DD	09c4abH
	DD	0b64a3H
	DD	06f475H
	DD	07e45eH
	DD	0a7459H
	DD	0e5450H
	DD	03004b208H
xdata	ENDS
;	COMDAT ??_C@_0BH@JJIGIBLH@new?5string?5is?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BH@JJIGIBLH@new?5string?5is?5too?5long?$AA@ DB 'new string is too '
	DB	'long', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DJDMKPID@?$HMi?3expandtabs?$AA@
CONST	SEGMENT
??_C@_0O@DJDMKPID@?$HMi?3expandtabs?$AA@ DB '|i:expandtabs', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_expandtabs
_TEXT	SEGMENT
u$1$ = 32
self$ = 112
args$ = 120
tabsize$ = 128
src_len$1$ = 136
unicode_expandtabs PROC					; COMDAT

; 10965: {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00008	48 8b c2	 mov	 rax, rdx
  0000b	48 8b d9	 mov	 rbx, rcx

; 10966:     Py_ssize_t i, j, line_pos, src_len, incr;
; 10967:     Py_UCS4 ch;
; 10968:     PyObject *u;
; 10969:     void *src_data, *dest_data;
; 10970:     int tabsize = 8;
; 10971:     int kind;
; 10972:     int found;
; 10973: 
; 10974:     if (!PyArg_ParseTuple(args, "|i:expandtabs", &tabsize))

  0000e	4d 8d 43 18	 lea	 r8, QWORD PTR [r11+24]
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@DJDMKPID@?$HMi?3expandtabs?$AA@
  00019	48 8b c8	 mov	 rcx, rax
  0001c	41 c7 43 18 08
	00 00 00	 mov	 DWORD PTR [r11+24], 8
  00024	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 08		 jne	 SHORT $LN45@unicode_ex
$LN90@unicode_ex:

; 10975:         return NULL;

  0002d	33 c0		 xor	 eax, eax

; 11042: }

  0002f	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00033	5b		 pop	 rbx
  00034	c3		 ret	 0
$LN45@unicode_ex:

; 10976: 
; 10977:     if (PyUnicode_READY(self) == -1)

  00035	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00039	75 0d		 jne	 SHORT $LN44@unicode_ex
  0003b	48 8b cb	 mov	 rcx, rbx
  0003e	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00043	83 f8 ff	 cmp	 eax, -1

; 10978:         return NULL;

  00046	74 e5		 je	 SHORT $LN90@unicode_ex
$LN44@unicode_ex:

; 10979: 
; 10980:     /* First pass: determine size of output string */
; 10981:     src_len = PyUnicode_GET_LENGTH(self);
; 10982:     i = j = line_pos = 0;
; 10983:     kind = PyUnicode_KIND(self);

  00048	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0004b	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  00050	48 8b 6b 60	 mov	 rbp, QWORD PTR [rbx+96]
  00054	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00059	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  0005e	44 8b f0	 mov	 r14d, eax
  00061	41 c1 ee 02	 shr	 r14d, 2
  00065	45 33 c0	 xor	 r8d, r8d
  00068	33 ff		 xor	 edi, edi
  0006a	33 c9		 xor	 ecx, ecx
  0006c	41 83 e6 07	 and	 r14d, 7
  00070	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  00075	48 89 ac 24 88
	00 00 00	 mov	 QWORD PTR src_len$1$[rsp], rbp

; 10984:     src_data = PyUnicode_DATA(self);

  0007d	a8 20		 test	 al, 32			; 00000020H
  0007f	74 16		 je	 SHORT $LN52@unicode_ex
  00081	a8 40		 test	 al, 64			; 00000040H
  00083	74 09		 je	 SHORT $LN50@unicode_ex
  00085	4c 8d bb 80 00
	00 00		 lea	 r15, QWORD PTR [rbx+128]
  0008c	eb 10		 jmp	 SHORT $LN53@unicode_ex
$LN50@unicode_ex:
  0008e	4c 8d bb a0 00
	00 00		 lea	 r15, QWORD PTR [rbx+160]
  00095	eb 07		 jmp	 SHORT $LN53@unicode_ex
$LN52@unicode_ex:
  00097	4c 8b bb a0 00
	00 00		 mov	 r15, QWORD PTR [rbx+160]
$LN53@unicode_ex:
  0009e	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi

; 10985:     found = 0;

  000a3	45 33 db	 xor	 r11d, r11d
  000a6	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  000ab	4c 89 6c 24 40	 mov	 QWORD PTR [rsp+64], r13

; 10987:         ch = PyUnicode_READ(kind, src_data, i);

  000b0	4d 63 d6	 movsxd	 r10, r14d
  000b3	48 85 ed	 test	 rbp, rbp
  000b6	0f 8e 14 02 00
	00		 jle	 $LN80@unicode_ex

; 10986:     for (; i < src_len; i++) {

  000bc	48 63 b4 24 80
	00 00 00	 movsxd	 rsi, DWORD PTR tabsize$[rsp]
  000c4	49 bd ff ff ff
	ff ff ff ff 7f	 mov	 r13, 9223372036854775807 ; 7fffffffffffffffH
  000ce	49 bc fe ff ff
	ff ff ff ff 7f	 mov	 r12, 9223372036854775806 ; 7ffffffffffffffeH
$LL43@unicode_ex:

; 10987:         ch = PyUnicode_READ(kind, src_data, i);

  000d8	49 83 fa 01	 cmp	 r10, 1
  000dc	75 07		 jne	 SHORT $LN56@unicode_ex
  000de	41 0f b6 04 0f	 movzx	 eax, BYTE PTR [r15+rcx]
  000e3	eb 11		 jmp	 SHORT $LN55@unicode_ex
$LN56@unicode_ex:
  000e5	49 83 fa 02	 cmp	 r10, 2
  000e9	75 07		 jne	 SHORT $LN54@unicode_ex
  000eb	41 0f b7 04 4f	 movzx	 eax, WORD PTR [r15+rcx*2]
  000f0	eb 04		 jmp	 SHORT $LN55@unicode_ex
$LN54@unicode_ex:
  000f2	41 8b 04 8f	 mov	 eax, DWORD PTR [r15+rcx*4]
$LN55@unicode_ex:

; 10988:         if (ch == '\t') {

  000f6	83 f8 09	 cmp	 eax, 9
  000f9	75 2d		 jne	 SHORT $LN40@unicode_ex

; 10989:             found = 1;

  000fb	44 8d 58 f8	 lea	 r11d, QWORD PTR [rax-8]

; 10990:             if (tabsize > 0) {

  000ff	85 f6		 test	 esi, esi
  00101	7e 41		 jle	 SHORT $LN42@unicode_ex

; 10991:                 incr = tabsize - (line_pos % tabsize); /* cannot overflow */

  00103	49 8b c0	 mov	 rax, r8
  00106	4c 8b ce	 mov	 r9, rsi
  00109	48 99		 cdq
  0010b	48 f7 fe	 idiv	 rsi

; 10992:                 if (j > PY_SSIZE_T_MAX - incr)

  0010e	49 8b c5	 mov	 rax, r13
  00111	4c 2b ca	 sub	 r9, rdx
  00114	49 2b c1	 sub	 rax, r9
  00117	48 3b f8	 cmp	 rdi, rax
  0011a	0f 8f 99 01 00
	00		 jg	 $overflow$138321

; 10993:                     goto overflow;
; 10994:                 line_pos += incr;

  00120	4d 03 c1	 add	 r8, r9

; 10995:                 j += incr;

  00123	49 03 f9	 add	 rdi, r9

; 10996:             }
; 10997:         }
; 10998:         else {

  00126	eb 1c		 jmp	 SHORT $LN42@unicode_ex
$LN40@unicode_ex:

; 10999:             if (j > PY_SSIZE_T_MAX - 1)

  00128	49 3b fc	 cmp	 rdi, r12
  0012b	0f 8f 88 01 00
	00		 jg	 $overflow$138321

; 11000:                 goto overflow;
; 11001:             line_pos++;

  00131	49 ff c0	 inc	 r8

; 11002:             j++;

  00134	48 ff c7	 inc	 rdi

; 11003:             if (ch == '\n' || ch == '\r')

  00137	83 f8 0a	 cmp	 eax, 10
  0013a	74 05		 je	 SHORT $LN34@unicode_ex
  0013c	83 f8 0d	 cmp	 eax, 13
  0013f	75 03		 jne	 SHORT $LN42@unicode_ex
$LN34@unicode_ex:

; 11004:                 line_pos = 0;

  00141	45 33 c0	 xor	 r8d, r8d
$LN42@unicode_ex:

; 10986:     for (; i < src_len; i++) {

  00144	48 ff c1	 inc	 rcx
  00147	48 3b cd	 cmp	 rcx, rbp
  0014a	7c 8c		 jl	 SHORT $LL43@unicode_ex

; 11005:         }
; 11006:     }
; 11007:     if (!found)

  0014c	45 85 db	 test	 r11d, r11d
  0014f	0f 84 7b 01 00
	00		 je	 $LN80@unicode_ex

; 11009: 
; 11010:     /* Second pass: create output string and fill it */
; 11011:     u = PyUnicode_New(j, PyUnicode_MAX_CHAR_VALUE(self));

  00155	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00158	a8 40		 test	 al, 64			; 00000040H
  0015a	74 07		 je	 SHORT $LN60@unicode_ex
  0015c	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00161	eb 22		 jmp	 SHORT $LN59@unicode_ex
$LN60@unicode_ex:
  00163	c1 e8 02	 shr	 eax, 2
  00166	83 e0 07	 and	 eax, 7
  00169	83 f8 01	 cmp	 eax, 1
  0016c	75 07		 jne	 SHORT $LN58@unicode_ex
  0016e	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  00173	eb 10		 jmp	 SHORT $LN59@unicode_ex
$LN58@unicode_ex:
  00175	ba ff ff 10 00	 mov	 edx, 1114111		; 0010ffffH
  0017a	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0017f	83 f8 02	 cmp	 eax, 2
  00182	0f 44 d1	 cmove	 edx, ecx
$LN59@unicode_ex:
  00185	48 8b cf	 mov	 rcx, rdi
  00188	e8 00 00 00 00	 call	 PyUnicode_New
  0018d	48 8b c8	 mov	 rcx, rax
  00190	48 89 44 24 20	 mov	 QWORD PTR u$1$[rsp], rax

; 11012:     if (!u)

  00195	48 85 c0	 test	 rax, rax

; 11013:         return NULL;

  00198	0f 84 2e 01 00
	00		 je	 $LN89@unicode_ex

; 11014:     dest_data = PyUnicode_DATA(u);

  0019e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001a1	a8 20		 test	 al, 32			; 00000020H
  001a3	74 16		 je	 SHORT $LN64@unicode_ex
  001a5	a8 40		 test	 al, 64			; 00000040H
  001a7	74 09		 je	 SHORT $LN62@unicode_ex
  001a9	48 8d a9 80 00
	00 00		 lea	 rbp, QWORD PTR [rcx+128]
  001b0	eb 10		 jmp	 SHORT $LN65@unicode_ex
$LN62@unicode_ex:
  001b2	48 8d a9 a0 00
	00 00		 lea	 rbp, QWORD PTR [rcx+160]
  001b9	eb 07		 jmp	 SHORT $LN65@unicode_ex
$LN64@unicode_ex:
  001bb	48 8b a9 a0 00
	00 00		 mov	 rbp, QWORD PTR [rcx+160]
$LN65@unicode_ex:

; 11015: 
; 11016:     i = j = line_pos = 0;

  001c2	45 33 ed	 xor	 r13d, r13d
  001c5	33 db		 xor	 ebx, ebx
  001c7	45 33 e4	 xor	 r12d, r12d
  001ca	45 8d 4d 20	 lea	 r9d, QWORD PTR [r13+32]
  001ce	66 90		 npad	 2
$LL31@unicode_ex:

; 11019:         ch = PyUnicode_READ(kind, src_data, i);

  001d0	41 83 fe 01	 cmp	 r14d, 1
  001d4	75 07		 jne	 SHORT $LN68@unicode_ex
  001d6	43 0f b6 0c 27	 movzx	 ecx, BYTE PTR [r15+r12]
  001db	eb 11		 jmp	 SHORT $LN67@unicode_ex
$LN68@unicode_ex:
  001dd	41 83 fe 02	 cmp	 r14d, 2
  001e1	75 07		 jne	 SHORT $LN66@unicode_ex
  001e3	43 0f b7 0c 67	 movzx	 ecx, WORD PTR [r15+r12*2]
  001e8	eb 04		 jmp	 SHORT $LN67@unicode_ex
$LN66@unicode_ex:
  001ea	43 8b 0c a7	 mov	 ecx, DWORD PTR [r15+r12*4]
$LN67@unicode_ex:

; 11020:         if (ch == '\t') {

  001ee	83 f9 09	 cmp	 ecx, 9
  001f1	75 7b		 jne	 SHORT $LN28@unicode_ex

; 11021:             if (tabsize > 0) {

  001f3	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR tabsize$[rsp]
  001fb	85 c0		 test	 eax, eax
  001fd	0f 8e 99 00 00
	00		 jle	 $LN30@unicode_ex

; 11022:                 incr = tabsize - (line_pos % tabsize);

  00203	48 8b f0	 mov	 rsi, rax
  00206	49 8b c5	 mov	 rax, r13

; 11023:                 line_pos += incr;
; 11024:                 FILL(kind, dest_data, ' ', j, incr);

  00209	41 8b ce	 mov	 ecx, r14d
  0020c	48 99		 cdq
  0020e	48 f7 fe	 idiv	 rsi
  00211	48 2b f2	 sub	 rsi, rdx
  00214	4c 03 ee	 add	 r13, rsi
  00217	ff c9		 dec	 ecx
  00219	74 39		 je	 SHORT $LN21@unicode_ex
  0021b	ff c9		 dec	 ecx
  0021d	74 1c		 je	 SHORT $LN20@unicode_ex
  0021f	83 f9 02	 cmp	 ecx, 2
  00222	75 45		 jne	 SHORT $LN25@unicode_ex
  00224	48 8d 7c 9d 00	 lea	 rdi, QWORD PTR [rbp+rbx*4]
  00229	48 85 f6	 test	 rsi, rsi
  0022c	7e 3b		 jle	 SHORT $LN25@unicode_ex
  0022e	49 8b c1	 mov	 rax, r9
  00231	48 8b ce	 mov	 rcx, rsi

; 11025:                 j += incr;

  00234	48 03 de	 add	 rbx, rsi
  00237	f3 ab		 rep stosd

; 11026:             }
; 11027:         }
; 11028:         else {

  00239	eb 61		 jmp	 SHORT $LN30@unicode_ex
$LN20@unicode_ex:

; 11023:                 line_pos += incr;
; 11024:                 FILL(kind, dest_data, ' ', j, incr);

  0023b	48 8d 7c 5d 00	 lea	 rdi, QWORD PTR [rbp+rbx*2]
  00240	48 85 f6	 test	 rsi, rsi
  00243	7e 24		 jle	 SHORT $LN25@unicode_ex
  00245	41 0f b7 c1	 movzx	 eax, r9w
  00249	48 8b ce	 mov	 rcx, rsi

; 11025:                 j += incr;

  0024c	48 03 de	 add	 rbx, rsi
  0024f	66 f3 ab	 rep stosw

; 11026:             }
; 11027:         }
; 11028:         else {

  00252	eb 48		 jmp	 SHORT $LN30@unicode_ex
$LN21@unicode_ex:

; 11023:                 line_pos += incr;
; 11024:                 FILL(kind, dest_data, ' ', j, incr);

  00254	48 8d 0c 2b	 lea	 rcx, QWORD PTR [rbx+rbp]
  00258	4c 8b c6	 mov	 r8, rsi
  0025b	41 8b d1	 mov	 edx, r9d
  0025e	e8 00 00 00 00	 call	 memset
  00263	41 b9 20 00 00
	00		 mov	 r9d, 32			; 00000020H
$LN25@unicode_ex:

; 11025:                 j += incr;

  00269	48 03 de	 add	 rbx, rsi

; 11026:             }
; 11027:         }
; 11028:         else {

  0026c	eb 2e		 jmp	 SHORT $LN30@unicode_ex
$LN28@unicode_ex:

; 11029:             line_pos++;
; 11030:             PyUnicode_WRITE(kind, dest_data, j, ch);

  0026e	41 8b d6	 mov	 edx, r14d
  00271	49 ff c5	 inc	 r13
  00274	ff ca		 dec	 edx
  00276	74 11		 je	 SHORT $LN5@unicode_ex
  00278	ff ca		 dec	 edx
  0027a	74 06		 je	 SHORT $LN4@unicode_ex
  0027c	89 4c 9d 00	 mov	 DWORD PTR [rbp+rbx*4], ecx
  00280	eb 0a		 jmp	 SHORT $LN9@unicode_ex
$LN4@unicode_ex:
  00282	66 89 4c 5d 00	 mov	 WORD PTR [rbp+rbx*2], cx
  00287	eb 03		 jmp	 SHORT $LN9@unicode_ex
$LN5@unicode_ex:
  00289	88 0c 2b	 mov	 BYTE PTR [rbx+rbp], cl
$LN9@unicode_ex:

; 11031:             j++;

  0028c	48 ff c3	 inc	 rbx

; 11032:             if (ch == '\n' || ch == '\r')

  0028f	83 f9 0a	 cmp	 ecx, 10
  00292	74 05		 je	 SHORT $LN1@unicode_ex
  00294	83 f9 0d	 cmp	 ecx, 13
  00297	75 03		 jne	 SHORT $LN30@unicode_ex
$LN1@unicode_ex:

; 11033:                 line_pos = 0;

  00299	45 33 ed	 xor	 r13d, r13d
$LN30@unicode_ex:

; 11017: 
; 11018:     for (; i < src_len; i++) {

  0029c	49 ff c4	 inc	 r12
  0029f	4c 3b a4 24 88
	00 00 00	 cmp	 r12, QWORD PTR src_len$1$[rsp]
  002a7	0f 8c 23 ff ff
	ff		 jl	 $LL31@unicode_ex

; 11034:         }
; 11035:     }
; 11036:     assert (j == PyUnicode_GET_LENGTH(u));
; 11037:     return unicode_result(u);

  002ad	48 8b 4c 24 20	 mov	 rcx, QWORD PTR u$1$[rsp]
  002b2	e8 00 00 00 00	 call	 unicode_result
  002b7	eb 1f		 jmp	 SHORT $LN88@unicode_ex
$overflow$138321:

; 11038: 
; 11039:   overflow:
; 11040:     PyErr_SetString(PyExc_OverflowError, "new string is too long");

  002b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  002c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@JJIGIBLH@new?5string?5is?5too?5long?$AA@
  002c7	e8 00 00 00 00	 call	 PyErr_SetString
$LN89@unicode_ex:

; 11041:     return NULL;

  002cc	33 c0		 xor	 eax, eax
  002ce	eb 08		 jmp	 SHORT $LN88@unicode_ex
$LN80@unicode_ex:

; 11008:         return unicode_result_unchanged(self);

  002d0	48 8b cb	 mov	 rcx, rbx
  002d3	e8 00 00 00 00	 call	 unicode_result_unchanged
$LN88@unicode_ex:
  002d8	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  002dd	4c 8b 6c 24 40	 mov	 r13, QWORD PTR [rsp+64]
  002e2	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  002e7	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  002ec	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]
  002f1	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  002f6	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]

; 11042: }

  002fb	48 83 c4 60	 add	 rsp, 96			; 00000060H
  002ff	5b		 pop	 rbx
  00300	c3		 ret	 0
unicode_expandtabs ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\find.h
pdata	SEGMENT
$pdata$unicode_find DD imagerel unicode_find
	DD	imagerel unicode_find+384
	DD	imagerel $unwind$unicode_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_find DD 081801H
	DD	0156418H
	DD	0143418H
	DD	0c00ef218H
	DD	0500b700cH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT unicode_find
_TEXT	SEGMENT
tmp_start$162297 = 48
tmp_end$162298 = 56
tmp_subobj$162296 = 64
format$162301 = 72
self$ = 160
args$ = 168
obj_start$162299 = 176
obj_end$162300 = 184
unicode_find PROC					; COMDAT

; 11055: {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00018	48 8b f1	 mov	 rsi, rcx

; 11056:     PyObject *substring;
; 11057:     Py_ssize_t start;
; 11058:     Py_ssize_t end;
; 11059:     Py_ssize_t result;
; 11060: 
; 11061:     if (!stringlib_parse_args_finds_unicode("find", args, &substring,
; 11062:                                             &start, &end))

  0001b	48 83 c9 ff	 or	 rcx, -1
  0001f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00029	48 89 45 b8	 mov	 QWORD PTR tmp_end$162298[rbp-128], rax
  0002d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@
  00033	48 8b da	 mov	 rbx, rdx
  00036	89 45 c8	 mov	 DWORD PTR format$162301[rbp-128], eax
  00039	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@+4
  00040	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_NoneStruct
  00047	66 89 45 cc	 mov	 WORD PTR format$162301[rbp-124], ax
  0004b	33 c0		 xor	 eax, eax
  0004d	48 8d 7d c8	 lea	 rdi, QWORD PTR format$162301[rbp-128]
  00051	48 89 45 ce	 mov	 QWORD PTR format$162301[rbp-122], rax
  00055	48 89 45 d6	 mov	 QWORD PTR format$162301[rbp-114], rax
  00059	48 89 45 de	 mov	 QWORD PTR format$162301[rbp-106], rax
  0005d	48 89 45 e6	 mov	 QWORD PTR format$162301[rbp-98], rax
  00061	48 89 45 ee	 mov	 QWORD PTR format$162301[rbp-90], rax
  00065	89 45 f6	 mov	 DWORD PTR format$162301[rbp-82], eax
  00068	f2 ae		 repne scasb
  0006a	41 b8 31 00 00
	00		 mov	 r8d, 49			; 00000031H
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04CKFJHKAP@find?$AA@
  00077	48 f7 d1	 not	 rcx
  0007a	48 c7 45 b0 00
	00 00 00	 mov	 QWORD PTR tmp_start$162297[rbp-128], 0
  00082	4c 89 65 30	 mov	 QWORD PTR obj_start$162299[rbp-128], r12
  00086	48 ff c9	 dec	 rcx
  00089	4c 89 65 38	 mov	 QWORD PTR obj_end$162300[rbp-128], r12
  0008d	4c 2b c1	 sub	 r8, rcx
  00090	48 8d 4c 0d c8	 lea	 rcx, QWORD PTR format$162301[rbp+rcx-128]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
  0009b	48 8d 45 38	 lea	 rax, QWORD PTR obj_end$162300[rbp-128]
  0009f	4c 8d 4d 30	 lea	 r9, QWORD PTR obj_start$162299[rbp-128]
  000a3	4c 8d 45 c0	 lea	 r8, QWORD PTR tmp_subobj$162296[rbp-128]
  000a7	48 8d 55 c8	 lea	 rdx, QWORD PTR format$162301[rbp-128]
  000ab	48 8b cb	 mov	 rcx, rbx
  000ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b3	c6 45 f9 00	 mov	 BYTE PTR format$162301[rbp-79], 0
  000b7	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000bc	85 c0		 test	 eax, eax
  000be	0f 84 a2 00 00
	00		 je	 $LN12@unicode_fi
  000c4	48 8b 4d 30	 mov	 rcx, QWORD PTR obj_start$162299[rbp-128]
  000c8	49 3b cc	 cmp	 rcx, r12
  000cb	74 11		 je	 SHORT $LN17@unicode_fi
  000cd	48 8d 55 b0	 lea	 rdx, QWORD PTR tmp_start$162297[rbp-128]
  000d1	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000d6	85 c0		 test	 eax, eax
  000d8	0f 84 88 00 00
	00		 je	 $LN12@unicode_fi
$LN17@unicode_fi:
  000de	48 8b 4d 38	 mov	 rcx, QWORD PTR obj_end$162300[rbp-128]
  000e2	49 3b cc	 cmp	 rcx, r12
  000e5	74 0d		 je	 SHORT $LN15@unicode_fi
  000e7	48 8d 55 b8	 lea	 rdx, QWORD PTR tmp_end$162298[rbp-128]
  000eb	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000f0	85 c0		 test	 eax, eax
  000f2	74 72		 je	 SHORT $LN12@unicode_fi
$LN15@unicode_fi:
  000f4	48 8b 4d c0	 mov	 rcx, QWORD PTR tmp_subobj$162296[rbp-128]
  000f8	48 8b 5d b0	 mov	 rbx, QWORD PTR tmp_start$162297[rbp-128]
  000fc	4c 8b 65 b8	 mov	 r12, QWORD PTR tmp_end$162298[rbp-128]
  00100	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00105	48 8b f8	 mov	 rdi, rax
  00108	48 85 c0	 test	 rax, rax
  0010b	74 59		 je	 SHORT $LN12@unicode_fi

; 11064: 
; 11065:     if (PyUnicode_READY(self) == -1)

  0010d	f6 46 70 80	 test	 BYTE PTR [rsi+112], 128	; 00000080H
  00111	75 0d		 jne	 SHORT $LN3@unicode_fi
  00113	48 8b ce	 mov	 rcx, rsi
  00116	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0011b	83 f8 ff	 cmp	 eax, -1

; 11066:         return NULL;

  0011e	74 46		 je	 SHORT $LN12@unicode_fi
$LN3@unicode_fi:

; 11067:     if (PyUnicode_READY(substring) == -1)

  00120	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  00124	75 0d		 jne	 SHORT $LN2@unicode_fi
  00126	48 8b cf	 mov	 rcx, rdi
  00129	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0012e	83 f8 ff	 cmp	 eax, -1

; 11068:         return NULL;

  00131	74 33		 je	 SHORT $LN12@unicode_fi
$LN2@unicode_fi:

; 11069: 
; 11070:     result = any_find_slice(1, self, substring, start, end);

  00133	4c 8b cb	 mov	 r9, rbx
  00136	4c 8b c7	 mov	 r8, rdi
  00139	48 8b d6	 mov	 rdx, rsi
  0013c	b9 01 00 00 00	 mov	 ecx, 1
  00141	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  00146	e8 00 00 00 00	 call	 any_find_slice

; 11071: 
; 11072:     Py_DECREF(substring);

  0014b	48 8b cf	 mov	 rcx, rdi
  0014e	48 8b d8	 mov	 rbx, rax
  00151	e8 00 00 00 00	 call	 _Py_DecRef

; 11073: 
; 11074:     if (result == -2)

  00156	48 83 fb fe	 cmp	 rbx, -2

; 11075:         return NULL;

  0015a	74 0a		 je	 SHORT $LN12@unicode_fi

; 11076: 
; 11077:     return PyLong_FromSsize_t(result);

  0015c	48 8b cb	 mov	 rcx, rbx
  0015f	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00164	eb 02		 jmp	 SHORT $LN5@unicode_fi

; 11056:     PyObject *substring;
; 11057:     Py_ssize_t start;
; 11058:     Py_ssize_t end;
; 11059:     Py_ssize_t result;
; 11060: 
; 11061:     if (!stringlib_parse_args_finds_unicode("find", args, &substring,
; 11062:                                             &start, &end))

$LN12@unicode_fi:

; 11063:         return NULL;

  00166	33 c0		 xor	 eax, eax
$LN5@unicode_fi:

; 11078: }

  00168	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  00170	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  00174	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  00178	49 8b e3	 mov	 rsp, r11
  0017b	41 5c		 pop	 r12
  0017d	5f		 pop	 rdi
  0017e	5d		 pop	 rbp
  0017f	c3		 ret	 0
unicode_find ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@NLNEJIOA@substring?5not?5found?$AA@	; `string'
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\find.h
pdata	SEGMENT
$pdata$unicode_index DD imagerel unicode_index
	DD	imagerel unicode_index+412
	DD	imagerel $unwind$unicode_index
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_index DD 081801H
	DD	0156418H
	DD	0143418H
	DD	0c00ef218H
	DD	0500b700cH
xdata	ENDS
;	COMDAT ??_C@_0BE@NLNEJIOA@substring?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BE@NLNEJIOA@substring?5not?5found?$AA@ DB 'substring not found', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT unicode_index
_TEXT	SEGMENT
tmp_start$162356 = 48
tmp_end$162357 = 56
tmp_subobj$162355 = 64
format$162361 = 72
self$ = 160
args$ = 168
obj_start$162358 = 176
obj_end$162359 = 184
unicode_index PROC					; COMDAT

; 11181: {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00018	48 8b f1	 mov	 rsi, rcx

; 11182:     Py_ssize_t result;
; 11183:     PyObject *substring;
; 11184:     Py_ssize_t start;
; 11185:     Py_ssize_t end;
; 11186: 
; 11187:     if (!stringlib_parse_args_finds_unicode("index", args, &substring,
; 11188:                                             &start, &end))

  0001b	48 83 c9 ff	 or	 rcx, -1
  0001f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00029	48 89 45 b8	 mov	 QWORD PTR tmp_end$162357[rbp-128], rax
  0002d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@
  00033	48 8b da	 mov	 rbx, rdx
  00036	89 45 c8	 mov	 DWORD PTR format$162361[rbp-128], eax
  00039	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@+4
  00040	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_NoneStruct
  00047	66 89 45 cc	 mov	 WORD PTR format$162361[rbp-124], ax
  0004b	33 c0		 xor	 eax, eax
  0004d	48 8d 7d c8	 lea	 rdi, QWORD PTR format$162361[rbp-128]
  00051	48 89 45 ce	 mov	 QWORD PTR format$162361[rbp-122], rax
  00055	48 89 45 d6	 mov	 QWORD PTR format$162361[rbp-114], rax
  00059	48 89 45 de	 mov	 QWORD PTR format$162361[rbp-106], rax
  0005d	48 89 45 e6	 mov	 QWORD PTR format$162361[rbp-98], rax
  00061	48 89 45 ee	 mov	 QWORD PTR format$162361[rbp-90], rax
  00065	89 45 f6	 mov	 DWORD PTR format$162361[rbp-82], eax
  00068	f2 ae		 repne scasb
  0006a	41 b8 31 00 00
	00		 mov	 r8d, 49			; 00000031H
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05FKHKFDID@index?$AA@
  00077	48 f7 d1	 not	 rcx
  0007a	48 c7 45 b0 00
	00 00 00	 mov	 QWORD PTR tmp_start$162356[rbp-128], 0
  00082	4c 89 65 30	 mov	 QWORD PTR obj_start$162358[rbp-128], r12
  00086	48 ff c9	 dec	 rcx
  00089	4c 89 65 38	 mov	 QWORD PTR obj_end$162359[rbp-128], r12
  0008d	4c 2b c1	 sub	 r8, rcx
  00090	48 8d 4c 0d c8	 lea	 rcx, QWORD PTR format$162361[rbp+rcx-128]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
  0009b	48 8d 45 38	 lea	 rax, QWORD PTR obj_end$162359[rbp-128]
  0009f	4c 8d 4d 30	 lea	 r9, QWORD PTR obj_start$162358[rbp-128]
  000a3	4c 8d 45 c0	 lea	 r8, QWORD PTR tmp_subobj$162355[rbp-128]
  000a7	48 8d 55 c8	 lea	 rdx, QWORD PTR format$162361[rbp-128]
  000ab	48 8b cb	 mov	 rcx, rbx
  000ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b3	c6 45 f9 00	 mov	 BYTE PTR format$162361[rbp-79], 0
  000b7	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000bc	85 c0		 test	 eax, eax
  000be	0f 84 b4 00 00
	00		 je	 $LN13@unicode_in
  000c4	48 8b 4d 30	 mov	 rcx, QWORD PTR obj_start$162358[rbp-128]
  000c8	49 3b cc	 cmp	 rcx, r12
  000cb	74 11		 je	 SHORT $LN18@unicode_in
  000cd	48 8d 55 b0	 lea	 rdx, QWORD PTR tmp_start$162356[rbp-128]
  000d1	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000d6	85 c0		 test	 eax, eax
  000d8	0f 84 9a 00 00
	00		 je	 $LN13@unicode_in
$LN18@unicode_in:
  000de	48 8b 4d 38	 mov	 rcx, QWORD PTR obj_end$162359[rbp-128]
  000e2	49 3b cc	 cmp	 rcx, r12
  000e5	74 11		 je	 SHORT $LN16@unicode_in
  000e7	48 8d 55 b8	 lea	 rdx, QWORD PTR tmp_end$162357[rbp-128]
  000eb	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000f0	85 c0		 test	 eax, eax
  000f2	0f 84 80 00 00
	00		 je	 $LN13@unicode_in
$LN16@unicode_in:
  000f8	48 8b 4d c0	 mov	 rcx, QWORD PTR tmp_subobj$162355[rbp-128]
  000fc	48 8b 5d b0	 mov	 rbx, QWORD PTR tmp_start$162356[rbp-128]
  00100	4c 8b 65 b8	 mov	 r12, QWORD PTR tmp_end$162357[rbp-128]
  00104	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00109	48 8b f8	 mov	 rdi, rax
  0010c	48 85 c0	 test	 rax, rax
  0010f	74 67		 je	 SHORT $LN13@unicode_in

; 11190: 
; 11191:     if (PyUnicode_READY(self) == -1)

  00111	f6 46 70 80	 test	 BYTE PTR [rsi+112], 128	; 00000080H
  00115	75 0d		 jne	 SHORT $LN4@unicode_in
  00117	48 8b ce	 mov	 rcx, rsi
  0011a	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0011f	83 f8 ff	 cmp	 eax, -1

; 11192:         return NULL;

  00122	74 54		 je	 SHORT $LN13@unicode_in
$LN4@unicode_in:

; 11193:     if (PyUnicode_READY(substring) == -1)

  00124	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  00128	75 0d		 jne	 SHORT $LN3@unicode_in
  0012a	48 8b cf	 mov	 rcx, rdi
  0012d	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00132	83 f8 ff	 cmp	 eax, -1

; 11194:         return NULL;

  00135	74 41		 je	 SHORT $LN13@unicode_in
$LN3@unicode_in:

; 11195: 
; 11196:     result = any_find_slice(1, self, substring, start, end);

  00137	4c 8b cb	 mov	 r9, rbx
  0013a	4c 8b c7	 mov	 r8, rdi
  0013d	48 8b d6	 mov	 rdx, rsi
  00140	b9 01 00 00 00	 mov	 ecx, 1
  00145	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  0014a	e8 00 00 00 00	 call	 any_find_slice

; 11197: 
; 11198:     Py_DECREF(substring);

  0014f	48 8b cf	 mov	 rcx, rdi
  00152	48 8b d8	 mov	 rbx, rax
  00155	e8 00 00 00 00	 call	 _Py_DecRef

; 11199: 
; 11200:     if (result == -2)

  0015a	48 83 fb fe	 cmp	 rbx, -2

; 11201:         return NULL;

  0015e	74 18		 je	 SHORT $LN13@unicode_in

; 11202: 
; 11203:     if (result < 0) {

  00160	48 85 db	 test	 rbx, rbx
  00163	79 2d		 jns	 SHORT $LN1@unicode_in

; 11204:         PyErr_SetString(PyExc_ValueError, "substring not found");

  00165	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0016c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@NLNEJIOA@substring?5not?5found?$AA@
  00173	e8 00 00 00 00	 call	 PyErr_SetString
$LN13@unicode_in:

; 11189:         return NULL;

  00178	33 c0		 xor	 eax, eax
$LN6@unicode_in:

; 11209: }

  0017a	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  00182	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  00186	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  0018a	49 8b e3	 mov	 rsp, r11
  0018d	41 5c		 pop	 r12
  0018f	5f		 pop	 rdi
  00190	5d		 pop	 rbp
  00191	c3		 ret	 0
$LN1@unicode_in:

; 11205:         return NULL;
; 11206:     }
; 11207: 
; 11208:     return PyLong_FromSsize_t(result);

  00192	48 8b cb	 mov	 rcx, rbx
  00195	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  0019a	eb de		 jmp	 SHORT $LN6@unicode_in
unicode_index ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@KFDPFBLI@n?$HMO?$CG?3ljust?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_ljust DD imagerel unicode_ljust
	DD	imagerel unicode_ljust+137
	DD	imagerel $unwind$unicode_ljust
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_ljust DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@KFDPFBLI@n?$HMO?$CG?3ljust?$AA@
CONST	SEGMENT
??_C@_0L@KFDPFBLI@n?$HMO?$CG?3ljust?$AA@ DB 'n|O&:ljust', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_ljust
_TEXT	SEGMENT
self$ = 64
args$ = 72
fillchar$ = 80
width$ = 88
unicode_ljust PROC					; COMDAT

; 11676: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 11677:     Py_ssize_t width;
; 11678:     Py_UCS4 fillchar = ' ';
; 11679: 
; 11680:     if (!PyArg_ParseTuple(args, "n|O&:ljust", &width, convert_uc, &fillchar))

  0000c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR fillchar$[rsp]
  00011	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00016	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:convert_uc
  0001d	4c 8d 44 24 58	 lea	 r8, QWORD PTR width$[rsp]
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@KFDPFBLI@n?$HMO?$CG?3ljust?$AA@
  00029	48 8b c8	 mov	 rcx, rax
  0002c	c7 44 24 50 20
	00 00 00	 mov	 DWORD PTR fillchar$[rsp], 32 ; 00000020H
  00034	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00039	85 c0		 test	 eax, eax
  0003b	75 08		 jne	 SHORT $LN3@unicode_lj
$LN8@unicode_lj:

; 11681:         return NULL;

  0003d	33 c0		 xor	 eax, eax

; 11690: }

  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	5b		 pop	 rbx
  00044	c3		 ret	 0
$LN3@unicode_lj:

; 11682: 
; 11683:     if (PyUnicode_READY(self) == -1)

  00045	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00049	75 0d		 jne	 SHORT $LN2@unicode_lj
  0004b	48 8b cb	 mov	 rcx, rbx
  0004e	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00053	83 f8 ff	 cmp	 eax, -1

; 11684:         return NULL;

  00056	74 e5		 je	 SHORT $LN8@unicode_lj
$LN2@unicode_lj:

; 11685: 
; 11686:     if (PyUnicode_GET_LENGTH(self) >= width)

  00058	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  0005c	4c 8b 44 24 58	 mov	 r8, QWORD PTR width$[rsp]

; 11687:         return unicode_result_unchanged(self);

  00061	48 8b cb	 mov	 rcx, rbx
  00064	49 3b c0	 cmp	 rax, r8
  00067	7c 0b		 jl	 SHORT $LN1@unicode_lj
  00069	e8 00 00 00 00	 call	 unicode_result_unchanged

; 11690: }

  0006e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00072	5b		 pop	 rbx
  00073	c3		 ret	 0
$LN1@unicode_lj:

; 11688: 
; 11689:     return pad(self, 0, width - PyUnicode_GET_LENGTH(self), fillchar);

  00074	44 8b 4c 24 50	 mov	 r9d, DWORD PTR fillchar$[rsp]
  00079	4c 2b c0	 sub	 r8, rax
  0007c	33 d2		 xor	 edx, edx
  0007e	e8 00 00 00 00	 call	 pad

; 11690: }

  00083	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00087	5b		 pop	 rbx
  00088	c3		 ret	 0
unicode_ljust ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_Substring
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_Substring DD imagerel $LN34
	DD	imagerel $LN34+360
	DD	imagerel $unwind$PyUnicode_Substring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Substring DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_Substring
_TEXT	SEGMENT
self$ = 48
start$ = 56
end$ = 64
PyUnicode_Substring PROC				; COMDAT

; 11757: {

$LN34:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 11758:     unsigned char *data;
; 11759:     int kind;
; 11760:     Py_ssize_t length;
; 11761: 
; 11762:     if (PyUnicode_READY(self) == -1)

  0000f	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00013	49 8b f8	 mov	 rdi, r8
  00016	48 8b f2	 mov	 rsi, rdx
  00019	48 8b d9	 mov	 rbx, rcx
  0001c	75 0e		 jne	 SHORT $LN17@PyUnicode_@89
  0001e	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00023	83 f8 ff	 cmp	 eax, -1

; 11763:         return NULL;

  00026	0f 84 2a 01 00
	00		 je	 $LN31@PyUnicode_@89
$LN17@PyUnicode_@89:

; 11764: 
; 11765:     length = PyUnicode_GET_LENGTH(self);

  0002c	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]

; 11766:     end = Py_MIN(end, length);

  00030	48 3b f8	 cmp	 rdi, rax
  00033	48 0f 4f f8	 cmovg	 rdi, rax

; 11767: 
; 11768:     if (start == 0 && end == length)

  00037	48 85 f6	 test	 rsi, rsi
  0003a	75 1c		 jne	 SHORT $LN32@PyUnicode_@89
  0003c	48 3b f8	 cmp	 rdi, rax
  0003f	75 1d		 jne	 SHORT $LN30@PyUnicode_@89

; 11769:         return unicode_result_unchanged(self);

  00041	48 8b cb	 mov	 rcx, rbx

; 11789:     }
; 11790: }

  00044	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00049	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5f		 pop	 rdi
  00053	e9 00 00 00 00	 jmp	 unicode_result_unchanged
$LN32@PyUnicode_@89:

; 11770: 
; 11771:     if (start < 0 || end < 0) {

  00058	0f 88 e5 00 00
	00		 js	 $LN14@PyUnicode_@89
$LN30@PyUnicode_@89:
  0005e	48 85 ff	 test	 rdi, rdi
  00061	0f 88 dc 00 00
	00		 js	 $LN14@PyUnicode_@89

; 11774:     }
; 11775:     if (start >= length || end < start)

  00067	48 3b f0	 cmp	 rsi, rax
  0006a	0f 8d 95 00 00
	00		 jge	 $LN11@PyUnicode_@89
  00070	48 3b fe	 cmp	 rdi, rsi
  00073	0f 8c 8c 00 00
	00		 jl	 $LN11@PyUnicode_@89

; 11777: 
; 11778:     length = end - start;
; 11779:     if (PyUnicode_IS_ASCII(self)) {

  00079	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0007c	48 2b fe	 sub	 rdi, rsi
  0007f	a8 40		 test	 al, 64			; 00000040H
  00081	74 45		 je	 SHORT $LN2@PyUnicode_@89

; 11780:         data = PyUnicode_1BYTE_DATA(self);

  00083	a8 20		 test	 al, 32			; 00000020H
  00085	74 1f		 je	 SHORT $LN24@PyUnicode_@89
  00087	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H

; 11781:         return _PyUnicode_FromASCII((char*)(data + start), length);

  0008b	48 8b d7	 mov	 rdx, rdi
  0008e	48 8d 0c 33	 lea	 rcx, QWORD PTR [rbx+rsi]

; 11789:     }
; 11790: }

  00092	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00097	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0009c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a0	5f		 pop	 rdi
  000a1	e9 00 00 00 00	 jmp	 _PyUnicode_FromASCII
$LN24@PyUnicode_@89:

; 11780:         data = PyUnicode_1BYTE_DATA(self);

  000a6	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]

; 11781:         return _PyUnicode_FromASCII((char*)(data + start), length);

  000ad	48 8b d7	 mov	 rdx, rdi
  000b0	48 8d 0c 33	 lea	 rcx, QWORD PTR [rbx+rsi]

; 11789:     }
; 11790: }

  000b4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b9	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000be	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c2	5f		 pop	 rdi
  000c3	e9 00 00 00 00	 jmp	 _PyUnicode_FromASCII
$LN2@PyUnicode_@89:

; 11782:     }
; 11783:     else {
; 11784:         kind = PyUnicode_KIND(self);

  000c8	8b c8		 mov	 ecx, eax
  000ca	c1 e9 02	 shr	 ecx, 2
  000cd	83 e1 07	 and	 ecx, 7

; 11785:         data = PyUnicode_1BYTE_DATA(self);

  000d0	a8 20		 test	 al, 32			; 00000020H
  000d2	74 09		 je	 SHORT $LN28@PyUnicode_@89
  000d4	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  000db	eb 07		 jmp	 SHORT $LN29@PyUnicode_@89
$LN28@PyUnicode_@89:
  000dd	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
$LN29@PyUnicode_@89:

; 11786:         return PyUnicode_FromKindAndData(kind,
; 11787:                                          data + kind * start,
; 11788:                                          length);

  000e4	48 63 d1	 movsxd	 rdx, ecx
  000e7	4c 8b c7	 mov	 r8, rdi
  000ea	48 0f af d6	 imul	 rdx, rsi
  000ee	48 03 d3	 add	 rdx, rbx

; 11789:     }
; 11790: }

  000f1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000f6	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000fb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ff	5f		 pop	 rdi
  00100	e9 00 00 00 00	 jmp	 PyUnicode_FromKindAndData
$LN11@PyUnicode_@89:

; 11776:         _Py_RETURN_UNICODE_EMPTY();

  00105	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  0010c	48 85 c9	 test	 rcx, rcx
  0010f	75 16		 jne	 SHORT $LN33@PyUnicode_@89
  00111	33 d2		 xor	 edx, edx
  00113	e8 00 00 00 00	 call	 PyUnicode_New
  00118	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  0011f	48 85 c0	 test	 rax, rax
  00122	74 34		 je	 SHORT $LN1@PyUnicode_@89
  00124	48 8b c8	 mov	 rcx, rax
$LN33@PyUnicode_@89:
  00127	e8 00 00 00 00	 call	 _Py_IncRef
  0012c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 11789:     }
; 11790: }

  00133	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00138	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0013d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00141	5f		 pop	 rdi
  00142	c3		 ret	 0
$LN14@PyUnicode_@89:

; 11772:         PyErr_SetString(PyExc_IndexError, "string index out of range");

  00143	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0014a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@DOEPEGBG@string?5index?5out?5of?5range?$AA@
  00151	e8 00 00 00 00	 call	 PyErr_SetString
$LN31@PyUnicode_@89:

; 11773:         return NULL;

  00156	33 c0		 xor	 eax, eax
$LN1@PyUnicode_@89:

; 11789:     }
; 11790: }

  00158	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0015d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00162	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00166	5f		 pop	 rdi
  00167	c3		 ret	 0
PyUnicode_Substring ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_strip DD imagerel do_strip
	DD	imagerel do_strip+449
	DD	imagerel $unwind$do_strip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_strip DD 0d4b01H
	DD	04e44bH
	DD	0b7443H
	DD	0a643cH
	DD	095437H
	DD	083432H
	DD	0d0044208H
	DD	0c002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT do_strip
_TEXT	SEGMENT
self$ = 64
striptype$ = 72
do_strip PROC						; COMDAT

; 11794: {

  00000	41 54		 push	 r12
  00002	41 55		 push	 r13
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 11795:     int kind;
; 11796:     void *data;
; 11797:     Py_ssize_t len, i, j;
; 11798: 
; 11799:     if (PyUnicode_READY(self) == -1)

  00008	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000c	44 8b e2	 mov	 r12d, edx
  0000f	4c 8b e9	 mov	 r13, rcx
  00012	75 15		 jne	 SHORT $LN9@do_strip
  00014	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00019	83 f8 ff	 cmp	 eax, -1
  0001c	75 0b		 jne	 SHORT $LN9@do_strip

; 11800:         return NULL;

  0001e	33 c0		 xor	 eax, eax

; 11822: }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	41 5d		 pop	 r13
  00026	41 5c		 pop	 r12
  00028	c3		 ret	 0
$LN9@do_strip:

; 11801: 
; 11802:     kind = PyUnicode_KIND(self);

  00029	41 8b 45 70	 mov	 eax, DWORD PTR [r13+112]
  0002d	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00032	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  00037	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0003c	8b c8		 mov	 ecx, eax
  0003e	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  00043	c1 e9 02	 shr	 ecx, 2
  00046	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  0004b	83 e1 07	 and	 ecx, 7

; 11803:     data = PyUnicode_DATA(self);

  0004e	a8 20		 test	 al, 32			; 00000020H
  00050	74 16		 je	 SHORT $LN16@do_strip
  00052	a8 40		 test	 al, 64			; 00000040H
  00054	74 09		 je	 SHORT $LN14@do_strip
  00056	49 8d 9d 80 00
	00 00		 lea	 rbx, QWORD PTR [r13+128]
  0005d	eb 10		 jmp	 SHORT $LN17@do_strip
$LN14@do_strip:
  0005f	49 8d 9d a0 00
	00 00		 lea	 rbx, QWORD PTR [r13+160]
  00066	eb 07		 jmp	 SHORT $LN17@do_strip
$LN16@do_strip:
  00068	49 8b 9d a0 00
	00 00		 mov	 rbx, QWORD PTR [r13+160]
$LN17@do_strip:

; 11804:     len = PyUnicode_GET_LENGTH(self);

  0006f	49 8b 7d 60	 mov	 rdi, QWORD PTR [r13+96]

; 11805: 
; 11806:     i = 0;

  00073	33 ed		 xor	 ebp, ebp

; 11807:     if (striptype != RIGHTSTRIP) {
; 11808:         while (i < len && Py_UNICODE_ISSPACE(PyUnicode_READ(kind, data, i))) {

  00075	48 63 f1	 movsxd	 rsi, ecx
  00078	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:_Py_ascii_whitespace
  0007f	41 83 fc 01	 cmp	 r12d, 1
  00083	0f 84 83 00 00
	00		 je	 $LN49@do_strip
  00089	48 85 ff	 test	 rdi, rdi
  0008c	0f 8e 7a 00 00
	00		 jle	 $LN49@do_strip
$LL7@do_strip:
  00092	48 83 fe 01	 cmp	 rsi, 1
  00096	75 06		 jne	 SHORT $LN20@do_strip
  00098	0f b6 04 2b	 movzx	 eax, BYTE PTR [rbx+rbp]
  0009c	eb 0f		 jmp	 SHORT $LN19@do_strip
$LN20@do_strip:
  0009e	48 83 fe 02	 cmp	 rsi, 2
  000a2	75 06		 jne	 SHORT $LN18@do_strip
  000a4	0f b7 04 6b	 movzx	 eax, WORD PTR [rbx+rbp*2]
  000a8	eb 03		 jmp	 SHORT $LN19@do_strip
$LN18@do_strip:
  000aa	8b 04 ab	 mov	 eax, DWORD PTR [rbx+rbp*4]
$LN19@do_strip:
  000ad	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000b2	73 2c		 jae	 SHORT $LN30@do_strip
  000b4	48 83 fe 01	 cmp	 rsi, 1
  000b8	75 0b		 jne	 SHORT $LN24@do_strip
  000ba	0f b6 04 2b	 movzx	 eax, BYTE PTR [rbx+rbp]
  000be	42 0f b6 04 30	 movzx	 eax, BYTE PTR [rax+r14]
  000c3	eb 3b		 jmp	 SHORT $LN31@do_strip
$LN24@do_strip:
  000c5	48 83 fe 02	 cmp	 rsi, 2
  000c9	75 0b		 jne	 SHORT $LN22@do_strip
  000cb	0f b7 04 6b	 movzx	 eax, WORD PTR [rbx+rbp*2]
  000cf	42 0f b6 04 30	 movzx	 eax, BYTE PTR [rax+r14]
  000d4	eb 2a		 jmp	 SHORT $LN31@do_strip
$LN22@do_strip:
  000d6	8b 04 ab	 mov	 eax, DWORD PTR [rbx+rbp*4]
  000d9	42 0f b6 04 30	 movzx	 eax, BYTE PTR [rax+r14]
  000de	eb 20		 jmp	 SHORT $LN31@do_strip
$LN30@do_strip:
  000e0	48 83 fe 01	 cmp	 rsi, 1
  000e4	75 06		 jne	 SHORT $LN28@do_strip
  000e6	0f b6 0c 2b	 movzx	 ecx, BYTE PTR [rbx+rbp]
  000ea	eb 0f		 jmp	 SHORT $LN27@do_strip
$LN28@do_strip:
  000ec	48 83 fe 02	 cmp	 rsi, 2
  000f0	75 06		 jne	 SHORT $LN26@do_strip
  000f2	0f b7 0c 6b	 movzx	 ecx, WORD PTR [rbx+rbp*2]
  000f6	eb 03		 jmp	 SHORT $LN27@do_strip
$LN26@do_strip:
  000f8	8b 0c ab	 mov	 ecx, DWORD PTR [rbx+rbp*4]
$LN27@do_strip:
  000fb	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
$LN31@do_strip:
  00100	85 c0		 test	 eax, eax
  00102	74 08		 je	 SHORT $LN49@do_strip

; 11809:             i++;

  00104	48 ff c5	 inc	 rbp
  00107	48 3b ef	 cmp	 rbp, rdi
  0010a	7c 86		 jl	 SHORT $LL7@do_strip
$LN49@do_strip:

; 11810:         }
; 11811:     }
; 11812: 
; 11813:     j = len;
; 11814:     if (striptype != LEFTSTRIP) {

  0010c	45 85 e4	 test	 r12d, r12d
  0010f	0f 84 7d 00 00
	00		 je	 $LN5@do_strip
$LL4@do_strip:

; 11815:         do {
; 11816:             j--;

  00115	48 ff cf	 dec	 rdi

; 11817:         } while (j >= i && Py_UNICODE_ISSPACE(PyUnicode_READ(kind, data, j)));

  00118	48 3b fd	 cmp	 rdi, rbp
  0011b	7c 72		 jl	 SHORT $LN1@do_strip
  0011d	48 83 fe 01	 cmp	 rsi, 1
  00121	75 06		 jne	 SHORT $LN34@do_strip
  00123	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  00127	eb 0f		 jmp	 SHORT $LN33@do_strip
$LN34@do_strip:
  00129	48 83 fe 02	 cmp	 rsi, 2
  0012d	75 06		 jne	 SHORT $LN32@do_strip
  0012f	0f b7 04 7b	 movzx	 eax, WORD PTR [rbx+rdi*2]
  00133	eb 03		 jmp	 SHORT $LN33@do_strip
$LN32@do_strip:
  00135	8b 04 bb	 mov	 eax, DWORD PTR [rbx+rdi*4]
$LN33@do_strip:
  00138	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0013d	73 2c		 jae	 SHORT $LN44@do_strip
  0013f	48 83 fe 01	 cmp	 rsi, 1
  00143	75 0b		 jne	 SHORT $LN38@do_strip
  00145	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  00149	42 0f b6 04 30	 movzx	 eax, BYTE PTR [rax+r14]
  0014e	eb 3b		 jmp	 SHORT $LN45@do_strip
$LN38@do_strip:
  00150	48 83 fe 02	 cmp	 rsi, 2
  00154	75 0b		 jne	 SHORT $LN36@do_strip
  00156	0f b7 04 7b	 movzx	 eax, WORD PTR [rbx+rdi*2]
  0015a	42 0f b6 04 30	 movzx	 eax, BYTE PTR [rax+r14]
  0015f	eb 2a		 jmp	 SHORT $LN45@do_strip
$LN36@do_strip:
  00161	8b 04 bb	 mov	 eax, DWORD PTR [rbx+rdi*4]
  00164	42 0f b6 04 30	 movzx	 eax, BYTE PTR [rax+r14]
  00169	eb 20		 jmp	 SHORT $LN45@do_strip
$LN44@do_strip:
  0016b	48 83 fe 01	 cmp	 rsi, 1
  0016f	75 06		 jne	 SHORT $LN42@do_strip
  00171	0f b6 0c 1f	 movzx	 ecx, BYTE PTR [rdi+rbx]
  00175	eb 0f		 jmp	 SHORT $LN41@do_strip
$LN42@do_strip:
  00177	48 83 fe 02	 cmp	 rsi, 2
  0017b	75 06		 jne	 SHORT $LN40@do_strip
  0017d	0f b7 0c 7b	 movzx	 ecx, WORD PTR [rbx+rdi*2]
  00181	eb 03		 jmp	 SHORT $LN41@do_strip
$LN40@do_strip:
  00183	8b 0c bb	 mov	 ecx, DWORD PTR [rbx+rdi*4]
$LN41@do_strip:
  00186	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
$LN45@do_strip:
  0018b	85 c0		 test	 eax, eax
  0018d	75 86		 jne	 SHORT $LL4@do_strip
$LN1@do_strip:

; 11818:         j++;

  0018f	48 ff c7	 inc	 rdi
$LN5@do_strip:

; 11819:     }
; 11820: 
; 11821:     return PyUnicode_Substring(self, i, j);

  00192	4c 8b c7	 mov	 r8, rdi
  00195	48 8b d5	 mov	 rdx, rbp
  00198	49 8b cd	 mov	 rcx, r13
  0019b	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
  001a0	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  001a5	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001aa	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001af	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 11822: }

  001b4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001b8	41 5d		 pop	 r13
  001ba	41 5c		 pop	 r12
  001bc	e9 00 00 00 00	 jmp	 PyUnicode_Substring
do_strip ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@IMFPEPF@repeated?5string?5is?5too?5long?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_repeat DD imagerel unicode_repeat
	DD	imagerel unicode_repeat+124
	DD	imagerel $unwind$unicode_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_repeat DD imagerel unicode_repeat+124
	DD	imagerel unicode_repeat+176
	DD	imagerel $chain$0$unicode_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$unicode_repeat DD imagerel unicode_repeat+176
	DD	imagerel unicode_repeat+266
	DD	imagerel $chain$3$unicode_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$unicode_repeat DD imagerel unicode_repeat+266
	DD	imagerel unicode_repeat+594
	DD	imagerel $chain$6$unicode_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$unicode_repeat DD imagerel unicode_repeat+594
	DD	imagerel unicode_repeat+740
	DD	imagerel $chain$7$unicode_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$unicode_repeat DD imagerel unicode_repeat+740
	DD	imagerel unicode_repeat+844
	DD	imagerel $chain$8$unicode_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$unicode_repeat DD imagerel unicode_repeat+844
	DD	imagerel unicode_repeat+849
	DD	imagerel $chain$9$unicode_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$unicode_repeat DD imagerel unicode_repeat+849
	DD	imagerel unicode_repeat+867
	DD	imagerel $chain$10$unicode_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$unicode_repeat DD imagerel unicode_repeat+867
	DD	imagerel unicode_repeat+874
	DD	imagerel $chain$11$unicode_repeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$unicode_repeat DD 021H
	DD	imagerel unicode_repeat
	DD	imagerel unicode_repeat+124
	DD	imagerel $unwind$unicode_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$unicode_repeat DD 021H
	DD	imagerel unicode_repeat+266
	DD	imagerel unicode_repeat+594
	DD	imagerel $chain$6$unicode_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$unicode_repeat DD 021H
	DD	imagerel unicode_repeat+594
	DD	imagerel unicode_repeat+740
	DD	imagerel $chain$7$unicode_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$unicode_repeat DD 020521H
	DD	0ac405H
	DD	imagerel unicode_repeat+594
	DD	imagerel unicode_repeat+740
	DD	imagerel $chain$7$unicode_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$unicode_repeat DD 020521H
	DD	04e405H
	DD	imagerel unicode_repeat+266
	DD	imagerel unicode_repeat+594
	DD	imagerel $chain$6$unicode_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$unicode_repeat DD 060821H
	DD	083408H
	DD	0bd400H
	DD	096400H
	DD	imagerel unicode_repeat
	DD	imagerel unicode_repeat+124
	DD	imagerel $unwind$unicode_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$unicode_repeat DD 040c21H
	DD	09640cH
	DD	0bd400H
	DD	imagerel unicode_repeat
	DD	imagerel unicode_repeat+124
	DD	imagerel $unwind$unicode_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_repeat DD 020521H
	DD	0bd405H
	DD	imagerel unicode_repeat
	DD	imagerel unicode_repeat+124
	DD	imagerel $unwind$unicode_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_repeat DD 030701H
	DD	070034207H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0BM@IMFPEPF@repeated?5string?5is?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BM@IMFPEPF@repeated?5string?5is?5too?5long?$AA@ DB 'repeated strin'
	DB	'g is too long', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_repeat
_TEXT	SEGMENT
str$ = 64
len$ = 72
unicode_repeat PROC					; COMDAT

; 11899: {

  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00007	48 8b ea	 mov	 rbp, rdx
  0000a	48 8b f9	 mov	 rdi, rcx

; 11900:     PyObject *u;
; 11901:     Py_ssize_t nchars, n;
; 11902: 
; 11903:     if (len < 1)

  0000d	48 83 fa 01	 cmp	 rdx, 1
  00011	7d 39		 jge	 SHORT $LN106@unicode_re@7

; 11904:         _Py_RETURN_UNICODE_EMPTY();

  00013	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  0001a	48 85 c9	 test	 rcx, rcx
  0001d	75 1a		 jne	 SHORT $LN107@unicode_re@7
  0001f	33 d2		 xor	 edx, edx
  00021	e8 00 00 00 00	 call	 PyUnicode_New
  00026	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  0002d	48 85 c0	 test	 rax, rax
  00030	0f 84 2d 03 00
	00		 je	 $LN45@unicode_re@7
  00036	48 8b c8	 mov	 rcx, rax
$LN107@unicode_re@7:
  00039	e8 00 00 00 00	 call	 _Py_IncRef
  0003e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 11959: }

  00045	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00049	5f		 pop	 rdi
  0004a	5d		 pop	 rbp
  0004b	c3		 ret	 0
$LN106@unicode_re@7:

; 11905: 
; 11906:     /* no repeat, return original string */
; 11907:     if (len == 1)

  0004c	75 0b		 jne	 SHORT $LN34@unicode_re@7

; 11959: }

  0004e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00052	5f		 pop	 rdi
  00053	5d		 pop	 rbp
  00054	e9 00 00 00 00	 jmp	 unicode_result_unchanged
$LN34@unicode_re@7:

; 11908:         return unicode_result_unchanged(str);
; 11909: 
; 11910:     if (PyUnicode_READY(str) == -1)

  00059	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0005d	75 13		 jne	 SHORT $LN33@unicode_re@7
  0005f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00064	83 f8 ff	 cmp	 eax, -1
  00067	75 09		 jne	 SHORT $LN33@unicode_re@7

; 11911:         return NULL;

  00069	33 c0		 xor	 eax, eax

; 11959: }

  0006b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006f	5f		 pop	 rdi
  00070	5d		 pop	 rbp
  00071	c3		 ret	 0
$LN33@unicode_re@7:

; 11912: 
; 11913:     if (PyUnicode_GET_LENGTH(str) > PY_SSIZE_T_MAX / len) {

  00072	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0007c	4c 89 6c 24 58	 mov	 QWORD PTR [rsp+88], r13
  00081	4c 8b 6f 60	 mov	 r13, QWORD PTR [rdi+96]
  00085	48 99		 cdq
  00087	48 f7 fd	 idiv	 rbp
  0008a	4c 3b e8	 cmp	 r13, rax
  0008d	7e 21		 jle	 SHORT $LN32@unicode_re@7

; 11914:         PyErr_SetString(PyExc_OverflowError,
; 11915:                         "repeated string is too long");

  0008f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@IMFPEPF@repeated?5string?5is?5too?5long?$AA@
  0009d	e8 00 00 00 00	 call	 PyErr_SetString
  000a2	4c 8b 6c 24 58	 mov	 r13, QWORD PTR [rsp+88]

; 11916:         return NULL;

  000a7	33 c0		 xor	 eax, eax

; 11959: }

  000a9	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ad	5f		 pop	 rdi
  000ae	5d		 pop	 rbp
  000af	c3		 ret	 0
$LN32@unicode_re@7:

; 11917:     }
; 11918:     nchars = len * PyUnicode_GET_LENGTH(str);
; 11919: 
; 11920:     u = PyUnicode_New(nchars, PyUnicode_MAX_CHAR_VALUE(str));

  000b0	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  000b3	4c 0f af ed	 imul	 r13, rbp
  000b7	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  000bc	a8 40		 test	 al, 64			; 00000040H
  000be	74 07		 je	 SHORT $LN51@unicode_re@7
  000c0	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  000c5	eb 22		 jmp	 SHORT $LN50@unicode_re@7
$LN51@unicode_re@7:
  000c7	c1 e8 02	 shr	 eax, 2
  000ca	83 e0 07	 and	 eax, 7
  000cd	83 f8 01	 cmp	 eax, 1
  000d0	75 07		 jne	 SHORT $LN49@unicode_re@7
  000d2	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  000d7	eb 10		 jmp	 SHORT $LN50@unicode_re@7
$LN49@unicode_re@7:
  000d9	ba ff ff 10 00	 mov	 edx, 1114111		; 0010ffffH
  000de	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  000e3	83 f8 02	 cmp	 eax, 2
  000e6	0f 44 d1	 cmove	 edx, ecx
$LN50@unicode_re@7:
  000e9	49 8b cd	 mov	 rcx, r13
  000ec	e8 00 00 00 00	 call	 PyUnicode_New
  000f1	48 8b f0	 mov	 rsi, rax

; 11921:     if (!u)

  000f4	48 85 c0	 test	 rax, rax
  000f7	75 11		 jne	 SHORT $LN31@unicode_re@7
  000f9	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000fe	4c 8b 6c 24 58	 mov	 r13, QWORD PTR [rsp+88]

; 11959: }

  00103	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00107	5f		 pop	 rdi
  00108	5d		 pop	 rbp
  00109	c3		 ret	 0
$LN31@unicode_re@7:

; 11922:         return NULL;
; 11923:     assert(PyUnicode_KIND(u) == PyUnicode_KIND(str));
; 11924: 
; 11925:     if (PyUnicode_GET_LENGTH(str) == 1) {
; 11926:         const int kind = PyUnicode_KIND(str);

  0010a	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  0010d	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00112	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  00116	48 83 fb 01	 cmp	 rbx, 1
  0011a	0f 85 2f 01 00
	00		 jne	 $LN30@unicode_re@7
  00120	8b c8		 mov	 ecx, eax
  00122	c1 e9 02	 shr	 ecx, 2
  00125	83 e1 07	 and	 ecx, 7

; 11927:         const Py_UCS4 fill_char = PyUnicode_READ(kind, PyUnicode_DATA(str), 0);

  00128	3b cb		 cmp	 ecx, ebx
  0012a	75 68		 jne	 SHORT $LN67@unicode_re@7
  0012c	a8 20		 test	 al, 32			; 00000020H
  0012e	74 13		 je	 SHORT $LN55@unicode_re@7
  00130	a8 40		 test	 al, 64			; 00000040H
  00132	74 06		 je	 SHORT $LN53@unicode_re@7
  00134	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  00138	eb 10		 jmp	 SHORT $LN56@unicode_re@7
$LN53@unicode_re@7:
  0013a	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  00141	eb 07		 jmp	 SHORT $LN56@unicode_re@7
$LN55@unicode_re@7:
  00143	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
$LN56@unicode_re@7:

; 11928:         if (kind == PyUnicode_1BYTE_KIND) {
; 11929:             void *to = PyUnicode_DATA(u);

  0014a	8b 46 70	 mov	 eax, DWORD PTR [rsi+112]
  0014d	0f b6 17	 movzx	 edx, BYTE PTR [rdi]
  00150	a8 20		 test	 al, 32			; 00000020H
  00152	74 2c		 je	 SHORT $LN71@unicode_re@7
  00154	a8 40		 test	 al, 64			; 00000040H
  00156	74 14		 je	 SHORT $LN69@unicode_re@7
  00158	48 8d 8e 80 00
	00 00		 lea	 rcx, QWORD PTR [rsi+128]

; 11930:             memset(to, (unsigned char)fill_char, len);

  0015f	4c 8b c5	 mov	 r8, rbp
  00162	e8 00 00 00 00	 call	 memset
  00167	e9 e5 01 00 00	 jmp	 $LN9@unicode_re@7
$LN69@unicode_re@7:

; 11928:         if (kind == PyUnicode_1BYTE_KIND) {
; 11929:             void *to = PyUnicode_DATA(u);

  0016c	48 8d 8e a0 00
	00 00		 lea	 rcx, QWORD PTR [rsi+160]

; 11930:             memset(to, (unsigned char)fill_char, len);

  00173	4c 8b c5	 mov	 r8, rbp
  00176	e8 00 00 00 00	 call	 memset
  0017b	e9 d1 01 00 00	 jmp	 $LN9@unicode_re@7
$LN71@unicode_re@7:

; 11928:         if (kind == PyUnicode_1BYTE_KIND) {
; 11929:             void *to = PyUnicode_DATA(u);

  00180	48 8b 8e a0 00
	00 00		 mov	 rcx, QWORD PTR [rsi+160]

; 11930:             memset(to, (unsigned char)fill_char, len);

  00187	4c 8b c5	 mov	 r8, rbp
  0018a	e8 00 00 00 00	 call	 memset
  0018f	e9 bd 01 00 00	 jmp	 $LN9@unicode_re@7
$LN67@unicode_re@7:

; 11927:         const Py_UCS4 fill_char = PyUnicode_READ(kind, PyUnicode_DATA(str), 0);

  00194	83 f9 02	 cmp	 ecx, 2
  00197	75 5c		 jne	 SHORT $LN65@unicode_re@7
  00199	a8 20		 test	 al, 32			; 00000020H
  0019b	74 13		 je	 SHORT $LN59@unicode_re@7
  0019d	a8 40		 test	 al, 64			; 00000040H
  0019f	74 06		 je	 SHORT $LN57@unicode_re@7
  001a1	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  001a5	eb 10		 jmp	 SHORT $LN60@unicode_re@7
$LN57@unicode_re@7:
  001a7	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  001ae	eb 07		 jmp	 SHORT $LN60@unicode_re@7
$LN59@unicode_re@7:
  001b0	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
$LN60@unicode_re@7:

; 11931:         }
; 11932:         else if (kind == PyUnicode_2BYTE_KIND) {
; 11933:             Py_UCS2 *ucs2 = PyUnicode_2BYTE_DATA(u);

  001b7	8b 46 70	 mov	 eax, DWORD PTR [rsi+112]
  001ba	0f b7 0f	 movzx	 ecx, WORD PTR [rdi]
  001bd	a8 20		 test	 al, 32			; 00000020H
  001bf	74 16		 je	 SHORT $LN75@unicode_re@7
  001c1	a8 40		 test	 al, 64			; 00000040H
  001c3	74 09		 je	 SHORT $LN73@unicode_re@7
  001c5	48 8d be 80 00
	00 00		 lea	 rdi, QWORD PTR [rsi+128]
  001cc	eb 10		 jmp	 SHORT $LN76@unicode_re@7
$LN73@unicode_re@7:
  001ce	48 8d be a0 00
	00 00		 lea	 rdi, QWORD PTR [rsi+160]
  001d5	eb 07		 jmp	 SHORT $LN76@unicode_re@7
$LN75@unicode_re@7:
  001d7	48 8b be a0 00
	00 00		 mov	 rdi, QWORD PTR [rsi+160]
$LN76@unicode_re@7:

; 11934:             for (n = 0; n < len; ++n)

  001de	48 85 ed	 test	 rbp, rbp
  001e1	0f 8e 6a 01 00
	00		 jle	 $LN9@unicode_re@7
  001e7	48 8b c1	 mov	 rax, rcx
  001ea	48 8b cd	 mov	 rcx, rbp
  001ed	66 f3 ab	 rep stosw

; 11935:                 ucs2[n] = fill_char;
; 11936:         } else {

  001f0	e9 5c 01 00 00	 jmp	 $LN9@unicode_re@7
$LN65@unicode_re@7:

; 11927:         const Py_UCS4 fill_char = PyUnicode_READ(kind, PyUnicode_DATA(str), 0);

  001f5	a8 20		 test	 al, 32			; 00000020H
  001f7	74 13		 je	 SHORT $LN63@unicode_re@7
  001f9	a8 40		 test	 al, 64			; 00000040H
  001fb	74 06		 je	 SHORT $LN61@unicode_re@7
  001fd	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  00201	eb 10		 jmp	 SHORT $LN64@unicode_re@7
$LN61@unicode_re@7:
  00203	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  0020a	eb 07		 jmp	 SHORT $LN64@unicode_re@7
$LN63@unicode_re@7:
  0020c	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
$LN64@unicode_re@7:

; 11937:             Py_UCS4 *ucs4 = PyUnicode_4BYTE_DATA(u);

  00213	8b 46 70	 mov	 eax, DWORD PTR [rsi+112]
  00216	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00218	a8 20		 test	 al, 32			; 00000020H
  0021a	74 16		 je	 SHORT $LN79@unicode_re@7
  0021c	a8 40		 test	 al, 64			; 00000040H
  0021e	74 09		 je	 SHORT $LN77@unicode_re@7
  00220	48 8d be 80 00
	00 00		 lea	 rdi, QWORD PTR [rsi+128]
  00227	eb 10		 jmp	 SHORT $LN80@unicode_re@7
$LN77@unicode_re@7:
  00229	48 8d be a0 00
	00 00		 lea	 rdi, QWORD PTR [rsi+160]
  00230	eb 07		 jmp	 SHORT $LN80@unicode_re@7
$LN79@unicode_re@7:
  00232	48 8b be a0 00
	00 00		 mov	 rdi, QWORD PTR [rsi+160]
$LN80@unicode_re@7:

; 11938:             assert(kind == PyUnicode_4BYTE_KIND);
; 11939:             for (n = 0; n < len; ++n)

  00239	48 85 ed	 test	 rbp, rbp
  0023c	0f 8e 0f 01 00
	00		 jle	 $LN9@unicode_re@7
  00242	48 8b c1	 mov	 rax, rcx
  00245	48 8b cd	 mov	 rcx, rbp
  00248	f3 ab		 rep stosd

; 11940:                 ucs4[n] = fill_char;
; 11941:         }
; 11942:     }
; 11943:     else {

  0024a	e9 02 01 00 00	 jmp	 $LN9@unicode_re@7
$LN30@unicode_re@7:

; 11944:         /* number of characters copied this far */
; 11945:         Py_ssize_t done = PyUnicode_GET_LENGTH(str);
; 11946:         const Py_ssize_t char_size = PyUnicode_KIND(str);
; 11947:         char *to = (char *) PyUnicode_DATA(u);

  0024f	8b 4e 70	 mov	 ecx, DWORD PTR [rsi+112]
  00252	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00257	4c 8b f0	 mov	 r14, rax
  0025a	49 c1 ee 02	 shr	 r14, 2
  0025e	41 83 e6 07	 and	 r14d, 7
  00262	f6 c1 20	 test	 cl, 32			; 00000020H
  00265	74 17		 je	 SHORT $LN83@unicode_re@7
  00267	f6 c1 40	 test	 cl, 64			; 00000040H
  0026a	74 09		 je	 SHORT $LN81@unicode_re@7
  0026c	48 8d ae 80 00
	00 00		 lea	 rbp, QWORD PTR [rsi+128]
  00273	eb 10		 jmp	 SHORT $LN84@unicode_re@7
$LN81@unicode_re@7:
  00275	48 8d ae a0 00
	00 00		 lea	 rbp, QWORD PTR [rsi+160]
  0027c	eb 07		 jmp	 SHORT $LN84@unicode_re@7
$LN83@unicode_re@7:
  0027e	48 8b ae a0 00
	00 00		 mov	 rbp, QWORD PTR [rsi+160]
$LN84@unicode_re@7:

; 11948:         Py_MEMCPY(to, PyUnicode_DATA(str),
; 11949:                   PyUnicode_GET_LENGTH(str) * char_size);

  00285	48 8b d3	 mov	 rdx, rbx
  00288	49 0f af d6	 imul	 rdx, r14
  0028c	a8 20		 test	 al, 32			; 00000020H
  0028e	74 13		 je	 SHORT $LN87@unicode_re@7
  00290	a8 40		 test	 al, 64			; 00000040H
  00292	74 06		 je	 SHORT $LN85@unicode_re@7
  00294	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  00298	eb 10		 jmp	 SHORT $LN88@unicode_re@7
$LN85@unicode_re@7:
  0029a	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  002a1	eb 07		 jmp	 SHORT $LN88@unicode_re@7
$LN87@unicode_re@7:
  002a3	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
$LN88@unicode_re@7:
  002aa	48 83 fa 10	 cmp	 rdx, 16
  002ae	72 10		 jb	 SHORT $LN15@unicode_re@7
  002b0	4c 8b c2	 mov	 r8, rdx
  002b3	48 8b cd	 mov	 rcx, rbp
  002b6	48 8b d7	 mov	 rdx, rdi
  002b9	e8 00 00 00 00	 call	 memcpy
  002be	eb 1f		 jmp	 SHORT $LN17@unicode_re@7
$LN15@unicode_re@7:
  002c0	48 85 d2	 test	 rdx, rdx
  002c3	74 1a		 je	 SHORT $LN17@unicode_re@7
  002c5	48 8b cd	 mov	 rcx, rbp
  002c8	48 2b fd	 sub	 rdi, rbp
  002cb	0f 1f 44 00 00	 npad	 5
$LL13@unicode_re@7:
  002d0	0f b6 04 0f	 movzx	 eax, BYTE PTR [rdi+rcx]
  002d4	48 ff c1	 inc	 rcx
  002d7	48 ff ca	 dec	 rdx
  002da	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  002dd	75 f1		 jne	 SHORT $LL13@unicode_re@7
$LN17@unicode_re@7:

; 11950:         while (done < nchars) {

  002df	49 3b dd	 cmp	 rbx, r13
  002e2	7d 68		 jge	 SHORT $LN105@unicode_re@7
  002e4	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  002e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@unicode_re@7:

; 11951:             n = (done <= nchars-done) ? done : nchars-done;

  002f0	4d 8b e5	 mov	 r12, r13

; 11952:             Py_MEMCPY(to + (done * char_size), to, n * char_size);

  002f3	49 8b ce	 mov	 rcx, r14
  002f6	49 8b d6	 mov	 rdx, r14
  002f9	4c 2b e3	 sub	 r12, rbx
  002fc	49 3b dc	 cmp	 rbx, r12
  002ff	4c 0f 4e e3	 cmovle	 r12, rbx
  00303	48 0f af cb	 imul	 rcx, rbx
  00307	49 0f af d4	 imul	 rdx, r12
  0030b	48 03 cd	 add	 rcx, rbp
  0030e	48 83 fa 10	 cmp	 rdx, 16
  00312	72 0d		 jb	 SHORT $LN5@unicode_re@7
  00314	4c 8b c2	 mov	 r8, rdx
  00317	48 8b d5	 mov	 rdx, rbp
  0031a	e8 00 00 00 00	 call	 memcpy
  0031f	eb 1e		 jmp	 SHORT $LN7@unicode_re@7
$LN5@unicode_re@7:
  00321	48 85 d2	 test	 rdx, rdx
  00324	74 19		 je	 SHORT $LN7@unicode_re@7
  00326	48 8b fd	 mov	 rdi, rbp
  00329	48 2b f9	 sub	 rdi, rcx
  0032c	0f 1f 40 00	 npad	 4
$LL3@unicode_re@7:
  00330	0f b6 04 0f	 movzx	 eax, BYTE PTR [rdi+rcx]
  00334	48 ff c1	 inc	 rcx
  00337	48 ff ca	 dec	 rdx
  0033a	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0033d	75 f1		 jne	 SHORT $LL3@unicode_re@7
$LN7@unicode_re@7:

; 11953:             done += n;

  0033f	49 03 dc	 add	 rbx, r12
  00342	49 3b dd	 cmp	 rbx, r13
  00345	7c a9		 jl	 SHORT $LL10@unicode_re@7
  00347	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
$LN105@unicode_re@7:
  0034c	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
$LN9@unicode_re@7:
  00351	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00356	4c 8b 6c 24 58	 mov	 r13, QWORD PTR [rsp+88]

; 11954:         }
; 11955:     }
; 11956: 
; 11957:     assert(_PyUnicode_CheckConsistency(u, 1));
; 11958:     return u;

  0035b	48 8b c6	 mov	 rax, rsi
  0035e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
$LN45@unicode_re@7:

; 11959: }

  00363	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00367	5f		 pop	 rdi
  00368	5d		 pop	 rbp
  00369	c3		 ret	 0
unicode_repeat ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_Replace
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_Replace DD imagerel $LN19
	DD	imagerel $LN19+238
	DD	imagerel $unwind$PyUnicode_Replace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Replace DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_Replace
_TEXT	SEGMENT
obj$ = 48
subobj$ = 56
replobj$ = 64
maxcount$ = 72
PyUnicode_Replace PROC					; COMDAT

; 11966: {

$LN19:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	49 8b e9	 mov	 rbp, r9
  00017	49 8b f0	 mov	 rsi, r8
  0001a	48 8b fa	 mov	 rdi, rdx

; 11967:     PyObject *self;
; 11968:     PyObject *str1;
; 11969:     PyObject *str2;
; 11970:     PyObject *result;
; 11971: 
; 11972:     self = PyUnicode_FromObject(obj);

  0001d	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00022	48 8b d8	 mov	 rbx, rax

; 11973:     if (self == NULL)

  00025	48 85 c0	 test	 rax, rax

; 11974:         return NULL;

  00028	74 18		 je	 SHORT $LN18@PyUnicode_@90

; 11975:     str1 = PyUnicode_FromObject(subobj);

  0002a	48 8b cf	 mov	 rcx, rdi
  0002d	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00032	48 8b f8	 mov	 rdi, rax

; 11976:     if (str1 == NULL) {

  00035	48 85 c0	 test	 rax, rax
  00038	75 0f		 jne	 SHORT $LN5@PyUnicode_@90

; 11977:         Py_DECREF(self);

  0003a	48 8b cb	 mov	 rcx, rbx
  0003d	e8 00 00 00 00	 call	 _Py_DecRef
$LN18@PyUnicode_@90:

; 11978:         return NULL;

  00042	33 c0		 xor	 eax, eax
  00044	e9 90 00 00 00	 jmp	 $LN7@PyUnicode_@90
$LN5@PyUnicode_@90:

; 11979:     }
; 11980:     str2 = PyUnicode_FromObject(replobj);

  00049	48 8b ce	 mov	 rcx, rsi
  0004c	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00051	48 8b f0	 mov	 rsi, rax

; 11981:     if (str2 == NULL) {

  00054	48 85 c0	 test	 rax, rax
  00057	75 14		 jne	 SHORT $LN4@PyUnicode_@90

; 11982:         Py_DECREF(self);

  00059	48 8b cb	 mov	 rcx, rbx
  0005c	e8 00 00 00 00	 call	 _Py_DecRef

; 11983:         Py_DECREF(str1);

  00061	48 8b cf	 mov	 rcx, rdi
  00064	e8 00 00 00 00	 call	 _Py_DecRef

; 11984:         return NULL;

  00069	33 c0		 xor	 eax, eax
  0006b	eb 6c		 jmp	 SHORT $LN7@PyUnicode_@90
$LN4@PyUnicode_@90:

; 11985:     }
; 11986:     if (PyUnicode_READY(self) == -1 ||
; 11987:         PyUnicode_READY(str1) == -1 ||
; 11988:         PyUnicode_READY(str2) == -1)

  0006d	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00071	75 0d		 jne	 SHORT $LN15@PyUnicode_@90
  00073	48 8b cb	 mov	 rcx, rbx
  00076	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0007b	83 f8 ff	 cmp	 eax, -1
  0007e	74 26		 je	 SHORT $LN2@PyUnicode_@90
$LN15@PyUnicode_@90:
  00080	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  00084	75 0d		 jne	 SHORT $LN16@PyUnicode_@90
  00086	48 8b cf	 mov	 rcx, rdi
  00089	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0008e	83 f8 ff	 cmp	 eax, -1
  00091	74 13		 je	 SHORT $LN2@PyUnicode_@90
$LN16@PyUnicode_@90:
  00093	f6 46 70 80	 test	 BYTE PTR [rsi+112], 128	; 00000080H
  00097	75 11		 jne	 SHORT $LN17@PyUnicode_@90
  00099	48 8b ce	 mov	 rcx, rsi
  0009c	e8 00 00 00 00	 call	 _PyUnicode_Ready
  000a1	83 f8 ff	 cmp	 eax, -1
  000a4	75 04		 jne	 SHORT $LN17@PyUnicode_@90
$LN2@PyUnicode_@90:

; 11989:         result = NULL;

  000a6	33 ed		 xor	 ebp, ebp
  000a8	eb 14		 jmp	 SHORT $LN1@PyUnicode_@90
$LN17@PyUnicode_@90:

; 11990:     else
; 11991:         result = replace(self, str1, str2, maxcount);

  000aa	4c 8b cd	 mov	 r9, rbp
  000ad	4c 8b c6	 mov	 r8, rsi
  000b0	48 8b d7	 mov	 rdx, rdi
  000b3	48 8b cb	 mov	 rcx, rbx
  000b6	e8 00 00 00 00	 call	 replace
  000bb	48 8b e8	 mov	 rbp, rax
$LN1@PyUnicode_@90:

; 11992:     Py_DECREF(self);

  000be	48 8b cb	 mov	 rcx, rbx
  000c1	e8 00 00 00 00	 call	 _Py_DecRef

; 11993:     Py_DECREF(str1);

  000c6	48 8b cf	 mov	 rcx, rdi
  000c9	e8 00 00 00 00	 call	 _Py_DecRef

; 11994:     Py_DECREF(str2);

  000ce	48 8b ce	 mov	 rcx, rsi
  000d1	e8 00 00 00 00	 call	 _Py_DecRef

; 11995:     return result;

  000d6	48 8b c5	 mov	 rax, rbp
$LN7@PyUnicode_@90:

; 11996: }

  000d9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000de	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000e3	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000e8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ec	5f		 pop	 rdi
  000ed	c3		 ret	 0
PyUnicode_Replace ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@BJBCHDAG@OO?$HMn?3replace?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_replace DD imagerel unicode_replace
	DD	imagerel unicode_replace+252
	DD	imagerel $unwind$unicode_replace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_replace DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT ??_C@_0N@BJBCHDAG@OO?$HMn?3replace?$AA@
CONST	SEGMENT
??_C@_0N@BJBCHDAG@OO?$HMn?3replace?$AA@ DB 'OO|n:replace', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_replace
_TEXT	SEGMENT
maxcount$ = 48
self$ = 80
args$ = 88
str1$ = 96
str2$ = 104
unicode_replace PROC					; COMDAT

; 12007: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 12008:     PyObject *str1;
; 12009:     PyObject *str2;
; 12010:     Py_ssize_t maxcount = -1;
; 12011:     PyObject *result;
; 12012: 
; 12013:     if (!PyArg_ParseTuple(args, "OO|n:replace", &str1, &str2, &maxcount))

  0000c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR maxcount$[rsp]
  00011	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00016	4c 8d 4c 24 68	 lea	 r9, QWORD PTR str2$[rsp]
  0001b	4c 8d 44 24 60	 lea	 r8, QWORD PTR str1$[rsp]
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@BJBCHDAG@OO?$HMn?3replace?$AA@
  00027	48 8b c8	 mov	 rcx, rax
  0002a	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR maxcount$[rsp], -1
  00033	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00038	85 c0		 test	 eax, eax

; 12014:         return NULL;

  0003a	74 45		 je	 SHORT $LN18@unicode_re@8

; 12015:     if (PyUnicode_READY(self) == -1)

  0003c	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00040	75 0d		 jne	 SHORT $LN6@unicode_re@8
  00042	48 8b cb	 mov	 rcx, rbx
  00045	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0004a	83 f8 ff	 cmp	 eax, -1

; 12016:         return NULL;

  0004d	74 32		 je	 SHORT $LN18@unicode_re@8
$LN6@unicode_re@8:

; 12017:     str1 = PyUnicode_FromObject(str1);

  0004f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str1$[rsp]
  00054	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00059	48 89 44 24 60	 mov	 QWORD PTR str1$[rsp], rax

; 12018:     if (str1 == NULL)

  0005e	48 85 c0	 test	 rax, rax

; 12019:         return NULL;

  00061	74 1e		 je	 SHORT $LN18@unicode_re@8

; 12020:     str2 = PyUnicode_FromObject(str2);

  00063	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str2$[rsp]
  00068	e8 00 00 00 00	 call	 PyUnicode_FromObject
  0006d	48 89 44 24 68	 mov	 QWORD PTR str2$[rsp], rax

; 12021:     if (str2 == NULL) {

  00072	48 85 c0	 test	 rax, rax
  00075	75 12		 jne	 SHORT $LN4@unicode_re@8

; 12022:         Py_DECREF(str1);

  00077	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str1$[rsp]
  0007c	e8 00 00 00 00	 call	 _Py_DecRef
$LN18@unicode_re@8:

; 12023:         return NULL;

  00081	33 c0		 xor	 eax, eax

; 12033: }

  00083	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00087	5b		 pop	 rbx
  00088	c3		 ret	 0
$LN4@unicode_re@8:

; 12024:     }
; 12025:     if (PyUnicode_READY(str1) == -1 || PyUnicode_READY(str2) == -1)

  00089	48 8b 54 24 60	 mov	 rdx, QWORD PTR str1$[rsp]
  0008e	f6 42 70 80	 test	 BYTE PTR [rdx+112], 128	; 00000080H
  00092	75 17		 jne	 SHORT $LN16@unicode_re@8
  00094	48 8b ca	 mov	 rcx, rdx
  00097	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0009c	83 f8 ff	 cmp	 eax, -1
  0009f	74 57		 je	 SHORT $LN2@unicode_re@8
  000a1	48 8b 44 24 68	 mov	 rax, QWORD PTR str2$[rsp]
  000a6	48 8b 54 24 60	 mov	 rdx, QWORD PTR str1$[rsp]
$LN16@unicode_re@8:
  000ab	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  000af	75 17		 jne	 SHORT $LN17@unicode_re@8
  000b1	48 8b c8	 mov	 rcx, rax
  000b4	e8 00 00 00 00	 call	 _PyUnicode_Ready
  000b9	83 f8 ff	 cmp	 eax, -1
  000bc	74 3a		 je	 SHORT $LN2@unicode_re@8
  000be	48 8b 44 24 68	 mov	 rax, QWORD PTR str2$[rsp]
  000c3	48 8b 54 24 60	 mov	 rdx, QWORD PTR str1$[rsp]
$LN17@unicode_re@8:

; 12027:     else
; 12028:         result = replace(self, str1, str2, maxcount);

  000c8	4c 8b 4c 24 30	 mov	 r9, QWORD PTR maxcount$[rsp]
  000cd	4c 8b c0	 mov	 r8, rax
  000d0	48 8b cb	 mov	 rcx, rbx
  000d3	e8 00 00 00 00	 call	 replace
  000d8	48 8b d8	 mov	 rbx, rax
$LN1@unicode_re@8:

; 12029: 
; 12030:     Py_DECREF(str1);

  000db	48 8b 4c 24 60	 mov	 rcx, QWORD PTR str1$[rsp]
  000e0	e8 00 00 00 00	 call	 _Py_DecRef

; 12031:     Py_DECREF(str2);

  000e5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str2$[rsp]
  000ea	e8 00 00 00 00	 call	 _Py_DecRef

; 12032:     return result;

  000ef	48 8b c3	 mov	 rax, rbx

; 12033: }

  000f2	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000f6	5b		 pop	 rbx
  000f7	c3		 ret	 0
$LN2@unicode_re@8:

; 12026:         result = NULL;

  000f8	33 db		 xor	 ebx, ebx
  000fa	eb df		 jmp	 SHORT $LN1@unicode_re@8
unicode_replace ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\find.h
pdata	SEGMENT
$pdata$unicode_rfind DD imagerel unicode_rfind
	DD	imagerel unicode_rfind+382
	DD	imagerel $unwind$unicode_rfind
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_rfind DD 081801H
	DD	0156418H
	DD	0143418H
	DD	0c00ef218H
	DD	0500b700cH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT unicode_rfind
_TEXT	SEGMENT
tmp_start$162692 = 48
tmp_end$162693 = 56
tmp_subobj$162691 = 64
format$162696 = 72
self$ = 160
args$ = 168
obj_start$162694 = 176
obj_end$162695 = 184
unicode_rfind PROC					; COMDAT

; 12195: {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00018	48 8b f1	 mov	 rsi, rcx

; 12196:     PyObject *substring;
; 12197:     Py_ssize_t start;
; 12198:     Py_ssize_t end;
; 12199:     Py_ssize_t result;
; 12200: 
; 12201:     if (!stringlib_parse_args_finds_unicode("rfind", args, &substring,
; 12202:                                             &start, &end))

  0001b	48 83 c9 ff	 or	 rcx, -1
  0001f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00029	48 89 45 b8	 mov	 QWORD PTR tmp_end$162693[rbp-128], rax
  0002d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@
  00033	48 8b da	 mov	 rbx, rdx
  00036	89 45 c8	 mov	 DWORD PTR format$162696[rbp-128], eax
  00039	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@+4
  00040	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_NoneStruct
  00047	66 89 45 cc	 mov	 WORD PTR format$162696[rbp-124], ax
  0004b	33 c0		 xor	 eax, eax
  0004d	48 8d 7d c8	 lea	 rdi, QWORD PTR format$162696[rbp-128]
  00051	48 89 45 ce	 mov	 QWORD PTR format$162696[rbp-122], rax
  00055	48 89 45 d6	 mov	 QWORD PTR format$162696[rbp-114], rax
  00059	48 89 45 de	 mov	 QWORD PTR format$162696[rbp-106], rax
  0005d	48 89 45 e6	 mov	 QWORD PTR format$162696[rbp-98], rax
  00061	48 89 45 ee	 mov	 QWORD PTR format$162696[rbp-90], rax
  00065	89 45 f6	 mov	 DWORD PTR format$162696[rbp-82], eax
  00068	f2 ae		 repne scasb
  0006a	41 b8 31 00 00
	00		 mov	 r8d, 49			; 00000031H
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05BLFDIAHL@rfind?$AA@
  00077	48 f7 d1	 not	 rcx
  0007a	48 c7 45 b0 00
	00 00 00	 mov	 QWORD PTR tmp_start$162692[rbp-128], 0
  00082	4c 89 65 30	 mov	 QWORD PTR obj_start$162694[rbp-128], r12
  00086	48 ff c9	 dec	 rcx
  00089	4c 89 65 38	 mov	 QWORD PTR obj_end$162695[rbp-128], r12
  0008d	4c 2b c1	 sub	 r8, rcx
  00090	48 8d 4c 0d c8	 lea	 rcx, QWORD PTR format$162696[rbp+rcx-128]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
  0009b	48 8d 45 38	 lea	 rax, QWORD PTR obj_end$162695[rbp-128]
  0009f	4c 8d 4d 30	 lea	 r9, QWORD PTR obj_start$162694[rbp-128]
  000a3	4c 8d 45 c0	 lea	 r8, QWORD PTR tmp_subobj$162691[rbp-128]
  000a7	48 8d 55 c8	 lea	 rdx, QWORD PTR format$162696[rbp-128]
  000ab	48 8b cb	 mov	 rcx, rbx
  000ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b3	c6 45 f9 00	 mov	 BYTE PTR format$162696[rbp-79], 0
  000b7	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000bc	85 c0		 test	 eax, eax
  000be	0f 84 a0 00 00
	00		 je	 $LN12@unicode_rf
  000c4	48 8b 4d 30	 mov	 rcx, QWORD PTR obj_start$162694[rbp-128]
  000c8	49 3b cc	 cmp	 rcx, r12
  000cb	74 11		 je	 SHORT $LN17@unicode_rf
  000cd	48 8d 55 b0	 lea	 rdx, QWORD PTR tmp_start$162692[rbp-128]
  000d1	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000d6	85 c0		 test	 eax, eax
  000d8	0f 84 86 00 00
	00		 je	 $LN12@unicode_rf
$LN17@unicode_rf:
  000de	48 8b 4d 38	 mov	 rcx, QWORD PTR obj_end$162695[rbp-128]
  000e2	49 3b cc	 cmp	 rcx, r12
  000e5	74 0d		 je	 SHORT $LN15@unicode_rf
  000e7	48 8d 55 b8	 lea	 rdx, QWORD PTR tmp_end$162693[rbp-128]
  000eb	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000f0	85 c0		 test	 eax, eax
  000f2	74 70		 je	 SHORT $LN12@unicode_rf
$LN15@unicode_rf:
  000f4	48 8b 4d c0	 mov	 rcx, QWORD PTR tmp_subobj$162691[rbp-128]
  000f8	48 8b 5d b0	 mov	 rbx, QWORD PTR tmp_start$162692[rbp-128]
  000fc	4c 8b 65 b8	 mov	 r12, QWORD PTR tmp_end$162693[rbp-128]
  00100	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00105	48 8b f8	 mov	 rdi, rax
  00108	48 85 c0	 test	 rax, rax
  0010b	74 57		 je	 SHORT $LN12@unicode_rf

; 12204: 
; 12205:     if (PyUnicode_READY(self) == -1)

  0010d	f6 46 70 80	 test	 BYTE PTR [rsi+112], 128	; 00000080H
  00111	75 0d		 jne	 SHORT $LN3@unicode_rf
  00113	48 8b ce	 mov	 rcx, rsi
  00116	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0011b	83 f8 ff	 cmp	 eax, -1

; 12206:         return NULL;

  0011e	74 44		 je	 SHORT $LN12@unicode_rf
$LN3@unicode_rf:

; 12207:     if (PyUnicode_READY(substring) == -1)

  00120	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  00124	75 0d		 jne	 SHORT $LN2@unicode_rf
  00126	48 8b cf	 mov	 rcx, rdi
  00129	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0012e	83 f8 ff	 cmp	 eax, -1

; 12208:         return NULL;

  00131	74 31		 je	 SHORT $LN12@unicode_rf
$LN2@unicode_rf:

; 12209: 
; 12210:     result = any_find_slice(-1, self, substring, start, end);

  00133	4c 8b cb	 mov	 r9, rbx
  00136	4c 8b c7	 mov	 r8, rdi
  00139	48 8b d6	 mov	 rdx, rsi
  0013c	83 c9 ff	 or	 ecx, -1
  0013f	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  00144	e8 00 00 00 00	 call	 any_find_slice

; 12211: 
; 12212:     Py_DECREF(substring);

  00149	48 8b cf	 mov	 rcx, rdi
  0014c	48 8b d8	 mov	 rbx, rax
  0014f	e8 00 00 00 00	 call	 _Py_DecRef

; 12213: 
; 12214:     if (result == -2)

  00154	48 83 fb fe	 cmp	 rbx, -2

; 12215:         return NULL;

  00158	74 0a		 je	 SHORT $LN12@unicode_rf

; 12216: 
; 12217:     return PyLong_FromSsize_t(result);

  0015a	48 8b cb	 mov	 rcx, rbx
  0015d	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00162	eb 02		 jmp	 SHORT $LN5@unicode_rf

; 12196:     PyObject *substring;
; 12197:     Py_ssize_t start;
; 12198:     Py_ssize_t end;
; 12199:     Py_ssize_t result;
; 12200: 
; 12201:     if (!stringlib_parse_args_finds_unicode("rfind", args, &substring,
; 12202:                                             &start, &end))

$LN12@unicode_rf:

; 12203:         return NULL;

  00164	33 c0		 xor	 eax, eax
$LN5@unicode_rf:

; 12218: }

  00166	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  0016e	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  00172	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  00176	49 8b e3	 mov	 rsp, r11
  00179	41 5c		 pop	 r12
  0017b	5f		 pop	 rdi
  0017c	5d		 pop	 rbp
  0017d	c3		 ret	 0
unicode_rfind ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\find.h
pdata	SEGMENT
$pdata$unicode_rindex DD imagerel unicode_rindex
	DD	imagerel unicode_rindex+406
	DD	imagerel $unwind$unicode_rindex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_rindex DD 081801H
	DD	0156418H
	DD	0143418H
	DD	0c00ef218H
	DD	0500b700cH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT unicode_rindex
_TEXT	SEGMENT
tmp_start$162752 = 48
tmp_end$162753 = 56
tmp_subobj$162751 = 64
format$162756 = 72
self$ = 160
args$ = 168
obj_start$162754 = 176
obj_end$162755 = 184
unicode_rindex PROC					; COMDAT

; 12227: {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00018	48 8b f1	 mov	 rsi, rcx

; 12228:     PyObject *substring;
; 12229:     Py_ssize_t start;
; 12230:     Py_ssize_t end;
; 12231:     Py_ssize_t result;
; 12232: 
; 12233:     if (!stringlib_parse_args_finds_unicode("rindex", args, &substring,
; 12234:                                             &start, &end))

  0001b	48 83 c9 ff	 or	 rcx, -1
  0001f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00029	48 89 45 b8	 mov	 QWORD PTR tmp_end$162753[rbp-128], rax
  0002d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@
  00033	48 8b da	 mov	 rbx, rdx
  00036	89 45 c8	 mov	 DWORD PTR format$162756[rbp-128], eax
  00039	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@+4
  00040	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_NoneStruct
  00047	66 89 45 cc	 mov	 WORD PTR format$162756[rbp-124], ax
  0004b	33 c0		 xor	 eax, eax
  0004d	48 8d 7d c8	 lea	 rdi, QWORD PTR format$162756[rbp-128]
  00051	48 89 45 ce	 mov	 QWORD PTR format$162756[rbp-122], rax
  00055	48 89 45 d6	 mov	 QWORD PTR format$162756[rbp-114], rax
  00059	48 89 45 de	 mov	 QWORD PTR format$162756[rbp-106], rax
  0005d	48 89 45 e6	 mov	 QWORD PTR format$162756[rbp-98], rax
  00061	48 89 45 ee	 mov	 QWORD PTR format$162756[rbp-90], rax
  00065	89 45 f6	 mov	 DWORD PTR format$162756[rbp-82], eax
  00068	f2 ae		 repne scasb
  0006a	41 b8 31 00 00
	00		 mov	 r8d, 49			; 00000031H
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06NCDOMFM@rindex?$AA@
  00077	48 f7 d1	 not	 rcx
  0007a	48 c7 45 b0 00
	00 00 00	 mov	 QWORD PTR tmp_start$162752[rbp-128], 0
  00082	4c 89 65 30	 mov	 QWORD PTR obj_start$162754[rbp-128], r12
  00086	48 ff c9	 dec	 rcx
  00089	4c 89 65 38	 mov	 QWORD PTR obj_end$162755[rbp-128], r12
  0008d	4c 2b c1	 sub	 r8, rcx
  00090	48 8d 4c 0d c8	 lea	 rcx, QWORD PTR format$162756[rbp+rcx-128]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
  0009b	48 8d 45 38	 lea	 rax, QWORD PTR obj_end$162755[rbp-128]
  0009f	4c 8d 4d 30	 lea	 r9, QWORD PTR obj_start$162754[rbp-128]
  000a3	4c 8d 45 c0	 lea	 r8, QWORD PTR tmp_subobj$162751[rbp-128]
  000a7	48 8d 55 c8	 lea	 rdx, QWORD PTR format$162756[rbp-128]
  000ab	48 8b cb	 mov	 rcx, rbx
  000ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b3	c6 45 f9 00	 mov	 BYTE PTR format$162756[rbp-79], 0
  000b7	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000bc	85 c0		 test	 eax, eax
  000be	0f 84 ae 00 00
	00		 je	 $LN13@unicode_ri
  000c4	48 8b 4d 30	 mov	 rcx, QWORD PTR obj_start$162754[rbp-128]
  000c8	49 3b cc	 cmp	 rcx, r12
  000cb	74 11		 je	 SHORT $LN18@unicode_ri
  000cd	48 8d 55 b0	 lea	 rdx, QWORD PTR tmp_start$162752[rbp-128]
  000d1	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000d6	85 c0		 test	 eax, eax
  000d8	0f 84 94 00 00
	00		 je	 $LN13@unicode_ri
$LN18@unicode_ri:
  000de	48 8b 4d 38	 mov	 rcx, QWORD PTR obj_end$162755[rbp-128]
  000e2	49 3b cc	 cmp	 rcx, r12
  000e5	74 0d		 je	 SHORT $LN16@unicode_ri
  000e7	48 8d 55 b8	 lea	 rdx, QWORD PTR tmp_end$162753[rbp-128]
  000eb	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000f0	85 c0		 test	 eax, eax
  000f2	74 7e		 je	 SHORT $LN13@unicode_ri
$LN16@unicode_ri:
  000f4	48 8b 4d c0	 mov	 rcx, QWORD PTR tmp_subobj$162751[rbp-128]
  000f8	48 8b 5d b0	 mov	 rbx, QWORD PTR tmp_start$162752[rbp-128]
  000fc	4c 8b 65 b8	 mov	 r12, QWORD PTR tmp_end$162753[rbp-128]
  00100	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00105	48 8b f8	 mov	 rdi, rax
  00108	48 85 c0	 test	 rax, rax
  0010b	74 65		 je	 SHORT $LN13@unicode_ri

; 12236: 
; 12237:     if (PyUnicode_READY(self) == -1)

  0010d	f6 46 70 80	 test	 BYTE PTR [rsi+112], 128	; 00000080H
  00111	75 0d		 jne	 SHORT $LN4@unicode_ri
  00113	48 8b ce	 mov	 rcx, rsi
  00116	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0011b	83 f8 ff	 cmp	 eax, -1

; 12238:         return NULL;

  0011e	74 52		 je	 SHORT $LN13@unicode_ri
$LN4@unicode_ri:

; 12239:     if (PyUnicode_READY(substring) == -1)

  00120	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  00124	75 0d		 jne	 SHORT $LN3@unicode_ri
  00126	48 8b cf	 mov	 rcx, rdi
  00129	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0012e	83 f8 ff	 cmp	 eax, -1

; 12240:         return NULL;

  00131	74 3f		 je	 SHORT $LN13@unicode_ri
$LN3@unicode_ri:

; 12241: 
; 12242:     result = any_find_slice(-1, self, substring, start, end);

  00133	4c 8b cb	 mov	 r9, rbx
  00136	4c 8b c7	 mov	 r8, rdi
  00139	48 8b d6	 mov	 rdx, rsi
  0013c	83 c9 ff	 or	 ecx, -1
  0013f	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  00144	e8 00 00 00 00	 call	 any_find_slice

; 12243: 
; 12244:     Py_DECREF(substring);

  00149	48 8b cf	 mov	 rcx, rdi
  0014c	48 8b d8	 mov	 rbx, rax
  0014f	e8 00 00 00 00	 call	 _Py_DecRef

; 12245: 
; 12246:     if (result == -2)

  00154	48 83 fb fe	 cmp	 rbx, -2

; 12247:         return NULL;

  00158	74 18		 je	 SHORT $LN13@unicode_ri

; 12248: 
; 12249:     if (result < 0) {

  0015a	48 85 db	 test	 rbx, rbx
  0015d	79 2d		 jns	 SHORT $LN1@unicode_ri

; 12250:         PyErr_SetString(PyExc_ValueError, "substring not found");

  0015f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00166	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@NLNEJIOA@substring?5not?5found?$AA@
  0016d	e8 00 00 00 00	 call	 PyErr_SetString
$LN13@unicode_ri:

; 12235:         return NULL;

  00172	33 c0		 xor	 eax, eax
$LN6@unicode_ri:

; 12255: }

  00174	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  0017c	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  00180	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  00184	49 8b e3	 mov	 rsp, r11
  00187	41 5c		 pop	 r12
  00189	5f		 pop	 rdi
  0018a	5d		 pop	 rbp
  0018b	c3		 ret	 0
$LN1@unicode_ri:

; 12251:         return NULL;
; 12252:     }
; 12253: 
; 12254:     return PyLong_FromSsize_t(result);

  0018c	48 8b cb	 mov	 rcx, rbx
  0018f	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00194	eb de		 jmp	 SHORT $LN6@unicode_ri
unicode_rindex ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@JMODDCFD@n?$HMO?$CG?3rjust?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_rjust DD imagerel unicode_rjust
	DD	imagerel unicode_rjust+138
	DD	imagerel $unwind$unicode_rjust
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_rjust DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@JMODDCFD@n?$HMO?$CG?3rjust?$AA@
CONST	SEGMENT
??_C@_0L@JMODDCFD@n?$HMO?$CG?3rjust?$AA@ DB 'n|O&:rjust', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_rjust
_TEXT	SEGMENT
self$ = 64
args$ = 72
fillchar$ = 80
width$ = 88
unicode_rjust PROC					; COMDAT

; 12265: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 12266:     Py_ssize_t width;
; 12267:     Py_UCS4 fillchar = ' ';
; 12268: 
; 12269:     if (!PyArg_ParseTuple(args, "n|O&:rjust", &width, convert_uc, &fillchar))

  0000c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR fillchar$[rsp]
  00011	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00016	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:convert_uc
  0001d	4c 8d 44 24 58	 lea	 r8, QWORD PTR width$[rsp]
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@JMODDCFD@n?$HMO?$CG?3rjust?$AA@
  00029	48 8b c8	 mov	 rcx, rax
  0002c	c7 44 24 50 20
	00 00 00	 mov	 DWORD PTR fillchar$[rsp], 32 ; 00000020H
  00034	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00039	85 c0		 test	 eax, eax
  0003b	75 08		 jne	 SHORT $LN3@unicode_rj
$LN8@unicode_rj:

; 12270:         return NULL;

  0003d	33 c0		 xor	 eax, eax

; 12279: }

  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	5b		 pop	 rbx
  00044	c3		 ret	 0
$LN3@unicode_rj:

; 12271: 
; 12272:     if (PyUnicode_READY(self) == -1)

  00045	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00049	75 0d		 jne	 SHORT $LN2@unicode_rj
  0004b	48 8b cb	 mov	 rcx, rbx
  0004e	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00053	83 f8 ff	 cmp	 eax, -1

; 12273:         return NULL;

  00056	74 e5		 je	 SHORT $LN8@unicode_rj
$LN2@unicode_rj:

; 12274: 
; 12275:     if (PyUnicode_GET_LENGTH(self) >= width)

  00058	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  0005c	48 8b 54 24 58	 mov	 rdx, QWORD PTR width$[rsp]

; 12276:         return unicode_result_unchanged(self);

  00061	48 8b cb	 mov	 rcx, rbx
  00064	48 3b c2	 cmp	 rax, rdx
  00067	7c 0b		 jl	 SHORT $LN1@unicode_rj
  00069	e8 00 00 00 00	 call	 unicode_result_unchanged

; 12279: }

  0006e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00072	5b		 pop	 rbx
  00073	c3		 ret	 0
$LN1@unicode_rj:

; 12277: 
; 12278:     return pad(self, width - PyUnicode_GET_LENGTH(self), 0, fillchar);

  00074	44 8b 4c 24 50	 mov	 r9d, DWORD PTR fillchar$[rsp]
  00079	48 2b d0	 sub	 rdx, rax
  0007c	45 33 c0	 xor	 r8d, r8d
  0007f	e8 00 00 00 00	 call	 pad

; 12279: }

  00084	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00088	5b		 pop	 rbx
  00089	c3		 ret	 0
unicode_rjust ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_Split
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyUnicode_Split DD imagerel $LN22
	DD	imagerel $LN22+275
	DD	imagerel $unwind$PyUnicode_Split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Split DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT PyUnicode_Split
_TEXT	SEGMENT
s$ = 64
sep$ = 72
maxsplit$ = 80
PyUnicode_Split PROC					; COMDAT

; 12283: {

$LN22:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	49 8b f0	 mov	 rsi, r8
  00012	48 8b da	 mov	 rbx, rdx

; 12284:     PyObject *result;
; 12285: 
; 12286:     s = PyUnicode_FromObject(s);

  00015	e8 00 00 00 00	 call	 PyUnicode_FromObject
  0001a	48 8b f8	 mov	 rdi, rax

; 12287:     if (s == NULL)

  0001d	48 85 c0	 test	 rax, rax

; 12288:         return NULL;

  00020	74 1d		 je	 SHORT $LN21@PyUnicode_@91

; 12289:     if (sep != NULL) {

  00022	48 85 db	 test	 rbx, rbx
  00025	74 2a		 je	 SHORT $LN5@PyUnicode_@91

; 12290:         sep = PyUnicode_FromObject(sep);

  00027	48 8b cb	 mov	 rcx, rbx
  0002a	e8 00 00 00 00	 call	 PyUnicode_FromObject
  0002f	48 8b d8	 mov	 rbx, rax

; 12291:         if (sep == NULL) {

  00032	48 85 c0	 test	 rax, rax
  00035	75 1a		 jne	 SHORT $LN5@PyUnicode_@91

; 12292:             Py_DECREF(s);

  00037	48 8b cf	 mov	 rcx, rdi
  0003a	e8 00 00 00 00	 call	 _Py_DecRef
$LN21@PyUnicode_@91:

; 12293:             return NULL;

  0003f	33 c0		 xor	 eax, eax

; 12302: }

  00041	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00046	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0004b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
$LN5@PyUnicode_@91:

; 12294:         }
; 12295:     }
; 12296: 
; 12297:     result = split(s, sep, maxsplit);

  00051	4c 8b c6	 mov	 r8, rsi
  00054	48 8b d3	 mov	 rdx, rbx
  00057	48 8b cf	 mov	 rcx, rdi
  0005a	e8 00 00 00 00	 call	 split

; 12298: 
; 12299:     Py_DECREF(s);

  0005f	48 8b cf	 mov	 rcx, rdi
  00062	48 8b f0	 mov	 rsi, rax
  00065	e8 00 00 00 00	 call	 _Py_DecRef

; 12300:     Py_XDECREF(sep);

  0006a	48 85 db	 test	 rbx, rbx
  0006d	0f 84 8d 00 00
	00		 je	 $LN3@PyUnicode_@91
  00073	e8 00 00 00 00	 call	 _Py_PXCTX
  00078	85 c0		 test	 eax, eax
  0007a	0f 85 80 00 00
	00		 jne	 $LN3@PyUnicode_@91
  00080	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00084	f6 c1 20	 test	 cl, 32			; 00000020H
  00087	75 6f		 jne	 SHORT $LN14@PyUnicode_@91
  00089	84 c9		 test	 cl, cl
  0008b	78 6b		 js	 SHORT $LN14@PyUnicode_@91
  0008d	f6 c1 02	 test	 cl, 2
  00090	75 6e		 jne	 SHORT $LN3@PyUnicode_@91
  00092	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00096	75 68		 jne	 SHORT $LN3@PyUnicode_@91
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000a6	4c 8b cb	 mov	 r9, rbx
  000a9	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000af	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000b7	e8 00 00 00 00	 call	 _PyParallel_Guard
  000bc	48 8b cb	 mov	 rcx, rbx
  000bf	85 c0		 test	 eax, eax
  000c1	74 18		 je	 SHORT $LN19@PyUnicode_@91
  000c3	e8 00 00 00 00	 call	 _Px_Dealloc

; 12301:     return result;

  000c8	48 8b c6	 mov	 rax, rsi

; 12302: }

  000cb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d0	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000d5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0

; 12300:     Py_XDECREF(sep);

$LN19@PyUnicode_@91:
  000db	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000df	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 12301:     return result;

  000e5	48 8b c6	 mov	 rax, rsi

; 12302: }

  000e8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ed	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000f2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f6	5f		 pop	 rdi
  000f7	c3		 ret	 0

; 12300:     Py_XDECREF(sep);

$LN14@PyUnicode_@91:
  000f8	48 8b cb	 mov	 rcx, rbx
  000fb	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PyUnicode_@91:

; 12302: }

  00100	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00105	48 8b c6	 mov	 rax, rsi
  00108	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0010d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00111	5f		 pop	 rdi
  00112	c3		 ret	 0
PyUnicode_Split ENDP
_TEXT	ENDS
PUBLIC	??_C@_09DBJIONJK@?$HMOn?3split?$AA@		; `string'
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_split DD imagerel unicode_split
	DD	imagerel unicode_split+166
	DD	imagerel $unwind$unicode_split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_split DD 040c01H
	DD	0a340cH
	DD	07008720cH
xdata	ENDS
;	COMDAT ??_C@_09DBJIONJK@?$HMOn?3split?$AA@
CONST	SEGMENT
??_C@_09DBJIONJK@?$HMOn?3split?$AA@ DB '|On:split', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_split
_TEXT	SEGMENT
substring$ = 48
self$ = 80
args$ = 88
kwds$ = 96
maxcount$ = 104
unicode_split PROC					; COMDAT

; 12315: {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00007	57		 push	 rdi
  00008	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000c	48 8b d9	 mov	 rbx, rcx

; 12316:     static char *kwlist[] = {"sep", "maxsplit", 0};
; 12317:     PyObject *substring = Py_None;
; 12318:     Py_ssize_t maxcount = -1;
; 12319: 
; 12320:     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|On:split",
; 12321:                                      kwlist, &substring, &maxcount))

  0000f	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00013	49 8b c0	 mov	 rax, r8
  00016	49 89 4b e0	 mov	 QWORD PTR [r11-32], rcx
  0001a	49 8d 4b e8	 lea	 rcx, QWORD PTR [r11-24]
  0001e	4c 8b d2	 mov	 r10, rdx
  00021	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  00025	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  0002c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??unicode_split@@9@9
  00033	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09DBJIONJK@?$HMOn?3split?$AA@
  0003a	49 8b ca	 mov	 rcx, r10
  0003d	48 8b d0	 mov	 rdx, rax
  00040	49 89 7b e8	 mov	 QWORD PTR [r11-24], rdi
  00044	49 c7 43 20 ff
	ff ff ff	 mov	 QWORD PTR [r11+32], -1
  0004c	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00051	85 c0		 test	 eax, eax
  00053	75 0d		 jne	 SHORT $LN5@unicode_sp

; 12322:         return NULL;

  00055	33 c0		 xor	 eax, eax

; 12330: }

  00057	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0005c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00060	5f		 pop	 rdi
  00061	c3		 ret	 0
$LN5@unicode_sp:

; 12323: 
; 12324:     if (substring == Py_None)

  00062	48 8b 54 24 30	 mov	 rdx, QWORD PTR substring$[rsp]

; 12325:         return split(self, NULL, maxcount);

  00067	4c 8b 44 24 68	 mov	 r8, QWORD PTR maxcount$[rsp]
  0006c	48 8b cb	 mov	 rcx, rbx
  0006f	48 3b d7	 cmp	 rdx, rdi
  00072	75 12		 jne	 SHORT $LN4@unicode_sp
  00074	33 d2		 xor	 edx, edx
$LN8@unicode_sp:
  00076	e8 00 00 00 00	 call	 split

; 12330: }

  0007b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00080	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00084	5f		 pop	 rdi
  00085	c3		 ret	 0
$LN4@unicode_sp:

; 12326:     else if (PyUnicode_Check(substring))

  00086	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0008a	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H

; 12327:         return split(self, substring, maxcount);

  00094	75 e0		 jne	 SHORT $LN8@unicode_sp

; 12328:     else
; 12329:         return PyUnicode_Split(self, substring, maxcount);

  00096	e8 00 00 00 00	 call	 PyUnicode_Split

; 12330: }

  0009b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000a0	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000a4	5f		 pop	 rdi
  000a5	c3		 ret	 0
unicode_split ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_Partition
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_Partition DD imagerel $LN44
	DD	imagerel $LN44+574
	DD	imagerel $unwind$PyUnicode_Partition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Partition DD 0d8d01H
	DD	06f48dH
	DD	0ee484H
	DD	0dc47fH
	DD	0c547aH
	DD	0d006620aH
	DD	060037004H
	DD	03002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_Partition
_TEXT	SEGMENT
str_in$ = 96
sep_in$ = 104
PyUnicode_Partition PROC				; COMDAT

; 12334: {

$LN44:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	41 55		 push	 r13
  00006	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 12335:     PyObject* str_obj;
; 12336:     PyObject* sep_obj;
; 12337:     PyObject* out;
; 12338:     int kind1, kind2, kind;
; 12339:     void *buf1 = NULL, *buf2 = NULL;

  0000a	45 33 ed	 xor	 r13d, r13d
  0000d	48 8b da	 mov	 rbx, rdx
  00010	41 8b f5	 mov	 esi, r13d

; 12340:     Py_ssize_t len1, len2;
; 12341: 
; 12342:     str_obj = PyUnicode_FromObject(str_in);

  00013	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00018	48 8b f8	 mov	 rdi, rax

; 12343:     if (!str_obj)

  0001b	48 85 c0	 test	 rax, rax

; 12344:         return NULL;

  0001e	74 46		 je	 SHORT $LN42@PyUnicode_@92

; 12345:     sep_obj = PyUnicode_FromObject(sep_in);

  00020	48 8b cb	 mov	 rcx, rbx
  00023	e8 00 00 00 00	 call	 PyUnicode_FromObject
  00028	48 8b d8	 mov	 rbx, rax

; 12346:     if (!sep_obj) {

  0002b	48 85 c0	 test	 rax, rax

; 12347:         Py_DECREF(str_obj);
; 12348:         return NULL;

  0002e	74 2e		 je	 SHORT $LN43@PyUnicode_@92

; 12349:     }
; 12350:     if (PyUnicode_READY(sep_obj) == -1 || PyUnicode_READY(str_obj) == -1) {

  00030	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  00034	75 0d		 jne	 SHORT $LN35@PyUnicode_@92
  00036	48 8b c8	 mov	 rcx, rax
  00039	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0003e	83 f8 ff	 cmp	 eax, -1
  00041	74 13		 je	 SHORT $LN17@PyUnicode_@92
$LN35@PyUnicode_@92:
  00043	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  00047	75 29		 jne	 SHORT $LN36@PyUnicode_@92
  00049	48 8b cf	 mov	 rcx, rdi
  0004c	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00051	83 f8 ff	 cmp	 eax, -1
  00054	75 1c		 jne	 SHORT $LN36@PyUnicode_@92
$LN17@PyUnicode_@92:

; 12351:         Py_DECREF(sep_obj);

  00056	48 8b cb	 mov	 rcx, rbx
  00059	e8 00 00 00 00	 call	 _Py_DecRef
$LN43@PyUnicode_@92:

; 12352:         Py_DECREF(str_obj);

  0005e	48 8b cf	 mov	 rcx, rdi
  00061	e8 00 00 00 00	 call	 _Py_DecRef
$LN42@PyUnicode_@92:

; 12353:         return NULL;

  00066	33 c0		 xor	 eax, eax

; 12406: }

  00068	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006c	41 5d		 pop	 r13
  0006e	5f		 pop	 rdi
  0006f	5e		 pop	 rsi
  00070	5b		 pop	 rbx
  00071	c3		 ret	 0
$LN36@PyUnicode_@92:

; 12354:     }
; 12355: 
; 12356:     kind1 = PyUnicode_KIND(str_obj);

  00072	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00075	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  0007a	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  0007f	4c 89 74 24 70	 mov	 QWORD PTR [rsp+112], r14

; 12357:     kind2 = PyUnicode_KIND(sep_obj);

  00084	44 8b 73 70	 mov	 r14d, DWORD PTR [rbx+112]
  00088	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  0008d	41 c1 ee 02	 shr	 r14d, 2
  00091	44 8b f8	 mov	 r15d, eax
  00094	41 c1 ef 02	 shr	 r15d, 2
  00098	41 83 e6 07	 and	 r14d, 7
  0009c	41 83 e7 07	 and	 r15d, 7

; 12358:     kind = Py_MAX(kind1, kind2);

  000a0	45 8b e6	 mov	 r12d, r14d
  000a3	45 3b fe	 cmp	 r15d, r14d
  000a6	45 0f 4f e7	 cmovg	 r12d, r15d

; 12359:     buf1 = PyUnicode_DATA(str_obj);

  000aa	a8 20		 test	 al, 32			; 00000020H
  000ac	74 16		 je	 SHORT $LN29@PyUnicode_@92
  000ae	a8 40		 test	 al, 64			; 00000040H
  000b0	74 09		 je	 SHORT $LN27@PyUnicode_@92
  000b2	48 8d af 80 00
	00 00		 lea	 rbp, QWORD PTR [rdi+128]
  000b9	eb 10		 jmp	 SHORT $LN30@PyUnicode_@92
$LN27@PyUnicode_@92:
  000bb	48 8d af a0 00
	00 00		 lea	 rbp, QWORD PTR [rdi+160]
  000c2	eb 07		 jmp	 SHORT $LN30@PyUnicode_@92
$LN29@PyUnicode_@92:
  000c4	48 8b af a0 00
	00 00		 mov	 rbp, QWORD PTR [rdi+160]
$LN30@PyUnicode_@92:

; 12360:     if (kind1 != kind)

  000cb	45 3b fc	 cmp	 r15d, r12d
  000ce	74 0e		 je	 SHORT $LN16@PyUnicode_@92

; 12361:         buf1 = _PyUnicode_AsKind(str_obj, kind);

  000d0	41 8b d4	 mov	 edx, r12d
  000d3	48 8b cf	 mov	 rcx, rdi
  000d6	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  000db	48 8b e8	 mov	 rbp, rax
$LN16@PyUnicode_@92:

; 12362:     if (!buf1)

  000de	48 85 ed	 test	 rbp, rbp
  000e1	0f 84 03 01 00
	00		 je	 $onError$140643

; 12363:         goto onError;
; 12364:     buf2 = PyUnicode_DATA(sep_obj);

  000e7	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  000ea	a8 20		 test	 al, 32			; 00000020H
  000ec	74 16		 je	 SHORT $LN33@PyUnicode_@92
  000ee	a8 40		 test	 al, 64			; 00000040H
  000f0	74 09		 je	 SHORT $LN31@PyUnicode_@92
  000f2	48 8d b3 80 00
	00 00		 lea	 rsi, QWORD PTR [rbx+128]
  000f9	eb 10		 jmp	 SHORT $LN34@PyUnicode_@92
$LN31@PyUnicode_@92:
  000fb	48 8d b3 a0 00
	00 00		 lea	 rsi, QWORD PTR [rbx+160]
  00102	eb 07		 jmp	 SHORT $LN34@PyUnicode_@92
$LN33@PyUnicode_@92:
  00104	48 8b b3 a0 00
	00 00		 mov	 rsi, QWORD PTR [rbx+160]
$LN34@PyUnicode_@92:

; 12365:     if (kind2 != kind)

  0010b	45 3b f4	 cmp	 r14d, r12d
  0010e	74 0e		 je	 SHORT $LN14@PyUnicode_@92

; 12366:         buf2 = _PyUnicode_AsKind(sep_obj, kind);

  00110	41 8b d4	 mov	 edx, r12d
  00113	48 8b cb	 mov	 rcx, rbx
  00116	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  0011b	48 8b f0	 mov	 rsi, rax
$LN14@PyUnicode_@92:

; 12367:     if (!buf2)

  0011e	48 85 f6	 test	 rsi, rsi
  00121	0f 84 c3 00 00
	00		 je	 $onError$140643

; 12368:         goto onError;
; 12369:     len1 = PyUnicode_GET_LENGTH(str_obj);
; 12370:     len2 = PyUnicode_GET_LENGTH(sep_obj);
; 12371: 
; 12372:     switch (PyUnicode_KIND(str_obj)) {

  00127	8b 4f 70	 mov	 ecx, DWORD PTR [rdi+112]
  0012a	4c 8b 47 60	 mov	 r8, QWORD PTR [rdi+96]
  0012e	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  00132	8b c1		 mov	 eax, ecx
  00134	c1 e8 02	 shr	 eax, 2
  00137	83 e0 07	 and	 eax, 7
  0013a	ff c8		 dec	 eax
  0013c	74 3d		 je	 SHORT $LN10@PyUnicode_@92
  0013e	ff c8		 dec	 eax
  00140	74 1f		 je	 SHORT $LN7@PyUnicode_@92
  00142	83 f8 02	 cmp	 eax, 2
  00145	75 74		 jne	 SHORT $LN8@PyUnicode_@92

; 12382:     case PyUnicode_4BYTE_KIND:
; 12383:         out = ucs4lib_partition(str_obj, buf1, len1, sep_obj, buf2, len2);

  00147	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0014c	4c 8b cb	 mov	 r9, rbx
  0014f	48 8b cf	 mov	 rcx, rdi
  00152	48 8b d5	 mov	 rdx, rbp
  00155	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0015a	e8 00 00 00 00	 call	 ucs4lib_partition

; 12384:         break;

  0015f	eb 57		 jmp	 SHORT $LN41@PyUnicode_@92
$LN7@PyUnicode_@92:

; 12378:         break;
; 12379:     case PyUnicode_2BYTE_KIND:
; 12380:         out = ucs2lib_partition(str_obj, buf1, len1, sep_obj, buf2, len2);

  00161	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00166	4c 8b cb	 mov	 r9, rbx
  00169	48 8b cf	 mov	 rcx, rdi
  0016c	48 8b d5	 mov	 rdx, rbp
  0016f	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00174	e8 00 00 00 00	 call	 ucs2lib_partition

; 12381:         break;

  00179	eb 3d		 jmp	 SHORT $LN41@PyUnicode_@92
$LN10@PyUnicode_@92:

; 12373:     case PyUnicode_1BYTE_KIND:
; 12374:         if (PyUnicode_IS_ASCII(str_obj) && PyUnicode_IS_ASCII(sep_obj))

  0017b	f6 c1 40	 test	 cl, 64			; 00000040H
  0017e	74 20		 je	 SHORT $LN9@PyUnicode_@92
  00180	f6 43 70 40	 test	 BYTE PTR [rbx+112], 64	; 00000040H
  00184	74 1a		 je	 SHORT $LN9@PyUnicode_@92

; 12375:             out = asciilib_partition(str_obj, buf1, len1, sep_obj, buf2, len2);

  00186	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0018b	4c 8b cb	 mov	 r9, rbx
  0018e	48 8b cf	 mov	 rcx, rdi
  00191	48 8b d5	 mov	 rdx, rbp
  00194	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00199	e8 00 00 00 00	 call	 asciilib_partition

; 12376:         else

  0019e	eb 18		 jmp	 SHORT $LN41@PyUnicode_@92
$LN9@PyUnicode_@92:

; 12377:             out = ucs1lib_partition(str_obj, buf1, len1, sep_obj, buf2, len2);

  001a0	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  001a5	4c 8b cb	 mov	 r9, rbx
  001a8	48 8b cf	 mov	 rcx, rdi
  001ab	48 8b d5	 mov	 rdx, rbp
  001ae	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  001b3	e8 00 00 00 00	 call	 ucs1lib_partition
$LN41@PyUnicode_@92:
  001b8	4c 8b e8	 mov	 r13, rax
$LN8@PyUnicode_@92:

; 12385:     default:
; 12386:         assert(0);
; 12387:         out = 0;
; 12388:     }
; 12389: 
; 12390:     Py_DECREF(sep_obj);

  001bb	48 8b cb	 mov	 rcx, rbx
  001be	e8 00 00 00 00	 call	 _Py_DecRef

; 12391:     Py_DECREF(str_obj);

  001c3	48 8b cf	 mov	 rcx, rdi
  001c6	e8 00 00 00 00	 call	 _Py_DecRef

; 12392:     if (kind1 != kind)

  001cb	45 3b fc	 cmp	 r15d, r12d
  001ce	74 08		 je	 SHORT $LN4@PyUnicode_@92

; 12393:         PyMem_Free(buf1);

  001d0	48 8b cd	 mov	 rcx, rbp
  001d3	e8 00 00 00 00	 call	 PyMem_Free
$LN4@PyUnicode_@92:

; 12394:     if (kind2 != kind)

  001d8	45 3b f4	 cmp	 r14d, r12d
  001db	74 08		 je	 SHORT $LN3@PyUnicode_@92

; 12395:         PyMem_Free(buf2);

  001dd	48 8b ce	 mov	 rcx, rsi
  001e0	e8 00 00 00 00	 call	 PyMem_Free
$LN3@PyUnicode_@92:

; 12396: 
; 12397:     return out;

  001e5	49 8b c5	 mov	 rax, r13
  001e8	eb 36		 jmp	 SHORT $LN40@PyUnicode_@92
$onError$140643:

; 12398:   onError:
; 12399:     Py_DECREF(sep_obj);

  001ea	48 8b cb	 mov	 rcx, rbx
  001ed	e8 00 00 00 00	 call	 _Py_DecRef

; 12400:     Py_DECREF(str_obj);

  001f2	48 8b cf	 mov	 rcx, rdi
  001f5	e8 00 00 00 00	 call	 _Py_DecRef

; 12401:     if (kind1 != kind && buf1)

  001fa	45 3b fc	 cmp	 r15d, r12d
  001fd	74 0d		 je	 SHORT $LN2@PyUnicode_@92
  001ff	48 85 ed	 test	 rbp, rbp
  00202	74 08		 je	 SHORT $LN2@PyUnicode_@92

; 12402:         PyMem_Free(buf1);

  00204	48 8b cd	 mov	 rcx, rbp
  00207	e8 00 00 00 00	 call	 PyMem_Free
$LN2@PyUnicode_@92:

; 12403:     if (kind2 != kind && buf2)

  0020c	45 3b f4	 cmp	 r14d, r12d
  0020f	74 0d		 je	 SHORT $LN1@PyUnicode_@92
  00211	48 85 f6	 test	 rsi, rsi
  00214	74 08		 je	 SHORT $LN1@PyUnicode_@92

; 12404:         PyMem_Free(buf2);

  00216	48 8b ce	 mov	 rcx, rsi
  00219	e8 00 00 00 00	 call	 PyMem_Free
$LN1@PyUnicode_@92:

; 12405:     return NULL;

  0021e	33 c0		 xor	 eax, eax
$LN40@PyUnicode_@92:
  00220	4c 8b 74 24 70	 mov	 r14, QWORD PTR [rsp+112]
  00225	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  0022a	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  0022f	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]

; 12406: }

  00234	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00238	41 5d		 pop	 r13
  0023a	5f		 pop	 rdi
  0023b	5e		 pop	 rsi
  0023c	5b		 pop	 rbx
  0023d	c3		 ret	 0
PyUnicode_Partition ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_RPartition
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_RPartition DD imagerel $LN34
	DD	imagerel $LN34+533
	DD	imagerel $unwind$PyUnicode_RPartition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_RPartition DD 0c5e01H
	DD	0ff45eH
	DD	0dc459H
	DD	0c6454H
	DD	0e008520cH
	DD	07004d006H
	DD	030025003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_RPartition
_TEXT	SEGMENT
str_in$ = 96
sep_in$ = 104
kind1$1$ = 112
PyUnicode_RPartition PROC				; COMDAT

; 12411: {

$LN34:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	41 55		 push	 r13
  00006	41 56		 push	 r14
  00008	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 12412:     PyObject* str_obj;
; 12413:     PyObject* sep_obj;
; 12414:     PyObject* out;
; 12415:     int kind1, kind2, kind;
; 12416:     void *buf1 = NULL, *buf2 = NULL;

  0000c	45 33 f6	 xor	 r14d, r14d
  0000f	48 8b da	 mov	 rbx, rdx
  00012	4c 8b e9	 mov	 r13, rcx
  00015	41 8b fe	 mov	 edi, r14d

; 12417:     Py_ssize_t len1, len2;
; 12418: 
; 12419:     str_obj = PyUnicode_FromObject(str_in);

  00018	e8 00 00 00 00	 call	 PyUnicode_FromObject
  0001d	48 8b e8	 mov	 rbp, rax

; 12420:     if (!str_obj)

  00020	48 85 c0	 test	 rax, rax

; 12421:         return NULL;

  00023	74 18		 je	 SHORT $LN33@PyUnicode_@93

; 12422:     sep_obj = PyUnicode_FromObject(sep_in);

  00025	48 8b cb	 mov	 rcx, rbx
  00028	e8 00 00 00 00	 call	 PyUnicode_FromObject
  0002d	48 8b d8	 mov	 rbx, rax

; 12423:     if (!sep_obj) {

  00030	48 85 c0	 test	 rax, rax
  00033	75 16		 jne	 SHORT $LN17@PyUnicode_@93

; 12424:         Py_DECREF(str_obj);

  00035	48 8b cd	 mov	 rcx, rbp
  00038	e8 00 00 00 00	 call	 _Py_DecRef
$LN33@PyUnicode_@93:

; 12425:         return NULL;

  0003d	33 c0		 xor	 eax, eax

; 12478: }

  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	41 5e		 pop	 r14
  00045	41 5d		 pop	 r13
  00047	5f		 pop	 rdi
  00048	5d		 pop	 rbp
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
$LN17@PyUnicode_@93:

; 12426:     }
; 12427: 
; 12428:     kind1 = PyUnicode_KIND(str_in);

  0004b	41 8b 45 70	 mov	 eax, DWORD PTR [r13+112]
  0004f	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00054	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  00059	4c 89 7c 24 78	 mov	 QWORD PTR [rsp+120], r15

; 12429:     kind2 = PyUnicode_KIND(sep_obj);

  0005e	44 8b 7b 70	 mov	 r15d, DWORD PTR [rbx+112]
  00062	8b c8		 mov	 ecx, eax
  00064	c1 e9 02	 shr	 ecx, 2
  00067	41 c1 ef 02	 shr	 r15d, 2
  0006b	83 e1 07	 and	 ecx, 7
  0006e	41 83 e7 07	 and	 r15d, 7

; 12430:     kind = Py_MAX(kind1, kind2);

  00072	41 3b cf	 cmp	 ecx, r15d
  00075	45 8b e7	 mov	 r12d, r15d
  00078	89 4c 24 70	 mov	 DWORD PTR kind1$1$[rsp], ecx
  0007c	44 0f 4f e1	 cmovg	 r12d, ecx

; 12431:     buf1 = PyUnicode_DATA(str_in);

  00080	a8 20		 test	 al, 32			; 00000020H
  00082	74 16		 je	 SHORT $LN23@PyUnicode_@93
  00084	a8 40		 test	 al, 64			; 00000040H
  00086	74 09		 je	 SHORT $LN21@PyUnicode_@93
  00088	49 8d b5 80 00
	00 00		 lea	 rsi, QWORD PTR [r13+128]
  0008f	eb 10		 jmp	 SHORT $LN24@PyUnicode_@93
$LN21@PyUnicode_@93:
  00091	49 8d b5 a0 00
	00 00		 lea	 rsi, QWORD PTR [r13+160]
  00098	eb 07		 jmp	 SHORT $LN24@PyUnicode_@93
$LN23@PyUnicode_@93:
  0009a	49 8b b5 a0 00
	00 00		 mov	 rsi, QWORD PTR [r13+160]
$LN24@PyUnicode_@93:

; 12432:     if (kind1 != kind)

  000a1	41 3b cc	 cmp	 ecx, r12d
  000a4	74 0e		 je	 SHORT $LN16@PyUnicode_@93

; 12433:         buf1 = _PyUnicode_AsKind(str_in, kind);

  000a6	41 8b d4	 mov	 edx, r12d
  000a9	49 8b cd	 mov	 rcx, r13
  000ac	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  000b1	48 8b f0	 mov	 rsi, rax
$LN16@PyUnicode_@93:

; 12434:     if (!buf1)

  000b4	48 85 f6	 test	 rsi, rsi
  000b7	0f 84 05 01 00
	00		 je	 $onError$140733

; 12435:         goto onError;
; 12436:     buf2 = PyUnicode_DATA(sep_obj);

  000bd	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  000c0	a8 20		 test	 al, 32			; 00000020H
  000c2	74 16		 je	 SHORT $LN27@PyUnicode_@93
  000c4	a8 40		 test	 al, 64			; 00000040H
  000c6	74 09		 je	 SHORT $LN25@PyUnicode_@93
  000c8	48 8d bb 80 00
	00 00		 lea	 rdi, QWORD PTR [rbx+128]
  000cf	eb 10		 jmp	 SHORT $LN28@PyUnicode_@93
$LN25@PyUnicode_@93:
  000d1	48 8d bb a0 00
	00 00		 lea	 rdi, QWORD PTR [rbx+160]
  000d8	eb 07		 jmp	 SHORT $LN28@PyUnicode_@93
$LN27@PyUnicode_@93:
  000da	48 8b bb a0 00
	00 00		 mov	 rdi, QWORD PTR [rbx+160]
$LN28@PyUnicode_@93:

; 12437:     if (kind2 != kind)

  000e1	45 3b fc	 cmp	 r15d, r12d
  000e4	74 0e		 je	 SHORT $LN14@PyUnicode_@93

; 12438:         buf2 = _PyUnicode_AsKind(sep_obj, kind);

  000e6	41 8b d4	 mov	 edx, r12d
  000e9	48 8b cb	 mov	 rcx, rbx
  000ec	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  000f1	48 8b f8	 mov	 rdi, rax
$LN14@PyUnicode_@93:

; 12439:     if (!buf2)

  000f4	48 85 ff	 test	 rdi, rdi
  000f7	0f 84 c5 00 00
	00		 je	 $onError$140733

; 12440:         goto onError;
; 12441:     len1 = PyUnicode_GET_LENGTH(str_obj);
; 12442:     len2 = PyUnicode_GET_LENGTH(sep_obj);
; 12443: 
; 12444:     switch (PyUnicode_KIND(str_in)) {

  000fd	41 8b 4d 70	 mov	 ecx, DWORD PTR [r13+112]
  00101	4c 8b 45 60	 mov	 r8, QWORD PTR [rbp+96]
  00105	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  00109	c1 e9 02	 shr	 ecx, 2
  0010c	83 e1 07	 and	 ecx, 7
  0010f	ff c9		 dec	 ecx
  00111	74 3d		 je	 SHORT $LN10@PyUnicode_@93
  00113	ff c9		 dec	 ecx
  00115	74 1f		 je	 SHORT $LN7@PyUnicode_@93
  00117	83 f9 02	 cmp	 ecx, 2
  0011a	75 75		 jne	 SHORT $LN8@PyUnicode_@93

; 12454:     case PyUnicode_4BYTE_KIND:
; 12455:         out = ucs4lib_rpartition(str_obj, buf1, len1, sep_obj, buf2, len2);

  0011c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00121	4c 8b cb	 mov	 r9, rbx
  00124	48 8b d6	 mov	 rdx, rsi
  00127	48 8b cd	 mov	 rcx, rbp
  0012a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0012f	e8 00 00 00 00	 call	 ucs4lib_rpartition

; 12456:         break;

  00134	eb 58		 jmp	 SHORT $LN32@PyUnicode_@93
$LN7@PyUnicode_@93:

; 12450:         break;
; 12451:     case PyUnicode_2BYTE_KIND:
; 12452:         out = ucs2lib_rpartition(str_obj, buf1, len1, sep_obj, buf2, len2);

  00136	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0013b	4c 8b cb	 mov	 r9, rbx
  0013e	48 8b d6	 mov	 rdx, rsi
  00141	48 8b cd	 mov	 rcx, rbp
  00144	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00149	e8 00 00 00 00	 call	 ucs2lib_rpartition

; 12453:         break;

  0014e	eb 3e		 jmp	 SHORT $LN32@PyUnicode_@93
$LN10@PyUnicode_@93:

; 12445:     case PyUnicode_1BYTE_KIND:
; 12446:         if (PyUnicode_IS_ASCII(str_obj) && PyUnicode_IS_ASCII(sep_obj))

  00150	f6 45 70 40	 test	 BYTE PTR [rbp+112], 64	; 00000040H
  00154	74 20		 je	 SHORT $LN9@PyUnicode_@93
  00156	f6 43 70 40	 test	 BYTE PTR [rbx+112], 64	; 00000040H
  0015a	74 1a		 je	 SHORT $LN9@PyUnicode_@93

; 12447:             out = asciilib_rpartition(str_obj, buf1, len1, sep_obj, buf2, len2);

  0015c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00161	4c 8b cb	 mov	 r9, rbx
  00164	48 8b d6	 mov	 rdx, rsi
  00167	48 8b cd	 mov	 rcx, rbp
  0016a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0016f	e8 00 00 00 00	 call	 asciilib_rpartition

; 12448:         else

  00174	eb 18		 jmp	 SHORT $LN32@PyUnicode_@93
$LN9@PyUnicode_@93:

; 12449:             out = ucs1lib_rpartition(str_obj, buf1, len1, sep_obj, buf2, len2);

  00176	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0017b	4c 8b cb	 mov	 r9, rbx
  0017e	48 8b d6	 mov	 rdx, rsi
  00181	48 8b cd	 mov	 rcx, rbp
  00184	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00189	e8 00 00 00 00	 call	 ucs1lib_rpartition
$LN32@PyUnicode_@93:
  0018e	4c 8b f0	 mov	 r14, rax
$LN8@PyUnicode_@93:

; 12457:     default:
; 12458:         assert(0);
; 12459:         out = 0;
; 12460:     }
; 12461: 
; 12462:     Py_DECREF(sep_obj);

  00191	48 8b cb	 mov	 rcx, rbx
  00194	e8 00 00 00 00	 call	 _Py_DecRef

; 12463:     Py_DECREF(str_obj);

  00199	48 8b cd	 mov	 rcx, rbp
  0019c	e8 00 00 00 00	 call	 _Py_DecRef

; 12464:     if (kind1 != kind)

  001a1	44 39 64 24 70	 cmp	 DWORD PTR kind1$1$[rsp], r12d
  001a6	74 08		 je	 SHORT $LN4@PyUnicode_@93

; 12465:         PyMem_Free(buf1);

  001a8	48 8b ce	 mov	 rcx, rsi
  001ab	e8 00 00 00 00	 call	 PyMem_Free
$LN4@PyUnicode_@93:

; 12466:     if (kind2 != kind)

  001b0	45 3b fc	 cmp	 r15d, r12d
  001b3	74 08		 je	 SHORT $LN3@PyUnicode_@93

; 12467:         PyMem_Free(buf2);

  001b5	48 8b cf	 mov	 rcx, rdi
  001b8	e8 00 00 00 00	 call	 PyMem_Free
$LN3@PyUnicode_@93:

; 12468: 
; 12469:     return out;

  001bd	49 8b c6	 mov	 rax, r14
  001c0	eb 38		 jmp	 SHORT $LN31@PyUnicode_@93
$onError$140733:

; 12470:   onError:
; 12471:     Py_DECREF(sep_obj);

  001c2	48 8b cb	 mov	 rcx, rbx
  001c5	e8 00 00 00 00	 call	 _Py_DecRef

; 12472:     Py_DECREF(str_obj);

  001ca	48 8b cd	 mov	 rcx, rbp
  001cd	e8 00 00 00 00	 call	 _Py_DecRef

; 12473:     if (kind1 != kind && buf1)

  001d2	44 39 64 24 70	 cmp	 DWORD PTR kind1$1$[rsp], r12d
  001d7	74 0d		 je	 SHORT $LN2@PyUnicode_@93
  001d9	48 85 f6	 test	 rsi, rsi
  001dc	74 08		 je	 SHORT $LN2@PyUnicode_@93

; 12474:         PyMem_Free(buf1);

  001de	48 8b ce	 mov	 rcx, rsi
  001e1	e8 00 00 00 00	 call	 PyMem_Free
$LN2@PyUnicode_@93:

; 12475:     if (kind2 != kind && buf2)

  001e6	45 3b fc	 cmp	 r15d, r12d
  001e9	74 0d		 je	 SHORT $LN1@PyUnicode_@93
  001eb	48 85 ff	 test	 rdi, rdi
  001ee	74 08		 je	 SHORT $LN1@PyUnicode_@93

; 12476:         PyMem_Free(buf2);

  001f0	48 8b cf	 mov	 rcx, rdi
  001f3	e8 00 00 00 00	 call	 PyMem_Free
$LN1@PyUnicode_@93:

; 12477:     return NULL;

  001f8	33 c0		 xor	 eax, eax
$LN31@PyUnicode_@93:
  001fa	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  001ff	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00204	4c 8b 7c 24 78	 mov	 r15, QWORD PTR [rsp+120]

; 12478: }

  00209	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0020d	41 5e		 pop	 r14
  0020f	41 5d		 pop	 r13
  00211	5f		 pop	 rdi
  00212	5d		 pop	 rbp
  00213	5b		 pop	 rbx
  00214	c3		 ret	 0
PyUnicode_RPartition ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT unicode_partition
_TEXT	SEGMENT
self$ = 8
separator$ = 16
unicode_partition PROC					; COMDAT

; 12490:     return PyUnicode_Partition(self, separator);
; 12491: }

  00000	e9 00 00 00 00	 jmp	 PyUnicode_Partition
unicode_partition ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT unicode_rpartition
_TEXT	SEGMENT
self$ = 8
separator$ = 16
unicode_rpartition PROC					; COMDAT

; 12503:     return PyUnicode_RPartition(self, separator);
; 12504: }

  00000	e9 00 00 00 00	 jmp	 PyUnicode_RPartition
unicode_rpartition ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_RSplit
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyUnicode_RSplit DD imagerel $LN22
	DD	imagerel $LN22+275
	DD	imagerel $unwind$PyUnicode_RSplit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_RSplit DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT PyUnicode_RSplit
_TEXT	SEGMENT
s$ = 64
sep$ = 72
maxsplit$ = 80
PyUnicode_RSplit PROC					; COMDAT

; 12508: {

$LN22:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	49 8b f0	 mov	 rsi, r8
  00012	48 8b da	 mov	 rbx, rdx

; 12509:     PyObject *result;
; 12510: 
; 12511:     s = PyUnicode_FromObject(s);

  00015	e8 00 00 00 00	 call	 PyUnicode_FromObject
  0001a	48 8b f8	 mov	 rdi, rax

; 12512:     if (s == NULL)

  0001d	48 85 c0	 test	 rax, rax

; 12513:         return NULL;

  00020	74 1d		 je	 SHORT $LN21@PyUnicode_@94

; 12514:     if (sep != NULL) {

  00022	48 85 db	 test	 rbx, rbx
  00025	74 2a		 je	 SHORT $LN5@PyUnicode_@94

; 12515:         sep = PyUnicode_FromObject(sep);

  00027	48 8b cb	 mov	 rcx, rbx
  0002a	e8 00 00 00 00	 call	 PyUnicode_FromObject
  0002f	48 8b d8	 mov	 rbx, rax

; 12516:         if (sep == NULL) {

  00032	48 85 c0	 test	 rax, rax
  00035	75 1a		 jne	 SHORT $LN5@PyUnicode_@94

; 12517:             Py_DECREF(s);

  00037	48 8b cf	 mov	 rcx, rdi
  0003a	e8 00 00 00 00	 call	 _Py_DecRef
$LN21@PyUnicode_@94:

; 12518:             return NULL;

  0003f	33 c0		 xor	 eax, eax

; 12527: }

  00041	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00046	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0004b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
$LN5@PyUnicode_@94:

; 12519:         }
; 12520:     }
; 12521: 
; 12522:     result = rsplit(s, sep, maxsplit);

  00051	4c 8b c6	 mov	 r8, rsi
  00054	48 8b d3	 mov	 rdx, rbx
  00057	48 8b cf	 mov	 rcx, rdi
  0005a	e8 00 00 00 00	 call	 rsplit

; 12523: 
; 12524:     Py_DECREF(s);

  0005f	48 8b cf	 mov	 rcx, rdi
  00062	48 8b f0	 mov	 rsi, rax
  00065	e8 00 00 00 00	 call	 _Py_DecRef

; 12525:     Py_XDECREF(sep);

  0006a	48 85 db	 test	 rbx, rbx
  0006d	0f 84 8d 00 00
	00		 je	 $LN3@PyUnicode_@94
  00073	e8 00 00 00 00	 call	 _Py_PXCTX
  00078	85 c0		 test	 eax, eax
  0007a	0f 85 80 00 00
	00		 jne	 $LN3@PyUnicode_@94
  00080	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00084	f6 c1 20	 test	 cl, 32			; 00000020H
  00087	75 6f		 jne	 SHORT $LN14@PyUnicode_@94
  00089	84 c9		 test	 cl, cl
  0008b	78 6b		 js	 SHORT $LN14@PyUnicode_@94
  0008d	f6 c1 02	 test	 cl, 2
  00090	75 6e		 jne	 SHORT $LN3@PyUnicode_@94
  00092	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00096	75 68		 jne	 SHORT $LN3@PyUnicode_@94
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000a6	4c 8b cb	 mov	 r9, rbx
  000a9	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000af	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000b7	e8 00 00 00 00	 call	 _PyParallel_Guard
  000bc	48 8b cb	 mov	 rcx, rbx
  000bf	85 c0		 test	 eax, eax
  000c1	74 18		 je	 SHORT $LN19@PyUnicode_@94
  000c3	e8 00 00 00 00	 call	 _Px_Dealloc

; 12526:     return result;

  000c8	48 8b c6	 mov	 rax, rsi

; 12527: }

  000cb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d0	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000d5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0

; 12525:     Py_XDECREF(sep);

$LN19@PyUnicode_@94:
  000db	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000df	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 12526:     return result;

  000e5	48 8b c6	 mov	 rax, rsi

; 12527: }

  000e8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ed	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000f2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f6	5f		 pop	 rdi
  000f7	c3		 ret	 0

; 12525:     Py_XDECREF(sep);

$LN14@PyUnicode_@94:
  000f8	48 8b cb	 mov	 rcx, rbx
  000fb	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PyUnicode_@94:

; 12527: }

  00100	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00105	48 8b c6	 mov	 rax, rsi
  00108	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0010d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00111	5f		 pop	 rdi
  00112	c3		 ret	 0
PyUnicode_RSplit ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@PNGLJNMN@?$HMOn?3rsplit?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_rsplit DD imagerel unicode_rsplit
	DD	imagerel unicode_rsplit+166
	DD	imagerel $unwind$unicode_rsplit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_rsplit DD 040c01H
	DD	0a340cH
	DD	07008720cH
xdata	ENDS
;	COMDAT ??_C@_0L@PNGLJNMN@?$HMOn?3rsplit?$AA@
CONST	SEGMENT
??_C@_0L@PNGLJNMN@?$HMOn?3rsplit?$AA@ DB '|On:rsplit', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_rsplit
_TEXT	SEGMENT
substring$ = 48
self$ = 80
args$ = 88
kwds$ = 96
maxcount$ = 104
unicode_rsplit PROC					; COMDAT

; 12540: {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00007	57		 push	 rdi
  00008	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000c	48 8b d9	 mov	 rbx, rcx

; 12541:     static char *kwlist[] = {"sep", "maxsplit", 0};
; 12542:     PyObject *substring = Py_None;
; 12543:     Py_ssize_t maxcount = -1;
; 12544: 
; 12545:     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|On:rsplit",
; 12546:                                      kwlist, &substring, &maxcount))

  0000f	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00013	49 8b c0	 mov	 rax, r8
  00016	49 89 4b e0	 mov	 QWORD PTR [r11-32], rcx
  0001a	49 8d 4b e8	 lea	 rcx, QWORD PTR [r11-24]
  0001e	4c 8b d2	 mov	 r10, rdx
  00021	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  00025	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  0002c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??unicode_rsplit@@9@9
  00033	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@PNGLJNMN@?$HMOn?3rsplit?$AA@
  0003a	49 8b ca	 mov	 rcx, r10
  0003d	48 8b d0	 mov	 rdx, rax
  00040	49 89 7b e8	 mov	 QWORD PTR [r11-24], rdi
  00044	49 c7 43 20 ff
	ff ff ff	 mov	 QWORD PTR [r11+32], -1
  0004c	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00051	85 c0		 test	 eax, eax
  00053	75 0d		 jne	 SHORT $LN5@unicode_rs

; 12547:         return NULL;

  00055	33 c0		 xor	 eax, eax

; 12555: }

  00057	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0005c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00060	5f		 pop	 rdi
  00061	c3		 ret	 0
$LN5@unicode_rs:

; 12548: 
; 12549:     if (substring == Py_None)

  00062	48 8b 54 24 30	 mov	 rdx, QWORD PTR substring$[rsp]

; 12550:         return rsplit(self, NULL, maxcount);

  00067	4c 8b 44 24 68	 mov	 r8, QWORD PTR maxcount$[rsp]
  0006c	48 8b cb	 mov	 rcx, rbx
  0006f	48 3b d7	 cmp	 rdx, rdi
  00072	75 12		 jne	 SHORT $LN4@unicode_rs
  00074	33 d2		 xor	 edx, edx
$LN8@unicode_rs:
  00076	e8 00 00 00 00	 call	 rsplit

; 12555: }

  0007b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00080	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00084	5f		 pop	 rdi
  00085	c3		 ret	 0
$LN4@unicode_rs:

; 12551:     else if (PyUnicode_Check(substring))

  00086	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0008a	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H

; 12552:         return rsplit(self, substring, maxcount);

  00094	75 e0		 jne	 SHORT $LN8@unicode_rs

; 12553:     else
; 12554:         return PyUnicode_RSplit(self, substring, maxcount);

  00096	e8 00 00 00 00	 call	 PyUnicode_RSplit

; 12555: }

  0009b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000a0	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000a4	5f		 pop	 rdi
  000a5	c3		 ret	 0
unicode_rsplit ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@BPBIFPCC@?$HMi?3splitlines?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_splitlines DD imagerel unicode_splitlines
	DD	imagerel unicode_splitlines+88
	DD	imagerel $unwind$unicode_splitlines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_splitlines DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0O@BPBIFPCC@?$HMi?3splitlines?$AA@
CONST	SEGMENT
??_C@_0O@BPBIFPCC@?$HMi?3splitlines?$AA@ DB '|i:splitlines', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_splitlines
_TEXT	SEGMENT
self$ = 64
args$ = 72
kwds$ = 80
keepends$ = 88
unicode_splitlines PROC					; COMDAT

; 12566: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	49 8b c0	 mov	 rax, r8
  0000c	4c 8b d2	 mov	 r10, rdx

; 12567:     static char *kwlist[] = {"keepends", 0};
; 12568:     int keepends = 0;
; 12569: 
; 12570:     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|i:splitlines",
; 12571:                                      kwlist, &keepends))

  0000f	48 8d 4c 24 58	 lea	 rcx, QWORD PTR keepends$[rsp]
  00014	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??unicode_splitlines@@9@9
  0001b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BPBIFPCC@?$HMi?3splitlines?$AA@
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	48 8b d0	 mov	 rdx, rax
  0002a	49 8b ca	 mov	 rcx, r10
  0002d	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR keepends$[rsp], 0
  00035	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0003a	85 c0		 test	 eax, eax
  0003c	75 08		 jne	 SHORT $LN1@unicode_sp@2

; 12572:         return NULL;

  0003e	33 c0		 xor	 eax, eax

; 12575: }

  00040	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00044	5b		 pop	 rbx
  00045	c3		 ret	 0
$LN1@unicode_sp@2:

; 12573: 
; 12574:     return PyUnicode_Splitlines(self, keepends);

  00046	8b 54 24 58	 mov	 edx, DWORD PTR keepends$[rsp]
  0004a	48 8b cb	 mov	 rcx, rbx
  0004d	e8 00 00 00 00	 call	 PyUnicode_Splitlines

; 12575: }

  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	5b		 pop	 rbx
  00057	c3		 ret	 0
unicode_splitlines ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT unicode_str
_TEXT	SEGMENT
self$ = 8
unicode_str PROC					; COMDAT

; 12580:     return unicode_result_unchanged(self);
; 12581: }

  00000	e9 00 00 00 00	 jmp	 unicode_result_unchanged
unicode_str ENDP
_TEXT	ENDS
PUBLIC	??_C@_07CBMPGKCP@n?3zfill?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_zfill DD imagerel unicode_zfill
	DD	imagerel unicode_zfill+67
	DD	imagerel $unwind$unicode_zfill
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_zfill DD imagerel unicode_zfill+67
	DD	imagerel unicode_zfill+101
	DD	imagerel $chain$0$unicode_zfill
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$unicode_zfill DD imagerel unicode_zfill+101
	DD	imagerel unicode_zfill+152
	DD	imagerel $chain$3$unicode_zfill
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$unicode_zfill DD imagerel unicode_zfill+152
	DD	imagerel unicode_zfill+293
	DD	imagerel $chain$5$unicode_zfill
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$unicode_zfill DD imagerel unicode_zfill+293
	DD	imagerel unicode_zfill+316
	DD	imagerel $chain$7$unicode_zfill
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$unicode_zfill DD imagerel unicode_zfill+316
	DD	imagerel unicode_zfill+339
	DD	imagerel $chain$9$unicode_zfill
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$unicode_zfill DD 040021H
	DD	076400H
	DD	063400H
	DD	imagerel unicode_zfill
	DD	imagerel unicode_zfill+67
	DD	imagerel $unwind$unicode_zfill
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$unicode_zfill DD 040021H
	DD	076400H
	DD	063400H
	DD	imagerel unicode_zfill
	DD	imagerel unicode_zfill+67
	DD	imagerel $unwind$unicode_zfill
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$unicode_zfill DD 040021H
	DD	076400H
	DD	063400H
	DD	imagerel unicode_zfill
	DD	imagerel unicode_zfill+67
	DD	imagerel $unwind$unicode_zfill
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$unicode_zfill DD 040821H
	DD	076408H
	DD	063400H
	DD	imagerel unicode_zfill
	DD	imagerel unicode_zfill+67
	DD	imagerel $unwind$unicode_zfill
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_zfill DD 020521H
	DD	063405H
	DD	imagerel unicode_zfill
	DD	imagerel unicode_zfill+67
	DD	imagerel $unwind$unicode_zfill
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_zfill DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT ??_C@_07CBMPGKCP@n?3zfill?$AA@
CONST	SEGMENT
??_C@_07CBMPGKCP@n?3zfill?$AA@ DB 'n:zfill', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_zfill
_TEXT	SEGMENT
self$ = 48
args$ = 56
width$ = 64
unicode_zfill PROC					; COMDAT

; 12755: {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b f9	 mov	 rdi, rcx

; 12756:     Py_ssize_t fill;
; 12757:     PyObject *u;
; 12758:     Py_ssize_t width;
; 12759:     int kind;
; 12760:     void *data;
; 12761:     Py_UCS4 chr;
; 12762: 
; 12763:     if (!PyArg_ParseTuple(args, "n:zfill", &width))

  0000c	4c 8d 44 24 40	 lea	 r8, QWORD PTR width$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07CBMPGKCP@n?3zfill?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00020	85 c0		 test	 eax, eax
  00022	75 08		 jne	 SHORT $LN22@unicode_zf
$LN37@unicode_zf:

; 12764:         return NULL;

  00024	33 c0		 xor	 eax, eax

; 12791: }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5f		 pop	 rdi
  0002b	c3		 ret	 0
$LN22@unicode_zf:

; 12765: 
; 12766:     if (PyUnicode_READY(self) == -1)

  0002c	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  00030	75 0d		 jne	 SHORT $LN21@unicode_zf
  00032	48 8b cf	 mov	 rcx, rdi
  00035	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0003a	83 f8 ff	 cmp	 eax, -1

; 12767:         return NULL;

  0003d	74 e5		 je	 SHORT $LN37@unicode_zf
$LN21@unicode_zf:

; 12768: 
; 12769:     if (PyUnicode_GET_LENGTH(self) >= width)

  0003f	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00043	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00048	48 8b 5c 24 40	 mov	 rbx, QWORD PTR width$[rsp]

; 12770:         return unicode_result_unchanged(self);

  0004d	48 8b cf	 mov	 rcx, rdi
  00050	48 3b c3	 cmp	 rax, rbx
  00053	7c 10		 jl	 SHORT $LN20@unicode_zf
  00055	e8 00 00 00 00	 call	 unicode_result_unchanged
  0005a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 12791: }

  0005f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00063	5f		 pop	 rdi
  00064	c3		 ret	 0
$LN20@unicode_zf:

; 12771: 
; 12772:     fill = width - PyUnicode_GET_LENGTH(self);

  00065	48 2b d8	 sub	 rbx, rax
  00068	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi

; 12773: 
; 12774:     u = pad(self, fill, 0, '0');

  0006d	be 30 00 00 00	 mov	 esi, 48			; 00000030H
  00072	44 8b ce	 mov	 r9d, esi
  00075	45 33 c0	 xor	 r8d, r8d
  00078	48 8b d3	 mov	 rdx, rbx
  0007b	e8 00 00 00 00	 call	 pad
  00080	4c 8b d8	 mov	 r11, rax

; 12775: 
; 12776:     if (u == NULL)

  00083	48 85 c0	 test	 rax, rax
  00086	75 10		 jne	 SHORT $LN19@unicode_zf
  00088	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0008d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 12791: }

  00092	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
$LN19@unicode_zf:

; 12777:         return NULL;
; 12778: 
; 12779:     kind = PyUnicode_KIND(u);

  00098	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0009b	8b d0		 mov	 edx, eax
  0009d	c1 ea 02	 shr	 edx, 2
  000a0	83 e2 07	 and	 edx, 7

; 12780:     data = PyUnicode_DATA(u);

  000a3	a8 20		 test	 al, 32			; 00000020H
  000a5	74 16		 je	 SHORT $LN29@unicode_zf
  000a7	a8 40		 test	 al, 64			; 00000040H
  000a9	74 09		 je	 SHORT $LN27@unicode_zf
  000ab	49 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [r11+128]
  000b2	eb 10		 jmp	 SHORT $LN30@unicode_zf
$LN27@unicode_zf:
  000b4	49 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [r11+160]
  000bb	eb 07		 jmp	 SHORT $LN30@unicode_zf
$LN29@unicode_zf:
  000bd	49 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [r11+160]
$LN30@unicode_zf:

; 12781:     chr = PyUnicode_READ(kind, data, fill);

  000c4	83 fa 01	 cmp	 edx, 1
  000c7	75 07		 jne	 SHORT $LN33@unicode_zf
  000c9	44 0f b6 04 19	 movzx	 r8d, BYTE PTR [rcx+rbx]
  000ce	eb 10		 jmp	 SHORT $LN32@unicode_zf
$LN33@unicode_zf:
  000d0	83 fa 02	 cmp	 edx, 2
  000d3	75 07		 jne	 SHORT $LN31@unicode_zf
  000d5	44 0f b7 04 59	 movzx	 r8d, WORD PTR [rcx+rbx*2]
  000da	eb 04		 jmp	 SHORT $LN32@unicode_zf
$LN31@unicode_zf:
  000dc	44 8b 04 99	 mov	 r8d, DWORD PTR [rcx+rbx*4]
$LN32@unicode_zf:

; 12782: 
; 12783:     if (chr == '+' || chr == '-') {

  000e0	41 83 f8 2b	 cmp	 r8d, 43			; 0000002bH
  000e4	74 06		 je	 SHORT $LN16@unicode_zf
  000e6	41 83 f8 2d	 cmp	 r8d, 45			; 0000002dH
  000ea	75 54		 jne	 SHORT $LN6@unicode_zf
$LN16@unicode_zf:

; 12784:         /* move sign to beginning of string */
; 12785:         PyUnicode_WRITE(kind, data, 0, chr);

  000ec	44 8b ca	 mov	 r9d, edx
  000ef	41 ff c9	 dec	 r9d
  000f2	74 10		 je	 SHORT $LN11@unicode_zf
  000f4	41 ff c9	 dec	 r9d
  000f7	74 05		 je	 SHORT $LN10@unicode_zf
  000f9	44 89 01	 mov	 DWORD PTR [rcx], r8d
  000fc	eb 09		 jmp	 SHORT $LN15@unicode_zf
$LN10@unicode_zf:
  000fe	66 44 89 01	 mov	 WORD PTR [rcx], r8w
  00102	eb 03		 jmp	 SHORT $LN15@unicode_zf
$LN11@unicode_zf:
  00104	44 88 01	 mov	 BYTE PTR [rcx], r8b
$LN15@unicode_zf:

; 12786:         PyUnicode_WRITE(kind, data, fill, '0');

  00107	ff ca		 dec	 edx
  00109	74 31		 je	 SHORT $LN3@unicode_zf
  0010b	ff ca		 dec	 edx
  0010d	74 16		 je	 SHORT $LN2@unicode_zf
  0010f	89 34 99	 mov	 DWORD PTR [rcx+rbx*4], esi
  00112	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00117	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 12787:     }
; 12788: 
; 12789:     assert(_PyUnicode_CheckConsistency(u, 1));
; 12790:     return u;

  0011c	49 8b c3	 mov	 rax, r11

; 12791: }

  0011f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00123	5f		 pop	 rdi
  00124	c3		 ret	 0
$LN2@unicode_zf:

; 12786:         PyUnicode_WRITE(kind, data, fill, '0');

  00125	66 89 34 59	 mov	 WORD PTR [rcx+rbx*2], si
  00129	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0012e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 12787:     }
; 12788: 
; 12789:     assert(_PyUnicode_CheckConsistency(u, 1));
; 12790:     return u;

  00133	49 8b c3	 mov	 rax, r11

; 12791: }

  00136	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013a	5f		 pop	 rdi
  0013b	c3		 ret	 0
$LN3@unicode_zf:

; 12786:         PyUnicode_WRITE(kind, data, fill, '0');

  0013c	40 88 34 19	 mov	 BYTE PTR [rcx+rbx], sil
$LN6@unicode_zf:
  00140	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00145	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 12787:     }
; 12788: 
; 12789:     assert(_PyUnicode_CheckConsistency(u, 1));
; 12790:     return u;

  0014a	49 8b c3	 mov	 rax, r11

; 12791: }

  0014d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00151	5f		 pop	 rdi
  00152	c3		 ret	 0
unicode_zfill ENDP
_TEXT	ENDS
PUBLIC	_PyUnicodeWriter_Finish
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_PyUnicodeWriter_Finish DD imagerel $LN32
	DD	imagerel $LN32+250
	DD	imagerel $unwind$_PyUnicodeWriter_Finish
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicodeWriter_Finish DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT _PyUnicodeWriter_Finish
_TEXT	SEGMENT
writer$ = 64
_PyUnicodeWriter_Finish PROC				; COMDAT

; 13020: {

$LN32:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 13021:     if (writer->pos == 0) {

  00006	48 8b 51 20	 mov	 rdx, QWORD PTR [rcx+32]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	48 85 d2	 test	 rdx, rdx
  00010	0f 85 a1 00 00
	00		 jne	 $LN10@PyUnicodeW@5

; 13022:         Py_XDECREF(writer->buffer);

  00016	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
  00019	48 85 db	 test	 rbx, rbx
  0001c	74 65		 je	 SHORT $LN15@PyUnicodeW@5
  0001e	e8 00 00 00 00	 call	 _Py_PXCTX
  00023	85 c0		 test	 eax, eax
  00025	75 5c		 jne	 SHORT $LN15@PyUnicodeW@5
  00027	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0002b	a8 20		 test	 al, 32			; 00000020H
  0002d	75 4c		 jne	 SHORT $LN24@PyUnicodeW@5
  0002f	84 c0		 test	 al, al
  00031	78 48		 js	 SHORT $LN24@PyUnicodeW@5
  00033	a8 02		 test	 al, 2
  00035	75 4c		 jne	 SHORT $LN15@PyUnicodeW@5
  00037	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0003b	75 46		 jne	 SHORT $LN15@PyUnicodeW@5
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0004b	4c 8b cb	 mov	 r9, rbx
  0004e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00054	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0005c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00061	48 8b cb	 mov	 rcx, rbx
  00064	85 c0		 test	 eax, eax
  00066	74 07		 je	 SHORT $LN29@PyUnicodeW@5
  00068	e8 00 00 00 00	 call	 _Px_Dealloc
  0006d	eb 14		 jmp	 SHORT $LN15@PyUnicodeW@5
$LN29@PyUnicodeW@5:
  0006f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00073	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00079	eb 08		 jmp	 SHORT $LN15@PyUnicodeW@5
$LN24@PyUnicodeW@5:
  0007b	48 8b cb	 mov	 rcx, rbx
  0007e	e8 00 00 00 00	 call	 Px_DecRef
$LN15@PyUnicodeW@5:

; 13023:         _Py_RETURN_UNICODE_EMPTY();

  00083	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  0008a	48 85 c9	 test	 rcx, rcx
  0008d	75 16		 jne	 SHORT $LN31@PyUnicodeW@5
  0008f	33 d2		 xor	 edx, edx
  00091	e8 00 00 00 00	 call	 PyUnicode_New
  00096	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  0009d	48 85 c0	 test	 rax, rax
  000a0	74 52		 je	 SHORT $LN18@PyUnicodeW@5
  000a2	48 8b c8	 mov	 rcx, rax
$LN31@PyUnicodeW@5:
  000a5	e8 00 00 00 00	 call	 _Py_IncRef
  000aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 13040: }

  000b1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b5	5b		 pop	 rbx
  000b6	c3		 ret	 0
$LN10@PyUnicodeW@5:

; 13024:     }
; 13025:     if (writer->readonly) {

  000b7	80 79 31 00	 cmp	 BYTE PTR [rcx+49], 0
  000bb	74 09		 je	 SHORT $LN3@PyUnicodeW@5

; 13026:         assert(PyUnicode_GET_LENGTH(writer->buffer) == writer->pos);
; 13027:         return writer->buffer;

  000bd	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 13040: }

  000c0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c4	5b		 pop	 rbx
  000c5	c3		 ret	 0
$LN3@PyUnicodeW@5:

; 13028:     }
; 13029:     if (PyUnicode_GET_LENGTH(writer->buffer) != writer->pos) {

  000c6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000c9	48 39 51 60	 cmp	 QWORD PTR [rcx+96], rdx
  000cd	74 1d		 je	 SHORT $LN2@PyUnicodeW@5

; 13030:         PyObject *newbuffer;
; 13031:         newbuffer = resize_compact(writer->buffer, writer->pos);

  000cf	e8 00 00 00 00	 call	 resize_compact

; 13032:         if (newbuffer == NULL) {

  000d4	48 85 c0	 test	 rax, rax
  000d7	75 10		 jne	 SHORT $LN1@PyUnicodeW@5

; 13033:             Py_DECREF(writer->buffer);

  000d9	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000dc	e8 00 00 00 00	 call	 _Py_DecRef

; 13034:             return NULL;

  000e1	33 c0		 xor	 eax, eax

; 13040: }

  000e3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e7	5b		 pop	 rbx
  000e8	c3		 ret	 0
$LN1@PyUnicodeW@5:

; 13035:         }
; 13036:         writer->buffer = newbuffer;

  000e9	48 89 03	 mov	 QWORD PTR [rbx], rax
$LN2@PyUnicodeW@5:

; 13037:     }
; 13038:     assert(_PyUnicode_CheckConsistency(writer->buffer, 1));
; 13039:     return unicode_result_ready(writer->buffer);

  000ec	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000ef	e8 00 00 00 00	 call	 unicode_result_ready
$LN18@PyUnicodeW@5:

; 13040: }

  000f4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f8	5b		 pop	 rbx
  000f9	c3		 ret	 0
_PyUnicodeWriter_Finish ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$SubString_new_object DD imagerel SubString_new_object
	DD	imagerel SubString_new_object+113
	DD	imagerel $unwind$SubString_new_object
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SubString_new_object DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\unicode_format.h
xdata	ENDS
;	COMDAT SubString_new_object
_TEXT	SEGMENT
str$ = 64
SubString_new_object PROC				; COMDAT

; 62   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 63   :     if (str->str == NULL) {

  00004	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00007	48 85 c0	 test	 rax, rax
  0000a	75 51		 jne	 SHORT $LN1@SubString_

; 64   :         Py_INCREF(Py_None);

  0000c	e8 00 00 00 00	 call	 _Py_PXCTX
  00011	85 c0		 test	 eax, eax
  00013	75 3c		 jne	 SHORT $LN5@SubString_
  00015	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0002a	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00030	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00038	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003d	85 c0		 test	 eax, eax
  0003f	75 09		 jne	 SHORT $LN4@SubString_
  00041	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00048	74 07		 je	 SHORT $LN5@SubString_
$LN4@SubString_:
  0004a	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@SubString_:

; 65   :         return Py_None;

  00051	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 68   : }

  00058	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005c	c3		 ret	 0
$LN1@SubString_:

; 66   :     }
; 67   :     return PyUnicode_Substring(str->str, str->start, str->end);

  0005d	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00061	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00065	48 8b c8	 mov	 rcx, rax

; 68   : }

  00068	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006c	e9 00 00 00 00	 jmp	 PyUnicode_Substring
SubString_new_object ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT SubString_new_object_or_empty
_TEXT	SEGMENT
str$ = 8
SubString_new_object_or_empty PROC			; COMDAT

; 74   :     if (str->str == NULL) {

  00000	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00004	75 09		 jne	 SHORT $LN1@SubString_@2

; 75   :         return PyUnicode_New(0, 0);

  00006	33 d2		 xor	 edx, edx
  00008	33 c9		 xor	 ecx, ecx

; 76   :     }
; 77   :     return SubString_new_object(str);
; 78   : }

  0000a	e9 00 00 00 00	 jmp	 PyUnicode_New
$LN1@SubString_@2:
  0000f	e9 00 00 00 00	 jmp	 SubString_new_object
SubString_new_object_or_empty ENDP
_TEXT	ENDS
EXTRN	PyObject_GetAttr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$getattr DD imagerel getattr
	DD	imagerel getattr+76
	DD	imagerel $unwind$getattr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getattr DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT getattr
_TEXT	SEGMENT
obj$ = 48
name$ = 56
getattr	PROC						; COMDAT

; 148  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 149  :     PyObject *newobj;
; 150  :     PyObject *str = SubString_new_object(name);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 SubString_new_object
  00015	48 8b f8	 mov	 rdi, rax

; 151  :     if (str == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0b		 jne	 SHORT $LN1@getattr

; 156  : }

  0001d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN1@getattr:

; 152  :         return NULL;
; 153  :     newobj = PyObject_GetAttr(obj, str);

  00028	48 8b d0	 mov	 rdx, rax
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	e8 00 00 00 00	 call	 PyObject_GetAttr

; 154  :     Py_DECREF(str);

  00033	48 8b cf	 mov	 rcx, rdi
  00036	48 8b d8	 mov	 rbx, rax
  00039	e8 00 00 00 00	 call	 _Py_DecRef

; 155  :     return newobj;

  0003e	48 8b c3	 mov	 rax, rbx

; 156  : }

  00041	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
getattr	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getitem_str DD imagerel getitem_str
	DD	imagerel getitem_str+76
	DD	imagerel $unwind$getitem_str
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getitem_str DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT getitem_str
_TEXT	SEGMENT
obj$ = 48
name$ = 56
getitem_str PROC					; COMDAT

; 181  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 182  :     PyObject *newobj;
; 183  :     PyObject *str = SubString_new_object(name);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 SubString_new_object
  00015	48 8b f8	 mov	 rdi, rax

; 184  :     if (str == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0b		 jne	 SHORT $LN1@getitem_st

; 189  : }

  0001d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN1@getitem_st:

; 185  :         return NULL;
; 186  :     newobj = PyObject_GetItem(obj, str);

  00028	48 8b d0	 mov	 rdx, rax
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	e8 00 00 00 00	 call	 PyObject_GetItem

; 187  :     Py_DECREF(str);

  00033	48 8b cf	 mov	 rcx, rdi
  00036	48 8b d8	 mov	 rbx, rax
  00039	e8 00 00 00 00	 call	 _Py_DecRef

; 188  :     return newobj;

  0003e	48 8b c3	 mov	 rax, rbx

; 189  : }

  00041	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
getitem_str ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@MGGADJAP@Format?5string?5contains?5positiona@ ; `string'
EXTRN	PySequence_Check:PROC
EXTRN	PyErr_SetObject:PROC
EXTRN	PyExc_KeyError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$get_field_object DD imagerel get_field_object
	DD	imagerel get_field_object+656
	DD	imagerel $unwind$get_field_object
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_field_object DD 061301H
	DD	0146413H
	DD	0133413H
	DD	0700cf213H
xdata	ENDS
;	COMDAT ??_C@_0CJ@MGGADJAP@Format?5string?5contains?5positiona@
CONST	SEGMENT
??_C@_0CJ@MGGADJAP@Format?5string?5contains?5positiona@ DB 'Format string'
	DB	' contains positional fields', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\unicode_format.h
CONST	ENDS
;	COMDAT get_field_object
_TEXT	SEGMENT
index$ = 64
name$ = 72
first$ = 72
rest$ = 96
is_attribute$ = 144
input$ = 144
args$ = 152
kwargs$ = 160
auto_number$ = 168
get_field_object PROC					; COMDAT

; 398  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00007	49 89 73 18	 mov	 QWORD PTR [r11+24], rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 399  :     PyObject *obj = NULL;
; 400  :     int ok;
; 401  :     int is_attribute;
; 402  :     SubString name;
; 403  :     SubString first;
; 404  :     Py_ssize_t index;
; 405  :     FieldNameIterator rest;
; 406  : 
; 407  :     if (!field_name_split(input->str, input->start, input->end, &first,
; 408  :                           &index, &rest, auto_number)) {

  00013	4d 89 4b a8	 mov	 QWORD PTR [r11-88], r9
  00017	49 8d 43 d8	 lea	 rax, QWORD PTR [r11-40]
  0001b	49 8b f0	 mov	 rsi, r8
  0001e	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00022	49 89 43 a0	 mov	 QWORD PTR [r11-96], rax
  00026	48 8b fa	 mov	 rdi, rdx
  00029	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  0002d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00030	49 8d 43 b8	 lea	 rax, QWORD PTR [r11-72]
  00034	4d 8d 4b c0	 lea	 r9, QWORD PTR [r11-64]
  00038	49 89 43 98	 mov	 QWORD PTR [r11-104], rax
  0003c	33 db		 xor	 ebx, ebx
  0003e	e8 00 00 00 00	 call	 field_name_split
  00043	85 c0		 test	 eax, eax
  00045	0f 84 2e 02 00
	00		 je	 $LN3@get_field_

; 409  :         goto error;
; 410  :     }
; 411  : 
; 412  :     if (index == -1) {

  0004b	48 8b 54 24 40	 mov	 rdx, QWORD PTR index$[rsp]
  00050	48 83 fa ff	 cmp	 rdx, -1
  00054	0f 85 20 01 00
	00		 jne	 $LN21@get_field_

; 413  :         /* look up in kwargs */
; 414  :         PyObject *key = SubString_new_object(&first);

  0005a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR first$[rsp]
  0005f	48 85 c9	 test	 rcx, rcx
  00062	75 4a		 jne	 SHORT $LN25@get_field_
  00064	e8 00 00 00 00	 call	 _Py_PXCTX
  00069	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  00070	85 c0		 test	 eax, eax
  00072	75 55		 jne	 SHORT $LN46@get_field_
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00082	4c 8b cf	 mov	 r9, rdi
  00085	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0008b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00093	e8 00 00 00 00	 call	 _PyParallel_Guard
  00098	85 c0		 test	 eax, eax
  0009a	75 09		 jne	 SHORT $LN28@get_field_
  0009c	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000a3	74 24		 je	 SHORT $LN46@get_field_
$LN28@get_field_:
  000a5	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
  000ac	eb 1b		 jmp	 SHORT $LN46@get_field_
$LN25@get_field_:
  000ae	4c 8b 44 24 58	 mov	 r8, QWORD PTR first$[rsp+16]
  000b3	48 8b 54 24 50	 mov	 rdx, QWORD PTR first$[rsp+8]
  000b8	e8 00 00 00 00	 call	 PyUnicode_Substring
  000bd	48 8b f8	 mov	 rdi, rax

; 415  :         if (key == NULL)

  000c0	48 85 c0	 test	 rax, rax
  000c3	0f 84 b0 01 00
	00		 je	 $LN3@get_field_
$LN46@get_field_:

; 416  :             goto error;
; 417  : 
; 418  :         /* Use PyObject_GetItem instead of PyDict_GetItem because this
; 419  :            code is no longer just used with kwargs. It might be passed
; 420  :            a non-dict when called through format_map. */
; 421  :         if ((kwargs == NULL) || (obj = PyObject_GetItem(kwargs, key)) == NULL) {

  000c9	48 85 f6	 test	 rsi, rsi
  000cc	74 20		 je	 SHORT $LN18@get_field_
  000ce	48 8b d7	 mov	 rdx, rdi
  000d1	48 8b ce	 mov	 rcx, rsi
  000d4	e8 00 00 00 00	 call	 PyObject_GetItem
  000d9	48 8b d8	 mov	 rbx, rax
  000dc	48 85 c0	 test	 rax, rax
  000df	74 0d		 je	 SHORT $LN18@get_field_

; 424  :             goto error;
; 425  :         }
; 426  :         Py_DECREF(key);

  000e1	48 8b cf	 mov	 rcx, rdi
  000e4	e8 00 00 00 00	 call	 _Py_DecRef

; 427  :     }
; 428  :     else {

  000e9	e9 bd 00 00 00	 jmp	 $LN43@get_field_
$LN18@get_field_:

; 422  :             PyErr_SetObject(PyExc_KeyError, key);

  000ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  000f5	48 8b d7	 mov	 rdx, rdi
  000f8	e8 00 00 00 00	 call	 PyErr_SetObject

; 423  :             Py_DECREF(key);

  000fd	48 8b cf	 mov	 rcx, rdi
  00100	e8 00 00 00 00	 call	 _Py_DecRef
$error$141858:

; 473  : error:
; 474  :     Py_XDECREF(obj);

  00105	48 85 db	 test	 rbx, rbx
  00108	0f 84 6b 01 00
	00		 je	 $LN3@get_field_
  0010e	e8 00 00 00 00	 call	 _Py_PXCTX
  00113	85 c0		 test	 eax, eax
  00115	0f 85 5e 01 00
	00		 jne	 $LN3@get_field_
  0011b	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0011f	a8 20		 test	 al, 32			; 00000020H
  00121	0f 85 4a 01 00
	00		 jne	 $LN36@get_field_
  00127	84 c0		 test	 al, al
  00129	0f 88 42 01 00
	00		 js	 $LN36@get_field_
  0012f	a8 02		 test	 al, 2
  00131	0f 85 42 01 00
	00		 jne	 $LN3@get_field_
  00137	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0013b	0f 85 38 01 00
	00		 jne	 $LN3@get_field_
  00141	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0014f	4c 8b cb	 mov	 r9, rbx
  00152	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00158	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00160	e8 00 00 00 00	 call	 _PyParallel_Guard
  00165	48 8b cb	 mov	 rcx, rbx
  00168	85 c0		 test	 eax, eax
  0016a	0f 84 f5 00 00
	00		 je	 $LN41@get_field_
  00170	e8 00 00 00 00	 call	 _Px_Dealloc
  00175	e9 ff 00 00 00	 jmp	 $LN3@get_field_
$LN21@get_field_:

; 429  :         /* If args is NULL, we have a format string with a positional field
; 430  :            with only kwargs to retrieve it from. This can only happen when
; 431  :            used with format_map(), where positional arguments are not
; 432  :            allowed. */
; 433  :         if (args == NULL) {

  0017a	48 85 ff	 test	 rdi, rdi
  0017d	75 18		 jne	 SHORT $LN16@get_field_

; 434  :             PyErr_SetString(PyExc_ValueError, "Format string contains "
; 435  :                             "positional fields");

  0017f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00186	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@MGGADJAP@Format?5string?5contains?5positiona@
  0018d	e8 00 00 00 00	 call	 PyErr_SetString

; 436  :             goto error;

  00192	e9 e2 00 00 00	 jmp	 $LN3@get_field_
$LN16@get_field_:

; 437  :         }
; 438  : 
; 439  :         /* look up in args */
; 440  :         obj = PySequence_GetItem(args, index);

  00197	48 8b cf	 mov	 rcx, rdi
  0019a	e8 00 00 00 00	 call	 PySequence_GetItem
  0019f	48 8b d8	 mov	 rbx, rax

; 441  :         if (obj == NULL)

  001a2	48 85 c0	 test	 rax, rax
  001a5	0f 84 ce 00 00
	00		 je	 $LN3@get_field_
$LN43@get_field_:

; 442  :             goto error;
; 443  :     }
; 444  : 
; 445  :     /* iterate over the rest of the field_name */
; 446  :     while ((ok = FieldNameIterator_next(&rest, &is_attribute, &index,
; 447  :                                         &name)) == 2) {

  001ab	4c 8d 4c 24 48	 lea	 r9, QWORD PTR name$[rsp]
  001b0	4c 8d 44 24 40	 lea	 r8, QWORD PTR index$[rsp]
  001b5	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR is_attribute$[rsp]
  001bd	48 8d 4c 24 60	 lea	 rcx, QWORD PTR rest$[rsp]
  001c2	e8 00 00 00 00	 call	 FieldNameIterator_next
  001c7	83 f8 02	 cmp	 eax, 2
  001ca	0f 85 87 00 00
	00		 jne	 $LN13@get_field_
$LL14@get_field_:

; 448  :         PyObject *tmp;
; 449  : 
; 450  :         if (is_attribute)

  001d0	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR is_attribute$[rsp], 0

; 451  :             /* getattr lookup "." */
; 452  :             tmp = getattr(obj, &name);

  001d8	48 8b cb	 mov	 rcx, rbx
  001db	74 0c		 je	 SHORT $LN12@get_field_
  001dd	48 8d 54 24 48	 lea	 rdx, QWORD PTR name$[rsp]
  001e2	e8 00 00 00 00	 call	 getattr

; 453  :         else

  001e7	eb 32		 jmp	 SHORT $LN47@get_field_
$LN12@get_field_:

; 454  :             /* getitem lookup "[]" */
; 455  :             if (index == -1)

  001e9	48 8b 7c 24 40	 mov	 rdi, QWORD PTR index$[rsp]
  001ee	48 83 ff ff	 cmp	 rdi, -1
  001f2	75 0c		 jne	 SHORT $LN10@get_field_

; 456  :                 tmp = getitem_str(obj, &name);

  001f4	48 8d 54 24 48	 lea	 rdx, QWORD PTR name$[rsp]
  001f9	e8 00 00 00 00	 call	 getitem_str

; 457  :             else

  001fe	eb 1b		 jmp	 SHORT $LN47@get_field_
$LN10@get_field_:

; 458  :                 if (PySequence_Check(obj))

  00200	e8 00 00 00 00	 call	 PySequence_Check

; 459  :                     tmp = getitem_sequence(obj, index);

  00205	48 8b d7	 mov	 rdx, rdi
  00208	48 8b cb	 mov	 rcx, rbx
  0020b	85 c0		 test	 eax, eax
  0020d	74 07		 je	 SHORT $LN8@get_field_
  0020f	e8 00 00 00 00	 call	 getitem_sequence

; 460  :                 else

  00214	eb 05		 jmp	 SHORT $LN47@get_field_
$LN8@get_field_:

; 461  :                     /* not a sequence */
; 462  :                     tmp = getitem_idx(obj, index);

  00216	e8 00 00 00 00	 call	 getitem_idx
$LN47@get_field_:
  0021b	48 8b f8	 mov	 rdi, rax

; 463  :         if (tmp == NULL)

  0021e	48 85 c0	 test	 rax, rax
  00221	0f 84 de fe ff
	ff		 je	 $error$141858

; 464  :             goto error;
; 465  : 
; 466  :         /* assign to obj */
; 467  :         Py_DECREF(obj);

  00227	48 8b cb	 mov	 rcx, rbx
  0022a	e8 00 00 00 00	 call	 _Py_DecRef
  0022f	4c 8d 4c 24 48	 lea	 r9, QWORD PTR name$[rsp]
  00234	4c 8d 44 24 40	 lea	 r8, QWORD PTR index$[rsp]
  00239	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR is_attribute$[rsp]
  00241	48 8d 4c 24 60	 lea	 rcx, QWORD PTR rest$[rsp]

; 468  :         obj = tmp;

  00246	48 8b df	 mov	 rbx, rdi
  00249	e8 00 00 00 00	 call	 FieldNameIterator_next
  0024e	83 f8 02	 cmp	 eax, 2
  00251	0f 84 79 ff ff
	ff		 je	 $LL14@get_field_
$LN13@get_field_:

; 469  :     }
; 470  :     /* end of iterator, this is the non-error case */
; 471  :     if (ok == 1)

  00257	83 f8 01	 cmp	 eax, 1
  0025a	0f 85 a5 fe ff
	ff		 jne	 $error$141858

; 472  :         return obj;

  00260	48 8b c3	 mov	 rax, rbx
  00263	eb 16		 jmp	 SHORT $LN23@get_field_

; 473  : error:
; 474  :     Py_XDECREF(obj);

$LN41@get_field_:
  00265	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00269	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0026f	eb 08		 jmp	 SHORT $LN3@get_field_
$LN36@get_field_:
  00271	48 8b cb	 mov	 rcx, rbx
  00274	e8 00 00 00 00	 call	 Px_DecRef
$LN3@get_field_:

; 475  :     return NULL;

  00279	33 c0		 xor	 eax, eax
$LN23@get_field_:

; 476  : }

  0027b	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  00283	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  00287	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  0028b	49 8b e3	 mov	 rsp, r11
  0028e	5f		 pop	 rdi
  0028f	c3		 ret	 0
get_field_object ENDP
_TEXT	ENDS
EXTRN	PyObject_Format:PROC
EXTRN	_PyComplex_FormatAdvancedWriter:PROC
EXTRN	PyComplex_Type:BYTE
EXTRN	_PyFloat_FormatAdvancedWriter:PROC
EXTRN	PyFloat_Type:BYTE
EXTRN	_PyLong_FormatAdvancedWriter:PROC
EXTRN	PyLong_Type:BYTE
EXTRN	_PyUnicode_FormatAdvancedWriter:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$render_field DD imagerel render_field
	DD	imagerel render_field+483
	DD	imagerel $unwind$render_field
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$render_field DD 08ab01H
	DD	0874abH
	DD	0a540fH
	DD	09340fH
	DD	0600b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\unicode_format.h
xdata	ENDS
;	COMDAT render_field
_TEXT	SEGMENT
fieldobj$ = 64
format_spec$ = 72
writer$ = 80
render_field PROC					; COMDAT

; 492  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 493  :     int ok = 0;
; 494  :     PyObject *result = NULL;
; 495  :     PyObject *format_spec_object = NULL;
; 496  :     int (*formatter) (_PyUnicodeWriter*, PyObject *, PyObject *, Py_ssize_t, Py_ssize_t) = NULL;
; 497  :     int err;
; 498  : 
; 499  :     /* If we know the type exactly, skip the lookup of __format__ and just
; 500  :        call the formatter directly. */
; 501  :     if (PyUnicode_CheckExact(fieldobj))

  0000f	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00013	48 8b d9	 mov	 rbx, rcx
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyUnicode_Type
  0001d	33 f6		 xor	 esi, esi
  0001f	49 8b e8	 mov	 rbp, r8
  00022	48 3b c1	 cmp	 rax, rcx
  00025	75 09		 jne	 SHORT $LN22@render_fie

; 502  :         formatter = _PyUnicode_FormatAdvancedWriter;

  00027	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:_PyUnicode_FormatAdvancedWriter
  0002e	eb 3d		 jmp	 SHORT $LN16@render_fie
$LN22@render_fie:

; 503  :     else if (PyLong_CheckExact(fieldobj))

  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyLong_Type
  00037	48 3b c1	 cmp	 rax, rcx
  0003a	75 09		 jne	 SHORT $LN20@render_fie

; 504  :         formatter = _PyLong_FormatAdvancedWriter;

  0003c	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:_PyLong_FormatAdvancedWriter
  00043	eb 28		 jmp	 SHORT $LN16@render_fie
$LN20@render_fie:

; 505  :     else if (PyFloat_CheckExact(fieldobj))

  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFloat_Type
  0004c	48 3b c1	 cmp	 rax, rcx
  0004f	75 09		 jne	 SHORT $LN18@render_fie

; 506  :         formatter = _PyFloat_FormatAdvancedWriter;

  00051	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:_PyFloat_FormatAdvancedWriter
  00058	eb 13		 jmp	 SHORT $LN16@render_fie
$LN18@render_fie:

; 507  :     else if (PyComplex_CheckExact(fieldobj))

  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyComplex_Type
  00061	48 3b c1	 cmp	 rax, rcx
  00064	75 3d		 jne	 SHORT $LN15@render_fie

; 508  :         formatter = _PyComplex_FormatAdvancedWriter;

  00066	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:_PyComplex_FormatAdvancedWriter
$LN16@render_fie:

; 509  : 
; 510  :     if (formatter) {

  0006d	4d 85 d2	 test	 r10, r10
  00070	74 31		 je	 SHORT $LN15@render_fie

; 511  :         /* we know exactly which formatter will be called when __format__ is
; 512  :            looked up, so call it directly, instead. */
; 513  :         err = formatter(writer, fieldobj, format_spec->str,
; 514  :                         format_spec->start, format_spec->end);

  00072	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  00076	4c 8b 4a 08	 mov	 r9, QWORD PTR [rdx+8]
  0007a	4c 8b 02	 mov	 r8, QWORD PTR [rdx]
  0007d	48 8b d3	 mov	 rdx, rbx
  00080	48 8b cd	 mov	 rcx, rbp
  00083	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00088	41 ff d2	 call	 r10

; 515  :         return (err == 0);

  0008b	85 c0		 test	 eax, eax
  0008d	40 0f 94 c6	 sete	 sil

; 541  :     return ok;

  00091	8b c6		 mov	 eax, esi

; 542  : }

  00093	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00098	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0009d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a1	5e		 pop	 rsi
  000a2	c3		 ret	 0
$LN15@render_fie:

; 516  :     }
; 517  :     else {
; 518  :         /* We need to create an object out of the pointers we have, because
; 519  :            __format__ takes a string/unicode object for format_spec. */
; 520  :         if (format_spec->str)

  000a3	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  000a6	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  000ab	48 85 c9	 test	 rcx, rcx
  000ae	74 0f		 je	 SHORT $LN13@render_fie

; 521  :             format_spec_object = PyUnicode_Substring(format_spec->str,
; 522  :                                                      format_spec->start,
; 523  :                                                      format_spec->end);

  000b0	4c 8b 42 10	 mov	 r8, QWORD PTR [rdx+16]
  000b4	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  000b8	e8 00 00 00 00	 call	 PyUnicode_Substring

; 524  :         else

  000bd	eb 09		 jmp	 SHORT $LN48@render_fie
$LN13@render_fie:

; 525  :             format_spec_object = PyUnicode_New(0, 0);

  000bf	33 d2		 xor	 edx, edx
  000c1	33 c9		 xor	 ecx, ecx
  000c3	e8 00 00 00 00	 call	 PyUnicode_New
$LN48@render_fie:
  000c8	48 8b f8	 mov	 rdi, rax

; 526  :         if (format_spec_object == NULL)

  000cb	48 85 c0	 test	 rax, rax
  000ce	0f 84 f8 00 00
	00		 je	 $LN3@render_fie

; 527  :             goto done;
; 528  : 
; 529  :         result = PyObject_Format(fieldobj, format_spec_object);

  000d4	48 8b d0	 mov	 rdx, rax
  000d7	48 8b cb	 mov	 rcx, rbx
  000da	e8 00 00 00 00	 call	 PyObject_Format
  000df	48 8b d8	 mov	 rbx, rax

; 530  :     }
; 531  :     if (result == NULL)

  000e2	48 85 c0	 test	 rax, rax
  000e5	74 16		 je	 SHORT $done$141933

; 532  :         goto done;
; 533  : 
; 534  :     if (_PyUnicodeWriter_WriteStr(writer, result) == -1)

  000e7	48 8b d0	 mov	 rdx, rax
  000ea	48 8b cd	 mov	 rcx, rbp
  000ed	e8 00 00 00 00	 call	 _PyUnicodeWriter_WriteStr
  000f2	b9 01 00 00 00	 mov	 ecx, 1
  000f7	83 f8 ff	 cmp	 eax, -1
  000fa	0f 45 f1	 cmovne	 esi, ecx
$done$141933:

; 535  :         goto done;
; 536  :     ok = 1;
; 537  : 
; 538  : done:
; 539  :     Py_XDECREF(format_spec_object);

  000fd	e8 00 00 00 00	 call	 _Py_PXCTX
  00102	85 c0		 test	 eax, eax
  00104	75 5c		 jne	 SHORT $LN7@render_fie
  00106	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0010a	a8 20		 test	 al, 32			; 00000020H
  0010c	75 4c		 jne	 SHORT $LN29@render_fie
  0010e	84 c0		 test	 al, al
  00110	78 48		 js	 SHORT $LN29@render_fie
  00112	a8 02		 test	 al, 2
  00114	75 4c		 jne	 SHORT $LN7@render_fie
  00116	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0011a	75 46		 jne	 SHORT $LN7@render_fie
  0011c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0012a	4c 8b cf	 mov	 r9, rdi
  0012d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00133	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0013b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00140	48 8b cf	 mov	 rcx, rdi
  00143	85 c0		 test	 eax, eax
  00145	74 07		 je	 SHORT $LN34@render_fie
  00147	e8 00 00 00 00	 call	 _Px_Dealloc
  0014c	eb 14		 jmp	 SHORT $LN7@render_fie
$LN34@render_fie:
  0014e	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00152	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00158	eb 08		 jmp	 SHORT $LN7@render_fie
$LN29@render_fie:
  0015a	48 8b cf	 mov	 rcx, rdi
  0015d	e8 00 00 00 00	 call	 Px_DecRef
$LN7@render_fie:

; 540  :     Py_XDECREF(result);

  00162	48 85 db	 test	 rbx, rbx
  00165	74 65		 je	 SHORT $LN3@render_fie
  00167	e8 00 00 00 00	 call	 _Py_PXCTX
  0016c	85 c0		 test	 eax, eax
  0016e	75 5c		 jne	 SHORT $LN3@render_fie
  00170	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00174	a8 20		 test	 al, 32			; 00000020H
  00176	75 4c		 jne	 SHORT $LN40@render_fie
  00178	84 c0		 test	 al, al
  0017a	78 48		 js	 SHORT $LN40@render_fie
  0017c	a8 02		 test	 al, 2
  0017e	75 4c		 jne	 SHORT $LN3@render_fie
  00180	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00184	75 46		 jne	 SHORT $LN3@render_fie
  00186	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0018d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00194	4c 8b cb	 mov	 r9, rbx
  00197	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0019d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001a5	e8 00 00 00 00	 call	 _PyParallel_Guard
  001aa	48 8b cb	 mov	 rcx, rbx
  001ad	85 c0		 test	 eax, eax
  001af	74 07		 je	 SHORT $LN45@render_fie
  001b1	e8 00 00 00 00	 call	 _Px_Dealloc
  001b6	eb 14		 jmp	 SHORT $LN3@render_fie
$LN45@render_fie:
  001b8	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001bc	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001c2	eb 08		 jmp	 SHORT $LN3@render_fie
$LN40@render_fie:
  001c4	48 8b cb	 mov	 rcx, rbx
  001c7	e8 00 00 00 00	 call	 Px_DecRef
$LN3@render_fie:

; 542  : }

  001cc	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  001d1	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  001d6	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  001db	8b c6		 mov	 eax, esi
  001dd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001e1	5e		 pop	 rsi
  001e2	c3		 ret	 0
render_field ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$output_markup DD imagerel output_markup
	DD	imagerel output_markup+522
	DD	imagerel $unwind$output_markup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$output_markup DD 0c1e01H
	DD	011741eH
	DD	010641eH
	DD	0f541eH
	DD	0e341eH
	DD	0e01a921eH
	DD	0c016d018H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\unicode_format.h
xdata	ENDS
;	COMDAT output_markup
_TEXT	SEGMENT
expanded_format_spec$ = 48
field_name$ = 112
format_spec$ = 120
format_spec_needs_expanding$ = 128
conversion$ = 136
writer$ = 144
args$ = 152
kwargs$ = 160
recursion_depth$ = 168
auto_number$ = 176
output_markup PROC					; COMDAT

; 812  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 813  :     PyObject *tmp = NULL;
; 814  :     PyObject *fieldobj = NULL;
; 815  :     SubString expanded_format_spec;
; 816  :     SubString *actual_format_spec;
; 817  :     int result = 0;
; 818  : 
; 819  :     /* convert field_name to an object */
; 820  :     fieldobj = get_field_object(field_name, args, kwargs, auto_number);

  0001e	4c 8b b4 24 b0
	00 00 00	 mov	 r14, QWORD PTR auto_number$[rsp]
  00026	45 8b e8	 mov	 r13d, r8d
  00029	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR kwargs$[rsp]
  00031	48 8b ea	 mov	 rbp, rdx
  00034	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR args$[rsp]
  0003c	45 8b e1	 mov	 r12d, r9d
  0003f	33 ff		 xor	 edi, edi
  00041	4d 8b ce	 mov	 r9, r14
  00044	8b df		 mov	 ebx, edi
  00046	e8 00 00 00 00	 call	 get_field_object
  0004b	48 8b f0	 mov	 rsi, rax

; 821  :     if (fieldobj == NULL)

  0004e	48 85 c0	 test	 rax, rax
  00051	0f 84 92 01 00
	00		 je	 $LN54@output_mar

; 822  :         goto done;
; 823  : 
; 824  :     if (conversion != '\0') {

  00057	45 85 e4	 test	 r12d, r12d
  0005a	74 3c		 je	 SHORT $LN16@output_mar

; 825  :         tmp = do_conversion(fieldobj, conversion);

  0005c	41 8b d4	 mov	 edx, r12d
  0005f	48 8b c8	 mov	 rcx, rax
  00062	e8 00 00 00 00	 call	 do_conversion
  00067	48 8b d8	 mov	 rbx, rax

; 826  :         if (tmp == NULL || PyUnicode_READY(tmp) == -1)

  0006a	48 85 c0	 test	 rax, rax
  0006d	0f 84 a2 00 00
	00		 je	 $done$142416
  00073	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  00077	75 11		 jne	 SHORT $LN48@output_mar
  00079	48 8b c8	 mov	 rcx, rax
  0007c	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00081	83 f8 ff	 cmp	 eax, -1
  00084	0f 84 8b 00 00
	00		 je	 $done$142416
$LN48@output_mar:

; 827  :             goto done;
; 828  : 
; 829  :         /* do the assignment, transferring ownership: fieldobj = tmp */
; 830  :         Py_DECREF(fieldobj);

  0008a	48 8b ce	 mov	 rcx, rsi
  0008d	e8 00 00 00 00	 call	 _Py_DecRef

; 831  :         fieldobj = tmp;

  00092	48 8b f3	 mov	 rsi, rbx

; 832  :         tmp = NULL;

  00095	48 8b df	 mov	 rbx, rdi
$LN16@output_mar:

; 833  :     }
; 834  : 
; 835  :     /* if needed, recurively compute the format_spec */
; 836  :     if (format_spec_needs_expanding) {

  00098	45 85 ed	 test	 r13d, r13d
  0009b	74 5b		 je	 SHORT $LN13@output_mar

; 837  :         tmp = build_string(format_spec, args, kwargs, recursion_depth-1,
; 838  :                            auto_number);

  0009d	44 8b 8c 24 a8
	00 00 00	 mov	 r9d, DWORD PTR recursion_depth$[rsp]
  000a5	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR kwargs$[rsp]
  000ad	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR args$[rsp]
  000b5	41 ff c9	 dec	 r9d
  000b8	48 8b cd	 mov	 rcx, rbp
  000bb	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  000c0	e8 00 00 00 00	 call	 build_string
  000c5	48 8b d8	 mov	 rbx, rax

; 839  :         if (tmp == NULL || PyUnicode_READY(tmp) == -1)

  000c8	48 85 c0	 test	 rax, rax
  000cb	74 48		 je	 SHORT $done$142416
  000cd	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  000d1	75 0d		 jne	 SHORT $LN49@output_mar
  000d3	48 8b c8	 mov	 rcx, rax
  000d6	e8 00 00 00 00	 call	 _PyUnicode_Ready
  000db	83 f8 ff	 cmp	 eax, -1
  000de	74 35		 je	 SHORT $done$142416
$LN49@output_mar:

; 840  :             goto done;
; 841  : 
; 842  :         /* note that in the case we're expanding the format string,
; 843  :            tmp must be kept around until after the call to
; 844  :            render_field. */
; 845  :         SubString_init(&expanded_format_spec, tmp, 0, PyUnicode_GET_LENGTH(tmp));

  000e0	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  000e4	48 89 5c 24 30	 mov	 QWORD PTR expanded_format_spec$[rsp], rbx
  000e9	48 89 7c 24 38	 mov	 QWORD PTR expanded_format_spec$[rsp+8], rdi
  000ee	48 89 44 24 40	 mov	 QWORD PTR expanded_format_spec$[rsp+16], rax

; 846  :         actual_format_spec = &expanded_format_spec;

  000f3	48 8d 6c 24 30	 lea	 rbp, QWORD PTR expanded_format_spec$[rsp]
$LN13@output_mar:

; 847  :     }
; 848  :     else
; 849  :         actual_format_spec = format_spec;
; 850  : 
; 851  :     if (render_field(fieldobj, actual_format_spec, writer) == 0)

  000f8	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR writer$[rsp]
  00100	48 8b d5	 mov	 rdx, rbp
  00103	48 8b ce	 mov	 rcx, rsi
  00106	e8 00 00 00 00	 call	 render_field
  0010b	b9 01 00 00 00	 mov	 ecx, 1
  00110	85 c0		 test	 eax, eax
  00112	0f 45 f9	 cmovne	 edi, ecx
$done$142416:

; 852  :         goto done;
; 853  : 
; 854  :     result = 1;
; 855  : 
; 856  : done:
; 857  :     Py_XDECREF(fieldobj);

  00115	48 85 f6	 test	 rsi, rsi
  00118	74 65		 je	 SHORT $LN7@output_mar
  0011a	e8 00 00 00 00	 call	 _Py_PXCTX
  0011f	85 c0		 test	 eax, eax
  00121	75 5c		 jne	 SHORT $LN7@output_mar
  00123	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  00127	a8 20		 test	 al, 32			; 00000020H
  00129	75 4c		 jne	 SHORT $LN30@output_mar
  0012b	84 c0		 test	 al, al
  0012d	78 48		 js	 SHORT $LN30@output_mar
  0012f	a8 02		 test	 al, 2
  00131	75 4c		 jne	 SHORT $LN7@output_mar
  00133	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  00137	75 46		 jne	 SHORT $LN7@output_mar
  00139	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00140	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00147	4c 8b ce	 mov	 r9, rsi
  0014a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00150	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00158	e8 00 00 00 00	 call	 _PyParallel_Guard
  0015d	48 8b ce	 mov	 rcx, rsi
  00160	85 c0		 test	 eax, eax
  00162	74 07		 je	 SHORT $LN35@output_mar
  00164	e8 00 00 00 00	 call	 _Px_Dealloc
  00169	eb 14		 jmp	 SHORT $LN7@output_mar
$LN35@output_mar:
  0016b	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  0016f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00175	eb 08		 jmp	 SHORT $LN7@output_mar
$LN30@output_mar:
  00177	48 8b ce	 mov	 rcx, rsi
  0017a	e8 00 00 00 00	 call	 Px_DecRef
$LN7@output_mar:

; 858  :     Py_XDECREF(tmp);

  0017f	48 85 db	 test	 rbx, rbx
  00182	74 65		 je	 SHORT $LN54@output_mar
  00184	e8 00 00 00 00	 call	 _Py_PXCTX
  00189	85 c0		 test	 eax, eax
  0018b	75 5c		 jne	 SHORT $LN54@output_mar
  0018d	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00191	a8 20		 test	 al, 32			; 00000020H
  00193	75 4c		 jne	 SHORT $LN41@output_mar
  00195	84 c0		 test	 al, al
  00197	78 48		 js	 SHORT $LN41@output_mar
  00199	a8 02		 test	 al, 2
  0019b	75 4c		 jne	 SHORT $LN54@output_mar
  0019d	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001a1	75 46		 jne	 SHORT $LN54@output_mar
  001a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001b1	4c 8b cb	 mov	 r9, rbx
  001b4	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001ba	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001c2	e8 00 00 00 00	 call	 _PyParallel_Guard
  001c7	48 8b cb	 mov	 rcx, rbx
  001ca	85 c0		 test	 eax, eax
  001cc	74 07		 je	 SHORT $LN46@output_mar
  001ce	e8 00 00 00 00	 call	 _Px_Dealloc
  001d3	eb 14		 jmp	 SHORT $LN54@output_mar
$LN46@output_mar:
  001d5	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001d9	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001df	eb 08		 jmp	 SHORT $LN54@output_mar
$LN41@output_mar:
  001e1	48 8b cb	 mov	 rcx, rbx
  001e4	e8 00 00 00 00	 call	 Px_DecRef
$LN54@output_mar:

; 859  : 
; 860  :     return result;
; 861  : }

  001e9	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  001ee	8b c7		 mov	 eax, edi
  001f0	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  001f4	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  001f8	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  001fc	49 8b 7b 38	 mov	 rdi, QWORD PTR [r11+56]
  00200	49 8b e3	 mov	 rsp, r11
  00203	41 5e		 pop	 r14
  00205	41 5d		 pop	 r13
  00207	41 5c		 pop	 r12
  00209	c3		 ret	 0
output_markup ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_markup DD imagerel do_markup
	DD	imagerel do_markup+389
	DD	imagerel $unwind$do_markup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_markup DD 0b2101H
	DD	0223421H
	DD	0180121H
	DD	0e013f015H
	DD	0c00fd011H
	DD	0600c700dH
	DD	0500bH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT do_markup
_TEXT	SEGMENT
conversion$ = 80
field_present$ = 84
literal$ = 88
iter$ = 112
format_spec$ = 136
field_name$ = 160
format_spec_needs_expanding$ = 256
input$ = 256
args$ = 264
kwargs$ = 272
writer$ = 280
recursion_depth$ = 288
auto_number$ = 296
do_markup PROC						; COMDAT

; 872  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 8d 6c 24 e9	 lea	 rbp, QWORD PTR [rsp-23]
  0001a	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00021	49 8b d9	 mov	 rbx, r9

; 873  :     MarkupIterator iter;
; 874  :     int format_spec_needs_expanding;
; 875  :     int result;
; 876  :     int field_present;
; 877  :     SubString literal;
; 878  :     SubString field_name;
; 879  :     SubString format_spec;
; 880  :     Py_UCS4 conversion, maxchar;
; 881  :     Py_ssize_t sublen;
; 882  :     int err;
; 883  : 
; 884  :     MarkupIterator_init(&iter, input->str, input->start, input->end);

  00024	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  00028	4d 8b f8	 mov	 r15, r8
  0002b	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  0002f	4c 8b e2	 mov	 r12, rdx
  00032	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00035	48 8d 4d c7	 lea	 rcx, QWORD PTR iter$[rbp-169]
  00039	e8 00 00 00 00	 call	 MarkupIterator_init

; 885  :     while ((result = MarkupIterator_next(&iter, &literal, &field_present,
; 886  :                                          &field_name, &format_spec,
; 887  :                                          &conversion,
; 888  :                                          &format_spec_needs_expanding)) == 2) {

  0003e	48 8d 4d 57	 lea	 rcx, QWORD PTR format_spec_needs_expanding$[rbp-169]
  00042	48 8d 45 a7	 lea	 rax, QWORD PTR conversion$[rbp-169]
  00046	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0004b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00050	48 8d 45 df	 lea	 rax, QWORD PTR format_spec$[rbp-169]
  00054	4c 8d 4d f7	 lea	 r9, QWORD PTR field_name$[rbp-169]
  00058	4c 8d 45 ab	 lea	 r8, QWORD PTR field_present$[rbp-169]
  0005c	48 8d 55 af	 lea	 rdx, QWORD PTR literal$[rbp-169]
  00060	48 8d 4d c7	 lea	 rcx, QWORD PTR iter$[rbp-169]
  00064	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00069	e8 00 00 00 00	 call	 MarkupIterator_next
  0006e	83 f8 02	 cmp	 eax, 2
  00071	0f 85 f3 00 00
	00		 jne	 $LN18@do_markup
  00077	4c 8b 6d 7f	 mov	 r13, QWORD PTR auto_number$[rbp-169]
  0007b	44 8b 75 77	 mov	 r14d, DWORD PTR recursion_depth$[rbp-169]
  0007f	90		 npad	 1
$LL7@do_markup:

; 889  :         sublen = literal.end - literal.start;

  00080	4c 8b 45 bf	 mov	 r8, QWORD PTR literal$[rbp-153]
  00084	48 8b 75 b7	 mov	 rsi, QWORD PTR literal$[rbp-161]
  00088	49 8b f8	 mov	 rdi, r8
  0008b	48 2b fe	 sub	 rdi, rsi

; 890  :         if (sublen) {

  0008e	74 57		 je	 SHORT $LN5@do_markup

; 891  :             maxchar = _PyUnicode_FindMaxChar(literal.str,
; 892  :                                              literal.start, literal.end);

  00090	4c 8b 65 af	 mov	 r12, QWORD PTR literal$[rbp-169]
  00094	48 8b d6	 mov	 rdx, rsi
  00097	49 8b cc	 mov	 rcx, r12
  0009a	e8 00 00 00 00	 call	 _PyUnicode_FindMaxChar

; 893  :             err = _PyUnicodeWriter_Prepare(writer, sublen, maxchar);

  0009f	3b 43 14	 cmp	 eax, DWORD PTR [rbx+20]
  000a2	77 0d		 ja	 SHORT $LN10@do_markup
  000a4	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  000a8	48 2b 4b 20	 sub	 rcx, QWORD PTR [rbx+32]
  000ac	48 3b f9	 cmp	 rdi, rcx
  000af	7e 17		 jle	 SHORT $LN17@do_markup
$LN10@do_markup:
  000b1	44 8b c0	 mov	 r8d, eax
  000b4	48 8b d7	 mov	 rdx, rdi
  000b7	48 8b cb	 mov	 rcx, rbx
  000ba	e8 00 00 00 00	 call	 _PyUnicodeWriter_PrepareInternal

; 894  :             if (err == -1)

  000bf	83 f8 ff	 cmp	 eax, -1
  000c2	0f 84 a0 00 00
	00		 je	 $LN16@do_markup
$LN17@do_markup:

; 895  :                 return 0;
; 896  :             _PyUnicode_FastCopyCharacters(writer->buffer, writer->pos,
; 897  :                                           literal.str, literal.start, sublen);

  000c8	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  000cc	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000cf	4c 8b ce	 mov	 r9, rsi
  000d2	4d 8b c4	 mov	 r8, r12
  000d5	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  000da	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 898  :             writer->pos += sublen;

  000df	48 01 7b 20	 add	 QWORD PTR [rbx+32], rdi
  000e3	4c 8b 65 5f	 mov	 r12, QWORD PTR args$[rbp-169]
$LN5@do_markup:

; 899  :         }
; 900  : 
; 901  :         if (field_present) {

  000e7	83 7d ab 00	 cmp	 DWORD PTR field_present$[rbp-169], 0
  000eb	74 40		 je	 SHORT $LN1@do_markup

; 902  :             if (iter.str.start == iter.str.end)

  000ed	48 8b 45 d7	 mov	 rax, QWORD PTR iter$[rbp-153]
  000f1	48 39 45 cf	 cmp	 QWORD PTR iter$[rbp-161], rax
  000f5	75 04		 jne	 SHORT $LN2@do_markup

; 903  :                 writer->overallocate = 0;

  000f7	c6 43 30 00	 mov	 BYTE PTR [rbx+48], 0
$LN2@do_markup:

; 904  :             if (!output_markup(&field_name, &format_spec,
; 905  :                                format_spec_needs_expanding, conversion, writer,
; 906  :                                args, kwargs, recursion_depth, auto_number))

  000fb	44 8b 4d a7	 mov	 r9d, DWORD PTR conversion$[rbp-169]
  000ff	44 8b 45 57	 mov	 r8d, DWORD PTR format_spec_needs_expanding$[rbp-169]
  00103	4c 89 6c 24 40	 mov	 QWORD PTR [rsp+64], r13
  00108	44 89 74 24 38	 mov	 DWORD PTR [rsp+56], r14d
  0010d	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  00112	48 8d 55 df	 lea	 rdx, QWORD PTR format_spec$[rbp-169]
  00116	48 8d 4d f7	 lea	 rcx, QWORD PTR field_name$[rbp-169]
  0011a	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  0011f	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00124	e8 00 00 00 00	 call	 output_markup
  00129	85 c0		 test	 eax, eax
  0012b	74 3b		 je	 SHORT $LN16@do_markup
$LN1@do_markup:

; 885  :     while ((result = MarkupIterator_next(&iter, &literal, &field_present,
; 886  :                                          &field_name, &format_spec,
; 887  :                                          &conversion,
; 888  :                                          &format_spec_needs_expanding)) == 2) {

  0012d	48 8d 45 57	 lea	 rax, QWORD PTR format_spec_needs_expanding$[rbp-169]
  00131	4c 8d 4d f7	 lea	 r9, QWORD PTR field_name$[rbp-169]
  00135	4c 8d 45 ab	 lea	 r8, QWORD PTR field_present$[rbp-169]
  00139	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0013e	48 8d 45 a7	 lea	 rax, QWORD PTR conversion$[rbp-169]
  00142	48 8d 55 af	 lea	 rdx, QWORD PTR literal$[rbp-169]
  00146	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0014b	48 8d 45 df	 lea	 rax, QWORD PTR format_spec$[rbp-169]
  0014f	48 8d 4d c7	 lea	 rcx, QWORD PTR iter$[rbp-169]
  00153	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00158	e8 00 00 00 00	 call	 MarkupIterator_next
  0015d	83 f8 02	 cmp	 eax, 2
  00160	0f 84 1a ff ff
	ff		 je	 $LL7@do_markup
  00166	eb 02		 jmp	 SHORT $LN18@do_markup
$LN16@do_markup:

; 907  :                 return 0;

  00168	33 c0		 xor	 eax, eax
$LN18@do_markup:

; 908  :         }
; 909  :     }
; 910  :     return result;
; 911  : }

  0016a	48 8b 9c 24 10
	01 00 00	 mov	 rbx, QWORD PTR [rsp+272]
  00172	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  00179	41 5f		 pop	 r15
  0017b	41 5e		 pop	 r14
  0017d	41 5d		 pop	 r13
  0017f	41 5c		 pop	 r12
  00181	5f		 pop	 rdi
  00182	5e		 pop	 rsi
  00183	5d		 pop	 rbp
  00184	c3		 ret	 0
do_markup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@ONNACCDC@Max?5string?5recursion?5exceeded?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$build_string DD imagerel build_string
	DD	imagerel build_string+127
	DD	imagerel $unwind$build_string
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$build_string DD 010401H
	DD	0e204H
xdata	ENDS
;	COMDAT ??_C@_0BO@ONNACCDC@Max?5string?5recursion?5exceeded?$AA@
CONST	SEGMENT
??_C@_0BO@ONNACCDC@Max?5string?5recursion?5exceeded?$AA@ DB 'Max string r'
	DB	'ecursion exceeded', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT build_string
_TEXT	SEGMENT
writer$ = 48
input$ = 128
args$ = 136
kwargs$ = 144
recursion_depth$ = 152
auto_number$ = 160
build_string PROC					; COMDAT

; 921  : {

  00000	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00004	4c 8b da	 mov	 r11, rdx
  00007	4c 8b d1	 mov	 r10, rcx

; 922  :     _PyUnicodeWriter writer;
; 923  :     Py_ssize_t minlen;
; 924  : 
; 925  :     /* check the recursion level */
; 926  :     if (recursion_depth <= 0) {

  0000a	45 85 c9	 test	 r9d, r9d
  0000d	7f 1a		 jg	 SHORT $LN2@build_stri

; 927  :         PyErr_SetString(PyExc_ValueError,
; 928  :                         "Max string recursion exceeded");

  0000f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@ONNACCDC@Max?5string?5recursion?5exceeded?$AA@
  0001d	e8 00 00 00 00	 call	 PyErr_SetString

; 929  :         return NULL;

  00022	33 c0		 xor	 eax, eax

; 942  : }

  00024	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00028	c3		 ret	 0
$LN2@build_stri:

; 930  :     }
; 931  : 
; 932  :     minlen = PyUnicode_GET_LENGTH(input->str) + 100;

  00029	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 933  :     _PyUnicodeWriter_Init(&writer, minlen);

  0002c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  00031	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00035	48 83 c2 64	 add	 rdx, 100		; 00000064H
  00039	e8 00 00 00 00	 call	 _PyUnicodeWriter_Init

; 934  : 
; 935  :     if (!do_markup(input, args, kwargs, &writer, recursion_depth,
; 936  :                    auto_number)) {

  0003e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR auto_number$[rsp]
  00046	49 8b d3	 mov	 rdx, r11
  00049	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0004e	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00053	4c 8d 4c 24 30	 lea	 r9, QWORD PTR writer$[rsp]
  00058	49 8b ca	 mov	 rcx, r10
  0005b	e8 00 00 00 00	 call	 do_markup

; 937  :         _PyUnicodeWriter_Dealloc(&writer);

  00060	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  00065	85 c0		 test	 eax, eax
  00067	75 0c		 jne	 SHORT $LN1@build_stri
  00069	e8 00 00 00 00	 call	 _PyUnicodeWriter_Dealloc

; 938  :         return NULL;

  0006e	33 c0		 xor	 eax, eax

; 942  : }

  00070	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00074	c3		 ret	 0
$LN1@build_stri:

; 939  :     }
; 940  : 
; 941  :     return _PyUnicodeWriter_Finish(&writer);

  00075	e8 00 00 00 00	 call	 _PyUnicodeWriter_Finish

; 942  : }

  0007a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0007e	c3		 ret	 0
build_string ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_string_format DD imagerel do_string_format
	DD	imagerel do_string_format+139
	DD	imagerel $unwind$do_string_format
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_string_format DD 060f01H
	DD	0e640fH
	DD	0d340fH
	DD	0700b920fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT do_string_format
_TEXT	SEGMENT
input$ = 48
auto_number$ = 96
self$ = 96
args$ = 104
kwargs$ = 112
do_string_format PROC					; COMDAT

; 951  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 952  :     SubString input;
; 953  : 
; 954  :     /* PEP 3101 says only 2 levels, so that
; 955  :        "{0:{1}}".format('abc', 's')            # works
; 956  :        "{0:{1:{2}}}".format('abc', 's', '')    # fails
; 957  :     */
; 958  :     int recursion_depth = 2;
; 959  : 
; 960  :     AutoNumber auto_number;
; 961  : 
; 962  :     if (PyUnicode_READY(self) == -1)

  0000f	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00013	49 8b f8	 mov	 rdi, r8
  00016	48 8b f2	 mov	 rsi, rdx
  00019	48 8b d9	 mov	 rbx, rcx
  0001c	75 1c		 jne	 SHORT $LN1@do_string_
  0001e	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00023	83 f8 ff	 cmp	 eax, -1
  00026	75 12		 jne	 SHORT $LN1@do_string_

; 963  :         return NULL;

  00028	33 c0		 xor	 eax, eax

; 968  : }

  0002a	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  0002f	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  00034	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00038	5f		 pop	 rdi
  00039	c3		 ret	 0
$LN1@do_string_:

; 964  : 
; 965  :     AutoNumber_Init(&auto_number);

  0003a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR auto_number$[rsp]
  0003f	e8 00 00 00 00	 call	 AutoNumber_Init

; 966  :     SubString_init(&input, self, 0, PyUnicode_GET_LENGTH(self));

  00044	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]

; 967  :     return build_string(&input, args, kwargs, recursion_depth, &auto_number);

  00048	48 8d 4c 24 30	 lea	 rcx, QWORD PTR input$[rsp]
  0004d	48 89 44 24 40	 mov	 QWORD PTR input$[rsp+16], rax
  00052	48 8d 44 24 60	 lea	 rax, QWORD PTR auto_number$[rsp]
  00057	41 b9 02 00 00
	00		 mov	 r9d, 2
  0005d	4c 8b c7	 mov	 r8, rdi
  00060	48 8b d6	 mov	 rdx, rsi
  00063	48 89 5c 24 30	 mov	 QWORD PTR input$[rsp], rbx
  00068	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR input$[rsp+8], 0
  00076	e8 00 00 00 00	 call	 build_string

; 968  : }

  0007b	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  00080	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  00085	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00089	5f		 pop	 rdi
  0008a	c3		 ret	 0
do_string_format ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT do_string_format_map
_TEXT	SEGMENT
self$ = 8
obj$ = 16
do_string_format_map PROC				; COMDAT

; 973  :     return do_string_format(self, NULL, obj);

  00000	4c 8b c2	 mov	 r8, rdx
  00003	33 d2		 xor	 edx, edx

; 974  : }

  00005	e9 00 00 00 00	 jmp	 do_string_format
do_string_format_map ENDP
_TEXT	ENDS
EXTRN	PyTuple_Pack:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$formatteriter_next DD imagerel formatteriter_next
	DD	imagerel formatteriter_next+80
	DD	imagerel $unwind$formatteriter_next
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$formatteriter_next DD imagerel formatteriter_next+80
	DD	imagerel formatteriter_next+234
	DD	imagerel $chain$3$formatteriter_next
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$formatteriter_next DD imagerel formatteriter_next+234
	DD	imagerel formatteriter_next+514
	DD	imagerel $chain$4$formatteriter_next
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$formatteriter_next DD imagerel formatteriter_next+514
	DD	imagerel formatteriter_next+578
	DD	imagerel $chain$5$formatteriter_next
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$formatteriter_next DD imagerel formatteriter_next+578
	DD	imagerel formatteriter_next+588
	DD	imagerel $chain$6$formatteriter_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$formatteriter_next DD 021H
	DD	imagerel formatteriter_next
	DD	imagerel formatteriter_next+80
	DD	imagerel $unwind$formatteriter_next
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$formatteriter_next DD 021H
	DD	imagerel formatteriter_next+80
	DD	imagerel formatteriter_next+234
	DD	imagerel $chain$3$formatteriter_next
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$formatteriter_next DD 020821H
	DD	0137408H
	DD	imagerel formatteriter_next+80
	DD	imagerel formatteriter_next+234
	DD	imagerel $chain$3$formatteriter_next
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$formatteriter_next DD 082221H
	DD	012c422H
	DD	014641aH
	DD	0155412H
	DD	0163408H
	DD	imagerel formatteriter_next
	DD	imagerel formatteriter_next+80
	DD	imagerel $unwind$formatteriter_next
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$formatteriter_next DD 020a01H
	DD	017010aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\unicode_format.h
xdata	ENDS
;	COMDAT formatteriter_next
_TEXT	SEGMENT
literal$ = 64
field_name$ = 88
format_spec$ = 112
conversion$ = 192
it$ = 192
field_present$ = 200
formatteriter_next PROC					; COMDAT

; 1009 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1010 :     SubString literal;
; 1011 :     SubString field_name;
; 1012 :     SubString format_spec;
; 1013 :     Py_UCS4 conversion;
; 1014 :     int format_spec_needs_expanding;
; 1015 :     int field_present;
; 1016 :     int result = MarkupIterator_next(&it->it_markup, &literal, &field_present,
; 1017 :                                      &field_name, &format_spec, &conversion,
; 1018 :                                      &format_spec_needs_expanding);

  0000a	49 8d 43 18	 lea	 rax, QWORD PTR [r11+24]
  0000e	4d 8d 4b a0	 lea	 r9, QWORD PTR [r11-96]
  00012	4d 8d 43 10	 lea	 r8, QWORD PTR [r11+16]
  00016	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0001b	49 8d 43 08	 lea	 rax, QWORD PTR [r11+8]
  0001f	49 8d 53 88	 lea	 rdx, QWORD PTR [r11-120]
  00023	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00028	49 8d 43 b8	 lea	 rax, QWORD PTR [r11-72]
  0002c	48 83 c1 68	 add	 rcx, 104		; 00000068H
  00030	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00035	e8 00 00 00 00	 call	 MarkupIterator_next

; 1019 : 
; 1020 :     /* all of the SubString objects point into it->str, so no
; 1021 :        memory management needs to be done on them */
; 1022 :     assert(0 <= result && result <= 2);
; 1023 :     if (result == 0 || result == 1)

  0003a	85 c0		 test	 eax, eax
  0003c	0f 84 00 02 00
	00		 je	 $LN24@formatteri@2
  00042	83 f8 01	 cmp	 eax, 1
  00045	0f 84 f7 01 00
	00		 je	 $LN24@formatteri@2

; 1026 :     else {
; 1027 :         PyObject *literal_str = NULL;
; 1028 :         PyObject *field_name_str = NULL;
; 1029 :         PyObject *format_spec_str = NULL;
; 1030 :         PyObject *conversion_str = NULL;
; 1031 :         PyObject *tuple = NULL;
; 1032 : 
; 1033 :         literal_str = SubString_new_object(&literal);

  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR literal$[rsp]
  00050	48 89 9c 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rbx
  00058	33 db		 xor	 ebx, ebx
  0005a	48 89 ac 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rbp
  00062	48 89 b4 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rsi
  0006a	4c 89 a4 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], r12
  00072	8b f3		 mov	 esi, ebx
  00074	44 8b e3	 mov	 r12d, ebx
  00077	48 85 c9	 test	 rcx, rcx
  0007a	75 4e		 jne	 SHORT $LN28@formatteri@2
  0007c	e8 00 00 00 00	 call	 _Py_PXCTX
  00081	85 c0		 test	 eax, eax
  00083	75 3c		 jne	 SHORT $LN32@formatteri@2
  00085	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0009a	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ad	85 c0		 test	 eax, eax
  000af	75 09		 jne	 SHORT $LN31@formatteri@2
  000b1	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000b8	74 07		 je	 SHORT $LN32@formatteri@2
$LN31@formatteri@2:
  000ba	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN32@formatteri@2:
  000c1	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:_Py_NoneStruct
  000c8	eb 1b		 jmp	 SHORT $LN42@formatteri@2
$LN28@formatteri@2:
  000ca	4c 8b 44 24 50	 mov	 r8, QWORD PTR literal$[rsp+16]
  000cf	48 8b 54 24 48	 mov	 rdx, QWORD PTR literal$[rsp+8]
  000d4	e8 00 00 00 00	 call	 PyUnicode_Substring
  000d9	48 8b e8	 mov	 rbp, rax

; 1034 :         if (literal_str == NULL)

  000dc	48 85 c0	 test	 rax, rax
  000df	0f 84 32 01 00
	00		 je	 $LN3@formatteri@2
$LN42@formatteri@2:

; 1035 :             goto done;
; 1036 : 
; 1037 :         field_name_str = SubString_new_object(&field_name);

  000e5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR field_name$[rsp]
  000ea	48 89 bc 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rdi
  000f2	48 85 c9	 test	 rcx, rcx
  000f5	75 4e		 jne	 SHORT $LN35@formatteri@2
  000f7	e8 00 00 00 00	 call	 _Py_PXCTX
  000fc	85 c0		 test	 eax, eax
  000fe	75 3c		 jne	 SHORT $LN39@formatteri@2
  00100	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00107	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00115	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0011b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00123	e8 00 00 00 00	 call	 _PyParallel_Guard
  00128	85 c0		 test	 eax, eax
  0012a	75 09		 jne	 SHORT $LN38@formatteri@2
  0012c	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00133	74 07		 je	 SHORT $LN39@formatteri@2
$LN38@formatteri@2:
  00135	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN39@formatteri@2:
  0013c	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  00143	eb 1b		 jmp	 SHORT $LN43@formatteri@2
$LN35@formatteri@2:
  00145	4c 8b 44 24 68	 mov	 r8, QWORD PTR field_name$[rsp+16]
  0014a	48 8b 54 24 60	 mov	 rdx, QWORD PTR field_name$[rsp+8]
  0014f	e8 00 00 00 00	 call	 PyUnicode_Substring
  00154	48 8b f8	 mov	 rdi, rax

; 1038 :         if (field_name_str == NULL)

  00157	48 85 c0	 test	 rax, rax
  0015a	0f 84 80 00 00
	00		 je	 $done$142567
$LN43@formatteri@2:

; 1039 :             goto done;
; 1040 : 
; 1041 :         /* if field_name is non-zero length, return a string for
; 1042 :            format_spec (even if zero length), else return None */
; 1043 :         format_spec_str = (field_present ?
; 1044 :                            SubString_new_object_or_empty :
; 1045 :                            SubString_new_object)(&format_spec);

  00160	39 9c 24 c8 00
	00 00		 cmp	 DWORD PTR field_present$[rsp], ebx
  00167	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:SubString_new_object_or_empty
  0016e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:SubString_new_object
  00175	48 8d 4c 24 70	 lea	 rcx, QWORD PTR format_spec$[rsp]
  0017a	48 0f 45 d0	 cmovne	 rdx, rax
  0017e	ff d2		 call	 rdx
  00180	48 8b d8	 mov	 rbx, rax

; 1046 :         if (format_spec_str == NULL)

  00183	48 85 c0	 test	 rax, rax
  00186	74 58		 je	 SHORT $done$142567

; 1047 :             goto done;
; 1048 : 
; 1049 :         /* if the conversion is not specified, return a None,
; 1050 :            otherwise create a one length string with the conversion
; 1051 :            character */
; 1052 :         if (conversion == '\0') {

  00188	39 b4 24 c0 00
	00 00		 cmp	 DWORD PTR conversion$[rsp], esi
  0018f	75 15		 jne	 SHORT $LN19@formatteri@2

; 1053 :             conversion_str = Py_None;
; 1054 :             Py_INCREF(conversion_str);

  00191	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00198	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  0019f	e8 00 00 00 00	 call	 _Py_IncRef

; 1055 :         }
; 1056 :         else

  001a4	eb 1f		 jmp	 SHORT $LN44@formatteri@2
$LN19@formatteri@2:

; 1057 :             conversion_str = PyUnicode_FromKindAndData(PyUnicode_4BYTE_KIND,
; 1058 :                                                        &conversion, 1);

  001a6	41 b8 01 00 00
	00		 mov	 r8d, 1
  001ac	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR conversion$[rsp]
  001b4	41 8d 48 03	 lea	 ecx, QWORD PTR [r8+3]
  001b8	e8 00 00 00 00	 call	 PyUnicode_FromKindAndData
  001bd	48 8b f0	 mov	 rsi, rax

; 1059 :         if (conversion_str == NULL)

  001c0	48 85 c0	 test	 rax, rax
  001c3	74 1b		 je	 SHORT $done$142567
$LN44@formatteri@2:

; 1060 :             goto done;
; 1061 : 
; 1062 :         tuple = PyTuple_Pack(4, literal_str, field_name_str, format_spec_str,
; 1063 :                              conversion_str);

  001c5	4c 8b cb	 mov	 r9, rbx
  001c8	4c 8b c7	 mov	 r8, rdi
  001cb	48 8b d5	 mov	 rdx, rbp
  001ce	b9 04 00 00 00	 mov	 ecx, 4
  001d3	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  001d8	e8 00 00 00 00	 call	 PyTuple_Pack
  001dd	4c 8b e0	 mov	 r12, rax
$done$142567:

; 1064 :     done:
; 1065 :         Py_XDECREF(literal_str);

  001e0	48 8b cd	 mov	 rcx, rbp
  001e3	e8 00 00 00 00	 call	 _Py_DecRef

; 1066 :         Py_XDECREF(field_name_str);

  001e8	48 85 ff	 test	 rdi, rdi
  001eb	74 08		 je	 SHORT $LN11@formatteri@2
  001ed	48 8b cf	 mov	 rcx, rdi
  001f0	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@formatteri@2:

; 1067 :         Py_XDECREF(format_spec_str);

  001f5	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR [rsp+152]
  001fd	48 85 db	 test	 rbx, rbx
  00200	74 08		 je	 SHORT $LN7@formatteri@2
  00202	48 8b cb	 mov	 rcx, rbx
  00205	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@formatteri@2:

; 1068 :         Py_XDECREF(conversion_str);

  0020a	48 85 f6	 test	 rsi, rsi
  0020d	74 08		 je	 SHORT $LN3@formatteri@2
  0020f	48 8b ce	 mov	 rcx, rsi
  00212	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@formatteri@2:

; 1069 :         return tuple;

  00217	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+160]
  0021f	48 8b ac 24 a8
	00 00 00	 mov	 rbp, QWORD PTR [rsp+168]
  00227	48 8b 9c 24 b0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+176]
  0022f	49 8b c4	 mov	 rax, r12
  00232	4c 8b a4 24 90
	00 00 00	 mov	 r12, QWORD PTR [rsp+144]

; 1070 :     }
; 1071 : }

  0023a	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00241	c3		 ret	 0
$LN24@formatteri@2:

; 1024 :         /* if 0, error has already been set, if 1, iterator is empty */
; 1025 :         return NULL;

  00242	33 c0		 xor	 eax, eax

; 1070 :     }
; 1071 : }

  00244	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0024b	c3		 ret	 0
formatteriter_next ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fieldnameiter_next DD imagerel fieldnameiter_next
	DD	imagerel fieldnameiter_next+49
	DD	imagerel $unwind$fieldnameiter_next
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$fieldnameiter_next DD imagerel fieldnameiter_next+49
	DD	imagerel fieldnameiter_next+79
	DD	imagerel $chain$1$fieldnameiter_next
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$fieldnameiter_next DD imagerel fieldnameiter_next+79
	DD	imagerel fieldnameiter_next+160
	DD	imagerel $chain$2$fieldnameiter_next
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$fieldnameiter_next DD imagerel fieldnameiter_next+160
	DD	imagerel fieldnameiter_next+178
	DD	imagerel $chain$3$fieldnameiter_next
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$fieldnameiter_next DD imagerel fieldnameiter_next+178
	DD	imagerel fieldnameiter_next+185
	DD	imagerel $chain$4$fieldnameiter_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$fieldnameiter_next DD 021H
	DD	imagerel fieldnameiter_next
	DD	imagerel fieldnameiter_next+49
	DD	imagerel $unwind$fieldnameiter_next
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$fieldnameiter_next DD 021H
	DD	imagerel fieldnameiter_next+49
	DD	imagerel fieldnameiter_next+79
	DD	imagerel $chain$1$fieldnameiter_next
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$fieldnameiter_next DD 020521H
	DD	0c3405H
	DD	imagerel fieldnameiter_next+49
	DD	imagerel fieldnameiter_next+79
	DD	imagerel $chain$1$fieldnameiter_next
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$fieldnameiter_next DD 040a21H
	DD	08740aH
	DD	0d6405H
	DD	imagerel fieldnameiter_next
	DD	imagerel fieldnameiter_next+49
	DD	imagerel $unwind$fieldnameiter_next
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fieldnameiter_next DD 010401H
	DD	08204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT fieldnameiter_next
_TEXT	SEGMENT
name$ = 32
is_attr$ = 80
it$ = 80
idx$ = 88
fieldnameiter_next PROC					; COMDAT

; 1171 : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1172 :     int result;
; 1173 :     int is_attr;
; 1174 :     Py_ssize_t idx;
; 1175 :     SubString name;
; 1176 : 
; 1177 :     result = FieldNameIterator_next(&it->it_field, &is_attr,
; 1178 :                                     &idx, &name);

  00004	4c 8d 4c 24 20	 lea	 r9, QWORD PTR name$[rsp]
  00009	4c 8d 44 24 58	 lea	 r8, QWORD PTR idx$[rsp]
  0000e	48 8d 54 24 50	 lea	 rdx, QWORD PTR is_attr$[rsp]
  00013	48 83 c1 68	 add	 rcx, 104		; 00000068H
  00017	e8 00 00 00 00	 call	 FieldNameIterator_next

; 1179 :     if (result == 0 || result == 1)

  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 8e 00 00
	00		 je	 $LN14@fieldnamei@2
  00024	83 f8 01	 cmp	 eax, 1
  00027	0f 84 85 00 00
	00		 je	 $LN14@fieldnamei@2

; 1182 :     else {
; 1183 :         PyObject* result = NULL;
; 1184 :         PyObject* is_attr_obj = NULL;
; 1185 :         PyObject* obj = NULL;
; 1186 : 
; 1187 :         is_attr_obj = PyBool_FromLong(is_attr);

  0002d	8b 4c 24 50	 mov	 ecx, DWORD PTR is_attr$[rsp]
  00031	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  00036	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0003b	33 f6		 xor	 esi, esi
  0003d	e8 00 00 00 00	 call	 PyBool_FromLong
  00042	48 8b f8	 mov	 rdi, rax

; 1188 :         if (is_attr_obj == NULL)

  00045	48 85 c0	 test	 rax, rax
  00048	74 56		 je	 SHORT $LN3@fieldnamei@2

; 1189 :             goto done;
; 1190 : 
; 1191 :         /* either an integer or a string */
; 1192 :         if (idx != -1)

  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR idx$[rsp]
  0004f	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00054	48 83 f9 ff	 cmp	 rcx, -1
  00058	74 07		 je	 SHORT $LN11@fieldnamei@2

; 1193 :             obj = PyLong_FromSsize_t(idx);

  0005a	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 1194 :         else

  0005f	eb 0a		 jmp	 SHORT $LN19@fieldnamei@2
$LN11@fieldnamei@2:

; 1195 :             obj = SubString_new_object(&name);

  00061	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  00066	e8 00 00 00 00	 call	 SubString_new_object
$LN19@fieldnamei@2:
  0006b	48 8b d8	 mov	 rbx, rax

; 1196 :         if (obj == NULL)

  0006e	48 85 c0	 test	 rax, rax
  00071	74 13		 je	 SHORT $done$142678

; 1197 :             goto done;
; 1198 : 
; 1199 :         /* return a tuple of values */
; 1200 :         result = PyTuple_Pack(2, is_attr_obj, obj);

  00073	4c 8b c0	 mov	 r8, rax
  00076	48 8b d7	 mov	 rdx, rdi
  00079	b9 02 00 00 00	 mov	 ecx, 2
  0007e	e8 00 00 00 00	 call	 PyTuple_Pack
  00083	48 8b f0	 mov	 rsi, rax
$done$142678:

; 1201 : 
; 1202 :     done:
; 1203 :         Py_XDECREF(is_attr_obj);

  00086	48 8b cf	 mov	 rcx, rdi
  00089	e8 00 00 00 00	 call	 _Py_DecRef

; 1204 :         Py_XDECREF(obj);

  0008e	48 85 db	 test	 rbx, rbx
  00091	74 08		 je	 SHORT $LN18@fieldnamei@2
  00093	48 8b cb	 mov	 rcx, rbx
  00096	e8 00 00 00 00	 call	 _Py_DecRef
$LN18@fieldnamei@2:
  0009b	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
$LN3@fieldnamei@2:
  000a0	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 1205 :         return result;

  000a5	48 8b c6	 mov	 rax, rsi
  000a8	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]

; 1206 :     }
; 1207 : }

  000ad	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b1	c3		 ret	 0
$LN14@fieldnamei@2:

; 1180 :         /* if 0, error has already been set, if 1, iterator is empty */
; 1181 :         return NULL;

  000b2	33 c0		 xor	 eax, eax

; 1206 :     }
; 1207 : }

  000b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b8	c3		 ret	 0
fieldnameiter_next ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$formatter_field_name_split DD imagerel formatter_field_name_split
	DD	imagerel formatter_field_name_split+307
	DD	imagerel $unwind$formatter_field_name_split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$formatter_field_name_split DD 086a01H
	DD	0e746aH
	DD	011540fH
	DD	010340fH
	DD	0600bb20fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT formatter_field_name_split
_TEXT	SEGMENT
first$ = 64
ignored$ = 112
first_idx$ = 120
self$ = 120
formatter_field_name_split PROC				; COMDAT

; 1254 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 1255 :     SubString first;
; 1256 :     Py_ssize_t first_idx;
; 1257 :     fieldnameiterobject *it;
; 1258 : 
; 1259 :     PyObject *first_obj = NULL;
; 1260 :     PyObject *result = NULL;
; 1261 : 
; 1262 :     if (!PyUnicode_Check(self)) {

  0000f	4c 8b 42 58	 mov	 r8, QWORD PTR [rdx+88]
  00013	33 db		 xor	 ebx, ebx
  00015	48 8b f2	 mov	 rsi, rdx
  00018	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  00023	8b eb		 mov	 ebp, ebx
  00025	75 2b		 jne	 SHORT $LN15@formatter_@2

; 1263 :         PyErr_Format(PyExc_TypeError, "expected str, got %s", Py_TYPE(self)->tp_name);

  00027	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@FGOOKPBC@expected?5str?0?5got?5?$CFs?$AA@
  00039	e8 00 00 00 00	 call	 PyErr_Format
$LN25@formatter_@2:

; 1264 :         return NULL;

  0003e	33 c0		 xor	 eax, eax

; 1301 : }

  00040	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  00045	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  00049	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  0004d	49 8b e3	 mov	 rsp, r11
  00050	5e		 pop	 rsi
  00051	c3		 ret	 0
$LN15@formatter_@2:

; 1265 :     }
; 1266 : 
; 1267 :     if (PyUnicode_READY(self) == -1)

  00052	f6 42 70 80	 test	 BYTE PTR [rdx+112], 128	; 00000080H
  00056	75 0d		 jne	 SHORT $LN14@formatter_@2
  00058	48 8b ca	 mov	 rcx, rdx
  0005b	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00060	83 f8 ff	 cmp	 eax, -1

; 1268 :         return NULL;

  00063	74 d9		 je	 SHORT $LN25@formatter_@2
$LN14@formatter_@2:
  00065	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi

; 1269 : 
; 1270 :     it = PyObject_New(fieldnameiterobject, &PyFieldNameIter_Type);

  0006a	e8 00 00 00 00	 call	 _Py_PXCTX
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFieldNameIter_Type
  00076	85 c0		 test	 eax, eax
  00078	74 07		 je	 SHORT $LN20@formatter_@2
  0007a	e8 00 00 00 00	 call	 _PxObject_New
  0007f	eb 05		 jmp	 SHORT $LN23@formatter_@2
$LN20@formatter_@2:
  00081	e8 00 00 00 00	 call	 _PyObject_New
$LN23@formatter_@2:
  00086	48 8b f8	 mov	 rdi, rax

; 1271 :     if (it == NULL)

  00089	48 85 c0	 test	 rax, rax
  0008c	0f 84 8a 00 00
	00		 je	 $LN22@formatter_@2
$LN13@formatter_@2:

; 1272 :         return NULL;
; 1273 : 
; 1274 :     /* take ownership, give the object to the iterator.  this is
; 1275 :        just to keep the field_name alive */
; 1276 :     Py_INCREF(self);

  00092	48 8b ce	 mov	 rcx, rsi
  00095	e8 00 00 00 00	 call	 _Py_IncRef

; 1277 :     it->str = self;
; 1278 : 
; 1279 :     /* Pass in auto_number = NULL. We'll return an empty string for
; 1280 :        first_obj in that case. */
; 1281 :     if (!field_name_split((PyObject*)self, 0, PyUnicode_GET_LENGTH(self),
; 1282 :                           &first, &first_idx, &it->it_field, NULL))

  0009a	48 8d 47 68	 lea	 rax, QWORD PTR [rdi+104]
  0009e	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  000a3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000a8	48 89 77 60	 mov	 QWORD PTR [rdi+96], rsi
  000ac	4c 8b 46 60	 mov	 r8, QWORD PTR [rsi+96]
  000b0	48 8d 44 24 78	 lea	 rax, QWORD PTR first_idx$[rsp]
  000b5	4c 8d 4c 24 40	 lea	 r9, QWORD PTR first$[rsp]
  000ba	33 d2		 xor	 edx, edx
  000bc	48 8b ce	 mov	 rcx, rsi
  000bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c4	e8 00 00 00 00	 call	 field_name_split
  000c9	85 c0		 test	 eax, eax
  000cb	74 37		 je	 SHORT $done$142746

; 1283 :         goto done;
; 1284 : 
; 1285 :     /* first becomes an integer, if possible; else a string */
; 1286 :     if (first_idx != -1)

  000cd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR first_idx$[rsp]
  000d2	48 83 f9 ff	 cmp	 rcx, -1
  000d6	74 07		 je	 SHORT $LN11@formatter_@2

; 1287 :         first_obj = PyLong_FromSsize_t(first_idx);

  000d8	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 1288 :     else

  000dd	eb 0a		 jmp	 SHORT $LN24@formatter_@2
$LN11@formatter_@2:

; 1289 :         /* convert "first" into a string object */
; 1290 :         first_obj = SubString_new_object(&first);

  000df	48 8d 4c 24 40	 lea	 rcx, QWORD PTR first$[rsp]
  000e4	e8 00 00 00 00	 call	 SubString_new_object
$LN24@formatter_@2:
  000e9	48 8b d8	 mov	 rbx, rax

; 1291 :     if (first_obj == NULL)

  000ec	48 85 c0	 test	 rax, rax
  000ef	74 13		 je	 SHORT $done$142746

; 1292 :         goto done;
; 1293 : 
; 1294 :     /* return a tuple of values */
; 1295 :     result = PyTuple_Pack(2, first_obj, it);

  000f1	4c 8b c7	 mov	 r8, rdi
  000f4	48 8b d0	 mov	 rdx, rax
  000f7	b9 02 00 00 00	 mov	 ecx, 2
  000fc	e8 00 00 00 00	 call	 PyTuple_Pack
  00101	48 8b e8	 mov	 rbp, rax
$done$142746:

; 1296 : 
; 1297 : done:
; 1298 :     Py_XDECREF(it);

  00104	48 8b cf	 mov	 rcx, rdi
  00107	e8 00 00 00 00	 call	 _Py_DecRef

; 1299 :     Py_XDECREF(first_obj);

  0010c	48 85 db	 test	 rbx, rbx
  0010f	74 08		 je	 SHORT $LN3@formatter_@2
  00111	48 8b cb	 mov	 rcx, rbx
  00114	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@formatter_@2:

; 1300 :     return result;

  00119	48 8b c5	 mov	 rax, rbp
$LN22@formatter_@2:
  0011c	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]

; 1301 : }

  00121	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  00126	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  0012a	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  0012e	49 8b e3	 mov	 rsp, r11
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
formatter_field_name_split ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@EKIKMBMC@U?3__format__?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\objects\unicodeobject.c
pdata	SEGMENT
$pdata$unicode__format__ DD imagerel unicode__format__
	DD	imagerel unicode__format__+137
	DD	imagerel $unwind$unicode__format__
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode__format__ DD 020601H
	DD	03002d206H
xdata	ENDS
;	COMDAT ??_C@_0N@EKIKMBMC@U?3__format__?$AA@
CONST	SEGMENT
??_C@_0N@EKIKMBMC@U?3__format__?$AA@ DB 'U:__format__', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode__format__
_TEXT	SEGMENT
writer$ = 48
self$ = 128
args$ = 136
format_spec$ = 144
unicode__format__ PROC					; COMDAT

; 13064: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 13065:     PyObject *format_spec;
; 13066:     _PyUnicodeWriter writer;
; 13067:     int ret;
; 13068: 
; 13069:     if (!PyArg_ParseTuple(args, "U:__format__", &format_spec))

  0000c	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR format_spec$[rsp]
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@EKIKMBMC@U?3__format__?$AA@
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00023	85 c0		 test	 eax, eax

; 13070:         return NULL;

  00025	74 4f		 je	 SHORT $LN8@unicode__f

; 13071: 
; 13072:     if (PyUnicode_READY(self) == -1)

  00027	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  0002b	75 0d		 jne	 SHORT $LN2@unicode__f
  0002d	48 8b cb	 mov	 rcx, rbx
  00030	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00035	83 f8 ff	 cmp	 eax, -1

; 13073:         return NULL;

  00038	74 3c		 je	 SHORT $LN8@unicode__f
$LN2@unicode__f:

; 13074:     _PyUnicodeWriter_Init(&writer, 0);

  0003a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  0003f	33 d2		 xor	 edx, edx
  00041	e8 00 00 00 00	 call	 _PyUnicodeWriter_Init

; 13075:     ret = _PyUnicode_FormatAdvancedWriter(&writer,
; 13076:                                           self, format_spec, 0,
; 13077:                                           PyUnicode_GET_LENGTH(format_spec));

  00046	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR format_spec$[rsp]
  0004e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  00053	49 8b 40 60	 mov	 rax, QWORD PTR [r8+96]
  00057	45 33 c9	 xor	 r9d, r9d
  0005a	48 8b d3	 mov	 rdx, rbx
  0005d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00062	e8 00 00 00 00	 call	 _PyUnicode_FormatAdvancedWriter

; 13078:     if (ret == -1) {
; 13079:         _PyUnicodeWriter_Dealloc(&writer);

  00067	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  0006c	83 f8 ff	 cmp	 eax, -1
  0006f	75 0d		 jne	 SHORT $LN1@unicode__f
  00071	e8 00 00 00 00	 call	 _PyUnicodeWriter_Dealloc
$LN8@unicode__f:

; 13080:         return NULL;

  00076	33 c0		 xor	 eax, eax

; 13083: }

  00078	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0007c	5b		 pop	 rbx
  0007d	c3		 ret	 0
$LN1@unicode__f:

; 13081:     }
; 13082:     return _PyUnicodeWriter_Finish(&writer);

  0007e	e8 00 00 00 00	 call	 _PyUnicodeWriter_Finish

; 13083: }

  00083	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00087	5b		 pop	 rbx
  00088	c3		 ret	 0
unicode__format__ ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@FNFMAOLL@string?5indices?5must?5be?5integers?$AA@ ; `string'
EXTRN	PySlice_GetIndicesEx:PROC
EXTRN	PySlice_Type:BYTE
EXTRN	PyNumber_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_subscript DD imagerel unicode_subscript
	DD	imagerel unicode_subscript+340
	DD	imagerel $unwind$unicode_subscript
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$unicode_subscript DD imagerel unicode_subscript+340
	DD	imagerel unicode_subscript+391
	DD	imagerel $chain$1$unicode_subscript
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$unicode_subscript DD imagerel unicode_subscript+391
	DD	imagerel unicode_subscript+550
	DD	imagerel $chain$4$unicode_subscript
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$unicode_subscript DD imagerel unicode_subscript+550
	DD	imagerel unicode_subscript+560
	DD	imagerel $chain$5$unicode_subscript
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$unicode_subscript DD imagerel unicode_subscript+560
	DD	imagerel unicode_subscript+567
	DD	imagerel $chain$6$unicode_subscript
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$unicode_subscript DD imagerel unicode_subscript+567
	DD	imagerel unicode_subscript+731
	DD	imagerel $chain$7$unicode_subscript
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$unicode_subscript DD imagerel unicode_subscript+731
	DD	imagerel unicode_subscript+759
	DD	imagerel $chain$8$unicode_subscript
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$unicode_subscript DD 021H
	DD	imagerel unicode_subscript
	DD	imagerel unicode_subscript+340
	DD	imagerel $unwind$unicode_subscript
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$unicode_subscript DD 040021H
	DD	0b6400H
	DD	0c5400H
	DD	imagerel unicode_subscript
	DD	imagerel unicode_subscript+340
	DD	imagerel $unwind$unicode_subscript
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$unicode_subscript DD 021H
	DD	imagerel unicode_subscript
	DD	imagerel unicode_subscript+340
	DD	imagerel $unwind$unicode_subscript
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$unicode_subscript DD 021H
	DD	imagerel unicode_subscript+340
	DD	imagerel unicode_subscript+391
	DD	imagerel $chain$1$unicode_subscript
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$unicode_subscript DD 061121H
	DD	08e411H
	DD	09d40cH
	DD	0ac405H
	DD	imagerel unicode_subscript+340
	DD	imagerel unicode_subscript+391
	DD	imagerel $chain$1$unicode_subscript
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$unicode_subscript DD 040a21H
	DD	0b640aH
	DD	0c5405H
	DD	imagerel unicode_subscript
	DD	imagerel unicode_subscript+340
	DD	imagerel $unwind$unicode_subscript
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_subscript DD 030701H
	DD	07003c207H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_0CA@FNFMAOLL@string?5indices?5must?5be?5integers?$AA@
CONST	SEGMENT
??_C@_0CA@FNFMAOLL@string?5indices?5must?5be?5integers?$AA@ DB 'string in'
	DB	'dices must be integers', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_subscript
_TEXT	SEGMENT
stop$142997 = 48
step$142998 = 128
self$ = 128
item$ = 136
slicelength$142999 = 144
start$142996 = 152
unicode_subscript PROC					; COMDAT

; 13217: {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 13218:     if (PyUnicode_READY(self) == -1)

  00007	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000b	48 8b fa	 mov	 rdi, rdx
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	75 0a		 jne	 SHORT $LN41@unicode_su
  00013	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00018	83 f8 ff	 cmp	 eax, -1

; 13219:         return NULL;

  0001b	74 3c		 je	 SHORT $LN72@unicode_su
$LN41@unicode_su:

; 13220: 
; 13221:     if (PyIndex_Check(item)) {

  0001d	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00021	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00028	48 85 c0	 test	 rax, rax
  0002b	74 4f		 je	 SHORT $LN40@unicode_su
  0002d	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  00035	74 45		 je	 SHORT $LN40@unicode_su

; 13222:         Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);

  00037	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  0003e	48 8b cf	 mov	 rcx, rdi
  00041	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00046	48 8b f8	 mov	 rdi, rax

; 13223:         if (i == -1 && PyErr_Occurred())

  00049	48 83 f8 ff	 cmp	 rax, -1
  0004d	75 13		 jne	 SHORT $LN39@unicode_su
  0004f	e8 00 00 00 00	 call	 PyErr_Occurred
  00054	48 85 c0	 test	 rax, rax
  00057	74 0e		 je	 SHORT $LN67@unicode_su
$LN72@unicode_su:

; 13224:             return NULL;

  00059	33 c0		 xor	 eax, eax

; 13281:     }
; 13282: }

  0005b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0005f	5f		 pop	 rdi
  00060	5b		 pop	 rbx
  00061	c3		 ret	 0
$LN39@unicode_su:

; 13225:         if (i < 0)

  00062	48 85 c0	 test	 rax, rax
  00065	79 04		 jns	 SHORT $LN38@unicode_su
$LN67@unicode_su:

; 13226:             i += PyUnicode_GET_LENGTH(self);

  00067	48 03 7b 60	 add	 rdi, QWORD PTR [rbx+96]
$LN38@unicode_su:

; 13227:         return unicode_getitem(self, i);

  0006b	48 8b d7	 mov	 rdx, rdi
  0006e	48 8b cb	 mov	 rcx, rbx

; 13281:     }
; 13282: }

  00071	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00075	5f		 pop	 rdi
  00076	5b		 pop	 rbx
  00077	e9 00 00 00 00	 jmp	 unicode_getitem
$LN40@unicode_su:

; 13228:     } else if (PySlice_Check(item)) {

  0007c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  00083	48 3b c8	 cmp	 rcx, rax
  00086	0f 85 4f 02 00
	00		 jne	 $LN36@unicode_su

; 13229:         Py_ssize_t start, stop, step, slicelength, cur, i;
; 13230:         PyObject *result;
; 13231:         void *src_data, *dest_data;
; 13232:         int src_kind, dest_kind;
; 13233:         Py_UCS4 ch, max_char, kind_limit;
; 13234: 
; 13235:         if (PySlice_GetIndicesEx(item, PyUnicode_GET_LENGTH(self),
; 13236:                                  &start, &stop, &step, &slicelength) < 0) {

  0008c	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  00090	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR slicelength$142999[rsp]
  00098	4c 8d 4c 24 30	 lea	 r9, QWORD PTR stop$142997[rsp]
  0009d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000a2	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR step$142998[rsp]
  000aa	4c 8d 84 24 98
	00 00 00	 lea	 r8, QWORD PTR start$142996[rsp]
  000b2	48 8b cf	 mov	 rcx, rdi
  000b5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ba	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  000bf	85 c0		 test	 eax, eax

; 13237:             return NULL;

  000c1	78 96		 js	 SHORT $LN72@unicode_su

; 13238:         }
; 13239: 
; 13240:         if (slicelength <= 0) {

  000c3	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR slicelength$142999[rsp]
  000cb	4d 85 c0	 test	 r8, r8
  000ce	7f 39		 jg	 SHORT $LN34@unicode_su

; 13241:             _Py_RETURN_UNICODE_EMPTY();

  000d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  000d7	48 85 c9	 test	 rcx, rcx
  000da	75 1a		 jne	 SHORT $LN71@unicode_su
  000dc	33 d2		 xor	 edx, edx
  000de	e8 00 00 00 00	 call	 PyUnicode_New
  000e3	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  000ea	48 85 c0	 test	 rax, rax
  000ed	0f 84 3d 01 00
	00		 je	 $LN1@unicode_su
  000f3	48 8b c8	 mov	 rcx, rax
$LN71@unicode_su:
  000f6	e8 00 00 00 00	 call	 _Py_IncRef
  000fb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 13281:     }
; 13282: }

  00102	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00106	5f		 pop	 rdi
  00107	5b		 pop	 rbx
  00108	c3		 ret	 0
$LN34@unicode_su:

; 13242:         } else if (start == 0 && step == 1 &&
; 13243:                    slicelength == PyUnicode_GET_LENGTH(self)) {

  00109	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR start$142996[rsp]
  00111	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR step$142998[rsp]
  00119	48 85 d2	 test	 rdx, rdx
  0011c	75 1b		 jne	 SHORT $LN23@unicode_su
  0011e	49 83 f9 01	 cmp	 r9, 1
  00122	75 2d		 jne	 SHORT $LN21@unicode_su
  00124	4c 3b 43 60	 cmp	 r8, QWORD PTR [rbx+96]
  00128	75 15		 jne	 SHORT $LN68@unicode_su

; 13244:             return unicode_result_unchanged(self);

  0012a	48 8b cb	 mov	 rcx, rbx
  0012d	e8 00 00 00 00	 call	 unicode_result_unchanged

; 13281:     }
; 13282: }

  00132	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00136	5f		 pop	 rdi
  00137	5b		 pop	 rbx
  00138	c3		 ret	 0
$LN23@unicode_su:

; 13245:         } else if (step == 1) {

  00139	49 83 f9 01	 cmp	 r9, 1
  0013d	75 12		 jne	 SHORT $LN21@unicode_su
$LN68@unicode_su:

; 13246:             return PyUnicode_Substring(self,
; 13247:                                        start, start + slicelength);

  0013f	4c 03 c2	 add	 r8, rdx
  00142	48 8b cb	 mov	 rcx, rbx
  00145	e8 00 00 00 00	 call	 PyUnicode_Substring

; 13281:     }
; 13282: }

  0014a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0014e	5f		 pop	 rdi
  0014f	5b		 pop	 rbx
  00150	c3		 ret	 0
$LN21@unicode_su:

; 13248:         }
; 13249:         /* General case */
; 13250:         src_kind = PyUnicode_KIND(self);

  00151	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00154	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  00159	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  0015e	8b c8		 mov	 ecx, eax
  00160	c1 e9 02	 shr	 ecx, 2
  00163	83 e1 07	 and	 ecx, 7

; 13251:         src_data = PyUnicode_DATA(self);

  00166	a8 20		 test	 al, 32			; 00000020H
  00168	74 16		 je	 SHORT $LN48@unicode_su
  0016a	a8 40		 test	 al, 64			; 00000040H
  0016c	74 09		 je	 SHORT $LN46@unicode_su
  0016e	48 8d b3 80 00
	00 00		 lea	 rsi, QWORD PTR [rbx+128]
  00175	eb 10		 jmp	 SHORT $LN49@unicode_su
$LN46@unicode_su:
  00177	48 8d b3 a0 00
	00 00		 lea	 rsi, QWORD PTR [rbx+160]
  0017e	eb 07		 jmp	 SHORT $LN49@unicode_su
$LN48@unicode_su:
  00180	48 8b b3 a0 00
	00 00		 mov	 rsi, QWORD PTR [rbx+160]
$LN49@unicode_su:
  00187	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12

; 13252:         if (!PyUnicode_IS_ASCII(self)) {

  0018c	33 ff		 xor	 edi, edi
  0018e	4c 89 6c 24 48	 mov	 QWORD PTR [rsp+72], r13
  00193	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14

; 13256:                 ch = PyUnicode_READ(src_kind, src_data, cur);

  00198	48 63 e9	 movsxd	 rbp, ecx
  0019b	a8 40		 test	 al, 64			; 00000040H
  0019d	75 61		 jne	 SHORT $LN20@unicode_su

; 13254:             max_char = 0;

  0019f	e8 00 00 00 00	 call	 kind_maxchar_limit
  001a4	8b cf		 mov	 ecx, edi

; 13255:             for (cur = start, i = 0; i < slicelength; cur += step, i++) {

  001a6	8b df		 mov	 ebx, edi
  001a8	44 8b f0	 mov	 r14d, eax
  001ab	4d 85 c0	 test	 r8, r8
  001ae	7e 55		 jle	 SHORT $LN14@unicode_su

; 13253:             kind_limit = kind_maxchar_limit(src_kind);

  001b0	4c 8d 14 16	 lea	 r10, QWORD PTR [rsi+rdx]
  001b4	4c 8d 1c 96	 lea	 r11, QWORD PTR [rsi+rdx*4]
  001b8	4e 8d 24 8d 00
	00 00 00	 lea	 r12, QWORD PTR [r9*4]
  001c0	48 8d 14 56	 lea	 rdx, QWORD PTR [rsi+rdx*2]
  001c4	4f 8d 2c 09	 lea	 r13, QWORD PTR [r9+r9]
$LL19@unicode_su:

; 13256:                 ch = PyUnicode_READ(src_kind, src_data, cur);

  001c8	48 83 fd 01	 cmp	 rbp, 1
  001cc	75 06		 jne	 SHORT $LN52@unicode_su
  001ce	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  001d2	eb 0e		 jmp	 SHORT $LN51@unicode_su
$LN52@unicode_su:
  001d4	48 83 fd 02	 cmp	 rbp, 2
  001d8	75 05		 jne	 SHORT $LN50@unicode_su
  001da	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  001dd	eb 03		 jmp	 SHORT $LN51@unicode_su
$LN50@unicode_su:
  001df	41 8b 03	 mov	 eax, DWORD PTR [r11]
$LN51@unicode_su:

; 13257:                 if (ch > max_char) {

  001e2	3b c1		 cmp	 eax, ecx
  001e4	76 07		 jbe	 SHORT $LN18@unicode_su

; 13258:                     max_char = ch;

  001e6	8b c8		 mov	 ecx, eax

; 13259:                     if (max_char >= kind_limit)

  001e8	41 3b c6	 cmp	 eax, r14d
  001eb	73 18		 jae	 SHORT $LN14@unicode_su
$LN18@unicode_su:

; 13255:             for (cur = start, i = 0; i < slicelength; cur += step, i++) {

  001ed	48 ff c3	 inc	 rbx
  001f0	4d 03 d1	 add	 r10, r9
  001f3	49 03 d5	 add	 rdx, r13
  001f6	4d 03 dc	 add	 r11, r12
  001f9	49 3b d8	 cmp	 rbx, r8
  001fc	7c ca		 jl	 SHORT $LL19@unicode_su

; 13260:                         break;
; 13261:                 }
; 13262:             }
; 13263:         }
; 13264:         else

  001fe	eb 05		 jmp	 SHORT $LN14@unicode_su
$LN20@unicode_su:

; 13265:             max_char = 127;

  00200	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
$LN14@unicode_su:

; 13266:         result = PyUnicode_New(slicelength, max_char);

  00205	8b d1		 mov	 edx, ecx
  00207	49 8b c8	 mov	 rcx, r8
  0020a	e8 00 00 00 00	 call	 PyUnicode_New
  0020f	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]
  00214	4c 8b 6c 24 48	 mov	 r13, QWORD PTR [rsp+72]
  00219	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  0021e	4c 8b d8	 mov	 r11, rax

; 13267:         if (result == NULL)

  00221	48 85 c0	 test	 rax, rax
  00224	75 11		 jne	 SHORT $LN13@unicode_su
  00226	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  0022b	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
$LN1@unicode_su:

; 13281:     }
; 13282: }

  00230	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00234	5f		 pop	 rdi
  00235	5b		 pop	 rbx
  00236	c3		 ret	 0
$LN13@unicode_su:

; 13268:             return NULL;
; 13269:         dest_kind = PyUnicode_KIND(result);

  00237	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0023a	44 8b d0	 mov	 r10d, eax
  0023d	41 c1 ea 02	 shr	 r10d, 2
  00241	41 83 e2 07	 and	 r10d, 7

; 13270:         dest_data = PyUnicode_DATA(result);

  00245	a8 20		 test	 al, 32			; 00000020H
  00247	74 16		 je	 SHORT $LN56@unicode_su
  00249	a8 40		 test	 al, 64			; 00000040H
  0024b	74 09		 je	 SHORT $LN54@unicode_su
  0024d	4d 8d 8b 80 00
	00 00		 lea	 r9, QWORD PTR [r11+128]
  00254	eb 10		 jmp	 SHORT $LN57@unicode_su
$LN54@unicode_su:
  00256	4d 8d 8b a0 00
	00 00		 lea	 r9, QWORD PTR [r11+160]
  0025d	eb 07		 jmp	 SHORT $LN57@unicode_su
$LN56@unicode_su:
  0025f	4d 8b 8b a0 00
	00 00		 mov	 r9, QWORD PTR [r11+160]
$LN57@unicode_su:

; 13271: 
; 13272:         for (cur = start, i = 0; i < slicelength; cur += step, i++) {

  00266	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR start$142996[rsp]
  0026e	48 39 bc 24 90
	00 00 00	 cmp	 QWORD PTR slicelength$142999[rsp], rdi
  00276	7e 4f		 jle	 SHORT $LN10@unicode_su
$LL12@unicode_su:

; 13273:             Py_UCS4 ch = PyUnicode_READ(src_kind, src_data, cur);

  00278	48 83 fd 01	 cmp	 rbp, 1
  0027c	75 07		 jne	 SHORT $LN60@unicode_su
  0027e	41 0f b6 0c 30	 movzx	 ecx, BYTE PTR [r8+rsi]
  00283	eb 11		 jmp	 SHORT $LN59@unicode_su
$LN60@unicode_su:
  00285	48 83 fd 02	 cmp	 rbp, 2
  00289	75 07		 jne	 SHORT $LN58@unicode_su
  0028b	42 0f b7 0c 46	 movzx	 ecx, WORD PTR [rsi+r8*2]
  00290	eb 04		 jmp	 SHORT $LN59@unicode_su
$LN58@unicode_su:
  00292	42 8b 0c 86	 mov	 ecx, DWORD PTR [rsi+r8*4]
$LN59@unicode_su:

; 13274:             PyUnicode_WRITE(dest_kind, dest_data, i, ch);

  00296	41 8b d2	 mov	 edx, r10d
  00299	ff ca		 dec	 edx
  0029b	74 11		 je	 SHORT $LN4@unicode_su
  0029d	ff ca		 dec	 edx
  0029f	74 06		 je	 SHORT $LN3@unicode_su
  002a1	41 89 0c b9	 mov	 DWORD PTR [r9+rdi*4], ecx
  002a5	eb 0b		 jmp	 SHORT $LN8@unicode_su
$LN3@unicode_su:
  002a7	66 41 89 0c 79	 mov	 WORD PTR [r9+rdi*2], cx
  002ac	eb 04		 jmp	 SHORT $LN8@unicode_su
$LN4@unicode_su:
  002ae	41 88 0c 39	 mov	 BYTE PTR [r9+rdi], cl
$LN8@unicode_su:

; 13271: 
; 13272:         for (cur = start, i = 0; i < slicelength; cur += step, i++) {

  002b2	4c 03 84 24 80
	00 00 00	 add	 r8, QWORD PTR step$142998[rsp]
  002ba	48 ff c7	 inc	 rdi
  002bd	48 3b bc 24 90
	00 00 00	 cmp	 rdi, QWORD PTR slicelength$142999[rsp]
  002c5	7c b1		 jl	 SHORT $LL12@unicode_su
$LN10@unicode_su:
  002c7	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  002cc	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]

; 13275:         }
; 13276:         assert(_PyUnicode_CheckConsistency(result, 1));
; 13277:         return result;

  002d1	49 8b c3	 mov	 rax, r11

; 13281:     }
; 13282: }

  002d4	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002d8	5f		 pop	 rdi
  002d9	5b		 pop	 rbx
  002da	c3		 ret	 0
$LN36@unicode_su:

; 13278:     } else {
; 13279:         PyErr_SetString(PyExc_TypeError, "string indices must be integers");

  002db	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@FNFMAOLL@string?5indices?5must?5be?5integers?$AA@
  002e9	e8 00 00 00 00	 call	 PyErr_SetString

; 13280:         return NULL;

  002ee	33 c0		 xor	 eax, eax

; 13281:     }
; 13282: }

  002f0	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002f4	5f		 pop	 rdi
  002f5	5b		 pop	 rbx
  002f6	c3		 ret	 0
unicode_subscript ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@DANAIGJF@not?5all?5arguments?5converted?5duri@ ; `string'
PUBLIC	??_C@_0DG@LHCILPFL@unsupported?5format?5character?5?8?$CFc@ ; `string'
PUBLIC	??_C@_0CO@LIHIEEDL@?$CF?$CF?$CFc?5format?3?5a?5number?5is?5require@ ; `string'
PUBLIC	??_C@_0N@IKLONOJC@prec?5too?5big?$AA@		; `string'
PUBLIC	??_C@_0M@HBDIHKFD@?$CK?5wants?5int?$AA@		; `string'
PUBLIC	??_C@_0O@JMPMPMIA@width?5too?5big?$AA@		; `string'
PUBLIC	??_C@_0BK@OMCHAEPP@format?5requires?5a?5mapping?$AA@ ; `string'
PUBLIC	??_C@_0BG@OJFHELCI@incomplete?5format?5key?$AA@	; `string'
PUBLIC	??_C@_0BB@EFFLDOHP@PyUnicode_Format?$AA@	; `string'
PUBLIC	??_C@_0BC@HHCGKOAC@incomplete?5format?$AA@	; `string'
PUBLIC	PyUnicode_Format
EXTRN	PyNumber_Long:PROC
EXTRN	PyNumber_Check:PROC
EXTRN	_PyLong_FormatWriter:PROC
EXTRN	_PyLong_AsInt:PROC
EXTRN	PyMapping_Check:PROC
EXTRN	PyTuple_Size:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyUnicode_Format DD imagerel $LN513
	DD	imagerel $LN513+66
	DD	imagerel $unwind$PyUnicode_Format
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyUnicode_Format DD imagerel $LN513+66
	DD	imagerel $LN513+125
	DD	imagerel $chain$0$PyUnicode_Format
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyUnicode_Format DD imagerel $LN513+125
	DD	imagerel $LN513+4705
	DD	imagerel $chain$3$PyUnicode_Format
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyUnicode_Format DD imagerel $LN513+4705
	DD	imagerel $LN513+4727
	DD	imagerel $chain$4$PyUnicode_Format
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$PyUnicode_Format DD imagerel $LN513+4727
	DD	imagerel $LN513+4774
	DD	imagerel $chain$6$PyUnicode_Format
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$PyUnicode_Format DD imagerel $LN513+4774
	DD	imagerel $LN513+4808
	DD	imagerel $chain$7$PyUnicode_Format
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$PyUnicode_Format DD imagerel $LN513+4808
	DD	imagerel $LN513+4880
	DD	imagerel $chain$8$PyUnicode_Format
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$PyUnicode_Format DD 080021H
	DD	019e400H
	DD	01ac400H
	DD	01b7400H
	DD	01c3400H
	DD	imagerel $LN513
	DD	imagerel $LN513+66
	DD	imagerel $unwind$PyUnicode_Format
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$PyUnicode_Format DD 021H
	DD	imagerel $LN513
	DD	imagerel $LN513+66
	DD	imagerel $unwind$PyUnicode_Format
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$PyUnicode_Format DD 080021H
	DD	019e400H
	DD	01ac400H
	DD	01b7400H
	DD	01c3400H
	DD	imagerel $LN513
	DD	imagerel $LN513+66
	DD	imagerel $unwind$PyUnicode_Format
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyUnicode_Format DD 021H
	DD	imagerel $LN513+66
	DD	imagerel $LN513+125
	DD	imagerel $chain$0$PyUnicode_Format
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyUnicode_Format DD 061c21H
	DD	01ac41cH
	DD	01b7410H
	DD	01c3408H
	DD	imagerel $LN513+66
	DD	imagerel $LN513+125
	DD	imagerel $chain$0$PyUnicode_Format
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyUnicode_Format DD 020821H
	DD	019e408H
	DD	imagerel $LN513
	DD	imagerel $LN513+66
	DD	imagerel $unwind$PyUnicode_Format
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Format DD 061701H
	DD	01d0117H
	DD	0d009f00bH
	DD	050066007H
xdata	ENDS
;	COMDAT ??_C@_0DF@DANAIGJF@not?5all?5arguments?5converted?5duri@
CONST	SEGMENT
??_C@_0DF@DANAIGJF@not?5all?5arguments?5converted?5duri@ DB 'not all argu'
	DB	'ments converted during string formatting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@LHCILPFL@unsupported?5format?5character?5?8?$CFc@
CONST	SEGMENT
??_C@_0DG@LHCILPFL@unsupported?5format?5character?5?8?$CFc@ DB 'unsupport'
	DB	'ed format character ''%c'' (0x%x) at index %zd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@LIHIEEDL@?$CF?$CF?$CFc?5format?3?5a?5number?5is?5require@
CONST	SEGMENT
??_C@_0CO@LIHIEEDL@?$CF?$CF?$CFc?5format?3?5a?5number?5is?5require@ DB '%'
	DB	'%%c format: a number is required, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IKLONOJC@prec?5too?5big?$AA@
CONST	SEGMENT
??_C@_0N@IKLONOJC@prec?5too?5big?$AA@ DB 'prec too big', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HBDIHKFD@?$CK?5wants?5int?$AA@
CONST	SEGMENT
??_C@_0M@HBDIHKFD@?$CK?5wants?5int?$AA@ DB '* wants int', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JMPMPMIA@width?5too?5big?$AA@
CONST	SEGMENT
??_C@_0O@JMPMPMIA@width?5too?5big?$AA@ DB 'width too big', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OMCHAEPP@format?5requires?5a?5mapping?$AA@
CONST	SEGMENT
??_C@_0BK@OMCHAEPP@format?5requires?5a?5mapping?$AA@ DB 'format requires '
	DB	'a mapping', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OJFHELCI@incomplete?5format?5key?$AA@
CONST	SEGMENT
??_C@_0BG@OJFHELCI@incomplete?5format?5key?$AA@ DB 'incomplete format key'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EFFLDOHP@PyUnicode_Format?$AA@
CONST	SEGMENT
??_C@_0BB@EFFLDOHP@PyUnicode_Format?$AA@ DB 'PyUnicode_Format', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HHCGKOAC@incomplete?5format?$AA@
CONST	SEGMENT
??_C@_0BC@HHCGKOAC@incomplete?5format?$AA@ DB 'incomplete format', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT PyUnicode_Format
_TEXT	SEGMENT
temp$1$ = 48
uformat$1$ = 56
fmtcnt$1$ = 64
sublen$3$ = 72
writer$ = 80
fill$1$ = 136
args_owned$1$ = 140
temp$ = 144
dict$1$ = 152
argidx$ = 160
arglen$1$ = 168
fmt$1$ = 176
$T163765 = 184
prec$1$ = 272
writer$2$ = 272
format$ = 272
args$ = 280
flags$1$ = 288
signchar$1$ = 296
PyUnicode_Format PROC					; COMDAT

; 13519: {

$LN513:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 55		 push	 r13
  00009	41 57		 push	 r15
  0000b	48 8d 6c 24 c1	 lea	 rbp, QWORD PTR [rsp-63]
  00010	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 13520:     Py_ssize_t fmtcnt, fmtpos, arglen, argidx;
; 13521:     int args_owned = 0;

  00017	45 33 ff	 xor	 r15d, r15d
  0001a	4c 8b ea	 mov	 r13, rdx
  0001d	44 89 7d e3	 mov	 DWORD PTR args_owned$1$[rbp-169], r15d

; 13522:     PyObject *dict = NULL;

  00021	4c 89 7d ef	 mov	 QWORD PTR dict$1$[rbp-169], r15

; 13523:     PyObject *temp = NULL;

  00025	41 8b f7	 mov	 esi, r15d
  00028	4c 89 7d 87	 mov	 QWORD PTR temp$1$[rbp-169], r15
  0002c	4c 89 7d e7	 mov	 QWORD PTR temp$[rbp-169], r15

; 13524:     PyObject *second = NULL;
; 13525:     PyObject *uformat;
; 13526:     void *fmt;
; 13527:     enum PyUnicode_Kind kind, fmtkind;
; 13528:     _PyUnicodeWriter writer;
; 13529:     Py_ssize_t sublen;
; 13530:     Py_UCS4 maxchar;
; 13531: 
; 13532:     if (format == NULL || args == NULL) {

  00030	48 85 c9	 test	 rcx, rcx
  00033	0f 84 6d 12 00
	00		 je	 $LN271@PyUnicode_@95
  00039	48 85 d2	 test	 rdx, rdx
  0003c	0f 84 64 12 00
	00		 je	 $LN271@PyUnicode_@95

; 13535:     }
; 13536:     uformat = PyUnicode_FromObject(format);

  00042	4c 89 b4 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], r14
  0004a	e8 00 00 00 00	 call	 PyUnicode_FromObject
  0004f	4c 8b f0	 mov	 r14, rax
  00052	48 89 45 8f	 mov	 QWORD PTR uformat$1$[rbp-169], rax

; 13537:     if (uformat == NULL)

  00056	48 85 c0	 test	 rax, rax

; 13538:         return NULL;

  00059	74 1b		 je	 SHORT $LN507@PyUnicode_@95

; 13539:     if (PyUnicode_READY(uformat) == -1) {

  0005b	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  0005f	75 1c		 jne	 SHORT $LN269@PyUnicode_@95
  00061	48 8b c8	 mov	 rcx, rax
  00064	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00069	83 f8 ff	 cmp	 eax, -1
  0006c	75 0f		 jne	 SHORT $LN269@PyUnicode_@95

; 13540:         Py_DECREF(uformat);

  0006e	49 8b ce	 mov	 rcx, r14
  00071	e8 00 00 00 00	 call	 _Py_DecRef
$LN507@PyUnicode_@95:

; 13541:         return NULL;

  00076	33 c0		 xor	 eax, eax
  00078	e9 e4 11 00 00	 jmp	 $LN488@PyUnicode_@95
$LN269@PyUnicode_@95:
  0007d	48 89 9c 24 e0
	00 00 00	 mov	 QWORD PTR [rsp+224], rbx
  00085	48 89 bc 24 d8
	00 00 00	 mov	 QWORD PTR [rsp+216], rdi

; 13542:     }
; 13543: 
; 13544:     fmt = PyUnicode_DATA(uformat);

  0008d	41 8b 7e 70	 mov	 edi, DWORD PTR [r14+112]
  00091	4c 89 a4 24 d0
	00 00 00	 mov	 QWORD PTR [rsp+208], r12
  00099	40 f6 c7 20	 test	 dil, 32			; 00000020H
  0009d	74 18		 je	 SHORT $LN279@PyUnicode_@95
  0009f	40 f6 c7 40	 test	 dil, 64			; 00000040H
  000a3	74 09		 je	 SHORT $LN277@PyUnicode_@95
  000a5	4d 8d a6 80 00
	00 00		 lea	 r12, QWORD PTR [r14+128]
  000ac	eb 10		 jmp	 SHORT $LN492@PyUnicode_@95
$LN277@PyUnicode_@95:
  000ae	4d 8d a6 a0 00
	00 00		 lea	 r12, QWORD PTR [r14+160]
  000b5	eb 07		 jmp	 SHORT $LN492@PyUnicode_@95
$LN279@PyUnicode_@95:
  000b7	4d 8b a6 a0 00
	00 00		 mov	 r12, QWORD PTR [r14+160]
$LN492@PyUnicode_@95:

; 13545:     fmtkind = PyUnicode_KIND(uformat);
; 13546:     fmtcnt = PyUnicode_GET_LENGTH(uformat);

  000be	49 8b 56 60	 mov	 rdx, QWORD PTR [r14+96]

; 13547:     fmtpos = 0;
; 13548: 
; 13549:     _PyUnicodeWriter_Init(&writer, fmtcnt + 100);

  000c2	48 8d 4d a7	 lea	 rcx, QWORD PTR writer$[rbp-169]
  000c6	c1 ef 02	 shr	 edi, 2
  000c9	48 89 55 97	 mov	 QWORD PTR fmtcnt$1$[rbp-169], rdx
  000cd	48 83 c2 64	 add	 rdx, 100		; 00000064H
  000d1	4c 89 65 07	 mov	 QWORD PTR fmt$1$[rbp-169], r12
  000d5	83 e7 07	 and	 edi, 7
  000d8	49 8b df	 mov	 rbx, r15
  000db	e8 00 00 00 00	 call	 _PyUnicodeWriter_Init

; 13550: 
; 13551:     if (PyTuple_Check(args)) {

  000e0	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  000e4	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  000ee	74 12		 je	 SHORT $LN268@PyUnicode_@95

; 13552:         arglen = PyTuple_Size(args);

  000f0	49 8b cd	 mov	 rcx, r13
  000f3	e8 00 00 00 00	 call	 PyTuple_Size

; 13553:         argidx = 0;

  000f8	4c 89 7d f7	 mov	 QWORD PTR argidx$[rbp-169], r15
  000fc	48 89 45 ff	 mov	 QWORD PTR arglen$1$[rbp-169], rax

; 13554:     }
; 13555:     else {

  00100	eb 10		 jmp	 SHORT $LN267@PyUnicode_@95
$LN268@PyUnicode_@95:

; 13556:         arglen = -1;

  00102	48 c7 45 ff ff
	ff ff ff	 mov	 QWORD PTR arglen$1$[rbp-169], -1

; 13557:         argidx = -2;

  0010a	48 c7 45 f7 fe
	ff ff ff	 mov	 QWORD PTR argidx$[rbp-169], -2
$LN267@PyUnicode_@95:

; 13558:     }
; 13559:     if (PyMapping_Check(args) && !PyTuple_Check(args) && !PyUnicode_Check(args))

  00112	49 8b cd	 mov	 rcx, r13
  00115	e8 00 00 00 00	 call	 PyMapping_Check
  0011a	4c 8b 4d 6f	 mov	 r9, QWORD PTR args$[rbp-169]
  0011e	85 c0		 test	 eax, eax
  00120	74 21		 je	 SHORT $LN483@PyUnicode_@95
  00122	49 8b 41 58	 mov	 rax, QWORD PTR [r9+88]
  00126	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  0012c	0f ba e1 1a	 bt	 ecx, 26
  00130	72 11		 jb	 SHORT $LN483@PyUnicode_@95
  00132	0f ba e1 1c	 bt	 ecx, 28
  00136	48 8b cb	 mov	 rcx, rbx
  00139	49 0f 43 c9	 cmovae	 rcx, r9
  0013d	48 89 4d ef	 mov	 QWORD PTR dict$1$[rbp-169], rcx
  00141	eb 03		 jmp	 SHORT $LN373@PyUnicode_@95
$LN483@PyUnicode_@95:

; 13560:         dict = args;
; 13561: 
; 13562:     while (--fmtcnt >= 0) {

  00143	48 8b cb	 mov	 rcx, rbx
$LN373@PyUnicode_@95:
  00146	4c 8b 45 97	 mov	 r8, QWORD PTR fmtcnt$1$[rbp-169]

; 13563:         if (PyUnicode_READ(fmtkind, fmt, fmtpos) != '%') {

  0014a	4c 63 ff	 movsxd	 r15, edi
  0014d	49 ff c8	 dec	 r8
  00150	4c 89 7d 0f	 mov	 QWORD PTR $T163765[rbp-169], r15
  00154	4c 89 45 97	 mov	 QWORD PTR fmtcnt$1$[rbp-169], r8
  00158	0f 88 7f 10 00
	00		 js	 $LN264@PyUnicode_@95

; 13560:         dict = args;
; 13561: 
; 13562:     while (--fmtcnt >= 0) {

  0015e	4c 8b 6d c7	 mov	 r13, QWORD PTR writer$[rbp-137]
$LN501@PyUnicode_@95:
  00162	49 ba 67 66 66
	66 66 66 66 66	 mov	 r10, 7378697629483820647 ; 6666666666666667H
  0016c	48 ba ff ff ff
	ff ff ff ff 7f	 mov	 rdx, 9223372036854775807 ; 7fffffffffffffffH

; 13563:         if (PyUnicode_READ(fmtkind, fmt, fmtpos) != '%') {

  00176	49 83 ff 01	 cmp	 r15, 1
  0017a	75 07		 jne	 SHORT $LN283@PyUnicode_@95
  0017c	42 0f b6 04 23	 movzx	 eax, BYTE PTR [rbx+r12]
  00181	eb 11		 jmp	 SHORT $LN282@PyUnicode_@95
$LN283@PyUnicode_@95:
  00183	49 83 ff 02	 cmp	 r15, 2
  00187	75 07		 jne	 SHORT $LN281@PyUnicode_@95
  00189	41 0f b7 04 5c	 movzx	 eax, WORD PTR [r12+rbx*2]
  0018e	eb 04		 jmp	 SHORT $LN282@PyUnicode_@95
$LN281@PyUnicode_@95:
  00190	41 8b 04 9c	 mov	 eax, DWORD PTR [r12+rbx*4]
$LN282@PyUnicode_@95:
  00194	83 f8 25	 cmp	 eax, 37			; 00000025H
  00197	0f 84 ad 00 00
	00		 je	 $LN263@PyUnicode_@95

; 13564:             Py_ssize_t nonfmtpos;
; 13565:             nonfmtpos = fmtpos++;

  0019d	48 8b f3	 mov	 rsi, rbx
  001a0	48 ff c3	 inc	 rbx
$LL262@PyUnicode_@95:

; 13566:             while (fmtcnt >= 0 &&
; 13567:                    PyUnicode_READ(fmtkind, fmt, fmtpos) != '%') {

  001a3	49 83 ff 01	 cmp	 r15, 1
  001a7	75 07		 jne	 SHORT $LN287@PyUnicode_@95
  001a9	42 0f b6 04 23	 movzx	 eax, BYTE PTR [rbx+r12]
  001ae	eb 11		 jmp	 SHORT $LN286@PyUnicode_@95
$LN287@PyUnicode_@95:
  001b0	49 83 ff 02	 cmp	 r15, 2
  001b4	75 07		 jne	 SHORT $LN285@PyUnicode_@95
  001b6	41 0f b7 04 5c	 movzx	 eax, WORD PTR [r12+rbx*2]
  001bb	eb 04		 jmp	 SHORT $LN286@PyUnicode_@95
$LN285@PyUnicode_@95:
  001bd	41 8b 04 9c	 mov	 eax, DWORD PTR [r12+rbx*4]
$LN286@PyUnicode_@95:
  001c1	83 f8 25	 cmp	 eax, 37			; 00000025H
  001c4	74 0e		 je	 SHORT $LN261@PyUnicode_@95

; 13568:                 fmtpos++;

  001c6	48 ff c3	 inc	 rbx

; 13569:                 fmtcnt--;

  001c9	49 ff c8	 dec	 r8
  001cc	4c 89 45 97	 mov	 QWORD PTR fmtcnt$1$[rbp-169], r8
  001d0	79 d1		 jns	 SHORT $LL262@PyUnicode_@95

; 13570:             }
; 13571:             if (fmtcnt < 0)

  001d2	eb 05		 jmp	 SHORT $LN424@PyUnicode_@95
$LN261@PyUnicode_@95:
  001d4	4d 85 c0	 test	 r8, r8
  001d7	79 03		 jns	 SHORT $LN260@PyUnicode_@95
$LN424@PyUnicode_@95:

; 13572:                 fmtpos--;

  001d9	48 ff cb	 dec	 rbx
$LN260@PyUnicode_@95:

; 13573:             sublen = fmtpos - nonfmtpos;

  001dc	48 8b fb	 mov	 rdi, rbx

; 13574:             maxchar = _PyUnicode_FindMaxChar(uformat,
; 13575:                                              nonfmtpos, nonfmtpos + sublen);

  001df	48 8b d6	 mov	 rdx, rsi
  001e2	49 8b ce	 mov	 rcx, r14
  001e5	48 2b fe	 sub	 rdi, rsi
  001e8	4c 8d 04 37	 lea	 r8, QWORD PTR [rdi+rsi]
  001ec	e8 00 00 00 00	 call	 _PyUnicode_FindMaxChar
  001f1	44 8b c0	 mov	 r8d, eax

; 13576:             if (_PyUnicodeWriter_Prepare(&writer, sublen, maxchar) == -1)

  001f4	3b 45 bb	 cmp	 eax, DWORD PTR writer$[rbp-149]
  001f7	77 0c		 ja	 SHORT $LN289@PyUnicode_@95
  001f9	48 8b 45 bf	 mov	 rax, QWORD PTR writer$[rbp-145]
  001fd	49 2b c5	 sub	 rax, r13
  00200	48 3b f8	 cmp	 rdi, rax
  00203	7e 1e		 jle	 SHORT $LN427@PyUnicode_@95
$LN289@PyUnicode_@95:
  00205	48 85 ff	 test	 rdi, rdi
  00208	74 19		 je	 SHORT $LN427@PyUnicode_@95
  0020a	48 8d 4d a7	 lea	 rcx, QWORD PTR writer$[rbp-169]
  0020e	48 8b d7	 mov	 rdx, rdi
  00211	e8 00 00 00 00	 call	 _PyUnicodeWriter_PrepareInternal
  00216	83 f8 ff	 cmp	 eax, -1
  00219	0f 84 65 0e 00
	00		 je	 $LN474@PyUnicode_@95
  0021f	4c 8b 6d c7	 mov	 r13, QWORD PTR writer$[rbp-137]
$LN427@PyUnicode_@95:

; 13577:                 goto onError;
; 13578: 
; 13579:             _PyUnicode_FastCopyCharacters(writer.buffer, writer.pos,
; 13580:                                           uformat, nonfmtpos, sublen);

  00223	48 8b 4d a7	 mov	 rcx, QWORD PTR writer$[rbp-169]
  00227	4c 8b ce	 mov	 r9, rsi
  0022a	4d 8b c6	 mov	 r8, r14
  0022d	49 8b d5	 mov	 rdx, r13
  00230	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00235	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 13581:             writer.pos += sublen;

  0023a	4c 8b 6d c7	 mov	 r13, QWORD PTR writer$[rbp-137]
  0023e	4c 03 ef	 add	 r13, rdi
  00241	4c 89 6d c7	 mov	 QWORD PTR writer$[rbp-137], r13

; 13582:         }
; 13583:         else {

  00245	e9 f9 0d 00 00	 jmp	 $LN493@PyUnicode_@95
$LN263@PyUnicode_@95:

; 13584:             /* Got a format specifier */
; 13585:             int flags = 0;

  0024a	45 33 f6	 xor	 r14d, r14d

; 13586:             Py_ssize_t width = -1;
; 13587:             int prec = -1;
; 13588:             Py_UCS4 c = '\0';
; 13589:             Py_UCS4 fill;
; 13590:             int sign;
; 13591:             Py_UCS4 signchar;
; 13592:             int isnumok;
; 13593:             PyObject *v = NULL;
; 13594:             void *pbuf = NULL;
; 13595:             Py_ssize_t pindex, len;
; 13596:             Py_UCS4 bufmaxchar;
; 13597:             Py_ssize_t buflen;
; 13598: 
; 13599:             fmtpos++;

  0024d	48 ff c3	 inc	 rbx
  00250	48 c7 45 9f ff
	ff ff ff	 mov	 QWORD PTR sublen$3$[rbp-169], -1
  00258	c7 45 67 ff ff
	ff ff		 mov	 DWORD PTR prec$1$[rbp-169], -1
  0025f	44 89 75 77	 mov	 DWORD PTR flags$1$[rbp-169], r14d

; 13600:             c = PyUnicode_READ(fmtkind, fmt, fmtpos);

  00263	49 83 ff 01	 cmp	 r15, 1
  00267	75 07		 jne	 SHORT $LN295@PyUnicode_@95
  00269	42 0f b6 34 23	 movzx	 esi, BYTE PTR [rbx+r12]
  0026e	eb 11		 jmp	 SHORT $LN294@PyUnicode_@95
$LN295@PyUnicode_@95:
  00270	49 83 ff 02	 cmp	 r15, 2
  00274	75 07		 jne	 SHORT $LN293@PyUnicode_@95
  00276	41 0f b7 34 5c	 movzx	 esi, WORD PTR [r12+rbx*2]
  0027b	eb 04		 jmp	 SHORT $LN294@PyUnicode_@95
$LN293@PyUnicode_@95:
  0027d	41 8b 34 9c	 mov	 esi, DWORD PTR [r12+rbx*4]
$LN294@PyUnicode_@95:

; 13601:             if (c == '(') {

  00281	83 fe 28	 cmp	 esi, 40			; 00000028H
  00284	0f 85 e1 00 00
	00		 jne	 $LN456@PyUnicode_@95

; 13602:                 Py_ssize_t keystart;
; 13603:                 Py_ssize_t keylen;
; 13604:                 PyObject *key;
; 13605:                 int pcount = 1;

  0028a	8d 46 d9	 lea	 eax, QWORD PTR [rsi-39]

; 13606: 
; 13607:                 if (dict == NULL) {

  0028d	48 85 c9	 test	 rcx, rcx
  00290	0f 84 db 0d 00
	00		 je	 $LN389@PyUnicode_@95

; 13610:                     goto onError;
; 13611:                 }
; 13612:                 ++fmtpos;

  00296	48 ff c3	 inc	 rbx

; 13613:                 --fmtcnt;

  00299	49 ff c8	 dec	 r8

; 13614:                 keystart = fmtpos;

  0029c	48 8b d3	 mov	 rdx, rbx
  0029f	90		 npad	 1
$LL255@PyUnicode_@95:

; 13615:                 /* Skip over balanced parentheses */
; 13616:                 while (pcount > 0 && --fmtcnt >= 0) {

  002a0	49 ff c8	 dec	 r8
  002a3	4c 89 45 97	 mov	 QWORD PTR fmtcnt$1$[rbp-169], r8
  002a7	0f 88 b4 0d 00
	00		 js	 $LN249@PyUnicode_@95

; 13617:                     c = PyUnicode_READ(fmtkind, fmt, fmtpos);

  002ad	49 83 ff 01	 cmp	 r15, 1
  002b1	75 07		 jne	 SHORT $LN299@PyUnicode_@95
  002b3	42 0f b6 34 23	 movzx	 esi, BYTE PTR [rbx+r12]
  002b8	eb 11		 jmp	 SHORT $LN298@PyUnicode_@95
$LN299@PyUnicode_@95:
  002ba	49 83 ff 02	 cmp	 r15, 2
  002be	75 07		 jne	 SHORT $LN297@PyUnicode_@95
  002c0	41 0f b7 34 5c	 movzx	 esi, WORD PTR [r12+rbx*2]
  002c5	eb 04		 jmp	 SHORT $LN298@PyUnicode_@95
$LN297@PyUnicode_@95:
  002c7	41 8b 34 9c	 mov	 esi, DWORD PTR [r12+rbx*4]
$LN298@PyUnicode_@95:

; 13618:                     if (c == ')')

  002cb	83 fe 29	 cmp	 esi, 41			; 00000029H
  002ce	75 04		 jne	 SHORT $LN253@PyUnicode_@95

; 13619:                         --pcount;

  002d0	ff c8		 dec	 eax
  002d2	eb 07		 jmp	 SHORT $LN251@PyUnicode_@95
$LN253@PyUnicode_@95:

; 13620:                     else if (c == '(')

  002d4	83 fe 28	 cmp	 esi, 40			; 00000028H
  002d7	75 02		 jne	 SHORT $LN251@PyUnicode_@95

; 13621:                         ++pcount;

  002d9	ff c0		 inc	 eax
$LN251@PyUnicode_@95:

; 13622:                     fmtpos++;

  002db	48 ff c3	 inc	 rbx
  002de	85 c0		 test	 eax, eax
  002e0	7f be		 jg	 SHORT $LL255@PyUnicode_@95

; 13629:                 }
; 13630:                 key = PyUnicode_Substring(uformat,
; 13631:                                           keystart, keystart + keylen);

  002e2	4c 8b 6d 8f	 mov	 r13, QWORD PTR uformat$1$[rbp-169]
  002e6	4c 8d 43 ff	 lea	 r8, QWORD PTR [rbx-1]
  002ea	49 8b cd	 mov	 rcx, r13
  002ed	e8 00 00 00 00	 call	 PyUnicode_Substring
  002f2	48 8b f8	 mov	 rdi, rax

; 13632:                 if (key == NULL)

  002f5	48 85 c0	 test	 rax, rax
  002f8	0f 84 8a 0d 00
	00		 je	 $LN477@PyUnicode_@95

; 13633:                     goto onError;
; 13634:                 if (args_owned) {

  002fe	44 39 75 e3	 cmp	 DWORD PTR args_owned$1$[rbp-169], r14d
  00302	74 0d		 je	 SHORT $LN247@PyUnicode_@95

; 13635:                     Py_DECREF(args);

  00304	48 8b 4d 6f	 mov	 rcx, QWORD PTR args$[rbp-169]
  00308	e8 00 00 00 00	 call	 _Py_DecRef

; 13636:                     args_owned = 0;

  0030d	44 89 75 e3	 mov	 DWORD PTR args_owned$1$[rbp-169], r14d
$LN247@PyUnicode_@95:

; 13637:                 }
; 13638:                 args = PyObject_GetItem(dict, key);

  00311	48 8b 4d ef	 mov	 rcx, QWORD PTR dict$1$[rbp-169]
  00315	48 8b d7	 mov	 rdx, rdi
  00318	e8 00 00 00 00	 call	 PyObject_GetItem

; 13639:                 Py_DECREF(key);

  0031d	48 8b cf	 mov	 rcx, rdi
  00320	48 89 45 6f	 mov	 QWORD PTR args$[rbp-169], rax
  00324	e8 00 00 00 00	 call	 _Py_DecRef

; 13640:                 if (args == NULL) {

  00329	4c 8b 4d 6f	 mov	 r9, QWORD PTR args$[rbp-169]
  0032d	4d 85 c9	 test	 r9, r9
  00330	0f 84 52 0d 00
	00		 je	 $LN477@PyUnicode_@95

; 13645:                 argidx = -2;

  00336	4c 8b 6d c7	 mov	 r13, QWORD PTR writer$[rbp-137]
  0033a	4c 8b 45 97	 mov	 r8, QWORD PTR fmtcnt$1$[rbp-169]
  0033e	48 83 c8 ff	 or	 rax, -1
  00342	48 89 45 ff	 mov	 QWORD PTR arglen$1$[rbp-169], rax
  00346	c7 45 e3 01 00
	00 00		 mov	 DWORD PTR args_owned$1$[rbp-169], 1
  0034d	48 c7 45 f7 fe
	ff ff ff	 mov	 QWORD PTR argidx$[rbp-169], -2
  00355	48 ba ff ff ff
	ff ff ff ff 7f	 mov	 rdx, 9223372036854775807 ; 7fffffffffffffffH
  0035f	49 ba 67 66 66
	66 66 66 66 66	 mov	 r10, 7378697629483820647 ; 6666666666666667H
  00369	eb 04		 jmp	 SHORT $LN376@PyUnicode_@95
$LN456@PyUnicode_@95:

; 13641:                     goto onError;
; 13642:                 }
; 13643:                 args_owned = 1;
; 13644:                 arglen = -1;

  0036b	48 8b 45 ff	 mov	 rax, QWORD PTR arglen$1$[rbp-169]
$LN376@PyUnicode_@95:

; 13646:             }
; 13647:             while (--fmtcnt >= 0) {

  0036f	49 ff c8	 dec	 r8
  00372	4c 89 45 97	 mov	 QWORD PTR fmtcnt$1$[rbp-169], r8
  00376	78 73		 js	 SHORT $LN383@PyUnicode_@95
$LL245@PyUnicode_@95:

; 13648:                 c = PyUnicode_READ(fmtkind, fmt, fmtpos++);

  00378	49 83 ff 01	 cmp	 r15, 1
  0037c	75 07		 jne	 SHORT $LN303@PyUnicode_@95
  0037e	42 0f b6 34 23	 movzx	 esi, BYTE PTR [rbx+r12]
  00383	eb 11		 jmp	 SHORT $LN494@PyUnicode_@95
$LN303@PyUnicode_@95:
  00385	49 83 ff 02	 cmp	 r15, 2
  00389	75 07		 jne	 SHORT $LN301@PyUnicode_@95
  0038b	41 0f b7 34 5c	 movzx	 esi, WORD PTR [r12+rbx*2]
  00390	eb 04		 jmp	 SHORT $LN494@PyUnicode_@95
$LN301@PyUnicode_@95:
  00392	41 8b 34 9c	 mov	 esi, DWORD PTR [r12+rbx*4]
$LN494@PyUnicode_@95:
  00396	48 ff c3	 inc	 rbx

; 13649:                 switch (c) {

  00399	83 fe 20	 cmp	 esi, 32			; 00000020H
  0039c	74 2c		 je	 SHORT $LN239@PyUnicode_@95
  0039e	83 fe 23	 cmp	 esi, 35			; 00000023H
  003a1	74 21		 je	 SHORT $LN238@PyUnicode_@95
  003a3	83 fe 2b	 cmp	 esi, 43			; 0000002bH
  003a6	74 16		 je	 SHORT $LN240@PyUnicode_@95
  003a8	83 fe 2d	 cmp	 esi, 45			; 0000002dH
  003ab	74 0b		 je	 SHORT $LN241@PyUnicode_@95
  003ad	83 fe 30	 cmp	 esi, 48			; 00000030H
  003b0	75 21		 jne	 SHORT $LN443@PyUnicode_@95

; 13654:                 case '0': flags |= F_ZERO; continue;

  003b2	41 83 ce 10	 or	 r14d, 16
  003b6	eb 16		 jmp	 SHORT $LN417@PyUnicode_@95
$LN241@PyUnicode_@95:

; 13650:                 case '-': flags |= F_LJUST; continue;

  003b8	41 83 ce 01	 or	 r14d, 1
  003bc	eb 10		 jmp	 SHORT $LN417@PyUnicode_@95
$LN240@PyUnicode_@95:

; 13651:                 case '+': flags |= F_SIGN; continue;

  003be	41 83 ce 02	 or	 r14d, 2
  003c2	eb 0a		 jmp	 SHORT $LN417@PyUnicode_@95
$LN238@PyUnicode_@95:

; 13653:                 case '#': flags |= F_ALT; continue;

  003c4	41 83 ce 08	 or	 r14d, 8
  003c8	eb 04		 jmp	 SHORT $LN417@PyUnicode_@95
$LN239@PyUnicode_@95:

; 13652:                 case ' ': flags |= F_BLANK; continue;

  003ca	41 83 ce 04	 or	 r14d, 4
$LN417@PyUnicode_@95:

; 13646:             }
; 13647:             while (--fmtcnt >= 0) {

  003ce	49 ff c8	 dec	 r8
  003d1	79 a5		 jns	 SHORT $LL245@PyUnicode_@95
$LN443@PyUnicode_@95:
  003d3	44 89 75 77	 mov	 DWORD PTR flags$1$[rbp-169], r14d
  003d7	44 89 75 77	 mov	 DWORD PTR flags$1$[rbp-169], r14d
  003db	44 89 75 77	 mov	 DWORD PTR flags$1$[rbp-169], r14d
  003df	44 89 75 77	 mov	 DWORD PTR flags$1$[rbp-169], r14d
  003e3	4c 89 45 97	 mov	 QWORD PTR fmtcnt$1$[rbp-169], r8
  003e7	44 89 75 77	 mov	 DWORD PTR flags$1$[rbp-169], r14d
$LN383@PyUnicode_@95:

; 13655:                 }
; 13656:                 break;
; 13657:             }
; 13658:             if (c == '*') {

  003eb	83 fe 2a	 cmp	 esi, 42			; 0000002aH
  003ee	0f 85 b4 00 00
	00		 jne	 $LN236@PyUnicode_@95

; 13659:                 v = getnextarg(args, arglen, &argidx);

  003f4	4c 8d 45 f7	 lea	 r8, QWORD PTR argidx$[rbp-169]
  003f8	48 8b d0	 mov	 rdx, rax
  003fb	49 8b c9	 mov	 rcx, r9
  003fe	e8 00 00 00 00	 call	 getnextarg
  00403	48 8b c8	 mov	 rcx, rax

; 13660:                 if (v == NULL)

  00406	48 85 c0	 test	 rax, rax
  00409	0f 84 75 0c 00
	00		 je	 $LN474@PyUnicode_@95

; 13661:                     goto onError;
; 13662:                 if (!PyLong_Check(v)) {

  0040f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00413	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0041d	0f 84 ec 0c 00
	00		 je	 $LN397@PyUnicode_@95

; 13663:                     PyErr_SetString(PyExc_TypeError,
; 13664:                                     "* wants int");
; 13665:                     goto onError;
; 13666:                 }
; 13667:                 width = PyLong_AsSsize_t(v);

  00423	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00428	4c 8b c8	 mov	 r9, rax
  0042b	48 89 45 9f	 mov	 QWORD PTR sublen$3$[rbp-169], rax

; 13668:                 if (width == -1 && PyErr_Occurred())

  0042f	48 83 f8 ff	 cmp	 rax, -1
  00433	75 14		 jne	 SHORT $LN233@PyUnicode_@95
  00435	e8 00 00 00 00	 call	 PyErr_Occurred
  0043a	48 85 c0	 test	 rax, rax
  0043d	0f 85 41 0c 00
	00		 jne	 $LN474@PyUnicode_@95

; 13669:                     goto onError;
; 13670:                 if (width < 0) {

  00443	4c 8b 4d 9f	 mov	 r9, QWORD PTR sublen$3$[rbp-169]
  00447	eb 05		 jmp	 SHORT $LN428@PyUnicode_@95
$LN233@PyUnicode_@95:
  00449	48 85 c0	 test	 rax, rax
  0044c	79 0f		 jns	 SHORT $LN232@PyUnicode_@95
$LN428@PyUnicode_@95:

; 13671:                     flags |= F_LJUST;

  0044e	41 83 ce 01	 or	 r14d, 1

; 13672:                     width = -width;

  00452	49 f7 d9	 neg	 r9
  00455	4c 89 4d 9f	 mov	 QWORD PTR sublen$3$[rbp-169], r9
  00459	44 89 75 77	 mov	 DWORD PTR flags$1$[rbp-169], r14d
$LN232@PyUnicode_@95:

; 13673:                 }
; 13674:                 if (--fmtcnt >= 0)

  0045d	4c 8b 45 97	 mov	 r8, QWORD PTR fmtcnt$1$[rbp-169]
  00461	49 ff c8	 dec	 r8
  00464	4c 89 45 97	 mov	 QWORD PTR fmtcnt$1$[rbp-169], r8
  00468	0f 88 2e 02 00
	00		 js	 $LN399@PyUnicode_@95

; 13675:                     c = PyUnicode_READ(fmtkind, fmt, fmtpos++);

  0046e	4c 8b 6d c7	 mov	 r13, QWORD PTR writer$[rbp-137]
  00472	49 83 ff 01	 cmp	 r15, 1
  00476	75 0d		 jne	 SHORT $LN307@PyUnicode_@95
  00478	42 0f b6 34 23	 movzx	 esi, BYTE PTR [rbx+r12]
  0047d	48 ff c3	 inc	 rbx
  00480	e9 ad 00 00 00	 jmp	 $LN481@PyUnicode_@95
$LN307@PyUnicode_@95:
  00485	4c 8b 4d 6f	 mov	 r9, QWORD PTR args$[rbp-169]
  00489	49 83 ff 02	 cmp	 r15, 2
  0048d	75 0d		 jne	 SHORT $LN305@PyUnicode_@95
  0048f	41 0f b7 34 5c	 movzx	 esi, WORD PTR [r12+rbx*2]
  00494	48 ff c3	 inc	 rbx
  00497	e9 9a 00 00 00	 jmp	 $LN384@PyUnicode_@95
$LN305@PyUnicode_@95:
  0049c	41 8b 34 9c	 mov	 esi, DWORD PTR [r12+rbx*4]
  004a0	48 ff c3	 inc	 rbx

; 13676:             }
; 13677:             else if (c >= '0' && c <= '9') {

  004a3	e9 8e 00 00 00	 jmp	 $LN384@PyUnicode_@95
$LN236@PyUnicode_@95:
  004a8	8d 46 d0	 lea	 eax, DWORD PTR [rsi-48]
  004ab	83 f8 09	 cmp	 eax, 9
  004ae	0f 87 82 00 00
	00		 ja	 $LN384@PyUnicode_@95

; 13678:                 width = c - '0';

  004b4	44 8b c8	 mov	 r9d, eax

; 13679:                 while (--fmtcnt >= 0) {

  004b7	49 ff c8	 dec	 r8
  004ba	4c 89 4d 9f	 mov	 QWORD PTR sublen$3$[rbp-169], r9
  004be	4c 89 45 97	 mov	 QWORD PTR fmtcnt$1$[rbp-169], r8
  004c2	78 6e		 js	 SHORT $LN481@PyUnicode_@95
$LL228@PyUnicode_@95:

; 13680:                     c = PyUnicode_READ(fmtkind, fmt, fmtpos++);

  004c4	49 83 ff 01	 cmp	 r15, 1
  004c8	75 07		 jne	 SHORT $LN311@PyUnicode_@95
  004ca	42 0f b6 34 23	 movzx	 esi, BYTE PTR [rbx+r12]
  004cf	eb 11		 jmp	 SHORT $LN495@PyUnicode_@95
$LN311@PyUnicode_@95:
  004d1	49 83 ff 02	 cmp	 r15, 2
  004d5	75 07		 jne	 SHORT $LN309@PyUnicode_@95
  004d7	41 0f b7 34 5c	 movzx	 esi, WORD PTR [r12+rbx*2]
  004dc	eb 04		 jmp	 SHORT $LN495@PyUnicode_@95
$LN309@PyUnicode_@95:
  004de	41 8b 34 9c	 mov	 esi, DWORD PTR [r12+rbx*4]
$LN495@PyUnicode_@95:

; 13681:                     if (c < '0' || c > '9')

  004e2	8d 7e d0	 lea	 edi, DWORD PTR [rsi-48]
  004e5	48 ff c3	 inc	 rbx
  004e8	83 ff 09	 cmp	 edi, 9
  004eb	77 45		 ja	 SHORT $LN481@PyUnicode_@95

; 13682:                         break;
; 13683:                     /* Since c is unsigned, the RHS would end up as unsigned,
; 13684:                        mixing signed and unsigned comparison. Since c is between
; 13685:                        '0' and '9', casting to int is safe. */
; 13686:                     if (width > (PY_SSIZE_T_MAX - ((int)c - '0')) / 10) {

  004ed	8d 46 d0	 lea	 eax, DWORD PTR [rsi-48]
  004f0	48 63 c8	 movsxd	 rcx, eax
  004f3	49 8b c2	 mov	 rax, r10
  004f6	48 2b d1	 sub	 rdx, rcx
  004f9	48 f7 ea	 imul	 rdx
  004fc	48 c1 fa 02	 sar	 rdx, 2
  00500	48 8b c2	 mov	 rax, rdx
  00503	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00507	48 03 d0	 add	 rdx, rax
  0050a	4c 3b ca	 cmp	 r9, rdx
  0050d	0f 8f e9 0b 00
	00		 jg	 $LN385@PyUnicode_@95

; 13689:                         goto onError;
; 13690:                     }
; 13691:                     width = width*10 + (c - '0');

  00513	4b 8d 0c 89	 lea	 rcx, QWORD PTR [r9+r9*4]
  00517	49 ff c8	 dec	 r8
  0051a	48 ba ff ff ff
	ff ff ff ff 7f	 mov	 rdx, 9223372036854775807 ; 7fffffffffffffffH
  00524	4c 8d 0c 4f	 lea	 r9, QWORD PTR [rdi+rcx*2]
  00528	4c 89 45 97	 mov	 QWORD PTR fmtcnt$1$[rbp-169], r8
  0052c	4c 89 4d 9f	 mov	 QWORD PTR sublen$3$[rbp-169], r9
  00530	79 92		 jns	 SHORT $LL228@PyUnicode_@95
$LN481@PyUnicode_@95:

; 13676:             }
; 13677:             else if (c >= '0' && c <= '9') {

  00532	4c 8b 4d 6f	 mov	 r9, QWORD PTR args$[rbp-169]
$LN384@PyUnicode_@95:

; 13692:                 }
; 13693:             }
; 13694:             if (c == '.') {
; 13695:                 prec = 0;

  00536	33 c9		 xor	 ecx, ecx
  00538	83 fe 2e	 cmp	 esi, 46			; 0000002eH
  0053b	0f 85 70 01 00
	00		 jne	 $LN386@PyUnicode_@95

; 13696:                 if (--fmtcnt >= 0)

  00541	49 ff c8	 dec	 r8
  00544	89 4d 67	 mov	 DWORD PTR prec$1$[rbp-169], ecx
  00547	4c 89 45 97	 mov	 QWORD PTR fmtcnt$1$[rbp-169], r8
  0054b	0f 88 4b 01 00
	00		 js	 $LN399@PyUnicode_@95

; 13697:                     c = PyUnicode_READ(fmtkind, fmt, fmtpos++);

  00551	49 83 ff 01	 cmp	 r15, 1
  00555	75 07		 jne	 SHORT $LN315@PyUnicode_@95
  00557	42 0f b6 34 23	 movzx	 esi, BYTE PTR [rbx+r12]
  0055c	eb 11		 jmp	 SHORT $LN496@PyUnicode_@95
$LN315@PyUnicode_@95:
  0055e	49 83 ff 02	 cmp	 r15, 2
  00562	75 07		 jne	 SHORT $LN313@PyUnicode_@95
  00564	41 0f b7 34 5c	 movzx	 esi, WORD PTR [r12+rbx*2]
  00569	eb 04		 jmp	 SHORT $LN496@PyUnicode_@95
$LN313@PyUnicode_@95:
  0056b	41 8b 34 9c	 mov	 esi, DWORD PTR [r12+rbx*4]
$LN496@PyUnicode_@95:
  0056f	48 ff c3	 inc	 rbx

; 13698:                 if (c == '*') {

  00572	83 fe 2a	 cmp	 esi, 42			; 0000002aH
  00575	0f 85 a6 00 00
	00		 jne	 $LN221@PyUnicode_@95

; 13699:                     v = getnextarg(args, arglen, &argidx);

  0057b	48 8b 55 ff	 mov	 rdx, QWORD PTR arglen$1$[rbp-169]
  0057f	4c 8d 45 f7	 lea	 r8, QWORD PTR argidx$[rbp-169]
  00583	49 8b c9	 mov	 rcx, r9
  00586	e8 00 00 00 00	 call	 getnextarg
  0058b	48 8b c8	 mov	 rcx, rax

; 13700:                     if (v == NULL)

  0058e	48 85 c0	 test	 rax, rax
  00591	0f 84 ed 0a 00
	00		 je	 $LN474@PyUnicode_@95

; 13701:                         goto onError;
; 13702:                     if (!PyLong_Check(v)) {

  00597	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0059b	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  005a5	0f 84 64 0b 00
	00		 je	 $LN397@PyUnicode_@95

; 13706:                     }
; 13707:                     prec = _PyLong_AsInt(v);

  005ab	e8 00 00 00 00	 call	 _PyLong_AsInt
  005b0	89 45 67	 mov	 DWORD PTR prec$1$[rbp-169], eax

; 13708:                     if (prec == -1 && PyErr_Occurred())

  005b3	83 f8 ff	 cmp	 eax, -1
  005b6	75 15		 jne	 SHORT $LN218@PyUnicode_@95
  005b8	e8 00 00 00 00	 call	 PyErr_Occurred
  005bd	48 85 c0	 test	 rax, rax
  005c0	0f 85 be 0a 00
	00		 jne	 $LN474@PyUnicode_@95

; 13711:                         prec = 0;

  005c6	33 c9		 xor	 ecx, ecx
  005c8	89 4d 67	 mov	 DWORD PTR prec$1$[rbp-169], ecx
  005cb	eb 0d		 jmp	 SHORT $LN217@PyUnicode_@95
$LN218@PyUnicode_@95:

; 13709:                         goto onError;
; 13710:                     if (prec < 0)

  005cd	85 c0		 test	 eax, eax
  005cf	79 07		 jns	 SHORT $LN486@PyUnicode_@95

; 13711:                         prec = 0;

  005d1	33 c9		 xor	 ecx, ecx
  005d3	89 4d 67	 mov	 DWORD PTR prec$1$[rbp-169], ecx
  005d6	eb 02		 jmp	 SHORT $LN217@PyUnicode_@95
$LN486@PyUnicode_@95:

; 13558:     }
; 13559:     if (PyMapping_Check(args) && !PyTuple_Check(args) && !PyUnicode_Check(args))

  005d8	33 c9		 xor	 ecx, ecx
$LN217@PyUnicode_@95:

; 13712:                     if (--fmtcnt >= 0)

  005da	4c 8b 45 97	 mov	 r8, QWORD PTR fmtcnt$1$[rbp-169]
  005de	49 ff c8	 dec	 r8
  005e1	4c 89 45 97	 mov	 QWORD PTR fmtcnt$1$[rbp-169], r8
  005e5	0f 88 b1 00 00
	00		 js	 $LN399@PyUnicode_@95

; 13713:                         c = PyUnicode_READ(fmtkind, fmt, fmtpos++);

  005eb	4c 8b 6d c7	 mov	 r13, QWORD PTR writer$[rbp-137]
  005ef	49 83 ff 01	 cmp	 r15, 1
  005f3	75 0d		 jne	 SHORT $LN319@PyUnicode_@95
  005f5	42 0f b6 34 23	 movzx	 esi, BYTE PTR [rbx+r12]
  005fa	48 ff c3	 inc	 rbx
  005fd	e9 af 00 00 00	 jmp	 $LN386@PyUnicode_@95
$LN319@PyUnicode_@95:
  00602	49 83 ff 02	 cmp	 r15, 2
  00606	75 0d		 jne	 SHORT $LN317@PyUnicode_@95
  00608	41 0f b7 34 5c	 movzx	 esi, WORD PTR [r12+rbx*2]
  0060d	48 ff c3	 inc	 rbx
  00610	e9 9c 00 00 00	 jmp	 $LN386@PyUnicode_@95
$LN317@PyUnicode_@95:
  00615	41 8b 34 9c	 mov	 esi, DWORD PTR [r12+rbx*4]
  00619	48 ff c3	 inc	 rbx

; 13714:                 }
; 13715:                 else if (c >= '0' && c <= '9') {

  0061c	e9 90 00 00 00	 jmp	 $LN386@PyUnicode_@95
$LN221@PyUnicode_@95:
  00621	8d 46 d0	 lea	 eax, DWORD PTR [rsi-48]
  00624	83 f8 09	 cmp	 eax, 9
  00627	0f 87 84 00 00
	00		 ja	 $LN386@PyUnicode_@95

; 13716:                     prec = c - '0';

  0062d	8d 7e d0	 lea	 edi, DWORD PTR [rsi-48]

; 13717:                     while (--fmtcnt >= 0) {

  00630	49 ff c8	 dec	 r8
  00633	89 7d 67	 mov	 DWORD PTR prec$1$[rbp-169], edi
  00636	4c 89 45 97	 mov	 QWORD PTR fmtcnt$1$[rbp-169], r8
  0063a	78 60		 js	 SHORT $LN399@PyUnicode_@95
  0063c	0f 1f 40 00	 npad	 4
$LL213@PyUnicode_@95:

; 13718:                         c = PyUnicode_READ(fmtkind, fmt, fmtpos++);

  00640	49 83 ff 01	 cmp	 r15, 1
  00644	75 07		 jne	 SHORT $LN323@PyUnicode_@95
  00646	42 0f b6 34 23	 movzx	 esi, BYTE PTR [rbx+r12]
  0064b	eb 11		 jmp	 SHORT $LN497@PyUnicode_@95
$LN323@PyUnicode_@95:
  0064d	49 83 ff 02	 cmp	 r15, 2
  00651	75 07		 jne	 SHORT $LN321@PyUnicode_@95
  00653	41 0f b7 34 5c	 movzx	 esi, WORD PTR [r12+rbx*2]
  00658	eb 04		 jmp	 SHORT $LN497@PyUnicode_@95
$LN321@PyUnicode_@95:
  0065a	41 8b 34 9c	 mov	 esi, DWORD PTR [r12+rbx*4]
$LN497@PyUnicode_@95:

; 13719:                         if (c < '0' || c > '9')

  0065e	8d 46 d0	 lea	 eax, DWORD PTR [rsi-48]
  00661	48 ff c3	 inc	 rbx
  00664	83 f8 09	 cmp	 eax, 9
  00667	77 46		 ja	 SHORT $LN485@PyUnicode_@95

; 13720:                             break;
; 13721:                         if (prec > (INT_MAX - ((int)c - '0')) / 10) {

  00669	b9 2f 00 00 80	 mov	 ecx, -2147483601	; ffffffff8000002fH
  0066e	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00673	2b ce		 sub	 ecx, esi
  00675	f7 e9		 imul	 ecx
  00677	c1 fa 02	 sar	 edx, 2
  0067a	8b c2		 mov	 eax, edx
  0067c	c1 e8 1f	 shr	 eax, 31
  0067f	03 d0		 add	 edx, eax
  00681	3b fa		 cmp	 edi, edx
  00683	0f 8f 92 0a 00
	00		 jg	 $LN387@PyUnicode_@95

; 13724:                             goto onError;
; 13725:                         }
; 13726:                         prec = prec*10 + (c - '0');

  00689	8d 04 bf	 lea	 eax, DWORD PTR [rdi+rdi*4]
  0068c	49 ff c8	 dec	 r8
  0068f	8d 7c 46 d0	 lea	 edi, DWORD PTR [rsi+rax*2-48]
  00693	4c 89 45 97	 mov	 QWORD PTR fmtcnt$1$[rbp-169], r8
  00697	89 7d 67	 mov	 DWORD PTR prec$1$[rbp-169], edi
  0069a	79 a4		 jns	 SHORT $LL213@PyUnicode_@95
$LN399@PyUnicode_@95:

; 13623:                 }
; 13624:                 keylen = fmtpos - keystart - 1;
; 13625:                 if (fmtcnt < 0 || pcount > 0) {
; 13626:                     PyErr_SetString(PyExc_ValueError,
; 13627:                                     "incomplete format key");

  0069c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError

; 13734:                 }
; 13735:             }
; 13736:             if (fmtcnt < 0) {
; 13737:                 PyErr_SetString(PyExc_ValueError,
; 13738:                                 "incomplete format");

  006a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@HHCGKOAC@incomplete?5format?$AA@
  006aa	e9 d0 09 00 00	 jmp	 $LN504@PyUnicode_@95
$LN485@PyUnicode_@95:

; 13558:     }
; 13559:     if (PyMapping_Check(args) && !PyTuple_Check(args) && !PyUnicode_Check(args))

  006af	33 c9		 xor	 ecx, ecx
$LN386@PyUnicode_@95:

; 13727:                     }
; 13728:                 }
; 13729:             } /* prec */
; 13730:             if (fmtcnt >= 0) {

  006b1	4d 85 c0	 test	 r8, r8
  006b4	78 e6		 js	 SHORT $LN399@PyUnicode_@95

; 13731:                 if (c == 'h' || c == 'l' || c == 'L') {

  006b6	83 fe 68	 cmp	 esi, 104		; 00000068H
  006b9	74 0a		 je	 SHORT $LN206@PyUnicode_@95
  006bb	83 fe 6c	 cmp	 esi, 108		; 0000006cH
  006be	74 05		 je	 SHORT $LN206@PyUnicode_@95
  006c0	83 fe 4c	 cmp	 esi, 76			; 0000004cH
  006c3	75 2a		 jne	 SHORT $LN326@PyUnicode_@95
$LN206@PyUnicode_@95:

; 13732:                     if (--fmtcnt >= 0)

  006c5	49 ff c8	 dec	 r8
  006c8	4c 89 45 97	 mov	 QWORD PTR fmtcnt$1$[rbp-169], r8
  006cc	78 ce		 js	 SHORT $LN399@PyUnicode_@95

; 13733:                         c = PyUnicode_READ(fmtkind, fmt, fmtpos++);

  006ce	49 83 ff 01	 cmp	 r15, 1
  006d2	75 07		 jne	 SHORT $LN327@PyUnicode_@95
  006d4	42 0f b6 34 23	 movzx	 esi, BYTE PTR [rbx+r12]
  006d9	eb 11		 jmp	 SHORT $LN498@PyUnicode_@95
$LN327@PyUnicode_@95:
  006db	49 83 ff 02	 cmp	 r15, 2
  006df	75 07		 jne	 SHORT $LN325@PyUnicode_@95
  006e1	41 0f b7 34 5c	 movzx	 esi, WORD PTR [r12+rbx*2]
  006e6	eb 04		 jmp	 SHORT $LN498@PyUnicode_@95
$LN325@PyUnicode_@95:
  006e8	41 8b 34 9c	 mov	 esi, DWORD PTR [r12+rbx*4]
$LN498@PyUnicode_@95:
  006ec	48 ff c3	 inc	 rbx
$LN326@PyUnicode_@95:

; 13739:                 goto onError;
; 13740:             }
; 13741:             if (fmtcnt == 0)

  006ef	0f b6 45 d7	 movzx	 eax, BYTE PTR writer$[rbp-121]
  006f3	4d 85 c0	 test	 r8, r8
  006f6	0f 44 c1	 cmove	 eax, ecx
  006f9	88 45 d7	 mov	 BYTE PTR writer$[rbp-121], al

; 13742:                 writer.overallocate = 0;
; 13743: 
; 13744:             if (c == '%') {

  006fc	83 fe 25	 cmp	 esi, 37			; 00000025H
  006ff	75 73		 jne	 SHORT $LN202@PyUnicode_@95

; 13745:                 if (_PyUnicodeWriter_Prepare(&writer, 1, '%') == -1)

  00701	39 75 bb	 cmp	 DWORD PTR writer$[rbp-149], esi
  00704	72 0d		 jb	 SHORT $LN329@PyUnicode_@95
  00706	48 8b 45 bf	 mov	 rax, QWORD PTR writer$[rbp-145]
  0070a	49 2b c5	 sub	 rax, r13
  0070d	48 83 f8 01	 cmp	 rax, 1
  00711	7d 27		 jge	 SHORT $LN487@PyUnicode_@95
$LN329@PyUnicode_@95:
  00713	bf 25 00 00 00	 mov	 edi, 37			; 00000025H
  00718	48 8d 4d a7	 lea	 rcx, QWORD PTR writer$[rbp-169]
  0071c	8d 57 dc	 lea	 edx, QWORD PTR [rdi-36]
  0071f	44 8b c7	 mov	 r8d, edi
  00722	e8 00 00 00 00	 call	 _PyUnicodeWriter_PrepareInternal
  00727	83 f8 ff	 cmp	 eax, -1
  0072a	0f 84 54 09 00
	00		 je	 $LN474@PyUnicode_@95
  00730	4c 8b 6d c7	 mov	 r13, QWORD PTR writer$[rbp-137]
  00734	4c 8b 45 97	 mov	 r8, QWORD PTR fmtcnt$1$[rbp-169]
  00738	eb 05		 jmp	 SHORT $LN430@PyUnicode_@95
$LN487@PyUnicode_@95:

; 13711:                         prec = 0;

  0073a	bf 25 00 00 00	 mov	 edi, 37			; 00000025H
$LN430@PyUnicode_@95:

; 13746:                     goto onError;
; 13747:                 PyUnicode_WRITE(writer.kind, writer.data, writer.pos, '%');

  0073f	8b 4d b7	 mov	 ecx, DWORD PTR writer$[rbp-153]
  00742	48 8b 45 af	 mov	 rax, QWORD PTR writer$[rbp-161]
  00746	ff c9		 dec	 ecx
  00748	74 11		 je	 SHORT $LN195@PyUnicode_@95
  0074a	ff c9		 dec	 ecx
  0074c	74 06		 je	 SHORT $LN194@PyUnicode_@95
  0074e	42 89 3c a8	 mov	 DWORD PTR [rax+r13*4], edi
  00752	eb 0c		 jmp	 SHORT $LN199@PyUnicode_@95
$LN194@PyUnicode_@95:
  00754	66 42 89 3c 68	 mov	 WORD PTR [rax+r13*2], di
  00759	eb 05		 jmp	 SHORT $LN199@PyUnicode_@95
$LN195@PyUnicode_@95:
  0075b	42 c6 04 28 25	 mov	 BYTE PTR [rax+r13], 37	; 00000025H
$LN199@PyUnicode_@95:

; 13748:                 writer.pos += 1;

  00760	4c 8b 6d c7	 mov	 r13, QWORD PTR writer$[rbp-137]

; 13749:                 continue;

  00764	4c 8b 75 8f	 mov	 r14, QWORD PTR uformat$1$[rbp-169]
  00768	49 ff c5	 inc	 r13
  0076b	4c 89 6d c7	 mov	 QWORD PTR writer$[rbp-137], r13
  0076f	e9 d3 08 00 00	 jmp	 $LN21@PyUnicode_@95
$LN202@PyUnicode_@95:

; 13750:             }
; 13751: 
; 13752:             v = getnextarg(args, arglen, &argidx);

  00774	4c 8b 65 6f	 mov	 r12, QWORD PTR args$[rbp-169]
  00778	48 8b 55 ff	 mov	 rdx, QWORD PTR arglen$1$[rbp-169]
  0077c	4c 8d 45 f7	 lea	 r8, QWORD PTR argidx$[rbp-169]
  00780	49 8b cc	 mov	 rcx, r12
  00783	e8 00 00 00 00	 call	 getnextarg
  00788	48 8b f8	 mov	 rdi, rax

; 13753:             if (v == NULL)

  0078b	48 85 c0	 test	 rax, rax
  0078e	0f 84 6e 0a 00
	00		 je	 $LN468@PyUnicode_@95

; 13754:                 goto onError;
; 13755: 
; 13756:             sign = 0;
; 13757:             signchar = '\0';
; 13758:             fill = ' ';

  00794	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00799	45 33 ed	 xor	 r13d, r13d
  0079c	44 8b e0	 mov	 r12d, eax
  0079f	89 45 df	 mov	 DWORD PTR fill$1$[rbp-169], eax

; 13759:             switch (c) {

  007a2	8d 46 bb	 lea	 eax, DWORD PTR [rsi-69]
  007a5	45 8b fd	 mov	 r15d, r13d
  007a8	44 89 6d 7f	 mov	 DWORD PTR signchar$1$[rbp-169], r13d
  007ac	83 f8 33	 cmp	 eax, 51			; 00000033H
  007af	0f 87 ee 09 00
	00		 ja	 $LN144@PyUnicode_@95
  007b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  007bc	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN438@PyUnicode_@95[rdx+rax]
  007c4	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN439@PyUnicode_@95[rdx+rax*4]
  007cb	48 03 ca	 add	 rcx, rdx
  007ce	ff e1		 jmp	 rcx
$LN189@PyUnicode_@95:

; 13760: 
; 13761:             case 's':
; 13762:             case 'r':
; 13763:             case 'a':
; 13764:                 if (PyLong_CheckExact(v) && width == -1 && prec == -1) {

  007d0	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  007d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyLong_Type
  007db	48 3b c1	 cmp	 rax, rcx
  007de	75 38		 jne	 SHORT $LN188@PyUnicode_@95
  007e0	48 83 7d 9f ff	 cmp	 QWORD PTR sublen$3$[rbp-169], -1
  007e5	75 31		 jne	 SHORT $LN188@PyUnicode_@95
  007e7	83 7d 67 ff	 cmp	 DWORD PTR prec$1$[rbp-169], -1
  007eb	75 2b		 jne	 SHORT $LN188@PyUnicode_@95
$LN176@PyUnicode_@95:

; 13765:                     /* Fast path */
; 13766:                     if (_PyLong_FormatWriter(&writer, v, 10, flags & F_ALT) == -1)

  007ed	41 b8 0a 00 00
	00		 mov	 r8d, 10
$LN512@PyUnicode_@95:
  007f3	41 83 e6 08	 and	 r14d, 8
  007f7	48 8d 4d a7	 lea	 rcx, QWORD PTR writer$[rbp-169]
  007fb	48 8b d7	 mov	 rdx, rdi
  007fe	45 8b ce	 mov	 r9d, r14d
  00801	e8 00 00 00 00	 call	 _PyLong_FormatWriter
$LN509@PyUnicode_@95:
  00806	83 f8 ff	 cmp	 eax, -1
  00809	0f 84 75 08 00
	00		 je	 $LN474@PyUnicode_@95

; 13767:                         goto onError;
; 13768:                     goto nextarg;

  0080f	4c 8b 6d c7	 mov	 r13, QWORD PTR writer$[rbp-137]
  00813	e9 c3 07 00 00	 jmp	 $LN499@PyUnicode_@95
$LN188@PyUnicode_@95:

; 13769:                 }
; 13770: 
; 13771:                 if (PyUnicode_CheckExact(v) && c == 's') {

  00818	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyUnicode_Type
  0081f	48 3b c1	 cmp	 rax, rcx
  00822	75 58		 jne	 SHORT $LN186@PyUnicode_@95
  00824	83 fe 73	 cmp	 esi, 115		; 00000073H
  00827	75 65		 jne	 SHORT $LN184@PyUnicode_@95

; 13772:                     temp = v;

  00829	4c 8b e7	 mov	 r12, rdi
  0082c	48 89 7d 87	 mov	 QWORD PTR temp$1$[rbp-169], rdi
  00830	48 89 7d e7	 mov	 QWORD PTR temp$[rbp-169], rdi

; 13773:                     Py_INCREF(temp);

  00834	e8 00 00 00 00	 call	 _Py_PXCTX
  00839	85 c0		 test	 eax, eax
  0083b	0f 85 b8 02 00
	00		 jne	 $LN453@PyUnicode_@95
  00841	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00848	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0084f	4c 8b cf	 mov	 r9, rdi
  00852	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00858	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00860	e8 00 00 00 00	 call	 _PyParallel_Guard
  00865	85 c0		 test	 eax, eax
  00867	75 0a		 jne	 SHORT $LN349@PyUnicode_@95
  00869	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0086d	0f 84 86 02 00
	00		 je	 $LN453@PyUnicode_@95
$LN349@PyUnicode_@95:
  00873	48 ff 47 50	 inc	 QWORD PTR [rdi+80]

; 13774:                 }
; 13775:                 else {

  00877	e9 7d 02 00 00	 jmp	 $LN453@PyUnicode_@95
$LN186@PyUnicode_@95:

; 13776:                     if (c == 's')

  0087c	83 fe 73	 cmp	 esi, 115		; 00000073H
  0087f	75 0d		 jne	 SHORT $LN184@PyUnicode_@95

; 13777:                         temp = PyObject_Str(v);

  00881	48 8b cf	 mov	 rcx, rdi
  00884	e8 00 00 00 00	 call	 PyObject_Str
  00889	e9 60 02 00 00	 jmp	 $LN511@PyUnicode_@95
$LN184@PyUnicode_@95:

; 13778:                     else if (c == 'r')
; 13779:                         temp = PyObject_Repr(v);

  0088e	48 8b cf	 mov	 rcx, rdi
  00891	83 fe 72	 cmp	 esi, 114		; 00000072H
  00894	75 0a		 jne	 SHORT $LN182@PyUnicode_@95
  00896	e8 00 00 00 00	 call	 PyObject_Repr

; 13780:                     else

  0089b	e9 4e 02 00 00	 jmp	 $LN511@PyUnicode_@95
$LN182@PyUnicode_@95:

; 13781:                         temp = PyObject_ASCII(v);

  008a0	e8 00 00 00 00	 call	 PyObject_ASCII

; 13782:                 }
; 13783:                 break;

  008a5	e9 44 02 00 00	 jmp	 $LN511@PyUnicode_@95
$LN180@PyUnicode_@95:

; 13784: 
; 13785:             case 'i':
; 13786:             case 'd':
; 13787:             case 'u':
; 13788:             case 'o':
; 13789:             case 'x':
; 13790:             case 'X':
; 13791:                 if (PyLong_CheckExact(v)
; 13792:                     && width == -1 && prec == -1
; 13793:                     && !(flags & (F_SIGN | F_BLANK)))

  008aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  008b1	48 39 47 58	 cmp	 QWORD PTR [rdi+88], rax
  008b5	75 4c		 jne	 SHORT $LN177@PyUnicode_@95
  008b7	48 83 7d 9f ff	 cmp	 QWORD PTR sublen$3$[rbp-169], -1
  008bc	75 45		 jne	 SHORT $LN177@PyUnicode_@95
  008be	83 7d 67 ff	 cmp	 DWORD PTR prec$1$[rbp-169], -1
  008c2	75 3f		 jne	 SHORT $LN177@PyUnicode_@95
  008c4	41 f6 c6 06	 test	 r14b, 6
  008c8	75 39		 jne	 SHORT $LN177@PyUnicode_@95

; 13794:                 {
; 13795:                     /* Fast path */
; 13796:                     switch(c)

  008ca	83 fe 64	 cmp	 esi, 100		; 00000064H
  008cd	0f 84 1a ff ff
	ff		 je	 $LN176@PyUnicode_@95
  008d3	83 fe 69	 cmp	 esi, 105		; 00000069H
  008d6	0f 84 11 ff ff
	ff		 je	 $LN176@PyUnicode_@95
  008dc	83 fe 6f	 cmp	 esi, 111		; 0000006fH
  008df	74 17		 je	 SHORT $LN172@PyUnicode_@95
  008e1	83 fe 75	 cmp	 esi, 117		; 00000075H
  008e4	0f 84 03 ff ff
	ff		 je	 $LN176@PyUnicode_@95
  008ea	83 fe 78	 cmp	 esi, 120		; 00000078H
  008ed	75 14		 jne	 SHORT $LN177@PyUnicode_@95

; 13797:                     {
; 13798:                     case 'd':
; 13799:                     case 'i':
; 13800:                     case 'u':
; 13801:                         if (_PyLong_FormatWriter(&writer, v, 10, flags & F_ALT) == -1)
; 13802:                             goto onError;
; 13803:                         goto nextarg;
; 13804:                     case 'x':
; 13805:                         if (_PyLong_FormatWriter(&writer, v, 16, flags & F_ALT) == -1)

  008ef	44 8d 46 98	 lea	 r8d, QWORD PTR [rsi-104]

; 13806:                             goto onError;
; 13807:                         goto nextarg;

  008f3	e9 fb fe ff ff	 jmp	 $LN512@PyUnicode_@95
$LN172@PyUnicode_@95:

; 13808:                     case 'o':
; 13809:                         if (_PyLong_FormatWriter(&writer, v, 8, flags & F_ALT) == -1)

  008f8	41 b8 08 00 00
	00		 mov	 r8d, 8

; 13810:                             goto onError;
; 13811:                         goto nextarg;

  008fe	e9 f0 fe ff ff	 jmp	 $LN512@PyUnicode_@95
$LN177@PyUnicode_@95:

; 13812:                     default:
; 13813:                         break;
; 13814:                     }
; 13815:                 }
; 13816: 
; 13817:                 isnumok = 0;
; 13818:                 if (PyNumber_Check(v)) {

  00903	48 8b cf	 mov	 rcx, rdi
  00906	e8 00 00 00 00	 call	 PyNumber_Check
  0090b	85 c0		 test	 eax, eax
  0090d	0f 84 20 08 00
	00		 je	 $LN406@PyUnicode_@95

; 13819:                     PyObject *iobj=NULL;
; 13820: 
; 13821:                     if (PyLong_Check(v)) {

  00913	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00917	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00921	74 40		 je	 SHORT $LN168@PyUnicode_@95

; 13822:                         iobj = v;

  00923	4c 8b e7	 mov	 r12, rdi

; 13823:                         Py_INCREF(iobj);

  00926	e8 00 00 00 00	 call	 _Py_PXCTX
  0092b	85 c0		 test	 eax, eax
  0092d	75 3f		 jne	 SHORT $LN167@PyUnicode_@95
  0092f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00936	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0093d	4c 8b cf	 mov	 r9, rdi
  00940	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00946	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0094e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00953	85 c0		 test	 eax, eax
  00955	75 06		 jne	 SHORT $LN353@PyUnicode_@95
  00957	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0095b	74 11		 je	 SHORT $LN167@PyUnicode_@95
$LN353@PyUnicode_@95:
  0095d	48 ff 47 50	 inc	 QWORD PTR [rdi+80]

; 13824:                     }
; 13825:                     else {

  00961	eb 0b		 jmp	 SHORT $LN167@PyUnicode_@95
$LN168@PyUnicode_@95:

; 13826:                         iobj = PyNumber_Long(v);

  00963	48 8b cf	 mov	 rcx, rdi
  00966	e8 00 00 00 00	 call	 PyNumber_Long
  0096b	4c 8b e0	 mov	 r12, rax
$LN167@PyUnicode_@95:

; 13827:                     }
; 13828:                     if (iobj!=NULL) {

  0096e	4d 85 e4	 test	 r12, r12
  00971	0f 84 bc 07 00
	00		 je	 $LN406@PyUnicode_@95

; 13829:                         if (PyLong_Check(iobj)) {

  00977	49 8b 4c 24 58	 mov	 rcx, QWORD PTR [r12+88]
  0097c	f7 81 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rcx+256], 16777216 ; 01000000H

; 13830:                             isnumok = 1;
; 13831:                             sign = 1;
; 13832:                             temp = formatlong(iobj, flags, prec, (c == 'i'? 'd': c));

  00986	49 8b cc	 mov	 rcx, r12
  00989	0f 84 9f 07 00
	00		 je	 $LN165@PyUnicode_@95
  0098f	8b 7d 67	 mov	 edi, DWORD PTR prec$1$[rbp-169]
  00992	44 8b ce	 mov	 r9d, esi
  00995	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  0099a	83 fe 69	 cmp	 esi, 105		; 00000069H
  0099d	41 8b d6	 mov	 edx, r14d
  009a0	44 8b c7	 mov	 r8d, edi
  009a3	44 0f 44 c8	 cmove	 r9d, eax
  009a7	41 bf 01 00 00
	00		 mov	 r15d, 1
  009ad	e8 00 00 00 00	 call	 formatlong

; 13833:                             Py_DECREF(iobj);

  009b2	49 8b cc	 mov	 rcx, r12
  009b5	48 89 45 87	 mov	 QWORD PTR temp$1$[rbp-169], rax
  009b9	48 89 45 e7	 mov	 QWORD PTR temp$[rbp-169], rax
  009bd	e8 00 00 00 00	 call	 _Py_DecRef

; 13848:                 break;

  009c2	4c 8b 65 87	 mov	 r12, QWORD PTR temp$1$[rbp-169]
  009c6	41 f6 c6 10	 test	 r14b, 16
  009ca	0f 84 2c 01 00
	00		 je	 $LN190@PyUnicode_@95

; 13845:                 }
; 13846:                 if (flags & F_ZERO)
; 13847:                     fill = '0';

  009d0	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  009d5	89 45 df	 mov	 DWORD PTR fill$1$[rbp-169], eax

; 13848:                 break;

  009d8	e9 1f 01 00 00	 jmp	 $LN190@PyUnicode_@95
$LN161@PyUnicode_@95:

; 13849: 
; 13850:             case 'e':
; 13851:             case 'E':
; 13852:             case 'f':
; 13853:             case 'F':
; 13854:             case 'g':
; 13855:             case 'G':
; 13856:                 if (width == -1 && prec == -1
; 13857:                     && !(flags & (F_SIGN | F_BLANK)))

  009dd	48 83 7d 9f ff	 cmp	 QWORD PTR sublen$3$[rbp-169], -1
  009e2	8b 4d 67	 mov	 ecx, DWORD PTR prec$1$[rbp-169]
  009e5	75 2f		 jne	 SHORT $LN160@PyUnicode_@95
  009e7	83 f9 ff	 cmp	 ecx, -1
  009ea	75 2a		 jne	 SHORT $LN160@PyUnicode_@95
  009ec	41 f6 c6 06	 test	 r14b, 6
  009f0	75 24		 jne	 SHORT $LN160@PyUnicode_@95

; 13858:                 {
; 13859:                     /* Fast path */
; 13860:                     if (formatfloat(v, flags, prec, c, NULL, &writer) == -1)

  009f2	48 8d 45 a7	 lea	 rax, QWORD PTR writer$[rbp-169]
  009f6	44 0b c1	 or	 r8d, ecx
  009f9	44 8b ce	 mov	 r9d, esi
  009fc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00a01	41 8b d6	 mov	 edx, r14d
  00a04	48 8b cf	 mov	 rcx, rdi
  00a07	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00a0c	e8 00 00 00 00	 call	 formatfloat

; 13861:                         goto onError;
; 13862:                     goto nextarg;

  00a11	e9 f0 fd ff ff	 jmp	 $LN509@PyUnicode_@95
$LN160@PyUnicode_@95:

; 13863:                 }
; 13864: 
; 13865:                 sign = 1;
; 13866:                 if (flags & F_ZERO)

  00a16	b8 30 00 00 00	 mov	 eax, 48			; 00000030H

; 13867:                     fill = '0';
; 13868:                 if (formatfloat(v, flags, prec, c, &temp, NULL) == -1)

  00a1b	44 8b c1	 mov	 r8d, ecx
  00a1e	41 f6 c6 10	 test	 r14b, 16
  00a22	44 0f 45 e0	 cmovne	 r12d, eax
  00a26	48 8d 45 e7	 lea	 rax, QWORD PTR temp$[rbp-169]
  00a2a	44 8b ce	 mov	 r9d, esi
  00a2d	41 8b d6	 mov	 edx, r14d
  00a30	48 8b cf	 mov	 rcx, rdi
  00a33	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  00a38	41 bf 01 00 00
	00		 mov	 r15d, 1
  00a3e	44 89 65 df	 mov	 DWORD PTR fill$1$[rbp-169], r12d
  00a42	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a47	e8 00 00 00 00	 call	 formatfloat
  00a4c	83 f8 ff	 cmp	 eax, -1
  00a4f	0f 84 02 07 00
	00		 je	 $LN435@PyUnicode_@95

; 13870:                 break;

  00a55	4c 8b 65 e7	 mov	 r12, QWORD PTR temp$[rbp-169]
  00a59	4c 89 65 87	 mov	 QWORD PTR temp$1$[rbp-169], r12
  00a5d	e9 97 00 00 00	 jmp	 $LN453@PyUnicode_@95
$LN156@PyUnicode_@95:

; 13871: 
; 13872:             case 'c':
; 13873:             {
; 13874:                 Py_UCS4 ch = formatchar(v);

  00a62	48 8b cf	 mov	 rcx, rdi
  00a65	e8 00 00 00 00	 call	 formatchar
  00a6a	8b f8		 mov	 edi, eax

; 13875:                 if (ch == (Py_UCS4) -1)

  00a6c	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00a6f	0f 84 0f 06 00
	00		 je	 $LN474@PyUnicode_@95

; 13876:                     goto onError;
; 13877:                 if (width == -1 && prec == -1) {

  00a75	48 83 7d 9f ff	 cmp	 QWORD PTR sublen$3$[rbp-169], -1
  00a7a	75 6b		 jne	 SHORT $LN154@PyUnicode_@95
  00a7c	83 7d 67 ff	 cmp	 DWORD PTR prec$1$[rbp-169], -1
  00a80	75 65		 jne	 SHORT $LN154@PyUnicode_@95

; 13878:                     /* Fast path */
; 13879:                     if (_PyUnicodeWriter_Prepare(&writer, 1, ch) == -1)

  00a82	3b 45 bb	 cmp	 eax, DWORD PTR writer$[rbp-149]
  00a85	77 11		 ja	 SHORT $LN331@PyUnicode_@95
  00a87	48 8b 4d bf	 mov	 rcx, QWORD PTR writer$[rbp-145]
  00a8b	48 8b 55 c7	 mov	 rdx, QWORD PTR writer$[rbp-137]
  00a8f	48 2b ca	 sub	 rcx, rdx
  00a92	48 83 f9 01	 cmp	 rcx, 1
  00a96	7d 1e		 jge	 SHORT $LN432@PyUnicode_@95
$LN331@PyUnicode_@95:
  00a98	48 8d 4d a7	 lea	 rcx, QWORD PTR writer$[rbp-169]
  00a9c	44 8b c0	 mov	 r8d, eax
  00a9f	ba 01 00 00 00	 mov	 edx, 1
  00aa4	e8 00 00 00 00	 call	 _PyUnicodeWriter_PrepareInternal
  00aa9	83 f8 ff	 cmp	 eax, -1
  00aac	0f 84 d2 05 00
	00		 je	 $LN474@PyUnicode_@95
  00ab2	48 8b 55 c7	 mov	 rdx, QWORD PTR writer$[rbp-137]
$LN432@PyUnicode_@95:

; 13880:                         goto onError;
; 13881:                     PyUnicode_WRITE(writer.kind, writer.data, writer.pos, ch);

  00ab6	8b 4d b7	 mov	 ecx, DWORD PTR writer$[rbp-153]
  00ab9	48 8b 45 af	 mov	 rax, QWORD PTR writer$[rbp-161]
  00abd	ff c9		 dec	 ecx
  00abf	74 0f		 je	 SHORT $LN147@PyUnicode_@95
  00ac1	ff c9		 dec	 ecx
  00ac3	74 05		 je	 SHORT $LN146@PyUnicode_@95
  00ac5	89 3c 90	 mov	 DWORD PTR [rax+rdx*4], edi
  00ac8	eb 0a		 jmp	 SHORT $LN151@PyUnicode_@95
$LN146@PyUnicode_@95:
  00aca	66 89 3c 50	 mov	 WORD PTR [rax+rdx*2], di
  00ace	eb 04		 jmp	 SHORT $LN151@PyUnicode_@95
$LN147@PyUnicode_@95:
  00ad0	40 88 3c 10	 mov	 BYTE PTR [rax+rdx], dil
$LN151@PyUnicode_@95:

; 13882:                     writer.pos += 1;

  00ad4	48 8b 7d c7	 mov	 rdi, QWORD PTR writer$[rbp-137]
  00ad8	48 ff c7	 inc	 rdi
  00adb	48 89 7d c7	 mov	 QWORD PTR writer$[rbp-137], rdi

; 13883:                     goto nextarg;

  00adf	4c 8b ef	 mov	 r13, rdi
  00ae2	e9 f4 04 00 00	 jmp	 $LN499@PyUnicode_@95
$LN154@PyUnicode_@95:

; 13884:                 }
; 13885:                 temp = PyUnicode_FromOrdinal(ch);

  00ae7	8b c8		 mov	 ecx, eax
  00ae9	e8 00 00 00 00	 call	 PyUnicode_FromOrdinal
$LN511@PyUnicode_@95:
  00aee	48 89 45 e7	 mov	 QWORD PTR temp$[rbp-169], rax
  00af2	48 89 45 87	 mov	 QWORD PTR temp$1$[rbp-169], rax
  00af6	4c 8b e0	 mov	 r12, rax
$LN453@PyUnicode_@95:

; 13760: 
; 13761:             case 's':
; 13762:             case 'r':
; 13763:             case 'a':
; 13764:                 if (PyLong_CheckExact(v) && width == -1 && prec == -1) {

  00af9	8b 7d 67	 mov	 edi, DWORD PTR prec$1$[rbp-169]
$LN190@PyUnicode_@95:

; 13897:             }
; 13898:             if (temp == NULL)

  00afc	4d 85 e4	 test	 r12, r12
  00aff	0f 84 7f 05 00
	00		 je	 $LN474@PyUnicode_@95

; 13899:                 goto onError;
; 13900:             assert (PyUnicode_Check(temp));
; 13901: 
; 13902:             if (width == -1 && prec == -1
; 13903:                 && !(flags & (F_SIGN | F_BLANK)))

  00b05	4c 8b 45 9f	 mov	 r8, QWORD PTR sublen$3$[rbp-169]
  00b09	49 83 f8 ff	 cmp	 r8, -1
  00b0d	75 29		 jne	 SHORT $LN142@PyUnicode_@95
  00b0f	41 3b f8	 cmp	 edi, r8d
  00b12	75 24		 jne	 SHORT $LN142@PyUnicode_@95
  00b14	41 f6 c6 06	 test	 r14b, 6
  00b18	75 1e		 jne	 SHORT $LN142@PyUnicode_@95

; 13904:             {
; 13905:                 /* Fast path */
; 13906:                 if (_PyUnicodeWriter_WriteStr(&writer, temp) == -1)

  00b1a	48 8d 4d a7	 lea	 rcx, QWORD PTR writer$[rbp-169]
  00b1e	49 8b d4	 mov	 rdx, r12
  00b21	e8 00 00 00 00	 call	 _PyUnicodeWriter_WriteStr
  00b26	83 f8 ff	 cmp	 eax, -1
  00b29	0f 84 55 05 00
	00		 je	 $LN474@PyUnicode_@95

; 13907:                     goto onError;
; 13908:                 goto nextarg;

  00b2f	4c 8b 6d c7	 mov	 r13, QWORD PTR writer$[rbp-137]
  00b33	e9 a7 04 00 00	 jmp	 $nextarg$143567
$LN142@PyUnicode_@95:

; 13909:             }
; 13910: 
; 13911:             if (PyUnicode_READY(temp) == -1) {

  00b38	41 f6 44 24 70
	80		 test	 BYTE PTR [r12+112], 128	; 00000080H
  00b3e	75 15		 jne	 SHORT $LN433@PyUnicode_@95
  00b40	49 8b cc	 mov	 rcx, r12
  00b43	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00b48	83 f8 ff	 cmp	 eax, -1
  00b4b	0f 84 12 06 00
	00		 je	 $LN412@PyUnicode_@95
  00b51	4c 8b 45 9f	 mov	 r8, QWORD PTR sublen$3$[rbp-169]
$LN433@PyUnicode_@95:

; 13914:             }
; 13915:             kind = PyUnicode_KIND(temp);

  00b55	41 8b 44 24 70	 mov	 eax, DWORD PTR [r12+112]
  00b5a	8b d0		 mov	 edx, eax
  00b5c	c1 ea 02	 shr	 edx, 2
  00b5f	83 e2 07	 and	 edx, 7

; 13916:             pbuf = PyUnicode_DATA(temp);

  00b62	a8 20		 test	 al, 32			; 00000020H
  00b64	74 18		 je	 SHORT $LN339@PyUnicode_@95
  00b66	a8 40		 test	 al, 64			; 00000040H
  00b68	74 0a		 je	 SHORT $LN337@PyUnicode_@95
  00b6a	49 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR [r12+128]
  00b72	eb 12		 jmp	 SHORT $LN340@PyUnicode_@95
$LN337@PyUnicode_@95:
  00b74	49 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR [r12+160]
  00b7c	eb 08		 jmp	 SHORT $LN340@PyUnicode_@95
$LN339@PyUnicode_@95:
  00b7e	49 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR [r12+160]
$LN340@PyUnicode_@95:

; 13917:             len = PyUnicode_GET_LENGTH(temp);

  00b86	4d 8b 6c 24 60	 mov	 r13, QWORD PTR [r12+96]

; 13918: 
; 13919:             if (c == 's' || c == 'r' || c == 'a') {

  00b8b	83 fe 73	 cmp	 esi, 115		; 00000073H
  00b8e	74 0a		 je	 SHORT $LN134@PyUnicode_@95
  00b90	83 fe 72	 cmp	 esi, 114		; 00000072H
  00b93	74 05		 je	 SHORT $LN134@PyUnicode_@95
  00b95	83 fe 61	 cmp	 esi, 97			; 00000061H
  00b98	75 0e		 jne	 SHORT $LN133@PyUnicode_@95
$LN134@PyUnicode_@95:

; 13920:                 if (prec >= 0 && len > prec)

  00b9a	85 ff		 test	 edi, edi
  00b9c	78 0a		 js	 SHORT $LN133@PyUnicode_@95
  00b9e	48 63 c7	 movsxd	 rax, edi
  00ba1	4c 3b e8	 cmp	 r13, rax
  00ba4	4c 0f 4f e8	 cmovg	 r13, rax
$LN133@PyUnicode_@95:

; 13921:                     len = prec;
; 13922:             }
; 13923: 
; 13924:             /* pbuf is initialized here. */
; 13925:             pindex = 0;

  00ba8	33 ff		 xor	 edi, edi
  00baa	44 8b f7	 mov	 r14d, edi

; 13926:             if (sign) {

  00bad	45 85 ff	 test	 r15d, r15d
  00bb0	74 54		 je	 SHORT $LN450@PyUnicode_@95

; 13927:                 Py_UCS4 ch = PyUnicode_READ(kind, pbuf, pindex);

  00bb2	83 fa 01	 cmp	 edx, 1
  00bb5	75 05		 jne	 SHORT $LN343@PyUnicode_@95
  00bb7	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00bba	eb 0c		 jmp	 SHORT $LN342@PyUnicode_@95
$LN343@PyUnicode_@95:
  00bbc	83 fa 02	 cmp	 edx, 2
  00bbf	75 05		 jne	 SHORT $LN341@PyUnicode_@95
  00bc1	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00bc4	eb 02		 jmp	 SHORT $LN342@PyUnicode_@95
$LN341@PyUnicode_@95:
  00bc6	8b 01		 mov	 eax, DWORD PTR [rcx]
$LN342@PyUnicode_@95:

; 13928:                 if (ch == '-' || ch == '+') {

  00bc8	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00bcb	74 2d		 je	 SHORT $LN130@PyUnicode_@95
  00bcd	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00bd0	74 28		 je	 SHORT $LN130@PyUnicode_@95

; 13932:                 }
; 13933:                 else if (flags & F_SIGN)

  00bd2	44 8b 65 77	 mov	 r12d, DWORD PTR flags$1$[rbp-169]
  00bd6	41 f6 c4 02	 test	 r12b, 2
  00bda	74 09		 je	 SHORT $LN128@PyUnicode_@95

; 13934:                     signchar = '+';

  00bdc	c7 45 7f 2b 00
	00 00		 mov	 DWORD PTR signchar$1$[rbp-169], 43 ; 0000002bH
  00be3	eb 25		 jmp	 SHORT $LN125@PyUnicode_@95
$LN128@PyUnicode_@95:

; 13935:                 else if (flags & F_BLANK)

  00be5	41 f6 c4 04	 test	 r12b, 4
  00be9	74 0a		 je	 SHORT $LN126@PyUnicode_@95

; 13936:                     signchar = ' ';

  00beb	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00bf0	89 45 7f	 mov	 DWORD PTR signchar$1$[rbp-169], eax

; 13937:                 else

  00bf3	eb 15		 jmp	 SHORT $LN125@PyUnicode_@95
$LN126@PyUnicode_@95:

; 13938:                     sign = 0;

  00bf5	44 8b ff	 mov	 r15d, edi
  00bf8	eb 10		 jmp	 SHORT $LN125@PyUnicode_@95
$LN130@PyUnicode_@95:

; 13929:                     signchar = ch;

  00bfa	89 45 7f	 mov	 DWORD PTR signchar$1$[rbp-169], eax

; 13930:                     len--;

  00bfd	49 ff cd	 dec	 r13

; 13931:                     pindex++;

  00c00	41 be 01 00 00
	00		 mov	 r14d, 1
$LN450@PyUnicode_@95:

; 14018:                 writer.pos += sublen;

  00c06	44 8b 65 77	 mov	 r12d, DWORD PTR flags$1$[rbp-169]
$LN125@PyUnicode_@95:

; 13939:             }
; 13940:             if (width < len)

  00c0a	4d 3b c5	 cmp	 r8, r13

; 13941:                 width = len;
; 13942: 
; 13943:             /* Compute the length and maximum character of the
; 13944:                written characters */
; 13945:             bufmaxchar = 127;

  00c0d	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00c12	4d 0f 4c c5	 cmovl	 r8, r13

; 13946:             if (!(flags & F_LJUST)) {

  00c16	41 83 e4 01	 and	 r12d, 1
  00c1a	8b f9		 mov	 edi, ecx
  00c1c	4c 89 45 9f	 mov	 QWORD PTR sublen$3$[rbp-169], r8
  00c20	75 1d		 jne	 SHORT $LN119@PyUnicode_@95

; 13947:                 if (sign) {

  00c22	45 85 ff	 test	 r15d, r15d
  00c25	74 09		 je	 SHORT $LN122@PyUnicode_@95

; 13948:                     if ((width-1) > len)

  00c27	49 8d 40 ff	 lea	 rax, QWORD PTR [r8-1]
  00c2b	49 3b c5	 cmp	 rax, r13

; 13949:                         bufmaxchar = Py_MAX(bufmaxchar, fill);
; 13950:                 }
; 13951:                 else {

  00c2e	eb 03		 jmp	 SHORT $LN500@PyUnicode_@95
$LN122@PyUnicode_@95:

; 13952:                     if (width > len)

  00c30	4d 3b c5	 cmp	 r8, r13
$LN500@PyUnicode_@95:
  00c33	7e 0a		 jle	 SHORT $LN119@PyUnicode_@95

; 13953:                         bufmaxchar = Py_MAX(bufmaxchar, fill);

  00c35	8b 45 df	 mov	 eax, DWORD PTR fill$1$[rbp-169]
  00c38	8b f8		 mov	 edi, eax
  00c3a	3b c1		 cmp	 eax, ecx
  00c3c	0f 42 f9	 cmovb	 edi, ecx
$LN119@PyUnicode_@95:

; 13954:                 }
; 13955:             }
; 13956:             maxchar = _PyUnicode_FindMaxChar(temp, 0, pindex+len);

  00c3f	48 8b 4d 87	 mov	 rcx, QWORD PTR temp$1$[rbp-169]
  00c43	4f 8d 04 2e	 lea	 r8, QWORD PTR [r14+r13]
  00c47	33 d2		 xor	 edx, edx
  00c49	e8 00 00 00 00	 call	 _PyUnicode_FindMaxChar

; 13957:             bufmaxchar = Py_MAX(bufmaxchar, maxchar);
; 13958: 
; 13959:             buflen = width;

  00c4e	4c 8b 4d 9f	 mov	 r9, QWORD PTR sublen$3$[rbp-169]
  00c52	3b f8		 cmp	 edi, eax
  00c54	44 8b c0	 mov	 r8d, eax
  00c57	49 8b d1	 mov	 rdx, r9
  00c5a	44 0f 47 c7	 cmova	 r8d, edi

; 13960:             if (sign && len == width)

  00c5e	45 85 ff	 test	 r15d, r15d
  00c61	74 09		 je	 SHORT $LN118@PyUnicode_@95
  00c63	4d 3b e9	 cmp	 r13, r9
  00c66	75 04		 jne	 SHORT $LN118@PyUnicode_@95

; 13961:                 buflen++;

  00c68	49 8d 51 01	 lea	 rdx, QWORD PTR [r9+1]
$LN118@PyUnicode_@95:

; 13962: 
; 13963:             if (_PyUnicodeWriter_Prepare(&writer, buflen, bufmaxchar) == -1)

  00c6c	48 8b 7d c7	 mov	 rdi, QWORD PTR writer$[rbp-137]
  00c70	48 89 7d 67	 mov	 QWORD PTR writer$2$[rbp-169], rdi
  00c74	44 3b 45 bb	 cmp	 r8d, DWORD PTR writer$[rbp-149]
  00c78	77 0c		 ja	 SHORT $LN345@PyUnicode_@95
  00c7a	48 8b 45 bf	 mov	 rax, QWORD PTR writer$[rbp-145]
  00c7e	48 2b c7	 sub	 rax, rdi
  00c81	48 3b d0	 cmp	 rdx, rax
  00c84	7e 23		 jle	 SHORT $LN434@PyUnicode_@95
$LN345@PyUnicode_@95:
  00c86	48 85 d2	 test	 rdx, rdx
  00c89	74 1e		 je	 SHORT $LN434@PyUnicode_@95
  00c8b	48 8d 4d a7	 lea	 rcx, QWORD PTR writer$[rbp-169]
  00c8f	e8 00 00 00 00	 call	 _PyUnicodeWriter_PrepareInternal
  00c94	83 f8 ff	 cmp	 eax, -1
  00c97	0f 84 e7 03 00
	00		 je	 $LN474@PyUnicode_@95
  00c9d	48 8b 7d c7	 mov	 rdi, QWORD PTR writer$[rbp-137]
  00ca1	4c 8b 4d 9f	 mov	 r9, QWORD PTR sublen$3$[rbp-169]
  00ca5	48 89 7d 67	 mov	 QWORD PTR writer$2$[rbp-169], rdi
$LN434@PyUnicode_@95:

; 13964:                 goto onError;
; 13965: 
; 13966:             /* Write characters */
; 13967:             if (sign) {
; 13968:                 if (fill != ' ') {

  00ca9	8b 55 df	 mov	 edx, DWORD PTR fill$1$[rbp-169]
  00cac	45 85 ff	 test	 r15d, r15d
  00caf	74 43		 je	 SHORT $LN106@PyUnicode_@95
  00cb1	83 fa 20	 cmp	 edx, 32			; 00000020H
  00cb4	74 32		 je	 SHORT $LN115@PyUnicode_@95

; 13969:                     PyUnicode_WRITE(writer.kind, writer.data, writer.pos, signchar);

  00cb6	8b 4d b7	 mov	 ecx, DWORD PTR writer$[rbp-153]
  00cb9	48 8b 45 af	 mov	 rax, QWORD PTR writer$[rbp-161]
  00cbd	ff c9		 dec	 ecx
  00cbf	74 12		 je	 SHORT $LN109@PyUnicode_@95
  00cc1	ff c9		 dec	 ecx
  00cc3	8b 4d 7f	 mov	 ecx, DWORD PTR signchar$1$[rbp-169]
  00cc6	74 05		 je	 SHORT $LN108@PyUnicode_@95
  00cc8	89 0c b8	 mov	 DWORD PTR [rax+rdi*4], ecx
  00ccb	eb 0c		 jmp	 SHORT $LN113@PyUnicode_@95
$LN108@PyUnicode_@95:
  00ccd	66 89 0c 78	 mov	 WORD PTR [rax+rdi*2], cx
  00cd1	eb 06		 jmp	 SHORT $LN113@PyUnicode_@95
$LN109@PyUnicode_@95:
  00cd3	8b 4d 7f	 mov	 ecx, DWORD PTR signchar$1$[rbp-169]
  00cd6	88 0c 38	 mov	 BYTE PTR [rax+rdi], cl
$LN113@PyUnicode_@95:

; 13970:                     writer.pos += 1;

  00cd9	48 8b 7d c7	 mov	 rdi, QWORD PTR writer$[rbp-137]
  00cdd	48 ff c7	 inc	 rdi
  00ce0	48 89 7d 67	 mov	 QWORD PTR writer$2$[rbp-169], rdi
  00ce4	48 89 7d c7	 mov	 QWORD PTR writer$[rbp-137], rdi
$LN115@PyUnicode_@95:

; 13971:                 }
; 13972:                 if (width > len)

  00ce8	4d 3b cd	 cmp	 r9, r13
  00ceb	7e 07		 jle	 SHORT $LN106@PyUnicode_@95

; 13973:                     width--;

  00ced	49 ff c9	 dec	 r9
  00cf0	4c 89 4d 9f	 mov	 QWORD PTR sublen$3$[rbp-169], r9
$LN106@PyUnicode_@95:

; 13974:             }
; 13975:             if ((flags & F_ALT) && (c == 'x' || c == 'X' || c == 'o')) {

  00cf4	44 8b 45 77	 mov	 r8d, DWORD PTR flags$1$[rbp-169]
  00cf8	41 83 e0 08	 and	 r8d, 8
  00cfc	44 89 45 77	 mov	 DWORD PTR flags$1$[rbp-169], r8d
  00d00	0f 84 89 00 00
	00		 je	 $LN105@PyUnicode_@95
  00d06	83 fe 78	 cmp	 esi, 120		; 00000078H
  00d09	74 0a		 je	 SHORT $LN104@PyUnicode_@95
  00d0b	83 fe 58	 cmp	 esi, 88			; 00000058H
  00d0e	74 05		 je	 SHORT $LN104@PyUnicode_@95
  00d10	83 fe 6f	 cmp	 esi, 111		; 0000006fH
  00d13	75 7a		 jne	 SHORT $LN105@PyUnicode_@95
$LN104@PyUnicode_@95:

; 13976:                 assert(PyUnicode_READ(kind, pbuf, pindex) == '0');
; 13977:                 assert(PyUnicode_READ(kind, pbuf, pindex + 1) == c);
; 13978:                 if (fill != ' ') {

  00d15	83 fa 20	 cmp	 edx, 32			; 00000020H
  00d18	74 60		 je	 SHORT $LN103@PyUnicode_@95

; 13979:                     PyUnicode_WRITE(writer.kind, writer.data, writer.pos, '0');

  00d1a	8b 4d b7	 mov	 ecx, DWORD PTR writer$[rbp-153]
  00d1d	48 8b 45 af	 mov	 rax, QWORD PTR writer$[rbp-161]
  00d21	ff c9		 dec	 ecx
  00d23	74 14		 je	 SHORT $LN97@PyUnicode_@95
  00d25	ff c9		 dec	 ecx
  00d27	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00d2c	74 05		 je	 SHORT $LN96@PyUnicode_@95
  00d2e	89 0c b8	 mov	 DWORD PTR [rax+rdi*4], ecx
  00d31	eb 0a		 jmp	 SHORT $LN101@PyUnicode_@95
$LN96@PyUnicode_@95:
  00d33	66 89 0c 78	 mov	 WORD PTR [rax+rdi*2], cx
  00d37	eb 04		 jmp	 SHORT $LN101@PyUnicode_@95
$LN97@PyUnicode_@95:
  00d39	c6 04 38 30	 mov	 BYTE PTR [rax+rdi], 48	; 00000030H
$LN101@PyUnicode_@95:

; 13980:                     PyUnicode_WRITE(writer.kind, writer.data, writer.pos+1, c);

  00d3d	8b 4d b7	 mov	 ecx, DWORD PTR writer$[rbp-153]
  00d40	48 8b 45 af	 mov	 rax, QWORD PTR writer$[rbp-161]
  00d44	ff c9		 dec	 ecx
  00d46	74 15		 je	 SHORT $LN89@PyUnicode_@95
  00d48	ff c9		 dec	 ecx
  00d4a	48 8b 4d c7	 mov	 rcx, QWORD PTR writer$[rbp-137]
  00d4e	74 06		 je	 SHORT $LN88@PyUnicode_@95
  00d50	89 74 88 04	 mov	 DWORD PTR [rax+rcx*4+4], esi
  00d54	eb 10		 jmp	 SHORT $LN93@PyUnicode_@95
$LN88@PyUnicode_@95:
  00d56	66 89 74 48 02	 mov	 WORD PTR [rax+rcx*2+2], si
  00d5b	eb 09		 jmp	 SHORT $LN93@PyUnicode_@95
$LN89@PyUnicode_@95:
  00d5d	48 8b 4d c7	 mov	 rcx, QWORD PTR writer$[rbp-137]
  00d61	40 88 74 08 01	 mov	 BYTE PTR [rax+rcx+1], sil
$LN93@PyUnicode_@95:

; 13981:                     writer.pos += 2;

  00d66	48 8b 7d c7	 mov	 rdi, QWORD PTR writer$[rbp-137]
  00d6a	48 83 c7 02	 add	 rdi, 2

; 13982:                     pindex += 2;

  00d6e	49 83 c6 02	 add	 r14, 2
  00d72	48 89 7d 67	 mov	 QWORD PTR writer$2$[rbp-169], rdi
  00d76	48 89 7d c7	 mov	 QWORD PTR writer$[rbp-137], rdi
$LN103@PyUnicode_@95:

; 13983:                 }
; 13984:                 width -= 2;

  00d7a	49 83 e9 02	 sub	 r9, 2

; 13985:                 if (width < 0)

  00d7e	b8 00 00 00 00	 mov	 eax, 0
  00d83	4c 0f 48 c8	 cmovs	 r9, rax

; 13986:                     width = 0;
; 13987:                 len -= 2;

  00d87	49 83 ed 02	 sub	 r13, 2
  00d8b	4c 89 4d 9f	 mov	 QWORD PTR sublen$3$[rbp-169], r9
$LN105@PyUnicode_@95:

; 13988:             }
; 13989:             if (width > len && !(flags & F_LJUST)) {

  00d8f	4d 3b cd	 cmp	 r9, r13
  00d92	0f 8e b8 00 00
	00		 jle	 $LN455@PyUnicode_@95
  00d98	45 85 e4	 test	 r12d, r12d
  00d9b	0f 85 af 00 00
	00		 jne	 $LN455@PyUnicode_@95

; 13990:                 sublen = width - len;
; 13991:                 FILL(writer.kind, writer.data, fill, writer.pos, sublen);

  00da1	8b 4d b7	 mov	 ecx, DWORD PTR writer$[rbp-153]
  00da4	4d 2b cd	 sub	 r9, r13
  00da7	ff c9		 dec	 ecx
  00da9	4c 89 4d 9f	 mov	 QWORD PTR sublen$3$[rbp-169], r9
  00dad	74 5f		 je	 SHORT $LN79@PyUnicode_@95
  00daf	ff c9		 dec	 ecx
  00db1	74 31		 je	 SHORT $LN78@PyUnicode_@95
  00db3	83 f9 02	 cmp	 ecx, 2
  00db6	0f 85 84 00 00
	00		 jne	 $LN83@PyUnicode_@95
  00dbc	48 8b 45 af	 mov	 rax, QWORD PTR writer$[rbp-161]
  00dc0	48 8d 3c b8	 lea	 rdi, QWORD PTR [rax+rdi*4]
  00dc4	4d 85 c9	 test	 r9, r9
  00dc7	7e 73		 jle	 SHORT $LN449@PyUnicode_@95
  00dc9	8b c2		 mov	 eax, edx
  00dcb	49 8b c9	 mov	 rcx, r9

; 13993:                 width = len;

  00dce	4d 8b e5	 mov	 r12, r13
  00dd1	f3 ab		 rep stosd
  00dd3	48 8b 7d c7	 mov	 rdi, QWORD PTR writer$[rbp-137]
  00dd7	49 03 f9	 add	 rdi, r9
  00dda	48 89 7d 67	 mov	 QWORD PTR writer$2$[rbp-169], rdi
  00dde	48 89 7d c7	 mov	 QWORD PTR writer$[rbp-137], rdi
  00de2	eb 70		 jmp	 SHORT $LN441@PyUnicode_@95
$LN78@PyUnicode_@95:

; 13990:                 sublen = width - len;
; 13991:                 FILL(writer.kind, writer.data, fill, writer.pos, sublen);

  00de4	48 8b 45 af	 mov	 rax, QWORD PTR writer$[rbp-161]
  00de8	48 8d 3c 78	 lea	 rdi, QWORD PTR [rax+rdi*2]
  00dec	4d 85 c9	 test	 r9, r9
  00def	7e 4b		 jle	 SHORT $LN449@PyUnicode_@95
  00df1	0f b7 c2	 movzx	 eax, dx
  00df4	49 8b c9	 mov	 rcx, r9

; 13993:                 width = len;

  00df7	4d 8b e5	 mov	 r12, r13
  00dfa	66 f3 ab	 rep stosw
  00dfd	48 8b 7d c7	 mov	 rdi, QWORD PTR writer$[rbp-137]
  00e01	49 03 f9	 add	 rdi, r9
  00e04	48 89 7d 67	 mov	 QWORD PTR writer$2$[rbp-169], rdi
  00e08	48 89 7d c7	 mov	 QWORD PTR writer$[rbp-137], rdi
  00e0c	eb 46		 jmp	 SHORT $LN441@PyUnicode_@95
$LN79@PyUnicode_@95:

; 13990:                 sublen = width - len;
; 13991:                 FILL(writer.kind, writer.data, fill, writer.pos, sublen);

  00e0e	48 8b 4d af	 mov	 rcx, QWORD PTR writer$[rbp-161]
  00e12	0f b6 d2	 movzx	 edx, dl
  00e15	4d 8b c1	 mov	 r8, r9
  00e18	48 03 cf	 add	 rcx, rdi
  00e1b	e8 00 00 00 00	 call	 memset
  00e20	48 8b 7d c7	 mov	 rdi, QWORD PTR writer$[rbp-137]
  00e24	4c 8b 4d 9f	 mov	 r9, QWORD PTR sublen$3$[rbp-169]
  00e28	44 8b 45 77	 mov	 r8d, DWORD PTR flags$1$[rbp-169]

; 13992:                 writer.pos += sublen;

  00e2c	49 03 f9	 add	 rdi, r9

; 13993:                 width = len;

  00e2f	4d 8b e5	 mov	 r12, r13
  00e32	48 89 7d 67	 mov	 QWORD PTR writer$2$[rbp-169], rdi
  00e36	48 89 7d c7	 mov	 QWORD PTR writer$[rbp-137], rdi
  00e3a	eb 18		 jmp	 SHORT $LN441@PyUnicode_@95
$LN449@PyUnicode_@95:

; 14018:                 writer.pos += sublen;

  00e3c	48 8b 7d 67	 mov	 rdi, QWORD PTR writer$2$[rbp-169]
$LN83@PyUnicode_@95:

; 13992:                 writer.pos += sublen;

  00e40	49 03 f9	 add	 rdi, r9

; 13993:                 width = len;

  00e43	4d 8b e5	 mov	 r12, r13
  00e46	48 89 7d 67	 mov	 QWORD PTR writer$2$[rbp-169], rdi
  00e4a	48 89 7d c7	 mov	 QWORD PTR writer$[rbp-137], rdi
  00e4e	eb 04		 jmp	 SHORT $LN441@PyUnicode_@95
$LN455@PyUnicode_@95:

; 13899:                 goto onError;
; 13900:             assert (PyUnicode_Check(temp));
; 13901: 
; 13902:             if (width == -1 && prec == -1
; 13903:                 && !(flags & (F_SIGN | F_BLANK)))

  00e50	4c 8b 65 9f	 mov	 r12, QWORD PTR sublen$3$[rbp-169]
$LN441@PyUnicode_@95:

; 13994:             }
; 13995:             if (fill == ' ') {

  00e54	83 7d df 20	 cmp	 DWORD PTR fill$1$[rbp-169], 32 ; 00000020H
  00e58	0f 85 ab 00 00
	00		 jne	 $LN59@PyUnicode_@95

; 13996:                 if (sign) {

  00e5e	45 85 ff	 test	 r15d, r15d
  00e61	74 32		 je	 SHORT $LN68@PyUnicode_@95

; 13997:                     PyUnicode_WRITE(writer.kind, writer.data, writer.pos, signchar);

  00e63	8b 4d b7	 mov	 ecx, DWORD PTR writer$[rbp-153]
  00e66	48 8b 45 af	 mov	 rax, QWORD PTR writer$[rbp-161]
  00e6a	ff c9		 dec	 ecx
  00e6c	74 12		 je	 SHORT $LN62@PyUnicode_@95
  00e6e	ff c9		 dec	 ecx
  00e70	8b 4d 7f	 mov	 ecx, DWORD PTR signchar$1$[rbp-169]
  00e73	74 05		 je	 SHORT $LN61@PyUnicode_@95
  00e75	89 0c b8	 mov	 DWORD PTR [rax+rdi*4], ecx
  00e78	eb 0c		 jmp	 SHORT $LN66@PyUnicode_@95
$LN61@PyUnicode_@95:
  00e7a	66 89 0c 78	 mov	 WORD PTR [rax+rdi*2], cx
  00e7e	eb 06		 jmp	 SHORT $LN66@PyUnicode_@95
$LN62@PyUnicode_@95:
  00e80	8b 4d 7f	 mov	 ecx, DWORD PTR signchar$1$[rbp-169]
  00e83	88 0c 38	 mov	 BYTE PTR [rax+rdi], cl
$LN66@PyUnicode_@95:

; 13998:                     writer.pos += 1;

  00e86	48 8b 7d c7	 mov	 rdi, QWORD PTR writer$[rbp-137]
  00e8a	48 ff c7	 inc	 rdi
  00e8d	48 89 7d 67	 mov	 QWORD PTR writer$2$[rbp-169], rdi
  00e91	48 89 7d c7	 mov	 QWORD PTR writer$[rbp-137], rdi
$LN68@PyUnicode_@95:

; 13999:                 }
; 14000:                 if ((flags & F_ALT) && (c == 'x' || c == 'X' || c == 'o')) {

  00e95	45 85 c0	 test	 r8d, r8d
  00e98	74 6f		 je	 SHORT $LN59@PyUnicode_@95
  00e9a	83 fe 78	 cmp	 esi, 120		; 00000078H
  00e9d	74 0a		 je	 SHORT $LN57@PyUnicode_@95
  00e9f	83 fe 58	 cmp	 esi, 88			; 00000058H
  00ea2	74 05		 je	 SHORT $LN57@PyUnicode_@95
  00ea4	83 fe 6f	 cmp	 esi, 111		; 0000006fH
  00ea7	75 60		 jne	 SHORT $LN59@PyUnicode_@95
$LN57@PyUnicode_@95:

; 14001:                     assert(PyUnicode_READ(kind, pbuf, pindex) == '0');
; 14002:                     assert(PyUnicode_READ(kind, pbuf, pindex+1) == c);
; 14003:                     PyUnicode_WRITE(writer.kind, writer.data, writer.pos, '0');

  00ea9	8b 4d b7	 mov	 ecx, DWORD PTR writer$[rbp-153]
  00eac	48 8b 45 af	 mov	 rax, QWORD PTR writer$[rbp-161]
  00eb0	ff c9		 dec	 ecx
  00eb2	74 14		 je	 SHORT $LN52@PyUnicode_@95
  00eb4	ff c9		 dec	 ecx
  00eb6	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00ebb	74 05		 je	 SHORT $LN51@PyUnicode_@95
  00ebd	89 0c b8	 mov	 DWORD PTR [rax+rdi*4], ecx
  00ec0	eb 0a		 jmp	 SHORT $LN56@PyUnicode_@95
$LN51@PyUnicode_@95:
  00ec2	66 89 0c 78	 mov	 WORD PTR [rax+rdi*2], cx
  00ec6	eb 04		 jmp	 SHORT $LN56@PyUnicode_@95
$LN52@PyUnicode_@95:
  00ec8	c6 04 38 30	 mov	 BYTE PTR [rax+rdi], 48	; 00000030H
$LN56@PyUnicode_@95:

; 14004:                     PyUnicode_WRITE(writer.kind, writer.data, writer.pos+1, c);

  00ecc	8b 4d b7	 mov	 ecx, DWORD PTR writer$[rbp-153]
  00ecf	48 8b 45 af	 mov	 rax, QWORD PTR writer$[rbp-161]
  00ed3	ff c9		 dec	 ecx
  00ed5	74 15		 je	 SHORT $LN44@PyUnicode_@95
  00ed7	ff c9		 dec	 ecx
  00ed9	48 8b 4d c7	 mov	 rcx, QWORD PTR writer$[rbp-137]
  00edd	74 06		 je	 SHORT $LN43@PyUnicode_@95
  00edf	89 74 88 04	 mov	 DWORD PTR [rax+rcx*4+4], esi
  00ee3	eb 10		 jmp	 SHORT $LN48@PyUnicode_@95
$LN43@PyUnicode_@95:
  00ee5	66 89 74 48 02	 mov	 WORD PTR [rax+rcx*2+2], si
  00eea	eb 09		 jmp	 SHORT $LN48@PyUnicode_@95
$LN44@PyUnicode_@95:
  00eec	48 8b 4d c7	 mov	 rcx, QWORD PTR writer$[rbp-137]
  00ef0	40 88 74 08 01	 mov	 BYTE PTR [rax+rcx+1], sil
$LN48@PyUnicode_@95:

; 14005:                     writer.pos += 2;

  00ef5	48 8b 7d c7	 mov	 rdi, QWORD PTR writer$[rbp-137]
  00ef9	48 83 c7 02	 add	 rdi, 2

; 14006:                     pindex += 2;

  00efd	49 83 c6 02	 add	 r14, 2
  00f01	48 89 7d 67	 mov	 QWORD PTR writer$2$[rbp-169], rdi
  00f05	48 89 7d c7	 mov	 QWORD PTR writer$[rbp-137], rdi
$LN59@PyUnicode_@95:

; 14007:                 }
; 14008:             }
; 14009: 
; 14010:             if (len) {

  00f09	4d 85 ed	 test	 r13, r13
  00f0c	74 27		 je	 SHORT $LN41@PyUnicode_@95

; 14011:                 _PyUnicode_FastCopyCharacters(writer.buffer, writer.pos,
; 14012:                                               temp, pindex, len);

  00f0e	4c 8b 45 87	 mov	 r8, QWORD PTR temp$1$[rbp-169]
  00f12	48 8b 4d a7	 mov	 rcx, QWORD PTR writer$[rbp-169]
  00f16	4d 8b ce	 mov	 r9, r14
  00f19	48 8b d7	 mov	 rdx, rdi
  00f1c	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00f21	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 14013:                 writer.pos += len;

  00f26	48 8b 7d c7	 mov	 rdi, QWORD PTR writer$[rbp-137]
  00f2a	49 03 fd	 add	 rdi, r13
  00f2d	48 89 7d 67	 mov	 QWORD PTR writer$2$[rbp-169], rdi
  00f31	48 89 7d c7	 mov	 QWORD PTR writer$[rbp-137], rdi
$LN41@PyUnicode_@95:

; 14014:             }
; 14015:             if (width > len) {

  00f35	4d 3b e5	 cmp	 r12, r13
  00f38	0f 8e 99 00 00
	00		 jle	 $LN445@PyUnicode_@95

; 14016:                 sublen = width - len;
; 14017:                 FILL(writer.kind, writer.data, ' ', writer.pos, sublen);

  00f3e	8b 4d b7	 mov	 ecx, DWORD PTR writer$[rbp-153]
  00f41	4d 2b e5	 sub	 r12, r13
  00f44	ff c9		 dec	 ecx
  00f46	74 5b		 je	 SHORT $LN34@PyUnicode_@95
  00f48	ff c9		 dec	 ecx
  00f4a	74 2c		 je	 SHORT $LN33@PyUnicode_@95
  00f4c	83 f9 02	 cmp	 ecx, 2
  00f4f	75 7a		 jne	 SHORT $LN38@PyUnicode_@95
  00f51	48 8b 45 af	 mov	 rax, QWORD PTR writer$[rbp-161]
  00f55	48 8d 3c b8	 lea	 rdi, QWORD PTR [rax+rdi*4]
  00f59	4d 85 e4	 test	 r12, r12
  00f5c	7e 69		 jle	 SHORT $LN447@PyUnicode_@95
  00f5e	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00f63	49 8b cc	 mov	 rcx, r12
  00f66	f3 ab		 rep stosd
  00f68	48 8b 7d c7	 mov	 rdi, QWORD PTR writer$[rbp-137]

; 14018:                 writer.pos += sublen;

  00f6c	49 03 fc	 add	 rdi, r12
  00f6f	48 89 7d c7	 mov	 QWORD PTR writer$[rbp-137], rdi
  00f73	4c 8b ef	 mov	 r13, rdi
  00f76	eb 63		 jmp	 SHORT $LN499@PyUnicode_@95
$LN33@PyUnicode_@95:

; 14016:                 sublen = width - len;
; 14017:                 FILL(writer.kind, writer.data, ' ', writer.pos, sublen);

  00f78	48 8b 45 af	 mov	 rax, QWORD PTR writer$[rbp-161]
  00f7c	48 8d 3c 78	 lea	 rdi, QWORD PTR [rax+rdi*2]
  00f80	4d 85 e4	 test	 r12, r12
  00f83	7e 42		 jle	 SHORT $LN447@PyUnicode_@95
  00f85	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00f8a	49 8b cc	 mov	 rcx, r12
  00f8d	0f b7 c0	 movzx	 eax, ax
  00f90	66 f3 ab	 rep stosw
  00f93	48 8b 7d c7	 mov	 rdi, QWORD PTR writer$[rbp-137]

; 14018:                 writer.pos += sublen;

  00f97	49 03 fc	 add	 rdi, r12
  00f9a	48 89 7d c7	 mov	 QWORD PTR writer$[rbp-137], rdi
  00f9e	4c 8b ef	 mov	 r13, rdi
  00fa1	eb 38		 jmp	 SHORT $LN499@PyUnicode_@95
$LN34@PyUnicode_@95:

; 14016:                 sublen = width - len;
; 14017:                 FILL(writer.kind, writer.data, ' ', writer.pos, sublen);

  00fa3	48 8b 4d af	 mov	 rcx, QWORD PTR writer$[rbp-161]
  00fa7	4d 8b c4	 mov	 r8, r12
  00faa	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00faf	48 03 cf	 add	 rcx, rdi
  00fb2	e8 00 00 00 00	 call	 memset
  00fb7	48 8b 7d c7	 mov	 rdi, QWORD PTR writer$[rbp-137]

; 14018:                 writer.pos += sublen;

  00fbb	49 03 fc	 add	 rdi, r12
  00fbe	48 89 7d c7	 mov	 QWORD PTR writer$[rbp-137], rdi
  00fc2	4c 8b ef	 mov	 r13, rdi
  00fc5	eb 14		 jmp	 SHORT $LN499@PyUnicode_@95
$LN447@PyUnicode_@95:
  00fc7	48 8b 7d 67	 mov	 rdi, QWORD PTR writer$2$[rbp-169]
$LN38@PyUnicode_@95:
  00fcb	49 03 fc	 add	 rdi, r12
  00fce	48 89 7d c7	 mov	 QWORD PTR writer$[rbp-137], rdi
  00fd2	4c 8b ef	 mov	 r13, rdi
  00fd5	eb 04		 jmp	 SHORT $LN499@PyUnicode_@95
$LN445@PyUnicode_@95:

; 13542:     }
; 13543: 
; 13544:     fmt = PyUnicode_DATA(uformat);

  00fd7	4c 8b 6d 67	 mov	 r13, QWORD PTR writer$2$[rbp-169]
$LN499@PyUnicode_@95:
  00fdb	4c 8b 65 87	 mov	 r12, QWORD PTR temp$1$[rbp-169]
$nextarg$143567:

; 14019:             }
; 14020: 
; 14021: nextarg:
; 14022:             if (dict && (argidx < arglen) && c != '%') {

  00fdf	48 83 7d ef 00	 cmp	 QWORD PTR dict$1$[rbp-169], 0
  00fe4	74 0e		 je	 SHORT $LN23@PyUnicode_@95
  00fe6	48 8b 45 ff	 mov	 rax, QWORD PTR arglen$1$[rbp-169]
  00fea	48 39 45 f7	 cmp	 QWORD PTR argidx$[rbp-169], rax
  00fee	0f 8c 02 02 00
	00		 jl	 $LN414@PyUnicode_@95
$LN23@PyUnicode_@95:

; 14023:                 PyErr_SetString(PyExc_TypeError,
; 14024:                                 "not all arguments converted during string formatting");
; 14025:                 goto onError;
; 14026:             }
; 14027:             Py_CLEAR(temp);

  00ff4	4d 85 e4	 test	 r12, r12
  00ff7	74 3e		 je	 SHORT $LN22@PyUnicode_@95
  00ff9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  01000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@EFFLDOHP@PyUnicode_Format?$AA@
  01007	4d 8b cc	 mov	 r9, r12
  0100a	41 b8 cb 36 00
	00		 mov	 r8d, 14027		; 000036cbH
  01010	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  01018	e8 00 00 00 00	 call	 _PyParallel_Guard
  0101d	85 c0		 test	 eax, eax
  0101f	75 12		 jne	 SHORT $LN442@PyUnicode_@95
  01021	33 c0		 xor	 eax, eax
  01023	49 8b cc	 mov	 rcx, r12
  01026	48 89 45 87	 mov	 QWORD PTR temp$1$[rbp-169], rax
  0102a	48 89 45 e7	 mov	 QWORD PTR temp$[rbp-169], rax
  0102e	e8 00 00 00 00	 call	 _Py_DecRef
$LN442@PyUnicode_@95:
  01033	4c 8b 6d c7	 mov	 r13, QWORD PTR writer$[rbp-137]
$LN22@PyUnicode_@95:
  01037	4c 8b 65 07	 mov	 r12, QWORD PTR fmt$1$[rbp-169]
  0103b	4c 8b 7d 0f	 mov	 r15, QWORD PTR $T163765[rbp-169]
  0103f	4c 8b 75 8f	 mov	 r14, QWORD PTR uformat$1$[rbp-169]
$LN493@PyUnicode_@95:
  01043	4c 8b 45 97	 mov	 r8, QWORD PTR fmtcnt$1$[rbp-169]
$LN21@PyUnicode_@95:

; 13560:         dict = args;
; 13561: 
; 13562:     while (--fmtcnt >= 0) {

  01047	49 ff c8	 dec	 r8
  0104a	4c 89 45 97	 mov	 QWORD PTR fmtcnt$1$[rbp-169], r8
  0104e	0f 88 85 01 00
	00		 js	 $LN475@PyUnicode_@95
  01054	4c 8b 4d 6f	 mov	 r9, QWORD PTR args$[rbp-169]
  01058	48 8b 4d ef	 mov	 rcx, QWORD PTR dict$1$[rbp-169]
  0105c	e9 01 f1 ff ff	 jmp	 $LN501@PyUnicode_@95
$LN249@PyUnicode_@95:

; 13623:                 }
; 13624:                 keylen = fmtpos - keystart - 1;
; 13625:                 if (fmtcnt < 0 || pcount > 0) {
; 13626:                     PyErr_SetString(PyExc_ValueError,
; 13627:                                     "incomplete format key");

  01061	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  01068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@OJFHELCI@incomplete?5format?5key?$AA@

; 13628:                     goto onError;

  0106f	eb 0e		 jmp	 SHORT $LN504@PyUnicode_@95
$LN389@PyUnicode_@95:

; 13608:                     PyErr_SetString(PyExc_TypeError,
; 13609:                                     "format requires a mapping");

  01071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@OMCHAEPP@format?5requires?5a?5mapping?$AA@
$LN510@PyUnicode_@95:

; 14031:         PyErr_SetString(PyExc_TypeError,
; 14032:                         "not all arguments converted during string formatting");

  01078	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
$LN504@PyUnicode_@95:

; 13608:                     PyErr_SetString(PyExc_TypeError,
; 13609:                                     "format requires a mapping");

  0107f	e8 00 00 00 00	 call	 PyErr_SetString
$LN474@PyUnicode_@95:

; 13870:                 break;

  01084	4c 8b 6d 8f	 mov	 r13, QWORD PTR uformat$1$[rbp-169]
$LN477@PyUnicode_@95:
  01088	48 8b 7d 87	 mov	 rdi, QWORD PTR temp$1$[rbp-169]
$LN502@PyUnicode_@95:
  0108c	4c 8b 65 6f	 mov	 r12, QWORD PTR args$[rbp-169]
$onError$143400:

; 14043: 
; 14044:   onError:
; 14045:     Py_DECREF(uformat);

  01090	e8 00 00 00 00	 call	 _Py_PXCTX
  01095	85 c0		 test	 eax, eax
  01097	0f 85 86 01 00
	00		 jne	 $LN9@PyUnicode_@95
  0109d	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  010a1	a8 20		 test	 al, 32			; 00000020H
  010a3	0f 85 72 01 00
	00		 jne	 $LN361@PyUnicode_@95
  010a9	84 c0		 test	 al, al
  010ab	0f 88 6a 01 00
	00		 js	 $LN361@PyUnicode_@95
  010b1	a8 02		 test	 al, 2
  010b3	0f 85 6a 01 00
	00		 jne	 $LN9@PyUnicode_@95
  010b9	49 ff 4d 50	 dec	 QWORD PTR [r13+80]
  010bd	0f 85 60 01 00
	00		 jne	 $LN9@PyUnicode_@95
  010c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  010ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  010d1	4d 8b cd	 mov	 r9, r13
  010d4	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  010da	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  010e2	e8 00 00 00 00	 call	 _PyParallel_Guard
  010e7	49 8b cd	 mov	 rcx, r13
  010ea	85 c0		 test	 eax, eax
  010ec	0f 84 1d 01 00
	00		 je	 $LN366@PyUnicode_@95
  010f2	e8 00 00 00 00	 call	 _Px_Dealloc
  010f7	e9 27 01 00 00	 jmp	 $LN9@PyUnicode_@95
$LN385@PyUnicode_@95:

; 13623:                 }
; 13624:                 keylen = fmtpos - keystart - 1;
; 13625:                 if (fmtcnt < 0 || pcount > 0) {
; 13626:                     PyErr_SetString(PyExc_ValueError,
; 13627:                                     "incomplete format key");

  010fc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError

; 13687:                         PyErr_SetString(PyExc_ValueError,
; 13688:                                         "width too big");

  01103	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@JMPMPMIA@width?5too?5big?$AA@
  0110a	e9 70 ff ff ff	 jmp	 $LN504@PyUnicode_@95
$LN397@PyUnicode_@95:

; 13703:                         PyErr_SetString(PyExc_TypeError,
; 13704:                                         "* wants int");

  0110f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@HBDIHKFD@?$CK?5wants?5int?$AA@

; 13705:                         goto onError;

  01116	e9 5d ff ff ff	 jmp	 $LN510@PyUnicode_@95
$LN387@PyUnicode_@95:

; 13623:                 }
; 13624:                 keylen = fmtpos - keystart - 1;
; 13625:                 if (fmtcnt < 0 || pcount > 0) {
; 13626:                     PyErr_SetString(PyExc_ValueError,
; 13627:                                     "incomplete format key");

  0111b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError

; 13722:                             PyErr_SetString(PyExc_ValueError,
; 13723:                                             "prec too big");

  01122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@IKLONOJC@prec?5too?5big?$AA@
  01129	e9 51 ff ff ff	 jmp	 $LN504@PyUnicode_@95
$LN165@PyUnicode_@95:

; 13834:                         }
; 13835:                         else {
; 13836:                             Py_DECREF(iobj);

  0112e	e8 00 00 00 00	 call	 _Py_DecRef
$LN406@PyUnicode_@95:

; 13837:                         }
; 13838:                     }
; 13839:                 }
; 13840:                 if (!isnumok) {
; 13841:                     PyErr_Format(PyExc_TypeError,
; 13842:                                  "%%%c format: a number is required, "
; 13843:                                  "not %.200s", (char)c, Py_TYPE(v)->tp_name);

  01133	4c 8b 4f 58	 mov	 r9, QWORD PTR [rdi+88]
  01137	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0113e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@LIHIEEDL@?$CF?$CF?$CFc?5format?3?5a?5number?5is?5require@
  01145	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  01149	44 0f be c6	 movsx	 r8d, sil
  0114d	e8 00 00 00 00	 call	 PyErr_Format

; 13844:                     goto onError;

  01152	e9 2d ff ff ff	 jmp	 $LN474@PyUnicode_@95
$LN435@PyUnicode_@95:

; 13869:                     temp = NULL;

  01157	49 8b fd	 mov	 rdi, r13

; 13870:                 break;

  0115a	4c 8b 6d 8f	 mov	 r13, QWORD PTR uformat$1$[rbp-169]
  0115e	e9 29 ff ff ff	 jmp	 $LN502@PyUnicode_@95
$LN412@PyUnicode_@95:

; 13912:                 Py_CLEAR(temp);

  01163	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  0116a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@EFFLDOHP@PyUnicode_Format?$AA@
  01171	4d 8b cc	 mov	 r9, r12
  01174	41 b8 58 36 00
	00		 mov	 r8d, 13912		; 00003658H
  0117a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  01182	e8 00 00 00 00	 call	 _PyParallel_Guard
  01187	85 c0		 test	 eax, eax
  01189	0f 85 f5 fe ff
	ff		 jne	 $LN474@PyUnicode_@95
  0118f	49 8b cc	 mov	 rcx, r12
  01192	49 8b fd	 mov	 rdi, r13
  01195	e8 00 00 00 00	 call	 _Py_DecRef

; 13913:                 goto onError;

  0119a	4c 8b 6d 8f	 mov	 r13, QWORD PTR uformat$1$[rbp-169]
  0119e	e9 e9 fe ff ff	 jmp	 $LN502@PyUnicode_@95
$LN144@PyUnicode_@95:

; 13886:                 break;
; 13887:             }
; 13888: 
; 13889:             default:
; 13890:                 PyErr_Format(PyExc_ValueError,
; 13891:                              "unsupported format character '%c' (0x%x) "
; 13892:                              "at index %zd",
; 13893:                              (31<=c && c<=126) ? (char)c : '?',
; 13894:                              (int)c,
; 13895:                              fmtpos - 1);

  011a3	8d 46 e1	 lea	 eax, DWORD PTR [rsi-31]
  011a6	44 0f be c6	 movsx	 r8d, sil
  011aa	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  011ad	76 06		 jbe	 SHORT $LN334@PyUnicode_@95
  011af	41 b8 3f 00 00
	00		 mov	 r8d, 63			; 0000003fH
$LN334@PyUnicode_@95:
  011b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  011bc	48 8d 43 ff	 lea	 rax, QWORD PTR [rbx-1]
  011c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@LHCILPFL@unsupported?5format?5character?5?8?$CFc@
  011c7	44 8b ce	 mov	 r9d, esi
  011ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  011cf	e8 00 00 00 00	 call	 PyErr_Format

; 13896:                 goto onError;

  011d4	e9 ab fe ff ff	 jmp	 $LN474@PyUnicode_@95
$LN475@PyUnicode_@95:

; 13523:     PyObject *temp = NULL;

  011d9	48 8b 75 87	 mov	 rsi, QWORD PTR temp$1$[rbp-169]
$LN264@PyUnicode_@95:

; 14028:         } /* '%' */
; 14029:     } /* until end */
; 14030:     if (argidx < arglen && !dict) {

  011dd	48 8b 45 ff	 mov	 rax, QWORD PTR arglen$1$[rbp-169]
  011e1	48 39 45 f7	 cmp	 QWORD PTR argidx$[rbp-169], rax
  011e5	0f 8d 8c 00 00
	00		 jge	 $LN19@PyUnicode_@95
  011eb	48 83 7d ef 00	 cmp	 QWORD PTR dict$1$[rbp-169], 0
  011f0	0f 85 81 00 00
	00		 jne	 $LN19@PyUnicode_@95
$LN414@PyUnicode_@95:

; 14031:         PyErr_SetString(PyExc_TypeError,
; 14032:                         "not all arguments converted during string formatting");

  011f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@DANAIGJF@not?5all?5arguments?5converted?5duri@

; 13641:                     goto onError;
; 13642:                 }
; 13643:                 args_owned = 1;
; 13644:                 arglen = -1;

  011fd	e9 76 fe ff ff	 jmp	 $LN510@PyUnicode_@95
$LN468@PyUnicode_@95:

; 13870:                 break;

  01202	4c 8b 6d 8f	 mov	 r13, QWORD PTR uformat$1$[rbp-169]
  01206	48 8b 7d 87	 mov	 rdi, QWORD PTR temp$1$[rbp-169]
  0120a	e9 81 fe ff ff	 jmp	 $onError$143400

; 14043: 
; 14044:   onError:
; 14045:     Py_DECREF(uformat);

$LN366@PyUnicode_@95:
  0120f	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  01213	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  01219	eb 08		 jmp	 SHORT $LN9@PyUnicode_@95
$LN361@PyUnicode_@95:
  0121b	49 8b cd	 mov	 rcx, r13
  0121e	e8 00 00 00 00	 call	 Px_DecRef
$LN9@PyUnicode_@95:

; 14046:     Py_XDECREF(temp);

  01223	48 85 ff	 test	 rdi, rdi
  01226	74 08		 je	 SHORT $LN4@PyUnicode_@95
  01228	48 8b cf	 mov	 rcx, rdi
  0122b	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@PyUnicode_@95:

; 14047:     Py_XDECREF(second);
; 14048:     _PyUnicodeWriter_Dealloc(&writer);

  01230	48 8d 4d a7	 lea	 rcx, QWORD PTR writer$[rbp-169]
  01234	e8 00 00 00 00	 call	 _PyUnicodeWriter_Dealloc

; 14049:     if (args_owned) {

  01239	83 7d e3 00	 cmp	 DWORD PTR args_owned$1$[rbp-169], 0
  0123d	74 08		 je	 SHORT $LN1@PyUnicode_@95

; 14050:         Py_DECREF(args);

  0123f	49 8b cc	 mov	 rcx, r12
  01242	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyUnicode_@95:

; 14051:     }
; 14052:     return NULL;

  01247	33 c0		 xor	 eax, eax
$LN491@PyUnicode_@95:
  01249	4c 8b a4 24 d0
	00 00 00	 mov	 r12, QWORD PTR [rsp+208]
  01251	48 8b bc 24 d8
	00 00 00	 mov	 rdi, QWORD PTR [rsp+216]
  01259	48 8b 9c 24 e0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+224]
$LN488@PyUnicode_@95:
  01261	4c 8b b4 24 c8
	00 00 00	 mov	 r14, QWORD PTR [rsp+200]

; 14053: }

  01269	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  01270	41 5f		 pop	 r15
  01272	41 5d		 pop	 r13
  01274	5e		 pop	 rsi
  01275	5d		 pop	 rbp
  01276	c3		 ret	 0
$LN19@PyUnicode_@95:

; 14033:         goto onError;
; 14034:     }
; 14035: 
; 14036:     if (args_owned) {

  01277	83 7d e3 00	 cmp	 DWORD PTR args_owned$1$[rbp-169], 0
  0127b	74 09		 je	 SHORT $LN18@PyUnicode_@95

; 14037:         Py_DECREF(args);

  0127d	48 8b 4d 6f	 mov	 rcx, QWORD PTR args$[rbp-169]
  01281	e8 00 00 00 00	 call	 _Py_DecRef
$LN18@PyUnicode_@95:

; 14038:     }
; 14039:     Py_DECREF(uformat);

  01286	49 8b ce	 mov	 rcx, r14
  01289	e8 00 00 00 00	 call	 _Py_DecRef

; 14040:     Py_XDECREF(temp);

  0128e	48 85 f6	 test	 rsi, rsi
  01291	74 08		 je	 SHORT $LN12@PyUnicode_@95
  01293	48 8b ce	 mov	 rcx, rsi
  01296	e8 00 00 00 00	 call	 _Py_DecRef
$LN12@PyUnicode_@95:

; 14041:     Py_XDECREF(second);
; 14042:     return _PyUnicodeWriter_Finish(&writer);

  0129b	48 8d 4d a7	 lea	 rcx, QWORD PTR writer$[rbp-169]
  0129f	e8 00 00 00 00	 call	 _PyUnicodeWriter_Finish
  012a4	eb a3		 jmp	 SHORT $LN491@PyUnicode_@95
$LN271@PyUnicode_@95:

; 13533:         PyErr_BadInternalCall();

  012a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  012ad	ba dd 34 00 00	 mov	 edx, 13533		; 000034ddH
  012b2	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 13534:         return NULL;

  012b7	33 c0		 xor	 eax, eax

; 14053: }

  012b9	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  012c0	41 5f		 pop	 r15
  012c2	41 5d		 pop	 r13
  012c4	5e		 pop	 rsi
  012c5	5d		 pop	 rbp
  012c6	c3		 ret	 0
  012c7	90		 npad	 1
$LN439@PyUnicode_@95:
  012c8	00 00 00 00	 DD	 $LN161@PyUnicode_@95
  012cc	00 00 00 00	 DD	 $LN180@PyUnicode_@95
  012d0	00 00 00 00	 DD	 $LN189@PyUnicode_@95
  012d4	00 00 00 00	 DD	 $LN156@PyUnicode_@95
  012d8	00 00 00 00	 DD	 $LN144@PyUnicode_@95
$LN438@PyUnicode_@95:
  012dc	00		 DB	 0
  012dd	00		 DB	 0
  012de	00		 DB	 0
  012df	04		 DB	 4
  012e0	04		 DB	 4
  012e1	04		 DB	 4
  012e2	04		 DB	 4
  012e3	04		 DB	 4
  012e4	04		 DB	 4
  012e5	04		 DB	 4
  012e6	04		 DB	 4
  012e7	04		 DB	 4
  012e8	04		 DB	 4
  012e9	04		 DB	 4
  012ea	04		 DB	 4
  012eb	04		 DB	 4
  012ec	04		 DB	 4
  012ed	04		 DB	 4
  012ee	04		 DB	 4
  012ef	01		 DB	 1
  012f0	04		 DB	 4
  012f1	04		 DB	 4
  012f2	04		 DB	 4
  012f3	04		 DB	 4
  012f4	04		 DB	 4
  012f5	04		 DB	 4
  012f6	04		 DB	 4
  012f7	04		 DB	 4
  012f8	02		 DB	 2
  012f9	04		 DB	 4
  012fa	03		 DB	 3
  012fb	01		 DB	 1
  012fc	00		 DB	 0
  012fd	00		 DB	 0
  012fe	00		 DB	 0
  012ff	04		 DB	 4
  01300	01		 DB	 1
  01301	04		 DB	 4
  01302	04		 DB	 4
  01303	04		 DB	 4
  01304	04		 DB	 4
  01305	04		 DB	 4
  01306	01		 DB	 1
  01307	04		 DB	 4
  01308	04		 DB	 4
  01309	02		 DB	 2
  0130a	02		 DB	 2
  0130b	04		 DB	 4
  0130c	01		 DB	 1
  0130d	04		 DB	 4
  0130e	04		 DB	 4
  0130f	01		 DB	 1
PyUnicode_Format ENDP
_TEXT	ENDS
PUBLIC	??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@		; `string'
PUBLIC	??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@		; `string'
PUBLIC	??_C@_04BKLHDIKK@iter?$AA@			; `string'
EXTRN	_PyObject_GetBuiltin:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicodeiter_reduce DD imagerel unicodeiter_reduce
	DD	imagerel unicodeiter_reduce+134
	DD	imagerel $unwind$unicodeiter_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicodeiter_reduce DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@
CONST	SEGMENT
??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@ DB 'N(N)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@
CONST	SEGMENT
??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@ DB 'N(O)n', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKLHDIKK@iter?$AA@
CONST	SEGMENT
??_C@_04BKLHDIKK@iter?$AA@ DB 'iter', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicodeiter_reduce
_TEXT	SEGMENT
it$ = 48
unicodeiter_reduce PROC					; COMDAT

; 14580: {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 14581:     if (it->it_seq != NULL) {

  0000a	48 8b 79 68	 mov	 rdi, QWORD PTR [rcx+104]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	48 85 ff	 test	 rdi, rdi
  00014	74 2c		 je	 SHORT $LN3@unicodeite@6

; 14582:         return Py_BuildValue("N(O)n", _PyObject_GetBuiltin("iter"),
; 14583:                              it->it_seq, it->it_index);

  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BKLHDIKK@iter?$AA@
  0001d	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  00022	4c 8b 4b 60	 mov	 r9, QWORD PTR [rbx+96]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@
  0002d	48 8b d0	 mov	 rdx, rax
  00030	4c 8b c7	 mov	 r8, rdi

; 14589:     }
; 14590: }

  00033	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5f		 pop	 rdi
  0003d	e9 00 00 00 00	 jmp	 _Py_BuildValue_SizeT
$LN3@unicodeite@6:

; 14584:     } else {
; 14585:         PyObject *u = PyUnicode_FromUnicode(NULL, 0);

  00042	33 d2		 xor	 edx, edx
  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  0004b	48 8b d8	 mov	 rbx, rax

; 14586:         if (u == NULL)

  0004e	48 85 c0	 test	 rax, rax
  00051	75 0b		 jne	 SHORT $LN1@unicodeite@6

; 14589:     }
; 14590: }

  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
$LN1@unicodeite@6:

; 14587:             return NULL;
; 14588:         return Py_BuildValue("N(N)", _PyObject_GetBuiltin("iter"), u);

  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BKLHDIKK@iter?$AA@
  00065	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@
  00071	4c 8b c3	 mov	 r8, rbx
  00074	48 8b d0	 mov	 rdx, rax

; 14589:     }
; 14590: }

  00077	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	5f		 pop	 rdi
  00081	e9 00 00 00 00	 jmp	 _Py_BuildValue_SizeT
unicodeiter_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@IJJDOKJB@Negative?5size?5passed?5to?5PyUnicod@ ; `string'
PUBLIC	PyUnicode_FromStringAndSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_FromStringAndSize DD imagerel $LN6
	DD	imagerel $LN6+67
	DD	imagerel $unwind$PyUnicode_FromStringAndSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_FromStringAndSize DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0DE@IJJDOKJB@Negative?5size?5passed?5to?5PyUnicod@
CONST	SEGMENT
??_C@_0DE@IJJDOKJB@Negative?5size?5passed?5to?5PyUnicod@ DB 'Negative siz'
	DB	'e passed to PyUnicode_FromStringAndSize', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_FromStringAndSize
_TEXT	SEGMENT
u$ = 48
size$ = 56
PyUnicode_FromStringAndSize PROC			; COMDAT

; 1862 : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1863 :     if (size < 0) {

  00004	48 85 d2	 test	 rdx, rdx
  00007	79 1a		 jns	 SHORT $LN3@PyUnicode_@96

; 1864 :         PyErr_SetString(PyExc_SystemError,
; 1865 :                         "Negative size passed to PyUnicode_FromStringAndSize");

  00009	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00010	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@IJJDOKJB@Negative?5size?5passed?5to?5PyUnicod@
  00017	e8 00 00 00 00	 call	 PyErr_SetString

; 1866 :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 1872 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
$LN3@PyUnicode_@96:

; 1867 :     }
; 1868 :     if (u != NULL)

  00023	48 85 c9	 test	 rcx, rcx
  00026	74 0f		 je	 SHORT $LN2@PyUnicode_@96

; 1869 :         return PyUnicode_DecodeUTF8Stateful(u, size, NULL, NULL);

  00028	45 33 c9	 xor	 r9d, r9d
  0002b	45 33 c0	 xor	 r8d, r8d

; 1872 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	e9 00 00 00 00	 jmp	 PyUnicode_DecodeUTF8Stateful
$LN2@PyUnicode_@96:

; 1870 :     else
; 1871 :         return (PyObject *)_PyUnicode_New(size);

  00037	48 8b ca	 mov	 rcx, rdx

; 1872 : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	e9 00 00 00 00	 jmp	 _PyUnicode_New
PyUnicode_FromStringAndSize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@NFDJKDFL@input?5too?5long?$AA@		; `string'
PUBLIC	PyUnicode_FromString
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_FromString DD imagerel $LN4
	DD	imagerel $LN4+90
	DD	imagerel $unwind$PyUnicode_FromString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_FromString DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT ??_C@_0P@NFDJKDFL@input?5too?5long?$AA@
CONST	SEGMENT
??_C@_0P@NFDJKDFL@input?5too?5long?$AA@ DB 'input too long', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_FromString
_TEXT	SEGMENT
u$ = 48
PyUnicode_FromString PROC				; COMDAT

; 1876 : {

$LN4:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4c 8b d1	 mov	 r10, rcx

; 1877 :     size_t size = strlen(u);

  00009	48 83 c9 ff	 or	 rcx, -1
  0000d	33 c0		 xor	 eax, eax
  0000f	49 8b fa	 mov	 rdi, r10
  00012	f2 ae		 repne scasb

; 1878 :     if (size > PY_SSIZE_T_MAX) {

  00014	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0001e	48 f7 d1	 not	 rcx
  00021	48 ff c9	 dec	 rcx
  00024	48 3b c8	 cmp	 rcx, rax
  00027	76 1b		 jbe	 SHORT $LN1@PyUnicode_@97

; 1879 :         PyErr_SetString(PyExc_OverflowError, "input too long");

  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@NFDJKDFL@input?5too?5long?$AA@
  00037	e8 00 00 00 00	 call	 PyErr_SetString

; 1880 :         return NULL;

  0003c	33 c0		 xor	 eax, eax

; 1883 : }

  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
$LN1@PyUnicode_@97:

; 1881 :     }
; 1882 :     return PyUnicode_DecodeUTF8Stateful(u, (Py_ssize_t)size, NULL, NULL);

  00044	48 8b d1	 mov	 rdx, rcx
  00047	45 33 c9	 xor	 r9d, r9d
  0004a	45 33 c0	 xor	 r8d, r8d
  0004d	49 8b ca	 mov	 rcx, r10

; 1883 : }

  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5f		 pop	 rdi
  00055	e9 00 00 00 00	 jmp	 PyUnicode_DecodeUTF8Stateful
PyUnicode_FromString ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@HKJDKHGL@_PyParallelUnicode_FromId?$AA@ ; `string'
PUBLIC	_PyParallelUnicode_FromId
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyParallelUnicode_FromId DD imagerel $LN5
	DD	imagerel $LN5+195
	DD	imagerel $unwind$_PyParallelUnicode_FromId
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyParallelUnicode_FromId DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BK@HKJDKHGL@_PyParallelUnicode_FromId?$AA@
CONST	SEGMENT
??_C@_0BK@HKJDKHGL@_PyParallelUnicode_FromId?$AA@ DB '_PyParallelUnicode_'
	DB	'FromId', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyParallelUnicode_FromId
_TEXT	SEGMENT
id$ = 48
_PyParallelUnicode_FromId PROC				; COMDAT

; 1890 : {

$LN5:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b d9	 mov	 rbx, rcx

; 1891 :     Px_GUARD

  00012	e8 00 00 00 00	 call	 _Py_PXCTX
  00017	85 c0		 test	 eax, eax
  00019	75 1d		 jne	 SHORT $LN2@PyParallel@2
  0001b	44 8d 48 01	 lea	 r9d, QWORD PTR [rax+1]
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@HKJDKHGL@_PyParallelUnicode_FromId?$AA@
  0002d	41 b8 63 07 00
	00		 mov	 r8d, 1891		; 00000763H
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN2@PyParallel@2:

; 1892 :     assert(!PyErr_Occurred());
; 1893 :     assert(!id->object);
; 1894 :     assert(!id->next);
; 1895 : 
; 1896 :     _PyParallel_EnableTLSHeap();

  00038	e8 00 00 00 00	 call	 _PyParallel_EnableTLSHeap

; 1897 :     id->object = PyUnicode_DecodeUTF8Stateful(id->string,
; 1898 :                                               strlen(id->string),
; 1899 :                                               NULL, NULL);

  0003d	4c 8b 5b 08	 mov	 r11, QWORD PTR [rbx+8]
  00041	48 83 c9 ff	 or	 rcx, -1
  00045	33 c0		 xor	 eax, eax
  00047	49 8b fb	 mov	 rdi, r11
  0004a	45 33 c9	 xor	 r9d, r9d
  0004d	f2 ae		 repne scasb
  0004f	45 33 c0	 xor	 r8d, r8d
  00052	48 f7 d1	 not	 rcx
  00055	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  00059	49 8b cb	 mov	 rcx, r11
  0005c	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8Stateful
  00061	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 1900 :     _PyParallel_DisableTLSHeap();

  00065	e8 00 00 00 00	 call	 _PyParallel_DisableTLSHeap

; 1901 : 
; 1902 :     if (!id->object)

  0006a	48 83 7b 10 00	 cmp	 QWORD PTR [rbx+16], 0
  0006f	75 12		 jne	 SHORT $LN1@PyParallel@2

; 1903 :         return NULL;

  00071	33 c0		 xor	 eax, eax

; 1908 :     tls_static_strings = id;
; 1909 : 
; 1910 :     return id->object;
; 1911 : }

  00073	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00078	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00081	5f		 pop	 rdi
  00082	c3		 ret	 0
$LN1@PyParallel@2:

; 1904 : 
; 1905 :     _PyParallelUnicode_InternInPlace(&id->object);

  00083	48 8d 4b 10	 lea	 rcx, QWORD PTR [rbx+16]
  00087	e8 00 00 00 00	 call	 _PyParallelUnicode_InternInPlace

; 1906 : 
; 1907 :     id->next = tls_static_strings;

  0008c	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  00095	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  0009b	48 8b 14 d1	 mov	 rdx, QWORD PTR [rcx+rdx*8]

; 1908 :     tls_static_strings = id;
; 1909 : 
; 1910 :     return id->object;
; 1911 : }

  0009f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000a4	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:tls_static_strings
  000a9	48 8b 0c 02	 mov	 rcx, QWORD PTR [rdx+rax]
  000ad	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  000b0	48 89 1c 02	 mov	 QWORD PTR [rdx+rax], rbx
  000b4	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000b8	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000bd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0
_PyParallelUnicode_FromId ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_FromId
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_FromId DD imagerel $LN6
	DD	imagerel $LN6+57
	DD	imagerel $unwind$_PyUnicode_FromId
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyUnicode_FromId DD imagerel $LN6+57
	DD	imagerel $LN6+104
	DD	imagerel $chain$0$_PyUnicode_FromId
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_PyUnicode_FromId DD imagerel $LN6+104
	DD	imagerel $LN6+156
	DD	imagerel $chain$1$_PyUnicode_FromId
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_PyUnicode_FromId DD 021H
	DD	imagerel $LN6
	DD	imagerel $LN6+57
	DD	imagerel $unwind$_PyUnicode_FromId
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyUnicode_FromId DD 020521H
	DD	067405H
	DD	imagerel $LN6
	DD	imagerel $LN6+57
	DD	imagerel $unwind$_PyUnicode_FromId
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_FromId DD 040a01H
	DD	07340aH
	DD	06006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_FromId
_TEXT	SEGMENT
id$ = 48
_PyUnicode_FromId PROC					; COMDAT

; 1916 : {

$LN6:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1917 :     if (id->object)

  0000a	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	48 85 c0	 test	 rax, rax

; 1918 :         return id->object;

  00014	75 7b		 jne	 SHORT $LN4@PyUnicode_@98

; 1919 : 
; 1920 :     Px_RETURN(_PyParallelUnicode_FromId(id));

  00016	e8 00 00 00 00	 call	 _Py_PXCTX
  0001b	85 c0		 test	 eax, eax
  0001d	74 12		 je	 SHORT $LN2@PyUnicode_@98
  0001f	48 8b cb	 mov	 rcx, rbx

; 1934 : }

  00022	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5e		 pop	 rsi
  0002c	e9 00 00 00 00	 jmp	 _PyParallelUnicode_FromId
$LN2@PyUnicode_@98:

; 1921 : 
; 1922 :     id->object = PyUnicode_DecodeUTF8Stateful(id->string,
; 1923 :                                               strlen(id->string),
; 1924 :                                               NULL, NULL);

  00031	4c 8b 53 08	 mov	 r10, QWORD PTR [rbx+8]
  00035	48 83 c9 ff	 or	 rcx, -1
  00039	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0003e	33 c0		 xor	 eax, eax
  00040	49 8b fa	 mov	 rdi, r10
  00043	45 33 c9	 xor	 r9d, r9d
  00046	f2 ae		 repne scasb
  00048	45 33 c0	 xor	 r8d, r8d
  0004b	48 f7 d1	 not	 rcx
  0004e	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  00052	49 8b ca	 mov	 rcx, r10
  00055	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8Stateful
  0005a	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  0005f	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 1925 :     if (!id->object)

  00063	48 85 c0	 test	 rax, rax
  00066	75 0b		 jne	 SHORT $LN1@PyUnicode_@98

; 1934 : }

  00068	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0006d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00071	5e		 pop	 rsi
  00072	c3		 ret	 0
$LN1@PyUnicode_@98:

; 1926 :         return NULL;
; 1927 : 
; 1928 :     PyUnicode_InternInPlace(&id->object);

  00073	48 8d 4b 10	 lea	 rcx, QWORD PTR [rbx+16]
  00077	e8 00 00 00 00	 call	 PyUnicode_InternInPlace

; 1929 :     assert(!id->next);
; 1930 :     id->next = static_strings;

  0007c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR static_strings

; 1931 :     static_strings = id;
; 1932 : 
; 1933 :     return id->object;

  00083	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00087	48 89 13	 mov	 QWORD PTR [rbx], rdx
  0008a	48 89 1d 00 00
	00 00		 mov	 QWORD PTR static_strings, rbx
$LN4@PyUnicode_@98:

; 1934 : }

  00091	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00096	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009a	5e		 pop	 rsi
  0009b	c3		 ret	 0
_PyUnicode_FromId ENDP
_TEXT	ENDS
PUBLIC	??_C@_02BBAHNLBA@?$CFp?$AA@			; `string'
PUBLIC	??_C@_0FN@GGEIKNGP@PyUnicode_FromFormatV?$CI?$CJ?5expects?5@ ; `string'
PUBLIC	PyUnicode_FromFormatV
EXTRN	__imp_memmove:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyUnicode_FromFormatV DD imagerel $LN231
	DD	imagerel $LN231+2844
	DD	imagerel $unwind$PyUnicode_FromFormatV
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_FromFormatV DD 0a1d01H
	DD	017011dH
	DD	0e00ff011H
	DD	0c00bd00dH
	DD	060087009H
	DD	050063007H
xdata	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp?$AA@ DB '%p', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@GGEIKNGP@PyUnicode_FromFormatV?$CI?$CJ?5expects?5@
CONST	SEGMENT
??_C@_0FN@GGEIKNGP@PyUnicode_FromFormatV?$CI?$CJ?5expects?5@ DB 'PyUnicod'
	DB	'e_FromFormatV() expects an ASCII-encoded format string, got a'
	DB	' non-ASCII byte: 0x%02x', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT PyUnicode_FromFormatV
_TEXT	SEGMENT
numberresult$1$ = 64
numberresults$1$ = 72
longflag$127367 = 80
longlongflag$127336 = 80
longlongflag$127368 = 84
size_tflag$127369 = 88
f$3$ = 96
callresults$1$ = 104
fmt$ = 112
maxchar$1$ = 256
callresult$2$ = 256
format$ = 256
vargs$ = 264
numberresult$2$ = 272
width$ = 272
precision$ = 280
PyUnicode_FromFormatV PROC				; COMDAT

; 2483 : {

$LN231:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	53		 push	 rbx
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 8d 6c 24 e1	 lea	 rbp, QWORD PTR [rsp-31]
  00016	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 2484 :     va_list count;
; 2485 :     Py_ssize_t callcount = 0;
; 2486 :     PyObject **callresults = NULL;
; 2487 :     PyObject **callresult = NULL;
; 2488 :     Py_ssize_t n = 0;
; 2489 :     int width = 0;
; 2490 :     int precision = 0;
; 2491 :     int zeropad;
; 2492 :     const char* f;
; 2493 :     PyObject *string;
; 2494 :     /* used by sprintf */
; 2495 :     char fmt[61]; /* should be enough for %0width.precisionlld */
; 2496 :     Py_UCS4 maxchar = 127; /* result is ASCII by default */
; 2497 :     Py_UCS4 argmaxchar;
; 2498 :     Py_ssize_t numbersize = 0;
; 2499 :     char *numberresults = NULL;
; 2500 :     char *numberresult = NULL;
; 2501 :     Py_ssize_t i;
; 2502 :     int kind;
; 2503 :     void *data;
; 2504 : 
; 2505 :     Py_VA_COPY(count, vargs);
; 2506 :     /* step 1: count the number of %S/%R/%A/%s format specifications
; 2507 :      * (we call PyObject_Str()/PyObject_Repr()/PyObject_ASCII()/
; 2508 :      * PyUnicode_DecodeUTF8() for these objects once during step 3 and put the
; 2509 :      * result in an array)
; 2510 :      * also estimate a upper bound for all the number formats in the string,
; 2511 :      * numbers will be formatted in step 3 and be kept in a '\0'-separated
; 2512 :      * buffer before putting everything together. */
; 2513 :     for (f = format; *f; f++) {

  0001d	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00020	33 db		 xor	 ebx, ebx
  00022	45 33 ff	 xor	 r15d, r15d
  00025	45 33 e4	 xor	 r12d, r12d
  00028	33 f6		 xor	 esi, esi
  0002a	4c 8b e9	 mov	 r13, rcx
  0002d	48 89 4d c7	 mov	 QWORD PTR f$3$[rbp-153], rcx
  00031	48 89 5d cf	 mov	 QWORD PTR callresults$1$[rbp-153], rbx
  00035	89 5d 77	 mov	 DWORD PTR width$[rbp-153], ebx
  00038	89 5d 7f	 mov	 DWORD PTR precision$[rbp-153], ebx
  0003b	c7 45 67 7f 00
	00 00		 mov	 DWORD PTR maxchar$1$[rbp-153], 127 ; 0000007fH
  00042	48 89 5d af	 mov	 QWORD PTR numberresults$1$[rbp-153], rbx
  00046	48 89 5d a7	 mov	 QWORD PTR numberresult$1$[rbp-153], rbx
  0004a	48 8b f9	 mov	 rdi, rcx
  0004d	84 c0		 test	 al, al
  0004f	0f 84 04 01 00
	00		 je	 $LN106@PyUnicode_@99
  00055	44 8d 73 15	 lea	 r14d, QWORD PTR [rbx+21]
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL123@PyUnicode_@99:

; 2514 :         if (*f == '%') {

  00060	3c 25		 cmp	 al, 37			; 00000025H
  00062	0f 85 85 00 00
	00		 jne	 $LN120@PyUnicode_@99

; 2515 :             int longlongflag;
; 2516 :             /* skip width or width.precision (eg. "1.2" of "%1.2f") */
; 2517 :             f = parse_format_flags(f, &width, NULL, NULL, &longlongflag, NULL);

  00068	48 8d 45 b7	 lea	 rax, QWORD PTR longlongflag$127336[rbp-153]
  0006c	48 8d 55 77	 lea	 rdx, QWORD PTR width$[rbp-153]
  00070	45 33 c9	 xor	 r9d, r9d
  00073	45 33 c0	 xor	 r8d, r8d
  00076	48 8b cf	 mov	 rcx, rdi
  00079	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  0007e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00083	e8 00 00 00 00	 call	 parse_format_flags
  00088	48 8b f8	 mov	 rdi, rax

; 2518 :             if (*f == 's' || *f=='S' || *f=='R' || *f=='A' || *f=='V')

  0008b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0008e	3c 73		 cmp	 al, 115			; 00000073H
  00090	74 56		 je	 SHORT $LN118@PyUnicode_@99
  00092	3c 53		 cmp	 al, 83			; 00000053H
  00094	74 52		 je	 SHORT $LN118@PyUnicode_@99
  00096	3c 52		 cmp	 al, 82			; 00000052H
  00098	74 4e		 je	 SHORT $LN118@PyUnicode_@99
  0009a	3c 41		 cmp	 al, 65			; 00000041H
  0009c	74 4a		 je	 SHORT $LN118@PyUnicode_@99
  0009e	3c 56		 cmp	 al, 86			; 00000056H
  000a0	74 46		 je	 SHORT $LN118@PyUnicode_@99

; 2520 : 
; 2521 :             else if (*f == 'd' || *f=='u' || *f=='i' || *f=='x' || *f=='p') {

  000a2	3c 64		 cmp	 al, 100			; 00000064H
  000a4	74 10		 je	 SHORT $LN115@PyUnicode_@99
  000a6	3c 75		 cmp	 al, 117			; 00000075H
  000a8	74 0c		 je	 SHORT $LN115@PyUnicode_@99
  000aa	3c 69		 cmp	 al, 105			; 00000069H
  000ac	74 08		 je	 SHORT $LN115@PyUnicode_@99
  000ae	3c 78		 cmp	 al, 120			; 00000078H
  000b0	74 04		 je	 SHORT $LN115@PyUnicode_@99
  000b2	3c 70		 cmp	 al, 112			; 00000070H
  000b4	75 3f		 jne	 SHORT $LN122@PyUnicode_@99
$LN115@PyUnicode_@99:

; 2522 : #ifdef HAVE_LONG_LONG
; 2523 :                 if (longlongflag) {
; 2524 :                     if (width < MAX_LONG_LONG_CHARS)

  000b6	8b 45 77	 mov	 eax, DWORD PTR width$[rbp-153]
  000b9	44 39 65 b7	 cmp	 DWORD PTR longlongflag$127336[rbp-153], r12d
  000bd	74 15		 je	 SHORT $LN114@PyUnicode_@99
  000bf	41 3b c6	 cmp	 eax, r14d
  000c2	7d 1a		 jge	 SHORT $LN111@PyUnicode_@99

; 2525 :                         width = MAX_LONG_LONG_CHARS;

  000c4	41 8b c6	 mov	 eax, r14d

; 2526 :                 }
; 2527 :                 else
; 2528 : #endif
; 2529 :                     /* MAX_LONG_CHARS is enough to hold a 64-bit integer,
; 2530 :                        including sign.  Decimal takes the most space.  This
; 2531 :                        isn't enough for octal.  If a width is specified we
; 2532 :                        need more (which we allocate later). */
; 2533 :                     if (width < MAX_LONG_CHARS)

  000c7	89 45 77	 mov	 DWORD PTR width$[rbp-153], eax

; 2534 :                         width = MAX_LONG_CHARS;
; 2535 : 
; 2536 :                 /* account for the size + '\0' to separate numbers
; 2537 :                    inside of the numberresults buffer */
; 2538 :                 numbersize += (width + 1);

  000ca	ff c0		 inc	 eax
  000cc	48 63 c8	 movsxd	 rcx, eax
  000cf	48 03 f1	 add	 rsi, rcx
  000d2	eb 21		 jmp	 SHORT $LN122@PyUnicode_@99
$LN114@PyUnicode_@99:

; 2526 :                 }
; 2527 :                 else
; 2528 : #endif
; 2529 :                     /* MAX_LONG_CHARS is enough to hold a 64-bit integer,
; 2530 :                        including sign.  Decimal takes the most space.  This
; 2531 :                        isn't enough for octal.  If a width is specified we
; 2532 :                        need more (which we allocate later). */
; 2533 :                     if (width < MAX_LONG_CHARS)

  000d4	41 3b c6	 cmp	 eax, r14d
  000d7	41 0f 4c c6	 cmovl	 eax, r14d
  000db	89 45 77	 mov	 DWORD PTR width$[rbp-153], eax
$LN111@PyUnicode_@99:

; 2534 :                         width = MAX_LONG_CHARS;
; 2535 : 
; 2536 :                 /* account for the size + '\0' to separate numbers
; 2537 :                    inside of the numberresults buffer */
; 2538 :                 numbersize += (width + 1);

  000de	ff c0		 inc	 eax
  000e0	48 63 c8	 movsxd	 rcx, eax
  000e3	48 03 f1	 add	 rsi, rcx
  000e6	eb 0d		 jmp	 SHORT $LN122@PyUnicode_@99
$LN118@PyUnicode_@99:

; 2519 :                 ++callcount;

  000e8	48 ff c3	 inc	 rbx

; 2539 :             }

  000eb	eb 08		 jmp	 SHORT $LN122@PyUnicode_@99
$LN120@PyUnicode_@99:

; 2540 :         }
; 2541 :         else if ((unsigned char)*f > 127) {

  000ed	3c 7f		 cmp	 al, 127			; 0000007fH
  000ef	0f 87 ea 00 00
	00		 ja	 $LN185@PyUnicode_@99
$LN122@PyUnicode_@99:

; 2484 :     va_list count;
; 2485 :     Py_ssize_t callcount = 0;
; 2486 :     PyObject **callresults = NULL;
; 2487 :     PyObject **callresult = NULL;
; 2488 :     Py_ssize_t n = 0;
; 2489 :     int width = 0;
; 2490 :     int precision = 0;
; 2491 :     int zeropad;
; 2492 :     const char* f;
; 2493 :     PyObject *string;
; 2494 :     /* used by sprintf */
; 2495 :     char fmt[61]; /* should be enough for %0width.precisionlld */
; 2496 :     Py_UCS4 maxchar = 127; /* result is ASCII by default */
; 2497 :     Py_UCS4 argmaxchar;
; 2498 :     Py_ssize_t numbersize = 0;
; 2499 :     char *numberresults = NULL;
; 2500 :     char *numberresult = NULL;
; 2501 :     Py_ssize_t i;
; 2502 :     int kind;
; 2503 :     void *data;
; 2504 : 
; 2505 :     Py_VA_COPY(count, vargs);
; 2506 :     /* step 1: count the number of %S/%R/%A/%s format specifications
; 2507 :      * (we call PyObject_Str()/PyObject_Repr()/PyObject_ASCII()/
; 2508 :      * PyUnicode_DecodeUTF8() for these objects once during step 3 and put the
; 2509 :      * result in an array)
; 2510 :      * also estimate a upper bound for all the number formats in the string,
; 2511 :      * numbers will be formatted in step 3 and be kept in a '\0'-separated
; 2512 :      * buffer before putting everything together. */
; 2513 :     for (f = format; *f; f++) {

  000f5	0f b6 47 01	 movzx	 eax, BYTE PTR [rdi+1]
  000f9	48 ff c7	 inc	 rdi
  000fc	84 c0		 test	 al, al
  000fe	0f 85 5c ff ff
	ff		 jne	 $LL123@PyUnicode_@99

; 2547 :         }
; 2548 :     }
; 2549 :     /* step 2: allocate memory for the results of
; 2550 :      * PyObject_Str()/PyObject_Repr()/PyUnicode_DecodeUTF8() calls */
; 2551 :     if (callcount) {

  00104	48 85 db	 test	 rbx, rbx
  00107	74 25		 je	 SHORT $LN108@PyUnicode_@99

; 2552 :         callresults = PyObject_Malloc(sizeof(PyObject *) * callcount);

  00109	48 8d 0c dd 00
	00 00 00	 lea	 rcx, QWORD PTR [rbx*8]
  00111	e8 00 00 00 00	 call	 PyObject_Malloc
  00116	48 89 45 cf	 mov	 QWORD PTR callresults$1$[rbp-153], rax

; 2553 :         if (!callresults) {

  0011a	48 85 c0	 test	 rax, rax
  0011d	75 0c		 jne	 SHORT $LN107@PyUnicode_@99

; 2554 :             PyErr_NoMemory();

  0011f	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2555 :             return NULL;

  00124	33 c0		 xor	 eax, eax
  00126	e9 e2 08 00 00	 jmp	 $LN124@PyUnicode_@99
$LN107@PyUnicode_@99:

; 2556 :         }
; 2557 :         callresult = callresults;

  0012b	4c 8b f8	 mov	 r15, rax
$LN108@PyUnicode_@99:

; 2558 :     }
; 2559 :     /* step 2.5: allocate memory for the results of formating numbers */
; 2560 :     if (numbersize) {

  0012e	48 85 f6	 test	 rsi, rsi
  00131	74 22		 je	 SHORT $LN214@PyUnicode_@99

; 2561 :         numberresults = PyObject_Malloc(numbersize);

  00133	48 8b ce	 mov	 rcx, rsi
  00136	e8 00 00 00 00	 call	 PyObject_Malloc
  0013b	4c 8b f0	 mov	 r14, rax
  0013e	48 89 45 af	 mov	 QWORD PTR numberresults$1$[rbp-153], rax

; 2562 :         if (!numberresults) {

  00142	48 85 c0	 test	 rax, rax
  00145	75 0a		 jne	 SHORT $LN105@PyUnicode_@99

; 2563 :             PyErr_NoMemory();

  00147	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2564 :             goto fail;

  0014c	e9 86 05 00 00	 jmp	 $fail$127361
$LN105@PyUnicode_@99:

; 2565 :         }
; 2566 :         numberresult = numberresults;

  00151	48 89 45 a7	 mov	 QWORD PTR numberresult$1$[rbp-153], rax
$LN214@PyUnicode_@99:

; 2483 : {

  00155	48 8b 55 6f	 mov	 rdx, QWORD PTR vargs$[rbp-153]
$LN106@PyUnicode_@99:

; 2567 :     }
; 2568 : 
; 2569 :     /* step 3: format numbers and figure out how large a buffer we need */
; 2570 :     for (f = format; *f; f++) {

  00159	4d 8b f5	 mov	 r14, r13
  0015c	45 38 65 00	 cmp	 BYTE PTR [r13], r12b
  00160	0f 84 56 05 00
	00		 je	 $expand$127748
  00166	48 8d 5a f8	 lea	 rbx, QWORD PTR [rdx-8]
  0016a	41 bd ff ff 00
	00		 mov	 r13d, 65535		; 0000ffffH
$LL104@PyUnicode_@99:

; 2571 :         if (*f == '%') {

  00170	41 80 3e 25	 cmp	 BYTE PTR [r14], 37	; 00000025H
  00174	0f 85 a0 00 00
	00		 jne	 $LN101@PyUnicode_@99

; 2572 :             const char* p;
; 2573 :             int longflag;
; 2574 :             int longlongflag;
; 2575 :             int size_tflag;
; 2576 :             int numprinted;
; 2577 : 
; 2578 :             p = f;
; 2579 :             zeropad = (f[1] == '0');
; 2580 :             f = parse_format_flags(f, &width, &precision,
; 2581 :                                    &longflag, &longlongflag, &size_tflag);

  0017a	48 8d 45 bf	 lea	 rax, QWORD PTR size_tflag$127369[rbp-153]
  0017e	33 f6		 xor	 esi, esi
  00180	41 80 7e 01 30	 cmp	 BYTE PTR [r14+1], 48	; 00000030H
  00185	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0018a	48 8d 45 bb	 lea	 rax, QWORD PTR longlongflag$127368[rbp-153]
  0018e	4c 8d 4d b7	 lea	 r9, QWORD PTR longflag$127367[rbp-153]
  00192	4c 8d 45 7f	 lea	 r8, QWORD PTR precision$[rbp-153]
  00196	48 8d 55 77	 lea	 rdx, QWORD PTR width$[rbp-153]
  0019a	49 8b ce	 mov	 rcx, r14
  0019d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a2	49 8b fe	 mov	 rdi, r14
  001a5	40 0f 94 c6	 sete	 sil
  001a9	e8 00 00 00 00	 call	 parse_format_flags
  001ae	4c 8b f0	 mov	 r14, rax

; 2582 :             switch (*f) {

  001b1	0f be 10	 movsx	 edx, BYTE PTR [rax]
  001b4	8d 42 db	 lea	 eax, DWORD PTR [rdx-37]
  001b7	83 f8 53	 cmp	 eax, 83			; 00000053H
  001ba	0f 87 eb 04 00
	00		 ja	 $LN56@PyUnicode_@99
  001c0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  001c7	48 98		 cdqe
  001c9	41 0f b6 84 00
	00 00 00 00	 movzx	 eax, BYTE PTR $LN210@PyUnicode_@99[r8+rax]
  001d2	41 8b 8c 80 00
	00 00 00	 mov	 ecx, DWORD PTR $LN211@PyUnicode_@99[r8+rax*4]
  001da	49 03 c8	 add	 rcx, r8
  001dd	ff e1		 jmp	 rcx
$LN185@PyUnicode_@99:

; 2542 :             PyErr_Format(PyExc_ValueError,
; 2543 :                 "PyUnicode_FromFormatV() expects an ASCII-encoded format "
; 2544 :                 "string, got a non-ASCII byte: 0x%02x",
; 2545 :                 (unsigned char)*f);

  001df	44 0f b6 07	 movzx	 r8d, BYTE PTR [rdi]
  001e3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FN@GGEIKNGP@PyUnicode_FromFormatV?$CI?$CJ?5expects?5@
  001f1	e8 00 00 00 00	 call	 PyErr_Format

; 2546 :             return NULL;

  001f6	33 c0		 xor	 eax, eax
  001f8	e9 10 08 00 00	 jmp	 $LN124@PyUnicode_@99
$LN98@PyUnicode_@99:

; 2583 :             case 'c':
; 2584 :             {
; 2585 :                 int ordinal = va_arg(count, int);

  001fd	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  00200	48 83 c3 08	 add	 rbx, 8

; 2586 :                 if (ordinal < 0 || ordinal > MAX_UNICODE) {

  00204	3d ff ff 10 00	 cmp	 eax, 1114111		; 0010ffffH
  00209	0f 87 7d 04 00
	00		 ja	 $LN186@PyUnicode_@99

; 2590 :                 }
; 2591 :                 maxchar = Py_MAX(maxchar, (Py_UCS4)ordinal);

  0020f	8b 55 67	 mov	 edx, DWORD PTR maxchar$1$[rbp-153]
  00212	3b d0		 cmp	 edx, eax
  00214	0f 47 c2	 cmova	 eax, edx
  00217	89 45 67	 mov	 DWORD PTR maxchar$1$[rbp-153], eax
$LN101@PyUnicode_@99:

; 2802 :             n++;

  0021a	49 ff c4	 inc	 r12
$LN103@PyUnicode_@99:

; 2567 :     }
; 2568 : 
; 2569 :     /* step 3: format numbers and figure out how large a buffer we need */
; 2570 :     for (f = format; *f; f++) {

  0021d	49 ff c6	 inc	 r14
  00220	41 80 3e 00	 cmp	 BYTE PTR [r14], 0
  00224	0f 85 46 ff ff
	ff		 jne	 $LL104@PyUnicode_@99
  0022a	e9 8d 04 00 00	 jmp	 $expand$127748
$LN94@PyUnicode_@99:

; 2592 :                 n++;
; 2593 :                 break;
; 2594 :             }
; 2595 :             case '%':
; 2596 :                 n++;
; 2597 :                 break;
; 2598 :             case 'i':
; 2599 :             case 'd':
; 2600 :                 makefmt(fmt, longflag, longlongflag, size_tflag, zeropad,
; 2601 :                         width, precision, *f);

  0022f	8b 45 7f	 mov	 eax, DWORD PTR precision$[rbp-153]
  00232	44 8b 6d bf	 mov	 r13d, DWORD PTR size_tflag$127369[rbp-153]
  00236	8b 7d b7	 mov	 edi, DWORD PTR longflag$127367[rbp-153]
  00239	88 54 24 38	 mov	 BYTE PTR [rsp+56], dl
  0023d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00241	8b 45 77	 mov	 eax, DWORD PTR width$[rbp-153]
  00244	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00248	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  0024c	8b 75 bb	 mov	 esi, DWORD PTR longlongflag$127368[rbp-153]
  0024f	48 8d 4d d7	 lea	 rcx, QWORD PTR fmt$[rbp-153]
  00253	45 8b cd	 mov	 r9d, r13d
  00256	8b d7		 mov	 edx, edi
  00258	44 8b c6	 mov	 r8d, esi
  0025b	e8 00 00 00 00	 call	 makefmt

; 2602 :                 if (longflag)

  00260	85 ff		 test	 edi, edi

; 2603 :                     numprinted = sprintf(numberresult, fmt,
; 2604 :                                          va_arg(count, long));

  00262	75 21		 jne	 SHORT $LN89@PyUnicode_@99

; 2605 : #ifdef HAVE_LONG_LONG
; 2606 :                 else if (longlongflag)

  00264	85 f6		 test	 esi, esi
  00266	74 18		 je	 SHORT $LN91@PyUnicode_@99
$LN225@PyUnicode_@99:

; 2607 :                     numprinted = sprintf(numberresult, fmt,
; 2608 :                                          va_arg(count, PY_LONG_LONG));

  00268	4c 8b 43 08	 mov	 r8, QWORD PTR [rbx+8]
  0026c	48 8b 4d a7	 mov	 rcx, QWORD PTR numberresult$1$[rbp-153]
  00270	48 83 c3 08	 add	 rbx, 8
  00274	48 8d 55 d7	 lea	 rdx, QWORD PTR fmt$[rbp-153]
  00278	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf
  0027e	eb 1b		 jmp	 SHORT $LN224@PyUnicode_@99
$LN91@PyUnicode_@99:

; 2609 : #endif
; 2610 :                 else if (size_tflag)

  00280	45 85 ed	 test	 r13d, r13d

; 2611 :                     numprinted = sprintf(numberresult, fmt,
; 2612 :                                          va_arg(count, Py_ssize_t));
; 2613 :                 else

  00283	75 e3		 jne	 SHORT $LN225@PyUnicode_@99
$LN89@PyUnicode_@99:

; 2614 :                     numprinted = sprintf(numberresult, fmt,
; 2615 :                                          va_arg(count, int));

  00285	44 8b 43 08	 mov	 r8d, DWORD PTR [rbx+8]
  00289	48 8b 4d a7	 mov	 rcx, QWORD PTR numberresult$1$[rbp-153]
  0028d	48 83 c3 08	 add	 rbx, 8
  00291	48 8d 55 d7	 lea	 rdx, QWORD PTR fmt$[rbp-153]
  00295	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf
$LN224@PyUnicode_@99:
  0029b	8b d0		 mov	 edx, eax

; 2616 :                 n += numprinted;

  0029d	48 98		 cdqe

; 2617 :                 /* advance by +1 to skip over the '\0' */
; 2618 :                 numberresult += (numprinted + 1);
; 2619 :                 assert(*(numberresult - 1) == '\0');
; 2620 :                 assert(*(numberresult - 2) != '\0');
; 2621 :                 assert(numprinted >= 0);
; 2622 :                 assert(numberresult <= numberresults + numbersize);
; 2623 :                 break;

  0029f	41 bd ff ff 00
	00		 mov	 r13d, 65535		; 0000ffffH
  002a5	4c 03 e0	 add	 r12, rax
  002a8	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  002ab	48 63 c8	 movsxd	 rcx, eax
  002ae	48 01 4d a7	 add	 QWORD PTR numberresult$1$[rbp-153], rcx
  002b2	e9 66 ff ff ff	 jmp	 $LN103@PyUnicode_@99
$LN87@PyUnicode_@99:

; 2624 :             case 'u':
; 2625 :                 makefmt(fmt, longflag, longlongflag, size_tflag, zeropad,
; 2626 :                         width, precision, 'u');

  002b7	8b 45 7f	 mov	 eax, DWORD PTR precision$[rbp-153]
  002ba	44 8b 6d bf	 mov	 r13d, DWORD PTR size_tflag$127369[rbp-153]
  002be	8b 7d b7	 mov	 edi, DWORD PTR longflag$127367[rbp-153]
  002c1	c6 44 24 38 75	 mov	 BYTE PTR [rsp+56], 117	; 00000075H
  002c6	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  002ca	8b 45 77	 mov	 eax, DWORD PTR width$[rbp-153]
  002cd	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  002d1	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  002d5	8b 75 bb	 mov	 esi, DWORD PTR longlongflag$127368[rbp-153]
  002d8	48 8d 4d d7	 lea	 rcx, QWORD PTR fmt$[rbp-153]
  002dc	45 8b cd	 mov	 r9d, r13d
  002df	8b d7		 mov	 edx, edi
  002e1	44 8b c6	 mov	 r8d, esi
  002e4	e8 00 00 00 00	 call	 makefmt

; 2627 :                 if (longflag)

  002e9	85 ff		 test	 edi, edi

; 2628 :                     numprinted = sprintf(numberresult, fmt,
; 2629 :                                          va_arg(count, unsigned long));

  002eb	75 98		 jne	 SHORT $LN89@PyUnicode_@99

; 2630 : #ifdef HAVE_LONG_LONG
; 2631 :                 else if (longlongflag)

  002ed	85 f6		 test	 esi, esi

; 2632 :                     numprinted = sprintf(numberresult, fmt,
; 2633 :                                          va_arg(count, unsigned PY_LONG_LONG));

  002ef	0f 85 73 ff ff
	ff		 jne	 $LN225@PyUnicode_@99

; 2634 : #endif
; 2635 :                 else if (size_tflag)

  002f5	45 85 ed	 test	 r13d, r13d
  002f8	74 8b		 je	 SHORT $LN89@PyUnicode_@99

; 2636 :                     numprinted = sprintf(numberresult, fmt,
; 2637 :                                          va_arg(count, size_t));
; 2638 :                 else

  002fa	e9 69 ff ff ff	 jmp	 $LN225@PyUnicode_@99
$LN80@PyUnicode_@99:

; 2639 :                     numprinted = sprintf(numberresult, fmt,
; 2640 :                                          va_arg(count, unsigned int));
; 2641 :                 n += numprinted;
; 2642 :                 numberresult += (numprinted + 1);
; 2643 :                 assert(*(numberresult - 1) == '\0');
; 2644 :                 assert(*(numberresult - 2) != '\0');
; 2645 :                 assert(numprinted >= 0);
; 2646 :                 assert(numberresult <= numberresults + numbersize);
; 2647 :                 break;
; 2648 :             case 'x':
; 2649 :                 makefmt(fmt, 0, 0, 0, zeropad, width, precision, 'x');

  002ff	8b 45 7f	 mov	 eax, DWORD PTR precision$[rbp-153]
  00302	c6 44 24 38 78	 mov	 BYTE PTR [rsp+56], 120	; 00000078H
  00307	48 8d 4d d7	 lea	 rcx, QWORD PTR fmt$[rbp-153]
  0030b	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0030f	8b 45 77	 mov	 eax, DWORD PTR width$[rbp-153]
  00312	45 33 c9	 xor	 r9d, r9d
  00315	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00319	45 33 c0	 xor	 r8d, r8d
  0031c	33 d2		 xor	 edx, edx
  0031e	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  00322	e8 00 00 00 00	 call	 makefmt

; 2650 :                 numprinted = sprintf(numberresult, fmt, va_arg(count, int));

  00327	44 8b 43 08	 mov	 r8d, DWORD PTR [rbx+8]
  0032b	48 8b 4d a7	 mov	 rcx, QWORD PTR numberresult$1$[rbp-153]
  0032f	48 83 c3 08	 add	 rbx, 8
  00333	48 8d 55 d7	 lea	 rdx, QWORD PTR fmt$[rbp-153]
  00337	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 2651 :                 n += numprinted;

  0033d	48 63 c8	 movsxd	 rcx, eax
  00340	4c 03 e1	 add	 r12, rcx

; 2652 :                 numberresult += (numprinted + 1);

  00343	ff c0		 inc	 eax
  00345	48 63 c8	 movsxd	 rcx, eax
  00348	48 01 4d a7	 add	 QWORD PTR numberresult$1$[rbp-153], rcx

; 2653 :                 assert(*(numberresult - 1) == '\0');
; 2654 :                 assert(*(numberresult - 2) != '\0');
; 2655 :                 assert(numprinted >= 0);
; 2656 :                 assert(numberresult <= numberresults + numbersize);
; 2657 :                 break;

  0034c	e9 cc fe ff ff	 jmp	 $LN103@PyUnicode_@99
$LN79@PyUnicode_@99:

; 2658 :             case 'p':
; 2659 :                 numprinted = sprintf(numberresult, "%p", va_arg(count, void*));

  00351	4c 8b 43 08	 mov	 r8, QWORD PTR [rbx+8]
  00355	48 8b 4d a7	 mov	 rcx, QWORD PTR numberresult$1$[rbp-153]
  00359	48 83 c3 08	 add	 rbx, 8
  0035d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02BBAHNLBA@?$CFp?$AA@
  00364	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 2660 :                 /* %p is ill-defined:  ensure leading 0x. */
; 2661 :                 if (numberresult[1] == 'X')

  0036a	48 8b 55 a7	 mov	 rdx, QWORD PTR numberresult$1$[rbp-153]
  0036e	8b f0		 mov	 esi, eax
  00370	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  00374	3c 58		 cmp	 al, 88			; 00000058H
  00376	75 06		 jne	 SHORT $LN78@PyUnicode_@99

; 2662 :                     numberresult[1] = 'x';

  00378	c6 42 01 78	 mov	 BYTE PTR [rdx+1], 120	; 00000078H
  0037c	eb 2b		 jmp	 SHORT $LN76@PyUnicode_@99
$LN78@PyUnicode_@99:

; 2663 :                 else if (numberresult[1] != 'x') {

  0037e	3c 78		 cmp	 al, 120			; 00000078H
  00380	74 27		 je	 SHORT $LN76@PyUnicode_@99

; 2664 :                     memmove(numberresult + 2, numberresult,
; 2665 :                             strlen(numberresult) + 1);

  00382	48 83 c9 ff	 or	 rcx, -1
  00386	33 c0		 xor	 eax, eax
  00388	48 8b fa	 mov	 rdi, rdx
  0038b	f2 ae		 repne scasb
  0038d	48 f7 d1	 not	 rcx
  00390	4c 8b c1	 mov	 r8, rcx
  00393	48 8d 4a 02	 lea	 rcx, QWORD PTR [rdx+2]
  00397	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 2666 :                     numberresult[0] = '0';

  0039d	48 8b 55 a7	 mov	 rdx, QWORD PTR numberresult$1$[rbp-153]

; 2667 :                     numberresult[1] = 'x';
; 2668 :                     numprinted += 2;

  003a1	83 c6 02	 add	 esi, 2
  003a4	66 c7 02 30 78	 mov	 WORD PTR [rdx], 30768	; 00007830H
$LN76@PyUnicode_@99:

; 2669 :                 }
; 2670 :                 n += numprinted;

  003a9	48 63 c6	 movsxd	 rax, esi
  003ac	4c 03 e0	 add	 r12, rax

; 2671 :                 numberresult += (numprinted + 1);

  003af	8d 46 01	 lea	 eax, DWORD PTR [rsi+1]
  003b2	48 63 c8	 movsxd	 rcx, eax
  003b5	48 03 d1	 add	 rdx, rcx
  003b8	48 89 55 a7	 mov	 QWORD PTR numberresult$1$[rbp-153], rdx

; 2672 :                 assert(*(numberresult - 1) == '\0');
; 2673 :                 assert(*(numberresult - 2) != '\0');
; 2674 :                 assert(numprinted >= 0);
; 2675 :                 assert(numberresult <= numberresults + numbersize);
; 2676 :                 break;

  003bc	e9 5c fe ff ff	 jmp	 $LN103@PyUnicode_@99
$LN75@PyUnicode_@99:

; 2677 :             case 's':
; 2678 :             {
; 2679 :                 /* UTF-8 */
; 2680 :                 const char *s = va_arg(count, const char*);

  003c1	4c 8b 53 08	 mov	 r10, QWORD PTR [rbx+8]

; 2681 :                 PyObject *str = PyUnicode_DecodeUTF8Stateful(s, strlen(s), "replace", NULL);

  003c5	48 83 c9 ff	 or	 rcx, -1
  003c9	33 c0		 xor	 eax, eax
  003cb	49 8b fa	 mov	 rdi, r10
  003ce	48 83 c3 08	 add	 rbx, 8
  003d2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07CLEHDIEJ@replace?$AA@
  003d9	f2 ae		 repne scasb
  003db	45 33 c9	 xor	 r9d, r9d
  003de	48 f7 d1	 not	 rcx
  003e1	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  003e5	49 8b ca	 mov	 rcx, r10
  003e8	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8Stateful

; 2682 :                 if (!str)

  003ed	48 85 c0	 test	 rax, rax
  003f0	0f 84 dd 02 00
	00		 je	 $LN222@PyUnicode_@99

; 2683 :                     goto fail;
; 2684 :                 /* since PyUnicode_DecodeUTF8 returns already flexible
; 2685 :                    unicode objects, there is no need to call ready on them */
; 2686 :                 argmaxchar = PyUnicode_MAX_CHAR_VALUE(str);

  003f6	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  003f9	f6 c2 40	 test	 dl, 64			; 00000040H
  003fc	74 07		 je	 SHORT $LN128@PyUnicode_@99
  003fe	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00403	eb 1e		 jmp	 SHORT $LN127@PyUnicode_@99
$LN128@PyUnicode_@99:
  00405	c1 ea 02	 shr	 edx, 2
  00408	83 e2 07	 and	 edx, 7
  0040b	83 fa 01	 cmp	 edx, 1
  0040e	75 07		 jne	 SHORT $LN126@PyUnicode_@99
  00410	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00415	eb 0c		 jmp	 SHORT $LN127@PyUnicode_@99
$LN126@PyUnicode_@99:
  00417	b9 ff ff 10 00	 mov	 ecx, 1114111		; 0010ffffH
  0041c	83 fa 02	 cmp	 edx, 2
  0041f	41 0f 44 cd	 cmove	 ecx, r13d
$LN127@PyUnicode_@99:

; 2687 :                 maxchar = Py_MAX(maxchar, argmaxchar);

  00423	8b 55 67	 mov	 edx, DWORD PTR maxchar$1$[rbp-153]
  00426	3b d1		 cmp	 edx, ecx
  00428	0f 47 ca	 cmova	 ecx, edx

; 2688 :                 n += PyUnicode_GET_LENGTH(str);

  0042b	4c 03 60 60	 add	 r12, QWORD PTR [rax+96]

; 2689 :                 /* Remember the str and switch to the next slot */
; 2690 :                 *callresult++ = str;

  0042f	49 89 07	 mov	 QWORD PTR [r15], rax
  00432	89 4d 67	 mov	 DWORD PTR maxchar$1$[rbp-153], ecx
  00435	49 83 c7 08	 add	 r15, 8

; 2691 :                 break;

  00439	e9 df fd ff ff	 jmp	 $LN103@PyUnicode_@99
$LN73@PyUnicode_@99:

; 2692 :             }
; 2693 :             case 'U':
; 2694 :             {
; 2695 :                 PyObject *obj = va_arg(count, PyObject *);

  0043e	48 8b 7b 08	 mov	 rdi, QWORD PTR [rbx+8]
  00442	48 83 c3 08	 add	 rbx, 8

; 2696 :                 assert(obj && _PyUnicode_CHECK(obj));
; 2697 :                 if (PyUnicode_READY(obj) == -1)

  00446	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  0044a	75 11		 jne	 SHORT $LN202@PyUnicode_@99
  0044c	48 8b cf	 mov	 rcx, rdi
  0044f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00454	83 f8 ff	 cmp	 eax, -1
  00457	0f 84 76 02 00
	00		 je	 $LN222@PyUnicode_@99
$LN202@PyUnicode_@99:

; 2698 :                     goto fail;
; 2699 :                 argmaxchar = PyUnicode_MAX_CHAR_VALUE(obj);

  0045d	8b 4f 70	 mov	 ecx, DWORD PTR [rdi+112]
  00460	f6 c1 40	 test	 cl, 64			; 00000040H
  00463	74 19		 je	 SHORT $LN134@PyUnicode_@99

; 2700 :                 maxchar = Py_MAX(maxchar, argmaxchar);

  00465	8b 4d 67	 mov	 ecx, DWORD PTR maxchar$1$[rbp-153]
  00468	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  0046d	3b c8		 cmp	 ecx, eax
  0046f	0f 47 c1	 cmova	 eax, ecx

; 2701 :                 n += PyUnicode_GET_LENGTH(obj);

  00472	4c 03 67 60	 add	 r12, QWORD PTR [rdi+96]
  00476	89 45 67	 mov	 DWORD PTR maxchar$1$[rbp-153], eax

; 2702 :                 break;

  00479	e9 9f fd ff ff	 jmp	 $LN103@PyUnicode_@99
$LN134@PyUnicode_@99:

; 2698 :                     goto fail;
; 2699 :                 argmaxchar = PyUnicode_MAX_CHAR_VALUE(obj);

  0047e	c1 e9 02	 shr	 ecx, 2
  00481	83 e1 07	 and	 ecx, 7
  00484	83 f9 01	 cmp	 ecx, 1
  00487	75 19		 jne	 SHORT $LN132@PyUnicode_@99

; 2700 :                 maxchar = Py_MAX(maxchar, argmaxchar);

  00489	8b 4d 67	 mov	 ecx, DWORD PTR maxchar$1$[rbp-153]
  0048c	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00491	3b c8		 cmp	 ecx, eax
  00493	0f 47 c1	 cmova	 eax, ecx

; 2701 :                 n += PyUnicode_GET_LENGTH(obj);

  00496	4c 03 67 60	 add	 r12, QWORD PTR [rdi+96]
  0049a	89 45 67	 mov	 DWORD PTR maxchar$1$[rbp-153], eax

; 2702 :                 break;

  0049d	e9 7b fd ff ff	 jmp	 $LN103@PyUnicode_@99
$LN132@PyUnicode_@99:

; 2698 :                     goto fail;
; 2699 :                 argmaxchar = PyUnicode_MAX_CHAR_VALUE(obj);

  004a2	83 f9 02	 cmp	 ecx, 2

; 2700 :                 maxchar = Py_MAX(maxchar, argmaxchar);

  004a5	8b 4d 67	 mov	 ecx, DWORD PTR maxchar$1$[rbp-153]
  004a8	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH
  004ad	41 0f 44 c5	 cmove	 eax, r13d
  004b1	3b c8		 cmp	 ecx, eax
  004b3	0f 47 c1	 cmova	 eax, ecx

; 2701 :                 n += PyUnicode_GET_LENGTH(obj);

  004b6	4c 03 67 60	 add	 r12, QWORD PTR [rdi+96]
  004ba	89 45 67	 mov	 DWORD PTR maxchar$1$[rbp-153], eax

; 2702 :                 break;

  004bd	e9 5b fd ff ff	 jmp	 $LN103@PyUnicode_@99
$LN71@PyUnicode_@99:

; 2703 :             }
; 2704 :             case 'V':
; 2705 :             {
; 2706 :                 PyObject *obj = va_arg(count, PyObject *);

  004c2	48 8b 7b 08	 mov	 rdi, QWORD PTR [rbx+8]

; 2707 :                 const char *str = va_arg(count, const char *);

  004c6	4c 8b 53 10	 mov	 r10, QWORD PTR [rbx+16]
  004ca	48 83 c3 10	 add	 rbx, 16

; 2708 :                 PyObject *str_obj;
; 2709 :                 assert(obj || str);
; 2710 :                 assert(!obj || _PyUnicode_CHECK(obj));
; 2711 :                 if (obj) {

  004ce	48 85 ff	 test	 rdi, rdi
  004d1	74 63		 je	 SHORT $LN70@PyUnicode_@99

; 2712 :                     if (PyUnicode_READY(obj) == -1)

  004d3	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  004d7	75 11		 jne	 SHORT $LN203@PyUnicode_@99
  004d9	48 8b cf	 mov	 rcx, rdi
  004dc	e8 00 00 00 00	 call	 _PyUnicode_Ready
  004e1	83 f8 ff	 cmp	 eax, -1
  004e4	0f 84 e9 01 00
	00		 je	 $LN222@PyUnicode_@99
$LN203@PyUnicode_@99:

; 2713 :                         goto fail;
; 2714 :                     argmaxchar = PyUnicode_MAX_CHAR_VALUE(obj);

  004ea	8b 4f 70	 mov	 ecx, DWORD PTR [rdi+112]
  004ed	f6 c1 40	 test	 cl, 64			; 00000040H
  004f0	74 07		 je	 SHORT $LN140@PyUnicode_@99
  004f2	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  004f7	eb 1e		 jmp	 SHORT $LN139@PyUnicode_@99
$LN140@PyUnicode_@99:
  004f9	c1 e9 02	 shr	 ecx, 2
  004fc	83 e1 07	 and	 ecx, 7
  004ff	83 f9 01	 cmp	 ecx, 1
  00502	75 07		 jne	 SHORT $LN138@PyUnicode_@99
  00504	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00509	eb 0c		 jmp	 SHORT $LN139@PyUnicode_@99
$LN138@PyUnicode_@99:
  0050b	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH
  00510	83 f9 02	 cmp	 ecx, 2
  00513	41 0f 44 c5	 cmove	 eax, r13d
$LN139@PyUnicode_@99:

; 2715 :                     maxchar = Py_MAX(maxchar, argmaxchar);

  00517	8b 4d 67	 mov	 ecx, DWORD PTR maxchar$1$[rbp-153]
  0051a	3b c8		 cmp	 ecx, eax
  0051c	0f 47 c1	 cmova	 eax, ecx

; 2716 :                     n += PyUnicode_GET_LENGTH(obj);

  0051f	4c 03 67 60	 add	 r12, QWORD PTR [rdi+96]

; 2717 :                     *callresult++ = NULL;

  00523	49 c7 07 00 00
	00 00		 mov	 QWORD PTR [r15], 0
  0052a	89 45 67	 mov	 DWORD PTR maxchar$1$[rbp-153], eax
  0052d	49 83 c7 08	 add	 r15, 8

; 2718 :                 }
; 2719 :                 else {

  00531	e9 e7 fc ff ff	 jmp	 $LN103@PyUnicode_@99
$LN70@PyUnicode_@99:

; 2720 :                     str_obj = PyUnicode_DecodeUTF8Stateful(str, strlen(str), "replace", NULL);

  00536	48 83 c9 ff	 or	 rcx, -1
  0053a	33 c0		 xor	 eax, eax
  0053c	49 8b fa	 mov	 rdi, r10
  0053f	f2 ae		 repne scasb
  00541	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07CLEHDIEJ@replace?$AA@
  00548	45 33 c9	 xor	 r9d, r9d
  0054b	48 f7 d1	 not	 rcx
  0054e	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  00552	49 8b ca	 mov	 rcx, r10
  00555	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8Stateful
  0055a	48 8b f8	 mov	 rdi, rax

; 2721 :                     if (!str_obj)

  0055d	48 85 c0	 test	 rax, rax
  00560	0f 84 6d 01 00
	00		 je	 $LN222@PyUnicode_@99

; 2722 :                         goto fail;
; 2723 :                     if (PyUnicode_READY(str_obj) == -1) {

  00566	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  0056a	75 11		 jne	 SHORT $LN204@PyUnicode_@99
  0056c	48 8b c8	 mov	 rcx, rax
  0056f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00574	83 f8 ff	 cmp	 eax, -1
  00577	0f 84 24 01 00
	00		 je	 $LN191@PyUnicode_@99
$LN204@PyUnicode_@99:

; 2726 :                     }
; 2727 :                     argmaxchar = PyUnicode_MAX_CHAR_VALUE(str_obj);

  0057d	8b 4f 70	 mov	 ecx, DWORD PTR [rdi+112]
  00580	f6 c1 40	 test	 cl, 64			; 00000040H
  00583	0f 84 ca 00 00
	00		 je	 $LN164@PyUnicode_@99
  00589	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  0058e	e9 de 00 00 00	 jmp	 $LN163@PyUnicode_@99
$LN65@PyUnicode_@99:

; 2728 :                     maxchar = Py_MAX(maxchar, argmaxchar);
; 2729 :                     n += PyUnicode_GET_LENGTH(str_obj);
; 2730 :                     *callresult++ = str_obj;
; 2731 :                 }
; 2732 :                 break;
; 2733 :             }
; 2734 :             case 'S':
; 2735 :             {
; 2736 :                 PyObject *obj = va_arg(count, PyObject *);
; 2737 :                 PyObject *str;
; 2738 :                 assert(obj);
; 2739 :                 str = PyObject_Str(obj);

  00593	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00597	48 83 c3 08	 add	 rbx, 8
  0059b	e8 00 00 00 00	 call	 PyObject_Str
  005a0	48 8b f8	 mov	 rdi, rax

; 2740 :                 if (!str)

  005a3	48 85 c0	 test	 rax, rax
  005a6	0f 84 27 01 00
	00		 je	 $LN222@PyUnicode_@99

; 2741 :                     goto fail;
; 2742 :                 if (PyUnicode_READY(str) == -1) {

  005ac	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  005b0	75 11		 jne	 SHORT $LN205@PyUnicode_@99
  005b2	48 8b c8	 mov	 rcx, rax
  005b5	e8 00 00 00 00	 call	 _PyUnicode_Ready
  005ba	83 f8 ff	 cmp	 eax, -1
  005bd	0f 84 de 00 00
	00		 je	 $LN191@PyUnicode_@99
$LN205@PyUnicode_@99:

; 2743 :                     Py_DECREF(str);
; 2744 :                     goto fail;
; 2745 :                 }
; 2746 :                 argmaxchar = PyUnicode_MAX_CHAR_VALUE(str);

  005c3	8b 4f 70	 mov	 ecx, DWORD PTR [rdi+112]
  005c6	f6 c1 40	 test	 cl, 64			; 00000040H
  005c9	0f 84 84 00 00
	00		 je	 $LN164@PyUnicode_@99
  005cf	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  005d4	e9 98 00 00 00	 jmp	 $LN163@PyUnicode_@99
$LN62@PyUnicode_@99:

; 2747 :                 maxchar = Py_MAX(maxchar, argmaxchar);
; 2748 :                 n += PyUnicode_GET_LENGTH(str);
; 2749 :                 /* Remember the str and switch to the next slot */
; 2750 :                 *callresult++ = str;
; 2751 :                 break;
; 2752 :             }
; 2753 :             case 'R':
; 2754 :             {
; 2755 :                 PyObject *obj = va_arg(count, PyObject *);
; 2756 :                 PyObject *repr;
; 2757 :                 assert(obj);
; 2758 :                 repr = PyObject_Repr(obj);

  005d9	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  005dd	48 83 c3 08	 add	 rbx, 8
  005e1	e8 00 00 00 00	 call	 PyObject_Repr
  005e6	48 8b f8	 mov	 rdi, rax

; 2759 :                 if (!repr)

  005e9	48 85 c0	 test	 rax, rax
  005ec	0f 84 e1 00 00
	00		 je	 $LN222@PyUnicode_@99

; 2760 :                     goto fail;
; 2761 :                 if (PyUnicode_READY(repr) == -1) {

  005f2	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  005f6	75 11		 jne	 SHORT $LN206@PyUnicode_@99
  005f8	48 8b c8	 mov	 rcx, rax
  005fb	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00600	83 f8 ff	 cmp	 eax, -1
  00603	0f 84 98 00 00
	00		 je	 $LN191@PyUnicode_@99
$LN206@PyUnicode_@99:

; 2762 :                     Py_DECREF(repr);
; 2763 :                     goto fail;
; 2764 :                 }
; 2765 :                 argmaxchar = PyUnicode_MAX_CHAR_VALUE(repr);

  00609	8b 4f 70	 mov	 ecx, DWORD PTR [rdi+112]
  0060c	f6 c1 40	 test	 cl, 64			; 00000040H
  0060f	74 42		 je	 SHORT $LN164@PyUnicode_@99
  00611	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  00616	eb 59		 jmp	 SHORT $LN163@PyUnicode_@99
$LN59@PyUnicode_@99:

; 2766 :                 maxchar = Py_MAX(maxchar, argmaxchar);
; 2767 :                 n += PyUnicode_GET_LENGTH(repr);
; 2768 :                 /* Remember the repr and switch to the next slot */
; 2769 :                 *callresult++ = repr;
; 2770 :                 break;
; 2771 :             }
; 2772 :             case 'A':
; 2773 :             {
; 2774 :                 PyObject *obj = va_arg(count, PyObject *);
; 2775 :                 PyObject *ascii;
; 2776 :                 assert(obj);
; 2777 :                 ascii = PyObject_ASCII(obj);

  00618	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0061c	48 83 c3 08	 add	 rbx, 8
  00620	e8 00 00 00 00	 call	 PyObject_ASCII
  00625	48 8b f8	 mov	 rdi, rax

; 2778 :                 if (!ascii)

  00628	48 85 c0	 test	 rax, rax
  0062b	0f 84 a2 00 00
	00		 je	 $LN222@PyUnicode_@99

; 2779 :                     goto fail;
; 2780 :                 if (PyUnicode_READY(ascii) == -1) {

  00631	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  00635	75 0d		 jne	 SHORT $LN207@PyUnicode_@99
  00637	48 8b c8	 mov	 rcx, rax
  0063a	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0063f	83 f8 ff	 cmp	 eax, -1
  00642	74 5d		 je	 SHORT $LN191@PyUnicode_@99
$LN207@PyUnicode_@99:

; 2781 :                     Py_DECREF(ascii);
; 2782 :                     goto fail;
; 2783 :                 }
; 2784 :                 argmaxchar = PyUnicode_MAX_CHAR_VALUE(ascii);

  00644	8b 4f 70	 mov	 ecx, DWORD PTR [rdi+112]
  00647	f6 c1 40	 test	 cl, 64			; 00000040H
  0064a	74 07		 je	 SHORT $LN164@PyUnicode_@99
  0064c	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  00651	eb 1e		 jmp	 SHORT $LN163@PyUnicode_@99
$LN164@PyUnicode_@99:
  00653	c1 e9 02	 shr	 ecx, 2
  00656	83 e1 07	 and	 ecx, 7
  00659	83 f9 01	 cmp	 ecx, 1
  0065c	75 07		 jne	 SHORT $LN162@PyUnicode_@99
  0065e	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00663	eb 0c		 jmp	 SHORT $LN163@PyUnicode_@99
$LN162@PyUnicode_@99:
  00665	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH
  0066a	83 f9 02	 cmp	 ecx, 2
  0066d	41 0f 44 c5	 cmove	 eax, r13d
$LN163@PyUnicode_@99:

; 2785 :                 maxchar = Py_MAX(maxchar, argmaxchar);

  00671	8b 4d 67	 mov	 ecx, DWORD PTR maxchar$1$[rbp-153]
  00674	3b c8		 cmp	 ecx, eax
  00676	0f 47 c1	 cmova	 eax, ecx

; 2786 :                 n += PyUnicode_GET_LENGTH(ascii);

  00679	4c 03 67 60	 add	 r12, QWORD PTR [rdi+96]

; 2787 :                 /* Remember the repr and switch to the next slot */
; 2788 :                 *callresult++ = ascii;

  0067d	49 89 3f	 mov	 QWORD PTR [r15], rdi
  00680	89 45 67	 mov	 DWORD PTR maxchar$1$[rbp-153], eax
  00683	49 83 c7 08	 add	 r15, 8

; 2799 :                 goto expand;
; 2800 :             }
; 2801 :         } else

  00687	e9 91 fb ff ff	 jmp	 $LN103@PyUnicode_@99
$LN186@PyUnicode_@99:

; 2587 :                     PyErr_SetString(PyExc_OverflowError,
; 2588 :                                     "%c arg not in range(0x110000)");

  0068c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00693	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@CEOKNOOI@?$CFc?5arg?5not?5in?5range?$CI0x110000?$CJ?$AA@
  0069a	e8 00 00 00 00	 call	 PyErr_SetString

; 2589 :                     goto fail;

  0069f	eb 32		 jmp	 SHORT $LN222@PyUnicode_@99
$LN191@PyUnicode_@99:

; 2724 :                         Py_DECREF(str_obj);

  006a1	48 8b cf	 mov	 rcx, rdi
  006a4	e8 00 00 00 00	 call	 _Py_DecRef

; 2725 :                         goto fail;

  006a9	eb 28		 jmp	 SHORT $LN222@PyUnicode_@99
$LN56@PyUnicode_@99:

; 2789 :                 break;
; 2790 :             }
; 2791 :             default:
; 2792 :                 /* if we stumble upon an unknown
; 2793 :                    formatting code, copy the rest of
; 2794 :                    the format string to the output
; 2795 :                    string. (we cannot just skip the
; 2796 :                    code, since there's no way to know
; 2797 :                    what's in the argument list) */
; 2798 :                 n += strlen(p);

  006ab	48 83 c9 ff	 or	 rcx, -1
  006af	33 c0		 xor	 eax, eax
  006b1	f2 ae		 repne scasb
  006b3	48 f7 d1	 not	 rcx
  006b6	48 ff c9	 dec	 rcx
  006b9	4c 03 e1	 add	 r12, rcx
$expand$127748:

; 2803 :     }
; 2804 :   expand:
; 2805 :     /* step 4: fill the buffer */
; 2806 :     /* Since we've analyzed how much space we need,
; 2807 :        we don't have to resize the string.
; 2808 :        There can be no errors beyond this point. */
; 2809 :     string = PyUnicode_New(n, maxchar);

  006bc	8b 55 67	 mov	 edx, DWORD PTR maxchar$1$[rbp-153]
  006bf	49 8b cc	 mov	 rcx, r12
  006c2	e8 00 00 00 00	 call	 PyUnicode_New
  006c7	4c 8b f0	 mov	 r14, rax

; 2810 :     if (!string)

  006ca	48 85 c0	 test	 rax, rax
  006cd	0f 85 af 00 00
	00		 jne	 $LN54@PyUnicode_@99
$LN222@PyUnicode_@99:

; 2561 :         numberresults = PyObject_Malloc(numbersize);

  006d3	4c 8b 75 af	 mov	 r14, QWORD PTR numberresults$1$[rbp-153]
$fail$127361:

; 2946 :   fail:
; 2947 :     if (callresults) {

  006d7	48 8b 75 cf	 mov	 rsi, QWORD PTR callresults$1$[rbp-153]
  006db	48 85 f6	 test	 rsi, rsi
  006de	0f 84 8a 00 00
	00		 je	 $LN8@PyUnicode_@99

; 2948 :         PyObject **callresult2 = callresults;

  006e4	48 8b de	 mov	 rbx, rsi

; 2949 :         while (callresult2 < callresult) {

  006e7	49 3b f7	 cmp	 rsi, r15
  006ea	73 7a		 jae	 SHORT $LN6@PyUnicode_@99
  006ec	0f 1f 40 00	 npad	 4
$LL7@PyUnicode_@99:

; 2950 :             Py_XDECREF(*callresult2);

  006f0	48 8b 3b	 mov	 rdi, QWORD PTR [rbx]
  006f3	48 85 ff	 test	 rdi, rdi
  006f6	74 65		 je	 SHORT $LN4@PyUnicode_@99
  006f8	e8 00 00 00 00	 call	 _Py_PXCTX
  006fd	85 c0		 test	 eax, eax
  006ff	75 5c		 jne	 SHORT $LN4@PyUnicode_@99
  00701	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00705	a8 20		 test	 al, 32			; 00000020H
  00707	75 4c		 jne	 SHORT $LN174@PyUnicode_@99
  00709	84 c0		 test	 al, al
  0070b	78 48		 js	 SHORT $LN174@PyUnicode_@99
  0070d	a8 02		 test	 al, 2
  0070f	75 4c		 jne	 SHORT $LN4@PyUnicode_@99
  00711	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00715	75 46		 jne	 SHORT $LN4@PyUnicode_@99
  00717	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0071e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00725	4c 8b cf	 mov	 r9, rdi
  00728	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0072e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00736	e8 00 00 00 00	 call	 _PyParallel_Guard
  0073b	48 8b cf	 mov	 rcx, rdi
  0073e	85 c0		 test	 eax, eax
  00740	74 07		 je	 SHORT $LN179@PyUnicode_@99
  00742	e8 00 00 00 00	 call	 _Px_Dealloc
  00747	eb 14		 jmp	 SHORT $LN4@PyUnicode_@99
$LN179@PyUnicode_@99:
  00749	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0074d	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00753	eb 08		 jmp	 SHORT $LN4@PyUnicode_@99
$LN174@PyUnicode_@99:
  00755	48 8b cf	 mov	 rcx, rdi
  00758	e8 00 00 00 00	 call	 Px_DecRef
$LN4@PyUnicode_@99:

; 2951 :             ++callresult2;

  0075d	48 83 c3 08	 add	 rbx, 8
  00761	49 3b df	 cmp	 rbx, r15
  00764	72 8a		 jb	 SHORT $LL7@PyUnicode_@99
$LN6@PyUnicode_@99:

; 2952 :         }
; 2953 :         PyObject_Free(callresults);

  00766	48 8b ce	 mov	 rcx, rsi
  00769	e8 00 00 00 00	 call	 PyObject_Free
$LN8@PyUnicode_@99:

; 2954 :     }
; 2955 :     if (numberresults)

  0076e	4d 85 f6	 test	 r14, r14
  00771	74 08		 je	 SHORT $LN1@PyUnicode_@99

; 2956 :         PyObject_Free(numberresults);

  00773	49 8b ce	 mov	 rcx, r14
  00776	e8 00 00 00 00	 call	 PyObject_Free
$LN1@PyUnicode_@99:

; 2957 :     return NULL;

  0077b	33 c0		 xor	 eax, eax
  0077d	e9 8b 02 00 00	 jmp	 $LN124@PyUnicode_@99
$LN54@PyUnicode_@99:

; 2811 :         goto fail;
; 2812 :     kind = PyUnicode_KIND(string);

  00782	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00785	44 8b e8	 mov	 r13d, eax
  00788	41 c1 ed 02	 shr	 r13d, 2
  0078c	41 83 e5 07	 and	 r13d, 7

; 2813 :     data = PyUnicode_DATA(string);

  00790	a8 20		 test	 al, 32			; 00000020H
  00792	74 16		 je	 SHORT $LN168@PyUnicode_@99
  00794	a8 40		 test	 al, 64			; 00000040H
  00796	74 09		 je	 SHORT $LN166@PyUnicode_@99
  00798	49 8d b6 80 00
	00 00		 lea	 rsi, QWORD PTR [r14+128]
  0079f	eb 10		 jmp	 SHORT $LN169@PyUnicode_@99
$LN166@PyUnicode_@99:
  007a1	49 8d b6 a0 00
	00 00		 lea	 rsi, QWORD PTR [r14+160]
  007a8	eb 07		 jmp	 SHORT $LN169@PyUnicode_@99
$LN168@PyUnicode_@99:
  007aa	49 8b b6 a0 00
	00 00		 mov	 rsi, QWORD PTR [r14+160]
$LN169@PyUnicode_@99:

; 2815 :     numberresult = numberresults;
; 2816 : 
; 2817 :     for (i = 0, f = format; *f; f++) {

  007b1	48 8b 45 c7	 mov	 rax, QWORD PTR f$3$[rbp-153]
  007b5	48 8b 7d cf	 mov	 rdi, QWORD PTR callresults$1$[rbp-153]
  007b9	4c 8b 65 af	 mov	 r12, QWORD PTR numberresults$1$[rbp-153]
  007bd	33 db		 xor	 ebx, ebx
  007bf	48 89 7d 67	 mov	 QWORD PTR callresult$2$[rbp-153], rdi
  007c3	4c 89 65 77	 mov	 QWORD PTR numberresult$2$[rbp-153], r12
  007c7	38 18		 cmp	 BYTE PTR [rax], bl
  007c9	0f 84 18 02 00
	00		 je	 $end$127945

; 2814 :     callresult = callresults;

  007cf	4c 8b 65 6f	 mov	 r12, QWORD PTR vargs$[rbp-153]
  007d3	49 83 c4 f8	 add	 r12, -8
  007d7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL53@PyUnicode_@99:

; 2818 :         if (*f == '%') {

  007e0	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  007e3	80 fa 25	 cmp	 dl, 37			; 00000025H
  007e6	0f 85 a8 01 00
	00		 jne	 $LN18@PyUnicode_@99

; 2819 :             const char* p;
; 2820 : 
; 2821 :             p = f;
; 2822 :             f = parse_format_flags(f, NULL, NULL, NULL, NULL, NULL);

  007ec	45 33 c9	 xor	 r9d, r9d
  007ef	45 33 c0	 xor	 r8d, r8d
  007f2	33 d2		 xor	 edx, edx
  007f4	48 8b c8	 mov	 rcx, rax
  007f7	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00800	4c 8b f8	 mov	 r15, rax
  00803	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0080c	e8 00 00 00 00	 call	 parse_format_flags

; 2823 :             /* checking for == because the last argument could be a empty
; 2824 :                string, which causes i to point to end, the assert at the end of
; 2825 :                the loop */
; 2826 :             assert(i <= PyUnicode_GET_LENGTH(string));
; 2827 : 
; 2828 :             switch (*f) {

  00811	0f be 10	 movsx	 edx, BYTE PTR [rax]
  00814	48 89 45 c7	 mov	 QWORD PTR f$3$[rbp-153], rax
  00818	8d 42 db	 lea	 eax, DWORD PTR [rdx-37]
  0081b	83 f8 53	 cmp	 eax, 83			; 00000053H
  0081e	0f 87 9f 01 00
	00		 ja	 $LN20@PyUnicode_@99
  00824	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  0082b	48 98		 cdqe
  0082d	41 0f b6 84 00
	00 00 00 00	 movzx	 eax, BYTE PTR $LN208@PyUnicode_@99[r8+rax]
  00836	41 8b 8c 80 00
	00 00 00	 mov	 ecx, DWORD PTR $LN209@PyUnicode_@99[r8+rax*4]
  0083e	49 03 c8	 add	 rcx, r8
  00841	ff e1		 jmp	 rcx
$LN47@PyUnicode_@99:

; 2829 :             case 'c':
; 2830 :             {
; 2831 :                 const int ordinal = va_arg(vargs, int);

  00843	41 8b 54 24 08	 mov	 edx, DWORD PTR [r12+8]
  00848	49 83 c4 08	 add	 r12, 8

; 2832 :                 PyUnicode_WRITE(kind, data, i++, ordinal);

  0084c	41 8b cd	 mov	 ecx, r13d
  0084f	ff c9		 dec	 ecx
  00851	0f 84 50 01 00
	00		 je	 $LN13@PyUnicode_@99
  00857	ff c9		 dec	 ecx
  00859	74 08		 je	 SHORT $LN40@PyUnicode_@99
  0085b	89 14 9e	 mov	 DWORD PTR [rsi+rbx*4], edx
  0085e	e9 47 01 00 00	 jmp	 $LN228@PyUnicode_@99
$LN40@PyUnicode_@99:
  00863	66 89 14 5e	 mov	 WORD PTR [rsi+rbx*2], dx
  00867	e9 3e 01 00 00	 jmp	 $LN228@PyUnicode_@99
$LN38@PyUnicode_@99:

; 2833 :                 break;
; 2834 :             }
; 2835 :             case 'i':
; 2836 :             case 'd':
; 2837 :             case 'u':
; 2838 :             case 'x':
; 2839 :             case 'p':
; 2840 :             {
; 2841 :                 Py_ssize_t len;
; 2842 :                 /* unused, since we already have the result */
; 2843 :                 if (*f == 'p')
; 2844 :                     (void) va_arg(vargs, void *);
; 2845 :                 else
; 2846 :                     (void) va_arg(vargs, int);
; 2847 :                 /* extract the result from numberresults and append. */
; 2848 :                 len = strlen(numberresult);

  0086c	4c 8b 7d 77	 mov	 r15, QWORD PTR numberresult$2$[rbp-153]
  00870	48 83 c9 ff	 or	 rcx, -1
  00874	33 c0		 xor	 eax, eax
  00876	49 8b ff	 mov	 rdi, r15

; 2849 :                 unicode_write_cstr(string, i, numberresult, len);

  00879	48 8b d3	 mov	 rdx, rbx
  0087c	4d 8b c7	 mov	 r8, r15
  0087f	f2 ae		 repne scasb
  00881	49 83 c4 08	 add	 r12, 8
  00885	48 f7 d1	 not	 rcx
  00888	4c 8d 49 ff	 lea	 r9, QWORD PTR [rcx-1]
  0088c	48 8d 79 ff	 lea	 rdi, QWORD PTR [rcx-1]
  00890	49 8b ce	 mov	 rcx, r14
  00893	e8 00 00 00 00	 call	 unicode_write_cstr

; 2850 :                 /* skip over the separating '\0' */
; 2851 :                 i += len;
; 2852 :                 numberresult += len;
; 2853 :                 assert(*numberresult == '\0');
; 2854 :                 numberresult++;

  00898	4d 8d 7c 3f 01	 lea	 r15, QWORD PTR [r15+rdi+1]
  0089d	48 03 df	 add	 rbx, rdi

; 2855 :                 assert(numberresult <= numberresults + numbersize);
; 2856 :                 break;

  008a0	48 8b 7d 67	 mov	 rdi, QWORD PTR callresult$2$[rbp-153]
  008a4	4c 89 7d 77	 mov	 QWORD PTR numberresult$2$[rbp-153], r15
  008a8	e9 00 01 00 00	 jmp	 $LN16@PyUnicode_@99
$LN35@PyUnicode_@99:

; 2857 :             }
; 2858 :             case 's':
; 2859 :             {
; 2860 :                 /* unused, since we already have the result */
; 2861 :                 Py_ssize_t size;
; 2862 :                 (void) va_arg(vargs, char *);
; 2863 :                 size = PyUnicode_GET_LENGTH(*callresult);

  008ad	4c 8b 07	 mov	 r8, QWORD PTR [rdi]

; 2864 :                 assert(PyUnicode_KIND(*callresult) <= PyUnicode_KIND(string));
; 2865 :                 _PyUnicode_FastCopyCharacters(string, i, *callresult, 0, size);

  008b0	45 33 c9	 xor	 r9d, r9d
  008b3	48 8b d3	 mov	 rdx, rbx
  008b6	49 8b 78 60	 mov	 rdi, QWORD PTR [r8+96]
  008ba	49 8b ce	 mov	 rcx, r14
  008bd	49 83 c4 08	 add	 r12, 8
  008c1	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  008c6	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 2866 :                 i += size;

  008cb	48 03 df	 add	 rbx, rdi

; 2867 :                 /* We're done with the unicode()/repr() => forget it */
; 2868 :                 Py_DECREF(*callresult);

  008ce	48 8b 7d 67	 mov	 rdi, QWORD PTR callresult$2$[rbp-153]
  008d2	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  008d5	e8 00 00 00 00	 call	 _Py_DecRef

; 2869 :                 /* switch to next unicode()/repr() result */
; 2870 :                 ++callresult;

  008da	48 83 c7 08	 add	 rdi, 8
  008de	48 89 7d 67	 mov	 QWORD PTR callresult$2$[rbp-153], rdi

; 2871 :                 break;

  008e2	e9 c6 00 00 00	 jmp	 $LN16@PyUnicode_@99
$LN34@PyUnicode_@99:

; 2872 :             }
; 2873 :             case 'U':
; 2874 :             {
; 2875 :                 PyObject *obj = va_arg(vargs, PyObject *);

  008e7	4d 8b 44 24 08	 mov	 r8, QWORD PTR [r12+8]
  008ec	49 83 c4 08	 add	 r12, 8

; 2876 :                 Py_ssize_t size;
; 2877 :                 assert(PyUnicode_KIND(obj) <= PyUnicode_KIND(string));
; 2878 :                 size = PyUnicode_GET_LENGTH(obj);
; 2879 :                 _PyUnicode_FastCopyCharacters(string, i, obj, 0, size);

  008f0	45 33 c9	 xor	 r9d, r9d
  008f3	49 8b 78 60	 mov	 rdi, QWORD PTR [r8+96]
  008f7	48 8b d3	 mov	 rdx, rbx
  008fa	49 8b ce	 mov	 rcx, r14
  008fd	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00902	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 2880 :                 i += size;

  00907	48 03 df	 add	 rbx, rdi

; 2881 :                 break;

  0090a	48 8b 7d 67	 mov	 rdi, QWORD PTR callresult$2$[rbp-153]
  0090e	e9 9a 00 00 00	 jmp	 $LN16@PyUnicode_@99
$LN33@PyUnicode_@99:

; 2882 :             }
; 2883 :             case 'V':
; 2884 :             {
; 2885 :                 Py_ssize_t size;
; 2886 :                 PyObject *obj = va_arg(vargs, PyObject *);

  00913	4d 8b 44 24 08	 mov	 r8, QWORD PTR [r12+8]

; 2887 :                 va_arg(vargs, const char *);

  00918	49 83 c4 10	 add	 r12, 16

; 2888 :                 if (obj) {
; 2889 :                     size = PyUnicode_GET_LENGTH(obj);
; 2890 :                     assert(PyUnicode_KIND(obj) <= PyUnicode_KIND(string));
; 2891 :                     _PyUnicode_FastCopyCharacters(string, i, obj, 0, size);

  0091c	45 33 c9	 xor	 r9d, r9d
  0091f	48 8b d3	 mov	 rdx, rbx
  00922	49 8b ce	 mov	 rcx, r14
  00925	4d 85 c0	 test	 r8, r8
  00928	74 1f		 je	 SHORT $LN32@PyUnicode_@99
  0092a	49 8b 78 60	 mov	 rdi, QWORD PTR [r8+96]
  0092e	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00933	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 2892 :                     i += size;

  00938	48 03 df	 add	 rbx, rdi

; 2893 :                 } else {

  0093b	48 8b 7d 67	 mov	 rdi, QWORD PTR callresult$2$[rbp-153]

; 2900 :                 }
; 2901 :                 ++callresult;

  0093f	48 83 c7 08	 add	 rdi, 8
  00943	48 89 7d 67	 mov	 QWORD PTR callresult$2$[rbp-153], rdi

; 2902 :                 break;
; 2903 :             }
; 2904 :             case 'S':
; 2905 :             case 'R':
; 2906 :             case 'A':
; 2907 :             {
; 2908 :                 Py_ssize_t size = PyUnicode_GET_LENGTH(*callresult);
; 2909 :                 /* unused, since we already have the result */
; 2910 :                 (void) va_arg(vargs, PyObject *);
; 2911 :                 assert(PyUnicode_KIND(*callresult) <= PyUnicode_KIND(string));
; 2912 :                 _PyUnicode_FastCopyCharacters(string, i, *callresult, 0,  size);
; 2913 :                 i += size;
; 2914 :                 /* We're done with the unicode()/repr() => forget it */
; 2915 :                 Py_DECREF(*callresult);
; 2916 :                 /* switch to next unicode()/repr() result */
; 2917 :                 ++callresult;
; 2918 :                 break;

  00947	eb 64		 jmp	 SHORT $LN16@PyUnicode_@99
$LN32@PyUnicode_@99:

; 2894 :                     size = PyUnicode_GET_LENGTH(*callresult);

  00949	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
  0094c	49 8b 78 60	 mov	 rdi, QWORD PTR [r8+96]

; 2895 :                     assert(PyUnicode_KIND(*callresult) <=
; 2896 :                            PyUnicode_KIND(string));
; 2897 :                     _PyUnicode_FastCopyCharacters(string, i, *callresult, 0, size);

  00950	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00955	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 2898 :                     i += size;

  0095a	48 03 df	 add	 rbx, rdi

; 2899 :                     Py_DECREF(*callresult);

  0095d	48 8b 7d 67	 mov	 rdi, QWORD PTR callresult$2$[rbp-153]
  00961	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00964	e8 00 00 00 00	 call	 _Py_DecRef

; 2900 :                 }
; 2901 :                 ++callresult;

  00969	48 83 c7 08	 add	 rdi, 8
  0096d	48 89 7d 67	 mov	 QWORD PTR callresult$2$[rbp-153], rdi

; 2902 :                 break;
; 2903 :             }
; 2904 :             case 'S':
; 2905 :             case 'R':
; 2906 :             case 'A':
; 2907 :             {
; 2908 :                 Py_ssize_t size = PyUnicode_GET_LENGTH(*callresult);
; 2909 :                 /* unused, since we already have the result */
; 2910 :                 (void) va_arg(vargs, PyObject *);
; 2911 :                 assert(PyUnicode_KIND(*callresult) <= PyUnicode_KIND(string));
; 2912 :                 _PyUnicode_FastCopyCharacters(string, i, *callresult, 0,  size);
; 2913 :                 i += size;
; 2914 :                 /* We're done with the unicode()/repr() => forget it */
; 2915 :                 Py_DECREF(*callresult);
; 2916 :                 /* switch to next unicode()/repr() result */
; 2917 :                 ++callresult;
; 2918 :                 break;

  00971	eb 3a		 jmp	 SHORT $LN16@PyUnicode_@99
$LN28@PyUnicode_@99:

; 2919 :             }
; 2920 :             case '%':
; 2921 :                 PyUnicode_WRITE(kind, data, i++, '%');

  00973	41 8b cd	 mov	 ecx, r13d
  00976	ff c9		 dec	 ecx
  00978	74 14		 je	 SHORT $LN23@PyUnicode_@99
  0097a	ff c9		 dec	 ecx
  0097c	b8 25 00 00 00	 mov	 eax, 37			; 00000025H
  00981	74 05		 je	 SHORT $LN22@PyUnicode_@99
  00983	89 04 9e	 mov	 DWORD PTR [rsi+rbx*4], eax
  00986	eb 22		 jmp	 SHORT $LN228@PyUnicode_@99
$LN22@PyUnicode_@99:
  00988	66 89 04 5e	 mov	 WORD PTR [rsi+rbx*2], ax
  0098c	eb 1c		 jmp	 SHORT $LN228@PyUnicode_@99
$LN23@PyUnicode_@99:
  0098e	c6 04 33 25	 mov	 BYTE PTR [rbx+rsi], 37	; 00000025H

; 2927 :                 i += len;
; 2928 :                 assert(i == PyUnicode_GET_LENGTH(string));
; 2929 :                 goto end;
; 2930 :             }
; 2931 :             }
; 2932 :         }
; 2933 :         else {

  00992	eb 16		 jmp	 SHORT $LN228@PyUnicode_@99
$LN18@PyUnicode_@99:

; 2934 :             assert(i < PyUnicode_GET_LENGTH(string));
; 2935 :             PyUnicode_WRITE(kind, data, i++, *f);

  00994	41 8b cd	 mov	 ecx, r13d
  00997	ff c9		 dec	 ecx
  00999	74 0c		 je	 SHORT $LN13@PyUnicode_@99
  0099b	ff c9		 dec	 ecx
  0099d	0f be c2	 movsx	 eax, dl
  009a0	74 e6		 je	 SHORT $LN22@PyUnicode_@99
  009a2	89 04 9e	 mov	 DWORD PTR [rsi+rbx*4], eax
  009a5	eb 03		 jmp	 SHORT $LN228@PyUnicode_@99
$LN13@PyUnicode_@99:
  009a7	88 14 33	 mov	 BYTE PTR [rbx+rsi], dl
$LN228@PyUnicode_@99:
  009aa	48 ff c3	 inc	 rbx
$LN16@PyUnicode_@99:

; 2815 :     numberresult = numberresults;
; 2816 : 
; 2817 :     for (i = 0, f = format; *f; f++) {

  009ad	48 8b 45 c7	 mov	 rax, QWORD PTR f$3$[rbp-153]
  009b1	48 ff c0	 inc	 rax
  009b4	48 89 45 c7	 mov	 QWORD PTR f$3$[rbp-153], rax
  009b8	80 38 00	 cmp	 BYTE PTR [rax], 0
  009bb	0f 85 1f fe ff
	ff		 jne	 $LL53@PyUnicode_@99
  009c1	eb 20		 jmp	 SHORT $LN215@PyUnicode_@99
$LN20@PyUnicode_@99:

; 2922 :                 break;
; 2923 :             default:
; 2924 :             {
; 2925 :                 Py_ssize_t len = strlen(p);

  009c3	48 83 c9 ff	 or	 rcx, -1
  009c7	33 c0		 xor	 eax, eax
  009c9	49 8b ff	 mov	 rdi, r15
  009cc	f2 ae		 repne scasb

; 2926 :                 unicode_write_cstr(string, i, p, len);

  009ce	4d 8b c7	 mov	 r8, r15
  009d1	48 8b d3	 mov	 rdx, rbx
  009d4	48 f7 d1	 not	 rcx
  009d7	4c 8d 49 ff	 lea	 r9, QWORD PTR [rcx-1]
  009db	49 8b ce	 mov	 rcx, r14
  009de	e8 00 00 00 00	 call	 unicode_write_cstr
$LN215@PyUnicode_@99:

; 2565 :         }
; 2566 :         numberresult = numberresults;

  009e3	4c 8b 65 af	 mov	 r12, QWORD PTR numberresults$1$[rbp-153]
$end$127945:

; 2936 :         }
; 2937 :     }
; 2938 :     assert(i == PyUnicode_GET_LENGTH(string));
; 2939 : 
; 2940 :   end:
; 2941 :     if (callresults)

  009e7	48 8b 45 cf	 mov	 rax, QWORD PTR callresults$1$[rbp-153]
  009eb	48 85 c0	 test	 rax, rax
  009ee	74 08		 je	 SHORT $LN10@PyUnicode_@99

; 2942 :         PyObject_Free(callresults);

  009f0	48 8b c8	 mov	 rcx, rax
  009f3	e8 00 00 00 00	 call	 PyObject_Free
$LN10@PyUnicode_@99:

; 2943 :     if (numberresults)

  009f8	4d 85 e4	 test	 r12, r12
  009fb	74 08		 je	 SHORT $LN9@PyUnicode_@99

; 2944 :         PyObject_Free(numberresults);

  009fd	49 8b cc	 mov	 rcx, r12
  00a00	e8 00 00 00 00	 call	 PyObject_Free
$LN9@PyUnicode_@99:

; 2945 :     return unicode_result(string);

  00a05	49 8b ce	 mov	 rcx, r14
  00a08	e8 00 00 00 00	 call	 unicode_result
$LN124@PyUnicode_@99:

; 2958 : }

  00a0d	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00a14	41 5f		 pop	 r15
  00a16	41 5e		 pop	 r14
  00a18	41 5d		 pop	 r13
  00a1a	41 5c		 pop	 r12
  00a1c	5f		 pop	 rdi
  00a1d	5e		 pop	 rsi
  00a1e	5b		 pop	 rbx
  00a1f	5d		 pop	 rbp
  00a20	c3		 ret	 0
  00a21	0f 1f 00	 npad	 3
$LN211@PyUnicode_@99:
  00a24	00 00 00 00	 DD	 $LN101@PyUnicode_@99
  00a28	00 00 00 00	 DD	 $LN59@PyUnicode_@99
  00a2c	00 00 00 00	 DD	 $LN62@PyUnicode_@99
  00a30	00 00 00 00	 DD	 $LN65@PyUnicode_@99
  00a34	00 00 00 00	 DD	 $LN73@PyUnicode_@99
  00a38	00 00 00 00	 DD	 $LN71@PyUnicode_@99
  00a3c	00 00 00 00	 DD	 $LN98@PyUnicode_@99
  00a40	00 00 00 00	 DD	 $LN94@PyUnicode_@99
  00a44	00 00 00 00	 DD	 $LN79@PyUnicode_@99
  00a48	00 00 00 00	 DD	 $LN75@PyUnicode_@99
  00a4c	00 00 00 00	 DD	 $LN87@PyUnicode_@99
  00a50	00 00 00 00	 DD	 $LN80@PyUnicode_@99
  00a54	00 00 00 00	 DD	 $LN56@PyUnicode_@99
$LN210@PyUnicode_@99:
  00a58	00		 DB	 0
  00a59	0c		 DB	 12
  00a5a	0c		 DB	 12
  00a5b	0c		 DB	 12
  00a5c	0c		 DB	 12
  00a5d	0c		 DB	 12
  00a5e	0c		 DB	 12
  00a5f	0c		 DB	 12
  00a60	0c		 DB	 12
  00a61	0c		 DB	 12
  00a62	0c		 DB	 12
  00a63	0c		 DB	 12
  00a64	0c		 DB	 12
  00a65	0c		 DB	 12
  00a66	0c		 DB	 12
  00a67	0c		 DB	 12
  00a68	0c		 DB	 12
  00a69	0c		 DB	 12
  00a6a	0c		 DB	 12
  00a6b	0c		 DB	 12
  00a6c	0c		 DB	 12
  00a6d	0c		 DB	 12
  00a6e	0c		 DB	 12
  00a6f	0c		 DB	 12
  00a70	0c		 DB	 12
  00a71	0c		 DB	 12
  00a72	0c		 DB	 12
  00a73	0c		 DB	 12
  00a74	01		 DB	 1
  00a75	0c		 DB	 12
  00a76	0c		 DB	 12
  00a77	0c		 DB	 12
  00a78	0c		 DB	 12
  00a79	0c		 DB	 12
  00a7a	0c		 DB	 12
  00a7b	0c		 DB	 12
  00a7c	0c		 DB	 12
  00a7d	0c		 DB	 12
  00a7e	0c		 DB	 12
  00a7f	0c		 DB	 12
  00a80	0c		 DB	 12
  00a81	0c		 DB	 12
  00a82	0c		 DB	 12
  00a83	0c		 DB	 12
  00a84	0c		 DB	 12
  00a85	02		 DB	 2
  00a86	03		 DB	 3
  00a87	0c		 DB	 12
  00a88	04		 DB	 4
  00a89	05		 DB	 5
  00a8a	0c		 DB	 12
  00a8b	0c		 DB	 12
  00a8c	0c		 DB	 12
  00a8d	0c		 DB	 12
  00a8e	0c		 DB	 12
  00a8f	0c		 DB	 12
  00a90	0c		 DB	 12
  00a91	0c		 DB	 12
  00a92	0c		 DB	 12
  00a93	0c		 DB	 12
  00a94	0c		 DB	 12
  00a95	0c		 DB	 12
  00a96	06		 DB	 6
  00a97	07		 DB	 7
  00a98	0c		 DB	 12
  00a99	0c		 DB	 12
  00a9a	0c		 DB	 12
  00a9b	0c		 DB	 12
  00a9c	07		 DB	 7
  00a9d	0c		 DB	 12
  00a9e	0c		 DB	 12
  00a9f	0c		 DB	 12
  00aa0	0c		 DB	 12
  00aa1	0c		 DB	 12
  00aa2	0c		 DB	 12
  00aa3	08		 DB	 8
  00aa4	0c		 DB	 12
  00aa5	0c		 DB	 12
  00aa6	09		 DB	 9
  00aa7	0c		 DB	 12
  00aa8	0a		 DB	 10
  00aa9	0c		 DB	 12
  00aaa	0c		 DB	 12
  00aab	0b		 DB	 11
$LN209@PyUnicode_@99:
  00aac	00 00 00 00	 DD	 $LN28@PyUnicode_@99
  00ab0	00 00 00 00	 DD	 $LN35@PyUnicode_@99
  00ab4	00 00 00 00	 DD	 $LN34@PyUnicode_@99
  00ab8	00 00 00 00	 DD	 $LN33@PyUnicode_@99
  00abc	00 00 00 00	 DD	 $LN47@PyUnicode_@99
  00ac0	00 00 00 00	 DD	 $LN38@PyUnicode_@99
  00ac4	00 00 00 00	 DD	 $LN20@PyUnicode_@99
$LN208@PyUnicode_@99:
  00ac8	00		 DB	 0
  00ac9	06		 DB	 6
  00aca	06		 DB	 6
  00acb	06		 DB	 6
  00acc	06		 DB	 6
  00acd	06		 DB	 6
  00ace	06		 DB	 6
  00acf	06		 DB	 6
  00ad0	06		 DB	 6
  00ad1	06		 DB	 6
  00ad2	06		 DB	 6
  00ad3	06		 DB	 6
  00ad4	06		 DB	 6
  00ad5	06		 DB	 6
  00ad6	06		 DB	 6
  00ad7	06		 DB	 6
  00ad8	06		 DB	 6
  00ad9	06		 DB	 6
  00ada	06		 DB	 6
  00adb	06		 DB	 6
  00adc	06		 DB	 6
  00add	06		 DB	 6
  00ade	06		 DB	 6
  00adf	06		 DB	 6
  00ae0	06		 DB	 6
  00ae1	06		 DB	 6
  00ae2	06		 DB	 6
  00ae3	06		 DB	 6
  00ae4	01		 DB	 1
  00ae5	06		 DB	 6
  00ae6	06		 DB	 6
  00ae7	06		 DB	 6
  00ae8	06		 DB	 6
  00ae9	06		 DB	 6
  00aea	06		 DB	 6
  00aeb	06		 DB	 6
  00aec	06		 DB	 6
  00aed	06		 DB	 6
  00aee	06		 DB	 6
  00aef	06		 DB	 6
  00af0	06		 DB	 6
  00af1	06		 DB	 6
  00af2	06		 DB	 6
  00af3	06		 DB	 6
  00af4	06		 DB	 6
  00af5	01		 DB	 1
  00af6	01		 DB	 1
  00af7	06		 DB	 6
  00af8	02		 DB	 2
  00af9	03		 DB	 3
  00afa	06		 DB	 6
  00afb	06		 DB	 6
  00afc	06		 DB	 6
  00afd	06		 DB	 6
  00afe	06		 DB	 6
  00aff	06		 DB	 6
  00b00	06		 DB	 6
  00b01	06		 DB	 6
  00b02	06		 DB	 6
  00b03	06		 DB	 6
  00b04	06		 DB	 6
  00b05	06		 DB	 6
  00b06	04		 DB	 4
  00b07	05		 DB	 5
  00b08	06		 DB	 6
  00b09	06		 DB	 6
  00b0a	06		 DB	 6
  00b0b	06		 DB	 6
  00b0c	05		 DB	 5
  00b0d	06		 DB	 6
  00b0e	06		 DB	 6
  00b0f	06		 DB	 6
  00b10	06		 DB	 6
  00b11	06		 DB	 6
  00b12	06		 DB	 6
  00b13	05		 DB	 5
  00b14	06		 DB	 6
  00b15	06		 DB	 6
  00b16	01		 DB	 1
  00b17	06		 DB	 6
  00b18	05		 DB	 5
  00b19	06		 DB	 6
  00b1a	06		 DB	 6
  00b1b	05		 DB	 5
PyUnicode_FromFormatV ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_FromFormat
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_FromFormat DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$PyUnicode_FromFormat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_FromFormat DD 011801H
	DD	04218H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_FromFormat
_TEXT	SEGMENT
format$ = 48
PyUnicode_FromFormat PROC				; COMDAT

; 2962 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2963 :     PyObject* ret;
; 2964 :     va_list vargs;
; 2965 : 
; 2966 : #ifdef HAVE_STDARG_PROTOTYPES
; 2967 :     va_start(vargs, format);

  00018	48 8d 54 24 38	 lea	 rdx, QWORD PTR format$[rsp+8]

; 2968 : #else
; 2969 :     va_start(vargs);
; 2970 : #endif
; 2971 :     ret = PyUnicode_FromFormatV(format, vargs);

  0001d	e8 00 00 00 00	 call	 PyUnicode_FromFormatV

; 2972 :     va_end(vargs);
; 2973 :     return ret;
; 2974 : }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
PyUnicode_FromFormat ENDP
_TEXT	ENDS
PUBLIC	??_C@_05PHHJNLHL@sOnnO?$AA@			; `string'
PUBLIC	??_C@_06NDGIILMC@locale?$AA@			; `string'
PUBLIC	??_C@_0DF@NNEJMCMG@wcstombs?$CI?$CJ?5encountered?5an?5unenco@ ; `string'
PUBLIC	??_C@_0BI@GLGICKAD@embedded?5null?5character?$AA@ ; `string'
PUBLIC	PyUnicode_EncodeLocale
EXTRN	_Py_char2wchar:PROC
EXTRN	__imp_strerror:PROC
EXTRN	__imp__errno:PROC
EXTRN	PyBytes_FromString:PROC
EXTRN	_Py_wchar2char:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_EncodeLocale DD imagerel $LN35
	DD	imagerel $LN35+52
	DD	imagerel $unwind$PyUnicode_EncodeLocale
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyUnicode_EncodeLocale DD imagerel $LN35+52
	DD	imagerel $LN35+82
	DD	imagerel $chain$0$PyUnicode_EncodeLocale
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyUnicode_EncodeLocale DD imagerel $LN35+82
	DD	imagerel $LN35+257
	DD	imagerel $chain$3$PyUnicode_EncodeLocale
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyUnicode_EncodeLocale DD imagerel $LN35+257
	DD	imagerel $LN35+354
	DD	imagerel $chain$5$PyUnicode_EncodeLocale
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$PyUnicode_EncodeLocale DD imagerel $LN35+354
	DD	imagerel $LN35+616
	DD	imagerel $chain$7$PyUnicode_EncodeLocale
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$PyUnicode_EncodeLocale DD 040021H
	DD	0a7400H
	DD	0e3400H
	DD	imagerel $LN35
	DD	imagerel $LN35+52
	DD	imagerel $unwind$PyUnicode_EncodeLocale
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyUnicode_EncodeLocale DD 040021H
	DD	0a7400H
	DD	0e3400H
	DD	imagerel $LN35
	DD	imagerel $LN35+52
	DD	imagerel $unwind$PyUnicode_EncodeLocale
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyUnicode_EncodeLocale DD 040921H
	DD	0a7409H
	DD	0e3400H
	DD	imagerel $LN35
	DD	imagerel $LN35+52
	DD	imagerel $unwind$PyUnicode_EncodeLocale
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyUnicode_EncodeLocale DD 020521H
	DD	0e3405H
	DD	imagerel $LN35
	DD	imagerel $LN35+52
	DD	imagerel $unwind$PyUnicode_EncodeLocale
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_EncodeLocale DD 030701H
	DD	06003a207H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_05PHHJNLHL@sOnnO?$AA@
CONST	SEGMENT
??_C@_05PHHJNLHL@sOnnO?$AA@ DB 'sOnnO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NDGIILMC@locale?$AA@
CONST	SEGMENT
??_C@_06NDGIILMC@locale?$AA@ DB 'locale', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@NNEJMCMG@wcstombs?$CI?$CJ?5encountered?5an?5unenco@
CONST	SEGMENT
??_C@_0DF@NNEJMCMG@wcstombs?$CI?$CJ?5encountered?5an?5unenco@ DB 'wcstomb'
	DB	's() encountered an unencodable wide character', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GLGICKAD@embedded?5null?5character?$AA@
CONST	SEGMENT
??_C@_0BI@GLGICKAD@embedded?5null?5character?$AA@ DB 'embedded null chara'
	DB	'cter', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_EncodeLocale
_TEXT	SEGMENT
wlen$ = 64
unicode$ = 112
errors$ = 120
errlen$128444 = 128
surrogateescape$ = 128
error_pos$ = 136
PyUnicode_EncodeLocale PROC				; COMDAT

; 3414 : {

$LN35:
  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00007	48 8b c2	 mov	 rax, rdx
  0000a	48 8b e9	 mov	 rbp, rcx

; 3415 :     Py_ssize_t wlen, wlen2;
; 3416 :     wchar_t *wstr;
; 3417 :     PyObject *bytes = NULL;
; 3418 :     char *errmsg;
; 3419 :     PyObject *reason = NULL;
; 3420 :     PyObject *exc;
; 3421 :     size_t error_pos;
; 3422 :     int surrogateescape;
; 3423 : 
; 3424 :     if (locale_error_handler(errors, &surrogateescape) < 0)

  0000d	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR surrogateescape$[rsp]
  00015	48 8b c8	 mov	 rcx, rax
  00018	33 f6		 xor	 esi, esi
  0001a	e8 00 00 00 00	 call	 locale_error_handler
  0001f	85 c0		 test	 eax, eax
  00021	79 09		 jns	 SHORT $LN27@PyUnicode_@100

; 3425 :         return NULL;

  00023	33 c0		 xor	 eax, eax

; 3519 : }

  00025	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00029	5e		 pop	 rsi
  0002a	5d		 pop	 rbp
  0002b	c3		 ret	 0
$LN27@PyUnicode_@100:

; 3426 : 
; 3427 :     wstr = PyUnicode_AsWideCharString(unicode, &wlen);

  0002c	48 8d 54 24 40	 lea	 rdx, QWORD PTR wlen$[rsp]
  00031	48 8b cd	 mov	 rcx, rbp
  00034	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx
  00039	e8 00 00 00 00	 call	 PyUnicode_AsWideCharString
  0003e	48 8b d8	 mov	 rbx, rax

; 3428 :     if (wstr == NULL)

  00041	48 85 c0	 test	 rax, rax
  00044	75 0c		 jne	 SHORT $LN26@PyUnicode_@100
  00046	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]

; 3519 : }

  0004b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0004f	5e		 pop	 rsi
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
$LN26@PyUnicode_@100:

; 3429 :         return NULL;
; 3430 : 
; 3431 :     wlen2 = wcslen(wstr);

  00052	48 83 c9 ff	 or	 rcx, -1
  00056	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0005b	33 c0		 xor	 eax, eax
  0005d	48 8b fb	 mov	 rdi, rbx
  00060	66 f2 af	 repne scasw
  00063	48 f7 d1	 not	 rcx
  00066	48 ff c9	 dec	 rcx

; 3432 :     if (wlen2 != wlen) {

  00069	48 3b 4c 24 40	 cmp	 rcx, QWORD PTR wlen$[rsp]
  0006e	74 20		 je	 SHORT $LN25@PyUnicode_@100

; 3433 :         PyMem_Free(wstr);

  00070	48 8b cb	 mov	 rcx, rbx
  00073	e8 00 00 00 00	 call	 PyMem_Free

; 3434 :         PyErr_SetString(PyExc_TypeError, "embedded null character");

  00078	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GLGICKAD@embedded?5null?5character?$AA@
  00086	e8 00 00 00 00	 call	 PyErr_SetString

; 3435 :         return NULL;

  0008b	e9 c5 01 00 00	 jmp	 $LN2@PyUnicode_@100
$LN25@PyUnicode_@100:

; 3436 :     }
; 3437 : 
; 3438 :     if (surrogateescape) {

  00090	39 84 24 80 00
	00 00		 cmp	 DWORD PTR surrogateescape$[rsp], eax
  00097	74 68		 je	 SHORT $LN24@PyUnicode_@100

; 3439 :         /* locale encoding with surrogateescape */
; 3440 :         char *str;
; 3441 : 
; 3442 :         str = _Py_wchar2char(wstr, &error_pos);

  00099	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR error_pos$[rsp]
  000a1	48 8b cb	 mov	 rcx, rbx
  000a4	e8 00 00 00 00	 call	 _Py_wchar2char
  000a9	48 8b f8	 mov	 rdi, rax

; 3443 :         if (str == NULL) {

  000ac	48 85 c0	 test	 rax, rax
  000af	75 21		 jne	 SHORT $LN21@PyUnicode_@100

; 3444 :             if (error_pos == (size_t)-1) {

  000b1	48 83 bc 24 88
	00 00 00 ff	 cmp	 QWORD PTR error_pos$[rsp], -1
  000ba	0f 85 ae 00 00
	00		 jne	 $encode_error$128416

; 3445 :                 PyErr_NoMemory();

  000c0	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN34@PyUnicode_@100:

; 3446 :                 PyMem_Free(wstr);

  000c5	48 8b cb	 mov	 rcx, rbx
  000c8	e8 00 00 00 00	 call	 PyMem_Free

; 3447 :                 return NULL;

  000cd	e9 83 01 00 00	 jmp	 $LN2@PyUnicode_@100
$LN21@PyUnicode_@100:

; 3448 :             }
; 3449 :             else {
; 3450 :                 goto encode_error;
; 3451 :             }
; 3452 :         }
; 3453 :         PyMem_Free(wstr);

  000d2	48 8b cb	 mov	 rcx, rbx
  000d5	e8 00 00 00 00	 call	 PyMem_Free

; 3454 : 
; 3455 :         bytes = PyBytes_FromString(str);

  000da	48 8b cf	 mov	 rcx, rdi
  000dd	e8 00 00 00 00	 call	 PyBytes_FromString

; 3456 :         PyMem_Free(str);

  000e2	48 8b cf	 mov	 rcx, rdi
  000e5	48 8b f0	 mov	 rsi, rax

; 3476 :             goto encode_error;
; 3477 :         }
; 3478 :         PyMem_Free(wstr);

  000e8	e8 00 00 00 00	 call	 PyMem_Free
  000ed	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  000f2	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]

; 3479 :     }
; 3480 :     return bytes;

  000f7	48 8b c6	 mov	 rax, rsi

; 3519 : }

  000fa	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000fe	5e		 pop	 rsi
  000ff	5d		 pop	 rbp
  00100	c3		 ret	 0
$LN24@PyUnicode_@100:

; 3457 :     }
; 3458 :     else {
; 3459 :         size_t len, len2;
; 3460 : 
; 3461 :         len = wcstombs(NULL, wstr, 0);

  00101	45 33 c0	 xor	 r8d, r8d
  00104	48 8b d3	 mov	 rdx, rbx
  00107	33 c9		 xor	 ecx, ecx
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstombs
  0010f	48 8b f8	 mov	 rdi, rax

; 3462 :         if (len == (size_t)-1) {

  00112	48 83 f8 ff	 cmp	 rax, -1

; 3463 :             error_pos = (size_t)-1;
; 3464 :             goto encode_error;

  00116	74 4a		 je	 SHORT $LN16@PyUnicode_@100

; 3465 :         }
; 3466 : 
; 3467 :         bytes = PyBytes_FromStringAndSize(NULL, len);

  00118	48 8b d0	 mov	 rdx, rax
  0011b	33 c9		 xor	 ecx, ecx
  0011d	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00122	48 8b f0	 mov	 rsi, rax

; 3468 :         if (bytes == NULL) {

  00125	48 85 c0	 test	 rax, rax

; 3469 :             PyMem_Free(wstr);
; 3470 :             return NULL;

  00128	74 9b		 je	 SHORT $LN34@PyUnicode_@100

; 3471 :         }
; 3472 : 
; 3473 :         len2 = wcstombs(PyBytes_AS_STRING(bytes), wstr, len+1);

  0012a	4c 8d 47 01	 lea	 r8, QWORD PTR [rdi+1]
  0012e	48 8d 48 78	 lea	 rcx, QWORD PTR [rax+120]
  00132	48 8b d3	 mov	 rdx, rbx
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstombs

; 3474 :         if (len2 == (size_t)-1 || len2 > len) {

  0013b	48 83 f8 ff	 cmp	 rax, -1
  0013f	74 21		 je	 SHORT $LN16@PyUnicode_@100
  00141	48 3b c7	 cmp	 rax, rdi
  00144	77 1c		 ja	 SHORT $LN16@PyUnicode_@100

; 3476 :             goto encode_error;
; 3477 :         }
; 3478 :         PyMem_Free(wstr);

  00146	48 8b cb	 mov	 rcx, rbx
  00149	e8 00 00 00 00	 call	 PyMem_Free
  0014e	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00153	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]

; 3479 :     }
; 3480 :     return bytes;

  00158	48 8b c6	 mov	 rax, rsi

; 3519 : }

  0015b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0015f	5e		 pop	 rsi
  00160	5d		 pop	 rbp
  00161	c3		 ret	 0
$LN16@PyUnicode_@100:

; 3475 :             error_pos = (size_t)-1;

  00162	48 c7 84 24 88
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR error_pos$[rsp], -1
$encode_error$128416:

; 3481 : 
; 3482 : encode_error:
; 3483 :     errmsg = strerror(errno);

  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00174	8b 08		 mov	 ecx, DWORD PTR [rax]
  00176	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror

; 3484 :     assert(errmsg != NULL);
; 3485 : 
; 3486 :     if (error_pos == (size_t)-1)

  0017c	48 83 bc 24 88
	00 00 00 ff	 cmp	 QWORD PTR error_pos$[rsp], -1
  00185	48 8b f8	 mov	 rdi, rax
  00188	75 10		 jne	 SHORT $LN15@PyUnicode_@100

; 3487 :         error_pos = wcstombs_errorpos(wstr);

  0018a	48 8b cb	 mov	 rcx, rbx
  0018d	e8 00 00 00 00	 call	 wcstombs_errorpos
  00192	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR error_pos$[rsp], rax
$LN15@PyUnicode_@100:

; 3488 : 
; 3489 :     PyMem_Free(wstr);

  0019a	48 8b cb	 mov	 rcx, rbx
  0019d	e8 00 00 00 00	 call	 PyMem_Free

; 3490 :     Py_XDECREF(bytes);

  001a2	48 85 f6	 test	 rsi, rsi
  001a5	74 08		 je	 SHORT $LN13@PyUnicode_@100
  001a7	48 8b ce	 mov	 rcx, rsi
  001aa	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@PyUnicode_@100:

; 3491 : 
; 3492 :     if (errmsg != NULL) {

  001af	48 85 ff	 test	 rdi, rdi
  001b2	74 35		 je	 SHORT $LN30@PyUnicode_@100

; 3493 :         size_t errlen;
; 3494 :         wstr = _Py_char2wchar(errmsg, &errlen);

  001b4	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR errlen$128444[rsp]
  001bc	48 8b cf	 mov	 rcx, rdi
  001bf	e8 00 00 00 00	 call	 _Py_char2wchar
  001c4	48 8b d8	 mov	 rbx, rax

; 3495 :         if (wstr != NULL) {

  001c7	48 85 c0	 test	 rax, rax
  001ca	74 1d		 je	 SHORT $LN30@PyUnicode_@100

; 3496 :             reason = PyUnicode_FromWideChar(wstr, errlen);

  001cc	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR errlen$128444[rsp]
  001d4	48 8b c8	 mov	 rcx, rax
  001d7	e8 00 00 00 00	 call	 PyUnicode_FromWideChar

; 3497 :             PyMem_Free(wstr);

  001dc	48 8b cb	 mov	 rcx, rbx
  001df	48 8b f8	 mov	 rdi, rax
  001e2	e8 00 00 00 00	 call	 PyMem_Free

; 3498 :         } else

  001e7	eb 0f		 jmp	 SHORT $LN7@PyUnicode_@100
$LN30@PyUnicode_@100:

; 3499 :             errmsg = NULL;
; 3500 :     }
; 3501 :     if (errmsg == NULL)
; 3502 :         reason = PyUnicode_FromString(
; 3503 :             "wcstombs() encountered an unencodable "
; 3504 :             "wide character");

  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DF@NNEJMCMG@wcstombs?$CI?$CJ?5encountered?5an?5unenco@
  001f0	e8 00 00 00 00	 call	 PyUnicode_FromString
  001f5	48 8b f8	 mov	 rdi, rax
$LN7@PyUnicode_@100:

; 3505 :     if (reason == NULL)

  001f8	48 85 ff	 test	 rdi, rdi

; 3506 :         return NULL;

  001fb	74 58		 je	 SHORT $LN2@PyUnicode_@100

; 3507 : 
; 3508 :     exc = PyObject_CallFunction(PyExc_UnicodeEncodeError, "sOnnO",
; 3509 :                                 "locale", unicode,
; 3510 :                                 (Py_ssize_t)error_pos,
; 3511 :                                 (Py_ssize_t)(error_pos+1),
; 3512 :                                 reason);

  001fd	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR error_pos$[rsp]
  00205	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0020a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06NDGIILMC@locale?$AA@
  00211	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  00215	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05PHHJNLHL@sOnnO?$AA@
  0021c	4c 8b cd	 mov	 r9, rbp
  0021f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00224	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00229	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnicodeEncodeError
  00230	e8 00 00 00 00	 call	 _PyObject_CallFunction_SizeT

; 3513 :     Py_DECREF(reason);

  00235	48 8b cf	 mov	 rcx, rdi
  00238	48 8b d8	 mov	 rbx, rax
  0023b	e8 00 00 00 00	 call	 _Py_DecRef

; 3514 :     if (exc != NULL) {

  00240	48 85 db	 test	 rbx, rbx
  00243	74 10		 je	 SHORT $LN2@PyUnicode_@100

; 3515 :         PyCodec_StrictErrors(exc);

  00245	48 8b cb	 mov	 rcx, rbx
  00248	e8 00 00 00 00	 call	 PyCodec_StrictErrors

; 3516 :         Py_XDECREF(exc);

  0024d	48 8b cb	 mov	 rcx, rbx
  00250	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@PyUnicode_@100:

; 3517 :     }
; 3518 :     return NULL;

  00255	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  0025a	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0025f	33 c0		 xor	 eax, eax

; 3519 : }

  00261	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00265	5e		 pop	 rsi
  00266	5d		 pop	 rbp
  00267	c3		 ret	 0
PyUnicode_EncodeLocale ENDP
_TEXT	ENDS
PUBLIC	??_C@_06PLAONGDK@sy?$CDnnO?$AA@			; `string'
PUBLIC	??_C@_0DF@ONCEBKAN@mbstowcs?$CI?$CJ?5encountered?5an?5invali@ ; `string'
PUBLIC	PyUnicode_DecodeLocaleAndSize
EXTRN	PyExc_UnicodeDecodeError:QWORD
EXTRN	__imp_mbstowcs:PROC
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	PyExc_OSError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_DecodeLocaleAndSize DD imagerel $LN35
	DD	imagerel $LN35+52
	DD	imagerel $unwind$PyUnicode_DecodeLocaleAndSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyUnicode_DecodeLocaleAndSize DD imagerel $LN35+52
	DD	imagerel $LN35+159
	DD	imagerel $chain$0$PyUnicode_DecodeLocaleAndSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyUnicode_DecodeLocaleAndSize DD imagerel $LN35+159
	DD	imagerel $LN35+191
	DD	imagerel $chain$2$PyUnicode_DecodeLocaleAndSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyUnicode_DecodeLocaleAndSize DD imagerel $LN35+191
	DD	imagerel $LN35+236
	DD	imagerel $chain$4$PyUnicode_DecodeLocaleAndSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$PyUnicode_DecodeLocaleAndSize DD imagerel $LN35+236
	DD	imagerel $LN35+337
	DD	imagerel $chain$6$PyUnicode_DecodeLocaleAndSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$PyUnicode_DecodeLocaleAndSize DD imagerel $LN35+337
	DD	imagerel $LN35+382
	DD	imagerel $chain$8$PyUnicode_DecodeLocaleAndSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$PyUnicode_DecodeLocaleAndSize DD imagerel $LN35+382
	DD	imagerel $LN35+478
	DD	imagerel $chain$10$PyUnicode_DecodeLocaleAndSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$PyUnicode_DecodeLocaleAndSize DD imagerel $LN35+478
	DD	imagerel $LN35+531
	DD	imagerel $chain$11$PyUnicode_DecodeLocaleAndSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$PyUnicode_DecodeLocaleAndSize DD imagerel $LN35+531
	DD	imagerel $LN35+559
	DD	imagerel $chain$13$PyUnicode_DecodeLocaleAndSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$PyUnicode_DecodeLocaleAndSize DD imagerel $LN35+559
	DD	imagerel $LN35+673
	DD	imagerel $chain$14$PyUnicode_DecodeLocaleAndSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$16$PyUnicode_DecodeLocaleAndSize DD imagerel $LN35+673
	DD	imagerel $LN35+712
	DD	imagerel $chain$16$PyUnicode_DecodeLocaleAndSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$16$PyUnicode_DecodeLocaleAndSize DD 020021H
	DD	04f7400H
	DD	imagerel $LN35
	DD	imagerel $LN35+52
	DD	imagerel $unwind$PyUnicode_DecodeLocaleAndSize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$PyUnicode_DecodeLocaleAndSize DD 040021H
	DD	04ac400H
	DD	04f7400H
	DD	imagerel $LN35
	DD	imagerel $LN35+52
	DD	imagerel $unwind$PyUnicode_DecodeLocaleAndSize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$PyUnicode_DecodeLocaleAndSize DD 060021H
	DD	04ac400H
	DD	04f7400H
	DD	04e6400H
	DD	imagerel $LN35
	DD	imagerel $LN35+52
	DD	imagerel $unwind$PyUnicode_DecodeLocaleAndSize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$PyUnicode_DecodeLocaleAndSize DD 021H
	DD	imagerel $LN35+337
	DD	imagerel $LN35+382
	DD	imagerel $chain$8$PyUnicode_DecodeLocaleAndSize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$PyUnicode_DecodeLocaleAndSize DD 041021H
	DD	04ac410H
	DD	04e6408H
	DD	imagerel $LN35+337
	DD	imagerel $LN35+382
	DD	imagerel $chain$8$PyUnicode_DecodeLocaleAndSize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$PyUnicode_DecodeLocaleAndSize DD 020021H
	DD	04f7400H
	DD	imagerel $LN35
	DD	imagerel $LN35+52
	DD	imagerel $unwind$PyUnicode_DecodeLocaleAndSize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$PyUnicode_DecodeLocaleAndSize DD 020021H
	DD	04f7400H
	DD	imagerel $LN35
	DD	imagerel $LN35+52
	DD	imagerel $unwind$PyUnicode_DecodeLocaleAndSize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyUnicode_DecodeLocaleAndSize DD 020021H
	DD	04f7400H
	DD	imagerel $LN35
	DD	imagerel $LN35+52
	DD	imagerel $unwind$PyUnicode_DecodeLocaleAndSize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyUnicode_DecodeLocaleAndSize DD 020021H
	DD	04f7400H
	DD	imagerel $LN35
	DD	imagerel $LN35+52
	DD	imagerel $unwind$PyUnicode_DecodeLocaleAndSize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyUnicode_DecodeLocaleAndSize DD 020821H
	DD	04f7408H
	DD	imagerel $LN35
	DD	imagerel $LN35+52
	DD	imagerel $unwind$PyUnicode_DecodeLocaleAndSize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_DecodeLocaleAndSize DD 040a01H
	DD	04b010aH
	DD	030025003H
xdata	ENDS
;	COMDAT ??_C@_06PLAONGDK@sy?$CDnnO?$AA@
CONST	SEGMENT
??_C@_06PLAONGDK@sy?$CDnnO?$AA@ DB 'sy#nnO', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@ONCEBKAN@mbstowcs?$CI?$CJ?5encountered?5an?5invali@
CONST	SEGMENT
??_C@_0DF@ONCEBKAN@mbstowcs?$CI?$CJ?5encountered?5an?5invali@ DB 'mbstowc'
	DB	's() encountered an invalid multibyte sequence', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_DecodeLocaleAndSize
_TEXT	SEGMENT
wlen$ = 64
smallbuf$ = 80
str$ = 624
len$ = 632
errors$ = 640
errlen$128600 = 648
surrogateescape$ = 648
PyUnicode_DecodeLocaleAndSize PROC			; COMDAT

; 3685 : {

$LN35:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	48 81 ec 58 02
	00 00		 sub	 rsp, 600		; 00000258H
  0000a	48 8b ea	 mov	 rbp, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 3686 :     wchar_t smallbuf[256];
; 3687 :     size_t smallbuf_len = Py_ARRAY_LENGTH(smallbuf);
; 3688 :     wchar_t *wstr;
; 3689 :     size_t wlen, wlen2;
; 3690 :     PyObject *unicode;
; 3691 :     int surrogateescape;
; 3692 :     size_t error_pos;
; 3693 :     char *errmsg;
; 3694 :     PyObject *reason, *exc;
; 3695 : 
; 3696 :     if (locale_error_handler(errors, &surrogateescape) < 0)

  00010	48 8d 94 24 88
	02 00 00	 lea	 rdx, QWORD PTR surrogateescape$[rsp]
  00018	49 8b c8	 mov	 rcx, r8
  0001b	e8 00 00 00 00	 call	 locale_error_handler
  00020	85 c0		 test	 eax, eax
  00022	79 0c		 jns	 SHORT $LN26@PyUnicode_@101

; 3697 :         return NULL;

  00024	33 c0		 xor	 eax, eax

; 3785 : }

  00026	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  0002d	5d		 pop	 rbp
  0002e	5b		 pop	 rbx
  0002f	c3		 ret	 0
$LN26@PyUnicode_@101:

; 3698 : 
; 3699 :     if (str[len] != '\0' || len != strlen(str)) {

  00030	80 3c 2b 00	 cmp	 BYTE PTR [rbx+rbp], 0
  00034	48 89 bc 24 78
	02 00 00	 mov	 QWORD PTR [rsp+632], rdi
  0003c	0f 85 5f 02 00
	00		 jne	 $LN24@PyUnicode_@101
  00042	48 83 c9 ff	 or	 rcx, -1
  00046	33 c0		 xor	 eax, eax
  00048	48 8b fb	 mov	 rdi, rbx
  0004b	f2 ae		 repne scasb
  0004d	48 f7 d1	 not	 rcx
  00050	48 ff c9	 dec	 rcx
  00053	48 3b e9	 cmp	 rbp, rcx
  00056	0f 85 45 02 00
	00		 jne	 $LN24@PyUnicode_@101

; 3702 :     }
; 3703 : 
; 3704 :     if (surrogateescape)

  0005c	39 84 24 88 02
	00 00		 cmp	 DWORD PTR surrogateescape$[rsp], eax
  00063	0f 84 83 00 00
	00		 je	 $LN23@PyUnicode_@101

; 3705 :     {
; 3706 :         wstr = _Py_char2wchar(str, &wlen);

  00069	48 8d 54 24 40	 lea	 rdx, QWORD PTR wlen$[rsp]
  0006e	48 8b cb	 mov	 rcx, rbx
  00071	e8 00 00 00 00	 call	 _Py_char2wchar
  00076	48 8b f8	 mov	 rdi, rax

; 3707 :         if (wstr == NULL) {

  00079	48 85 c0	 test	 rax, rax
  0007c	75 41		 jne	 SHORT $LN22@PyUnicode_@101

; 3708 :             if (wlen == (size_t)-1)

  0007e	48 83 7c 24 40
	ff		 cmp	 QWORD PTR wlen$[rsp], -1
  00084	75 19		 jne	 SHORT $LN21@PyUnicode_@101

; 3709 :                 PyErr_NoMemory();

  00086	e8 00 00 00 00	 call	 PyErr_NoMemory
  0008b	48 8b bc 24 78
	02 00 00	 mov	 rdi, QWORD PTR [rsp+632]

; 3712 :             return NULL;

  00093	33 c0		 xor	 eax, eax

; 3785 : }

  00095	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  0009c	5d		 pop	 rbp
  0009d	5b		 pop	 rbx
  0009e	c3		 ret	 0
$LN21@PyUnicode_@101:

; 3710 :             else
; 3711 :                 PyErr_SetFromErrno(PyExc_OSError);

  0009f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  000a6	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  000ab	48 8b bc 24 78
	02 00 00	 mov	 rdi, QWORD PTR [rsp+632]

; 3712 :             return NULL;

  000b3	33 c0		 xor	 eax, eax

; 3785 : }

  000b5	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  000bc	5d		 pop	 rbp
  000bd	5b		 pop	 rbx
  000be	c3		 ret	 0
$LN22@PyUnicode_@101:

; 3713 :         }
; 3714 : 
; 3715 :         unicode = PyUnicode_FromWideChar(wstr, wlen);

  000bf	48 8b 54 24 40	 mov	 rdx, QWORD PTR wlen$[rsp]
  000c4	48 8b c8	 mov	 rcx, rax
  000c7	e8 00 00 00 00	 call	 PyUnicode_FromWideChar

; 3750 :             PyMem_Free(wstr);

  000cc	48 8b cf	 mov	 rcx, rdi
  000cf	48 8b d8	 mov	 rbx, rax
  000d2	e8 00 00 00 00	 call	 PyMem_Free
  000d7	48 8b bc 24 78
	02 00 00	 mov	 rdi, QWORD PTR [rsp+632]

; 3751 :     }
; 3752 :     return unicode;

  000df	48 8b c3	 mov	 rax, rbx

; 3785 : }

  000e2	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  000e9	5d		 pop	 rbp
  000ea	5b		 pop	 rbx
  000eb	c3		 ret	 0
$LN23@PyUnicode_@101:

; 3716 :         PyMem_Free(wstr);
; 3717 :     }
; 3718 :     else {
; 3719 : #ifndef HAVE_BROKEN_MBSTOWCS
; 3720 :         wlen = mbstowcs(NULL, str, 0);

  000ec	45 33 c0	 xor	 r8d, r8d
  000ef	48 8b d3	 mov	 rdx, rbx
  000f2	33 c9		 xor	 ecx, ecx
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mbstowcs
  000fa	48 89 44 24 40	 mov	 QWORD PTR wlen$[rsp], rax

; 3721 : #else
; 3722 :         wlen = len;
; 3723 : #endif
; 3724 :         if (wlen == (size_t)-1)

  000ff	48 83 f8 ff	 cmp	 rax, -1
  00103	74 79		 je	 SHORT $decode_error$128584

; 3725 :             goto decode_error;
; 3726 :         if (wlen+1 <= smallbuf_len) {

  00105	48 8d 48 01	 lea	 rcx, QWORD PTR [rax+1]
  00109	48 81 f9 00 01
	00 00		 cmp	 rcx, 256		; 00000100H
  00110	77 07		 ja	 SHORT $LN17@PyUnicode_@101

; 3727 :             wstr = smallbuf;

  00112	48 8d 7c 24 50	 lea	 rdi, QWORD PTR smallbuf$[rsp]

; 3728 :         }
; 3729 :         else {

  00117	eb 3d		 jmp	 SHORT $LN14@PyUnicode_@101
$LN17@PyUnicode_@101:

; 3730 :             if (wlen > PY_SSIZE_T_MAX / sizeof(wchar_t) - 1)

  00119	48 b9 fe ff ff
	ff ff ff ff 3f	 mov	 rcx, 4611686018427387902 ; 3ffffffffffffffeH
  00123	48 3b c1	 cmp	 rax, rcx

; 3731 :                 return PyErr_NoMemory();

  00126	77 12		 ja	 SHORT $LN34@PyUnicode_@101

; 3732 : 
; 3733 :             wstr = PyMem_Malloc((wlen+1) * sizeof(wchar_t));

  00128	48 8d 4c 00 02	 lea	 rcx, QWORD PTR [rax+rax+2]
  0012d	e8 00 00 00 00	 call	 PyMem_Malloc
  00132	48 8b f8	 mov	 rdi, rax

; 3734 :             if (!wstr)

  00135	48 85 c0	 test	 rax, rax
  00138	75 17		 jne	 SHORT $LN30@PyUnicode_@101
$LN34@PyUnicode_@101:

; 3735 :                 return PyErr_NoMemory();

  0013a	e8 00 00 00 00	 call	 PyErr_NoMemory
  0013f	48 8b bc 24 78
	02 00 00	 mov	 rdi, QWORD PTR [rsp+632]

; 3785 : }

  00147	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  0014e	5d		 pop	 rbp
  0014f	5b		 pop	 rbx
  00150	c3		 ret	 0
$LN30@PyUnicode_@101:

; 3735 :                 return PyErr_NoMemory();

  00151	48 8b 44 24 40	 mov	 rax, QWORD PTR wlen$[rsp]
$LN14@PyUnicode_@101:

; 3736 :         }
; 3737 : 
; 3738 :         /* This shouldn't fail now */
; 3739 :         wlen2 = mbstowcs(wstr, str, wlen+1);

  00156	4c 8d 40 01	 lea	 r8, QWORD PTR [rax+1]
  0015a	48 8b d3	 mov	 rdx, rbx
  0015d	48 8b cf	 mov	 rcx, rdi
  00160	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mbstowcs

; 3740 :         if (wlen2 == (size_t)-1) {

  00166	48 83 f8 ff	 cmp	 rax, -1
  0016a	75 72		 jne	 SHORT $LN13@PyUnicode_@101

; 3741 :             if (wstr != smallbuf)

  0016c	48 8d 44 24 50	 lea	 rax, QWORD PTR smallbuf$[rsp]
  00171	48 3b f8	 cmp	 rdi, rax
  00174	74 08		 je	 SHORT $decode_error$128584

; 3742 :                 PyMem_Free(wstr);

  00176	48 8b cf	 mov	 rcx, rdi
  00179	e8 00 00 00 00	 call	 PyMem_Free
$decode_error$128584:

; 3753 : 
; 3754 : decode_error:
; 3755 :     errmsg = strerror(errno);

  0017e	48 89 b4 24 70
	02 00 00	 mov	 QWORD PTR [rsp+624], rsi
  00186	4c 89 a4 24 50
	02 00 00	 mov	 QWORD PTR [rsp+592], r12
  0018e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00194	8b 08		 mov	 ecx, DWORD PTR [rax]
  00196	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  0019c	48 8b c8	 mov	 rcx, rax

; 3756 :     assert(errmsg != NULL);
; 3757 : 
; 3758 :     error_pos = mbstowcs_errorpos(str, len);

  0019f	e8 00 00 00 00	 call	 mbstowcs_errorpos
  001a4	4c 8b e0	 mov	 r12, rax

; 3759 :     if (errmsg != NULL) {

  001a7	48 85 c9	 test	 rcx, rcx
  001aa	74 67		 je	 SHORT $LN29@PyUnicode_@101

; 3760 :         size_t errlen;
; 3761 :         wstr = _Py_char2wchar(errmsg, &errlen);

  001ac	48 8d 94 24 88
	02 00 00	 lea	 rdx, QWORD PTR errlen$128600[rsp]
  001b4	e8 00 00 00 00	 call	 _Py_char2wchar
  001b9	48 8b f0	 mov	 rsi, rax

; 3762 :         if (wstr != NULL) {

  001bc	48 85 c0	 test	 rax, rax
  001bf	74 52		 je	 SHORT $LN29@PyUnicode_@101

; 3763 :             reason = PyUnicode_FromWideChar(wstr, errlen);

  001c1	48 8b 94 24 88
	02 00 00	 mov	 rdx, QWORD PTR errlen$128600[rsp]
  001c9	48 8b c8	 mov	 rcx, rax
  001cc	e8 00 00 00 00	 call	 PyUnicode_FromWideChar

; 3764 :             PyMem_Free(wstr);

  001d1	48 8b ce	 mov	 rcx, rsi
  001d4	48 8b f8	 mov	 rdi, rax
  001d7	e8 00 00 00 00	 call	 PyMem_Free

; 3765 :         } else

  001dc	eb 44		 jmp	 SHORT $LN7@PyUnicode_@101
$LN13@PyUnicode_@101:

; 3743 :             goto decode_error;
; 3744 :         }
; 3745 : #ifdef HAVE_BROKEN_MBSTOWCS
; 3746 :         assert(wlen2 == wlen);
; 3747 : #endif
; 3748 :         unicode = PyUnicode_FromWideChar(wstr, wlen2);

  001de	48 8b d0	 mov	 rdx, rax
  001e1	48 8b cf	 mov	 rcx, rdi
  001e4	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  001e9	48 8b d8	 mov	 rbx, rax

; 3749 :         if (wstr != smallbuf)

  001ec	48 8d 44 24 50	 lea	 rax, QWORD PTR smallbuf$[rsp]
  001f1	48 3b f8	 cmp	 rdi, rax
  001f4	74 08		 je	 SHORT $LN11@PyUnicode_@101

; 3750 :             PyMem_Free(wstr);

  001f6	48 8b cf	 mov	 rcx, rdi
  001f9	e8 00 00 00 00	 call	 PyMem_Free
$LN11@PyUnicode_@101:

; 3751 :     }
; 3752 :     return unicode;

  001fe	48 8b c3	 mov	 rax, rbx
  00201	48 8b bc 24 78
	02 00 00	 mov	 rdi, QWORD PTR [rsp+632]

; 3785 : }

  00209	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  00210	5d		 pop	 rbp
  00211	5b		 pop	 rbx
  00212	c3		 ret	 0
$LN29@PyUnicode_@101:

; 3766 :             errmsg = NULL;
; 3767 :     }
; 3768 :     if (errmsg == NULL)
; 3769 :         reason = PyUnicode_FromString(
; 3770 :             "mbstowcs() encountered an invalid multibyte sequence");

  00213	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DF@ONCEBKAN@mbstowcs?$CI?$CJ?5encountered?5an?5invali@
  0021a	e8 00 00 00 00	 call	 PyUnicode_FromString
  0021f	48 8b f8	 mov	 rdi, rax
$LN7@PyUnicode_@101:

; 3771 :     if (reason == NULL)

  00222	48 8b b4 24 70
	02 00 00	 mov	 rsi, QWORD PTR [rsp+624]
  0022a	48 85 ff	 test	 rdi, rdi

; 3772 :         return NULL;

  0022d	74 56		 je	 SHORT $LN2@PyUnicode_@101

; 3773 : 
; 3774 :     exc = PyObject_CallFunction(PyExc_UnicodeDecodeError, "sy#nnO",
; 3775 :                                 "locale", str, len,
; 3776 :                                 (Py_ssize_t)error_pos,
; 3777 :                                 (Py_ssize_t)(error_pos+1),
; 3778 :                                 reason);

  0022f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnicodeDecodeError
  00236	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0023b	49 8d 44 24 01	 lea	 rax, QWORD PTR [r12+1]
  00240	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00245	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06NDGIILMC@locale?$AA@
  0024c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06PLAONGDK@sy?$CDnnO?$AA@
  00253	4c 8b cb	 mov	 r9, rbx
  00256	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  0025b	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00260	e8 00 00 00 00	 call	 _PyObject_CallFunction_SizeT

; 3779 :     Py_DECREF(reason);

  00265	48 8b cf	 mov	 rcx, rdi
  00268	48 8b d8	 mov	 rbx, rax
  0026b	e8 00 00 00 00	 call	 _Py_DecRef

; 3780 :     if (exc != NULL) {

  00270	48 85 db	 test	 rbx, rbx
  00273	74 10		 je	 SHORT $LN2@PyUnicode_@101

; 3781 :         PyCodec_StrictErrors(exc);

  00275	48 8b cb	 mov	 rcx, rbx
  00278	e8 00 00 00 00	 call	 PyCodec_StrictErrors

; 3782 :         Py_XDECREF(exc);

  0027d	48 8b cb	 mov	 rcx, rbx
  00280	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@PyUnicode_@101:

; 3783 :     }
; 3784 :     return NULL;

  00285	4c 8b a4 24 50
	02 00 00	 mov	 r12, QWORD PTR [rsp+592]
  0028d	48 8b bc 24 78
	02 00 00	 mov	 rdi, QWORD PTR [rsp+632]
  00295	33 c0		 xor	 eax, eax

; 3785 : }

  00297	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  0029e	5d		 pop	 rbp
  0029f	5b		 pop	 rbx
  002a0	c3		 ret	 0
$LN24@PyUnicode_@101:

; 3700 :         PyErr_SetString(PyExc_TypeError, "embedded null character");

  002a1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GLGICKAD@embedded?5null?5character?$AA@
  002af	e8 00 00 00 00	 call	 PyErr_SetString
  002b4	48 8b bc 24 78
	02 00 00	 mov	 rdi, QWORD PTR [rsp+632]

; 3701 :         return NULL;

  002bc	33 c0		 xor	 eax, eax

; 3785 : }

  002be	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  002c5	5d		 pop	 rbp
  002c6	5b		 pop	 rbx
  002c7	c3		 ret	 0
PyUnicode_DecodeLocaleAndSize ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_DecodeLocale
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_DecodeLocale DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$PyUnicode_DecodeLocale
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_DecodeLocale DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_DecodeLocale
_TEXT	SEGMENT
str$ = 48
errors$ = 56
PyUnicode_DecodeLocale PROC				; COMDAT

; 3789 : {

$LN3:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4c 8b c9	 mov	 r9, rcx

; 3790 :     Py_ssize_t size = (Py_ssize_t)strlen(str);

  00009	48 83 c9 ff	 or	 rcx, -1
  0000d	33 c0		 xor	 eax, eax
  0000f	49 8b f9	 mov	 rdi, r9

; 3791 :     return PyUnicode_DecodeLocaleAndSize(str, size, errors);

  00012	4c 8b c2	 mov	 r8, rdx
  00015	f2 ae		 repne scasb
  00017	48 f7 d1	 not	 rcx
  0001a	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  0001e	49 8b c9	 mov	 rcx, r9

; 3792 : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5f		 pop	 rdi
  00026	e9 00 00 00 00	 jmp	 PyUnicode_DecodeLocaleAndSize
PyUnicode_DecodeLocale ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_DecodeFSDefaultAndSize
; Function compile flags: /Ogtpy
;	COMDAT PyUnicode_DecodeFSDefaultAndSize
_TEXT	SEGMENT
s$ = 8
size$ = 16
PyUnicode_DecodeFSDefaultAndSize PROC			; COMDAT

; 3804 : #ifdef HAVE_MBCS
; 3805 :     return PyUnicode_DecodeMBCS(s, size, NULL);

  00000	45 33 c0	 xor	 r8d, r8d

; 3806 : #elif defined(__APPLE__)
; 3807 :     return PyUnicode_DecodeUTF8Stateful(s, size, "surrogateescape", NULL);
; 3808 : #else
; 3809 :     PyInterpreterState *interp = PyThreadState_GET()->interp;
; 3810 :     /* Bootstrap check: if the filesystem codec is implemented in Python, we
; 3811 :        cannot use it to encode and decode filenames before it is loaded. Load
; 3812 :        the Python codec requires to encode at least its own filename. Use the C
; 3813 :        version of the locale codec until the codec registry is initialized and
; 3814 :        the Python codec is loaded.
; 3815 : 
; 3816 :        Py_FileSystemDefaultEncoding is shared between all interpreters, we
; 3817 :        cannot only rely on it: check also interp->fscodec_initialized for
; 3818 :        subinterpreters. */
; 3819 :     if (Py_FileSystemDefaultEncoding && interp->fscodec_initialized) {
; 3820 :         return PyUnicode_Decode(s, size,
; 3821 :                                 Py_FileSystemDefaultEncoding,
; 3822 :                                 "surrogateescape");
; 3823 :     }
; 3824 :     else {
; 3825 :         return PyUnicode_DecodeLocaleAndSize(s, size, "surrogateescape");
; 3826 :     }
; 3827 : #endif
; 3828 : }

  00003	e9 00 00 00 00	 jmp	 PyUnicode_DecodeMBCS
PyUnicode_DecodeFSDefaultAndSize ENDP
_TEXT	ENDS
PUBLIC	??_C@_01LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	_PyUnicode_HasNULChars
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_HasNULChars DD imagerel $LN5
	DD	imagerel $LN5+73
	DD	imagerel $unwind$_PyUnicode_HasNULChars
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_HasNULChars DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_01LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_01LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyUnicode_HasNULChars
_TEXT	SEGMENT
s$ = 48
_PyUnicode_HasNULChars PROC				; COMDAT

; 3833 : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3834 :     static PyObject *nul = NULL;
; 3835 : 
; 3836 :     if (nul == NULL)

  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?nul@?1??_PyUnicode_HasNULChars@@9@9
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 85 c0	 test	 rax, rax
  00013	75 24		 jne	 SHORT $LN1@PyUnicode_@102

; 3837 :         nul = PyUnicode_FromStringAndSize("\0", 1);

  00015	8d 50 01	 lea	 edx, QWORD PTR [rax+1]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01LOCGONAA@?$AA?$AA@
  0001f	e8 00 00 00 00	 call	 PyUnicode_FromStringAndSize
  00024	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?nul@?1??_PyUnicode_HasNULChars@@9@9, rax

; 3838 :     if (nul == NULL)

  0002b	48 85 c0	 test	 rax, rax
  0002e	75 09		 jne	 SHORT $LN1@PyUnicode_@102

; 3839 :         return -1;

  00030	83 c8 ff	 or	 eax, -1

; 3841 : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5b		 pop	 rbx
  00038	c3		 ret	 0
$LN1@PyUnicode_@102:

; 3840 :     return PyUnicode_Contains(s, nul);

  00039	48 8b d0	 mov	 rdx, rax
  0003c	48 8b cb	 mov	 rcx, rbx

; 3841 : }

  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5b		 pop	 rbx
  00044	e9 00 00 00 00	 jmp	 PyUnicode_Contains
_PyUnicode_HasNULChars ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@JDIDDKBJ@embedded?5NUL?5character?$AA@ ; `string'
PUBLIC	??_C@_0CB@EEHGMMMK@decoder?5failed?5to?5return?5unicode@ ; `string'
PUBLIC	PyUnicode_FSDecoder
EXTRN	PyBytes_FromObject:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_FSDecoder DD imagerel $LN23
	DD	imagerel $LN23+47
	DD	imagerel $unwind$PyUnicode_FSDecoder
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyUnicode_FSDecoder DD imagerel $LN23+47
	DD	imagerel $LN23+252
	DD	imagerel $chain$0$PyUnicode_FSDecoder
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyUnicode_FSDecoder DD imagerel $LN23+252
	DD	imagerel $LN23+344
	DD	imagerel $chain$2$PyUnicode_FSDecoder
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyUnicode_FSDecoder DD imagerel $LN23+344
	DD	imagerel $LN23+368
	DD	imagerel $chain$4$PyUnicode_FSDecoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyUnicode_FSDecoder DD 020021H
	DD	087400H
	DD	imagerel $LN23
	DD	imagerel $LN23+47
	DD	imagerel $unwind$PyUnicode_FSDecoder
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyUnicode_FSDecoder DD 020021H
	DD	087400H
	DD	imagerel $LN23
	DD	imagerel $LN23+47
	DD	imagerel $unwind$PyUnicode_FSDecoder
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyUnicode_FSDecoder DD 020521H
	DD	087405H
	DD	imagerel $LN23
	DD	imagerel $LN23+47
	DD	imagerel $unwind$PyUnicode_FSDecoder
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_FSDecoder DD 040a01H
	DD	09340aH
	DD	06006520aH
xdata	ENDS
;	COMDAT ??_C@_0BH@JDIDDKBJ@embedded?5NUL?5character?$AA@
CONST	SEGMENT
??_C@_0BH@JDIDDKBJ@embedded?5NUL?5character?$AA@ DB 'embedded NUL charact'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EEHGMMMK@decoder?5failed?5to?5return?5unicode@
CONST	SEGMENT
??_C@_0CB@EEHGMMMK@decoder?5failed?5to?5return?5unicode@ DB 'decoder fail'
	DB	'ed to return unicode', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_FSDecoder
_TEXT	SEGMENT
arg$ = 64
addr$ = 72
PyUnicode_FSDecoder PROC				; COMDAT

; 3886 : {

$LN23:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f2	 mov	 rsi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 3887 :     PyObject *output = NULL;
; 3888 :     if (arg == NULL) {

  00010	48 85 c9	 test	 rcx, rcx
  00013	75 16		 jne	 SHORT $LN9@PyUnicode_@103

; 3889 :         Py_DECREF(*(PyObject**)addr);

  00015	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00018	e8 00 00 00 00	 call	 _Py_DecRef

; 3890 :         return 1;

  0001d	8d 43 01	 lea	 eax, QWORD PTR [rbx+1]

; 3924 :     return Py_CLEANUP_SUPPORTED;
; 3925 : }

  00020	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00025	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00029	5e		 pop	 rsi
  0002a	c3		 ret	 0
$LN9@PyUnicode_@103:

; 3891 :     }
; 3892 :     if (PyUnicode_Check(arg)) {

  0002b	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0002f	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00034	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0003e	74 4d		 je	 SHORT $LN8@PyUnicode_@103

; 3893 :         if (PyUnicode_READY(arg) == -1)

  00040	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00044	75 0e		 jne	 SHORT $LN7@PyUnicode_@103
  00046	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0004b	83 f8 ff	 cmp	 eax, -1

; 3894 :             return 0;

  0004e	0f 84 f2 00 00
	00		 je	 $LN22@PyUnicode_@103
$LN7@PyUnicode_@103:

; 3895 :         output = arg;
; 3896 :         Py_INCREF(output);

  00054	48 8b cb	 mov	 rcx, rbx
  00057	e8 00 00 00 00	 call	 _Py_IncRef
$LN3@PyUnicode_@103:

; 3911 :         }
; 3912 :     }
; 3913 :     if (PyUnicode_READY(output) == -1) {

  0005c	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00060	75 11		 jne	 SHORT $LN2@PyUnicode_@103
  00062	48 8b cb	 mov	 rcx, rbx
  00065	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0006a	83 f8 ff	 cmp	 eax, -1

; 3914 :         Py_DECREF(output);
; 3915 :         return 0;

  0006d	0f 84 cb 00 00
	00		 je	 $LN21@PyUnicode_@103
$LN2@PyUnicode_@103:

; 3916 :     }
; 3917 :     if (findchar(PyUnicode_DATA(output), PyUnicode_KIND(output),
; 3918 :                  PyUnicode_GET_LENGTH(output), 0, 1) >= 0) {

  00073	8b 53 70	 mov	 edx, DWORD PTR [rbx+112]
  00076	f6 c2 20	 test	 dl, 32			; 00000020H
  00079	0f 84 86 00 00
	00		 je	 $LN18@PyUnicode_@103
  0007f	f6 c2 40	 test	 dl, 64			; 00000040H
  00082	74 78		 je	 SHORT $LN16@PyUnicode_@103
  00084	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  0008b	eb 7f		 jmp	 SHORT $LN19@PyUnicode_@103
$LN8@PyUnicode_@103:

; 3897 :     }
; 3898 :     else {
; 3899 :         arg = PyBytes_FromObject(arg);

  0008d	e8 00 00 00 00	 call	 PyBytes_FromObject
  00092	48 8b f8	 mov	 rdi, rax

; 3900 :         if (!arg)

  00095	48 85 c0	 test	 rax, rax

; 3901 :             return 0;

  00098	0f 84 a8 00 00
	00		 je	 $LN22@PyUnicode_@103

; 3902 :         output = PyUnicode_DecodeFSDefaultAndSize(PyBytes_AS_STRING(arg),
; 3903 :                                                   PyBytes_GET_SIZE(arg));

  0009e	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000a2	48 8d 48 78	 lea	 rcx, QWORD PTR [rax+120]
  000a6	e8 00 00 00 00	 call	 PyUnicode_DecodeFSDefaultAndSize

; 3904 :         Py_DECREF(arg);

  000ab	48 8b cf	 mov	 rcx, rdi
  000ae	48 8b d8	 mov	 rbx, rax
  000b1	e8 00 00 00 00	 call	 _Py_DecRef

; 3905 :         if (!output)

  000b6	48 85 db	 test	 rbx, rbx

; 3906 :             return 0;

  000b9	0f 84 87 00 00
	00		 je	 $LN22@PyUnicode_@103

; 3907 :         if (!PyUnicode_Check(output)) {

  000bf	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000c3	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  000cd	75 8d		 jne	 SHORT $LN3@PyUnicode_@103

; 3908 :             Py_DECREF(output);

  000cf	48 8b cb	 mov	 rcx, rbx
  000d2	e8 00 00 00 00	 call	 _Py_DecRef

; 3909 :             PyErr_SetString(PyExc_TypeError, "decoder failed to return unicode");

  000d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@EEHGMMMK@decoder?5failed?5to?5return?5unicode@
  000e5	e8 00 00 00 00	 call	 PyErr_SetString
  000ea	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 3910 :             return 0;

  000ef	33 c0		 xor	 eax, eax

; 3924 :     return Py_CLEANUP_SUPPORTED;
; 3925 : }

  000f1	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000f6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fa	5e		 pop	 rsi
  000fb	c3		 ret	 0
$LN16@PyUnicode_@103:

; 3916 :     }
; 3917 :     if (findchar(PyUnicode_DATA(output), PyUnicode_KIND(output),
; 3918 :                  PyUnicode_GET_LENGTH(output), 0, 1) >= 0) {

  000fc	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  00103	eb 07		 jmp	 SHORT $LN19@PyUnicode_@103
$LN18@PyUnicode_@103:
  00105	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
$LN19@PyUnicode_@103:
  0010c	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  00110	c1 ea 02	 shr	 edx, 2
  00113	45 33 c9	 xor	 r9d, r9d
  00116	83 e2 07	 and	 edx, 7
  00119	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00121	e8 00 00 00 00	 call	 findchar
  00126	48 85 c0	 test	 rax, rax
  00129	78 2d		 js	 SHORT $LN1@PyUnicode_@103

; 3919 :         PyErr_SetString(PyExc_TypeError, "embedded NUL character");

  0012b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@JDIDDKBJ@embedded?5NUL?5character?$AA@
  00139	e8 00 00 00 00	 call	 PyErr_SetString
$LN21@PyUnicode_@103:

; 3920 :         Py_DECREF(output);

  0013e	48 8b cb	 mov	 rcx, rbx
  00141	e8 00 00 00 00	 call	 _Py_DecRef
$LN22@PyUnicode_@103:

; 3921 :         return 0;

  00146	33 c0		 xor	 eax, eax
  00148	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 3924 :     return Py_CLEANUP_SUPPORTED;
; 3925 : }

  0014d	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00152	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00156	5e		 pop	 rsi
  00157	c3		 ret	 0
$LN1@PyUnicode_@103:
  00158	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 3922 :     }
; 3923 :     *(PyObject**)addr = output;

  0015d	48 89 1e	 mov	 QWORD PTR [rsi], rbx

; 3924 :     return Py_CLEANUP_SUPPORTED;
; 3925 : }

  00160	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00165	b8 00 00 02 00	 mov	 eax, 131072		; 00020000H
  0016a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0016e	5e		 pop	 rsi
  0016f	c3		 ret	 0
PyUnicode_FSDecoder ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsUTF8AndSize
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_AsUTF8AndSize DD imagerel $LN30
	DD	imagerel $LN30+91
	DD	imagerel $unwind$PyUnicode_AsUTF8AndSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyUnicode_AsUTF8AndSize DD imagerel $LN30+91
	DD	imagerel $LN30+181
	DD	imagerel $chain$0$PyUnicode_AsUTF8AndSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyUnicode_AsUTF8AndSize DD imagerel $LN30+181
	DD	imagerel $LN30+338
	DD	imagerel $chain$2$PyUnicode_AsUTF8AndSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyUnicode_AsUTF8AndSize DD 020021H
	DD	067400H
	DD	imagerel $LN30
	DD	imagerel $LN30+91
	DD	imagerel $unwind$PyUnicode_AsUTF8AndSize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyUnicode_AsUTF8AndSize DD 020521H
	DD	067405H
	DD	imagerel $LN30
	DD	imagerel $LN30+91
	DD	imagerel $unwind$PyUnicode_AsUTF8AndSize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_AsUTF8AndSize DD 040a01H
	DD	07340aH
	DD	06006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_AsUTF8AndSize
_TEXT	SEGMENT
unicode$ = 48
psize$ = 56
PyUnicode_AsUTF8AndSize PROC				; COMDAT

; 3930 : {

$LN30:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3931 :     PyObject *bytes;
; 3932 : 
; 3933 :     if (!PyUnicode_Check(unicode)) {

  0000a	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000e	48 8b f2	 mov	 rsi, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0001e	75 12		 jne	 SHORT $LN14@PyUnicode_@104

; 3934 :         PyErr_BadArgument();

  00020	e8 00 00 00 00	 call	 PyErr_BadArgument
$LN29@PyUnicode_@104:

; 3935 :         return NULL;

  00025	33 c0		 xor	 eax, eax

; 3960 : }

  00027	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5e		 pop	 rsi
  00031	c3		 ret	 0
$LN14@PyUnicode_@104:

; 3936 :     }
; 3937 :     if (PyUnicode_READY(unicode) == -1)

  00032	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00036	75 0a		 jne	 SHORT $LN13@PyUnicode_@104
  00038	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0003d	83 f8 ff	 cmp	 eax, -1

; 3938 :         return NULL;

  00040	74 e3		 je	 SHORT $LN29@PyUnicode_@104
$LN13@PyUnicode_@104:

; 3939 : 
; 3940 :     if (PyUnicode_UTF8(unicode) == NULL) {

  00042	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00045	a8 40		 test	 al, 64			; 00000040H
  00047	74 0b		 je	 SHORT $LN19@PyUnicode_@104
  00049	a8 20		 test	 al, 32			; 00000020H
  0004b	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00052	75 07		 jne	 SHORT $LN20@PyUnicode_@104
$LN19@PyUnicode_@104:
  00054	48 8b 83 88 00
	00 00		 mov	 rax, QWORD PTR [rbx+136]
$LN20@PyUnicode_@104:
  0005b	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00060	48 85 c0	 test	 rax, rax
  00063	0f 85 a0 00 00
	00		 jne	 $LN12@PyUnicode_@104

; 3941 :         assert(!PyUnicode_IS_COMPACT_ASCII(unicode));
; 3942 :         bytes = _PyUnicode_AsUTF8String(unicode, "strict");

  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  00070	48 8b cb	 mov	 rcx, rbx
  00073	e8 00 00 00 00	 call	 _PyUnicode_AsUTF8String
  00078	48 8b f8	 mov	 rdi, rax

; 3943 :         if (bytes == NULL)

  0007b	48 85 c0	 test	 rax, rax

; 3944 :             return NULL;

  0007e	74 23		 je	 SHORT $LN28@PyUnicode_@104

; 3945 :         _PyUnicode_UTF8(unicode) = PyObject_MALLOC(PyBytes_GET_SIZE(bytes) + 1);

  00080	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00084	48 ff c1	 inc	 rcx
  00087	e8 00 00 00 00	 call	 PyObject_Malloc
  0008c	4c 8b d8	 mov	 r11, rax
  0008f	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 3946 :         if (_PyUnicode_UTF8(unicode) == NULL) {

  00096	48 85 c0	 test	 rax, rax
  00099	75 1a		 jne	 SHORT $LN10@PyUnicode_@104

; 3947 :             Py_DECREF(bytes);

  0009b	48 8b cf	 mov	 rcx, rdi
  0009e	e8 00 00 00 00	 call	 _Py_DecRef
$LN28@PyUnicode_@104:

; 3948 :             return NULL;

  000a3	33 c0		 xor	 eax, eax
  000a5	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 3960 : }

  000aa	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000af	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b3	5e		 pop	 rsi
  000b4	c3		 ret	 0
$LN10@PyUnicode_@104:

; 3949 :         }
; 3950 :         _PyUnicode_UTF8_LENGTH(unicode) = PyBytes_GET_SIZE(bytes);

  000b5	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]

; 3951 :         Py_MEMCPY(_PyUnicode_UTF8(unicode),
; 3952 :                   PyBytes_AS_STRING(bytes),
; 3953 :                   _PyUnicode_UTF8_LENGTH(unicode) + 1);

  000b9	48 8d 57 78	 lea	 rdx, QWORD PTR [rdi+120]
  000bd	48 8d 48 01	 lea	 rcx, QWORD PTR [rax+1]
  000c1	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax
  000c8	48 83 f9 10	 cmp	 rcx, 16
  000cc	72 0d		 jb	 SHORT $LN6@PyUnicode_@104
  000ce	4c 8b c1	 mov	 r8, rcx
  000d1	49 8b cb	 mov	 rcx, r11
  000d4	e8 00 00 00 00	 call	 memcpy
  000d9	eb 26		 jmp	 SHORT $LN8@PyUnicode_@104
$LN6@PyUnicode_@104:
  000db	48 85 c9	 test	 rcx, rcx
  000de	74 21		 je	 SHORT $LN8@PyUnicode_@104
  000e0	49 2b d3	 sub	 rdx, r11
  000e3	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL4@PyUnicode_@104:
  000f0	42 0f b6 04 1a	 movzx	 eax, BYTE PTR [rdx+r11]
  000f5	49 ff c3	 inc	 r11
  000f8	48 ff c9	 dec	 rcx
  000fb	41 88 43 ff	 mov	 BYTE PTR [r11-1], al
  000ff	75 ef		 jne	 SHORT $LL4@PyUnicode_@104
$LN8@PyUnicode_@104:

; 3954 :         Py_DECREF(bytes);

  00101	48 8b cf	 mov	 rcx, rdi
  00104	e8 00 00 00 00	 call	 _Py_DecRef
$LN12@PyUnicode_@104:

; 3955 :     }
; 3956 : 
; 3957 :     if (psize)

  00109	48 85 f6	 test	 rsi, rsi
  0010c	74 1b		 je	 SHORT $LN1@PyUnicode_@104

; 3958 :         *psize = PyUnicode_UTF8_LENGTH(unicode);

  0010e	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00111	a8 40		 test	 al, 64			; 00000040H
  00113	74 0a		 je	 SHORT $LN21@PyUnicode_@104
  00115	a8 20		 test	 al, 32			; 00000020H
  00117	74 06		 je	 SHORT $LN21@PyUnicode_@104
  00119	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  0011d	eb 07		 jmp	 SHORT $LN22@PyUnicode_@104
$LN21@PyUnicode_@104:
  0011f	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]
$LN22@PyUnicode_@104:
  00126	48 89 06	 mov	 QWORD PTR [rsi], rax
$LN1@PyUnicode_@104:

; 3959 :     return PyUnicode_UTF8(unicode);

  00129	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0012c	a8 40		 test	 al, 64			; 00000040H
  0012e	74 0b		 je	 SHORT $LN23@PyUnicode_@104
  00130	a8 20		 test	 al, 32			; 00000020H
  00132	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00139	75 07		 jne	 SHORT $LN24@PyUnicode_@104
$LN23@PyUnicode_@104:
  0013b	48 8b 83 88 00
	00 00		 mov	 rax, QWORD PTR [rbx+136]
$LN24@PyUnicode_@104:
  00142	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 3960 : }

  00147	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0014c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00150	5e		 pop	 rsi
  00151	c3		 ret	 0
PyUnicode_AsUTF8AndSize ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsUTF8
; Function compile flags: /Ogtpy
;	COMDAT PyUnicode_AsUTF8
_TEXT	SEGMENT
unicode$ = 8
PyUnicode_AsUTF8 PROC					; COMDAT

; 3965 :     return PyUnicode_AsUTF8AndSize(unicode, NULL);

  00000	33 d2		 xor	 edx, edx

; 3966 : }

  00002	e9 00 00 00 00	 jmp	 PyUnicode_AsUTF8AndSize
PyUnicode_AsUTF8 ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_DecodeUTF7
; Function compile flags: /Ogtpy
;	COMDAT PyUnicode_DecodeUTF7
_TEXT	SEGMENT
s$ = 8
size$ = 16
errors$ = 24
PyUnicode_DecodeUTF7 PROC				; COMDAT

; 4395 :     return PyUnicode_DecodeUTF7Stateful(s, size, errors, NULL);

  00000	45 33 c9	 xor	 r9d, r9d

; 4396 : }

  00003	e9 00 00 00 00	 jmp	 PyUnicode_DecodeUTF7Stateful
PyUnicode_DecodeUTF7 ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_DecodeUTF8
; Function compile flags: /Ogtpy
;	COMDAT PyUnicode_DecodeUTF8
_TEXT	SEGMENT
s$ = 8
size$ = 16
errors$ = 24
PyUnicode_DecodeUTF8 PROC				; COMDAT

; 4731 :     return PyUnicode_DecodeUTF8Stateful(s, size, errors, NULL);

  00000	45 33 c9	 xor	 r9d, r9d

; 4732 : }

  00003	e9 00 00 00 00	 jmp	 PyUnicode_DecodeUTF8Stateful
PyUnicode_DecodeUTF8 ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_DecodeUTF32
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_DecodeUTF32 DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$PyUnicode_DecodeUTF32
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_DecodeUTF32 DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_DecodeUTF32
_TEXT	SEGMENT
s$ = 64
size$ = 72
errors$ = 80
byteorder$ = 88
PyUnicode_DecodeUTF32 PROC				; COMDAT

; 5060 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5061 :     return PyUnicode_DecodeUTF32Stateful(s, size, errors, byteorder, NULL);

  00004	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0000d	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF32Stateful

; 5062 : }

  00012	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00016	c3		 ret	 0
PyUnicode_DecodeUTF32 ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_DecodeUTF16
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_DecodeUTF16 DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$PyUnicode_DecodeUTF16
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_DecodeUTF16 DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_DecodeUTF16
_TEXT	SEGMENT
s$ = 64
size$ = 72
errors$ = 80
byteorder$ = 88
PyUnicode_DecodeUTF16 PROC				; COMDAT

; 5305 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5306 :     return PyUnicode_DecodeUTF16Stateful(s, size, errors, byteorder, NULL);

  00004	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0000d	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF16Stateful

; 5307 : }

  00012	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00016	c3		 ret	 0
PyUnicode_DecodeUTF16 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@GIGGOBPC@encode_code_page_strict?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$encode_code_page_strict DD imagerel encode_code_page_strict
	DD	imagerel encode_code_page_strict+125
	DD	imagerel $unwind$encode_code_page_strict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$encode_code_page_strict DD imagerel encode_code_page_strict+125
	DD	imagerel encode_code_page_strict+500
	DD	imagerel $chain$0$encode_code_page_strict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$encode_code_page_strict DD imagerel encode_code_page_strict+500
	DD	imagerel encode_code_page_strict+520
	DD	imagerel $chain$1$encode_code_page_strict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$encode_code_page_strict DD 021H
	DD	imagerel encode_code_page_strict
	DD	imagerel encode_code_page_strict+125
	DD	imagerel $unwind$encode_code_page_strict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$encode_code_page_strict DD 020821H
	DD	011e408H
	DD	imagerel encode_code_page_strict
	DD	imagerel encode_code_page_strict+125
	DD	imagerel $unwind$encode_code_page_strict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encode_code_page_strict DD 081001H
	DD	0123410H
	DD	0d00c9210H
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT ??_C@_0BI@GIGGOBPC@encode_code_page_strict?$AA@
CONST	SEGMENT
??_C@_0BI@GIGGOBPC@encode_code_page_strict?$AA@ DB 'encode_code_page_stri'
	DB	'ct', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT encode_code_page_strict
_TEXT	SEGMENT
size$ = 64
usedDefaultChar$ = 128
code_page$ = 128
outbytes$ = 136
unicode$ = 144
flags$1$ = 152
offset$ = 152
len$ = 160
encode_code_page_strict PROC				; COMDAT

; 7122 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00010	48 8b f2	 mov	 rsi, rdx

; 7123 :     BOOL usedDefaultChar = FALSE;

  00013	45 33 ed	 xor	 r13d, r13d

; 7124 :     BOOL *pusedDefaultChar = &usedDefaultChar;
; 7125 :     int outsize;
; 7126 :     PyObject *exc = NULL;
; 7127 :     wchar_t *p;
; 7128 :     Py_ssize_t size;
; 7129 :     const DWORD flags = encode_code_page_flags(code_page, NULL);

  00016	33 d2		 xor	 edx, edx
  00018	4d 8b d0	 mov	 r10, r8
  0001b	8b e9		 mov	 ebp, ecx
  0001d	44 89 ac 24 80
	00 00 00	 mov	 DWORD PTR usedDefaultChar$[rsp], r13d
  00025	e8 00 00 00 00	 call	 encode_code_page_flags
  0002a	44 8b e0	 mov	 r12d, eax
  0002d	89 84 24 98 00
	00 00		 mov	 DWORD PTR flags$1$[rsp], eax

; 7130 :     char *out;
; 7131 :     /* Create a substring so that we can get the UTF-16 representation
; 7132 :        of just the slice under consideration. */
; 7133 :     PyObject *substring;
; 7134 : 
; 7135 :     assert(len > 0);
; 7136 : 
; 7137 :     if (code_page != CP_UTF8 && code_page != CP_UTF7)

  00034	81 fd e9 fd 00
	00		 cmp	 ebp, 65001		; 0000fde9H
  0003a	74 10		 je	 SHORT $LN22@encode_cod@3

; 7138 :         pusedDefaultChar = &usedDefaultChar;

  0003c	48 8d bc 24 80
	00 00 00	 lea	 rdi, QWORD PTR usedDefaultChar$[rsp]
  00044	81 fd e8 fd 00
	00		 cmp	 ebp, 65000		; 0000fde8H
  0004a	75 03		 jne	 SHORT $LN21@encode_cod@3
$LN22@encode_cod@3:

; 7139 :     else
; 7140 :         pusedDefaultChar = NULL;

  0004c	49 8b fd	 mov	 rdi, r13
$LN21@encode_cod@3:

; 7141 : 
; 7142 :     substring = PyUnicode_Substring(unicode, offset, offset+len);

  0004f	4c 63 84 24 a0
	00 00 00	 movsxd	 r8, DWORD PTR len$[rsp]
  00057	49 8b d1	 mov	 rdx, r9
  0005a	49 8b ca	 mov	 rcx, r10
  0005d	4d 03 c1	 add	 r8, r9
  00060	e8 00 00 00 00	 call	 PyUnicode_Substring
  00065	48 8b d8	 mov	 rbx, rax

; 7143 :     if (substring == NULL)

  00068	48 85 c0	 test	 rax, rax
  0006b	75 08		 jne	 SHORT $LN20@encode_cod@3

; 7144 :         return -1;

  0006d	83 c8 ff	 or	 eax, -1
  00070	e9 7f 01 00 00	 jmp	 $LN23@encode_cod@3
$LN20@encode_cod@3:

; 7145 :     p = PyUnicode_AsUnicodeAndSize(substring, &size);

  00075	48 8d 54 24 40	 lea	 rdx, QWORD PTR size$[rsp]
  0007a	48 8b c8	 mov	 rcx, rax
  0007d	4c 89 b4 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], r14
  00085	e8 00 00 00 00	 call	 PyUnicode_AsUnicodeAndSize
  0008a	4c 8b f0	 mov	 r14, rax

; 7146 :     if (p == NULL) {

  0008d	48 85 c0	 test	 rax, rax

; 7147 :         Py_DECREF(substring);
; 7148 :         return -1;

  00090	0f 84 8b 00 00
	00		 je	 $LN27@encode_cod@3

; 7149 :     }
; 7150 : 
; 7151 :     /* First get the size of the result */
; 7152 :     outsize = WideCharToMultiByte(code_page, flags,
; 7153 :                                   p, size,
; 7154 :                                   NULL, 0,
; 7155 :                                   NULL, pusedDefaultChar);

  00096	44 8b 4c 24 40	 mov	 r9d, DWORD PTR size$[rsp]
  0009b	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  000a0	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  000a5	4c 8b c0	 mov	 r8, rax
  000a8	41 8b d4	 mov	 edx, r12d
  000ab	8b cd		 mov	 ecx, ebp
  000ad	44 89 6c 24 28	 mov	 DWORD PTR [rsp+40], r13d
  000b2	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WideCharToMultiByte
  000bd	4c 63 e8	 movsxd	 r13, eax

; 7156 :     if (outsize <= 0)

  000c0	85 c0		 test	 eax, eax
  000c2	0f 8e fc 00 00
	00		 jle	 $error$133153

; 7157 :         goto error;
; 7158 :     /* If we used a default char, then we failed! */
; 7159 :     if (pusedDefaultChar && *pusedDefaultChar) {

  000c8	48 85 ff	 test	 rdi, rdi
  000cb	74 17		 je	 SHORT $LN17@encode_cod@3
  000cd	83 3f 00	 cmp	 DWORD PTR [rdi], 0
  000d0	74 12		 je	 SHORT $LN17@encode_cod@3

; 7160 :         Py_DECREF(substring);

  000d2	48 8b cb	 mov	 rcx, rbx
  000d5	e8 00 00 00 00	 call	 _Py_DecRef
$LN28@encode_cod@3:

; 7161 :         return -2;

  000da	b8 fe ff ff ff	 mov	 eax, -2
  000df	e9 08 01 00 00	 jmp	 $LN25@encode_cod@3
$LN17@encode_cod@3:

; 7162 :     }
; 7163 : 
; 7164 :     if (*outbytes == NULL) {

  000e4	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  000e7	48 85 c9	 test	 rcx, rcx
  000ea	75 16		 jne	 SHORT $LN16@encode_cod@3

; 7165 :         /* Create string object */
; 7166 :         *outbytes = PyBytes_FromStringAndSize(NULL, outsize);

  000ec	49 8b d5	 mov	 rdx, r13
  000ef	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000f4	48 89 06	 mov	 QWORD PTR [rsi], rax

; 7167 :         if (*outbytes == NULL) {

  000f7	48 85 c0	 test	 rax, rax

; 7168 :             Py_DECREF(substring);
; 7169 :             return -1;

  000fa	74 25		 je	 SHORT $LN27@encode_cod@3

; 7170 :         }
; 7171 :         out = PyBytes_AS_STRING(*outbytes);

  000fc	48 83 c0 78	 add	 rax, 120		; 00000078H

; 7172 :     }
; 7173 :     else {

  00100	eb 4d		 jmp	 SHORT $LN14@encode_cod@3
$LN16@encode_cod@3:

; 7174 :         /* Extend string object */
; 7175 :         const Py_ssize_t n = PyBytes_Size(*outbytes);

  00102	e8 00 00 00 00	 call	 PyBytes_Size

; 7176 :         if (outsize > PY_SSIZE_T_MAX - n) {

  00107	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00111	48 2b c8	 sub	 rcx, rax
  00114	4c 8b e0	 mov	 r12, rax
  00117	4c 3b e9	 cmp	 r13, rcx
  0011a	7e 12		 jle	 SHORT $LN13@encode_cod@3

; 7177 :             PyErr_NoMemory();

  0011c	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN27@encode_cod@3:

; 7178 :             Py_DECREF(substring);

  00121	48 8b cb	 mov	 rcx, rbx
  00124	e8 00 00 00 00	 call	 _Py_DecRef

; 7179 :             return -1;

  00129	e9 bb 00 00 00	 jmp	 $LN26@encode_cod@3
$LN13@encode_cod@3:

; 7180 :         }
; 7181 :         if (_PyBytes_Resize(outbytes, n + outsize) < 0) {

  0012e	49 8d 54 05 00	 lea	 rdx, QWORD PTR [r13+rax]
  00133	48 8b ce	 mov	 rcx, rsi
  00136	e8 00 00 00 00	 call	 _PyBytes_Resize
  0013b	85 c0		 test	 eax, eax

; 7182 :             Py_DECREF(substring);
; 7183 :             return -1;

  0013d	78 e2		 js	 SHORT $LN27@encode_cod@3

; 7184 :         }
; 7185 :         out = PyBytes_AS_STRING(*outbytes) + n;

  0013f	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00142	4a 8d 44 20 78	 lea	 rax, QWORD PTR [rax+r12+120]
  00147	44 8b a4 24 98
	00 00 00	 mov	 r12d, DWORD PTR flags$1$[rsp]
$LN14@encode_cod@3:

; 7186 :     }
; 7187 : 
; 7188 :     /* Do the conversion */
; 7189 :     outsize = WideCharToMultiByte(code_page, flags,
; 7190 :                                   p, size,
; 7191 :                                   out, outsize,
; 7192 :                                   NULL, pusedDefaultChar);

  0014f	44 8b 4c 24 40	 mov	 r9d, DWORD PTR size$[rsp]
  00154	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00159	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00162	4d 8b c6	 mov	 r8, r14
  00165	41 8b d4	 mov	 edx, r12d
  00168	8b cd		 mov	 ecx, ebp
  0016a	44 89 6c 24 28	 mov	 DWORD PTR [rsp+40], r13d
  0016f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00174	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WideCharToMultiByte

; 7193 :     Py_CLEAR(substring);

  0017a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@GIGGOBPC@encode_code_page_strict?$AA@
  00188	4c 8b cb	 mov	 r9, rbx
  0018b	41 b8 19 1c 00
	00		 mov	 r8d, 7193		; 00001c19H
  00191	8b f0		 mov	 esi, eax
  00193	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0019b	e8 00 00 00 00	 call	 _PyParallel_Guard
  001a0	85 c0		 test	 eax, eax
  001a2	75 0a		 jne	 SHORT $LN10@encode_cod@3
  001a4	48 8b cb	 mov	 rcx, rbx
  001a7	33 db		 xor	 ebx, ebx
  001a9	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@encode_cod@3:

; 7194 :     if (outsize <= 0)

  001ae	85 f6		 test	 esi, esi
  001b0	7e 12		 jle	 SHORT $error$133153

; 7195 :         goto error;
; 7196 :     if (pusedDefaultChar && *pusedDefaultChar)

  001b2	48 85 ff	 test	 rdi, rdi
  001b5	74 09		 je	 SHORT $LN6@encode_cod@3
  001b7	83 3f 00	 cmp	 DWORD PTR [rdi], 0

; 7197 :         return -2;

  001ba	0f 85 1a ff ff
	ff		 jne	 $LN28@encode_cod@3
$LN6@encode_cod@3:

; 7198 :     return 0;

  001c0	33 c0		 xor	 eax, eax
  001c2	eb 28		 jmp	 SHORT $LN25@encode_cod@3
$error$133153:

; 7199 : 
; 7200 : error:
; 7201 :     Py_XDECREF(substring);

  001c4	48 85 db	 test	 rbx, rbx
  001c7	74 08		 je	 SHORT $LN4@encode_cod@3
  001c9	48 8b cb	 mov	 rcx, rbx
  001cc	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@encode_cod@3:

; 7202 :     if (GetLastError() == ERROR_NO_UNICODE_TRANSLATION)

  001d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  001d7	3d 59 04 00 00	 cmp	 eax, 1113		; 00000459H

; 7203 :         return -2;

  001dc	0f 84 f8 fe ff
	ff		 je	 $LN28@encode_cod@3

; 7204 :     PyErr_SetFromWindowsErr(0);

  001e2	33 c9		 xor	 ecx, ecx
  001e4	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
$LN26@encode_cod@3:

; 7205 :     return -1;

  001e9	83 c8 ff	 or	 eax, -1
$LN25@encode_cod@3:
  001ec	4c 8b b4 24 88
	00 00 00	 mov	 r14, QWORD PTR [rsp+136]
$LN23@encode_cod@3:

; 7206 : }

  001f4	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  001fc	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00200	41 5d		 pop	 r13
  00202	41 5c		 pop	 r12
  00204	5f		 pop	 rdi
  00205	5e		 pop	 rsi
  00206	5d		 pop	 rbp
  00207	c3		 ret	 0
encode_code_page_strict ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$encode_code_page DD imagerel encode_code_page
	DD	imagerel encode_code_page+60
	DD	imagerel $unwind$encode_code_page
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$encode_code_page DD imagerel encode_code_page+60
	DD	imagerel encode_code_page+112
	DD	imagerel $chain$0$encode_code_page
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$encode_code_page DD imagerel encode_code_page+112
	DD	imagerel encode_code_page+142
	DD	imagerel $chain$2$encode_code_page
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$encode_code_page DD imagerel encode_code_page+142
	DD	imagerel encode_code_page+317
	DD	imagerel $chain$7$encode_code_page
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$encode_code_page DD 080f21H
	DD	07640fH
	DD	06740aH
	DD	0e5405H
	DD	0c3400H
	DD	imagerel encode_code_page
	DD	imagerel encode_code_page+60
	DD	imagerel $unwind$encode_code_page
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$encode_code_page DD 020021H
	DD	0c3400H
	DD	imagerel encode_code_page
	DD	imagerel encode_code_page+60
	DD	imagerel $unwind$encode_code_page
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$encode_code_page DD 020521H
	DD	0c3405H
	DD	imagerel encode_code_page
	DD	imagerel encode_code_page+60
	DD	imagerel $unwind$encode_code_page
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encode_code_page DD 040a01H
	DD	0e006720aH
	DD	0c002d004H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT encode_code_page
_TEXT	SEGMENT
code_page$ = 96
outbytes$ = 104
unicode$ = 104
errors$ = 112
encode_code_page PROC					; COMDAT

; 7401 : {

  00000	41 54		 push	 r12
  00002	41 55		 push	 r13
  00004	41 56		 push	 r14
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 7402 :     Py_ssize_t len;
; 7403 :     PyObject *outbytes = NULL;
; 7404 :     Py_ssize_t offset;
; 7405 :     int chunk_len, ret, done;
; 7406 : 
; 7407 :     if (PyUnicode_READY(unicode) == -1)

  0000a	f6 42 70 80	 test	 BYTE PTR [rdx+112], 128	; 00000080H
  0000e	4d 8b f0	 mov	 r14, r8
  00011	4c 8b e2	 mov	 r12, rdx
  00014	44 8b e9	 mov	 r13d, ecx
  00017	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR outbytes$[rsp], 0
  00020	75 1a		 jne	 SHORT $LN14@encode_cod@4
  00022	48 8b ca	 mov	 rcx, rdx
  00025	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0002a	83 f8 ff	 cmp	 eax, -1
  0002d	75 0d		 jne	 SHORT $LN14@encode_cod@4

; 7408 :         return NULL;

  0002f	33 c0		 xor	 eax, eax

; 7453 : }

  00031	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00035	41 5e		 pop	 r14
  00037	41 5d		 pop	 r13
  00039	41 5c		 pop	 r12
  0003b	c3		 ret	 0
$LN14@encode_cod@4:
  0003c	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx

; 7409 :     len = PyUnicode_GET_LENGTH(unicode);

  00041	49 8b 5c 24 60	 mov	 rbx, QWORD PTR [r12+96]

; 7410 : 
; 7411 :     if (code_page < 0) {

  00046	45 85 ed	 test	 r13d, r13d
  00049	79 25		 jns	 SHORT $LN13@encode_cod@4

; 7412 :         PyErr_SetString(PyExc_ValueError, "invalid code page number");

  0004b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@GCBOAGML@invalid?5code?5page?5number?$AA@
  00059	e8 00 00 00 00	 call	 PyErr_SetString
  0005e	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 7413 :         return NULL;

  00063	33 c0		 xor	 eax, eax

; 7453 : }

  00065	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00069	41 5e		 pop	 r14
  0006b	41 5d		 pop	 r13
  0006d	41 5c		 pop	 r12
  0006f	c3		 ret	 0
$LN13@encode_cod@4:

; 7414 :     }
; 7415 : 
; 7416 :     if (len == 0)

  00070	48 85 db	 test	 rbx, rbx
  00073	75 19		 jne	 SHORT $LN12@encode_cod@4

; 7417 :         return PyBytes_FromStringAndSize(NULL, 0);

  00075	33 d2		 xor	 edx, edx
  00077	33 c9		 xor	 ecx, ecx
  00079	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0007e	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 7453 : }

  00083	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00087	41 5e		 pop	 r14
  00089	41 5d		 pop	 r13
  0008b	41 5c		 pop	 r12
  0008d	c3		 ret	 0
$LN12@encode_cod@4:
  0008e	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  00093	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00098	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi

; 7418 : 
; 7419 :     offset = 0;

  0009d	33 ed		 xor	 ebp, ebp
  0009f	90		 npad	 1
$LL11@encode_cod@4:

; 7420 :     do
; 7421 :     {
; 7422 : #ifdef NEED_RETRY
; 7423 :         /* UTF-16 encoding may double the size, so use only INT_MAX/2
; 7424 :            chunks. */
; 7425 :         if (len > INT_MAX/2) {

  000a0	48 81 fb ff ff
	ff 3f		 cmp	 rbx, 1073741823		; 3fffffffH
  000a7	7e 09		 jle	 SHORT $LN8@encode_cod@4

; 7426 :             chunk_len = INT_MAX/2;

  000a9	bf ff ff ff 3f	 mov	 edi, 1073741823		; 3fffffffH

; 7427 :             done = 0;

  000ae	33 f6		 xor	 esi, esi

; 7428 :         }
; 7429 :         else

  000b0	eb 07		 jmp	 SHORT $LN7@encode_cod@4
$LN8@encode_cod@4:

; 7430 : #endif
; 7431 :         {
; 7432 :             chunk_len = (int)len;

  000b2	8b fb		 mov	 edi, ebx

; 7433 :             done = 1;

  000b4	be 01 00 00 00	 mov	 esi, 1
$LN7@encode_cod@4:

; 7434 :         }
; 7435 : 
; 7436 :         ret = encode_code_page_strict(code_page, &outbytes,
; 7437 :                                       unicode, offset, chunk_len,
; 7438 :                                       errors);

  000b9	48 8d 54 24 68	 lea	 rdx, QWORD PTR outbytes$[rsp]
  000be	4c 8b cd	 mov	 r9, rbp
  000c1	4d 8b c4	 mov	 r8, r12
  000c4	41 8b cd	 mov	 ecx, r13d
  000c7	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  000cb	e8 00 00 00 00	 call	 encode_code_page_strict

; 7439 :         if (ret == -2)

  000d0	83 f8 fe	 cmp	 eax, -2
  000d3	75 20		 jne	 SHORT $LN6@encode_cod@4

; 7440 :             ret = encode_code_page_errors(code_page, &outbytes,
; 7441 :                                           unicode, offset,
; 7442 :                                           chunk_len, errors);

  000d5	48 63 c7	 movsxd	 rax, edi
  000d8	48 8d 54 24 68	 lea	 rdx, QWORD PTR outbytes$[rsp]
  000dd	4c 8b cd	 mov	 r9, rbp
  000e0	4d 8b c4	 mov	 r8, r12
  000e3	41 8b cd	 mov	 ecx, r13d
  000e6	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  000eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f0	e8 00 00 00 00	 call	 encode_code_page_errors
$LN6@encode_cod@4:

; 7443 :         if (ret < 0) {

  000f5	85 c0		 test	 eax, eax
  000f7	78 14		 js	 SHORT $LN20@encode_cod@4

; 7446 :         }
; 7447 : 
; 7448 :         offset += chunk_len;

  000f9	48 63 c7	 movsxd	 rax, edi
  000fc	48 03 e8	 add	 rbp, rax

; 7449 :         len -= chunk_len;

  000ff	48 2b d8	 sub	 rbx, rax

; 7450 :     } while (!done);

  00102	85 f6		 test	 esi, esi
  00104	74 9a		 je	 SHORT $LL11@encode_cod@4

; 7451 : 
; 7452 :     return outbytes;

  00106	48 8b 44 24 68	 mov	 rax, QWORD PTR outbytes$[rsp]
  0010b	eb 11		 jmp	 SHORT $LN25@encode_cod@4
$LN20@encode_cod@4:

; 7444 :             Py_XDECREF(outbytes);

  0010d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR outbytes$[rsp]
  00112	48 85 c9	 test	 rcx, rcx
  00115	74 05		 je	 SHORT $LN3@encode_cod@4
  00117	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@encode_cod@4:

; 7445 :             return NULL;

  0011c	33 c0		 xor	 eax, eax
$LN25@encode_cod@4:
  0011e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00123	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00128	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  0012d	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 7453 : }

  00132	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00136	41 5e		 pop	 r14
  00138	41 5d		 pop	 r13
  0013a	41 5c		 pop	 r12
  0013c	c3		 ret	 0
encode_code_page ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_EncodeMBCS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_EncodeMBCS DD imagerel $LN4
	DD	imagerel $LN4+75
	DD	imagerel $unwind$PyUnicode_EncodeMBCS
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_EncodeMBCS DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_EncodeMBCS
_TEXT	SEGMENT
p$ = 48
size$ = 56
errors$ = 64
PyUnicode_EncodeMBCS PROC				; COMDAT

; 7459 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b d8	 mov	 rbx, r8

; 7460 :     PyObject *unicode, *res;
; 7461 :     unicode = PyUnicode_FromUnicode(p, size);

  0000d	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  00012	48 8b f8	 mov	 rdi, rax

; 7462 :     if (unicode == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0b		 jne	 SHORT $LN1@PyUnicode_@105

; 7467 : }

  0001a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
$LN1@PyUnicode_@105:

; 7463 :         return NULL;
; 7464 :     res = encode_code_page(CP_ACP, unicode, errors);

  00025	4c 8b c3	 mov	 r8, rbx
  00028	48 8b d0	 mov	 rdx, rax
  0002b	33 c9		 xor	 ecx, ecx
  0002d	e8 00 00 00 00	 call	 encode_code_page

; 7465 :     Py_DECREF(unicode);

  00032	48 8b cf	 mov	 rcx, rdi
  00035	48 8b d8	 mov	 rbx, rax
  00038	e8 00 00 00 00	 call	 _Py_DecRef

; 7466 :     return res;

  0003d	48 8b c3	 mov	 rax, rbx

; 7467 : }

  00040	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5f		 pop	 rdi
  0004a	c3		 ret	 0
PyUnicode_EncodeMBCS ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_EncodeCodePage
; Function compile flags: /Ogtpy
;	COMDAT PyUnicode_EncodeCodePage
_TEXT	SEGMENT
code_page$ = 8
unicode$ = 16
errors$ = 24
PyUnicode_EncodeCodePage PROC				; COMDAT

; 7474 :     return encode_code_page(code_page, unicode, errors);
; 7475 : }

  00000	e9 00 00 00 00	 jmp	 encode_code_page
PyUnicode_EncodeCodePage ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_AsMBCSString
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_AsMBCSString DD imagerel $LN4
	DD	imagerel $LN4+49
	DD	imagerel $unwind$PyUnicode_AsMBCSString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_AsMBCSString DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_AsMBCSString
_TEXT	SEGMENT
unicode$ = 48
PyUnicode_AsMBCSString PROC				; COMDAT

; 7479 : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 7480 :     if (!PyUnicode_Check(unicode)) {

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00012	75 0c		 jne	 SHORT $LN1@PyUnicode_@106

; 7481 :         PyErr_BadArgument();

  00014	e8 00 00 00 00	 call	 PyErr_BadArgument

; 7482 :         return NULL;

  00019	33 c0		 xor	 eax, eax

; 7485 : }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
$LN1@PyUnicode_@106:

; 7483 :     }
; 7484 :     return PyUnicode_EncodeCodePage(CP_ACP, unicode, NULL);

  00020	48 8b d1	 mov	 rdx, rcx
  00023	45 33 c0	 xor	 r8d, r8d
  00026	33 c9		 xor	 ecx, ecx

; 7485 : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	e9 00 00 00 00	 jmp	 PyUnicode_EncodeCodePage
PyUnicode_AsMBCSString ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_XStrip
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_XStrip DD imagerel $LN48
	DD	imagerel $LN48+488
	DD	imagerel $unwind$_PyUnicode_XStrip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_XStrip DD 0e6701H
	DD	06f467H
	DD	07745fH
	DD	0e6458H
	DD	0d5453H
	DD	0c344eH
	DD	0e006720aH
	DD	0c002d004H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_XStrip
_TEXT	SEGMENT
self$ = 96
striptype$ = 104
sepobj$ = 112
_PyUnicode_XStrip PROC					; COMDAT

; 11719: {

$LN48:
  00000	41 54		 push	 r12
  00002	41 55		 push	 r13
  00004	41 56		 push	 r14
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 11720:     void *data;
; 11721:     int kind;
; 11722:     Py_ssize_t i, j, len;
; 11723:     BLOOM_MASK sepmask;
; 11724: 
; 11725:     if (PyUnicode_READY(self) == -1 || PyUnicode_READY(sepobj) == -1)

  0000a	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000e	4d 8b e0	 mov	 r12, r8
  00011	44 8b f2	 mov	 r14d, edx
  00014	4c 8b e9	 mov	 r13, rcx
  00017	75 0a		 jne	 SHORT $LN45@PyUnicode_@107
  00019	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0001e	83 f8 ff	 cmp	 eax, -1
  00021	74 15		 je	 SHORT $LN10@PyUnicode_@107
$LN45@PyUnicode_@107:
  00023	41 f6 44 24 70
	80		 test	 BYTE PTR [r12+112], 128	; 00000080H
  00029	75 1a		 jne	 SHORT $LN46@PyUnicode_@107
  0002b	49 8b cc	 mov	 rcx, r12
  0002e	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00033	83 f8 ff	 cmp	 eax, -1
  00036	75 0d		 jne	 SHORT $LN46@PyUnicode_@107
$LN10@PyUnicode_@107:

; 11726:         return NULL;

  00038	33 c0		 xor	 eax, eax

; 11753: }

  0003a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0003e	41 5e		 pop	 r14
  00040	41 5d		 pop	 r13
  00042	41 5c		 pop	 r12
  00044	c3		 ret	 0
$LN46@PyUnicode_@107:

; 11727: 
; 11728:     kind = PyUnicode_KIND(self);

  00045	41 8b 45 70	 mov	 eax, DWORD PTR [r13+112]
  00049	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  0004e	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp
  00053	48 89 74 24 70	 mov	 QWORD PTR [rsp+112], rsi
  00058	8b e8		 mov	 ebp, eax
  0005a	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0005f	c1 ed 02	 shr	 ebp, 2
  00062	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  00067	83 e5 07	 and	 ebp, 7

; 11729:     data = PyUnicode_DATA(self);

  0006a	a8 20		 test	 al, 32			; 00000020H
  0006c	74 16		 je	 SHORT $LN20@PyUnicode_@107
  0006e	a8 40		 test	 al, 64			; 00000040H
  00070	74 09		 je	 SHORT $LN18@PyUnicode_@107
  00072	49 8d 9d 80 00
	00 00		 lea	 rbx, QWORD PTR [r13+128]
  00079	eb 10		 jmp	 SHORT $LN21@PyUnicode_@107
$LN18@PyUnicode_@107:
  0007b	49 8d 9d a0 00
	00 00		 lea	 rbx, QWORD PTR [r13+160]
  00082	eb 07		 jmp	 SHORT $LN21@PyUnicode_@107
$LN20@PyUnicode_@107:
  00084	49 8b 9d a0 00
	00 00		 mov	 rbx, QWORD PTR [r13+160]
$LN21@PyUnicode_@107:

; 11730:     len = PyUnicode_GET_LENGTH(self);
; 11731:     sepmask = make_bloom_mask(PyUnicode_KIND(sepobj),
; 11732:                               PyUnicode_DATA(sepobj),
; 11733:                               PyUnicode_GET_LENGTH(sepobj));

  0008b	41 8b 4c 24 70	 mov	 ecx, DWORD PTR [r12+112]
  00090	49 8b 7d 60	 mov	 rdi, QWORD PTR [r13+96]
  00094	f6 c1 20	 test	 cl, 32			; 00000020H
  00097	74 19		 je	 SHORT $LN24@PyUnicode_@107
  00099	f6 c1 40	 test	 cl, 64			; 00000040H
  0009c	74 0a		 je	 SHORT $LN22@PyUnicode_@107
  0009e	49 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR [r12+128]
  000a6	eb 12		 jmp	 SHORT $LN25@PyUnicode_@107
$LN22@PyUnicode_@107:
  000a8	49 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR [r12+160]
  000b0	eb 08		 jmp	 SHORT $LN25@PyUnicode_@107
$LN24@PyUnicode_@107:
  000b2	49 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR [r12+160]
$LN25@PyUnicode_@107:
  000ba	4d 8b 44 24 60	 mov	 r8, QWORD PTR [r12+96]
  000bf	c1 e9 02	 shr	 ecx, 2
  000c2	83 e1 07	 and	 ecx, 7
  000c5	e8 00 00 00 00	 call	 make_bloom_mask

; 11734: 
; 11735:     i = 0;

  000ca	33 f6		 xor	 esi, esi

; 11736:     if (striptype != RIGHTSTRIP) {
; 11737:         while (i < len &&
; 11738:                BLOOM_MEMBER(sepmask, PyUnicode_READ(kind, data, i), sepobj)) {

  000cc	48 63 ed	 movsxd	 rbp, ebp
  000cf	44 8b f8	 mov	 r15d, eax
  000d2	41 83 fe 01	 cmp	 r14d, 1
  000d6	74 6c		 je	 SHORT $LN47@PyUnicode_@107
  000d8	48 85 ff	 test	 rdi, rdi
  000db	7e 67		 jle	 SHORT $LN47@PyUnicode_@107
  000dd	0f 1f 00	 npad	 3
$LL8@PyUnicode_@107:
  000e0	48 83 fd 01	 cmp	 rbp, 1
  000e4	75 06		 jne	 SHORT $LN28@PyUnicode_@107
  000e6	0f b6 04 1e	 movzx	 eax, BYTE PTR [rsi+rbx]
  000ea	eb 0f		 jmp	 SHORT $LN27@PyUnicode_@107
$LN28@PyUnicode_@107:
  000ec	48 83 fd 02	 cmp	 rbp, 2
  000f0	75 06		 jne	 SHORT $LN26@PyUnicode_@107
  000f2	0f b7 04 73	 movzx	 eax, WORD PTR [rbx+rsi*2]
  000f6	eb 03		 jmp	 SHORT $LN27@PyUnicode_@107
$LN26@PyUnicode_@107:
  000f8	8b 04 b3	 mov	 eax, DWORD PTR [rbx+rsi*4]
$LN27@PyUnicode_@107:
  000fb	83 e0 1f	 and	 eax, 31
  000fe	41 0f a3 c7	 bt	 r15d, eax
  00102	73 40		 jae	 SHORT $LN47@PyUnicode_@107
  00104	48 83 fd 01	 cmp	 rbp, 1
  00108	75 06		 jne	 SHORT $LN32@PyUnicode_@107
  0010a	0f b6 14 1e	 movzx	 edx, BYTE PTR [rsi+rbx]
  0010e	eb 0f		 jmp	 SHORT $LN31@PyUnicode_@107
$LN32@PyUnicode_@107:
  00110	48 83 fd 02	 cmp	 rbp, 2
  00114	75 06		 jne	 SHORT $LN30@PyUnicode_@107
  00116	0f b7 14 73	 movzx	 edx, WORD PTR [rbx+rsi*2]
  0011a	eb 03		 jmp	 SHORT $LN31@PyUnicode_@107
$LN30@PyUnicode_@107:
  0011c	8b 14 b3	 mov	 edx, DWORD PTR [rbx+rsi*4]
$LN31@PyUnicode_@107:
  0011f	4d 8b 4c 24 60	 mov	 r9, QWORD PTR [r12+96]
  00124	45 33 c0	 xor	 r8d, r8d
  00127	49 8b cc	 mov	 rcx, r12
  0012a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00132	e8 00 00 00 00	 call	 PyUnicode_FindChar
  00137	48 85 c0	 test	 rax, rax
  0013a	78 08		 js	 SHORT $LN47@PyUnicode_@107

; 11739:             i++;

  0013c	48 ff c6	 inc	 rsi
  0013f	48 3b f7	 cmp	 rsi, rdi
  00142	7c 9c		 jl	 SHORT $LL8@PyUnicode_@107
$LN47@PyUnicode_@107:

; 11740:         }
; 11741:     }
; 11742: 
; 11743:     j = len;
; 11744:     if (striptype != LEFTSTRIP) {

  00144	45 85 f6	 test	 r14d, r14d
  00147	74 6e		 je	 SHORT $LN6@PyUnicode_@107
  00149	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@PyUnicode_@107:

; 11745:         do {
; 11746:             j--;

  00150	48 ff cf	 dec	 rdi

; 11747:         } while (j >= i &&
; 11748:                  BLOOM_MEMBER(sepmask, PyUnicode_READ(kind, data, j), sepobj));

  00153	48 3b fe	 cmp	 rdi, rsi
  00156	7c 5c		 jl	 SHORT $LN2@PyUnicode_@107
  00158	48 83 fd 01	 cmp	 rbp, 1
  0015c	75 06		 jne	 SHORT $LN36@PyUnicode_@107
  0015e	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  00162	eb 0f		 jmp	 SHORT $LN35@PyUnicode_@107
$LN36@PyUnicode_@107:
  00164	48 83 fd 02	 cmp	 rbp, 2
  00168	75 06		 jne	 SHORT $LN34@PyUnicode_@107
  0016a	0f b7 04 7b	 movzx	 eax, WORD PTR [rbx+rdi*2]
  0016e	eb 03		 jmp	 SHORT $LN35@PyUnicode_@107
$LN34@PyUnicode_@107:
  00170	8b 04 bb	 mov	 eax, DWORD PTR [rbx+rdi*4]
$LN35@PyUnicode_@107:
  00173	83 e0 1f	 and	 eax, 31
  00176	41 0f a3 c7	 bt	 r15d, eax
  0017a	73 38		 jae	 SHORT $LN2@PyUnicode_@107
  0017c	48 83 fd 01	 cmp	 rbp, 1
  00180	75 06		 jne	 SHORT $LN40@PyUnicode_@107
  00182	0f b6 14 1f	 movzx	 edx, BYTE PTR [rdi+rbx]
  00186	eb 0f		 jmp	 SHORT $LN39@PyUnicode_@107
$LN40@PyUnicode_@107:
  00188	48 83 fd 02	 cmp	 rbp, 2
  0018c	75 06		 jne	 SHORT $LN38@PyUnicode_@107
  0018e	0f b7 14 7b	 movzx	 edx, WORD PTR [rbx+rdi*2]
  00192	eb 03		 jmp	 SHORT $LN39@PyUnicode_@107
$LN38@PyUnicode_@107:
  00194	8b 14 bb	 mov	 edx, DWORD PTR [rbx+rdi*4]
$LN39@PyUnicode_@107:
  00197	4d 8b 4c 24 60	 mov	 r9, QWORD PTR [r12+96]
  0019c	45 33 c0	 xor	 r8d, r8d
  0019f	49 8b cc	 mov	 rcx, r12
  001a2	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  001aa	e8 00 00 00 00	 call	 PyUnicode_FindChar
  001af	48 85 c0	 test	 rax, rax
  001b2	79 9c		 jns	 SHORT $LL5@PyUnicode_@107
$LN2@PyUnicode_@107:

; 11749:         j++;

  001b4	48 ff c7	 inc	 rdi
$LN6@PyUnicode_@107:

; 11750:     }
; 11751: 
; 11752:     return PyUnicode_Substring(self, i, j);

  001b7	4c 8b c7	 mov	 r8, rdi
  001ba	48 8b d6	 mov	 rdx, rsi
  001bd	49 8b cd	 mov	 rcx, r13
  001c0	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]
  001c5	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  001ca	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  001cf	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  001d4	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 11753: }

  001d9	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001dd	41 5e		 pop	 r14
  001df	41 5d		 pop	 r13
  001e1	41 5c		 pop	 r12
  001e3	e9 00 00 00 00	 jmp	 PyUnicode_Substring
_PyUnicode_XStrip ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@KNBJIPGH@?$CFs?5arg?5must?5be?5None?5or?5str?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_argstrip DD imagerel do_argstrip
	DD	imagerel do_argstrip+180
	DD	imagerel $unwind$do_argstrip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_argstrip DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_0BL@KNBJIPGH@?$CFs?5arg?5must?5be?5None?5or?5str?$AA@
CONST	SEGMENT
??_C@_0BL@KNBJIPGH@?$CFs?5arg?5must?5be?5None?5or?5str?$AA@ DB '%s arg mu'
	DB	'st be None or str', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT do_argstrip
_TEXT	SEGMENT
self$ = 48
striptype$ = 56
args$ = 64
sep$ = 72
do_argstrip PROC					; COMDAT

; 11827: {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	49 8b c0	 mov	 rax, r8
  00017	48 63 da	 movsxd	 rbx, edx
  0001a	48 8b f9	 mov	 rdi, rcx

; 11828:     PyObject *sep = NULL;
; 11829: 
; 11830:     if (!PyArg_ParseTuple(args, (char *)stripformat[striptype], &sep))

  0001d	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:stripformat
  00024	4c 8d 44 24 48	 lea	 r8, QWORD PTR sep$[rsp]
  00029	48 8b c8	 mov	 rcx, rax
  0002c	48 8b 54 dd 00	 mov	 rdx, QWORD PTR [rbp+rbx*8]
  00031	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR sep$[rsp], 0
  0003a	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003f	85 c0		 test	 eax, eax

; 11831:         return NULL;

  00041	74 4e		 je	 SHORT $LN7@do_argstri

; 11832: 
; 11833:     if (sep != NULL && sep != Py_None) {

  00043	4c 8b 44 24 48	 mov	 r8, QWORD PTR sep$[rsp]
  00048	4d 85 c0	 test	 r8, r8
  0004b	74 48		 je	 SHORT $LN1@do_argstri
  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00054	4c 3b c0	 cmp	 r8, rax
  00057	74 3c		 je	 SHORT $LN1@do_argstri

; 11834:         if (PyUnicode_Check(sep))

  00059	49 8b 40 58	 mov	 rax, QWORD PTR [r8+88]
  0005d	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00067	74 0c		 je	 SHORT $LN2@do_argstri

; 11835:             return _PyUnicode_XStrip(self, striptype, sep);

  00069	8b d3		 mov	 edx, ebx
  0006b	48 8b cf	 mov	 rcx, rdi
  0006e	e8 00 00 00 00	 call	 _PyUnicode_XStrip
  00073	eb 2a		 jmp	 SHORT $LN5@do_argstri
$LN2@do_argstri:

; 11836:         else {
; 11837:             PyErr_Format(PyExc_TypeError,
; 11838:                          "%s arg must be None or str",
; 11839:                          STRIPNAME(striptype));

  00075	4c 8b 44 dd 00	 mov	 r8, QWORD PTR [rbp+rbx*8]
  0007a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@KNBJIPGH@?$CFs?5arg?5must?5be?5None?5or?5str?$AA@
  00088	49 83 c0 03	 add	 r8, 3
  0008c	e8 00 00 00 00	 call	 PyErr_Format
$LN7@do_argstri:

; 11840:             return NULL;

  00091	33 c0		 xor	 eax, eax
  00093	eb 0a		 jmp	 SHORT $LN5@do_argstri
$LN1@do_argstri:

; 11841:         }
; 11842:     }
; 11843: 
; 11844:     return do_strip(self, striptype);

  00095	8b d3		 mov	 edx, ebx
  00097	48 8b cf	 mov	 rcx, rdi
  0009a	e8 00 00 00 00	 call	 do_strip
$LN5@do_argstri:

; 11845: }

  0009f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a4	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000a9	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000ae	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b2	5f		 pop	 rdi
  000b3	c3		 ret	 0
do_argstrip ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT unicode_strip
_TEXT	SEGMENT
self$ = 8
args$ = 16
unicode_strip PROC					; COMDAT

; 11858:     if (PyTuple_GET_SIZE(args) == 0)

  00000	48 83 7a 60 00	 cmp	 QWORD PTR [rdx+96], 0
  00005	75 0a		 jne	 SHORT $LN2@unicode_st@2

; 11859:         return do_strip(self, BOTHSTRIP); /* Common case */

  00007	ba 02 00 00 00	 mov	 edx, 2

; 11862: }

  0000c	e9 00 00 00 00	 jmp	 do_strip
$LN2@unicode_st@2:

; 11860:     else
; 11861:         return do_argstrip(self, BOTHSTRIP, args);

  00011	4c 8b c2	 mov	 r8, rdx
  00014	ba 02 00 00 00	 mov	 edx, 2

; 11862: }

  00019	e9 00 00 00 00	 jmp	 do_argstrip
unicode_strip ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT unicode_lstrip
_TEXT	SEGMENT
self$ = 8
args$ = 16
unicode_lstrip PROC					; COMDAT

; 11874:     if (PyTuple_GET_SIZE(args) == 0)

  00000	48 83 7a 60 00	 cmp	 QWORD PTR [rdx+96], 0
  00005	75 07		 jne	 SHORT $LN2@unicode_ls

; 11875:         return do_strip(self, LEFTSTRIP); /* Common case */

  00007	33 d2		 xor	 edx, edx

; 11878: }

  00009	e9 00 00 00 00	 jmp	 do_strip
$LN2@unicode_ls:

; 11876:     else
; 11877:         return do_argstrip(self, LEFTSTRIP, args);

  0000e	4c 8b c2	 mov	 r8, rdx
  00011	33 d2		 xor	 edx, edx

; 11878: }

  00013	e9 00 00 00 00	 jmp	 do_argstrip
unicode_lstrip ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT unicode_rstrip
_TEXT	SEGMENT
self$ = 8
args$ = 16
unicode_rstrip PROC					; COMDAT

; 11890:     if (PyTuple_GET_SIZE(args) == 0)

  00000	48 83 7a 60 00	 cmp	 QWORD PTR [rdx+96], 0
  00005	75 0a		 jne	 SHORT $LN2@unicode_rs@2

; 11891:         return do_strip(self, RIGHTSTRIP); /* Common case */

  00007	ba 01 00 00 00	 mov	 edx, 1

; 11894: }

  0000c	e9 00 00 00 00	 jmp	 do_strip
$LN2@unicode_rs@2:

; 11892:     else
; 11893:         return do_argstrip(self, RIGHTSTRIP, args);

  00011	4c 8b c2	 mov	 r8, rdx
  00014	ba 01 00 00 00	 mov	 edx, 1

; 11894: }

  00019	e9 00 00 00 00	 jmp	 do_argstrip
unicode_rstrip ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$unicode_mod DD imagerel unicode_mod
	DD	imagerel unicode_mod+110
	DD	imagerel $unwind$unicode_mod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_mod DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
xdata	ENDS
;	COMDAT unicode_mod
_TEXT	SEGMENT
v$ = 64
w$ = 72
unicode_mod PROC					; COMDAT

; 13191: {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 13192:     if (!PyUnicode_Check(v))

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00012	75 51		 jne	 SHORT $LN1@unicode_mo@2

; 13193:         Py_RETURN_NOTIMPLEMENTED;

  00014	e8 00 00 00 00	 call	 _Py_PXCTX
  00019	85 c0		 test	 eax, eax
  0001b	75 3c		 jne	 SHORT $LN5@unicode_mo@2
  0001d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00032	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00038	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00040	e8 00 00 00 00	 call	 _PyParallel_Guard
  00045	85 c0		 test	 eax, eax
  00047	75 09		 jne	 SHORT $LN4@unicode_mo@2
  00049	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00050	74 07		 je	 SHORT $LN5@unicode_mo@2
$LN4@unicode_mo@2:
  00052	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN5@unicode_mo@2:
  00059	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 13194:     return PyUnicode_Format(v, w);
; 13195: }

  00060	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00064	c3		 ret	 0
$LN1@unicode_mo@2:
  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	e9 00 00 00 00	 jmp	 PyUnicode_Format
unicode_mod ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_InternFromString
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_InternFromString DD imagerel $LN5
	DD	imagerel $LN5+70
	DD	imagerel $unwind$PyUnicode_InternFromString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_InternFromString DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_InternFromString
_TEXT	SEGMENT
cp$ = 48
s$ = 56
PyUnicode_InternFromString PROC				; COMDAT

; 14446: {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 14447:     PyObject *s = NULL;
; 14448:     _PyParallel_EnableTLSHeap();

  00009	e8 00 00 00 00	 call	 _PyParallel_EnableTLSHeap

; 14449:     s = PyUnicode_FromString(cp);

  0000e	48 8b cb	 mov	 rcx, rbx
  00011	e8 00 00 00 00	 call	 PyUnicode_FromString
  00016	48 8b d8	 mov	 rbx, rax
  00019	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 14450:     _PyParallel_DisableTLSHeap();

  0001e	e8 00 00 00 00	 call	 _PyParallel_DisableTLSHeap

; 14451:     if (s == NULL)

  00023	48 85 db	 test	 rbx, rbx
  00026	74 15		 je	 SHORT $LN4@PyUnicode_@108

; 14452:         goto end;
; 14453:     PyUnicode_InternInPlace(&s);

  00028	48 8d 4c 24 38	 lea	 rcx, QWORD PTR s$[rsp]
  0002d	e8 00 00 00 00	 call	 PyUnicode_InternInPlace

; 14454: end:
; 14455:     return s;

  00032	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]

; 14456: }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
$LN4@PyUnicode_@108:

; 14454: end:
; 14455:     return s;

  0003d	48 8b c3	 mov	 rax, rbx
$end$144239:

; 14456: }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5b		 pop	 rbx
  00045	c3		 ret	 0
PyUnicode_InternFromString ENDP
_TEXT	ENDS
PUBLIC	??_C@_06MDAHGKGM@utf?932?$AA@			; `string'
PUBLIC	??_C@_06KEOPHLAG@utf?916?$AA@			; `string'
PUBLIC	??_C@_0L@CCLJNNOO@iso?98859?91?$AA@		; `string'
PUBLIC	??_C@_04LHHHFLPP@utf8?$AA@			; `string'
PUBLIC	PyUnicode_Decode
EXTRN	_PyCodec_DecodeText:PROC
EXTRN	PyMemoryView_FromBuffer:PROC
EXTRN	PyBuffer_FillInfo:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyUnicode_Decode DD imagerel $LN36
	DD	imagerel $LN36+674
	DD	imagerel $unwind$PyUnicode_Decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Decode DD 091701H
	DD	0166417H
	DD	0155417H
	DD	0143417H
	DD	0120117H
	DD	07010H
xdata	ENDS
;	COMDAT ??_C@_06MDAHGKGM@utf?932?$AA@
CONST	SEGMENT
??_C@_06MDAHGKGM@utf?932?$AA@ DB 'utf-32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KEOPHLAG@utf?916?$AA@
CONST	SEGMENT
??_C@_06KEOPHLAG@utf?916?$AA@ DB 'utf-16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CCLJNNOO@iso?98859?91?$AA@
CONST	SEGMENT
??_C@_0L@CCLJNNOO@iso?98859?91?$AA@ DB 'iso-8859-1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04LHHHFLPP@utf8?$AA@
CONST	SEGMENT
??_C@_04LHHHFLPP@utf8?$AA@ DB 'utf8', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT PyUnicode_Decode
_TEXT	SEGMENT
lower$ = 48
info$ = 64
s$ = 160
size$ = 168
encoding$ = 176
errors$ = 184
PyUnicode_Decode PROC					; COMDAT

; 3193 : {

$LN36:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00017	49 8b e8	 mov	 rbp, r8
  0001a	4c 8b d2	 mov	 r10, rdx
  0001d	4c 8b d9	 mov	 r11, rcx

; 3194 :     PyObject *buffer = NULL, *unicode;
; 3195 :     Py_buffer info;
; 3196 :     char lower[11];  /* Enough for any encoding shortcut */
; 3197 : 
; 3198 :     /* Shortcuts for common default encodings */
; 3199 :     if (_Py_normalize_encoding(encoding, lower, sizeof(lower))) {

  00020	48 8d 54 24 30	 lea	 rdx, QWORD PTR lower$[rsp]
  00025	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0002b	48 8b cd	 mov	 rcx, rbp
  0002e	49 8b d9	 mov	 rbx, r9
  00031	e8 00 00 00 00	 call	 _Py_normalize_encoding
  00036	85 c0		 test	 eax, eax
  00038	0f 84 4c 01 00
	00		 je	 $LN9@PyUnicode_@109

; 3200 :         if ((strcmp(lower, "utf-8") == 0) ||
; 3201 :             (strcmp(lower, "utf8") == 0))

  0003e	48 8d 74 24 30	 lea	 rsi, QWORD PTR lower$[rsp]
  00043	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  0004a	b9 06 00 00 00	 mov	 ecx, 6
  0004f	f3 a6		 repe cmpsb
  00051	0f 84 1d 01 00
	00		 je	 $LN20@PyUnicode_@109
  00057	48 8d 74 24 30	 lea	 rsi, QWORD PTR lower$[rsp]
  0005c	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_04LHHHFLPP@utf8?$AA@
  00063	b9 05 00 00 00	 mov	 ecx, 5
  00068	f3 a6		 repe cmpsb
  0006a	0f 84 04 01 00
	00		 je	 $LN20@PyUnicode_@109

; 3203 :         else if ((strcmp(lower, "latin-1") == 0) ||
; 3204 :                  (strcmp(lower, "latin1") == 0) ||
; 3205 :                  (strcmp(lower, "iso-8859-1") == 0))

  00070	48 8d 74 24 30	 lea	 rsi, QWORD PTR lower$[rsp]
  00075	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_07BJPINKOJ@latin?91?$AA@
  0007c	b9 08 00 00 00	 mov	 ecx, 8
  00081	f3 a6		 repe cmpsb
  00083	0f 84 d8 00 00
	00		 je	 $LN17@PyUnicode_@109
  00089	48 8d 74 24 30	 lea	 rsi, QWORD PTR lower$[rsp]
  0008e	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06CDEFMFPB@latin1?$AA@
  00095	b9 07 00 00 00	 mov	 ecx, 7
  0009a	f3 a6		 repe cmpsb
  0009c	0f 84 bf 00 00
	00		 je	 $LN17@PyUnicode_@109
  000a2	48 8d 74 24 30	 lea	 rsi, QWORD PTR lower$[rsp]
  000a7	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0L@CCLJNNOO@iso?98859?91?$AA@
  000ae	b9 0b 00 00 00	 mov	 ecx, 11
  000b3	f3 a6		 repe cmpsb
  000b5	0f 84 a6 00 00
	00		 je	 $LN17@PyUnicode_@109

; 3207 : #ifdef HAVE_MBCS
; 3208 :         else if (strcmp(lower, "mbcs") == 0)

  000bb	48 8d 74 24 30	 lea	 rsi, QWORD PTR lower$[rsp]
  000c0	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_04IHNDNLNK@mbcs?$AA@
  000c7	b9 05 00 00 00	 mov	 ecx, 5
  000cc	f3 a6		 repe cmpsb
  000ce	75 13		 jne	 SHORT $LN15@PyUnicode_@109

; 3209 :             return PyUnicode_DecodeMBCS(s, size, errors);

  000d0	4c 8b c3	 mov	 r8, rbx
  000d3	49 8b d2	 mov	 rdx, r10
  000d6	49 8b cb	 mov	 rcx, r11
  000d9	e8 00 00 00 00	 call	 PyUnicode_DecodeMBCS
  000de	e9 a6 01 00 00	 jmp	 $LN23@PyUnicode_@109
$LN15@PyUnicode_@109:

; 3210 : #endif
; 3211 :         else if (strcmp(lower, "ascii") == 0)

  000e3	48 8d 74 24 30	 lea	 rsi, QWORD PTR lower$[rsp]
  000e8	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_05OJENGABA@ascii?$AA@
  000ef	b9 06 00 00 00	 mov	 ecx, 6
  000f4	f3 a6		 repe cmpsb
  000f6	75 13		 jne	 SHORT $LN13@PyUnicode_@109

; 3212 :             return PyUnicode_DecodeASCII(s, size, errors);

  000f8	4c 8b c3	 mov	 r8, rbx
  000fb	49 8b d2	 mov	 rdx, r10
  000fe	49 8b cb	 mov	 rcx, r11
  00101	e8 00 00 00 00	 call	 PyUnicode_DecodeASCII
  00106	e9 7e 01 00 00	 jmp	 $LN23@PyUnicode_@109
$LN13@PyUnicode_@109:

; 3213 :         else if (strcmp(lower, "utf-16") == 0)

  0010b	48 8d 74 24 30	 lea	 rsi, QWORD PTR lower$[rsp]
  00110	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06KEOPHLAG@utf?916?$AA@
  00117	b9 07 00 00 00	 mov	 ecx, 7
  0011c	f3 a6		 repe cmpsb
  0011e	75 16		 jne	 SHORT $LN11@PyUnicode_@109

; 3214 :             return PyUnicode_DecodeUTF16(s, size, errors, 0);

  00120	45 33 c9	 xor	 r9d, r9d
  00123	4c 8b c3	 mov	 r8, rbx
  00126	49 8b d2	 mov	 rdx, r10
  00129	49 8b cb	 mov	 rcx, r11
  0012c	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF16
  00131	e9 53 01 00 00	 jmp	 $LN23@PyUnicode_@109
$LN11@PyUnicode_@109:

; 3215 :         else if (strcmp(lower, "utf-32") == 0)

  00136	48 8d 74 24 30	 lea	 rsi, QWORD PTR lower$[rsp]
  0013b	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06MDAHGKGM@utf?932?$AA@
  00142	b9 07 00 00 00	 mov	 ecx, 7
  00147	f3 a6		 repe cmpsb
  00149	75 3f		 jne	 SHORT $LN9@PyUnicode_@109

; 3216 :             return PyUnicode_DecodeUTF32(s, size, errors, 0);

  0014b	45 33 c9	 xor	 r9d, r9d
  0014e	4c 8b c3	 mov	 r8, rbx
  00151	49 8b d2	 mov	 rdx, r10
  00154	49 8b cb	 mov	 rcx, r11
  00157	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF32
  0015c	e9 28 01 00 00	 jmp	 $LN23@PyUnicode_@109
$LN17@PyUnicode_@109:

; 3206 :             return PyUnicode_DecodeLatin1(s, size, errors);

  00161	4c 8b c3	 mov	 r8, rbx
  00164	49 8b d2	 mov	 rdx, r10
  00167	49 8b cb	 mov	 rcx, r11
  0016a	e8 00 00 00 00	 call	 PyUnicode_DecodeLatin1
  0016f	e9 15 01 00 00	 jmp	 $LN23@PyUnicode_@109
$LN20@PyUnicode_@109:

; 3202 :             return PyUnicode_DecodeUTF8Stateful(s, size, errors, NULL);

  00174	45 33 c9	 xor	 r9d, r9d
  00177	4c 8b c3	 mov	 r8, rbx
  0017a	49 8b d2	 mov	 rdx, r10
  0017d	49 8b cb	 mov	 rcx, r11
  00180	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8Stateful
  00185	e9 ff 00 00 00	 jmp	 $LN23@PyUnicode_@109
$LN9@PyUnicode_@109:

; 3217 :     }
; 3218 : 
; 3219 :     /* Decode via the codec registry */
; 3220 :     buffer = NULL;
; 3221 :     if (PyBuffer_FillInfo(&info, NULL, (void *)s, size, 1, PyBUF_FULL_RO) < 0)

  0018a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR info$[rsp]
  0018f	4d 8b ca	 mov	 r9, r10
  00192	4d 8b c3	 mov	 r8, r11
  00195	33 d2		 xor	 edx, edx
  00197	c7 44 24 28 1c
	01 00 00	 mov	 DWORD PTR [rsp+40], 284	; 0000011cH
  0019f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  001a7	e8 00 00 00 00	 call	 PyBuffer_FillInfo
  001ac	85 c0		 test	 eax, eax
  001ae	0f 88 d3 00 00
	00		 js	 $LN3@PyUnicode_@109

; 3222 :         goto onError;
; 3223 :     buffer = PyMemoryView_FromBuffer(&info);

  001b4	48 8d 4c 24 40	 lea	 rcx, QWORD PTR info$[rsp]
  001b9	e8 00 00 00 00	 call	 PyMemoryView_FromBuffer
  001be	48 8b f8	 mov	 rdi, rax

; 3224 :     if (buffer == NULL)

  001c1	48 85 c0	 test	 rax, rax
  001c4	0f 84 bd 00 00
	00		 je	 $LN3@PyUnicode_@109

; 3225 :         goto onError;
; 3226 :     unicode = _PyCodec_DecodeText(buffer, encoding, errors);

  001ca	4c 8b c3	 mov	 r8, rbx
  001cd	48 8b d5	 mov	 rdx, rbp
  001d0	48 8b c8	 mov	 rcx, rax
  001d3	e8 00 00 00 00	 call	 _PyCodec_DecodeText
  001d8	48 8b f0	 mov	 rsi, rax

; 3227 :     if (unicode == NULL)

  001db	48 85 c0	 test	 rax, rax
  001de	74 30		 je	 SHORT $onError$128271

; 3228 :         goto onError;
; 3229 :     if (!PyUnicode_Check(unicode)) {

  001e0	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  001e4	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  001ef	75 70		 jne	 SHORT $LN5@PyUnicode_@109

; 3230 :         PyErr_Format(PyExc_TypeError,
; 3231 :                      "decoder did not return a str object (type=%.400s)",
; 3232 :                      Py_TYPE(unicode)->tp_name);

  001f1	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  001f5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@PNAMKIJE@decoder?5did?5not?5return?5a?5str?5obj@
  00203	e8 00 00 00 00	 call	 PyErr_Format

; 3233 :         Py_DECREF(unicode);

  00208	48 8b ce	 mov	 rcx, rsi
  0020b	e8 00 00 00 00	 call	 _Py_DecRef
$onError$128271:

; 3238 : 
; 3239 :   onError:
; 3240 :     Py_XDECREF(buffer);

  00210	e8 00 00 00 00	 call	 _Py_PXCTX
  00215	85 c0		 test	 eax, eax
  00217	75 6e		 jne	 SHORT $LN3@PyUnicode_@109
  00219	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0021d	a8 20		 test	 al, 32			; 00000020H
  0021f	75 5e		 jne	 SHORT $LN29@PyUnicode_@109
  00221	84 c0		 test	 al, al
  00223	78 5a		 js	 SHORT $LN29@PyUnicode_@109
  00225	a8 02		 test	 al, 2
  00227	75 5e		 jne	 SHORT $LN3@PyUnicode_@109
  00229	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0022d	75 58		 jne	 SHORT $LN3@PyUnicode_@109
  0022f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00236	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0023d	4c 8b cf	 mov	 r9, rdi
  00240	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00246	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0024e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00253	48 8b cf	 mov	 rcx, rdi
  00256	85 c0		 test	 eax, eax
  00258	74 19		 je	 SHORT $LN34@PyUnicode_@109
  0025a	e8 00 00 00 00	 call	 _Px_Dealloc
  0025f	eb 26		 jmp	 SHORT $LN3@PyUnicode_@109
$LN5@PyUnicode_@109:

; 3234 :         goto onError;
; 3235 :     }
; 3236 :     Py_DECREF(buffer);

  00261	48 8b cf	 mov	 rcx, rdi
  00264	e8 00 00 00 00	 call	 _Py_DecRef

; 3237 :     return unicode_result(unicode);

  00269	48 8b ce	 mov	 rcx, rsi
  0026c	e8 00 00 00 00	 call	 unicode_result
  00271	eb 16		 jmp	 SHORT $LN23@PyUnicode_@109

; 3238 : 
; 3239 :   onError:
; 3240 :     Py_XDECREF(buffer);

$LN34@PyUnicode_@109:
  00273	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00277	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0027d	eb 08		 jmp	 SHORT $LN3@PyUnicode_@109
$LN29@PyUnicode_@109:
  0027f	48 8b cf	 mov	 rcx, rdi
  00282	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PyUnicode_@109:

; 3241 :     return NULL;

  00287	33 c0		 xor	 eax, eax
$LN23@PyUnicode_@109:

; 3242 : }

  00289	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  00291	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00295	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  00299	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  0029d	49 8b e3	 mov	 rsp, r11
  002a0	5f		 pop	 rdi
  002a1	c3		 ret	 0
PyUnicode_Decode ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_EncodeFSDefault
; Function compile flags: /Ogtpy
;	COMDAT PyUnicode_EncodeFSDefault
_TEXT	SEGMENT
unicode$ = 8
PyUnicode_EncodeFSDefault PROC				; COMDAT

; 3524 : #ifdef HAVE_MBCS
; 3525 :     return PyUnicode_EncodeCodePage(CP_ACP, unicode, NULL);

  00000	48 8b d1	 mov	 rdx, rcx
  00003	45 33 c0	 xor	 r8d, r8d
  00006	33 c9		 xor	 ecx, ecx

; 3526 : #elif defined(__APPLE__)
; 3527 :     return _PyUnicode_AsUTF8String(unicode, "surrogateescape");
; 3528 : #else
; 3529 :     PyInterpreterState *interp = PyThreadState_GET()->interp;
; 3530 :     /* Bootstrap check: if the filesystem codec is implemented in Python, we
; 3531 :        cannot use it to encode and decode filenames before it is loaded. Load
; 3532 :        the Python codec requires to encode at least its own filename. Use the C
; 3533 :        version of the locale codec until the codec registry is initialized and
; 3534 :        the Python codec is loaded.
; 3535 : 
; 3536 :        Py_FileSystemDefaultEncoding is shared between all interpreters, we
; 3537 :        cannot only rely on it: check also interp->fscodec_initialized for
; 3538 :        subinterpreters. */
; 3539 :     if (Py_FileSystemDefaultEncoding && interp->fscodec_initialized) {
; 3540 :         return PyUnicode_AsEncodedString(unicode,
; 3541 :                                          Py_FileSystemDefaultEncoding,
; 3542 :                                          "surrogateescape");
; 3543 :     }
; 3544 :     else {
; 3545 :         return PyUnicode_EncodeLocale(unicode, "surrogateescape");
; 3546 :     }
; 3547 : #endif
; 3548 : }

  00008	e9 00 00 00 00	 jmp	 PyUnicode_EncodeCodePage
PyUnicode_EncodeFSDefault ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@CJABAFNJ@encoder?5?$CFs?5returned?5bytearray?5in@ ; `string'
PUBLIC	??_C@_0DE@GBKIGCGF@encoder?5did?5not?5return?5a?5bytes?5o@ ; `string'
PUBLIC	PyUnicode_AsEncodedString
EXTRN	_PyByteArray_empty_string:BYTE
EXTRN	PyErr_WarnFormat:PROC
EXTRN	PyExc_RuntimeWarning:QWORD
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyByteArray_Type:BYTE
EXTRN	_PyCodec_EncodeText:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_AsEncodedString DD imagerel $LN28
	DD	imagerel $LN28+58
	DD	imagerel $unwind$PyUnicode_AsEncodedString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyUnicode_AsEncodedString DD imagerel $LN28+58
	DD	imagerel $LN28+247
	DD	imagerel $chain$1$PyUnicode_AsEncodedString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyUnicode_AsEncodedString DD imagerel $LN28+247
	DD	imagerel $LN28+294
	DD	imagerel $chain$3$PyUnicode_AsEncodedString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyUnicode_AsEncodedString DD imagerel $LN28+294
	DD	imagerel $LN28+320
	DD	imagerel $chain$5$PyUnicode_AsEncodedString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$PyUnicode_AsEncodedString DD imagerel $LN28+320
	DD	imagerel $LN28+370
	DD	imagerel $chain$7$PyUnicode_AsEncodedString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$PyUnicode_AsEncodedString DD imagerel $LN28+370
	DD	imagerel $LN28+395
	DD	imagerel $chain$9$PyUnicode_AsEncodedString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$PyUnicode_AsEncodedString DD imagerel $LN28+395
	DD	imagerel $LN28+511
	DD	imagerel $chain$11$PyUnicode_AsEncodedString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$PyUnicode_AsEncodedString DD imagerel $LN28+511
	DD	imagerel $LN28+602
	DD	imagerel $chain$13$PyUnicode_AsEncodedString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$PyUnicode_AsEncodedString DD 040021H
	DD	097400H
	DD	086400H
	DD	imagerel $LN28
	DD	imagerel $LN28+58
	DD	imagerel $unwind$PyUnicode_AsEncodedString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$PyUnicode_AsEncodedString DD 040021H
	DD	097400H
	DD	086400H
	DD	imagerel $LN28
	DD	imagerel $LN28+58
	DD	imagerel $unwind$PyUnicode_AsEncodedString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$PyUnicode_AsEncodedString DD 040021H
	DD	097400H
	DD	086400H
	DD	imagerel $LN28
	DD	imagerel $LN28+58
	DD	imagerel $unwind$PyUnicode_AsEncodedString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$PyUnicode_AsEncodedString DD 040021H
	DD	097400H
	DD	086400H
	DD	imagerel $LN28
	DD	imagerel $LN28+58
	DD	imagerel $unwind$PyUnicode_AsEncodedString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyUnicode_AsEncodedString DD 040021H
	DD	097400H
	DD	086400H
	DD	imagerel $LN28
	DD	imagerel $LN28+58
	DD	imagerel $unwind$PyUnicode_AsEncodedString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyUnicode_AsEncodedString DD 040021H
	DD	097400H
	DD	086400H
	DD	imagerel $LN28
	DD	imagerel $LN28+58
	DD	imagerel $unwind$PyUnicode_AsEncodedString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyUnicode_AsEncodedString DD 040a21H
	DD	09740aH
	DD	086405H
	DD	imagerel $LN28
	DD	imagerel $LN28+58
	DD	imagerel $unwind$PyUnicode_AsEncodedString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_AsEncodedString DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0CP@CJABAFNJ@encoder?5?$CFs?5returned?5bytearray?5in@
CONST	SEGMENT
??_C@_0CP@CJABAFNJ@encoder?5?$CFs?5returned?5bytearray?5in@ DB 'encoder %'
	DB	's returned bytearray instead of bytes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@GBKIGCGF@encoder?5did?5not?5return?5a?5bytes?5o@
CONST	SEGMENT
??_C@_0DE@GBKIGCGF@encoder?5did?5not?5return?5a?5bytes?5o@ DB 'encoder di'
	DB	'd not return a bytes object (type=%.400s)', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_AsEncodedString
_TEXT	SEGMENT
lower$ = 32
unicode$ = 64
encoding$ = 72
errors$ = 80
PyUnicode_AsEncodedString PROC				; COMDAT

; 3554 : {

$LN28:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3555 :     PyObject *v;
; 3556 :     char lower[11];  /* Enough for any encoding shortcut */
; 3557 : 
; 3558 :     if (!PyUnicode_Check(unicode)) {

  00006	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000a	4d 8b d0	 mov	 r10, r8
  0000d	48 8b da	 mov	 rbx, rdx
  00010	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0001a	4c 8b d9	 mov	 r11, rcx
  0001d	75 0d		 jne	 SHORT $LN19@PyUnicode_@110

; 3559 :         PyErr_BadArgument();

  0001f	e8 00 00 00 00	 call	 PyErr_BadArgument

; 3560 :         return NULL;

  00024	33 c0		 xor	 eax, eax

; 3617 : }

  00026	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
$LN19@PyUnicode_@110:

; 3561 :     }
; 3562 : 
; 3563 :     /* Shortcuts for common default encodings */
; 3564 :     if (_Py_normalize_encoding(encoding, lower, sizeof(lower))) {

  0002c	48 8d 54 24 20	 lea	 rdx, QWORD PTR lower$[rsp]
  00031	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00037	48 8b cb	 mov	 rcx, rbx
  0003a	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0003f	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00044	e8 00 00 00 00	 call	 _Py_normalize_encoding
  00049	85 c0		 test	 eax, eax
  0004b	0f 84 3a 01 00
	00		 je	 $LN6@PyUnicode_@110

; 3565 :         if ((strcmp(lower, "utf-8") == 0) ||
; 3566 :             (strcmp(lower, "utf8") == 0))

  00051	48 8d 74 24 20	 lea	 rsi, QWORD PTR lower$[rsp]
  00056	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  0005d	b9 06 00 00 00	 mov	 ecx, 6
  00062	f3 a6		 repe cmpsb
  00064	0f 84 d6 00 00
	00		 je	 $LN16@PyUnicode_@110
  0006a	48 8d 74 24 20	 lea	 rsi, QWORD PTR lower$[rsp]
  0006f	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_04LHHHFLPP@utf8?$AA@
  00076	b9 05 00 00 00	 mov	 ecx, 5
  0007b	f3 a6		 repe cmpsb
  0007d	0f 84 bd 00 00
	00		 je	 $LN16@PyUnicode_@110

; 3572 :         }
; 3573 :         else if ((strcmp(lower, "latin-1") == 0) ||
; 3574 :                  (strcmp(lower, "latin1") == 0) ||
; 3575 :                  (strcmp(lower, "iso-8859-1") == 0))

  00083	48 8d 74 24 20	 lea	 rsi, QWORD PTR lower$[rsp]
  00088	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_07BJPINKOJ@latin?91?$AA@
  0008f	b9 08 00 00 00	 mov	 ecx, 8
  00094	f3 a6		 repe cmpsb
  00096	0f 84 8a 00 00
	00		 je	 $LN10@PyUnicode_@110
  0009c	48 8d 74 24 20	 lea	 rsi, QWORD PTR lower$[rsp]
  000a1	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06CDEFMFPB@latin1?$AA@
  000a8	b9 07 00 00 00	 mov	 ecx, 7
  000ad	f3 a6		 repe cmpsb
  000af	74 75		 je	 SHORT $LN10@PyUnicode_@110
  000b1	48 8d 74 24 20	 lea	 rsi, QWORD PTR lower$[rsp]
  000b6	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0L@CCLJNNOO@iso?98859?91?$AA@
  000bd	b9 0b 00 00 00	 mov	 ecx, 11
  000c2	f3 a6		 repe cmpsb
  000c4	74 60		 je	 SHORT $LN10@PyUnicode_@110

; 3577 : #ifdef HAVE_MBCS
; 3578 :         else if (strcmp(lower, "mbcs") == 0)

  000c6	48 8d 74 24 20	 lea	 rsi, QWORD PTR lower$[rsp]
  000cb	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_04IHNDNLNK@mbcs?$AA@
  000d2	b9 05 00 00 00	 mov	 ecx, 5
  000d7	f3 a6		 repe cmpsb
  000d9	75 1c		 jne	 SHORT $LN8@PyUnicode_@110

; 3579 :             return PyUnicode_EncodeCodePage(CP_ACP, unicode, errors);

  000db	4d 8b c2	 mov	 r8, r10
  000de	49 8b d3	 mov	 rdx, r11
  000e1	33 c9		 xor	 ecx, ecx
  000e3	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000e8	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 3617 : }

  000ed	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f1	5b		 pop	 rbx
  000f2	e9 00 00 00 00	 jmp	 PyUnicode_EncodeCodePage
$LN8@PyUnicode_@110:

; 3580 : #endif
; 3581 :         else if (strcmp(lower, "ascii") == 0)

  000f7	48 8d 74 24 20	 lea	 rsi, QWORD PTR lower$[rsp]
  000fc	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_05OJENGABA@ascii?$AA@
  00103	b9 06 00 00 00	 mov	 ecx, 6
  00108	f3 a6		 repe cmpsb
  0010a	75 7f		 jne	 SHORT $LN6@PyUnicode_@110

; 3582 :             return _PyUnicode_AsASCIIString(unicode, errors);

  0010c	49 8b d2	 mov	 rdx, r10
  0010f	49 8b cb	 mov	 rcx, r11
  00112	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00117	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 3617 : }

  0011c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00120	5b		 pop	 rbx
  00121	e9 00 00 00 00	 jmp	 _PyUnicode_AsASCIIString
$LN10@PyUnicode_@110:

; 3576 :             return _PyUnicode_AsLatin1String(unicode, errors);

  00126	49 8b d2	 mov	 rdx, r10
  00129	49 8b cb	 mov	 rcx, r11
  0012c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00131	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 3617 : }

  00136	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0013a	5b		 pop	 rbx
  0013b	e9 00 00 00 00	 jmp	 _PyUnicode_AsLatin1String
$LN16@PyUnicode_@110:

; 3567 :         {
; 3568 :             if (errors == NULL || strcmp(errors, "strict") == 0)

  00140	4d 85 d2	 test	 r10, r10
  00143	74 2d		 je	 SHORT $LN14@PyUnicode_@110
  00145	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  0014c	49 8b f2	 mov	 rsi, r10
  0014f	b9 07 00 00 00	 mov	 ecx, 7
  00154	f3 a6		 repe cmpsb
  00156	74 1a		 je	 SHORT $LN14@PyUnicode_@110

; 3570 :             else
; 3571 :                 return _PyUnicode_AsUTF8String(unicode, errors);

  00158	49 8b d2	 mov	 rdx, r10
  0015b	49 8b cb	 mov	 rcx, r11
  0015e	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00163	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 3617 : }

  00168	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0016c	5b		 pop	 rbx
  0016d	e9 00 00 00 00	 jmp	 _PyUnicode_AsUTF8String
$LN14@PyUnicode_@110:

; 3569 :                 return _PyUnicode_AsUTF8String(unicode, NULL);

  00172	33 d2		 xor	 edx, edx
  00174	49 8b cb	 mov	 rcx, r11
  00177	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0017c	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 3617 : }

  00181	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00185	5b		 pop	 rbx
  00186	e9 00 00 00 00	 jmp	 _PyUnicode_AsUTF8String
$LN6@PyUnicode_@110:

; 3583 :     }
; 3584 : 
; 3585 :     /* Encode via the codec registry */
; 3586 :     v = _PyCodec_EncodeText(unicode, encoding, errors);

  0018b	4d 8b c2	 mov	 r8, r10
  0018e	48 8b d3	 mov	 rdx, rbx
  00191	49 8b cb	 mov	 rcx, r11
  00194	e8 00 00 00 00	 call	 _PyCodec_EncodeText
  00199	48 8b f0	 mov	 rsi, rax

; 3587 :     if (v == NULL)

  0019c	48 85 c0	 test	 rax, rax

; 3588 :         return NULL;

  0019f	74 4c		 je	 SHORT $LN27@PyUnicode_@110

; 3589 : 
; 3590 :     /* The normal path */
; 3591 :     if (PyBytes_Check(v))

  001a1	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  001a5	f7 81 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rcx+256], 134217728 ; 08000000H

; 3592 :         return v;

  001af	0f 85 95 00 00
	00		 jne	 $LN25@PyUnicode_@110

; 3593 : 
; 3594 :     /* If the codec returns a buffer, raise a warning and convert to bytes */
; 3595 :     if (PyByteArray_Check(v)) {

  001b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  001bc	48 3b ca	 cmp	 rcx, rdx
  001bf	74 3e		 je	 SHORT $LN2@PyUnicode_@110
  001c1	e8 00 00 00 00	 call	 PyType_IsSubtype
  001c6	85 c0		 test	 eax, eax
  001c8	75 35		 jne	 SHORT $LN2@PyUnicode_@110

; 3610 :     }
; 3611 : 
; 3612 :     PyErr_Format(PyExc_TypeError,
; 3613 :                  "encoder did not return a bytes object (type=%.400s)",
; 3614 :                  Py_TYPE(v)->tp_name);

  001ca	4c 8b 46 58	 mov	 r8, QWORD PTR [rsi+88]
  001ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@GBKIGCGF@encoder?5did?5not?5return?5a?5bytes?5o@
  001dc	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  001e0	e8 00 00 00 00	 call	 PyErr_Format
$LN26@PyUnicode_@110:

; 3615 :     Py_DECREF(v);

  001e5	48 8b ce	 mov	 rcx, rsi
  001e8	e8 00 00 00 00	 call	 _Py_DecRef
$LN27@PyUnicode_@110:

; 3616 :     return NULL;

  001ed	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  001f2	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  001f7	33 c0		 xor	 eax, eax

; 3617 : }

  001f9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001fd	5b		 pop	 rbx
  001fe	c3		 ret	 0
$LN2@PyUnicode_@110:

; 3596 :         int error;
; 3597 :         PyObject *b;
; 3598 : 
; 3599 :         error = PyErr_WarnFormat(PyExc_RuntimeWarning, 1,
; 3600 :             "encoder %s returned bytearray instead of bytes",
; 3601 :             encoding);

  001ff	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeWarning
  00206	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CP@CJABAFNJ@encoder?5?$CFs?5returned?5bytearray?5in@
  0020d	4c 8b cb	 mov	 r9, rbx
  00210	ba 01 00 00 00	 mov	 edx, 1
  00215	e8 00 00 00 00	 call	 PyErr_WarnFormat

; 3602 :         if (error) {

  0021a	85 c0		 test	 eax, eax

; 3603 :             Py_DECREF(v);
; 3604 :             return NULL;

  0021c	75 c7		 jne	 SHORT $LN26@PyUnicode_@110

; 3605 :         }
; 3606 : 
; 3607 :         b = PyBytes_FromStringAndSize(PyByteArray_AS_STRING(v), Py_SIZE(v));

  0021e	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]
  00222	48 85 d2	 test	 rdx, rdx
  00225	74 09		 je	 SHORT $LN22@PyUnicode_@110
  00227	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  0022e	eb 07		 jmp	 SHORT $LN23@PyUnicode_@110
$LN22@PyUnicode_@110:
  00230	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string
$LN23@PyUnicode_@110:
  00237	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 3608 :         Py_DECREF(v);

  0023c	48 8b ce	 mov	 rcx, rsi
  0023f	48 8b f8	 mov	 rdi, rax
  00242	e8 00 00 00 00	 call	 _Py_DecRef

; 3609 :         return b;

  00247	48 8b c7	 mov	 rax, rdi
$LN25@PyUnicode_@110:
  0024a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0024f	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 3617 : }

  00254	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00258	5b		 pop	 rbx
  00259	c3		 ret	 0
PyUnicode_AsEncodedString ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_DecodeFSDefault
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_DecodeFSDefault DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$PyUnicode_DecodeFSDefault
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_DecodeFSDefault DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_DecodeFSDefault
_TEXT	SEGMENT
s$ = 48
PyUnicode_DecodeFSDefault PROC				; COMDAT

; 3796 : PyUnicode_DecodeFSDefault(const char *s) {

$LN3:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4c 8b c1	 mov	 r8, rcx

; 3797 :     Py_ssize_t size = (Py_ssize_t)strlen(s);

  00009	48 83 c9 ff	 or	 rcx, -1
  0000d	33 c0		 xor	 eax, eax
  0000f	49 8b f8	 mov	 rdi, r8
  00012	f2 ae		 repne scasb
  00014	48 f7 d1	 not	 rcx

; 3798 :     return PyUnicode_DecodeFSDefaultAndSize(s, size);

  00017	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  0001b	49 8b c8	 mov	 rcx, r8

; 3799 : }

  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5f		 pop	 rdi
  00023	e9 00 00 00 00	 jmp	 PyUnicode_DecodeFSDefaultAndSize
PyUnicode_DecodeFSDefault ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@FCKLEIDG@encoder?5failed?5to?5return?5bytes?$AA@ ; `string'
PUBLIC	PyUnicode_FSConverter
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyUnicode_FSConverter DD imagerel $LN16
	DD	imagerel $LN16+47
	DD	imagerel $unwind$PyUnicode_FSConverter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyUnicode_FSConverter DD imagerel $LN16+47
	DD	imagerel $LN16+200
	DD	imagerel $chain$0$PyUnicode_FSConverter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyUnicode_FSConverter DD imagerel $LN16+200
	DD	imagerel $LN16+298
	DD	imagerel $chain$2$PyUnicode_FSConverter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyUnicode_FSConverter DD imagerel $LN16+298
	DD	imagerel $LN16+322
	DD	imagerel $chain$4$PyUnicode_FSConverter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyUnicode_FSConverter DD 020021H
	DD	087400H
	DD	imagerel $LN16
	DD	imagerel $LN16+47
	DD	imagerel $unwind$PyUnicode_FSConverter
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyUnicode_FSConverter DD 020021H
	DD	087400H
	DD	imagerel $LN16
	DD	imagerel $LN16+47
	DD	imagerel $unwind$PyUnicode_FSConverter
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyUnicode_FSConverter DD 020521H
	DD	087405H
	DD	imagerel $LN16
	DD	imagerel $LN16+47
	DD	imagerel $unwind$PyUnicode_FSConverter
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_FSConverter DD 040a01H
	DD	09340aH
	DD	06006520aH
xdata	ENDS
;	COMDAT ??_C@_0BP@FCKLEIDG@encoder?5failed?5to?5return?5bytes?$AA@
CONST	SEGMENT
??_C@_0BP@FCKLEIDG@encoder?5failed?5to?5return?5bytes?$AA@ DB 'encoder fa'
	DB	'iled to return bytes', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\unicodeobject.c
CONST	ENDS
;	COMDAT PyUnicode_FSConverter
_TEXT	SEGMENT
arg$ = 64
addr$ = 72
PyUnicode_FSConverter PROC				; COMDAT

; 3846 : {

$LN16:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f2	 mov	 rsi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 3847 :     PyObject *output = NULL;
; 3848 :     Py_ssize_t size;
; 3849 :     void *data;
; 3850 :     if (arg == NULL) {

  00010	48 85 c9	 test	 rcx, rcx
  00013	75 16		 jne	 SHORT $LN7@PyUnicode_@111

; 3851 :         Py_DECREF(*(PyObject**)addr);

  00015	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00018	e8 00 00 00 00	 call	 _Py_DecRef

; 3852 :         return 1;

  0001d	8d 43 01	 lea	 eax, QWORD PTR [rbx+1]

; 3880 :     return Py_CLEANUP_SUPPORTED;
; 3881 : }

  00020	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00025	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00029	5e		 pop	 rsi
  0002a	c3		 ret	 0
$LN7@PyUnicode_@111:

; 3853 :     }
; 3854 :     if (PyBytes_Check(arg)) {

  0002b	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0002f	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00034	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  0003e	0f 84 84 00 00
	00		 je	 $LN6@PyUnicode_@111

; 3855 :         output = arg;
; 3856 :         Py_INCREF(output);

  00044	e8 00 00 00 00	 call	 _Py_PXCTX
  00049	85 c0		 test	 eax, eax
  0004b	75 32		 jne	 SHORT $LN2@PyUnicode_@111
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0005b	4c 8b cb	 mov	 r9, rbx
  0005e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00064	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0006c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00071	85 c0		 test	 eax, eax
  00073	75 06		 jne	 SHORT $LN10@PyUnicode_@111
  00075	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00079	74 04		 je	 SHORT $LN2@PyUnicode_@111
$LN10@PyUnicode_@111:
  0007b	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@PyUnicode_@111:

; 3870 :         }
; 3871 :     }
; 3872 :     size = PyBytes_GET_SIZE(output);
; 3873 :     data = PyBytes_AS_STRING(output);
; 3874 :     if (size != strlen(data)) {

  0007f	48 83 c9 ff	 or	 rcx, -1
  00083	33 c0		 xor	 eax, eax
  00085	48 8d 7b 78	 lea	 rdi, QWORD PTR [rbx+120]
  00089	f2 ae		 repne scasb
  0008b	48 f7 d1	 not	 rcx
  0008e	48 ff c9	 dec	 rcx
  00091	48 39 4b 60	 cmp	 QWORD PTR [rbx+96], rcx
  00095	0f 84 8f 00 00
	00		 je	 $LN1@PyUnicode_@111

; 3875 :         PyErr_SetString(PyExc_TypeError, "embedded NUL character");

  0009b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@JDIDDKBJ@embedded?5NUL?5character?$AA@
  000a9	e8 00 00 00 00	 call	 PyErr_SetString

; 3876 :         Py_DECREF(output);

  000ae	48 8b cb	 mov	 rcx, rbx
  000b1	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@PyUnicode_@111:

; 3877 :         return 0;

  000b6	33 c0		 xor	 eax, eax
  000b8	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 3880 :     return Py_CLEANUP_SUPPORTED;
; 3881 : }

  000bd	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000c2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c6	5e		 pop	 rsi
  000c7	c3		 ret	 0
$LN6@PyUnicode_@111:

; 3857 :     }
; 3858 :     else {
; 3859 :         arg = PyUnicode_FromObject(arg);

  000c8	e8 00 00 00 00	 call	 PyUnicode_FromObject
  000cd	48 8b f8	 mov	 rdi, rax

; 3860 :         if (!arg)

  000d0	48 85 c0	 test	 rax, rax

; 3861 :             return 0;

  000d3	74 e1		 je	 SHORT $LN15@PyUnicode_@111

; 3862 :         output = PyUnicode_EncodeFSDefault(arg);

  000d5	48 8b c8	 mov	 rcx, rax
  000d8	e8 00 00 00 00	 call	 PyUnicode_EncodeFSDefault

; 3863 :         Py_DECREF(arg);

  000dd	48 8b cf	 mov	 rcx, rdi
  000e0	48 8b d8	 mov	 rbx, rax
  000e3	e8 00 00 00 00	 call	 _Py_DecRef

; 3864 :         if (!output)

  000e8	48 85 db	 test	 rbx, rbx

; 3865 :             return 0;

  000eb	74 c9		 je	 SHORT $LN15@PyUnicode_@111

; 3866 :         if (!PyBytes_Check(output)) {

  000ed	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000f1	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  000fb	75 82		 jne	 SHORT $LN2@PyUnicode_@111

; 3867 :             Py_DECREF(output);

  000fd	48 8b cb	 mov	 rcx, rbx
  00100	e8 00 00 00 00	 call	 _Py_DecRef

; 3868 :             PyErr_SetString(PyExc_TypeError, "encoder failed to return bytes");

  00105	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@FCKLEIDG@encoder?5failed?5to?5return?5bytes?$AA@
  00113	e8 00 00 00 00	 call	 PyErr_SetString
  00118	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 3869 :             return 0;

  0011d	33 c0		 xor	 eax, eax

; 3880 :     return Py_CLEANUP_SUPPORTED;
; 3881 : }

  0011f	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00124	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00128	5e		 pop	 rsi
  00129	c3		 ret	 0
$LN1@PyUnicode_@111:
  0012a	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 3878 :     }
; 3879 :     *(PyObject**)addr = output;

  0012f	48 89 1e	 mov	 QWORD PTR [rsi], rbx

; 3880 :     return Py_CLEANUP_SUPPORTED;
; 3881 : }

  00132	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00137	b8 00 00 02 00	 mov	 eax, 131072		; 00020000H
  0013c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00140	5e		 pop	 rsi
  00141	c3		 ret	 0
PyUnicode_FSConverter ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@KBOOBLKH@?$HMss?3encode?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_encode DD imagerel unicode_encode
	DD	imagerel unicode_encode+108
	DD	imagerel $unwind$unicode_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_encode DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT ??_C@_0L@KBOOBLKH@?$HMss?3encode?$AA@
CONST	SEGMENT
??_C@_0L@KBOOBLKH@?$HMss?3encode?$AA@ DB '|ss:encode', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_encode
_TEXT	SEGMENT
encoding$ = 48
self$ = 80
args$ = 88
kwargs$ = 96
errors$ = 104
unicode_encode PROC					; COMDAT

; 10946: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8b d9	 mov	 rbx, rcx

; 10947:     static char *kwlist[] = {"encoding", "errors", 0};
; 10948:     char *encoding = NULL;

  00009	33 c9		 xor	 ecx, ecx
  0000b	49 8b c0	 mov	 rax, r8
  0000e	48 89 4c 24 30	 mov	 QWORD PTR encoding$[rsp], rcx

; 10949:     char *errors = NULL;

  00013	48 89 4c 24 68	 mov	 QWORD PTR errors$[rsp], rcx
  00018	4c 8b d2	 mov	 r10, rdx

; 10950: 
; 10951:     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|ss:encode",
; 10952:                                      kwlist, &encoding, &errors))

  0001b	48 8d 4c 24 68	 lea	 rcx, QWORD PTR errors$[rsp]
  00020	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??unicode_encode@@9@9
  00027	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@KBOOBLKH@?$HMss?3encode?$AA@
  0002e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00033	48 8d 4c 24 30	 lea	 rcx, QWORD PTR encoding$[rsp]
  00038	48 8b d0	 mov	 rdx, rax
  0003b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00040	49 8b ca	 mov	 rcx, r10
  00043	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00048	85 c0		 test	 eax, eax
  0004a	75 08		 jne	 SHORT $LN1@unicode_en@4

; 10953:         return NULL;

  0004c	33 c0		 xor	 eax, eax

; 10955: }

  0004e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00052	5b		 pop	 rbx
  00053	c3		 ret	 0
$LN1@unicode_en@4:

; 10954:     return PyUnicode_AsEncodedString(self, encoding, errors);

  00054	4c 8b 44 24 68	 mov	 r8, QWORD PTR errors$[rsp]
  00059	48 8b 54 24 30	 mov	 rdx, QWORD PTR encoding$[rsp]
  0005e	48 8b cb	 mov	 rcx, rbx
  00061	e8 00 00 00 00	 call	 PyUnicode_AsEncodedString

; 10955: }

  00066	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0006a	5b		 pop	 rbx
  0006b	c3		 ret	 0
unicode_encode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EK@HBIOHOLB@coercing?5to?5str?3?5need?5bytes?0?5byt@ ; `string'
PUBLIC	??_C@_0BO@ICIOAMLP@decoding?5str?5is?5not?5supported?$AA@ ; `string'
PUBLIC	PyUnicode_FromEncodedObject
EXTRN	PyBuffer_Release:PROC
EXTRN	PyObject_GetBuffer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_FromEncodedObject DD imagerel $LN29
	DD	imagerel $LN29+436
	DD	imagerel $unwind$PyUnicode_FromEncodedObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_FromEncodedObject DD 060f01H
	DD	011640fH
	DD	010340fH
	DD	0700bd20fH
xdata	ENDS
;	COMDAT ??_C@_0EK@HBIOHOLB@coercing?5to?5str?3?5need?5bytes?0?5byt@
CONST	SEGMENT
??_C@_0EK@HBIOHOLB@coercing?5to?5str?3?5need?5bytes?0?5byt@ DB 'coercing '
	DB	'to str: need bytes, bytearray or buffer-like object, %.80s fo'
	DB	'und', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ICIOAMLP@decoding?5str?5is?5not?5supported?$AA@
CONST	SEGMENT
??_C@_0BO@ICIOAMLP@decoding?5str?5is?5not?5supported?$AA@ DB 'decoding st'
	DB	'r is not supported', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyUnicode_FromEncodedObject
_TEXT	SEGMENT
buffer$ = 32
obj$ = 128
encoding$ = 136
errors$ = 144
PyUnicode_FromEncodedObject PROC			; COMDAT

; 3107 : {

$LN29:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 3108 :     Py_buffer buffer;
; 3109 :     PyObject *v;
; 3110 : 
; 3111 :     if (obj == NULL) {

  00018	48 85 c9	 test	 rcx, rcx
  0001b	75 25		 jne	 SHORT $LN24@PyUnicode_@112

; 3112 :         PyErr_BadInternalCall();

  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@DJKJDODG@?4?4?2Objects?2unicodeobject?4c?$AA@
  00024	ba 28 0c 00 00	 mov	 edx, 3112		; 00000c28H
  00029	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 3113 :         return NULL;

  0002e	33 c0		 xor	 eax, eax

; 3149 : }

  00030	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  00035	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00039	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  0003d	49 8b e3	 mov	 rsp, r11
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
$LN24@PyUnicode_@112:

; 3114 :     }
; 3115 : 
; 3116 :     /* Decoding bytes objects is the most common case and should be fast */
; 3117 :     if (PyBytes_Check(obj)) {

  00042	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00046	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  0004c	0f ba e1 1b	 bt	 ecx, 27
  00050	73 6c		 jae	 SHORT $LN23@PyUnicode_@112

; 3118 :         if (PyBytes_GET_SIZE(obj) == 0)

  00052	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  00056	48 85 d2	 test	 rdx, rdx
  00059	75 42		 jne	 SHORT $LN19@PyUnicode_@112

; 3119 :             _Py_RETURN_UNICODE_EMPTY();

  0005b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  00062	48 85 c9	 test	 rcx, rcx
  00065	75 18		 jne	 SHORT $LN27@PyUnicode_@112
  00067	e8 00 00 00 00	 call	 PyUnicode_New
  0006c	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  00073	48 85 c0	 test	 rax, rax
  00076	0f 84 26 01 00
	00		 je	 $LN25@PyUnicode_@112
  0007c	48 8b c8	 mov	 rcx, rax
$LN27@PyUnicode_@112:
  0007f	e8 00 00 00 00	 call	 _Py_IncRef
  00084	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 3149 : }

  0008b	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  00090	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00094	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00098	49 8b e3	 mov	 rsp, r11
  0009b	5f		 pop	 rdi
  0009c	c3		 ret	 0
$LN19@PyUnicode_@112:

; 3120 :         v = PyUnicode_Decode(
; 3121 :                 PyBytes_AS_STRING(obj), PyBytes_GET_SIZE(obj),
; 3122 :                 encoding, errors);

  0009d	4d 8b c8	 mov	 r9, r8
  000a0	48 8d 4b 78	 lea	 rcx, QWORD PTR [rbx+120]
  000a4	4c 8b c6	 mov	 r8, rsi
  000a7	e8 00 00 00 00	 call	 PyUnicode_Decode

; 3149 : }

  000ac	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  000b1	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000b5	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  000b9	49 8b e3	 mov	 rsp, r11
  000bc	5f		 pop	 rdi
  000bd	c3		 ret	 0
$LN23@PyUnicode_@112:

; 3123 :         return v;
; 3124 :     }
; 3125 : 
; 3126 :     if (PyUnicode_Check(obj)) {

  000be	0f ba e1 1c	 bt	 ecx, 28
  000c2	73 27		 jae	 SHORT $LN12@PyUnicode_@112

; 3127 :         PyErr_SetString(PyExc_TypeError,
; 3128 :                         "decoding str is not supported");

  000c4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@ICIOAMLP@decoding?5str?5is?5not?5supported?$AA@
  000d2	e8 00 00 00 00	 call	 PyErr_SetString

; 3129 :         return NULL;

  000d7	33 c0		 xor	 eax, eax

; 3149 : }

  000d9	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  000de	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000e2	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  000e6	49 8b e3	 mov	 rsp, r11
  000e9	5f		 pop	 rdi
  000ea	c3		 ret	 0
$LN12@PyUnicode_@112:

; 3130 :     }
; 3131 : 
; 3132 :     /* Retrieve a bytes buffer view through the PEP 3118 buffer interface */
; 3133 :     if (PyObject_GetBuffer(obj, &buffer, PyBUF_SIMPLE) < 0) {

  000eb	48 8d 54 24 20	 lea	 rdx, QWORD PTR buffer$[rsp]
  000f0	45 33 c0	 xor	 r8d, r8d
  000f3	48 8b cb	 mov	 rcx, rbx
  000f6	e8 00 00 00 00	 call	 PyObject_GetBuffer
  000fb	85 c0		 test	 eax, eax
  000fd	79 2f		 jns	 SHORT $LN11@PyUnicode_@112

; 3134 :         PyErr_Format(PyExc_TypeError,
; 3135 :                      "coercing to str: need bytes, bytearray "
; 3136 :                      "or buffer-like object, %.80s found",
; 3137 :                      Py_TYPE(obj)->tp_name);

  000ff	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  00103	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0010a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EK@HBIOHOLB@coercing?5to?5str?3?5need?5bytes?0?5byt@
  00111	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00115	e8 00 00 00 00	 call	 PyErr_Format

; 3138 :         return NULL;

  0011a	33 c0		 xor	 eax, eax

; 3149 : }

  0011c	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  00121	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00125	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00129	49 8b e3	 mov	 rsp, r11
  0012c	5f		 pop	 rdi
  0012d	c3		 ret	 0
$LN11@PyUnicode_@112:

; 3139 :     }
; 3140 : 
; 3141 :     if (buffer.len == 0) {

  0012e	48 8b 54 24 30	 mov	 rdx, QWORD PTR buffer$[rsp+16]
  00133	48 85 d2	 test	 rdx, rdx
  00136	75 4a		 jne	 SHORT $LN7@PyUnicode_@112

; 3142 :         PyBuffer_Release(&buffer);

  00138	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buffer$[rsp]
  0013d	e8 00 00 00 00	 call	 PyBuffer_Release

; 3143 :         _Py_RETURN_UNICODE_EMPTY();

  00142	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  00149	48 85 c9	 test	 rcx, rcx
  0014c	75 16		 jne	 SHORT $LN28@PyUnicode_@112
  0014e	33 d2		 xor	 edx, edx
  00150	e8 00 00 00 00	 call	 PyUnicode_New
  00155	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  0015c	48 85 c0	 test	 rax, rax
  0015f	74 41		 je	 SHORT $LN25@PyUnicode_@112
  00161	48 8b c8	 mov	 rcx, rax
$LN28@PyUnicode_@112:
  00164	e8 00 00 00 00	 call	 _Py_IncRef
  00169	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 3149 : }

  00170	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  00175	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00179	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  0017d	49 8b e3	 mov	 rsp, r11
  00180	5f		 pop	 rdi
  00181	c3		 ret	 0
$LN7@PyUnicode_@112:

; 3144 :     }
; 3145 : 
; 3146 :     v = PyUnicode_Decode((char*) buffer.buf, buffer.len, encoding, errors);

  00182	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  00187	4c 8b cf	 mov	 r9, rdi
  0018a	4c 8b c6	 mov	 r8, rsi
  0018d	e8 00 00 00 00	 call	 PyUnicode_Decode

; 3147 :     PyBuffer_Release(&buffer);

  00192	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buffer$[rsp]
  00197	48 8b d8	 mov	 rbx, rax
  0019a	e8 00 00 00 00	 call	 PyBuffer_Release

; 3148 :     return v;

  0019f	48 8b c3	 mov	 rax, rbx
$LN25@PyUnicode_@112:

; 3149 : }

  001a2	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  001a7	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  001ab	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  001af	49 8b e3	 mov	 rsp, r11
  001b2	5f		 pop	 rdi
  001b3	c3		 ret	 0
PyUnicode_FromEncodedObject ENDP
_TEXT	ENDS
PUBLIC	PyUnicode_Encode
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyUnicode_Encode DD imagerel $LN4
	DD	imagerel $LN4+94
	DD	imagerel $unwind$PyUnicode_Encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyUnicode_Encode DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyUnicode_Encode
_TEXT	SEGMENT
s$ = 48
size$ = 56
encoding$ = 64
errors$ = 72
PyUnicode_Encode PROC					; COMDAT

; 3306 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b d9	 mov	 rbx, r9
  00012	49 8b f0	 mov	 rsi, r8

; 3307 :     PyObject *v, *unicode;
; 3308 : 
; 3309 :     unicode = PyUnicode_FromUnicode(s, size);

  00015	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  0001a	48 8b f8	 mov	 rdi, rax

; 3310 :     if (unicode == NULL)

  0001d	48 85 c0	 test	 rax, rax
  00020	75 10		 jne	 SHORT $LN1@PyUnicode_@113

; 3314 :     return v;
; 3315 : }

  00022	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00027	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN1@PyUnicode_@113:

; 3311 :         return NULL;
; 3312 :     v = PyUnicode_AsEncodedString(unicode, encoding, errors);

  00032	4c 8b c3	 mov	 r8, rbx
  00035	48 8b d6	 mov	 rdx, rsi
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 PyUnicode_AsEncodedString

; 3313 :     Py_DECREF(unicode);

  00040	48 8b cf	 mov	 rcx, rdi
  00043	48 8b d8	 mov	 rbx, rax
  00046	e8 00 00 00 00	 call	 _Py_DecRef

; 3314 :     return v;
; 3315 : }

  0004b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00050	48 8b c3	 mov	 rax, rbx
  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
PyUnicode_Encode ENDP
_TEXT	ENDS
PUBLIC	??_C@_08HDAAMKKF@?$HMOss?3str?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_new DD imagerel unicode_new
	DD	imagerel unicode_new+219
	DD	imagerel $unwind$unicode_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_new DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_08HDAAMKKF@?$HMOss?3str?$AA@
CONST	SEGMENT
??_C@_08HDAAMKKF@?$HMOss?3str?$AA@ DB '|Oss:str', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unicode_new
_TEXT	SEGMENT
encoding$ = 64
x$ = 96
type$ = 96
args$ = 104
kwds$ = 112
errors$ = 120
unicode_new PROC					; COMDAT

; 14060: {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00004	4c 8b d2	 mov	 r10, rdx

; 14061:     PyObject *x = NULL;

  00007	33 d2		 xor	 edx, edx
  00009	49 8b c0	 mov	 rax, r8
  0000c	48 89 54 24 60	 mov	 QWORD PTR x$[rsp], rdx

; 14062:     static char *kwlist[] = {"object", "encoding", "errors", 0};
; 14063:     char *encoding = NULL;

  00011	48 89 54 24 40	 mov	 QWORD PTR encoding$[rsp], rdx

; 14064:     char *errors = NULL;

  00016	48 89 54 24 78	 mov	 QWORD PTR errors$[rsp], rdx

; 14065: 
; 14066:     if (type != &PyUnicode_Type)

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyUnicode_Type
  00022	48 3b ca	 cmp	 rcx, rdx
  00025	74 0d		 je	 SHORT $LN14@unicode_ne

; 14067:         return unicode_subtype_new(type, args, kwds);

  00027	49 8b d2	 mov	 rdx, r10
  0002a	e8 00 00 00 00	 call	 unicode_subtype_new

; 14077: }

  0002f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00033	c3		 ret	 0
$LN14@unicode_ne:

; 14068:     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|Oss:str",
; 14069:                                      kwlist, &x, &encoding, &errors))

  00034	48 8d 4c 24 78	 lea	 rcx, QWORD PTR errors$[rsp]
  00039	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??unicode_new@@9@9
  00040	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08HDAAMKKF@?$HMOss?3str?$AA@
  00047	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0004c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR encoding$[rsp]
  00051	48 8b d0	 mov	 rdx, rax
  00054	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00059	48 8d 4c 24 60	 lea	 rcx, QWORD PTR x$[rsp]
  0005e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00063	49 8b ca	 mov	 rcx, r10
  00066	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0006b	85 c0		 test	 eax, eax
  0006d	75 07		 jne	 SHORT $LN13@unicode_ne

; 14070:         return NULL;

  0006f	33 c0		 xor	 eax, eax

; 14077: }

  00071	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00075	c3		 ret	 0
$LN13@unicode_ne:

; 14071:     if (x == NULL)

  00076	48 8b 4c 24 60	 mov	 rcx, QWORD PTR x$[rsp]
  0007b	48 85 c9	 test	 rcx, rcx
  0007e	75 33		 jne	 SHORT $LN9@unicode_ne

; 14072:         _Py_RETURN_UNICODE_EMPTY();

  00080	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unicode_empty
  00087	48 85 c9	 test	 rcx, rcx
  0008a	75 16		 jne	 SHORT $LN17@unicode_ne
  0008c	33 d2		 xor	 edx, edx
  0008e	e8 00 00 00 00	 call	 PyUnicode_New
  00093	48 89 05 00 00
	00 00		 mov	 QWORD PTR unicode_empty, rax
  0009a	48 85 c0	 test	 rax, rax
  0009d	74 37		 je	 SHORT $LN1@unicode_ne
  0009f	48 8b c8	 mov	 rcx, rax
$LN17@unicode_ne:
  000a2	e8 00 00 00 00	 call	 _Py_IncRef
  000a7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unicode_empty

; 14077: }

  000ae	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000b2	c3		 ret	 0
$LN9@unicode_ne:

; 14073:     if (encoding == NULL && errors == NULL)

  000b3	48 8b 54 24 40	 mov	 rdx, QWORD PTR encoding$[rsp]
  000b8	4c 8b 44 24 78	 mov	 r8, QWORD PTR errors$[rsp]
  000bd	48 85 d2	 test	 rdx, rdx
  000c0	75 0f		 jne	 SHORT $LN2@unicode_ne
  000c2	4d 85 c0	 test	 r8, r8
  000c5	75 0a		 jne	 SHORT $LN2@unicode_ne

; 14074:         return PyObject_Str(x);

  000c7	e8 00 00 00 00	 call	 PyObject_Str

; 14077: }

  000cc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000d0	c3		 ret	 0
$LN2@unicode_ne:

; 14075:     else
; 14076:         return PyUnicode_FromEncodedObject(x, encoding, errors);

  000d1	e8 00 00 00 00	 call	 PyUnicode_FromEncodedObject
$LN1@unicode_ne:

; 14077: }

  000d6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000da	c3		 ret	 0
unicode_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_subtype_new DD imagerel unicode_subtype_new
	DD	imagerel unicode_subtype_new+297
	DD	imagerel $unwind$unicode_subtype_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$unicode_subtype_new DD imagerel unicode_subtype_new+297
	DD	imagerel unicode_subtype_new+540
	DD	imagerel $chain$4$unicode_subtype_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$unicode_subtype_new DD 020521H
	DD	085405H
	DD	imagerel unicode_subtype_new
	DD	imagerel unicode_subtype_new+297
	DD	imagerel $unwind$unicode_subtype_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_subtype_new DD 0b9101H
	DD	04e491H
	DD	0bd486H
	DD	0ac463H
	DD	09645aH
	DD	070034207H
	DD	03002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_subtype_new
_TEXT	SEGMENT
type$ = 64
args$ = 72
kwds$ = 80
unicode_subtype_new PROC				; COMDAT

; 14081: {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00007	48 8b f9	 mov	 rdi, rcx

; 14082:     PyObject *unicode, *self;
; 14083:     Py_ssize_t length, char_size;
; 14084:     int share_wstr, share_utf8;
; 14085:     unsigned int kind;
; 14086:     void *data;
; 14087: 
; 14088:     assert(PyType_IsSubtype(type, &PyUnicode_Type));
; 14089: 
; 14090:     unicode = unicode_new(&PyUnicode_Type, args, kwds);

  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyUnicode_Type
  00011	e8 00 00 00 00	 call	 unicode_new
  00016	48 8b d8	 mov	 rbx, rax

; 14091:     if (unicode == NULL)

  00019	48 85 c0	 test	 rax, rax

; 14092:         return NULL;

  0001c	74 1b		 je	 SHORT $LN44@unicode_su@2

; 14093:     assert(_PyUnicode_CHECK(unicode));
; 14094:     if (PyUnicode_READY(unicode) == -1) {

  0001e	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  00022	75 1e		 jne	 SHORT $LN21@unicode_su@2
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0002c	83 f8 ff	 cmp	 eax, -1
  0002f	75 11		 jne	 SHORT $LN21@unicode_su@2
$LN45@unicode_su@2:

; 14095:         Py_DECREF(unicode);

  00031	48 8b cb	 mov	 rcx, rbx
  00034	e8 00 00 00 00	 call	 _Py_DecRef
$LN44@unicode_su@2:

; 14096:         return NULL;

  00039	33 c0		 xor	 eax, eax

; 14177: }

  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	5f		 pop	 rdi
  00040	5b		 pop	 rbx
  00041	c3		 ret	 0
$LN21@unicode_su@2:

; 14097:     }
; 14098: 
; 14099:     self = type->tp_alloc(type, 0);

  00042	33 d2		 xor	 edx, edx
  00044	48 8b cf	 mov	 rcx, rdi
  00047	ff 97 88 01 00
	00		 call	 QWORD PTR [rdi+392]
  0004d	48 8b f8	 mov	 rdi, rax

; 14100:     if (self == NULL) {

  00050	48 85 c0	 test	 rax, rax

; 14101:         Py_DECREF(unicode);
; 14102:         return NULL;

  00053	74 dc		 je	 SHORT $LN45@unicode_su@2

; 14103:     }
; 14104:     kind = PyUnicode_KIND(unicode);
; 14105:     length = PyUnicode_GET_LENGTH(unicode);

  00055	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  0005a	48 8b 73 60	 mov	 rsi, QWORD PTR [rbx+96]
  0005e	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  00063	44 8b 63 70	 mov	 r12d, DWORD PTR [rbx+112]

; 14106: 
; 14107:     _PyUnicode_LENGTH(self) = length;

  00067	48 89 70 60	 mov	 QWORD PTR [rax+96], rsi

; 14108: #ifdef Py_DEBUG
; 14109:     _PyUnicode_HASH(self) = -1;
; 14110: #else
; 14111:     _PyUnicode_HASH(self) = _PyUnicode_HASH(unicode);

  0006b	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  0006f	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax

; 14112: #endif
; 14113:     _PyUnicode_STATE(self).interned = 0;
; 14114:     _PyUnicode_STATE(self).kind = kind;
; 14115:     _PyUnicode_STATE(self).compact = 0;

  00073	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00076	41 c1 ec 02	 shr	 r12d, 2
  0007a	83 e0 c0	 and	 eax, -64		; ffffffc0H
  0007d	41 83 e4 07	 and	 r12d, 7
  00081	4c 89 6c 24 58	 mov	 QWORD PTR [rsp+88], r13

; 14116:     _PyUnicode_STATE(self).ascii = _PyUnicode_STATE(unicode).ascii;
; 14117:     _PyUnicode_STATE(self).ready = 1;
; 14118:     _PyUnicode_WSTR(self) = NULL;

  00086	45 33 ed	 xor	 r13d, r13d
  00089	41 8b cc	 mov	 ecx, r12d
  0008c	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00091	83 e1 07	 and	 ecx, 7

; 14119:     _PyUnicode_UTF8_LENGTH(self) = 0;
; 14120:     _PyUnicode_UTF8(self) = NULL;
; 14121:     _PyUnicode_WSTR_LENGTH(self) = 0;
; 14122:     _PyUnicode_DATA_ANY(self) = NULL;
; 14123: 
; 14124:     share_utf8 = 0;
; 14125:     share_wstr = 0;

  00094	45 8b f5	 mov	 r14d, r13d
  00097	c1 e1 02	 shl	 ecx, 2
  0009a	0b c8		 or	 ecx, eax
  0009c	89 4f 70	 mov	 DWORD PTR [rdi+112], ecx
  0009f	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  000a2	83 e1 bf	 and	 ecx, -65		; ffffffbfH
  000a5	83 e0 40	 and	 eax, 64			; 00000040H
  000a8	4c 89 6f 78	 mov	 QWORD PTR [rdi+120], r13
  000ac	4c 89 af 80 00
	00 00		 mov	 QWORD PTR [rdi+128], r13
  000b3	0b c8		 or	 ecx, eax
  000b5	4c 89 af 88 00
	00 00		 mov	 QWORD PTR [rdi+136], r13
  000bc	4c 89 af 90 00
	00 00		 mov	 QWORD PTR [rdi+144], r13
  000c3	0f ba e9 07	 bts	 ecx, 7
  000c7	4c 89 af a0 00
	00 00		 mov	 QWORD PTR [rdi+160], r13
  000ce	89 4f 70	 mov	 DWORD PTR [rdi+112], ecx

; 14126:     if (kind == PyUnicode_1BYTE_KIND) {

  000d1	41 83 fc 01	 cmp	 r12d, 1
  000d5	75 32		 jne	 SHORT $LN19@unicode_su@2

; 14127:         char_size = 1;
; 14128:         if (PyUnicode_MAX_CHAR_VALUE(unicode) < 128)

  000d7	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  000da	45 8b c4	 mov	 r8d, r12d
  000dd	f6 c1 40	 test	 cl, 64			; 00000040H
  000e0	75 22		 jne	 SHORT $LN37@unicode_su@2
  000e2	c1 e9 02	 shr	 ecx, 2
  000e5	83 e1 07	 and	 ecx, 7
  000e8	41 3b c8	 cmp	 ecx, r8d
  000eb	74 32		 je	 SHORT $LN13@unicode_su@2
  000ed	83 f9 02	 cmp	 ecx, 2
  000f0	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH
  000f5	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  000fa	0f 44 c2	 cmove	 eax, edx
  000fd	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00102	73 1b		 jae	 SHORT $LN13@unicode_su@2
$LN37@unicode_su@2:

; 14129:             share_utf8 = 1;

  00104	45 8b e8	 mov	 r13d, r8d

; 14130:     }
; 14131:     else if (kind == PyUnicode_2BYTE_KIND) {

  00107	eb 16		 jmp	 SHORT $LN13@unicode_su@2
$LN19@unicode_su@2:
  00109	41 83 fc 02	 cmp	 r12d, 2
  0010d	75 0a		 jne	 SHORT $LN16@unicode_su@2

; 14132:         char_size = 2;

  0010f	45 8b c4	 mov	 r8d, r12d

; 14133:         if (sizeof(wchar_t) == 2)
; 14134:             share_wstr = 1;

  00112	45 8d 74 24 ff	 lea	 r14d, QWORD PTR [r12-1]

; 14135:     }
; 14136:     else {

  00117	eb 06		 jmp	 SHORT $LN13@unicode_su@2
$LN16@unicode_su@2:

; 14137:         assert(kind == PyUnicode_4BYTE_KIND);
; 14138:         char_size = 4;

  00119	41 b8 04 00 00
	00		 mov	 r8d, 4
$LN13@unicode_su@2:

; 14139:         if (sizeof(wchar_t) == 4)
; 14140:             share_wstr = 1;
; 14141:     }
; 14142: 
; 14143:     /* Ensure we won't overflow the length. */
; 14144:     if (length > (PY_SSIZE_T_MAX / char_size - 1)) {

  0011f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00129	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  0012e	48 99		 cdq
  00130	49 f7 f8	 idiv	 r8
  00133	48 ff c8	 dec	 rax
  00136	48 3b f0	 cmp	 rsi, rax

; 14145:         PyErr_NoMemory();
; 14146:         goto onError;

  00139	7f 18		 jg	 SHORT $LN43@unicode_su@2

; 14147:     }
; 14148:     data = PyObject_MALLOC((length + 1) * char_size);

  0013b	48 8d 6e 01	 lea	 rbp, QWORD PTR [rsi+1]
  0013f	48 8b cd	 mov	 rcx, rbp
  00142	49 0f af c8	 imul	 rcx, r8
  00146	e8 00 00 00 00	 call	 PyObject_Malloc
  0014b	4c 8b d8	 mov	 r11, rax

; 14149:     if (data == NULL) {

  0014e	48 85 c0	 test	 rax, rax
  00151	75 1c		 jne	 SHORT $LN11@unicode_su@2
$LN43@unicode_su@2:

; 14150:         PyErr_NoMemory();

  00153	e8 00 00 00 00	 call	 PyErr_NoMemory

; 14172: 
; 14173: onError:
; 14174:     Py_DECREF(unicode);

  00158	48 8b cb	 mov	 rcx, rbx
$onError$144037:
  0015b	e8 00 00 00 00	 call	 _Py_DecRef

; 14175:     Py_DECREF(self);

  00160	48 8b cf	 mov	 rcx, rdi
  00163	e8 00 00 00 00	 call	 _Py_DecRef

; 14176:     return NULL;

  00168	33 c0		 xor	 eax, eax
  0016a	e9 8d 00 00 00	 jmp	 $LN42@unicode_su@2
$LN11@unicode_su@2:

; 14151:         goto onError;
; 14152:     }
; 14153: 
; 14154:     _PyUnicode_DATA_ANY(self) = data;

  0016f	48 89 87 a0 00
	00 00		 mov	 QWORD PTR [rdi+160], rax

; 14155:     if (share_utf8) {

  00176	45 85 ed	 test	 r13d, r13d
  00179	74 0e		 je	 SHORT $LN10@unicode_su@2

; 14156:         _PyUnicode_UTF8_LENGTH(self) = length;

  0017b	48 89 b7 80 00
	00 00		 mov	 QWORD PTR [rdi+128], rsi

; 14157:         _PyUnicode_UTF8(self) = data;

  00182	48 89 87 88 00
	00 00		 mov	 QWORD PTR [rdi+136], rax
$LN10@unicode_su@2:

; 14158:     }
; 14159:     if (share_wstr) {

  00189	45 85 f6	 test	 r14d, r14d
  0018c	74 0b		 je	 SHORT $LN8@unicode_su@2

; 14160:         _PyUnicode_WSTR_LENGTH(self) = length;

  0018e	48 89 b7 90 00
	00 00		 mov	 QWORD PTR [rdi+144], rsi

; 14161:         _PyUnicode_WSTR(self) = (wchar_t *)data;

  00195	48 89 47 78	 mov	 QWORD PTR [rdi+120], rax
$LN8@unicode_su@2:

; 14162:     }
; 14163: 
; 14164:     Py_MEMCPY(data, PyUnicode_DATA(unicode),
; 14165:               kind * (length + 1));

  00199	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0019c	41 8b cc	 mov	 ecx, r12d
  0019f	48 0f af cd	 imul	 rcx, rbp
  001a3	a8 20		 test	 al, 32			; 00000020H
  001a5	74 16		 je	 SHORT $LN33@unicode_su@2
  001a7	a8 40		 test	 al, 64			; 00000040H
  001a9	74 09		 je	 SHORT $LN31@unicode_su@2
  001ab	48 8d 93 80 00
	00 00		 lea	 rdx, QWORD PTR [rbx+128]
  001b2	eb 10		 jmp	 SHORT $LN34@unicode_su@2
$LN31@unicode_su@2:
  001b4	48 8d 93 a0 00
	00 00		 lea	 rdx, QWORD PTR [rbx+160]
  001bb	eb 07		 jmp	 SHORT $LN34@unicode_su@2
$LN33@unicode_su@2:
  001bd	48 8b 93 a0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+160]
$LN34@unicode_su@2:
  001c4	48 83 f9 10	 cmp	 rcx, 16
  001c8	72 0d		 jb	 SHORT $LN5@unicode_su@2
  001ca	4c 8b c1	 mov	 r8, rcx
  001cd	49 8b cb	 mov	 rcx, r11
  001d0	e8 00 00 00 00	 call	 memcpy
  001d5	eb 1a		 jmp	 SHORT $LN7@unicode_su@2
$LN5@unicode_su@2:
  001d7	48 85 c9	 test	 rcx, rcx
  001da	74 15		 je	 SHORT $LN7@unicode_su@2
  001dc	49 2b d3	 sub	 rdx, r11
  001df	90		 npad	 1
$LL3@unicode_su@2:
  001e0	42 0f b6 04 1a	 movzx	 eax, BYTE PTR [rdx+r11]
  001e5	49 ff c3	 inc	 r11
  001e8	48 ff c9	 dec	 rcx
  001eb	41 88 43 ff	 mov	 BYTE PTR [r11-1], al
  001ef	75 ef		 jne	 SHORT $LL3@unicode_su@2
$LN7@unicode_su@2:

; 14166:     assert(_PyUnicode_CheckConsistency(self, 1));
; 14167: #ifdef Py_DEBUG
; 14168:     _PyUnicode_HASH(self) = _PyUnicode_HASH(unicode);
; 14169: #endif
; 14170:     Py_DECREF(unicode);

  001f1	48 8b cb	 mov	 rcx, rbx
  001f4	e8 00 00 00 00	 call	 _Py_DecRef

; 14171:     return self;

  001f9	48 8b c7	 mov	 rax, rdi
$LN42@unicode_su@2:
  001fc	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00201	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  00206	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0020b	4c 8b 6c 24 58	 mov	 r13, QWORD PTR [rsp+88]
  00210	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]

; 14177: }

  00215	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00219	5f		 pop	 rdi
  0021a	5b		 pop	 rbx
  0021b	c3		 ret	 0
unicode_subtype_new ENDP
_TEXT	ENDS
END
