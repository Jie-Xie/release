; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_04OALOKMFL@cp?$CFu?$AA@			; `string'
PUBLIC	_Py_device_encoding
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyUnicode_FromFormat:PROC
EXTRN	__imp_GetConsoleOutputCP:PROC
EXTRN	__imp_GetConsoleCP:PROC
EXTRN	__imp_isatty:PROC
EXTRN	_PyVerify_fd:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_device_encoding DD imagerel $LN22
	DD	imagerel $LN22+162
	DD	imagerel $unwind$_Py_device_encoding
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_device_encoding DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_04OALOKMFL@cp?$CFu?$AA@
CONST	SEGMENT
??_C@_04OALOKMFL@cp?$CFu?$AA@ DB 'cp%u', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\fileutils.c
CONST	ENDS
;	COMDAT _Py_device_encoding
_TEXT	SEGMENT
fd$ = 64
_Py_device_encoding PROC				; COMDAT

; 19   : {

$LN22:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	8b d9		 mov	 ebx, ecx

; 20   : #if defined(MS_WINDOWS) || defined(MS_WIN64)
; 21   :     UINT cp;
; 22   : #endif
; 23   :     if (!_PyVerify_fd(fd) || !isatty(fd)) {

  00008	e8 00 00 00 00	 call	 _PyVerify_fd
  0000d	85 c0		 test	 eax, eax
  0000f	74 3f		 je	 SHORT $LN7@Py_device_
  00011	8b cb		 mov	 ecx, ebx
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  00019	85 c0		 test	 eax, eax
  0001b	74 33		 je	 SHORT $LN7@Py_device_

; 25   :     }
; 26   : #if defined(MS_WINDOWS) || defined(MS_WIN64)
; 27   :     if (fd == 0)

  0001d	85 db		 test	 ebx, ebx
  0001f	75 08		 jne	 SHORT $LN6@Py_device_

; 28   :         cp = GetConsoleCP();

  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleCP
  00027	eb 10		 jmp	 SHORT $LN2@Py_device_
$LN6@Py_device_:

; 29   :     else if (fd == 1 || fd == 2)

  00029	83 fb 01	 cmp	 ebx, 1
  0002c	74 05		 je	 SHORT $LN3@Py_device_
  0002e	83 fb 02	 cmp	 ebx, 2

; 31   :     else
; 32   :         cp = 0;

  00031	75 1d		 jne	 SHORT $LN7@Py_device_
$LN3@Py_device_:

; 30   :         cp = GetConsoleOutputCP();

  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleOutputCP
$LN2@Py_device_:

; 33   :     /* GetConsoleCP() and GetConsoleOutputCP() return 0 if the application
; 34   :        has no console */
; 35   :     if (cp != 0)

  00039	85 c0		 test	 eax, eax
  0003b	74 13		 je	 SHORT $LN7@Py_device_

; 36   :         return PyUnicode_FromFormat("cp%u", (unsigned int)cp);

  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04OALOKMFL@cp?$CFu?$AA@
  00044	8b d0		 mov	 edx, eax

; 37   : #elif defined(CODESET)
; 38   :     {
; 39   :         char *codeset = nl_langinfo(CODESET);
; 40   :         if (codeset != NULL && codeset[0] != 0)
; 41   :             return PyUnicode_FromString(codeset);
; 42   :     }
; 43   : #endif
; 44   :     Py_RETURN_NONE;
; 45   : }

  00046	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004a	5b		 pop	 rbx
  0004b	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
$LN7@Py_device_:

; 24   :         Py_RETURN_NONE;

  00050	e8 00 00 00 00	 call	 _Py_PXCTX
  00055	85 c0		 test	 eax, eax
  00057	75 3c		 jne	 SHORT $LN12@Py_device_
  00059	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0006e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00074	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00081	85 c0		 test	 eax, eax
  00083	75 09		 jne	 SHORT $LN11@Py_device_
  00085	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0008c	74 07		 je	 SHORT $LN12@Py_device_
$LN11@Py_device_:
  0008e	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN12@Py_device_:
  00095	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 37   : #elif defined(CODESET)
; 38   :     {
; 39   :         char *codeset = nl_langinfo(CODESET);
; 40   :         if (codeset != NULL && codeset[0] != 0)
; 41   :             return PyUnicode_FromString(codeset);
; 42   :     }
; 43   : #endif
; 44   :     Py_RETURN_NONE;
; 45   : }

  0009c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a0	5b		 pop	 rbx
  000a1	c3		 ret	 0
_Py_device_encoding ENDP
_TEXT	ENDS
EXTRN	PyMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$decode_ascii_surrogateescape DD imagerel decode_ascii_surrogateescape
	DD	imagerel decode_ascii_surrogateescape+146
	DD	imagerel $unwind$decode_ascii_surrogateescape
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$decode_ascii_surrogateescape DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT decode_ascii_surrogateescape
_TEXT	SEGMENT
arg$ = 48
size$ = 56
decode_ascii_surrogateescape PROC			; COMDAT

; 200  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b d9	 mov	 rbx, rcx

; 201  :     wchar_t *res;
; 202  :     unsigned char *in;
; 203  :     wchar_t *out;
; 204  : 
; 205  :     res = PyMem_Malloc((strlen(arg)+1)*sizeof(wchar_t));

  00012	48 83 c9 ff	 or	 rcx, -1
  00016	33 c0		 xor	 eax, eax
  00018	48 8b fb	 mov	 rdi, rbx
  0001b	48 8b f2	 mov	 rsi, rdx
  0001e	f2 ae		 repne scasb
  00020	48 f7 d1	 not	 rcx
  00023	48 03 c9	 add	 rcx, rcx
  00026	e8 00 00 00 00	 call	 PyMem_Malloc
  0002b	48 8b d0	 mov	 rdx, rax

; 206  :     if (!res)

  0002e	48 85 c0	 test	 rax, rax
  00031	75 10		 jne	 SHORT $LN6@decode_asc

; 219  :     return res;
; 220  : }

  00033	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00038	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
$LN6@decode_asc:

; 207  :         return NULL;
; 208  : 
; 209  :     in = (unsigned char*)arg;
; 210  :     out = res;
; 211  :     while(*in)

  00043	80 3b 00	 cmp	 BYTE PTR [rbx], 0
  00046	48 8b c8	 mov	 rcx, rax
  00049	74 21		 je	 SHORT $LN4@decode_asc
  0004b	bf 00 24 00 00	 mov	 edi, 9216		; 00002400H
$LL5@decode_asc:

; 212  :         if(*in < 128)

  00050	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00053	3c 80		 cmp	 al, 128			; 00000080H

; 213  :             *out++ = *in++;

  00055	0f b6 c0	 movzx	 eax, al

; 214  :         else

  00058	72 03		 jb	 SHORT $LN10@decode_asc

; 215  :             *out++ = 0xdc00 + *in++;

  0005a	66 2b c7	 sub	 ax, di
$LN10@decode_asc:
  0005d	66 89 01	 mov	 WORD PTR [rcx], ax
  00060	48 ff c3	 inc	 rbx
  00063	48 83 c1 02	 add	 rcx, 2
  00067	80 3b 00	 cmp	 BYTE PTR [rbx], 0
  0006a	75 e4		 jne	 SHORT $LL5@decode_asc
$LN4@decode_asc:

; 216  :     *out = 0;

  0006c	33 c0		 xor	 eax, eax
  0006e	66 89 01	 mov	 WORD PTR [rcx], ax

; 217  :     if (size != NULL)

  00071	48 85 f6	 test	 rsi, rsi
  00074	74 09		 je	 SHORT $LN1@decode_asc

; 218  :         *size = out - res;

  00076	48 2b ca	 sub	 rcx, rdx
  00079	48 d1 f9	 sar	 rcx, 1
  0007c	48 89 0e	 mov	 QWORD PTR [rsi], rcx
$LN1@decode_asc:

; 219  :     return res;
; 220  : }

  0007f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00084	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00089	48 8b c2	 mov	 rax, rdx
  0008c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00090	5f		 pop	 rdi
  00091	c3		 ret	 0
decode_ascii_surrogateescape ENDP
_TEXT	ENDS
PUBLIC	_Py_char2wchar
EXTRN	PyMem_Free:PROC
EXTRN	__imp_mbstowcs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_char2wchar DD imagerel $LN17
	DD	imagerel $LN17+217
	DD	imagerel $unwind$_Py_char2wchar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_char2wchar DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _Py_char2wchar
_TEXT	SEGMENT
arg$ = 48
size$ = 56
_Py_char2wchar PROC					; COMDAT

; 243  : {

$LN17:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b da	 mov	 rbx, rdx
  00017	48 8b e9	 mov	 rbp, rcx

; 244  : #ifdef __APPLE__
; 245  :     wchar_t *wstr;
; 246  :     wstr = _Py_DecodeUTF8_surrogateescape(arg, strlen(arg));
; 247  :     if (size != NULL) {
; 248  :         if (wstr != NULL)
; 249  :             *size = wcslen(wstr);
; 250  :         else
; 251  :             *size = (size_t)-1;
; 252  :     }
; 253  :     return wstr;
; 254  : #else
; 255  :     wchar_t *res;
; 256  :     size_t argsize;
; 257  :     size_t count;
; 258  :     unsigned char *in;
; 259  :     wchar_t *out;
; 260  : #ifdef HAVE_MBRTOWC
; 261  :     mbstate_t mbs;
; 262  : #endif
; 263  : 
; 264  : #ifndef MS_WINDOWS
; 265  :     if (force_ascii == -1)
; 266  :         force_ascii = check_force_ascii();
; 267  : 
; 268  :     if (force_ascii) {
; 269  :         /* force ASCII encoding to workaround mbstowcs() issue */
; 270  :         res = decode_ascii_surrogateescape(arg, size);
; 271  :         if (res == NULL)
; 272  :             goto oom;
; 273  :         return res;
; 274  :     }
; 275  : #endif
; 276  : 
; 277  : #ifdef HAVE_BROKEN_MBSTOWCS
; 278  :     /* Some platforms have a broken implementation of
; 279  :      * mbstowcs which does not count the characters that
; 280  :      * would result from conversion.  Use an upper bound.
; 281  :      */
; 282  :     argsize = strlen(arg);
; 283  : #else
; 284  :     argsize = mbstowcs(NULL, arg, 0);

  0001a	48 8b d1	 mov	 rdx, rcx
  0001d	33 c9		 xor	 ecx, ecx
  0001f	45 33 c0	 xor	 r8d, r8d
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mbstowcs
  00028	48 8b f0	 mov	 rsi, rax

; 285  : #endif
; 286  :     if (argsize != (size_t)-1) {

  0002b	48 83 f8 ff	 cmp	 rax, -1
  0002f	74 75		 je	 SHORT $LN11@Py_char2wc

; 287  :         res = (wchar_t *)PyMem_Malloc((argsize+1)*sizeof(wchar_t));

  00031	48 8d 4c 00 02	 lea	 rcx, QWORD PTR [rax+rax+2]
  00036	e8 00 00 00 00	 call	 PyMem_Malloc
  0003b	48 8b f8	 mov	 rdi, rax

; 288  :         if (!res)

  0003e	48 85 c0	 test	 rax, rax
  00041	74 73		 je	 SHORT $oom$120420

; 289  :             goto oom;
; 290  :         count = mbstowcs(res, arg, argsize+1);

  00043	4c 8d 46 01	 lea	 r8, QWORD PTR [rsi+1]
  00047	48 8b d5	 mov	 rdx, rbp
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mbstowcs

; 291  :         if (count != (size_t)-1) {

  00053	48 83 f8 ff	 cmp	 rax, -1
  00057	74 45		 je	 SHORT $LN4@Py_char2wc

; 292  :             wchar_t *tmp;
; 293  :             /* Only use the result if it contains no
; 294  :                surrogate characters. */
; 295  :             for (tmp = res; *tmp != 0 &&
; 296  :                          (*tmp < 0xd800 || *tmp > 0xdfff); tmp++)

  00059	0f b7 0f	 movzx	 ecx, WORD PTR [rdi]
  0005c	48 8b d7	 mov	 rdx, rdi
  0005f	66 85 c9	 test	 cx, cx
  00062	74 27		 je	 SHORT $LN6@Py_char2wc
  00064	41 b8 00 d8 00
	00		 mov	 r8d, 55296		; 0000d800H
  0006a	41 b9 ff df 00
	00		 mov	 r9d, 57343		; 0000dfffH
$LL8@Py_char2wc:
  00070	66 41 3b c8	 cmp	 cx, r8w
  00074	72 06		 jb	 SHORT $LN7@Py_char2wc
  00076	66 41 3b c9	 cmp	 cx, r9w
  0007a	76 0f		 jbe	 SHORT $LN6@Py_char2wc
$LN7@Py_char2wc:
  0007c	0f b7 4a 02	 movzx	 ecx, WORD PTR [rdx+2]
  00080	48 83 c2 02	 add	 rdx, 2
  00084	66 85 c9	 test	 cx, cx
  00087	75 e7		 jne	 SHORT $LL8@Py_char2wc

; 297  :                 ;
; 298  :             if (*tmp == 0) {

  00089	eb 06		 jmp	 SHORT $LN16@Py_char2wc
$LN6@Py_char2wc:
  0008b	66 83 3a 00	 cmp	 WORD PTR [rdx], 0
  0008f	75 0d		 jne	 SHORT $LN4@Py_char2wc
$LN16@Py_char2wc:

; 299  :                 if (size != NULL)

  00091	48 85 db	 test	 rbx, rbx
  00094	74 03		 je	 SHORT $LN3@Py_char2wc

; 300  :                     *size = count;

  00096	48 89 03	 mov	 QWORD PTR [rbx], rax
$LN3@Py_char2wc:

; 301  :                 return res;

  00099	48 8b c7	 mov	 rax, rdi
  0009c	eb 26		 jmp	 SHORT $LN2@Py_char2wc
$LN4@Py_char2wc:

; 302  :             }
; 303  :         }
; 304  :         PyMem_Free(res);

  0009e	48 8b cf	 mov	 rcx, rdi
  000a1	e8 00 00 00 00	 call	 PyMem_Free
$LN11@Py_char2wc:

; 305  :     }
; 306  :     /* Conversion failed. Fall back to escaping with surrogateescape. */
; 307  : #ifdef HAVE_MBRTOWC
; 308  :     /* Try conversion with mbrtwoc (C99), and escape non-decodable bytes. */
; 309  : 
; 310  :     /* Overallocate; as multi-byte characters are in the argument, the
; 311  :        actual output could use less memory. */
; 312  :     argsize = strlen(arg) + 1;
; 313  :     res = (wchar_t*)PyMem_Malloc(argsize*sizeof(wchar_t));
; 314  :     if (!res)
; 315  :         goto oom;
; 316  :     in = (unsigned char*)arg;
; 317  :     out = res;
; 318  :     memset(&mbs, 0, sizeof mbs);
; 319  :     while (argsize) {
; 320  :         size_t converted = mbrtowc(out, (char*)in, argsize, &mbs);
; 321  :         if (converted == 0)
; 322  :             /* Reached end of string; null char stored. */
; 323  :             break;
; 324  :         if (converted == (size_t)-2) {
; 325  :             /* Incomplete character. This should never happen,
; 326  :                since we provide everything that we have -
; 327  :                unless there is a bug in the C library, or I
; 328  :                misunderstood how mbrtowc works. */
; 329  :             PyMem_Free(res);
; 330  :             if (size != NULL)
; 331  :                 *size = (size_t)-2;
; 332  :             return NULL;
; 333  :         }
; 334  :         if (converted == (size_t)-1) {
; 335  :             /* Conversion error. Escape as UTF-8b, and start over
; 336  :                in the initial shift state. */
; 337  :             *out++ = 0xdc00 + *in++;
; 338  :             argsize--;
; 339  :             memset(&mbs, 0, sizeof mbs);
; 340  :             continue;
; 341  :         }
; 342  :         if (*out >= 0xd800 && *out <= 0xdfff) {
; 343  :             /* Surrogate character.  Escape the original
; 344  :                byte sequence with surrogateescape. */
; 345  :             argsize -= converted;
; 346  :             while (converted--)
; 347  :                 *out++ = 0xdc00 + *in++;
; 348  :             continue;
; 349  :         }
; 350  :         /* successfully converted some bytes */
; 351  :         in += converted;
; 352  :         argsize -= converted;
; 353  :         out++;
; 354  :     }
; 355  :     if (size != NULL)
; 356  :         *size = out - res;
; 357  : #else   /* HAVE_MBRTOWC */
; 358  :     /* Cannot use C locale for escaping; manually escape as if charset
; 359  :        is ASCII (i.e. escape all bytes > 128. This will still roundtrip
; 360  :        correctly in the locale's charset, which must be an ASCII superset. */
; 361  :     res = decode_ascii_surrogateescape(arg, size);

  000a6	48 8b d3	 mov	 rdx, rbx
  000a9	48 8b cd	 mov	 rcx, rbp
  000ac	e8 00 00 00 00	 call	 decode_ascii_surrogateescape

; 362  :     if (res == NULL)

  000b1	48 85 c0	 test	 rax, rax
  000b4	75 0e		 jne	 SHORT $LN2@Py_char2wc
$oom$120420:

; 363  :         goto oom;
; 364  : #endif   /* HAVE_MBRTOWC */
; 365  :     return res;
; 366  : oom:
; 367  :     if (size != NULL)

  000b6	48 85 db	 test	 rbx, rbx
  000b9	74 07		 je	 SHORT $LN1@Py_char2wc

; 368  :         *size = (size_t)-1;

  000bb	48 c7 03 ff ff
	ff ff		 mov	 QWORD PTR [rbx], -1
$LN1@Py_char2wc:

; 369  :     return NULL;

  000c2	33 c0		 xor	 eax, eax
$LN2@Py_char2wc:

; 370  : #endif   /* __APPLE__ */
; 371  : }

  000c4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c9	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000ce	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000d3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d7	5f		 pop	 rdi
  000d8	c3		 ret	 0
_Py_char2wchar ENDP
_TEXT	ENDS
PUBLIC	_Py_wchar2char
EXTRN	__imp_wcstombs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_wchar2char DD imagerel $LN30
	DD	imagerel $LN30+290
	DD	imagerel $unwind$_Py_wchar2char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_wchar2char DD 0c1c01H
	DD	0d641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _Py_wchar2char
_TEXT	SEGMENT
text$ = 80
error_pos$ = 88
buf$ = 96
_Py_wchar2char PROC					; COMDAT

; 386  : {

$LN30:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 387  : #ifdef __APPLE__
; 388  :     Py_ssize_t len;
; 389  :     PyObject *unicode, *bytes = NULL;
; 390  :     char *cpath;
; 391  : 
; 392  :     unicode = PyUnicode_FromWideChar(text, wcslen(text));
; 393  :     if (unicode == NULL)
; 394  :         return NULL;
; 395  : 
; 396  :     bytes = _PyUnicode_AsUTF8String(unicode, "surrogateescape");
; 397  :     Py_DECREF(unicode);
; 398  :     if (bytes == NULL) {
; 399  :         PyErr_Clear();
; 400  :         if (error_pos != NULL)
; 401  :             *error_pos = (size_t)-1;
; 402  :         return NULL;
; 403  :     }
; 404  : 
; 405  :     len = PyBytes_GET_SIZE(bytes);
; 406  :     cpath = PyMem_Malloc(len+1);
; 407  :     if (cpath == NULL) {
; 408  :         PyErr_Clear();
; 409  :         Py_DECREF(bytes);
; 410  :         if (error_pos != NULL)
; 411  :             *error_pos = (size_t)-1;
; 412  :         return NULL;
; 413  :     }
; 414  :     memcpy(cpath, PyBytes_AsString(bytes), len + 1);
; 415  :     Py_DECREF(bytes);
; 416  :     return cpath;
; 417  : #else   /* __APPLE__ */
; 418  :     const size_t len = wcslen(text);

  0001c	33 c0		 xor	 eax, eax
  0001e	4c 8b e9	 mov	 r13, rcx
  00021	48 83 c9 ff	 or	 rcx, -1
  00025	49 8b fd	 mov	 rdi, r13
  00028	4c 8b f2	 mov	 r14, rdx

; 419  :     char *result = NULL, *bytes = NULL;
; 420  :     size_t i, size, converted;
; 421  :     wchar_t c, buf[2];
; 422  : 
; 423  : #ifndef MS_WINDOWS
; 424  :     if (force_ascii == -1)
; 425  :         force_ascii = check_force_ascii();
; 426  : 
; 427  :     if (force_ascii)
; 428  :         return encode_ascii_surrogateescape(text, error_pos);
; 429  : #endif
; 430  : 
; 431  :     /* The function works in two steps:
; 432  :        1. compute the length of the output buffer in bytes (size)
; 433  :        2. outputs the bytes */
; 434  :     size = 0;
; 435  :     buf[1] = 0;

  0002b	41 bf 80 23 00
	00		 mov	 r15d, 9088		; 00002380H
  00031	66 f2 af	 repne scasw
  00034	8b e8		 mov	 ebp, eax
  00036	8b d8		 mov	 ebx, eax
  00038	48 f7 d1	 not	 rcx
  0003b	8b f8		 mov	 edi, eax
  0003d	66 89 44 24 62	 mov	 WORD PTR buf$[rsp+2], ax
  00042	48 ff c9	 dec	 rcx
  00045	4c 8b e1	 mov	 r12, rcx
$LL19@Py_wchar2c:

; 436  :     while (1) {
; 437  :         for (i=0; i < len; i++) {

  00048	48 8b f0	 mov	 rsi, rax
  0004b	4d 85 e4	 test	 r12, r12
  0004e	74 64		 je	 SHORT $LN15@Py_wchar2c
$LL17@Py_wchar2c:

; 438  :             c = text[i];

  00050	41 0f b7 4c 75
	00		 movzx	 ecx, WORD PTR [r13+rsi*2]

; 439  :             if (c >= 0xdc80 && c <= 0xdcff) {

  00056	41 8d 04 0f	 lea	 eax, DWORD PTR [r15+rcx]
  0005a	66 83 f8 7f	 cmp	 ax, 127			; 0000007fH
  0005e	77 14		 ja	 SHORT $LN14@Py_wchar2c

; 440  :                 /* UTF-8b surrogate */
; 441  :                 if (bytes != NULL) {

  00060	48 85 db	 test	 rbx, rbx
  00063	74 0a		 je	 SHORT $LN13@Py_wchar2c

; 442  :                     *bytes++ = c - 0xdc00;

  00065	88 0b		 mov	 BYTE PTR [rbx], cl
  00067	48 ff c3	 inc	 rbx

; 443  :                     size--;

  0006a	48 ff cf	 dec	 rdi

; 444  :                 }
; 445  :                 else

  0006d	eb 3d		 jmp	 SHORT $LN16@Py_wchar2c
$LN13@Py_wchar2c:

; 446  :                     size++;

  0006f	48 ff c7	 inc	 rdi

; 447  :                 continue;

  00072	eb 38		 jmp	 SHORT $LN16@Py_wchar2c
$LN14@Py_wchar2c:

; 448  :             }
; 449  :             else {
; 450  :                 buf[0] = c;

  00074	66 89 4c 24 60	 mov	 WORD PTR buf$[rsp], cx

; 451  :                 if (bytes != NULL)
; 452  :                     converted = wcstombs(bytes, buf, size);

  00079	48 8d 54 24 60	 lea	 rdx, QWORD PTR buf$[rsp]
  0007e	48 85 db	 test	 rbx, rbx
  00081	74 08		 je	 SHORT $LN10@Py_wchar2c
  00083	4c 8b c7	 mov	 r8, rdi
  00086	48 8b cb	 mov	 rcx, rbx

; 453  :                 else

  00089	eb 05		 jmp	 SHORT $LN29@Py_wchar2c
$LN10@Py_wchar2c:

; 454  :                     converted = wcstombs(NULL, buf, 0);

  0008b	45 33 c0	 xor	 r8d, r8d
  0008e	33 c9		 xor	 ecx, ecx
$LN29@Py_wchar2c:
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstombs

; 455  :                 if (converted == (size_t)-1) {

  00096	48 83 f8 ff	 cmp	 rax, -1
  0009a	74 3a		 je	 SHORT $LN25@Py_wchar2c

; 461  :                 }
; 462  :                 if (bytes != NULL) {

  0009c	48 85 db	 test	 rbx, rbx
  0009f	74 08		 je	 SHORT $LN5@Py_wchar2c

; 463  :                     bytes += converted;

  000a1	48 03 d8	 add	 rbx, rax

; 464  :                     size -= converted;

  000a4	48 2b f8	 sub	 rdi, rax

; 465  :                 }
; 466  :                 else

  000a7	eb 03		 jmp	 SHORT $LN16@Py_wchar2c
$LN5@Py_wchar2c:

; 467  :                     size += converted;

  000a9	48 03 f8	 add	 rdi, rax
$LN16@Py_wchar2c:

; 436  :     while (1) {
; 437  :         for (i=0; i < len; i++) {

  000ac	48 ff c6	 inc	 rsi
  000af	49 3b f4	 cmp	 rsi, r12
  000b2	72 9c		 jb	 SHORT $LL17@Py_wchar2c
$LN15@Py_wchar2c:

; 468  :             }
; 469  :         }
; 470  :         if (result != NULL) {

  000b4	48 85 ed	 test	 rbp, rbp
  000b7	75 46		 jne	 SHORT $LN26@Py_wchar2c

; 472  :             break;
; 473  :         }
; 474  : 
; 475  :         size += 1; /* nul byte at the end */

  000b9	48 ff c7	 inc	 rdi

; 476  :         result = PyMem_Malloc(size);

  000bc	48 8b cf	 mov	 rcx, rdi
  000bf	e8 00 00 00 00	 call	 PyMem_Malloc
  000c4	48 8b e8	 mov	 rbp, rax

; 477  :         if (result == NULL) {

  000c7	48 85 c0	 test	 rax, rax
  000ca	74 23		 je	 SHORT $LN27@Py_wchar2c

; 481  :         }
; 482  :         bytes = result;

  000cc	48 8b d8	 mov	 rbx, rax

; 483  :     }

  000cf	33 c0		 xor	 eax, eax
  000d1	e9 72 ff ff ff	 jmp	 $LL19@Py_wchar2c
$LN25@Py_wchar2c:

; 456  :                     if (result != NULL)

  000d6	48 85 ed	 test	 rbp, rbp
  000d9	74 08		 je	 SHORT $LN7@Py_wchar2c

; 457  :                         PyMem_Free(result);

  000db	48 8b cd	 mov	 rcx, rbp
  000de	e8 00 00 00 00	 call	 PyMem_Free
$LN7@Py_wchar2c:

; 458  :                     if (error_pos != NULL)

  000e3	4d 85 f6	 test	 r14, r14
  000e6	74 03		 je	 SHORT $LN6@Py_wchar2c

; 459  :                         *error_pos = i;

  000e8	49 89 36	 mov	 QWORD PTR [r14], rsi
$LN6@Py_wchar2c:

; 460  :                     return NULL;

  000eb	33 c0		 xor	 eax, eax
  000ed	eb 16		 jmp	 SHORT $LN20@Py_wchar2c
$LN27@Py_wchar2c:

; 478  :             if (error_pos != NULL)

  000ef	4d 85 f6	 test	 r14, r14
  000f2	74 07		 je	 SHORT $LN1@Py_wchar2c

; 479  :                 *error_pos = (size_t)-1;

  000f4	49 c7 06 ff ff
	ff ff		 mov	 QWORD PTR [r14], -1
$LN1@Py_wchar2c:

; 480  :             return NULL;

  000fb	33 c0		 xor	 eax, eax
  000fd	eb 06		 jmp	 SHORT $LN20@Py_wchar2c
$LN26@Py_wchar2c:

; 471  :             *bytes = '\0';

  000ff	c6 03 00	 mov	 BYTE PTR [rbx], 0

; 484  :     return result;

  00102	48 8b c5	 mov	 rax, rbp
$LN20@Py_wchar2c:

; 485  : #endif   /* __APPLE__ */
; 486  : }

  00105	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0010a	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  0010f	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00114	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00118	41 5f		 pop	 r15
  0011a	41 5e		 pop	 r14
  0011c	41 5d		 pop	 r13
  0011e	41 5c		 pop	 r12
  00120	5f		 pop	 rdi
  00121	c3		 ret	 0
_Py_wchar2char ENDP
_TEXT	ENDS
PUBLIC	_Py_stat
EXTRN	__imp__wstat64i32:PROC
EXTRN	PyUnicode_AsUnicode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_stat DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$_Py_stat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_stat DD 020601H
	DD	030029206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _Py_stat
_TEXT	SEGMENT
wstatbuf$ = 32
path$ = 96
statbuf$ = 104
_Py_stat PROC						; COMDAT

; 525  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 8b da	 mov	 rbx, rdx

; 526  : #ifdef MS_WINDOWS
; 527  :     int err;
; 528  :     struct _stat wstatbuf;
; 529  :     wchar_t *wpath;
; 530  : 
; 531  :     wpath = PyUnicode_AsUnicode(path);

  00009	e8 00 00 00 00	 call	 PyUnicode_AsUnicode

; 532  :     if (wpath == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 0b		 jne	 SHORT $LN2@Py_stat

; 533  :         return -2;

  00013	b8 fe ff ff ff	 mov	 eax, -2

; 537  :     return err;
; 538  : #else
; 539  :     int ret;
; 540  :     PyObject *bytes = PyUnicode_EncodeFSDefault(path);
; 541  :     if (bytes == NULL)
; 542  :         return -2;
; 543  :     ret = stat(PyBytes_AS_STRING(bytes), statbuf);
; 544  :     Py_DECREF(bytes);
; 545  :     return ret;
; 546  : #endif
; 547  : }

  00018	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0001c	5b		 pop	 rbx
  0001d	c3		 ret	 0
$LN2@Py_stat:

; 534  :     err = _wstat(wpath, &wstatbuf);

  0001e	48 8d 54 24 20	 lea	 rdx, QWORD PTR wstatbuf$[rsp]
  00023	48 8b c8	 mov	 rcx, rax
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wstat64i32

; 535  :     if (!err)

  0002c	85 c0		 test	 eax, eax
  0002e	75 09		 jne	 SHORT $LN1@Py_stat

; 536  :         statbuf->st_mode = wstatbuf.st_mode;

  00030	0f b7 4c 24 26	 movzx	 ecx, WORD PTR wstatbuf$[rsp+6]
  00035	66 89 4b 06	 mov	 WORD PTR [rbx+6], cx
$LN1@Py_stat:

; 537  :     return err;
; 538  : #else
; 539  :     int ret;
; 540  :     PyObject *bytes = PyUnicode_EncodeFSDefault(path);
; 541  :     if (bytes == NULL)
; 542  :         return -2;
; 543  :     ret = stat(PyBytes_AS_STRING(bytes), statbuf);
; 544  :     Py_DECREF(bytes);
; 545  :     return ret;
; 546  : #endif
; 547  : }

  00039	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
_Py_stat ENDP
_TEXT	ENDS
PUBLIC	_Py_wfopen
EXTRN	__imp__wfopen:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Py_wfopen
_TEXT	SEGMENT
path$ = 8
mode$ = 16
_Py_wfopen PROC						; COMDAT

; 557  : #ifndef MS_WINDOWS
; 558  :     FILE *f;
; 559  :     char *cpath;
; 560  :     char cmode[10];
; 561  :     size_t r;
; 562  :     r = wcstombs(cmode, mode, 10);
; 563  :     if (r == (size_t)-1 || r >= 10) {
; 564  :         errno = EINVAL;
; 565  :         return NULL;
; 566  :     }
; 567  :     cpath = _Py_wchar2char(path, NULL);
; 568  :     if (cpath == NULL)
; 569  :         return NULL;
; 570  :     f = fopen(cpath, cmode);
; 571  :     PyMem_Free(cpath);
; 572  :     return f;
; 573  : #else
; 574  :     return _wfopen(path, mode);
; 575  : #endif
; 576  : }

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__wfopen
_Py_wfopen ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@PLNMAGID@str?5file?5path?5expected?5under?5Win@ ; `string'
PUBLIC	_Py_fopen
EXTRN	__imp_MultiByteToWideChar:PROC
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_fopen DD imagerel $LN8
	DD	imagerel $LN8+53
	DD	imagerel $unwind$_Py_fopen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_Py_fopen DD imagerel $LN8+53
	DD	imagerel $LN8+123
	DD	imagerel $chain$0$_Py_fopen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_Py_fopen DD imagerel $LN8+123
	DD	imagerel $LN8+148
	DD	imagerel $chain$2$_Py_fopen
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_Py_fopen DD 020021H
	DD	0c3400H
	DD	imagerel $LN8
	DD	imagerel $LN8+53
	DD	imagerel $unwind$_Py_fopen
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_Py_fopen DD 020521H
	DD	0c3405H
	DD	imagerel $LN8
	DD	imagerel $LN8+53
	DD	imagerel $unwind$_Py_fopen
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_fopen DD 020601H
	DD	070029206H
xdata	ENDS
;	COMDAT ??_C@_0CN@PLNMAGID@str?5file?5path?5expected?5under?5Win@
CONST	SEGMENT
??_C@_0CN@PLNMAGID@str?5file?5path?5expected?5under?5Win@ DB 'str file pa'
	DB	'th expected under Windows, got %R', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_fopen
_TEXT	SEGMENT
wmode$ = 48
path$ = 96
mode$ = 104
_Py_fopen PROC						; COMDAT

; 586  : {

$LN8:
  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 587  : #ifdef MS_WINDOWS
; 588  :     wchar_t *wpath;
; 589  :     wchar_t wmode[10];
; 590  :     int usize;
; 591  : 
; 592  :     if (!PyUnicode_Check(path)) {

  00006	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  00018	75 1b		 jne	 SHORT $LN3@Py_fopen

; 593  :         PyErr_Format(PyExc_TypeError,
; 594  :                      "str file path expected under Windows, got %R",
; 595  :                      Py_TYPE(path));

  0001a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@PLNMAGID@str?5file?5path?5expected?5under?5Win@
  00028	e8 00 00 00 00	 call	 PyErr_Format

; 596  :         return NULL;

  0002d	33 c0		 xor	 eax, eax

; 607  : #else
; 608  :     FILE *f;
; 609  :     PyObject *bytes;
; 610  :     if (!PyUnicode_FSConverter(path, &bytes))
; 611  :         return NULL;
; 612  :     f = fopen(PyBytes_AS_STRING(bytes), mode);
; 613  :     Py_DECREF(bytes);
; 614  :     return f;
; 615  : #endif
; 616  : }

  0002f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00033	5f		 pop	 rdi
  00034	c3		 ret	 0
$LN3@Py_fopen:
  00035	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx

; 597  :     }
; 598  :     wpath = PyUnicode_AsUnicode(path);

  0003a	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  0003f	48 8b d8	 mov	 rbx, rax

; 599  :     if (wpath == NULL)

  00042	48 85 c0	 test	 rax, rax

; 600  :         return NULL;

  00045	74 27		 je	 SHORT $LN7@Py_fopen

; 601  : 
; 602  :     usize = MultiByteToWideChar(CP_ACP, 0, mode, -1, wmode, sizeof(wmode));

  00047	48 8d 44 24 30	 lea	 rax, QWORD PTR wmode$[rsp]
  0004c	41 83 c9 ff	 or	 r9d, -1
  00050	4c 8b c7	 mov	 r8, rdi
  00053	33 d2		 xor	 edx, edx
  00055	33 c9		 xor	 ecx, ecx
  00057	c7 44 24 28 14
	00 00 00	 mov	 DWORD PTR [rsp+40], 20
  0005f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MultiByteToWideChar

; 603  :     if (usize == 0)

  0006a	85 c0		 test	 eax, eax
  0006c	75 0d		 jne	 SHORT $LN1@Py_fopen
$LN7@Py_fopen:

; 604  :         return NULL;

  0006e	33 c0		 xor	 eax, eax
  00070	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 607  : #else
; 608  :     FILE *f;
; 609  :     PyObject *bytes;
; 610  :     if (!PyUnicode_FSConverter(path, &bytes))
; 611  :         return NULL;
; 612  :     f = fopen(PyBytes_AS_STRING(bytes), mode);
; 613  :     Py_DECREF(bytes);
; 614  :     return f;
; 615  : #endif
; 616  : }

  00075	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00079	5f		 pop	 rdi
  0007a	c3		 ret	 0
$LN1@Py_fopen:

; 605  : 
; 606  :     return _wfopen(wpath, wmode);

  0007b	48 8d 54 24 30	 lea	 rdx, QWORD PTR wmode$[rsp]
  00080	48 8b cb	 mov	 rcx, rbx
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wfopen
  00089	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 607  : #else
; 608  :     FILE *f;
; 609  :     PyObject *bytes;
; 610  :     if (!PyUnicode_FSConverter(path, &bytes))
; 611  :         return NULL;
; 612  :     f = fopen(PyBytes_AS_STRING(bytes), mode);
; 613  :     Py_DECREF(bytes);
; 614  :     return f;
; 615  : #endif
; 616  : }

  0008e	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00092	5f		 pop	 rdi
  00093	c3		 ret	 0
_Py_fopen ENDP
_TEXT	ENDS
PUBLIC	_Py_wgetcwd
EXTRN	__imp__wgetcwd:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Py_wgetcwd
_TEXT	SEGMENT
buf$ = 8
size$ = 16
_Py_wgetcwd PROC					; COMDAT

; 710  : #ifdef MS_WINDOWS
; 711  :     return _wgetcwd(buf, size);
; 712  : #else
; 713  :     char fname[MAXPATHLEN];
; 714  :     wchar_t *wname;
; 715  :     size_t len;
; 716  : 
; 717  :     if (getcwd(fname, Py_ARRAY_LENGTH(fname)) == NULL)
; 718  :         return NULL;
; 719  :     wname = _Py_char2wchar(fname, &len);
; 720  :     if (wname == NULL)
; 721  :         return NULL;
; 722  :     if (size <= len) {
; 723  :         PyMem_Free(wname);
; 724  :         return NULL;
; 725  :     }
; 726  :     wcsncpy(buf, wname, size);
; 727  :     PyMem_Free(wname);
; 728  :     return buf;
; 729  : #endif
; 730  : }

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__wgetcwd
_Py_wgetcwd ENDP
_TEXT	ENDS
END
