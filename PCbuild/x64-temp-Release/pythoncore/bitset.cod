; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@NPBBDHCH@no?5mem?5for?5bitset?$AA@	; `string'
PUBLIC	_Py_newbitset
EXTRN	Py_FatalError:PROC
EXTRN	PyObject_Malloc:PROC
;	COMDAT pdata
; File c:\src\pyparallel\parser\bitset.c
pdata	SEGMENT
$pdata$_Py_newbitset DD imagerel $LN9
	DD	imagerel $LN9+93
	DD	imagerel $unwind$_Py_newbitset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_newbitset DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BC@NPBBDHCH@no?5mem?5for?5bitset?$AA@
CONST	SEGMENT
??_C@_0BC@NPBBDHCH@no?5mem?5for?5bitset?$AA@ DB 'no mem for bitset', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_newbitset
_TEXT	SEGMENT
nbits$ = 48
_Py_newbitset PROC					; COMDAT

; 9    : {

$LN9:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 10   :     int nbytes = NBYTES(nbits);

  0000f	48 63 f9	 movsxd	 rdi, ecx
  00012	48 83 c7 07	 add	 rdi, 7
  00016	48 c1 ef 03	 shr	 rdi, 3

; 11   :     bitset ss = (char *)PyObject_MALLOC(sizeof(BYTE) *  nbytes);

  0001a	48 63 f7	 movsxd	 rsi, edi
  0001d	48 8b ce	 mov	 rcx, rsi
  00020	e8 00 00 00 00	 call	 PyObject_Malloc
  00025	48 8b d8	 mov	 rbx, rax

; 12   : 
; 13   :     if (ss == NULL)

  00028	48 85 c0	 test	 rax, rax
  0002b	75 0c		 jne	 SHORT $LN3@Py_newbits

; 14   :         Py_FatalError("no mem for bitset");

  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@NPBBDHCH@no?5mem?5for?5bitset?$AA@
  00034	e8 00 00 00 00	 call	 Py_FatalError
$LN3@Py_newbits:

; 15   : 
; 16   :     ss += nbytes;

  00039	48 03 de	 add	 rbx, rsi

; 17   :     while (--nbytes >= 0)

  0003c	ff cf		 dec	 edi
  0003e	78 0a		 js	 SHORT $LN8@Py_newbits
$LL2@Py_newbits:

; 18   :         *--ss = 0;

  00040	48 ff cb	 dec	 rbx
  00043	ff cf		 dec	 edi
  00045	c6 03 00	 mov	 BYTE PTR [rbx], 0
  00048	79 f6		 jns	 SHORT $LL2@Py_newbits
$LN8@Py_newbits:

; 19   :     return ss;
; 20   : }

  0004a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004f	48 8b c3	 mov	 rax, rbx
  00052	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00057	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005b	5f		 pop	 rdi
  0005c	c3		 ret	 0
_Py_newbitset ENDP
_TEXT	ENDS
PUBLIC	_Py_delbitset
EXTRN	PyObject_Free:PROC
; Function compile flags: /Ogtpy
;	COMDAT _Py_delbitset
_TEXT	SEGMENT
ss$ = 8
_Py_delbitset PROC					; COMDAT

; 25   :     PyObject_FREE(ss);
; 26   : }

  00000	e9 00 00 00 00	 jmp	 PyObject_Free
_Py_delbitset ENDP
_TEXT	ENDS
PUBLIC	_Py_addbit
; Function compile flags: /Ogtpy
;	COMDAT _Py_addbit
_TEXT	SEGMENT
ss$ = 8
ibit$ = 16
_Py_addbit PROC						; COMDAT

; 31   :     int ibyte = BIT2BYTE(ibit);

  00000	48 63 c2	 movsxd	 rax, edx
  00003	4c 8b c9	 mov	 r9, rcx

; 32   :     BYTE mask = BIT2MASK(ibit);

  00006	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000c	48 8b d0	 mov	 rdx, rax
  0000f	24 07		 and	 al, 7
  00011	0f b6 c8	 movzx	 ecx, al
  00014	48 c1 ea 03	 shr	 rdx, 3
  00018	41 d2 e0	 shl	 r8b, cl

; 33   : 
; 34   :     if (ss[ibyte] & mask)

  0001b	48 63 ca	 movsxd	 rcx, edx
  0001e	42 0f b6 04 09	 movzx	 eax, BYTE PTR [rcx+r9]
  00023	41 84 c0	 test	 al, r8b
  00026	74 03		 je	 SHORT $LN1@Py_addbit

; 35   :         return 0; /* Bit already set */

  00028	33 c0		 xor	 eax, eax

; 38   : }

  0002a	c3		 ret	 0
$LN1@Py_addbit:

; 36   :     ss[ibyte] |= mask;

  0002b	41 0a c0	 or	 al, r8b
  0002e	42 88 04 09	 mov	 BYTE PTR [rcx+r9], al

; 37   :     return 1;

  00032	b8 01 00 00 00	 mov	 eax, 1

; 38   : }

  00037	c3		 ret	 0
_Py_addbit ENDP
_TEXT	ENDS
PUBLIC	_Py_samebitset
; Function compile flags: /Ogtpy
;	COMDAT _Py_samebitset
_TEXT	SEGMENT
ss1$ = 8
ss2$ = 16
nbits$ = 24
_Py_samebitset PROC					; COMDAT

; 51   :     int i;
; 52   : 
; 53   :     for (i = NBYTES(nbits); --i >= 0; )

  00000	4d 63 c8	 movsxd	 r9, r8d
  00003	4c 8b d1	 mov	 r10, rcx
  00006	49 83 c1 07	 add	 r9, 7
  0000a	49 c1 e9 03	 shr	 r9, 3
  0000e	41 ff c9	 dec	 r9d
  00011	78 21		 js	 SHORT $LN2@Py_samebit
  00013	4c 2b d2	 sub	 r10, rdx
  00016	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL3@Py_samebit:

; 54   :         if (*ss1++ != *ss2++)

  00020	41 0f b6 0c 12	 movzx	 ecx, BYTE PTR [r10+rdx]
  00025	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00028	48 ff c2	 inc	 rdx
  0002b	3a c8		 cmp	 cl, al
  0002d	75 0b		 jne	 SHORT $LN7@Py_samebit

; 51   :     int i;
; 52   : 
; 53   :     for (i = NBYTES(nbits); --i >= 0; )

  0002f	41 ff c9	 dec	 r9d
  00032	79 ec		 jns	 SHORT $LL3@Py_samebit
$LN2@Py_samebit:

; 56   :     return 1;

  00034	b8 01 00 00 00	 mov	 eax, 1

; 57   : }

  00039	c3		 ret	 0
$LN7@Py_samebit:

; 55   :             return 0;

  0003a	33 c0		 xor	 eax, eax

; 57   : }

  0003c	c3		 ret	 0
_Py_samebitset ENDP
_TEXT	ENDS
PUBLIC	_Py_mergebitset
; Function compile flags: /Ogtpy
;	COMDAT _Py_mergebitset
_TEXT	SEGMENT
ss1$ = 8
ss2$ = 16
nbits$ = 24
_Py_mergebitset PROC					; COMDAT

; 62   :     int i;
; 63   : 
; 64   :     for (i = NBYTES(nbits); --i >= 0; )

  00000	4d 63 c8	 movsxd	 r9, r8d
  00003	49 83 c1 07	 add	 r9, 7
  00007	49 c1 e9 03	 shr	 r9, 3
  0000b	41 ff c9	 dec	 r9d
  0000e	78 1f		 js	 SHORT $LN1@Py_mergebi
  00010	48 2b d1	 sub	 rdx, rcx
  00013	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL2@Py_mergebi:

; 65   :         *ss1++ |= *ss2++;

  00020	0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+rcx]
  00024	48 ff c1	 inc	 rcx
  00027	08 41 ff	 or	 BYTE PTR [rcx-1], al
  0002a	41 ff c9	 dec	 r9d
  0002d	79 f1		 jns	 SHORT $LL2@Py_mergebi
$LN1@Py_mergebi:

; 66   : }

  0002f	f3 c3		 fatret	 0
_Py_mergebitset ENDP
_TEXT	ENDS
END
