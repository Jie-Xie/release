; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_dist_code
PUBLIC	_length_code
_DATA	SEGMENT
static_l_desc DQ FLAT:static_ltree
	DQ	FLAT:extra_lbits
	DD	0101H
	DD	011eH
	DD	0fH
	ORG $+4
static_d_desc DQ FLAT:static_dtree
	DQ	FLAT:extra_dbits
	DD	00H
	DD	01eH
	DD	0fH
	ORG $+4
static_bl_desc DQ 0000000000000000H
	DQ	FLAT:extra_blbits
	DD	00H
	DD	013H
	DD	07H
	ORG $+4
_DATA	ENDS
CONST	SEGMENT
extra_lbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
	ORG $+12
extra_dbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
	ORG $+8
extra_blbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	03H
	DD	07H
	ORG $+4
bl_order DB	010H
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
	ORG $+13
static_ltree DW	0cH
	DW	08H
	DW	08cH
	DW	08H
	DW	04cH
	DW	08H
	DW	0ccH
	DW	08H
	DW	02cH
	DW	08H
	DW	0acH
	DW	08H
	DW	06cH
	DW	08H
	DW	0ecH
	DW	08H
	DW	01cH
	DW	08H
	DW	09cH
	DW	08H
	DW	05cH
	DW	08H
	DW	0dcH
	DW	08H
	DW	03cH
	DW	08H
	DW	0bcH
	DW	08H
	DW	07cH
	DW	08H
	DW	0fcH
	DW	08H
	DW	02H
	DW	08H
	DW	082H
	DW	08H
	DW	042H
	DW	08H
	DW	0c2H
	DW	08H
	DW	022H
	DW	08H
	DW	0a2H
	DW	08H
	DW	062H
	DW	08H
	DW	0e2H
	DW	08H
	DW	012H
	DW	08H
	DW	092H
	DW	08H
	DW	052H
	DW	08H
	DW	0d2H
	DW	08H
	DW	032H
	DW	08H
	DW	0b2H
	DW	08H
	DW	072H
	DW	08H
	DW	0f2H
	DW	08H
	DW	0aH
	DW	08H
	DW	08aH
	DW	08H
	DW	04aH
	DW	08H
	DW	0caH
	DW	08H
	DW	02aH
	DW	08H
	DW	0aaH
	DW	08H
	DW	06aH
	DW	08H
	DW	0eaH
	DW	08H
	DW	01aH
	DW	08H
	DW	09aH
	DW	08H
	DW	05aH
	DW	08H
	DW	0daH
	DW	08H
	DW	03aH
	DW	08H
	DW	0baH
	DW	08H
	DW	07aH
	DW	08H
	DW	0faH
	DW	08H
	DW	06H
	DW	08H
	DW	086H
	DW	08H
	DW	046H
	DW	08H
	DW	0c6H
	DW	08H
	DW	026H
	DW	08H
	DW	0a6H
	DW	08H
	DW	066H
	DW	08H
	DW	0e6H
	DW	08H
	DW	016H
	DW	08H
	DW	096H
	DW	08H
	DW	056H
	DW	08H
	DW	0d6H
	DW	08H
	DW	036H
	DW	08H
	DW	0b6H
	DW	08H
	DW	076H
	DW	08H
	DW	0f6H
	DW	08H
	DW	0eH
	DW	08H
	DW	08eH
	DW	08H
	DW	04eH
	DW	08H
	DW	0ceH
	DW	08H
	DW	02eH
	DW	08H
	DW	0aeH
	DW	08H
	DW	06eH
	DW	08H
	DW	0eeH
	DW	08H
	DW	01eH
	DW	08H
	DW	09eH
	DW	08H
	DW	05eH
	DW	08H
	DW	0deH
	DW	08H
	DW	03eH
	DW	08H
	DW	0beH
	DW	08H
	DW	07eH
	DW	08H
	DW	0feH
	DW	08H
	DW	01H
	DW	08H
	DW	081H
	DW	08H
	DW	041H
	DW	08H
	DW	0c1H
	DW	08H
	DW	021H
	DW	08H
	DW	0a1H
	DW	08H
	DW	061H
	DW	08H
	DW	0e1H
	DW	08H
	DW	011H
	DW	08H
	DW	091H
	DW	08H
	DW	051H
	DW	08H
	DW	0d1H
	DW	08H
	DW	031H
	DW	08H
	DW	0b1H
	DW	08H
	DW	071H
	DW	08H
	DW	0f1H
	DW	08H
	DW	09H
	DW	08H
	DW	089H
	DW	08H
	DW	049H
	DW	08H
	DW	0c9H
	DW	08H
	DW	029H
	DW	08H
	DW	0a9H
	DW	08H
	DW	069H
	DW	08H
	DW	0e9H
	DW	08H
	DW	019H
	DW	08H
	DW	099H
	DW	08H
	DW	059H
	DW	08H
	DW	0d9H
	DW	08H
	DW	039H
	DW	08H
	DW	0b9H
	DW	08H
	DW	079H
	DW	08H
	DW	0f9H
	DW	08H
	DW	05H
	DW	08H
	DW	085H
	DW	08H
	DW	045H
	DW	08H
	DW	0c5H
	DW	08H
	DW	025H
	DW	08H
	DW	0a5H
	DW	08H
	DW	065H
	DW	08H
	DW	0e5H
	DW	08H
	DW	015H
	DW	08H
	DW	095H
	DW	08H
	DW	055H
	DW	08H
	DW	0d5H
	DW	08H
	DW	035H
	DW	08H
	DW	0b5H
	DW	08H
	DW	075H
	DW	08H
	DW	0f5H
	DW	08H
	DW	0dH
	DW	08H
	DW	08dH
	DW	08H
	DW	04dH
	DW	08H
	DW	0cdH
	DW	08H
	DW	02dH
	DW	08H
	DW	0adH
	DW	08H
	DW	06dH
	DW	08H
	DW	0edH
	DW	08H
	DW	01dH
	DW	08H
	DW	09dH
	DW	08H
	DW	05dH
	DW	08H
	DW	0ddH
	DW	08H
	DW	03dH
	DW	08H
	DW	0bdH
	DW	08H
	DW	07dH
	DW	08H
	DW	0fdH
	DW	08H
	DW	013H
	DW	09H
	DW	0113H
	DW	09H
	DW	093H
	DW	09H
	DW	0193H
	DW	09H
	DW	053H
	DW	09H
	DW	0153H
	DW	09H
	DW	0d3H
	DW	09H
	DW	01d3H
	DW	09H
	DW	033H
	DW	09H
	DW	0133H
	DW	09H
	DW	0b3H
	DW	09H
	DW	01b3H
	DW	09H
	DW	073H
	DW	09H
	DW	0173H
	DW	09H
	DW	0f3H
	DW	09H
	DW	01f3H
	DW	09H
	DW	0bH
	DW	09H
	DW	010bH
	DW	09H
	DW	08bH
	DW	09H
	DW	018bH
	DW	09H
	DW	04bH
	DW	09H
	DW	014bH
	DW	09H
	DW	0cbH
	DW	09H
	DW	01cbH
	DW	09H
	DW	02bH
	DW	09H
	DW	012bH
	DW	09H
	DW	0abH
	DW	09H
	DW	01abH
	DW	09H
	DW	06bH
	DW	09H
	DW	016bH
	DW	09H
	DW	0ebH
	DW	09H
	DW	01ebH
	DW	09H
	DW	01bH
	DW	09H
	DW	011bH
	DW	09H
	DW	09bH
	DW	09H
	DW	019bH
	DW	09H
	DW	05bH
	DW	09H
	DW	015bH
	DW	09H
	DW	0dbH
	DW	09H
	DW	01dbH
	DW	09H
	DW	03bH
	DW	09H
	DW	013bH
	DW	09H
	DW	0bbH
	DW	09H
	DW	01bbH
	DW	09H
	DW	07bH
	DW	09H
	DW	017bH
	DW	09H
	DW	0fbH
	DW	09H
	DW	01fbH
	DW	09H
	DW	07H
	DW	09H
	DW	0107H
	DW	09H
	DW	087H
	DW	09H
	DW	0187H
	DW	09H
	DW	047H
	DW	09H
	DW	0147H
	DW	09H
	DW	0c7H
	DW	09H
	DW	01c7H
	DW	09H
	DW	027H
	DW	09H
	DW	0127H
	DW	09H
	DW	0a7H
	DW	09H
	DW	01a7H
	DW	09H
	DW	067H
	DW	09H
	DW	0167H
	DW	09H
	DW	0e7H
	DW	09H
	DW	01e7H
	DW	09H
	DW	017H
	DW	09H
	DW	0117H
	DW	09H
	DW	097H
	DW	09H
	DW	0197H
	DW	09H
	DW	057H
	DW	09H
	DW	0157H
	DW	09H
	DW	0d7H
	DW	09H
	DW	01d7H
	DW	09H
	DW	037H
	DW	09H
	DW	0137H
	DW	09H
	DW	0b7H
	DW	09H
	DW	01b7H
	DW	09H
	DW	077H
	DW	09H
	DW	0177H
	DW	09H
	DW	0f7H
	DW	09H
	DW	01f7H
	DW	09H
	DW	0fH
	DW	09H
	DW	010fH
	DW	09H
	DW	08fH
	DW	09H
	DW	018fH
	DW	09H
	DW	04fH
	DW	09H
	DW	014fH
	DW	09H
	DW	0cfH
	DW	09H
	DW	01cfH
	DW	09H
	DW	02fH
	DW	09H
	DW	012fH
	DW	09H
	DW	0afH
	DW	09H
	DW	01afH
	DW	09H
	DW	06fH
	DW	09H
	DW	016fH
	DW	09H
	DW	0efH
	DW	09H
	DW	01efH
	DW	09H
	DW	01fH
	DW	09H
	DW	011fH
	DW	09H
	DW	09fH
	DW	09H
	DW	019fH
	DW	09H
	DW	05fH
	DW	09H
	DW	015fH
	DW	09H
	DW	0dfH
	DW	09H
	DW	01dfH
	DW	09H
	DW	03fH
	DW	09H
	DW	013fH
	DW	09H
	DW	0bfH
	DW	09H
	DW	01bfH
	DW	09H
	DW	07fH
	DW	09H
	DW	017fH
	DW	09H
	DW	0ffH
	DW	09H
	DW	01ffH
	DW	09H
	DW	00H
	DW	07H
	DW	040H
	DW	07H
	DW	020H
	DW	07H
	DW	060H
	DW	07H
	DW	010H
	DW	07H
	DW	050H
	DW	07H
	DW	030H
	DW	07H
	DW	070H
	DW	07H
	DW	08H
	DW	07H
	DW	048H
	DW	07H
	DW	028H
	DW	07H
	DW	068H
	DW	07H
	DW	018H
	DW	07H
	DW	058H
	DW	07H
	DW	038H
	DW	07H
	DW	078H
	DW	07H
	DW	04H
	DW	07H
	DW	044H
	DW	07H
	DW	024H
	DW	07H
	DW	064H
	DW	07H
	DW	014H
	DW	07H
	DW	054H
	DW	07H
	DW	034H
	DW	07H
	DW	074H
	DW	07H
	DW	03H
	DW	08H
	DW	083H
	DW	08H
	DW	043H
	DW	08H
	DW	0c3H
	DW	08H
	DW	023H
	DW	08H
	DW	0a3H
	DW	08H
	DW	063H
	DW	08H
	DW	0e3H
	DW	08H
static_dtree DW	00H
	DW	05H
	DW	010H
	DW	05H
	DW	08H
	DW	05H
	DW	018H
	DW	05H
	DW	04H
	DW	05H
	DW	014H
	DW	05H
	DW	0cH
	DW	05H
	DW	01cH
	DW	05H
	DW	02H
	DW	05H
	DW	012H
	DW	05H
	DW	0aH
	DW	05H
	DW	01aH
	DW	05H
	DW	06H
	DW	05H
	DW	016H
	DW	05H
	DW	0eH
	DW	05H
	DW	01eH
	DW	05H
	DW	01H
	DW	05H
	DW	011H
	DW	05H
	DW	09H
	DW	05H
	DW	019H
	DW	05H
	DW	05H
	DW	05H
	DW	015H
	DW	05H
	DW	0dH
	DW	05H
	DW	01dH
	DW	05H
	DW	03H
	DW	05H
	DW	013H
	DW	05H
	DW	0bH
	DW	05H
	DW	01bH
	DW	05H
	DW	07H
	DW	05H
	DW	017H
	DW	05H
	ORG $+8
_dist_code DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	00H
	DB	00H
	DB	010H
	DB	011H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
_length_code DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01cH
base_length DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	0aH
	DD	0cH
	DD	0eH
	DD	010H
	DD	014H
	DD	018H
	DD	01cH
	DD	020H
	DD	028H
	DD	030H
	DD	038H
	DD	040H
	DD	050H
	DD	060H
	DD	070H
	DD	080H
	DD	0a0H
	DD	0c0H
	DD	0e0H
	DD	00H
	ORG $+12
base_dist DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	06H
	DD	08H
	DD	0cH
	DD	010H
	DD	018H
	DD	020H
	DD	030H
	DD	040H
	DD	060H
	DD	080H
	DD	0c0H
	DD	0100H
	DD	0180H
	DD	0200H
	DD	0300H
	DD	0400H
	DD	0600H
	DD	0800H
	DD	0c00H
	DD	01000H
	DD	01800H
	DD	02000H
	DD	03000H
	DD	04000H
	DD	06000H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\zlib\trees.c
CONST	ENDS
;	COMDAT tr_static_init
_TEXT	SEGMENT
tr_static_init PROC					; COMDAT

; 241  : #if defined(GEN_TREES_H) || !defined(STDC)
; 242  :     static int static_init_done = 0;
; 243  :     int n;        /* iterates over tree elements */
; 244  :     int bits;     /* bit counter */
; 245  :     int length;   /* length value */
; 246  :     int code;     /* code value */
; 247  :     int dist;     /* distance index */
; 248  :     ush bl_count[MAX_BITS+1];
; 249  :     /* number of codes at each bit length for an optimal tree */
; 250  : 
; 251  :     if (static_init_done) return;
; 252  : 
; 253  :     /* For some embedded targets, global variables are not initialized: */
; 254  : #ifdef NO_INIT_GLOBAL_POINTERS
; 255  :     static_l_desc.static_tree = static_ltree;
; 256  :     static_l_desc.extra_bits = extra_lbits;
; 257  :     static_d_desc.static_tree = static_dtree;
; 258  :     static_d_desc.extra_bits = extra_dbits;
; 259  :     static_bl_desc.extra_bits = extra_blbits;
; 260  : #endif
; 261  : 
; 262  :     /* Initialize the mapping length (0..255) -> length code (0..28) */
; 263  :     length = 0;
; 264  :     for (code = 0; code < LENGTH_CODES-1; code++) {
; 265  :         base_length[code] = length;
; 266  :         for (n = 0; n < (1<<extra_lbits[code]); n++) {
; 267  :             _length_code[length++] = (uch)code;
; 268  :         }
; 269  :     }
; 270  :     Assert (length == 256, "tr_static_init: length != 256");
; 271  :     /* Note that the length 255 (match length 258) can be represented
; 272  :      * in two different ways: code 284 + 5 bits or code 285, so we
; 273  :      * overwrite length_code[255] to use the best encoding:
; 274  :      */
; 275  :     _length_code[length-1] = (uch)code;
; 276  : 
; 277  :     /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
; 278  :     dist = 0;
; 279  :     for (code = 0 ; code < 16; code++) {
; 280  :         base_dist[code] = dist;
; 281  :         for (n = 0; n < (1<<extra_dbits[code]); n++) {
; 282  :             _dist_code[dist++] = (uch)code;
; 283  :         }
; 284  :     }
; 285  :     Assert (dist == 256, "tr_static_init: dist != 256");
; 286  :     dist >>= 7; /* from now on, all distances are divided by 128 */
; 287  :     for ( ; code < D_CODES; code++) {
; 288  :         base_dist[code] = dist << 7;
; 289  :         for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
; 290  :             _dist_code[256 + dist++] = (uch)code;
; 291  :         }
; 292  :     }
; 293  :     Assert (dist == 256, "tr_static_init: 256+dist != 512");
; 294  : 
; 295  :     /* Construct the codes of the static literal tree */
; 296  :     for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
; 297  :     n = 0;
; 298  :     while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
; 299  :     while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
; 300  :     while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
; 301  :     while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
; 302  :     /* Codes 286 and 287 do not exist, but we must include them in the
; 303  :      * tree construction to get a canonical Huffman tree (longest code
; 304  :      * all ones)
; 305  :      */
; 306  :     gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
; 307  : 
; 308  :     /* The static distance tree is trivial: */
; 309  :     for (n = 0; n < D_CODES; n++) {
; 310  :         static_dtree[n].Len = 5;
; 311  :         static_dtree[n].Code = bi_reverse((unsigned)n, 5);
; 312  :     }
; 313  :     static_init_done = 1;
; 314  : 
; 315  : #  ifdef GEN_TREES_H
; 316  :     gen_trees_header();
; 317  : #  endif
; 318  : #endif /* defined(GEN_TREES_H) || !defined(STDC) */
; 319  : }

  00000	c2 00 00	 ret	 0
tr_static_init ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT init_block
_TEXT	SEGMENT
s$ = 8
init_block PROC						; COMDAT

; 418  :     int n; /* iterates over tree elements */
; 419  : 
; 420  :     /* Initialize the trees. */
; 421  :     for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;

  00000	48 8d 81 bc 00
	00 00		 lea	 rax, QWORD PTR [rcx+188]
  00007	ba 1e 01 00 00	 mov	 edx, 286		; 0000011eH
  0000c	45 33 c0	 xor	 r8d, r8d
  0000f	90		 npad	 1
$LL9@init_block:
  00010	66 44 89 00	 mov	 WORD PTR [rax], r8w
  00014	48 83 c0 04	 add	 rax, 4
  00018	48 ff ca	 dec	 rdx
  0001b	75 f3		 jne	 SHORT $LL9@init_block

; 422  :     for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;

  0001d	48 8d 81 b0 09
	00 00		 lea	 rax, QWORD PTR [rcx+2480]
  00024	ba 1e 00 00 00	 mov	 edx, 30
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@init_block:
  00030	66 44 89 00	 mov	 WORD PTR [rax], r8w
  00034	48 83 c0 04	 add	 rax, 4
  00038	48 ff ca	 dec	 rdx
  0003b	75 f3		 jne	 SHORT $LL6@init_block

; 423  :     for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

  0003d	48 8d 81 a4 0a
	00 00		 lea	 rax, QWORD PTR [rcx+2724]
  00044	ba 13 00 00 00	 mov	 edx, 19
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL3@init_block:
  00050	66 44 89 00	 mov	 WORD PTR [rax], r8w
  00054	48 83 c0 04	 add	 rax, 4
  00058	48 ff ca	 dec	 rdx
  0005b	75 f3		 jne	 SHORT $LL3@init_block

; 424  : 
; 425  :     s->dyn_ltree[END_BLOCK].Freq = 1;

  0005d	b8 01 00 00 00	 mov	 eax, 1

; 426  :     s->opt_len = s->static_len = 0L;

  00062	4c 89 81 00 17
	00 00		 mov	 QWORD PTR [rcx+5888], r8

; 427  :     s->last_lit = s->matches = 0;

  00069	44 89 81 08 17
	00 00		 mov	 DWORD PTR [rcx+5896], r8d
  00070	66 89 81 bc 04
	00 00		 mov	 WORD PTR [rcx+1212], ax
  00077	44 89 81 f4 16
	00 00		 mov	 DWORD PTR [rcx+5876], r8d

; 428  : }

  0007e	c3		 ret	 0
init_block ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pqdownheap DD imagerel pqdownheap
	DD	imagerel pqdownheap+235
	DD	imagerel $unwind$pqdownheap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pqdownheap DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT pqdownheap
_TEXT	SEGMENT
s$ = 8
tree$ = 16
k$ = 24
pqdownheap PROC						; COMDAT

; 463  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi

; 464  :     int v = s->heap[k];
; 465  :     int j = k << 1;  /* left son of k */
; 466  :     while (j <= s->heap_len) {

  0000f	8b 81 9c 14 00
	00		 mov	 eax, DWORD PTR [rcx+5276]
  00015	4d 63 d0	 movsxd	 r10, r8d
  00018	48 8b fa	 mov	 rdi, rdx
  0001b	4a 63 9c 91 a8
	0b 00 00	 movsxd	 rbx, DWORD PTR [rcx+r10*4+2984]
  00023	47 8d 0c 12	 lea	 r9d, DWORD PTR [r10+r10]
  00027	44 3b c8	 cmp	 r9d, eax
  0002a	0f 8f 89 00 00
	00		 jg	 $LN14@pqdownheap
$LN16@pqdownheap:

; 467  :         /* Set j to the smallest of the two sons: */
; 468  :         if (j < s->heap_len &&
; 469  :             smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {

  00030	7d 3a		 jge	 SHORT $LN4@pqdownheap
  00032	49 63 c1	 movsxd	 rax, r9d
  00035	4c 63 9c 81 a8
	0b 00 00	 movsxd	 r11, DWORD PTR [rcx+rax*4+2984]
  0003d	4c 63 84 81 ac
	0b 00 00	 movsxd	 r8, DWORD PTR [rcx+rax*4+2988]
  00045	42 0f b7 04 87	 movzx	 eax, WORD PTR [rdi+r8*4]
  0004a	42 0f b7 14 9f	 movzx	 edx, WORD PTR [rdi+r11*4]
  0004f	66 3b c2	 cmp	 ax, dx
  00052	72 15		 jb	 SHORT $LN3@pqdownheap
  00054	75 16		 jne	 SHORT $LN4@pqdownheap
  00056	41 0f b6 84 0b
	a4 14 00 00	 movzx	 eax, BYTE PTR [r11+rcx+5284]
  0005f	41 38 84 08 a4
	14 00 00	 cmp	 BYTE PTR [r8+rcx+5284], al
  00067	77 03		 ja	 SHORT $LN4@pqdownheap
$LN3@pqdownheap:

; 470  :             j++;

  00069	41 ff c1	 inc	 r9d
$LN4@pqdownheap:

; 471  :         }
; 472  :         /* Exit if v is smaller than both sons */
; 473  :         if (smaller(tree, v, s->heap[j], s->depth)) break;

  0006c	49 63 c1	 movsxd	 rax, r9d
  0006f	4c 63 9c 81 a8
	0b 00 00	 movsxd	 r11, DWORD PTR [rcx+rax*4+2984]
  00077	0f b7 04 9f	 movzx	 eax, WORD PTR [rdi+rbx*4]
  0007b	42 0f b7 14 9f	 movzx	 edx, WORD PTR [rdi+r11*4]
  00080	66 3b c2	 cmp	 ax, dx
  00083	72 4c		 jb	 SHORT $LN13@pqdownheap
  00085	75 12		 jne	 SHORT $LN2@pqdownheap
  00087	41 0f b6 84 0b
	a4 14 00 00	 movzx	 eax, BYTE PTR [r11+rcx+5284]
  00090	38 84 0b a4 14
	00 00		 cmp	 BYTE PTR [rbx+rcx+5284], al
  00097	76 38		 jbe	 SHORT $LN13@pqdownheap
$LN2@pqdownheap:

; 474  : 
; 475  :         /* Exchange v with the smallest son */
; 476  :         s->heap[k] = s->heap[j];  k = j;

  00099	49 63 c2	 movsxd	 rax, r10d
  0009c	4d 63 d1	 movsxd	 r10, r9d

; 477  : 
; 478  :         /* And continue down the tree, setting j to the left son of k */
; 479  :         j <<= 1;

  0009f	45 03 c9	 add	 r9d, r9d
  000a2	44 89 9c 81 a8
	0b 00 00	 mov	 DWORD PTR [rcx+rax*4+2984], r11d
  000aa	8b 81 9c 14 00
	00		 mov	 eax, DWORD PTR [rcx+5276]
  000b0	44 3b c8	 cmp	 r9d, eax
  000b3	0f 8e 77 ff ff
	ff		 jle	 $LN16@pqdownheap
$LN14@pqdownheap:

; 480  :     }
; 481  :     s->heap[k] = v;

  000b9	42 89 9c 91 a8
	0b 00 00	 mov	 DWORD PTR [rcx+r10*4+2984], ebx

; 482  : }

  000c1	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  000c6	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
  000cb	48 8b 7c 24 18	 mov	 rdi, QWORD PTR [rsp+24]
  000d0	c3		 ret	 0
$LN13@pqdownheap:
  000d1	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
  000d6	48 8b 7c 24 18	 mov	 rdi, QWORD PTR [rsp+24]
  000db	49 63 c2	 movsxd	 rax, r10d
  000de	89 9c 81 a8 0b
	00 00		 mov	 DWORD PTR [rcx+rax*4+2984], ebx
  000e5	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  000ea	c3		 ret	 0
pqdownheap ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gen_bitlen DD imagerel gen_bitlen
	DD	imagerel gen_bitlen+32
	DD	imagerel $unwind$gen_bitlen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$gen_bitlen DD imagerel gen_bitlen+32
	DD	imagerel gen_bitlen+129
	DD	imagerel $chain$2$gen_bitlen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gen_bitlen DD imagerel gen_bitlen+129
	DD	imagerel gen_bitlen+307
	DD	imagerel $chain$3$gen_bitlen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$gen_bitlen DD imagerel gen_bitlen+307
	DD	imagerel gen_bitlen+329
	DD	imagerel $chain$4$gen_bitlen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$gen_bitlen DD imagerel gen_bitlen+329
	DD	imagerel gen_bitlen+539
	DD	imagerel $chain$5$gen_bitlen
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$gen_bitlen DD 021H
	DD	imagerel gen_bitlen
	DD	imagerel gen_bitlen+32
	DD	imagerel $unwind$gen_bitlen
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$gen_bitlen DD 021H
	DD	imagerel gen_bitlen+32
	DD	imagerel gen_bitlen+129
	DD	imagerel $chain$2$gen_bitlen
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gen_bitlen DD 020521H
	DD	0ac405H
	DD	imagerel gen_bitlen+32
	DD	imagerel gen_bitlen+129
	DD	imagerel $chain$2$gen_bitlen
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$gen_bitlen DD 061a21H
	DD	0f41aH
	DD	01e411H
	DD	02d405H
	DD	imagerel gen_bitlen
	DD	imagerel gen_bitlen+32
	DD	imagerel $unwind$gen_bitlen
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gen_bitlen DD 050901H
	DD	070052209H
	DD	050036004H
	DD	03002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gen_bitlen
_TEXT	SEGMENT
base$1$ = 64
s$ = 64
h$1$ = 72
desc$ = 72
gen_bitlen PROC						; COMDAT

; 497  : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	48 83 ec 18	 sub	 rsp, 24

; 498  :     ct_data *tree        = desc->dyn_tree;
; 499  :     int max_code         = desc->max_code;
; 500  :     const ct_data *stree = desc->stat_desc->static_tree;

  00009	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  0000d	4c 8b 1a	 mov	 r11, QWORD PTR [rdx]
  00010	8b 72 08	 mov	 esi, DWORD PTR [rdx+8]

; 501  :     const intf *extra    = desc->stat_desc->extra_bits;
; 502  :     int base             = desc->stat_desc->extra_base;

  00013	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]

; 503  :     int max_length       = desc->stat_desc->max_length;

  00017	4c 63 50 18	 movsxd	 r10, DWORD PTR [rax+24]

; 504  :     int h;              /* heap index */
; 505  :     int n, m;           /* iterate over the tree elements */
; 506  :     int bits;           /* bit length */
; 507  :     int xbits;          /* extra bits */
; 508  :     ush f;              /* frequency */
; 509  :     int overflow = 0;   /* number of elements with bit length too large */

  0001b	33 db		 xor	 ebx, ebx
  0001d	4c 8b c1	 mov	 r8, rcx
  00020	4c 89 6c 24 10	 mov	 QWORD PTR [rsp+16], r13
  00025	48 8d b9 88 0b
	00 00		 lea	 rdi, QWORD PTR [rcx+2952]
  0002c	4c 89 74 24 08	 mov	 QWORD PTR [rsp+8], r14
  00031	4c 8b 30	 mov	 r14, QWORD PTR [rax]
  00034	8b d3		 mov	 edx, ebx
  00036	4c 89 3c 24	 mov	 QWORD PTR [rsp], r15
  0003a	4c 8b 78 08	 mov	 r15, QWORD PTR [rax+8]

; 510  : 
; 511  :     for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

  0003e	0f b7 c3	 movzx	 eax, bx
  00041	b9 10 00 00 00	 mov	 ecx, 16

; 517  : 
; 518  :     for (h = s->heap_max+1; h < HEAP_SIZE; h++) {

  00046	41 bd 3d 02 00
	00		 mov	 r13d, 573		; 0000023dH
  0004c	44 89 4c 24 40	 mov	 DWORD PTR base$1$[rsp], r9d
  00051	66 f3 ab	 rep stosw
  00054	49 63 80 a0 14
	00 00		 movsxd	 rax, DWORD PTR [r8+5280]
  0005b	49 63 8c 80 a8
	0b 00 00	 movsxd	 rcx, DWORD PTR [r8+rax*4+2984]
  00063	66 41 89 5c 8b
	02		 mov	 WORD PTR [r11+rcx*4+2], bx
  00069	41 8b 98 a0 14
	00 00		 mov	 ebx, DWORD PTR [r8+5280]
  00070	ff c3		 inc	 ebx
  00072	48 63 c3	 movsxd	 rax, ebx
  00075	49 3b c5	 cmp	 rax, r13
  00078	0f 8d b5 00 00
	00		 jge	 $LN18@gen_bitlen

; 512  : 
; 513  :     /* In a first pass, compute the optimal bit lengths (which may
; 514  :      * overflow in the case of the bit length tree).
; 515  :      */
; 516  :     tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

  0007e	4c 2b e8	 sub	 r13, rax
  00081	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  00086	4d 8d a4 80 a8
	0b 00 00	 lea	 r12, QWORD PTR [r8+rax*4+2984]

; 517  : 
; 518  :     for (h = s->heap_max+1; h < HEAP_SIZE; h++) {

  0008e	41 03 dd	 add	 ebx, r13d
  00091	89 5c 24 48	 mov	 DWORD PTR h$1$[rsp], ebx
  00095	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL20@gen_bitlen:

; 519  :         n = s->heap[h];

  000a0	49 63 2c 24	 movsxd	 rbp, DWORD PTR [r12]

; 520  :         bits = tree[tree[n].Dad].Len + 1;

  000a4	48 8b fd	 mov	 rdi, rbp
  000a7	48 8d 1c ad 00
	00 00 00	 lea	 rbx, QWORD PTR [rbp*4]
  000af	42 0f b7 44 1b
	02		 movzx	 eax, WORD PTR [rbx+r11+2]
  000b5	41 0f b7 4c 83
	02		 movzx	 ecx, WORD PTR [r11+rax*4+2]
  000bb	ff c1		 inc	 ecx

; 521  :         if (bits > max_length) bits = max_length, overflow++;

  000bd	41 3b ca	 cmp	 ecx, r10d
  000c0	7e 05		 jle	 SHORT $LN17@gen_bitlen
  000c2	41 8b ca	 mov	 ecx, r10d
  000c5	ff c2		 inc	 edx
$LN17@gen_bitlen:

; 522  :         tree[n].Len = (ush)bits;

  000c7	66 42 89 4c 1b
	02		 mov	 WORD PTR [rbx+r11+2], cx

; 523  :         /* We overwrite tree[n].Dad which is no longer needed */
; 524  : 
; 525  :         if (n > max_code) continue; /* not a leaf node */

  000cd	3b ee		 cmp	 ebp, esi
  000cf	7f 4c		 jg	 SHORT $LN19@gen_bitlen

; 526  : 
; 527  :         s->bl_count[bits]++;

  000d1	48 63 c1	 movsxd	 rax, ecx

; 528  :         xbits = 0;

  000d4	45 33 c9	 xor	 r9d, r9d
  000d7	66 41 ff 84 40
	88 0b 00 00	 inc	 WORD PTR [r8+rax*2+2952]

; 529  :         if (n >= base) xbits = extra[n-base];

  000e0	3b 6c 24 40	 cmp	 ebp, DWORD PTR base$1$[rsp]
  000e4	7c 0c		 jl	 SHORT $LN15@gen_bitlen
  000e6	4c 63 4c 24 40	 movsxd	 r9, DWORD PTR base$1$[rsp]
  000eb	49 2b f9	 sub	 rdi, r9
  000ee	45 8b 0c bf	 mov	 r9d, DWORD PTR [r15+rdi*4]
$LN15@gen_bitlen:

; 530  :         f = tree[n].Freq;
; 531  :         s->opt_len += (ulg)f * (bits + xbits);

  000f2	42 0f b7 3c 1b	 movzx	 edi, WORD PTR [rbx+r11]
  000f7	41 8d 04 09	 lea	 eax, DWORD PTR [r9+rcx]
  000fb	0f af c7	 imul	 eax, edi
  000fe	41 01 80 00 17
	00 00		 add	 DWORD PTR [r8+5888], eax

; 532  :         if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);

  00105	4d 85 f6	 test	 r14, r14
  00108	74 13		 je	 SHORT $LN19@gen_bitlen
  0010a	42 0f b7 44 33
	02		 movzx	 eax, WORD PTR [rbx+r14+2]
  00110	41 03 c1	 add	 eax, r9d
  00113	0f af c7	 imul	 eax, edi
  00116	41 01 80 04 17
	00 00		 add	 DWORD PTR [r8+5892], eax
$LN19@gen_bitlen:

; 517  : 
; 518  :     for (h = s->heap_max+1; h < HEAP_SIZE; h++) {

  0011d	49 83 c4 04	 add	 r12, 4
  00121	49 ff cd	 dec	 r13
  00124	0f 85 76 ff ff
	ff		 jne	 $LL20@gen_bitlen
  0012a	8b 5c 24 48	 mov	 ebx, DWORD PTR h$1$[rsp]
  0012e	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
$LN18@gen_bitlen:
  00133	4c 8b 3c 24	 mov	 r15, QWORD PTR [rsp]
  00137	4c 8b 74 24 08	 mov	 r14, QWORD PTR [rsp+8]
  0013c	4c 8b 6c 24 10	 mov	 r13, QWORD PTR [rsp+16]

; 533  :     }
; 534  :     if (overflow == 0) return;

  00141	85 d2		 test	 edx, edx
  00143	0f 84 c9 00 00
	00		 je	 $LN5@gen_bitlen
  00149	45 8d 4a ff	 lea	 r9d, DWORD PTR [r10-1]
  0014d	bd ff ff 00 00	 mov	 ebp, 65535		; 0000ffffH
  00152	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL12@gen_bitlen:

; 535  : 
; 536  :     Trace((stderr,"\nbit length overflow\n"));
; 537  :     /* This happens for example on obj2 and pic of the Calgary corpus */
; 538  : 
; 539  :     /* Find the first bit length which could increase: */
; 540  :     do {
; 541  :         bits = max_length-1;

  00160	49 63 c9	 movsxd	 rcx, r9d

; 542  :         while (s->bl_count[bits] == 0) bits--;

  00163	66 41 83 bc 48
	88 0b 00 00 00	 cmp	 WORD PTR [r8+rcx*2+2952], 0
  0016d	75 12		 jne	 SHORT $LN8@gen_bitlen
  0016f	90		 npad	 1
$LL9@gen_bitlen:
  00170	ff c9		 dec	 ecx
  00172	48 63 c1	 movsxd	 rax, ecx
  00175	66 41 83 bc 40
	88 0b 00 00 00	 cmp	 WORD PTR [r8+rax*2+2952], 0
  0017f	74 ef		 je	 SHORT $LL9@gen_bitlen
$LN8@gen_bitlen:

; 543  :         s->bl_count[bits]--;      /* move one leaf down the tree */

  00181	48 63 c1	 movsxd	 rax, ecx

; 544  :         s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
; 545  :         s->bl_count[max_length]--;
; 546  :         /* The brother of the overflow item also moves one step up,
; 547  :          * but this does not affect bl_count[max_length]
; 548  :          */
; 549  :         overflow -= 2;

  00184	83 ea 02	 sub	 edx, 2
  00187	66 41 01 ac 40
	88 0b 00 00	 add	 WORD PTR [r8+rax*2+2952], bp
  00190	66 41 83 84 40
	8a 0b 00 00 02	 add	 WORD PTR [r8+rax*2+2954], 2
  0019a	66 43 01 ac 50
	88 0b 00 00	 add	 WORD PTR [r8+r10*2+2952], bp

; 550  :     } while (overflow > 0);

  001a3	85 d2		 test	 edx, edx
  001a5	7f b9		 jg	 SHORT $LL12@gen_bitlen

; 551  : 
; 552  :     /* Now recompute all bit lengths, scanning in increasing frequency.
; 553  :      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
; 554  :      * lengths instead of fixing only the wrong ones. This idea is taken
; 555  :      * from 'ar' written by Haruhiko Okumura.)
; 556  :      */
; 557  :     for (bits = max_length; bits != 0; bits--) {

  001a7	48 63 db	 movsxd	 rbx, ebx
  001aa	45 85 d2	 test	 r10d, r10d
  001ad	74 63		 je	 SHORT $LN5@gen_bitlen
  001af	90		 npad	 1
$LL7@gen_bitlen:

; 558  :         n = s->bl_count[bits];

  001b0	49 63 c2	 movsxd	 rax, r10d
  001b3	41 0f b7 94 40
	88 0b 00 00	 movzx	 edx, WORD PTR [r8+rax*2+2952]

; 559  :         while (n != 0) {

  001bc	85 d2		 test	 edx, edx
  001be	74 4d		 je	 SHORT $LN6@gen_bitlen

; 558  :         n = s->bl_count[bits];

  001c0	49 8d bc 98 a8
	0b 00 00	 lea	 rdi, QWORD PTR [r8+rbx*4+2984]
  001c8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@gen_bitlen:

; 560  :             m = s->heap[--h];

  001d0	48 63 47 fc	 movsxd	 rax, DWORD PTR [rdi-4]
  001d4	48 83 ef 04	 sub	 rdi, 4
  001d8	48 ff cb	 dec	 rbx

; 561  :             if (m > max_code) continue;

  001db	3b c6		 cmp	 eax, esi
  001dd	7f 2a		 jg	 SHORT $LN36@gen_bitlen

; 562  :             if ((unsigned) tree[m].Len != (unsigned) bits) {

  001df	4c 8b c8	 mov	 r9, rax
  001e2	41 0f b7 44 83
	02		 movzx	 eax, WORD PTR [r11+rax*4+2]
  001e8	41 3b c2	 cmp	 eax, r10d
  001eb	74 1a		 je	 SHORT $LN1@gen_bitlen

; 563  :                 Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
; 564  :                 s->opt_len += ((long)bits - (long)tree[m].Len)
; 565  :                               *(long)tree[m].Freq;

  001ed	41 8b ca	 mov	 ecx, r10d
  001f0	2b c8		 sub	 ecx, eax
  001f2	43 0f b7 04 8b	 movzx	 eax, WORD PTR [r11+r9*4]
  001f7	0f af c8	 imul	 ecx, eax
  001fa	41 01 88 00 17
	00 00		 add	 DWORD PTR [r8+5888], ecx

; 566  :                 tree[m].Len = (ush)bits;

  00201	66 47 89 54 8b
	02		 mov	 WORD PTR [r11+r9*4+2], r10w
$LN1@gen_bitlen:

; 567  :             }
; 568  :             n--;

  00207	ff ca		 dec	 edx
$LN36@gen_bitlen:

; 559  :         while (n != 0) {

  00209	85 d2		 test	 edx, edx
  0020b	75 c3		 jne	 SHORT $LL4@gen_bitlen
$LN6@gen_bitlen:

; 551  : 
; 552  :     /* Now recompute all bit lengths, scanning in increasing frequency.
; 553  :      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
; 554  :      * lengths instead of fixing only the wrong ones. This idea is taken
; 555  :      * from 'ar' written by Haruhiko Okumura.)
; 556  :      */
; 557  :     for (bits = max_length; bits != 0; bits--) {

  0020d	41 ff ca	 dec	 r10d
  00210	75 9e		 jne	 SHORT $LL7@gen_bitlen
$LN5@gen_bitlen:

; 569  :         }
; 570  :     }
; 571  : }

  00212	48 83 c4 18	 add	 rsp, 24
  00216	5f		 pop	 rdi
  00217	5e		 pop	 rsi
  00218	5d		 pop	 rbp
  00219	5b		 pop	 rbx
  0021a	c3		 ret	 0
gen_bitlen ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$scan_tree DD imagerel scan_tree
	DD	imagerel scan_tree+230
	DD	imagerel $unwind$scan_tree
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scan_tree DD 040a01H
	DD	02740aH
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT scan_tree
_TEXT	SEGMENT
s$ = 8
tree$ = 16
max_code$ = 24
scan_tree PROC						; COMDAT

; 715  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi

; 716  :     int n;                     /* iterates over all tree elements */
; 717  :     int prevlen = -1;          /* last emitted length */
; 718  :     int curlen;                /* length of current code */
; 719  :     int nextlen = tree[0].Len; /* length of next code */

  0000a	0f b7 7a 02	 movzx	 edi, WORD PTR [rdx+2]
  0000e	83 cb ff	 or	 ebx, -1

; 720  :     int count = 0;             /* repeat count of the current code */

  00011	45 33 d2	 xor	 r10d, r10d
  00014	4c 8b da	 mov	 r11, rdx

; 721  :     int max_count = 7;         /* max repeat count */

  00017	8d 43 08	 lea	 eax, QWORD PTR [rbx+8]

; 722  :     int min_count = 4;         /* min repeat count */

  0001a	44 8d 4b 05	 lea	 r9d, QWORD PTR [rbx+5]

; 723  : 
; 724  :     if (nextlen == 0) max_count = 138, min_count = 3;

  0001e	85 ff		 test	 edi, edi
  00020	75 09		 jne	 SHORT $LN17@scan_tree
  00022	b8 8a 00 00 00	 mov	 eax, 138		; 0000008aH
  00027	44 8d 4b 04	 lea	 r9d, QWORD PTR [rbx+4]
$LN17@scan_tree:

; 725  :     tree[max_code+1].Len = (ush)0xffff; /* guard */

  0002b	49 63 d0	 movsxd	 rdx, r8d
  0002e	41 b8 ff ff 00
	00		 mov	 r8d, 65535		; 0000ffffH
  00034	66 45 89 44 93
	06		 mov	 WORD PTR [r11+rdx*4+6], r8w

; 726  : 
; 727  :     for (n = 0; n <= max_code; n++) {

  0003a	48 85 d2	 test	 rdx, rdx
  0003d	0f 88 98 00 00
	00		 js	 $LN14@scan_tree

; 725  :     tree[max_code+1].Len = (ush)0xffff; /* guard */

  00043	49 83 c3 06	 add	 r11, 6
  00047	4c 8d 42 01	 lea	 r8, QWORD PTR [rdx+1]
  0004b	0f 1f 44 00 00	 npad	 5
$LL16@scan_tree:

; 728  :         curlen = nextlen; nextlen = tree[n+1].Len;
; 729  :         if (++count < max_count && curlen == nextlen) {

  00050	41 ff c2	 inc	 r10d
  00053	48 63 d7	 movsxd	 rdx, edi
  00056	41 0f b7 3b	 movzx	 edi, WORD PTR [r11]
  0005a	44 3b d0	 cmp	 r10d, eax
  0005d	7d 04		 jge	 SHORT $LN13@scan_tree
  0005f	3b d7		 cmp	 edx, edi
  00061	74 6b		 je	 SHORT $LN15@scan_tree
$LN13@scan_tree:

; 730  :             continue;
; 731  :         } else if (count < min_count) {

  00063	45 3b d1	 cmp	 r10d, r9d
  00066	7d 0b		 jge	 SHORT $LN11@scan_tree

; 732  :             s->bl_tree[curlen].Freq += count;

  00068	66 44 01 94 91
	a4 0a 00 00	 add	 WORD PTR [rcx+rdx*4+2724], r10w
  00071	eb 2f		 jmp	 SHORT $LN5@scan_tree
$LN11@scan_tree:

; 733  :         } else if (curlen != 0) {

  00073	85 d2		 test	 edx, edx
  00075	74 15		 je	 SHORT $LN9@scan_tree

; 734  :             if (curlen != prevlen) s->bl_tree[curlen].Freq++;

  00077	3b d3		 cmp	 edx, ebx
  00079	74 08		 je	 SHORT $LN8@scan_tree
  0007b	66 ff 84 91 a4
	0a 00 00	 inc	 WORD PTR [rcx+rdx*4+2724]
$LN8@scan_tree:

; 735  :             s->bl_tree[REP_3_6].Freq++;

  00083	66 ff 81 e4 0a
	00 00		 inc	 WORD PTR [rcx+2788]
  0008a	eb 16		 jmp	 SHORT $LN5@scan_tree
$LN9@scan_tree:

; 736  :         } else if (count <= 10) {

  0008c	41 83 fa 0a	 cmp	 r10d, 10
  00090	7f 09		 jg	 SHORT $LN6@scan_tree

; 737  :             s->bl_tree[REPZ_3_10].Freq++;

  00092	66 ff 81 e8 0a
	00 00		 inc	 WORD PTR [rcx+2792]

; 738  :         } else {

  00099	eb 07		 jmp	 SHORT $LN5@scan_tree
$LN6@scan_tree:

; 739  :             s->bl_tree[REPZ_11_138].Freq++;

  0009b	66 ff 81 ec 0a
	00 00		 inc	 WORD PTR [rcx+2796]
$LN5@scan_tree:

; 740  :         }
; 741  :         count = 0; prevlen = curlen;

  000a2	45 33 d2	 xor	 r10d, r10d
  000a5	8b da		 mov	 ebx, edx

; 742  :         if (nextlen == 0) {

  000a7	85 ff		 test	 edi, edi
  000a9	75 0b		 jne	 SHORT $LN4@scan_tree

; 743  :             max_count = 138, min_count = 3;

  000ab	b8 8a 00 00 00	 mov	 eax, 138		; 0000008aH
  000b0	45 8d 4a 03	 lea	 r9d, QWORD PTR [r10+3]
  000b4	eb 18		 jmp	 SHORT $LN15@scan_tree
$LN4@scan_tree:

; 744  :         } else if (curlen == nextlen) {

  000b6	3b d7		 cmp	 edx, edi
  000b8	75 0b		 jne	 SHORT $LN2@scan_tree

; 745  :             max_count = 6, min_count = 3;

  000ba	b8 06 00 00 00	 mov	 eax, 6
  000bf	44 8d 48 fd	 lea	 r9d, QWORD PTR [rax-3]

; 746  :         } else {

  000c3	eb 09		 jmp	 SHORT $LN15@scan_tree
$LN2@scan_tree:

; 747  :             max_count = 7, min_count = 4;

  000c5	b8 07 00 00 00	 mov	 eax, 7
  000ca	44 8d 48 fd	 lea	 r9d, QWORD PTR [rax-3]
$LN15@scan_tree:

; 726  : 
; 727  :     for (n = 0; n <= max_code; n++) {

  000ce	49 83 c3 04	 add	 r11, 4
  000d2	49 ff c8	 dec	 r8
  000d5	0f 85 75 ff ff
	ff		 jne	 $LL16@scan_tree
$LN14@scan_tree:

; 748  :         }
; 749  :     }
; 750  : }

  000db	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  000e0	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
  000e5	c3		 ret	 0
scan_tree ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$send_tree DD imagerel send_tree
	DD	imagerel send_tree+51
	DD	imagerel $unwind$send_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$send_tree DD imagerel send_tree+51
	DD	imagerel send_tree+1383
	DD	imagerel $chain$2$send_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$send_tree DD imagerel send_tree+1383
	DD	imagerel send_tree+1390
	DD	imagerel $chain$3$send_tree
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$send_tree DD 021H
	DD	imagerel send_tree
	DD	imagerel send_tree+51
	DD	imagerel $unwind$send_tree
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$send_tree DD 060f21H
	DD	04c40fH
	DD	03740aH
	DD	025405H
	DD	imagerel send_tree
	DD	imagerel send_tree+51
	DD	imagerel $unwind$send_tree
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$send_tree DD 030601H
	DD	053406H
	DD	06006H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT send_tree
_TEXT	SEGMENT
s$ = 16
tree$ = 24
max_code$ = 32
send_tree PROC						; COMDAT

; 760  : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	56		 push	 rsi

; 761  :     int n;                     /* iterates over all tree elements */
; 762  :     int prevlen = -1;          /* last emitted length */
; 763  :     int curlen;                /* length of current code */
; 764  :     int nextlen = tree[0].Len; /* length of next code */

  00006	0f b7 72 02	 movzx	 esi, WORD PTR [rdx+2]
  0000a	41 83 cb ff	 or	 r11d, -1

; 765  :     int count = 0;             /* repeat count of the current code */

  0000e	45 33 d2	 xor	 r10d, r10d

; 766  :     int max_count = 7;         /* max repeat count */

  00011	41 8d 43 08	 lea	 eax, QWORD PTR [r11+8]
  00015	4c 8b c9	 mov	 r9, rcx
  00018	49 63 d8	 movsxd	 rbx, r8d

; 767  :     int min_count = 4;         /* min repeat count */

  0001b	8d 48 fd	 lea	 ecx, QWORD PTR [rax-3]

; 768  : 
; 769  :     /* tree[max_code+1].Len = -1; */  /* guard already set */
; 770  :     if (nextlen == 0) max_count = 138, min_count = 3;

  0001e	85 f6		 test	 esi, esi
  00020	75 08		 jne	 SHORT $LN36@send_tree
  00022	b8 8a 00 00 00	 mov	 eax, 138		; 0000008aH
  00027	8d 4e 03	 lea	 ecx, QWORD PTR [rsi+3]
$LN36@send_tree:

; 771  : 
; 772  :     for (n = 0; n <= max_code; n++) {

  0002a	45 85 c0	 test	 r8d, r8d
  0002d	0f 88 34 05 00
	00		 js	 $LN33@send_tree
  00033	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00038	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0003d	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  00042	4c 8d 63 01	 lea	 r12, QWORD PTR [rbx+1]
  00046	48 8d 6a 06	 lea	 rbp, QWORD PTR [rdx+6]
  0004a	66 0f 1f 44 00
	00		 npad	 6
$LL35@send_tree:

; 773  :         curlen = nextlen; nextlen = tree[n+1].Len;
; 774  :         if (++count < max_count && curlen == nextlen) {

  00050	41 ff c2	 inc	 r10d
  00053	48 63 fe	 movsxd	 rdi, esi
  00056	0f b7 75 00	 movzx	 esi, WORD PTR [rbp]
  0005a	44 3b d0	 cmp	 r10d, eax
  0005d	7d 08		 jge	 SHORT $LN32@send_tree
  0005f	3b fe		 cmp	 edi, esi
  00061	0f 84 e4 04 00
	00		 je	 $LN34@send_tree
$LN32@send_tree:

; 775  :             continue;
; 776  :         } else if (count < min_count) {

  00067	44 3b d1	 cmp	 r10d, ecx
  0006a	0f 8d b0 00 00
	00		 jge	 $LN30@send_tree
$LL29@send_tree:

; 777  :             do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

  00070	45 0f b7 9c b9
	a6 0a 00 00	 movzx	 r11d, WORD PTR [r9+rdi*4+2726]
  00079	41 8b 89 14 17
	00 00		 mov	 ecx, DWORD PTR [r9+5908]
  00080	b8 10 00 00 00	 mov	 eax, 16
  00085	41 2b c3	 sub	 eax, r11d
  00088	3b c8		 cmp	 ecx, eax
  0008a	7e 67		 jle	 SHORT $LN26@send_tree
  0008c	45 0f b7 84 b9
	a4 0a 00 00	 movzx	 r8d, WORD PTR [r9+rdi*4+2724]
  00095	41 8b 51 28	 mov	 edx, DWORD PTR [r9+40]
  00099	41 0f b7 c0	 movzx	 eax, r8w
  0009d	66 d3 e0	 shl	 ax, cl
  000a0	49 8b 49 10	 mov	 rcx, QWORD PTR [r9+16]
  000a4	66 41 09 81 10
	17 00 00	 or	 WORD PTR [r9+5904], ax
  000ac	41 0f b6 81 10
	17 00 00	 movzx	 eax, BYTE PTR [r9+5904]
  000b4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000b7	41 ff 41 28	 inc	 DWORD PTR [r9+40]
  000bb	41 8b 51 28	 mov	 edx, DWORD PTR [r9+40]
  000bf	41 0f b6 81 11
	17 00 00	 movzx	 eax, BYTE PTR [r9+5905]
  000c7	49 8b 49 10	 mov	 rcx, QWORD PTR [r9+16]
  000cb	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000ce	41 8b 91 14 17
	00 00		 mov	 edx, DWORD PTR [r9+5908]
  000d5	41 ff 41 28	 inc	 DWORD PTR [r9+40]
  000d9	b9 10 00 00 00	 mov	 ecx, 16
  000de	42 8d 44 1a f0	 lea	 eax, DWORD PTR [rdx+r11-16]
  000e3	2a ca		 sub	 cl, dl
  000e5	66 41 d3 e8	 shr	 r8w, cl
  000e9	66 45 89 81 10
	17 00 00	 mov	 WORD PTR [r9+5904], r8w
  000f1	eb 18		 jmp	 SHORT $LN42@send_tree
$LN26@send_tree:
  000f3	41 0f b7 84 b9
	a4 0a 00 00	 movzx	 eax, WORD PTR [r9+rdi*4+2724]
  000fc	66 d3 e0	 shl	 ax, cl
  000ff	66 41 09 81 10
	17 00 00	 or	 WORD PTR [r9+5904], ax
  00107	42 8d 04 19	 lea	 eax, DWORD PTR [rcx+r11]
$LN42@send_tree:
  0010b	41 ff ca	 dec	 r10d
  0010e	41 89 81 14 17
	00 00		 mov	 DWORD PTR [r9+5908], eax
  00115	0f 85 55 ff ff
	ff		 jne	 $LL29@send_tree

; 778  : 
; 779  :         } else if (curlen != 0) {

  0011b	e9 01 04 00 00	 jmp	 $LN5@send_tree
$LN30@send_tree:
  00120	85 ff		 test	 edi, edi
  00122	0f 84 c4 01 00
	00		 je	 $LN23@send_tree

; 780  :             if (curlen != prevlen) {

  00128	41 3b fb	 cmp	 edi, r11d
  0012b	0f 84 a5 00 00
	00		 je	 $LN22@send_tree

; 781  :                 send_code(s, curlen, s->bl_tree); count--;

  00131	45 0f b7 9c b9
	a6 0a 00 00	 movzx	 r11d, WORD PTR [r9+rdi*4+2726]
  0013a	41 8b 89 14 17
	00 00		 mov	 ecx, DWORD PTR [r9+5908]
  00141	b8 10 00 00 00	 mov	 eax, 16
  00146	41 2b c3	 sub	 eax, r11d
  00149	3b c8		 cmp	 ecx, eax
  0014b	7e 67		 jle	 SHORT $LN21@send_tree
  0014d	45 0f b7 84 b9
	a4 0a 00 00	 movzx	 r8d, WORD PTR [r9+rdi*4+2724]
  00156	41 8b 51 28	 mov	 edx, DWORD PTR [r9+40]
  0015a	41 0f b7 c0	 movzx	 eax, r8w
  0015e	66 d3 e0	 shl	 ax, cl
  00161	49 8b 49 10	 mov	 rcx, QWORD PTR [r9+16]
  00165	66 41 09 81 10
	17 00 00	 or	 WORD PTR [r9+5904], ax
  0016d	41 0f b6 81 10
	17 00 00	 movzx	 eax, BYTE PTR [r9+5904]
  00175	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00178	41 ff 41 28	 inc	 DWORD PTR [r9+40]
  0017c	41 8b 51 28	 mov	 edx, DWORD PTR [r9+40]
  00180	41 0f b6 81 11
	17 00 00	 movzx	 eax, BYTE PTR [r9+5905]
  00188	49 8b 49 10	 mov	 rcx, QWORD PTR [r9+16]
  0018c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0018f	41 8b 91 14 17
	00 00		 mov	 edx, DWORD PTR [r9+5908]
  00196	41 ff 41 28	 inc	 DWORD PTR [r9+40]
  0019a	b9 10 00 00 00	 mov	 ecx, 16
  0019f	42 8d 44 1a f0	 lea	 eax, DWORD PTR [rdx+r11-16]
  001a4	2a ca		 sub	 cl, dl
  001a6	66 41 d3 e8	 shr	 r8w, cl
  001aa	66 45 89 81 10
	17 00 00	 mov	 WORD PTR [r9+5904], r8w
  001b2	eb 18		 jmp	 SHORT $LN43@send_tree
$LN21@send_tree:
  001b4	41 0f b7 84 b9
	a4 0a 00 00	 movzx	 eax, WORD PTR [r9+rdi*4+2724]
  001bd	66 d3 e0	 shl	 ax, cl
  001c0	66 41 09 81 10
	17 00 00	 or	 WORD PTR [r9+5904], ax
  001c8	42 8d 04 19	 lea	 eax, DWORD PTR [rcx+r11]
$LN43@send_tree:
  001cc	41 89 81 14 17
	00 00		 mov	 DWORD PTR [r9+5908], eax
  001d3	41 ff ca	 dec	 r10d
$LN22@send_tree:

; 782  :             }
; 783  :             Assert(count >= 3 && count <= 6, " 3_6?");
; 784  :             send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

  001d6	45 0f b7 99 e6
	0a 00 00	 movzx	 r11d, WORD PTR [r9+2790]
  001de	41 8b 89 14 17
	00 00		 mov	 ecx, DWORD PTR [r9+5908]
  001e5	b8 10 00 00 00	 mov	 eax, 16
  001ea	41 2b c3	 sub	 eax, r11d
  001ed	3b c8		 cmp	 ecx, eax
  001ef	7e 66		 jle	 SHORT $LN19@send_tree
  001f1	41 8b 51 28	 mov	 edx, DWORD PTR [r9+40]
  001f5	45 0f b7 81 e4
	0a 00 00	 movzx	 r8d, WORD PTR [r9+2788]
  001fd	41 0f b7 c0	 movzx	 eax, r8w
  00201	66 d3 e0	 shl	 ax, cl
  00204	49 8b 49 10	 mov	 rcx, QWORD PTR [r9+16]
  00208	66 41 09 81 10
	17 00 00	 or	 WORD PTR [r9+5904], ax
  00210	41 0f b6 81 10
	17 00 00	 movzx	 eax, BYTE PTR [r9+5904]
  00218	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0021b	41 ff 41 28	 inc	 DWORD PTR [r9+40]
  0021f	41 8b 51 28	 mov	 edx, DWORD PTR [r9+40]
  00223	41 0f b6 81 11
	17 00 00	 movzx	 eax, BYTE PTR [r9+5905]
  0022b	49 8b 49 10	 mov	 rcx, QWORD PTR [r9+16]
  0022f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00232	41 8b 91 14 17
	00 00		 mov	 edx, DWORD PTR [r9+5908]
  00239	41 ff 41 28	 inc	 DWORD PTR [r9+40]
  0023d	b9 10 00 00 00	 mov	 ecx, 16
  00242	42 8d 44 1a f0	 lea	 eax, DWORD PTR [rdx+r11-16]
  00247	2a ca		 sub	 cl, dl
  00249	66 41 d3 e8	 shr	 r8w, cl
  0024d	66 45 89 81 10
	17 00 00	 mov	 WORD PTR [r9+5904], r8w
  00255	eb 17		 jmp	 SHORT $LN44@send_tree
$LN19@send_tree:
  00257	41 0f b7 81 e4
	0a 00 00	 movzx	 eax, WORD PTR [r9+2788]
  0025f	66 d3 e0	 shl	 ax, cl
  00262	66 41 09 81 10
	17 00 00	 or	 WORD PTR [r9+5904], ax
  0026a	42 8d 04 19	 lea	 eax, DWORD PTR [rcx+r11]
$LN44@send_tree:
  0026e	41 89 81 14 17
	00 00		 mov	 DWORD PTR [r9+5908], eax
  00275	8b c8		 mov	 ecx, eax
  00277	83 f8 0e	 cmp	 eax, 14
  0027a	7e 63		 jle	 SHORT $LN17@send_tree
  0027c	41 8b 51 28	 mov	 edx, DWORD PTR [r9+40]
  00280	45 8d 42 fd	 lea	 r8d, DWORD PTR [r10-3]
  00284	41 0f b7 c0	 movzx	 eax, r8w
  00288	66 d3 e0	 shl	 ax, cl
  0028b	49 8b 49 10	 mov	 rcx, QWORD PTR [r9+16]
  0028f	66 41 09 81 10
	17 00 00	 or	 WORD PTR [r9+5904], ax
  00297	41 0f b6 81 10
	17 00 00	 movzx	 eax, BYTE PTR [r9+5904]
  0029f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  002a2	41 ff 41 28	 inc	 DWORD PTR [r9+40]
  002a6	41 8b 51 28	 mov	 edx, DWORD PTR [r9+40]
  002aa	41 0f b6 81 11
	17 00 00	 movzx	 eax, BYTE PTR [r9+5905]
  002b2	49 8b 49 10	 mov	 rcx, QWORD PTR [r9+16]
  002b6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  002b9	41 8b 91 14 17
	00 00		 mov	 edx, DWORD PTR [r9+5908]
  002c0	41 ff 41 28	 inc	 DWORD PTR [r9+40]
  002c4	b9 10 00 00 00	 mov	 ecx, 16
  002c9	8d 42 f2	 lea	 eax, DWORD PTR [rdx-14]
  002cc	2a ca		 sub	 cl, dl
  002ce	66 41 d3 e8	 shr	 r8w, cl
  002d2	66 45 89 81 10
	17 00 00	 mov	 WORD PTR [r9+5904], r8w
  002da	e9 3b 02 00 00	 jmp	 $LN45@send_tree
$LN17@send_tree:
  002df	66 41 83 ea 03	 sub	 r10w, 3
  002e4	8d 41 02	 lea	 eax, DWORD PTR [rcx+2]
  002e7	e9 22 02 00 00	 jmp	 $LN46@send_tree
$LN23@send_tree:

; 785  : 
; 786  :         } else if (count <= 10) {
; 787  :             send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

  002ec	41 8b 89 14 17
	00 00		 mov	 ecx, DWORD PTR [r9+5908]
  002f3	b8 10 00 00 00	 mov	 eax, 16
  002f8	41 83 fa 0a	 cmp	 r10d, 10
  002fc	0f 8f 0a 01 00
	00		 jg	 $LN14@send_tree
  00302	45 0f b7 99 ea
	0a 00 00	 movzx	 r11d, WORD PTR [r9+2794]
  0030a	41 2b c3	 sub	 eax, r11d
  0030d	3b c8		 cmp	 ecx, eax
  0030f	7e 66		 jle	 SHORT $LN13@send_tree
  00311	41 8b 51 28	 mov	 edx, DWORD PTR [r9+40]
  00315	45 0f b7 81 e8
	0a 00 00	 movzx	 r8d, WORD PTR [r9+2792]
  0031d	41 0f b7 c0	 movzx	 eax, r8w
  00321	66 d3 e0	 shl	 ax, cl
  00324	49 8b 49 10	 mov	 rcx, QWORD PTR [r9+16]
  00328	66 41 09 81 10
	17 00 00	 or	 WORD PTR [r9+5904], ax
  00330	41 0f b6 81 10
	17 00 00	 movzx	 eax, BYTE PTR [r9+5904]
  00338	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0033b	41 ff 41 28	 inc	 DWORD PTR [r9+40]
  0033f	41 8b 51 28	 mov	 edx, DWORD PTR [r9+40]
  00343	41 0f b6 81 11
	17 00 00	 movzx	 eax, BYTE PTR [r9+5905]
  0034b	49 8b 49 10	 mov	 rcx, QWORD PTR [r9+16]
  0034f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00352	41 8b 91 14 17
	00 00		 mov	 edx, DWORD PTR [r9+5908]
  00359	41 ff 41 28	 inc	 DWORD PTR [r9+40]
  0035d	b9 10 00 00 00	 mov	 ecx, 16
  00362	42 8d 44 1a f0	 lea	 eax, DWORD PTR [rdx+r11-16]
  00367	2a ca		 sub	 cl, dl
  00369	66 41 d3 e8	 shr	 r8w, cl
  0036d	66 45 89 81 10
	17 00 00	 mov	 WORD PTR [r9+5904], r8w
  00375	eb 17		 jmp	 SHORT $LN47@send_tree
$LN13@send_tree:
  00377	41 0f b7 81 e8
	0a 00 00	 movzx	 eax, WORD PTR [r9+2792]
  0037f	66 d3 e0	 shl	 ax, cl
  00382	66 41 09 81 10
	17 00 00	 or	 WORD PTR [r9+5904], ax
  0038a	42 8d 04 19	 lea	 eax, DWORD PTR [rcx+r11]
$LN47@send_tree:
  0038e	41 89 81 14 17
	00 00		 mov	 DWORD PTR [r9+5908], eax
  00395	8b c8		 mov	 ecx, eax
  00397	83 f8 0d	 cmp	 eax, 13
  0039a	7e 63		 jle	 SHORT $LN11@send_tree
  0039c	41 8b 51 28	 mov	 edx, DWORD PTR [r9+40]
  003a0	45 8d 42 fd	 lea	 r8d, DWORD PTR [r10-3]
  003a4	41 0f b7 c0	 movzx	 eax, r8w
  003a8	66 d3 e0	 shl	 ax, cl
  003ab	49 8b 49 10	 mov	 rcx, QWORD PTR [r9+16]
  003af	66 41 09 81 10
	17 00 00	 or	 WORD PTR [r9+5904], ax
  003b7	41 0f b6 81 10
	17 00 00	 movzx	 eax, BYTE PTR [r9+5904]
  003bf	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003c2	41 ff 41 28	 inc	 DWORD PTR [r9+40]
  003c6	41 8b 51 28	 mov	 edx, DWORD PTR [r9+40]
  003ca	41 0f b6 81 11
	17 00 00	 movzx	 eax, BYTE PTR [r9+5905]
  003d2	49 8b 49 10	 mov	 rcx, QWORD PTR [r9+16]
  003d6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003d9	41 8b 91 14 17
	00 00		 mov	 edx, DWORD PTR [r9+5908]
  003e0	41 ff 41 28	 inc	 DWORD PTR [r9+40]
  003e4	b9 10 00 00 00	 mov	 ecx, 16
  003e9	8d 42 f3	 lea	 eax, DWORD PTR [rdx-13]
  003ec	2a ca		 sub	 cl, dl
  003ee	66 41 d3 e8	 shr	 r8w, cl
  003f2	66 45 89 81 10
	17 00 00	 mov	 WORD PTR [r9+5904], r8w
  003fa	e9 1b 01 00 00	 jmp	 $LN45@send_tree
$LN11@send_tree:
  003ff	66 41 83 ea 03	 sub	 r10w, 3
  00404	8d 41 03	 lea	 eax, DWORD PTR [rcx+3]

; 788  : 
; 789  :         } else {

  00407	e9 02 01 00 00	 jmp	 $LN46@send_tree
$LN14@send_tree:

; 790  :             send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);

  0040c	45 0f b7 99 ee
	0a 00 00	 movzx	 r11d, WORD PTR [r9+2798]
  00414	41 2b c3	 sub	 eax, r11d
  00417	3b c8		 cmp	 ecx, eax
  00419	7e 66		 jle	 SHORT $LN8@send_tree
  0041b	41 8b 51 28	 mov	 edx, DWORD PTR [r9+40]
  0041f	45 0f b7 81 ec
	0a 00 00	 movzx	 r8d, WORD PTR [r9+2796]
  00427	41 0f b7 c0	 movzx	 eax, r8w
  0042b	66 d3 e0	 shl	 ax, cl
  0042e	49 8b 49 10	 mov	 rcx, QWORD PTR [r9+16]
  00432	66 41 09 81 10
	17 00 00	 or	 WORD PTR [r9+5904], ax
  0043a	41 0f b6 81 10
	17 00 00	 movzx	 eax, BYTE PTR [r9+5904]
  00442	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00445	41 ff 41 28	 inc	 DWORD PTR [r9+40]
  00449	41 8b 51 28	 mov	 edx, DWORD PTR [r9+40]
  0044d	41 0f b6 81 11
	17 00 00	 movzx	 eax, BYTE PTR [r9+5905]
  00455	49 8b 49 10	 mov	 rcx, QWORD PTR [r9+16]
  00459	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0045c	41 8b 91 14 17
	00 00		 mov	 edx, DWORD PTR [r9+5908]
  00463	41 ff 41 28	 inc	 DWORD PTR [r9+40]
  00467	b9 10 00 00 00	 mov	 ecx, 16
  0046c	42 8d 44 1a f0	 lea	 eax, DWORD PTR [rdx+r11-16]
  00471	2a ca		 sub	 cl, dl
  00473	66 41 d3 e8	 shr	 r8w, cl
  00477	66 45 89 81 10
	17 00 00	 mov	 WORD PTR [r9+5904], r8w
  0047f	eb 17		 jmp	 SHORT $LN48@send_tree
$LN8@send_tree:
  00481	41 0f b7 81 ec
	0a 00 00	 movzx	 eax, WORD PTR [r9+2796]
  00489	66 d3 e0	 shl	 ax, cl
  0048c	66 41 09 81 10
	17 00 00	 or	 WORD PTR [r9+5904], ax
  00494	42 8d 04 19	 lea	 eax, DWORD PTR [rcx+r11]
$LN48@send_tree:
  00498	41 89 81 14 17
	00 00		 mov	 DWORD PTR [r9+5908], eax
  0049f	8b c8		 mov	 ecx, eax
  004a1	83 f8 09	 cmp	 eax, 9
  004a4	7e 60		 jle	 SHORT $LN6@send_tree
  004a6	41 8b 51 28	 mov	 edx, DWORD PTR [r9+40]
  004aa	45 8d 42 f5	 lea	 r8d, DWORD PTR [r10-11]
  004ae	41 0f b7 c0	 movzx	 eax, r8w
  004b2	66 d3 e0	 shl	 ax, cl
  004b5	49 8b 49 10	 mov	 rcx, QWORD PTR [r9+16]
  004b9	66 41 09 81 10
	17 00 00	 or	 WORD PTR [r9+5904], ax
  004c1	41 0f b6 81 10
	17 00 00	 movzx	 eax, BYTE PTR [r9+5904]
  004c9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  004cc	41 ff 41 28	 inc	 DWORD PTR [r9+40]
  004d0	41 8b 51 28	 mov	 edx, DWORD PTR [r9+40]
  004d4	41 0f b6 81 11
	17 00 00	 movzx	 eax, BYTE PTR [r9+5905]
  004dc	49 8b 49 10	 mov	 rcx, QWORD PTR [r9+16]
  004e0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  004e3	41 8b 91 14 17
	00 00		 mov	 edx, DWORD PTR [r9+5908]
  004ea	41 ff 41 28	 inc	 DWORD PTR [r9+40]
  004ee	b9 10 00 00 00	 mov	 ecx, 16
  004f3	8d 42 f7	 lea	 eax, DWORD PTR [rdx-9]
  004f6	2a ca		 sub	 cl, dl
  004f8	66 41 d3 e8	 shr	 r8w, cl
  004fc	66 45 89 81 10
	17 00 00	 mov	 WORD PTR [r9+5904], r8w
  00504	eb 14		 jmp	 SHORT $LN45@send_tree
$LN6@send_tree:
  00506	66 41 83 ea 0b	 sub	 r10w, 11
  0050b	8d 41 07	 lea	 eax, DWORD PTR [rcx+7]
$LN46@send_tree:
  0050e	66 41 d3 e2	 shl	 r10w, cl
  00512	66 45 09 91 10
	17 00 00	 or	 WORD PTR [r9+5904], r10w
$LN45@send_tree:
  0051a	41 89 81 14 17
	00 00		 mov	 DWORD PTR [r9+5908], eax
$LN5@send_tree:

; 791  :         }
; 792  :         count = 0; prevlen = curlen;

  00521	45 33 d2	 xor	 r10d, r10d
  00524	44 8b df	 mov	 r11d, edi

; 793  :         if (nextlen == 0) {

  00527	85 f6		 test	 esi, esi
  00529	75 0a		 jne	 SHORT $LN4@send_tree

; 794  :             max_count = 138, min_count = 3;

  0052b	b8 8a 00 00 00	 mov	 eax, 138		; 0000008aH
  00530	8d 4e 03	 lea	 ecx, QWORD PTR [rsi+3]
  00533	eb 16		 jmp	 SHORT $LN34@send_tree
$LN4@send_tree:

; 795  :         } else if (curlen == nextlen) {

  00535	3b fe		 cmp	 edi, esi
  00537	75 0a		 jne	 SHORT $LN2@send_tree

; 796  :             max_count = 6, min_count = 3;

  00539	b8 06 00 00 00	 mov	 eax, 6
  0053e	8d 48 fd	 lea	 ecx, QWORD PTR [rax-3]

; 797  :         } else {

  00541	eb 08		 jmp	 SHORT $LN34@send_tree
$LN2@send_tree:

; 798  :             max_count = 7, min_count = 4;

  00543	b8 07 00 00 00	 mov	 eax, 7
  00548	8d 48 fd	 lea	 ecx, QWORD PTR [rax-3]
$LN34@send_tree:

; 771  : 
; 772  :     for (n = 0; n <= max_code; n++) {

  0054b	48 83 c5 04	 add	 rbp, 4
  0054f	49 ff cc	 dec	 r12
  00552	0f 85 f8 fa ff
	ff		 jne	 $LL35@send_tree
  00558	4c 8b 64 24 20	 mov	 r12, QWORD PTR [rsp+32]
  0055d	48 8b 7c 24 18	 mov	 rdi, QWORD PTR [rsp+24]
  00562	48 8b 6c 24 10	 mov	 rbp, QWORD PTR [rsp+16]
$LN33@send_tree:

; 799  :         }
; 800  :     }
; 801  : }

  00567	48 8b 5c 24 28	 mov	 rbx, QWORD PTR [rsp+40]
  0056c	5e		 pop	 rsi
  0056d	c3		 ret	 0
send_tree ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$send_all_trees DD imagerel send_all_trees
	DD	imagerel send_all_trees+616
	DD	imagerel $unwind$send_all_trees
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$send_all_trees DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT send_all_trees
_TEXT	SEGMENT
s$ = 48
lcodes$ = 56
dcodes$ = 64
blcodes$ = 72
send_all_trees PROC					; COMDAT

; 845  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b d9	 mov	 rbx, rcx

; 846  :     int rank;                    /* index in bl_order */
; 847  : 
; 848  :     Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
; 849  :     Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
; 850  :             "too many codes");
; 851  :     Tracev((stderr, "\nbl counts: "));
; 852  :     send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */

  00012	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00018	45 8b d9	 mov	 r11d, r9d
  0001b	41 8b f8	 mov	 edi, r8d
  0001e	8b f2		 mov	 esi, edx
  00020	83 f9 0b	 cmp	 ecx, 11
  00023	7e 5b		 jle	 SHORT $LN11@send_all_t
  00025	44 8d 92 ff fe
	ff ff		 lea	 r10d, DWORD PTR [rdx-257]
  0002c	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  0002f	41 0f b7 c2	 movzx	 eax, r10w
  00033	66 d3 e0	 shl	 ax, cl
  00036	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0003a	66 09 83 10 17
	00 00		 or	 WORD PTR [rbx+5904], ax
  00041	0f b6 83 10 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5904]
  00048	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0004b	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0004e	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  00051	0f b6 83 11 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5905]
  00058	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0005c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0005f	8b 93 14 17 00
	00		 mov	 edx, DWORD PTR [rbx+5908]
  00065	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00068	b9 10 00 00 00	 mov	 ecx, 16
  0006d	8d 42 f5	 lea	 eax, DWORD PTR [rdx-11]
  00070	2a ca		 sub	 cl, dl
  00072	66 41 d3 ea	 shr	 r10w, cl
  00076	66 44 89 93 10
	17 00 00	 mov	 WORD PTR [rbx+5904], r10w
  0007e	eb 18		 jmp	 SHORT $LN16@send_all_t
$LN11@send_all_t:
  00080	0f b7 c6	 movzx	 eax, si
  00083	ba 01 01 00 00	 mov	 edx, 257		; 00000101H
  00088	66 2b c2	 sub	 ax, dx
  0008b	66 d3 e0	 shl	 ax, cl
  0008e	66 09 83 10 17
	00 00		 or	 WORD PTR [rbx+5904], ax
  00095	8d 41 05	 lea	 eax, DWORD PTR [rcx+5]
$LN16@send_all_t:
  00098	89 83 14 17 00
	00		 mov	 DWORD PTR [rbx+5908], eax

; 853  :     send_bits(s, dcodes-1,   5);

  0009e	8b c8		 mov	 ecx, eax
  000a0	83 f8 0b	 cmp	 eax, 11
  000a3	7e 57		 jle	 SHORT $LN9@send_all_t
  000a5	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  000a8	41 ff c8	 dec	 r8d
  000ab	41 0f b7 c0	 movzx	 eax, r8w
  000af	66 d3 e0	 shl	 ax, cl
  000b2	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  000b6	66 09 83 10 17
	00 00		 or	 WORD PTR [rbx+5904], ax
  000bd	0f b6 83 10 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5904]
  000c4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000c7	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000ca	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  000cd	0f b6 83 11 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5905]
  000d4	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  000d8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000db	8b 93 14 17 00
	00		 mov	 edx, DWORD PTR [rbx+5908]
  000e1	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000e4	b9 10 00 00 00	 mov	 ecx, 16
  000e9	8d 42 f5	 lea	 eax, DWORD PTR [rdx-11]
  000ec	2a ca		 sub	 cl, dl
  000ee	66 41 d3 e8	 shr	 r8w, cl
  000f2	66 44 89 83 10
	17 00 00	 mov	 WORD PTR [rbx+5904], r8w
  000fa	eb 11		 jmp	 SHORT $LN17@send_all_t
$LN9@send_all_t:
  000fc	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  00100	66 d3 e0	 shl	 ax, cl
  00103	66 09 83 10 17
	00 00		 or	 WORD PTR [rbx+5904], ax
  0010a	8d 41 05	 lea	 eax, DWORD PTR [rcx+5]
$LN17@send_all_t:
  0010d	89 83 14 17 00
	00		 mov	 DWORD PTR [rbx+5908], eax

; 854  :     send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */

  00113	8b c8		 mov	 ecx, eax
  00115	83 f8 0c	 cmp	 eax, 12
  00118	7e 58		 jle	 SHORT $LN7@send_all_t
  0011a	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  0011d	45 8d 43 fc	 lea	 r8d, DWORD PTR [r11-4]
  00121	41 0f b7 c0	 movzx	 eax, r8w
  00125	66 d3 e0	 shl	 ax, cl
  00128	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0012c	66 09 83 10 17
	00 00		 or	 WORD PTR [rbx+5904], ax
  00133	0f b6 83 10 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5904]
  0013a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0013d	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00140	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  00143	0f b6 83 11 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5905]
  0014a	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0014e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00151	8b 93 14 17 00
	00		 mov	 edx, DWORD PTR [rbx+5908]
  00157	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0015a	b9 10 00 00 00	 mov	 ecx, 16
  0015f	8d 42 f4	 lea	 eax, DWORD PTR [rdx-12]
  00162	2a ca		 sub	 cl, dl
  00164	66 41 d3 e8	 shr	 r8w, cl
  00168	66 44 89 83 10
	17 00 00	 mov	 WORD PTR [rbx+5904], r8w
  00170	eb 11		 jmp	 SHORT $LN18@send_all_t
$LN7@send_all_t:
  00172	41 8d 43 fc	 lea	 eax, DWORD PTR [r11-4]
  00176	66 d3 e0	 shl	 ax, cl
  00179	66 09 83 10 17
	00 00		 or	 WORD PTR [rbx+5904], ax
  00180	8d 41 04	 lea	 eax, DWORD PTR [rcx+4]
$LN18@send_all_t:
  00183	89 83 14 17 00
	00		 mov	 DWORD PTR [rbx+5908], eax

; 855  :     for (rank = 0; rank < blcodes; rank++) {

  00189	45 85 db	 test	 r11d, r11d
  0018c	0f 8e a1 00 00
	00		 jle	 $LN3@send_all_t
  00192	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:bl_order
  00199	4d 8b d3	 mov	 r10, r11
  0019c	0f 1f 40 00	 npad	 4
$LL5@send_all_t:

; 856  :         Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
; 857  :         send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);

  001a0	8b 8b 14 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5908]
  001a6	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  001aa	83 f9 0d	 cmp	 ecx, 13
  001ad	7e 5d		 jle	 SHORT $LN2@send_all_t
  001af	44 0f b7 84 83
	a6 0a 00 00	 movzx	 r8d, WORD PTR [rbx+rax*4+2726]
  001b8	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  001bb	41 0f b7 c0	 movzx	 eax, r8w
  001bf	66 d3 e0	 shl	 ax, cl
  001c2	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  001c6	66 09 83 10 17
	00 00		 or	 WORD PTR [rbx+5904], ax
  001cd	0f b6 83 10 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5904]
  001d4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001d7	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001da	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  001dd	0f b6 83 11 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5905]
  001e4	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  001e8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001eb	8b 93 14 17 00
	00		 mov	 edx, DWORD PTR [rbx+5908]
  001f1	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001f4	b9 10 00 00 00	 mov	 ecx, 16
  001f9	8d 42 f3	 lea	 eax, DWORD PTR [rdx-13]
  001fc	2a ca		 sub	 cl, dl
  001fe	66 41 d3 e8	 shr	 r8w, cl
  00202	66 44 89 83 10
	17 00 00	 mov	 WORD PTR [rbx+5904], r8w
  0020a	eb 15		 jmp	 SHORT $LN19@send_all_t
$LN2@send_all_t:
  0020c	0f b7 94 83 a6
	0a 00 00	 movzx	 edx, WORD PTR [rbx+rax*4+2726]
  00214	8d 41 03	 lea	 eax, DWORD PTR [rcx+3]
  00217	66 d3 e2	 shl	 dx, cl
  0021a	66 09 93 10 17
	00 00		 or	 WORD PTR [rbx+5904], dx
$LN19@send_all_t:

; 855  :     for (rank = 0; rank < blcodes; rank++) {

  00221	49 ff c1	 inc	 r9
  00224	49 ff ca	 dec	 r10

; 856  :         Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
; 857  :         send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);

  00227	89 83 14 17 00
	00		 mov	 DWORD PTR [rbx+5908], eax
  0022d	0f 85 6d ff ff
	ff		 jne	 $LL5@send_all_t
$LN3@send_all_t:

; 858  :     }
; 859  :     Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
; 860  : 
; 861  :     send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */

  00233	44 8d 46 ff	 lea	 r8d, DWORD PTR [rsi-1]
  00237	48 8d 93 bc 00
	00 00		 lea	 rdx, QWORD PTR [rbx+188]
  0023e	48 8b cb	 mov	 rcx, rbx
  00241	e8 00 00 00 00	 call	 send_tree

; 862  :     Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
; 863  : 
; 864  :     send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */

  00246	44 8d 47 ff	 lea	 r8d, DWORD PTR [rdi-1]
  0024a	48 8d 93 b0 09
	00 00		 lea	 rdx, QWORD PTR [rbx+2480]
  00251	48 8b cb	 mov	 rcx, rbx

; 865  :     Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
; 866  : }

  00254	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00259	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0025e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00262	5f		 pop	 rdi
  00263	e9 00 00 00 00	 jmp	 send_tree
send_all_trees ENDP
_TEXT	ENDS
PUBLIC	_tr_tally
EXTRN	__ImageBase:BYTE
; Function compile flags: /Ogtpy
;	COMDAT _tr_tally
_TEXT	SEGMENT
s$ = 8
dist$ = 16
lc$ = 24
_tr_tally PROC						; COMDAT

; 1031 :     s->d_buf[s->last_lit] = (ush)dist;

  00000	44 8b 89 f4 16
	00 00		 mov	 r9d, DWORD PTR [rcx+5876]
  00007	48 8b 81 f8 16
	00 00		 mov	 rax, QWORD PTR [rcx+5880]
  0000e	4c 8b d1	 mov	 r10, rcx
  00011	66 42 89 14 48	 mov	 WORD PTR [rax+r9*2], dx

; 1032 :     s->l_buf[s->last_lit++] = (uch)lc;

  00016	44 8b 89 f4 16
	00 00		 mov	 r9d, DWORD PTR [rcx+5876]
  0001d	48 8b 81 e8 16
	00 00		 mov	 rax, QWORD PTR [rcx+5864]
  00024	45 88 04 01	 mov	 BYTE PTR [r9+rax], r8b
  00028	ff 81 f4 16 00
	00		 inc	 DWORD PTR [rcx+5876]

; 1033 :     if (dist == 0) {
; 1034 :         /* lc is the unmatched char */
; 1035 :         s->dyn_ltree[lc].Freq++;

  0002e	41 8b c0	 mov	 eax, r8d
  00031	85 d2		 test	 edx, edx
  00033	75 0a		 jne	 SHORT $LN2@tr_tally
  00035	66 ff 84 81 bc
	00 00 00	 inc	 WORD PTR [rcx+rax*4+188]

; 1036 :     } else {

  0003d	eb 45		 jmp	 SHORT $LN1@tr_tally
$LN2@tr_tally:

; 1037 :         s->matches++;

  0003f	ff 81 08 17 00
	00		 inc	 DWORD PTR [rcx+5896]

; 1038 :         /* Here, lc is the match length - MIN_MATCH */
; 1039 :         dist--;             /* dist = match distance - 1 */
; 1040 :         Assert((ush)dist < (ush)MAX_DIST(s) &&
; 1041 :                (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
; 1042 :                (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
; 1043 : 
; 1044 :         s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;

  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0004c	ff ca		 dec	 edx
  0004e	0f b6 84 08 00
	00 00 00	 movzx	 eax, BYTE PTR _length_code[rax+rcx]
  00056	66 41 ff 84 82
	c0 04 00 00	 inc	 WORD PTR [r10+rax*4+1216]

; 1045 :         s->dyn_dtree[d_code(dist)].Freq++;

  0005f	81 fa 00 01 00
	00		 cmp	 edx, 256		; 00000100H
  00065	72 09		 jb	 SHORT $LN7@tr_tally
  00067	c1 ea 07	 shr	 edx, 7
  0006a	81 c2 00 01 00
	00		 add	 edx, 256		; 00000100H
$LN7@tr_tally:
  00070	0f b6 8c 0a 00
	00 00 00	 movzx	 ecx, BYTE PTR _dist_code[rdx+rcx]
  00078	48 63 c1	 movsxd	 rax, ecx
  0007b	66 41 ff 84 82
	b0 09 00 00	 inc	 WORD PTR [r10+rax*4+2480]
$LN1@tr_tally:

; 1046 :     }
; 1047 : 
; 1048 : #ifdef TRUNCATE_BLOCK
; 1049 :     /* Try to guess if it is profitable to stop the current block here */
; 1050 :     if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
; 1051 :         /* Compute an upper bound for the compressed length */
; 1052 :         ulg out_length = (ulg)s->last_lit*8L;
; 1053 :         ulg in_length = (ulg)((long)s->strstart - s->block_start);
; 1054 :         int dcode;
; 1055 :         for (dcode = 0; dcode < D_CODES; dcode++) {
; 1056 :             out_length += (ulg)s->dyn_dtree[dcode].Freq *
; 1057 :                 (5L+extra_dbits[dcode]);
; 1058 :         }
; 1059 :         out_length >>= 3;
; 1060 :         Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
; 1061 :                s->last_lit, in_length, out_length,
; 1062 :                100L - out_length*100L/in_length));
; 1063 :         if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
; 1064 :     }
; 1065 : #endif
; 1066 :     return (s->last_lit == s->lit_bufsize-1);

  00084	41 8b 8a f0 16
	00 00		 mov	 ecx, DWORD PTR [r10+5872]
  0008b	33 c0		 xor	 eax, eax
  0008d	ff c9		 dec	 ecx
  0008f	41 39 8a f4 16
	00 00		 cmp	 DWORD PTR [r10+5876], ecx
  00096	0f 94 c0	 sete	 al

; 1067 :     /* We avoid equality with lit_bufsize because of wraparound at 64K
; 1068 :      * on 16 bit machines and because stored blocks are restricted to
; 1069 :      * 64K-1 bytes.
; 1070 :      */
; 1071 : }

  00099	c3		 ret	 0
_tr_tally ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compress_block DD imagerel compress_block
	DD	imagerel compress_block+7
	DD	imagerel $unwind$compress_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$compress_block DD imagerel compress_block+7
	DD	imagerel compress_block+43
	DD	imagerel $chain$1$compress_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$compress_block DD imagerel compress_block+43
	DD	imagerel compress_block+942
	DD	imagerel $chain$5$compress_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$compress_block DD imagerel compress_block+942
	DD	imagerel compress_block+976
	DD	imagerel $chain$6$compress_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$compress_block DD imagerel compress_block+976
	DD	imagerel compress_block+1128
	DD	imagerel $chain$7$compress_block
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$compress_block DD 021H
	DD	imagerel compress_block
	DD	imagerel compress_block+7
	DD	imagerel $unwind$compress_block
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$compress_block DD 021H
	DD	imagerel compress_block+7
	DD	imagerel compress_block+43
	DD	imagerel $chain$1$compress_block
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$compress_block DD 081321H
	DD	08c413H
	DD	07640eH
	DD	0f409H
	DD	02d405H
	DD	imagerel compress_block+7
	DD	imagerel compress_block+43
	DD	imagerel $chain$1$compress_block
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$compress_block DD 040c21H
	DD	01e40cH
	DD	065405H
	DD	imagerel compress_block
	DD	imagerel compress_block+7
	DD	imagerel $unwind$compress_block
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compress_block DD 030701H
	DD	070032207H
	DD	03002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compress_block
_TEXT	SEGMENT
s$ = 48
ltree$ = 56
dtree$ = 64
compress_block PROC					; COMDAT

; 1080 : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	48 83 ec 18	 sub	 rsp, 24
  00007	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp

; 1081 :     unsigned dist;      /* distance of matched string */
; 1082 :     int lc;             /* match length or unmatched char (if dist == 0) */
; 1083 :     unsigned lx = 0;    /* running index in l_buf */

  0000c	33 ed		 xor	 ebp, ebp
  0000e	4c 89 74 24 08	 mov	 QWORD PTR [rsp+8], r14
  00013	4d 8b f0	 mov	 r14, r8
  00016	48 8b fa	 mov	 rdi, rdx
  00019	4c 8b d1	 mov	 r10, rcx

; 1084 :     unsigned code;      /* the code to send */
; 1085 :     int extra;          /* number of extra bits to send */
; 1086 : 
; 1087 :     if (s->last_lit != 0) do {

  0001c	8d 5d 10	 lea	 ebx, QWORD PTR [rbp+16]
  0001f	39 a9 f4 16 00
	00		 cmp	 DWORD PTR [rcx+5876], ebp
  00025	0f 84 83 03 00
	00		 je	 $LN17@compress_b

; 1081 :     unsigned dist;      /* distance of matched string */
; 1082 :     int lc;             /* match length or unmatched char (if dist == 0) */
; 1083 :     unsigned lx = 0;    /* running index in l_buf */

  0002b	4c 89 6c 24 10	 mov	 QWORD PTR [rsp+16], r13
  00030	4c 89 3c 24	 mov	 QWORD PTR [rsp], r15
  00034	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00039	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12
  0003e	44 8b ed	 mov	 r13d, ebp
  00041	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:__ImageBase
  00048	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL19@compress_b:

; 1088 :         dist = s->d_buf[lx];

  00050	49 8b 82 f8 16
	00 00		 mov	 rax, QWORD PTR [r10+5880]

; 1089 :         lc = s->l_buf[lx++];

  00057	8b cd		 mov	 ecx, ebp
  00059	49 83 c5 02	 add	 r13, 2
  0005d	46 0f b7 4c 28
	fe		 movzx	 r9d, WORD PTR [rax+r13-2]
  00063	49 8b 82 e8 16
	00 00		 mov	 rax, QWORD PTR [r10+5864]
  0006a	ff c5		 inc	 ebp
  0006c	44 0f b6 1c 01	 movzx	 r11d, BYTE PTR [rcx+rax]

; 1090 :         if (dist == 0) {
; 1091 :             send_code(s, lc, ltree); /* send a literal byte */

  00071	41 8b 8a 14 17
	00 00		 mov	 ecx, DWORD PTR [r10+5908]
  00078	45 85 c9	 test	 r9d, r9d
  0007b	0f 85 8d 00 00
	00		 jne	 $LN16@compress_b
  00081	49 63 d3	 movsxd	 rdx, r11d
  00084	8b c3		 mov	 eax, ebx
  00086	44 0f b7 4c 97
	02		 movzx	 r9d, WORD PTR [rdi+rdx*4+2]
  0008c	41 2b c1	 sub	 eax, r9d
  0008f	3b c8		 cmp	 ecx, eax
  00091	7e 63		 jle	 SHORT $LN15@compress_b
  00093	44 0f b7 04 97	 movzx	 r8d, WORD PTR [rdi+rdx*4]
  00098	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  0009c	41 0f b7 c0	 movzx	 eax, r8w
  000a0	66 d3 e0	 shl	 ax, cl
  000a3	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  000a7	66 41 09 82 10
	17 00 00	 or	 WORD PTR [r10+5904], ax
  000af	41 0f b6 82 10
	17 00 00	 movzx	 eax, BYTE PTR [r10+5904]
  000b7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000ba	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  000be	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  000c2	41 0f b6 82 11
	17 00 00	 movzx	 eax, BYTE PTR [r10+5905]
  000ca	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  000ce	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000d1	41 8b 92 14 17
	00 00		 mov	 edx, DWORD PTR [r10+5908]
  000d8	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  000dc	8b cb		 mov	 ecx, ebx
  000de	42 8d 44 0a f0	 lea	 eax, DWORD PTR [rdx+r9-16]
  000e3	2a ca		 sub	 cl, dl
  000e5	66 41 d3 e8	 shr	 r8w, cl
  000e9	66 45 89 82 10
	17 00 00	 mov	 WORD PTR [r10+5904], r8w
  000f1	e9 91 02 00 00	 jmp	 $LN26@compress_b
$LN15@compress_b:
  000f6	0f b7 04 97	 movzx	 eax, WORD PTR [rdi+rdx*4]
  000fa	66 d3 e0	 shl	 ax, cl
  000fd	66 41 09 82 10
	17 00 00	 or	 WORD PTR [r10+5904], ax
  00105	42 8d 04 09	 lea	 eax, DWORD PTR [rcx+r9]

; 1092 :             Tracecv(isgraph(lc), (stderr," '%c' ", lc));
; 1093 :         } else {

  00109	e9 79 02 00 00	 jmp	 $LN26@compress_b
$LN16@compress_b:

; 1094 :             /* Here, lc is the match length - MIN_MATCH */
; 1095 :             code = _length_code[lc];

  0010e	47 0f b6 a4 3b
	00 00 00 00	 movzx	 r12d, BYTE PTR _length_code[r11+r15]

; 1096 :             send_code(s, code+LITERALS+1, ltree); /* send the length code */

  00117	41 8d 84 24 01
	01 00 00	 lea	 eax, DWORD PTR [r12+257]
  0011f	8b d0		 mov	 edx, eax
  00121	0f b7 74 87 02	 movzx	 esi, WORD PTR [rdi+rax*4+2]
  00126	8b c3		 mov	 eax, ebx
  00128	2b c6		 sub	 eax, esi
  0012a	3b c8		 cmp	 ecx, eax
  0012c	7e 5f		 jle	 SHORT $LN12@compress_b
  0012e	44 0f b7 04 97	 movzx	 r8d, WORD PTR [rdi+rdx*4]
  00133	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  00137	41 0f b7 c0	 movzx	 eax, r8w
  0013b	66 d3 e0	 shl	 ax, cl
  0013e	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  00142	66 41 09 82 10
	17 00 00	 or	 WORD PTR [r10+5904], ax
  0014a	41 0f b6 82 10
	17 00 00	 movzx	 eax, BYTE PTR [r10+5904]
  00152	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00155	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  00159	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  0015d	41 0f b6 82 11
	17 00 00	 movzx	 eax, BYTE PTR [r10+5905]
  00165	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  00169	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0016c	41 8b 92 14 17
	00 00		 mov	 edx, DWORD PTR [r10+5908]
  00173	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  00177	8b cb		 mov	 ecx, ebx
  00179	8d 44 32 f0	 lea	 eax, DWORD PTR [rdx+rsi-16]
  0017d	2a ca		 sub	 cl, dl
  0017f	66 41 d3 e8	 shr	 r8w, cl
  00183	66 45 89 82 10
	17 00 00	 mov	 WORD PTR [r10+5904], r8w
  0018b	eb 12		 jmp	 SHORT $LN27@compress_b
$LN12@compress_b:
  0018d	0f b7 04 97	 movzx	 eax, WORD PTR [rdi+rdx*4]
  00191	66 d3 e0	 shl	 ax, cl
  00194	66 41 09 82 10
	17 00 00	 or	 WORD PTR [r10+5904], ax
  0019c	8d 04 31	 lea	 eax, DWORD PTR [rcx+rsi]
$LN27@compress_b:
  0019f	41 89 82 14 17
	00 00		 mov	 DWORD PTR [r10+5908], eax

; 1097 :             extra = extra_lbits[code];

  001a6	47 8b 84 a7 00
	00 00 00	 mov	 r8d, DWORD PTR extra_lbits[r15+r12*4]

; 1098 :             if (extra != 0) {

  001ae	45 85 c0	 test	 r8d, r8d
  001b1	0f 84 85 00 00
	00		 je	 $LN8@compress_b

; 1099 :                 lc -= base_length[code];

  001b7	47 2b 9c a7 00
	00 00 00	 sub	 r11d, DWORD PTR base_length[r15+r12*4]

; 1100 :                 send_bits(s, lc, extra);       /* send the extra length bits */

  001bf	8b c8		 mov	 ecx, eax
  001c1	8b c3		 mov	 eax, ebx
  001c3	41 2b c0	 sub	 eax, r8d
  001c6	3b c8		 cmp	 ecx, eax
  001c8	7e 5b		 jle	 SHORT $LN9@compress_b
  001ca	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  001ce	41 0f b7 c3	 movzx	 eax, r11w
  001d2	66 d3 e0	 shl	 ax, cl
  001d5	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  001d9	66 41 09 82 10
	17 00 00	 or	 WORD PTR [r10+5904], ax
  001e1	41 0f b6 82 10
	17 00 00	 movzx	 eax, BYTE PTR [r10+5904]
  001e9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001ec	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  001f0	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  001f4	41 0f b6 82 11
	17 00 00	 movzx	 eax, BYTE PTR [r10+5905]
  001fc	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  00200	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00203	41 8b 92 14 17
	00 00		 mov	 edx, DWORD PTR [r10+5908]
  0020a	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  0020e	8b cb		 mov	 ecx, ebx
  00210	42 8d 44 02 f0	 lea	 eax, DWORD PTR [rdx+r8-16]
  00215	2a ca		 sub	 cl, dl
  00217	66 41 d3 eb	 shr	 r11w, cl
  0021b	66 45 89 9a 10
	17 00 00	 mov	 WORD PTR [r10+5904], r11w
  00223	eb 10		 jmp	 SHORT $LN28@compress_b
$LN9@compress_b:
  00225	66 41 d3 e3	 shl	 r11w, cl
  00229	42 8d 04 01	 lea	 eax, DWORD PTR [rcx+r8]
  0022d	66 45 09 9a 10
	17 00 00	 or	 WORD PTR [r10+5904], r11w
$LN28@compress_b:
  00235	41 89 82 14 17
	00 00		 mov	 DWORD PTR [r10+5908], eax
$LN8@compress_b:

; 1101 :             }
; 1102 :             dist--; /* dist is now the match distance - 1 */

  0023c	41 ff c9	 dec	 r9d

; 1103 :             code = d_code(dist);

  0023f	41 81 f9 00 01
	00 00		 cmp	 r9d, 256		; 00000100H
  00246	73 0b		 jae	 SHORT $LN23@compress_b
  00248	43 0f b6 8c 39
	00 00 00 00	 movzx	 ecx, BYTE PTR _dist_code[r9+r15]
  00251	eb 14		 jmp	 SHORT $LN24@compress_b
$LN23@compress_b:
  00253	41 8b c1	 mov	 eax, r9d
  00256	c1 e8 07	 shr	 eax, 7
  00259	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0025e	42 0f b6 8c 38
	00 00 00 00	 movzx	 ecx, BYTE PTR _dist_code[rax+r15]
$LN24@compress_b:

; 1104 :             Assert (code < D_CODES, "bad d_code");
; 1105 : 
; 1106 :             send_code(s, code, dtree);       /* send the distance code */

  00267	41 0f b7 74 8e
	02		 movzx	 esi, WORD PTR [r14+rcx*4+2]
  0026d	44 8b d9	 mov	 r11d, ecx
  00270	41 8b 8a 14 17
	00 00		 mov	 ecx, DWORD PTR [r10+5908]
  00277	8b c3		 mov	 eax, ebx
  00279	2b c6		 sub	 eax, esi
  0027b	3b c8		 cmp	 ecx, eax
  0027d	7e 5f		 jle	 SHORT $LN7@compress_b
  0027f	47 0f b7 04 9e	 movzx	 r8d, WORD PTR [r14+r11*4]
  00284	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  00288	41 0f b7 c0	 movzx	 eax, r8w
  0028c	66 d3 e0	 shl	 ax, cl
  0028f	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  00293	66 41 09 82 10
	17 00 00	 or	 WORD PTR [r10+5904], ax
  0029b	41 0f b6 82 10
	17 00 00	 movzx	 eax, BYTE PTR [r10+5904]
  002a3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  002a6	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  002aa	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  002ae	41 0f b6 82 11
	17 00 00	 movzx	 eax, BYTE PTR [r10+5905]
  002b6	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  002ba	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  002bd	41 8b 92 14 17
	00 00		 mov	 edx, DWORD PTR [r10+5908]
  002c4	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  002c8	8b cb		 mov	 ecx, ebx
  002ca	8d 44 32 f0	 lea	 eax, DWORD PTR [rdx+rsi-16]
  002ce	2a ca		 sub	 cl, dl
  002d0	66 41 d3 e8	 shr	 r8w, cl
  002d4	66 45 89 82 10
	17 00 00	 mov	 WORD PTR [r10+5904], r8w
  002dc	eb 13		 jmp	 SHORT $LN29@compress_b
$LN7@compress_b:
  002de	43 0f b7 04 9e	 movzx	 eax, WORD PTR [r14+r11*4]
  002e3	66 d3 e0	 shl	 ax, cl
  002e6	66 41 09 82 10
	17 00 00	 or	 WORD PTR [r10+5904], ax
  002ee	8d 04 31	 lea	 eax, DWORD PTR [rcx+rsi]
$LN29@compress_b:
  002f1	41 89 82 14 17
	00 00		 mov	 DWORD PTR [r10+5908], eax

; 1107 :             extra = extra_dbits[code];

  002f8	47 8b 84 9f 00
	00 00 00	 mov	 r8d, DWORD PTR extra_dbits[r15+r11*4]

; 1108 :             if (extra != 0) {

  00300	45 85 c0	 test	 r8d, r8d
  00303	0f 84 85 00 00
	00		 je	 $LN18@compress_b

; 1109 :                 dist -= base_dist[code];

  00309	47 2b 8c 9f 00
	00 00 00	 sub	 r9d, DWORD PTR base_dist[r15+r11*4]

; 1110 :                 send_bits(s, dist, extra);   /* send the extra distance bits */

  00311	8b c8		 mov	 ecx, eax
  00313	8b c3		 mov	 eax, ebx
  00315	41 2b c0	 sub	 eax, r8d
  00318	3b c8		 cmp	 ecx, eax
  0031a	7e 5b		 jle	 SHORT $LN4@compress_b
  0031c	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  00320	41 0f b7 c1	 movzx	 eax, r9w
  00324	66 d3 e0	 shl	 ax, cl
  00327	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  0032b	66 41 09 82 10
	17 00 00	 or	 WORD PTR [r10+5904], ax
  00333	41 0f b6 82 10
	17 00 00	 movzx	 eax, BYTE PTR [r10+5904]
  0033b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0033e	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  00342	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  00346	41 0f b6 82 11
	17 00 00	 movzx	 eax, BYTE PTR [r10+5905]
  0034e	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  00352	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00355	41 8b 92 14 17
	00 00		 mov	 edx, DWORD PTR [r10+5908]
  0035c	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  00360	8b cb		 mov	 ecx, ebx
  00362	42 8d 44 02 f0	 lea	 eax, DWORD PTR [rdx+r8-16]
  00367	2a ca		 sub	 cl, dl
  00369	66 41 d3 e9	 shr	 r9w, cl
  0036d	66 45 89 8a 10
	17 00 00	 mov	 WORD PTR [r10+5904], r9w
  00375	eb 10		 jmp	 SHORT $LN26@compress_b
$LN4@compress_b:
  00377	66 41 d3 e1	 shl	 r9w, cl
  0037b	42 8d 04 01	 lea	 eax, DWORD PTR [rcx+r8]
  0037f	66 45 09 8a 10
	17 00 00	 or	 WORD PTR [r10+5904], r9w
$LN26@compress_b:
  00387	41 89 82 14 17
	00 00		 mov	 DWORD PTR [r10+5908], eax
$LN18@compress_b:

; 1111 :             }
; 1112 :         } /* literal or match pair ? */
; 1113 : 
; 1114 :         /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
; 1115 :         Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
; 1116 :                "pendingBuf overflow");
; 1117 : 
; 1118 :     } while (lx < s->last_lit);

  0038e	41 3b aa f4 16
	00 00		 cmp	 ebp, DWORD PTR [r10+5876]
  00395	0f 82 b5 fc ff
	ff		 jb	 $LL19@compress_b
  0039b	4c 8b 3c 24	 mov	 r15, QWORD PTR [rsp]
  0039f	4c 8b 6c 24 10	 mov	 r13, QWORD PTR [rsp+16]
  003a4	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]
  003a9	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
$LN17@compress_b:

; 1119 : 
; 1120 :     send_code(s, END_BLOCK, ltree);

  003ae	44 0f b7 9f 02
	04 00 00	 movzx	 r11d, WORD PTR [rdi+1026]
  003b6	41 8b 8a 14 17
	00 00		 mov	 ecx, DWORD PTR [r10+5908]
  003bd	4c 8b 74 24 08	 mov	 r14, QWORD PTR [rsp+8]
  003c2	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  003c7	8b c3		 mov	 eax, ebx
  003c9	41 2b c3	 sub	 eax, r11d
  003cc	3b c8		 cmp	 ecx, eax
  003ce	7e 66		 jle	 SHORT $LN2@compress_b
  003d0	44 0f b7 8f 00
	04 00 00	 movzx	 r9d, WORD PTR [rdi+1024]
  003d8	45 8b 42 28	 mov	 r8d, DWORD PTR [r10+40]
  003dc	49 8b 52 10	 mov	 rdx, QWORD PTR [r10+16]
  003e0	41 0f b7 c1	 movzx	 eax, r9w
  003e4	66 d3 e0	 shl	 ax, cl
  003e7	66 41 09 82 10
	17 00 00	 or	 WORD PTR [r10+5904], ax
  003ef	41 0f b6 82 10
	17 00 00	 movzx	 eax, BYTE PTR [r10+5904]
  003f7	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  003fb	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  003ff	41 0f b6 82 11
	17 00 00	 movzx	 eax, BYTE PTR [r10+5905]
  00407	45 8b 42 28	 mov	 r8d, DWORD PTR [r10+40]
  0040b	49 8b 52 10	 mov	 rdx, QWORD PTR [r10+16]
  0040f	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00413	41 8b 92 14 17
	00 00		 mov	 edx, DWORD PTR [r10+5908]
  0041a	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  0041e	2a da		 sub	 bl, dl
  00420	42 8d 44 1a f0	 lea	 eax, DWORD PTR [rdx+r11-16]
  00425	0f b6 cb	 movzx	 ecx, bl
  00428	66 41 d3 e9	 shr	 r9w, cl
  0042c	66 45 89 8a 10
	17 00 00	 mov	 WORD PTR [r10+5904], r9w
  00434	eb 16		 jmp	 SHORT $LN30@compress_b
$LN2@compress_b:
  00436	0f b7 87 00 04
	00 00		 movzx	 eax, WORD PTR [rdi+1024]
  0043d	66 d3 e0	 shl	 ax, cl
  00440	66 41 09 82 10
	17 00 00	 or	 WORD PTR [r10+5904], ax
  00448	42 8d 04 19	 lea	 eax, DWORD PTR [rcx+r11]
$LN30@compress_b:
  0044c	41 89 82 14 17
	00 00		 mov	 DWORD PTR [r10+5908], eax

; 1121 :     s->last_eob_len = ltree[END_BLOCK].Len;

  00453	0f b7 87 02 04
	00 00		 movzx	 eax, WORD PTR [rdi+1026]
  0045a	41 89 82 0c 17
	00 00		 mov	 DWORD PTR [r10+5900], eax

; 1122 : }

  00461	48 83 c4 18	 add	 rsp, 24
  00465	5f		 pop	 rdi
  00466	5b		 pop	 rbx
  00467	c3		 ret	 0
compress_block ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT detect_data_type
_TEXT	SEGMENT
s$ = 8
detect_data_type PROC					; COMDAT

; 1139 : {

  00000	4c 8b c9	 mov	 r9, rcx
  00003	33 d2		 xor	 edx, edx

; 1140 :     /* black_mask is the bit mask of black-listed bytes
; 1141 :      * set bits 0..6, 14..25, and 28..31
; 1142 :      * 0xf3ffc07f = binary 11110011111111111100000001111111
; 1143 :      */
; 1144 :     unsigned long black_mask = 0xf3ffc07fUL;

  00005	41 b8 7f c0 ff
	f3		 mov	 r8d, -201342849		; f3ffc07fH
  0000b	48 8d 81 bc 00
	00 00		 lea	 rax, QWORD PTR [rcx+188]
$LL10@detect_dat:

; 1149 :         if ((black_mask & 1) && (s->dyn_ltree[n].Freq != 0))

  00012	41 f6 c0 01	 test	 r8b, 1
  00016	74 06		 je	 SHORT $LN9@detect_dat
  00018	66 83 38 00	 cmp	 WORD PTR [rax], 0
  0001c	75 50		 jne	 SHORT $LN15@detect_dat
$LN9@detect_dat:

; 1145 :     int n;
; 1146 : 
; 1147 :     /* Check for non-textual ("black-listed") bytes. */
; 1148 :     for (n = 0; n <= 31; n++, black_mask >>= 1)

  0001e	48 ff c2	 inc	 rdx
  00021	48 83 c0 04	 add	 rax, 4
  00025	41 d1 e8	 shr	 r8d, 1
  00028	48 83 fa 1f	 cmp	 rdx, 31
  0002c	7e e4		 jle	 SHORT $LL10@detect_dat

; 1150 :             return Z_BINARY;
; 1151 : 
; 1152 :     /* Check for textual ("white-listed") bytes. */
; 1153 :     if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
; 1154 :             || s->dyn_ltree[13].Freq != 0)

  0002e	66 83 b9 e0 00
	00 00 00	 cmp	 WORD PTR [rcx+224], 0
  00036	75 39		 jne	 SHORT $LN5@detect_dat
  00038	66 83 b9 e4 00
	00 00 00	 cmp	 WORD PTR [rcx+228], 0
  00040	75 2f		 jne	 SHORT $LN5@detect_dat
  00042	66 83 b9 f0 00
	00 00 00	 cmp	 WORD PTR [rcx+240], 0
  0004a	75 25		 jne	 SHORT $LN5@detect_dat
  0004c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00051	49 8d 81 3c 01
	00 00		 lea	 rax, QWORD PTR [r9+316]
$LL4@detect_dat:

; 1157 :         if (s->dyn_ltree[n].Freq != 0)

  00058	66 83 38 00	 cmp	 WORD PTR [rax], 0
  0005c	75 13		 jne	 SHORT $LN5@detect_dat

; 1156 :     for (n = 32; n < LITERALS; n++)

  0005e	48 ff c1	 inc	 rcx
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 81 f9 00 01
	00 00		 cmp	 rcx, 256		; 00000100H
  0006c	7c ea		 jl	 SHORT $LL4@detect_dat
$LN15@detect_dat:

; 1158 :             return Z_TEXT;
; 1159 : 
; 1160 :     /* There are no "black-listed" or "white-listed" bytes:
; 1161 :      * this stream either is empty or has tolerated ("gray-listed") bytes only.
; 1162 :      */
; 1163 :     return Z_BINARY;

  0006e	33 c0		 xor	 eax, eax

; 1164 : }

  00070	c3		 ret	 0
$LN5@detect_dat:

; 1155 :         return Z_TEXT;

  00071	b8 01 00 00 00	 mov	 eax, 1

; 1164 : }

  00076	c3		 ret	 0
detect_data_type ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bi_reverse
_TEXT	SEGMENT
code$ = 8
len$ = 16
bi_reverse PROC						; COMDAT

; 1175 :     register unsigned res = 0;

  00000	33 c0		 xor	 eax, eax
$LL3@bi_reverse:

; 1176 :     do {
; 1177 :         res |= code & 1;

  00002	44 8b c1	 mov	 r8d, ecx

; 1178 :         code >>= 1, res <<= 1;
; 1179 :     } while (--len > 0);

  00005	ff ca		 dec	 edx
  00007	d1 e9		 shr	 ecx, 1
  00009	41 83 e0 01	 and	 r8d, 1
  0000d	41 0b c0	 or	 eax, r8d
  00010	03 c0		 add	 eax, eax
  00012	85 d2		 test	 edx, edx
  00014	7f ec		 jg	 SHORT $LL3@bi_reverse

; 1180 :     return res >> 1;

  00016	d1 e8		 shr	 eax, 1

; 1181 : }

  00018	c3		 ret	 0
bi_reverse ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bi_flush
_TEXT	SEGMENT
s$ = 8
bi_flush PROC						; COMDAT

; 1189 :     if (s->bi_valid == 16) {

  00000	8b 81 14 17 00
	00		 mov	 eax, DWORD PTR [rcx+5908]
  00006	4c 8b c9	 mov	 r9, rcx
  00009	83 f8 10	 cmp	 eax, 16
  0000c	75 3e		 jne	 SHORT $LN3@bi_flush

; 1190 :         put_short(s, s->bi_buf);

  0000e	0f b6 81 10 17
	00 00		 movzx	 eax, BYTE PTR [rcx+5904]
  00015	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00019	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  0001d	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00021	ff 41 28	 inc	 DWORD PTR [rcx+40]
  00024	8b 51 28	 mov	 edx, DWORD PTR [rcx+40]
  00027	41 0f b6 81 11
	17 00 00	 movzx	 eax, BYTE PTR [r9+5905]
  0002f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00033	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00036	41 ff 41 28	 inc	 DWORD PTR [r9+40]

; 1191 :         s->bi_buf = 0;

  0003a	33 c0		 xor	 eax, eax

; 1192 :         s->bi_valid = 0;

  0003c	41 89 81 14 17
	00 00		 mov	 DWORD PTR [r9+5908], eax

; 1195 :         s->bi_buf >>= 8;

  00043	66 41 89 81 10
	17 00 00	 mov	 WORD PTR [r9+5904], ax

; 1197 :     }
; 1198 : }

  0004b	c3		 ret	 0
$LN3@bi_flush:

; 1193 :     } else if (s->bi_valid >= 8) {

  0004c	83 f8 08	 cmp	 eax, 8
  0004f	7c 2e		 jl	 SHORT $LN1@bi_flush

; 1194 :         put_byte(s, (Byte)s->bi_buf);

  00051	8b 51 28	 mov	 edx, DWORD PTR [rcx+40]
  00054	41 0f b6 81 10
	17 00 00	 movzx	 eax, BYTE PTR [r9+5904]
  0005c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00060	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1195 :         s->bi_buf >>= 8;

  00063	41 0f b6 81 11
	17 00 00	 movzx	 eax, BYTE PTR [r9+5905]
  0006b	41 ff 41 28	 inc	 DWORD PTR [r9+40]

; 1196 :         s->bi_valid -= 8;

  0006f	41 83 81 14 17
	00 00 f8	 add	 DWORD PTR [r9+5908], -8
  00077	66 41 89 81 10
	17 00 00	 mov	 WORD PTR [r9+5904], ax
$LN1@bi_flush:

; 1197 :     }
; 1198 : }

  0007f	f3 c3		 fatret	 0
bi_flush ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bi_windup
_TEXT	SEGMENT
s$ = 8
bi_windup PROC						; COMDAT

; 1206 :     if (s->bi_valid > 8) {

  00000	8b 81 14 17 00
	00		 mov	 eax, DWORD PTR [rcx+5908]
  00006	4c 8b c9	 mov	 r9, rcx
  00009	83 f8 08	 cmp	 eax, 8
  0000c	7e 1f		 jle	 SHORT $LN3@bi_windup

; 1207 :         put_short(s, s->bi_buf);

  0000e	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00012	0f b6 81 10 17
	00 00		 movzx	 eax, BYTE PTR [rcx+5904]
  00019	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  0001d	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00021	ff 41 28	 inc	 DWORD PTR [rcx+40]
  00024	0f b6 81 11 17
	00 00		 movzx	 eax, BYTE PTR [rcx+5905]
  0002b	eb 0c		 jmp	 SHORT $LN6@bi_windup
$LN3@bi_windup:

; 1208 :     } else if (s->bi_valid > 0) {

  0002d	85 c0		 test	 eax, eax
  0002f	7e 16		 jle	 SHORT $LN1@bi_windup

; 1209 :         put_byte(s, (Byte)s->bi_buf);

  00031	41 0f b6 81 10
	17 00 00	 movzx	 eax, BYTE PTR [r9+5904]
$LN6@bi_windup:
  00039	8b 51 28	 mov	 edx, DWORD PTR [rcx+40]
  0003c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00040	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00043	41 ff 41 28	 inc	 DWORD PTR [r9+40]
$LN1@bi_windup:

; 1210 :     }
; 1211 :     s->bi_buf = 0;

  00047	33 c0		 xor	 eax, eax
  00049	66 41 89 81 10
	17 00 00	 mov	 WORD PTR [r9+5904], ax

; 1212 :     s->bi_valid = 0;

  00051	41 89 81 14 17
	00 00		 mov	 DWORD PTR [r9+5908], eax

; 1213 : #ifdef DEBUG
; 1214 :     s->bits_sent = (s->bits_sent+7) & ~7;
; 1215 : #endif
; 1216 : }

  00058	c3		 ret	 0
bi_windup ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$copy_block DD imagerel copy_block
	DD	imagerel copy_block+166
	DD	imagerel $unwind$copy_block
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$copy_block DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT copy_block
_TEXT	SEGMENT
s$ = 48
buf$ = 56
len$ = 64
header$ = 72
copy_block PROC						; COMDAT

; 1227 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	45 8b d1	 mov	 r10d, r9d
  0000d	41 8b d8	 mov	 ebx, r8d
  00010	48 8b fa	 mov	 rdi, rdx
  00013	4c 8b d9	 mov	 r11, rcx

; 1228 :     bi_windup(s);        /* align on byte boundary */

  00016	e8 00 00 00 00	 call	 bi_windup

; 1229 :     s->last_eob_len = 8; /* enough lookahead for inflate */

  0001b	41 c7 83 0c 17
	00 00 08 00 00
	00		 mov	 DWORD PTR [r11+5900], 8

; 1230 : 
; 1231 :     if (header) {

  00026	45 85 d2	 test	 r10d, r10d
  00029	74 53		 je	 SHORT $LN6@copy_block

; 1232 :         put_short(s, (ush)len);

  0002b	45 8b 4b 28	 mov	 r9d, DWORD PTR [r11+40]
  0002f	49 8b 43 10	 mov	 rax, QWORD PTR [r11+16]
  00033	0f b7 cb	 movzx	 ecx, bx
  00036	41 88 1c 01	 mov	 BYTE PTR [r9+rax], bl
  0003a	41 ff 43 28	 inc	 DWORD PTR [r11+40]
  0003e	41 8b 53 28	 mov	 edx, DWORD PTR [r11+40]
  00042	49 8b 43 10	 mov	 rax, QWORD PTR [r11+16]
  00046	66 c1 e9 08	 shr	 cx, 8
  0004a	88 0c 02	 mov	 BYTE PTR [rdx+rax], cl
  0004d	41 ff 43 28	 inc	 DWORD PTR [r11+40]
  00051	41 8b 53 28	 mov	 edx, DWORD PTR [r11+40]

; 1233 :         put_short(s, (ush)~len);

  00055	49 8b 43 10	 mov	 rax, QWORD PTR [r11+16]
  00059	0f b6 cb	 movzx	 ecx, bl
  0005c	f6 d1		 not	 cl
  0005e	88 0c 02	 mov	 BYTE PTR [rdx+rax], cl
  00061	41 ff 43 28	 inc	 DWORD PTR [r11+40]
  00065	41 8b 53 28	 mov	 edx, DWORD PTR [r11+40]
  00069	49 8b 43 10	 mov	 rax, QWORD PTR [r11+16]
  0006d	0f b7 cb	 movzx	 ecx, bx
  00070	66 f7 d1	 not	 cx
  00073	66 c1 e9 08	 shr	 cx, 8
  00077	88 0c 02	 mov	 BYTE PTR [rdx+rax], cl
  0007a	41 ff 43 28	 inc	 DWORD PTR [r11+40]
$LN6@copy_block:

; 1234 : #ifdef DEBUG
; 1235 :         s->bits_sent += 2*16;
; 1236 : #endif
; 1237 :     }
; 1238 : #ifdef DEBUG
; 1239 :     s->bits_sent += (ulg)len<<3;
; 1240 : #endif
; 1241 :     while (len--) {

  0007e	85 db		 test	 ebx, ebx
  00080	74 19		 je	 SHORT $LN7@copy_block
$LL2@copy_block:

; 1242 :         put_byte(s, *buf++);

  00082	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  00085	41 8b 53 28	 mov	 edx, DWORD PTR [r11+40]
  00089	49 8b 4b 10	 mov	 rcx, QWORD PTR [r11+16]
  0008d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00090	41 ff 43 28	 inc	 DWORD PTR [r11+40]
  00094	48 ff c7	 inc	 rdi
  00097	ff cb		 dec	 ebx
  00099	75 e7		 jne	 SHORT $LL2@copy_block
$LN7@copy_block:

; 1243 :     }
; 1244 : }

  0009b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a4	5f		 pop	 rdi
  000a5	c3		 ret	 0
copy_block ENDP
_TEXT	ENDS
PUBLIC	_tr_init
; Function compile flags: /Ogtpy
;	COMDAT _tr_init
_TEXT	SEGMENT
s$ = 8
_tr_init PROC						; COMDAT

; 389  :     tr_static_init();
; 390  : 
; 391  :     s->l_desc.dyn_tree = s->dyn_ltree;

  00000	48 8d 81 bc 00
	00 00		 lea	 rax, QWORD PTR [rcx+188]

; 392  :     s->l_desc.stat_desc = &static_l_desc;
; 393  : 
; 394  :     s->d_desc.dyn_tree = s->dyn_dtree;
; 395  :     s->d_desc.stat_desc = &static_d_desc;
; 396  : 
; 397  :     s->bl_desc.dyn_tree = s->bl_tree;
; 398  :     s->bl_desc.stat_desc = &static_bl_desc;
; 399  : 
; 400  :     s->bi_buf = 0;
; 401  :     s->bi_valid = 0;
; 402  :     s->last_eob_len = 8; /* enough lookahead for inflate */

  00007	c7 81 0c 17 00
	00 08 00 00 00	 mov	 DWORD PTR [rcx+5900], 8
  00011	48 89 81 40 0b
	00 00		 mov	 QWORD PTR [rcx+2880], rax
  00018	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:static_l_desc
  0001f	48 89 81 50 0b
	00 00		 mov	 QWORD PTR [rcx+2896], rax
  00026	48 8d 81 b0 09
	00 00		 lea	 rax, QWORD PTR [rcx+2480]
  0002d	48 89 81 58 0b
	00 00		 mov	 QWORD PTR [rcx+2904], rax
  00034	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:static_d_desc
  0003b	48 89 81 68 0b
	00 00		 mov	 QWORD PTR [rcx+2920], rax
  00042	48 8d 81 a4 0a
	00 00		 lea	 rax, QWORD PTR [rcx+2724]
  00049	48 89 81 70 0b
	00 00		 mov	 QWORD PTR [rcx+2928], rax
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:static_bl_desc
  00057	48 89 81 80 0b
	00 00		 mov	 QWORD PTR [rcx+2944], rax
  0005e	33 c0		 xor	 eax, eax
  00060	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax
  00067	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax

; 403  : #ifdef DEBUG
; 404  :     s->compressed_len = 0L;
; 405  :     s->bits_sent = 0L;
; 406  : #endif
; 407  : 
; 408  :     /* Initialize the first block of the first file: */
; 409  :     init_block(s);
; 410  : }

  0006d	e9 00 00 00 00	 jmp	 init_block
_tr_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gen_codes DD imagerel gen_codes
	DD	imagerel gen_codes+115
	DD	imagerel $unwind$gen_codes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gen_codes DD 020601H
	DD	030027206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gen_codes
_TEXT	SEGMENT
next_code$ = 32
tree$ = 80
max_code$ = 88
bl_count$ = 96
gen_codes PROC						; COMDAT

; 585  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 586  :     ush next_code[MAX_BITS+1]; /* next code value for each bit length */
; 587  :     ush code = 0;              /* running code value */

  00006	45 33 c9	 xor	 r9d, r9d

; 588  :     int bits;                  /* bit index */
; 589  :     int n;                     /* code index */
; 590  : 
; 591  :     /* The distribution counts are first used to generate the code values
; 592  :      * without bit reversal.
; 593  :      */
; 594  :     for (bits = 1; bits <= MAX_BITS; bits++) {

  00009	48 8d 44 24 22	 lea	 rax, QWORD PTR next_code$[rsp+2]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	4c 2b c0	 sub	 r8, rax
  00014	45 0f b7 d9	 movzx	 r11d, r9w
  00018	41 ba 01 00 00
	00		 mov	 r10d, 1
  0001e	66 90		 npad	 2
$LL7@gen_codes:
  00020	4b 8d 04 50	 lea	 rax, QWORD PTR [r8+r10*2]
  00024	49 ff c2	 inc	 r10

; 595  :         next_code[bits] = code = (code + bl_count[bits-1]) << 1;

  00027	66 44 03 5c 04
	20		 add	 r11w, WORD PTR next_code$[rsp+rax]
  0002d	66 45 03 db	 add	 r11w, r11w
  00031	66 46 89 5c 54
	1e		 mov	 WORD PTR next_code$[rsp+r10*2-2], r11w
  00037	49 83 fa 0f	 cmp	 r10, 15
  0003b	7e e3		 jle	 SHORT $LL7@gen_codes

; 596  :     }
; 597  :     /* Check that the bit counts in bl_count are consistent. The last code
; 598  :      * must be all ones.
; 599  :      */
; 600  :     Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
; 601  :             "inconsistent bit counts");
; 602  :     Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
; 603  : 
; 604  :     for (n = 0;  n <= max_code; n++) {

  0003d	4c 63 d2	 movsxd	 r10, edx
  00040	85 d2		 test	 edx, edx
  00042	78 29		 js	 SHORT $LN2@gen_codes
$LL4@gen_codes:

; 605  :         int len = tree[n].Len;

  00044	42 0f b7 54 8b
	02		 movzx	 edx, WORD PTR [rbx+r9*4+2]

; 606  :         if (len == 0) continue;

  0004a	85 d2		 test	 edx, edx
  0004c	74 17		 je	 SHORT $LN3@gen_codes

; 607  :         /* Now reverse the bits */
; 608  :         tree[n].Code = bi_reverse(next_code[len]++, len);

  0004e	0f b7 4c 54 20	 movzx	 ecx, WORD PTR next_code$[rsp+rdx*2]
  00053	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  00056	66 89 44 54 20	 mov	 WORD PTR next_code$[rsp+rdx*2], ax
  0005b	e8 00 00 00 00	 call	 bi_reverse
  00060	66 42 89 04 8b	 mov	 WORD PTR [rbx+r9*4], ax
$LN3@gen_codes:

; 596  :     }
; 597  :     /* Check that the bit counts in bl_count are consistent. The last code
; 598  :      * must be all ones.
; 599  :      */
; 600  :     Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
; 601  :             "inconsistent bit counts");
; 602  :     Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
; 603  : 
; 604  :     for (n = 0;  n <= max_code; n++) {

  00065	49 ff c1	 inc	 r9
  00068	4d 3b ca	 cmp	 r9, r10
  0006b	7e d7		 jle	 SHORT $LL4@gen_codes
$LN2@gen_codes:

; 609  : 
; 610  :         Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
; 611  :              n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
; 612  :     }
; 613  : }

  0006d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00071	5b		 pop	 rbx
  00072	c3		 ret	 0
gen_codes ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$build_tree DD imagerel build_tree
	DD	imagerel build_tree+587
	DD	imagerel $unwind$build_tree
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$build_tree DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0e01a321eH
	DD	0c016d018H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT build_tree
_TEXT	SEGMENT
s$ = 64
desc$ = 72
build_tree PROC						; COMDAT

; 626  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 627  :     ct_data *tree         = desc->dyn_tree;
; 628  :     const ct_data *stree  = desc->stat_desc->static_tree;

  0001e	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  00022	48 8b 32	 mov	 rsi, QWORD PTR [rdx]

; 629  :     int elems             = desc->stat_desc->elems;
; 630  :     int n, m;          /* iterate over heap elements */
; 631  :     int max_code = -1; /* largest code with non zero frequency */
; 632  :     int node;          /* new node being created */
; 633  : 
; 634  :     /* Construct the initial heap, with least frequent element in
; 635  :      * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
; 636  :      * heap[0] is not used.
; 637  :      */
; 638  :     s->heap_len = 0, s->heap_max = HEAP_SIZE;

  00025	45 33 d2	 xor	 r10d, r10d
  00028	4c 63 60 14	 movsxd	 r12, DWORD PTR [rax+20]
  0002c	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  0002f	83 cd ff	 or	 ebp, -1
  00032	48 8b f9	 mov	 rdi, rcx
  00035	44 89 91 9c 14
	00 00		 mov	 DWORD PTR [rcx+5276], r10d
  0003c	c7 81 a0 14 00
	00 3d 02 00 00	 mov	 DWORD PTR [rcx+5280], 573 ; 0000023dH
  00046	4c 8b ea	 mov	 r13, rdx

; 639  : 
; 640  :     for (n = 0; n < elems; n++) {

  00049	45 8b c2	 mov	 r8d, r10d
  0004c	41 8b ca	 mov	 ecx, r10d
  0004f	45 85 e4	 test	 r12d, r12d
  00052	7e 3a		 jle	 SHORT $LN22@build_tree
$LL14@build_tree:

; 641  :         if (tree[n].Freq != 0) {

  00054	66 44 39 14 8e	 cmp	 WORD PTR [rsi+rcx*4], r10w
  00059	74 22		 je	 SHORT $LN11@build_tree

; 642  :             s->heap[++(s->heap_len)] = max_code = n;

  0005b	ff 87 9c 14 00
	00		 inc	 DWORD PTR [rdi+5276]
  00061	48 63 87 9c 14
	00 00		 movsxd	 rax, DWORD PTR [rdi+5276]
  00068	41 8b e8	 mov	 ebp, r8d
  0006b	44 89 84 87 a8
	0b 00 00	 mov	 DWORD PTR [rdi+rax*4+2984], r8d

; 643  :             s->depth[n] = 0;

  00073	44 88 94 39 a4
	14 00 00	 mov	 BYTE PTR [rcx+rdi+5284], r10b

; 644  :         } else {

  0007b	eb 06		 jmp	 SHORT $LN13@build_tree
$LN11@build_tree:

; 645  :             tree[n].Len = 0;

  0007d	66 44 89 54 8e
	02		 mov	 WORD PTR [rsi+rcx*4+2], r10w
$LN13@build_tree:

; 639  : 
; 640  :     for (n = 0; n < elems; n++) {

  00083	48 ff c1	 inc	 rcx
  00086	41 ff c0	 inc	 r8d
  00089	49 3b cc	 cmp	 rcx, r12
  0008c	7c c6		 jl	 SHORT $LL14@build_tree
$LN22@build_tree:

; 646  :         }
; 647  :     }
; 648  : 
; 649  :     /* The pkzip format requires that at least one distance code exists,
; 650  :      * and that at least one bit should be sent even if there is only one
; 651  :      * possible code. So to avoid special checks later on we force at least
; 652  :      * two codes of non zero frequency.
; 653  :      */
; 654  :     while (s->heap_len < 2) {

  0008e	83 bf 9c 14 00
	00 02		 cmp	 DWORD PTR [rdi+5276], 2
  00095	41 be 01 00 00
	00		 mov	 r14d, 1
  0009b	7d 55		 jge	 SHORT $LN8@build_tree
  0009d	0f 1f 00	 npad	 3
$LL9@build_tree:

; 655  :         node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);

  000a0	83 fd 02	 cmp	 ebp, 2
  000a3	7d 06		 jge	 SHORT $LN17@build_tree
  000a5	ff c5		 inc	 ebp
  000a7	8b cd		 mov	 ecx, ebp
  000a9	eb 03		 jmp	 SHORT $LN18@build_tree
$LN17@build_tree:
  000ab	41 8b ca	 mov	 ecx, r10d
$LN18@build_tree:
  000ae	ff 87 9c 14 00
	00		 inc	 DWORD PTR [rdi+5276]
  000b4	48 63 87 9c 14
	00 00		 movsxd	 rax, DWORD PTR [rdi+5276]
  000bb	89 8c 87 a8 0b
	00 00		 mov	 DWORD PTR [rdi+rax*4+2984], ecx

; 656  :         tree[node].Freq = 1;

  000c2	48 63 c1	 movsxd	 rax, ecx
  000c5	66 44 89 34 86	 mov	 WORD PTR [rsi+rax*4], r14w

; 657  :         s->depth[node] = 0;

  000ca	44 88 94 38 a4
	14 00 00	 mov	 BYTE PTR [rax+rdi+5284], r10b

; 658  :         s->opt_len--; if (stree) s->static_len -= stree[node].Len;

  000d2	ff 8f 00 17 00
	00		 dec	 DWORD PTR [rdi+5888]
  000d8	4d 85 c9	 test	 r9, r9
  000db	74 0c		 je	 SHORT $LN7@build_tree
  000dd	41 0f b7 44 81
	02		 movzx	 eax, WORD PTR [r9+rax*4+2]
  000e3	29 87 04 17 00
	00		 sub	 DWORD PTR [rdi+5892], eax
$LN7@build_tree:

; 646  :         }
; 647  :     }
; 648  : 
; 649  :     /* The pkzip format requires that at least one distance code exists,
; 650  :      * and that at least one bit should be sent even if there is only one
; 651  :      * possible code. So to avoid special checks later on we force at least
; 652  :      * two codes of non zero frequency.
; 653  :      */
; 654  :     while (s->heap_len < 2) {

  000e9	83 bf 9c 14 00
	00 02		 cmp	 DWORD PTR [rdi+5276], 2
  000f0	7c ae		 jl	 SHORT $LL9@build_tree
$LN8@build_tree:

; 659  :         /* node is 0 or 1 so it does not have extra bits */
; 660  :     }
; 661  :     desc->max_code = max_code;

  000f2	89 6a 08	 mov	 DWORD PTR [rdx+8], ebp

; 662  : 
; 663  :     /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
; 664  :      * establish sub-heaps of increasing lengths:
; 665  :      */
; 666  :     for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

  000f5	8b 87 9c 14 00
	00		 mov	 eax, DWORD PTR [rdi+5276]
  000fb	99		 cdq
  000fc	2b c2		 sub	 eax, edx
  000fe	d1 f8		 sar	 eax, 1
  00100	8b d8		 mov	 ebx, eax
  00102	41 3b c6	 cmp	 eax, r14d
  00105	7c 29		 jl	 SHORT $LL3@build_tree
  00107	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL6@build_tree:
  00110	44 8b c3	 mov	 r8d, ebx
  00113	48 8b d6	 mov	 rdx, rsi
  00116	48 8b cf	 mov	 rcx, rdi
  00119	e8 00 00 00 00	 call	 pqdownheap
  0011e	ff cb		 dec	 ebx
  00120	41 3b de	 cmp	 ebx, r14d
  00123	7d eb		 jge	 SHORT $LL6@build_tree
  00125	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL3@build_tree:

; 667  : 
; 668  :     /* Construct the Huffman tree by repeatedly combining the least two
; 669  :      * frequent nodes.
; 670  :      */
; 671  :     node = elems;              /* next internal node of the tree */
; 672  :     do {
; 673  :         pqremove(s, tree, n);  /* n = node of least frequency */

  00130	48 63 97 9c 14
	00 00		 movsxd	 rdx, DWORD PTR [rdi+5276]
  00137	48 63 9f ac 0b
	00 00		 movsxd	 rbx, DWORD PTR [rdi+2988]
  0013e	45 8b c6	 mov	 r8d, r14d
  00141	8b 8c 97 a8 0b
	00 00		 mov	 ecx, DWORD PTR [rdi+rdx*4+2984]
  00148	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  0014b	48 8b d6	 mov	 rdx, rsi
  0014e	89 8f ac 0b 00
	00		 mov	 DWORD PTR [rdi+2988], ecx
  00154	48 8b cf	 mov	 rcx, rdi
  00157	89 87 9c 14 00
	00		 mov	 DWORD PTR [rdi+5276], eax
  0015d	e8 00 00 00 00	 call	 pqdownheap

; 674  :         m = s->heap[SMALLEST]; /* m = node of next least frequency */
; 675  : 
; 676  :         s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */

  00162	ff 8f a0 14 00
	00		 dec	 DWORD PTR [rdi+5280]
  00168	48 63 8f ac 0b
	00 00		 movsxd	 rcx, DWORD PTR [rdi+2988]
  0016f	48 63 87 a0 14
	00 00		 movsxd	 rax, DWORD PTR [rdi+5280]

; 677  :         s->heap[--(s->heap_max)] = m;
; 678  : 
; 679  :         /* Create a new node father of n and m */
; 680  :         tree[node].Freq = tree[n].Freq + tree[m].Freq;

  00176	4d 63 cc	 movsxd	 r9, r12d
  00179	48 8b d1	 mov	 rdx, rcx
  0017c	89 9c 87 a8 0b
	00 00		 mov	 DWORD PTR [rdi+rax*4+2984], ebx
  00183	ff 8f a0 14 00
	00		 dec	 DWORD PTR [rdi+5280]
  00189	48 63 87 a0 14
	00 00		 movsxd	 rax, DWORD PTR [rdi+5280]
  00190	89 8c 87 a8 0b
	00 00		 mov	 DWORD PTR [rdi+rax*4+2984], ecx
  00197	0f b7 04 8e	 movzx	 eax, WORD PTR [rsi+rcx*4]
  0019b	66 03 04 9e	 add	 ax, WORD PTR [rsi+rbx*4]
  0019f	66 42 89 04 8e	 mov	 WORD PTR [rsi+r9*4], ax

; 681  :         s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
; 682  :                                 s->depth[n] : s->depth[m]) + 1);

  001a4	0f b6 84 3b a4
	14 00 00	 movzx	 eax, BYTE PTR [rbx+rdi+5284]
  001ac	0f b6 8c 39 a4
	14 00 00	 movzx	 ecx, BYTE PTR [rcx+rdi+5284]
  001b4	3a c1		 cmp	 al, cl
  001b6	0f b6 c0	 movzx	 eax, al
  001b9	73 03		 jae	 SHORT $LN20@build_tree
  001bb	0f b6 c1	 movzx	 eax, cl
$LN20@build_tree:
  001be	fe c0		 inc	 al

; 683  :         tree[n].Dad = tree[m].Dad = (ush)node;
; 684  : #ifdef DUMP_BL_TREE
; 685  :         if (tree == s->bl_tree) {
; 686  :             fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
; 687  :                     node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
; 688  :         }
; 689  : #endif
; 690  :         /* and insert the new node in the heap */
; 691  :         s->heap[SMALLEST] = node++;
; 692  :         pqdownheap(s, tree, SMALLEST);

  001c0	45 8b c6	 mov	 r8d, r14d
  001c3	48 8b cf	 mov	 rcx, rdi
  001c6	41 88 84 39 a4
	14 00 00	 mov	 BYTE PTR [r9+rdi+5284], al
  001ce	66 44 89 64 96
	02		 mov	 WORD PTR [rsi+rdx*4+2], r12w
  001d4	66 44 89 64 9e
	02		 mov	 WORD PTR [rsi+rbx*4+2], r12w
  001da	44 89 a7 ac 0b
	00 00		 mov	 DWORD PTR [rdi+2988], r12d
  001e1	48 8b d6	 mov	 rdx, rsi
  001e4	41 ff c4	 inc	 r12d
  001e7	e8 00 00 00 00	 call	 pqdownheap

; 693  : 
; 694  :     } while (s->heap_len >= 2);

  001ec	83 bf 9c 14 00
	00 02		 cmp	 DWORD PTR [rdi+5276], 2
  001f3	0f 8d 37 ff ff
	ff		 jge	 $LL3@build_tree

; 695  : 
; 696  :     s->heap[--(s->heap_max)] = s->heap[SMALLEST];

  001f9	ff 8f a0 14 00
	00		 dec	 DWORD PTR [rdi+5280]
  001ff	4c 63 87 a0 14
	00 00		 movsxd	 r8, DWORD PTR [rdi+5280]
  00206	8b 87 ac 0b 00
	00		 mov	 eax, DWORD PTR [rdi+2988]

; 697  : 
; 698  :     /* At this point, the fields freq and dad are set. We can now
; 699  :      * generate the bit lengths.
; 700  :      */
; 701  :     gen_bitlen(s, (tree_desc *)desc);

  0020c	49 8b d5	 mov	 rdx, r13
  0020f	42 89 84 87 a8
	0b 00 00	 mov	 DWORD PTR [rdi+r8*4+2984], eax
  00217	e8 00 00 00 00	 call	 gen_bitlen

; 702  : 
; 703  :     /* The field len is now set, we can generate the bit codes */
; 704  :     gen_codes ((ct_data *)tree, max_code, s->bl_count);

  0021c	4c 8d 87 88 0b
	00 00		 lea	 r8, QWORD PTR [rdi+2952]
  00223	8b d5		 mov	 edx, ebp
  00225	48 8b ce	 mov	 rcx, rsi

; 705  : }

  00228	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0022d	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00232	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00237	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0023c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00240	41 5e		 pop	 r14
  00242	41 5d		 pop	 r13
  00244	41 5c		 pop	 r12
  00246	e9 00 00 00 00	 jmp	 gen_codes
build_tree ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$build_bl_tree DD imagerel build_bl_tree
	DD	imagerel build_bl_tree+127
	DD	imagerel $unwind$build_bl_tree
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$build_bl_tree DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT build_bl_tree
_TEXT	SEGMENT
s$ = 48
build_bl_tree PROC					; COMDAT

; 809  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 810  :     int max_blindex;  /* index of last bit length code of non zero freq */
; 811  : 
; 812  :     /* Determine the bit length frequencies for literal and distance trees */
; 813  :     scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);

  00006	44 8b 81 48 0b
	00 00		 mov	 r8d, DWORD PTR [rcx+2888]
  0000d	48 8d 91 bc 00
	00 00		 lea	 rdx, QWORD PTR [rcx+188]
  00014	48 8b d9	 mov	 rbx, rcx
  00017	e8 00 00 00 00	 call	 scan_tree

; 814  :     scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

  0001c	44 8b 81 60 0b
	00 00		 mov	 r8d, DWORD PTR [rcx+2912]
  00023	48 8d 91 b0 09
	00 00		 lea	 rdx, QWORD PTR [rcx+2480]
  0002a	e8 00 00 00 00	 call	 scan_tree

; 815  : 
; 816  :     /* Build the bit length tree: */
; 817  :     build_tree(s, (tree_desc *)(&(s->bl_desc)));

  0002f	48 8d 91 70 0b
	00 00		 lea	 rdx, QWORD PTR [rcx+2928]
  00036	e8 00 00 00 00	 call	 build_tree

; 818  :     /* opt_len now includes the length of the tree representations, except
; 819  :      * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
; 820  :      */
; 821  : 
; 822  :     /* Determine the number of bit length codes to send. The pkzip format
; 823  :      * requires that at least 4 bit length codes be sent. (appnote.txt says
; 824  :      * 3 but the actual value used is 4.)
; 825  :      */
; 826  :     for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {

  0003b	41 bb 12 00 00
	00		 mov	 r11d, 18
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:bl_order
  00048	41 8b d3	 mov	 edx, r11d
  0004b	0f 1f 44 00 00	 npad	 5
$LL4@build_bl_t:

; 827  :         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;

  00050	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  00054	66 83 bc 8b a6
	0a 00 00 00	 cmp	 WORD PTR [rbx+rcx*4+2726], 0
  0005d	75 0c		 jne	 SHORT $LN8@build_bl_t

; 818  :     /* opt_len now includes the length of the tree representations, except
; 819  :      * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
; 820  :      */
; 821  : 
; 822  :     /* Determine the number of bit length codes to send. The pkzip format
; 823  :      * requires that at least 4 bit length codes be sent. (appnote.txt says
; 824  :      * 3 but the actual value used is 4.)
; 825  :      */
; 826  :     for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {

  0005f	48 ff ca	 dec	 rdx
  00062	41 ff cb	 dec	 r11d
  00065	48 83 fa 03	 cmp	 rdx, 3
  00069	7d e5		 jge	 SHORT $LL4@build_bl_t
$LN8@build_bl_t:

; 828  :     }
; 829  :     /* Update opt_len to include the bit length tree and counts */
; 830  :     s->opt_len += 3*(max_blindex+1) + 5+5+4;

  0006b	43 8d 4c 5b 11	 lea	 ecx, DWORD PTR [r11+r11*2+17]

; 831  :     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
; 832  :             s->opt_len, s->static_len));
; 833  : 
; 834  :     return max_blindex;

  00070	41 8b c3	 mov	 eax, r11d
  00073	01 8b 00 17 00
	00		 add	 DWORD PTR [rbx+5888], ecx

; 835  : }

  00079	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007d	5b		 pop	 rbx
  0007e	c3		 ret	 0
build_bl_tree ENDP
_TEXT	ENDS
PUBLIC	_tr_stored_block
; Function compile flags: /Ogtpy
;	COMDAT _tr_stored_block
_TEXT	SEGMENT
s$ = 8
buf$ = 16
stored_len$ = 24
last$ = 32
_tr_stored_block PROC					; COMDAT

; 876  : {

  00000	4c 8b d1	 mov	 r10, rcx

; 877  :     send_bits(s, (STORED_BLOCK<<1)+last, 3);    /* send block type */

  00003	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00009	4c 8b da	 mov	 r11, rdx
  0000c	83 f9 0d	 cmp	 ecx, 13
  0000f	7e 5c		 jle	 SHORT $LN2@tr_stored_
  00011	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  00015	41 0f b7 c1	 movzx	 eax, r9w
  00019	66 d3 e0	 shl	 ax, cl
  0001c	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  00020	66 41 09 82 10
	17 00 00	 or	 WORD PTR [r10+5904], ax
  00028	41 0f b6 82 10
	17 00 00	 movzx	 eax, BYTE PTR [r10+5904]
  00030	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00033	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  00037	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  0003b	41 0f b6 82 11
	17 00 00	 movzx	 eax, BYTE PTR [r10+5905]
  00043	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  00047	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0004a	41 8b 92 14 17
	00 00		 mov	 edx, DWORD PTR [r10+5908]
  00051	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  00055	b9 10 00 00 00	 mov	 ecx, 16
  0005a	8d 42 f3	 lea	 eax, DWORD PTR [rdx-13]
  0005d	2a ca		 sub	 cl, dl
  0005f	66 41 d3 e9	 shr	 r9w, cl
  00063	66 45 89 8a 10
	17 00 00	 mov	 WORD PTR [r10+5904], r9w
  0006b	eb 0f		 jmp	 SHORT $LN5@tr_stored_
$LN2@tr_stored_:
  0006d	66 41 d3 e1	 shl	 r9w, cl
  00071	8d 41 03	 lea	 eax, DWORD PTR [rcx+3]
  00074	66 45 09 8a 10
	17 00 00	 or	 WORD PTR [r10+5904], r9w
$LN5@tr_stored_:

; 878  : #ifdef DEBUG
; 879  :     s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
; 880  :     s->compressed_len += (stored_len + 4) << 3;
; 881  : #endif
; 882  :     copy_block(s, buf, (unsigned)stored_len, 1); /* with header */

  0007c	41 b9 01 00 00
	00		 mov	 r9d, 1
  00082	49 8b d3	 mov	 rdx, r11
  00085	49 8b ca	 mov	 rcx, r10
  00088	41 89 82 14 17
	00 00		 mov	 DWORD PTR [r10+5908], eax

; 883  : }

  0008f	e9 00 00 00 00	 jmp	 copy_block
_tr_stored_block ENDP
_TEXT	ENDS
PUBLIC	_tr_align
;	COMDAT pdata
pdata	SEGMENT
$pdata$_tr_align DD imagerel $LN17
	DD	imagerel $LN17+542
	DD	imagerel $unwind$_tr_align
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_tr_align DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _tr_align
_TEXT	SEGMENT
s$ = 48
_tr_align PROC						; COMDAT

; 898  : {

$LN17:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	4c 8b d1	 mov	 r10, rcx

; 899  :     send_bits(s, STATIC_TREES<<1, 3);

  0000d	8b 89 14 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5908]
  00013	bb 02 00 00 00	 mov	 ebx, 2
  00018	8b c3		 mov	 eax, ebx
  0001a	bf 10 00 00 00	 mov	 edi, 16
  0001f	66 d3 e0	 shl	 ax, cl
  00022	66 41 09 82 10
	17 00 00	 or	 WORD PTR [r10+5904], ax
  0002a	83 f9 0d	 cmp	 ecx, 13
  0002d	7e 4b		 jle	 SHORT $LN9@tr_align
  0002f	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  00033	41 0f b6 82 10
	17 00 00	 movzx	 eax, BYTE PTR [r10+5904]
  0003b	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  0003f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00042	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  00046	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  0004a	41 0f b6 82 11
	17 00 00	 movzx	 eax, BYTE PTR [r10+5905]
  00052	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  00056	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00059	41 8b 92 14 17
	00 00		 mov	 edx, DWORD PTR [r10+5908]
  00060	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  00064	8b c3		 mov	 eax, ebx
  00066	8b cf		 mov	 ecx, edi
  00068	2a ca		 sub	 cl, dl
  0006a	66 d3 e8	 shr	 ax, cl
  0006d	66 41 89 82 10
	17 00 00	 mov	 WORD PTR [r10+5904], ax
  00075	8d 42 f3	 lea	 eax, DWORD PTR [rdx-13]
  00078	eb 03		 jmp	 SHORT $LN13@tr_align
$LN9@tr_align:
  0007a	8d 41 03	 lea	 eax, DWORD PTR [rcx+3]
$LN13@tr_align:

; 900  :     send_code(s, END_BLOCK, static_ltree);

  0007d	8b c8		 mov	 ecx, eax
  0007f	45 33 db	 xor	 r11d, r11d
  00082	41 89 82 14 17
	00 00		 mov	 DWORD PTR [r10+5908], eax
  00089	41 8b c3	 mov	 eax, r11d
  0008c	66 d3 e0	 shl	 ax, cl
  0008f	66 41 09 82 10
	17 00 00	 or	 WORD PTR [r10+5904], ax
  00097	83 f9 09	 cmp	 ecx, 9
  0009a	7e 4c		 jle	 SHORT $LN7@tr_align
  0009c	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  000a0	41 0f b6 82 10
	17 00 00	 movzx	 eax, BYTE PTR [r10+5904]
  000a8	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  000ac	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000af	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  000b3	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  000b7	41 0f b6 82 11
	17 00 00	 movzx	 eax, BYTE PTR [r10+5905]
  000bf	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  000c3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000c6	41 8b 92 14 17
	00 00		 mov	 edx, DWORD PTR [r10+5908]
  000cd	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  000d1	41 8b c3	 mov	 eax, r11d
  000d4	8b cf		 mov	 ecx, edi
  000d6	2a ca		 sub	 cl, dl
  000d8	66 d3 e8	 shr	 ax, cl
  000db	66 41 89 82 10
	17 00 00	 mov	 WORD PTR [r10+5904], ax
  000e3	8d 42 f7	 lea	 eax, DWORD PTR [rdx-9]
  000e6	eb 03		 jmp	 SHORT $LN14@tr_align
$LN7@tr_align:
  000e8	8d 41 07	 lea	 eax, DWORD PTR [rcx+7]
$LN14@tr_align:

; 901  : #ifdef DEBUG
; 902  :     s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
; 903  : #endif
; 904  :     bi_flush(s);

  000eb	49 8b ca	 mov	 rcx, r10
  000ee	41 89 82 14 17
	00 00		 mov	 DWORD PTR [r10+5908], eax
  000f5	e8 00 00 00 00	 call	 bi_flush

; 905  :     /* Of the 10 bits for the empty block, we have already sent
; 906  :      * (10 - bi_valid) bits. The lookahead for the last real code (before
; 907  :      * the EOB of the previous block) was thus at least one plus the length
; 908  :      * of the EOB plus what we have just sent of the empty static block.
; 909  :      */
; 910  :     if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {

  000fa	41 8b 8a 14 17
	00 00		 mov	 ecx, DWORD PTR [r10+5908]
  00101	41 8b 82 0c 17
	00 00		 mov	 eax, DWORD PTR [r10+5900]
  00108	2b c1		 sub	 eax, ecx
  0010a	83 c0 0b	 add	 eax, 11
  0010d	83 f8 09	 cmp	 eax, 9
  00110	0f 8d f2 00 00
	00		 jge	 $LN12@tr_align

; 911  :         send_bits(s, STATIC_TREES<<1, 3);

  00116	83 f9 0d	 cmp	 ecx, 13
  00119	7e 56		 jle	 SHORT $LN4@tr_align
  0011b	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  0011f	8b c3		 mov	 eax, ebx
  00121	66 d3 e0	 shl	 ax, cl
  00124	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  00128	66 41 09 82 10
	17 00 00	 or	 WORD PTR [r10+5904], ax
  00130	41 0f b6 82 10
	17 00 00	 movzx	 eax, BYTE PTR [r10+5904]
  00138	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0013b	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  0013f	41 8b 52 28	 mov	 edx, DWORD PTR [r10+40]
  00143	41 0f b6 82 11
	17 00 00	 movzx	 eax, BYTE PTR [r10+5905]
  0014b	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  0014f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00152	41 8b 92 14 17
	00 00		 mov	 edx, DWORD PTR [r10+5908]
  00159	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  0015d	8b cf		 mov	 ecx, edi
  0015f	8d 42 f3	 lea	 eax, DWORD PTR [rdx-13]
  00162	2a ca		 sub	 cl, dl
  00164	66 d3 eb	 shr	 bx, cl
  00167	66 41 89 9a 10
	17 00 00	 mov	 WORD PTR [r10+5904], bx
  0016f	eb 0e		 jmp	 SHORT $LN15@tr_align
$LN4@tr_align:
  00171	66 d3 e3	 shl	 bx, cl
  00174	8d 41 03	 lea	 eax, DWORD PTR [rcx+3]
  00177	66 41 09 9a 10
	17 00 00	 or	 WORD PTR [r10+5904], bx
$LN15@tr_align:
  0017f	41 89 82 14 17
	00 00		 mov	 DWORD PTR [r10+5908], eax

; 912  :         send_code(s, END_BLOCK, static_ltree);

  00186	8b c8		 mov	 ecx, eax
  00188	83 f8 09	 cmp	 eax, 9
  0018b	7e 5d		 jle	 SHORT $LN2@tr_align
  0018d	45 8b 42 28	 mov	 r8d, DWORD PTR [r10+40]
  00191	49 8b 52 10	 mov	 rdx, QWORD PTR [r10+16]
  00195	41 8b c3	 mov	 eax, r11d
  00198	66 d3 e0	 shl	 ax, cl
  0019b	66 41 09 82 10
	17 00 00	 or	 WORD PTR [r10+5904], ax
  001a3	41 0f b6 82 10
	17 00 00	 movzx	 eax, BYTE PTR [r10+5904]
  001ab	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  001af	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  001b3	41 0f b6 82 11
	17 00 00	 movzx	 eax, BYTE PTR [r10+5905]
  001bb	45 8b 42 28	 mov	 r8d, DWORD PTR [r10+40]
  001bf	49 8b 52 10	 mov	 rdx, QWORD PTR [r10+16]
  001c3	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  001c7	41 8b 92 14 17
	00 00		 mov	 edx, DWORD PTR [r10+5908]
  001ce	41 ff 42 28	 inc	 DWORD PTR [r10+40]
  001d2	40 2a fa	 sub	 dil, dl
  001d5	8d 42 f7	 lea	 eax, DWORD PTR [rdx-9]
  001d8	40 0f b6 cf	 movzx	 ecx, dil
  001dc	66 41 d3 eb	 shr	 r11w, cl
  001e0	66 45 89 9a 10
	17 00 00	 mov	 WORD PTR [r10+5904], r11w
  001e8	eb 0f		 jmp	 SHORT $LN16@tr_align
$LN2@tr_align:
  001ea	66 41 d3 e3	 shl	 r11w, cl
  001ee	8d 41 07	 lea	 eax, DWORD PTR [rcx+7]
  001f1	66 45 09 9a 10
	17 00 00	 or	 WORD PTR [r10+5904], r11w
$LN16@tr_align:

; 913  : #ifdef DEBUG
; 914  :         s->compressed_len += 10L;
; 915  : #endif
; 916  :         bi_flush(s);

  001f9	49 8b ca	 mov	 rcx, r10
  001fc	41 89 82 14 17
	00 00		 mov	 DWORD PTR [r10+5908], eax
  00203	e8 00 00 00 00	 call	 bi_flush
$LN12@tr_align:

; 917  :     }
; 918  :     s->last_eob_len = 7;

  00208	41 c7 82 0c 17
	00 00 07 00 00
	00		 mov	 DWORD PTR [r10+5900], 7

; 919  : }

  00213	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00218	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0021c	5f		 pop	 rdi
  0021d	c3		 ret	 0
_tr_align ENDP
_TEXT	ENDS
PUBLIC	_tr_flush_block
;	COMDAT pdata
pdata	SEGMENT
$pdata$_tr_flush_block DD imagerel $LN21
	DD	imagerel $LN21+545
	DD	imagerel $unwind$_tr_flush_block
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_tr_flush_block DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _tr_flush_block
_TEXT	SEGMENT
s$ = 48
buf$ = 56
stored_len$ = 64
last$ = 72
_tr_flush_block PROC					; COMDAT

; 930  : {

$LN21:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	41 8b f9	 mov	 edi, r9d

; 931  :     ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
; 932  :     int max_blindex = 0;  /* index of last bit length code of non zero freq */

  00017	45 33 c9	 xor	 r9d, r9d
  0001a	41 8b f0	 mov	 esi, r8d
  0001d	48 8b ea	 mov	 rbp, rdx
  00020	48 8b d9	 mov	 rbx, rcx

; 933  : 
; 934  :     /* Build the Huffman trees unless a stored block is forced */
; 935  :     if (s->level > 0) {

  00023	44 39 89 ac 00
	00 00		 cmp	 DWORD PTR [rcx+172], r9d
  0002a	7e 5a		 jle	 SHORT $LN14@tr_flush_b

; 936  : 
; 937  :         /* Check if the file is binary or text */
; 938  :         if (s->strm->data_type == Z_UNKNOWN)

  0002c	4c 8b 11	 mov	 r10, QWORD PTR [rcx]
  0002f	41 83 7a 48 02	 cmp	 DWORD PTR [r10+72], 2
  00034	75 09		 jne	 SHORT $LN13@tr_flush_b

; 939  :             s->strm->data_type = detect_data_type(s);

  00036	e8 00 00 00 00	 call	 detect_data_type
  0003b	41 89 42 48	 mov	 DWORD PTR [r10+72], eax
$LN13@tr_flush_b:

; 940  : 
; 941  :         /* Construct the literal and distance trees */
; 942  :         build_tree(s, (tree_desc *)(&(s->l_desc)));

  0003f	48 8d 93 40 0b
	00 00		 lea	 rdx, QWORD PTR [rbx+2880]
  00046	48 8b cb	 mov	 rcx, rbx
  00049	e8 00 00 00 00	 call	 build_tree

; 943  :         Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
; 944  :                 s->static_len));
; 945  : 
; 946  :         build_tree(s, (tree_desc *)(&(s->d_desc)));

  0004e	48 8d 93 58 0b
	00 00		 lea	 rdx, QWORD PTR [rbx+2904]
  00055	48 8b cb	 mov	 rcx, rbx
  00058	e8 00 00 00 00	 call	 build_tree

; 947  :         Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
; 948  :                 s->static_len));
; 949  :         /* At this point, opt_len and static_len are the total bit lengths of
; 950  :          * the compressed block data, excluding the tree representations.
; 951  :          */
; 952  : 
; 953  :         /* Build the bit length tree for the above two trees, and get the index
; 954  :          * in bl_order of the last bit length code to send.
; 955  :          */
; 956  :         max_blindex = build_bl_tree(s);

  0005d	48 8b cb	 mov	 rcx, rbx
  00060	e8 00 00 00 00	 call	 build_bl_tree

; 957  : 
; 958  :         /* Determine the best encoding. Compute the block lengths in bytes. */
; 959  :         opt_lenb = (s->opt_len+3+7)>>3;

  00065	8b 8b 00 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5888]

; 960  :         static_lenb = (s->static_len+3+7)>>3;

  0006b	8b 93 04 17 00
	00		 mov	 edx, DWORD PTR [rbx+5892]
  00071	83 c1 0a	 add	 ecx, 10
  00074	83 c2 0a	 add	 edx, 10
  00077	44 8b c8	 mov	 r9d, eax
  0007a	c1 e9 03	 shr	 ecx, 3
  0007d	c1 ea 03	 shr	 edx, 3

; 961  : 
; 962  :         Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
; 963  :                 opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
; 964  :                 s->last_lit));
; 965  : 
; 966  :         if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

  00080	3b d1		 cmp	 edx, ecx
  00082	77 08		 ja	 SHORT $LN11@tr_flush_b

; 967  : 
; 968  :     } else {

  00084	eb 04		 jmp	 SHORT $LN17@tr_flush_b
$LN14@tr_flush_b:

; 969  :         Assert(buf != (char*)0, "lost buf");
; 970  :         opt_lenb = static_lenb = stored_len + 5; /* force a stored block */

  00086	41 8d 50 05	 lea	 edx, DWORD PTR [r8+5]
$LN17@tr_flush_b:
  0008a	8b ca		 mov	 ecx, edx
$LN11@tr_flush_b:

; 971  :     }
; 972  : 
; 973  : #ifdef FORCE_STORED
; 974  :     if (buf != (char*)0) { /* force stored block */
; 975  : #else
; 976  :     if (stored_len+4 <= opt_lenb && buf != (char*)0) {

  0008c	8d 46 04	 lea	 eax, DWORD PTR [rsi+4]
  0008f	3b c1		 cmp	 eax, ecx
  00091	77 1b		 ja	 SHORT $LN10@tr_flush_b
  00093	48 85 ed	 test	 rbp, rbp
  00096	74 16		 je	 SHORT $LN10@tr_flush_b

; 977  :                        /* 4: two words for the lengths */
; 978  : #endif
; 979  :         /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
; 980  :          * Otherwise we can't have processed more than WSIZE input bytes since
; 981  :          * the last block flush, because compression would have been
; 982  :          * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
; 983  :          * transform a block into a stored block.
; 984  :          */
; 985  :         _tr_stored_block(s, buf, stored_len, last);

  00098	44 8b cf	 mov	 r9d, edi
  0009b	44 8b c6	 mov	 r8d, esi
  0009e	48 8b d5	 mov	 rdx, rbp
  000a1	48 8b cb	 mov	 rcx, rbx
  000a4	e8 00 00 00 00	 call	 _tr_stored_block
  000a9	e9 4d 01 00 00	 jmp	 $LN4@tr_flush_b
$LN10@tr_flush_b:

; 986  : 
; 987  : #ifdef FORCE_STATIC
; 988  :     } else if (static_lenb >= 0) { /* force static trees */
; 989  : #else
; 990  :     } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {

  000ae	83 bb b0 00 00
	00 04		 cmp	 DWORD PTR [rbx+176], 4
  000b5	0f 84 b1 00 00
	00		 je	 $LN7@tr_flush_b
  000bb	3b d1		 cmp	 edx, ecx
  000bd	0f 84 a9 00 00
	00		 je	 $LN7@tr_flush_b

; 994  : #ifdef DEBUG
; 995  :         s->compressed_len += 3 + s->static_len;
; 996  : #endif
; 997  :     } else {
; 998  :         send_bits(s, (DYN_TREES<<1)+last, 3);

  000c3	8b 8b 14 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5908]
  000c9	83 f9 0d	 cmp	 ecx, 13
  000cc	7e 58		 jle	 SHORT $LN3@tr_flush_b
  000ce	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  000d1	44 8d 47 04	 lea	 r8d, DWORD PTR [rdi+4]
  000d5	41 0f b7 c0	 movzx	 eax, r8w
  000d9	66 d3 e0	 shl	 ax, cl
  000dc	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  000e0	66 09 83 10 17
	00 00		 or	 WORD PTR [rbx+5904], ax
  000e7	0f b6 83 10 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5904]
  000ee	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000f1	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000f4	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  000f7	0f b6 83 11 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5905]
  000fe	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00102	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00105	8b 93 14 17 00
	00		 mov	 edx, DWORD PTR [rbx+5908]
  0010b	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0010e	b9 10 00 00 00	 mov	 ecx, 16
  00113	8d 42 f3	 lea	 eax, DWORD PTR [rdx-13]
  00116	2a ca		 sub	 cl, dl
  00118	66 41 d3 e8	 shr	 r8w, cl
  0011c	66 44 89 83 10
	17 00 00	 mov	 WORD PTR [rbx+5904], r8w
  00124	eb 10		 jmp	 SHORT $LN18@tr_flush_b
$LN3@tr_flush_b:
  00126	8d 47 04	 lea	 eax, DWORD PTR [rdi+4]
  00129	66 d3 e0	 shl	 ax, cl
  0012c	66 09 83 10 17
	00 00		 or	 WORD PTR [rbx+5904], ax
  00133	8d 41 03	 lea	 eax, DWORD PTR [rcx+3]
$LN18@tr_flush_b:

; 999  :         send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
; 1000 :                        max_blindex+1);

  00136	44 8b 83 60 0b
	00 00		 mov	 r8d, DWORD PTR [rbx+2912]
  0013d	8b 93 48 0b 00
	00		 mov	 edx, DWORD PTR [rbx+2888]
  00143	41 ff c1	 inc	 r9d
  00146	48 8b cb	 mov	 rcx, rbx
  00149	41 ff c0	 inc	 r8d
  0014c	ff c2		 inc	 edx
  0014e	89 83 14 17 00
	00		 mov	 DWORD PTR [rbx+5908], eax
  00154	e8 00 00 00 00	 call	 send_all_trees

; 1001 :         compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);

  00159	4c 8d 83 b0 09
	00 00		 lea	 r8, QWORD PTR [rbx+2480]
  00160	48 8d 93 bc 00
	00 00		 lea	 rdx, QWORD PTR [rbx+188]
  00167	e9 87 00 00 00	 jmp	 $LN19@tr_flush_b
$LN7@tr_flush_b:

; 991  : #endif
; 992  :         send_bits(s, (STATIC_TREES<<1)+last, 3);

  0016c	8b 8b 14 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5908]
  00172	83 f9 0d	 cmp	 ecx, 13
  00175	7e 58		 jle	 SHORT $LN6@tr_flush_b
  00177	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  0017a	44 8d 47 02	 lea	 r8d, DWORD PTR [rdi+2]
  0017e	41 0f b7 c0	 movzx	 eax, r8w
  00182	66 d3 e0	 shl	 ax, cl
  00185	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00189	66 09 83 10 17
	00 00		 or	 WORD PTR [rbx+5904], ax
  00190	0f b6 83 10 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5904]
  00197	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0019a	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0019d	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  001a0	0f b6 83 11 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5905]
  001a7	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  001ab	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001ae	8b 93 14 17 00
	00		 mov	 edx, DWORD PTR [rbx+5908]
  001b4	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001b7	b9 10 00 00 00	 mov	 ecx, 16
  001bc	8d 42 f3	 lea	 eax, DWORD PTR [rdx-13]
  001bf	2a ca		 sub	 cl, dl
  001c1	66 41 d3 e8	 shr	 r8w, cl
  001c5	66 44 89 83 10
	17 00 00	 mov	 WORD PTR [rbx+5904], r8w
  001cd	eb 10		 jmp	 SHORT $LN20@tr_flush_b
$LN6@tr_flush_b:
  001cf	8d 47 02	 lea	 eax, DWORD PTR [rdi+2]
  001d2	66 d3 e0	 shl	 ax, cl
  001d5	66 09 83 10 17
	00 00		 or	 WORD PTR [rbx+5904], ax
  001dc	8d 41 03	 lea	 eax, DWORD PTR [rcx+3]
$LN20@tr_flush_b:
  001df	89 83 14 17 00
	00		 mov	 DWORD PTR [rbx+5908], eax

; 993  :         compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);

  001e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:static_dtree
  001ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:static_ltree
$LN19@tr_flush_b:
  001f3	48 8b cb	 mov	 rcx, rbx
  001f6	e8 00 00 00 00	 call	 compress_block
$LN4@tr_flush_b:

; 1002 : #ifdef DEBUG
; 1003 :         s->compressed_len += 3 + s->opt_len;
; 1004 : #endif
; 1005 :     }
; 1006 :     Assert (s->compressed_len == s->bits_sent, "bad compressed size");
; 1007 :     /* The above check is made mod 2^32, for files larger than 512 MB
; 1008 :      * and uLong implemented on 32 bits.
; 1009 :      */
; 1010 :     init_block(s);

  001fb	48 8b cb	 mov	 rcx, rbx
  001fe	e8 00 00 00 00	 call	 init_block

; 1011 : 
; 1012 :     if (last) {

  00203	85 ff		 test	 edi, edi
  00205	74 05		 je	 SHORT $LN1@tr_flush_b

; 1013 :         bi_windup(s);

  00207	e8 00 00 00 00	 call	 bi_windup
$LN1@tr_flush_b:

; 1014 : #ifdef DEBUG
; 1015 :         s->compressed_len += 7;  /* align on byte boundary */
; 1016 : #endif
; 1017 :     }
; 1018 :     Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
; 1019 :            s->compressed_len-7*last));
; 1020 : }

  0020c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00211	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00216	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0021b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0021f	5f		 pop	 rdi
  00220	c3		 ret	 0
_tr_flush_block ENDP
_TEXT	ENDS
END
