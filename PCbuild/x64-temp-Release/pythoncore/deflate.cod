; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	deflate_copyright
CONST	SEGMENT
deflate_copyright DB ' deflate 1.2.5 Copyright 1995-2010 Jean-loup Gailly'
	DB	' and Mark Adler ', 00H
?my_version@?1??deflateInit2_@@9@9 DB '1.2.5', 00H	; `deflateInit2_'::`2'::my_version
	ORG $+6
configuration_table DW 00H
	DW	00H
	DW	00H
	DW	00H
	DQ	FLAT:deflate_stored
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	05H
	DW	010H
	DW	08H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	06H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	04H
	DW	010H
	DW	010H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	080H
	DW	080H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	020H
	DW	080H
	DW	0100H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	080H
	DW	0102H
	DW	0400H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	0102H
	DW	0102H
	DW	01000H
	DQ	FLAT:deflate_slow
CONST	ENDS
PUBLIC	deflateSetDictionary
EXTRN	adler32:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\zlib\deflate.c
pdata	SEGMENT
$pdata$deflateSetDictionary DD imagerel $LN15
	DD	imagerel $LN15+322
	DD	imagerel $unwind$deflateSetDictionary
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateSetDictionary DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT deflateSetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
deflateSetDictionary PROC				; COMDAT

; 315  : {

$LN15:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	41 8b f8	 mov	 edi, r8d
  0001d	48 8b f2	 mov	 rsi, rdx
  00020	48 8b e9	 mov	 rbp, rcx

; 316  :     deflate_state *s;
; 317  :     uInt length = dictLength;

  00023	45 8b e0	 mov	 r12d, r8d

; 318  :     uInt n;
; 319  :     IPos hash_head = 0;
; 320  : 
; 321  :     if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
; 322  :         strm->state->wrap == 2 ||
; 323  :         (strm->state->wrap == 1 && strm->state->status != INIT_STATE))

  00026	48 85 c9	 test	 rcx, rcx
  00029	0f 84 f3 00 00
	00		 je	 $LN8@deflateSet
  0002f	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  00033	48 85 db	 test	 rbx, rbx
  00036	0f 84 e6 00 00
	00		 je	 $LN8@deflateSet
  0003c	48 85 d2	 test	 rdx, rdx
  0003f	0f 84 dd 00 00
	00		 je	 $LN8@deflateSet
  00045	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  00048	83 f8 02	 cmp	 eax, 2
  0004b	0f 84 d1 00 00
	00		 je	 $LN8@deflateSet
  00051	83 f8 01	 cmp	 eax, 1
  00054	75 0a		 jne	 SHORT $LN9@deflateSet
  00056	83 7b 08 2a	 cmp	 DWORD PTR [rbx+8], 42	; 0000002aH
  0005a	0f 85 c2 00 00
	00		 jne	 $LN8@deflateSet
$LN9@deflateSet:

; 325  : 
; 326  :     s = strm->state;
; 327  :     if (s->wrap)

  00060	83 f8 00	 cmp	 eax, 0
  00063	74 0b		 je	 SHORT $LN7@deflateSet

; 328  :         strm->adler = adler32(strm->adler, dictionary, dictLength);

  00065	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00068	e8 00 00 00 00	 call	 adler32
  0006d	89 45 4c	 mov	 DWORD PTR [rbp+76], eax
$LN7@deflateSet:

; 329  : 
; 330  :     if (length < MIN_MATCH) return Z_OK;

  00070	83 ff 03	 cmp	 edi, 3
  00073	0f 82 a5 00 00
	00		 jb	 $LN14@deflateSet

; 331  :     if (length > s->w_size) {

  00079	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  0007c	3b f8		 cmp	 edi, eax
  0007e	76 0a		 jbe	 SHORT $LN5@deflateSet

; 332  :         length = s->w_size;
; 333  :         dictionary += dictLength - length; /* use the tail of the dictionary */

  00080	2b f8		 sub	 edi, eax
  00082	44 8b e0	 mov	 r12d, eax
  00085	8b c7		 mov	 eax, edi
  00087	48 03 f0	 add	 rsi, rax
$LN5@deflateSet:

; 334  :     }
; 335  :     zmemcpy(s->window, dictionary, length);

  0008a	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  0008e	45 8b c4	 mov	 r8d, r12d
  00091	48 8b d6	 mov	 rdx, rsi
  00094	e8 00 00 00 00	 call	 memcpy

; 336  :     s->strstart = length;
; 337  :     s->block_start = (long)length;
; 338  : 
; 339  :     /* Insert all strings in the hash table (except for the last two bytes).
; 340  :      * s->lookahead stays null, so s->ins_h will be recomputed at the next
; 341  :      * call of fill_window.
; 342  :      */
; 343  :     s->ins_h = s->window[0];

  00099	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]

; 344  :     UPDATE_HASH(s, s->ins_h, s->window[1]);

  0009d	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  000a3	44 89 a3 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r12d
  000aa	44 89 a3 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r12d
  000b1	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  000b4	89 53 70	 mov	 DWORD PTR [rbx+112], edx
  000b7	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  000bb	d3 e2		 shl	 edx, cl
  000bd	33 d0		 xor	 edx, eax

; 345  :     for (n = 0; n <= length - MIN_MATCH; n++) {

  000bf	45 33 c9	 xor	 r9d, r9d
  000c2	23 53 7c	 and	 edx, DWORD PTR [rbx+124]
  000c5	41 83 c4 fd	 add	 r12d, -3		; fffffffdH
  000c9	45 8b d1	 mov	 r10d, r9d
  000cc	89 53 70	 mov	 DWORD PTR [rbx+112], edx
  000cf	90		 npad	 1
$LL4@deflateSet:

; 346  :         INSERT_STRING(s, n, hash_head);

  000d0	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000d4	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  000da	8b 53 4c	 mov	 edx, DWORD PTR [rbx+76]
  000dd	46 0f b6 44 10
	02		 movzx	 r8d, BYTE PTR [rax+r10+2]
  000e3	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  000e6	49 23 d2	 and	 rdx, r10
  000e9	d3 e0		 shl	 eax, cl
  000eb	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  000ef	49 ff c2	 inc	 r10
  000f2	44 33 c0	 xor	 r8d, eax
  000f5	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  000f9	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  000fd	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  00101	42 0f b7 04 40	 movzx	 eax, WORD PTR [rax+r8*2]
  00106	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  0010a	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  0010d	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00111	66 44 89 0c 48	 mov	 WORD PTR [rax+rcx*2], r9w
  00116	41 ff c1	 inc	 r9d
  00119	45 3b cc	 cmp	 r9d, r12d
  0011c	76 b2		 jbe	 SHORT $LL4@deflateSet
$LN14@deflateSet:

; 347  :     }
; 348  :     if (hash_head) hash_head = 0;  /* to make compiler happy */
; 349  :     return Z_OK;

  0011e	33 c0		 xor	 eax, eax
  00120	eb 05		 jmp	 SHORT $LN10@deflateSet
$LN8@deflateSet:

; 324  :         return Z_STREAM_ERROR;

  00122	b8 fe ff ff ff	 mov	 eax, -2
$LN10@deflateSet:

; 350  : }

  00127	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0012c	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00131	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00136	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0013b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013f	41 5c		 pop	 r12
  00141	c3		 ret	 0
deflateSetDictionary ENDP
_TEXT	ENDS
PUBLIC	deflateSetHeader
; Function compile flags: /Ogtpy
;	COMDAT deflateSetHeader
_TEXT	SEGMENT
strm$ = 8
head$ = 16
deflateSetHeader PROC					; COMDAT

; 393  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 16		 je	 SHORT $LN2@deflateSet@2
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 0d		 je	 SHORT $LN2@deflateSet@2

; 394  :     if (strm->state->wrap != 2) return Z_STREAM_ERROR;

  0000e	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  00012	75 07		 jne	 SHORT $LN2@deflateSet@2

; 395  :     strm->state->gzhead = head;

  00014	48 89 50 30	 mov	 QWORD PTR [rax+48], rdx

; 396  :     return Z_OK;

  00018	33 c0		 xor	 eax, eax

; 397  : }

  0001a	c3		 ret	 0
$LN2@deflateSet@2:

; 393  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0001b	b8 fe ff ff ff	 mov	 eax, -2

; 397  : }

  00020	c3		 ret	 0
deflateSetHeader ENDP
_TEXT	ENDS
PUBLIC	deflatePrime
; Function compile flags: /Ogtpy
;	COMDAT deflatePrime
_TEXT	SEGMENT
strm$ = 8
bits$ = 16
value$ = 24
deflatePrime PROC					; COMDAT

; 404  : {

  00000	4c 8b d1	 mov	 r10, rcx

; 405  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	48 85 c9	 test	 rcx, rcx
  00006	74 34		 je	 SHORT $LN1@deflatePri
  00008	48 83 79 28 00	 cmp	 QWORD PTR [rcx+40], 0
  0000d	74 2d		 je	 SHORT $LN1@deflatePri

; 406  :     strm->state->bi_valid = bits;

  0000f	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 407  :     strm->state->bi_buf = (ush)(value & ((1 << bits) - 1));

  00013	41 b9 01 00 00
	00		 mov	 r9d, 1
  00019	8b ca		 mov	 ecx, edx
  0001b	66 41 d3 e1	 shl	 r9w, cl
  0001f	89 90 14 17 00
	00		 mov	 DWORD PTR [rax+5908], edx
  00025	49 8b 42 28	 mov	 rax, QWORD PTR [r10+40]
  00029	66 41 ff c9	 dec	 r9w
  0002d	66 45 23 c8	 and	 r9w, r8w
  00031	66 44 89 88 10
	17 00 00	 mov	 WORD PTR [rax+5904], r9w

; 408  :     return Z_OK;

  00039	33 c0		 xor	 eax, eax

; 409  : }

  0003b	c3		 ret	 0
$LN1@deflatePri:

; 405  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0003c	b8 fe ff ff ff	 mov	 eax, -2

; 409  : }

  00041	c3		 ret	 0
deflatePrime ENDP
_TEXT	ENDS
PUBLIC	deflateTune
; Function compile flags: /Ogtpy
;	COMDAT deflateTune
_TEXT	SEGMENT
strm$ = 8
good_length$ = 16
max_lazy$ = 24
nice_length$ = 32
max_chain$ = 40
deflateTune PROC					; COMDAT

; 458  :     deflate_state *s;
; 459  : 
; 460  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 2a		 je	 SHORT $LN1@deflateTun
  00005	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 21		 je	 SHORT $LN1@deflateTun

; 461  :     s = strm->state;
; 462  :     s->good_match = good_length;
; 463  :     s->max_lazy_match = max_lazy;
; 464  :     s->nice_match = nice_length;
; 465  :     s->max_chain_length = max_chain;

  0000e	8b 44 24 28	 mov	 eax, DWORD PTR max_chain$[rsp]
  00012	89 91 b4 00 00
	00		 mov	 DWORD PTR [rcx+180], edx
  00018	44 89 81 a8 00
	00 00		 mov	 DWORD PTR [rcx+168], r8d
  0001f	89 81 a4 00 00
	00		 mov	 DWORD PTR [rcx+164], eax

; 466  :     return Z_OK;

  00025	33 c0		 xor	 eax, eax
  00027	44 89 89 b8 00
	00 00		 mov	 DWORD PTR [rcx+184], r9d

; 467  : }

  0002e	c3		 ret	 0
$LN1@deflateTun:

; 458  :     deflate_state *s;
; 459  : 
; 460  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0002f	b8 fe ff ff ff	 mov	 eax, -2

; 467  : }

  00034	c3		 ret	 0
deflateTune ENDP
_TEXT	ENDS
PUBLIC	deflateBound
; Function compile flags: /Ogtpy
;	COMDAT deflateBound
_TEXT	SEGMENT
strm$ = 8
sourceLen$ = 16
deflateBound PROC					; COMDAT

; 490  :     deflate_state *s;
; 491  :     uLong complen, wraplen;
; 492  :     Bytef *str;
; 493  : 
; 494  :     /* conservative upper bound for compressed data */
; 495  :     complen = sourceLen +
; 496  :               ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;

  00000	8d 42 3f	 lea	 eax, DWORD PTR [rdx+63]
  00003	44 8d 42 07	 lea	 r8d, DWORD PTR [rdx+7]
  00007	44 8b da	 mov	 r11d, edx
  0000a	c1 e8 06	 shr	 eax, 6
  0000d	41 c1 e8 03	 shr	 r8d, 3
  00011	03 c2		 add	 eax, edx
  00013	45 8d 54 00 05	 lea	 r10d, DWORD PTR [r8+rax+5]

; 497  : 
; 498  :     /* if can't get parameters, return conservative bound plus zlib wrapper */
; 499  :     if (strm == Z_NULL || strm->state == Z_NULL)

  00018	48 85 c9	 test	 rcx, rcx
  0001b	0f 84 e3 00 00
	00		 je	 $LN20@deflateBou
  00021	4c 8b 49 28	 mov	 r9, QWORD PTR [rcx+40]
  00025	4d 85 c9	 test	 r9, r9
  00028	0f 84 d6 00 00
	00		 je	 $LN20@deflateBou

; 501  : 
; 502  :     /* compute wrapper length */
; 503  :     s = strm->state;
; 504  :     switch (s->wrap) {

  0002e	41 8b 49 2c	 mov	 ecx, DWORD PTR [r9+44]
  00032	85 c9		 test	 ecx, ecx
  00034	0f 84 95 00 00
	00		 je	 $LN17@deflateBou
  0003a	ff c9		 dec	 ecx
  0003c	74 7b		 je	 SHORT $LN16@deflateBou
  0003e	ff c9		 dec	 ecx
  00040	74 0b		 je	 SHORT $LN15@deflateBou

; 530  :     default:                                /* for compiler happiness */
; 531  :         wraplen = 6;

  00042	41 b8 06 00 00
	00		 mov	 r8d, 6
  00048	e9 85 00 00 00	 jmp	 $LN18@deflateBou
$LN15@deflateBou:

; 511  :     case 2:                                 /* gzip wrapper */
; 512  :         wraplen = 18;
; 513  :         if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */

  0004d	49 8b 51 30	 mov	 rdx, QWORD PTR [r9+48]
  00051	41 b8 12 00 00
	00		 mov	 r8d, 18
  00057	48 85 d2	 test	 rdx, rdx
  0005a	74 76		 je	 SHORT $LN18@deflateBou

; 514  :             if (s->gzhead->extra != Z_NULL)

  0005c	48 83 7a 10 00	 cmp	 QWORD PTR [rdx+16], 0
  00061	74 08		 je	 SHORT $LN13@deflateBou

; 515  :                 wraplen += 2 + s->gzhead->extra_len;

  00063	44 8b 42 18	 mov	 r8d, DWORD PTR [rdx+24]
  00067	41 83 c0 14	 add	 r8d, 20
$LN13@deflateBou:

; 516  :             str = s->gzhead->name;

  0006b	48 8b 4a 20	 mov	 rcx, QWORD PTR [rdx+32]

; 517  :             if (str != Z_NULL)

  0006f	48 85 c9	 test	 rcx, rcx
  00072	74 19		 je	 SHORT $LN9@deflateBou
  00074	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL11@deflateBou:

; 518  :                 do {
; 519  :                     wraplen++;
; 520  :                 } while (*str++);

  00080	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00083	41 ff c0	 inc	 r8d
  00086	48 ff c1	 inc	 rcx
  00089	84 c0		 test	 al, al
  0008b	75 f3		 jne	 SHORT $LL11@deflateBou
$LN9@deflateBou:

; 521  :             str = s->gzhead->comment;

  0008d	48 8b 4a 30	 mov	 rcx, QWORD PTR [rdx+48]

; 522  :             if (str != Z_NULL)

  00091	48 85 c9	 test	 rcx, rcx
  00094	74 17		 je	 SHORT $LN5@deflateBou
  00096	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL7@deflateBou:

; 523  :                 do {
; 524  :                     wraplen++;
; 525  :                 } while (*str++);

  000a0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  000a3	41 ff c0	 inc	 r8d
  000a6	48 ff c1	 inc	 rcx
  000a9	84 c0		 test	 al, al
  000ab	75 f3		 jne	 SHORT $LL7@deflateBou
$LN5@deflateBou:

; 526  :             if (s->gzhead->hcrc)

  000ad	83 7a 3c 00	 cmp	 DWORD PTR [rdx+60], 0
  000b1	74 1f		 je	 SHORT $LN18@deflateBou

; 527  :                 wraplen += 2;

  000b3	41 83 c0 02	 add	 r8d, 2

; 528  :         }
; 529  :         break;

  000b7	eb 19		 jmp	 SHORT $LN18@deflateBou
$LN16@deflateBou:

; 507  :         break;
; 508  :     case 1:                                 /* zlib wrapper */
; 509  :         wraplen = 6 + (s->strstart ? 4 : 0);

  000b9	41 8b 81 94 00
	00 00		 mov	 eax, DWORD PTR [r9+148]
  000c0	f7 d8		 neg	 eax
  000c2	45 1b c0	 sbb	 r8d, r8d
  000c5	41 83 e0 04	 and	 r8d, 4
  000c9	41 83 c0 06	 add	 r8d, 6

; 510  :         break;

  000cd	eb 03		 jmp	 SHORT $LN18@deflateBou
$LN17@deflateBou:

; 505  :     case 0:                                 /* raw deflate */
; 506  :         wraplen = 0;

  000cf	45 33 c0	 xor	 r8d, r8d
$LN18@deflateBou:

; 532  :     }
; 533  : 
; 534  :     /* if not default parameters, return conservative bound */
; 535  :     if (s->w_bits != 15 || s->hash_bits != 8 + 7)

  000d2	41 83 79 48 0f	 cmp	 DWORD PTR [r9+72], 15
  000d7	75 26		 jne	 SHORT $LN1@deflateBou
  000d9	41 83 79 78 0f	 cmp	 DWORD PTR [r9+120], 15
  000de	75 1f		 jne	 SHORT $LN1@deflateBou

; 537  : 
; 538  :     /* default settings: return tight bound for that case */
; 539  :     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
; 540  :            (sourceLen >> 25) + 13 - 6 + wraplen;

  000e0	41 8b d3	 mov	 edx, r11d
  000e3	41 8b cb	 mov	 ecx, r11d
  000e6	41 8b c3	 mov	 eax, r11d
  000e9	c1 ea 0e	 shr	 edx, 14
  000ec	c1 e9 19	 shr	 ecx, 25
  000ef	c1 e8 0c	 shr	 eax, 12
  000f2	41 03 d0	 add	 edx, r8d
  000f5	03 d1		 add	 edx, ecx
  000f7	03 c2		 add	 eax, edx
  000f9	42 8d 44 18 07	 lea	 eax, DWORD PTR [rax+r11+7]

; 541  : }

  000fe	c3		 ret	 0
$LN1@deflateBou:

; 536  :         return complen + wraplen;

  000ff	43 8d 04 10	 lea	 eax, DWORD PTR [r8+r10]

; 541  : }

  00103	c3		 ret	 0
$LN20@deflateBou:

; 500  :         return complen + 6;

  00104	41 8d 42 06	 lea	 eax, DWORD PTR [r10+6]

; 541  : }

  00108	c3		 ret	 0
deflateBound ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT putShortMSB
_TEXT	SEGMENT
s$ = 8
b$ = 16
putShortMSB PROC					; COMDAT

; 552  :     put_byte(s, (Byte)(b >> 8));

  00000	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00004	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00008	44 8b ca	 mov	 r9d, edx
  0000b	41 c1 e9 08	 shr	 r9d, 8
  0000f	45 88 0c 00	 mov	 BYTE PTR [r8+rax], r9b
  00013	ff 41 28	 inc	 DWORD PTR [rcx+40]
  00016	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]

; 553  :     put_byte(s, (Byte)(b & 0xff));

  0001a	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0001e	41 88 14 00	 mov	 BYTE PTR [r8+rax], dl
  00022	ff 41 28	 inc	 DWORD PTR [rcx+40]

; 554  : }

  00025	c3		 ret	 0
putShortMSB ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$flush_pending DD imagerel flush_pending
	DD	imagerel flush_pending+43
	DD	imagerel $unwind$flush_pending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$flush_pending DD imagerel flush_pending+43
	DD	imagerel flush_pending+95
	DD	imagerel $chain$0$flush_pending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$flush_pending DD imagerel flush_pending+95
	DD	imagerel flush_pending+114
	DD	imagerel $chain$1$flush_pending
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$flush_pending DD 021H
	DD	imagerel flush_pending
	DD	imagerel flush_pending+43
	DD	imagerel $unwind$flush_pending
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$flush_pending DD 020521H
	DD	063405H
	DD	imagerel flush_pending
	DD	imagerel flush_pending+43
	DD	imagerel $unwind$flush_pending
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$flush_pending DD 040a01H
	DD	07640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT flush_pending
_TEXT	SEGMENT
strm$ = 48
flush_pending PROC					; COMDAT

; 564  : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 565  :     unsigned len = strm->state->pending;
; 566  : 
; 567  :     if (len > strm->avail_out) len = strm->avail_out;

  0000a	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  0000d	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]
  00011	48 8b f1	 mov	 rsi, rcx
  00014	8b 7a 28	 mov	 edi, DWORD PTR [rdx+40]
  00017	3b f8		 cmp	 edi, eax
  00019	0f 47 f8	 cmova	 edi, eax

; 568  :     if (len == 0) return;

  0001c	85 ff		 test	 edi, edi
  0001e	74 47		 je	 SHORT $LN1@flush_pend

; 569  : 
; 570  :     zmemcpy(strm->next_out, strm->state->pending_out, len);

  00020	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00024	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00028	44 8b c7	 mov	 r8d, edi
  0002b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00030	8b df		 mov	 ebx, edi
  00032	e8 00 00 00 00	 call	 memcpy

; 571  :     strm->next_out  += len;

  00037	48 01 5e 10	 add	 QWORD PTR [rsi+16], rbx

; 572  :     strm->state->pending_out  += len;

  0003b	48 8b 46 28	 mov	 rax, QWORD PTR [rsi+40]
  0003f	48 01 58 20	 add	 QWORD PTR [rax+32], rbx

; 573  :     strm->total_out += len;

  00043	01 7e 1c	 add	 DWORD PTR [rsi+28], edi

; 574  :     strm->avail_out  -= len;

  00046	29 7e 18	 sub	 DWORD PTR [rsi+24], edi

; 575  :     strm->state->pending -= len;

  00049	48 8b 46 28	 mov	 rax, QWORD PTR [rsi+40]
  0004d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00052	29 78 28	 sub	 DWORD PTR [rax+40], edi

; 576  :     if (strm->state->pending == 0) {

  00055	48 8b 4e 28	 mov	 rcx, QWORD PTR [rsi+40]
  00059	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  0005d	75 08		 jne	 SHORT $LN1@flush_pend

; 577  :         strm->state->pending_out = strm->state->pending_buf;

  0005f	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00063	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN1@flush_pend:

; 578  :     }
; 579  : }

  00067	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0006c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00070	5f		 pop	 rdi
  00071	c3		 ret	 0
flush_pending ENDP
_TEXT	ENDS
PUBLIC	deflateEnd
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateEnd DD imagerel $LN11
	DD	imagerel $LN11+31
	DD	imagerel $unwind$deflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$deflateEnd DD imagerel $LN11+31
	DD	imagerel $LN11+93
	DD	imagerel $chain$0$deflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$deflateEnd DD imagerel $LN11+93
	DD	imagerel $LN11+213
	DD	imagerel $chain$2$deflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflateEnd DD imagerel $LN11+213
	DD	imagerel $LN11+224
	DD	imagerel $chain$3$deflateEnd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflateEnd DD 021H
	DD	imagerel $LN11
	DD	imagerel $LN11+31
	DD	imagerel $unwind$deflateEnd
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$deflateEnd DD 020021H
	DD	067400H
	DD	imagerel $LN11
	DD	imagerel $LN11+31
	DD	imagerel $unwind$deflateEnd
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$deflateEnd DD 020521H
	DD	067405H
	DD	imagerel $LN11
	DD	imagerel $LN11+31
	DD	imagerel $unwind$deflateEnd
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateEnd DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT deflateEnd
_TEXT	SEGMENT
strm$ = 48
deflateEnd PROC						; COMDAT

; 897  : {

$LN11:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 898  :     int status;
; 899  : 
; 900  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00009	48 85 c9	 test	 rcx, rcx
  0000c	0f 84 c3 00 00
	00		 je	 $LN6@deflateEnd
  00012	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00016	48 85 c0	 test	 rax, rax
  00019	0f 84 b6 00 00
	00		 je	 $LN6@deflateEnd

; 901  : 
; 902  :     status = strm->state->status;

  0001f	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00024	8b 78 08	 mov	 edi, DWORD PTR [rax+8]

; 903  :     if (status != INIT_STATE &&
; 904  :         status != EXTRA_STATE &&
; 905  :         status != NAME_STATE &&
; 906  :         status != COMMENT_STATE &&
; 907  :         status != HCRC_STATE &&
; 908  :         status != BUSY_STATE &&
; 909  :         status != FINISH_STATE) {

  00027	83 ff 2a	 cmp	 edi, 42			; 0000002aH
  0002a	74 31		 je	 SHORT $LN5@deflateEnd
  0002c	83 ff 45	 cmp	 edi, 69			; 00000045H
  0002f	74 2c		 je	 SHORT $LN5@deflateEnd
  00031	83 ff 49	 cmp	 edi, 73			; 00000049H
  00034	74 27		 je	 SHORT $LN5@deflateEnd
  00036	83 ff 5b	 cmp	 edi, 91			; 0000005bH
  00039	74 22		 je	 SHORT $LN5@deflateEnd
  0003b	83 ff 67	 cmp	 edi, 103		; 00000067H
  0003e	74 1d		 je	 SHORT $LN5@deflateEnd
  00040	83 ff 71	 cmp	 edi, 113		; 00000071H
  00043	74 18		 je	 SHORT $LN5@deflateEnd
  00045	81 ff 9a 02 00
	00		 cmp	 edi, 666		; 0000029aH
  0004b	74 10		 je	 SHORT $LN5@deflateEnd

; 910  :       return Z_STREAM_ERROR;

  0004d	b8 fe ff ff ff	 mov	 eax, -2
  00052	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 923  : }

  00057	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005b	5b		 pop	 rbx
  0005c	c3		 ret	 0
$LN5@deflateEnd:

; 911  :     }
; 912  : 
; 913  :     /* Deallocate in reverse order of allocations: */
; 914  :     TRY_FREE(strm, strm->state->pending_buf);

  0005d	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00061	48 85 d2	 test	 rdx, rdx
  00064	74 07		 je	 SHORT $LN4@deflateEnd
  00066	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0006a	ff 53 38	 call	 QWORD PTR [rbx+56]
$LN4@deflateEnd:

; 915  :     TRY_FREE(strm, strm->state->head);

  0006d	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00071	48 8b 50 68	 mov	 rdx, QWORD PTR [rax+104]
  00075	48 85 d2	 test	 rdx, rdx
  00078	74 07		 je	 SHORT $LN3@deflateEnd
  0007a	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0007e	ff 53 38	 call	 QWORD PTR [rbx+56]
$LN3@deflateEnd:

; 916  :     TRY_FREE(strm, strm->state->prev);

  00081	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00085	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00089	48 85 d2	 test	 rdx, rdx
  0008c	74 07		 je	 SHORT $LN2@deflateEnd
  0008e	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00092	ff 53 38	 call	 QWORD PTR [rbx+56]
$LN2@deflateEnd:

; 917  :     TRY_FREE(strm, strm->state->window);

  00095	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00099	48 8b 50 50	 mov	 rdx, QWORD PTR [rax+80]
  0009d	48 85 d2	 test	 rdx, rdx
  000a0	74 07		 je	 SHORT $LN1@deflateEnd
  000a2	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000a6	ff 53 38	 call	 QWORD PTR [rbx+56]
$LN1@deflateEnd:

; 918  : 
; 919  :     ZFREE(strm, strm->state);

  000a9	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
  000ad	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000b1	ff 53 38	 call	 QWORD PTR [rbx+56]

; 920  :     strm->state = Z_NULL;

  000b4	45 33 db	 xor	 r11d, r11d

; 921  : 
; 922  :     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;

  000b7	83 ff 71	 cmp	 edi, 113		; 00000071H
  000ba	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  000bf	b8 fd ff ff ff	 mov	 eax, -3
  000c4	4c 89 5b 28	 mov	 QWORD PTR [rbx+40], r11
  000c8	44 0f 44 d8	 cmove	 r11d, eax
  000cc	41 8b c3	 mov	 eax, r11d

; 923  : }

  000cf	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d3	5b		 pop	 rbx
  000d4	c3		 ret	 0
$LN6@deflateEnd:

; 898  :     int status;
; 899  : 
; 900  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000d5	b8 fe ff ff ff	 mov	 eax, -2

; 923  : }

  000da	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000de	5b		 pop	 rbx
  000df	c3		 ret	 0
deflateEnd ENDP
_TEXT	ENDS
PUBLIC	deflateCopy
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateCopy DD imagerel $LN10
	DD	imagerel $LN10+50
	DD	imagerel $unwind$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$deflateCopy DD imagerel $LN10+50
	DD	imagerel $LN10+105
	DD	imagerel $chain$0$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflateCopy DD imagerel $LN10+105
	DD	imagerel $LN10+458
	DD	imagerel $chain$3$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$deflateCopy DD imagerel $LN10+458
	DD	imagerel $LN10+473
	DD	imagerel $chain$5$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$deflateCopy DD imagerel $LN10+473
	DD	imagerel $LN10+489
	DD	imagerel $chain$6$deflateCopy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$deflateCopy DD 021H
	DD	imagerel $LN10
	DD	imagerel $LN10+50
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$deflateCopy DD 040021H
	DD	077400H
	DD	065400H
	DD	imagerel $LN10
	DD	imagerel $LN10+50
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflateCopy DD 041121H
	DD	065411H
	DD	077400H
	DD	imagerel $LN10
	DD	imagerel $LN10+50
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$deflateCopy DD 020521H
	DD	077405H
	DD	imagerel $LN10
	DD	imagerel $LN10+50
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateCopy DD 040a01H
	DD	08340aH
	DD	06006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT deflateCopy
_TEXT	SEGMENT
dest$ = 48
source$ = 56
deflateCopy PROC					; COMDAT

; 933  : {

$LN10:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 934  : #ifdef MAXSEG_64K
; 935  :     return Z_STREAM_ERROR;
; 936  : #else
; 937  :     deflate_state *ds;
; 938  :     deflate_state *ss;
; 939  :     ushf *overlay;
; 940  : 
; 941  : 
; 942  :     if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {

  0000d	48 85 d2	 test	 rdx, rdx
  00010	0f 84 c3 01 00
	00		 je	 $LN4@deflateCop
  00016	48 85 c9	 test	 rcx, rcx
  00019	0f 84 ba 01 00
	00		 je	 $LN4@deflateCop
  0001f	48 8b 72 28	 mov	 rsi, QWORD PTR [rdx+40]
  00023	48 85 f6	 test	 rsi, rsi
  00026	0f 84 ad 01 00
	00		 je	 $LN4@deflateCop

; 944  :     }
; 945  : 
; 946  :     ss = source->state;
; 947  : 
; 948  :     zmemcpy(dest, source, sizeof(z_stream));

  0002c	41 b8 58 00 00
	00		 mov	 r8d, 88			; 00000058H
  00032	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00037	e8 00 00 00 00	 call	 memcpy

; 949  : 
; 950  :     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));

  0003c	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00040	ba 01 00 00 00	 mov	 edx, 1
  00045	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  0004b	ff 53 30	 call	 QWORD PTR [rbx+48]
  0004e	48 8b f8	 mov	 rdi, rax

; 951  :     if (ds == Z_NULL) return Z_MEM_ERROR;

  00051	48 85 c0	 test	 rax, rax
  00054	75 13		 jne	 SHORT $LN3@deflateCop
  00056	8d 47 fc	 lea	 eax, QWORD PTR [rdi-4]
  00059	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 982  : #endif /* MAXSEG_64K */
; 983  : }

  0005e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5e		 pop	 rsi
  00068	c3		 ret	 0
$LN3@deflateCop:

; 952  :     dest->state = (struct internal_state FAR *) ds;
; 953  :     zmemcpy(ds, ss, sizeof(deflate_state));

  00069	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  0006f	48 8b d6	 mov	 rdx, rsi
  00072	48 8b c8	 mov	 rcx, rax
  00075	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0007a	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  0007e	e8 00 00 00 00	 call	 memcpy

; 954  :     ds->strm = dest;
; 955  : 
; 956  :     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));

  00083	8b 57 44	 mov	 edx, DWORD PTR [rdi+68]
  00086	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  00089	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0008d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00093	ff 53 30	 call	 QWORD PTR [rbx+48]

; 957  :     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));

  00096	8b 57 44	 mov	 edx, DWORD PTR [rdi+68]
  00099	41 b8 02 00 00
	00		 mov	 r8d, 2
  0009f	48 89 47 50	 mov	 QWORD PTR [rdi+80], rax
  000a3	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000a7	ff 53 30	 call	 QWORD PTR [rbx+48]

; 958  :     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));

  000aa	8b 57 74	 mov	 edx, DWORD PTR [rdi+116]
  000ad	41 b8 02 00 00
	00		 mov	 r8d, 2
  000b3	48 89 47 60	 mov	 QWORD PTR [rdi+96], rax
  000b7	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000bb	ff 53 30	 call	 QWORD PTR [rbx+48]

; 959  :     overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);

  000be	8b 97 f0 16 00
	00		 mov	 edx, DWORD PTR [rdi+5872]
  000c4	41 b8 04 00 00
	00		 mov	 r8d, 4
  000ca	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax
  000ce	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000d2	ff 53 30	 call	 QWORD PTR [rbx+48]

; 960  :     ds->pending_buf = (uchf *) overlay;
; 961  : 
; 962  :     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
; 963  :         ds->pending_buf == Z_NULL) {

  000d5	48 8b 4f 50	 mov	 rcx, QWORD PTR [rdi+80]
  000d9	48 8b e8	 mov	 rbp, rax
  000dc	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  000e0	48 85 c9	 test	 rcx, rcx
  000e3	0f 84 e1 00 00
	00		 je	 $LN1@deflateCop
  000e9	48 83 7f 60 00	 cmp	 QWORD PTR [rdi+96], 0
  000ee	0f 84 d6 00 00
	00		 je	 $LN1@deflateCop
  000f4	48 83 7f 68 00	 cmp	 QWORD PTR [rdi+104], 0
  000f9	0f 84 cb 00 00
	00		 je	 $LN1@deflateCop
  000ff	48 85 c0	 test	 rax, rax
  00102	0f 84 c2 00 00
	00		 je	 $LN1@deflateCop

; 966  :     }
; 967  :     /* following zmemcpy do not work for 16-bit MSDOS */
; 968  :     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));

  00108	8b 47 44	 mov	 eax, DWORD PTR [rdi+68]
  0010b	48 8b 56 50	 mov	 rdx, QWORD PTR [rsi+80]
  0010f	44 8d 04 00	 lea	 r8d, DWORD PTR [rax+rax]
  00113	e8 00 00 00 00	 call	 memcpy

; 969  :     zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));

  00118	44 8b 47 44	 mov	 r8d, DWORD PTR [rdi+68]
  0011c	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]
  00120	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  00124	4d 03 c0	 add	 r8, r8
  00127	e8 00 00 00 00	 call	 memcpy

; 970  :     zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));

  0012c	44 8b 47 74	 mov	 r8d, DWORD PTR [rdi+116]
  00130	48 8b 56 68	 mov	 rdx, QWORD PTR [rsi+104]
  00134	48 8b 4f 68	 mov	 rcx, QWORD PTR [rdi+104]
  00138	4d 03 c0	 add	 r8, r8
  0013b	e8 00 00 00 00	 call	 memcpy

; 971  :     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

  00140	44 8b 47 18	 mov	 r8d, DWORD PTR [rdi+24]
  00144	48 8b 56 10	 mov	 rdx, QWORD PTR [rsi+16]
  00148	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  0014c	e8 00 00 00 00	 call	 memcpy

; 972  : 
; 973  :     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);

  00151	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]

; 974  :     ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);

  00155	8b 8f f0 16 00
	00		 mov	 ecx, DWORD PTR [rdi+5872]
  0015b	48 2b 46 10	 sub	 rax, QWORD PTR [rsi+16]
  0015f	4c 8b 5f 10	 mov	 r11, QWORD PTR [rdi+16]
  00163	49 03 c3	 add	 rax, r11
  00166	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  0016a	8b c1		 mov	 eax, ecx
  0016c	48 d1 e8	 shr	 rax, 1
  0016f	48 8d 44 45 00	 lea	 rax, QWORD PTR [rbp+rax*2]
  00174	48 89 87 f8 16
	00 00		 mov	 QWORD PTR [rdi+5880], rax

; 975  :     ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

  0017b	49 8d 04 4b	 lea	 rax, QWORD PTR [r11+rcx*2]
  0017f	48 03 c8	 add	 rcx, rax

; 976  : 
; 977  :     ds->l_desc.dyn_tree = ds->dyn_ltree;

  00182	48 8d 87 bc 00
	00 00		 lea	 rax, QWORD PTR [rdi+188]
  00189	48 89 87 40 0b
	00 00		 mov	 QWORD PTR [rdi+2880], rax

; 978  :     ds->d_desc.dyn_tree = ds->dyn_dtree;

  00190	48 8d 87 b0 09
	00 00		 lea	 rax, QWORD PTR [rdi+2480]
  00197	48 89 8f e8 16
	00 00		 mov	 QWORD PTR [rdi+5864], rcx
  0019e	48 89 87 58 0b
	00 00		 mov	 QWORD PTR [rdi+2904], rax

; 979  :     ds->bl_desc.dyn_tree = ds->bl_tree;

  001a5	48 8d 87 a4 0a
	00 00		 lea	 rax, QWORD PTR [rdi+2724]
  001ac	48 89 87 70 0b
	00 00		 mov	 QWORD PTR [rdi+2928], rax

; 980  : 
; 981  :     return Z_OK;

  001b3	33 c0		 xor	 eax, eax
$LN9@deflateCop:
  001b5	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  001ba	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 982  : #endif /* MAXSEG_64K */
; 983  : }

  001bf	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001c4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001c8	5e		 pop	 rsi
  001c9	c3		 ret	 0
$LN1@deflateCop:

; 964  :         deflateEnd (dest);

  001ca	48 8b cb	 mov	 rcx, rbx
  001cd	e8 00 00 00 00	 call	 deflateEnd

; 965  :         return Z_MEM_ERROR;

  001d2	b8 fc ff ff ff	 mov	 eax, -4
  001d7	eb dc		 jmp	 SHORT $LN9@deflateCop
$LN4@deflateCop:

; 943  :         return Z_STREAM_ERROR;

  001d9	b8 fe ff ff ff	 mov	 eax, -2

; 982  : #endif /* MAXSEG_64K */
; 983  : }

  001de	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001e3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001e7	5e		 pop	 rsi
  001e8	c3		 ret	 0
deflateCopy ENDP
_TEXT	ENDS
EXTRN	crc32:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$read_buf DD imagerel read_buf
	DD	imagerel read_buf+160
	DD	imagerel $unwind$read_buf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$read_buf DD 083e01H
	DD	06343eH
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT read_buf
_TEXT	SEGMENT
strm$ = 48
buf$ = 56
size$ = 64
read_buf PROC						; COMDAT

; 996  : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 997  :     unsigned len = strm->avail_in;

  0000f	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00012	48 8b ea	 mov	 rbp, rdx
  00015	48 8b f9	 mov	 rdi, rcx

; 998  : 
; 999  :     if (len > size) len = size;

  00018	41 3b c0	 cmp	 eax, r8d
  0001b	8b f0		 mov	 esi, eax
  0001d	41 0f 47 f0	 cmova	 esi, r8d

; 1000 :     if (len == 0) return 0;

  00021	85 f6		 test	 esi, esi
  00023	75 12		 jne	 SHORT $LN4@read_buf
  00025	33 c0		 xor	 eax, eax

; 1015 : 
; 1016 :     return (int)len;
; 1017 : }

  00027	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0002c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5f		 pop	 rdi
  00036	c3		 ret	 0
$LN4@read_buf:

; 1001 : 
; 1002 :     strm->avail_in  -= len;

  00037	2b c6		 sub	 eax, esi
  00039	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0003e	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 1003 : 
; 1004 :     if (strm->state->wrap == 1) {

  00041	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00045	8b 48 2c	 mov	 ecx, DWORD PTR [rax+44]
  00048	83 f9 01	 cmp	 ecx, 1
  0004b	75 10		 jne	 SHORT $LN3@read_buf

; 1005 :         strm->adler = adler32(strm->adler, strm->next_in, len);

  0004d	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00050	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  00053	44 8b c6	 mov	 r8d, esi
  00056	e8 00 00 00 00	 call	 adler32
  0005b	eb 13		 jmp	 SHORT $LN8@read_buf
$LN3@read_buf:

; 1006 :     }
; 1007 : #ifdef GZIP
; 1008 :     else if (strm->state->wrap == 2) {

  0005d	83 f9 02	 cmp	 ecx, 2
  00060	75 11		 jne	 SHORT $LN1@read_buf

; 1009 :         strm->adler = crc32(strm->adler, strm->next_in, len);

  00062	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00065	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  00068	44 8b c6	 mov	 r8d, esi
  0006b	e8 00 00 00 00	 call	 crc32
$LN8@read_buf:
  00070	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN1@read_buf:

; 1010 :     }
; 1011 : #endif
; 1012 :     zmemcpy(buf, strm->next_in, len);

  00073	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00076	44 8b c6	 mov	 r8d, esi
  00079	48 8b cd	 mov	 rcx, rbp
  0007c	8b de		 mov	 ebx, esi
  0007e	e8 00 00 00 00	 call	 memcpy

; 1013 :     strm->next_in  += len;

  00083	48 01 1f	 add	 QWORD PTR [rdi], rbx

; 1014 :     strm->total_in += len;

  00086	01 77 0c	 add	 DWORD PTR [rdi+12], esi
  00089	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1015 : 
; 1016 :     return (int)len;
; 1017 : }

  0008e	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00093	8b c6		 mov	 eax, esi
  00095	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
read_buf ENDP
_TEXT	ENDS
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$lm_init DD imagerel lm_init
	DD	imagerel lm_init+174
	DD	imagerel $unwind$lm_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lm_init DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT lm_init
_TEXT	SEGMENT
s$ = 48
lm_init	PROC						; COMDAT

; 1024 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1025 :     s->window_size = (ulg)2L*s->w_size;

  0000a	8b 41 44	 mov	 eax, DWORD PTR [rcx+68]

; 1026 : 
; 1027 :     CLEAR_HASH(s);

  0000d	8b 51 74	 mov	 edx, DWORD PTR [rcx+116]
  00010	48 8b d9	 mov	 rbx, rcx
  00013	03 c0		 add	 eax, eax
  00015	ff ca		 dec	 edx
  00017	33 ff		 xor	 edi, edi
  00019	89 41 58	 mov	 DWORD PTR [rcx+88], eax
  0001c	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
  00020	66 89 3c 50	 mov	 WORD PTR [rax+rdx*2], di
  00024	44 8b 41 74	 mov	 r8d, DWORD PTR [rcx+116]
  00028	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0002c	41 ff c8	 dec	 r8d
  0002f	33 d2		 xor	 edx, edx
  00031	4d 03 c0	 add	 r8, r8
  00034	e8 00 00 00 00	 call	 memset

; 1028 : 
; 1029 :     /* Set the default configuration parameters:
; 1030 :      */
; 1031 :     s->max_lazy_match   = configuration_table[s->level].max_lazy;

  00039	4c 63 9b ac 00
	00 00		 movsxd	 r11, DWORD PTR [rbx+172]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  00047	4d 03 db	 add	 r11, r11
  0004a	42 0f b7 44 d9
	02		 movzx	 eax, WORD PTR [rcx+r11*8+2]
  00050	89 83 a8 00 00
	00		 mov	 DWORD PTR [rbx+168], eax

; 1032 :     s->good_match       = configuration_table[s->level].good_length;

  00056	42 0f b7 04 d9	 movzx	 eax, WORD PTR [rcx+r11*8]
  0005b	89 83 b4 00 00
	00		 mov	 DWORD PTR [rbx+180], eax

; 1033 :     s->nice_match       = configuration_table[s->level].nice_length;

  00061	42 0f b7 44 d9
	04		 movzx	 eax, WORD PTR [rcx+r11*8+4]
  00067	89 83 b8 00 00
	00		 mov	 DWORD PTR [rbx+184], eax

; 1034 :     s->max_chain_length = configuration_table[s->level].max_chain;

  0006d	42 0f b7 44 d9
	06		 movzx	 eax, WORD PTR [rcx+r11*8+6]

; 1035 : 
; 1036 :     s->strstart = 0;
; 1037 :     s->block_start = 0L;

  00073	89 bb 84 00 00
	00		 mov	 DWORD PTR [rbx+132], edi

; 1038 :     s->lookahead = 0;

  00079	89 bb 9c 00 00
	00		 mov	 DWORD PTR [rbx+156], edi

; 1039 :     s->match_length = s->prev_length = MIN_MATCH-1;

  0007f	c7 83 a0 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+160], 2
  00089	c7 83 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+136], 2
  00093	89 83 a4 00 00
	00		 mov	 DWORD PTR [rbx+164], eax
  00099	48 89 bb 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rdi

; 1040 :     s->match_available = 0;
; 1041 :     s->ins_h = 0;

  000a0	89 7b 70	 mov	 DWORD PTR [rbx+112], edi

; 1042 : #ifndef FASTEST
; 1043 : #ifdef ASMV
; 1044 :     match_init(); /* initialize the asm code */
; 1045 : #endif
; 1046 : #endif
; 1047 : }

  000a3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ac	5f		 pop	 rdi
  000ad	c3		 ret	 0
lm_init	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$longest_match DD imagerel longest_match
	DD	imagerel longest_match+430
	DD	imagerel $unwind$longest_match
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$longest_match DD 0c1c01H
	DD	08741cH
	DD	07641cH
	DD	06541cH
	DD	05341cH
	DD	0e01af01cH
	DD	0c016d018H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT longest_match
_TEXT	SEGMENT
s$ = 40
cur_match$ = 48
longest_match PROC					; COMDAT

; 1066 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	41 57		 push	 r15

; 1067 :     unsigned chain_length = s->max_chain_length;/* max hash chain length */
; 1068 :     register Bytef *scan = s->window + s->strstart; /* current string */

  0001c	8b b9 94 00 00
	00		 mov	 edi, DWORD PTR [rcx+148]
  00022	8b b1 a4 00 00
	00		 mov	 esi, DWORD PTR [rcx+164]
  00028	48 8b d9	 mov	 rbx, rcx

; 1069 :     register Bytef *match;                       /* matched string */
; 1070 :     register int len;                           /* length of current match */
; 1071 :     int best_len = s->prev_length;              /* best match length so far */
; 1072 :     int nice_match = s->nice_match;             /* stop if match long enough */
; 1073 :     IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
; 1074 :         s->strstart - (IPos)MAX_DIST(s) : NIL;

  0002b	44 8b 4b 44	 mov	 r9d, DWORD PTR [rbx+68]
  0002f	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00033	4c 63 93 a0 00
	00 00		 movsxd	 r10, DWORD PTR [rbx+160]
  0003a	44 8b b3 b8 00
	00 00		 mov	 r14d, DWORD PTR [rbx+184]
  00041	41 8d 81 fa fe
	ff ff		 lea	 eax, DWORD PTR [r9-262]
  00048	44 8b da	 mov	 r11d, edx
  0004b	4c 8d 04 0f	 lea	 r8, QWORD PTR [rdi+rcx]
  0004f	3b f8		 cmp	 edi, eax
  00051	76 0b		 jbe	 SHORT $LN18@longest_ma
  00053	41 2b f9	 sub	 edi, r9d
  00056	81 c7 06 01 00
	00		 add	 edi, 262		; 00000106H
  0005c	eb 02		 jmp	 SHORT $LN19@longest_ma
$LN18@longest_ma:
  0005e	33 ff		 xor	 edi, edi
$LN19@longest_ma:

; 1075 :     /* Stop when cur_match becomes <= limit. To simplify the code,
; 1076 :      * we prevent matches with the string of window index 0.
; 1077 :      */
; 1078 :     Posf *prev = s->prev;

  00060	4c 8b 7b 60	 mov	 r15, QWORD PTR [rbx+96]

; 1079 :     uInt wmask = s->w_mask;
; 1080 : 
; 1081 : #ifdef UNALIGNED_OK
; 1082 :     /* Compare two bytes at a time. Note: this is not always beneficial.
; 1083 :      * Try with and without -DUNALIGNED_OK to check.
; 1084 :      */
; 1085 :     register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
; 1086 :     register ush scan_start = *(ushf*)scan;
; 1087 :     register ush scan_end   = *(ushf*)(scan+best_len-1);
; 1088 : #else
; 1089 :     register Bytef *strend = s->window + s->strstart + MAX_MATCH;
; 1090 :     register Byte scan_end1  = scan[best_len-1];

  00064	47 0f b6 64 02
	ff		 movzx	 r12d, BYTE PTR [r10+r8-1]

; 1091 :     register Byte scan_end   = scan[best_len];

  0006a	47 0f b6 2c 02	 movzx	 r13d, BYTE PTR [r10+r8]
  0006f	49 8d 90 02 01
	00 00		 lea	 rdx, QWORD PTR [r8+258]

; 1092 : #endif
; 1093 : 
; 1094 :     /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
; 1095 :      * It is easy to get rid of this optimization if necessary.
; 1096 :      */
; 1097 :     Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
; 1098 : 
; 1099 :     /* Do not waste too much time if we already have a good match: */
; 1100 :     if (s->prev_length >= s->good_match) {

  00076	44 3b 93 b4 00
	00 00		 cmp	 r10d, DWORD PTR [rbx+180]
  0007d	72 03		 jb	 SHORT $LN15@longest_ma

; 1101 :         chain_length >>= 2;

  0007f	c1 ee 02	 shr	 esi, 2
$LN15@longest_ma:

; 1102 :     }
; 1103 :     /* Do not look for matches beyond the end of the input. This is necessary
; 1104 :      * to make deflate deterministic.
; 1105 :      */
; 1106 :     if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;

  00082	44 8b 8b 9c 00
	00 00		 mov	 r9d, DWORD PTR [rbx+156]
  00089	45 3b f1	 cmp	 r14d, r9d
  0008c	45 0f 47 f1	 cmova	 r14d, r9d
$LL13@longest_ma:

; 1107 : 
; 1108 :     Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
; 1109 : 
; 1110 :     do {
; 1111 :         Assert(cur_match < s->strstart, "no future");
; 1112 :         match = s->window + cur_match;

  00090	41 8b eb	 mov	 ebp, r11d

; 1113 : 
; 1114 :         /* Skip to next match if the match length cannot increase
; 1115 :          * or if the match length is less than 2.  Note that the checks below
; 1116 :          * for insufficient lookahead only occur occasionally for performance
; 1117 :          * reasons.  Therefore uninitialized memory will be accessed, and
; 1118 :          * conditional jumps will be made that depend on those values.
; 1119 :          * However the length of the match is limited to the lookahead, so
; 1120 :          * the output of deflate is not affected by the uninitialized values.
; 1121 :          */
; 1122 : #if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
; 1123 :         /* This code assumes sizeof(unsigned short) == 2. Do not use
; 1124 :          * UNALIGNED_OK if your compiler uses a different size.
; 1125 :          */
; 1126 :         if (*(ushf*)(match+best_len-1) != scan_end ||
; 1127 :             *(ushf*)match != scan_start) continue;
; 1128 : 
; 1129 :         /* It is not necessary to compare scan[2] and match[2] since they are
; 1130 :          * always equal when the other bytes match, given that the hash keys
; 1131 :          * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
; 1132 :          * strstart+3, +5, ... up to strstart+257. We check for insufficient
; 1133 :          * lookahead only every 4th comparison; the 128th check will be made
; 1134 :          * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
; 1135 :          * necessary to put more guard bytes at the end of the window, or
; 1136 :          * to check more often for insufficient lookahead.
; 1137 :          */
; 1138 :         Assert(scan[2] == match[2], "scan[2]?");
; 1139 :         scan++, match++;
; 1140 :         do {
; 1141 :         } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1142 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1143 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1144 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1145 :                  scan < strend);
; 1146 :         /* The funny "do {}" generates better code on most compilers */
; 1147 : 
; 1148 :         /* Here, scan <= window+strstart+257 */
; 1149 :         Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
; 1150 :         if (*scan == *match) scan++;
; 1151 : 
; 1152 :         len = (MAX_MATCH - 1) - (int)(strend-scan);
; 1153 :         scan = strend - (MAX_MATCH-1);
; 1154 : 
; 1155 : #else /* UNALIGNED_OK */
; 1156 : 
; 1157 :         if (match[best_len]   != scan_end  ||
; 1158 :             match[best_len-1] != scan_end1 ||
; 1159 :             *match            != *scan     ||
; 1160 :             *++match          != scan[1])      continue;

  00093	49 63 c2	 movsxd	 rax, r10d
  00096	48 03 cd	 add	 rcx, rbp
  00099	44 38 2c 08	 cmp	 BYTE PTR [rax+rcx], r13b
  0009d	0f 85 c8 00 00
	00		 jne	 $LN12@longest_ma
  000a3	44 38 64 08 ff	 cmp	 BYTE PTR [rax+rcx-1], r12b
  000a8	0f 85 bd 00 00
	00		 jne	 $LN12@longest_ma
  000ae	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  000b2	38 01		 cmp	 BYTE PTR [rcx], al
  000b4	0f 85 b1 00 00
	00		 jne	 $LN12@longest_ma
  000ba	41 0f b6 40 01	 movzx	 eax, BYTE PTR [r8+1]
  000bf	38 41 01	 cmp	 BYTE PTR [rcx+1], al
  000c2	0f 85 a3 00 00
	00		 jne	 $LN12@longest_ma

; 1161 : 
; 1162 :         /* The check at best_len-1 can be removed because it will be made
; 1163 :          * again later. (This heuristic is not always a win.)
; 1164 :          * It is not necessary to compare scan[2] and match[2] since they
; 1165 :          * are always equal when the other bytes match, given that
; 1166 :          * the hash keys are equal and that HASH_BITS >= 8.
; 1167 :          */
; 1168 :         scan += 2, match++;

  000c8	49 83 c0 02	 add	 r8, 2
  000cc	48 83 c1 02	 add	 rcx, 2
$LL8@longest_ma:

; 1169 :         Assert(*scan == *match, "match[2]?");
; 1170 : 
; 1171 :         /* We check for insufficient lookahead only every 8th comparison;
; 1172 :          * the 256th check will be made at strstart+258.
; 1173 :          */
; 1174 :         do {
; 1175 :         } while (*++scan == *++match && *++scan == *++match &&
; 1176 :                  *++scan == *++match && *++scan == *++match &&
; 1177 :                  *++scan == *++match && *++scan == *++match &&
; 1178 :                  *++scan == *++match && *++scan == *++match &&
; 1179 :                  scan < strend);

  000d0	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000d4	49 ff c0	 inc	 r8
  000d7	41 38 00	 cmp	 BYTE PTR [r8], al
  000da	75 5d		 jne	 SHORT $LN5@longest_ma
  000dc	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  000e0	49 ff c0	 inc	 r8
  000e3	41 38 00	 cmp	 BYTE PTR [r8], al
  000e6	75 51		 jne	 SHORT $LN5@longest_ma
  000e8	0f b6 41 03	 movzx	 eax, BYTE PTR [rcx+3]
  000ec	49 ff c0	 inc	 r8
  000ef	41 38 00	 cmp	 BYTE PTR [r8], al
  000f2	75 45		 jne	 SHORT $LN5@longest_ma
  000f4	0f b6 41 04	 movzx	 eax, BYTE PTR [rcx+4]
  000f8	49 ff c0	 inc	 r8
  000fb	41 38 00	 cmp	 BYTE PTR [r8], al
  000fe	75 39		 jne	 SHORT $LN5@longest_ma
  00100	0f b6 41 05	 movzx	 eax, BYTE PTR [rcx+5]
  00104	49 ff c0	 inc	 r8
  00107	41 38 00	 cmp	 BYTE PTR [r8], al
  0010a	75 2d		 jne	 SHORT $LN5@longest_ma
  0010c	0f b6 41 06	 movzx	 eax, BYTE PTR [rcx+6]
  00110	49 ff c0	 inc	 r8
  00113	41 38 00	 cmp	 BYTE PTR [r8], al
  00116	75 21		 jne	 SHORT $LN5@longest_ma
  00118	0f b6 41 07	 movzx	 eax, BYTE PTR [rcx+7]
  0011c	49 ff c0	 inc	 r8
  0011f	41 38 00	 cmp	 BYTE PTR [r8], al
  00122	75 15		 jne	 SHORT $LN5@longest_ma
  00124	0f b6 41 08	 movzx	 eax, BYTE PTR [rcx+8]
  00128	48 83 c1 08	 add	 rcx, 8
  0012c	49 ff c0	 inc	 r8
  0012f	41 38 00	 cmp	 BYTE PTR [r8], al
  00132	75 05		 jne	 SHORT $LN5@longest_ma
  00134	4c 3b c2	 cmp	 r8, rdx
  00137	72 97		 jb	 SHORT $LL8@longest_ma
$LN5@longest_ma:

; 1180 : 
; 1181 :         Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
; 1182 : 
; 1183 :         len = MAX_MATCH - (int)(strend - scan);

  00139	44 2b c2	 sub	 r8d, edx
  0013c	41 8d 80 02 01
	00 00		 lea	 eax, DWORD PTR [r8+258]

; 1184 :         scan = strend - MAX_MATCH;

  00143	4c 8d 82 fe fe
	ff ff		 lea	 r8, QWORD PTR [rdx-258]
  0014a	48 98		 cdqe

; 1185 : 
; 1186 : #endif /* UNALIGNED_OK */
; 1187 : 
; 1188 :         if (len > best_len) {

  0014c	41 3b c2	 cmp	 eax, r10d
  0014f	7e 1a		 jle	 SHORT $LN12@longest_ma

; 1189 :             s->match_start = cur_match;

  00151	44 89 9b 98 00
	00 00		 mov	 DWORD PTR [rbx+152], r11d

; 1190 :             best_len = len;

  00158	44 8b d0	 mov	 r10d, eax

; 1191 :             if (len >= nice_match) break;

  0015b	41 3b c6	 cmp	 eax, r14d
  0015e	7d 27		 jge	 SHORT $LN11@longest_ma

; 1192 : #ifdef UNALIGNED_OK
; 1193 :             scan_end = *(ushf*)(scan+best_len-1);
; 1194 : #else
; 1195 :             scan_end1  = scan[best_len-1];

  00160	46 0f b6 64 00
	ff		 movzx	 r12d, BYTE PTR [rax+r8-1]

; 1196 :             scan_end   = scan[best_len];

  00166	46 0f b6 2c 00	 movzx	 r13d, BYTE PTR [rax+r8]
$LN12@longest_ma:

; 1197 : #endif
; 1198 :         }
; 1199 :     } while ((cur_match = prev[cur_match & wmask]) > limit
; 1200 :              && --chain_length != 0);

  0016b	8b 4b 4c	 mov	 ecx, DWORD PTR [rbx+76]
  0016e	48 23 cd	 and	 rcx, rbp
  00171	45 0f b7 1c 4f	 movzx	 r11d, WORD PTR [r15+rcx*2]
  00176	44 3b df	 cmp	 r11d, edi
  00179	76 0c		 jbe	 SHORT $LN11@longest_ma
  0017b	ff ce		 dec	 esi
  0017d	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  00181	0f 85 09 ff ff
	ff		 jne	 $LL13@longest_ma
$LN11@longest_ma:

; 1201 : 
; 1202 :     if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
; 1203 :     return s->lookahead;
; 1204 : }

  00187	48 8b 5c 24 28	 mov	 rbx, QWORD PTR [rsp+40]
  0018c	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  00191	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00196	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  0019b	45 3b d1	 cmp	 r10d, r9d
  0019e	45 0f 46 ca	 cmovbe	 r9d, r10d
  001a2	41 8b c1	 mov	 eax, r9d
  001a5	41 5f		 pop	 r15
  001a7	41 5e		 pop	 r14
  001a9	41 5d		 pop	 r13
  001ab	41 5c		 pop	 r12
  001ad	c3		 ret	 0
longest_match ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_window DD imagerel fill_window
	DD	imagerel fill_window+436
	DD	imagerel $unwind$fill_window
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_window DD 081a01H
	DD	06541aH
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT fill_window
_TEXT	SEGMENT
s$ = 48
fill_window PROC					; COMDAT

; 1307 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1308 :     register unsigned n, m;
; 1309 :     register Posf *p;
; 1310 :     unsigned more;    /* Amount of free space at the end of the window. */
; 1311 :     uInt wsize = s->w_size;

  0000f	8b 59 44	 mov	 ebx, DWORD PTR [rcx+68]
  00012	48 8b f9	 mov	 rdi, rcx
  00015	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL23@fill_windo:

; 1312 : 
; 1313 :     do {
; 1314 :         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

  00020	8b 97 94 00 00
	00		 mov	 edx, DWORD PTR [rdi+148]
  00026	8b 77 58	 mov	 esi, DWORD PTR [rdi+88]

; 1315 : 
; 1316 :         /* Deal with !@#$% 64K limit: */
; 1317 :         if (sizeof(int) <= 2) {
; 1318 :             if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
; 1319 :                 more = wsize;
; 1320 : 
; 1321 :             } else if (more == (unsigned)(-1)) {
; 1322 :                 /* Very unlikely, but possible on 16 bit machine if
; 1323 :                  * strstart == 0 && lookahead == 1 (input done a byte at time)
; 1324 :                  */
; 1325 :                 more--;
; 1326 :             }
; 1327 :         }
; 1328 : 
; 1329 :         /* If the window is almost full and there is insufficient lookahead,
; 1330 :          * move the upper half to the lower one to make room in the upper half.
; 1331 :          */
; 1332 :         if (s->strstart >= wsize+MAX_DIST(s)) {

  00029	8b 47 44	 mov	 eax, DWORD PTR [rdi+68]
  0002c	2b b7 9c 00 00
	00		 sub	 esi, DWORD PTR [rdi+156]
  00032	8d 8c 03 fa fe
	ff ff		 lea	 ecx, DWORD PTR [rbx+rax-262]
  00039	2b f2		 sub	 esi, edx
  0003b	3b d1		 cmp	 edx, ecx
  0003d	72 70		 jb	 SHORT $LN16@fill_windo

; 1333 : 
; 1334 :             zmemcpy(s->window, s->window+wsize, (unsigned)wsize);

  0003f	48 8b 4f 50	 mov	 rcx, QWORD PTR [rdi+80]
  00043	4c 8b c3	 mov	 r8, rbx
  00046	48 8d 14 19	 lea	 rdx, QWORD PTR [rcx+rbx]
  0004a	e8 00 00 00 00	 call	 memcpy

; 1335 :             s->match_start -= wsize;
; 1336 :             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
; 1337 :             s->block_start -= (long) wsize;
; 1338 : 
; 1339 :             /* Slide the hash table (could be avoided with 32 bit values
; 1340 :                at the expense of memory usage). We slide even when level == 0
; 1341 :                to keep the hash table consistent if we switch back to level > 0
; 1342 :                later. (Using level 0 permanently is not an optimal usage of
; 1343 :                zlib, so we don't care about this pathological case.)
; 1344 :              */
; 1345 :             n = s->hash_size;

  0004f	44 8b 47 74	 mov	 r8d, DWORD PTR [rdi+116]

; 1346 :             p = &s->head[n];

  00053	48 8b 47 68	 mov	 rax, QWORD PTR [rdi+104]
  00057	29 9f 98 00 00
	00		 sub	 DWORD PTR [rdi+152], ebx
  0005d	29 9f 94 00 00
	00		 sub	 DWORD PTR [rdi+148], ebx
  00063	29 9f 84 00 00
	00		 sub	 DWORD PTR [rdi+132], ebx
  00069	4a 8d 14 40	 lea	 rdx, QWORD PTR [rax+r8*2]
  0006d	0f 1f 00	 npad	 3
$LL15@fill_windo:

; 1347 :             do {
; 1348 :                 m = *--p;

  00070	0f b7 42 fe	 movzx	 eax, WORD PTR [rdx-2]
  00074	48 83 ea 02	 sub	 rdx, 2

; 1349 :                 *p = (Pos)(m >= wsize ? m-wsize : NIL);

  00078	3b c3		 cmp	 eax, ebx
  0007a	72 04		 jb	 SHORT $LN26@fill_windo
  0007c	2b c3		 sub	 eax, ebx
  0007e	eb 02		 jmp	 SHORT $LN27@fill_windo
$LN26@fill_windo:
  00080	33 c0		 xor	 eax, eax
$LN27@fill_windo:

; 1350 :             } while (--n);

  00082	41 ff c8	 dec	 r8d
  00085	66 89 02	 mov	 WORD PTR [rdx], ax
  00088	75 e6		 jne	 SHORT $LL15@fill_windo

; 1351 : 
; 1352 :             n = wsize;
; 1353 : #ifndef FASTEST
; 1354 :             p = &s->prev[n];

  0008a	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  0008e	8b d3		 mov	 edx, ebx
  00090	48 8d 0c 58	 lea	 rcx, QWORD PTR [rax+rbx*2]
$LL12@fill_windo:

; 1355 :             do {
; 1356 :                 m = *--p;

  00094	0f b7 41 fe	 movzx	 eax, WORD PTR [rcx-2]
  00098	48 83 e9 02	 sub	 rcx, 2

; 1357 :                 *p = (Pos)(m >= wsize ? m-wsize : NIL);

  0009c	3b c3		 cmp	 eax, ebx
  0009e	72 04		 jb	 SHORT $LN28@fill_windo
  000a0	2b c3		 sub	 eax, ebx
  000a2	eb 02		 jmp	 SHORT $LN29@fill_windo
$LN28@fill_windo:
  000a4	33 c0		 xor	 eax, eax
$LN29@fill_windo:

; 1358 :                 /* If n is not on any hash chain, prev[n] is garbage but
; 1359 :                  * its value will never be used.
; 1360 :                  */
; 1361 :             } while (--n);

  000a6	ff ca		 dec	 edx
  000a8	66 89 01	 mov	 WORD PTR [rcx], ax
  000ab	75 e7		 jne	 SHORT $LL12@fill_windo

; 1362 : #endif
; 1363 :             more += wsize;

  000ad	03 f3		 add	 esi, ebx
$LN16@fill_windo:

; 1364 :         }
; 1365 :         if (s->strm->avail_in == 0) return;

  000af	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  000b2	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  000b6	0f 84 e3 00 00
	00		 je	 $LN2@fill_windo

; 1366 : 
; 1367 :         /* If there was no sliding:
; 1368 :          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
; 1369 :          *    more == window_size - lookahead - strstart
; 1370 :          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
; 1371 :          * => more >= window_size - 2*WSIZE + 2
; 1372 :          * In the BIG_MEM or MMAP case (not yet supported),
; 1373 :          *   window_size == input_size + MIN_LOOKAHEAD  &&
; 1374 :          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
; 1375 :          * Otherwise, window_size == 2*WSIZE so more >= 2.
; 1376 :          * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
; 1377 :          */
; 1378 :         Assert(more >= 2, "more < 2");
; 1379 : 
; 1380 :         n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);

  000bc	8b 97 9c 00 00
	00		 mov	 edx, DWORD PTR [rdi+156]
  000c2	8b 87 94 00 00
	00		 mov	 eax, DWORD PTR [rdi+148]
  000c8	44 8b c6	 mov	 r8d, esi
  000cb	48 03 d0	 add	 rdx, rax
  000ce	48 03 57 50	 add	 rdx, QWORD PTR [rdi+80]
  000d2	e8 00 00 00 00	 call	 read_buf

; 1381 :         s->lookahead += n;

  000d7	01 87 9c 00 00
	00		 add	 DWORD PTR [rdi+156], eax
  000dd	44 8b 8f 9c 00
	00 00		 mov	 r9d, DWORD PTR [rdi+156]

; 1382 : 
; 1383 :         /* Initialize the hash value now that we have some input: */
; 1384 :         if (s->lookahead >= MIN_MATCH) {

  000e4	41 83 f9 03	 cmp	 r9d, 3
  000e8	72 2d		 jb	 SHORT $LN22@fill_windo

; 1385 :             s->ins_h = s->window[s->strstart];

  000ea	8b 87 94 00 00
	00		 mov	 eax, DWORD PTR [rdi+148]
  000f0	48 8b 57 50	 mov	 rdx, QWORD PTR [rdi+80]

; 1386 :             UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  000f4	8b 8f 80 00 00
	00		 mov	 ecx, DWORD PTR [rdi+128]
  000fa	44 0f b6 04 10	 movzx	 r8d, BYTE PTR [rax+rdx]
  000ff	44 89 47 70	 mov	 DWORD PTR [rdi+112], r8d
  00103	41 d3 e0	 shl	 r8d, cl
  00106	ff c0		 inc	 eax
  00108	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  0010c	44 33 c0	 xor	 r8d, eax
  0010f	44 23 47 7c	 and	 r8d, DWORD PTR [rdi+124]
  00113	44 89 47 70	 mov	 DWORD PTR [rdi+112], r8d
$LN22@fill_windo:

; 1387 : #if MIN_MATCH != 3
; 1388 :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 1389 : #endif
; 1390 :         }
; 1391 :         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
; 1392 :          * but this is not important since only literal bytes will be emitted.
; 1393 :          */
; 1394 : 
; 1395 :     } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);

  00117	41 81 f9 06 01
	00 00		 cmp	 r9d, 262		; 00000106H
  0011e	73 0d		 jae	 SHORT $LN7@fill_windo
  00120	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00123	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00127	0f 85 f3 fe ff
	ff		 jne	 $LL23@fill_windo
$LN7@fill_windo:

; 1396 : 
; 1397 :     /* If the WIN_INIT bytes after the end of the current data have never been
; 1398 :      * written, then zero those bytes in order to avoid memory check reports of
; 1399 :      * the use of uninitialized (or uninitialised as Julian writes) bytes by
; 1400 :      * the longest match routines.  Update the high water mark for the next
; 1401 :      * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
; 1402 :      * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
; 1403 :      */
; 1404 :     if (s->high_water < s->window_size) {

  0012d	8b 8f 18 17 00
	00		 mov	 ecx, DWORD PTR [rdi+5912]
  00133	8b 77 58	 mov	 esi, DWORD PTR [rdi+88]
  00136	3b ce		 cmp	 ecx, esi
  00138	73 65		 jae	 SHORT $LN2@fill_windo

; 1405 :         ulg curr = s->strstart + (ulg)(s->lookahead);

  0013a	8b 87 94 00 00
	00		 mov	 eax, DWORD PTR [rdi+148]
  00140	41 8d 1c 01	 lea	 ebx, DWORD PTR [r9+rax]

; 1406 :         ulg init;
; 1407 : 
; 1408 :         if (s->high_water < curr) {

  00144	3b cb		 cmp	 ecx, ebx
  00146	73 29		 jae	 SHORT $LN5@fill_windo

; 1409 :             /* Previous high water mark below current data -- zero WIN_INIT
; 1410 :              * bytes or up to end of window, whichever is less.
; 1411 :              */
; 1412 :             init = s->window_size - curr;

  00148	2b f3		 sub	 esi, ebx

; 1413 :             if (init > WIN_INIT)

  0014a	b8 02 01 00 00	 mov	 eax, 258		; 00000102H

; 1414 :                 init = WIN_INIT;
; 1415 :             zmemzero(s->window + curr, (unsigned)init);

  0014f	8b cb		 mov	 ecx, ebx
  00151	3b f0		 cmp	 esi, eax
  00153	0f 47 f0	 cmova	 esi, eax
  00156	48 03 4f 50	 add	 rcx, QWORD PTR [rdi+80]
  0015a	33 d2		 xor	 edx, edx
  0015c	44 8b c6	 mov	 r8d, esi
  0015f	e8 00 00 00 00	 call	 memset

; 1416 :             s->high_water = curr + init;

  00164	44 8d 1c 1e	 lea	 r11d, DWORD PTR [rsi+rbx]
  00168	44 89 9f 18 17
	00 00		 mov	 DWORD PTR [rdi+5912], r11d
  0016f	eb 2e		 jmp	 SHORT $LN2@fill_windo
$LN5@fill_windo:

; 1417 :         }
; 1418 :         else if (s->high_water < (ulg)curr + WIN_INIT) {

  00171	8d 83 02 01 00
	00		 lea	 eax, DWORD PTR [rbx+258]
  00177	3b c8		 cmp	 ecx, eax
  00179	73 24		 jae	 SHORT $LN2@fill_windo

; 1419 :             /* High water mark at or above current data, but below current data
; 1420 :              * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
; 1421 :              * to end of window, whichever is less.
; 1422 :              */
; 1423 :             init = (ulg)curr + WIN_INIT - s->high_water;

  0017b	2b d9		 sub	 ebx, ecx

; 1424 :             if (init > s->window_size - s->high_water)

  0017d	2b f1		 sub	 esi, ecx
  0017f	b8 02 01 00 00	 mov	 eax, 258		; 00000102H
  00184	03 d8		 add	 ebx, eax
  00186	3b de		 cmp	 ebx, esi
  00188	0f 47 de	 cmova	 ebx, esi

; 1425 :                 init = s->window_size - s->high_water;
; 1426 :             zmemzero(s->window + s->high_water, (unsigned)init);

  0018b	48 03 4f 50	 add	 rcx, QWORD PTR [rdi+80]
  0018f	33 d2		 xor	 edx, edx
  00191	44 8b c3	 mov	 r8d, ebx
  00194	e8 00 00 00 00	 call	 memset

; 1427 :             s->high_water += init;

  00199	01 9f 18 17 00
	00		 add	 DWORD PTR [rdi+5912], ebx
$LN2@fill_windo:

; 1428 :         }
; 1429 :     }
; 1430 : }

  0019f	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  001a4	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  001a9	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  001ae	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001b2	5f		 pop	 rdi
  001b3	c3		 ret	 0
fill_window ENDP
_TEXT	ENDS
EXTRN	_tr_flush_block:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_stored DD imagerel deflate_stored
	DD	imagerel deflate_stored+430
	DD	imagerel $unwind$deflate_stored
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_stored DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT deflate_stored
_TEXT	SEGMENT
s$ = 48
flush$ = 56
deflate_stored PROC					; COMDAT

; 1465 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1466 :     /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
; 1467 :      * to pending_buf_size, and each stored block has a 5 byte header:
; 1468 :      */
; 1469 :     ulg max_block_size = 0xffff;
; 1470 :     ulg max_start;
; 1471 : 
; 1472 :     if (max_block_size > s->pending_buf_size - 5) {

  00014	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  00017	be ff ff 00 00	 mov	 esi, 65535		; 0000ffffH
  0001c	8b ea		 mov	 ebp, edx
  0001e	83 c0 fb	 add	 eax, -5			; fffffffbH
  00021	48 8b d9	 mov	 rbx, rcx
  00024	3b c6		 cmp	 eax, esi
  00026	0f 42 f0	 cmovb	 esi, eax
  00029	33 ff		 xor	 edi, edi
  0002b	0f 1f 44 00 00	 npad	 5
$LL11@deflate_st:

; 1473 :         max_block_size = s->pending_buf_size - 5;
; 1474 :     }
; 1475 : 
; 1476 :     /* Copy as much as possible from input to output: */
; 1477 :     for (;;) {
; 1478 :         /* Fill the window as much as possible: */
; 1479 :         if (s->lookahead <= 1) {

  00030	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  00036	83 f8 01	 cmp	 eax, 1
  00039	77 16		 ja	 SHORT $LN7@deflate_st

; 1480 : 
; 1481 :             Assert(s->strstart < s->w_size+MAX_DIST(s) ||
; 1482 :                    s->block_start >= (long)s->w_size, "slide too late");
; 1483 : 
; 1484 :             fill_window(s);

  0003b	48 8b cb	 mov	 rcx, rbx
  0003e	e8 00 00 00 00	 call	 fill_window

; 1485 :             if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

  00043	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  00049	85 c0		 test	 eax, eax
  0004b	0f 84 e5 00 00
	00		 je	 $LN27@deflate_st
$LN7@deflate_st:

; 1486 : 
; 1487 :             if (s->lookahead == 0) break; /* flush the current block */
; 1488 :         }
; 1489 :         Assert(s->block_start >= 0L, "block gone");
; 1490 : 
; 1491 :         s->strstart += s->lookahead;
; 1492 :         s->lookahead = 0;
; 1493 : 
; 1494 :         /* Emit a stored block if pending_buf will be full: */
; 1495 :         max_start = s->block_start + max_block_size;

  00051	8b 8b 84 00 00
	00		 mov	 ecx, DWORD PTR [rbx+132]
  00057	01 83 94 00 00
	00		 add	 DWORD PTR [rbx+148], eax

; 1496 :         if (s->strstart == 0 || (ulg)s->strstart >= max_start) {

  0005d	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00063	44 8d 04 31	 lea	 r8d, DWORD PTR [rcx+rsi]
  00067	89 bb 9c 00 00
	00		 mov	 DWORD PTR [rbx+156], edi
  0006d	74 05		 je	 SHORT $LN5@deflate_st
  0006f	41 3b c0	 cmp	 eax, r8d
  00072	72 4d		 jb	 SHORT $LN4@deflate_st
$LN5@deflate_st:

; 1497 :             /* strstart == 0 is possible when wraparound on 16-bit machine */
; 1498 :             s->lookahead = (uInt)(s->strstart - max_start);

  00074	41 2b c0	 sub	 eax, r8d

; 1499 :             s->strstart = (uInt)max_start;

  00077	44 89 83 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r8d
  0007e	89 83 9c 00 00
	00		 mov	 DWORD PTR [rbx+156], eax

; 1500 :             FLUSH_BLOCK(s, 0);

  00084	85 c9		 test	 ecx, ecx
  00086	78 09		 js	 SHORT $LN15@deflate_st
  00088	48 8b d1	 mov	 rdx, rcx
  0008b	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  0008f	eb 03		 jmp	 SHORT $LN16@deflate_st
$LN15@deflate_st:
  00091	48 8b d7	 mov	 rdx, rdi
$LN16@deflate_st:
  00094	44 2b c1	 sub	 r8d, ecx
  00097	45 33 c9	 xor	 r9d, r9d
  0009a	48 8b cb	 mov	 rcx, rbx
  0009d	e8 00 00 00 00	 call	 _tr_flush_block
  000a2	44 8b 9b 94 00
	00 00		 mov	 r11d, DWORD PTR [rbx+148]
  000a9	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000ac	44 89 9b 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r11d
  000b3	e8 00 00 00 00	 call	 flush_pending
  000b8	4c 8b 1b	 mov	 r11, QWORD PTR [rbx]
  000bb	41 39 7b 18	 cmp	 DWORD PTR [r11+24], edi
  000bf	74 5e		 je	 SHORT $LN25@deflate_st
$LN4@deflate_st:

; 1501 :         }
; 1502 :         /* Flush if we may have to slide, otherwise block_start may become
; 1503 :          * negative and the data will be gone:
; 1504 :          */
; 1505 :         if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {

  000c1	8b 8b 84 00 00
	00		 mov	 ecx, DWORD PTR [rbx+132]
  000c7	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  000ce	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  000d1	44 2b c1	 sub	 r8d, ecx
  000d4	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  000d9	44 3b c0	 cmp	 r8d, eax
  000dc	0f 82 4e ff ff
	ff		 jb	 $LL11@deflate_st

; 1506 :             FLUSH_BLOCK(s, 0);

  000e2	85 c9		 test	 ecx, ecx
  000e4	78 08		 js	 SHORT $LN17@deflate_st
  000e6	8b d1		 mov	 edx, ecx
  000e8	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  000ec	eb 03		 jmp	 SHORT $LN18@deflate_st
$LN17@deflate_st:
  000ee	48 8b d7	 mov	 rdx, rdi
$LN18@deflate_st:
  000f1	45 33 c9	 xor	 r9d, r9d
  000f4	48 8b cb	 mov	 rcx, rbx
  000f7	e8 00 00 00 00	 call	 _tr_flush_block
  000fc	44 8b 9b 94 00
	00 00		 mov	 r11d, DWORD PTR [rbx+148]
  00103	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00106	44 89 9b 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r11d
  0010d	e8 00 00 00 00	 call	 flush_pending
  00112	4c 8b 1b	 mov	 r11, QWORD PTR [rbx]
  00115	41 39 7b 18	 cmp	 DWORD PTR [r11+24], edi
  00119	0f 85 11 ff ff
	ff		 jne	 $LL11@deflate_st
$LN25@deflate_st:

; 1500 :             FLUSH_BLOCK(s, 0);

  0011f	33 c0		 xor	 eax, eax
$LN13@deflate_st:

; 1511 : }

  00121	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00126	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0012b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00130	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00134	5f		 pop	 rdi
  00135	c3		 ret	 0
$LN27@deflate_st:

; 1485 :             if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

  00136	85 ed		 test	 ebp, ebp
  00138	74 e5		 je	 SHORT $LN25@deflate_st

; 1507 :         }
; 1508 :     }
; 1509 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  0013a	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  00140	85 c0		 test	 eax, eax
  00142	78 08		 js	 SHORT $LN19@deflate_st
  00144	8b d0		 mov	 edx, eax
  00146	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  0014a	eb 03		 jmp	 SHORT $LN20@deflate_st
$LN19@deflate_st:
  0014c	48 8b d7	 mov	 rdx, rdi
$LN20@deflate_st:
  0014f	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  00156	44 8b cf	 mov	 r9d, edi
  00159	83 fd 04	 cmp	 ebp, 4
  0015c	41 0f 94 c1	 sete	 r9b
  00160	44 2b c0	 sub	 r8d, eax
  00163	48 8b cb	 mov	 rcx, rbx
  00166	e8 00 00 00 00	 call	 _tr_flush_block
  0016b	44 8b 9b 94 00
	00 00		 mov	 r11d, DWORD PTR [rbx+148]
  00172	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00175	44 89 9b 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r11d
  0017c	e8 00 00 00 00	 call	 flush_pending
  00181	4c 8b 1b	 mov	 r11, QWORD PTR [rbx]
  00184	41 39 7b 18	 cmp	 DWORD PTR [r11+24], edi
  00188	75 0f		 jne	 SHORT $LN1@deflate_st
  0018a	b8 02 00 00 00	 mov	 eax, 2
  0018f	83 fd 04	 cmp	 ebp, 4
  00192	0f 44 f8	 cmove	 edi, eax
  00195	8b c7		 mov	 eax, edi
  00197	eb 88		 jmp	 SHORT $LN13@deflate_st
$LN1@deflate_st:

; 1510 :     return flush == Z_FINISH ? finish_done : block_done;

  00199	b8 01 00 00 00	 mov	 eax, 1
  0019e	b9 03 00 00 00	 mov	 ecx, 3
  001a3	83 fd 04	 cmp	 ebp, 4
  001a6	0f 44 c1	 cmove	 eax, ecx
  001a9	e9 73 ff ff ff	 jmp	 $LN13@deflate_st
deflate_stored ENDP
_TEXT	ENDS
EXTRN	_dist_code:BYTE
EXTRN	_length_code:BYTE
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_fast DD imagerel deflate_fast
	DD	imagerel deflate_fast+949
	DD	imagerel $unwind$deflate_fast
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_fast DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0d0143218H
	DD	07010c012H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT deflate_fast
_TEXT	SEGMENT
s$ = 64
flush$ = 72
deflate_fast PROC					; COMDAT

; 1523 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00018	8b f2		 mov	 esi, edx
  0001a	48 8b d9	 mov	 rbx, rcx
  0001d	41 bc ff ff 00
	00		 mov	 r12d, 65535		; 0000ffffH
  00023	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:__ImageBase
  0002a	33 ff		 xor	 edi, edi
  0002c	41 bd 00 01 00
	00		 mov	 r13d, 256		; 00000100H
$LL17@deflate_fa:

; 1524 :     IPos hash_head;       /* head of the hash chain */
; 1525 :     int bflush;           /* set if current block must be flushed */
; 1526 : 
; 1527 :     for (;;) {
; 1528 :         /* Make sure that we always have enough lookahead, except
; 1529 :          * at the end of the input file. We need MAX_MATCH bytes
; 1530 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1531 :          * string following the next match.
; 1532 :          */
; 1533 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00032	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  00038	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0003d	73 25		 jae	 SHORT $LN13@deflate_fa

; 1534 :             fill_window(s);

  0003f	48 8b cb	 mov	 rcx, rbx
  00042	e8 00 00 00 00	 call	 fill_window

; 1535 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00047	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  0004d	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00052	73 08		 jae	 SHORT $LN14@deflate_fa
  00054	85 f6		 test	 esi, esi
  00056	0f 84 ca 02 00
	00		 je	 $LN31@deflate_fa
$LN14@deflate_fa:

; 1536 :                 return need_more;
; 1537 :             }
; 1538 :             if (s->lookahead == 0) break; /* flush the current block */

  0005c	85 c0		 test	 eax, eax
  0005e	0f 84 dd 02 00
	00		 je	 $LN30@deflate_fa
$LN13@deflate_fa:

; 1539 :         }
; 1540 : 
; 1541 :         /* Insert the string window[strstart .. strstart+2] in the
; 1542 :          * dictionary, and set hash_head to the head of the hash chain:
; 1543 :          */
; 1544 :         hash_head = NIL;
; 1545 :         if (s->lookahead >= MIN_MATCH) {

  00064	83 f8 03	 cmp	 eax, 3
  00067	0f 82 90 00 00
	00		 jb	 $LN11@deflate_fa

; 1546 :             INSERT_STRING(s, s->strstart, hash_head);

  0006d	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00071	44 8b 8b 94 00
	00 00		 mov	 r9d, DWORD PTR [rbx+148]
  00078	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0007c	41 8d 49 02	 lea	 ecx, DWORD PTR [r9+2]
  00080	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  00085	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00088	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  0008e	d3 e0		 shl	 eax, cl
  00090	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00094	44 33 c0	 xor	 r8d, eax
  00097	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  0009a	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  0009e	4c 23 c8	 and	 r9, rax
  000a1	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  000a5	42 0f b7 04 42	 movzx	 eax, WORD PTR [rdx+r8*2]
  000aa	66 42 89 04 49	 mov	 WORD PTR [rcx+r9*2], ax
  000af	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  000b2	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  000b8	44 8b 43 70	 mov	 r8d, DWORD PTR [rbx+112]
  000bc	48 23 c8	 and	 rcx, rax
  000bf	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  000c3	0f b7 14 48	 movzx	 edx, WORD PTR [rax+rcx*2]
  000c7	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  000cb	0f b7 83 94 00
	00 00		 movzx	 eax, WORD PTR [rbx+148]
  000d2	66 42 89 04 41	 mov	 WORD PTR [rcx+r8*2], ax

; 1547 :         }
; 1548 : 
; 1549 :         /* Find the longest match, discarding those <= prev_length.
; 1550 :          * At this point we have always match_length < MIN_MATCH
; 1551 :          */
; 1552 :         if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {

  000d7	85 d2		 test	 edx, edx
  000d9	74 22		 je	 SHORT $LN11@deflate_fa
  000db	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  000e1	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  000e4	2b ca		 sub	 ecx, edx
  000e6	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  000eb	3b c8		 cmp	 ecx, eax
  000ed	77 0e		 ja	 SHORT $LN11@deflate_fa

; 1553 :             /* To simplify the code, we prevent matches with the string
; 1554 :              * of window index 0 (in particular we have to avoid a match
; 1555 :              * of the string with itself at the start of the input file).
; 1556 :              */
; 1557 :             s->match_length = longest_match (s, hash_head);

  000ef	48 8b cb	 mov	 rcx, rbx
  000f2	e8 00 00 00 00	 call	 longest_match
  000f7	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax
$LN11@deflate_fa:

; 1558 :             /* longest_match() sets match_start */
; 1559 :         }
; 1560 :         if (s->match_length >= MIN_MATCH) {

  000fd	83 bb 88 00 00
	00 03		 cmp	 DWORD PTR [rbx+136], 3
  00104	0f 82 68 01 00
	00		 jb	 $LN10@deflate_fa

; 1561 :             check_match(s, s->strstart, s->match_start, s->match_length);
; 1562 : 
; 1563 :             _tr_tally_dist(s, s->strstart - s->match_start,
; 1564 :                            s->match_length - MIN_MATCH, bflush);

  0010a	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00110	44 0f b7 83 94
	00 00 00	 movzx	 r8d, WORD PTR [rbx+148]
  00118	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  0011f	66 44 2b 83 98
	00 00 00	 sub	 r8w, WORD PTR [rbx+152]
  00127	0f b6 93 88 00
	00 00		 movzx	 edx, BYTE PTR [rbx+136]
  0012e	66 44 89 04 48	 mov	 WORD PTR [rax+rcx*2], r8w
  00133	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00139	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00140	80 ea 03	 sub	 dl, 3
  00143	66 45 03 c4	 add	 r8w, r12w
  00147	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0014a	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00150	0f b6 c2	 movzx	 eax, dl
  00153	0f b6 84 28 00
	00 00 00	 movzx	 eax, BYTE PTR _length_code[rax+rbp]
  0015b	66 ff 84 83 c0
	04 00 00	 inc	 WORD PTR [rbx+rax*4+1216]
  00163	41 0f b7 c0	 movzx	 eax, r8w
  00167	66 45 3b c5	 cmp	 r8w, r13w
  0016b	73 0a		 jae	 SHORT $LN20@deflate_fa
  0016d	0f b6 8c 28 00
	00 00 00	 movzx	 ecx, BYTE PTR _dist_code[rax+rbp]
  00175	eb 0c		 jmp	 SHORT $LN21@deflate_fa
$LN20@deflate_fa:
  00177	48 c1 e8 07	 shr	 rax, 7
  0017b	0f b6 8c 28 00
	01 00 00	 movzx	 ecx, BYTE PTR _dist_code[rax+rbp+256]
$LN21@deflate_fa:
  00183	48 63 c1	 movsxd	 rax, ecx
  00186	44 8b d7	 mov	 r10d, edi
  00189	66 ff 84 83 b0
	09 00 00	 inc	 WORD PTR [rbx+rax*4+2480]
  00191	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  00197	ff c8		 dec	 eax
  00199	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 1565 : 
; 1566 :             s->lookahead -= s->match_length;

  0019f	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [rbx+136]
  001a5	41 0f 94 c2	 sete	 r10b
  001a9	29 83 9c 00 00
	00		 sub	 DWORD PTR [rbx+156], eax

; 1567 : 
; 1568 :             /* Insert new strings in the hash table only if the match length
; 1569 :              * is not too large. This saves time but degrades compression.
; 1570 :              */
; 1571 : #ifndef FASTEST
; 1572 :             if (s->match_length <= s->max_insert_length &&
; 1573 :                 s->lookahead >= MIN_MATCH) {

  001af	3b 83 a8 00 00
	00		 cmp	 eax, DWORD PTR [rbx+168]
  001b5	0f 87 7c 00 00
	00		 ja	 $LN9@deflate_fa
  001bb	83 bb 9c 00 00
	00 03		 cmp	 DWORD PTR [rbx+156], 3
  001c2	72 73		 jb	 SHORT $LN9@deflate_fa

; 1574 :                 s->match_length--; /* string at strstart already in table */

  001c4	ff c8		 dec	 eax
  001c6	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax
  001cc	0f 1f 40 00	 npad	 4
$LL8@deflate_fa:

; 1575 :                 do {
; 1576 :                     s->strstart++;

  001d0	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]

; 1577 :                     INSERT_STRING(s, s->strstart, hash_head);

  001d6	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  001da	44 8b 8b 94 00
	00 00		 mov	 r9d, DWORD PTR [rbx+148]
  001e1	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  001e5	41 8d 49 02	 lea	 ecx, DWORD PTR [r9+2]
  001e9	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  001ee	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  001f1	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  001f7	d3 e0		 shl	 eax, cl
  001f9	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  001fd	44 33 c0	 xor	 r8d, eax
  00200	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  00203	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  00207	4c 23 c8	 and	 r9, rax
  0020a	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  0020e	42 0f b7 04 42	 movzx	 eax, WORD PTR [rdx+r8*2]
  00213	66 42 89 04 49	 mov	 WORD PTR [rcx+r9*2], ax
  00218	8b 53 70	 mov	 edx, DWORD PTR [rbx+112]
  0021b	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  0021f	0f b7 83 94 00
	00 00		 movzx	 eax, WORD PTR [rbx+148]
  00226	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax

; 1578 :                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
; 1579 :                      * always MIN_MATCH bytes ahead.
; 1580 :                      */
; 1581 :                 } while (--s->match_length != 0);

  0022a	ff 8b 88 00 00
	00		 dec	 DWORD PTR [rbx+136]
  00230	75 9e		 jne	 SHORT $LL8@deflate_fa

; 1582 :                 s->strstart++;
; 1583 :             } else

  00232	e9 93 00 00 00	 jmp	 $LN32@deflate_fa
$LN9@deflate_fa:

; 1584 : #endif
; 1585 :             {
; 1586 :                 s->strstart += s->match_length;

  00237	01 83 94 00 00
	00		 add	 DWORD PTR [rbx+148], eax

; 1587 :                 s->match_length = 0;
; 1588 :                 s->ins_h = s->window[s->strstart];

  0023d	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00243	48 8b 53 50	 mov	 rdx, QWORD PTR [rbx+80]

; 1589 :                 UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  00247	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  0024d	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi
  00253	44 0f b6 04 10	 movzx	 r8d, BYTE PTR [rax+rdx]
  00258	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  0025c	41 d3 e0	 shl	 r8d, cl
  0025f	ff c0		 inc	 eax
  00261	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  00265	44 33 c0	 xor	 r8d, eax
  00268	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  0026c	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d

; 1590 : #if MIN_MATCH != 3
; 1591 :                 Call UPDATE_HASH() MIN_MATCH-3 more times
; 1592 : #endif
; 1593 :                 /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
; 1594 :                  * matter since it will be recomputed at next deflate call.
; 1595 :                  */
; 1596 :             }
; 1597 :         } else {

  00270	eb 5e		 jmp	 SHORT $LN4@deflate_fa
$LN10@deflate_fa:

; 1598 :             /* No match, output a literal byte */
; 1599 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1600 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  00272	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00278	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0027c	44 8b d7	 mov	 r10d, edi
  0027f	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00283	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00289	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  00290	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  00294	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0029a	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  002a1	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  002a4	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  002aa	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]
  002b2	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  002b8	ff c8		 dec	 eax
  002ba	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax
  002c0	41 0f 94 c2	 sete	 r10b

; 1601 :             s->lookahead--;

  002c4	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
$LN32@deflate_fa:

; 1602 :             s->strstart++;

  002ca	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
$LN4@deflate_fa:

; 1603 :         }
; 1604 :         if (bflush) FLUSH_BLOCK(s, 0);

  002d0	45 85 d2	 test	 r10d, r10d
  002d3	0f 84 59 fd ff
	ff		 je	 $LL17@deflate_fa
  002d9	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  002df	85 c0		 test	 eax, eax
  002e1	78 08		 js	 SHORT $LN22@deflate_fa
  002e3	8b d0		 mov	 edx, eax
  002e5	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  002e9	eb 03		 jmp	 SHORT $LN23@deflate_fa
$LN22@deflate_fa:
  002eb	48 8b d7	 mov	 rdx, rdi
$LN23@deflate_fa:
  002ee	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  002f5	45 33 c9	 xor	 r9d, r9d
  002f8	48 8b cb	 mov	 rcx, rbx
  002fb	44 2b c0	 sub	 r8d, eax
  002fe	e8 00 00 00 00	 call	 _tr_flush_block
  00303	44 8b 9b 94 00
	00 00		 mov	 r11d, DWORD PTR [rbx+148]
  0030a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0030d	44 89 9b 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r11d
  00314	e8 00 00 00 00	 call	 flush_pending
  00319	4c 8b 1b	 mov	 r11, QWORD PTR [rbx]
  0031c	41 39 7b 18	 cmp	 DWORD PTR [r11+24], edi
  00320	0f 85 0c fd ff
	ff		 jne	 $LL17@deflate_fa
$LN31@deflate_fa:
  00326	33 c0		 xor	 eax, eax
$LN18@deflate_fa:

; 1608 : }

  00328	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0032d	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00332	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00337	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0033b	41 5d		 pop	 r13
  0033d	41 5c		 pop	 r12
  0033f	5f		 pop	 rdi
  00340	c3		 ret	 0
$LN30@deflate_fa:

; 1605 :     }
; 1606 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  00341	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  00347	85 c0		 test	 eax, eax
  00349	78 08		 js	 SHORT $LN24@deflate_fa
  0034b	8b d0		 mov	 edx, eax
  0034d	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00351	eb 03		 jmp	 SHORT $LN25@deflate_fa
$LN24@deflate_fa:
  00353	48 8b d7	 mov	 rdx, rdi
$LN25@deflate_fa:
  00356	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  0035d	44 8b cf	 mov	 r9d, edi
  00360	83 fe 04	 cmp	 esi, 4
  00363	41 0f 94 c1	 sete	 r9b
  00367	44 2b c0	 sub	 r8d, eax
  0036a	48 8b cb	 mov	 rcx, rbx
  0036d	e8 00 00 00 00	 call	 _tr_flush_block
  00372	44 8b 9b 94 00
	00 00		 mov	 r11d, DWORD PTR [rbx+148]
  00379	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0037c	44 89 9b 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r11d
  00383	e8 00 00 00 00	 call	 flush_pending
  00388	4c 8b 1b	 mov	 r11, QWORD PTR [rbx]
  0038b	41 39 7b 18	 cmp	 DWORD PTR [r11+24], edi
  0038f	75 0f		 jne	 SHORT $LN1@deflate_fa
  00391	b8 02 00 00 00	 mov	 eax, 2
  00396	83 fe 04	 cmp	 esi, 4
  00399	0f 44 f8	 cmove	 edi, eax
  0039c	8b c7		 mov	 eax, edi
  0039e	eb 88		 jmp	 SHORT $LN18@deflate_fa
$LN1@deflate_fa:

; 1607 :     return flush == Z_FINISH ? finish_done : block_done;

  003a0	b8 01 00 00 00	 mov	 eax, 1
  003a5	b9 03 00 00 00	 mov	 ecx, 3
  003aa	83 fe 04	 cmp	 esi, 4
  003ad	0f 44 c1	 cmove	 eax, ecx
  003b0	e9 73 ff ff ff	 jmp	 $LN18@deflate_fa
deflate_fast ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_slow DD imagerel deflate_slow
	DD	imagerel deflate_slow+1235
	DD	imagerel $unwind$deflate_slow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_slow DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT deflate_slow
_TEXT	SEGMENT
s$ = 80
flush$ = 88
deflate_slow PROC					; COMDAT

; 1619 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001c	33 ff		 xor	 edi, edi
  0001e	44 8b e2	 mov	 r12d, edx
  00021	48 8b d9	 mov	 rbx, rcx
  00024	41 bf ff ff 00
	00		 mov	 r15d, 65535		; 0000ffffH
  0002a	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:__ImageBase
  00031	be 00 01 00 00	 mov	 esi, 256		; 00000100H
  00036	44 8d 6f 02	 lea	 r13d, QWORD PTR [rdi+2]
  0003a	8d 6f 01	 lea	 ebp, QWORD PTR [rdi+1]
  0003d	0f 1f 00	 npad	 3
$LL23@deflate_sl:

; 1620 :     IPos hash_head;          /* head of hash chain */
; 1621 :     int bflush;              /* set if current block must be flushed */
; 1622 : 
; 1623 :     /* Process the input block. */
; 1624 :     for (;;) {
; 1625 :         /* Make sure that we always have enough lookahead, except
; 1626 :          * at the end of the input file. We need MAX_MATCH bytes
; 1627 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1628 :          * string following the next match.
; 1629 :          */
; 1630 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00040	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  00046	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0004b	73 26		 jae	 SHORT $LN19@deflate_sl

; 1631 :             fill_window(s);

  0004d	48 8b cb	 mov	 rcx, rbx
  00050	e8 00 00 00 00	 call	 fill_window

; 1632 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00055	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  0005b	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00060	73 09		 jae	 SHORT $LN20@deflate_sl
  00062	45 85 e4	 test	 r12d, r12d
  00065	0f 84 ba 02 00
	00		 je	 $LN40@deflate_sl
$LN20@deflate_sl:

; 1633 :                 return need_more;
; 1634 :             }
; 1635 :             if (s->lookahead == 0) break; /* flush the current block */

  0006b	85 c0		 test	 eax, eax
  0006d	0f 84 a0 03 00
	00		 je	 $LN38@deflate_sl
$LN19@deflate_sl:

; 1636 :         }
; 1637 : 
; 1638 :         /* Insert the string window[strstart .. strstart+2] in the
; 1639 :          * dictionary, and set hash_head to the head of the hash chain:
; 1640 :          */
; 1641 :         hash_head = NIL;

  00073	44 8b c7	 mov	 r8d, edi

; 1642 :         if (s->lookahead >= MIN_MATCH) {

  00076	83 f8 03	 cmp	 eax, 3
  00079	72 69		 jb	 SHORT $LN18@deflate_sl

; 1643 :             INSERT_STRING(s, s->strstart, hash_head);

  0007b	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0007f	44 8b 8b 94 00
	00 00		 mov	 r9d, DWORD PTR [rbx+148]
  00086	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0008a	41 8d 49 02	 lea	 ecx, DWORD PTR [r9+2]
  0008e	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  00093	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00096	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  0009c	d3 e0		 shl	 eax, cl
  0009e	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  000a2	44 33 c0	 xor	 r8d, eax
  000a5	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  000a8	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  000ac	4c 23 c8	 and	 r9, rax
  000af	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  000b3	42 0f b7 04 42	 movzx	 eax, WORD PTR [rdx+r8*2]
  000b8	66 42 89 04 49	 mov	 WORD PTR [rcx+r9*2], ax
  000bd	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  000c0	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  000c6	8b 53 70	 mov	 edx, DWORD PTR [rbx+112]
  000c9	48 23 c8	 and	 rcx, rax
  000cc	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  000d0	44 0f b7 04 48	 movzx	 r8d, WORD PTR [rax+rcx*2]
  000d5	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  000d9	0f b7 83 94 00
	00 00		 movzx	 eax, WORD PTR [rbx+148]
  000e0	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
$LN18@deflate_sl:

; 1644 :         }
; 1645 : 
; 1646 :         /* Find the longest match, discarding those <= prev_length.
; 1647 :          */
; 1648 :         s->prev_length = s->match_length, s->prev_match = s->match_start;

  000e4	8b 8b 88 00 00
	00		 mov	 ecx, DWORD PTR [rbx+136]
  000ea	8b 83 98 00 00
	00		 mov	 eax, DWORD PTR [rbx+152]

; 1649 :         s->match_length = MIN_MATCH-1;

  000f0	44 89 ab 88 00
	00 00		 mov	 DWORD PTR [rbx+136], r13d
  000f7	89 8b a0 00 00
	00		 mov	 DWORD PTR [rbx+160], ecx
  000fd	89 83 8c 00 00
	00		 mov	 DWORD PTR [rbx+140], eax

; 1650 : 
; 1651 :         if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
; 1652 :             s->strstart - hash_head <= MAX_DIST(s)) {

  00103	45 85 c0	 test	 r8d, r8d
  00106	74 5a		 je	 SHORT $LN16@deflate_sl
  00108	3b 8b a8 00 00
	00		 cmp	 ecx, DWORD PTR [rbx+168]
  0010e	73 52		 jae	 SHORT $LN16@deflate_sl
  00110	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00116	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  00119	41 2b c8	 sub	 ecx, r8d
  0011c	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  00121	3b c8		 cmp	 ecx, eax
  00123	77 3d		 ja	 SHORT $LN16@deflate_sl

; 1653 :             /* To simplify the code, we prevent matches with the string
; 1654 :              * of window index 0 (in particular we have to avoid a match
; 1655 :              * of the string with itself at the start of the input file).
; 1656 :              */
; 1657 :             s->match_length = longest_match (s, hash_head);

  00125	41 8b d0	 mov	 edx, r8d
  00128	48 8b cb	 mov	 rcx, rbx
  0012b	e8 00 00 00 00	 call	 longest_match
  00130	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax

; 1658 :             /* longest_match() sets match_start */
; 1659 : 
; 1660 :             if (s->match_length <= 5 && (s->strategy == Z_FILTERED
; 1661 : #if TOO_FAR <= 32767
; 1662 :                 || (s->match_length == MIN_MATCH &&
; 1663 :                     s->strstart - s->match_start > TOO_FAR)
; 1664 : #endif
; 1665 :                 )) {

  00136	83 f8 05	 cmp	 eax, 5
  00139	77 27		 ja	 SHORT $LN16@deflate_sl
  0013b	39 ab b0 00 00
	00		 cmp	 DWORD PTR [rbx+176], ebp
  00141	74 18		 je	 SHORT $LN15@deflate_sl
  00143	83 f8 03	 cmp	 eax, 3
  00146	75 1a		 jne	 SHORT $LN16@deflate_sl
  00148	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0014e	2b 83 98 00 00
	00		 sub	 eax, DWORD PTR [rbx+152]
  00154	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00159	76 07		 jbe	 SHORT $LN16@deflate_sl
$LN15@deflate_sl:

; 1666 : 
; 1667 :                 /* If prev_match is also MIN_MATCH, match_start is garbage
; 1668 :                  * but we will ignore the current match anyway.
; 1669 :                  */
; 1670 :                 s->match_length = MIN_MATCH-1;

  0015b	44 89 ab 88 00
	00 00		 mov	 DWORD PTR [rbx+136], r13d
$LN16@deflate_sl:

; 1671 :             }
; 1672 :         }
; 1673 :         /* If there was a match at the previous step and the current
; 1674 :          * match is not better, output the previous match:
; 1675 :          */
; 1676 :         if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {

  00162	8b 83 a0 00 00
	00		 mov	 eax, DWORD PTR [rbx+160]
  00168	83 f8 03	 cmp	 eax, 3
  0016b	0f 82 d3 01 00
	00		 jb	 $LN14@deflate_sl
  00171	39 83 88 00 00
	00		 cmp	 DWORD PTR [rbx+136], eax
  00177	0f 87 c7 01 00
	00		 ja	 $LN14@deflate_sl

; 1677 :             uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;

  0017d	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00183	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]

; 1678 :             /* Do not insert strings in hash table beyond this. */
; 1679 : 
; 1680 :             check_match(s, s->strstart-1, s->prev_match, s->prev_length);
; 1681 : 
; 1682 :             _tr_tally_dist(s, s->strstart -1 - s->prev_match,
; 1683 :                            s->prev_length - MIN_MATCH, bflush);

  00189	0f b6 93 a0 00
	00 00		 movzx	 edx, BYTE PTR [rbx+160]
  00190	44 8d 5c 01 fd	 lea	 r11d, DWORD PTR [rcx+rax-3]
  00195	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  0019c	44 0f b7 c1	 movzx	 r8d, cx
  001a0	66 44 2b 83 8c
	00 00 00	 sub	 r8w, WORD PTR [rbx+140]
  001a8	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001ae	80 ea 03	 sub	 dl, 3
  001b1	66 41 ff c8	 dec	 r8w
  001b5	66 44 89 04 48	 mov	 WORD PTR [rax+rcx*2], r8w
  001ba	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001c0	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  001c7	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  001ca	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  001d0	66 45 03 c7	 add	 r8w, r15w
  001d4	0f b6 c2	 movzx	 eax, dl
  001d7	42 0f b6 84 30
	00 00 00 00	 movzx	 eax, BYTE PTR _length_code[rax+r14]
  001e0	66 ff 84 83 c0
	04 00 00	 inc	 WORD PTR [rbx+rax*4+1216]
  001e8	41 0f b7 c0	 movzx	 eax, r8w
  001ec	66 44 3b c6	 cmp	 r8w, si
  001f0	73 0b		 jae	 SHORT $LN26@deflate_sl
  001f2	42 0f b6 8c 30
	00 00 00 00	 movzx	 ecx, BYTE PTR _dist_code[rax+r14]
  001fb	eb 0d		 jmp	 SHORT $LN27@deflate_sl
$LN26@deflate_sl:
  001fd	48 c1 e8 07	 shr	 rax, 7
  00201	42 0f b6 8c 30
	00 01 00 00	 movzx	 ecx, BYTE PTR _dist_code[rax+r14+256]
$LN27@deflate_sl:
  0020a	48 63 c1	 movsxd	 rax, ecx
  0020d	8b f7		 mov	 esi, edi
  0020f	66 ff 84 83 b0
	09 00 00	 inc	 WORD PTR [rbx+rax*4+2480]

; 1684 : 
; 1685 :             /* Insert in hash table all strings up to the end of the match.
; 1686 :              * strstart-1 and strstart are already inserted. If there is not
; 1687 :              * enough lookahead, the last two strings are not inserted in
; 1688 :              * the hash table.
; 1689 :              */
; 1690 :             s->lookahead -= s->prev_length-1;

  00217	8b 8b a0 00 00
	00		 mov	 ecx, DWORD PTR [rbx+160]
  0021d	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  00223	ff c8		 dec	 eax
  00225	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax
  0022b	8b c5		 mov	 eax, ebp
  0022d	40 0f 94 c6	 sete	 sil
  00231	2b c1		 sub	 eax, ecx
  00233	01 83 9c 00 00
	00		 add	 DWORD PTR [rbx+156], eax

; 1691 :             s->prev_length -= 2;

  00239	8d 41 fe	 lea	 eax, DWORD PTR [rcx-2]
  0023c	89 83 a0 00 00
	00		 mov	 DWORD PTR [rbx+160], eax
  00242	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL13@deflate_sl:

; 1692 :             do {
; 1693 :                 if (++s->strstart <= max_insert) {

  00250	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
  00256	44 8b 93 94 00
	00 00		 mov	 r10d, DWORD PTR [rbx+148]
  0025d	45 3b d3	 cmp	 r10d, r11d
  00260	77 4e		 ja	 SHORT $LN12@deflate_sl

; 1694 :                     INSERT_STRING(s, s->strstart, hash_head);

  00262	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00266	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0026a	44 8b 43 4c	 mov	 r8d, DWORD PTR [rbx+76]
  0026e	41 8d 4a 02	 lea	 ecx, DWORD PTR [r10+2]
  00272	44 0f b6 0c 01	 movzx	 r9d, BYTE PTR [rcx+rax]
  00277	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  0027d	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00280	d3 e0		 shl	 eax, cl
  00282	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00286	44 33 c8	 xor	 r9d, eax
  00289	44 23 4b 7c	 and	 r9d, DWORD PTR [rbx+124]
  0028d	4d 23 c2	 and	 r8, r10
  00290	44 89 4b 70	 mov	 DWORD PTR [rbx+112], r9d
  00294	42 0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+r9*2]
  00299	66 42 89 04 41	 mov	 WORD PTR [rcx+r8*2], ax
  0029e	8b 53 70	 mov	 edx, DWORD PTR [rbx+112]
  002a1	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  002a5	0f b7 83 94 00
	00 00		 movzx	 eax, WORD PTR [rbx+148]
  002ac	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
$LN12@deflate_sl:

; 1695 :                 }
; 1696 :             } while (--s->prev_length != 0);

  002b0	ff 8b a0 00 00
	00		 dec	 DWORD PTR [rbx+160]
  002b6	75 98		 jne	 SHORT $LL13@deflate_sl

; 1697 :             s->match_available = 0;
; 1698 :             s->match_length = MIN_MATCH-1;
; 1699 :             s->strstart++;

  002b8	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
  002be	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]

; 1700 : 
; 1701 :             if (bflush) FLUSH_BLOCK(s, 0);

  002c5	85 f6		 test	 esi, esi
  002c7	be 00 01 00 00	 mov	 esi, 256		; 00000100H
  002cc	89 bb 90 00 00
	00		 mov	 DWORD PTR [rbx+144], edi
  002d2	44 89 ab 88 00
	00 00		 mov	 DWORD PTR [rbx+136], r13d
  002d9	0f 84 61 fd ff
	ff		 je	 $LL23@deflate_sl
  002df	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  002e5	85 c0		 test	 eax, eax
  002e7	78 08		 js	 SHORT $LN28@deflate_sl
  002e9	8b d0		 mov	 edx, eax
  002eb	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  002ef	eb 03		 jmp	 SHORT $LN29@deflate_sl
$LN28@deflate_sl:
  002f1	48 8b d7	 mov	 rdx, rdi
$LN29@deflate_sl:
  002f4	44 2b c0	 sub	 r8d, eax
  002f7	45 33 c9	 xor	 r9d, r9d
  002fa	48 8b cb	 mov	 rcx, rbx
  002fd	e8 00 00 00 00	 call	 _tr_flush_block
  00302	44 8b 9b 94 00
	00 00		 mov	 r11d, DWORD PTR [rbx+148]
  00309	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0030c	44 89 9b 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r11d
  00313	e8 00 00 00 00	 call	 flush_pending
  00318	4c 8b 1b	 mov	 r11, QWORD PTR [rbx]
  0031b	41 39 7b 18	 cmp	 DWORD PTR [r11+24], edi
  0031f	0f 85 1b fd ff
	ff		 jne	 $LL23@deflate_sl
$LN40@deflate_sl:

; 1712 :             }
; 1713 :             s->strstart++;
; 1714 :             s->lookahead--;
; 1715 :             if (s->strm->avail_out == 0) return need_more;

  00325	33 c0		 xor	 eax, eax
$LN24@deflate_sl:

; 1733 : }

  00327	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0032c	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00331	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00336	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0033a	41 5f		 pop	 r15
  0033c	41 5e		 pop	 r14
  0033e	41 5d		 pop	 r13
  00340	41 5c		 pop	 r12
  00342	5f		 pop	 rdi
  00343	c3		 ret	 0
$LN14@deflate_sl:

; 1702 : 
; 1703 :         } else if (s->match_available) {

  00344	39 bb 90 00 00
	00		 cmp	 DWORD PTR [rbx+144], edi
  0034a	0f 84 ac 00 00
	00		 je	 $LN6@deflate_sl

; 1704 :             /* If there was no match at the previous position, output a
; 1705 :              * single literal. If there was a match but the current match
; 1706 :              * is longer, truncate the previous match to a single literal.
; 1707 :              */
; 1708 :             Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1709 :             _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  00350	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00356	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0035a	ff c9		 dec	 ecx
  0035c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00360	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00366	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  0036d	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  00371	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00377	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  0037e	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00381	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00387	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]
  0038f	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  00395	ff c8		 dec	 eax
  00397	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 1710 :             if (bflush) {

  0039d	75 40		 jne	 SHORT $LN5@deflate_sl

; 1711 :                 FLUSH_BLOCK_ONLY(s, 0);

  0039f	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  003a5	85 c0		 test	 eax, eax
  003a7	78 08		 js	 SHORT $LN30@deflate_sl
  003a9	8b d0		 mov	 edx, eax
  003ab	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  003af	eb 03		 jmp	 SHORT $LN31@deflate_sl
$LN30@deflate_sl:
  003b1	48 8b d7	 mov	 rdx, rdi
$LN31@deflate_sl:
  003b4	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  003bb	45 33 c9	 xor	 r9d, r9d
  003be	48 8b cb	 mov	 rcx, rbx
  003c1	44 2b c0	 sub	 r8d, eax
  003c4	e8 00 00 00 00	 call	 _tr_flush_block
  003c9	44 8b 9b 94 00
	00 00		 mov	 r11d, DWORD PTR [rbx+148]
  003d0	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  003d3	44 89 9b 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r11d
  003da	e8 00 00 00 00	 call	 flush_pending
$LN5@deflate_sl:

; 1712 :             }
; 1713 :             s->strstart++;
; 1714 :             s->lookahead--;
; 1715 :             if (s->strm->avail_out == 0) return need_more;

  003df	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  003e2	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
  003e8	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
  003ee	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  003f1	0f 85 49 fc ff
	ff		 jne	 $LL23@deflate_sl

; 1716 :         } else {

  003f7	e9 29 ff ff ff	 jmp	 $LN40@deflate_sl
$LN6@deflate_sl:

; 1717 :             /* There is no previous match to compare with, wait for
; 1718 :              * the next step to decide.
; 1719 :              */
; 1720 :             s->match_available = 1;
; 1721 :             s->strstart++;

  003fc	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]

; 1722 :             s->lookahead--;

  00402	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
  00408	89 ab 90 00 00
	00		 mov	 DWORD PTR [rbx+144], ebp

; 1723 :         }
; 1724 :     }

  0040e	e9 2d fc ff ff	 jmp	 $LL23@deflate_sl
$LN38@deflate_sl:

; 1725 :     Assert (flush != Z_NO_FLUSH, "no flush?");
; 1726 :     if (s->match_available) {

  00413	39 bb 90 00 00
	00		 cmp	 DWORD PTR [rbx+144], edi
  00419	74 45		 je	 SHORT $LN2@deflate_sl

; 1727 :         Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1728 :         _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  0041b	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00421	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00425	ff c9		 dec	 ecx
  00427	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0042b	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00431	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  00438	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  0043c	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00442	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00449	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0044c	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00452	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]

; 1729 :         s->match_available = 0;

  0045a	89 bb 90 00 00
	00		 mov	 DWORD PTR [rbx+144], edi
$LN2@deflate_sl:

; 1730 :     }
; 1731 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  00460	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  00466	85 c0		 test	 eax, eax
  00468	78 08		 js	 SHORT $LN32@deflate_sl
  0046a	8b d0		 mov	 edx, eax
  0046c	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00470	eb 03		 jmp	 SHORT $LN33@deflate_sl
$LN32@deflate_sl:
  00472	48 8b d7	 mov	 rdx, rdi
$LN33@deflate_sl:
  00475	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  0047c	44 8b cf	 mov	 r9d, edi
  0047f	41 83 fc 04	 cmp	 r12d, 4
  00483	41 0f 94 c1	 sete	 r9b
  00487	44 2b c0	 sub	 r8d, eax
  0048a	48 8b cb	 mov	 rcx, rbx
  0048d	e8 00 00 00 00	 call	 _tr_flush_block
  00492	44 8b 9b 94 00
	00 00		 mov	 r11d, DWORD PTR [rbx+148]
  00499	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0049c	44 89 9b 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r11d
  004a3	e8 00 00 00 00	 call	 flush_pending
  004a8	4c 8b 1b	 mov	 r11, QWORD PTR [rbx]
  004ab	41 39 7b 18	 cmp	 DWORD PTR [r11+24], edi
  004af	75 0f		 jne	 SHORT $LN1@deflate_sl
  004b1	41 83 fc 04	 cmp	 r12d, 4
  004b5	41 0f 44 fd	 cmove	 edi, r13d
  004b9	8b c7		 mov	 eax, edi
  004bb	e9 67 fe ff ff	 jmp	 $LN24@deflate_sl
$LN1@deflate_sl:

; 1732 :     return flush == Z_FINISH ? finish_done : block_done;

  004c0	b8 03 00 00 00	 mov	 eax, 3
  004c5	41 83 fc 04	 cmp	 r12d, 4
  004c9	0f 44 e8	 cmove	 ebp, eax
  004cc	8b c5		 mov	 eax, ebp
  004ce	e9 54 fe ff ff	 jmp	 $LN24@deflate_sl
deflate_slow ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_rle DD imagerel deflate_rle
	DD	imagerel deflate_rle+781
	DD	imagerel $unwind$deflate_rle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_rle DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT deflate_rle
_TEXT	SEGMENT
s$ = 48
flush$ = 56
deflate_rle PROC					; COMDAT

; 1744 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	33 ff		 xor	 edi, edi
  0001c	8b f2		 mov	 esi, edx
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	8d 6f 01	 lea	 ebp, QWORD PTR [rdi+1]
  00024	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_length_code
  0002b	0f 1f 44 00 00	 npad	 5
$LL17@deflate_rl:

; 1745 :     int bflush;             /* set if current block must be flushed */
; 1746 :     uInt prev;              /* byte at distance one to match */
; 1747 :     Bytef *scan, *strend;   /* scan goes up to strend for length of run */
; 1748 : 
; 1749 :     for (;;) {
; 1750 :         /* Make sure that we always have enough lookahead, except
; 1751 :          * at the end of the input file. We need MAX_MATCH bytes
; 1752 :          * for the longest encodable run.
; 1753 :          */
; 1754 :         if (s->lookahead < MAX_MATCH) {

  00030	44 8b 83 9c 00
	00 00		 mov	 r8d, DWORD PTR [rbx+156]
  00037	41 81 f8 02 01
	00 00		 cmp	 r8d, 258		; 00000102H
  0003e	73 29		 jae	 SHORT $LN13@deflate_rl

; 1755 :             fill_window(s);

  00040	48 8b cb	 mov	 rcx, rbx
  00043	e8 00 00 00 00	 call	 fill_window

; 1756 :             if (s->lookahead < MAX_MATCH && flush == Z_NO_FLUSH) {

  00048	44 8b 83 9c 00
	00 00		 mov	 r8d, DWORD PTR [rbx+156]
  0004f	41 81 f8 02 01
	00 00		 cmp	 r8d, 258		; 00000102H
  00056	73 08		 jae	 SHORT $LN14@deflate_rl
  00058	85 f6		 test	 esi, esi
  0005a	0f 84 1f 02 00
	00		 je	 $LN31@deflate_rl
$LN14@deflate_rl:

; 1757 :                 return need_more;
; 1758 :             }
; 1759 :             if (s->lookahead == 0) break; /* flush the current block */

  00060	45 85 c0	 test	 r8d, r8d
  00063	0f 84 33 02 00
	00		 je	 $LN30@deflate_rl
$LN13@deflate_rl:

; 1760 :         }
; 1761 : 
; 1762 :         /* See how many times the previous byte repeats */
; 1763 :         s->match_length = 0;

  00069	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi

; 1764 :         if (s->lookahead >= MIN_MATCH && s->strstart > 0) {

  0006f	41 83 f8 03	 cmp	 r8d, 3
  00073	0f 82 cf 00 00
	00		 jb	 $LN6@deflate_rl
  00079	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0007f	85 c0		 test	 eax, eax
  00081	0f 84 c1 00 00
	00		 je	 $LN6@deflate_rl

; 1765 :             scan = s->window + s->strstart - 1;

  00087	4c 8b 53 50	 mov	 r10, QWORD PTR [rbx+80]
  0008b	44 8b c8	 mov	 r9d, eax

; 1766 :             prev = *scan;

  0008e	41 0f b6 54 02
	ff		 movzx	 edx, BYTE PTR [r10+rax-1]
  00094	49 8d 4c 02 ff	 lea	 rcx, QWORD PTR [r10+rax-1]

; 1767 :             if (prev == *++scan && prev == *++scan && prev == *++scan) {

  00099	41 0f b6 04 02	 movzx	 eax, BYTE PTR [r10+rax]
  0009e	3b d0		 cmp	 edx, eax
  000a0	0f 85 a2 00 00
	00		 jne	 $LN6@deflate_rl
  000a6	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  000aa	3b d0		 cmp	 edx, eax
  000ac	0f 85 96 00 00
	00		 jne	 $LN6@deflate_rl
  000b2	0f b6 41 03	 movzx	 eax, BYTE PTR [rcx+3]
  000b6	48 83 c1 03	 add	 rcx, 3
  000ba	3b d0		 cmp	 edx, eax
  000bc	0f 85 86 00 00
	00		 jne	 $LN6@deflate_rl

; 1768 :                 strend = s->window + s->strstart + MAX_MATCH;

  000c2	4f 8d 8c 0a 02
	01 00 00	 lea	 r9, QWORD PTR [r10+r9+258]
  000ca	66 0f 1f 44 00
	00		 npad	 6
$LL10@deflate_rl:

; 1769 :                 do {
; 1770 :                 } while (prev == *++scan && prev == *++scan &&
; 1771 :                          prev == *++scan && prev == *++scan &&
; 1772 :                          prev == *++scan && prev == *++scan &&
; 1773 :                          prev == *++scan && prev == *++scan &&
; 1774 :                          scan < strend);

  000d0	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000d4	48 ff c1	 inc	 rcx
  000d7	3b d0		 cmp	 edx, eax
  000d9	75 52		 jne	 SHORT $LN7@deflate_rl
  000db	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000df	48 ff c1	 inc	 rcx
  000e2	3b d0		 cmp	 edx, eax
  000e4	75 47		 jne	 SHORT $LN7@deflate_rl
  000e6	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000ea	48 ff c1	 inc	 rcx
  000ed	3b d0		 cmp	 edx, eax
  000ef	75 3c		 jne	 SHORT $LN7@deflate_rl
  000f1	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000f5	48 ff c1	 inc	 rcx
  000f8	3b d0		 cmp	 edx, eax
  000fa	75 31		 jne	 SHORT $LN7@deflate_rl
  000fc	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00100	48 ff c1	 inc	 rcx
  00103	3b d0		 cmp	 edx, eax
  00105	75 26		 jne	 SHORT $LN7@deflate_rl
  00107	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0010b	48 ff c1	 inc	 rcx
  0010e	3b d0		 cmp	 edx, eax
  00110	75 1b		 jne	 SHORT $LN7@deflate_rl
  00112	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00116	48 ff c1	 inc	 rcx
  00119	3b d0		 cmp	 edx, eax
  0011b	75 10		 jne	 SHORT $LN7@deflate_rl
  0011d	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00121	48 ff c1	 inc	 rcx
  00124	3b d0		 cmp	 edx, eax
  00126	75 05		 jne	 SHORT $LN7@deflate_rl
  00128	49 3b c9	 cmp	 rcx, r9
  0012b	72 a3		 jb	 SHORT $LL10@deflate_rl
$LN7@deflate_rl:

; 1775 :                 s->match_length = MAX_MATCH - (int)(strend - scan);

  0012d	41 2b c9	 sub	 ecx, r9d
  00130	8d 81 02 01 00
	00		 lea	 eax, DWORD PTR [rcx+258]
  00136	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax

; 1776 :                 if (s->match_length > s->lookahead)

  0013c	41 3b c0	 cmp	 eax, r8d
  0013f	76 07		 jbe	 SHORT $LN6@deflate_rl

; 1777 :                     s->match_length = s->lookahead;

  00141	44 89 83 88 00
	00 00		 mov	 DWORD PTR [rbx+136], r8d
$LN6@deflate_rl:

; 1778 :             }
; 1779 :         }
; 1780 : 
; 1781 :         /* Emit match if have run of MIN_MATCH or longer, else emit literal */
; 1782 :         if (s->match_length >= MIN_MATCH) {

  00148	83 bb 88 00 00
	00 03		 cmp	 DWORD PTR [rbx+136], 3
  0014f	72 7d		 jb	 SHORT $LN5@deflate_rl

; 1783 :             check_match(s, s->strstart, s->strstart - 1, s->match_length);
; 1784 : 
; 1785 :             _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);

  00151	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00157	0f b6 93 88 00
	00 00		 movzx	 edx, BYTE PTR [rbx+136]
  0015e	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  00165	66 89 2c 48	 mov	 WORD PTR [rax+rcx*2], bp
  00169	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0016f	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00176	80 ea 03	 sub	 dl, 3
  00179	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0017c	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00182	0f b6 c2	 movzx	 eax, dl
  00185	42 0f b6 0c 20	 movzx	 ecx, BYTE PTR [rax+r12]
  0018a	66 ff 84 8b c0
	04 00 00	 inc	 WORD PTR [rbx+rcx*4+1216]
  00192	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _dist_code
  00199	8b cf		 mov	 ecx, edi
  0019b	66 ff 84 83 b0
	09 00 00	 inc	 WORD PTR [rbx+rax*4+2480]
  001a3	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  001a9	ff c8		 dec	 eax
  001ab	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 1786 : 
; 1787 :             s->lookahead -= s->match_length;

  001b1	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [rbx+136]

; 1788 :             s->strstart += s->match_length;
; 1789 :             s->match_length = 0;

  001b7	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi
  001bd	0f 94 c1	 sete	 cl
  001c0	29 83 9c 00 00
	00		 sub	 DWORD PTR [rbx+156], eax
  001c6	01 83 94 00 00
	00		 add	 DWORD PTR [rbx+148], eax

; 1790 :         } else {

  001cc	eb 5c		 jmp	 SHORT $LN4@deflate_rl
$LN5@deflate_rl:

; 1791 :             /* No match, output a literal byte */
; 1792 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1793 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  001ce	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  001d4	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  001d8	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001dc	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001e2	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  001e9	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  001ed	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001f3	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  001fa	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  001fd	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00203	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]
  0020b	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  00211	8b cf		 mov	 ecx, edi
  00213	ff c8		 dec	 eax
  00215	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax
  0021b	0f 94 c1	 sete	 cl

; 1794 :             s->lookahead--;

  0021e	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]

; 1795 :             s->strstart++;

  00224	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
$LN4@deflate_rl:

; 1796 :         }
; 1797 :         if (bflush) FLUSH_BLOCK(s, 0);

  0022a	85 c9		 test	 ecx, ecx
  0022c	0f 84 fe fd ff
	ff		 je	 $LL17@deflate_rl
  00232	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  00238	85 c0		 test	 eax, eax
  0023a	78 08		 js	 SHORT $LN22@deflate_rl
  0023c	8b d0		 mov	 edx, eax
  0023e	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00242	eb 03		 jmp	 SHORT $LN23@deflate_rl
$LN22@deflate_rl:
  00244	48 8b d7	 mov	 rdx, rdi
$LN23@deflate_rl:
  00247	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  0024e	45 33 c9	 xor	 r9d, r9d
  00251	48 8b cb	 mov	 rcx, rbx
  00254	44 2b c0	 sub	 r8d, eax
  00257	e8 00 00 00 00	 call	 _tr_flush_block
  0025c	44 8b 9b 94 00
	00 00		 mov	 r11d, DWORD PTR [rbx+148]
  00263	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00266	44 89 9b 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r11d
  0026d	e8 00 00 00 00	 call	 flush_pending
  00272	4c 8b 1b	 mov	 r11, QWORD PTR [rbx]
  00275	41 39 7b 18	 cmp	 DWORD PTR [r11+24], edi
  00279	0f 85 b1 fd ff
	ff		 jne	 $LL17@deflate_rl
$LN31@deflate_rl:
  0027f	33 c0		 xor	 eax, eax
$LN18@deflate_rl:

; 1801 : }

  00281	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00286	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0028b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00290	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00295	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00299	41 5c		 pop	 r12
  0029b	c3		 ret	 0
$LN30@deflate_rl:

; 1798 :     }
; 1799 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  0029c	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  002a2	85 c0		 test	 eax, eax
  002a4	78 08		 js	 SHORT $LN24@deflate_rl
  002a6	8b d0		 mov	 edx, eax
  002a8	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  002ac	eb 03		 jmp	 SHORT $LN25@deflate_rl
$LN24@deflate_rl:
  002ae	48 8b d7	 mov	 rdx, rdi
$LN25@deflate_rl:
  002b1	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  002b8	44 8b cf	 mov	 r9d, edi
  002bb	83 fe 04	 cmp	 esi, 4
  002be	41 0f 94 c1	 sete	 r9b
  002c2	44 2b c0	 sub	 r8d, eax
  002c5	48 8b cb	 mov	 rcx, rbx
  002c8	e8 00 00 00 00	 call	 _tr_flush_block
  002cd	44 8b 9b 94 00
	00 00		 mov	 r11d, DWORD PTR [rbx+148]
  002d4	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  002d7	44 89 9b 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r11d
  002de	e8 00 00 00 00	 call	 flush_pending
  002e3	4c 8b 1b	 mov	 r11, QWORD PTR [rbx]
  002e6	41 39 7b 18	 cmp	 DWORD PTR [r11+24], edi
  002ea	75 0f		 jne	 SHORT $LN1@deflate_rl
  002ec	b8 02 00 00 00	 mov	 eax, 2
  002f1	83 fe 04	 cmp	 esi, 4
  002f4	0f 44 f8	 cmove	 edi, eax
  002f7	8b c7		 mov	 eax, edi
  002f9	eb 86		 jmp	 SHORT $LN18@deflate_rl
$LN1@deflate_rl:

; 1800 :     return flush == Z_FINISH ? finish_done : block_done;

  002fb	b8 03 00 00 00	 mov	 eax, 3
  00300	83 fe 04	 cmp	 esi, 4
  00303	0f 44 e8	 cmove	 ebp, eax
  00306	8b c5		 mov	 eax, ebp
  00308	e9 74 ff ff ff	 jmp	 $LN18@deflate_rl
deflate_rle ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_huff DD imagerel deflate_huff
	DD	imagerel deflate_huff+389
	DD	imagerel $unwind$deflate_huff
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_huff DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT deflate_huff
_TEXT	SEGMENT
s$ = 48
flush$ = 56
deflate_huff PROC					; COMDAT

; 1810 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b f2		 mov	 esi, edx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	33 ff		 xor	 edi, edi
$LL8@deflate_hu:

; 1811 :     int bflush;             /* set if current block must be flushed */
; 1812 : 
; 1813 :     for (;;) {
; 1814 :         /* Make sure that we have a literal to write. */
; 1815 :         if (s->lookahead == 0) {

  00016	39 bb 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], edi
  0001c	75 14		 jne	 SHORT $LN5@deflate_hu

; 1816 :             fill_window(s);

  0001e	48 8b cb	 mov	 rcx, rbx
  00021	e8 00 00 00 00	 call	 fill_window

; 1817 :             if (s->lookahead == 0) {

  00026	39 bb 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], edi
  0002c	0f 84 c2 00 00
	00		 je	 $LN17@deflate_hu
$LN5@deflate_hu:

; 1820 :                 break;      /* flush the current block */
; 1821 :             }
; 1822 :         }
; 1823 : 
; 1824 :         /* Output a literal byte */
; 1825 :         s->match_length = 0;
; 1826 :         Tracevv((stderr,"%c", s->window[s->strstart]));
; 1827 :         _tr_tally_lit (s, s->window[s->strstart], bflush);

  00032	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00038	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0003c	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi
  00042	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00046	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0004c	48 8b 83 f8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5880]
  00053	66 89 3c 48	 mov	 WORD PTR [rax+rcx*2], di
  00057	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0005d	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00064	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00067	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0006d	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]

; 1828 :         s->lookahead--;
; 1829 :         s->strstart++;

  00075	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]
  0007b	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  00081	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
  00087	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  0008e	ff c8		 dec	 eax
  00090	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 1830 :         if (bflush) FLUSH_BLOCK(s, 0);

  00096	0f 85 7a ff ff
	ff		 jne	 $LL8@deflate_hu
  0009c	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  000a2	85 c0		 test	 eax, eax
  000a4	78 08		 js	 SHORT $LN11@deflate_hu
  000a6	8b d0		 mov	 edx, eax
  000a8	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  000ac	eb 03		 jmp	 SHORT $LN12@deflate_hu
$LN11@deflate_hu:
  000ae	48 8b d7	 mov	 rdx, rdi
$LN12@deflate_hu:
  000b1	44 2b c0	 sub	 r8d, eax
  000b4	45 33 c9	 xor	 r9d, r9d
  000b7	48 8b cb	 mov	 rcx, rbx
  000ba	e8 00 00 00 00	 call	 _tr_flush_block
  000bf	44 8b 9b 94 00
	00 00		 mov	 r11d, DWORD PTR [rbx+148]
  000c6	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000c9	44 89 9b 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r11d
  000d0	e8 00 00 00 00	 call	 flush_pending
  000d5	4c 8b 1b	 mov	 r11, QWORD PTR [rbx]
  000d8	41 39 7b 18	 cmp	 DWORD PTR [r11+24], edi
  000dc	0f 85 34 ff ff
	ff		 jne	 $LL8@deflate_hu
$LN18@deflate_hu:
  000e2	33 c0		 xor	 eax, eax

; 1833 :     return flush == Z_FINISH ? finish_done : block_done;
; 1834 : }

  000e4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000e9	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000ee	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f2	5f		 pop	 rdi
  000f3	c3		 ret	 0
$LN17@deflate_hu:

; 1818 :                 if (flush == Z_NO_FLUSH)

  000f4	85 f6		 test	 esi, esi

; 1819 :                     return need_more;

  000f6	74 ea		 je	 SHORT $LN18@deflate_hu

; 1831 :     }
; 1832 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  000f8	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  000fe	85 c0		 test	 eax, eax
  00100	78 08		 js	 SHORT $LN13@deflate_hu
  00102	8b d0		 mov	 edx, eax
  00104	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00108	eb 03		 jmp	 SHORT $LN14@deflate_hu
$LN13@deflate_hu:
  0010a	48 8b d7	 mov	 rdx, rdi
$LN14@deflate_hu:
  0010d	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  00114	44 8b cf	 mov	 r9d, edi
  00117	83 fe 04	 cmp	 esi, 4
  0011a	41 0f 94 c1	 sete	 r9b
  0011e	44 2b c0	 sub	 r8d, eax
  00121	48 8b cb	 mov	 rcx, rbx
  00124	e8 00 00 00 00	 call	 _tr_flush_block
  00129	44 8b 9b 94 00
	00 00		 mov	 r11d, DWORD PTR [rbx+148]
  00130	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00133	44 89 9b 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r11d
  0013a	e8 00 00 00 00	 call	 flush_pending
  0013f	4c 8b 1b	 mov	 r11, QWORD PTR [rbx]
  00142	41 39 7b 18	 cmp	 DWORD PTR [r11+24], edi
  00146	75 1d		 jne	 SHORT $LN1@deflate_hu
  00148	b8 02 00 00 00	 mov	 eax, 2
  0014d	83 fe 04	 cmp	 esi, 4
  00150	0f 44 f8	 cmove	 edi, eax
  00153	8b c7		 mov	 eax, edi

; 1833 :     return flush == Z_FINISH ? finish_done : block_done;
; 1834 : }

  00155	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0015a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0015f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00163	5f		 pop	 rdi
  00164	c3		 ret	 0
$LN1@deflate_hu:
  00165	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0016a	83 fe 04	 cmp	 esi, 4
  0016d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00172	b8 01 00 00 00	 mov	 eax, 1
  00177	b9 03 00 00 00	 mov	 ecx, 3
  0017c	0f 44 c1	 cmove	 eax, ecx
  0017f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00183	5f		 pop	 rdi
  00184	c3		 ret	 0
deflate_huff ENDP
_TEXT	ENDS
PUBLIC	deflateReset
EXTRN	_tr_init:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateReset DD imagerel $LN8
	DD	imagerel $LN8+64
	DD	imagerel $unwind$deflateReset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$deflateReset DD imagerel $LN8+64
	DD	imagerel $LN8+191
	DD	imagerel $chain$0$deflateReset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$deflateReset DD imagerel $LN8+191
	DD	imagerel $LN8+207
	DD	imagerel $chain$1$deflateReset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$deflateReset DD 021H
	DD	imagerel $LN8
	DD	imagerel $LN8+64
	DD	imagerel $unwind$deflateReset
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$deflateReset DD 020521H
	DD	066405H
	DD	imagerel $LN8
	DD	imagerel $LN8+64
	DD	imagerel $unwind$deflateReset
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateReset DD 040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT deflateReset
_TEXT	SEGMENT
strm$ = 48
deflateReset PROC					; COMDAT

; 355  : {

$LN8:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 356  :     deflate_state *s;
; 357  : 
; 358  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 359  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {

  0000d	48 85 c9	 test	 rcx, rcx
  00010	0f 84 a9 00 00
	00		 je	 $LN2@deflateRes
  00016	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  0001a	48 85 ff	 test	 rdi, rdi
  0001d	0f 84 9c 00 00
	00		 je	 $LN2@deflateRes
  00023	48 83 79 30 00	 cmp	 QWORD PTR [rcx+48], 0
  00028	0f 84 91 00 00
	00		 je	 $LN2@deflateRes
  0002e	48 83 79 38 00	 cmp	 QWORD PTR [rcx+56], 0
  00033	0f 84 86 00 00
	00		 je	 $LN2@deflateRes

; 361  :     }
; 362  : 
; 363  :     strm->total_in = strm->total_out = 0;
; 364  :     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
; 365  :     strm->data_type = Z_UNKNOWN;

  00039	c7 41 48 02 00
	00 00		 mov	 DWORD PTR [rcx+72], 2
  00040	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00045	33 f6		 xor	 esi, esi
  00047	89 71 1c	 mov	 DWORD PTR [rcx+28], esi
  0004a	89 71 0c	 mov	 DWORD PTR [rcx+12], esi
  0004d	48 89 71 20	 mov	 QWORD PTR [rcx+32], rsi

; 366  : 
; 367  :     s = (deflate_state *)strm->state;
; 368  :     s->pending = 0;
; 369  :     s->pending_out = s->pending_buf;

  00051	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00055	89 77 28	 mov	 DWORD PTR [rdi+40], esi
  00058	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 370  : 
; 371  :     if (s->wrap < 0) {

  0005c	8b 47 2c	 mov	 eax, DWORD PTR [rdi+44]
  0005f	85 c0		 test	 eax, eax
  00061	79 05		 jns	 SHORT $LN1@deflateRes

; 372  :         s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */

  00063	f7 d8		 neg	 eax
  00065	89 47 2c	 mov	 DWORD PTR [rdi+44], eax
$LN1@deflateRes:

; 373  :     }
; 374  :     s->status = s->wrap ? INIT_STATE : BUSY_STATE;

  00068	8b 4f 2c	 mov	 ecx, DWORD PTR [rdi+44]
  0006b	ba 2a 00 00 00	 mov	 edx, 42			; 0000002aH
  00070	b8 71 00 00 00	 mov	 eax, 113		; 00000071H
  00075	85 c9		 test	 ecx, ecx
  00077	0f 45 c2	 cmovne	 eax, edx

; 375  :     strm->adler =
; 376  : #ifdef GZIP
; 377  :         s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
; 378  : #endif
; 379  :         adler32(0L, Z_NULL, 0);

  0007a	45 33 c0	 xor	 r8d, r8d
  0007d	33 d2		 xor	 edx, edx
  0007f	89 47 08	 mov	 DWORD PTR [rdi+8], eax
  00082	83 f9 02	 cmp	 ecx, 2
  00085	75 09		 jne	 SHORT $LN6@deflateRes
  00087	33 c9		 xor	 ecx, ecx
  00089	e8 00 00 00 00	 call	 crc32
  0008e	eb 07		 jmp	 SHORT $LN7@deflateRes
$LN6@deflateRes:
  00090	33 c9		 xor	 ecx, ecx
  00092	e8 00 00 00 00	 call	 adler32
$LN7@deflateRes:
  00097	89 43 4c	 mov	 DWORD PTR [rbx+76], eax

; 380  :     s->last_flush = Z_NO_FLUSH;
; 381  : 
; 382  :     _tr_init(s);

  0009a	48 8b cf	 mov	 rcx, rdi
  0009d	89 77 40	 mov	 DWORD PTR [rdi+64], esi
  000a0	e8 00 00 00 00	 call	 _tr_init

; 383  :     lm_init(s);

  000a5	48 8b cf	 mov	 rcx, rdi
  000a8	e8 00 00 00 00	 call	 lm_init
  000ad	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 384  : 
; 385  :     return Z_OK;

  000b2	33 c0		 xor	 eax, eax

; 386  : }

  000b4	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000b9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bd	5f		 pop	 rdi
  000be	c3		 ret	 0
$LN2@deflateRes:

; 360  :         return Z_STREAM_ERROR;

  000bf	b8 fe ff ff ff	 mov	 eax, -2

; 386  : }

  000c4	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000c9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cd	5f		 pop	 rdi
  000ce	c3		 ret	 0
deflateReset ENDP
_TEXT	ENDS
PUBLIC	deflate
EXTRN	_tr_stored_block:PROC
EXTRN	_tr_align:PROC
EXTRN	z_errmsg:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate DD imagerel $LN112
	DD	imagerel $LN112+120
	DD	imagerel $unwind$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$deflate DD imagerel $LN112+120
	DD	imagerel $LN112+1079
	DD	imagerel $chain$1$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$deflate DD imagerel $LN112+1079
	DD	imagerel $LN112+1469
	DD	imagerel $chain$2$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflate DD imagerel $LN112+1469
	DD	imagerel $LN112+1611
	DD	imagerel $chain$3$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$deflate DD imagerel $LN112+1611
	DD	imagerel $LN112+2157
	DD	imagerel $chain$5$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$deflate DD imagerel $LN112+2157
	DD	imagerel $LN112+2181
	DD	imagerel $chain$6$deflate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$deflate DD 021H
	DD	imagerel $LN112
	DD	imagerel $LN112+120
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$deflate DD 040021H
	DD	0ad400H
	DD	09c400H
	DD	imagerel $LN112
	DD	imagerel $LN112+120
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflate DD 021H
	DD	imagerel $LN112+120
	DD	imagerel $LN112+1079
	DD	imagerel $chain$1$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$deflate DD 020521H
	DD	086405H
	DD	imagerel $LN112+120
	DD	imagerel $LN112+1079
	DD	imagerel $chain$1$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$deflate DD 040a21H
	DD	0ad40aH
	DD	09c405H
	DD	imagerel $LN112
	DD	imagerel $LN112+120
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate DD 040801H
	DD	070043208H
	DD	030025003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT deflate
_TEXT	SEGMENT
strm$ = 64
flush$ = 72
deflate	PROC						; COMDAT

; 585  : {

$LN112:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00008	8b ea		 mov	 ebp, edx
  0000a	48 8b f9	 mov	 rdi, rcx

; 586  :     int old_flush; /* value of flush param for previous deflate call */
; 587  :     deflate_state *s;
; 588  : 
; 589  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 590  :         flush > Z_BLOCK || flush < 0) {

  0000d	48 85 c9	 test	 rcx, rcx
  00010	0f 84 62 08 00
	00		 je	 $LN82@deflate
  00016	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  0001a	48 85 db	 test	 rbx, rbx
  0001d	0f 84 55 08 00
	00		 je	 $LN82@deflate
  00023	83 fa 05	 cmp	 edx, 5
  00026	0f 87 4c 08 00
	00		 ja	 $LN82@deflate

; 591  :         return Z_STREAM_ERROR;
; 592  :     }
; 593  :     s = strm->state;
; 594  : 
; 595  :     if (strm->next_out == Z_NULL ||
; 596  :         (strm->next_in == Z_NULL && strm->avail_in != 0) ||
; 597  :         (s->status == FINISH_STATE && flush != Z_FINISH)) {

  0002c	48 83 79 10 00	 cmp	 QWORD PTR [rcx+16], 0
  00031	0f 84 36 08 00
	00		 je	 $LN80@deflate
  00037	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  0003b	75 0a		 jne	 SHORT $LN79@deflate
  0003d	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00041	0f 85 26 08 00
	00		 jne	 $LN80@deflate
$LN79@deflate:
  00047	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  0004a	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  0004f	75 09		 jne	 SHORT $LN81@deflate
  00051	83 fa 04	 cmp	 edx, 4
  00054	0f 85 13 08 00
	00		 jne	 $LN80@deflate
$LN81@deflate:

; 599  :     }
; 600  :     if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

  0005a	83 79 18 00	 cmp	 DWORD PTR [rcx+24], 0
  0005e	75 18		 jne	 SHORT $LN78@deflate
  00060	48 8b 05 38 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+56
  00067	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
  0006b	b8 fb ff ff ff	 mov	 eax, -5

; 892  : }

  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5f		 pop	 rdi
  00075	5d		 pop	 rbp
  00076	5b		 pop	 rbx
  00077	c3		 ret	 0
$LN78@deflate:
  00078	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  0007d	4c 89 6c 24 50	 mov	 QWORD PTR [rsp+80], r13

; 601  : 
; 602  :     s->strm = strm; /* just in case */
; 603  :     old_flush = s->last_flush;

  00082	44 8b 6b 40	 mov	 r13d, DWORD PTR [rbx+64]

; 604  :     s->last_flush = flush;
; 605  : 
; 606  :     /* Write the header */
; 607  :     if (s->status == INIT_STATE) {

  00086	45 33 e4	 xor	 r12d, r12d
  00089	89 53 40	 mov	 DWORD PTR [rbx+64], edx
  0008c	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  0008f	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00092	0f 85 c6 02 00
	00		 jne	 $LN71@deflate

; 608  : #ifdef GZIP
; 609  :         if (s->wrap == 2) {

  00098	83 7b 2c 02	 cmp	 DWORD PTR [rbx+44], 2
  0009c	0f 85 1d 02 00
	00		 jne	 $LN76@deflate

; 610  :             strm->adler = crc32(0L, Z_NULL, 0);

  000a2	45 33 c0	 xor	 r8d, r8d
  000a5	33 d2		 xor	 edx, edx
  000a7	33 c9		 xor	 ecx, ecx
  000a9	e8 00 00 00 00	 call	 crc32
  000ae	89 47 4c	 mov	 DWORD PTR [rdi+76], eax

; 611  :             put_byte(s, 31);

  000b1	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  000b4	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000b8	c6 04 01 1f	 mov	 BYTE PTR [rcx+rax], 31
  000bc	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000bf	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 612  :             put_byte(s, 139);

  000c2	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000c6	c6 04 01 8b	 mov	 BYTE PTR [rcx+rax], 139	; 0000008bH
  000ca	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000cd	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 613  :             put_byte(s, 8);

  000d0	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000d4	c6 04 01 08	 mov	 BYTE PTR [rcx+rax], 8
  000d8	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 614  :             if (s->gzhead == Z_NULL) {

  000db	4c 8b 43 30	 mov	 r8, QWORD PTR [rbx+48]
  000df	44 8b 4b 28	 mov	 r9d, DWORD PTR [rbx+40]
  000e3	4d 85 c0	 test	 r8, r8
  000e6	0f 85 90 00 00
	00		 jne	 $LN75@deflate

; 615  :                 put_byte(s, 0);

  000ec	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000f0	45 88 24 01	 mov	 BYTE PTR [r9+rax], r12b
  000f4	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000f7	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 616  :                 put_byte(s, 0);

  000fa	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000fe	44 88 24 01	 mov	 BYTE PTR [rcx+rax], r12b
  00102	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00105	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 617  :                 put_byte(s, 0);

  00108	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0010c	44 88 24 01	 mov	 BYTE PTR [rcx+rax], r12b
  00110	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00113	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 618  :                 put_byte(s, 0);

  00116	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0011a	44 88 24 01	 mov	 BYTE PTR [rcx+rax], r12b
  0011e	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00121	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 619  :                 put_byte(s, 0);

  00124	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00128	44 88 24 01	 mov	 BYTE PTR [rcx+rax], r12b

; 620  :                 put_byte(s, s->level == 9 ? 2 :
; 621  :                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 622  :                              4 : 0));

  0012c	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [rbx+172]
  00132	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00135	83 f8 09	 cmp	 eax, 9
  00138	75 05		 jne	 SHORT $LN88@deflate
  0013a	8d 50 f9	 lea	 edx, QWORD PTR [rax-7]
  0013d	eb 16		 jmp	 SHORT $LN87@deflate
$LN88@deflate:
  0013f	83 bb b0 00 00
	00 02		 cmp	 DWORD PTR [rbx+176], 2
  00146	7d 08		 jge	 SHORT $LN86@deflate
  00148	41 8b d4	 mov	 edx, r12d
  0014b	83 f8 02	 cmp	 eax, 2
  0014e	7d 05		 jge	 SHORT $LN87@deflate
$LN86@deflate:
  00150	ba 04 00 00 00	 mov	 edx, 4
$LN87@deflate:
  00155	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  00158	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0015c	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0015f	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00162	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 623  :                 put_byte(s, OS_CODE);

  00165	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00169	c6 04 01 0b	 mov	 BYTE PTR [rcx+rax], 11
  0016d	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 624  :                 s->status = BUSY_STATE;

  00170	c7 43 08 71 00
	00 00		 mov	 DWORD PTR [rbx+8], 113	; 00000071H

; 625  :             }
; 626  :             else {

  00177	e9 e2 01 00 00	 jmp	 $LN71@deflate
$LN75@deflate:

; 627  :                 put_byte(s, (s->gzhead->text ? 1 : 0) +
; 628  :                             (s->gzhead->hcrc ? 2 : 0) +
; 629  :                             (s->gzhead->extra == Z_NULL ? 0 : 4) +
; 630  :                             (s->gzhead->name == Z_NULL ? 0 : 8) +
; 631  :                             (s->gzhead->comment == Z_NULL ? 0 : 16)
; 632  :                         );

  0017c	49 8b 40 30	 mov	 rax, QWORD PTR [r8+48]
  00180	48 f7 d8	 neg	 rax
  00183	41 8b 40 3c	 mov	 eax, DWORD PTR [r8+60]
  00187	1a d2		 sbb	 dl, dl
  00189	80 e2 10	 and	 dl, 16
  0018c	f7 d8		 neg	 eax
  0018e	49 8b 40 20	 mov	 rax, QWORD PTR [r8+32]
  00192	1a c9		 sbb	 cl, cl
  00194	80 e1 02	 and	 cl, 2
  00197	02 d1		 add	 dl, cl
  00199	48 f7 d8	 neg	 rax
  0019c	49 8b 40 10	 mov	 rax, QWORD PTR [r8+16]
  001a0	1a c9		 sbb	 cl, cl
  001a2	80 e1 08	 and	 cl, 8
  001a5	02 d1		 add	 dl, cl
  001a7	48 f7 d8	 neg	 rax
  001aa	1a c9		 sbb	 cl, cl
  001ac	80 e1 04	 and	 cl, 4
  001af	02 d1		 add	 dl, cl
  001b1	45 39 20	 cmp	 DWORD PTR [r8], r12d
  001b4	0f 95 c0	 setne	 al
  001b7	02 d0		 add	 dl, al
  001b9	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  001bd	41 88 14 01	 mov	 BYTE PTR [r9+rax], dl
  001c1	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001c4	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 633  :                 put_byte(s, (Byte)(s->gzhead->time & 0xff));

  001c7	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  001cb	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  001cf	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  001d3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001d6	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001d9	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 634  :                 put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));

  001dc	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  001e0	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  001e4	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  001e8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001eb	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001ee	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 635  :                 put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));

  001f1	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  001f5	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  001f9	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  001fd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00200	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 636  :                 put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));

  00203	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00207	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  0020b	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  0020e	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00212	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 637  :                 put_byte(s, s->level == 9 ? 2 :
; 638  :                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 639  :                              4 : 0));

  00215	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [rbx+172]
  0021b	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0021e	83 f8 09	 cmp	 eax, 9
  00221	75 05		 jne	 SHORT $LN92@deflate
  00223	8d 50 f9	 lea	 edx, QWORD PTR [rax-7]
  00226	eb 16		 jmp	 SHORT $LN91@deflate
$LN92@deflate:
  00228	83 bb b0 00 00
	00 02		 cmp	 DWORD PTR [rbx+176], 2
  0022f	7d 08		 jge	 SHORT $LN90@deflate
  00231	41 8b d4	 mov	 edx, r12d
  00234	83 f8 02	 cmp	 eax, 2
  00237	7d 05		 jge	 SHORT $LN91@deflate
$LN90@deflate:
  00239	ba 04 00 00 00	 mov	 edx, 4
$LN91@deflate:
  0023e	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  00241	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00245	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00248	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 640  :                 put_byte(s, s->gzhead->os & 0xff);

  0024b	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0024f	0f b6 40 0c	 movzx	 eax, BYTE PTR [rax+12]
  00253	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  00256	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0025a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0025d	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 641  :                 if (s->gzhead->extra != Z_NULL) {

  00260	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00264	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00268	4c 39 60 10	 cmp	 QWORD PTR [rax+16], r12
  0026c	74 28		 je	 SHORT $LN73@deflate

; 642  :                     put_byte(s, s->gzhead->extra_len & 0xff);

  0026e	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00272	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00276	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
  0027a	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 643  :                     put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);

  0027d	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00281	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  00284	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  00288	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0028c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0028f	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00292	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
$LN73@deflate:

; 644  :                 }
; 645  :                 if (s->gzhead->hcrc)

  00296	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0029a	44 39 60 3c	 cmp	 DWORD PTR [rax+60], r12d
  0029e	74 0f		 je	 SHORT $LN72@deflate

; 646  :                     strm->adler = crc32(strm->adler, s->pending_buf,
; 647  :                                         s->pending);

  002a0	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  002a4	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  002a7	e8 00 00 00 00	 call	 crc32
  002ac	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN72@deflate:

; 648  :                 s->gzindex = 0;

  002af	44 89 63 38	 mov	 DWORD PTR [rbx+56], r12d

; 649  :                 s->status = EXTRA_STATE;

  002b3	c7 43 08 45 00
	00 00		 mov	 DWORD PTR [rbx+8], 69	; 00000045H

; 650  :             }
; 651  :         }
; 652  :         else

  002ba	e9 9f 00 00 00	 jmp	 $LN71@deflate
$LN76@deflate:

; 653  : #endif
; 654  :         {
; 655  :             uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;

  002bf	8b 4b 48	 mov	 ecx, DWORD PTR [rbx+72]
  002c2	83 e9 08	 sub	 ecx, 8
  002c5	c1 e1 0c	 shl	 ecx, 12
  002c8	81 c1 00 08 00
	00		 add	 ecx, 2048		; 00000800H

; 656  :             uInt level_flags;
; 657  : 
; 658  :             if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)

  002ce	83 bb b0 00 00
	00 02		 cmp	 DWORD PTR [rbx+176], 2
  002d5	7d 25		 jge	 SHORT $LN69@deflate
  002d7	8b 93 ac 00 00
	00		 mov	 edx, DWORD PTR [rbx+172]
  002dd	83 fa 02	 cmp	 edx, 2
  002e0	7c 1a		 jl	 SHORT $LN69@deflate

; 660  :             else if (s->level < 6)

  002e2	83 fa 06	 cmp	 edx, 6
  002e5	7d 07		 jge	 SHORT $LN67@deflate

; 661  :                 level_flags = 1;

  002e7	b8 01 00 00 00	 mov	 eax, 1
  002ec	eb 11		 jmp	 SHORT $LN64@deflate
$LN67@deflate:

; 662  :             else if (s->level == 6)

  002ee	83 fa 06	 cmp	 edx, 6
  002f1	41 8b c4	 mov	 eax, r12d
  002f4	0f 95 c0	 setne	 al
  002f7	83 c0 02	 add	 eax, 2

; 663  :                 level_flags = 2;
; 664  :             else
; 665  :                 level_flags = 3;

  002fa	eb 03		 jmp	 SHORT $LN64@deflate
$LN69@deflate:

; 659  :                 level_flags = 0;

  002fc	41 8b c4	 mov	 eax, r12d
$LN64@deflate:

; 666  :             header |= (level_flags << 6);

  002ff	c1 e0 06	 shl	 eax, 6
  00302	0b c8		 or	 ecx, eax

; 667  :             if (s->strstart != 0) header |= PRESET_DICT;

  00304	44 39 a3 94 00
	00 00		 cmp	 DWORD PTR [rbx+148], r12d
  0030b	74 03		 je	 SHORT $LN63@deflate
  0030d	83 c9 20	 or	 ecx, 32			; 00000020H
$LN63@deflate:

; 668  :             header += 31 - (header % 31);

  00310	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H

; 669  : 
; 670  :             s->status = BUSY_STATE;

  00315	c7 43 08 71 00
	00 00		 mov	 DWORD PTR [rbx+8], 113	; 00000071H
  0031c	f7 e1		 mul	 ecx
  0031e	2b ca		 sub	 ecx, edx
  00320	d1 e9		 shr	 ecx, 1
  00322	03 d1		 add	 edx, ecx

; 671  :             putShortMSB(s, header);

  00324	48 8b cb	 mov	 rcx, rbx
  00327	c1 ea 04	 shr	 edx, 4
  0032a	ff c2		 inc	 edx
  0032c	6b d2 1f	 imul	 edx, 31
  0032f	e8 00 00 00 00	 call	 putShortMSB

; 672  : 
; 673  :             /* Save the adler32 of the preset dictionary: */
; 674  :             if (s->strstart != 0) {

  00334	44 39 a3 94 00
	00 00		 cmp	 DWORD PTR [rbx+148], r12d
  0033b	74 12		 je	 SHORT $LN62@deflate

; 675  :                 putShortMSB(s, (uInt)(strm->adler >> 16));

  0033d	0f b7 57 4e	 movzx	 edx, WORD PTR [rdi+78]
  00341	e8 00 00 00 00	 call	 putShortMSB

; 676  :                 putShortMSB(s, (uInt)(strm->adler & 0xffff));

  00346	0f b7 57 4c	 movzx	 edx, WORD PTR [rdi+76]
  0034a	e8 00 00 00 00	 call	 putShortMSB
$LN62@deflate:

; 677  :             }
; 678  :             strm->adler = adler32(0L, Z_NULL, 0);

  0034f	45 33 c0	 xor	 r8d, r8d
  00352	33 d2		 xor	 edx, edx
  00354	33 c9		 xor	 ecx, ecx
  00356	e8 00 00 00 00	 call	 adler32
  0035b	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN71@deflate:

; 679  :         }
; 680  :     }
; 681  : #ifdef GZIP
; 682  :     if (s->status == EXTRA_STATE) {

  0035e	83 7b 08 45	 cmp	 DWORD PTR [rbx+8], 69	; 00000045H
  00362	0f 85 cb 00 00
	00		 jne	 $LN52@deflate

; 683  :         if (s->gzhead->extra != Z_NULL) {

  00368	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0036c	4c 39 60 10	 cmp	 QWORD PTR [rax+16], r12
  00370	0f 84 b6 00 00
	00		 je	 $LN60@deflate

; 684  :             uInt beg = s->pending;  /* start of bytes to update crc */
; 685  : 
; 686  :             while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {

  00376	0f b7 40 18	 movzx	 eax, WORD PTR [rax+24]
  0037a	44 8b 53 28	 mov	 r10d, DWORD PTR [rbx+40]
  0037e	39 43 38	 cmp	 DWORD PTR [rbx+56], eax
  00381	73 71		 jae	 SHORT $LN105@deflate
$LL59@deflate:

; 687  :                 if (s->pending == s->pending_buf_size) {

  00383	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  00386	3b 4b 18	 cmp	 ecx, DWORD PTR [rbx+24]
  00389	75 3a		 jne	 SHORT $LN55@deflate

; 688  :                     if (s->gzhead->hcrc && s->pending > beg)

  0038b	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0038f	44 39 60 3c	 cmp	 DWORD PTR [rax+60], r12d
  00393	74 1d		 je	 SHORT $LN56@deflate
  00395	41 3b ca	 cmp	 ecx, r10d
  00398	76 18		 jbe	 SHORT $LN56@deflate

; 689  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 690  :                                             s->pending - beg);

  0039a	41 2b ca	 sub	 ecx, r10d
  0039d	41 8b d2	 mov	 edx, r10d
  003a0	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  003a4	44 8b c1	 mov	 r8d, ecx
  003a7	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  003aa	e8 00 00 00 00	 call	 crc32
  003af	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN56@deflate:

; 691  :                     flush_pending(strm);

  003b2	48 8b cf	 mov	 rcx, rdi
  003b5	e8 00 00 00 00	 call	 flush_pending

; 692  :                     beg = s->pending;

  003ba	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  003bd	44 8b d1	 mov	 r10d, ecx

; 693  :                     if (s->pending == s->pending_buf_size)

  003c0	3b 4b 18	 cmp	 ecx, DWORD PTR [rbx+24]
  003c3	74 2f		 je	 SHORT $LN105@deflate
$LN55@deflate:

; 694  :                         break;
; 695  :                 }
; 696  :                 put_byte(s, s->gzhead->extra[s->gzindex]);

  003c5	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  003c9	44 8b 4b 38	 mov	 r9d, DWORD PTR [rbx+56]
  003cd	44 8b c1	 mov	 r8d, ecx
  003d0	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  003d4	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  003d8	41 0f b6 04 11	 movzx	 eax, BYTE PTR [r9+rdx]
  003dd	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
  003e1	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 697  :                 s->gzindex++;

  003e4	ff 43 38	 inc	 DWORD PTR [rbx+56]
  003e7	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  003eb	0f b7 48 18	 movzx	 ecx, WORD PTR [rax+24]
  003ef	39 4b 38	 cmp	 DWORD PTR [rbx+56], ecx
  003f2	72 8f		 jb	 SHORT $LL59@deflate
$LN105@deflate:

; 698  :             }
; 699  :             if (s->gzhead->hcrc && s->pending > beg)

  003f4	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  003f8	44 39 60 3c	 cmp	 DWORD PTR [rax+60], r12d
  003fc	74 1e		 je	 SHORT $LN54@deflate
  003fe	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00402	45 3b c2	 cmp	 r8d, r10d
  00405	76 15		 jbe	 SHORT $LN54@deflate

; 700  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 701  :                                     s->pending - beg);

  00407	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  0040a	41 8b d2	 mov	 edx, r10d
  0040d	45 2b c2	 sub	 r8d, r10d
  00410	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  00414	e8 00 00 00 00	 call	 crc32
  00419	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN54@deflate:

; 702  :             if (s->gzindex == s->gzhead->extra_len) {

  0041c	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00420	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00423	39 4b 38	 cmp	 DWORD PTR [rbx+56], ecx
  00426	75 0b		 jne	 SHORT $LN52@deflate

; 703  :                 s->gzindex = 0;

  00428	44 89 63 38	 mov	 DWORD PTR [rbx+56], r12d
$LN60@deflate:

; 704  :                 s->status = NAME_STATE;
; 705  :             }
; 706  :         }
; 707  :         else
; 708  :             s->status = NAME_STATE;

  0042c	c7 43 08 49 00
	00 00		 mov	 DWORD PTR [rbx+8], 73	; 00000049H
$LN52@deflate:

; 709  :     }
; 710  :     if (s->status == NAME_STATE) {

  00433	83 7b 08 49	 cmp	 DWORD PTR [rbx+8], 73	; 00000049H
  00437	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0043c	0f 85 b5 00 00
	00		 jne	 $LN41@deflate

; 711  :         if (s->gzhead->name != Z_NULL) {

  00442	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00446	4c 39 60 20	 cmp	 QWORD PTR [rax+32], r12
  0044a	0f 84 a0 00 00
	00		 je	 $LN50@deflate

; 712  :             uInt beg = s->pending;  /* start of bytes to update crc */

  00450	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
$LL49@deflate:

; 713  :             int val;
; 714  : 
; 715  :             do {
; 716  :                 if (s->pending == s->pending_buf_size) {

  00453	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00457	44 3b 43 18	 cmp	 r8d, DWORD PTR [rbx+24]
  0045b	75 38		 jne	 SHORT $LN44@deflate

; 717  :                     if (s->gzhead->hcrc && s->pending > beg)

  0045d	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00461	44 39 60 3c	 cmp	 DWORD PTR [rax+60], r12d
  00465	74 19		 je	 SHORT $LN45@deflate
  00467	44 3b c2	 cmp	 r8d, edx
  0046a	76 14		 jbe	 SHORT $LN45@deflate

; 718  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 719  :                                             s->pending - beg);

  0046c	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  0046f	44 2b c2	 sub	 r8d, edx
  00472	8b d2		 mov	 edx, edx
  00474	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  00478	e8 00 00 00 00	 call	 crc32
  0047d	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN45@deflate:

; 720  :                     flush_pending(strm);

  00480	48 8b cf	 mov	 rcx, rdi
  00483	e8 00 00 00 00	 call	 flush_pending

; 721  :                     beg = s->pending;

  00488	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  0048c	41 8b d0	 mov	 edx, r8d

; 722  :                     if (s->pending == s->pending_buf_size) {

  0048f	44 3b 43 18	 cmp	 r8d, DWORD PTR [rbx+24]
  00493	74 29		 je	 SHORT $LN102@deflate
$LN44@deflate:

; 724  :                         break;
; 725  :                     }
; 726  :                 }
; 727  :                 val = s->gzhead->name[s->gzindex++];

  00495	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  00498	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0049c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  004a0	0f b6 34 08	 movzx	 esi, BYTE PTR [rax+rcx]
  004a4	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]

; 728  :                 put_byte(s, val);

  004a7	41 8b c8	 mov	 ecx, r8d
  004aa	89 43 38	 mov	 DWORD PTR [rbx+56], eax
  004ad	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  004b1	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  004b5	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 729  :             } while (val != 0);

  004b8	85 f6		 test	 esi, esi
  004ba	75 97		 jne	 SHORT $LL49@deflate
  004bc	eb 05		 jmp	 SHORT $LN47@deflate
$LN102@deflate:

; 723  :                         val = 1;

  004be	be 01 00 00 00	 mov	 esi, 1
$LN47@deflate:

; 730  :             if (s->gzhead->hcrc && s->pending > beg)

  004c3	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  004c7	44 39 60 3c	 cmp	 DWORD PTR [rax+60], r12d
  004cb	74 1b		 je	 SHORT $LN43@deflate
  004cd	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  004d1	44 3b c2	 cmp	 r8d, edx
  004d4	76 12		 jbe	 SHORT $LN43@deflate

; 731  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 732  :                                     s->pending - beg);

  004d6	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  004d9	44 2b c2	 sub	 r8d, edx
  004dc	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  004e0	e8 00 00 00 00	 call	 crc32
  004e5	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN43@deflate:

; 733  :             if (val == 0) {

  004e8	85 f6		 test	 esi, esi
  004ea	75 0b		 jne	 SHORT $LN41@deflate

; 734  :                 s->gzindex = 0;

  004ec	44 89 63 38	 mov	 DWORD PTR [rbx+56], r12d
$LN50@deflate:

; 735  :                 s->status = COMMENT_STATE;
; 736  :             }
; 737  :         }
; 738  :         else
; 739  :             s->status = COMMENT_STATE;

  004f0	c7 43 08 5b 00
	00 00		 mov	 DWORD PTR [rbx+8], 91	; 0000005bH
$LN41@deflate:

; 740  :     }
; 741  :     if (s->status == COMMENT_STATE) {

  004f7	83 7b 08 5b	 cmp	 DWORD PTR [rbx+8], 91	; 0000005bH
  004fb	0f 85 b1 00 00
	00		 jne	 $LN30@deflate

; 742  :         if (s->gzhead->comment != Z_NULL) {

  00501	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00505	4c 39 60 30	 cmp	 QWORD PTR [rax+48], r12
  00509	0f 84 9c 00 00
	00		 je	 $LN39@deflate

; 743  :             uInt beg = s->pending;  /* start of bytes to update crc */

  0050f	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
$LL38@deflate:

; 744  :             int val;
; 745  : 
; 746  :             do {
; 747  :                 if (s->pending == s->pending_buf_size) {

  00512	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00516	44 3b 43 18	 cmp	 r8d, DWORD PTR [rbx+24]
  0051a	75 38		 jne	 SHORT $LN33@deflate

; 748  :                     if (s->gzhead->hcrc && s->pending > beg)

  0051c	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00520	44 39 60 3c	 cmp	 DWORD PTR [rax+60], r12d
  00524	74 19		 je	 SHORT $LN34@deflate
  00526	44 3b c2	 cmp	 r8d, edx
  00529	76 14		 jbe	 SHORT $LN34@deflate

; 749  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 750  :                                             s->pending - beg);

  0052b	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  0052e	44 2b c2	 sub	 r8d, edx
  00531	8b d2		 mov	 edx, edx
  00533	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  00537	e8 00 00 00 00	 call	 crc32
  0053c	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN34@deflate:

; 751  :                     flush_pending(strm);

  0053f	48 8b cf	 mov	 rcx, rdi
  00542	e8 00 00 00 00	 call	 flush_pending

; 752  :                     beg = s->pending;

  00547	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  0054b	41 8b d0	 mov	 edx, r8d

; 753  :                     if (s->pending == s->pending_buf_size) {

  0054e	44 3b 43 18	 cmp	 r8d, DWORD PTR [rbx+24]
  00552	74 29		 je	 SHORT $LN103@deflate
$LN33@deflate:

; 755  :                         break;
; 756  :                     }
; 757  :                 }
; 758  :                 val = s->gzhead->comment[s->gzindex++];

  00554	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  00557	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0055b	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0055f	0f b6 34 08	 movzx	 esi, BYTE PTR [rax+rcx]
  00563	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]

; 759  :                 put_byte(s, val);

  00566	41 8b c8	 mov	 ecx, r8d
  00569	89 43 38	 mov	 DWORD PTR [rbx+56], eax
  0056c	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00570	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  00574	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 760  :             } while (val != 0);

  00577	85 f6		 test	 esi, esi
  00579	75 97		 jne	 SHORT $LL38@deflate
  0057b	eb 05		 jmp	 SHORT $LN36@deflate
$LN103@deflate:

; 754  :                         val = 1;

  0057d	be 01 00 00 00	 mov	 esi, 1
$LN36@deflate:

; 761  :             if (s->gzhead->hcrc && s->pending > beg)

  00582	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00586	44 39 60 3c	 cmp	 DWORD PTR [rax+60], r12d
  0058a	74 1b		 je	 SHORT $LN32@deflate
  0058c	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00590	44 3b c2	 cmp	 r8d, edx
  00593	76 12		 jbe	 SHORT $LN32@deflate

; 762  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 763  :                                     s->pending - beg);

  00595	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  00598	44 2b c2	 sub	 r8d, edx
  0059b	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  0059f	e8 00 00 00 00	 call	 crc32
  005a4	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN32@deflate:

; 764  :             if (val == 0)

  005a7	85 f6		 test	 esi, esi
  005a9	75 07		 jne	 SHORT $LN30@deflate
$LN39@deflate:

; 765  :                 s->status = HCRC_STATE;
; 766  :         }
; 767  :         else
; 768  :             s->status = HCRC_STATE;

  005ab	c7 43 08 67 00
	00 00		 mov	 DWORD PTR [rbx+8], 103	; 00000067H
$LN30@deflate:

; 769  :     }
; 770  :     if (s->status == HCRC_STATE) {

  005b2	83 7b 08 67	 cmp	 DWORD PTR [rbx+8], 103	; 00000067H
  005b6	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  005bb	75 5f		 jne	 SHORT $LN25@deflate

; 771  :         if (s->gzhead->hcrc) {

  005bd	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  005c1	44 39 60 3c	 cmp	 DWORD PTR [rax+60], r12d
  005c5	74 4e		 je	 SHORT $LN28@deflate

; 772  :             if (s->pending + 2 > s->pending_buf_size)

  005c7	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  005ca	83 c0 02	 add	 eax, 2
  005cd	3b 43 18	 cmp	 eax, DWORD PTR [rbx+24]
  005d0	76 08		 jbe	 SHORT $LN27@deflate

; 773  :                 flush_pending(strm);

  005d2	48 8b cf	 mov	 rcx, rdi
  005d5	e8 00 00 00 00	 call	 flush_pending
$LN27@deflate:

; 774  :             if (s->pending + 2 <= s->pending_buf_size) {

  005da	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  005dd	8d 41 02	 lea	 eax, DWORD PTR [rcx+2]
  005e0	3b 43 18	 cmp	 eax, DWORD PTR [rbx+24]
  005e3	77 37		 ja	 SHORT $LN25@deflate

; 775  :                 put_byte(s, (Byte)(strm->adler & 0xff));

  005e5	0f b6 47 4c	 movzx	 eax, BYTE PTR [rdi+76]
  005e9	8b d1		 mov	 edx, ecx
  005eb	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  005ef	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  005f2	ff 43 28	 inc	 DWORD PTR [rbx+40]
  005f5	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 776  :                 put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  005f8	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  005fc	0f b6 47 4d	 movzx	 eax, BYTE PTR [rdi+77]

; 777  :                 strm->adler = crc32(0L, Z_NULL, 0);

  00600	45 33 c0	 xor	 r8d, r8d
  00603	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00606	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00609	33 d2		 xor	 edx, edx
  0060b	33 c9		 xor	 ecx, ecx
  0060d	e8 00 00 00 00	 call	 crc32
  00612	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN28@deflate:

; 778  :                 s->status = BUSY_STATE;
; 779  :             }
; 780  :         }
; 781  :         else
; 782  :             s->status = BUSY_STATE;

  00615	c7 43 08 71 00
	00 00		 mov	 DWORD PTR [rbx+8], 113	; 00000071H
$LN25@deflate:

; 783  :     }
; 784  : #endif
; 785  : 
; 786  :     /* Flush as much pending output as possible */
; 787  :     if (s->pending != 0) {

  0061c	44 39 63 28	 cmp	 DWORD PTR [rbx+40], r12d
  00620	74 29		 je	 SHORT $LN24@deflate

; 788  :         flush_pending(strm);

  00622	48 8b cf	 mov	 rcx, rdi
  00625	e8 00 00 00 00	 call	 flush_pending

; 789  :         if (strm->avail_out == 0) {

  0062a	44 39 67 18	 cmp	 DWORD PTR [rdi+24], r12d
  0062e	75 2b		 jne	 SHORT $LN21@deflate
$LN110@deflate:

; 790  :             /* Since avail_out is 0, deflate will be called again with
; 791  :              * more output space, but possibly with both pending and
; 792  :              * avail_in equal to zero. There won't be anything to do,
; 793  :              * but this is not an error situation so make sure we
; 794  :              * return OK instead of BUF_ERROR at next call of deflate:
; 795  :              */
; 796  :             s->last_flush = -1;

  00630	c7 43 40 ff ff
	ff ff		 mov	 DWORD PTR [rbx+64], -1
$LN13@deflate:

; 797  :             return Z_OK;

  00637	33 c0		 xor	 eax, eax
$LN107@deflate:
  00639	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  0063e	4c 8b 6c 24 50	 mov	 r13, QWORD PTR [rsp+80]

; 892  : }

  00643	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00647	5f		 pop	 rdi
  00648	5d		 pop	 rbp
  00649	5b		 pop	 rbx
  0064a	c3		 ret	 0
$LN24@deflate:

; 798  :         }
; 799  : 
; 800  :     /* Make sure there is something to do and avoid duplicate consecutive
; 801  :      * flushes. For repeated and useless calls with Z_FINISH, we keep
; 802  :      * returning Z_STREAM_END instead of Z_BUF_ERROR.
; 803  :      */
; 804  :     } else if (strm->avail_in == 0 && flush <= old_flush &&
; 805  :                flush != Z_FINISH) {

  0064b	44 39 67 08	 cmp	 DWORD PTR [rdi+8], r12d
  0064f	75 0a		 jne	 SHORT $LN21@deflate
  00651	41 3b ed	 cmp	 ebp, r13d
  00654	7f 05		 jg	 SHORT $LN21@deflate
  00656	83 fd 04	 cmp	 ebp, 4

; 806  :         ERR_RETURN(strm, Z_BUF_ERROR);

  00659	75 10		 jne	 SHORT $LN111@deflate
$LN21@deflate:

; 807  :     }
; 808  : 
; 809  :     /* User must not provide more input after the first FINISH: */
; 810  :     if (s->status == FINISH_STATE && strm->avail_in != 0) {

  0065b	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  0065e	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  00663	75 18		 jne	 SHORT $LN20@deflate
  00665	44 39 67 08	 cmp	 DWORD PTR [rdi+8], r12d
  00669	74 18		 je	 SHORT $LN109@deflate
$LN111@deflate:

; 811  :         ERR_RETURN(strm, Z_BUF_ERROR);

  0066b	48 8b 05 38 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+56
  00672	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00676	b8 fb ff ff ff	 mov	 eax, -5
  0067b	eb bc		 jmp	 SHORT $LN107@deflate
$LN20@deflate:

; 812  :     }
; 813  : 
; 814  :     /* Start a new block or continue the current one.
; 815  :      */
; 816  :     if (strm->avail_in != 0 || s->lookahead != 0 ||
; 817  :         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {

  0067d	44 39 67 08	 cmp	 DWORD PTR [rdi+8], r12d
  00681	75 1c		 jne	 SHORT $LN18@deflate
$LN109@deflate:
  00683	44 39 a3 9c 00
	00 00		 cmp	 DWORD PTR [rbx+156], r12d
  0068a	75 13		 jne	 SHORT $LN18@deflate
  0068c	85 ed		 test	 ebp, ebp
  0068e	0f 84 e2 00 00
	00		 je	 $LN6@deflate
  00694	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  00699	0f 84 d7 00 00
	00		 je	 $LN6@deflate
$LN18@deflate:

; 818  :         block_state bstate;
; 819  : 
; 820  :         bstate = s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
; 821  :                     (s->strategy == Z_RLE ? deflate_rle(s, flush) :
; 822  :                         (*(configuration_table[s->level].func))(s, flush));

  0069f	8b 83 b0 00 00
	00		 mov	 eax, DWORD PTR [rbx+176]
  006a5	8b d5		 mov	 edx, ebp
  006a7	48 8b cb	 mov	 rcx, rbx
  006aa	83 f8 02	 cmp	 eax, 2
  006ad	75 07		 jne	 SHORT $LN96@deflate
  006af	e8 00 00 00 00	 call	 deflate_huff
  006b4	eb 21		 jmp	 SHORT $LN95@deflate
$LN96@deflate:
  006b6	83 f8 03	 cmp	 eax, 3
  006b9	75 07		 jne	 SHORT $LN94@deflate
  006bb	e8 00 00 00 00	 call	 deflate_rle
  006c0	eb 15		 jmp	 SHORT $LN95@deflate
$LN94@deflate:
  006c2	48 63 83 ac 00
	00 00		 movsxd	 rax, DWORD PTR [rbx+172]
  006c9	4c 8d 05 08 00
	00 00		 lea	 r8, OFFSET FLAT:configuration_table+8
  006d0	48 03 c0	 add	 rax, rax
  006d3	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
$LN95@deflate:

; 823  : 
; 824  :         if (bstate == finish_started || bstate == finish_done) {

  006d7	83 f8 02	 cmp	 eax, 2
  006da	74 05		 je	 SHORT $LN16@deflate
  006dc	83 f8 03	 cmp	 eax, 3
  006df	75 07		 jne	 SHORT $LN17@deflate
$LN16@deflate:

; 825  :             s->status = FINISH_STATE;

  006e1	c7 43 08 9a 02
	00 00		 mov	 DWORD PTR [rbx+8], 666	; 0000029aH
$LN17@deflate:

; 826  :         }
; 827  :         if (bstate == need_more || bstate == finish_started) {

  006e8	85 c0		 test	 eax, eax
  006ea	0f 84 6e 01 00
	00		 je	 $LN14@deflate
  006f0	83 f8 02	 cmp	 eax, 2
  006f3	0f 84 65 01 00
	00		 je	 $LN14@deflate

; 832  :             /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
; 833  :              * of deflate should use the same flush parameter to make sure
; 834  :              * that the flush is complete. So we don't have to output an
; 835  :              * empty block here, this will be done at next call. This also
; 836  :              * ensures that for a very small output buffer, we emit at most
; 837  :              * one empty block.
; 838  :              */
; 839  :         }
; 840  :         if (bstate == block_done) {

  006f9	83 f8 01	 cmp	 eax, 1
  006fc	0f 85 74 00 00
	00		 jne	 $LN6@deflate

; 841  :             if (flush == Z_PARTIAL_FLUSH) {

  00702	3b e8		 cmp	 ebp, eax
  00704	75 0a		 jne	 SHORT $LN11@deflate

; 842  :                 _tr_align(s);

  00706	48 8b cb	 mov	 rcx, rbx
  00709	e8 00 00 00 00	 call	 _tr_align
  0070e	eb 54		 jmp	 SHORT $LN7@deflate
$LN11@deflate:

; 843  :             } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

  00710	83 fd 05	 cmp	 ebp, 5
  00713	74 4f		 je	 SHORT $LN7@deflate

; 844  :                 _tr_stored_block(s, (char*)0, 0L, 0);

  00715	45 33 c9	 xor	 r9d, r9d
  00718	45 33 c0	 xor	 r8d, r8d
  0071b	33 d2		 xor	 edx, edx
  0071d	48 8b cb	 mov	 rcx, rbx
  00720	e8 00 00 00 00	 call	 _tr_stored_block

; 845  :                 /* For a full flush, this empty block will be recognized
; 846  :                  * as a special marker by inflate_sync().
; 847  :                  */
; 848  :                 if (flush == Z_FULL_FLUSH) {

  00725	83 fd 03	 cmp	 ebp, 3
  00728	75 3a		 jne	 SHORT $LN7@deflate

; 849  :                     CLEAR_HASH(s);             /* forget history */

  0072a	8b 4b 74	 mov	 ecx, DWORD PTR [rbx+116]
  0072d	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00731	33 d2		 xor	 edx, edx
  00733	ff c9		 dec	 ecx
  00735	66 44 89 24 48	 mov	 WORD PTR [rax+rcx*2], r12w
  0073a	44 8b 43 74	 mov	 r8d, DWORD PTR [rbx+116]
  0073e	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00742	41 ff c8	 dec	 r8d
  00745	4d 03 c0	 add	 r8, r8
  00748	e8 00 00 00 00	 call	 memset

; 850  :                     if (s->lookahead == 0) {

  0074d	44 39 a3 9c 00
	00 00		 cmp	 DWORD PTR [rbx+156], r12d
  00754	75 0e		 jne	 SHORT $LN7@deflate

; 851  :                         s->strstart = 0;

  00756	44 89 a3 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r12d

; 852  :                         s->block_start = 0L;

  0075d	44 89 a3 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r12d
$LN7@deflate:

; 853  :                     }
; 854  :                 }
; 855  :             }
; 856  :             flush_pending(strm);

  00764	48 8b cf	 mov	 rcx, rdi
  00767	e8 00 00 00 00	 call	 flush_pending

; 857  :             if (strm->avail_out == 0) {

  0076c	44 39 67 18	 cmp	 DWORD PTR [rdi+24], r12d

; 858  :               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
; 859  :               return Z_OK;

  00770	0f 84 ba fe ff
	ff		 je	 $LN110@deflate
$LN6@deflate:

; 860  :             }
; 861  :         }
; 862  :     }
; 863  :     Assert(strm->avail_out > 0, "bug2");
; 864  : 
; 865  :     if (flush != Z_FINISH) return Z_OK;

  00776	83 fd 04	 cmp	 ebp, 4
  00779	0f 85 b8 fe ff
	ff		 jne	 $LN13@deflate

; 866  :     if (s->wrap <= 0) return Z_STREAM_END;

  0077f	8b 4b 2c	 mov	 ecx, DWORD PTR [rbx+44]
  00782	85 c9		 test	 ecx, ecx
  00784	7f 08		 jg	 SHORT $LN4@deflate
  00786	8d 45 fd	 lea	 eax, QWORD PTR [rbp-3]
  00789	e9 ab fe ff ff	 jmp	 $LN107@deflate
$LN4@deflate:

; 867  : 
; 868  :     /* Write the trailer */
; 869  : #ifdef GZIP
; 870  :     if (s->wrap == 2) {

  0078e	83 f9 02	 cmp	 ecx, 2
  00791	0f 85 8a 00 00
	00		 jne	 $LN3@deflate

; 871  :         put_byte(s, (Byte)(strm->adler & 0xff));

  00797	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  0079a	0f b6 47 4c	 movzx	 eax, BYTE PTR [rdi+76]
  0079e	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  007a2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  007a5	ff 43 28	 inc	 DWORD PTR [rbx+40]
  007a8	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 872  :         put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  007ab	0f b6 47 4d	 movzx	 eax, BYTE PTR [rdi+77]
  007af	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  007b3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  007b6	ff 43 28	 inc	 DWORD PTR [rbx+40]
  007b9	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 873  :         put_byte(s, (Byte)((strm->adler >> 16) & 0xff));

  007bc	0f b6 47 4e	 movzx	 eax, BYTE PTR [rdi+78]
  007c0	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  007c4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  007c7	ff 43 28	 inc	 DWORD PTR [rbx+40]
  007ca	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 874  :         put_byte(s, (Byte)((strm->adler >> 24) & 0xff));

  007cd	0f b6 47 4f	 movzx	 eax, BYTE PTR [rdi+79]
  007d1	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  007d5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  007d8	ff 43 28	 inc	 DWORD PTR [rbx+40]
  007db	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 875  :         put_byte(s, (Byte)(strm->total_in & 0xff));

  007de	0f b6 47 0c	 movzx	 eax, BYTE PTR [rdi+12]
  007e2	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  007e6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  007e9	ff 43 28	 inc	 DWORD PTR [rbx+40]
  007ec	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 876  :         put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));

  007ef	0f b6 47 0d	 movzx	 eax, BYTE PTR [rdi+13]
  007f3	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  007f7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  007fa	ff 43 28	 inc	 DWORD PTR [rbx+40]
  007fd	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 877  :         put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));

  00800	0f b6 47 0e	 movzx	 eax, BYTE PTR [rdi+14]
  00804	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00808	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0080b	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0080e	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]

; 878  :         put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));

  00811	0f b6 47 0f	 movzx	 eax, BYTE PTR [rdi+15]
  00815	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00819	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0081c	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 879  :     }
; 880  :     else

  0081f	eb 15		 jmp	 SHORT $LN2@deflate
$LN3@deflate:

; 881  : #endif
; 882  :     {
; 883  :         putShortMSB(s, (uInt)(strm->adler >> 16));

  00821	0f b7 57 4e	 movzx	 edx, WORD PTR [rdi+78]
  00825	48 8b cb	 mov	 rcx, rbx
  00828	e8 00 00 00 00	 call	 putShortMSB

; 884  :         putShortMSB(s, (uInt)(strm->adler & 0xffff));

  0082d	0f b7 57 4c	 movzx	 edx, WORD PTR [rdi+76]
  00831	e8 00 00 00 00	 call	 putShortMSB
$LN2@deflate:

; 885  :     }
; 886  :     flush_pending(strm);

  00836	48 8b cf	 mov	 rcx, rdi
  00839	e8 00 00 00 00	 call	 flush_pending

; 887  :     /* If avail_out is zero, the application will call deflate again
; 888  :      * to flush the rest.
; 889  :      */
; 890  :     if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */

  0083e	44 8b 5b 2c	 mov	 r11d, DWORD PTR [rbx+44]
  00842	45 85 db	 test	 r11d, r11d
  00845	7e 07		 jle	 SHORT $LN1@deflate
  00847	41 f7 db	 neg	 r11d
  0084a	44 89 5b 2c	 mov	 DWORD PTR [rbx+44], r11d
$LN1@deflate:

; 891  :     return s->pending != 0 ? Z_OK : Z_STREAM_END;

  0084e	44 39 63 28	 cmp	 DWORD PTR [rbx+40], r12d
  00852	41 0f 94 c4	 sete	 r12b
  00856	41 8b c4	 mov	 eax, r12d
  00859	e9 db fd ff ff	 jmp	 $LN107@deflate
$LN14@deflate:

; 828  :             if (strm->avail_out == 0) {

  0085e	44 39 67 18	 cmp	 DWORD PTR [rdi+24], r12d
  00862	0f 85 cf fd ff
	ff		 jne	 $LN13@deflate

; 829  :                 s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
; 830  :             }
; 831  :             return Z_OK;

  00868	e9 c3 fd ff ff	 jmp	 $LN110@deflate
$LN80@deflate:

; 598  :         ERR_RETURN(strm, Z_STREAM_ERROR);

  0086d	48 8b 05 20 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+32
  00874	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN82@deflate:
  00878	b8 fe ff ff ff	 mov	 eax, -2

; 892  : }

  0087d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00881	5f		 pop	 rdi
  00882	5d		 pop	 rbp
  00883	5b		 pop	 rbx
  00884	c3		 ret	 0
deflate	ENDP
_TEXT	ENDS
PUBLIC	deflateInit2_
EXTRN	zcfree:PROC
EXTRN	zcalloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateInit2_ DD imagerel $LN22
	DD	imagerel $LN22+91
	DD	imagerel $unwind$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$deflateInit2_ DD imagerel $LN22+91
	DD	imagerel $LN22+271
	DD	imagerel $chain$1$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$deflateInit2_ DD imagerel $LN22+271
	DD	imagerel $LN22+567
	DD	imagerel $chain$2$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflateInit2_ DD imagerel $LN22+567
	DD	imagerel $LN22+589
	DD	imagerel $chain$3$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$deflateInit2_ DD imagerel $LN22+589
	DD	imagerel $LN22+622
	DD	imagerel $chain$5$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$deflateInit2_ DD imagerel $LN22+622
	DD	imagerel $LN22+629
	DD	imagerel $chain$6$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$deflateInit2_ DD imagerel $LN22+629
	DD	imagerel $LN22+646
	DD	imagerel $chain$7$deflateInit2_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$deflateInit2_ DD 021H
	DD	imagerel $LN22
	DD	imagerel $LN22+91
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$deflateInit2_ DD 040021H
	DD	0cf400H
	DD	0bc400H
	DD	imagerel $LN22
	DD	imagerel $LN22+91
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$deflateInit2_ DD 060021H
	DD	0cf400H
	DD	0bc400H
	DD	0a6400H
	DD	imagerel $LN22
	DD	imagerel $LN22+91
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflateInit2_ DD 021H
	DD	imagerel $LN22+91
	DD	imagerel $LN22+271
	DD	imagerel $chain$1$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$deflateInit2_ DD 020521H
	DD	0a6405H
	DD	imagerel $LN22+91
	DD	imagerel $LN22+271
	DD	imagerel $chain$1$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$deflateInit2_ DD 046421H
	DD	0bc464H
	DD	0cf405H
	DD	imagerel $LN22
	DD	imagerel $LN22+91
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit2_ DD 060c01H
	DD	0e008320cH
	DD	07004d006H
	DD	030025003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT deflateInit2_
_TEXT	SEGMENT
strm$ = 80
level$ = 88
method$ = 96
windowBits$ = 104
memLevel$ = 112
strategy$ = 120
version$ = 128
stream_size$ = 136
deflateInit2_ PROC					; COMDAT

; 220  : {

$LN22:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	41 55		 push	 r13
  00006	41 56		 push	 r14
  00008	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 221  :     deflate_state *s;
; 222  :     int wrap = 1;
; 223  :     static const char my_version[] = ZLIB_VERSION;
; 224  : 
; 225  :     ushf *overlay;
; 226  :     /* We overlay pending_buf and d_buf+l_buf. This works since the average
; 227  :      * output size for (length,distance) codes is <= 24 bits.
; 228  :      */
; 229  : 
; 230  :     if (version == Z_NULL || version[0] != my_version[0] ||
; 231  :         stream_size != sizeof(z_stream)) {

  0000c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR version$[rsp]
  00014	41 be 01 00 00
	00		 mov	 r14d, 1
  0001a	41 8b f9	 mov	 edi, r9d
  0001d	8b ea		 mov	 ebp, edx
  0001f	48 8b d9	 mov	 rbx, rcx
  00022	45 8b ee	 mov	 r13d, r14d
  00025	48 85 c0	 test	 rax, rax
  00028	0f 84 47 02 00
	00		 je	 $LN14@deflateIni
  0002e	80 38 31	 cmp	 BYTE PTR [rax], 49	; 00000031H
  00031	0f 85 3e 02 00
	00		 jne	 $LN14@deflateIni
  00037	83 bc 24 88 00
	00 00 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  0003f	0f 85 30 02 00
	00		 jne	 $LN14@deflateIni

; 233  :     }
; 234  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00045	48 85 c9	 test	 rcx, rcx
  00048	75 0f		 jne	 SHORT $LN13@deflateIni
  0004a	8d 41 fe	 lea	 eax, QWORD PTR [rcx-2]

; 308  : }

  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	41 5e		 pop	 r14
  00053	41 5d		 pop	 r13
  00055	5f		 pop	 rdi
  00056	5d		 pop	 rbp
  00057	5b		 pop	 rbx
  00058	c3		 ret	 0
$LN13@deflateIni:

; 235  : 
; 236  :     strm->msg = Z_NULL;

  00059	33 d2		 xor	 edx, edx
  0005b	4c 89 7c 24 60	 mov	 QWORD PTR [rsp+96], r15
  00060	48 89 51 20	 mov	 QWORD PTR [rcx+32], rdx

; 237  :     if (strm->zalloc == (alloc_func)0) {

  00064	48 39 51 30	 cmp	 QWORD PTR [rcx+48], rdx
  00068	75 0f		 jne	 SHORT $LN12@deflateIni

; 238  :         strm->zalloc = zcalloc;

  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 239  :         strm->opaque = (voidpf)0;

  00071	48 89 51 40	 mov	 QWORD PTR [rcx+64], rdx
  00075	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN12@deflateIni:

; 240  :     }
; 241  :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  00079	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zcfree
  00084	48 3b c2	 cmp	 rax, rdx
  00087	48 0f 44 c1	 cmove	 rax, rcx

; 242  : 
; 243  : #ifdef FASTEST
; 244  :     if (level != 0) level = 1;
; 245  : #else
; 246  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;

  0008b	83 fd ff	 cmp	 ebp, -1
  0008e	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
  00092	b8 06 00 00 00	 mov	 eax, 6
  00097	0f 44 e8	 cmove	 ebp, eax

; 247  : #endif
; 248  : 
; 249  :     if (windowBits < 0) { /* suppress zlib wrapper */

  0009a	45 85 c9	 test	 r9d, r9d
  0009d	79 07		 jns	 SHORT $LN9@deflateIni

; 250  :         wrap = 0;

  0009f	44 8b ea	 mov	 r13d, edx

; 251  :         windowBits = -windowBits;

  000a2	f7 df		 neg	 edi
  000a4	eb 0f		 jmp	 SHORT $LN7@deflateIni
$LN9@deflateIni:

; 252  :     }
; 253  : #ifdef GZIP
; 254  :     else if (windowBits > 15) {

  000a6	41 83 f9 0f	 cmp	 r9d, 15
  000aa	7e 09		 jle	 SHORT $LN7@deflateIni

; 255  :         wrap = 2;       /* write gzip wrapper instead */

  000ac	41 bd 02 00 00
	00		 mov	 r13d, 2

; 256  :         windowBits -= 16;

  000b2	83 ef 10	 sub	 edi, 16
$LN7@deflateIni:

; 257  :     }
; 258  : #endif
; 259  :     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
; 260  :         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
; 261  :         strategy < 0 || strategy > Z_FIXED) {

  000b5	44 8b 7c 24 70	 mov	 r15d, DWORD PTR memLevel$[rsp]
  000ba	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12
  000bf	41 8d 47 ff	 lea	 eax, DWORD PTR [r15-1]
  000c3	83 f8 08	 cmp	 eax, 8
  000c6	0f 87 a2 01 00
	00		 ja	 $LN5@deflateIni
  000cc	41 83 f8 08	 cmp	 r8d, 8
  000d0	0f 85 98 01 00
	00		 jne	 $LN5@deflateIni
  000d6	8d 47 f8	 lea	 eax, DWORD PTR [rdi-8]
  000d9	83 f8 07	 cmp	 eax, 7
  000dc	0f 87 8c 01 00
	00		 ja	 $LN5@deflateIni
  000e2	83 fd 09	 cmp	 ebp, 9
  000e5	0f 87 83 01 00
	00		 ja	 $LN5@deflateIni
  000eb	44 8b 64 24 78	 mov	 r12d, DWORD PTR strategy$[rsp]
  000f0	41 83 fc 04	 cmp	 r12d, 4
  000f4	0f 87 74 01 00
	00		 ja	 $LN5@deflateIni

; 263  :     }
; 264  :     if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
; 265  :     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));

  000fa	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000fe	41 3b f8	 cmp	 edi, r8d
  00101	b8 09 00 00 00	 mov	 eax, 9
  00106	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  0010c	41 8b d6	 mov	 edx, r14d
  0010f	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  00114	0f 44 f8	 cmove	 edi, eax
  00117	ff 53 30	 call	 QWORD PTR [rbx+48]
  0011a	48 8b f0	 mov	 rsi, rax

; 266  :     if (s == Z_NULL) return Z_MEM_ERROR;

  0011d	48 85 c0	 test	 rax, rax
  00120	0f 84 41 01 00
	00		 je	 $LN21@deflateIni

; 267  :     strm->state = (struct internal_state FAR *)s;

  00126	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 268  :     s->strm = strm;
; 269  : 
; 270  :     s->wrap = wrap;

  0012a	44 89 68 2c	 mov	 DWORD PTR [rax+44], r13d
  0012e	48 89 18	 mov	 QWORD PTR [rax], rbx

; 271  :     s->gzhead = Z_NULL;
; 272  :     s->w_bits = windowBits;

  00131	89 78 48	 mov	 DWORD PTR [rax+72], edi

; 273  :     s->w_size = 1 << s->w_bits;

  00134	8b cf		 mov	 ecx, edi
  00136	45 33 ed	 xor	 r13d, r13d
  00139	4c 89 68 30	 mov	 QWORD PTR [rax+48], r13
  0013d	45 8b ce	 mov	 r9d, r14d

; 274  :     s->w_mask = s->w_size - 1;
; 275  : 
; 276  :     s->hash_bits = memLevel + 7;
; 277  :     s->hash_size = 1 << s->hash_bits;
; 278  :     s->hash_mask = s->hash_size - 1;
; 279  :     s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
; 280  : 
; 281  :     s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));

  00140	45 8d 45 02	 lea	 r8d, QWORD PTR [r13+2]
  00144	41 d3 e1	 shl	 r9d, cl
  00147	41 8d 4f 07	 lea	 ecx, DWORD PTR [r15+7]
  0014b	44 89 48 44	 mov	 DWORD PTR [rax+68], r9d
  0014f	41 8d 41 ff	 lea	 eax, DWORD PTR [r9-1]
  00153	89 4e 78	 mov	 DWORD PTR [rsi+120], ecx
  00156	89 46 4c	 mov	 DWORD PTR [rsi+76], eax
  00159	41 8b c6	 mov	 eax, r14d
  0015c	d3 e0		 shl	 eax, cl
  0015e	83 c1 02	 add	 ecx, 2
  00161	89 46 74	 mov	 DWORD PTR [rsi+116], eax
  00164	ff c8		 dec	 eax
  00166	89 46 7c	 mov	 DWORD PTR [rsi+124], eax
  00169	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0016e	f7 e1		 mul	 ecx
  00170	d1 ea		 shr	 edx, 1
  00172	89 96 80 00 00
	00		 mov	 DWORD PTR [rsi+128], edx
  00178	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0017c	41 8b d1	 mov	 edx, r9d
  0017f	ff 53 30	 call	 QWORD PTR [rbx+48]

; 282  :     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));

  00182	8b 56 44	 mov	 edx, DWORD PTR [rsi+68]
  00185	45 8d 45 02	 lea	 r8d, QWORD PTR [r13+2]
  00189	48 89 46 50	 mov	 QWORD PTR [rsi+80], rax
  0018d	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00191	ff 53 30	 call	 QWORD PTR [rbx+48]

; 283  :     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

  00194	8b 56 74	 mov	 edx, DWORD PTR [rsi+116]
  00197	45 8d 45 02	 lea	 r8d, QWORD PTR [r13+2]
  0019b	48 89 46 60	 mov	 QWORD PTR [rsi+96], rax
  0019f	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  001a3	ff 53 30	 call	 QWORD PTR [rbx+48]

; 284  : 
; 285  :     s->high_water = 0;      /* nothing written to s->window yet */
; 286  : 
; 287  :     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  001a6	41 8d 4f 06	 lea	 ecx, DWORD PTR [r15+6]
  001aa	44 89 ae 18 17
	00 00		 mov	 DWORD PTR [rsi+5912], r13d
  001b1	41 d3 e6	 shl	 r14d, cl
  001b4	48 89 46 68	 mov	 QWORD PTR [rsi+104], rax

; 288  : 
; 289  :     overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);

  001b8	45 8d 45 04	 lea	 r8d, QWORD PTR [r13+4]
  001bc	44 89 b6 f0 16
	00 00		 mov	 DWORD PTR [rsi+5872], r14d
  001c3	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  001c7	41 8b d6	 mov	 edx, r14d
  001ca	ff 53 30	 call	 QWORD PTR [rbx+48]
  001cd	4c 8b d8	 mov	 r11, rax

; 290  :     s->pending_buf = (uchf *) overlay;

  001d0	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax

; 291  :     s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

  001d4	8b 86 f0 16 00
	00		 mov	 eax, DWORD PTR [rsi+5872]
  001da	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [rax*4]
  001e1	89 4e 18	 mov	 DWORD PTR [rsi+24], ecx

; 292  : 
; 293  :     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
; 294  :         s->pending_buf == Z_NULL) {

  001e4	4c 39 6e 50	 cmp	 QWORD PTR [rsi+80], r13
  001e8	74 63		 je	 SHORT $LN1@deflateIni
  001ea	4c 39 6e 60	 cmp	 QWORD PTR [rsi+96], r13
  001ee	74 5d		 je	 SHORT $LN1@deflateIni
  001f0	4c 39 6e 68	 cmp	 QWORD PTR [rsi+104], r13
  001f4	74 57		 je	 SHORT $LN1@deflateIni
  001f6	4d 85 db	 test	 r11, r11
  001f9	74 52		 je	 SHORT $LN1@deflateIni

; 299  :     }
; 300  :     s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  001fb	8b c8		 mov	 ecx, eax
  001fd	48 d1 e8	 shr	 rax, 1

; 301  :     s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
; 302  : 
; 303  :     s->level = level;

  00200	89 ae ac 00 00
	00		 mov	 DWORD PTR [rsi+172], ebp
  00206	49 8d 04 43	 lea	 rax, QWORD PTR [r11+rax*2]

; 304  :     s->strategy = strategy;

  0020a	44 89 a6 b0 00
	00 00		 mov	 DWORD PTR [rsi+176], r12d

; 305  :     s->method = (Byte)method;

  00211	c6 46 3c 08	 mov	 BYTE PTR [rsi+60], 8
  00215	48 89 86 f8 16
	00 00		 mov	 QWORD PTR [rsi+5880], rax
  0021c	49 8d 04 4b	 lea	 rax, QWORD PTR [r11+rcx*2]
  00220	48 03 c8	 add	 rcx, rax
  00223	48 89 8e e8 16
	00 00		 mov	 QWORD PTR [rsi+5864], rcx

; 306  : 
; 307  :     return deflateReset(strm);

  0022a	48 8b cb	 mov	 rcx, rbx
  0022d	e8 00 00 00 00	 call	 deflateReset
$LN20@deflateIni:
  00232	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
$LN19@deflateIni:
  00237	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]
  0023c	4c 8b 7c 24 60	 mov	 r15, QWORD PTR [rsp+96]

; 308  : }

  00241	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00245	41 5e		 pop	 r14
  00247	41 5d		 pop	 r13
  00249	5f		 pop	 rdi
  0024a	5d		 pop	 rbp
  0024b	5b		 pop	 rbx
  0024c	c3		 ret	 0
$LN1@deflateIni:

; 295  :         s->status = FINISH_STATE;

  0024d	c7 46 08 9a 02
	00 00		 mov	 DWORD PTR [rsi+8], 666	; 0000029aH

; 296  :         strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);

  00254	48 8b 05 30 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+48

; 297  :         deflateEnd (strm);

  0025b	48 8b cb	 mov	 rcx, rbx
  0025e	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  00262	e8 00 00 00 00	 call	 deflateEnd
$LN21@deflateIni:

; 298  :         return Z_MEM_ERROR;

  00267	b8 fc ff ff ff	 mov	 eax, -4
  0026c	eb c4		 jmp	 SHORT $LN20@deflateIni
$LN5@deflateIni:

; 262  :         return Z_STREAM_ERROR;

  0026e	b8 fe ff ff ff	 mov	 eax, -2
  00273	eb c2		 jmp	 SHORT $LN19@deflateIni
$LN14@deflateIni:

; 232  :         return Z_VERSION_ERROR;

  00275	b8 fa ff ff ff	 mov	 eax, -6

; 308  : }

  0027a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0027e	41 5e		 pop	 r14
  00280	41 5d		 pop	 r13
  00282	5f		 pop	 rdi
  00283	5d		 pop	 rbp
  00284	5b		 pop	 rbx
  00285	c3		 ret	 0
deflateInit2_ ENDP
_TEXT	ENDS
PUBLIC	deflateParams
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateParams DD imagerel $LN13
	DD	imagerel $LN13+84
	DD	imagerel $unwind$deflateParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$deflateParams DD imagerel $LN13+84
	DD	imagerel $LN13+248
	DD	imagerel $chain$0$deflateParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$deflateParams DD imagerel $LN13+248
	DD	imagerel $LN13+269
	DD	imagerel $chain$1$deflateParams
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$deflateParams DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+84
	DD	imagerel $unwind$deflateParams
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$deflateParams DD 020521H
	DD	065405H
	DD	imagerel $LN13
	DD	imagerel $LN13+84
	DD	imagerel $unwind$deflateParams
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateParams DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT deflateParams
_TEXT	SEGMENT
strm$ = 48
level$ = 56
strategy$ = 64
deflateParams PROC					; COMDAT

; 416  : {

$LN13:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	41 8b f0	 mov	 esi, r8d

; 417  :     deflate_state *s;
; 418  :     compress_func func;
; 419  :     int err = Z_OK;

  00012	45 33 c0	 xor	 r8d, r8d
  00015	8b da		 mov	 ebx, edx
  00017	4c 8b c9	 mov	 r9, rcx

; 420  : 
; 421  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0001a	48 85 c9	 test	 rcx, rcx
  0001d	0f 84 d5 00 00
	00		 je	 $LN7@deflatePar
  00023	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  00027	48 85 ff	 test	 rdi, rdi
  0002a	0f 84 c8 00 00
	00		 je	 $LN7@deflatePar

; 422  :     s = strm->state;
; 423  : 
; 424  : #ifdef FASTEST
; 425  :     if (level != 0) level = 1;
; 426  : #else
; 427  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;

  00030	83 fa ff	 cmp	 edx, -1
  00033	75 05		 jne	 SHORT $LN6@deflatePar
  00035	8d 5a 07	 lea	 ebx, QWORD PTR [rdx+7]

; 428  : #endif
; 429  :     if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {

  00038	eb 11		 jmp	 SHORT $LN12@deflatePar
$LN6@deflatePar:
  0003a	85 d2		 test	 edx, edx
  0003c	0f 88 b6 00 00
	00		 js	 $LN7@deflatePar
  00042	83 fa 09	 cmp	 edx, 9
  00045	0f 8f ad 00 00
	00		 jg	 $LN7@deflatePar
$LN12@deflatePar:
  0004b	83 fe 04	 cmp	 esi, 4
  0004e	0f 87 a4 00 00
	00		 ja	 $LN7@deflatePar

; 430  :         return Z_STREAM_ERROR;
; 431  :     }
; 432  :     func = configuration_table[s->level].func;
; 433  : 
; 434  :     if ((strategy != s->strategy || func != configuration_table[level].func) &&
; 435  :         strm->total_in != 0) {

  00054	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00059	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:configuration_table
  00060	3b b7 b0 00 00
	00		 cmp	 esi, DWORD PTR [rdi+176]
  00066	75 1c		 jne	 SHORT $LN2@deflatePar
  00068	48 63 8f ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rdi+172]
  0006f	48 63 c3	 movsxd	 rax, ebx
  00072	48 03 c0	 add	 rax, rax
  00075	48 03 c9	 add	 rcx, rcx
  00078	48 8b 44 c5 08	 mov	 rax, QWORD PTR [rbp+rax*8+8]
  0007d	48 39 44 cd 08	 cmp	 QWORD PTR [rbp+rcx*8+8], rax
  00082	74 16		 je	 SHORT $LN3@deflatePar
$LN2@deflatePar:
  00084	45 39 41 0c	 cmp	 DWORD PTR [r9+12], r8d
  00088	74 10		 je	 SHORT $LN3@deflatePar

; 436  :         /* Flush the last buffer: */
; 437  :         err = deflate(strm, Z_BLOCK);

  0008a	ba 05 00 00 00	 mov	 edx, 5
  0008f	49 8b c9	 mov	 rcx, r9
  00092	e8 00 00 00 00	 call	 deflate
  00097	44 8b c0	 mov	 r8d, eax
$LN3@deflatePar:

; 438  :     }
; 439  :     if (s->level != level) {

  0009a	39 9f ac 00 00
	00		 cmp	 DWORD PTR [rdi+172], ebx
  000a0	74 38		 je	 SHORT $LN1@deflatePar

; 440  :         s->level = level;

  000a2	89 9f ac 00 00
	00		 mov	 DWORD PTR [rdi+172], ebx

; 441  :         s->max_lazy_match   = configuration_table[level].max_lazy;

  000a8	48 63 d3	 movsxd	 rdx, ebx
  000ab	48 03 d2	 add	 rdx, rdx
  000ae	0f b7 4c d5 02	 movzx	 ecx, WORD PTR [rbp+rdx*8+2]
  000b3	89 8f a8 00 00
	00		 mov	 DWORD PTR [rdi+168], ecx

; 442  :         s->good_match       = configuration_table[level].good_length;

  000b9	0f b7 44 d5 00	 movzx	 eax, WORD PTR [rbp+rdx*8]
  000be	89 87 b4 00 00
	00		 mov	 DWORD PTR [rdi+180], eax

; 443  :         s->nice_match       = configuration_table[level].nice_length;

  000c4	0f b7 44 d5 04	 movzx	 eax, WORD PTR [rbp+rdx*8+4]
  000c9	89 87 b8 00 00
	00		 mov	 DWORD PTR [rdi+184], eax

; 444  :         s->max_chain_length = configuration_table[level].max_chain;

  000cf	0f b7 44 d5 06	 movzx	 eax, WORD PTR [rbp+rdx*8+6]
  000d4	89 87 a4 00 00
	00		 mov	 DWORD PTR [rdi+164], eax
$LN1@deflatePar:

; 445  :     }
; 446  :     s->strategy = strategy;

  000da	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  000df	89 b7 b0 00 00
	00		 mov	 DWORD PTR [rdi+176], esi

; 447  :     return err;

  000e5	41 8b c0	 mov	 eax, r8d

; 448  : }

  000e8	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000ed	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000f2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f6	5f		 pop	 rdi
  000f7	c3		 ret	 0
$LN7@deflatePar:
  000f8	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000fd	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00102	b8 fe ff ff ff	 mov	 eax, -2
  00107	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010b	5f		 pop	 rdi
  0010c	c3		 ret	 0
deflateParams ENDP
_TEXT	ENDS
PUBLIC	deflateInit_
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateInit_ DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$deflateInit_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit_ DD 010401H
	DD	08204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT deflateInit_
_TEXT	SEGMENT
strm$ = 80
level$ = 88
version$ = 96
stream_size$ = 104
deflateInit_ PROC					; COMDAT

; 203  : {

$LN3:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 204  :     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
; 205  :                          Z_DEFAULT_STRATEGY, version, stream_size);

  00004	44 89 4c 24 38	 mov	 DWORD PTR [rsp+56], r9d
  00009	4c 89 44 24 30	 mov	 QWORD PTR [rsp+48], r8
  0000e	41 b9 0f 00 00
	00		 mov	 r9d, 15
  00014	45 8d 41 f9	 lea	 r8d, QWORD PTR [r9-7]
  00018	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00020	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  00028	e8 00 00 00 00	 call	 deflateInit2_

; 206  :     /* To do: ignore strm->next_in if we use it as window */
; 207  : }

  0002d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00031	c3		 ret	 0
deflateInit_ ENDP
_TEXT	ENDS
END
