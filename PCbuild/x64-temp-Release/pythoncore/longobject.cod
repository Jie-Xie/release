; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@EJLIILFJ@sys?4int_info?$AA@		; `string'
PUBLIC	??_C@_0DG@LNJMIEPA@size?5in?5bytes?5of?5the?5C?5type?5used@ ; `string'
PUBLIC	??_C@_0N@IECNJPGN@sizeof_digit?$AA@		; `string'
PUBLIC	??_C@_0BI@LACMDNDE@size?5of?5a?5digit?5in?5bits?$AA@ ; `string'
PUBLIC	??_C@_0P@FEHGIBKA@bits_per_digit?$AA@		; `string'
PUBLIC	??_C@_03JBIPMCLC@int?$AA@			; `string'
PUBLIC	??_C@_0DF@LGNICKCI@the?5denominator?5of?5a?5rational?5nu@ ; `string'
PUBLIC	??_C@_0M@LLLKACAC@denominator?$AA@		; `string'
PUBLIC	??_C@_0DD@BMEDFGDO@the?5numerator?5of?5a?5rational?5numb@ ; `string'
PUBLIC	??_C@_09KDGIKBGN@numerator?$AA@			; `string'
PUBLIC	??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@ ; `string'
PUBLIC	??_C@_04HBKGOHH@imag?$AA@			; `string'
PUBLIC	??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@ ; `string'
PUBLIC	??_C@_04DGGKDJMA@real?$AA@			; `string'
PUBLIC	??_C@_0CB@JHJAIPOI@Returns?5size?5in?5memory?0?5in?5bytes@ ; `string'
PUBLIC	??_C@_0L@HOGGIPGN@__sizeof__?$AA@		; `string'
PUBLIC	??_C@_0L@MEMCGMKL@__format__?$AA@		; `string'
PUBLIC	??_C@_0P@BCBHENLA@__getnewargs__?$AA@		; `string'
PUBLIC	??_C@_0GA@KJCBPGNO@Rounding?5an?5Integral?5returns?5its@ ; `string'
PUBLIC	??_C@_09PJGAHDBG@__round__?$AA@			; `string'
PUBLIC	??_C@_0CH@CCENPBPG@Ceiling?5of?5an?5Integral?5returns?5i@ ; `string'
PUBLIC	??_C@_08GFGNDJJM@__ceil__?$AA@			; `string'
PUBLIC	??_C@_0CF@ODDNPKME@Flooring?5an?5Integral?5returns?5its@ ; `string'
PUBLIC	??_C@_09NKCGFGFE@__floor__?$AA@			; `string'
PUBLIC	??_C@_0CH@PIJCOPCL@Truncating?5an?5Integral?5returns?5i@ ; `string'
PUBLIC	??_C@_09KENBLPCG@__trunc__?$AA@			; `string'
PUBLIC	??_C@_0L@NMKBBNFG@from_bytes?$AA@		; `string'
PUBLIC	??_C@_08HHECGKBL@to_bytes?$AA@			; `string'
PUBLIC	??_C@_0L@PKHLKCCO@bit_length?$AA@		; `string'
PUBLIC	??_C@_0DA@INOKAKKF@Returns?5self?0?5the?5complex?5conjug@ ; `string'
PUBLIC	??_C@_09PHMNDPIK@conjugate?$AA@			; `string'
PUBLIC	??_C@_05FBJAGGIG@bytes?$AA@			; `string'
PUBLIC	??_C@_06CPIODIKA@signed?$AA@			; `string'
PUBLIC	??_C@_09PJBCLGKJ@byteorder?$AA@			; `string'
PUBLIC	??_C@_06IJDLPEM@length?$AA@			; `string'
PUBLIC	??_C@_04BHIIPFEC@base?$AA@			; `string'
PUBLIC	??_C@_01FJMABOPO@x?$AA@				; `string'
PUBLIC	_PyLong_DigitValue
PUBLIC	PyLong_Type
EXTRN	PyObject_Free:PROC
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	PyType_Type:BYTE
_BSS	SEGMENT
?log_base_BASE@?6??PyLong_FromString@@9@9 DQ 025H DUP (?) ; `PyLong_FromString'::`7'::log_base_BASE
?convwidth_base@?6??PyLong_FromString@@9@9 DD 025H DUP (?) ; `PyLong_FromString'::`7'::convwidth_base
	ALIGN	8

?convmultmax_base@?6??PyLong_FromString@@9@9 DQ 025H DUP (?) ; `PyLong_FromString'::`7'::convmultmax_base
_BSS	ENDS
;	COMDAT ??_C@_0N@EJLIILFJ@sys?4int_info?$AA@
CONST	SEGMENT
??_C@_0N@EJLIILFJ@sys?4int_info?$AA@ DB 'sys.int_info', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@LNJMIEPA@size?5in?5bytes?5of?5the?5C?5type?5used@
CONST	SEGMENT
??_C@_0DG@LNJMIEPA@size?5in?5bytes?5of?5the?5C?5type?5used@ DB 'size in b'
	DB	'ytes of the C type used to represent a digit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IECNJPGN@sizeof_digit?$AA@
CONST	SEGMENT
??_C@_0N@IECNJPGN@sizeof_digit?$AA@ DB 'sizeof_digit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LACMDNDE@size?5of?5a?5digit?5in?5bits?$AA@
CONST	SEGMENT
??_C@_0BI@LACMDNDE@size?5of?5a?5digit?5in?5bits?$AA@ DB 'size of a digit '
	DB	'in bits', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FEHGIBKA@bits_per_digit?$AA@
CONST	SEGMENT
??_C@_0P@FEHGIBKA@bits_per_digit?$AA@ DB 'bits_per_digit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBIPMCLC@int?$AA@
CONST	SEGMENT
??_C@_03JBIPMCLC@int?$AA@ DB 'int', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LGNICKCI@the?5denominator?5of?5a?5rational?5nu@
CONST	SEGMENT
??_C@_0DF@LGNICKCI@the?5denominator?5of?5a?5rational?5nu@ DB 'the denomin'
	DB	'ator of a rational number in lowest terms', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LLLKACAC@denominator?$AA@
CONST	SEGMENT
??_C@_0M@LLLKACAC@denominator?$AA@ DB 'denominator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@BMEDFGDO@the?5numerator?5of?5a?5rational?5numb@
CONST	SEGMENT
??_C@_0DD@BMEDFGDO@the?5numerator?5of?5a?5rational?5numb@ DB 'the numerat'
	DB	'or of a rational number in lowest terms', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KDGIKBGN@numerator?$AA@
CONST	SEGMENT
??_C@_09KDGIKBGN@numerator?$AA@ DB 'numerator', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@
CONST	SEGMENT
??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@ DB 'the imagin'
	DB	'ary part of a complex number', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HBKGOHH@imag?$AA@
CONST	SEGMENT
??_C@_04HBKGOHH@imag?$AA@ DB 'imag', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@
CONST	SEGMENT
??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@ DB 'the real pa'
	DB	'rt of a complex number', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DGGKDJMA@real?$AA@
CONST	SEGMENT
??_C@_04DGGKDJMA@real?$AA@ DB 'real', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JHJAIPOI@Returns?5size?5in?5memory?0?5in?5bytes@
CONST	SEGMENT
??_C@_0CB@JHJAIPOI@Returns?5size?5in?5memory?0?5in?5bytes@ DB 'Returns si'
	DB	'ze in memory, in bytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGGIPGN@__sizeof__?$AA@
CONST	SEGMENT
??_C@_0L@HOGGIPGN@__sizeof__?$AA@ DB '__sizeof__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MEMCGMKL@__format__?$AA@
CONST	SEGMENT
??_C@_0L@MEMCGMKL@__format__?$AA@ DB '__format__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BCBHENLA@__getnewargs__?$AA@
CONST	SEGMENT
??_C@_0P@BCBHENLA@__getnewargs__?$AA@ DB '__getnewargs__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@KJCBPGNO@Rounding?5an?5Integral?5returns?5its@
CONST	SEGMENT
??_C@_0GA@KJCBPGNO@Rounding?5an?5Integral?5returns?5its@ DB 'Rounding an '
	DB	'Integral returns itself.', 0aH, 'Rounding with an ndigits arg'
	DB	'ument also returns an integer.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PJGAHDBG@__round__?$AA@
CONST	SEGMENT
??_C@_09PJGAHDBG@__round__?$AA@ DB '__round__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CCENPBPG@Ceiling?5of?5an?5Integral?5returns?5i@
CONST	SEGMENT
??_C@_0CH@CCENPBPG@Ceiling?5of?5an?5Integral?5returns?5i@ DB 'Ceiling of '
	DB	'an Integral returns itself.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GFGNDJJM@__ceil__?$AA@
CONST	SEGMENT
??_C@_08GFGNDJJM@__ceil__?$AA@ DB '__ceil__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@ODDNPKME@Flooring?5an?5Integral?5returns?5its@
CONST	SEGMENT
??_C@_0CF@ODDNPKME@Flooring?5an?5Integral?5returns?5its@ DB 'Flooring an '
	DB	'Integral returns itself.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NKCGFGFE@__floor__?$AA@
CONST	SEGMENT
??_C@_09NKCGFGFE@__floor__?$AA@ DB '__floor__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PIJCOPCL@Truncating?5an?5Integral?5returns?5i@
CONST	SEGMENT
??_C@_0CH@PIJCOPCL@Truncating?5an?5Integral?5returns?5i@ DB 'Truncating a'
	DB	'n Integral returns itself.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KENBLPCG@__trunc__?$AA@
CONST	SEGMENT
??_C@_09KENBLPCG@__trunc__?$AA@ DB '__trunc__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NMKBBNFG@from_bytes?$AA@
CONST	SEGMENT
??_C@_0L@NMKBBNFG@from_bytes?$AA@ DB 'from_bytes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HHECGKBL@to_bytes?$AA@
CONST	SEGMENT
??_C@_08HHECGKBL@to_bytes?$AA@ DB 'to_bytes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PKHLKCCO@bit_length?$AA@
CONST	SEGMENT
??_C@_0L@PKHLKCCO@bit_length?$AA@ DB 'bit_length', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@INOKAKKF@Returns?5self?0?5the?5complex?5conjug@
CONST	SEGMENT
??_C@_0DA@INOKAKKF@Returns?5self?0?5the?5complex?5conjug@ DB 'Returns sel'
	DB	'f, the complex conjugate of any int.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PHMNDPIK@conjugate?$AA@
CONST	SEGMENT
??_C@_09PHMNDPIK@conjugate?$AA@ DB 'conjugate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FBJAGGIG@bytes?$AA@
CONST	SEGMENT
??_C@_05FBJAGGIG@bytes?$AA@ DB 'bytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CPIODIKA@signed?$AA@
CONST	SEGMENT
??_C@_06CPIODIKA@signed?$AA@ DB 'signed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PJBCLGKJ@byteorder?$AA@
CONST	SEGMENT
??_C@_09PJBCLGKJ@byteorder?$AA@ DB 'byteorder', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IJDLPEM@length?$AA@
CONST	SEGMENT
??_C@_06IJDLPEM@length?$AA@ DB 'length', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BHIIPFEC@base?$AA@
CONST	SEGMENT
??_C@_04BHIIPFEC@base?$AA@ DB 'base', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01FJMABOPO@x?$AA@
CONST	SEGMENT
??_C@_01FJMABOPO@x?$AA@ DB 'x', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
_PyLong_DigitValue DB 025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
	DB	025H
?kwlist@?1??long_new@@9@9 DQ FLAT:??_C@_01FJMABOPO@x?$AA@ ; `long_new'::`2'::kwlist
	DQ	FLAT:??_C@_04BHIIPFEC@base?$AA@
	DQ	0000000000000000H
	ORG $+8
long_bit_length_doc DB 'int.bit_length() -> int', 0aH, 0aH, 'Number of bi'
	DB	'ts necessary to represent self in binary.', 0aH, '>>> bin(37)'
	DB	0aH, '''0b100101''', 0aH, '>>> (37).bit_length()', 0aH, '6', 00H
	ORG $+2
?kwlist@?1??long_to_bytes@@9@9 DQ FLAT:??_C@_06IJDLPEM@length?$AA@ ; `long_to_bytes'::`2'::kwlist
	DQ	FLAT:??_C@_09PJBCLGKJ@byteorder?$AA@
	DQ	FLAT:??_C@_06CPIODIKA@signed?$AA@
	DQ	0000000000000000H
long_to_bytes_doc DB 'int.to_bytes(length, byteorder, *, signed=False) ->'
	DB	' bytes', 0aH, 0aH, 'Return an array of bytes representing an '
	DB	'integer.', 0aH, 0aH, 'The integer is represented using length'
	DB	' bytes.  An OverflowError is', 0aH, 'raised if the integer is'
	DB	' not representable with the given number of', 0aH, 'bytes.', 0aH
	DB	0aH, 'The byteorder argument determines the byte order used to'
	DB	' represent the', 0aH, 'integer.  If byteorder is ''big'', the'
	DB	' most significant byte is at the', 0aH, 'beginning of the byt'
	DB	'e array.  If byteorder is ''little'', the most', 0aH, 'signif'
	DB	'icant byte is at the end of the byte array.  To request the n'
	DB	'ative', 0aH, 'byte order of the host system, use `sys.byteord'
	DB	'er'' as the byte order value.', 0aH, 0aH, 'The signed keyword'
	DB	'-only argument determines whether two''s complement is', 0aH, 'u'
	DB	'sed to represent the integer.  If signed is False and a negat'
	DB	'ive integer', 0aH, 'is given, an OverflowError is raised.', 00H
	ORG $+7
?kwlist@?1??long_from_bytes@@9@9 DQ FLAT:??_C@_05FBJAGGIG@bytes?$AA@ ; `long_from_bytes'::`2'::kwlist
	DQ	FLAT:??_C@_09PJBCLGKJ@byteorder?$AA@
	DQ	FLAT:??_C@_06CPIODIKA@signed?$AA@
	DQ	0000000000000000H
long_from_bytes_doc DB 'int.from_bytes(bytes, byteorder, *, signed=False)'
	DB	' -> int', 0aH, 0aH, 'Return the integer represented by the gi'
	DB	'ven array of bytes.', 0aH, 0aH, 'The bytes argument must eith'
	DB	'er support the buffer protocol or be an', 0aH, 'iterable obje'
	DB	'ct producing bytes.  Bytes and bytearray are examples of', 0aH
	DB	'built-in objects that support the buffer protocol.', 0aH, 0aH
	DB	'The byteorder argument determines the byte order used to repr'
	DB	'esent the', 0aH, 'integer.  If byteorder is ''big'', the most'
	DB	' significant byte is at the', 0aH, 'beginning of the byte arr'
	DB	'ay.  If byteorder is ''little'', the most', 0aH, 'significant'
	DB	' byte is at the end of the byte array.  To request the native'
	DB	0aH, 'byte order of the host system, use `sys.byteorder'' as t'
	DB	'he byte order value.', 0aH, 0aH, 'The signed keyword-only arg'
	DB	'ument indicates whether two''s complement is', 0aH, 'used to '
	DB	'represent the integer.', 00H
	ORG $+2
long_methods DQ	FLAT:??_C@_09PHMNDPIK@conjugate?$AA@
	DQ	FLAT:long_long
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DA@INOKAKKF@Returns?5self?0?5the?5complex?5conjug@
	DQ	FLAT:??_C@_0L@PKHLKCCO@bit_length?$AA@
	DQ	FLAT:long_bit_length
	DD	04H
	ORG $+4
	DQ	FLAT:long_bit_length_doc
	DQ	FLAT:??_C@_08HHECGKBL@to_bytes?$AA@
	DQ	FLAT:long_to_bytes
	DD	03H
	ORG $+4
	DQ	FLAT:long_to_bytes_doc
	DQ	FLAT:??_C@_0L@NMKBBNFG@from_bytes?$AA@
	DQ	FLAT:long_from_bytes
	DD	013H
	ORG $+4
	DQ	FLAT:long_from_bytes_doc
	DQ	FLAT:??_C@_09KENBLPCG@__trunc__?$AA@
	DQ	FLAT:long_long
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CH@PIJCOPCL@Truncating?5an?5Integral?5returns?5i@
	DQ	FLAT:??_C@_09NKCGFGFE@__floor__?$AA@
	DQ	FLAT:long_long
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CF@ODDNPKME@Flooring?5an?5Integral?5returns?5its@
	DQ	FLAT:??_C@_08GFGNDJJM@__ceil__?$AA@
	DQ	FLAT:long_long
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CH@CCENPBPG@Ceiling?5of?5an?5Integral?5returns?5i@
	DQ	FLAT:??_C@_09PJGAHDBG@__round__?$AA@
	DQ	FLAT:long_round
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0GA@KJCBPGNO@Rounding?5an?5Integral?5returns?5its@
	DQ	FLAT:??_C@_0P@BCBHENLA@__getnewargs__?$AA@
	DQ	FLAT:long_getnewargs
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0L@MEMCGMKL@__format__?$AA@
	DQ	FLAT:long__format__
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:long_sizeof
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CB@JHJAIPOI@Returns?5size?5in?5memory?0?5in?5bytes@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
long_getset DQ	FLAT:??_C@_04DGGKDJMA@real?$AA@
	DQ	FLAT:long_long
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@
	DQ	0000000000000000H
	DQ	FLAT:??_C@_04HBKGOHH@imag?$AA@
	DQ	FLAT:long_get0
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@
	DQ	0000000000000000H
	DQ	FLAT:??_C@_09KDGIKBGN@numerator?$AA@
	DQ	FLAT:long_long
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0DD@BMEDFGDO@the?5numerator?5of?5a?5rational?5numb@
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0M@LLLKACAC@denominator?$AA@
	DQ	FLAT:long_get1
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0DF@LGNICKCI@the?5denominator?5of?5a?5rational?5nu@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
long_doc DB	'int(x=0) -> integer', 0aH, 'int(x, base=10) -> integer', 0aH
	DB	0aH, 'Convert a number or string to an integer, or return 0 if'
	DB	' no arguments', 0aH, 'are given.  If x is a number, return x.'
	DB	'__int__().  For floating point', 0aH, 'numbers, this truncate'
	DB	's towards zero.', 0aH, 0aH, 'If x is not a number or if base '
	DB	'is given, then x must be a string,', 0aH, 'bytes, or bytearra'
	DB	'y instance representing an integer literal in the', 0aH, 'giv'
	DB	'en base.  The literal can be preceded by ''+'' or ''-'' and b'
	DB	'e surrounded', 0aH, 'by whitespace.  The base defaults to 10.'
	DB	'  Valid bases are 0 and 2-36.', 0aH, 'Base 0 means to interpr'
	DB	'et the base from the string as an integer literal.', 0aH, '>>'
	DB	'> int(''0b100'', base=0)', 0aH, '4', 00H
	ORG $+2
long_as_number DQ FLAT:long_add
	DQ	FLAT:long_sub
	DQ	FLAT:long_mul
	DQ	FLAT:long_mod
	DQ	FLAT:long_divmod
	DQ	FLAT:long_pow
	DQ	FLAT:long_neg
	DQ	FLAT:long_long
	DQ	FLAT:long_abs
	DQ	FLAT:long_bool
	DQ	FLAT:long_invert
	DQ	FLAT:long_lshift
	DQ	FLAT:long_rshift
	DQ	FLAT:long_and
	DQ	FLAT:long_xor
	DQ	FLAT:long_or
	DQ	FLAT:long_long
	DQ	0000000000000000H
	DQ	FLAT:long_float
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:long_div
	DQ	FLAT:long_true_divide
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:long_long
PyLong_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_03JBIPMCLC@int?$AA@
	DQ	0000000000000070H
	DQ	0000000000000004H
	DQ	FLAT:long_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:long_to_decimal_string
	DQ	FLAT:long_as_number
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:long_hash
	DQ	0000000000000000H
	DQ	FLAT:long_to_decimal_string
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	01040400H
	ORG $+4
	DQ	FLAT:long_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:long_richcompare
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:long_methods
	DQ	0000000000000000H
	DQ	FLAT:long_getset
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:long_new
	DQ	FLAT:PyObject_Free
	ORG $+64
int_info__doc__ DB 'sys.int_info', 0aH, 0aH, 'A struct sequence that hold'
	DB	's information about Python''s', 0aH, 'internal representation'
	DB	' of integers.  The attributes are read only.', 00H
	ORG $+6
int_info_fields DQ FLAT:??_C@_0P@FEHGIBKA@bits_per_digit?$AA@
	DQ	FLAT:??_C@_0BI@LACMDNDE@size?5of?5a?5digit?5in?5bits?$AA@
	DQ	FLAT:??_C@_0N@IECNJPGN@sizeof_digit?$AA@
	DQ	FLAT:??_C@_0DG@LNJMIEPA@size?5in?5bytes?5of?5the?5C?5type?5used@
	DQ	0000000000000000H
	DQ	0000000000000000H
int_info_desc DQ FLAT:??_C@_0N@EJLIILFJ@sys?4int_info?$AA@
	DQ	FLAT:int_info__doc__
	DQ	FLAT:int_info_fields
	DD	02H
	ORG $+4
_DATA	ENDS
CONST	SEGMENT
BitLengthTable DB 00H
	DB	01H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
?half_even_correction@?1??_PyLong_Frexp@@9@9 DD 00H	; `_PyLong_Frexp'::`2'::half_even_correction
	DD	0ffffffffH
	DD	0fffffffeH
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	02H
	DD	01H
CONST	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\include\objimpl.h
_TEXT	ENDS
;	COMDAT _PyObject_InitHead
_TEXT	SEGMENT
op$ = 8
_PyObject_InitHead PROC					; COMDAT

; 216  :     assert(Py_TYPE(op));
; 217  :     op->is_px = _Py_NOT_PARALLEL;

  00000	48 ba 78 56 ef
	be 34 12 ad de	 mov	 rdx, -2401243008567650696 ; dead1234beef5678H

; 218  :     op->px    = _Py_NOT_PARALLEL;
; 219  :     op->slist_entry.Next = NULL;

  0000a	33 c0		 xor	 eax, eax

; 220  :     op->px_flags  = Py_PXFLAGS_ISPY;

  0000c	48 c7 41 20 01
	00 00 00	 mov	 QWORD PTR [rcx+32], 1
  00014	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00017	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  0001b	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 221  :     op->srw_lock  = NULL;

  0001f	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 222  :     op->event     = NULL;

  00023	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 223  :     op->orig_type = NULL;

  00027	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 224  : #ifdef Py_TRACE_REFS
; 225  :     op->_ob_next = NULL;
; 226  :     op->_ob_prev = NULL;
; 227  : #else
; 228  :     op->_ob_next = _Py_NOT_PARALLEL;

  0002b	48 89 51 40	 mov	 QWORD PTR [rcx+64], rdx

; 229  :     op->_ob_prev = _Py_NOT_PARALLEL;

  0002f	48 89 51 48	 mov	 QWORD PTR [rcx+72], rdx

; 230  : #endif
; 231  : }

  00033	c3		 ret	 0
_PyObject_InitHead ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@JKHPLOII@PyObject_INIT?$AA@		; `string'
PUBLIC	??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@ ; `string'
EXTRN	_Px_NewReference:PROC
EXTRN	_PxObject_Init:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_INIT DD imagerel PyObject_INIT
	DD	imagerel PyObject_INIT+185
	DD	imagerel $unwind$PyObject_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_INIT DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0O@JKHPLOII@PyObject_INIT?$AA@
CONST	SEGMENT
??_C@_0O@JKHPLOII@PyObject_INIT?$AA@ DB 'PyObject_INIT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@
CONST	SEGMENT
??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@ DB 'c:\src\pypa'
	DB	'rallel\include\objimpl.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_INIT
_TEXT	SEGMENT
op$ = 64
tp$ = 72
PyObject_INIT PROC					; COMDAT

; 236  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 237  :     Px_RETURN(_PxObject_Init(op, tp))

  00010	e8 00 00 00 00	 call	 _Py_PXCTX
  00015	85 c0		 test	 eax, eax
  00017	74 15		 je	 SHORT $LN1@PyObject_I
  00019	48 8b d7	 mov	 rdx, rdi
  0001c	48 8b cb	 mov	 rcx, rbx

; 242  : }

  0001f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00024	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00028	5f		 pop	 rdi
  00029	e9 00 00 00 00	 jmp	 _PxObject_Init
$LN1@PyObject_I:

; 238  :     Py_TYPE(op) = tp;
; 239  :     _PyObject_InitHead(op);

  0002e	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00038	33 c0		 xor	 eax, eax

; 240  :     _Py_NewReference(op);

  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@
  00041	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  00044	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx
  00048	48 89 4b 40	 mov	 QWORD PTR [rbx+64], rcx
  0004c	48 89 4b 48	 mov	 QWORD PTR [rbx+72], rcx
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@JKHPLOII@PyObject_INIT?$AA@
  00057	4c 8b cb	 mov	 r9, rbx
  0005a	41 b8 f0 00 00
	00		 mov	 r8d, 240		; 000000f0H
  00060	48 89 7b 58	 mov	 QWORD PTR [rbx+88], rdi
  00064	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
  00068	48 c7 43 20 01
	00 00 00	 mov	 QWORD PTR [rbx+32], 1
  00070	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  00074	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax
  00078	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
  0007c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00084	e8 00 00 00 00	 call	 _PyParallel_Guard
  00089	85 c0		 test	 eax, eax
  0008b	74 16		 je	 SHORT $LN4@PyObject_I
  0008d	48 8b cb	 mov	 rcx, rbx
  00090	e8 00 00 00 00	 call	 _Px_NewReference

; 241  :     return op;

  00095	48 8b c3	 mov	 rax, rbx

; 242  : }

  00098	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a1	5f		 pop	 rdi
  000a2	c3		 ret	 0
$LN4@PyObject_I:

; 240  :     _Py_NewReference(op);

  000a3	48 c7 43 50 01
	00 00 00	 mov	 QWORD PTR [rbx+80], 1

; 241  :     return op;

  000ab	48 8b c3	 mov	 rax, rbx

; 242  : }

  000ae	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
PyObject_INIT ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@PCKAICOI@PyObject_INIT_VAR?$AA@	; `string'
EXTRN	_PxObject_InitVar:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_INIT_VAR DD imagerel PyObject_INIT_VAR
	DD	imagerel PyObject_INIT_VAR+215
	DD	imagerel $unwind$PyObject_INIT_VAR
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_INIT_VAR DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0BC@PCKAICOI@PyObject_INIT_VAR?$AA@
CONST	SEGMENT
??_C@_0BC@PCKAICOI@PyObject_INIT_VAR?$AA@ DB 'PyObject_INIT_VAR', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_INIT_VAR
_TEXT	SEGMENT
op$ = 64
tp$ = 72
n$ = 80
PyObject_INIT_VAR PROC					; COMDAT

; 247  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 248  :     Px_RETURN(_PxObject_InitVar(op, tp, n))

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1d		 je	 SHORT $LN1@PyObject_I@2
  00021	4c 8b c7	 mov	 r8, rdi
  00024	48 8b d6	 mov	 rdx, rsi
  00027	48 8b cb	 mov	 rcx, rbx

; 254  : }

  0002a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0002f	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00034	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00038	5f		 pop	 rdi
  00039	e9 00 00 00 00	 jmp	 _PxObject_InitVar
$LN1@PyObject_I@2:

; 249  :     Py_SIZE(op) = n;
; 250  :     Py_TYPE(op) = tp;
; 251  :     _PyObject_InitHead((PyObject *)op);

  0003e	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00048	33 c0		 xor	 eax, eax

; 252  :     _Py_NewReference((PyObject *)op);

  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@
  00051	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  00054	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx
  00058	48 89 4b 40	 mov	 QWORD PTR [rbx+64], rcx
  0005c	48 89 4b 48	 mov	 QWORD PTR [rbx+72], rcx
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@PCKAICOI@PyObject_INIT_VAR?$AA@
  00067	4c 8b cb	 mov	 r9, rbx
  0006a	41 b8 fc 00 00
	00		 mov	 r8d, 252		; 000000fcH
  00070	48 89 7b 60	 mov	 QWORD PTR [rbx+96], rdi
  00074	48 89 73 58	 mov	 QWORD PTR [rbx+88], rsi
  00078	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
  0007c	48 c7 43 20 01
	00 00 00	 mov	 QWORD PTR [rbx+32], 1
  00084	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  00088	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax
  0008c	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
  00090	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00098	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009d	85 c0		 test	 eax, eax
  0009f	74 1b		 je	 SHORT $LN4@PyObject_I@2
  000a1	48 8b cb	 mov	 rcx, rbx
  000a4	e8 00 00 00 00	 call	 _Px_NewReference

; 253  :     return op;

  000a9	48 8b c3	 mov	 rax, rbx

; 254  : }

  000ac	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b1	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
$LN4@PyObject_I@2:
  000bc	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000c1	48 c7 43 50 01
	00 00 00	 mov	 QWORD PTR [rbx+80], 1
  000c9	48 8b c3	 mov	 rax, rbx
  000cc	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d5	5f		 pop	 rdi
  000d6	c3		 ret	 0
PyObject_INIT_VAR ENDP
_TEXT	ENDS
_BSS	SEGMENT
small_ints DB	08300H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$get_small_int DD imagerel get_small_int
	DD	imagerel get_small_int+91
	DD	imagerel $unwind$get_small_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_small_int DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT get_small_int
_TEXT	SEGMENT
ival$ = 64
get_small_int PROC					; COMDAT

; 38   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 39   :     PyObject *v = (PyObject*)(small_ints + ival + NSMALLNEGINTS);

  00006	48 63 d9	 movsxd	 rbx, ecx
  00009	48 8d 05 80 02
	00 00		 lea	 rax, OFFSET FLAT:small_ints+640
  00010	48 c1 e3 07	 shl	 rbx, 7
  00014	48 03 d8	 add	 rbx, rax

; 40   :     Py_INCREF(v);

  00017	e8 00 00 00 00	 call	 _Py_PXCTX
  0001c	85 c0		 test	 eax, eax
  0001e	75 32		 jne	 SHORT $LN7@get_small_
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0002e	4c 8b cb	 mov	 r9, rbx
  00031	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00037	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0003f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00044	85 c0		 test	 eax, eax
  00046	75 06		 jne	 SHORT $LN3@get_small_
  00048	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0004c	74 04		 je	 SHORT $LN7@get_small_
$LN3@get_small_:
  0004e	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN7@get_small_:

; 41   : #ifdef COUNT_ALLOCS
; 42   :     if (ival >= 0)
; 43   :         quick_int_allocs++;
; 44   :     else
; 45   :         quick_neg_int_allocs++;
; 46   : #endif
; 47   :     return v;

  00052	48 8b c3	 mov	 rax, rbx

; 48   : }

  00055	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00059	5b		 pop	 rbx
  0005a	c3		 ret	 0
get_small_int ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$maybe_small_long DD imagerel maybe_small_long
	DD	imagerel maybe_small_long+107
	DD	imagerel $unwind$maybe_small_long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$maybe_small_long DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT maybe_small_long
_TEXT	SEGMENT
v$ = 48
maybe_small_long PROC					; COMDAT

; 56   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 57   :     if (v && ABS(Py_SIZE(v)) <= 1) {

  00006	48 85 c9	 test	 rcx, rcx
  00009	74 57		 je	 SHORT $LN1@maybe_smal
  0000b	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  0000f	48 8b d0	 mov	 rdx, rax
  00012	48 85 c0	 test	 rax, rax
  00015	79 03		 jns	 SHORT $LN6@maybe_smal
  00017	48 f7 da	 neg	 rdx
$LN6@maybe_smal:
  0001a	48 83 fa 01	 cmp	 rdx, 1
  0001e	7f 42		 jg	 SHORT $LN1@maybe_smal

; 58   :         sdigit ival = MEDIUM_VALUE(v);

  00020	48 85 c0	 test	 rax, rax
  00023	79 07		 jns	 SHORT $LN13@maybe_smal
  00025	8b 59 70	 mov	 ebx, DWORD PTR [rcx+112]
  00028	f7 db		 neg	 ebx
  0002a	eb 18		 jmp	 SHORT $LN8@maybe_smal
$LN13@maybe_smal:
  0002c	75 13		 jne	 SHORT $LN7@maybe_smal
  0002e	33 db		 xor	 ebx, ebx

; 60   :             Py_DECREF(v);

  00030	e8 00 00 00 00	 call	 _Py_DecRef

; 61   :             return (PyLongObject *)get_small_int(ival);

  00035	8b cb		 mov	 ecx, ebx

; 65   : }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	e9 00 00 00 00	 jmp	 get_small_int
$LN7@maybe_smal:

; 58   :         sdigit ival = MEDIUM_VALUE(v);

  00041	8b 59 70	 mov	 ebx, DWORD PTR [rcx+112]
$LN8@maybe_smal:

; 59   :         if (-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS) {

  00044	83 fb fb	 cmp	 ebx, -5
  00047	7c 19		 jl	 SHORT $LN1@maybe_smal
  00049	81 fb 01 01 00
	00		 cmp	 ebx, 257		; 00000101H
  0004f	7d 11		 jge	 SHORT $LN1@maybe_smal

; 60   :             Py_DECREF(v);

  00051	e8 00 00 00 00	 call	 _Py_DecRef

; 61   :             return (PyLongObject *)get_small_int(ival);

  00056	8b cb		 mov	 ecx, ebx

; 65   : }

  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5b		 pop	 rbx
  0005d	e9 00 00 00 00	 jmp	 get_small_int
$LN1@maybe_smal:

; 62   :         }
; 63   :     }
; 64   :     return v;

  00062	48 8b c1	 mov	 rax, rcx

; 65   : }

  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	5b		 pop	 rbx
  0006a	c3		 ret	 0
maybe_small_long ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT long_normalize
_TEXT	SEGMENT
v$ = 8
long_normalize PROC					; COMDAT

; 109  :     Py_ssize_t j = ABS(Py_SIZE(v));

  00000	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  00004	4d 8b c1	 mov	 r8, r9
  00007	4d 85 c9	 test	 r9, r9
  0000a	79 03		 jns	 SHORT $LN7@long_norma
  0000c	49 f7 d8	 neg	 r8
$LN7@long_norma:

; 110  :     Py_ssize_t i = j;

  0000f	49 8b c0	 mov	 rax, r8

; 111  : 
; 112  :     while (i > 0 && v->ob_digit[i-1] == 0)

  00012	4d 85 c0	 test	 r8, r8
  00015	7e 2b		 jle	 SHORT $LN13@long_norma

; 110  :     Py_ssize_t i = j;

  00017	4a 8d 54 81 6c	 lea	 rdx, QWORD PTR [rcx+r8*4+108]
  0001c	0f 1f 40 00	 npad	 4
$LL3@long_norma:

; 111  : 
; 112  :     while (i > 0 && v->ob_digit[i-1] == 0)

  00020	83 3a 00	 cmp	 DWORD PTR [rdx], 0
  00023	75 0c		 jne	 SHORT $LN2@long_norma

; 113  :         --i;

  00025	48 ff c8	 dec	 rax
  00028	48 83 ea 04	 sub	 rdx, 4
  0002c	48 85 c0	 test	 rax, rax
  0002f	7f ef		 jg	 SHORT $LL3@long_norma
$LN2@long_norma:

; 114  :     if (i != j)

  00031	49 3b c0	 cmp	 rax, r8
  00034	74 0c		 je	 SHORT $LN13@long_norma

; 115  :         Py_SIZE(v) = (Py_SIZE(v) < 0) ? -(i) : i;

  00036	4d 85 c9	 test	 r9, r9
  00039	79 03		 jns	 SHORT $LN8@long_norma
  0003b	48 f7 d8	 neg	 rax
$LN8@long_norma:
  0003e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
$LN13@long_norma:

; 116  :     return v;

  00042	48 8b c1	 mov	 rax, rcx

; 117  : }

  00045	c3		 ret	 0
long_normalize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@CAOECIFE@an?5integer?5is?5required?5?$CIgot?5type@ ; `string'
PUBLIC	??_C@_0CH@FBOPHEGH@__int__?5returned?5non?9int?5?$CItype?5?$CF@ ; `string'
PUBLIC	_PyLong_FromNbInt
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_PyLong_FromNbInt DD imagerel $LN14
	DD	imagerel $LN14+238
	DD	imagerel $unwind$_PyLong_FromNbInt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_FromNbInt DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0CJ@CAOECIFE@an?5integer?5is?5required?5?$CIgot?5type@
CONST	SEGMENT
??_C@_0CJ@CAOECIFE@an?5integer?5is?5required?5?$CIgot?5type@ DB 'an integ'
	DB	'er is required (got type %.200s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FBOPHEGH@__int__?5returned?5non?9int?5?$CItype?5?$CF@
CONST	SEGMENT
??_C@_0CH@FBOPHEGH@__int__?5returned?5non?9int?5?$CItype?5?$CF@ DB '__int'
	DB	'__ returned non-int (type %.200s)', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
CONST	ENDS
;	COMDAT _PyLong_FromNbInt
_TEXT	SEGMENT
integral$ = 64
_PyLong_FromNbInt PROC					; COMDAT

; 126  : {

$LN14:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 127  :     PyNumberMethods *nb;
; 128  :     PyObject *result;
; 129  : 
; 130  :     /* Fast path for the case that we already have an int. */
; 131  :     if (PyLong_CheckExact(integral)) {

  0000a	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  0000e	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:PyLong_Type
  00015	48 8b d9	 mov	 rbx, rcx
  00018	4c 3b c7	 cmp	 r8, rdi
  0001b	75 49		 jne	 SHORT $LN6@PyLong_Fro

; 132  :         Py_INCREF(integral);

  0001d	e8 00 00 00 00	 call	 _Py_PXCTX
  00022	85 c0		 test	 eax, eax
  00024	75 32		 jne	 SHORT $LN10@PyLong_Fro
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00034	4c 8b cb	 mov	 r9, rbx
  00037	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0003d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00045	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004a	85 c0		 test	 eax, eax
  0004c	75 06		 jne	 SHORT $LN9@PyLong_Fro
  0004e	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00052	74 04		 je	 SHORT $LN10@PyLong_Fro
$LN9@PyLong_Fro:
  00054	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN10@PyLong_Fro:

; 133  :         return (PyLongObject *)integral;

  00058	48 8b c3	 mov	 rax, rbx

; 154  :         return NULL;
; 155  :     }
; 156  :     return (PyLongObject *)result;
; 157  : }

  0005b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
$LN6@PyLong_Fro:

; 134  :     }
; 135  : 
; 136  :     nb = Py_TYPE(integral)->tp_as_number;

  00066	49 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [r8+184]

; 137  :     if (nb == NULL || nb->nb_int == NULL) {

  0006d	48 85 c0	 test	 rax, rax
  00070	74 58		 je	 SHORT $LN4@PyLong_Fro
  00072	48 8b 90 80 00
	00 00		 mov	 rdx, QWORD PTR [rax+128]
  00079	48 85 d2	 test	 rdx, rdx
  0007c	74 4c		 je	 SHORT $LN4@PyLong_Fro

; 142  :     }
; 143  : 
; 144  :     /* Convert using the nb_int slot, which should return something
; 145  :        of exact type int. */
; 146  :     result = nb->nb_int(integral);

  0007e	ff d2		 call	 rdx
  00080	48 8b d8	 mov	 rbx, rax

; 147  :     if (!result || PyLong_CheckExact(result))

  00083	48 85 c0	 test	 rax, rax
  00086	74 5b		 je	 SHORT $LN7@PyLong_Fro
  00088	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  0008c	4c 3b c7	 cmp	 r8, rdi
  0008f	74 52		 je	 SHORT $LN7@PyLong_Fro

; 148  :         return (PyLongObject *)result;
; 149  :     if (!PyLong_Check(result)) {

  00091	41 f7 80 00 01
	00 00 00 00 00
	01		 test	 DWORD PTR [r8+256], 16777216 ; 01000000H
  0009c	75 45		 jne	 SHORT $LN7@PyLong_Fro

; 150  :         PyErr_Format(PyExc_TypeError,
; 151  :                      "__int__ returned non-int (type %.200s)",
; 152  :                      result->ob_type->tp_name);

  0009e	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000a2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@FBOPHEGH@__int__?5returned?5non?9int?5?$CItype?5?$CF@
  000b0	e8 00 00 00 00	 call	 PyErr_Format

; 153  :         Py_DECREF(result);

  000b5	48 8b cb	 mov	 rcx, rbx
  000b8	e8 00 00 00 00	 call	 _Py_DecRef
  000bd	33 c0		 xor	 eax, eax

; 154  :         return NULL;
; 155  :     }
; 156  :     return (PyLongObject *)result;
; 157  : }

  000bf	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c8	5f		 pop	 rdi
  000c9	c3		 ret	 0
$LN4@PyLong_Fro:

; 138  :         PyErr_Format(PyExc_TypeError,
; 139  :                      "an integer is required (got type %.200s)",
; 140  :                      Py_TYPE(integral)->tp_name);

  000ca	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@CAOECIFE@an?5integer?5is?5required?5?$CIgot?5type@
  000dc	e8 00 00 00 00	 call	 PyErr_Format

; 141  :         return NULL;

  000e1	33 c0		 xor	 eax, eax
$LN7@PyLong_Fro:

; 154  :         return NULL;
; 155  :     }
; 156  :     return (PyLongObject *)result;
; 157  : }

  000e3	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ec	5f		 pop	 rdi
  000ed	c3		 ret	 0
_PyLong_FromNbInt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@NJCLNNOK@too?5many?5digits?5in?5integer?$AA@ ; `string'
PUBLIC	_PyLong_New
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyObject_Malloc:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_OverflowError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_New DD imagerel $LN5
	DD	imagerel $LN5+105
	DD	imagerel $unwind$_PyLong_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_New DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BL@NJCLNNOK@too?5many?5digits?5in?5integer?$AA@
CONST	SEGMENT
??_C@_0BL@NJCLNNOK@too?5many?5digits?5in?5integer?$AA@ DB 'too many digit'
	DB	's in integer', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyLong_New
_TEXT	SEGMENT
size$ = 48
_PyLong_New PROC					; COMDAT

; 168  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 169  :     PyLongObject *result;
; 170  :     /* Number of bytes needed is: offsetof(PyLongObject, ob_digit) +
; 171  :        sizeof(digit)*size.  Previous incarnations of this code used
; 172  :        sizeof(PyVarObject) instead of the offsetof, but this risks being
; 173  :        incorrect in the presence of padding between the PyVarObject header
; 174  :        and the digits. */
; 175  :     if (size > (Py_ssize_t)MAX_LONG_DIGITS) {

  00006	48 b8 e3 ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693923 ; 1fffffffffffffe3H
  00010	48 8b d9	 mov	 rbx, rcx
  00013	48 3b c8	 cmp	 rcx, rax
  00016	7e 1b		 jle	 SHORT $LN2@PyLong_New

; 176  :         PyErr_SetString(PyExc_OverflowError,
; 177  :                         "too many digits in integer");

  00018	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@NJCLNNOK@too?5many?5digits?5in?5integer?$AA@
  00026	e8 00 00 00 00	 call	 PyErr_SetString

; 178  :         return NULL;

  0002b	33 c0		 xor	 eax, eax

; 187  : }

  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5b		 pop	 rbx
  00032	c3		 ret	 0
$LN2@PyLong_New:

; 179  :     }
; 180  :     result = PyObject_MALLOC(offsetof(PyLongObject, ob_digit) +
; 181  :                              size*sizeof(digit));

  00033	48 8d 0c 8d 70
	00 00 00	 lea	 rcx, QWORD PTR [rcx*4+112]
  0003b	e8 00 00 00 00	 call	 PyObject_Malloc

; 182  :     if (!result) {

  00040	48 85 c0	 test	 rax, rax
  00043	75 0d		 jne	 SHORT $LN1@PyLong_New

; 183  :         PyErr_NoMemory();

  00045	e8 00 00 00 00	 call	 PyErr_NoMemory

; 184  :         return NULL;

  0004a	33 c0		 xor	 eax, eax

; 187  : }

  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5b		 pop	 rbx
  00051	c3		 ret	 0
$LN1@PyLong_New:

; 185  :     }
; 186  :     return (PyLongObject*)PyObject_INIT_VAR((PyVarObject *)result, &PyLong_Type, size);

  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyLong_Type
  00059	4c 8b c3	 mov	 r8, rbx
  0005c	48 8b c8	 mov	 rcx, rax

; 187  : }

  0005f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00063	5b		 pop	 rbx
  00064	e9 00 00 00 00	 jmp	 PyObject_INIT_VAR
_PyLong_New ENDP
_TEXT	ENDS
PUBLIC	_PyLong_Copy
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_Copy DD imagerel $LN21
	DD	imagerel $LN21+173
	DD	imagerel $unwind$_PyLong_Copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_Copy DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyLong_Copy
_TEXT	SEGMENT
src$ = 48
_PyLong_Copy PROC					; COMDAT

; 191  : {

$LN21:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 192  :     PyLongObject *result;
; 193  :     Py_ssize_t i;
; 194  : 
; 195  :     assert(src != NULL);
; 196  :     i = Py_SIZE(src);

  0000a	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 8b d8	 mov	 rbx, rax

; 197  :     if (i < 0)

  00014	48 85 c0	 test	 rax, rax
  00017	79 03		 jns	 SHORT $LN9@PyLong_Cop

; 198  :         i = -(i);

  00019	48 f7 db	 neg	 rbx
$LN9@PyLong_Cop:

; 199  :     if (i < 2) {

  0001c	48 83 fb 02	 cmp	 rbx, 2
  00020	7d 3e		 jge	 SHORT $LN5@PyLong_Cop

; 200  :         sdigit ival = MEDIUM_VALUE(src);

  00022	48 85 c0	 test	 rax, rax
  00025	79 07		 jns	 SHORT $LN20@PyLong_Cop
  00027	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  0002a	f7 d9		 neg	 ecx
  0002c	eb 16		 jmp	 SHORT $LN13@PyLong_Cop
$LN20@PyLong_Cop:
  0002e	75 11		 jne	 SHORT $LN12@PyLong_Cop
  00030	33 c9		 xor	 ecx, ecx

; 210  : }

  00032	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5f		 pop	 rdi
  0003c	e9 00 00 00 00	 jmp	 get_small_int
$LN12@PyLong_Cop:

; 200  :         sdigit ival = MEDIUM_VALUE(src);

  00041	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
$LN13@PyLong_Cop:

; 201  :         CHECK_SMALL_INT(ival);

  00044	83 f9 fb	 cmp	 ecx, -5
  00047	7c 17		 jl	 SHORT $LN5@PyLong_Cop
  00049	81 f9 01 01 00
	00		 cmp	 ecx, 257		; 00000101H
  0004f	7d 0f		 jge	 SHORT $LN5@PyLong_Cop

; 210  : }

  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5f		 pop	 rdi
  0005b	e9 00 00 00 00	 jmp	 get_small_int
$LN5@PyLong_Cop:

; 202  :     }
; 203  :     result = _PyLong_New(i);

  00060	48 8b cb	 mov	 rcx, rbx
  00063	e8 00 00 00 00	 call	 _PyLong_New
  00068	4c 8b d8	 mov	 r11, rax

; 204  :     if (result != NULL) {

  0006b	48 85 c0	 test	 rax, rax
  0006e	74 2f		 je	 SHORT $LN1@PyLong_Cop

; 205  :         Py_SIZE(result) = Py_SIZE(src);
; 206  :         while (--i >= 0)

  00070	48 ff cb	 dec	 rbx
  00073	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  00077	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx
  0007b	78 22		 js	 SHORT $LN1@PyLong_Cop
  0007d	48 8d 4c 98 70	 lea	 rcx, QWORD PTR [rax+rbx*4+112]
  00082	48 2b f8	 sub	 rdi, rax
  00085	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL2@PyLong_Cop:

; 207  :             result->ob_digit[i] = src->ob_digit[i];

  00090	8b 04 0f	 mov	 eax, DWORD PTR [rdi+rcx]
  00093	48 83 e9 04	 sub	 rcx, 4
  00097	48 ff cb	 dec	 rbx
  0009a	89 41 04	 mov	 DWORD PTR [rcx+4], eax
  0009d	79 f1		 jns	 SHORT $LL2@PyLong_Cop
$LN1@PyLong_Cop:

; 208  :     }
; 209  :     return (PyObject *)result;

  0009f	49 8b c3	 mov	 rax, r11

; 210  : }

  000a2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ab	5f		 pop	 rdi
  000ac	c3		 ret	 0
_PyLong_Copy ENDP
_TEXT	ENDS
PUBLIC	PyLong_FromLong
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromLong DD imagerel $LN20
	DD	imagerel $LN20+200
	DD	imagerel $unwind$PyLong_FromLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromLong DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyLong_FromLong
_TEXT	SEGMENT
ival$ = 48
PyLong_FromLong PROC					; COMDAT

; 216  : {

$LN20:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 217  :     PyLongObject *v;
; 218  :     unsigned long abs_ival;
; 219  :     unsigned long t;  /* unsigned so >> doesn't propagate sign bit */
; 220  :     int ndigits = 0;

  0000f	33 ff		 xor	 edi, edi

; 221  :     int sign = 1;
; 222  : 
; 223  :     CHECK_SMALL_INT(ival);

  00011	8d 41 05	 lea	 eax, DWORD PTR [rcx+5]
  00014	8b d9		 mov	 ebx, ecx
  00016	8d 77 01	 lea	 esi, QWORD PTR [rdi+1]
  00019	3d 05 01 00 00	 cmp	 eax, 261		; 00000105H
  0001e	77 14		 ja	 SHORT $LN12@PyLong_Fro@2

; 279  : }

  00020	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00025	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	e9 00 00 00 00	 jmp	 get_small_int
$LN12@PyLong_Fro@2:

; 224  : 
; 225  :     if (ival < 0) {

  00034	85 c9		 test	 ecx, ecx
  00036	79 05		 jns	 SHORT $LN9@PyLong_Fro@2

; 226  :         /* negate: can't write this as abs_ival = -ival since that
; 227  :            invokes undefined behaviour when ival is LONG_MIN */
; 228  :         abs_ival = 0U-(unsigned long)ival;

  00038	f7 db		 neg	 ebx

; 229  :         sign = -1;

  0003a	83 ce ff	 or	 esi, -1
$LN9@PyLong_Fro@2:

; 230  :     }
; 231  :     else {
; 232  :         abs_ival = (unsigned long)ival;
; 233  :     }
; 234  : 
; 235  :     /* Fast path for single-digit ints */
; 236  :     if (!(abs_ival >> PyLong_SHIFT)) {

  0003d	f7 c3 00 00 00
	c0		 test	 ebx, -1073741824	; c0000000H
  00043	75 29		 jne	 SHORT $LN7@PyLong_Fro@2

; 237  :         v = _PyLong_New(1);

  00045	b9 01 00 00 00	 mov	 ecx, 1
  0004a	e8 00 00 00 00	 call	 _PyLong_New

; 238  :         if (v) {

  0004f	48 85 c0	 test	 rax, rax
  00052	74 64		 je	 SHORT $LN14@PyLong_Fro@2

; 239  :             Py_SIZE(v) = sign;

  00054	48 63 ce	 movsxd	 rcx, esi

; 240  :             v->ob_digit[0] = Py_SAFE_DOWNCAST(
; 241  :                 abs_ival, unsigned long, digit);

  00057	89 58 70	 mov	 DWORD PTR [rax+112], ebx
  0005a	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 279  : }

  0005e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00063	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00068	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006c	5f		 pop	 rdi
  0006d	c3		 ret	 0
$LN7@PyLong_Fro@2:

; 242  :         }
; 243  :         return (PyObject*)v;
; 244  :     }
; 245  : 
; 246  : #if PyLong_SHIFT==15
; 247  :     /* 2 digits */
; 248  :     if (!(abs_ival >> 2*PyLong_SHIFT)) {
; 249  :         v = _PyLong_New(2);
; 250  :         if (v) {
; 251  :             Py_SIZE(v) = 2*sign;
; 252  :             v->ob_digit[0] = Py_SAFE_DOWNCAST(
; 253  :                 abs_ival & PyLong_MASK, unsigned long, digit);
; 254  :             v->ob_digit[1] = Py_SAFE_DOWNCAST(
; 255  :                   abs_ival >> PyLong_SHIFT, unsigned long, digit);
; 256  :         }
; 257  :         return (PyObject*)v;
; 258  :     }
; 259  : #endif
; 260  : 
; 261  :     /* Larger numbers: loop to determine number of digits */
; 262  :     t = abs_ival;

  0006e	8b c3		 mov	 eax, ebx

; 263  :     while (t) {

  00070	85 db		 test	 ebx, ebx
  00072	74 09		 je	 SHORT $LN4@PyLong_Fro@2
$LL5@PyLong_Fro@2:

; 264  :         ++ndigits;
; 265  :         t >>= PyLong_SHIFT;

  00074	c1 e8 1e	 shr	 eax, 30
  00077	ff c7		 inc	 edi
  00079	85 c0		 test	 eax, eax
  0007b	75 f7		 jne	 SHORT $LL5@PyLong_Fro@2
$LN4@PyLong_Fro@2:

; 266  :     }
; 267  :     v = _PyLong_New(ndigits);

  0007d	48 63 cf	 movsxd	 rcx, edi
  00080	e8 00 00 00 00	 call	 _PyLong_New
  00085	4c 8b d8	 mov	 r11, rax

; 268  :     if (v != NULL) {

  00088	48 85 c0	 test	 rax, rax
  0008b	74 28		 je	 SHORT $LN1@PyLong_Fro@2

; 269  :         digit *p = v->ob_digit;
; 270  :         Py_SIZE(v) = ndigits*sign;

  0008d	0f af f7	 imul	 esi, edi
  00090	48 8d 50 70	 lea	 rdx, QWORD PTR [rax+112]
  00094	48 63 ce	 movsxd	 rcx, esi
  00097	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 271  :         t = abs_ival;
; 272  :         while (t) {

  0009b	85 db		 test	 ebx, ebx
  0009d	74 16		 je	 SHORT $LN1@PyLong_Fro@2
  0009f	90		 npad	 1
$LL2@PyLong_Fro@2:

; 273  :             *p++ = Py_SAFE_DOWNCAST(
; 274  :                 t & PyLong_MASK, unsigned long, digit);

  000a0	8b c3		 mov	 eax, ebx

; 275  :             t >>= PyLong_SHIFT;

  000a2	c1 eb 1e	 shr	 ebx, 30
  000a5	48 83 c2 04	 add	 rdx, 4
  000a9	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  000ae	89 42 fc	 mov	 DWORD PTR [rdx-4], eax
  000b1	85 db		 test	 ebx, ebx
  000b3	75 eb		 jne	 SHORT $LL2@PyLong_Fro@2
$LN1@PyLong_Fro@2:

; 276  :         }
; 277  :     }
; 278  :     return (PyObject *)v;

  000b5	49 8b c3	 mov	 rax, r11
$LN14@PyLong_Fro@2:

; 279  : }

  000b8	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000bd	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000c2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c6	5f		 pop	 rdi
  000c7	c3		 ret	 0
PyLong_FromLong ENDP
_TEXT	ENDS
PUBLIC	PyLong_FromUnsignedLong
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromUnsignedLong DD imagerel $LN13
	DD	imagerel $LN13+129
	DD	imagerel $unwind$PyLong_FromUnsignedLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromUnsignedLong DD 042301H
	DD	067423H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyLong_FromUnsignedLong
_TEXT	SEGMENT
ival$ = 48
PyLong_FromUnsignedLong PROC				; COMDAT

; 285  : {

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b d9		 mov	 ebx, ecx

; 286  :     PyLongObject *v;
; 287  :     unsigned long t;
; 288  :     int ndigits = 0;

  00008	33 c9		 xor	 ecx, ecx

; 289  : 
; 290  :     if (ival < PyLong_BASE)

  0000a	81 fb 00 00 00
	40		 cmp	 ebx, 1073741824		; 40000000H
  00010	73 0c		 jae	 SHORT $LN6@PyLong_Fro@3

; 291  :         return PyLong_FromLong(ival);

  00012	8b cb		 mov	 ecx, ebx

; 305  :         }
; 306  :     }
; 307  :     return (PyObject *)v;
; 308  : }

  00014	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00018	5b		 pop	 rbx
  00019	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN6@PyLong_Fro@3:
  0001e	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 292  :     /* Count the number of Python digits. */
; 293  :     t = (unsigned long)ival;

  00023	8b c3		 mov	 eax, ebx

; 294  :     while (t) {

  00025	85 db		 test	 ebx, ebx
  00027	74 10		 je	 SHORT $LN4@PyLong_Fro@3
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@PyLong_Fro@3:

; 295  :         ++ndigits;
; 296  :         t >>= PyLong_SHIFT;

  00030	c1 e8 1e	 shr	 eax, 30
  00033	ff c1		 inc	 ecx
  00035	85 c0		 test	 eax, eax
  00037	75 f7		 jne	 SHORT $LL5@PyLong_Fro@3
$LN4@PyLong_Fro@3:

; 297  :     }
; 298  :     v = _PyLong_New(ndigits);

  00039	48 63 f9	 movsxd	 rdi, ecx
  0003c	48 8b cf	 mov	 rcx, rdi
  0003f	e8 00 00 00 00	 call	 _PyLong_New

; 299  :     if (v != NULL) {

  00044	48 85 c0	 test	 rax, rax
  00047	74 2d		 je	 SHORT $LN1@PyLong_Fro@3

; 300  :         digit *p = v->ob_digit;

  00049	48 8d 50 70	 lea	 rdx, QWORD PTR [rax+112]

; 301  :         Py_SIZE(v) = ndigits;

  0004d	48 89 78 60	 mov	 QWORD PTR [rax+96], rdi

; 302  :         while (ival) {

  00051	85 db		 test	 ebx, ebx
  00053	74 21		 je	 SHORT $LN1@PyLong_Fro@3
  00055	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL2@PyLong_Fro@3:

; 303  :             *p++ = (digit)(ival & PyLong_MASK);

  00060	8b cb		 mov	 ecx, ebx

; 304  :             ival >>= PyLong_SHIFT;

  00062	c1 eb 1e	 shr	 ebx, 30
  00065	48 83 c2 04	 add	 rdx, 4
  00069	81 e1 ff ff ff
	3f		 and	 ecx, 1073741823		; 3fffffffH
  0006f	89 4a fc	 mov	 DWORD PTR [rdx-4], ecx
  00072	85 db		 test	 ebx, ebx
  00074	75 ea		 jne	 SHORT $LL2@PyLong_Fro@3
$LN1@PyLong_Fro@3:
  00076	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 305  :         }
; 306  :     }
; 307  :     return (PyObject *)v;
; 308  : }

  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5b		 pop	 rbx
  00080	c3		 ret	 0
PyLong_FromUnsignedLong ENDP
_TEXT	ENDS
PUBLIC	__mask@@NegDouble@
PUBLIC	??_C@_0CE@HNDAIPOH@cannot?5convert?5float?5NaN?5to?5inte@ ; `string'
PUBLIC	??_C@_0CJ@FCONGJCF@cannot?5convert?5float?5infinity?5to@ ; `string'
PUBLIC	PyLong_FromDouble
EXTRN	__imp_ldexp:PROC
EXTRN	__imp_frexp:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	__imp__isnan:PROC
EXTRN	__imp__finite:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromDouble DD imagerel $LN15
	DD	imagerel $LN15+297
	DD	imagerel $unwind$PyLong_FromDouble
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyLong_FromDouble DD imagerel $LN15+297
	DD	imagerel $LN15+375
	DD	imagerel $chain$2$PyLong_FromDouble
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyLong_FromDouble DD imagerel $LN15+375
	DD	imagerel $LN15+414
	DD	imagerel $chain$3$PyLong_FromDouble
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyLong_FromDouble DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+297
	DD	imagerel $unwind$PyLong_FromDouble
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyLong_FromDouble DD 020521H
	DD	0b7405H
	DD	imagerel $LN15
	DD	imagerel $LN15+297
	DD	imagerel $unwind$PyLong_FromDouble
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromDouble DD 08cc01H
	DD	0a64ccH
	DD	0834c7H
	DD	02680bH
	DD	050025206H
xdata	ENDS
;	COMDAT __mask@@NegDouble@
CONST	SEGMENT
__mask@@NegDouble@ DB 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT ??_C@_0CE@HNDAIPOH@cannot?5convert?5float?5NaN?5to?5inte@
CONST	SEGMENT
??_C@_0CE@HNDAIPOH@cannot?5convert?5float?5NaN?5to?5inte@ DB 'cannot conv'
	DB	'ert float NaN to integer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FCONGJCF@cannot?5convert?5float?5infinity?5to@
CONST	SEGMENT
??_C@_0CJ@FCONGJCF@cannot?5convert?5float?5infinity?5to@ DB 'cannot conve'
	DB	'rt float infinity to integer', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyLong_FromDouble
_TEXT	SEGMENT
dval$ = 64
expo$ = 72
PyLong_FromDouble PROC					; COMDAT

; 314  : {

$LN15:
  00000	40 55		 push	 rbp
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6

; 315  :     PyLongObject *v;
; 316  :     double frac;
; 317  :     int i, ndig, expo, neg;
; 318  :     neg = 0;

  0000b	33 ed		 xor	 ebp, ebp
  0000d	66 0f 28 f0	 movapd	 xmm6, xmm0

; 319  :     if (Py_IS_INFINITY(dval)) {

  00011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00017	85 c0		 test	 eax, eax
  00019	75 2e		 jne	 SHORT $LN8@PyLong_Fro@4
  0001b	66 0f 28 c6	 movapd	 xmm0, xmm6
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00025	85 c0		 test	 eax, eax
  00027	75 20		 jne	 SHORT $LN8@PyLong_Fro@4

; 320  :         PyErr_SetString(PyExc_OverflowError,
; 321  :                         "cannot convert float infinity to integer");

  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@FCONGJCF@cannot?5convert?5float?5infinity?5to@
  00037	e8 00 00 00 00	 call	 PyErr_SetString

; 322  :         return NULL;

  0003c	33 c0		 xor	 eax, eax

; 350  : }

  0003e	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00043	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00047	5d		 pop	 rbp
  00048	c3		 ret	 0
$LN8@PyLong_Fro@4:

; 323  :     }
; 324  :     if (Py_IS_NAN(dval)) {

  00049	66 0f 28 c6	 movapd	 xmm0, xmm6
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00053	85 c0		 test	 eax, eax
  00055	74 20		 je	 SHORT $LN7@PyLong_Fro@4

; 325  :         PyErr_SetString(PyExc_ValueError,
; 326  :                         "cannot convert float NaN to integer");

  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@HNDAIPOH@cannot?5convert?5float?5NaN?5to?5inte@
  00065	e8 00 00 00 00	 call	 PyErr_SetString

; 327  :         return NULL;

  0006a	33 c0		 xor	 eax, eax

; 350  : }

  0006c	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00071	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00075	5d		 pop	 rbp
  00076	c3		 ret	 0
$LN7@PyLong_Fro@4:

; 328  :     }
; 329  :     if (dval < 0.0) {

  00077	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0007b	66 0f 2f c6	 comisd	 xmm0, xmm6
  0007f	76 0d		 jbe	 SHORT $LN6@PyLong_Fro@4

; 330  :         neg = 1;
; 331  :         dval = -dval;

  00081	66 0f 57 35 00
	00 00 00	 xorpd	 xmm6, QWORD PTR __mask@@NegDouble@
  00089	bd 01 00 00 00	 mov	 ebp, 1
$LN6@PyLong_Fro@4:

; 332  :     }
; 333  :     frac = frexp(dval, &expo); /* dval = frac*2**expo; 0.0 <= frac < 1.0 */

  0008e	48 8d 54 24 48	 lea	 rdx, QWORD PTR expo$[rsp]
  00093	66 0f 28 c6	 movapd	 xmm0, xmm6
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_frexp

; 334  :     if (expo <= 0)

  0009d	8b 4c 24 48	 mov	 ecx, DWORD PTR expo$[rsp]
  000a1	66 0f 28 f0	 movapd	 xmm6, xmm0
  000a5	85 c9		 test	 ecx, ecx
  000a7	7f 12		 jg	 SHORT $LN5@PyLong_Fro@4

; 335  :         return PyLong_FromLong(0L);

  000a9	33 c9		 xor	 ecx, ecx
  000ab	e8 00 00 00 00	 call	 PyLong_FromLong

; 350  : }

  000b0	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000b5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b9	5d		 pop	 rbp
  000ba	c3		 ret	 0
$LN5@PyLong_Fro@4:

; 336  :     ndig = (expo-1) / PyLong_SHIFT + 1; /* Number of 'digits' in result */

  000bb	ff c9		 dec	 ecx
  000bd	b8 89 88 88 88	 mov	 eax, -2004318071	; ffffffff88888889H
  000c2	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  000c7	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  000cc	f7 e9		 imul	 ecx
  000ce	03 d1		 add	 edx, ecx
  000d0	c1 fa 04	 sar	 edx, 4
  000d3	8b c2		 mov	 eax, edx
  000d5	c1 e8 1f	 shr	 eax, 31
  000d8	8d 5c 02 01	 lea	 ebx, DWORD PTR [rdx+rax+1]

; 337  :     v = _PyLong_New(ndig);

  000dc	48 63 cb	 movsxd	 rcx, ebx
  000df	e8 00 00 00 00	 call	 _PyLong_New
  000e4	48 8b f0	 mov	 rsi, rax

; 338  :     if (v == NULL)

  000e7	48 85 c0	 test	 rax, rax
  000ea	0f 84 99 00 00
	00		 je	 $LN14@PyLong_Fro@4
$LN4@PyLong_Fro@4:

; 339  :         return NULL;
; 340  :     frac = ldexp(frac, (expo-1) % PyLong_SHIFT + 1);

  000f0	8b 4c 24 48	 mov	 ecx, DWORD PTR expo$[rsp]
  000f4	b8 89 88 88 88	 mov	 eax, -2004318071	; ffffffff88888889H
  000f9	66 0f 28 c6	 movapd	 xmm0, xmm6
  000fd	ff c9		 dec	 ecx
  000ff	f7 e9		 imul	 ecx
  00101	03 d1		 add	 edx, ecx
  00103	c1 fa 04	 sar	 edx, 4
  00106	8b c2		 mov	 eax, edx
  00108	c1 e8 1f	 shr	 eax, 31
  0010b	03 d0		 add	 edx, eax
  0010d	6b d2 1e	 imul	 edx, 30
  00110	2b ca		 sub	 ecx, edx
  00112	8d 51 01	 lea	 edx, DWORD PTR [rcx+1]
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp

; 341  :     for (i = ndig; --i >= 0; ) {

  0011b	8d 43 ff	 lea	 eax, DWORD PTR [rbx-1]
  0011e	48 63 d8	 movsxd	 rbx, eax
  00121	66 0f 28 e8	 movapd	 xmm5, xmm0
  00125	85 c0		 test	 eax, eax
  00127	78 4e		 js	 SHORT $LN2@PyLong_Fro@4

; 339  :         return NULL;
; 340  :     frac = ldexp(frac, (expo-1) % PyLong_SHIFT + 1);

  00129	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  0012e	48 8d 7c 9e 70	 lea	 rdi, QWORD PTR [rsi+rbx*4+112]
  00133	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL3@PyLong_Fro@4:

; 342  :         digit bits = (digit)frac;

  00140	f2 48 0f 2c c5	 cvttsd2si rax, xmm5

; 343  :         v->ob_digit[i] = bits;
; 344  :         frac = frac - (double)bits;
; 345  :         frac = ldexp(frac, PyLong_SHIFT);

  00145	66 0f ef c0	 pxor	 xmm0, xmm0
  00149	ba 1e 00 00 00	 mov	 edx, 30
  0014e	89 07		 mov	 DWORD PTR [rdi], eax
  00150	8b c0		 mov	 eax, eax
  00152	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00157	f2 0f 5c e8	 subsd	 xmm5, xmm0
  0015b	66 0f 28 c5	 movapd	 xmm0, xmm5
  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  00165	48 83 ef 04	 sub	 rdi, 4
  00169	48 ff cb	 dec	 rbx
  0016c	66 0f 28 e8	 movapd	 xmm5, xmm0
  00170	79 ce		 jns	 SHORT $LL3@PyLong_Fro@4
  00172	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
$LN2@PyLong_Fro@4:

; 346  :     }
; 347  :     if (neg)

  00177	85 ed		 test	 ebp, ebp
  00179	74 0b		 je	 SHORT $LN1@PyLong_Fro@4

; 348  :         Py_SIZE(v) = -(Py_SIZE(v));

  0017b	48 8b 46 60	 mov	 rax, QWORD PTR [rsi+96]
  0017f	48 f7 d8	 neg	 rax
  00182	48 89 46 60	 mov	 QWORD PTR [rsi+96], rax
$LN1@PyLong_Fro@4:

; 349  :     return (PyObject *)v;

  00186	48 8b c6	 mov	 rax, rsi
$LN14@PyLong_Fro@4:
  00189	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0018e	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 350  : }

  00193	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00198	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019c	5d		 pop	 rbp
  0019d	c3		 ret	 0
PyLong_FromDouble ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@ ; `string'
PUBLIC	PyLong_AsLongAndOverflow
EXTRN	_PyErr_BadInternalCall:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsLongAndOverflow DD imagerel $LN26
	DD	imagerel $LN26+279
	DD	imagerel $unwind$PyLong_AsLongAndOverflow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsLongAndOverflow DD 084e01H
	DD	06644eH
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
CONST	SEGMENT
??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@ DB '..\Objects\longob'
	DB	'ject.c', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyLong_AsLongAndOverflow
_TEXT	SEGMENT
vv$ = 48
overflow$ = 56
PyLong_AsLongAndOverflow PROC				; COMDAT

; 376  : {

$LN26:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 377  :     /* This version by Tim Peters */
; 378  :     register PyLongObject *v;
; 379  :     unsigned long x, prev;
; 380  :     long res;
; 381  :     Py_ssize_t i;
; 382  :     int sign;
; 383  :     int do_decref = 0; /* if nb_int was called */

  0000f	33 ff		 xor	 edi, edi
  00011	48 8b ea	 mov	 rbp, rdx
  00014	4c 8b c1	 mov	 r8, rcx
  00017	44 8b d7	 mov	 r10d, edi

; 384  : 
; 385  :     *overflow = 0;

  0001a	89 3a		 mov	 DWORD PTR [rdx], edi

; 386  :     if (vv == NULL) {

  0001c	48 85 c9	 test	 rcx, rcx
  0001f	75 24		 jne	 SHORT $LN19@PyLong_AsL

; 387  :         PyErr_BadInternalCall();

  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00028	ba 83 01 00 00	 mov	 edx, 387		; 00000183H
  0002d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 388  :         return -1;

  00032	83 c8 ff	 or	 eax, -1

; 448  : }

  00035	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0003a	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
$LN19@PyLong_AsL:

; 389  :     }
; 390  : 
; 391  :     if (PyLong_Check(vv)) {

  00045	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00049	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0004e	be 01 00 00 00	 mov	 esi, 1
  00053	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0005d	75 18		 jne	 SHORT $LN17@PyLong_AsL

; 392  :         v = (PyLongObject *)vv;
; 393  :     }
; 394  :     else {
; 395  :         v = _PyLong_FromNbInt(vv);

  0005f	e8 00 00 00 00	 call	 _PyLong_FromNbInt
  00064	4c 8b c0	 mov	 r8, rax

; 396  :         if (v == NULL)

  00067	48 85 c0	 test	 rax, rax
  0006a	75 08		 jne	 SHORT $LN16@PyLong_AsL

; 397  :             return -1;

  0006c	83 c8 ff	 or	 eax, -1
  0006f	e9 8e 00 00 00	 jmp	 $LN25@PyLong_AsL
$LN16@PyLong_AsL:

; 398  :         do_decref = 1;

  00074	44 8b d6	 mov	 r10d, esi
$LN17@PyLong_AsL:

; 399  :     }
; 400  : 
; 401  :     res = -1;
; 402  :     i = Py_SIZE(v);

  00077	49 8b 50 60	 mov	 rdx, QWORD PTR [r8+96]
  0007b	83 cb ff	 or	 ebx, -1

; 403  : 
; 404  :     switch (i) {

  0007e	48 83 fa ff	 cmp	 rdx, -1
  00082	74 69		 je	 SHORT $LN13@PyLong_AsL
  00084	48 85 d2	 test	 rdx, rdx
  00087	74 60		 je	 SHORT $LN12@PyLong_AsL
  00089	48 3b d6	 cmp	 rdx, rsi
  0008c	74 55		 je	 SHORT $LN11@PyLong_AsL

; 414  :     default:
; 415  :         sign = 1;
; 416  :         x = 0;
; 417  :         if (i < 0) {

  0008e	48 85 d2	 test	 rdx, rdx
  00091	79 05		 jns	 SHORT $LN22@PyLong_AsL

; 418  :             sign = -1;

  00093	8b f3		 mov	 esi, ebx

; 419  :             i = -(i);

  00095	48 f7 da	 neg	 rdx
$LN22@PyLong_AsL:

; 420  :         }
; 421  :         while (--i >= 0) {

  00098	48 ff ca	 dec	 rdx
  0009b	78 3f		 js	 SHORT $LN24@PyLong_AsL
  0009d	4d 8d 4c 90 70	 lea	 r9, QWORD PTR [r8+rdx*4+112]
$LL8@PyLong_AsL:

; 422  :             prev = x;

  000a2	8b cf		 mov	 ecx, edi

; 423  :             x = (x << PyLong_SHIFT) | v->ob_digit[i];

  000a4	c1 e7 1e	 shl	 edi, 30
  000a7	41 0b 39	 or	 edi, DWORD PTR [r9]

; 424  :             if ((x >> PyLong_SHIFT) != prev) {

  000aa	8b c7		 mov	 eax, edi
  000ac	c1 e8 1e	 shr	 eax, 30
  000af	3b c1		 cmp	 eax, ecx
  000b1	75 24		 jne	 SHORT $LN23@PyLong_AsL

; 420  :         }
; 421  :         while (--i >= 0) {

  000b3	49 83 e9 04	 sub	 r9, 4
  000b7	48 ff ca	 dec	 rdx
  000ba	79 e6		 jns	 SHORT $LL8@PyLong_AsL

; 427  :             }
; 428  :         }
; 429  :         /* Haven't lost any bits, but casting to long requires extra
; 430  :          * care (see comment above).
; 431  :          */
; 432  :         if (x <= (unsigned long)LONG_MAX) {

  000bc	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  000c2	76 18		 jbe	 SHORT $LN24@PyLong_AsL

; 434  :         }
; 435  :         else if (sign < 0 && x == PY_ABS_LONG_MIN) {

  000c4	85 f6		 test	 esi, esi
  000c6	79 0f		 jns	 SHORT $LN23@PyLong_AsL
  000c8	81 ff 00 00 00
	80		 cmp	 edi, -2147483648	; 80000000H
  000ce	75 07		 jne	 SHORT $LN23@PyLong_AsL

; 436  :             res = LONG_MIN;

  000d0	bb 00 00 00 80	 mov	 ebx, -2147483648	; ffffffff80000000H

; 437  :         }
; 438  :         else {

  000d5	eb 1c		 jmp	 SHORT $exit$20435
$LN23@PyLong_AsL:

; 425  :                 *overflow = sign;

  000d7	89 75 00	 mov	 DWORD PTR [rbp], esi

; 426  :                 goto exit;

  000da	eb 17		 jmp	 SHORT $exit$20435
$LN24@PyLong_AsL:

; 433  :             res = (long)x * sign;

  000dc	8b df		 mov	 ebx, edi
  000de	0f af de	 imul	 ebx, esi
  000e1	eb 10		 jmp	 SHORT $exit$20435
$LN11@PyLong_AsL:

; 411  :     case 1:
; 412  :         res = v->ob_digit[0];

  000e3	41 8b 58 70	 mov	 ebx, DWORD PTR [r8+112]

; 413  :         break;

  000e7	eb 0a		 jmp	 SHORT $exit$20435
$LN12@PyLong_AsL:

; 407  :         break;
; 408  :     case 0:
; 409  :         res = 0;

  000e9	8b df		 mov	 ebx, edi

; 410  :         break;

  000eb	eb 06		 jmp	 SHORT $exit$20435
$LN13@PyLong_AsL:

; 405  :     case -1:
; 406  :         res = -(sdigit)v->ob_digit[0];

  000ed	41 8b 58 70	 mov	 ebx, DWORD PTR [r8+112]
  000f1	f7 db		 neg	 ebx
$exit$20435:

; 439  :             *overflow = sign;
; 440  :             /* res is already set to -1 */
; 441  :         }
; 442  :     }
; 443  :   exit:
; 444  :     if (do_decref) {

  000f3	45 85 d2	 test	 r10d, r10d
  000f6	74 08		 je	 SHORT $LN1@PyLong_AsL

; 445  :         Py_DECREF(v);

  000f8	49 8b c8	 mov	 rcx, r8
  000fb	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyLong_AsL:

; 446  :     }
; 447  :     return res;

  00100	8b c3		 mov	 eax, ebx
$LN25@PyLong_AsL:
  00102	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 448  : }

  00107	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0010c	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00111	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00115	5f		 pop	 rdi
  00116	c3		 ret	 0
PyLong_AsLongAndOverflow ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@CMJMJMG@Python?5int?5too?5large?5to?5convert?5@ ; `string'
PUBLIC	PyLong_AsLong
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsLong DD imagerel $LN5
	DD	imagerel $LN5+52
	DD	imagerel $unwind$PyLong_AsLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsLong DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CK@CMJMJMG@Python?5int?5too?5large?5to?5convert?5@
CONST	SEGMENT
??_C@_0CK@CMJMJMG@Python?5int?5too?5large?5to?5convert?5@ DB 'Python int '
	DB	'too large to convert to C long', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyLong_AsLong
_TEXT	SEGMENT
obj$ = 48
overflow$ = 56
PyLong_AsLong PROC					; COMDAT

; 455  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 456  :     int overflow;
; 457  :     long result = PyLong_AsLongAndOverflow(obj, &overflow);

  00006	48 8d 54 24 38	 lea	 rdx, QWORD PTR overflow$[rsp]
  0000b	e8 00 00 00 00	 call	 PyLong_AsLongAndOverflow

; 458  :     if (overflow) {

  00010	83 7c 24 38 00	 cmp	 DWORD PTR overflow$[rsp], 0
  00015	8b d8		 mov	 ebx, eax
  00017	74 15		 je	 SHORT $LN1@PyLong_AsL@2

; 459  :         /* XXX: could be cute and give a different
; 460  :            message for overflow == -1 */
; 461  :         PyErr_SetString(PyExc_OverflowError,
; 462  :                         "Python int too large to convert to C long");

  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@CMJMJMG@Python?5int?5too?5large?5to?5convert?5@
  00027	e8 00 00 00 00	 call	 PyErr_SetString

; 463  :     }
; 464  :     return result;

  0002c	8b c3		 mov	 eax, ebx
$LN1@PyLong_AsL@2:

; 465  : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
PyLong_AsLong ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@PBLNFIOG@Python?5int?5too?5large?5to?5convert?5@ ; `string'
PUBLIC	_PyLong_AsInt
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_AsInt DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$_PyLong_AsInt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_AsInt DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CJ@PBLNFIOG@Python?5int?5too?5large?5to?5convert?5@
CONST	SEGMENT
??_C@_0CJ@PBLNFIOG@Python?5int?5too?5large?5to?5convert?5@ DB 'Python int'
	DB	' too large to convert to C int', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyLong_AsInt
_TEXT	SEGMENT
obj$ = 48
overflow$ = 56
_PyLong_AsInt PROC					; COMDAT

; 472  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 473  :     int overflow;
; 474  :     long result = PyLong_AsLongAndOverflow(obj, &overflow);

  00004	48 8d 54 24 38	 lea	 rdx, QWORD PTR overflow$[rsp]
  00009	e8 00 00 00 00	 call	 PyLong_AsLongAndOverflow

; 475  :     if (overflow || result > INT_MAX || result < INT_MIN) {

  0000e	83 7c 24 38 00	 cmp	 DWORD PTR overflow$[rsp], 0
  00013	75 0c		 jne	 SHORT $LN1@PyLong_AsI
  00015	b9 00 00 00 80	 mov	 ecx, -2147483648	; ffffffff80000000H
  0001a	03 c8		 add	 ecx, eax
  0001c	83 f9 ff	 cmp	 ecx, -1			; ffffffffH

; 481  :     }
; 482  :     return (int)result;

  0001f	76 16		 jbe	 SHORT $LN3@PyLong_AsI
$LN1@PyLong_AsI:

; 476  :         /* XXX: could be cute and give a different
; 477  :            message for overflow == -1 */
; 478  :         PyErr_SetString(PyExc_OverflowError,
; 479  :                         "Python int too large to convert to C int");

  00021	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@PBLNFIOG@Python?5int?5too?5large?5to?5convert?5@
  0002f	e8 00 00 00 00	 call	 PyErr_SetString

; 480  :         return -1;

  00034	83 c8 ff	 or	 eax, -1
$LN3@PyLong_AsI:

; 483  : }

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
_PyLong_AsInt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@MNHJJIBL@Python?5int?5too?5large?5to?5convert?5@ ; `string'
PUBLIC	??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@ ; `string'
PUBLIC	PyLong_AsSsize_t
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsSsize_t DD imagerel $LN20
	DD	imagerel $LN20+280
	DD	imagerel $unwind$PyLong_AsSsize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsSsize_t DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CN@MNHJJIBL@Python?5int?5too?5large?5to?5convert?5@
CONST	SEGMENT
??_C@_0CN@MNHJJIBL@Python?5int?5too?5large?5to?5convert?5@ DB 'Python int'
	DB	' too large to convert to C ssize_t', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
CONST	SEGMENT
??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@ DB 'an integer is requi'
	DB	'red', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyLong_AsSsize_t
_TEXT	SEGMENT
vv$ = 48
PyLong_AsSsize_t PROC					; COMDAT

; 489  : PyLong_AsSsize_t(PyObject *vv) {

$LN20:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 490  :     register PyLongObject *v;
; 491  :     size_t x, prev;
; 492  :     Py_ssize_t i;
; 493  :     int sign;
; 494  : 
; 495  :     if (vv == NULL) {

  00004	48 85 c9	 test	 rcx, rcx
  00007	75 1a		 jne	 SHORT $LN14@PyLong_AsS

; 496  :         PyErr_BadInternalCall();

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00010	ba f0 01 00 00	 mov	 edx, 496		; 000001f0H
  00015	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 497  :         return -1;

  0001a	48 83 c8 ff	 or	 rax, -1

; 538  : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
$LN14@PyLong_AsS:

; 498  :     }
; 499  :     if (!PyLong_Check(vv)) {

  00023	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00027	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00031	75 1c		 jne	 SHORT $LN13@PyLong_AsS

; 500  :         PyErr_SetString(PyExc_TypeError, "an integer is required");

  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
  00041	e8 00 00 00 00	 call	 PyErr_SetString

; 501  :         return -1;

  00046	48 83 c8 ff	 or	 rax, -1

; 538  : }

  0004a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004e	c3		 ret	 0
$LN13@PyLong_AsS:

; 502  :     }
; 503  : 
; 504  :     v = (PyLongObject *)vv;
; 505  :     i = Py_SIZE(v);

  0004f	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]

; 506  :     switch (i) {

  00053	48 83 fa ff	 cmp	 rdx, -1
  00057	0f 84 af 00 00
	00		 je	 $LN10@PyLong_AsS
  0005d	48 85 d2	 test	 rdx, rdx
  00060	0f 84 9f 00 00
	00		 je	 $LN9@PyLong_AsS
  00066	48 83 fa 01	 cmp	 rdx, 1
  0006a	0f 84 8d 00 00
	00		 je	 $LN8@PyLong_AsS

; 510  :     }
; 511  :     sign = 1;
; 512  :     x = 0;

  00070	45 33 c9	 xor	 r9d, r9d
  00073	41 ba 01 00 00
	00		 mov	 r10d, 1

; 513  :     if (i < 0) {

  00079	48 85 d2	 test	 rdx, rdx
  0007c	79 07		 jns	 SHORT $LN17@PyLong_AsS

; 514  :         sign = -1;

  0007e	41 83 ca ff	 or	 r10d, -1

; 515  :         i = -(i);

  00082	48 f7 da	 neg	 rdx
$LN17@PyLong_AsS:

; 516  :     }
; 517  :     while (--i >= 0) {

  00085	48 ff ca	 dec	 rdx
  00088	78 67		 js	 SHORT $LN19@PyLong_AsS
  0008a	4c 8d 44 91 70	 lea	 r8, QWORD PTR [rcx+rdx*4+112]
  0008f	90		 npad	 1
$LL6@PyLong_AsS:

; 518  :         prev = x;
; 519  :         x = (x << PyLong_SHIFT) | v->ob_digit[i];

  00090	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00093	49 8b c9	 mov	 rcx, r9
  00096	49 c1 e1 1e	 shl	 r9, 30
  0009a	4c 0b c8	 or	 r9, rax

; 520  :         if ((x >> PyLong_SHIFT) != prev)

  0009d	49 8b c1	 mov	 rax, r9
  000a0	48 c1 e8 1e	 shr	 rax, 30
  000a4	48 3b c1	 cmp	 rax, rcx
  000a7	75 2c		 jne	 SHORT $overflow$20489

; 516  :     }
; 517  :     while (--i >= 0) {

  000a9	49 83 e8 04	 sub	 r8, 4
  000ad	48 ff ca	 dec	 rdx
  000b0	79 de		 jns	 SHORT $LL6@PyLong_AsS

; 521  :             goto overflow;
; 522  :     }
; 523  :     /* Haven't lost any bits, but casting to a signed type requires
; 524  :      * extra care (see comment above).
; 525  :      */
; 526  :     if (x <= (size_t)PY_SSIZE_T_MAX) {

  000b2	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000bc	4c 3b c8	 cmp	 r9, rax
  000bf	76 30		 jbe	 SHORT $LN19@PyLong_AsS

; 528  :     }
; 529  :     else if (sign < 0 && x == PY_ABS_SSIZE_T_MIN) {

  000c1	45 85 d2	 test	 r10d, r10d
  000c4	79 0f		 jns	 SHORT $overflow$20489
  000c6	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  000d0	4c 3b c8	 cmp	 r9, rax

; 530  :         return PY_SSIZE_T_MIN;

  000d3	74 3e		 je	 SHORT $LN15@PyLong_AsS
$overflow$20489:

; 531  :     }
; 532  :     /* else overflow */
; 533  : 
; 534  :   overflow:
; 535  :     PyErr_SetString(PyExc_OverflowError,
; 536  :                     "Python int too large to convert to C ssize_t");

  000d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@MNHJJIBL@Python?5int?5too?5large?5to?5convert?5@
  000e3	e8 00 00 00 00	 call	 PyErr_SetString

; 537  :     return -1;

  000e8	48 83 c8 ff	 or	 rax, -1

; 538  : }

  000ec	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000f0	c3		 ret	 0
$LN19@PyLong_AsS:

; 527  :         return (Py_ssize_t)x * sign;

  000f1	49 63 c2	 movsxd	 rax, r10d
  000f4	49 0f af c1	 imul	 rax, r9

; 538  : }

  000f8	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000fc	c3		 ret	 0
$LN8@PyLong_AsS:

; 509  :     case 1: return v->ob_digit[0];

  000fd	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]

; 538  : }

  00100	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00104	c3		 ret	 0
$LN9@PyLong_AsS:

; 508  :     case 0: return 0;

  00105	33 c0		 xor	 eax, eax

; 538  : }

  00107	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010b	c3		 ret	 0
$LN10@PyLong_AsS:

; 507  :     case -1: return -(sdigit)v->ob_digit[0];

  0010c	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  0010f	f7 d8		 neg	 eax
  00111	48 98		 cdqe
$LN15@PyLong_AsS:

; 538  : }

  00113	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00117	c3		 ret	 0
PyLong_AsSsize_t ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@FEJEGDLF@python?5int?5too?5large?5to?5convert?5@ ; `string'
PUBLIC	??_C@_0CN@MPCGIGO@can?8t?5convert?5negative?5value?5to?5@ ; `string'
PUBLIC	PyLong_AsUnsignedLong
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsUnsignedLong DD imagerel $LN15
	DD	imagerel $LN15+223
	DD	imagerel $unwind$PyLong_AsUnsignedLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsUnsignedLong DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0DD@FEJEGDLF@python?5int?5too?5large?5to?5convert?5@
CONST	SEGMENT
??_C@_0DD@FEJEGDLF@python?5int?5too?5large?5to?5convert?5@ DB 'python int'
	DB	' too large to convert to C unsigned long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@MPCGIGO@can?8t?5convert?5negative?5value?5to?5@
CONST	SEGMENT
??_C@_0CN@MPCGIGO@can?8t?5convert?5negative?5value?5to?5@ DB 'can''t conv'
	DB	'ert negative value to unsigned int', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyLong_AsUnsignedLong
_TEXT	SEGMENT
vv$ = 48
PyLong_AsUnsignedLong PROC				; COMDAT

; 545  : {

$LN15:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 546  :     register PyLongObject *v;
; 547  :     unsigned long x, prev;
; 548  :     Py_ssize_t i;
; 549  : 
; 550  :     if (vv == NULL) {

  00004	48 85 c9	 test	 rcx, rcx
  00007	75 19		 jne	 SHORT $LN10@PyLong_AsU

; 551  :         PyErr_BadInternalCall();

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00010	ba 27 02 00 00	 mov	 edx, 551		; 00000227H
  00015	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 552  :         return (unsigned long)-1;

  0001a	83 c8 ff	 or	 eax, -1			; ffffffffH

; 582  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
$LN10@PyLong_AsU:

; 553  :     }
; 554  :     if (!PyLong_Check(vv)) {

  00022	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00026	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00030	75 1b		 jne	 SHORT $LN9@PyLong_AsU

; 555  :         PyErr_SetString(PyExc_TypeError, "an integer is required");

  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
  00040	e8 00 00 00 00	 call	 PyErr_SetString

; 556  :         return (unsigned long)-1;

  00045	83 c8 ff	 or	 eax, -1			; ffffffffH

; 582  : }

  00048	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004c	c3		 ret	 0
$LN9@PyLong_AsU:

; 557  :     }
; 558  : 
; 559  :     v = (PyLongObject *)vv;
; 560  :     i = Py_SIZE(v);

  0004d	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]

; 561  :     x = 0;

  00051	45 33 c9	 xor	 r9d, r9d

; 562  :     if (i < 0) {

  00054	48 85 d2	 test	 rdx, rdx
  00057	79 1b		 jns	 SHORT $LN8@PyLong_AsU

; 563  :         PyErr_SetString(PyExc_OverflowError,
; 564  :                         "can't convert negative value to unsigned int");

  00059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@MPCGIGO@can?8t?5convert?5negative?5value?5to?5@
  00067	e8 00 00 00 00	 call	 PyErr_SetString

; 565  :         return (unsigned long) -1;

  0006c	83 c8 ff	 or	 eax, -1			; ffffffffH

; 582  : }

  0006f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00073	c3		 ret	 0
$LN8@PyLong_AsU:

; 566  :     }
; 567  :     switch (i) {

  00074	48 8b c2	 mov	 rax, rdx
  00077	48 85 d2	 test	 rdx, rdx
  0007a	74 5c		 je	 SHORT $LN5@PyLong_AsU
  0007c	48 ff c8	 dec	 rax
  0007f	74 4f		 je	 SHORT $LN4@PyLong_AsU

; 570  :     }
; 571  :     while (--i >= 0) {

  00081	48 ff ca	 dec	 rdx
  00084	78 27		 js	 SHORT $LN2@PyLong_AsU
  00086	4c 8d 44 91 70	 lea	 r8, QWORD PTR [rcx+rdx*4+112]
  0008b	0f 1f 44 00 00	 npad	 5
$LL3@PyLong_AsU:

; 572  :         prev = x;

  00090	41 8b c9	 mov	 ecx, r9d

; 573  :         x = (x << PyLong_SHIFT) | v->ob_digit[i];

  00093	41 c1 e1 1e	 shl	 r9d, 30
  00097	45 0b 08	 or	 r9d, DWORD PTR [r8]

; 574  :         if ((x >> PyLong_SHIFT) != prev) {

  0009a	41 8b c1	 mov	 eax, r9d
  0009d	c1 e8 1e	 shr	 eax, 30
  000a0	3b c1		 cmp	 eax, ecx
  000a2	75 11		 jne	 SHORT $LN14@PyLong_AsU

; 570  :     }
; 571  :     while (--i >= 0) {

  000a4	49 83 e8 04	 sub	 r8, 4
  000a8	48 ff ca	 dec	 rdx
  000ab	79 e3		 jns	 SHORT $LL3@PyLong_AsU
$LN2@PyLong_AsU:

; 579  :         }
; 580  :     }
; 581  :     return x;

  000ad	41 8b c1	 mov	 eax, r9d

; 582  : }

  000b0	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b4	c3		 ret	 0
$LN14@PyLong_AsU:

; 575  :             PyErr_SetString(PyExc_OverflowError,
; 576  :                             "python int too large to convert "
; 577  :                             "to C unsigned long");

  000b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@FEJEGDLF@python?5int?5too?5large?5to?5convert?5@
  000c3	e8 00 00 00 00	 call	 PyErr_SetString

; 578  :             return (unsigned long) -1;

  000c8	83 c8 ff	 or	 eax, -1			; ffffffffH

; 582  : }

  000cb	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000cf	c3		 ret	 0
$LN4@PyLong_AsU:

; 569  :     case 1: return v->ob_digit[0];

  000d0	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]

; 582  : }

  000d3	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d7	c3		 ret	 0
$LN5@PyLong_AsU:

; 568  :     case 0: return 0;

  000d8	33 c0		 xor	 eax, eax

; 582  : }

  000da	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000de	c3		 ret	 0
PyLong_AsUnsignedLong ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@CLANCLJJ@Python?5int?5too?5large?5to?5convert?5@ ; `string'
PUBLIC	??_C@_0CH@MBHBMDDI@can?8t?5convert?5negative?5value?5to?5@ ; `string'
PUBLIC	PyLong_AsSize_t
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsSize_t DD imagerel $LN16
	DD	imagerel $LN16+210
	DD	imagerel $unwind$PyLong_AsSize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsSize_t DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CM@CLANCLJJ@Python?5int?5too?5large?5to?5convert?5@
CONST	SEGMENT
??_C@_0CM@CLANCLJJ@Python?5int?5too?5large?5to?5convert?5@ DB 'Python int'
	DB	' too large to convert to C size_t', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MBHBMDDI@can?8t?5convert?5negative?5value?5to?5@
CONST	SEGMENT
??_C@_0CH@MBHBMDDI@can?8t?5convert?5negative?5value?5to?5@ DB 'can''t con'
	DB	'vert negative value to size_t', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyLong_AsSize_t
_TEXT	SEGMENT
vv$ = 48
PyLong_AsSize_t PROC					; COMDAT

; 589  : {

$LN16:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 590  :     register PyLongObject *v;
; 591  :     size_t x, prev;
; 592  :     Py_ssize_t i;
; 593  : 
; 594  :     if (vv == NULL) {

  00004	48 85 c9	 test	 rcx, rcx
  00007	75 1a		 jne	 SHORT $LN10@PyLong_AsS@2

; 595  :         PyErr_BadInternalCall();

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00010	ba 53 02 00 00	 mov	 edx, 595		; 00000253H
  00015	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 596  :         return (size_t) -1;

  0001a	48 83 c8 ff	 or	 rax, -1

; 625  : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
$LN10@PyLong_AsS@2:

; 597  :     }
; 598  :     if (!PyLong_Check(vv)) {

  00023	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00027	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00031	75 1c		 jne	 SHORT $LN9@PyLong_AsS@2

; 599  :         PyErr_SetString(PyExc_TypeError, "an integer is required");

  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
  00041	e8 00 00 00 00	 call	 PyErr_SetString

; 600  :         return (size_t)-1;

  00046	48 83 c8 ff	 or	 rax, -1

; 625  : }

  0004a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004e	c3		 ret	 0
$LN9@PyLong_AsS@2:

; 601  :     }
; 602  : 
; 603  :     v = (PyLongObject *)vv;
; 604  :     i = Py_SIZE(v);

  0004f	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]

; 605  :     x = 0;

  00053	45 33 c9	 xor	 r9d, r9d

; 606  :     if (i < 0) {

  00056	48 85 d2	 test	 rdx, rdx
  00059	79 1c		 jns	 SHORT $LN8@PyLong_AsS@2

; 607  :         PyErr_SetString(PyExc_OverflowError,
; 608  :                    "can't convert negative value to size_t");

  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@MBHBMDDI@can?8t?5convert?5negative?5value?5to?5@
$LN15@PyLong_AsS@2:
  00062	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00069	e8 00 00 00 00	 call	 PyErr_SetString

; 609  :         return (size_t) -1;

  0006e	48 83 c8 ff	 or	 rax, -1

; 625  : }

  00072	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00076	c3		 ret	 0
$LN8@PyLong_AsS@2:

; 610  :     }
; 611  :     switch (i) {

  00077	48 8b c2	 mov	 rax, rdx
  0007a	48 85 d2	 test	 rdx, rdx
  0007d	74 4c		 je	 SHORT $LN5@PyLong_AsS@2
  0007f	48 ff c8	 dec	 rax
  00082	74 3f		 je	 SHORT $LN4@PyLong_AsS@2

; 614  :     }
; 615  :     while (--i >= 0) {

  00084	48 ff ca	 dec	 rdx
  00087	78 29		 js	 SHORT $LN2@PyLong_AsS@2
  00089	4c 8d 44 91 70	 lea	 r8, QWORD PTR [rcx+rdx*4+112]
  0008e	66 90		 npad	 2
$LL3@PyLong_AsS@2:

; 616  :         prev = x;
; 617  :         x = (x << PyLong_SHIFT) | v->ob_digit[i];

  00090	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00093	49 8b c9	 mov	 rcx, r9
  00096	49 c1 e1 1e	 shl	 r9, 30
  0009a	4c 0b c8	 or	 r9, rax

; 618  :         if ((x >> PyLong_SHIFT) != prev) {

  0009d	49 8b c1	 mov	 rax, r9
  000a0	48 c1 e8 1e	 shr	 rax, 30
  000a4	48 3b c1	 cmp	 rax, rcx
  000a7	75 11		 jne	 SHORT $LN14@PyLong_AsS@2

; 614  :     }
; 615  :     while (--i >= 0) {

  000a9	49 83 e8 04	 sub	 r8, 4
  000ad	48 ff ca	 dec	 rdx
  000b0	79 de		 jns	 SHORT $LL3@PyLong_AsS@2
$LN2@PyLong_AsS@2:

; 622  :         }
; 623  :     }
; 624  :     return x;

  000b2	49 8b c1	 mov	 rax, r9

; 625  : }

  000b5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b9	c3		 ret	 0
$LN14@PyLong_AsS@2:

; 619  :             PyErr_SetString(PyExc_OverflowError,
; 620  :                 "Python int too large to convert to C size_t");

  000ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@CLANCLJJ@Python?5int?5too?5large?5to?5convert?5@

; 621  :             return (size_t) -1;

  000c1	eb 9f		 jmp	 SHORT $LN15@PyLong_AsS@2
$LN4@PyLong_AsS@2:

; 613  :     case 1: return v->ob_digit[0];

  000c3	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]

; 625  : }

  000c6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ca	c3		 ret	 0
$LN5@PyLong_AsS@2:

; 612  :     case 0: return 0;

  000cb	33 c0		 xor	 eax, eax

; 625  : }

  000cd	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d1	c3		 ret	 0
PyLong_AsSize_t ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_AsUnsignedLongMask DD imagerel _PyLong_AsUnsignedLongMask
	DD	imagerel _PyLong_AsUnsignedLongMask+145
	DD	imagerel $unwind$_PyLong_AsUnsignedLongMask
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_AsUnsignedLongMask DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyLong_AsUnsignedLongMask
_TEXT	SEGMENT
vv$ = 48
_PyLong_AsUnsignedLongMask PROC				; COMDAT

; 632  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 633  :     register PyLongObject *v;
; 634  :     unsigned long x;
; 635  :     Py_ssize_t i;
; 636  :     int sign;
; 637  : 
; 638  :     if (vv == NULL || !PyLong_Check(vv)) {

  00004	48 85 c9	 test	 rcx, rcx
  00007	74 6f		 je	 SHORT $LN8@PyLong_AsU@2
  00009	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000d	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00017	74 5f		 je	 SHORT $LN8@PyLong_AsU@2

; 641  :     }
; 642  :     v = (PyLongObject *)vv;
; 643  :     i = Py_SIZE(v);

  00019	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]

; 644  :     switch (i) {

  0001d	48 8b c2	 mov	 rax, rdx
  00020	48 85 d2	 test	 rdx, rdx
  00023	74 4c		 je	 SHORT $LN5@PyLong_AsU@2
  00025	48 ff c8	 dec	 rax
  00028	74 3f		 je	 SHORT $LN4@PyLong_AsU@2

; 647  :     }
; 648  :     sign = 1;
; 649  :     x = 0;

  0002a	33 c0		 xor	 eax, eax
  0002c	44 8d 48 01	 lea	 r9d, QWORD PTR [rax+1]

; 650  :     if (i < 0) {

  00030	48 85 d2	 test	 rdx, rdx
  00033	79 07		 jns	 SHORT $LN12@PyLong_AsU@2

; 651  :         sign = -1;

  00035	41 83 c9 ff	 or	 r9d, -1

; 652  :         i = -i;

  00039	48 f7 da	 neg	 rdx
$LN12@PyLong_AsU@2:

; 653  :     }
; 654  :     while (--i >= 0) {

  0003c	48 ff ca	 dec	 rdx
  0003f	78 1f		 js	 SHORT $LN1@PyLong_AsU@2
  00041	4c 8d 44 91 70	 lea	 r8, QWORD PTR [rcx+rdx*4+112]
  00046	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL2@PyLong_AsU@2:

; 655  :         x = (x << PyLong_SHIFT) | v->ob_digit[i];

  00050	c1 e0 1e	 shl	 eax, 30
  00053	49 83 e8 04	 sub	 r8, 4
  00057	41 0b 40 04	 or	 eax, DWORD PTR [r8+4]
  0005b	48 ff ca	 dec	 rdx
  0005e	79 f0		 jns	 SHORT $LL2@PyLong_AsU@2
$LN1@PyLong_AsU@2:

; 656  :     }
; 657  :     return x * sign;

  00060	41 0f af c1	 imul	 eax, r9d

; 658  : }

  00064	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00068	c3		 ret	 0
$LN4@PyLong_AsU@2:

; 646  :     case 1: return v->ob_digit[0];

  00069	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]

; 658  : }

  0006c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00070	c3		 ret	 0
$LN5@PyLong_AsU@2:

; 645  :     case 0: return 0;

  00071	33 c0		 xor	 eax, eax

; 658  : }

  00073	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00077	c3		 ret	 0
$LN8@PyLong_AsU@2:

; 639  :         PyErr_BadInternalCall();

  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  0007f	ba 7f 02 00 00	 mov	 edx, 639		; 0000027fH
  00084	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 640  :         return (unsigned long) -1;

  00089	83 c8 ff	 or	 eax, -1			; ffffffffH

; 658  : }

  0008c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00090	c3		 ret	 0
_PyLong_AsUnsignedLongMask ENDP
_TEXT	ENDS
PUBLIC	PyLong_AsUnsignedLongMask
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsUnsignedLongMask DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$PyLong_AsUnsignedLongMask
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyLong_AsUnsignedLongMask DD imagerel $LN7+59
	DD	imagerel $LN7+90
	DD	imagerel $chain$0$PyLong_AsUnsignedLongMask
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyLong_AsUnsignedLongMask DD imagerel $LN7+90
	DD	imagerel $LN7+130
	DD	imagerel $chain$3$PyLong_AsUnsignedLongMask
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyLong_AsUnsignedLongMask DD 040821H
	DD	063408H
	DD	047400H
	DD	imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$PyLong_AsUnsignedLongMask
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyLong_AsUnsignedLongMask DD 020521H
	DD	047405H
	DD	imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$PyLong_AsUnsignedLongMask
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsUnsignedLongMask DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyLong_AsUnsignedLongMask
_TEXT	SEGMENT
op$ = 48
PyLong_AsUnsignedLongMask PROC				; COMDAT

; 662  : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 663  :     PyLongObject *lo;
; 664  :     unsigned long val;
; 665  : 
; 666  :     if (op == NULL) {

  00004	48 85 c9	 test	 rcx, rcx
  00007	75 19		 jne	 SHORT $LN3@PyLong_AsU@3

; 667  :         PyErr_BadInternalCall();

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00010	ba 9b 02 00 00	 mov	 edx, 667		; 0000029bH
  00015	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 668  :         return (unsigned long)-1;

  0001a	83 c8 ff	 or	 eax, -1			; ffffffffH

; 682  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
$LN3@PyLong_AsU@3:

; 669  :     }
; 670  : 
; 671  :     if (PyLong_Check(op)) {

  00022	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00026	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00030	74 09		 je	 SHORT $LN2@PyLong_AsU@3

; 682  : }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00036	e9 00 00 00 00	 jmp	 _PyLong_AsUnsignedLongMask
$LN2@PyLong_AsU@3:
  0003b	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi

; 672  :         return _PyLong_AsUnsignedLongMask(op);
; 673  :     }
; 674  : 
; 675  :     lo = _PyLong_FromNbInt(op);

  00040	e8 00 00 00 00	 call	 _PyLong_FromNbInt
  00045	48 8b f8	 mov	 rdi, rax

; 676  :     if (lo == NULL)

  00048	48 85 c0	 test	 rax, rax
  0004b	75 0d		 jne	 SHORT $LN1@PyLong_AsU@3

; 677  :         return (unsigned long)-1;

  0004d	83 c8 ff	 or	 eax, -1			; ffffffffH
  00050	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 682  : }

  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	c3		 ret	 0
$LN1@PyLong_AsU@3:

; 678  : 
; 679  :     val = _PyLong_AsUnsignedLongMask((PyObject *)lo);

  0005a	48 8b c8	 mov	 rcx, rax
  0005d	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00062	e8 00 00 00 00	 call	 _PyLong_AsUnsignedLongMask

; 680  :     Py_DECREF(lo);

  00067	48 8b cf	 mov	 rcx, rdi
  0006a	8b d8		 mov	 ebx, eax
  0006c	e8 00 00 00 00	 call	 _Py_DecRef
  00071	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 681  :     return val;

  00076	8b c3		 mov	 eax, ebx
  00078	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 682  : }

  0007d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00081	c3		 ret	 0
PyLong_AsUnsignedLongMask ENDP
_TEXT	ENDS
PUBLIC	_PyLong_Sign
; Function compile flags: /Ogtpy
;	COMDAT _PyLong_Sign
_TEXT	SEGMENT
vv$ = 8
_PyLong_Sign PROC					; COMDAT

; 687  :     PyLongObject *v = (PyLongObject *)vv;
; 688  : 
; 689  :     assert(v != NULL);
; 690  :     assert(PyLong_Check(v));
; 691  : 
; 692  :     return Py_SIZE(v) == 0 ? 0 : (Py_SIZE(v) < 0 ? -1 : 1);

  00000	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00004	48 85 d2	 test	 rdx, rdx
  00007	75 03		 jne	 SHORT $LN3@PyLong_Sig
  00009	33 c0		 xor	 eax, eax

; 693  : }

  0000b	c3		 ret	 0
$LN3@PyLong_Sig:

; 687  :     PyLongObject *v = (PyLongObject *)vv;
; 688  : 
; 689  :     assert(v != NULL);
; 690  :     assert(PyLong_Check(v));
; 691  : 
; 692  :     return Py_SIZE(v) == 0 ? 0 : (Py_SIZE(v) < 0 ? -1 : 1);

  0000c	83 c9 ff	 or	 ecx, -1
  0000f	b8 01 00 00 00	 mov	 eax, 1
  00014	48 85 d2	 test	 rdx, rdx
  00017	0f 48 c1	 cmovs	 eax, ecx

; 693  : }

  0001a	c3		 ret	 0
_PyLong_Sign ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@ICDEHKHP@int?5has?5too?5many?5bits?5to?5express@ ; `string'
PUBLIC	_PyLong_NumBits
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_NumBits DD imagerel $LN14
	DD	imagerel $LN14+89
	DD	imagerel $unwind$_PyLong_NumBits
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_NumBits DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0DG@ICDEHKHP@int?5has?5too?5many?5bits?5to?5express@
CONST	SEGMENT
??_C@_0DG@ICDEHKHP@int?5has?5too?5many?5bits?5to?5express@ DB 'int has to'
	DB	'o many bits to express in a platform size_t', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyLong_NumBits
_TEXT	SEGMENT
vv$ = 48
_PyLong_NumBits PROC					; COMDAT

; 697  : {

$LN14:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 698  :     PyLongObject *v = (PyLongObject *)vv;
; 699  :     size_t result = 0;
; 700  :     Py_ssize_t ndigits;
; 701  : 
; 702  :     assert(v != NULL);
; 703  :     assert(PyLong_Check(v));
; 704  :     ndigits = ABS(Py_SIZE(v));

  00004	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00008	33 c0		 xor	 eax, eax
  0000a	48 85 d2	 test	 rdx, rdx
  0000d	79 06		 jns	 SHORT $LN13@PyLong_Num
  0000f	48 f7 da	 neg	 rdx

; 705  :     assert(ndigits == 0 || v->ob_digit[ndigits - 1] != 0);
; 706  :     if (ndigits > 0) {

  00012	48 85 d2	 test	 rdx, rdx
$LN13@PyLong_Num:
  00015	7e 3d		 jle	 SHORT $LN2@PyLong_Num

; 707  :         digit msd = v->ob_digit[ndigits - 1];

  00017	8b 4c 91 6c	 mov	 ecx, DWORD PTR [rcx+rdx*4+108]

; 708  :         if ((size_t)(ndigits - 1) > PY_SIZE_MAX / (size_t)PyLong_SHIFT)

  0001b	48 8d 42 ff	 lea	 rax, QWORD PTR [rdx-1]
  0001f	48 ba 88 88 88
	88 88 88 88 08	 mov	 rdx, 614891469123651720	; 0888888888888888H
  00029	48 3b c2	 cmp	 rax, rdx
  0002c	77 0f		 ja	 SHORT $Overflow$20630

; 709  :             goto Overflow;
; 710  :         result = (size_t)(ndigits - 1) * (size_t)PyLong_SHIFT;

  0002e	48 6b c0 1e	 imul	 rax, 30
$LL4@PyLong_Num:

; 711  :         do {
; 712  :             ++result;

  00032	48 ff c0	 inc	 rax

; 713  :             if (result == 0)

  00035	74 06		 je	 SHORT $Overflow$20630

; 714  :                 goto Overflow;
; 715  :             msd >>= 1;

  00037	d1 e9		 shr	 ecx, 1

; 716  :         } while (msd);

  00039	74 19		 je	 SHORT $LN2@PyLong_Num
  0003b	eb f5		 jmp	 SHORT $LL4@PyLong_Num
$Overflow$20630:

; 717  :     }
; 718  :     return result;
; 719  : 
; 720  :   Overflow:
; 721  :     PyErr_SetString(PyExc_OverflowError, "int has too many bits "
; 722  :                     "to express in a platform size_t");

  0003d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@ICDEHKHP@int?5has?5too?5many?5bits?5to?5express@
  0004b	e8 00 00 00 00	 call	 PyErr_SetString

; 723  :     return (size_t)-1;

  00050	48 83 c8 ff	 or	 rax, -1
$LN2@PyLong_Num:

; 724  : }

  00054	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00058	c3		 ret	 0
_PyLong_NumBits ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@IILJNAIE@byte?5array?5too?5long?5to?5convert?5t@ ; `string'
PUBLIC	_PyLong_FromByteArray
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_FromByteArray DD imagerel $LN33
	DD	imagerel $LN33+395
	DD	imagerel $unwind$_PyLong_FromByteArray
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_FromByteArray DD 0b3501H
	DD	04d435H
	DD	0ac430H
	DD	09742bH
	DD	086426H
	DD	050034207H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_0CG@IILJNAIE@byte?5array?5too?5long?5to?5convert?5t@
CONST	SEGMENT
??_C@_0CG@IILJNAIE@byte?5array?5too?5long?5to?5convert?5t@ DB 'byte array'
	DB	' too long to convert to int', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyLong_FromByteArray
_TEXT	SEGMENT
bytes$ = 64
n$ = 72
little_endian$ = 80
is_signed$ = 88
_PyLong_FromByteArray PROC				; COMDAT

; 729  : {

$LN33:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 730  :     const unsigned char* pstartbyte;    /* LSB of bytes */
; 731  :     int incr;                           /* direction to move pstartbyte */
; 732  :     const unsigned char* pendbyte;      /* MSB of bytes */
; 733  :     size_t numsignificantbytes;         /* number of bytes that matter */
; 734  :     Py_ssize_t ndigits;                 /* number of Python int digits */
; 735  :     PyLongObject* v;                    /* result */
; 736  :     Py_ssize_t idigit = 0;              /* next free index in v->ob_digit */

  00007	33 db		 xor	 ebx, ebx
  00009	41 8b e9	 mov	 ebp, r9d
  0000c	4c 8b d2	 mov	 r10, rdx

; 737  : 
; 738  :     if (n == 0)

  0000f	48 85 d2	 test	 rdx, rdx
  00012	75 0d		 jne	 SHORT $LN17@PyLong_Fro@5

; 739  :         return PyLong_FromLong(0L);

  00014	33 c9		 xor	 ecx, ecx

; 835  : }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	5d		 pop	 rbp
  0001b	5b		 pop	 rbx
  0001c	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN17@PyLong_Fro@5:
  00021	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00026	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0002b	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  00030	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13

; 740  : 
; 741  :     if (little_endian) {

  00035	41 bd 01 00 00
	00		 mov	 r13d, 1
  0003b	45 85 c0	 test	 r8d, r8d
  0003e	74 0d		 je	 SHORT $LN16@PyLong_Fro@5

; 742  :         pstartbyte = bytes;

  00040	48 8b f1	 mov	 rsi, rcx

; 743  :         pendbyte = bytes + n - 1;
; 744  :         incr = 1;

  00043	45 8b e5	 mov	 r12d, r13d
  00046	48 8d 4c 11 ff	 lea	 rcx, QWORD PTR [rcx+rdx-1]

; 745  :     }
; 746  :     else {

  0004b	eb 09		 jmp	 SHORT $LN15@PyLong_Fro@5
$LN16@PyLong_Fro@5:

; 747  :         pstartbyte = bytes + n - 1;

  0004d	48 8d 74 11 ff	 lea	 rsi, QWORD PTR [rcx+rdx-1]

; 748  :         pendbyte = bytes;
; 749  :         incr = -1;

  00052	41 83 cc ff	 or	 r12d, -1
$LN15@PyLong_Fro@5:

; 750  :     }
; 751  : 
; 752  :     if (is_signed)

  00056	45 85 c9	 test	 r9d, r9d
  00059	74 09		 je	 SHORT $LN14@PyLong_Fro@5

; 753  :         is_signed = *pendbyte >= 0x80;

  0005b	80 39 80	 cmp	 BYTE PTR [rcx], 128	; 00000080H
  0005e	8b eb		 mov	 ebp, ebx
  00060	40 0f 93 c5	 setae	 bpl
$LN14@PyLong_Fro@5:

; 754  : 
; 755  :     /* Compute numsignificantbytes.  This consists of finding the most
; 756  :        significant byte.  Leading 0 bytes are insignificant if the number
; 757  :        is positive, and leading 0xff bytes if negative. */
; 758  :     {
; 759  :         size_t i;
; 760  :         const unsigned char* p = pendbyte;
; 761  :         const int pincr = -incr;  /* search MSB to LSB */

  00064	45 8b cc	 mov	 r9d, r12d

; 762  :         const unsigned char insignficant = is_signed ? 0xff : 0x00;

  00067	8b c5		 mov	 eax, ebp

; 763  : 
; 764  :         for (i = 0; i < n; ++i, p += pincr) {

  00069	48 8b d3	 mov	 rdx, rbx
  0006c	41 f7 d9	 neg	 r9d
  0006f	f7 d8		 neg	 eax
  00071	45 1a c0	 sbb	 r8b, r8b
  00074	4d 85 d2	 test	 r10, r10
  00077	74 1a		 je	 SHORT $LN27@PyLong_Fro@5
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@PyLong_Fro@5:

; 765  :             if (*p != insignficant)

  00080	44 38 01	 cmp	 BYTE PTR [rcx], r8b
  00083	75 0e		 jne	 SHORT $LN27@PyLong_Fro@5

; 763  : 
; 764  :         for (i = 0; i < n; ++i, p += pincr) {

  00085	49 63 c1	 movsxd	 rax, r9d
  00088	48 ff c2	 inc	 rdx
  0008b	48 03 c8	 add	 rcx, rax
  0008e	49 3b d2	 cmp	 rdx, r10
  00091	72 ed		 jb	 SHORT $LL13@PyLong_Fro@5
$LN27@PyLong_Fro@5:

; 766  :                 break;
; 767  :         }
; 768  :         numsignificantbytes = n - i;

  00093	49 8b fa	 mov	 rdi, r10
  00096	48 2b fa	 sub	 rdi, rdx

; 769  :         /* 2's-comp is a bit tricky here, e.g. 0xff00 == -0x0100, so
; 770  :            actually has 2 significant bytes.  OTOH, 0xff0001 ==
; 771  :            -0x00ffff, so we wouldn't *need* to bump it there; but we
; 772  :            do for 0xffff = -0x0001.  To be safe without bothering to
; 773  :            check every case, bump it regardless. */
; 774  :         if (is_signed && numsignificantbytes < n)

  00099	85 ed		 test	 ebp, ebp
  0009b	74 08		 je	 SHORT $LN9@PyLong_Fro@5
  0009d	49 3b fa	 cmp	 rdi, r10
  000a0	73 03		 jae	 SHORT $LN9@PyLong_Fro@5

; 775  :             ++numsignificantbytes;

  000a2	48 ff c7	 inc	 rdi
$LN9@PyLong_Fro@5:

; 776  :     }
; 777  : 
; 778  :     /* How many Python int digits do we need?  We have
; 779  :        8*numsignificantbytes bits, and each Python int digit has
; 780  :        PyLong_SHIFT bits, so it's the ceiling of the quotient. */
; 781  :     /* catch overflow before it happens */
; 782  :     if (numsignificantbytes > (PY_SSIZE_T_MAX - PyLong_SHIFT) / 8) {

  000a5	48 b8 fc ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846972 ; 0ffffffffffffffcH
  000af	48 3b f8	 cmp	 rdi, rax
  000b2	76 1a		 jbe	 SHORT $LN8@PyLong_Fro@5

; 783  :         PyErr_SetString(PyExc_OverflowError,
; 784  :                         "byte array too long to convert to int");

  000b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@IILJNAIE@byte?5array?5too?5long?5to?5convert?5t@
  000c2	e8 00 00 00 00	 call	 PyErr_SetString
$LN32@PyLong_Fro@5:

; 785  :         return NULL;

  000c7	33 c0		 xor	 eax, eax
  000c9	e9 a2 00 00 00	 jmp	 $LN31@PyLong_Fro@5
$LN8@PyLong_Fro@5:

; 786  :     }
; 787  :     ndigits = (numsignificantbytes * 8 + PyLong_SHIFT - 1) / PyLong_SHIFT;

  000ce	48 8d 0c fd 1d
	00 00 00	 lea	 rcx, QWORD PTR [rdi*8+29]
  000d6	48 b8 89 88 88
	88 88 88 88 88	 mov	 rax, -8608480567731124087 ; 8888888888888889H
  000e0	48 f7 e1	 mul	 rcx
  000e3	48 c1 ea 04	 shr	 rdx, 4

; 788  :     v = _PyLong_New(ndigits);

  000e7	48 8b ca	 mov	 rcx, rdx
  000ea	e8 00 00 00 00	 call	 _PyLong_New
  000ef	4c 8b d8	 mov	 r11, rax

; 789  :     if (v == NULL)

  000f2	48 85 c0	 test	 rax, rax

; 790  :         return NULL;

  000f5	74 d0		 je	 SHORT $LN32@PyLong_Fro@5

; 791  : 
; 792  :     /* Copy the bits over.  The tricky parts are computing 2's-comp on
; 793  :        the fly for signed numbers, and dealing with the mismatch between
; 794  :        8-bit bytes and (probably) 15-bit Python digits.*/
; 795  :     {
; 796  :         size_t i;
; 797  :         twodigits carry = 1;                    /* for 2's-comp calculation */
; 798  :         twodigits accum = 0;                    /* sliding register */

  000f7	48 8b d3	 mov	 rdx, rbx

; 799  :         unsigned int accumbits = 0;             /* number of bits in accum */

  000fa	8b cb		 mov	 ecx, ebx

; 800  :         const unsigned char* p = pstartbyte;
; 801  : 
; 802  :         for (i = 0; i < numsignificantbytes; ++i, p += incr) {

  000fc	48 85 ff	 test	 rdi, rdi
  000ff	74 5c		 je	 SHORT $LN1@PyLong_Fro@5

; 822  :                 assert(accumbits < PyLong_SHIFT);
; 823  :             }
; 824  :         }
; 825  :         assert(accumbits < PyLong_SHIFT);
; 826  :         if (accumbits) {

  00101	4d 63 cc	 movsxd	 r9, r12d
  00104	4c 8d 40 70	 lea	 r8, QWORD PTR [rax+112]
$LL6@PyLong_Fro@5:

; 803  :             twodigits thisbyte = *p;
; 804  :             /* Compute correction for 2's comp, if needed. */
; 805  :             if (is_signed) {

  00108	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0010b	85 ed		 test	 ebp, ebp
  0010d	74 13		 je	 SHORT $LN3@PyLong_Fro@5

; 806  :                 thisbyte = (0xff ^ thisbyte) + carry;

  0010f	48 35 ff 00 00
	00		 xor	 rax, 255		; 000000ffH
  00115	49 03 c5	 add	 rax, r13

; 807  :                 carry = thisbyte >> 8;

  00118	4c 8b e8	 mov	 r13, rax

; 808  :                 thisbyte &= 0xff;

  0011b	0f b6 c0	 movzx	 eax, al
  0011e	49 c1 ed 08	 shr	 r13, 8
$LN3@PyLong_Fro@5:

; 809  :             }
; 810  :             /* Because we're going LSB to MSB, thisbyte is
; 811  :                more significant than what's already in accum,
; 812  :                so needs to be prepended to accum. */
; 813  :             accum |= (twodigits)thisbyte << accumbits;

  00122	48 d3 e0	 shl	 rax, cl

; 814  :             accumbits += 8;

  00125	83 c1 08	 add	 ecx, 8
  00128	48 0b d0	 or	 rdx, rax

; 815  :             if (accumbits >= PyLong_SHIFT) {

  0012b	83 f9 1e	 cmp	 ecx, 30
  0012e	72 19		 jb	 SHORT $LN5@PyLong_Fro@5

; 816  :                 /* There's enough to fill a Python digit. */
; 817  :                 assert(idigit < ndigits);
; 818  :                 v->ob_digit[idigit] = (digit)(accum & PyLong_MASK);

  00130	8b c2		 mov	 eax, edx

; 819  :                 ++idigit;

  00132	49 83 c0 04	 add	 r8, 4
  00136	48 ff c3	 inc	 rbx
  00139	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH

; 820  :                 accum >>= PyLong_SHIFT;

  0013e	48 c1 ea 1e	 shr	 rdx, 30

; 821  :                 accumbits -= PyLong_SHIFT;

  00142	83 c1 e2	 add	 ecx, -30		; ffffffe2H
  00145	41 89 40 fc	 mov	 DWORD PTR [r8-4], eax
$LN5@PyLong_Fro@5:

; 800  :         const unsigned char* p = pstartbyte;
; 801  : 
; 802  :         for (i = 0; i < numsignificantbytes; ++i, p += incr) {

  00149	49 03 f1	 add	 rsi, r9
  0014c	48 ff cf	 dec	 rdi
  0014f	75 b7		 jne	 SHORT $LL6@PyLong_Fro@5

; 822  :                 assert(accumbits < PyLong_SHIFT);
; 823  :             }
; 824  :         }
; 825  :         assert(accumbits < PyLong_SHIFT);
; 826  :         if (accumbits) {

  00151	85 c9		 test	 ecx, ecx
  00153	74 08		 je	 SHORT $LN1@PyLong_Fro@5

; 827  :             assert(idigit < ndigits);
; 828  :             v->ob_digit[idigit] = (digit)accum;

  00155	41 89 54 9b 70	 mov	 DWORD PTR [r11+rbx*4+112], edx

; 829  :             ++idigit;

  0015a	48 ff c3	 inc	 rbx
$LN1@PyLong_Fro@5:

; 830  :         }
; 831  :     }
; 832  : 
; 833  :     Py_SIZE(v) = is_signed ? -idigit : idigit;

  0015d	85 ed		 test	 ebp, ebp
  0015f	74 03		 je	 SHORT $LN20@PyLong_Fro@5
  00161	48 f7 db	 neg	 rbx
$LN20@PyLong_Fro@5:

; 834  :     return (PyObject *)long_normalize(v);

  00164	49 8b cb	 mov	 rcx, r11
  00167	49 89 5b 60	 mov	 QWORD PTR [r11+96], rbx
  0016b	e8 00 00 00 00	 call	 long_normalize
$LN31@PyLong_Fro@5:
  00170	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  00175	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0017a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0017f	4c 8b 6c 24 20	 mov	 r13, QWORD PTR [rsp+32]

; 835  : }

  00184	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00188	5d		 pop	 rbp
  00189	5b		 pop	 rbx
  0018a	c3		 ret	 0
_PyLong_FromByteArray ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@KCBHMDHM@int?5too?5big?5to?5convert?$AA@ ; `string'
PUBLIC	??_C@_0CH@PHDOCLKE@can?8t?5convert?5negative?5int?5to?5un@ ; `string'
PUBLIC	_PyLong_AsByteArray
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_AsByteArray DD imagerel $LN43
	DD	imagerel $LN43+104
	DD	imagerel $unwind$_PyLong_AsByteArray
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_PyLong_AsByteArray DD imagerel $LN43+104
	DD	imagerel $LN43+394
	DD	imagerel $chain$1$_PyLong_AsByteArray
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_PyLong_AsByteArray DD imagerel $LN43+394
	DD	imagerel $LN43+455
	DD	imagerel $chain$3$_PyLong_AsByteArray
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_PyLong_AsByteArray DD 040021H
	DD	0cf400H
	DD	0b5400H
	DD	imagerel $LN43
	DD	imagerel $LN43+104
	DD	imagerel $unwind$_PyLong_AsByteArray
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_PyLong_AsByteArray DD 040a21H
	DD	0cf40aH
	DD	0b5405H
	DD	imagerel $LN43
	DD	imagerel $LN43+104
	DD	imagerel $unwind$_PyLong_AsByteArray
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_AsByteArray DD 081101H
	DD	0d3411H
	DD	0e00d3211H
	DD	0c009d00bH
	DD	060067007H
xdata	ENDS
;	COMDAT ??_C@_0BH@KCBHMDHM@int?5too?5big?5to?5convert?$AA@
CONST	SEGMENT
??_C@_0BH@KCBHMDHM@int?5too?5big?5to?5convert?$AA@ DB 'int too big to con'
	DB	'vert', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@PHDOCLKE@can?8t?5convert?5negative?5int?5to?5un@
CONST	SEGMENT
??_C@_0CH@PHDOCLKE@can?8t?5convert?5negative?5int?5to?5un@ DB 'can''t con'
	DB	'vert negative int to unsigned', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyLong_AsByteArray
_TEXT	SEGMENT
carry$1$ = 80
v$ = 80
bytes$ = 88
n$ = 96
little_endian$ = 104
is_signed$ = 112
_PyLong_AsByteArray PROC				; COMDAT

; 841  : {

$LN43:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 842  :     Py_ssize_t i;               /* index into v->ob_digit */
; 843  :     Py_ssize_t ndigits;         /* |v->ob_size| */
; 844  :     twodigits accum;            /* sliding register */
; 845  :     unsigned int accumbits;     /* # bits in accum */
; 846  :     int do_twos_comp;           /* store 2's-comp?  is_signed and v < 0 */
; 847  :     digit carry;                /* for computing 2's-comp */
; 848  :     size_t j;                   /* # bytes filled */
; 849  :     unsigned char* p;           /* pointer to next byte in bytes */
; 850  :     int pincr;                  /* direction to move p */
; 851  : 
; 852  :     assert(v != NULL && PyLong_Check(v));
; 853  : 
; 854  :     if (Py_SIZE(v) < 0) {

  00011	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]
  00015	44 8b 6c 24 70	 mov	 r13d, DWORD PTR is_signed$[rsp]
  0001a	45 33 f6	 xor	 r14d, r14d
  0001d	4d 8b d0	 mov	 r10, r8
  00020	48 8b c1	 mov	 rax, rcx
  00023	41 8d 5e 01	 lea	 ebx, QWORD PTR [r14+1]
  00027	48 85 ff	 test	 rdi, rdi
  0002a	79 35		 jns	 SHORT $LN26@PyLong_AsB

; 855  :         ndigits = -(Py_SIZE(v));

  0002c	48 f7 df	 neg	 rdi

; 856  :         if (!is_signed) {

  0002f	45 85 ed	 test	 r13d, r13d
  00032	75 28		 jne	 SHORT $LN25@PyLong_AsB

; 857  :             PyErr_SetString(PyExc_OverflowError,
; 858  :                             "can't convert negative int to unsigned");

  00034	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@PHDOCLKE@can?8t?5convert?5negative?5int?5to?5un@
  00042	e8 00 00 00 00	 call	 PyErr_SetString

; 859  :             return -1;

  00047	83 c8 ff	 or	 eax, -1

; 967  : 
; 968  : }

  0004a	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	41 5e		 pop	 r14
  00055	41 5d		 pop	 r13
  00057	41 5c		 pop	 r12
  00059	5f		 pop	 rdi
  0005a	5e		 pop	 rsi
  0005b	c3		 ret	 0
$LN25@PyLong_AsB:

; 860  :         }
; 861  :         do_twos_comp = 1;

  0005c	44 8b e3	 mov	 r12d, ebx

; 862  :     }
; 863  :     else {

  0005f	eb 03		 jmp	 SHORT $LN24@PyLong_AsB
$LN26@PyLong_AsB:

; 864  :         ndigits = Py_SIZE(v);
; 865  :         do_twos_comp = 0;

  00061	45 8b e6	 mov	 r12d, r14d
$LN24@PyLong_AsB:

; 866  :     }
; 867  : 
; 868  :     if (little_endian) {

  00064	48 83 ce ff	 or	 rsi, -1
  00068	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  0006d	4c 89 7c 24 60	 mov	 QWORD PTR [rsp+96], r15
  00072	45 85 c9	 test	 r9d, r9d
  00075	75 07		 jne	 SHORT $LN22@PyLong_AsB

; 869  :         p = bytes;
; 870  :         pincr = 1;
; 871  :     }
; 872  :     else {
; 873  :         p = bytes + n - 1;

  00077	4a 8d 54 02 ff	 lea	 rdx, QWORD PTR [rdx+r8-1]

; 874  :         pincr = -1;

  0007c	8b de		 mov	 ebx, esi
$LN22@PyLong_AsB:

; 883  :     accum = 0;
; 884  :     accumbits = 0;
; 885  :     carry = do_twos_comp ? 1 : 0;

  0007e	45 85 e4	 test	 r12d, r12d
  00081	45 8b c6	 mov	 r8d, r14d
  00084	4d 8b ce	 mov	 r9, r14
  00087	41 0f 95 c0	 setne	 r8b
  0008b	4d 8b de	 mov	 r11, r14
  0008e	41 8b ce	 mov	 ecx, r14d
  00091	44 89 44 24 50	 mov	 DWORD PTR carry$1$[rsp], r8d

; 886  :     for (i = 0; i < ndigits; ++i) {

  00096	49 8b ee	 mov	 rbp, r14
  00099	48 85 ff	 test	 rdi, rdi
  0009c	0f 8e ed 00 00
	00		 jle	 $LN10@PyLong_AsB

; 875  :     }
; 876  : 
; 877  :     /* Copy over all the Python digits.
; 878  :        It's crucial that every Python digit except for the MSD contribute
; 879  :        exactly PyLong_SHIFT bits to the total, so first assert that the int is
; 880  :        normalized. */
; 881  :     assert(ndigits == 0 || v->ob_digit[ndigits - 1] != 0);
; 882  :     j = 0;

  000a2	4c 8d 68 70	 lea	 r13, QWORD PTR [rax+112]
$LL21@PyLong_AsB:

; 887  :         digit thisdigit = v->ob_digit[i];

  000a6	45 8b 45 00	 mov	 r8d, DWORD PTR [r13]

; 888  :         if (do_twos_comp) {

  000aa	45 85 e4	 test	 r12d, r12d
  000ad	74 1d		 je	 SHORT $LN18@PyLong_AsB

; 889  :             thisdigit = (thisdigit ^ PyLong_MASK) + carry;

  000af	41 81 f0 ff ff
	ff 3f		 xor	 r8d, 1073741823		; 3fffffffH
  000b6	44 03 44 24 50	 add	 r8d, DWORD PTR carry$1$[rsp]

; 890  :             carry = thisdigit >> PyLong_SHIFT;

  000bb	41 8b c0	 mov	 eax, r8d
  000be	c1 e8 1e	 shr	 eax, 30

; 891  :             thisdigit &= PyLong_MASK;

  000c1	41 81 e0 ff ff
	ff 3f		 and	 r8d, 1073741823		; 3fffffffH
  000c8	89 44 24 50	 mov	 DWORD PTR carry$1$[rsp], eax
$LN18@PyLong_AsB:

; 892  :         }
; 893  :         /* Because we're going LSB to MSB, thisdigit is more
; 894  :            significant than what's already in accum, so needs to be
; 895  :            prepended to accum. */
; 896  :         accum |= (twodigits)thisdigit << accumbits;

  000cc	41 8b c0	 mov	 eax, r8d
  000cf	48 d3 e0	 shl	 rax, cl
  000d2	4c 0b d8	 or	 r11, rax

; 897  : 
; 898  :         /* The most-significant digit may be (probably is) at least
; 899  :            partly empty. */
; 900  :         if (i == ndigits - 1) {

  000d5	48 8d 47 ff	 lea	 rax, QWORD PTR [rdi-1]
  000d9	48 3b e8	 cmp	 rbp, rax
  000dc	75 1b		 jne	 SHORT $LN17@PyLong_AsB

; 901  :             /* Count # of sign bits -- they needn't be stored,
; 902  :              * although for signed conversion we need later to
; 903  :              * make sure at least one sign bit gets stored. */
; 904  :             digit s = do_twos_comp ? thisdigit ^ PyLong_MASK : thisdigit;

  000de	45 85 e4	 test	 r12d, r12d
  000e1	74 07		 je	 SHORT $LN29@PyLong_AsB
  000e3	41 81 f0 ff ff
	ff 3f		 xor	 r8d, 1073741823		; 3fffffffH
$LN29@PyLong_AsB:

; 905  :             while (s != 0) {

  000ea	45 85 c0	 test	 r8d, r8d
  000ed	74 0d		 je	 SHORT $LN33@PyLong_AsB
  000ef	90		 npad	 1
$LL16@PyLong_AsB:

; 906  :                 s >>= 1;
; 907  :                 accumbits++;

  000f0	ff c1		 inc	 ecx
  000f2	41 d1 e8	 shr	 r8d, 1
  000f5	75 f9		 jne	 SHORT $LL16@PyLong_AsB

; 908  :             }
; 909  :         }
; 910  :         else

  000f7	eb 03		 jmp	 SHORT $LN33@PyLong_AsB
$LN17@PyLong_AsB:

; 911  :             accumbits += PyLong_SHIFT;

  000f9	83 c1 1e	 add	 ecx, 30
$LN33@PyLong_AsB:

; 912  : 
; 913  :         /* Store as many bytes as possible. */
; 914  :         while (accumbits >= 8) {

  000fc	83 f9 08	 cmp	 ecx, 8
  000ff	72 21		 jb	 SHORT $LN20@PyLong_AsB
$LL13@PyLong_AsB:

; 915  :             if (j >= n)

  00101	4d 3b ca	 cmp	 r9, r10
  00104	0f 83 a6 00 00
	00		 jae	 $Overflow$20752

; 916  :                 goto Overflow;
; 917  :             ++j;
; 918  :             *p = (unsigned char)(accum & 0xff);

  0010a	44 88 1a	 mov	 BYTE PTR [rdx], r11b

; 919  :             p += pincr;

  0010d	48 63 c3	 movsxd	 rax, ebx

; 920  :             accumbits -= 8;

  00110	83 c1 f8	 add	 ecx, -8			; fffffff8H
  00113	49 ff c1	 inc	 r9

; 921  :             accum >>= 8;

  00116	49 c1 eb 08	 shr	 r11, 8
  0011a	48 03 d0	 add	 rdx, rax
  0011d	83 f9 08	 cmp	 ecx, 8
  00120	73 df		 jae	 SHORT $LL13@PyLong_AsB
$LN20@PyLong_AsB:

; 886  :     for (i = 0; i < ndigits; ++i) {

  00122	48 ff c5	 inc	 rbp
  00125	49 83 c5 04	 add	 r13, 4
  00129	48 3b ef	 cmp	 rbp, rdi
  0012c	0f 8c 74 ff ff
	ff		 jl	 $LL21@PyLong_AsB

; 922  :         }
; 923  :     }
; 924  : 
; 925  :     /* Store the straggler (if any). */
; 926  :     assert(accumbits < 8);
; 927  :     assert(carry == 0);  /* else do_twos_comp and *every* digit was 0 */
; 928  :     if (accumbits > 0) {

  00132	85 c9		 test	 ecx, ecx
  00134	74 54		 je	 SHORT $LN40@PyLong_AsB

; 929  :         if (j >= n)

  00136	4d 3b ca	 cmp	 r9, r10
  00139	73 75		 jae	 SHORT $Overflow$20752

; 930  :             goto Overflow;
; 931  :         ++j;

  0013b	49 ff c1	 inc	 r9

; 932  :         if (do_twos_comp) {

  0013e	45 85 e4	 test	 r12d, r12d
  00141	74 06		 je	 SHORT $LN8@PyLong_AsB

; 933  :             /* Fill leading bits of the byte with sign bits
; 934  :                (appropriately pretending that the int had an
; 935  :                infinite supply of sign bits). */
; 936  :             accum |= (~(twodigits)0) << accumbits;

  00143	48 d3 e6	 shl	 rsi, cl
  00146	4c 0b de	 or	 r11, rsi
$LN8@PyLong_AsB:

; 937  :         }
; 938  :         *p = (unsigned char)(accum & 0xff);
; 939  :         p += pincr;

  00149	48 63 c3	 movsxd	 rax, ebx
  0014c	44 88 1a	 mov	 BYTE PTR [rdx], r11b
  0014f	48 03 d0	 add	 rdx, rax
$LN4@PyLong_AsB:

; 951  :         else
; 952  :             goto Overflow;
; 953  :     }
; 954  : 
; 955  :     /* Fill remaining bytes with copies of the sign bit. */
; 956  :     {
; 957  :         unsigned char signbyte = do_twos_comp ? 0xffU : 0U;

  00152	41 f7 dc	 neg	 r12d
  00155	1a c0		 sbb	 al, al

; 958  :         for ( ; j < n; ++j, p += pincr)

  00157	4d 3b ca	 cmp	 r9, r10
  0015a	73 10		 jae	 SHORT $LN1@PyLong_AsB
  0015c	48 63 cb	 movsxd	 rcx, ebx
  0015f	4d 2b d1	 sub	 r10, r9
$LL3@PyLong_AsB:

; 959  :             *p = signbyte;

  00162	88 02		 mov	 BYTE PTR [rdx], al
  00164	48 03 d1	 add	 rdx, rcx
  00167	49 ff ca	 dec	 r10
  0016a	75 f6		 jne	 SHORT $LL3@PyLong_AsB
$LN1@PyLong_AsB:

; 960  :     }
; 961  : 
; 962  :     return 0;

  0016c	33 c0		 xor	 eax, eax
$LN42@PyLong_AsB:
  0016e	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00173	4c 8b 7c 24 60	 mov	 r15, QWORD PTR [rsp+96]

; 967  : 
; 968  : }

  00178	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  0017d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00181	41 5e		 pop	 r14
  00183	41 5d		 pop	 r13
  00185	41 5c		 pop	 r12
  00187	5f		 pop	 rdi
  00188	5e		 pop	 rsi
  00189	c3		 ret	 0
$LN40@PyLong_AsB:

; 890  :             carry = thisdigit >> PyLong_SHIFT;

  0018a	44 8b 6c 24 70	 mov	 r13d, DWORD PTR is_signed$[rsp]
$LN10@PyLong_AsB:

; 940  :     }
; 941  :     else if (j == n && n > 0 && is_signed) {

  0018f	4d 3b ca	 cmp	 r9, r10
  00192	75 be		 jne	 SHORT $LN4@PyLong_AsB
  00194	4d 85 d2	 test	 r10, r10
  00197	74 b9		 je	 SHORT $LN4@PyLong_AsB
  00199	45 85 ed	 test	 r13d, r13d
  0019c	74 b4		 je	 SHORT $LN4@PyLong_AsB

; 942  :         /* The main loop filled the byte array exactly, so the code
; 943  :            just above didn't get to ensure there's a sign bit, and the
; 944  :            loop below wouldn't add one either.  Make sure a sign bit
; 945  :            exists. */
; 946  :         unsigned char msb = *(p - pincr);
; 947  :         int sign_bit_set = msb >= 0x80;
; 948  :         assert(accumbits == 0);
; 949  :         if (sign_bit_set == do_twos_comp)

  0019e	48 63 c3	 movsxd	 rax, ebx
  001a1	48 2b d0	 sub	 rdx, rax
  001a4	80 3a 80	 cmp	 BYTE PTR [rdx], 128	; 00000080H
  001a7	41 0f 93 c6	 setae	 r14b
  001ab	45 3b f4	 cmp	 r14d, r12d

; 950  :             return 0;

  001ae	74 bc		 je	 SHORT $LN1@PyLong_AsB
$Overflow$20752:

; 963  : 
; 964  :   Overflow:
; 965  :     PyErr_SetString(PyExc_OverflowError, "int too big to convert");

  001b0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  001b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@KCBHMDHM@int?5too?5big?5to?5convert?$AA@
  001be	e8 00 00 00 00	 call	 PyErr_SetString

; 966  :     return -1;

  001c3	8b c6		 mov	 eax, esi
  001c5	eb a7		 jmp	 SHORT $LN42@PyLong_AsB
_PyLong_AsByteArray ENDP
_TEXT	ENDS
PUBLIC	PyLong_FromLongLong
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromLongLong DD imagerel $LN20
	DD	imagerel $LN20+171
	DD	imagerel $unwind$PyLong_FromLongLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromLongLong DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyLong_FromLongLong
_TEXT	SEGMENT
ival$ = 48
PyLong_FromLongLong PROC				; COMDAT

; 1043 : {

$LN20:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1044 :     PyLongObject *v;
; 1045 :     unsigned PY_LONG_LONG abs_ival;
; 1046 :     unsigned PY_LONG_LONG t;  /* unsigned so >> doesn't propagate sign bit */
; 1047 :     int ndigits = 0;

  0000f	33 ff		 xor	 edi, edi

; 1048 :     int negative = 0;
; 1049 : 
; 1050 :     CHECK_SMALL_INT(ival);

  00011	48 8d 41 05	 lea	 rax, QWORD PTR [rcx+5]
  00015	48 8b d9	 mov	 rbx, rcx
  00018	8b f7		 mov	 esi, edi
  0001a	48 3d 05 01 00
	00		 cmp	 rax, 261		; 00000105H
  00020	77 14		 ja	 SHORT $LN10@PyLong_Fro@6

; 1078 :         }
; 1079 :     }
; 1080 :     return (PyObject *)v;
; 1081 : }

  00022	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00027	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	e9 00 00 00 00	 jmp	 get_small_int
$LN10@PyLong_Fro@6:

; 1051 :     if (ival < 0) {

  00036	48 85 c9	 test	 rcx, rcx
  00039	79 08		 jns	 SHORT $LN7@PyLong_Fro@6

; 1052 :         /* avoid signed overflow on negation;  see comments
; 1053 :            in PyLong_FromLong above. */
; 1054 :         abs_ival = (unsigned PY_LONG_LONG)(-1-ival) + 1;

  0003b	48 f7 db	 neg	 rbx

; 1055 :         negative = 1;

  0003e	be 01 00 00 00	 mov	 esi, 1
$LN7@PyLong_Fro@6:

; 1056 :     }
; 1057 :     else {
; 1058 :         abs_ival = (unsigned PY_LONG_LONG)ival;
; 1059 :     }
; 1060 : 
; 1061 :     /* Count the number of Python digits.
; 1062 :        We used to pick 5 ("big enough for anything"), but that's a
; 1063 :        waste of time and space given that 5*15 = 75 bits are rarely
; 1064 :        needed. */
; 1065 :     t = abs_ival;

  00043	48 8b c3	 mov	 rax, rbx

; 1066 :     while (t) {

  00046	48 85 db	 test	 rbx, rbx
  00049	74 10		 je	 SHORT $LN4@PyLong_Fro@6
  0004b	0f 1f 44 00 00	 npad	 5
$LL5@PyLong_Fro@6:

; 1067 :         ++ndigits;
; 1068 :         t >>= PyLong_SHIFT;

  00050	48 c1 e8 1e	 shr	 rax, 30
  00054	ff c7		 inc	 edi
  00056	48 85 c0	 test	 rax, rax
  00059	75 f5		 jne	 SHORT $LL5@PyLong_Fro@6
$LN4@PyLong_Fro@6:

; 1069 :     }
; 1070 :     v = _PyLong_New(ndigits);

  0005b	48 63 cf	 movsxd	 rcx, edi
  0005e	e8 00 00 00 00	 call	 _PyLong_New
  00063	4c 8b d8	 mov	 r11, rax

; 1071 :     if (v != NULL) {

  00066	48 85 c0	 test	 rax, rax
  00069	74 2d		 je	 SHORT $LN1@PyLong_Fro@6

; 1072 :         digit *p = v->ob_digit;

  0006b	48 8d 48 70	 lea	 rcx, QWORD PTR [rax+112]

; 1073 :         Py_SIZE(v) = negative ? -ndigits : ndigits;

  0006f	85 f6		 test	 esi, esi
  00071	74 02		 je	 SHORT $LN14@PyLong_Fro@6
  00073	f7 df		 neg	 edi
$LN14@PyLong_Fro@6:
  00075	48 63 c7	 movsxd	 rax, edi
  00078	49 89 43 60	 mov	 QWORD PTR [r11+96], rax

; 1074 :         t = abs_ival;
; 1075 :         while (t) {

  0007c	48 85 db	 test	 rbx, rbx
  0007f	74 17		 je	 SHORT $LN1@PyLong_Fro@6
$LL2@PyLong_Fro@6:

; 1076 :             *p++ = (digit)(t & PyLong_MASK);

  00081	8b c3		 mov	 eax, ebx

; 1077 :             t >>= PyLong_SHIFT;

  00083	48 c1 eb 1e	 shr	 rbx, 30
  00087	48 83 c1 04	 add	 rcx, 4
  0008b	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00090	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  00093	48 85 db	 test	 rbx, rbx
  00096	75 e9		 jne	 SHORT $LL2@PyLong_Fro@6
$LN1@PyLong_Fro@6:

; 1078 :         }
; 1079 :     }
; 1080 :     return (PyObject *)v;
; 1081 : }

  00098	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000a2	49 8b c3	 mov	 rax, r11
  000a5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a9	5f		 pop	 rdi
  000aa	c3		 ret	 0
PyLong_FromLongLong ENDP
_TEXT	ENDS
PUBLIC	PyLong_FromUnsignedLongLong
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromUnsignedLongLong DD imagerel $LN13
	DD	imagerel $LN13+131
	DD	imagerel $unwind$PyLong_FromUnsignedLongLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromUnsignedLongLong DD 042501H
	DD	067425H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyLong_FromUnsignedLongLong
_TEXT	SEGMENT
ival$ = 48
PyLong_FromUnsignedLongLong PROC			; COMDAT

; 1087 : {

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1088 :     PyLongObject *v;
; 1089 :     unsigned PY_LONG_LONG t;
; 1090 :     int ndigits = 0;

  00009	33 c9		 xor	 ecx, ecx

; 1091 : 
; 1092 :     if (ival < PyLong_BASE)

  0000b	48 81 fb 00 00
	00 40		 cmp	 rbx, 1073741824		; 40000000H
  00012	73 0c		 jae	 SHORT $LN6@PyLong_Fro@7

; 1093 :         return PyLong_FromLong((long)ival);

  00014	8b cb		 mov	 ecx, ebx

; 1107 :         }
; 1108 :     }
; 1109 :     return (PyObject *)v;
; 1110 : }

  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5b		 pop	 rbx
  0001b	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN6@PyLong_Fro@7:
  00020	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 1094 :     /* Count the number of Python digits. */
; 1095 :     t = (unsigned PY_LONG_LONG)ival;

  00025	48 8b c3	 mov	 rax, rbx

; 1096 :     while (t) {

  00028	48 85 db	 test	 rbx, rbx
  0002b	74 0e		 je	 SHORT $LN4@PyLong_Fro@7
  0002d	0f 1f 00	 npad	 3
$LL5@PyLong_Fro@7:

; 1097 :         ++ndigits;
; 1098 :         t >>= PyLong_SHIFT;

  00030	48 c1 e8 1e	 shr	 rax, 30
  00034	ff c1		 inc	 ecx
  00036	48 85 c0	 test	 rax, rax
  00039	75 f5		 jne	 SHORT $LL5@PyLong_Fro@7
$LN4@PyLong_Fro@7:

; 1099 :     }
; 1100 :     v = _PyLong_New(ndigits);

  0003b	48 63 f9	 movsxd	 rdi, ecx
  0003e	48 8b cf	 mov	 rcx, rdi
  00041	e8 00 00 00 00	 call	 _PyLong_New

; 1101 :     if (v != NULL) {

  00046	48 85 c0	 test	 rax, rax
  00049	74 2d		 je	 SHORT $LN1@PyLong_Fro@7

; 1102 :         digit *p = v->ob_digit;

  0004b	48 8d 50 70	 lea	 rdx, QWORD PTR [rax+112]

; 1103 :         Py_SIZE(v) = ndigits;

  0004f	48 89 78 60	 mov	 QWORD PTR [rax+96], rdi

; 1104 :         while (ival) {

  00053	48 85 db	 test	 rbx, rbx
  00056	74 20		 je	 SHORT $LN1@PyLong_Fro@7
  00058	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@PyLong_Fro@7:

; 1105 :             *p++ = (digit)(ival & PyLong_MASK);

  00060	8b cb		 mov	 ecx, ebx

; 1106 :             ival >>= PyLong_SHIFT;

  00062	48 c1 eb 1e	 shr	 rbx, 30
  00066	48 83 c2 04	 add	 rdx, 4
  0006a	81 e1 ff ff ff
	3f		 and	 ecx, 1073741823		; 3fffffffH
  00070	89 4a fc	 mov	 DWORD PTR [rdx-4], ecx
  00073	48 85 db	 test	 rbx, rbx
  00076	75 e8		 jne	 SHORT $LL2@PyLong_Fro@7
$LN1@PyLong_Fro@7:
  00078	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1107 :         }
; 1108 :     }
; 1109 :     return (PyObject *)v;
; 1110 : }

  0007d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00081	5b		 pop	 rbx
  00082	c3		 ret	 0
PyLong_FromUnsignedLongLong ENDP
_TEXT	ENDS
PUBLIC	PyLong_FromSsize_t
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromSsize_t DD imagerel $LN20
	DD	imagerel $LN20+171
	DD	imagerel $unwind$PyLong_FromSsize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromSsize_t DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyLong_FromSsize_t
_TEXT	SEGMENT
ival$ = 48
PyLong_FromSsize_t PROC					; COMDAT

; 1116 : {

$LN20:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1117 :     PyLongObject *v;
; 1118 :     size_t abs_ival;
; 1119 :     size_t t;  /* unsigned so >> doesn't propagate sign bit */
; 1120 :     int ndigits = 0;

  0000f	33 ff		 xor	 edi, edi

; 1121 :     int negative = 0;
; 1122 : 
; 1123 :     CHECK_SMALL_INT(ival);

  00011	48 8d 41 05	 lea	 rax, QWORD PTR [rcx+5]
  00015	48 8b d9	 mov	 rbx, rcx
  00018	8b f7		 mov	 esi, edi
  0001a	48 3d 05 01 00
	00		 cmp	 rax, 261		; 00000105H
  00020	77 14		 ja	 SHORT $LN10@PyLong_Fro@8

; 1147 :         }
; 1148 :     }
; 1149 :     return (PyObject *)v;
; 1150 : }

  00022	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00027	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	e9 00 00 00 00	 jmp	 get_small_int
$LN10@PyLong_Fro@8:

; 1124 :     if (ival < 0) {

  00036	48 85 c9	 test	 rcx, rcx
  00039	79 08		 jns	 SHORT $LN7@PyLong_Fro@8

; 1125 :         /* avoid signed overflow when ival = SIZE_T_MIN */
; 1126 :         abs_ival = (size_t)(-1-ival)+1;

  0003b	48 f7 db	 neg	 rbx

; 1127 :         negative = 1;

  0003e	be 01 00 00 00	 mov	 esi, 1
$LN7@PyLong_Fro@8:

; 1128 :     }
; 1129 :     else {
; 1130 :         abs_ival = (size_t)ival;
; 1131 :     }
; 1132 : 
; 1133 :     /* Count the number of Python digits. */
; 1134 :     t = abs_ival;

  00043	48 8b c3	 mov	 rax, rbx

; 1135 :     while (t) {

  00046	48 85 db	 test	 rbx, rbx
  00049	74 10		 je	 SHORT $LN4@PyLong_Fro@8
  0004b	0f 1f 44 00 00	 npad	 5
$LL5@PyLong_Fro@8:

; 1136 :         ++ndigits;
; 1137 :         t >>= PyLong_SHIFT;

  00050	48 c1 e8 1e	 shr	 rax, 30
  00054	ff c7		 inc	 edi
  00056	48 85 c0	 test	 rax, rax
  00059	75 f5		 jne	 SHORT $LL5@PyLong_Fro@8
$LN4@PyLong_Fro@8:

; 1138 :     }
; 1139 :     v = _PyLong_New(ndigits);

  0005b	48 63 cf	 movsxd	 rcx, edi
  0005e	e8 00 00 00 00	 call	 _PyLong_New
  00063	4c 8b d8	 mov	 r11, rax

; 1140 :     if (v != NULL) {

  00066	48 85 c0	 test	 rax, rax
  00069	74 2d		 je	 SHORT $LN1@PyLong_Fro@8

; 1141 :         digit *p = v->ob_digit;

  0006b	48 8d 48 70	 lea	 rcx, QWORD PTR [rax+112]

; 1142 :         Py_SIZE(v) = negative ? -ndigits : ndigits;

  0006f	85 f6		 test	 esi, esi
  00071	74 02		 je	 SHORT $LN14@PyLong_Fro@8
  00073	f7 df		 neg	 edi
$LN14@PyLong_Fro@8:
  00075	48 63 c7	 movsxd	 rax, edi
  00078	49 89 43 60	 mov	 QWORD PTR [r11+96], rax

; 1143 :         t = abs_ival;
; 1144 :         while (t) {

  0007c	48 85 db	 test	 rbx, rbx
  0007f	74 17		 je	 SHORT $LN1@PyLong_Fro@8
$LL2@PyLong_Fro@8:

; 1145 :             *p++ = (digit)(t & PyLong_MASK);

  00081	8b c3		 mov	 eax, ebx

; 1146 :             t >>= PyLong_SHIFT;

  00083	48 c1 eb 1e	 shr	 rbx, 30
  00087	48 83 c1 04	 add	 rcx, 4
  0008b	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00090	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  00093	48 85 db	 test	 rbx, rbx
  00096	75 e9		 jne	 SHORT $LL2@PyLong_Fro@8
$LN1@PyLong_Fro@8:

; 1147 :         }
; 1148 :     }
; 1149 :     return (PyObject *)v;
; 1150 : }

  00098	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000a2	49 8b c3	 mov	 rax, r11
  000a5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a9	5f		 pop	 rdi
  000aa	c3		 ret	 0
PyLong_FromSsize_t ENDP
_TEXT	ENDS
PUBLIC	PyLong_FromSize_t
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromSize_t DD imagerel $LN13
	DD	imagerel $LN13+131
	DD	imagerel $unwind$PyLong_FromSize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromSize_t DD 042501H
	DD	067425H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyLong_FromSize_t
_TEXT	SEGMENT
ival$ = 48
PyLong_FromSize_t PROC					; COMDAT

; 1156 : {

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1157 :     PyLongObject *v;
; 1158 :     size_t t;
; 1159 :     int ndigits = 0;

  00009	33 c9		 xor	 ecx, ecx

; 1160 : 
; 1161 :     if (ival < PyLong_BASE)

  0000b	48 81 fb 00 00
	00 40		 cmp	 rbx, 1073741824		; 40000000H
  00012	73 0c		 jae	 SHORT $LN6@PyLong_Fro@9

; 1162 :         return PyLong_FromLong((long)ival);

  00014	8b cb		 mov	 ecx, ebx

; 1176 :         }
; 1177 :     }
; 1178 :     return (PyObject *)v;
; 1179 : }

  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5b		 pop	 rbx
  0001b	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN6@PyLong_Fro@9:
  00020	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 1163 :     /* Count the number of Python digits. */
; 1164 :     t = ival;

  00025	48 8b c3	 mov	 rax, rbx

; 1165 :     while (t) {

  00028	48 85 db	 test	 rbx, rbx
  0002b	74 0e		 je	 SHORT $LN4@PyLong_Fro@9
  0002d	0f 1f 00	 npad	 3
$LL5@PyLong_Fro@9:

; 1166 :         ++ndigits;
; 1167 :         t >>= PyLong_SHIFT;

  00030	48 c1 e8 1e	 shr	 rax, 30
  00034	ff c1		 inc	 ecx
  00036	48 85 c0	 test	 rax, rax
  00039	75 f5		 jne	 SHORT $LL5@PyLong_Fro@9
$LN4@PyLong_Fro@9:

; 1168 :     }
; 1169 :     v = _PyLong_New(ndigits);

  0003b	48 63 f9	 movsxd	 rdi, ecx
  0003e	48 8b cf	 mov	 rcx, rdi
  00041	e8 00 00 00 00	 call	 _PyLong_New

; 1170 :     if (v != NULL) {

  00046	48 85 c0	 test	 rax, rax
  00049	74 2d		 je	 SHORT $LN1@PyLong_Fro@9

; 1171 :         digit *p = v->ob_digit;

  0004b	48 8d 50 70	 lea	 rdx, QWORD PTR [rax+112]

; 1172 :         Py_SIZE(v) = ndigits;

  0004f	48 89 78 60	 mov	 QWORD PTR [rax+96], rdi

; 1173 :         while (ival) {

  00053	48 85 db	 test	 rbx, rbx
  00056	74 20		 je	 SHORT $LN1@PyLong_Fro@9
  00058	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@PyLong_Fro@9:

; 1174 :             *p++ = (digit)(ival & PyLong_MASK);

  00060	8b cb		 mov	 ecx, ebx

; 1175 :             ival >>= PyLong_SHIFT;

  00062	48 c1 eb 1e	 shr	 rbx, 30
  00066	48 83 c2 04	 add	 rdx, 4
  0006a	81 e1 ff ff ff
	3f		 and	 ecx, 1073741823		; 3fffffffH
  00070	89 4a fc	 mov	 DWORD PTR [rdx-4], ecx
  00073	48 85 db	 test	 rbx, rbx
  00076	75 e8		 jne	 SHORT $LL2@PyLong_Fro@9
$LN1@PyLong_Fro@9:
  00078	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1176 :         }
; 1177 :     }
; 1178 :     return (PyObject *)v;
; 1179 : }

  0007d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00081	5b		 pop	 rbx
  00082	c3		 ret	 0
PyLong_FromSize_t ENDP
_TEXT	ENDS
PUBLIC	PyLong_AsLongLong
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsLongLong DD imagerel $LN17
	DD	imagerel $LN17+228
	DD	imagerel $unwind$PyLong_AsLongLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsLongLong DD 086b01H
	DD	09746bH
	DD	0b540fH
	DD	0a340fH
	DD	0600b520fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyLong_AsLongLong
_TEXT	SEGMENT
bytes$ = 64
vv$ = 64
PyLong_AsLongLong PROC					; COMDAT

; 1186 : {

$LN17:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1187 :     PyLongObject *v;
; 1188 :     PY_LONG_LONG bytes;
; 1189 :     int one = 1;
; 1190 :     int res;
; 1191 :     int do_decref = 0; /* if nb_int was called */

  0000f	33 f6		 xor	 esi, esi
  00011	48 8b d9	 mov	 rbx, rcx
  00014	8b ee		 mov	 ebp, esi

; 1192 : 
; 1193 :     if (vv == NULL) {

  00016	48 85 c9	 test	 rcx, rcx
  00019	75 25		 jne	 SHORT $LN13@PyLong_AsL@3

; 1194 :         PyErr_BadInternalCall();

  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00022	ba aa 04 00 00	 mov	 edx, 1194		; 000004aaH
  00027	e8 00 00 00 00	 call	 _PyErr_BadInternalCall
$LN16@PyLong_AsL@3:

; 1195 :         return -1;

  0002c	48 83 c8 ff	 or	 rax, -1

; 1225 :     }
; 1226 : 
; 1227 :     /* Plan 9 can't handle PY_LONG_LONG in ? : expressions */
; 1228 :     if (res < 0)
; 1229 :         return (PY_LONG_LONG)-1;
; 1230 :     else
; 1231 :         return bytes;
; 1232 : }

  00030	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00035	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  0003a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003e	5e		 pop	 rsi
  0003f	c3		 ret	 0
$LN13@PyLong_AsL@3:

; 1196 :     }
; 1197 : 
; 1198 :     if (PyLong_Check(vv)) {

  00040	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00044	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0004e	75 12		 jne	 SHORT $LN11@PyLong_AsL@3

; 1199 :         v = (PyLongObject *)vv;
; 1200 :     }
; 1201 :     else {
; 1202 :         v = _PyLong_FromNbInt(vv);

  00050	e8 00 00 00 00	 call	 _PyLong_FromNbInt
  00055	48 8b d8	 mov	 rbx, rax

; 1203 :         if (v == NULL)

  00058	48 85 c0	 test	 rax, rax

; 1204 :             return -1;

  0005b	74 cf		 je	 SHORT $LN16@PyLong_AsL@3

; 1205 :         do_decref = 1;

  0005d	bd 01 00 00 00	 mov	 ebp, 1
$LN11@PyLong_AsL@3:

; 1206 :     }
; 1207 : 
; 1208 :     res = 0;
; 1209 :     switch(Py_SIZE(v)) {

  00062	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  00066	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0006b	48 83 f8 ff	 cmp	 rax, -1
  0006f	74 3d		 je	 SHORT $LN7@PyLong_AsL@3
  00071	48 85 c0	 test	 rax, rax
  00074	74 33		 je	 SHORT $LN6@PyLong_AsL@3
  00076	48 83 f8 01	 cmp	 rax, 1
  0007a	74 28		 je	 SHORT $LN5@PyLong_AsL@3

; 1219 :     default:
; 1220 :         res = _PyLong_AsByteArray((PyLongObject *)v, (unsigned char *)&bytes,
; 1221 :                                   SIZEOF_LONG_LONG, IS_LITTLE_ENDIAN, 1);

  0007c	41 b9 01 00 00
	00		 mov	 r9d, 1
  00082	48 8d 54 24 40	 lea	 rdx, QWORD PTR bytes$[rsp]
  00087	48 8b cb	 mov	 rcx, rbx
  0008a	45 8d 41 07	 lea	 r8d, QWORD PTR [r9+7]
  0008e	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00096	e8 00 00 00 00	 call	 _PyLong_AsByteArray
  0009b	48 8b 7c 24 40	 mov	 rdi, QWORD PTR bytes$[rsp]
  000a0	8b f0		 mov	 esi, eax
  000a2	eb 12		 jmp	 SHORT $LN8@PyLong_AsL@3
$LN5@PyLong_AsL@3:

; 1216 :     case 1:
; 1217 :         bytes = v->ob_digit[0];

  000a4	8b 7b 70	 mov	 edi, DWORD PTR [rbx+112]

; 1218 :         break;

  000a7	eb 0d		 jmp	 SHORT $LN8@PyLong_AsL@3
$LN6@PyLong_AsL@3:

; 1212 :         break;
; 1213 :     case 0:
; 1214 :         bytes = 0;

  000a9	48 8b fe	 mov	 rdi, rsi

; 1215 :         break;

  000ac	eb 08		 jmp	 SHORT $LN8@PyLong_AsL@3
$LN7@PyLong_AsL@3:

; 1210 :     case -1:
; 1211 :         bytes = -(sdigit)v->ob_digit[0];

  000ae	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  000b1	f7 d8		 neg	 eax
  000b3	48 63 f8	 movsxd	 rdi, eax
$LN8@PyLong_AsL@3:

; 1222 :     }
; 1223 :     if (do_decref) {

  000b6	85 ed		 test	 ebp, ebp
  000b8	74 08		 je	 SHORT $LN3@PyLong_AsL@3

; 1224 :         Py_DECREF(v);

  000ba	48 8b cb	 mov	 rcx, rbx
  000bd	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyLong_AsL@3:

; 1225 :     }
; 1226 : 
; 1227 :     /* Plan 9 can't handle PY_LONG_LONG in ? : expressions */
; 1228 :     if (res < 0)
; 1229 :         return (PY_LONG_LONG)-1;
; 1230 :     else
; 1231 :         return bytes;
; 1232 : }

  000c2	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000c7	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000cc	49 83 cb ff	 or	 r11, -1
  000d0	85 f6		 test	 esi, esi
  000d2	49 0f 48 fb	 cmovs	 rdi, r11
  000d6	48 8b c7	 mov	 rax, rdi
  000d9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000de	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e2	5e		 pop	 rsi
  000e3	c3		 ret	 0
PyLong_AsLongLong ENDP
_TEXT	ENDS
PUBLIC	PyLong_AsUnsignedLongLong
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsUnsignedLongLong DD imagerel $LN11
	DD	imagerel $LN11+155
	DD	imagerel $unwind$PyLong_AsUnsignedLongLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsUnsignedLongLong DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyLong_AsUnsignedLongLong
_TEXT	SEGMENT
bytes$ = 64
vv$ = 64
PyLong_AsUnsignedLongLong PROC				; COMDAT

; 1239 : {

$LN11:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1240 :     PyLongObject *v;
; 1241 :     unsigned PY_LONG_LONG bytes;
; 1242 :     int one = 1;
; 1243 :     int res;
; 1244 : 
; 1245 :     if (vv == NULL) {

  00004	48 85 c9	 test	 rcx, rcx
  00007	75 1a		 jne	 SHORT $LN8@PyLong_AsU@4

; 1246 :         PyErr_BadInternalCall();

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00010	ba de 04 00 00	 mov	 edx, 1246		; 000004deH
  00015	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1247 :         return (unsigned PY_LONG_LONG)-1;

  0001a	48 83 c8 ff	 or	 rax, -1

; 1268 : }

  0001e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00022	c3		 ret	 0
$LN8@PyLong_AsU@4:

; 1248 :     }
; 1249 :     if (!PyLong_Check(vv)) {

  00023	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00027	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00031	75 1c		 jne	 SHORT $LN7@PyLong_AsU@4

; 1250 :         PyErr_SetString(PyExc_TypeError, "an integer is required");

  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
  00041	e8 00 00 00 00	 call	 PyErr_SetString

; 1251 :         return (unsigned PY_LONG_LONG)-1;

  00046	48 83 c8 ff	 or	 rax, -1

; 1268 : }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
$LN7@PyLong_AsU@4:

; 1252 :     }
; 1253 : 
; 1254 :     v = (PyLongObject*)vv;
; 1255 :     switch(Py_SIZE(v)) {

  0004f	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00053	48 85 c0	 test	 rax, rax
  00056	74 3e		 je	 SHORT $LN4@PyLong_AsU@4
  00058	48 ff c8	 dec	 rax
  0005b	74 31		 je	 SHORT $LN3@PyLong_AsU@4

; 1258 :     }
; 1259 : 
; 1260 :     res = _PyLong_AsByteArray((PyLongObject *)vv, (unsigned char *)&bytes,
; 1261 :                               SIZEOF_LONG_LONG, IS_LITTLE_ENDIAN, 0);

  0005d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00063	48 8d 54 24 40	 lea	 rdx, QWORD PTR bytes$[rsp]
  00068	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00070	45 8d 41 07	 lea	 r8d, QWORD PTR [r9+7]
  00074	e8 00 00 00 00	 call	 _PyLong_AsByteArray

; 1262 : 
; 1263 :     /* Plan 9 can't handle PY_LONG_LONG in ? : expressions */
; 1264 :     if (res < 0)

  00079	85 c0		 test	 eax, eax
  0007b	79 07		 jns	 SHORT $LN2@PyLong_AsU@4

; 1265 :         return (unsigned PY_LONG_LONG)res;

  0007d	48 98		 cdqe

; 1268 : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
$LN2@PyLong_AsU@4:

; 1266 :     else
; 1267 :         return bytes;

  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR bytes$[rsp]

; 1268 : }

  00089	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008d	c3		 ret	 0
$LN3@PyLong_AsU@4:

; 1256 :     case 0: return 0;
; 1257 :     case 1: return v->ob_digit[0];

  0008e	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]

; 1268 : }

  00091	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00095	c3		 ret	 0
$LN4@PyLong_AsU@4:
  00096	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009a	c3		 ret	 0
PyLong_AsUnsignedLongLong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_AsUnsignedLongLongMask DD imagerel _PyLong_AsUnsignedLongLongMask
	DD	imagerel _PyLong_AsUnsignedLongLongMask+153
	DD	imagerel $unwind$_PyLong_AsUnsignedLongLongMask
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_AsUnsignedLongLongMask DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyLong_AsUnsignedLongLongMask
_TEXT	SEGMENT
vv$ = 48
_PyLong_AsUnsignedLongLongMask PROC			; COMDAT

; 1275 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1276 :     register PyLongObject *v;
; 1277 :     unsigned PY_LONG_LONG x;
; 1278 :     Py_ssize_t i;
; 1279 :     int sign;
; 1280 : 
; 1281 :     if (vv == NULL || !PyLong_Check(vv)) {

  00004	48 85 c9	 test	 rcx, rcx
  00007	74 75		 je	 SHORT $LN8@PyLong_AsU@5
  00009	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000d	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00017	74 65		 je	 SHORT $LN8@PyLong_AsU@5

; 1284 :     }
; 1285 :     v = (PyLongObject *)vv;
; 1286 :     switch(Py_SIZE(v)) {

  00019	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  0001d	48 8b c2	 mov	 rax, rdx
  00020	48 85 d2	 test	 rdx, rdx
  00023	74 52		 je	 SHORT $LN5@PyLong_AsU@5
  00025	48 ff c8	 dec	 rax
  00028	74 45		 je	 SHORT $LN4@PyLong_AsU@5

; 1289 :     }
; 1290 :     i = Py_SIZE(v);
; 1291 :     sign = 1;
; 1292 :     x = 0;

  0002a	45 33 c0	 xor	 r8d, r8d
  0002d	41 ba 01 00 00
	00		 mov	 r10d, 1

; 1293 :     if (i < 0) {

  00033	48 85 d2	 test	 rdx, rdx
  00036	79 07		 jns	 SHORT $LN12@PyLong_AsU@5

; 1294 :         sign = -1;

  00038	41 83 ca ff	 or	 r10d, -1

; 1295 :         i = -i;

  0003c	48 f7 da	 neg	 rdx
$LN12@PyLong_AsU@5:

; 1296 :     }
; 1297 :     while (--i >= 0) {

  0003f	48 ff ca	 dec	 rdx
  00042	78 1f		 js	 SHORT $LN1@PyLong_AsU@5
  00044	4c 8d 4c 91 70	 lea	 r9, QWORD PTR [rcx+rdx*4+112]
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@PyLong_AsU@5:

; 1298 :         x = (x << PyLong_SHIFT) | v->ob_digit[i];

  00050	41 8b 01	 mov	 eax, DWORD PTR [r9]
  00053	49 c1 e0 1e	 shl	 r8, 30
  00057	49 83 e9 04	 sub	 r9, 4
  0005b	4c 0b c0	 or	 r8, rax
  0005e	48 ff ca	 dec	 rdx
  00061	79 ed		 jns	 SHORT $LL2@PyLong_AsU@5
$LN1@PyLong_AsU@5:

; 1299 :     }
; 1300 :     return x * sign;

  00063	49 63 c2	 movsxd	 rax, r10d
  00066	49 0f af c0	 imul	 rax, r8

; 1301 : }

  0006a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006e	c3		 ret	 0
$LN4@PyLong_AsU@5:

; 1288 :     case 1: return v->ob_digit[0];

  0006f	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]

; 1301 : }

  00072	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00076	c3		 ret	 0
$LN5@PyLong_AsU@5:

; 1287 :     case 0: return 0;

  00077	33 c0		 xor	 eax, eax

; 1301 : }

  00079	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007d	c3		 ret	 0
$LN8@PyLong_AsU@5:

; 1282 :         PyErr_BadInternalCall();

  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00085	ba 02 05 00 00	 mov	 edx, 1282		; 00000502H
  0008a	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1283 :         return (unsigned long) -1;

  0008f	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH

; 1301 : }

  00094	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00098	c3		 ret	 0
_PyLong_AsUnsignedLongLongMask ENDP
_TEXT	ENDS
PUBLIC	PyLong_AsUnsignedLongLongMask
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsUnsignedLongLongMask DD imagerel $LN7
	DD	imagerel $LN7+61
	DD	imagerel $unwind$PyLong_AsUnsignedLongLongMask
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyLong_AsUnsignedLongLongMask DD imagerel $LN7+61
	DD	imagerel $LN7+93
	DD	imagerel $chain$0$PyLong_AsUnsignedLongLongMask
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyLong_AsUnsignedLongLongMask DD imagerel $LN7+93
	DD	imagerel $LN7+135
	DD	imagerel $chain$3$PyLong_AsUnsignedLongLongMask
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyLong_AsUnsignedLongLongMask DD 040821H
	DD	063408H
	DD	047400H
	DD	imagerel $LN7
	DD	imagerel $LN7+61
	DD	imagerel $unwind$PyLong_AsUnsignedLongLongMask
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyLong_AsUnsignedLongLongMask DD 020521H
	DD	047405H
	DD	imagerel $LN7
	DD	imagerel $LN7+61
	DD	imagerel $unwind$PyLong_AsUnsignedLongLongMask
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsUnsignedLongLongMask DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyLong_AsUnsignedLongLongMask
_TEXT	SEGMENT
op$ = 48
PyLong_AsUnsignedLongLongMask PROC			; COMDAT

; 1305 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1306 :     PyLongObject *lo;
; 1307 :     unsigned PY_LONG_LONG val;
; 1308 : 
; 1309 :     if (op == NULL) {

  00004	48 85 c9	 test	 rcx, rcx
  00007	75 1b		 jne	 SHORT $LN3@PyLong_AsU@6

; 1310 :         PyErr_BadInternalCall();

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00010	ba 1e 05 00 00	 mov	 edx, 1310		; 0000051eH
  00015	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1311 :         return (unsigned long)-1;

  0001a	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH

; 1325 : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
$LN3@PyLong_AsU@6:

; 1312 :     }
; 1313 : 
; 1314 :     if (PyLong_Check(op)) {

  00024	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00028	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00032	74 09		 je	 SHORT $LN2@PyLong_AsU@6

; 1325 : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	e9 00 00 00 00	 jmp	 _PyLong_AsUnsignedLongLongMask
$LN2@PyLong_AsU@6:
  0003d	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi

; 1315 :         return _PyLong_AsUnsignedLongLongMask(op);
; 1316 :     }
; 1317 : 
; 1318 :     lo = _PyLong_FromNbInt(op);

  00042	e8 00 00 00 00	 call	 _PyLong_FromNbInt
  00047	48 8b f8	 mov	 rdi, rax

; 1319 :     if (lo == NULL)

  0004a	48 85 c0	 test	 rax, rax
  0004d	75 0e		 jne	 SHORT $LN1@PyLong_AsU@6

; 1320 :         return (unsigned PY_LONG_LONG)-1;

  0004f	48 83 c8 ff	 or	 rax, -1
  00053	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 1325 : }

  00058	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005c	c3		 ret	 0
$LN1@PyLong_AsU@6:

; 1321 : 
; 1322 :     val = _PyLong_AsUnsignedLongLongMask((PyObject *)lo);

  0005d	48 8b c8	 mov	 rcx, rax
  00060	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00065	e8 00 00 00 00	 call	 _PyLong_AsUnsignedLongLongMask

; 1323 :     Py_DECREF(lo);

  0006a	48 8b cf	 mov	 rcx, rdi
  0006d	48 8b d8	 mov	 rbx, rax
  00070	e8 00 00 00 00	 call	 _Py_DecRef
  00075	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 1324 :     return val;

  0007a	48 8b c3	 mov	 rax, rbx
  0007d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1325 : }

  00082	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00086	c3		 ret	 0
PyLong_AsUnsignedLongLongMask ENDP
_TEXT	ENDS
PUBLIC	PyLong_AsLongLongAndOverflow
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsLongLongAndOverflow DD imagerel $LN26
	DD	imagerel $LN26+320
	DD	imagerel $unwind$PyLong_AsLongLongAndOverflow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsLongLongAndOverflow DD 084f01H
	DD	06644fH
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyLong_AsLongLongAndOverflow
_TEXT	SEGMENT
vv$ = 48
overflow$ = 56
PyLong_AsLongLongAndOverflow PROC			; COMDAT

; 1340 : {

$LN26:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1341 :     /* This version by Tim Peters */
; 1342 :     register PyLongObject *v;
; 1343 :     unsigned PY_LONG_LONG x, prev;
; 1344 :     PY_LONG_LONG res;
; 1345 :     Py_ssize_t i;
; 1346 :     int sign;
; 1347 :     int do_decref = 0; /* if nb_int was called */

  0000f	33 ff		 xor	 edi, edi
  00011	48 8b ea	 mov	 rbp, rdx
  00014	4c 8b c1	 mov	 r8, rcx
  00017	44 8b d7	 mov	 r10d, edi

; 1348 : 
; 1349 :     *overflow = 0;

  0001a	89 3a		 mov	 DWORD PTR [rdx], edi

; 1350 :     if (vv == NULL) {

  0001c	48 85 c9	 test	 rcx, rcx
  0001f	75 25		 jne	 SHORT $LN19@PyLong_AsL@4

; 1351 :         PyErr_BadInternalCall();

  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00028	ba 47 05 00 00	 mov	 edx, 1351		; 00000547H
  0002d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1352 :         return -1;

  00032	48 83 c8 ff	 or	 rax, -1

; 1412 : }

  00036	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0003b	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
$LN19@PyLong_AsL@4:

; 1353 :     }
; 1354 : 
; 1355 :     if (PyLong_Check(vv)) {

  00046	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0004a	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0004f	be 01 00 00 00	 mov	 esi, 1
  00054	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0005e	75 19		 jne	 SHORT $LN17@PyLong_AsL@4

; 1356 :         v = (PyLongObject *)vv;
; 1357 :     }
; 1358 :     else {
; 1359 :         v = _PyLong_FromNbInt(vv);

  00060	e8 00 00 00 00	 call	 _PyLong_FromNbInt
  00065	4c 8b c0	 mov	 r8, rax

; 1360 :         if (v == NULL)

  00068	48 85 c0	 test	 rax, rax
  0006b	75 09		 jne	 SHORT $LN16@PyLong_AsL@4

; 1361 :             return -1;

  0006d	48 83 c8 ff	 or	 rax, -1
  00071	e9 b5 00 00 00	 jmp	 $LN25@PyLong_AsL@4
$LN16@PyLong_AsL@4:

; 1362 :         do_decref = 1;

  00076	44 8b d6	 mov	 r10d, esi
$LN17@PyLong_AsL@4:

; 1363 :     }
; 1364 : 
; 1365 :     res = -1;
; 1366 :     i = Py_SIZE(v);

  00079	49 8b 50 60	 mov	 rdx, QWORD PTR [r8+96]
  0007d	48 83 cb ff	 or	 rbx, -1

; 1367 : 
; 1368 :     switch (i) {

  00081	48 3b d3	 cmp	 rdx, rbx
  00084	0f 84 88 00 00
	00		 je	 $LN13@PyLong_AsL@4
  0008a	48 85 d2	 test	 rdx, rdx
  0008d	0f 84 7a 00 00
	00		 je	 $LN12@PyLong_AsL@4
  00093	48 3b d6	 cmp	 rdx, rsi
  00096	74 6f		 je	 SHORT $LN11@PyLong_AsL@4

; 1378 :     default:
; 1379 :         sign = 1;
; 1380 :         x = 0;
; 1381 :         if (i < 0) {

  00098	48 85 d2	 test	 rdx, rdx
  0009b	79 05		 jns	 SHORT $LN22@PyLong_AsL@4

; 1382 :             sign = -1;

  0009d	8b f3		 mov	 esi, ebx

; 1383 :             i = -(i);

  0009f	48 f7 da	 neg	 rdx
$LN22@PyLong_AsL@4:

; 1384 :         }
; 1385 :         while (--i >= 0) {

  000a2	48 ff ca	 dec	 rdx
  000a5	78 57		 js	 SHORT $LN24@PyLong_AsL@4
  000a7	4d 8d 4c 90 70	 lea	 r9, QWORD PTR [r8+rdx*4+112]
  000ac	0f 1f 40 00	 npad	 4
$LL8@PyLong_AsL@4:

; 1386 :             prev = x;
; 1387 :             x = (x << PyLong_SHIFT) + v->ob_digit[i];

  000b0	41 8b 01	 mov	 eax, DWORD PTR [r9]
  000b3	48 8b cf	 mov	 rcx, rdi
  000b6	48 c1 e7 1e	 shl	 rdi, 30
  000ba	48 03 f8	 add	 rdi, rax

; 1388 :             if ((x >> PyLong_SHIFT) != prev) {

  000bd	48 8b c7	 mov	 rax, rdi
  000c0	48 c1 e8 1e	 shr	 rax, 30
  000c4	48 3b c1	 cmp	 rax, rcx
  000c7	75 30		 jne	 SHORT $LN23@PyLong_AsL@4

; 1384 :         }
; 1385 :         while (--i >= 0) {

  000c9	49 83 e9 04	 sub	 r9, 4
  000cd	48 ff ca	 dec	 rdx
  000d0	79 de		 jns	 SHORT $LL8@PyLong_AsL@4

; 1391 :             }
; 1392 :         }
; 1393 :         /* Haven't lost any bits, but casting to long requires extra
; 1394 :          * care (see comment above).
; 1395 :          */
; 1396 :         if (x <= (unsigned PY_LONG_LONG)PY_LLONG_MAX) {

  000d2	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000dc	48 3b f8	 cmp	 rdi, rax
  000df	76 1d		 jbe	 SHORT $LN24@PyLong_AsL@4

; 1398 :         }
; 1399 :         else if (sign < 0 && x == PY_ABS_LLONG_MIN) {

  000e1	85 f6		 test	 esi, esi
  000e3	79 14		 jns	 SHORT $LN23@PyLong_AsL@4
  000e5	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  000ef	48 3b f8	 cmp	 rdi, rax
  000f2	75 05		 jne	 SHORT $LN23@PyLong_AsL@4

; 1400 :             res = PY_LLONG_MIN;

  000f4	48 8b d8	 mov	 rbx, rax

; 1401 :         }
; 1402 :         else {

  000f7	eb 22		 jmp	 SHORT $exit$21039
$LN23@PyLong_AsL@4:

; 1389 :                 *overflow = sign;

  000f9	89 75 00	 mov	 DWORD PTR [rbp], esi

; 1390 :                 goto exit;

  000fc	eb 1d		 jmp	 SHORT $exit$21039
$LN24@PyLong_AsL@4:

; 1397 :             res = (PY_LONG_LONG)x * sign;

  000fe	48 63 de	 movsxd	 rbx, esi
  00101	48 0f af df	 imul	 rbx, rdi
  00105	eb 14		 jmp	 SHORT $exit$21039
$LN11@PyLong_AsL@4:

; 1375 :     case 1:
; 1376 :         res = v->ob_digit[0];

  00107	41 8b 58 70	 mov	 ebx, DWORD PTR [r8+112]

; 1377 :         break;

  0010b	eb 0e		 jmp	 SHORT $exit$21039
$LN12@PyLong_AsL@4:

; 1371 :         break;
; 1372 :     case 0:
; 1373 :         res = 0;

  0010d	48 8b df	 mov	 rbx, rdi

; 1374 :         break;

  00110	eb 09		 jmp	 SHORT $exit$21039
$LN13@PyLong_AsL@4:

; 1369 :     case -1:
; 1370 :         res = -(sdigit)v->ob_digit[0];

  00112	41 8b 40 70	 mov	 eax, DWORD PTR [r8+112]
  00116	f7 d8		 neg	 eax
  00118	48 63 d8	 movsxd	 rbx, eax
$exit$21039:

; 1403 :             *overflow = sign;
; 1404 :             /* res is already set to -1 */
; 1405 :         }
; 1406 :     }
; 1407 :   exit:
; 1408 :     if (do_decref) {

  0011b	45 85 d2	 test	 r10d, r10d
  0011e	74 08		 je	 SHORT $LN1@PyLong_AsL@4

; 1409 :         Py_DECREF(v);

  00120	49 8b c8	 mov	 rcx, r8
  00123	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyLong_AsL@4:

; 1410 :     }
; 1411 :     return res;

  00128	48 8b c3	 mov	 rax, rbx
$LN25@PyLong_AsL@4:
  0012b	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 1412 : }

  00130	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00135	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0013a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013e	5f		 pop	 rdi
  0013f	c3		 ret	 0
PyLong_AsLongLongAndOverflow ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bits_in_digit
_TEXT	SEGMENT
d$ = 8
bits_in_digit PROC					; COMDAT

; 1433 :     int d_bits = 0;

  00000	33 d2		 xor	 edx, edx

; 1434 :     while (d >= 32) {

  00002	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00005	72 14		 jb	 SHORT $LN1@bits_in_di
  00007	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@bits_in_di:

; 1435 :         d_bits += 6;
; 1436 :         d >>= 6;

  00010	c1 e9 06	 shr	 ecx, 6
  00013	83 c2 06	 add	 edx, 6
  00016	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00019	73 f5		 jae	 SHORT $LL2@bits_in_di
$LN1@bits_in_di:

; 1437 :     }
; 1438 :     d_bits += (int)BitLengthTable[d];
; 1439 :     return d_bits;

  0001b	8b c1		 mov	 eax, ecx
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:BitLengthTable
  00024	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00028	03 c2		 add	 eax, edx

; 1440 : }

  0002a	c3		 ret	 0
bits_in_digit ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$v_iadd DD imagerel v_iadd
	DD	imagerel v_iadd+114
	DD	imagerel $unwind$v_iadd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$v_iadd DD 020501H
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT v_iadd
_TEXT	SEGMENT
x$ = 8
m$ = 16
y$ = 24
n$ = 32
v_iadd	PROC						; COMDAT

; 1448 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	49 8b d8	 mov	 rbx, r8

; 1449 :     Py_ssize_t i;
; 1450 :     digit carry = 0;

  00008	45 33 d2	 xor	 r10d, r10d
  0000b	4c 8b c2	 mov	 r8, rdx
  0000e	48 8b d1	 mov	 rdx, rcx

; 1451 : 
; 1452 :     assert(m >= n);
; 1453 :     for (i = 0; i < n; ++i) {

  00011	4d 85 c9	 test	 r9, r9
  00014	7e 53		 jle	 SHORT $LN15@v_iadd
  00016	48 2b d9	 sub	 rbx, rcx
  00019	4d 8b d9	 mov	 r11, r9
  0001c	0f 1f 40 00	 npad	 4
$LL6@v_iadd:

; 1454 :         carry += x[i] + y[i];

  00020	8b 04 0b	 mov	 eax, DWORD PTR [rbx+rcx]
  00023	48 83 c1 04	 add	 rcx, 4
  00027	03 41 fc	 add	 eax, DWORD PTR [rcx-4]
  0002a	44 03 d0	 add	 r10d, eax

; 1455 :         x[i] = carry & PyLong_MASK;

  0002d	41 8b c2	 mov	 eax, r10d

; 1456 :         carry >>= PyLong_SHIFT;

  00030	41 c1 ea 1e	 shr	 r10d, 30
  00034	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00039	49 ff c9	 dec	 r9
  0003c	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  0003f	75 df		 jne	 SHORT $LL6@v_iadd

; 1457 :         assert((carry & 1) == carry);
; 1458 :     }
; 1459 :     for (; carry && i < m; ++i) {

  00041	45 85 d2	 test	 r10d, r10d
  00044	74 23		 je	 SHORT $LN15@v_iadd
$LL3@v_iadd:
  00046	4d 3b d8	 cmp	 r11, r8
  00049	7d 1e		 jge	 SHORT $LN15@v_iadd

; 1460 :         carry += x[i];

  0004b	46 03 14 9a	 add	 r10d, DWORD PTR [rdx+r11*4]
  0004f	49 ff c3	 inc	 r11

; 1461 :         x[i] = carry & PyLong_MASK;

  00052	41 8b ca	 mov	 ecx, r10d

; 1462 :         carry >>= PyLong_SHIFT;

  00055	41 c1 ea 1e	 shr	 r10d, 30
  00059	81 e1 ff ff ff
	3f		 and	 ecx, 1073741823		; 3fffffffH
  0005f	42 89 4c 9a fc	 mov	 DWORD PTR [rdx+r11*4-4], ecx
  00064	45 85 d2	 test	 r10d, r10d
  00067	75 dd		 jne	 SHORT $LL3@v_iadd
$LN15@v_iadd:

; 1463 :         assert((carry & 1) == carry);
; 1464 :     }
; 1465 :     return carry;
; 1466 : }

  00069	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0006e	41 8b c2	 mov	 eax, r10d
  00071	c3		 ret	 0
v_iadd	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$v_isub DD imagerel v_isub
	DD	imagerel v_isub+130
	DD	imagerel $unwind$v_isub
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$v_isub DD 020501H
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT v_isub
_TEXT	SEGMENT
x$ = 8
m$ = 16
y$ = 24
n$ = 32
v_isub	PROC						; COMDAT

; 1474 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	49 8b d8	 mov	 rbx, r8

; 1475 :     Py_ssize_t i;
; 1476 :     digit borrow = 0;

  00008	45 33 d2	 xor	 r10d, r10d
  0000b	4c 8b c2	 mov	 r8, rdx
  0000e	48 8b d1	 mov	 rdx, rcx

; 1477 : 
; 1478 :     assert(m >= n);
; 1479 :     for (i = 0; i < n; ++i) {

  00011	4d 85 c9	 test	 r9, r9
  00014	7e 63		 jle	 SHORT $LN15@v_isub
  00016	48 2b d9	 sub	 rbx, rcx
  00019	4d 8b d9	 mov	 r11, r9
  0001c	0f 1f 40 00	 npad	 4
$LL6@v_isub:

; 1480 :         borrow = x[i] - y[i] - borrow;

  00020	8b 01		 mov	 eax, DWORD PTR [rcx]
  00022	48 83 c1 04	 add	 rcx, 4
  00026	2b 44 0b fc	 sub	 eax, DWORD PTR [rbx+rcx-4]
  0002a	41 2b c2	 sub	 eax, r10d
  0002d	44 8b d0	 mov	 r10d, eax

; 1481 :         x[i] = borrow & PyLong_MASK;

  00030	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH

; 1482 :         borrow >>= PyLong_SHIFT;
; 1483 :         borrow &= 1;            /* keep only 1 sign bit */

  00035	41 c1 ea 1e	 shr	 r10d, 30
  00039	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  0003c	41 83 e2 01	 and	 r10d, 1
  00040	49 ff c9	 dec	 r9
  00043	75 db		 jne	 SHORT $LL6@v_isub

; 1484 :     }
; 1485 :     for (; borrow && i < m; ++i) {

  00045	45 85 d2	 test	 r10d, r10d
  00048	74 2f		 je	 SHORT $LN15@v_isub
  0004a	66 0f 1f 44 00
	00		 npad	 6
$LL3@v_isub:
  00050	4d 3b d8	 cmp	 r11, r8
  00053	7d 24		 jge	 SHORT $LN15@v_isub

; 1486 :         borrow = x[i] - borrow;

  00055	42 8b 04 9a	 mov	 eax, DWORD PTR [rdx+r11*4]
  00059	49 ff c3	 inc	 r11
  0005c	41 2b c2	 sub	 eax, r10d

; 1487 :         x[i] = borrow & PyLong_MASK;

  0005f	8b c8		 mov	 ecx, eax
  00061	44 8b d0	 mov	 r10d, eax
  00064	81 e1 ff ff ff
	3f		 and	 ecx, 1073741823		; 3fffffffH

; 1488 :         borrow >>= PyLong_SHIFT;
; 1489 :         borrow &= 1;

  0006a	41 c1 ea 1e	 shr	 r10d, 30
  0006e	41 83 e2 01	 and	 r10d, 1
  00072	42 89 4c 9a fc	 mov	 DWORD PTR [rdx+r11*4-4], ecx
  00077	75 d7		 jne	 SHORT $LL3@v_isub
$LN15@v_isub:

; 1490 :     }
; 1491 :     return borrow;
; 1492 : }

  00079	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0007e	41 8b c2	 mov	 eax, r10d
  00081	c3		 ret	 0
v_isub	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT v_lshift
_TEXT	SEGMENT
z$ = 8
a$ = 16
m$ = 24
d$ = 32
v_lshift PROC						; COMDAT

; 1500 :     Py_ssize_t i;
; 1501 :     digit carry = 0;

  00000	33 c0		 xor	 eax, eax
  00002	4c 8b da	 mov	 r11, rdx
  00005	4c 8b d1	 mov	 r10, rcx

; 1502 : 
; 1503 :     assert(0 <= d && d < PyLong_SHIFT);
; 1504 :     for (i=0; i < m; i++) {

  00008	4d 85 c0	 test	 r8, r8
  0000b	7e 2d		 jle	 SHORT $LN8@v_lshift
  0000d	4c 2b d9	 sub	 r11, rcx
$LL3@v_lshift:

; 1505 :         twodigits acc = (twodigits)a[i] << d | carry;

  00010	43 8b 14 13	 mov	 edx, DWORD PTR [r11+r10]
  00014	8b c0		 mov	 eax, eax
  00016	41 8b c9	 mov	 ecx, r9d
  00019	48 d3 e2	 shl	 rdx, cl
  0001c	49 83 c2 04	 add	 r10, 4
  00020	48 0b d0	 or	 rdx, rax

; 1506 :         z[i] = (digit)acc & PyLong_MASK;

  00023	8b c2		 mov	 eax, edx
  00025	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  0002a	41 89 42 fc	 mov	 DWORD PTR [r10-4], eax

; 1507 :         carry = (digit)(acc >> PyLong_SHIFT);

  0002e	48 8b c2	 mov	 rax, rdx
  00031	48 c1 e8 1e	 shr	 rax, 30
  00035	49 ff c8	 dec	 r8
  00038	75 d6		 jne	 SHORT $LL3@v_lshift
$LN8@v_lshift:

; 1508 :     }
; 1509 :     return carry;
; 1510 : }

  0003a	f3 c3		 fatret	 0
v_lshift ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$v_rshift DD imagerel v_rshift
	DD	imagerel v_rshift+91
	DD	imagerel $unwind$v_rshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$v_rshift DD 020501H
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT v_rshift
_TEXT	SEGMENT
z$ = 8
a$ = 16
m$ = 24
d$ = 32
v_rshift PROC						; COMDAT

; 1517 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	41 8b d9	 mov	 ebx, r9d
  00008	4c 8b da	 mov	 r11, rdx
  0000b	48 8b d1	 mov	 rdx, rcx

; 1518 :     Py_ssize_t i;
; 1519 :     digit carry = 0;
; 1520 :     digit mask = ((digit)1 << d) - 1U;

  0000e	41 8b c9	 mov	 ecx, r9d
  00011	41 b9 01 00 00
	00		 mov	 r9d, 1
  00017	33 c0		 xor	 eax, eax
  00019	41 d3 e1	 shl	 r9d, cl
  0001c	4d 8b d0	 mov	 r10, r8
  0001f	41 ff c9	 dec	 r9d

; 1521 : 
; 1522 :     assert(0 <= d && d < PyLong_SHIFT);
; 1523 :     for (i=m; i-- > 0;) {

  00022	4d 85 c0	 test	 r8, r8
  00025	7e 2e		 jle	 SHORT $LN8@v_rshift
  00027	4e 8d 04 82	 lea	 r8, QWORD PTR [rdx+r8*4]
  0002b	4c 2b da	 sub	 r11, rdx
  0002e	66 90		 npad	 2
$LL2@v_rshift:

; 1524 :         twodigits acc = (twodigits)carry << PyLong_SHIFT | a[i];

  00030	43 8b 54 03 fc	 mov	 edx, DWORD PTR [r11+r8-4]
  00035	48 c1 e0 1e	 shl	 rax, 30
  00039	49 83 e8 04	 sub	 r8, 4
  0003d	48 0b d0	 or	 rdx, rax

; 1525 :         carry = (digit)acc & mask;
; 1526 :         z[i] = (digit)(acc >> d);

  00040	8b cb		 mov	 ecx, ebx
  00042	49 ff ca	 dec	 r10
  00045	8b c2		 mov	 eax, edx
  00047	48 d3 ea	 shr	 rdx, cl
  0004a	41 23 c1	 and	 eax, r9d
  0004d	41 89 10	 mov	 DWORD PTR [r8], edx
  00050	4d 85 d2	 test	 r10, r10
  00053	7f db		 jg	 SHORT $LL2@v_rshift
$LN8@v_rshift:

; 1527 :     }
; 1528 :     return carry;
; 1529 : }

  00055	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0005a	c3		 ret	 0
v_rshift ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inplace_divrem1 DD imagerel inplace_divrem1
	DD	imagerel inplace_divrem1+98
	DD	imagerel $unwind$inplace_divrem1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inplace_divrem1 DD 020501H
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inplace_divrem1
_TEXT	SEGMENT
pout$ = 8
pin$ = 16
size$ = 24
n$ = 32
inplace_divrem1 PROC					; COMDAT

; 1539 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 1540 :     twodigits rem = 0;
; 1541 : 
; 1542 :     assert(n > 0 && n <= PyLong_MASK);
; 1543 :     pin += size;

  00005	4a 8d 04 85 00
	00 00 00	 lea	 rax, QWORD PTR [r8*4]
  0000d	41 8b d9	 mov	 ebx, r9d
  00010	4d 8b c8	 mov	 r9, r8
  00013	45 33 d2	 xor	 r10d, r10d

; 1544 :     pout += size;
; 1545 :     while (--size >= 0) {

  00016	49 ff c9	 dec	 r9
  00019	4c 8d 1c 10	 lea	 r11, QWORD PTR [rax+rdx]
  0001d	4c 8d 04 08	 lea	 r8, QWORD PTR [rax+rcx]
  00021	78 36		 js	 SHORT $LN7@inplace_di
  00023	4d 2b c3	 sub	 r8, r11
  00026	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL2@inplace_di:

; 1546 :         digit hi;
; 1547 :         rem = (rem << PyLong_SHIFT) | *--pin;

  00030	41 8b 43 fc	 mov	 eax, DWORD PTR [r11-4]
  00034	49 83 eb 04	 sub	 r11, 4
  00038	49 c1 e2 1e	 shl	 r10, 30
  0003c	4c 0b d0	 or	 r10, rax

; 1548 :         *--pout = hi = (digit)(rem / n);

  0003f	33 d2		 xor	 edx, edx
  00041	49 8b c2	 mov	 rax, r10
  00044	48 f7 f3	 div	 rbx

; 1549 :         rem -= (twodigits)hi * n;

  00047	8b c8		 mov	 ecx, eax
  00049	43 89 04 18	 mov	 DWORD PTR [r8+r11], eax
  0004d	48 0f af cb	 imul	 rcx, rbx
  00051	4c 2b d1	 sub	 r10, rcx
  00054	49 ff c9	 dec	 r9
  00057	79 d7		 jns	 SHORT $LL2@inplace_di
$LN7@inplace_di:

; 1550 :     }
; 1551 :     return (digit)rem;
; 1552 : }

  00059	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0005e	41 8b c2	 mov	 eax, r10d
  00061	c3		 ret	 0
inplace_divrem1 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$divrem1 DD imagerel divrem1
	DD	imagerel divrem1+120
	DD	imagerel $unwind$divrem1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$divrem1 DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT divrem1
_TEXT	SEGMENT
a$ = 48
n$ = 56
prem$ = 64
divrem1	PROC						; COMDAT

; 1560 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1561 :     const Py_ssize_t size = ABS(Py_SIZE(a));

  0001a	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  0001e	49 8b e8	 mov	 rbp, r8
  00021	44 8b e2	 mov	 r12d, edx
  00024	48 8b f1	 mov	 rsi, rcx
  00027	48 85 db	 test	 rbx, rbx
  0002a	79 03		 jns	 SHORT $LN4@divrem1
  0002c	48 f7 db	 neg	 rbx
$LN4@divrem1:

; 1562 :     PyLongObject *z;
; 1563 : 
; 1564 :     assert(n > 0 && n <= PyLong_MASK);
; 1565 :     z = _PyLong_New(size);

  0002f	48 8b cb	 mov	 rcx, rbx
  00032	e8 00 00 00 00	 call	 _PyLong_New
  00037	48 8b f8	 mov	 rdi, rax

; 1566 :     if (z == NULL)

  0003a	48 85 c0	 test	 rax, rax
  0003d	74 1e		 je	 SHORT $LN2@divrem1
$LN1@divrem1:

; 1567 :         return NULL;
; 1568 :     *prem = inplace_divrem1(z->ob_digit, a->ob_digit, size, n);

  0003f	48 8d 56 70	 lea	 rdx, QWORD PTR [rsi+112]
  00043	48 8d 48 70	 lea	 rcx, QWORD PTR [rax+112]
  00047	45 8b cc	 mov	 r9d, r12d
  0004a	4c 8b c3	 mov	 r8, rbx
  0004d	e8 00 00 00 00	 call	 inplace_divrem1

; 1569 :     return long_normalize(z);

  00052	48 8b cf	 mov	 rcx, rdi
  00055	89 45 00	 mov	 DWORD PTR [rbp], eax
  00058	e8 00 00 00 00	 call	 long_normalize
$LN2@divrem1:

; 1570 : }

  0005d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00062	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00067	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0006c	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00071	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00075	41 5c		 pop	 r12
  00077	c3		 ret	 0
divrem1	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@IDJHHDAH@long?5is?5too?5large?5to?5format?$AA@ ; `string'
EXTRN	PyUnicode_New:PROC
EXTRN	_PyUnicodeWriter_PrepareInternal:PROC
EXTRN	PyErr_CheckSignals:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_to_decimal_string_internal DD imagerel long_to_decimal_string_internal
	DD	imagerel long_to_decimal_string_internal+57
	DD	imagerel $unwind$long_to_decimal_string_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$long_to_decimal_string_internal DD imagerel long_to_decimal_string_internal+57
	DD	imagerel long_to_decimal_string_internal+150
	DD	imagerel $chain$2$long_to_decimal_string_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$long_to_decimal_string_internal DD imagerel long_to_decimal_string_internal+150
	DD	imagerel long_to_decimal_string_internal+198
	DD	imagerel $chain$3$long_to_decimal_string_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$long_to_decimal_string_internal DD imagerel long_to_decimal_string_internal+198
	DD	imagerel long_to_decimal_string_internal+562
	DD	imagerel $chain$4$long_to_decimal_string_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$long_to_decimal_string_internal DD imagerel long_to_decimal_string_internal+562
	DD	imagerel long_to_decimal_string_internal+567
	DD	imagerel $chain$5$long_to_decimal_string_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$long_to_decimal_string_internal DD imagerel long_to_decimal_string_internal+567
	DD	imagerel long_to_decimal_string_internal+593
	DD	imagerel $chain$6$long_to_decimal_string_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$long_to_decimal_string_internal DD imagerel long_to_decimal_string_internal+593
	DD	imagerel long_to_decimal_string_internal+2447
	DD	imagerel $chain$8$long_to_decimal_string_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$long_to_decimal_string_internal DD imagerel long_to_decimal_string_internal+2447
	DD	imagerel long_to_decimal_string_internal+2478
	DD	imagerel $chain$9$long_to_decimal_string_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$long_to_decimal_string_internal DD 021H
	DD	imagerel long_to_decimal_string_internal
	DD	imagerel long_to_decimal_string_internal+57
	DD	imagerel $unwind$long_to_decimal_string_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$long_to_decimal_string_internal DD 0a0021H
	DD	06e400H
	DD	077400H
	DD	0f6400H
	DD	0d5400H
	DD	0c3400H
	DD	imagerel long_to_decimal_string_internal
	DD	imagerel long_to_decimal_string_internal+57
	DD	imagerel $unwind$long_to_decimal_string_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$long_to_decimal_string_internal DD 021H
	DD	imagerel long_to_decimal_string_internal+57
	DD	imagerel long_to_decimal_string_internal+150
	DD	imagerel $chain$2$long_to_decimal_string_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$long_to_decimal_string_internal DD 021H
	DD	imagerel long_to_decimal_string_internal+150
	DD	imagerel long_to_decimal_string_internal+198
	DD	imagerel $chain$3$long_to_decimal_string_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$long_to_decimal_string_internal DD 020521H
	DD	0c3405H
	DD	imagerel long_to_decimal_string_internal+150
	DD	imagerel long_to_decimal_string_internal+198
	DD	imagerel $chain$3$long_to_decimal_string_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$long_to_decimal_string_internal DD 020521H
	DD	077405H
	DD	imagerel long_to_decimal_string_internal+57
	DD	imagerel long_to_decimal_string_internal+150
	DD	imagerel $chain$2$long_to_decimal_string_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$long_to_decimal_string_internal DD 060f21H
	DD	06e40fH
	DD	0f640aH
	DD	0d5405H
	DD	imagerel long_to_decimal_string_internal
	DD	imagerel long_to_decimal_string_internal+57
	DD	imagerel $unwind$long_to_decimal_string_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_to_decimal_string_internal DD 040f01H
	DD	0f00b720fH
	DD	0c007d009H
xdata	ENDS
;	COMDAT ??_C@_0BM@IDJHHDAH@long?5is?5too?5large?5to?5format?$AA@
CONST	SEGMENT
??_C@_0BM@IDJHHDAH@long?5is?5too?5large?5to?5format?$AA@ DB 'long is too '
	DB	'large to format', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
CONST	ENDS
;	COMDAT long_to_decimal_string_internal
_TEXT	SEGMENT
aa$ = 96
p_output$ = 104
writer$ = 112
long_to_decimal_string_internal PROC			; COMDAT

; 1580 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 57		 push	 r15
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	4d 8b e0	 mov	 r12, r8
  00012	4c 8b fa	 mov	 r15, rdx
  00015	4c 8b e9	 mov	 r13, rcx

; 1581 :     PyLongObject *scratch, *a;
; 1582 :     PyObject *str;
; 1583 :     Py_ssize_t size, strlen, size_a, i, j;
; 1584 :     digit *pout, *pin, rem, tenpow;
; 1585 :     int negative;
; 1586 :     enum PyUnicode_Kind kind;
; 1587 : 
; 1588 :     a = (PyLongObject *)aa;
; 1589 :     if (a == NULL || !PyLong_Check(a)) {

  00018	48 85 c9	 test	 rcx, rcx
  0001b	0f 84 6e 09 00
	00		 je	 $LN78@long_to_de
  00021	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00025	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0002f	0f 84 5a 09 00
	00		 je	 $LN78@long_to_de

; 1592 :     }
; 1593 :     size_a = ABS(Py_SIZE(a));

  00035	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00039	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp
  0003e	48 89 74 24 78	 mov	 QWORD PTR [rsp+120], rsi
  00043	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  00048	48 8b f0	 mov	 rsi, rax
  0004b	48 85 c0	 test	 rax, rax
  0004e	79 03		 jns	 SHORT $LN83@long_to_de
  00050	48 f7 de	 neg	 rsi
$LN83@long_to_de:

; 1594 :     negative = Py_SIZE(a) < 0;

  00053	33 ed		 xor	 ebp, ebp
  00055	48 85 c0	 test	 rax, rax

; 1595 : 
; 1596 :     /* quick and dirty upper bound for the number of digits
; 1597 :        required to express a in base _PyLong_DECIMAL_BASE:
; 1598 : 
; 1599 :          #digits = 1 + floor(log2(a) / log2(_PyLong_DECIMAL_BASE))
; 1600 : 
; 1601 :        But log2(a) < size_a * PyLong_SHIFT, and
; 1602 :        log2(_PyLong_DECIMAL_BASE) = log2(10) * _PyLong_DECIMAL_SHIFT
; 1603 :                                   > 3 * _PyLong_DECIMAL_SHIFT
; 1604 :     */
; 1605 :     if (size_a > PY_SSIZE_T_MAX / PyLong_SHIFT) {

  00058	48 b8 44 44 44
	44 44 44 44 04	 mov	 rax, 307445734561825860	; 0444444444444444H
  00062	44 8b f5	 mov	 r14d, ebp
  00065	41 0f 98 c6	 sets	 r14b
  00069	48 3b f0	 cmp	 rsi, rax
  0006c	7e 1b		 jle	 SHORT $LN77@long_to_de

; 1606 :         PyErr_SetString(PyExc_OverflowError,
; 1607 :                         "long is too large to format");

  0006e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@IDJHHDAH@long?5is?5too?5large?5to?5format?$AA@
  0007c	e8 00 00 00 00	 call	 PyErr_SetString

; 1608 :         return -1;

  00081	83 c8 ff	 or	 eax, -1
  00084	e9 ae 01 00 00	 jmp	 $LN179@long_to_de
$LN77@long_to_de:

; 1609 :     }
; 1610 :     /* the expression size_a * PyLong_SHIFT is now safe from overflow */
; 1611 :     size = 1 + size_a * PyLong_SHIFT / (3 * _PyLong_DECIMAL_SHIFT);

  00089	48 8b ce	 mov	 rcx, rsi
  0008c	48 b8 26 b4 97
	d0 5e 42 7b 09	 mov	 rax, 683212743470724134	; 097b425ed097b426H
  00096	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0009b	48 6b c9 1e	 imul	 rcx, 30
  0009f	48 f7 e9	 imul	 rcx
  000a2	48 8b c2	 mov	 rax, rdx
  000a5	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  000a9	48 8d 4c 02 01	 lea	 rcx, QWORD PTR [rdx+rax+1]

; 1612 :     scratch = _PyLong_New(size);

  000ae	e8 00 00 00 00	 call	 _PyLong_New
  000b3	48 8b f8	 mov	 rdi, rax

; 1613 :     if (scratch == NULL)

  000b6	48 85 c0	 test	 rax, rax
  000b9	75 08		 jne	 SHORT $LN76@long_to_de

; 1614 :         return -1;

  000bb	83 c8 ff	 or	 eax, -1
  000be	e9 6f 01 00 00	 jmp	 $LN180@long_to_de
$LN76@long_to_de:

; 1615 : 
; 1616 :     /* convert array of base _PyLong_BASE digits in pin to an array of
; 1617 :        base _PyLong_DECIMAL_BASE digits in pout, following Knuth (TAOCP,
; 1618 :        Volume 2 (3rd edn), section 4.4, Method 1b). */
; 1619 :     pin = a->ob_digit;
; 1620 :     pout = scratch->ob_digit;
; 1621 :     size = 0;
; 1622 :     for (i = size_a; --i >= 0; ) {

  000c3	48 ff ce	 dec	 rsi
  000c6	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  000cb	48 8b dd	 mov	 rbx, rbp
  000ce	0f 88 c5 00 00
	00		 js	 $LN176@long_to_de
  000d4	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL75@long_to_de:

; 1623 :         digit hi = pin[i];

  000e0	45 8b 44 b5 70	 mov	 r8d, DWORD PTR [r13+rsi*4+112]

; 1624 :         for (j = 0; j < size; j++) {

  000e5	4c 8b cd	 mov	 r9, rbp
  000e8	48 85 db	 test	 rbx, rbx
  000eb	7e 55		 jle	 SHORT $LN125@long_to_de
  000ed	49 bc 2f 4b 69
	6d 82 be e0 12	 mov	 r12, 1360296554856532783 ; 12e0be826d694b2fH
  000f7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL73@long_to_de:

; 1625 :             twodigits z = (twodigits)pout[j] << PyLong_SHIFT | hi;

  00100	42 8b 4c 8f 70	 mov	 ecx, DWORD PTR [rdi+r9*4+112]
  00105	41 8b c0	 mov	 eax, r8d
  00108	49 ff c1	 inc	 r9
  0010b	48 c1 e1 1e	 shl	 rcx, 30
  0010f	48 0b c8	 or	 rcx, rax

; 1626 :             hi = (digit)(z / _PyLong_DECIMAL_BASE);

  00112	49 8b c4	 mov	 rax, r12
  00115	4c 8b c1	 mov	 r8, rcx
  00118	48 f7 e1	 mul	 rcx
  0011b	4c 2b c2	 sub	 r8, rdx
  0011e	49 d1 e8	 shr	 r8, 1
  00121	4c 03 c2	 add	 r8, rdx
  00124	49 c1 e8 1d	 shr	 r8, 29

; 1627 :             pout[j] = (digit)(z - (twodigits)hi *
; 1628 :                               _PyLong_DECIMAL_BASE);

  00128	41 8b c0	 mov	 eax, r8d
  0012b	69 c0 00 ca 9a
	3b		 imul	 eax, 1000000000		; 3b9aca00H
  00131	2b c8		 sub	 ecx, eax
  00133	42 89 4c 8f 6c	 mov	 DWORD PTR [rdi+r9*4+108], ecx
  00138	4c 3b cb	 cmp	 r9, rbx
  0013b	7c c3		 jl	 SHORT $LL73@long_to_de
  0013d	4c 8b 64 24 70	 mov	 r12, QWORD PTR writer$[rsp]
$LN125@long_to_de:

; 1629 :         }
; 1630 :         while (hi) {

  00142	45 85 c0	 test	 r8d, r8d
  00145	74 37		 je	 SHORT $LN68@long_to_de
  00147	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL70@long_to_de:

; 1631 :             pout[size++] = hi % _PyLong_DECIMAL_BASE;

  00150	41 8b c8	 mov	 ecx, r8d
  00153	b8 83 be e0 12	 mov	 eax, 316718723		; 12e0be83H
  00158	48 ff c3	 inc	 rbx
  0015b	41 f7 e0	 mul	 r8d
  0015e	2b ca		 sub	 ecx, edx
  00160	d1 e9		 shr	 ecx, 1
  00162	03 ca		 add	 ecx, edx
  00164	c1 e9 1d	 shr	 ecx, 29
  00167	8b c1		 mov	 eax, ecx
  00169	69 c0 00 ca 9a
	3b		 imul	 eax, 1000000000		; 3b9aca00H
  0016f	44 2b c0	 sub	 r8d, eax
  00172	44 89 44 9f 6c	 mov	 DWORD PTR [rdi+rbx*4+108], r8d

; 1632 :             hi /= _PyLong_DECIMAL_BASE;

  00177	44 8b c1	 mov	 r8d, ecx
  0017a	85 c9		 test	 ecx, ecx
  0017c	75 d2		 jne	 SHORT $LL70@long_to_de
$LN68@long_to_de:

; 1633 :         }
; 1634 :         /* check for keyboard interrupt */
; 1635 :         SIGCHECK({
; 1636 :                 Py_DECREF(scratch);
; 1637 :                 return -1;
; 1638 :             });

  0017e	e8 00 00 00 00	 call	 PyErr_CheckSignals
  00183	85 c0		 test	 eax, eax
  00185	0f 85 97 00 00
	00		 jne	 $LN182@long_to_de

; 1615 : 
; 1616 :     /* convert array of base _PyLong_BASE digits in pin to an array of
; 1617 :        base _PyLong_DECIMAL_BASE digits in pout, following Knuth (TAOCP,
; 1618 :        Volume 2 (3rd edn), section 4.4, Method 1b). */
; 1619 :     pin = a->ob_digit;
; 1620 :     pout = scratch->ob_digit;
; 1621 :     size = 0;
; 1622 :     for (i = size_a; --i >= 0; ) {

  0018b	48 ff ce	 dec	 rsi
  0018e	0f 89 4c ff ff
	ff		 jns	 $LL75@long_to_de

; 1639 :     }
; 1640 :     /* pout should have at least one digit, so that the case when a = 0
; 1641 :        works correctly */
; 1642 :     if (size == 0)

  00194	48 85 db	 test	 rbx, rbx
  00197	75 08		 jne	 SHORT $LN64@long_to_de
$LN176@long_to_de:

; 1643 :         pout[size++] = 0;

  00199	89 6f 70	 mov	 DWORD PTR [rdi+112], ebp
  0019c	bb 01 00 00 00	 mov	 ebx, 1
$LN64@long_to_de:

; 1644 : 
; 1645 :     /* calculate exact length of output string, and allocate */
; 1646 :     strlen = negative + 1 + (size - 1) * _PyLong_DECIMAL_SHIFT;

  001a1	41 8d 46 01	 lea	 eax, DWORD PTR [r14+1]
  001a5	48 63 c8	 movsxd	 rcx, eax
  001a8	48 8d 04 db	 lea	 rax, QWORD PTR [rbx+rbx*8]
  001ac	48 8d 74 01 f7	 lea	 rsi, QWORD PTR [rcx+rax-9]

; 1647 :     tenpow = 10;
; 1648 :     rem = pout[size-1];

  001b1	8b 4c 9f 6c	 mov	 ecx, DWORD PTR [rdi+rbx*4+108]
  001b5	b8 0a 00 00 00	 mov	 eax, 10

; 1649 :     while (rem >= tenpow) {

  001ba	3b c8		 cmp	 ecx, eax
  001bc	72 0e		 jb	 SHORT $LN62@long_to_de
  001be	66 90		 npad	 2
$LL63@long_to_de:

; 1650 :         tenpow *= 10;

  001c0	8d 04 80	 lea	 eax, DWORD PTR [rax+rax*4]

; 1651 :         strlen++;

  001c3	48 ff c6	 inc	 rsi
  001c6	03 c0		 add	 eax, eax
  001c8	3b c8		 cmp	 ecx, eax
  001ca	73 f4		 jae	 SHORT $LL63@long_to_de
$LN62@long_to_de:

; 1652 :     }
; 1653 :     if (writer) {

  001cc	4d 85 e4	 test	 r12, r12
  001cf	74 3c		 je	 SHORT $LN61@long_to_de

; 1654 :         if (_PyUnicodeWriter_Prepare(writer, strlen, '9') == -1) {

  001d1	41 83 7c 24 14
	39		 cmp	 DWORD PTR [r12+20], 57	; 00000039H
  001d7	72 0f		 jb	 SHORT $LN84@long_to_de
  001d9	49 8b 44 24 18	 mov	 rax, QWORD PTR [r12+24]
  001de	49 2b 44 24 20	 sub	 rax, QWORD PTR [r12+32]
  001e3	48 3b f0	 cmp	 rsi, rax
  001e6	7e 1b		 jle	 SHORT $LN60@long_to_de
$LN84@long_to_de:
  001e8	48 85 f6	 test	 rsi, rsi
  001eb	74 16		 je	 SHORT $LN60@long_to_de
  001ed	41 b8 39 00 00
	00		 mov	 r8d, 57			; 00000039H
  001f3	48 8b d6	 mov	 rdx, rsi
  001f6	49 8b cc	 mov	 rcx, r12
  001f9	e8 00 00 00 00	 call	 _PyUnicodeWriter_PrepareInternal
  001fe	83 f8 ff	 cmp	 eax, -1

; 1655 :             Py_DECREF(scratch);
; 1656 :             return -1;

  00201	74 1f		 je	 SHORT $LN182@long_to_de
$LN60@long_to_de:

; 1657 :         }
; 1658 :         kind = writer->kind;

  00203	41 8b 44 24 10	 mov	 eax, DWORD PTR [r12+16]

; 1659 :         str = NULL;

  00208	4c 8b ed	 mov	 r13, rbp

; 1660 :     }
; 1661 :     else {

  0020b	eb 4d		 jmp	 SHORT $LN59@long_to_de
$LN61@long_to_de:

; 1662 :         str = PyUnicode_New(strlen, '9');

  0020d	ba 39 00 00 00	 mov	 edx, 57			; 00000039H
  00212	48 8b ce	 mov	 rcx, rsi
  00215	e8 00 00 00 00	 call	 PyUnicode_New
  0021a	4c 8b e8	 mov	 r13, rax

; 1663 :         if (str == NULL) {

  0021d	48 85 c0	 test	 rax, rax
  00220	75 2f		 jne	 SHORT $LN58@long_to_de
$LN182@long_to_de:

; 1664 :             Py_DECREF(scratch);

  00222	48 8b cf	 mov	 rcx, rdi
  00225	e8 00 00 00 00	 call	 _Py_DecRef

; 1665 :             return -1;

  0022a	83 c8 ff	 or	 eax, -1
$LN181@long_to_de:
  0022d	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
$LN180@long_to_de:
  00232	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
$LN179@long_to_de:
  00237	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  0023c	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00241	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]

; 1730 : }

  00246	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0024a	41 5f		 pop	 r15
  0024c	41 5d		 pop	 r13
  0024e	41 5c		 pop	 r12
  00250	c3		 ret	 0
$LN58@long_to_de:

; 1666 :         }
; 1667 :         kind = PyUnicode_KIND(str);

  00251	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00254	c1 e8 02	 shr	 eax, 2
  00257	83 e0 07	 and	 eax, 7
$LN59@long_to_de:

; 1668 :     }
; 1669 : 
; 1670 : #define WRITE_DIGITS(TYPE)                                            \
; 1671 :     do {                                                              \
; 1672 :         if (writer)                                                   \
; 1673 :             p = (TYPE*)PyUnicode_DATA(writer->buffer) + writer->pos + strlen; \
; 1674 :         else                                                          \
; 1675 :             p = (TYPE*)PyUnicode_DATA(str) + strlen;                  \
; 1676 :                                                                       \
; 1677 :         *p = '\0';                                                    \
; 1678 :         /* pout[0] through pout[size-2] contribute exactly            \
; 1679 :            _PyLong_DECIMAL_SHIFT digits each */                       \
; 1680 :         for (i=0; i < size - 1; i++) {                                \
; 1681 :             rem = pout[i];                                            \
; 1682 :             for (j = 0; j < _PyLong_DECIMAL_SHIFT; j++) {             \
; 1683 :                 *--p = '0' + rem % 10;                                \
; 1684 :                 rem /= 10;                                            \
; 1685 :             }                                                         \
; 1686 :         }                                                             \
; 1687 :         /* pout[size-1]: always produce at least one decimal digit */ \
; 1688 :         rem = pout[i];                                                \
; 1689 :         do {                                                          \
; 1690 :             *--p = '0' + rem % 10;                                    \
; 1691 :             rem /= 10;                                                \
; 1692 :         } while (rem != 0);                                           \
; 1693 :                                                                       \
; 1694 :         /* and sign */                                                \
; 1695 :         if (negative)                                                 \
; 1696 :             *--p = '-';                                               \
; 1697 :                                                                       \
; 1698 :         /* check we've counted correctly */                           \
; 1699 :         if (writer)                                                   \
; 1700 :             assert(p == ((TYPE*)PyUnicode_DATA(writer->buffer) + writer->pos)); \
; 1701 :         else                                                          \
; 1702 :             assert(p == (TYPE*)PyUnicode_DATA(str));                  \
; 1703 :     } while (0)
; 1704 : 
; 1705 :     /* fill the string right-to-left */
; 1706 :     if (kind == PyUnicode_1BYTE_KIND) {

  0025a	83 f8 01	 cmp	 eax, 1
  0025d	0f 85 3b 02 00
	00		 jne	 $LN57@long_to_de

; 1707 :         Py_UCS1 *p;
; 1708 :         WRITE_DIGITS(Py_UCS1);

  00263	4d 85 e4	 test	 r12, r12
  00266	74 49		 je	 SHORT $LN53@long_to_de
  00268	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  0026c	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  0026f	f6 c1 20	 test	 cl, 32			; 00000020H
  00272	74 29		 je	 SHORT $LN90@long_to_de
  00274	f6 c1 40	 test	 cl, 64			; 00000040H
  00277	74 11		 je	 SHORT $LN88@long_to_de
  00279	4d 8b 54 24 20	 mov	 r10, QWORD PTR [r12+32]
  0027e	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  00282	4c 03 d0	 add	 r10, rax
  00285	4c 03 d6	 add	 r10, rsi
  00288	eb 50		 jmp	 SHORT $LN52@long_to_de
$LN88@long_to_de:
  0028a	4d 8b 54 24 20	 mov	 r10, QWORD PTR [r12+32]
  0028f	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00295	4c 03 d0	 add	 r10, rax
  00298	4c 03 d6	 add	 r10, rsi
  0029b	eb 3d		 jmp	 SHORT $LN52@long_to_de
$LN90@long_to_de:
  0029d	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  002a4	4d 8b 54 24 20	 mov	 r10, QWORD PTR [r12+32]
  002a9	4c 03 d0	 add	 r10, rax
  002ac	4c 03 d6	 add	 r10, rsi
  002af	eb 29		 jmp	 SHORT $LN52@long_to_de
$LN53@long_to_de:
  002b1	41 8b 45 70	 mov	 eax, DWORD PTR [r13+112]
  002b5	a8 20		 test	 al, 32			; 00000020H
  002b7	74 16		 je	 SHORT $LN94@long_to_de
  002b9	a8 40		 test	 al, 64			; 00000040H
  002bb	74 09		 je	 SHORT $LN92@long_to_de
  002bd	49 8d 85 80 00
	00 00		 lea	 rax, QWORD PTR [r13+128]
  002c4	eb 10		 jmp	 SHORT $LN95@long_to_de
$LN92@long_to_de:
  002c6	49 8d 85 a0 00
	00 00		 lea	 rax, QWORD PTR [r13+160]
  002cd	eb 07		 jmp	 SHORT $LN95@long_to_de
$LN94@long_to_de:
  002cf	49 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR [r13+160]
$LN95@long_to_de:
  002d6	4c 8d 14 30	 lea	 r10, QWORD PTR [rax+rsi]
$LN52@long_to_de:
  002da	48 ff cb	 dec	 rbx
  002dd	41 88 2a	 mov	 BYTE PTR [r10], bpl
  002e0	48 85 db	 test	 rbx, rbx
  002e3	0f 8e 73 01 00
	00		 jle	 $LN49@long_to_de
  002e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL51@long_to_de:
  002f0	44 8b 44 af 70	 mov	 r8d, DWORD PTR [rdi+rbp*4+112]
  002f5	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  002fa	41 f7 e0	 mul	 r8d
  002fd	44 8b ca	 mov	 r9d, edx
  00300	41 c1 e9 03	 shr	 r9d, 3
  00304	41 0f b6 c1	 movzx	 eax, r9b
  00308	c0 e0 02	 shl	 al, 2
  0030b	42 8d 0c 08	 lea	 ecx, DWORD PTR [rax+r9]
  0030f	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00314	02 c9		 add	 cl, cl
  00316	41 f7 e1	 mul	 r9d
  00319	44 2a c1	 sub	 r8b, cl
  0031c	41 80 c0 30	 add	 r8b, 48			; 00000030H
  00320	45 88 42 ff	 mov	 BYTE PTR [r10-1], r8b
  00324	44 8b c2	 mov	 r8d, edx
  00327	41 c1 e8 03	 shr	 r8d, 3
  0032b	41 0f b6 c0	 movzx	 eax, r8b
  0032f	c0 e0 02	 shl	 al, 2
  00332	42 8d 0c 00	 lea	 ecx, DWORD PTR [rax+r8]
  00336	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  0033b	02 c9		 add	 cl, cl
  0033d	41 f7 e0	 mul	 r8d
  00340	44 2a c9	 sub	 r9b, cl
  00343	41 80 c1 30	 add	 r9b, 48			; 00000030H
  00347	45 88 4a fe	 mov	 BYTE PTR [r10-2], r9b
  0034b	44 8b ca	 mov	 r9d, edx
  0034e	41 c1 e9 03	 shr	 r9d, 3
  00352	41 0f b6 c1	 movzx	 eax, r9b
  00356	c0 e0 02	 shl	 al, 2
  00359	42 8d 0c 08	 lea	 ecx, DWORD PTR [rax+r9]
  0035d	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00362	02 c9		 add	 cl, cl
  00364	41 f7 e1	 mul	 r9d
  00367	44 2a c1	 sub	 r8b, cl
  0036a	41 80 c0 30	 add	 r8b, 48			; 00000030H
  0036e	45 88 42 fd	 mov	 BYTE PTR [r10-3], r8b
  00372	44 8b c2	 mov	 r8d, edx
  00375	41 c1 e8 03	 shr	 r8d, 3
  00379	41 0f b6 c0	 movzx	 eax, r8b
  0037d	c0 e0 02	 shl	 al, 2
  00380	42 8d 0c 00	 lea	 ecx, DWORD PTR [rax+r8]
  00384	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00389	02 c9		 add	 cl, cl
  0038b	41 f7 e0	 mul	 r8d
  0038e	44 2a c9	 sub	 r9b, cl
  00391	41 80 c1 30	 add	 r9b, 48			; 00000030H
  00395	45 88 4a fc	 mov	 BYTE PTR [r10-4], r9b
  00399	44 8b ca	 mov	 r9d, edx
  0039c	41 c1 e9 03	 shr	 r9d, 3
  003a0	41 0f b6 c1	 movzx	 eax, r9b
  003a4	c0 e0 02	 shl	 al, 2
  003a7	42 8d 0c 08	 lea	 ecx, DWORD PTR [rax+r9]
  003ab	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  003b0	02 c9		 add	 cl, cl
  003b2	41 f7 e1	 mul	 r9d
  003b5	44 2a c1	 sub	 r8b, cl
  003b8	41 80 c0 30	 add	 r8b, 48			; 00000030H
  003bc	45 88 42 fb	 mov	 BYTE PTR [r10-5], r8b
  003c0	44 8b c2	 mov	 r8d, edx
  003c3	41 c1 e8 03	 shr	 r8d, 3
  003c7	41 0f b6 c0	 movzx	 eax, r8b
  003cb	c0 e0 02	 shl	 al, 2
  003ce	42 8d 0c 00	 lea	 ecx, DWORD PTR [rax+r8]
  003d2	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  003d7	02 c9		 add	 cl, cl
  003d9	41 f7 e0	 mul	 r8d
  003dc	44 2a c9	 sub	 r9b, cl
  003df	41 80 c1 30	 add	 r9b, 48			; 00000030H
  003e3	45 88 4a fa	 mov	 BYTE PTR [r10-6], r9b
  003e7	44 8b ca	 mov	 r9d, edx
  003ea	41 c1 e9 03	 shr	 r9d, 3
  003ee	41 0f b6 c1	 movzx	 eax, r9b
  003f2	c0 e0 02	 shl	 al, 2
  003f5	42 8d 0c 08	 lea	 ecx, DWORD PTR [rax+r9]
  003f9	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  003fe	02 c9		 add	 cl, cl
  00400	44 2a c1	 sub	 r8b, cl
  00403	41 80 c0 30	 add	 r8b, 48			; 00000030H
  00407	45 88 42 f9	 mov	 BYTE PTR [r10-7], r8b
  0040b	41 f7 e1	 mul	 r9d
  0040e	44 8b c2	 mov	 r8d, edx
  00411	41 c1 e8 03	 shr	 r8d, 3
  00415	49 83 c2 f7	 add	 r10, -9
  00419	48 ff c5	 inc	 rbp
  0041c	41 0f b6 c0	 movzx	 eax, r8b
  00420	c0 e0 02	 shl	 al, 2
  00423	42 8d 0c 00	 lea	 ecx, DWORD PTR [rax+r8]
  00427	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  0042c	02 c9		 add	 cl, cl
  0042e	41 f7 e0	 mul	 r8d
  00431	c1 ea 03	 shr	 edx, 3
  00434	44 2a c9	 sub	 r9b, cl
  00437	0f b6 c2	 movzx	 eax, dl
  0043a	41 80 c1 30	 add	 r9b, 48			; 00000030H
  0043e	c0 e0 02	 shl	 al, 2
  00441	45 88 4a 01	 mov	 BYTE PTR [r10+1], r9b
  00445	02 d0		 add	 dl, al
  00447	02 d2		 add	 dl, dl
  00449	44 2a c2	 sub	 r8b, dl
  0044c	41 80 c0 30	 add	 r8b, 48			; 00000030H
  00450	45 88 02	 mov	 BYTE PTR [r10], r8b
  00453	48 3b eb	 cmp	 rbp, rbx
  00456	0f 8c 94 fe ff
	ff		 jl	 $LL51@long_to_de
$LN49@long_to_de:
  0045c	44 8b 44 af 70	 mov	 r8d, DWORD PTR [rdi+rbp*4+112]
$LL45@long_to_de:
  00461	49 ff ca	 dec	 r10
  00464	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00469	41 f7 e0	 mul	 r8d
  0046c	c1 ea 03	 shr	 edx, 3
  0046f	0f b6 c2	 movzx	 eax, dl
  00472	c0 e0 02	 shl	 al, 2
  00475	8d 0c 10	 lea	 ecx, DWORD PTR [rax+rdx]
  00478	02 c9		 add	 cl, cl
  0047a	44 2a c1	 sub	 r8b, cl
  0047d	41 80 c0 30	 add	 r8b, 48			; 00000030H
  00481	45 88 02	 mov	 BYTE PTR [r10], r8b
  00484	44 8b c2	 mov	 r8d, edx
  00487	85 d2		 test	 edx, edx
  00489	75 d6		 jne	 SHORT $LL45@long_to_de
  0048b	45 85 f6	 test	 r14d, r14d
  0048e	0f 84 7b 04 00
	00		 je	 $LN17@long_to_de
  00494	41 c6 42 ff 2d	 mov	 BYTE PTR [r10-1], 45	; 0000002dH

; 1709 :     }
; 1710 :     else if (kind == PyUnicode_2BYTE_KIND) {

  00499	e9 71 04 00 00	 jmp	 $LN17@long_to_de
$LN57@long_to_de:
  0049e	83 f8 02	 cmp	 eax, 2
  004a1	0f 85 81 02 00
	00		 jne	 $LN19@long_to_de

; 1711 :         Py_UCS2 *p;
; 1712 :         WRITE_DIGITS(Py_UCS2);

  004a7	4d 85 e4	 test	 r12, r12
  004aa	74 50		 je	 SHORT $LN34@long_to_de
  004ac	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  004b0	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  004b3	f6 c1 20	 test	 cl, 32			; 00000020H
  004b6	74 2f		 je	 SHORT $LN98@long_to_de
  004b8	f6 c1 40	 test	 cl, 64			; 00000040H
  004bb	74 15		 je	 SHORT $LN96@long_to_de
  004bd	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  004c4	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  004c9	48 03 c6	 add	 rax, rsi
  004cc	4c 8d 14 41	 lea	 r10, QWORD PTR [rcx+rax*2]
  004d0	eb 53		 jmp	 SHORT $LN33@long_to_de
$LN96@long_to_de:
  004d2	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  004d9	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  004de	48 03 c6	 add	 rax, rsi
  004e1	4c 8d 14 41	 lea	 r10, QWORD PTR [rcx+rax*2]
  004e5	eb 3e		 jmp	 SHORT $LN33@long_to_de
$LN98@long_to_de:
  004e7	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  004ee	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  004f3	48 03 c6	 add	 rax, rsi
  004f6	4c 8d 14 41	 lea	 r10, QWORD PTR [rcx+rax*2]
  004fa	eb 29		 jmp	 SHORT $LN33@long_to_de
$LN34@long_to_de:
  004fc	41 8b 45 70	 mov	 eax, DWORD PTR [r13+112]
  00500	a8 20		 test	 al, 32			; 00000020H
  00502	74 16		 je	 SHORT $LN102@long_to_de
  00504	a8 40		 test	 al, 64			; 00000040H
  00506	74 09		 je	 SHORT $LN100@long_to_de
  00508	49 8d 85 80 00
	00 00		 lea	 rax, QWORD PTR [r13+128]
  0050f	eb 10		 jmp	 SHORT $LN103@long_to_de
$LN100@long_to_de:
  00511	49 8d 85 a0 00
	00 00		 lea	 rax, QWORD PTR [r13+160]
  00518	eb 07		 jmp	 SHORT $LN103@long_to_de
$LN102@long_to_de:
  0051a	49 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR [r13+160]
$LN103@long_to_de:
  00521	4c 8d 14 70	 lea	 r10, QWORD PTR [rax+rsi*2]
$LN33@long_to_de:
  00525	48 ff cb	 dec	 rbx
  00528	66 41 89 2a	 mov	 WORD PTR [r10], bp
  0052c	48 85 db	 test	 rbx, rbx
  0052f	0f 8e a5 01 00
	00		 jle	 $LN30@long_to_de
  00535	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL32@long_to_de:
  00540	44 8b 44 af 70	 mov	 r8d, DWORD PTR [rdi+rbp*4+112]
  00545	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  0054a	41 f7 e0	 mul	 r8d
  0054d	44 8b ca	 mov	 r9d, edx
  00550	41 c1 e9 03	 shr	 r9d, 3
  00554	41 0f b7 c1	 movzx	 eax, r9w
  00558	66 c1 e0 02	 shl	 ax, 2
  0055c	42 8d 0c 08	 lea	 ecx, DWORD PTR [rax+r9]
  00560	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00565	66 03 c9	 add	 cx, cx
  00568	41 f7 e1	 mul	 r9d
  0056b	66 44 2b c1	 sub	 r8w, cx
  0056f	66 41 83 c0 30	 add	 r8w, 48			; 00000030H
  00574	66 45 89 42 fe	 mov	 WORD PTR [r10-2], r8w
  00579	44 8b c2	 mov	 r8d, edx
  0057c	41 c1 e8 03	 shr	 r8d, 3
  00580	41 0f b7 c0	 movzx	 eax, r8w
  00584	66 c1 e0 02	 shl	 ax, 2
  00588	42 8d 0c 00	 lea	 ecx, DWORD PTR [rax+r8]
  0058c	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00591	66 03 c9	 add	 cx, cx
  00594	41 f7 e0	 mul	 r8d
  00597	66 44 2b c9	 sub	 r9w, cx
  0059b	66 41 83 c1 30	 add	 r9w, 48			; 00000030H
  005a0	66 45 89 4a fc	 mov	 WORD PTR [r10-4], r9w
  005a5	44 8b ca	 mov	 r9d, edx
  005a8	41 c1 e9 03	 shr	 r9d, 3
  005ac	41 0f b7 c1	 movzx	 eax, r9w
  005b0	66 c1 e0 02	 shl	 ax, 2
  005b4	42 8d 0c 08	 lea	 ecx, DWORD PTR [rax+r9]
  005b8	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  005bd	66 03 c9	 add	 cx, cx
  005c0	41 f7 e1	 mul	 r9d
  005c3	66 44 2b c1	 sub	 r8w, cx
  005c7	66 41 83 c0 30	 add	 r8w, 48			; 00000030H
  005cc	66 45 89 42 fa	 mov	 WORD PTR [r10-6], r8w
  005d1	44 8b c2	 mov	 r8d, edx
  005d4	41 c1 e8 03	 shr	 r8d, 3
  005d8	41 0f b7 c0	 movzx	 eax, r8w
  005dc	66 c1 e0 02	 shl	 ax, 2
  005e0	42 8d 0c 00	 lea	 ecx, DWORD PTR [rax+r8]
  005e4	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  005e9	66 03 c9	 add	 cx, cx
  005ec	41 f7 e0	 mul	 r8d
  005ef	66 44 2b c9	 sub	 r9w, cx
  005f3	66 41 83 c1 30	 add	 r9w, 48			; 00000030H
  005f8	66 45 89 4a f8	 mov	 WORD PTR [r10-8], r9w
  005fd	44 8b ca	 mov	 r9d, edx
  00600	41 c1 e9 03	 shr	 r9d, 3
  00604	41 0f b7 c1	 movzx	 eax, r9w
  00608	66 c1 e0 02	 shl	 ax, 2
  0060c	42 8d 0c 08	 lea	 ecx, DWORD PTR [rax+r9]
  00610	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00615	66 03 c9	 add	 cx, cx
  00618	41 f7 e1	 mul	 r9d
  0061b	66 44 2b c1	 sub	 r8w, cx
  0061f	66 41 83 c0 30	 add	 r8w, 48			; 00000030H
  00624	66 45 89 42 f6	 mov	 WORD PTR [r10-10], r8w
  00629	44 8b c2	 mov	 r8d, edx
  0062c	41 c1 e8 03	 shr	 r8d, 3
  00630	41 0f b7 c0	 movzx	 eax, r8w
  00634	66 c1 e0 02	 shl	 ax, 2
  00638	42 8d 0c 00	 lea	 ecx, DWORD PTR [rax+r8]
  0063c	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00641	66 03 c9	 add	 cx, cx
  00644	41 f7 e0	 mul	 r8d
  00647	66 44 2b c9	 sub	 r9w, cx
  0064b	66 41 83 c1 30	 add	 r9w, 48			; 00000030H
  00650	66 45 89 4a f4	 mov	 WORD PTR [r10-12], r9w
  00655	44 8b ca	 mov	 r9d, edx
  00658	41 c1 e9 03	 shr	 r9d, 3
  0065c	41 0f b7 c1	 movzx	 eax, r9w
  00660	66 c1 e0 02	 shl	 ax, 2
  00664	42 8d 0c 08	 lea	 ecx, DWORD PTR [rax+r9]
  00668	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  0066d	66 03 c9	 add	 cx, cx
  00670	66 44 2b c1	 sub	 r8w, cx
  00674	66 41 83 c0 30	 add	 r8w, 48			; 00000030H
  00679	66 45 89 42 f2	 mov	 WORD PTR [r10-14], r8w
  0067e	41 f7 e1	 mul	 r9d
  00681	44 8b c2	 mov	 r8d, edx
  00684	41 c1 e8 03	 shr	 r8d, 3
  00688	49 83 c2 ee	 add	 r10, -18
  0068c	48 ff c5	 inc	 rbp
  0068f	41 0f b7 c0	 movzx	 eax, r8w
  00693	66 c1 e0 02	 shl	 ax, 2
  00697	42 8d 0c 00	 lea	 ecx, DWORD PTR [rax+r8]
  0069b	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  006a0	66 03 c9	 add	 cx, cx
  006a3	41 f7 e0	 mul	 r8d
  006a6	c1 ea 03	 shr	 edx, 3
  006a9	66 44 2b c9	 sub	 r9w, cx
  006ad	0f b7 c2	 movzx	 eax, dx
  006b0	66 41 83 c1 30	 add	 r9w, 48			; 00000030H
  006b5	66 c1 e0 02	 shl	 ax, 2
  006b9	66 45 89 4a 02	 mov	 WORD PTR [r10+2], r9w
  006be	66 03 d0	 add	 dx, ax
  006c1	66 03 d2	 add	 dx, dx
  006c4	66 44 2b c2	 sub	 r8w, dx
  006c8	66 41 83 c0 30	 add	 r8w, 48			; 00000030H
  006cd	66 45 89 02	 mov	 WORD PTR [r10], r8w
  006d1	48 3b eb	 cmp	 rbp, rbx
  006d4	0f 8c 66 fe ff
	ff		 jl	 $LL32@long_to_de
$LN30@long_to_de:
  006da	44 8b 44 af 70	 mov	 r8d, DWORD PTR [rdi+rbp*4+112]
  006df	90		 npad	 1
$LL26@long_to_de:
  006e0	49 83 ea 02	 sub	 r10, 2
  006e4	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  006e9	41 f7 e0	 mul	 r8d
  006ec	c1 ea 03	 shr	 edx, 3
  006ef	0f b7 c2	 movzx	 eax, dx
  006f2	66 c1 e0 02	 shl	 ax, 2
  006f6	8d 0c 10	 lea	 ecx, DWORD PTR [rax+rdx]
  006f9	66 03 c9	 add	 cx, cx
  006fc	66 44 2b c1	 sub	 r8w, cx
  00700	66 41 83 c0 30	 add	 r8w, 48			; 00000030H
  00705	66 45 89 02	 mov	 WORD PTR [r10], r8w
  00709	44 8b c2	 mov	 r8d, edx
  0070c	85 d2		 test	 edx, edx
  0070e	75 d0		 jne	 SHORT $LL26@long_to_de
  00710	45 85 f6	 test	 r14d, r14d
  00713	0f 84 f6 01 00
	00		 je	 $LN17@long_to_de
  00719	b8 2d 00 00 00	 mov	 eax, 45			; 0000002dH
  0071e	66 41 89 42 fe	 mov	 WORD PTR [r10-2], ax

; 1713 :     }
; 1714 :     else {

  00723	e9 e7 01 00 00	 jmp	 $LN17@long_to_de
$LN19@long_to_de:

; 1715 :         Py_UCS4 *p;
; 1716 :         assert (kind == PyUnicode_4BYTE_KIND);
; 1717 :         WRITE_DIGITS(Py_UCS4);

  00728	4d 85 e4	 test	 r12, r12
  0072b	74 50		 je	 SHORT $LN16@long_to_de
  0072d	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  00731	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  00734	f6 c1 20	 test	 cl, 32			; 00000020H
  00737	74 2f		 je	 SHORT $LN106@long_to_de
  00739	f6 c1 40	 test	 cl, 64			; 00000040H
  0073c	74 15		 je	 SHORT $LN104@long_to_de
  0073e	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  00745	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  0074a	48 03 c6	 add	 rax, rsi
  0074d	4c 8d 0c 81	 lea	 r9, QWORD PTR [rcx+rax*4]
  00751	eb 53		 jmp	 SHORT $LN15@long_to_de
$LN104@long_to_de:
  00753	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  0075a	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  0075f	48 03 c6	 add	 rax, rsi
  00762	4c 8d 0c 81	 lea	 r9, QWORD PTR [rcx+rax*4]
  00766	eb 3e		 jmp	 SHORT $LN15@long_to_de
$LN106@long_to_de:
  00768	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  0076f	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  00774	48 03 c6	 add	 rax, rsi
  00777	4c 8d 0c 81	 lea	 r9, QWORD PTR [rcx+rax*4]
  0077b	eb 29		 jmp	 SHORT $LN15@long_to_de
$LN16@long_to_de:
  0077d	41 8b 45 70	 mov	 eax, DWORD PTR [r13+112]
  00781	a8 20		 test	 al, 32			; 00000020H
  00783	74 16		 je	 SHORT $LN110@long_to_de
  00785	a8 40		 test	 al, 64			; 00000040H
  00787	74 09		 je	 SHORT $LN108@long_to_de
  00789	49 8d 85 80 00
	00 00		 lea	 rax, QWORD PTR [r13+128]
  00790	eb 10		 jmp	 SHORT $LN111@long_to_de
$LN108@long_to_de:
  00792	49 8d 85 a0 00
	00 00		 lea	 rax, QWORD PTR [r13+160]
  00799	eb 07		 jmp	 SHORT $LN111@long_to_de
$LN110@long_to_de:
  0079b	49 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR [r13+160]
$LN111@long_to_de:
  007a2	4c 8d 0c b0	 lea	 r9, QWORD PTR [rax+rsi*4]
$LN15@long_to_de:
  007a6	48 ff cb	 dec	 rbx
  007a9	41 89 29	 mov	 DWORD PTR [r9], ebp
  007ac	48 85 db	 test	 rbx, rbx
  007af	0f 8e 1e 01 00
	00		 jle	 $LN12@long_to_de
  007b5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL14@long_to_de:
  007c0	8b 4c af 70	 mov	 ecx, DWORD PTR [rdi+rbp*4+112]
  007c4	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  007c9	49 83 c1 dc	 add	 r9, -36			; ffffffffffffffdcH
  007cd	f7 e1		 mul	 ecx
  007cf	44 8b c2	 mov	 r8d, edx
  007d2	41 c1 e8 03	 shr	 r8d, 3
  007d6	43 8d 04 80	 lea	 eax, DWORD PTR [r8+r8*4]
  007da	03 c0		 add	 eax, eax
  007dc	2b c8		 sub	 ecx, eax
  007de	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  007e3	83 c1 30	 add	 ecx, 48			; 00000030H
  007e6	41 89 49 20	 mov	 DWORD PTR [r9+32], ecx
  007ea	41 f7 e0	 mul	 r8d
  007ed	8b ca		 mov	 ecx, edx
  007ef	c1 e9 03	 shr	 ecx, 3
  007f2	8d 04 89	 lea	 eax, DWORD PTR [rcx+rcx*4]
  007f5	03 c0		 add	 eax, eax
  007f7	44 2b c0	 sub	 r8d, eax
  007fa	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  007ff	41 83 c0 30	 add	 r8d, 48			; 00000030H
  00803	45 89 41 1c	 mov	 DWORD PTR [r9+28], r8d
  00807	f7 e1		 mul	 ecx
  00809	44 8b c2	 mov	 r8d, edx
  0080c	41 c1 e8 03	 shr	 r8d, 3
  00810	43 8d 04 80	 lea	 eax, DWORD PTR [r8+r8*4]
  00814	03 c0		 add	 eax, eax
  00816	2b c8		 sub	 ecx, eax
  00818	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  0081d	83 c1 30	 add	 ecx, 48			; 00000030H
  00820	41 89 49 18	 mov	 DWORD PTR [r9+24], ecx
  00824	41 f7 e0	 mul	 r8d
  00827	8b ca		 mov	 ecx, edx
  00829	c1 e9 03	 shr	 ecx, 3
  0082c	8d 04 89	 lea	 eax, DWORD PTR [rcx+rcx*4]
  0082f	03 c0		 add	 eax, eax
  00831	44 2b c0	 sub	 r8d, eax
  00834	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00839	41 83 c0 30	 add	 r8d, 48			; 00000030H
  0083d	45 89 41 14	 mov	 DWORD PTR [r9+20], r8d
  00841	f7 e1		 mul	 ecx
  00843	44 8b c2	 mov	 r8d, edx
  00846	41 c1 e8 03	 shr	 r8d, 3
  0084a	43 8d 04 80	 lea	 eax, DWORD PTR [r8+r8*4]
  0084e	03 c0		 add	 eax, eax
  00850	2b c8		 sub	 ecx, eax
  00852	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00857	83 c1 30	 add	 ecx, 48			; 00000030H
  0085a	41 89 49 10	 mov	 DWORD PTR [r9+16], ecx
  0085e	41 f7 e0	 mul	 r8d
  00861	8b ca		 mov	 ecx, edx
  00863	c1 e9 03	 shr	 ecx, 3
  00866	8d 04 89	 lea	 eax, DWORD PTR [rcx+rcx*4]
  00869	03 c0		 add	 eax, eax
  0086b	44 2b c0	 sub	 r8d, eax
  0086e	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00873	41 83 c0 30	 add	 r8d, 48			; 00000030H
  00877	45 89 41 0c	 mov	 DWORD PTR [r9+12], r8d
  0087b	f7 e1		 mul	 ecx
  0087d	44 8b c2	 mov	 r8d, edx
  00880	41 c1 e8 03	 shr	 r8d, 3
  00884	43 8d 04 80	 lea	 eax, DWORD PTR [r8+r8*4]
  00888	03 c0		 add	 eax, eax
  0088a	2b c8		 sub	 ecx, eax
  0088c	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  00891	83 c1 30	 add	 ecx, 48			; 00000030H
  00894	41 89 49 08	 mov	 DWORD PTR [r9+8], ecx
  00898	41 f7 e0	 mul	 r8d
  0089b	8b ca		 mov	 ecx, edx
  0089d	c1 e9 03	 shr	 ecx, 3
  008a0	8d 04 89	 lea	 eax, DWORD PTR [rcx+rcx*4]
  008a3	03 c0		 add	 eax, eax
  008a5	44 2b c0	 sub	 r8d, eax
  008a8	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  008ad	41 83 c0 30	 add	 r8d, 48			; 00000030H
  008b1	45 89 41 04	 mov	 DWORD PTR [r9+4], r8d
  008b5	f7 e1		 mul	 ecx
  008b7	c1 ea 03	 shr	 edx, 3
  008ba	8d 04 92	 lea	 eax, DWORD PTR [rdx+rdx*4]
  008bd	03 c0		 add	 eax, eax
  008bf	2b c8		 sub	 ecx, eax
  008c1	83 c1 30	 add	 ecx, 48			; 00000030H
  008c4	48 ff c5	 inc	 rbp
  008c7	41 89 09	 mov	 DWORD PTR [r9], ecx
  008ca	48 3b eb	 cmp	 rbp, rbx
  008cd	0f 8c ed fe ff
	ff		 jl	 $LL14@long_to_de
$LN12@long_to_de:
  008d3	8b 4c af 70	 mov	 ecx, DWORD PTR [rdi+rbp*4+112]
  008d7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL8@long_to_de:
  008e0	49 83 e9 04	 sub	 r9, 4
  008e4	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  008e9	f7 e1		 mul	 ecx
  008eb	c1 ea 03	 shr	 edx, 3
  008ee	8d 04 92	 lea	 eax, DWORD PTR [rdx+rdx*4]
  008f1	03 c0		 add	 eax, eax
  008f3	2b c8		 sub	 ecx, eax
  008f5	83 c1 30	 add	 ecx, 48			; 00000030H
  008f8	41 89 09	 mov	 DWORD PTR [r9], ecx
  008fb	8b ca		 mov	 ecx, edx
  008fd	85 d2		 test	 edx, edx
  008ff	75 df		 jne	 SHORT $LL8@long_to_de
  00901	45 85 f6	 test	 r14d, r14d
  00904	74 09		 je	 SHORT $LN17@long_to_de
  00906	b8 2d 00 00 00	 mov	 eax, 45			; 0000002dH
  0090b	41 89 41 fc	 mov	 DWORD PTR [r9-4], eax
$LN17@long_to_de:

; 1718 :     }
; 1719 : #undef WRITE_DIGITS
; 1720 : 
; 1721 :     Py_DECREF(scratch);

  0090f	e8 00 00 00 00	 call	 _Py_PXCTX
  00914	85 c0		 test	 eax, eax
  00916	75 5c		 jne	 SHORT $LN122@long_to_de
  00918	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0091c	a8 20		 test	 al, 32			; 00000020H
  0091e	75 4c		 jne	 SHORT $LN116@long_to_de
  00920	84 c0		 test	 al, al
  00922	78 48		 js	 SHORT $LN116@long_to_de
  00924	a8 02		 test	 al, 2
  00926	75 4c		 jne	 SHORT $LN122@long_to_de
  00928	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0092c	75 46		 jne	 SHORT $LN122@long_to_de
  0092e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00935	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0093c	4c 8b cf	 mov	 r9, rdi
  0093f	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00945	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0094d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00952	48 8b cf	 mov	 rcx, rdi
  00955	85 c0		 test	 eax, eax
  00957	74 07		 je	 SHORT $LN121@long_to_de
  00959	e8 00 00 00 00	 call	 _Px_Dealloc
  0095e	eb 14		 jmp	 SHORT $LN122@long_to_de
$LN121@long_to_de:
  00960	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00964	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0096a	eb 08		 jmp	 SHORT $LN122@long_to_de
$LN116@long_to_de:
  0096c	48 8b cf	 mov	 rcx, rdi
  0096f	e8 00 00 00 00	 call	 Px_DecRef
$LN122@long_to_de:

; 1722 :     if (writer) {

  00974	4d 85 e4	 test	 r12, r12
  00977	74 0c		 je	 SHORT $LN2@long_to_de

; 1723 :         writer->pos += strlen;

  00979	49 01 74 24 20	 add	 QWORD PTR [r12+32], rsi

; 1728 :     }
; 1729 :     return 0;

  0097e	33 c0		 xor	 eax, eax
  00980	e9 a8 f8 ff ff	 jmp	 $LN181@long_to_de
$LN2@long_to_de:

; 1724 :     }
; 1725 :     else {
; 1726 :         assert(_PyUnicode_CheckConsistency(str, 1));
; 1727 :         *p_output = (PyObject *)str;

  00985	4d 89 2f	 mov	 QWORD PTR [r15], r13

; 1728 :     }
; 1729 :     return 0;

  00988	33 c0		 xor	 eax, eax
  0098a	e9 9e f8 ff ff	 jmp	 $LN181@long_to_de
$LN78@long_to_de:

; 1590 :         PyErr_BadInternalCall();

  0098f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00996	ba 36 06 00 00	 mov	 edx, 1590		; 00000636H
  0099b	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1591 :         return -1;

  009a0	83 c8 ff	 or	 eax, -1

; 1730 : }

  009a3	48 83 c4 40	 add	 rsp, 64			; 00000040H
  009a7	41 5f		 pop	 r15
  009a9	41 5d		 pop	 r13
  009ab	41 5c		 pop	 r12
  009ad	c3		 ret	 0
long_to_decimal_string_internal ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_to_decimal_string DD imagerel long_to_decimal_string
	DD	imagerel long_to_decimal_string+39
	DD	imagerel $unwind$long_to_decimal_string
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_to_decimal_string DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT long_to_decimal_string
_TEXT	SEGMENT
aa$ = 48
v$ = 56
long_to_decimal_string PROC				; COMDAT

; 1734 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1735 :     PyObject *v;
; 1736 :     if (long_to_decimal_string_internal(aa, &v, NULL) == -1)

  00004	48 8d 54 24 38	 lea	 rdx, QWORD PTR v$[rsp]
  00009	45 33 c0	 xor	 r8d, r8d
  0000c	e8 00 00 00 00	 call	 long_to_decimal_string_internal
  00011	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$[rsp]
  00016	33 d2		 xor	 edx, edx
  00018	83 f8 ff	 cmp	 eax, -1
  0001b	48 0f 44 ca	 cmove	 rcx, rdx
  0001f	48 8b c1	 mov	 rax, rcx

; 1737 :         return NULL;
; 1738 :     return v;
; 1739 : }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
long_to_decimal_string ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@JIIGGCNL@int?5is?5too?5large?5to?5format?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_format_binary DD imagerel long_format_binary
	DD	imagerel long_format_binary+58
	DD	imagerel $unwind$long_format_binary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$long_format_binary DD imagerel long_format_binary+58
	DD	imagerel long_format_binary+253
	DD	imagerel $chain$3$long_format_binary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$long_format_binary DD imagerel long_format_binary+253
	DD	imagerel long_format_binary+393
	DD	imagerel $chain$5$long_format_binary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$long_format_binary DD imagerel long_format_binary+393
	DD	imagerel long_format_binary+420
	DD	imagerel $chain$6$long_format_binary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$long_format_binary DD imagerel long_format_binary+420
	DD	imagerel long_format_binary+1553
	DD	imagerel $chain$8$long_format_binary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$long_format_binary DD imagerel long_format_binary+1553
	DD	imagerel long_format_binary+1580
	DD	imagerel $chain$9$long_format_binary
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$long_format_binary DD 021H
	DD	imagerel long_format_binary
	DD	imagerel long_format_binary+58
	DD	imagerel $unwind$long_format_binary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$long_format_binary DD 0c0021H
	DD	07f400H
	DD	08e400H
	DD	09d400H
	DD	0ac400H
	DD	0b6400H
	DD	0c3400H
	DD	imagerel long_format_binary
	DD	imagerel long_format_binary+58
	DD	imagerel $unwind$long_format_binary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$long_format_binary DD 021H
	DD	imagerel long_format_binary+58
	DD	imagerel long_format_binary+253
	DD	imagerel $chain$3$long_format_binary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$long_format_binary DD 042021H
	DD	08e420H
	DD	07f405H
	DD	imagerel long_format_binary+58
	DD	imagerel long_format_binary+253
	DD	imagerel $chain$3$long_format_binary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$long_format_binary DD 083121H
	DD	0c3431H
	DD	09d40fH
	DD	0ac40aH
	DD	0b6405H
	DD	imagerel long_format_binary
	DD	imagerel long_format_binary+58
	DD	imagerel $unwind$long_format_binary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_format_binary DD 031401H
	DD	07010c214H
	DD	0500fH
xdata	ENDS
;	COMDAT ??_C@_0BL@JIIGGCNL@int?5is?5too?5large?5to?5format?$AA@
CONST	SEGMENT
??_C@_0BL@JIIGGCNL@int?5is?5too?5large?5to?5format?$AA@ DB 'int is too la'
	DB	'rge to format', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT long_format_binary
_TEXT	SEGMENT
sz$1$ = 32
v$1$ = 40
negative$1$ = 128
aa$ = 128
base$ = 136
alternate$ = 144
p_output$ = 152
writer$ = 160
long_format_binary PROC					; COMDAT

; 1749 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	55		 push	 rbp
  0000f	57		 push	 rdi
  00010	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00014	8b ea		 mov	 ebp, edx
  00016	48 8b f9	 mov	 rdi, rcx

; 1750 :     register PyLongObject *a = (PyLongObject *)aa;
; 1751 :     PyObject *v;
; 1752 :     Py_ssize_t sz;
; 1753 :     Py_ssize_t size_a;
; 1754 :     enum PyUnicode_Kind kind;
; 1755 :     int negative;
; 1756 :     int bits;
; 1757 : 
; 1758 :     assert(base == 2 || base == 8 || base == 16);
; 1759 :     if (a == NULL || !PyLong_Check(a)) {

  00019	48 85 c9	 test	 rcx, rcx
  0001c	0f 84 ef 05 00
	00		 je	 $LN84@long_forma
  00022	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00026	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00030	0f 84 db 05 00
	00		 je	 $LN84@long_forma

; 1762 :     }
; 1763 :     size_a = ABS(Py_SIZE(a));

  00036	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  0003a	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  0003f	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  00044	4c 89 6c 24 48	 mov	 QWORD PTR [rsp+72], r13
  00049	4c 8b e8	 mov	 r13, rax
  0004c	48 85 c0	 test	 rax, rax
  0004f	79 03		 jns	 SHORT $LN89@long_forma
  00051	49 f7 dd	 neg	 r13
$LN89@long_forma:

; 1764 :     negative = Py_SIZE(a) < 0;

  00054	45 33 d2	 xor	 r10d, r10d
  00057	48 85 c0	 test	 rax, rax

; 1765 : 
; 1766 :     /* Compute a rough upper bound for the length of the string */
; 1767 :     switch (base) {

  0005a	be 01 00 00 00	 mov	 esi, 1
  0005f	45 8b e2	 mov	 r12d, r10d
  00062	41 0f 98 c4	 sets	 r12b
  00066	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  0006b	44 89 a4 24 80
	00 00 00	 mov	 DWORD PTR negative$1$[rsp], r12d
  00073	48 89 74 24 20	 mov	 QWORD PTR sz$1$[rsp], rsi
  00078	83 fa 02	 cmp	 edx, 2
  0007b	74 1a		 je	 SHORT $LN79@long_forma
  0007d	83 fa 08	 cmp	 edx, 8
  00080	74 0e		 je	 SHORT $LN80@long_forma
  00082	bb 04 00 00 00	 mov	 ebx, 4
  00087	83 fa 10	 cmp	 edx, 16
  0008a	41 0f 45 da	 cmovne	 ebx, r10d

; 1768 :     case 16:
; 1769 :         bits = 4;
; 1770 :         break;

  0008e	eb 09		 jmp	 SHORT $LN82@long_forma
$LN80@long_forma:

; 1771 :     case 8:
; 1772 :         bits = 3;

  00090	bb 03 00 00 00	 mov	 ebx, 3

; 1773 :         break;

  00095	eb 02		 jmp	 SHORT $LN82@long_forma
$LN79@long_forma:

; 1774 :     case 2:
; 1775 :         bits = 1;

  00097	8b de		 mov	 ebx, esi
$LN82@long_forma:

; 1776 :         break;
; 1777 :     default:
; 1778 :         assert(0); /* shouldn't ever get here */
; 1779 :         bits = 0; /* to silence gcc warning */
; 1780 :     }
; 1781 : 
; 1782 :     /* Compute exact length 'sz' of output string. */
; 1783 :     if (size_a == 0) {

  00099	4d 85 ed	 test	 r13, r13
  0009c	74 5f		 je	 SHORT $LN76@long_forma

; 1784 :         sz = 1;
; 1785 :     }
; 1786 :     else {
; 1787 :         Py_ssize_t size_a_in_bits;
; 1788 :         /* Ensure overflow doesn't occur during computation of sz. */
; 1789 :         if (size_a > (PY_SSIZE_T_MAX - 3) / PyLong_SHIFT) {

  0009e	48 b8 44 44 44
	44 44 44 44 04	 mov	 rax, 307445734561825860	; 0444444444444444H
  000a8	4c 3b e8	 cmp	 r13, rax
  000ab	7e 1b		 jle	 SHORT $LN75@long_forma

; 1790 :             PyErr_SetString(PyExc_OverflowError,
; 1791 :                             "int is too large to format");

  000ad	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@JIIGGCNL@int?5is?5too?5large?5to?5format?$AA@
  000bb	e8 00 00 00 00	 call	 PyErr_SetString

; 1792 :             return -1;

  000c0	83 c8 ff	 or	 eax, -1
  000c3	e9 c1 00 00 00	 jmp	 $LN137@long_forma
$LN75@long_forma:

; 1793 :         }
; 1794 :         size_a_in_bits = (size_a - 1) * PyLong_SHIFT +
; 1795 :                          bits_in_digit(a->ob_digit[size_a - 1]);

  000c8	42 8b 4c a9 6c	 mov	 ecx, DWORD PTR [rcx+r13*4+108]
  000cd	e8 00 00 00 00	 call	 bits_in_digit

; 1796 :         /* Allow 1 character for a '-' sign. */
; 1797 :         sz = negative + (size_a_in_bits + (bits - 1)) / bits;

  000d2	49 63 f4	 movsxd	 rsi, r12d
  000d5	48 63 d0	 movsxd	 rdx, eax
  000d8	8d 43 ff	 lea	 eax, DWORD PTR [rbx-1]
  000db	48 63 c8	 movsxd	 rcx, eax
  000de	49 8b c5	 mov	 rax, r13
  000e1	48 03 d1	 add	 rdx, rcx
  000e4	48 63 cb	 movsxd	 rcx, ebx
  000e7	48 6b c0 1e	 imul	 rax, 30
  000eb	48 8d 44 02 e2	 lea	 rax, QWORD PTR [rdx+rax-30]
  000f0	48 99		 cdq
  000f2	48 f7 f9	 idiv	 rcx
  000f5	48 03 f0	 add	 rsi, rax
  000f8	48 89 74 24 20	 mov	 QWORD PTR sz$1$[rsp], rsi
$LN76@long_forma:

; 1798 :     }
; 1799 :     if (alternate) {

  000fd	4c 89 7c 24 38	 mov	 QWORD PTR [rsp+56], r15
  00102	45 85 c0	 test	 r8d, r8d
  00105	74 09		 je	 SHORT $LN74@long_forma

; 1800 :         /* 2 characters for prefix  */
; 1801 :         sz += 2;

  00107	48 83 c6 02	 add	 rsi, 2
  0010b	48 89 74 24 20	 mov	 QWORD PTR sz$1$[rsp], rsi
$LN74@long_forma:

; 1802 :     }
; 1803 : 
; 1804 :     if (writer) {

  00110	4c 8b bc 24 a0
	00 00 00	 mov	 r15, QWORD PTR writer$[rsp]
  00118	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14

; 1805 :         if (_PyUnicodeWriter_Prepare(writer, sz, 'x') == -1)

  0011d	41 be 78 00 00
	00		 mov	 r14d, 120		; 00000078H
  00123	4d 85 ff	 test	 r15, r15
  00126	74 3c		 je	 SHORT $LN73@long_forma
  00128	45 39 77 14	 cmp	 DWORD PTR [r15+20], r14d
  0012c	72 0d		 jb	 SHORT $LN90@long_forma
  0012e	49 8b 47 18	 mov	 rax, QWORD PTR [r15+24]
  00132	49 2b 47 20	 sub	 rax, QWORD PTR [r15+32]
  00136	48 3b f0	 cmp	 rsi, rax
  00139	7e 1b		 jle	 SHORT $LN72@long_forma
$LN90@long_forma:
  0013b	48 85 f6	 test	 rsi, rsi
  0013e	74 16		 je	 SHORT $LN72@long_forma
  00140	45 8b c6	 mov	 r8d, r14d
  00143	48 8b d6	 mov	 rdx, rsi
  00146	49 8b cf	 mov	 rcx, r15
  00149	e8 00 00 00 00	 call	 _PyUnicodeWriter_PrepareInternal
  0014e	83 f8 ff	 cmp	 eax, -1

; 1806 :             return -1;

  00151	74 29		 je	 SHORT $LN142@long_forma

; 1881 :     }
; 1882 :     else {
; 1883 :         assert(_PyUnicode_CheckConsistency(v, 1));
; 1884 :         *p_output = v;

  00153	45 33 d2	 xor	 r10d, r10d
$LN72@long_forma:

; 1807 :         kind = writer->kind;

  00156	41 8b 47 10	 mov	 eax, DWORD PTR [r15+16]

; 1808 :         v = NULL;

  0015a	49 8b ca	 mov	 rcx, r10
  0015d	48 89 4c 24 28	 mov	 QWORD PTR v$1$[rsp], rcx

; 1809 :     }
; 1810 :     else {

  00162	eb 4c		 jmp	 SHORT $LN71@long_forma
$LN73@long_forma:

; 1811 :         v = PyUnicode_New(sz, 'x');

  00164	41 8b d6	 mov	 edx, r14d
  00167	48 8b ce	 mov	 rcx, rsi
  0016a	e8 00 00 00 00	 call	 PyUnicode_New
  0016f	48 8b c8	 mov	 rcx, rax
  00172	48 89 44 24 28	 mov	 QWORD PTR v$1$[rsp], rax

; 1812 :         if (v == NULL)

  00177	48 85 c0	 test	 rax, rax
  0017a	75 28		 jne	 SHORT $LN70@long_forma
$LN142@long_forma:

; 1813 :             return -1;

  0017c	83 c8 ff	 or	 eax, -1
$LN139@long_forma:
  0017f	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]
  00184	4c 8b 7c 24 38	 mov	 r15, QWORD PTR [rsp+56]
$LN137@long_forma:
  00189	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0018e	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00193	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  00198	4c 8b 6c 24 48	 mov	 r13, QWORD PTR [rsp+72]

; 1887 : }

  0019d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001a1	5f		 pop	 rdi
  001a2	5d		 pop	 rbp
  001a3	c3		 ret	 0
$LN70@long_forma:

; 1814 :         kind = PyUnicode_KIND(v);

  001a4	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001a7	c1 e8 02	 shr	 eax, 2
  001aa	83 e0 07	 and	 eax, 7
  001ad	45 33 d2	 xor	 r10d, r10d
$LN71@long_forma:

; 1815 :     }
; 1816 : 
; 1817 : #define WRITE_DIGITS(TYPE)                                              \
; 1818 :     do {                                                                \
; 1819 :         if (writer)                                                     \
; 1820 :             p = (TYPE*)PyUnicode_DATA(writer->buffer) + writer->pos + sz; \
; 1821 :         else                                                            \
; 1822 :             p = (TYPE*)PyUnicode_DATA(v) + sz;                          \
; 1823 :                                                                         \
; 1824 :         if (size_a == 0) {                                              \
; 1825 :             *--p = '0';                                                 \
; 1826 :         }                                                               \
; 1827 :         else {                                                          \
; 1828 :             /* JRH: special case for power-of-2 bases */                \
; 1829 :             twodigits accum = 0;                                        \
; 1830 :             int accumbits = 0;   /* # of bits in accum */               \
; 1831 :             Py_ssize_t i;                                               \
; 1832 :             for (i = 0; i < size_a; ++i) {                              \
; 1833 :                 accum |= (twodigits)a->ob_digit[i] << accumbits;        \
; 1834 :                 accumbits += PyLong_SHIFT;                              \
; 1835 :                 assert(accumbits >= bits);                              \
; 1836 :                 do {                                                    \
; 1837 :                     char cdigit;                                        \
; 1838 :                     cdigit = (char)(accum & (base - 1));                \
; 1839 :                     cdigit += (cdigit < 10) ? '0' : 'a'-10;             \
; 1840 :                     *--p = cdigit;                                      \
; 1841 :                     accumbits -= bits;                                  \
; 1842 :                     accum >>= bits;                                     \
; 1843 :                 } while (i < size_a-1 ? accumbits >= bits : accum > 0); \
; 1844 :             }                                                           \
; 1845 :         }                                                               \
; 1846 :                                                                         \
; 1847 :         if (alternate) {                                                \
; 1848 :             if (base == 16)                                             \
; 1849 :                 *--p = 'x';                                             \
; 1850 :             else if (base == 8)                                         \
; 1851 :                 *--p = 'o';                                             \
; 1852 :             else /* (base == 2) */                                      \
; 1853 :                 *--p = 'b';                                             \
; 1854 :             *--p = '0';                                                 \
; 1855 :         }                                                               \
; 1856 :         if (negative)                                                   \
; 1857 :             *--p = '-';                                                 \
; 1858 :         if (writer)                                                     \
; 1859 :             assert(p == ((TYPE*)PyUnicode_DATA(writer->buffer) + writer->pos)); \
; 1860 :         else                                                            \
; 1861 :             assert(p == (TYPE*)PyUnicode_DATA(v));                      \
; 1862 :     } while (0)
; 1863 : 
; 1864 :     if (kind == PyUnicode_1BYTE_KIND) {

  001b0	83 f8 01	 cmp	 eax, 1
  001b3	0f 85 60 01 00
	00		 jne	 $LN69@long_forma

; 1865 :         Py_UCS1 *p;
; 1866 :         WRITE_DIGITS(Py_UCS1);

  001b9	4d 85 ff	 test	 r15, r15
  001bc	74 45		 je	 SHORT $LN65@long_forma
  001be	49 8b 07	 mov	 rax, QWORD PTR [r15]
  001c1	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  001c4	f6 c1 20	 test	 cl, 32			; 00000020H
  001c7	74 27		 je	 SHORT $LN96@long_forma
  001c9	f6 c1 40	 test	 cl, 64			; 00000040H
  001cc	74 10		 je	 SHORT $LN94@long_forma
  001ce	49 8b 57 20	 mov	 rdx, QWORD PTR [r15+32]
  001d2	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  001d6	48 03 d0	 add	 rdx, rax
  001d9	48 03 d6	 add	 rdx, rsi
  001dc	eb 4d		 jmp	 SHORT $LN64@long_forma
$LN94@long_forma:
  001de	49 8b 57 20	 mov	 rdx, QWORD PTR [r15+32]
  001e2	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  001e8	48 03 d0	 add	 rdx, rax
  001eb	48 03 d6	 add	 rdx, rsi
  001ee	eb 3b		 jmp	 SHORT $LN64@long_forma
$LN96@long_forma:
  001f0	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  001f7	49 8b 57 20	 mov	 rdx, QWORD PTR [r15+32]
  001fb	48 03 d0	 add	 rdx, rax
  001fe	48 03 d6	 add	 rdx, rsi
  00201	eb 28		 jmp	 SHORT $LN64@long_forma
$LN65@long_forma:
  00203	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00206	a8 20		 test	 al, 32			; 00000020H
  00208	74 16		 je	 SHORT $LN100@long_forma
  0020a	a8 40		 test	 al, 64			; 00000040H
  0020c	74 09		 je	 SHORT $LN98@long_forma
  0020e	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  00215	eb 10		 jmp	 SHORT $LN101@long_forma
$LN98@long_forma:
  00217	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  0021e	eb 07		 jmp	 SHORT $LN101@long_forma
$LN100@long_forma:
  00220	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
$LN101@long_forma:
  00227	48 8d 14 30	 lea	 rdx, QWORD PTR [rax+rsi]
$LN64@long_forma:
  0022b	4d 85 ed	 test	 r13, r13
  0022e	75 0b		 jne	 SHORT $LN63@long_forma
  00230	48 ff ca	 dec	 rdx
  00233	c6 02 30	 mov	 BYTE PTR [rdx], 48	; 00000030H
  00236	e9 a2 00 00 00	 jmp	 $LN59@long_forma
$LN63@long_forma:
  0023b	45 33 f6	 xor	 r14d, r14d
  0023e	45 8b c6	 mov	 r8d, r14d
  00241	45 8b ce	 mov	 r9d, r14d
  00244	45 8b d6	 mov	 r10d, r14d
  00247	4d 85 ed	 test	 r13, r13
  0024a	0f 8e 8d 00 00
	00		 jle	 $LN59@long_forma
  00250	44 8d 5d ff	 lea	 r11d, DWORD PTR [rbp-1]
  00254	48 63 f3	 movsxd	 rsi, ebx
  00257	48 83 c7 70	 add	 rdi, 112		; 00000070H
  0025b	49 8d 6d ff	 lea	 rbp, QWORD PTR [r13-1]
  0025f	45 8d 66 30	 lea	 r12d, QWORD PTR [r14+48]
  00263	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL61@long_forma:
  00270	8b 07		 mov	 eax, DWORD PTR [rdi]
  00272	41 8b c9	 mov	 ecx, r9d
  00275	48 d3 e0	 shl	 rax, cl
  00278	4c 0b c0	 or	 r8, rax
  0027b	41 83 c1 1e	 add	 r9d, 30
  0027f	90		 npad	 1
$LL58@long_forma:
  00280	48 ff ca	 dec	 rdx
  00283	41 0f b6 cb	 movzx	 ecx, r11b
  00287	b8 57 00 00 00	 mov	 eax, 87			; 00000057H
  0028c	41 22 c8	 and	 cl, r8b
  0028f	80 f9 0a	 cmp	 cl, 10
  00292	41 0f 4c c4	 cmovl	 eax, r12d
  00296	44 2b cb	 sub	 r9d, ebx
  00299	02 c1		 add	 al, cl
  0029b	48 8b ce	 mov	 rcx, rsi
  0029e	49 d3 e8	 shr	 r8, cl
  002a1	88 02		 mov	 BYTE PTR [rdx], al
  002a3	41 8b c6	 mov	 eax, r14d
  002a6	4c 3b d5	 cmp	 r10, rbp
  002a9	7d 08		 jge	 SHORT $LN102@long_forma
  002ab	44 3b cb	 cmp	 r9d, ebx
  002ae	0f 9d c0	 setge	 al
  002b1	eb 06		 jmp	 SHORT $LN103@long_forma
$LN102@long_forma:
  002b3	4d 85 c0	 test	 r8, r8
  002b6	0f 95 c0	 setne	 al
$LN103@long_forma:
  002b9	85 c0		 test	 eax, eax
  002bb	75 c3		 jne	 SHORT $LL58@long_forma
  002bd	49 ff c2	 inc	 r10
  002c0	48 83 c7 04	 add	 rdi, 4
  002c4	4d 3b d5	 cmp	 r10, r13
  002c7	7c a7		 jl	 SHORT $LL61@long_forma
  002c9	48 8b 74 24 20	 mov	 rsi, QWORD PTR sz$1$[rsp]
  002ce	8b ac 24 88 00
	00 00		 mov	 ebp, DWORD PTR base$[rsp]
  002d5	44 8b a4 24 80
	00 00 00	 mov	 r12d, DWORD PTR negative$1$[rsp]
$LN59@long_forma:
  002dd	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR alternate$[rsp], 0
  002e5	74 20		 je	 SHORT $LN55@long_forma
  002e7	48 ff ca	 dec	 rdx
  002ea	83 fd 10	 cmp	 ebp, 16
  002ed	75 05		 jne	 SHORT $LN54@long_forma
  002ef	c6 02 78	 mov	 BYTE PTR [rdx], 120	; 00000078H
  002f2	eb 0d		 jmp	 SHORT $LN51@long_forma
$LN54@long_forma:
  002f4	83 fd 08	 cmp	 ebp, 8
  002f7	75 05		 jne	 SHORT $LN52@long_forma
  002f9	c6 02 6f	 mov	 BYTE PTR [rdx], 111	; 0000006fH
  002fc	eb 03		 jmp	 SHORT $LN51@long_forma
$LN52@long_forma:
  002fe	c6 02 62	 mov	 BYTE PTR [rdx], 98	; 00000062H
$LN51@long_forma:
  00301	48 ff ca	 dec	 rdx
  00304	c6 02 30	 mov	 BYTE PTR [rdx], 48	; 00000030H
$LN55@long_forma:
  00307	45 85 e4	 test	 r12d, r12d
  0030a	0f 84 da 02 00
	00		 je	 $LN21@long_forma
  00310	c6 42 ff 2d	 mov	 BYTE PTR [rdx-1], 45	; 0000002dH

; 1867 :     }
; 1868 :     else if (kind == PyUnicode_2BYTE_KIND) {

  00314	e9 d1 02 00 00	 jmp	 $LN21@long_forma
$LN69@long_forma:
  00319	83 f8 02	 cmp	 eax, 2
  0031c	0f 85 66 01 00
	00		 jne	 $LN23@long_forma

; 1869 :         Py_UCS2 *p;
; 1870 :         WRITE_DIGITS(Py_UCS2);

  00322	4d 85 ff	 test	 r15, r15
  00325	74 4c		 je	 SHORT $LN42@long_forma
  00327	49 8b 07	 mov	 rax, QWORD PTR [r15]
  0032a	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  0032d	f6 c1 20	 test	 cl, 32			; 00000020H
  00330	74 2d		 je	 SHORT $LN106@long_forma
  00332	f6 c1 40	 test	 cl, 64			; 00000040H
  00335	74 14		 je	 SHORT $LN104@long_forma
  00337	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  0033e	49 8b 47 20	 mov	 rax, QWORD PTR [r15+32]
  00342	48 03 c6	 add	 rax, rsi
  00345	48 8d 14 41	 lea	 rdx, QWORD PTR [rcx+rax*2]
  00349	eb 50		 jmp	 SHORT $LN41@long_forma
$LN104@long_forma:
  0034b	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  00352	49 8b 47 20	 mov	 rax, QWORD PTR [r15+32]
  00356	48 03 c6	 add	 rax, rsi
  00359	48 8d 14 41	 lea	 rdx, QWORD PTR [rcx+rax*2]
  0035d	eb 3c		 jmp	 SHORT $LN41@long_forma
$LN106@long_forma:
  0035f	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  00366	49 8b 47 20	 mov	 rax, QWORD PTR [r15+32]
  0036a	48 03 c6	 add	 rax, rsi
  0036d	48 8d 14 41	 lea	 rdx, QWORD PTR [rcx+rax*2]
  00371	eb 28		 jmp	 SHORT $LN41@long_forma
$LN42@long_forma:
  00373	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00376	a8 20		 test	 al, 32			; 00000020H
  00378	74 16		 je	 SHORT $LN110@long_forma
  0037a	a8 40		 test	 al, 64			; 00000040H
  0037c	74 09		 je	 SHORT $LN108@long_forma
  0037e	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  00385	eb 10		 jmp	 SHORT $LN111@long_forma
$LN108@long_forma:
  00387	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  0038e	eb 07		 jmp	 SHORT $LN111@long_forma
$LN110@long_forma:
  00390	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
$LN111@long_forma:
  00397	48 8d 14 70	 lea	 rdx, QWORD PTR [rax+rsi*2]
$LN41@long_forma:
  0039b	41 bc 30 00 00
	00		 mov	 r12d, 48		; 00000030H
  003a1	4d 85 ed	 test	 r13, r13
  003a4	75 0d		 jne	 SHORT $LN40@long_forma
  003a6	48 83 ea 02	 sub	 rdx, 2
  003aa	66 44 89 22	 mov	 WORD PTR [rdx], r12w
  003ae	e9 86 00 00 00	 jmp	 $LN36@long_forma
$LN40@long_forma:
  003b3	4d 8b ca	 mov	 r9, r10
  003b6	45 8b c2	 mov	 r8d, r10d
  003b9	4d 85 ed	 test	 r13, r13
  003bc	7e 7b		 jle	 SHORT $LN36@long_forma
  003be	44 8d 5d ff	 lea	 r11d, DWORD PTR [rbp-1]
  003c2	48 63 f3	 movsxd	 rsi, ebx
  003c5	48 83 c7 70	 add	 rdi, 112		; 00000070H
  003c9	49 8d 6d ff	 lea	 rbp, QWORD PTR [r13-1]
  003cd	0f 1f 00	 npad	 3
$LL38@long_forma:
  003d0	8b 07		 mov	 eax, DWORD PTR [rdi]
  003d2	41 8b c8	 mov	 ecx, r8d
  003d5	48 d3 e0	 shl	 rax, cl
  003d8	4c 0b c8	 or	 r9, rax
  003db	41 83 c0 1e	 add	 r8d, 30
  003df	90		 npad	 1
$LL35@long_forma:
  003e0	48 83 ea 02	 sub	 rdx, 2
  003e4	41 0f b6 cb	 movzx	 ecx, r11b
  003e8	b8 57 00 00 00	 mov	 eax, 87			; 00000057H
  003ed	41 22 c9	 and	 cl, r9b
  003f0	80 f9 0a	 cmp	 cl, 10
  003f3	41 0f 4c c4	 cmovl	 eax, r12d
  003f7	44 2b c3	 sub	 r8d, ebx
  003fa	02 c1		 add	 al, cl
  003fc	48 8b ce	 mov	 rcx, rsi
  003ff	0f be c0	 movsx	 eax, al
  00402	49 d3 e9	 shr	 r9, cl
  00405	66 89 02	 mov	 WORD PTR [rdx], ax
  00408	33 c0		 xor	 eax, eax
  0040a	4c 3b d5	 cmp	 r10, rbp
  0040d	7d 08		 jge	 SHORT $LN112@long_forma
  0040f	44 3b c3	 cmp	 r8d, ebx
  00412	0f 9d c0	 setge	 al
  00415	eb 06		 jmp	 SHORT $LN113@long_forma
$LN112@long_forma:
  00417	4d 85 c9	 test	 r9, r9
  0041a	0f 95 c0	 setne	 al
$LN113@long_forma:
  0041d	85 c0		 test	 eax, eax
  0041f	75 bf		 jne	 SHORT $LL35@long_forma
  00421	49 ff c2	 inc	 r10
  00424	48 83 c7 04	 add	 rdi, 4
  00428	4d 3b d5	 cmp	 r10, r13
  0042b	7c a3		 jl	 SHORT $LL38@long_forma
  0042d	48 8b 74 24 20	 mov	 rsi, QWORD PTR sz$1$[rsp]
  00432	8b ac 24 88 00
	00 00		 mov	 ebp, DWORD PTR base$[rsp]
$LN36@long_forma:
  00439	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR alternate$[rsp], 0
  00441	74 29		 je	 SHORT $LN32@long_forma
  00443	48 83 ea 02	 sub	 rdx, 2
  00447	83 fd 10	 cmp	 ebp, 16
  0044a	75 06		 jne	 SHORT $LN31@long_forma
  0044c	66 44 89 32	 mov	 WORD PTR [rdx], r14w
  00450	eb 12		 jmp	 SHORT $LN28@long_forma
$LN31@long_forma:
  00452	b8 6f 00 00 00	 mov	 eax, 111		; 0000006fH
  00457	83 fd 08	 cmp	 ebp, 8
  0045a	74 05		 je	 SHORT $LN140@long_forma
  0045c	b8 62 00 00 00	 mov	 eax, 98			; 00000062H
$LN140@long_forma:
  00461	66 89 02	 mov	 WORD PTR [rdx], ax
$LN28@long_forma:
  00464	48 83 ea 02	 sub	 rdx, 2
  00468	66 44 89 22	 mov	 WORD PTR [rdx], r12w
$LN32@long_forma:
  0046c	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR negative$1$[rsp], 0
  00474	0f 84 70 01 00
	00		 je	 $LN21@long_forma
  0047a	b8 2d 00 00 00	 mov	 eax, 45			; 0000002dH
  0047f	66 89 42 fe	 mov	 WORD PTR [rdx-2], ax

; 1871 :     }
; 1872 :     else {

  00483	e9 62 01 00 00	 jmp	 $LN21@long_forma
$LN23@long_forma:

; 1873 :         Py_UCS4 *p;
; 1874 :         assert (kind == PyUnicode_4BYTE_KIND);
; 1875 :         WRITE_DIGITS(Py_UCS4);

  00488	4d 85 ff	 test	 r15, r15
  0048b	74 4c		 je	 SHORT $LN20@long_forma
  0048d	49 8b 07	 mov	 rax, QWORD PTR [r15]
  00490	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  00493	f6 c1 20	 test	 cl, 32			; 00000020H
  00496	74 2d		 je	 SHORT $LN116@long_forma
  00498	f6 c1 40	 test	 cl, 64			; 00000040H
  0049b	74 14		 je	 SHORT $LN114@long_forma
  0049d	48 8d 88 80 00
	00 00		 lea	 rcx, QWORD PTR [rax+128]
  004a4	49 8b 47 20	 mov	 rax, QWORD PTR [r15+32]
  004a8	48 03 c6	 add	 rax, rsi
  004ab	48 8d 14 81	 lea	 rdx, QWORD PTR [rcx+rax*4]
  004af	eb 50		 jmp	 SHORT $LN19@long_forma
$LN114@long_forma:
  004b1	48 8d 88 a0 00
	00 00		 lea	 rcx, QWORD PTR [rax+160]
  004b8	49 8b 47 20	 mov	 rax, QWORD PTR [r15+32]
  004bc	48 03 c6	 add	 rax, rsi
  004bf	48 8d 14 81	 lea	 rdx, QWORD PTR [rcx+rax*4]
  004c3	eb 3c		 jmp	 SHORT $LN19@long_forma
$LN116@long_forma:
  004c5	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  004cc	49 8b 47 20	 mov	 rax, QWORD PTR [r15+32]
  004d0	48 03 c6	 add	 rax, rsi
  004d3	48 8d 14 81	 lea	 rdx, QWORD PTR [rcx+rax*4]
  004d7	eb 28		 jmp	 SHORT $LN19@long_forma
$LN20@long_forma:
  004d9	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  004dc	a8 20		 test	 al, 32			; 00000020H
  004de	74 16		 je	 SHORT $LN120@long_forma
  004e0	a8 40		 test	 al, 64			; 00000040H
  004e2	74 09		 je	 SHORT $LN118@long_forma
  004e4	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  004eb	eb 10		 jmp	 SHORT $LN121@long_forma
$LN118@long_forma:
  004ed	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  004f4	eb 07		 jmp	 SHORT $LN121@long_forma
$LN120@long_forma:
  004f6	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
$LN121@long_forma:
  004fd	48 8d 14 b0	 lea	 rdx, QWORD PTR [rax+rsi*4]
$LN19@long_forma:
  00501	41 bc 30 00 00
	00		 mov	 r12d, 48		; 00000030H
  00507	4d 85 ed	 test	 r13, r13
  0050a	75 0c		 jne	 SHORT $LN18@long_forma
  0050c	48 83 ea 04	 sub	 rdx, 4
  00510	44 89 22	 mov	 DWORD PTR [rdx], r12d
  00513	e9 90 00 00 00	 jmp	 $LN14@long_forma
$LN18@long_forma:
  00518	4d 8b ca	 mov	 r9, r10
  0051b	45 8b c2	 mov	 r8d, r10d
  0051e	4d 85 ed	 test	 r13, r13
  00521	0f 8e 81 00 00
	00		 jle	 $LN14@long_forma
  00527	44 8d 5d ff	 lea	 r11d, DWORD PTR [rbp-1]
  0052b	48 63 f3	 movsxd	 rsi, ebx
  0052e	48 83 c7 70	 add	 rdi, 112		; 00000070H
  00532	49 8d 6d ff	 lea	 rbp, QWORD PTR [r13-1]
  00536	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL16@long_forma:
  00540	8b 07		 mov	 eax, DWORD PTR [rdi]
  00542	41 8b c8	 mov	 ecx, r8d
  00545	48 d3 e0	 shl	 rax, cl
  00548	4c 0b c8	 or	 r9, rax
  0054b	41 83 c0 1e	 add	 r8d, 30
  0054f	90		 npad	 1
$LL13@long_forma:
  00550	48 83 ea 04	 sub	 rdx, 4
  00554	41 0f b6 cb	 movzx	 ecx, r11b
  00558	b8 57 00 00 00	 mov	 eax, 87			; 00000057H
  0055d	41 22 c9	 and	 cl, r9b
  00560	80 f9 0a	 cmp	 cl, 10
  00563	41 0f 4c c4	 cmovl	 eax, r12d
  00567	44 2b c3	 sub	 r8d, ebx
  0056a	02 c1		 add	 al, cl
  0056c	48 8b ce	 mov	 rcx, rsi
  0056f	0f be c0	 movsx	 eax, al
  00572	49 d3 e9	 shr	 r9, cl
  00575	89 02		 mov	 DWORD PTR [rdx], eax
  00577	33 c0		 xor	 eax, eax
  00579	4c 3b d5	 cmp	 r10, rbp
  0057c	7d 08		 jge	 SHORT $LN122@long_forma
  0057e	44 3b c3	 cmp	 r8d, ebx
  00581	0f 9d c0	 setge	 al
  00584	eb 06		 jmp	 SHORT $LN123@long_forma
$LN122@long_forma:
  00586	4d 85 c9	 test	 r9, r9
  00589	0f 95 c0	 setne	 al
$LN123@long_forma:
  0058c	85 c0		 test	 eax, eax
  0058e	75 c0		 jne	 SHORT $LL13@long_forma
  00590	49 ff c2	 inc	 r10
  00593	48 83 c7 04	 add	 rdi, 4
  00597	4d 3b d5	 cmp	 r10, r13
  0059a	7c a4		 jl	 SHORT $LL16@long_forma
  0059c	48 8b 74 24 20	 mov	 rsi, QWORD PTR sz$1$[rsp]
  005a1	8b ac 24 88 00
	00 00		 mov	 ebp, DWORD PTR base$[rsp]
$LN14@long_forma:
  005a8	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR alternate$[rsp], 0
  005b0	74 26		 je	 SHORT $LN10@long_forma
  005b2	48 83 ea 04	 sub	 rdx, 4
  005b6	83 fd 10	 cmp	 ebp, 16
  005b9	75 05		 jne	 SHORT $LN9@long_forma
  005bb	44 89 32	 mov	 DWORD PTR [rdx], r14d
  005be	eb 11		 jmp	 SHORT $LN6@long_forma
$LN9@long_forma:
  005c0	b8 6f 00 00 00	 mov	 eax, 111		; 0000006fH
  005c5	83 fd 08	 cmp	 ebp, 8
  005c8	74 05		 je	 SHORT $LN141@long_forma
  005ca	b8 62 00 00 00	 mov	 eax, 98			; 00000062H
$LN141@long_forma:
  005cf	89 02		 mov	 DWORD PTR [rdx], eax
$LN6@long_forma:
  005d1	48 83 ea 04	 sub	 rdx, 4
  005d5	44 89 22	 mov	 DWORD PTR [rdx], r12d
$LN10@long_forma:
  005d8	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR negative$1$[rsp], 0
  005e0	74 08		 je	 SHORT $LN21@long_forma
  005e2	b8 2d 00 00 00	 mov	 eax, 45			; 0000002dH
  005e7	89 42 fc	 mov	 DWORD PTR [rdx-4], eax
$LN21@long_forma:

; 1876 :     }
; 1877 : #undef WRITE_DIGITS
; 1878 : 
; 1879 :     if (writer) {

  005ea	4d 85 ff	 test	 r15, r15
  005ed	74 0b		 je	 SHORT $LN2@long_forma

; 1880 :         writer->pos += sz;

  005ef	49 01 77 20	 add	 QWORD PTR [r15+32], rsi

; 1885 :     }
; 1886 :     return 0;

  005f3	33 c0		 xor	 eax, eax
  005f5	e9 85 fb ff ff	 jmp	 $LN139@long_forma
$LN2@long_forma:

; 1881 :     }
; 1882 :     else {
; 1883 :         assert(_PyUnicode_CheckConsistency(v, 1));
; 1884 :         *p_output = v;

  005fa	48 8b 44 24 28	 mov	 rax, QWORD PTR v$1$[rsp]
  005ff	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR p_output$[rsp]
  00607	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1885 :     }
; 1886 :     return 0;

  0060a	33 c0		 xor	 eax, eax
  0060c	e9 6e fb ff ff	 jmp	 $LN139@long_forma
$LN84@long_forma:

; 1760 :         PyErr_BadInternalCall();

  00611	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00618	ba e0 06 00 00	 mov	 edx, 1760		; 000006e0H
  0061d	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 1761 :         return -1;

  00622	83 c8 ff	 or	 eax, -1

; 1887 : }

  00625	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00629	5f		 pop	 rdi
  0062a	5d		 pop	 rbp
  0062b	c3		 ret	 0
long_format_binary ENDP
_TEXT	ENDS
PUBLIC	_PyLong_Format
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_Format DD imagerel $LN7
	DD	imagerel $LN7+71
	DD	imagerel $unwind$_PyLong_Format
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_Format DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyLong_Format
_TEXT	SEGMENT
obj$ = 64
base$ = 72
str$ = 80
_PyLong_Format PROC					; COMDAT

; 1891 : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1892 :     PyObject *str;
; 1893 :     int err;
; 1894 :     if (base == 10)

  00006	33 db		 xor	 ebx, ebx
  00008	83 fa 0a	 cmp	 edx, 10
  0000b	75 0f		 jne	 SHORT $LN3@PyLong_For

; 1895 :         err = long_to_decimal_string_internal(obj, &str, NULL);

  0000d	48 8d 54 24 50	 lea	 rdx, QWORD PTR str$[rsp]
  00012	45 33 c0	 xor	 r8d, r8d
  00015	e8 00 00 00 00	 call	 long_to_decimal_string_internal

; 1896 :     else

  0001a	eb 15		 jmp	 SHORT $LN6@PyLong_For
$LN3@PyLong_For:

; 1897 :         err = long_format_binary(obj, base, 1, &str, NULL);

  0001c	4c 8d 4c 24 50	 lea	 r9, QWORD PTR str$[rsp]
  00021	41 b8 01 00 00
	00		 mov	 r8d, 1
  00027	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0002c	e8 00 00 00 00	 call	 long_format_binary
$LN6@PyLong_For:
  00031	44 8b d8	 mov	 r11d, eax

; 1898 :     if (err == -1)

  00034	48 8b 44 24 50	 mov	 rax, QWORD PTR str$[rsp]
  00039	41 83 fb ff	 cmp	 r11d, -1
  0003d	48 0f 44 c3	 cmove	 rax, rbx

; 1899 :         return NULL;
; 1900 :     return str;
; 1901 : }

  00041	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00045	5b		 pop	 rbx
  00046	c3		 ret	 0
_PyLong_Format ENDP
_TEXT	ENDS
PUBLIC	_PyLong_FormatWriter
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_FormatWriter DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$_PyLong_FormatWriter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_FormatWriter DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyLong_FormatWriter
_TEXT	SEGMENT
writer$ = 64
obj$ = 72
base$ = 80
alternate$ = 88
_PyLong_FormatWriter PROC				; COMDAT

; 1907 : {

$LN5:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	45 8b d9	 mov	 r11d, r9d
  00007	45 8b d0	 mov	 r10d, r8d
  0000a	48 8b c2	 mov	 rax, rdx

; 1908 :     if (base == 10)

  0000d	41 83 f8 0a	 cmp	 r8d, 10
  00011	75 11		 jne	 SHORT $LN2@PyLong_For@2

; 1909 :         return long_to_decimal_string_internal(obj, NULL, writer);

  00013	4c 8b c1	 mov	 r8, rcx
  00016	33 d2		 xor	 edx, edx
  00018	48 8b c8	 mov	 rcx, rax

; 1912 : }

  0001b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001f	e9 00 00 00 00	 jmp	 long_to_decimal_string_internal
$LN2@PyLong_For@2:

; 1910 :     else
; 1911 :         return long_format_binary(obj, base, alternate, NULL, writer);

  00024	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00029	45 33 c9	 xor	 r9d, r9d
  0002c	45 8b c3	 mov	 r8d, r11d
  0002f	48 8b c8	 mov	 rcx, rax
  00032	41 8b d2	 mov	 edx, r10d
  00035	e8 00 00 00 00	 call	 long_format_binary

; 1912 : }

  0003a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003e	c3		 ret	 0
_PyLong_FormatWriter ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@KANPCKBN@int?5string?5too?5large?5to?5convert?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_from_binary_base DD imagerel long_from_binary_base
	DD	imagerel long_from_binary_base+142
	DD	imagerel $unwind$long_from_binary_base
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$long_from_binary_base DD imagerel long_from_binary_base+142
	DD	imagerel long_from_binary_base+353
	DD	imagerel $chain$0$long_from_binary_base
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$long_from_binary_base DD imagerel long_from_binary_base+353
	DD	imagerel long_from_binary_base+375
	DD	imagerel $chain$1$long_from_binary_base
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$long_from_binary_base DD 021H
	DD	imagerel long_from_binary_base
	DD	imagerel long_from_binary_base+142
	DD	imagerel $unwind$long_from_binary_base
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$long_from_binary_base DD 020521H
	DD	066405H
	DD	imagerel long_from_binary_base
	DD	imagerel long_from_binary_base+142
	DD	imagerel $unwind$long_from_binary_base
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_from_binary_base DD 081501H
	DD	097415H
	DD	085415H
	DD	073415H
	DD	0c0113215H
xdata	ENDS
;	COMDAT ??_C@_0CA@KANPCKBN@int?5string?5too?5large?5to?5convert?$AA@
CONST	SEGMENT
??_C@_0CA@KANPCKBN@int?5string?5too?5large?5to?5convert?$AA@ DB 'int stri'
	DB	'ng too large to convert', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT long_from_binary_base
_TEXT	SEGMENT
str$ = 48
base$ = 56
long_from_binary_base PROC				; COMDAT

; 1948 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1949 :     char *p = *str;

  00015	48 8b 19	 mov	 rbx, QWORD PTR [rcx]

; 1950 :     char *start = p;
; 1951 :     int bits_per_char;
; 1952 :     Py_ssize_t n;
; 1953 :     PyLongObject *z;
; 1954 :     twodigits accum;
; 1955 :     int bits_in_accum;
; 1956 :     digit *pdigit;
; 1957 : 
; 1958 :     assert(base >= 2 && base <= 32 && (base & (base - 1)) == 0);
; 1959 :     n = base;
; 1960 :     for (bits_per_char = -1; n; ++bits_per_char)

  00018	83 cf ff	 or	 edi, -1
  0001b	48 63 c2	 movsxd	 rax, edx
  0001e	48 8b eb	 mov	 rbp, rbx
  00021	85 d2		 test	 edx, edx
  00023	74 07		 je	 SHORT $LN17@long_from_
$LL13@long_from_:
  00025	ff c7		 inc	 edi

; 1961 :         n >>= 1;

  00027	48 d1 f8	 sar	 rax, 1
  0002a	75 f9		 jne	 SHORT $LL13@long_from_
$LN17@long_from_:

; 1962 :     /* n <- total # of bits needed, while setting p to end-of-string */
; 1963 :     while (_PyLong_DigitValue[Py_CHARMASK(*p)] < base)

  0002c	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  0002f	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_PyLong_DigitValue
  00036	42 0f b6 04 20	 movzx	 eax, BYTE PTR [rax+r12]
  0003b	3b c2		 cmp	 eax, edx
  0003d	7d 11		 jge	 SHORT $LN9@long_from_
  0003f	90		 npad	 1
$LL10@long_from_:
  00040	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]

; 1964 :         ++p;

  00044	48 ff c3	 inc	 rbx
  00047	42 0f b6 04 20	 movzx	 eax, BYTE PTR [rax+r12]
  0004c	3b c2		 cmp	 eax, edx
  0004e	7c f0		 jl	 SHORT $LL10@long_from_
$LN9@long_from_:

; 1965 :     *str = p;

  00050	48 89 19	 mov	 QWORD PTR [rcx], rbx

; 1966 :     /* n <- # of Python digits needed, = ceiling(n/PyLong_SHIFT). */
; 1967 :     n = (p - start) * bits_per_char + PyLong_SHIFT - 1;

  00053	48 63 cf	 movsxd	 rcx, edi
  00056	4c 8b c3	 mov	 r8, rbx
  00059	4c 2b c5	 sub	 r8, rbp
  0005c	4c 8b c9	 mov	 r9, rcx
  0005f	4d 0f af c8	 imul	 r9, r8
  00063	49 83 c1 1d	 add	 r9, 29

; 1968 :     if (n / bits_per_char < p - start) {

  00067	49 8b c1	 mov	 rax, r9
  0006a	48 99		 cdq
  0006c	48 f7 f9	 idiv	 rcx
  0006f	49 3b c0	 cmp	 rax, r8
  00072	7d 1a		 jge	 SHORT $LN8@long_from_

; 1969 :         PyErr_SetString(PyExc_ValueError,
; 1970 :                         "int string too large to convert");

  00074	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@KANPCKBN@int?5string?5too?5large?5to?5convert?$AA@
  00082	e8 00 00 00 00	 call	 PyErr_SetString

; 1971 :         return NULL;

  00087	33 c0		 xor	 eax, eax
  00089	e9 d3 00 00 00	 jmp	 $LN14@long_from_
$LN8@long_from_:
  0008e	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi

; 1972 :     }
; 1973 :     n = n / PyLong_SHIFT;

  00093	48 b8 89 88 88
	88 88 88 88 88	 mov	 rax, -8608480567731124087 ; 8888888888888889H
  0009d	49 f7 e9	 imul	 r9
  000a0	49 8d 34 11	 lea	 rsi, QWORD PTR [r9+rdx]
  000a4	48 c1 fe 04	 sar	 rsi, 4
  000a8	48 8b c6	 mov	 rax, rsi
  000ab	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  000af	48 03 f0	 add	 rsi, rax

; 1974 :     z = _PyLong_New(n);

  000b2	48 8b ce	 mov	 rcx, rsi
  000b5	e8 00 00 00 00	 call	 _PyLong_New
  000ba	4c 8b d8	 mov	 r11, rax

; 1975 :     if (z == NULL)

  000bd	48 85 c0	 test	 rax, rax
  000c0	0f 84 96 00 00
	00		 je	 $LN23@long_from_
$LN7@long_from_:

; 1976 :         return NULL;
; 1977 :     /* Read string from right, and fill in int from left; i.e.,
; 1978 :      * from least to most significant in both.
; 1979 :      */
; 1980 :     accum = 0;

  000c6	45 33 d2	 xor	 r10d, r10d

; 1981 :     bits_in_accum = 0;
; 1982 :     pdigit = z->ob_digit;
; 1983 :     while (--p >= start) {

  000c9	48 ff cb	 dec	 rbx
  000cc	4c 8d 40 70	 lea	 r8, QWORD PTR [rax+112]
  000d0	45 8b ca	 mov	 r9d, r10d
  000d3	41 8b ca	 mov	 ecx, r10d
  000d6	48 3b dd	 cmp	 rbx, rbp
  000d9	72 44		 jb	 SHORT $LN19@long_from_
  000db	0f 1f 44 00 00	 npad	 5
$LL6@long_from_:

; 1984 :         int k = (int)_PyLong_DigitValue[Py_CHARMASK(*p)];
; 1985 :         assert(k >= 0 && k < base);
; 1986 :         accum |= (twodigits)k << bits_in_accum;

  000e0	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000e3	42 0f b6 14 20	 movzx	 edx, BYTE PTR [rax+r12]
  000e8	48 d3 e2	 shl	 rdx, cl

; 1987 :         bits_in_accum += bits_per_char;

  000eb	03 cf		 add	 ecx, edi
  000ed	4c 0b ca	 or	 r9, rdx

; 1988 :         if (bits_in_accum >= PyLong_SHIFT) {

  000f0	83 f9 1e	 cmp	 ecx, 30
  000f3	7c 17		 jl	 SHORT $LN4@long_from_

; 1989 :             *pdigit++ = (digit)(accum & PyLong_MASK);

  000f5	41 8b c1	 mov	 eax, r9d
  000f8	49 83 c0 04	 add	 r8, 4

; 1990 :             assert(pdigit - z->ob_digit <= n);
; 1991 :             accum >>= PyLong_SHIFT;

  000fc	49 c1 e9 1e	 shr	 r9, 30
  00100	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH

; 1992 :             bits_in_accum -= PyLong_SHIFT;

  00105	83 e9 1e	 sub	 ecx, 30
  00108	41 89 40 fc	 mov	 DWORD PTR [r8-4], eax
$LN4@long_from_:

; 1981 :     bits_in_accum = 0;
; 1982 :     pdigit = z->ob_digit;
; 1983 :     while (--p >= start) {

  0010c	48 ff cb	 dec	 rbx
  0010f	48 3b dd	 cmp	 rbx, rbp
  00112	73 cc		 jae	 SHORT $LL6@long_from_

; 1993 :             assert(bits_in_accum < PyLong_SHIFT);
; 1994 :         }
; 1995 :     }
; 1996 :     if (bits_in_accum) {

  00114	85 c9		 test	 ecx, ecx
  00116	74 07		 je	 SHORT $LN19@long_from_

; 1997 :         assert(bits_in_accum <= PyLong_SHIFT);
; 1998 :         *pdigit++ = (digit)accum;

  00118	45 89 08	 mov	 DWORD PTR [r8], r9d
  0011b	49 83 c0 04	 add	 r8, 4
$LN19@long_from_:

; 1999 :         assert(pdigit - z->ob_digit <= n);
; 2000 :     }
; 2001 :     while (pdigit - z->ob_digit < n)

  0011f	49 8b c0	 mov	 rax, r8
  00122	49 2b c3	 sub	 rax, r11
  00125	48 83 e8 70	 sub	 rax, 112		; 00000070H
  00129	48 c1 f8 02	 sar	 rax, 2
  0012d	48 3b c6	 cmp	 rax, rsi
  00130	7d 22		 jge	 SHORT $LN1@long_from_
  00132	48 c7 c1 90 ff
	ff ff		 mov	 rcx, -112		; ffffffffffffff90H
  00139	49 2b cb	 sub	 rcx, r11
  0013c	0f 1f 40 00	 npad	 4
$LL2@long_from_:

; 2002 :         *pdigit++ = 0;

  00140	45 89 10	 mov	 DWORD PTR [r8], r10d
  00143	49 83 c0 04	 add	 r8, 4
  00147	4a 8d 04 01	 lea	 rax, QWORD PTR [rcx+r8]
  0014b	48 c1 f8 02	 sar	 rax, 2
  0014f	48 3b c6	 cmp	 rax, rsi
  00152	7c ec		 jl	 SHORT $LL2@long_from_
$LN1@long_from_:

; 2003 :     return long_normalize(z);

  00154	49 8b cb	 mov	 rcx, r11
  00157	e8 00 00 00 00	 call	 long_normalize
$LN23@long_from_:
  0015c	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
$LN14@long_from_:

; 2004 : }

  00161	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00166	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0016b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00170	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00174	41 5c		 pop	 r12
  00176	c3		 ret	 0
long_from_binary_base ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@EMMOEPEF@invalid?5literal?5for?5int?$CI?$CJ?5with?5b@ ; `string'
PUBLIC	__real@41d0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	??_C@_0CD@JHJGICHC@int?$CI?$CJ?5arg?52?5must?5be?5?$DO?$DN?52?5and?5?$DM?$DN?5@ ; `string'
PUBLIC	PyLong_FromString
EXTRN	PyUnicode_FromStringAndSize:PROC
EXTRN	_Py_ctype_table:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	log:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyLong_FromString DD imagerel $LN124
	DD	imagerel $LN124+371
	DD	imagerel $unwind$PyLong_FromString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyLong_FromString DD imagerel $LN124+371
	DD	imagerel $LN124+430
	DD	imagerel $chain$3$PyLong_FromString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyLong_FromString DD imagerel $LN124+430
	DD	imagerel $LN124+686
	DD	imagerel $chain$4$PyLong_FromString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyLong_FromString DD imagerel $LN124+686
	DD	imagerel $LN124+1558
	DD	imagerel $chain$5$PyLong_FromString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyLong_FromString DD 021H
	DD	imagerel $LN124+371
	DD	imagerel $LN124+430
	DD	imagerel $chain$3$PyLong_FromString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyLong_FromString DD 020521H
	DD	066805H
	DD	imagerel $LN124+371
	DD	imagerel $LN124+430
	DD	imagerel $chain$3$PyLong_FromString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyLong_FromString DD 041021H
	DD	0ff410H
	DD	0123408H
	DD	imagerel $LN124
	DD	imagerel $LN124+371
	DD	imagerel $unwind$PyLong_FromString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromString DD 0a8701H
	DD	010d487H
	DD	011647fH
	DD	013011cH
	DD	0c013e015H
	DD	050107011H
xdata	ENDS
;	COMDAT ??_C@_0CL@EMMOEPEF@invalid?5literal?5for?5int?$CI?$CJ?5with?5b@
CONST	SEGMENT
??_C@_0CL@EMMOEPEF@invalid?5literal?5for?5int?$CI?$CJ?5with?5b@ DB 'inval'
	DB	'id literal for int() with base %d: %R', 00H	; `string'
CONST	ENDS
;	COMDAT __real@41d0000000000000
CONST	SEGMENT
__real@41d0000000000000 DQ 041d0000000000000r	; 1.07374e+009
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_0CD@JHJGICHC@int?$CI?$CJ?5arg?52?5must?5be?5?$DO?$DN?52?5and?5?$DM?$DN?5@
CONST	SEGMENT
??_C@_0CD@JHJGICHC@int?$CI?$CJ?5arg?52?5must?5be?5?$DO?$DN?52?5and?5?$DM?$DN?5@ DB 'i'
	DB	'nt() arg 2 must be >= 2 and <= 36', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
CONST	ENDS
;	COMDAT PyLong_FromString
_TEXT	SEGMENT
sign$1$ = 48
scan$1$ = 56
convmultmax$1$ = 64
start$1$ = 72
orig_str$1$ = 80
convwidth$1$ = 192
str$ = 192
pend$ = 200
base$ = 208
error_if_nonzero$1$ = 216
PyLong_FromString PROC					; COMDAT

; 2016 : {

$LN124:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	41 54		 push	 r12
  00013	41 56		 push	 r14
  00015	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0001c	41 8b e8	 mov	 ebp, r8d
  0001f	4c 8b e2	 mov	 r12, rdx
  00022	48 8b f9	 mov	 rdi, rcx

; 2017 :     int sign = 1, error_if_nonzero = 0;

  00025	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR sign$1$[rsp], 1
  0002d	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR error_if_nonzero$1$[rsp], 0

; 2018 :     char *start, *orig_str = str;

  00038	4c 8b f1	 mov	 r14, rcx
  0003b	48 89 4c 24 50	 mov	 QWORD PTR orig_str$1$[rsp], rcx

; 2019 :     PyLongObject *z = NULL;
; 2020 :     PyObject *strobj;
; 2021 :     Py_ssize_t slen;
; 2022 : 
; 2023 :     if ((base != 0 && base < 2) || base > 36) {

  00040	45 85 c0	 test	 r8d, r8d
  00043	74 06		 je	 SHORT $LN64@PyLong_Fro@10
  00045	41 83 f8 02	 cmp	 r8d, 2
  00049	7c 06		 jl	 SHORT $LN65@PyLong_Fro@10
$LN64@PyLong_Fro@10:
  0004b	41 83 f8 24	 cmp	 r8d, 36			; 00000024H
  0004f	7e 23		 jle	 SHORT $LN93@PyLong_Fro@10
$LN65@PyLong_Fro@10:

; 2024 :         PyErr_SetString(PyExc_ValueError,
; 2025 :                         "int() arg 2 must be >= 2 and <= 36");

  00051	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@JHJGICHC@int?$CI?$CJ?5arg?52?5must?5be?5?$DO?$DN?52?5and?5?$DM?$DN?5@
  0005f	e8 00 00 00 00	 call	 PyErr_SetString

; 2026 :         return NULL;

  00064	33 c0		 xor	 eax, eax

; 2297 : }

  00066	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0006d	41 5e		 pop	 r14
  0006f	41 5c		 pop	 r12
  00071	5f		 pop	 rdi
  00072	5d		 pop	 rbp
  00073	c3		 ret	 0
$LN93@PyLong_Fro@10:

; 2027 :     }
; 2028 :     while (*str != '\0' && Py_ISSPACE(Py_CHARMASK(*str)))

  00074	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00077	48 89 b4 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rsi
  0007f	4c 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r13
  00087	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:__ImageBase
  0008e	84 c0		 test	 al, al
  00090	74 20		 je	 SHORT $LN111@PyLong_Fro@10
$LL63@PyLong_Fro@10:
  00092	0f b6 c0	 movzx	 eax, al
  00095	f6 84 86 00 00
	00 00 08	 test	 BYTE PTR _Py_ctype_table[rsi+rax*4], 8
  0009d	74 13		 je	 SHORT $LN111@PyLong_Fro@10
  0009f	0f b6 47 01	 movzx	 eax, BYTE PTR [rdi+1]

; 2029 :         str++;

  000a3	48 ff c7	 inc	 rdi
  000a6	48 89 bc 24 c0
	00 00 00	 mov	 QWORD PTR str$[rsp], rdi
  000ae	84 c0		 test	 al, al
  000b0	75 e0		 jne	 SHORT $LL63@PyLong_Fro@10
$LN111@PyLong_Fro@10:

; 2030 :     if (*str == '+')

  000b2	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  000b5	3c 2b		 cmp	 al, 43			; 0000002bH

; 2031 :         ++str;

  000b7	74 0c		 je	 SHORT $LN119@PyLong_Fro@10

; 2032 :     else if (*str == '-') {

  000b9	3c 2d		 cmp	 al, 45			; 0000002dH
  000bb	75 13		 jne	 SHORT $LN59@PyLong_Fro@10

; 2034 :         sign = -1;

  000bd	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR sign$1$[rsp], -1
$LN119@PyLong_Fro@10:

; 2033 :         ++str;

  000c5	48 ff c7	 inc	 rdi
  000c8	48 89 bc 24 c0
	00 00 00	 mov	 QWORD PTR str$[rsp], rdi
$LN59@PyLong_Fro@10:

; 2035 :     }
; 2036 :     if (base == 0) {

  000d0	45 85 c0	 test	 r8d, r8d
  000d3	75 53		 jne	 SHORT $LN47@PyLong_Fro@10

; 2037 :         if (str[0] != '0')

  000d5	80 3f 30	 cmp	 BYTE PTR [rdi], 48	; 00000030H
  000d8	74 06		 je	 SHORT $LN57@PyLong_Fro@10

; 2038 :             base = 10;

  000da	41 8d 68 0a	 lea	 ebp, QWORD PTR [r8+10]
  000de	eb 41		 jmp	 SHORT $LN120@PyLong_Fro@10
$LN57@PyLong_Fro@10:

; 2039 :         else if (str[1] == 'x' || str[1] == 'X')

  000e0	0f b6 47 01	 movzx	 eax, BYTE PTR [rdi+1]
  000e4	3c 78		 cmp	 al, 120			; 00000078H
  000e6	74 34		 je	 SHORT $LN54@PyLong_Fro@10
  000e8	3c 58		 cmp	 al, 88			; 00000058H
  000ea	74 30		 je	 SHORT $LN54@PyLong_Fro@10

; 2041 :         else if (str[1] == 'o' || str[1] == 'O')

  000ec	3c 6f		 cmp	 al, 111			; 0000006fH
  000ee	74 25		 je	 SHORT $LN51@PyLong_Fro@10
  000f0	3c 4f		 cmp	 al, 79			; 0000004fH
  000f2	74 21		 je	 SHORT $LN51@PyLong_Fro@10

; 2043 :         else if (str[1] == 'b' || str[1] == 'B')

  000f4	3c 62		 cmp	 al, 98			; 00000062H
  000f6	74 16		 je	 SHORT $LN48@PyLong_Fro@10
  000f8	3c 42		 cmp	 al, 66			; 00000042H
  000fa	74 12		 je	 SHORT $LN48@PyLong_Fro@10

; 2046 :             /* "old" (C-style) octal literal, now invalid.
; 2047 :                it might still be zero though */
; 2048 :             error_if_nonzero = 1;

  000fc	c7 84 24 d8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR error_if_nonzero$1$[rsp], 1

; 2049 :             base = 10;

  00107	bd 0a 00 00 00	 mov	 ebp, 10
  0010c	eb 13		 jmp	 SHORT $LN120@PyLong_Fro@10
$LN48@PyLong_Fro@10:

; 2044 :             base = 2;

  0010e	bd 02 00 00 00	 mov	 ebp, 2

; 2045 :         else {

  00113	eb 0c		 jmp	 SHORT $LN120@PyLong_Fro@10
$LN51@PyLong_Fro@10:

; 2042 :             base = 8;

  00115	bd 08 00 00 00	 mov	 ebp, 8
  0011a	eb 05		 jmp	 SHORT $LN120@PyLong_Fro@10
$LN54@PyLong_Fro@10:

; 2040 :             base = 16;

  0011c	bd 10 00 00 00	 mov	 ebp, 16
$LN120@PyLong_Fro@10:
  00121	89 ac 24 d0 00
	00 00		 mov	 DWORD PTR base$[rsp], ebp
$LN47@PyLong_Fro@10:

; 2050 :         }
; 2051 :     }
; 2052 :     if (str[0] == '0' &&
; 2053 :         ((base == 16 && (str[1] == 'x' || str[1] == 'X')) ||
; 2054 :          (base == 8  && (str[1] == 'o' || str[1] == 'O')) ||
; 2055 :          (base == 2  && (str[1] == 'b' || str[1] == 'B'))))

  00128	80 3f 30	 cmp	 BYTE PTR [rdi], 48	; 00000030H
  0012b	75 43		 jne	 SHORT $LN46@PyLong_Fro@10
  0012d	83 fd 10	 cmp	 ebp, 16
  00130	75 0e		 jne	 SHORT $LN44@PyLong_Fro@10
  00132	0f b6 47 01	 movzx	 eax, BYTE PTR [rdi+1]
  00136	3c 78		 cmp	 al, 120			; 00000078H
  00138	74 2a		 je	 SHORT $LN42@PyLong_Fro@10
  0013a	3c 58		 cmp	 al, 88			; 00000058H
  0013c	74 26		 je	 SHORT $LN42@PyLong_Fro@10
  0013e	eb 30		 jmp	 SHORT $LN46@PyLong_Fro@10
$LN44@PyLong_Fro@10:
  00140	83 fd 08	 cmp	 ebp, 8
  00143	75 0e		 jne	 SHORT $LN43@PyLong_Fro@10
  00145	0f b6 47 01	 movzx	 eax, BYTE PTR [rdi+1]
  00149	3c 6f		 cmp	 al, 111			; 0000006fH
  0014b	74 17		 je	 SHORT $LN42@PyLong_Fro@10
  0014d	3c 4f		 cmp	 al, 79			; 0000004fH
  0014f	74 13		 je	 SHORT $LN42@PyLong_Fro@10
  00151	eb 1d		 jmp	 SHORT $LN46@PyLong_Fro@10
$LN43@PyLong_Fro@10:
  00153	83 fd 02	 cmp	 ebp, 2
  00156	75 18		 jne	 SHORT $LN46@PyLong_Fro@10
  00158	0f b6 47 01	 movzx	 eax, BYTE PTR [rdi+1]
  0015c	3c 62		 cmp	 al, 98			; 00000062H
  0015e	74 04		 je	 SHORT $LN42@PyLong_Fro@10
  00160	3c 42		 cmp	 al, 66			; 00000042H
  00162	75 0c		 jne	 SHORT $LN46@PyLong_Fro@10
$LN42@PyLong_Fro@10:

; 2056 :         str += 2;

  00164	48 83 c7 02	 add	 rdi, 2
  00168	48 89 bc 24 c0
	00 00 00	 mov	 QWORD PTR str$[rsp], rdi
$LN46@PyLong_Fro@10:

; 2057 : 
; 2058 :     start = str;
; 2059 :     if ((base & (base - 1)) == 0)

  00170	8d 45 ff	 lea	 eax, DWORD PTR [rbp-1]
  00173	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx
  0017b	4c 8b ef	 mov	 r13, rdi
  0017e	4c 89 7c 24 78	 mov	 QWORD PTR [rsp+120], r15
  00183	48 89 7c 24 48	 mov	 QWORD PTR start$1$[rsp], rdi
  00188	85 c5		 test	 eax, ebp
  0018a	75 1f		 jne	 SHORT $LN41@PyLong_Fro@10

; 2060 :         z = long_from_binary_base(&str, base);

  0018c	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR str$[rsp]
  00194	8b d5		 mov	 edx, ebp
  00196	e8 00 00 00 00	 call	 long_from_binary_base

; 2061 :     else {

  0019b	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR str$[rsp]
  001a3	48 8b d8	 mov	 rbx, rax
  001a6	e9 54 03 00 00	 jmp	 $LN110@PyLong_Fro@10
$LN41@PyLong_Fro@10:

; 2062 : /***
; 2063 : Binary bases can be converted in time linear in the number of digits, because
; 2064 : Python's representation base is binary.  Other bases (including decimal!) use
; 2065 : the simple quadratic-time algorithm below, complicated by some speed tricks.
; 2066 : 
; 2067 : First some math:  the largest integer that can be expressed in N base-B digits
; 2068 : is B**N-1.  Consequently, if we have an N-digit input in base B, the worst-
; 2069 : case number of Python digits needed to hold it is the smallest integer n s.t.
; 2070 : 
; 2071 :     BASE**n-1 >= B**N-1  [or, adding 1 to both sides]
; 2072 :     BASE**n >= B**N      [taking logs to base BASE]
; 2073 :     n >= log(B**N)/log(BASE) = N * log(B)/log(BASE)
; 2074 : 
; 2075 : The static array log_base_BASE[base] == log(base)/log(BASE) so we can compute
; 2076 : this quickly.  A Python int with that much space is reserved near the start,
; 2077 : and the result is computed into it.
; 2078 : 
; 2079 : The input string is actually treated as being in base base**i (i.e., i digits
; 2080 : are processed at a time), where two more static arrays hold:
; 2081 : 
; 2082 :     convwidth_base[base] = the largest integer i such that base**i <= BASE
; 2083 :     convmultmax_base[base] = base ** convwidth_base[base]
; 2084 : 
; 2085 : The first of these is the largest i such that i consecutive input digits
; 2086 : must fit in a single Python digit.  The second is effectively the input
; 2087 : base we're really using.
; 2088 : 
; 2089 : Viewing the input as a sequence <c0, c1, ..., c_n-1> of digits in base
; 2090 : convmultmax_base[base], the result is "simply"
; 2091 : 
; 2092 :    (((c0*B + c1)*B + c2)*B + c3)*B + ... ))) + c_n-1
; 2093 : 
; 2094 : where B = convmultmax_base[base].
; 2095 : 
; 2096 : Error analysis:  as above, the number of Python digits `n` needed is worst-
; 2097 : case
; 2098 : 
; 2099 :     n >= N * log(B)/log(BASE)
; 2100 : 
; 2101 : where `N` is the number of input digits in base `B`.  This is computed via
; 2102 : 
; 2103 :     size_z = (Py_ssize_t)((scan - str) * log_base_BASE[base]) + 1;
; 2104 : 
; 2105 : below.  Two numeric concerns are how much space this can waste, and whether
; 2106 : the computed result can be too small.  To be concrete, assume BASE = 2**15,
; 2107 : which is the default (and it's unlikely anyone changes that).
; 2108 : 
; 2109 : Waste isn't a problem:  provided the first input digit isn't 0, the difference
; 2110 : between the worst-case input with N digits and the smallest input with N
; 2111 : digits is about a factor of B, but B is small compared to BASE so at most
; 2112 : one allocated Python digit can remain unused on that count.  If
; 2113 : N*log(B)/log(BASE) is mathematically an exact integer, then truncating that
; 2114 : and adding 1 returns a result 1 larger than necessary.  However, that can't
; 2115 : happen:  whenever B is a power of 2, long_from_binary_base() is called
; 2116 : instead, and it's impossible for B**i to be an integer power of 2**15 when
; 2117 : B is not a power of 2 (i.e., it's impossible for N*log(B)/log(BASE) to be
; 2118 : an exact integer when B is not a power of 2, since B**i has a prime factor
; 2119 : other than 2 in that case, but (2**15)**j's only prime factor is 2).
; 2120 : 
; 2121 : The computed result can be too small if the true value of N*log(B)/log(BASE)
; 2122 : is a little bit larger than an exact integer, but due to roundoff errors (in
; 2123 : computing log(B), log(BASE), their quotient, and/or multiplying that by N)
; 2124 : yields a numeric result a little less than that integer.  Unfortunately, "how
; 2125 : close can a transcendental function get to an integer over some range?"
; 2126 : questions are generally theoretically intractable.  Computer analysis via
; 2127 : continued fractions is practical:  expand log(B)/log(BASE) via continued
; 2128 : fractions, giving a sequence i/j of "the best" rational approximations.  Then
; 2129 : j*log(B)/log(BASE) is approximately equal to (the integer) i.  This shows that
; 2130 : we can get very close to being in trouble, but very rarely.  For example,
; 2131 : 76573 is a denominator in one of the continued-fraction approximations to
; 2132 : log(10)/log(2**15), and indeed:
; 2133 : 
; 2134 :     >>> log(10)/log(2**15)*76573
; 2135 :     16958.000000654003
; 2136 : 
; 2137 : is very close to an integer.  If we were working with IEEE single-precision,
; 2138 : rounding errors could kill us.  Finding worst cases in IEEE double-precision
; 2139 : requires better-than-double-precision log() functions, and Tim didn't bother.
; 2140 : Instead the code checks to see whether the allocated space is enough as each
; 2141 : new Python digit is added, and copies the whole thing to a larger int if not.
; 2142 : This should happen extremely rarely, and in fact I don't have a test case
; 2143 : that triggers it(!).  Instead the code was tested by artificially allocating
; 2144 : just 1 digit at the start, so that the copying code was exercised for every
; 2145 : digit beyond the first.
; 2146 : ***/
; 2147 :         register twodigits c;           /* current input character */
; 2148 :         Py_ssize_t size_z;
; 2149 :         int i;
; 2150 :         int convwidth;
; 2151 :         twodigits convmultmax, convmult;
; 2152 :         digit *pz, *pzstop;
; 2153 :         char* scan;
; 2154 : 
; 2155 :         static double log_base_BASE[37] = {0.0e0,};
; 2156 :         static int convwidth_base[37] = {0,};
; 2157 :         static twodigits convmultmax_base[37] = {0,};
; 2158 : 
; 2159 :         if (log_base_BASE[base] == 0.0) {

  001ab	4c 63 fd	 movsxd	 r15, ebp
  001ae	0f 29 74 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm6
  001b3	f2 42 0f 10 b4
	fe 00 00 00 00	 movsdx	 xmm6, QWORD PTR ?log_base_BASE@?6??PyLong_FromString@@9@9[rsi+r15*8]
  001bd	66 0f 2e 35 00
	00 00 00	 ucomisd xmm6, QWORD PTR __real@0000000000000000
  001c5	0f 8a 7d 00 00
	00		 jp	 $LN39@PyLong_Fro@10
  001cb	75 7b		 jne	 SHORT $LN39@PyLong_Fro@10

; 2160 :             twodigits convmax = base;
; 2161 :             int i = 1;
; 2162 : 
; 2163 :             log_base_BASE[base] = (log((double)base) /
; 2164 :                                    log((double)PyLong_BASE));

  001cd	66 0f 6e c5	 movd	 xmm0, ebp
  001d1	49 8b f7	 mov	 rsi, r15
  001d4	bb 01 00 00 00	 mov	 ebx, 1
  001d9	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001dd	e8 00 00 00 00	 call	 log
  001e2	66 0f 28 f0	 movapd	 xmm6, xmm0
  001e6	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@41d0000000000000
  001ee	e8 00 00 00 00	 call	 log

; 2165 :             for (;;) {
; 2166 :                 twodigits next = convmax * base;

  001f3	49 8b c7	 mov	 rax, r15
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  001fd	49 0f af c7	 imul	 rax, r15
  00201	f2 0f 5e f0	 divsd	 xmm6, xmm0
  00205	f2 42 0f 11 b4
	f9 00 00 00 00	 movsdx	 QWORD PTR ?log_base_BASE@?6??PyLong_FromString@@9@9[rcx+r15*8], xmm6

; 2167 :                 if (next > PyLong_BASE)

  0020f	48 3d 00 00 00
	40		 cmp	 rax, 1073741824		; 40000000H
  00215	77 1a		 ja	 SHORT $LN101@PyLong_Fro@10
  00217	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL38@PyLong_Fro@10:

; 2168 :                     break;
; 2169 :                 convmax = next;

  00220	48 8b f0	 mov	 rsi, rax
  00223	49 0f af c7	 imul	 rax, r15

; 2170 :                 ++i;

  00227	ff c3		 inc	 ebx
  00229	48 3d 00 00 00
	40		 cmp	 rax, 1073741824		; 40000000H
  0022f	76 ef		 jbe	 SHORT $LL38@PyLong_Fro@10
$LN101@PyLong_Fro@10:

; 2171 :             }
; 2172 :             convmultmax_base[base] = convmax;

  00231	4a 89 b4 f9 00
	00 00 00	 mov	 QWORD PTR ?convmultmax_base@?6??PyLong_FromString@@9@9[rcx+r15*8], rsi

; 2173 :             assert(i > 0);
; 2174 :             convwidth_base[base] = i;

  00239	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:__ImageBase
  00240	42 89 9c be 00
	00 00 00	 mov	 DWORD PTR ?convwidth_base@?6??PyLong_FromString@@9@9[rsi+r15*4], ebx
$LN39@PyLong_Fro@10:

; 2175 :         }
; 2176 : 
; 2177 :         /* Find length of the string of numeric characters. */
; 2178 :         scan = str;
; 2179 :         while (_PyLong_DigitValue[Py_CHARMASK(*scan)] < base)

  00248	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  0024b	4c 8b e7	 mov	 r12, rdi
  0024e	48 89 7c 24 38	 mov	 QWORD PTR scan$1$[rsp], rdi
  00253	0f b6 84 30 00
	00 00 00	 movzx	 eax, BYTE PTR _PyLong_DigitValue[rax+rsi]
  0025b	3b c5		 cmp	 eax, ebp
  0025d	7d 1b		 jge	 SHORT $LN34@PyLong_Fro@10
  0025f	90		 npad	 1
$LL35@PyLong_Fro@10:
  00260	41 0f b6 44 24
	01		 movzx	 eax, BYTE PTR [r12+1]

; 2180 :             ++scan;

  00266	49 ff c4	 inc	 r12
  00269	0f b6 84 30 00
	00 00 00	 movzx	 eax, BYTE PTR _PyLong_DigitValue[rax+rsi]
  00271	3b c5		 cmp	 eax, ebp
  00273	7c eb		 jl	 SHORT $LL35@PyLong_Fro@10
  00275	4c 89 64 24 38	 mov	 QWORD PTR scan$1$[rsp], r12
$LN34@PyLong_Fro@10:

; 2181 : 
; 2182 :         /* Create an int object that can contain the largest possible
; 2183 :          * integer with this base and length.  Note that there's no
; 2184 :          * need to initialize z->ob_digit -- no slot is read up before
; 2185 :          * being stored into.
; 2186 :          */
; 2187 :         size_z = (Py_ssize_t)((scan - str) * log_base_BASE[base]) + 1;

  0027a	66 0f ef c0	 pxor	 xmm0, xmm0
  0027e	49 8b c4	 mov	 rax, r12
  00281	48 2b c7	 sub	 rax, rdi
  00284	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00289	f2 0f 59 c6	 mulsd	 xmm0, xmm6
  0028d	f2 4c 0f 2c e8	 cvttsd2si r13, xmm0
  00292	49 ff c5	 inc	 r13

; 2188 :         /* Uncomment next line to test exceedingly rare copy code */
; 2189 :         /* size_z = 1; */
; 2190 :         assert(size_z > 0);
; 2191 :         z = _PyLong_New(size_z);

  00295	49 8b cd	 mov	 rcx, r13
  00298	e8 00 00 00 00	 call	 _PyLong_New
  0029d	48 8b d8	 mov	 rbx, rax
  002a0	0f 28 74 24 60	 movaps	 xmm6, XMMWORD PTR [rsp+96]

; 2192 :         if (z == NULL)

  002a5	48 85 c0	 test	 rax, rax

; 2193 :             return NULL;

  002a8	0f 84 3b 03 00
	00		 je	 $LN121@PyLong_Fro@10

; 2194 :         Py_SIZE(z) = 0;
; 2195 : 
; 2196 :         /* `convwidth` consecutive input digits are treated as a single
; 2197 :          * digit in base `convmultmax`.
; 2198 :          */
; 2199 :         convwidth = convwidth_base[base];

  002ae	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:__ImageBase
  002b5	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
  002bd	47 8b 84 b9 00
	00 00 00	 mov	 r8d, DWORD PTR ?convwidth_base@?6??PyLong_FromString@@9@9[r9+r15*4]

; 2200 :         convmultmax = convmultmax_base[base];

  002c5	4b 8b 8c f9 00
	00 00 00	 mov	 rcx, QWORD PTR ?convmultmax_base@?6??PyLong_FromString@@9@9[r9+r15*8]
  002cd	44 89 84 24 c0
	00 00 00	 mov	 DWORD PTR convwidth$1$[rsp], r8d
  002d5	48 89 4c 24 40	 mov	 QWORD PTR convmultmax$1$[rsp], rcx

; 2201 : 
; 2202 :         /* Work ;-) */
; 2203 :         while (str < scan) {

  002da	49 3b fc	 cmp	 rdi, r12
  002dd	0f 83 0a 02 00
	00		 jae	 $LN114@PyLong_Fro@10
$LL32@PyLong_Fro@10:

; 2204 :             /* grab up to convwidth digits from the input string */
; 2205 :             c = (digit)_PyLong_DigitValue[Py_CHARMASK(*str++)];

  002e3	0f b6 07	 movzx	 eax, BYTE PTR [rdi]

; 2206 :             for (i = 1; i < convwidth && str != scan; ++i, ++str) {

  002e6	ba 01 00 00 00	 mov	 edx, 1
  002eb	48 ff c7	 inc	 rdi
  002ee	42 0f b6 b4 08
	00 00 00 00	 movzx	 esi, BYTE PTR _PyLong_DigitValue[rax+r9]
  002f7	41 3b d0	 cmp	 edx, r8d
  002fa	7d 2e		 jge	 SHORT $LN122@PyLong_Fro@10
  002fc	0f 1f 40 00	 npad	 4
$LL30@PyLong_Fro@10:
  00300	49 3b fc	 cmp	 rdi, r12
  00303	74 1d		 je	 SHORT $LN112@PyLong_Fro@10

; 2207 :                 c = (twodigits)(c *  base +
; 2208 :                                 (int)_PyLong_DigitValue[Py_CHARMASK(*str)]);

  00305	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  00308	49 0f af f7	 imul	 rsi, r15
  0030c	ff c2		 inc	 edx
  0030e	42 0f b6 8c 08
	00 00 00 00	 movzx	 ecx, BYTE PTR _PyLong_DigitValue[rax+r9]
  00317	48 ff c7	 inc	 rdi
  0031a	48 03 f1	 add	 rsi, rcx
  0031d	41 3b d0	 cmp	 edx, r8d
  00320	7c de		 jl	 SHORT $LL30@PyLong_Fro@10
$LN112@PyLong_Fro@10:
  00322	48 8b 4c 24 40	 mov	 rcx, QWORD PTR convmultmax$1$[rsp]

; 2209 :                 assert(c < PyLong_BASE);
; 2210 :             }
; 2211 : 
; 2212 :             convmult = convmultmax;
; 2213 :             /* Calculate the shift only if we couldn't get
; 2214 :              * convwidth digits.
; 2215 :              */
; 2216 :             if (i != convwidth) {

  00327	41 3b d0	 cmp	 edx, r8d
$LN122@PyLong_Fro@10:
  0032a	74 13		 je	 SHORT $LN24@PyLong_Fro@10

; 2217 :                 convmult = base;

  0032c	49 8b cf	 mov	 rcx, r15

; 2218 :                 for ( ; i > 1; --i)

  0032f	83 fa 01	 cmp	 edx, 1
  00332	7e 0b		 jle	 SHORT $LN24@PyLong_Fro@10

; 2217 :                 convmult = base;

  00334	ff ca		 dec	 edx
$LL26@PyLong_Fro@10:

; 2219 :                     convmult *= base;

  00336	49 0f af cf	 imul	 rcx, r15
  0033a	48 ff ca	 dec	 rdx
  0033d	75 f7		 jne	 SHORT $LL26@PyLong_Fro@10
$LN24@PyLong_Fro@10:

; 2220 :             }
; 2221 : 
; 2222 :             /* Multiply z by convmult, and add c. */
; 2223 :             pz = z->ob_digit;
; 2224 :             pzstop = pz + Py_SIZE(z);

  0033f	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  00343	4c 8d 73 70	 lea	 r14, QWORD PTR [rbx+112]
  00347	4d 8d 04 86	 lea	 r8, QWORD PTR [r14+rax*4]
  0034b	49 8b d6	 mov	 rdx, r14

; 2225 :             for (; pz < pzstop; ++pz) {

  0034e	4d 3b f0	 cmp	 r14, r8
  00351	73 2d		 jae	 SHORT $LN21@PyLong_Fro@10
  00353	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL23@PyLong_Fro@10:

; 2226 :                 c += (twodigits)*pz * convmult;

  00360	8b 02		 mov	 eax, DWORD PTR [rdx]
  00362	48 83 c2 04	 add	 rdx, 4
  00366	48 0f af c1	 imul	 rax, rcx
  0036a	48 03 f0	 add	 rsi, rax

; 2227 :                 *pz = (digit)(c & PyLong_MASK);

  0036d	8b c6		 mov	 eax, esi

; 2228 :                 c >>= PyLong_SHIFT;

  0036f	48 c1 ee 1e	 shr	 rsi, 30
  00373	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00378	89 42 fc	 mov	 DWORD PTR [rdx-4], eax
  0037b	49 3b d0	 cmp	 rdx, r8
  0037e	72 e0		 jb	 SHORT $LL23@PyLong_Fro@10
$LN21@PyLong_Fro@10:

; 2229 :             }
; 2230 :             /* carry off the current end? */
; 2231 :             if (c) {

  00380	48 85 f6	 test	 rsi, rsi
  00383	0f 84 ba 00 00
	00		 je	 $LN18@PyLong_Fro@10

; 2232 :                 assert(c < PyLong_BASE);
; 2233 :                 if (Py_SIZE(z) < size_z) {

  00389	4c 39 6b 60	 cmp	 QWORD PTR [rbx+96], r13
  0038d	7d 0b		 jge	 SHORT $LN19@PyLong_Fro@10

; 2234 :                     *pz = (digit)c;

  0038f	89 32		 mov	 DWORD PTR [rdx], esi

; 2235 :                     ++Py_SIZE(z);

  00391	48 ff 43 60	 inc	 QWORD PTR [rbx+96]

; 2236 :                 }
; 2237 :                 else {

  00395	e9 a9 00 00 00	 jmp	 $LN18@PyLong_Fro@10
$LN19@PyLong_Fro@10:

; 2201 : 
; 2202 :         /* Work ;-) */
; 2203 :         while (str < scan) {

  0039a	4d 8d 65 01	 lea	 r12, QWORD PTR [r13+1]

; 2238 :                     PyLongObject *tmp;
; 2239 :                     /* Extremely rare.  Get more space. */
; 2240 :                     assert(Py_SIZE(z) == size_z);
; 2241 :                     tmp = _PyLong_New(size_z + 1);

  0039e	49 8b cc	 mov	 rcx, r12
  003a1	e8 00 00 00 00	 call	 _PyLong_New
  003a6	48 8b e8	 mov	 rbp, rax

; 2242 :                     if (tmp == NULL) {

  003a9	48 85 c0	 test	 rax, rax
  003ac	0f 84 ac 00 00
	00		 je	 $LN102@PyLong_Fro@10

; 2245 :                     }
; 2246 :                     memcpy(tmp->ob_digit,
; 2247 :                            z->ob_digit,
; 2248 :                            sizeof(digit) * size_z);

  003b2	49 c1 e5 02	 shl	 r13, 2
  003b6	48 8d 48 70	 lea	 rcx, QWORD PTR [rax+112]
  003ba	49 8b d6	 mov	 rdx, r14
  003bd	4d 8b c5	 mov	 r8, r13
  003c0	e8 00 00 00 00	 call	 memcpy

; 2249 :                     Py_DECREF(z);

  003c5	e8 00 00 00 00	 call	 _Py_PXCTX
  003ca	85 c0		 test	 eax, eax
  003cc	75 5e		 jne	 SHORT $LN92@PyLong_Fro@10
  003ce	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  003d2	f6 c1 20	 test	 cl, 32			; 00000020H
  003d5	75 4d		 jne	 SHORT $LN86@PyLong_Fro@10
  003d7	84 c9		 test	 cl, cl
  003d9	78 49		 js	 SHORT $LN86@PyLong_Fro@10
  003db	f6 c1 02	 test	 cl, 2
  003de	75 4c		 jne	 SHORT $LN92@PyLong_Fro@10
  003e0	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  003e4	75 46		 jne	 SHORT $LN92@PyLong_Fro@10
  003e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  003f4	4c 8b cb	 mov	 r9, rbx
  003f7	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  003fd	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00405	e8 00 00 00 00	 call	 _PyParallel_Guard
  0040a	48 8b cb	 mov	 rcx, rbx
  0040d	85 c0		 test	 eax, eax
  0040f	74 07		 je	 SHORT $LN91@PyLong_Fro@10
  00411	e8 00 00 00 00	 call	 _Px_Dealloc
  00416	eb 14		 jmp	 SHORT $LN92@PyLong_Fro@10
$LN91@PyLong_Fro@10:
  00418	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0041c	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00422	eb 08		 jmp	 SHORT $LN92@PyLong_Fro@10
$LN86@PyLong_Fro@10:
  00424	48 8b cb	 mov	 rcx, rbx
  00427	e8 00 00 00 00	 call	 Px_DecRef
$LN92@PyLong_Fro@10:

; 2250 :                     z = tmp;
; 2251 :                     z->ob_digit[size_z] = (digit)c;

  0042c	41 89 74 2d 70	 mov	 DWORD PTR [r13+rbp+112], esi

; 2252 :                     ++size_z;

  00431	4d 8b ec	 mov	 r13, r12
  00434	4c 8b 64 24 38	 mov	 r12, QWORD PTR scan$1$[rsp]
  00439	48 8b dd	 mov	 rbx, rbp
  0043c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:__ImageBase
$LN18@PyLong_Fro@10:

; 2201 : 
; 2202 :         /* Work ;-) */
; 2203 :         while (str < scan) {

  00443	49 3b fc	 cmp	 rdi, r12
  00446	0f 83 8e 00 00
	00		 jae	 $LN113@PyLong_Fro@10
  0044c	44 8b 84 24 c0
	00 00 00	 mov	 r8d, DWORD PTR convwidth$1$[rsp]
  00454	48 8b 4c 24 40	 mov	 rcx, QWORD PTR convmultmax$1$[rsp]
  00459	e9 85 fe ff ff	 jmp	 $LL32@PyLong_Fro@10
$LN102@PyLong_Fro@10:

; 2243 :                         Py_DECREF(z);

  0045e	e8 00 00 00 00	 call	 _Py_PXCTX
  00463	85 c0		 test	 eax, eax
  00465	0f 85 7e 01 00
	00		 jne	 $LN121@PyLong_Fro@10
  0046b	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0046f	a8 20		 test	 al, 32			; 00000020H
  00471	75 5a		 jne	 SHORT $LN75@PyLong_Fro@10
  00473	84 c0		 test	 al, al
  00475	78 56		 js	 SHORT $LN75@PyLong_Fro@10
  00477	a8 02		 test	 al, 2
  00479	0f 85 6a 01 00
	00		 jne	 $LN121@PyLong_Fro@10
  0047f	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00483	0f 85 60 01 00
	00		 jne	 $LN121@PyLong_Fro@10
  00489	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00490	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00497	4c 8b cb	 mov	 r9, rbx
  0049a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  004a0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004a8	e8 00 00 00 00	 call	 _PyParallel_Guard
  004ad	48 8b cb	 mov	 rcx, rbx
  004b0	85 c0		 test	 eax, eax
  004b2	74 0a		 je	 SHORT $LN80@PyLong_Fro@10
  004b4	e8 00 00 00 00	 call	 _Px_Dealloc
  004b9	e9 2b 01 00 00	 jmp	 $LN121@PyLong_Fro@10
$LN80@PyLong_Fro@10:
  004be	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  004c2	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  004c8	e9 1c 01 00 00	 jmp	 $LN121@PyLong_Fro@10
$LN75@PyLong_Fro@10:
  004cd	48 8b cb	 mov	 rcx, rbx
  004d0	e8 00 00 00 00	 call	 Px_DecRef

; 2244 :                         return NULL;

  004d5	e9 0f 01 00 00	 jmp	 $LN121@PyLong_Fro@10
$LN113@PyLong_Fro@10:

; 2040 :             base = 16;

  004da	8b ac 24 d0 00
	00 00		 mov	 ebp, DWORD PTR base$[rsp]
  004e1	4c 8b 6c 24 48	 mov	 r13, QWORD PTR start$1$[rsp]
  004e6	4c 8b 74 24 50	 mov	 r14, QWORD PTR orig_str$1$[rsp]
  004eb	eb 03		 jmp	 SHORT $LN123@PyLong_Fro@10
$LN114@PyLong_Fro@10:

; 2016 : {

  004ed	4c 8b ef	 mov	 r13, rdi
$LN123@PyLong_Fro@10:
  004f0	4c 8b a4 24 c8
	00 00 00	 mov	 r12, QWORD PTR pend$[rsp]
  004f8	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:__ImageBase
$LN110@PyLong_Fro@10:

; 2253 :                 }
; 2254 :             }
; 2255 :         }
; 2256 :     }
; 2257 :     if (z == NULL)

  004ff	48 85 db	 test	 rbx, rbx

; 2258 :         return NULL;

  00502	0f 84 e1 00 00
	00		 je	 $LN121@PyLong_Fro@10

; 2259 :     if (error_if_nonzero) {

  00508	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR error_if_nonzero$1$[rsp], 0
  00510	74 08		 je	 SHORT $LN14@PyLong_Fro@10

; 2260 :         /* reset the base to 0, else the exception message
; 2261 :            doesn't make too much sense */
; 2262 :         base = 0;

  00512	33 ed		 xor	 ebp, ebp

; 2263 :         if (Py_SIZE(z) != 0)

  00514	48 39 6b 60	 cmp	 QWORD PTR [rbx+96], rbp
  00518	75 62		 jne	 SHORT $onError$21850
$LN14@PyLong_Fro@10:

; 2264 :             goto onError;
; 2265 :         /* there might still be other problems, therefore base
; 2266 :            remains zero here for the same reason */
; 2267 :     }
; 2268 :     if (str == start)

  0051a	49 3b fd	 cmp	 rdi, r13
  0051d	74 5d		 je	 SHORT $onError$21850

; 2269 :         goto onError;
; 2270 :     if (sign < 0)

  0051f	83 7c 24 30 00	 cmp	 DWORD PTR sign$1$[rsp], 0
  00524	7d 0b		 jge	 SHORT $LN100@PyLong_Fro@10

; 2271 :         Py_SIZE(z) = -(Py_SIZE(z));

  00526	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  0052a	48 f7 d8	 neg	 rax
  0052d	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax
$LN100@PyLong_Fro@10:

; 2272 :     while (*str && Py_ISSPACE(Py_CHARMASK(*str)))

  00531	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  00534	84 c0		 test	 al, al
  00536	74 27		 je	 SHORT $LN9@PyLong_Fro@10
  00538	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL11@PyLong_Fro@10:
  00540	0f b6 c0	 movzx	 eax, al
  00543	f6 84 86 00 00
	00 00 08	 test	 BYTE PTR _Py_ctype_table[rsi+rax*4], 8
  0054b	74 0d		 je	 SHORT $LN10@PyLong_Fro@10
  0054d	0f b6 47 01	 movzx	 eax, BYTE PTR [rdi+1]

; 2273 :         str++;

  00551	48 ff c7	 inc	 rdi
  00554	84 c0		 test	 al, al
  00556	75 e8		 jne	 SHORT $LL11@PyLong_Fro@10

; 2274 :     if (*str != '\0')

  00558	eb 05		 jmp	 SHORT $LN9@PyLong_Fro@10
$LN10@PyLong_Fro@10:
  0055a	80 3f 00	 cmp	 BYTE PTR [rdi], 0
  0055d	75 1d		 jne	 SHORT $onError$21850
$LN9@PyLong_Fro@10:

; 2275 :         goto onError;
; 2276 :     long_normalize(z);

  0055f	48 8b cb	 mov	 rcx, rbx
  00562	e8 00 00 00 00	 call	 long_normalize

; 2277 :     z = maybe_small_long(z);

  00567	e8 00 00 00 00	 call	 maybe_small_long

; 2278 :     if (z == NULL)

  0056c	48 85 c0	 test	 rax, rax

; 2279 :         return NULL;

  0056f	74 78		 je	 SHORT $LN121@PyLong_Fro@10

; 2280 :     if (pend != NULL)

  00571	4d 85 e4	 test	 r12, r12
  00574	74 75		 je	 SHORT $LN118@PyLong_Fro@10

; 2281 :         *pend = str;

  00576	49 89 3c 24	 mov	 QWORD PTR [r12], rdi

; 2282 :     return (PyObject *) z;

  0057a	eb 6f		 jmp	 SHORT $LN118@PyLong_Fro@10
$onError$21850:

; 2283 : 
; 2284 :   onError:
; 2285 :     if (pend != NULL)

  0057c	4d 85 e4	 test	 r12, r12
  0057f	74 04		 je	 SHORT $LN5@PyLong_Fro@10

; 2286 :         *pend = str;

  00581	49 89 3c 24	 mov	 QWORD PTR [r12], rdi
$LN5@PyLong_Fro@10:

; 2287 :     Py_XDECREF(z);

  00585	48 8b cb	 mov	 rcx, rbx
  00588	e8 00 00 00 00	 call	 _Py_DecRef

; 2288 :     slen = strlen(orig_str) < 200 ? strlen(orig_str) : 200;

  0058d	48 83 c9 ff	 or	 rcx, -1
  00591	33 c0		 xor	 eax, eax
  00593	49 8b fe	 mov	 rdi, r14
  00596	ba c8 00 00 00	 mov	 edx, 200		; 000000c8H
  0059b	f2 ae		 repne scasb
  0059d	48 f7 d1	 not	 rcx
  005a0	48 ff c9	 dec	 rcx
  005a3	48 3b ca	 cmp	 rcx, rdx
  005a6	73 10		 jae	 SHORT $LN69@PyLong_Fro@10
  005a8	48 83 c9 ff	 or	 rcx, -1
  005ac	49 8b fe	 mov	 rdi, r14
  005af	f2 ae		 repne scasb
  005b1	48 f7 d1	 not	 rcx
  005b4	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
$LN69@PyLong_Fro@10:

; 2289 :     strobj = PyUnicode_FromStringAndSize(orig_str, slen);

  005b8	49 8b ce	 mov	 rcx, r14
  005bb	e8 00 00 00 00	 call	 PyUnicode_FromStringAndSize
  005c0	48 8b f8	 mov	 rdi, rax

; 2290 :     if (strobj == NULL)

  005c3	48 85 c0	 test	 rax, rax

; 2291 :         return NULL;

  005c6	74 21		 je	 SHORT $LN121@PyLong_Fro@10

; 2292 :     PyErr_Format(PyExc_ValueError,
; 2293 :                  "invalid literal for int() with base %d: %R",
; 2294 :                  base, strobj);

  005c8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  005cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@EMMOEPEF@invalid?5literal?5for?5int?$CI?$CJ?5with?5b@
  005d6	4c 8b c8	 mov	 r9, rax
  005d9	44 8b c5	 mov	 r8d, ebp
  005dc	e8 00 00 00 00	 call	 PyErr_Format

; 2295 :     Py_DECREF(strobj);

  005e1	48 8b cf	 mov	 rcx, rdi
  005e4	e8 00 00 00 00	 call	 _Py_DecRef
$LN121@PyLong_Fro@10:

; 2296 :     return NULL;

  005e9	33 c0		 xor	 eax, eax
$LN118@PyLong_Fro@10:
  005eb	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  005f3	4c 8b 7c 24 78	 mov	 r15, QWORD PTR [rsp+120]
  005f8	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR [rsp+136]
  00600	4c 8b ac 24 80
	00 00 00	 mov	 r13, QWORD PTR [rsp+128]

; 2297 : }

  00608	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0060f	41 5e		 pop	 r14
  00611	41 5c		 pop	 r12
  00613	5f		 pop	 rdi
  00614	5d		 pop	 rbp
  00615	c3		 ret	 0
PyLong_FromString ENDP
_TEXT	ENDS
PUBLIC	_PyLong_FromBytes
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_PyLong_FromBytes DD imagerel $LN21
	DD	imagerel $LN21+276
	DD	imagerel $unwind$_PyLong_FromBytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_FromBytes DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT _PyLong_FromBytes
_TEXT	SEGMENT
s$ = 64
len$ = 72
base$ = 80
end$ = 88
_PyLong_FromBytes PROC					; COMDAT

; 2306 : {

$LN21:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fa	 mov	 rdi, rdx

; 2307 :     PyObject *result, *strobj;
; 2308 :     char *end = NULL;
; 2309 : 
; 2310 :     result = PyLong_FromString((char*)s, &end, base);

  00017	48 8d 54 24 58	 lea	 rdx, QWORD PTR end$[rsp]
  0001c	41 8b e8	 mov	 ebp, r8d
  0001f	48 8b f1	 mov	 rsi, rcx
  00022	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR end$[rsp], 0
  0002b	e8 00 00 00 00	 call	 PyLong_FromString
  00030	48 8b d8	 mov	 rbx, rax

; 2311 :     if (end == NULL || (result != NULL && end == s + len))

  00033	48 8b 44 24 58	 mov	 rax, QWORD PTR end$[rsp]
  00038	48 85 c0	 test	 rax, rax
  0003b	0f 84 bb 00 00
	00		 je	 $LN6@PyLong_Fro@11
  00041	48 85 db	 test	 rbx, rbx
  00044	74 72		 je	 SHORT $LN4@PyLong_Fro@11
  00046	48 8d 0c 3e	 lea	 rcx, QWORD PTR [rsi+rdi]
  0004a	48 3b c1	 cmp	 rax, rcx
  0004d	0f 84 a9 00 00
	00		 je	 $LN6@PyLong_Fro@11

; 2313 :     Py_XDECREF(result);

  00053	e8 00 00 00 00	 call	 _Py_PXCTX
  00058	85 c0		 test	 eax, eax
  0005a	75 5c		 jne	 SHORT $LN4@PyLong_Fro@11
  0005c	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00060	a8 20		 test	 al, 32			; 00000020H
  00062	75 4c		 jne	 SHORT $LN14@PyLong_Fro@11
  00064	84 c0		 test	 al, al
  00066	78 48		 js	 SHORT $LN14@PyLong_Fro@11
  00068	a8 02		 test	 al, 2
  0006a	75 4c		 jne	 SHORT $LN4@PyLong_Fro@11
  0006c	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00070	75 46		 jne	 SHORT $LN4@PyLong_Fro@11
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00080	4c 8b cb	 mov	 r9, rbx
  00083	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00089	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00091	e8 00 00 00 00	 call	 _PyParallel_Guard
  00096	48 8b cb	 mov	 rcx, rbx
  00099	85 c0		 test	 eax, eax
  0009b	74 07		 je	 SHORT $LN19@PyLong_Fro@11
  0009d	e8 00 00 00 00	 call	 _Px_Dealloc
  000a2	eb 14		 jmp	 SHORT $LN4@PyLong_Fro@11
$LN19@PyLong_Fro@11:
  000a4	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000a8	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000ae	eb 08		 jmp	 SHORT $LN4@PyLong_Fro@11
$LN14@PyLong_Fro@11:
  000b0	48 8b cb	 mov	 rcx, rbx
  000b3	e8 00 00 00 00	 call	 Px_DecRef
$LN4@PyLong_Fro@11:

; 2314 :     strobj = PyBytes_FromStringAndSize(s, Py_MIN(len, 200));

  000b8	b8 c8 00 00 00	 mov	 eax, 200		; 000000c8H
  000bd	48 8b ce	 mov	 rcx, rsi
  000c0	48 3b f8	 cmp	 rdi, rax
  000c3	48 0f 4f f8	 cmovg	 rdi, rax
  000c7	48 8b d7	 mov	 rdx, rdi
  000ca	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000cf	48 8b d8	 mov	 rbx, rax

; 2315 :     if (strobj != NULL) {

  000d2	48 85 c0	 test	 rax, rax
  000d5	74 21		 je	 SHORT $LN1@PyLong_Fro@11

; 2316 :         PyErr_Format(PyExc_ValueError,
; 2317 :                      "invalid literal for int() with base %d: %R",
; 2318 :                      base, strobj);

  000d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@EMMOEPEF@invalid?5literal?5for?5int?$CI?$CJ?5with?5b@
  000e5	4c 8b c8	 mov	 r9, rax
  000e8	44 8b c5	 mov	 r8d, ebp
  000eb	e8 00 00 00 00	 call	 PyErr_Format

; 2319 :         Py_DECREF(strobj);

  000f0	48 8b cb	 mov	 rcx, rbx
  000f3	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyLong_Fro@11:

; 2320 :     }
; 2321 :     return NULL;

  000f8	33 c0		 xor	 eax, eax
  000fa	eb 03		 jmp	 SHORT $LN8@PyLong_Fro@11
$LN6@PyLong_Fro@11:

; 2312 :         return result;

  000fc	48 8b c3	 mov	 rax, rbx
$LN8@PyLong_Fro@11:

; 2322 : }

  000ff	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00104	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00109	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0010e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00112	5f		 pop	 rdi
  00113	c3		 ret	 0
_PyLong_FromBytes ENDP
_TEXT	ENDS
PUBLIC	PyLong_FromUnicodeObject
EXTRN	PySequence_GetSlice:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_UnicodeEncodeError:QWORD
EXTRN	PyUnicode_AsUTF8AndSize:PROC
EXTRN	_PyUnicode_TransformDecimalAndSpaceToASCII:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromUnicodeObject DD imagerel $LN16
	DD	imagerel $LN16+267
	DD	imagerel $unwind$PyLong_FromUnicodeObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromUnicodeObject DD 084001H
	DD	097440H
	DD	08643bH
	DD	0c0053209H
	DD	030025003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyLong_FromUnicodeObject
_TEXT	SEGMENT
u$ = 64
base$ = 72
end$ = 80
buflen$ = 88
PyLong_FromUnicodeObject PROC				; COMDAT

; 2337 : {

$LN16:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	41 54		 push	 r12
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00009	44 8b e2	 mov	 r12d, edx
  0000c	48 8b e9	 mov	 rbp, rcx

; 2338 :     PyObject *result, *asciidig, *strobj;
; 2339 :     char *buffer, *end = NULL;

  0000f	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR end$[rsp], 0

; 2340 :     Py_ssize_t buflen;
; 2341 : 
; 2342 :     asciidig = _PyUnicode_TransformDecimalAndSpaceToASCII(u);

  00018	e8 00 00 00 00	 call	 _PyUnicode_TransformDecimalAndSpaceToASCII
  0001d	48 8b d8	 mov	 rbx, rax

; 2343 :     if (asciidig == NULL)

  00020	48 85 c0	 test	 rax, rax
  00023	75 09		 jne	 SHORT $LN11@PyLong_Fro@12

; 2368 : }

  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	41 5c		 pop	 r12
  0002b	5d		 pop	 rbp
  0002c	5b		 pop	 rbx
  0002d	c3		 ret	 0
$LN11@PyLong_Fro@12:

; 2344 :         return NULL;
; 2345 :     buffer = PyUnicode_AsUTF8AndSize(asciidig, &buflen);

  0002e	48 8d 54 24 58	 lea	 rdx, QWORD PTR buflen$[rsp]
  00033	48 8b c8	 mov	 rcx, rax
  00036	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0003b	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00040	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  00045	48 8b f0	 mov	 rsi, rax

; 2346 :     if (buffer == NULL) {

  00048	48 85 c0	 test	 rax, rax
  0004b	75 1f		 jne	 SHORT $LN10@PyLong_Fro@12

; 2347 :         Py_DECREF(asciidig);

  0004d	48 8b cb	 mov	 rcx, rbx
  00050	e8 00 00 00 00	 call	 _Py_DecRef

; 2348 :         if (!PyErr_ExceptionMatches(PyExc_UnicodeEncodeError))

  00055	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnicodeEncodeError
  0005c	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00061	85 c0		 test	 eax, eax
  00063	75 4b		 jne	 SHORT $LN3@PyLong_Fro@12

; 2349 :             return NULL;

  00065	33 c0		 xor	 eax, eax
  00067	e9 8c 00 00 00	 jmp	 $LN15@PyLong_Fro@12
$LN10@PyLong_Fro@12:

; 2350 :     }
; 2351 :     else {
; 2352 :         result = PyLong_FromString(buffer, &end, base);

  0006c	48 8d 54 24 50	 lea	 rdx, QWORD PTR end$[rsp]
  00071	45 8b c4	 mov	 r8d, r12d
  00074	48 8b c8	 mov	 rcx, rax
  00077	e8 00 00 00 00	 call	 PyLong_FromString
  0007c	48 8b f8	 mov	 rdi, rax

; 2353 :         if (end == NULL || (result != NULL && end == buffer + buflen)) {

  0007f	48 8b 44 24 50	 mov	 rax, QWORD PTR end$[rsp]
  00084	48 85 c0	 test	 rax, rax
  00087	74 64		 je	 SHORT $LN6@PyLong_Fro@12
  00089	48 85 ff	 test	 rdi, rdi
  0008c	74 0d		 je	 SHORT $LN7@PyLong_Fro@12
  0008e	48 8b 54 24 58	 mov	 rdx, QWORD PTR buflen$[rsp]
  00093	48 03 d6	 add	 rdx, rsi
  00096	48 3b c2	 cmp	 rax, rdx
  00099	74 52		 je	 SHORT $LN6@PyLong_Fro@12
$LN7@PyLong_Fro@12:

; 2356 :         }
; 2357 :         Py_DECREF(asciidig);

  0009b	48 8b cb	 mov	 rcx, rbx
  0009e	e8 00 00 00 00	 call	 _Py_DecRef

; 2358 :         Py_XDECREF(result);

  000a3	48 85 ff	 test	 rdi, rdi
  000a6	74 08		 je	 SHORT $LN3@PyLong_Fro@12
  000a8	48 8b cf	 mov	 rcx, rdi
  000ab	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyLong_Fro@12:

; 2359 :     }
; 2360 :     strobj = PySequence_GetSlice(u, 0, 200);

  000b0	33 d2		 xor	 edx, edx
  000b2	41 b8 c8 00 00
	00		 mov	 r8d, 200		; 000000c8H
  000b8	48 8b cd	 mov	 rcx, rbp
  000bb	e8 00 00 00 00	 call	 PySequence_GetSlice
  000c0	48 8b d8	 mov	 rbx, rax

; 2361 :     if (strobj != NULL) {

  000c3	48 85 c0	 test	 rax, rax
  000c6	74 21		 je	 SHORT $LN1@PyLong_Fro@12

; 2362 :         PyErr_Format(PyExc_ValueError,
; 2363 :                      "invalid literal for int() with base %d: %R",
; 2364 :                      base, strobj);

  000c8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@EMMOEPEF@invalid?5literal?5for?5int?$CI?$CJ?5with?5b@
  000d6	4c 8b c8	 mov	 r9, rax
  000d9	45 8b c4	 mov	 r8d, r12d
  000dc	e8 00 00 00 00	 call	 PyErr_Format

; 2365 :         Py_DECREF(strobj);

  000e1	48 8b cb	 mov	 rcx, rbx
  000e4	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyLong_Fro@12:

; 2366 :     }
; 2367 :     return NULL;

  000e9	33 c0		 xor	 eax, eax
  000eb	eb 0b		 jmp	 SHORT $LN15@PyLong_Fro@12
$LN6@PyLong_Fro@12:

; 2354 :             Py_DECREF(asciidig);

  000ed	48 8b cb	 mov	 rcx, rbx
  000f0	e8 00 00 00 00	 call	 _Py_DecRef

; 2355 :             return result;

  000f5	48 8b c7	 mov	 rax, rdi
$LN15@PyLong_Fro@12:
  000f8	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000fd	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 2368 : }

  00102	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00106	41 5c		 pop	 r12
  00108	5d		 pop	 rbp
  00109	5b		 pop	 rbx
  0010a	c3		 ret	 0
PyLong_FromUnicodeObject ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$x_divrem DD imagerel x_divrem
	DD	imagerel x_divrem+90
	DD	imagerel $unwind$x_divrem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$x_divrem DD imagerel x_divrem+90
	DD	imagerel x_divrem+646
	DD	imagerel $chain$0$x_divrem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$x_divrem DD imagerel x_divrem+646
	DD	imagerel x_divrem+694
	DD	imagerel $chain$2$x_divrem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$x_divrem DD 020021H
	DD	05f400H
	DD	imagerel x_divrem
	DD	imagerel x_divrem+90
	DD	imagerel $unwind$x_divrem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$x_divrem DD 020521H
	DD	05f405H
	DD	imagerel x_divrem
	DD	imagerel x_divrem+90
	DD	imagerel $unwind$x_divrem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$x_divrem DD 081301H
	DD	0e00f5213H
	DD	0c00bd00dH
	DD	060087009H
	DD	030065007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT x_divrem
_TEXT	SEGMENT
wm2$1$ = 112
v1$ = 112
d$1$ = 120
w1$ = 120
prem$ = 128
a$1$ = 136
x_divrem PROC						; COMDAT

; 2433 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2434 :     PyLongObject *v, *w, *a;
; 2435 :     Py_ssize_t i, k, size_v, size_w;
; 2436 :     int d;
; 2437 :     digit wm1, wm2, carry, q, r, vtop, *v0, *vk, *w0, *ak;
; 2438 :     twodigits vv;
; 2439 :     sdigit zhi;
; 2440 :     stwodigits z;
; 2441 : 
; 2442 :     /* We follow Knuth [The Art of Computer Programming, Vol. 2 (3rd
; 2443 :        edn.), section 4.3.1, Algorithm D], except that we don't explicitly
; 2444 :        handle the special case when the initial estimate q for a quotient
; 2445 :        digit is >= PyLong_BASE: the max value for q is PyLong_BASE+1, and
; 2446 :        that won't overflow a digit. */
; 2447 : 
; 2448 :     /* allocate space; w will also be used to hold the final remainder */
; 2449 :     size_v = ABS(Py_SIZE(v1));

  00013	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  00017	4d 8b f0	 mov	 r14, r8
  0001a	48 8b f2	 mov	 rsi, rdx
  0001d	4c 8b e1	 mov	 r12, rcx
  00020	48 85 db	 test	 rbx, rbx
  00023	79 03		 jns	 SHORT $LN24@x_divrem
  00025	48 f7 db	 neg	 rbx
$LN24@x_divrem:

; 2450 :     size_w = ABS(Py_SIZE(w1));

  00028	48 8b 7a 60	 mov	 rdi, QWORD PTR [rdx+96]
  0002c	48 85 ff	 test	 rdi, rdi
  0002f	79 03		 jns	 SHORT $LN26@x_divrem
  00031	48 f7 df	 neg	 rdi
$LN26@x_divrem:

; 2451 :     assert(size_v >= size_w && size_w >= 2); /* Assert checks by div() */
; 2452 :     v = _PyLong_New(size_v+1);

  00034	48 8d 4b 01	 lea	 rcx, QWORD PTR [rbx+1]
  00038	e8 00 00 00 00	 call	 _PyLong_New
  0003d	4c 8b e8	 mov	 r13, rax

; 2453 :     if (v == NULL) {

  00040	48 85 c0	 test	 rax, rax
  00043	75 12		 jne	 SHORT $LN21@x_divrem

; 2454 :         *prem = NULL;

  00045	49 89 06	 mov	 QWORD PTR [r14], rax

; 2553 : }

  00048	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004c	41 5e		 pop	 r14
  0004e	41 5d		 pop	 r13
  00050	41 5c		 pop	 r12
  00052	5f		 pop	 rdi
  00053	5e		 pop	 rsi
  00054	5d		 pop	 rbp
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
$LN21@x_divrem:

; 2455 :         return NULL;
; 2456 :     }
; 2457 :     w = _PyLong_New(size_w);

  00057	48 8b cf	 mov	 rcx, rdi
  0005a	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  0005f	e8 00 00 00 00	 call	 _PyLong_New
  00064	4c 8b f8	 mov	 r15, rax

; 2458 :     if (w == NULL) {

  00067	48 85 c0	 test	 rax, rax

; 2459 :         Py_DECREF(v);
; 2460 :         *prem = NULL;
; 2461 :         return NULL;

  0006a	74 70		 je	 SHORT $LN40@x_divrem

; 2462 :     }
; 2463 : 
; 2464 :     /* normalize: shift w1 left so that its top digit is >= PyLong_BASE/2.
; 2465 :        shift v1 left by the same amount.  Results go into w and v. */
; 2466 :     d = PyLong_SHIFT - bits_in_digit(w1->ob_digit[size_w-1]);

  0006c	8b 4c be 6c	 mov	 ecx, DWORD PTR [rsi+rdi*4+108]
  00070	e8 00 00 00 00	 call	 bits_in_digit
  00075	41 b9 1e 00 00
	00		 mov	 r9d, 30

; 2467 :     carry = v_lshift(w->ob_digit, w1->ob_digit, size_w, d);

  0007b	48 8d 56 70	 lea	 rdx, QWORD PTR [rsi+112]
  0007f	44 2b c8	 sub	 r9d, eax
  00082	49 8d 4f 70	 lea	 rcx, QWORD PTR [r15+112]
  00086	4c 8b c7	 mov	 r8, rdi
  00089	44 89 4c 24 78	 mov	 DWORD PTR d$1$[rsp], r9d
  0008e	e8 00 00 00 00	 call	 v_lshift

; 2468 :     assert(carry == 0);
; 2469 :     carry = v_lshift(v->ob_digit, v1->ob_digit, size_v, d);

  00093	49 8d 54 24 70	 lea	 rdx, QWORD PTR [r12+112]
  00098	49 8d 4d 70	 lea	 rcx, QWORD PTR [r13+112]
  0009c	4c 8b c3	 mov	 r8, rbx
  0009f	e8 00 00 00 00	 call	 v_lshift

; 2470 :     if (carry != 0 || v->ob_digit[size_v-1] >= w->ob_digit[size_w-1]) {

  000a4	85 c0		 test	 eax, eax
  000a6	75 0c		 jne	 SHORT $LN18@x_divrem
  000a8	41 8b 4c bf 6c	 mov	 ecx, DWORD PTR [r15+rdi*4+108]
  000ad	41 39 4c 9d 6c	 cmp	 DWORD PTR [r13+rbx*4+108], ecx
  000b2	72 08		 jb	 SHORT $LN19@x_divrem
$LN18@x_divrem:

; 2471 :         v->ob_digit[size_v] = carry;

  000b4	41 89 44 9d 70	 mov	 DWORD PTR [r13+rbx*4+112], eax

; 2472 :         size_v++;

  000b9	48 ff c3	 inc	 rbx
$LN19@x_divrem:

; 2473 :     }
; 2474 : 
; 2475 :     /* Now v->ob_digit[size_v-1] < w->ob_digit[size_w-1], so quotient has
; 2476 :        at most (and usually exactly) k = size_v - size_w digits. */
; 2477 :     k = size_v - size_w;

  000bc	48 2b df	 sub	 rbx, rdi

; 2478 :     assert(k >= 0);
; 2479 :     a = _PyLong_New(k);

  000bf	48 8b cb	 mov	 rcx, rbx
  000c2	e8 00 00 00 00	 call	 _PyLong_New
  000c7	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR a$1$[rsp], rax

; 2480 :     if (a == NULL) {

  000cf	48 85 c0	 test	 rax, rax
  000d2	75 1e		 jne	 SHORT $LN17@x_divrem

; 2481 :         Py_DECREF(w);

  000d4	49 8b cf	 mov	 rcx, r15
  000d7	e8 00 00 00 00	 call	 _Py_DecRef
$LN40@x_divrem:

; 2482 :         Py_DECREF(v);

  000dc	49 8b cd	 mov	 rcx, r13
  000df	e8 00 00 00 00	 call	 _Py_DecRef

; 2483 :         *prem = NULL;

  000e4	49 c7 06 00 00
	00 00		 mov	 QWORD PTR [r14], 0

; 2484 :         return NULL;

  000eb	33 c0		 xor	 eax, eax
  000ed	e9 80 01 00 00	 jmp	 $LN39@x_divrem
$LN17@x_divrem:

; 2487 :     w0 = w->ob_digit;
; 2488 :     wm1 = w0[size_w-1];
; 2489 :     wm2 = w0[size_w-2];

  000f2	41 8b 54 bf 68	 mov	 edx, DWORD PTR [r15+rdi*4+104]
  000f7	41 8b 6c bf 6c	 mov	 ebp, DWORD PTR [r15+rdi*4+108]
  000fc	49 8d 4f 70	 lea	 rcx, QWORD PTR [r15+112]

; 2490 :     for (vk = v0+k, ak = a->ob_digit + k; vk-- > v0;) {

  00100	4c 8d 64 98 70	 lea	 r12, QWORD PTR [rax+rbx*4+112]
  00105	49 8d 74 9d 70	 lea	 rsi, QWORD PTR [r13+rbx*4+112]
  0010a	49 8d 45 70	 lea	 rax, QWORD PTR [r13+112]
  0010e	89 54 24 70	 mov	 DWORD PTR wm2$1$[rsp], edx
  00112	48 3b f0	 cmp	 rsi, rax
  00115	0f 86 27 01 00
	00		 jbe	 $LN36@x_divrem

; 2485 :     }
; 2486 :     v0 = v->ob_digit;

  0011b	48 8b d9	 mov	 rbx, rcx
  0011e	48 2b de	 sub	 rbx, rsi
$LL16@x_divrem:

; 2490 :     for (vk = v0+k, ak = a->ob_digit + k; vk-- > v0;) {

  00121	48 83 ee 04	 sub	 rsi, 4
  00125	48 83 c3 04	 add	 rbx, 4

; 2491 :         /* inner loop: divide vk[0:size_w+1] by w0[0:size_w], giving
; 2492 :            single-digit quotient q, remainder in vk[0:size_w]. */
; 2493 : 
; 2494 :         SIGCHECK({
; 2495 :                 Py_DECREF(a);
; 2496 :                 Py_DECREF(w);
; 2497 :                 Py_DECREF(v);
; 2498 :                 *prem = NULL;
; 2499 :                 return NULL;
; 2500 :             });

  00129	e8 00 00 00 00	 call	 PyErr_CheckSignals
  0012e	85 c0		 test	 eax, eax
  00130	0f 85 50 01 00
	00		 jne	 $LN33@x_divrem

; 2501 : 
; 2502 :         /* estimate quotient digit q; may overestimate by 1 (rare) */
; 2503 :         vtop = vk[size_w];

  00136	44 8b 34 be	 mov	 r14d, DWORD PTR [rsi+rdi*4]

; 2504 :         assert(vtop <= wm1);
; 2505 :         vv = ((twodigits)vtop << PyLong_SHIFT) | vk[size_w-1];

  0013a	44 8b 44 be fc	 mov	 r8d, DWORD PTR [rsi+rdi*4-4]

; 2506 :         q = (digit)(vv / wm1);
; 2507 :         r = (digit)(vv - (twodigits)wm1 * q); /* r = vv % wm1 */
; 2508 :         while ((twodigits)wm2 * q > (((twodigits)r << PyLong_SHIFT)
; 2509 :                                      | vk[size_w-2])) {

  0013f	44 8b 5c 24 70	 mov	 r11d, DWORD PTR wm2$1$[rsp]
  00144	44 8b 54 be f8	 mov	 r10d, DWORD PTR [rsi+rdi*4-8]
  00149	33 d2		 xor	 edx, edx
  0014b	41 8b c6	 mov	 eax, r14d
  0014e	48 c1 e0 1e	 shl	 rax, 30
  00152	4c 0b c0	 or	 r8, rax
  00155	49 8b c0	 mov	 rax, r8
  00158	48 f7 f5	 div	 rbp
  0015b	8b c8		 mov	 ecx, eax
  0015d	4c 8b c8	 mov	 r9, rax
  00160	0f af cd	 imul	 ecx, ebp
  00163	44 2b c1	 sub	 r8d, ecx
  00166	8b c8		 mov	 ecx, eax
  00168	41 8b d0	 mov	 edx, r8d
  0016b	48 c1 e2 1e	 shl	 rdx, 30
  0016f	49 0f af cb	 imul	 rcx, r11
  00173	49 0b d2	 or	 rdx, r10
  00176	48 3b ca	 cmp	 rcx, rdx
  00179	76 2a		 jbe	 SHORT $LN38@x_divrem
  0017b	0f 1f 44 00 00	 npad	 5
$LL10@x_divrem:

; 2510 :             --q;
; 2511 :             r += wm1;

  00180	44 03 c5	 add	 r8d, ebp
  00183	41 ff c9	 dec	 r9d

; 2512 :             if (r >= PyLong_BASE)

  00186	41 81 f8 00 00
	00 40		 cmp	 r8d, 1073741824		; 40000000H
  0018d	73 16		 jae	 SHORT $LN38@x_divrem

; 2506 :         q = (digit)(vv / wm1);
; 2507 :         r = (digit)(vv - (twodigits)wm1 * q); /* r = vv % wm1 */
; 2508 :         while ((twodigits)wm2 * q > (((twodigits)r << PyLong_SHIFT)
; 2509 :                                      | vk[size_w-2])) {

  0018f	41 8b c1	 mov	 eax, r9d
  00192	41 8b c8	 mov	 ecx, r8d
  00195	48 c1 e1 1e	 shl	 rcx, 30
  00199	49 0f af c3	 imul	 rax, r11
  0019d	49 0b ca	 or	 rcx, r10
  001a0	48 3b c1	 cmp	 rax, rcx
  001a3	77 db		 ja	 SHORT $LL10@x_divrem
$LN38@x_divrem:

; 2513 :                 break;
; 2514 :         }
; 2515 :         assert(q <= PyLong_BASE);
; 2516 : 
; 2517 :         /* subtract q*w0[0:size_w] from vk[0:size_w+1] */
; 2518 :         zhi = 0;

  001a5	33 d2		 xor	 edx, edx

; 2519 :         for (i = 0; i < size_w; ++i) {

  001a7	48 85 ff	 test	 rdi, rdi
  001aa	7e 3f		 jle	 SHORT $LN5@x_divrem
  001ac	45 8b d9	 mov	 r11d, r9d
  001af	4c 8b c6	 mov	 r8, rsi
  001b2	4c 8b d7	 mov	 r10, rdi
  001b5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL7@x_divrem:

; 2520 :             /* invariants: -PyLong_BASE <= -q <= zhi <= 0;
; 2521 :                -PyLong_BASE * q <= z < PyLong_BASE */
; 2522 :             z = (sdigit)vk[i] + zhi -
; 2523 :                 (stwodigits)q * (stwodigits)w0[i];

  001c0	42 8b 0c 03	 mov	 ecx, DWORD PTR [rbx+r8]
  001c4	41 8b 00	 mov	 eax, DWORD PTR [r8]
  001c7	49 83 c0 04	 add	 r8, 4
  001cb	03 c2		 add	 eax, edx
  001cd	48 63 d0	 movsxd	 rdx, eax
  001d0	49 0f af cb	 imul	 rcx, r11
  001d4	48 2b d1	 sub	 rdx, rcx

; 2524 :             vk[i] = (digit)z & PyLong_MASK;

  001d7	8b c2		 mov	 eax, edx

; 2525 :             zhi = (sdigit)Py_ARITHMETIC_RIGHT_SHIFT(stwodigits,
; 2526 :                                                     z, PyLong_SHIFT);

  001d9	48 c1 fa 1e	 sar	 rdx, 30
  001dd	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  001e2	49 ff ca	 dec	 r10
  001e5	41 89 40 fc	 mov	 DWORD PTR [r8-4], eax
  001e9	75 d5		 jne	 SHORT $LL7@x_divrem
$LN5@x_divrem:

; 2527 :         }
; 2528 : 
; 2529 :         /* add w back if q was too large (this branch taken rarely) */
; 2530 :         assert((sdigit)vtop + zhi == -1 || (sdigit)vtop + zhi == 0);
; 2531 :         if ((sdigit)vtop + zhi < 0) {

  001eb	42 8d 04 32	 lea	 eax, DWORD PTR [rdx+r14]
  001ef	85 c0		 test	 eax, eax
  001f1	79 2e		 jns	 SHORT $LN4@x_divrem

; 2532 :             carry = 0;

  001f3	33 d2		 xor	 edx, edx

; 2533 :             for (i = 0; i < size_w; ++i) {

  001f5	48 85 ff	 test	 rdi, rdi
  001f8	7e 24		 jle	 SHORT $LN1@x_divrem

; 2532 :             carry = 0;

  001fa	48 8b ce	 mov	 rcx, rsi
  001fd	4c 8b c7	 mov	 r8, rdi
$LL3@x_divrem:

; 2534 :                 carry += vk[i] + w0[i];

  00200	8b 04 0b	 mov	 eax, DWORD PTR [rbx+rcx]
  00203	48 83 c1 04	 add	 rcx, 4
  00207	03 41 fc	 add	 eax, DWORD PTR [rcx-4]
  0020a	03 d0		 add	 edx, eax

; 2535 :                 vk[i] = carry & PyLong_MASK;

  0020c	8b c2		 mov	 eax, edx

; 2536 :                 carry >>= PyLong_SHIFT;

  0020e	c1 ea 1e	 shr	 edx, 30
  00211	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00216	49 ff c8	 dec	 r8
  00219	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  0021c	75 e2		 jne	 SHORT $LL3@x_divrem
$LN1@x_divrem:

; 2537 :             }
; 2538 :             --q;

  0021e	41 ff c9	 dec	 r9d
$LN4@x_divrem:

; 2539 :         }
; 2540 : 
; 2541 :         /* store quotient digit */
; 2542 :         assert(q < PyLong_BASE);
; 2543 :         *--ak = q;

  00221	49 83 ec 04	 sub	 r12, 4
  00225	49 8d 45 70	 lea	 rax, QWORD PTR [r13+112]
  00229	45 89 0c 24	 mov	 DWORD PTR [r12], r9d
  0022d	48 3b f0	 cmp	 rsi, rax
  00230	0f 87 eb fe ff
	ff		 ja	 $LL16@x_divrem

; 2491 :         /* inner loop: divide vk[0:size_w+1] by w0[0:size_w], giving
; 2492 :            single-digit quotient q, remainder in vk[0:size_w]. */
; 2493 : 
; 2494 :         SIGCHECK({
; 2495 :                 Py_DECREF(a);
; 2496 :                 Py_DECREF(w);
; 2497 :                 Py_DECREF(v);
; 2498 :                 *prem = NULL;
; 2499 :                 return NULL;
; 2500 :             });

  00236	4c 8b b4 24 80
	00 00 00	 mov	 r14, QWORD PTR prem$[rsp]
  0023e	49 8d 4f 70	 lea	 rcx, QWORD PTR [r15+112]
$LN36@x_divrem:

; 2544 :     }
; 2545 : 
; 2546 :     /* unshift remainder; we reuse w to store the result */
; 2547 :     carry = v_rshift(w0, v0, size_w, d);

  00242	44 8b 4c 24 78	 mov	 r9d, DWORD PTR d$1$[rsp]
  00247	4c 8b c7	 mov	 r8, rdi
  0024a	48 8b d0	 mov	 rdx, rax
  0024d	e8 00 00 00 00	 call	 v_rshift

; 2548 :     assert(carry==0);
; 2549 :     Py_DECREF(v);

  00252	49 8b cd	 mov	 rcx, r13
  00255	e8 00 00 00 00	 call	 _Py_DecRef

; 2550 : 
; 2551 :     *prem = long_normalize(w);

  0025a	49 8b cf	 mov	 rcx, r15
  0025d	e8 00 00 00 00	 call	 long_normalize

; 2552 :     return long_normalize(a);

  00262	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR a$1$[rsp]
  0026a	49 89 06	 mov	 QWORD PTR [r14], rax
  0026d	e8 00 00 00 00	 call	 long_normalize
$LN39@x_divrem:
  00272	4c 8b 7c 24 28	 mov	 r15, QWORD PTR [rsp+40]

; 2553 : }

  00277	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0027b	41 5e		 pop	 r14
  0027d	41 5d		 pop	 r13
  0027f	41 5c		 pop	 r12
  00281	5f		 pop	 rdi
  00282	5e		 pop	 rsi
  00283	5d		 pop	 rbp
  00284	5b		 pop	 rbx
  00285	c3		 ret	 0
$LN33@x_divrem:

; 2491 :         /* inner loop: divide vk[0:size_w+1] by w0[0:size_w], giving
; 2492 :            single-digit quotient q, remainder in vk[0:size_w]. */
; 2493 : 
; 2494 :         SIGCHECK({
; 2495 :                 Py_DECREF(a);
; 2496 :                 Py_DECREF(w);
; 2497 :                 Py_DECREF(v);
; 2498 :                 *prem = NULL;
; 2499 :                 return NULL;
; 2500 :             });

  00286	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR a$1$[rsp]
  0028e	e8 00 00 00 00	 call	 _Py_DecRef
  00293	49 8b cf	 mov	 rcx, r15
  00296	e8 00 00 00 00	 call	 _Py_DecRef
  0029b	49 8b cd	 mov	 rcx, r13
  0029e	e8 00 00 00 00	 call	 _Py_DecRef
  002a3	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR prem$[rsp]
  002ab	33 c0		 xor	 eax, eax
  002ad	49 c7 03 00 00
	00 00		 mov	 QWORD PTR [r11], 0
  002b4	eb bc		 jmp	 SHORT $LN39@x_divrem
x_divrem ENDP
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@bff0000000000000
PUBLIC	??_C@_0DE@KPOPPGPJ@huge?5integer?3?5number?5of?5bits?5ove@ ; `string'
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3c80000000000000
PUBLIC	_PyLong_Frexp
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_Frexp DD imagerel $LN32
	DD	imagerel $LN32+58
	DD	imagerel $unwind$_PyLong_Frexp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyLong_Frexp DD imagerel $LN32+58
	DD	imagerel $LN32+105
	DD	imagerel $chain$0$_PyLong_Frexp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_PyLong_Frexp DD imagerel $LN32+105
	DD	imagerel $LN32+110
	DD	imagerel $chain$1$_PyLong_Frexp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_PyLong_Frexp DD imagerel $LN32+110
	DD	imagerel $LN32+140
	DD	imagerel $chain$2$_PyLong_Frexp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_PyLong_Frexp DD imagerel $LN32+140
	DD	imagerel $LN32+252
	DD	imagerel $chain$3$_PyLong_Frexp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_PyLong_Frexp DD imagerel $LN32+252
	DD	imagerel $LN32+408
	DD	imagerel $chain$4$_PyLong_Frexp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$_PyLong_Frexp DD imagerel $LN32+408
	DD	imagerel $LN32+472
	DD	imagerel $chain$5$_PyLong_Frexp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$_PyLong_Frexp DD imagerel $LN32+472
	DD	imagerel $LN32+539
	DD	imagerel $chain$6$_PyLong_Frexp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$_PyLong_Frexp DD imagerel $LN32+539
	DD	imagerel $LN32+589
	DD	imagerel $chain$8$_PyLong_Frexp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$_PyLong_Frexp DD 020021H
	DD	0b5400H
	DD	imagerel $LN32
	DD	imagerel $LN32+58
	DD	imagerel $unwind$_PyLong_Frexp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$_PyLong_Frexp DD 021H
	DD	imagerel $LN32+58
	DD	imagerel $LN32+105
	DD	imagerel $chain$0$_PyLong_Frexp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$_PyLong_Frexp DD 021H
	DD	imagerel $LN32+105
	DD	imagerel $LN32+110
	DD	imagerel $chain$1$_PyLong_Frexp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_PyLong_Frexp DD 021H
	DD	imagerel $LN32+110
	DD	imagerel $LN32+140
	DD	imagerel $chain$2$_PyLong_Frexp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_PyLong_Frexp DD 020521H
	DD	0de405H
	DD	imagerel $LN32+110
	DD	imagerel $LN32+140
	DD	imagerel $chain$2$_PyLong_Frexp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_PyLong_Frexp DD 020521H
	DD	0c7405H
	DD	imagerel $LN32+105
	DD	imagerel $LN32+110
	DD	imagerel $chain$1$_PyLong_Frexp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_PyLong_Frexp DD 020521H
	DD	0a3405H
	DD	imagerel $LN32+58
	DD	imagerel $LN32+105
	DD	imagerel $chain$0$_PyLong_Frexp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyLong_Frexp DD 020521H
	DD	0b5405H
	DD	imagerel $LN32
	DD	imagerel $LN32+58
	DD	imagerel $unwind$_PyLong_Frexp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_Frexp DD 040a01H
	DD	0d006520aH
	DD	06002c004H
xdata	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT ??_C@_0DE@KPOPPGPJ@huge?5integer?3?5number?5of?5bits?5ove@
CONST	SEGMENT
??_C@_0DE@KPOPPGPJ@huge?5integer?3?5number?5of?5bits?5ove@ DB 'huge integ'
	DB	'er: number of bits overflows a Py_ssize_t', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3c80000000000000
CONST	SEGMENT
__real@3c80000000000000 DQ 03c80000000000000r	; 2.77556e-017
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyLong_Frexp
_TEXT	SEGMENT
x_digits$ = 32
a$ = 80
e$ = 88
_PyLong_Frexp PROC					; COMDAT

; 2571 : {

$LN32:
  00000	40 56		 push	 rsi
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2572 :     Py_ssize_t a_size, a_bits, shift_digits, shift_bits, x_size;
; 2573 :     /* See below for why x_digits is always large enough. */
; 2574 :     digit rem, x_digits[2 + (DBL_MANT_DIG + 1) / PyLong_SHIFT];
; 2575 :     double dx;
; 2576 :     /* Correction term for round-half-to-even rounding.  For a digit x,
; 2577 :        "x + half_even_correction[x & 7]" gives x rounded to the nearest
; 2578 :        multiple of 4, rounding ties to a multiple of 8. */
; 2579 :     static const int half_even_correction[8] = {0, -1, -2, 1, 0, -1, 2, 1};
; 2580 : 
; 2581 :     a_size = ABS(Py_SIZE(a));

  0000a	48 8b 71 60	 mov	 rsi, QWORD PTR [rcx+96]
  0000e	4c 8b ea	 mov	 r13, rdx
  00011	4c 8b e1	 mov	 r12, rcx
  00014	48 85 f6	 test	 rsi, rsi
  00017	79 06		 jns	 SHORT $LN31@PyLong_Fre
  00019	48 f7 de	 neg	 rsi

; 2582 :     if (a_size == 0) {

  0001c	48 85 f6	 test	 rsi, rsi
$LN31@PyLong_Fre:
  0001f	75 15		 jne	 SHORT $LN16@PyLong_Fre

; 2583 :         /* Special case for 0: significand 0.0, exponent 0. */
; 2584 :         *e = 0;

  00021	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0

; 2585 :         return 0.0;

  00028	66 0f 57 c0	 xorpd	 xmm0, xmm0

; 2677 : }

  0002c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00030	41 5d		 pop	 r13
  00032	41 5c		 pop	 r12
  00034	5e		 pop	 rsi
  00035	c3		 ret	 0
$LN16@PyLong_Fre:

; 2586 :     }
; 2587 :     a_bits = bits_in_digit(a->ob_digit[a_size-1]);

  00036	8b 4c b1 6c	 mov	 ecx, DWORD PTR [rcx+rsi*4+108]
  0003a	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  0003f	e8 00 00 00 00	 call	 bits_in_digit
  00044	48 63 c8	 movsxd	 rcx, eax

; 2588 :     /* The following is an overflow-free version of the check
; 2589 :        "if ((a_size - 1) * PyLong_SHIFT + a_bits > PY_SSIZE_T_MAX) ..." */
; 2590 :     if (a_size >= (PY_SSIZE_T_MAX - 1) / PyLong_SHIFT + 1 &&
; 2591 :         (a_size > (PY_SSIZE_T_MAX - 1) / PyLong_SHIFT + 1 ||
; 2592 :          a_bits > (PY_SSIZE_T_MAX - 1) % PyLong_SHIFT + 1))

  00047	48 b8 45 44 44
	44 44 44 44 04	 mov	 rax, 307445734561825861	; 0444444444444445H
  00051	48 3b f0	 cmp	 rsi, rax
  00054	7c 10		 jl	 SHORT $LN15@PyLong_Fre
  00056	0f 8f 8d 01 00
	00		 jg	 $overflow$22167
  0005c	48 83 f9 07	 cmp	 rcx, 7

; 2593 :         goto overflow;

  00060	0f 8f 83 01 00
	00		 jg	 $overflow$22167
$LN15@PyLong_Fre:

; 2594 :     a_bits = (a_size - 1) * PyLong_SHIFT + a_bits;

  00066	48 8b c6	 mov	 rax, rsi
  00069	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0006e	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00073	48 6b c0 1e	 imul	 rax, 30
  00077	48 8d 6c 01 e2	 lea	 rbp, QWORD PTR [rcx+rax-30]

; 2595 : 
; 2596 :     /* Shift the first DBL_MANT_DIG + 2 bits of a into x_digits[0:x_size]
; 2597 :        (shifting left if a_bits <= DBL_MANT_DIG + 2).
; 2598 : 
; 2599 :        Number of digits needed for result: write // for floor division.
; 2600 :        Then if shifting left, we end up using
; 2601 : 
; 2602 :          1 + a_size + (DBL_MANT_DIG + 2 - a_bits) // PyLong_SHIFT
; 2603 : 
; 2604 :        digits.  If shifting right, we use
; 2605 : 
; 2606 :          a_size - (a_bits - DBL_MANT_DIG - 2) // PyLong_SHIFT
; 2607 : 
; 2608 :        digits.  Using a_size = 1 + (a_bits - 1) // PyLong_SHIFT along with
; 2609 :        the inequalities
; 2610 : 
; 2611 :          m // PyLong_SHIFT + n // PyLong_SHIFT <= (m + n) // PyLong_SHIFT
; 2612 :          m // PyLong_SHIFT - n // PyLong_SHIFT <=
; 2613 :                                           1 + (m - n - 1) // PyLong_SHIFT,
; 2614 : 
; 2615 :        valid for any integers m and n, we find that x_size satisfies
; 2616 : 
; 2617 :          x_size <= 2 + (DBL_MANT_DIG + 1) // PyLong_SHIFT
; 2618 : 
; 2619 :        in both cases.
; 2620 :     */
; 2621 :     if (a_bits <= DBL_MANT_DIG + 2) {
; 2622 :         shift_digits = (DBL_MANT_DIG + 2 - a_bits) / PyLong_SHIFT;

  0007c	48 b8 89 88 88
	88 88 88 88 88	 mov	 rax, -8608480567731124087 ; 8888888888888889H
  00086	48 83 fd 37	 cmp	 rbp, 55			; 00000037H
  0008a	7f 70		 jg	 SHORT $LN13@PyLong_Fre
  0008c	4c 89 74 24 68	 mov	 QWORD PTR [rsp+104], r14
  00091	41 be 37 00 00
	00		 mov	 r14d, 55		; 00000037H

; 2623 :         shift_bits = (DBL_MANT_DIG + 2 - a_bits) % PyLong_SHIFT;
; 2624 :         x_size = 0;

  00097	33 db		 xor	 ebx, ebx
  00099	4c 2b f5	 sub	 r14, rbp
  0009c	49 f7 ee	 imul	 r14
  0009f	49 8d 3c 16	 lea	 rdi, QWORD PTR [r14+rdx]
  000a3	48 c1 ff 04	 sar	 rdi, 4
  000a7	48 8b c7	 mov	 rax, rdi
  000aa	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  000ae	48 03 f8	 add	 rdi, rax
  000b1	48 8b c7	 mov	 rax, rdi
  000b4	48 6b c0 1e	 imul	 rax, 30
  000b8	4c 2b f0	 sub	 r14, rax

; 2625 :         while (x_size < shift_digits)

  000bb	48 85 ff	 test	 rdi, rdi
  000be	7e 16		 jle	 SHORT $LN12@PyLong_Fre

; 2595 : 
; 2596 :     /* Shift the first DBL_MANT_DIG + 2 bits of a into x_digits[0:x_size]
; 2597 :        (shifting left if a_bits <= DBL_MANT_DIG + 2).
; 2598 : 
; 2599 :        Number of digits needed for result: write // for floor division.
; 2600 :        Then if shifting left, we end up using
; 2601 : 
; 2602 :          1 + a_size + (DBL_MANT_DIG + 2 - a_bits) // PyLong_SHIFT
; 2603 : 
; 2604 :        digits.  If shifting right, we use
; 2605 : 
; 2606 :          a_size - (a_bits - DBL_MANT_DIG - 2) // PyLong_SHIFT
; 2607 : 
; 2608 :        digits.  Using a_size = 1 + (a_bits - 1) // PyLong_SHIFT along with
; 2609 :        the inequalities
; 2610 : 
; 2611 :          m // PyLong_SHIFT + n // PyLong_SHIFT <= (m + n) // PyLong_SHIFT
; 2612 :          m // PyLong_SHIFT - n // PyLong_SHIFT <=
; 2613 :                                           1 + (m - n - 1) // PyLong_SHIFT,
; 2614 : 
; 2615 :        valid for any integers m and n, we find that x_size satisfies
; 2616 : 
; 2617 :          x_size <= 2 + (DBL_MANT_DIG + 1) // PyLong_SHIFT
; 2618 : 
; 2619 :        in both cases.
; 2620 :     */
; 2621 :     if (a_bits <= DBL_MANT_DIG + 2) {
; 2622 :         shift_digits = (DBL_MANT_DIG + 2 - a_bits) / PyLong_SHIFT;

  000c0	4c 8b c7	 mov	 r8, rdi
  000c3	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x_digits$[rsp]
  000c8	33 d2		 xor	 edx, edx
  000ca	49 c1 e0 02	 shl	 r8, 2
  000ce	e8 00 00 00 00	 call	 memset

; 2625 :         while (x_size < shift_digits)

  000d3	48 8b df	 mov	 rbx, rdi
$LN12@PyLong_Fre:

; 2626 :             x_digits[x_size++] = 0;
; 2627 :         rem = v_lshift(x_digits + x_size, a->ob_digit, a_size,
; 2628 :                        (int)shift_bits);

  000d6	49 8d 54 24 70	 lea	 rdx, QWORD PTR [r12+112]
  000db	48 8d 4c 9c 20	 lea	 rcx, QWORD PTR x_digits$[rsp+rbx*4]
  000e0	45 8b ce	 mov	 r9d, r14d
  000e3	4c 8b c6	 mov	 r8, rsi
  000e6	e8 00 00 00 00	 call	 v_lshift
  000eb	4c 8b 74 24 68	 mov	 r14, QWORD PTR [rsp+104]

; 2629 :         x_size += a_size;

  000f0	48 03 de	 add	 rbx, rsi

; 2630 :         x_digits[x_size++] = rem;

  000f3	89 44 9c 20	 mov	 DWORD PTR x_digits$[rsp+rbx*4], eax
  000f7	48 ff c3	 inc	 rbx

; 2631 :     }
; 2632 :     else {

  000fa	eb 6c		 jmp	 SHORT $LN29@PyLong_Fre
$LN13@PyLong_Fre:

; 2633 :         shift_digits = (a_bits - DBL_MANT_DIG - 2) / PyLong_SHIFT;

  000fc	48 8d 4d c9	 lea	 rcx, QWORD PTR [rbp-55]

; 2634 :         shift_bits = (a_bits - DBL_MANT_DIG - 2) % PyLong_SHIFT;
; 2635 :         rem = v_rshift(x_digits, a->ob_digit + shift_digits,
; 2636 :                        a_size - shift_digits, (int)shift_bits);
; 2637 :         x_size = a_size - shift_digits;

  00100	48 8b de	 mov	 rbx, rsi
  00103	48 f7 e9	 imul	 rcx
  00106	48 8d 3c 11	 lea	 rdi, QWORD PTR [rcx+rdx]
  0010a	48 c1 ff 04	 sar	 rdi, 4
  0010e	48 8b c7	 mov	 rax, rdi
  00111	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00115	48 03 f8	 add	 rdi, rax
  00118	48 8b c7	 mov	 rax, rdi
  0011b	48 2b df	 sub	 rbx, rdi
  0011e	49 8d 74 bc 70	 lea	 rsi, QWORD PTR [r12+rdi*4+112]
  00123	4c 8b c3	 mov	 r8, rbx
  00126	48 8b d6	 mov	 rdx, rsi
  00129	48 6b c0 1e	 imul	 rax, 30
  0012d	48 2b c8	 sub	 rcx, rax
  00130	44 8b c9	 mov	 r9d, ecx
  00133	48 8d 4c 24 20	 lea	 rcx, QWORD PTR x_digits$[rsp]
  00138	e8 00 00 00 00	 call	 v_rshift

; 2638 :         /* For correct rounding below, we need the least significant
; 2639 :            bit of x to be 'sticky' for this shift: if any of the bits
; 2640 :            shifted out was nonzero, we set the least significant bit
; 2641 :            of x. */
; 2642 :         if (rem)

  0013d	85 c0		 test	 eax, eax

; 2643 :             x_digits[0] |= 1;
; 2644 :         else

  0013f	75 22		 jne	 SHORT $LN26@PyLong_Fre

; 2645 :             while (shift_digits > 0)

  00141	48 85 ff	 test	 rdi, rdi
  00144	7e 22		 jle	 SHORT $LN29@PyLong_Fre
  00146	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL7@PyLong_Fre:

; 2646 :                 if (a->ob_digit[--shift_digits]) {

  00150	48 83 ee 04	 sub	 rsi, 4
  00154	48 ff cf	 dec	 rdi
  00157	83 3e 00	 cmp	 DWORD PTR [rsi], 0
  0015a	75 07		 jne	 SHORT $LN26@PyLong_Fre

; 2645 :             while (shift_digits > 0)

  0015c	48 85 ff	 test	 rdi, rdi
  0015f	7f ef		 jg	 SHORT $LL7@PyLong_Fre

; 2646 :                 if (a->ob_digit[--shift_digits]) {

  00161	eb 05		 jmp	 SHORT $LN29@PyLong_Fre
$LN26@PyLong_Fre:

; 2647 :                     x_digits[0] |= 1;

  00163	83 4c 24 20 01	 or	 DWORD PTR x_digits$[rsp], 1
$LN29@PyLong_Fre:

; 2648 :                     break;
; 2649 :                 }
; 2650 :     }
; 2651 :     assert(1 <= x_size && x_size <= (Py_ssize_t)Py_ARRAY_LENGTH(x_digits));
; 2652 : 
; 2653 :     /* Round, and convert to double. */
; 2654 :     x_digits[0] += half_even_correction[x_digits[0] & 7];

  00168	48 8b 44 24 20	 mov	 rax, QWORD PTR x_digits$[rsp]
  0016d	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]

; 2655 :     dx = x_digits[--x_size];

  00172	48 ff cb	 dec	 rbx
  00175	66 0f ef c9	 pxor	 xmm1, xmm1
  00179	83 e0 07	 and	 eax, 7
  0017c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?half_even_correction@?1??_PyLong_Frexp@@9@9
  00183	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00186	01 44 24 20	 add	 DWORD PTR x_digits$[rsp], eax
  0018a	8b 44 9c 20	 mov	 eax, DWORD PTR x_digits$[rsp+rbx*4]
  0018e	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax

; 2656 :     while (x_size > 0)

  00193	48 85 db	 test	 rbx, rbx
  00196	7e 29		 jle	 SHORT $LN3@PyLong_Fre
  00198	f2 0f 10 15 00
	00 00 00	 movsdx	 xmm2, QWORD PTR __real@41d0000000000000
$LL4@PyLong_Fre:

; 2657 :         dx = dx * PyLong_BASE + x_digits[--x_size];

  001a0	8b 44 9c 1c	 mov	 eax, DWORD PTR x_digits$[rsp+rbx*4-4]
  001a4	48 ff cb	 dec	 rbx
  001a7	66 0f ef c0	 pxor	 xmm0, xmm0
  001ab	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  001af	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  001b4	f2 0f 58 c1	 addsd	 xmm0, xmm1
  001b8	66 0f 28 c8	 movapd	 xmm1, xmm0
  001bc	48 85 db	 test	 rbx, rbx
  001bf	7f df		 jg	 SHORT $LL4@PyLong_Fre
$LN3@PyLong_Fre:

; 2658 : 
; 2659 :     /* Rescale;  make correction if result is 1.0. */
; 2660 :     dx /= 4.0 * EXP2_DBL_MANT_DIG;

  001c1	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3c80000000000000
  001c9	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 2661 :     if (dx == 1.0) {

  001ce	66 0f 2e 0d 00
	00 00 00	 ucomisd xmm1, QWORD PTR __real@3ff0000000000000
  001d6	7a 4e		 jp	 SHORT $LN2@PyLong_Fre
  001d8	75 4c		 jne	 SHORT $LN2@PyLong_Fre

; 2662 :         if (a_bits == PY_SSIZE_T_MAX)

  001da	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  001e4	48 3b e8	 cmp	 rbp, rax
  001e7	75 32		 jne	 SHORT $LN1@PyLong_Fre
$overflow$22167:

; 2670 : 
; 2671 :   overflow:
; 2672 :     /* exponent > PY_SSIZE_T_MAX */
; 2673 :     PyErr_SetString(PyExc_OverflowError,
; 2674 :                     "huge integer: number of bits overflows a Py_ssize_t");

  001e9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  001f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@KPOPPGPJ@huge?5integer?3?5number?5of?5bits?5ove@
  001f7	e8 00 00 00 00	 call	 PyErr_SetString
  001fc	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]

; 2675 :     *e = 0;

  00201	49 c7 45 00 00
	00 00 00	 mov	 QWORD PTR [r13], 0

; 2676 :     return -1.0;

  00209	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000

; 2677 : }

  00211	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00215	41 5d		 pop	 r13
  00217	41 5c		 pop	 r12
  00219	5e		 pop	 rsi
  0021a	c3		 ret	 0
$LN1@PyLong_Fre:

; 2663 :             goto overflow;
; 2664 :         dx = 0.5;

  0021b	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@3fe0000000000000

; 2665 :         a_bits += 1;

  00223	48 ff c5	 inc	 rbp
$LN2@PyLong_Fre:

; 2666 :     }
; 2667 : 
; 2668 :     *e = a_bits;

  00226	49 89 6d 00	 mov	 QWORD PTR [r13], rbp

; 2669 :     return Py_SIZE(a) < 0 ? -dx : dx;

  0022a	49 83 7c 24 60
	00		 cmp	 QWORD PTR [r12+96], 0
  00230	7d 08		 jge	 SHORT $LN21@PyLong_Fre
  00232	66 0f 57 0d 00
	00 00 00	 xorpd	 xmm1, QWORD PTR __mask@@NegDouble@
$LN21@PyLong_Fre:
  0023a	66 0f 28 c1	 movapd	 xmm0, xmm1
  0023e	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]

; 2677 : }

  00243	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00247	41 5d		 pop	 r13
  00249	41 5c		 pop	 r12
  0024b	5e		 pop	 rsi
  0024c	c3		 ret	 0
_PyLong_Frexp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@DONHKOON@long?5int?5too?5large?5to?5convert?5to@ ; `string'
PUBLIC	PyLong_AsDouble
EXTRN	PyErr_Occurred:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsDouble DD imagerel $LN9
	DD	imagerel $LN9+92
	DD	imagerel $unwind$PyLong_AsDouble
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyLong_AsDouble DD imagerel $LN9+92
	DD	imagerel $LN9+178
	DD	imagerel $chain$0$PyLong_AsDouble
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyLong_AsDouble DD imagerel $LN9+178
	DD	imagerel $LN9+200
	DD	imagerel $chain$2$PyLong_AsDouble
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyLong_AsDouble DD 020021H
	DD	027800H
	DD	imagerel $LN9
	DD	imagerel $LN9+92
	DD	imagerel $unwind$PyLong_AsDouble
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyLong_AsDouble DD 020521H
	DD	027805H
	DD	imagerel $LN9
	DD	imagerel $LN9+92
	DD	imagerel $unwind$PyLong_AsDouble
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsDouble DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0CH@DONHKOON@long?5int?5too?5large?5to?5convert?5to@
CONST	SEGMENT
??_C@_0CH@DONHKOON@long?5int?5too?5large?5to?5convert?5to@ DB 'long int t'
	DB	'oo large to convert to float', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyLong_AsDouble
_TEXT	SEGMENT
exponent$ = 64
v$ = 64
PyLong_AsDouble PROC					; COMDAT

; 2684 : {

$LN9:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2685 :     Py_ssize_t exponent;
; 2686 :     double x;
; 2687 : 
; 2688 :     if (v == NULL) {

  00004	48 85 c9	 test	 rcx, rcx
  00007	75 1e		 jne	 SHORT $LN5@PyLong_AsD

; 2689 :         PyErr_BadInternalCall();

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00010	ba 81 0a 00 00	 mov	 edx, 2689		; 00000a81H
  00015	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2690 :         return -1.0;

  0001a	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000

; 2703 : }

  00022	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00026	c3		 ret	 0
$LN5@PyLong_AsD:

; 2691 :     }
; 2692 :     if (!PyLong_Check(v)) {

  00027	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0002b	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00035	75 20		 jne	 SHORT $LN4@PyLong_AsD

; 2693 :         PyErr_SetString(PyExc_TypeError, "an integer is required");

  00037	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
  00045	e8 00 00 00 00	 call	 PyErr_SetString

; 2694 :         return -1.0;

  0004a	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000

; 2703 : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
$LN4@PyLong_AsD:

; 2695 :     }
; 2696 :     x = _PyLong_Frexp((PyLongObject *)v, &exponent);

  00057	48 8d 54 24 40	 lea	 rdx, QWORD PTR exponent$[rsp]
  0005c	0f 29 7c 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm7
  00061	e8 00 00 00 00	 call	 _PyLong_Frexp

; 2697 :     if ((x == -1.0 && PyErr_Occurred()) || exponent > DBL_MAX_EXP) {

  00066	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0006e	66 0f 28 f8	 movapd	 xmm7, xmm0
  00072	7a 0c		 jp	 SHORT $LN1@PyLong_AsD
  00074	75 0a		 jne	 SHORT $LN1@PyLong_AsD
  00076	e8 00 00 00 00	 call	 PyErr_Occurred
  0007b	48 85 c0	 test	 rax, rax
  0007e	75 0d		 jne	 SHORT $LN2@PyLong_AsD
$LN1@PyLong_AsD:
  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR exponent$[rsp]
  00085	48 3d 00 04 00
	00		 cmp	 rax, 1024		; 00000400H
  0008b	7e 25		 jle	 SHORT $LN3@PyLong_AsD
$LN2@PyLong_AsD:

; 2698 :         PyErr_SetString(PyExc_OverflowError,
; 2699 :                         "long int too large to convert to float");

  0008d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@DONHKOON@long?5int?5too?5large?5to?5convert?5to@
  0009b	e8 00 00 00 00	 call	 PyErr_SetString

; 2700 :         return -1.0;

  000a0	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  000a8	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]

; 2703 : }

  000ad	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b1	c3		 ret	 0
$LN3@PyLong_AsD:

; 2701 :     }
; 2702 :     return ldexp(x, (int)exponent);

  000b2	66 0f 28 c7	 movapd	 xmm0, xmm7
  000b6	8b d0		 mov	 edx, eax
  000b8	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]

; 2703 : }

  000bd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c1	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_ldexp
PyLong_AsDouble ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT long_dealloc
_TEXT	SEGMENT
v$ = 8
long_dealloc PROC					; COMDAT

; 2710 :     Py_TYPE(v)->tp_free(v);

  00000	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]

; 2711 : }

  00004	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
long_dealloc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_compare DD imagerel long_compare
	DD	imagerel long_compare+133
	DD	imagerel $unwind$long_compare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_compare DD 020501H
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT long_compare
_TEXT	SEGMENT
a$ = 8
b$ = 16
long_compare PROC					; COMDAT

; 2715 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 2716 :     Py_ssize_t sign;
; 2717 : 
; 2718 :     if (Py_SIZE(a) != Py_SIZE(b)) {

  00005	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  00009	48 8b 42 60	 mov	 rax, QWORD PTR [rdx+96]
  0000d	45 33 d2	 xor	 r10d, r10d
  00010	4c 8b da	 mov	 r11, rdx
  00013	48 8b d9	 mov	 rbx, rcx
  00016	4c 3b c0	 cmp	 r8, rax
  00019	74 08		 je	 SHORT $LN7@long_compa

; 2719 :         sign = Py_SIZE(a) - Py_SIZE(b);

  0001b	4c 2b c0	 sub	 r8, rax
  0001e	49 8b c0	 mov	 rax, r8

; 2720 :     }
; 2721 :     else {

  00021	eb 41		 jmp	 SHORT $LN1@long_compa
$LN7@long_compa:

; 2722 :         Py_ssize_t i = ABS(Py_SIZE(a));

  00023	49 8b c8	 mov	 rcx, r8
  00026	4d 85 c0	 test	 r8, r8
  00029	79 03		 jns	 SHORT $LN17@long_compa
  0002b	48 f7 d9	 neg	 rcx
$LN17@long_compa:

; 2723 :         while (--i >= 0 && a->ob_digit[i] == b->ob_digit[i])

  0002e	4c 8b cb	 mov	 r9, rbx
  00031	48 8d 54 8a 70	 lea	 rdx, QWORD PTR [rdx+rcx*4+112]
  00036	4d 2b cb	 sub	 r9, r11
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@long_compa:
  00040	48 83 ea 04	 sub	 rdx, 4
  00044	48 ff c9	 dec	 rcx
  00047	78 29		 js	 SHORT $LN15@long_compa
  00049	8b 02		 mov	 eax, DWORD PTR [rdx]
  0004b	41 39 04 11	 cmp	 DWORD PTR [r9+rdx], eax
  0004f	74 ef		 je	 SHORT $LL5@long_compa

; 2727 :         else {
; 2728 :             sign = (sdigit)a->ob_digit[i] - (sdigit)b->ob_digit[i];

  00051	8b 44 8b 70	 mov	 eax, DWORD PTR [rbx+rcx*4+112]
  00055	41 2b 44 8b 70	 sub	 eax, DWORD PTR [r11+rcx*4+112]
  0005a	48 98		 cdqe

; 2729 :             if (Py_SIZE(a) < 0)

  0005c	4d 85 c0	 test	 r8, r8
  0005f	79 03		 jns	 SHORT $LN1@long_compa

; 2730 :                 sign = -sign;

  00061	48 f7 d8	 neg	 rax
$LN1@long_compa:

; 2731 :         }
; 2732 :     }
; 2733 :     return sign < 0 ? -1 : sign > 0 ? 1 : 0;

  00064	48 85 c0	 test	 rax, rax
  00067	79 0f		 jns	 SHORT $LN18@long_compa
  00069	83 c8 ff	 or	 eax, -1

; 2734 : }

  0006c	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00071	c3		 ret	 0
$LN15@long_compa:

; 2724 :             ;
; 2725 :         if (i < 0)
; 2726 :             sign = 0;

  00072	49 8b c2	 mov	 rax, r10

; 2731 :         }
; 2732 :     }
; 2733 :     return sign < 0 ? -1 : sign > 0 ? 1 : 0;

  00075	48 85 c0	 test	 rax, rax
$LN18@long_compa:

; 2734 : }

  00078	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0007d	41 0f 9f c2	 setg	 r10b
  00081	41 8b c2	 mov	 eax, r10d
  00084	c3		 ret	 0
long_compare ENDP
_TEXT	ENDS
EXTRN	_Py_NotImplementedStruct:BYTE
EXTRN	PyErr_BadArgument:PROC
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_richcompare DD imagerel long_richcompare
	DD	imagerel long_richcompare+372
	DD	imagerel $unwind$long_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_richcompare DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT long_richcompare
_TEXT	SEGMENT
self$ = 64
other$ = 72
op$ = 80
long_richcompare PROC					; COMDAT

; 2741 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2742 :     int result;
; 2743 :     PyObject *v;
; 2744 :     CHECK_BINOP(self, other);

  00006	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000a	49 63 d8	 movsxd	 rbx, r8d
  0000d	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00017	0f 84 ea 00 00
	00		 je	 $LN12@long_richc
  0001d	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00021	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0002b	0f 84 d6 00 00
	00		 je	 $LN12@long_richc

; 2745 :     if (self == other)

  00031	48 3b ca	 cmp	 rcx, rdx
  00034	75 04		 jne	 SHORT $LN11@long_richc

; 2746 :         result = 0;

  00036	33 c0		 xor	 eax, eax

; 2747 :     else

  00038	eb 05		 jmp	 SHORT $LN10@long_richc
$LN11@long_richc:

; 2748 :         result = long_compare((PyLongObject*)self, (PyLongObject*)other);

  0003a	e8 00 00 00 00	 call	 long_compare
$LN10@long_richc:

; 2749 :     /* Convert the return value to a Boolean */
; 2750 :     switch (op) {

  0003f	83 fb 05	 cmp	 ebx, 5
  00042	0f 87 b2 00 00
	00		 ja	 $LN1@long_richc
  00048	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  0004f	41 8b 94 98 00
	00 00 00	 mov	 edx, DWORD PTR $LN23@long_richc[r8+rbx*4]
  00057	49 03 d0	 add	 rdx, r8
  0005a	ff e2		 jmp	 rdx
$LN7@long_richc:

; 2751 :     case Py_EQ:
; 2752 :         v = TEST_COND(result == 0);

  0005c	85 c0		 test	 eax, eax

; 2753 :         break;

  0005e	eb 77		 jmp	 SHORT $LN24@long_richc
$LN6@long_richc:

; 2754 :     case Py_NE:
; 2755 :         v = TEST_COND(result != 0);

  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00067	85 c0		 test	 eax, eax
  00069	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  00070	48 0f 45 d9	 cmovne	 rbx, rcx

; 2772 :     }
; 2773 :     Py_INCREF(v);

  00074	48 8b cb	 mov	 rcx, rbx
  00077	e8 00 00 00 00	 call	 _Py_IncRef

; 2774 :     return v;

  0007c	48 8b c3	 mov	 rax, rbx

; 2775 : }

  0007f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00083	5b		 pop	 rbx
  00084	c3		 ret	 0
$LN5@long_richc:

; 2756 :         break;
; 2757 :     case Py_LE:
; 2758 :         v = TEST_COND(result <= 0);

  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  0008c	85 c0		 test	 eax, eax
  0008e	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  00095	48 0f 4e d9	 cmovle	 rbx, rcx

; 2772 :     }
; 2773 :     Py_INCREF(v);

  00099	48 8b cb	 mov	 rcx, rbx
  0009c	e8 00 00 00 00	 call	 _Py_IncRef

; 2774 :     return v;

  000a1	48 8b c3	 mov	 rax, rbx

; 2775 : }

  000a4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a8	5b		 pop	 rbx
  000a9	c3		 ret	 0
$LN4@long_richc:

; 2759 :         break;
; 2760 :     case Py_GE:
; 2761 :         v = TEST_COND(result >= 0);

  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  000b1	85 c0		 test	 eax, eax
  000b3	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  000ba	48 0f 49 d9	 cmovns	 rbx, rcx

; 2772 :     }
; 2773 :     Py_INCREF(v);

  000be	48 8b cb	 mov	 rcx, rbx
  000c1	e8 00 00 00 00	 call	 _Py_IncRef

; 2774 :     return v;

  000c6	48 8b c3	 mov	 rax, rbx

; 2775 : }

  000c9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cd	5b		 pop	 rbx
  000ce	c3		 ret	 0
$LN3@long_richc:

; 2762 :         break;
; 2763 :     case Py_LT:
; 2764 :         v = TEST_COND(result == -1);

  000cf	83 f8 ff	 cmp	 eax, -1

; 2765 :         break;

  000d2	eb 03		 jmp	 SHORT $LN24@long_richc
$LN2@long_richc:

; 2766 :     case Py_GT:
; 2767 :         v = TEST_COND(result == 1);

  000d4	83 f8 01	 cmp	 eax, 1
$LN24@long_richc:
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  000de	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  000e5	48 0f 44 d9	 cmove	 rbx, rcx

; 2772 :     }
; 2773 :     Py_INCREF(v);

  000e9	48 8b cb	 mov	 rcx, rbx
  000ec	e8 00 00 00 00	 call	 _Py_IncRef

; 2774 :     return v;

  000f1	48 8b c3	 mov	 rax, rbx

; 2775 : }

  000f4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f8	5b		 pop	 rbx
  000f9	c3		 ret	 0
$LN1@long_richc:

; 2768 :         break;
; 2769 :     default:
; 2770 :         PyErr_BadArgument();

  000fa	e8 00 00 00 00	 call	 PyErr_BadArgument

; 2771 :         return NULL;

  000ff	33 c0		 xor	 eax, eax

; 2775 : }

  00101	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00105	5b		 pop	 rbx
  00106	c3		 ret	 0
$LN12@long_richc:

; 2742 :     int result;
; 2743 :     PyObject *v;
; 2744 :     CHECK_BINOP(self, other);

  00107	e8 00 00 00 00	 call	 _Py_PXCTX
  0010c	85 c0		 test	 eax, eax
  0010e	75 3c		 jne	 SHORT $LN20@long_richc
  00110	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00117	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0011e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00125	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0012b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00133	e8 00 00 00 00	 call	 _PyParallel_Guard
  00138	85 c0		 test	 eax, eax
  0013a	75 09		 jne	 SHORT $LN19@long_richc
  0013c	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00143	74 07		 je	 SHORT $LN20@long_richc
$LN19@long_richc:
  00145	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN20@long_richc:
  0014c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 2775 : }

  00153	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00157	5b		 pop	 rbx
  00158	c3		 ret	 0
  00159	0f 1f 00	 npad	 3
$LN23@long_richc:
  0015c	00 00 00 00	 DD	 $LN3@long_richc
  00160	00 00 00 00	 DD	 $LN5@long_richc
  00164	00 00 00 00	 DD	 $LN7@long_richc
  00168	00 00 00 00	 DD	 $LN6@long_richc
  0016c	00 00 00 00	 DD	 $LN2@long_richc
  00170	00 00 00 00	 DD	 $LN4@long_richc
long_richcompare ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT long_hash
_TEXT	SEGMENT
v$ = 8
long_hash PROC						; COMDAT

; 2780 :     Py_uhash_t x;
; 2781 :     Py_ssize_t i;
; 2782 :     int sign;
; 2783 : 
; 2784 :     i = Py_SIZE(v);

  00000	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]

; 2785 :     switch(i) {

  00004	48 83 fa ff	 cmp	 rdx, -1
  00008	0f 84 84 00 00
	00		 je	 $LN8@long_hash
  0000e	48 85 d2	 test	 rdx, rdx
  00011	74 7c		 je	 SHORT $LN7@long_hash
  00013	48 83 fa 01	 cmp	 rdx, 1
  00017	74 72		 je	 SHORT $LN6@long_hash

; 2789 :     }
; 2790 :     sign = 1;
; 2791 :     x = 0;

  00019	45 33 c0	 xor	 r8d, r8d
  0001c	41 ba 01 00 00
	00		 mov	 r10d, 1

; 2792 :     if (i < 0) {

  00022	48 85 d2	 test	 rdx, rdx
  00025	79 07		 jns	 SHORT $LN15@long_hash

; 2793 :         sign = -1;

  00027	41 83 ca ff	 or	 r10d, -1

; 2794 :         i = -(i);

  0002b	48 f7 da	 neg	 rdx
$LN15@long_hash:

; 2795 :     }
; 2796 :     while (--i >= 0) {

  0002e	48 ff ca	 dec	 rdx
  00031	78 3e		 js	 SHORT $LN3@long_hash
  00033	4c 8d 4c 91 70	 lea	 r9, QWORD PTR [rcx+rdx*4+112]
  00038	49 bb ff ff ff
	ff ff ff ff 1f	 mov	 r11, 2305843009213693951 ; 1fffffffffffffffH
$LL4@long_hash:

; 2797 :         /* Here x is a quantity in the range [0, _PyHASH_MODULUS); we
; 2798 :            want to compute x * 2**PyLong_SHIFT + v->ob_digit[i] modulo
; 2799 :            _PyHASH_MODULUS.
; 2800 : 
; 2801 :            The computation of x * 2**PyLong_SHIFT % _PyHASH_MODULUS
; 2802 :            amounts to a rotation of the bits of x.  To see this, write
; 2803 : 
; 2804 :              x * 2**PyLong_SHIFT = y * 2**_PyHASH_BITS + z
; 2805 : 
; 2806 :            where y = x >> (_PyHASH_BITS - PyLong_SHIFT) gives the top
; 2807 :            PyLong_SHIFT bits of x (those that are shifted out of the
; 2808 :            original _PyHASH_BITS bits, and z = (x << PyLong_SHIFT) &
; 2809 :            _PyHASH_MODULUS gives the bottom _PyHASH_BITS - PyLong_SHIFT
; 2810 :            bits of x, shifted up.  Then since 2**_PyHASH_BITS is
; 2811 :            congruent to 1 modulo _PyHASH_MODULUS, y*2**_PyHASH_BITS is
; 2812 :            congruent to y modulo _PyHASH_MODULUS.  So
; 2813 : 
; 2814 :              x * 2**PyLong_SHIFT = y + z (mod _PyHASH_MODULUS).
; 2815 : 
; 2816 :            The right-hand side is just the result of rotating the
; 2817 :            _PyHASH_BITS bits of x left by PyLong_SHIFT places; since
; 2818 :            not all _PyHASH_BITS bits of x are 1s, the same is true
; 2819 :            after rotation, so 0 <= y+z < _PyHASH_MODULUS and y + z is
; 2820 :            the reduction of x*2**PyLong_SHIFT modulo
; 2821 :            _PyHASH_MODULUS. */
; 2822 :         x = ((x << PyLong_SHIFT) & _PyHASH_MODULUS) |
; 2823 :             (x >> (_PyHASH_BITS - PyLong_SHIFT));
; 2824 :         x += v->ob_digit[i];

  00042	49 8b c8	 mov	 rcx, r8
  00045	49 8b c0	 mov	 rax, r8
  00048	48 c1 e8 1f	 shr	 rax, 31
  0004c	0f ba f1 1f	 btr	 ecx, 31
  00050	48 c1 e1 1e	 shl	 rcx, 30
  00054	4c 8b c1	 mov	 r8, rcx
  00057	4c 0b c0	 or	 r8, rax
  0005a	41 8b 01	 mov	 eax, DWORD PTR [r9]
  0005d	4c 03 c0	 add	 r8, rax

; 2825 :         if (x >= _PyHASH_MODULUS)

  00060	4d 3b c3	 cmp	 r8, r11
  00063	72 03		 jb	 SHORT $LN2@long_hash

; 2826 :             x -= _PyHASH_MODULUS;

  00065	4d 2b c3	 sub	 r8, r11
$LN2@long_hash:

; 2795 :     }
; 2796 :     while (--i >= 0) {

  00068	49 83 e9 04	 sub	 r9, 4
  0006c	48 ff ca	 dec	 rdx
  0006f	79 d1		 jns	 SHORT $LL4@long_hash
$LN3@long_hash:

; 2827 :     }
; 2828 :     x = x * sign;
; 2829 :     if (x == (Py_uhash_t)-1)

  00071	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  00078	49 63 ca	 movsxd	 rcx, r10d
  0007b	4c 0f af c1	 imul	 r8, rcx
  0007f	49 83 f8 ff	 cmp	 r8, -1
  00083	4c 0f 44 c0	 cmove	 r8, rax

; 2830 :         x = (Py_uhash_t)-2;
; 2831 :     return (Py_hash_t)x;

  00087	49 8b c0	 mov	 rax, r8

; 2832 : }

  0008a	c3		 ret	 0
$LN6@long_hash:

; 2788 :     case 1: return v->ob_digit[0];

  0008b	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]

; 2832 : }

  0008e	c3		 ret	 0
$LN7@long_hash:

; 2787 :     case 0: return 0;

  0008f	33 c0		 xor	 eax, eax

; 2832 : }

  00091	c3		 ret	 0
$LN8@long_hash:

; 2786 :     case -1: return v->ob_digit[0]==1 ? -2 : -(sdigit)v->ob_digit[0];

  00092	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00095	83 f8 01	 cmp	 eax, 1
  00098	75 0a		 jne	 SHORT $LN13@long_hash
  0009a	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  000a1	48 98		 cdqe

; 2832 : }

  000a3	c3		 ret	 0
$LN13@long_hash:

; 2786 :     case -1: return v->ob_digit[0]==1 ? -2 : -(sdigit)v->ob_digit[0];

  000a4	f7 d8		 neg	 eax
  000a6	48 98		 cdqe

; 2832 : }

  000a8	c3		 ret	 0
long_hash ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$x_add DD	imagerel x_add
	DD	imagerel x_add+245
	DD	imagerel $unwind$x_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$x_add DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT x_add
_TEXT	SEGMENT
a$ = 48
b$ = 56
x_add	PROC						; COMDAT

; 2839 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2840 :     Py_ssize_t size_a = ABS(Py_SIZE(a)), size_b = ABS(Py_SIZE(b));

  0001a	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]
  0001e	4c 8b e2	 mov	 r12, rdx
  00021	48 8b e9	 mov	 rbp, rcx
  00024	48 85 ff	 test	 rdi, rdi
  00027	79 03		 jns	 SHORT $LN11@x_add
  00029	48 f7 df	 neg	 rdi
$LN11@x_add:
  0002c	48 8b 72 60	 mov	 rsi, QWORD PTR [rdx+96]
  00030	48 85 f6	 test	 rsi, rsi
  00033	79 03		 jns	 SHORT $LN13@x_add
  00035	48 f7 de	 neg	 rsi
$LN13@x_add:

; 2841 :     PyLongObject *z;
; 2842 :     Py_ssize_t i;
; 2843 :     digit carry = 0;

  00038	33 db		 xor	 ebx, ebx

; 2844 : 
; 2845 :     /* Ensure a is the larger of the two: */
; 2846 :     if (size_a < size_b) {

  0003a	48 3b fe	 cmp	 rdi, rsi
  0003d	7d 0f		 jge	 SHORT $LN8@x_add

; 2847 :         { PyLongObject *temp = a; a = b; b = temp; }
; 2848 :         { Py_ssize_t size_temp = size_a;

  0003f	48 8b c7	 mov	 rax, rdi

; 2849 :             size_a = size_b;

  00042	48 8b fe	 mov	 rdi, rsi
  00045	48 8b ea	 mov	 rbp, rdx

; 2850 :             size_b = size_temp; }

  00048	48 8b f0	 mov	 rsi, rax
  0004b	4c 8b e1	 mov	 r12, rcx
$LN8@x_add:

; 2851 :     }
; 2852 :     z = _PyLong_New(size_a+1);

  0004e	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
  00052	e8 00 00 00 00	 call	 _PyLong_New
  00057	4c 8b d8	 mov	 r11, rax

; 2853 :     if (z == NULL)

  0005a	48 85 c0	 test	 rax, rax
  0005d	74 7b		 je	 SHORT $LN9@x_add
$LN7@x_add:

; 2854 :         return NULL;
; 2855 :     for (i = 0; i < size_b; ++i) {

  0005f	48 8b d3	 mov	 rdx, rbx
  00062	48 85 f6	 test	 rsi, rsi
  00065	7e 3a		 jle	 SHORT $LN4@x_add
  00067	4c 8b c5	 mov	 r8, rbp
  0006a	4c 8b c8	 mov	 r9, rax
  0006d	49 8d 4c 24 70	 lea	 rcx, QWORD PTR [r12+112]
  00072	4d 2b c4	 sub	 r8, r12
  00075	4d 2b cc	 sub	 r9, r12
  00078	48 8b d6	 mov	 rdx, rsi
  0007b	0f 1f 44 00 00	 npad	 5
$LL6@x_add:

; 2856 :         carry += a->ob_digit[i] + b->ob_digit[i];

  00080	41 8b 04 08	 mov	 eax, DWORD PTR [r8+rcx]
  00084	48 83 c1 04	 add	 rcx, 4
  00088	03 41 fc	 add	 eax, DWORD PTR [rcx-4]
  0008b	03 d8		 add	 ebx, eax

; 2857 :         z->ob_digit[i] = carry & PyLong_MASK;

  0008d	8b c3		 mov	 eax, ebx

; 2858 :         carry >>= PyLong_SHIFT;

  0008f	c1 eb 1e	 shr	 ebx, 30
  00092	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00097	48 ff ce	 dec	 rsi
  0009a	41 89 44 09 fc	 mov	 DWORD PTR [r9+rcx-4], eax
  0009f	75 df		 jne	 SHORT $LL6@x_add
$LN4@x_add:

; 2859 :     }
; 2860 :     for (; i < size_a; ++i) {

  000a1	48 3b d7	 cmp	 rdx, rdi
  000a4	7d 27		 jge	 SHORT $LN1@x_add
  000a6	48 2b fa	 sub	 rdi, rdx
  000a9	49 8d 4c 93 70	 lea	 rcx, QWORD PTR [r11+rdx*4+112]
  000ae	49 2b eb	 sub	 rbp, r11
  000b1	48 03 d7	 add	 rdx, rdi
$LL3@x_add:

; 2861 :         carry += a->ob_digit[i];

  000b4	03 1c 29	 add	 ebx, DWORD PTR [rcx+rbp]
  000b7	48 83 c1 04	 add	 rcx, 4

; 2862 :         z->ob_digit[i] = carry & PyLong_MASK;

  000bb	8b c3		 mov	 eax, ebx

; 2863 :         carry >>= PyLong_SHIFT;

  000bd	c1 eb 1e	 shr	 ebx, 30
  000c0	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  000c5	48 ff cf	 dec	 rdi
  000c8	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  000cb	75 e7		 jne	 SHORT $LL3@x_add
$LN1@x_add:

; 2864 :     }
; 2865 :     z->ob_digit[i] = carry;
; 2866 :     return long_normalize(z);

  000cd	49 8b cb	 mov	 rcx, r11
  000d0	41 89 5c 93 70	 mov	 DWORD PTR [r11+rdx*4+112], ebx
  000d5	e8 00 00 00 00	 call	 long_normalize
$LN9@x_add:

; 2867 : }

  000da	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000df	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000e4	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000e9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000ee	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f2	41 5c		 pop	 r12
  000f4	c3		 ret	 0
x_add	ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$x_sub DD	imagerel x_sub
	DD	imagerel x_sub+92
	DD	imagerel $unwind$x_sub
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$x_sub DD imagerel x_sub+92
	DD	imagerel x_sub+115
	DD	imagerel $chain$0$x_sub
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$x_sub DD imagerel x_sub+115
	DD	imagerel x_sub+190
	DD	imagerel $chain$1$x_sub
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$x_sub DD imagerel x_sub+190
	DD	imagerel x_sub+492
	DD	imagerel $chain$2$x_sub
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$x_sub DD imagerel x_sub+492
	DD	imagerel x_sub+516
	DD	imagerel $chain$3$x_sub
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$x_sub DD 021H
	DD	imagerel x_sub
	DD	imagerel x_sub+92
	DD	imagerel $unwind$x_sub
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$x_sub DD 020021H
	DD	0c7400H
	DD	imagerel x_sub
	DD	imagerel x_sub+92
	DD	imagerel $unwind$x_sub
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$x_sub DD 021H
	DD	imagerel x_sub
	DD	imagerel x_sub+92
	DD	imagerel $unwind$x_sub
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$x_sub DD 020521H
	DD	0c7405H
	DD	imagerel x_sub
	DD	imagerel x_sub+92
	DD	imagerel $unwind$x_sub
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$x_sub DD 0a1701H
	DD	0e5417H
	DD	0d3417H
	DD	0f0135217H
	DD	0d00fe011H
	DD	0600bc00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT x_sub
_TEXT	SEGMENT
a$ = 96
b$ = 104
x_sub	PROC						; COMDAT

; 2873 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2874 :     Py_ssize_t size_a = ABS(Py_SIZE(a)), size_b = ABS(Py_SIZE(b));

  00017	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  0001b	4c 8b ea	 mov	 r13, rdx
  0001e	4c 8b e1	 mov	 r12, rcx
  00021	48 85 db	 test	 rbx, rbx
  00024	79 03		 jns	 SHORT $LN23@x_sub
  00026	48 f7 db	 neg	 rbx
$LN23@x_sub:
  00029	48 8b 6a 60	 mov	 rbp, QWORD PTR [rdx+96]
  0002d	48 85 ed	 test	 rbp, rbp
  00030	79 03		 jns	 SHORT $LN25@x_sub
  00032	48 f7 dd	 neg	 rbp
$LN25@x_sub:

; 2875 :     PyLongObject *z;
; 2876 :     Py_ssize_t i;
; 2877 :     int sign = 1;
; 2878 :     digit borrow = 0;

  00035	45 33 f6	 xor	 r14d, r14d
  00038	41 bf 01 00 00
	00		 mov	 r15d, 1
  0003e	41 8b f6	 mov	 esi, r14d

; 2879 : 
; 2880 :     /* Ensure a is the larger of the two: */
; 2881 :     if (size_a < size_b) {

  00041	48 3b dd	 cmp	 rbx, rbp
  00044	7d 2d		 jge	 SHORT $LN49@x_sub

; 2882 :         sign = -1;
; 2883 :         { PyLongObject *temp = a; a = b; b = temp; }
; 2884 :         { Py_ssize_t size_temp = size_a;

  00046	48 8b c3	 mov	 rax, rbx

; 2885 :             size_a = size_b;

  00049	48 8b dd	 mov	 rbx, rbp
  0004c	41 83 cf ff	 or	 r15d, -1
  00050	4c 8b e2	 mov	 r12, rdx
  00053	4c 8b e9	 mov	 r13, rcx

; 2886 :             size_b = size_temp; }

  00056	48 8b e8	 mov	 rbp, rax
$LN18@x_sub:

; 2900 :     }
; 2901 :     z = _PyLong_New(size_a);

  00059	48 8b cb	 mov	 rcx, rbx
  0005c	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00061	e8 00 00 00 00	 call	 _PyLong_New
  00066	48 8b f8	 mov	 rdi, rax

; 2902 :     if (z == NULL)

  00069	48 85 c0	 test	 rax, rax
  0006c	75 50		 jne	 SHORT $LN13@x_sub

; 2903 :         return NULL;

  0006e	e9 74 01 00 00	 jmp	 $LN48@x_sub
$LN49@x_sub:

; 2887 :     }
; 2888 :     else if (size_a == size_b) {

  00073	75 e4		 jne	 SHORT $LN18@x_sub

; 2889 :         /* Find highest digit where a and b differ: */
; 2890 :         i = size_a;

  00075	48 8d 4c 9a 70	 lea	 rcx, QWORD PTR [rdx+rbx*4+112]

; 2891 :         while (--i >= 0 && a->ob_digit[i] == b->ob_digit[i])

  0007a	49 8b d4	 mov	 rdx, r12
  0007d	49 2b d5	 sub	 rdx, r13
$LL17@x_sub:
  00080	48 83 e9 04	 sub	 rcx, 4
  00084	48 ff cb	 dec	 rbx
  00087	78 29		 js	 SHORT $LN47@x_sub
  00089	8b 01		 mov	 eax, DWORD PTR [rcx]
  0008b	39 04 0a	 cmp	 DWORD PTR [rdx+rcx], eax
  0008e	74 f0		 je	 SHORT $LL17@x_sub

; 2895 :         if (a->ob_digit[i] < b->ob_digit[i]) {

  00090	41 8b 44 9d 70	 mov	 eax, DWORD PTR [r13+rbx*4+112]
  00095	41 39 44 9c 70	 cmp	 DWORD PTR [r12+rbx*4+112], eax
  0009a	73 0d		 jae	 SHORT $LN14@x_sub

; 2896 :             sign = -1;
; 2897 :             { PyLongObject *temp = a; a = b; b = temp; }

  0009c	49 8b c4	 mov	 rax, r12
  0009f	4d 8b e5	 mov	 r12, r13
  000a2	41 83 cf ff	 or	 r15d, -1
  000a6	4c 8b e8	 mov	 r13, rax
$LN14@x_sub:

; 2898 :         }
; 2899 :         size_a = size_b = i+1;

  000a9	48 8d 6b 01	 lea	 rbp, QWORD PTR [rbx+1]
  000ad	48 8b dd	 mov	 rbx, rbp
  000b0	eb a7		 jmp	 SHORT $LN18@x_sub
$LN47@x_sub:

; 2892 :             ;
; 2893 :         if (i < 0)
; 2894 :             return (PyLongObject *)PyLong_FromLong(0);

  000b2	33 c9		 xor	 ecx, ecx
  000b4	e8 00 00 00 00	 call	 PyLong_FromLong
  000b9	e9 2e 01 00 00	 jmp	 $LN21@x_sub
$LN13@x_sub:

; 2904 :     for (i = 0; i < size_b; ++i) {

  000be	49 8b d6	 mov	 rdx, r14
  000c1	48 85 ed	 test	 rbp, rbp
  000c4	7e 3e		 jle	 SHORT $LN10@x_sub
  000c6	4d 8b c4	 mov	 r8, r12
  000c9	4c 8b c8	 mov	 r9, rax
  000cc	49 8d 4d 70	 lea	 rcx, QWORD PTR [r13+112]
  000d0	4d 2b c5	 sub	 r8, r13
  000d3	4d 2b cd	 sub	 r9, r13
  000d6	48 8b d5	 mov	 rdx, rbp
  000d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL12@x_sub:

; 2905 :         /* The following assumes unsigned arithmetic
; 2906 :            works module 2**N for some N>PyLong_SHIFT. */
; 2907 :         borrow = a->ob_digit[i] - b->ob_digit[i] - borrow;

  000e0	42 8b 04 01	 mov	 eax, DWORD PTR [rcx+r8]
  000e4	48 83 c1 04	 add	 rcx, 4
  000e8	2b 41 fc	 sub	 eax, DWORD PTR [rcx-4]
  000eb	2b c6		 sub	 eax, esi
  000ed	8b f0		 mov	 esi, eax

; 2908 :         z->ob_digit[i] = borrow & PyLong_MASK;

  000ef	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH

; 2909 :         borrow >>= PyLong_SHIFT;
; 2910 :         borrow &= 1; /* Keep only one sign bit */

  000f4	c1 ee 1e	 shr	 esi, 30
  000f7	41 89 44 09 fc	 mov	 DWORD PTR [r9+rcx-4], eax
  000fc	83 e6 01	 and	 esi, 1
  000ff	48 ff cd	 dec	 rbp
  00102	75 dc		 jne	 SHORT $LL12@x_sub
$LN10@x_sub:

; 2911 :     }
; 2912 :     for (; i < size_a; ++i) {

  00104	48 3b d3	 cmp	 rdx, rbx
  00107	7d 2a		 jge	 SHORT $LN7@x_sub
  00109	4c 2b e7	 sub	 r12, rdi
  0010c	48 8d 4c 97 70	 lea	 rcx, QWORD PTR [rdi+rdx*4+112]
  00111	48 2b da	 sub	 rbx, rdx
$LL9@x_sub:

; 2913 :         borrow = a->ob_digit[i] - borrow;

  00114	41 8b 04 0c	 mov	 eax, DWORD PTR [r12+rcx]
  00118	48 83 c1 04	 add	 rcx, 4
  0011c	2b c6		 sub	 eax, esi
  0011e	8b f0		 mov	 esi, eax

; 2914 :         z->ob_digit[i] = borrow & PyLong_MASK;

  00120	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH

; 2915 :         borrow >>= PyLong_SHIFT;
; 2916 :         borrow &= 1; /* Keep only one sign bit */

  00125	c1 ee 1e	 shr	 esi, 30
  00128	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  0012b	83 e6 01	 and	 esi, 1
  0012e	48 ff cb	 dec	 rbx
  00131	75 e1		 jne	 SHORT $LL9@x_sub
$LN7@x_sub:

; 2917 :     }
; 2918 :     assert(borrow == 0);
; 2919 :     if (sign < 0)

  00133	45 85 ff	 test	 r15d, r15d
  00136	0f 89 a3 00 00
	00		 jns	 $LN3@x_sub

; 2920 :         NEGATE(z);

  0013c	48 83 7f 50 01	 cmp	 QWORD PTR [rdi+80], 1
  00141	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00145	75 0c		 jne	 SHORT $LN2@x_sub
  00147	48 f7 d8	 neg	 rax
  0014a	48 89 47 60	 mov	 QWORD PTR [rdi+96], rax
  0014e	e9 8c 00 00 00	 jmp	 $LN3@x_sub
$LN2@x_sub:
  00153	48 85 c0	 test	 rax, rax
  00156	79 09		 jns	 SHORT $LN50@x_sub
  00158	44 8b 77 70	 mov	 r14d, DWORD PTR [rdi+112]
  0015c	41 f7 de	 neg	 r14d
  0015f	eb 06		 jmp	 SHORT $LN28@x_sub
$LN50@x_sub:
  00161	74 04		 je	 SHORT $LN28@x_sub
  00163	44 8b 77 70	 mov	 r14d, DWORD PTR [rdi+112]
$LN28@x_sub:
  00167	41 f7 de	 neg	 r14d
  0016a	41 8b ce	 mov	 ecx, r14d
  0016d	e8 00 00 00 00	 call	 PyLong_FromLong
  00172	48 8b d8	 mov	 rbx, rax
  00175	e8 00 00 00 00	 call	 _Py_PXCTX
  0017a	85 c0		 test	 eax, eax
  0017c	75 5e		 jne	 SHORT $LN41@x_sub
  0017e	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  00182	f6 c1 20	 test	 cl, 32			; 00000020H
  00185	75 4d		 jne	 SHORT $LN35@x_sub
  00187	84 c9		 test	 cl, cl
  00189	78 49		 js	 SHORT $LN35@x_sub
  0018b	f6 c1 02	 test	 cl, 2
  0018e	75 4c		 jne	 SHORT $LN41@x_sub
  00190	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00194	75 46		 jne	 SHORT $LN41@x_sub
  00196	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0019d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001a4	4c 8b cf	 mov	 r9, rdi
  001a7	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001ad	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001b5	e8 00 00 00 00	 call	 _PyParallel_Guard
  001ba	48 8b cf	 mov	 rcx, rdi
  001bd	85 c0		 test	 eax, eax
  001bf	74 07		 je	 SHORT $LN40@x_sub
  001c1	e8 00 00 00 00	 call	 _Px_Dealloc
  001c6	eb 14		 jmp	 SHORT $LN41@x_sub
$LN40@x_sub:
  001c8	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001cc	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001d2	eb 08		 jmp	 SHORT $LN41@x_sub
$LN35@x_sub:
  001d4	48 8b cf	 mov	 rcx, rdi
  001d7	e8 00 00 00 00	 call	 Px_DecRef
$LN41@x_sub:
  001dc	48 8b fb	 mov	 rdi, rbx
$LN3@x_sub:

; 2921 :     return long_normalize(z);

  001df	48 8b cf	 mov	 rcx, rdi
  001e2	e8 00 00 00 00	 call	 long_normalize
$LN48@x_sub:
  001e7	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
$LN21@x_sub:

; 2922 : }

  001ec	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  001f1	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  001f6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001fa	41 5f		 pop	 r15
  001fc	41 5e		 pop	 r14
  001fe	41 5d		 pop	 r13
  00200	41 5c		 pop	 r12
  00202	5e		 pop	 rsi
  00203	c3		 ret	 0
x_sub	ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_add DD imagerel long_add
	DD	imagerel long_add+325
	DD	imagerel $unwind$long_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_add DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT long_add
_TEXT	SEGMENT
a$ = 64
b$ = 72
long_add PROC						; COMDAT

; 2926 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2927 :     PyLongObject *z;
; 2928 : 
; 2929 :     CHECK_BINOP(a, b);

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	4c 8b c2	 mov	 r8, rdx
  0000b	4c 8b c9	 mov	 r9, rcx
  0000e	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00018	0f 84 d6 00 00
	00		 je	 $LN9@long_add
  0001e	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00022	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0002c	0f 84 c2 00 00
	00		 je	 $LN9@long_add

; 2930 : 
; 2931 :     if (ABS(Py_SIZE(a)) <= 1 && ABS(Py_SIZE(b)) <= 1) {

  00032	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00036	48 8b c8	 mov	 rcx, rax
  00039	48 85 c0	 test	 rax, rax
  0003c	79 03		 jns	 SHORT $LN17@long_add
  0003e	48 f7 d9	 neg	 rcx
$LN17@long_add:
  00041	48 83 f9 01	 cmp	 rcx, 1
  00045	7f 53		 jg	 SHORT $LN8@long_add
  00047	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  0004b	48 8b ca	 mov	 rcx, rdx
  0004e	48 85 d2	 test	 rdx, rdx
  00051	79 03		 jns	 SHORT $LN19@long_add
  00053	48 f7 d9	 neg	 rcx
$LN19@long_add:
  00056	48 83 f9 01	 cmp	 rcx, 1
  0005a	7f 3e		 jg	 SHORT $LN8@long_add

; 2932 :         PyObject *result = PyLong_FromLong(MEDIUM_VALUE(a) +
; 2933 :                                           MEDIUM_VALUE(b));

  0005c	33 c9		 xor	 ecx, ecx
  0005e	48 85 c0	 test	 rax, rax
  00061	79 08		 jns	 SHORT $LN32@long_add
  00063	41 8b 41 70	 mov	 eax, DWORD PTR [r9+112]
  00067	f7 d8		 neg	 eax
  00069	eb 08		 jmp	 SHORT $LN21@long_add
$LN32@long_add:
  0006b	8b c1		 mov	 eax, ecx
  0006d	74 04		 je	 SHORT $LN21@long_add
  0006f	41 8b 41 70	 mov	 eax, DWORD PTR [r9+112]
$LN21@long_add:
  00073	48 85 d2	 test	 rdx, rdx
  00076	79 11		 jns	 SHORT $LN33@long_add
  00078	41 8b 48 70	 mov	 ecx, DWORD PTR [r8+112]
  0007c	f7 d9		 neg	 ecx
  0007e	03 c8		 add	 ecx, eax

; 2949 :             z = x_add(a, b);
; 2950 :     }
; 2951 :     return (PyObject *)z;
; 2952 : }

  00080	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00084	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN33@long_add:

; 2932 :         PyObject *result = PyLong_FromLong(MEDIUM_VALUE(a) +
; 2933 :                                           MEDIUM_VALUE(b));

  00089	74 04		 je	 SHORT $LN25@long_add
  0008b	41 8b 48 70	 mov	 ecx, DWORD PTR [r8+112]
$LN25@long_add:
  0008f	03 c8		 add	 ecx, eax

; 2949 :             z = x_add(a, b);
; 2950 :     }
; 2951 :     return (PyObject *)z;
; 2952 : }

  00091	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00095	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN8@long_add:

; 2934 :         return result;
; 2935 :     }
; 2936 :     if (Py_SIZE(a) < 0) {

  0009a	48 85 c0	 test	 rax, rax
  0009d	79 3f		 jns	 SHORT $LN7@long_add

; 2937 :         if (Py_SIZE(b) < 0) {

  0009f	49 83 78 60 00	 cmp	 QWORD PTR [r8+96], 0
  000a4	7d 29		 jge	 SHORT $LN6@long_add

; 2938 :             z = x_add(a, b);

  000a6	49 8b d0	 mov	 rdx, r8
  000a9	49 8b c9	 mov	 rcx, r9
  000ac	e8 00 00 00 00	 call	 x_add

; 2939 :             if (z != NULL && Py_SIZE(z) != 0)

  000b1	48 85 c0	 test	 rax, rax
  000b4	0f 84 86 00 00
	00		 je	 $LN14@long_add
  000ba	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000be	48 85 c9	 test	 rcx, rcx
  000c1	74 7d		 je	 SHORT $LN14@long_add

; 2940 :                 Py_SIZE(z) = -(Py_SIZE(z));

  000c3	48 f7 d9	 neg	 rcx
  000c6	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 2949 :             z = x_add(a, b);
; 2950 :     }
; 2951 :     return (PyObject *)z;
; 2952 : }

  000ca	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ce	c3		 ret	 0
$LN6@long_add:

; 2941 :         }
; 2942 :         else
; 2943 :             z = x_sub(b, a);

  000cf	49 8b d1	 mov	 rdx, r9
  000d2	49 8b c8	 mov	 rcx, r8
$LN34@long_add:

; 2949 :             z = x_add(a, b);
; 2950 :     }
; 2951 :     return (PyObject *)z;
; 2952 : }

  000d5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d9	e9 00 00 00 00	 jmp	 x_sub
$LN7@long_add:

; 2944 :     }
; 2945 :     else {
; 2946 :         if (Py_SIZE(b) < 0)

  000de	49 83 78 60 00	 cmp	 QWORD PTR [r8+96], 0

; 2947 :             z = x_sub(a, b);

  000e3	49 8b d0	 mov	 rdx, r8
  000e6	49 8b c9	 mov	 rcx, r9

; 2948 :         else

  000e9	7c ea		 jl	 SHORT $LN34@long_add

; 2949 :             z = x_add(a, b);
; 2950 :     }
; 2951 :     return (PyObject *)z;
; 2952 : }

  000eb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ef	e9 00 00 00 00	 jmp	 x_add
$LN9@long_add:

; 2927 :     PyLongObject *z;
; 2928 : 
; 2929 :     CHECK_BINOP(a, b);

  000f4	e8 00 00 00 00	 call	 _Py_PXCTX
  000f9	85 c0		 test	 eax, eax
  000fb	75 3c		 jne	 SHORT $LN29@long_add
  000fd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00104	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0010b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00112	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00118	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00120	e8 00 00 00 00	 call	 _PyParallel_Guard
  00125	85 c0		 test	 eax, eax
  00127	75 09		 jne	 SHORT $LN28@long_add
  00129	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00130	74 07		 je	 SHORT $LN29@long_add
$LN28@long_add:
  00132	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN29@long_add:
  00139	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
$LN14@long_add:

; 2949 :             z = x_add(a, b);
; 2950 :     }
; 2951 :     return (PyObject *)z;
; 2952 : }

  00140	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00144	c3		 ret	 0
long_add ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_sub DD imagerel long_sub
	DD	imagerel long_sub+312
	DD	imagerel $unwind$long_sub
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_sub DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT long_sub
_TEXT	SEGMENT
a$ = 64
b$ = 72
long_sub PROC						; COMDAT

; 2956 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2957 :     PyLongObject *z;
; 2958 : 
; 2959 :     CHECK_BINOP(a, b);

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	4c 8b c9	 mov	 r9, rcx
  0000b	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00015	0f 84 cc 00 00
	00		 je	 $LN9@long_sub
  0001b	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0001f	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00029	0f 84 b8 00 00
	00		 je	 $LN9@long_sub

; 2960 : 
; 2961 :     if (ABS(Py_SIZE(a)) <= 1 && ABS(Py_SIZE(b)) <= 1) {

  0002f	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00033	48 8b c8	 mov	 rcx, rax
  00036	48 85 c0	 test	 rax, rax
  00039	79 03		 jns	 SHORT $LN17@long_sub
  0003b	48 f7 d9	 neg	 rcx
$LN17@long_sub:
  0003e	48 83 f9 01	 cmp	 rcx, 1
  00042	7f 55		 jg	 SHORT $LN8@long_sub
  00044	4c 8b 42 60	 mov	 r8, QWORD PTR [rdx+96]
  00048	49 8b c8	 mov	 rcx, r8
  0004b	4d 85 c0	 test	 r8, r8
  0004e	79 03		 jns	 SHORT $LN19@long_sub
  00050	48 f7 d9	 neg	 rcx
$LN19@long_sub:
  00053	48 83 f9 01	 cmp	 rcx, 1
  00057	7f 40		 jg	 SHORT $LN8@long_sub

; 2962 :         PyObject* r;
; 2963 :         r = PyLong_FromLong(MEDIUM_VALUE(a)-MEDIUM_VALUE(b));

  00059	33 c9		 xor	 ecx, ecx
  0005b	48 85 c0	 test	 rax, rax
  0005e	79 08		 jns	 SHORT $LN32@long_sub
  00060	41 8b 41 70	 mov	 eax, DWORD PTR [r9+112]
  00064	f7 d8		 neg	 eax
  00066	eb 08		 jmp	 SHORT $LN21@long_sub
$LN32@long_sub:
  00068	8b c1		 mov	 eax, ecx
  0006a	74 04		 je	 SHORT $LN21@long_sub
  0006c	41 8b 41 70	 mov	 eax, DWORD PTR [r9+112]
$LN21@long_sub:
  00070	4d 85 c0	 test	 r8, r8
  00073	79 12		 jns	 SHORT $LN33@long_sub
  00075	8b 4a 70	 mov	 ecx, DWORD PTR [rdx+112]
  00078	f7 d9		 neg	 ecx
  0007a	2b c1		 sub	 eax, ecx
  0007c	8b c8		 mov	 ecx, eax

; 2976 :             z = x_add(a, b);
; 2977 :         else
; 2978 :             z = x_sub(a, b);
; 2979 :     }
; 2980 :     return (PyObject *)z;
; 2981 : }

  0007e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00082	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN33@long_sub:

; 2962 :         PyObject* r;
; 2963 :         r = PyLong_FromLong(MEDIUM_VALUE(a)-MEDIUM_VALUE(b));

  00087	74 03		 je	 SHORT $LN25@long_sub
  00089	8b 4a 70	 mov	 ecx, DWORD PTR [rdx+112]
$LN25@long_sub:
  0008c	2b c1		 sub	 eax, ecx
  0008e	8b c8		 mov	 ecx, eax

; 2976 :             z = x_add(a, b);
; 2977 :         else
; 2978 :             z = x_sub(a, b);
; 2979 :     }
; 2980 :     return (PyObject *)z;
; 2981 : }

  00090	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00094	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN8@long_sub:

; 2968 :             z = x_sub(a, b);

  00099	49 8b c9	 mov	 rcx, r9
  0009c	48 85 c0	 test	 rax, rax
  0009f	79 2d		 jns	 SHORT $LN7@long_sub

; 2964 :         return r;
; 2965 :     }
; 2966 :     if (Py_SIZE(a) < 0) {
; 2967 :         if (Py_SIZE(b) < 0)

  000a1	48 83 7a 60 00	 cmp	 QWORD PTR [rdx+96], 0
  000a6	7d 07		 jge	 SHORT $LN6@long_sub

; 2968 :             z = x_sub(a, b);

  000a8	e8 00 00 00 00	 call	 x_sub

; 2969 :         else

  000ad	eb 05		 jmp	 SHORT $LN5@long_sub
$LN6@long_sub:

; 2970 :             z = x_add(a, b);

  000af	e8 00 00 00 00	 call	 x_add
$LN5@long_sub:

; 2971 :         if (z != NULL && Py_SIZE(z) != 0)

  000b4	48 85 c0	 test	 rax, rax
  000b7	74 7a		 je	 SHORT $LN14@long_sub
  000b9	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000bd	48 85 c9	 test	 rcx, rcx
  000c0	74 71		 je	 SHORT $LN14@long_sub

; 2972 :             Py_SIZE(z) = -(Py_SIZE(z));

  000c2	48 f7 d9	 neg	 rcx
  000c5	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 2976 :             z = x_add(a, b);
; 2977 :         else
; 2978 :             z = x_sub(a, b);
; 2979 :     }
; 2980 :     return (PyObject *)z;
; 2981 : }

  000c9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cd	c3		 ret	 0
$LN7@long_sub:

; 2973 :     }
; 2974 :     else {
; 2975 :         if (Py_SIZE(b) < 0)

  000ce	48 83 7a 60 00	 cmp	 QWORD PTR [rdx+96], 0
  000d3	7d 09		 jge	 SHORT $LN2@long_sub

; 2976 :             z = x_add(a, b);
; 2977 :         else
; 2978 :             z = x_sub(a, b);
; 2979 :     }
; 2980 :     return (PyObject *)z;
; 2981 : }

  000d5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d9	e9 00 00 00 00	 jmp	 x_add
$LN2@long_sub:
  000de	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e2	e9 00 00 00 00	 jmp	 x_sub
$LN9@long_sub:

; 2957 :     PyLongObject *z;
; 2958 : 
; 2959 :     CHECK_BINOP(a, b);

  000e7	e8 00 00 00 00	 call	 _Py_PXCTX
  000ec	85 c0		 test	 eax, eax
  000ee	75 3c		 jne	 SHORT $LN29@long_sub
  000f0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00105	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0010b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00113	e8 00 00 00 00	 call	 _PyParallel_Guard
  00118	85 c0		 test	 eax, eax
  0011a	75 09		 jne	 SHORT $LN28@long_sub
  0011c	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00123	74 07		 je	 SHORT $LN29@long_sub
$LN28@long_sub:
  00125	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN29@long_sub:
  0012c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
$LN14@long_sub:

; 2976 :             z = x_add(a, b);
; 2977 :         else
; 2978 :             z = x_sub(a, b);
; 2979 :     }
; 2980 :     return (PyObject *)z;
; 2981 : }

  00133	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00137	c3		 ret	 0
long_sub ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$x_mul DD	imagerel x_mul
	DD	imagerel x_mul+89
	DD	imagerel $unwind$x_mul
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$x_mul DD imagerel x_mul+89
	DD	imagerel x_mul+363
	DD	imagerel $chain$2$x_mul
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$x_mul DD imagerel x_mul+363
	DD	imagerel x_mul+623
	DD	imagerel $chain$4$x_mul
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$x_mul DD 060021H
	DD	07e400H
	DD	086400H
	DD	095400H
	DD	imagerel x_mul
	DD	imagerel x_mul+89
	DD	imagerel $unwind$x_mul
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$x_mul DD 061c21H
	DD	07e41cH
	DD	086417H
	DD	095405H
	DD	imagerel x_mul
	DD	imagerel x_mul+89
	DD	imagerel $unwind$x_mul
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$x_mul DD 061101H
	DD	0f00d9211H
	DD	0c009d00bH
	DD	030067007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT x_mul
_TEXT	SEGMENT
tv649 = 32
a$ = 128
b$ = 136
z$1$ = 144
pb$1$ = 152
x_mul	PROC						; COMDAT

; 2988 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	53		 push	 rbx
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 57		 push	 r15
  0000d	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 2989 :     PyLongObject *z;
; 2990 :     Py_ssize_t size_a = ABS(Py_SIZE(a));

  00011	4c 8b 69 60	 mov	 r13, QWORD PTR [rcx+96]
  00015	4c 8b e2	 mov	 r12, rdx
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	4d 85 ed	 test	 r13, r13
  0001e	79 03		 jns	 SHORT $LN27@x_mul
  00020	49 f7 dd	 neg	 r13
$LN27@x_mul:

; 2991 :     Py_ssize_t size_b = ABS(Py_SIZE(b));

  00023	48 8b 5a 60	 mov	 rbx, QWORD PTR [rdx+96]
  00027	48 85 db	 test	 rbx, rbx
  0002a	79 03		 jns	 SHORT $LN29@x_mul
  0002c	48 f7 db	 neg	 rbx
$LN29@x_mul:

; 2992 :     Py_ssize_t i;
; 2993 : 
; 2994 :     z = _PyLong_New(size_a + size_b);

  0002f	4a 8d 0c 2b	 lea	 rcx, QWORD PTR [rbx+r13]
  00033	e8 00 00 00 00	 call	 _PyLong_New
  00038	4c 8b f8	 mov	 r15, rax
  0003b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR z$1$[rsp], rax

; 2995 :     if (z == NULL)

  00043	48 85 c0	 test	 rax, rax
  00046	75 0d		 jne	 SHORT $LN24@x_mul

; 3068 : }

  00048	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0004c	41 5f		 pop	 r15
  0004e	41 5d		 pop	 r13
  00050	41 5c		 pop	 r12
  00052	5f		 pop	 rdi
  00053	5b		 pop	 rbx
  00054	c3		 ret	 0
$LN24@x_mul:

; 2996 :         return NULL;
; 2997 : 
; 2998 :     memset(z->ob_digit, 0, Py_SIZE(z) * sizeof(digit));

  00055	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00059	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  0005e	48 8d 68 70	 lea	 rbp, QWORD PTR [rax+112]
  00062	48 8b cd	 mov	 rcx, rbp
  00065	33 d2		 xor	 edx, edx
  00067	49 c1 e0 02	 shl	 r8, 2
  0006b	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00070	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  00075	e8 00 00 00 00	 call	 memset

; 2999 :     if (a == b) {
; 3000 :         /* Efficient squaring per HAC, Algorithm 14.16:
; 3001 :          * http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf
; 3002 :          * Gives slightly less than a 2x speedup when a == b,
; 3003 :          * via exploiting that each entry in the multiplication
; 3004 :          * pyramid appears twice (except for the size_a squares).
; 3005 :          */
; 3006 :         for (i = 0; i < size_a; ++i) {

  0007a	45 33 f6	 xor	 r14d, r14d
  0007d	49 3b fc	 cmp	 rdi, r12
  00080	0f 85 f1 00 00
	00		 jne	 $LN23@x_mul
  00086	4d 85 ed	 test	 r13, r13
  00089	0f 8e b8 00 00
	00		 jle	 $LN8@x_mul
  0008f	4e 8d 64 af 70	 lea	 r12, QWORD PTR [rdi+r13*4+112]
  00094	48 8d 77 74	 lea	 rsi, QWORD PTR [rdi+116]
  00098	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL22@x_mul:

; 3007 :             twodigits carry;
; 3008 :             twodigits f = a->ob_digit[i];

  000a0	8b 7e fc	 mov	 edi, DWORD PTR [rsi-4]

; 3009 :             digit *pz = z->ob_digit + (i << 1);
; 3010 :             digit *pa = a->ob_digit + i + 1;

  000a3	48 8b de	 mov	 rbx, rsi

; 3011 :             digit *paend = a->ob_digit + size_a;
; 3012 : 
; 3013 :             SIGCHECK({
; 3014 :                     Py_DECREF(z);
; 3015 :                     return NULL;
; 3016 :                 });

  000a6	e8 00 00 00 00	 call	 PyErr_CheckSignals
  000ab	85 c0		 test	 eax, eax
  000ad	0f 85 b8 00 00
	00		 jne	 $LN35@x_mul

; 3017 : 
; 3018 :             carry = *pz + f * f;

  000b3	8b 45 00	 mov	 eax, DWORD PTR [rbp]
  000b6	8b d7		 mov	 edx, edi

; 3019 :             *pz++ = (digit)(carry & PyLong_MASK);

  000b8	4c 8d 45 04	 lea	 r8, QWORD PTR [rbp+4]
  000bc	48 0f af d7	 imul	 rdx, rdi
  000c0	48 03 d0	 add	 rdx, rax

; 3020 :             carry >>= PyLong_SHIFT;
; 3021 :             assert(carry <= PyLong_MASK);
; 3022 : 
; 3023 :             /* Now f is added in twice in each column of the
; 3024 :              * pyramid it appears.  Same as adding f<<1 once.
; 3025 :              */
; 3026 :             f <<= 1;

  000c3	48 03 ff	 add	 rdi, rdi
  000c6	8b c2		 mov	 eax, edx
  000c8	48 c1 ea 1e	 shr	 rdx, 30
  000cc	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  000d1	89 45 00	 mov	 DWORD PTR [rbp], eax

; 3027 :             while (pa < paend) {

  000d4	49 3b f4	 cmp	 rsi, r12
  000d7	73 32		 jae	 SHORT $LN14@x_mul
  000d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL15@x_mul:

; 3028 :                 carry += *pz + *pa++ * f;

  000e0	41 8b 00	 mov	 eax, DWORD PTR [r8]
  000e3	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  000e5	48 83 c3 04	 add	 rbx, 4
  000e9	48 03 d0	 add	 rdx, rax

; 3029 :                 *pz++ = (digit)(carry & PyLong_MASK);

  000ec	49 83 c0 04	 add	 r8, 4
  000f0	48 0f af cf	 imul	 rcx, rdi
  000f4	48 03 d1	 add	 rdx, rcx
  000f7	8b c2		 mov	 eax, edx

; 3030 :                 carry >>= PyLong_SHIFT;

  000f9	48 c1 ea 1e	 shr	 rdx, 30
  000fd	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00102	41 89 40 fc	 mov	 DWORD PTR [r8-4], eax
  00106	49 3b dc	 cmp	 rbx, r12
  00109	72 d5		 jb	 SHORT $LL15@x_mul
$LN14@x_mul:

; 3031 :                 assert(carry <= (PyLong_MASK << 1));
; 3032 :             }
; 3033 :             if (carry) {

  0010b	48 85 d2	 test	 rdx, rdx
  0010e	74 23		 je	 SHORT $LN21@x_mul

; 3034 :                 carry += *pz;

  00110	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00113	48 03 d0	 add	 rdx, rax

; 3035 :                 *pz++ = (digit)(carry & PyLong_MASK);

  00116	8b c2		 mov	 eax, edx

; 3036 :                 carry >>= PyLong_SHIFT;

  00118	48 c1 ea 1e	 shr	 rdx, 30
  0011c	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00121	41 89 00	 mov	 DWORD PTR [r8], eax

; 3037 :             }
; 3038 :             if (carry)

  00124	48 85 d2	 test	 rdx, rdx
  00127	74 0a		 je	 SHORT $LN21@x_mul

; 3039 :                 *pz += (digit)(carry & PyLong_MASK);

  00129	81 e2 ff ff ff
	3f		 and	 edx, 1073741823		; 3fffffffH
  0012f	41 01 50 04	 add	 DWORD PTR [r8+4], edx
$LN21@x_mul:

; 2999 :     if (a == b) {
; 3000 :         /* Efficient squaring per HAC, Algorithm 14.16:
; 3001 :          * http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf
; 3002 :          * Gives slightly less than a 2x speedup when a == b,
; 3003 :          * via exploiting that each entry in the multiplication
; 3004 :          * pyramid appears twice (except for the size_a squares).
; 3005 :          */
; 3006 :         for (i = 0; i < size_a; ++i) {

  00133	49 ff c6	 inc	 r14
  00136	48 83 c5 08	 add	 rbp, 8
  0013a	48 83 c6 04	 add	 rsi, 4
  0013e	4d 3b f5	 cmp	 r14, r13
  00141	0f 8c 59 ff ff
	ff		 jl	 $LL22@x_mul
$LN8@x_mul:

; 3064 :             assert((carry >> PyLong_SHIFT) == 0);
; 3065 :         }
; 3066 :     }
; 3067 :     return long_normalize(z);

  00147	49 8b cf	 mov	 rcx, r15
  0014a	e8 00 00 00 00	 call	 long_normalize
$LN43@x_mul:
  0014f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00154	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00159	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]

; 3068 : }

  0015e	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00162	41 5f		 pop	 r15
  00164	41 5d		 pop	 r13
  00166	41 5c		 pop	 r12
  00168	5f		 pop	 rdi
  00169	5b		 pop	 rbx
  0016a	c3		 ret	 0
$LN35@x_mul:

; 3011 :             digit *paend = a->ob_digit + size_a;
; 3012 : 
; 3013 :             SIGCHECK({
; 3014 :                     Py_DECREF(z);
; 3015 :                     return NULL;
; 3016 :                 });

  0016b	49 8b cf	 mov	 rcx, r15
  0016e	e8 00 00 00 00	 call	 _Py_DecRef
  00173	33 c0		 xor	 eax, eax
  00175	eb d8		 jmp	 SHORT $LN43@x_mul
$LN23@x_mul:

; 3040 :             assert((carry >> PyLong_SHIFT) == 0);
; 3041 :         }
; 3042 :     }
; 3043 :     else {      /* a is not the same as b -- gradeschool int mult */
; 3044 :         for (i = 0; i < size_a; ++i) {

  00177	49 8b f6	 mov	 rsi, r14
  0017a	4d 85 ed	 test	 r13, r13
  0017d	7e c8		 jle	 SHORT $LN8@x_mul
  0017f	49 8d 44 24 70	 lea	 rax, QWORD PTR [r12+112]
  00184	48 c7 c1 90 ff
	ff ff		 mov	 rcx, -112		; ffffffffffffff90H
  0018b	4d 8d 7c 9c 70	 lea	 r15, QWORD PTR [r12+rbx*4+112]
  00190	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pb$1$[rsp], rax
  00198	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$1$[rsp]
  001a0	48 2b f8	 sub	 rdi, rax
  001a3	48 2b c8	 sub	 rcx, rax
  001a6	48 89 4c 24 20	 mov	 QWORD PTR tv649[rsp], rcx
  001ab	48 89 bc 24 80
	00 00 00	 mov	 QWORD PTR a$[rsp], rdi
  001b3	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL10@x_mul:

; 3045 :             twodigits carry = 0;
; 3046 :             twodigits f = a->ob_digit[i];

  001c0	44 8b 24 2f	 mov	 r12d, DWORD PTR [rdi+rbp]
  001c4	49 8b de	 mov	 rbx, r14

; 3047 :             digit *pz = z->ob_digit + i;

  001c7	48 8b fd	 mov	 rdi, rbp

; 3048 :             digit *pb = b->ob_digit;
; 3049 :             digit *pbend = b->ob_digit + size_b;
; 3050 : 
; 3051 :             SIGCHECK({
; 3052 :                     Py_DECREF(z);
; 3053 :                     return NULL;
; 3054 :                 });

  001ca	e8 00 00 00 00	 call	 PyErr_CheckSignals
  001cf	85 c0		 test	 eax, eax
  001d1	0f 85 84 00 00
	00		 jne	 $LN36@x_mul

; 3055 : 
; 3056 :             while (pb < pbend) {

  001d7	4c 39 bc 24 98
	00 00 00	 cmp	 QWORD PTR pb$1$[rsp], r15
  001df	73 55		 jae	 SHORT $LN9@x_mul
  001e1	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  001e9	48 2b 54 24 20	 sub	 rdx, QWORD PTR tv649[rsp]
  001ee	48 2b 94 24 90
	00 00 00	 sub	 rdx, QWORD PTR z$1$[rsp]
  001f6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL3@x_mul:

; 3057 :                 carry += *pz + *pb++ * f;

  00200	8b 07		 mov	 eax, DWORD PTR [rdi]
  00202	8b 0a		 mov	 ecx, DWORD PTR [rdx]

; 3058 :                 *pz++ = (digit)(carry & PyLong_MASK);

  00204	48 83 c2 04	 add	 rdx, 4
  00208	48 03 d8	 add	 rbx, rax
  0020b	48 83 c7 04	 add	 rdi, 4
  0020f	49 0f af cc	 imul	 rcx, r12
  00213	48 03 d9	 add	 rbx, rcx
  00216	8b c3		 mov	 eax, ebx

; 3059 :                 carry >>= PyLong_SHIFT;

  00218	48 c1 eb 1e	 shr	 rbx, 30
  0021c	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  00221	89 47 fc	 mov	 DWORD PTR [rdi-4], eax
  00224	49 3b d7	 cmp	 rdx, r15
  00227	72 d7		 jb	 SHORT $LL3@x_mul

; 3060 :                 assert(carry <= PyLong_MASK);
; 3061 :             }
; 3062 :             if (carry)

  00229	48 85 db	 test	 rbx, rbx
  0022c	74 08		 je	 SHORT $LN9@x_mul

; 3063 :                 *pz += (digit)(carry & PyLong_MASK);

  0022e	81 e3 ff ff ff
	3f		 and	 ebx, 1073741823		; 3fffffffH
  00234	01 1f		 add	 DWORD PTR [rdi], ebx
$LN9@x_mul:

; 3040 :             assert((carry >> PyLong_SHIFT) == 0);
; 3041 :         }
; 3042 :     }
; 3043 :     else {      /* a is not the same as b -- gradeschool int mult */
; 3044 :         for (i = 0; i < size_a; ++i) {

  00236	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR a$[rsp]
  0023e	48 ff c6	 inc	 rsi
  00241	48 83 c5 04	 add	 rbp, 4
  00245	49 3b f5	 cmp	 rsi, r13
  00248	0f 8c 72 ff ff
	ff		 jl	 $LL10@x_mul

; 3048 :             digit *pb = b->ob_digit;
; 3049 :             digit *pbend = b->ob_digit + size_b;
; 3050 : 
; 3051 :             SIGCHECK({
; 3052 :                     Py_DECREF(z);
; 3053 :                     return NULL;
; 3054 :                 });

  0024e	4c 8b bc 24 90
	00 00 00	 mov	 r15, QWORD PTR z$1$[rsp]
  00256	e9 ec fe ff ff	 jmp	 $LN8@x_mul
$LN36@x_mul:
  0025b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR z$1$[rsp]
  00263	e8 00 00 00 00	 call	 _Py_DecRef
  00268	33 c0		 xor	 eax, eax
  0026a	e9 e0 fe ff ff	 jmp	 $LN43@x_mul
x_mul	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$kmul_split DD imagerel kmul_split
	DD	imagerel kmul_split+83
	DD	imagerel $unwind$kmul_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$kmul_split DD imagerel kmul_split+83
	DD	imagerel kmul_split+188
	DD	imagerel $chain$0$kmul_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$kmul_split DD imagerel kmul_split+188
	DD	imagerel kmul_split+214
	DD	imagerel $chain$1$kmul_split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$kmul_split DD 021H
	DD	imagerel kmul_split
	DD	imagerel kmul_split+83
	DD	imagerel $unwind$kmul_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$kmul_split DD 020521H
	DD	085405H
	DD	imagerel kmul_split
	DD	imagerel kmul_split+83
	DD	imagerel $unwind$kmul_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$kmul_split DD 0a1901H
	DD	0b7419H
	DD	0a6419H
	DD	093419H
	DD	0e0153219H
	DD	0c011d013H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT kmul_split
_TEXT	SEGMENT
n$ = 64
size$ = 72
high$ = 80
low$ = 88
kmul_split PROC						; COMDAT

; 3082 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	41 55		 push	 r13
  00013	41 56		 push	 r14
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3083 :     PyLongObject *hi, *lo;
; 3084 :     Py_ssize_t size_lo, size_hi;
; 3085 :     const Py_ssize_t size_n = ABS(Py_SIZE(n));

  00019	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  0001d	4d 8b e9	 mov	 r13, r9
  00020	4d 8b f0	 mov	 r14, r8
  00023	4c 8b e1	 mov	 r12, rcx
  00026	48 85 db	 test	 rbx, rbx
  00029	79 03		 jns	 SHORT $LN5@kmul_split
  0002b	48 f7 db	 neg	 rbx
$LN5@kmul_split:

; 3086 : 
; 3087 :     size_lo = MIN(size_n, size);

  0002e	48 3b da	 cmp	 rbx, rdx
  00031	48 8b fb	 mov	 rdi, rbx
  00034	48 0f 4f fa	 cmovg	 rdi, rdx

; 3088 :     size_hi = size_n - size_lo;

  00038	48 2b df	 sub	 rbx, rdi

; 3089 : 
; 3090 :     if ((hi = _PyLong_New(size_hi)) == NULL)

  0003b	48 8b cb	 mov	 rcx, rbx
  0003e	e8 00 00 00 00	 call	 _PyLong_New
  00043	48 8b f0	 mov	 rsi, rax
  00046	48 85 c0	 test	 rax, rax
  00049	75 05		 jne	 SHORT $LN2@kmul_split

; 3091 :         return -1;

  0004b	83 c8 ff	 or	 eax, -1
  0004e	eb 6c		 jmp	 SHORT $LN3@kmul_split
$LN2@kmul_split:

; 3092 :     if ((lo = _PyLong_New(size_lo)) == NULL) {

  00050	48 8b cf	 mov	 rcx, rdi
  00053	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00058	e8 00 00 00 00	 call	 _PyLong_New
  0005d	48 8b e8	 mov	 rbp, rax
  00060	48 85 c0	 test	 rax, rax
  00063	75 0d		 jne	 SHORT $LN1@kmul_split

; 3093 :         Py_DECREF(hi);

  00065	48 8b ce	 mov	 rcx, rsi
  00068	e8 00 00 00 00	 call	 _Py_DecRef

; 3094 :         return -1;

  0006d	83 c8 ff	 or	 eax, -1
  00070	eb 45		 jmp	 SHORT $LN7@kmul_split
$LN1@kmul_split:

; 3095 :     }
; 3096 : 
; 3097 :     memcpy(lo->ob_digit, n->ob_digit, size_lo * sizeof(digit));

  00072	4c 8d 04 bd 00
	00 00 00	 lea	 r8, QWORD PTR [rdi*4]
  0007a	49 8d 54 24 70	 lea	 rdx, QWORD PTR [r12+112]
  0007f	48 8d 48 70	 lea	 rcx, QWORD PTR [rax+112]
  00083	e8 00 00 00 00	 call	 memcpy

; 3098 :     memcpy(hi->ob_digit, n->ob_digit + size_lo, size_hi * sizeof(digit));

  00088	4c 8d 04 9d 00
	00 00 00	 lea	 r8, QWORD PTR [rbx*4]
  00090	49 8d 54 bc 70	 lea	 rdx, QWORD PTR [r12+rdi*4+112]
  00095	48 8d 4e 70	 lea	 rcx, QWORD PTR [rsi+112]
  00099	e8 00 00 00 00	 call	 memcpy

; 3099 : 
; 3100 :     *high = long_normalize(hi);

  0009e	48 8b ce	 mov	 rcx, rsi
  000a1	e8 00 00 00 00	 call	 long_normalize

; 3101 :     *low = long_normalize(lo);

  000a6	48 8b cd	 mov	 rcx, rbp
  000a9	49 89 06	 mov	 QWORD PTR [r14], rax
  000ac	e8 00 00 00 00	 call	 long_normalize
  000b1	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 3102 :     return 0;

  000b5	33 c0		 xor	 eax, eax
$LN7@kmul_split:
  000b7	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
$LN3@kmul_split:

; 3103 : }

  000bc	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000c1	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000c6	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000cb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cf	41 5e		 pop	 r14
  000d1	41 5d		 pop	 r13
  000d3	41 5c		 pop	 r12
  000d5	c3		 ret	 0
kmul_split ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$k_lopsided_mul DD imagerel k_lopsided_mul
	DD	imagerel k_lopsided_mul+421
	DD	imagerel $unwind$k_lopsided_mul
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$k_lopsided_mul DD 0c6801H
	DD	0fe468H
	DD	0ed463H
	DD	0d5454H
	DD	0f00c5210H
	DD	07008c00aH
	DD	030066007H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT k_lopsided_mul
_TEXT	SEGMENT
a$ = 96
b$ = 104
k_lopsided_mul PROC					; COMDAT

; 3334 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 57		 push	 r15
  0000c	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3335 :     const Py_ssize_t asize = ABS(Py_SIZE(a));

  00010	48 8b 71 60	 mov	 rsi, QWORD PTR [rcx+96]
  00014	4c 8b fa	 mov	 r15, rdx
  00017	48 8b d9	 mov	 rbx, rcx
  0001a	48 85 f6	 test	 rsi, rsi
  0001d	79 03		 jns	 SHORT $LN12@k_lopsided
  0001f	48 f7 de	 neg	 rsi
$LN12@k_lopsided:

; 3336 :     Py_ssize_t bsize = ABS(Py_SIZE(b));

  00022	48 8b 7a 60	 mov	 rdi, QWORD PTR [rdx+96]
  00026	48 85 ff	 test	 rdi, rdi
  00029	79 03		 jns	 SHORT $LN14@k_lopsided
  0002b	48 f7 df	 neg	 rdi
$LN14@k_lopsided:

; 3337 :     Py_ssize_t nbdone;          /* # of b digits already multiplied */
; 3338 :     PyLongObject *ret;
; 3339 :     PyLongObject *bslice = NULL;
; 3340 : 
; 3341 :     assert(asize > KARATSUBA_CUTOFF);
; 3342 :     assert(2 * asize <= bsize);
; 3343 : 
; 3344 :     /* Allocate result space, and zero it out. */
; 3345 :     ret = _PyLong_New(asize + bsize);

  0002e	48 8d 0c 37	 lea	 rcx, QWORD PTR [rdi+rsi]
  00032	e8 00 00 00 00	 call	 _PyLong_New
  00037	4c 8b e0	 mov	 r12, rax

; 3346 :     if (ret == NULL)

  0003a	48 85 c0	 test	 rax, rax
  0003d	75 0c		 jne	 SHORT $LN9@k_lopsided

; 3384 : }

  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	41 5f		 pop	 r15
  00045	41 5c		 pop	 r12
  00047	5f		 pop	 rdi
  00048	5e		 pop	 rsi
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
$LN9@k_lopsided:

; 3347 :         return NULL;
; 3348 :     memset(ret->ob_digit, 0, Py_SIZE(ret) * sizeof(digit));

  0004b	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0004f	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp
  00054	48 8d 48 70	 lea	 rcx, QWORD PTR [rax+112]
  00058	33 d2		 xor	 edx, edx
  0005a	49 c1 e0 02	 shl	 r8, 2
  0005e	4c 89 6c 24 70	 mov	 QWORD PTR [rsp+112], r13
  00063	4c 89 74 24 78	 mov	 QWORD PTR [rsp+120], r14
  00068	e8 00 00 00 00	 call	 memset

; 3349 : 
; 3350 :     /* Successive slices of b are copied into bslice. */
; 3351 :     bslice = _PyLong_New(asize);

  0006d	48 8b ce	 mov	 rcx, rsi
  00070	e8 00 00 00 00	 call	 _PyLong_New
  00075	4c 8b f0	 mov	 r14, rax

; 3352 :     if (bslice == NULL)

  00078	48 85 c0	 test	 rax, rax
  0007b	0f 84 f2 00 00
	00		 je	 $fail$22765

; 3353 :         goto fail;
; 3354 : 
; 3355 :     nbdone = 0;

  00081	33 ed		 xor	 ebp, ebp

; 3356 :     while (bsize > 0) {

  00083	48 85 ff	 test	 rdi, rdi
  00086	0f 8e d5 00 00
	00		 jle	 $LN6@k_lopsided
  0008c	48 83 c0 70	 add	 rax, 112		; 00000070H
$LL7@k_lopsided:

; 3357 :         PyLongObject *product;
; 3358 :         const Py_ssize_t nbtouse = MIN(bsize, asize);

  00090	4c 8b ef	 mov	 r13, rdi
  00093	48 3b fe	 cmp	 rdi, rsi

; 3359 : 
; 3360 :         /* Multiply the next slice of b by a. */
; 3361 :         memcpy(bslice->ob_digit, b->ob_digit + nbdone,
; 3362 :                nbtouse * sizeof(digit));

  00096	49 8d 54 af 70	 lea	 rdx, QWORD PTR [r15+rbp*4+112]
  0009b	4c 0f 4f ee	 cmovg	 r13, rsi
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	4e 8d 04 ad 00
	00 00 00	 lea	 r8, QWORD PTR [r13*4]
  000aa	e8 00 00 00 00	 call	 memcpy

; 3363 :         Py_SIZE(bslice) = nbtouse;
; 3364 :         product = k_mul(a, bslice);

  000af	49 8b d6	 mov	 rdx, r14
  000b2	48 8b cb	 mov	 rcx, rbx
  000b5	4d 89 6e 60	 mov	 QWORD PTR [r14+96], r13
  000b9	e8 00 00 00 00	 call	 k_mul
  000be	48 8b d8	 mov	 rbx, rax

; 3365 :         if (product == NULL)

  000c1	48 85 c0	 test	 rax, rax
  000c4	0f 84 a9 00 00
	00		 je	 $fail$22765

; 3366 :             goto fail;
; 3367 : 
; 3368 :         /* Add into result. */
; 3369 :         (void)v_iadd(ret->ob_digit + nbdone, Py_SIZE(ret) - nbdone,
; 3370 :                      product->ob_digit, Py_SIZE(product));

  000ca	49 8b 54 24 60	 mov	 rdx, QWORD PTR [r12+96]
  000cf	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  000d3	4c 8d 40 70	 lea	 r8, QWORD PTR [rax+112]
  000d7	49 8d 4c ac 70	 lea	 rcx, QWORD PTR [r12+rbp*4+112]
  000dc	48 2b d5	 sub	 rdx, rbp
  000df	e8 00 00 00 00	 call	 v_iadd

; 3371 :         Py_DECREF(product);

  000e4	e8 00 00 00 00	 call	 _Py_PXCTX
  000e9	85 c0		 test	 eax, eax
  000eb	75 5c		 jne	 SHORT $LN26@k_lopsided
  000ed	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000f1	a8 20		 test	 al, 32			; 00000020H
  000f3	75 4c		 jne	 SHORT $LN20@k_lopsided
  000f5	84 c0		 test	 al, al
  000f7	78 48		 js	 SHORT $LN20@k_lopsided
  000f9	a8 02		 test	 al, 2
  000fb	75 4c		 jne	 SHORT $LN26@k_lopsided
  000fd	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00101	75 46		 jne	 SHORT $LN26@k_lopsided
  00103	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00111	4c 8b cb	 mov	 r9, rbx
  00114	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0011a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00122	e8 00 00 00 00	 call	 _PyParallel_Guard
  00127	48 8b cb	 mov	 rcx, rbx
  0012a	85 c0		 test	 eax, eax
  0012c	74 07		 je	 SHORT $LN25@k_lopsided
  0012e	e8 00 00 00 00	 call	 _Px_Dealloc
  00133	eb 14		 jmp	 SHORT $LN26@k_lopsided
$LN25@k_lopsided:
  00135	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00139	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0013f	eb 08		 jmp	 SHORT $LN26@k_lopsided
$LN20@k_lopsided:
  00141	48 8b cb	 mov	 rcx, rbx
  00144	e8 00 00 00 00	 call	 Px_DecRef
$LN26@k_lopsided:

; 3372 : 
; 3373 :         bsize -= nbtouse;

  00149	48 8b 5c 24 60	 mov	 rbx, QWORD PTR a$[rsp]
  0014e	49 2b fd	 sub	 rdi, r13

; 3374 :         nbdone += nbtouse;

  00151	49 03 ed	 add	 rbp, r13
  00154	49 8d 46 70	 lea	 rax, QWORD PTR [r14+112]
  00158	48 85 ff	 test	 rdi, rdi
  0015b	0f 8f 2f ff ff
	ff		 jg	 $LL7@k_lopsided
$LN6@k_lopsided:

; 3375 :     }
; 3376 : 
; 3377 :     Py_DECREF(bslice);

  00161	49 8b ce	 mov	 rcx, r14
  00164	e8 00 00 00 00	 call	 _Py_DecRef

; 3378 :     return long_normalize(ret);

  00169	49 8b cc	 mov	 rcx, r12
  0016c	e8 00 00 00 00	 call	 long_normalize
  00171	eb 17		 jmp	 SHORT $LN32@k_lopsided
$fail$22765:

; 3379 : 
; 3380 :   fail:
; 3381 :     Py_DECREF(ret);

  00173	49 8b cc	 mov	 rcx, r12
  00176	e8 00 00 00 00	 call	 _Py_DecRef

; 3382 :     Py_XDECREF(bslice);

  0017b	4d 85 f6	 test	 r14, r14
  0017e	74 08		 je	 SHORT $LN3@k_lopsided
  00180	49 8b ce	 mov	 rcx, r14
  00183	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@k_lopsided:

; 3383 :     return NULL;

  00188	33 c0		 xor	 eax, eax
$LN32@k_lopsided:
  0018a	4c 8b 6c 24 70	 mov	 r13, QWORD PTR [rsp+112]
  0018f	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00194	4c 8b 74 24 78	 mov	 r14, QWORD PTR [rsp+120]

; 3384 : }

  00199	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019d	41 5f		 pop	 r15
  0019f	41 5c		 pop	 r12
  001a1	5f		 pop	 rdi
  001a2	5e		 pop	 rsi
  001a3	5b		 pop	 rbx
  001a4	c3		 ret	 0
k_lopsided_mul ENDP
_TEXT	ENDS
PUBLIC	__real@8000000000000000
PUBLIC	??_C@_0CO@FMAPPLED@integer?5division?5result?5too?5larg@ ; `string'
PUBLIC	??_C@_0CG@JGBBDDEJ@intermediate?5overflow?5during?5div@ ; `string'
PUBLIC	??_C@_0BB@OMEBCKB@division?5by?5zero?$AA@	; `string'
EXTRN	PyFloat_FromDouble:PROC
EXTRN	PyExc_ZeroDivisionError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_true_divide DD imagerel long_true_divide
	DD	imagerel long_true_divide+60
	DD	imagerel $unwind$long_true_divide
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$long_true_divide DD imagerel long_true_divide+60
	DD	imagerel long_true_divide+1295
	DD	imagerel $chain$7$long_true_divide
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$long_true_divide DD imagerel long_true_divide+1295
	DD	imagerel long_true_divide+1339
	DD	imagerel $chain$9$long_true_divide
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$long_true_divide DD imagerel long_true_divide+1339
	DD	imagerel long_true_divide+1422
	DD	imagerel $chain$10$long_true_divide
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$long_true_divide DD 021H
	DD	imagerel long_true_divide
	DD	imagerel long_true_divide+60
	DD	imagerel $unwind$long_true_divide
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$long_true_divide DD 0100021H
	DD	036800H
	DD	08f400H
	DD	09e400H
	DD	0ad400H
	DD	0b7400H
	DD	0c6400H
	DD	0d5400H
	DD	0133400H
	DD	imagerel long_true_divide
	DD	imagerel long_true_divide+60
	DD	imagerel $unwind$long_true_divide
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$long_true_divide DD 0106021H
	DD	036860H
	DD	08f450H
	DD	0ad448H
	DD	0c6436H
	DD	0d5431H
	DD	09e40cH
	DD	0b7408H
	DD	0133404H
	DD	imagerel long_true_divide
	DD	imagerel long_true_divide+60
	DD	imagerel $unwind$long_true_divide
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_true_divide DD 020d01H
	DD	0c009d20dH
xdata	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT ??_C@_0CO@FMAPPLED@integer?5division?5result?5too?5larg@
CONST	SEGMENT
??_C@_0CO@FMAPPLED@integer?5division?5result?5too?5larg@ DB 'integer divi'
	DB	'sion result too large for a float', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JGBBDDEJ@intermediate?5overflow?5during?5div@
CONST	SEGMENT
??_C@_0CG@JGBBDDEJ@intermediate?5overflow?5during?5div@ DB 'intermediate '
	DB	'overflow during division', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OMEBCKB@division?5by?5zero?$AA@
CONST	SEGMENT
??_C@_0BB@OMEBCKB@division?5by?5zero?$AA@ DB 'division by zero', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
CONST	ENDS
;	COMDAT long_true_divide
_TEXT	SEGMENT
negate$1$ = 128
v$ = 128
w$ = 136
rem$23015 = 144
long_true_divide PROC					; COMDAT

; 3499 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 53 10	 mov	 QWORD PTR [r11+16], rdx
  00007	41 54		 push	 r12
  00009	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 3500 :     PyLongObject *a, *b, *x;
; 3501 :     Py_ssize_t a_size, b_size, shift, extra_bits, diff, x_size, x_bits;
; 3502 :     digit mask, low;
; 3503 :     int inexact, negate, a_is_small, b_is_small;
; 3504 :     double dx, result;
; 3505 : 
; 3506 :     CHECK_BINOP(v, w);

  0000d	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00011	4c 8b e1	 mov	 r12, rcx
  00014	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0001e	0f 84 17 05 00
	00		 je	 $LN36@long_true_
  00024	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00028	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00032	0f 84 03 05 00
	00		 je	 $LN36@long_true_

; 3507 :     a = (PyLongObject *)v;
; 3508 :     b = (PyLongObject *)w;
; 3509 : 
; 3510 :     /*
; 3511 :        Method in a nutshell:
; 3512 : 
; 3513 :          0. reduce to case a, b > 0; filter out obvious underflow/overflow
; 3514 :          1. choose a suitable integer 'shift'
; 3515 :          2. use integer arithmetic to compute x = floor(2**-shift*a/b)
; 3516 :          3. adjust x for correct rounding
; 3517 :          4. convert x to a double dx with the same value
; 3518 :          5. return ldexp(dx, shift).
; 3519 : 
; 3520 :        In more detail:
; 3521 : 
; 3522 :        0. For any a, a/0 raises ZeroDivisionError; for nonzero b, 0/b
; 3523 :        returns either 0.0 or -0.0, depending on the sign of b.  For a and
; 3524 :        b both nonzero, ignore signs of a and b, and add the sign back in
; 3525 :        at the end.  Now write a_bits and b_bits for the bit lengths of a
; 3526 :        and b respectively (that is, a_bits = 1 + floor(log_2(a)); likewise
; 3527 :        for b).  Then
; 3528 : 
; 3529 :           2**(a_bits - b_bits - 1) < a/b < 2**(a_bits - b_bits + 1).
; 3530 : 
; 3531 :        So if a_bits - b_bits > DBL_MAX_EXP then a/b > 2**DBL_MAX_EXP and
; 3532 :        so overflows.  Similarly, if a_bits - b_bits < DBL_MIN_EXP -
; 3533 :        DBL_MANT_DIG - 1 then a/b underflows to 0.  With these cases out of
; 3534 :        the way, we can assume that
; 3535 : 
; 3536 :           DBL_MIN_EXP - DBL_MANT_DIG - 1 <= a_bits - b_bits <= DBL_MAX_EXP.
; 3537 : 
; 3538 :        1. The integer 'shift' is chosen so that x has the right number of
; 3539 :        bits for a double, plus two or three extra bits that will be used
; 3540 :        in the rounding decisions.  Writing a_bits and b_bits for the
; 3541 :        number of significant bits in a and b respectively, a
; 3542 :        straightforward formula for shift is:
; 3543 : 
; 3544 :           shift = a_bits - b_bits - DBL_MANT_DIG - 2
; 3545 : 
; 3546 :        This is fine in the usual case, but if a/b is smaller than the
; 3547 :        smallest normal float then it can lead to double rounding on an
; 3548 :        IEEE 754 platform, giving incorrectly rounded results.  So we
; 3549 :        adjust the formula slightly.  The actual formula used is:
; 3550 : 
; 3551 :            shift = MAX(a_bits - b_bits, DBL_MIN_EXP) - DBL_MANT_DIG - 2
; 3552 : 
; 3553 :        2. The quantity x is computed by first shifting a (left -shift bits
; 3554 :        if shift <= 0, right shift bits if shift > 0) and then dividing by
; 3555 :        b.  For both the shift and the division, we keep track of whether
; 3556 :        the result is inexact, in a flag 'inexact'; this information is
; 3557 :        needed at the rounding stage.
; 3558 : 
; 3559 :        With the choice of shift above, together with our assumption that
; 3560 :        a_bits - b_bits >= DBL_MIN_EXP - DBL_MANT_DIG - 1, it follows
; 3561 :        that x >= 1.
; 3562 : 
; 3563 :        3. Now x * 2**shift <= a/b < (x+1) * 2**shift.  We want to replace
; 3564 :        this with an exactly representable float of the form
; 3565 : 
; 3566 :           round(x/2**extra_bits) * 2**(extra_bits+shift).
; 3567 : 
; 3568 :        For float representability, we need x/2**extra_bits <
; 3569 :        2**DBL_MANT_DIG and extra_bits + shift >= DBL_MIN_EXP -
; 3570 :        DBL_MANT_DIG.  This translates to the condition:
; 3571 : 
; 3572 :           extra_bits >= MAX(x_bits, DBL_MIN_EXP - shift) - DBL_MANT_DIG
; 3573 : 
; 3574 :        To round, we just modify the bottom digit of x in-place; this can
; 3575 :        end up giving a digit with value > PyLONG_MASK, but that's not a
; 3576 :        problem since digits can hold values up to 2*PyLONG_MASK+1.
; 3577 : 
; 3578 :        With the original choices for shift above, extra_bits will always
; 3579 :        be 2 or 3.  Then rounding under the round-half-to-even rule, we
; 3580 :        round up iff the most significant of the extra bits is 1, and
; 3581 :        either: (a) the computation of x in step 2 had an inexact result,
; 3582 :        or (b) at least one other of the extra bits is 1, or (c) the least
; 3583 :        significant bit of x (above those to be rounded) is 1.
; 3584 : 
; 3585 :        4. Conversion to a double is straightforward; all floating-point
; 3586 :        operations involved in the conversion are exact, so there's no
; 3587 :        danger of rounding errors.
; 3588 : 
; 3589 :        5. Use ldexp(x, shift) to compute x*2**shift, the final result.
; 3590 :        The result will always be exactly representable as a double, except
; 3591 :        in the case that it overflows.  To avoid dependence on the exact
; 3592 :        behaviour of ldexp on overflow, we check for overflow before
; 3593 :        applying ldexp.  The result of ldexp is adjusted for sign before
; 3594 :        returning.
; 3595 :     */
; 3596 : 
; 3597 :     /* Reduce to case where a and b are both positive. */
; 3598 :     a_size = ABS(Py_SIZE(a));

  00038	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  0003c	49 89 5b 20	 mov	 QWORD PTR [r11+32], rbx
  00040	49 89 7b e0	 mov	 QWORD PTR [r11-32], rdi
  00044	4d 89 73 d0	 mov	 QWORD PTR [r11-48], r14
  00048	49 8b d8	 mov	 rbx, r8
  0004b	4d 85 c0	 test	 r8, r8
  0004e	79 03		 jns	 SHORT $LN44@long_true_
  00050	48 f7 db	 neg	 rbx
$LN44@long_true_:

; 3599 :     b_size = ABS(Py_SIZE(b));

  00053	48 8b 42 60	 mov	 rax, QWORD PTR [rdx+96]
  00057	48 8b f8	 mov	 rdi, rax
  0005a	48 85 c0	 test	 rax, rax
  0005d	79 03		 jns	 SHORT $LN46@long_true_
  0005f	48 f7 df	 neg	 rdi
$LN46@long_true_:

; 3600 :     negate = (Py_SIZE(a) < 0) ^ (Py_SIZE(b) < 0);

  00062	45 33 f6	 xor	 r14d, r14d
  00065	48 85 c0	 test	 rax, rax
  00068	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp
  0006d	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00072	45 8b ce	 mov	 r9d, r14d
  00075	41 0f 98 c1	 sets	 r9b
  00079	4d 85 c0	 test	 r8, r8
  0007c	41 8b c6	 mov	 eax, r14d
  0007f	4c 89 6c 24 50	 mov	 QWORD PTR [rsp+80], r13
  00084	0f 98 c0	 sets	 al
  00087	4c 89 7c 24 40	 mov	 QWORD PTR [rsp+64], r15
  0008c	44 33 c8	 xor	 r9d, eax
  0008f	44 89 8c 24 80
	00 00 00	 mov	 DWORD PTR negate$1$[rsp], r9d
  00097	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6

; 3601 :     if (b_size == 0) {

  0009c	48 85 ff	 test	 rdi, rdi
  0009f	75 1a		 jne	 SHORT $LN35@long_true_

; 3602 :         PyErr_SetString(PyExc_ZeroDivisionError,
; 3603 :                         "division by zero");

  000a1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ZeroDivisionError
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@OMEBCKB@division?5by?5zero?$AA@

; 3747 : 
; 3748 :   overflow:
; 3749 :     PyErr_SetString(PyExc_OverflowError,
; 3750 :                     "integer division result too large for a float");

  000af	e8 00 00 00 00	 call	 PyErr_SetString

; 3751 :   error:
; 3752 :     return NULL;

  000b4	33 c0		 xor	 eax, eax
  000b6	e9 22 04 00 00	 jmp	 $LN87@long_true_
$LN35@long_true_:

; 3604 :         goto error;
; 3605 :     }
; 3606 :     if (a_size == 0)

  000bb	48 85 db	 test	 rbx, rbx
  000be	0f 84 62 04 00
	00		 je	 $underflow_or_zero$22961

; 3607 :         goto underflow_or_zero;
; 3608 : 
; 3609 :     /* Fast path for a and b small (exactly representable in a double).
; 3610 :        Relies on floating-point division being correctly rounded; results
; 3611 :        may be subject to double rounding on x86 machines that operate with
; 3612 :        the x87 FPU set to 64-bit precision. */
; 3613 :     a_is_small = a_size <= MANT_DIG_DIGITS ||
; 3614 :         (a_size == MANT_DIG_DIGITS+1 &&
; 3615 :          a->ob_digit[MANT_DIG_DIGITS] >> MANT_DIG_BITS == 0);

  000c4	41 bf 01 00 00
	00		 mov	 r15d, 1
  000ca	49 3b df	 cmp	 rbx, r15
  000cd	7e 14		 jle	 SHORT $LN48@long_true_
  000cf	48 83 fb 02	 cmp	 rbx, 2
  000d3	75 09		 jne	 SHORT $LN47@long_true_
  000d5	f7 41 74 00 00
	80 ff		 test	 DWORD PTR [rcx+116], -8388608 ; ff800000H
  000dc	74 05		 je	 SHORT $LN48@long_true_
$LN47@long_true_:
  000de	41 8b ce	 mov	 ecx, r14d
  000e1	eb 03		 jmp	 SHORT $LN49@long_true_
$LN48@long_true_:
  000e3	41 8b cf	 mov	 ecx, r15d
$LN49@long_true_:

; 3616 :     b_is_small = b_size <= MANT_DIG_DIGITS ||
; 3617 :         (b_size == MANT_DIG_DIGITS+1 &&
; 3618 :          b->ob_digit[MANT_DIG_DIGITS] >> MANT_DIG_BITS == 0);

  000e6	49 3b ff	 cmp	 rdi, r15
  000e9	7e 14		 jle	 SHORT $LN51@long_true_
  000eb	48 83 ff 02	 cmp	 rdi, 2
  000ef	75 09		 jne	 SHORT $LN50@long_true_
  000f1	f7 42 74 00 00
	80 ff		 test	 DWORD PTR [rdx+116], -8388608 ; ff800000H
  000f8	74 05		 je	 SHORT $LN51@long_true_
$LN50@long_true_:
  000fa	41 8b c6	 mov	 eax, r14d
  000fd	eb 03		 jmp	 SHORT $LN52@long_true_
$LN51@long_true_:
  000ff	41 8b c7	 mov	 eax, r15d
$LN52@long_true_:

; 3619 :     if (a_is_small && b_is_small) {

  00102	85 c9		 test	 ecx, ecx
  00104	0f 84 9f 00 00
	00		 je	 $LN33@long_true_
  0010a	85 c0		 test	 eax, eax
  0010c	0f 84 97 00 00
	00		 je	 $LN33@long_true_

; 3620 :         double da, db;
; 3621 :         da = a->ob_digit[--a_size];
; 3622 :         while (a_size > 0)

  00112	f2 0f 10 1d 00
	00 00 00	 movsdx	 xmm3, QWORD PTR __real@41d0000000000000
  0011a	48 ff cb	 dec	 rbx
  0011d	66 0f ef c9	 pxor	 xmm1, xmm1
  00121	49 8d 4c 9c 70	 lea	 rcx, QWORD PTR [r12+rbx*4+112]
  00126	8b 01		 mov	 eax, DWORD PTR [rcx]
  00128	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  0012d	48 85 db	 test	 rbx, rbx
  00130	7e 2e		 jle	 SHORT $LN31@long_true_
  00132	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL32@long_true_:

; 3623 :             da = da * PyLong_BASE + a->ob_digit[--a_size];

  00140	8b 41 fc	 mov	 eax, DWORD PTR [rcx-4]
  00143	48 83 e9 04	 sub	 rcx, 4
  00147	66 0f ef c0	 pxor	 xmm0, xmm0
  0014b	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  0014f	48 ff cb	 dec	 rbx
  00152	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00157	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0015b	48 85 db	 test	 rbx, rbx
  0015e	7f e0		 jg	 SHORT $LL32@long_true_
$LN31@long_true_:

; 3624 :         db = b->ob_digit[--b_size];

  00160	48 ff cf	 dec	 rdi
  00163	66 0f ef d2	 pxor	 xmm2, xmm2
  00167	48 8d 4c ba 70	 lea	 rcx, QWORD PTR [rdx+rdi*4+112]
  0016c	8b 01		 mov	 eax, DWORD PTR [rcx]
  0016e	f2 48 0f 2a d0	 cvtsi2sd xmm2, rax

; 3625 :         while (b_size > 0)

  00173	48 85 ff	 test	 rdi, rdi
  00176	7e 28		 jle	 SHORT $LN29@long_true_
  00178	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL30@long_true_:

; 3626 :             db = db * PyLong_BASE + b->ob_digit[--b_size];

  00180	8b 41 fc	 mov	 eax, DWORD PTR [rcx-4]
  00183	48 83 e9 04	 sub	 rcx, 4
  00187	66 0f ef c0	 pxor	 xmm0, xmm0
  0018b	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  0018f	48 ff cf	 dec	 rdi
  00192	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00197	f2 0f 58 d0	 addsd	 xmm2, xmm0
  0019b	48 85 ff	 test	 rdi, rdi
  0019e	7f e0		 jg	 SHORT $LL30@long_true_
$LN29@long_true_:

; 3627 :         result = da / db;

  001a0	f2 0f 5e ca	 divsd	 xmm1, xmm2

; 3628 :         goto success;

  001a4	e9 1e 03 00 00	 jmp	 $success$22973
$LN33@long_true_:

; 3629 :     }
; 3630 : 
; 3631 :     /* Catch obvious cases of underflow and overflow */
; 3632 :     diff = a_size - b_size;

  001a9	48 8b f3	 mov	 rsi, rbx

; 3633 :     if (diff > PY_SSIZE_T_MAX/PyLong_SHIFT - 1)

  001ac	48 b8 43 44 44
	44 44 44 44 04	 mov	 rax, 307445734561825859	; 0444444444444443H
  001b6	48 2b f7	 sub	 rsi, rdi
  001b9	48 3b f0	 cmp	 rsi, rax
  001bc	0f 8f 4d 03 00
	00		 jg	 $overflow$22977

; 3634 :         /* Extreme overflow */
; 3635 :         goto overflow;
; 3636 :     else if (diff < 1 - PY_SSIZE_T_MAX/PyLong_SHIFT)

  001c2	48 b8 bd bb bb
	bb bb bb bb fb	 mov	 rax, -307445734561825859 ; fbbbbbbbbbbbbbbdH
  001cc	48 3b f0	 cmp	 rsi, rax
  001cf	0f 8c 51 03 00
	00		 jl	 $underflow_or_zero$22961

; 3637 :         /* Extreme underflow */
; 3638 :         goto underflow_or_zero;
; 3639 :     /* Next line is now safe from overflowing a Py_ssize_t */
; 3640 :     diff = diff * PyLong_SHIFT + bits_in_digit(a->ob_digit[a_size - 1]) -
; 3641 :         bits_in_digit(b->ob_digit[b_size - 1]);

  001d5	8b 4c ba 6c	 mov	 ecx, DWORD PTR [rdx+rdi*4+108]
  001d9	e8 00 00 00 00	 call	 bits_in_digit
  001de	48 63 c8	 movsxd	 rcx, eax
  001e1	48 6b f6 1e	 imul	 rsi, 30
  001e5	48 2b f1	 sub	 rsi, rcx
  001e8	41 8b 4c 9c 6c	 mov	 ecx, DWORD PTR [r12+rbx*4+108]
  001ed	e8 00 00 00 00	 call	 bits_in_digit
  001f2	48 63 c8	 movsxd	 rcx, eax
  001f5	48 03 f1	 add	 rsi, rcx

; 3642 :     /* Now diff = a_bits - b_bits. */
; 3643 :     if (diff > DBL_MAX_EXP)

  001f8	48 81 fe 00 04
	00 00		 cmp	 rsi, 1024		; 00000400H
  001ff	0f 8f 0a 03 00
	00		 jg	 $overflow$22977

; 3644 :         goto overflow;
; 3645 :     else if (diff < DBL_MIN_EXP - DBL_MANT_DIG - 1)

  00205	48 81 fe cd fb
	ff ff		 cmp	 rsi, -1075		; fffffffffffffbcdH
  0020c	0f 8c 14 03 00
	00		 jl	 $underflow_or_zero$22961

; 3646 :         goto underflow_or_zero;
; 3647 : 
; 3648 :     /* Choose value for shift; see comments for step 1 above. */
; 3649 :     shift = MAX(diff, DBL_MIN_EXP) - DBL_MANT_DIG - 2;

  00212	48 c7 c0 03 fc
	ff ff		 mov	 rax, -1021		; fffffffffffffc03H
  00219	48 3b f0	 cmp	 rsi, rax
  0021c	48 0f 4c f0	 cmovl	 rsi, rax
  00220	48 83 ee 37	 sub	 rsi, 55			; 00000037H

; 3650 : 
; 3651 :     inexact = 0;
; 3652 : 
; 3653 :     /* x = abs(a * 2**-shift) */
; 3654 :     if (shift <= 0) {

  00224	48 85 f6	 test	 rsi, rsi
  00227	0f 8f c2 00 00
	00		 jg	 $LN22@long_true_

; 3655 :         Py_ssize_t i, shift_digits = -shift / PyLong_SHIFT;

  0022d	48 b8 77 77 77
	77 77 77 77 77	 mov	 rax, 8608480567731124087 ; 7777777777777777H
  00237	48 f7 ee	 imul	 rsi
  0023a	48 8b ea	 mov	 rbp, rdx
  0023d	48 2b ee	 sub	 rbp, rsi
  00240	48 c1 fd 04	 sar	 rbp, 4
  00244	48 8b c5	 mov	 rax, rbp
  00247	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0024b	48 03 e8	 add	 rbp, rax

; 3656 :         digit rem;
; 3657 :         /* x = a << -shift */
; 3658 :         if (a_size >= PY_SSIZE_T_MAX - 1 - shift_digits) {

  0024e	48 b8 fe ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775806 ; 7ffffffffffffffeH
  00258	48 2b c5	 sub	 rax, rbp
  0025b	48 3b d8	 cmp	 rbx, rax
  0025e	7c 1a		 jl	 SHORT $LN21@long_true_

; 3747 : 
; 3748 :   overflow:
; 3749 :     PyErr_SetString(PyExc_OverflowError,
; 3750 :                     "integer division result too large for a float");

  00260	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00267	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@JGBBDDEJ@intermediate?5overflow?5during?5div@
  0026e	e8 00 00 00 00	 call	 PyErr_SetString

; 3751 :   error:
; 3752 :     return NULL;

  00273	33 c0		 xor	 eax, eax
  00275	e9 63 02 00 00	 jmp	 $LN87@long_true_
$LN21@long_true_:

; 3659 :             /* In practice, it's probably impossible to end up
; 3660 :                here.  Both a and b would have to be enormous,
; 3661 :                using close to SIZE_T_MAX bytes of memory each. */
; 3662 :             PyErr_SetString(PyExc_OverflowError,
; 3663 :                             "intermediate overflow during division");
; 3664 :             goto error;
; 3665 :         }
; 3666 :         x = _PyLong_New(a_size + shift_digits + 1);

  0027a	48 8d 4c 2b 01	 lea	 rcx, QWORD PTR [rbx+rbp+1]
  0027f	e8 00 00 00 00	 call	 _PyLong_New
  00284	4c 8b e8	 mov	 r13, rax

; 3667 :         if (x == NULL)

  00287	48 85 c0	 test	 rax, rax
  0028a	0f 84 92 02 00
	00		 je	 $error$22959

; 3668 :             goto error;
; 3669 :         for (i = 0; i < shift_digits; i++)

  00290	48 85 ed	 test	 rbp, rbp
  00293	7e 12		 jle	 SHORT $LN19@long_true_
  00295	4c 8b c5	 mov	 r8, rbp
  00298	48 8d 48 70	 lea	 rcx, QWORD PTR [rax+112]
  0029c	33 d2		 xor	 edx, edx
  0029e	49 c1 e0 02	 shl	 r8, 2
  002a2	e8 00 00 00 00	 call	 memset
$LN19@long_true_:

; 3670 :             x->ob_digit[i] = 0;
; 3671 :         rem = v_lshift(x->ob_digit + shift_digits, a->ob_digit,
; 3672 :                        a_size, -shift % PyLong_SHIFT);

  002a7	4c 8b ce	 mov	 r9, rsi
  002aa	48 b8 89 88 88
	88 88 88 88 88	 mov	 rax, -8608480567731124087 ; 8888888888888889H
  002b4	49 8d 4c ad 70	 lea	 rcx, QWORD PTR [r13+rbp*4+112]
  002b9	49 f7 d9	 neg	 r9
  002bc	4c 8b c3	 mov	 r8, rbx
  002bf	49 f7 e9	 imul	 r9
  002c2	49 03 d1	 add	 rdx, r9
  002c5	48 c1 fa 04	 sar	 rdx, 4
  002c9	48 8b c2	 mov	 rax, rdx
  002cc	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  002d0	48 03 d0	 add	 rdx, rax
  002d3	48 6b d2 1e	 imul	 rdx, 30
  002d7	4c 2b ca	 sub	 r9, rdx
  002da	49 8d 54 24 70	 lea	 rdx, QWORD PTR [r12+112]
  002df	e8 00 00 00 00	 call	 v_lshift

; 3673 :         x->ob_digit[a_size + shift_digits] = rem;

  002e4	48 8d 0c 2b	 lea	 rcx, QWORD PTR [rbx+rbp]
  002e8	41 89 44 8d 70	 mov	 DWORD PTR [r13+rcx*4+112], eax

; 3674 :     }
; 3675 :     else {

  002ed	eb 6e		 jmp	 SHORT $LN12@long_true_
$LN22@long_true_:

; 3676 :         Py_ssize_t shift_digits = shift / PyLong_SHIFT;

  002ef	48 b8 89 88 88
	88 88 88 88 88	 mov	 rax, -8608480567731124087 ; 8888888888888889H
  002f9	48 f7 ee	 imul	 rsi
  002fc	48 8d 2c 16	 lea	 rbp, QWORD PTR [rsi+rdx]
  00300	48 c1 fd 04	 sar	 rbp, 4
  00304	48 8b c5	 mov	 rax, rbp
  00307	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0030b	48 03 e8	 add	 rbp, rax

; 3677 :         digit rem;
; 3678 :         /* x = a >> shift */
; 3679 :         assert(a_size >= shift_digits);
; 3680 :         x = _PyLong_New(a_size - shift_digits);

  0030e	48 2b dd	 sub	 rbx, rbp
  00311	48 8b cb	 mov	 rcx, rbx
  00314	e8 00 00 00 00	 call	 _PyLong_New
  00319	4c 8b e8	 mov	 r13, rax

; 3681 :         if (x == NULL)

  0031c	48 85 c0	 test	 rax, rax
  0031f	0f 84 fd 01 00
	00		 je	 $error$22959

; 3682 :             goto error;
; 3683 :         rem = v_rshift(x->ob_digit, a->ob_digit + shift_digits,
; 3684 :                        a_size - shift_digits, shift % PyLong_SHIFT);

  00325	8b c5		 mov	 eax, ebp
  00327	44 8b ce	 mov	 r9d, esi
  0032a	4d 8d 64 ac 70	 lea	 r12, QWORD PTR [r12+rbp*4+112]
  0032f	49 8d 4d 70	 lea	 rcx, QWORD PTR [r13+112]
  00333	4c 8b c3	 mov	 r8, rbx
  00336	49 8b d4	 mov	 rdx, r12
  00339	6b c0 1e	 imul	 eax, 30
  0033c	44 2b c8	 sub	 r9d, eax
  0033f	e8 00 00 00 00	 call	 v_rshift

; 3685 :         /* set inexact if any of the bits shifted out is nonzero */
; 3686 :         if (rem)

  00344	85 c0		 test	 eax, eax

; 3687 :             inexact = 1;
; 3688 :         while (!inexact && shift_digits > 0)

  00346	eb 10		 jmp	 SHORT $LN90@long_true_
$LL13@long_true_:
  00348	48 85 ed	 test	 rbp, rbp
  0034b	7e 10		 jle	 SHORT $LN12@long_true_

; 3689 :             if (a->ob_digit[--shift_digits])

  0034d	49 83 ec 04	 sub	 r12, 4
  00351	48 ff cd	 dec	 rbp
  00354	45 39 34 24	 cmp	 DWORD PTR [r12], r14d
$LN90@long_true_:

; 3687 :             inexact = 1;
; 3688 :         while (!inexact && shift_digits > 0)

  00358	74 ee		 je	 SHORT $LL13@long_true_

; 3690 :                 inexact = 1;

  0035a	45 8b f7	 mov	 r14d, r15d
$LN12@long_true_:

; 3691 :     }
; 3692 :     long_normalize(x);

  0035d	49 8b cd	 mov	 rcx, r13
  00360	e8 00 00 00 00	 call	 long_normalize

; 3693 :     x_size = Py_SIZE(x);
; 3694 : 
; 3695 :     /* x //= b. If the remainder is nonzero, set inexact.  We own the only
; 3696 :        reference to x, so it's safe to modify it in-place. */
; 3697 :     if (b_size == 1) {
; 3698 :         digit rem = inplace_divrem1(x->ob_digit, x->ob_digit, x_size,
; 3699 :                               b->ob_digit[0]);

  00365	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR w$[rsp]
  0036d	49 3b ff	 cmp	 rdi, r15
  00370	75 29		 jne	 SHORT $LN10@long_true_
  00372	44 8b 4a 70	 mov	 r9d, DWORD PTR [rdx+112]
  00376	4d 8b 45 60	 mov	 r8, QWORD PTR [r13+96]
  0037a	49 8d 4d 70	 lea	 rcx, QWORD PTR [r13+112]
  0037e	48 8b d1	 mov	 rdx, rcx
  00381	e8 00 00 00 00	 call	 inplace_divrem1

; 3700 :         long_normalize(x);

  00386	49 8b cd	 mov	 rcx, r13
  00389	44 8b d8	 mov	 r11d, eax
  0038c	e8 00 00 00 00	 call	 long_normalize

; 3701 :         if (rem)

  00391	45 85 db	 test	 r11d, r11d
  00394	74 3f		 je	 SHORT $LN8@long_true_

; 3702 :             inexact = 1;

  00396	45 8b f7	 mov	 r14d, r15d

; 3703 :     }
; 3704 :     else {

  00399	eb 3a		 jmp	 SHORT $LN8@long_true_
$LN10@long_true_:

; 3705 :         PyLongObject *div, *rem;
; 3706 :         div = x_divrem(x, b, &rem);

  0039b	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR rem$23015[rsp]
  003a3	e8 00 00 00 00	 call	 x_divrem

; 3707 :         Py_DECREF(x);

  003a8	49 8b cd	 mov	 rcx, r13
  003ab	48 8b d8	 mov	 rbx, rax
  003ae	e8 00 00 00 00	 call	 _Py_DecRef

; 3708 :         x = div;

  003b3	4c 8b eb	 mov	 r13, rbx

; 3709 :         if (x == NULL)

  003b6	48 85 db	 test	 rbx, rbx
  003b9	0f 84 63 01 00
	00		 je	 $error$22959

; 3710 :             goto error;
; 3711 :         if (Py_SIZE(rem))

  003bf	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rem$23015[rsp]
  003c7	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  003cc	45 0f 45 f7	 cmovne	 r14d, r15d

; 3712 :             inexact = 1;
; 3713 :         Py_DECREF(rem);

  003d0	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@long_true_:

; 3714 :     }
; 3715 :     x_size = ABS(Py_SIZE(x));

  003d5	4d 8b 45 60	 mov	 r8, QWORD PTR [r13+96]
  003d9	4d 85 c0	 test	 r8, r8
  003dc	79 03		 jns	 SHORT $LN53@long_true_
  003de	49 f7 d8	 neg	 r8
$LN53@long_true_:

; 3716 :     assert(x_size > 0); /* result of division is never zero */
; 3717 :     x_bits = (x_size-1)*PyLong_SHIFT+bits_in_digit(x->ob_digit[x_size-1]);

  003e1	43 8b 4c 85 6c	 mov	 ecx, DWORD PTR [r13+r8*4+108]
  003e6	e8 00 00 00 00	 call	 bits_in_digit
  003eb	48 63 c8	 movsxd	 rcx, eax
  003ee	49 8b c0	 mov	 rax, r8
  003f1	48 6b c0 1e	 imul	 rax, 30
  003f5	48 8d 5c 01 e2	 lea	 rbx, QWORD PTR [rcx+rax-30]

; 3718 : 
; 3719 :     /* The number of extra bits that have to be rounded away. */
; 3720 :     extra_bits = MAX(x_bits, DBL_MIN_EXP - shift) - DBL_MANT_DIG;

  003fa	48 c7 c1 03 fc
	ff ff		 mov	 rcx, -1021		; fffffffffffffc03H
  00401	48 2b ce	 sub	 rcx, rsi
  00404	48 8b c3	 mov	 rax, rbx
  00407	48 3b d9	 cmp	 rbx, rcx
  0040a	48 0f 4c c1	 cmovl	 rax, rcx

; 3721 :     assert(extra_bits == 2 || extra_bits == 3);
; 3722 : 
; 3723 :     /* Round by directly modifying the low digit of x. */
; 3724 :     mask = (digit)1 << (extra_bits - 1);

  0040e	8d 48 ca	 lea	 ecx, DWORD PTR [rax-54]
  00411	41 d3 e7	 shl	 r15d, cl

; 3725 :     low = x->ob_digit[0] | inexact;

  00414	41 8b 4d 70	 mov	 ecx, DWORD PTR [r13+112]
  00418	41 0b ce	 or	 ecx, r14d

; 3726 :     if (low & mask && low & (3*mask-1))

  0041b	41 85 cf	 test	 ecx, r15d
  0041e	74 0c		 je	 SHORT $LN5@long_true_
  00420	43 8d 44 7f ff	 lea	 eax, DWORD PTR [r15+r15*2-1]
  00425	85 c1		 test	 eax, ecx
  00427	74 03		 je	 SHORT $LN5@long_true_

; 3727 :         low += mask;

  00429	41 03 cf	 add	 ecx, r15d
$LN5@long_true_:

; 3728 :     x->ob_digit[0] = low & ~(mask-1U);

  0042c	41 8d 47 ff	 lea	 eax, DWORD PTR [r15-1]

; 3729 : 
; 3730 :     /* Convert x to a double dx; the conversion is exact. */
; 3731 :     dx = x->ob_digit[--x_size];

  00430	49 ff c8	 dec	 r8
  00433	66 0f ef f6	 pxor	 xmm6, xmm6
  00437	f7 d0		 not	 eax
  00439	23 c1		 and	 eax, ecx
  0043b	4b 8d 4c 85 70	 lea	 rcx, QWORD PTR [r13+r8*4+112]
  00440	41 89 45 70	 mov	 DWORD PTR [r13+112], eax
  00444	8b 01		 mov	 eax, DWORD PTR [rcx]
  00446	f2 48 0f 2a f0	 cvtsi2sd xmm6, rax

; 3732 :     while (x_size > 0)

  0044b	4d 85 c0	 test	 r8, r8
  0044e	7e 30		 jle	 SHORT $LN3@long_true_

; 3728 :     x->ob_digit[0] = low & ~(mask-1U);

  00450	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@41d0000000000000
  00458	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@long_true_:

; 3733 :         dx = dx * PyLong_BASE + x->ob_digit[--x_size];

  00460	8b 41 fc	 mov	 eax, DWORD PTR [rcx-4]
  00463	48 83 e9 04	 sub	 rcx, 4
  00467	66 0f ef c0	 pxor	 xmm0, xmm0
  0046b	f2 0f 59 f1	 mulsd	 xmm6, xmm1
  0046f	49 ff c8	 dec	 r8
  00472	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00477	f2 0f 58 f0	 addsd	 xmm6, xmm0
  0047b	4d 85 c0	 test	 r8, r8
  0047e	7f e0		 jg	 SHORT $LL4@long_true_
$LN3@long_true_:

; 3734 :     Py_DECREF(x);

  00480	49 8b cd	 mov	 rcx, r13
  00483	e8 00 00 00 00	 call	 _Py_DecRef

; 3735 : 
; 3736 :     /* Check whether ldexp result will overflow a double. */
; 3737 :     if (shift + x_bits >= DBL_MAX_EXP &&
; 3738 :         (shift + x_bits > DBL_MAX_EXP || dx == ldexp(1.0, (int)x_bits)))

  00488	4c 8d 1c 33	 lea	 r11, QWORD PTR [rbx+rsi]
  0048c	49 81 fb 00 04
	00 00		 cmp	 r11, 1024		; 00000400H
  00493	7c 1a		 jl	 SHORT $LN2@long_true_
  00495	7f 78		 jg	 SHORT $overflow$22977
  00497	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  0049f	8b d3		 mov	 edx, ebx
  004a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  004a7	66 0f 2e f0	 ucomisd xmm6, xmm0
  004ab	7a 02		 jp	 SHORT $LN2@long_true_
  004ad	74 60		 je	 SHORT $overflow$22977
$LN2@long_true_:

; 3739 :         goto overflow;
; 3740 :     result = ldexp(dx, (int)shift);

  004af	66 0f 28 c6	 movapd	 xmm0, xmm6
  004b3	8b d6		 mov	 edx, esi
  004b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  004bb	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR negate$1$[rsp]
  004c3	66 0f 28 c8	 movapd	 xmm1, xmm0
$success$22973:

; 3741 : 
; 3742 :   success:
; 3743 :     return PyFloat_FromDouble(negate ? -result : result);

  004c7	45 85 c9	 test	 r9d, r9d
  004ca	74 08		 je	 SHORT $LN57@long_true_
  004cc	66 0f 57 0d 00
	00 00 00	 xorpd	 xmm1, QWORD PTR __mask@@NegDouble@
$LN57@long_true_:
  004d4	66 0f 28 c1	 movapd	 xmm0, xmm1
$LN60@long_true_:
  004d8	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN87@long_true_:
  004dd	4c 8b 7c 24 40	 mov	 r15, QWORD PTR [rsp+64]
  004e2	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  004e7	4c 8b 6c 24 50	 mov	 r13, QWORD PTR [rsp+80]
  004ec	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  004f1	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  004f6	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  004fb	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  00503	4c 8b 74 24 48	 mov	 r14, QWORD PTR [rsp+72]

; 3753 : }

  00508	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0050c	41 5c		 pop	 r12
  0050e	c3		 ret	 0
$overflow$22977:

; 3747 : 
; 3748 :   overflow:
; 3749 :     PyErr_SetString(PyExc_OverflowError,
; 3750 :                     "integer division result too large for a float");

  0050f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00516	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@FMAPPLED@integer?5division?5result?5too?5larg@
  0051d	e8 00 00 00 00	 call	 PyErr_SetString
$error$22959:

; 3751 :   error:
; 3752 :     return NULL;

  00522	33 c0		 xor	 eax, eax
  00524	eb b7		 jmp	 SHORT $LN87@long_true_
$underflow_or_zero$22961:

; 3744 : 
; 3745 :   underflow_or_zero:
; 3746 :     return PyFloat_FromDouble(negate ? -0.0 : 0.0);

  00526	45 85 c9	 test	 r9d, r9d
  00529	74 0a		 je	 SHORT $LN59@long_true_
  0052b	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@8000000000000000
  00533	eb a3		 jmp	 SHORT $LN60@long_true_
$LN59@long_true_:
  00535	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00539	eb 9d		 jmp	 SHORT $LN60@long_true_
$LN36@long_true_:

; 3500 :     PyLongObject *a, *b, *x;
; 3501 :     Py_ssize_t a_size, b_size, shift, extra_bits, diff, x_size, x_bits;
; 3502 :     digit mask, low;
; 3503 :     int inexact, negate, a_is_small, b_is_small;
; 3504 :     double dx, result;
; 3505 : 
; 3506 :     CHECK_BINOP(v, w);

  0053b	e8 00 00 00 00	 call	 _Py_PXCTX
  00540	85 c0		 test	 eax, eax
  00542	75 3c		 jne	 SHORT $LN62@long_true_
  00544	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  0054b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00552	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00559	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0055f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00567	e8 00 00 00 00	 call	 _PyParallel_Guard
  0056c	85 c0		 test	 eax, eax
  0056e	75 09		 jne	 SHORT $LN61@long_true_
  00570	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00577	74 07		 je	 SHORT $LN62@long_true_
$LN61@long_true_:
  00579	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN62@long_true_:
  00580	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 3753 : }

  00587	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0058b	41 5c		 pop	 r12
  0058d	c3		 ret	 0
long_true_divide ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_invert DD imagerel long_invert
	DD	imagerel long_invert+97
	DD	imagerel $unwind$long_invert
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$long_invert DD imagerel long_invert+97
	DD	imagerel long_invert+155
	DD	imagerel $chain$0$long_invert
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$long_invert DD imagerel long_invert+155
	DD	imagerel long_invert+184
	DD	imagerel $chain$2$long_invert
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$long_invert DD 020021H
	DD	067400H
	DD	imagerel long_invert
	DD	imagerel long_invert+97
	DD	imagerel $unwind$long_invert
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$long_invert DD 020521H
	DD	067405H
	DD	imagerel long_invert
	DD	imagerel long_invert+97
	DD	imagerel $unwind$long_invert
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_invert DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT long_invert
_TEXT	SEGMENT
v$ = 48
long_invert PROC					; COMDAT

; 3984 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3985 :     /* Implement ~x as -(x+1) */
; 3986 :     PyLongObject *x;
; 3987 :     PyLongObject *w;
; 3988 :     if (ABS(Py_SIZE(v)) <=1)

  00006	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	48 8b d0	 mov	 rdx, rax
  00010	48 85 c0	 test	 rax, rax
  00013	79 03		 jns	 SHORT $LN7@long_inver
  00015	48 f7 da	 neg	 rdx
$LN7@long_inver:
  00018	48 83 fa 01	 cmp	 rdx, 1
  0001c	7f 3e		 jg	 SHORT $LN3@long_inver

; 3989 :         return PyLong_FromLong(-(MEDIUM_VALUE(v)+1));

  0001e	48 85 c0	 test	 rax, rax
  00021	79 14		 jns	 SHORT $LN13@long_inver
  00023	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00026	83 c9 ff	 or	 ecx, -1
  00029	f7 d8		 neg	 eax
  0002b	2b c8		 sub	 ecx, eax

; 3999 : }

  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5b		 pop	 rbx
  00032	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN13@long_inver:

; 3989 :         return PyLong_FromLong(-(MEDIUM_VALUE(v)+1));

  00037	75 11		 jne	 SHORT $LN8@long_inver
  00039	33 c0		 xor	 eax, eax
  0003b	83 c9 ff	 or	 ecx, -1
  0003e	2b c8		 sub	 ecx, eax

; 3999 : }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5b		 pop	 rbx
  00045	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN8@long_inver:

; 3989 :         return PyLong_FromLong(-(MEDIUM_VALUE(v)+1));

  0004a	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  0004d	83 c9 ff	 or	 ecx, -1
  00050	2b c8		 sub	 ecx, eax

; 3999 : }

  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5b		 pop	 rbx
  00057	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN3@long_inver:

; 3990 :     w = (PyLongObject *)PyLong_FromLong(1L);

  0005c	b9 01 00 00 00	 mov	 ecx, 1
  00061	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00066	e8 00 00 00 00	 call	 PyLong_FromLong
  0006b	48 8b f8	 mov	 rdi, rax

; 3991 :     if (w == NULL)

  0006e	48 85 c0	 test	 rax, rax

; 3992 :         return NULL;

  00071	74 1b		 je	 SHORT $LN14@long_inver

; 3993 :     x = (PyLongObject *) long_add(v, w);

  00073	48 8b d0	 mov	 rdx, rax
  00076	48 8b cb	 mov	 rcx, rbx
  00079	e8 00 00 00 00	 call	 long_add

; 3994 :     Py_DECREF(w);

  0007e	48 8b cf	 mov	 rcx, rdi
  00081	48 8b d8	 mov	 rbx, rax
  00084	e8 00 00 00 00	 call	 _Py_DecRef

; 3995 :     if (x == NULL)

  00089	48 85 db	 test	 rbx, rbx
  0008c	75 0d		 jne	 SHORT $LN1@long_inver
$LN14@long_inver:

; 3996 :         return NULL;

  0008e	33 c0		 xor	 eax, eax
  00090	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 3999 : }

  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5b		 pop	 rbx
  0009a	c3		 ret	 0
$LN1@long_inver:

; 3997 :     Py_SIZE(x) = -(Py_SIZE(x));

  0009b	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]

; 3998 :     return (PyObject *)maybe_small_long(x);

  0009f	48 8b cb	 mov	 rcx, rbx
  000a2	48 f7 d8	 neg	 rax
  000a5	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax
  000a9	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 3999 : }

  000ae	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b2	5b		 pop	 rbx
  000b3	e9 00 00 00 00	 jmp	 maybe_small_long
long_invert ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_neg DD imagerel long_neg
	DD	imagerel long_neg+113
	DD	imagerel $unwind$long_neg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_neg DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT long_neg
_TEXT	SEGMENT
v$ = 48
long_neg PROC						; COMDAT

; 4003 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4004 :     PyLongObject *z;
; 4005 :     if (ABS(Py_SIZE(v)) <= 1)

  00006	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	48 8b c8	 mov	 rcx, rax
  00010	48 85 c0	 test	 rax, rax
  00013	79 03		 jns	 SHORT $LN6@long_neg
  00015	48 f7 d9	 neg	 rcx
$LN6@long_neg:
  00018	48 83 f9 01	 cmp	 rcx, 1
  0001c	7f 35		 jg	 SHORT $LN2@long_neg

; 4006 :         return PyLong_FromLong(-MEDIUM_VALUE(v));

  0001e	48 85 c0	 test	 rax, rax
  00021	79 11		 jns	 SHORT $LN11@long_neg
  00023	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00026	f7 d9		 neg	 ecx
  00028	f7 d9		 neg	 ecx

; 4010 :     return (PyObject *)z;
; 4011 : }

  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5b		 pop	 rbx
  0002f	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN11@long_neg:

; 4006 :         return PyLong_FromLong(-MEDIUM_VALUE(v));

  00034	75 0e		 jne	 SHORT $LN7@long_neg
  00036	33 c9		 xor	 ecx, ecx
  00038	f7 d9		 neg	 ecx

; 4010 :     return (PyObject *)z;
; 4011 : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN7@long_neg:

; 4006 :         return PyLong_FromLong(-MEDIUM_VALUE(v));

  00044	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00047	f7 d9		 neg	 ecx

; 4010 :     return (PyObject *)z;
; 4011 : }

  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5b		 pop	 rbx
  0004e	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN2@long_neg:

; 4007 :     z = (PyLongObject *)_PyLong_Copy(v);

  00053	48 8b cb	 mov	 rcx, rbx
  00056	e8 00 00 00 00	 call	 _PyLong_Copy

; 4008 :     if (z != NULL)

  0005b	48 85 c0	 test	 rax, rax
  0005e	74 0b		 je	 SHORT $LN1@long_neg

; 4009 :         Py_SIZE(z) = -(Py_SIZE(v));

  00060	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00064	48 f7 d9	 neg	 rcx
  00067	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx
$LN1@long_neg:

; 4010 :     return (PyObject *)z;
; 4011 : }

  0006b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006f	5b		 pop	 rbx
  00070	c3		 ret	 0
long_neg ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT long_bool
_TEXT	SEGMENT
v$ = 8
long_bool PROC						; COMDAT

; 4025 :     return Py_SIZE(v) != 0;

  00000	33 c0		 xor	 eax, eax
  00002	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  00006	0f 95 c0	 setne	 al

; 4026 : }

  00009	c3		 ret	 0
long_bool ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@NDIOBNCG@negative?5shift?5count?$AA@	; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_rshift DD imagerel long_rshift
	DD	imagerel long_rshift+639
	DD	imagerel $unwind$long_rshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_rshift DD 060c01H
	DD	0f340cH
	DD	07008920cH
	DD	050066007H
xdata	ENDS
;	COMDAT ??_C@_0BF@NDIOBNCG@negative?5shift?5count?$AA@
CONST	SEGMENT
??_C@_0BF@NDIOBNCG@negative?5shift?5count?$AA@ DB 'negative shift count', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
CONST	ENDS
;	COMDAT long_rshift
_TEXT	SEGMENT
loshift$1$ = 48
hishift$1$ = 56
z$1$ = 64
lomask$1$ = 112
a$ = 112
b$ = 120
himask$1$ = 128
wordshift$1$ = 136
long_rshift PROC					; COMDAT

; 4030 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 4031 :     PyLongObject *z = NULL;
; 4032 :     Py_ssize_t shiftby, newsize, wordshift, loshift, hishift, i, j;
; 4033 :     digit lomask, himask;
; 4034 : 
; 4035 :     CHECK_BINOP(a, b);

  0000c	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00010	33 ff		 xor	 edi, edi
  00012	48 8b da	 mov	 rbx, rdx
  00015	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0001f	48 8b e9	 mov	 rbp, rcx
  00022	8b f7		 mov	 esi, edi
  00024	0f 84 fc 01 00
	00		 je	 $LN14@long_rshif
  0002a	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0002e	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00038	0f 84 e8 01 00
	00		 je	 $LN14@long_rshif

; 4036 : 
; 4037 :     if (Py_SIZE(a) < 0) {

  0003e	48 39 79 60	 cmp	 QWORD PTR [rcx+96], rdi
  00042	7d 57		 jge	 SHORT $LN13@long_rshif

; 4038 :         /* Right shifting negative numbers is harder */
; 4039 :         PyLongObject *a1, *a2;
; 4040 :         a1 = (PyLongObject *) long_invert(a);

  00044	e8 00 00 00 00	 call	 long_invert
  00049	48 8b f8	 mov	 rdi, rax

; 4041 :         if (a1 == NULL)

  0004c	48 85 c0	 test	 rax, rax
  0004f	0f 84 bd 01 00
	00		 je	 $rshift_error$23466

; 4042 :             goto rshift_error;
; 4043 :         a2 = (PyLongObject *) long_rshift(a1, b);

  00055	48 8b d3	 mov	 rdx, rbx
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 long_rshift

; 4044 :         Py_DECREF(a1);

  00060	48 8b cf	 mov	 rcx, rdi
  00063	48 8b d8	 mov	 rbx, rax
  00066	e8 00 00 00 00	 call	 _Py_DecRef

; 4045 :         if (a2 == NULL)

  0006b	48 85 db	 test	 rbx, rbx
  0006e	0f 84 9e 01 00
	00		 je	 $rshift_error$23466

; 4046 :             goto rshift_error;
; 4047 :         z = (PyLongObject *) long_invert(a2);

  00074	48 8b cb	 mov	 rcx, rbx
  00077	e8 00 00 00 00	 call	 long_invert

; 4048 :         Py_DECREF(a2);

  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	48 8b f0	 mov	 rsi, rax
  00082	e8 00 00 00 00	 call	 _Py_DecRef

; 4078 :     }
; 4079 :   rshift_error:
; 4080 :     return (PyObject *) maybe_small_long(z);

  00087	48 8b ce	 mov	 rcx, rsi

; 4081 : 
; 4082 : }

  0008a	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  0008f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00093	5f		 pop	 rdi
  00094	5e		 pop	 rsi
  00095	5d		 pop	 rbp
  00096	e9 00 00 00 00	 jmp	 maybe_small_long
$LN13@long_rshif:

; 4049 :     }
; 4050 :     else {
; 4051 :         shiftby = PyLong_AsSsize_t((PyObject *)b);

  0009b	48 8b ca	 mov	 rcx, rdx
  0009e	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  000a3	4c 8b c0	 mov	 r8, rax

; 4052 :         if (shiftby == -1L && PyErr_Occurred())

  000a6	48 83 f8 ff	 cmp	 rax, -1
  000aa	75 10		 jne	 SHORT $LN9@long_rshif
  000ac	e8 00 00 00 00	 call	 PyErr_Occurred
  000b1	48 85 c0	 test	 rax, rax
  000b4	0f 85 58 01 00
	00		 jne	 $rshift_error$23466

; 4053 :             goto rshift_error;
; 4054 :         if (shiftby < 0) {

  000ba	eb 05		 jmp	 SHORT $LN29@long_rshif
$LN9@long_rshif:
  000bc	48 85 c0	 test	 rax, rax
  000bf	79 27		 jns	 SHORT $LN8@long_rshif
$LN29@long_rshif:

; 4055 :             PyErr_SetString(PyExc_ValueError,
; 4056 :                             "negative shift count");

  000c1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@NDIOBNCG@negative?5shift?5count?$AA@
  000cf	e8 00 00 00 00	 call	 PyErr_SetString

; 4078 :     }
; 4079 :   rshift_error:
; 4080 :     return (PyObject *) maybe_small_long(z);

  000d4	48 8b ce	 mov	 rcx, rsi

; 4081 : 
; 4082 : }

  000d7	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  000dc	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000e0	5f		 pop	 rdi
  000e1	5e		 pop	 rsi
  000e2	5d		 pop	 rbp
  000e3	e9 00 00 00 00	 jmp	 maybe_small_long
$LN8@long_rshif:

; 4057 :             goto rshift_error;
; 4058 :         }
; 4059 :         wordshift = shiftby / PyLong_SHIFT;
; 4060 :         newsize = ABS(Py_SIZE(a)) - wordshift;

  000e8	48 8b 5d 60	 mov	 rbx, QWORD PTR [rbp+96]
  000ec	48 b8 89 88 88
	88 88 88 88 88	 mov	 rax, -8608480567731124087 ; 8888888888888889H
  000f6	49 f7 e8	 imul	 r8
  000f9	49 8d 0c 10	 lea	 rcx, QWORD PTR [r8+rdx]
  000fd	48 c1 f9 04	 sar	 rcx, 4
  00101	48 8b c1	 mov	 rax, rcx
  00104	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00108	48 03 c8	 add	 rcx, rax
  0010b	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR wordshift$1$[rsp], rcx
  00113	48 85 db	 test	 rbx, rbx
  00116	79 03		 jns	 SHORT $LN21@long_rshif
  00118	48 f7 db	 neg	 rbx
$LN21@long_rshif:
  0011b	48 2b d9	 sub	 rbx, rcx

; 4061 :         if (newsize <= 0)

  0011e	48 85 db	 test	 rbx, rbx
  00121	7f 13		 jg	 SHORT $LN7@long_rshif

; 4062 :             return PyLong_FromLong(0);

  00123	33 c9		 xor	 ecx, ecx

; 4081 : 
; 4082 : }

  00125	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  0012a	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0012e	5f		 pop	 rdi
  0012f	5e		 pop	 rsi
  00130	5d		 pop	 rbp
  00131	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN7@long_rshif:

; 4063 :         loshift = shiftby % PyLong_SHIFT;

  00136	48 8b c1	 mov	 rax, rcx
  00139	48 6b c0 1e	 imul	 rax, 30
  0013d	4c 2b c0	 sub	 r8, rax

; 4064 :         hishift = PyLong_SHIFT - loshift;

  00140	b8 1e 00 00 00	 mov	 eax, 30
  00145	49 2b c0	 sub	 rax, r8
  00148	4c 89 44 24 30	 mov	 QWORD PTR loshift$1$[rsp], r8

; 4065 :         lomask = ((digit)1 << hishift) - 1;

  0014d	48 8b c8	 mov	 rcx, rax
  00150	48 89 44 24 38	 mov	 QWORD PTR hishift$1$[rsp], rax
  00155	b8 01 00 00 00	 mov	 eax, 1
  0015a	d3 e0		 shl	 eax, cl

; 4066 :         himask = PyLong_MASK ^ lomask;
; 4067 :         z = _PyLong_New(newsize);

  0015c	48 8b cb	 mov	 rcx, rbx
  0015f	ff c8		 dec	 eax
  00161	89 44 24 70	 mov	 DWORD PTR lomask$1$[rsp], eax
  00165	35 ff ff ff 3f	 xor	 eax, 1073741823		; 3fffffffH
  0016a	89 84 24 80 00
	00 00		 mov	 DWORD PTR himask$1$[rsp], eax
  00171	e8 00 00 00 00	 call	 _PyLong_New
  00176	48 8b f0	 mov	 rsi, rax
  00179	48 89 44 24 40	 mov	 QWORD PTR z$1$[rsp], rax

; 4068 :         if (z == NULL)

  0017e	48 85 c0	 test	 rax, rax
  00181	0f 84 8b 00 00
	00		 je	 $rshift_error$23466

; 4069 :             goto rshift_error;
; 4070 :         if (Py_SIZE(a) < 0)

  00187	48 39 7d 60	 cmp	 QWORD PTR [rbp+96], rdi
  0018b	7d 0b		 jge	 SHORT $LN5@long_rshif

; 4071 :             Py_SIZE(z) = -(Py_SIZE(z));

  0018d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00191	48 f7 d8	 neg	 rax
  00194	48 89 46 60	 mov	 QWORD PTR [rsi+96], rax
$LN5@long_rshif:

; 4072 :         for (i = 0, j = wordshift; i < newsize; i++, j++) {

  00198	48 85 db	 test	 rbx, rbx
  0019b	7e 6a		 jle	 SHORT $LN2@long_rshif
  0019d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR wordshift$1$[rsp]
  001a5	4c 8b 4c 24 30	 mov	 r9, QWORD PTR loshift$1$[rsp]
  001aa	44 8b 5c 24 70	 mov	 r11d, DWORD PTR lomask$1$[rsp]
  001af	4c 8d 14 85 04
	00 00 00	 lea	 r10, QWORD PTR [rax*4+4]
  001b7	48 8d 56 70	 lea	 rdx, QWORD PTR [rsi+112]
  001bb	4c 2b d6	 sub	 r10, rsi
  001be	8b b4 24 80 00
	00 00		 mov	 esi, DWORD PTR himask$1$[rsp]
  001c5	4c 03 d5	 add	 r10, rbp
  001c8	48 8b 6c 24 38	 mov	 rbp, QWORD PTR hishift$1$[rsp]
  001cd	0f 1f 00	 npad	 3
$LL4@long_rshif:

; 4073 :             z->ob_digit[i] = (a->ob_digit[j] >> loshift) & lomask;

  001d0	45 8b 44 12 fc	 mov	 r8d, DWORD PTR [r10+rdx-4]
  001d5	49 8b c9	 mov	 rcx, r9
  001d8	41 d3 e8	 shr	 r8d, cl
  001db	45 23 c3	 and	 r8d, r11d

; 4074 :             if (i+1 < newsize)

  001de	48 ff c7	 inc	 rdi
  001e1	44 89 02	 mov	 DWORD PTR [rdx], r8d
  001e4	48 3b fb	 cmp	 rdi, rbx
  001e7	7d 10		 jge	 SHORT $LN3@long_rshif

; 4075 :                 z->ob_digit[i] |= (a->ob_digit[j+1] << hishift) & himask;

  001e9	41 8b 04 12	 mov	 eax, DWORD PTR [r10+rdx]
  001ed	48 8b cd	 mov	 rcx, rbp
  001f0	d3 e0		 shl	 eax, cl
  001f2	23 c6		 and	 eax, esi
  001f4	41 0b c0	 or	 eax, r8d
  001f7	89 02		 mov	 DWORD PTR [rdx], eax
$LN3@long_rshif:

; 4072 :         for (i = 0, j = wordshift; i < newsize; i++, j++) {

  001f9	48 83 c2 04	 add	 rdx, 4
  001fd	48 3b fb	 cmp	 rdi, rbx
  00200	7c ce		 jl	 SHORT $LL4@long_rshif
  00202	48 8b 74 24 40	 mov	 rsi, QWORD PTR z$1$[rsp]
$LN2@long_rshif:

; 4076 :         }
; 4077 :         z = long_normalize(z);

  00207	48 8b ce	 mov	 rcx, rsi
  0020a	e8 00 00 00 00	 call	 long_normalize
  0020f	48 8b f0	 mov	 rsi, rax
$rshift_error$23466:

; 4078 :     }
; 4079 :   rshift_error:
; 4080 :     return (PyObject *) maybe_small_long(z);

  00212	48 8b ce	 mov	 rcx, rsi

; 4081 : 
; 4082 : }

  00215	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  0021a	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0021e	5f		 pop	 rdi
  0021f	5e		 pop	 rsi
  00220	5d		 pop	 rbp
  00221	e9 00 00 00 00	 jmp	 maybe_small_long
$LN14@long_rshif:

; 4031 :     PyLongObject *z = NULL;
; 4032 :     Py_ssize_t shiftby, newsize, wordshift, loshift, hishift, i, j;
; 4033 :     digit lomask, himask;
; 4034 : 
; 4035 :     CHECK_BINOP(a, b);

  00226	e8 00 00 00 00	 call	 _Py_PXCTX
  0022b	85 c0		 test	 eax, eax
  0022d	75 3c		 jne	 SHORT $LN24@long_rshif
  0022f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00236	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0023d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00244	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0024a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00252	e8 00 00 00 00	 call	 _PyParallel_Guard
  00257	85 c0		 test	 eax, eax
  00259	75 09		 jne	 SHORT $LN23@long_rshif
  0025b	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00262	74 07		 je	 SHORT $LN24@long_rshif
$LN23@long_rshif:
  00264	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN24@long_rshif:
  0026b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 4081 : 
; 4082 : }

  00272	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  00277	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0027b	5f		 pop	 rdi
  0027c	5e		 pop	 rsi
  0027d	5d		 pop	 rbp
  0027e	c3		 ret	 0
long_rshift ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_lshift DD imagerel long_lshift
	DD	imagerel long_lshift+59
	DD	imagerel $unwind$long_lshift
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$long_lshift DD imagerel long_lshift+59
	DD	imagerel long_lshift+139
	DD	imagerel $chain$0$long_lshift
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$long_lshift DD imagerel long_lshift+139
	DD	imagerel long_lshift+269
	DD	imagerel $chain$5$long_lshift
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$long_lshift DD imagerel long_lshift+269
	DD	imagerel long_lshift+319
	DD	imagerel $chain$6$long_lshift
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$long_lshift DD imagerel long_lshift+319
	DD	imagerel long_lshift+440
	DD	imagerel $chain$7$long_lshift
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$long_lshift DD imagerel long_lshift+440
	DD	imagerel long_lshift+461
	DD	imagerel $chain$2$long_lshift
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$long_lshift DD imagerel long_lshift+461
	DD	imagerel long_lshift+546
	DD	imagerel $chain$8$long_lshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$long_lshift DD 021H
	DD	imagerel long_lshift
	DD	imagerel long_lshift+59
	DD	imagerel $unwind$long_lshift
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$long_lshift DD 020021H
	DD	0ec400H
	DD	imagerel long_lshift
	DD	imagerel long_lshift+59
	DD	imagerel $unwind$long_lshift
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$long_lshift DD 021H
	DD	imagerel long_lshift+139
	DD	imagerel long_lshift+269
	DD	imagerel $chain$5$long_lshift
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$long_lshift DD 020521H
	DD	0c3405H
	DD	imagerel long_lshift+139
	DD	imagerel long_lshift+269
	DD	imagerel $chain$5$long_lshift
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$long_lshift DD 062021H
	DD	06e420H
	DD	07d41bH
	DD	0d5405H
	DD	imagerel long_lshift+440
	DD	imagerel long_lshift+461
	DD	imagerel $chain$2$long_lshift
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$long_lshift DD 020521H
	DD	0ec405H
	DD	imagerel long_lshift
	DD	imagerel long_lshift+59
	DD	imagerel $unwind$long_lshift
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_lshift DD 040901H
	DD	0f0057209H
	DD	060027003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT long_lshift
_TEXT	SEGMENT
v$ = 96
w$ = 104
long_lshift PROC					; COMDAT

; 4086 : {

  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 57		 push	 r15
  00005	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 4087 :     /* This version due to Tim Peters */
; 4088 :     PyLongObject *a = (PyLongObject*)v;
; 4089 :     PyLongObject *b = (PyLongObject*)w;
; 4090 :     PyLongObject *z = NULL;
; 4091 :     Py_ssize_t shiftby, oldsize, newsize, wordshift, remshift, i, j;
; 4092 :     twodigits accum;
; 4093 : 
; 4094 :     CHECK_BINOP(a, b);

  00009	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000d	33 ff		 xor	 edi, edi
  0000f	4c 8b f9	 mov	 r15, rcx
  00012	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0001c	8b f7		 mov	 esi, edi
  0001e	0f 84 a9 01 00
	00		 je	 $LN19@long_lshif
  00024	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00028	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00032	0f 84 95 01 00
	00		 je	 $LN19@long_lshif

; 4095 : 
; 4096 :     shiftby = PyLong_AsSsize_t((PyObject *)b);

  00038	48 8b ca	 mov	 rcx, rdx
  0003b	4c 89 64 24 70	 mov	 QWORD PTR [rsp+112], r12
  00040	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00045	4c 8b e0	 mov	 r12, rax

; 4097 :     if (shiftby == -1L && PyErr_Occurred())

  00048	48 83 f8 ff	 cmp	 rax, -1
  0004c	75 10		 jne	 SHORT $LN18@long_lshif
  0004e	e8 00 00 00 00	 call	 PyErr_Occurred
  00053	48 85 c0	 test	 rax, rax
  00056	0f 85 5c 01 00
	00		 jne	 $lshift_error$23526

; 4098 :         goto lshift_error;
; 4099 :     if (shiftby < 0) {

  0005c	eb 05		 jmp	 SHORT $LN40@long_lshif
$LN18@long_lshif:
  0005e	48 85 c0	 test	 rax, rax
  00061	79 28		 jns	 SHORT $LN17@long_lshif
$LN40@long_lshif:

; 4100 :         PyErr_SetString(PyExc_ValueError, "negative shift count");

  00063	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@NDIOBNCG@negative?5shift?5count?$AA@
  00071	e8 00 00 00 00	 call	 PyErr_SetString

; 4129 :   lshift_error:
; 4130 :     return (PyObject *) maybe_small_long(z);

  00076	48 8b ce	 mov	 rcx, rsi
  00079	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]

; 4131 : }

  0007e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00082	41 5f		 pop	 r15
  00084	5f		 pop	 rdi
  00085	5e		 pop	 rsi
  00086	e9 00 00 00 00	 jmp	 maybe_small_long
$LN17@long_lshif:
  0008b	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp

; 4101 :         goto lshift_error;
; 4102 :     }
; 4103 :     /* wordshift, remshift = divmod(shiftby, PyLong_SHIFT) */
; 4104 :     wordshift = shiftby / PyLong_SHIFT;
; 4105 :     remshift  = shiftby - wordshift * PyLong_SHIFT;
; 4106 : 
; 4107 :     oldsize = ABS(Py_SIZE(a));

  00090	49 8b 6f 60	 mov	 rbp, QWORD PTR [r15+96]
  00094	48 b8 89 88 88
	88 88 88 88 88	 mov	 rax, -8608480567731124087 ; 8888888888888889H
  0009e	49 f7 ec	 imul	 r12
  000a1	4c 89 6c 24 38	 mov	 QWORD PTR [rsp+56], r13
  000a6	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  000ab	4d 8d 34 14	 lea	 r14, QWORD PTR [r12+rdx]
  000af	49 c1 fe 04	 sar	 r14, 4
  000b3	49 8b c6	 mov	 rax, r14
  000b6	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  000ba	4c 03 f0	 add	 r14, rax
  000bd	49 8b c6	 mov	 rax, r14
  000c0	48 6b c0 1e	 imul	 rax, 30
  000c4	4c 2b e0	 sub	 r12, rax
  000c7	48 85 ed	 test	 rbp, rbp
  000ca	79 03		 jns	 SHORT $LN26@long_lshif
  000cc	48 f7 dd	 neg	 rbp
$LN26@long_lshif:

; 4108 :     newsize = oldsize + wordshift;

  000cf	4d 8d 2c 2e	 lea	 r13, QWORD PTR [r14+rbp]

; 4109 :     if (remshift)

  000d3	4d 85 e4	 test	 r12, r12
  000d6	74 03		 je	 SHORT $LN16@long_lshif

; 4110 :         ++newsize;

  000d8	49 ff c5	 inc	 r13
$LN16@long_lshif:

; 4111 :     z = _PyLong_New(newsize);

  000db	49 8b cd	 mov	 rcx, r13
  000de	e8 00 00 00 00	 call	 _PyLong_New
  000e3	48 8b f0	 mov	 rsi, rax

; 4112 :     if (z == NULL)

  000e6	48 85 c0	 test	 rax, rax
  000e9	0f 84 ba 00 00
	00		 je	 $LN43@long_lshif

; 4113 :         goto lshift_error;
; 4114 :     if (Py_SIZE(a) < 0)

  000ef	49 39 7f 60	 cmp	 QWORD PTR [r15+96], rdi
  000f3	7d 4a		 jge	 SHORT $LN11@long_lshif

; 4115 :         NEGATE(z);

  000f5	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  000fa	75 0d		 jne	 SHORT $LN10@long_lshif
  000fc	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00100	48 f7 d9	 neg	 rcx
  00103	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx
  00107	eb 36		 jmp	 SHORT $LN11@long_lshif
$LN10@long_lshif:
  00109	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0010d	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00112	48 85 c0	 test	 rax, rax
  00115	79 07		 jns	 SHORT $LN44@long_lshif
  00117	8b 4e 70	 mov	 ecx, DWORD PTR [rsi+112]
  0011a	f7 d9		 neg	 ecx
  0011c	eb 07		 jmp	 SHORT $LN29@long_lshif
$LN44@long_lshif:
  0011e	8b cf		 mov	 ecx, edi
  00120	74 03		 je	 SHORT $LN29@long_lshif
  00122	8b 4e 70	 mov	 ecx, DWORD PTR [rsi+112]
$LN29@long_lshif:
  00125	f7 d9		 neg	 ecx
  00127	e8 00 00 00 00	 call	 PyLong_FromLong
  0012c	48 8b ce	 mov	 rcx, rsi
  0012f	48 8b d8	 mov	 rbx, rax
  00132	e8 00 00 00 00	 call	 _Py_DecRef
  00137	48 8b f3	 mov	 rsi, rbx
  0013a	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
$LN11@long_lshif:

; 4116 :     for (i = 0; i < wordshift; i++)

  0013f	4d 85 f6	 test	 r14, r14
  00142	7e 12		 jle	 SHORT $LN8@long_lshif
  00144	4d 8b c6	 mov	 r8, r14
  00147	48 8d 4e 70	 lea	 rcx, QWORD PTR [rsi+112]
  0014b	33 d2		 xor	 edx, edx
  0014d	49 c1 e0 02	 shl	 r8, 2
  00151	e8 00 00 00 00	 call	 memset
$LN8@long_lshif:

; 4117 :         z->ob_digit[i] = 0;
; 4118 :     accum = 0;
; 4119 :     for (i = wordshift, j = 0; j < oldsize; i++, j++) {

  00156	48 85 ed	 test	 rbp, rbp
  00159	7e 39		 jle	 SHORT $LN3@long_lshif
  0015b	4e 8d 04 b5 00
	00 00 00	 lea	 r8, QWORD PTR [r14*4]
  00163	49 8d 57 70	 lea	 rdx, QWORD PTR [r15+112]
  00167	4d 2b c7	 sub	 r8, r15
  0016a	4c 03 c6	 add	 r8, rsi
  0016d	0f 1f 00	 npad	 3
$LL5@long_lshif:

; 4120 :         accum |= (twodigits)a->ob_digit[j] << remshift;

  00170	8b 02		 mov	 eax, DWORD PTR [rdx]
  00172	49 8b cc	 mov	 rcx, r12
  00175	48 83 c2 04	 add	 rdx, 4
  00179	48 d3 e0	 shl	 rax, cl
  0017c	48 0b f8	 or	 rdi, rax

; 4121 :         z->ob_digit[i] = (digit)(accum & PyLong_MASK);

  0017f	8b c7		 mov	 eax, edi

; 4122 :         accum >>= PyLong_SHIFT;

  00181	48 c1 ef 1e	 shr	 rdi, 30
  00185	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  0018a	48 ff cd	 dec	 rbp
  0018d	41 89 44 10 fc	 mov	 DWORD PTR [r8+rdx-4], eax
  00192	75 dc		 jne	 SHORT $LL5@long_lshif
$LN3@long_lshif:

; 4123 :     }
; 4124 :     if (remshift)

  00194	4d 85 e4	 test	 r12, r12
  00197	74 05		 je	 SHORT $LN2@long_lshif

; 4125 :         z->ob_digit[newsize-1] = (digit)accum;

  00199	42 89 7c ae 6c	 mov	 DWORD PTR [rsi+r13*4+108], edi
$LN2@long_lshif:

; 4126 :     else
; 4127 :         assert(!accum);
; 4128 :     z = long_normalize(z);

  0019e	48 8b ce	 mov	 rcx, rsi
  001a1	e8 00 00 00 00	 call	 long_normalize
  001a6	48 8b f0	 mov	 rsi, rax
$LN43@long_lshif:
  001a9	4c 8b 6c 24 38	 mov	 r13, QWORD PTR [rsp+56]
  001ae	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  001b3	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]
$lshift_error$23526:

; 4129 :   lshift_error:
; 4130 :     return (PyObject *) maybe_small_long(z);

  001b8	48 8b ce	 mov	 rcx, rsi
  001bb	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]

; 4131 : }

  001c0	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001c4	41 5f		 pop	 r15
  001c6	5f		 pop	 rdi
  001c7	5e		 pop	 rsi
  001c8	e9 00 00 00 00	 jmp	 maybe_small_long
$LN19@long_lshif:

; 4087 :     /* This version due to Tim Peters */
; 4088 :     PyLongObject *a = (PyLongObject*)v;
; 4089 :     PyLongObject *b = (PyLongObject*)w;
; 4090 :     PyLongObject *z = NULL;
; 4091 :     Py_ssize_t shiftby, oldsize, newsize, wordshift, remshift, i, j;
; 4092 :     twodigits accum;
; 4093 : 
; 4094 :     CHECK_BINOP(a, b);

  001cd	e8 00 00 00 00	 call	 _Py_PXCTX
  001d2	85 c0		 test	 eax, eax
  001d4	75 3c		 jne	 SHORT $LN33@long_lshif
  001d6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  001dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  001eb	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  001f1	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001f9	e8 00 00 00 00	 call	 _PyParallel_Guard
  001fe	85 c0		 test	 eax, eax
  00200	75 09		 jne	 SHORT $LN32@long_lshif
  00202	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00209	74 07		 je	 SHORT $LN33@long_lshif
$LN32@long_lshif:
  0020b	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN33@long_lshif:
  00212	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 4131 : }

  00219	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0021d	41 5f		 pop	 r15
  0021f	5f		 pop	 rdi
  00220	5e		 pop	 rsi
  00221	c3		 ret	 0
long_lshift ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT v_complement
_TEXT	SEGMENT
z$ = 8
a$ = 16
m$ = 24
v_complement PROC					; COMDAT

; 4140 :     Py_ssize_t i;
; 4141 :     digit carry = 1;

  00000	41 b9 01 00 00
	00		 mov	 r9d, 1

; 4142 :     for (i = 0; i < m; ++i) {

  00006	4d 85 c0	 test	 r8, r8
  00009	7e 28		 jle	 SHORT $LN1@v_compleme
  0000b	48 2b d1	 sub	 rdx, rcx
  0000e	66 90		 npad	 2
$LL3@v_compleme:

; 4143 :         carry += a[i] ^ PyLong_MASK;

  00010	8b 04 0a	 mov	 eax, DWORD PTR [rdx+rcx]
  00013	48 83 c1 04	 add	 rcx, 4
  00017	35 ff ff ff 3f	 xor	 eax, 1073741823		; 3fffffffH
  0001c	44 03 c8	 add	 r9d, eax

; 4144 :         z[i] = carry & PyLong_MASK;

  0001f	41 8b c1	 mov	 eax, r9d

; 4145 :         carry >>= PyLong_SHIFT;

  00022	41 c1 e9 1e	 shr	 r9d, 30
  00026	25 ff ff ff 3f	 and	 eax, 1073741823		; 3fffffffH
  0002b	49 ff c8	 dec	 r8
  0002e	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  00031	75 dd		 jne	 SHORT $LL3@v_compleme
$LN1@v_compleme:

; 4146 :     }
; 4147 :     assert(carry == 0);
; 4148 : }

  00033	f3 c3		 fatret	 0
v_complement ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_bitwise DD imagerel long_bitwise
	DD	imagerel long_bitwise+825
	DD	imagerel $unwind$long_bitwise
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_bitwise DD 0cbe01H
	DD	0ef4beH
	DD	0d34b9H
	DD	0f5411H
	DD	0e00d5211H
	DD	0c009d00bH
	DD	060067007H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT long_bitwise
_TEXT	SEGMENT
negz$2$ = 96
a$ = 96
op$ = 104
b$ = 112
long_bitwise PROC					; COMDAT

; 4156 : {

  00000	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 4157 :     int nega, negb, negz;
; 4158 :     Py_ssize_t size_a, size_b, size_z, i;
; 4159 :     PyLongObject *z;
; 4160 : 
; 4161 :     /* Bitwise operations for negative numbers operate as though
; 4162 :        on a two's complement representation.  So convert arguments
; 4163 :        from sign-magnitude to two's complement, and convert the
; 4164 :        result back to sign-magnitude at the end. */
; 4165 : 
; 4166 :     /* If a is negative, replace it by its two's complement. */
; 4167 :     size_a = ABS(Py_SIZE(a));

  00011	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00015	49 8b e8	 mov	 rbp, r8
  00018	44 8b f2	 mov	 r14d, edx
  0001b	4c 8b e1	 mov	 r12, rcx
  0001e	48 8b f8	 mov	 rdi, rax
  00021	48 85 c0	 test	 rax, rax
  00024	79 03		 jns	 SHORT $LN40@long_bitwi
  00026	48 f7 df	 neg	 rdi
$LN40@long_bitwi:

; 4168 :     nega = Py_SIZE(a) < 0;

  00029	33 f6		 xor	 esi, esi
  0002b	48 85 c0	 test	 rax, rax
  0002e	44 8b ee	 mov	 r13d, esi
  00031	41 0f 98 c5	 sets	 r13b

; 4169 :     if (nega) {

  00035	45 85 ed	 test	 r13d, r13d
  00038	74 38		 je	 SHORT $LN36@long_bitwi

; 4170 :         z = _PyLong_New(size_a);

  0003a	48 8b cf	 mov	 rcx, rdi
  0003d	e8 00 00 00 00	 call	 _PyLong_New
  00042	4c 8b d8	 mov	 r11, rax

; 4171 :         if (z == NULL)

  00045	48 85 c0	 test	 rax, rax
  00048	75 12		 jne	 SHORT $LN35@long_bitwi

; 4273 : }

  0004a	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  0004f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00053	41 5e		 pop	 r14
  00055	41 5d		 pop	 r13
  00057	41 5c		 pop	 r12
  00059	5f		 pop	 rdi
  0005a	5e		 pop	 rsi
  0005b	c3		 ret	 0
$LN35@long_bitwi:

; 4172 :             return NULL;
; 4173 :         v_complement(z->ob_digit, a->ob_digit, size_a);

  0005c	49 8d 54 24 70	 lea	 rdx, QWORD PTR [r12+112]
  00061	48 8d 48 70	 lea	 rcx, QWORD PTR [rax+112]
  00065	4c 8b c7	 mov	 r8, rdi
  00068	e8 00 00 00 00	 call	 v_complement

; 4174 :         a = z;

  0006d	4d 8b e3	 mov	 r12, r11

; 4175 :     }
; 4176 :     else

  00070	eb 3e		 jmp	 SHORT $LN44@long_bitwi
$LN36@long_bitwi:

; 4177 :         /* Keep reference count consistent. */
; 4178 :         Py_INCREF(a);

  00072	e8 00 00 00 00	 call	 _Py_PXCTX
  00077	85 c0		 test	 eax, eax
  00079	75 35		 jne	 SHORT $LN44@long_bitwi
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00089	4d 8b cc	 mov	 r9, r12
  0008c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00092	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0009a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009f	85 c0		 test	 eax, eax
  000a1	75 08		 jne	 SHORT $LN43@long_bitwi
  000a3	41 f6 44 24 20
	20		 test	 BYTE PTR [r12+32], 32	; 00000020H
  000a9	74 05		 je	 SHORT $LN44@long_bitwi
$LN43@long_bitwi:
  000ab	49 ff 44 24 50	 inc	 QWORD PTR [r12+80]
$LN44@long_bitwi:

; 4179 : 
; 4180 :     /* Same for b. */
; 4181 :     size_b = ABS(Py_SIZE(b));

  000b0	48 8b 45 60	 mov	 rax, QWORD PTR [rbp+96]
  000b4	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx
  000b9	4c 89 7c 24 70	 mov	 QWORD PTR [rsp+112], r15
  000be	48 8b d8	 mov	 rbx, rax
  000c1	48 85 c0	 test	 rax, rax
  000c4	79 03		 jns	 SHORT $LN42@long_bitwi
  000c6	48 f7 db	 neg	 rbx
$LN42@long_bitwi:

; 4182 :     negb = Py_SIZE(b) < 0;

  000c9	48 85 c0	 test	 rax, rax
  000cc	44 8b fe	 mov	 r15d, esi
  000cf	41 0f 98 c7	 sets	 r15b

; 4183 :     if (negb) {

  000d3	45 85 ff	 test	 r15d, r15d
  000d6	74 34		 je	 SHORT $LN33@long_bitwi

; 4184 :         z = _PyLong_New(size_b);

  000d8	48 8b cb	 mov	 rcx, rbx
  000db	e8 00 00 00 00	 call	 _PyLong_New
  000e0	4c 8b d8	 mov	 r11, rax

; 4185 :         if (z == NULL) {

  000e3	48 85 c0	 test	 rax, rax
  000e6	75 0f		 jne	 SHORT $LN32@long_bitwi

; 4186 :             Py_DECREF(a);

  000e8	49 8b cc	 mov	 rcx, r12
  000eb	e8 00 00 00 00	 call	 _Py_DecRef

; 4187 :             return NULL;

  000f0	33 c0		 xor	 eax, eax
  000f2	e9 26 02 00 00	 jmp	 $LN61@long_bitwi
$LN32@long_bitwi:

; 4188 :         }
; 4189 :         v_complement(z->ob_digit, b->ob_digit, size_b);

  000f7	48 8d 55 70	 lea	 rdx, QWORD PTR [rbp+112]
  000fb	48 8d 48 70	 lea	 rcx, QWORD PTR [rax+112]
  000ff	4c 8b c3	 mov	 r8, rbx
  00102	e8 00 00 00 00	 call	 v_complement

; 4190 :         b = z;

  00107	49 8b eb	 mov	 rbp, r11

; 4191 :     }
; 4192 :     else

  0010a	eb 3b		 jmp	 SHORT $LN48@long_bitwi
$LN33@long_bitwi:

; 4193 :         Py_INCREF(b);

  0010c	e8 00 00 00 00	 call	 _Py_PXCTX
  00111	85 c0		 test	 eax, eax
  00113	75 32		 jne	 SHORT $LN48@long_bitwi
  00115	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0011c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00123	4c 8b cd	 mov	 r9, rbp
  00126	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0012c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00134	e8 00 00 00 00	 call	 _PyParallel_Guard
  00139	85 c0		 test	 eax, eax
  0013b	75 06		 jne	 SHORT $LN47@long_bitwi
  0013d	f6 45 20 20	 test	 BYTE PTR [rbp+32], 32	; 00000020H
  00141	74 04		 je	 SHORT $LN48@long_bitwi
$LN47@long_bitwi:
  00143	48 ff 45 50	 inc	 QWORD PTR [rbp+80]
$LN48@long_bitwi:

; 4194 : 
; 4195 :     /* Swap a and b if necessary to ensure size_a >= size_b. */
; 4196 :     if (size_a < size_b) {

  00147	48 3b fb	 cmp	 rdi, rbx
  0014a	7d 1b		 jge	 SHORT $LN30@long_bitwi

; 4197 :         z = a; a = b; b = z;

  0014c	49 8b c4	 mov	 rax, r12
  0014f	4c 8b e5	 mov	 r12, rbp
  00152	48 8b e8	 mov	 rbp, rax

; 4198 :         size_z = size_a; size_a = size_b; size_b = size_z;

  00155	48 8b c7	 mov	 rax, rdi
  00158	48 8b fb	 mov	 rdi, rbx
  0015b	48 8b d8	 mov	 rbx, rax

; 4199 :         negz = nega; nega = negb; negb = negz;

  0015e	41 8b c5	 mov	 eax, r13d
  00161	45 8b ef	 mov	 r13d, r15d
  00164	44 8b f8	 mov	 r15d, eax
$LN30@long_bitwi:

; 4200 :     }
; 4201 : 
; 4202 :     /* JRH: The original logic here was to allocate the result value (z)
; 4203 :        as the longer of the two operands.  However, there are some cases
; 4204 :        where the result is guaranteed to be shorter than that: AND of two
; 4205 :        positives, OR of two negatives: use the shorter number.  AND with
; 4206 :        mixed signs: use the positive number.  OR with mixed signs: use the
; 4207 :        negative number.
; 4208 :     */
; 4209 :     switch (op) {

  00167	41 83 fe 26	 cmp	 r14d, 38		; 00000026H
  0016b	74 23		 je	 SHORT $LN26@long_bitwi
  0016d	41 83 fe 5e	 cmp	 r14d, 94		; 0000005eH
  00171	74 15		 je	 SHORT $LN27@long_bitwi
  00173	41 83 fe 7c	 cmp	 r14d, 124		; 0000007cH

; 4222 :     default:
; 4223 :         PyErr_BadArgument();
; 4224 :         return NULL;

  00177	75 6e		 jne	 SHORT $LN63@long_bitwi

; 4217 :         break;
; 4218 :     case '|':
; 4219 :         negz = nega | negb;

  00179	41 8b cf	 mov	 ecx, r15d
  0017c	41 0b cd	 or	 ecx, r13d

; 4220 :         size_z = negb ? size_b : size_a;

  0017f	45 85 ff	 test	 r15d, r15d
  00182	48 0f 45 fb	 cmovne	 rdi, rbx

; 4221 :         break;

  00186	eb 1b		 jmp	 SHORT $LN62@long_bitwi
$LN27@long_bitwi:

; 4210 :     case '^':
; 4211 :         negz = nega ^ negb;

  00188	41 8b cf	 mov	 ecx, r15d
  0018b	41 33 cd	 xor	 ecx, r13d

; 4212 :         size_z = size_a;
; 4213 :         break;

  0018e	eb 13		 jmp	 SHORT $LN62@long_bitwi
$LN26@long_bitwi:

; 4214 :     case '&':
; 4215 :         negz = nega & negb;

  00190	41 8b cf	 mov	 ecx, r15d

; 4216 :         size_z = negb ? size_a : size_b;

  00193	48 8b c3	 mov	 rax, rbx
  00196	41 23 cd	 and	 ecx, r13d
  00199	45 85 ff	 test	 r15d, r15d
  0019c	48 0f 45 c7	 cmovne	 rax, rdi
  001a0	48 8b f8	 mov	 rdi, rax
$LN62@long_bitwi:

; 4225 :     }
; 4226 : 
; 4227 :     /* We allow an extra digit if z is negative, to make sure that
; 4228 :        the final two's complement of z doesn't overflow. */
; 4229 :     z = _PyLong_New(size_z + negz);

  001a3	89 4c 24 60	 mov	 DWORD PTR negz$2$[rsp], ecx
  001a7	48 63 c9	 movsxd	 rcx, ecx
  001aa	48 03 cf	 add	 rcx, rdi
  001ad	e8 00 00 00 00	 call	 _PyLong_New
  001b2	4c 8b e8	 mov	 r13, rax

; 4230 :     if (z == NULL) {

  001b5	48 85 c0	 test	 rax, rax
  001b8	75 17		 jne	 SHORT $LN23@long_bitwi

; 4231 :         Py_DECREF(a);

  001ba	49 8b cc	 mov	 rcx, r12
  001bd	e8 00 00 00 00	 call	 _Py_DecRef

; 4232 :         Py_DECREF(b);

  001c2	48 8b cd	 mov	 rcx, rbp
  001c5	e8 00 00 00 00	 call	 _Py_DecRef

; 4233 :         return NULL;

  001ca	33 c0		 xor	 eax, eax
  001cc	e9 4c 01 00 00	 jmp	 $LN61@long_bitwi
$LN23@long_bitwi:

; 4234 :     }
; 4235 : 
; 4236 :     /* Compute digits for overlap of a and b. */
; 4237 :     switch(op) {

  001d1	41 83 fe 26	 cmp	 r14d, 38		; 00000026H
  001d5	0f 84 ac 00 00
	00		 je	 $LN20@long_bitwi
  001db	41 83 fe 5e	 cmp	 r14d, 94		; 0000005eH
  001df	74 48		 je	 SHORT $LN12@long_bitwi
  001e1	41 83 fe 7c	 cmp	 r14d, 124		; 0000007cH
  001e5	74 0c		 je	 SHORT $LN16@long_bitwi
$LN63@long_bitwi:

; 4249 :         break;
; 4250 :     default:
; 4251 :         PyErr_BadArgument();

  001e7	e8 00 00 00 00	 call	 PyErr_BadArgument

; 4252 :         return NULL;

  001ec	33 c0		 xor	 eax, eax
  001ee	e9 2a 01 00 00	 jmp	 $LN61@long_bitwi
$LN16@long_bitwi:

; 4241 :         break;
; 4242 :     case '|':
; 4243 :         for (i = 0; i < size_b; ++i)

  001f3	48 85 db	 test	 rbx, rbx
  001f6	0f 8e b8 00 00
	00		 jle	 $LN7@long_bitwi
  001fc	49 8b d4	 mov	 rdx, r12
  001ff	4c 8b c0	 mov	 r8, rax
  00202	48 8d 4d 70	 lea	 rcx, QWORD PTR [rbp+112]
  00206	48 2b d5	 sub	 rdx, rbp
  00209	4c 2b c5	 sub	 r8, rbp
  0020c	48 8b f3	 mov	 rsi, rbx
  0020f	90		 npad	 1
$LL15@long_bitwi:

; 4244 :             z->ob_digit[i] = a->ob_digit[i] | b->ob_digit[i];

  00210	8b 04 0a	 mov	 eax, DWORD PTR [rdx+rcx]
  00213	48 83 c1 04	 add	 rcx, 4
  00217	0b 41 fc	 or	 eax, DWORD PTR [rcx-4]
  0021a	48 ff cb	 dec	 rbx
  0021d	41 89 44 08 fc	 mov	 DWORD PTR [r8+rcx-4], eax
  00222	75 ec		 jne	 SHORT $LL15@long_bitwi

; 4241 :         break;
; 4242 :     case '|':
; 4243 :         for (i = 0; i < size_b; ++i)

  00224	e9 8b 00 00 00	 jmp	 $LN7@long_bitwi
$LN12@long_bitwi:

; 4245 :         break;
; 4246 :     case '^':
; 4247 :         for (i = 0; i < size_b; ++i)

  00229	48 85 db	 test	 rbx, rbx
  0022c	7e 27		 jle	 SHORT $LN59@long_bitwi
  0022e	49 8b d4	 mov	 rdx, r12
  00231	4c 8b c0	 mov	 r8, rax
  00234	48 8d 4d 70	 lea	 rcx, QWORD PTR [rbp+112]
  00238	48 2b d5	 sub	 rdx, rbp
  0023b	4c 2b c5	 sub	 r8, rbp
  0023e	48 8b f3	 mov	 rsi, rbx
$LL11@long_bitwi:

; 4248 :             z->ob_digit[i] = a->ob_digit[i] ^ b->ob_digit[i];

  00241	8b 04 11	 mov	 eax, DWORD PTR [rcx+rdx]
  00244	48 83 c1 04	 add	 rcx, 4
  00248	33 41 fc	 xor	 eax, DWORD PTR [rcx-4]
  0024b	48 ff cb	 dec	 rbx
  0024e	42 89 44 01 fc	 mov	 DWORD PTR [rcx+r8-4], eax
  00253	75 ec		 jne	 SHORT $LL11@long_bitwi
$LN59@long_bitwi:

; 4253 :     }
; 4254 : 
; 4255 :     /* Copy any remaining digits of a, inverting if necessary. */
; 4256 :     if (op == '^' && negb)

  00255	45 85 ff	 test	 r15d, r15d
  00258	74 5a		 je	 SHORT $LN7@long_bitwi

; 4257 :         for (; i < size_z; ++i)

  0025a	48 3b f7	 cmp	 rsi, rdi
  0025d	7d 73		 jge	 SHORT $LN2@long_bitwi
  0025f	4d 8b c4	 mov	 r8, r12
  00262	48 8b d7	 mov	 rdx, rdi
  00265	49 8d 4c b5 70	 lea	 rcx, QWORD PTR [r13+rsi*4+112]
  0026a	4d 2b c5	 sub	 r8, r13
  0026d	48 2b d6	 sub	 rdx, rsi
$LL6@long_bitwi:

; 4258 :             z->ob_digit[i] = a->ob_digit[i] ^ PyLong_MASK;

  00270	41 8b 04 08	 mov	 eax, DWORD PTR [r8+rcx]
  00274	48 83 c1 04	 add	 rcx, 4
  00278	35 ff ff ff 3f	 xor	 eax, 1073741823		; 3fffffffH
  0027d	48 ff ca	 dec	 rdx
  00280	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  00283	75 eb		 jne	 SHORT $LL6@long_bitwi

; 4259 :     else if (i < size_z)

  00285	eb 4b		 jmp	 SHORT $LN2@long_bitwi
$LN20@long_bitwi:

; 4238 :     case '&':
; 4239 :         for (i = 0; i < size_b; ++i)

  00287	48 85 db	 test	 rbx, rbx
  0028a	7e 28		 jle	 SHORT $LN7@long_bitwi
  0028c	49 8b d4	 mov	 rdx, r12
  0028f	4c 8b c0	 mov	 r8, rax
  00292	48 8d 4d 70	 lea	 rcx, QWORD PTR [rbp+112]
  00296	48 2b d5	 sub	 rdx, rbp
  00299	4c 2b c5	 sub	 r8, rbp
  0029c	48 8b f3	 mov	 rsi, rbx
  0029f	90		 npad	 1
$LL19@long_bitwi:

; 4240 :             z->ob_digit[i] = a->ob_digit[i] & b->ob_digit[i];

  002a0	8b 04 11	 mov	 eax, DWORD PTR [rcx+rdx]
  002a3	48 83 c1 04	 add	 rcx, 4
  002a7	23 41 fc	 and	 eax, DWORD PTR [rcx-4]
  002aa	48 ff cb	 dec	 rbx
  002ad	42 89 44 01 fc	 mov	 DWORD PTR [rcx+r8-4], eax
  002b2	75 ec		 jne	 SHORT $LL19@long_bitwi
$LN7@long_bitwi:

; 4259 :     else if (i < size_z)

  002b4	48 3b f7	 cmp	 rsi, rdi
  002b7	7d 19		 jge	 SHORT $LN2@long_bitwi

; 4260 :         memcpy(&z->ob_digit[i], &a->ob_digit[i],
; 4261 :                (size_z-i)*sizeof(digit));

  002b9	4c 8b c7	 mov	 r8, rdi
  002bc	49 8d 54 b4 70	 lea	 rdx, QWORD PTR [r12+rsi*4+112]
  002c1	49 8d 4c b5 70	 lea	 rcx, QWORD PTR [r13+rsi*4+112]
  002c6	4c 2b c6	 sub	 r8, rsi
  002c9	49 c1 e0 02	 shl	 r8, 2
  002cd	e8 00 00 00 00	 call	 memcpy
$LN2@long_bitwi:

; 4262 : 
; 4263 :     /* Complement result if negative. */
; 4264 :     if (negz) {

  002d2	83 7c 24 60 00	 cmp	 DWORD PTR negz$2$[rsp], 0
  002d7	74 24		 je	 SHORT $LN1@long_bitwi

; 4265 :         Py_SIZE(z) = -(Py_SIZE(z));

  002d9	49 8b 45 60	 mov	 rax, QWORD PTR [r13+96]

; 4266 :         z->ob_digit[size_z] = PyLong_MASK;
; 4267 :         v_complement(z->ob_digit, z->ob_digit, size_z+1);

  002dd	49 8d 4d 70	 lea	 rcx, QWORD PTR [r13+112]
  002e1	4c 8d 47 01	 lea	 r8, QWORD PTR [rdi+1]
  002e5	48 f7 d8	 neg	 rax
  002e8	48 8b d1	 mov	 rdx, rcx
  002eb	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  002ef	41 c7 44 bd 70
	ff ff ff 3f	 mov	 DWORD PTR [r13+rdi*4+112], 1073741823 ; 3fffffffH
  002f8	e8 00 00 00 00	 call	 v_complement
$LN1@long_bitwi:

; 4268 :     }
; 4269 : 
; 4270 :     Py_DECREF(a);

  002fd	49 8b cc	 mov	 rcx, r12
  00300	e8 00 00 00 00	 call	 _Py_DecRef

; 4271 :     Py_DECREF(b);

  00305	48 8b cd	 mov	 rcx, rbp
  00308	e8 00 00 00 00	 call	 _Py_DecRef

; 4272 :     return (PyObject *)maybe_small_long(long_normalize(z));

  0030d	49 8b cd	 mov	 rcx, r13
  00310	e8 00 00 00 00	 call	 long_normalize
  00315	48 8b c8	 mov	 rcx, rax
  00318	e8 00 00 00 00	 call	 maybe_small_long
$LN61@long_bitwi:

; 4273 : }

  0031d	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  00322	4c 8b 7c 24 70	 mov	 r15, QWORD PTR [rsp+112]
  00327	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  0032c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00330	41 5e		 pop	 r14
  00332	41 5d		 pop	 r13
  00334	41 5c		 pop	 r12
  00336	5f		 pop	 rdi
  00337	5e		 pop	 rsi
  00338	c3		 ret	 0
long_bitwise ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_and DD imagerel long_and
	DD	imagerel long_and+134
	DD	imagerel $unwind$long_and
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_and DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT long_and
_TEXT	SEGMENT
a$ = 64
b$ = 72
long_and PROC						; COMDAT

; 4277 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4278 :     PyObject *c;
; 4279 :     CHECK_BINOP(a, b);

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00012	74 21		 je	 SHORT $LN1@long_and
  00014	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00018	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00022	74 11		 je	 SHORT $LN1@long_and

; 4280 :     c = long_bitwise((PyLongObject*)a, '&', (PyLongObject*)b);

  00024	4c 8b c2	 mov	 r8, rdx
  00027	ba 26 00 00 00	 mov	 edx, 38			; 00000026H

; 4281 :     return c;
; 4282 : }

  0002c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00030	e9 00 00 00 00	 jmp	 long_bitwise
$LN1@long_and:

; 4278 :     PyObject *c;
; 4279 :     CHECK_BINOP(a, b);

  00035	e8 00 00 00 00	 call	 _Py_PXCTX
  0003a	85 c0		 test	 eax, eax
  0003c	75 3c		 jne	 SHORT $LN9@long_and
  0003e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00053	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00059	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00061	e8 00 00 00 00	 call	 _PyParallel_Guard
  00066	85 c0		 test	 eax, eax
  00068	75 09		 jne	 SHORT $LN8@long_and
  0006a	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00071	74 07		 je	 SHORT $LN9@long_and
$LN8@long_and:
  00073	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN9@long_and:
  0007a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 4281 :     return c;
; 4282 : }

  00081	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00085	c3		 ret	 0
long_and ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_xor DD imagerel long_xor
	DD	imagerel long_xor+134
	DD	imagerel $unwind$long_xor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_xor DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT long_xor
_TEXT	SEGMENT
a$ = 64
b$ = 72
long_xor PROC						; COMDAT

; 4286 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4287 :     PyObject *c;
; 4288 :     CHECK_BINOP(a, b);

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00012	74 21		 je	 SHORT $LN1@long_xor
  00014	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00018	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00022	74 11		 je	 SHORT $LN1@long_xor

; 4289 :     c = long_bitwise((PyLongObject*)a, '^', (PyLongObject*)b);

  00024	4c 8b c2	 mov	 r8, rdx
  00027	ba 5e 00 00 00	 mov	 edx, 94			; 0000005eH

; 4290 :     return c;
; 4291 : }

  0002c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00030	e9 00 00 00 00	 jmp	 long_bitwise
$LN1@long_xor:

; 4287 :     PyObject *c;
; 4288 :     CHECK_BINOP(a, b);

  00035	e8 00 00 00 00	 call	 _Py_PXCTX
  0003a	85 c0		 test	 eax, eax
  0003c	75 3c		 jne	 SHORT $LN9@long_xor
  0003e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00053	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00059	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00061	e8 00 00 00 00	 call	 _PyParallel_Guard
  00066	85 c0		 test	 eax, eax
  00068	75 09		 jne	 SHORT $LN8@long_xor
  0006a	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00071	74 07		 je	 SHORT $LN9@long_xor
$LN8@long_xor:
  00073	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN9@long_xor:
  0007a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 4290 :     return c;
; 4291 : }

  00081	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00085	c3		 ret	 0
long_xor ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_or DD imagerel long_or
	DD	imagerel long_or+134
	DD	imagerel $unwind$long_or
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_or DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT long_or
_TEXT	SEGMENT
a$ = 64
b$ = 72
long_or	PROC						; COMDAT

; 4295 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4296 :     PyObject *c;
; 4297 :     CHECK_BINOP(a, b);

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00012	74 21		 je	 SHORT $LN1@long_or
  00014	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00018	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00022	74 11		 je	 SHORT $LN1@long_or

; 4298 :     c = long_bitwise((PyLongObject*)a, '|', (PyLongObject*)b);

  00024	4c 8b c2	 mov	 r8, rdx
  00027	ba 7c 00 00 00	 mov	 edx, 124		; 0000007cH

; 4299 :     return c;
; 4300 : }

  0002c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00030	e9 00 00 00 00	 jmp	 long_bitwise
$LN1@long_or:

; 4296 :     PyObject *c;
; 4297 :     CHECK_BINOP(a, b);

  00035	e8 00 00 00 00	 call	 _Py_PXCTX
  0003a	85 c0		 test	 eax, eax
  0003c	75 3c		 jne	 SHORT $LN9@long_or
  0003e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00053	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00059	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00061	e8 00 00 00 00	 call	 _PyParallel_Guard
  00066	85 c0		 test	 eax, eax
  00068	75 09		 jne	 SHORT $LN8@long_or
  0006a	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00071	74 07		 je	 SHORT $LN9@long_or
$LN8@long_or:
  00073	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN9@long_or:
  0007a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 4299 :     return c;
; 4300 : }

  00081	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00085	c3		 ret	 0
long_or	ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_long DD imagerel long_long
	DD	imagerel long_long+100
	DD	imagerel $unwind$long_long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_long DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT long_long
_TEXT	SEGMENT
v$ = 64
long_long PROC						; COMDAT

; 4304 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 4305 :     if (PyLong_CheckExact(v))

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00014	75 44		 jne	 SHORT $LN2@long_long

; 4306 :         Py_INCREF(v);

  00016	e8 00 00 00 00	 call	 _Py_PXCTX
  0001b	85 c0		 test	 eax, eax
  0001d	75 32		 jne	 SHORT $LN9@long_long
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0002d	4c 8b cb	 mov	 r9, rbx
  00030	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00036	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0003e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00043	85 c0		 test	 eax, eax
  00045	75 06		 jne	 SHORT $LN5@long_long
  00047	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H

; 4307 :     else
; 4308 :         v = _PyLong_Copy((PyLongObject *)v);

  0004b	74 04		 je	 SHORT $LN9@long_long

; 4306 :         Py_INCREF(v);

$LN5@long_long:
  0004d	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN9@long_long:

; 4309 :     return v;

  00051	48 8b c3	 mov	 rax, rbx

; 4310 : }

  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
$LN2@long_long:
  0005a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005e	5b		 pop	 rbx
  0005f	e9 00 00 00 00	 jmp	 _PyLong_Copy
long_long ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_float DD imagerel long_float
	DD	imagerel long_float+70
	DD	imagerel $unwind$long_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_float DD 030901H
	DD	026809H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT long_float
_TEXT	SEGMENT
v$ = 64
long_float PROC						; COMDAT

; 4314 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6

; 4315 :     double result;
; 4316 :     result = PyLong_AsDouble(v);

  00009	e8 00 00 00 00	 call	 PyLong_AsDouble

; 4317 :     if (result == -1.0 && PyErr_Occurred())

  0000e	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00016	66 0f 28 f0	 movapd	 xmm6, xmm0
  0001a	7a 18		 jp	 SHORT $LN1@long_float
  0001c	75 16		 jne	 SHORT $LN1@long_float
  0001e	e8 00 00 00 00	 call	 PyErr_Occurred
  00023	48 85 c0	 test	 rax, rax
  00026	74 0c		 je	 SHORT $LN1@long_float

; 4318 :         return NULL;

  00028	33 c0		 xor	 eax, eax

; 4320 : }

  0002a	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0002f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00033	c3		 ret	 0
$LN1@long_float:

; 4319 :     return PyFloat_FromDouble(result);

  00034	66 0f 28 c6	 movapd	 xmm0, xmm6

; 4320 : }

  00038	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
long_float ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@HFLKJAMF@int?$CI?$CJ?5base?5must?5be?5?$DO?$DN?52?5and?5?$DM?$DN?53@ ; `string'
PUBLIC	??_C@_0DC@OAMPAPFL@int?$CI?$CJ?5can?8t?5convert?5non?9string?5w@ ; `string'
PUBLIC	??_C@_0BO@MFMCCHH@int?$CI?$CJ?5missing?5string?5argument?$AA@ ; `string'
PUBLIC	??_C@_07IJMKFLBG@?$HMOO?3int?$AA@		; `string'
EXTRN	_PyByteArray_empty_string:BYTE
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyByteArray_Type:BYTE
EXTRN	PyNumber_Long:PROC
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_new DD imagerel long_new
	DD	imagerel long_new+179
	DD	imagerel $unwind$long_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$long_new DD imagerel long_new+179
	DD	imagerel long_new+281
	DD	imagerel $chain$0$long_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$long_new DD imagerel long_new+281
	DD	imagerel long_new+370
	DD	imagerel $chain$3$long_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$long_new DD imagerel long_new+370
	DD	imagerel long_new+431
	DD	imagerel $chain$5$long_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$long_new DD imagerel long_new+431
	DD	imagerel long_new+475
	DD	imagerel $chain$7$long_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$long_new DD imagerel long_new+475
	DD	imagerel long_new+512
	DD	imagerel $chain$9$long_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$long_new DD imagerel long_new+512
	DD	imagerel long_new+543
	DD	imagerel $chain$11$long_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$long_new DD 020021H
	DD	0b3400H
	DD	imagerel long_new
	DD	imagerel long_new+179
	DD	imagerel $unwind$long_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$long_new DD 040021H
	DD	087400H
	DD	0b3400H
	DD	imagerel long_new
	DD	imagerel long_new+179
	DD	imagerel $unwind$long_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$long_new DD 040021H
	DD	087400H
	DD	0b3400H
	DD	imagerel long_new
	DD	imagerel long_new+179
	DD	imagerel $unwind$long_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$long_new DD 040021H
	DD	087400H
	DD	0b3400H
	DD	imagerel long_new
	DD	imagerel long_new+179
	DD	imagerel $unwind$long_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$long_new DD 040521H
	DD	087405H
	DD	0b3400H
	DD	imagerel long_new
	DD	imagerel long_new+179
	DD	imagerel $unwind$long_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$long_new DD 020521H
	DD	0b3405H
	DD	imagerel long_new
	DD	imagerel long_new+179
	DD	imagerel $unwind$long_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_new DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_0CC@HFLKJAMF@int?$CI?$CJ?5base?5must?5be?5?$DO?$DN?52?5and?5?$DM?$DN?53@
CONST	SEGMENT
??_C@_0CC@HFLKJAMF@int?$CI?$CJ?5base?5must?5be?5?$DO?$DN?52?5and?5?$DM?$DN?53@ DB 'i'
	DB	'nt() base must be >= 2 and <= 36', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@OAMPAPFL@int?$CI?$CJ?5can?8t?5convert?5non?9string?5w@
CONST	SEGMENT
??_C@_0DC@OAMPAPFL@int?$CI?$CJ?5can?8t?5convert?5non?9string?5w@ DB 'int('
	DB	') can''t convert non-string with explicit base', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MFMCCHH@int?$CI?$CJ?5missing?5string?5argument?$AA@
CONST	SEGMENT
??_C@_0BO@MFMCCHH@int?$CI?$CJ?5missing?5string?5argument?$AA@ DB 'int() m'
	DB	'issing string argument', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IJMKFLBG@?$HMOO?3int?$AA@
CONST	SEGMENT
??_C@_07IJMKFLBG@?$HMOO?3int?$AA@ DB '|OO:int', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT long_new
_TEXT	SEGMENT
obase$ = 48
overflow$ = 80
type$ = 80
args$ = 88
kwds$ = 96
x$ = 104
long_new PROC						; COMDAT

; 4327 : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00004	4c 8b d2	 mov	 r10, rdx

; 4328 :     PyObject *obase = NULL, *x = NULL;

  00007	33 d2		 xor	 edx, edx
  00009	49 8b c0	 mov	 rax, r8
  0000c	48 89 54 24 30	 mov	 QWORD PTR obase$[rsp], rdx
  00011	48 89 54 24 68	 mov	 QWORD PTR x$[rsp], rdx

; 4329 :     long base;
; 4330 :     int overflow;
; 4331 :     static char *kwlist[] = {"x", "base", 0};
; 4332 : 
; 4333 :     if (type != &PyLong_Type)

  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyLong_Type
  0001d	48 3b ca	 cmp	 rcx, rdx
  00020	74 0d		 je	 SHORT $LN17@long_new

; 4334 :         return long_subtype_new(type, args, kwds); /* Wimp out */

  00022	49 8b d2	 mov	 rdx, r10
  00025	e8 00 00 00 00	 call	 long_subtype_new

; 4372 :     }
; 4373 : }

  0002a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0002e	c3		 ret	 0
$LN17@long_new:

; 4335 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|OO:int", kwlist,
; 4336 :                                      &x, &obase))

  0002f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR obase$[rsp]
  00034	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??long_new@@9@9
  0003b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07IJMKFLBG@?$HMOO?3int?$AA@
  00042	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00047	48 8d 4c 24 68	 lea	 rcx, QWORD PTR x$[rsp]
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00054	49 8b ca	 mov	 rcx, r10
  00057	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0005c	85 c0		 test	 eax, eax

; 4337 :         return NULL;

  0005e	74 24		 je	 SHORT $LN27@long_new

; 4338 :     if (x == NULL) {

  00060	48 8b 4c 24 68	 mov	 rcx, QWORD PTR x$[rsp]
  00065	48 85 c9	 test	 rcx, rcx
  00068	75 2d		 jne	 SHORT $LN15@long_new

; 4339 :         if (obase != NULL) {

  0006a	48 39 4c 24 30	 cmp	 QWORD PTR obase$[rsp], rcx
  0006f	74 1a		 je	 SHORT $LN14@long_new

; 4340 :             PyErr_SetString(PyExc_TypeError,
; 4341 :                             "int() missing string argument");

  00071	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@MFMCCHH@int?$CI?$CJ?5missing?5string?5argument?$AA@
  0007f	e8 00 00 00 00	 call	 PyErr_SetString
$LN27@long_new:

; 4342 :             return NULL;

  00084	33 c0		 xor	 eax, eax

; 4372 :     }
; 4373 : }

  00086	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008a	c3		 ret	 0
$LN14@long_new:

; 4343 :         }
; 4344 :         return PyLong_FromLong(0L);

  0008b	33 c9		 xor	 ecx, ecx
  0008d	e8 00 00 00 00	 call	 PyLong_FromLong

; 4372 :     }
; 4373 : }

  00092	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00096	c3		 ret	 0
$LN15@long_new:

; 4345 :     }
; 4346 :     if (obase == NULL)

  00097	48 8b 44 24 30	 mov	 rax, QWORD PTR obase$[rsp]
  0009c	48 85 c0	 test	 rax, rax
  0009f	75 0a		 jne	 SHORT $LN13@long_new

; 4347 :         return PyNumber_Long(x);

  000a1	e8 00 00 00 00	 call	 PyNumber_Long

; 4372 :     }
; 4373 : }

  000a6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000aa	c3		 ret	 0
$LN13@long_new:

; 4348 : 
; 4349 :     base = PyLong_AsLongAndOverflow(obase, &overflow);

  000ab	48 8d 54 24 50	 lea	 rdx, QWORD PTR overflow$[rsp]
  000b0	48 8b c8	 mov	 rcx, rax
  000b3	48 89 5c 24 58	 mov	 QWORD PTR [rsp+88], rbx
  000b8	e8 00 00 00 00	 call	 PyLong_AsLongAndOverflow
  000bd	8b d8		 mov	 ebx, eax

; 4350 :     if (base == -1 && PyErr_Occurred())

  000bf	83 f8 ff	 cmp	 eax, -1
  000c2	75 0e		 jne	 SHORT $LN12@long_new
  000c4	e8 00 00 00 00	 call	 PyErr_Occurred
  000c9	48 85 c0	 test	 rax, rax

; 4351 :         return NULL;

  000cc	0f 85 41 01 00
	00		 jne	 $LN26@long_new
$LN12@long_new:

; 4352 :     if (overflow || (base != 0 && base < 2) || base > 36) {

  000d2	83 7c 24 50 00	 cmp	 DWORD PTR overflow$[rsp], 0
  000d7	0f 85 23 01 00
	00		 jne	 $LN10@long_new
  000dd	85 db		 test	 ebx, ebx
  000df	74 09		 je	 SHORT $LN9@long_new
  000e1	83 fb 02	 cmp	 ebx, 2
  000e4	0f 8c 16 01 00
	00		 jl	 $LN10@long_new
$LN9@long_new:
  000ea	83 fb 24	 cmp	 ebx, 36			; 00000024H
  000ed	0f 8f 0d 01 00
	00		 jg	 $LN10@long_new

; 4356 :     }
; 4357 : 
; 4358 :     if (PyUnicode_Check(x))

  000f3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR x$[rsp]
  000f8	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  000fc	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00106	74 11		 je	 SHORT $LN8@long_new

; 4359 :         return PyLong_FromUnicodeObject(x, (int)base);

  00108	8b d3		 mov	 edx, ebx
  0010a	e8 00 00 00 00	 call	 PyLong_FromUnicodeObject
  0010f	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]

; 4372 :     }
; 4373 : }

  00114	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00118	c3		 ret	 0
$LN8@long_new:
  00119	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 4360 :     else if (PyByteArray_Check(x) || PyBytes_Check(x)) {

  0011e	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:PyByteArray_Type
  00125	48 3b c7	 cmp	 rax, rdi
  00128	74 48		 je	 SHORT $LN5@long_new
  0012a	48 8b d7	 mov	 rdx, rdi
  0012d	48 8b c8	 mov	 rcx, rax
  00130	e8 00 00 00 00	 call	 PyType_IsSubtype
  00135	48 8b 4c 24 68	 mov	 rcx, QWORD PTR x$[rsp]
  0013a	85 c0		 test	 eax, eax
  0013c	75 34		 jne	 SHORT $LN5@long_new
  0013e	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00142	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  0014c	75 24		 jne	 SHORT $LN5@long_new

; 4367 :     }
; 4368 :     else {
; 4369 :         PyErr_SetString(PyExc_TypeError,
; 4370 :                         "int() can't convert non-string with explicit base");

  0014e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00155	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@OAMPAPFL@int?$CI?$CJ?5can?8t?5convert?5non?9string?5w@
  0015c	e8 00 00 00 00	 call	 PyErr_SetString
  00161	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00166	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]

; 4371 :         return NULL;

  0016b	33 c0		 xor	 eax, eax

; 4372 :     }
; 4373 : }

  0016d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00171	c3		 ret	 0
$LN5@long_new:

; 4361 :         char *string;
; 4362 :         if (PyByteArray_Check(x))

  00172	48 39 79 58	 cmp	 QWORD PTR [rcx+88], rdi
  00176	74 37		 je	 SHORT $LN3@long_new
  00178	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0017c	48 8b d7	 mov	 rdx, rdi
  0017f	e8 00 00 00 00	 call	 PyType_IsSubtype

; 4364 :         else
; 4365 :             string = PyBytes_AS_STRING(x);

  00184	48 8b 4c 24 68	 mov	 rcx, QWORD PTR x$[rsp]
  00189	85 c0		 test	 eax, eax
  0018b	75 22		 jne	 SHORT $LN3@long_new

; 4366 :         return _PyLong_FromBytes(string, Py_SIZE(x), (int)base);

  0018d	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00191	48 8d 41 78	 lea	 rax, QWORD PTR [rcx+120]
  00195	44 8b c3	 mov	 r8d, ebx
  00198	48 8b c8	 mov	 rcx, rax
  0019b	e8 00 00 00 00	 call	 _PyLong_FromBytes
  001a0	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  001a5	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]

; 4372 :     }
; 4373 : }

  001aa	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001ae	c3		 ret	 0
$LN3@long_new:

; 4363 :             string = PyByteArray_AS_STRING(x);

  001af	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  001b4	74 25		 je	 SHORT $LN20@long_new
  001b6	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]

; 4366 :         return _PyLong_FromBytes(string, Py_SIZE(x), (int)base);

  001bd	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  001c1	44 8b c3	 mov	 r8d, ebx
  001c4	48 8b c8	 mov	 rcx, rax
  001c7	e8 00 00 00 00	 call	 _PyLong_FromBytes
  001cc	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  001d1	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]

; 4372 :     }
; 4373 : }

  001d6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001da	c3		 ret	 0
$LN20@long_new:

; 4366 :         return _PyLong_FromBytes(string, Py_SIZE(x), (int)base);

  001db	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  001df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  001e6	44 8b c3	 mov	 r8d, ebx
  001e9	48 8b c8	 mov	 rcx, rax
  001ec	e8 00 00 00 00	 call	 _PyLong_FromBytes
  001f1	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  001f6	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]

; 4372 :     }
; 4373 : }

  001fb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001ff	c3		 ret	 0
$LN10@long_new:

; 4353 :         PyErr_SetString(PyExc_ValueError,
; 4354 :                         "int() base must be >= 2 and <= 36");

  00200	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00207	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@HFLKJAMF@int?$CI?$CJ?5base?5must?5be?5?$DO?$DN?52?5and?5?$DM?$DN?53@
  0020e	e8 00 00 00 00	 call	 PyErr_SetString
$LN26@long_new:

; 4355 :         return NULL;

  00213	33 c0		 xor	 eax, eax
  00215	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]

; 4372 :     }
; 4373 : }

  0021a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0021e	c3		 ret	 0
long_new ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_subtype_new DD imagerel long_subtype_new
	DD	imagerel long_subtype_new+44
	DD	imagerel $unwind$long_subtype_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$long_subtype_new DD imagerel long_subtype_new+44
	DD	imagerel long_subtype_new+107
	DD	imagerel $chain$0$long_subtype_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$long_subtype_new DD imagerel long_subtype_new+107
	DD	imagerel long_subtype_new+257
	DD	imagerel $chain$2$long_subtype_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$long_subtype_new DD imagerel long_subtype_new+257
	DD	imagerel long_subtype_new+286
	DD	imagerel $chain$4$long_subtype_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$long_subtype_new DD imagerel long_subtype_new+286
	DD	imagerel long_subtype_new+313
	DD	imagerel $chain$6$long_subtype_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$long_subtype_new DD 020021H
	DD	083400H
	DD	imagerel long_subtype_new
	DD	imagerel long_subtype_new+44
	DD	imagerel $unwind$long_subtype_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$long_subtype_new DD 020021H
	DD	083400H
	DD	imagerel long_subtype_new
	DD	imagerel long_subtype_new+44
	DD	imagerel $unwind$long_subtype_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$long_subtype_new DD 020021H
	DD	083400H
	DD	imagerel long_subtype_new
	DD	imagerel long_subtype_new+44
	DD	imagerel $unwind$long_subtype_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$long_subtype_new DD 020521H
	DD	083405H
	DD	imagerel long_subtype_new
	DD	imagerel long_subtype_new+44
	DD	imagerel $unwind$long_subtype_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_subtype_new DD 040a01H
	DD	09640aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT long_subtype_new
_TEXT	SEGMENT
type$ = 64
args$ = 72
kwds$ = 80
long_subtype_new PROC					; COMDAT

; 4382 : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f1	 mov	 rsi, rcx

; 4383 :     PyLongObject *tmp, *newobj;
; 4384 :     Py_ssize_t i, n;
; 4385 : 
; 4386 :     assert(PyType_IsSubtype(type, &PyLong_Type));
; 4387 :     tmp = (PyLongObject *)long_new(&PyLong_Type, args, kwds);

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyLong_Type
  00014	e8 00 00 00 00	 call	 long_new
  00019	48 8b f8	 mov	 rdi, rax

; 4388 :     if (tmp == NULL)

  0001c	48 85 c0	 test	 rax, rax
  0001f	75 0b		 jne	 SHORT $LN6@long_subty

; 4405 : }

  00021	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00026	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002a	5f		 pop	 rdi
  0002b	c3		 ret	 0
$LN6@long_subty:
  0002c	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 4389 :         return NULL;
; 4390 :     assert(PyLong_CheckExact(tmp));
; 4391 :     n = Py_SIZE(tmp);

  00031	48 8b 58 60	 mov	 rbx, QWORD PTR [rax+96]

; 4392 :     if (n < 0)

  00035	48 85 db	 test	 rbx, rbx
  00038	79 03		 jns	 SHORT $LN5@long_subty

; 4393 :         n = -n;

  0003a	48 f7 db	 neg	 rbx
$LN5@long_subty:

; 4394 :     newobj = (PyLongObject *)type->tp_alloc(type, n);

  0003d	48 8b d3	 mov	 rdx, rbx
  00040	48 8b ce	 mov	 rcx, rsi
  00043	ff 96 88 01 00
	00		 call	 QWORD PTR [rsi+392]
  00049	48 8b f0	 mov	 rsi, rax

; 4395 :     if (newobj == NULL) {

  0004c	48 85 c0	 test	 rax, rax
  0004f	75 1a		 jne	 SHORT $LN4@long_subty

; 4396 :         Py_DECREF(tmp);

  00051	48 8b cf	 mov	 rcx, rdi
  00054	e8 00 00 00 00	 call	 _Py_DecRef
  00059	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 4397 :         return NULL;

  0005e	33 c0		 xor	 eax, eax

; 4405 : }

  00060	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00065	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00069	5f		 pop	 rdi
  0006a	c3		 ret	 0
$LN4@long_subty:

; 4398 :     }
; 4399 :     assert(PyLong_Check(newobj));
; 4400 :     Py_SIZE(newobj) = Py_SIZE(tmp);

  0006b	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  0006f	48 89 46 60	 mov	 QWORD PTR [rsi+96], rax

; 4401 :     for (i = 0; i < n; i++)

  00073	48 85 db	 test	 rbx, rbx
  00076	7e 27		 jle	 SHORT $LN1@long_subty
  00078	48 8b d7	 mov	 rdx, rdi
  0007b	48 8d 4e 70	 lea	 rcx, QWORD PTR [rsi+112]
  0007f	48 2b d6	 sub	 rdx, rsi
  00082	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL3@long_subty:

; 4402 :         newobj->ob_digit[i] = tmp->ob_digit[i];

  00090	8b 04 0a	 mov	 eax, DWORD PTR [rdx+rcx]
  00093	48 83 c1 04	 add	 rcx, 4
  00097	48 ff cb	 dec	 rbx
  0009a	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  0009d	75 f1		 jne	 SHORT $LL3@long_subty
$LN1@long_subty:

; 4403 :     Py_DECREF(tmp);

  0009f	e8 00 00 00 00	 call	 _Py_PXCTX
  000a4	85 c0		 test	 eax, eax
  000a6	75 7e		 jne	 SHORT $LN19@long_subty
  000a8	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000ac	a8 20		 test	 al, 32			; 00000020H
  000ae	75 6e		 jne	 SHORT $LN13@long_subty
  000b0	84 c0		 test	 al, al
  000b2	78 6a		 js	 SHORT $LN13@long_subty
  000b4	a8 02		 test	 al, 2
  000b6	75 6e		 jne	 SHORT $LN19@long_subty
  000b8	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000bc	75 68		 jne	 SHORT $LN19@long_subty
  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000cc	4c 8b cf	 mov	 r9, rdi
  000cf	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000d5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000dd	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e2	48 8b cf	 mov	 rcx, rdi
  000e5	85 c0		 test	 eax, eax
  000e7	74 18		 je	 SHORT $LN18@long_subty
  000e9	e8 00 00 00 00	 call	 _Px_Dealloc
  000ee	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 4404 :     return (PyObject *)newobj;

  000f3	48 8b c6	 mov	 rax, rsi

; 4405 : }

  000f6	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000fb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ff	5f		 pop	 rdi
  00100	c3		 ret	 0

; 4403 :     Py_DECREF(tmp);

$LN18@long_subty:
  00101	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00105	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0010b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 4404 :     return (PyObject *)newobj;

  00110	48 8b c6	 mov	 rax, rsi

; 4405 : }

  00113	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00118	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011c	5f		 pop	 rdi
  0011d	c3		 ret	 0

; 4403 :     Py_DECREF(tmp);

$LN13@long_subty:
  0011e	48 8b cf	 mov	 rcx, rdi
  00121	e8 00 00 00 00	 call	 Px_DecRef
$LN19@long_subty:

; 4404 :     return (PyObject *)newobj;

  00126	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0012b	48 8b c6	 mov	 rax, rsi

; 4405 : }

  0012e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00133	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00137	5f		 pop	 rdi
  00138	c3		 ret	 0
long_subtype_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@			; `string'
EXTRN	Py_BuildValue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_getnewargs DD imagerel long_getnewargs
	DD	imagerel long_getnewargs+28
	DD	imagerel $unwind$long_getnewargs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_getnewargs DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@
CONST	SEGMENT
??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@ DB '(N)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT long_getnewargs
_TEXT	SEGMENT
v$ = 48
long_getnewargs PROC					; COMDAT

; 4409 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4410 :     return Py_BuildValue("(N)", _PyLong_Copy(v));

  00004	e8 00 00 00 00	 call	 _PyLong_Copy
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@
  00010	48 8b d0	 mov	 rdx, rax

; 4411 : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	e9 00 00 00 00	 jmp	 Py_BuildValue
long_getnewargs ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT long_get0
_TEXT	SEGMENT
v$ = 8
context$ = 16
long_get0 PROC						; COMDAT

; 4415 :     return PyLong_FromLong(0L);

  00000	33 c9		 xor	 ecx, ecx

; 4416 : }

  00002	e9 00 00 00 00	 jmp	 PyLong_FromLong
long_get0 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT long_get1
_TEXT	SEGMENT
v$ = 8
context$ = 16
long_get1 PROC						; COMDAT

; 4420 :     return PyLong_FromLong(1L);

  00000	b9 01 00 00 00	 mov	 ecx, 1

; 4421 : }

  00005	e9 00 00 00 00	 jmp	 PyLong_FromLong
long_get1 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@EKIKMBMC@U?3__format__?$AA@		; `string'
EXTRN	_PyUnicodeWriter_Finish:PROC
EXTRN	_PyUnicodeWriter_Dealloc:PROC
EXTRN	_PyLong_FormatAdvancedWriter:PROC
EXTRN	_PyUnicodeWriter_Init:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$long__format__ DD imagerel long__format__
	DD	imagerel long__format__+118
	DD	imagerel $unwind$long__format__
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long__format__ DD 020601H
	DD	03002d206H
xdata	ENDS
;	COMDAT ??_C@_0N@EKIKMBMC@U?3__format__?$AA@
CONST	SEGMENT
??_C@_0N@EKIKMBMC@U?3__format__?$AA@ DB 'U:__format__', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT long__format__
_TEXT	SEGMENT
writer$ = 48
self$ = 128
args$ = 136
format_spec$ = 144
long__format__ PROC					; COMDAT

; 4425 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 4426 :     PyObject *format_spec;
; 4427 :     _PyUnicodeWriter writer;
; 4428 :     int ret;
; 4429 : 
; 4430 :     if (!PyArg_ParseTuple(args, "U:__format__", &format_spec))

  0000c	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR format_spec$[rsp]
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@EKIKMBMC@U?3__format__?$AA@
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00023	85 c0		 test	 eax, eax

; 4431 :         return NULL;

  00025	74 3c		 je	 SHORT $LN5@long__form

; 4432 : 
; 4433 :     _PyUnicodeWriter_Init(&writer, 0);

  00027	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  0002c	33 d2		 xor	 edx, edx
  0002e	e8 00 00 00 00	 call	 _PyUnicodeWriter_Init

; 4434 :     ret = _PyLong_FormatAdvancedWriter(
; 4435 :         &writer,
; 4436 :         self,
; 4437 :         format_spec, 0, PyUnicode_GET_LENGTH(format_spec));

  00033	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR format_spec$[rsp]
  0003b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  00040	49 8b 40 60	 mov	 rax, QWORD PTR [r8+96]
  00044	45 33 c9	 xor	 r9d, r9d
  00047	48 8b d3	 mov	 rdx, rbx
  0004a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004f	e8 00 00 00 00	 call	 _PyLong_FormatAdvancedWriter

; 4438 :     if (ret == -1) {
; 4439 :         _PyUnicodeWriter_Dealloc(&writer);

  00054	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  00059	83 f8 ff	 cmp	 eax, -1
  0005c	75 0d		 jne	 SHORT $LN1@long__form
  0005e	e8 00 00 00 00	 call	 _PyUnicodeWriter_Dealloc
$LN5@long__form:

; 4440 :         return NULL;

  00063	33 c0		 xor	 eax, eax

; 4443 : }

  00065	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00069	5b		 pop	 rbx
  0006a	c3		 ret	 0
$LN1@long__form:

; 4441 :     }
; 4442 :     return _PyUnicodeWriter_Finish(&writer);

  0006b	e8 00 00 00 00	 call	 _PyUnicodeWriter_Finish

; 4443 : }

  00070	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00074	5b		 pop	 rbx
  00075	c3		 ret	 0
long__format__ ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT long_sizeof
_TEXT	SEGMENT
v$ = 8
long_sizeof PROC					; COMDAT

; 4613 :     Py_ssize_t res;
; 4614 : 
; 4615 :     res = offsetof(PyLongObject, ob_digit) + ABS(Py_SIZE(v))*sizeof(digit);

  00000	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00004	48 85 c9	 test	 rcx, rcx
  00007	79 03		 jns	 SHORT $LN3@long_sizeo
  00009	48 f7 d9	 neg	 rcx
$LN3@long_sizeo:
  0000c	48 8d 0c 8d 70
	00 00 00	 lea	 rcx, QWORD PTR [rcx*4+112]

; 4616 :     return PyLong_FromSsize_t(res);
; 4617 : }

  00014	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
long_sizeof ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@NMHKNCFJ@byteorder?5must?5be?5either?5?8little@ ; `string'
PUBLIC	??_C@_0CF@DOGCLHPA@length?5argument?5must?5be?5non?9nega@ ; `string'
PUBLIC	??_C@_03CCCOBCKE@big?$AA@			; `string'
PUBLIC	??_C@_06LADGIEOA@little?$AA@			; `string'
PUBLIC	??_C@_0CE@NEILIJIN@?8signed?8?5is?5a?5keyword?9only?5argum@ ; `string'
PUBLIC	??_C@_0O@IDCGKBE@nU?$HMO?3to_bytes?$AA@		; `string'
EXTRN	PyObject_IsTrue:PROC
EXTRN	PyUnicode_CompareWithASCIIString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_to_bytes DD imagerel long_to_bytes
	DD	imagerel long_to_bytes+329
	DD	imagerel $unwind$long_to_bytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_to_bytes DD 089601H
	DD	0c6496H
	DD	0e5410H
	DD	0d3410H
	DD	0700c9210H
xdata	ENDS
;	COMDAT ??_C@_0CL@NMHKNCFJ@byteorder?5must?5be?5either?5?8little@
CONST	SEGMENT
??_C@_0CL@NMHKNCFJ@byteorder?5must?5be?5either?5?8little@ DB 'byteorder m'
	DB	'ust be either ''little'' or ''big''', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DOGCLHPA@length?5argument?5must?5be?5non?9nega@
CONST	SEGMENT
??_C@_0CF@DOGCLHPA@length?5argument?5must?5be?5non?9nega@ DB 'length argu'
	DB	'ment must be non-negative', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CCCOBCKE@big?$AA@
CONST	SEGMENT
??_C@_03CCCOBCKE@big?$AA@ DB 'big', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06LADGIEOA@little?$AA@
CONST	SEGMENT
??_C@_06LADGIEOA@little?$AA@ DB 'little', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NEILIJIN@?8signed?8?5is?5a?5keyword?9only?5argum@
CONST	SEGMENT
??_C@_0CE@NEILIJIN@?8signed?8?5is?5a?5keyword?9only?5argum@ DB '''signed'''
	DB	' is a keyword-only argument', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IDCGKBE@nU?$HMO?3to_bytes?$AA@
CONST	SEGMENT
??_C@_0O@IDCGKBE@nU?$HMO?3to_bytes?$AA@ DB 'nU|O:to_bytes', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT long_to_bytes
_TEXT	SEGMENT
is_signed_obj$ = 64
length$ = 72
v$ = 96
args$ = 104
kwds$ = 112
byteorder_str$ = 120
long_to_bytes PROC					; COMDAT

; 4694 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00007	49 89 6b 18	 mov	 QWORD PTR [r11+24], rbp
  0000b	57		 push	 rdi
  0000c	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00010	48 8b e9	 mov	 rbp, rcx

; 4695 :     PyObject *byteorder_str;
; 4696 :     PyObject *is_signed_obj = NULL;
; 4697 :     Py_ssize_t length;
; 4698 :     int little_endian;
; 4699 :     int is_signed;
; 4700 :     PyObject *bytes;
; 4701 :     static char *kwlist[] = {"length", "byteorder", "signed", NULL};
; 4702 : 
; 4703 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "nU|O:to_bytes", kwlist,
; 4704 :                                      &length, &byteorder_str,
; 4705 :                                      &is_signed_obj))

  00013	49 8d 4b e8	 lea	 rcx, QWORD PTR [r11-24]
  00017	49 8b c0	 mov	 rax, r8
  0001a	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  0001e	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00022	48 8b da	 mov	 rbx, rdx
  00025	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  00029	49 8d 4b f0	 lea	 rcx, QWORD PTR [r11-16]
  0002d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??long_to_bytes@@9@9
  00034	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  00038	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@IDCGKBE@nU?$HMO?3to_bytes?$AA@
  0003f	33 ff		 xor	 edi, edi
  00041	48 8b cb	 mov	 rcx, rbx
  00044	48 8b d0	 mov	 rdx, rax
  00047	49 89 7b e8	 mov	 QWORD PTR [r11-24], rdi
  0004b	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00050	85 c0		 test	 eax, eax

; 4706 :         return NULL;

  00052	74 1f		 je	 SHORT $LN19@long_to_by

; 4707 : 
; 4708 :     if (args != NULL && Py_SIZE(args) > 2) {

  00054	48 85 db	 test	 rbx, rbx
  00057	74 2c		 je	 SHORT $LN11@long_to_by
  00059	48 83 7b 60 02	 cmp	 QWORD PTR [rbx+96], 2
  0005e	7e 25		 jle	 SHORT $LN11@long_to_by

; 4709 :         PyErr_SetString(PyExc_TypeError,
; 4710 :             "'signed' is a keyword-only argument");

  00060	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@NEILIJIN@?8signed?8?5is?5a?5keyword?9only?5argum@
  0006e	e8 00 00 00 00	 call	 PyErr_SetString
$LN19@long_to_by:

; 4711 :         return NULL;

  00073	33 c0		 xor	 eax, eax

; 4753 : }

  00075	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  0007a	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  0007f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
$LN11@long_to_by:

; 4712 :     }
; 4713 : 
; 4714 :     if (!PyUnicode_CompareWithASCIIString(byteorder_str, "little"))

  00085	48 8b 4c 24 78	 mov	 rcx, QWORD PTR byteorder_str$[rsp]
  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06LADGIEOA@little?$AA@
  00091	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00096	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  0009b	85 c0		 test	 eax, eax
  0009d	75 05		 jne	 SHORT $LN10@long_to_by

; 4715 :         little_endian = 1;

  0009f	8d 70 01	 lea	 esi, QWORD PTR [rax+1]
  000a2	eb 17		 jmp	 SHORT $LN7@long_to_by
$LN10@long_to_by:

; 4716 :     else if (!PyUnicode_CompareWithASCIIString(byteorder_str, "big"))

  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR byteorder_str$[rsp]
  000a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03CCCOBCKE@big?$AA@
  000b0	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  000b5	85 c0		 test	 eax, eax
  000b7	75 66		 jne	 SHORT $LN8@long_to_by

; 4717 :         little_endian = 0;

  000b9	8b f7		 mov	 esi, edi
$LN7@long_to_by:

; 4722 :     }
; 4723 : 
; 4724 :     if (is_signed_obj != NULL) {

  000bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is_signed_obj$[rsp]
  000c0	48 85 c9	 test	 rcx, rcx
  000c3	74 0d		 je	 SHORT $LN6@long_to_by

; 4725 :         int cmp = PyObject_IsTrue(is_signed_obj);

  000c5	e8 00 00 00 00	 call	 PyObject_IsTrue

; 4726 :         if (cmp < 0)

  000ca	85 c0		 test	 eax, eax

; 4727 :             return NULL;

  000cc	78 64		 js	 SHORT $LN17@long_to_by

; 4728 :         is_signed = cmp ? 1 : 0;

  000ce	40 0f 95 c7	 setne	 dil
$LN6@long_to_by:

; 4729 :     }
; 4730 :     else {
; 4731 :         /* If the signed argument was omitted, use False as the
; 4732 :            default. */
; 4733 :         is_signed = 0;
; 4734 :     }
; 4735 : 
; 4736 :     if (length < 0) {

  000d2	48 8b 54 24 48	 mov	 rdx, QWORD PTR length$[rsp]
  000d7	48 85 d2	 test	 rdx, rdx
  000da	79 09		 jns	 SHORT $LN3@long_to_by

; 4737 :         PyErr_SetString(PyExc_ValueError,
; 4738 :                         "length argument must be non-negative");

  000dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@DOGCLHPA@length?5argument?5must?5be?5non?9nega@

; 4739 :         return NULL;

  000e3	eb 41		 jmp	 SHORT $LN18@long_to_by
$LN3@long_to_by:

; 4740 :     }
; 4741 : 
; 4742 :     bytes = PyBytes_FromStringAndSize(NULL, length);

  000e5	33 c9		 xor	 ecx, ecx
  000e7	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000ec	48 8b d8	 mov	 rbx, rax

; 4743 :     if (bytes == NULL)

  000ef	48 85 c0	 test	 rax, rax

; 4744 :         return NULL;

  000f2	74 3e		 je	 SHORT $LN17@long_to_by

; 4745 : 
; 4746 :     if (_PyLong_AsByteArray(v, (unsigned char *)PyBytes_AS_STRING(bytes),
; 4747 :                             length, little_endian, is_signed) < 0) {

  000f4	4c 8b 44 24 48	 mov	 r8, QWORD PTR length$[rsp]
  000f9	48 8d 50 78	 lea	 rdx, QWORD PTR [rax+120]
  000fd	44 8b ce	 mov	 r9d, esi
  00100	48 8b cd	 mov	 rcx, rbp
  00103	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  00107	e8 00 00 00 00	 call	 _PyLong_AsByteArray
  0010c	85 c0		 test	 eax, eax
  0010e	79 0a		 jns	 SHORT $LN1@long_to_by

; 4748 :         Py_DECREF(bytes);

  00110	48 8b cb	 mov	 rcx, rbx
  00113	e8 00 00 00 00	 call	 _Py_DecRef

; 4749 :         return NULL;

  00118	eb 18		 jmp	 SHORT $LN17@long_to_by
$LN1@long_to_by:

; 4750 :     }
; 4751 : 
; 4752 :     return bytes;

  0011a	48 8b c3	 mov	 rax, rbx
  0011d	eb 15		 jmp	 SHORT $LN15@long_to_by
$LN8@long_to_by:

; 4718 :     else {
; 4719 :         PyErr_SetString(PyExc_ValueError,
; 4720 :             "byteorder must be either 'little' or 'big'");

  0011f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@NMHKNCFJ@byteorder?5must?5be?5either?5?8little@
$LN18@long_to_by:
  00126	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0012d	e8 00 00 00 00	 call	 PyErr_SetString
$LN17@long_to_by:

; 4721 :         return NULL;

  00132	33 c0		 xor	 eax, eax
$LN15@long_to_by:
  00134	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]

; 4753 : }

  00139	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  0013e	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00143	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00147	5f		 pop	 rdi
  00148	c3		 ret	 0
long_to_bytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@OCGOJEAF@OU?$HMO?3from_bytes?$AA@	; `string'
EXTRN	PyObject_Bytes:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_from_bytes DD imagerel long_from_bytes
	DD	imagerel long_from_bytes+136
	DD	imagerel $unwind$long_from_bytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$long_from_bytes DD imagerel long_from_bytes+136
	DD	imagerel long_from_bytes+366
	DD	imagerel $chain$1$long_from_bytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$long_from_bytes DD imagerel long_from_bytes+366
	DD	imagerel long_from_bytes+438
	DD	imagerel $chain$3$long_from_bytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$long_from_bytes DD imagerel long_from_bytes+438
	DD	imagerel long_from_bytes+473
	DD	imagerel $chain$4$long_from_bytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$long_from_bytes DD 020021H
	DD	0f6400H
	DD	imagerel long_from_bytes
	DD	imagerel long_from_bytes+136
	DD	imagerel $unwind$long_from_bytes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$long_from_bytes DD 040021H
	DD	0f6400H
	DD	0e5400H
	DD	imagerel long_from_bytes
	DD	imagerel long_from_bytes+136
	DD	imagerel $unwind$long_from_bytes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$long_from_bytes DD 045c21H
	DD	0e545cH
	DD	0f6405H
	DD	imagerel long_from_bytes
	DD	imagerel long_from_bytes+136
	DD	imagerel $unwind$long_from_bytes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_from_bytes DD 040b01H
	DD	0c007920bH
	DD	030047005H
xdata	ENDS
;	COMDAT ??_C@_0BA@OCGOJEAF@OU?$HMO?3from_bytes?$AA@
CONST	SEGMENT
??_C@_0BA@OCGOJEAF@OU?$HMO?3from_bytes?$AA@ DB 'OU|O:from_bytes', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT long_from_bytes
_TEXT	SEGMENT
is_signed_obj$ = 64
obj$ = 72
type$ = 112
args$ = 120
kwds$ = 128
byteorder_str$ = 136
long_from_bytes PROC					; COMDAT

; 4776 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000b	4c 8b e1	 mov	 r12, rcx

; 4777 :     PyObject *byteorder_str;
; 4778 :     PyObject *is_signed_obj = NULL;
; 4779 :     int little_endian;
; 4780 :     int is_signed;
; 4781 :     PyObject *obj;
; 4782 :     PyObject *bytes;
; 4783 :     PyObject *long_obj;
; 4784 :     static char *kwlist[] = {"bytes", "byteorder", "signed", NULL};
; 4785 : 
; 4786 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "OU|O:from_bytes", kwlist,
; 4787 :                                      &obj, &byteorder_str,
; 4788 :                                      &is_signed_obj))

  0000e	49 8d 4b d8	 lea	 rcx, QWORD PTR [r11-40]
  00012	49 8b c0	 mov	 rax, r8
  00015	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  00019	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0001d	48 8b fa	 mov	 rdi, rdx
  00020	49 89 4b c0	 mov	 QWORD PTR [r11-64], rcx
  00024	49 8d 4b e0	 lea	 rcx, QWORD PTR [r11-32]
  00028	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??long_from_bytes@@9@9
  0002f	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  00033	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@OCGOJEAF@OU?$HMO?3from_bytes?$AA@
  0003a	33 db		 xor	 ebx, ebx
  0003c	48 8b cf	 mov	 rcx, rdi
  0003f	48 8b d0	 mov	 rdx, rax
  00042	49 89 5b d8	 mov	 QWORD PTR [r11-40], rbx
  00046	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0004b	85 c0		 test	 eax, eax

; 4789 :         return NULL;

  0004d	74 1f		 je	 SHORT $LN26@long_from_@2

; 4790 : 
; 4791 :     if (args != NULL && Py_SIZE(args) > 2) {

  0004f	48 85 ff	 test	 rdi, rdi
  00052	74 25		 je	 SHORT $LN14@long_from_@2
  00054	48 83 7f 60 02	 cmp	 QWORD PTR [rdi+96], 2
  00059	7e 1e		 jle	 SHORT $LN14@long_from_@2

; 4792 :         PyErr_SetString(PyExc_TypeError,
; 4793 :             "'signed' is a keyword-only argument");

  0005b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@NEILIJIN@?8signed?8?5is?5a?5keyword?9only?5argum@
  00069	e8 00 00 00 00	 call	 PyErr_SetString
$LN26@long_from_@2:

; 4794 :         return NULL;

  0006e	33 c0		 xor	 eax, eax

; 4852 : }

  00070	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00074	41 5c		 pop	 r12
  00076	5f		 pop	 rdi
  00077	5b		 pop	 rbx
  00078	c3		 ret	 0
$LN14@long_from_@2:

; 4795 :     }
; 4796 : 
; 4797 :     if (!PyUnicode_CompareWithASCIIString(byteorder_str, "little"))

  00079	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR byteorder_str$[rsp]
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06LADGIEOA@little?$AA@
  00088	48 89 74 24 78	 mov	 QWORD PTR [rsp+120], rsi
  0008d	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  00092	85 c0		 test	 eax, eax
  00094	75 05		 jne	 SHORT $LN13@long_from_@2

; 4798 :         little_endian = 1;

  00096	8d 70 01	 lea	 esi, QWORD PTR [rax+1]
  00099	eb 1e		 jmp	 SHORT $LN10@long_from_@2
$LN13@long_from_@2:

; 4799 :     else if (!PyUnicode_CompareWithASCIIString(byteorder_str, "big"))

  0009b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR byteorder_str$[rsp]
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03CCCOBCKE@big?$AA@
  000aa	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  000af	85 c0		 test	 eax, eax
  000b1	0f 85 ff 00 00
	00		 jne	 $LN11@long_from_@2

; 4800 :         little_endian = 0;

  000b7	8b f3		 mov	 esi, ebx
$LN10@long_from_@2:

; 4805 :     }
; 4806 : 
; 4807 :     if (is_signed_obj != NULL) {

  000b9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is_signed_obj$[rsp]
  000be	48 85 c9	 test	 rcx, rcx
  000c1	74 15		 je	 SHORT $LN9@long_from_@2

; 4808 :         int cmp = PyObject_IsTrue(is_signed_obj);

  000c3	e8 00 00 00 00	 call	 PyObject_IsTrue

; 4809 :         if (cmp < 0)

  000c8	85 c0		 test	 eax, eax

; 4810 :             return NULL;

  000ca	0f 88 f9 00 00
	00		 js	 $LN25@long_from_@2

; 4811 :         is_signed = cmp ? 1 : 0;

  000d0	8b fb		 mov	 edi, ebx
  000d2	40 0f 95 c7	 setne	 dil

; 4812 :     }
; 4813 :     else {

  000d6	eb 02		 jmp	 SHORT $LN7@long_from_@2
$LN9@long_from_@2:

; 4814 :         /* If the signed argument was omitted, use False as the
; 4815 :            default. */
; 4816 :         is_signed = 0;

  000d8	8b fb		 mov	 edi, ebx
$LN7@long_from_@2:

; 4817 :     }
; 4818 : 
; 4819 :     bytes = PyObject_Bytes(obj);

  000da	48 8b 4c 24 48	 mov	 rcx, QWORD PTR obj$[rsp]
  000df	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  000e4	e8 00 00 00 00	 call	 PyObject_Bytes
  000e9	48 8b e8	 mov	 rbp, rax

; 4820 :     if (bytes == NULL)

  000ec	48 85 c0	 test	 rax, rax

; 4821 :         return NULL;

  000ef	74 68		 je	 SHORT $LN24@long_from_@2

; 4822 : 
; 4823 :     long_obj = _PyLong_FromByteArray(
; 4824 :         (unsigned char *)PyBytes_AS_STRING(bytes), Py_SIZE(bytes),
; 4825 :         little_endian, is_signed);

  000f1	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000f5	48 8d 48 78	 lea	 rcx, QWORD PTR [rax+120]
  000f9	44 8b cf	 mov	 r9d, edi
  000fc	44 8b c6	 mov	 r8d, esi
  000ff	e8 00 00 00 00	 call	 _PyLong_FromByteArray

; 4826 :     Py_DECREF(bytes);

  00104	48 8b cd	 mov	 rcx, rbp
  00107	48 8b f0	 mov	 rsi, rax
  0010a	e8 00 00 00 00	 call	 _Py_DecRef

; 4827 : 
; 4828 :     /* If from_bytes() was used on subclass, allocate new subclass
; 4829 :      * instance, initialize it with decoded int value and return it.
; 4830 :      */
; 4831 :     if (type != &PyLong_Type && PyType_IsSubtype(type, &PyLong_Type)) {

  0010f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyLong_Type
  00116	4c 3b e2	 cmp	 r12, rdx
  00119	0f 84 92 00 00
	00		 je	 $LN5@long_from_@2
  0011f	49 8b cc	 mov	 rcx, r12
  00122	e8 00 00 00 00	 call	 PyType_IsSubtype
  00127	85 c0		 test	 eax, eax
  00129	0f 84 82 00 00
	00		 je	 $LN5@long_from_@2

; 4832 :         PyLongObject *newobj;
; 4833 :         int i;
; 4834 :         Py_ssize_t n = ABS(Py_SIZE(long_obj));

  0012f	48 8b 7e 60	 mov	 rdi, QWORD PTR [rsi+96]
  00133	48 85 ff	 test	 rdi, rdi
  00136	79 03		 jns	 SHORT $LN18@long_from_@2
  00138	48 f7 df	 neg	 rdi
$LN18@long_from_@2:

; 4835 : 
; 4836 :         newobj = (PyLongObject *)type->tp_alloc(type, n);

  0013b	48 8b d7	 mov	 rdx, rdi
  0013e	49 8b cc	 mov	 rcx, r12
  00141	41 ff 94 24 88
	01 00 00	 call	 QWORD PTR [r12+392]
  00149	48 8b e8	 mov	 rbp, rax

; 4837 :         if (newobj == NULL) {

  0014c	48 85 c0	 test	 rax, rax
  0014f	75 1d		 jne	 SHORT $LN4@long_from_@2

; 4838 :             Py_DECREF(long_obj);

  00151	48 8b ce	 mov	 rcx, rsi
  00154	e8 00 00 00 00	 call	 _Py_DecRef
$LN24@long_from_@2:

; 4839 :             return NULL;

  00159	33 c0		 xor	 eax, eax
$LN23@long_from_@2:
  0015b	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00160	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]

; 4852 : }

  00165	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00169	41 5c		 pop	 r12
  0016b	5f		 pop	 rdi
  0016c	5b		 pop	 rbx
  0016d	c3		 ret	 0
$LN4@long_from_@2:

; 4840 :         }
; 4841 :         assert(PyLong_Check(newobj));
; 4842 :         Py_SIZE(newobj) = Py_SIZE(long_obj);

  0016e	48 8b 46 60	 mov	 rax, QWORD PTR [rsi+96]
  00172	48 89 45 60	 mov	 QWORD PTR [rbp+96], rax

; 4843 :         for (i = 0; i < n; i++) {

  00176	48 85 ff	 test	 rdi, rdi
  00179	7e 29		 jle	 SHORT $LN1@long_from_@2
  0017b	48 8b d6	 mov	 rdx, rsi
  0017e	48 8d 4d 70	 lea	 rcx, QWORD PTR [rbp+112]
  00182	48 2b d5	 sub	 rdx, rbp
  00185	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL3@long_from_@2:

; 4844 :             newobj->ob_digit[i] =
; 4845 :                 ((PyLongObject *)long_obj)->ob_digit[i];

  00190	8b 04 0a	 mov	 eax, DWORD PTR [rdx+rcx]
  00193	ff c3		 inc	 ebx
  00195	48 83 c1 04	 add	 rcx, 4
  00199	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  0019c	48 63 c3	 movsxd	 rax, ebx
  0019f	48 3b c7	 cmp	 rax, rdi
  001a2	7c ec		 jl	 SHORT $LL3@long_from_@2
$LN1@long_from_@2:

; 4846 :         }
; 4847 :         Py_DECREF(long_obj);

  001a4	48 8b ce	 mov	 rcx, rsi
  001a7	e8 00 00 00 00	 call	 _Py_DecRef

; 4848 :         return (PyObject *)newobj;

  001ac	48 8b c5	 mov	 rax, rbp
  001af	eb aa		 jmp	 SHORT $LN23@long_from_@2
$LN5@long_from_@2:

; 4849 :     }
; 4850 : 
; 4851 :     return long_obj;

  001b1	48 8b c6	 mov	 rax, rsi
  001b4	eb a5		 jmp	 SHORT $LN23@long_from_@2
$LN11@long_from_@2:

; 4801 :     else {
; 4802 :         PyErr_SetString(PyExc_ValueError,
; 4803 :             "byteorder must be either 'little' or 'big'");

  001b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@NMHKNCFJ@byteorder?5must?5be?5either?5?8little@
  001c4	e8 00 00 00 00	 call	 PyErr_SetString
$LN25@long_from_@2:

; 4804 :         return NULL;

  001c9	33 c0		 xor	 eax, eax
  001cb	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]

; 4852 : }

  001d0	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001d4	41 5c		 pop	 r12
  001d6	5f		 pop	 rdi
  001d7	5b		 pop	 rbx
  001d8	c3		 ret	 0
long_from_bytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@EJEPDOAF@PyLong_GetInfo?$AA@		; `string'
PUBLIC	PyLong_GetInfo
EXTRN	PyStructSequence_New:PROC
_BSS	SEGMENT
Int_InfoType DB	01e0H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_GetInfo DD imagerel $LN9
	DD	imagerel $LN9+129
	DD	imagerel $unwind$PyLong_GetInfo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_GetInfo DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0P@EJEPDOAF@PyLong_GetInfo?$AA@
CONST	SEGMENT
??_C@_0P@EJEPDOAF@PyLong_GetInfo?$AA@ DB 'PyLong_GetInfo', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyLong_GetInfo
_TEXT	SEGMENT
PyLong_GetInfo PROC					; COMDAT

; 5040 : {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 5041 :     PyObject* int_info;
; 5042 :     int field = 0;
; 5043 :     int_info = PyStructSequence_New(&Int_InfoType);

  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Int_InfoType
  0000d	e8 00 00 00 00	 call	 PyStructSequence_New
  00012	48 8b d8	 mov	 rbx, rax

; 5044 :     if (int_info == NULL)

  00015	48 85 c0	 test	 rax, rax

; 5045 :         return NULL;

  00018	74 56		 je	 SHORT $LN3@PyLong_Get

; 5046 :     PyStructSequence_SET_ITEM(int_info, field++,
; 5047 :                               PyLong_FromLong(PyLong_SHIFT));

  0001a	b9 1e 00 00 00	 mov	 ecx, 30
  0001f	e8 00 00 00 00	 call	 PyLong_FromLong

; 5048 :     PyStructSequence_SET_ITEM(int_info, field++,
; 5049 :                               PyLong_FromLong(sizeof(digit)));

  00024	b9 04 00 00 00	 mov	 ecx, 4
  00029	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax
  0002d	e8 00 00 00 00	 call	 PyLong_FromLong
  00032	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 5050 :     if (PyErr_Occurred()) {

  00036	e8 00 00 00 00	 call	 PyErr_Occurred
  0003b	48 85 c0	 test	 rax, rax
  0003e	74 38		 je	 SHORT $LN5@PyLong_Get

; 5051 :         Py_CLEAR(int_info);

  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@EJEPDOAF@PyLong_GetInfo?$AA@
  0004e	4c 8b cb	 mov	 r9, rbx
  00051	41 b8 bb 13 00
	00		 mov	 r8d, 5051		; 000013bbH
  00057	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0005f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00064	85 c0		 test	 eax, eax
  00066	75 08		 jne	 SHORT $LN3@PyLong_Get
  00068	48 8b cb	 mov	 rcx, rbx
  0006b	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyLong_Get:

; 5052 :         return NULL;

  00070	33 c0		 xor	 eax, eax

; 5055 : }

  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5b		 pop	 rbx
  00077	c3		 ret	 0
$LN5@PyLong_Get:

; 5053 :     }
; 5054 :     return int_info;

  00078	48 8b c3	 mov	 rax, rbx

; 5055 : }

  0007b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007f	5b		 pop	 rbx
  00080	c3		 ret	 0
PyLong_GetInfo ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@JENOEIIN@_PyLong_Init?$AA@		; `string'
PUBLIC	_PyLong_Init
EXTRN	PyStructSequence_InitType:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\objimpl.h
pdata	SEGMENT
$pdata$_PyLong_Init DD imagerel $LN25
	DD	imagerel $LN25+7
	DD	imagerel $unwind$_PyLong_Init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$_PyLong_Init DD imagerel $LN25+7
	DD	imagerel $LN25+399
	DD	imagerel $chain$7$_PyLong_Init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$_PyLong_Init DD imagerel $LN25+399
	DD	imagerel $LN25+428
	DD	imagerel $chain$8$_PyLong_Init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$_PyLong_Init DD 021H
	DD	imagerel $LN25
	DD	imagerel $LN25+7
	DD	imagerel $unwind$_PyLong_Init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$_PyLong_Init DD 0102c21H
	DD	09c42cH
	DD	0d541cH
	DD	06f418H
	DD	07e414H
	DD	08d410H
	DD	0a740cH
	DD	0e6408H
	DD	0c3404H
	DD	imagerel $LN25
	DD	imagerel $LN25+7
	DD	imagerel $unwind$_PyLong_Init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_Init DD 010701H
	DD	0a207H
xdata	ENDS
;	COMDAT ??_C@_0N@JENOEIIN@_PyLong_Init?$AA@
CONST	SEGMENT
??_C@_0N@JENOEIIN@_PyLong_Init?$AA@ DB '_PyLong_Init', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
CONST	ENDS
;	COMDAT _PyLong_Init
_TEXT	SEGMENT
_PyLong_Init PROC					; COMDAT

; 5059 : {

$LN25:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00007	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 f8	 mov	 QWORD PTR [rax-8], rdi
  00013	4c 89 68 e8	 mov	 QWORD PTR [rax-24], r13
  00017	4c 89 70 e0	 mov	 QWORD PTR [rax-32], r14
  0001b	4c 89 78 d8	 mov	 QWORD PTR [rax-40], r15
  0001f	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp

; 5060 : #if NSMALLNEGINTS + NSMALLPOSINTS > 0
; 5061 :     int ival, size;
; 5062 :     PyLongObject *v = small_ints;
; 5063 : 
; 5064 :     for (ival = -NSMALLNEGINTS; ival <  NSMALLPOSINTS; ival++, v++) {

  00023	bf fb ff ff ff	 mov	 edi, -5
  00028	48 8d 1d 58 00
	00 00		 lea	 rbx, OFFSET FLAT:small_ints+88
  0002f	4c 89 60 f0	 mov	 QWORD PTR [rax-16], r12
  00033	45 33 f6	 xor	 r14d, r14d
  00036	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:PyLong_Type
  0003d	49 bf 78 56 ef
	be 34 12 ad de	 mov	 r15, -2401243008567650696 ; dead1234beef5678H
$LL6@PyLong_Ini:

; 5065 :         size = (ival < 0) ? -1 : ((ival == 0) ? 0 : 1);

  00047	85 ff		 test	 edi, edi
  00049	79 05		 jns	 SHORT $LN9@PyLong_Ini
  0004b	83 ce ff	 or	 esi, -1
  0004e	eb 09		 jmp	 SHORT $LN10@PyLong_Ini
$LN9@PyLong_Ini:
  00050	85 ff		 test	 edi, edi
  00052	41 8b f6	 mov	 esi, r14d
  00055	40 0f 95 c6	 setne	 sil
$LN10@PyLong_Ini:

; 5066 :         if (Py_TYPE(v) == &PyLong_Type) {

  00059	4c 39 2b	 cmp	 QWORD PTR [rbx], r13
  0005c	75 5e		 jne	 SHORT $LN3@PyLong_Ini

; 5067 :             /* The element is already initialized, most likely
; 5068 :              * the Python interpreter was initialized before.
; 5069 :              */
; 5070 :             Py_ssize_t refcnt;
; 5071 :             PyObject* op = (PyObject*)v;
; 5072 : 
; 5073 :             refcnt = Py_REFCNT(op) < 0 ? 0 : Py_REFCNT(op);

  0005e	4c 8b 63 f8	 mov	 r12, QWORD PTR [rbx-8]

; 5074 :             _Py_NewReference(op);

  00062	4c 8d 4b a8	 lea	 r9, QWORD PTR [rbx-88]
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PEFAOAL@?4?4?2Objects?2longobject?4c?$AA@
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@JENOEIIN@_PyLong_Init?$AA@
  00074	4d 85 e4	 test	 r12, r12
  00077	41 b8 d2 13 00
	00		 mov	 r8d, 5074		; 000013d2H
  0007d	4d 0f 48 e6	 cmovs	 r12, r14
  00081	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00089	e8 00 00 00 00	 call	 _PyParallel_Guard
  0008e	85 c0		 test	 eax, eax
  00090	74 17		 je	 SHORT $LN13@PyLong_Ini
  00092	48 8d 4b a8	 lea	 rcx, QWORD PTR [rbx-88]
  00096	e8 00 00 00 00	 call	 _Px_NewReference

; 5075 :             /* _Py_NewReference sets the ref count to 1 but
; 5076 :              * the ref count might be larger. Set the refcnt
; 5077 :              * to the original refcnt + 1 */
; 5078 :             Py_REFCNT(op) = refcnt + 1;

  0009b	49 8d 44 24 01	 lea	 rax, QWORD PTR [r12+1]
  000a0	48 89 43 f8	 mov	 QWORD PTR [rbx-8], rax

; 5079 :             assert(Py_SIZE(op) == size);
; 5080 :             assert(v->ob_digit[0] == abs(ival));
; 5081 :         }
; 5082 :         else {

  000a4	e9 91 00 00 00	 jmp	 $LN19@PyLong_Ini
$LN13@PyLong_Ini:

; 5075 :             /* _Py_NewReference sets the ref count to 1 but
; 5076 :              * the ref count might be larger. Set the refcnt
; 5077 :              * to the original refcnt + 1 */
; 5078 :             Py_REFCNT(op) = refcnt + 1;

  000a9	49 8d 44 24 01	 lea	 rax, QWORD PTR [r12+1]
  000ae	48 c7 43 f8 01
	00 00 00	 mov	 QWORD PTR [rbx-8], 1
  000b6	48 89 43 f8	 mov	 QWORD PTR [rbx-8], rax

; 5079 :             assert(Py_SIZE(op) == size);
; 5080 :             assert(v->ob_digit[0] == abs(ival));
; 5081 :         }
; 5082 :         else {

  000ba	eb 7e		 jmp	 SHORT $LN19@PyLong_Ini
$LN3@PyLong_Ini:

; 5083 :             PyObject_INIT((PyObject *)v, &PyLong_Type);

  000bc	e8 00 00 00 00	 call	 _Py_PXCTX
  000c1	85 c0		 test	 eax, eax
  000c3	74 0e		 je	 SHORT $LN15@PyLong_Ini
  000c5	48 8d 4b a8	 lea	 rcx, QWORD PTR [rbx-88]
  000c9	49 8b d5	 mov	 rdx, r13
  000cc	e8 00 00 00 00	 call	 _PxObject_Init
  000d1	eb 67		 jmp	 SHORT $LN19@PyLong_Ini
$LN15@PyLong_Ini:
  000d3	4c 8d 4b a8	 lea	 r9, QWORD PTR [rbx-88]
  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@
  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@JKHPLOII@PyObject_INIT?$AA@
  000e5	41 b8 f0 00 00
	00		 mov	 r8d, 240		; 000000f0H
  000eb	4c 89 2b	 mov	 QWORD PTR [rbx], r13
  000ee	4c 89 7b a8	 mov	 QWORD PTR [rbx-88], r15
  000f2	4c 89 7b b0	 mov	 QWORD PTR [rbx-80], r15
  000f6	4c 89 73 b8	 mov	 QWORD PTR [rbx-72], r14
  000fa	48 c7 43 c8 01
	00 00 00	 mov	 QWORD PTR [rbx-56], 1
  00102	4c 89 73 d0	 mov	 QWORD PTR [rbx-48], r14
  00106	4c 89 73 d8	 mov	 QWORD PTR [rbx-40], r14
  0010a	4c 89 73 e0	 mov	 QWORD PTR [rbx-32], r14
  0010e	4c 89 7b e8	 mov	 QWORD PTR [rbx-24], r15
  00112	4c 89 7b f0	 mov	 QWORD PTR [rbx-16], r15
  00116	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0011e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00123	85 c0		 test	 eax, eax
  00125	74 0b		 je	 SHORT $LN18@PyLong_Ini
  00127	48 8d 4b a8	 lea	 rcx, QWORD PTR [rbx-88]
  0012b	e8 00 00 00 00	 call	 _Px_NewReference
  00130	eb 08		 jmp	 SHORT $LN19@PyLong_Ini
$LN18@PyLong_Ini:
  00132	48 c7 43 f8 01
	00 00 00	 mov	 QWORD PTR [rbx-8], 1
$LN19@PyLong_Ini:

; 5084 :         }
; 5085 :         Py_SIZE(v) = size;

  0013a	48 63 c6	 movsxd	 rax, esi
  0013d	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  00141	48 89 43 88	 mov	 QWORD PTR [rbx-120], rax

; 5086 :         v->ob_digit[0] = abs(ival);

  00145	8b c7		 mov	 eax, edi
  00147	ff c7		 inc	 edi
  00149	99		 cdq
  0014a	33 c2		 xor	 eax, edx
  0014c	2b c2		 sub	 eax, edx
  0014e	89 43 98	 mov	 DWORD PTR [rbx-104], eax
  00151	81 ff 01 01 00
	00		 cmp	 edi, 257		; 00000101H
  00157	0f 8c ea fe ff
	ff		 jl	 $LL6@PyLong_Ini

; 5087 :     }
; 5088 : #endif
; 5089 :     /* initialize int_info */
; 5090 :     if (Int_InfoType.tp_name == 0)

  0015d	48 83 3d 70 00
	00 00 00	 cmp	 QWORD PTR Int_InfoType+112, 0
  00165	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]
  0016a	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]
  0016f	4c 8b 6c 24 40	 mov	 r13, QWORD PTR [rsp+64]
  00174	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  00179	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  0017e	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  00183	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00188	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0018d	75 13		 jne	 SHORT $LN24@PyLong_Ini

; 5091 :         PyStructSequence_InitType(&Int_InfoType, &int_info_desc);

  0018f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:int_info_desc
  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Int_InfoType
  0019d	e8 00 00 00 00	 call	 PyStructSequence_InitType
$LN24@PyLong_Ini:

; 5092 : 
; 5093 :     return 1;

  001a2	b8 01 00 00 00	 mov	 eax, 1

; 5094 : }

  001a7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ab	c3		 ret	 0
_PyLong_Init ENDP
_TEXT	ENDS
PUBLIC	PyLong_Fini
EXTRN	_Px_ForgetReference:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_Fini DD imagerel $LN13
	DD	imagerel $LN13+59
	DD	imagerel $unwind$PyLong_Fini
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_Fini DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyLong_Fini
_TEXT	SEGMENT
PyLong_Fini PROC					; COMDAT

; 5098 : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5099 :     /* Integers are currently statically allocated. Py_DECREF is not
; 5100 :        needed, but Python must forget about the reference or multiple
; 5101 :        reinitializations will fail. */
; 5102 : #if NSMALLNEGINTS + NSMALLPOSINTS > 0
; 5103 :     int i;
; 5104 :     PyLongObject *v = small_ints;

  0000a	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:small_ints
  00011	bf 06 01 00 00	 mov	 edi, 262		; 00000106H
$LL8@PyLong_Fin:

; 5106 :         _Py_DEC_REFTOTAL;
; 5107 :         _Py_ForgetReference((PyObject*)v);

  00016	e8 00 00 00 00	 call	 _Py_PXCTX
  0001b	85 c0		 test	 eax, eax
  0001d	74 08		 je	 SHORT $LN3@PyLong_Fin
  0001f	48 8b cb	 mov	 rcx, rbx
  00022	e8 00 00 00 00	 call	 _Px_ForgetReference
$LN3@PyLong_Fin:

; 5105 :     for (i = 0; i < NSMALLNEGINTS + NSMALLPOSINTS; i++, v++) {

  00027	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  0002b	48 ff cf	 dec	 rdi
  0002e	75 e6		 jne	 SHORT $LL8@PyLong_Fin

; 5108 :     }
; 5109 : #endif
; 5110 : }

  00030	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
PyLong_Fini ENDP
_TEXT	ENDS
PUBLIC	PyLong_FromVoidPtr
; Function compile flags: /Ogtpy
;	COMDAT PyLong_FromVoidPtr
_TEXT	SEGMENT
p$ = 8
PyLong_FromVoidPtr PROC					; COMDAT

; 975  : #if SIZEOF_VOID_P <= SIZEOF_LONG
; 976  :     /* special-case null pointer */
; 977  :     if (!p)
; 978  :         return PyLong_FromLong(0);
; 979  :     return PyLong_FromUnsignedLong((unsigned long)(Py_uintptr_t)p);
; 980  : #else
; 981  : 
; 982  : #ifndef HAVE_LONG_LONG
; 983  : #   error "PyLong_FromVoidPtr: sizeof(void*) > sizeof(long), but no long long"
; 984  : #endif
; 985  : #if SIZEOF_LONG_LONG < SIZEOF_VOID_P
; 986  : #   error "PyLong_FromVoidPtr: sizeof(PY_LONG_LONG) < sizeof(void*)"
; 987  : #endif
; 988  :     /* special-case null pointer */
; 989  :     if (!p)

  00000	48 85 c9	 test	 rcx, rcx
  00003	75 05		 jne	 SHORT $LN1@PyLong_Fro@13

; 990  :         return PyLong_FromLong(0);
; 991  :     return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG)(Py_uintptr_t)p);
; 992  : #endif /* SIZEOF_VOID_P <= SIZEOF_LONG */
; 993  : 
; 994  : }

  00005	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN1@PyLong_Fro@13:
  0000a	e9 00 00 00 00	 jmp	 PyLong_FromUnsignedLongLong
PyLong_FromVoidPtr ENDP
_TEXT	ENDS
PUBLIC	PyLong_AsVoidPtr
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_AsVoidPtr DD imagerel $LN7
	DD	imagerel $LN7+88
	DD	imagerel $unwind$PyLong_AsVoidPtr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_AsVoidPtr DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyLong_AsVoidPtr
_TEXT	SEGMENT
vv$ = 48
PyLong_AsVoidPtr PROC					; COMDAT

; 1000 : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1001 : #if SIZEOF_VOID_P <= SIZEOF_LONG
; 1002 :     long x;
; 1003 : 
; 1004 :     if (PyLong_Check(vv) && _PyLong_Sign(vv) < 0)
; 1005 :         x = PyLong_AsLong(vv);
; 1006 :     else
; 1007 :         x = PyLong_AsUnsignedLong(vv);
; 1008 : #else
; 1009 : 
; 1010 : #ifndef HAVE_LONG_LONG
; 1011 : #   error "PyLong_AsVoidPtr: sizeof(void*) > sizeof(long), but no long long"
; 1012 : #endif
; 1013 : #if SIZEOF_LONG_LONG < SIZEOF_VOID_P
; 1014 : #   error "PyLong_AsVoidPtr: sizeof(PY_LONG_LONG) < sizeof(void*)"
; 1015 : #endif
; 1016 :     PY_LONG_LONG x;
; 1017 : 
; 1018 :     if (PyLong_Check(vv) && _PyLong_Sign(vv) < 0)

  00006	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000a	4c 8b c1	 mov	 r8, rcx
  0000d	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00017	74 13		 je	 SHORT $LN3@PyLong_AsV
  00019	e8 00 00 00 00	 call	 _PyLong_Sign
  0001e	85 c0		 test	 eax, eax
  00020	79 0a		 jns	 SHORT $LN3@PyLong_AsV

; 1019 :         x = PyLong_AsLongLong(vv);

  00022	49 8b c8	 mov	 rcx, r8
  00025	e8 00 00 00 00	 call	 PyLong_AsLongLong

; 1020 :     else

  0002a	eb 08		 jmp	 SHORT $LN6@PyLong_AsV
$LN3@PyLong_AsV:

; 1021 :         x = PyLong_AsUnsignedLongLong(vv);

  0002c	49 8b c8	 mov	 rcx, r8
  0002f	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongLong
$LN6@PyLong_AsV:
  00034	48 8b d8	 mov	 rbx, rax

; 1022 : 
; 1023 : #endif /* SIZEOF_VOID_P <= SIZEOF_LONG */
; 1024 : 
; 1025 :     if (x == -1 && PyErr_Occurred())

  00037	48 83 f8 ff	 cmp	 rax, -1
  0003b	75 12		 jne	 SHORT $LN1@PyLong_AsV
  0003d	e8 00 00 00 00	 call	 PyErr_Occurred
  00042	48 85 c0	 test	 rax, rax
  00045	74 08		 je	 SHORT $LN1@PyLong_AsV

; 1026 :         return NULL;

  00047	33 c0		 xor	 eax, eax

; 1028 : }

  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5b		 pop	 rbx
  0004e	c3		 ret	 0
$LN1@PyLong_AsV:

; 1027 :     return (void *)x;

  0004f	48 8b c3	 mov	 rax, rbx

; 1028 : }

  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5b		 pop	 rbx
  00057	c3		 ret	 0
PyLong_AsVoidPtr ENDP
_TEXT	ENDS
PUBLIC	PyLong_FromUnicode
EXTRN	PyUnicode_FromUnicode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyLong_FromUnicode DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$PyLong_FromUnicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyLong_FromUnicode DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyLong_FromUnicode
_TEXT	SEGMENT
u$ = 48
length$ = 56
base$ = 64
PyLong_FromUnicode PROC					; COMDAT

; 2326 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	41 8b d8	 mov	 ebx, r8d

; 2327 :     PyObject *v, *unicode = PyUnicode_FromUnicode(u, length);

  0000d	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  00012	48 8b f8	 mov	 rdi, rax

; 2328 :     if (unicode == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0b		 jne	 SHORT $LN1@PyLong_Fro@14

; 2333 : }

  0001a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
$LN1@PyLong_Fro@14:

; 2329 :         return NULL;
; 2330 :     v = PyLong_FromUnicodeObject(unicode, base);

  00025	8b d3		 mov	 edx, ebx
  00027	48 8b c8	 mov	 rcx, rax
  0002a	e8 00 00 00 00	 call	 PyLong_FromUnicodeObject

; 2331 :     Py_DECREF(unicode);

  0002f	48 8b cf	 mov	 rcx, rdi
  00032	48 8b d8	 mov	 rbx, rax
  00035	e8 00 00 00 00	 call	 _Py_DecRef

; 2332 :     return v;

  0003a	48 8b c3	 mov	 rax, rbx

; 2333 : }

  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
PyLong_FromUnicode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@OPLMMFNH@integer?5division?5or?5modulo?5by?5ze@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_divrem DD imagerel long_divrem
	DD	imagerel long_divrem+118
	DD	imagerel $unwind$long_divrem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$long_divrem DD imagerel long_divrem+118
	DD	imagerel long_divrem+218
	DD	imagerel $chain$1$long_divrem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$long_divrem DD imagerel long_divrem+218
	DD	imagerel long_divrem+421
	DD	imagerel $chain$3$long_divrem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$long_divrem DD imagerel long_divrem+421
	DD	imagerel long_divrem+470
	DD	imagerel $chain$4$long_divrem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$long_divrem DD 021H
	DD	imagerel long_divrem
	DD	imagerel long_divrem+118
	DD	imagerel $unwind$long_divrem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$long_divrem DD 040021H
	DD	0a7400H
	DD	093400H
	DD	imagerel long_divrem
	DD	imagerel long_divrem+118
	DD	imagerel $unwind$long_divrem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$long_divrem DD 041321H
	DD	0a7413H
	DD	093405H
	DD	imagerel long_divrem
	DD	imagerel long_divrem+118
	DD	imagerel $unwind$long_divrem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_divrem DD 060e01H
	DD	0b540eH
	DD	0d00a320eH
	DD	06006c008H
xdata	ENDS
;	COMDAT ??_C@_0CD@OPLMMFNH@integer?5division?5or?5modulo?5by?5ze@
CONST	SEGMENT
??_C@_0CD@OPLMMFNH@integer?5division?5or?5modulo?5by?5ze@ DB 'integer div'
	DB	'ision or modulo by zero', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT long_divrem
_TEXT	SEGMENT
rem$21990 = 64
a$ = 64
b$ = 72
pdiv$ = 80
prem$ = 88
long_divrem PROC					; COMDAT

; 2380 : {

  00000	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00005	56		 push	 rsi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2381 :     Py_ssize_t size_a = ABS(Py_SIZE(a)), size_b = ABS(Py_SIZE(b));

  0000e	4c 8b 51 60	 mov	 r10, QWORD PTR [rcx+96]
  00012	4d 8b e1	 mov	 r12, r9
  00015	4d 8b e8	 mov	 r13, r8
  00018	48 8b ea	 mov	 rbp, rdx
  0001b	48 8b f1	 mov	 rsi, rcx
  0001e	4d 85 d2	 test	 r10, r10
  00021	79 03		 jns	 SHORT $LN24@long_divre
  00023	49 f7 da	 neg	 r10
$LN24@long_divre:
  00026	48 8b 4a 60	 mov	 rcx, QWORD PTR [rdx+96]
  0002a	48 85 c9	 test	 rcx, rcx
  0002d	79 06		 jns	 SHORT $LN38@long_divre
  0002f	48 f7 d9	 neg	 rcx

; 2382 :     PyLongObject *z;
; 2383 : 
; 2384 :     if (size_b == 0) {

  00032	48 85 c9	 test	 rcx, rcx
$LN38@long_divre:
  00035	75 25		 jne	 SHORT $LN21@long_divre

; 2385 :         PyErr_SetString(PyExc_ZeroDivisionError,
; 2386 :                         "integer division or modulo by zero");

  00037	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ZeroDivisionError
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@OPLMMFNH@integer?5division?5or?5modulo?5by?5ze@
  00045	e8 00 00 00 00	 call	 PyErr_SetString
$LN41@long_divre:

; 2387 :         return -1;

  0004a	83 c8 ff	 or	 eax, -1

; 2426 : }

  0004d	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	41 5d		 pop	 r13
  00058	41 5c		 pop	 r12
  0005a	5e		 pop	 rsi
  0005b	c3		 ret	 0
$LN21@long_divre:

; 2388 :     }
; 2389 :     if (size_a < size_b ||
; 2390 :         (size_a == size_b &&
; 2391 :          a->ob_digit[size_a-1] < b->ob_digit[size_b-1])) {

  0005c	4c 3b d1	 cmp	 r10, rcx
  0005f	0f 8c 40 01 00
	00		 jl	 $LN19@long_divre
  00065	75 0f		 jne	 SHORT $LN20@long_divre
  00067	8b 44 8a 6c	 mov	 eax, DWORD PTR [rdx+rcx*4+108]
  0006b	42 39 44 96 6c	 cmp	 DWORD PTR [rsi+r10*4+108], eax
  00070	0f 82 2f 01 00
	00		 jb	 $LN19@long_divre
$LN20@long_divre:
  00076	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx

; 2397 :         *prem = (PyLongObject *) a;
; 2398 :         return 0;
; 2399 :     }
; 2400 :     if (size_b == 1) {

  0007b	33 db		 xor	 ebx, ebx
  0007d	48 83 f9 01	 cmp	 rcx, 1

; 2401 :         digit rem = 0;
; 2402 :         z = divrem1(a, b->ob_digit[0], &rem);

  00081	48 8b ce	 mov	 rcx, rsi
  00084	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00089	75 4f		 jne	 SHORT $LN17@long_divre
  0008b	8b 52 70	 mov	 edx, DWORD PTR [rdx+112]
  0008e	4c 8d 44 24 40	 lea	 r8, QWORD PTR rem$21990[rsp]
  00093	89 5c 24 40	 mov	 DWORD PTR rem$21990[rsp], ebx
  00097	e8 00 00 00 00	 call	 divrem1
  0009c	48 8b f8	 mov	 rdi, rax

; 2403 :         if (z == NULL)

  0009f	48 85 c0	 test	 rax, rax

; 2404 :             return -1;

  000a2	74 1a		 je	 SHORT $LN40@long_divre

; 2405 :         *prem = (PyLongObject *) PyLong_FromLong((long)rem);

  000a4	8b 4c 24 40	 mov	 ecx, DWORD PTR rem$21990[rsp]
  000a8	e8 00 00 00 00	 call	 PyLong_FromLong
  000ad	49 89 04 24	 mov	 QWORD PTR [r12], rax

; 2406 :         if (*prem == NULL) {

  000b1	48 85 c0	 test	 rax, rax
  000b4	75 34		 jne	 SHORT $LN13@long_divre

; 2407 :             Py_DECREF(z);

  000b6	48 8b cf	 mov	 rcx, rdi
  000b9	e8 00 00 00 00	 call	 _Py_DecRef
$LN40@long_divre:

; 2408 :             return -1;

  000be	83 c8 ff	 or	 eax, -1
$LN37@long_divre:
  000c1	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000c6	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 2426 : }

  000cb	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000d0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d4	41 5d		 pop	 r13
  000d6	41 5c		 pop	 r12
  000d8	5e		 pop	 rsi
  000d9	c3		 ret	 0
$LN17@long_divre:

; 2409 :         }
; 2410 :     }
; 2411 :     else {
; 2412 :         z = x_divrem(a, b, prem);

  000da	4d 8b c1	 mov	 r8, r9
  000dd	e8 00 00 00 00	 call	 x_divrem
  000e2	48 8b f8	 mov	 rdi, rax

; 2413 :         if (z == NULL)

  000e5	48 85 c0	 test	 rax, rax

; 2414 :             return -1;

  000e8	74 d4		 je	 SHORT $LN40@long_divre
$LN13@long_divre:

; 2415 :     }
; 2416 :     /* Set the signs.
; 2417 :        The quotient z has the sign of a*b;
; 2418 :        the remainder r has the sign of a,
; 2419 :        so a = b*z + r. */
; 2420 :     if ((Py_SIZE(a) < 0) != (Py_SIZE(b) < 0))

  000ea	8b cb		 mov	 ecx, ebx
  000ec	8b c3		 mov	 eax, ebx
  000ee	48 39 4d 60	 cmp	 QWORD PTR [rbp+96], rcx
  000f2	0f 9c c1	 setl	 cl
  000f5	48 39 46 60	 cmp	 QWORD PTR [rsi+96], rax
  000f9	0f 9c c0	 setl	 al
  000fc	3b c1		 cmp	 eax, ecx
  000fe	74 3c		 je	 SHORT $LN9@long_divre

; 2421 :         NEGATE(z);

  00100	48 83 7f 50 01	 cmp	 QWORD PTR [rdi+80], 1
  00105	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00109	75 09		 jne	 SHORT $LN8@long_divre
  0010b	48 f7 d8	 neg	 rax
  0010e	48 89 47 60	 mov	 QWORD PTR [rdi+96], rax
  00112	eb 28		 jmp	 SHORT $LN9@long_divre
$LN8@long_divre:
  00114	48 85 c0	 test	 rax, rax
  00117	79 07		 jns	 SHORT $LN39@long_divre
  00119	8b 5f 70	 mov	 ebx, DWORD PTR [rdi+112]
  0011c	f7 db		 neg	 ebx
  0011e	eb 05		 jmp	 SHORT $LN29@long_divre
$LN39@long_divre:
  00120	74 03		 je	 SHORT $LN29@long_divre
  00122	8b 5f 70	 mov	 ebx, DWORD PTR [rdi+112]
$LN29@long_divre:
  00125	f7 db		 neg	 ebx
  00127	8b cb		 mov	 ecx, ebx
  00129	e8 00 00 00 00	 call	 PyLong_FromLong
  0012e	48 8b cf	 mov	 rcx, rdi
  00131	48 8b d8	 mov	 rbx, rax
  00134	e8 00 00 00 00	 call	 _Py_DecRef
  00139	48 8b fb	 mov	 rdi, rbx
$LN9@long_divre:

; 2422 :     if (Py_SIZE(a) < 0 && Py_SIZE(*prem) != 0)

  0013c	48 83 7e 60 00	 cmp	 QWORD PTR [rsi+96], 0
  00141	7d 4f		 jge	 SHORT $LN3@long_divre
  00143	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  00147	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  0014b	48 85 c0	 test	 rax, rax
  0014e	74 42		 je	 SHORT $LN3@long_divre

; 2423 :         NEGATE(*prem);

  00150	48 83 79 50 01	 cmp	 QWORD PTR [rcx+80], 1
  00155	75 1a		 jne	 SHORT $LN2@long_divre
  00157	48 f7 d8	 neg	 rax
  0015a	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 2424 :     *pdiv = maybe_small_long(z);

  0015e	48 8b cf	 mov	 rcx, rdi
  00161	e8 00 00 00 00	 call	 maybe_small_long
  00166	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 2425 :     return 0;

  0016a	33 c0		 xor	 eax, eax
  0016c	e9 50 ff ff ff	 jmp	 $LN37@long_divre
$LN2@long_divre:

; 2423 :         NEGATE(*prem);

  00171	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00174	48 85 c0	 test	 rax, rax
  00177	79 02		 jns	 SHORT $LN33@long_divre
  00179	f7 d9		 neg	 ecx
$LN33@long_divre:
  0017b	f7 d9		 neg	 ecx
  0017d	e8 00 00 00 00	 call	 PyLong_FromLong
  00182	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  00186	48 8b d8	 mov	 rbx, rax
  00189	e8 00 00 00 00	 call	 _Py_DecRef
  0018e	49 89 1c 24	 mov	 QWORD PTR [r12], rbx
$LN3@long_divre:

; 2424 :     *pdiv = maybe_small_long(z);

  00192	48 8b cf	 mov	 rcx, rdi
  00195	e8 00 00 00 00	 call	 maybe_small_long
  0019a	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 2425 :     return 0;

  0019e	33 c0		 xor	 eax, eax
  001a0	e9 1c ff ff ff	 jmp	 $LN37@long_divre
$LN19@long_divre:

; 2392 :         /* |a| < |b|. */
; 2393 :         *pdiv = (PyLongObject*)PyLong_FromLong(0);

  001a5	33 c9		 xor	 ecx, ecx
  001a7	e8 00 00 00 00	 call	 PyLong_FromLong
  001ac	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 2394 :         if (*pdiv == NULL)

  001b0	48 85 c0	 test	 rax, rax

; 2395 :             return -1;

  001b3	0f 84 91 fe ff
	ff		 je	 $LN41@long_divre

; 2396 :         Py_INCREF(a);

  001b9	48 8b ce	 mov	 rcx, rsi
  001bc	e8 00 00 00 00	 call	 _Py_IncRef

; 2426 : }

  001c1	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  001c6	49 89 34 24	 mov	 QWORD PTR [r12], rsi
  001ca	33 c0		 xor	 eax, eax
  001cc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001d0	41 5d		 pop	 r13
  001d2	41 5c		 pop	 r12
  001d4	5e		 pop	 rsi
  001d5	c3		 ret	 0
long_divrem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$k_mul DD	imagerel k_mul
	DD	imagerel k_mul+1048
	DD	imagerel $unwind$k_mul
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$k_mul DD 051201H
	DD	0700e8212H
	DD	0500c600dH
	DD	0300bH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT k_mul
_TEXT	SEGMENT
t1$2$ = 32
ah$ = 32
tv378 = 40
shift$1$ = 40
i$4$ = 48
i$3$ = 48
bl$ = 48
al$1$ = 56
t2$2$ = 112
a$ = 112
t3$1$ = 120
b$ = 120
t2$1$ = 128
t1$3$ = 128
al$ = 128
ret$1$ = 136
bh$ = 136
k_mul	PROC						; COMDAT

; 3113 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3114 :     Py_ssize_t asize = ABS(Py_SIZE(a));

  00012	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  00016	48 85 db	 test	 rbx, rbx
  00019	79 03		 jns	 SHORT $LN42@k_mul
  0001b	48 f7 db	 neg	 rbx
$LN42@k_mul:

; 3115 :     Py_ssize_t bsize = ABS(Py_SIZE(b));

  0001e	48 8b 7a 60	 mov	 rdi, QWORD PTR [rdx+96]
  00022	48 85 ff	 test	 rdi, rdi
  00025	79 03		 jns	 SHORT $LN44@k_mul
  00027	48 f7 df	 neg	 rdi
$LN44@k_mul:

; 3116 :     PyLongObject *ah = NULL;

  0002a	33 c0		 xor	 eax, eax
  0002c	48 89 44 24 20	 mov	 QWORD PTR ah$[rsp], rax

; 3117 :     PyLongObject *al = NULL;

  00031	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR al$[rsp], rax

; 3118 :     PyLongObject *bh = NULL;

  00039	8b f0		 mov	 esi, eax
  0003b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR bh$[rsp], rax

; 3119 :     PyLongObject *bl = NULL;

  00043	8b e8		 mov	 ebp, eax
  00045	48 89 44 24 30	 mov	 QWORD PTR bl$[rsp], rax

; 3120 :     PyLongObject *ret = NULL;
; 3121 :     PyLongObject *t1, *t2, *t3;
; 3122 :     Py_ssize_t shift;           /* the number of digits we split off */
; 3123 :     Py_ssize_t i;
; 3124 : 
; 3125 :     /* (ah*X+al)(bh*X+bl) = ah*bh*X*X + (ah*bl + al*bh)*X + al*bl
; 3126 :      * Let k = (ah+al)*(bh+bl) = ah*bl + al*bh  + ah*bh + al*bl
; 3127 :      * Then the original product is
; 3128 :      *     ah*bh*X*X + (k - ah*bh - al*bl)*X + al*bl
; 3129 :      * By picking X to be a power of 2, "*X" is just shifting, and it's
; 3130 :      * been reduced to 3 multiplies on numbers half the size.
; 3131 :      */
; 3132 : 
; 3133 :     /* We want to split based on the larger number; fiddle so that b
; 3134 :      * is largest.
; 3135 :      */
; 3136 :     if (asize > bsize) {

  0004a	48 3b df	 cmp	 rbx, rdi
  0004d	7e 1c		 jle	 SHORT $LN39@k_mul

; 3137 :         t1 = a;

  0004f	48 8b c1	 mov	 rax, rcx

; 3138 :         a = b;

  00052	48 89 54 24 70	 mov	 QWORD PTR a$[rsp], rdx
  00057	48 8b ca	 mov	 rcx, rdx

; 3139 :         b = t1;

  0005a	48 8b d0	 mov	 rdx, rax
  0005d	48 89 44 24 78	 mov	 QWORD PTR b$[rsp], rax

; 3140 : 
; 3141 :         i = asize;

  00062	48 8b c3	 mov	 rax, rbx

; 3142 :         asize = bsize;

  00065	48 8b df	 mov	 rbx, rdi

; 3143 :         bsize = i;

  00068	48 8b f8	 mov	 rdi, rax
$LN39@k_mul:

; 3144 :     }
; 3145 : 
; 3146 :     /* Use gradeschool math when either number is too small. */
; 3147 :     i = a == b ? KARATSUBA_SQUARE_CUTOFF : KARATSUBA_CUTOFF;

  0006b	48 3b ca	 cmp	 rcx, rdx
  0006e	b8 46 00 00 00	 mov	 eax, 70			; 00000046H
  00073	41 b8 8c 00 00
	00		 mov	 r8d, 140		; 0000008cH
  00079	41 0f 44 c0	 cmove	 eax, r8d

; 3148 :     if (asize <= i) {

  0007d	48 3b d8	 cmp	 rbx, rax
  00080	7f 21		 jg	 SHORT $LN36@k_mul

; 3149 :         if (asize == 0)

  00082	48 85 db	 test	 rbx, rbx
  00085	75 0f		 jne	 SHORT $LN37@k_mul

; 3150 :             return (PyLongObject *)PyLong_FromLong(0);

  00087	33 c9		 xor	 ecx, ecx

; 3277 : }

  00089	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008d	5f		 pop	 rdi
  0008e	5e		 pop	 rsi
  0008f	5d		 pop	 rbp
  00090	5b		 pop	 rbx
  00091	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN37@k_mul:
  00096	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009a	5f		 pop	 rdi
  0009b	5e		 pop	 rsi
  0009c	5d		 pop	 rbp
  0009d	5b		 pop	 rbx
  0009e	e9 00 00 00 00	 jmp	 x_mul
$LN36@k_mul:

; 3151 :         else
; 3152 :             return x_mul(a, b);
; 3153 :     }
; 3154 : 
; 3155 :     /* If a is small compared to b, splitting on b gives a degenerate
; 3156 :      * case with ah==0, and Karatsuba may be (even much) less efficient
; 3157 :      * than "grade school" then.  However, we can still win, by viewing
; 3158 :      * b as a string of "big digits", each of width a->ob_size.  That
; 3159 :      * leads to a sequence of balanced calls to k_mul.
; 3160 :      */
; 3161 :     if (2 * asize <= bsize)

  000a3	48 8d 04 1b	 lea	 rax, QWORD PTR [rbx+rbx]
  000a7	48 3b c7	 cmp	 rax, rdi
  000aa	7f 0d		 jg	 SHORT $LN35@k_mul

; 3277 : }

  000ac	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b0	5f		 pop	 rdi
  000b1	5e		 pop	 rsi
  000b2	5d		 pop	 rbp
  000b3	5b		 pop	 rbx
  000b4	e9 00 00 00 00	 jmp	 k_lopsided_mul
$LN35@k_mul:

; 3162 :         return k_lopsided_mul(a, b);
; 3163 : 
; 3164 :     /* Split a & b into hi & lo pieces. */
; 3165 :     shift = bsize >> 1;

  000b9	48 8b c7	 mov	 rax, rdi

; 3166 :     if (kmul_split(a, shift, &ah, &al) < 0) goto fail;

  000bc	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR al$[rsp]
  000c4	4c 8d 44 24 20	 lea	 r8, QWORD PTR ah$[rsp]
  000c9	48 d1 f8	 sar	 rax, 1
  000cc	48 8b d0	 mov	 rdx, rax
  000cf	48 89 44 24 28	 mov	 QWORD PTR shift$1$[rsp], rax
  000d4	e8 00 00 00 00	 call	 kmul_split
  000d9	85 c0		 test	 eax, eax
  000db	0f 88 eb 02 00
	00		 js	 $LN46@k_mul

; 3167 :     assert(Py_SIZE(ah) > 0);            /* the split isn't degenerate */
; 3168 : 
; 3169 :     if (a == b) {

  000e1	48 8b 44 24 78	 mov	 rax, QWORD PTR b$[rsp]
  000e6	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR al$[rsp]
  000ee	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ah$[rsp]
  000f3	48 89 54 24 38	 mov	 QWORD PTR al$1$[rsp], rdx
  000f8	48 39 44 24 70	 cmp	 QWORD PTR a$[rsp], rax
  000fd	75 15		 jne	 SHORT $LN33@k_mul

; 3170 :         bh = ah;

  000ff	48 8b f1	 mov	 rsi, rcx

; 3171 :         bl = al;

  00102	48 8b ea	 mov	 rbp, rdx

; 3172 :         Py_INCREF(bh);

  00105	e8 00 00 00 00	 call	 _Py_IncRef

; 3173 :         Py_INCREF(bl);

  0010a	48 8b cd	 mov	 rcx, rbp
  0010d	e8 00 00 00 00	 call	 _Py_IncRef
  00112	eb 2f		 jmp	 SHORT $LN31@k_mul
$LN33@k_mul:

; 3174 :     }
; 3175 :     else if (kmul_split(b, shift, &bh, &bl) < 0) goto fail;

  00114	48 8b 54 24 28	 mov	 rdx, QWORD PTR shift$1$[rsp]
  00119	4c 8d 4c 24 30	 lea	 r9, QWORD PTR bl$[rsp]
  0011e	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR bh$[rsp]
  00126	48 8b c8	 mov	 rcx, rax
  00129	e8 00 00 00 00	 call	 kmul_split
  0012e	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR bh$[rsp]
  00136	48 8b 6c 24 30	 mov	 rbp, QWORD PTR bl$[rsp]
  0013b	85 c0		 test	 eax, eax
  0013d	0f 88 89 02 00
	00		 js	 $LN46@k_mul
$LN31@k_mul:

; 3176 : 
; 3177 :     /* The plan:
; 3178 :      * 1. Allocate result space (asize + bsize digits:  that's always
; 3179 :      *    enough).
; 3180 :      * 2. Compute ah*bh, and copy into result at 2*shift.
; 3181 :      * 3. Compute al*bl, and copy into result at 0.  Note that this
; 3182 :      *    can't overlap with #2.
; 3183 :      * 4. Subtract al*bl from the result, starting at shift.  This may
; 3184 :      *    underflow (borrow out of the high digit), but we don't care:
; 3185 :      *    we're effectively doing unsigned arithmetic mod
; 3186 :      *    BASE**(sizea + sizeb), and so long as the *final* result fits,
; 3187 :      *    borrows and carries out of the high digit can be ignored.
; 3188 :      * 5. Subtract ah*bh from the result, starting at shift.
; 3189 :      * 6. Compute (ah+al)*(bh+bl), and add it into the result starting
; 3190 :      *    at shift.
; 3191 :      */
; 3192 : 
; 3193 :     /* 1. Allocate result space. */
; 3194 :     ret = _PyLong_New(asize + bsize);

  00143	48 8d 0c 1f	 lea	 rcx, QWORD PTR [rdi+rbx]
  00147	e8 00 00 00 00	 call	 _PyLong_New

; 3195 :     if (ret == NULL) goto fail;
; 3196 : #ifdef Py_DEBUG
; 3197 :     /* Fill with trash, to catch reference to uninitialized digits. */
; 3198 :     memset(ret->ob_digit, 0xDF, Py_SIZE(ret) * sizeof(digit));
; 3199 : #endif
; 3200 : 
; 3201 :     /* 2. t1 <- ah*bh, and copy into high digits of result. */
; 3202 :     if ((t1 = k_mul(ah, bh)) == NULL) goto fail;

  0014c	48 8b 5c 24 20	 mov	 rbx, QWORD PTR ah$[rsp]
  00151	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ret$1$[rsp], rax
  00159	48 85 c0	 test	 rax, rax
  0015c	0f 84 6f 02 00
	00		 je	 $LN48@k_mul
  00162	48 8b d6	 mov	 rdx, rsi
  00165	48 8b cb	 mov	 rcx, rbx
  00168	e8 00 00 00 00	 call	 k_mul
  0016d	48 89 44 24 20	 mov	 QWORD PTR t1$2$[rsp], rax
  00172	48 85 c0	 test	 rax, rax
  00175	0f 84 84 00 00
	00		 je	 $fail$22653

; 3203 :     assert(Py_SIZE(t1) >= 0);
; 3204 :     assert(2*shift + Py_SIZE(t1) <= Py_SIZE(ret));
; 3205 :     memcpy(ret->ob_digit + 2*shift, t1->ob_digit,
; 3206 :            Py_SIZE(t1) * sizeof(digit));

  0017b	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0017f	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR ret$1$[rsp]
  00187	48 8d 50 70	 lea	 rdx, QWORD PTR [rax+112]
  0018b	48 8b 44 24 28	 mov	 rax, QWORD PTR shift$1$[rsp]
  00190	49 c1 e0 02	 shl	 r8, 2
  00194	48 8d 4c c7 70	 lea	 rcx, QWORD PTR [rdi+rax*8+112]
  00199	e8 00 00 00 00	 call	 memcpy

; 3207 : 
; 3208 :     /* Zero-out the digits higher than the ah*bh copy. */
; 3209 :     i = Py_SIZE(ret) - 2*shift - Py_SIZE(t1);

  0019e	48 8b 44 24 20	 mov	 rax, QWORD PTR t1$2$[rsp]
  001a3	4c 8b 47 60	 mov	 r8, QWORD PTR [rdi+96]
  001a7	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  001ab	48 8b 44 24 28	 mov	 rax, QWORD PTR shift$1$[rsp]
  001b0	48 8d 0c 00	 lea	 rcx, QWORD PTR [rax+rax]
  001b4	4c 2b c1	 sub	 r8, rcx
  001b7	48 89 4c 24 30	 mov	 QWORD PTR i$3$[rsp], rcx
  001bc	4c 2b c2	 sub	 r8, rdx

; 3210 :     if (i)

  001bf	74 14		 je	 SHORT $LN28@k_mul

; 3211 :         memset(ret->ob_digit + 2*shift + Py_SIZE(t1), 0,
; 3212 :                i * sizeof(digit));

  001c1	48 8d 44 42 1c	 lea	 rax, QWORD PTR [rdx+rax*2+28]
  001c6	49 c1 e0 02	 shl	 r8, 2
  001ca	33 d2		 xor	 edx, edx
  001cc	48 8d 0c 87	 lea	 rcx, QWORD PTR [rdi+rax*4]
  001d0	e8 00 00 00 00	 call	 memset
$LN28@k_mul:

; 3213 : 
; 3214 :     /* 3. t2 <- al*bl, and copy into the low digits. */
; 3215 :     if ((t2 = k_mul(al, bl)) == NULL) {

  001d5	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR al$[rsp]
  001dd	48 8b d5	 mov	 rdx, rbp
  001e0	48 8b cf	 mov	 rcx, rdi
  001e3	e8 00 00 00 00	 call	 k_mul
  001e8	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR t2$1$[rsp], rax
  001f0	48 85 c0	 test	 rax, rax
  001f3	75 21		 jne	 SHORT $LN27@k_mul

; 3216 :         Py_DECREF(t1);

  001f5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR t1$2$[rsp]
$LN50@k_mul:

; 3249 :         Py_DECREF(t1);

  001fa	e8 00 00 00 00	 call	 _Py_DecRef
$fail$22653:

; 3269 : 
; 3270 :   fail:
; 3271 :     Py_XDECREF(ret);

  001ff	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ret$1$[rsp]
  00207	e8 00 00 00 00	 call	 _Py_DecRef
  0020c	48 8b 7c 24 38	 mov	 rdi, QWORD PTR al$1$[rsp]
  00211	e9 c3 01 00 00	 jmp	 $LN19@k_mul
$LN27@k_mul:

; 3217 :         goto fail;
; 3218 :     }
; 3219 :     assert(Py_SIZE(t2) >= 0);
; 3220 :     assert(Py_SIZE(t2) <= 2*shift); /* no overlap with high digits */
; 3221 :     memcpy(ret->ob_digit, t2->ob_digit, Py_SIZE(t2) * sizeof(digit));

  00216	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0021a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ret$1$[rsp]
  00222	48 8d 50 70	 lea	 rdx, QWORD PTR [rax+112]
  00226	49 c1 e0 02	 shl	 r8, 2
  0022a	48 83 c1 70	 add	 rcx, 112		; 00000070H
  0022e	e8 00 00 00 00	 call	 memcpy

; 3222 : 
; 3223 :     /* Zero out remaining digits. */
; 3224 :     i = 2*shift - Py_SIZE(t2);          /* number of uninitialized digits */

  00233	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR t2$1$[rsp]
  0023b	48 8b 44 24 30	 mov	 rax, QWORD PTR i$3$[rsp]
  00240	4d 8b 5b 60	 mov	 r11, QWORD PTR [r11+96]
  00244	49 2b c3	 sub	 rax, r11

; 3225 :     if (i)

  00247	74 1c		 je	 SHORT $LN26@k_mul

; 3226 :         memset(ret->ob_digit + Py_SIZE(t2), 0, i * sizeof(digit));

  00249	4c 8d 04 85 00
	00 00 00	 lea	 r8, QWORD PTR [rax*4]
  00251	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ret$1$[rsp]
  00259	33 d2		 xor	 edx, edx
  0025b	4a 8d 4c 98 70	 lea	 rcx, QWORD PTR [rax+r11*4+112]
  00260	e8 00 00 00 00	 call	 memset
$LN26@k_mul:

; 3227 : 
; 3228 :     /* 4 & 5. Subtract ah*bh (t1) and al*bl (t2).  We do al*bl first
; 3229 :      * because it's fresher in cache.
; 3230 :      */
; 3231 :     i = Py_SIZE(ret) - shift;  /* # digits after shift */

  00265	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ret$1$[rsp]
  0026d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR shift$1$[rsp]
  00272	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00276	48 2b d1	 sub	 rdx, rcx

; 3232 :     (void)v_isub(ret->ob_digit + shift, i, t2->ob_digit, Py_SIZE(t2));

  00279	48 8d 4c 88 70	 lea	 rcx, QWORD PTR [rax+rcx*4+112]
  0027e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR t2$1$[rsp]
  00286	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  0028a	4c 8d 40 70	 lea	 r8, QWORD PTR [rax+112]
  0028e	48 89 54 24 30	 mov	 QWORD PTR i$4$[rsp], rdx
  00293	48 89 4c 24 28	 mov	 QWORD PTR tv378[rsp], rcx
  00298	e8 00 00 00 00	 call	 v_isub

; 3233 :     Py_DECREF(t2);

  0029d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR t2$1$[rsp]
  002a5	e8 00 00 00 00	 call	 _Py_DecRef

; 3234 : 
; 3235 :     (void)v_isub(ret->ob_digit + shift, i, t1->ob_digit, Py_SIZE(t1));

  002aa	48 8b 44 24 20	 mov	 rax, QWORD PTR t1$2$[rsp]
  002af	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$4$[rsp]
  002b4	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  002b8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv378[rsp]
  002bd	4c 8d 40 70	 lea	 r8, QWORD PTR [rax+112]
  002c1	e8 00 00 00 00	 call	 v_isub

; 3236 :     Py_DECREF(t1);

  002c6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR t1$2$[rsp]
  002cb	e8 00 00 00 00	 call	 _Py_DecRef

; 3237 : 
; 3238 :     /* 6. t3 <- (ah+al)(bh+bl), and add into result. */
; 3239 :     if ((t1 = x_add(ah, al)) == NULL) goto fail;

  002d0	48 8b d7	 mov	 rdx, rdi
  002d3	48 8b cb	 mov	 rcx, rbx
  002d6	e8 00 00 00 00	 call	 x_add
  002db	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR t1$3$[rsp], rax
  002e3	48 85 c0	 test	 rax, rax
  002e6	0f 84 13 ff ff
	ff		 je	 $fail$22653

; 3240 :     Py_DECREF(ah);

  002ec	48 8b cb	 mov	 rcx, rbx
  002ef	e8 00 00 00 00	 call	 _Py_DecRef

; 3241 :     Py_DECREF(al);

  002f4	48 8b cf	 mov	 rcx, rdi
  002f7	e8 00 00 00 00	 call	 _Py_DecRef

; 3242 :     ah = al = NULL;
; 3243 : 
; 3244 :     if (a == b) {

  002fc	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  00301	33 c9		 xor	 ecx, ecx
  00303	33 db		 xor	 ebx, ebx
  00305	48 89 4c 24 38	 mov	 QWORD PTR al$1$[rsp], rcx
  0030a	48 3b 44 24 78	 cmp	 rax, QWORD PTR b$[rsp]
  0030f	75 17		 jne	 SHORT $LN24@k_mul

; 3245 :         t2 = t1;

  00311	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR t1$3$[rsp]

; 3246 :         Py_INCREF(t2);

  00319	48 8b cf	 mov	 rcx, rdi
  0031c	48 89 7c 24 70	 mov	 QWORD PTR t2$2$[rsp], rdi
  00321	e8 00 00 00 00	 call	 _Py_IncRef
  00326	eb 2a		 jmp	 SHORT $LN22@k_mul
$LN24@k_mul:

; 3247 :     }
; 3248 :     else if ((t2 = x_add(bh, bl)) == NULL) {

  00328	48 8b d5	 mov	 rdx, rbp
  0032b	48 8b ce	 mov	 rcx, rsi
  0032e	e8 00 00 00 00	 call	 x_add
  00333	48 89 44 24 70	 mov	 QWORD PTR t2$2$[rsp], rax
  00338	48 85 c0	 test	 rax, rax
  0033b	75 0d		 jne	 SHORT $LN49@k_mul

; 3249 :         Py_DECREF(t1);

  0033d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR t1$3$[rsp]

; 3250 :         goto fail;

  00345	e9 b0 fe ff ff	 jmp	 $LN50@k_mul
$LN49@k_mul:

; 3162 :         return k_lopsided_mul(a, b);
; 3163 : 
; 3164 :     /* Split a & b into hi & lo pieces. */
; 3165 :     shift = bsize >> 1;

  0034a	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR t1$3$[rsp]
$LN22@k_mul:

; 3251 :     }
; 3252 :     Py_DECREF(bh);

  00352	48 8b ce	 mov	 rcx, rsi
  00355	e8 00 00 00 00	 call	 _Py_DecRef

; 3253 :     Py_DECREF(bl);

  0035a	48 8b cd	 mov	 rcx, rbp
  0035d	e8 00 00 00 00	 call	 _Py_DecRef

; 3254 :     bh = bl = NULL;
; 3255 : 
; 3256 :     t3 = k_mul(t1, t2);

  00362	48 8b 54 24 70	 mov	 rdx, QWORD PTR t2$2$[rsp]
  00367	48 8b cf	 mov	 rcx, rdi
  0036a	33 ed		 xor	 ebp, ebp
  0036c	33 f6		 xor	 esi, esi
  0036e	e8 00 00 00 00	 call	 k_mul

; 3257 :     Py_DECREF(t1);

  00373	48 8b cf	 mov	 rcx, rdi
  00376	48 89 44 24 78	 mov	 QWORD PTR t3$1$[rsp], rax
  0037b	e8 00 00 00 00	 call	 _Py_DecRef

; 3258 :     Py_DECREF(t2);

  00380	48 8b 4c 24 70	 mov	 rcx, QWORD PTR t2$2$[rsp]
  00385	e8 00 00 00 00	 call	 _Py_DecRef

; 3259 :     if (t3 == NULL) goto fail;

  0038a	48 8b 7c 24 78	 mov	 rdi, QWORD PTR t3$1$[rsp]
  0038f	48 85 ff	 test	 rdi, rdi
  00392	0f 84 67 fe ff
	ff		 je	 $fail$22653

; 3260 :     assert(Py_SIZE(t3) >= 0);
; 3261 : 
; 3262 :     /* Add t3.  It's not obvious why we can't run out of room here.
; 3263 :      * See the (*) comment after this function.
; 3264 :      */
; 3265 :     (void)v_iadd(ret->ob_digit + shift, i, t3->ob_digit, Py_SIZE(t3));

  00398	4c 8b 4f 60	 mov	 r9, QWORD PTR [rdi+96]
  0039c	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$4$[rsp]
  003a1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv378[rsp]
  003a6	4c 8d 47 70	 lea	 r8, QWORD PTR [rdi+112]
  003aa	e8 00 00 00 00	 call	 v_iadd

; 3266 :     Py_DECREF(t3);

  003af	48 8b cf	 mov	 rcx, rdi
  003b2	e8 00 00 00 00	 call	 _Py_DecRef

; 3267 : 
; 3268 :     return long_normalize(ret);

  003b7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ret$1$[rsp]

; 3277 : }

  003bf	48 83 c4 48	 add	 rsp, 72			; 00000048H
  003c3	5f		 pop	 rdi
  003c4	5e		 pop	 rsi
  003c5	5d		 pop	 rbp
  003c6	5b		 pop	 rbx
  003c7	e9 00 00 00 00	 jmp	 long_normalize
$LN46@k_mul:

; 3269 : 
; 3270 :   fail:
; 3271 :     Py_XDECREF(ret);

  003cc	48 8b 5c 24 20	 mov	 rbx, QWORD PTR ah$[rsp]
$LN48@k_mul:

; 3138 :         a = b;

  003d1	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR al$[rsp]
$LN19@k_mul:

; 3272 :     Py_XDECREF(ah);

  003d9	48 85 db	 test	 rbx, rbx
  003dc	74 08		 je	 SHORT $LN15@k_mul
  003de	48 8b cb	 mov	 rcx, rbx
  003e1	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@k_mul:

; 3273 :     Py_XDECREF(al);

  003e6	48 85 ff	 test	 rdi, rdi
  003e9	74 08		 je	 SHORT $LN11@k_mul
  003eb	48 8b cf	 mov	 rcx, rdi
  003ee	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@k_mul:

; 3274 :     Py_XDECREF(bh);

  003f3	48 85 f6	 test	 rsi, rsi
  003f6	74 08		 je	 SHORT $LN7@k_mul
  003f8	48 8b ce	 mov	 rcx, rsi
  003fb	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@k_mul:

; 3275 :     Py_XDECREF(bl);

  00400	48 85 ed	 test	 rbp, rbp
  00403	74 08		 je	 SHORT $LN3@k_mul
  00405	48 8b cd	 mov	 rcx, rbp
  00408	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@k_mul:

; 3276 :     return NULL;

  0040d	33 c0		 xor	 eax, eax

; 3277 : }

  0040f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00413	5f		 pop	 rdi
  00414	5e		 pop	 rsi
  00415	5d		 pop	 rbp
  00416	5b		 pop	 rbx
  00417	c3		 ret	 0
k_mul	ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_mul DD imagerel long_mul
	DD	imagerel long_mul+188
	DD	imagerel $unwind$long_mul
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$long_mul DD imagerel long_mul+188
	DD	imagerel long_mul+250
	DD	imagerel $chain$0$long_mul
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$long_mul DD imagerel long_mul+250
	DD	imagerel long_mul+315
	DD	imagerel $chain$2$long_mul
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$long_mul DD imagerel long_mul+315
	DD	imagerel long_mul+402
	DD	imagerel $chain$3$long_mul
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$long_mul DD 021H
	DD	imagerel long_mul
	DD	imagerel long_mul+188
	DD	imagerel $unwind$long_mul
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$long_mul DD 020021H
	DD	087400H
	DD	imagerel long_mul
	DD	imagerel long_mul+188
	DD	imagerel $unwind$long_mul
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$long_mul DD 020521H
	DD	087405H
	DD	imagerel long_mul
	DD	imagerel long_mul+188
	DD	imagerel $unwind$long_mul
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_mul DD 040a01H
	DD	09340aH
	DD	06006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT long_mul
_TEXT	SEGMENT
a$ = 64
b$ = 72
long_mul PROC						; COMDAT

; 3388 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3389 :     PyLongObject *z;
; 3390 : 
; 3391 :     CHECK_BINOP(a, b);

  0000a	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000e	48 8b da	 mov	 rbx, rdx
  00011	48 8b f1	 mov	 rsi, rcx
  00014	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0001e	0f 84 17 01 00
	00		 je	 $LN8@long_mul
  00024	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00028	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00032	0f 84 03 01 00
	00		 je	 $LN8@long_mul

; 3392 : 
; 3393 :     /* fast path for single-digit multiplication */
; 3394 :     if (ABS(Py_SIZE(a)) <= 1 && ABS(Py_SIZE(b)) <= 1) {

  00038	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	48 85 c0	 test	 rax, rax
  00042	79 03		 jns	 SHORT $LN16@long_mul
  00044	48 f7 d9	 neg	 rcx
$LN16@long_mul:
  00047	48 83 f9 01	 cmp	 rcx, 1
  0004b	7f 69		 jg	 SHORT $LN7@long_mul
  0004d	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  00051	48 8b ca	 mov	 rcx, rdx
  00054	48 85 d2	 test	 rdx, rdx
  00057	79 03		 jns	 SHORT $LN18@long_mul
  00059	48 f7 d9	 neg	 rcx
$LN18@long_mul:
  0005c	48 83 f9 01	 cmp	 rcx, 1
  00060	7f 54		 jg	 SHORT $LN7@long_mul

; 3395 :         stwodigits v = (stwodigits)(MEDIUM_VALUE(a)) * MEDIUM_VALUE(b);

  00062	33 c9		 xor	 ecx, ecx
  00064	48 85 c0	 test	 rax, rax
  00067	79 07		 jns	 SHORT $LN35@long_mul
  00069	8b 46 70	 mov	 eax, DWORD PTR [rsi+112]
  0006c	f7 d8		 neg	 eax
  0006e	eb 07		 jmp	 SHORT $LN20@long_mul
$LN35@long_mul:
  00070	8b c1		 mov	 eax, ecx
  00072	74 03		 je	 SHORT $LN20@long_mul
  00074	8b 46 70	 mov	 eax, DWORD PTR [rsi+112]
$LN20@long_mul:
  00077	48 85 d2	 test	 rdx, rdx
  0007a	79 1d		 jns	 SHORT $LN36@long_mul
  0007c	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]

; 3396 : #ifdef HAVE_LONG_LONG
; 3397 :         return PyLong_FromLongLong((PY_LONG_LONG)v);

  0007f	48 98		 cdqe
  00081	f7 d9		 neg	 ecx
  00083	48 63 c9	 movsxd	 rcx, ecx
  00086	48 0f af c8	 imul	 rcx, rax

; 3414 : }

  0008a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0008f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00093	5e		 pop	 rsi
  00094	e9 00 00 00 00	 jmp	 PyLong_FromLongLong
$LN36@long_mul:

; 3395 :         stwodigits v = (stwodigits)(MEDIUM_VALUE(a)) * MEDIUM_VALUE(b);

  00099	74 03		 je	 SHORT $LN24@long_mul
  0009b	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
$LN24@long_mul:

; 3396 : #ifdef HAVE_LONG_LONG
; 3397 :         return PyLong_FromLongLong((PY_LONG_LONG)v);

  0009e	48 63 c9	 movsxd	 rcx, ecx
  000a1	48 98		 cdqe
  000a3	48 0f af c8	 imul	 rcx, rax

; 3414 : }

  000a7	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b0	5e		 pop	 rsi
  000b1	e9 00 00 00 00	 jmp	 PyLong_FromLongLong
$LN7@long_mul:

; 3398 : #else
; 3399 :         /* if we don't have long long then we're almost certainly
; 3400 :            using 15-bit digits, so v will fit in a long.  In the
; 3401 :            unlikely event that we're using 30-bit digits on a platform
; 3402 :            without long long, a large v will just cause us to fall
; 3403 :            through to the general multiplication code below. */
; 3404 :         if (v >= LONG_MIN && v <= LONG_MAX)
; 3405 :             return PyLong_FromLong((long)v);
; 3406 : #endif
; 3407 :     }
; 3408 : 
; 3409 :     z = k_mul(a, b);

  000b6	48 8b d3	 mov	 rdx, rbx
  000b9	48 8b ce	 mov	 rcx, rsi
  000bc	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  000c1	e8 00 00 00 00	 call	 k_mul

; 3410 :     /* Negate if exactly one of the inputs is negative. */
; 3411 :     if (((Py_SIZE(a) ^ Py_SIZE(b)) < 0) && z)

  000c6	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  000ca	48 33 4e 60	 xor	 rcx, QWORD PTR [rsi+96]
  000ce	48 8b f8	 mov	 rdi, rax
  000d1	7d 55		 jge	 SHORT $LN3@long_mul
  000d3	48 85 c0	 test	 rax, rax
  000d6	74 50		 je	 SHORT $LN3@long_mul

; 3412 :         NEGATE(z);

  000d8	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  000dd	75 1b		 jne	 SHORT $LN2@long_mul
  000df	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000e3	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000e8	48 f7 d9	 neg	 rcx
  000eb	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 3414 : }

  000ef	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000f4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f8	5e		 pop	 rsi
  000f9	c3		 ret	 0
$LN2@long_mul:

; 3412 :         NEGATE(z);

  000fa	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000fe	48 85 c0	 test	 rax, rax
  00101	79 07		 jns	 SHORT $LN37@long_mul
  00103	8b 4f 70	 mov	 ecx, DWORD PTR [rdi+112]
  00106	f7 d9		 neg	 ecx
  00108	eb 09		 jmp	 SHORT $LN28@long_mul
$LN37@long_mul:
  0010a	75 04		 jne	 SHORT $LN27@long_mul
  0010c	33 c9		 xor	 ecx, ecx
  0010e	eb 03		 jmp	 SHORT $LN28@long_mul
$LN27@long_mul:
  00110	8b 4f 70	 mov	 ecx, DWORD PTR [rdi+112]
$LN28@long_mul:
  00113	f7 d9		 neg	 ecx
  00115	e8 00 00 00 00	 call	 PyLong_FromLong
  0011a	48 8b cf	 mov	 rcx, rdi
  0011d	48 8b d8	 mov	 rbx, rax
  00120	e8 00 00 00 00	 call	 _Py_DecRef
  00125	48 8b fb	 mov	 rdi, rbx
$LN3@long_mul:

; 3413 :     return (PyObject *)z;

  00128	48 8b c7	 mov	 rax, rdi
  0012b	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 3414 : }

  00130	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00135	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00139	5e		 pop	 rsi
  0013a	c3		 ret	 0
$LN8@long_mul:

; 3389 :     PyLongObject *z;
; 3390 : 
; 3391 :     CHECK_BINOP(a, b);

  0013b	e8 00 00 00 00	 call	 _Py_PXCTX
  00140	85 c0		 test	 eax, eax
  00142	75 3c		 jne	 SHORT $LN32@long_mul
  00144	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  0014b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00152	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00159	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0015f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00167	e8 00 00 00 00	 call	 _PyParallel_Guard
  0016c	85 c0		 test	 eax, eax
  0016e	75 09		 jne	 SHORT $LN31@long_mul
  00170	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00177	74 07		 je	 SHORT $LN32@long_mul
$LN31@long_mul:
  00179	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN32@long_mul:
  00180	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 3414 : }

  00187	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0018c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00190	5e		 pop	 rsi
  00191	c3		 ret	 0
long_mul ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$l_divmod DD imagerel l_divmod
	DD	imagerel l_divmod+330
	DD	imagerel $unwind$l_divmod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$l_divmod DD 0a4a01H
	DD	09744aH
	DD	086445H
	DD	0bc410H
	DD	0a3410H
	DD	0d00c5210H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT l_divmod
_TEXT	SEGMENT
div$ = 32
mod$ = 40
v$ = 64
w$ = 72
pdiv$ = 80
pmod$ = 88
l_divmod PROC						; COMDAT

; 3440 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  0000a	41 55		 push	 r13
  0000c	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00010	4d 8b e1	 mov	 r12, r9
  00013	4d 8b e8	 mov	 r13, r8

; 3441 :     PyLongObject *div, *mod;
; 3442 : 
; 3443 :     if (long_divrem(v, w, &div, &mod) < 0)

  00016	4c 8d 4c 24 28	 lea	 r9, QWORD PTR mod$[rsp]
  0001b	4c 8d 44 24 20	 lea	 r8, QWORD PTR div$[rsp]
  00020	48 8b da	 mov	 rbx, rdx
  00023	e8 00 00 00 00	 call	 long_divrem
  00028	85 c0		 test	 eax, eax
  0002a	79 14		 jns	 SHORT $LN15@l_divmod

; 3444 :         return -1;

  0002c	83 c8 ff	 or	 eax, -1

; 3479 : }

  0002f	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00034	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]
  00039	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003d	41 5d		 pop	 r13
  0003f	c3		 ret	 0
$LN15@l_divmod:
  00040	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00045	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 3445 :     if ((Py_SIZE(mod) < 0 && Py_SIZE(w) > 0) ||
; 3446 :         (Py_SIZE(mod) > 0 && Py_SIZE(w) < 0)) {

  0004a	48 8b 7c 24 28	 mov	 rdi, QWORD PTR mod$[rsp]
  0004f	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00053	48 85 c0	 test	 rax, rax
  00056	79 0a		 jns	 SHORT $LN21@l_divmod
  00058	48 83 7b 60 00	 cmp	 QWORD PTR [rbx+96], 0
  0005d	7f 14		 jg	 SHORT $LN13@l_divmod
  0005f	48 85 c0	 test	 rax, rax
$LN21@l_divmod:
  00062	0f 8e 9a 00 00
	00		 jle	 $LN18@l_divmod
  00068	48 83 7b 60 00	 cmp	 QWORD PTR [rbx+96], 0
  0006d	0f 8d 8f 00 00
	00		 jge	 $LN18@l_divmod
$LN13@l_divmod:

; 3447 :         PyLongObject *temp;
; 3448 :         PyLongObject *one;
; 3449 :         temp = (PyLongObject *) long_add(mod, w);

  00073	48 8b d3	 mov	 rdx, rbx
  00076	48 8b cf	 mov	 rcx, rdi
  00079	e8 00 00 00 00	 call	 long_add

; 3450 :         Py_DECREF(mod);

  0007e	48 8b cf	 mov	 rcx, rdi
  00081	48 8b d8	 mov	 rbx, rax
  00084	e8 00 00 00 00	 call	 _Py_DecRef

; 3451 :         mod = temp;

  00089	48 8b fb	 mov	 rdi, rbx

; 3452 :         if (mod == NULL) {

  0008c	48 85 db	 test	 rbx, rbx
  0008f	75 12		 jne	 SHORT $LN11@l_divmod

; 3453 :             Py_DECREF(div);

  00091	48 8b 4c 24 20	 mov	 rcx, QWORD PTR div$[rsp]
  00096	e8 00 00 00 00	 call	 _Py_DecRef

; 3454 :             return -1;

  0009b	83 c8 ff	 or	 eax, -1
  0009e	e9 8c 00 00 00	 jmp	 $LN20@l_divmod
$LN11@l_divmod:

; 3455 :         }
; 3456 :         one = (PyLongObject *) PyLong_FromLong(1L);

  000a3	b9 01 00 00 00	 mov	 ecx, 1
  000a8	e8 00 00 00 00	 call	 PyLong_FromLong
  000ad	48 8b d8	 mov	 rbx, rax

; 3457 :         if (one == NULL ||
; 3458 :             (temp = (PyLongObject *) long_sub(div, one)) == NULL) {

  000b0	48 85 c0	 test	 rax, rax
  000b3	74 29		 je	 SHORT $LN9@l_divmod
  000b5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR div$[rsp]
  000ba	48 8b d0	 mov	 rdx, rax
  000bd	e8 00 00 00 00	 call	 long_sub
  000c2	48 8b f0	 mov	 rsi, rax
  000c5	48 85 c0	 test	 rax, rax
  000c8	74 14		 je	 SHORT $LN9@l_divmod

; 3463 :         }
; 3464 :         Py_DECREF(one);

  000ca	48 8b cb	 mov	 rcx, rbx
  000cd	e8 00 00 00 00	 call	 _Py_DecRef

; 3465 :         Py_DECREF(div);

  000d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR div$[rsp]
  000d7	e8 00 00 00 00	 call	 _Py_DecRef

; 3466 :         div = temp;

  000dc	eb 29		 jmp	 SHORT $LN14@l_divmod
$LN9@l_divmod:

; 3459 :             Py_DECREF(mod);

  000de	48 8b cf	 mov	 rcx, rdi
  000e1	e8 00 00 00 00	 call	 _Py_DecRef

; 3460 :             Py_DECREF(div);

  000e6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR div$[rsp]
  000eb	e8 00 00 00 00	 call	 _Py_DecRef

; 3461 :             Py_XDECREF(one);

  000f0	48 85 db	 test	 rbx, rbx
  000f3	74 08		 je	 SHORT $LN7@l_divmod
  000f5	48 8b cb	 mov	 rcx, rbx
  000f8	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@l_divmod:

; 3462 :             return -1;

  000fd	83 c8 ff	 or	 eax, -1
  00100	eb 2d		 jmp	 SHORT $LN20@l_divmod
$LN18@l_divmod:
  00102	48 8b 74 24 20	 mov	 rsi, QWORD PTR div$[rsp]
$LN14@l_divmod:

; 3467 :     }
; 3468 :     if (pdiv != NULL)

  00107	4d 85 ed	 test	 r13, r13
  0010a	74 06		 je	 SHORT $LN4@l_divmod

; 3469 :         *pdiv = div;

  0010c	49 89 75 00	 mov	 QWORD PTR [r13], rsi

; 3470 :     else

  00110	eb 08		 jmp	 SHORT $LN3@l_divmod
$LN4@l_divmod:

; 3471 :         Py_DECREF(div);

  00112	48 8b ce	 mov	 rcx, rsi
  00115	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@l_divmod:

; 3472 : 
; 3473 :     if (pmod != NULL)

  0011a	4d 85 e4	 test	 r12, r12
  0011d	74 06		 je	 SHORT $LN2@l_divmod

; 3474 :         *pmod = mod;

  0011f	49 89 3c 24	 mov	 QWORD PTR [r12], rdi

; 3475 :     else

  00123	eb 08		 jmp	 SHORT $LN1@l_divmod
$LN2@l_divmod:

; 3476 :         Py_DECREF(mod);

  00125	48 8b cf	 mov	 rcx, rdi
  00128	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@l_divmod:

; 3477 : 
; 3478 :     return 0;

  0012d	33 c0		 xor	 eax, eax
$LN20@l_divmod:
  0012f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00134	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 3479 : }

  00139	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0013e	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]
  00143	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00147	41 5d		 pop	 r13
  00149	c3		 ret	 0
l_divmod ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_div DD imagerel long_div
	DD	imagerel long_div+151
	DD	imagerel $unwind$long_div
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_div DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT long_div
_TEXT	SEGMENT
div$ = 64
a$ = 64
b$ = 72
long_div PROC						; COMDAT

; 3483 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3484 :     PyLongObject *div;
; 3485 : 
; 3486 :     CHECK_BINOP(a, b);

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00012	74 32		 je	 SHORT $LN2@long_div
  00014	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00018	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00022	74 22		 je	 SHORT $LN2@long_div

; 3487 :     if (l_divmod((PyLongObject*)a, (PyLongObject*)b, &div, NULL) < 0)

  00024	4c 8d 44 24 40	 lea	 r8, QWORD PTR div$[rsp]
  00029	45 33 c9	 xor	 r9d, r9d
  0002c	e8 00 00 00 00	 call	 l_divmod
  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR div$[rsp]
  00036	33 d2		 xor	 edx, edx
  00038	85 c0		 test	 eax, eax
  0003a	48 0f 48 ca	 cmovs	 rcx, rdx

; 3488 :         div = NULL;
; 3489 :     return (PyObject *)div;

  0003e	48 8b c1	 mov	 rax, rcx

; 3490 : }

  00041	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00045	c3		 ret	 0
$LN2@long_div:

; 3484 :     PyLongObject *div;
; 3485 : 
; 3486 :     CHECK_BINOP(a, b);

  00046	e8 00 00 00 00	 call	 _Py_PXCTX
  0004b	85 c0		 test	 eax, eax
  0004d	75 3c		 jne	 SHORT $LN10@long_div
  0004f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00064	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0006a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00072	e8 00 00 00 00	 call	 _PyParallel_Guard
  00077	85 c0		 test	 eax, eax
  00079	75 09		 jne	 SHORT $LN9@long_div
  0007b	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00082	74 07		 je	 SHORT $LN10@long_div
$LN9@long_div:
  00084	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN10@long_div:
  0008b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 3490 : }

  00092	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00096	c3		 ret	 0
long_div ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_mod DD imagerel long_mod
	DD	imagerel long_mod+151
	DD	imagerel $unwind$long_mod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_mod DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT long_mod
_TEXT	SEGMENT
mod$ = 64
a$ = 64
b$ = 72
long_mod PROC						; COMDAT

; 3757 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3758 :     PyLongObject *mod;
; 3759 : 
; 3760 :     CHECK_BINOP(a, b);

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00012	74 32		 je	 SHORT $LN2@long_mod
  00014	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00018	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00022	74 22		 je	 SHORT $LN2@long_mod

; 3761 : 
; 3762 :     if (l_divmod((PyLongObject*)a, (PyLongObject*)b, NULL, &mod) < 0)

  00024	4c 8d 4c 24 40	 lea	 r9, QWORD PTR mod$[rsp]
  00029	45 33 c0	 xor	 r8d, r8d
  0002c	e8 00 00 00 00	 call	 l_divmod
  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mod$[rsp]
  00036	33 d2		 xor	 edx, edx
  00038	85 c0		 test	 eax, eax
  0003a	48 0f 48 ca	 cmovs	 rcx, rdx

; 3763 :         mod = NULL;
; 3764 :     return (PyObject *)mod;

  0003e	48 8b c1	 mov	 rax, rcx

; 3765 : }

  00041	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00045	c3		 ret	 0
$LN2@long_mod:

; 3758 :     PyLongObject *mod;
; 3759 : 
; 3760 :     CHECK_BINOP(a, b);

  00046	e8 00 00 00 00	 call	 _Py_PXCTX
  0004b	85 c0		 test	 eax, eax
  0004d	75 3c		 jne	 SHORT $LN10@long_mod
  0004f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00064	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0006a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00072	e8 00 00 00 00	 call	 _PyParallel_Guard
  00077	85 c0		 test	 eax, eax
  00079	75 09		 jne	 SHORT $LN9@long_mod
  0007b	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00082	74 07		 je	 SHORT $LN10@long_mod
$LN9@long_mod:
  00084	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN10@long_mod:
  0008b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 3765 : }

  00092	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00096	c3		 ret	 0
long_mod ENDP
_TEXT	ENDS
EXTRN	PyTuple_SetItem:PROC
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_divmod DD imagerel long_divmod
	DD	imagerel long_divmod+75
	DD	imagerel $unwind$long_divmod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$long_divmod DD imagerel long_divmod+75
	DD	imagerel long_divmod+139
	DD	imagerel $chain$0$long_divmod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$long_divmod DD imagerel long_divmod+139
	DD	imagerel long_divmod+172
	DD	imagerel $chain$2$long_divmod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$long_divmod DD imagerel long_divmod+172
	DD	imagerel long_divmod+253
	DD	imagerel $chain$3$long_divmod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$long_divmod DD 021H
	DD	imagerel long_divmod
	DD	imagerel long_divmod+75
	DD	imagerel $unwind$long_divmod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$long_divmod DD 020021H
	DD	063400H
	DD	imagerel long_divmod
	DD	imagerel long_divmod+75
	DD	imagerel $unwind$long_divmod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$long_divmod DD 020521H
	DD	063405H
	DD	imagerel long_divmod
	DD	imagerel long_divmod+75
	DD	imagerel $unwind$long_divmod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_divmod DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
xdata	ENDS
;	COMDAT long_divmod
_TEXT	SEGMENT
div$ = 64
a$ = 64
b$ = 72
mod$ = 80
long_divmod PROC					; COMDAT

; 3769 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3770 :     PyLongObject *div, *mod;
; 3771 :     PyObject *z;
; 3772 : 
; 3773 :     CHECK_BINOP(a, b);

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00012	0f 84 94 00 00
	00		 je	 $LN4@long_divmo
  00018	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0001c	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00026	0f 84 80 00 00
	00		 je	 $LN4@long_divmo

; 3774 : 
; 3775 :     if (l_divmod((PyLongObject*)a, (PyLongObject*)b, &div, &mod) < 0) {

  0002c	4c 8d 4c 24 50	 lea	 r9, QWORD PTR mod$[rsp]
  00031	4c 8d 44 24 40	 lea	 r8, QWORD PTR div$[rsp]
  00036	e8 00 00 00 00	 call	 l_divmod
  0003b	85 c0		 test	 eax, eax
  0003d	79 07		 jns	 SHORT $LN3@long_divmo

; 3776 :         return NULL;

  0003f	33 c0		 xor	 eax, eax

; 3788 : }

  00041	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00045	c3		 ret	 0
$LN3@long_divmo:

; 3777 :     }
; 3778 :     z = PyTuple_New(2);

  00046	b9 02 00 00 00	 mov	 ecx, 2
  0004b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00050	e8 00 00 00 00	 call	 PyTuple_New
  00055	48 8b d8	 mov	 rbx, rax

; 3779 :     if (z != NULL) {

  00058	48 85 c0	 test	 rax, rax
  0005b	74 2e		 je	 SHORT $LN2@long_divmo

; 3780 :         PyTuple_SetItem(z, 0, (PyObject *) div);

  0005d	4c 8b 44 24 40	 mov	 r8, QWORD PTR div$[rsp]
  00062	33 d2		 xor	 edx, edx
  00064	48 8b c8	 mov	 rcx, rax
  00067	e8 00 00 00 00	 call	 PyTuple_SetItem

; 3781 :         PyTuple_SetItem(z, 1, (PyObject *) mod);

  0006c	4c 8b 44 24 50	 mov	 r8, QWORD PTR mod$[rsp]
  00071	ba 01 00 00 00	 mov	 edx, 1
  00076	48 8b cb	 mov	 rcx, rbx
  00079	e8 00 00 00 00	 call	 PyTuple_SetItem

; 3786 :     }
; 3787 :     return z;

  0007e	48 8b c3	 mov	 rax, rbx
  00081	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 3788 : }

  00086	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008a	c3		 ret	 0
$LN2@long_divmo:

; 3782 :     }
; 3783 :     else {
; 3784 :         Py_DECREF(div);

  0008b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR div$[rsp]
  00090	e8 00 00 00 00	 call	 _Py_DecRef

; 3785 :         Py_DECREF(mod);

  00095	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mod$[rsp]
  0009a	e8 00 00 00 00	 call	 _Py_DecRef

; 3786 :     }
; 3787 :     return z;

  0009f	48 8b c3	 mov	 rax, rbx
  000a2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 3788 : }

  000a7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ab	c3		 ret	 0
$LN4@long_divmo:

; 3770 :     PyLongObject *div, *mod;
; 3771 :     PyObject *z;
; 3772 : 
; 3773 :     CHECK_BINOP(a, b);

  000ac	e8 00 00 00 00	 call	 _Py_PXCTX
  000b1	85 c0		 test	 eax, eax
  000b3	75 3c		 jne	 SHORT $LN12@long_divmo
  000b5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000ca	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000d0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000d8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000dd	85 c0		 test	 eax, eax
  000df	75 09		 jne	 SHORT $LN11@long_divmo
  000e1	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  000e8	74 07		 je	 SHORT $LN12@long_divmo
$LN11@long_divmo:
  000ea	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN12@long_divmo:
  000f1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 3788 : }

  000f8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fc	c3		 ret	 0
long_divmod ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@OLNKGOFI@pow?$CI?$CJ?53rd?5argument?5cannot?5be?50?$AA@ ; `string'
PUBLIC	??_C@_0EC@HKEPHICC@pow?$CI?$CJ?52nd?5argument?5cannot?5be?5neg@ ; `string'
EXTRN	PyFloat_Type:BYTE
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$long_pow DD imagerel long_pow
	DD	imagerel long_pow+362
	DD	imagerel $unwind$long_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$long_pow DD imagerel long_pow+362
	DD	imagerel long_pow+506
	DD	imagerel $chain$0$long_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$long_pow DD imagerel long_pow+506
	DD	imagerel long_pow+524
	DD	imagerel $chain$1$long_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$long_pow DD imagerel long_pow+524
	DD	imagerel long_pow+3470
	DD	imagerel $chain$2$long_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$long_pow DD imagerel long_pow+3470
	DD	imagerel long_pow+3551
	DD	imagerel $chain$3$long_pow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$long_pow DD 021H
	DD	imagerel long_pow
	DD	imagerel long_pow+362
	DD	imagerel $unwind$long_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$long_pow DD 020021H
	DD	034d400H
	DD	imagerel long_pow
	DD	imagerel long_pow+362
	DD	imagerel $unwind$long_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$long_pow DD 021H
	DD	imagerel long_pow
	DD	imagerel long_pow+362
	DD	imagerel $unwind$long_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$long_pow DD 020821H
	DD	034d408H
	DD	imagerel long_pow
	DD	imagerel long_pow+362
	DD	imagerel $unwind$long_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_pow DD 091b01H
	DD	02a011bH
	DD	0e00df00fH
	DD	07009c00bH
	DD	030076008H
	DD	05006H
xdata	ENDS
;	COMDAT ??_C@_0BP@OLNKGOFI@pow?$CI?$CJ?53rd?5argument?5cannot?5be?50?$AA@
CONST	SEGMENT
??_C@_0BP@OLNKGOFI@pow?$CI?$CJ?53rd?5argument?5cannot?5be?50?$AA@ DB 'pow'
	DB	'() 3rd argument cannot be 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@HKEPHICC@pow?$CI?$CJ?52nd?5argument?5cannot?5be?5neg@
CONST	SEGMENT
??_C@_0EC@HKEPHICC@pow?$CI?$CJ?52nd?5argument?5cannot?5be?5neg@ DB 'pow()'
	DB	' 2nd argument cannot be negative when 3rd argument specified', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\longobject.c
CONST	ENDS
;	COMDAT long_pow
_TEXT	SEGMENT
temp$ = 48
a$1$ = 56
i$3$ = 64
tv1909 = 72
table$ = 80
negativeOutput$1$ = 400
v$ = 400
w$ = 408
x$ = 416
c$1$ = 424
long_pow PROC						; COMDAT

; 3793 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	53		 push	 rbx
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 56		 push	 r14
  0000d	41 57		 push	 r15
  0000f	48 8d 6c 24 b0	 lea	 rbp, QWORD PTR [rsp-80]
  00014	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H

; 3794 :     PyLongObject *a, *b, *c; /* a,b,c = v,w,x */
; 3795 :     int negativeOutput = 0;  /* if x<0 return negative output */

  0001b	45 33 ff	 xor	 r15d, r15d

; 3796 : 
; 3797 :     PyLongObject *z = NULL;  /* accumulated result */
; 3798 :     Py_ssize_t i, j, k;             /* counters */
; 3799 :     PyLongObject *temp = NULL;
; 3800 : 
; 3801 :     /* 5-ary values.  If the exponent is large enough, table is
; 3802 :      * precomputed so that table[i] == a**i % c for i in range(32).
; 3803 :      */
; 3804 :     PyLongObject *table[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
; 3805 :                                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
; 3806 : 
; 3807 :     /* a, b, c = v, w, x */
; 3808 :     CHECK_BINOP(v, w);

  0001e	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00022	49 8b d8	 mov	 rbx, r8
  00025	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0002f	4c 8b f2	 mov	 r14, rdx
  00032	4c 8b e1	 mov	 r12, rcx
  00035	48 89 4c 24 38	 mov	 QWORD PTR a$1$[rsp], rcx
  0003a	44 89 bd 90 00
	00 00		 mov	 DWORD PTR negativeOutput$1$[rbp-256], r15d
  00041	41 8b ff	 mov	 edi, r15d
  00044	41 8b f7	 mov	 esi, r15d
  00047	4c 89 7c 24 30	 mov	 QWORD PTR temp$[rsp], r15
  0004c	4c 89 7c 24 50	 mov	 QWORD PTR table$[rsp], r15
  00051	4c 89 7c 24 58	 mov	 QWORD PTR table$[rsp+8], r15
  00056	4c 89 7c 24 60	 mov	 QWORD PTR table$[rsp+16], r15
  0005b	4c 89 7c 24 68	 mov	 QWORD PTR table$[rsp+24], r15
  00060	4c 89 7c 24 70	 mov	 QWORD PTR table$[rsp+32], r15
  00065	4c 89 7c 24 78	 mov	 QWORD PTR table$[rsp+40], r15
  0006a	4c 89 7d 80	 mov	 QWORD PTR table$[rbp-208], r15
  0006e	4c 89 7d 88	 mov	 QWORD PTR table$[rbp-200], r15
  00072	4c 89 7d 90	 mov	 QWORD PTR table$[rbp-192], r15
  00076	4c 89 7d 98	 mov	 QWORD PTR table$[rbp-184], r15
  0007a	4c 89 7d a0	 mov	 QWORD PTR table$[rbp-176], r15
  0007e	4c 89 7d a8	 mov	 QWORD PTR table$[rbp-168], r15
  00082	4c 89 7d b0	 mov	 QWORD PTR table$[rbp-160], r15
  00086	4c 89 7d b8	 mov	 QWORD PTR table$[rbp-152], r15
  0008a	4c 89 7d c0	 mov	 QWORD PTR table$[rbp-144], r15
  0008e	4c 89 7d c8	 mov	 QWORD PTR table$[rbp-136], r15
  00092	4c 89 7d d0	 mov	 QWORD PTR table$[rbp-128], r15
  00096	4c 89 7d d8	 mov	 QWORD PTR table$[rbp-120], r15
  0009a	4c 89 7d e0	 mov	 QWORD PTR table$[rbp-112], r15
  0009e	4c 89 7d e8	 mov	 QWORD PTR table$[rbp-104], r15
  000a2	4c 89 7d f0	 mov	 QWORD PTR table$[rbp-96], r15
  000a6	4c 89 7d f8	 mov	 QWORD PTR table$[rbp-88], r15
  000aa	4c 89 7d 00	 mov	 QWORD PTR table$[rbp-80], r15
  000ae	4c 89 7d 08	 mov	 QWORD PTR table$[rbp-72], r15
  000b2	4c 89 7d 10	 mov	 QWORD PTR table$[rbp-64], r15
  000b6	4c 89 7d 18	 mov	 QWORD PTR table$[rbp-56], r15
  000ba	4c 89 7d 20	 mov	 QWORD PTR table$[rbp-48], r15
  000be	4c 89 7d 28	 mov	 QWORD PTR table$[rbp-40], r15
  000c2	4c 89 7d 30	 mov	 QWORD PTR table$[rbp-32], r15
  000c6	4c 89 7d 38	 mov	 QWORD PTR table$[rbp-24], r15
  000ca	4c 89 7d 40	 mov	 QWORD PTR table$[rbp-16], r15
  000ce	4c 89 7d 48	 mov	 QWORD PTR table$[rbp-8], r15
  000d2	0f 84 b6 0c 00
	00		 je	 $LN148@long_pow
  000d8	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  000dc	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  000e6	0f 84 a2 0c 00
	00		 je	 $LN148@long_pow

; 3809 :     a = (PyLongObject*)v; Py_INCREF(a);

  000ec	e8 00 00 00 00	 call	 _Py_PXCTX
  000f1	85 c0		 test	 eax, eax
  000f3	75 35		 jne	 SHORT $LN164@long_pow
  000f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00103	4d 8b cc	 mov	 r9, r12
  00106	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0010c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00114	e8 00 00 00 00	 call	 _PyParallel_Guard
  00119	85 c0		 test	 eax, eax
  0011b	75 08		 jne	 SHORT $LN163@long_pow
  0011d	41 f6 44 24 20
	20		 test	 BYTE PTR [r12+32], 32	; 00000020H
  00123	74 05		 je	 SHORT $LN164@long_pow
$LN163@long_pow:
  00125	49 ff 44 24 50	 inc	 QWORD PTR [r12+80]
$LN164@long_pow:

; 3810 :     b = (PyLongObject*)w; Py_INCREF(b);

  0012a	e8 00 00 00 00	 call	 _Py_PXCTX
  0012f	85 c0		 test	 eax, eax
  00131	75 33		 jne	 SHORT $LN168@long_pow
  00133	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0013a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00141	4d 8b ce	 mov	 r9, r14
  00144	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0014a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00152	e8 00 00 00 00	 call	 _PyParallel_Guard
  00157	85 c0		 test	 eax, eax
  00159	75 07		 jne	 SHORT $LN167@long_pow
  0015b	41 f6 46 20 20	 test	 BYTE PTR [r14+32], 32	; 00000020H
  00160	74 04		 je	 SHORT $LN168@long_pow
$LN167@long_pow:
  00162	49 ff 46 50	 inc	 QWORD PTR [r14+80]
$LN168@long_pow:

; 3811 :     if (PyLong_Check(x)) {

  00166	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0016a	4c 89 ac 24 a0
	01 00 00	 mov	 QWORD PTR [rsp+416], r13
  00172	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0017c	74 14		 je	 SHORT $LN147@long_pow

; 3812 :         c = (PyLongObject *)x;
; 3813 :         Py_INCREF(x);

  0017e	48 8b cb	 mov	 rcx, rbx
  00181	4c 8b eb	 mov	 r13, rbx
  00184	48 89 9d a8 00
	00 00		 mov	 QWORD PTR c$1$[rbp-256], rbx
  0018b	e8 00 00 00 00	 call	 _Py_IncRef
  00190	eb 1a		 jmp	 SHORT $LN144@long_pow
$LN147@long_pow:

; 3814 :     }
; 3815 :     else if (x == Py_None)

  00192	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00199	48 3b d8	 cmp	 rbx, rax
  0019c	0f 85 8b 0b 00
	00		 jne	 $LN145@long_pow

; 3816 :         c = NULL;

  001a2	4d 8b ef	 mov	 r13, r15
  001a5	4c 89 bd a8 00
	00 00		 mov	 QWORD PTR c$1$[rbp-256], r15
$LN144@long_pow:

; 3821 :     }
; 3822 : 
; 3823 :     if (Py_SIZE(b) < 0) {  /* if exponent is negative */

  001ac	49 39 76 60	 cmp	 QWORD PTR [r14+96], rsi
  001b0	7d 5a		 jge	 SHORT $LN141@long_pow

; 3824 :         if (c) {

  001b2	4d 85 ed	 test	 r13, r13
  001b5	74 18		 je	 SHORT $LN142@long_pow

; 3825 :             PyErr_SetString(PyExc_TypeError, "pow() 2nd argument "
; 3826 :                             "cannot be negative when 3rd argument specified");

  001b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@HKEPHICC@pow?$CI?$CJ?52nd?5argument?5cannot?5be?5neg@
  001c5	e8 00 00 00 00	 call	 PyErr_SetString

; 3827 :             goto Error;

  001ca	e9 1c 09 00 00	 jmp	 $Done$23170
$LN142@long_pow:

; 3828 :         }
; 3829 :         else {
; 3830 :             /* else return a float.  This works because we know
; 3831 :                that this calls float_pow() which converts its
; 3832 :                arguments to double. */
; 3833 :             Py_DECREF(a);

  001cf	49 8b cc	 mov	 rcx, r12
  001d2	e8 00 00 00 00	 call	 _Py_DecRef

; 3834 :             Py_DECREF(b);

  001d7	49 8b ce	 mov	 rcx, r14
  001da	e8 00 00 00 00	 call	 _Py_DecRef

; 3835 :             return PyFloat_Type.tp_as_number->nb_power(v, w, x);

  001df	48 8b 05 b8 00
	00 00		 mov	 rax, QWORD PTR PyFloat_Type+184
  001e6	4c 8b c3	 mov	 r8, rbx
  001e9	49 8b d6	 mov	 rdx, r14
  001ec	49 8b cc	 mov	 rcx, r12
  001ef	ff 50 28	 call	 QWORD PTR [rax+40]
$LN385@long_pow:
  001f2	4c 8b ac 24 a0
	01 00 00	 mov	 r13, QWORD PTR [rsp+416]
$LN153@long_pow:

; 3980 : }

  001fa	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  00201	41 5f		 pop	 r15
  00203	41 5e		 pop	 r14
  00205	41 5c		 pop	 r12
  00207	5f		 pop	 rdi
  00208	5e		 pop	 rsi
  00209	5b		 pop	 rbx
  0020a	5d		 pop	 rbp
  0020b	c3		 ret	 0
$LN141@long_pow:

; 3836 :         }
; 3837 :     }
; 3838 : 
; 3839 :     if (c) {

  0020c	48 8b 9d a8 00
	00 00		 mov	 rbx, QWORD PTR c$1$[rbp-256]
  00213	41 bc 01 00 00
	00		 mov	 r12d, 1
  00219	48 85 db	 test	 rbx, rbx
  0021c	0f 84 04 01 00
	00		 je	 $LN384@long_pow

; 3840 :         /* if modulus == 0:
; 3841 :                raise ValueError() */
; 3842 :         if (Py_SIZE(c) == 0) {

  00222	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  00226	48 85 c0	 test	 rax, rax
  00229	75 1b		 jne	 SHORT $LN386@long_pow

; 3843 :             PyErr_SetString(PyExc_ValueError,
; 3844 :                             "pow() 3rd argument cannot be 0");

  0022b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00232	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@OLNKGOFI@pow?$CI?$CJ?53rd?5argument?5cannot?5be?50?$AA@
  00239	e8 00 00 00 00	 call	 PyErr_SetString
$LN378@long_pow:

; 3845 :             goto Error;

  0023e	4c 8b eb	 mov	 r13, rbx
  00241	e9 a0 08 00 00	 jmp	 $LN387@long_pow
$LN386@long_pow:

; 3846 :         }
; 3847 : 
; 3848 :         /* if modulus < 0:
; 3849 :                negativeOutput = True
; 3850 :                modulus = -modulus */
; 3851 :         if (Py_SIZE(c) < 0) {

  00246	79 75		 jns	 SHORT $LN134@long_pow

; 3852 :             negativeOutput = 1;
; 3853 :             temp = (PyLongObject *)_PyLong_Copy(c);

  00248	48 8b cb	 mov	 rcx, rbx
  0024b	44 89 a5 90 00
	00 00		 mov	 DWORD PTR negativeOutput$1$[rbp-256], r12d
  00252	e8 00 00 00 00	 call	 _PyLong_Copy
  00257	48 8b f0	 mov	 rsi, rax

; 3854 :             if (temp == NULL)

  0025a	48 85 c0	 test	 rax, rax
  0025d	74 df		 je	 SHORT $LN378@long_pow

; 3855 :                 goto Error;
; 3856 :             Py_DECREF(c);

  0025f	48 8b cb	 mov	 rcx, rbx
  00262	e8 00 00 00 00	 call	 _Py_DecRef

; 3857 :             c = temp;

  00267	48 8b de	 mov	 rbx, rsi

; 3858 :             temp = NULL;

  0026a	49 8b f7	 mov	 rsi, r15

; 3859 :             NEGATE(c);

  0026d	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  00271	48 89 9d a8 00
	00 00		 mov	 QWORD PTR c$1$[rbp-256], rbx
  00278	4c 89 7c 24 30	 mov	 QWORD PTR temp$[rsp], r15
  0027d	4c 39 63 50	 cmp	 QWORD PTR [rbx+80], r12
  00281	75 09		 jne	 SHORT $LN133@long_pow
  00283	48 f7 d8	 neg	 rax
  00286	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax
  0028a	eb 31		 jmp	 SHORT $LN134@long_pow
$LN133@long_pow:
  0028c	48 85 c0	 test	 rax, rax
  0028f	79 07		 jns	 SHORT $LN388@long_pow
  00291	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00294	f7 d9		 neg	 ecx
  00296	eb 08		 jmp	 SHORT $LN156@long_pow
$LN388@long_pow:
  00298	41 8b cf	 mov	 ecx, r15d
  0029b	74 03		 je	 SHORT $LN156@long_pow
  0029d	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
$LN156@long_pow:
  002a0	f7 d9		 neg	 ecx
  002a2	e8 00 00 00 00	 call	 PyLong_FromLong
  002a7	48 8b 8d a8 00
	00 00		 mov	 rcx, QWORD PTR c$1$[rbp-256]
  002ae	48 8b d8	 mov	 rbx, rax
  002b1	e8 00 00 00 00	 call	 _Py_DecRef
  002b6	48 89 9d a8 00
	00 00		 mov	 QWORD PTR c$1$[rbp-256], rbx
$LN134@long_pow:

; 3860 :         }
; 3861 : 
; 3862 :         /* if modulus == 1:
; 3863 :                return 0 */
; 3864 :         if ((Py_SIZE(c) == 1) && (c->ob_digit[0] == 1)) {

  002bd	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  002c1	49 3b cc	 cmp	 rcx, r12
  002c4	75 15		 jne	 SHORT $LN131@long_pow
  002c6	44 39 63 70	 cmp	 DWORD PTR [rbx+112], r12d
  002ca	75 0f		 jne	 SHORT $LN131@long_pow

; 3865 :             z = (PyLongObject *)PyLong_FromLong(0L);

  002cc	33 c9		 xor	 ecx, ecx
  002ce	e8 00 00 00 00	 call	 PyLong_FromLong
  002d3	48 8b f8	 mov	 rdi, rax

; 3866 :             goto Done;

  002d6	e9 04 08 00 00	 jmp	 $LN382@long_pow
$LN131@long_pow:

; 3867 :         }
; 3868 : 
; 3869 :         /* Reduce base by modulus in some cases:
; 3870 :            1. If base < 0.  Forcing the base non-negative makes things easier.
; 3871 :            2. If base is obviously larger than the modulus.  The "small
; 3872 :               exponent" case later can multiply directly by base repeatedly,
; 3873 :               while the "large exponent" case multiplies directly by base 31
; 3874 :               times.  It can be unboundedly faster to multiply by
; 3875 :               base % modulus instead.
; 3876 :            We could _always_ do this reduction, but l_divmod() isn't cheap,
; 3877 :            so we only do it when it buys something. */
; 3878 :         if (Py_SIZE(a) < 0 || Py_SIZE(a) > Py_SIZE(c)) {

  002db	4c 8b 6c 24 38	 mov	 r13, QWORD PTR a$1$[rsp]
  002e0	49 8b 45 60	 mov	 rax, QWORD PTR [r13+96]
  002e4	48 85 c0	 test	 rax, rax
  002e7	78 05		 js	 SHORT $LN129@long_pow
  002e9	48 3b c1	 cmp	 rax, rcx
  002ec	7e 3d		 jle	 SHORT $LN130@long_pow
$LN129@long_pow:

; 3879 :             if (l_divmod(a, c, NULL, &temp) < 0)

  002ee	4c 8d 4c 24 30	 lea	 r9, QWORD PTR temp$[rsp]
  002f3	45 33 c0	 xor	 r8d, r8d
  002f6	48 8b d3	 mov	 rdx, rbx
  002f9	49 8b cd	 mov	 rcx, r13
  002fc	e8 00 00 00 00	 call	 l_divmod
  00301	85 c0		 test	 eax, eax
  00303	78 17		 js	 SHORT $LN376@long_pow

; 3880 :                 goto Error;
; 3881 :             Py_DECREF(a);

  00305	49 8b cd	 mov	 rcx, r13
  00308	e8 00 00 00 00	 call	 _Py_DecRef

; 3882 :             a = temp;

  0030d	4c 8b 6c 24 30	 mov	 r13, QWORD PTR temp$[rsp]

; 3883 :             temp = NULL;

  00312	49 8b f7	 mov	 rsi, r15
  00315	4c 89 6c 24 38	 mov	 QWORD PTR a$1$[rsp], r13
  0031a	eb 0f		 jmp	 SHORT $LN130@long_pow
$LN376@long_pow:

; 3960 :         temp = NULL;

  0031c	48 8b 74 24 30	 mov	 rsi, QWORD PTR temp$[rsp]
  00321	e9 b9 07 00 00	 jmp	 $LN382@long_pow
$LN384@long_pow:

; 3882 :             a = temp;

  00326	4c 8b 6c 24 38	 mov	 r13, QWORD PTR a$1$[rsp]
$LN130@long_pow:

; 3884 :         }
; 3885 :     }
; 3886 : 
; 3887 :     /* At this point a, b, and c are guaranteed non-negative UNLESS
; 3888 :        c is NULL, in which case a may be negative. */
; 3889 : 
; 3890 :     z = (PyLongObject *)PyLong_FromLong(1L);

  0032b	41 8b cc	 mov	 ecx, r12d
  0032e	e8 00 00 00 00	 call	 PyLong_FromLong
  00333	48 8b f8	 mov	 rdi, rax

; 3891 :     if (z == NULL)

  00336	48 85 c0	 test	 rax, rax
  00339	0f 84 a0 07 00
	00		 je	 $LN382@long_pow

; 3892 :         goto Error;
; 3893 : 
; 3894 :     /* Perform a modular reduction, X = X % c, but leave X alone if c
; 3895 :      * is NULL.
; 3896 :      */
; 3897 : #define REDUCE(X)                                       \
; 3898 :     do {                                                \
; 3899 :         if (c != NULL) {                                \
; 3900 :             if (l_divmod(X, c, NULL, &temp) < 0)        \
; 3901 :                 goto Error;                             \
; 3902 :             Py_XDECREF(X);                              \
; 3903 :             X = temp;                                   \
; 3904 :             temp = NULL;                                \
; 3905 :         }                                               \
; 3906 :     } while(0)
; 3907 : 
; 3908 :     /* Multiply two values, then reduce the result:
; 3909 :        result = X*Y % c.  If c is NULL, skip the mod. */
; 3910 : #define MULT(X, Y, result)                      \
; 3911 :     do {                                        \
; 3912 :         temp = (PyLongObject *)long_mul(X, Y);  \
; 3913 :         if (temp == NULL)                       \
; 3914 :             goto Error;                         \
; 3915 :         Py_XDECREF(result);                     \
; 3916 :         result = temp;                          \
; 3917 :         temp = NULL;                            \
; 3918 :         REDUCE(result);                         \
; 3919 :     } while(0)
; 3920 : 
; 3921 :     if (Py_SIZE(b) <= FIVEARY_CUTOFF) {

  0033f	49 8b 46 60	 mov	 rax, QWORD PTR [r14+96]
  00343	48 83 f8 08	 cmp	 rax, 8
  00347	0f 8f d8 02 00
	00		 jg	 $LN126@long_pow

; 3922 :         /* Left-to-right binary exponentiation (HAC Algorithm 14.79) */
; 3923 :         /* http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf    */
; 3924 :         for (i = Py_SIZE(b) - 1; i >= 0; --i) {

  0034d	4c 8d 68 ff	 lea	 r13, QWORD PTR [rax-1]
  00351	4d 85 ed	 test	 r13, r13
  00354	0f 88 8a 02 00
	00		 js	 $LN61@long_pow
  0035a	4f 8d 74 ae 70	 lea	 r14, QWORD PTR [r14+r13*4+112]
  0035f	90		 npad	 1
$LL125@long_pow:

; 3925 :             digit bi = b->ob_digit[i];

  00360	45 8b 26	 mov	 r12d, DWORD PTR [r14]

; 3926 : 
; 3927 :             for (j = (digit)1 << (PyLong_SHIFT-1); j != 0; j >>= 1) {

  00363	bb 00 00 00 20	 mov	 ebx, 536870912		; 20000000H
  00368	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL122@long_pow:

; 3928 :                 MULT(z, z, z);

  00370	48 8b d7	 mov	 rdx, rdi
  00373	48 8b cf	 mov	 rcx, rdi
  00376	e8 00 00 00 00	 call	 long_mul
  0037b	48 8b f0	 mov	 rsi, rax
  0037e	48 85 c0	 test	 rax, rax
  00381	0f 84 eb 06 00
	00		 je	 $Error$23136
  00387	48 85 ff	 test	 rdi, rdi
  0038a	74 65		 je	 SHORT $LN114@long_pow
  0038c	e8 00 00 00 00	 call	 _Py_PXCTX
  00391	85 c0		 test	 eax, eax
  00393	75 5c		 jne	 SHORT $LN114@long_pow
  00395	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00399	a8 20		 test	 al, 32			; 00000020H
  0039b	75 4c		 jne	 SHORT $LN179@long_pow
  0039d	84 c0		 test	 al, al
  0039f	78 48		 js	 SHORT $LN179@long_pow
  003a1	a8 02		 test	 al, 2
  003a3	75 4c		 jne	 SHORT $LN114@long_pow
  003a5	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  003a9	75 46		 jne	 SHORT $LN114@long_pow
  003ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  003b9	4c 8b cf	 mov	 r9, rdi
  003bc	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  003c2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003ca	e8 00 00 00 00	 call	 _PyParallel_Guard
  003cf	48 8b cf	 mov	 rcx, rdi
  003d2	85 c0		 test	 eax, eax
  003d4	74 07		 je	 SHORT $LN184@long_pow
  003d6	e8 00 00 00 00	 call	 _Px_Dealloc
  003db	eb 14		 jmp	 SHORT $LN114@long_pow
$LN184@long_pow:
  003dd	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  003e1	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  003e7	eb 08		 jmp	 SHORT $LN114@long_pow
$LN179@long_pow:
  003e9	48 8b cf	 mov	 rcx, rdi
  003ec	e8 00 00 00 00	 call	 Px_DecRef
$LN114@long_pow:
  003f1	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR c$1$[rbp-256]
  003f8	48 8b fe	 mov	 rdi, rsi
  003fb	4c 89 7c 24 30	 mov	 QWORD PTR temp$[rsp], r15
  00400	49 8b f7	 mov	 rsi, r15
  00403	48 85 c0	 test	 rax, rax
  00406	0f 84 8a 00 00
	00		 je	 $LN110@long_pow
  0040c	4c 8d 4c 24 30	 lea	 r9, QWORD PTR temp$[rsp]
  00411	45 33 c0	 xor	 r8d, r8d
  00414	48 8b d0	 mov	 rdx, rax
  00417	48 8b cf	 mov	 rcx, rdi
  0041a	e8 00 00 00 00	 call	 l_divmod
  0041f	85 c0		 test	 eax, eax
  00421	0f 88 46 06 00
	00		 js	 $LN375@long_pow
  00427	48 85 ff	 test	 rdi, rdi
  0042a	74 65		 je	 SHORT $LN105@long_pow
  0042c	e8 00 00 00 00	 call	 _Py_PXCTX
  00431	85 c0		 test	 eax, eax
  00433	75 5c		 jne	 SHORT $LN105@long_pow
  00435	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00439	a8 20		 test	 al, 32			; 00000020H
  0043b	75 4c		 jne	 SHORT $LN190@long_pow
  0043d	84 c0		 test	 al, al
  0043f	78 48		 js	 SHORT $LN190@long_pow
  00441	a8 02		 test	 al, 2
  00443	75 4c		 jne	 SHORT $LN105@long_pow
  00445	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00449	75 46		 jne	 SHORT $LN105@long_pow
  0044b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00452	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00459	4c 8b cf	 mov	 r9, rdi
  0045c	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00462	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0046a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0046f	48 8b cf	 mov	 rcx, rdi
  00472	85 c0		 test	 eax, eax
  00474	74 07		 je	 SHORT $LN195@long_pow
  00476	e8 00 00 00 00	 call	 _Px_Dealloc
  0047b	eb 14		 jmp	 SHORT $LN105@long_pow
$LN195@long_pow:
  0047d	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00481	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00487	eb 08		 jmp	 SHORT $LN105@long_pow
$LN190@long_pow:
  00489	48 8b cf	 mov	 rcx, rdi
  0048c	e8 00 00 00 00	 call	 Px_DecRef
$LN105@long_pow:
  00491	48 8b 7c 24 30	 mov	 rdi, QWORD PTR temp$[rsp]
$LN110@long_pow:

; 3929 :                 if (bi & j)

  00496	4c 85 e3	 test	 r12, rbx
  00499	0f 84 28 01 00
	00		 je	 $LN99@long_pow

; 3930 :                     MULT(z, a, z);

  0049f	48 8b 54 24 38	 mov	 rdx, QWORD PTR a$1$[rsp]
  004a4	48 8b cf	 mov	 rcx, rdi
  004a7	e8 00 00 00 00	 call	 long_mul
  004ac	48 8b f0	 mov	 rsi, rax
  004af	48 85 c0	 test	 rax, rax
  004b2	0f 84 ba 05 00
	00		 je	 $Error$23136
  004b8	48 85 ff	 test	 rdi, rdi
  004bb	74 65		 je	 SHORT $LN96@long_pow
  004bd	e8 00 00 00 00	 call	 _Py_PXCTX
  004c2	85 c0		 test	 eax, eax
  004c4	75 5c		 jne	 SHORT $LN96@long_pow
  004c6	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  004ca	a8 20		 test	 al, 32			; 00000020H
  004cc	75 4c		 jne	 SHORT $LN201@long_pow
  004ce	84 c0		 test	 al, al
  004d0	78 48		 js	 SHORT $LN201@long_pow
  004d2	a8 02		 test	 al, 2
  004d4	75 4c		 jne	 SHORT $LN96@long_pow
  004d6	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  004da	75 46		 jne	 SHORT $LN96@long_pow
  004dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  004e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  004ea	4c 8b cf	 mov	 r9, rdi
  004ed	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  004f3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004fb	e8 00 00 00 00	 call	 _PyParallel_Guard
  00500	48 8b cf	 mov	 rcx, rdi
  00503	85 c0		 test	 eax, eax
  00505	74 07		 je	 SHORT $LN206@long_pow
  00507	e8 00 00 00 00	 call	 _Px_Dealloc
  0050c	eb 14		 jmp	 SHORT $LN96@long_pow
$LN206@long_pow:
  0050e	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00512	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00518	eb 08		 jmp	 SHORT $LN96@long_pow
$LN201@long_pow:
  0051a	48 8b cf	 mov	 rcx, rdi
  0051d	e8 00 00 00 00	 call	 Px_DecRef
$LN96@long_pow:
  00522	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR c$1$[rbp-256]
  00529	48 8b fe	 mov	 rdi, rsi
  0052c	4c 89 7c 24 30	 mov	 QWORD PTR temp$[rsp], r15
  00531	49 8b f7	 mov	 rsi, r15
  00534	48 85 c0	 test	 rax, rax
  00537	0f 84 8a 00 00
	00		 je	 $LN99@long_pow
  0053d	4c 8d 4c 24 30	 lea	 r9, QWORD PTR temp$[rsp]
  00542	45 33 c0	 xor	 r8d, r8d
  00545	48 8b d0	 mov	 rdx, rax
  00548	48 8b cf	 mov	 rcx, rdi
  0054b	e8 00 00 00 00	 call	 l_divmod
  00550	85 c0		 test	 eax, eax
  00552	0f 88 15 05 00
	00		 js	 $LN375@long_pow
  00558	48 85 ff	 test	 rdi, rdi
  0055b	74 65		 je	 SHORT $LN87@long_pow
  0055d	e8 00 00 00 00	 call	 _Py_PXCTX
  00562	85 c0		 test	 eax, eax
  00564	75 5c		 jne	 SHORT $LN87@long_pow
  00566	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0056a	a8 20		 test	 al, 32			; 00000020H
  0056c	75 4c		 jne	 SHORT $LN212@long_pow
  0056e	84 c0		 test	 al, al
  00570	78 48		 js	 SHORT $LN212@long_pow
  00572	a8 02		 test	 al, 2
  00574	75 4c		 jne	 SHORT $LN87@long_pow
  00576	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0057a	75 46		 jne	 SHORT $LN87@long_pow
  0057c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00583	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0058a	4c 8b cf	 mov	 r9, rdi
  0058d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00593	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0059b	e8 00 00 00 00	 call	 _PyParallel_Guard
  005a0	48 8b cf	 mov	 rcx, rdi
  005a3	85 c0		 test	 eax, eax
  005a5	74 07		 je	 SHORT $LN217@long_pow
  005a7	e8 00 00 00 00	 call	 _Px_Dealloc
  005ac	eb 14		 jmp	 SHORT $LN87@long_pow
$LN217@long_pow:
  005ae	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  005b2	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  005b8	eb 08		 jmp	 SHORT $LN87@long_pow
$LN212@long_pow:
  005ba	48 8b cf	 mov	 rcx, rdi
  005bd	e8 00 00 00 00	 call	 Px_DecRef
$LN87@long_pow:
  005c2	48 8b 7c 24 30	 mov	 rdi, QWORD PTR temp$[rsp]
$LN99@long_pow:

; 3926 : 
; 3927 :             for (j = (digit)1 << (PyLong_SHIFT-1); j != 0; j >>= 1) {

  005c7	48 d1 fb	 sar	 rbx, 1
  005ca	0f 85 a0 fd ff
	ff		 jne	 $LL122@long_pow

; 3922 :         /* Left-to-right binary exponentiation (HAC Algorithm 14.79) */
; 3923 :         /* http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf    */
; 3924 :         for (i = Py_SIZE(b) - 1; i >= 0; --i) {

  005d0	49 83 ee 04	 sub	 r14, 4
  005d4	49 ff cd	 dec	 r13
  005d7	0f 89 83 fd ff
	ff		 jns	 $LL125@long_pow

; 3949 :                     MULT(z, table[index], z);

  005dd	48 8b 9d a8 00
	00 00		 mov	 rbx, QWORD PTR c$1$[rbp-256]
$LN61@long_pow:

; 3950 :             }
; 3951 :         }
; 3952 :     }
; 3953 : 
; 3954 :     if (negativeOutput && (Py_SIZE(z) != 0)) {

  005e4	44 39 bd 90 00
	00 00		 cmp	 DWORD PTR negativeOutput$1$[rbp-256], r15d
  005eb	0f 84 ee 04 00
	00		 je	 $LN382@long_pow
  005f1	4c 39 7f 60	 cmp	 QWORD PTR [rdi+96], r15
  005f5	0f 84 e4 04 00
	00		 je	 $LN382@long_pow

; 3955 :         temp = (PyLongObject *)long_sub(z, c);

  005fb	48 8b d3	 mov	 rdx, rbx
  005fe	48 8b cf	 mov	 rcx, rdi
  00601	e8 00 00 00 00	 call	 long_sub
  00606	48 8b f0	 mov	 rsi, rax

; 3956 :         if (temp == NULL)

  00609	48 85 c0	 test	 rax, rax
  0060c	0f 84 60 04 00
	00		 je	 $Error$23136

; 3957 :             goto Error;
; 3958 :         Py_DECREF(z);

  00612	48 8b cf	 mov	 rcx, rdi
  00615	e8 00 00 00 00	 call	 _Py_DecRef

; 3959 :         z = temp;

  0061a	48 8b fe	 mov	 rdi, rsi

; 3960 :         temp = NULL;

  0061d	49 8b f7	 mov	 rsi, r15
  00620	e9 ba 04 00 00	 jmp	 $LN382@long_pow
$LN126@long_pow:

; 3931 :             }
; 3932 :         }
; 3933 :     }
; 3934 :     else {
; 3935 :         /* Left-to-right 5-ary exponentiation (HAC Algorithm 14.82) */
; 3936 :         Py_INCREF(z);           /* still holds 1L */

  00625	48 8b cf	 mov	 rcx, rdi
  00628	e8 00 00 00 00	 call	 _Py_IncRef

; 3937 :         table[0] = z;

  0062d	48 89 7c 24 50	 mov	 QWORD PTR table$[rsp], rdi
$LL83@long_pow:

; 3939 :             MULT(table[i-1], a, table[i]);

  00632	4a 8b 4c e4 48	 mov	 rcx, QWORD PTR table$[rsp+r12*8-8]
  00637	49 8b d5	 mov	 rdx, r13
  0063a	e8 00 00 00 00	 call	 long_mul
  0063f	48 8b f0	 mov	 rsi, rax
  00642	48 85 c0	 test	 rax, rax
  00645	0f 84 27 04 00
	00		 je	 $Error$23136
  0064b	4a 8b 5c e4 50	 mov	 rbx, QWORD PTR table$[rsp+r12*8]
  00650	48 85 db	 test	 rbx, rbx
  00653	74 65		 je	 SHORT $LN75@long_pow
  00655	e8 00 00 00 00	 call	 _Py_PXCTX
  0065a	85 c0		 test	 eax, eax
  0065c	75 5c		 jne	 SHORT $LN75@long_pow
  0065e	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00662	a8 20		 test	 al, 32			; 00000020H
  00664	75 4c		 jne	 SHORT $LN223@long_pow
  00666	84 c0		 test	 al, al
  00668	78 48		 js	 SHORT $LN223@long_pow
  0066a	a8 02		 test	 al, 2
  0066c	75 4c		 jne	 SHORT $LN75@long_pow
  0066e	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00672	75 46		 jne	 SHORT $LN75@long_pow
  00674	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0067b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00682	4c 8b cb	 mov	 r9, rbx
  00685	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0068b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00693	e8 00 00 00 00	 call	 _PyParallel_Guard
  00698	48 8b cb	 mov	 rcx, rbx
  0069b	85 c0		 test	 eax, eax
  0069d	74 07		 je	 SHORT $LN228@long_pow
  0069f	e8 00 00 00 00	 call	 _Px_Dealloc
  006a4	eb 14		 jmp	 SHORT $LN75@long_pow
$LN228@long_pow:
  006a6	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  006aa	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  006b0	eb 08		 jmp	 SHORT $LN75@long_pow
$LN223@long_pow:
  006b2	48 8b cb	 mov	 rcx, rbx
  006b5	e8 00 00 00 00	 call	 Px_DecRef
$LN75@long_pow:
  006ba	48 8b 9d a8 00
	00 00		 mov	 rbx, QWORD PTR c$1$[rbp-256]
  006c1	48 8b ce	 mov	 rcx, rsi
  006c4	4a 89 74 e4 50	 mov	 QWORD PTR table$[rsp+r12*8], rsi
  006c9	49 8b f7	 mov	 rsi, r15
  006cc	4c 89 7c 24 30	 mov	 QWORD PTR temp$[rsp], r15
  006d1	48 85 db	 test	 rbx, rbx
  006d4	0f 84 98 00 00
	00		 je	 $LN71@long_pow
  006da	4c 8d 4c 24 30	 lea	 r9, QWORD PTR temp$[rsp]
  006df	45 33 c0	 xor	 r8d, r8d
  006e2	48 8b d3	 mov	 rdx, rbx
  006e5	e8 00 00 00 00	 call	 l_divmod
  006ea	85 c0		 test	 eax, eax
  006ec	0f 88 7b 03 00
	00		 js	 $LN375@long_pow
  006f2	4a 8b 5c e4 50	 mov	 rbx, QWORD PTR table$[rsp+r12*8]
  006f7	48 85 db	 test	 rbx, rbx
  006fa	74 65		 je	 SHORT $LN66@long_pow
  006fc	e8 00 00 00 00	 call	 _Py_PXCTX
  00701	85 c0		 test	 eax, eax
  00703	75 5c		 jne	 SHORT $LN66@long_pow
  00705	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00709	a8 20		 test	 al, 32			; 00000020H
  0070b	75 4c		 jne	 SHORT $LN234@long_pow
  0070d	84 c0		 test	 al, al
  0070f	78 48		 js	 SHORT $LN234@long_pow
  00711	a8 02		 test	 al, 2
  00713	75 4c		 jne	 SHORT $LN66@long_pow
  00715	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00719	75 46		 jne	 SHORT $LN66@long_pow
  0071b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00722	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00729	4c 8b cb	 mov	 r9, rbx
  0072c	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00732	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0073a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0073f	48 8b cb	 mov	 rcx, rbx
  00742	85 c0		 test	 eax, eax
  00744	74 07		 je	 SHORT $LN239@long_pow
  00746	e8 00 00 00 00	 call	 _Px_Dealloc
  0074b	eb 14		 jmp	 SHORT $LN66@long_pow
$LN239@long_pow:
  0074d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00751	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00757	eb 08		 jmp	 SHORT $LN66@long_pow
$LN234@long_pow:
  00759	48 8b cb	 mov	 rcx, rbx
  0075c	e8 00 00 00 00	 call	 Px_DecRef
$LN66@long_pow:
  00761	48 8b 44 24 30	 mov	 rax, QWORD PTR temp$[rsp]
  00766	48 8b 9d a8 00
	00 00		 mov	 rbx, QWORD PTR c$1$[rbp-256]
  0076d	4a 89 44 e4 50	 mov	 QWORD PTR table$[rsp+r12*8], rax
$LN71@long_pow:

; 3938 :         for (i = 1; i < 32; ++i)

  00772	49 ff c4	 inc	 r12
  00775	49 83 fc 20	 cmp	 r12, 32			; 00000020H
  00779	0f 8c b3 fe ff
	ff		 jl	 $LL83@long_pow

; 3940 : 
; 3941 :         for (i = Py_SIZE(b) - 1; i >= 0; --i) {

  0077f	49 8b 46 60	 mov	 rax, QWORD PTR [r14+96]
  00783	48 ff c8	 dec	 rax
  00786	48 89 44 24 40	 mov	 QWORD PTR i$3$[rsp], rax
  0078b	0f 88 53 fe ff
	ff		 js	 $LN61@long_pow
  00791	49 8d 4c 86 70	 lea	 rcx, QWORD PTR [r14+rax*4+112]
  00796	48 89 4c 24 48	 mov	 QWORD PTR tv1909[rsp], rcx
  0079b	0f 1f 44 00 00	 npad	 5
$LL63@long_pow:

; 3942 :             const digit bi = b->ob_digit[i];

  007a0	44 8b 31	 mov	 r14d, DWORD PTR [rcx]

; 3943 : 
; 3944 :             for (j = PyLong_SHIFT - 5; j >= 0; j -= 5) {

  007a3	41 bd 19 00 00
	00		 mov	 r13d, 25
  007a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL60@long_pow:

; 3945 :                 const int index = (bi >> j) & 0x1f;

  007b0	45 8b e6	 mov	 r12d, r14d
  007b3	49 8b cd	 mov	 rcx, r13

; 3946 :                 for (k = 0; k < 5; ++k)

  007b6	49 8b df	 mov	 rbx, r15
  007b9	41 d3 ec	 shr	 r12d, cl
  007bc	41 83 e4 1f	 and	 r12d, 31
$LL57@long_pow:

; 3947 :                     MULT(z, z, z);

  007c0	48 8b d7	 mov	 rdx, rdi
  007c3	48 8b cf	 mov	 rcx, rdi
  007c6	e8 00 00 00 00	 call	 long_mul
  007cb	48 8b f0	 mov	 rsi, rax
  007ce	48 85 c0	 test	 rax, rax
  007d1	0f 84 9b 02 00
	00		 je	 $Error$23136
  007d7	48 85 ff	 test	 rdi, rdi
  007da	74 65		 je	 SHORT $LN49@long_pow
  007dc	e8 00 00 00 00	 call	 _Py_PXCTX
  007e1	85 c0		 test	 eax, eax
  007e3	75 5c		 jne	 SHORT $LN49@long_pow
  007e5	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  007e9	a8 20		 test	 al, 32			; 00000020H
  007eb	75 4c		 jne	 SHORT $LN245@long_pow
  007ed	84 c0		 test	 al, al
  007ef	78 48		 js	 SHORT $LN245@long_pow
  007f1	a8 02		 test	 al, 2
  007f3	75 4c		 jne	 SHORT $LN49@long_pow
  007f5	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  007f9	75 46		 jne	 SHORT $LN49@long_pow
  007fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00802	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00809	4c 8b cf	 mov	 r9, rdi
  0080c	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00812	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0081a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0081f	48 8b cf	 mov	 rcx, rdi
  00822	85 c0		 test	 eax, eax
  00824	74 07		 je	 SHORT $LN250@long_pow
  00826	e8 00 00 00 00	 call	 _Px_Dealloc
  0082b	eb 14		 jmp	 SHORT $LN49@long_pow
$LN250@long_pow:
  0082d	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00831	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00837	eb 08		 jmp	 SHORT $LN49@long_pow
$LN245@long_pow:
  00839	48 8b cf	 mov	 rcx, rdi
  0083c	e8 00 00 00 00	 call	 Px_DecRef
$LN49@long_pow:
  00841	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR c$1$[rbp-256]
  00848	48 8b fe	 mov	 rdi, rsi
  0084b	4c 89 7c 24 30	 mov	 QWORD PTR temp$[rsp], r15
  00850	49 8b f7	 mov	 rsi, r15
  00853	48 85 c0	 test	 rax, rax
  00856	0f 84 8a 00 00
	00		 je	 $LN45@long_pow
  0085c	4c 8d 4c 24 30	 lea	 r9, QWORD PTR temp$[rsp]
  00861	45 33 c0	 xor	 r8d, r8d
  00864	48 8b d0	 mov	 rdx, rax
  00867	48 8b cf	 mov	 rcx, rdi
  0086a	e8 00 00 00 00	 call	 l_divmod
  0086f	85 c0		 test	 eax, eax
  00871	0f 88 f6 01 00
	00		 js	 $LN375@long_pow
  00877	48 85 ff	 test	 rdi, rdi
  0087a	74 65		 je	 SHORT $LN40@long_pow
  0087c	e8 00 00 00 00	 call	 _Py_PXCTX
  00881	85 c0		 test	 eax, eax
  00883	75 5c		 jne	 SHORT $LN40@long_pow
  00885	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00889	a8 20		 test	 al, 32			; 00000020H
  0088b	75 4c		 jne	 SHORT $LN256@long_pow
  0088d	84 c0		 test	 al, al
  0088f	78 48		 js	 SHORT $LN256@long_pow
  00891	a8 02		 test	 al, 2
  00893	75 4c		 jne	 SHORT $LN40@long_pow
  00895	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00899	75 46		 jne	 SHORT $LN40@long_pow
  0089b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  008a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  008a9	4c 8b cf	 mov	 r9, rdi
  008ac	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  008b2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  008ba	e8 00 00 00 00	 call	 _PyParallel_Guard
  008bf	48 8b cf	 mov	 rcx, rdi
  008c2	85 c0		 test	 eax, eax
  008c4	74 07		 je	 SHORT $LN261@long_pow
  008c6	e8 00 00 00 00	 call	 _Px_Dealloc
  008cb	eb 14		 jmp	 SHORT $LN40@long_pow
$LN261@long_pow:
  008cd	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  008d1	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  008d7	eb 08		 jmp	 SHORT $LN40@long_pow
$LN256@long_pow:
  008d9	48 8b cf	 mov	 rcx, rdi
  008dc	e8 00 00 00 00	 call	 Px_DecRef
$LN40@long_pow:
  008e1	48 8b 7c 24 30	 mov	 rdi, QWORD PTR temp$[rsp]
$LN45@long_pow:

; 3946 :                 for (k = 0; k < 5; ++k)

  008e6	48 ff c3	 inc	 rbx
  008e9	48 83 fb 05	 cmp	 rbx, 5
  008ed	0f 8c cd fe ff
	ff		 jl	 $LL57@long_pow

; 3948 :                 if (index)

  008f3	45 85 e4	 test	 r12d, r12d
  008f6	0f 84 37 01 00
	00		 je	 $LN383@long_pow

; 3949 :                     MULT(z, table[index], z);

  008fc	49 63 d4	 movsxd	 rdx, r12d
  008ff	48 8b cf	 mov	 rcx, rdi
  00902	48 8b 54 d4 50	 mov	 rdx, QWORD PTR table$[rsp+rdx*8]
  00907	e8 00 00 00 00	 call	 long_mul
  0090c	48 8b f0	 mov	 rsi, rax
  0090f	48 85 c0	 test	 rax, rax
  00912	0f 84 5a 01 00
	00		 je	 $Error$23136
  00918	48 85 ff	 test	 rdi, rdi
  0091b	74 65		 je	 SHORT $LN31@long_pow
  0091d	e8 00 00 00 00	 call	 _Py_PXCTX
  00922	85 c0		 test	 eax, eax
  00924	75 5c		 jne	 SHORT $LN31@long_pow
  00926	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0092a	a8 20		 test	 al, 32			; 00000020H
  0092c	75 4c		 jne	 SHORT $LN267@long_pow
  0092e	84 c0		 test	 al, al
  00930	78 48		 js	 SHORT $LN267@long_pow
  00932	a8 02		 test	 al, 2
  00934	75 4c		 jne	 SHORT $LN31@long_pow
  00936	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0093a	75 46		 jne	 SHORT $LN31@long_pow
  0093c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00943	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0094a	4c 8b cf	 mov	 r9, rdi
  0094d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00953	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0095b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00960	48 8b cf	 mov	 rcx, rdi
  00963	85 c0		 test	 eax, eax
  00965	74 07		 je	 SHORT $LN272@long_pow
  00967	e8 00 00 00 00	 call	 _Px_Dealloc
  0096c	eb 14		 jmp	 SHORT $LN31@long_pow
$LN272@long_pow:
  0096e	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00972	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00978	eb 08		 jmp	 SHORT $LN31@long_pow
$LN267@long_pow:
  0097a	48 8b cf	 mov	 rcx, rdi
  0097d	e8 00 00 00 00	 call	 Px_DecRef
$LN31@long_pow:
  00982	48 8b 9d a8 00
	00 00		 mov	 rbx, QWORD PTR c$1$[rbp-256]
  00989	48 8b fe	 mov	 rdi, rsi
  0098c	4c 89 7c 24 30	 mov	 QWORD PTR temp$[rsp], r15
  00991	49 8b f7	 mov	 rsi, r15
  00994	48 85 db	 test	 rbx, rbx
  00997	0f 84 9d 00 00
	00		 je	 $LN34@long_pow
  0099d	4c 8d 4c 24 30	 lea	 r9, QWORD PTR temp$[rsp]
  009a2	45 33 c0	 xor	 r8d, r8d
  009a5	48 8b d3	 mov	 rdx, rbx
  009a8	48 8b cf	 mov	 rcx, rdi
  009ab	e8 00 00 00 00	 call	 l_divmod
  009b0	85 c0		 test	 eax, eax
  009b2	0f 88 b5 00 00
	00		 js	 $LN375@long_pow
  009b8	48 85 ff	 test	 rdi, rdi
  009bb	74 6f		 je	 SHORT $LN22@long_pow
  009bd	e8 00 00 00 00	 call	 _Py_PXCTX
  009c2	85 c0		 test	 eax, eax
  009c4	75 66		 jne	 SHORT $LN22@long_pow
  009c6	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  009ca	a8 20		 test	 al, 32			; 00000020H
  009cc	75 56		 jne	 SHORT $LN278@long_pow
  009ce	84 c0		 test	 al, al
  009d0	78 52		 js	 SHORT $LN278@long_pow
  009d2	a8 02		 test	 al, 2
  009d4	75 56		 jne	 SHORT $LN22@long_pow
  009d6	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  009da	75 50		 jne	 SHORT $LN22@long_pow
  009dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  009e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  009ea	4c 8b cf	 mov	 r9, rdi
  009ed	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  009f3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  009fb	e8 00 00 00 00	 call	 _PyParallel_Guard
  00a00	48 8b cf	 mov	 rcx, rdi
  00a03	85 c0		 test	 eax, eax
  00a05	74 0c		 je	 SHORT $LN283@long_pow
  00a07	e8 00 00 00 00	 call	 _Px_Dealloc
  00a0c	48 8b 7c 24 30	 mov	 rdi, QWORD PTR temp$[rsp]
  00a11	eb 27		 jmp	 SHORT $LN34@long_pow
$LN283@long_pow:
  00a13	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00a17	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00a1d	48 8b 7c 24 30	 mov	 rdi, QWORD PTR temp$[rsp]
  00a22	eb 16		 jmp	 SHORT $LN34@long_pow
$LN278@long_pow:
  00a24	48 8b cf	 mov	 rcx, rdi
  00a27	e8 00 00 00 00	 call	 Px_DecRef
$LN22@long_pow:
  00a2c	48 8b 7c 24 30	 mov	 rdi, QWORD PTR temp$[rsp]
  00a31	eb 07		 jmp	 SHORT $LN34@long_pow
$LN383@long_pow:
  00a33	48 8b 9d a8 00
	00 00		 mov	 rbx, QWORD PTR c$1$[rbp-256]
$LN34@long_pow:

; 3943 : 
; 3944 :             for (j = PyLong_SHIFT - 5; j >= 0; j -= 5) {

  00a3a	49 83 ed 05	 sub	 r13, 5
  00a3e	0f 89 6c fd ff
	ff		 jns	 $LL60@long_pow

; 3940 : 
; 3941 :         for (i = Py_SIZE(b) - 1; i >= 0; --i) {

  00a44	48 8b 44 24 40	 mov	 rax, QWORD PTR i$3$[rsp]
  00a49	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv1909[rsp]
  00a4e	48 ff c8	 dec	 rax
  00a51	48 83 e9 04	 sub	 rcx, 4
  00a55	48 89 44 24 40	 mov	 QWORD PTR i$3$[rsp], rax
  00a5a	48 89 4c 24 48	 mov	 QWORD PTR tv1909[rsp], rcx
  00a5f	48 85 c0	 test	 rax, rax
  00a62	0f 89 38 fd ff
	ff		 jns	 $LL63@long_pow
  00a68	e9 77 fb ff ff	 jmp	 $LN61@long_pow
$LN375@long_pow:

; 3956 :         if (temp == NULL)

  00a6d	48 8b 74 24 30	 mov	 rsi, QWORD PTR temp$[rsp]
$Error$23136:

; 3961 :     }
; 3962 :     goto Done;
; 3963 : 
; 3964 :   Error:
; 3965 :     if (z != NULL) {

  00a72	48 85 ff	 test	 rdi, rdi
  00a75	74 68		 je	 SHORT $LN382@long_pow

; 3966 :         Py_DECREF(z);

  00a77	e8 00 00 00 00	 call	 _Py_PXCTX
  00a7c	85 c0		 test	 eax, eax
  00a7e	75 5c		 jne	 SHORT $LN295@long_pow
  00a80	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00a84	a8 20		 test	 al, 32			; 00000020H
  00a86	75 4c		 jne	 SHORT $LN289@long_pow
  00a88	84 c0		 test	 al, al
  00a8a	78 48		 js	 SHORT $LN289@long_pow
  00a8c	a8 02		 test	 al, 2
  00a8e	75 4c		 jne	 SHORT $LN295@long_pow
  00a90	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00a94	75 46		 jne	 SHORT $LN295@long_pow
  00a96	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00a9d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00aa4	4c 8b cf	 mov	 r9, rdi
  00aa7	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00aad	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00ab5	e8 00 00 00 00	 call	 _PyParallel_Guard
  00aba	48 8b cf	 mov	 rcx, rdi
  00abd	85 c0		 test	 eax, eax
  00abf	74 07		 je	 SHORT $LN294@long_pow
  00ac1	e8 00 00 00 00	 call	 _Px_Dealloc
  00ac6	eb 14		 jmp	 SHORT $LN295@long_pow
$LN294@long_pow:
  00ac8	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00acc	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00ad2	eb 08		 jmp	 SHORT $LN295@long_pow
$LN289@long_pow:
  00ad4	48 8b cf	 mov	 rcx, rdi
  00ad7	e8 00 00 00 00	 call	 Px_DecRef
$LN295@long_pow:

; 3967 :         z = NULL;

  00adc	49 8b ff	 mov	 rdi, r15
$LN382@long_pow:
  00adf	4c 8b ad a8 00
	00 00		 mov	 r13, QWORD PTR c$1$[rbp-256]
$LN387@long_pow:
  00ae6	4c 8b 64 24 38	 mov	 r12, QWORD PTR a$1$[rsp]
$Done$23170:

; 3968 :     }
; 3969 :     /* fall through */
; 3970 :   Done:
; 3971 :     if (Py_SIZE(b) > FIVEARY_CUTOFF) {

  00aeb	4c 8b b5 98 00
	00 00		 mov	 r14, QWORD PTR w$[rbp-256]
  00af2	49 83 7e 60 08	 cmp	 QWORD PTR [r14+96], 8
  00af7	7e 7f		 jle	 SHORT $LN13@long_pow
  00af9	0f 1f 80 00 00
	00 00		 npad	 7
$LL15@long_pow:

; 3972 :         for (i = 0; i < 32; ++i)

  00b00	4a 8b 5c fc 50	 mov	 rbx, QWORD PTR table$[rsp+r15*8]

; 3973 :             Py_XDECREF(table[i]);

  00b05	48 85 db	 test	 rbx, rbx
  00b08	74 65		 je	 SHORT $LN11@long_pow
  00b0a	e8 00 00 00 00	 call	 _Py_PXCTX
  00b0f	85 c0		 test	 eax, eax
  00b11	75 5c		 jne	 SHORT $LN11@long_pow
  00b13	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00b17	a8 20		 test	 al, 32			; 00000020H
  00b19	75 4c		 jne	 SHORT $LN300@long_pow
  00b1b	84 c0		 test	 al, al
  00b1d	78 48		 js	 SHORT $LN300@long_pow
  00b1f	a8 02		 test	 al, 2
  00b21	75 4c		 jne	 SHORT $LN11@long_pow
  00b23	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00b27	75 46		 jne	 SHORT $LN11@long_pow
  00b29	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00b30	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00b37	4c 8b cb	 mov	 r9, rbx
  00b3a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00b40	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00b48	e8 00 00 00 00	 call	 _PyParallel_Guard
  00b4d	48 8b cb	 mov	 rcx, rbx
  00b50	85 c0		 test	 eax, eax
  00b52	74 07		 je	 SHORT $LN305@long_pow
  00b54	e8 00 00 00 00	 call	 _Px_Dealloc
  00b59	eb 14		 jmp	 SHORT $LN11@long_pow
$LN305@long_pow:
  00b5b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00b5f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00b65	eb 08		 jmp	 SHORT $LN11@long_pow
$LN300@long_pow:
  00b67	48 8b cb	 mov	 rcx, rbx
  00b6a	e8 00 00 00 00	 call	 Px_DecRef
$LN11@long_pow:

; 3972 :         for (i = 0; i < 32; ++i)

  00b6f	49 ff c7	 inc	 r15
  00b72	49 83 ff 20	 cmp	 r15, 32			; 00000020H
  00b76	7c 88		 jl	 SHORT $LL15@long_pow
$LN13@long_pow:

; 3974 :     }
; 3975 :     Py_DECREF(a);

  00b78	e8 00 00 00 00	 call	 _Py_PXCTX
  00b7d	85 c0		 test	 eax, eax
  00b7f	75 5f		 jne	 SHORT $LN317@long_pow
  00b81	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  00b86	a8 20		 test	 al, 32			; 00000020H
  00b88	75 4e		 jne	 SHORT $LN311@long_pow
  00b8a	84 c0		 test	 al, al
  00b8c	78 4a		 js	 SHORT $LN311@long_pow
  00b8e	a8 02		 test	 al, 2
  00b90	75 4e		 jne	 SHORT $LN317@long_pow
  00b92	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  00b97	75 47		 jne	 SHORT $LN317@long_pow
  00b99	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00ba0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00ba7	4d 8b cc	 mov	 r9, r12
  00baa	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00bb0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00bb8	e8 00 00 00 00	 call	 _PyParallel_Guard
  00bbd	49 8b cc	 mov	 rcx, r12
  00bc0	85 c0		 test	 eax, eax
  00bc2	74 07		 je	 SHORT $LN316@long_pow
  00bc4	e8 00 00 00 00	 call	 _Px_Dealloc
  00bc9	eb 15		 jmp	 SHORT $LN317@long_pow
$LN316@long_pow:
  00bcb	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  00bd0	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00bd6	eb 08		 jmp	 SHORT $LN317@long_pow
$LN311@long_pow:
  00bd8	49 8b cc	 mov	 rcx, r12
  00bdb	e8 00 00 00 00	 call	 Px_DecRef
$LN317@long_pow:

; 3976 :     Py_DECREF(b);

  00be0	e8 00 00 00 00	 call	 _Py_PXCTX
  00be5	85 c0		 test	 eax, eax
  00be7	75 5c		 jne	 SHORT $LN8@long_pow
  00be9	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  00bed	a8 20		 test	 al, 32			; 00000020H
  00bef	75 4c		 jne	 SHORT $LN322@long_pow
  00bf1	84 c0		 test	 al, al
  00bf3	78 48		 js	 SHORT $LN322@long_pow
  00bf5	a8 02		 test	 al, 2
  00bf7	75 4c		 jne	 SHORT $LN8@long_pow
  00bf9	49 ff 4e 50	 dec	 QWORD PTR [r14+80]
  00bfd	75 46		 jne	 SHORT $LN8@long_pow
  00bff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00c06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00c0d	4d 8b ce	 mov	 r9, r14
  00c10	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00c16	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00c1e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00c23	49 8b ce	 mov	 rcx, r14
  00c26	85 c0		 test	 eax, eax
  00c28	74 07		 je	 SHORT $LN327@long_pow
  00c2a	e8 00 00 00 00	 call	 _Px_Dealloc
  00c2f	eb 14		 jmp	 SHORT $LN8@long_pow
$LN327@long_pow:
  00c31	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  00c35	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00c3b	eb 08		 jmp	 SHORT $LN8@long_pow
$LN322@long_pow:
  00c3d	49 8b ce	 mov	 rcx, r14
  00c40	e8 00 00 00 00	 call	 Px_DecRef
$LN8@long_pow:

; 3977 :     Py_XDECREF(c);

  00c45	4d 85 ed	 test	 r13, r13
  00c48	74 65		 je	 SHORT $LN7@long_pow
  00c4a	e8 00 00 00 00	 call	 _Py_PXCTX
  00c4f	85 c0		 test	 eax, eax
  00c51	75 5c		 jne	 SHORT $LN7@long_pow
  00c53	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  00c57	a8 20		 test	 al, 32			; 00000020H
  00c59	75 4c		 jne	 SHORT $LN333@long_pow
  00c5b	84 c0		 test	 al, al
  00c5d	78 48		 js	 SHORT $LN333@long_pow
  00c5f	a8 02		 test	 al, 2
  00c61	75 4c		 jne	 SHORT $LN7@long_pow
  00c63	49 ff 4d 50	 dec	 QWORD PTR [r13+80]
  00c67	75 46		 jne	 SHORT $LN7@long_pow
  00c69	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00c70	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00c77	4d 8b cd	 mov	 r9, r13
  00c7a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00c80	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00c88	e8 00 00 00 00	 call	 _PyParallel_Guard
  00c8d	49 8b cd	 mov	 rcx, r13
  00c90	85 c0		 test	 eax, eax
  00c92	74 07		 je	 SHORT $LN338@long_pow
  00c94	e8 00 00 00 00	 call	 _Px_Dealloc
  00c99	eb 14		 jmp	 SHORT $LN7@long_pow
$LN338@long_pow:
  00c9b	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  00c9f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00ca5	eb 08		 jmp	 SHORT $LN7@long_pow
$LN333@long_pow:
  00ca7	49 8b cd	 mov	 rcx, r13
  00caa	e8 00 00 00 00	 call	 Px_DecRef
$LN7@long_pow:

; 3978 :     Py_XDECREF(temp);

  00caf	48 85 f6	 test	 rsi, rsi
  00cb2	74 71		 je	 SHORT $LN3@long_pow
  00cb4	e8 00 00 00 00	 call	 _Py_PXCTX
  00cb9	85 c0		 test	 eax, eax
  00cbb	75 68		 jne	 SHORT $LN3@long_pow
  00cbd	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  00cc1	a8 20		 test	 al, 32			; 00000020H
  00cc3	75 58		 jne	 SHORT $LN344@long_pow
  00cc5	84 c0		 test	 al, al
  00cc7	78 54		 js	 SHORT $LN344@long_pow
  00cc9	a8 02		 test	 al, 2
  00ccb	75 58		 jne	 SHORT $LN3@long_pow
  00ccd	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  00cd1	75 52		 jne	 SHORT $LN3@long_pow
  00cd3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00cda	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00ce1	4c 8b ce	 mov	 r9, rsi
  00ce4	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00cea	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00cf2	e8 00 00 00 00	 call	 _PyParallel_Guard
  00cf7	48 8b ce	 mov	 rcx, rsi
  00cfa	85 c0		 test	 eax, eax
  00cfc	74 0d		 je	 SHORT $LN349@long_pow
  00cfe	e8 00 00 00 00	 call	 _Px_Dealloc

; 3979 :     return (PyObject *)z;

  00d03	48 8b c7	 mov	 rax, rdi
  00d06	e9 e7 f4 ff ff	 jmp	 $LN385@long_pow

; 3978 :     Py_XDECREF(temp);

$LN349@long_pow:
  00d0b	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00d0f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 3979 :     return (PyObject *)z;

  00d15	48 8b c7	 mov	 rax, rdi
  00d18	e9 d5 f4 ff ff	 jmp	 $LN385@long_pow

; 3978 :     Py_XDECREF(temp);

$LN344@long_pow:
  00d1d	48 8b ce	 mov	 rcx, rsi
  00d20	e8 00 00 00 00	 call	 Px_DecRef
$LN3@long_pow:

; 3979 :     return (PyObject *)z;

  00d25	48 8b c7	 mov	 rax, rdi
  00d28	e9 c5 f4 ff ff	 jmp	 $LN385@long_pow
$LN145@long_pow:

; 3817 :     else {
; 3818 :         Py_DECREF(a);

  00d2d	49 8b cc	 mov	 rcx, r12
  00d30	e8 00 00 00 00	 call	 _Py_DecRef

; 3819 :         Py_DECREF(b);

  00d35	49 8b ce	 mov	 rcx, r14
  00d38	e8 00 00 00 00	 call	 _Py_DecRef

; 3820 :         Py_RETURN_NOTIMPLEMENTED;

  00d3d	e8 00 00 00 00	 call	 _Py_PXCTX
  00d42	85 c0		 test	 eax, eax
  00d44	75 3c		 jne	 SHORT $LN172@long_pow
  00d46	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00d4d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00d54	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00d5b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00d61	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00d69	e8 00 00 00 00	 call	 _PyParallel_Guard
  00d6e	85 c0		 test	 eax, eax
  00d70	75 09		 jne	 SHORT $LN171@long_pow
  00d72	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00d79	74 07		 je	 SHORT $LN172@long_pow
$LN171@long_pow:
  00d7b	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN172@long_pow:
  00d82	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00d89	e9 64 f4 ff ff	 jmp	 $LN385@long_pow
$LN148@long_pow:

; 3796 : 
; 3797 :     PyLongObject *z = NULL;  /* accumulated result */
; 3798 :     Py_ssize_t i, j, k;             /* counters */
; 3799 :     PyLongObject *temp = NULL;
; 3800 : 
; 3801 :     /* 5-ary values.  If the exponent is large enough, table is
; 3802 :      * precomputed so that table[i] == a**i % c for i in range(32).
; 3803 :      */
; 3804 :     PyLongObject *table[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
; 3805 :                                0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
; 3806 : 
; 3807 :     /* a, b, c = v, w, x */
; 3808 :     CHECK_BINOP(v, w);

  00d8e	e8 00 00 00 00	 call	 _Py_PXCTX
  00d93	85 c0		 test	 eax, eax
  00d95	75 3c		 jne	 SHORT $LN160@long_pow
  00d97	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00d9e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00da5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00dac	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00db2	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00dba	e8 00 00 00 00	 call	 _PyParallel_Guard
  00dbf	85 c0		 test	 eax, eax
  00dc1	75 09		 jne	 SHORT $LN159@long_pow
  00dc3	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00dca	74 07		 je	 SHORT $LN160@long_pow
$LN159@long_pow:
  00dcc	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN160@long_pow:
  00dd3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00dda	e9 1b f4 ff ff	 jmp	 $LN153@long_pow
long_pow ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT long_abs
_TEXT	SEGMENT
v$ = 8
long_abs PROC						; COMDAT

; 4016 :     if (Py_SIZE(v) < 0)

  00000	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  00005	7d 05		 jge	 SHORT $LN2@long_abs

; 4017 :         return long_neg(v);
; 4018 :     else
; 4019 :         return long_long((PyObject *)v);
; 4020 : }

  00007	e9 00 00 00 00	 jmp	 long_neg
$LN2@long_abs:
  0000c	e9 00 00 00 00	 jmp	 long_long
long_abs ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@NJOBDKOI@non?9integer?5arguments?5in?5divisio@ ; `string'
PUBLIC	_PyLong_DivmodNear
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_DivmodNear DD imagerel $LN44
	DD	imagerel $LN44+70
	DD	imagerel $unwind$_PyLong_DivmodNear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_PyLong_DivmodNear DD imagerel $LN44+70
	DD	imagerel $LN44+123
	DD	imagerel $chain$1$_PyLong_DivmodNear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_PyLong_DivmodNear DD imagerel $LN44+123
	DD	imagerel $LN44+452
	DD	imagerel $chain$4$_PyLong_DivmodNear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$_PyLong_DivmodNear DD imagerel $LN44+452
	DD	imagerel $LN44+470
	DD	imagerel $chain$5$_PyLong_DivmodNear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$_PyLong_DivmodNear DD imagerel $LN44+470
	DD	imagerel $LN44+513
	DD	imagerel $chain$7$_PyLong_DivmodNear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$_PyLong_DivmodNear DD imagerel $LN44+513
	DD	imagerel $LN44+542
	DD	imagerel $chain$8$_PyLong_DivmodNear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$_PyLong_DivmodNear DD 021H
	DD	imagerel $LN44
	DD	imagerel $LN44+70
	DD	imagerel $unwind$_PyLong_DivmodNear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$_PyLong_DivmodNear DD 0a0021H
	DD	04f400H
	DD	05e400H
	DD	06d400H
	DD	07c400H
	DD	0d7400H
	DD	imagerel $LN44
	DD	imagerel $LN44+70
	DD	imagerel $unwind$_PyLong_DivmodNear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$_PyLong_DivmodNear DD 021H
	DD	imagerel $LN44+70
	DD	imagerel $LN44+123
	DD	imagerel $chain$1$_PyLong_DivmodNear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_PyLong_DivmodNear DD 061f21H
	DD	04f41fH
	DD	05e41aH
	DD	0d7405H
	DD	imagerel $LN44+70
	DD	imagerel $LN44+123
	DD	imagerel $chain$1$_PyLong_DivmodNear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_PyLong_DivmodNear DD 040e21H
	DD	06d40eH
	DD	07c405H
	DD	imagerel $LN44
	DD	imagerel $LN44+70
	DD	imagerel $unwind$_PyLong_DivmodNear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_DivmodNear DD 040801H
	DD	060047208H
	DD	030025003H
xdata	ENDS
;	COMDAT ??_C@_0CC@NJOBDKOI@non?9integer?5arguments?5in?5divisio@
CONST	SEGMENT
??_C@_0CC@NJOBDKOI@non?9integer?5arguments?5in?5divisio@ DB 'non-integer '
	DB	'arguments in division', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyLong_DivmodNear
_TEXT	SEGMENT
quo$ = 96
a$ = 96
b$ = 104
rem$ = 112
_PyLong_DivmodNear PROC					; COMDAT

; 4452 : {

$LN44:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 4453 :     PyLongObject *quo = NULL, *rem = NULL;
; 4454 :     PyObject *one = NULL, *twice_rem, *result, *temp;
; 4455 :     int cmp, quo_is_odd, quo_is_neg;
; 4456 : 
; 4457 :     /* Equivalent Python code:
; 4458 : 
; 4459 :        def divmod_near(a, b):
; 4460 :            q, r = divmod(a, b)
; 4461 :            # round up if either r / b > 0.5, or r / b == 0.5 and q is odd.
; 4462 :            # The expression r / b > 0.5 is equivalent to 2 * r > b if b is
; 4463 :            # positive, 2 * r < b if b negative.
; 4464 :            greater_than_half = 2*r > b if b > 0 else 2*r < b
; 4465 :            exactly_half = 2*r == b
; 4466 :            if greater_than_half or exactly_half and q % 2 == 1:
; 4467 :                q += 1
; 4468 :                r -= b
; 4469 :            return q, r
; 4470 : 
; 4471 :     */
; 4472 :     if (!PyLong_Check(a) || !PyLong_Check(b)) {

  00008	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000c	33 f6		 xor	 esi, esi
  0000e	48 8b ea	 mov	 rbp, rdx
  00011	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0001b	48 8b d9	 mov	 rbx, rcx
  0001e	48 89 74 24 60	 mov	 QWORD PTR quo$[rsp], rsi
  00023	48 89 74 24 70	 mov	 QWORD PTR rem$[rsp], rsi
  00028	0f 84 d3 01 00
	00		 je	 $LN27@PyLong_Div
  0002e	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00032	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0003c	0f 84 bf 01 00
	00		 je	 $LN27@PyLong_Div

; 4476 :     }
; 4477 : 
; 4478 :     /* Do a and b have different signs?  If so, quotient is negative. */
; 4479 :     quo_is_neg = (Py_SIZE(a) < 0) != (Py_SIZE(b) < 0);

  00042	8b ce		 mov	 ecx, esi
  00044	8b c6		 mov	 eax, esi
  00046	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  0004b	48 39 4b 60	 cmp	 QWORD PTR [rbx+96], rcx
  0004f	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  00054	44 8b ee	 mov	 r13d, esi
  00057	0f 9c c1	 setl	 cl
  0005a	48 39 42 60	 cmp	 QWORD PTR [rdx+96], rax
  0005e	0f 9c c0	 setl	 al
  00061	3b c8		 cmp	 ecx, eax

; 4480 : 
; 4481 :     one = PyLong_FromLong(1L);

  00063	8d 4e 01	 lea	 ecx, QWORD PTR [rsi+1]
  00066	41 0f 95 c5	 setne	 r13b
  0006a	e8 00 00 00 00	 call	 PyLong_FromLong
  0006f	4c 8b e0	 mov	 r12, rax

; 4482 :     if (one == NULL)

  00072	48 85 c0	 test	 rax, rax
  00075	0f 84 49 01 00
	00		 je	 $LN38@PyLong_Div
$LN26@PyLong_Div:
  0007b	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi

; 4483 :         return NULL;
; 4484 : 
; 4485 :     if (long_divrem((PyLongObject*)a, (PyLongObject*)b, &quo, &rem) < 0)

  00080	4c 8d 4c 24 70	 lea	 r9, QWORD PTR rem$[rsp]
  00085	4c 8d 44 24 60	 lea	 r8, QWORD PTR quo$[rsp]
  0008a	48 8b d5	 mov	 rdx, rbp
  0008d	48 8b cb	 mov	 rcx, rbx
  00090	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00095	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  0009a	e8 00 00 00 00	 call	 long_divrem

; 4486 :         goto error;
; 4487 : 
; 4488 :     /* compare twice the remainder with the divisor, to see
; 4489 :        if we need to adjust the quotient and remainder */
; 4490 :     twice_rem = long_lshift((PyObject *)rem, one);

  0009f	48 8b 7c 24 70	 mov	 rdi, QWORD PTR rem$[rsp]
  000a4	85 c0		 test	 eax, eax
  000a6	0f 88 2a 01 00
	00		 js	 $LN35@PyLong_Div
  000ac	49 8b d4	 mov	 rdx, r12
  000af	48 8b cf	 mov	 rcx, rdi
  000b2	e8 00 00 00 00	 call	 long_lshift
  000b7	4c 8b f0	 mov	 r14, rax

; 4491 :     if (twice_rem == NULL)

  000ba	48 85 c0	 test	 rax, rax
  000bd	0f 84 13 01 00
	00		 je	 $LN35@PyLong_Div

; 4492 :         goto error;
; 4493 :     if (quo_is_neg) {

  000c3	45 85 ed	 test	 r13d, r13d
  000c6	74 1f		 je	 SHORT $LN22@PyLong_Div

; 4494 :         temp = long_neg((PyLongObject*)twice_rem);

  000c8	48 8b c8	 mov	 rcx, rax
  000cb	e8 00 00 00 00	 call	 long_neg

; 4495 :         Py_DECREF(twice_rem);

  000d0	49 8b ce	 mov	 rcx, r14
  000d3	48 8b d8	 mov	 rbx, rax
  000d6	e8 00 00 00 00	 call	 _Py_DecRef

; 4496 :         twice_rem = temp;

  000db	4c 8b f3	 mov	 r14, rbx

; 4497 :         if (twice_rem == NULL)

  000de	48 85 db	 test	 rbx, rbx
  000e1	0f 84 ef 00 00
	00		 je	 $LN35@PyLong_Div
$LN22@PyLong_Div:

; 4498 :             goto error;
; 4499 :     }
; 4500 :     cmp = long_compare((PyLongObject *)twice_rem, (PyLongObject *)b);

  000e7	48 8b d5	 mov	 rdx, rbp
  000ea	49 8b ce	 mov	 rcx, r14
  000ed	e8 00 00 00 00	 call	 long_compare

; 4501 :     Py_DECREF(twice_rem);

  000f2	49 8b ce	 mov	 rcx, r14
  000f5	44 8b f8	 mov	 r15d, eax
  000f8	e8 00 00 00 00	 call	 _Py_DecRef

; 4502 : 
; 4503 :     quo_is_odd = Py_SIZE(quo) != 0 && ((quo->ob_digit[0] & 1) != 0);

  000fd	48 8b 5c 24 60	 mov	 rbx, QWORD PTR quo$[rsp]
  00102	48 39 73 60	 cmp	 QWORD PTR [rbx+96], rsi
  00106	74 0b		 je	 SHORT $LN31@PyLong_Div
  00108	f6 43 70 01	 test	 BYTE PTR [rbx+112], 1
  0010c	b8 01 00 00 00	 mov	 eax, 1
  00111	75 02		 jne	 SHORT $LN32@PyLong_Div
$LN31@PyLong_Div:
  00113	8b c6		 mov	 eax, esi
$LN32@PyLong_Div:

; 4504 :     if ((Py_SIZE(b) < 0 ? cmp < 0 : cmp > 0) || (cmp == 0 && quo_is_odd)) {

  00115	48 39 75 60	 cmp	 QWORD PTR [rbp+96], rsi
  00119	7d 09		 jge	 SHORT $LN33@PyLong_Div
  0011b	45 85 ff	 test	 r15d, r15d
  0011e	40 0f 98 c6	 sets	 sil
  00122	eb 07		 jmp	 SHORT $LN34@PyLong_Div
$LN33@PyLong_Div:
  00124	45 85 ff	 test	 r15d, r15d
  00127	40 0f 9f c6	 setg	 sil
$LN34@PyLong_Div:
  0012b	85 f6		 test	 esi, esi
  0012d	75 09		 jne	 SHORT $LN20@PyLong_Div
  0012f	45 85 ff	 test	 r15d, r15d
  00132	75 5c		 jne	 SHORT $LN14@PyLong_Div
  00134	85 c0		 test	 eax, eax
  00136	74 58		 je	 SHORT $LN14@PyLong_Div
$LN20@PyLong_Div:

; 4505 :         /* fix up quotient */
; 4506 :         if (quo_is_neg)
; 4507 :             temp = long_sub(quo, (PyLongObject *)one);

  00138	49 8b d4	 mov	 rdx, r12
  0013b	48 8b cb	 mov	 rcx, rbx
  0013e	45 85 ed	 test	 r13d, r13d
  00141	74 07		 je	 SHORT $LN19@PyLong_Div
  00143	e8 00 00 00 00	 call	 long_sub

; 4508 :         else

  00148	eb 05		 jmp	 SHORT $LN42@PyLong_Div
$LN19@PyLong_Div:

; 4509 :             temp = long_add(quo, (PyLongObject *)one);

  0014a	e8 00 00 00 00	 call	 long_add
$LN42@PyLong_Div:

; 4510 :         Py_DECREF(quo);

  0014f	48 8b cb	 mov	 rcx, rbx
  00152	48 8b f0	 mov	 rsi, rax
  00155	e8 00 00 00 00	 call	 _Py_DecRef

; 4511 :         quo = (PyLongObject *)temp;

  0015a	48 8b de	 mov	 rbx, rsi

; 4512 :         if (quo == NULL)

  0015d	48 85 f6	 test	 rsi, rsi
  00160	0f 84 82 00 00
	00		 je	 $LN11@PyLong_Div

; 4513 :             goto error;
; 4514 :         /* and remainder */
; 4515 :         if (quo_is_neg)
; 4516 :             temp = long_add(rem, (PyLongObject *)b);

  00166	48 8b d5	 mov	 rdx, rbp
  00169	48 8b cf	 mov	 rcx, rdi
  0016c	45 85 ed	 test	 r13d, r13d
  0016f	74 07		 je	 SHORT $LN16@PyLong_Div
  00171	e8 00 00 00 00	 call	 long_add

; 4517 :         else

  00176	eb 05		 jmp	 SHORT $LN43@PyLong_Div
$LN16@PyLong_Div:

; 4518 :             temp = long_sub(rem, (PyLongObject *)b);

  00178	e8 00 00 00 00	 call	 long_sub
$LN43@PyLong_Div:

; 4519 :         Py_DECREF(rem);

  0017d	48 8b cf	 mov	 rcx, rdi
  00180	48 8b f0	 mov	 rsi, rax
  00183	e8 00 00 00 00	 call	 _Py_DecRef

; 4520 :         rem = (PyLongObject *)temp;

  00188	48 8b fe	 mov	 rdi, rsi

; 4521 :         if (rem == NULL)

  0018b	48 85 f6	 test	 rsi, rsi
  0018e	74 4b		 je	 SHORT $error$23904
$LN14@PyLong_Div:

; 4522 :             goto error;
; 4523 :     }
; 4524 : 
; 4525 :     result = PyTuple_New(2);

  00190	b9 02 00 00 00	 mov	 ecx, 2
  00195	e8 00 00 00 00	 call	 PyTuple_New
  0019a	48 8b f0	 mov	 rsi, rax

; 4526 :     if (result == NULL)

  0019d	48 85 c0	 test	 rax, rax
  001a0	74 39		 je	 SHORT $error$23904

; 4527 :         goto error;
; 4528 : 
; 4529 :     /* PyTuple_SET_ITEM steals references */
; 4530 :     PyTuple_SET_ITEM(result, 0, (PyObject *)quo);
; 4531 :     PyTuple_SET_ITEM(result, 1, (PyObject *)rem);
; 4532 :     Py_DECREF(one);

  001a2	49 8b cc	 mov	 rcx, r12
  001a5	48 89 58 70	 mov	 QWORD PTR [rax+112], rbx
  001a9	48 89 78 78	 mov	 QWORD PTR [rax+120], rdi
  001ad	e8 00 00 00 00	 call	 _Py_DecRef

; 4533 :     return result;

  001b2	48 8b c6	 mov	 rax, rsi
$LN41@PyLong_Div:
  001b5	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]
  001ba	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  001bf	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
$LN38@PyLong_Div:
  001c4	4c 8b 64 24 38	 mov	 r12, QWORD PTR [rsp+56]
  001c9	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]

; 4540 : }

  001ce	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001d2	5e		 pop	 rsi
  001d3	5d		 pop	 rbp
  001d4	5b		 pop	 rbx
  001d5	c3		 ret	 0
$LN35@PyLong_Div:

; 4526 :     if (result == NULL)

  001d6	48 8b 5c 24 60	 mov	 rbx, QWORD PTR quo$[rsp]
$error$23904:

; 4534 : 
; 4535 :   error:
; 4536 :     Py_XDECREF(quo);

  001db	48 85 db	 test	 rbx, rbx
  001de	74 08		 je	 SHORT $LN11@PyLong_Div
  001e0	48 8b cb	 mov	 rcx, rbx
  001e3	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@PyLong_Div:

; 4537 :     Py_XDECREF(rem);

  001e8	48 85 ff	 test	 rdi, rdi
  001eb	74 08		 je	 SHORT $LN7@PyLong_Div
  001ed	48 8b cf	 mov	 rcx, rdi
  001f0	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@PyLong_Div:

; 4538 :     Py_XDECREF(one);

  001f5	49 8b cc	 mov	 rcx, r12
  001f8	e8 00 00 00 00	 call	 _Py_DecRef

; 4539 :     return NULL;

  001fd	33 c0		 xor	 eax, eax
  001ff	eb b4		 jmp	 SHORT $LN41@PyLong_Div
$LN27@PyLong_Div:

; 4473 :         PyErr_SetString(PyExc_TypeError,
; 4474 :                         "non-integer arguments in division");

  00201	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00208	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@NJOBDKOI@non?9integer?5arguments?5in?5divisio@
  0020f	e8 00 00 00 00	 call	 PyErr_SetString

; 4475 :         return NULL;

  00214	33 c0		 xor	 eax, eax

; 4540 : }

  00216	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0021a	5e		 pop	 rsi
  0021b	5d		 pop	 rbp
  0021c	5b		 pop	 rbx
  0021d	c3		 ret	 0
_PyLong_DivmodNear ENDP
_TEXT	ENDS
PUBLIC	??_C@_02CKLEOEBD@?$HMO?$AA@			; `string'
EXTRN	PyNumber_Index:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_round DD imagerel long_round
	DD	imagerel long_round+77
	DD	imagerel $unwind$long_round
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$long_round DD imagerel long_round+77
	DD	imagerel long_round+106
	DD	imagerel $chain$0$long_round
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$long_round DD imagerel long_round+106
	DD	imagerel long_round+140
	DD	imagerel $chain$2$long_round
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$long_round DD imagerel long_round+140
	DD	imagerel long_round+210
	DD	imagerel $chain$5$long_round
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$long_round DD imagerel long_round+210
	DD	imagerel long_round+335
	DD	imagerel $chain$8$long_round
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$long_round DD 061221H
	DD	075412H
	DD	096400H
	DD	063400H
	DD	imagerel long_round
	DD	imagerel long_round+77
	DD	imagerel $unwind$long_round
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$long_round DD 040521H
	DD	096405H
	DD	063400H
	DD	imagerel long_round
	DD	imagerel long_round+77
	DD	imagerel $unwind$long_round
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$long_round DD 020021H
	DD	063400H
	DD	imagerel long_round
	DD	imagerel long_round+77
	DD	imagerel $unwind$long_round
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$long_round DD 020521H
	DD	063405H
	DD	imagerel long_round
	DD	imagerel long_round+77
	DD	imagerel $unwind$long_round
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_round DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT ??_C@_02CKLEOEBD@?$HMO?$AA@
CONST	SEGMENT
??_C@_02CKLEOEBD@?$HMO?$AA@ DB '|O', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT long_round
_TEXT	SEGMENT
self$ = 48
args$ = 56
o_ndigits$ = 64
long_round PROC						; COMDAT

; 4544 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b f9	 mov	 rdi, rcx

; 4545 :     PyObject *o_ndigits=NULL, *temp, *result, *ndigits;
; 4546 : 
; 4547 :     /* To round an integer m to the nearest 10**n (n positive), we make use of
; 4548 :      * the divmod_near operation, defined by:
; 4549 :      *
; 4550 :      *   divmod_near(a, b) = (q, r)
; 4551 :      *
; 4552 :      * where q is the nearest integer to the quotient a / b (the
; 4553 :      * nearest even integer in the case of a tie) and r == a - q * b.
; 4554 :      * Hence q * b = a - r is the nearest multiple of b to a,
; 4555 :      * preferring even multiples in the case of a tie.
; 4556 :      *
; 4557 :      * So the nearest multiple of 10**n to m is:
; 4558 :      *
; 4559 :      *   m - divmod_near(m, 10**n)[1].
; 4560 :      */
; 4561 :     if (!PyArg_ParseTuple(args, "|O", &o_ndigits))

  0000c	4c 8d 44 24 40	 lea	 r8, QWORD PTR o_ndigits$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02CKLEOEBD@?$HMO?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR o_ndigits$[rsp], 0
  00024	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00029	85 c0		 test	 eax, eax
  0002b	75 08		 jne	 SHORT $LN8@long_round

; 4562 :         return NULL;

  0002d	33 c0		 xor	 eax, eax

; 4608 : }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	c3		 ret	 0
$LN8@long_round:

; 4563 :     if (o_ndigits == NULL)

  00035	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o_ndigits$[rsp]
  0003a	48 85 c9	 test	 rcx, rcx
  0003d	75 0e		 jne	 SHORT $LN7@long_round

; 4564 :         return long_long(self);

  0003f	48 8b cf	 mov	 rcx, rdi
  00042	e8 00 00 00 00	 call	 long_long

; 4608 : }

  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
$LN7@long_round:
  0004d	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 4565 : 
; 4566 :     ndigits = PyNumber_Index(o_ndigits);

  00052	e8 00 00 00 00	 call	 PyNumber_Index
  00057	48 8b d8	 mov	 rbx, rax

; 4567 :     if (ndigits == NULL)

  0005a	48 85 c0	 test	 rax, rax
  0005d	75 0b		 jne	 SHORT $LN6@long_round
  0005f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 4608 : }

  00064	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00068	5f		 pop	 rdi
  00069	c3		 ret	 0
$LN6@long_round:

; 4568 :         return NULL;
; 4569 : 
; 4570 :     /* if ndigits >= 0 then no rounding is necessary; return self unchanged */
; 4571 :     if (Py_SIZE(ndigits) >= 0) {

  0006a	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0

; 4572 :         Py_DECREF(ndigits);

  0006f	48 8b c8	 mov	 rcx, rax
  00072	7c 18		 jl	 SHORT $LN5@long_round
  00074	e8 00 00 00 00	 call	 _Py_DecRef

; 4573 :         return long_long(self);

  00079	48 8b cf	 mov	 rcx, rdi
  0007c	e8 00 00 00 00	 call	 long_long
  00081	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 4608 : }

  00086	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008a	5f		 pop	 rdi
  0008b	c3		 ret	 0
$LN5@long_round:
  0008c	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi

; 4574 :     }
; 4575 : 
; 4576 :     /* result = self - divmod_near(self, 10 ** -ndigits)[1] */
; 4577 :     temp = long_neg((PyLongObject*)ndigits);

  00091	e8 00 00 00 00	 call	 long_neg

; 4578 :     Py_DECREF(ndigits);

  00096	48 8b cb	 mov	 rcx, rbx
  00099	48 8b f0	 mov	 rsi, rax
  0009c	e8 00 00 00 00	 call	 _Py_DecRef

; 4579 :     ndigits = temp;
; 4580 :     if (ndigits == NULL)

  000a1	48 85 f6	 test	 rsi, rsi

; 4581 :         return NULL;

  000a4	74 1a		 je	 SHORT $LN15@long_round

; 4582 : 
; 4583 :     result = PyLong_FromLong(10L);

  000a6	b9 0a 00 00 00	 mov	 ecx, 10
  000ab	e8 00 00 00 00	 call	 PyLong_FromLong
  000b0	48 8b d8	 mov	 rbx, rax

; 4584 :     if (result == NULL) {

  000b3	48 85 c0	 test	 rax, rax
  000b6	75 1a		 jne	 SHORT $LN3@long_round

; 4585 :         Py_DECREF(ndigits);

  000b8	48 8b ce	 mov	 rcx, rsi
  000bb	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@long_round:

; 4586 :         return NULL;

  000c0	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000c5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ca	33 c0		 xor	 eax, eax

; 4608 : }

  000cc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d0	5f		 pop	 rdi
  000d1	c3		 ret	 0
$LN3@long_round:

; 4587 :     }
; 4588 : 
; 4589 :     temp = long_pow(result, ndigits, Py_None);

  000d2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  000d9	48 8b d6	 mov	 rdx, rsi
  000dc	48 8b c8	 mov	 rcx, rax
  000df	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  000e4	e8 00 00 00 00	 call	 long_pow

; 4590 :     Py_DECREF(ndigits);

  000e9	48 8b ce	 mov	 rcx, rsi
  000ec	48 8b e8	 mov	 rbp, rax
  000ef	e8 00 00 00 00	 call	 _Py_DecRef

; 4591 :     Py_DECREF(result);

  000f4	48 8b cb	 mov	 rcx, rbx
  000f7	e8 00 00 00 00	 call	 _Py_DecRef

; 4592 :     result = temp;
; 4593 :     if (result == NULL)

  000fc	48 85 ed	 test	 rbp, rbp

; 4594 :         return NULL;

  000ff	74 1b		 je	 SHORT $LN14@long_round

; 4595 : 
; 4596 :     temp = _PyLong_DivmodNear(self, result);

  00101	48 8b d5	 mov	 rdx, rbp
  00104	48 8b cf	 mov	 rcx, rdi
  00107	e8 00 00 00 00	 call	 _PyLong_DivmodNear

; 4597 :     Py_DECREF(result);

  0010c	48 8b cd	 mov	 rcx, rbp
  0010f	48 8b f0	 mov	 rsi, rax
  00112	e8 00 00 00 00	 call	 _Py_DecRef

; 4598 :     result = temp;
; 4599 :     if (result == NULL)

  00117	48 85 f6	 test	 rsi, rsi
  0011a	75 04		 jne	 SHORT $LN1@long_round
$LN14@long_round:

; 4600 :         return NULL;

  0011c	33 c0		 xor	 eax, eax
  0011e	eb 1a		 jmp	 SHORT $LN13@long_round
$LN1@long_round:

; 4601 : 
; 4602 :     temp = long_sub((PyLongObject *)self,
; 4603 :                     (PyLongObject *)PyTuple_GET_ITEM(result, 1));

  00120	48 8b 56 78	 mov	 rdx, QWORD PTR [rsi+120]
  00124	48 8b cf	 mov	 rcx, rdi
  00127	e8 00 00 00 00	 call	 long_sub

; 4604 :     Py_DECREF(result);

  0012c	48 8b ce	 mov	 rcx, rsi
  0012f	48 8b d8	 mov	 rbx, rax
  00132	e8 00 00 00 00	 call	 _Py_DecRef

; 4605 :     result = temp;
; 4606 : 
; 4607 :     return result;

  00137	48 8b c3	 mov	 rax, rbx
$LN13@long_round:
  0013a	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0013f	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00144	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 4608 : }

  00149	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0014d	5f		 pop	 rdi
  0014e	c3		 ret	 0
long_round ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$long_bit_length DD imagerel long_bit_length
	DD	imagerel long_bit_length+112
	DD	imagerel $unwind$long_bit_length
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$long_bit_length DD imagerel long_bit_length+112
	DD	imagerel long_bit_length+141
	DD	imagerel $chain$0$long_bit_length
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$long_bit_length DD imagerel long_bit_length+141
	DD	imagerel long_bit_length+293
	DD	imagerel $chain$4$long_bit_length
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$long_bit_length DD 060f21H
	DD	07640fH
	DD	06540aH
	DD	087400H
	DD	imagerel long_bit_length
	DD	imagerel long_bit_length+112
	DD	imagerel $unwind$long_bit_length
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$long_bit_length DD 020521H
	DD	087405H
	DD	imagerel long_bit_length
	DD	imagerel long_bit_length+112
	DD	imagerel $unwind$long_bit_length
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$long_bit_length DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT long_bit_length
_TEXT	SEGMENT
v$ = 48
long_bit_length PROC					; COMDAT

; 4621 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c1	 mov	 rax, rcx

; 4622 :     PyLongObject *result, *x, *y;
; 4623 :     Py_ssize_t ndigits, msd_bits = 0;
; 4624 :     digit msd;
; 4625 : 
; 4626 :     assert(v != NULL);
; 4627 :     assert(PyLong_Check(v));
; 4628 : 
; 4629 :     ndigits = ABS(Py_SIZE(v));

  00009	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0000d	33 db		 xor	 ebx, ebx
  0000f	48 85 c9	 test	 rcx, rcx
  00012	79 06		 jns	 SHORT $LN19@long_bit_l
  00014	48 f7 d9	 neg	 rcx

; 4630 :     if (ndigits == 0)

  00017	48 85 c9	 test	 rcx, rcx
$LN19@long_bit_l:
  0001a	75 0c		 jne	 SHORT $LN9@long_bit_l

; 4631 :         return PyLong_FromLong(0);

  0001c	33 c9		 xor	 ecx, ecx

; 4672 : }

  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5b		 pop	 rbx
  00023	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN9@long_bit_l:

; 4632 : 
; 4633 :     msd = v->ob_digit[ndigits-1];

  00028	8b 44 88 6c	 mov	 eax, DWORD PTR [rax+rcx*4+108]

; 4634 :     while (msd >= 32) {

  0002c	83 f8 20	 cmp	 eax, 32			; 00000020H
  0002f	72 0c		 jb	 SHORT $LN7@long_bit_l
$LL8@long_bit_l:

; 4635 :         msd_bits += 6;
; 4636 :         msd >>= 6;

  00031	c1 e8 06	 shr	 eax, 6
  00034	48 83 c3 06	 add	 rbx, 6
  00038	83 f8 20	 cmp	 eax, 32			; 00000020H
  0003b	73 f4		 jae	 SHORT $LL8@long_bit_l
$LN7@long_bit_l:

; 4637 :     }
; 4638 :     msd_bits += (long)(BitLengthTable[msd]);

  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:BitLengthTable
  00044	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  00048	48 03 d8	 add	 rbx, rax

; 4639 : 
; 4640 :     if (ndigits <= PY_SSIZE_T_MAX/PyLong_SHIFT)

  0004b	48 b8 44 44 44
	44 44 44 44 04	 mov	 rax, 307445734561825860	; 0444444444444444H
  00055	48 3b c8	 cmp	 rcx, rax
  00058	7f 13		 jg	 SHORT $LN6@long_bit_l

; 4641 :         return PyLong_FromSsize_t((ndigits-1)*PyLong_SHIFT + msd_bits);

  0005a	48 6b c9 1e	 imul	 rcx, 30
  0005e	48 8d 4c 19 e2	 lea	 rcx, QWORD PTR [rcx+rbx-30]

; 4672 : }

  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5b		 pop	 rbx
  00068	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
$LN6@long_bit_l:

; 4642 : 
; 4643 :     /* expression above may overflow; use Python integers instead */
; 4644 :     result = (PyLongObject *)PyLong_FromSsize_t(ndigits - 1);

  0006d	48 ff c9	 dec	 rcx
  00070	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00075	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  0007a	48 8b f8	 mov	 rdi, rax

; 4645 :     if (result == NULL)

  0007d	48 85 c0	 test	 rax, rax
  00080	75 0b		 jne	 SHORT $LN5@long_bit_l
  00082	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 4672 : }

  00087	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008b	5b		 pop	 rbx
  0008c	c3		 ret	 0
$LN5@long_bit_l:

; 4646 :         return NULL;
; 4647 :     x = (PyLongObject *)PyLong_FromLong(PyLong_SHIFT);

  0008d	b9 1e 00 00 00	 mov	 ecx, 30
  00092	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00097	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0009c	e8 00 00 00 00	 call	 PyLong_FromLong
  000a1	48 8b f0	 mov	 rsi, rax

; 4648 :     if (x == NULL)

  000a4	48 85 c0	 test	 rax, rax
  000a7	74 5d		 je	 SHORT $error$24045

; 4649 :         goto error;
; 4650 :     y = (PyLongObject *)long_mul(result, x);

  000a9	48 8b d0	 mov	 rdx, rax
  000ac	48 8b cf	 mov	 rcx, rdi
  000af	e8 00 00 00 00	 call	 long_mul

; 4651 :     Py_DECREF(x);

  000b4	48 8b ce	 mov	 rcx, rsi
  000b7	48 8b e8	 mov	 rbp, rax
  000ba	e8 00 00 00 00	 call	 _Py_DecRef

; 4652 :     if (y == NULL)

  000bf	48 85 ed	 test	 rbp, rbp
  000c2	74 42		 je	 SHORT $error$24045

; 4653 :         goto error;
; 4654 :     Py_DECREF(result);

  000c4	48 8b cf	 mov	 rcx, rdi
  000c7	e8 00 00 00 00	 call	 _Py_DecRef

; 4655 :     result = y;
; 4656 : 
; 4657 :     x = (PyLongObject *)PyLong_FromLong((long)msd_bits);

  000cc	8b cb		 mov	 ecx, ebx
  000ce	48 8b fd	 mov	 rdi, rbp
  000d1	e8 00 00 00 00	 call	 PyLong_FromLong
  000d6	48 8b f0	 mov	 rsi, rax

; 4658 :     if (x == NULL)

  000d9	48 85 c0	 test	 rax, rax
  000dc	74 28		 je	 SHORT $error$24045

; 4659 :         goto error;
; 4660 :     y = (PyLongObject *)long_add(result, x);

  000de	48 8b d0	 mov	 rdx, rax
  000e1	48 8b cd	 mov	 rcx, rbp
  000e4	e8 00 00 00 00	 call	 long_add

; 4661 :     Py_DECREF(x);

  000e9	48 8b ce	 mov	 rcx, rsi
  000ec	48 8b d8	 mov	 rbx, rax
  000ef	e8 00 00 00 00	 call	 _Py_DecRef

; 4662 :     if (y == NULL)

  000f4	48 85 db	 test	 rbx, rbx
  000f7	74 0d		 je	 SHORT $error$24045

; 4663 :         goto error;
; 4664 :     Py_DECREF(result);

  000f9	48 8b cd	 mov	 rcx, rbp
  000fc	e8 00 00 00 00	 call	 _Py_DecRef

; 4665 :     result = y;
; 4666 : 
; 4667 :     return (PyObject *)result;

  00101	48 8b c3	 mov	 rax, rbx
  00104	eb 0a		 jmp	 SHORT $LN18@long_bit_l
$error$24045:

; 4668 : 
; 4669 :   error:
; 4670 :     Py_DECREF(result);

  00106	48 8b cf	 mov	 rcx, rdi
  00109	e8 00 00 00 00	 call	 _Py_DecRef

; 4671 :     return NULL;

  0010e	33 c0		 xor	 eax, eax
$LN18@long_bit_l:
  00110	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00115	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0011a	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 4672 : }

  0011f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00123	5b		 pop	 rbx
  00124	c3		 ret	 0
long_bit_length ENDP
_TEXT	ENDS
END
