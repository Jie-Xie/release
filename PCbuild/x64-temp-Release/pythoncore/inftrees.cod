; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	inflate_copyright
CONST	SEGMENT
inflate_copyright DB ' inflate 1.2.5 Copyright 1995-2010 Mark Adler ', 00H
	ORG $+1
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	049H
	DW	0c3H
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
CONST	ENDS
PUBLIC	inflate_table
;	COMDAT pdata
; File c:\src\pyparallel\modules\zlib\inftrees.c
pdata	SEGMENT
$pdata$inflate_table DD imagerel $LN136
	DD	imagerel $LN136+285
	DD	imagerel $unwind$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflate_table DD imagerel $LN136+285
	DD	imagerel $LN136+1119
	DD	imagerel $chain$0$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflate_table DD imagerel $LN136+1119
	DD	imagerel $LN136+1137
	DD	imagerel $chain$1$inflate_table
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflate_table DD 021H
	DD	imagerel $LN136
	DD	imagerel $LN136+285
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflate_table DD 020521H
	DD	0ff405H
	DD	imagerel $LN136
	DD	imagerel $LN136+285
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_table DD 082201H
	DD	0e018f222H
	DD	0c014d016H
	DD	060117012H
	DD	0500f3010H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflate_table
_TEXT	SEGMENT
end$1$ = 0
root$3$ = 4
sym$2$ = 8
used$1$ = 12
mask$1$ = 16
base$1$ = 24
extra$1$ = 32
count$ = 40
offs$ = 72
type$ = 192
lens$ = 200
here$ = 208
codes$ = 208
table$ = 216
bits$ = 224
work$ = 232
inflate_table PROC					; COMDAT

; 39   : {

$LN136:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	55		 push	 rbp
  0000f	53		 push	 rbx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 54		 push	 r12
  00014	41 55		 push	 r13
  00016	41 56		 push	 r14
  00018	48 8b ec	 mov	 rbp, rsp
  0001b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     int end;                    /* use base and extra for symbol > end */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 73, 195};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)
; 108  :         count[len] = 0;

  00022	45 33 e4	 xor	 r12d, r12d
  00025	8b f1		 mov	 esi, ecx
  00027	48 8d 7d a8	 lea	 rdi, QWORD PTR count$[rbp-128]
  0002b	b9 10 00 00 00	 mov	 ecx, 16
  00030	41 0f b7 c4	 movzx	 eax, r12w
  00034	4d 8b e9	 mov	 r13, r9
  00037	66 f3 ab	 rep stosw
  0003a	4c 8b ca	 mov	 r9, rdx

; 109  :     for (sym = 0; sym < codes; sym++)

  0003d	45 85 c0	 test	 r8d, r8d
  00040	74 1f		 je	 SHORT $LN63@inflate_ta
  00042	48 8b ca	 mov	 rcx, rdx
  00045	41 8b d0	 mov	 edx, r8d
  00048	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL65@inflate_ta:

; 110  :         count[lens[sym]]++;

  00050	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00053	48 83 c1 02	 add	 rcx, 2
  00057	66 ff 44 45 a8	 inc	 WORD PTR count$[rbp+rax*2-128]
  0005c	48 ff ca	 dec	 rdx
  0005f	75 ef		 jne	 SHORT $LL65@inflate_ta
$LN63@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  00061	48 8b 55 60	 mov	 rdx, QWORD PTR bits$[rbp-128]

; 114  :     for (max = MAXBITS; max >= 1; max--)

  00065	41 ba 0f 00 00
	00		 mov	 r10d, 15
  0006b	48 8d 45 c6	 lea	 rax, QWORD PTR count$[rbp-98]
  0006f	8b 1a		 mov	 ebx, DWORD PTR [rdx]
  00071	41 83 ce ff	 or	 r14d, -1		; ffffffffH
$LL62@inflate_ta:

; 115  :         if (count[max] != 0) break;

  00075	66 44 39 20	 cmp	 WORD PTR [rax], r12w
  00079	75 0d		 jne	 SHORT $LN85@inflate_ta

; 114  :     for (max = MAXBITS; max >= 1; max--)

  0007b	45 03 d6	 add	 r10d, r14d
  0007e	48 83 e8 02	 sub	 rax, 2
  00082	41 83 fa 01	 cmp	 r10d, 1
  00086	73 ed		 jae	 SHORT $LL62@inflate_ta
$LN85@inflate_ta:

; 116  :     if (root > max) root = max;

  00088	41 3b da	 cmp	 ebx, r10d
  0008b	41 0f 47 da	 cmova	 ebx, r10d

; 117  :     if (max == 0) {                     /* no symbols to code at all */

  0008f	45 85 d2	 test	 r10d, r10d
  00092	75 2d		 jne	 SHORT $LN57@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */
; 119  :         here.bits = (unsigned char)1;
; 120  :         here.val = (unsigned short)0;
; 121  :         *(*table)++ = here;             /* make a table to force an error */

  00094	49 8b 4d 00	 mov	 rcx, QWORD PTR [r13]
  00098	c7 45 50 40 01
	00 00		 mov	 DWORD PTR here$[rbp-128], 320 ; 00000140H
  0009f	8b 45 50	 mov	 eax, DWORD PTR here$[rbp-128]
  000a2	89 01		 mov	 DWORD PTR [rcx], eax
  000a4	49 83 45 00 04	 add	 QWORD PTR [r13], 4
  000a9	49 8b 4d 00	 mov	 rcx, QWORD PTR [r13]

; 122  :         *(*table)++ = here;

  000ad	89 01		 mov	 DWORD PTR [rcx], eax
  000af	49 83 45 00 04	 add	 QWORD PTR [r13], 4

; 123  :         *bits = 1;

  000b4	c7 02 01 00 00
	00		 mov	 DWORD PTR [rdx], 1

; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  000ba	33 c0		 xor	 eax, eax
  000bc	e9 9e 03 00 00	 jmp	 $LN69@inflate_ta
$LN57@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  000c1	41 bb 01 00 00
	00		 mov	 r11d, 1
  000c7	45 3b d3	 cmp	 r10d, r11d
  000ca	76 16		 jbe	 SHORT $LN119@inflate_ta
  000cc	48 8d 45 aa	 lea	 rax, QWORD PTR count$[rbp-126]
$LL56@inflate_ta:

; 127  :         if (count[min] != 0) break;

  000d0	66 44 39 20	 cmp	 WORD PTR [rax], r12w
  000d4	75 0c		 jne	 SHORT $LN119@inflate_ta

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  000d6	41 ff c3	 inc	 r11d
  000d9	48 83 c0 02	 add	 rax, 2
  000dd	45 3b da	 cmp	 r11d, r10d
  000e0	72 ee		 jb	 SHORT $LL56@inflate_ta
$LN119@inflate_ta:

; 128  :     if (root < min) root = min;

  000e2	41 3b db	 cmp	 ebx, r11d

; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  000e5	bf 01 00 00 00	 mov	 edi, 1
  000ea	41 0f 42 db	 cmovb	 ebx, r11d

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  000ee	8b d7		 mov	 edx, edi
  000f0	89 5d 84	 mov	 DWORD PTR root$3$[rbp-128], ebx
$LL51@inflate_ta:

; 133  :         left <<= 1;
; 134  :         left -= count[len];

  000f3	8b c2		 mov	 eax, edx
  000f5	03 ff		 add	 edi, edi
  000f7	0f b7 4c 45 a8	 movzx	 ecx, WORD PTR count$[rbp+rax*2-128]
  000fc	2b f9		 sub	 edi, ecx

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  000fe	78 15		 js	 SHORT $LN46@inflate_ta

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  00100	ff c2		 inc	 edx
  00102	83 fa 0f	 cmp	 edx, 15
  00105	76 ec		 jbe	 SHORT $LL51@inflate_ta

; 136  :     }
; 137  :     if (left > 0 && (type == CODES || max != 1))

  00107	85 ff		 test	 edi, edi
  00109	7e 12		 jle	 SHORT $LN47@inflate_ta
  0010b	85 f6		 test	 esi, esi
  0010d	74 06		 je	 SHORT $LN46@inflate_ta
  0010f	41 83 fa 01	 cmp	 r10d, 1
  00113	74 08		 je	 SHORT $LN47@inflate_ta
$LN46@inflate_ta:

; 138  :         return -1;                      /* incomplete set */

  00115	83 c8 ff	 or	 eax, -1
  00118	e9 42 03 00 00	 jmp	 $LN69@inflate_ta
$LN47@inflate_ta:
  0011d	4c 89 7c 24 78	 mov	 QWORD PTR [rsp+120], r15

; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  00122	66 44 89 65 ca	 mov	 WORD PTR offs$[rbp-126], r12w

; 142  :     for (len = 1; len < MAXBITS; len++)

  00127	49 8b cc	 mov	 rcx, r12
  0012a	ba 0e 00 00 00	 mov	 edx, 14
  0012f	90		 npad	 1
$LL45@inflate_ta:

; 143  :         offs[len + 1] = offs[len] + count[len];

  00130	0f b7 44 0d aa	 movzx	 eax, WORD PTR count$[rbp+rcx-126]
  00135	48 83 c1 02	 add	 rcx, 2
  00139	66 03 44 0d c8	 add	 ax, WORD PTR offs$[rbp+rcx-128]
  0013e	48 ff ca	 dec	 rdx
  00141	66 89 44 0d ca	 mov	 WORD PTR offs$[rbp+rcx-126], ax
  00146	75 e8		 jne	 SHORT $LL45@inflate_ta

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  00148	41 8b fc	 mov	 edi, r12d
  0014b	45 85 c0	 test	 r8d, r8d
  0014e	74 2d		 je	 SHORT $LN40@inflate_ta
  00150	49 8b d1	 mov	 rdx, r9
  00153	4c 8b 4d 68	 mov	 r9, QWORD PTR work$[rbp-128]
$LL42@inflate_ta:

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  00157	66 44 39 22	 cmp	 WORD PTR [rdx], r12w
  0015b	74 15		 je	 SHORT $LN41@inflate_ta
  0015d	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  00160	0f b7 4c 45 c8	 movzx	 ecx, WORD PTR offs$[rbp+rax*2-128]
  00165	66 41 89 3c 49	 mov	 WORD PTR [r9+rcx*2], di
  0016a	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  0016d	66 ff 44 45 c8	 inc	 WORD PTR offs$[rbp+rax*2-128]
$LN41@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  00172	ff c7		 inc	 edi
  00174	48 83 c2 02	 add	 rdx, 2
  00178	41 3b f8	 cmp	 edi, r8d
  0017b	72 da		 jb	 SHORT $LL42@inflate_ta
$LN40@inflate_ta:

; 195  :         extra = dext;
; 196  :         end = -1;

  0017d	4c 8b 45 68	 mov	 r8, QWORD PTR work$[rbp-128]
  00181	8b ce		 mov	 ecx, esi
  00183	85 f6		 test	 esi, esi
  00185	74 48		 je	 SHORT $LN36@inflate_ta

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  00187	ff c9		 dec	 ecx
  00189	74 1b		 je	 SHORT $LN35@inflate_ta

; 193  :     default:            /* DISTS */
; 194  :         base = dbase;

  0018b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dbase@?1??inflate_table@@9@9

; 195  :         extra = dext;
; 196  :         end = -1;

  00192	83 ca ff	 or	 edx, -1
  00195	48 89 45 98	 mov	 QWORD PTR base$1$[rbp-128], rax
  00199	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dext@?1??inflate_table@@9@9
  001a0	48 89 45 a0	 mov	 QWORD PTR extra$1$[rbp-128], rax
  001a4	eb 36		 jmp	 SHORT $LN132@inflate_ta
$LN35@inflate_ta:

; 185  :         break;
; 186  :     case LENS:
; 187  :         base = lbase;
; 188  :         base -= 257;

  001a6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lbase@?1??inflate_table@@9@9

; 189  :         extra = lext;
; 190  :         extra -= 257;
; 191  :         end = 256;

  001ad	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  001b2	48 2d 02 02 00
	00		 sub	 rax, 514		; 00000202H
  001b8	48 89 45 98	 mov	 QWORD PTR base$1$[rbp-128], rax
  001bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lext@?1??inflate_table@@9@9
  001c3	48 2d 02 02 00
	00		 sub	 rax, 514		; 00000202H
  001c9	48 89 45 a0	 mov	 QWORD PTR extra$1$[rbp-128], rax

; 192  :         break;

  001cd	eb 0d		 jmp	 SHORT $LN132@inflate_ta
$LN36@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  001cf	4c 89 45 a0	 mov	 QWORD PTR extra$1$[rbp-128], r8
  001d3	4c 89 45 98	 mov	 QWORD PTR base$1$[rbp-128], r8

; 184  :         end = 19;

  001d7	ba 13 00 00 00	 mov	 edx, 19
$LN132@inflate_ta:

; 197  :     }
; 198  : 
; 199  :     /* initialize state for loop */
; 200  :     huff = 0;                   /* starting code */
; 201  :     sym = 0;                    /* starting code symbol */
; 202  :     len = min;                  /* starting code length */
; 203  :     next = *table;              /* current table to fill in */

  001dc	4d 8b 7d 00	 mov	 r15, QWORD PTR [r13]

; 204  :     curr = root;                /* current table index bits */
; 205  :     drop = 0;                   /* current bits to drop from code for index */
; 206  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */
; 207  :     used = 1U << root;          /* use root table entries */

  001e0	8b cb		 mov	 ecx, ebx
  001e2	be 01 00 00 00	 mov	 esi, 1
  001e7	d3 e6		 shl	 esi, cl
  001e9	89 55 80	 mov	 DWORD PTR end$1$[rbp-128], edx
  001ec	41 8b fc	 mov	 edi, r12d

; 208  :     mask = used - 1;            /* mask for comparing low */

  001ef	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  001f2	45 8b cc	 mov	 r9d, r12d
  001f5	44 89 65 88	 mov	 DWORD PTR sym$2$[rbp-128], r12d
  001f9	89 45 90	 mov	 DWORD PTR mask$1$[rbp-128], eax

; 209  : 
; 210  :     /* check available table space */
; 211  :     if ((type == LENS && used >= ENOUGH_LENS) ||
; 212  :         (type == DISTS && used >= ENOUGH_DISTS))

  001fc	8b 45 40	 mov	 eax, DWORD PTR type$[rbp-128]
  001ff	89 75 8c	 mov	 DWORD PTR used$1$[rbp-128], esi
  00202	83 f8 01	 cmp	 eax, 1
  00205	75 0a		 jne	 SHORT $LN31@inflate_ta
  00207	81 fe 54 03 00
	00		 cmp	 esi, 852		; 00000354H
  0020d	73 0f		 jae	 SHORT $LN32@inflate_ta
  0020f	eb 22		 jmp	 SHORT $LL30@inflate_ta
$LN31@inflate_ta:
  00211	83 f8 02	 cmp	 eax, 2
  00214	75 1d		 jne	 SHORT $LL30@inflate_ta
  00216	81 fe 50 02 00
	00		 cmp	 esi, 592		; 00000250H
  0021c	72 15		 jb	 SHORT $LL30@inflate_ta
$LN32@inflate_ta:

; 213  :         return 1;

  0021e	b8 01 00 00 00	 mov	 eax, 1
  00223	e9 32 02 00 00	 jmp	 $LN131@inflate_ta
  00228	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL122@inflate_ta:

; 287  :             (*table)[low].bits = (unsigned char)root;

  00230	8b 5d 84	 mov	 ebx, DWORD PTR root$3$[rbp-128]
$LL30@inflate_ta:

; 214  : 
; 215  :     /* process all codes and make table entries */
; 216  :     for (;;) {
; 217  :         /* create table entry */
; 218  :         here.bits = (unsigned char)(len - drop);

  00233	41 0f b6 c3	 movzx	 eax, r11b

; 219  :         if ((int)(work[sym]) < end) {

  00237	41 8b c9	 mov	 ecx, r9d
  0023a	41 2a c4	 sub	 al, r12b
  0023d	88 45 51	 mov	 BYTE PTR here$[rbp-127], al
  00240	41 0f b7 04 48	 movzx	 eax, WORD PTR [r8+rcx*2]
  00245	3b c2		 cmp	 eax, edx
  00247	7d 06		 jge	 SHORT $LN133@inflate_ta

; 220  :             here.op = (unsigned char)0;

  00249	c6 45 50 00	 mov	 BYTE PTR here$[rbp-128], 0

; 221  :             here.val = work[sym];

  0024d	eb 22		 jmp	 SHORT $LN134@inflate_ta
$LN133@inflate_ta:

; 222  :         }
; 223  :         else if ((int)(work[sym]) > end) {

  0024f	7e 1a		 jle	 SHORT $LN26@inflate_ta

; 224  :             here.op = (unsigned char)(extra[work[sym]]);

  00251	41 0f b7 0c 48	 movzx	 ecx, WORD PTR [r8+rcx*2]
  00256	48 8b 45 a0	 mov	 rax, QWORD PTR extra$1$[rbp-128]
  0025a	0f b6 04 48	 movzx	 eax, BYTE PTR [rax+rcx*2]
  0025e	88 45 50	 mov	 BYTE PTR here$[rbp-128], al

; 225  :             here.val = base[work[sym]];

  00261	48 8b 45 98	 mov	 rax, QWORD PTR base$1$[rbp-128]
  00265	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]

; 226  :         }
; 227  :         else {

  00269	eb 06		 jmp	 SHORT $LN134@inflate_ta
$LN26@inflate_ta:

; 228  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  0026b	c6 45 50 60	 mov	 BYTE PTR here$[rbp-128], 96 ; 00000060H

; 229  :             here.val = 0;

  0026f	33 c0		 xor	 eax, eax
$LN134@inflate_ta:

; 230  :         }
; 231  : 
; 232  :         /* replicate for those indices with low len bits equal to huff */
; 233  :         incr = 1U << (len - drop);

  00271	41 8b cb	 mov	 ecx, r11d
  00274	41 b9 01 00 00
	00		 mov	 r9d, 1
  0027a	8b d7		 mov	 edx, edi
  0027c	41 2b cc	 sub	 ecx, r12d
  0027f	66 89 45 52	 mov	 WORD PTR here$[rbp-126], ax
  00283	8b 45 50	 mov	 eax, DWORD PTR here$[rbp-128]
  00286	41 d3 e1	 shl	 r9d, cl
  00289	41 8b cc	 mov	 ecx, r12d

; 234  :         fill = 1U << curr;

  0028c	44 8b c6	 mov	 r8d, esi
  0028f	d3 ea		 shr	 edx, cl
  00291	03 d6		 add	 edx, esi
$LL24@inflate_ta:

; 235  :         min = fill;                 /* save offset to next table */
; 236  :         do {
; 237  :             fill -= incr;

  00293	41 2b d1	 sub	 edx, r9d
  00296	45 2b c1	 sub	 r8d, r9d

; 238  :             next[(huff >> drop) + fill] = here;

  00299	41 89 04 97	 mov	 DWORD PTR [r15+rdx*4], eax

; 239  :         } while (fill != 0);

  0029d	75 f4		 jne	 SHORT $LL24@inflate_ta

; 240  : 
; 241  :         /* backwards increment the len-bit code huff */
; 242  :         incr = 1U << (len - 1);

  0029f	41 8d 4b ff	 lea	 ecx, DWORD PTR [r11-1]
  002a3	ba 01 00 00 00	 mov	 edx, 1
  002a8	d3 e2		 shl	 edx, cl

; 243  :         while (huff & incr)

  002aa	85 d7		 test	 edx, edi
  002ac	74 08		 je	 SHORT $LN20@inflate_ta
  002ae	66 90		 npad	 2
$LL21@inflate_ta:

; 244  :             incr >>= 1;

  002b0	d1 ea		 shr	 edx, 1
  002b2	85 d7		 test	 edx, edi
  002b4	75 fa		 jne	 SHORT $LL21@inflate_ta
$LN20@inflate_ta:

; 245  :         if (incr != 0) {

  002b6	85 d2		 test	 edx, edx
  002b8	74 0c		 je	 SHORT $LN19@inflate_ta

; 246  :             huff &= incr - 1;

  002ba	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  002bd	23 c7		 and	 eax, edi

; 247  :             huff += incr;
; 248  :         }
; 249  :         else

  002bf	33 c9		 xor	 ecx, ecx
  002c1	8d 3c 02	 lea	 edi, DWORD PTR [rdx+rax]
  002c4	eb 04		 jmp	 SHORT $LN18@inflate_ta
$LN19@inflate_ta:

; 250  :             huff = 0;

  002c6	33 c9		 xor	 ecx, ecx
  002c8	8b f9		 mov	 edi, ecx
$LN18@inflate_ta:

; 251  : 
; 252  :         /* go to next symbol, update count, len */
; 253  :         sym++;

  002ca	44 8b 4d 88	 mov	 r9d, DWORD PTR sym$2$[rbp-128]

; 254  :         if (--(count[len]) == 0) {

  002ce	41 8b c3	 mov	 eax, r11d
  002d1	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  002d6	41 ff c1	 inc	 r9d
  002d9	66 01 54 45 a8	 add	 WORD PTR count$[rbp+rax*2-128], dx
  002de	44 89 4d 88	 mov	 DWORD PTR sym$2$[rbp-128], r9d
  002e2	75 1d		 jne	 SHORT $LN123@inflate_ta

; 255  :             if (len == max) break;

  002e4	45 3b da	 cmp	 r11d, r10d
  002e7	0f 84 e4 00 00
	00		 je	 $LN89@inflate_ta

; 256  :             len = lens[work[sym]];

  002ed	4c 8b 45 68	 mov	 r8, QWORD PTR work$[rbp-128]
  002f1	48 8b 45 48	 mov	 rax, QWORD PTR lens$[rbp-128]
  002f5	43 0f b7 0c 48	 movzx	 ecx, WORD PTR [r8+r9*2]
  002fa	44 0f b7 1c 48	 movzx	 r11d, WORD PTR [rax+rcx*2]
  002ff	eb 04		 jmp	 SHORT $LN17@inflate_ta
$LN123@inflate_ta:

; 288  :             (*table)[low].val = (unsigned short)(next - *table);
; 289  :         }
; 290  :     }

  00301	4c 8b 45 68	 mov	 r8, QWORD PTR work$[rbp-128]
$LN17@inflate_ta:

; 257  :         }
; 258  : 
; 259  :         /* create new sub-table if needed */
; 260  :         if (len > root && (huff & mask) != low) {

  00305	8b 55 80	 mov	 edx, DWORD PTR end$1$[rbp-128]
  00308	44 3b db	 cmp	 r11d, ebx
  0030b	0f 86 22 ff ff
	ff		 jbe	 $LL30@inflate_ta
  00311	8b 5d 90	 mov	 ebx, DWORD PTR mask$1$[rbp-128]
  00314	23 df		 and	 ebx, edi
  00316	41 3b de	 cmp	 ebx, r14d
  00319	0f 84 11 ff ff
	ff		 je	 $LL122@inflate_ta

; 261  :             /* if first time, transition to sub-tables */
; 262  :             if (drop == 0)

  0031f	45 85 e4	 test	 r12d, r12d

; 263  :                 drop = root;
; 264  : 
; 265  :             /* increment past last table */
; 266  :             next += min;            /* here min is 1 << curr */
; 267  : 
; 268  :             /* determine length of next table */
; 269  :             curr = len - drop;

  00322	45 8b cb	 mov	 r9d, r11d

; 270  :             left = (int)(1 << curr);

  00325	ba 01 00 00 00	 mov	 edx, 1
  0032a	44 0f 44 65 84	 cmove	 r12d, DWORD PTR root$3$[rbp-128]
  0032f	4d 8d 3c b7	 lea	 r15, QWORD PTR [r15+rsi*4]
  00333	45 2b cc	 sub	 r9d, r12d
  00336	41 8b c9	 mov	 ecx, r9d

; 271  :             while (curr + drop < max) {

  00339	47 8d 04 0c	 lea	 r8d, DWORD PTR [r12+r9]
  0033d	d3 e2		 shl	 edx, cl
  0033f	45 3b c2	 cmp	 r8d, r10d
  00342	73 19		 jae	 SHORT $LN120@inflate_ta
$LL13@inflate_ta:

; 272  :                 left -= count[curr + drop];

  00344	42 0f b7 4c 45
	a8		 movzx	 ecx, WORD PTR count$[rbp+r8*2-128]
  0034a	2b d1		 sub	 edx, ecx

; 273  :                 if (left <= 0) break;

  0034c	85 d2		 test	 edx, edx
  0034e	7e 0d		 jle	 SHORT $LN120@inflate_ta

; 274  :                 curr++;

  00350	41 ff c0	 inc	 r8d
  00353	41 ff c1	 inc	 r9d

; 275  :                 left <<= 1;

  00356	03 d2		 add	 edx, edx
  00358	45 3b c2	 cmp	 r8d, r10d
  0035b	72 e7		 jb	 SHORT $LL13@inflate_ta
$LN120@inflate_ta:

; 276  :             }
; 277  : 
; 278  :             /* check for enough space */
; 279  :             used += 1U << curr;

  0035d	44 8b 6d 8c	 mov	 r13d, DWORD PTR used$1$[rbp-128]

; 280  :             if ((type == LENS && used >= ENOUGH_LENS) ||
; 281  :                 (type == DISTS && used >= ENOUGH_DISTS))

  00361	8b 45 40	 mov	 eax, DWORD PTR type$[rbp-128]
  00364	41 8b c9	 mov	 ecx, r9d
  00367	be 01 00 00 00	 mov	 esi, 1
  0036c	d3 e6		 shl	 esi, cl
  0036e	44 03 ee	 add	 r13d, esi
  00371	44 89 6d 8c	 mov	 DWORD PTR used$1$[rbp-128], r13d
  00375	83 f8 01	 cmp	 eax, 1
  00378	75 09		 jne	 SHORT $LN8@inflate_ta
  0037a	41 81 fd 54 03
	00 00		 cmp	 r13d, 852		; 00000354H
  00381	eb 0c		 jmp	 SHORT $LN135@inflate_ta
$LN8@inflate_ta:
  00383	83 f8 02	 cmp	 eax, 2
  00386	75 0d		 jne	 SHORT $LN10@inflate_ta
  00388	41 81 fd 50 02
	00 00		 cmp	 r13d, 592		; 00000250H
$LN135@inflate_ta:
  0038f	0f 83 89 fe ff
	ff		 jae	 $LN32@inflate_ta
$LN10@inflate_ta:

; 282  :                 return 1;
; 283  : 
; 284  :             /* point entry in root table to sub-table */
; 285  :             low = huff & mask;
; 286  :             (*table)[low].op = (unsigned char)curr;

  00395	48 8b 4d 58	 mov	 rcx, QWORD PTR table$[rbp-128]

; 288  :             (*table)[low].val = (unsigned short)(next - *table);
; 289  :         }
; 290  :     }

  00399	8b 55 80	 mov	 edx, DWORD PTR end$1$[rbp-128]
  0039c	4c 8b 45 68	 mov	 r8, QWORD PTR work$[rbp-128]
  003a0	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  003a3	44 8b f3	 mov	 r14d, ebx
  003a6	44 88 0c 98	 mov	 BYTE PTR [rax+rbx*4], r9b
  003aa	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  003ad	8b 5d 84	 mov	 ebx, DWORD PTR root$3$[rbp-128]
  003b0	44 8b 4d 88	 mov	 r9d, DWORD PTR sym$2$[rbp-128]
  003b4	42 88 5c b0 01	 mov	 BYTE PTR [rax+r14*4+1], bl
  003b9	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003bc	49 8b c7	 mov	 rax, r15
  003bf	48 2b c1	 sub	 rax, rcx
  003c2	48 c1 f8 02	 sar	 rax, 2
  003c6	66 42 89 44 b1
	02		 mov	 WORD PTR [rcx+r14*4+2], ax
  003cc	e9 62 fe ff ff	 jmp	 $LL30@inflate_ta
$LN89@inflate_ta:
  003d1	4c 8b 45 58	 mov	 r8, QWORD PTR table$[rbp-128]

; 291  : 
; 292  :     /*
; 293  :        Fill in rest of table for incomplete codes.  This loop is similar to the
; 294  :        loop above in incrementing huff for table indices.  It is assumed that
; 295  :        len is equal to curr + drop, so there is no loop needed to increment
; 296  :        through high index bits.  When the current sub-table is filled, the loop
; 297  :        drops back to the root table to fill in any remaining entries there.
; 298  :      */
; 299  :     here.op = (unsigned char)64;                /* invalid code marker */
; 300  :     here.bits = (unsigned char)(len - drop);

  003d5	41 0f b6 c3	 movzx	 eax, r11b
  003d9	c6 45 50 40	 mov	 BYTE PTR here$[rbp-128], 64 ; 00000040H
  003dd	41 2a c4	 sub	 al, r12b

; 301  :     here.val = (unsigned short)0;

  003e0	66 89 4d 52	 mov	 WORD PTR here$[rbp-126], cx
  003e4	88 45 51	 mov	 BYTE PTR here$[rbp-127], al

; 302  :     while (huff != 0) {

  003e7	85 ff		 test	 edi, edi
  003e9	74 5d		 je	 SHORT $LN2@inflate_ta
  003eb	0f 1f 44 00 00	 npad	 5
$LL7@inflate_ta:

; 303  :         /* when done with sub-table, drop back to root table */
; 304  :         if (drop != 0 && (huff & mask) != low) {

  003f0	45 85 e4	 test	 r12d, r12d
  003f3	74 16		 je	 SHORT $LN5@inflate_ta
  003f5	8b 45 90	 mov	 eax, DWORD PTR mask$1$[rbp-128]
  003f8	23 c7		 and	 eax, edi
  003fa	41 3b c6	 cmp	 eax, r14d
  003fd	74 0c		 je	 SHORT $LN5@inflate_ta

; 305  :             drop = 0;
; 306  :             len = root;
; 307  :             next = *table;

  003ff	4d 8b 38	 mov	 r15, QWORD PTR [r8]
  00402	44 8b e1	 mov	 r12d, ecx
  00405	44 8b db	 mov	 r11d, ebx

; 308  :             here.bits = (unsigned char)len;

  00408	88 5d 51	 mov	 BYTE PTR here$[rbp-127], bl
$LN5@inflate_ta:

; 309  :         }
; 310  : 
; 311  :         /* put invalid code marker in table */
; 312  :         next[huff >> drop] = here;

  0040b	8b 45 50	 mov	 eax, DWORD PTR here$[rbp-128]
  0040e	41 8b cc	 mov	 ecx, r12d
  00411	8b d7		 mov	 edx, edi
  00413	48 d3 ea	 shr	 rdx, cl

; 313  : 
; 314  :         /* backwards increment the len-bit code huff */
; 315  :         incr = 1U << (len - 1);

  00416	41 8d 4b ff	 lea	 ecx, DWORD PTR [r11-1]
  0041a	41 89 04 97	 mov	 DWORD PTR [r15+rdx*4], eax
  0041e	ba 01 00 00 00	 mov	 edx, 1
  00423	d3 e2		 shl	 edx, cl

; 316  :         while (huff & incr)

  00425	85 d7		 test	 edx, edi
  00427	74 0d		 je	 SHORT $LN3@inflate_ta
  00429	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@inflate_ta:

; 317  :             incr >>= 1;

  00430	d1 ea		 shr	 edx, 1
  00432	85 d7		 test	 edx, edi
  00434	75 fa		 jne	 SHORT $LL4@inflate_ta
$LN3@inflate_ta:

; 318  :         if (incr != 0) {

  00436	85 d2		 test	 edx, edx
  00438	74 0e		 je	 SHORT $LN2@inflate_ta

; 319  :             huff &= incr - 1;

  0043a	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  0043d	b9 00 00 00 00	 mov	 ecx, 0
  00442	23 f8		 and	 edi, eax

; 320  :             huff += incr;

  00444	03 fa		 add	 edi, edx
  00446	75 a8		 jne	 SHORT $LL7@inflate_ta
$LN2@inflate_ta:

; 321  :         }
; 322  :         else
; 323  :             huff = 0;
; 324  :     }
; 325  : 
; 326  :     /* set return parameters */
; 327  :     *table += used;

  00448	8b 45 8c	 mov	 eax, DWORD PTR used$1$[rbp-128]
  0044b	48 c1 e0 02	 shl	 rax, 2
  0044f	49 01 00	 add	 QWORD PTR [r8], rax

; 328  :     *bits = root;

  00452	48 8b 45 60	 mov	 rax, QWORD PTR bits$[rbp-128]
  00456	89 18		 mov	 DWORD PTR [rax], ebx

; 329  :     return 0;

  00458	33 c0		 xor	 eax, eax
$LN131@inflate_ta:
  0045a	4c 8b 7c 24 78	 mov	 r15, QWORD PTR [rsp+120]
$LN69@inflate_ta:

; 330  : }

  0045f	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00466	41 5e		 pop	 r14
  00468	41 5d		 pop	 r13
  0046a	41 5c		 pop	 r12
  0046c	5f		 pop	 rdi
  0046d	5e		 pop	 rsi
  0046e	5b		 pop	 rbx
  0046f	5d		 pop	 rbp
  00470	c3		 ret	 0
inflate_table ENDP
_TEXT	ENDS
END
