; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LEAOPCJE@no?5mem?5for?5new?5grammar?$AA@ ; `string'
PUBLIC	_Py_newgrammar
EXTRN	Py_FatalError:PROC
EXTRN	PyObject_Malloc:PROC
;	COMDAT pdata
; File c:\src\pyparallel\parser\grammar.c
pdata	SEGMENT
$pdata$_Py_newgrammar DD imagerel $LN4
	DD	imagerel $LN4+77
	DD	imagerel $unwind$_Py_newgrammar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_newgrammar DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BH@LEAOPCJE@no?5mem?5for?5new?5grammar?$AA@
CONST	SEGMENT
??_C@_0BH@LEAOPCJE@no?5mem?5for?5new?5grammar?$AA@ DB 'no mem for new gra'
	DB	'mmar', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_newgrammar
_TEXT	SEGMENT
start$ = 48
_Py_newgrammar PROC					; COMDAT

; 16   : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b f9		 mov	 edi, ecx

; 17   :     grammar *g;
; 18   : 
; 19   :     g = (grammar *)PyObject_MALLOC(sizeof(grammar));

  0000c	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00011	e8 00 00 00 00	 call	 PyObject_Malloc
  00016	48 8b d8	 mov	 rbx, rax

; 20   :     if (g == NULL)

  00019	48 85 c0	 test	 rax, rax
  0001c	75 0c		 jne	 SHORT $LN1@Py_newgram

; 21   :         Py_FatalError("no mem for new grammar");

  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LEAOPCJE@no?5mem?5for?5new?5grammar?$AA@
  00025	e8 00 00 00 00	 call	 Py_FatalError
$LN1@Py_newgram:

; 22   :     g->g_ndfas = 0;

  0002a	33 c0		 xor	 eax, eax

; 23   :     g->g_dfa = NULL;
; 24   :     g->g_start = start;

  0002c	89 7b 20	 mov	 DWORD PTR [rbx+32], edi
  0002f	89 03		 mov	 DWORD PTR [rbx], eax
  00031	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 25   :     g->g_ll.ll_nlabels = 0;

  00035	89 43 10	 mov	 DWORD PTR [rbx+16], eax

; 26   :     g->g_ll.ll_label = NULL;

  00038	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax

; 27   :     g->g_accel = 0;

  0003c	89 43 24	 mov	 DWORD PTR [rbx+36], eax

; 28   :     return g;

  0003f	48 8b c3	 mov	 rax, rbx

; 29   : }

  00042	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
_Py_newgrammar ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@PACJOLEE@no?5mem?5to?5resize?5dfa?5in?5adddfa?$AA@ ; `string'
PUBLIC	_Py_adddfa
EXTRN	__imp_strdup:PROC
EXTRN	PyObject_Realloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_adddfa DD imagerel $LN4
	DD	imagerel $LN4+151
	DD	imagerel $unwind$_Py_adddfa
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_adddfa DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_0BP@PACJOLEE@no?5mem?5to?5resize?5dfa?5in?5adddfa?$AA@
CONST	SEGMENT
??_C@_0BP@PACJOLEE@no?5mem?5to?5resize?5dfa?5in?5adddfa?$AA@ DB 'no mem t'
	DB	'o resize dfa in adddfa', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_adddfa
_TEXT	SEGMENT
g$ = 48
type$ = 56
name$ = 64
_Py_adddfa PROC						; COMDAT

; 33   : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 34   :     dfa *d;
; 35   : 
; 36   :     g->g_dfa = (dfa *)PyObject_REALLOC(g->g_dfa,
; 37   :                                         sizeof(dfa) * (g->g_ndfas + 1));

  00014	8b 01		 mov	 eax, DWORD PTR [rcx]
  00016	8b ea		 mov	 ebp, edx
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0001f	ff c0		 inc	 eax
  00021	49 8b f0	 mov	 rsi, r8
  00024	48 98		 cdqe
  00026	48 8d 14 80	 lea	 rdx, QWORD PTR [rax+rax*4]
  0002a	48 c1 e2 03	 shl	 rdx, 3
  0002e	e8 00 00 00 00	 call	 PyObject_Realloc
  00033	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax

; 38   :     if (g->g_dfa == NULL)

  00037	48 85 c0	 test	 rax, rax
  0003a	75 0c		 jne	 SHORT $LN1@Py_adddfa

; 39   :         Py_FatalError("no mem to resize dfa in adddfa");

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@PACJOLEE@no?5mem?5to?5resize?5dfa?5in?5adddfa?$AA@
  00043	e8 00 00 00 00	 call	 Py_FatalError
$LN1@Py_adddfa:

; 40   :     d = &g->g_dfa[g->g_ndfas++];

  00048	48 63 17	 movsxd	 rdx, DWORD PTR [rdi]
  0004b	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  0004f	48 8d 0c 92	 lea	 rcx, QWORD PTR [rdx+rdx*4]
  00053	48 8d 1c c8	 lea	 rbx, QWORD PTR [rax+rcx*8]
  00057	8d 4a 01	 lea	 ecx, DWORD PTR [rdx+1]
  0005a	89 0f		 mov	 DWORD PTR [rdi], ecx

; 41   :     d->d_type = type;
; 42   :     d->d_name = strdup(name);

  0005c	48 8b ce	 mov	 rcx, rsi
  0005f	89 2b		 mov	 DWORD PTR [rbx], ebp
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup

; 43   :     d->d_nstates = 0;
; 44   :     d->d_state = NULL;
; 45   :     d->d_initial = -1;
; 46   :     d->d_first = NULL;
; 47   :     return d; /* Only use while fresh! */
; 48   : }

  00067	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0006c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00071	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
  00075	33 c0		 xor	 eax, eax
  00077	c7 43 10 ff ff
	ff ff		 mov	 DWORD PTR [rbx+16], -1
  0007e	89 43 14	 mov	 DWORD PTR [rbx+20], eax
  00081	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
  00085	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  00089	48 8b c3	 mov	 rax, rbx
  0008c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00091	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00095	5f		 pop	 rdi
  00096	c3		 ret	 0
_Py_adddfa ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@NDGOOPPB@no?5mem?5to?5resize?5state?5in?5addsta@ ; `string'
PUBLIC	_Py_addstate
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_addstate DD imagerel $LN4
	DD	imagerel $LN4+134
	DD	imagerel $unwind$_Py_addstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_addstate DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CD@NDGOOPPB@no?5mem?5to?5resize?5state?5in?5addsta@
CONST	SEGMENT
??_C@_0CD@NDGOOPPB@no?5mem?5to?5resize?5state?5in?5addsta@ DB 'no mem to '
	DB	'resize state in addstate', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_addstate
_TEXT	SEGMENT
d$ = 48
_Py_addstate PROC					; COMDAT

; 52   : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 53   :     state *s;
; 54   : 
; 55   :     d->d_state = (state *)PyObject_REALLOC(d->d_state,
; 56   :                                   sizeof(state) * (d->d_nstates + 1));

  00006	8b 41 14	 mov	 eax, DWORD PTR [rcx+20]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00010	ff c0		 inc	 eax
  00012	48 98		 cdqe
  00014	48 8d 14 80	 lea	 rdx, QWORD PTR [rax+rax*4]
  00018	48 c1 e2 03	 shl	 rdx, 3
  0001c	e8 00 00 00 00	 call	 PyObject_Realloc
  00021	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax

; 57   :     if (d->d_state == NULL)

  00025	48 85 c0	 test	 rax, rax
  00028	75 0c		 jne	 SHORT $LN1@Py_addstat

; 58   :         Py_FatalError("no mem to resize state in addstate");

  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@NDGOOPPB@no?5mem?5to?5resize?5state?5in?5addsta@
  00031	e8 00 00 00 00	 call	 Py_FatalError
$LN1@Py_addstat:

; 59   :     s = &d->d_state[d->d_nstates++];

  00036	48 63 53 14	 movsxd	 rdx, DWORD PTR [rbx+20]
  0003a	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  0003e	48 8d 0c 92	 lea	 rcx, QWORD PTR [rdx+rdx*4]
  00042	4c 8d 04 c8	 lea	 r8, QWORD PTR [rax+rcx*8]
  00046	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  00049	89 43 14	 mov	 DWORD PTR [rbx+20], eax

; 60   :     s->s_narcs = 0;

  0004c	33 c0		 xor	 eax, eax
  0004e	41 89 00	 mov	 DWORD PTR [r8], eax

; 61   :     s->s_arc = NULL;

  00051	49 89 40 08	 mov	 QWORD PTR [r8+8], rax

; 62   :     s->s_lower = 0;

  00055	49 89 40 10	 mov	 QWORD PTR [r8+16], rax

; 63   :     s->s_upper = 0;
; 64   :     s->s_accel = NULL;

  00059	49 89 40 18	 mov	 QWORD PTR [r8+24], rax

; 65   :     s->s_accept = 0;

  0005d	41 89 40 20	 mov	 DWORD PTR [r8+32], eax

; 66   :     return s - d->d_state;

  00061	4c 2b 43 18	 sub	 r8, QWORD PTR [rbx+24]
  00065	48 b8 67 66 66
	66 66 66 66 66	 mov	 rax, 7378697629483820647 ; 6666666666666667H
  0006f	49 f7 e8	 imul	 r8
  00072	48 c1 fa 04	 sar	 rdx, 4
  00076	48 8b c2	 mov	 rax, rdx
  00079	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0007d	48 03 c2	 add	 rax, rdx

; 67   : }

  00080	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00084	5b		 pop	 rbx
  00085	c3		 ret	 0
_Py_addstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@LKHKMPMN@no?5mem?5to?5resize?5arc?5list?5in?5add@ ; `string'
PUBLIC	_Py_addarc
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_addarc DD imagerel $LN4
	DD	imagerel $LN4+128
	DD	imagerel $unwind$_Py_addarc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_addarc DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_0CE@LKHKMPMN@no?5mem?5to?5resize?5arc?5list?5in?5add@
CONST	SEGMENT
??_C@_0CE@LKHKMPMN@no?5mem?5to?5resize?5arc?5list?5in?5add@ DB 'no mem to'
	DB	' resize arc list in addarc', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_addarc
_TEXT	SEGMENT
d$ = 48
from$ = 56
to$ = 64
lbl$ = 72
_Py_addarc PROC						; COMDAT

; 71   : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 72   :     state *s;
; 73   :     arc *a;
; 74   : 
; 75   :     assert(0 <= from && from < d->d_nstates);
; 76   :     assert(0 <= to && to < d->d_nstates);
; 77   : 
; 78   :     s = &d->d_state[from];

  00014	48 8b 79 18	 mov	 rdi, QWORD PTR [rcx+24]
  00018	48 63 c2	 movsxd	 rax, edx
  0001b	41 8b f1	 mov	 esi, r9d
  0001e	48 8d 1c 80	 lea	 rbx, QWORD PTR [rax+rax*4]
  00022	41 8b e8	 mov	 ebp, r8d

; 79   :     s->s_arc = (arc *)PyObject_REALLOC(s->s_arc, sizeof(arc) * (s->s_narcs + 1));

  00025	8b 04 df	 mov	 eax, DWORD PTR [rdi+rbx*8]
  00028	48 8b 4c df 08	 mov	 rcx, QWORD PTR [rdi+rbx*8+8]
  0002d	ff c0		 inc	 eax
  0002f	48 63 d0	 movsxd	 rdx, eax
  00032	48 c1 e2 02	 shl	 rdx, 2
  00036	e8 00 00 00 00	 call	 PyObject_Realloc
  0003b	48 89 44 df 08	 mov	 QWORD PTR [rdi+rbx*8+8], rax

; 80   :     if (s->s_arc == NULL)

  00040	48 85 c0	 test	 rax, rax
  00043	75 0c		 jne	 SHORT $LN1@Py_addarc

; 81   :         Py_FatalError("no mem to resize arc list in addarc");

  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@LKHKMPMN@no?5mem?5to?5resize?5arc?5list?5in?5add@
  0004c	e8 00 00 00 00	 call	 Py_FatalError
$LN1@Py_addarc:

; 82   :     a = &s->s_arc[s->s_narcs++];

  00051	48 63 04 df	 movsxd	 rax, DWORD PTR [rdi+rbx*8]
  00055	48 8b 4c df 08	 mov	 rcx, QWORD PTR [rdi+rbx*8+8]
  0005a	48 8b d0	 mov	 rdx, rax
  0005d	ff c0		 inc	 eax
  0005f	89 04 df	 mov	 DWORD PTR [rdi+rbx*8], eax

; 83   :     a->a_lbl = lbl;
; 84   :     a->a_arrow = to;
; 85   : }

  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	66 89 34 91	 mov	 WORD PTR [rcx+rdx*4], si
  0006b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00070	66 89 6c 91 02	 mov	 WORD PTR [rcx+rdx*4+2], bp
  00075	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0007a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007e	5f		 pop	 rdi
  0007f	c3		 ret	 0
_Py_addarc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@NJBLCGHI@Label?5?$EA?5?$CF8p?0?5?$CFd?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@EICAKID@no?5mem?5to?5resize?5labellist?5in?5ad@ ; `string'
PUBLIC	_Py_addlabel
EXTRN	__imp_printf:PROC
EXTRN	PyGrammar_LabelRepr:PROC
EXTRN	Py_DebugFlag:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_addlabel DD imagerel $LN15
	DD	imagerel $LN15+111
	DD	imagerel $unwind$_Py_addlabel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_Py_addlabel DD imagerel $LN15+111
	DD	imagerel $LN15+252
	DD	imagerel $chain$0$_Py_addlabel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_Py_addlabel DD imagerel $LN15+252
	DD	imagerel $LN15+271
	DD	imagerel $chain$1$_Py_addlabel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_Py_addlabel DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+111
	DD	imagerel $unwind$_Py_addlabel
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_Py_addlabel DD 020521H
	DD	063405H
	DD	imagerel $LN15
	DD	imagerel $LN15+111
	DD	imagerel $unwind$_Py_addlabel
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_addlabel DD 060f01H
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BF@NJBLCGHI@Label?5?$EA?5?$CF8p?0?5?$CFd?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BF@NJBLCGHI@Label?5?$EA?5?$CF8p?0?5?$CFd?3?5?$CFs?6?$AA@ DB 'Label'
	DB	' @ %8p, %d: %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EICAKID@no?5mem?5to?5resize?5labellist?5in?5ad@
CONST	SEGMENT
??_C@_0CH@EICAKID@no?5mem?5to?5resize?5labellist?5in?5ad@ DB 'no mem to r'
	DB	'esize labellist in addlabel', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_addlabel
_TEXT	SEGMENT
ll$ = 48
type$ = 56
str$ = 64
_Py_addlabel PROC					; COMDAT

; 89   : {

$LN15:
  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 90   :     int i;
; 91   :     label *lb;
; 92   : 
; 93   :     for (i = 0; i < ll->ll_nlabels; i++) {

  0000f	44 8b 19	 mov	 r11d, DWORD PTR [rcx]
  00012	45 33 d2	 xor	 r10d, r10d
  00015	49 8b e8	 mov	 rbp, r8
  00018	8b f2		 mov	 esi, edx
  0001a	48 8b f9	 mov	 rdi, rcx
  0001d	45 85 db	 test	 r11d, r11d
  00020	7e 45		 jle	 SHORT $LN14@Py_addlabe
  00022	4c 8b 49 08	 mov	 r9, QWORD PTR [rcx+8]
$LL6@Py_addlabe:

; 94   :         if (ll->ll_label[i].lb_type == type &&
; 95   :             strcmp(ll->ll_label[i].lb_str, str) == 0)

  00026	41 39 31	 cmp	 DWORD PTR [r9], esi
  00029	75 30		 jne	 SHORT $LN5@Py_addlabe
  0002b	49 8b 41 08	 mov	 rax, QWORD PTR [r9+8]
  0002f	4c 8b c5	 mov	 r8, rbp
  00032	4c 2b c0	 sub	 r8, rax
  00035	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL12@Py_addlabe:
  00040	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00043	42 0f b6 0c 00	 movzx	 ecx, BYTE PTR [rax+r8]
  00048	2b d1		 sub	 edx, ecx
  0004a	75 07		 jne	 SHORT $LN13@Py_addlabe
  0004c	48 ff c0	 inc	 rax
  0004f	85 c9		 test	 ecx, ecx
  00051	75 ed		 jne	 SHORT $LL12@Py_addlabe
$LN13@Py_addlabe:
  00053	85 d2		 test	 edx, edx
  00055	0f 84 a1 00 00
	00		 je	 $LN10@Py_addlabe
$LN5@Py_addlabe:

; 90   :     int i;
; 91   :     label *lb;
; 92   : 
; 93   :     for (i = 0; i < ll->ll_nlabels; i++) {

  0005b	41 ff c2	 inc	 r10d
  0005e	49 83 c1 10	 add	 r9, 16
  00062	45 3b d3	 cmp	 r10d, r11d
  00065	7c bf		 jl	 SHORT $LL6@Py_addlabe
$LN14@Py_addlabe:

; 96   :             return i;
; 97   :     }
; 98   :     ll->ll_label = (label *)PyObject_REALLOC(ll->ll_label,
; 99   :                                     sizeof(label) * (ll->ll_nlabels + 1));

  00067	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  0006b	41 8d 43 01	 lea	 eax, DWORD PTR [r11+1]
  0006f	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00074	48 63 d0	 movsxd	 rdx, eax
  00077	48 c1 e2 04	 shl	 rdx, 4
  0007b	e8 00 00 00 00	 call	 PyObject_Realloc
  00080	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax

; 100  :     if (ll->ll_label == NULL)

  00084	48 85 c0	 test	 rax, rax
  00087	75 0c		 jne	 SHORT $LN2@Py_addlabe

; 101  :         Py_FatalError("no mem to resize labellist in addlabel");

  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@EICAKID@no?5mem?5to?5resize?5labellist?5in?5ad@
  00090	e8 00 00 00 00	 call	 Py_FatalError
$LN2@Py_addlabe:

; 102  :     lb = &ll->ll_label[ll->ll_nlabels++];

  00095	48 63 07	 movsxd	 rax, DWORD PTR [rdi]

; 103  :     lb->lb_type = type;
; 104  :     lb->lb_str = strdup(str);

  00098	48 8b cd	 mov	 rcx, rbp
  0009b	48 8b d8	 mov	 rbx, rax
  0009e	48 c1 e3 04	 shl	 rbx, 4
  000a2	48 03 5f 08	 add	 rbx, QWORD PTR [rdi+8]
  000a6	ff c0		 inc	 eax
  000a8	89 07		 mov	 DWORD PTR [rdi], eax
  000aa	89 33		 mov	 DWORD PTR [rbx], esi
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000b2	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 105  :     if (Py_DebugFlag)

  000b6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  000bd	74 1e		 je	 SHORT $LN1@Py_addlabe

; 106  :         printf("Label @ %8p, %d: %s\n", ll, ll->ll_nlabels,
; 107  :                PyGrammar_LabelRepr(lb));

  000bf	48 8b cb	 mov	 rcx, rbx
  000c2	e8 00 00 00 00	 call	 PyGrammar_LabelRepr
  000c7	44 8b 07	 mov	 r8d, DWORD PTR [rdi]
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@NJBLCGHI@Label?5?$EA?5?$CF8p?0?5?$CFd?3?5?$CFs?6?$AA@
  000d1	4c 8b c8	 mov	 r9, rax
  000d4	48 8b d7	 mov	 rdx, rdi
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN1@Py_addlabe:

; 108  :     return lb - ll->ll_label;

  000dd	48 2b 5f 08	 sub	 rbx, QWORD PTR [rdi+8]
  000e1	48 c1 fb 04	 sar	 rbx, 4
  000e5	8b c3		 mov	 eax, ebx
  000e7	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 109  : }

  000ec	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000f1	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000f6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fa	5f		 pop	 rdi
  000fb	c3		 ret	 0
$LN10@Py_addlabe:
  000fc	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00101	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00106	41 8b c2	 mov	 eax, r10d
  00109	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010d	5f		 pop	 rdi
  0010e	c3		 ret	 0
_Py_addlabel ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@CFAOJANI@grammar?4c?3findlabel?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BJ@LLAIDDKD@Label?5?$CFd?1?8?$CFs?8?5not?5found?6?$AA@ ; `string'
PUBLIC	_Py_findlabel
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_findlabel DD imagerel $LN10
	DD	imagerel $LN10+101
	DD	imagerel $unwind$_Py_findlabel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_findlabel DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BG@CFAOJANI@grammar?4c?3findlabel?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BG@CFAOJANI@grammar?4c?3findlabel?$CI?$CJ?$AA@ DB 'grammar.c:findl'
	DB	'abel()', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LLAIDDKD@Label?5?$CFd?1?8?$CFs?8?5not?5found?6?$AA@
CONST	SEGMENT
??_C@_0BJ@LLAIDDKD@Label?5?$CFd?1?8?$CFs?8?5not?5found?6?$AA@ DB 'Label %'
	DB	'd/''%s'' not found', 0aH, 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_findlabel
_TEXT	SEGMENT
ll$ = 48
type$ = 56
str$ = 64
_Py_findlabel PROC					; COMDAT

; 115  : {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 116  :     int i;
; 117  : 
; 118  :     for (i = 0; i < ll->ll_nlabels; i++) {

  0000a	44 8b 09	 mov	 r9d, DWORD PTR [rcx]
  0000d	33 c0		 xor	 eax, eax
  0000f	49 8b f8	 mov	 rdi, r8
  00012	8b da		 mov	 ebx, edx
  00014	45 85 c9	 test	 r9d, r9d
  00017	7e 16		 jle	 SHORT $LN2@Py_findlab
  00019	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0001d	0f 1f 00	 npad	 3
$LL4@Py_findlab:

; 119  :         if (ll->ll_label[i].lb_type == type /*&&
; 120  :             strcmp(ll->ll_label[i].lb_str, str) == 0*/)

  00020	39 11		 cmp	 DWORD PTR [rcx], edx
  00022	74 36		 je	 SHORT $LN5@Py_findlab

; 116  :     int i;
; 117  : 
; 118  :     for (i = 0; i < ll->ll_nlabels; i++) {

  00024	ff c0		 inc	 eax
  00026	48 83 c1 10	 add	 rcx, 16
  0002a	41 3b c1	 cmp	 eax, r9d
  0002d	7c f1		 jl	 SHORT $LL4@Py_findlab
$LN2@Py_findlab:

; 121  :             return i;
; 122  :     }
; 123  :     fprintf(stderr, "Label %d/'%s' not found\n", type, str);

  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@LLAIDDKD@Label?5?$CFd?1?8?$CFs?8?5not?5found?6?$AA@
  0003c	4c 8b cf	 mov	 r9, rdi
  0003f	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00043	44 8b c3	 mov	 r8d, ebx
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 124  :     Py_FatalError("grammar.c:findlabel()");

  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@CFAOJANI@grammar?4c?3findlabel?$CI?$CJ?$AA@
  00053	e8 00 00 00 00	 call	 Py_FatalError

; 125  :     return 0; /* Make gcc -Wall happy */

  00058	33 c0		 xor	 eax, eax
$LN5@Py_findlab:

; 126  : }

  0005a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00063	5f		 pop	 rdi
  00064	c3		 ret	 0
_Py_findlabel ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@MCBIKPJI@Can?8t?5translate?5label?5?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@GEDIIBCK@Can?8t?5alloc?5dest?5?8?$CFs?8?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@IJIDICON@Label?5?$CFs?5is?5a?5keyword?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@JPAKDDAN@Can?8t?5translate?5STRING?5label?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BF@BOLHCNHE@Unknown?5OP?5label?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@BLHJLOEA@Label?5?$CFs?5is?5terminal?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@FPEDPNFN@Label?5?$CFs?5is?5non?9terminal?5?$CFd?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@NOMEMCLM@Can?8t?5translate?5NAME?5label?5?8?$CFs?8?6@ ; `string'
PUBLIC	??_C@_0BK@BMNEMALA@Translating?5label?5?$CFs?5?4?4?4?6?$AA@ ; `string'
EXTRN	__imp_strncpy:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_strchr:PROC
EXTRN	PyToken_ThreeChars:PROC
EXTRN	PyToken_TwoChars:PROC
EXTRN	PyToken_OneChar:PROC
EXTRN	__imp_isalpha:PROC
EXTRN	__imp_free:PROC
EXTRN	_PyParser_TokenNames:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$translabel DD imagerel translabel
	DD	imagerel translabel+748
	DD	imagerel $unwind$translabel
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$translabel DD 0a4c01H
	DD	0a744cH
	DD	096447H
	DD	085442H
	DD	0d006320aH
	DD	03002c004H
xdata	ENDS
;	COMDAT ??_C@_0BM@MCBIKPJI@Can?8t?5translate?5label?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BM@MCBIKPJI@Can?8t?5translate?5label?5?8?$CFs?8?6?$AA@ DB 'Can''t '
	DB	'translate label ''%s''', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GEDIIBCK@Can?8t?5alloc?5dest?5?8?$CFs?8?6?$AA@
CONST	SEGMENT
??_C@_0BH@GEDIIBCK@Can?8t?5alloc?5dest?5?8?$CFs?8?6?$AA@ DB 'Can''t alloc'
	DB	' dest ''%s''', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IJIDICON@Label?5?$CFs?5is?5a?5keyword?6?$AA@
CONST	SEGMENT
??_C@_0BH@IJIDICON@Label?5?$CFs?5is?5a?5keyword?6?$AA@ DB 'Label %s is a '
	DB	'keyword', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JPAKDDAN@Can?8t?5translate?5STRING?5label?5?$CFs?6@
CONST	SEGMENT
??_C@_0CB@JPAKDDAN@Can?8t?5translate?5STRING?5label?5?$CFs?6@ DB 'Can''t '
	DB	'translate STRING label %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BOLHCNHE@Unknown?5OP?5label?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BF@BOLHCNHE@Unknown?5OP?5label?5?$CFs?6?$AA@ DB 'Unknown OP label '
	DB	'%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BLHJLOEA@Label?5?$CFs?5is?5terminal?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@BLHJLOEA@Label?5?$CFs?5is?5terminal?5?$CFd?4?6?$AA@ DB 'Label %'
	DB	's is terminal %d.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FPEDPNFN@Label?5?$CFs?5is?5non?9terminal?5?$CFd?4?6?$AA@
CONST	SEGMENT
??_C@_0BO@FPEDPNFN@Label?5?$CFs?5is?5non?9terminal?5?$CFd?4?6?$AA@ DB 'La'
	DB	'bel %s is non-terminal %d.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NOMEMCLM@Can?8t?5translate?5NAME?5label?5?8?$CFs?8?6@
CONST	SEGMENT
??_C@_0CB@NOMEMCLM@Can?8t?5translate?5NAME?5label?5?8?$CFs?8?6@ DB 'Can'''
	DB	't translate NAME label ''%s''', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMNEMALA@Translating?5label?5?$CFs?5?4?4?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@BMNEMALA@Translating?5label?5?$CFs?5?4?4?4?6?$AA@ DB 'Translati'
	DB	'ng label %s ...', 0aH, 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT translabel
_TEXT	SEGMENT
g$ = 64
lb$ = 72
translabel PROC						; COMDAT

; 146  : {

  00000	40 53		 push	 rbx
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 147  :     int i;
; 148  : 
; 149  :     if (Py_DebugFlag)

  0000a	44 8b 2d 00 00
	00 00		 mov	 r13d, DWORD PTR Py_DebugFlag
  00011	48 8b da	 mov	 rbx, rdx
  00014	4c 8b e1	 mov	 r12, rcx
  00017	45 85 ed	 test	 r13d, r13d
  0001a	74 1f		 je	 SHORT $LN33@translabel

; 150  :         printf("Translating label %s ...\n", PyGrammar_LabelRepr(lb));

  0001c	48 8b ca	 mov	 rcx, rdx
  0001f	e8 00 00 00 00	 call	 PyGrammar_LabelRepr
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BMNEMALA@Translating?5label?5?$CFs?5?4?4?4?6?$AA@
  0002b	48 8b d0	 mov	 rdx, rax
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
  00034	44 8b 2d 00 00
	00 00		 mov	 r13d, DWORD PTR Py_DebugFlag
$LN33@translabel:

; 151  : 
; 152  :     if (lb->lb_type == NAME) {

  0003b	8b 03		 mov	 eax, DWORD PTR [rbx]
  0003d	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00042	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00047	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0004c	83 f8 01	 cmp	 eax, 1
  0004f	0f 85 1c 01 00
	00		 jne	 $LN32@translabel

; 153  :         for (i = 0; i < g->g_ndfas; i++) {

  00055	45 8b 0c 24	 mov	 r9d, DWORD PTR [r12]
  00059	33 ed		 xor	 ebp, ebp
  0005b	8b f5		 mov	 esi, ebp
  0005d	45 85 c9	 test	 r9d, r9d
  00060	7e 3f		 jle	 SHORT $LN29@translabel
  00062	4d 8b 5c 24 08	 mov	 r11, QWORD PTR [r12+8]
  00067	4c 8b 53 08	 mov	 r10, QWORD PTR [rbx+8]
  0006b	4d 8d 43 08	 lea	 r8, QWORD PTR [r11+8]
  0006f	90		 npad	 1
$LL31@translabel:

; 154  :             if (strcmp(lb->lb_str, g->g_dfa[i].d_name) == 0) {

  00070	49 8b 38	 mov	 rdi, QWORD PTR [r8]
  00073	49 8b c2	 mov	 rax, r10
  00076	49 2b fa	 sub	 rdi, r10
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL44@translabel:
  00080	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00083	0f b6 0c 38	 movzx	 ecx, BYTE PTR [rax+rdi]
  00087	2b d1		 sub	 edx, ecx
  00089	75 07		 jne	 SHORT $LN45@translabel
  0008b	48 ff c0	 inc	 rax
  0008e	85 c9		 test	 ecx, ecx
  00090	75 ee		 jne	 SHORT $LL44@translabel
$LN45@translabel:
  00092	85 d2		 test	 edx, edx
  00094	74 6a		 je	 SHORT $LN38@translabel

; 153  :         for (i = 0; i < g->g_ndfas; i++) {

  00096	ff c6		 inc	 esi
  00098	49 83 c0 28	 add	 r8, 40			; 00000028H
  0009c	41 3b f1	 cmp	 esi, r9d
  0009f	7c cf		 jl	 SHORT $LL31@translabel
$LN29@translabel:
  000a1	4c 8b 4b 08	 mov	 r9, QWORD PTR [rbx+8]

; 164  :             }
; 165  :         }
; 166  :         for (i = 0; i < (int)N_TOKENS; i++) {

  000a5	8b f5		 mov	 esi, ebp
  000a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_PyParser_TokenNames
  000ae	4c 8d 15 b0 01
	00 00		 lea	 r10, OFFSET FLAT:_PyParser_TokenNames+432
  000b5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL26@translabel:

; 167  :             if (strcmp(lb->lb_str, _PyParser_TokenNames[i]) == 0) {

  000c0	49 8b 38	 mov	 rdi, QWORD PTR [r8]
  000c3	49 8b c1	 mov	 rax, r9
  000c6	49 2b f9	 sub	 rdi, r9
  000c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL42@translabel:
  000d0	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  000d3	0f b6 0c 38	 movzx	 ecx, BYTE PTR [rax+rdi]
  000d7	2b d1		 sub	 edx, ecx
  000d9	75 07		 jne	 SHORT $LN43@translabel
  000db	48 ff c0	 inc	 rax
  000de	85 c9		 test	 ecx, ecx
  000e0	75 ee		 jne	 SHORT $LL42@translabel
$LN43@translabel:
  000e2	85 d2		 test	 edx, edx
  000e4	74 5e		 je	 SHORT $LN39@translabel

; 164  :             }
; 165  :         }
; 166  :         for (i = 0; i < (int)N_TOKENS; i++) {

  000e6	49 83 c0 08	 add	 r8, 8
  000ea	ff c6		 inc	 esi
  000ec	4d 3b c2	 cmp	 r8, r10
  000ef	7c cf		 jl	 SHORT $LL26@translabel

; 175  :             }
; 176  :         }
; 177  :         printf("Can't translate NAME label '%s'\n", lb->lb_str);

  000f1	49 8b d1	 mov	 rdx, r9
  000f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@NOMEMCLM@Can?8t?5translate?5NAME?5label?5?8?$CFs?8?6@

; 178  :         return;

  000fb	e9 cd 01 00 00	 jmp	 $LN46@translabel
$LN38@translabel:

; 155  :                 if (Py_DebugFlag)

  00100	45 85 ed	 test	 r13d, r13d
  00103	74 1b		 je	 SHORT $LN27@translabel

; 156  :                     printf(
; 157  :                         "Label %s is non-terminal %d.\n",
; 158  :                         lb->lb_str,
; 159  :                         g->g_dfa[i].d_type);

  00105	48 63 c6	 movsxd	 rax, esi
  00108	49 8b d2	 mov	 rdx, r10
  0010b	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  0010f	45 8b 04 cb	 mov	 r8d, DWORD PTR [r11+rcx*8]
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@FPEDPNFN@Label?5?$CFs?5is?5non?9terminal?5?$CFd?4?6?$AA@
  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN27@translabel:

; 160  :                 lb->lb_type = g->g_dfa[i].d_type;

  00120	48 63 c6	 movsxd	 rax, esi
  00123	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00127	49 8b 44 24 08	 mov	 rax, QWORD PTR [r12+8]
  0012c	8b 0c c8	 mov	 ecx, DWORD PTR [rax+rcx*8]
  0012f	89 0b		 mov	 DWORD PTR [rbx], ecx

; 161  :                 free(lb->lb_str);

  00131	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 162  :                 lb->lb_str = NULL;

  0013b	48 89 6b 08	 mov	 QWORD PTR [rbx+8], rbp

; 163  :                 return;

  0013f	e9 8f 01 00 00	 jmp	 $LN1@translabel
$LN39@translabel:

; 168  :                 if (Py_DebugFlag)

  00144	45 85 ed	 test	 r13d, r13d
  00147	74 13		 je	 SHORT $LN22@translabel

; 169  :                     printf("Label %s is terminal %d.\n",
; 170  :                         lb->lb_str, i);

  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BLHJLOEA@Label?5?$CFs?5is?5terminal?5?$CFd?4?6?$AA@
  00150	44 8b c6	 mov	 r8d, esi
  00153	49 8b d1	 mov	 rdx, r9
  00156	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN22@translabel:

; 171  :                 lb->lb_type = i;
; 172  :                 free(lb->lb_str);

  0015c	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00160	89 33		 mov	 DWORD PTR [rbx], esi
  00162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 173  :                 lb->lb_str = NULL;

  00168	48 89 6b 08	 mov	 QWORD PTR [rbx+8], rbp

; 174  :                 return;

  0016c	e9 62 01 00 00	 jmp	 $LN1@translabel
$LN32@translabel:

; 179  :     }
; 180  : 
; 181  :     if (lb->lb_type == STRING) {

  00171	83 f8 03	 cmp	 eax, 3
  00174	0f 85 41 01 00
	00		 jne	 $LN21@translabel

; 182  :         if (isalpha(Py_CHARMASK(lb->lb_str[1])) ||
; 183  :             lb->lb_str[1] == '_') {

  0017a	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0017e	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalpha
  00188	85 c0		 test	 eax, eax
  0018a	0f 85 9b 00 00
	00		 jne	 $LN19@translabel
  00190	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00194	0f b6 4a 01	 movzx	 ecx, BYTE PTR [rdx+1]
  00198	80 f9 5f	 cmp	 cl, 95			; 0000005fH
  0019b	0f 84 8a 00 00
	00		 je	 $LN19@translabel

; 206  :         }
; 207  :         else if (lb->lb_str[2] == lb->lb_str[0]) {

  001a1	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  001a4	38 42 02	 cmp	 BYTE PTR [rdx+2], al
  001a7	75 34		 jne	 SHORT $LN13@translabel

; 208  :             int type = (int) PyToken_OneChar(lb->lb_str[1]);

  001a9	0f be c9	 movsx	 ecx, cl
  001ac	e8 00 00 00 00	 call	 PyToken_OneChar
$LN48@translabel:

; 209  :             if (type != OP) {

  001b1	83 f8 34	 cmp	 eax, 52			; 00000034H
  001b4	74 17		 je	 SHORT $LN12@translabel

; 210  :                 lb->lb_type = type;
; 211  :                 free(lb->lb_str);

  001b6	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  001ba	89 03		 mov	 DWORD PTR [rbx], eax
  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 212  :                 lb->lb_str = NULL;

  001c2	33 ed		 xor	 ebp, ebp
  001c4	48 89 6b 08	 mov	 QWORD PTR [rbx+8], rbp

; 213  :             }
; 214  :             else

  001c8	e9 06 01 00 00	 jmp	 $LN1@translabel
$LN12@translabel:

; 215  :                 printf("Unknown OP label %s\n",
; 216  :                     lb->lb_str);

  001cd	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  001d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@BOLHCNHE@Unknown?5OP?5label?5?$CFs?6?$AA@

; 217  :         }
; 218  :         else if (lb->lb_str[2] && lb->lb_str[3] == lb->lb_str[0]) {

  001d8	e9 f0 00 00 00	 jmp	 $LN46@translabel
$LN13@translabel:
  001dd	0f b6 7a 02	 movzx	 edi, BYTE PTR [rdx+2]
  001e1	40 84 ff	 test	 dil, dil
  001e4	74 39		 je	 SHORT $LN5@translabel
  001e6	38 42 03	 cmp	 BYTE PTR [rdx+3], al
  001e9	75 0e		 jne	 SHORT $LN9@translabel

; 219  :             int type = (int) PyToken_TwoChars(lb->lb_str[1],
; 220  :                                        lb->lb_str[2]);

  001eb	40 0f be d7	 movsx	 edx, dil
  001ef	0f be c9	 movsx	 ecx, cl
  001f2	e8 00 00 00 00	 call	 PyToken_TwoChars

; 221  :             if (type != OP) {
; 222  :                 lb->lb_type = type;
; 223  :                 free(lb->lb_str);
; 224  :                 lb->lb_str = NULL;
; 225  :             }
; 226  :             else

  001f7	eb b8		 jmp	 SHORT $LN48@translabel
$LN9@translabel:

; 227  :                 printf("Unknown OP label %s\n",
; 228  :                     lb->lb_str);
; 229  :         }
; 230  :         else if (lb->lb_str[2] && lb->lb_str[3] && lb->lb_str[4] == lb->lb_str[0]) {

  001f9	40 84 ff	 test	 dil, dil
  001fc	74 21		 je	 SHORT $LN5@translabel
  001fe	44 0f b6 42 03	 movzx	 r8d, BYTE PTR [rdx+3]
  00203	45 84 c0	 test	 r8b, r8b
  00206	74 17		 je	 SHORT $LN5@translabel
  00208	38 42 04	 cmp	 BYTE PTR [rdx+4], al
  0020b	75 12		 jne	 SHORT $LN5@translabel

; 231  :             int type = (int) PyToken_ThreeChars(lb->lb_str[1],
; 232  :                                                 lb->lb_str[2],
; 233  :                                                 lb->lb_str[3]);

  0020d	45 0f be c0	 movsx	 r8d, r8b
  00211	40 0f be d7	 movsx	 edx, dil
  00215	0f be c9	 movsx	 ecx, cl
  00218	e8 00 00 00 00	 call	 PyToken_ThreeChars

; 234  :             if (type != OP) {
; 235  :                 lb->lb_type = type;
; 236  :                 free(lb->lb_str);
; 237  :                 lb->lb_str = NULL;
; 238  :             }
; 239  :             else

  0021d	eb 92		 jmp	 SHORT $LN48@translabel
$LN5@translabel:

; 240  :                 printf("Unknown OP label %s\n",
; 241  :                     lb->lb_str);
; 242  :         }
; 243  :         else
; 244  :             printf("Can't translate STRING label %s\n",
; 245  :                 lb->lb_str);

  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@JPAKDDAN@Can?8t?5translate?5STRING?5label?5?$CFs?6@
  00226	e9 a2 00 00 00	 jmp	 $LN46@translabel
$LN19@translabel:

; 184  :             char *p;
; 185  :             char *src;
; 186  :             char *dest;
; 187  :             size_t name_len;
; 188  :             if (Py_DebugFlag)

  0022b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  00232	74 11		 je	 SHORT $LN18@translabel

; 189  :                 printf("Label %s is a keyword\n", lb->lb_str);

  00234	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00238	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@IJIDICON@Label?5?$CFs?5is?5a?5keyword?6?$AA@
  0023f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN18@translabel:

; 190  :             lb->lb_type = NAME;
; 191  :             src = lb->lb_str + 1;

  00245	48 8b 73 08	 mov	 rsi, QWORD PTR [rbx+8]

; 192  :             p = strchr(src, '\'');

  00249	ba 27 00 00 00	 mov	 edx, 39			; 00000027H
  0024e	c7 03 01 00 00
	00		 mov	 DWORD PTR [rbx], 1
  00254	48 ff c6	 inc	 rsi
  00257	48 8b ce	 mov	 rcx, rsi
  0025a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  00260	48 8b f8	 mov	 rdi, rax

; 193  :             if (p)

  00263	48 85 c0	 test	 rax, rax
  00266	74 05		 je	 SHORT $LN17@translabel

; 194  :                 name_len = p - src;

  00268	48 2b fe	 sub	 rdi, rsi

; 195  :             else

  0026b	eb 10		 jmp	 SHORT $LN16@translabel
$LN17@translabel:

; 196  :                 name_len = strlen(src);

  0026d	48 83 c9 ff	 or	 rcx, -1
  00271	48 8b fe	 mov	 rdi, rsi
  00274	f2 ae		 repne scasb
  00276	48 f7 d1	 not	 rcx
  00279	48 8d 79 ff	 lea	 rdi, QWORD PTR [rcx-1]
$LN16@translabel:

; 197  :             dest = (char *)malloc(name_len + 1);

  0027d	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
  00281	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 198  :             if (!dest) {
; 199  :                 printf("Can't alloc dest '%s'\n", src);

  00287	48 8b d6	 mov	 rdx, rsi
  0028a	48 8b e8	 mov	 rbp, rax
  0028d	48 85 c0	 test	 rax, rax
  00290	75 09		 jne	 SHORT $LN15@translabel
  00292	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@GEDIIBCK@Can?8t?5alloc?5dest?5?8?$CFs?8?6?$AA@

; 200  :                 return;

  00299	eb 32		 jmp	 SHORT $LN46@translabel
$LN15@translabel:

; 201  :             }
; 202  :             strncpy(dest, src, name_len);

  0029b	4c 8b c7	 mov	 r8, rdi
  0029e	48 8b c8	 mov	 rcx, rax
  002a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 203  :             dest[name_len] = '\0';

  002a7	c6 04 2f 00	 mov	 BYTE PTR [rdi+rbp], 0

; 204  :             free(lb->lb_str);

  002ab	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  002af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 205  :             lb->lb_str = dest;

  002b5	48 89 6b 08	 mov	 QWORD PTR [rbx+8], rbp

; 246  :     }
; 247  :     else

  002b9	eb 18		 jmp	 SHORT $LN1@translabel
$LN21@translabel:

; 248  :         printf("Can't translate label '%s'\n",
; 249  :                PyGrammar_LabelRepr(lb));

  002bb	48 8b cb	 mov	 rcx, rbx
  002be	e8 00 00 00 00	 call	 PyGrammar_LabelRepr
  002c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@MCBIKPJI@Can?8t?5translate?5label?5?8?$CFs?8?6?$AA@
  002ca	48 8b d0	 mov	 rdx, rax
$LN46@translabel:
  002cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN1@translabel:
  002d3	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  002d8	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  002dd	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 250  : }

  002e2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002e6	41 5d		 pop	 r13
  002e8	41 5c		 pop	 r12
  002ea	5b		 pop	 rbx
  002eb	c3		 ret	 0
translabel ENDP
_TEXT	ENDS
PUBLIC	_Py_translatelabels
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_translatelabels DD imagerel $LN8
	DD	imagerel $LN8+69
	DD	imagerel $unwind$_Py_translatelabels
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_translatelabels DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _Py_translatelabels
_TEXT	SEGMENT
g$ = 48
_Py_translatelabels PROC				; COMDAT

; 133  : {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 134  :     int i;
; 135  : 
; 136  : #ifdef Py_DEBUG
; 137  :     printf("Translating labels ...\n");
; 138  : #endif
; 139  :     /* Don't translate EMPTY */
; 140  :     for (i = EMPTY+1; i < g->g_ll.ll_nlabels; i++)

  0000a	bf 01 00 00 00	 mov	 edi, 1
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	39 79 10	 cmp	 DWORD PTR [rcx+16], edi
  00015	7e 23		 jle	 SHORT $LN1@Py_transla
  00017	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL3@Py_transla:

; 141  :         translabel(g, &g->g_ll.ll_label[i]);

  00020	48 63 d7	 movsxd	 rdx, edi
  00023	48 8b cb	 mov	 rcx, rbx
  00026	48 c1 e2 04	 shl	 rdx, 4
  0002a	48 03 53 18	 add	 rdx, QWORD PTR [rbx+24]
  0002e	e8 00 00 00 00	 call	 translabel
  00033	ff c7		 inc	 edi
  00035	3b 7b 10	 cmp	 edi, DWORD PTR [rbx+16]
  00038	7c e6		 jl	 SHORT $LL3@Py_transla
$LN1@Py_transla:

; 142  : }

  0003a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
_Py_translatelabels ENDP
_TEXT	ENDS
END
