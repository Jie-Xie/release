; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
CONST	ENDS
PUBLIC	inflateBackInit_
EXTRN	zcfree:PROC
EXTRN	zcalloc:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\zlib\infback.c
pdata	SEGMENT
$pdata$inflateBackInit_ DD imagerel $LN12
	DD	imagerel $LN12+83
	DD	imagerel $unwind$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateBackInit_ DD imagerel $LN12+83
	DD	imagerel $LN12+197
	DD	imagerel $chain$1$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBackInit_ DD imagerel $LN12+197
	DD	imagerel $LN12+230
	DD	imagerel $chain$3$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBackInit_ DD imagerel $LN12+230
	DD	imagerel $LN12+272
	DD	imagerel $chain$4$inflateBackInit_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBackInit_ DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+83
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBackInit_ DD 040021H
	DD	07c400H
	DD	066400H
	DD	imagerel $LN12
	DD	imagerel $LN12+83
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateBackInit_ DD 040a21H
	DD	07c40aH
	DD	066405H
	DD	imagerel $LN12
	DD	imagerel $LN12+83
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackInit_ DD 060f01H
	DD	09540fH
	DD	08340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflateBackInit_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
window$ = 64
version$ = 72
stream_size$ = 80
inflateBackInit_ PROC					; COMDAT

; 34   : {

$LN12:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b e8	 mov	 rbp, r8
  00012	8b fa		 mov	 edi, edx
  00014	48 8b d9	 mov	 rbx, rcx

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 38   :         stream_size != (int)(sizeof(z_stream)))

  00017	4d 85 c9	 test	 r9, r9
  0001a	0f 84 db 00 00
	00		 je	 $LN6@inflateBac
  00020	41 80 39 31	 cmp	 BYTE PTR [r9], 49	; 00000031H
  00024	0f 85 d1 00 00
	00		 jne	 $LN6@inflateBac
  0002a	83 7c 24 50 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  0002f	0f 85 c6 00 00
	00		 jne	 $LN6@inflateBac

; 39   :         return Z_VERSION_ERROR;
; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  00035	48 85 c9	 test	 rcx, rcx
  00038	0f 84 a8 00 00
	00		 je	 $LN4@inflateBac
  0003e	4d 85 c0	 test	 r8, r8
  00041	0f 84 9f 00 00
	00		 je	 $LN4@inflateBac
  00047	8d 42 f8	 lea	 eax, DWORD PTR [rdx-8]
  0004a	83 f8 07	 cmp	 eax, 7
  0004d	0f 87 93 00 00
	00		 ja	 $LN4@inflateBac

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */

  00053	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00058	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  0005d	45 33 e4	 xor	 r12d, r12d
  00060	4c 89 61 20	 mov	 QWORD PTR [rcx+32], r12

; 44   :     if (strm->zalloc == (alloc_func)0) {

  00064	4c 39 61 30	 cmp	 QWORD PTR [rcx+48], r12
  00068	75 0f		 jne	 SHORT $LN3@inflateBac

; 45   :         strm->zalloc = zcalloc;

  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 46   :         strm->opaque = (voidpf)0;

  00071	4c 89 61 40	 mov	 QWORD PTR [rcx+64], r12
  00075	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN3@inflateBac:

; 47   :     }
; 48   :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  00079	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zcfree

; 49   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,
; 50   :                                                sizeof(struct inflate_state));

  00084	be 01 00 00 00	 mov	 esi, 1
  00089	49 3b c4	 cmp	 rax, r12
  0008c	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  00092	8b d6		 mov	 edx, esi
  00094	48 0f 44 c1	 cmove	 rax, rcx
  00098	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0009c	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
  000a0	ff 53 30	 call	 QWORD PTR [rbx+48]

; 51   :     if (state == Z_NULL) return Z_MEM_ERROR;

  000a3	48 85 c0	 test	 rax, rax
  000a6	75 1d		 jne	 SHORT $LN1@inflateBac
  000a8	8d 46 fb	 lea	 eax, QWORD PTR [rsi-5]
$LN11@inflateBac:
  000ab	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000b0	4c 8b 64 24 38	 mov	 r12, QWORD PTR [rsp+56]

; 61   : }

  000b5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ba	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000bf	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c3	5f		 pop	 rdi
  000c4	c3		 ret	 0
$LN1@inflateBac:

; 52   :     Tracev((stderr, "inflate: allocated\n"));
; 53   :     strm->state = (struct internal_state FAR *)state;

  000c5	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 54   :     state->dmax = 32768U;
; 55   :     state->wbits = windowBits;
; 56   :     state->wsize = 1U << windowBits;

  000c9	8b cf		 mov	 ecx, edi
  000cb	c7 40 14 00 80
	00 00		 mov	 DWORD PTR [rax+20], 32768 ; 00008000H
  000d2	d3 e6		 shl	 esi, cl
  000d4	89 78 28	 mov	 DWORD PTR [rax+40], edi

; 57   :     state->window = window;

  000d7	48 89 68 38	 mov	 QWORD PTR [rax+56], rbp
  000db	89 70 2c	 mov	 DWORD PTR [rax+44], esi

; 58   :     state->wnext = 0;

  000de	4c 89 60 30	 mov	 QWORD PTR [rax+48], r12

; 59   :     state->whave = 0;
; 60   :     return Z_OK;

  000e2	33 c0		 xor	 eax, eax
  000e4	eb c5		 jmp	 SHORT $LN11@inflateBac
$LN4@inflateBac:

; 42   :         return Z_STREAM_ERROR;

  000e6	b8 fe ff ff ff	 mov	 eax, -2

; 61   : }

  000eb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000f0	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000f5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f9	5f		 pop	 rdi
  000fa	c3		 ret	 0
$LN6@inflateBac:
  000fb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00100	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00105	b8 fa ff ff ff	 mov	 eax, -6
  0010a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010e	5f		 pop	 rdi
  0010f	c3		 ret	 0
inflateBackInit_ ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 76   : #ifdef BUILDFIXED
; 77   :     static int virgin = 1;
; 78   :     static code *lenfix, *distfix;
; 79   :     static code fixed[544];
; 80   : 
; 81   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 82   :     if (virgin) {
; 83   :         unsigned sym, bits;
; 84   :         static code *next;
; 85   : 
; 86   :         /* literal/length table */
; 87   :         sym = 0;
; 88   :         while (sym < 144) state->lens[sym++] = 8;
; 89   :         while (sym < 256) state->lens[sym++] = 9;
; 90   :         while (sym < 280) state->lens[sym++] = 7;
; 91   :         while (sym < 288) state->lens[sym++] = 8;
; 92   :         next = fixed;
; 93   :         lenfix = next;
; 94   :         bits = 9;
; 95   :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 96   : 
; 97   :         /* distance table */
; 98   :         sym = 0;
; 99   :         while (sym < 32) state->lens[sym++] = 5;
; 100  :         distfix = next;
; 101  :         bits = 5;
; 102  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 103  : 
; 104  :         /* do this just once */
; 105  :         virgin = 0;
; 106  :     }
; 107  : #else /* !BUILDFIXED */
; 108  : #   include "inffixed.h"
; 109  : #endif /* BUILDFIXED */
; 110  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 111  :     state->lenbits = 9;

  00007	c7 41 68 09 00
	00 00		 mov	 DWORD PTR [rcx+104], 9

; 112  :     state->distcode = distfix;
; 113  :     state->distbits = 5;

  0000e	c7 41 6c 05 00
	00 00		 mov	 DWORD PTR [rcx+108], 5
  00015	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax
  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00020	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 114  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	inflateBack
EXTRN	inflate_fast:PROC
EXTRN	inflate_table:PROC
EXTRN	__ImageBase:BYTE
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBack DD imagerel $LN457
	DD	imagerel $LN457+66
	DD	imagerel $unwind$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBack DD imagerel $LN457+66
	DD	imagerel $LN457+3806
	DD	imagerel $chain$3$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBack DD imagerel $LN457+3806
	DD	imagerel $LN457+3824
	DD	imagerel $chain$4$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflateBack DD imagerel $LN457+3824
	DD	imagerel $LN457+3900
	DD	imagerel $chain$5$inflateBack
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflateBack DD 080021H
	DD	0bd400H
	DD	0c7400H
	DD	0d6400H
	DD	0e3400H
	DD	imagerel $LN457
	DD	imagerel $LN457+66
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBack DD 021H
	DD	imagerel $LN457
	DD	imagerel $LN457+66
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBack DD 082221H
	DD	0bd422H
	DD	0c741eH
	DD	0d6408H
	DD	0e3404H
	DD	imagerel $LN457
	DD	imagerel $LN457+66
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBack DD 052101H
	DD	0f01ae221H
	DD	0c016e018H
	DD	05014H
xdata	ENDS
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT inflateBack
_TEXT	SEGMENT
left$1$ = 48
last$ = 52
here$ = 52
next$ = 56
put$1$ = 64
strm$ = 160
in$ = 168
in_desc$ = 176
out$ = 184
out_desc$ = 192
inflateBack PROC					; COMDAT

; 247  : {

$LN457:
  00000	48 8b c4	 mov	 rax, rsp
  00003	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  00007	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000b	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  0000f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00013	55		 push	 rbp
  00014	41 54		 push	 r12
  00016	41 56		 push	 r14
  00018	41 57		 push	 r15
  0001a	48 8b ec	 mov	 rbp, rsp
  0001d	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00021	4d 8b f0	 mov	 r14, r8
  00024	4c 8b e2	 mov	 r12, rdx
  00027	4c 8b c1	 mov	 r8, rcx

; 248  :     struct inflate_state FAR *state;
; 249  :     unsigned char FAR *next;    /* next input */
; 250  :     unsigned char FAR *put;     /* next output */
; 251  :     unsigned have, left;        /* available input and output */
; 252  :     unsigned long hold;         /* bit buffer */
; 253  :     unsigned bits;              /* bits in bit buffer */
; 254  :     unsigned copy;              /* number of stored or match bytes to copy */
; 255  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 256  :     code here;                  /* current decoding table entry */
; 257  :     code last;                  /* parent table entry */
; 258  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 259  :     int ret;                    /* return code */
; 260  :     static const unsigned short order[19] = /* permutation of code lengths */
; 261  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 262  : 
; 263  :     /* Check that the strm exists and that the state was initialized */
; 264  :     if (strm == Z_NULL || strm->state == Z_NULL)

  0002a	48 85 c9	 test	 rcx, rcx
  0002d	0f 84 ab 0e 00
	00		 je	 $LN346@inflateBac@2
  00033	4c 8b 79 28	 mov	 r15, QWORD PTR [rcx+40]
  00037	4d 85 ff	 test	 r15, r15
  0003a	0f 84 9e 0e 00
	00		 je	 $LN346@inflateBac@2

; 266  :     state = (struct inflate_state FAR *)strm->state;
; 267  : 
; 268  :     /* Reset the state */
; 269  :     strm->msg = Z_NULL;

  00040	33 d2		 xor	 edx, edx
  00042	48 89 58 d8	 mov	 QWORD PTR [rax-40], rbx
  00046	48 89 70 d0	 mov	 QWORD PTR [rax-48], rsi
  0004a	48 89 51 20	 mov	 QWORD PTR [rcx+32], rdx

; 270  :     state->mode = TYPE;

  0004e	49 c7 07 0b 00
	00 00		 mov	 QWORD PTR [r15], 11

; 271  :     state->last = 0;
; 272  :     state->whave = 0;

  00055	41 89 57 30	 mov	 DWORD PTR [r15+48], edx

; 273  :     next = strm->next_in;

  00059	4c 8b 11	 mov	 r10, QWORD PTR [rcx]
  0005c	48 89 78 c8	 mov	 QWORD PTR [rax-56], rdi
  00060	4c 89 68 c0	 mov	 QWORD PTR [rax-64], r13
  00064	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10

; 274  :     have = next != Z_NULL ? strm->avail_in : 0;

  00068	4d 85 d2	 test	 r10, r10
  0006b	74 05		 je	 SHORT $LN350@inflateBac@2
  0006d	8b 79 08	 mov	 edi, DWORD PTR [rcx+8]
  00070	eb 02		 jmp	 SHORT $LN351@inflateBac@2
$LN350@inflateBac@2:
  00072	8b fa		 mov	 edi, edx
$LN351@inflateBac@2:

; 275  :     hold = 0;
; 276  :     bits = 0;
; 277  :     put = state->window;
; 278  :     left = state->wsize;
; 279  : 
; 280  :     /* Inflate until end of block marked as last */
; 281  :     for (;;)
; 282  :         switch (state->mode) {

  00074	41 8b 07	 mov	 eax, DWORD PTR [r15]
  00077	49 8b 5f 38	 mov	 rbx, QWORD PTR [r15+56]
  0007b	45 8b 4f 2c	 mov	 r9d, DWORD PTR [r15+44]
  0007f	83 e8 0b	 sub	 eax, 11
  00082	44 8b ea	 mov	 r13d, edx
  00085	8b f2		 mov	 esi, edx
  00087	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  0008b	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  0008f	83 f8 12	 cmp	 eax, 18
  00092	0f 87 13 0e 00
	00		 ja	 $LN1@inflateBac@2
$LN452@inflateBac@2:
  00098	48 98		 cdqe
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000a1	41 bb 01 00 00
	00		 mov	 r11d, 1
  000a7	8b 8c 81 00 00
	00 00		 mov	 ecx, DWORD PTR $LN430@inflateBac@2[rcx+rax*4]
  000ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  000b5	48 03 c8	 add	 rcx, rax
  000b8	ff e1		 jmp	 rcx
$LN341@inflateBac@2:

; 283  :         case TYPE:
; 284  :             /* determine and dispatch block type */
; 285  :             if (state->last) {

  000ba	41 83 7f 04 00	 cmp	 DWORD PTR [r15+4], 0
  000bf	74 1a		 je	 SHORT $LN336@inflateBac@2

; 286  :                 BYTEBITS();

  000c1	8b ce		 mov	 ecx, esi

; 287  :                 state->mode = DONE;

  000c3	41 c7 07 1c 00
	00 00		 mov	 DWORD PTR [r15], 28

; 288  :                 break;

  000ca	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  000ce	83 e1 07	 and	 ecx, 7
  000d1	41 d3 ed	 shr	 r13d, cl
  000d4	2b f1		 sub	 esi, ecx
  000d6	e9 17 0a 00 00	 jmp	 $LN402@inflateBac@2
$LN336@inflateBac@2:

; 289  :             }
; 290  :             NEEDBITS(3);

  000db	83 fe 03	 cmp	 esi, 3
  000de	73 42		 jae	 SHORT $LN335@inflateBac@2
$LL333@inflateBac@2:
  000e0	85 ff		 test	 edi, edi
  000e2	75 18		 jne	 SHORT $LN327@inflateBac@2
  000e4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  000e8	49 8b ce	 mov	 rcx, r14
  000eb	41 ff d4	 call	 r12
  000ee	8b f8		 mov	 edi, eax
  000f0	85 c0		 test	 eax, eax
  000f2	0f 84 70 0d 00
	00		 je	 $LN377@inflateBac@2
  000f8	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN327@inflateBac@2:
  000fc	41 0f b6 12	 movzx	 edx, BYTE PTR [r10]
  00100	8b ce		 mov	 ecx, esi
  00102	49 ff c2	 inc	 r10
  00105	d3 e2		 shl	 edx, cl
  00107	83 c6 08	 add	 esi, 8
  0010a	ff cf		 dec	 edi
  0010c	44 03 ea	 add	 r13d, edx
  0010f	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00113	83 fe 03	 cmp	 esi, 3
  00116	72 c8		 jb	 SHORT $LL333@inflateBac@2
  00118	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  0011c	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00120	33 d2		 xor	 edx, edx
$LN335@inflateBac@2:

; 291  :             state->last = BITS(1);

  00122	41 8b c5	 mov	 eax, r13d

; 292  :             DROPBITS(1);

  00125	41 d1 ed	 shr	 r13d, 1
  00128	ff ce		 dec	 esi
  0012a	83 e0 01	 and	 eax, 1
  0012d	41 89 47 04	 mov	 DWORD PTR [r15+4], eax

; 293  :             switch (BITS(2)) {

  00131	41 8b c5	 mov	 eax, r13d
  00134	83 e0 03	 and	 eax, 3
  00137	74 64		 je	 SHORT $LN318@inflateBac@2
  00139	ff c8		 dec	 eax
  0013b	74 41		 je	 SHORT $LN317@inflateBac@2
  0013d	ff c8		 dec	 eax
  0013f	74 26		 je	 SHORT $LN316@inflateBac@2
  00141	ff c8		 dec	 eax
  00143	75 5f		 jne	 SHORT $LN314@inflateBac@2

; 309  :                 break;
; 310  :             case 3:
; 311  :                 strm->msg = (char *)"invalid block type";

  00145	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 312  :                 state->mode = BAD;
; 313  :             }
; 314  :             DROPBITS(2);

  0014c	41 c1 ed 02	 shr	 r13d, 2
  00150	83 c6 fe	 add	 esi, -2			; fffffffeH
  00153	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  00157	41 c7 07 1d 00
	00 00		 mov	 DWORD PTR [r15], 29

; 315  :             break;

  0015e	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00162	e9 8b 09 00 00	 jmp	 $LN402@inflateBac@2
$LN316@inflateBac@2:

; 304  :                 break;
; 305  :             case 2:                             /* dynamic block */
; 306  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 307  :                         state->last ? " (last)" : ""));
; 308  :                 state->mode = TABLE;

  00167	41 c7 07 10 00
	00 00		 mov	 DWORD PTR [r15], 16

; 315  :             break;

  0016e	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00172	41 c1 ed 02	 shr	 r13d, 2
  00176	83 c6 fe	 add	 esi, -2			; fffffffeH
  00179	e9 74 09 00 00	 jmp	 $LN402@inflateBac@2
$LN317@inflateBac@2:

; 298  :                 break;
; 299  :             case 1:                             /* fixed block */
; 300  :                 fixedtables(state);

  0017e	49 8b cf	 mov	 rcx, r15
  00181	e8 00 00 00 00	 call	 fixedtables

; 301  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 302  :                         state->last ? " (last)" : ""));
; 303  :                 state->mode = LEN;              /* decode codes */

  00186	41 c7 07 14 00
	00 00		 mov	 DWORD PTR [r15], 20

; 315  :             break;

  0018d	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00191	41 c1 ed 02	 shr	 r13d, 2
  00195	83 c6 fe	 add	 esi, -2			; fffffffeH
  00198	e9 55 09 00 00	 jmp	 $LN402@inflateBac@2
$LN318@inflateBac@2:

; 294  :             case 0:                             /* stored block */
; 295  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 296  :                         state->last ? " (last)" : ""));
; 297  :                 state->mode = STORED;

  0019d	41 c7 07 0d 00
	00 00		 mov	 DWORD PTR [r15], 13
$LN314@inflateBac@2:

; 315  :             break;

  001a4	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  001a8	41 c1 ed 02	 shr	 r13d, 2
  001ac	83 c6 fe	 add	 esi, -2			; fffffffeH
  001af	e9 3e 09 00 00	 jmp	 $LN402@inflateBac@2
$LN310@inflateBac@2:

; 316  : 
; 317  :         case STORED:
; 318  :             /* get and verify stored block length */
; 319  :             BYTEBITS();                         /* go to byte boundary */

  001b4	8b ce		 mov	 ecx, esi
  001b6	83 e1 07	 and	 ecx, 7
  001b9	2b f1		 sub	 esi, ecx
  001bb	41 d3 ed	 shr	 r13d, cl

; 320  :             NEEDBITS(32);

  001be	83 fe 20	 cmp	 esi, 32			; 00000020H
  001c1	73 42		 jae	 SHORT $LN306@inflateBac@2
$LL304@inflateBac@2:
  001c3	85 ff		 test	 edi, edi
  001c5	75 18		 jne	 SHORT $LN298@inflateBac@2
  001c7	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  001cb	49 8b ce	 mov	 rcx, r14
  001ce	41 ff d4	 call	 r12
  001d1	8b f8		 mov	 edi, eax
  001d3	85 c0		 test	 eax, eax
  001d5	0f 84 8d 0c 00
	00		 je	 $LN377@inflateBac@2
  001db	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN298@inflateBac@2:
  001df	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  001e3	8b ce		 mov	 ecx, esi
  001e5	49 ff c2	 inc	 r10
  001e8	d3 e0		 shl	 eax, cl
  001ea	83 c6 08	 add	 esi, 8
  001ed	ff cf		 dec	 edi
  001ef	44 03 e8	 add	 r13d, eax
  001f2	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  001f6	83 fe 20	 cmp	 esi, 32			; 00000020H
  001f9	72 c8		 jb	 SHORT $LL304@inflateBac@2
  001fb	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  001ff	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00203	33 d2		 xor	 edx, edx
$LN306@inflateBac@2:

; 321  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  00205	41 8b c5	 mov	 eax, r13d
  00208	41 0f b7 cd	 movzx	 ecx, r13w
  0020c	f7 d0		 not	 eax
  0020e	c1 e8 10	 shr	 eax, 16
  00211	3b c8		 cmp	 ecx, eax
  00213	74 1b		 je	 SHORT $LN294@inflateBac@2

; 322  :                 strm->msg = (char *)"invalid stored block lengths";

  00215	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  0021c	49 89 40 20	 mov	 QWORD PTR [r8+32], rax

; 323  :                 state->mode = BAD;

  00220	41 c7 07 1d 00
	00 00		 mov	 DWORD PTR [r15], 29

; 324  :                 break;

  00227	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  0022b	e9 c2 08 00 00	 jmp	 $LN402@inflateBac@2
$LN294@inflateBac@2:

; 325  :             }
; 326  :             state->length = (unsigned)hold & 0xffff;

  00230	41 89 4f 48	 mov	 DWORD PTR [r15+72], ecx

; 327  :             Tracev((stderr, "inflate:       stored length %u\n",
; 328  :                     state->length));
; 329  :             INITBITS();

  00234	44 8b ea	 mov	 r13d, edx
  00237	8b f2		 mov	 esi, edx

; 330  : 
; 331  :             /* copy stored block from input to output */
; 332  :             while (state->length != 0) {

  00239	85 c9		 test	 ecx, ecx
  0023b	0f 84 97 00 00
	00		 je	 $LN289@inflateBac@2
$LL290@inflateBac@2:

; 333  :                 copy = state->length;

  00241	45 8b 67 48	 mov	 r12d, DWORD PTR [r15+72]

; 334  :                 PULL();

  00245	85 ff		 test	 edi, edi
  00247	75 14		 jne	 SHORT $LN287@inflateBac@2
  00249	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0024d	49 8b ce	 mov	 rcx, r14
  00250	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00253	8b f8		 mov	 edi, eax
  00255	85 c0		 test	 eax, eax
  00257	0f 84 0b 0c 00
	00		 je	 $LN377@inflateBac@2
$LN287@inflateBac@2:

; 335  :                 ROOM();

  0025d	8b 5d b8	 mov	 ebx, DWORD PTR left$1$[rbp-120]
  00260	85 db		 test	 ebx, ebx
  00262	75 28		 jne	 SHORT $LN282@inflateBac@2
  00264	41 8b 5f 2c	 mov	 ebx, DWORD PTR [r15+44]
  00268	49 8b 47 38	 mov	 rax, QWORD PTR [r15+56]
  0026c	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00270	44 8b c3	 mov	 r8d, ebx
  00273	48 8b d0	 mov	 rdx, rax
  00276	48 89 45 c8	 mov	 QWORD PTR put$1$[rbp-120], rax
  0027a	89 5d b8	 mov	 DWORD PTR left$1$[rbp-120], ebx
  0027d	41 89 5f 30	 mov	 DWORD PTR [r15+48], ebx
  00281	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00284	85 c0		 test	 eax, eax
  00286	0f 85 10 08 00
	00		 jne	 $LN380@inflateBac@2
$LN282@inflateBac@2:

; 336  :                 if (copy > have) copy = have;
; 337  :                 if (copy > left) copy = left;
; 338  :                 zmemcpy(put, next, copy);

  0028c	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  00290	48 8b 4d c8	 mov	 rcx, QWORD PTR put$1$[rbp-120]
  00294	44 3b e7	 cmp	 r12d, edi
  00297	44 0f 47 e7	 cmova	 r12d, edi
  0029b	44 3b e3	 cmp	 r12d, ebx
  0029e	44 0f 47 e3	 cmova	 r12d, ebx
  002a2	45 8b c4	 mov	 r8d, r12d
  002a5	41 8b dc	 mov	 ebx, r12d
  002a8	e8 00 00 00 00	 call	 memcpy

; 339  :                 have -= copy;
; 340  :                 next += copy;
; 341  :                 left -= copy;

  002ad	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  002b1	48 01 5d c0	 add	 QWORD PTR next$[rbp-120], rbx

; 342  :                 put += copy;

  002b5	48 01 5d c8	 add	 QWORD PTR put$1$[rbp-120], rbx

; 343  :                 state->length -= copy;

  002b9	45 29 67 48	 sub	 DWORD PTR [r15+72], r12d
  002bd	45 2b cc	 sub	 r9d, r12d
  002c0	41 2b fc	 sub	 edi, r12d
  002c3	41 83 7f 48 00	 cmp	 DWORD PTR [r15+72], 0
  002c8	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  002cc	0f 85 6f ff ff
	ff		 jne	 $LL290@inflateBac@2
  002d2	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  002d6	33 d2		 xor	 edx, edx
$LN289@inflateBac@2:

; 344  :             }
; 345  :             Tracev((stderr, "inflate:       stored end\n"));
; 346  :             state->mode = TYPE;

  002d8	41 c7 07 0b 00
	00 00		 mov	 DWORD PTR [r15], 11

; 347  :             break;

  002df	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  002e3	e9 06 08 00 00	 jmp	 $LN446@inflateBac@2
$LN275@inflateBac@2:

; 348  : 
; 349  :         case TABLE:
; 350  :             /* get dynamic table entries descriptor */
; 351  :             NEEDBITS(14);

  002e8	83 fe 0e	 cmp	 esi, 14
  002eb	73 43		 jae	 SHORT $LN274@inflateBac@2
  002ed	0f 1f 00	 npad	 3
$LL272@inflateBac@2:
  002f0	85 ff		 test	 edi, edi
  002f2	75 18		 jne	 SHORT $LN266@inflateBac@2
  002f4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  002f8	49 8b ce	 mov	 rcx, r14
  002fb	41 ff d4	 call	 r12
  002fe	8b f8		 mov	 edi, eax
  00300	85 c0		 test	 eax, eax
  00302	0f 84 60 0b 00
	00		 je	 $LN377@inflateBac@2
  00308	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN266@inflateBac@2:
  0030c	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00310	8b ce		 mov	 ecx, esi
  00312	49 ff c2	 inc	 r10
  00315	d3 e0		 shl	 eax, cl
  00317	83 c6 08	 add	 esi, 8
  0031a	ff cf		 dec	 edi
  0031c	44 03 e8	 add	 r13d, eax
  0031f	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00323	83 fe 0e	 cmp	 esi, 14
  00326	72 c8		 jb	 SHORT $LL272@inflateBac@2
  00328	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  0032c	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
$LN274@inflateBac@2:

; 352  :             state->nlen = BITS(5) + 257;

  00330	41 8b c5	 mov	 eax, r13d

; 353  :             DROPBITS(5);

  00333	41 c1 ed 05	 shr	 r13d, 5

; 354  :             state->ndist = BITS(5) + 1;
; 355  :             DROPBITS(5);
; 356  :             state->ncode = BITS(4) + 4;
; 357  :             DROPBITS(4);

  00337	83 c6 f2	 add	 esi, -14		; fffffff2H
  0033a	41 8b cd	 mov	 ecx, r13d
  0033d	41 c1 ed 05	 shr	 r13d, 5
  00341	83 e0 1f	 and	 eax, 31
  00344	41 8b d5	 mov	 edx, r13d
  00347	83 e1 1f	 and	 ecx, 31
  0034a	05 01 01 00 00	 add	 eax, 257		; 00000101H
  0034f	83 e2 0f	 and	 edx, 15
  00352	ff c1		 inc	 ecx
  00354	41 c1 ed 04	 shr	 r13d, 4
  00358	83 c2 04	 add	 edx, 4
  0035b	41 89 47 74	 mov	 DWORD PTR [r15+116], eax
  0035f	41 89 4f 78	 mov	 DWORD PTR [r15+120], ecx
  00363	41 89 57 70	 mov	 DWORD PTR [r15+112], edx

; 358  : #ifndef PKZIP_BUG_WORKAROUND
; 359  :             if (state->nlen > 286 || state->ndist > 30) {

  00367	3d 1e 01 00 00	 cmp	 eax, 286		; 0000011eH
  0036c	0f 87 69 05 00
	00		 ja	 $LN252@inflateBac@2
  00372	83 f9 1e	 cmp	 ecx, 30
  00375	0f 87 60 05 00
	00		 ja	 $LN252@inflateBac@2

; 363  :             }
; 364  : #endif
; 365  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 366  : 
; 367  :             /* get code length code lengths (not a typo) */
; 368  :             state->have = 0;

  0037b	33 db		 xor	 ebx, ebx

; 369  :             while (state->have < state->ncode) {

  0037d	85 d2		 test	 edx, edx
  0037f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00386	41 89 5f 7c	 mov	 DWORD PTR [r15+124], ebx
  0038a	0f 84 80 00 00
	00		 je	 $LN359@inflateBac@2
$LL251@inflateBac@2:

; 370  :                 NEEDBITS(3);

  00390	83 fe 03	 cmp	 esi, 3
  00393	73 49		 jae	 SHORT $LN248@inflateBac@2
  00395	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  00399	0f 1f 80 00 00
	00 00		 npad	 7
$LL246@inflateBac@2:
  003a0	85 ff		 test	 edi, edi
  003a2	75 18		 jne	 SHORT $LN240@inflateBac@2
  003a4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  003a8	49 8b ce	 mov	 rcx, r14
  003ab	41 ff d4	 call	 r12
  003ae	8b f8		 mov	 edi, eax
  003b0	85 c0		 test	 eax, eax
  003b2	0f 84 bb 0a 00
	00		 je	 $LN382@inflateBac@2
  003b8	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN240@inflateBac@2:
  003bc	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  003bf	8b ce		 mov	 ecx, esi
  003c1	48 ff c2	 inc	 rdx
  003c4	d3 e0		 shl	 eax, cl
  003c6	83 c6 08	 add	 esi, 8
  003c9	ff cf		 dec	 edi
  003cb	44 03 e8	 add	 r13d, eax
  003ce	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  003d2	83 fe 03	 cmp	 esi, 3
  003d5	72 c9		 jb	 SHORT $LL246@inflateBac@2
  003d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
$LN248@inflateBac@2:

; 371  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  003de	41 8b 47 7c	 mov	 eax, DWORD PTR [r15+124]
  003e2	41 0f b7 cd	 movzx	 ecx, r13w

; 372  :                 DROPBITS(3);

  003e6	83 c6 fd	 add	 esi, -3			; fffffffdH
  003e9	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[rdx+rax*2]
  003f1	66 83 e1 07	 and	 cx, 7
  003f5	41 c1 ed 03	 shr	 r13d, 3
  003f9	66 41 89 8c 47
	88 00 00 00	 mov	 WORD PTR [r15+rax*2+136], cx
  00402	41 ff 47 7c	 inc	 DWORD PTR [r15+124]
  00406	41 8b 47 70	 mov	 eax, DWORD PTR [r15+112]
  0040a	41 39 47 7c	 cmp	 DWORD PTR [r15+124], eax
  0040e	72 80		 jb	 SHORT $LL251@inflateBac@2
$LN359@inflateBac@2:

; 373  :             }
; 374  :             while (state->have < 19)

  00410	41 83 7f 7c 13	 cmp	 DWORD PTR [r15+124], 19
  00415	73 29		 jae	 SHORT $LN232@inflateBac@2
  00417	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL233@inflateBac@2:

; 375  :                 state->lens[order[state->have++]] = 0;

  00420	41 8b 47 7c	 mov	 eax, DWORD PTR [r15+124]
  00424	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[rdx+rax*2]
  0042c	66 41 89 9c 47
	88 00 00 00	 mov	 WORD PTR [r15+rax*2+136], bx
  00435	41 ff 47 7c	 inc	 DWORD PTR [r15+124]
  00439	41 83 7f 7c 13	 cmp	 DWORD PTR [r15+124], 19
  0043e	72 e0		 jb	 SHORT $LL233@inflateBac@2
$LN232@inflateBac@2:

; 376  :             state->next = state->codes;

  00440	49 8d 8f 48 05
	00 00		 lea	 rcx, QWORD PTR [r15+1352]

; 377  :             state->lencode = (code const FAR *)(state->next);
; 378  :             state->lenbits = 7;

  00447	49 8d 5f 68	 lea	 rbx, QWORD PTR [r15+104]

; 379  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 380  :                                 &(state->lenbits), state->work);

  0044b	49 8d 97 88 00
	00 00		 lea	 rdx, QWORD PTR [r15+136]
  00452	49 89 8f 80 00
	00 00		 mov	 QWORD PTR [r15+128], rcx
  00459	49 89 4f 58	 mov	 QWORD PTR [r15+88], rcx
  0045d	49 8d 8f 08 03
	00 00		 lea	 rcx, QWORD PTR [r15+776]
  00464	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00469	33 c9		 xor	 ecx, ecx
  0046b	4d 8d 8f 80 00
	00 00		 lea	 r9, QWORD PTR [r15+128]
  00472	44 8d 41 13	 lea	 r8d, QWORD PTR [rcx+19]
  00476	c7 03 07 00 00
	00		 mov	 DWORD PTR [rbx], 7
  0047c	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00481	e8 00 00 00 00	 call	 inflate_table

; 381  :             if (ret) {

  00486	85 c0		 test	 eax, eax
  00488	74 29		 je	 SHORT $LN231@inflateBac@2

; 382  :                 strm->msg = (char *)"invalid code lengths set";

  0048a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
$LN454@inflateBac@2:
  00491	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 383  :                 state->mode = BAD;
; 384  :                 break;

  00495	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00499	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  0049d	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  004a1	41 c7 07 1d 00
	00 00		 mov	 DWORD PTR [r15], 29
  004a8	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  004ac	33 d2		 xor	 edx, edx
  004ae	e9 3f 06 00 00	 jmp	 $LN402@inflateBac@2
$LN231@inflateBac@2:

; 385  :             }
; 386  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 387  : 
; 388  :             /* get length and distance code code lengths */
; 389  :             state->have = 0;
; 390  :             while (state->have < state->nlen + state->ndist) {

  004b3	41 8b 47 78	 mov	 eax, DWORD PTR [r15+120]
  004b7	41 c7 47 7c 00
	00 00 00	 mov	 DWORD PTR [r15+124], 0
  004bf	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  004c3	41 03 47 74	 add	 eax, DWORD PTR [r15+116]
  004c7	0f 84 9a 02 00
	00		 je	 $LN229@inflateBac@2
  004cd	0f 1f 00	 npad	 3
$LL230@inflateBac@2:

; 391  :                 for (;;) {
; 392  :                     here = state->lencode[BITS(state->lenbits)];

  004d0	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  004d2	b8 01 00 00 00	 mov	 eax, 1
  004d7	d3 e0		 shl	 eax, cl
  004d9	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  004dc	41 8b c5	 mov	 eax, r13d
  004df	48 23 c8	 and	 rcx, rax
  004e2	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  004e6	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]

; 393  :                     if ((unsigned)(here.bits) <= bits) break;

  004e9	8b c8		 mov	 ecx, eax
  004eb	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  004ee	c1 e9 08	 shr	 ecx, 8
  004f1	0f b6 c9	 movzx	 ecx, cl
  004f4	3b ce		 cmp	 ecx, esi
  004f6	76 5b		 jbe	 SHORT $LN383@inflateBac@2
$LL228@inflateBac@2:

; 394  :                     PULLBYTE();

  004f8	85 ff		 test	 edi, edi
  004fa	75 18		 jne	 SHORT $LN221@inflateBac@2
  004fc	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00500	49 8b ce	 mov	 rcx, r14
  00503	41 ff d4	 call	 r12
  00506	8b f8		 mov	 edi, eax
  00508	85 c0		 test	 eax, eax
  0050a	0f 84 58 09 00
	00		 je	 $LN377@inflateBac@2
  00510	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN221@inflateBac@2:
  00514	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00518	8b ce		 mov	 ecx, esi
  0051a	49 ff c2	 inc	 r10
  0051d	d3 e0		 shl	 eax, cl
  0051f	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00523	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00525	44 03 e8	 add	 r13d, eax
  00528	b8 01 00 00 00	 mov	 eax, 1
  0052d	83 c6 08	 add	 esi, 8
  00530	d3 e0		 shl	 eax, cl
  00532	ff cf		 dec	 edi
  00534	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00537	41 8b c5	 mov	 eax, r13d
  0053a	48 23 c8	 and	 rcx, rax
  0053d	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  00541	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00544	8b c8		 mov	 ecx, eax
  00546	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  00549	c1 e9 08	 shr	 ecx, 8
  0054c	0f b6 c9	 movzx	 ecx, cl
  0054f	3b ce		 cmp	 ecx, esi
  00551	77 a5		 ja	 SHORT $LL228@inflateBac@2
$LN383@inflateBac@2:

; 395  :                 }
; 396  :                 if (here.val < 16) {

  00553	8b c8		 mov	 ecx, eax
  00555	c1 e9 10	 shr	 ecx, 16
  00558	66 83 f9 10	 cmp	 cx, 16
  0055c	73 72		 jae	 SHORT $LN217@inflateBac@2

; 397  :                     NEEDBITS(here.bits);

  0055e	0f b6 5d bd	 movzx	 ebx, BYTE PTR here$[rbp-119]
  00562	c1 e8 08	 shr	 eax, 8
  00565	0f b6 c8	 movzx	 ecx, al
  00568	3b f1		 cmp	 esi, ecx
  0056a	73 3e		 jae	 SHORT $LN215@inflateBac@2
  0056c	0f 1f 40 00	 npad	 4
$LL213@inflateBac@2:
  00570	85 ff		 test	 edi, edi
  00572	75 18		 jne	 SHORT $LN207@inflateBac@2
  00574	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00578	49 8b ce	 mov	 rcx, r14
  0057b	41 ff d4	 call	 r12
  0057e	8b f8		 mov	 edi, eax
  00580	85 c0		 test	 eax, eax
  00582	0f 84 e0 08 00
	00		 je	 $LN377@inflateBac@2
  00588	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN207@inflateBac@2:
  0058c	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00590	8b ce		 mov	 ecx, esi
  00592	49 ff c2	 inc	 r10
  00595	d3 e0		 shl	 eax, cl
  00597	83 c6 08	 add	 esi, 8
  0059a	ff cf		 dec	 edi
  0059c	44 03 e8	 add	 r13d, eax
  0059f	0f b6 c3	 movzx	 eax, bl
  005a2	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  005a6	3b f0		 cmp	 esi, eax
  005a8	72 c6		 jb	 SHORT $LL213@inflateBac@2
$LN215@inflateBac@2:

; 398  :                     DROPBITS(here.bits);
; 399  :                     state->lens[state->have++] = here.val;

  005aa	0f b7 45 be	 movzx	 eax, WORD PTR here$[rbp-118]
  005ae	0f b6 cb	 movzx	 ecx, bl
  005b1	41 d3 ed	 shr	 r13d, cl
  005b4	2b f1		 sub	 esi, ecx
  005b6	41 8b 4f 7c	 mov	 ecx, DWORD PTR [r15+124]
  005ba	66 41 89 84 4f
	88 00 00 00	 mov	 WORD PTR [r15+rcx*2+136], ax
  005c3	41 ff 47 7c	 inc	 DWORD PTR [r15+124]

; 400  :                 }
; 401  :                 else {

  005c7	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  005cb	e9 81 01 00 00	 jmp	 $LN416@inflateBac@2
$LN217@inflateBac@2:

; 402  :                     if (here.val == 16) {

  005d0	0f b7 45 be	 movzx	 eax, WORD PTR here$[rbp-118]

; 403  :                         NEEDBITS(here.bits + 2);

  005d4	44 0f b6 65 bd	 movzx	 r12d, BYTE PTR here$[rbp-119]
  005d9	66 83 f8 10	 cmp	 ax, 16
  005dd	75 77		 jne	 SHORT $LN199@inflateBac@2
  005df	41 8d 5c 24 02	 lea	 ebx, DWORD PTR [r12+2]
  005e4	3b f3		 cmp	 esi, ebx
  005e6	73 37		 jae	 SHORT $LN197@inflateBac@2
$LL195@inflateBac@2:
  005e8	85 ff		 test	 edi, edi
  005ea	75 18		 jne	 SHORT $LN189@inflateBac@2
  005ec	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  005f0	49 8b ce	 mov	 rcx, r14
  005f3	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  005f6	8b f8		 mov	 edi, eax
  005f8	85 c0		 test	 eax, eax
  005fa	0f 84 68 08 00
	00		 je	 $LN377@inflateBac@2
  00600	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN189@inflateBac@2:
  00604	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00608	8b ce		 mov	 ecx, esi
  0060a	49 ff c2	 inc	 r10
  0060d	d3 e0		 shl	 eax, cl
  0060f	83 c6 08	 add	 esi, 8
  00612	ff cf		 dec	 edi
  00614	44 03 e8	 add	 r13d, eax
  00617	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  0061b	3b f3		 cmp	 esi, ebx
  0061d	72 c9		 jb	 SHORT $LL195@inflateBac@2
$LN197@inflateBac@2:

; 404  :                         DROPBITS(here.bits);
; 405  :                         if (state->have == 0) {

  0061f	41 8b 47 7c	 mov	 eax, DWORD PTR [r15+124]
  00623	41 8b cc	 mov	 ecx, r12d
  00626	41 2b f4	 sub	 esi, r12d
  00629	41 d3 ed	 shr	 r13d, cl
  0062c	85 c0		 test	 eax, eax
  0062e	0f 84 54 01 00
	00		 je	 $LN389@inflateBac@2

; 409  :                         }
; 410  :                         len = (unsigned)(state->lens[state->have - 1]);
; 411  :                         copy = 3 + BITS(2);

  00634	45 8b c5	 mov	 r8d, r13d
  00637	ff c8		 dec	 eax

; 412  :                         DROPBITS(2);

  00639	41 c1 ed 02	 shr	 r13d, 2
  0063d	45 0f b7 8c 47
	88 00 00 00	 movzx	 r9d, WORD PTR [r15+rax*2+136]
  00646	41 83 e0 03	 and	 r8d, 3
  0064a	41 83 c0 03	 add	 r8d, 3
  0064e	83 c6 fe	 add	 esi, -2			; fffffffeH

; 413  :                     }
; 414  :                     else if (here.val == 17) {

  00651	e9 c4 00 00 00	 jmp	 $LN138@inflateBac@2
$LN199@inflateBac@2:
  00656	66 83 f8 11	 cmp	 ax, 17
  0065a	75 5c		 jne	 SHORT $LN156@inflateBac@2

; 415  :                         NEEDBITS(here.bits + 3);

  0065c	41 8d 5c 24 03	 lea	 ebx, DWORD PTR [r12+3]
  00661	3b f3		 cmp	 esi, ebx
  00663	73 37		 jae	 SHORT $LN175@inflateBac@2
$LL173@inflateBac@2:
  00665	85 ff		 test	 edi, edi
  00667	75 18		 jne	 SHORT $LN167@inflateBac@2
  00669	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0066d	49 8b ce	 mov	 rcx, r14
  00670	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00673	8b f8		 mov	 edi, eax
  00675	85 c0		 test	 eax, eax
  00677	0f 84 eb 07 00
	00		 je	 $LN377@inflateBac@2
  0067d	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN167@inflateBac@2:
  00681	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00685	8b ce		 mov	 ecx, esi
  00687	49 ff c2	 inc	 r10
  0068a	d3 e0		 shl	 eax, cl
  0068c	83 c6 08	 add	 esi, 8
  0068f	ff cf		 dec	 edi
  00691	44 03 e8	 add	 r13d, eax
  00694	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00698	3b f3		 cmp	 esi, ebx
  0069a	72 c9		 jb	 SHORT $LL173@inflateBac@2
$LN175@inflateBac@2:

; 416  :                         DROPBITS(here.bits);

  0069c	41 8b cc	 mov	 ecx, r12d

; 417  :                         len = 0;
; 418  :                         copy = 3 + BITS(3);
; 419  :                         DROPBITS(3);

  0069f	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  006a4	41 d3 ed	 shr	 r13d, cl
  006a7	45 8b c5	 mov	 r8d, r13d
  006aa	41 83 e0 07	 and	 r8d, 7
  006ae	41 83 c0 03	 add	 r8d, 3
  006b2	41 c1 ed 03	 shr	 r13d, 3

; 420  :                     }
; 421  :                     else {

  006b6	eb 5a		 jmp	 SHORT $LN447@inflateBac@2
$LN156@inflateBac@2:

; 422  :                         NEEDBITS(here.bits + 7);

  006b8	41 8d 5c 24 07	 lea	 ebx, DWORD PTR [r12+7]
  006bd	3b f3		 cmp	 esi, ebx
  006bf	73 37		 jae	 SHORT $LN155@inflateBac@2
$LL153@inflateBac@2:
  006c1	85 ff		 test	 edi, edi
  006c3	75 18		 jne	 SHORT $LN147@inflateBac@2
  006c5	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  006c9	49 8b ce	 mov	 rcx, r14
  006cc	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  006cf	8b f8		 mov	 edi, eax
  006d1	85 c0		 test	 eax, eax
  006d3	0f 84 8f 07 00
	00		 je	 $LN377@inflateBac@2
  006d9	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN147@inflateBac@2:
  006dd	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  006e1	8b ce		 mov	 ecx, esi
  006e3	49 ff c2	 inc	 r10
  006e6	d3 e0		 shl	 eax, cl
  006e8	83 c6 08	 add	 esi, 8
  006eb	ff cf		 dec	 edi
  006ed	44 03 e8	 add	 r13d, eax
  006f0	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  006f4	3b f3		 cmp	 esi, ebx
  006f6	72 c9		 jb	 SHORT $LL153@inflateBac@2
$LN155@inflateBac@2:

; 423  :                         DROPBITS(here.bits);

  006f8	41 8b cc	 mov	 ecx, r12d

; 424  :                         len = 0;
; 425  :                         copy = 11 + BITS(7);
; 426  :                         DROPBITS(7);

  006fb	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  00700	41 d3 ed	 shr	 r13d, cl
  00703	45 8b c5	 mov	 r8d, r13d
  00706	41 83 e0 7f	 and	 r8d, 127		; 0000007fH
  0070a	41 83 c0 0b	 add	 r8d, 11
  0070e	41 c1 ed 07	 shr	 r13d, 7
$LN447@inflateBac@2:
  00712	41 2b c4	 sub	 eax, r12d
  00715	45 33 c9	 xor	 r9d, r9d
  00718	03 f0		 add	 esi, eax
$LN138@inflateBac@2:

; 427  :                     }
; 428  :                     if (state->have + copy > state->nlen + state->ndist) {

  0071a	41 8b 57 78	 mov	 edx, DWORD PTR [r15+120]
  0071e	41 8b 47 7c	 mov	 eax, DWORD PTR [r15+124]
  00722	41 03 57 74	 add	 edx, DWORD PTR [r15+116]
  00726	41 8d 0c 00	 lea	 ecx, DWORD PTR [r8+rax]
  0072a	3b ca		 cmp	 ecx, edx
  0072c	77 5a		 ja	 SHORT $LN389@inflateBac@2

; 429  :                         strm->msg = (char *)"invalid bit length repeat";
; 430  :                         state->mode = BAD;
; 431  :                         break;
; 432  :                     }
; 433  :                     while (copy--)

  0072e	45 85 c0	 test	 r8d, r8d
  00731	74 1a		 je	 SHORT $LN442@inflateBac@2
$LL136@inflateBac@2:

; 434  :                         state->lens[state->have++] = (unsigned short)len;

  00733	41 8b 47 7c	 mov	 eax, DWORD PTR [r15+124]
  00737	66 45 89 8c 47
	88 00 00 00	 mov	 WORD PTR [r15+rax*2+136], r9w
  00740	41 ff 47 7c	 inc	 DWORD PTR [r15+124]
  00744	41 ff c8	 dec	 r8d
  00747	75 ea		 jne	 SHORT $LL136@inflateBac@2

; 429  :                         strm->msg = (char *)"invalid bit length repeat";
; 430  :                         state->mode = BAD;
; 431  :                         break;
; 432  :                     }
; 433  :                     while (copy--)

  00749	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN442@inflateBac@2:

; 247  : {

  0074d	4c 8b 65 30	 mov	 r12, QWORD PTR in$[rbp-120]
$LN416@inflateBac@2:

; 385  :             }
; 386  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 387  : 
; 388  :             /* get length and distance code code lengths */
; 389  :             state->have = 0;
; 390  :             while (state->have < state->nlen + state->ndist) {

  00751	41 8b 47 78	 mov	 eax, DWORD PTR [r15+120]
  00755	49 8d 5f 68	 lea	 rbx, QWORD PTR [r15+104]
  00759	41 03 47 74	 add	 eax, DWORD PTR [r15+116]
  0075d	41 39 47 7c	 cmp	 DWORD PTR [r15+124], eax
  00761	0f 82 69 fd ff
	ff		 jb	 $LL230@inflateBac@2
$LN229@inflateBac@2:

; 435  :                 }
; 436  :             }
; 437  : 
; 438  :             /* handle error breaks in while */
; 439  :             if (state->mode == BAD) break;

  00767	41 83 3f 1d	 cmp	 DWORD PTR [r15], 29
  0076b	0f 84 73 03 00
	00		 je	 $LN443@inflateBac@2

; 440  : 
; 441  :             /* check for end-of-block code (better have one) */
; 442  :             if (state->lens[256] == 0) {

  00771	66 41 83 bf 88
	02 00 00 00	 cmp	 WORD PTR [r15+648], 0
  0077a	75 24		 jne	 SHORT $LN133@inflateBac@2

; 443  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  0077c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 444  :                 state->mode = BAD;
; 445  :                 break;

  00783	e9 09 fd ff ff	 jmp	 $LN454@inflateBac@2
$LN389@inflateBac@2:

; 406  :                             strm->msg = (char *)"invalid bit length repeat";

  00788	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 407  :                             state->mode = BAD;
; 408  :                             break;

  0078c	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00790	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00794	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  0079b	e9 42 01 00 00	 jmp	 $LN449@inflateBac@2
$LN133@inflateBac@2:

; 446  :             }
; 447  : 
; 448  :             /* build code tables -- note: do not change the lenbits or distbits
; 449  :                values here (9 and 6) without reading the comments in inftrees.h
; 450  :                concerning the ENOUGH constants, which depend on those values */
; 451  :             state->next = state->codes;
; 452  :             state->lencode = (code const FAR *)(state->next);
; 453  :             state->lenbits = 9;
; 454  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 455  :                                 &(state->lenbits), state->work);

  007a0	45 8b 47 74	 mov	 r8d, DWORD PTR [r15+116]
  007a4	49 8d 87 48 05
	00 00		 lea	 rax, QWORD PTR [r15+1352]
  007ab	4d 8d 8f 80 00
	00 00		 lea	 r9, QWORD PTR [r15+128]
  007b2	49 89 87 80 00
	00 00		 mov	 QWORD PTR [r15+128], rax
  007b9	49 89 47 58	 mov	 QWORD PTR [r15+88], rax
  007bd	49 8d 87 08 03
	00 00		 lea	 rax, QWORD PTR [r15+776]
  007c4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  007c9	49 8d 97 88 00
	00 00		 lea	 rdx, QWORD PTR [r15+136]
  007d0	b9 01 00 00 00	 mov	 ecx, 1
  007d5	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  007da	c7 03 09 00 00
	00		 mov	 DWORD PTR [rbx], 9
  007e0	e8 00 00 00 00	 call	 inflate_table

; 456  :             if (ret) {

  007e5	85 c0		 test	 eax, eax
  007e7	74 0c		 je	 SHORT $LN132@inflateBac@2

; 457  :                 strm->msg = (char *)"invalid literal/lengths set";

  007e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 458  :                 state->mode = BAD;
; 459  :                 break;

  007f0	e9 9c fc ff ff	 jmp	 $LN454@inflateBac@2
$LN132@inflateBac@2:

; 460  :             }
; 461  :             state->distcode = (code const FAR *)(state->next);

  007f5	49 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [r15+128]

; 462  :             state->distbits = 6;
; 463  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 464  :                             &(state->next), &(state->distbits), state->work);

  007fc	45 8b 47 78	 mov	 r8d, DWORD PTR [r15+120]
  00800	49 8d 4f 6c	 lea	 rcx, QWORD PTR [r15+108]
  00804	49 89 47 60	 mov	 QWORD PTR [r15+96], rax

; 465  :             if (ret) {

  00808	41 8b 47 74	 mov	 eax, DWORD PTR [r15+116]
  0080c	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  00812	49 8d 94 47 88
	00 00 00	 lea	 rdx, QWORD PTR [r15+rax*2+136]
  0081a	49 8d 87 08 03
	00 00		 lea	 rax, QWORD PTR [r15+776]
  00821	4d 8d 8f 80 00
	00 00		 lea	 r9, QWORD PTR [r15+128]
  00828	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0082d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00832	b9 02 00 00 00	 mov	 ecx, 2
  00837	e8 00 00 00 00	 call	 inflate_table

; 466  :                 strm->msg = (char *)"invalid distances set";

  0083c	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 467  :                 state->mode = BAD;
; 468  :                 break;

  00840	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00844	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00848	85 c0		 test	 eax, eax
  0084a	74 0c		 je	 SHORT $LN131@inflateBac@2

; 466  :                 strm->msg = (char *)"invalid distances set";

  0084c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 467  :                 state->mode = BAD;
; 468  :                 break;

  00853	e9 8a 00 00 00	 jmp	 $LN449@inflateBac@2
$LN131@inflateBac@2:

; 469  :             }
; 470  :             Tracev((stderr, "inflate:       codes ok\n"));
; 471  :             state->mode = LEN;

  00858	41 c7 07 14 00
	00 00		 mov	 DWORD PTR [r15], 20
  0085f	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00863	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN130@inflateBac@2:

; 472  : 
; 473  :         case LEN:
; 474  :             /* use inflate_fast() if we have enough input and output */
; 475  :             if (have >= 6 && left >= 258) {

  00869	83 ff 06	 cmp	 edi, 6
  0086c	0f 82 86 00 00
	00		 jb	 $LN367@inflateBac@2
  00872	41 81 f9 02 01
	00 00		 cmp	 r9d, 258		; 00000102H
  00879	72 7d		 jb	 SHORT $LN367@inflateBac@2

; 476  :                 RESTORE();

  0087b	49 89 58 10	 mov	 QWORD PTR [r8+16], rbx
  0087f	45 89 48 18	 mov	 DWORD PTR [r8+24], r9d
  00883	4d 89 10	 mov	 QWORD PTR [r8], r10
  00886	41 89 78 08	 mov	 DWORD PTR [r8+8], edi

; 477  :                 if (state->whave < state->wsize)

  0088a	41 8b 57 2c	 mov	 edx, DWORD PTR [r15+44]
  0088e	45 89 6f 40	 mov	 DWORD PTR [r15+64], r13d
  00892	41 89 77 44	 mov	 DWORD PTR [r15+68], esi
  00896	41 39 57 30	 cmp	 DWORD PTR [r15+48], edx
  0089a	73 09		 jae	 SHORT $LN125@inflateBac@2

; 478  :                     state->whave = state->wsize - left;

  0089c	8b c2		 mov	 eax, edx
  0089e	41 2b c1	 sub	 eax, r9d
  008a1	41 89 47 30	 mov	 DWORD PTR [r15+48], eax
$LN125@inflateBac@2:

; 479  :                 inflate_fast(strm, state->wsize);

  008a5	49 8b c8	 mov	 rcx, r8
  008a8	e8 00 00 00 00	 call	 inflate_fast

; 480  :                 LOAD();

  008ad	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  008b1	33 d2		 xor	 edx, edx
  008b3	4d 8b 10	 mov	 r10, QWORD PTR [r8]
  008b6	49 8b 58 10	 mov	 rbx, QWORD PTR [r8+16]
  008ba	45 8b 48 18	 mov	 r9d, DWORD PTR [r8+24]
  008be	41 8b 78 08	 mov	 edi, DWORD PTR [r8+8]
  008c2	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  008c6	45 8b 6f 40	 mov	 r13d, DWORD PTR [r15+64]
  008ca	41 8b 77 44	 mov	 esi, DWORD PTR [r15+68]
  008ce	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  008d2	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  008d6	e9 17 02 00 00	 jmp	 $LN402@inflateBac@2
$LN252@inflateBac@2:

; 360  :                 strm->msg = (char *)"too many length or distance symbols";

  008db	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
$LN449@inflateBac@2:
  008e2	49 89 40 20	 mov	 QWORD PTR [r8+32], rax

; 361  :                 state->mode = BAD;

  008e6	41 c7 07 1d 00
	00 00		 mov	 DWORD PTR [r15], 29

; 362  :                 break;

  008ed	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  008f1	33 d2		 xor	 edx, edx
  008f3	e9 fa 01 00 00	 jmp	 $LN402@inflateBac@2
$LN367@inflateBac@2:

; 481  :                 break;
; 482  :             }
; 483  : 
; 484  :             /* get a literal, length, or end-of-block code */
; 485  :             for (;;) {
; 486  :                 here = state->lencode[BITS(state->lenbits)];

  008f8	41 8b 4f 68	 mov	 ecx, DWORD PTR [r15+104]
  008fc	41 8b c3	 mov	 eax, r11d
  008ff	d3 e0		 shl	 eax, cl
  00901	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00904	41 8b c5	 mov	 eax, r13d
  00907	48 23 c8	 and	 rcx, rax
  0090a	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  0090e	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]

; 487  :                 if ((unsigned)(here.bits) <= bits) break;

  00911	8b c8		 mov	 ecx, eax
  00913	c1 e9 08	 shr	 ecx, 8
  00916	0f b6 c9	 movzx	 ecx, cl
  00919	3b ce		 cmp	 ecx, esi
  0091b	76 61		 jbe	 SHORT $LN391@inflateBac@2
  0091d	0f 1f 00	 npad	 3
$LL121@inflateBac@2:

; 488  :                 PULLBYTE();

  00920	85 ff		 test	 edi, edi
  00922	75 1e		 jne	 SHORT $LN114@inflateBac@2
  00924	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00928	49 8b ce	 mov	 rcx, r14
  0092b	41 ff d4	 call	 r12
  0092e	8b f8		 mov	 edi, eax
  00930	85 c0		 test	 eax, eax
  00932	0f 84 30 05 00
	00		 je	 $LN377@inflateBac@2
  00938	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  0093c	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN114@inflateBac@2:
  00942	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00946	8b ce		 mov	 ecx, esi
  00948	49 ff c2	 inc	 r10
  0094b	d3 e0		 shl	 eax, cl
  0094d	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00951	41 8b 4f 68	 mov	 ecx, DWORD PTR [r15+104]
  00955	44 03 e8	 add	 r13d, eax
  00958	41 8b c3	 mov	 eax, r11d
  0095b	83 c6 08	 add	 esi, 8
  0095e	d3 e0		 shl	 eax, cl
  00960	ff cf		 dec	 edi
  00962	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00965	41 8b c5	 mov	 eax, r13d
  00968	48 23 c8	 and	 rcx, rax
  0096b	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  0096f	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00972	8b c8		 mov	 ecx, eax
  00974	c1 e9 08	 shr	 ecx, 8
  00977	0f b6 c9	 movzx	 ecx, cl
  0097a	3b ce		 cmp	 ecx, esi
  0097c	77 a2		 ja	 SHORT $LL121@inflateBac@2
$LN391@inflateBac@2:

; 489  :             }
; 490  :             if (here.op && (here.op & 0xf0) == 0) {

  0097e	84 c0		 test	 al, al
  00980	0f 84 d6 00 00
	00		 je	 $LN96@inflateBac@2
  00986	a8 f0		 test	 al, 240			; 000000f0H
  00988	0f 85 ce 00 00
	00		 jne	 $LN96@inflateBac@2

; 491  :                 last = here;
; 492  :                 for (;;) {
; 493  :                     here = state->lencode[last.val +
; 494  :                             (BITS(last.bits + last.op) >> last.bits)];

  0098e	44 8b c8	 mov	 r9d, eax
  00991	0f b6 c8	 movzx	 ecx, al
  00994	89 45 bc	 mov	 DWORD PTR last$[rbp-120], eax

; 495  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00997	44 0f b6 75 bd	 movzx	 r14d, BYTE PTR last$[rbp-119]
  0099c	41 c1 e9 08	 shr	 r9d, 8
  009a0	8b d8		 mov	 ebx, eax
  009a2	c1 e8 10	 shr	 eax, 16
  009a5	41 0f b6 d1	 movzx	 edx, r9b
  009a9	45 8b c3	 mov	 r8d, r11d
  009ac	03 ca		 add	 ecx, edx
  009ae	41 d3 e0	 shl	 r8d, cl
  009b1	8b ca		 mov	 ecx, edx
  009b3	41 ff c8	 dec	 r8d
  009b6	45 23 c5	 and	 r8d, r13d
  009b9	41 d3 e8	 shr	 r8d, cl
  009bc	44 03 c0	 add	 r8d, eax
  009bf	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  009c3	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  009c7	8b c8		 mov	 ecx, eax
  009c9	c1 e9 08	 shr	 ecx, 8
  009cc	0f b6 d1	 movzx	 edx, cl
  009cf	41 0f b6 c9	 movzx	 ecx, r9b
  009d3	03 d1		 add	 edx, ecx
  009d5	3b d6		 cmp	 edx, esi
  009d7	76 76		 jbe	 SHORT $LN98@inflateBac@2
  009d9	44 0f b7 65 be	 movzx	 r12d, WORD PTR last$[rbp-118]
  009de	66 90		 npad	 2
$LL109@inflateBac@2:

; 496  :                     PULLBYTE();

  009e0	85 ff		 test	 edi, edi
  009e2	75 1f		 jne	 SHORT $LN102@inflateBac@2
  009e4	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  009e8	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  009ec	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  009ef	8b f8		 mov	 edi, eax
  009f1	85 c0		 test	 eax, eax
  009f3	0f 84 6f 04 00
	00		 je	 $LN377@inflateBac@2
  009f9	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  009fd	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN102@inflateBac@2:
  00a03	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00a07	8b ce		 mov	 ecx, esi
  00a09	45 0f b6 c6	 movzx	 r8d, r14b
  00a0d	d3 e0		 shl	 eax, cl
  00a0f	41 8b d3	 mov	 edx, r11d
  00a12	49 ff c2	 inc	 r10
  00a15	44 03 e8	 add	 r13d, eax
  00a18	41 0f b7 c4	 movzx	 eax, r12w
  00a1c	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00a20	0f b6 cb	 movzx	 ecx, bl
  00a23	83 c6 08	 add	 esi, 8
  00a26	ff cf		 dec	 edi
  00a28	41 03 c8	 add	 ecx, r8d
  00a2b	d3 e2		 shl	 edx, cl
  00a2d	41 8b c8	 mov	 ecx, r8d
  00a30	ff ca		 dec	 edx
  00a32	41 23 d5	 and	 edx, r13d
  00a35	d3 ea		 shr	 edx, cl
  00a37	03 d0		 add	 edx, eax
  00a39	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  00a3d	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00a40	8b c8		 mov	 ecx, eax
  00a42	c1 e9 08	 shr	 ecx, 8
  00a45	0f b6 d1	 movzx	 edx, cl
  00a48	41 03 d0	 add	 edx, r8d
  00a4b	3b d6		 cmp	 edx, esi
  00a4d	77 91		 ja	 SHORT $LL109@inflateBac@2
$LN98@inflateBac@2:

; 497  :                 }
; 498  :                 DROPBITS(last.bits);

  00a4f	41 0f b6 ce	 movzx	 ecx, r14b
  00a53	4c 8b 75 38	 mov	 r14, QWORD PTR in_desc$[rbp-120]
  00a57	41 d3 ed	 shr	 r13d, cl
  00a5a	2b f1		 sub	 esi, ecx
$LN96@inflateBac@2:

; 499  :             }
; 500  :             DROPBITS(here.bits);

  00a5c	8b c8		 mov	 ecx, eax
  00a5e	c1 e9 08	 shr	 ecx, 8
  00a61	0f b6 c9	 movzx	 ecx, cl
  00a64	41 d3 ed	 shr	 r13d, cl
  00a67	2b f1		 sub	 esi, ecx

; 501  :             state->length = (unsigned)here.val;

  00a69	8b c8		 mov	 ecx, eax
  00a6b	c1 e9 10	 shr	 ecx, 16
  00a6e	41 89 4f 48	 mov	 DWORD PTR [r15+72], ecx

; 502  : 
; 503  :             /* process literal */
; 504  :             if (here.op == 0) {

  00a72	84 c0		 test	 al, al
  00a74	75 5f		 jne	 SHORT $LN92@inflateBac@2

; 505  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 506  :                         "inflate:         literal '%c'\n" :
; 507  :                         "inflate:         literal 0x%02x\n", here.val));
; 508  :                 ROOM();

  00a76	44 8b 65 b8	 mov	 r12d, DWORD PTR left$1$[rbp-120]
  00a7a	45 85 e4	 test	 r12d, r12d
  00a7d	75 2c		 jne	 SHORT $LN444@inflateBac@2
  00a7f	45 8b 67 2c	 mov	 r12d, DWORD PTR [r15+44]
  00a83	49 8b 5f 38	 mov	 rbx, QWORD PTR [r15+56]
  00a87	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00a8b	45 8b c4	 mov	 r8d, r12d
  00a8e	48 8b d3	 mov	 rdx, rbx
  00a91	45 89 67 30	 mov	 DWORD PTR [r15+48], r12d
  00a95	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00a98	85 c0		 test	 eax, eax
  00a9a	74 13		 je	 SHORT $LN90@inflateBac@2
$LN380@inflateBac@2:

; 335  :                 ROOM();

  00a9c	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00aa0	41 bb fb ff ff
	ff		 mov	 r11d, -5
  00aa6	e9 06 04 00 00	 jmp	 $inf_leave$4949
$LN444@inflateBac@2:

; 383  :                 state->mode = BAD;
; 384  :                 break;

  00aab	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
$LN90@inflateBac@2:

; 509  :                 *put++ = (unsigned char)(state->length);

  00aaf	41 0f b6 47 48	 movzx	 eax, BYTE PTR [r15+72]
  00ab4	48 ff c3	 inc	 rbx

; 510  :                 left--;

  00ab7	41 ff cc	 dec	 r12d
  00aba	88 43 ff	 mov	 BYTE PTR [rbx-1], al

; 511  :                 state->mode = LEN;

  00abd	41 c7 07 14 00
	00 00		 mov	 DWORD PTR [r15], 20

; 512  :                 break;

  00ac4	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00ac8	44 89 65 b8	 mov	 DWORD PTR left$1$[rbp-120], r12d
  00acc	45 8b cc	 mov	 r9d, r12d
  00acf	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00ad3	eb 17		 jmp	 SHORT $LN448@inflateBac@2
$LN92@inflateBac@2:

; 513  :             }
; 514  : 
; 515  :             /* process end of block */
; 516  :             if (here.op & 32) {

  00ad5	a8 20		 test	 al, 32			; 00000020H
  00ad7	74 35		 je	 SHORT $LN86@inflateBac@2

; 517  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 518  :                 state->mode = TYPE;

  00ad9	41 c7 07 0b 00
	00 00		 mov	 DWORD PTR [r15], 11

; 519  :                 break;

  00ae0	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN443@inflateBac@2:

; 383  :                 state->mode = BAD;
; 384  :                 break;

  00ae4	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00ae8	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
$LN448@inflateBac@2:
  00aec	33 d2		 xor	 edx, edx
$LN446@inflateBac@2:
  00aee	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
$LN402@inflateBac@2:

; 275  :     hold = 0;
; 276  :     bits = 0;
; 277  :     put = state->window;
; 278  :     left = state->wsize;
; 279  : 
; 280  :     /* Inflate until end of block marked as last */
; 281  :     for (;;)
; 282  :         switch (state->mode) {

  00af2	41 8b 07	 mov	 eax, DWORD PTR [r15]
  00af5	83 e8 0b	 sub	 eax, 11
  00af8	83 f8 12	 cmp	 eax, 18
  00afb	0f 87 aa 03 00
	00		 ja	 $LN1@inflateBac@2
  00b01	4c 8b 75 38	 mov	 r14, QWORD PTR in_desc$[rbp-120]
  00b05	4c 8b 65 30	 mov	 r12, QWORD PTR in$[rbp-120]
  00b09	e9 8a f5 ff ff	 jmp	 $LN452@inflateBac@2
$LN86@inflateBac@2:

; 520  :             }
; 521  : 
; 522  :             /* invalid code */
; 523  :             if (here.op & 64) {

  00b0e	a8 40		 test	 al, 64			; 00000040H
  00b10	74 18		 je	 SHORT $LN85@inflateBac@2

; 524  :                 strm->msg = (char *)"invalid literal/length code";

  00b12	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 525  :                 state->mode = BAD;
; 526  :                 break;

  00b16	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00b1a	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00b1e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  00b25	e9 b8 fd ff ff	 jmp	 $LN449@inflateBac@2
$LN85@inflateBac@2:

; 527  :             }
; 528  : 
; 529  :             /* length code -- get extra bits, if any */
; 530  :             state->extra = (unsigned)(here.op) & 15;

  00b2a	0f b6 c8	 movzx	 ecx, al
  00b2d	83 e1 0f	 and	 ecx, 15
  00b30	41 89 4f 50	 mov	 DWORD PTR [r15+80], ecx

; 531  :             if (state->extra != 0) {

  00b34	74 5f		 je	 SHORT $LN68@inflateBac@2

; 532  :                 NEEDBITS(state->extra);

  00b36	3b f1		 cmp	 esi, ecx
  00b38	73 44		 jae	 SHORT $LN82@inflateBac@2
  00b3a	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  00b3e	66 90		 npad	 2
$LL80@inflateBac@2:
  00b40	85 ff		 test	 edi, edi
  00b42	75 18		 jne	 SHORT $LN74@inflateBac@2
  00b44	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00b48	49 8b ce	 mov	 rcx, r14
  00b4b	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00b4e	8b f8		 mov	 edi, eax
  00b50	85 c0		 test	 eax, eax
  00b52	0f 84 10 03 00
	00		 je	 $LN377@inflateBac@2
  00b58	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN74@inflateBac@2:
  00b5c	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00b5f	8b ce		 mov	 ecx, esi
  00b61	48 ff c2	 inc	 rdx
  00b64	d3 e0		 shl	 eax, cl
  00b66	83 c6 08	 add	 esi, 8
  00b69	ff cf		 dec	 edi
  00b6b	44 03 e8	 add	 r13d, eax
  00b6e	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00b72	41 3b 77 50	 cmp	 esi, DWORD PTR [r15+80]
  00b76	72 c8		 jb	 SHORT $LL80@inflateBac@2
  00b78	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN82@inflateBac@2:

; 533  :                 state->length += BITS(state->extra);

  00b7e	41 8b 4f 50	 mov	 ecx, DWORD PTR [r15+80]
  00b82	41 8b c3	 mov	 eax, r11d
  00b85	d3 e0		 shl	 eax, cl
  00b87	ff c8		 dec	 eax
  00b89	41 23 c5	 and	 eax, r13d

; 534  :                 DROPBITS(state->extra);

  00b8c	41 d3 ed	 shr	 r13d, cl
  00b8f	41 01 47 48	 add	 DWORD PTR [r15+72], eax
  00b93	2b f1		 sub	 esi, ecx
$LN68@inflateBac@2:

; 535  :             }
; 536  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 537  : 
; 538  :             /* get distance code */
; 539  :             for (;;) {
; 540  :                 here = state->distcode[BITS(state->distbits)];

  00b95	41 8b 4f 6c	 mov	 ecx, DWORD PTR [r15+108]

; 541  :                 if ((unsigned)(here.bits) <= bits) break;

  00b99	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00b9d	41 8b c3	 mov	 eax, r11d
  00ba0	d3 e0		 shl	 eax, cl
  00ba2	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00ba5	41 8b c5	 mov	 eax, r13d
  00ba8	48 23 c8	 and	 rcx, rax
  00bab	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  00baf	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00bb2	8b c8		 mov	 ecx, eax
  00bb4	c1 e9 08	 shr	 ecx, 8
  00bb7	0f b6 c9	 movzx	 ecx, cl
  00bba	3b ce		 cmp	 ecx, esi
  00bbc	76 60		 jbe	 SHORT $LN396@inflateBac@2
  00bbe	66 90		 npad	 2
$LL67@inflateBac@2:

; 542  :                 PULLBYTE();

  00bc0	85 ff		 test	 edi, edi
  00bc2	75 1e		 jne	 SHORT $LN60@inflateBac@2
  00bc4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00bc8	49 8b ce	 mov	 rcx, r14
  00bcb	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00bce	8b f8		 mov	 edi, eax
  00bd0	85 c0		 test	 eax, eax
  00bd2	0f 84 90 02 00
	00		 je	 $LN377@inflateBac@2
  00bd8	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00bdc	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN60@inflateBac@2:
  00be2	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00be6	8b ce		 mov	 ecx, esi
  00be8	49 ff c2	 inc	 r10
  00beb	d3 e0		 shl	 eax, cl
  00bed	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00bf1	41 8b 4f 6c	 mov	 ecx, DWORD PTR [r15+108]
  00bf5	44 03 e8	 add	 r13d, eax
  00bf8	41 8b c3	 mov	 eax, r11d
  00bfb	83 c6 08	 add	 esi, 8
  00bfe	d3 e0		 shl	 eax, cl
  00c00	ff cf		 dec	 edi
  00c02	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00c05	41 8b c5	 mov	 eax, r13d
  00c08	48 23 c8	 and	 rcx, rax
  00c0b	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  00c0f	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00c12	8b c8		 mov	 ecx, eax
  00c14	c1 e9 08	 shr	 ecx, 8
  00c17	0f b6 c9	 movzx	 ecx, cl
  00c1a	3b ce		 cmp	 ecx, esi
  00c1c	77 a2		 ja	 SHORT $LL67@inflateBac@2
$LN396@inflateBac@2:

; 543  :             }
; 544  :             if ((here.op & 0xf0) == 0) {

  00c1e	a8 f0		 test	 al, 240			; 000000f0H
  00c20	0f 85 c8 00 00
	00		 jne	 $LN42@inflateBac@2

; 545  :                 last = here;
; 546  :                 for (;;) {
; 547  :                     here = state->distcode[last.val +
; 548  :                             (BITS(last.bits + last.op) >> last.bits)];

  00c26	44 8b c8	 mov	 r9d, eax
  00c29	0f b6 c8	 movzx	 ecx, al
  00c2c	89 45 bc	 mov	 DWORD PTR last$[rbp-120], eax

; 549  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00c2f	44 0f b6 75 bd	 movzx	 r14d, BYTE PTR last$[rbp-119]
  00c34	41 c1 e9 08	 shr	 r9d, 8
  00c38	8b d8		 mov	 ebx, eax
  00c3a	c1 e8 10	 shr	 eax, 16
  00c3d	41 0f b6 d1	 movzx	 edx, r9b
  00c41	45 8b c3	 mov	 r8d, r11d
  00c44	03 ca		 add	 ecx, edx
  00c46	41 d3 e0	 shl	 r8d, cl
  00c49	8b ca		 mov	 ecx, edx
  00c4b	41 ff c8	 dec	 r8d
  00c4e	45 23 c5	 and	 r8d, r13d
  00c51	41 d3 e8	 shr	 r8d, cl
  00c54	44 03 c0	 add	 r8d, eax
  00c57	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  00c5b	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  00c5f	8b c8		 mov	 ecx, eax
  00c61	c1 e9 08	 shr	 ecx, 8
  00c64	0f b6 d1	 movzx	 edx, cl
  00c67	41 0f b6 c9	 movzx	 ecx, r9b
  00c6b	03 d1		 add	 edx, ecx
  00c6d	3b d6		 cmp	 edx, esi
  00c6f	76 74		 jbe	 SHORT $LN44@inflateBac@2
  00c71	44 0f b7 65 be	 movzx	 r12d, WORD PTR last$[rbp-118]
$LL55@inflateBac@2:

; 550  :                     PULLBYTE();

  00c76	85 ff		 test	 edi, edi
  00c78	75 1f		 jne	 SHORT $LN48@inflateBac@2
  00c7a	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00c7e	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00c82	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00c85	8b f8		 mov	 edi, eax
  00c87	85 c0		 test	 eax, eax
  00c89	0f 84 d9 01 00
	00		 je	 $LN377@inflateBac@2
  00c8f	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00c93	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN48@inflateBac@2:
  00c99	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00c9d	8b ce		 mov	 ecx, esi
  00c9f	45 0f b6 c6	 movzx	 r8d, r14b
  00ca3	d3 e0		 shl	 eax, cl
  00ca5	41 8b d3	 mov	 edx, r11d
  00ca8	49 ff c2	 inc	 r10
  00cab	44 03 e8	 add	 r13d, eax
  00cae	41 0f b7 c4	 movzx	 eax, r12w
  00cb2	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00cb6	0f b6 cb	 movzx	 ecx, bl
  00cb9	83 c6 08	 add	 esi, 8
  00cbc	ff cf		 dec	 edi
  00cbe	41 03 c8	 add	 ecx, r8d
  00cc1	d3 e2		 shl	 edx, cl
  00cc3	41 8b c8	 mov	 ecx, r8d
  00cc6	ff ca		 dec	 edx
  00cc8	41 23 d5	 and	 edx, r13d
  00ccb	d3 ea		 shr	 edx, cl
  00ccd	03 d0		 add	 edx, eax
  00ccf	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  00cd3	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00cd6	8b c8		 mov	 ecx, eax
  00cd8	c1 e9 08	 shr	 ecx, 8
  00cdb	0f b6 d1	 movzx	 edx, cl
  00cde	41 03 d0	 add	 edx, r8d
  00ce1	3b d6		 cmp	 edx, esi
  00ce3	77 91		 ja	 SHORT $LL55@inflateBac@2
$LN44@inflateBac@2:

; 551  :                 }
; 552  :                 DROPBITS(last.bits);

  00ce5	41 0f b6 ce	 movzx	 ecx, r14b
  00ce9	41 d3 ed	 shr	 r13d, cl
  00cec	2b f1		 sub	 esi, ecx
$LN42@inflateBac@2:

; 553  :             }
; 554  :             DROPBITS(here.bits);

  00cee	8b c8		 mov	 ecx, eax
  00cf0	c1 e9 08	 shr	 ecx, 8
  00cf3	0f b6 c9	 movzx	 ecx, cl
  00cf6	41 d3 ed	 shr	 r13d, cl
  00cf9	2b f1		 sub	 esi, ecx

; 555  :             if (here.op & 64) {

  00cfb	a8 40		 test	 al, 64			; 00000040H
  00cfd	74 18		 je	 SHORT $LN38@inflateBac@2

; 525  :                 state->mode = BAD;
; 526  :                 break;

  00cff	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00d03	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00d07	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]

; 556  :                 strm->msg = (char *)"invalid distance code";

  00d0b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  00d12	e9 cb fb ff ff	 jmp	 $LN449@inflateBac@2
$LN38@inflateBac@2:

; 557  :                 state->mode = BAD;
; 558  :                 break;
; 559  :             }
; 560  :             state->offset = (unsigned)here.val;

  00d17	8b c8		 mov	 ecx, eax
  00d19	c1 e9 10	 shr	 ecx, 16
  00d1c	41 89 4f 4c	 mov	 DWORD PTR [r15+76], ecx

; 561  : 
; 562  :             /* get distance extra bits, if any */
; 563  :             state->extra = (unsigned)(here.op) & 15;

  00d20	0f b6 c8	 movzx	 ecx, al
  00d23	83 e1 0f	 and	 ecx, 15
  00d26	41 89 4f 50	 mov	 DWORD PTR [r15+80], ecx

; 564  :             if (state->extra != 0) {

  00d2a	74 5e		 je	 SHORT $LN21@inflateBac@2

; 565  :                 NEEDBITS(state->extra);

  00d2c	3b f1		 cmp	 esi, ecx
  00d2e	73 43		 jae	 SHORT $LN35@inflateBac@2
  00d30	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LL33@inflateBac@2:
  00d34	85 ff		 test	 edi, edi
  00d36	75 19		 jne	 SHORT $LN27@inflateBac@2
  00d38	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00d3c	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00d40	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00d43	8b f8		 mov	 edi, eax
  00d45	85 c0		 test	 eax, eax
  00d47	0f 84 1b 01 00
	00		 je	 $LN377@inflateBac@2
  00d4d	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN27@inflateBac@2:
  00d51	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00d54	8b ce		 mov	 ecx, esi
  00d56	48 ff c2	 inc	 rdx
  00d59	d3 e0		 shl	 eax, cl
  00d5b	83 c6 08	 add	 esi, 8
  00d5e	ff cf		 dec	 edi
  00d60	44 03 e8	 add	 r13d, eax
  00d63	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00d67	41 3b 77 50	 cmp	 esi, DWORD PTR [r15+80]
  00d6b	72 c7		 jb	 SHORT $LL33@inflateBac@2
  00d6d	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN35@inflateBac@2:

; 566  :                 state->offset += BITS(state->extra);

  00d73	41 8b 4f 50	 mov	 ecx, DWORD PTR [r15+80]
  00d77	41 8b c3	 mov	 eax, r11d
  00d7a	d3 e0		 shl	 eax, cl
  00d7c	ff c8		 dec	 eax
  00d7e	41 23 c5	 and	 eax, r13d

; 567  :                 DROPBITS(state->extra);

  00d81	41 d3 ed	 shr	 r13d, cl
  00d84	41 01 47 4c	 add	 DWORD PTR [r15+76], eax
  00d88	2b f1		 sub	 esi, ecx
$LN21@inflateBac@2:

; 568  :             }
; 569  :             if (state->offset > state->wsize - (state->whave < state->wsize ?
; 570  :                                                 left : 0)) {

  00d8a	41 8b 4f 2c	 mov	 ecx, DWORD PTR [r15+44]
  00d8e	44 8b 65 b8	 mov	 r12d, DWORD PTR left$1$[rbp-120]

; 572  :                 state->mode = BAD;
; 573  :                 break;

  00d92	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00d96	33 d2		 xor	 edx, edx
  00d98	41 39 4f 30	 cmp	 DWORD PTR [r15+48], ecx
  00d9c	8b c2		 mov	 eax, edx
  00d9e	41 0f 42 c4	 cmovb	 eax, r12d
  00da2	2b c8		 sub	 ecx, eax
  00da4	41 39 4f 4c	 cmp	 DWORD PTR [r15+76], ecx
  00da8	76 26		 jbe	 SHORT $LL19@inflateBac@2

; 571  :                 strm->msg = (char *)"invalid distance too far back";

  00daa	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00dae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 572  :                 state->mode = BAD;
; 573  :                 break;

  00db5	45 8b cc	 mov	 r9d, r12d
  00db8	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  00dbc	41 c7 07 1d 00
	00 00		 mov	 DWORD PTR [r15], 29
  00dc3	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00dc7	e9 26 fd ff ff	 jmp	 $LN402@inflateBac@2
  00dcc	0f 1f 40 00	 npad	 4
$LL19@inflateBac@2:

; 574  :             }
; 575  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 576  : 
; 577  :             /* copy match from window to output */
; 578  :             do {
; 579  :                 ROOM();

  00dd0	45 85 e4	 test	 r12d, r12d
  00dd3	75 21		 jne	 SHORT $LN15@inflateBac@2
  00dd5	45 8b 67 2c	 mov	 r12d, DWORD PTR [r15+44]
  00dd9	49 8b 5f 38	 mov	 rbx, QWORD PTR [r15+56]
  00ddd	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00de1	45 8b c4	 mov	 r8d, r12d
  00de4	48 8b d3	 mov	 rdx, rbx
  00de7	45 89 67 30	 mov	 DWORD PTR [r15+48], r12d
  00deb	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00dee	85 c0		 test	 eax, eax
  00df0	0f 85 a6 fc ff
	ff		 jne	 $LN380@inflateBac@2
$LN15@inflateBac@2:

; 580  :                 copy = state->wsize - state->offset;

  00df6	41 8b 4f 4c	 mov	 ecx, DWORD PTR [r15+76]
  00dfa	41 8b 47 2c	 mov	 eax, DWORD PTR [r15+44]
  00dfe	2b c1		 sub	 eax, ecx

; 581  :                 if (copy < left) {

  00e00	41 3b c4	 cmp	 eax, r12d
  00e03	73 0c		 jae	 SHORT $LN11@inflateBac@2

; 582  :                     from = put + copy;

  00e05	8b d0		 mov	 edx, eax

; 583  :                     copy = left - copy;

  00e07	41 8b cc	 mov	 ecx, r12d
  00e0a	48 03 d3	 add	 rdx, rbx
  00e0d	2b c8		 sub	 ecx, eax

; 584  :                 }
; 585  :                 else {

  00e0f	eb 09		 jmp	 SHORT $LN10@inflateBac@2
$LN11@inflateBac@2:

; 586  :                     from = put - state->offset;

  00e11	48 8b d3	 mov	 rdx, rbx
  00e14	48 2b d1	 sub	 rdx, rcx

; 587  :                     copy = left;

  00e17	41 8b cc	 mov	 ecx, r12d
$LN10@inflateBac@2:

; 588  :                 }
; 589  :                 if (copy > state->length) copy = state->length;

  00e1a	41 8b 47 48	 mov	 eax, DWORD PTR [r15+72]
  00e1e	3b c8		 cmp	 ecx, eax
  00e20	0f 47 c8	 cmova	 ecx, eax

; 590  :                 state->length -= copy;

  00e23	2b c1		 sub	 eax, ecx

; 591  :                 left -= copy;

  00e25	44 2b e1	 sub	 r12d, ecx

; 594  :                 } while (--copy);

  00e28	48 2b d3	 sub	 rdx, rbx
  00e2b	41 89 47 48	 mov	 DWORD PTR [r15+72], eax
  00e2f	44 89 65 b8	 mov	 DWORD PTR left$1$[rbp-120], r12d
  00e33	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL8@inflateBac@2:

; 592  :                 do {
; 593  :                     *put++ = *from++;

  00e40	0f b6 04 13	 movzx	 eax, BYTE PTR [rbx+rdx]
  00e44	48 ff c3	 inc	 rbx

; 594  :                 } while (--copy);

  00e47	ff c9		 dec	 ecx
  00e49	88 43 ff	 mov	 BYTE PTR [rbx-1], al
  00e4c	75 f2		 jne	 SHORT $LL8@inflateBac@2

; 595  :             } while (state->length != 0);

  00e4e	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00e52	41 39 4f 48	 cmp	 DWORD PTR [r15+72], ecx
  00e56	0f 85 74 ff ff
	ff		 jne	 $LL19@inflateBac@2
  00e5c	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00e60	45 8b cc	 mov	 r9d, r12d
  00e63	e9 84 fc ff ff	 jmp	 $LN448@inflateBac@2
$LN377@inflateBac@2:

; 289  :             }
; 290  :             NEEDBITS(3);

  00e68	45 33 d2	 xor	 r10d, r10d
$LN453@inflateBac@2:
  00e6b	41 bb fb ff ff
	ff		 mov	 r11d, -5
  00e71	eb 3e		 jmp	 SHORT $inf_leave$4949
$LN382@inflateBac@2:

; 370  :                 NEEDBITS(3);

  00e73	4c 8b d3	 mov	 r10, rbx
  00e76	41 bb fb ff ff
	ff		 mov	 r11d, -5
  00e7c	eb 33		 jmp	 SHORT $inf_leave$4949
$LN5@inflateBac@2:

; 596  :             break;
; 597  : 
; 598  :         case DONE:
; 599  :             /* inflate stream terminated properly -- write leftover output */
; 600  :             ret = Z_STREAM_END;
; 601  :             if (left < state->wsize) {

  00e7e	45 8b 47 2c	 mov	 r8d, DWORD PTR [r15+44]
  00e82	45 3b c8	 cmp	 r9d, r8d
  00e85	73 2a		 jae	 SHORT $inf_leave$4949

; 602  :                 if (out(out_desc, state->window, state->wsize - left))

  00e87	49 8b 57 38	 mov	 rdx, QWORD PTR [r15+56]
  00e8b	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00e8f	45 2b c1	 sub	 r8d, r9d
  00e92	ff 55 40	 call	 QWORD PTR out$[rbp-120]

; 603  :                     ret = Z_BUF_ERROR;
; 604  :             }
; 605  :             goto inf_leave;

  00e95	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00e99	85 c0		 test	 eax, eax
  00e9b	75 ce		 jne	 SHORT $LN453@inflateBac@2
  00e9d	44 8d 58 01	 lea	 r11d, QWORD PTR [rax+1]
  00ea1	eb 0e		 jmp	 SHORT $inf_leave$4949
$LN2@inflateBac@2:

; 606  : 
; 607  :         case BAD:
; 608  :             ret = Z_DATA_ERROR;

  00ea3	41 bb fd ff ff
	ff		 mov	 r11d, -3

; 609  :             goto inf_leave;

  00ea9	eb 06		 jmp	 SHORT $inf_leave$4949
$LN1@inflateBac@2:

; 610  : 
; 611  :         default:                /* can't happen, but makes compilers happy */
; 612  :             ret = Z_STREAM_ERROR;

  00eab	41 bb fe ff ff
	ff		 mov	 r11d, -2
$inf_leave$4949:

; 613  :             goto inf_leave;
; 614  :         }
; 615  : 
; 616  :     /* Return unused input */
; 617  :   inf_leave:
; 618  :     strm->next_in = next;

  00eb1	48 8b 45 28	 mov	 rax, QWORD PTR strm$[rbp-120]
  00eb5	4c 8b 6c 24 58	 mov	 r13, QWORD PTR [rsp+88]
  00eba	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00ebf	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]

; 619  :     strm->avail_in = have;

  00ec4	89 78 08	 mov	 DWORD PTR [rax+8], edi
  00ec7	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00ecc	4c 89 10	 mov	 QWORD PTR [rax], r10

; 620  :     return ret;

  00ecf	41 8b c3	 mov	 eax, r11d

; 621  : }

  00ed2	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00ed6	41 5f		 pop	 r15
  00ed8	41 5e		 pop	 r14
  00eda	41 5c		 pop	 r12
  00edc	5d		 pop	 rbp
  00edd	c3		 ret	 0
$LN346@inflateBac@2:

; 265  :         return Z_STREAM_ERROR;

  00ede	b8 fe ff ff ff	 mov	 eax, -2

; 621  : }

  00ee3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00ee7	41 5f		 pop	 r15
  00ee9	41 5e		 pop	 r14
  00eeb	41 5c		 pop	 r12
  00eed	5d		 pop	 rbp
  00eee	c3		 ret	 0
  00eef	90		 npad	 1
$LN430@inflateBac@2:
  00ef0	00 00 00 00	 DD	 $LN341@inflateBac@2
  00ef4	00 00 00 00	 DD	 $LN1@inflateBac@2
  00ef8	00 00 00 00	 DD	 $LN310@inflateBac@2
  00efc	00 00 00 00	 DD	 $LN1@inflateBac@2
  00f00	00 00 00 00	 DD	 $LN1@inflateBac@2
  00f04	00 00 00 00	 DD	 $LN275@inflateBac@2
  00f08	00 00 00 00	 DD	 $LN1@inflateBac@2
  00f0c	00 00 00 00	 DD	 $LN1@inflateBac@2
  00f10	00 00 00 00	 DD	 $LN1@inflateBac@2
  00f14	00 00 00 00	 DD	 $LN130@inflateBac@2
  00f18	00 00 00 00	 DD	 $LN1@inflateBac@2
  00f1c	00 00 00 00	 DD	 $LN1@inflateBac@2
  00f20	00 00 00 00	 DD	 $LN1@inflateBac@2
  00f24	00 00 00 00	 DD	 $LN1@inflateBac@2
  00f28	00 00 00 00	 DD	 $LN1@inflateBac@2
  00f2c	00 00 00 00	 DD	 $LN1@inflateBac@2
  00f30	00 00 00 00	 DD	 $LN1@inflateBac@2
  00f34	00 00 00 00	 DD	 $LN5@inflateBac@2
  00f38	00 00 00 00	 DD	 $LN2@inflateBac@2
inflateBack ENDP
_TEXT	ENDS
PUBLIC	inflateBackEnd
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackEnd DD imagerel $LN5
	DD	imagerel $LN5+65
	DD	imagerel $unwind$inflateBackEnd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackEnd DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflateBackEnd
_TEXT	SEGMENT
strm$ = 48
inflateBackEnd PROC					; COMDAT

; 625  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 626  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 28		 je	 SHORT $LN1@inflateBac@3
  0000e	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]
  00012	48 85 d2	 test	 rdx, rdx
  00015	74 1f		 je	 SHORT $LN1@inflateBac@3
  00017	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0001b	48 85 c0	 test	 rax, rax
  0001e	74 16		 je	 SHORT $LN1@inflateBac@3

; 628  :     ZFREE(strm, strm->state);

  00020	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00024	ff d0		 call	 rax

; 629  :     strm->state = Z_NULL;

  00026	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 630  :     Tracev((stderr, "inflate: end\n"));
; 631  :     return Z_OK;

  0002e	33 c0		 xor	 eax, eax

; 632  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
$LN1@inflateBac@3:

; 627  :         return Z_STREAM_ERROR;

  00036	b8 fe ff ff ff	 mov	 eax, -2

; 632  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
inflateBackEnd ENDP
_TEXT	ENDS
END
