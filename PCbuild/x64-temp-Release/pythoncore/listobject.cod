; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BF@EBOOGILH@list_reverseiterator?$AA@	; `string'
PUBLIC	??_C@_0O@NAJHOHI@list_iterator?$AA@		; `string'
PUBLIC	??_C@_0N@MOOGCAMH@__setstate__?$AA@		; `string'
PUBLIC	??_C@_0L@NNMACJIG@__reduce__?$AA@		; `string'
PUBLIC	??_C@_0BA@BJLPBKGK@__length_hint__?$AA@		; `string'
PUBLIC	??_C@_04DONFEANM@list?$AA@			; `string'
PUBLIC	??_C@_04PIMMHFGE@sort?$AA@			; `string'
PUBLIC	??_C@_05IOMEMJEC@count?$AA@			; `string'
PUBLIC	??_C@_05FKHKFDID@index?$AA@			; `string'
PUBLIC	??_C@_06LEMKAMD@remove?$AA@			; `string'
PUBLIC	??_C@_03NJDAHFJE@pop?$AA@			; `string'
PUBLIC	??_C@_06BPBOMFNI@extend?$AA@			; `string'
PUBLIC	??_C@_06OAOPNKHP@insert?$AA@			; `string'
PUBLIC	??_C@_06PCICMFGG@append?$AA@			; `string'
PUBLIC	??_C@_04COAGEIMF@copy?$AA@			; `string'
PUBLIC	??_C@_05MEHLAELG@clear?$AA@			; `string'
PUBLIC	??_C@_0L@HOGGIPGN@__sizeof__?$AA@		; `string'
PUBLIC	??_C@_0N@FDLIKANA@__reversed__?$AA@		; `string'
PUBLIC	??_C@_0M@GAJGCIJD@__getitem__?$AA@		; `string'
PUBLIC	??_C@_08IBBDGPOF@sequence?$AA@			; `string'
PUBLIC	??_C@_07KOIEOCCE@reverse?$AA@			; `string'
PUBLIC	??_C@_03ICHNJLJF@key?$AA@			; `string'
PUBLIC	PyList_Type
PUBLIC	PyListIter_Type
PUBLIC	PyListRevIter_Type
EXTRN	PyObject_SelfIter:PROC
EXTRN	PyObject_GC_Del:PROC
EXTRN	PyType_GenericNew:PROC
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	PyObject_HashNotImplemented:PROC
EXTRN	PyType_Type:BYTE
_BSS	SEGMENT
numfree	DD	01H DUP (?)
	ALIGN	8

indexerr DQ	01H DUP (?)
?sep@?1??list_repr@@9@9 DQ 01H DUP (?)			; `list_repr'::`2'::sep
_BSS	ENDS
;	COMDAT ??_C@_0BF@EBOOGILH@list_reverseiterator?$AA@
CONST	SEGMENT
??_C@_0BF@EBOOGILH@list_reverseiterator?$AA@ DB 'list_reverseiterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NAJHOHI@list_iterator?$AA@
CONST	SEGMENT
??_C@_0O@NAJHOHI@list_iterator?$AA@ DB 'list_iterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOOGCAMH@__setstate__?$AA@
CONST	SEGMENT
??_C@_0N@MOOGCAMH@__setstate__?$AA@ DB '__setstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNMACJIG@__reduce__?$AA@
CONST	SEGMENT
??_C@_0L@NNMACJIG@__reduce__?$AA@ DB '__reduce__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
CONST	SEGMENT
??_C@_0BA@BJLPBKGK@__length_hint__?$AA@ DB '__length_hint__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DONFEANM@list?$AA@
CONST	SEGMENT
??_C@_04DONFEANM@list?$AA@ DB 'list', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PIMMHFGE@sort?$AA@
CONST	SEGMENT
??_C@_04PIMMHFGE@sort?$AA@ DB 'sort', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count?$AA@
CONST	SEGMENT
??_C@_05IOMEMJEC@count?$AA@ DB 'count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKHKFDID@index?$AA@
CONST	SEGMENT
??_C@_05FKHKFDID@index?$AA@ DB 'index', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LEMKAMD@remove?$AA@
CONST	SEGMENT
??_C@_06LEMKAMD@remove?$AA@ DB 'remove', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJDAHFJE@pop?$AA@
CONST	SEGMENT
??_C@_03NJDAHFJE@pop?$AA@ DB 'pop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06BPBOMFNI@extend?$AA@
CONST	SEGMENT
??_C@_06BPBOMFNI@extend?$AA@ DB 'extend', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OAOPNKHP@insert?$AA@
CONST	SEGMENT
??_C@_06OAOPNKHP@insert?$AA@ DB 'insert', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PCICMFGG@append?$AA@
CONST	SEGMENT
??_C@_06PCICMFGG@append?$AA@ DB 'append', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04COAGEIMF@copy?$AA@
CONST	SEGMENT
??_C@_04COAGEIMF@copy?$AA@ DB 'copy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEHLAELG@clear?$AA@
CONST	SEGMENT
??_C@_05MEHLAELG@clear?$AA@ DB 'clear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGGIPGN@__sizeof__?$AA@
CONST	SEGMENT
??_C@_0L@HOGGIPGN@__sizeof__?$AA@ DB '__sizeof__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FDLIKANA@__reversed__?$AA@
CONST	SEGMENT
??_C@_0N@FDLIKANA@__reversed__?$AA@ DB '__reversed__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GAJGCIJD@__getitem__?$AA@
CONST	SEGMENT
??_C@_0M@GAJGCIJD@__getitem__?$AA@ DB '__getitem__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBBDGPOF@sequence?$AA@
CONST	SEGMENT
??_C@_08IBBDGPOF@sequence?$AA@ DB 'sequence', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
?kwlist@?1??listsort@@9@9 DQ FLAT:??_C@_03ICHNJLJF@key?$AA@ ; `listsort'::`2'::kwlist
	DQ	FLAT:??_C@_07KOIEOCCE@reverse?$AA@
	DQ	0000000000000000H
?kwlist@?1??list_init@@9@9 DQ FLAT:??_C@_08IBBDGPOF@sequence?$AA@ ; `list_init'::`2'::kwlist
	DQ	0000000000000000H
getitem_doc DB	'x.__getitem__(y) <==> x[y]', 00H
	ORG $+5
reversed_doc DB	'L.__reversed__() -- return a reverse iterator over the l'
	DB	'ist', 00H
	ORG $+4
sizeof_doc DB	'L.__sizeof__() -- size of L in memory, in bytes', 00H
clear_doc DB	'L.clear() -> None -- remove all items from L', 00H
	ORG $+3
copy_doc DB	'L.copy() -> list -- a shallow copy of L', 00H
append_doc DB	'L.append(object) -> None -- append object to end', 00H
	ORG $+15
extend_doc DB	'L.extend(iterable) -> None -- extend list by appending e'
	DB	'lements from the iterable', 00H
	ORG $+6
insert_doc DB	'L.insert(index, object) -- insert object before index', 00H
	ORG $+2
pop_doc	DB	'L.pop([index]) -> item -- remove and return item at inde'
	DB	'x (default last).', 0aH, 'Raises IndexError if list is empty '
	DB	'or index is out of range.', 00H
	ORG $+9
remove_doc DB	'L.remove(value) -> None -- remove first occurrence of va'
	DB	'lue.', 0aH, 'Raises ValueError if the value is not present.', 00H
	ORG $+4
index_doc DB	'L.index(value, [start, [stop]]) -> integer -- return fir'
	DB	'st index of value.', 0aH, 'Raises ValueError if the value is '
	DB	'not present.', 00H
	ORG $+6
count_doc DB	'L.count(value) -> integer -- return number of occurrence'
	DB	's of value', 00H
	ORG $+5
reverse_doc DB	'L.reverse() -- reverse *IN PLACE*', 00H
	ORG $+6
sort_doc DB	'L.sort(key=None, reverse=False) -> None -- stable sort *'
	DB	'IN PLACE*', 00H
	ORG $+14
list_methods DQ	FLAT:??_C@_0M@GAJGCIJD@__getitem__?$AA@
	DQ	FLAT:list_subscript
	DD	048H
	ORG $+4
	DQ	FLAT:getitem_doc
	DQ	FLAT:??_C@_0N@FDLIKANA@__reversed__?$AA@
	DQ	FLAT:list_reversed
	DD	04H
	ORG $+4
	DQ	FLAT:reversed_doc
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:list_sizeof
	DD	04H
	ORG $+4
	DQ	FLAT:sizeof_doc
	DQ	FLAT:??_C@_05MEHLAELG@clear?$AA@
	DQ	FLAT:listclear
	DD	04H
	ORG $+4
	DQ	FLAT:clear_doc
	DQ	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DQ	FLAT:listcopy
	DD	04H
	ORG $+4
	DQ	FLAT:copy_doc
	DQ	FLAT:??_C@_06PCICMFGG@append?$AA@
	DQ	FLAT:listappend
	DD	08H
	ORG $+4
	DQ	FLAT:append_doc
	DQ	FLAT:??_C@_06OAOPNKHP@insert?$AA@
	DQ	FLAT:listinsert
	DD	01H
	ORG $+4
	DQ	FLAT:insert_doc
	DQ	FLAT:??_C@_06BPBOMFNI@extend?$AA@
	DQ	FLAT:listextend
	DD	08H
	ORG $+4
	DQ	FLAT:extend_doc
	DQ	FLAT:??_C@_03NJDAHFJE@pop?$AA@
	DQ	FLAT:listpop
	DD	01H
	ORG $+4
	DQ	FLAT:pop_doc
	DQ	FLAT:??_C@_06LEMKAMD@remove?$AA@
	DQ	FLAT:listremove
	DD	08H
	ORG $+4
	DQ	FLAT:remove_doc
	DQ	FLAT:??_C@_05FKHKFDID@index?$AA@
	DQ	FLAT:listindex
	DD	01H
	ORG $+4
	DQ	FLAT:index_doc
	DQ	FLAT:??_C@_05IOMEMJEC@count?$AA@
	DQ	FLAT:listcount
	DD	08H
	ORG $+4
	DQ	FLAT:count_doc
	DQ	FLAT:??_C@_07KOIEOCCE@reverse?$AA@
	DQ	FLAT:listreverse
	DD	04H
	ORG $+4
	DQ	FLAT:reverse_doc
	DQ	FLAT:??_C@_04PIMMHFGE@sort?$AA@
	DQ	FLAT:listsort
	DD	03H
	ORG $+4
	DQ	FLAT:sort_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
list_as_sequence DQ FLAT:list_length
	DQ	FLAT:list_concat
	DQ	FLAT:list_repeat
	DQ	FLAT:list_item
	DQ	0000000000000000H
	DQ	FLAT:list_ass_item
	DQ	0000000000000000H
	DQ	FLAT:list_contains
	DQ	FLAT:list_inplace_concat
	DQ	FLAT:list_inplace_repeat
list_doc DB	'list() -> new empty list', 0aH, 'list(iterable) -> new l'
	DB	'ist initialized from iterable''s items', 00H
	ORG $+2
list_as_mapping DQ FLAT:list_length
	DQ	FLAT:list_subscript
	DQ	FLAT:list_ass_subscript
PyList_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_04DONFEANM@list?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:list_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:list_repr
	DQ	0000000000000000H
	DQ	FLAT:list_as_sequence
	DQ	FLAT:list_as_mapping
	DQ	FLAT:PyObject_HashNotImplemented
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	02044400H
	ORG $+4
	DQ	FLAT:list_doc
	DQ	FLAT:list_traverse
	DQ	FLAT:list_clear
	DQ	FLAT:list_richcompare
	DQ	0000000000000000H
	DQ	FLAT:list_iter
	DQ	0000000000000000H
	DQ	FLAT:list_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:list_init
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:PyType_GenericNew
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
length_hint_doc DB 'Private method returning an estimate of len(list(it))'
	DB	'.', 00H
	ORG $+1
reduce_doc DB	'Return state information for pickling.', 00H
	ORG $+1
setstate_doc DB	'Set state information for unpickling.', 00H
	ORG $+10
listiter_methods DQ FLAT:??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
	DQ	FLAT:listiter_len
	DD	04H
	ORG $+4
	DQ	FLAT:length_hint_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:listiter_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:listiter_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
PyListIter_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0O@NAJHOHI@list_iterator?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:listiter_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:listiter_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:listiter_next
	DQ	FLAT:listiter_methods
	DQ	0000000000000000H
	ORG $+144
listreviter_methods DQ FLAT:??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
	DQ	FLAT:listreviter_len
	DD	04H
	ORG $+4
	DQ	FLAT:length_hint_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:listreviter_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:listreviter_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
PyListRevIter_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BF@EBOOGILH@list_reverseiterator?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:listreviter_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:listreviter_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:listreviter_next
	DQ	FLAT:listreviter_methods
	DQ	0000000000000000H
	ORG $+144
_DATA	ENDS
;	COMDAT ??_C@_07KOIEOCCE@reverse?$AA@
CONST	SEGMENT
??_C@_07KOIEOCCE@reverse?$AA@ DB 'reverse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICHNJLJF@key?$AA@
CONST	SEGMENT
??_C@_03ICHNJLJF@key?$AA@ DB 'key', 00H			; `string'
CONST	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@MDNNEGKD@list_resize?5from?5px?5thread?$AA@ ; `string'
PUBLIC	??_C@_0M@CEKCPCJF@list_resize?$AA@		; `string'
PUBLIC	??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@ ; `string'
EXTRN	__imp_realloc:PROC
EXTRN	_PxMem_Realloc:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_AssignmentError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\objects\listobject.c
pdata	SEGMENT
$pdata$list_resize DD imagerel list_resize
	DD	imagerel list_resize+132
	DD	imagerel $unwind$list_resize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$list_resize DD imagerel list_resize+132
	DD	imagerel list_resize+200
	DD	imagerel $chain$0$list_resize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$list_resize DD imagerel list_resize+200
	DD	imagerel list_resize+372
	DD	imagerel $chain$3$list_resize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$list_resize DD 041b21H
	DD	09541bH
	DD	083400H
	DD	imagerel list_resize
	DD	imagerel list_resize+132
	DD	imagerel $unwind$list_resize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$list_resize DD 020521H
	DD	083405H
	DD	imagerel list_resize
	DD	imagerel list_resize+132
	DD	imagerel $unwind$list_resize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_resize DD 040a01H
	DD	0a640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0BL@MDNNEGKD@list_resize?5from?5px?5thread?$AA@
CONST	SEGMENT
??_C@_0BL@MDNNEGKD@list_resize?5from?5px?5thread?$AA@ DB 'list_resize fro'
	DB	'm px thread', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CEKCPCJF@list_resize?$AA@
CONST	SEGMENT
??_C@_0M@CEKCPCJF@list_resize?$AA@ DB 'list_resize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
CONST	SEGMENT
??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@ DB '..\Objects\listo'
	DB	'bject.c', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT list_resize
_TEXT	SEGMENT
self$ = 64
newsize$ = 72
list_resize PROC					; COMDAT

; 27   : {

  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 28   :     PyObject **items;
; 29   :     size_t new_allocated;
; 30   :     Py_ssize_t allocated = self->allocated;

  0000a	48 8b 41 78	 mov	 rax, QWORD PTR [rcx+120]
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b f1	 mov	 rsi, rcx

; 31   : 
; 32   :     /* Bypass realloc() when a previous overallocation is large enough
; 33   :        to accommodate the newsize.  If the newsize falls lower than half
; 34   :        the allocated size, then proceed with the realloc() to shrink the list.
; 35   :     */
; 36   :     if (allocated >= newsize && newsize >= (allocated >> 1)) {

  00014	48 3b c2	 cmp	 rax, rdx
  00017	7c 19		 jl	 SHORT $LN8@list_resiz
  00019	48 d1 f8	 sar	 rax, 1
  0001c	48 3b d0	 cmp	 rdx, rax
  0001f	7c 11		 jl	 SHORT $LN8@list_resiz

; 37   :         assert(self->ob_item != NULL || newsize == 0);
; 38   :         Py_SIZE(self) = newsize;

  00021	48 89 51 60	 mov	 QWORD PTR [rcx+96], rdx

; 39   :         return 0;

  00025	33 c0		 xor	 eax, eax

; 81   : }

  00027	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0002c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN8@list_resiz:

; 40   :     }
; 41   : 
; 42   : #ifdef WITH_PARALLEL
; 43   :     if (Py_PXCTX && Py_ISPY(self)) {

  00032	e8 00 00 00 00	 call	 _Py_PXCTX
  00037	85 c0		 test	 eax, eax
  00039	74 49		 je	 SHORT $LN7@list_resiz
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@CEKCPCJF@list_resize?$AA@
  00049	4c 8b ce	 mov	 r9, rsi
  0004c	41 b8 2b 00 00
	00		 mov	 r8d, 43			; 0000002bH
  00052	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0005a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005f	85 c0		 test	 eax, eax
  00061	74 21		 je	 SHORT $LN7@list_resiz

; 44   :         PyErr_SetString(PyExc_AssignmentError, "list_resize from px thread");

  00063	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AssignmentError
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@MDNNEGKD@list_resize?5from?5px?5thread?$AA@
  00071	e8 00 00 00 00	 call	 PyErr_SetString

; 45   :         return -1;

  00076	83 c8 ff	 or	 eax, -1

; 81   : }

  00079	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0007e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
$LN7@list_resiz:
  00084	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 46   :     }
; 47   : #endif
; 48   : 
; 49   :     /* This over-allocates proportional to the list size, making room
; 50   :      * for additional growth.  The over-allocation is mild, but is
; 51   :      * enough to give linear-time amortized behavior over a long
; 52   :      * sequence of appends() in the presence of a poorly-performing
; 53   :      * system realloc().
; 54   :      * The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...
; 55   :      */
; 56   :     new_allocated = (newsize >> 3) + (newsize < 9 ? 3 : 6);

  00089	b8 03 00 00 00	 mov	 eax, 3
  0008e	48 83 ff 09	 cmp	 rdi, 9
  00092	bb 06 00 00 00	 mov	 ebx, 6
  00097	0f 4c d8	 cmovl	 ebx, eax
  0009a	48 8b c7	 mov	 rax, rdi
  0009d	48 c1 f8 03	 sar	 rax, 3
  000a1	48 03 d8	 add	 rbx, rax

; 57   : 
; 58   :     /* check for integer overflow */
; 59   :     if (new_allocated > PY_SIZE_MAX - newsize) {

  000a4	48 83 c8 ff	 or	 rax, -1
  000a8	48 2b c7	 sub	 rax, rdi
  000ab	48 3b d8	 cmp	 rbx, rax
  000ae	76 18		 jbe	 SHORT $LN6@list_resiz

; 60   :         PyErr_NoMemory();

  000b0	e8 00 00 00 00	 call	 PyErr_NoMemory
  000b5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 61   :         return -1;

  000ba	83 c8 ff	 or	 eax, -1

; 81   : }

  000bd	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000c2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c6	5f		 pop	 rdi
  000c7	c3		 ret	 0
$LN6@list_resiz:

; 62   :     } else {
; 63   :         new_allocated += newsize;
; 64   :     }
; 65   : 
; 66   :     if (newsize == 0)

  000c8	33 c0		 xor	 eax, eax
  000ca	48 03 df	 add	 rbx, rdi
  000cd	48 85 ff	 test	 rdi, rdi
  000d0	48 0f 44 d8	 cmove	 rbx, rax

; 67   :         new_allocated = 0;
; 68   :     items = self->ob_item;
; 69   :     if (new_allocated <= (PY_SIZE_MAX / sizeof(PyObject *)))

  000d4	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  000de	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  000e3	48 8b 6e 70	 mov	 rbp, QWORD PTR [rsi+112]
  000e7	48 3b d8	 cmp	 rbx, rax
  000ea	77 6b		 ja	 SHORT $LN19@list_resiz

; 70   :         PyMem_RESIZE(items, PyObject *, new_allocated);

  000ec	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  000f6	48 3b d8	 cmp	 rbx, rax
  000f9	77 5c		 ja	 SHORT $LN19@list_resiz
  000fb	e8 00 00 00 00	 call	 _Py_PXCTX
  00100	85 c0		 test	 eax, eax
  00102	74 12		 je	 SHORT $LN15@list_resiz
  00104	48 8d 14 dd 00
	00 00 00	 lea	 rdx, QWORD PTR [rbx*8]
  0010c	48 8b cd	 mov	 rcx, rbp
  0010f	e8 00 00 00 00	 call	 _PxMem_Realloc
  00114	eb 2c		 jmp	 SHORT $LN2@list_resiz
$LN15@list_resiz:
  00116	48 8d 04 dd 00
	00 00 00	 lea	 rax, QWORD PTR [rbx*8]
  0011e	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00128	48 3b c1	 cmp	 rax, rcx
  0012b	77 2a		 ja	 SHORT $LN19@list_resiz
  0012d	48 85 c0	 test	 rax, rax
  00130	ba 01 00 00 00	 mov	 edx, 1
  00135	48 8b cd	 mov	 rcx, rbp
  00138	48 0f 45 d0	 cmovne	 rdx, rax
  0013c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
$LN2@list_resiz:

; 71   :     else
; 72   :         items = NULL;
; 73   :     if (items == NULL) {

  00142	48 85 c0	 test	 rax, rax
  00145	74 10		 je	 SHORT $LN19@list_resiz

; 76   :     }
; 77   :     self->ob_item = items;

  00147	48 89 46 70	 mov	 QWORD PTR [rsi+112], rax

; 78   :     Py_SIZE(self) = newsize;

  0014b	48 89 7e 60	 mov	 QWORD PTR [rsi+96], rdi

; 79   :     self->allocated = new_allocated;

  0014f	48 89 5e 78	 mov	 QWORD PTR [rsi+120], rbx

; 80   :     return 0;

  00153	33 c0		 xor	 eax, eax
  00155	eb 08		 jmp	 SHORT $LN21@list_resiz
$LN19@list_resiz:

; 74   :         PyErr_NoMemory();

  00157	e8 00 00 00 00	 call	 PyErr_NoMemory

; 75   :         return -1;

  0015c	83 c8 ff	 or	 eax, -1
$LN21@list_resiz:

; 81   : }

  0015f	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00164	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00169	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0016e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00172	5f		 pop	 rdi
  00173	c3		 ret	 0
list_resize ENDP
_TEXT	ENDS
PUBLIC	PyList_ClearFreeList
_BSS	SEGMENT
free_list DQ	050H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_ClearFreeList DD imagerel $LN8
	DD	imagerel $LN8+39
	DD	imagerel $unwind$PyList_ClearFreeList
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyList_ClearFreeList DD imagerel $LN8+39
	DD	imagerel $LN8+99
	DD	imagerel $chain$0$PyList_ClearFreeList
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyList_ClearFreeList DD imagerel $LN8+99
	DD	imagerel $LN8+107
	DD	imagerel $chain$1$PyList_ClearFreeList
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyList_ClearFreeList DD 021H
	DD	imagerel $LN8
	DD	imagerel $LN8+39
	DD	imagerel $unwind$PyList_ClearFreeList
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyList_ClearFreeList DD 020521H
	DD	067405H
	DD	imagerel $LN8
	DD	imagerel $LN8+39
	DD	imagerel $unwind$PyList_ClearFreeList
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_ClearFreeList DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyList_ClearFreeList
_TEXT	SEGMENT
PyList_ClearFreeList PROC				; COMDAT

; 110  : {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 111  :     PyListObject *op;
; 112  :     int ret = numfree;

  00006	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR numfree

; 113  :     if (Py_PXCTX)

  0000c	e8 00 00 00 00	 call	 _Py_PXCTX
  00011	85 c0		 test	 eax, eax
  00013	74 08		 je	 SHORT $LN6@PyList_Cle

; 114  :         return 0;

  00015	33 c0		 xor	 eax, eax

; 121  : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
$LN6@PyList_Cle:

; 115  :     while (numfree) {

  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR numfree
  00023	85 c9		 test	 ecx, ecx
  00025	74 3c		 je	 SHORT $LN1@PyList_Cle
  00027	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0002c	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:free_list
  00033	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL2@PyList_Cle:

; 116  :         op = free_list[--numfree];

  00040	ff c9		 dec	 ecx
  00042	89 0d 00 00 00
	00		 mov	 DWORD PTR numfree, ecx

; 117  :         assert(PyList_CheckExact(op));
; 118  :         PyObject_GC_Del(op);

  00048	48 63 c9	 movsxd	 rcx, ecx
  0004b	48 8b 0c cf	 mov	 rcx, QWORD PTR [rdi+rcx*8]
  0004f	e8 00 00 00 00	 call	 PyObject_GC_Del
  00054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR numfree
  0005a	85 c9		 test	 ecx, ecx
  0005c	75 e2		 jne	 SHORT $LL2@PyList_Cle
  0005e	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN1@PyList_Cle:

; 119  :     }
; 120  :     return ret;

  00063	8b c3		 mov	 eax, ebx

; 121  : }

  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	5b		 pop	 rbx
  0006a	c3		 ret	 0
PyList_ClearFreeList ENDP
_TEXT	ENDS
PUBLIC	PyList_Fini
; Function compile flags: /Ogtpy
;	COMDAT PyList_Fini
_TEXT	SEGMENT
PyList_Fini PROC					; COMDAT

; 126  :     PyList_ClearFreeList();
; 127  : }

  00000	e9 00 00 00 00	 jmp	 PyList_ClearFreeList
PyList_Fini ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@LHCEILJJ@free?5PyListObject?$AA@	; `string'
PUBLIC	_PyList_DebugMallocStats
EXTRN	_PyDebugAllocatorStats:PROC
;	COMDAT ??_C@_0BC@LHCEILJJ@free?5PyListObject?$AA@
CONST	SEGMENT
??_C@_0BC@LHCEILJJ@free?5PyListObject?$AA@ DB 'free PyListObject', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyList_DebugMallocStats
_TEXT	SEGMENT
out$ = 8
_PyList_DebugMallocStats PROC				; COMDAT

; 133  :     _PyDebugAllocatorStats(out,
; 134  :                            "free PyListObject",
; 135  :                            numfree, sizeof(PyListObject));

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR numfree
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@LHCEILJJ@free?5PyListObject?$AA@
  0000e	41 b9 80 00 00
	00		 mov	 r9d, 128		; 00000080H

; 136  : }

  00014	e9 00 00 00 00	 jmp	 _PyDebugAllocatorStats
_PyList_DebugMallocStats ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ ; `string'
PUBLIC	??_C@_0L@LDEBGCGJ@PyList_New?$AA@		; `string'
PUBLIC	PyList_New
EXTRN	_PyGC_generation0:QWORD
EXTRN	Py_FatalError:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	_PyObject_GC_New:PROC
EXTRN	_PxObject_New:PROC
EXTRN	_Px_NewReference:PROC
EXTRN	_PyErr_BadInternalCall:PROC
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_New DD imagerel $LN31
	DD	imagerel $LN31+181
	DD	imagerel $unwind$PyList_New
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyList_New DD imagerel $LN31+181
	DD	imagerel $LN31+202
	DD	imagerel $chain$3$PyList_New
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyList_New DD imagerel $LN31+202
	DD	imagerel $LN31+249
	DD	imagerel $chain$4$PyList_New
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyList_New DD imagerel $LN31+249
	DD	imagerel $LN31+512
	DD	imagerel $chain$5$PyList_New
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$PyList_New DD imagerel $LN31+512
	DD	imagerel $LN31+533
	DD	imagerel $chain$6$PyList_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$PyList_New DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+181
	DD	imagerel $unwind$PyList_New
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyList_New DD 020021H
	DD	0a7400H
	DD	imagerel $LN31
	DD	imagerel $LN31+181
	DD	imagerel $unwind$PyList_New
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyList_New DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+181
	DD	imagerel $unwind$PyList_New
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyList_New DD 020521H
	DD	0a7405H
	DD	imagerel $LN31
	DD	imagerel $LN31+181
	DD	imagerel $unwind$PyList_New
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_New DD 084f01H
	DD	0bc44fH
	DD	09544aH
	DD	083445H
	DD	060025206H
xdata	ENDS
;	COMDAT ??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
CONST	SEGMENT
??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ DB 'GC object alread'
	DB	'y tracked', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LDEBGCGJ@PyList_New?$AA@
CONST	SEGMENT
??_C@_0L@LDEBGCGJ@PyList_New?$AA@ DB 'PyList_New', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyList_New
_TEXT	SEGMENT
size$ = 64
PyList_New PROC						; COMDAT

; 140  : {

$LN31:
  00000	40 56		 push	 rsi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b f1	 mov	 rsi, rcx

; 141  :     PyListObject *op;
; 142  :     size_t nbytes;
; 143  : #ifdef SHOW_ALLOC_COUNT
; 144  :     static int initialized = 0;
; 145  :     if (!initialized) {
; 146  :         Py_AtExit(show_alloc);
; 147  :         initialized = 1;
; 148  :     }
; 149  : #endif
; 150  : 
; 151  :     if (size < 0) {

  00009	48 85 c9	 test	 rcx, rcx
  0000c	79 19		 jns	 SHORT $LN13@PyList_New

; 152  :         PyErr_BadInternalCall();

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00015	ba 98 00 00 00	 mov	 edx, 152		; 00000098H
  0001a	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 153  :         return NULL;

  0001f	33 c0		 xor	 eax, eax

; 189  : }

  00021	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00025	5e		 pop	 rsi
  00026	c3		 ret	 0
$LN13@PyList_New:

; 154  :     }
; 155  :     /* Check for overflow without an actual overflow,
; 156  :      *  which can cause compiler to optimise out */
; 157  :     if ((size_t)size > PY_SIZE_MAX / sizeof(PyObject *))

  00027	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00031	48 3b c8	 cmp	 rcx, rax
  00034	76 0a		 jbe	 SHORT $LN12@PyList_New

; 189  : }

  00036	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003a	5e		 pop	 rsi
  0003b	e9 00 00 00 00	 jmp	 PyErr_NoMemory
$LN12@PyList_New:
  00040	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00045	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  0004a	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12

; 158  :         return PyErr_NoMemory();
; 159  :     nbytes = size * sizeof(PyObject *);

  0004f	48 8d 2c cd 00
	00 00 00	 lea	 rbp, QWORD PTR [rcx*8]

; 160  :     if (!Py_PXCTX && numfree) {

  00057	e8 00 00 00 00	 call	 _Py_PXCTX
  0005c	41 bc 01 00 00
	00		 mov	 r12d, 1
  00062	85 c0		 test	 eax, eax
  00064	75 6a		 jne	 SHORT $LN11@PyList_New
  00066	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numfree
  0006c	85 c0		 test	 eax, eax
  0006e	74 60		 je	 SHORT $LN11@PyList_New

; 161  :         numfree--;

  00070	ff c8		 dec	 eax

; 162  :         op = free_list[numfree];

  00072	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:free_list

; 163  :         _Py_NewReference((PyObject *)op);

  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00080	89 05 00 00 00
	00		 mov	 DWORD PTR numfree, eax
  00086	48 98		 cdqe
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LDEBGCGJ@PyList_New?$AA@
  0008f	48 8b 1c c3	 mov	 rbx, QWORD PTR [rbx+rax*8]
  00093	41 b8 a3 00 00
	00		 mov	 r8d, 163		; 000000a3H
  00099	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000a1	4c 8b cb	 mov	 r9, rbx
  000a4	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a9	85 c0		 test	 eax, eax
  000ab	74 1d		 je	 SHORT $LN16@PyList_New
  000ad	48 8b cb	 mov	 rcx, rbx
  000b0	e8 00 00 00 00	 call	 _Px_NewReference
$LN9@PyList_New:

; 171  : #ifdef SHOW_ALLOC_COUNT
; 172  :         count_alloc++;
; 173  : #endif
; 174  :     }
; 175  :     if (size <= 0)

  000b5	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  000ba	48 85 f6	 test	 rsi, rsi
  000bd	7f 3a		 jg	 SHORT $LN8@PyList_New

; 176  :         op->ob_item = NULL;

  000bf	33 ff		 xor	 edi, edi
  000c1	48 89 7b 70	 mov	 QWORD PTR [rbx+112], rdi

; 177  :     else {

  000c5	e9 90 00 00 00	 jmp	 $LN7@PyList_New
$LN16@PyList_New:

; 163  :         _Py_NewReference((PyObject *)op);

  000ca	4c 89 63 50	 mov	 QWORD PTR [rbx+80], r12

; 164  : #ifdef SHOW_ALLOC_COUNT
; 165  :         count_reuse++;
; 166  : #endif
; 167  :     } else {

  000ce	eb e5		 jmp	 SHORT $LN9@PyList_New
$LN11@PyList_New:

; 168  :         op = PyObject_GC_New(PyListObject, &PyList_Type);

  000d0	e8 00 00 00 00	 call	 _Py_PXCTX
  000d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyList_Type
  000dc	85 c0		 test	 eax, eax
  000de	74 07		 je	 SHORT $LN18@PyList_New
  000e0	e8 00 00 00 00	 call	 _PxObject_New
  000e5	eb 05		 jmp	 SHORT $LN30@PyList_New
$LN18@PyList_New:
  000e7	e8 00 00 00 00	 call	 _PyObject_GC_New
$LN30@PyList_New:
  000ec	48 8b d8	 mov	 rbx, rax

; 169  :         if (op == NULL)

  000ef	48 85 c0	 test	 rax, rax
  000f2	75 c1		 jne	 SHORT $LN9@PyList_New

; 170  :             return NULL;

  000f4	e9 07 01 00 00	 jmp	 $LN28@PyList_New
$LN8@PyList_New:

; 178  :         op->ob_item = (PyObject **) PyMem_MALLOC(nbytes);

  000f9	e8 00 00 00 00	 call	 _Py_PXCTX
  000fe	33 ff		 xor	 edi, edi
  00100	85 c0		 test	 eax, eax
  00102	74 0a		 je	 SHORT $LN22@PyList_New
  00104	48 8b cd	 mov	 rcx, rbp
  00107	e8 00 00 00 00	 call	 _PxMem_Malloc
  0010c	eb 24		 jmp	 SHORT $LN21@PyList_New
$LN22@PyList_New:
  0010e	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00118	48 3b e8	 cmp	 rbp, rax
  0011b	76 05		 jbe	 SHORT $LN20@PyList_New
  0011d	48 8b c7	 mov	 rax, rdi
  00120	eb 10		 jmp	 SHORT $LN21@PyList_New
$LN20@PyList_New:
  00122	48 85 ed	 test	 rbp, rbp
  00125	4c 0f 45 e5	 cmovne	 r12, rbp
  00129	49 8b cc	 mov	 rcx, r12
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN21@PyList_New:
  00132	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 179  :         if (op->ob_item == NULL) {

  00136	48 85 c0	 test	 rax, rax
  00139	75 12		 jne	 SHORT $LN6@PyList_New

; 180  :             Py_DECREF(op);

  0013b	48 8b cb	 mov	 rcx, rbx
  0013e	e8 00 00 00 00	 call	 _Py_DecRef

; 181  :             return PyErr_NoMemory();

  00143	e8 00 00 00 00	 call	 PyErr_NoMemory
  00148	e9 ae 00 00 00	 jmp	 $LN29@PyList_New
$LN6@PyList_New:

; 182  :         }
; 183  :         memset(op->ob_item, 0, nbytes);

  0014d	4c 8b c5	 mov	 r8, rbp
  00150	33 d2		 xor	 edx, edx
  00152	48 8b c8	 mov	 rcx, rax
  00155	e8 00 00 00 00	 call	 memset
$LN7@PyList_New:

; 184  :     }
; 185  :     Py_SIZE(op) = size;
; 186  :     op->allocated = size;
; 187  :     _PyObject_GC_TRACK(op);

  0015a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LDEBGCGJ@PyList_New?$AA@
  00168	4c 8b cb	 mov	 r9, rbx
  0016b	41 b8 bb 00 00
	00		 mov	 r8d, 187		; 000000bbH
  00171	48 89 73 60	 mov	 QWORD PTR [rbx+96], rsi
  00175	48 89 73 78	 mov	 QWORD PTR [rbx+120], rsi
  00179	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00181	e8 00 00 00 00	 call	 _PyParallel_Guard
  00186	85 c0		 test	 eax, eax
  00188	75 6e		 jne	 SHORT $LN2@PyList_New
  0018a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00191	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LDEBGCGJ@PyList_New?$AA@
  00198	4c 8b cb	 mov	 r9, rbx
  0019b	41 b8 bb 00 00
	00		 mov	 r8d, 187		; 000000bbH
  001a1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001a9	e8 00 00 00 00	 call	 _PyParallel_Guard
  001ae	85 c0		 test	 eax, eax
  001b0	75 04		 jne	 SHORT $LN25@PyList_New
  001b2	48 8d 7b e8	 lea	 rdi, QWORD PTR [rbx-24]
$LN25@PyList_New:
  001b6	48 83 7f 10 fe	 cmp	 QWORD PTR [rdi+16], -2
  001bb	74 0c		 je	 SHORT $LN1@PyList_New
  001bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
  001c4	e8 00 00 00 00	 call	 Py_FatalError
$LN1@PyList_New:
  001c9	48 c7 47 10 fd
	ff ff ff	 mov	 QWORD PTR [rdi+16], -3
  001d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  001d8	48 89 07	 mov	 QWORD PTR [rdi], rax
  001db	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  001e2	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  001e6	48 89 4f 08	 mov	 QWORD PTR [rdi+8], rcx
  001ea	48 89 39	 mov	 QWORD PTR [rcx], rdi
  001ed	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  001f4	48 89 78 08	 mov	 QWORD PTR [rax+8], rdi
$LN2@PyList_New:

; 188  :     return (PyObject *) op;

  001f8	48 8b c3	 mov	 rax, rbx
$LN29@PyList_New:
  001fb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
$LN28@PyList_New:
  00200	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00205	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0020a	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]

; 189  : }

  0020f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00213	5e		 pop	 rsi
  00214	c3		 ret	 0
PyList_New ENDP
_TEXT	ENDS
PUBLIC	PyList_Size
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_Size DD imagerel $LN5
	DD	imagerel $LN5+55
	DD	imagerel $unwind$PyList_Size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_Size DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyList_Size
_TEXT	SEGMENT
op$ = 48
PyList_Size PROC					; COMDAT

; 193  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 194  :     if (!PyList_Check(op)) {

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  00012	75 1a		 jne	 SHORT $LN2@PyList_Siz

; 195  :         PyErr_BadInternalCall();

  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0001b	ba c3 00 00 00	 mov	 edx, 195		; 000000c3H
  00020	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 196  :         return -1;

  00025	48 83 c8 ff	 or	 rax, -1

; 200  : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
$LN2@PyList_Siz:

; 197  :     }
; 198  :     else
; 199  :         return Py_SIZE(op);

  0002e	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]

; 200  : }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00036	c3		 ret	 0
PyList_Size ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@PPFNPBPL@list?5index?5out?5of?5range?$AA@ ; `string'
PUBLIC	PyList_GetItem
EXTRN	PyErr_SetObject:PROC
EXTRN	PyExc_IndexError:QWORD
EXTRN	PyUnicode_FromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_GetItem DD imagerel $LN9
	DD	imagerel $LN9+126
	DD	imagerel $unwind$PyList_GetItem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_GetItem DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BI@PPFNPBPL@list?5index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BI@PPFNPBPL@list?5index?5out?5of?5range?$AA@ DB 'list index out of'
	DB	' range', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyList_GetItem
_TEXT	SEGMENT
op$ = 48
i$ = 56
PyList_GetItem PROC					; COMDAT

; 206  : {

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 207  :     if (!PyList_Check(op)) {

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  00012	75 18		 jne	 SHORT $LN5@PyList_Get

; 208  :         PyErr_BadInternalCall();

  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0001b	ba d0 00 00 00	 mov	 edx, 208		; 000000d0H
  00020	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 219  :         return NULL;

  00025	33 c0		 xor	 eax, eax

; 222  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
$LN5@PyList_Get:

; 209  :         return NULL;
; 210  :     }
; 211  :     if (i < 0 || i >= Py_SIZE(op)) {

  0002c	48 85 d2	 test	 rdx, rdx
  0002f	78 13		 js	 SHORT $LN3@PyList_Get
  00031	48 3b 51 60	 cmp	 rdx, QWORD PTR [rcx+96]
  00035	7d 0d		 jge	 SHORT $LN3@PyList_Get

; 220  :     }
; 221  :     return ((PyListObject *)op) -> ob_item[i];

  00037	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  0003b	48 8b 04 d0	 mov	 rax, QWORD PTR [rax+rdx*8]

; 222  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
$LN3@PyList_Get:

; 212  :         if (indexerr == NULL) {

  00044	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR indexerr
  0004b	48 85 c0	 test	 rax, rax
  0004e	75 18		 jne	 SHORT $LN1@PyList_Get

; 213  :             indexerr = PyUnicode_FromString(
; 214  :                 "list index out of range");

  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PPFNPBPL@list?5index?5out?5of?5range?$AA@
  00057	e8 00 00 00 00	 call	 PyUnicode_FromString
  0005c	48 89 05 00 00
	00 00		 mov	 QWORD PTR indexerr, rax

; 215  :             if (indexerr == NULL)

  00063	48 85 c0	 test	 rax, rax

; 216  :                 return NULL;

  00066	74 0f		 je	 SHORT $LN8@PyList_Get
$LN1@PyList_Get:

; 217  :         }
; 218  :         PyErr_SetObject(PyExc_IndexError, indexerr);

  00068	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0006f	48 8b d0	 mov	 rdx, rax
  00072	e8 00 00 00 00	 call	 PyErr_SetObject
$LN8@PyList_Get:

; 219  :         return NULL;

  00077	33 c0		 xor	 eax, eax

; 222  : }

  00079	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007d	c3		 ret	 0
PyList_GetItem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@MGPAAEOB@list?5assignment?5index?5out?5of?5ran@ ; `string'
PUBLIC	PyList_SetItem
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyList_SetItem DD imagerel $LN30
	DD	imagerel $LN30+243
	DD	imagerel $unwind$PyList_SetItem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_SetItem DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0CD@MGPAAEOB@list?5assignment?5index?5out?5of?5ran@
CONST	SEGMENT
??_C@_0CD@MGPAAEOB@list?5assignment?5index?5out?5of?5ran@ DB 'list assign'
	DB	'ment index out of range', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
CONST	ENDS
;	COMDAT PyList_SetItem
_TEXT	SEGMENT
op$ = 64
i$ = 72
newitem$ = 80
PyList_SetItem PROC					; COMDAT

; 227  : {

$LN30:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 228  :     register PyObject *olditem;
; 229  :     register PyObject **p;
; 230  :     if (!PyList_Check(op)) {

  00006	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000a	49 8b d8	 mov	 rbx, r8
  0000d	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  00017	0f 85 84 00 00
	00		 jne	 $LN15@PyList_Set

; 231  :         Py_XDECREF(newitem);

  0001d	48 85 db	 test	 rbx, rbx
  00020	74 65		 je	 SHORT $LN13@PyList_Set
  00022	e8 00 00 00 00	 call	 _Py_PXCTX
  00027	85 c0		 test	 eax, eax
  00029	75 5c		 jne	 SHORT $LN13@PyList_Set
  0002b	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0002f	a8 20		 test	 al, 32			; 00000020H
  00031	75 4c		 jne	 SHORT $LN22@PyList_Set
  00033	84 c0		 test	 al, al
  00035	78 48		 js	 SHORT $LN22@PyList_Set
  00037	a8 02		 test	 al, 2
  00039	75 4c		 jne	 SHORT $LN13@PyList_Set
  0003b	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0003f	75 46		 jne	 SHORT $LN13@PyList_Set
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0004f	4c 8b cb	 mov	 r9, rbx
  00052	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00058	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00060	e8 00 00 00 00	 call	 _PyParallel_Guard
  00065	48 8b cb	 mov	 rcx, rbx
  00068	85 c0		 test	 eax, eax
  0006a	74 07		 je	 SHORT $LN27@PyList_Set
  0006c	e8 00 00 00 00	 call	 _Px_Dealloc
  00071	eb 14		 jmp	 SHORT $LN13@PyList_Set
$LN27@PyList_Set:
  00073	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00077	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0007d	eb 08		 jmp	 SHORT $LN13@PyList_Set
$LN22@PyList_Set:
  0007f	48 8b cb	 mov	 rcx, rbx
  00082	e8 00 00 00 00	 call	 Px_DecRef
$LN13@PyList_Set:

; 232  :         PyErr_BadInternalCall();

  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0008e	ba e8 00 00 00	 mov	 edx, 232		; 000000e8H
  00093	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 245  :         return -1;

  00098	83 c8 ff	 or	 eax, -1

; 256  : }

  0009b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009f	5b		 pop	 rbx
  000a0	c3		 ret	 0
$LN15@PyList_Set:

; 233  :         return -1;
; 234  :     }
; 235  : 
; 236  :     /*
; 237  :     if (Px_PROTECTION_ERROR(op))
; 238  :         return -1;
; 239  :     */
; 240  : 
; 241  :     if (i < 0 || i >= Py_SIZE(op)) {

  000a1	48 85 d2	 test	 rdx, rdx
  000a4	78 24		 js	 SHORT $LN8@PyList_Set
  000a6	48 3b 51 60	 cmp	 rdx, QWORD PTR [rcx+96]
  000aa	7d 1e		 jge	 SHORT $LN8@PyList_Set

; 246  :     }
; 247  :     p = ((PyListObject *)op) -> ob_item + i;

  000ac	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]

; 248  :     olditem = *p;

  000b0	48 8b 0c d0	 mov	 rcx, QWORD PTR [rax+rdx*8]

; 249  :     /*
; 250  :     if (Px_ASSIGNMENT_ERROR(op, olditem))
; 251  :         return -1;
; 252  :     */
; 253  :     *p = newitem;

  000b4	48 89 1c d0	 mov	 QWORD PTR [rax+rdx*8], rbx

; 254  :     Py_XDECREF(olditem);

  000b8	48 85 c9	 test	 rcx, rcx
  000bb	74 05		 je	 SHORT $LN3@PyList_Set
  000bd	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyList_Set:

; 255  :     return 0;

  000c2	33 c0		 xor	 eax, eax

; 256  : }

  000c4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c8	5b		 pop	 rbx
  000c9	c3		 ret	 0
$LN8@PyList_Set:

; 242  :         Py_XDECREF(newitem);

  000ca	48 85 db	 test	 rbx, rbx
  000cd	74 08		 je	 SHORT $LN7@PyList_Set
  000cf	48 8b cb	 mov	 rcx, rbx
  000d2	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@PyList_Set:

; 243  :         PyErr_SetString(PyExc_IndexError,
; 244  :                         "list assignment index out of range");

  000d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  000de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@MGPAAEOB@list?5assignment?5index?5out?5of?5ran@
  000e5	e8 00 00 00 00	 call	 PyErr_SetString

; 245  :         return -1;

  000ea	83 c8 ff	 or	 eax, -1

; 256  : }

  000ed	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f1	5b		 pop	 rbx
  000f2	c3		 ret	 0
PyList_SetItem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@KPHNNLBH@cannot?5add?5more?5objects?5to?5list?$AA@ ; `string'
EXTRN	PyExc_OverflowError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$ins1 DD	imagerel ins1
	DD	imagerel ins1+212
	DD	imagerel $unwind$ins1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ins1 DD	081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_0CA@KPHNNLBH@cannot?5add?5more?5objects?5to?5list?$AA@
CONST	SEGMENT
??_C@_0CA@KPHNNLBH@cannot?5add?5more?5objects?5to?5list?$AA@ DB 'cannot a'
	DB	'dd more objects to list', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ins1
_TEXT	SEGMENT
self$ = 48
where$ = 56
v$ = 64
ins1	PROC						; COMDAT

; 260  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 261  :     Py_ssize_t i, n = Py_SIZE(self);

  00014	48 8b 71 60	 mov	 rsi, QWORD PTR [rcx+96]
  00018	49 8b e8	 mov	 rbp, r8
  0001b	48 8b da	 mov	 rbx, rdx
  0001e	48 8b f9	 mov	 rdi, rcx

; 262  :     PyObject **items;
; 263  :     if (v == NULL) {

  00021	4d 85 c0	 test	 r8, r8
  00024	75 19		 jne	 SHORT $LN8@ins1

; 264  :         PyErr_BadInternalCall();

  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0002d	ba 08 01 00 00	 mov	 edx, 264		; 00000108H
  00032	e8 00 00 00 00	 call	 _PyErr_BadInternalCall
$LN13@ins1:

; 265  :         return -1;

  00037	83 c8 ff	 or	 eax, -1
  0003a	e9 80 00 00 00	 jmp	 $LN9@ins1
$LN8@ins1:

; 266  :     }
; 267  :     if (n == PY_SSIZE_T_MAX) {

  0003f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00049	48 3b f0	 cmp	 rsi, rax
  0004c	75 18		 jne	 SHORT $LN7@ins1

; 268  :         PyErr_SetString(PyExc_OverflowError,
; 269  :             "cannot add more objects to list");

  0004e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@KPHNNLBH@cannot?5add?5more?5objects?5to?5list?$AA@
  0005c	e8 00 00 00 00	 call	 PyErr_SetString

; 270  :         return -1;

  00061	83 c8 ff	 or	 eax, -1
  00064	eb 59		 jmp	 SHORT $LN9@ins1
$LN7@ins1:

; 271  :     }
; 272  : 
; 273  :     /* Px_CHECK_PROTECTION handled by list_resize() */
; 274  :     if (list_resize(self, n+1) == -1)

  00066	48 8d 56 01	 lea	 rdx, QWORD PTR [rsi+1]
  0006a	e8 00 00 00 00	 call	 list_resize
  0006f	83 f8 ff	 cmp	 eax, -1

; 275  :         return -1;

  00072	74 c3		 je	 SHORT $LN13@ins1

; 276  : 
; 277  :     if (where < 0) {

  00074	48 85 db	 test	 rbx, rbx
  00077	79 0c		 jns	 SHORT $LN4@ins1

; 278  :         where += n;

  00079	48 03 de	 add	 rbx, rsi

; 279  :         if (where < 0)

  0007c	b8 00 00 00 00	 mov	 eax, 0
  00081	48 0f 48 d8	 cmovs	 rbx, rax
$LN4@ins1:

; 280  :             where = 0;
; 281  :     }
; 282  :     if (where > n)
; 283  :         where = n;
; 284  :     items = self->ob_item;

  00085	48 8b 7f 70	 mov	 rdi, QWORD PTR [rdi+112]
  00089	48 3b de	 cmp	 rbx, rsi

; 285  :     for (i = n; --i >= where; )

  0008c	48 8d 4e ff	 lea	 rcx, QWORD PTR [rsi-1]
  00090	48 0f 4f de	 cmovg	 rbx, rsi
  00094	48 3b cb	 cmp	 rcx, rbx
  00097	7c 18		 jl	 SHORT $LN1@ins1
  00099	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@ins1:

; 286  :         items[i+1] = items[i];

  000a0	48 8b 04 cf	 mov	 rax, QWORD PTR [rdi+rcx*8]
  000a4	48 ff c9	 dec	 rcx
  000a7	48 89 44 cf 10	 mov	 QWORD PTR [rdi+rcx*8+16], rax
  000ac	48 3b cb	 cmp	 rcx, rbx
  000af	7d ef		 jge	 SHORT $LL2@ins1
$LN1@ins1:

; 287  :     Py_INCREF(v);

  000b1	48 8b cd	 mov	 rcx, rbp
  000b4	e8 00 00 00 00	 call	 _Py_IncRef

; 288  :     items[where] = v;

  000b9	48 89 2c df	 mov	 QWORD PTR [rdi+rbx*8], rbp

; 289  :     return 0;

  000bd	33 c0		 xor	 eax, eax
$LN9@ins1:

; 290  : }

  000bf	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c4	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000c9	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000ce	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
ins1	ENDP
_TEXT	ENDS
PUBLIC	PyList_Insert
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_Insert DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$PyList_Insert
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_Insert DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyList_Insert
_TEXT	SEGMENT
op$ = 48
where$ = 56
newitem$ = 64
PyList_Insert PROC					; COMDAT

; 294  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 295  :     if (!PyList_Check(op)) {

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  00012	75 19		 jne	 SHORT $LN1@PyList_Ins

; 296  :         PyErr_BadInternalCall();

  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0001b	ba 28 01 00 00	 mov	 edx, 296		; 00000128H
  00020	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 297  :         return -1;

  00025	83 c8 ff	 or	 eax, -1

; 298  :     }
; 299  :     /* Px_CHECK_PROTECTION handled by inst1()->list_resize() */
; 300  :     return ins1((PyListObject *)op, where, newitem);
; 301  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
$LN1@PyList_Ins:
  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	e9 00 00 00 00	 jmp	 ins1
PyList_Insert ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$app1 DD	imagerel app1
	DD	imagerel app1+177
	DD	imagerel $unwind$app1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$app1 DD	060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT app1
_TEXT	SEGMENT
self$ = 64
v$ = 72
app1	PROC						; COMDAT

; 305  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 306  :     Py_ssize_t n = PyList_GET_SIZE(self);

  0000f	48 8b 71 60	 mov	 rsi, QWORD PTR [rcx+96]

; 307  : 
; 308  :     assert (v != NULL);
; 309  :     if (n == PY_SSIZE_T_MAX) {

  00013	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0001d	48 8b da	 mov	 rbx, rdx
  00020	48 8b f9	 mov	 rdi, rcx
  00023	48 3b f0	 cmp	 rsi, rax
  00026	75 26		 jne	 SHORT $LN2@app1

; 310  :         PyErr_SetString(PyExc_OverflowError,
; 311  :             "cannot add more objects to list");

  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@KPHNNLBH@cannot?5add?5more?5objects?5to?5list?$AA@
  00036	e8 00 00 00 00	 call	 PyErr_SetString
$LN9@app1:

; 312  :         return -1;

  0003b	83 c8 ff	 or	 eax, -1

; 321  :     return 0;
; 322  : }

  0003e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00043	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00048	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004c	5f		 pop	 rdi
  0004d	c3		 ret	 0
$LN2@app1:

; 313  :     }
; 314  : 
; 315  :     /* Px_CHECK_PROTECTION handled by list_resize() */
; 316  :     if (list_resize(self, n+1) == -1)

  0004e	48 8d 56 01	 lea	 rdx, QWORD PTR [rsi+1]
  00052	e8 00 00 00 00	 call	 list_resize
  00057	83 f8 ff	 cmp	 eax, -1

; 317  :         return -1;

  0005a	74 df		 je	 SHORT $LN9@app1

; 318  : 
; 319  :     Py_INCREF(v);

  0005c	e8 00 00 00 00	 call	 _Py_PXCTX
  00061	85 c0		 test	 eax, eax
  00063	75 32		 jne	 SHORT $LN6@app1
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00073	4c 8b cb	 mov	 r9, rbx
  00076	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0007c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00084	e8 00 00 00 00	 call	 _PyParallel_Guard
  00089	85 c0		 test	 eax, eax
  0008b	75 06		 jne	 SHORT $LN5@app1
  0008d	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00091	74 04		 je	 SHORT $LN6@app1
$LN5@app1:
  00093	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@app1:

; 320  :     PyList_SET_ITEM(self, n, v);

  00097	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  0009b	48 89 1c f0	 mov	 QWORD PTR [rax+rsi*8], rbx

; 321  :     return 0;
; 322  : }

  0009f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a4	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000a9	33 c0		 xor	 eax, eax
  000ab	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000af	5f		 pop	 rdi
  000b0	c3		 ret	 0
app1	ENDP
_TEXT	ENDS
PUBLIC	PyList_Append
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_Append DD imagerel $LN4
	DD	imagerel $LN4+59
	DD	imagerel $unwind$PyList_Append
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_Append DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyList_Append
_TEXT	SEGMENT
op$ = 48
newitem$ = 56
PyList_Append PROC					; COMDAT

; 326  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 327  :     if (PyList_Check(op) && (newitem != NULL))

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  00012	74 0e		 je	 SHORT $LN1@PyList_App
  00014	48 85 d2	 test	 rdx, rdx
  00017	74 09		 je	 SHORT $LN1@PyList_App

; 332  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	e9 00 00 00 00	 jmp	 app1
$LN1@PyList_App:

; 328  :         /* Px_CHECK_PROTECTION handled by app1()->list_resize() */
; 329  :         return app1((PyListObject *)op, newitem);
; 330  :     PyErr_BadInternalCall();

  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00029	ba 4a 01 00 00	 mov	 edx, 330		; 0000014aH
  0002e	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 331  :     return -1;

  00033	83 c8 ff	 or	 eax, -1

; 332  : }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
PyList_Append ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@IKFOGEIE@list_dealloc?$AA@		; `string'
EXTRN	_PyTrash_thread_deposit_object:PROC
EXTRN	_PyTrash_thread_destroy_chain:PROC
EXTRN	__imp_free:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	_PyThreadState_Current:QWORD
EXTRN	_PyParallel_GetThreadState:PROC
EXTRN	PyObject_GC_UnTrack:PROC
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$list_dealloc DD imagerel list_dealloc
	DD	imagerel list_dealloc+118
	DD	imagerel $unwind$list_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$list_dealloc DD imagerel list_dealloc+118
	DD	imagerel list_dealloc+136
	DD	imagerel $chain$0$list_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$list_dealloc DD imagerel list_dealloc+136
	DD	imagerel list_dealloc+270
	DD	imagerel $chain$1$list_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$list_dealloc DD imagerel list_dealloc+270
	DD	imagerel list_dealloc+288
	DD	imagerel $chain$2$list_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$list_dealloc DD imagerel list_dealloc+288
	DD	imagerel list_dealloc+419
	DD	imagerel $chain$3$list_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$list_dealloc DD 021H
	DD	imagerel list_dealloc
	DD	imagerel list_dealloc+118
	DD	imagerel $unwind$list_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$list_dealloc DD 021H
	DD	imagerel list_dealloc+118
	DD	imagerel list_dealloc+136
	DD	imagerel $chain$0$list_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$list_dealloc DD 020521H
	DD	083405H
	DD	imagerel list_dealloc+118
	DD	imagerel list_dealloc+136
	DD	imagerel $chain$0$list_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$list_dealloc DD 020521H
	DD	096405H
	DD	imagerel list_dealloc
	DD	imagerel list_dealloc+118
	DD	imagerel $unwind$list_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_dealloc DD 040a01H
	DD	0a540aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0N@IKFOGEIE@list_dealloc?$AA@
CONST	SEGMENT
??_C@_0N@IKFOGEIE@list_dealloc?$AA@ DB 'list_dealloc', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
CONST	ENDS
;	COMDAT list_dealloc
_TEXT	SEGMENT
op$ = 64
list_dealloc PROC					; COMDAT

; 338  : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 339  :     Py_ssize_t i;
; 340  :     Py_GUARD

  0000d	e8 00 00 00 00	 call	 _Py_PXCTX
  00012	85 c0		 test	 eax, eax
  00014	74 1c		 je	 SHORT $LN16@list_deall
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@IKFOGEIE@list_dealloc?$AA@
  00024	45 33 c9	 xor	 r9d, r9d
  00027	41 b8 54 01 00
	00		 mov	 r8d, 340		; 00000154H
  0002d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN16@list_deall:

; 341  :     PyObject_GC_UnTrack(op);

  00032	48 8b cf	 mov	 rcx, rdi
  00035	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 342  :     Py_TRASHCAN_SAFE_BEGIN(op)

  0003a	e8 00 00 00 00	 call	 _Py_PXCTX
  0003f	85 c0		 test	 eax, eax
  00041	74 0a		 je	 SHORT $LN19@list_deall
  00043	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00048	48 8b e8	 mov	 rbp, rax
  0004b	eb 07		 jmp	 SHORT $LN20@list_deall
$LN19@list_deall:
  0004d	48 8b 2d 00 00
	00 00		 mov	 rbp, QWORD PTR _PyThreadState_Current
$LN20@list_deall:
  00054	8b 85 94 00 00
	00		 mov	 eax, DWORD PTR [rbp+148]
  0005a	83 f8 32	 cmp	 eax, 50			; 00000032H
  0005d	0f 8d 2d 01 00
	00		 jge	 $LN12@list_deall
  00063	ff c0		 inc	 eax
  00065	89 85 94 00 00
	00		 mov	 DWORD PTR [rbp+148], eax

; 343  :     if (op->ob_item != NULL) {

  0006b	48 83 7f 70 00	 cmp	 QWORD PTR [rdi+112], 0
  00070	0f 84 b7 00 00
	00		 je	 $LN22@list_deall

; 344  :         /* Do it backwards, for Christian Tismer.
; 345  :            There's a simple test case where somehow this reduces
; 346  :            thrashing when a *very* large list is created and
; 347  :            immediately deleted. */
; 348  :         i = Py_SIZE(op);
; 349  :         while (--i >= 0) {

  00076	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  0007b	48 8b 77 60	 mov	 rsi, QWORD PTR [rdi+96]
  0007f	48 ff ce	 dec	 rsi
  00082	0f 88 86 00 00
	00		 js	 $LN9@list_deall
  00088	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0008d	0f 1f 00	 npad	 3
$LL10@list_deall:
  00090	48 8b 5f 70	 mov	 rbx, QWORD PTR [rdi+112]

; 350  :             Py_XDECREF(op->ob_item[i]);

  00094	48 83 3c f3 00	 cmp	 QWORD PTR [rbx+rsi*8], 0
  00099	74 69		 je	 SHORT $LN7@list_deall
  0009b	48 8b 1c f3	 mov	 rbx, QWORD PTR [rbx+rsi*8]
  0009f	e8 00 00 00 00	 call	 _Py_PXCTX
  000a4	85 c0		 test	 eax, eax
  000a6	75 5c		 jne	 SHORT $LN7@list_deall
  000a8	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000ac	a8 20		 test	 al, 32			; 00000020H
  000ae	75 4c		 jne	 SHORT $LN27@list_deall
  000b0	84 c0		 test	 al, al
  000b2	78 48		 js	 SHORT $LN27@list_deall
  000b4	a8 02		 test	 al, 2
  000b6	75 4c		 jne	 SHORT $LN7@list_deall
  000b8	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000bc	75 46		 jne	 SHORT $LN7@list_deall
  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000cc	4c 8b cb	 mov	 r9, rbx
  000cf	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000d5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000dd	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e2	48 8b cb	 mov	 rcx, rbx
  000e5	85 c0		 test	 eax, eax
  000e7	74 07		 je	 SHORT $LN32@list_deall
  000e9	e8 00 00 00 00	 call	 _Px_Dealloc
  000ee	eb 14		 jmp	 SHORT $LN7@list_deall
$LN32@list_deall:
  000f0	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000f4	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000fa	eb 08		 jmp	 SHORT $LN7@list_deall
$LN27@list_deall:
  000fc	48 8b cb	 mov	 rcx, rbx
  000ff	e8 00 00 00 00	 call	 Px_DecRef
$LN7@list_deall:

; 344  :         /* Do it backwards, for Christian Tismer.
; 345  :            There's a simple test case where somehow this reduces
; 346  :            thrashing when a *very* large list is created and
; 347  :            immediately deleted. */
; 348  :         i = Py_SIZE(op);
; 349  :         while (--i >= 0) {

  00104	48 ff ce	 dec	 rsi
  00107	79 87		 jns	 SHORT $LL10@list_deall
  00109	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN9@list_deall:

; 351  :         }
; 352  :         PyMem_FREE(op->ob_item);

  0010e	e8 00 00 00 00	 call	 _Py_PXCTX
  00113	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00118	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  0011c	85 c0		 test	 eax, eax
  0011e	74 07		 je	 SHORT $LN21@list_deall
  00120	e8 00 00 00 00	 call	 _PxMem_Free
  00125	eb 06		 jmp	 SHORT $LN22@list_deall
$LN21@list_deall:
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN22@list_deall:

; 353  :     }
; 354  :     if (numfree < PyList_MAXFREELIST && PyList_CheckExact(op))

  0012d	48 63 0d 00 00
	00 00		 movsxd	 rcx, DWORD PTR numfree
  00134	83 f9 50	 cmp	 ecx, 80			; 00000050H
  00137	7d 22		 jge	 SHORT $LN4@list_deall
  00139	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyList_Type
  00140	48 39 47 58	 cmp	 QWORD PTR [rdi+88], rax
  00144	75 15		 jne	 SHORT $LN4@list_deall

; 355  :         free_list[numfree++] = op;

  00146	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:free_list
  0014d	48 89 3c ca	 mov	 QWORD PTR [rdx+rcx*8], rdi
  00151	ff c1		 inc	 ecx
  00153	89 0d 00 00 00
	00		 mov	 DWORD PTR numfree, ecx

; 356  :     else

  00159	eb 0d		 jmp	 SHORT $LN3@list_deall
$LN4@list_deall:

; 357  :         Py_TYPE(op)->tp_free((PyObject *)op);

  0015b	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0015f	48 8b cf	 mov	 rcx, rdi
  00162	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]
$LN3@list_deall:

; 358  :     Py_TRASHCAN_SAFE_END(op)

  00168	ff 8d 94 00 00
	00		 dec	 DWORD PTR [rbp+148]
  0016e	48 83 bd 98 00
	00 00 00	 cmp	 QWORD PTR [rbp+152], 0
  00176	74 20		 je	 SHORT $LN14@list_deall
  00178	83 bd 94 00 00
	00 00		 cmp	 DWORD PTR [rbp+148], 0
  0017f	7f 17		 jg	 SHORT $LN14@list_deall

; 359  : }

  00181	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00186	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0018a	5f		 pop	 rdi
  0018b	e9 00 00 00 00	 jmp	 _PyTrash_thread_destroy_chain
$LN12@list_deall:

; 358  :     Py_TRASHCAN_SAFE_END(op)

  00190	48 8b cf	 mov	 rcx, rdi
  00193	e8 00 00 00 00	 call	 _PyTrash_thread_deposit_object
$LN14@list_deall:

; 359  : }

  00198	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0019d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001a1	5f		 pop	 rdi
  001a2	c3		 ret	 0
list_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_01LBDDMOBJ@?$FN?$AA@			; `string'
PUBLIC	??_C@_0CC@LCJMBFL@?5while?5getting?5the?5repr?5of?5a?5lis@ ; `string'
PUBLIC	??_C@_09CGFMFLFL@list_repr?$AA@			; `string'
PUBLIC	??_C@_01OHGJGJJP@?$FL?$AA@			; `string'
PUBLIC	??_C@_05CLKOKHPD@?$FL?4?4?4?$FN?$AA@		; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_02GPECMEKF@?$FL?$FN?$AA@			; `string'
EXTRN	_PyAccu_Destroy:PROC
EXTRN	_PyAccu_Finish:PROC
EXTRN	Py_ReprLeave:PROC
EXTRN	PyObject_Repr:PROC
EXTRN	_Py_CheckRecursiveCall:PROC
EXTRN	_Py_CheckRecursionLimit:DWORD
EXTRN	_PyAccu_Accumulate:PROC
EXTRN	_PyAccu_Init:PROC
EXTRN	Py_ReprEnter:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_repr DD imagerel list_repr
	DD	imagerel list_repr+729
	DD	imagerel $unwind$list_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_repr DD 08a301H
	DD	0a74a3H
	DD	0c540fH
	DD	0b340fH
	DD	0600b720fH
xdata	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN?$AA@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN?$AA@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LCJMBFL@?5while?5getting?5the?5repr?5of?5a?5lis@
CONST	SEGMENT
??_C@_0CC@LCJMBFL@?5while?5getting?5the?5repr?5of?5a?5lis@ DB ' while get'
	DB	'ting the repr of a list', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09CGFMFLFL@list_repr?$AA@
CONST	SEGMENT
??_C@_09CGFMFLFL@list_repr?$AA@ DB 'list_repr', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL?$AA@
CONST	SEGMENT
??_C@_01OHGJGJJP@?$FL?$AA@ DB '[', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CLKOKHPD@?$FL?4?4?4?$FN?$AA@
CONST	SEGMENT
??_C@_05CLKOKHPD@?$FL?4?4?4?$FN?$AA@ DB '[...]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GPECMEKF@?$FL?$FN?$AA@
CONST	SEGMENT
??_C@_02GPECMEKF@?$FL?$FN?$AA@ DB '[]', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT list_repr
_TEXT	SEGMENT
acc$ = 48
v$ = 80
list_repr PROC						; COMDAT

; 363  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 364  :     Py_ssize_t i;
; 365  :     PyObject *s = NULL;

  0000f	33 ed		 xor	 ebp, ebp
  00011	48 8b f1	 mov	 rsi, rcx
  00014	8b dd		 mov	 ebx, ebp

; 366  :     _PyAccu acc;
; 367  :     static PyObject *sep = NULL;
; 368  : 
; 369  :     if (Py_SIZE(v) == 0) {

  00016	48 39 59 60	 cmp	 QWORD PTR [rcx+96], rbx
  0001a	75 1c		 jne	 SHORT $LN36@list_repr

; 370  :         return PyUnicode_FromString("[]");

  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02GPECMEKF@?$FL?$FN?$AA@
  00023	e8 00 00 00 00	 call	 PyUnicode_FromString

; 418  : }

  00028	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0002d	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00032	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00036	5e		 pop	 rsi
  00037	c3		 ret	 0
$LN36@list_repr:

; 371  :     }
; 372  : 
; 373  :     if (sep == NULL) {

  00038	48 39 1d 00 00
	00 00		 cmp	 QWORD PTR ?sep@?1??list_repr@@9@9, rbx
  0003f	75 28		 jne	 SHORT $LN34@list_repr

; 374  :         sep = PyUnicode_FromString(", ");

  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02KEGNLNML@?0?5?$AA@
  00048	e8 00 00 00 00	 call	 PyUnicode_FromString
  0004d	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?sep@?1??list_repr@@9@9, rax

; 375  :         if (sep == NULL)

  00054	48 85 c0	 test	 rax, rax
  00057	75 10		 jne	 SHORT $LN34@list_repr

; 418  : }

  00059	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0005e	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00063	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00067	5e		 pop	 rsi
  00068	c3		 ret	 0
$LN34@list_repr:

; 376  :             return NULL;
; 377  :     }
; 378  : 
; 379  :     i = Py_ReprEnter((PyObject*)v);

  00069	48 8b ce	 mov	 rcx, rsi
  0006c	e8 00 00 00 00	 call	 Py_ReprEnter

; 380  :     if (i != 0) {

  00071	85 c0		 test	 eax, eax
  00073	74 24		 je	 SHORT $LN33@list_repr

; 381  :         return i > 0 ? PyUnicode_FromString("[...]") : NULL;

  00075	7e 0f		 jle	 SHORT $LN39@list_repr
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05CLKOKHPD@?$FL?4?4?4?$FN?$AA@
  0007e	e8 00 00 00 00	 call	 PyUnicode_FromString
  00083	48 8b e8	 mov	 rbp, rax
$LN39@list_repr:
  00086	48 8b c5	 mov	 rax, rbp

; 418  : }

  00089	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0008e	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00093	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00097	5e		 pop	 rsi
  00098	c3		 ret	 0
$LN33@list_repr:

; 382  :     }
; 383  : 
; 384  :     if (_PyAccu_Init(&acc))

  00099	48 8d 4c 24 30	 lea	 rcx, QWORD PTR acc$[rsp]
  0009e	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  000a3	e8 00 00 00 00	 call	 _PyAccu_Init
  000a8	85 c0		 test	 eax, eax
  000aa	0f 85 f3 01 00
	00		 jne	 $error$20487

; 385  :         goto error;
; 386  : 
; 387  :     s = PyUnicode_FromString("[");

  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01OHGJGJJP@?$FL?$AA@
  000b7	e8 00 00 00 00	 call	 PyUnicode_FromString
  000bc	48 8b d8	 mov	 rbx, rax

; 388  :     if (s == NULL || _PyAccu_Accumulate(&acc, s))

  000bf	48 85 c0	 test	 rax, rax
  000c2	0f 84 db 01 00
	00		 je	 $error$20487
  000c8	48 8d 4c 24 30	 lea	 rcx, QWORD PTR acc$[rsp]
  000cd	48 8b d0	 mov	 rdx, rax
  000d0	e8 00 00 00 00	 call	 _PyAccu_Accumulate
  000d5	85 c0		 test	 eax, eax
  000d7	0f 85 c6 01 00
	00		 jne	 $error$20487

; 389  :         goto error;
; 390  :     Py_CLEAR(s);

  000dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09CGFMFLFL@list_repr?$AA@
  000eb	4c 8b cb	 mov	 r9, rbx
  000ee	41 b8 86 01 00
	00		 mov	 r8d, 390		; 00000186H
  000f4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000fc	e8 00 00 00 00	 call	 _PyParallel_Guard
  00101	85 c0		 test	 eax, eax
  00103	75 0b		 jne	 SHORT $LN28@list_repr
  00105	48 8b cb	 mov	 rcx, rbx
  00108	48 8b dd	 mov	 rbx, rbp
  0010b	e8 00 00 00 00	 call	 _Py_DecRef
$LN28@list_repr:

; 391  : 
; 392  :     /* Do repr() on each element.  Note that this may mutate the list,
; 393  :        so must refetch the list size on each iteration. */
; 394  :     for (i = 0; i < Py_SIZE(v); ++i) {

  00110	48 8b fd	 mov	 rdi, rbp
  00113	48 39 6e 60	 cmp	 QWORD PTR [rsi+96], rbp
  00117	0f 8e 1d 01 00
	00		 jle	 $LN23@list_repr
  0011d	0f 1f 00	 npad	 3
$LL25@list_repr:

; 395  :         if (Py_EnterRecursiveCall(" while getting the repr of a list"))

  00120	e8 00 00 00 00	 call	 _Py_PXCTX
  00125	85 c0		 test	 eax, eax
  00127	74 07		 je	 SHORT $LN41@list_repr
  00129	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0012e	eb 07		 jmp	 SHORT $LN42@list_repr
$LN41@list_repr:
  00130	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN42@list_repr:
  00137	ff 40 18	 inc	 DWORD PTR [rax+24]
  0013a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0013d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  00143	7e 14		 jle	 SHORT $LN22@list_repr
  00145	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@LCJMBFL@?5while?5getting?5the?5repr?5of?5a?5lis@
  0014c	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  00151	85 c0		 test	 eax, eax
  00153	0f 85 4a 01 00
	00		 jne	 $error$20487
$LN22@list_repr:

; 396  :             goto error;
; 397  :         s = PyObject_Repr(v->ob_item[i]);

  00159	48 8b 4e 70	 mov	 rcx, QWORD PTR [rsi+112]
  0015d	48 8b 0c f9	 mov	 rcx, QWORD PTR [rcx+rdi*8]
  00161	e8 00 00 00 00	 call	 PyObject_Repr
  00166	48 8b d8	 mov	 rbx, rax

; 398  :         Py_LeaveRecursiveCall();

  00169	e8 00 00 00 00	 call	 _Py_PXCTX
  0016e	85 c0		 test	 eax, eax
  00170	74 0a		 je	 SHORT $LN43@list_repr
  00172	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00177	4c 8b d8	 mov	 r11, rax
  0017a	eb 07		 jmp	 SHORT $LN44@list_repr
$LN43@list_repr:
  0017c	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _PyThreadState_Current
$LN44@list_repr:
  00183	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  00189	83 f8 64	 cmp	 eax, 100		; 00000064H
  0018c	7e 05		 jle	 SHORT $LN45@list_repr
  0018e	83 c0 ce	 add	 eax, -50		; ffffffffffffffceH
  00191	eb 06		 jmp	 SHORT $LN46@list_repr
$LN45@list_repr:
  00193	c1 f8 02	 sar	 eax, 2
  00196	8d 04 40	 lea	 eax, DWORD PTR [rax+rax*2]
$LN46@list_repr:
  00199	41 ff 4b 18	 dec	 DWORD PTR [r11+24]
  0019d	41 39 43 18	 cmp	 DWORD PTR [r11+24], eax
  001a1	7d 1b		 jge	 SHORT $LN20@list_repr
  001a3	e8 00 00 00 00	 call	 _Py_PXCTX
  001a8	85 c0		 test	 eax, eax
  001aa	74 07		 je	 SHORT $LN47@list_repr
  001ac	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  001b1	eb 07		 jmp	 SHORT $LN48@list_repr
$LN47@list_repr:
  001b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN48@list_repr:
  001ba	40 88 68 1c	 mov	 BYTE PTR [rax+28], bpl
$LN20@list_repr:

; 399  :         if (i > 0 && _PyAccu_Accumulate(&acc, sep))

  001be	48 85 ff	 test	 rdi, rdi
  001c1	7e 19		 jle	 SHORT $LN17@list_repr
  001c3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?sep@?1??list_repr@@9@9
  001ca	48 8d 4c 24 30	 lea	 rcx, QWORD PTR acc$[rsp]
  001cf	e8 00 00 00 00	 call	 _PyAccu_Accumulate
  001d4	85 c0		 test	 eax, eax
  001d6	0f 85 c7 00 00
	00		 jne	 $error$20487
$LN17@list_repr:

; 400  :             goto error;
; 401  :         if (s == NULL || _PyAccu_Accumulate(&acc, s))

  001dc	48 85 db	 test	 rbx, rbx
  001df	0f 84 be 00 00
	00		 je	 $error$20487
  001e5	48 8d 4c 24 30	 lea	 rcx, QWORD PTR acc$[rsp]
  001ea	48 8b d3	 mov	 rdx, rbx
  001ed	e8 00 00 00 00	 call	 _PyAccu_Accumulate
  001f2	85 c0		 test	 eax, eax
  001f4	0f 85 a9 00 00
	00		 jne	 $error$20487

; 402  :             goto error;
; 403  :         Py_CLEAR(s);

  001fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00201	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09CGFMFLFL@list_repr?$AA@
  00208	4c 8b cb	 mov	 r9, rbx
  0020b	41 b8 93 01 00
	00		 mov	 r8d, 403		; 00000193H
  00211	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00219	e8 00 00 00 00	 call	 _PyParallel_Guard
  0021e	85 c0		 test	 eax, eax
  00220	75 0b		 jne	 SHORT $LN13@list_repr
  00222	48 8b cb	 mov	 rcx, rbx
  00225	48 8b dd	 mov	 rbx, rbp
  00228	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@list_repr:

; 391  : 
; 392  :     /* Do repr() on each element.  Note that this may mutate the list,
; 393  :        so must refetch the list size on each iteration. */
; 394  :     for (i = 0; i < Py_SIZE(v); ++i) {

  0022d	48 ff c7	 inc	 rdi
  00230	48 3b 7e 60	 cmp	 rdi, QWORD PTR [rsi+96]
  00234	0f 8c e6 fe ff
	ff		 jl	 $LL25@list_repr
$LN23@list_repr:

; 404  :     }
; 405  :     s = PyUnicode_FromString("]");

  0023a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01LBDDMOBJ@?$FN?$AA@
  00241	e8 00 00 00 00	 call	 PyUnicode_FromString
  00246	48 8b d8	 mov	 rbx, rax

; 406  :     if (s == NULL || _PyAccu_Accumulate(&acc, s))

  00249	48 85 c0	 test	 rax, rax
  0024c	74 55		 je	 SHORT $error$20487
  0024e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR acc$[rsp]
  00253	48 8b d0	 mov	 rdx, rax
  00256	e8 00 00 00 00	 call	 _PyAccu_Accumulate
  0025b	85 c0		 test	 eax, eax
  0025d	75 44		 jne	 SHORT $error$20487

; 407  :         goto error;
; 408  :     Py_CLEAR(s);

  0025f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00266	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09CGFMFLFL@list_repr?$AA@
  0026d	4c 8b cb	 mov	 r9, rbx
  00270	41 b8 98 01 00
	00		 mov	 r8d, 408		; 00000198H
  00276	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0027e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00283	85 c0		 test	 eax, eax
  00285	75 08		 jne	 SHORT $LN7@list_repr
  00287	48 8b cb	 mov	 rcx, rbx
  0028a	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@list_repr:

; 409  : 
; 410  :     Py_ReprLeave((PyObject *)v);

  0028f	48 8b ce	 mov	 rcx, rsi
  00292	e8 00 00 00 00	 call	 Py_ReprLeave

; 411  :     return _PyAccu_Finish(&acc);

  00297	48 8d 4c 24 30	 lea	 rcx, QWORD PTR acc$[rsp]
  0029c	e8 00 00 00 00	 call	 _PyAccu_Finish
  002a1	eb 21		 jmp	 SHORT $LN54@list_repr
$error$20487:

; 412  : 
; 413  : error:
; 414  :     _PyAccu_Destroy(&acc);

  002a3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR acc$[rsp]
  002a8	e8 00 00 00 00	 call	 _PyAccu_Destroy

; 415  :     Py_XDECREF(s);

  002ad	48 85 db	 test	 rbx, rbx
  002b0	74 08		 je	 SHORT $LN3@list_repr
  002b2	48 8b cb	 mov	 rcx, rbx
  002b5	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@list_repr:

; 416  :     Py_ReprLeave((PyObject *)v);

  002ba	48 8b ce	 mov	 rcx, rsi
  002bd	e8 00 00 00 00	 call	 Py_ReprLeave

; 417  :     return NULL;

  002c2	33 c0		 xor	 eax, eax
$LN54@list_repr:

; 418  : }

  002c4	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  002c9	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  002ce	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  002d3	48 83 c4 40	 add	 rsp, 64			; 00000040H
  002d7	5e		 pop	 rsi
  002d8	c3		 ret	 0
list_repr ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT list_length
_TEXT	SEGMENT
a$ = 8
list_length PROC					; COMDAT

; 423  :     return Py_SIZE(a);

  00000	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]

; 424  : }

  00004	c3		 ret	 0
list_length ENDP
_TEXT	ENDS
EXTRN	PyObject_RichCompareBool:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_contains DD imagerel list_contains
	DD	imagerel list_contains+83
	DD	imagerel $unwind$list_contains
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_contains DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT list_contains
_TEXT	SEGMENT
a$ = 48
el$ = 56
list_contains PROC					; COMDAT

; 428  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 429  :     Py_ssize_t i;
; 430  :     int cmp;
; 431  : 
; 432  :     for (i = 0, cmp = 0 ; cmp == 0 && i < Py_SIZE(a); ++i)

  0000f	33 db		 xor	 ebx, ebx
  00011	48 8b f2	 mov	 rsi, rdx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	8b c3		 mov	 eax, ebx
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL3@list_conta:
  00020	48 3b 5f 60	 cmp	 rbx, QWORD PTR [rdi+96]
  00024	7d 1d		 jge	 SHORT $LN8@list_conta

; 433  :         cmp = PyObject_RichCompareBool(el, PyList_GET_ITEM(a, i),
; 434  :                                            Py_EQ);

  00026	48 8b 57 70	 mov	 rdx, QWORD PTR [rdi+112]
  0002a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00030	48 8b ce	 mov	 rcx, rsi
  00033	48 8b 14 da	 mov	 rdx, QWORD PTR [rdx+rbx*8]
  00037	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0003c	48 ff c3	 inc	 rbx
  0003f	85 c0		 test	 eax, eax
  00041	74 dd		 je	 SHORT $LL3@list_conta
$LN8@list_conta:

; 435  :     return cmp;
; 436  : }

  00043	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00048	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
list_contains ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$list_item DD imagerel list_item
	DD	imagerel list_item+31
	DD	imagerel $unwind$list_item
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$list_item DD imagerel list_item+31
	DD	imagerel list_item+123
	DD	imagerel $chain$0$list_item
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$list_item DD imagerel list_item+123
	DD	imagerel list_item+187
	DD	imagerel $chain$1$list_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$list_item DD 021H
	DD	imagerel list_item
	DD	imagerel list_item+31
	DD	imagerel $unwind$list_item
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$list_item DD 020521H
	DD	087405H
	DD	imagerel list_item
	DD	imagerel list_item+31
	DD	imagerel $unwind$list_item
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_item DD 040a01H
	DD	09340aH
	DD	06006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT list_item
_TEXT	SEGMENT
a$ = 64
i$ = 72
list_item PROC						; COMDAT

; 440  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f1	 mov	 rsi, rcx

; 441  :     if (i < 0 || i >= Py_SIZE(a)) {

  00010	48 85 d2	 test	 rdx, rdx
  00013	78 66		 js	 SHORT $LN3@list_item
  00015	48 3b 51 60	 cmp	 rdx, QWORD PTR [rcx+96]
  00019	7d 60		 jge	 SHORT $LN3@list_item

; 450  :     }
; 451  :     Py_INCREF(a->ob_item[i]);

  0001b	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  0001f	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00024	48 8b 3c d0	 mov	 rdi, QWORD PTR [rax+rdx*8]
  00028	e8 00 00 00 00	 call	 _Py_PXCTX
  0002d	85 c0		 test	 eax, eax
  0002f	75 32		 jne	 SHORT $LN8@list_item
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0003f	4c 8b cf	 mov	 r9, rdi
  00042	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00048	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00050	e8 00 00 00 00	 call	 _PyParallel_Guard
  00055	85 c0		 test	 eax, eax
  00057	75 06		 jne	 SHORT $LN7@list_item
  00059	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0005d	74 04		 je	 SHORT $LN8@list_item
$LN7@list_item:
  0005f	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN8@list_item:

; 452  :     return a->ob_item[i];

  00063	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  00067	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  0006c	48 8b 04 d8	 mov	 rax, QWORD PTR [rax+rbx*8]

; 453  : }

  00070	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5e		 pop	 rsi
  0007a	c3		 ret	 0
$LN3@list_item:

; 442  :         if (indexerr == NULL) {

  0007b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR indexerr
  00082	48 85 c0	 test	 rax, rax
  00085	75 18		 jne	 SHORT $LN1@list_item

; 443  :             indexerr = PyUnicode_FromString(
; 444  :                 "list index out of range");

  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PPFNPBPL@list?5index?5out?5of?5range?$AA@
  0008e	e8 00 00 00 00	 call	 PyUnicode_FromString
  00093	48 89 05 00 00
	00 00		 mov	 QWORD PTR indexerr, rax

; 445  :             if (indexerr == NULL)

  0009a	48 85 c0	 test	 rax, rax

; 446  :                 return NULL;

  0009d	74 0f		 je	 SHORT $LN11@list_item
$LN1@list_item:

; 447  :         }
; 448  :         PyErr_SetObject(PyExc_IndexError, indexerr);

  0009f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  000a6	48 8b d0	 mov	 rdx, rax
  000a9	e8 00 00 00 00	 call	 PyErr_SetObject
$LN11@list_item:

; 449  :         return NULL;

  000ae	33 c0		 xor	 eax, eax

; 453  : }

  000b0	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000b5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b9	5e		 pop	 rsi
  000ba	c3		 ret	 0
list_item ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$list_slice DD imagerel list_slice
	DD	imagerel list_slice+99
	DD	imagerel $unwind$list_slice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$list_slice DD imagerel list_slice+99
	DD	imagerel list_slice+199
	DD	imagerel $chain$0$list_slice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$list_slice DD imagerel list_slice+199
	DD	imagerel list_slice+221
	DD	imagerel $chain$1$list_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$list_slice DD 021H
	DD	imagerel list_slice
	DD	imagerel list_slice+99
	DD	imagerel $unwind$list_slice
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$list_slice DD 020521H
	DD	085405H
	DD	imagerel list_slice
	DD	imagerel list_slice+99
	DD	imagerel $unwind$list_slice
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_slice DD 081501H
	DD	0b7415H
	DD	0a6415H
	DD	093415H
	DD	0c0115215H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT list_slice
_TEXT	SEGMENT
a$ = 64
ilow$ = 72
ihigh$ = 80
list_slice PROC						; COMDAT

; 457  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00015	49 8b d8	 mov	 rbx, r8
  00018	48 8b fa	 mov	 rdi, rdx
  0001b	48 8b f1	 mov	 rsi, rcx

; 458  :     PyListObject *np;
; 459  :     PyObject **src, **dest;
; 460  :     Py_ssize_t i, len;
; 461  :     if (ilow < 0)

  0001e	48 85 d2	 test	 rdx, rdx
  00021	79 04		 jns	 SHORT $LN10@list_slice

; 462  :         ilow = 0;

  00023	33 ff		 xor	 edi, edi
  00025	eb 0b		 jmp	 SHORT $LN8@list_slice
$LN10@list_slice:

; 463  :     else if (ilow > Py_SIZE(a))

  00027	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  0002b	48 3b d0	 cmp	 rdx, rax
  0002e	48 0f 4f f8	 cmovg	 rdi, rax
$LN8@list_slice:

; 464  :         ilow = Py_SIZE(a);
; 465  :     if (ihigh < ilow)

  00032	48 3b df	 cmp	 rbx, rdi
  00035	7d 05		 jge	 SHORT $LN7@list_slice

; 466  :         ihigh = ilow;

  00037	48 8b df	 mov	 rbx, rdi
  0003a	eb 0b		 jmp	 SHORT $LN5@list_slice
$LN7@list_slice:

; 467  :     else if (ihigh > Py_SIZE(a))

  0003c	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00040	48 3b d8	 cmp	 rbx, rax
  00043	48 0f 4f d8	 cmovg	 rbx, rax
$LN5@list_slice:

; 468  :         ihigh = Py_SIZE(a);
; 469  :     len = ihigh - ilow;

  00047	48 2b df	 sub	 rbx, rdi

; 470  :     np = (PyListObject *) PyList_New(len);

  0004a	48 8b cb	 mov	 rcx, rbx
  0004d	e8 00 00 00 00	 call	 PyList_New
  00052	4c 8b e0	 mov	 r12, rax

; 471  :     if (np == NULL)

  00055	48 85 c0	 test	 rax, rax
  00058	74 6d		 je	 SHORT $LN11@list_slice
$LN4@list_slice:

; 472  :         return NULL;
; 473  : 
; 474  :     src = a->ob_item + ilow;

  0005a	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]

; 475  :     dest = np->ob_item;

  0005e	49 8b 74 24 70	 mov	 rsi, QWORD PTR [r12+112]
  00063	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00068	48 8d 2c f8	 lea	 rbp, QWORD PTR [rax+rdi*8]

; 476  :     for (i = 0; i < len; i++) {

  0006c	48 85 db	 test	 rbx, rbx
  0006f	7e 4e		 jle	 SHORT $LN1@list_slice
  00071	48 2b ee	 sub	 rbp, rsi
$LL3@list_slice:

; 477  :         PyObject *v = src[i];

  00074	48 8b 3c 2e	 mov	 rdi, QWORD PTR [rsi+rbp]

; 478  :         Py_INCREF(v);

  00078	e8 00 00 00 00	 call	 _Py_PXCTX
  0007d	85 c0		 test	 eax, eax
  0007f	75 32		 jne	 SHORT $LN14@list_slice
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0008f	4c 8b cf	 mov	 r9, rdi
  00092	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00098	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a0	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a5	85 c0		 test	 eax, eax
  000a7	75 06		 jne	 SHORT $LN13@list_slice
  000a9	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  000ad	74 04		 je	 SHORT $LN14@list_slice
$LN13@list_slice:
  000af	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN14@list_slice:

; 479  :         dest[i] = v;

  000b3	48 89 3e	 mov	 QWORD PTR [rsi], rdi
  000b6	48 83 c6 08	 add	 rsi, 8
  000ba	48 ff cb	 dec	 rbx
  000bd	75 b5		 jne	 SHORT $LL3@list_slice
$LN1@list_slice:
  000bf	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 480  :     }
; 481  :     return (PyObject *)np;

  000c4	49 8b c4	 mov	 rax, r12
$LN11@list_slice:

; 482  : }

  000c7	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000cc	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000d1	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000d6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000da	41 5c		 pop	 r12
  000dc	c3		 ret	 0
list_slice ENDP
_TEXT	ENDS
PUBLIC	PyList_GetSlice
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_GetSlice DD imagerel $LN4
	DD	imagerel $LN4+53
	DD	imagerel $unwind$PyList_GetSlice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_GetSlice DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyList_GetSlice
_TEXT	SEGMENT
a$ = 48
ilow$ = 56
ihigh$ = 64
PyList_GetSlice PROC					; COMDAT

; 486  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 487  :     if (!PyList_Check(a)) {

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  00012	75 18		 jne	 SHORT $LN1@PyList_Get@2

; 488  :         PyErr_BadInternalCall();

  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0001b	ba e8 01 00 00	 mov	 edx, 488		; 000001e8H
  00020	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 489  :         return NULL;

  00025	33 c0		 xor	 eax, eax

; 490  :     }
; 491  :     return list_slice((PyListObject *)a, ilow, ihigh);
; 492  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
$LN1@PyList_Get@2:
  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	e9 00 00 00 00	 jmp	 list_slice
PyList_GetSlice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@BIAFAIAC@can?5only?5concatenate?5list?5?$CInot?5?$CC@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$list_concat DD imagerel list_concat
	DD	imagerel list_concat+88
	DD	imagerel $unwind$list_concat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$list_concat DD imagerel list_concat+88
	DD	imagerel list_concat+120
	DD	imagerel $chain$0$list_concat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$list_concat DD imagerel list_concat+120
	DD	imagerel list_concat+146
	DD	imagerel $chain$6$list_concat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$list_concat DD imagerel list_concat+146
	DD	imagerel list_concat+284
	DD	imagerel $chain$7$list_concat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$list_concat DD imagerel list_concat+284
	DD	imagerel list_concat+404
	DD	imagerel $chain$8$list_concat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$list_concat DD 021H
	DD	imagerel list_concat+120
	DD	imagerel list_concat+146
	DD	imagerel $chain$6$list_concat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$list_concat DD 020521H
	DD	07e405H
	DD	imagerel list_concat+120
	DD	imagerel list_concat+146
	DD	imagerel $chain$6$list_concat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$list_concat DD 0a1621H
	DD	087416H
	DD	0e640fH
	DD	0d540aH
	DD	0c3405H
	DD	06f400H
	DD	imagerel list_concat
	DD	imagerel list_concat+88
	DD	imagerel $unwind$list_concat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$list_concat DD 020521H
	DD	06f405H
	DD	imagerel list_concat
	DD	imagerel list_concat+88
	DD	imagerel $unwind$list_concat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_concat DD 030801H
	DD	0d0048208H
	DD	0c002H
xdata	ENDS
;	COMDAT ??_C@_0DB@BIAFAIAC@can?5only?5concatenate?5list?5?$CInot?5?$CC@
CONST	SEGMENT
??_C@_0DB@BIAFAIAC@can?5only?5concatenate?5list?5?$CInot?5?$CC@ DB 'can o'
	DB	'nly concatenate list (not "%.200s") to list', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
CONST	ENDS
;	COMDAT list_concat
_TEXT	SEGMENT
a$ = 96
bb$ = 104
list_concat PROC					; COMDAT

; 496  : {

  00000	41 54		 push	 r12
  00002	41 55		 push	 r13
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 497  :     Py_ssize_t size;
; 498  :     Py_ssize_t i;
; 499  :     PyObject **src, **dest;
; 500  :     PyListObject *np;
; 501  :     if (!PyList_Check(bb)) {

  00008	4c 8b 42 58	 mov	 r8, QWORD PTR [rdx+88]
  0000c	4c 8b ea	 mov	 r13, rdx
  0000f	4c 8b e1	 mov	 r12, rcx
  00012	41 f7 80 00 01
	00 00 00 00 00
	02		 test	 DWORD PTR [r8+256], 33554432 ; 02000000H
  0001d	75 22		 jne	 SHORT $LN9@list_conca

; 502  :         PyErr_Format(PyExc_TypeError,
; 503  :                   "can only concatenate list (not \"%.200s\") to list",
; 504  :                   bb->ob_type->tp_name);

  0001f	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00023	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@BIAFAIAC@can?5only?5concatenate?5list?5?$CInot?5?$CC@
  00031	e8 00 00 00 00	 call	 PyErr_Format

; 505  :         return NULL;

  00036	33 c0		 xor	 eax, eax

; 530  : #undef b
; 531  : }

  00038	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0003c	41 5d		 pop	 r13
  0003e	41 5c		 pop	 r12
  00040	c3		 ret	 0
$LN9@list_conca:

; 506  :     }
; 507  : #define b ((PyListObject *)bb)
; 508  :     size = Py_SIZE(a) + Py_SIZE(b);

  00041	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00045	48 03 4a 60	 add	 rcx, QWORD PTR [rdx+96]

; 509  :     if (size < 0)

  00049	79 0d		 jns	 SHORT $LN8@list_conca

; 530  : #undef b
; 531  : }

  0004b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004f	41 5d		 pop	 r13
  00051	41 5c		 pop	 r12
  00053	e9 00 00 00 00	 jmp	 PyErr_NoMemory
$LN8@list_conca:
  00058	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15

; 510  :         return PyErr_NoMemory();
; 511  :     np = (PyListObject *) PyList_New(size);

  0005d	e8 00 00 00 00	 call	 PyList_New
  00062	4c 8b f8	 mov	 r15, rax

; 512  :     if (np == NULL) {

  00065	48 85 c0	 test	 rax, rax
  00068	75 0e		 jne	 SHORT $LN7@list_conca
  0006a	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]

; 530  : #undef b
; 531  : }

  0006f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00073	41 5d		 pop	 r13
  00075	41 5c		 pop	 r12
  00077	c3		 ret	 0
$LN7@list_conca:
  00078	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  0007d	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp
  00082	48 89 74 24 70	 mov	 QWORD PTR [rsp+112], rsi

; 513  :         return NULL;
; 514  :     }
; 515  :     src = a->ob_item;
; 516  :     dest = np->ob_item;
; 517  :     for (i = 0; i < Py_SIZE(a); i++) {

  00087	33 f6		 xor	 esi, esi
  00089	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0008e	48 8b 78 70	 mov	 rdi, QWORD PTR [rax+112]
  00092	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  00097	4d 8b 74 24 70	 mov	 r14, QWORD PTR [r12+112]
  0009c	8b ee		 mov	 ebp, esi
  0009e	49 39 74 24 60	 cmp	 QWORD PTR [r12+96], rsi
  000a3	7e 5b		 jle	 SHORT $LN4@list_conca
  000a5	4c 2b f7	 sub	 r14, rdi
  000a8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL6@list_conca:

; 518  :         PyObject *v = src[i];

  000b0	49 8b 1c 3e	 mov	 rbx, QWORD PTR [r14+rdi]

; 519  :         Py_INCREF(v);

  000b4	e8 00 00 00 00	 call	 _Py_PXCTX
  000b9	85 c0		 test	 eax, eax
  000bb	75 32		 jne	 SHORT $LN13@list_conca
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000cb	4c 8b cb	 mov	 r9, rbx
  000ce	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000d4	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000dc	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e1	85 c0		 test	 eax, eax
  000e3	75 06		 jne	 SHORT $LN12@list_conca
  000e5	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000e9	74 04		 je	 SHORT $LN13@list_conca
$LN12@list_conca:
  000eb	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN13@list_conca:

; 520  :         dest[i] = v;

  000ef	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  000f2	48 ff c5	 inc	 rbp
  000f5	48 83 c7 08	 add	 rdi, 8
  000f9	49 3b 6c 24 60	 cmp	 rbp, QWORD PTR [r12+96]
  000fe	7c b0		 jl	 SHORT $LL6@list_conca
$LN4@list_conca:

; 521  :     }
; 522  :     src = b->ob_item;
; 523  :     dest = np->ob_item + Py_SIZE(a);

  00100	49 8b 4c 24 60	 mov	 rcx, QWORD PTR [r12+96]
  00105	49 8b 47 70	 mov	 rax, QWORD PTR [r15+112]
  00109	49 8b 6d 70	 mov	 rbp, QWORD PTR [r13+112]
  0010d	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]
  00112	48 8d 3c c8	 lea	 rdi, QWORD PTR [rax+rcx*8]

; 524  :     for (i = 0; i < Py_SIZE(b); i++) {

  00116	49 39 75 60	 cmp	 QWORD PTR [r13+96], rsi
  0011a	7e 53		 jle	 SHORT $LN1@list_conca
  0011c	48 2b ef	 sub	 rbp, rdi
  0011f	90		 npad	 1
$LL3@list_conca:

; 525  :         PyObject *v = src[i];

  00120	48 8b 1c 2f	 mov	 rbx, QWORD PTR [rdi+rbp]

; 526  :         Py_INCREF(v);

  00124	e8 00 00 00 00	 call	 _Py_PXCTX
  00129	85 c0		 test	 eax, eax
  0012b	75 32		 jne	 SHORT $LN17@list_conca
  0012d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0013b	4c 8b cb	 mov	 r9, rbx
  0013e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00144	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0014c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00151	85 c0		 test	 eax, eax
  00153	75 06		 jne	 SHORT $LN16@list_conca
  00155	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00159	74 04		 je	 SHORT $LN17@list_conca
$LN16@list_conca:
  0015b	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN17@list_conca:

; 527  :         dest[i] = v;

  0015f	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  00162	48 ff c6	 inc	 rsi
  00165	48 83 c7 08	 add	 rdi, 8
  00169	49 3b 75 60	 cmp	 rsi, QWORD PTR [r13+96]
  0016d	7c b1		 jl	 SHORT $LL3@list_conca
$LN1@list_conca:
  0016f	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00174	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  00179	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  0017e	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 528  :     }
; 529  :     return (PyObject *)np;

  00183	49 8b c7	 mov	 rax, r15
  00186	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]

; 530  : #undef b
; 531  : }

  0018b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0018f	41 5d		 pop	 r13
  00191	41 5c		 pop	 r12
  00193	c3		 ret	 0
list_concat ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$list_repeat DD imagerel list_repeat
	DD	imagerel list_repeat+91
	DD	imagerel $unwind$list_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$list_repeat DD imagerel list_repeat+91
	DD	imagerel list_repeat+124
	DD	imagerel $chain$0$list_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$list_repeat DD imagerel list_repeat+124
	DD	imagerel list_repeat+240
	DD	imagerel $chain$4$list_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$list_repeat DD imagerel list_repeat+240
	DD	imagerel list_repeat+254
	DD	imagerel $chain$5$list_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$list_repeat DD imagerel list_repeat+254
	DD	imagerel list_repeat+364
	DD	imagerel $chain$6$list_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$list_repeat DD imagerel list_repeat+364
	DD	imagerel list_repeat+369
	DD	imagerel $chain$7$list_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$list_repeat DD imagerel list_repeat+369
	DD	imagerel list_repeat+397
	DD	imagerel $chain$8$list_repeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$list_repeat DD 021H
	DD	imagerel list_repeat+124
	DD	imagerel list_repeat+240
	DD	imagerel $chain$4$list_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$list_repeat DD 021H
	DD	imagerel list_repeat+240
	DD	imagerel list_repeat+254
	DD	imagerel $chain$5$list_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$list_repeat DD 020521H
	DD	0e7405H
	DD	imagerel list_repeat+240
	DD	imagerel list_repeat+254
	DD	imagerel $chain$5$list_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$list_repeat DD 020521H
	DD	07e405H
	DD	imagerel list_repeat+124
	DD	imagerel list_repeat+240
	DD	imagerel $chain$4$list_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$list_repeat DD 060a21H
	DD	0d640aH
	DD	0c3405H
	DD	06f400H
	DD	imagerel list_repeat
	DD	imagerel list_repeat+91
	DD	imagerel $unwind$list_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$list_repeat DD 020521H
	DD	06f405H
	DD	imagerel list_repeat
	DD	imagerel list_repeat+91
	DD	imagerel $unwind$list_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_repeat DD 040a01H
	DD	0d006720aH
	DD	05002c004H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT list_repeat
_TEXT	SEGMENT
a$ = 96
n$ = 104
list_repeat PROC					; COMDAT

; 535  : {

  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 536  :     Py_ssize_t i, j;
; 537  :     Py_ssize_t size;
; 538  :     PyListObject *np;
; 539  :     PyObject **p, **items;
; 540  :     PyObject *elem;
; 541  :     if (n < 0)

  0000a	45 33 e4	 xor	 r12d, r12d
  0000d	4c 8b ea	 mov	 r13, rdx
  00010	48 8b e9	 mov	 rbp, rcx
  00013	48 85 d2	 test	 rdx, rdx
  00016	79 1e		 jns	 SHORT $LN34@list_repea

; 542  :         n = 0;

  00018	45 8b ec	 mov	 r13d, r12d
$LN13@list_repea:

; 544  :         return PyErr_NoMemory();
; 545  :     size = Py_SIZE(a) * n;

  0001b	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0001f	49 0f af cd	 imul	 rcx, r13

; 546  :     if (size == 0)

  00023	48 85 c9	 test	 rcx, rcx
  00026	75 33		 jne	 SHORT $LN12@list_repea

; 571  : }

  00028	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0002c	41 5d		 pop	 r13
  0002e	41 5c		 pop	 r12
  00030	5d		 pop	 rbp
  00031	e9 00 00 00 00	 jmp	 PyList_New
$LN34@list_repea:

; 543  :     if (n > 0 && Py_SIZE(a) > PY_SSIZE_T_MAX / n)

  00036	7e e3		 jle	 SHORT $LN13@list_repea
  00038	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00042	48 99		 cdq
  00044	49 f7 fd	 idiv	 r13
  00047	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  0004b	7e ce		 jle	 SHORT $LN13@list_repea

; 571  : }

  0004d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00051	41 5d		 pop	 r13
  00053	41 5c		 pop	 r12
  00055	5d		 pop	 rbp
  00056	e9 00 00 00 00	 jmp	 PyErr_NoMemory
$LN12@list_repea:
  0005b	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15

; 547  :         return PyList_New(0);
; 548  :     np = (PyListObject *) PyList_New(size);

  00060	e8 00 00 00 00	 call	 PyList_New
  00065	4c 8b f8	 mov	 r15, rax

; 549  :     if (np == NULL)

  00068	48 85 c0	 test	 rax, rax
  0006b	75 0f		 jne	 SHORT $LN11@list_repea
  0006d	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]

; 571  : }

  00072	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00076	41 5d		 pop	 r13
  00078	41 5c		 pop	 r12
  0007a	5d		 pop	 rbp
  0007b	c3		 ret	 0
$LN11@list_repea:
  0007c	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00081	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi

; 550  :         return NULL;
; 551  : 
; 552  :     items = np->ob_item;

  00086	48 8b 70 70	 mov	 rsi, QWORD PTR [rax+112]

; 553  :     if (Py_SIZE(a) == 1) {

  0008a	48 8b 45 60	 mov	 rax, QWORD PTR [rbp+96]
  0008e	48 83 f8 01	 cmp	 rax, 1
  00092	75 5c		 jne	 SHORT $LN10@list_repea

; 554  :         elem = a->ob_item[0];

  00094	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  00098	48 8b 18	 mov	 rbx, QWORD PTR [rax]

; 555  :         for (i = 0; i < n; i++) {

  0009b	4d 85 ed	 test	 r13, r13
  0009e	0f 8e cd 00 00
	00		 jle	 $LN7@list_repea
$LL9@list_repea:

; 556  :             items[i] = elem;

  000a4	4a 89 1c e6	 mov	 QWORD PTR [rsi+r12*8], rbx

; 557  :             Py_INCREF(elem);

  000a8	e8 00 00 00 00	 call	 _Py_PXCTX
  000ad	85 c0		 test	 eax, eax
  000af	75 32		 jne	 SHORT $LN8@list_repea
  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000bf	4c 8b cb	 mov	 r9, rbx
  000c2	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000c8	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000d0	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d5	85 c0		 test	 eax, eax
  000d7	75 06		 jne	 SHORT $LN17@list_repea
  000d9	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000dd	74 04		 je	 SHORT $LN8@list_repea
$LN17@list_repea:
  000df	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN8@list_repea:

; 555  :         for (i = 0; i < n; i++) {

  000e3	49 ff c4	 inc	 r12
  000e6	4d 3b e5	 cmp	 r12, r13
  000e9	7c b9		 jl	 SHORT $LL9@list_repea

; 558  :         }
; 559  :         return (PyObject *) np;

  000eb	e9 81 00 00 00	 jmp	 $LN7@list_repea
$LN10@list_repea:
  000f0	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14

; 560  :     }
; 561  :     p = np->ob_item;
; 562  :     items = a->ob_item;

  000f5	4c 8b 75 70	 mov	 r14, QWORD PTR [rbp+112]

; 563  :     for (i = 0; i < n; i++) {

  000f9	4d 85 ed	 test	 r13, r13
  000fc	7e 6e		 jle	 SHORT $LN4@list_repea
  000fe	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi
$LL6@list_repea:

; 564  :         for (j = 0; j < Py_SIZE(a); j++) {

  00103	49 8b fc	 mov	 rdi, r12
  00106	48 85 c0	 test	 rax, rax
  00109	7e 57		 jle	 SHORT $LN5@list_repea
  0010b	0f 1f 44 00 00	 npad	 5
$LL3@list_repea:

; 565  :             *p = items[j];

  00110	49 8b 1c fe	 mov	 rbx, QWORD PTR [r14+rdi*8]
  00114	48 89 1e	 mov	 QWORD PTR [rsi], rbx

; 566  :             Py_INCREF(*p);

  00117	e8 00 00 00 00	 call	 _Py_PXCTX
  0011c	85 c0		 test	 eax, eax
  0011e	75 32		 jne	 SHORT $LN22@list_repea
  00120	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0012e	4c 8b cb	 mov	 r9, rbx
  00131	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00137	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0013f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00144	85 c0		 test	 eax, eax
  00146	75 06		 jne	 SHORT $LN21@list_repea
  00148	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0014c	74 04		 je	 SHORT $LN22@list_repea
$LN21@list_repea:
  0014e	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN22@list_repea:

; 564  :         for (j = 0; j < Py_SIZE(a); j++) {

  00152	48 8b 45 60	 mov	 rax, QWORD PTR [rbp+96]
  00156	48 ff c7	 inc	 rdi

; 567  :             p++;

  00159	48 83 c6 08	 add	 rsi, 8
  0015d	48 3b f8	 cmp	 rdi, rax
  00160	7c ae		 jl	 SHORT $LL3@list_repea
$LN5@list_repea:

; 563  :     for (i = 0; i < n; i++) {

  00162	49 ff cd	 dec	 r13
  00165	75 9c		 jne	 SHORT $LL6@list_repea
  00167	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
$LN4@list_repea:
  0016c	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]
$LN7@list_repea:
  00171	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00176	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 568  :         }
; 569  :     }
; 570  :     return (PyObject *) np;

  0017b	49 8b c7	 mov	 rax, r15
  0017e	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]

; 571  : }

  00183	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00187	41 5d		 pop	 r13
  00189	41 5c		 pop	 r12
  0018b	5d		 pop	 rbp
  0018c	c3		 ret	 0
list_repeat ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$list_clear DD imagerel list_clear
	DD	imagerel list_clear+21
	DD	imagerel $unwind$list_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$list_clear DD imagerel list_clear+21
	DD	imagerel list_clear+47
	DD	imagerel $chain$0$list_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$list_clear DD imagerel list_clear+47
	DD	imagerel list_clear+172
	DD	imagerel $chain$1$list_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$list_clear DD imagerel list_clear+172
	DD	imagerel list_clear+189
	DD	imagerel $chain$2$list_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$list_clear DD imagerel list_clear+189
	DD	imagerel list_clear+216
	DD	imagerel $chain$3$list_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$list_clear DD 021H
	DD	imagerel list_clear
	DD	imagerel list_clear+21
	DD	imagerel $unwind$list_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$list_clear DD 021H
	DD	imagerel list_clear+21
	DD	imagerel list_clear+47
	DD	imagerel $chain$0$list_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$list_clear DD 020521H
	DD	083405H
	DD	imagerel list_clear+21
	DD	imagerel list_clear+47
	DD	imagerel $chain$0$list_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$list_clear DD 020521H
	DD	097405H
	DD	imagerel list_clear
	DD	imagerel list_clear+21
	DD	imagerel $unwind$list_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_clear DD 020601H
	DD	060025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT list_clear
_TEXT	SEGMENT
a$ = 64
list_clear PROC						; COMDAT

; 575  : {

  00000	40 56		 push	 rsi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 576  :     Py_ssize_t i;
; 577  :     PyObject **item = a->ob_item;

  00006	48 8b 71 70	 mov	 rsi, QWORD PTR [rcx+112]

; 578  :     if (item != NULL) {

  0000a	48 85 f6	 test	 rsi, rsi
  0000d	0f 84 bd 00 00
	00		 je	 $LN24@list_clear

; 579  :         /* Because XDECREF can recursively invoke operations on
; 580  :            this list, we make it empty first. */
; 581  :         i = Py_SIZE(a);
; 582  :         Py_SIZE(a) = 0;

  00013	33 c0		 xor	 eax, eax
  00015	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0001a	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]

; 583  :         a->ob_item = NULL;
; 584  :         a->allocated = 0;
; 585  :         while (--i >= 0) {

  0001e	48 ff cf	 dec	 rdi
  00021	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
  00025	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax
  00029	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax
  0002d	78 7d		 js	 SHORT $LN5@list_clear
  0002f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
$LL6@list_clear:
  00034	48 8b 1c fe	 mov	 rbx, QWORD PTR [rsi+rdi*8]

; 586  :             Py_XDECREF(item[i]);

  00038	48 85 db	 test	 rbx, rbx
  0003b	74 65		 je	 SHORT $LN3@list_clear
  0003d	e8 00 00 00 00	 call	 _Py_PXCTX
  00042	85 c0		 test	 eax, eax
  00044	75 5c		 jne	 SHORT $LN3@list_clear
  00046	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0004a	a8 20		 test	 al, 32			; 00000020H
  0004c	75 4c		 jne	 SHORT $LN16@list_clear
  0004e	84 c0		 test	 al, al
  00050	78 48		 js	 SHORT $LN16@list_clear
  00052	a8 02		 test	 al, 2
  00054	75 4c		 jne	 SHORT $LN3@list_clear
  00056	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0005a	75 46		 jne	 SHORT $LN3@list_clear
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0006a	4c 8b cb	 mov	 r9, rbx
  0006d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00073	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0007b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00080	48 8b cb	 mov	 rcx, rbx
  00083	85 c0		 test	 eax, eax
  00085	74 07		 je	 SHORT $LN21@list_clear
  00087	e8 00 00 00 00	 call	 _Px_Dealloc
  0008c	eb 14		 jmp	 SHORT $LN3@list_clear
$LN21@list_clear:
  0008e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00092	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00098	eb 08		 jmp	 SHORT $LN3@list_clear
$LN16@list_clear:
  0009a	48 8b cb	 mov	 rcx, rbx
  0009d	e8 00 00 00 00	 call	 Px_DecRef
$LN3@list_clear:

; 583  :         a->ob_item = NULL;
; 584  :         a->allocated = 0;
; 585  :         while (--i >= 0) {

  000a2	48 ff cf	 dec	 rdi
  000a5	79 8d		 jns	 SHORT $LL6@list_clear
  000a7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN5@list_clear:

; 587  :         }
; 588  :         PyMem_FREE(item);

  000ac	e8 00 00 00 00	 call	 _Py_PXCTX
  000b1	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000b6	48 8b ce	 mov	 rcx, rsi
  000b9	85 c0		 test	 eax, eax
  000bb	74 0d		 je	 SHORT $LN10@list_clear
  000bd	e8 00 00 00 00	 call	 _PxMem_Free

; 589  :     }
; 590  :     /* Never fails; the return value can be ignored.
; 591  :        Note that there is no guarantee that the list is actually empty
; 592  :        at this point, because XDECREF may have populated it again! */
; 593  :     return 0;

  000c2	33 c0		 xor	 eax, eax

; 594  : }

  000c4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c8	5e		 pop	 rsi
  000c9	c3		 ret	 0
$LN10@list_clear:

; 587  :         }
; 588  :         PyMem_FREE(item);

  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN24@list_clear:

; 589  :     }
; 590  :     /* Never fails; the return value can be ignored.
; 591  :        Note that there is no guarantee that the list is actually empty
; 592  :        at this point, because XDECREF may have populated it again! */
; 593  :     return 0;

  000d0	33 c0		 xor	 eax, eax

; 594  : }

  000d2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d6	5e		 pop	 rsi
  000d7	c3		 ret	 0
list_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@INPHMALO@can?5only?5assign?5an?5iterable?$AA@ ; `string'
PUBLIC	??_C@_0EF@DGJDNGLM@parallel?5thread?5attempted?5to?5ass@ ; `string'
EXTRN	__imp_memmove:PROC
EXTRN	PySequence_Fast:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$list_ass_slice DD imagerel list_ass_slice
	DD	imagerel list_ass_slice+1107
	DD	imagerel $unwind$list_ass_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_ass_slice DD 091b01H
	DD	01c641bH
	DD	01b541bH
	DD	01a341bH
	DD	018011bH
	DD	07014H
xdata	ENDS
;	COMDAT ??_C@_0BM@INPHMALO@can?5only?5assign?5an?5iterable?$AA@
CONST	SEGMENT
??_C@_0BM@INPHMALO@can?5only?5assign?5an?5iterable?$AA@ DB 'can only assi'
	DB	'gn an iterable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@DGJDNGLM@parallel?5thread?5attempted?5to?5ass@
CONST	SEGMENT
??_C@_0EF@DGJDNGLM@parallel?5thread?5attempted?5to?5ass@ DB 'parallel thr'
	DB	'ead attempted to assign to a slice of a main thread list', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
CONST	ENDS
;	COMDAT list_ass_slice
_TEXT	SEGMENT
recycle$1$ = 48
vitem$1$ = 56
item$1$ = 64
k$1$ = 72
s$1$ = 72
result$2$ = 80
n$1$ = 88
d$1$ = 96
v_as_SF$1$ = 104
norig$1$ = 112
recycle_on_stack$ = 128
a$ = 208
ilow$ = 216
ihigh$ = 224
v$ = 232
list_ass_slice PROC					; COMDAT

; 604  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  00013	57		 push	 rdi
  00014	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H

; 605  :     /* Because [X]DECREF can recursively invoke list operations on
; 606  :        this list, we must postpone all [X]DECREF activity until
; 607  :        after the list is back in its canonical shape.  Therefore
; 608  :        we must allocate an additional array, 'recycle', into which
; 609  :        we temporarily copy the items that are deleted from the
; 610  :        list. :-( */
; 611  :     PyObject *recycle_on_stack[8];
; 612  :     PyObject **recycle = recycle_on_stack; /* will allocate more if needed */

  0001b	48 8d 40 b8	 lea	 rax, QWORD PTR [rax-72]

; 613  :     PyObject **item;
; 614  :     PyObject **vitem = NULL;
; 615  :     PyObject *v_as_SF = NULL; /* PySequence_Fast(v) */

  0001f	33 f6		 xor	 esi, esi
  00021	49 8b e8	 mov	 rbp, r8
  00024	48 8b da	 mov	 rbx, rdx
  00027	48 8b f9	 mov	 rdi, rcx
  0002a	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR vitem$1$[rsp], 0
  00033	48 89 44 24 30	 mov	 QWORD PTR recycle$1$[rsp], rax
  00038	48 89 74 24 68	 mov	 QWORD PTR v_as_SF$1$[rsp], rsi

; 616  :     Py_ssize_t n; /* # of elements in replacement list */
; 617  :     Py_ssize_t norig; /* # of elements in list getting replaced */
; 618  :     Py_ssize_t d; /* Change in size */
; 619  :     Py_ssize_t k;
; 620  :     size_t s;
; 621  :     int result = -1;            /* guilty until proved innocent */

  0003d	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR result$2$[rsp], -1

; 622  : #ifdef WITH_PARALLEL
; 623  :     if (Py_PXCTX && Px_ISPY(a)) {

  00045	e8 00 00 00 00	 call	 _Py_PXCTX
  0004a	85 c0		 test	 eax, eax
  0004c	74 21		 je	 SHORT $LN42@list_ass_s
  0004e	f6 47 20 01	 test	 BYTE PTR [rdi+32], 1
  00052	74 1b		 je	 SHORT $LN42@list_ass_s

; 624  :         PyErr_SetString(PyExc_AssignmentError,
; 625  :                         "parallel thread attempted to assign to a slice "
; 626  :                         "of a main thread list");

  00054	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AssignmentError
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EF@DGJDNGLM@parallel?5thread?5attempted?5to?5ass@
  00062	e8 00 00 00 00	 call	 PyErr_SetString
$LN96@list_ass_s:

; 627  :         return result;

  00067	83 c8 ff	 or	 eax, -1
  0006a	e9 cb 03 00 00	 jmp	 $LN43@list_ass_s
$LN42@list_ass_s:

; 628  :     }
; 629  : #endif
; 630  : #define b ((PyListObject *)v)
; 631  :     if (v == NULL)

  0006f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  00077	48 85 c0	 test	 rax, rax
  0007a	75 0c		 jne	 SHORT $LN41@list_ass_s

; 632  :         n = 0;

  0007c	33 d2		 xor	 edx, edx
  0007e	48 89 54 24 58	 mov	 QWORD PTR n$1$[rsp], rdx

; 633  :     else {

  00083	e9 86 00 00 00	 jmp	 $LN48@list_ass_s
$LN41@list_ass_s:

; 634  :         if (a == b) {
; 635  :             /* Special case "a[i:j] = a" -- copy b first */
; 636  :             v = list_slice(b, 0, Py_SIZE(b));

  00088	48 8b c8	 mov	 rcx, rax
  0008b	48 3b f8	 cmp	 rdi, rax
  0008e	75 35		 jne	 SHORT $LN39@list_ass_s
  00090	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00094	33 d2		 xor	 edx, edx
  00096	e8 00 00 00 00	 call	 list_slice
  0009b	48 8b f0	 mov	 rsi, rax

; 637  :             if (v == NULL)

  0009e	48 85 c0	 test	 rax, rax

; 638  :                 return result;

  000a1	74 c4		 je	 SHORT $LN96@list_ass_s

; 639  :             result = list_ass_slice(a, ilow, ihigh, v);

  000a3	4c 8b c8	 mov	 r9, rax
  000a6	4c 8b c5	 mov	 r8, rbp
  000a9	48 8b d3	 mov	 rdx, rbx
  000ac	48 8b cf	 mov	 rcx, rdi
  000af	e8 00 00 00 00	 call	 list_ass_slice

; 640  :             Py_DECREF(v);

  000b4	48 8b ce	 mov	 rcx, rsi
  000b7	8b d8		 mov	 ebx, eax
  000b9	e8 00 00 00 00	 call	 _Py_DecRef

; 641  :             return result;

  000be	8b c3		 mov	 eax, ebx
  000c0	e9 75 03 00 00	 jmp	 $LN43@list_ass_s
$LN39@list_ass_s:

; 642  :         }
; 643  :         v_as_SF = PySequence_Fast(v, "can only assign an iterable");

  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@INPHMALO@can?5only?5assign?5an?5iterable?$AA@
  000cc	e8 00 00 00 00	 call	 PySequence_Fast
  000d1	48 8b f0	 mov	 rsi, rax
  000d4	48 89 44 24 68	 mov	 QWORD PTR v_as_SF$1$[rsp], rax

; 644  :         if(v_as_SF == NULL)

  000d9	48 85 c0	 test	 rax, rax
  000dc	0f 84 54 03 00
	00		 je	 $LN3@list_ass_s

; 645  :             goto Error;
; 646  :         n = PySequence_Fast_GET_SIZE(v_as_SF);

  000e2	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000e6	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]
  000ea	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  000f0	48 89 54 24 58	 mov	 QWORD PTR n$1$[rsp], rdx
  000f5	81 e1 00 00 00
	02		 and	 ecx, 33554432		; 02000000H

; 647  :         vitem = PySequence_Fast_ITEMS(v_as_SF);

  000fb	85 c9		 test	 ecx, ecx
  000fd	74 06		 je	 SHORT $LN47@list_ass_s
  000ff	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  00103	eb 04		 jmp	 SHORT $LN93@list_ass_s
$LN47@list_ass_s:
  00105	48 8d 46 70	 lea	 rax, QWORD PTR [rsi+112]
$LN93@list_ass_s:
  00109	48 89 44 24 38	 mov	 QWORD PTR vitem$1$[rsp], rax
$LN48@list_ass_s:

; 648  :     }
; 649  :     if (ilow < 0)

  0010e	48 85 db	 test	 rbx, rbx
  00111	79 04		 jns	 SHORT $LN36@list_ass_s

; 650  :         ilow = 0;

  00113	33 db		 xor	 ebx, ebx
  00115	eb 0b		 jmp	 SHORT $LN34@list_ass_s
$LN36@list_ass_s:

; 651  :     else if (ilow > Py_SIZE(a))

  00117	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  0011b	48 3b d8	 cmp	 rbx, rax
  0011e	48 0f 4f d8	 cmovg	 rbx, rax
$LN34@list_ass_s:

; 652  :         ilow = Py_SIZE(a);
; 653  : 
; 654  :     if (ihigh < ilow)

  00122	48 3b eb	 cmp	 rbp, rbx
  00125	7d 05		 jge	 SHORT $LN33@list_ass_s

; 655  :         ihigh = ilow;

  00127	48 8b eb	 mov	 rbp, rbx
  0012a	eb 0b		 jmp	 SHORT $LN31@list_ass_s
$LN33@list_ass_s:

; 656  :     else if (ihigh > Py_SIZE(a))

  0012c	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00130	48 3b e8	 cmp	 rbp, rax
  00133	48 0f 4f e8	 cmovg	 rbp, rax
$LN31@list_ass_s:

; 657  :         ihigh = Py_SIZE(a);
; 658  : 
; 659  :     norig = ihigh - ilow;

  00137	4c 8b c5	 mov	 r8, rbp

; 660  :     assert(norig >= 0);
; 661  :     d = n - norig;

  0013a	48 8b ca	 mov	 rcx, rdx
  0013d	4c 2b c3	 sub	 r8, rbx
  00140	49 2b c8	 sub	 rcx, r8
  00143	4c 89 44 24 70	 mov	 QWORD PTR norig$1$[rsp], r8
  00148	48 89 4c 24 60	 mov	 QWORD PTR d$1$[rsp], rcx

; 662  :     if (Py_SIZE(a) + d == 0) {

  0014d	48 03 4f 60	 add	 rcx, QWORD PTR [rdi+96]
  00151	75 1a		 jne	 SHORT $LN30@list_ass_s

; 663  :         Py_XDECREF(v_as_SF);

  00153	48 85 f6	 test	 rsi, rsi
  00156	74 08		 je	 SHORT $LN28@list_ass_s
  00158	48 8b ce	 mov	 rcx, rsi
  0015b	e8 00 00 00 00	 call	 _Py_DecRef
$LN28@list_ass_s:

; 664  :         return list_clear(a);

  00160	48 8b cf	 mov	 rcx, rdi
  00163	e8 00 00 00 00	 call	 list_clear
  00168	e9 cd 02 00 00	 jmp	 $LN43@list_ass_s
$LN30@list_ass_s:

; 665  :     }
; 666  :     item = a->ob_item;

  0016d	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  00171	48 89 44 24 40	 mov	 QWORD PTR item$1$[rsp], rax

; 667  :     /* recycle the items that we are about to remove */
; 668  :     s = norig * sizeof(PyObject *);

  00176	4a 8d 04 c5 00
	00 00 00	 lea	 rax, QWORD PTR [r8*8]
  0017e	48 89 44 24 48	 mov	 QWORD PTR s$1$[rsp], rax

; 669  :     if (s > sizeof(recycle_on_stack)) {

  00183	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00187	76 67		 jbe	 SHORT $LN24@list_ass_s

; 670  :         recycle = (PyObject **)PyMem_MALLOC(s);

  00189	e8 00 00 00 00	 call	 _Py_PXCTX
  0018e	85 c0		 test	 eax, eax
  00190	74 0c		 je	 SHORT $LN51@list_ass_s
  00192	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$1$[rsp]
  00197	e8 00 00 00 00	 call	 _PxMem_Malloc
  0019c	eb 39		 jmp	 SHORT $LN94@list_ass_s
$LN51@list_ass_s:
  0019e	48 8b 44 24 48	 mov	 rax, QWORD PTR s$1$[rsp]
  001a3	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  001ad	48 3b c1	 cmp	 rax, rcx
  001b0	76 13		 jbe	 SHORT $LN49@list_ass_s
  001b2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR recycle$1$[rsp], 0

; 672  :             PyErr_NoMemory();

  001bb	e8 00 00 00 00	 call	 PyErr_NoMemory

; 673  :             goto Error;

  001c0	e9 dc 01 00 00	 jmp	 $Error$20764
$LN49@list_ass_s:

; 670  :         recycle = (PyObject **)PyMem_MALLOC(s);

  001c5	48 85 c0	 test	 rax, rax
  001c8	b9 01 00 00 00	 mov	 ecx, 1
  001cd	48 0f 45 c8	 cmovne	 rcx, rax
  001d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN94@list_ass_s:
  001d7	48 89 44 24 30	 mov	 QWORD PTR recycle$1$[rsp], rax

; 671  :         if (recycle == NULL) {

  001dc	48 85 c0	 test	 rax, rax
  001df	75 0a		 jne	 SHORT $LN86@list_ass_s

; 672  :             PyErr_NoMemory();

  001e1	e8 00 00 00 00	 call	 PyErr_NoMemory

; 673  :             goto Error;

  001e6	e9 b6 01 00 00	 jmp	 $Error$20764
$LN86@list_ass_s:

; 667  :     /* recycle the items that we are about to remove */
; 668  :     s = norig * sizeof(PyObject *);

  001eb	48 8b 44 24 48	 mov	 rax, QWORD PTR s$1$[rsp]
$LN24@list_ass_s:

; 674  :         }
; 675  :     }
; 676  :     memcpy(recycle, &item[ilow], s);

  001f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$1$[rsp]
  001f5	4c 8b c0	 mov	 r8, rax
  001f8	48 8d 14 d9	 lea	 rdx, QWORD PTR [rcx+rbx*8]
  001fc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR recycle$1$[rsp]
  00201	e8 00 00 00 00	 call	 memcpy

; 677  : 
; 678  :     if (d < 0) { /* Delete -d items */

  00206	48 8b 44 24 60	 mov	 rax, QWORD PTR d$1$[rsp]
  0020b	48 85 c0	 test	 rax, rax
  0020e	79 38		 jns	 SHORT $LN95@list_ass_s

; 679  :         memmove(&item[ihigh+d], &item[ihigh],
; 680  :             (Py_SIZE(a) - ihigh)*sizeof(PyObject *));

  00210	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$1$[rsp]
  00215	4c 8b 47 60	 mov	 r8, QWORD PTR [rdi+96]
  00219	48 03 c5	 add	 rax, rbp
  0021c	48 8d 14 e9	 lea	 rdx, QWORD PTR [rcx+rbp*8]
  00220	4c 2b c5	 sub	 r8, rbp
  00223	48 8d 0c c1	 lea	 rcx, QWORD PTR [rcx+rax*8]
  00227	49 c1 e0 03	 shl	 r8, 3
  0022b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 681  :         list_resize(a, Py_SIZE(a) + d);

  00231	48 8b 54 24 60	 mov	 rdx, QWORD PTR d$1$[rsp]
  00236	48 8b cf	 mov	 rcx, rdi
  00239	48 03 57 60	 add	 rdx, QWORD PTR [rdi+96]
  0023d	e8 00 00 00 00	 call	 list_resize

; 682  :         item = a->ob_item;

  00242	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  00246	eb 4f		 jmp	 SHORT $LN21@list_ass_s
$LN95@list_ass_s:

; 683  :     }
; 684  :     else if (d > 0) { /* Insert d items */

  00248	7e 48		 jle	 SHORT $LN90@list_ass_s

; 685  :         k = Py_SIZE(a);

  0024a	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  0024e	48 89 4c 24 48	 mov	 QWORD PTR k$1$[rsp], rcx

; 686  :         if (list_resize(a, k+d) < 0)

  00253	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  00257	48 8b cf	 mov	 rcx, rdi
  0025a	e8 00 00 00 00	 call	 list_resize
  0025f	85 c0		 test	 eax, eax
  00261	0f 88 3a 01 00
	00		 js	 $Error$20764

; 687  :             goto Error;
; 688  :         item = a->ob_item;

  00267	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]

; 689  :         memmove(&item[ihigh+d], &item[ihigh],
; 690  :             (k - ihigh)*sizeof(PyObject *));

  0026b	48 8b 44 24 60	 mov	 rax, QWORD PTR d$1$[rsp]
  00270	4c 8b 44 24 48	 mov	 r8, QWORD PTR k$1$[rsp]
  00275	48 03 c5	 add	 rax, rbp
  00278	48 89 4c 24 40	 mov	 QWORD PTR item$1$[rsp], rcx
  0027d	4c 2b c5	 sub	 r8, rbp
  00280	48 8d 14 e9	 lea	 rdx, QWORD PTR [rcx+rbp*8]
  00284	48 8d 0c c1	 lea	 rcx, QWORD PTR [rcx+rax*8]
  00288	49 c1 e0 03	 shl	 r8, 3
  0028c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN90@list_ass_s:

; 665  :     }
; 666  :     item = a->ob_item;

  00292	48 8b 44 24 40	 mov	 rax, QWORD PTR item$1$[rsp]
$LN21@list_ass_s:

; 691  :     }
; 692  :     for (k = 0; k < n; k++, ilow++) {

  00297	33 ff		 xor	 edi, edi
  00299	48 39 7c 24 58	 cmp	 QWORD PTR n$1$[rsp], rdi
  0029e	7e 6e		 jle	 SHORT $LN17@list_ass_s
  002a0	48 8b 74 24 58	 mov	 rsi, QWORD PTR n$1$[rsp]
  002a5	48 8d 2c d8	 lea	 rbp, QWORD PTR [rax+rbx*8]
  002a9	48 8b 44 24 38	 mov	 rax, QWORD PTR vitem$1$[rsp]
  002ae	66 90		 npad	 2
$LL19@list_ass_s:

; 693  :         PyObject *w = vitem[k];

  002b0	48 8b 1c f8	 mov	 rbx, QWORD PTR [rax+rdi*8]

; 694  :         Py_XINCREF(w);

  002b4	48 85 db	 test	 rbx, rbx
  002b7	74 40		 je	 SHORT $LN15@list_ass_s
  002b9	e8 00 00 00 00	 call	 _Py_PXCTX
  002be	85 c0		 test	 eax, eax
  002c0	75 32		 jne	 SHORT $LN92@list_ass_s
  002c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  002d0	4c 8b cb	 mov	 r9, rbx
  002d3	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  002d9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  002e1	e8 00 00 00 00	 call	 _PyParallel_Guard
  002e6	85 c0		 test	 eax, eax
  002e8	75 06		 jne	 SHORT $LN55@list_ass_s
  002ea	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  002ee	74 04		 je	 SHORT $LN92@list_ass_s
$LN55@list_ass_s:
  002f0	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN92@list_ass_s:

; 687  :             goto Error;
; 688  :         item = a->ob_item;

  002f4	48 8b 44 24 38	 mov	 rax, QWORD PTR vitem$1$[rsp]
$LN15@list_ass_s:

; 691  :     }
; 692  :     for (k = 0; k < n; k++, ilow++) {

  002f9	48 ff c7	 inc	 rdi

; 695  :         item[ilow] = w;

  002fc	48 89 5d 00	 mov	 QWORD PTR [rbp], rbx
  00300	48 83 c5 08	 add	 rbp, 8
  00304	48 3b fe	 cmp	 rdi, rsi
  00307	7c a7		 jl	 SHORT $LL19@list_ass_s
  00309	48 8b 74 24 68	 mov	 rsi, QWORD PTR v_as_SF$1$[rsp]
$LN17@list_ass_s:

; 696  :     }
; 697  :     for (k = norig - 1; k >= 0; --k)

  0030e	48 8b 7c 24 70	 mov	 rdi, QWORD PTR norig$1$[rsp]
  00313	48 ff cf	 dec	 rdi
  00316	0f 88 7d 00 00
	00		 js	 $LN10@list_ass_s
  0031c	48 8b 44 24 30	 mov	 rax, QWORD PTR recycle$1$[rsp]
$LL12@list_ass_s:
  00321	48 8b 1c f8	 mov	 rbx, QWORD PTR [rax+rdi*8]

; 698  :         Py_XDECREF(recycle[k]);

  00325	48 85 db	 test	 rbx, rbx
  00328	74 6a		 je	 SHORT $LN8@list_ass_s
  0032a	e8 00 00 00 00	 call	 _Py_PXCTX
  0032f	85 c0		 test	 eax, eax
  00331	75 5c		 jne	 SHORT $LN89@list_ass_s
  00333	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00337	a8 20		 test	 al, 32			; 00000020H
  00339	75 4c		 jne	 SHORT $LN63@list_ass_s
  0033b	84 c0		 test	 al, al
  0033d	78 48		 js	 SHORT $LN63@list_ass_s
  0033f	a8 02		 test	 al, 2
  00341	75 4c		 jne	 SHORT $LN89@list_ass_s
  00343	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00347	75 46		 jne	 SHORT $LN89@list_ass_s
  00349	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00350	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00357	4c 8b cb	 mov	 r9, rbx
  0035a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00360	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00368	e8 00 00 00 00	 call	 _PyParallel_Guard
  0036d	48 8b cb	 mov	 rcx, rbx
  00370	85 c0		 test	 eax, eax
  00372	74 07		 je	 SHORT $LN68@list_ass_s
  00374	e8 00 00 00 00	 call	 _Px_Dealloc
  00379	eb 14		 jmp	 SHORT $LN89@list_ass_s
$LN68@list_ass_s:
  0037b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0037f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00385	eb 08		 jmp	 SHORT $LN89@list_ass_s
$LN63@list_ass_s:
  00387	48 8b cb	 mov	 rcx, rbx
  0038a	e8 00 00 00 00	 call	 Px_DecRef
$LN89@list_ass_s:
  0038f	48 8b 44 24 30	 mov	 rax, QWORD PTR recycle$1$[rsp]
$LN8@list_ass_s:

; 696  :     }
; 697  :     for (k = norig - 1; k >= 0; --k)

  00394	48 ff cf	 dec	 rdi
  00397	79 88		 jns	 SHORT $LL12@list_ass_s
$LN10@list_ass_s:

; 699  :     result = 0;

  00399	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR result$2$[rsp], 0
$Error$20764:

; 700  :  Error:
; 701  :     if (recycle != recycle_on_stack)

  003a1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR recycle$1$[rsp]
  003a6	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR recycle_on_stack$[rsp]
  003ae	48 3b d8	 cmp	 rbx, rax
  003b1	74 19		 je	 SHORT $LN4@list_ass_s

; 702  :         PyMem_FREE(recycle);

  003b3	e8 00 00 00 00	 call	 _Py_PXCTX
  003b8	48 8b cb	 mov	 rcx, rbx
  003bb	85 c0		 test	 eax, eax
  003bd	74 07		 je	 SHORT $LN53@list_ass_s
  003bf	e8 00 00 00 00	 call	 _PxMem_Free
  003c4	eb 06		 jmp	 SHORT $LN4@list_ass_s
$LN53@list_ass_s:
  003c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@list_ass_s:

; 703  :     Py_XDECREF(v_as_SF);

  003cc	48 85 f6	 test	 rsi, rsi
  003cf	74 65		 je	 SHORT $LN3@list_ass_s
  003d1	e8 00 00 00 00	 call	 _Py_PXCTX
  003d6	85 c0		 test	 eax, eax
  003d8	75 5c		 jne	 SHORT $LN3@list_ass_s
  003da	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  003de	a8 20		 test	 al, 32			; 00000020H
  003e0	75 4c		 jne	 SHORT $LN74@list_ass_s
  003e2	84 c0		 test	 al, al
  003e4	78 48		 js	 SHORT $LN74@list_ass_s
  003e6	a8 02		 test	 al, 2
  003e8	75 4c		 jne	 SHORT $LN3@list_ass_s
  003ea	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  003ee	75 46		 jne	 SHORT $LN3@list_ass_s
  003f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  003fe	4c 8b ce	 mov	 r9, rsi
  00401	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00407	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0040f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00414	48 8b ce	 mov	 rcx, rsi
  00417	85 c0		 test	 eax, eax
  00419	74 07		 je	 SHORT $LN79@list_ass_s
  0041b	e8 00 00 00 00	 call	 _Px_Dealloc
  00420	eb 14		 jmp	 SHORT $LN3@list_ass_s
$LN79@list_ass_s:
  00422	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00426	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0042c	eb 08		 jmp	 SHORT $LN3@list_ass_s
$LN74@list_ass_s:
  0042e	48 8b ce	 mov	 rcx, rsi
  00431	e8 00 00 00 00	 call	 Px_DecRef
$LN3@list_ass_s:

; 704  :     return result;

  00436	8b 44 24 50	 mov	 eax, DWORD PTR result$2$[rsp]
$LN43@list_ass_s:

; 705  : #undef b
; 706  : }

  0043a	4c 8d 9c 24 c0
	00 00 00	 lea	 r11, QWORD PTR [rsp+192]
  00442	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00446	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  0044a	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  0044e	49 8b e3	 mov	 rsp, r11
  00451	5f		 pop	 rdi
  00452	c3		 ret	 0
list_ass_slice ENDP
_TEXT	ENDS
PUBLIC	PyList_SetSlice
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_SetSlice DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$PyList_SetSlice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_SetSlice DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyList_SetSlice
_TEXT	SEGMENT
a$ = 48
ilow$ = 56
ihigh$ = 64
v$ = 72
PyList_SetSlice PROC					; COMDAT

; 710  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 711  :     if (!PyList_Check(a)) {

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  00012	75 19		 jne	 SHORT $LN1@PyList_Set@2

; 712  :         PyErr_BadInternalCall();

  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0001b	ba c8 02 00 00	 mov	 edx, 712		; 000002c8H
  00020	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 713  :         return -1;

  00025	83 c8 ff	 or	 eax, -1

; 714  :     }
; 715  : 
; 716  :     /* Px_CHECK_PROTECTION handled by list_ass_slice(). */
; 717  :     return list_ass_slice((PyListObject *)a, ilow, ihigh, v);
; 718  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
$LN1@PyList_Set@2:
  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	e9 00 00 00 00	 jmp	 list_ass_slice
PyList_SetSlice ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$list_inplace_repeat DD imagerel list_inplace_repeat
	DD	imagerel list_inplace_repeat+130
	DD	imagerel $unwind$list_inplace_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$list_inplace_repeat DD imagerel list_inplace_repeat+130
	DD	imagerel list_inplace_repeat+153
	DD	imagerel $chain$1$list_inplace_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$list_inplace_repeat DD imagerel list_inplace_repeat+153
	DD	imagerel list_inplace_repeat+271
	DD	imagerel $chain$3$list_inplace_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$list_inplace_repeat DD imagerel list_inplace_repeat+271
	DD	imagerel list_inplace_repeat+302
	DD	imagerel $chain$4$list_inplace_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$list_inplace_repeat DD imagerel list_inplace_repeat+302
	DD	imagerel list_inplace_repeat+375
	DD	imagerel $chain$5$list_inplace_repeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$list_inplace_repeat DD 021H
	DD	imagerel list_inplace_repeat
	DD	imagerel list_inplace_repeat+130
	DD	imagerel $unwind$list_inplace_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$list_inplace_repeat DD 021H
	DD	imagerel list_inplace_repeat+130
	DD	imagerel list_inplace_repeat+153
	DD	imagerel $chain$1$list_inplace_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$list_inplace_repeat DD 040a21H
	DD	0de40aH
	DD	0c7405H
	DD	imagerel list_inplace_repeat+130
	DD	imagerel list_inplace_repeat+153
	DD	imagerel $chain$1$list_inplace_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$list_inplace_repeat DD 040e21H
	DD	0b640eH
	DD	0a5405H
	DD	imagerel list_inplace_repeat
	DD	imagerel list_inplace_repeat+130
	DD	imagerel $unwind$list_inplace_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_inplace_repeat DD 040a01H
	DD	0d006520aH
	DD	03002c004H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT list_inplace_repeat
_TEXT	SEGMENT
self$ = 80
n$ = 88
list_inplace_repeat PROC				; COMDAT

; 722  : {

  00000	40 53		 push	 rbx
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 723  :     PyObject **items;
; 724  :     Py_ssize_t size, i, j, p;
; 725  : 
; 726  :     /*
; 727  :     if (Px_PROTECTION_ERROR(self))
; 728  :         return NULL;
; 729  :     */
; 730  : 
; 731  :     size = PyList_GET_SIZE(self);

  0000a	4c 8b 61 60	 mov	 r12, QWORD PTR [rcx+96]
  0000e	48 8b da	 mov	 rbx, rdx
  00011	4c 8b e9	 mov	 r13, rcx

; 732  :     if (size == 0 || n == 1) {

  00014	4d 85 e4	 test	 r12, r12
  00017	0f 84 11 01 00
	00		 je	 $LN10@list_inpla
  0001d	48 83 fa 01	 cmp	 rdx, 1
  00021	0f 84 07 01 00
	00		 je	 $LN10@list_inpla

; 735  :     }
; 736  : 
; 737  :     if (n < 1) {

  00027	7d 1a		 jge	 SHORT $LN9@list_inpla

; 738  :         (void)list_clear(self);

  00029	e8 00 00 00 00	 call	 list_clear

; 739  :         Py_INCREF(self);

  0002e	49 8b cd	 mov	 rcx, r13
  00031	e8 00 00 00 00	 call	 _Py_IncRef
  00036	49 8b c5	 mov	 rax, r13

; 760  :     return (PyObject *)self;
; 761  : }

  00039	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003d	41 5d		 pop	 r13
  0003f	41 5c		 pop	 r12
  00041	5b		 pop	 rbx
  00042	c3		 ret	 0
$LN9@list_inpla:

; 740  :         return (PyObject *)self;
; 741  :     }
; 742  : 
; 743  :     if (size > PY_SSIZE_T_MAX / n) {

  00043	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0004d	48 99		 cdq
  0004f	48 f7 fb	 idiv	 rbx
  00052	4c 3b e0	 cmp	 r12, rax
  00055	7e 0e		 jle	 SHORT $LN8@list_inpla

; 760  :     return (PyObject *)self;
; 761  : }

  00057	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005b	41 5d		 pop	 r13
  0005d	41 5c		 pop	 r12
  0005f	5b		 pop	 rbx
  00060	e9 00 00 00 00	 jmp	 PyErr_NoMemory
$LN8@list_inpla:

; 744  :         return PyErr_NoMemory();
; 745  :     }
; 746  : 
; 747  :     if (list_resize(self, size*n) == -1)

  00065	49 8b d4	 mov	 rdx, r12
  00068	48 0f af d3	 imul	 rdx, rbx
  0006c	e8 00 00 00 00	 call	 list_resize
  00071	83 f8 ff	 cmp	 eax, -1
  00074	75 0c		 jne	 SHORT $LN7@list_inpla

; 748  :         return NULL;

  00076	33 c0		 xor	 eax, eax

; 760  :     return (PyObject *)self;
; 761  : }

  00078	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007c	41 5d		 pop	 r13
  0007e	41 5c		 pop	 r12
  00080	5b		 pop	 rbx
  00081	c3		 ret	 0
$LN7@list_inpla:
  00082	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp

; 751  :     items = self->ob_item;

  00087	49 8b 6d 70	 mov	 rbp, QWORD PTR [r13+112]
  0008b	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  00090	49 8b f4	 mov	 rsi, r12

; 752  :     for (i = 1; i < n; i++) { /* Start counting at 1, not 0 */

  00093	48 83 fb 01	 cmp	 rbx, 1
  00097	7e 76		 jle	 SHORT $LN4@list_inpla

; 749  : 
; 750  :     p = size;

  00099	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  0009e	4c 89 74 24 68	 mov	 QWORD PTR [rsp+104], r14
  000a3	4c 8d 73 ff	 lea	 r14, QWORD PTR [rbx-1]
$LL6@list_inpla:

; 753  :         for (j = 0; j < size; j++) {

  000a7	33 ff		 xor	 edi, edi
  000a9	4d 85 e4	 test	 r12, r12
  000ac	7e 52		 jle	 SHORT $LN5@list_inpla
  000ae	66 90		 npad	 2
$LL3@list_inpla:

; 754  :             PyObject *o = items[j];

  000b0	48 8b 5c fd 00	 mov	 rbx, QWORD PTR [rbp+rdi*8]

; 755  :             Py_INCREF(o);

  000b5	e8 00 00 00 00	 call	 _Py_PXCTX
  000ba	85 c0		 test	 eax, eax
  000bc	75 32		 jne	 SHORT $LN19@list_inpla
  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000cc	4c 8b cb	 mov	 r9, rbx
  000cf	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000d5	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000dd	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e2	85 c0		 test	 eax, eax
  000e4	75 06		 jne	 SHORT $LN18@list_inpla
  000e6	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000ea	74 04		 je	 SHORT $LN19@list_inpla
$LN18@list_inpla:
  000ec	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN19@list_inpla:

; 756  :             items[p++] = o;

  000f0	48 ff c7	 inc	 rdi
  000f3	48 89 5c f5 00	 mov	 QWORD PTR [rbp+rsi*8], rbx
  000f8	48 ff c6	 inc	 rsi
  000fb	49 3b fc	 cmp	 rdi, r12
  000fe	7c b0		 jl	 SHORT $LL3@list_inpla
$LN5@list_inpla:

; 752  :     for (i = 1; i < n; i++) { /* Start counting at 1, not 0 */

  00100	49 ff ce	 dec	 r14
  00103	75 a2		 jne	 SHORT $LL6@list_inpla
  00105	4c 8b 74 24 68	 mov	 r14, QWORD PTR [rsp+104]
  0010a	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
$LN4@list_inpla:

; 757  :         }
; 758  :     }
; 759  :     Py_INCREF(self);

  0010f	49 8b cd	 mov	 rcx, r13
  00112	e8 00 00 00 00	 call	 _Py_IncRef
  00117	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0011c	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00121	49 8b c5	 mov	 rax, r13

; 760  :     return (PyObject *)self;
; 761  : }

  00124	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00128	41 5d		 pop	 r13
  0012a	41 5c		 pop	 r12
  0012c	5b		 pop	 rbx
  0012d	c3		 ret	 0
$LN10@list_inpla:

; 733  :         Py_INCREF(self);

  0012e	e8 00 00 00 00	 call	 _Py_PXCTX
  00133	85 c0		 test	 eax, eax
  00135	75 33		 jne	 SHORT $LN15@list_inpla
  00137	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00145	4d 8b cd	 mov	 r9, r13
  00148	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0014e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00156	e8 00 00 00 00	 call	 _PyParallel_Guard
  0015b	85 c0		 test	 eax, eax
  0015d	75 07		 jne	 SHORT $LN14@list_inpla
  0015f	41 f6 45 20 20	 test	 BYTE PTR [r13+32], 32	; 00000020H
  00164	74 04		 je	 SHORT $LN15@list_inpla
$LN14@list_inpla:
  00166	49 ff 45 50	 inc	 QWORD PTR [r13+80]
$LN15@list_inpla:

; 734  :         return (PyObject *)self;

  0016a	49 8b c5	 mov	 rax, r13

; 760  :     return (PyObject *)self;
; 761  : }

  0016d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00171	41 5d		 pop	 r13
  00173	41 5c		 pop	 r12
  00175	5b		 pop	 rbx
  00176	c3		 ret	 0
list_inplace_repeat ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_ass_item DD imagerel list_ass_item
	DD	imagerel list_ass_item+74
	DD	imagerel $unwind$list_ass_item
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$list_ass_item DD imagerel list_ass_item+74
	DD	imagerel list_ass_item+127
	DD	imagerel $chain$0$list_ass_item
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$list_ass_item DD imagerel list_ass_item+127
	DD	imagerel list_ass_item+165
	DD	imagerel $chain$1$list_ass_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$list_ass_item DD 021H
	DD	imagerel list_ass_item
	DD	imagerel list_ass_item+74
	DD	imagerel $unwind$list_ass_item
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$list_ass_item DD 020521H
	DD	063405H
	DD	imagerel list_ass_item
	DD	imagerel list_ass_item+74
	DD	imagerel $unwind$list_ass_item
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_ass_item DD 060f01H
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT list_ass_item
_TEXT	SEGMENT
a$ = 48
i$ = 56
v$ = 64
list_ass_item PROC					; COMDAT

; 765  : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b e8	 mov	 rbp, r8
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b f1	 mov	 rsi, rcx

; 766  :     PyObject *old_value;
; 767  :     if (i < 0 || i >= Py_SIZE(a)) {

  00018	48 85 d2	 test	 rdx, rdx
  0001b	78 62		 js	 SHORT $LN2@list_ass_i
  0001d	48 3b 51 60	 cmp	 rdx, QWORD PTR [rcx+96]
  00021	7d 5c		 jge	 SHORT $LN2@list_ass_i

; 770  :         return -1;
; 771  :     }
; 772  :     if (v == NULL)

  00023	4d 85 c0	 test	 r8, r8
  00026	75 1b		 jne	 SHORT $LN1@list_ass_i

; 773  :         /* Px_CHECK_PROTECTION handled by list_ass_slice() */
; 774  :         return list_ass_slice(a, i, i+1, v);

  00028	4c 8d 42 01	 lea	 r8, QWORD PTR [rdx+1]
  0002c	45 33 c9	 xor	 r9d, r9d

; 784  : }

  0002f	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00034	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	e9 00 00 00 00	 jmp	 list_ass_slice
$LN1@list_ass_i:

; 775  :     old_value = a->ob_item[i];

  00043	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]

; 776  :     /*
; 777  :     if (Px_ASSIGNMENT_ERROR(a, old_value))
; 778  :         return -1;
; 779  :     */
; 780  :     Py_INCREF(v);

  00047	49 8b c8	 mov	 rcx, r8
  0004a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0004f	48 8b 1c d0	 mov	 rbx, QWORD PTR [rax+rdx*8]
  00053	e8 00 00 00 00	 call	 _Py_IncRef

; 781  :     a->ob_item[i] = v;

  00058	4c 8b 5e 70	 mov	 r11, QWORD PTR [rsi+112]

; 782  :     Py_DECREF(old_value);

  0005c	48 8b cb	 mov	 rcx, rbx
  0005f	49 89 2c fb	 mov	 QWORD PTR [r11+rdi*8], rbp
  00063	e8 00 00 00 00	 call	 _Py_DecRef
  00068	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 783  :     return 0;

  0006d	33 c0		 xor	 eax, eax

; 784  : }

  0006f	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00074	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00079	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007d	5f		 pop	 rdi
  0007e	c3		 ret	 0
$LN2@list_ass_i:

; 768  :         PyErr_SetString(PyExc_IndexError,
; 769  :                         "list assignment index out of range");

  0007f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@MGPAAEOB@list?5assignment?5index?5out?5of?5ran@
  0008d	e8 00 00 00 00	 call	 PyErr_SetString

; 784  : }

  00092	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00097	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009c	83 c8 ff	 or	 eax, -1
  0009f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a3	5f		 pop	 rdi
  000a4	c3		 ret	 0
list_ass_item ENDP
_TEXT	ENDS
PUBLIC	??_C@_09EEABNKNH@nO?3insert?$AA@		; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$listinsert DD imagerel listinsert
	DD	imagerel listinsert+153
	DD	imagerel $unwind$listinsert
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listinsert DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_09EEABNKNH@nO?3insert?$AA@
CONST	SEGMENT
??_C@_09EEABNKNH@nO?3insert?$AA@ DB 'nO:insert', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
CONST	ENDS
;	COMDAT listinsert
_TEXT	SEGMENT
self$ = 64
args$ = 72
v$ = 80
i$ = 88
listinsert PROC						; COMDAT

; 788  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 789  :     Py_ssize_t i;
; 790  :     PyObject *v;
; 791  :     if (!PyArg_ParseTuple(args, "nO:insert", &i, &v))

  0000c	4c 8d 4c 24 50	 lea	 r9, QWORD PTR v$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09EEABNKNH@nO?3insert?$AA@
  00018	4c 8d 44 24 58	 lea	 r8, QWORD PTR i$[rsp]
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00025	85 c0		 test	 eax, eax

; 792  :         return NULL;

  00027	74 68		 je	 SHORT $LN1@listinsert

; 793  :     /* Px_CHECK_PROTECTION handled by ins1()->list_resize() */
; 794  :     if (ins1(self, i, v) == 0)

  00029	4c 8b 44 24 50	 mov	 r8, QWORD PTR v$[rsp]
  0002e	48 8b 54 24 58	 mov	 rdx, QWORD PTR i$[rsp]
  00033	48 8b cb	 mov	 rcx, rbx
  00036	e8 00 00 00 00	 call	 ins1
  0003b	85 c0		 test	 eax, eax
  0003d	75 52		 jne	 SHORT $LN1@listinsert

; 795  :         Py_RETURN_NONE;

  0003f	e8 00 00 00 00	 call	 _Py_PXCTX
  00044	85 c0		 test	 eax, eax
  00046	75 3c		 jne	 SHORT $LN6@listinsert
  00048	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0005d	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00063	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0006b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00070	85 c0		 test	 eax, eax
  00072	75 09		 jne	 SHORT $LN5@listinsert
  00074	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0007b	74 07		 je	 SHORT $LN6@listinsert
$LN5@listinsert:
  0007d	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN6@listinsert:
  00084	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 797  : }

  0008b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008f	5b		 pop	 rbx
  00090	c3		 ret	 0
$LN1@listinsert:

; 796  :     return NULL;

  00091	33 c0		 xor	 eax, eax

; 797  : }

  00093	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00097	5b		 pop	 rbx
  00098	c3		 ret	 0
listinsert ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$listclear DD imagerel listclear
	DD	imagerel listclear+105
	DD	imagerel $unwind$listclear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listclear DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT listclear
_TEXT	SEGMENT
self$ = 64
listclear PROC						; COMDAT

; 801  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 802  :     /*
; 803  :     if (Px_PROTECTION_ERROR(self))
; 804  :         return NULL;
; 805  :     */
; 806  :     list_clear(self);

  00006	e8 00 00 00 00	 call	 list_clear

; 807  :     Py_RETURN_NONE;

  0000b	e8 00 00 00 00	 call	 _Py_PXCTX
  00010	85 c0		 test	 eax, eax
  00012	75 48		 jne	 SHORT $LN7@listclear
  00014	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00029	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0002f	4c 8b cb	 mov	 r9, rbx
  00032	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0003a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003f	85 c0		 test	 eax, eax
  00041	75 09		 jne	 SHORT $LN3@listclear
  00043	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0004a	74 07		 je	 SHORT $LN9@listclear
$LN3@listclear:
  0004c	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN9@listclear:
  00053	48 8b c3	 mov	 rax, rbx

; 808  : }

  00056	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005a	5b		 pop	 rbx
  0005b	c3		 ret	 0
$LN7@listclear:

; 807  :     Py_RETURN_NONE;

  0005c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 808  : }

  00063	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00067	5b		 pop	 rbx
  00068	c3		 ret	 0
listclear ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT listcopy
_TEXT	SEGMENT
self$ = 8
listcopy PROC						; COMDAT

; 813  :     return list_slice(self, 0, Py_SIZE(self));

  00000	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  00004	33 d2		 xor	 edx, edx

; 814  : }

  00006	e9 00 00 00 00	 jmp	 list_slice
listcopy ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$listappend DD imagerel listappend
	DD	imagerel listappend+101
	DD	imagerel $unwind$listappend
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listappend DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT listappend
_TEXT	SEGMENT
self$ = 64
v$ = 72
listappend PROC						; COMDAT

; 818  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 819  :     /* Px_CHECK_PROTECTION handled by app1()->list_resize() */
; 820  :     if (app1(self, v) == 0)

  00004	e8 00 00 00 00	 call	 app1
  00009	85 c0		 test	 eax, eax
  0000b	75 51		 jne	 SHORT $LN1@listappend

; 821  :         Py_RETURN_NONE;

  0000d	e8 00 00 00 00	 call	 _Py_PXCTX
  00012	85 c0		 test	 eax, eax
  00014	75 3c		 jne	 SHORT $LN5@listappend
  00016	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0002b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00031	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00039	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003e	85 c0		 test	 eax, eax
  00040	75 09		 jne	 SHORT $LN4@listappend
  00042	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00049	74 07		 je	 SHORT $LN5@listappend
$LN4@listappend:
  0004b	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@listappend:
  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 823  : }

  00059	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005d	c3		 ret	 0
$LN1@listappend:

; 822  :     return NULL;

  0005e	33 c0		 xor	 eax, eax

; 823  : }

  00060	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00064	c3		 ret	 0
listappend ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@PNNFBCAN@argument?5must?5be?5iterable?$AA@ ; `string'
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_StopIteration:QWORD
EXTRN	PyErr_Occurred:PROC
EXTRN	_PyObject_LengthHint:PROC
EXTRN	PyObject_GetIter:PROC
EXTRN	PyTuple_Type:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$listextend DD imagerel listextend
	DD	imagerel listextend+637
	DD	imagerel $unwind$listextend
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listextend DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
xdata	ENDS
;	COMDAT ??_C@_0BK@PNNFBCAN@argument?5must?5be?5iterable?$AA@
CONST	SEGMENT
??_C@_0BK@PNNFBCAN@argument?5must?5be?5iterable?$AA@ DB 'argument must be'
	DB	' iterable', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
CONST	ENDS
;	COMDAT listextend
_TEXT	SEGMENT
self$ = 64
b$ = 72
listextend PROC						; COMDAT

; 827  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 828  :     PyObject *it;      /* iter(v) */
; 829  :     Py_ssize_t m;                  /* size of self */
; 830  :     Py_ssize_t n;                  /* guess for size of b */
; 831  :     Py_ssize_t mn;                 /* m + n */
; 832  :     Py_ssize_t i;
; 833  :     PyObject *(*iternext)(PyObject *);
; 834  : 
; 835  :     /*
; 836  :     if (Px_PROTECTION_ERROR(self))
; 837  :         return NULL;
; 838  :     */
; 839  : 
; 840  :     /* Special cases:
; 841  :        1) lists and tuples which can use PySequence_Fast ops
; 842  :        2) extending self to self requires making a copy first
; 843  :     */
; 844  :     if (PyList_CheckExact(b) || PyTuple_CheckExact(b) || (PyObject *)self == b) {

  0001a	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0001e	48 8b f9	 mov	 rdi, rcx
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyList_Type
  00028	48 8b da	 mov	 rbx, rdx
  0002b	48 3b c1	 cmp	 rax, rcx
  0002e	0f 84 19 01 00
	00		 je	 $LN21@listextend
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyTuple_Type
  0003b	48 3b c1	 cmp	 rax, rcx
  0003e	0f 84 09 01 00
	00		 je	 $LN21@listextend
  00044	48 3b fa	 cmp	 rdi, rdx
  00047	0f 84 00 01 00
	00		 je	 $LN21@listextend

; 875  :     }
; 876  : 
; 877  :     it = PyObject_GetIter(b);

  0004d	48 8b ca	 mov	 rcx, rdx
  00050	e8 00 00 00 00	 call	 PyObject_GetIter
  00055	48 8b e8	 mov	 rbp, rax

; 878  :     if (it == NULL)

  00058	48 85 c0	 test	 rax, rax

; 879  :         return NULL;

  0005b	0f 84 31 01 00
	00		 je	 $LN49@listextend

; 880  :     iternext = *it->ob_type->tp_iternext;

  00061	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]

; 881  : 
; 882  :     /* Guess a result list size. */
; 883  :     n = _PyObject_LengthHint(b, 8);

  00065	ba 08 00 00 00	 mov	 edx, 8
  0006a	48 8b cb	 mov	 rcx, rbx
  0006d	4c 8b a0 38 01
	00 00		 mov	 r12, QWORD PTR [rax+312]
  00074	e8 00 00 00 00	 call	 _PyObject_LengthHint

; 884  :     if (n == -1) {

  00079	48 83 f8 ff	 cmp	 rax, -1
  0007d	75 0f		 jne	 SHORT $LN13@listextend
$error$20983:

; 885  :         Py_DECREF(it);

  0007f	48 8b cd	 mov	 rcx, rbp
  00082	e8 00 00 00 00	 call	 _Py_DecRef

; 886  :         return NULL;

  00087	33 c0		 xor	 eax, eax
  00089	e9 d4 01 00 00	 jmp	 $LN23@listextend
$LN13@listextend:

; 887  :     }
; 888  :     m = Py_SIZE(self);

  0008e	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]

; 889  :     mn = m + n;

  00092	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]

; 890  :     if (mn >= m) {

  00096	48 3b d3	 cmp	 rdx, rbx
  00099	7c 11		 jl	 SHORT $LN41@listextend

; 891  :         /* Make room. */
; 892  :         if (list_resize(self, mn) == -1)

  0009b	48 8b cf	 mov	 rcx, rdi
  0009e	e8 00 00 00 00	 call	 list_resize
  000a3	83 f8 ff	 cmp	 eax, -1
  000a6	74 d7		 je	 SHORT $error$20983

; 893  :             goto error;
; 894  :         /* Make the list sane again. */
; 895  :         Py_SIZE(self) = m;

  000a8	48 89 5f 60	 mov	 QWORD PTR [rdi+96], rbx
$LN41@listextend:

; 896  :     }
; 897  :     /* Else m + n overflowed; on the chance that n lied, and there really
; 898  :      * is enough room, ignore it.  If n was telling the truth, we'll
; 899  :      * eventually run out of memory during the loop.
; 900  :      */
; 901  : 
; 902  :     /* Run iterator to exhaustion. */
; 903  :     for (;;) {
; 904  :         PyObject *item = iternext(it);

  000ac	48 8b cd	 mov	 rcx, rbp
  000af	41 ff d4	 call	 r12
  000b2	48 8b f0	 mov	 rsi, rax

; 905  :         if (item == NULL) {

  000b5	48 85 c0	 test	 rax, rax
  000b8	74 45		 je	 SHORT $LN43@listextend
  000ba	66 0f 1f 44 00
	00		 npad	 6
$LL10@listextend:

; 909  :                 else
; 910  :                     goto error;
; 911  :             }
; 912  :             break;
; 913  :         }
; 914  :         if (Py_SIZE(self) < self->allocated) {

  000c0	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  000c4	48 3b 47 78	 cmp	 rax, QWORD PTR [rdi+120]
  000c8	7d 0e		 jge	 SHORT $LN4@listextend

; 915  :             /* steals ref */
; 916  :             PyList_SET_ITEM(self, Py_SIZE(self), item);

  000ca	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  000ce	48 89 34 c1	 mov	 QWORD PTR [rcx+rax*8], rsi

; 917  :             ++Py_SIZE(self);

  000d2	48 ff 47 60	 inc	 QWORD PTR [rdi+96]

; 918  :         }
; 919  :         else {

  000d6	eb 19		 jmp	 SHORT $LN2@listextend
$LN4@listextend:

; 920  :             int status = app1(self, item);

  000d8	48 8b d6	 mov	 rdx, rsi
  000db	48 8b cf	 mov	 rcx, rdi
  000de	e8 00 00 00 00	 call	 app1

; 921  :             Py_DECREF(item);  /* append creates a new ref */

  000e3	48 8b ce	 mov	 rcx, rsi
  000e6	8b d8		 mov	 ebx, eax
  000e8	e8 00 00 00 00	 call	 _Py_DecRef

; 922  :             if (status < 0)

  000ed	85 db		 test	 ebx, ebx
  000ef	78 8e		 js	 SHORT $error$20983
$LN2@listextend:

; 896  :     }
; 897  :     /* Else m + n overflowed; on the chance that n lied, and there really
; 898  :      * is enough room, ignore it.  If n was telling the truth, we'll
; 899  :      * eventually run out of memory during the loop.
; 900  :      */
; 901  : 
; 902  :     /* Run iterator to exhaustion. */
; 903  :     for (;;) {
; 904  :         PyObject *item = iternext(it);

  000f1	48 8b cd	 mov	 rcx, rbp
  000f4	41 ff d4	 call	 r12
  000f7	48 8b f0	 mov	 rsi, rax

; 905  :         if (item == NULL) {

  000fa	48 85 c0	 test	 rax, rax
  000fd	75 c1		 jne	 SHORT $LL10@listextend
$LN43@listextend:

; 906  :             if (PyErr_Occurred()) {

  000ff	e8 00 00 00 00	 call	 PyErr_Occurred
  00104	48 85 c0	 test	 rax, rax
  00107	74 19		 je	 SHORT $LN5@listextend

; 907  :                 if (PyErr_ExceptionMatches(PyExc_StopIteration))

  00109	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_StopIteration
  00110	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00115	85 c0		 test	 eax, eax
  00117	0f 84 62 ff ff
	ff		 je	 $error$20983

; 908  :                     PyErr_Clear();

  0011d	e8 00 00 00 00	 call	 PyErr_Clear
$LN5@listextend:

; 923  :                 goto error;
; 924  :         }
; 925  :     }
; 926  : 
; 927  :     /* Cut back result list if initial guess was too large. */
; 928  :     if (Py_SIZE(self) < self->allocated)

  00122	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]
  00126	48 3b 57 78	 cmp	 rdx, QWORD PTR [rdi+120]
  0012a	7d 08		 jge	 SHORT $LN1@listextend

; 929  :         list_resize(self, Py_SIZE(self));  /* shrinking can't fail */

  0012c	48 8b cf	 mov	 rcx, rdi
  0012f	e8 00 00 00 00	 call	 list_resize
$LN1@listextend:

; 930  : 
; 931  :     Py_DECREF(it);

  00134	48 8b cd	 mov	 rcx, rbp
  00137	e8 00 00 00 00	 call	 _Py_DecRef

; 932  :     Py_RETURN_NONE;

  0013c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00143	e8 00 00 00 00	 call	 _Py_IncRef
  00148	e9 0e 01 00 00	 jmp	 $LN38@listextend
$LN21@listextend:

; 845  :         PyObject **src, **dest;
; 846  :         b = PySequence_Fast(b, "argument must be iterable");

  0014d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PNNFBCAN@argument?5must?5be?5iterable?$AA@
  00154	48 8b cb	 mov	 rcx, rbx
  00157	e8 00 00 00 00	 call	 PySequence_Fast
  0015c	48 8b f0	 mov	 rsi, rax

; 847  :         if (!b)

  0015f	48 85 c0	 test	 rax, rax

; 848  :             return NULL;

  00162	74 2e		 je	 SHORT $LN49@listextend

; 849  :         n = PySequence_Fast_GET_SIZE(b);

  00164	48 8b 6e 60	 mov	 rbp, QWORD PTR [rsi+96]
  00168	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]

; 850  :         if (n == 0) {

  0016c	48 85 ed	 test	 rbp, rbp

; 851  :             /* short circuit when b is empty */
; 852  :             Py_DECREF(b);
; 853  :             Py_RETURN_NONE;

  0016f	0f 84 99 00 00
	00		 je	 $LN15@listextend

; 854  :         }
; 855  :         m = Py_SIZE(self);

  00175	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]

; 856  :         if (list_resize(self, m + n) == -1) {

  00179	48 8b cf	 mov	 rcx, rdi
  0017c	48 8d 14 2b	 lea	 rdx, QWORD PTR [rbx+rbp]
  00180	e8 00 00 00 00	 call	 list_resize
  00185	83 f8 ff	 cmp	 eax, -1
  00188	75 0f		 jne	 SHORT $LN18@listextend

; 857  :             Py_DECREF(b);

  0018a	48 8b ce	 mov	 rcx, rsi
  0018d	e8 00 00 00 00	 call	 _Py_DecRef
$LN49@listextend:

; 858  :             return NULL;

  00192	33 c0		 xor	 eax, eax
  00194	e9 c9 00 00 00	 jmp	 $LN23@listextend
$LN18@listextend:

; 859  :         }
; 860  :         /* note that we may still have self == b here for the
; 861  :          * situation a.extend(a), but the following code works
; 862  :          * in that case too.  Just make sure to resize self
; 863  :          * before calling PySequence_Fast_ITEMS.
; 864  :          */
; 865  :         /* populate the end of self with b's items */
; 866  :         src = PySequence_Fast_ITEMS(b);

  00199	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  0019d	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  001a7	74 06		 je	 SHORT $LN27@listextend
  001a9	4c 8b 66 70	 mov	 r12, QWORD PTR [rsi+112]
  001ad	eb 04		 jmp	 SHORT $LN28@listextend
$LN27@listextend:
  001af	4c 8d 66 70	 lea	 r12, QWORD PTR [rsi+112]
$LN28@listextend:

; 867  :         dest = self->ob_item + m;

  001b3	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  001b7	48 8d 3c d8	 lea	 rdi, QWORD PTR [rax+rbx*8]

; 868  :         for (i = 0; i < n; i++) {

  001bb	48 85 ed	 test	 rbp, rbp
  001be	7e 4e		 jle	 SHORT $LN15@listextend
  001c0	4c 2b e7	 sub	 r12, rdi
$LL17@listextend:

; 869  :             PyObject *o = src[i];

  001c3	49 8b 1c 3c	 mov	 rbx, QWORD PTR [r12+rdi]

; 870  :             Py_INCREF(o);

  001c7	e8 00 00 00 00	 call	 _Py_PXCTX
  001cc	85 c0		 test	 eax, eax
  001ce	75 32		 jne	 SHORT $LN34@listextend
  001d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  001de	4c 8b cb	 mov	 r9, rbx
  001e1	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  001e7	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001ef	e8 00 00 00 00	 call	 _PyParallel_Guard
  001f4	85 c0		 test	 eax, eax
  001f6	75 06		 jne	 SHORT $LN33@listextend
  001f8	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  001fc	74 04		 je	 SHORT $LN34@listextend
$LN33@listextend:
  001fe	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN34@listextend:

; 871  :             dest[i] = o;

  00202	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  00205	48 83 c7 08	 add	 rdi, 8
  00209	48 ff cd	 dec	 rbp
  0020c	75 b5		 jne	 SHORT $LL17@listextend
$LN15@listextend:

; 872  :         }
; 873  :         Py_DECREF(b);

  0020e	48 8b ce	 mov	 rcx, rsi
  00211	e8 00 00 00 00	 call	 _Py_DecRef

; 874  :         Py_RETURN_NONE;

  00216	e8 00 00 00 00	 call	 _Py_PXCTX
  0021b	85 c0		 test	 eax, eax
  0021d	75 3c		 jne	 SHORT $LN38@listextend
  0021f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00226	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0022d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00234	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0023a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00242	e8 00 00 00 00	 call	 _PyParallel_Guard
  00247	85 c0		 test	 eax, eax
  00249	75 09		 jne	 SHORT $LN37@listextend
  0024b	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00252	74 07		 je	 SHORT $LN38@listextend
$LN37@listextend:
  00254	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN38@listextend:
  0025b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN23@listextend:

; 933  : 
; 934  :   error:
; 935  :     Py_DECREF(it);
; 936  :     return NULL;
; 937  : }

  00262	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00267	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0026c	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00271	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00276	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0027a	41 5c		 pop	 r12
  0027c	c3		 ret	 0
listextend ENDP
_TEXT	ENDS
PUBLIC	_PyList_Extend
; Function compile flags: /Ogtpy
;	COMDAT _PyList_Extend
_TEXT	SEGMENT
self$ = 8
b$ = 16
_PyList_Extend PROC					; COMDAT

; 942  :     /* Px_CHECK_PROTECTION handled by listextend() */
; 943  :     return listextend(self, b);
; 944  : }

  00000	e9 00 00 00 00	 jmp	 listextend
_PyList_Extend ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$list_inplace_concat DD imagerel list_inplace_concat
	DD	imagerel list_inplace_concat+101
	DD	imagerel $unwind$list_inplace_concat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_inplace_concat DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT list_inplace_concat
_TEXT	SEGMENT
self$ = 64
other$ = 72
list_inplace_concat PROC				; COMDAT

; 948  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 949  :     PyObject *result;
; 950  : 
; 951  :     /* Px_CHECK_PROTECTION handled by listextend() */
; 952  :     result = listextend(self, other);

  00009	e8 00 00 00 00	 call	 listextend

; 953  :     if (result == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 06		 jne	 SHORT $LN1@list_inpla@2

; 958  : }

  00013	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00017	5b		 pop	 rbx
  00018	c3		 ret	 0
$LN1@list_inpla@2:

; 954  :         return result;
; 955  :     Py_DECREF(result);

  00019	48 8b c8	 mov	 rcx, rax
  0001c	e8 00 00 00 00	 call	 _Py_DecRef

; 956  :     Py_INCREF(self);

  00021	e8 00 00 00 00	 call	 _Py_PXCTX
  00026	85 c0		 test	 eax, eax
  00028	75 32		 jne	 SHORT $LN5@list_inpla@2
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00038	4c 8b cb	 mov	 r9, rbx
  0003b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00041	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00049	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004e	85 c0		 test	 eax, eax
  00050	75 06		 jne	 SHORT $LN4@list_inpla@2
  00052	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00056	74 04		 je	 SHORT $LN5@list_inpla@2
$LN4@list_inpla@2:
  00058	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN5@list_inpla@2:

; 957  :     return (PyObject *)self;

  0005c	48 8b c3	 mov	 rax, rbx

; 958  : }

  0005f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00063	5b		 pop	 rbx
  00064	c3		 ret	 0
list_inplace_concat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@ ; `string'
PUBLIC	??_C@_0BE@BLOKHBKG@pop?5from?5empty?5list?$AA@	; `string'
PUBLIC	??_C@_06JHLPABKE@?$HMn?3pop?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$listpop DD imagerel listpop
	DD	imagerel listpop+113
	DD	imagerel $unwind$listpop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$listpop DD imagerel listpop+113
	DD	imagerel listpop+149
	DD	imagerel $chain$0$listpop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$listpop DD imagerel listpop+149
	DD	imagerel listpop+191
	DD	imagerel $chain$2$listpop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$listpop DD imagerel listpop+191
	DD	imagerel listpop+218
	DD	imagerel $chain$3$listpop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$listpop DD 021H
	DD	imagerel listpop
	DD	imagerel listpop+113
	DD	imagerel $unwind$listpop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$listpop DD 020021H
	DD	067400H
	DD	imagerel listpop
	DD	imagerel listpop+113
	DD	imagerel $unwind$listpop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$listpop DD 020521H
	DD	067405H
	DD	imagerel listpop
	DD	imagerel listpop+113
	DD	imagerel $unwind$listpop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listpop DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@ DB 'pop index out of r'
	DB	'ange', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BLOKHBKG@pop?5from?5empty?5list?$AA@
CONST	SEGMENT
??_C@_0BE@BLOKHBKG@pop?5from?5empty?5list?$AA@ DB 'pop from empty list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JHLPABKE@?$HMn?3pop?$AA@
CONST	SEGMENT
??_C@_06JHLPABKE@?$HMn?3pop?$AA@ DB '|n:pop', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT listpop
_TEXT	SEGMENT
self$ = 48
args$ = 56
i$ = 64
listpop	PROC						; COMDAT

; 962  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 963  :     Py_ssize_t i = -1;
; 964  :     PyObject *v;
; 965  :     int status;
; 966  : 
; 967  :     if (!PyArg_ParseTuple(args, "|n:pop", &i))

  0000c	4c 8d 44 24 40	 lea	 r8, QWORD PTR i$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06JHLPABKE@?$HMn?3pop?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	48 c7 44 24 40
	ff ff ff ff	 mov	 QWORD PTR i$[rsp], -1
  00024	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00029	85 c0		 test	 eax, eax

; 968  :         return NULL;

  0002b	74 1c		 je	 SHORT $LN12@listpop

; 969  : 
; 970  :     if (Py_SIZE(self) == 0) {

  0002d	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  00031	48 85 d2	 test	 rdx, rdx
  00034	75 1b		 jne	 SHORT $LN5@listpop

; 971  :         /* Special-case most common failure cause */
; 972  :         PyErr_SetString(PyExc_IndexError, "pop from empty list");

  00036	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@BLOKHBKG@pop?5from?5empty?5list?$AA@
  00044	e8 00 00 00 00	 call	 PyErr_SetString
$LN12@listpop:

; 973  :         return NULL;

  00049	33 c0		 xor	 eax, eax

; 990  :     assert(status >= 0);
; 991  :     /* Use status, so that in a release build compilers don't
; 992  :      * complain about the unused name.
; 993  :      */
; 994  :     (void) status;
; 995  : 
; 996  :     return v;
; 997  : }

  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5b		 pop	 rbx
  00050	c3		 ret	 0
$LN5@listpop:

; 974  :     }
; 975  :     if (i < 0)

  00051	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00056	48 85 c9	 test	 rcx, rcx
  00059	79 0a		 jns	 SHORT $LN9@listpop

; 976  :         i += Py_SIZE(self);

  0005b	48 03 ca	 add	 rcx, rdx
  0005e	48 89 4c 24 40	 mov	 QWORD PTR i$[rsp], rcx

; 977  :     if (i < 0 || i >= Py_SIZE(self)) {

  00063	78 5a		 js	 SHORT $LN2@listpop
$LN9@listpop:
  00065	48 3b ca	 cmp	 rcx, rdx
  00068	7d 55		 jge	 SHORT $LN2@listpop

; 980  :     }
; 981  :     v = self->ob_item[i];

  0006a	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]

; 982  :     /* Px_CHECK_PROTECTION handled by list_resize() or list_ass_slice() */
; 983  :     if (i == Py_SIZE(self) - 1) {

  0006e	48 ff ca	 dec	 rdx
  00071	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00076	48 8b 3c c8	 mov	 rdi, QWORD PTR [rax+rcx*8]
  0007a	48 3b ca	 cmp	 rcx, rdx
  0007d	75 16		 jne	 SHORT $LN1@listpop

; 984  :         status = list_resize(self, Py_SIZE(self) - 1);

  0007f	48 8b cb	 mov	 rcx, rbx
  00082	e8 00 00 00 00	 call	 list_resize

; 985  :         assert(status >= 0);
; 986  :         return v; /* and v now owns the reference the list had */

  00087	48 8b c7	 mov	 rax, rdi
  0008a	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 990  :     assert(status >= 0);
; 991  :     /* Use status, so that in a release build compilers don't
; 992  :      * complain about the unused name.
; 993  :      */
; 994  :     (void) status;
; 995  : 
; 996  :     return v;
; 997  : }

  0008f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00093	5b		 pop	 rbx
  00094	c3		 ret	 0
$LN1@listpop:

; 987  :     }
; 988  :     Py_INCREF(v);

  00095	48 8b cf	 mov	 rcx, rdi
  00098	e8 00 00 00 00	 call	 _Py_IncRef

; 989  :     status = list_ass_slice(self, i, i+1, (PyObject *)NULL);

  0009d	48 8b 54 24 40	 mov	 rdx, QWORD PTR i$[rsp]
  000a2	45 33 c9	 xor	 r9d, r9d
  000a5	4c 8d 42 01	 lea	 r8, QWORD PTR [rdx+1]
  000a9	48 8b cb	 mov	 rcx, rbx
  000ac	e8 00 00 00 00	 call	 list_ass_slice
  000b1	48 8b c7	 mov	 rax, rdi
  000b4	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 990  :     assert(status >= 0);
; 991  :     /* Use status, so that in a release build compilers don't
; 992  :      * complain about the unused name.
; 993  :      */
; 994  :     (void) status;
; 995  : 
; 996  :     return v;
; 997  : }

  000b9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bd	5b		 pop	 rbx
  000be	c3		 ret	 0
$LN2@listpop:

; 978  :         PyErr_SetString(PyExc_IndexError, "pop index out of range");

  000bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@
  000cd	e8 00 00 00 00	 call	 PyErr_SetString

; 979  :         return NULL;

  000d2	33 c0		 xor	 eax, eax

; 990  :     assert(status >= 0);
; 991  :     /* Use status, so that in a release build compilers don't
; 992  :      * complain about the unused name.
; 993  :      */
; 994  :     (void) status;
; 995  : 
; 996  :     return v;
; 997  : }

  000d4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d8	5b		 pop	 rbx
  000d9	c3		 ret	 0
listpop	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT reverse_slice
_TEXT	SEGMENT
lo$ = 8
hi$ = 16
reverse_slice PROC					; COMDAT

; 1003 :     assert(lo && hi);
; 1004 : 
; 1005 :     /* Px_CHECK_PROTECTION handled by callers (listreverse, listsort,
; 1006 :      * PyList_Reverse()).
; 1007 :      */
; 1008 : 
; 1009 :     --hi;

  00000	48 83 ea 08	 sub	 rdx, 8

; 1010 :     while (lo < hi) {

  00004	48 3b ca	 cmp	 rcx, rdx
  00007	73 21		 jae	 SHORT $LN1@reverse_sl
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@reverse_sl:

; 1011 :         PyObject *t = *lo;
; 1012 :         *lo = *hi;

  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00013	4c 8b 01	 mov	 r8, QWORD PTR [rcx]

; 1013 :         *hi = t;
; 1014 :         ++lo;
; 1015 :         --hi;

  00016	48 83 ea 08	 sub	 rdx, 8
  0001a	48 89 01	 mov	 QWORD PTR [rcx], rax
  0001d	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8
  00021	48 83 c1 08	 add	 rcx, 8
  00025	48 3b ca	 cmp	 rcx, rdx
  00028	72 e6		 jb	 SHORT $LL2@reverse_sl
$LN1@reverse_sl:

; 1016 :     }
; 1017 : }

  0002a	f3 c3		 fatret	 0
reverse_slice ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT sortslice_copy
_TEXT	SEGMENT
s1$ = 8
i$ = 16
s2$ = 24
j$ = 32
sortslice_copy PROC					; COMDAT

; 1040 :     s1->keys[i] = s2->keys[j];

  00000	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00003	4c 8b 11	 mov	 r10, QWORD PTR [rcx]
  00006	4a 8b 04 c8	 mov	 rax, QWORD PTR [rax+r9*8]
  0000a	49 89 04 d2	 mov	 QWORD PTR [r10+rdx*8], rax

; 1041 :     if (s1->values != NULL)

  0000e	4c 8b 51 08	 mov	 r10, QWORD PTR [rcx+8]
  00012	4d 85 d2	 test	 r10, r10
  00015	74 0c		 je	 SHORT $LN1@sortslice_

; 1042 :         s1->values[i] = s2->values[j];

  00017	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  0001b	4a 8b 0c c8	 mov	 rcx, QWORD PTR [rax+r9*8]
  0001f	49 89 0c d2	 mov	 QWORD PTR [r10+rdx*8], rcx
$LN1@sortslice_:

; 1043 : }

  00023	f3 c3		 fatret	 0
sortslice_copy ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT sortslice_copy_incr
_TEXT	SEGMENT
dst$ = 8
src$ = 16
sortslice_copy_incr PROC				; COMDAT

; 1048 :     *dst->keys++ = *src->keys++;

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00006	4c 8b c9	 mov	 r9, rcx
  00009	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000c	49 89 00	 mov	 QWORD PTR [r8], rax
  0000f	48 83 01 08	 add	 QWORD PTR [rcx], 8
  00013	48 83 02 08	 add	 QWORD PTR [rdx], 8

; 1049 :     if (dst->values != NULL)

  00017	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 14		 je	 SHORT $LN1@sortslice_@2

; 1050 :         *dst->values++ = *src->values++;

  00020	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00024	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00027	49 89 08	 mov	 QWORD PTR [r8], rcx
  0002a	49 83 41 08 08	 add	 QWORD PTR [r9+8], 8
  0002f	48 83 42 08 08	 add	 QWORD PTR [rdx+8], 8
$LN1@sortslice_@2:

; 1051 : }

  00034	f3 c3		 fatret	 0
sortslice_copy_incr ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT sortslice_copy_decr
_TEXT	SEGMENT
dst$ = 8
src$ = 16
sortslice_copy_decr PROC				; COMDAT

; 1056 :     *dst->keys-- = *src->keys--;

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00006	4c 8b c9	 mov	 r9, rcx
  00009	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000c	49 89 00	 mov	 QWORD PTR [r8], rax
  0000f	48 83 01 f8	 add	 QWORD PTR [rcx], -8
  00013	48 83 02 f8	 add	 QWORD PTR [rdx], -8

; 1057 :     if (dst->values != NULL)

  00017	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 14		 je	 SHORT $LN1@sortslice_@3

; 1058 :         *dst->values-- = *src->values--;

  00020	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00024	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00027	49 89 08	 mov	 QWORD PTR [r8], rcx
  0002a	49 83 41 08 f8	 add	 QWORD PTR [r9+8], -8
  0002f	48 83 42 08 f8	 add	 QWORD PTR [rdx+8], -8
$LN1@sortslice_@3:

; 1059 : }

  00034	f3 c3		 fatret	 0
sortslice_copy_decr ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sortslice_memcpy DD imagerel sortslice_memcpy
	DD	imagerel sortslice_memcpy+129
	DD	imagerel $unwind$sortslice_memcpy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sortslice_memcpy DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT sortslice_memcpy
_TEXT	SEGMENT
s1$ = 48
i$ = 56
s2$ = 64
j$ = 72
n$ = 80
sortslice_memcpy PROC					; COMDAT

; 1065 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1066 :     memcpy(&s1->keys[i], &s2->keys[j], sizeof(PyObject *) * n);

  0001a	48 8b 44 24 50	 mov	 rax, QWORD PTR n$[rsp]
  0001f	48 8b ea	 mov	 rbp, rdx
  00022	48 8b d9	 mov	 rbx, rcx
  00025	4c 8d 24 c5 00
	00 00 00	 lea	 r12, QWORD PTR [rax*8]
  0002d	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00030	49 8b f0	 mov	 rsi, r8
  00033	4a 8d 14 c8	 lea	 rdx, QWORD PTR [rax+r9*8]
  00037	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0003a	4d 8b c4	 mov	 r8, r12
  0003d	48 8d 0c e8	 lea	 rcx, QWORD PTR [rax+rbp*8]
  00041	49 8b f9	 mov	 rdi, r9
  00044	e8 00 00 00 00	 call	 memcpy

; 1067 :     if (s1->values != NULL)

  00049	4c 8b 5b 08	 mov	 r11, QWORD PTR [rbx+8]
  0004d	4d 85 db	 test	 r11, r11
  00050	74 14		 je	 SHORT $LN1@sortslice_@4

; 1068 :         memcpy(&s1->values[i], &s2->values[j], sizeof(PyObject *) * n);

  00052	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  00056	49 8d 0c eb	 lea	 rcx, QWORD PTR [r11+rbp*8]
  0005a	4d 8b c4	 mov	 r8, r12
  0005d	48 8d 14 f8	 lea	 rdx, QWORD PTR [rax+rdi*8]
  00061	e8 00 00 00 00	 call	 memcpy
$LN1@sortslice_@4:

; 1069 : }

  00066	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006b	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00070	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00075	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0007a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007e	41 5c		 pop	 r12
  00080	c3		 ret	 0
sortslice_memcpy ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sortslice_memmove DD imagerel sortslice_memmove
	DD	imagerel sortslice_memmove+131
	DD	imagerel $unwind$sortslice_memmove
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sortslice_memmove DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT sortslice_memmove
_TEXT	SEGMENT
s1$ = 48
i$ = 56
s2$ = 64
j$ = 72
n$ = 80
sortslice_memmove PROC					; COMDAT

; 1074 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1075 :     memmove(&s1->keys[i], &s2->keys[j], sizeof(PyObject *) * n);

  0001a	48 8b 44 24 50	 mov	 rax, QWORD PTR n$[rsp]
  0001f	48 8b ea	 mov	 rbp, rdx
  00022	48 8b d9	 mov	 rbx, rcx
  00025	4c 8d 24 c5 00
	00 00 00	 lea	 r12, QWORD PTR [rax*8]
  0002d	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00030	49 8b f0	 mov	 rsi, r8
  00033	4a 8d 14 c8	 lea	 rdx, QWORD PTR [rax+r9*8]
  00037	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0003a	4d 8b c4	 mov	 r8, r12
  0003d	48 8d 0c e8	 lea	 rcx, QWORD PTR [rax+rbp*8]
  00041	49 8b f9	 mov	 rdi, r9
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 1076 :     if (s1->values != NULL)

  0004a	4c 8b 5b 08	 mov	 r11, QWORD PTR [rbx+8]
  0004e	4d 85 db	 test	 r11, r11
  00051	74 15		 je	 SHORT $LN1@sortslice_@5

; 1077 :         memmove(&s1->values[i], &s2->values[j], sizeof(PyObject *) * n);

  00053	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  00057	49 8d 0c eb	 lea	 rcx, QWORD PTR [r11+rbp*8]
  0005b	4d 8b c4	 mov	 r8, r12
  0005e	48 8d 14 f8	 lea	 rdx, QWORD PTR [rax+rdi*8]
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN1@sortslice_@5:

; 1078 : }

  00068	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006d	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00072	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00077	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	41 5c		 pop	 r12
  00082	c3		 ret	 0
sortslice_memmove ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT sortslice_advance
_TEXT	SEGMENT
slice$ = 8
n$ = 16
sortslice_advance PROC					; COMDAT

; 1083 :     slice->keys += n;
; 1084 :     if (slice->values != NULL)

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	48 c1 e2 03	 shl	 rdx, 3
  00008	48 01 11	 add	 QWORD PTR [rcx], rdx
  0000b	48 85 c0	 test	 rax, rax
  0000e	74 07		 je	 SHORT $LN1@sortslice_@6

; 1085 :         slice->values += n;

  00010	48 03 c2	 add	 rax, rdx
  00013	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN1@sortslice_@6:

; 1086 : }

  00017	f3 c3		 fatret	 0
sortslice_advance ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$binarysort DD imagerel binarysort
	DD	imagerel binarysort+280
	DD	imagerel $unwind$binarysort
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binarysort DD 0c3001H
	DD	0bc430H
	DD	0a742bH
	DD	096426H
	DD	083421H
	DD	0e006320aH
	DD	05002d004H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT binarysort
_TEXT	SEGMENT
lo$ = 64
hi$ = 72
start$ = 80
binarysort PROC						; COMDAT

; 1114 : {

  00000	40 55		 push	 rbp
  00002	41 55		 push	 r13
  00004	41 56		 push	 r14
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b e8	 mov	 rbp, r8
  0000d	4c 8b f2	 mov	 r14, rdx
  00010	4c 8b e9	 mov	 r13, rcx

; 1115 :     register Py_ssize_t k;
; 1116 :     register PyObject **l, **p, **r;
; 1117 :     register PyObject *pivot;
; 1118 : 
; 1119 :     assert(lo.keys <= start && start <= hi);
; 1120 :     /* assert [lo, start) is sorted */
; 1121 :     if (lo.keys == start)

  00013	4c 39 01	 cmp	 QWORD PTR [rcx], r8
  00016	75 04		 jne	 SHORT $LN17@binarysort

; 1122 :         ++start;

  00018	48 83 c5 08	 add	 rbp, 8
$LN17@binarysort:
  0001c	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00021	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00026	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0002b	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12

; 1123 :     for (; start < hi; ++start) {

  00030	48 3b ea	 cmp	 rbp, rdx
  00033	0f 83 ba 00 00
	00		 jae	 $LN14@binarysort
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL16@binarysort:

; 1124 :         /* set l to where *start belongs */
; 1125 :         l = lo.keys;

  00040	49 8b 5d 00	 mov	 rbx, QWORD PTR [r13]

; 1126 :         r = start;
; 1127 :         pivot = *r;

  00044	4c 8b 65 00	 mov	 r12, QWORD PTR [rbp]
  00048	48 8b fd	 mov	 rdi, rbp
  0004b	0f 1f 44 00 00	 npad	 5
$LL13@binarysort:

; 1128 :         /* Invariants:
; 1129 :          * pivot >= all in [lo, l).
; 1130 :          * pivot  < all in [r, start).
; 1131 :          * The second is vacuously true at the start.
; 1132 :          */
; 1133 :         assert(l < r);
; 1134 :         do {
; 1135 :             p = l + ((r - l) >> 1);

  00050	48 8b c7	 mov	 rax, rdi

; 1136 :             IFLT(pivot, *p)

  00053	45 33 c0	 xor	 r8d, r8d
  00056	49 8b cc	 mov	 rcx, r12
  00059	48 2b c3	 sub	 rax, rbx
  0005c	48 c1 f8 04	 sar	 rax, 4
  00060	48 8d 34 c3	 lea	 rsi, QWORD PTR [rbx+rax*8]
  00064	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00067	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0006c	85 c0		 test	 eax, eax
  0006e	0f 88 9f 00 00
	00		 js	 $fail$21167
  00074	74 05		 je	 SHORT $LN9@binarysort

; 1137 :                 r = p;

  00076	48 8b fe	 mov	 rdi, rsi

; 1138 :             else

  00079	eb 04		 jmp	 SHORT $LN12@binarysort
$LN9@binarysort:

; 1139 :                 l = p+1;

  0007b	48 8d 5e 08	 lea	 rbx, QWORD PTR [rsi+8]
$LN12@binarysort:

; 1140 :         } while (l < r);

  0007f	48 3b df	 cmp	 rbx, rdi
  00082	72 cc		 jb	 SHORT $LL13@binarysort

; 1141 :         assert(l == r);
; 1142 :         /* The invariants still hold, so pivot >= all in [lo, l) and
; 1143 :            pivot < all in [l, start), so pivot belongs at l.  Note
; 1144 :            that if there are elements equal to pivot, l points to the
; 1145 :            first slot after them -- that's why this sort is stable.
; 1146 :            Slide over to make room.
; 1147 :            Caution: using memmove is much slower under MSVC 5;
; 1148 :            we're not usually moving many slots. */
; 1149 :         for (p = start; p > l; --p)

  00084	48 8b d5	 mov	 rdx, rbp
  00087	48 3b eb	 cmp	 rbp, rbx
  0008a	76 17		 jbe	 SHORT $LN5@binarysort
  0008c	0f 1f 40 00	 npad	 4
$LL7@binarysort:

; 1150 :             *p = *(p-1);

  00090	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]
  00094	48 8d 4a f8	 lea	 rcx, QWORD PTR [rdx-8]
  00098	48 89 02	 mov	 QWORD PTR [rdx], rax
  0009b	48 8b d1	 mov	 rdx, rcx
  0009e	48 3b cb	 cmp	 rcx, rbx
  000a1	77 ed		 ja	 SHORT $LL7@binarysort
$LN5@binarysort:

; 1151 :         *l = pivot;

  000a3	4c 89 23	 mov	 QWORD PTR [rbx], r12

; 1152 :         if (lo.values != NULL) {

  000a6	49 8b 45 08	 mov	 rax, QWORD PTR [r13+8]
  000aa	48 85 c0	 test	 rax, rax
  000ad	74 37		 je	 SHORT $LN15@binarysort

; 1153 :             Py_ssize_t offset = lo.values - lo.keys;

  000af	49 2b 45 00	 sub	 rax, QWORD PTR [r13]

; 1154 :             p = start + offset;

  000b3	48 83 e0 f8	 and	 rax, -8

; 1155 :             pivot = *p;
; 1156 :             l += offset;

  000b7	48 03 d8	 add	 rbx, rax
  000ba	48 8d 14 28	 lea	 rdx, QWORD PTR [rax+rbp]
  000be	4c 8b 02	 mov	 r8, QWORD PTR [rdx]

; 1157 :             for (p = start + offset; p > l; --p)

  000c1	48 3b d3	 cmp	 rdx, rbx
  000c4	76 1d		 jbe	 SHORT $LN1@binarysort
  000c6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL3@binarysort:

; 1158 :                 *p = *(p-1);

  000d0	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]
  000d4	48 8d 4a f8	 lea	 rcx, QWORD PTR [rdx-8]
  000d8	48 89 02	 mov	 QWORD PTR [rdx], rax
  000db	48 8b d1	 mov	 rdx, rcx
  000de	48 3b cb	 cmp	 rcx, rbx
  000e1	77 ed		 ja	 SHORT $LL3@binarysort
$LN1@binarysort:

; 1159 :             *l = pivot;

  000e3	4c 89 03	 mov	 QWORD PTR [rbx], r8
$LN15@binarysort:

; 1123 :     for (; start < hi; ++start) {

  000e6	48 83 c5 08	 add	 rbp, 8
  000ea	49 3b ee	 cmp	 rbp, r14
  000ed	0f 82 4d ff ff
	ff		 jb	 $LL16@binarysort
$LN14@binarysort:

; 1160 :         }
; 1161 :     }
; 1162 :     return 0;

  000f3	33 c0		 xor	 eax, eax
$LN18@binarysort:
  000f5	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]
  000fa	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  000ff	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00104	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1166 : }

  00109	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010d	41 5e		 pop	 r14
  0010f	41 5d		 pop	 r13
  00111	5d		 pop	 rbp
  00112	c3		 ret	 0
$fail$21167:

; 1163 : 
; 1164 :  fail:
; 1165 :     return -1;

  00113	83 c8 ff	 or	 eax, -1
  00116	eb dd		 jmp	 SHORT $LN18@binarysort
binarysort ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$count_run DD imagerel count_run
	DD	imagerel count_run+223
	DD	imagerel $unwind$count_run
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$count_run DD 084901H
	DD	067449H
	DD	08540fH
	DD	07340fH
	DD	0600b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT count_run
_TEXT	SEGMENT
lo$ = 48
hi$ = 56
descending$ = 64
count_run PROC						; COMDAT

; 1188 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1189 :     Py_ssize_t k;
; 1190 :     Py_ssize_t n;
; 1191 : 
; 1192 :     assert(lo < hi);
; 1193 :     *descending = 0;
; 1194 :     ++lo;

  0000f	48 8d 59 08	 lea	 rbx, QWORD PTR [rcx+8]
  00013	49 8b e8	 mov	 rbp, r8
  00016	48 8b f2	 mov	 rsi, rdx
  00019	41 c7 00 00 00
	00 00		 mov	 DWORD PTR [r8], 0

; 1195 :     if (lo == hi)

  00020	48 3b da	 cmp	 rbx, rdx
  00023	75 15		 jne	 SHORT $LN15@count_run

; 1196 :         return 1;

  00025	b8 01 00 00 00	 mov	 eax, 1

; 1218 : }

  0002a	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0002f	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5e		 pop	 rsi
  00039	c3		 ret	 0
$LN15@count_run:

; 1197 : 
; 1198 :     n = 2;
; 1199 :     IFLT(*lo, *(lo-1)) {

  0003a	48 8b 53 f8	 mov	 rdx, QWORD PTR [rbx-8]
  0003e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00041	45 33 c0	 xor	 r8d, r8d
  00044	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00049	bf 02 00 00 00	 mov	 edi, 2
  0004e	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00053	85 c0		 test	 eax, eax
  00055	78 6f		 js	 SHORT $fail$21193
  00057	74 3d		 je	 SHORT $LN13@count_run

; 1200 :         *descending = 1;
; 1201 :         for (lo = lo+1; lo < hi; ++lo, ++n) {

  00059	48 83 c3 08	 add	 rbx, 8
  0005d	c7 45 00 01 00
	00 00		 mov	 DWORD PTR [rbp], 1
  00064	48 3b de	 cmp	 rbx, rsi
  00067	73 58		 jae	 SHORT $LN22@count_run
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL12@count_run:

; 1202 :             IFLT(*lo, *(lo-1))

  00070	48 8b 53 f8	 mov	 rdx, QWORD PTR [rbx-8]
  00074	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00077	45 33 c0	 xor	 r8d, r8d
  0007a	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0007f	85 c0		 test	 eax, eax
  00081	78 43		 js	 SHORT $fail$21193
  00083	74 3c		 je	 SHORT $LN22@count_run

; 1200 :         *descending = 1;
; 1201 :         for (lo = lo+1; lo < hi; ++lo, ++n) {

  00085	48 83 c3 08	 add	 rbx, 8
  00089	48 ff c7	 inc	 rdi
  0008c	48 3b de	 cmp	 rbx, rsi
  0008f	72 df		 jb	 SHORT $LL12@count_run

; 1211 :                 break;
; 1212 :         }
; 1213 :     }
; 1214 : 
; 1215 :     return n;

  00091	48 8b c7	 mov	 rax, rdi
  00094	eb 34		 jmp	 SHORT $LN25@count_run
$LN13@count_run:

; 1203 :                 ;
; 1204 :             else
; 1205 :                 break;
; 1206 :         }
; 1207 :     }
; 1208 :     else {
; 1209 :         for (lo = lo+1; lo < hi; ++lo, ++n) {

  00096	48 83 c3 08	 add	 rbx, 8
  0009a	48 3b de	 cmp	 rbx, rsi
  0009d	73 22		 jae	 SHORT $LN22@count_run
  0009f	90		 npad	 1
$LL5@count_run:

; 1210 :             IFLT(*lo, *(lo-1))

  000a0	48 8b 53 f8	 mov	 rdx, QWORD PTR [rbx-8]
  000a4	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000a7	45 33 c0	 xor	 r8d, r8d
  000aa	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  000af	85 c0		 test	 eax, eax
  000b1	78 13		 js	 SHORT $fail$21193
  000b3	75 0c		 jne	 SHORT $LN22@count_run

; 1203 :                 ;
; 1204 :             else
; 1205 :                 break;
; 1206 :         }
; 1207 :     }
; 1208 :     else {
; 1209 :         for (lo = lo+1; lo < hi; ++lo, ++n) {

  000b5	48 83 c3 08	 add	 rbx, 8
  000b9	48 ff c7	 inc	 rdi
  000bc	48 3b de	 cmp	 rbx, rsi
  000bf	72 df		 jb	 SHORT $LL5@count_run
$LN22@count_run:

; 1211 :                 break;
; 1212 :         }
; 1213 :     }
; 1214 : 
; 1215 :     return n;

  000c1	48 8b c7	 mov	 rax, rdi
  000c4	eb 04		 jmp	 SHORT $LN25@count_run
$fail$21193:

; 1216 : fail:
; 1217 :     return -1;

  000c6	48 83 c8 ff	 or	 rax, -1
$LN25@count_run:
  000ca	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1218 : }

  000cf	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000d4	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000d9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000dd	5e		 pop	 rsi
  000de	c3		 ret	 0
count_run ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gallop_left DD imagerel gallop_left
	DD	imagerel gallop_left+360
	DD	imagerel $unwind$gallop_left
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gallop_left DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0e01a321eH
	DD	0c016d018H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gallop_left
_TEXT	SEGMENT
key$ = 64
a$ = 72
n$ = 80
hint$ = 88
gallop_left PROC					; COMDAT

; 1243 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1244 :     Py_ssize_t ofs;
; 1245 :     Py_ssize_t lastofs;
; 1246 :     Py_ssize_t k;
; 1247 : 
; 1248 :     assert(key && a && n > 0 && hint >= 0 && hint < n);
; 1249 : 
; 1250 :     a += hint;

  0001e	4e 8d 34 cd 00
	00 00 00	 lea	 r14, QWORD PTR [r9*8]
  00026	4c 8b e9	 mov	 r13, rcx
  00029	49 8b f8	 mov	 rdi, r8
  0002c	49 8d 2c 16	 lea	 rbp, QWORD PTR [r14+rdx]

; 1251 :     lastofs = 0;
; 1252 :     ofs = 1;
; 1253 :     IFLT(*a, key) {

  00030	48 8b d1	 mov	 rdx, rcx
  00033	33 f6		 xor	 esi, esi
  00035	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
  00039	45 33 c0	 xor	 r8d, r8d
  0003c	4d 8b e1	 mov	 r12, r9
  0003f	8d 5e 01	 lea	 ebx, QWORD PTR [rsi+1]
  00042	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00047	85 c0		 test	 eax, eax
  00049	0f 88 f6 00 00
	00		 js	 $fail$21222
  0004f	74 4d		 je	 SHORT $LN20@gallop_lef

; 1254 :         /* a[hint] < key -- gallop right, until
; 1255 :          * a[hint + lastofs] < key <= a[hint + ofs]
; 1256 :          */
; 1257 :         const Py_ssize_t maxofs = n - hint;             /* &a[n-1] is highest */

  00051	49 2b fc	 sub	 rdi, r12

; 1258 :         while (ofs < maxofs) {

  00054	48 3b df	 cmp	 rbx, rdi
  00057	7d 36		 jge	 SHORT $LN37@gallop_lef
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL19@gallop_lef:

; 1259 :             IFLT(a[ofs], key) {

  00060	48 8b 4c dd 00	 mov	 rcx, QWORD PTR [rbp+rbx*8]
  00065	45 33 c0	 xor	 r8d, r8d
  00068	49 8b d5	 mov	 rdx, r13
  0006b	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00070	85 c0		 test	 eax, eax
  00072	0f 88 cd 00 00
	00		 js	 $fail$21222
  00078	74 12		 je	 SHORT $LN16@gallop_lef

; 1260 :                 lastofs = ofs;

  0007a	48 8b f3	 mov	 rsi, rbx

; 1261 :                 ofs = (ofs << 1) + 1;

  0007d	48 8d 5c 1b 01	 lea	 rbx, QWORD PTR [rbx+rbx+1]

; 1262 :                 if (ofs <= 0)                   /* int overflow */

  00082	48 85 db	 test	 rbx, rbx
  00085	7e 0f		 jle	 SHORT $LN13@gallop_lef

; 1258 :         while (ofs < maxofs) {

  00087	48 3b df	 cmp	 rbx, rdi
  0008a	7c d4		 jl	 SHORT $LL19@gallop_lef
$LN16@gallop_lef:

; 1263 :                     ofs = maxofs;
; 1264 :             }
; 1265 :             else                /* key <= a[hint + ofs] */
; 1266 :                 break;
; 1267 :         }
; 1268 :         if (ofs > maxofs)

  0008c	48 3b df	 cmp	 rbx, rdi
$LN37@gallop_lef:
  0008f	48 0f 4f df	 cmovg	 rbx, rdi
  00093	48 8b fb	 mov	 rdi, rbx
$LN13@gallop_lef:

; 1269 :             ofs = maxofs;
; 1270 :         /* Translate back to offsets relative to &a[0]. */
; 1271 :         lastofs += hint;

  00096	49 03 f4	 add	 rsi, r12

; 1272 :         ofs += hint;

  00099	49 03 fc	 add	 rdi, r12

; 1273 :     }
; 1274 :     else {

  0009c	eb 5f		 jmp	 SHORT $LN12@gallop_lef
$LN20@gallop_lef:

; 1275 :         /* key <= a[hint] -- gallop left, until
; 1276 :          * a[hint - ofs] < key <= a[hint - lastofs]
; 1277 :          */
; 1278 :         const Py_ssize_t maxofs = hint + 1;             /* &a[0] is lowest */

  0009e	49 8d 7c 24 01	 lea	 rdi, QWORD PTR [r12+1]

; 1279 :         while (ofs < maxofs) {

  000a3	48 3b df	 cmp	 rbx, rdi
  000a6	7d 3f		 jge	 SHORT $LN38@gallop_lef
  000a8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL11@gallop_lef:

; 1280 :             IFLT(*(a-ofs), key)

  000b0	48 8d 04 dd 00
	00 00 00	 lea	 rax, QWORD PTR [rbx*8]
  000b8	48 8b cd	 mov	 rcx, rbp
  000bb	45 33 c0	 xor	 r8d, r8d
  000be	48 2b c8	 sub	 rcx, rax
  000c1	49 8b d5	 mov	 rdx, r13
  000c4	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000c7	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  000cc	85 c0		 test	 eax, eax
  000ce	78 75		 js	 SHORT $fail$21222
  000d0	75 12		 jne	 SHORT $LN29@gallop_lef

; 1281 :                 break;
; 1282 :             /* key <= a[hint - ofs] */
; 1283 :             lastofs = ofs;

  000d2	48 8b f3	 mov	 rsi, rbx

; 1284 :             ofs = (ofs << 1) + 1;

  000d5	48 8d 5c 1b 01	 lea	 rbx, QWORD PTR [rbx+rbx+1]

; 1285 :             if (ofs <= 0)               /* int overflow */

  000da	48 85 db	 test	 rbx, rbx
  000dd	7e 0f		 jle	 SHORT $LN6@gallop_lef

; 1279 :         while (ofs < maxofs) {

  000df	48 3b df	 cmp	 rbx, rdi
  000e2	7c cc		 jl	 SHORT $LL11@gallop_lef
$LN29@gallop_lef:

; 1286 :                 ofs = maxofs;
; 1287 :         }
; 1288 :         if (ofs > maxofs)

  000e4	48 3b df	 cmp	 rbx, rdi
$LN38@gallop_lef:
  000e7	48 0f 4f df	 cmovg	 rbx, rdi
  000eb	48 8b fb	 mov	 rdi, rbx
$LN6@gallop_lef:

; 1289 :             ofs = maxofs;
; 1290 :         /* Translate back to positive offsets relative to &a[0]. */
; 1291 :         k = lastofs;

  000ee	48 8b c6	 mov	 rax, rsi

; 1292 :         lastofs = hint - ofs;

  000f1	49 8b f4	 mov	 rsi, r12
  000f4	48 2b f7	 sub	 rsi, rdi

; 1293 :         ofs = hint - k;

  000f7	49 8b fc	 mov	 rdi, r12
  000fa	48 2b f8	 sub	 rdi, rax
$LN12@gallop_lef:

; 1294 :     }
; 1295 :     a -= hint;
; 1296 : 
; 1297 :     assert(-1 <= lastofs && lastofs < ofs && ofs <= n);
; 1298 :     /* Now a[lastofs] < key <= a[ofs], so key belongs somewhere to the
; 1299 :      * right of lastofs but no farther right than ofs.  Do a binary
; 1300 :      * search, with invariant a[lastofs-1] < key <= a[ofs].
; 1301 :      */
; 1302 :     ++lastofs;

  000fd	48 ff c6	 inc	 rsi
  00100	49 2b ee	 sub	 rbp, r14

; 1303 :     while (lastofs < ofs) {

  00103	48 3b f7	 cmp	 rsi, rdi
  00106	7d 38		 jge	 SHORT $LN4@gallop_lef
  00108	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@gallop_lef:

; 1304 :         Py_ssize_t m = lastofs + ((ofs - lastofs) >> 1);

  00110	48 8b df	 mov	 rbx, rdi

; 1305 : 
; 1306 :         IFLT(a[m], key)

  00113	45 33 c0	 xor	 r8d, r8d
  00116	49 8b d5	 mov	 rdx, r13
  00119	48 2b de	 sub	 rbx, rsi
  0011c	48 d1 fb	 sar	 rbx, 1
  0011f	48 03 de	 add	 rbx, rsi
  00122	48 8b 4c dd 00	 mov	 rcx, QWORD PTR [rbp+rbx*8]
  00127	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0012c	85 c0		 test	 eax, eax
  0012e	78 15		 js	 SHORT $fail$21222
  00130	74 06		 je	 SHORT $LN2@gallop_lef

; 1307 :             lastofs = m+1;              /* a[m] < key */

  00132	48 8d 73 01	 lea	 rsi, QWORD PTR [rbx+1]

; 1308 :         else

  00136	eb 03		 jmp	 SHORT $LN1@gallop_lef
$LN2@gallop_lef:

; 1309 :             ofs = m;                    /* key <= a[m] */

  00138	48 8b fb	 mov	 rdi, rbx
$LN1@gallop_lef:

; 1303 :     while (lastofs < ofs) {

  0013b	48 3b f7	 cmp	 rsi, rdi
  0013e	7c d0		 jl	 SHORT $LL5@gallop_lef
$LN4@gallop_lef:

; 1310 :     }
; 1311 :     assert(lastofs == ofs);             /* so a[ofs-1] < key <= a[ofs] */
; 1312 :     return ofs;

  00140	48 8b c7	 mov	 rax, rdi
  00143	eb 04		 jmp	 SHORT $LN22@gallop_lef
$fail$21222:

; 1313 : 
; 1314 : fail:
; 1315 :     return -1;

  00145	48 83 c8 ff	 or	 rax, -1
$LN22@gallop_lef:

; 1316 : }

  00149	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0014e	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00153	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00158	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0015d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00161	41 5e		 pop	 r14
  00163	41 5d		 pop	 r13
  00165	41 5c		 pop	 r12
  00167	c3		 ret	 0
gallop_left ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gallop_right DD imagerel gallop_right
	DD	imagerel gallop_right+360
	DD	imagerel $unwind$gallop_right
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gallop_right DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0e01a321eH
	DD	0c016d018H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gallop_right
_TEXT	SEGMENT
key$ = 64
a$ = 72
n$ = 80
hint$ = 88
gallop_right PROC					; COMDAT

; 1334 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1335 :     Py_ssize_t ofs;
; 1336 :     Py_ssize_t lastofs;
; 1337 :     Py_ssize_t k;
; 1338 : 
; 1339 :     assert(key && a && n > 0 && hint >= 0 && hint < n);
; 1340 : 
; 1341 :     a += hint;

  0001e	4e 8d 34 cd 00
	00 00 00	 lea	 r14, QWORD PTR [r9*8]
  00026	49 8b f8	 mov	 rdi, r8

; 1342 :     lastofs = 0;

  00029	33 f6		 xor	 esi, esi
  0002b	49 8d 2c 16	 lea	 rbp, QWORD PTR [r14+rdx]

; 1343 :     ofs = 1;
; 1344 :     IFLT(key, *a) {

  0002f	45 33 c0	 xor	 r8d, r8d
  00032	4d 8b e1	 mov	 r12, r9
  00035	48 8b 55 00	 mov	 rdx, QWORD PTR [rbp]
  00039	4c 8b e9	 mov	 r13, rcx
  0003c	8d 5e 01	 lea	 ebx, QWORD PTR [rsi+1]
  0003f	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00044	85 c0		 test	 eax, eax
  00046	0f 88 f9 00 00
	00		 js	 $fail$21266
  0004c	74 65		 je	 SHORT $LN20@gallop_rig

; 1345 :         /* key < a[hint] -- gallop left, until
; 1346 :          * a[hint - ofs] <= key < a[hint - lastofs]
; 1347 :          */
; 1348 :         const Py_ssize_t maxofs = hint + 1;             /* &a[0] is lowest */

  0004e	49 8d 7c 24 01	 lea	 rdi, QWORD PTR [r12+1]

; 1349 :         while (ofs < maxofs) {

  00053	48 3b df	 cmp	 rbx, rdi
  00056	7d 43		 jge	 SHORT $LN37@gallop_rig
  00058	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL19@gallop_rig:

; 1350 :             IFLT(key, *(a-ofs)) {

  00060	48 8d 04 dd 00
	00 00 00	 lea	 rax, QWORD PTR [rbx*8]
  00068	48 8b d5	 mov	 rdx, rbp
  0006b	45 33 c0	 xor	 r8d, r8d
  0006e	48 2b d0	 sub	 rdx, rax
  00071	49 8b cd	 mov	 rcx, r13
  00074	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00077	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0007c	85 c0		 test	 eax, eax
  0007e	0f 88 c1 00 00
	00		 js	 $fail$21266
  00084	74 12		 je	 SHORT $LN16@gallop_rig

; 1351 :                 lastofs = ofs;

  00086	48 8b f3	 mov	 rsi, rbx

; 1352 :                 ofs = (ofs << 1) + 1;

  00089	48 8d 5c 1b 01	 lea	 rbx, QWORD PTR [rbx+rbx+1]

; 1353 :                 if (ofs <= 0)                   /* int overflow */

  0008e	48 85 db	 test	 rbx, rbx
  00091	7e 0f		 jle	 SHORT $LN13@gallop_rig

; 1349 :         while (ofs < maxofs) {

  00093	48 3b df	 cmp	 rbx, rdi
  00096	7c c8		 jl	 SHORT $LL19@gallop_rig
$LN16@gallop_rig:

; 1354 :                     ofs = maxofs;
; 1355 :             }
; 1356 :             else                /* a[hint - ofs] <= key */
; 1357 :                 break;
; 1358 :         }
; 1359 :         if (ofs > maxofs)

  00098	48 3b df	 cmp	 rbx, rdi
$LN37@gallop_rig:
  0009b	48 0f 4f df	 cmovg	 rbx, rdi
  0009f	48 8b fb	 mov	 rdi, rbx
$LN13@gallop_rig:

; 1360 :             ofs = maxofs;
; 1361 :         /* Translate back to positive offsets relative to &a[0]. */
; 1362 :         k = lastofs;

  000a2	48 8b c6	 mov	 rax, rsi

; 1363 :         lastofs = hint - ofs;

  000a5	49 8b f4	 mov	 rsi, r12
  000a8	48 2b f7	 sub	 rsi, rdi

; 1364 :         ofs = hint - k;

  000ab	4c 2b e0	 sub	 r12, rax
  000ae	49 8b fc	 mov	 rdi, r12

; 1365 :     }
; 1366 :     else {

  000b1	eb 45		 jmp	 SHORT $LN12@gallop_rig
$LN20@gallop_rig:

; 1367 :         /* a[hint] <= key -- gallop right, until
; 1368 :          * a[hint + lastofs] <= key < a[hint + ofs]
; 1369 :         */
; 1370 :         const Py_ssize_t maxofs = n - hint;             /* &a[n-1] is highest */

  000b3	49 2b fc	 sub	 rdi, r12

; 1371 :         while (ofs < maxofs) {

  000b6	48 3b df	 cmp	 rbx, rdi
  000b9	7d 30		 jge	 SHORT $LN38@gallop_rig
  000bb	0f 1f 44 00 00	 npad	 5
$LL11@gallop_rig:

; 1372 :             IFLT(key, a[ofs])

  000c0	48 8b 54 dd 00	 mov	 rdx, QWORD PTR [rbp+rbx*8]
  000c5	45 33 c0	 xor	 r8d, r8d
  000c8	49 8b cd	 mov	 rcx, r13
  000cb	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  000d0	85 c0		 test	 eax, eax
  000d2	78 71		 js	 SHORT $fail$21266
  000d4	75 12		 jne	 SHORT $LN29@gallop_rig

; 1373 :                 break;
; 1374 :             /* a[hint + ofs] <= key */
; 1375 :             lastofs = ofs;

  000d6	48 8b f3	 mov	 rsi, rbx

; 1376 :             ofs = (ofs << 1) + 1;

  000d9	48 8d 5c 1b 01	 lea	 rbx, QWORD PTR [rbx+rbx+1]

; 1377 :             if (ofs <= 0)               /* int overflow */

  000de	48 85 db	 test	 rbx, rbx
  000e1	7e 0f		 jle	 SHORT $LN6@gallop_rig

; 1371 :         while (ofs < maxofs) {

  000e3	48 3b df	 cmp	 rbx, rdi
  000e6	7c d8		 jl	 SHORT $LL11@gallop_rig
$LN29@gallop_rig:

; 1378 :                 ofs = maxofs;
; 1379 :         }
; 1380 :         if (ofs > maxofs)

  000e8	48 3b df	 cmp	 rbx, rdi
$LN38@gallop_rig:
  000eb	48 0f 4f df	 cmovg	 rbx, rdi
  000ef	48 8b fb	 mov	 rdi, rbx
$LN6@gallop_rig:

; 1381 :             ofs = maxofs;
; 1382 :         /* Translate back to offsets relative to &a[0]. */
; 1383 :         lastofs += hint;

  000f2	49 03 f4	 add	 rsi, r12

; 1384 :         ofs += hint;

  000f5	49 03 fc	 add	 rdi, r12
$LN12@gallop_rig:

; 1385 :     }
; 1386 :     a -= hint;
; 1387 : 
; 1388 :     assert(-1 <= lastofs && lastofs < ofs && ofs <= n);
; 1389 :     /* Now a[lastofs] <= key < a[ofs], so key belongs somewhere to the
; 1390 :      * right of lastofs but no farther right than ofs.  Do a binary
; 1391 :      * search, with invariant a[lastofs-1] <= key < a[ofs].
; 1392 :      */
; 1393 :     ++lastofs;

  000f8	48 ff c6	 inc	 rsi
  000fb	49 2b ee	 sub	 rbp, r14

; 1394 :     while (lastofs < ofs) {

  000fe	48 3b f7	 cmp	 rsi, rdi
  00101	7d 3d		 jge	 SHORT $LN4@gallop_rig
  00103	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL5@gallop_rig:

; 1395 :         Py_ssize_t m = lastofs + ((ofs - lastofs) >> 1);

  00110	48 8b df	 mov	 rbx, rdi

; 1396 : 
; 1397 :         IFLT(key, a[m])

  00113	45 33 c0	 xor	 r8d, r8d
  00116	49 8b cd	 mov	 rcx, r13
  00119	48 2b de	 sub	 rbx, rsi
  0011c	48 d1 fb	 sar	 rbx, 1
  0011f	48 03 de	 add	 rbx, rsi
  00122	48 8b 54 dd 00	 mov	 rdx, QWORD PTR [rbp+rbx*8]
  00127	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0012c	85 c0		 test	 eax, eax
  0012e	78 15		 js	 SHORT $fail$21266
  00130	74 05		 je	 SHORT $LN2@gallop_rig

; 1398 :             ofs = m;                    /* key < a[m] */

  00132	48 8b fb	 mov	 rdi, rbx

; 1399 :         else

  00135	eb 04		 jmp	 SHORT $LN1@gallop_rig
$LN2@gallop_rig:

; 1400 :             lastofs = m+1;              /* a[m] <= key */

  00137	48 8d 73 01	 lea	 rsi, QWORD PTR [rbx+1]
$LN1@gallop_rig:

; 1394 :     while (lastofs < ofs) {

  0013b	48 3b f7	 cmp	 rsi, rdi
  0013e	7c d0		 jl	 SHORT $LL5@gallop_rig
$LN4@gallop_rig:

; 1401 :     }
; 1402 :     assert(lastofs == ofs);             /* so a[ofs-1] <= key < a[ofs] */
; 1403 :     return ofs;

  00140	48 8b c7	 mov	 rax, rdi
  00143	eb 04		 jmp	 SHORT $LN22@gallop_rig
$fail$21266:

; 1404 : 
; 1405 : fail:
; 1406 :     return -1;

  00145	48 83 c8 ff	 or	 rax, -1
$LN22@gallop_rig:

; 1407 : }

  00149	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0014e	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00153	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00158	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0015d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00161	41 5e		 pop	 r14
  00163	41 5d		 pop	 r13
  00165	41 5c		 pop	 r12
  00167	c3		 ret	 0
gallop_right ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT merge_init
_TEXT	SEGMENT
ms$ = 8
list_size$ = 16
has_keyfunc$ = 24
merge_init PROC						; COMDAT

; 1466 :     assert(ms != NULL);
; 1467 :     if (has_keyfunc) {

  00000	45 33 d2	 xor	 r10d, r10d
  00003	4c 8b c9	 mov	 r9, rcx
  00006	45 85 c0	 test	 r8d, r8d
  00009	74 2e		 je	 SHORT $LN3@merge_init

; 1468 :         /* The temporary space for merging will need at most half the list
; 1469 :          * size rounded up.  Use the minimum possible space so we can use the
; 1470 :          * rest of temparray for other things.  In particular, if there is
; 1471 :          * enough extra space, listsort() will use it to store the keys.
; 1472 :          */
; 1473 :         ms->alloced = (list_size + 1) / 2;

  0000b	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  0000f	48 99		 cdq
  00011	48 2b c2	 sub	 rax, rdx
  00014	48 d1 f8	 sar	 rax, 1
  00017	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1474 : 
; 1475 :         /* ms->alloced describes how many keys will be stored at
; 1476 :            ms->temparray, but we also need to store the values.  Hence,
; 1477 :            ms->alloced is capped at half of MERGESTATE_TEMP_SIZE. */
; 1478 :         if (MERGESTATE_TEMP_SIZE / 2 < ms->alloced)

  0001b	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00020	48 3b c1	 cmp	 rax, rcx
  00023	48 0f 4f c1	 cmovg	 rax, rcx
  00027	49 89 41 18	 mov	 QWORD PTR [r9+24], rax

; 1479 :             ms->alloced = MERGESTATE_TEMP_SIZE / 2;
; 1480 :         ms->a.values = &ms->temparray[ms->alloced];

  0002b	49 8d 8c c1 20
	08 00 00	 lea	 rcx, QWORD PTR [r9+rax*8+2080]
  00033	49 89 49 10	 mov	 QWORD PTR [r9+16], rcx

; 1481 :     }
; 1482 :     else {

  00037	eb 0c		 jmp	 SHORT $LN1@merge_init
$LN3@merge_init:

; 1483 :         ms->alloced = MERGESTATE_TEMP_SIZE;

  00039	48 c7 41 18 00
	01 00 00	 mov	 QWORD PTR [rcx+24], 256	; 00000100H

; 1484 :         ms->a.values = NULL;

  00041	4c 89 51 10	 mov	 QWORD PTR [rcx+16], r10
$LN1@merge_init:

; 1485 :     }
; 1486 :     ms->a.keys = ms->temparray;

  00045	49 8d 81 20 08
	00 00		 lea	 rax, QWORD PTR [r9+2080]

; 1487 :     ms->n = 0;

  0004c	45 89 51 20	 mov	 DWORD PTR [r9+32], r10d

; 1488 :     ms->min_gallop = MIN_GALLOP;

  00050	49 c7 01 07 00
	00 00		 mov	 QWORD PTR [r9], 7
  00057	49 89 41 08	 mov	 QWORD PTR [r9+8], rax

; 1489 : }

  0005b	c3		 ret	 0
merge_init ENDP
_TEXT	ENDS
EXTRN	PyMem_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$merge_freemem DD imagerel merge_freemem
	DD	imagerel merge_freemem+33
	DD	imagerel $unwind$merge_freemem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$merge_freemem DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT merge_freemem
_TEXT	SEGMENT
ms$ = 48
merge_freemem PROC					; COMDAT

; 1497 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1498 :     assert(ms != NULL);
; 1499 :     if (ms->a.keys != ms->temparray)

  00004	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00008	48 8d 81 20 08
	00 00		 lea	 rax, QWORD PTR [rcx+2080]
  0000f	48 3b d0	 cmp	 rdx, rax
  00012	74 08		 je	 SHORT $LN1@merge_free

; 1500 :         PyMem_Free(ms->a.keys);

  00014	48 8b ca	 mov	 rcx, rdx
  00017	e8 00 00 00 00	 call	 PyMem_Free
$LN1@merge_free:

; 1501 : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
merge_freemem ENDP
_TEXT	ENDS
EXTRN	PyMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$merge_getmem DD imagerel merge_getmem
	DD	imagerel merge_getmem+22
	DD	imagerel $unwind$merge_getmem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$merge_getmem DD imagerel merge_getmem+22
	DD	imagerel merge_getmem+71
	DD	imagerel $chain$0$merge_getmem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$merge_getmem DD imagerel merge_getmem+71
	DD	imagerel merge_getmem+144
	DD	imagerel $chain$1$merge_getmem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$merge_getmem DD 021H
	DD	imagerel merge_getmem
	DD	imagerel merge_getmem+22
	DD	imagerel $unwind$merge_getmem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$merge_getmem DD 020521H
	DD	063405H
	DD	imagerel merge_getmem
	DD	imagerel merge_getmem+22
	DD	imagerel $unwind$merge_getmem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$merge_getmem DD 040a01H
	DD	07640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT merge_getmem
_TEXT	SEGMENT
ms$ = 48
need$ = 56
merge_getmem PROC					; COMDAT

; 1508 : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f2	 mov	 rsi, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 1509 :     int multiplier;
; 1510 : 
; 1511 :     assert(ms != NULL);
; 1512 :     if (need <= ms->alloced)

  00010	48 3b 51 18	 cmp	 rdx, QWORD PTR [rcx+24]

; 1513 :         return 0;

  00014	7e 5a		 jle	 SHORT $LN1@merge_getm

; 1514 : 
; 1515 :     multiplier = ms->a.values != NULL ? 2 : 1;

  00016	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0001b	33 db		 xor	 ebx, ebx
  0001d	48 39 59 10	 cmp	 QWORD PTR [rcx+16], rbx
  00021	0f 95 c3	 setne	 bl
  00024	ff c3		 inc	 ebx

; 1516 : 
; 1517 :     /* Don't realloc!  That can cost cycles to copy the old data, but
; 1518 :      * we don't care what's in the block.
; 1519 :      */
; 1520 :     merge_freemem(ms);

  00026	e8 00 00 00 00	 call	 merge_freemem

; 1521 :     if ((size_t)need > PY_SSIZE_T_MAX / sizeof(PyObject*) / multiplier) {

  0002b	48 63 cb	 movsxd	 rcx, ebx
  0002e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00033	33 d2		 xor	 edx, edx
  00035	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  0003f	48 f7 f1	 div	 rcx
  00042	48 3b f0	 cmp	 rsi, rax

; 1522 :         PyErr_NoMemory();
; 1523 :         return -1;

  00045	77 36		 ja	 SHORT $LN2@merge_getm

; 1524 :     }
; 1525 :     ms->a.keys = (PyObject**)PyMem_Malloc(multiplier * need
; 1526 :                                           * sizeof(PyObject *));

  00047	48 0f af ce	 imul	 rcx, rsi
  0004b	48 c1 e1 03	 shl	 rcx, 3
  0004f	e8 00 00 00 00	 call	 PyMem_Malloc
  00054	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax

; 1527 :     if (ms->a.keys != NULL) {

  00058	48 85 c0	 test	 rax, rax
  0005b	74 20		 je	 SHORT $LN2@merge_getm

; 1528 :         ms->alloced = need;
; 1529 :         if (ms->a.values != NULL)

  0005d	48 83 7f 10 00	 cmp	 QWORD PTR [rdi+16], 0
  00062	48 89 77 18	 mov	 QWORD PTR [rdi+24], rsi
  00066	74 08		 je	 SHORT $LN1@merge_getm

; 1530 :             ms->a.values = &ms->a.keys[need];

  00068	48 8d 04 f0	 lea	 rax, QWORD PTR [rax+rsi*8]
  0006c	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
$LN1@merge_getm:

; 1531 :         return 0;

  00070	33 c0		 xor	 eax, eax

; 1534 :     return -1;
; 1535 : }

  00072	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
$LN2@merge_getm:

; 1532 :     }
; 1533 :     PyErr_NoMemory();

  0007d	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1534 :     return -1;
; 1535 : }

  00082	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00087	83 c8 ff	 or	 eax, -1
  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
merge_getmem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$merge_lo DD imagerel merge_lo
	DD	imagerel merge_lo+1021
	DD	imagerel $unwind$merge_lo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$merge_lo DD 0d6401H
	DD	08f464H
	DD	09c45aH
	DD	0a7449H
	DD	0113444H
	DD	0e00ba20fH
	DD	06007d009H
	DD	05006H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT merge_lo
_TEXT	SEGMENT
acount$2$ = 48
ms$ = 128
ssa$ = 136
min_gallop$1$ = 144
na$ = 144
ssb$ = 152
nb$ = 160
merge_lo PROC						; COMDAT

; 1548 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0000f	49 8b f1	 mov	 rsi, r9
  00012	4d 8b e8	 mov	 r13, r8
  00015	48 8b ea	 mov	 rbp, rdx
  00018	4c 8b f1	 mov	 r14, rcx

; 1549 :     Py_ssize_t k;
; 1550 :     sortslice dest;
; 1551 :     int result = -1;            /* guilty until proved innocent */
; 1552 :     Py_ssize_t min_gallop;
; 1553 : 
; 1554 :     assert(ms && ssa.keys && ssb.keys && na > 0 && nb > 0);
; 1555 :     assert(ssa.keys + na == ssb.keys);
; 1556 :     if (MERGE_GETMEM(ms, na) < 0)

  0001b	4c 3b 41 18	 cmp	 r8, QWORD PTR [rcx+24]
  0001f	7e 1b		 jle	 SHORT $LN27@merge_lo
  00021	49 8b d0	 mov	 rdx, r8
  00024	e8 00 00 00 00	 call	 merge_getmem
  00029	85 c0		 test	 eax, eax
  0002b	79 0f		 jns	 SHORT $LN27@merge_lo

; 1557 :         return -1;

  0002d	48 83 c8 ff	 or	 rax, -1

; 1669 : }

  00031	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00035	41 5e		 pop	 r14
  00037	41 5d		 pop	 r13
  00039	5e		 pop	 rsi
  0003a	5d		 pop	 rbp
  0003b	c3		 ret	 0
$LN27@merge_lo:
  0003c	48 89 9c 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbx
  00044	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi

; 1558 :     sortslice_memcpy(&ms->a, 0, &ssa, 0, na);

  00049	49 8d 4e 08	 lea	 rcx, QWORD PTR [r14+8]
  0004d	45 33 c9	 xor	 r9d, r9d
  00050	4c 8b c5	 mov	 r8, rbp
  00053	33 d2		 xor	 edx, edx
  00055	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  0005a	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  0005f	4c 89 7c 24 40	 mov	 QWORD PTR [rsp+64], r15
  00064	e8 00 00 00 00	 call	 sortslice_memcpy

; 1559 :     dest = ssa;
; 1560 :     ssa = ms->a;

  00069	49 8b 46 08	 mov	 rax, QWORD PTR [r14+8]
  0006d	4c 8b 65 00	 mov	 r12, QWORD PTR [rbp]
  00071	48 8b 7d 08	 mov	 rdi, QWORD PTR [rbp+8]
  00075	48 89 45 00	 mov	 QWORD PTR [rbp], rax
  00079	49 8b 46 10	 mov	 rax, QWORD PTR [r14+16]
  0007d	48 89 45 08	 mov	 QWORD PTR [rbp+8], rax

; 1561 : 
; 1562 :     sortslice_copy_incr(&dest, &ssb);

  00081	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00084	49 83 c4 08	 add	 r12, 8
  00088	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0008b	49 89 4c 24 f8	 mov	 QWORD PTR [r12-8], rcx
  00090	48 83 06 08	 add	 QWORD PTR [rsi], 8
  00094	48 85 ff	 test	 rdi, rdi
  00097	74 14		 je	 SHORT $LN32@merge_lo
  00099	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  0009d	48 83 c7 08	 add	 rdi, 8
  000a1	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000a4	48 89 4f f8	 mov	 QWORD PTR [rdi-8], rcx
  000a8	48 83 46 08 08	 add	 QWORD PTR [rsi+8], 8
$LN32@merge_lo:

; 1563 :     --nb;

  000ad	4c 8b bc 24 a0
	00 00 00	 mov	 r15, QWORD PTR nb$[rsp]
  000b5	49 ff cf	 dec	 r15

; 1564 :     if (nb == 0)

  000b8	0f 84 e6 02 00
	00		 je	 $Succeed$21370

; 1565 :         goto Succeed;
; 1566 :     if (na == 1)

  000be	49 83 fd 01	 cmp	 r13, 1
  000c2	0f 84 95 02 00
	00		 je	 $CopyB$21372

; 1567 :         goto CopyB;
; 1568 : 
; 1569 :     min_gallop = ms->min_gallop;

  000c8	49 8b 06	 mov	 rax, QWORD PTR [r14]
$LN101@merge_lo:

; 1570 :     for (;;) {
; 1571 :         Py_ssize_t acount = 0;          /* # of times A won in a row */

  000cb	33 db		 xor	 ebx, ebx
  000cd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR min_gallop$1$[rsp], rax

; 1572 :         Py_ssize_t bcount = 0;          /* # of times B won in a row */

  000d5	45 33 f6	 xor	 r14d, r14d
  000d8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL22@merge_lo:

; 1573 : 
; 1574 :         /* Do the straightforward thing until (if ever) one run
; 1575 :          * appears to win consistently.
; 1576 :          */
; 1577 :         for (;;) {
; 1578 :             assert(na > 1 && nb > 0);
; 1579 :             k = ISLT(ssb.keys[0], ssa.keys[0]);

  000e0	48 8b 55 00	 mov	 rdx, QWORD PTR [rbp]
  000e4	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  000e7	45 33 c0	 xor	 r8d, r8d
  000ea	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000ed	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000f0	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 1580 :             if (k) {

  000f5	85 c0		 test	 eax, eax
  000f7	74 4d		 je	 SHORT $LN20@merge_lo

; 1581 :                 if (k < 0)

  000f9	0f 88 a9 02 00
	00		 js	 $LN95@merge_lo

; 1582 :                     goto Fail;
; 1583 :                 sortslice_copy_incr(&dest, &ssb);

  000ff	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00102	49 83 c4 08	 add	 r12, 8
  00106	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00109	49 89 4c 24 f8	 mov	 QWORD PTR [r12-8], rcx
  0010e	48 83 06 08	 add	 QWORD PTR [rsi], 8
  00112	48 85 ff	 test	 rdi, rdi
  00115	74 14		 je	 SHORT $LN35@merge_lo
  00117	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  0011b	48 83 c7 08	 add	 rdi, 8
  0011f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00122	48 89 4f f8	 mov	 QWORD PTR [rdi-8], rcx
  00126	48 83 46 08 08	 add	 QWORD PTR [rsi+8], 8
$LN35@merge_lo:

; 1584 :                 ++bcount;

  0012b	49 ff c6	 inc	 r14

; 1585 :                 acount = 0;

  0012e	33 db		 xor	 ebx, ebx

; 1586 :                 --nb;

  00130	49 ff cf	 dec	 r15

; 1587 :                 if (nb == 0)

  00133	0f 84 6b 02 00
	00		 je	 $Succeed$21370

; 1588 :                     goto Succeed;
; 1589 :                 if (bcount >= min_gallop)

  00139	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR min_gallop$1$[rsp]
  00141	4c 3b f1	 cmp	 r14, rcx

; 1590 :                     break;
; 1591 :             }
; 1592 :             else {

  00144	eb 4c		 jmp	 SHORT $LN100@merge_lo
$LN20@merge_lo:

; 1593 :                 sortslice_copy_incr(&dest, &ssa);

  00146	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  0014a	49 83 c4 08	 add	 r12, 8
  0014e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00151	49 89 4c 24 f8	 mov	 QWORD PTR [r12-8], rcx
  00156	48 83 45 00 08	 add	 QWORD PTR [rbp], 8
  0015b	48 85 ff	 test	 rdi, rdi
  0015e	74 14		 je	 SHORT $LN38@merge_lo
  00160	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  00164	48 83 c7 08	 add	 rdi, 8
  00168	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0016b	48 89 4f f8	 mov	 QWORD PTR [rdi-8], rcx
  0016f	48 83 45 08 08	 add	 QWORD PTR [rbp+8], 8
$LN38@merge_lo:

; 1594 :                 ++acount;
; 1595 :                 bcount = 0;
; 1596 :                 --na;

  00174	49 ff cd	 dec	 r13
  00177	48 ff c3	 inc	 rbx
  0017a	45 33 f6	 xor	 r14d, r14d

; 1597 :                 if (na == 1)

  0017d	49 83 fd 01	 cmp	 r13, 1
  00181	0f 84 d6 01 00
	00		 je	 $CopyB$21372

; 1598 :                     goto CopyB;
; 1599 :                 if (acount >= min_gallop)

  00187	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR min_gallop$1$[rsp]
  0018f	48 3b d9	 cmp	 rbx, rcx
$LN100@merge_lo:

; 1600 :                     break;
; 1601 :             }
; 1602 :         }

  00192	0f 8c 48 ff ff
	ff		 jl	 $LL22@merge_lo

; 1603 : 
; 1604 :         /* One run is winning so consistently that galloping may
; 1605 :          * be a huge win.  So try that, and continue galloping until
; 1606 :          * (if ever) neither run appears to be winning consistently
; 1607 :          * anymore.
; 1608 :          */
; 1609 :         ++min_gallop;

  00198	48 ff c1	 inc	 rcx
  0019b	0f 1f 44 00 00	 npad	 5
$LL13@merge_lo:

; 1610 :         do {
; 1611 :             assert(na > 1 && nb > 0);
; 1612 :             min_gallop -= min_gallop > 1;

  001a0	33 c0		 xor	 eax, eax
  001a2	48 83 f9 01	 cmp	 rcx, 1

; 1613 :             ms->min_gallop = min_gallop;
; 1614 :             k = gallop_right(ssb.keys[0], ssa.keys, na, 0);

  001a6	4d 8b c5	 mov	 r8, r13
  001a9	0f 9f c0	 setg	 al
  001ac	45 33 c9	 xor	 r9d, r9d
  001af	48 2b c8	 sub	 rcx, rax
  001b2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  001ba	48 89 08	 mov	 QWORD PTR [rax], rcx
  001bd	48 8b 55 00	 mov	 rdx, QWORD PTR [rbp]
  001c1	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR min_gallop$1$[rsp], rcx
  001c9	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  001cc	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  001cf	e8 00 00 00 00	 call	 gallop_right
  001d4	4c 8b f0	 mov	 r14, rax
  001d7	48 89 44 24 30	 mov	 QWORD PTR acount$2$[rsp], rax

; 1615 :             acount = k;
; 1616 :             if (k) {

  001dc	48 85 c0	 test	 rax, rax
  001df	74 66		 je	 SHORT $LN7@merge_lo

; 1617 :                 if (k < 0)

  001e1	0f 88 c1 01 00
	00		 js	 $LN95@merge_lo

; 1618 :                     goto Fail;
; 1619 :                 sortslice_memcpy(&dest, 0, &ssa, 0, k);

  001e7	48 8b 55 00	 mov	 rdx, QWORD PTR [rbp]
  001eb	48 8d 1c c5 00
	00 00 00	 lea	 rbx, QWORD PTR [rax*8]
  001f3	49 8b cc	 mov	 rcx, r12
  001f6	4c 8b c3	 mov	 r8, rbx
  001f9	e8 00 00 00 00	 call	 memcpy
  001fe	48 85 ff	 test	 rdi, rdi
  00201	74 0f		 je	 SHORT $LN41@merge_lo
  00203	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
  00207	4c 8b c3	 mov	 r8, rbx
  0020a	48 8b cf	 mov	 rcx, rdi
  0020d	e8 00 00 00 00	 call	 memcpy
$LN41@merge_lo:

; 1620 :                 sortslice_advance(&dest, k);

  00212	4c 03 e3	 add	 r12, rbx
  00215	48 85 ff	 test	 rdi, rdi
  00218	74 03		 je	 SHORT $LN44@merge_lo
  0021a	48 03 fb	 add	 rdi, rbx
$LN44@merge_lo:

; 1621 :                 sortslice_advance(&ssa, k);

  0021d	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  00221	48 01 5d 00	 add	 QWORD PTR [rbp], rbx
  00225	48 85 c0	 test	 rax, rax
  00228	74 07		 je	 SHORT $LN47@merge_lo
  0022a	48 03 c3	 add	 rax, rbx
  0022d	48 89 45 08	 mov	 QWORD PTR [rbp+8], rax
$LN47@merge_lo:

; 1622 :                 na -= k;

  00231	4d 2b ee	 sub	 r13, r14

; 1623 :                 if (na == 1)

  00234	49 83 fd 01	 cmp	 r13, 1
  00238	0f 84 1f 01 00
	00		 je	 $CopyB$21372

; 1624 :                     goto CopyB;
; 1625 :                 /* na==0 is impossible now if the comparison
; 1626 :                  * function is consistent, but we can't assume
; 1627 :                  * that it is.
; 1628 :                  */
; 1629 :                 if (na == 0)

  0023e	4d 85 ed	 test	 r13, r13
  00241	0f 84 5d 01 00
	00		 je	 $Succeed$21370
$LN7@merge_lo:

; 1630 :                     goto Succeed;
; 1631 :             }
; 1632 :             sortslice_copy_incr(&dest, &ssb);

  00247	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0024a	49 83 c4 08	 add	 r12, 8
  0024e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00251	49 89 4c 24 f8	 mov	 QWORD PTR [r12-8], rcx
  00256	48 83 06 08	 add	 QWORD PTR [rsi], 8
  0025a	48 85 ff	 test	 rdi, rdi
  0025d	74 14		 je	 SHORT $LN50@merge_lo
  0025f	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  00263	48 83 c7 08	 add	 rdi, 8
  00267	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0026a	48 89 4f f8	 mov	 QWORD PTR [rdi-8], rcx
  0026e	48 83 46 08 08	 add	 QWORD PTR [rsi+8], 8
$LN50@merge_lo:

; 1633 :             --nb;

  00273	49 ff cf	 dec	 r15

; 1634 :             if (nb == 0)

  00276	0f 84 28 01 00
	00		 je	 $Succeed$21370

; 1635 :                 goto Succeed;
; 1636 : 
; 1637 :             k = gallop_left(ssa.keys[0], ssb.keys, nb, 0);

  0027c	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
  00280	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00283	45 33 c9	 xor	 r9d, r9d
  00286	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00289	4d 8b c7	 mov	 r8, r15
  0028c	e8 00 00 00 00	 call	 gallop_left
  00291	4c 8b f0	 mov	 r14, rax

; 1638 :             bcount = k;
; 1639 :             if (k) {

  00294	48 85 c0	 test	 rax, rax
  00297	74 59		 je	 SHORT $LN3@merge_lo

; 1640 :                 if (k < 0)

  00299	0f 88 09 01 00
	00		 js	 $LN95@merge_lo

; 1641 :                     goto Fail;
; 1642 :                 sortslice_memmove(&dest, 0, &ssb, 0, k);

  0029f	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  002a2	48 8d 1c c5 00
	00 00 00	 lea	 rbx, QWORD PTR [rax*8]
  002aa	49 8b cc	 mov	 rcx, r12
  002ad	4c 8b c3	 mov	 r8, rbx
  002b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
  002b6	48 85 ff	 test	 rdi, rdi
  002b9	74 10		 je	 SHORT $LN53@merge_lo
  002bb	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  002bf	4c 8b c3	 mov	 r8, rbx
  002c2	48 8b cf	 mov	 rcx, rdi
  002c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN53@merge_lo:

; 1643 :                 sortslice_advance(&dest, k);

  002cb	4c 03 e3	 add	 r12, rbx
  002ce	48 85 ff	 test	 rdi, rdi
  002d1	74 03		 je	 SHORT $LN56@merge_lo
  002d3	48 03 fb	 add	 rdi, rbx
$LN56@merge_lo:

; 1644 :                 sortslice_advance(&ssb, k);

  002d6	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  002da	48 01 1e	 add	 QWORD PTR [rsi], rbx
  002dd	48 85 c0	 test	 rax, rax
  002e0	74 07		 je	 SHORT $LN59@merge_lo
  002e2	48 03 c3	 add	 rax, rbx
  002e5	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax
$LN59@merge_lo:

; 1645 :                 nb -= k;

  002e9	4d 2b fe	 sub	 r15, r14

; 1646 :                 if (nb == 0)

  002ec	0f 84 b2 00 00
	00		 je	 $Succeed$21370
$LN3@merge_lo:

; 1647 :                     goto Succeed;
; 1648 :             }
; 1649 :             sortslice_copy_incr(&dest, &ssa);

  002f2	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  002f6	49 83 c4 08	 add	 r12, 8
  002fa	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002fd	49 89 4c 24 f8	 mov	 QWORD PTR [r12-8], rcx
  00302	48 83 45 00 08	 add	 QWORD PTR [rbp], 8
  00307	48 85 ff	 test	 rdi, rdi
  0030a	74 14		 je	 SHORT $LN62@merge_lo
  0030c	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  00310	48 83 c7 08	 add	 rdi, 8
  00314	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00317	48 89 4f f8	 mov	 QWORD PTR [rdi-8], rcx
  0031b	48 83 45 08 08	 add	 QWORD PTR [rbp+8], 8
$LN62@merge_lo:

; 1650 :             --na;

  00320	49 ff cd	 dec	 r13

; 1651 :             if (na == 1)

  00323	49 83 fd 01	 cmp	 r13, 1
  00327	74 34		 je	 SHORT $CopyB$21372

; 1652 :                 goto CopyB;
; 1653 :         } while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);

  00329	48 83 7c 24 30
	07		 cmp	 QWORD PTR acount$2$[rsp], 7
  0032f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR min_gallop$1$[rsp]
  00337	0f 8d 63 fe ff
	ff		 jge	 $LL13@merge_lo
  0033d	49 83 fe 07	 cmp	 r14, 7
  00341	0f 8d 59 fe ff
	ff		 jge	 $LL13@merge_lo

; 1654 :         ++min_gallop;           /* penalize it for leaving galloping mode */

  00347	48 8b c1	 mov	 rax, rcx

; 1655 :         ms->min_gallop = min_gallop;

  0034a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ms$[rsp]
  00352	48 ff c0	 inc	 rax
  00355	48 89 01	 mov	 QWORD PTR [rcx], rax
  00358	e9 6e fd ff ff	 jmp	 $LN101@merge_lo
$CopyB$21372:

; 1663 : CopyB:
; 1664 :     assert(na == 1 && nb > 0);
; 1665 :     /* The last element of ssa belongs at the end of the merge. */
; 1666 :     sortslice_memmove(&dest, 0, &ssb, 0, nb);

  0035d	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00360	49 c1 e7 03	 shl	 r15, 3
  00364	49 8b cc	 mov	 rcx, r12
  00367	4d 8b c7	 mov	 r8, r15
  0036a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
  00370	48 85 ff	 test	 rdi, rdi
  00373	74 10		 je	 SHORT $LN68@merge_lo
  00375	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  00379	4d 8b c7	 mov	 r8, r15
  0037c	48 8b cf	 mov	 rcx, rdi
  0037f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN68@merge_lo:

; 1667 :     sortslice_copy(&dest, nb, &ssa, 0);

  00385	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  00389	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0038c	4b 89 0c 27	 mov	 QWORD PTR [r15+r12], rcx
  00390	48 85 ff	 test	 rdi, rdi
  00393	74 0b		 je	 SHORT $LN71@merge_lo
  00395	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  00399	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0039c	49 89 0c 3f	 mov	 QWORD PTR [r15+rdi], rcx
$LN71@merge_lo:

; 1668 :     return 0;

  003a0	33 c0		 xor	 eax, eax
  003a2	eb 37		 jmp	 SHORT $LN99@merge_lo
$Succeed$21370:

; 1656 :     }
; 1657 : Succeed:
; 1658 :     result = 0;

  003a4	33 db		 xor	 ebx, ebx

; 1548 : {

  003a6	eb 04		 jmp	 SHORT $Fail$21384
$LN95@merge_lo:

; 1656 :     }
; 1657 : Succeed:
; 1658 :     result = 0;

  003a8	48 83 cb ff	 or	 rbx, -1
$Fail$21384:

; 1659 : Fail:
; 1660 :     if (na)

  003ac	4d 85 ed	 test	 r13, r13
  003af	74 27		 je	 SHORT $LN65@merge_lo

; 1661 :         sortslice_memcpy(&dest, 0, &ssa, 0, na);

  003b1	48 8b 55 00	 mov	 rdx, QWORD PTR [rbp]
  003b5	49 c1 e5 03	 shl	 r13, 3
  003b9	49 8b cc	 mov	 rcx, r12
  003bc	4d 8b c5	 mov	 r8, r13
  003bf	e8 00 00 00 00	 call	 memcpy
  003c4	48 85 ff	 test	 rdi, rdi
  003c7	74 0f		 je	 SHORT $LN65@merge_lo
  003c9	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
  003cd	4d 8b c5	 mov	 r8, r13
  003d0	48 8b cf	 mov	 rcx, rdi
  003d3	e8 00 00 00 00	 call	 memcpy
$LN65@merge_lo:

; 1662 :     return result;

  003d8	48 63 c3	 movsxd	 rax, ebx
$LN99@merge_lo:
  003db	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  003e0	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  003e5	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR [rsp+136]
  003ed	4c 8b 7c 24 40	 mov	 r15, QWORD PTR [rsp+64]

; 1669 : }

  003f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003f6	41 5e		 pop	 r14
  003f8	41 5d		 pop	 r13
  003fa	5e		 pop	 rsi
  003fb	5d		 pop	 rbp
  003fc	c3		 ret	 0
merge_lo ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$merge_hi DD imagerel merge_hi
	DD	imagerel merge_hi+1298
	DD	imagerel $unwind$merge_hi
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$merge_hi DD 0c6401H
	DD	015c464H
	DD	0147458H
	DD	0133450H
	DD	0f00db211H
	DD	0d009e00bH
	DD	050066007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT merge_hi
_TEXT	SEGMENT
min_gallop$1$ = 48
baseb$1$ = 56
basea$1$ = 64
baseb$2$ = 72
basea$ = 72
ms$ = 144
ssa$ = 152
na$ = 160
ssb$ = 168
na$2$ = 176
nb$ = 176
merge_hi PROC						; COMDAT

; 1680 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 1681 :     Py_ssize_t k;
; 1682 :     sortslice dest, basea, baseb;
; 1683 :     int result = -1;            /* guilty until proved innocent */
; 1684 :     Py_ssize_t min_gallop;
; 1685 : 
; 1686 :     assert(ms && ssa.keys && ssb.keys && na > 0 && nb > 0);
; 1687 :     assert(ssa.keys + na == ssb.keys);
; 1688 :     if (MERGE_GETMEM(ms, nb) < 0)

  00011	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR nb$[rsp]
  00019	49 8b e9	 mov	 rbp, r9
  0001c	4d 8b f0	 mov	 r14, r8
  0001f	48 8b f2	 mov	 rsi, rdx
  00022	4c 8b f9	 mov	 r15, rcx
  00025	4c 3b 69 18	 cmp	 r13, QWORD PTR [rcx+24]
  00029	7e 1d		 jle	 SHORT $LN28@merge_hi
  0002b	49 8b d5	 mov	 rdx, r13
  0002e	e8 00 00 00 00	 call	 merge_getmem
  00033	85 c0		 test	 eax, eax
  00035	79 11		 jns	 SHORT $LN28@merge_hi

; 1689 :         return -1;

  00037	48 83 c8 ff	 or	 rax, -1

; 1811 : }

  0003b	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0003f	41 5f		 pop	 r15
  00041	41 5e		 pop	 r14
  00043	41 5d		 pop	 r13
  00045	5e		 pop	 rsi
  00046	5d		 pop	 rbp
  00047	c3		 ret	 0
$LN28@merge_hi:
  00048	48 89 9c 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rbx
  00050	48 89 bc 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rdi

; 1690 :     dest = ssb;

  00058	48 8b 7d 08	 mov	 rdi, QWORD PTR [rbp+8]
  0005c	4c 89 a4 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], r12
  00064	4c 8b 65 00	 mov	 r12, QWORD PTR [rbp]

; 1691 :     sortslice_advance(&dest, nb-1);

  00068	4a 8d 04 ed f8
	ff ff ff	 lea	 rax, QWORD PTR [r13*8-8]
  00070	4c 03 e0	 add	 r12, rax
  00073	48 85 ff	 test	 rdi, rdi
  00076	74 03		 je	 SHORT $LN33@merge_hi
  00078	48 03 f8	 add	 rdi, rax
$LN33@merge_hi:

; 1692 :     sortslice_memcpy(&ms->a, 0, &ssb, 0, nb);

  0007b	49 8d 4f 08	 lea	 rcx, QWORD PTR [r15+8]
  0007f	45 33 c9	 xor	 r9d, r9d
  00082	4c 8b c5	 mov	 r8, rbp
  00085	33 d2		 xor	 edx, edx
  00087	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  0008c	e8 00 00 00 00	 call	 sortslice_memcpy

; 1694 :     baseb = ms->a;
; 1695 :     ssb.keys = ms->a.keys + nb - 1;
; 1696 :     if (ssb.values != NULL)

  00091	48 83 7d 08 00	 cmp	 QWORD PTR [rbp+8], 0
  00096	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00099	48 89 44 24 40	 mov	 QWORD PTR basea$1$[rsp], rax
  0009e	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  000a2	48 89 44 24 50	 mov	 QWORD PTR basea$[rsp+8], rax
  000a7	49 8b 47 08	 mov	 rax, QWORD PTR [r15+8]
  000ab	48 89 44 24 38	 mov	 QWORD PTR baseb$1$[rsp], rax
  000b0	49 8b 47 10	 mov	 rax, QWORD PTR [r15+16]
  000b4	48 89 44 24 48	 mov	 QWORD PTR baseb$2$[rsp], rax
  000b9	49 8b 47 08	 mov	 rax, QWORD PTR [r15+8]
  000bd	4a 8d 4c e8 f8	 lea	 rcx, QWORD PTR [rax+r13*8-8]
  000c2	48 89 4d 00	 mov	 QWORD PTR [rbp], rcx
  000c6	74 0d		 je	 SHORT $LN27@merge_hi

; 1697 :         ssb.values = ms->a.values + nb - 1;

  000c8	49 8b 47 10	 mov	 rax, QWORD PTR [r15+16]
  000cc	4a 8d 4c e8 f8	 lea	 rcx, QWORD PTR [rax+r13*8-8]
  000d1	48 89 4d 08	 mov	 QWORD PTR [rbp+8], rcx
$LN27@merge_hi:

; 1698 :     sortslice_advance(&ssa, na - 1);

  000d5	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  000d9	49 ff ce	 dec	 r14
  000dc	4a 8d 04 f5 00
	00 00 00	 lea	 rax, QWORD PTR [r14*8]
  000e4	4c 89 b4 24 b0
	00 00 00	 mov	 QWORD PTR na$2$[rsp], r14
  000ec	48 01 06	 add	 QWORD PTR [rsi], rax
  000ef	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  000f2	48 85 c9	 test	 rcx, rcx
  000f5	74 07		 je	 SHORT $LN36@merge_hi
  000f7	48 03 c1	 add	 rax, rcx
  000fa	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax
$LN36@merge_hi:

; 1699 : 
; 1700 :     sortslice_copy_decr(&dest, &ssa);

  000fe	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00101	49 83 ec 08	 sub	 r12, 8
  00105	49 89 44 24 08	 mov	 QWORD PTR [r12+8], rax
  0010a	48 83 06 f8	 add	 QWORD PTR [rsi], -8
  0010e	48 85 ff	 test	 rdi, rdi
  00111	74 14		 je	 SHORT $LN39@merge_hi
  00113	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  00117	48 83 ef 08	 sub	 rdi, 8
  0011b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0011e	48 89 4f 08	 mov	 QWORD PTR [rdi+8], rcx
  00122	48 83 46 08 f8	 add	 QWORD PTR [rsi+8], -8
$LN39@merge_hi:

; 1701 :     --na;
; 1702 :     if (na == 0)

  00127	4d 85 f6	 test	 r14, r14
  0012a	0f 84 7a 03 00
	00		 je	 $Succeed$21429

; 1703 :         goto Succeed;
; 1704 :     if (nb == 1)

  00130	49 83 fd 01	 cmp	 r13, 1
  00134	0f 84 eb 02 00
	00		 je	 $CopyA$21431

; 1705 :         goto CopyA;
; 1706 : 
; 1707 :     min_gallop = ms->min_gallop;

  0013a	49 8b 07	 mov	 rax, QWORD PTR [r15]
$LN115@merge_hi:
  0013d	4c 8b bc 24 b0
	00 00 00	 mov	 r15, QWORD PTR na$2$[rsp]

; 1708 :     for (;;) {
; 1709 :         Py_ssize_t acount = 0;          /* # of times A won in a row */

  00145	45 33 f6	 xor	 r14d, r14d
  00148	48 89 44 24 30	 mov	 QWORD PTR min_gallop$1$[rsp], rax

; 1710 :         Py_ssize_t bcount = 0;          /* # of times B won in a row */

  0014d	33 db		 xor	 ebx, ebx
  0014f	90		 npad	 1
$LL22@merge_hi:

; 1711 : 
; 1712 :         /* Do the straightforward thing until (if ever) one run
; 1713 :          * appears to win consistently.
; 1714 :          */
; 1715 :         for (;;) {
; 1716 :             assert(na > 0 && nb > 1);
; 1717 :             k = ISLT(ssb.keys[0], ssa.keys[0]);

  00150	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00153	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
  00157	45 33 c0	 xor	 r8d, r8d
  0015a	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0015d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00160	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 1718 :             if (k) {

  00165	85 c0		 test	 eax, eax
  00167	74 52		 je	 SHORT $LN20@merge_hi

; 1719 :                 if (k < 0)

  00169	0f 88 3f 03 00
	00		 js	 $LN110@merge_hi

; 1720 :                     goto Fail;
; 1721 :                 sortslice_copy_decr(&dest, &ssa);

  0016f	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00172	49 83 ec 08	 sub	 r12, 8
  00176	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00179	49 89 4c 24 08	 mov	 QWORD PTR [r12+8], rcx
  0017e	48 83 06 f8	 add	 QWORD PTR [rsi], -8
  00182	48 85 ff	 test	 rdi, rdi
  00185	74 14		 je	 SHORT $LN42@merge_hi
  00187	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  0018b	48 83 ef 08	 sub	 rdi, 8
  0018f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00192	48 89 4f 08	 mov	 QWORD PTR [rdi+8], rcx
  00196	48 83 46 08 f8	 add	 QWORD PTR [rsi+8], -8
$LN42@merge_hi:

; 1722 :                 ++acount;

  0019b	49 ff c6	 inc	 r14

; 1723 :                 bcount = 0;

  0019e	33 db		 xor	 ebx, ebx

; 1724 :                 --na;

  001a0	49 ff cf	 dec	 r15
  001a3	4c 89 bc 24 b0
	00 00 00	 mov	 QWORD PTR na$2$[rsp], r15

; 1725 :                 if (na == 0)

  001ab	0f 84 f9 02 00
	00		 je	 $Succeed$21429

; 1726 :                     goto Succeed;
; 1727 :                 if (acount >= min_gallop)

  001b1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR min_gallop$1$[rsp]
  001b6	4c 3b f1	 cmp	 r14, rcx

; 1728 :                     break;
; 1729 :             }
; 1730 :             else {

  001b9	eb 49		 jmp	 SHORT $LN114@merge_hi
$LN20@merge_hi:

; 1731 :                 sortslice_copy_decr(&dest, &ssb);

  001bb	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  001bf	49 83 ec 08	 sub	 r12, 8
  001c3	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001c6	49 89 4c 24 08	 mov	 QWORD PTR [r12+8], rcx
  001cb	48 83 45 00 f8	 add	 QWORD PTR [rbp], -8
  001d0	48 85 ff	 test	 rdi, rdi
  001d3	74 14		 je	 SHORT $LN45@merge_hi
  001d5	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  001d9	48 83 ef 08	 sub	 rdi, 8
  001dd	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001e0	48 89 4f 08	 mov	 QWORD PTR [rdi+8], rcx
  001e4	48 83 45 08 f8	 add	 QWORD PTR [rbp+8], -8
$LN45@merge_hi:

; 1732 :                 ++bcount;
; 1733 :                 acount = 0;
; 1734 :                 --nb;

  001e9	49 ff cd	 dec	 r13
  001ec	48 ff c3	 inc	 rbx
  001ef	45 33 f6	 xor	 r14d, r14d

; 1735 :                 if (nb == 1)

  001f2	49 83 fd 01	 cmp	 r13, 1
  001f6	0f 84 21 02 00
	00		 je	 $LN107@merge_hi

; 1736 :                     goto CopyA;
; 1737 :                 if (bcount >= min_gallop)

  001fc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR min_gallop$1$[rsp]
  00201	48 3b d9	 cmp	 rbx, rcx
$LN114@merge_hi:

; 1738 :                     break;
; 1739 :             }
; 1740 :         }

  00204	0f 8c 46 ff ff
	ff		 jl	 $LL22@merge_hi

; 1741 : 
; 1742 :         /* One run is winning so consistently that galloping may
; 1743 :          * be a huge win.  So try that, and continue galloping until
; 1744 :          * (if ever) neither run appears to be winning consistently
; 1745 :          * anymore.
; 1746 :          */
; 1747 :         ++min_gallop;

  0020a	4c 8b b4 24 b0
	00 00 00	 mov	 r14, QWORD PTR na$2$[rsp]
  00212	48 ff c1	 inc	 rcx
  00215	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL13@merge_hi:

; 1748 :         do {
; 1749 :             assert(na > 0 && nb > 1);
; 1750 :             min_gallop -= min_gallop > 1;
; 1751 :             ms->min_gallop = min_gallop;
; 1752 :             k = gallop_right(ssb.keys[0], basea.keys, na, na-1);

  00220	48 8b 54 24 40	 mov	 rdx, QWORD PTR basea$1$[rsp]
  00225	33 c0		 xor	 eax, eax
  00227	48 83 f9 01	 cmp	 rcx, 1
  0022b	0f 9f c0	 setg	 al
  0022e	4d 8d 4e ff	 lea	 r9, QWORD PTR [r14-1]
  00232	4d 8b c6	 mov	 r8, r14
  00235	48 2b c8	 sub	 rcx, rax
  00238	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ms$[rsp]
  00240	48 89 08	 mov	 QWORD PTR [rax], rcx
  00243	48 89 4c 24 30	 mov	 QWORD PTR min_gallop$1$[rsp], rcx
  00248	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
  0024c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0024f	e8 00 00 00 00	 call	 gallop_right

; 1753 :             if (k < 0)

  00254	48 85 c0	 test	 rax, rax
  00257	0f 88 51 02 00
	00		 js	 $LN110@merge_hi

; 1754 :                 goto Fail;
; 1755 :             k = na - k;

  0025d	4d 8b fe	 mov	 r15, r14
  00260	4c 2b f8	 sub	 r15, rax

; 1756 :             acount = k;
; 1757 :             if (k) {

  00263	74 70		 je	 SHORT $LN8@merge_hi

; 1758 :                 sortslice_advance(&dest, -k);

  00265	49 8b c7	 mov	 rax, r15
  00268	48 f7 d8	 neg	 rax
  0026b	48 c1 e0 03	 shl	 rax, 3
  0026f	4c 03 e0	 add	 r12, rax
  00272	48 85 ff	 test	 rdi, rdi
  00275	74 03		 je	 SHORT $LN48@merge_hi
  00277	48 03 f8	 add	 rdi, rax
$LN48@merge_hi:

; 1759 :                 sortslice_advance(&ssa, -k);

  0027a	48 01 06	 add	 QWORD PTR [rsi], rax
  0027d	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  00281	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00284	48 85 c9	 test	 rcx, rcx
  00287	74 07		 je	 SHORT $LN51@merge_hi
  00289	48 03 c1	 add	 rax, rcx
  0028c	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax
$LN51@merge_hi:

; 1760 :                 sortslice_memmove(&dest, 1, &ssa, 1, k);

  00290	4a 8d 1c fd 00
	00 00 00	 lea	 rbx, QWORD PTR [r15*8]
  00298	49 8d 4c 24 08	 lea	 rcx, QWORD PTR [r12+8]
  0029d	48 83 c2 08	 add	 rdx, 8
  002a1	4c 8b c3	 mov	 r8, rbx
  002a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
  002aa	48 85 ff	 test	 rdi, rdi
  002ad	74 15		 je	 SHORT $LN54@merge_hi
  002af	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  002b3	48 8d 4f 08	 lea	 rcx, QWORD PTR [rdi+8]
  002b7	4c 8b c3	 mov	 r8, rbx
  002ba	48 83 c2 08	 add	 rdx, 8
  002be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN54@merge_hi:

; 1761 :                 na -= k;

  002c4	4d 2b f7	 sub	 r14, r15
  002c7	4c 89 b4 24 b0
	00 00 00	 mov	 QWORD PTR na$2$[rsp], r14

; 1762 :                 if (na == 0)

  002cf	0f 84 d5 01 00
	00		 je	 $Succeed$21429
$LN8@merge_hi:

; 1763 :                     goto Succeed;
; 1764 :             }
; 1765 :             sortslice_copy_decr(&dest, &ssb);

  002d5	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  002d9	49 83 ec 08	 sub	 r12, 8
  002dd	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002e0	49 89 4c 24 08	 mov	 QWORD PTR [r12+8], rcx
  002e5	48 83 45 00 f8	 add	 QWORD PTR [rbp], -8
  002ea	48 85 ff	 test	 rdi, rdi
  002ed	74 14		 je	 SHORT $LN57@merge_hi
  002ef	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  002f3	48 83 ef 08	 sub	 rdi, 8
  002f7	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002fa	48 89 4f 08	 mov	 QWORD PTR [rdi+8], rcx
  002fe	48 83 45 08 f8	 add	 QWORD PTR [rbp+8], -8
$LN57@merge_hi:

; 1766 :             --nb;

  00303	49 ff cd	 dec	 r13

; 1767 :             if (nb == 1)

  00306	49 83 fd 01	 cmp	 r13, 1
  0030a	0f 84 15 01 00
	00		 je	 $CopyA$21431

; 1768 :                 goto CopyA;
; 1769 : 
; 1770 :             k = gallop_left(ssa.keys[0], baseb.keys, nb, nb-1);

  00310	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00313	48 8b 54 24 38	 mov	 rdx, QWORD PTR baseb$1$[rsp]
  00318	4d 8d 4d ff	 lea	 r9, QWORD PTR [r13-1]
  0031c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0031f	4d 8b c5	 mov	 r8, r13
  00322	e8 00 00 00 00	 call	 gallop_left

; 1771 :             if (k < 0)

  00327	48 85 c0	 test	 rax, rax
  0032a	0f 88 7e 01 00
	00		 js	 $LN110@merge_hi

; 1772 :                 goto Fail;
; 1773 :             k = nb - k;

  00330	49 8b dd	 mov	 rbx, r13
  00333	48 2b d8	 sub	 rbx, rax

; 1774 :             bcount = k;
; 1775 :             if (k) {

  00336	74 79		 je	 SHORT $LN3@merge_hi

; 1776 :                 sortslice_advance(&dest, -k);

  00338	48 8b c3	 mov	 rax, rbx
  0033b	48 f7 d8	 neg	 rax
  0033e	48 c1 e0 03	 shl	 rax, 3
  00342	4c 03 e0	 add	 r12, rax
  00345	48 85 ff	 test	 rdi, rdi
  00348	74 03		 je	 SHORT $LN60@merge_hi
  0034a	48 03 f8	 add	 rdi, rax
$LN60@merge_hi:

; 1777 :                 sortslice_advance(&ssb, -k);

  0034d	48 01 45 00	 add	 QWORD PTR [rbp], rax
  00351	48 8b 4d 08	 mov	 rcx, QWORD PTR [rbp+8]
  00355	48 8b 55 00	 mov	 rdx, QWORD PTR [rbp]
  00359	48 85 c9	 test	 rcx, rcx
  0035c	74 07		 je	 SHORT $LN63@merge_hi
  0035e	48 03 c1	 add	 rax, rcx
  00361	48 89 45 08	 mov	 QWORD PTR [rbp+8], rax
$LN63@merge_hi:

; 1778 :                 sortslice_memcpy(&dest, 1, &ssb, 1, k);

  00365	4c 8d 34 dd 00
	00 00 00	 lea	 r14, QWORD PTR [rbx*8]
  0036d	49 8d 4c 24 08	 lea	 rcx, QWORD PTR [r12+8]
  00372	48 83 c2 08	 add	 rdx, 8
  00376	4d 8b c6	 mov	 r8, r14
  00379	e8 00 00 00 00	 call	 memcpy
  0037e	48 85 ff	 test	 rdi, rdi
  00381	74 14		 je	 SHORT $LN66@merge_hi
  00383	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
  00387	48 8d 4f 08	 lea	 rcx, QWORD PTR [rdi+8]
  0038b	4d 8b c6	 mov	 r8, r14
  0038e	48 83 c2 08	 add	 rdx, 8
  00392	e8 00 00 00 00	 call	 memcpy
$LN66@merge_hi:

; 1779 :                 nb -= k;

  00397	4c 2b eb	 sub	 r13, rbx

; 1780 :                 if (nb == 1)

  0039a	49 83 fd 01	 cmp	 r13, 1
  0039e	74 7d		 je	 SHORT $LN107@merge_hi

; 1781 :                     goto CopyA;
; 1782 :                 /* nb==0 is impossible now if the comparison
; 1783 :                  * function is consistent, but we can't assume
; 1784 :                  * that it is.
; 1785 :                  */
; 1786 :                 if (nb == 0)

  003a0	4d 85 ed	 test	 r13, r13
  003a3	0f 84 01 01 00
	00		 je	 $Succeed$21429
  003a9	4c 8b b4 24 b0
	00 00 00	 mov	 r14, QWORD PTR na$2$[rsp]
$LN3@merge_hi:

; 1787 :                     goto Succeed;
; 1788 :             }
; 1789 :             sortslice_copy_decr(&dest, &ssa);

  003b1	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  003b4	49 83 ec 08	 sub	 r12, 8
  003b8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  003bb	49 89 4c 24 08	 mov	 QWORD PTR [r12+8], rcx
  003c0	48 83 06 f8	 add	 QWORD PTR [rsi], -8
  003c4	48 85 ff	 test	 rdi, rdi
  003c7	74 14		 je	 SHORT $LN69@merge_hi
  003c9	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  003cd	48 83 ef 08	 sub	 rdi, 8
  003d1	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  003d4	48 89 4f 08	 mov	 QWORD PTR [rdi+8], rcx
  003d8	48 83 46 08 f8	 add	 QWORD PTR [rsi+8], -8
$LN69@merge_hi:

; 1790 :             --na;

  003dd	49 ff ce	 dec	 r14
  003e0	4c 89 b4 24 b0
	00 00 00	 mov	 QWORD PTR na$2$[rsp], r14

; 1791 :             if (na == 0)

  003e8	0f 84 bc 00 00
	00		 je	 $Succeed$21429

; 1792 :                 goto Succeed;
; 1793 :         } while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);

  003ee	48 8b 4c 24 30	 mov	 rcx, QWORD PTR min_gallop$1$[rsp]
  003f3	49 83 ff 07	 cmp	 r15, 7
  003f7	0f 8d 23 fe ff
	ff		 jge	 $LL13@merge_hi
  003fd	48 83 fb 07	 cmp	 rbx, 7
  00401	0f 8d 19 fe ff
	ff		 jge	 $LL13@merge_hi

; 1794 :         ++min_gallop;           /* penalize it for leaving galloping mode */

  00407	48 8b c1	 mov	 rax, rcx

; 1795 :         ms->min_gallop = min_gallop;

  0040a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ms$[rsp]
  00412	48 ff c0	 inc	 rax
  00415	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1810 :     return 0;

  00418	e9 20 fd ff ff	 jmp	 $LN115@merge_hi
$LN107@merge_hi:

; 1790 :             --na;

  0041d	4c 8b b4 24 b0
	00 00 00	 mov	 r14, QWORD PTR na$2$[rsp]
$CopyA$21431:

; 1803 : CopyA:
; 1804 :     assert(nb == 1 && na > 0);
; 1805 :     /* The first element of ssb belongs at the front of the merge. */
; 1806 :     sortslice_memmove(&dest, 1-na, &ssa, 1-na, na);

  00425	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00428	bb 01 00 00 00	 mov	 ebx, 1
  0042d	4e 8d 2c f5 00
	00 00 00	 lea	 r13, QWORD PTR [r14*8]
  00435	49 2b de	 sub	 rbx, r14
  00438	4d 8b c5	 mov	 r8, r13
  0043b	48 8d 14 d8	 lea	 rdx, QWORD PTR [rax+rbx*8]
  0043f	49 8d 0c dc	 lea	 rcx, QWORD PTR [r12+rbx*8]
  00443	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
  00449	48 85 ff	 test	 rdi, rdi
  0044c	74 15		 je	 SHORT $LN75@merge_hi
  0044e	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  00452	48 8d 0c df	 lea	 rcx, QWORD PTR [rdi+rbx*8]
  00456	4d 8b c5	 mov	 r8, r13
  00459	48 8d 14 d8	 lea	 rdx, QWORD PTR [rax+rbx*8]
  0045d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN75@merge_hi:

; 1807 :     sortslice_advance(&dest, -na);

  00463	49 f7 de	 neg	 r14
  00466	4a 8d 04 f5 00
	00 00 00	 lea	 rax, QWORD PTR [r14*8]
  0046e	4c 03 e0	 add	 r12, rax
  00471	48 85 ff	 test	 rdi, rdi
  00474	74 03		 je	 SHORT $LN78@merge_hi
  00476	48 03 f8	 add	 rdi, rax
$LN78@merge_hi:

; 1808 :     sortslice_advance(&ssa, -na);

  00479	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  0047d	48 01 06	 add	 QWORD PTR [rsi], rax
  00480	48 85 c9	 test	 rcx, rcx
  00483	74 07		 je	 SHORT $LN81@merge_hi
  00485	48 03 c1	 add	 rax, rcx
  00488	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax
$LN81@merge_hi:

; 1809 :     sortslice_copy(&dest, 0, &ssb, 0);

  0048c	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  00490	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00493	49 89 0c 24	 mov	 QWORD PTR [r12], rcx
  00497	48 85 ff	 test	 rdi, rdi
  0049a	74 0a		 je	 SHORT $LN84@merge_hi
  0049c	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  004a0	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  004a3	48 89 0f	 mov	 QWORD PTR [rdi], rcx
$LN84@merge_hi:

; 1810 :     return 0;

  004a6	33 c0		 xor	 eax, eax
  004a8	eb 43		 jmp	 SHORT $LN113@merge_hi
$Succeed$21429:

; 1796 :     }
; 1797 : Succeed:
; 1798 :     result = 0;

  004aa	33 f6		 xor	 esi, esi

; 1693 :     basea = ssa;

  004ac	eb 04		 jmp	 SHORT $Fail$21443
$LN110@merge_hi:

; 1796 :     }
; 1797 : Succeed:
; 1798 :     result = 0;

  004ae	48 83 ce ff	 or	 rsi, -1
$Fail$21443:

; 1799 : Fail:
; 1800 :     if (nb)

  004b2	4d 85 ed	 test	 r13, r13
  004b5	74 33		 je	 SHORT $LN72@merge_hi

; 1801 :         sortslice_memcpy(&dest, -(nb-1), &baseb, 0, nb);

  004b7	48 8b 54 24 38	 mov	 rdx, QWORD PTR baseb$1$[rsp]
  004bc	bb 01 00 00 00	 mov	 ebx, 1
  004c1	49 2b dd	 sub	 rbx, r13
  004c4	49 c1 e5 03	 shl	 r13, 3
  004c8	49 8d 0c dc	 lea	 rcx, QWORD PTR [r12+rbx*8]
  004cc	4d 8b c5	 mov	 r8, r13
  004cf	e8 00 00 00 00	 call	 memcpy
  004d4	48 85 ff	 test	 rdi, rdi
  004d7	74 11		 je	 SHORT $LN72@merge_hi
  004d9	48 8b 54 24 48	 mov	 rdx, QWORD PTR baseb$2$[rsp]
  004de	48 8d 0c df	 lea	 rcx, QWORD PTR [rdi+rbx*8]
  004e2	4d 8b c5	 mov	 r8, r13
  004e5	e8 00 00 00 00	 call	 memcpy
$LN72@merge_hi:

; 1802 :     return result;

  004ea	48 63 c6	 movsxd	 rax, esi
$LN113@merge_hi:
  004ed	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR [rsp+160]
  004f5	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  004fd	4c 8b a4 24 a8
	00 00 00	 mov	 r12, QWORD PTR [rsp+168]

; 1811 : }

  00505	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00509	41 5f		 pop	 r15
  0050b	41 5e		 pop	 r14
  0050d	41 5d		 pop	 r13
  0050f	5e		 pop	 rsi
  00510	5d		 pop	 rbp
  00511	c3		 ret	 0
merge_hi ENDP
_TEXT	ENDS
PUBLIC	$T24225
PUBLIC	$T24226
;	COMDAT pdata
pdata	SEGMENT
$pdata$merge_at DD imagerel merge_at
	DD	imagerel merge_at+317
	DD	imagerel $unwind$merge_at
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$merge_at DD 0c2401H
	DD	056824H
	DD	0117419H
	DD	0106419H
	DD	0f5419H
	DD	0e3419H
	DD	0c015b219H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT merge_at
_TEXT	SEGMENT
$T24225 = 48
ssa$ = 48
$T24226 = 64
ssb$ = 64
ms$ = 112
i$ = 120
merge_at PROC						; COMDAT

; 1818 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00019	48 8b d9	 mov	 rbx, rcx

; 1819 :     sortslice ssa, ssb;
; 1820 :     Py_ssize_t na, nb;
; 1821 :     Py_ssize_t k;
; 1822 : 
; 1823 :     assert(ms != NULL);
; 1824 :     assert(ms->n >= 2);
; 1825 :     assert(i >= 0);
; 1826 :     assert(i == ms->n - 2 || i == ms->n - 3);
; 1827 : 
; 1828 :     ssa = ms->pending[i].base;

  0001c	48 8d 0c 52	 lea	 rcx, QWORD PTR [rdx+rdx*2]
  00020	0f 29 70 e8	 movaps	 XMMWORD PTR [rax-24], xmm6

; 1829 :     na = ms->pending[i].len;

  00024	48 8b 7c cb 38	 mov	 rdi, QWORD PTR [rbx+rcx*8+56]

; 1830 :     ssb = ms->pending[i+1].base;
; 1831 :     nb = ms->pending[i+1].len;

  00029	4c 8b 64 cb 50	 mov	 r12, QWORD PTR [rbx+rcx*8+80]
  0002e	0f 10 44 cb 28	 movups	 xmm0, XMMWORD PTR [rbx+rcx*8+40]
  00033	0f 10 74 cb 40	 movups	 xmm6, XMMWORD PTR [rbx+rcx*8+64]
  00038	0f 29 40 c8	 movaps	 XMMWORD PTR [rax-56], xmm0
  0003c	0f 29 70 d8	 movaps	 XMMWORD PTR [rax-40], xmm6

; 1832 :     assert(na > 0 && nb > 0);
; 1833 :     assert(ssa.keys + na == ssb.keys);
; 1834 : 
; 1835 :     /* Record the length of the combined runs; if i is the 3rd-last
; 1836 :      * run now, also slide over the last run (which isn't involved
; 1837 :      * in this merge).  The current run i+1 goes away in any case.
; 1838 :      */
; 1839 :     ms->pending[i].len = na + nb;

  00040	49 8d 04 3c	 lea	 rax, QWORD PTR [r12+rdi]
  00044	48 89 44 cb 38	 mov	 QWORD PTR [rbx+rcx*8+56], rax

; 1840 :     if (i == ms->n - 3)

  00049	8b 43 20	 mov	 eax, DWORD PTR [rbx+32]
  0004c	83 e8 03	 sub	 eax, 3
  0004f	48 98		 cdqe
  00051	48 3b d0	 cmp	 rdx, rax
  00054	75 1e		 jne	 SHORT $LN6@merge_at

; 1841 :         ms->pending[i+1] = ms->pending[i+2];

  00056	48 8b 44 cb 58	 mov	 rax, QWORD PTR [rbx+rcx*8+88]
  0005b	48 89 44 cb 40	 mov	 QWORD PTR [rbx+rcx*8+64], rax
  00060	48 8b 44 cb 60	 mov	 rax, QWORD PTR [rbx+rcx*8+96]
  00065	48 89 44 cb 48	 mov	 QWORD PTR [rbx+rcx*8+72], rax
  0006a	48 8b 44 cb 68	 mov	 rax, QWORD PTR [rbx+rcx*8+104]
  0006f	48 89 44 cb 50	 mov	 QWORD PTR [rbx+rcx*8+80], rax
$LN6@merge_at:

; 1842 :     --ms->n;

  00074	ff 4b 20	 dec	 DWORD PTR [rbx+32]

; 1843 : 
; 1844 :     /* Where does b start in a?  Elements in a before that can be
; 1845 :      * ignored (already in place).
; 1846 :      */
; 1847 :     k = gallop_right(*ssb.keys, ssa.keys, na, 0);

  00077	48 8b 6c 24 40	 mov	 rbp, QWORD PTR ssb$[rsp]
  0007c	48 8b 74 24 30	 mov	 rsi, QWORD PTR ssa$[rsp]
  00081	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
  00085	45 33 c9	 xor	 r9d, r9d
  00088	4c 8b c7	 mov	 r8, rdi
  0008b	48 8b d6	 mov	 rdx, rsi
  0008e	e8 00 00 00 00	 call	 gallop_right
  00093	4c 8b d8	 mov	 r11, rax

; 1848 :     if (k < 0)

  00096	48 85 c0	 test	 rax, rax
  00099	79 06		 jns	 SHORT $LN5@merge_at

; 1849 :         return -1;

  0009b	48 83 c8 ff	 or	 rax, -1
  0009f	eb 7c		 jmp	 SHORT $LN1@merge_at
$LN5@merge_at:

; 1850 :     sortslice_advance(&ssa, k);

  000a1	48 8d 0c c5 00
	00 00 00	 lea	 rcx, QWORD PTR [rax*8]
  000a9	48 8b 44 24 38	 mov	 rax, QWORD PTR ssa$[rsp+8]
  000ae	48 03 f1	 add	 rsi, rcx
  000b1	48 89 74 24 30	 mov	 QWORD PTR ssa$[rsp], rsi
  000b6	48 85 c0	 test	 rax, rax
  000b9	74 08		 je	 SHORT $LN9@merge_at
  000bb	48 03 c1	 add	 rax, rcx
  000be	48 89 44 24 38	 mov	 QWORD PTR ssa$[rsp+8], rax
$LN9@merge_at:

; 1851 :     na -= k;

  000c3	49 2b fb	 sub	 rdi, r11

; 1852 :     if (na == 0)

  000c6	75 04		 jne	 SHORT $LN4@merge_at

; 1853 :         return 0;

  000c8	33 c0		 xor	 eax, eax
  000ca	eb 51		 jmp	 SHORT $LN1@merge_at
$LN4@merge_at:

; 1854 : 
; 1855 :     /* Where does a end in b?  Elements in b after that can be
; 1856 :      * ignored (already in place).
; 1857 :      */
; 1858 :     nb = gallop_left(ssa.keys[na-1], ssb.keys, nb, nb-1);

  000cc	48 8b 4c fe f8	 mov	 rcx, QWORD PTR [rsi+rdi*8-8]
  000d1	4d 8d 4c 24 ff	 lea	 r9, QWORD PTR [r12-1]
  000d6	4d 8b c4	 mov	 r8, r12
  000d9	48 8b d5	 mov	 rdx, rbp
  000dc	e8 00 00 00 00	 call	 gallop_left

; 1859 :     if (nb <= 0)

  000e1	48 85 c0	 test	 rax, rax

; 1860 :         return nb;

  000e4	7e 37		 jle	 SHORT $LN1@merge_at

; 1861 : 
; 1862 :     /* Merge what remains of the runs, using a temp array with
; 1863 :      * min(na, nb) elements.
; 1864 :      */
; 1865 :     if (na <= nb)
; 1866 :         return merge_lo(ms, ssa, na, ssb, nb);

  000e6	0f 28 44 24 30	 movaps	 xmm0, XMMWORD PTR ssa$[rsp]
  000eb	66 0f 7f 74 24
	40		 movdqa	 XMMWORD PTR $T24226[rsp], xmm6
  000f1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f6	4c 8d 4c 24 40	 lea	 r9, QWORD PTR $T24226[rsp]
  000fb	4c 8b c7	 mov	 r8, rdi
  000fe	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T24225[rsp]
  00103	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR $T24225[rsp], xmm0
  00109	48 8b cb	 mov	 rcx, rbx
  0010c	48 3b f8	 cmp	 rdi, rax
  0010f	7f 07		 jg	 SHORT $LN2@merge_at
  00111	e8 00 00 00 00	 call	 merge_lo
  00116	eb 05		 jmp	 SHORT $LN1@merge_at
$LN2@merge_at:

; 1867 :     else
; 1868 :         return merge_hi(ms, ssa, na, ssb, nb);

  00118	e8 00 00 00 00	 call	 merge_hi
$LN1@merge_at:

; 1869 : }

  0011d	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  00122	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  00127	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  0012b	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  0012f	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00133	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  00137	49 8b e3	 mov	 rsp, r11
  0013a	41 5c		 pop	 r12
  0013c	c3		 ret	 0
merge_at ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$merge_collapse DD imagerel merge_collapse
	DD	imagerel merge_collapse+119
	DD	imagerel $unwind$merge_collapse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$merge_collapse DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT merge_collapse
_TEXT	SEGMENT
ms$ = 48
merge_collapse PROC					; COMDAT

; 1883 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1884 :     struct s_slice *p = ms->pending;
; 1885 : 
; 1886 :     assert(ms);
; 1887 :     while (ms->n > 1) {

  00006	8b 41 20	 mov	 eax, DWORD PTR [rcx+32]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	83 f8 01	 cmp	 eax, 1
  0000f	7e 55		 jle	 SHORT $LN3@merge_coll
$LL9@merge_coll:

; 1888 :         Py_ssize_t n = ms->n - 2;

  00011	83 c0 fe	 add	 eax, -2
  00014	48 63 d0	 movsxd	 rdx, eax

; 1889 :         if (n > 0 && p[n-1].len <= p[n].len + p[n+1].len) {

  00017	85 c0		 test	 eax, eax
  00019	7e 26		 jle	 SHORT $LN7@merge_coll
  0001b	48 8d 04 52	 lea	 rax, QWORD PTR [rdx+rdx*2]
  0001f	4c 8b 44 c3 50	 mov	 r8, QWORD PTR [rbx+rax*8+80]
  00024	4c 8b 4c c3 20	 mov	 r9, QWORD PTR [rbx+rax*8+32]
  00029	48 8b 44 c3 38	 mov	 rax, QWORD PTR [rbx+rax*8+56]
  0002e	49 8d 0c 00	 lea	 rcx, QWORD PTR [r8+rax]
  00032	4c 3b c9	 cmp	 r9, rcx
  00035	7f 0a		 jg	 SHORT $LN7@merge_coll

; 1890 :             if (p[n-1].len < p[n+1].len)

  00037	4d 3b c8	 cmp	 r9, r8
  0003a	7d 15		 jge	 SHORT $LN6@merge_coll

; 1891 :                 --n;

  0003c	48 ff ca	 dec	 rdx

; 1894 :         }
; 1895 :         else if (p[n].len <= p[n+1].len) {

  0003f	eb 10		 jmp	 SHORT $LN6@merge_coll
$LN7@merge_coll:
  00041	48 8d 0c 52	 lea	 rcx, QWORD PTR [rdx+rdx*2]
  00045	48 8b 44 cb 50	 mov	 rax, QWORD PTR [rbx+rcx*8+80]
  0004a	48 39 44 cb 38	 cmp	 QWORD PTR [rbx+rcx*8+56], rax
  0004f	7f 15		 jg	 SHORT $LN3@merge_coll
$LN6@merge_coll:

; 1896 :                  if (merge_at(ms, n) < 0)

  00051	48 8b cb	 mov	 rcx, rbx
  00054	e8 00 00 00 00	 call	 merge_at
  00059	48 85 c0	 test	 rax, rax
  0005c	78 10		 js	 SHORT $LN13@merge_coll

; 1884 :     struct s_slice *p = ms->pending;
; 1885 : 
; 1886 :     assert(ms);
; 1887 :     while (ms->n > 1) {

  0005e	8b 43 20	 mov	 eax, DWORD PTR [rbx+32]
  00061	83 f8 01	 cmp	 eax, 1
  00064	7f ab		 jg	 SHORT $LL9@merge_coll
$LN3@merge_coll:

; 1897 :                         return -1;
; 1898 :         }
; 1899 :         else
; 1900 :             break;
; 1901 :     }
; 1902 :     return 0;

  00066	33 c0		 xor	 eax, eax

; 1903 : }

  00068	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006c	5b		 pop	 rbx
  0006d	c3		 ret	 0
$LN13@merge_coll:

; 1892 :             if (merge_at(ms, n) < 0)
; 1893 :                 return -1;

  0006e	83 c8 ff	 or	 eax, -1

; 1903 : }

  00071	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00075	5b		 pop	 rbx
  00076	c3		 ret	 0
merge_collapse ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$merge_force_collapse DD imagerel merge_force_collapse
	DD	imagerel merge_force_collapse+84
	DD	imagerel $unwind$merge_force_collapse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$merge_force_collapse DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT merge_force_collapse
_TEXT	SEGMENT
ms$ = 48
merge_force_collapse PROC				; COMDAT

; 1912 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1913 :     struct s_slice *p = ms->pending;
; 1914 : 
; 1915 :     assert(ms);
; 1916 :     while (ms->n > 1) {

  00006	8b 41 20	 mov	 eax, DWORD PTR [rcx+32]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	83 f8 01	 cmp	 eax, 1
  0000f	7e 32		 jle	 SHORT $LN3@merge_forc
$LL4@merge_forc:

; 1917 :         Py_ssize_t n = ms->n - 2;

  00011	83 c0 fe	 add	 eax, -2
  00014	48 63 d0	 movsxd	 rdx, eax

; 1918 :         if (n > 0 && p[n-1].len < p[n+1].len)

  00017	85 c0		 test	 eax, eax
  00019	7e 13		 jle	 SHORT $LN2@merge_forc
  0001b	48 8d 0c 52	 lea	 rcx, QWORD PTR [rdx+rdx*2]
  0001f	48 8b 44 cb 50	 mov	 rax, QWORD PTR [rbx+rcx*8+80]
  00024	48 39 44 cb 20	 cmp	 QWORD PTR [rbx+rcx*8+32], rax
  00029	7d 03		 jge	 SHORT $LN2@merge_forc

; 1919 :             --n;

  0002b	48 ff ca	 dec	 rdx
$LN2@merge_forc:

; 1920 :         if (merge_at(ms, n) < 0)

  0002e	48 8b cb	 mov	 rcx, rbx
  00031	e8 00 00 00 00	 call	 merge_at
  00036	48 85 c0	 test	 rax, rax
  00039	78 10		 js	 SHORT $LN8@merge_forc

; 1913 :     struct s_slice *p = ms->pending;
; 1914 : 
; 1915 :     assert(ms);
; 1916 :     while (ms->n > 1) {

  0003b	8b 43 20	 mov	 eax, DWORD PTR [rbx+32]
  0003e	83 f8 01	 cmp	 eax, 1
  00041	7f ce		 jg	 SHORT $LL4@merge_forc
$LN3@merge_forc:

; 1922 :     }
; 1923 :     return 0;

  00043	33 c0		 xor	 eax, eax

; 1924 : }

  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
$LN8@merge_forc:

; 1921 :             return -1;

  0004b	83 c8 ff	 or	 eax, -1

; 1924 : }

  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5b		 pop	 rbx
  00053	c3		 ret	 0
merge_force_collapse ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT merge_compute_minrun
_TEXT	SEGMENT
n$ = 8
merge_compute_minrun PROC				; COMDAT

; 1939 :     Py_ssize_t r = 0;           /* becomes 1 if any 1 bits are shifted off */

  00000	33 d2		 xor	 edx, edx

; 1940 : 
; 1941 :     assert(n >= 0);
; 1942 :     while (n >= 64) {

  00002	48 83 f9 40	 cmp	 rcx, 64			; 00000040H
  00006	7c 1a		 jl	 SHORT $LN7@merge_comp
  00008	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@merge_comp:

; 1943 :         r |= n & 1;

  00010	48 8b c1	 mov	 rax, rcx

; 1944 :         n >>= 1;

  00013	48 d1 f9	 sar	 rcx, 1
  00016	83 e0 01	 and	 eax, 1
  00019	48 0b d0	 or	 rdx, rax
  0001c	48 83 f9 40	 cmp	 rcx, 64			; 00000040H
  00020	7d ee		 jge	 SHORT $LL2@merge_comp
$LN7@merge_comp:

; 1945 :     }
; 1946 :     return n + r;

  00022	48 8d 04 0a	 lea	 rax, QWORD PTR [rdx+rcx]

; 1947 : }

  00026	c3		 ret	 0
merge_compute_minrun ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$reverse_sortslice DD imagerel reverse_sortslice
	DD	imagerel reverse_sortslice+47
	DD	imagerel $unwind$reverse_sortslice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reverse_sortslice DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT reverse_sortslice
_TEXT	SEGMENT
s$ = 48
n$ = 56
reverse_sortslice PROC					; COMDAT

; 1951 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b c9	 mov	 r9, rcx

; 1952 :     reverse_slice(s->keys, &s->keys[n]);

  00007	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000a	4c 8b d2	 mov	 r10, rdx
  0000d	48 8d 14 d1	 lea	 rdx, QWORD PTR [rcx+rdx*8]
  00011	e8 00 00 00 00	 call	 reverse_slice

; 1953 :     if (s->values != NULL)

  00016	49 83 79 08 00	 cmp	 QWORD PTR [r9+8], 0
  0001b	74 0d		 je	 SHORT $LN1@reverse_so

; 1954 :         reverse_slice(s->values, &s->values[n]);

  0001d	49 8b 49 08	 mov	 rcx, QWORD PTR [r9+8]
  00021	4a 8d 14 d1	 lea	 rdx, QWORD PTR [rcx+r10*8]
  00025	e8 00 00 00 00	 call	 reverse_slice
$LN1@reverse_so:

; 1955 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
reverse_sortslice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@BOEBAINE@list?5modified?5during?5sort?$AA@ ; `string'
PUBLIC	$T24314
PUBLIC	??_C@_0CL@HOEKIDMG@must?5use?5keyword?5argument?5for?5ke@ ; `string'
PUBLIC	??_C@_08IFACFLKK@?$HMOi?3sort?$AA@		; `string'
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	PyArg_ParseTupleAndKeywords:PROC
EXTRN	__chkstk:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$listsort DD imagerel listsort
	DD	imagerel listsort+1579
	DD	imagerel $unwind$listsort
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listsort DD 0ed701H
	DD	0214f4d7H
	DD	0215e4cfH
	DD	0216c4c3H
	DD	021e74adH
	DD	0217011fH
	DD	06008d00aH
	DD	050063007H
xdata	ENDS
;	COMDAT ??_C@_0BK@BOEBAINE@list?5modified?5during?5sort?$AA@
CONST	SEGMENT
??_C@_0BK@BOEBAINE@list?5modified?5during?5sort?$AA@ DB 'list modified du'
	DB	'ring sort', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HOEKIDMG@must?5use?5keyword?5argument?5for?5ke@
CONST	SEGMENT
??_C@_0CL@HOEKIDMG@must?5use?5keyword?5argument?5for?5ke@ DB 'must use ke'
	DB	'yword argument for key function', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IFACFLKK@?$HMOi?3sort?$AA@
CONST	SEGMENT
??_C@_08IFACFLKK@?$HMOi?3sort?$AA@ DB '|Oi:sort', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
CONST	ENDS
;	COMDAT listsort
_TEXT	SEGMENT
saved_ob_item$1$ = 48
keyfunc$ = 56
result$1$ = 64
lo$ = 80
saved_ob_size$1$ = 96
saved_allocated$1$ = 104
$T24314 = 112
ms$ = 128
self$ = 4320
reverse$ = 4328
args$ = 4328
kwds$ = 4336
descending$21620 = 4344
listsort PROC						; COMDAT

; 1964 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	53		 push	 rbx
  00007	56		 push	 rsi
  00008	41 55		 push	 r13
  0000a	48 8d ac 24 48
	f0 ff ff	 lea	 rbp, QWORD PTR [rsp-4024]
  00012	b8 b8 10 00 00	 mov	 eax, 4280		; 000010b8H
  00017	e8 00 00 00 00	 call	 __chkstk
  0001c	48 2b e0	 sub	 rsp, rax

; 1965 :     MergeState ms;
; 1966 :     Py_ssize_t nremaining;
; 1967 :     Py_ssize_t minrun;
; 1968 :     sortslice lo;
; 1969 :     Py_ssize_t saved_ob_size, saved_allocated;
; 1970 :     PyObject **saved_ob_item;
; 1971 :     PyObject **final_ob_item;
; 1972 :     PyObject *result = NULL;            /* guilty until proved innocent */

  0001f	33 f6		 xor	 esi, esi
  00021	4c 8b e9	 mov	 r13, rcx
  00024	49 8b c0	 mov	 rax, r8

; 1973 :     int reverse = 0;
; 1974 :     PyObject *keyfunc = NULL;

  00027	8b ce		 mov	 ecx, esi
  00029	48 8b da	 mov	 rbx, rdx
  0002c	48 89 74 24 40	 mov	 QWORD PTR result$1$[rsp], rsi
  00031	89 b5 e8 0f 00
	00		 mov	 DWORD PTR reverse$[rbp-256], esi
  00037	48 89 4c 24 38	 mov	 QWORD PTR keyfunc$[rsp], rcx

; 1975 :     Py_ssize_t i;
; 1976 :     static char *kwlist[] = {"key", "reverse", 0};
; 1977 :     PyObject **keys;
; 1978 : 
; 1979 :     assert(self != NULL);
; 1980 :     assert (PyList_Check(self));
; 1981 : 
; 1982 :     /*
; 1983 :     if (Px_PROTECTION_ERROR(self))
; 1984 :         return NULL;
; 1985 :     */
; 1986 : 
; 1987 :     if (args != NULL) {

  0003c	48 85 d2	 test	 rdx, rdx
  0003f	74 60		 je	 SHORT $LN45@listsort

; 1988 :         if (!PyArg_ParseTupleAndKeywords(args, kwds, "|Oi:sort",
; 1989 :             kwlist, &keyfunc, &reverse))

  00041	48 8d 8d e8 0f
	00 00		 lea	 rcx, QWORD PTR reverse$[rbp-256]
  00048	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??listsort@@9@9
  0004f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08IFACFLKK@?$HMOi?3sort?$AA@
  00056	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0005b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR keyfunc$[rsp]
  00060	48 8b d0	 mov	 rdx, rax
  00063	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00068	48 8b cb	 mov	 rcx, rbx
  0006b	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00070	85 c0		 test	 eax, eax

; 1990 :             return NULL;

  00072	74 19		 je	 SHORT $LN136@listsort

; 1991 :         if (Py_SIZE(args) > 0) {

  00074	48 39 73 60	 cmp	 QWORD PTR [rbx+96], rsi
  00078	7e 22		 jle	 SHORT $LN116@listsort

; 1992 :             PyErr_SetString(PyExc_TypeError,
; 1993 :                 "must use keyword argument for key function");

  0007a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@HOEKIDMG@must?5use?5keyword?5argument?5for?5ke@
  00088	e8 00 00 00 00	 call	 PyErr_SetString
$LN136@listsort:

; 1994 :             return NULL;

  0008d	33 c0		 xor	 eax, eax

; 2139 : }

  0008f	48 81 c4 b8 10
	00 00		 add	 rsp, 4280		; 000010b8H
  00096	41 5d		 pop	 r13
  00098	5e		 pop	 rsi
  00099	5b		 pop	 rbx
  0009a	5d		 pop	 rbp
  0009b	c3		 ret	 0
$LN116@listsort:

; 1994 :             return NULL;

  0009c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR keyfunc$[rsp]
$LN45@listsort:

; 1995 :         }
; 1996 :     }
; 1997 :     if (keyfunc == Py_None)
; 1998 :         keyfunc = NULL;
; 1999 : 
; 2000 :     /* The list is temporarily made empty, so that mutations performed
; 2001 :      * by comparison functions can't affect the slice of memory we're
; 2002 :      * sorting (allowing mutations during sorting is a core-dump
; 2003 :      * factory, since ob_item may change).
; 2004 :      */
; 2005 :     saved_ob_size = Py_SIZE(self);
; 2006 :     saved_ob_item = self->ob_item;

  000a1	4d 8b 5d 70	 mov	 r11, QWORD PTR [r13+112]
  000a5	48 89 bc 24 f0
	10 00 00	 mov	 QWORD PTR [rsp+4336], rdi
  000ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000b4	48 3b c8	 cmp	 rcx, rax

; 2007 :     saved_allocated = self->allocated;

  000b7	49 8b 45 78	 mov	 rax, QWORD PTR [r13+120]
  000bb	4c 89 a4 24 b0
	10 00 00	 mov	 QWORD PTR [rsp+4272], r12
  000c3	48 0f 44 ce	 cmove	 rcx, rsi
  000c7	4c 89 b4 24 a8
	10 00 00	 mov	 QWORD PTR [rsp+4264], r14
  000cf	4c 89 bc 24 a0
	10 00 00	 mov	 QWORD PTR [rsp+4256], r15
  000d7	4d 8b 7d 60	 mov	 r15, QWORD PTR [r13+96]
  000db	48 89 44 24 68	 mov	 QWORD PTR saved_allocated$1$[rsp], rax
  000e0	4c 89 5c 24 30	 mov	 QWORD PTR saved_ob_item$1$[rsp], r11
  000e5	48 89 4c 24 38	 mov	 QWORD PTR keyfunc$[rsp], rcx

; 2008 :     Py_SIZE(self) = 0;

  000ea	49 89 75 60	 mov	 QWORD PTR [r13+96], rsi

; 2009 :     self->ob_item = NULL;

  000ee	49 89 75 70	 mov	 QWORD PTR [r13+112], rsi
  000f2	4c 89 7c 24 60	 mov	 QWORD PTR saved_ob_size$1$[rsp], r15

; 2010 :     self->allocated = -1; /* any operation will reset it to >= 0 */

  000f7	49 c7 45 78 ff
	ff ff ff	 mov	 QWORD PTR [r13+120], -1

; 2011 : 
; 2012 :     if (keyfunc == NULL) {

  000ff	48 85 c9	 test	 rcx, rcx
  00102	75 15		 jne	 SHORT $LN43@listsort

; 2013 :         keys = NULL;

  00104	4c 8b f6	 mov	 r14, rsi

; 2014 :         lo.keys = saved_ob_item;

  00107	49 8b fb	 mov	 rdi, r11
  0010a	4c 89 5c 24 50	 mov	 QWORD PTR lo$[rsp], r11

; 2015 :         lo.values = NULL;

  0010f	48 89 74 24 58	 mov	 QWORD PTR lo$[rsp+8], rsi

; 2016 :     }
; 2017 :     else {

  00114	e9 c7 00 00 00	 jmp	 $LN42@listsort
$LN43@listsort:

; 2018 :         if (saved_ob_size < MERGESTATE_TEMP_SIZE/2)

  00119	49 81 ff 80 00
	00 00		 cmp	 r15, 128		; 00000080H
  00120	7d 12		 jge	 SHORT $LN41@listsort

; 2019 :             /* Leverage stack space we allocated but won't otherwise use */
; 2020 :             keys = &ms.temparray[saved_ob_size+1];

  00122	4e 8d 24 fd 00
	00 00 00	 lea	 r12, QWORD PTR [r15*8]
  0012a	4e 8d b4 25 a8
	07 00 00	 lea	 r14, QWORD PTR ms$[rbp+r12+1832]

; 2021 :         else {

  00132	eb 56		 jmp	 SHORT $LN39@listsort
$LN41@listsort:

; 2022 :             keys = PyMem_MALLOC(sizeof(PyObject *) * saved_ob_size);

  00134	e8 00 00 00 00	 call	 _Py_PXCTX
  00139	4e 8d 24 fd 00
	00 00 00	 lea	 r12, QWORD PTR [r15*8]
  00141	85 c0		 test	 eax, eax
  00143	74 0a		 je	 SHORT $LN54@listsort
  00145	49 8b cc	 mov	 rcx, r12
  00148	e8 00 00 00 00	 call	 _PxMem_Malloc
  0014d	eb 25		 jmp	 SHORT $LN135@listsort
$LN54@listsort:
  0014f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00159	4c 3b e0	 cmp	 r12, rax
  0015c	0f 87 9a 04 00
	00		 ja	 $LN115@listsort
  00162	4d 85 e4	 test	 r12, r12
  00165	b9 01 00 00 00	 mov	 ecx, 1
  0016a	49 0f 45 cc	 cmovne	 rcx, r12
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN135@listsort:
  00174	4c 8b f0	 mov	 r14, rax

; 2023 :             if (keys == NULL)

  00177	48 85 c0	 test	 rax, rax
  0017a	0f 84 7c 04 00
	00		 je	 $LN115@listsort

; 2024 :                 return NULL;

  00180	48 8b 4c 24 38	 mov	 rcx, QWORD PTR keyfunc$[rsp]
  00185	4c 8b 5c 24 30	 mov	 r11, QWORD PTR saved_ob_item$1$[rsp]
$LN39@listsort:

; 2025 :         }
; 2026 : 
; 2027 :         for (i = 0; i < saved_ob_size ; i++) {

  0018a	48 8b fe	 mov	 rdi, rsi
  0018d	4d 85 ff	 test	 r15, r15
  00190	7e 3e		 jle	 SHORT $LN36@listsort
  00192	49 8b f3	 mov	 rsi, r11
  00195	49 8b de	 mov	 rbx, r14
  00198	49 2b f6	 sub	 rsi, r14
  0019b	0f 1f 44 00 00	 npad	 5
$LL38@listsort:

; 2028 :             keys[i] = PyObject_CallFunctionObjArgs(keyfunc, saved_ob_item[i],
; 2029 :                                                    NULL);

  001a0	48 8b 14 1e	 mov	 rdx, QWORD PTR [rsi+rbx]
  001a4	45 33 c0	 xor	 r8d, r8d
  001a7	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  001ac	48 89 03	 mov	 QWORD PTR [rbx], rax

; 2030 :             if (keys[i] == NULL) {

  001af	48 85 c0	 test	 rax, rax
  001b2	0f 84 60 01 00
	00		 je	 $LN107@listsort

; 2025 :         }
; 2026 : 
; 2027 :         for (i = 0; i < saved_ob_size ; i++) {

  001b8	48 ff c7	 inc	 rdi
  001bb	48 83 c3 08	 add	 rbx, 8
  001bf	49 3b ff	 cmp	 rdi, r15
  001c2	7d 07		 jge	 SHORT $LN126@listsort
  001c4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR keyfunc$[rsp]
  001c9	eb d5		 jmp	 SHORT $LL38@listsort
$LN126@listsort:

; 2084 :         if (merge_collapse(&ms) < 0)

  001cb	4c 8b 5c 24 30	 mov	 r11, QWORD PTR saved_ob_item$1$[rsp]
$LN36@listsort:

; 2036 :             }
; 2037 :         }
; 2038 : 
; 2039 :         lo.keys = keys;

  001d0	49 8b fe	 mov	 rdi, r14
  001d3	4c 89 74 24 50	 mov	 QWORD PTR lo$[rsp], r14

; 2040 :         lo.values = saved_ob_item;

  001d8	49 8b f3	 mov	 rsi, r11
  001db	4c 89 5c 24 58	 mov	 QWORD PTR lo$[rsp+8], r11
$LN42@listsort:

; 2041 :     }
; 2042 : 
; 2043 :     merge_init(&ms, saved_ob_size, keys != NULL);

  001e0	45 33 c0	 xor	 r8d, r8d
  001e3	4d 85 f6	 test	 r14, r14
  001e6	48 8d 4d 80	 lea	 rcx, QWORD PTR ms$[rbp-256]
  001ea	41 0f 95 c0	 setne	 r8b
  001ee	49 8b d7	 mov	 rdx, r15
  001f1	e8 00 00 00 00	 call	 merge_init

; 2044 : 
; 2045 :     nremaining = saved_ob_size;

  001f6	4d 8b ef	 mov	 r13, r15

; 2046 :     if (nremaining < 2)

  001f9	49 83 ff 02	 cmp	 r15, 2
  001fd	0f 8c 71 02 00
	00		 jl	 $succeed$21613

; 2047 :         goto succeed;
; 2048 : 
; 2049 :     /* Reverse sort stability achieved by initially reversing the list,
; 2050 :     applying a stable forward sort, then reversing the final result. */
; 2051 :     if (reverse) {

  00203	83 bd e8 0f 00
	00 00		 cmp	 DWORD PTR reverse$[rbp-256], 0
  0020a	74 1d		 je	 SHORT $LN29@listsort

; 2052 :         if (keys != NULL)

  0020c	4d 85 f6	 test	 r14, r14
  0020f	74 0c		 je	 SHORT $LN28@listsort

; 2053 :             reverse_slice(&keys[0], &keys[saved_ob_size]);

  00211	4b 8d 14 fe	 lea	 rdx, QWORD PTR [r14+r15*8]
  00215	49 8b ce	 mov	 rcx, r14
  00218	e8 00 00 00 00	 call	 reverse_slice
$LN28@listsort:

; 2054 :         reverse_slice(&saved_ob_item[0], &saved_ob_item[saved_ob_size]);

  0021d	4b 8d 14 fb	 lea	 rdx, QWORD PTR [r11+r15*8]
  00221	49 8b cb	 mov	 rcx, r11
  00224	e8 00 00 00 00	 call	 reverse_slice
$LN29@listsort:

; 2055 :     }
; 2056 : 
; 2057 :     /* March over the array once, left to right, finding natural runs,
; 2058 :      * and extending short natural runs to minrun elements.
; 2059 :      */
; 2060 :     minrun = merge_compute_minrun(nremaining);

  00229	49 8b cf	 mov	 rcx, r15
  0022c	e8 00 00 00 00	 call	 merge_compute_minrun
  00231	4c 8b f8	 mov	 r15, rax
  00234	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL27@listsort:

; 2061 :     do {
; 2062 :         int descending;
; 2063 :         Py_ssize_t n;
; 2064 : 
; 2065 :         /* Identify next run. */
; 2066 :         n = count_run(lo.keys, lo.keys + nremaining, &descending);

  00240	4a 8d 14 ef	 lea	 rdx, QWORD PTR [rdi+r13*8]
  00244	4c 8d 85 f8 0f
	00 00		 lea	 r8, QWORD PTR descending$21620[rbp-256]
  0024b	48 8b cf	 mov	 rcx, rdi
  0024e	e8 00 00 00 00	 call	 count_run
  00253	48 8b d8	 mov	 rbx, rax

; 2067 :         if (n < 0)

  00256	48 85 c0	 test	 rax, rax
  00259	0f 88 af 00 00
	00		 js	 $LN119@listsort

; 2068 :             goto fail;
; 2069 :         if (descending)

  0025f	83 bd f8 0f 00
	00 00		 cmp	 DWORD PTR descending$21620[rbp-256], 0
  00266	74 0d		 je	 SHORT $LN23@listsort

; 2070 :             reverse_sortslice(&lo, n);

  00268	48 8d 4c 24 50	 lea	 rcx, QWORD PTR lo$[rsp]
  0026d	48 8b d0	 mov	 rdx, rax
  00270	e8 00 00 00 00	 call	 reverse_sortslice
$LN23@listsort:

; 2071 :         /* If short, extend to min(minrun, nremaining). */
; 2072 :         if (n < minrun) {

  00275	49 3b df	 cmp	 rbx, r15
  00278	7d 2e		 jge	 SHORT $LN22@listsort

; 2073 :             const Py_ssize_t force = nremaining <= minrun ?
; 2074 :                               nremaining : minrun;
; 2075 :             if (binarysort(lo, lo.keys + force, lo.keys + n) < 0)

  0027a	0f 28 44 24 50	 movaps	 xmm0, XMMWORD PTR lo$[rsp]
  0027f	4d 8b e7	 mov	 r12, r15
  00282	4d 3b ef	 cmp	 r13, r15
  00285	4d 0f 4e e5	 cmovle	 r12, r13
  00289	4c 8d 04 df	 lea	 r8, QWORD PTR [rdi+rbx*8]
  0028d	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T24314[rsp]
  00292	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR $T24314[rsp], xmm0
  00298	4a 8d 14 e7	 lea	 rdx, QWORD PTR [rdi+r12*8]
  0029c	e8 00 00 00 00	 call	 binarysort
  002a1	85 c0		 test	 eax, eax
  002a3	78 69		 js	 SHORT $LN119@listsort

; 2076 :                 goto fail;
; 2077 :             n = force;

  002a5	49 8b dc	 mov	 rbx, r12
$LN22@listsort:

; 2078 :         }
; 2079 :         /* Push run onto pending-runs stack, and maybe merge. */
; 2080 :         assert(ms.n < MAX_MERGE_PENDING);
; 2081 :         ms.pending[ms.n].base = lo;

  002a8	48 63 45 a0	 movsxd	 rax, DWORD PTR ms$[rbp-224]
  002ac	48 8d 0c 40	 lea	 rcx, QWORD PTR [rax+rax*2]
  002b0	48 89 7c cd a8	 mov	 QWORD PTR ms$[rbp+rcx*8-216], rdi
  002b5	48 89 74 cd b0	 mov	 QWORD PTR ms$[rbp+rcx*8-208], rsi

; 2082 :         ms.pending[ms.n].len = n;

  002ba	48 63 45 a0	 movsxd	 rax, DWORD PTR ms$[rbp-224]
  002be	48 8d 0c 40	 lea	 rcx, QWORD PTR [rax+rax*2]
  002c2	48 89 5c cd b8	 mov	 QWORD PTR ms$[rbp+rcx*8-200], rbx

; 2083 :         ++ms.n;

  002c7	ff 45 a0	 inc	 DWORD PTR ms$[rbp-224]

; 2084 :         if (merge_collapse(&ms) < 0)

  002ca	48 8d 4d 80	 lea	 rcx, QWORD PTR ms$[rbp-256]
  002ce	e8 00 00 00 00	 call	 merge_collapse
  002d3	85 c0		 test	 eax, eax
  002d5	78 37		 js	 SHORT $LN119@listsort

; 2085 :             goto fail;
; 2086 :         /* Advance to find next run. */
; 2087 :         sortslice_advance(&lo, n);

  002d7	48 8d 04 dd 00
	00 00 00	 lea	 rax, QWORD PTR [rbx*8]
  002df	48 03 f8	 add	 rdi, rax
  002e2	48 89 7c 24 50	 mov	 QWORD PTR lo$[rsp], rdi
  002e7	48 85 f6	 test	 rsi, rsi
  002ea	74 08		 je	 SHORT $LN73@listsort
  002ec	48 03 f0	 add	 rsi, rax
  002ef	48 89 74 24 58	 mov	 QWORD PTR lo$[rsp+8], rsi
$LN73@listsort:

; 2088 :         nremaining -= n;

  002f4	4c 2b eb	 sub	 r13, rbx

; 2089 :     } while (nremaining);

  002f7	0f 85 43 ff ff
	ff		 jne	 $LL27@listsort

; 2090 : 
; 2091 :     if (merge_force_collapse(&ms) < 0)

  002fd	48 8d 4d 80	 lea	 rcx, QWORD PTR ms$[rbp-256]
  00301	e8 00 00 00 00	 call	 merge_force_collapse
  00306	85 c0		 test	 eax, eax
  00308	0f 89 66 01 00
	00		 jns	 $succeed$21613
$LN119@listsort:

; 2092 :         goto fail;
; 2093 :     assert(ms.n == 1);
; 2094 :     assert(keys == NULL
; 2095 :            ? ms.pending[0].base.keys == saved_ob_item
; 2096 :            : ms.pending[0].base.keys == &keys[0]);
; 2097 :     assert(ms.pending[0].len == saved_ob_size);
; 2098 :     lo = ms.pending[0].base;
; 2099 : 
; 2100 : succeed:
; 2101 :     result = Py_None;

  0030e	4c 8b 64 24 40	 mov	 r12, QWORD PTR result$1$[rsp]
  00313	e9 63 01 00 00	 jmp	 $fail$21623
$LN107@listsort:

; 2031 :                 for (i=i-1 ; i>=0 ; i--)

  00318	48 ff cf	 dec	 rdi
  0031b	78 71		 js	 SHORT $LN32@listsort
  0031d	0f 1f 00	 npad	 3
$LL34@listsort:

; 2032 :                     Py_DECREF(keys[i]);

  00320	49 8b 1c fe	 mov	 rbx, QWORD PTR [r14+rdi*8]
  00324	e8 00 00 00 00	 call	 _Py_PXCTX
  00329	85 c0		 test	 eax, eax
  0032b	75 5c		 jne	 SHORT $LN33@listsort
  0032d	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00331	a8 20		 test	 al, 32			; 00000020H
  00333	75 4c		 jne	 SHORT $LN66@listsort
  00335	84 c0		 test	 al, al
  00337	78 48		 js	 SHORT $LN66@listsort
  00339	a8 02		 test	 al, 2
  0033b	75 4c		 jne	 SHORT $LN33@listsort
  0033d	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00341	75 46		 jne	 SHORT $LN33@listsort
  00343	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0034a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00351	4c 8b cb	 mov	 r9, rbx
  00354	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0035a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00362	e8 00 00 00 00	 call	 _PyParallel_Guard
  00367	48 8b cb	 mov	 rcx, rbx
  0036a	85 c0		 test	 eax, eax
  0036c	74 07		 je	 SHORT $LN71@listsort
  0036e	e8 00 00 00 00	 call	 _Px_Dealloc
  00373	eb 14		 jmp	 SHORT $LN33@listsort
$LN71@listsort:
  00375	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00379	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0037f	eb 08		 jmp	 SHORT $LN33@listsort
$LN66@listsort:
  00381	48 8b cb	 mov	 rcx, rbx
  00384	e8 00 00 00 00	 call	 Px_DecRef
$LN33@listsort:

; 2031 :                 for (i=i-1 ; i>=0 ; i--)

  00389	48 ff cf	 dec	 rdi
  0038c	79 92		 jns	 SHORT $LL34@listsort
$LN32@listsort:

; 2033 :                 if (keys != &ms.temparray[saved_ob_size+1])

  0038e	4a 8d 84 25 a8
	07 00 00	 lea	 rax, QWORD PTR ms$[rbp+r12+1832]
  00396	4c 3b f0	 cmp	 r14, rax
  00399	74 15		 je	 SHORT $LN128@listsort

; 2034 :                     PyMem_FREE(keys);

  0039b	e8 00 00 00 00	 call	 _Py_PXCTX
  003a0	49 8b ce	 mov	 rcx, r14
  003a3	85 c0		 test	 eax, eax
  003a5	0f 84 be 00 00
	00		 je	 $LN56@listsort
  003ab	e8 00 00 00 00	 call	 _PxMem_Free
$LN128@listsort:

; 2108 :     }
; 2109 : 
; 2110 :     if (self->allocated != -1 && result != NULL) {

  003b0	4c 8b 64 24 40	 mov	 r12, QWORD PTR result$1$[rsp]
  003b5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR saved_ob_item$1$[rsp]
$keyfunc_fail$21610:

; 2122 : 
; 2123 : keyfunc_fail:
; 2124 :     final_ob_item = self->ob_item;

  003ba	49 8b 75 70	 mov	 rsi, QWORD PTR [r13+112]

; 2125 :     i = Py_SIZE(self);
; 2126 :     Py_SIZE(self) = saved_ob_size;
; 2127 :     self->ob_item = saved_ob_item;
; 2128 :     self->allocated = saved_allocated;

  003be	48 8b 44 24 68	 mov	 rax, QWORD PTR saved_allocated$1$[rsp]
  003c3	49 8b 7d 60	 mov	 rdi, QWORD PTR [r13+96]
  003c7	4d 89 7d 60	 mov	 QWORD PTR [r13+96], r15
  003cb	49 89 5d 70	 mov	 QWORD PTR [r13+112], rbx
  003cf	49 89 45 78	 mov	 QWORD PTR [r13+120], rax

; 2129 :     if (final_ob_item != NULL) {

  003d3	48 85 f6	 test	 rsi, rsi
  003d6	0f 84 d8 01 00
	00		 je	 $LN4@listsort

; 2130 :         /* we cannot use list_clear() for this because it does not
; 2131 :            guarantee that the list is really empty when it returns */
; 2132 :         while (--i >= 0) {

  003dc	48 ff cf	 dec	 rdi
  003df	0f 88 b6 01 00
	00		 js	 $LN9@listsort
  003e5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL10@listsort:
  003f0	48 8b 1c fe	 mov	 rbx, QWORD PTR [rsi+rdi*8]

; 2133 :             Py_XDECREF(final_ob_item[i]);

  003f4	48 85 db	 test	 rbx, rbx
  003f7	0f 84 95 01 00
	00		 je	 $LN7@listsort
  003fd	e8 00 00 00 00	 call	 _Py_PXCTX
  00402	85 c0		 test	 eax, eax
  00404	0f 85 88 01 00
	00		 jne	 $LN7@listsort
  0040a	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0040e	a8 20		 test	 al, 32			; 00000020H
  00410	0f 85 74 01 00
	00		 jne	 $LN91@listsort
  00416	84 c0		 test	 al, al
  00418	0f 88 6c 01 00
	00		 js	 $LN91@listsort
  0041e	a8 02		 test	 al, 2
  00420	0f 85 6c 01 00
	00		 jne	 $LN7@listsort
  00426	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0042a	0f 85 62 01 00
	00		 jne	 $LN7@listsort
  00430	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00437	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0043e	4c 8b cb	 mov	 r9, rbx
  00441	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00447	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0044f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00454	48 8b cb	 mov	 rcx, rbx
  00457	85 c0		 test	 eax, eax
  00459	0f 84 1f 01 00
	00		 je	 $LN96@listsort
  0045f	e8 00 00 00 00	 call	 _Px_Dealloc
  00464	e9 29 01 00 00	 jmp	 $LN7@listsort
$LN56@listsort:

; 2034 :                     PyMem_FREE(keys);

  00469	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2035 :                 goto keyfunc_fail;

  0046f	e9 3c ff ff ff	 jmp	 $LN128@listsort
$succeed$21613:

; 2092 :         goto fail;
; 2093 :     assert(ms.n == 1);
; 2094 :     assert(keys == NULL
; 2095 :            ? ms.pending[0].base.keys == saved_ob_item
; 2096 :            : ms.pending[0].base.keys == &keys[0]);
; 2097 :     assert(ms.pending[0].len == saved_ob_size);
; 2098 :     lo = ms.pending[0].base;
; 2099 : 
; 2100 : succeed:
; 2101 :     result = Py_None;

  00474	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_NoneStruct
$fail$21623:

; 2102 : fail:
; 2103 :     if (keys != NULL) {
; 2104 :         for (i = 0; i < saved_ob_size; i++)

  0047b	4c 8b 7c 24 60	 mov	 r15, QWORD PTR saved_ob_size$1$[rsp]
  00480	4d 85 f6	 test	 r14, r14
  00483	0f 84 9e 00 00
	00		 je	 $LN59@listsort
  00489	33 ff		 xor	 edi, edi
  0048b	4d 85 ff	 test	 r15, r15
  0048e	7e 71		 jle	 SHORT $LN15@listsort
$LL17@listsort:

; 2105 :             Py_DECREF(keys[i]);

  00490	49 8b 1c fe	 mov	 rbx, QWORD PTR [r14+rdi*8]
  00494	e8 00 00 00 00	 call	 _Py_PXCTX
  00499	85 c0		 test	 eax, eax
  0049b	75 5c		 jne	 SHORT $LN16@listsort
  0049d	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  004a1	a8 20		 test	 al, 32			; 00000020H
  004a3	75 4c		 jne	 SHORT $LN80@listsort
  004a5	84 c0		 test	 al, al
  004a7	78 48		 js	 SHORT $LN80@listsort
  004a9	a8 02		 test	 al, 2
  004ab	75 4c		 jne	 SHORT $LN16@listsort
  004ad	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  004b1	75 46		 jne	 SHORT $LN16@listsort
  004b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  004ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  004c1	4c 8b cb	 mov	 r9, rbx
  004c4	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  004ca	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004d2	e8 00 00 00 00	 call	 _PyParallel_Guard
  004d7	48 8b cb	 mov	 rcx, rbx
  004da	85 c0		 test	 eax, eax
  004dc	74 07		 je	 SHORT $LN85@listsort
  004de	e8 00 00 00 00	 call	 _Px_Dealloc
  004e3	eb 14		 jmp	 SHORT $LN16@listsort
$LN85@listsort:
  004e5	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  004e9	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  004ef	eb 08		 jmp	 SHORT $LN16@listsort
$LN80@listsort:
  004f1	48 8b cb	 mov	 rcx, rbx
  004f4	e8 00 00 00 00	 call	 Px_DecRef
$LN16@listsort:

; 2102 : fail:
; 2103 :     if (keys != NULL) {
; 2104 :         for (i = 0; i < saved_ob_size; i++)

  004f9	48 ff c7	 inc	 rdi
  004fc	49 3b ff	 cmp	 rdi, r15
  004ff	7c 8f		 jl	 SHORT $LL17@listsort
$LN15@listsort:

; 2106 :         if (keys != &ms.temparray[saved_ob_size+1])

  00501	4a 8d 84 fd a8
	07 00 00	 lea	 rax, QWORD PTR ms$[rbp+r15*8+1832]
  00509	4c 3b f0	 cmp	 r14, rax
  0050c	74 19		 je	 SHORT $LN59@listsort

; 2107 :             PyMem_FREE(keys);

  0050e	e8 00 00 00 00	 call	 _Py_PXCTX
  00513	49 8b ce	 mov	 rcx, r14
  00516	85 c0		 test	 eax, eax
  00518	74 07		 je	 SHORT $LN58@listsort
  0051a	e8 00 00 00 00	 call	 _PxMem_Free
  0051f	eb 06		 jmp	 SHORT $LN59@listsort
$LN58@listsort:
  00521	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN59@listsort:

; 2108 :     }
; 2109 : 
; 2110 :     if (self->allocated != -1 && result != NULL) {

  00527	4c 8b ad e0 0f
	00 00		 mov	 r13, QWORD PTR self$[rbp-256]
  0052e	49 83 7d 78 ff	 cmp	 QWORD PTR [r13+120], -1
  00533	74 1b		 je	 SHORT $LN13@listsort
  00535	4d 85 e4	 test	 r12, r12
  00538	74 16		 je	 SHORT $LN13@listsort

; 2111 :         /* The user mucked with the list during the sort,
; 2112 :          * and we don't already have another error to report.
; 2113 :          */
; 2114 :         PyErr_SetString(PyExc_ValueError, "list modified during sort");

  0053a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00541	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@BOEBAINE@list?5modified?5during?5sort?$AA@
  00548	e8 00 00 00 00	 call	 PyErr_SetString

; 2115 :         result = NULL;

  0054d	45 33 e4	 xor	 r12d, r12d
$LN13@listsort:

; 2116 :     }
; 2117 : 
; 2118 :     if (reverse && saved_ob_size > 1)

  00550	83 bd e8 0f 00
	00 00		 cmp	 DWORD PTR reverse$[rbp-256], 0

; 2119 :         reverse_slice(saved_ob_item, saved_ob_item + saved_ob_size);

  00557	48 8b 5c 24 30	 mov	 rbx, QWORD PTR saved_ob_item$1$[rsp]
  0055c	74 12		 je	 SHORT $LN12@listsort

; 2116 :     }
; 2117 : 
; 2118 :     if (reverse && saved_ob_size > 1)

  0055e	49 83 ff 01	 cmp	 r15, 1
  00562	7e 0c		 jle	 SHORT $LN12@listsort

; 2119 :         reverse_slice(saved_ob_item, saved_ob_item + saved_ob_size);

  00564	4a 8d 14 fb	 lea	 rdx, QWORD PTR [rbx+r15*8]
  00568	48 8b cb	 mov	 rcx, rbx
  0056b	e8 00 00 00 00	 call	 reverse_slice
$LN12@listsort:

; 2120 : 
; 2121 :     merge_freemem(&ms);

  00570	48 8d 4d 80	 lea	 rcx, QWORD PTR ms$[rbp-256]
  00574	e8 00 00 00 00	 call	 merge_freemem
  00579	e9 3c fe ff ff	 jmp	 $keyfunc_fail$21610

; 2133 :             Py_XDECREF(final_ob_item[i]);

$LN96@listsort:
  0057e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00582	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00588	eb 08		 jmp	 SHORT $LN7@listsort
$LN91@listsort:
  0058a	48 8b cb	 mov	 rcx, rbx
  0058d	e8 00 00 00 00	 call	 Px_DecRef
$LN7@listsort:

; 2130 :         /* we cannot use list_clear() for this because it does not
; 2131 :            guarantee that the list is really empty when it returns */
; 2132 :         while (--i >= 0) {

  00592	48 ff cf	 dec	 rdi
  00595	0f 89 55 fe ff
	ff		 jns	 $LL10@listsort
$LN9@listsort:

; 2134 :         }
; 2135 :         PyMem_FREE(final_ob_item);

  0059b	e8 00 00 00 00	 call	 _Py_PXCTX
  005a0	48 8b ce	 mov	 rcx, rsi
  005a3	85 c0		 test	 eax, eax
  005a5	74 07		 je	 SHORT $LN60@listsort
  005a7	e8 00 00 00 00	 call	 _PxMem_Free
  005ac	eb 06		 jmp	 SHORT $LN4@listsort
$LN60@listsort:
  005ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@listsort:

; 2136 :     }
; 2137 :     Py_XINCREF(result);

  005b4	4d 85 e4	 test	 r12, r12
  005b7	74 3e		 je	 SHORT $LN3@listsort
  005b9	e8 00 00 00 00	 call	 _Py_PXCTX
  005be	85 c0		 test	 eax, eax
  005c0	75 35		 jne	 SHORT $LN3@listsort
  005c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  005c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  005d0	4d 8b cc	 mov	 r9, r12
  005d3	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  005d9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  005e1	e8 00 00 00 00	 call	 _PyParallel_Guard
  005e6	85 c0		 test	 eax, eax
  005e8	75 08		 jne	 SHORT $LN98@listsort
  005ea	41 f6 44 24 20
	20		 test	 BYTE PTR [r12+32], 32	; 00000020H
  005f0	74 05		 je	 SHORT $LN3@listsort
$LN98@listsort:
  005f2	49 ff 44 24 50	 inc	 QWORD PTR [r12+80]
$LN3@listsort:

; 2138 :     return result;

  005f7	49 8b c4	 mov	 rax, r12
  005fa	eb 02		 jmp	 SHORT $LN134@listsort
$LN115@listsort:

; 2024 :                 return NULL;

  005fc	33 c0		 xor	 eax, eax
$LN134@listsort:
  005fe	4c 8b b4 24 a8
	10 00 00	 mov	 r14, QWORD PTR [rsp+4264]
  00606	4c 8b a4 24 b0
	10 00 00	 mov	 r12, QWORD PTR [rsp+4272]
  0060e	48 8b bc 24 f0
	10 00 00	 mov	 rdi, QWORD PTR [rsp+4336]
  00616	4c 8b bc 24 a0
	10 00 00	 mov	 r15, QWORD PTR [rsp+4256]

; 2139 : }

  0061e	48 81 c4 b8 10
	00 00		 add	 rsp, 4280		; 000010b8H
  00625	41 5d		 pop	 r13
  00627	5e		 pop	 rsi
  00628	5b		 pop	 rbx
  00629	5d		 pop	 rbp
  0062a	c3		 ret	 0
listsort ENDP
_TEXT	ENDS
PUBLIC	PyList_Sort
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_Sort DD imagerel $LN7
	DD	imagerel $LN7+80
	DD	imagerel $unwind$PyList_Sort
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_Sort DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyList_Sort
_TEXT	SEGMENT
v$ = 48
PyList_Sort PROC					; COMDAT

; 2145 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2146 :     if (v == NULL || !PyList_Check(v)) {

  00004	48 85 c9	 test	 rcx, rcx
  00007	74 2e		 je	 SHORT $LN2@PyList_Sor
  00009	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000d	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  00017	74 1e		 je	 SHORT $LN2@PyList_Sor

; 2149 :     }
; 2150 :     /*
; 2151 :     if (Px_CHECK_PROTECTION(v, NULL, NULL))
; 2152 :         return -1;
; 2153 :     */
; 2154 :     v = listsort((PyListObject *)v, (PyObject *)NULL, (PyObject *)NULL);

  00019	45 33 c0	 xor	 r8d, r8d
  0001c	33 d2		 xor	 edx, edx
  0001e	e8 00 00 00 00	 call	 listsort

; 2155 :     if (v == NULL)

  00023	48 85 c0	 test	 rax, rax

; 2156 :         return -1;

  00026	74 20		 je	 SHORT $LN6@PyList_Sor

; 2157 :     Py_DECREF(v);

  00028	48 8b c8	 mov	 rcx, rax
  0002b	e8 00 00 00 00	 call	 _Py_DecRef

; 2158 :     return 0;

  00030	33 c0		 xor	 eax, eax

; 2159 : }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00036	c3		 ret	 0
$LN2@PyList_Sor:

; 2147 :         PyErr_BadInternalCall();

  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0003e	ba 63 08 00 00	 mov	 edx, 2147		; 00000863H
  00043	e8 00 00 00 00	 call	 _PyErr_BadInternalCall
$LN6@PyList_Sor:

; 2148 :         return -1;

  00048	83 c8 ff	 or	 eax, -1

; 2159 : }

  0004b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004f	c3		 ret	 0
PyList_Sort ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$listreverse DD imagerel listreverse
	DD	imagerel listreverse+134
	DD	imagerel $unwind$listreverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listreverse DD 032001H
	DD	063420H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT listreverse
_TEXT	SEGMENT
self$ = 64
listreverse PROC					; COMDAT

; 2163 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2164 :     if (Py_SIZE(self) > 1)

  00004	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00008	48 83 f8 01	 cmp	 rax, 1
  0000c	7e 0d		 jle	 SHORT $LN1@listrevers

; 2165 :         reverse_slice(self->ob_item, self->ob_item + Py_SIZE(self));

  0000e	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00012	48 8d 14 c1	 lea	 rdx, QWORD PTR [rcx+rax*8]
  00016	e8 00 00 00 00	 call	 reverse_slice
$LN1@listrevers:

; 2166 :     Py_RETURN_NONE;

  0001b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00020	e8 00 00 00 00	 call	 _Py_PXCTX
  00025	85 c0		 test	 eax, eax
  00027	75 4c		 jne	 SHORT $LN8@listrevers
  00029	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0003e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00044	4c 8b cb	 mov	 r9, rbx
  00047	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0004f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00054	85 c0		 test	 eax, eax
  00056	75 09		 jne	 SHORT $LN4@listrevers
  00058	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0005f	74 07		 je	 SHORT $LN10@listrevers
$LN4@listrevers:
  00061	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN10@listrevers:
  00068	48 8b c3	 mov	 rax, rbx
  0006b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 2167 : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
$LN8@listrevers:

; 2166 :     Py_RETURN_NONE;

  00075	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0007c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 2167 : }

  00081	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00085	c3		 ret	 0
listreverse ENDP
_TEXT	ENDS
PUBLIC	PyList_Reverse
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyList_Reverse DD imagerel $LN6
	DD	imagerel $LN6+80
	DD	imagerel $unwind$PyList_Reverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_Reverse DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyList_Reverse
_TEXT	SEGMENT
v$ = 48
PyList_Reverse PROC					; COMDAT

; 2171 : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2172 :     PyListObject *self = (PyListObject *)v;
; 2173 : 
; 2174 :     /*
; 2175 :     if (Px_CHECK_PROTECTION(v, NULL, NULL))
; 2176 :         return -1;
; 2177 :     */
; 2178 : 
; 2179 :     if (v == NULL || !PyList_Check(v)) {

  00004	48 85 c9	 test	 rcx, rcx
  00007	74 2e		 je	 SHORT $LN2@PyList_Rev
  00009	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000d	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  00017	74 1e		 je	 SHORT $LN2@PyList_Rev

; 2182 :     }
; 2183 :     if (Py_SIZE(self) > 1)

  00019	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  0001d	48 83 f8 01	 cmp	 rax, 1
  00021	7e 0d		 jle	 SHORT $LN1@PyList_Rev

; 2184 :         reverse_slice(self->ob_item, self->ob_item + Py_SIZE(self));

  00023	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00027	48 8d 14 c1	 lea	 rdx, QWORD PTR [rcx+rax*8]
  0002b	e8 00 00 00 00	 call	 reverse_slice
$LN1@PyList_Rev:

; 2185 :     return 0;

  00030	33 c0		 xor	 eax, eax

; 2186 : }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00036	c3		 ret	 0
$LN2@PyList_Rev:

; 2180 :         PyErr_BadInternalCall();

  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0003e	ba 84 08 00 00	 mov	 edx, 2180		; 00000884H
  00043	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2181 :         return -1;

  00048	83 c8 ff	 or	 eax, -1

; 2186 : }

  0004b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004f	c3		 ret	 0
PyList_Reverse ENDP
_TEXT	ENDS
PUBLIC	PyList_AsTuple
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyList_AsTuple DD imagerel $LN16
	DD	imagerel $LN16+38
	DD	imagerel $unwind$PyList_AsTuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyList_AsTuple DD imagerel $LN16+38
	DD	imagerel $LN16+84
	DD	imagerel $chain$1$PyList_AsTuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyList_AsTuple DD imagerel $LN16+84
	DD	imagerel $LN16+102
	DD	imagerel $chain$4$PyList_AsTuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyList_AsTuple DD imagerel $LN16+102
	DD	imagerel $LN16+199
	DD	imagerel $chain$5$PyList_AsTuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$PyList_AsTuple DD imagerel $LN16+199
	DD	imagerel $LN16+223
	DD	imagerel $chain$6$PyList_AsTuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$PyList_AsTuple DD imagerel $LN16+223
	DD	imagerel $LN16+248
	DD	imagerel $chain$7$PyList_AsTuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$PyList_AsTuple DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+38
	DD	imagerel $unwind$PyList_AsTuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$PyList_AsTuple DD 021H
	DD	imagerel $LN16+84
	DD	imagerel $LN16+102
	DD	imagerel $chain$4$PyList_AsTuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyList_AsTuple DD 020521H
	DD	083405H
	DD	imagerel $LN16+84
	DD	imagerel $LN16+102
	DD	imagerel $chain$4$PyList_AsTuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyList_AsTuple DD 060c21H
	DD	09540cH
	DD	0bc400H
	DD	0a6400H
	DD	imagerel $LN16
	DD	imagerel $LN16+38
	DD	imagerel $unwind$PyList_AsTuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyList_AsTuple DD 040e21H
	DD	0bc40eH
	DD	0a6405H
	DD	imagerel $LN16
	DD	imagerel $LN16+38
	DD	imagerel $unwind$PyList_AsTuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyList_AsTuple DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT PyList_AsTuple
_TEXT	SEGMENT
v$ = 64
PyList_AsTuple PROC					; COMDAT

; 2190 : {

$LN16:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b f9	 mov	 rdi, rcx

; 2191 :     PyObject *w;
; 2192 :     PyObject **p, **q;
; 2193 :     Py_ssize_t n;
; 2194 :     if (v == NULL || !PyList_Check(v)) {

  00009	48 85 c9	 test	 rcx, rcx
  0000c	0f 84 cd 00 00
	00		 je	 $LN4@PyList_AsT
  00012	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00016	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  00020	0f 84 b9 00 00
	00		 je	 $LN4@PyList_AsT

; 2197 :     }
; 2198 :     n = Py_SIZE(v);

  00026	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0002b	48 8b 71 60	 mov	 rsi, QWORD PTR [rcx+96]
  0002f	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12

; 2199 :     w = PyTuple_New(n);

  00034	48 8b ce	 mov	 rcx, rsi
  00037	e8 00 00 00 00	 call	 PyTuple_New
  0003c	4c 8b e0	 mov	 r12, rax

; 2200 :     if (w == NULL)

  0003f	48 85 c0	 test	 rax, rax
  00042	75 10		 jne	 SHORT $LN3@PyList_AsT
  00044	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00049	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]

; 2211 : }

  0004e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
$LN3@PyList_AsT:

; 2201 :         return NULL;
; 2202 :     p = ((PyTupleObject *)w)->ob_item;
; 2203 :     q = ((PyListObject *)v)->ob_item;
; 2204 :     while (--n >= 0) {

  00054	48 ff ce	 dec	 rsi
  00057	48 8b 7f 70	 mov	 rdi, QWORD PTR [rdi+112]
  0005b	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  00060	48 8d 68 70	 lea	 rbp, QWORD PTR [rax+112]
  00064	78 61		 js	 SHORT $LN1@PyList_AsT
  00066	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0006b	0f 1f 44 00 00	 npad	 5
$LL2@PyList_AsT:

; 2205 :         Py_INCREF(*q);

  00070	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00073	e8 00 00 00 00	 call	 _Py_PXCTX
  00078	85 c0		 test	 eax, eax
  0007a	75 32		 jne	 SHORT $LN9@PyList_AsT
  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0008a	4c 8b cb	 mov	 r9, rbx
  0008d	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00093	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0009b	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a0	85 c0		 test	 eax, eax
  000a2	75 06		 jne	 SHORT $LN8@PyList_AsT
  000a4	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000a8	74 04		 je	 SHORT $LN9@PyList_AsT
$LN8@PyList_AsT:
  000aa	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN9@PyList_AsT:

; 2206 :         *p = *q;

  000ae	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 2207 :         p++;

  000b1	48 83 c5 08	 add	 rbp, 8

; 2208 :         q++;

  000b5	48 83 c7 08	 add	 rdi, 8
  000b9	48 ff ce	 dec	 rsi
  000bc	48 89 45 f8	 mov	 QWORD PTR [rbp-8], rax
  000c0	79 ae		 jns	 SHORT $LL2@PyList_AsT
  000c2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN1@PyList_AsT:
  000c7	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000cc	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 2209 :     }
; 2210 :     return w;

  000d1	49 8b c4	 mov	 rax, r12
  000d4	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]

; 2211 : }

  000d9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000dd	5f		 pop	 rdi
  000de	c3		 ret	 0
$LN4@PyList_AsT:

; 2195 :         PyErr_BadInternalCall();

  000df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  000e6	ba 93 08 00 00	 mov	 edx, 2195		; 00000893H
  000eb	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2196 :         return NULL;

  000f0	33 c0		 xor	 eax, eax

; 2211 : }

  000f2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f6	5f		 pop	 rdi
  000f7	c3		 ret	 0
PyList_AsTuple ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@NCOFMKDI@?$CFR?5is?5not?5in?5list?$AA@ ; `string'
PUBLIC	??_C@_0N@GKKDPPOM@O?$HMO?$CGO?$CG?3index?$AA@	; `string'
EXTRN	PyLong_FromSsize_t:PROC
EXTRN	_PyEval_SliceIndex:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$listindex DD imagerel listindex
	DD	imagerel listindex+88
	DD	imagerel $unwind$listindex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$listindex DD imagerel listindex+88
	DD	imagerel listindex+228
	DD	imagerel $chain$0$listindex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$listindex DD imagerel listindex+228
	DD	imagerel listindex+248
	DD	imagerel $chain$2$listindex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$listindex DD 020021H
	DD	083400H
	DD	imagerel listindex
	DD	imagerel listindex+88
	DD	imagerel $unwind$listindex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$listindex DD 020521H
	DD	083405H
	DD	imagerel listindex
	DD	imagerel listindex+88
	DD	imagerel $unwind$listindex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listindex DD 030901H
	DD	070058209H
	DD	06004H
xdata	ENDS
;	COMDAT ??_C@_0BC@NCOFMKDI@?$CFR?5is?5not?5in?5list?$AA@
CONST	SEGMENT
??_C@_0BC@NCOFMKDI@?$CFR?5is?5not?5in?5list?$AA@ DB '%R is not in list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GKKDPPOM@O?$HMO?$CGO?$CG?3index?$AA@
CONST	SEGMENT
??_C@_0N@GKKDPPOM@O?$HMO?$CGO?$CG?3index?$AA@ DB 'O|O&O&:index', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT listindex
_TEXT	SEGMENT
stop$ = 96
self$ = 96
args$ = 104
start$ = 112
v$ = 120
listindex PROC						; COMDAT

; 2215 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2216 :     Py_ssize_t i, start=0, stop=Py_SIZE(self);

  00009	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  0000d	4c 8b d2	 mov	 r10, rdx

; 2217 :     PyObject *v;
; 2218 : 
; 2219 :     if (!PyArg_ParseTuple(args, "O|O&O&:index", &v,
; 2220 :                                 _PyEval_SliceIndex, &start,
; 2221 :                                 _PyEval_SliceIndex, &stop))

  00010	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_PyEval_SliceIndex
  00017	49 89 43 08	 mov	 QWORD PTR [r11+8], rax
  0001b	49 8d 43 08	 lea	 rax, QWORD PTR [r11+8]
  0001f	48 8b f9	 mov	 rdi, rcx
  00022	49 89 43 d8	 mov	 QWORD PTR [r11-40], rax
  00026	49 8d 43 18	 lea	 rax, QWORD PTR [r11+24]
  0002a	4d 89 4b d0	 mov	 QWORD PTR [r11-48], r9
  0002e	4d 8d 43 20	 lea	 r8, QWORD PTR [r11+32]
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@GKKDPPOM@O?$HMO?$CGO?$CG?3index?$AA@
  00039	33 f6		 xor	 esi, esi
  0003b	49 8b ca	 mov	 rcx, r10
  0003e	49 89 43 c8	 mov	 QWORD PTR [r11-56], rax
  00042	49 89 73 18	 mov	 QWORD PTR [r11+24], rsi
  00046	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0004b	85 c0		 test	 eax, eax
  0004d	75 09		 jne	 SHORT $LN11@listindex

; 2222 :         return NULL;

  0004f	33 c0		 xor	 eax, eax

; 2242 : }

  00051	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00055	5f		 pop	 rdi
  00056	5e		 pop	 rsi
  00057	c3		 ret	 0
$LN11@listindex:
  00058	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 2223 :     if (start < 0) {

  0005d	48 8b 5c 24 70	 mov	 rbx, QWORD PTR start$[rsp]
  00062	48 85 db	 test	 rbx, rbx
  00065	79 0d		 jns	 SHORT $LN9@listindex

; 2224 :         start += Py_SIZE(self);

  00067	48 03 5f 60	 add	 rbx, QWORD PTR [rdi+96]

; 2225 :         if (start < 0)

  0006b	48 0f 48 de	 cmovs	 rbx, rsi
  0006f	48 89 5c 24 70	 mov	 QWORD PTR start$[rsp], rbx
$LN9@listindex:

; 2226 :             start = 0;
; 2227 :     }
; 2228 :     if (stop < 0) {

  00074	48 8b 44 24 60	 mov	 rax, QWORD PTR stop$[rsp]
  00079	48 85 c0	 test	 rax, rax
  0007c	79 0d		 jns	 SHORT $LN7@listindex

; 2229 :         stop += Py_SIZE(self);

  0007e	48 03 47 60	 add	 rax, QWORD PTR [rdi+96]

; 2230 :         if (stop < 0)

  00082	48 0f 48 c6	 cmovs	 rax, rsi
  00086	48 89 44 24 60	 mov	 QWORD PTR stop$[rsp], rax
$LN7@listindex:

; 2231 :             stop = 0;
; 2232 :     }
; 2233 :     for (i = start; i < stop && i < Py_SIZE(self); i++) {

  0008b	48 3b d8	 cmp	 rbx, rax
  0008e	7d 2e		 jge	 SHORT $LN4@listindex
$LL6@listindex:
  00090	48 3b 5f 60	 cmp	 rbx, QWORD PTR [rdi+96]
  00094	7d 28		 jge	 SHORT $LN4@listindex

; 2234 :         int cmp = PyObject_RichCompareBool(self->ob_item[i], v, Py_EQ);

  00096	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  0009a	48 8b 54 24 78	 mov	 rdx, QWORD PTR v$[rsp]
  0009f	41 b8 02 00 00
	00		 mov	 r8d, 2
  000a5	48 8b 0c d9	 mov	 rcx, QWORD PTR [rcx+rbx*8]
  000a9	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 2235 :         if (cmp > 0)

  000ae	85 c0		 test	 eax, eax
  000b0	7f 32		 jg	 SHORT $LN15@listindex

; 2237 :         else if (cmp < 0)

  000b2	78 22		 js	 SHORT $LN16@listindex

; 2231 :             stop = 0;
; 2232 :     }
; 2233 :     for (i = start; i < stop && i < Py_SIZE(self); i++) {

  000b4	48 ff c3	 inc	 rbx
  000b7	48 3b 5c 24 60	 cmp	 rbx, QWORD PTR stop$[rsp]
  000bc	7c d2		 jl	 SHORT $LL6@listindex
$LN4@listindex:

; 2238 :             return NULL;
; 2239 :     }
; 2240 :     PyErr_Format(PyExc_ValueError, "%R is not in list", v);

  000be	4c 8b 44 24 78	 mov	 r8, QWORD PTR v$[rsp]
  000c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@NCOFMKDI@?$CFR?5is?5not?5in?5list?$AA@
  000d1	e8 00 00 00 00	 call	 PyErr_Format
$LN16@listindex:

; 2241 :     return NULL;

  000d6	33 c0		 xor	 eax, eax
  000d8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2242 : }

  000dd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e1	5f		 pop	 rdi
  000e2	5e		 pop	 rsi
  000e3	c3		 ret	 0
$LN15@listindex:

; 2236 :             return PyLong_FromSsize_t(i);

  000e4	48 8b cb	 mov	 rcx, rbx
  000e7	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  000ec	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2242 : }

  000f1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f5	5f		 pop	 rdi
  000f6	5e		 pop	 rsi
  000f7	c3		 ret	 0
listindex ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$listcount DD imagerel listcount
	DD	imagerel listcount+123
	DD	imagerel $unwind$listcount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listcount DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT listcount
_TEXT	SEGMENT
self$ = 48
v$ = 56
listcount PROC						; COMDAT

; 2246 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2247 :     Py_ssize_t count = 0;

  00014	33 ff		 xor	 edi, edi
  00016	48 8b ea	 mov	 rbp, rdx
  00019	48 8b f1	 mov	 rsi, rcx

; 2248 :     Py_ssize_t i;
; 2249 : 
; 2250 :     for (i = 0; i < Py_SIZE(self); i++) {

  0001c	8b df		 mov	 ebx, edi
  0001e	48 39 59 60	 cmp	 QWORD PTR [rcx+96], rbx
  00022	7e 36		 jle	 SHORT $LN4@listcount
  00024	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL6@listcount:

; 2251 :         int cmp = PyObject_RichCompareBool(self->ob_item[i], v, Py_EQ);

  00030	48 8b 4e 70	 mov	 rcx, QWORD PTR [rsi+112]
  00034	41 b8 02 00 00
	00		 mov	 r8d, 2
  0003a	48 8b d5	 mov	 rdx, rbp
  0003d	48 8b 0c d9	 mov	 rcx, QWORD PTR [rcx+rbx*8]
  00041	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 2252 :         if (cmp > 0)

  00046	85 c0		 test	 eax, eax
  00048	7e 05		 jle	 SHORT $LN12@listcount

; 2253 :             count++;

  0004a	48 ff c7	 inc	 rdi
  0004d	eb 02		 jmp	 SHORT $LN5@listcount
$LN12@listcount:

; 2254 :         else if (cmp < 0)

  0004f	78 26		 js	 SHORT $LN10@listcount
$LN5@listcount:

; 2248 :     Py_ssize_t i;
; 2249 : 
; 2250 :     for (i = 0; i < Py_SIZE(self); i++) {

  00051	48 ff c3	 inc	 rbx
  00054	48 3b 5e 60	 cmp	 rbx, QWORD PTR [rsi+96]
  00058	7c d6		 jl	 SHORT $LL6@listcount
$LN4@listcount:

; 2256 :     }
; 2257 :     return PyLong_FromSsize_t(count);

  0005a	48 8b cf	 mov	 rcx, rdi
  0005d	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN7@listcount:

; 2258 : }

  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0006c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00071	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
$LN10@listcount:

; 2255 :             return NULL;

  00077	33 c0		 xor	 eax, eax
  00079	eb e7		 jmp	 SHORT $LN7@listcount
listcount ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@DNOMBHLJ@list?4remove?$CIx?$CJ?3?5x?5not?5in?5list?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$listremove DD imagerel listremove
	DD	imagerel listremove+220
	DD	imagerel $unwind$listremove
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listremove DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0BO@DNOMBHLJ@list?4remove?$CIx?$CJ?3?5x?5not?5in?5list?$AA@
CONST	SEGMENT
??_C@_0BO@DNOMBHLJ@list?4remove?$CIx?$CJ?3?5x?5not?5in?5list?$AA@ DB 'lis'
	DB	't.remove(x): x not in list', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
CONST	ENDS
;	COMDAT listremove
_TEXT	SEGMENT
self$ = 64
v$ = 72
listremove PROC						; COMDAT

; 2262 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2263 :     Py_ssize_t i;
; 2264 : 
; 2265 :     /*
; 2266 :     if (Px_PROTECTION_ERROR(self))
; 2267 :         return NULL;
; 2268 :     */
; 2269 : 
; 2270 :     for (i = 0; i < Py_SIZE(self); i++) {

  0000f	33 db		 xor	 ebx, ebx
  00011	48 8b f2	 mov	 rsi, rdx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	48 39 59 60	 cmp	 QWORD PTR [rcx+96], rbx
  0001b	7e 28		 jle	 SHORT $LN5@listremove
  0001d	0f 1f 00	 npad	 3
$LL7@listremove:

; 2271 :         int cmp = PyObject_RichCompareBool(self->ob_item[i], v, Py_EQ);

  00020	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  00024	41 b8 02 00 00
	00		 mov	 r8d, 2
  0002a	48 8b d6	 mov	 rdx, rsi
  0002d	48 8b 0c d9	 mov	 rcx, QWORD PTR [rcx+rbx*8]
  00031	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 2272 :         if (cmp > 0) {

  00036	85 c0		 test	 eax, eax
  00038	7f 30		 jg	 SHORT $LN15@listremove

; 2276 :             return NULL;
; 2277 :         }
; 2278 :         else if (cmp < 0)

  0003a	78 1c		 js	 SHORT $LN16@listremove

; 2263 :     Py_ssize_t i;
; 2264 : 
; 2265 :     /*
; 2266 :     if (Px_PROTECTION_ERROR(self))
; 2267 :         return NULL;
; 2268 :     */
; 2269 : 
; 2270 :     for (i = 0; i < Py_SIZE(self); i++) {

  0003c	48 ff c3	 inc	 rbx
  0003f	48 3b 5f 60	 cmp	 rbx, QWORD PTR [rdi+96]
  00043	7c db		 jl	 SHORT $LL7@listremove
$LN5@listremove:

; 2279 :             return NULL;
; 2280 :     }
; 2281 :     PyErr_SetString(PyExc_ValueError, "list.remove(x): x not in list");

  00045	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@DNOMBHLJ@list?4remove?$CIx?$CJ?3?5x?5not?5in?5list?$AA@
  00053	e8 00 00 00 00	 call	 PyErr_SetString
$LN16@listremove:

; 2282 :     return NULL;

  00058	33 c0		 xor	 eax, eax

; 2283 : }

  0005a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0005f	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00064	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00068	5f		 pop	 rdi
  00069	c3		 ret	 0
$LN15@listremove:

; 2273 :             if (list_ass_slice(self, i, i+1,
; 2274 :                                (PyObject *)NULL) == 0)

  0006a	4c 8d 43 01	 lea	 r8, QWORD PTR [rbx+1]
  0006e	45 33 c9	 xor	 r9d, r9d
  00071	48 8b d3	 mov	 rdx, rbx
  00074	48 8b cf	 mov	 rcx, rdi
  00077	e8 00 00 00 00	 call	 list_ass_slice
  0007c	85 c0		 test	 eax, eax
  0007e	75 d8		 jne	 SHORT $LN16@listremove

; 2275 :                 Py_RETURN_NONE;

  00080	e8 00 00 00 00	 call	 _Py_PXCTX
  00085	85 c0		 test	 eax, eax
  00087	75 3c		 jne	 SHORT $LN11@listremove
  00089	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0009e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a4	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000ac	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b1	85 c0		 test	 eax, eax
  000b3	75 09		 jne	 SHORT $LN10@listremove
  000b5	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000bc	74 07		 je	 SHORT $LN11@listremove
$LN10@listremove:
  000be	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN11@listremove:

; 2283 : }

  000c5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ca	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000d6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000da	5f		 pop	 rdi
  000db	c3		 ret	 0
listremove ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@DJGDJDEC@list_traverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_traverse DD imagerel list_traverse
	DD	imagerel list_traverse+127
	DD	imagerel $unwind$list_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_traverse DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_0O@DJGDJDEC@list_traverse?$AA@
CONST	SEGMENT
??_C@_0O@DJGDJDEC@list_traverse?$AA@ DB 'list_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT list_traverse
_TEXT	SEGMENT
o$ = 48
visit$ = 56
arg$ = 64
list_traverse PROC					; COMDAT

; 2287 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2288 :     Py_ssize_t i;
; 2289 : 
; 2290 :     for (i = Py_SIZE(o); --i >= 0; )

  00014	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  00018	49 8b f0	 mov	 rsi, r8
  0001b	48 8b ea	 mov	 rbp, rdx
  0001e	48 ff cb	 dec	 rbx
  00021	48 8b f9	 mov	 rdi, rcx
  00024	78 42		 js	 SHORT $LN13@list_trave
$LL8@list_trave:

; 2291 :         Py_VISIT(o->ob_item[i]);

  00026	e8 00 00 00 00	 call	 _Py_PXCTX
  0002b	85 c0		 test	 eax, eax
  0002d	74 1c		 je	 SHORT $LN3@list_trave
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DJGDJDEC@list_traverse?$AA@
  0003d	45 33 c9	 xor	 r9d, r9d
  00040	41 b8 f3 08 00
	00		 mov	 r8d, 2291		; 000008f3H
  00046	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@list_trave:
  0004b	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  0004f	48 83 3c d9 00	 cmp	 QWORD PTR [rcx+rbx*8], 0
  00054	74 0d		 je	 SHORT $LN5@list_trave
  00056	48 8b 0c d9	 mov	 rcx, QWORD PTR [rcx+rbx*8]
  0005a	48 8b d6	 mov	 rdx, rsi
  0005d	ff d5		 call	 rbp
  0005f	85 c0		 test	 eax, eax
  00061	75 07		 jne	 SHORT $LN9@list_trave
$LN5@list_trave:

; 2288 :     Py_ssize_t i;
; 2289 : 
; 2290 :     for (i = Py_SIZE(o); --i >= 0; )

  00063	48 ff cb	 dec	 rbx
  00066	79 be		 jns	 SHORT $LL8@list_trave
$LN13@list_trave:

; 2292 :     return 0;

  00068	33 c0		 xor	 eax, eax
$LN9@list_trave:

; 2293 : }

  0006a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006f	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00074	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00079	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007d	5f		 pop	 rdi
  0007e	c3		 ret	 0
list_traverse ENDP
_TEXT	ENDS
EXTRN	_Py_NotImplementedStruct:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	PyObject_RichCompare:PROC
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$list_richcompare DD imagerel list_richcompare
	DD	imagerel list_richcompare+69
	DD	imagerel $unwind$list_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$list_richcompare DD imagerel list_richcompare+69
	DD	imagerel list_richcompare+138
	DD	imagerel $chain$0$list_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$list_richcompare DD imagerel list_richcompare+138
	DD	imagerel list_richcompare+310
	DD	imagerel $chain$1$list_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$list_richcompare DD imagerel list_richcompare+310
	DD	imagerel list_richcompare+332
	DD	imagerel $chain$2$list_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$list_richcompare DD imagerel list_richcompare+332
	DD	imagerel list_richcompare+621
	DD	imagerel $chain$4$list_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$list_richcompare DD imagerel list_richcompare+621
	DD	imagerel list_richcompare+716
	DD	imagerel $chain$5$list_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$list_richcompare DD imagerel list_richcompare+716
	DD	imagerel list_richcompare+740
	DD	imagerel $chain$6$list_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$list_richcompare DD 040021H
	DD	097400H
	DD	083400H
	DD	imagerel list_richcompare
	DD	imagerel list_richcompare+69
	DD	imagerel $unwind$list_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$list_richcompare DD 021H
	DD	imagerel list_richcompare
	DD	imagerel list_richcompare+69
	DD	imagerel $unwind$list_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$list_richcompare DD 040021H
	DD	097400H
	DD	083400H
	DD	imagerel list_richcompare
	DD	imagerel list_richcompare+69
	DD	imagerel $unwind$list_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$list_richcompare DD 021H
	DD	imagerel list_richcompare+69
	DD	imagerel list_richcompare+138
	DD	imagerel $chain$0$list_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$list_richcompare DD 020521H
	DD	097405H
	DD	imagerel list_richcompare+69
	DD	imagerel list_richcompare+138
	DD	imagerel $chain$0$list_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$list_richcompare DD 020521H
	DD	083405H
	DD	imagerel list_richcompare
	DD	imagerel list_richcompare+69
	DD	imagerel $unwind$list_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_richcompare DD 061001H
	DD	0b6410H
	DD	0a5410H
	DD	0c00c5210H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT list_richcompare
_TEXT	SEGMENT
v$ = 64
w$ = 72
op$ = 80
list_richcompare PROC					; COMDAT

; 2297 : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	41 54		 push	 r12
  0000c	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2298 :     PyListObject *vl, *wl;
; 2299 :     Py_ssize_t i;
; 2300 : 
; 2301 :     if (!PyList_Check(v) || !PyList_Check(w))

  00010	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00014	4d 63 e0	 movsxd	 r12, r8d
  00017	48 8b f2	 mov	 rsi, rdx
  0001a	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  00024	48 8b e9	 mov	 rbp, rcx
  00027	0f 84 40 02 00
	00		 je	 $LN25@list_richc
  0002d	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00031	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  0003b	0f 84 2c 02 00
	00		 je	 $LN25@list_richc

; 2303 : 
; 2304 :     vl = (PyListObject *)v;
; 2305 :     wl = (PyListObject *)w;
; 2306 : 
; 2307 :     if (Py_SIZE(vl) != Py_SIZE(wl) && (op == Py_EQ || op == Py_NE)) {

  00041	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00045	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0004a	48 3b 42 60	 cmp	 rax, QWORD PTR [rdx+96]
  0004e	74 3a		 je	 SHORT $LN24@list_richc
  00050	41 83 fc 02	 cmp	 r12d, 2
  00054	74 1d		 je	 SHORT $LN49@list_richc
  00056	41 83 fc 03	 cmp	 r12d, 3
  0005a	75 2e		 jne	 SHORT $LN24@list_richc

; 2312 :         else
; 2313 :             res = Py_True;

  0005c	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_TrueStruct

; 2314 :         Py_INCREF(res);

  00063	48 8b cb	 mov	 rcx, rbx
  00066	e8 00 00 00 00	 call	 _Py_IncRef

; 2315 :         return res;

  0006b	48 8b c3	 mov	 rax, rbx
  0006e	e9 c3 00 00 00	 jmp	 $LN51@list_richc
$LN49@list_richc:

; 2308 :         /* Shortcut: if the lengths differ, the lists differ */
; 2309 :         PyObject *res;
; 2310 :         if (op == Py_EQ)
; 2311 :             res = Py_False;

  00073	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct

; 2314 :         Py_INCREF(res);

  0007a	48 8b cb	 mov	 rcx, rbx
  0007d	e8 00 00 00 00	 call	 _Py_IncRef

; 2315 :         return res;

  00082	48 8b c3	 mov	 rax, rbx
  00085	e9 ac 00 00 00	 jmp	 $LN51@list_richc
$LN24@list_richc:
  0008a	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 2316 :     }
; 2317 : 
; 2318 :     /* Search for the first index where items are different */
; 2319 :     for (i = 0; i < Py_SIZE(vl) && i < Py_SIZE(wl); i++) {

  0008f	33 ff		 xor	 edi, edi
  00091	8b df		 mov	 ebx, edi
  00093	48 85 c0	 test	 rax, rax
  00096	7e 34		 jle	 SHORT $LN47@list_richc
$LL20@list_richc:
  00098	48 3b 5e 60	 cmp	 rbx, QWORD PTR [rsi+96]
  0009c	7d 2e		 jge	 SHORT $LN47@list_richc

; 2320 :         int k = PyObject_RichCompareBool(vl->ob_item[i],
; 2321 :                                          wl->ob_item[i], Py_EQ);

  0009e	48 8b 56 70	 mov	 rdx, QWORD PTR [rsi+112]
  000a2	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  000a6	41 b8 02 00 00
	00		 mov	 r8d, 2
  000ac	48 8b 14 da	 mov	 rdx, QWORD PTR [rdx+rbx*8]
  000b0	48 8b 0c d9	 mov	 rcx, QWORD PTR [rcx+rbx*8]
  000b4	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 2322 :         if (k < 0)

  000b9	85 c0		 test	 eax, eax
  000bb	0f 88 a5 01 00
	00		 js	 $LN5@list_richc

; 2323 :             return NULL;
; 2324 :         if (!k)

  000c1	74 09		 je	 SHORT $LN47@list_richc

; 2316 :     }
; 2317 : 
; 2318 :     /* Search for the first index where items are different */
; 2319 :     for (i = 0; i < Py_SIZE(vl) && i < Py_SIZE(wl); i++) {

  000c3	48 ff c3	 inc	 rbx
  000c6	48 3b 5d 60	 cmp	 rbx, QWORD PTR [rbp+96]
  000ca	7c cc		 jl	 SHORT $LL20@list_richc
$LN47@list_richc:

; 2325 :             break;
; 2326 :     }
; 2327 : 
; 2328 :     if (i >= Py_SIZE(vl) || i >= Py_SIZE(wl)) {

  000cc	48 8b 55 60	 mov	 rdx, QWORD PTR [rbp+96]
  000d0	48 3b da	 cmp	 rbx, rdx
  000d3	0f 8d e0 00 00
	00		 jge	 $LN14@list_richc
  000d9	48 3b 5e 60	 cmp	 rbx, QWORD PTR [rsi+96]
  000dd	0f 8d d6 00 00
	00		 jge	 $LN14@list_richc

; 2349 :     }
; 2350 : 
; 2351 :     /* We have an item that differs -- shortcuts for EQ/NE */
; 2352 :     if (op == Py_EQ) {

  000e3	41 83 fc 02	 cmp	 r12d, 2
  000e7	75 63		 jne	 SHORT $LN2@list_richc

; 2353 :         Py_INCREF(Py_False);

  000e9	e8 00 00 00 00	 call	 _Py_PXCTX
  000ee	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  000f5	85 c0		 test	 eax, eax
  000f7	75 35		 jne	 SHORT $LN38@list_richc
  000f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00107	4c 8b cb	 mov	 r9, rbx
  0010a	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00110	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  00115	e8 00 00 00 00	 call	 _PyParallel_Guard
  0011a	85 c0		 test	 eax, eax
  0011c	75 09		 jne	 SHORT $LN37@list_richc
  0011e	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  00125	74 07		 je	 SHORT $LN38@list_richc
$LN37@list_richc:
  00127	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN38@list_richc:

; 2354 :         return Py_False;

  0012e	48 8b c3	 mov	 rax, rbx
$LN52@list_richc:
  00131	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
$LN51@list_richc:
  00136	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2363 : }

  0013b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00140	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00145	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00149	41 5c		 pop	 r12
  0014b	c3		 ret	 0
$LN2@list_richc:

; 2355 :     }
; 2356 :     if (op == Py_NE) {

  0014c	41 83 fc 03	 cmp	 r12d, 3
  00150	75 4a		 jne	 SHORT $LN1@list_richc

; 2357 :         Py_INCREF(Py_True);

  00152	e8 00 00 00 00	 call	 _Py_PXCTX
  00157	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_TrueStruct
  0015e	85 c0		 test	 eax, eax
  00160	75 cc		 jne	 SHORT $LN38@list_richc
  00162	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00169	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00170	4c 8b cb	 mov	 r9, rbx
  00173	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00179	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00181	e8 00 00 00 00	 call	 _PyParallel_Guard
  00186	85 c0		 test	 eax, eax
  00188	75 09		 jne	 SHORT $LN41@list_richc
  0018a	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  00191	74 9b		 je	 SHORT $LN38@list_richc
$LN41@list_richc:
  00193	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80

; 2358 :         return Py_True;

  0019a	eb 92		 jmp	 SHORT $LN38@list_richc
$LN1@list_richc:

; 2359 :     }
; 2360 : 
; 2361 :     /* Compare the final item again using the proper operator */
; 2362 :     return PyObject_RichCompare(vl->ob_item[i], wl->ob_item[i], op);

  0019c	48 8b 56 70	 mov	 rdx, QWORD PTR [rsi+112]
  001a0	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  001a4	45 8b c4	 mov	 r8d, r12d
  001a7	48 8b 14 da	 mov	 rdx, QWORD PTR [rdx+rbx*8]
  001ab	48 8b 0c d9	 mov	 rcx, QWORD PTR [rcx+rbx*8]
  001af	e8 00 00 00 00	 call	 PyObject_RichCompare
  001b4	e9 78 ff ff ff	 jmp	 $LN52@list_richc
$LN14@list_richc:

; 2329 :         /* No more items to compare -- compare sizes */
; 2330 :         Py_ssize_t vs = Py_SIZE(vl);
; 2331 :         Py_ssize_t ws = Py_SIZE(wl);

  001b9	4c 8b 46 60	 mov	 r8, QWORD PTR [rsi+96]

; 2332 :         int cmp;
; 2333 :         PyObject *res;
; 2334 :         switch (op) {

  001bd	41 83 fc 05	 cmp	 r12d, 5
  001c1	0f 87 9f 00 00
	00		 ja	 $LN5@list_richc
  001c7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:__ImageBase
  001ce	43 8b 8c a1 00
	00 00 00	 mov	 ecx, DWORD PTR $LN50@list_richc[r9+r12*4]
  001d6	49 03 c9	 add	 rcx, r9
  001d9	ff e1		 jmp	 rcx
$LN11@list_richc:

; 2335 :         case Py_LT: cmp = vs <  ws; break;

  001db	49 3b d0	 cmp	 rdx, r8
  001de	40 0f 9c c7	 setl	 dil
  001e2	eb 2b		 jmp	 SHORT $LN12@list_richc
$LN10@list_richc:

; 2336 :         case Py_LE: cmp = vs <= ws; break;

  001e4	49 3b d0	 cmp	 rdx, r8
  001e7	40 0f 9e c7	 setle	 dil
  001eb	eb 22		 jmp	 SHORT $LN12@list_richc
$LN9@list_richc:

; 2337 :         case Py_EQ: cmp = vs == ws; break;

  001ed	49 3b d0	 cmp	 rdx, r8
  001f0	40 0f 94 c7	 sete	 dil
  001f4	eb 19		 jmp	 SHORT $LN12@list_richc
$LN8@list_richc:

; 2338 :         case Py_NE: cmp = vs != ws; break;

  001f6	49 3b d0	 cmp	 rdx, r8
  001f9	40 0f 95 c7	 setne	 dil
  001fd	eb 10		 jmp	 SHORT $LN12@list_richc
$LN7@list_richc:

; 2339 :         case Py_GT: cmp = vs >  ws; break;

  001ff	49 3b d0	 cmp	 rdx, r8
  00202	40 0f 9f c7	 setg	 dil
  00206	eb 07		 jmp	 SHORT $LN12@list_richc
$LN6@list_richc:

; 2340 :         case Py_GE: cmp = vs >= ws; break;

  00208	49 3b d0	 cmp	 rdx, r8
  0020b	40 0f 9d c7	 setge	 dil
$LN12@list_richc:

; 2342 :         }
; 2343 :         if (cmp)

  0020f	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_TrueStruct
  00216	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  0021d	85 ff		 test	 edi, edi
  0021f	48 0f 44 f3	 cmove	 rsi, rbx

; 2344 :             res = Py_True;
; 2345 :         else
; 2346 :             res = Py_False;
; 2347 :         Py_INCREF(res);

  00223	e8 00 00 00 00	 call	 _Py_PXCTX
  00228	85 c0		 test	 eax, eax
  0022a	75 32		 jne	 SHORT $LN34@list_richc
  0022c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00233	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0023a	4c 8b ce	 mov	 r9, rsi
  0023d	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00243	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0024b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00250	85 c0		 test	 eax, eax
  00252	75 06		 jne	 SHORT $LN33@list_richc
  00254	f6 46 20 20	 test	 BYTE PTR [rsi+32], 32	; 00000020H
  00258	74 04		 je	 SHORT $LN34@list_richc
$LN33@list_richc:
  0025a	48 ff 46 50	 inc	 QWORD PTR [rsi+80]
$LN34@list_richc:

; 2348 :         return res;

  0025e	48 8b c6	 mov	 rax, rsi
  00261	e9 cb fe ff ff	 jmp	 $LN52@list_richc
$LN5@list_richc:

; 2341 :         default: return NULL; /* cannot happen */

  00266	33 c0		 xor	 eax, eax
  00268	e9 c4 fe ff ff	 jmp	 $LN52@list_richc
$LN25@list_richc:

; 2302 :         Py_RETURN_NOTIMPLEMENTED;

  0026d	e8 00 00 00 00	 call	 _Py_PXCTX
  00272	85 c0		 test	 eax, eax
  00274	75 3c		 jne	 SHORT $LN30@list_richc
  00276	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  0027d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00284	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0028b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00291	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00299	e8 00 00 00 00	 call	 _PyParallel_Guard
  0029e	85 c0		 test	 eax, eax
  002a0	75 09		 jne	 SHORT $LN29@list_richc
  002a2	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  002a9	74 07		 je	 SHORT $LN30@list_richc
$LN29@list_richc:
  002ab	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN30@list_richc:

; 2363 : }

  002b2	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  002b7	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  002bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  002c3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002c7	41 5c		 pop	 r12
  002c9	c3		 ret	 0
  002ca	66 90		 npad	 2
$LN50@list_richc:
  002cc	00 00 00 00	 DD	 $LN11@list_richc
  002d0	00 00 00 00	 DD	 $LN10@list_richc
  002d4	00 00 00 00	 DD	 $LN9@list_richc
  002d8	00 00 00 00	 DD	 $LN8@list_richc
  002dc	00 00 00 00	 DD	 $LN7@list_richc
  002e0	00 00 00 00	 DD	 $LN6@list_richc
list_richcompare ENDP
_TEXT	ENDS
PUBLIC	??_C@_07HBIIMNCM@?$HMO?3list?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_init DD imagerel list_init
	DD	imagerel list_init+126
	DD	imagerel $unwind$list_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_init DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_07HBIIMNCM@?$HMO?3list?$AA@
CONST	SEGMENT
??_C@_07HBIIMNCM@?$HMO?3list?$AA@ DB '|O:list', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT list_init
_TEXT	SEGMENT
self$ = 64
args$ = 72
kw$ = 80
arg$ = 88
list_init PROC						; COMDAT

; 2367 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	49 8b c0	 mov	 rax, r8
  0000c	4c 8b d2	 mov	 r10, rdx

; 2368 :     PyObject *arg = NULL;
; 2369 :     static char *kwlist[] = {"sequence", 0};
; 2370 : 
; 2371 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:list", kwlist, &arg))

  0000f	48 8d 4c 24 58	 lea	 rcx, QWORD PTR arg$[rsp]
  00014	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??list_init@@9@9
  0001b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07HBIIMNCM@?$HMO?3list?$AA@
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	48 8b d0	 mov	 rdx, rax
  0002a	49 8b ca	 mov	 rcx, r10
  0002d	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR arg$[rsp], 0
  00036	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0003b	85 c0		 test	 eax, eax
  0003d	75 09		 jne	 SHORT $LN4@list_init
$LN7@list_init:

; 2372 :         return -1;

  0003f	83 c8 ff	 or	 eax, -1

; 2391 : }

  00042	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00046	5b		 pop	 rbx
  00047	c3		 ret	 0
$LN4@list_init:

; 2373 : 
; 2374 :     /* Verify list invariants established by PyType_GenericAlloc() */
; 2375 :     assert(0 <= Py_SIZE(self));
; 2376 :     assert(Py_SIZE(self) <= self->allocated || self->allocated == -1);
; 2377 :     assert(self->ob_item != NULL ||
; 2378 :            self->allocated == 0 || self->allocated == -1);
; 2379 : 
; 2380 :     /* Empty previous contents */
; 2381 :     if (self->ob_item != NULL) {

  00048	48 83 7b 70 00	 cmp	 QWORD PTR [rbx+112], 0
  0004d	74 08		 je	 SHORT $LN3@list_init

; 2382 :         (void)list_clear(self);

  0004f	48 8b cb	 mov	 rcx, rbx
  00052	e8 00 00 00 00	 call	 list_clear
$LN3@list_init:

; 2383 :     }
; 2384 :     if (arg != NULL) {

  00057	48 8b 54 24 58	 mov	 rdx, QWORD PTR arg$[rsp]
  0005c	48 85 d2	 test	 rdx, rdx
  0005f	74 15		 je	 SHORT $LN2@list_init

; 2385 :         PyObject *rv = listextend(self, arg);

  00061	48 8b cb	 mov	 rcx, rbx
  00064	e8 00 00 00 00	 call	 listextend

; 2386 :         if (rv == NULL)

  00069	48 85 c0	 test	 rax, rax

; 2387 :             return -1;

  0006c	74 d1		 je	 SHORT $LN7@list_init

; 2388 :         Py_DECREF(rv);

  0006e	48 8b c8	 mov	 rcx, rax
  00071	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@list_init:

; 2389 :     }
; 2390 :     return 0;

  00076	33 c0		 xor	 eax, eax

; 2391 : }

  00078	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007c	5b		 pop	 rbx
  0007d	c3		 ret	 0
list_init ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT list_sizeof
_TEXT	SEGMENT
self$ = 8
list_sizeof PROC					; COMDAT

; 2396 :     Py_ssize_t res;
; 2397 : 
; 2398 :     res = sizeof(PyListObject) + self->allocated * sizeof(void*);

  00000	48 8b 41 78	 mov	 rax, QWORD PTR [rcx+120]
  00004	48 8d 0c c5 80
	00 00 00	 lea	 rcx, QWORD PTR [rax*8+128]

; 2399 :     return PyLong_FromSsize_t(res);
; 2400 : }

  0000c	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
list_sizeof ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@NOMKDFOD@list?5indices?5must?5be?5integers?0?5n@ ; `string'
EXTRN	PySlice_GetIndicesEx:PROC
EXTRN	PySlice_Type:BYTE
EXTRN	PyNumber_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_subscript DD imagerel list_subscript
	DD	imagerel list_subscript+239
	DD	imagerel $unwind$list_subscript
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$list_subscript DD imagerel list_subscript+239
	DD	imagerel list_subscript+269
	DD	imagerel $chain$0$list_subscript
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$list_subscript DD imagerel list_subscript+269
	DD	imagerel list_subscript+385
	DD	imagerel $chain$5$list_subscript
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$list_subscript DD imagerel list_subscript+385
	DD	imagerel list_subscript+417
	DD	imagerel $chain$6$list_subscript
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$list_subscript DD 021H
	DD	imagerel list_subscript
	DD	imagerel list_subscript+239
	DD	imagerel $unwind$list_subscript
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$list_subscript DD 081d21H
	DD	08d41dH
	DD	09c412H
	DD	0a6405H
	DD	0e5400H
	DD	imagerel list_subscript
	DD	imagerel list_subscript+239
	DD	imagerel $unwind$list_subscript
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$list_subscript DD 020521H
	DD	0e5405H
	DD	imagerel list_subscript
	DD	imagerel list_subscript+239
	DD	imagerel $unwind$list_subscript
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_subscript DD 030701H
	DD	07003a207H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_0CK@NOMKDFOD@list?5indices?5must?5be?5integers?0?5n@
CONST	SEGMENT
??_C@_0CK@NOMKDFOD@list?5indices?5must?5be?5integers?0?5n@ DB 'list indic'
	DB	'es must be integers, not %.200s', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT list_subscript
_TEXT	SEGMENT
stop$22001 = 48
self$ = 112
slicelength$22003 = 120
item$ = 120
start$22000 = 128
step$22002 = 136
list_subscript PROC					; COMDAT

; 2476 : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2477 :     if (PyIndex_Check(item)) {

  00007	4c 8b 42 58	 mov	 r8, QWORD PTR [rdx+88]
  0000b	4c 8b d2	 mov	 r10, rdx
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	49 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [r8+184]
  00018	48 85 c0	 test	 rax, rax
  0001b	74 4f		 je	 SHORT $LN15@list_subsc
  0001d	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  00025	74 45		 je	 SHORT $LN15@list_subsc

; 2478 :         Py_ssize_t i;
; 2479 :         i = PyNumber_AsSsize_t(item, PyExc_IndexError);

  00027	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  0002e	49 8b ca	 mov	 rcx, r10
  00031	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00036	48 8b d8	 mov	 rbx, rax

; 2480 :         if (i == -1 && PyErr_Occurred())

  00039	48 83 f8 ff	 cmp	 rax, -1
  0003d	75 13		 jne	 SHORT $LN14@list_subsc
  0003f	e8 00 00 00 00	 call	 PyErr_Occurred
  00044	48 85 c0	 test	 rax, rax
  00047	74 0e		 je	 SHORT $LN20@list_subsc
$LN22@list_subsc:

; 2481 :             return NULL;

  00049	33 c0		 xor	 eax, eax

; 2524 :     }
; 2525 : }

  0004b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0004f	5f		 pop	 rdi
  00050	5b		 pop	 rbx
  00051	c3		 ret	 0
$LN14@list_subsc:

; 2482 :         if (i < 0)

  00052	48 85 c0	 test	 rax, rax
  00055	79 04		 jns	 SHORT $LN13@list_subsc
$LN20@list_subsc:

; 2483 :             i += PyList_GET_SIZE(self);

  00057	48 03 5f 60	 add	 rbx, QWORD PTR [rdi+96]
$LN13@list_subsc:

; 2484 :         return list_item(self, i);

  0005b	48 8b d3	 mov	 rdx, rbx
  0005e	48 8b cf	 mov	 rcx, rdi

; 2524 :     }
; 2525 : }

  00061	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00065	5f		 pop	 rdi
  00066	5b		 pop	 rbx
  00067	e9 00 00 00 00	 jmp	 list_item
$LN15@list_subsc:

; 2485 :     }
; 2486 :     else if (PySlice_Check(item)) {

  0006c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  00073	4c 3b c0	 cmp	 r8, rax
  00076	0f 85 05 01 00
	00		 jne	 $LN11@list_subsc

; 2487 :         Py_ssize_t start, stop, step, slicelength, cur, i;
; 2488 :         PyObject* result;
; 2489 :         PyObject* it;
; 2490 :         PyObject **src, **dest;
; 2491 : 
; 2492 :         if (PySlice_GetIndicesEx(item, Py_SIZE(self),
; 2493 :                          &start, &stop, &step, &slicelength) < 0) {

  0007c	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00080	48 8d 44 24 78	 lea	 rax, QWORD PTR slicelength$22003[rsp]
  00085	4c 8d 4c 24 30	 lea	 r9, QWORD PTR stop$22001[rsp]
  0008a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0008f	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR step$22002[rsp]
  00097	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR start$22000[rsp]
  0009f	49 8b ca	 mov	 rcx, r10
  000a2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a7	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  000ac	85 c0		 test	 eax, eax

; 2494 :             return NULL;

  000ae	78 99		 js	 SHORT $LN22@list_subsc

; 2495 :         }
; 2496 : 
; 2497 :         if (slicelength <= 0) {

  000b0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR slicelength$22003[rsp]
  000b5	48 85 c9	 test	 rcx, rcx
  000b8	7f 0e		 jg	 SHORT $LN9@list_subsc

; 2498 :             return PyList_New(0);

  000ba	33 c9		 xor	 ecx, ecx
  000bc	e8 00 00 00 00	 call	 PyList_New

; 2524 :     }
; 2525 : }

  000c1	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000c5	5f		 pop	 rdi
  000c6	5b		 pop	 rbx
  000c7	c3		 ret	 0
$LN9@list_subsc:

; 2499 :         }
; 2500 :         else if (step == 1) {

  000c8	48 83 bc 24 88
	00 00 00 01	 cmp	 QWORD PTR step$22002[rsp], 1
  000d1	75 1c		 jne	 SHORT $LN7@list_subsc

; 2501 :             return list_slice(self, start, stop);

  000d3	4c 8b 44 24 30	 mov	 r8, QWORD PTR stop$22001[rsp]
  000d8	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR start$22000[rsp]
  000e0	48 8b cf	 mov	 rcx, rdi
  000e3	e8 00 00 00 00	 call	 list_slice

; 2524 :     }
; 2525 : }

  000e8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ec	5f		 pop	 rdi
  000ed	5b		 pop	 rbx
  000ee	c3		 ret	 0
$LN7@list_subsc:
  000ef	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp

; 2502 :         }
; 2503 :         else {
; 2504 :             result = PyList_New(slicelength);

  000f4	e8 00 00 00 00	 call	 PyList_New
  000f9	48 8b e8	 mov	 rbp, rax

; 2505 :             if (!result) return NULL;

  000fc	48 85 c0	 test	 rax, rax
  000ff	75 0c		 jne	 SHORT $LN5@list_subsc
  00101	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]

; 2524 :     }
; 2525 : }

  00106	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0010a	5f		 pop	 rdi
  0010b	5b		 pop	 rbx
  0010c	c3		 ret	 0
$LN5@list_subsc:
  0010d	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi

; 2506 : 
; 2507 :             src = self->ob_item;
; 2508 :             dest = ((PyListObject *)result)->ob_item;
; 2509 :             for (cur = start, i = 0; i < slicelength;
; 2510 :                  cur += (size_t)step, i++) {

  00112	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR start$22000[rsp]
  0011a	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  0011f	4c 8b 67 70	 mov	 r12, QWORD PTR [rdi+112]
  00123	33 ff		 xor	 edi, edi
  00125	4c 89 6c 24 40	 mov	 QWORD PTR [rsp+64], r13
  0012a	4c 8b 68 70	 mov	 r13, QWORD PTR [rax+112]
  0012e	48 39 7c 24 78	 cmp	 QWORD PTR slicelength$22003[rsp], rdi
  00133	7e 2e		 jle	 SHORT $LN2@list_subsc
  00135	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@list_subsc:

; 2511 :                 it = src[cur];

  00140	49 8b 1c f4	 mov	 rbx, QWORD PTR [r12+rsi*8]

; 2512 :                 Py_INCREF(it);

  00144	48 8b cb	 mov	 rcx, rbx
  00147	e8 00 00 00 00	 call	 _Py_IncRef

; 2513 :                 dest[i] = it;

  0014c	49 89 5c fd 00	 mov	 QWORD PTR [r13+rdi*8], rbx
  00151	48 03 b4 24 88
	00 00 00	 add	 rsi, QWORD PTR step$22002[rsp]
  00159	48 ff c7	 inc	 rdi
  0015c	48 3b 7c 24 78	 cmp	 rdi, QWORD PTR slicelength$22003[rsp]
  00161	7c dd		 jl	 SHORT $LL4@list_subsc
$LN2@list_subsc:
  00163	4c 8b 6c 24 40	 mov	 r13, QWORD PTR [rsp+64]
  00168	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  0016d	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 2514 :             }
; 2515 : 
; 2516 :             return result;

  00172	48 8b c5	 mov	 rax, rbp
  00175	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]

; 2524 :     }
; 2525 : }

  0017a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0017e	5f		 pop	 rdi
  0017f	5b		 pop	 rbx
  00180	c3		 ret	 0
$LN11@list_subsc:

; 2517 :         }
; 2518 :     }
; 2519 :     else {
; 2520 :         PyErr_Format(PyExc_TypeError,
; 2521 :                      "list indices must be integers, not %.200s",
; 2522 :                      item->ob_type->tp_name);

  00181	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00185	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0018c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@NOMKDFOD@list?5indices?5must?5be?5integers?0?5n@
  00193	e8 00 00 00 00	 call	 PyErr_Format

; 2523 :         return NULL;

  00198	33 c0		 xor	 eax, eax

; 2524 :     }
; 2525 : }

  0019a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0019e	5f		 pop	 rdi
  0019f	5b		 pop	 rbx
  001a0	c3		 ret	 0
list_subscript ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EF@EIODKBFE@attempt?5to?5assign?5sequence?5of?5si@ ; `string'
PUBLIC	??_C@_0CH@ECOCECDB@must?5assign?5iterable?5to?5extended@ ; `string'
PUBLIC	??_C@_0DI@BCOHAMCP@parallel?5thread?5attempted?5to?5ass@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$list_ass_subscript DD imagerel list_ass_subscript
	DD	imagerel list_ass_subscript+307
	DD	imagerel $unwind$list_ass_subscript
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$list_ass_subscript DD imagerel list_ass_subscript+307
	DD	imagerel list_ass_subscript+857
	DD	imagerel $chain$2$list_ass_subscript
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$list_ass_subscript DD imagerel list_ass_subscript+857
	DD	imagerel list_ass_subscript+959
	DD	imagerel $chain$4$list_ass_subscript
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$list_ass_subscript DD imagerel list_ass_subscript+959
	DD	imagerel list_ass_subscript+1088
	DD	imagerel $chain$5$list_ass_subscript
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$list_ass_subscript DD imagerel list_ass_subscript+1088
	DD	imagerel list_ass_subscript+1177
	DD	imagerel $chain$6$list_ass_subscript
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$list_ass_subscript DD imagerel list_ass_subscript+1177
	DD	imagerel list_ass_subscript+1213
	DD	imagerel $chain$7$list_ass_subscript
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$list_ass_subscript DD 021H
	DD	imagerel list_ass_subscript
	DD	imagerel list_ass_subscript+307
	DD	imagerel $unwind$list_ass_subscript
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$list_ass_subscript DD 021H
	DD	imagerel list_ass_subscript+857
	DD	imagerel list_ass_subscript+959
	DD	imagerel $chain$4$list_ass_subscript
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$list_ass_subscript DD 020521H
	DD	0cf405H
	DD	imagerel list_ass_subscript+857
	DD	imagerel list_ass_subscript+959
	DD	imagerel $chain$4$list_ass_subscript
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$list_ass_subscript DD 060021H
	DD	014e400H
	DD	013c400H
	DD	0126400H
	DD	imagerel list_ass_subscript
	DD	imagerel list_ass_subscript+307
	DD	imagerel $unwind$list_ass_subscript
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$list_ass_subscript DD 061821H
	DD	014e418H
	DD	013c410H
	DD	0126408H
	DD	imagerel list_ass_subscript
	DD	imagerel list_ass_subscript+307
	DD	imagerel $unwind$list_ass_subscript
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_ass_subscript DD 050d01H
	DD	0d006c20dH
	DD	030037004H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0EF@EIODKBFE@attempt?5to?5assign?5sequence?5of?5si@
CONST	SEGMENT
??_C@_0EF@EIODKBFE@attempt?5to?5assign?5sequence?5of?5si@ DB 'attempt to '
	DB	'assign sequence of size %zd to extended slice of size %zd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@ECOCECDB@must?5assign?5iterable?5to?5extended@
CONST	SEGMENT
??_C@_0CH@ECOCECDB@must?5assign?5iterable?5to?5extended@ DB 'must assign '
	DB	'iterable to extended slice', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@BCOHAMCP@parallel?5thread?5attempted?5to?5ass@
CONST	SEGMENT
??_C@_0DI@BCOHAMCP@parallel?5thread?5attempted?5to?5ass@ DB 'parallel thr'
	DB	'ead attempted to assign to main thread list', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT list_ass_subscript
_TEXT	SEGMENT
slicelength$22052 = 48
step$22051 = 56
stop$22050 = 64
start$22049 = 72
seq$1$ = 80
self$ = 144
item$ = 152
value$ = 160
selfitems$1$ = 168
tv475 = 168
list_ass_subscript PROC					; COMDAT

; 2529 : {

  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	57		 push	 rdi
  00004	41 55		 push	 r13
  00006	48 8b ec	 mov	 rbp, rsp
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000d	49 8b d8	 mov	 rbx, r8
  00010	48 8b fa	 mov	 rdi, rdx
  00013	4c 8b e9	 mov	 r13, rcx

; 2530 : #ifdef WITH_PARALLEL
; 2531 :     if (Py_PXCTX && Px_ISPY(self)) {

  00016	e8 00 00 00 00	 call	 _Py_PXCTX
  0001b	85 c0		 test	 eax, eax
  0001d	74 27		 je	 SHORT $LN37@list_ass_s@2
  0001f	41 f6 45 20 01	 test	 BYTE PTR [r13+32], 1
  00024	74 20		 je	 SHORT $LN37@list_ass_s@2

; 2532 :         PyErr_SetString(PyExc_AssignmentError,
; 2533 :                         "parallel thread attempted to "
; 2534 :                         "assign to main thread list");

  00026	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AssignmentError
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DI@BCOHAMCP@parallel?5thread?5attempted?5to?5ass@
  00034	e8 00 00 00 00	 call	 PyErr_SetString
$LN83@list_ass_s@2:

; 2535 :         return -1;

  00039	83 c8 ff	 or	 eax, -1

; 2696 :     }
; 2697 : }

  0003c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00040	41 5d		 pop	 r13
  00042	5f		 pop	 rdi
  00043	5b		 pop	 rbx
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
$LN37@list_ass_s@2:

; 2536 :     }
; 2537 : #endif
; 2538 : 
; 2539 :     if (PyIndex_Check(item)) {

  00046	4c 8b 47 58	 mov	 r8, QWORD PTR [rdi+88]
  0004a	49 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [r8+184]
  00051	48 85 c0	 test	 rax, rax
  00054	74 58		 je	 SHORT $LN36@list_ass_s@2
  00056	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  0005e	74 4e		 je	 SHORT $LN36@list_ass_s@2

; 2540 :         Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);

  00060	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  00067	48 8b cf	 mov	 rcx, rdi
  0006a	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  0006f	48 8b f8	 mov	 rdi, rax

; 2541 :         if (i == -1 && PyErr_Occurred())

  00072	48 83 f8 ff	 cmp	 rax, -1
  00076	75 16		 jne	 SHORT $LN35@list_ass_s@2
  00078	e8 00 00 00 00	 call	 PyErr_Occurred
  0007d	48 85 c0	 test	 rax, rax
  00080	74 11		 je	 SHORT $LN70@list_ass_s@2

; 2542 :             return -1;

  00082	0b c7		 or	 eax, edi

; 2696 :     }
; 2697 : }

  00084	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00088	41 5d		 pop	 r13
  0008a	5f		 pop	 rdi
  0008b	5b		 pop	 rbx
  0008c	5d		 pop	 rbp
  0008d	c3		 ret	 0
$LN35@list_ass_s@2:

; 2543 :         if (i < 0)

  0008e	48 85 c0	 test	 rax, rax
  00091	79 04		 jns	 SHORT $LN34@list_ass_s@2
$LN70@list_ass_s@2:

; 2544 :             i += PyList_GET_SIZE(self);

  00093	49 03 7d 60	 add	 rdi, QWORD PTR [r13+96]
$LN34@list_ass_s@2:

; 2545 :         return list_ass_item(self, i, value);

  00097	4c 8b c3	 mov	 r8, rbx
  0009a	48 8b d7	 mov	 rdx, rdi
  0009d	49 8b cd	 mov	 rcx, r13

; 2696 :     }
; 2697 : }

  000a0	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000a4	41 5d		 pop	 r13
  000a6	5f		 pop	 rdi
  000a7	5b		 pop	 rbx
  000a8	5d		 pop	 rbp
  000a9	e9 00 00 00 00	 jmp	 list_ass_item
$LN36@list_ass_s@2:

; 2546 :     }
; 2547 :     else if (PySlice_Check(item)) {

  000ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  000b5	4c 3b c0	 cmp	 r8, rax
  000b8	0f 85 db 03 00
	00		 jne	 $LN32@list_ass_s@2

; 2548 :         Py_ssize_t start, stop, step, slicelength;
; 2549 : 
; 2550 :         if (PySlice_GetIndicesEx(item, Py_SIZE(self),
; 2551 :                          &start, &stop, &step, &slicelength) < 0) {

  000be	49 8b 55 60	 mov	 rdx, QWORD PTR [r13+96]
  000c2	48 8d 45 c8	 lea	 rax, QWORD PTR slicelength$22052[rbp-104]
  000c6	4c 8d 4d d8	 lea	 r9, QWORD PTR stop$22050[rbp-104]
  000ca	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000cf	48 8d 45 d0	 lea	 rax, QWORD PTR step$22051[rbp-104]
  000d3	4c 8d 45 e0	 lea	 r8, QWORD PTR start$22049[rbp-104]
  000d7	48 8b cf	 mov	 rcx, rdi
  000da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000df	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  000e4	85 c0		 test	 eax, eax

; 2552 :             return -1;

  000e6	0f 88 4d ff ff
	ff		 js	 $LN83@list_ass_s@2

; 2553 :         }
; 2554 : 
; 2555 :         if (step == 1)

  000ec	48 8b 55 d0	 mov	 rdx, QWORD PTR step$22051[rbp-104]
  000f0	48 83 fa 01	 cmp	 rdx, 1
  000f4	75 1d		 jne	 SHORT $LN30@list_ass_s@2

; 2556 :             return list_ass_slice(self, start, stop, value);

  000f6	4c 8b 45 d8	 mov	 r8, QWORD PTR stop$22050[rbp-104]
  000fa	48 8b 55 e0	 mov	 rdx, QWORD PTR start$22049[rbp-104]
  000fe	4c 8b cb	 mov	 r9, rbx
  00101	49 8b cd	 mov	 rcx, r13
  00104	e8 00 00 00 00	 call	 list_ass_slice

; 2696 :     }
; 2697 : }

  00109	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0010d	41 5d		 pop	 r13
  0010f	5f		 pop	 rdi
  00110	5b		 pop	 rbx
  00111	5d		 pop	 rbp
  00112	c3		 ret	 0
$LN30@list_ass_s@2:

; 2557 : 
; 2558 :         /* Make sure s[5:2] = [..] inserts at the right place:
; 2559 :            before 5, not before 2. */
; 2560 :         if ((step < 0 && start < stop) ||
; 2561 :             (step > 0 && start > stop))

  00113	48 8b 45 d8	 mov	 rax, QWORD PTR stop$22050[rbp-104]
  00117	48 8b 4d e0	 mov	 rcx, QWORD PTR start$22049[rbp-104]
  0011b	48 85 d2	 test	 rdx, rdx
  0011e	79 08		 jns	 SHORT $LN77@list_ass_s@2
  00120	48 3b c8	 cmp	 rcx, rax
  00123	7c 0a		 jl	 SHORT $LN28@list_ass_s@2
  00125	48 85 d2	 test	 rdx, rdx
$LN77@list_ass_s@2:
  00128	7e 09		 jle	 SHORT $LN29@list_ass_s@2
  0012a	48 3b c8	 cmp	 rcx, rax
  0012d	7e 04		 jle	 SHORT $LN29@list_ass_s@2
$LN28@list_ass_s@2:

; 2562 :             stop = start;

  0012f	48 89 4d d8	 mov	 QWORD PTR stop$22050[rbp-104], rcx
$LN29@list_ass_s@2:
  00133	48 89 b4 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rsi
  0013b	4c 89 a4 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], r12
  00143	4c 89 b4 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], r14

; 2563 : 
; 2564 :         if (value == NULL) {

  0014b	48 85 db	 test	 rbx, rbx
  0014e	0f 85 75 01 00
	00		 jne	 $LN26@list_ass_s@2

; 2565 :             /* delete slice */
; 2566 :             PyObject **garbage;
; 2567 :             size_t cur;
; 2568 :             Py_ssize_t i;
; 2569 : 
; 2570 :             if (slicelength <= 0)

  00154	48 8b 45 c8	 mov	 rax, QWORD PTR slicelength$22052[rbp-104]
  00158	48 85 c0	 test	 rax, rax

; 2571 :                 return 0;

  0015b	0f 8e 1f 03 00
	00		 jle	 $LN82@list_ass_s@2

; 2572 : 
; 2573 :             if (step < 0) {

  00161	48 85 d2	 test	 rdx, rdx
  00164	79 1e		 jns	 SHORT $LN24@list_ass_s@2

; 2574 :                 stop = start + 1;

  00166	48 ff c1	 inc	 rcx

; 2575 :                 start = stop + step*(slicelength - 1) - 1;

  00169	48 ff c8	 dec	 rax
  0016c	48 89 4d d8	 mov	 QWORD PTR stop$22050[rbp-104], rcx
  00170	48 0f af c2	 imul	 rax, rdx

; 2576 :                 step = -step;

  00174	48 f7 da	 neg	 rdx
  00177	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  0017c	48 89 55 d0	 mov	 QWORD PTR step$22051[rbp-104], rdx
  00180	48 89 45 e0	 mov	 QWORD PTR start$22049[rbp-104], rax
$LN24@list_ass_s@2:

; 2577 :             }
; 2578 : 
; 2579 :             assert((size_t)slicelength <=
; 2580 :                    PY_SIZE_MAX / sizeof(PyObject*));
; 2581 : 
; 2582 :             garbage = (PyObject**)
; 2583 :                 PyMem_MALLOC(slicelength*sizeof(PyObject*));

  00184	e8 00 00 00 00	 call	 _Py_PXCTX
  00189	85 c0		 test	 eax, eax
  0018b	74 13		 je	 SHORT $LN44@list_ass_s@2
  0018d	48 8b 4d c8	 mov	 rcx, QWORD PTR slicelength$22052[rbp-104]
  00191	48 c1 e1 03	 shl	 rcx, 3
  00195	e8 00 00 00 00	 call	 _PxMem_Malloc
  0019a	4c 8b 65 c8	 mov	 r12, QWORD PTR slicelength$22052[rbp-104]
  0019e	eb 31		 jmp	 SHORT $LN78@list_ass_s@2
$LN44@list_ass_s@2:
  001a0	4c 8b 65 c8	 mov	 r12, QWORD PTR slicelength$22052[rbp-104]
  001a4	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  001ae	4a 8d 14 e5 00
	00 00 00	 lea	 rdx, QWORD PTR [r12*8]
  001b6	48 3b d0	 cmp	 rdx, rax
  001b9	0f 87 d0 02 00
	00		 ja	 $LN71@list_ass_s@2
  001bf	48 85 d2	 test	 rdx, rdx
  001c2	b9 01 00 00 00	 mov	 ecx, 1
  001c7	48 0f 45 ca	 cmovne	 rcx, rdx
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN78@list_ass_s@2:
  001d1	48 8b d8	 mov	 rbx, rax

; 2584 :             if (!garbage) {

  001d4	48 85 c0	 test	 rax, rax
  001d7	0f 84 b2 02 00
	00		 je	 $LN71@list_ass_s@2

; 2585 :                 PyErr_NoMemory();
; 2586 :                 return -1;
; 2587 :             }
; 2588 : 
; 2589 :             /* drawing pictures might help understand these for
; 2590 :                loops. Basically, we memmove the parts of the
; 2591 :                list that are *not* part of the slice: step-1
; 2592 :                items for each item that is part of the slice,
; 2593 :                and then tail end of the list that was not
; 2594 :                covered by the slice */
; 2595 :             for (cur = start, i = 0;
; 2596 :                  cur < (size_t)stop;
; 2597 :                  cur += step, i++) {

  001dd	48 8b 75 e0	 mov	 rsi, QWORD PTR start$22049[rbp-104]
  001e1	48 8b 4d d0	 mov	 rcx, QWORD PTR step$22051[rbp-104]
  001e5	33 ff		 xor	 edi, edi
  001e7	44 8b f7	 mov	 r14d, edi
  001ea	48 3b 75 d8	 cmp	 rsi, QWORD PTR stop$22050[rbp-104]
  001ee	73 5f		 jae	 SHORT $LN20@list_ass_s@2
$LL22@list_ass_s@2:

; 2598 :                 Py_ssize_t lim = step - 1;
; 2599 : 
; 2600 :                 garbage[i] = PyList_GET_ITEM(self, cur);

  001f0	49 8b 45 70	 mov	 rax, QWORD PTR [r13+112]
  001f4	4c 8d 41 ff	 lea	 r8, QWORD PTR [rcx-1]
  001f8	48 8b 0c f0	 mov	 rcx, QWORD PTR [rax+rsi*8]
  001fc	4a 89 0c f3	 mov	 QWORD PTR [rbx+r14*8], rcx

; 2601 : 
; 2602 :                 if (cur + step >= (size_t)Py_SIZE(self)) {

  00200	48 8b 45 d0	 mov	 rax, QWORD PTR step$22051[rbp-104]
  00204	49 8b 55 60	 mov	 rdx, QWORD PTR [r13+96]
  00208	48 8d 0c 06	 lea	 rcx, QWORD PTR [rsi+rax]
  0020c	48 3b ca	 cmp	 rcx, rdx
  0020f	72 09		 jb	 SHORT $LN19@list_ass_s@2

; 2603 :                     lim = Py_SIZE(self) - cur - 1;

  00211	4c 8b c2	 mov	 r8, rdx
  00214	4c 2b c6	 sub	 r8, rsi
  00217	49 ff c8	 dec	 r8
$LN19@list_ass_s@2:

; 2604 :                 }
; 2605 : 
; 2606 :                 memmove(self->ob_item + cur - i,
; 2607 :                     self->ob_item + cur + 1,
; 2608 :                     lim * sizeof(PyObject *));

  0021a	49 8b 4d 70	 mov	 rcx, QWORD PTR [r13+112]
  0021e	48 8b c6	 mov	 rax, rsi
  00221	49 c1 e0 03	 shl	 r8, 3
  00225	49 2b c6	 sub	 rax, r14
  00228	48 8d 54 f1 08	 lea	 rdx, QWORD PTR [rcx+rsi*8+8]
  0022d	48 8d 0c c1	 lea	 rcx, QWORD PTR [rcx+rax*8]
  00231	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
  00237	48 8b 4d d0	 mov	 rcx, QWORD PTR step$22051[rbp-104]
  0023b	49 ff c6	 inc	 r14
  0023e	48 03 f1	 add	 rsi, rcx
  00241	48 3b 75 d8	 cmp	 rsi, QWORD PTR stop$22050[rbp-104]
  00245	72 a9		 jb	 SHORT $LL22@list_ass_s@2

; 2585 :                 PyErr_NoMemory();
; 2586 :                 return -1;
; 2587 :             }
; 2588 : 
; 2589 :             /* drawing pictures might help understand these for
; 2590 :                loops. Basically, we memmove the parts of the
; 2591 :                list that are *not* part of the slice: step-1
; 2592 :                items for each item that is part of the slice,
; 2593 :                and then tail end of the list that was not
; 2594 :                covered by the slice */
; 2595 :             for (cur = start, i = 0;
; 2596 :                  cur < (size_t)stop;
; 2597 :                  cur += step, i++) {

  00247	4c 8b 65 c8	 mov	 r12, QWORD PTR slicelength$22052[rbp-104]
  0024b	48 8b 75 e0	 mov	 rsi, QWORD PTR start$22049[rbp-104]
$LN20@list_ass_s@2:

; 2609 :             }
; 2610 :             cur = start + (size_t)slicelength * step;
; 2611 :             if (cur < (size_t)Py_SIZE(self)) {

  0024f	4d 8b 45 60	 mov	 r8, QWORD PTR [r13+96]
  00253	49 0f af cc	 imul	 rcx, r12
  00257	48 03 ce	 add	 rcx, rsi
  0025a	49 3b c8	 cmp	 rcx, r8
  0025d	73 20		 jae	 SHORT $LN18@list_ass_s@2

; 2612 :                 memmove(self->ob_item + cur - slicelength,
; 2613 :                     self->ob_item + cur,
; 2614 :                     (Py_SIZE(self) - cur) *
; 2615 :                      sizeof(PyObject *));

  0025f	49 8b 45 70	 mov	 rax, QWORD PTR [r13+112]
  00263	4c 2b c1	 sub	 r8, rcx
  00266	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  0026a	49 2b cc	 sub	 rcx, r12
  0026d	49 c1 e0 03	 shl	 r8, 3
  00271	48 8d 0c c8	 lea	 rcx, QWORD PTR [rax+rcx*8]
  00275	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
  0027b	4c 8b 65 c8	 mov	 r12, QWORD PTR slicelength$22052[rbp-104]
$LN18@list_ass_s@2:

; 2616 :             }
; 2617 : 
; 2618 :             Py_SIZE(self) -= slicelength;

  0027f	4d 29 65 60	 sub	 QWORD PTR [r13+96], r12

; 2619 :             list_resize(self, Py_SIZE(self));

  00283	49 8b 55 60	 mov	 rdx, QWORD PTR [r13+96]
  00287	49 8b cd	 mov	 rcx, r13
  0028a	e8 00 00 00 00	 call	 list_resize

; 2620 : 
; 2621 :             for (i = 0; i < slicelength; i++) {

  0028f	48 39 7d c8	 cmp	 QWORD PTR slicelength$22052[rbp-104], rdi
  00293	7e 12		 jle	 SHORT $LN15@list_ass_s@2
$LL17@list_ass_s@2:

; 2622 :                 Py_DECREF(garbage[i]);

  00295	48 8b 0c fb	 mov	 rcx, QWORD PTR [rbx+rdi*8]
  00299	e8 00 00 00 00	 call	 _Py_DecRef
  0029e	48 ff c7	 inc	 rdi
  002a1	48 3b 7d c8	 cmp	 rdi, QWORD PTR slicelength$22052[rbp-104]
  002a5	7c ee		 jl	 SHORT $LL17@list_ass_s@2
$LN15@list_ass_s@2:

; 2623 :             }
; 2624 :             PyMem_FREE(garbage);

  002a7	e8 00 00 00 00	 call	 _Py_PXCTX
  002ac	48 8b cb	 mov	 rcx, rbx
  002af	85 c0		 test	 eax, eax
  002b1	74 0c		 je	 SHORT $LN46@list_ass_s@2
  002b3	e8 00 00 00 00	 call	 _PxMem_Free

; 2625 : 
; 2626 :             return 0;

  002b8	33 c0		 xor	 eax, eax
  002ba	e9 78 00 00 00	 jmp	 $LN76@list_ass_s@2
$LN46@list_ass_s@2:

; 2623 :             }
; 2624 :             PyMem_FREE(garbage);

  002bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2625 : 
; 2626 :             return 0;

  002c5	33 c0		 xor	 eax, eax
  002c7	eb 6e		 jmp	 SHORT $LN76@list_ass_s@2
$LN26@list_ass_s@2:

; 2627 :         }
; 2628 :         else {
; 2629 :             /* assign slice */
; 2630 :             PyObject *ins, *seq;
; 2631 :             PyObject **garbage, **seqitems, **selfitems;
; 2632 :             Py_ssize_t cur, i;
; 2633 : 
; 2634 :             /* protect against a[::-1] = a */
; 2635 :             if (self == (PyListObject*)value) {
; 2636 :                 seq = list_slice((PyListObject*)value, 0,
; 2637 :                                    PyList_GET_SIZE(value));

  002c9	48 8b cb	 mov	 rcx, rbx
  002cc	4c 3b eb	 cmp	 r13, rbx
  002cf	75 0d		 jne	 SHORT $LN13@list_ass_s@2
  002d1	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  002d5	33 d2		 xor	 edx, edx
  002d7	e8 00 00 00 00	 call	 list_slice

; 2638 :             }
; 2639 :             else {

  002dc	eb 0c		 jmp	 SHORT $LN79@list_ass_s@2
$LN13@list_ass_s@2:

; 2640 :                 seq = PySequence_Fast(value,
; 2641 :                                       "must assign iterable "
; 2642 :                                       "to extended slice");

  002de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@ECOCECDB@must?5assign?5iterable?5to?5extended@
  002e5	e8 00 00 00 00	 call	 PySequence_Fast
$LN79@list_ass_s@2:
  002ea	48 8b f0	 mov	 rsi, rax
  002ed	48 89 45 e8	 mov	 QWORD PTR seq$1$[rbp-104], rax

; 2643 :             }
; 2644 :             if (!seq)

  002f1	48 85 c0	 test	 rax, rax

; 2645 :                 return -1;

  002f4	74 3e		 je	 SHORT $LN81@list_ass_s@2

; 2646 : 
; 2647 :             if (PySequence_Fast_GET_SIZE(seq) != slicelength) {

  002f6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002fa	4c 8b 46 60	 mov	 r8, QWORD PTR [rsi+96]
  002fe	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  00304	48 8b 45 c8	 mov	 rax, QWORD PTR slicelength$22052[rbp-104]
  00308	81 e1 00 00 00
	02		 and	 ecx, 33554432		; 02000000H
  0030e	49 8b c8	 mov	 rcx, r8
  00311	48 3b c8	 cmp	 rcx, rax
  00314	74 43		 je	 SHORT $LN10@list_ass_s@2

; 2648 :                 PyErr_Format(PyExc_ValueError,
; 2649 :                     "attempt to assign sequence of "
; 2650 :                     "size %zd to extended slice of "
; 2651 :                     "size %zd",
; 2652 :                          PySequence_Fast_GET_SIZE(seq),
; 2653 :                          slicelength);

  00316	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0031d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EF@EIODKBFE@attempt?5to?5assign?5sequence?5of?5si@
  00324	4c 8b c8	 mov	 r9, rax
  00327	e8 00 00 00 00	 call	 PyErr_Format

; 2654 :                 Py_DECREF(seq);

  0032c	48 8b ce	 mov	 rcx, rsi
  0032f	e8 00 00 00 00	 call	 _Py_DecRef
$LN81@list_ass_s@2:

; 2655 :                 return -1;

  00334	83 c8 ff	 or	 eax, -1
$LN76@list_ass_s@2:
  00337	4c 8b a4 24 98
	00 00 00	 mov	 r12, QWORD PTR [rsp+152]
  0033f	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR [rsp+144]
  00347	4c 8b b4 24 a0
	00 00 00	 mov	 r14, QWORD PTR [rsp+160]

; 2696 :     }
; 2697 : }

  0034f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00353	41 5d		 pop	 r13
  00355	5f		 pop	 rdi
  00356	5b		 pop	 rbx
  00357	5d		 pop	 rbp
  00358	c3		 ret	 0
$LN10@list_ass_s@2:

; 2656 :             }
; 2657 : 
; 2658 :             if (!slicelength) {

  00359	48 85 c0	 test	 rax, rax

; 2659 :                 Py_DECREF(seq);
; 2660 :                 return 0;

  0035c	0f 84 16 01 00
	00		 je	 $LN61@list_ass_s@2

; 2661 :             }
; 2662 : 
; 2663 :             garbage = (PyObject**)
; 2664 :                 PyMem_MALLOC(slicelength*sizeof(PyObject*));

  00362	e8 00 00 00 00	 call	 _Py_PXCTX
  00367	85 c0		 test	 eax, eax
  00369	74 13		 je	 SHORT $LN56@list_ass_s@2
  0036b	48 8b 4d c8	 mov	 rcx, QWORD PTR slicelength$22052[rbp-104]
  0036f	48 c1 e1 03	 shl	 rcx, 3
  00373	e8 00 00 00 00	 call	 _PxMem_Malloc
  00378	48 8b 5d c8	 mov	 rbx, QWORD PTR slicelength$22052[rbp-104]
  0037c	eb 31		 jmp	 SHORT $LN80@list_ass_s@2
$LN56@list_ass_s@2:
  0037e	48 8b 5d c8	 mov	 rbx, QWORD PTR slicelength$22052[rbp-104]
  00382	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0038c	48 8d 14 dd 00
	00 00 00	 lea	 rdx, QWORD PTR [rbx*8]
  00394	48 3b d0	 cmp	 rdx, rax
  00397	0f 87 ea 00 00
	00		 ja	 $LN72@list_ass_s@2
  0039d	48 85 d2	 test	 rdx, rdx
  003a0	b9 01 00 00 00	 mov	 ecx, 1
  003a5	48 0f 45 ca	 cmovne	 rcx, rdx
  003a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN80@list_ass_s@2:
  003af	4c 8b e0	 mov	 r12, rax

; 2665 :             if (!garbage) {

  003b2	48 85 c0	 test	 rax, rax
  003b5	0f 84 cc 00 00
	00		 je	 $LN72@list_ass_s@2

; 2669 :             }
; 2670 : 
; 2671 :             selfitems = self->ob_item;

  003bb	49 8b 45 70	 mov	 rax, QWORD PTR [r13+112]
  003bf	4c 89 7c 24 60	 mov	 QWORD PTR [rsp+96], r15
  003c4	48 89 45 40	 mov	 QWORD PTR selfitems$1$[rbp-104], rax

; 2672 :             seqitems = PySequence_Fast_ITEMS(seq);

  003c8	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  003cc	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  003d6	74 06		 je	 SHORT $LN58@list_ass_s@2
  003d8	4c 8b 6e 70	 mov	 r13, QWORD PTR [rsi+112]
  003dc	eb 04		 jmp	 SHORT $LN59@list_ass_s@2
$LN58@list_ass_s@2:
  003de	4c 8d 6e 70	 lea	 r13, QWORD PTR [rsi+112]
$LN59@list_ass_s@2:

; 2673 :             for (cur = start, i = 0; i < slicelength;
; 2674 :                  cur += (size_t)step, i++) {

  003e2	4c 8b 75 e0	 mov	 r14, QWORD PTR start$22049[rbp-104]
  003e6	33 ff		 xor	 edi, edi
  003e8	44 8b ff	 mov	 r15d, edi
  003eb	48 85 db	 test	 rbx, rbx
  003ee	7e 42		 jle	 SHORT $LN5@list_ass_s@2
  003f0	48 8b 75 40	 mov	 rsi, QWORD PTR selfitems$1$[rbp-104]
  003f4	49 8b fc	 mov	 rdi, r12
  003f7	49 2b fd	 sub	 rdi, r13
  003fa	66 0f 1f 44 00
	00		 npad	 6
$LL7@list_ass_s@2:

; 2675 :                 garbage[i] = selfitems[cur];

  00400	4a 8b 04 f6	 mov	 rax, QWORD PTR [rsi+r14*8]
  00404	4a 89 04 2f	 mov	 QWORD PTR [rdi+r13], rax

; 2676 :                 ins = seqitems[i];

  00408	49 8b 5d 00	 mov	 rbx, QWORD PTR [r13]

; 2677 :                 Py_INCREF(ins);

  0040c	48 8b cb	 mov	 rcx, rbx
  0040f	e8 00 00 00 00	 call	 _Py_IncRef

; 2678 :                 selfitems[cur] = ins;

  00414	4a 89 1c f6	 mov	 QWORD PTR [rsi+r14*8], rbx
  00418	48 8b 5d c8	 mov	 rbx, QWORD PTR slicelength$22052[rbp-104]
  0041c	4c 03 75 d0	 add	 r14, QWORD PTR step$22051[rbp-104]
  00420	49 ff c7	 inc	 r15
  00423	49 83 c5 08	 add	 r13, 8
  00427	4c 3b fb	 cmp	 r15, rbx
  0042a	7c d4		 jl	 SHORT $LL7@list_ass_s@2
  0042c	48 8b 75 e8	 mov	 rsi, QWORD PTR seq$1$[rbp-104]
  00430	33 ff		 xor	 edi, edi
$LN5@list_ass_s@2:
  00432	4c 8b 7c 24 60	 mov	 r15, QWORD PTR [rsp+96]

; 2679 :             }
; 2680 : 
; 2681 :             for (i = 0; i < slicelength; i++) {

  00437	48 85 db	 test	 rbx, rbx
  0043a	7e 16		 jle	 SHORT $LN2@list_ass_s@2
  0043c	0f 1f 40 00	 npad	 4
$LL4@list_ass_s@2:

; 2682 :                 Py_DECREF(garbage[i]);

  00440	49 8b 0c fc	 mov	 rcx, QWORD PTR [r12+rdi*8]
  00444	e8 00 00 00 00	 call	 _Py_DecRef
  00449	48 ff c7	 inc	 rdi
  0044c	48 3b 7d c8	 cmp	 rdi, QWORD PTR slicelength$22052[rbp-104]
  00450	7c ee		 jl	 SHORT $LL4@list_ass_s@2
$LN2@list_ass_s@2:

; 2683 :             }
; 2684 : 
; 2685 :             PyMem_FREE(garbage);

  00452	e8 00 00 00 00	 call	 _Py_PXCTX
  00457	49 8b cc	 mov	 rcx, r12
  0045a	85 c0		 test	 eax, eax
  0045c	74 14		 je	 SHORT $LN60@list_ass_s@2
  0045e	e8 00 00 00 00	 call	 _PxMem_Free

; 2686 :             Py_DECREF(seq);

  00463	48 8b ce	 mov	 rcx, rsi
  00466	e8 00 00 00 00	 call	 _Py_DecRef

; 2687 : 
; 2688 :             return 0;

  0046b	33 c0		 xor	 eax, eax
  0046d	e9 c5 fe ff ff	 jmp	 $LN76@list_ass_s@2
$LN60@list_ass_s@2:

; 2683 :             }
; 2684 : 
; 2685 :             PyMem_FREE(garbage);

  00472	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN61@list_ass_s@2:

; 2686 :             Py_DECREF(seq);

  00478	48 8b ce	 mov	 rcx, rsi
  0047b	e8 00 00 00 00	 call	 _Py_DecRef
$LN82@list_ass_s@2:

; 2687 : 
; 2688 :             return 0;

  00480	33 c0		 xor	 eax, eax
  00482	e9 b0 fe ff ff	 jmp	 $LN76@list_ass_s@2
$LN72@list_ass_s@2:

; 2666 :                 Py_DECREF(seq);

  00487	48 8b ce	 mov	 rcx, rsi
  0048a	e8 00 00 00 00	 call	 _Py_DecRef
$LN71@list_ass_s@2:

; 2667 :                 PyErr_NoMemory();

  0048f	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2668 :                 return -1;

  00494	e9 9b fe ff ff	 jmp	 $LN81@list_ass_s@2
$LN32@list_ass_s@2:

; 2689 :         }
; 2690 :     }
; 2691 :     else {
; 2692 :         PyErr_Format(PyExc_TypeError,
; 2693 :                      "list indices must be integers, not %.200s",
; 2694 :                      item->ob_type->tp_name);

  00499	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0049d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  004a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@NOMKDFOD@list?5indices?5must?5be?5integers?0?5n@
  004ab	e8 00 00 00 00	 call	 PyErr_Format

; 2695 :         return -1;

  004b0	83 c8 ff	 or	 eax, -1

; 2696 :     }
; 2697 : }

  004b3	48 83 c4 68	 add	 rsp, 104		; 00000068H
  004b7	41 5d		 pop	 r13
  004b9	5f		 pop	 rdi
  004ba	5b		 pop	 rbx
  004bb	5d		 pop	 rbp
  004bc	c3		 ret	 0
list_ass_subscript ENDP
_TEXT	ENDS
PUBLIC	??_C@_09MDCEKMKJ@list_iter?$AA@			; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$list_iter DD imagerel list_iter
	DD	imagerel list_iter+50
	DD	imagerel $unwind$list_iter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$list_iter DD imagerel list_iter+50
	DD	imagerel list_iter+102
	DD	imagerel $chain$0$list_iter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$list_iter DD imagerel list_iter+102
	DD	imagerel list_iter+344
	DD	imagerel $chain$3$list_iter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$list_iter DD 040521H
	DD	083405H
	DD	097400H
	DD	imagerel list_iter
	DD	imagerel list_iter+50
	DD	imagerel $unwind$list_iter
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$list_iter DD 020521H
	DD	097405H
	DD	imagerel list_iter
	DD	imagerel list_iter+50
	DD	imagerel $unwind$list_iter
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_iter DD 020601H
	DD	060025206H
xdata	ENDS
;	COMDAT ??_C@_09MDCEKMKJ@list_iter?$AA@
CONST	SEGMENT
??_C@_09MDCEKMKJ@list_iter?$AA@ DB 'list_iter', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
CONST	ENDS
;	COMDAT list_iter
_TEXT	SEGMENT
seq$ = 64
list_iter PROC						; COMDAT

; 2813 : {

  00000	40 56		 push	 rsi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2814 :     listiterobject *it;
; 2815 : 
; 2816 :     if (!PyList_Check(seq)) {

  00006	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000a	48 8b f1	 mov	 rsi, rcx
  0000d	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  00017	75 19		 jne	 SHORT $LN7@list_iter

; 2817 :         PyErr_BadInternalCall();

  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00020	ba 01 0b 00 00	 mov	 edx, 2817		; 00000b01H
  00025	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2818 :         return NULL;

  0002a	33 c0		 xor	 eax, eax

; 2828 : }

  0002c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00030	5e		 pop	 rsi
  00031	c3		 ret	 0
$LN7@list_iter:
  00032	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 2819 :     }
; 2820 :     it = PyObject_GC_New(listiterobject, &PyListIter_Type);

  00037	e8 00 00 00 00	 call	 _Py_PXCTX
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyListIter_Type
  00043	85 c0		 test	 eax, eax
  00045	74 07		 je	 SHORT $LN10@list_iter
  00047	e8 00 00 00 00	 call	 _PxObject_New
  0004c	eb 05		 jmp	 SHORT $LN19@list_iter
$LN10@list_iter:
  0004e	e8 00 00 00 00	 call	 _PyObject_GC_New
$LN19@list_iter:
  00053	48 8b f8	 mov	 rdi, rax

; 2821 :     if (it == NULL)

  00056	48 85 c0	 test	 rax, rax
  00059	75 0b		 jne	 SHORT $LN6@list_iter
  0005b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 2828 : }

  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5e		 pop	 rsi
  00065	c3		 ret	 0
$LN6@list_iter:
  00066	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 2822 :         return NULL;
; 2823 :     it->it_index = 0;

  0006b	33 db		 xor	 ebx, ebx
  0006d	89 5f 60	 mov	 DWORD PTR [rdi+96], ebx

; 2824 :     Py_INCREF(seq);

  00070	e8 00 00 00 00	 call	 _Py_PXCTX
  00075	85 c0		 test	 eax, eax
  00077	75 32		 jne	 SHORT $LN15@list_iter
  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00087	4c 8b ce	 mov	 r9, rsi
  0008a	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00090	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00098	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009d	85 c0		 test	 eax, eax
  0009f	75 06		 jne	 SHORT $LN14@list_iter
  000a1	f6 46 20 20	 test	 BYTE PTR [rsi+32], 32	; 00000020H
  000a5	74 04		 je	 SHORT $LN15@list_iter
$LN14@list_iter:
  000a7	48 ff 46 50	 inc	 QWORD PTR [rsi+80]
$LN15@list_iter:

; 2825 :     it->it_seq = (PyListObject *)seq;
; 2826 :     _PyObject_GC_TRACK(it);

  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09MDCEKMKJ@list_iter?$AA@
  000b9	4c 8b cf	 mov	 r9, rdi
  000bc	41 b8 0a 0b 00
	00		 mov	 r8d, 2826		; 00000b0aH
  000c2	48 89 77 68	 mov	 QWORD PTR [rdi+104], rsi
  000c6	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ce	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d3	85 c0		 test	 eax, eax
  000d5	75 6e		 jne	 SHORT $LN2@list_iter
  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09MDCEKMKJ@list_iter?$AA@
  000e5	4c 8b cf	 mov	 r9, rdi
  000e8	41 b8 0a 0b 00
	00		 mov	 r8d, 2826		; 00000b0aH
  000ee	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000f6	e8 00 00 00 00	 call	 _PyParallel_Guard
  000fb	85 c0		 test	 eax, eax
  000fd	75 04		 jne	 SHORT $LN13@list_iter
  000ff	48 8d 5f e8	 lea	 rbx, QWORD PTR [rdi-24]
$LN13@list_iter:
  00103	48 83 7b 10 fe	 cmp	 QWORD PTR [rbx+16], -2
  00108	74 0c		 je	 SHORT $LN1@list_iter
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
  00111	e8 00 00 00 00	 call	 Py_FatalError
$LN1@list_iter:
  00116	48 c7 43 10 fd
	ff ff ff	 mov	 QWORD PTR [rbx+16], -3
  0011e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  00125	48 89 03	 mov	 QWORD PTR [rbx], rax
  00128	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  0012f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00133	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx
  00137	48 89 19	 mov	 QWORD PTR [rcx], rbx
  0013a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  00141	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
$LN2@list_iter:

; 2827 :     return (PyObject *)it;

  00145	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0014a	48 8b c7	 mov	 rax, rdi
  0014d	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 2828 : }

  00152	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00156	5e		 pop	 rsi
  00157	c3		 ret	 0
list_iter ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@GOCFMCPI@listiter_dealloc?$AA@	; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$listiter_dealloc DD imagerel listiter_dealloc
	DD	imagerel listiter_dealloc+301
	DD	imagerel $unwind$listiter_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listiter_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0BB@GOCFMCPI@listiter_dealloc?$AA@
CONST	SEGMENT
??_C@_0BB@GOCFMCPI@listiter_dealloc?$AA@ DB 'listiter_dealloc', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
CONST	ENDS
;	COMDAT listiter_dealloc
_TEXT	SEGMENT
it$ = 64
listiter_dealloc PROC					; COMDAT

; 2832 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 2833 :     _PyObject_GC_UNTRACK(it);

  0000d	4c 8b c9	 mov	 r9, rcx
  00010	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GOCFMCPI@listiter_dealloc?$AA@
  0001e	41 b8 11 0b 00
	00		 mov	 r8d, 2833		; 00000b11H
  00024	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0002c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00031	85 c0		 test	 eax, eax
  00033	75 54		 jne	 SHORT $LN5@listiter_d
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GOCFMCPI@listiter_dealloc?$AA@
  00043	4c 8b cf	 mov	 r9, rdi
  00046	41 b8 11 0b 00
	00		 mov	 r8d, 2833		; 00000b11H
  0004c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00054	e8 00 00 00 00	 call	 _PyParallel_Guard
  00059	85 c0		 test	 eax, eax
  0005b	74 04		 je	 SHORT $LN11@listiter_d
  0005d	33 d2		 xor	 edx, edx
  0005f	eb 04		 jmp	 SHORT $LN12@listiter_d
$LN11@listiter_d:
  00061	48 8d 57 e8	 lea	 rdx, QWORD PTR [rdi-24]
$LN12@listiter_d:
  00065	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00068	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  0006c	48 c7 42 10 fe
	ff ff ff	 mov	 QWORD PTR [rdx+16], -2
  00074	48 89 01	 mov	 QWORD PTR [rcx], rax
  00077	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  0007a	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0007e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00082	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0
$LN5@listiter_d:

; 2834 :     Py_XDECREF(it->it_seq);

  00089	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
  0008d	48 85 db	 test	 rbx, rbx
  00090	0f 84 85 00 00
	00		 je	 $LN3@listiter_d
  00096	e8 00 00 00 00	 call	 _Py_PXCTX
  0009b	85 c0		 test	 eax, eax
  0009d	75 7c		 jne	 SHORT $LN3@listiter_d
  0009f	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000a3	a8 20		 test	 al, 32			; 00000020H
  000a5	75 6c		 jne	 SHORT $LN17@listiter_d
  000a7	84 c0		 test	 al, al
  000a9	78 68		 js	 SHORT $LN17@listiter_d
  000ab	a8 02		 test	 al, 2
  000ad	75 6c		 jne	 SHORT $LN3@listiter_d
  000af	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000b3	75 66		 jne	 SHORT $LN3@listiter_d
  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c3	4c 8b cb	 mov	 r9, rbx
  000c6	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000cc	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d4	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d9	48 8b cb	 mov	 rcx, rbx
  000dc	85 c0		 test	 eax, eax
  000de	74 17		 je	 SHORT $LN22@listiter_d
  000e0	e8 00 00 00 00	 call	 _Px_Dealloc

; 2835 :     PyObject_GC_Del(it);

  000e5	48 8b cf	 mov	 rcx, rdi

; 2836 : }

  000e8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ed	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f1	5f		 pop	 rdi
  000f2	e9 00 00 00 00	 jmp	 PyObject_GC_Del

; 2834 :     Py_XDECREF(it->it_seq);

$LN22@listiter_d:
  000f7	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000fb	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 2835 :     PyObject_GC_Del(it);

  00101	48 8b cf	 mov	 rcx, rdi

; 2836 : }

  00104	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00109	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010d	5f		 pop	 rdi
  0010e	e9 00 00 00 00	 jmp	 PyObject_GC_Del

; 2834 :     Py_XDECREF(it->it_seq);

$LN17@listiter_d:
  00113	48 8b cb	 mov	 rcx, rbx
  00116	e8 00 00 00 00	 call	 Px_DecRef
$LN3@listiter_d:

; 2835 :     PyObject_GC_Del(it);

  0011b	48 8b cf	 mov	 rcx, rdi

; 2836 : }

  0011e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00123	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00127	5f		 pop	 rdi
  00128	e9 00 00 00 00	 jmp	 PyObject_GC_Del
listiter_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@GADENFPD@listiter_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$listiter_traverse DD imagerel listiter_traverse
	DD	imagerel listiter_traverse+97
	DD	imagerel $unwind$listiter_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listiter_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BC@GADENFPD@listiter_traverse?$AA@
CONST	SEGMENT
??_C@_0BC@GADENFPD@listiter_traverse?$AA@ DB 'listiter_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT listiter_traverse
_TEXT	SEGMENT
it$ = 48
visit$ = 56
arg$ = 64
listiter_traverse PROC					; COMDAT

; 2840 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 2841 :     Py_VISIT(it->it_seq);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN3@listiter_t
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@GADENFPD@listiter_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 19 0b 00
	00		 mov	 r8d, 2841		; 00000b19H
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@listiter_t:
  0003d	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00041	48 85 c9	 test	 rcx, rcx
  00044	74 09		 je	 SHORT $LN5@listiter_t
  00046	48 8b d7	 mov	 rdx, rdi
  00049	ff d6		 call	 rsi
  0004b	85 c0		 test	 eax, eax
  0004d	75 02		 jne	 SHORT $LN7@listiter_t
$LN5@listiter_t:

; 2842 :     return 0;

  0004f	33 c0		 xor	 eax, eax
$LN7@listiter_t:

; 2843 : }

  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
listiter_traverse ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$listiter_next DD imagerel listiter_next
	DD	imagerel listiter_next+30
	DD	imagerel $unwind$listiter_next
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$listiter_next DD imagerel listiter_next+30
	DD	imagerel listiter_next+128
	DD	imagerel $chain$0$listiter_next
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$listiter_next DD imagerel listiter_next+128
	DD	imagerel listiter_next+154
	DD	imagerel $chain$2$listiter_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$listiter_next DD 020021H
	DD	083400H
	DD	imagerel listiter_next
	DD	imagerel listiter_next+30
	DD	imagerel $unwind$listiter_next
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$listiter_next DD 020521H
	DD	083405H
	DD	imagerel listiter_next
	DD	imagerel listiter_next+30
	DD	imagerel $unwind$listiter_next
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listiter_next DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT listiter_next
_TEXT	SEGMENT
it$ = 64
listiter_next PROC					; COMDAT

; 2847 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b f9	 mov	 rdi, rcx

; 2848 :     PyListObject *seq;
; 2849 :     PyObject *item;
; 2850 : 
; 2851 :     assert(it != NULL);
; 2852 :     seq = it->it_seq;

  00009	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]

; 2853 :     if (seq == NULL)

  0000d	48 85 c9	 test	 rcx, rcx
  00010	75 08		 jne	 SHORT $LN2@listiter_n

; 2854 :         return NULL;

  00012	33 c0		 xor	 eax, eax

; 2867 : }

  00014	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00018	5f		 pop	 rdi
  00019	c3		 ret	 0
$LN2@listiter_n:

; 2855 :     assert(PyList_Check(seq));
; 2856 : 
; 2857 :     if (it->it_index < PyList_GET_SIZE(seq)) {

  0001a	48 63 57 60	 movsxd	 rdx, DWORD PTR [rdi+96]
  0001e	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00023	48 3b 51 60	 cmp	 rdx, QWORD PTR [rcx+96]
  00027	7d 57		 jge	 SHORT $LN1@listiter_n

; 2858 :         item = PyList_GET_ITEM(seq, it->it_index);

  00029	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  0002d	48 8b 1c d0	 mov	 rbx, QWORD PTR [rax+rdx*8]

; 2859 :         ++it->it_index;

  00031	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  00034	89 47 60	 mov	 DWORD PTR [rdi+96], eax

; 2860 :         Py_INCREF(item);

  00037	e8 00 00 00 00	 call	 _Py_PXCTX
  0003c	85 c0		 test	 eax, eax
  0003e	75 32		 jne	 SHORT $LN6@listiter_n
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0004e	4c 8b cb	 mov	 r9, rbx
  00051	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00057	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0005f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00064	85 c0		 test	 eax, eax
  00066	75 06		 jne	 SHORT $LN5@listiter_n
  00068	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0006c	74 04		 je	 SHORT $LN6@listiter_n
$LN5@listiter_n:
  0006e	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@listiter_n:

; 2861 :         return item;

  00072	48 8b c3	 mov	 rax, rbx
  00075	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2867 : }

  0007a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007e	5f		 pop	 rdi
  0007f	c3		 ret	 0
$LN1@listiter_n:

; 2862 :     }
; 2863 : 
; 2864 :     Py_DECREF(seq);

  00080	e8 00 00 00 00	 call	 _Py_DecRef
  00085	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2865 :     it->it_seq = NULL;

  0008a	48 c7 47 68 00
	00 00 00	 mov	 QWORD PTR [rdi+104], 0

; 2866 :     return NULL;

  00092	33 c0		 xor	 eax, eax

; 2867 : }

  00094	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00098	5f		 pop	 rdi
  00099	c3		 ret	 0
listiter_next ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT listiter_len
_TEXT	SEGMENT
it$ = 8
listiter_len PROC					; COMDAT

; 2872 :     Py_ssize_t len;
; 2873 :     if (it->it_seq) {

  00000	48 8b 51 68	 mov	 rdx, QWORD PTR [rcx+104]
  00004	48 85 d2	 test	 rdx, rdx
  00007	74 12		 je	 SHORT $LN1@listiter_l

; 2874 :         len = PyList_GET_SIZE(it->it_seq) - it->it_index;

  00009	48 63 41 60	 movsxd	 rax, DWORD PTR [rcx+96]
  0000d	48 8b 4a 60	 mov	 rcx, QWORD PTR [rdx+96]
  00011	48 2b c8	 sub	 rcx, rax

; 2875 :         if (len >= 0)

  00014	78 05		 js	 SHORT $LN1@listiter_l

; 2879 : }

  00016	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
$LN1@listiter_l:

; 2876 :             return PyLong_FromSsize_t(len);
; 2877 :     }
; 2878 :     return PyLong_FromLong(0);

  0001b	33 c9		 xor	 ecx, ecx

; 2879 : }

  0001d	e9 00 00 00 00	 jmp	 PyLong_FromLong
listiter_len ENDP
_TEXT	ENDS
EXTRN	PyLong_AsLong:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$listiter_setstate DD imagerel listiter_setstate
	DD	imagerel listiter_setstate+155
	DD	imagerel $unwind$listiter_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listiter_setstate DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT listiter_setstate
_TEXT	SEGMENT
it$ = 64
state$ = 72
listiter_setstate PROC					; COMDAT

; 2889 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 2890 :     long index = PyLong_AsLong(state);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 PyLong_AsLong
  00015	8b d8		 mov	 ebx, eax

; 2891 :     if (index == -1 && PyErr_Occurred())

  00017	83 f8 ff	 cmp	 eax, -1
  0001a	75 17		 jne	 SHORT $LN3@listiter_s
  0001c	e8 00 00 00 00	 call	 PyErr_Occurred
  00021	48 85 c0	 test	 rax, rax
  00024	74 0d		 je	 SHORT $LN3@listiter_s

; 2892 :         return NULL;

  00026	33 c0		 xor	 eax, eax

; 2899 : }

  00028	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0002d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00031	5f		 pop	 rdi
  00032	c3		 ret	 0
$LN3@listiter_s:

; 2893 :     if (it->it_seq != NULL) {

  00033	48 83 7f 68 00	 cmp	 QWORD PTR [rdi+104], 0
  00038	74 0a		 je	 SHORT $LN2@listiter_s

; 2894 :         if (index < 0)

  0003a	33 c0		 xor	 eax, eax
  0003c	85 db		 test	 ebx, ebx
  0003e	0f 48 d8	 cmovs	 ebx, eax

; 2895 :             index = 0;
; 2896 :         it->it_index = index;

  00041	89 5f 60	 mov	 DWORD PTR [rdi+96], ebx
$LN2@listiter_s:

; 2897 :     }
; 2898 :     Py_RETURN_NONE;

  00044	e8 00 00 00 00	 call	 _Py_PXCTX
  00049	85 c0		 test	 eax, eax
  0004b	75 3c		 jne	 SHORT $LN7@listiter_s
  0004d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00062	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00068	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00070	e8 00 00 00 00	 call	 _PyParallel_Guard
  00075	85 c0		 test	 eax, eax
  00077	75 09		 jne	 SHORT $LN6@listiter_s
  00079	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00080	74 07		 je	 SHORT $LN7@listiter_s
$LN6@listiter_s:
  00082	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN7@listiter_s:
  00089	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 2899 : }

  00090	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00095	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
listiter_setstate ENDP
_TEXT	ENDS
EXTRN	PyObject_GC_Track:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$list_reversed DD imagerel list_reversed
	DD	imagerel list_reversed+156
	DD	imagerel $unwind$list_reversed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list_reversed DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT list_reversed
_TEXT	SEGMENT
seq$ = 64
unused$ = 72
list_reversed PROC					; COMDAT

; 2959 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 2960 :     listreviterobject *it;
; 2961 : 
; 2962 :     it = PyObject_GC_New(listreviterobject, &PyListRevIter_Type);

  0000d	e8 00 00 00 00	 call	 _Py_PXCTX
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyListRevIter_Type
  00019	85 c0		 test	 eax, eax
  0001b	74 07		 je	 SHORT $LN4@list_rever
  0001d	e8 00 00 00 00	 call	 _PxObject_New
  00022	eb 05		 jmp	 SHORT $LN10@list_rever
$LN4@list_rever:
  00024	e8 00 00 00 00	 call	 _PyObject_GC_New
$LN10@list_rever:
  00029	48 8b d8	 mov	 rbx, rax

; 2963 :     if (it == NULL)

  0002c	48 85 c0	 test	 rax, rax
  0002f	75 0b		 jne	 SHORT $LN1@list_rever

; 2971 : }

  00031	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00036	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
$LN1@list_rever:

; 2964 :         return NULL;
; 2965 :     assert(PyList_Check(seq));
; 2966 :     it->it_index = PyList_GET_SIZE(seq) - 1;

  0003c	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00040	48 ff c8	 dec	 rax
  00043	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 2967 :     Py_INCREF(seq);

  00047	e8 00 00 00 00	 call	 _Py_PXCTX
  0004c	85 c0		 test	 eax, eax
  0004e	75 32		 jne	 SHORT $LN7@list_rever
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0005e	4c 8b cf	 mov	 r9, rdi
  00061	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00067	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0006f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00074	85 c0		 test	 eax, eax
  00076	75 06		 jne	 SHORT $LN6@list_rever
  00078	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0007c	74 04		 je	 SHORT $LN7@list_rever
$LN6@list_rever:
  0007e	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN7@list_rever:

; 2968 :     it->it_seq = seq;
; 2969 :     PyObject_GC_Track(it);

  00082	48 8b cb	 mov	 rcx, rbx
  00085	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi
  00089	e8 00 00 00 00	 call	 PyObject_GC_Track

; 2970 :     return (PyObject *)it;

  0008e	48 8b c3	 mov	 rax, rbx

; 2971 : }

  00091	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00096	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
list_reversed ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$listreviter_dealloc DD imagerel listreviter_dealloc
	DD	imagerel listreviter_dealloc+182
	DD	imagerel $unwind$listreviter_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listreviter_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT listreviter_dealloc
_TEXT	SEGMENT
it$ = 64
listreviter_dealloc PROC				; COMDAT

; 2975 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 2976 :     PyObject_GC_UnTrack(it);

  0000d	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 2977 :     Py_XDECREF(it->it_seq);

  00012	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
  00016	48 85 db	 test	 rbx, rbx
  00019	0f 84 85 00 00
	00		 je	 $LN3@listrevite
  0001f	e8 00 00 00 00	 call	 _Py_PXCTX
  00024	85 c0		 test	 eax, eax
  00026	75 7c		 jne	 SHORT $LN3@listrevite
  00028	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0002c	a8 20		 test	 al, 32			; 00000020H
  0002e	75 6c		 jne	 SHORT $LN11@listrevite
  00030	84 c0		 test	 al, al
  00032	78 68		 js	 SHORT $LN11@listrevite
  00034	a8 02		 test	 al, 2
  00036	75 6c		 jne	 SHORT $LN3@listrevite
  00038	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0003c	75 66		 jne	 SHORT $LN3@listrevite
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0004c	4c 8b cb	 mov	 r9, rbx
  0004f	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00055	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0005d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00062	48 8b cb	 mov	 rcx, rbx
  00065	85 c0		 test	 eax, eax
  00067	74 17		 je	 SHORT $LN16@listrevite
  00069	e8 00 00 00 00	 call	 _Px_Dealloc

; 2978 :     PyObject_GC_Del(it);

  0006e	48 8b cf	 mov	 rcx, rdi

; 2979 : }

  00071	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00076	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007a	5f		 pop	 rdi
  0007b	e9 00 00 00 00	 jmp	 PyObject_GC_Del

; 2977 :     Py_XDECREF(it->it_seq);

$LN16@listrevite:
  00080	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00084	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 2978 :     PyObject_GC_Del(it);

  0008a	48 8b cf	 mov	 rcx, rdi

; 2979 : }

  0008d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00092	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00096	5f		 pop	 rdi
  00097	e9 00 00 00 00	 jmp	 PyObject_GC_Del

; 2977 :     Py_XDECREF(it->it_seq);

$LN11@listrevite:
  0009c	48 8b cb	 mov	 rcx, rbx
  0009f	e8 00 00 00 00	 call	 Px_DecRef
$LN3@listrevite:

; 2978 :     PyObject_GC_Del(it);

  000a4	48 8b cf	 mov	 rcx, rdi

; 2979 : }

  000a7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b0	5f		 pop	 rdi
  000b1	e9 00 00 00 00	 jmp	 PyObject_GC_Del
listreviter_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@JIDABJDP@listreviter_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$listreviter_traverse DD imagerel listreviter_traverse
	DD	imagerel listreviter_traverse+97
	DD	imagerel $unwind$listreviter_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listreviter_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BF@JIDABJDP@listreviter_traverse?$AA@
CONST	SEGMENT
??_C@_0BF@JIDABJDP@listreviter_traverse?$AA@ DB 'listreviter_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT listreviter_traverse
_TEXT	SEGMENT
it$ = 48
visit$ = 56
arg$ = 64
listreviter_traverse PROC				; COMDAT

; 2983 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 2984 :     Py_VISIT(it->it_seq);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN3@listrevite@2
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJIDBIMM@?4?4?2Objects?2listobject?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@JIDABJDP@listreviter_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 a8 0b 00
	00		 mov	 r8d, 2984		; 00000ba8H
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@listrevite@2:
  0003d	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00041	48 85 c9	 test	 rcx, rcx
  00044	74 09		 je	 SHORT $LN5@listrevite@2
  00046	48 8b d7	 mov	 rdx, rdi
  00049	ff d6		 call	 rsi
  0004b	85 c0		 test	 eax, eax
  0004d	75 02		 jne	 SHORT $LN7@listrevite@2
$LN5@listrevite@2:

; 2985 :     return 0;

  0004f	33 c0		 xor	 eax, eax
$LN7@listrevite@2:

; 2986 : }

  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
listreviter_traverse ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$listreviter_next DD imagerel listreviter_next
	DD	imagerel listreviter_next+27
	DD	imagerel $unwind$listreviter_next
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$listreviter_next DD imagerel listreviter_next+27
	DD	imagerel listreviter_next+116
	DD	imagerel $chain$0$listreviter_next
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$listreviter_next DD imagerel listreviter_next+116
	DD	imagerel listreviter_next+152
	DD	imagerel $chain$1$listreviter_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$listreviter_next DD 021H
	DD	imagerel listreviter_next
	DD	imagerel listreviter_next+27
	DD	imagerel $unwind$listreviter_next
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$listreviter_next DD 020521H
	DD	063405H
	DD	imagerel listreviter_next
	DD	imagerel listreviter_next+27
	DD	imagerel $unwind$listreviter_next
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listreviter_next DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT listreviter_next
_TEXT	SEGMENT
it$ = 64
listreviter_next PROC					; COMDAT

; 2990 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2991 :     PyObject *item;
; 2992 :     Py_ssize_t index = it->it_index;

  00004	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]

; 2993 :     PyListObject *seq = it->it_seq;

  00008	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]

; 2994 : 
; 2995 :     if (index>=0 && index < PyList_GET_SIZE(seq)) {

  0000c	48 85 d2	 test	 rdx, rdx
  0000f	78 63		 js	 SHORT $LN2@listrevite@3
  00011	48 3b 50 60	 cmp	 rdx, QWORD PTR [rax+96]
  00015	7d 5d		 jge	 SHORT $LN2@listrevite@3

; 2996 :         item = PyList_GET_ITEM(seq, index);

  00017	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0001b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00020	48 8b 1c d0	 mov	 rbx, QWORD PTR [rax+rdx*8]

; 2997 :         it->it_index--;

  00024	48 8d 42 ff	 lea	 rax, QWORD PTR [rdx-1]
  00028	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 2998 :         Py_INCREF(item);

  0002c	e8 00 00 00 00	 call	 _Py_PXCTX
  00031	85 c0		 test	 eax, eax
  00033	75 32		 jne	 SHORT $LN6@listrevite@3
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00043	4c 8b cb	 mov	 r9, rbx
  00046	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0004c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00054	e8 00 00 00 00	 call	 _PyParallel_Guard
  00059	85 c0		 test	 eax, eax
  0005b	75 06		 jne	 SHORT $LN5@listrevite@3
  0005d	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00061	74 04		 je	 SHORT $LN6@listrevite@3
$LN5@listrevite@3:
  00063	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@listrevite@3:

; 2999 :         return item;

  00067	48 8b c3	 mov	 rax, rbx
  0006a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 3007 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
$LN2@listrevite@3:

; 3000 :     }
; 3001 :     it->it_index = -1;

  00074	48 c7 41 60 ff
	ff ff ff	 mov	 QWORD PTR [rcx+96], -1

; 3002 :     if (seq != NULL) {

  0007c	48 85 c0	 test	 rax, rax
  0007f	74 10		 je	 SHORT $LN1@listrevite@3

; 3003 :         it->it_seq = NULL;

  00081	48 c7 41 68 00
	00 00 00	 mov	 QWORD PTR [rcx+104], 0

; 3004 :         Py_DECREF(seq);

  00089	48 8b c8	 mov	 rcx, rax
  0008c	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@listrevite@3:

; 3005 :     }
; 3006 :     return NULL;

  00091	33 c0		 xor	 eax, eax

; 3007 : }

  00093	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00097	c3		 ret	 0
listreviter_next ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT listreviter_len
_TEXT	SEGMENT
it$ = 8
listreviter_len PROC					; COMDAT

; 3012 :     Py_ssize_t len = it->it_index + 1;

  00000	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]

; 3013 :     if (it->it_seq == NULL || PyList_GET_SIZE(it->it_seq) < len)

  00004	48 8b 51 68	 mov	 rdx, QWORD PTR [rcx+104]
  00008	48 ff c0	 inc	 rax
  0000b	48 85 d2	 test	 rdx, rdx
  0000e	74 06		 je	 SHORT $LN1@listrevite@4
  00010	48 39 42 60	 cmp	 QWORD PTR [rdx+96], rax
  00014	7d 02		 jge	 SHORT $LN2@listrevite@4
$LN1@listrevite@4:

; 3014 :         len = 0;

  00016	33 c0		 xor	 eax, eax
$LN2@listrevite@4:

; 3015 :     return PyLong_FromSsize_t(len);

  00018	48 8b c8	 mov	 rcx, rax

; 3016 : }

  0001b	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
listreviter_len ENDP
_TEXT	ENDS
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$listreviter_setstate DD imagerel listreviter_setstate
	DD	imagerel listreviter_setstate+179
	DD	imagerel $unwind$listreviter_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listreviter_setstate DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\listobject.c
xdata	ENDS
;	COMDAT listreviter_setstate
_TEXT	SEGMENT
it$ = 64
state$ = 72
listreviter_setstate PROC				; COMDAT

; 3026 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 3027 :     Py_ssize_t index = PyLong_AsSsize_t(state);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00015	48 8b d8	 mov	 rbx, rax

; 3028 :     if (index == -1 && PyErr_Occurred())

  00018	48 83 f8 ff	 cmp	 rax, -1
  0001c	75 17		 jne	 SHORT $LN5@listrevite@5
  0001e	e8 00 00 00 00	 call	 PyErr_Occurred
  00023	48 85 c0	 test	 rax, rax
  00026	74 0d		 je	 SHORT $LN5@listrevite@5

; 3029 :         return NULL;

  00028	33 c0		 xor	 eax, eax

; 3038 : }

  0002a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0002f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00033	5f		 pop	 rdi
  00034	c3		 ret	 0
$LN5@listrevite@5:

; 3030 :     if (it->it_seq != NULL) {

  00035	48 8b 47 68	 mov	 rax, QWORD PTR [rdi+104]
  00039	48 85 c0	 test	 rax, rax
  0003c	74 1e		 je	 SHORT $LN4@listrevite@5

; 3031 :         if (index < -1)

  0003e	48 83 fb ff	 cmp	 rbx, -1
  00042	7d 06		 jge	 SHORT $LN3@listrevite@5

; 3032 :             index = -1;

  00044	48 83 cb ff	 or	 rbx, -1
  00048	eb 0e		 jmp	 SHORT $LN1@listrevite@5
$LN3@listrevite@5:

; 3033 :         else if (index > PyList_GET_SIZE(it->it_seq) - 1)

  0004a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0004e	48 ff c8	 dec	 rax
  00051	48 3b d8	 cmp	 rbx, rax
  00054	48 0f 4f d8	 cmovg	 rbx, rax
$LN1@listrevite@5:

; 3034 :             index = PyList_GET_SIZE(it->it_seq) - 1;
; 3035 :         it->it_index = index;

  00058	48 89 5f 60	 mov	 QWORD PTR [rdi+96], rbx
$LN4@listrevite@5:

; 3036 :     }
; 3037 :     Py_RETURN_NONE;

  0005c	e8 00 00 00 00	 call	 _Py_PXCTX
  00061	85 c0		 test	 eax, eax
  00063	75 3c		 jne	 SHORT $LN9@listrevite@5
  00065	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0007a	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00080	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00088	e8 00 00 00 00	 call	 _PyParallel_Guard
  0008d	85 c0		 test	 eax, eax
  0008f	75 09		 jne	 SHORT $LN8@listrevite@5
  00091	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00098	74 07		 je	 SHORT $LN9@listrevite@5
$LN8@listrevite@5:
  0009a	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN9@listrevite@5:
  000a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 3038 : }

  000a8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ad	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b1	5f		 pop	 rdi
  000b2	c3		 ret	 0
listreviter_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@		; `string'
PUBLIC	??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@		; `string'
PUBLIC	??_C@_08DNDMMOJA@reversed?$AA@			; `string'
PUBLIC	??_C@_05LHHNEACK@N?$CIO?$CJl?$AA@		; `string'
PUBLIC	??_C@_04BKLHDIKK@iter?$AA@			; `string'
EXTRN	Py_BuildValue:PROC
EXTRN	_PyObject_GetBuiltin:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$listiter_reduce_general DD imagerel listiter_reduce_general
	DD	imagerel listiter_reduce_general+185
	DD	imagerel $unwind$listiter_reduce_general
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listiter_reduce_general DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@
CONST	SEGMENT
??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@ DB 'N(N)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@
CONST	SEGMENT
??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@ DB 'N(O)n', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DNDMMOJA@reversed?$AA@
CONST	SEGMENT
??_C@_08DNDMMOJA@reversed?$AA@ DB 'reversed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05LHHNEACK@N?$CIO?$CJl?$AA@
CONST	SEGMENT
??_C@_05LHHNEACK@N?$CIO?$CJl?$AA@ DB 'N(O)l', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKLHDIKK@iter?$AA@
CONST	SEGMENT
??_C@_04BKLHDIKK@iter?$AA@ DB 'iter', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT listiter_reduce_general
_TEXT	SEGMENT
_it$ = 48
forward$ = 56
listiter_reduce_general PROC				; COMDAT

; 3044 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3045 :     PyObject *list;
; 3046 : 
; 3047 :     /* the objects are not the same, index is of different types! */
; 3048 :     if (forward) {
; 3049 :         listiterobject *it = (listiterobject *)_it;
; 3050 :         if (it->it_seq)

  0000a	48 8b 79 68	 mov	 rdi, QWORD PTR [rcx+104]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	85 d2		 test	 edx, edx
  00013	74 31		 je	 SHORT $LN5@listiter_r
  00015	48 85 ff	 test	 rdi, rdi
  00018	74 5d		 je	 SHORT $LN2@listiter_r

; 3051 :             return Py_BuildValue("N(O)l", _PyObject_GetBuiltin("iter"),
; 3052 :                                  it->it_seq, it->it_index);

  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BKLHDIKK@iter?$AA@
  00021	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  00026	44 8b 4b 60	 mov	 r9d, DWORD PTR [rbx+96]
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05LHHNEACK@N?$CIO?$CJl?$AA@
  00031	48 8b d0	 mov	 rdx, rax
  00034	4c 8b c7	 mov	 r8, rdi

; 3064 : }

  00037	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi
  00041	e9 00 00 00 00	 jmp	 Py_BuildValue
$LN5@listiter_r:

; 3053 :     } else {
; 3054 :         listreviterobject *it = (listreviterobject *)_it;
; 3055 :         if (it->it_seq)

  00046	48 85 ff	 test	 rdi, rdi
  00049	74 2c		 je	 SHORT $LN2@listiter_r

; 3056 :             return Py_BuildValue("N(O)n", _PyObject_GetBuiltin("reversed"),
; 3057 :                                  it->it_seq, it->it_index);

  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08DNDMMOJA@reversed?$AA@
  00052	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  00057	4c 8b 4b 60	 mov	 r9, QWORD PTR [rbx+96]
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@
  00062	48 8b d0	 mov	 rdx, rax
  00065	4c 8b c7	 mov	 r8, rdi

; 3064 : }

  00068	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00071	5f		 pop	 rdi
  00072	e9 00 00 00 00	 jmp	 Py_BuildValue
$LN2@listiter_r:

; 3058 :     }
; 3059 :     /* empty iterator, create an empty list */
; 3060 :     list = PyList_New(0);

  00077	33 c9		 xor	 ecx, ecx
  00079	e8 00 00 00 00	 call	 PyList_New
  0007e	48 8b d8	 mov	 rbx, rax

; 3061 :     if (list == NULL)

  00081	48 85 c0	 test	 rax, rax
  00084	75 0b		 jne	 SHORT $LN1@listiter_r

; 3064 : }

  00086	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008f	5f		 pop	 rdi
  00090	c3		 ret	 0
$LN1@listiter_r:

; 3062 :         return NULL;
; 3063 :     return Py_BuildValue("N(N)", _PyObject_GetBuiltin("iter"), list);

  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BKLHDIKK@iter?$AA@
  00098	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@
  000a4	4c 8b c3	 mov	 r8, rbx
  000a7	48 8b d0	 mov	 rdx, rax

; 3064 : }

  000aa	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000af	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b3	5f		 pop	 rdi
  000b4	e9 00 00 00 00	 jmp	 Py_BuildValue
listiter_reduce_general ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT listiter_reduce
_TEXT	SEGMENT
it$ = 8
listiter_reduce PROC					; COMDAT

; 2884 :     return listiter_reduce_general(it, 1);

  00000	ba 01 00 00 00	 mov	 edx, 1

; 2885 : }

  00005	e9 00 00 00 00	 jmp	 listiter_reduce_general
listiter_reduce ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT listreviter_reduce
_TEXT	SEGMENT
it$ = 8
listreviter_reduce PROC					; COMDAT

; 3021 :     return listiter_reduce_general(it, 0);

  00000	33 d2		 xor	 edx, edx

; 3022 : }

  00002	e9 00 00 00 00	 jmp	 listiter_reduce_general
listreviter_reduce ENDP
_TEXT	ENDS
END
