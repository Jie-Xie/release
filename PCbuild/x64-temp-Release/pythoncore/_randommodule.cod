; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_07KPBKOMIO@_random?$AA@			; `string'
PUBLIC	??_C@_0P@BMHHKIKM@_random?4Random?$AA@		; `string'
PUBLIC	??_C@_0DL@OGGNEOFD@getrandbits?$CIk?$CJ?5?9?$DO?5x?4?5?5Generates?5@ ; `string'
PUBLIC	??_C@_0M@HOAPOEBA@getrandbits?$AA@		; `string'
PUBLIC	??_C@_0DE@PFEOEBCD@setstate?$CIstate?$CJ?5?9?$DO?5None?4?5?5Restor@ ; `string'
PUBLIC	??_C@_08BJPILIMO@setstate?$AA@			; `string'
PUBLIC	??_C@_0DC@DEMJLMBG@getstate?$CI?$CJ?5?9?$DO?5tuple?5containing?5t@ ; `string'
PUBLIC	??_C@_08OINEKLLD@getstate?$AA@			; `string'
PUBLIC	??_C@_0CO@HHDJAPIE@seed?$CI?$FLn?$FN?$CJ?5?9?$DO?5None?4?5?5Defaults?5to?5@ ; `string'
PUBLIC	??_C@_04MENKDCKE@seed?$AA@			; `string'
PUBLIC	??_C@_0CG@FGCGGJHI@random?$CI?$CJ?5?9?$DO?5x?5in?5the?5interval?5?$FL0@ ; `string'
PUBLIC	??_C@_06NLFCANPD@random?$AA@			; `string'
EXTRN	PyObject_Free:PROC
EXTRN	PyObject_GenericGetAttr:PROC
;	COMDAT ??_C@_07KPBKOMIO@_random?$AA@
CONST	SEGMENT
??_C@_07KPBKOMIO@_random?$AA@ DB '_random', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BMHHKIKM@_random?4Random?$AA@
CONST	SEGMENT
??_C@_0P@BMHHKIKM@_random?4Random?$AA@ DB '_random.Random', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@OGGNEOFD@getrandbits?$CIk?$CJ?5?9?$DO?5x?4?5?5Generates?5@
CONST	SEGMENT
??_C@_0DL@OGGNEOFD@getrandbits?$CIk?$CJ?5?9?$DO?5x?4?5?5Generates?5@ DB 'g'
	DB	'etrandbits(k) -> x.  Generates an int with k random bits.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HOAPOEBA@getrandbits?$AA@
CONST	SEGMENT
??_C@_0M@HOAPOEBA@getrandbits?$AA@ DB 'getrandbits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PFEOEBCD@setstate?$CIstate?$CJ?5?9?$DO?5None?4?5?5Restor@
CONST	SEGMENT
??_C@_0DE@PFEOEBCD@setstate?$CIstate?$CJ?5?9?$DO?5None?4?5?5Restor@ DB 's'
	DB	'etstate(state) -> None.  Restores generator state.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BJPILIMO@setstate?$AA@
CONST	SEGMENT
??_C@_08BJPILIMO@setstate?$AA@ DB 'setstate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DEMJLMBG@getstate?$CI?$CJ?5?9?$DO?5tuple?5containing?5t@
CONST	SEGMENT
??_C@_0DC@DEMJLMBG@getstate?$CI?$CJ?5?9?$DO?5tuple?5containing?5t@ DB 'ge'
	DB	'tstate() -> tuple containing the current state.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OINEKLLD@getstate?$AA@
CONST	SEGMENT
??_C@_08OINEKLLD@getstate?$AA@ DB 'getstate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HHDJAPIE@seed?$CI?$FLn?$FN?$CJ?5?9?$DO?5None?4?5?5Defaults?5to?5@
CONST	SEGMENT
??_C@_0CO@HHDJAPIE@seed?$CI?$FLn?$FN?$CJ?5?9?$DO?5None?4?5?5Defaults?5to?5@ DB 's'
	DB	'eed([n]) -> None.  Defaults to current time.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MENKDCKE@seed?$AA@
CONST	SEGMENT
??_C@_04MENKDCKE@seed?$AA@ DB 'seed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@FGCGGJHI@random?$CI?$CJ?5?9?$DO?5x?5in?5the?5interval?5?$FL0@
CONST	SEGMENT
??_C@_0CG@FGCGGJHI@random?$CI?$CJ?5?9?$DO?5x?5in?5the?5interval?5?$FL0@ DB 'r'
	DB	'andom() -> x in the interval [0, 1).', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06NLFCANPD@random?$AA@
CONST	SEGMENT
??_C@_06NLFCANPD@random?$AA@ DB 'random', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?mag01@?1??genrand_int32@@9@9 DD 00H			; `genrand_int32'::`2'::mag01
	DD	09908b0dfH
	ORG $+8
random_methods DQ FLAT:??_C@_06NLFCANPD@random?$AA@
	DQ	FLAT:random_random
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CG@FGCGGJHI@random?$CI?$CJ?5?9?$DO?5x?5in?5the?5interval?5?$FL0@
	DQ	FLAT:??_C@_04MENKDCKE@seed?$AA@
	DQ	FLAT:random_seed
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0CO@HHDJAPIE@seed?$CI?$FLn?$FN?$CJ?5?9?$DO?5None?4?5?5Defaults?5to?5@
	DQ	FLAT:??_C@_08OINEKLLD@getstate?$AA@
	DQ	FLAT:random_getstate
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DC@DEMJLMBG@getstate?$CI?$CJ?5?9?$DO?5tuple?5containing?5t@
	DQ	FLAT:??_C@_08BJPILIMO@setstate?$AA@
	DQ	FLAT:random_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0DE@PFEOEBCD@setstate?$CIstate?$CJ?5?9?$DO?5None?4?5?5Restor@
	DQ	FLAT:??_C@_0M@HOAPOEBA@getrandbits?$AA@
	DQ	FLAT:random_getrandbits
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0DL@OGGNEOFD@getrandbits?$CIk?$CJ?5?9?$DO?5x?4?5?5Generates?5@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
random_doc DB	'Random() -> create a random number generator with its ow'
	DB	'n internal state.', 00H
	ORG $+6
Random_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0P@BMHHKIKM@_random?4Random?$AA@
	DQ	0000000000000a30H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:random_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:random_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:random_new
	DQ	FLAT:PyObject_Free
	DQ	0000000000000000H
	ORG $+56
module_doc DB	'Module implements the Mersenne Twister random number gen'
	DB	'erator.', 00H
_randommodule DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_07KPBKOMIO@_random?$AA@
	DQ	FLAT:module_doc
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
EXTRN	__imp__time64:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT time
_TEXT	SEGMENT
_Time$ = 8
time	PROC						; COMDAT

; 133  :     return _time64(_Time);
; 134  : }

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__time64
time	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_randommodule.c
_TEXT	ENDS
;	COMDAT genrand_int32
_TEXT	SEGMENT
self$ = 8
genrand_int32 PROC					; COMDAT

; 97   :     unsigned long y;
; 98   :     static unsigned long mag01[2]={0x0UL, MATRIX_A};
; 99   :     /* mag01[x] = x * MATRIX_A  for x=0,1 */
; 100  :     unsigned long *mt;
; 101  : 
; 102  :     mt = self->state;
; 103  :     if (self->index >= N) { /* generate N words at one time */

  00000	81 b9 20 0a 00
	00 70 02 00 00	 cmp	 DWORD PTR [rcx+2592], 624 ; 00000270H
  0000a	4c 8b c1	 mov	 r8, rcx
  0000d	0f 8c c2 00 00
	00		 jl	 $LN7@genrand_in

; 104  :         int kk;
; 105  : 
; 106  :         for (kk=0;kk<N-M;kk++) {

  00013	45 33 c9	 xor	 r9d, r9d
  00016	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:?mag01@?1??genrand_int32@@9@9
  0001d	ba e3 00 00 00	 mov	 edx, 227		; 000000e3H
$LL6@genrand_in:

; 107  :             y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);

  00022	43 8b 4c 88 64	 mov	 ecx, DWORD PTR [r8+r9*4+100]
  00027	49 ff c1	 inc	 r9
  0002a	43 33 4c 88 5c	 xor	 ecx, DWORD PTR [r8+r9*4+92]
  0002f	0f ba f1 1f	 btr	 ecx, 31
  00033	43 33 4c 88 5c	 xor	 ecx, DWORD PTR [r8+r9*4+92]

; 108  :             mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];

  00038	8b c1		 mov	 eax, ecx
  0003a	d1 e9		 shr	 ecx, 1
  0003c	83 e0 01	 and	 eax, 1
  0003f	41 8b 04 82	 mov	 eax, DWORD PTR [r10+rax*4]
  00043	33 c1		 xor	 eax, ecx
  00045	43 33 84 88 90
	06 00 00	 xor	 eax, DWORD PTR [r8+r9*4+1680]
  0004d	43 89 44 88 5c	 mov	 DWORD PTR [r8+r9*4+92], eax
  00052	4c 3b ca	 cmp	 r9, rdx
  00055	7c cb		 jl	 SHORT $LL6@genrand_in
  00057	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL3@genrand_in:

; 109  :         }
; 110  :         for (;kk<N-1;kk++) {
; 111  :             y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);

  00060	41 8b 4c 90 64	 mov	 ecx, DWORD PTR [r8+rdx*4+100]
  00065	48 ff c2	 inc	 rdx
  00068	41 33 4c 90 5c	 xor	 ecx, DWORD PTR [r8+rdx*4+92]
  0006d	0f ba f1 1f	 btr	 ecx, 31
  00071	41 33 4c 90 5c	 xor	 ecx, DWORD PTR [r8+rdx*4+92]

; 112  :             mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];

  00076	8b c1		 mov	 eax, ecx
  00078	d1 e9		 shr	 ecx, 1
  0007a	83 e0 01	 and	 eax, 1
  0007d	41 8b 04 82	 mov	 eax, DWORD PTR [r10+rax*4]
  00081	33 c1		 xor	 eax, ecx
  00083	41 33 84 90 d0
	fc ff ff	 xor	 eax, DWORD PTR [r8+rdx*4-816]
  0008b	41 89 44 90 5c	 mov	 DWORD PTR [r8+rdx*4+92], eax
  00090	48 81 fa 6f 02
	00 00		 cmp	 rdx, 623		; 0000026fH
  00097	7c c7		 jl	 SHORT $LL3@genrand_in

; 113  :         }
; 114  :         y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);

  00099	41 8b 90 1c 0a
	00 00		 mov	 edx, DWORD PTR [r8+2588]
  000a0	41 33 50 60	 xor	 edx, DWORD PTR [r8+96]
  000a4	0f ba f2 1f	 btr	 edx, 31
  000a8	41 33 90 1c 0a
	00 00		 xor	 edx, DWORD PTR [r8+2588]

; 115  :         mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];

  000af	8b c2		 mov	 eax, edx
  000b1	d1 ea		 shr	 edx, 1
  000b3	83 e0 01	 and	 eax, 1
  000b6	41 8b 0c 82	 mov	 ecx, DWORD PTR [r10+rax*4]
  000ba	41 33 88 90 06
	00 00		 xor	 ecx, DWORD PTR [r8+1680]
  000c1	33 ca		 xor	 ecx, edx
  000c3	41 89 88 1c 0a
	00 00		 mov	 DWORD PTR [r8+2588], ecx

; 116  : 
; 117  :         self->index = 0;

  000ca	41 c7 80 20 0a
	00 00 00 00 00
	00		 mov	 DWORD PTR [r8+2592], 0
$LN7@genrand_in:

; 118  :     }
; 119  : 
; 120  :     y = mt[self->index++];

  000d5	49 63 88 20 0a
	00 00		 movsxd	 rcx, DWORD PTR [r8+2592]
  000dc	41 8b 54 88 60	 mov	 edx, DWORD PTR [r8+rcx*4+96]
  000e1	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  000e4	41 89 80 20 0a
	00 00		 mov	 DWORD PTR [r8+2592], eax

; 121  :     y ^= (y >> 11);

  000eb	8b c2		 mov	 eax, edx
  000ed	c1 e8 0b	 shr	 eax, 11
  000f0	33 d0		 xor	 edx, eax

; 122  :     y ^= (y << 7) & 0x9d2c5680UL;

  000f2	8b c2		 mov	 eax, edx
  000f4	25 ad 58 3a ff	 and	 eax, -12953427		; ff3a58adH
  000f9	c1 e0 07	 shl	 eax, 7
  000fc	33 d0		 xor	 edx, eax

; 123  :     y ^= (y << 15) & 0xefc60000UL;

  000fe	8b c2		 mov	 eax, edx
  00100	25 8c df ff ff	 and	 eax, -8308		; ffffdf8cH
  00105	c1 e0 0f	 shl	 eax, 15
  00108	33 d0		 xor	 edx, eax

; 124  :     y ^= (y >> 18);

  0010a	8b c2		 mov	 eax, edx
  0010c	c1 e8 12	 shr	 eax, 18
  0010f	33 c2		 xor	 eax, edx

; 125  :     return y;
; 126  : }

  00111	c3		 ret	 0
genrand_int32 ENDP
_TEXT	ENDS
PUBLIC	__real@3ca0000000000000
PUBLIC	__real@4190000000000000
EXTRN	PyFloat_FromDouble:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$random_random DD imagerel random_random
	DD	imagerel random_random+80
	DD	imagerel $unwind$random_random
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$random_random DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT __real@3ca0000000000000
CONST	SEGMENT
__real@3ca0000000000000 DQ 03ca0000000000000r	; 1.11022e-016
CONST	ENDS
;	COMDAT __real@4190000000000000
CONST	SEGMENT
__real@4190000000000000 DQ 04190000000000000r	; 6.71089e+007
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT random_random
_TEXT	SEGMENT
self$ = 48
random_random PROC					; COMDAT

; 139  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4c 8b d9	 mov	 r11, rcx

; 140  :     unsigned long a=genrand_int32(self)>>5, b=genrand_int32(self)>>6;

  00009	e8 00 00 00 00	 call	 genrand_int32
  0000e	49 8b cb	 mov	 rcx, r11
  00011	8b d8		 mov	 ebx, eax
  00013	c1 eb 05	 shr	 ebx, 5
  00016	e8 00 00 00 00	 call	 genrand_int32

; 141  :     return PyFloat_FromDouble((a*67108864.0+b)*(1.0/9007199254740992.0));

  0001b	8b cb		 mov	 ecx, ebx
  0001d	66 0f ef c0	 pxor	 xmm0, xmm0
  00021	66 0f ef c9	 pxor	 xmm1, xmm1
  00025	c1 e8 06	 shr	 eax, 6
  00028	f2 48 0f 2a c1	 cvtsi2sd xmm0, rcx
  0002d	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  00032	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4190000000000000
  0003a	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0003e	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3ca0000000000000

; 142  : }

  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5b		 pop	 rbx
  0004b	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
random_random ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT init_genrand
_TEXT	SEGMENT
self$ = 8
s$ = 16
init_genrand PROC					; COMDAT

; 148  :     int mti;
; 149  :     unsigned long *mt;
; 150  : 
; 151  :     mt = self->state;
; 152  :     mt[0]= s & 0xffffffffUL;

  00000	89 51 60	 mov	 DWORD PTR [rcx+96], edx

; 153  :     for (mti=1; mti<N; mti++) {

  00003	41 b8 01 00 00
	00		 mov	 r8d, 1
  00009	4c 8d 49 64	 lea	 r9, QWORD PTR [rcx+100]
  0000d	0f 1f 00	 npad	 3
$LL3@init_genra:

; 154  :         mt[mti] =
; 155  :         (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);

  00010	41 8b 41 fc	 mov	 eax, DWORD PTR [r9-4]
  00014	49 83 c1 04	 add	 r9, 4
  00018	8b d0		 mov	 edx, eax
  0001a	c1 ea 1e	 shr	 edx, 30
  0001d	33 d0		 xor	 edx, eax
  0001f	69 d2 65 89 07
	6c		 imul	 edx, 1812433253		; 6c078965H
  00025	41 03 d0	 add	 edx, r8d
  00028	41 ff c0	 inc	 r8d

; 156  :         /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
; 157  :         /* In the previous versions, MSBs of the seed affect   */
; 158  :         /* only MSBs of the array mt[].                                */
; 159  :         /* 2002/01/09 modified by Makoto Matsumoto                     */
; 160  :         mt[mti] &= 0xffffffffUL;

  0002b	41 89 51 fc	 mov	 DWORD PTR [r9-4], edx
  0002f	41 81 f8 70 02
	00 00		 cmp	 r8d, 624		; 00000270H
  00036	7c d8		 jl	 SHORT $LL3@init_genra

; 161  :         /* for >32 bit machines */
; 162  :     }
; 163  :     self->index = mti;

  00038	44 89 81 20 0a
	00 00		 mov	 DWORD PTR [rcx+2592], r8d

; 164  :     return;
; 165  : }

  0003f	c3		 ret	 0
init_genrand ENDP
_TEXT	ENDS
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$init_by_array DD imagerel init_by_array
	DD	imagerel init_by_array+355
	DD	imagerel $unwind$init_by_array
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init_by_array DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_randommodule.c
xdata	ENDS
;	COMDAT init_by_array
_TEXT	SEGMENT
self$ = 64
init_key$ = 72
key_length$ = 80
init_by_array PROC					; COMDAT

; 172  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f2	 mov	 rsi, rdx

; 173  :     unsigned int i, j, k;       /* was signed in the original code. RDH 12/16/2002 */
; 174  :     unsigned long *mt;
; 175  : 
; 176  :     mt = self->state;
; 177  :     init_genrand(self, 19650218UL);

  00017	ba aa d6 2b 01	 mov	 edx, 19650218		; 012bd6aaH
  0001c	41 8b f8	 mov	 edi, r8d
  0001f	4c 8b d1	 mov	 r10, rcx
  00022	e8 00 00 00 00	 call	 init_genrand

; 178  :     i=1; j=0;
; 179  :     k = (N>key_length ? N : key_length);

  00027	bd 70 02 00 00	 mov	 ebp, 624		; 00000270H
  0002c	45 33 db	 xor	 r11d, r11d
  0002f	3b fd		 cmp	 edi, ebp
  00031	8b d7		 mov	 edx, edi
  00033	0f 42 d5	 cmovb	 edx, ebp
  00036	41 b9 01 00 00
	00		 mov	 r9d, 1
  0003c	33 db		 xor	 ebx, ebx
  0003e	45 8b c1	 mov	 r8d, r9d

; 180  :     for (; k; k--) {

  00041	85 d2		 test	 edx, edx
  00043	74 61		 je	 SHORT $LN7@init_by_ar
  00045	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL9@init_by_ar:

; 181  :         mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL))
; 182  :                  + init_key[j] + j; /* non linear */

  00050	43 8b 44 82 5c	 mov	 eax, DWORD PTR [r10+r8*4+92]

; 183  :         mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
; 184  :         i++; j++;

  00055	41 ff c1	 inc	 r9d
  00058	49 ff c0	 inc	 r8
  0005b	8b c8		 mov	 ecx, eax
  0005d	48 ff c3	 inc	 rbx
  00060	c1 e9 1e	 shr	 ecx, 30
  00063	33 c8		 xor	 ecx, eax
  00065	69 c9 0d 66 19
	00		 imul	 ecx, 1664525		; 0019660dH
  0006b	43 33 4c 82 5c	 xor	 ecx, DWORD PTR [r10+r8*4+92]
  00070	03 4c 9e fc	 add	 ecx, DWORD PTR [rsi+rbx*4-4]
  00074	41 03 cb	 add	 ecx, r11d
  00077	41 ff c3	 inc	 r11d
  0007a	43 89 4c 82 5c	 mov	 DWORD PTR [r10+r8*4+92], ecx

; 185  :         if (i>=N) { mt[0] = mt[N-1]; i=1; }

  0007f	44 3b cd	 cmp	 r9d, ebp
  00082	72 14		 jb	 SHORT $LN6@init_by_ar
  00084	41 8b 82 1c 0a
	00 00		 mov	 eax, DWORD PTR [r10+2588]
  0008b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00091	41 89 42 60	 mov	 DWORD PTR [r10+96], eax
  00095	45 8b c1	 mov	 r8d, r9d
$LN6@init_by_ar:

; 186  :         if (j>=key_length) j=0;

  00098	44 3b df	 cmp	 r11d, edi
  0009b	72 05		 jb	 SHORT $LN8@init_by_ar
  0009d	45 33 db	 xor	 r11d, r11d
  000a0	33 db		 xor	 ebx, ebx
$LN8@init_by_ar:

; 180  :     for (; k; k--) {

  000a2	ff ca		 dec	 edx
  000a4	75 aa		 jne	 SHORT $LL9@init_by_ar
$LN7@init_by_ar:

; 187  :     }
; 188  :     for (k=N-1; k; k--) {

  000a6	41 b8 6f 02 00
	00		 mov	 r8d, 623		; 0000026fH
  000ac	49 63 d1	 movsxd	 rdx, r9d
  000af	90		 npad	 1
$LL4@init_by_ar:

; 189  :         mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL))
; 190  :                  - i; /* non linear */

  000b0	41 8b 44 92 5c	 mov	 eax, DWORD PTR [r10+rdx*4+92]

; 191  :         mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
; 192  :         i++;

  000b5	48 ff c2	 inc	 rdx
  000b8	8b c8		 mov	 ecx, eax
  000ba	c1 e9 1e	 shr	 ecx, 30
  000bd	33 c8		 xor	 ecx, eax
  000bf	69 c9 65 8b 58
	5d		 imul	 ecx, 1566083941		; 5d588b65H
  000c5	41 33 4c 92 5c	 xor	 ecx, DWORD PTR [r10+rdx*4+92]
  000ca	41 2b c9	 sub	 ecx, r9d
  000cd	41 ff c1	 inc	 r9d
  000d0	41 89 4c 92 5c	 mov	 DWORD PTR [r10+rdx*4+92], ecx

; 193  :         if (i>=N) { mt[0] = mt[N-1]; i=1; }

  000d5	44 3b cd	 cmp	 r9d, ebp
  000d8	72 13		 jb	 SHORT $LN3@init_by_ar
  000da	41 8b 82 1c 0a
	00 00		 mov	 eax, DWORD PTR [r10+2588]
  000e1	ba 01 00 00 00	 mov	 edx, 1
  000e6	41 89 42 60	 mov	 DWORD PTR [r10+96], eax
  000ea	44 8b ca	 mov	 r9d, edx
$LN3@init_by_ar:

; 187  :     }
; 188  :     for (k=N-1; k; k--) {

  000ed	41 ff c8	 dec	 r8d
  000f0	75 be		 jne	 SHORT $LL4@init_by_ar

; 194  :     }
; 195  : 
; 196  :     mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */

  000f2	41 c7 42 60 00
	00 00 80	 mov	 DWORD PTR [r10+96], -2147483648 ; 80000000H

; 197  :     Py_INCREF(Py_None);

  000fa	e8 00 00 00 00	 call	 _Py_PXCTX
  000ff	85 c0		 test	 eax, eax
  00101	75 44		 jne	 SHORT $LN20@init_by_ar
  00103	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  0010a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00111	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00118	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0011e	4c 8b cb	 mov	 r9, rbx
  00121	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00129	e8 00 00 00 00	 call	 _PyParallel_Guard
  0012e	85 c0		 test	 eax, eax
  00130	75 09		 jne	 SHORT $LN12@init_by_ar
  00132	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00139	74 07		 je	 SHORT $LN22@init_by_ar
$LN12@init_by_ar:
  0013b	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN22@init_by_ar:

; 198  :     return Py_None;

  00142	48 8b c3	 mov	 rax, rbx

; 197  :     Py_INCREF(Py_None);

  00145	eb 07		 jmp	 SHORT $LN13@init_by_ar
$LN20@init_by_ar:

; 198  :     return Py_None;

  00147	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 197  :     Py_INCREF(Py_None);

$LN13@init_by_ar:

; 199  : }

  0014e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00153	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00158	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0015d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00161	5f		 pop	 rdi
  00162	c3		 ret	 0
init_by_array ENDP
_TEXT	ENDS
EXTRN	PyMem_Free:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyMem_Realloc:PROC
EXTRN	PyNumber_Rshift:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsUnsignedLong:PROC
EXTRN	PyNumber_And:PROC
EXTRN	PyObject_IsTrue:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyLong_FromUnsignedLong:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	PyLong_FromSize_t:PROC
EXTRN	PyObject_Hash:PROC
EXTRN	PyNumber_Absolute:PROC
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$random_seed DD imagerel random_seed
	DD	imagerel random_seed+86
	DD	imagerel $unwind$random_seed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$random_seed DD imagerel random_seed+86
	DD	imagerel random_seed+174
	DD	imagerel $chain$0$random_seed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$random_seed DD imagerel random_seed+174
	DD	imagerel random_seed+240
	DD	imagerel $chain$2$random_seed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$random_seed DD imagerel random_seed+240
	DD	imagerel random_seed+273
	DD	imagerel $chain$3$random_seed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$random_seed DD imagerel random_seed+273
	DD	imagerel random_seed+570
	DD	imagerel $chain$4$random_seed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$random_seed DD imagerel random_seed+570
	DD	imagerel random_seed+598
	DD	imagerel $chain$5$random_seed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$random_seed DD imagerel random_seed+598
	DD	imagerel random_seed+616
	DD	imagerel $chain$6$random_seed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$random_seed DD imagerel random_seed+616
	DD	imagerel random_seed+650
	DD	imagerel $chain$7$random_seed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$random_seed DD imagerel random_seed+650
	DD	imagerel random_seed+762
	DD	imagerel $chain$9$random_seed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$random_seed DD 020021H
	DD	0a7400H
	DD	imagerel random_seed
	DD	imagerel random_seed+86
	DD	imagerel $unwind$random_seed
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$random_seed DD 021H
	DD	imagerel random_seed+86
	DD	imagerel random_seed+174
	DD	imagerel $chain$0$random_seed
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$random_seed DD 021H
	DD	imagerel random_seed+174
	DD	imagerel random_seed+240
	DD	imagerel $chain$2$random_seed
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$random_seed DD 021H
	DD	imagerel random_seed+240
	DD	imagerel random_seed+273
	DD	imagerel $chain$3$random_seed
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$random_seed DD 020521H
	DD	08e405H
	DD	imagerel random_seed+240
	DD	imagerel random_seed+273
	DD	imagerel $chain$3$random_seed
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$random_seed DD 020521H
	DD	0b6405H
	DD	imagerel random_seed+174
	DD	imagerel random_seed+240
	DD	imagerel $chain$2$random_seed
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$random_seed DD 041221H
	DD	09d412H
	DD	0115408H
	DD	imagerel random_seed+86
	DD	imagerel random_seed+174
	DD	imagerel $chain$0$random_seed
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$random_seed DD 020521H
	DD	0a7405H
	DD	imagerel random_seed
	DD	imagerel random_seed+86
	DD	imagerel $unwind$random_seed
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$random_seed DD 041001H
	DD	0f00cb210H
	DD	03008c00aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_randommodule.c
xdata	ENDS
;	COMDAT random_seed
_TEXT	SEGMENT
tv321 = 48
masklower$1$ = 56
self$ = 128
args$ = 136
thirtytwo$1$ = 144
now$20273 = 144
arg$ = 152
random_seed PROC					; COMDAT

; 208  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 4b 08	 mov	 QWORD PTR [r11+8], rcx
  00007	53		 push	 rbx
  00008	41 54		 push	 r12
  0000a	41 57		 push	 r15
  0000c	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00010	48 8b d9	 mov	 rbx, rcx

; 209  :     PyObject *result = NULL;            /* guilty until proved innocent */

  00013	45 33 ff	 xor	 r15d, r15d

; 210  :     PyObject *masklower = NULL;
; 211  :     PyObject *thirtytwo = NULL;
; 212  :     PyObject *n = NULL;
; 213  :     unsigned long *new_key, *key = NULL;
; 214  :     unsigned long keymax;               /* # of allocated slots in key */
; 215  :     unsigned long keyused;              /* # of used slots in key */
; 216  :     int err;
; 217  : 
; 218  :     PyObject *arg = NULL;
; 219  : 
; 220  :     if (!PyArg_UnpackTuple(args, "seed", 0, 1, &arg))

  00016	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0001a	48 8b c2	 mov	 rax, rdx
  0001d	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  00021	45 8d 4f 01	 lea	 r9d, QWORD PTR [r15+1]
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04MENKDCKE@seed?$AA@
  0002c	45 33 c0	 xor	 r8d, r8d
  0002f	48 8b c8	 mov	 rcx, rax
  00032	45 8b e7	 mov	 r12d, r15d
  00035	4d 89 7b 20	 mov	 QWORD PTR [r11+32], r15
  00039	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0003e	85 c0		 test	 eax, eax
  00040	75 0c		 jne	 SHORT $LN33@random_see

; 221  :         return NULL;

  00042	33 c0		 xor	 eax, eax

; 312  : }

  00044	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00048	41 5f		 pop	 r15
  0004a	41 5c		 pop	 r12
  0004c	5b		 pop	 rbx
  0004d	c3		 ret	 0
$LN33@random_see:

; 222  : 
; 223  :     if (arg == NULL || arg == Py_None) {

  0004e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00056	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0005b	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  00062	48 85 c9	 test	 rcx, rcx
  00065	0f 84 1f 02 00
	00		 je	 $LN31@random_see
  0006b	48 3b cf	 cmp	 rcx, rdi
  0006e	0f 84 16 02 00
	00		 je	 $LN31@random_see

; 230  :     }
; 231  :     /* This algorithm relies on the number being unsigned.
; 232  :      * So: if the arg is a PyLong, use its absolute value.
; 233  :      * Otherwise use its hash value, cast to unsigned.
; 234  :      */
; 235  :     if (PyLong_Check(arg))

  00074	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00078	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00082	74 07		 je	 SHORT $LN30@random_see

; 236  :         n = PyNumber_Absolute(arg);

  00084	e8 00 00 00 00	 call	 PyNumber_Absolute

; 237  :     else {

  00089	eb 17		 jmp	 SHORT $LN57@random_see
$LN30@random_see:

; 238  :         Py_hash_t hash = PyObject_Hash(arg);

  0008b	e8 00 00 00 00	 call	 PyObject_Hash

; 239  :         if (hash == -1)

  00090	48 83 f8 ff	 cmp	 rax, -1
  00094	0f 84 d6 01 00
	00		 je	 $LN3@random_see

; 240  :             goto Done;
; 241  :         n = PyLong_FromSize_t((size_t)hash);

  0009a	48 8b c8	 mov	 rcx, rax
  0009d	e8 00 00 00 00	 call	 PyLong_FromSize_t
$LN57@random_see:
  000a2	48 8b f8	 mov	 rdi, rax

; 242  :     }
; 243  :     if (n == NULL)

  000a5	48 85 c0	 test	 rax, rax
  000a8	0f 84 c2 01 00
	00		 je	 $LN3@random_see

; 244  :         goto Done;
; 245  : 
; 246  :     /* Now split n into 32-bit chunks, from the right.  Each piece is
; 247  :      * stored into key, which has a capacity of keymax chunks, of which
; 248  :      * keyused are filled.  Alas, the repeated shifting makes this a
; 249  :      * quadratic-time algorithm; we'd really like to use
; 250  :      * _PyLong_AsByteArray here, but then we'd have to break into the
; 251  :      * long representation to figure out how big an array was needed
; 252  :      * in advance.
; 253  :      */
; 254  :     keymax = 8;         /* arbitrary; grows later if needed */

  000ae	48 89 ac 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbp
  000b6	bd 08 00 00 00	 mov	 ebp, 8
  000bb	4c 89 6c 24 48	 mov	 QWORD PTR [rsp+72], r13

; 255  :     keyused = 0;
; 256  :     key = (unsigned long *)PyMem_Malloc(keymax * sizeof(*key));

  000c0	8d 4d 18	 lea	 ecx, QWORD PTR [rbp+24]
  000c3	45 8b ef	 mov	 r13d, r15d
  000c6	e8 00 00 00 00	 call	 PyMem_Malloc
  000cb	4c 8b e0	 mov	 r12, rax

; 257  :     if (key == NULL)

  000ce	48 85 c0	 test	 rax, rax
  000d1	0f 84 7f 01 00
	00		 je	 $LN7@random_see

; 258  :         goto Done;
; 259  : 
; 260  :     masklower = PyLong_FromUnsignedLong(0xffffffffU);

  000d7	83 c9 ff	 or	 ecx, -1			; ffffffffH
  000da	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
  000df	48 89 44 24 38	 mov	 QWORD PTR masklower$1$[rsp], rax

; 261  :     if (masklower == NULL)

  000e4	48 85 c0	 test	 rax, rax
  000e7	0f 84 69 01 00
	00		 je	 $LN7@random_see

; 262  :         goto Done;
; 263  :     thirtytwo = PyLong_FromLong(32L);

  000ed	8d 4d 18	 lea	 ecx, QWORD PTR [rbp+24]
  000f0	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  000f5	e8 00 00 00 00	 call	 PyLong_FromLong
  000fa	48 8b f0	 mov	 rsi, rax
  000fd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR thirtytwo$1$[rsp], rax

; 264  :     if (thirtytwo == NULL)

  00105	48 85 c0	 test	 rax, rax
  00108	0f 84 2c 01 00
	00		 je	 $Done$20281

; 265  :         goto Done;
; 266  :     while ((err=PyObject_IsTrue(n))) {

  0010e	48 8b cf	 mov	 rcx, rdi
  00111	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  00116	e8 00 00 00 00	 call	 PyObject_IsTrue
  0011b	85 c0		 test	 eax, eax
  0011d	0f 84 ea 00 00
	00		 je	 $LN50@random_see
  00123	4c 89 7c 24 30	 mov	 QWORD PTR tv321[rsp], r15
  00128	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL23@random_see:

; 267  :         PyObject *newn;
; 268  :         PyObject *pychunk;
; 269  :         unsigned long chunk;
; 270  : 
; 271  :         if (err == -1)

  00130	83 f8 ff	 cmp	 eax, -1
  00133	0f 84 fc 00 00
	00		 je	 $LN56@random_see

; 272  :             goto Done;
; 273  :         pychunk = PyNumber_And(n, masklower);

  00139	48 8b 54 24 38	 mov	 rdx, QWORD PTR masklower$1$[rsp]
  0013e	48 8b cf	 mov	 rcx, rdi
  00141	e8 00 00 00 00	 call	 PyNumber_And
  00146	48 8b d8	 mov	 rbx, rax

; 274  :         if (pychunk == NULL)

  00149	48 85 c0	 test	 rax, rax
  0014c	0f 84 e3 00 00
	00		 je	 $LN56@random_see

; 275  :             goto Done;
; 276  :         chunk = PyLong_AsUnsignedLong(pychunk);

  00152	48 8b c8	 mov	 rcx, rax
  00155	e8 00 00 00 00	 call	 PyLong_AsUnsignedLong

; 277  :         Py_DECREF(pychunk);

  0015a	48 8b cb	 mov	 rcx, rbx
  0015d	44 8b f0	 mov	 r14d, eax
  00160	e8 00 00 00 00	 call	 _Py_DecRef

; 278  :         if (chunk == (unsigned long)-1 && PyErr_Occurred())

  00165	41 83 fe ff	 cmp	 r14d, -1		; ffffffffH
  00169	75 0e		 jne	 SHORT $LN19@random_see
  0016b	e8 00 00 00 00	 call	 PyErr_Occurred
  00170	48 85 c0	 test	 rax, rax
  00173	0f 85 bc 00 00
	00		 jne	 $LN56@random_see
$LN19@random_see:

; 279  :             goto Done;
; 280  :         newn = PyNumber_Rshift(n, thirtytwo);

  00179	48 8b d6	 mov	 rdx, rsi
  0017c	48 8b cf	 mov	 rcx, rdi
  0017f	e8 00 00 00 00	 call	 PyNumber_Rshift
  00184	48 8b f0	 mov	 rsi, rax

; 281  :         if (newn == NULL)

  00187	48 85 c0	 test	 rax, rax
  0018a	0f 84 9d 00 00
	00		 je	 $LN53@random_see

; 282  :             goto Done;
; 283  :         Py_DECREF(n);

  00190	48 8b cf	 mov	 rcx, rdi
  00193	e8 00 00 00 00	 call	 _Py_DecRef

; 284  :         n = newn;

  00198	48 8b fe	 mov	 rdi, rsi

; 285  :         if (keyused >= keymax) {

  0019b	44 3b ed	 cmp	 r13d, ebp
  0019e	72 33		 jb	 SHORT $LN17@random_see

; 286  :             unsigned long bigger = keymax << 1;

  001a0	8d 5c 2d 00	 lea	 ebx, DWORD PTR [rbp+rbp]

; 287  :             if ((bigger >> 1) != keymax ||
; 288  :                 bigger > PY_SSIZE_T_MAX / sizeof(*key)) {

  001a4	8b c3		 mov	 eax, ebx
  001a6	d1 e8		 shr	 eax, 1
  001a8	3b c5		 cmp	 eax, ebp
  001aa	75 55		 jne	 SHORT $LN15@random_see
  001ac	8b d3		 mov	 edx, ebx
  001ae	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  001b8	48 3b d0	 cmp	 rdx, rax
  001bb	77 44		 ja	 SHORT $LN15@random_see

; 291  :             }
; 292  :             new_key = (unsigned long *)PyMem_Realloc(key,
; 293  :                                     bigger * sizeof(*key));

  001bd	48 c1 e2 02	 shl	 rdx, 2
  001c1	49 8b cc	 mov	 rcx, r12
  001c4	e8 00 00 00 00	 call	 PyMem_Realloc

; 294  :             if (new_key == NULL)

  001c9	48 85 c0	 test	 rax, rax
  001cc	74 5f		 je	 SHORT $LN53@random_see

; 295  :                 goto Done;
; 296  :             key = new_key;

  001ce	4c 8b e0	 mov	 r12, rax

; 297  :             keymax = bigger;

  001d1	8b eb		 mov	 ebp, ebx
$LN17@random_see:

; 298  :         }
; 299  :         assert(keyused < keymax);
; 300  :         key[keyused++] = chunk;

  001d3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR tv321[rsp]
  001d8	48 8b ce	 mov	 rcx, rsi
  001db	41 ff c5	 inc	 r13d
  001de	46 89 34 23	 mov	 DWORD PTR [rbx+r12], r14d
  001e2	48 83 c3 04	 add	 rbx, 4
  001e6	48 89 5c 24 30	 mov	 QWORD PTR tv321[rsp], rbx
  001eb	e8 00 00 00 00	 call	 PyObject_IsTrue
  001f0	85 c0		 test	 eax, eax
  001f2	74 14		 je	 SHORT $LN51@random_see

; 265  :         goto Done;
; 266  :     while ((err=PyObject_IsTrue(n))) {

  001f4	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR thirtytwo$1$[rsp]
  001fc	e9 2f ff ff ff	 jmp	 $LL23@random_see
$LN15@random_see:

; 289  :                 PyErr_NoMemory();

  00201	e8 00 00 00 00	 call	 PyErr_NoMemory

; 290  :                 goto Done;

  00206	eb 25		 jmp	 SHORT $LN53@random_see
$LN51@random_see:

; 301  :     }
; 302  : 
; 303  :     if (keyused == 0)

  00208	45 85 ed	 test	 r13d, r13d
  0020b	75 0a		 jne	 SHORT $LN13@random_see
$LN50@random_see:

; 304  :         key[keyused++] = 0UL;

  0020d	45 89 3c 24	 mov	 DWORD PTR [r12], r15d
  00211	41 bd 01 00 00
	00		 mov	 r13d, 1
$LN13@random_see:

; 305  :     result = init_by_array(self, key, keyused);

  00217	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0021f	45 8b c5	 mov	 r8d, r13d
  00222	49 8b d4	 mov	 rdx, r12
  00225	e8 00 00 00 00	 call	 init_by_array
  0022a	4c 8b f8	 mov	 r15, rax
$LN53@random_see:

; 262  :         goto Done;
; 263  :     thirtytwo = PyLong_FromLong(32L);

  0022d	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR thirtytwo$1$[rsp]
$LN56@random_see:
  00235	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]
$Done$20281:

; 306  : Done:
; 307  :     Py_XDECREF(masklower);

  0023a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR masklower$1$[rsp]
  0023f	e8 00 00 00 00	 call	 _Py_DecRef

; 308  :     Py_XDECREF(thirtytwo);

  00244	48 85 f6	 test	 rsi, rsi
  00247	74 08		 je	 SHORT $LN55@random_see
  00249	48 8b ce	 mov	 rcx, rsi
  0024c	e8 00 00 00 00	 call	 _Py_DecRef
$LN55@random_see:
  00251	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
$LN7@random_see:
  00256	4c 8b 6c 24 48	 mov	 r13, QWORD PTR [rsp+72]
  0025b	48 8b ac 24 88
	00 00 00	 mov	 rbp, QWORD PTR [rsp+136]

; 309  :     Py_XDECREF(n);

  00263	48 85 ff	 test	 rdi, rdi
  00266	74 08		 je	 SHORT $LN3@random_see
  00268	48 8b cf	 mov	 rcx, rdi
  0026b	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@random_see:

; 310  :     PyMem_Free(key);

  00270	49 8b cc	 mov	 rcx, r12
  00273	e8 00 00 00 00	 call	 PyMem_Free
  00278	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 311  :     return result;

  0027d	49 8b c7	 mov	 rax, r15

; 312  : }

  00280	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00284	41 5f		 pop	 r15
  00286	41 5c		 pop	 r12
  00288	5b		 pop	 rbx
  00289	c3		 ret	 0
$LN31@random_see:

; 224  :         time_t now;
; 225  : 
; 226  :         time(&now);

  0028a	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR now$20273[rsp]
  00292	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 227  :         init_genrand(self, (unsigned long)now);

  00298	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR now$20273[rsp]
  0029f	48 8b cb	 mov	 rcx, rbx
  002a2	e8 00 00 00 00	 call	 init_genrand

; 228  :         Py_INCREF(Py_None);

  002a7	e8 00 00 00 00	 call	 _Py_PXCTX
  002ac	85 c0		 test	 eax, eax
  002ae	75 38		 jne	 SHORT $LN39@random_see
  002b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  002be	4c 8b cf	 mov	 r9, rdi
  002c1	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  002c7	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  002cf	e8 00 00 00 00	 call	 _PyParallel_Guard
  002d4	85 c0		 test	 eax, eax
  002d6	75 09		 jne	 SHORT $LN38@random_see
  002d8	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  002df	74 07		 je	 SHORT $LN39@random_see
$LN38@random_see:
  002e1	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN39@random_see:

; 229  :         return Py_None;

  002e8	48 8b c7	 mov	 rax, rdi
  002eb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 312  : }

  002f0	48 83 c4 60	 add	 rsp, 96			; 00000060H
  002f4	41 5f		 pop	 r15
  002f6	41 5c		 pop	 r12
  002f8	5b		 pop	 rbx
  002f9	c3		 ret	 0
random_seed ENDP
_TEXT	ENDS
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$random_getstate DD imagerel random_getstate
	DD	imagerel random_getstate+269
	DD	imagerel $unwind$random_getstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$random_getstate DD 0b3b01H
	DD	06c43bH
	DD	0c7434H
	DD	0b642fH
	DD	0a542aH
	DD	0d0046208H
	DD	03002H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_randommodule.c
xdata	ENDS
;	COMDAT random_getstate
_TEXT	SEGMENT
self$ = 80
random_getstate PROC					; COMDAT

; 316  : {

  00000	40 53		 push	 rbx
  00002	41 55		 push	 r13
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00008	4c 8b e9	 mov	 r13, rcx

; 317  :     PyObject *state;
; 318  :     PyObject *element;
; 319  :     int i;
; 320  : 
; 321  :     state = PyTuple_New(N+1);

  0000b	b9 71 02 00 00	 mov	 ecx, 625		; 00000271H
  00010	e8 00 00 00 00	 call	 PyTuple_New
  00015	48 8b d8	 mov	 rbx, rax

; 322  :     if (state == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 08		 jne	 SHORT $LN6@random_get

; 339  : }

  0001d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00021	41 5d		 pop	 r13
  00023	5b		 pop	 rbx
  00024	c3		 ret	 0
$LN6@random_get:
  00025	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0002a	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  0002f	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi

; 323  :         return NULL;
; 324  :     for (i=0; i<N ; i++) {

  00034	33 ed		 xor	 ebp, ebp
  00036	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  0003b	48 8d 70 70	 lea	 rsi, QWORD PTR [rax+112]
  0003f	8b fd		 mov	 edi, ebp
  00041	4d 8d 65 60	 lea	 r12, QWORD PTR [r13+96]
$LL5@random_get:

; 325  :         element = PyLong_FromUnsignedLong(self->state[i]);

  00045	41 8b 0c 24	 mov	 ecx, DWORD PTR [r12]
  00049	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong

; 326  :         if (element == NULL)

  0004e	48 85 c0	 test	 rax, rax
  00051	74 37		 je	 SHORT $Fail$20348

; 327  :             goto Fail;
; 328  :         PyTuple_SET_ITEM(state, i, element);

  00053	48 ff c7	 inc	 rdi
  00056	48 89 06	 mov	 QWORD PTR [rsi], rax
  00059	ff c5		 inc	 ebp
  0005b	49 83 c4 04	 add	 r12, 4
  0005f	48 83 c6 08	 add	 rsi, 8
  00063	48 81 ff 70 02
	00 00		 cmp	 rdi, 624		; 00000270H
  0006a	7c d9		 jl	 SHORT $LL5@random_get

; 329  :     }
; 330  :     element = PyLong_FromLong((long)(self->index));

  0006c	41 8b 8d 20 0a
	00 00		 mov	 ecx, DWORD PTR [r13+2592]
  00073	e8 00 00 00 00	 call	 PyLong_FromLong

; 331  :     if (element == NULL)

  00078	48 85 c0	 test	 rax, rax
  0007b	74 0d		 je	 SHORT $Fail$20348

; 332  :         goto Fail;
; 333  :     PyTuple_SET_ITEM(state, i, element);

  0007d	48 63 cd	 movsxd	 rcx, ebp
  00080	48 89 44 cb 70	 mov	 QWORD PTR [rbx+rcx*8+112], rax

; 334  :     return state;

  00085	48 8b c3	 mov	 rax, rbx
  00088	eb 67		 jmp	 SHORT $LN26@random_get
$Fail$20348:

; 335  : 
; 336  : Fail:
; 337  :     Py_DECREF(state);

  0008a	e8 00 00 00 00	 call	 _Py_PXCTX
  0008f	85 c0		 test	 eax, eax
  00091	75 5c		 jne	 SHORT $LN19@random_get
  00093	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00097	a8 20		 test	 al, 32			; 00000020H
  00099	75 4c		 jne	 SHORT $LN13@random_get
  0009b	84 c0		 test	 al, al
  0009d	78 48		 js	 SHORT $LN13@random_get
  0009f	a8 02		 test	 al, 2
  000a1	75 4c		 jne	 SHORT $LN19@random_get
  000a3	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000a7	75 46		 jne	 SHORT $LN19@random_get
  000a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000b7	4c 8b cb	 mov	 r9, rbx
  000ba	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000c0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000c8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000cd	48 8b cb	 mov	 rcx, rbx
  000d0	85 c0		 test	 eax, eax
  000d2	74 07		 je	 SHORT $LN18@random_get
  000d4	e8 00 00 00 00	 call	 _Px_Dealloc
  000d9	eb 14		 jmp	 SHORT $LN19@random_get
$LN18@random_get:
  000db	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000df	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000e5	eb 08		 jmp	 SHORT $LN19@random_get
$LN13@random_get:
  000e7	48 8b cb	 mov	 rcx, rbx
  000ea	e8 00 00 00 00	 call	 Px_DecRef
$LN19@random_get:

; 338  :     return NULL;

  000ef	33 c0		 xor	 eax, eax
$LN26@random_get:
  000f1	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  000f6	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  000fb	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00100	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]

; 339  : }

  00105	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00109	41 5d		 pop	 r13
  0010b	5b		 pop	 rbx
  0010c	c3		 ret	 0
random_getstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@FGJCAIOP@state?5vector?5is?5the?5wrong?5size?$AA@ ; `string'
PUBLIC	??_C@_0BN@JMGFCIDC@state?5vector?5must?5be?5a?5tuple?$AA@ ; `string'
EXTRN	PyLong_AsLong:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyTuple_Size:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$random_setstate DD imagerel random_setstate
	DD	imagerel random_setstate+346
	DD	imagerel $unwind$random_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$random_setstate DD 0d8901H
	DD	06c489H
	DD	0d747eH
	DD	0c6479H
	DD	0b5474H
	DD	0a346fH
	DD	0e0046208H
	DD	0d002H
xdata	ENDS
;	COMDAT ??_C@_0BP@FGJCAIOP@state?5vector?5is?5the?5wrong?5size?$AA@
CONST	SEGMENT
??_C@_0BP@FGJCAIOP@state?5vector?5is?5the?5wrong?5size?$AA@ DB 'state vec'
	DB	'tor is the wrong size', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JMGFCIDC@state?5vector?5must?5be?5a?5tuple?$AA@
CONST	SEGMENT
??_C@_0BN@JMGFCIDC@state?5vector?5must?5be?5a?5tuple?$AA@ DB 'state vecto'
	DB	'r must be a tuple', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_randommodule.c
CONST	ENDS
;	COMDAT random_setstate
_TEXT	SEGMENT
self$ = 80
state$ = 88
random_setstate PROC					; COMDAT

; 343  : {

  00000	41 55		 push	 r13
  00002	41 56		 push	 r14
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 344  :     int i;
; 345  :     unsigned long element;
; 346  :     long index;
; 347  : 
; 348  :     if (!PyTuple_Check(state)) {

  00008	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0000c	4c 8b ea	 mov	 r13, rdx
  0000f	4c 8b f1	 mov	 r14, rcx
  00012	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  0001c	75 1e		 jne	 SHORT $LN7@random_set

; 349  :         PyErr_SetString(PyExc_TypeError,
; 350  :             "state vector must be a tuple");

  0001e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@JMGFCIDC@state?5vector?5must?5be?5a?5tuple?$AA@
  0002c	e8 00 00 00 00	 call	 PyErr_SetString

; 351  :         return NULL;

  00031	33 c0		 xor	 eax, eax

; 373  : }

  00033	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00037	41 5e		 pop	 r14
  00039	41 5d		 pop	 r13
  0003b	c3		 ret	 0
$LN7@random_set:

; 352  :     }
; 353  :     if (PyTuple_Size(state) != N+1) {

  0003c	48 8b ca	 mov	 rcx, rdx
  0003f	e8 00 00 00 00	 call	 PyTuple_Size
  00044	48 3d 71 02 00
	00		 cmp	 rax, 625		; 00000271H
  0004a	74 1e		 je	 SHORT $LN6@random_set

; 354  :         PyErr_SetString(PyExc_ValueError,
; 355  :             "state vector is the wrong size");

  0004c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@FGJCAIOP@state?5vector?5is?5the?5wrong?5size?$AA@
  0005a	e8 00 00 00 00	 call	 PyErr_SetString

; 356  :         return NULL;

  0005f	33 c0		 xor	 eax, eax

; 373  : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	41 5e		 pop	 r14
  00067	41 5d		 pop	 r13
  00069	c3		 ret	 0
$LN6@random_set:
  0006a	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0006f	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  00074	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00079	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi

; 357  :     }
; 358  : 
; 359  :     for (i=0; i<N ; i++) {

  0007e	33 ed		 xor	 ebp, ebp
  00080	49 8d 75 70	 lea	 rsi, QWORD PTR [r13+112]
  00084	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  00089	49 8d 7e 60	 lea	 rdi, QWORD PTR [r14+96]
  0008d	8b dd		 mov	 ebx, ebp
  0008f	90		 npad	 1
$LL5@random_set:

; 360  :         element = PyLong_AsUnsignedLong(PyTuple_GET_ITEM(state, i));

  00090	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00093	e8 00 00 00 00	 call	 PyLong_AsUnsignedLong
  00098	44 8b e0	 mov	 r12d, eax

; 361  :         if (element == (unsigned long)-1 && PyErr_Occurred())

  0009b	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  0009e	75 0a		 jne	 SHORT $LN2@random_set
  000a0	e8 00 00 00 00	 call	 PyErr_Occurred
  000a5	48 85 c0	 test	 rax, rax
  000a8	75 37		 jne	 SHORT $LN15@random_set
$LN2@random_set:

; 357  :     }
; 358  : 
; 359  :     for (i=0; i<N ; i++) {

  000aa	48 ff c3	 inc	 rbx

; 362  :             return NULL;
; 363  :         self->state[i] = element & 0xffffffffUL; /* Make sure we get sane state */

  000ad	44 89 27	 mov	 DWORD PTR [rdi], r12d
  000b0	ff c5		 inc	 ebp
  000b2	48 83 c6 08	 add	 rsi, 8
  000b6	48 83 c7 04	 add	 rdi, 4
  000ba	48 81 fb 70 02
	00 00		 cmp	 rbx, 624		; 00000270H
  000c1	7c cd		 jl	 SHORT $LL5@random_set

; 364  :     }
; 365  : 
; 366  :     index = PyLong_AsLong(PyTuple_GET_ITEM(state, i));

  000c3	48 63 cd	 movsxd	 rcx, ebp
  000c6	49 8b 4c cd 70	 mov	 rcx, QWORD PTR [r13+rcx*8+112]
  000cb	e8 00 00 00 00	 call	 PyLong_AsLong
  000d0	8b d8		 mov	 ebx, eax

; 367  :     if (index == -1 && PyErr_Occurred())

  000d2	83 f8 ff	 cmp	 eax, -1
  000d5	75 0e		 jne	 SHORT $LN1@random_set
  000d7	e8 00 00 00 00	 call	 PyErr_Occurred
  000dc	48 85 c0	 test	 rax, rax
  000df	74 04		 je	 SHORT $LN1@random_set
$LN15@random_set:

; 368  :         return NULL;

  000e1	33 c0		 xor	 eax, eax
  000e3	eb 53		 jmp	 SHORT $LN22@random_set
$LN1@random_set:

; 369  :     self->index = (int)index;

  000e5	41 89 9e 20 0a
	00 00		 mov	 DWORD PTR [r14+2592], ebx

; 370  : 
; 371  :     Py_INCREF(Py_None);

  000ec	e8 00 00 00 00	 call	 _Py_PXCTX
  000f1	85 c0		 test	 eax, eax
  000f3	75 3c		 jne	 SHORT $LN11@random_set
  000f5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0010a	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00110	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00118	e8 00 00 00 00	 call	 _PyParallel_Guard
  0011d	85 c0		 test	 eax, eax
  0011f	75 09		 jne	 SHORT $LN10@random_set
  00121	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00128	74 07		 je	 SHORT $LN11@random_set
$LN10@random_set:
  0012a	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN11@random_set:

; 372  :     return Py_None;

  00131	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN22@random_set:
  00138	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  0013d	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00142	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00147	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0014c	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]

; 373  : }

  00151	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00155	41 5e		 pop	 r14
  00157	41 5d		 pop	 r13
  00159	c3		 ret	 0
random_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@IHHDGINB@number?5of?5bits?5must?5be?5greater?5t@ ; `string'
PUBLIC	??_C@_0O@MLMMKANI@i?3getrandbits?$AA@		; `string'
EXTRN	_PyLong_FromByteArray:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$random_getrandbits DD imagerel random_getrandbits
	DD	imagerel random_getrandbits+73
	DD	imagerel $unwind$random_getrandbits
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$random_getrandbits DD imagerel random_getrandbits+73
	DD	imagerel random_getrandbits+141
	DD	imagerel $chain$1$random_getrandbits
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$random_getrandbits DD imagerel random_getrandbits+141
	DD	imagerel random_getrandbits+151
	DD	imagerel $chain$4$random_getrandbits
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$random_getrandbits DD imagerel random_getrandbits+151
	DD	imagerel random_getrandbits+254
	DD	imagerel $chain$5$random_getrandbits
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$random_getrandbits DD imagerel random_getrandbits+254
	DD	imagerel random_getrandbits+307
	DD	imagerel $chain$6$random_getrandbits
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$random_getrandbits DD 021H
	DD	imagerel random_getrandbits+141
	DD	imagerel random_getrandbits+151
	DD	imagerel $chain$4$random_getrandbits
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$random_getrandbits DD 020521H
	DD	057405H
	DD	imagerel random_getrandbits+141
	DD	imagerel random_getrandbits+151
	DD	imagerel $chain$4$random_getrandbits
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$random_getrandbits DD 060521H
	DD	083405H
	DD	04c400H
	DD	096400H
	DD	imagerel random_getrandbits
	DD	imagerel random_getrandbits+73
	DD	imagerel $unwind$random_getrandbits
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$random_getrandbits DD 040a21H
	DD	04c40aH
	DD	096405H
	DD	imagerel random_getrandbits
	DD	imagerel random_getrandbits+73
	DD	imagerel $unwind$random_getrandbits
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$random_getrandbits DD 020601H
	DD	050025206H
xdata	ENDS
;	COMDAT ??_C@_0CJ@IHHDGINB@number?5of?5bits?5must?5be?5greater?5t@
CONST	SEGMENT
??_C@_0CJ@IHHDGINB@number?5of?5bits?5must?5be?5greater?5t@ DB 'number of '
	DB	'bits must be greater than zero', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLMMKANI@i?3getrandbits?$AA@
CONST	SEGMENT
??_C@_0O@MLMMKANI@i?3getrandbits?$AA@ DB 'i:getrandbits', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT random_getrandbits
_TEXT	SEGMENT
self$ = 64
args$ = 72
k$ = 80
random_getrandbits PROC					; COMDAT

; 377  : {

  00000	40 55		 push	 rbp
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b e9	 mov	 rbp, rcx

; 378  :     int k, i, bytes;
; 379  :     unsigned long r;
; 380  :     unsigned char *bytearray;
; 381  :     PyObject *result;
; 382  : 
; 383  :     if (!PyArg_ParseTuple(args, "i:getrandbits", &k))

  0000c	4c 8d 44 24 50	 lea	 r8, QWORD PTR k$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@MLMMKANI@i?3getrandbits?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00020	85 c0		 test	 eax, eax

; 384  :         return NULL;

  00022	74 1b		 je	 SHORT $LN14@random_get@2

; 385  : 
; 386  :     if (k <= 0) {

  00024	8b 44 24 50	 mov	 eax, DWORD PTR k$[rsp]
  00028	85 c0		 test	 eax, eax
  0002a	7f 1b		 jg	 SHORT $LN6@random_get@2

; 387  :         PyErr_SetString(PyExc_ValueError,
; 388  :                         "number of bits must be greater than zero");

  0002c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@IHHDGINB@number?5of?5bits?5must?5be?5greater?5t@
  0003a	e8 00 00 00 00	 call	 PyErr_SetString
$LN14@random_get@2:

; 389  :         return NULL;

  0003f	33 c0		 xor	 eax, eax

; 414  : }

  00041	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00045	5d		 pop	 rbp
  00046	c3		 ret	 0
$LN6@random_get@2:

; 390  :     }
; 391  : 
; 392  :     bytes = ((k - 1) / 32 + 1) * 4;

  00047	ff c8		 dec	 eax
  00049	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  0004e	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  00053	99		 cdq
  00054	83 e2 1f	 and	 edx, 31
  00057	03 c2		 add	 eax, edx
  00059	c1 f8 05	 sar	 eax, 5
  0005c	8d 04 85 04 00
	00 00		 lea	 eax, DWORD PTR [rax*4+4]

; 393  :     bytearray = (unsigned char *)PyMem_Malloc(bytes);

  00063	48 63 f0	 movsxd	 rsi, eax
  00066	48 8b ce	 mov	 rcx, rsi
  00069	e8 00 00 00 00	 call	 PyMem_Malloc
  0006e	4c 8b e0	 mov	 r12, rax

; 394  :     if (bytearray == NULL) {

  00071	48 85 c0	 test	 rax, rax
  00074	75 17		 jne	 SHORT $LN5@random_get@2

; 395  :         PyErr_NoMemory();

  00076	e8 00 00 00 00	 call	 PyErr_NoMemory
  0007b	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00080	4c 8b 64 24 20	 mov	 r12, QWORD PTR [rsp+32]

; 396  :         return NULL;

  00085	33 c0		 xor	 eax, eax

; 414  : }

  00087	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008b	5d		 pop	 rbp
  0008c	c3		 ret	 0
$LN5@random_get@2:
  0008d	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 397  :     }
; 398  : 
; 399  :     /* Fill-out whole words, byte-by-byte to avoid endianness issues */
; 400  :     for (i=0 ; i<bytes ; i+=4, k-=32) {

  00092	48 85 f6	 test	 rsi, rsi
  00095	7e 67		 jle	 SHORT $LN2@random_get@2
  00097	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  0009c	48 8d 7e ff	 lea	 rdi, QWORD PTR [rsi-1]
  000a0	48 8d 58 01	 lea	 rbx, QWORD PTR [rax+1]
  000a4	48 c1 ef 02	 shr	 rdi, 2
  000a8	48 ff c7	 inc	 rdi
  000ab	0f 1f 44 00 00	 npad	 5
$LL4@random_get@2:

; 401  :         r = genrand_int32(self);

  000b0	48 8b cd	 mov	 rcx, rbp
  000b3	e8 00 00 00 00	 call	 genrand_int32
  000b8	44 8b d8	 mov	 r11d, eax

; 402  :         if (k < 32)

  000bb	8b 44 24 50	 mov	 eax, DWORD PTR k$[rsp]
  000bf	83 f8 20	 cmp	 eax, 32			; 00000020H
  000c2	7d 0a		 jge	 SHORT $LN1@random_get@2

; 403  :             r >>= (32 - k);

  000c4	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000c9	2b c8		 sub	 ecx, eax
  000cb	41 d3 eb	 shr	 r11d, cl
$LN1@random_get@2:

; 404  :         bytearray[i+0] = (unsigned char)r;

  000ce	44 88 5b ff	 mov	 BYTE PTR [rbx-1], r11b

; 405  :         bytearray[i+1] = (unsigned char)(r >> 8);

  000d2	41 8b cb	 mov	 ecx, r11d

; 406  :         bytearray[i+2] = (unsigned char)(r >> 16);

  000d5	41 8b c3	 mov	 eax, r11d

; 407  :         bytearray[i+3] = (unsigned char)(r >> 24);

  000d8	41 c1 eb 18	 shr	 r11d, 24
  000dc	c1 e9 08	 shr	 ecx, 8
  000df	c1 e8 10	 shr	 eax, 16
  000e2	88 0b		 mov	 BYTE PTR [rbx], cl
  000e4	88 43 01	 mov	 BYTE PTR [rbx+1], al
  000e7	44 88 5b 02	 mov	 BYTE PTR [rbx+2], r11b
  000eb	83 6c 24 50 20	 sub	 DWORD PTR k$[rsp], 32	; 00000020H
  000f0	48 83 c3 04	 add	 rbx, 4
  000f4	48 ff cf	 dec	 rdi
  000f7	75 b7		 jne	 SHORT $LL4@random_get@2
  000f9	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]
$LN2@random_get@2:

; 408  :     }
; 409  : 
; 410  :     /* little endian order to match bytearray assignment order */
; 411  :     result = _PyLong_FromByteArray(bytearray, bytes, 1, 0);

  000fe	45 33 c9	 xor	 r9d, r9d
  00101	48 8b d6	 mov	 rdx, rsi
  00104	49 8b cc	 mov	 rcx, r12
  00107	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  0010b	e8 00 00 00 00	 call	 _PyLong_FromByteArray

; 412  :     PyMem_Free(bytearray);

  00110	49 8b cc	 mov	 rcx, r12
  00113	48 8b d8	 mov	 rbx, rax
  00116	e8 00 00 00 00	 call	 PyMem_Free
  0011b	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00120	4c 8b 64 24 20	 mov	 r12, QWORD PTR [rsp+32]

; 413  :     return result;

  00125	48 8b c3	 mov	 rax, rbx
  00128	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 414  : }

  0012d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00131	5d		 pop	 rbp
  00132	c3		 ret	 0
random_getrandbits ENDP
_TEXT	ENDS
PUBLIC	??_C@_08LBMJBPIB@Random?$CI?$CJ?$AA@		; `string'
EXTRN	_PyArg_NoKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$random_new DD imagerel random_new
	DD	imagerel random_new+125
	DD	imagerel $unwind$random_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$random_new DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_08LBMJBPIB@Random?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_08LBMJBPIB@Random?$CI?$CJ?$AA@ DB 'Random()', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT random_new
_TEXT	SEGMENT
type$ = 48
args$ = 56
kwds$ = 64
random_new PROC						; COMDAT

; 418  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 419  :     RandomObject *self;
; 420  :     PyObject *tmp;
; 421  : 
; 422  :     if (type == &Random_Type && !_PyArg_NoKeywords("Random()", kwds))

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Random_Type
  00011	48 8b fa	 mov	 rdi, rdx
  00014	48 8b d9	 mov	 rbx, rcx
  00017	48 3b c8	 cmp	 rcx, rax
  0001a	75 13		 jne	 SHORT $LN3@random_new
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08LBMJBPIB@Random?$CI?$CJ?$AA@
  00023	49 8b d0	 mov	 rdx, r8
  00026	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  0002b	85 c0		 test	 eax, eax

; 423  :         return NULL;

  0002d	74 2b		 je	 SHORT $LN6@random_new
$LN3@random_new:

; 424  : 
; 425  :     self = (RandomObject *)type->tp_alloc(type, 0);

  0002f	33 d2		 xor	 edx, edx
  00031	48 8b cb	 mov	 rcx, rbx
  00034	ff 93 88 01 00
	00		 call	 QWORD PTR [rbx+392]
  0003a	48 8b d8	 mov	 rbx, rax

; 426  :     if (self == NULL)

  0003d	48 85 c0	 test	 rax, rax

; 427  :         return NULL;

  00040	74 18		 je	 SHORT $LN6@random_new

; 428  :     tmp = random_seed(self, args);

  00042	48 8b d7	 mov	 rdx, rdi
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 random_seed

; 429  :     if (tmp == NULL) {

  0004d	48 85 c0	 test	 rax, rax
  00050	75 15		 jne	 SHORT $LN1@random_new

; 430  :         Py_DECREF(self);

  00052	48 8b cb	 mov	 rcx, rbx
  00055	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@random_new:

; 431  :         return NULL;

  0005a	33 c0		 xor	 eax, eax

; 435  : }

  0005c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5f		 pop	 rdi
  00066	c3		 ret	 0
$LN1@random_new:

; 432  :     }
; 433  :     Py_DECREF(tmp);

  00067	48 8b c8	 mov	 rcx, rax
  0006a	e8 00 00 00 00	 call	 _Py_DecRef

; 434  :     return (PyObject *)self;

  0006f	48 8b c3	 mov	 rax, rbx

; 435  : }

  00072	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
random_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_06BEOPDEGP@Random?$AA@			; `string'
PUBLIC	PyInit__random
EXTRN	PyModule_AddObject:PROC
EXTRN	PyModule_Create2:PROC
EXTRN	PyType_Ready:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyInit__random DD imagerel $LN10
	DD	imagerel $LN10+39
	DD	imagerel $unwind$PyInit__random
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyInit__random DD imagerel $LN10+39
	DD	imagerel $LN10+67
	DD	imagerel $chain$0$PyInit__random
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyInit__random DD imagerel $LN10+67
	DD	imagerel $LN10+171
	DD	imagerel $chain$2$PyInit__random
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyInit__random DD 020021H
	DD	063400H
	DD	imagerel $LN10
	DD	imagerel $LN10+39
	DD	imagerel $unwind$PyInit__random
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyInit__random DD 020521H
	DD	063405H
	DD	imagerel $LN10
	DD	imagerel $LN10+39
	DD	imagerel $unwind$PyInit__random
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__random DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_06BEOPDEGP@Random?$AA@
CONST	SEGMENT
??_C@_06BEOPDEGP@Random?$AA@ DB 'Random', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_randommodule.c
CONST	ENDS
;	COMDAT PyInit__random
_TEXT	SEGMENT
PyInit__random PROC					; COMDAT

; 517  : {

$LN10:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 518  :     PyObject *m;
; 519  : 
; 520  :     if (PyType_Ready(&Random_Type) < 0)

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Random_Type
  0000b	e8 00 00 00 00	 call	 PyType_Ready
  00010	85 c0		 test	 eax, eax
  00012	79 07		 jns	 SHORT $LN2@PyInit__ra

; 521  :         return NULL;

  00014	33 c0		 xor	 eax, eax

; 528  : }

  00016	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001a	c3		 ret	 0
$LN2@PyInit__ra:

; 522  :     m = PyModule_Create(&_randommodule);

  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_randommodule
  00022	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00027	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0002c	e8 00 00 00 00	 call	 PyModule_Create2
  00031	48 8b d8	 mov	 rbx, rax

; 523  :     if (m == NULL)

  00034	48 85 c0	 test	 rax, rax
  00037	75 0a		 jne	 SHORT $LN1@PyInit__ra
  00039	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 528  : }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
$LN1@PyInit__ra:

; 524  :         return NULL;
; 525  :     Py_INCREF(&Random_Type);

  00043	e8 00 00 00 00	 call	 _Py_PXCTX
  00048	85 c0		 test	 eax, eax
  0004a	75 3c		 jne	 SHORT $LN6@PyInit__ra
  0004c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:Random_Type
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00061	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00067	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0006f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00074	85 c0		 test	 eax, eax
  00076	75 09		 jne	 SHORT $LN5@PyInit__ra
  00078	f6 05 20 00 00
	00 20		 test	 BYTE PTR Random_Type+32, 32 ; 00000020H
  0007f	74 07		 je	 SHORT $LN6@PyInit__ra
$LN5@PyInit__ra:
  00081	48 ff 05 50 00
	00 00		 inc	 QWORD PTR Random_Type+80
$LN6@PyInit__ra:

; 526  :     PyModule_AddObject(m, "Random", (PyObject *)&Random_Type);

  00088	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:Random_Type
  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06BEOPDEGP@Random?$AA@
  00096	48 8b cb	 mov	 rcx, rbx
  00099	e8 00 00 00 00	 call	 PyModule_AddObject

; 527  :     return m;

  0009e	48 8b c3	 mov	 rax, rbx
  000a1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 528  : }

  000a6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000aa	c3		 ret	 0
PyInit__random ENDP
_TEXT	ENDS
END
