; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_07CMPFPFAH@complex?$AA@			; `string'
PUBLIC	??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@ ; `string'
PUBLIC	??_C@_04HBKGOHH@imag?$AA@			; `string'
PUBLIC	??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@ ; `string'
PUBLIC	??_C@_04DGGKDJMA@real?$AA@			; `string'
PUBLIC	??_C@_0L@MEMCGMKL@__format__?$AA@		; `string'
PUBLIC	??_C@_0P@BCBHENLA@__getnewargs__?$AA@		; `string'
PUBLIC	??_C@_09PHMNDPIK@conjugate?$AA@			; `string'
PUBLIC	??_C@_0M@OFKDNGDB@__complex__?$AA@		; `string'
PUBLIC	PyComplex_Type
EXTRN	PyObject_Free:PROC
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	PyType_Type:BYTE
;	COMDAT ??_C@_07CMPFPFAH@complex?$AA@
CONST	SEGMENT
??_C@_07CMPFPFAH@complex?$AA@ DB 'complex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@
CONST	SEGMENT
??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@ DB 'the imagin'
	DB	'ary part of a complex number', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HBKGOHH@imag?$AA@
CONST	SEGMENT
??_C@_04HBKGOHH@imag?$AA@ DB 'imag', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@
CONST	SEGMENT
??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@ DB 'the real pa'
	DB	'rt of a complex number', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DGGKDJMA@real?$AA@
CONST	SEGMENT
??_C@_04DGGKDJMA@real?$AA@ DB 'real', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MEMCGMKL@__format__?$AA@
CONST	SEGMENT
??_C@_0L@MEMCGMKL@__format__?$AA@ DB '__format__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BCBHENLA@__getnewargs__?$AA@
CONST	SEGMENT
??_C@_0P@BCBHENLA@__getnewargs__?$AA@ DB '__getnewargs__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PHMNDPIK@conjugate?$AA@
CONST	SEGMENT
??_C@_09PHMNDPIK@conjugate?$AA@ DB 'conjugate', 00H	; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId___complex__@?1??try_complex_special_method@@9@9 DQ 0000000000000000H ; `try_complex_special_method'::`2'::PyId___complex__
	DQ	FLAT:??_C@_0M@OFKDNGDB@__complex__?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_0M@OFKDNGDB@__complex__?$AA@
CONST	SEGMENT
??_C@_0M@OFKDNGDB@__complex__?$AA@ DB '__complex__', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
c_1	DQ	03ff0000000000000r		; 1
	DQ	00000000000000000r		; 0
complex_conjugate_doc DB 'complex.conjugate() -> complex', 0aH, 0aH, 'Ret'
	DB	'urn the complex conjugate of its argument. (3-4j).conjugate()'
	DB	' == 3+4j.', 00H
	ORG $+6
complex__format__doc DB 'complex.__format__() -> str', 0aH, 0aH, 'Convert'
	DB	' to a string according to format_spec.', 00H
	ORG $+5
complex_methods DQ FLAT:??_C@_09PHMNDPIK@conjugate?$AA@
	DQ	FLAT:complex_conjugate
	DD	04H
	ORG $+4
	DQ	FLAT:complex_conjugate_doc
	DQ	FLAT:??_C@_0P@BCBHENLA@__getnewargs__?$AA@
	DQ	FLAT:complex_getnewargs
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0L@MEMCGMKL@__format__?$AA@
	DQ	FLAT:complex__format__
	DD	01H
	ORG $+4
	DQ	FLAT:complex__format__doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
complex_members DQ FLAT:??_C@_04DGGKDJMA@real?$AA@
	DD	04H
	ORG $+4
	DQ	0000000000000060H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@
	DQ	FLAT:??_C@_04HBKGOHH@imag?$AA@
	DD	04H
	ORG $+4
	DQ	0000000000000068H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@
	DQ	0000000000000000H
	ORG $+32
?kwlist@?1??complex_new@@9@9 DQ FLAT:??_C@_04DGGKDJMA@real?$AA@ ; `complex_new'::`2'::kwlist
	DQ	FLAT:??_C@_04HBKGOHH@imag?$AA@
	DQ	0000000000000000H
complex_doc DB	'complex(real[, imag]) -> complex number', 0aH, 0aH, 'Cre'
	DB	'ate a complex number from a real part and an optional imagina'
	DB	'ry part.', 0aH, 'This is equivalent to (real + imag*1j) where'
	DB	' imag defaults to 0.', 00H
	ORG $+13
complex_as_number DQ FLAT:complex_add
	DQ	FLAT:complex_sub
	DQ	FLAT:complex_mul
	DQ	FLAT:complex_remainder
	DQ	FLAT:complex_divmod
	DQ	FLAT:complex_pow
	DQ	FLAT:complex_neg
	DQ	FLAT:complex_pos
	DQ	FLAT:complex_abs
	DQ	FLAT:complex_bool
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:complex_int
	DQ	0000000000000000H
	DQ	FLAT:complex_float
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:complex_int_div
	DQ	FLAT:complex_div
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
PyComplex_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_07CMPFPFAH@complex?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:complex_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:complex_repr
	DQ	FLAT:complex_as_number
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:complex_hash
	DQ	0000000000000000H
	DQ	FLAT:complex_repr
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:complex_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:complex_richcompare
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:complex_methods
	DQ	FLAT:complex_members
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:complex_new
	DQ	FLAT:PyObject_Free
	ORG $+64
_DATA	ENDS
EXTRN	__imp__hypot:PROC
EXTRN	_fltused:DWORD
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT hypot
_TEXT	SEGMENT
_X$ = 8
_Y$ = 16
hypot	PROC						; COMDAT

; 163  :     return _hypot(_X, _Y);
; 164  : }

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__hypot
hypot	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\include\objimpl.h
_TEXT	ENDS
;	COMDAT _PyObject_InitHead
_TEXT	SEGMENT
op$ = 8
_PyObject_InitHead PROC					; COMDAT

; 216  :     assert(Py_TYPE(op));
; 217  :     op->is_px = _Py_NOT_PARALLEL;

  00000	48 ba 78 56 ef
	be 34 12 ad de	 mov	 rdx, -2401243008567650696 ; dead1234beef5678H

; 218  :     op->px    = _Py_NOT_PARALLEL;
; 219  :     op->slist_entry.Next = NULL;

  0000a	33 c0		 xor	 eax, eax

; 220  :     op->px_flags  = Py_PXFLAGS_ISPY;

  0000c	48 c7 41 20 01
	00 00 00	 mov	 QWORD PTR [rcx+32], 1
  00014	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00017	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  0001b	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 221  :     op->srw_lock  = NULL;

  0001f	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 222  :     op->event     = NULL;

  00023	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 223  :     op->orig_type = NULL;

  00027	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 224  : #ifdef Py_TRACE_REFS
; 225  :     op->_ob_next = NULL;
; 226  :     op->_ob_prev = NULL;
; 227  : #else
; 228  :     op->_ob_next = _Py_NOT_PARALLEL;

  0002b	48 89 51 40	 mov	 QWORD PTR [rcx+64], rdx

; 229  :     op->_ob_prev = _Py_NOT_PARALLEL;

  0002f	48 89 51 48	 mov	 QWORD PTR [rcx+72], rdx

; 230  : #endif
; 231  : }

  00033	c3		 ret	 0
_PyObject_InitHead ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@JKHPLOII@PyObject_INIT?$AA@		; `string'
PUBLIC	??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@ ; `string'
EXTRN	_Px_NewReference:PROC
EXTRN	_PxObject_Init:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_INIT DD imagerel PyObject_INIT
	DD	imagerel PyObject_INIT+185
	DD	imagerel $unwind$PyObject_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_INIT DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0O@JKHPLOII@PyObject_INIT?$AA@
CONST	SEGMENT
??_C@_0O@JKHPLOII@PyObject_INIT?$AA@ DB 'PyObject_INIT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@
CONST	SEGMENT
??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@ DB 'c:\src\pypa'
	DB	'rallel\include\objimpl.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_INIT
_TEXT	SEGMENT
op$ = 64
tp$ = 72
PyObject_INIT PROC					; COMDAT

; 236  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 237  :     Px_RETURN(_PxObject_Init(op, tp))

  00010	e8 00 00 00 00	 call	 _Py_PXCTX
  00015	85 c0		 test	 eax, eax
  00017	74 15		 je	 SHORT $LN1@PyObject_I
  00019	48 8b d7	 mov	 rdx, rdi
  0001c	48 8b cb	 mov	 rcx, rbx

; 242  : }

  0001f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00024	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00028	5f		 pop	 rdi
  00029	e9 00 00 00 00	 jmp	 _PxObject_Init
$LN1@PyObject_I:

; 238  :     Py_TYPE(op) = tp;
; 239  :     _PyObject_InitHead(op);

  0002e	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00038	33 c0		 xor	 eax, eax

; 240  :     _Py_NewReference(op);

  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@
  00041	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  00044	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx
  00048	48 89 4b 40	 mov	 QWORD PTR [rbx+64], rcx
  0004c	48 89 4b 48	 mov	 QWORD PTR [rbx+72], rcx
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@JKHPLOII@PyObject_INIT?$AA@
  00057	4c 8b cb	 mov	 r9, rbx
  0005a	41 b8 f0 00 00
	00		 mov	 r8d, 240		; 000000f0H
  00060	48 89 7b 58	 mov	 QWORD PTR [rbx+88], rdi
  00064	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
  00068	48 c7 43 20 01
	00 00 00	 mov	 QWORD PTR [rbx+32], 1
  00070	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  00074	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax
  00078	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
  0007c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00084	e8 00 00 00 00	 call	 _PyParallel_Guard
  00089	85 c0		 test	 eax, eax
  0008b	74 16		 je	 SHORT $LN4@PyObject_I
  0008d	48 8b cb	 mov	 rcx, rbx
  00090	e8 00 00 00 00	 call	 _Px_NewReference

; 241  :     return op;

  00095	48 8b c3	 mov	 rax, rbx

; 242  : }

  00098	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a1	5f		 pop	 rdi
  000a2	c3		 ret	 0
$LN4@PyObject_I:

; 240  :     _Py_NewReference(op);

  000a3	48 c7 43 50 01
	00 00 00	 mov	 QWORD PTR [rbx+80], 1

; 241  :     return op;

  000ab	48 8b c3	 mov	 rax, rbx

; 242  : }

  000ae	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
PyObject_INIT ENDP
_TEXT	ENDS
PUBLIC	_Py_c_sum
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\complexobject.c
;	COMDAT _Py_c_sum
_TEXT	SEGMENT
$T21255 = 8
a$ = 16
b$ = 24
_Py_c_sum PROC						; COMDAT

; 18   :     Py_complex r;
; 19   :     r.real = a.real + b.real;

  00000	f2 0f 10 02	 movsdx	 xmm0, QWORD PTR [rdx]

; 20   :     r.imag = a.imag + b.imag;

  00004	f2 0f 10 4a 08	 movsdx	 xmm1, QWORD PTR [rdx+8]

; 21   :     return r;

  00009	48 8b c1	 mov	 rax, rcx
  0000c	f2 41 0f 58 00	 addsd	 xmm0, QWORD PTR [r8]
  00011	f2 41 0f 58 48
	08		 addsd	 xmm1, QWORD PTR [r8+8]
  00017	f2 0f 11 01	 movsdx	 QWORD PTR [rcx], xmm0
  0001b	f2 0f 11 49 08	 movsdx	 QWORD PTR [rcx+8], xmm1

; 22   : }

  00020	c3		 ret	 0
_Py_c_sum ENDP
_TEXT	ENDS
PUBLIC	_Py_c_diff
; Function compile flags: /Ogtpy
;	COMDAT _Py_c_diff
_TEXT	SEGMENT
$T21262 = 8
a$ = 16
b$ = 24
_Py_c_diff PROC						; COMDAT

; 27   :     Py_complex r;
; 28   :     r.real = a.real - b.real;

  00000	f2 0f 10 02	 movsdx	 xmm0, QWORD PTR [rdx]

; 29   :     r.imag = a.imag - b.imag;

  00004	f2 0f 10 4a 08	 movsdx	 xmm1, QWORD PTR [rdx+8]

; 30   :     return r;

  00009	48 8b c1	 mov	 rax, rcx
  0000c	f2 41 0f 5c 00	 subsd	 xmm0, QWORD PTR [r8]
  00011	f2 41 0f 5c 48
	08		 subsd	 xmm1, QWORD PTR [r8+8]
  00017	f2 0f 11 01	 movsdx	 QWORD PTR [rcx], xmm0
  0001b	f2 0f 11 49 08	 movsdx	 QWORD PTR [rcx+8], xmm1

; 31   : }

  00020	c3		 ret	 0
_Py_c_diff ENDP
_TEXT	ENDS
PUBLIC	__mask@@NegDouble@
PUBLIC	_Py_c_neg
;	COMDAT __mask@@NegDouble@
CONST	SEGMENT
__mask@@NegDouble@ DB 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 080H
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_c_neg
_TEXT	SEGMENT
$T21269 = 8
a$ = 16
_Py_c_neg PROC						; COMDAT

; 36   :     Py_complex r;
; 37   :     r.real = -a.real;

  00000	f2 0f 10 02	 movsdx	 xmm0, QWORD PTR [rdx]

; 38   :     r.imag = -a.imag;
; 39   :     return r;

  00004	48 8b c1	 mov	 rax, rcx
  00007	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  0000f	f2 0f 11 01	 movsdx	 QWORD PTR [rcx], xmm0
  00013	f2 0f 10 42 08	 movsdx	 xmm0, QWORD PTR [rdx+8]
  00018	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00020	f2 0f 11 41 08	 movsdx	 QWORD PTR [rcx+8], xmm0

; 40   : }

  00025	c3		 ret	 0
_Py_c_neg ENDP
_TEXT	ENDS
PUBLIC	_Py_c_prod
; Function compile flags: /Ogtpy
;	COMDAT _Py_c_prod
_TEXT	SEGMENT
$T21280 = 8
a$ = 16
b$ = 24
_Py_c_prod PROC						; COMDAT

; 45   :     Py_complex r;
; 46   :     r.real = a.real*b.real - a.imag*b.imag;

  00000	f2 41 0f 10 58
	08		 movsdx	 xmm3, QWORD PTR [r8+8]
  00006	f2 0f 10 6a 08	 movsdx	 xmm5, QWORD PTR [rdx+8]
  0000b	f2 41 0f 10 08	 movsdx	 xmm1, QWORD PTR [r8]

; 47   :     r.imag = a.real*b.imag + a.imag*b.real;
; 48   :     return r;

  00010	48 8b c1	 mov	 rax, rcx
  00013	f2 0f 59 0a	 mulsd	 xmm1, QWORD PTR [rdx]
  00017	66 0f 28 c3	 movapd	 xmm0, xmm3
  0001b	f2 0f 59 1a	 mulsd	 xmm3, QWORD PTR [rdx]
  0001f	f2 0f 59 c5	 mulsd	 xmm0, xmm5
  00023	f2 41 0f 59 28	 mulsd	 xmm5, QWORD PTR [r8]
  00028	f2 0f 5c c8	 subsd	 xmm1, xmm0
  0002c	f2 0f 58 eb	 addsd	 xmm5, xmm3
  00030	f2 0f 11 09	 movsdx	 QWORD PTR [rcx], xmm1
  00034	f2 0f 11 69 08	 movsdx	 QWORD PTR [rcx+8], xmm5

; 49   : }

  00039	c3		 ret	 0
_Py_c_prod ENDP
_TEXT	ENDS
PUBLIC	_Py_c_quot
EXTRN	__imp__errno:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_c_quot DD imagerel $LN13
	DD	imagerel $LN13+248
	DD	imagerel $unwind$_Py_c_quot
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_c_quot DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _Py_c_quot
_TEXT	SEGMENT
$T21287 = 48
a$ = 56
b$ = 64
_Py_c_quot PROC						; COMDAT

; 53   : {

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 54   :     /******************************************************************
; 55   :     This was the original algorithm.  It's grossly prone to spurious
; 56   :     overflow and underflow errors.  It also merrily divides by 0 despite
; 57   :     checking for that(!).  The code still serves a doc purpose here, as
; 58   :     the algorithm following is a simple by-cases transformation of this
; 59   :     one:
; 60   : 
; 61   :     Py_complex r;
; 62   :     double d = b.real*b.real + b.imag*b.imag;
; 63   :     if (d == 0.)
; 64   :         errno = EDOM;
; 65   :     r.real = (a.real*b.real + a.imag*b.imag)/d;
; 66   :     r.imag = (a.imag*b.real - a.real*b.imag)/d;
; 67   :     return r;
; 68   :     ******************************************************************/
; 69   : 
; 70   :     /* This algorithm is better, and is pretty obvious:  first divide the
; 71   :      * numerators and denominator by whichever of {b.real, b.imag} has
; 72   :      * larger magnitude.  The earliest reference I found was to CACM
; 73   :      * Algorithm 116 (Complex Division, Robert L. Smith, Stanford
; 74   :      * University).  As usual, though, we're still ignoring all IEEE
; 75   :      * endcases.
; 76   :      */
; 77   :      Py_complex r;      /* the result */
; 78   :      const double abs_breal = b.real < 0 ? -b.real : b.real;

  00006	f2 41 0f 10 28	 movsdx	 xmm5, QWORD PTR [r8]
  0000b	66 0f 57 d2	 xorpd	 xmm2, xmm2
  0000f	f2 0f 10 1d 00
	00 00 00	 movsdx	 xmm3, QWORD PTR __mask@@NegDouble@
  00017	48 8b d9	 mov	 rbx, rcx
  0001a	66 0f 2f d5	 comisd	 xmm2, xmm5
  0001e	66 0f 28 cd	 movapd	 xmm1, xmm5
  00022	76 04		 jbe	 SHORT $LN8@Py_c_quot
  00024	66 0f 57 cb	 xorpd	 xmm1, xmm3
$LN8@Py_c_quot:

; 79   :      const double abs_bimag = b.imag < 0 ? -b.imag : b.imag;

  00028	f2 41 0f 10 40
	08		 movsdx	 xmm0, QWORD PTR [r8+8]
  0002e	66 0f 2f d0	 comisd	 xmm2, xmm0
  00032	76 04		 jbe	 SHORT $LN9@Py_c_quot
  00034	66 0f 57 c3	 xorpd	 xmm0, xmm3
$LN9@Py_c_quot:

; 80   : 
; 81   :      if (abs_breal >= abs_bimag) {

  00038	66 0f 2f c8	 comisd	 xmm1, xmm0
  0003c	72 73		 jb	 SHORT $LN4@Py_c_quot

; 82   :         /* divide tops and bottom by b.real */
; 83   :         if (abs_breal == 0.0) {

  0003e	66 0f 2e ca	 ucomisd xmm1, xmm2
  00042	7a 20		 jp	 SHORT $LN3@Py_c_quot
  00044	75 1e		 jne	 SHORT $LN3@Py_c_quot

; 84   :             errno = EDOM;

  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0004c	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 85   :             r.real = r.imag = 0.0;

  00052	33 c0		 xor	 eax, eax
  00054	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
  00058	48 89 03	 mov	 QWORD PTR [rbx], rax

; 100  :         r.imag = (a.imag * ratio - a.real) / denom;
; 101  :     }
; 102  :     return r;

  0005b	48 8b c3	 mov	 rax, rbx

; 103  : }

  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5b		 pop	 rbx
  00063	c3		 ret	 0
$LN3@Py_c_quot:

; 86   :         }
; 87   :         else {
; 88   :             const double ratio = b.imag / b.real;

  00064	f2 41 0f 10 60
	08		 movsdx	 xmm4, QWORD PTR [r8+8]

; 89   :             const double denom = b.real + b.imag * ratio;
; 90   :             r.real = (a.real + a.imag * ratio) / denom;

  0006a	f2 0f 10 52 08	 movsdx	 xmm2, QWORD PTR [rdx+8]
  0006f	f2 0f 10 0a	 movsdx	 xmm1, QWORD PTR [rdx]

; 100  :         r.imag = (a.imag * ratio - a.real) / denom;
; 101  :     }
; 102  :     return r;

  00073	48 8b c3	 mov	 rax, rbx
  00076	66 0f 28 dc	 movapd	 xmm3, xmm4
  0007a	66 0f 28 c2	 movapd	 xmm0, xmm2
  0007e	f2 0f 5e dd	 divsd	 xmm3, xmm5
  00082	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  00086	f2 0f 59 e3	 mulsd	 xmm4, xmm3
  0008a	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0008e	f2 0f 58 e5	 addsd	 xmm4, xmm5
  00092	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  00096	f2 0f 5e c4	 divsd	 xmm0, xmm4
  0009a	f2 0f 5c d1	 subsd	 xmm2, xmm1
  0009e	f2 0f 11 01	 movsdx	 QWORD PTR [rcx], xmm0
  000a2	f2 0f 5e d4	 divsd	 xmm2, xmm4
  000a6	f2 0f 11 51 08	 movsdx	 QWORD PTR [rcx+8], xmm2

; 103  : }

  000ab	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000af	5b		 pop	 rbx
  000b0	c3		 ret	 0
$LN4@Py_c_quot:

; 91   :             r.imag = (a.imag - a.real * ratio) / denom;
; 92   :         }
; 93   :     }
; 94   :     else {
; 95   :         /* divide tops and bottom by b.imag */
; 96   :         const double ratio = b.real / b.imag;
; 97   :         const double denom = b.real * ratio + b.imag;
; 98   :         assert(b.imag != 0.0);
; 99   :         r.real = (a.real * ratio + a.imag) / denom;

  000b1	f2 0f 10 52 08	 movsdx	 xmm2, QWORD PTR [rdx+8]
  000b6	f2 0f 10 02	 movsdx	 xmm0, QWORD PTR [rdx]
  000ba	66 0f 28 dd	 movapd	 xmm3, xmm5

; 100  :         r.imag = (a.imag * ratio - a.real) / denom;
; 101  :     }
; 102  :     return r;

  000be	48 8b c3	 mov	 rax, rbx
  000c1	f2 41 0f 5e 58
	08		 divsd	 xmm3, QWORD PTR [r8+8]
  000c7	f2 0f 59 c3	 mulsd	 xmm0, xmm3
  000cb	f2 0f 59 eb	 mulsd	 xmm5, xmm3
  000cf	f2 41 0f 58 68
	08		 addsd	 xmm5, QWORD PTR [r8+8]
  000d5	f2 0f 58 c2	 addsd	 xmm0, xmm2
  000d9	f2 0f 59 d3	 mulsd	 xmm2, xmm3
  000dd	f2 0f 5e c5	 divsd	 xmm0, xmm5
  000e1	f2 0f 5c 12	 subsd	 xmm2, QWORD PTR [rdx]
  000e5	f2 0f 5e d5	 divsd	 xmm2, xmm5
  000e9	f2 0f 11 01	 movsdx	 QWORD PTR [rcx], xmm0
  000ed	f2 0f 11 51 08	 movsdx	 QWORD PTR [rcx+8], xmm2

; 103  : }

  000f2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f6	5b		 pop	 rbx
  000f7	c3		 ret	 0
_Py_c_quot ENDP
_TEXT	ENDS
PUBLIC	_Py_c_pow
EXTRN	pow:PROC
EXTRN	atan2:PROC
EXTRN	exp:PROC
EXTRN	log:PROC
EXTRN	cos:PROC
EXTRN	sin:PROC
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
pdata	SEGMENT
$pdata$_Py_c_pow DD imagerel $LN14
	DD	imagerel $LN14+163
	DD	imagerel $unwind$_Py_c_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_Py_c_pow DD imagerel $LN14+163
	DD	imagerel $LN14+356
	DD	imagerel $chain$3$_Py_c_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_Py_c_pow DD imagerel $LN14+356
	DD	imagerel $LN14+382
	DD	imagerel $chain$4$_Py_c_pow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_Py_c_pow DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+163
	DD	imagerel $unwind$_Py_c_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_Py_c_pow DD 081b21H
	DD	02a81bH
	DD	039815H
	DD	04880bH
	DD	057805H
	DD	imagerel $LN14
	DD	imagerel $LN14+163
	DD	imagerel $unwind$_Py_c_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_c_pow DD 081901H
	DD	066819H
	DD	011640fH
	DD	010340fH
	DD	0700bd20fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\complexobject.c
xdata	ENDS
;	COMDAT _Py_c_pow
_TEXT	SEGMENT
$T21315 = 128
a$ = 136
b$ = 144
_Py_c_pow PROC						; COMDAT

; 107  : {

$LN14:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 108  :     Py_complex r;
; 109  :     double vabs,len,at,phase;
; 110  :     if (b.real == 0. && b.imag == 0.) {

  0000f	f2 41 0f 10 08	 movsdx	 xmm1, QWORD PTR [r8]
  00014	0f 29 74 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm6
  00019	66 0f 57 f6	 xorpd	 xmm6, xmm6
  0001d	49 8b f8	 mov	 rdi, r8
  00020	48 8b f2	 mov	 rsi, rdx
  00023	48 8b d9	 mov	 rbx, rcx
  00026	66 0f 2e ce	 ucomisd xmm1, xmm6
  0002a	7a 2b		 jp	 SHORT $LN7@Py_c_pow
  0002c	75 29		 jne	 SHORT $LN7@Py_c_pow
  0002e	f2 41 0f 10 40
	08		 movsdx	 xmm0, QWORD PTR [r8+8]
  00034	66 0f 2e c6	 ucomisd xmm0, xmm6
  00038	7a 1d		 jp	 SHORT $LN7@Py_c_pow
  0003a	75 1b		 jne	 SHORT $LN7@Py_c_pow

; 111  :         r.real = 1.;

  0003c	48 b8 00 00 00
	00 00 00 f0 3f	 mov	 rax, 4607182418800017408 ; 3ff0000000000000H
  00046	48 89 01	 mov	 QWORD PTR [rcx], rax

; 112  :         r.imag = 0.;

  00049	33 c0		 xor	 eax, eax
  0004b	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 131  :     }
; 132  :     return r;

  0004f	48 8b c1	 mov	 rax, rcx
  00052	e9 10 01 00 00	 jmp	 $LN2@Py_c_pow
$LN7@Py_c_pow:

; 113  :     }
; 114  :     else if (a.real == 0. && a.imag == 0.) {

  00057	f2 0f 10 12	 movsdx	 xmm2, QWORD PTR [rdx]
  0005b	66 0f 2e d6	 ucomisd xmm2, xmm6
  0005f	7a 3d		 jp	 SHORT $LN5@Py_c_pow
  00061	75 3b		 jne	 SHORT $LN5@Py_c_pow
  00063	f2 0f 10 42 08	 movsdx	 xmm0, QWORD PTR [rdx+8]
  00068	66 0f 2e c6	 ucomisd xmm0, xmm6
  0006c	7a 30		 jp	 SHORT $LN5@Py_c_pow
  0006e	75 2e		 jne	 SHORT $LN5@Py_c_pow

; 115  :         if (b.imag != 0. || b.real < 0.)

  00070	f2 41 0f 10 40
	08		 movsdx	 xmm0, QWORD PTR [r8+8]
  00076	66 0f 2e c6	 ucomisd xmm0, xmm6
  0007a	7a 08		 jp	 SHORT $LN3@Py_c_pow
  0007c	75 06		 jne	 SHORT $LN3@Py_c_pow
  0007e	66 0f 2f f1	 comisd	 xmm6, xmm1
  00082	76 0c		 jbe	 SHORT $LN4@Py_c_pow
$LN3@Py_c_pow:

; 116  :             errno = EDOM;

  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0008a	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H
$LN4@Py_c_pow:

; 117  :         r.real = 0.;

  00090	33 c0		 xor	 eax, eax
  00092	48 89 03	 mov	 QWORD PTR [rbx], rax

; 118  :         r.imag = 0.;

  00095	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 119  :     }
; 120  :     else {

  00099	e9 c6 00 00 00	 jmp	 $LN13@Py_c_pow
$LN5@Py_c_pow:

; 121  :         vabs = hypot(a.real,a.imag);

  0009e	f2 0f 10 4a 08	 movsdx	 xmm1, QWORD PTR [rdx+8]
  000a3	0f 29 7c 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm7
  000a8	44 0f 29 44 24
	40		 movaps	 XMMWORD PTR [rsp+64], xmm8
  000ae	66 0f 28 c2	 movapd	 xmm0, xmm2
  000b2	44 0f 29 4c 24
	30		 movaps	 XMMWORD PTR [rsp+48], xmm9
  000b8	44 0f 29 54 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm10
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__hypot

; 122  :         len = pow(vabs,b.real);

  000c4	f2 44 0f 10 07	 movsdx	 xmm8, QWORD PTR [rdi]
  000c9	66 41 0f 28 c8	 movapd	 xmm1, xmm8
  000ce	66 44 0f 28 d0	 movapd	 xmm10, xmm0
  000d3	e8 00 00 00 00	 call	 pow

; 123  :         at = atan2(a.imag, a.real);

  000d8	f2 0f 10 0e	 movsdx	 xmm1, QWORD PTR [rsi]
  000dc	66 0f 28 f8	 movapd	 xmm7, xmm0
  000e0	f2 0f 10 46 08	 movsdx	 xmm0, QWORD PTR [rsi+8]
  000e5	e8 00 00 00 00	 call	 atan2

; 124  :         phase = at*b.real;
; 125  :         if (b.imag != 0.0) {

  000ea	f2 44 0f 10 4f
	08		 movsdx	 xmm9, QWORD PTR [rdi+8]
  000f0	66 44 0f 2e ce	 ucomisd xmm9, xmm6
  000f5	66 0f 28 e8	 movapd	 xmm5, xmm0
  000f9	f2 44 0f 59 c0	 mulsd	 xmm8, xmm0
  000fe	7a 02		 jp	 SHORT $LN12@Py_c_pow
  00100	74 26		 je	 SHORT $LN1@Py_c_pow
$LN12@Py_c_pow:

; 126  :             len /= exp(at*b.imag);

  00102	66 41 0f 28 c1	 movapd	 xmm0, xmm9
  00107	f2 0f 59 c5	 mulsd	 xmm0, xmm5
  0010b	e8 00 00 00 00	 call	 exp
  00110	f2 0f 5e f8	 divsd	 xmm7, xmm0

; 127  :             phase += b.imag*log(vabs);

  00114	66 41 0f 28 c2	 movapd	 xmm0, xmm10
  00119	e8 00 00 00 00	 call	 log
  0011e	f2 41 0f 59 c1	 mulsd	 xmm0, xmm9
  00123	f2 44 0f 58 c0	 addsd	 xmm8, xmm0
$LN1@Py_c_pow:

; 128  :         }
; 129  :         r.real = len*cos(phase);

  00128	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  0012d	e8 00 00 00 00	 call	 cos
  00132	f2 0f 59 c7	 mulsd	 xmm0, xmm7
  00136	f2 0f 11 03	 movsdx	 QWORD PTR [rbx], xmm0

; 130  :         r.imag = len*sin(phase);

  0013a	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  0013f	e8 00 00 00 00	 call	 sin
  00144	44 0f 28 54 24
	20		 movaps	 xmm10, XMMWORD PTR [rsp+32]
  0014a	44 0f 28 4c 24
	30		 movaps	 xmm9, XMMWORD PTR [rsp+48]
  00150	f2 0f 59 c7	 mulsd	 xmm0, xmm7
  00154	44 0f 28 44 24
	40		 movaps	 xmm8, XMMWORD PTR [rsp+64]
  0015a	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
  0015f	f2 0f 11 43 08	 movsdx	 QWORD PTR [rbx+8], xmm0
$LN13@Py_c_pow:

; 131  :     }
; 132  :     return r;

  00164	48 8b c3	 mov	 rax, rbx
$LN2@Py_c_pow:

; 133  : }

  00167	0f 28 74 24 60	 movaps	 xmm6, XMMWORD PTR [rsp+96]
  0016c	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  00171	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00175	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00179	49 8b e3	 mov	 rsp, r11
  0017c	5f		 pop	 rdi
  0017d	c3		 ret	 0
_Py_c_pow ENDP
_TEXT	ENDS
PUBLIC	$T21360
PUBLIC	$T21361
PUBLIC	$T21358
PUBLIC	$T21359
;	COMDAT pdata
pdata	SEGMENT
$pdata$c_powu DD imagerel c_powu
	DD	imagerel c_powu+201
	DD	imagerel $unwind$c_powu
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$c_powu DD 041601H
	DD	096816H
	DD	0150107H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT c_powu
_TEXT	SEGMENT
p$ = 32
$T21359 = 48
$T21358 = 64
$T21361 = 80
$T21360 = 96
$T21356 = 112
$T21357 = 128
$T21355 = 176
x$ = 184
n$ = 192
c_powu	PROC						; COMDAT

; 137  : {

  00000	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 138  :     Py_complex r, p;
; 139  :     long mask = 1;
; 140  :     r = c_1;

  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR c_1
  0000e	0f 29 b4 24 90
	00 00 00	 movaps	 XMMWORD PTR [rsp+144], xmm6

; 141  :     p = x;

  00016	0f 10 32	 movups	 xmm6, XMMWORD PTR [rdx]
  00019	48 89 01	 mov	 QWORD PTR [rcx], rax
  0001c	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR c_1+8
  00023	45 8b d0	 mov	 r10d, r8d
  00026	4c 8b d9	 mov	 r11, rcx
  00029	41 b9 01 00 00
	00		 mov	 r9d, 1
  0002f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00033	0f 29 74 24 20	 movaps	 XMMWORD PTR p$[rsp], xmm6
$LL3@c_powu:

; 142  :     while (mask > 0 && n >= mask) {

  00038	45 3b d1	 cmp	 r10d, r9d
  0003b	7c 79		 jl	 SHORT $LN8@c_powu

; 143  :         if (n & mask)

  0003d	45 85 ca	 test	 r9d, r10d
  00040	74 31		 je	 SHORT $LN1@c_powu

; 144  :             r = c_prod(r,p);

  00042	41 0f 10 03	 movups	 xmm0, XMMWORD PTR [r11]
  00046	4c 8d 44 24 30	 lea	 r8, QWORD PTR $T21359[rsp]
  0004b	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T21358[rsp]
  00050	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T21356[rsp]
  00055	66 0f 7f 74 24
	30		 movdqa	 XMMWORD PTR $T21359[rsp], xmm6
  0005b	0f 29 44 24 40	 movaps	 XMMWORD PTR $T21358[rsp], xmm0
  00060	e8 00 00 00 00	 call	 _Py_c_prod
  00065	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00068	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0006c	49 89 0b	 mov	 QWORD PTR [r11], rcx
  0006f	49 89 43 08	 mov	 QWORD PTR [r11+8], rax
$LN1@c_powu:

; 145  :         mask <<= 1;
; 146  :         p = c_prod(p,p);

  00073	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T21361[rsp]
  00078	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T21360[rsp]
  0007d	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T21357[rsp]
  00085	66 0f 7f 74 24
	50		 movdqa	 XMMWORD PTR $T21361[rsp], xmm6
  0008b	66 0f 7f 74 24
	60		 movdqa	 XMMWORD PTR $T21360[rsp], xmm6
  00091	45 03 c9	 add	 r9d, r9d
  00094	e8 00 00 00 00	 call	 _Py_c_prod
  00099	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0009c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000a0	48 89 44 24 28	 mov	 QWORD PTR p$[rsp+8], rax
  000a5	48 89 4c 24 20	 mov	 QWORD PTR p$[rsp], rcx
  000aa	45 85 c9	 test	 r9d, r9d
  000ad	7e 07		 jle	 SHORT $LN8@c_powu

; 141  :     p = x;

  000af	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR p$[rsp]
  000b4	eb 82		 jmp	 SHORT $LL3@c_powu
$LN8@c_powu:

; 147  :     }
; 148  :     return r;

  000b6	49 8b c3	 mov	 rax, r11

; 149  : }

  000b9	0f 28 b4 24 90
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+144]
  000c1	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  000c8	c3		 ret	 0
c_powu	ENDP
_TEXT	ENDS
PUBLIC	$T21386
PUBLIC	$T21387
PUBLIC	$T21390
PUBLIC	$T21391
PUBLIC	$T21388
;	COMDAT pdata
pdata	SEGMENT
$pdata$c_powi DD imagerel c_powi
	DD	imagerel c_powi+187
	DD	imagerel $unwind$c_powi
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$c_powi DD 040d01H
	DD	0e340dH
	DD	05006b20dH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT c_powi
_TEXT	SEGMENT
$T21391 = 32
$T21388 = 32
$T21386 = 32
cn$ = 32
$T21390 = 48
$T21387 = 48
$T21383 = 48
$T21384 = 64
$T21385 = 80
$T21382 = 80
$T21381 = 112
x$ = 120
n$ = 128
c_powi	PROC						; COMDAT

; 153  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	48 8b ec	 mov	 rbp, rsp
  00009	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 154  :     Py_complex cn;
; 155  : 
; 156  :     if (n > 100 || n < -100) {

  0000d	41 8d 40 64	 lea	 eax, DWORD PTR [r8+100]
  00011	48 8b d9	 mov	 rbx, rcx
  00014	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  00019	77 4c		 ja	 SHORT $LN4@c_powi

; 160  :     }
; 161  :     else if (n > 0)
; 162  :         return c_powu(x,n);

  0001b	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  0001e	48 8d 55 c0	 lea	 rdx, QWORD PTR $T21388[rbp-96]
  00022	0f 29 45 c0	 movaps	 XMMWORD PTR $T21388[rbp-96], xmm0
  00026	45 85 c0	 test	 r8d, r8d
  00029	7e 0b		 jle	 SHORT $LN2@c_powi
  0002b	48 8d 4d d0	 lea	 rcx, QWORD PTR $T21383[rbp-96]
  0002f	e8 00 00 00 00	 call	 c_powu
  00034	eb 69		 jmp	 SHORT $LN8@c_powi
$LN2@c_powi:

; 163  :     else
; 164  :         return c_quot(c_1,c_powu(x,-n));

  00036	48 8d 4d e0	 lea	 rcx, QWORD PTR $T21384[rbp-96]
  0003a	41 f7 d8	 neg	 r8d
  0003d	e8 00 00 00 00	 call	 c_powu
  00042	4c 8d 45 c0	 lea	 r8, QWORD PTR $T21391[rbp-96]
  00046	48 8d 55 d0	 lea	 rdx, QWORD PTR $T21390[rbp-96]
  0004a	0f 10 0d 00 00
	00 00		 movups	 xmm1, XMMWORD PTR c_1
  00051	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00054	48 8d 4d f0	 lea	 rcx, QWORD PTR $T21385[rbp-96]
  00058	0f 29 4d d0	 movaps	 XMMWORD PTR $T21390[rbp-96], xmm1
  0005c	0f 29 45 c0	 movaps	 XMMWORD PTR $T21391[rbp-96], xmm0
  00060	e8 00 00 00 00	 call	 _Py_c_quot
  00065	eb 38		 jmp	 SHORT $LN8@c_powi
$LN4@c_powi:

; 157  :         cn.real = (double) n;
; 158  :         cn.imag = 0.;

  00067	66 0f 57 c9	 xorpd	 xmm1, xmm1
  0006b	66 41 0f 6e c0	 movd	 xmm0, r8d

; 159  :         return c_pow(x,cn);

  00070	48 8d 4d f0	 lea	 rcx, QWORD PTR $T21382[rbp-96]
  00074	f2 0f 11 4d c8	 movsdx	 QWORD PTR cn$[rbp-88], xmm1
  00079	4c 8d 45 d0	 lea	 r8, QWORD PTR $T21387[rbp-96]
  0007d	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00081	f2 0f 11 45 c0	 movsdx	 QWORD PTR cn$[rbp-96], xmm0
  00086	0f 28 45 c0	 movaps	 xmm0, XMMWORD PTR cn$[rbp-96]
  0008a	66 0f 7f 45 d0	 movdqa	 XMMWORD PTR $T21387[rbp-96], xmm0
  0008f	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  00092	48 8d 55 c0	 lea	 rdx, QWORD PTR $T21386[rbp-96]
  00096	0f 29 45 c0	 movaps	 XMMWORD PTR $T21386[rbp-96], xmm0
  0009a	e8 00 00 00 00	 call	 _Py_c_pow
$LN8@c_powi:
  0009f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000a2	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000a6	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  000a9	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
  000ad	48 8b c3	 mov	 rax, rbx

; 165  : 
; 166  : }

  000b0	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  000b5	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000b9	5d		 pop	 rbp
  000ba	c3		 ret	 0
c_powi	ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	__mask@@AbsDouble@
PUBLIC	_Py_c_abs
EXTRN	__imp__HUGE:QWORD
EXTRN	__imp__isnan:PROC
EXTRN	__imp__finite:PROC
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
pdata	SEGMENT
$pdata$_Py_c_abs DD imagerel $LN11
	DD	imagerel $LN11+266
	DD	imagerel $unwind$_Py_c_abs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_c_abs DD 040f01H
	DD	02680fH
	DD	030025206H
xdata	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __mask@@AbsDouble@
CONST	SEGMENT
__mask@@AbsDouble@ DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\complexobject.c
CONST	ENDS
;	COMDAT _Py_c_abs
_TEXT	SEGMENT
z$ = 64
_Py_c_abs PROC						; COMDAT

; 170  : {

$LN11:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 171  :     /* sets errno = ERANGE on overflow;  otherwise errno = 0 */
; 172  :     double result;
; 173  : 
; 174  :     if (!Py_IS_FINITE(z.real) || !Py_IS_FINITE(z.imag)) {

  00006	f2 0f 10 01	 movsdx	 xmm0, QWORD PTR [rcx]
  0000a	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00018	85 c0		 test	 eax, eax
  0001a	74 47		 je	 SHORT $LN5@Py_c_abs
  0001c	f2 0f 10 43 08	 movsdx	 xmm0, QWORD PTR [rbx+8]
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00027	85 c0		 test	 eax, eax
  00029	74 38		 je	 SHORT $LN5@Py_c_abs

; 191  :     }
; 192  :     result = hypot(z.real, z.imag);

  0002b	f2 0f 10 4b 08	 movsdx	 xmm1, QWORD PTR [rbx+8]
  00030	f2 0f 10 03	 movsdx	 xmm0, QWORD PTR [rbx]
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__hypot
  0003a	66 0f 28 f0	 movapd	 xmm6, xmm0

; 193  :     if (!Py_IS_FINITE(result))

  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00044	85 c0		 test	 eax, eax
  00046	75 43		 jne	 SHORT $LN2@Py_c_abs

; 194  :         errno = ERANGE;

  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0004e	66 0f 28 c6	 movapd	 xmm0, xmm6
  00052	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H

; 195  :     else
; 196  :         errno = 0;
; 197  :     return result;
; 198  : }

  00058	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
$LN5@Py_c_abs:

; 175  :         /* C99 rules: if either the real or the imaginary part is an
; 176  :            infinity, return infinity, even if the other part is a
; 177  :            NaN. */
; 178  :         if (Py_IS_INFINITY(z.real)) {

  00063	f2 0f 10 03	 movsdx	 xmm0, QWORD PTR [rbx]
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0006d	85 c0		 test	 eax, eax
  0006f	75 35		 jne	 SHORT $LN4@Py_c_abs
  00071	f2 0f 10 03	 movsdx	 xmm0, QWORD PTR [rbx]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0007b	85 c0		 test	 eax, eax
  0007d	75 27		 jne	 SHORT $LN4@Py_c_abs

; 179  :             result = fabs(z.real);

  0007f	f2 0f 10 33	 movsdx	 xmm6, QWORD PTR [rbx]
  00083	66 0f 54 35 00
	00 00 00	 andpd	 xmm6, QWORD PTR __mask@@AbsDouble@
$LN2@Py_c_abs:

; 180  :             errno = 0;

  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 181  :             return result;

  00091	66 0f 28 c6	 movapd	 xmm0, xmm6
  00095	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 195  :     else
; 196  :         errno = 0;
; 197  :     return result;
; 198  : }

  0009b	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000a0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a4	5b		 pop	 rbx
  000a5	c3		 ret	 0
$LN4@Py_c_abs:

; 182  :         }
; 183  :         if (Py_IS_INFINITY(z.imag)) {

  000a6	f2 0f 10 43 08	 movsdx	 xmm0, QWORD PTR [rbx+8]
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000b1	85 c0		 test	 eax, eax
  000b3	75 37		 jne	 SHORT $LN3@Py_c_abs
  000b5	f2 0f 10 43 08	 movsdx	 xmm0, QWORD PTR [rbx+8]
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000c0	85 c0		 test	 eax, eax
  000c2	75 28		 jne	 SHORT $LN3@Py_c_abs

; 184  :             result = fabs(z.imag);

  000c4	f2 0f 10 73 08	 movsdx	 xmm6, QWORD PTR [rbx+8]
  000c9	66 0f 54 35 00
	00 00 00	 andpd	 xmm6, QWORD PTR __mask@@AbsDouble@

; 185  :             errno = 0;

  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 186  :             return result;

  000d7	66 0f 28 c6	 movapd	 xmm0, xmm6
  000db	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 195  :     else
; 196  :         errno = 0;
; 197  :     return result;
; 198  : }

  000e1	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000e6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ea	5b		 pop	 rbx
  000eb	c3		 ret	 0
$LN3@Py_c_abs:

; 187  :         }
; 188  :         /* either the real or imaginary part is a NaN,
; 189  :            and neither is infinite. Result should be NaN. */
; 190  :         return Py_NAN;

  000ec	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE

; 195  :     else
; 196  :         errno = 0;
; 197  :     return result;
; 198  : }

  000f3	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000f8	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  000fc	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@0000000000000000
  00104	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00108	5b		 pop	 rbx
  00109	c3		 ret	 0
_Py_c_abs ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_subtype_from_c_complex DD imagerel complex_subtype_from_c_complex
	DD	imagerel complex_subtype_from_c_complex+46
	DD	imagerel $unwind$complex_subtype_from_c_complex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_subtype_from_c_complex DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT complex_subtype_from_c_complex
_TEXT	SEGMENT
type$ = 48
cval$ = 56
complex_subtype_from_c_complex PROC			; COMDAT

; 202  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx
  00009	48 8b c1	 mov	 rax, rcx

; 203  :     PyObject *op;
; 204  : 
; 205  :     op = type->tp_alloc(type, 0);

  0000c	33 d2		 xor	 edx, edx
  0000e	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]

; 206  :     if (op != NULL)

  00014	48 85 c0	 test	 rax, rax
  00017	74 0f		 je	 SHORT $LN4@complex_su

; 207  :         ((PyComplexObject *)op)->cval = cval;

  00019	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0001c	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx
  00020	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00024	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN4@complex_su:

; 208  :     return op;
; 209  : }

  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5b		 pop	 rbx
  0002d	c3		 ret	 0
complex_subtype_from_c_complex ENDP
_TEXT	ENDS
PUBLIC	PyComplex_FromCComplex
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyObject_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyComplex_FromCComplex DD imagerel $LN4
	DD	imagerel $LN4+90
	DD	imagerel $unwind$PyComplex_FromCComplex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyComplex_FromCComplex DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyComplex_FromCComplex
_TEXT	SEGMENT
cval$ = 48
PyComplex_FromCComplex PROC				; COMDAT

; 213  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 214  :     register PyComplexObject *op;
; 215  : 
; 216  :     /* Inline PyObject_New */
; 217  :     op = (PyComplexObject *) PyObject_MALLOC(sizeof(PyComplexObject));

  0000d	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  00012	e8 00 00 00 00	 call	 PyObject_Malloc
  00017	48 8b d8	 mov	 rbx, rax

; 218  :     if (op == NULL)

  0001a	48 85 c0	 test	 rax, rax
  0001d	75 0f		 jne	 SHORT $LN1@PyComplex_

; 223  : }

  0001f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5f		 pop	 rdi
  00029	e9 00 00 00 00	 jmp	 PyErr_NoMemory
$LN1@PyComplex_:

; 219  :         return PyErr_NoMemory();
; 220  :     PyObject_INIT(op, &PyComplex_Type);

  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyComplex_Type
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 PyObject_INIT

; 221  :     op->cval = cval;

  0003d	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00040	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax
  00044	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00048	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax

; 222  :     return (PyObject *) op;

  0004c	48 8b c3	 mov	 rax, rbx

; 223  : }

  0004f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
PyComplex_FromCComplex ENDP
_TEXT	ENDS
PUBLIC	$T21451
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_subtype_from_doubles DD imagerel complex_subtype_from_doubles
	DD	imagerel complex_subtype_from_doubles+42
	DD	imagerel $unwind$complex_subtype_from_doubles
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_subtype_from_doubles DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT complex_subtype_from_doubles
_TEXT	SEGMENT
$T21451 = 32
c$ = 32
type$ = 64
real$ = 72
imag$ = 80
complex_subtype_from_doubles PROC			; COMDAT

; 227  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 228  :     Py_complex c;
; 229  :     c.real = real;

  00004	f2 0f 11 4c 24
	20		 movsdx	 QWORD PTR c$[rsp], xmm1

; 230  :     c.imag = imag;

  0000a	f2 0f 11 54 24
	28		 movsdx	 QWORD PTR c$[rsp+8], xmm2

; 231  :     return complex_subtype_from_c_complex(type, c);

  00010	0f 28 44 24 20	 movaps	 xmm0, XMMWORD PTR c$[rsp]
  00015	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T21451[rsp]
  0001a	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR $T21451[rsp], xmm0
  00020	e8 00 00 00 00	 call	 complex_subtype_from_c_complex

; 232  : }

  00025	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00029	c3		 ret	 0
complex_subtype_from_doubles ENDP
_TEXT	ENDS
PUBLIC	$T21462
PUBLIC	PyComplex_FromDoubles
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyComplex_FromDoubles DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$PyComplex_FromDoubles
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyComplex_FromDoubles DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyComplex_FromDoubles
_TEXT	SEGMENT
$T21462 = 32
c$ = 32
real$ = 64
imag$ = 72
PyComplex_FromDoubles PROC				; COMDAT

; 236  : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 237  :     Py_complex c;
; 238  :     c.real = real;

  00004	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR c$[rsp], xmm0

; 239  :     c.imag = imag;

  0000a	f2 0f 11 4c 24
	28		 movsdx	 QWORD PTR c$[rsp+8], xmm1

; 240  :     return PyComplex_FromCComplex(c);

  00010	0f 28 44 24 20	 movaps	 xmm0, XMMWORD PTR c$[rsp]
  00015	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T21462[rsp]
  0001a	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR $T21462[rsp], xmm0
  00020	e8 00 00 00 00	 call	 PyComplex_FromCComplex

; 241  : }

  00025	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00029	c3		 ret	 0
PyComplex_FromDoubles ENDP
_TEXT	ENDS
PUBLIC	PyComplex_RealAsDouble
EXTRN	PyFloat_AsDouble:PROC
EXTRN	PyType_IsSubtype:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyComplex_RealAsDouble DD imagerel $LN6
	DD	imagerel $LN6+58
	DD	imagerel $unwind$PyComplex_RealAsDouble
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyComplex_RealAsDouble DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyComplex_RealAsDouble
_TEXT	SEGMENT
op$ = 48
PyComplex_RealAsDouble PROC				; COMDAT

; 245  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 246  :     if (PyComplex_Check(op)) {

  00009	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyComplex_Type
  00014	48 3b ca	 cmp	 rcx, rdx
  00017	74 16		 je	 SHORT $LN2@PyComplex_@2
  00019	e8 00 00 00 00	 call	 PyType_IsSubtype
  0001e	85 c0		 test	 eax, eax
  00020	75 0d		 jne	 SHORT $LN2@PyComplex_@2

; 248  :     }
; 249  :     else {
; 250  :         return PyFloat_AsDouble(op);

  00022	48 8b cb	 mov	 rcx, rbx

; 251  :     }
; 252  : }

  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5b		 pop	 rbx
  0002a	e9 00 00 00 00	 jmp	 PyFloat_AsDouble
$LN2@PyComplex_@2:

; 247  :         return ((PyComplexObject *)op)->cval.real;

  0002f	f2 0f 10 43 60	 movsdx	 xmm0, QWORD PTR [rbx+96]

; 251  :     }
; 252  : }

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
PyComplex_RealAsDouble ENDP
_TEXT	ENDS
PUBLIC	PyComplex_ImagAsDouble
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyComplex_ImagAsDouble DD imagerel $LN6
	DD	imagerel $LN6+55
	DD	imagerel $unwind$PyComplex_ImagAsDouble
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyComplex_ImagAsDouble DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyComplex_ImagAsDouble
_TEXT	SEGMENT
op$ = 48
PyComplex_ImagAsDouble PROC				; COMDAT

; 256  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 257  :     if (PyComplex_Check(op)) {

  00009	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyComplex_Type
  00014	48 3b ca	 cmp	 rcx, rdx
  00017	74 13		 je	 SHORT $LN2@PyComplex_@3
  00019	e8 00 00 00 00	 call	 PyType_IsSubtype
  0001e	85 c0		 test	 eax, eax
  00020	75 0a		 jne	 SHORT $LN2@PyComplex_@3

; 259  :     }
; 260  :     else {
; 261  :         return 0.0;

  00022	66 0f 57 c0	 xorpd	 xmm0, xmm0

; 262  :     }
; 263  : }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
$LN2@PyComplex_@3:

; 258  :         return ((PyComplexObject *)op)->cval.imag;

  0002c	f2 0f 10 43 68	 movsdx	 xmm0, QWORD PTR [rbx+104]

; 262  :     }
; 263  : }

  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5b		 pop	 rbx
  00036	c3		 ret	 0
PyComplex_ImagAsDouble ENDP
_TEXT	ENDS
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	_PyObject_LookupSpecial:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$try_complex_special_method DD imagerel try_complex_special_method
	DD	imagerel try_complex_special_method+49
	DD	imagerel $unwind$try_complex_special_method
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$try_complex_special_method DD imagerel try_complex_special_method+49
	DD	imagerel try_complex_special_method+84
	DD	imagerel $chain$0$try_complex_special_method
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$try_complex_special_method DD imagerel try_complex_special_method+84
	DD	imagerel try_complex_special_method+90
	DD	imagerel $chain$1$try_complex_special_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$try_complex_special_method DD 021H
	DD	imagerel try_complex_special_method
	DD	imagerel try_complex_special_method+49
	DD	imagerel $unwind$try_complex_special_method
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$try_complex_special_method DD 020521H
	DD	063405H
	DD	imagerel try_complex_special_method
	DD	imagerel try_complex_special_method+49
	DD	imagerel $unwind$try_complex_special_method
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$try_complex_special_method DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT try_complex_special_method
_TEXT	SEGMENT
op$ = 48
try_complex_special_method PROC				; COMDAT

; 266  : try_complex_special_method(PyObject *op) {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 267  :     PyObject *f;
; 268  :     _Py_IDENTIFIER(__complex__);
; 269  : 
; 270  :     f = _PyObject_LookupSpecial(op, &PyId___complex__);

  00006	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0000d	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00016	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___complex__@?1??try_complex_special_method@@9@9
  0001b	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0001f	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  00024	48 8b f8	 mov	 rdi, rax

; 271  :     if (f) {

  00027	48 85 c0	 test	 rax, rax
  0002a	74 28		 je	 SHORT $LN1@try_comple

; 272  :         PyObject *res = PyObject_CallFunctionObjArgs(f, NULL);

  0002c	33 d2		 xor	 edx, edx
  0002e	48 8b c8	 mov	 rcx, rax
  00031	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00036	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs

; 273  :         Py_DECREF(f);

  0003b	48 8b cf	 mov	 rcx, rdi
  0003e	48 8b d8	 mov	 rbx, rax
  00041	e8 00 00 00 00	 call	 _Py_DecRef

; 274  :         return res;

  00046	48 8b c3	 mov	 rax, rbx
  00049	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 275  :     }
; 276  :     return NULL;
; 277  : }

  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
$LN1@try_comple:
  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
try_complex_special_method ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@JPAGGKMO@__complex__?5should?5return?5a?5comp@ ; `string'
PUBLIC	__real@bff0000000000000
PUBLIC	PyComplex_AsCComplex
EXTRN	PyErr_Occurred:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyComplex_AsCComplex DD imagerel $LN14
	DD	imagerel $LN14+72
	DD	imagerel $unwind$PyComplex_AsCComplex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyComplex_AsCComplex DD imagerel $LN14+72
	DD	imagerel $LN14+199
	DD	imagerel $chain$0$PyComplex_AsCComplex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyComplex_AsCComplex DD imagerel $LN14+199
	DD	imagerel $LN14+242
	DD	imagerel $chain$2$PyComplex_AsCComplex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyComplex_AsCComplex DD imagerel $LN14+242
	DD	imagerel $LN14+276
	DD	imagerel $chain$3$PyComplex_AsCComplex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyComplex_AsCComplex DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+72
	DD	imagerel $unwind$PyComplex_AsCComplex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyComplex_AsCComplex DD 020021H
	DD	085400H
	DD	imagerel $LN14
	DD	imagerel $LN14+72
	DD	imagerel $unwind$PyComplex_AsCComplex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyComplex_AsCComplex DD 020521H
	DD	085405H
	DD	imagerel $LN14
	DD	imagerel $LN14+72
	DD	imagerel $unwind$PyComplex_AsCComplex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyComplex_AsCComplex DD 060f01H
	DD	0a640fH
	DD	09340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0CL@JPAGGKMO@__complex__?5should?5return?5a?5comp@
CONST	SEGMENT
??_C@_0CL@JPAGGKMO@__complex__?5should?5return?5a?5comp@ DB '__complex__ '
	DB	'should return a complex object', 00H	; `string'
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyComplex_AsCComplex
_TEXT	SEGMENT
cv$ = 32
$T21517 = 64
op$ = 72
PyComplex_AsCComplex PROC				; COMDAT

; 281  : {

$LN14:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b f1	 mov	 rsi, rcx

; 282  :     Py_complex cv;
; 283  :     PyObject *newop = NULL;
; 284  : 
; 285  :     assert(op);
; 286  :     /* If op is already of type PyComplex_Type, return its value */
; 287  :     if (PyComplex_Check(op)) {

  00012	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00016	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:PyComplex_Type
  0001d	48 8b da	 mov	 rbx, rdx
  00020	48 3b cf	 cmp	 rcx, rdi
  00023	0f 84 c9 00 00
	00		 je	 $LN6@PyComplex_@4
  00029	48 8b d7	 mov	 rdx, rdi
  0002c	e8 00 00 00 00	 call	 PyType_IsSubtype
  00031	85 c0		 test	 eax, eax
  00033	0f 85 b9 00 00
	00		 jne	 $LN6@PyComplex_@4

; 289  :     }
; 290  :     /* If not, use op's __complex__  method, if it exists */
; 291  : 
; 292  :     /* return -1 on failure */
; 293  :     cv.real = -1.;

  00039	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000

; 294  :     cv.imag = 0.;

  00041	66 0f 57 c9	 xorpd	 xmm1, xmm1

; 295  : 
; 296  :     newop = try_complex_special_method(op);

  00045	48 8b cb	 mov	 rcx, rbx
  00048	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  0004d	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR cv$[rsp], xmm0
  00053	f2 0f 11 4c 24
	28		 movsdx	 QWORD PTR cv$[rsp+8], xmm1
  00059	e8 00 00 00 00	 call	 try_complex_special_method
  0005e	48 8b e8	 mov	 rbp, rax

; 297  : 
; 298  :     if (newop) {

  00061	48 85 c0	 test	 rax, rax
  00064	74 61		 je	 SHORT $LN5@PyComplex_@4

; 299  :         if (!PyComplex_Check(newop)) {

  00066	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0006a	48 3b cf	 cmp	 rcx, rdi
  0006d	74 29		 je	 SHORT $LN4@PyComplex_@4
  0006f	48 8b d7	 mov	 rdx, rdi
  00072	e8 00 00 00 00	 call	 PyType_IsSubtype
  00077	85 c0		 test	 eax, eax
  00079	75 1d		 jne	 SHORT $LN4@PyComplex_@4

; 300  :             PyErr_SetString(PyExc_TypeError,
; 301  :                 "__complex__ should return a complex object");

  0007b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@JPAGGKMO@__complex__?5should?5return?5a?5comp@
  00089	e8 00 00 00 00	 call	 PyErr_SetString

; 302  :             Py_DECREF(newop);

  0008e	48 8b cd	 mov	 rcx, rbp
  00091	e8 00 00 00 00	 call	 _Py_DecRef

; 303  :             return cv;

  00096	eb 47		 jmp	 SHORT $LN11@PyComplex_@4
$LN4@PyComplex_@4:

; 304  :         }
; 305  :         cv = ((PyComplexObject *)newop)->cval;

  00098	48 8b 5d 60	 mov	 rbx, QWORD PTR [rbp+96]
  0009c	48 8b 7d 68	 mov	 rdi, QWORD PTR [rbp+104]

; 306  :         Py_DECREF(newop);

  000a0	48 8b cd	 mov	 rcx, rbp
  000a3	e8 00 00 00 00	 call	 _Py_DecRef

; 307  :         return cv;

  000a8	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  000ab	48 89 7e 08	 mov	 QWORD PTR [rsi+8], rdi
$LN12@PyComplex_@4:
  000af	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000b4	48 8b c6	 mov	 rax, rsi

; 318  :     }
; 319  : }

  000b7	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000bc	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000c1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c5	5f		 pop	 rdi
  000c6	c3		 ret	 0
$LN5@PyComplex_@4:

; 308  :     }
; 309  :     else if (PyErr_Occurred()) {

  000c7	e8 00 00 00 00	 call	 PyErr_Occurred
  000cc	48 85 c0	 test	 rax, rax

; 310  :         return cv;

  000cf	75 0e		 jne	 SHORT $LN11@PyComplex_@4

; 311  :     }
; 312  :     /* If neither of the above works, interpret op as a float giving the
; 313  :        real part of the result, and fill in the imaginary part as 0. */
; 314  :     else {
; 315  :         /* PyFloat_AsDouble will return -1 on failure */
; 316  :         cv.real = PyFloat_AsDouble(op);

  000d1	48 8b cb	 mov	 rcx, rbx
  000d4	e8 00 00 00 00	 call	 PyFloat_AsDouble
  000d9	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR cv$[rsp], xmm0
$LN11@PyComplex_@4:

; 317  :         return cv;

  000df	48 8b 44 24 20	 mov	 rax, QWORD PTR cv$[rsp]
  000e4	48 89 06	 mov	 QWORD PTR [rsi], rax
  000e7	48 8b 44 24 28	 mov	 rax, QWORD PTR cv$[rsp+8]
  000ec	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax
  000f0	eb bd		 jmp	 SHORT $LN12@PyComplex_@4
$LN6@PyComplex_@4:

; 288  :         return ((PyComplexObject *)op)->cval;

  000f2	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  000f6	48 89 06	 mov	 QWORD PTR [rsi], rax
  000f9	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]

; 318  :     }
; 319  : }

  000fd	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00102	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax
  00106	48 8b c6	 mov	 rax, rsi
  00109	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0010e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00112	5f		 pop	 rdi
  00113	c3		 ret	 0
PyComplex_AsCComplex ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT complex_dealloc
_TEXT	SEGMENT
op$ = 8
complex_dealloc PROC					; COMDAT

; 324  :     op->ob_type->tp_free(op);

  00000	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]

; 325  : }

  00004	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
complex_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_09JHCFLBEK@?$CFs?$CFs?$CFsj?$CFs?$AA@	; `string'
PUBLIC	??_C@_01PKGAHCOL@?$CJ?$AA@			; `string'
PUBLIC	??_C@_01ODHLEDKK@?$CI?$AA@			; `string'
PUBLIC	__real@3ff0000000000000
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
EXTRN	PyMem_Free:PROC
EXTRN	PyUnicode_FromFormat:PROC
EXTRN	PyOS_double_to_string:PROC
EXTRN	__imp__copysign:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_repr DD imagerel complex_repr
	DD	imagerel complex_repr+300
	DD	imagerel $unwind$complex_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_repr DD 0c1e01H
	DD	0d741eH
	DD	0c641eH
	DD	0b541eH
	DD	0a341eH
	DD	0e01a521eH
	DD	0c016d018H
xdata	ENDS
;	COMDAT ??_C@_09JHCFLBEK@?$CFs?$CFs?$CFsj?$CFs?$AA@
CONST	SEGMENT
??_C@_09JHCFLBEK@?$CFs?$CFs?$CFsj?$CFs?$AA@ DB '%s%s%sj%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ?$AA@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ?$AA@ DB ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01ODHLEDKK@?$CI?$AA@
CONST	SEGMENT
??_C@_01ODHLEDKK@?$CI?$AA@ DB '(', 00H			; `string'
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT complex_repr
_TEXT	SEGMENT
v$ = 80
complex_repr PROC					; COMDAT

; 329  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 330  :     int precision = 0;
; 331  :     char format_code = 'r';
; 332  :     PyObject *result = NULL;
; 333  : 
; 334  :     /* If these are non-NULL, they'll need to be freed. */
; 335  :     char *pre = NULL;
; 336  :     char *im = NULL;
; 337  : 
; 338  :     /* These do not need to be freed. re is either an alias
; 339  :        for pre or a pointer to a constant.  lead and tail
; 340  :        are pointers to constants. */
; 341  :     char *re = NULL;
; 342  :     char *lead = "";
; 343  :     char *tail = "";
; 344  : 
; 345  :     if (v->cval.real == 0. && copysign(1.0, v->cval.real)==1.0) {

  0001e	f2 0f 10 49 60	 movsdx	 xmm1, QWORD PTR [rcx+96]
  00023	33 db		 xor	 ebx, ebx
  00025	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0002c	66 0f 2e 0d 00
	00 00 00	 ucomisd xmm1, QWORD PTR __real@0000000000000000
  00034	4c 8b e1	 mov	 r12, rcx
  00037	8b eb		 mov	 ebp, ebx
  00039	8b fb		 mov	 edi, ebx
  0003b	4c 8b ee	 mov	 r13, rsi
  0003e	7a 47		 jp	 SHORT $LN5@complex_re
  00040	75 45		 jne	 SHORT $LN5@complex_re
  00042	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  00050	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  00058	7a 2d		 jp	 SHORT $LN5@complex_re
  0005a	75 2b		 jne	 SHORT $LN5@complex_re

; 346  :         /* Real part is +0: just output the imaginary part and do not
; 347  :            include parens. */
; 348  :         re = "";
; 349  :         im = PyOS_double_to_string(v->cval.imag, format_code,
; 350  :                                    precision, 0, NULL);

  0005c	f2 41 0f 10 44
	24 68		 movsdx	 xmm0, QWORD PTR [r12+104]
  00063	45 33 c9	 xor	 r9d, r9d
  00066	45 33 c0	 xor	 r8d, r8d
  00069	b2 72		 mov	 dl, 114			; 00000072H
  0006b	4c 8b f6	 mov	 r14, rsi
  0006e	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00073	e8 00 00 00 00	 call	 PyOS_double_to_string
  00078	48 8b f8	 mov	 rdi, rax

; 351  :         if (!im) {

  0007b	48 85 c0	 test	 rax, rax
  0007e	75 5d		 jne	 SHORT $LN3@complex_re
$LN8@complex_re:

; 352  :             PyErr_NoMemory();

  00080	e8 00 00 00 00	 call	 PyErr_NoMemory

; 353  :             goto done;

  00085	eb 73		 jmp	 SHORT $done$20422
$LN5@complex_re:

; 354  :         }
; 355  :     } else {
; 356  :         /* Format imaginary part with sign, real part without. Include
; 357  :            parens in the result. */
; 358  :         pre = PyOS_double_to_string(v->cval.real, format_code,
; 359  :                                     precision, 0, NULL);

  00087	f2 41 0f 10 44
	24 60		 movsdx	 xmm0, QWORD PTR [r12+96]
  0008e	45 33 c9	 xor	 r9d, r9d
  00091	45 33 c0	 xor	 r8d, r8d
  00094	b2 72		 mov	 dl, 114			; 00000072H
  00096	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0009b	e8 00 00 00 00	 call	 PyOS_double_to_string
  000a0	48 8b e8	 mov	 rbp, rax

; 360  :         if (!pre) {

  000a3	48 85 c0	 test	 rax, rax

; 361  :             PyErr_NoMemory();
; 362  :             goto done;

  000a6	74 d8		 je	 SHORT $LN8@complex_re

; 363  :         }
; 364  :         re = pre;
; 365  : 
; 366  :         im = PyOS_double_to_string(v->cval.imag, format_code,
; 367  :                                    precision, Py_DTSF_SIGN, NULL);

  000a8	f2 41 0f 10 44
	24 68		 movsdx	 xmm0, QWORD PTR [r12+104]
  000af	41 b9 01 00 00
	00		 mov	 r9d, 1
  000b5	45 33 c0	 xor	 r8d, r8d
  000b8	b2 72		 mov	 dl, 114			; 00000072H
  000ba	4c 8b f0	 mov	 r14, rax
  000bd	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  000c2	e8 00 00 00 00	 call	 PyOS_double_to_string
  000c7	48 8b f8	 mov	 rdi, rax

; 368  :         if (!im) {

  000ca	48 85 c0	 test	 rax, rax

; 369  :             PyErr_NoMemory();
; 370  :             goto done;

  000cd	74 b1		 je	 SHORT $LN8@complex_re

; 371  :         }
; 372  :         lead = "(";

  000cf	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:??_C@_01ODHLEDKK@?$CI?$AA@

; 373  :         tail = ")";

  000d6	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ?$AA@
$LN3@complex_re:

; 374  :     }
; 375  :     result = PyUnicode_FromFormat("%s%s%sj%s", lead, re, im, tail);

  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09JHCFLBEK@?$CFs?$CFs?$CFsj?$CFs?$AA@
  000e4	4c 8b cf	 mov	 r9, rdi
  000e7	4d 8b c6	 mov	 r8, r14
  000ea	48 8b d6	 mov	 rdx, rsi
  000ed	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  000f2	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  000f7	48 8b d8	 mov	 rbx, rax
$done$20422:

; 376  :   done:
; 377  :     PyMem_Free(im);

  000fa	48 8b cf	 mov	 rcx, rdi
  000fd	e8 00 00 00 00	 call	 PyMem_Free

; 378  :     PyMem_Free(pre);

  00102	48 8b cd	 mov	 rcx, rbp
  00105	e8 00 00 00 00	 call	 PyMem_Free

; 379  : 
; 380  :     return result;
; 381  : }

  0010a	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  0010f	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00114	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00119	48 8b c3	 mov	 rax, rbx
  0011c	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00121	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00125	41 5e		 pop	 r14
  00127	41 5d		 pop	 r13
  00129	41 5c		 pop	 r12
  0012b	c3		 ret	 0
complex_repr ENDP
_TEXT	ENDS
EXTRN	_Py_HashDouble:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_hash DD imagerel complex_hash
	DD	imagerel complex_hash+99
	DD	imagerel $unwind$complex_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_hash DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT complex_hash
_TEXT	SEGMENT
v$ = 48
complex_hash PROC					; COMDAT

; 385  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 386  :     Py_uhash_t hashreal, hashimag, combined;
; 387  :     hashreal = (Py_uhash_t)_Py_HashDouble(v->cval.real);

  0000a	f2 0f 10 41 60	 movsdx	 xmm0, QWORD PTR [rcx+96]
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	e8 00 00 00 00	 call	 _Py_HashDouble
  00017	48 8b f8	 mov	 rdi, rax

; 388  :     if (hashreal == (Py_uhash_t)-1)

  0001a	48 83 f8 ff	 cmp	 rax, -1
  0001e	75 0f		 jne	 SHORT $LN3@complex_ha
$LN6@complex_ha:

; 389  :         return -1;

  00020	48 83 c8 ff	 or	 rax, -1

; 393  :     /* Note:  if the imaginary part is 0, hashimag is 0 now,
; 394  :      * so the following returns hashreal unchanged.  This is
; 395  :      * important because numbers of different types that
; 396  :      * compare equal must have the same hash value, so that
; 397  :      * hash(x + 0*j) must equal hash(x).
; 398  :      */
; 399  :     combined = hashreal + _PyHASH_IMAG * hashimag;
; 400  :     if (combined == (Py_uhash_t)-1)
; 401  :         combined = (Py_uhash_t)-2;
; 402  :     return (Py_hash_t)combined;
; 403  : }

  00024	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5f		 pop	 rdi
  0002e	c3		 ret	 0
$LN3@complex_ha:

; 390  :     hashimag = (Py_uhash_t)_Py_HashDouble(v->cval.imag);

  0002f	f2 0f 10 43 68	 movsdx	 xmm0, QWORD PTR [rbx+104]
  00034	e8 00 00 00 00	 call	 _Py_HashDouble

; 391  :     if (hashimag == (Py_uhash_t)-1)

  00039	48 83 f8 ff	 cmp	 rax, -1

; 392  :         return -1;

  0003d	74 e1		 je	 SHORT $LN6@complex_ha

; 393  :     /* Note:  if the imaginary part is 0, hashimag is 0 now,
; 394  :      * so the following returns hashreal unchanged.  This is
; 395  :      * important because numbers of different types that
; 396  :      * compare equal must have the same hash value, so that
; 397  :      * hash(x + 0*j) must equal hash(x).
; 398  :      */
; 399  :     combined = hashreal + _PyHASH_IMAG * hashimag;
; 400  :     if (combined == (Py_uhash_t)-1)
; 401  :         combined = (Py_uhash_t)-2;
; 402  :     return (Py_hash_t)combined;
; 403  : }

  0003f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00044	48 69 c0 43 42
	0f 00		 imul	 rax, 1000003		; 000f4243H
  0004b	48 c7 c1 fe ff
	ff ff		 mov	 rcx, -2
  00052	48 03 c7	 add	 rax, rdi
  00055	48 83 f8 ff	 cmp	 rax, -1
  00059	48 0f 44 c1	 cmove	 rax, rcx
  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
complex_hash ENDP
_TEXT	ENDS
EXTRN	_Py_NotImplementedStruct:BYTE
EXTRN	PyFloat_Type:BYTE
EXTRN	PyLong_AsDouble:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$to_complex DD imagerel to_complex
	DD	imagerel to_complex+272
	DD	imagerel $unwind$to_complex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$to_complex DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\complexobject.c
xdata	ENDS
;	COMDAT to_complex
_TEXT	SEGMENT
pobj$ = 64
pc$ = 72
to_complex PROC						; COMDAT

; 414  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 415  :     PyObject *obj = *pobj;

  0000f	48 8b 31	 mov	 rsi, QWORD PTR [rcx]

; 416  : 
; 417  :     pc->real = pc->imag = 0.0;

  00012	48 c7 42 08 00
	00 00 00	 mov	 QWORD PTR [rdx+8], 0
  0001a	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0
  00021	48 8b f9	 mov	 rdi, rcx

; 418  :     if (PyLong_Check(obj)) {

  00024	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  00028	48 8b da	 mov	 rbx, rdx
  0002b	f7 81 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rcx+256], 16777216 ; 01000000H
  00035	74 48		 je	 SHORT $LN4@to_complex

; 419  :         pc->real = PyLong_AsDouble(obj);

  00037	48 8b ce	 mov	 rcx, rsi
  0003a	e8 00 00 00 00	 call	 PyLong_AsDouble

; 420  :         if (pc->real == -1.0 && PyErr_Occurred()) {

  0003f	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00047	f2 0f 11 03	 movsdx	 QWORD PTR [rbx], xmm0
  0004b	0f 8a ad 00 00
	00		 jp	 $LN3@to_complex
  00051	0f 85 a7 00 00
	00		 jne	 $LN3@to_complex
  00057	e8 00 00 00 00	 call	 PyErr_Occurred
  0005c	48 85 c0	 test	 rax, rax
  0005f	0f 84 99 00 00
	00		 je	 $LN3@to_complex

; 421  :             *pobj = NULL;

  00065	48 c7 07 00 00
	00 00		 mov	 QWORD PTR [rdi], 0

; 422  :             return -1;

  0006c	83 c8 ff	 or	 eax, -1

; 433  : }

  0006f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00074	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00079	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007d	5f		 pop	 rdi
  0007e	c3		 ret	 0
$LN4@to_complex:

; 423  :         }
; 424  :         return 0;
; 425  :     }
; 426  :     if (PyFloat_Check(obj)) {

  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00086	48 3b ca	 cmp	 rcx, rdx
  00089	74 67		 je	 SHORT $LN1@to_complex
  0008b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00090	85 c0		 test	 eax, eax
  00092	75 5e		 jne	 SHORT $LN1@to_complex

; 428  :         return 0;
; 429  :     }
; 430  :     Py_INCREF(Py_NotImplemented);

  00094	e8 00 00 00 00	 call	 _Py_PXCTX
  00099	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NotImplementedStruct
  000a0	85 c0		 test	 eax, eax
  000a2	75 38		 jne	 SHORT $LN8@to_complex
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000b2	4c 8b cb	 mov	 r9, rbx
  000b5	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000bb	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000c3	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c8	85 c0		 test	 eax, eax
  000ca	75 09		 jne	 SHORT $LN7@to_complex
  000cc	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  000d3	74 07		 je	 SHORT $LN8@to_complex
$LN7@to_complex:
  000d5	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN8@to_complex:

; 431  :     *pobj = Py_NotImplemented;

  000dc	48 89 1f	 mov	 QWORD PTR [rdi], rbx

; 432  :     return -1;

  000df	83 c8 ff	 or	 eax, -1

; 433  : }

  000e2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e7	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000ec	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f0	5f		 pop	 rdi
  000f1	c3		 ret	 0
$LN1@to_complex:

; 427  :         pc->real = PyFloat_AsDouble(obj);

  000f2	48 8b ce	 mov	 rcx, rsi
  000f5	e8 00 00 00 00	 call	 PyFloat_AsDouble
  000fa	f2 0f 11 03	 movsdx	 QWORD PTR [rbx], xmm0
$LN3@to_complex:

; 433  : }

  000fe	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00103	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00108	33 c0		 xor	 eax, eax
  0010a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010e	5f		 pop	 rdi
  0010f	c3		 ret	 0
to_complex ENDP
_TEXT	ENDS
PUBLIC	$T21610
PUBLIC	$T21608
PUBLIC	$T21609
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_add DD imagerel complex_add
	DD	imagerel complex_add+234
	DD	imagerel $unwind$complex_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_add DD 082501H
	DD	056825H
	DD	0116419H
	DD	0103419H
	DD	07015b219H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT complex_add
_TEXT	SEGMENT
$T21609 = 32
b$ = 32
a$ = 32
$T21610 = 48
$T21608 = 48
$T21607 = 64
v$ = 112
w$ = 120
complex_add PROC					; COMDAT

; 438  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 439  :     Py_complex result;
; 440  :     Py_complex a, b;
; 441  :     TO_COMPLEX(v, a);

  00019	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyComplex_Type
  00020	0f 29 74 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm6
  00025	48 8b da	 mov	 rbx, rdx
  00028	48 8b f9	 mov	 rdi, rcx
  0002b	48 39 71 58	 cmp	 QWORD PTR [rcx+88], rsi
  0002f	74 31		 je	 SHORT $LN7@complex_ad
  00031	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00035	48 8b d6	 mov	 rdx, rsi
  00038	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003d	85 c0		 test	 eax, eax
  0003f	75 21		 jne	 SHORT $LN7@complex_ad
  00041	48 8d 54 24 20	 lea	 rdx, QWORD PTR a$[rsp]
  00046	48 8d 4c 24 70	 lea	 rcx, QWORD PTR v$[rsp]
  0004b	e8 00 00 00 00	 call	 to_complex
  00050	85 c0		 test	 eax, eax
  00052	79 07		 jns	 SHORT $LN11@complex_ad
  00054	48 8b 44 24 70	 mov	 rax, QWORD PTR v$[rsp]
  00059	eb 78		 jmp	 SHORT $LN9@complex_ad
$LN11@complex_ad:
  0005b	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR a$[rsp]
  00060	eb 04		 jmp	 SHORT $LN5@complex_ad
$LN7@complex_ad:
  00062	0f 10 77 60	 movups	 xmm6, XMMWORD PTR [rdi+96]
$LN5@complex_ad:

; 442  :     TO_COMPLEX(w, b);

  00066	48 39 73 58	 cmp	 QWORD PTR [rbx+88], rsi
  0006a	74 31		 je	 SHORT $LN3@complex_ad
  0006c	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00070	48 8b d6	 mov	 rdx, rsi
  00073	e8 00 00 00 00	 call	 PyType_IsSubtype
  00078	85 c0		 test	 eax, eax
  0007a	75 21		 jne	 SHORT $LN3@complex_ad
  0007c	48 8d 54 24 20	 lea	 rdx, QWORD PTR b$[rsp]
  00081	48 8d 4c 24 78	 lea	 rcx, QWORD PTR w$[rsp]
  00086	e8 00 00 00 00	 call	 to_complex
  0008b	85 c0		 test	 eax, eax
  0008d	79 07		 jns	 SHORT $LN12@complex_ad
  0008f	48 8b 44 24 78	 mov	 rax, QWORD PTR w$[rsp]
  00094	eb 3d		 jmp	 SHORT $LN9@complex_ad
$LN12@complex_ad:
  00096	0f 28 44 24 20	 movaps	 xmm0, XMMWORD PTR b$[rsp]
  0009b	eb 04		 jmp	 SHORT $LN1@complex_ad
$LN3@complex_ad:
  0009d	0f 10 43 60	 movups	 xmm0, XMMWORD PTR [rbx+96]
$LN1@complex_ad:

; 443  :     PyFPE_START_PROTECT("complex_add", return 0)
; 444  :     result = c_sum(a, b);

  000a1	4c 8d 44 24 20	 lea	 r8, QWORD PTR $T21609[rsp]
  000a6	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T21608[rsp]
  000ab	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T21607[rsp]
  000b0	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR $T21609[rsp], xmm0
  000b6	66 0f 7f 74 24
	30		 movdqa	 XMMWORD PTR $T21608[rsp], xmm6
  000bc	e8 00 00 00 00	 call	 _Py_c_sum

; 445  :     PyFPE_END_PROTECT(result)
; 446  :     return PyComplex_FromCComplex(result);

  000c1	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T21610[rsp]
  000c6	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  000c9	0f 29 44 24 30	 movaps	 XMMWORD PTR $T21610[rsp], xmm0
  000ce	e8 00 00 00 00	 call	 PyComplex_FromCComplex
$LN9@complex_ad:

; 447  : }

  000d3	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  000d8	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  000dd	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  000e1	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  000e5	49 8b e3	 mov	 rsp, r11
  000e8	5f		 pop	 rdi
  000e9	c3		 ret	 0
complex_add ENDP
_TEXT	ENDS
PUBLIC	$T21628
PUBLIC	$T21626
PUBLIC	$T21627
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_sub DD imagerel complex_sub
	DD	imagerel complex_sub+234
	DD	imagerel $unwind$complex_sub
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_sub DD 082501H
	DD	056825H
	DD	0116419H
	DD	0103419H
	DD	07015b219H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT complex_sub
_TEXT	SEGMENT
$T21627 = 32
b$ = 32
a$ = 32
$T21628 = 48
$T21626 = 48
$T21625 = 64
v$ = 112
w$ = 120
complex_sub PROC					; COMDAT

; 451  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 452  :     Py_complex result;
; 453  :     Py_complex a, b;
; 454  :     TO_COMPLEX(v, a);

  00019	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyComplex_Type
  00020	0f 29 74 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm6
  00025	48 8b da	 mov	 rbx, rdx
  00028	48 8b f9	 mov	 rdi, rcx
  0002b	48 39 71 58	 cmp	 QWORD PTR [rcx+88], rsi
  0002f	74 31		 je	 SHORT $LN7@complex_su@2
  00031	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00035	48 8b d6	 mov	 rdx, rsi
  00038	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003d	85 c0		 test	 eax, eax
  0003f	75 21		 jne	 SHORT $LN7@complex_su@2
  00041	48 8d 54 24 20	 lea	 rdx, QWORD PTR a$[rsp]
  00046	48 8d 4c 24 70	 lea	 rcx, QWORD PTR v$[rsp]
  0004b	e8 00 00 00 00	 call	 to_complex
  00050	85 c0		 test	 eax, eax
  00052	79 07		 jns	 SHORT $LN11@complex_su@2
  00054	48 8b 44 24 70	 mov	 rax, QWORD PTR v$[rsp]
  00059	eb 78		 jmp	 SHORT $LN9@complex_su@2
$LN11@complex_su@2:
  0005b	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR a$[rsp]
  00060	eb 04		 jmp	 SHORT $LN5@complex_su@2
$LN7@complex_su@2:
  00062	0f 10 77 60	 movups	 xmm6, XMMWORD PTR [rdi+96]
$LN5@complex_su@2:

; 455  :     TO_COMPLEX(w, b);

  00066	48 39 73 58	 cmp	 QWORD PTR [rbx+88], rsi
  0006a	74 31		 je	 SHORT $LN3@complex_su@2
  0006c	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00070	48 8b d6	 mov	 rdx, rsi
  00073	e8 00 00 00 00	 call	 PyType_IsSubtype
  00078	85 c0		 test	 eax, eax
  0007a	75 21		 jne	 SHORT $LN3@complex_su@2
  0007c	48 8d 54 24 20	 lea	 rdx, QWORD PTR b$[rsp]
  00081	48 8d 4c 24 78	 lea	 rcx, QWORD PTR w$[rsp]
  00086	e8 00 00 00 00	 call	 to_complex
  0008b	85 c0		 test	 eax, eax
  0008d	79 07		 jns	 SHORT $LN12@complex_su@2
  0008f	48 8b 44 24 78	 mov	 rax, QWORD PTR w$[rsp]
  00094	eb 3d		 jmp	 SHORT $LN9@complex_su@2
$LN12@complex_su@2:
  00096	0f 28 44 24 20	 movaps	 xmm0, XMMWORD PTR b$[rsp]
  0009b	eb 04		 jmp	 SHORT $LN1@complex_su@2
$LN3@complex_su@2:
  0009d	0f 10 43 60	 movups	 xmm0, XMMWORD PTR [rbx+96]
$LN1@complex_su@2:

; 456  :     PyFPE_START_PROTECT("complex_sub", return 0)
; 457  :     result = c_diff(a, b);

  000a1	4c 8d 44 24 20	 lea	 r8, QWORD PTR $T21627[rsp]
  000a6	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T21626[rsp]
  000ab	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T21625[rsp]
  000b0	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR $T21627[rsp], xmm0
  000b6	66 0f 7f 74 24
	30		 movdqa	 XMMWORD PTR $T21626[rsp], xmm6
  000bc	e8 00 00 00 00	 call	 _Py_c_diff

; 458  :     PyFPE_END_PROTECT(result)
; 459  :     return PyComplex_FromCComplex(result);

  000c1	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T21628[rsp]
  000c6	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  000c9	0f 29 44 24 30	 movaps	 XMMWORD PTR $T21628[rsp], xmm0
  000ce	e8 00 00 00 00	 call	 PyComplex_FromCComplex
$LN9@complex_su@2:

; 460  : }

  000d3	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  000d8	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  000dd	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  000e1	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  000e5	49 8b e3	 mov	 rsp, r11
  000e8	5f		 pop	 rdi
  000e9	c3		 ret	 0
complex_sub ENDP
_TEXT	ENDS
PUBLIC	$T21646
PUBLIC	$T21644
PUBLIC	$T21645
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_mul DD imagerel complex_mul
	DD	imagerel complex_mul+234
	DD	imagerel $unwind$complex_mul
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_mul DD 082501H
	DD	056825H
	DD	0116419H
	DD	0103419H
	DD	07015b219H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT complex_mul
_TEXT	SEGMENT
$T21645 = 32
b$ = 32
a$ = 32
$T21646 = 48
$T21644 = 48
$T21643 = 64
v$ = 112
w$ = 120
complex_mul PROC					; COMDAT

; 464  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 465  :     Py_complex result;
; 466  :     Py_complex a, b;
; 467  :     TO_COMPLEX(v, a);

  00019	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyComplex_Type
  00020	0f 29 74 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm6
  00025	48 8b da	 mov	 rbx, rdx
  00028	48 8b f9	 mov	 rdi, rcx
  0002b	48 39 71 58	 cmp	 QWORD PTR [rcx+88], rsi
  0002f	74 31		 je	 SHORT $LN7@complex_mu
  00031	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00035	48 8b d6	 mov	 rdx, rsi
  00038	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003d	85 c0		 test	 eax, eax
  0003f	75 21		 jne	 SHORT $LN7@complex_mu
  00041	48 8d 54 24 20	 lea	 rdx, QWORD PTR a$[rsp]
  00046	48 8d 4c 24 70	 lea	 rcx, QWORD PTR v$[rsp]
  0004b	e8 00 00 00 00	 call	 to_complex
  00050	85 c0		 test	 eax, eax
  00052	79 07		 jns	 SHORT $LN11@complex_mu
  00054	48 8b 44 24 70	 mov	 rax, QWORD PTR v$[rsp]
  00059	eb 78		 jmp	 SHORT $LN9@complex_mu
$LN11@complex_mu:
  0005b	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR a$[rsp]
  00060	eb 04		 jmp	 SHORT $LN5@complex_mu
$LN7@complex_mu:
  00062	0f 10 77 60	 movups	 xmm6, XMMWORD PTR [rdi+96]
$LN5@complex_mu:

; 468  :     TO_COMPLEX(w, b);

  00066	48 39 73 58	 cmp	 QWORD PTR [rbx+88], rsi
  0006a	74 31		 je	 SHORT $LN3@complex_mu
  0006c	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00070	48 8b d6	 mov	 rdx, rsi
  00073	e8 00 00 00 00	 call	 PyType_IsSubtype
  00078	85 c0		 test	 eax, eax
  0007a	75 21		 jne	 SHORT $LN3@complex_mu
  0007c	48 8d 54 24 20	 lea	 rdx, QWORD PTR b$[rsp]
  00081	48 8d 4c 24 78	 lea	 rcx, QWORD PTR w$[rsp]
  00086	e8 00 00 00 00	 call	 to_complex
  0008b	85 c0		 test	 eax, eax
  0008d	79 07		 jns	 SHORT $LN12@complex_mu
  0008f	48 8b 44 24 78	 mov	 rax, QWORD PTR w$[rsp]
  00094	eb 3d		 jmp	 SHORT $LN9@complex_mu
$LN12@complex_mu:
  00096	0f 28 44 24 20	 movaps	 xmm0, XMMWORD PTR b$[rsp]
  0009b	eb 04		 jmp	 SHORT $LN1@complex_mu
$LN3@complex_mu:
  0009d	0f 10 43 60	 movups	 xmm0, XMMWORD PTR [rbx+96]
$LN1@complex_mu:

; 469  :     PyFPE_START_PROTECT("complex_mul", return 0)
; 470  :     result = c_prod(a, b);

  000a1	4c 8d 44 24 20	 lea	 r8, QWORD PTR $T21645[rsp]
  000a6	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T21644[rsp]
  000ab	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T21643[rsp]
  000b0	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR $T21645[rsp], xmm0
  000b6	66 0f 7f 74 24
	30		 movdqa	 XMMWORD PTR $T21644[rsp], xmm6
  000bc	e8 00 00 00 00	 call	 _Py_c_prod

; 471  :     PyFPE_END_PROTECT(result)
; 472  :     return PyComplex_FromCComplex(result);

  000c1	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T21646[rsp]
  000c6	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  000c9	0f 29 44 24 30	 movaps	 XMMWORD PTR $T21646[rsp], xmm0
  000ce	e8 00 00 00 00	 call	 PyComplex_FromCComplex
$LN9@complex_mu:

; 473  : }

  000d3	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  000d8	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  000dd	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  000e1	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  000e5	49 8b e3	 mov	 rsp, r11
  000e8	5f		 pop	 rdi
  000e9	c3		 ret	 0
complex_mul ENDP
_TEXT	ENDS
PUBLIC	$T21664
PUBLIC	??_C@_0BJ@CAAPCGAK@complex?5division?5by?5zero?$AA@ ; `string'
PUBLIC	$T21662
PUBLIC	$T21663
EXTRN	PyExc_ZeroDivisionError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_div DD imagerel complex_div
	DD	imagerel complex_div+111
	DD	imagerel $unwind$complex_div
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$complex_div DD imagerel complex_div+111
	DD	imagerel complex_div+283
	DD	imagerel $chain$0$complex_div
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$complex_div DD imagerel complex_div+283
	DD	imagerel complex_div+306
	DD	imagerel $chain$1$complex_div
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$complex_div DD 021H
	DD	imagerel complex_div
	DD	imagerel complex_div+111
	DD	imagerel $unwind$complex_div
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$complex_div DD 020521H
	DD	066805H
	DD	imagerel complex_div
	DD	imagerel complex_div+111
	DD	imagerel $unwind$complex_div
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_div DD 082501H
	DD	057825H
	DD	0136419H
	DD	0123419H
	DD	07015d219H
xdata	ENDS
;	COMDAT ??_C@_0BJ@CAAPCGAK@complex?5division?5by?5zero?$AA@
CONST	SEGMENT
??_C@_0BJ@CAAPCGAK@complex?5division?5by?5zero?$AA@ DB 'complex division '
	DB	'by zero', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT complex_div
_TEXT	SEGMENT
$T21663 = 32
b$ = 32
a$ = 32
$T21664 = 48
$T21662 = 48
$T21661 = 64
v$ = 128
w$ = 136
complex_div PROC					; COMDAT

; 477  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 478  :     Py_complex quot;
; 479  :     Py_complex a, b;
; 480  :     TO_COMPLEX(v, a);

  00019	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyComplex_Type
  00020	0f 29 7c 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm7
  00025	48 8b da	 mov	 rbx, rdx
  00028	48 8b f9	 mov	 rdi, rcx
  0002b	48 39 71 58	 cmp	 QWORD PTR [rcx+88], rsi
  0002f	74 3a		 je	 SHORT $LN8@complex_di
  00031	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00035	48 8b d6	 mov	 rdx, rsi
  00038	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003d	85 c0		 test	 eax, eax
  0003f	75 2a		 jne	 SHORT $LN8@complex_di
  00041	48 8d 54 24 20	 lea	 rdx, QWORD PTR a$[rsp]
  00046	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR v$[rsp]
  0004e	e8 00 00 00 00	 call	 to_complex
  00053	85 c0		 test	 eax, eax
  00055	79 0d		 jns	 SHORT $LN12@complex_di
  00057	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  0005f	e9 b7 00 00 00	 jmp	 $LN10@complex_di
$LN12@complex_di:
  00064	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR a$[rsp]
  00069	eb 04		 jmp	 SHORT $LN6@complex_di
$LN8@complex_di:
  0006b	0f 10 7f 60	 movups	 xmm7, XMMWORD PTR [rdi+96]
$LN6@complex_di:
  0006f	0f 29 74 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm6

; 481  :     TO_COMPLEX(w, b);

  00074	48 39 73 58	 cmp	 QWORD PTR [rbx+88], rsi
  00078	74 37		 je	 SHORT $LN4@complex_di
  0007a	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  0007e	48 8b d6	 mov	 rdx, rsi
  00081	e8 00 00 00 00	 call	 PyType_IsSubtype
  00086	85 c0		 test	 eax, eax
  00088	75 27		 jne	 SHORT $LN4@complex_di
  0008a	48 8d 54 24 20	 lea	 rdx, QWORD PTR b$[rsp]
  0008f	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR w$[rsp]
  00097	e8 00 00 00 00	 call	 to_complex
  0009c	85 c0		 test	 eax, eax
  0009e	79 0a		 jns	 SHORT $LN13@complex_di
  000a0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  000a8	eb 6c		 jmp	 SHORT $LN14@complex_di
$LN13@complex_di:
  000aa	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR b$[rsp]
  000af	eb 04		 jmp	 SHORT $LN2@complex_di
$LN4@complex_di:
  000b1	0f 10 73 60	 movups	 xmm6, XMMWORD PTR [rbx+96]
$LN2@complex_di:

; 482  :     PyFPE_START_PROTECT("complex_div", return 0)
; 483  :     errno = 0;

  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 484  :     quot = c_quot(a, b);

  000bb	4c 8d 44 24 20	 lea	 r8, QWORD PTR $T21663[rsp]
  000c0	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T21662[rsp]
  000c5	66 0f 7f 74 24
	20		 movdqa	 XMMWORD PTR $T21663[rsp], xmm6
  000cb	66 0f 7f 7c 24
	30		 movdqa	 XMMWORD PTR $T21662[rsp], xmm7
  000d1	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T21661[rsp]
  000d6	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  000dc	e8 00 00 00 00	 call	 _Py_c_quot
  000e1	0f 10 30	 movups	 xmm6, XMMWORD PTR [rax]

; 485  :     PyFPE_END_PROTECT(quot)
; 486  :     if (errno == EDOM) {

  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ea	83 38 21	 cmp	 DWORD PTR [rax], 33	; 00000021H
  000ed	75 17		 jne	 SHORT $LN1@complex_di

; 487  :         PyErr_SetString(PyExc_ZeroDivisionError, "complex division by zero");

  000ef	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ZeroDivisionError
  000f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@CAAPCGAK@complex?5division?5by?5zero?$AA@
  000fd	e8 00 00 00 00	 call	 PyErr_SetString

; 488  :         return NULL;

  00102	33 c0		 xor	 eax, eax
  00104	eb 10		 jmp	 SHORT $LN14@complex_di
$LN1@complex_di:

; 489  :     }
; 490  :     return PyComplex_FromCComplex(quot);

  00106	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T21664[rsp]
  0010b	66 0f 7f 74 24
	30		 movdqa	 XMMWORD PTR $T21664[rsp], xmm6
  00111	e8 00 00 00 00	 call	 PyComplex_FromCComplex
$LN14@complex_di:
  00116	0f 28 74 24 60	 movaps	 xmm6, XMMWORD PTR [rsp+96]
$LN10@complex_di:

; 491  : }

  0011b	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
  00120	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  00125	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  00129	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  0012d	49 8b e3	 mov	 rsp, r11
  00130	5f		 pop	 rdi
  00131	c3		 ret	 0
complex_div ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@FAJMKFOP@can?8t?5mod?5complex?5numbers?4?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_remainder DD imagerel complex_remainder
	DD	imagerel complex_remainder+30
	DD	imagerel $unwind$complex_remainder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_remainder DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BL@FAJMKFOP@can?8t?5mod?5complex?5numbers?4?$AA@
CONST	SEGMENT
??_C@_0BL@FAJMKFOP@can?8t?5mod?5complex?5numbers?4?$AA@ DB 'can''t mod co'
	DB	'mplex numbers.', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT complex_remainder
_TEXT	SEGMENT
v$ = 48
w$ = 56
complex_remainder PROC					; COMDAT

; 495  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 496  :     PyErr_SetString(PyExc_TypeError,
; 497  :                     "can't mod complex numbers.");

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@FAJMKFOP@can?8t?5mod?5complex?5numbers?4?$AA@
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 498  :     return NULL;

  00017	33 c0		 xor	 eax, eax

; 499  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
complex_remainder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@LMFBJNLG@can?8t?5take?5floor?5or?5mod?5of?5compl@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_divmod DD imagerel complex_divmod
	DD	imagerel complex_divmod+30
	DD	imagerel $unwind$complex_divmod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_divmod DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CL@LMFBJNLG@can?8t?5take?5floor?5or?5mod?5of?5compl@
CONST	SEGMENT
??_C@_0CL@LMFBJNLG@can?8t?5take?5floor?5or?5mod?5of?5compl@ DB 'can''t ta'
	DB	'ke floor or mod of complex number.', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT complex_divmod
_TEXT	SEGMENT
v$ = 48
w$ = 56
complex_divmod PROC					; COMDAT

; 504  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 505  :     PyErr_SetString(PyExc_TypeError,
; 506  :                     "can't take floor or mod of complex number.");

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@LMFBJNLG@can?8t?5take?5floor?5or?5mod?5of?5compl@
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 507  :     return NULL;

  00017	33 c0		 xor	 eax, eax

; 508  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
complex_divmod ENDP
_TEXT	ENDS
PUBLIC	$T21710
PUBLIC	??_C@_0BH@JFGOLFJP@complex?5exponentiation?$AA@	; `string'
PUBLIC	??_C@_0CD@FLGLCEEA@0?40?5to?5a?5negative?5or?5complex?5pow@ ; `string'
PUBLIC	$T21708
PUBLIC	$T21709
PUBLIC	$T21707
PUBLIC	??_C@_0P@JDIGEPHM@complex?5modulo?$AA@		; `string'
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyExc_ValueError:QWORD
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_pow DD imagerel complex_pow
	DD	imagerel complex_pow+110
	DD	imagerel $unwind$complex_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$complex_pow DD imagerel complex_pow+110
	DD	imagerel complex_pow+518
	DD	imagerel $chain$0$complex_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$complex_pow DD imagerel complex_pow+518
	DD	imagerel complex_pow+544
	DD	imagerel $chain$1$complex_pow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$complex_pow DD 021H
	DD	imagerel complex_pow
	DD	imagerel complex_pow+110
	DD	imagerel $unwind$complex_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$complex_pow DD 020521H
	DD	066805H
	DD	imagerel complex_pow
	DD	imagerel complex_pow+110
	DD	imagerel $unwind$complex_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_pow DD 0a2b01H
	DD	05782bH
	DD	015641fH
	DD	014341fH
	DD	0c018d21fH
	DD	050157016H
xdata	ENDS
;	COMDAT ??_C@_0BH@JFGOLFJP@complex?5exponentiation?$AA@
CONST	SEGMENT
??_C@_0BH@JFGOLFJP@complex?5exponentiation?$AA@ DB 'complex exponentiatio'
	DB	'n', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FLGLCEEA@0?40?5to?5a?5negative?5or?5complex?5pow@
CONST	SEGMENT
??_C@_0CD@FLGLCEEA@0?40?5to?5a?5negative?5or?5complex?5pow@ DB '0.0 to a '
	DB	'negative or complex power', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JDIGEPHM@complex?5modulo?$AA@
CONST	SEGMENT
??_C@_0P@JDIGEPHM@complex?5modulo?$AA@ DB 'complex modulo', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT complex_pow
_TEXT	SEGMENT
$T21709 = 32
$T21707 = 32
p$ = 32
b$ = 32
a$ = 32
$T21710 = 48
$T21708 = 48
$T21705 = 48
$T21706 = 64
v$ = 144
w$ = 152
z$ = 160
complex_pow PROC					; COMDAT

; 512  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	41 54		 push	 r12
  00018	48 8b ec	 mov	 rbp, rsp
  0001b	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 513  :     Py_complex p;
; 514  :     Py_complex exponent;
; 515  :     long int_exponent;
; 516  :     Py_complex a, b;
; 517  :     TO_COMPLEX(v, a);

  0001f	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:PyComplex_Type
  00026	0f 29 7c 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm7
  0002b	49 8b f0	 mov	 rsi, r8
  0002e	48 8b da	 mov	 rbx, rdx
  00031	48 8b f9	 mov	 rdi, rcx
  00034	4c 39 61 58	 cmp	 QWORD PTR [rcx+88], r12
  00038	74 30		 je	 SHORT $LN21@complex_po
  0003a	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0003e	49 8b d4	 mov	 rdx, r12
  00041	e8 00 00 00 00	 call	 PyType_IsSubtype
  00046	85 c0		 test	 eax, eax
  00048	75 20		 jne	 SHORT $LN21@complex_po
  0004a	48 8d 55 b0	 lea	 rdx, QWORD PTR a$[rbp-112]
  0004e	48 8d 4d 20	 lea	 rcx, QWORD PTR v$[rbp-112]
  00052	e8 00 00 00 00	 call	 to_complex
  00057	85 c0		 test	 eax, eax
  00059	79 09		 jns	 SHORT $LN29@complex_po
  0005b	48 8b 45 20	 mov	 rax, QWORD PTR v$[rbp-112]
  0005f	e9 a2 01 00 00	 jmp	 $LN23@complex_po
$LN29@complex_po:
  00064	0f 28 7d b0	 movaps	 xmm7, XMMWORD PTR a$[rbp-112]
  00068	eb 04		 jmp	 SHORT $LN19@complex_po
$LN21@complex_po:
  0006a	0f 10 7f 60	 movups	 xmm7, XMMWORD PTR [rdi+96]
$LN19@complex_po:
  0006e	0f 29 74 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm6

; 518  :     TO_COMPLEX(w, b);

  00073	4c 39 63 58	 cmp	 QWORD PTR [rbx+88], r12
  00077	74 30		 je	 SHORT $LN17@complex_po
  00079	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  0007d	49 8b d4	 mov	 rdx, r12
  00080	e8 00 00 00 00	 call	 PyType_IsSubtype
  00085	85 c0		 test	 eax, eax
  00087	75 20		 jne	 SHORT $LN17@complex_po
  00089	48 8d 55 b0	 lea	 rdx, QWORD PTR b$[rbp-112]
  0008d	48 8d 4d 28	 lea	 rcx, QWORD PTR w$[rbp-112]
  00091	e8 00 00 00 00	 call	 to_complex
  00096	85 c0		 test	 eax, eax
  00098	79 09		 jns	 SHORT $LN30@complex_po
  0009a	48 8b 45 28	 mov	 rax, QWORD PTR w$[rbp-112]
  0009e	e9 5e 01 00 00	 jmp	 $LN31@complex_po
$LN30@complex_po:
  000a3	0f 28 75 b0	 movaps	 xmm6, XMMWORD PTR b$[rbp-112]
  000a7	eb 08		 jmp	 SHORT $LN15@complex_po
$LN17@complex_po:
  000a9	0f 10 73 60	 movups	 xmm6, XMMWORD PTR [rbx+96]
  000ad	0f 29 75 b0	 movaps	 XMMWORD PTR b$[rbp-112], xmm6
$LN15@complex_po:

; 519  : 
; 520  :     if (z != Py_None) {

  000b1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000b8	48 3b f0	 cmp	 rsi, rax
  000bb	74 1a		 je	 SHORT $LN14@complex_po

; 521  :         PyErr_SetString(PyExc_ValueError, "complex modulo");

  000bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@JDIGEPHM@complex?5modulo?$AA@
  000cb	e8 00 00 00 00	 call	 PyErr_SetString

; 522  :         return NULL;

  000d0	33 c0		 xor	 eax, eax
  000d2	e9 2a 01 00 00	 jmp	 $LN31@complex_po
$LN14@complex_po:

; 523  :     }
; 524  :     PyFPE_START_PROTECT("complex_pow", return 0)
; 525  :     errno = 0;

  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 526  :     exponent = b;
; 527  :     int_exponent = (long)exponent.real;
; 528  :     if (exponent.imag == 0. && exponent.real == int_exponent)

  000dd	f2 0f 10 45 b8	 movsdx	 xmm0, QWORD PTR b$[rbp-104]
  000e2	f2 0f 10 4d b0	 movsdx	 xmm1, QWORD PTR b$[rbp-112]
  000e7	33 db		 xor	 ebx, ebx
  000e9	89 18		 mov	 DWORD PTR [rax], ebx
  000eb	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  000f3	f2 44 0f 2c c1	 cvttsd2si r8d, xmm1
  000f8	7a 27		 jp	 SHORT $LN13@complex_po
  000fa	75 25		 jne	 SHORT $LN13@complex_po
  000fc	66 41 0f 6e c0	 movd	 xmm0, r8d
  00101	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00105	66 0f 2e c8	 ucomisd xmm1, xmm0
  00109	7a 16		 jp	 SHORT $LN13@complex_po
  0010b	75 14		 jne	 SHORT $LN13@complex_po

; 529  :         p = c_powi(a, int_exponent);

  0010d	48 8d 55 b0	 lea	 rdx, QWORD PTR $T21707[rbp-112]
  00111	48 8d 4d c0	 lea	 rcx, QWORD PTR $T21705[rbp-112]
  00115	66 0f 7f 7d b0	 movdqa	 XMMWORD PTR $T21707[rbp-112], xmm7
  0011a	e8 00 00 00 00	 call	 c_powi

; 530  :     else

  0011f	eb 1b		 jmp	 SHORT $LN32@complex_po
$LN13@complex_po:

; 531  :         p = c_pow(a, exponent);

  00121	4c 8d 45 b0	 lea	 r8, QWORD PTR $T21709[rbp-112]
  00125	48 8d 55 c0	 lea	 rdx, QWORD PTR $T21708[rbp-112]
  00129	48 8d 4d d0	 lea	 rcx, QWORD PTR $T21706[rbp-112]
  0012d	66 0f 7f 75 b0	 movdqa	 XMMWORD PTR $T21709[rbp-112], xmm6
  00132	66 0f 7f 7d c0	 movdqa	 XMMWORD PTR $T21708[rbp-112], xmm7
  00137	e8 00 00 00 00	 call	 _Py_c_pow
$LN32@complex_po:
  0013c	0f 10 30	 movups	 xmm6, XMMWORD PTR [rax]

; 532  : 
; 533  :     PyFPE_END_PROTECT(p)
; 534  :     Py_ADJUST_ERANGE2(p.real, p.imag);

  0013f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  00146	f2 0f 10 08	 movsdx	 xmm1, QWORD PTR [rax]
  0014a	0f 29 75 b0	 movaps	 XMMWORD PTR p$[rbp-112], xmm6
  0014e	f2 0f 10 55 b0	 movsdx	 xmm2, QWORD PTR p$[rbp-112]
  00153	66 0f 2e d1	 ucomisd xmm2, xmm1
  00157	7a 02		 jp	 SHORT $LN28@complex_po
  00159	74 29		 je	 SHORT $LN7@complex_po
$LN28@complex_po:
  0015b	66 0f 28 c1	 movapd	 xmm0, xmm1
  0015f	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00167	66 0f 2e d0	 ucomisd xmm2, xmm0
  0016b	7a 02		 jp	 SHORT $LN27@complex_po
  0016d	74 15		 je	 SHORT $LN7@complex_po
$LN27@complex_po:
  0016f	f2 0f 10 55 b8	 movsdx	 xmm2, QWORD PTR p$[rbp-104]
  00174	66 0f 2e d1	 ucomisd xmm2, xmm1
  00178	7a 02		 jp	 SHORT $LN26@complex_po
  0017a	74 08		 je	 SHORT $LN7@complex_po
$LN26@complex_po:
  0017c	66 0f 2e d0	 ucomisd xmm2, xmm0
  00180	7a 1a		 jp	 SHORT $LN25@complex_po
  00182	75 18		 jne	 SHORT $LN25@complex_po
$LN7@complex_po:
  00184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0018a	39 18		 cmp	 DWORD PTR [rax], ebx
  0018c	75 21		 jne	 SHORT $LN10@complex_po
  0018e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00194	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H
  0019a	eb 13		 jmp	 SHORT $LN10@complex_po
$LN25@complex_po:
  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001a2	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  001a5	75 08		 jne	 SHORT $LN10@complex_po
  001a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001ad	89 18		 mov	 DWORD PTR [rax], ebx
$LN10@complex_po:

; 535  :     if (errno == EDOM) {

  001af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001b5	83 38 21	 cmp	 DWORD PTR [rax], 33	; 00000021H
  001b8	75 17		 jne	 SHORT $LN3@complex_po

; 536  :         PyErr_SetString(PyExc_ZeroDivisionError,
; 537  :                         "0.0 to a negative or complex power");

  001ba	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ZeroDivisionError
  001c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@FLGLCEEA@0?40?5to?5a?5negative?5or?5complex?5pow@
  001c8	e8 00 00 00 00	 call	 PyErr_SetString

; 538  :         return NULL;

  001cd	33 c0		 xor	 eax, eax
  001cf	eb 30		 jmp	 SHORT $LN31@complex_po
$LN3@complex_po:

; 539  :     }
; 540  :     else if (errno == ERANGE) {

  001d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001d7	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  001da	75 17		 jne	 SHORT $LN1@complex_po

; 541  :         PyErr_SetString(PyExc_OverflowError,
; 542  :                         "complex exponentiation");

  001dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  001e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@JFGOLFJP@complex?5exponentiation?$AA@
  001ea	e8 00 00 00 00	 call	 PyErr_SetString

; 543  :         return NULL;

  001ef	33 c0		 xor	 eax, eax
  001f1	eb 0e		 jmp	 SHORT $LN31@complex_po
$LN1@complex_po:

; 544  :     }
; 545  :     return PyComplex_FromCComplex(p);

  001f3	48 8d 4d c0	 lea	 rcx, QWORD PTR $T21710[rbp-112]
  001f7	66 0f 7f 75 c0	 movdqa	 XMMWORD PTR $T21710[rbp-112], xmm6
  001fc	e8 00 00 00 00	 call	 PyComplex_FromCComplex
$LN31@complex_po:
  00201	0f 28 74 24 60	 movaps	 xmm6, XMMWORD PTR [rsp+96]
$LN23@complex_po:

; 546  : }

  00206	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
  0020b	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  00210	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  00214	49 8b 73 38	 mov	 rsi, QWORD PTR [r11+56]
  00218	49 8b e3	 mov	 rsp, r11
  0021b	41 5c		 pop	 r12
  0021d	5f		 pop	 rdi
  0021e	5d		 pop	 rbp
  0021f	c3		 ret	 0
complex_pow ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@GONAHFFA@can?8t?5take?5floor?5of?5complex?5numb@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_int_div DD imagerel complex_int_div
	DD	imagerel complex_int_div+30
	DD	imagerel $unwind$complex_int_div
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_int_div DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CE@GONAHFFA@can?8t?5take?5floor?5of?5complex?5numb@
CONST	SEGMENT
??_C@_0CE@GONAHFFA@can?8t?5take?5floor?5of?5complex?5numb@ DB 'can''t tak'
	DB	'e floor of complex number.', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT complex_int_div
_TEXT	SEGMENT
v$ = 48
w$ = 56
complex_int_div PROC					; COMDAT

; 550  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 551  :     PyErr_SetString(PyExc_TypeError,
; 552  :                     "can't take floor of complex number.");

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@GONAHFFA@can?8t?5take?5floor?5of?5complex?5numb@
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 553  :     return NULL;

  00017	33 c0		 xor	 eax, eax

; 554  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
complex_int_div ENDP
_TEXT	ENDS
PUBLIC	$T21752
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_neg DD imagerel complex_neg
	DD	imagerel complex_neg+68
	DD	imagerel $unwind$complex_neg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_neg DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT complex_neg
_TEXT	SEGMENT
$T21752 = 32
neg$ = 32
v$ = 64
complex_neg PROC					; COMDAT

; 558  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 559  :     Py_complex neg;
; 560  :     neg.real = -v->cval.real;

  00004	f2 0f 10 41 60	 movsdx	 xmm0, QWORD PTR [rcx+96]
  00009	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00011	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR neg$[rsp], xmm0

; 561  :     neg.imag = -v->cval.imag;

  00017	f2 0f 10 41 68	 movsdx	 xmm0, QWORD PTR [rcx+104]

; 562  :     return PyComplex_FromCComplex(neg);

  0001c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T21752[rsp]
  00021	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00029	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR neg$[rsp+8], xmm0
  0002f	0f 28 44 24 20	 movaps	 xmm0, XMMWORD PTR neg$[rsp]
  00034	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR $T21752[rsp], xmm0
  0003a	e8 00 00 00 00	 call	 PyComplex_FromCComplex

; 563  : }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
complex_neg ENDP
_TEXT	ENDS
PUBLIC	$T21764
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$complex_pos DD imagerel complex_pos
	DD	imagerel complex_pos+115
	DD	imagerel $unwind$complex_pos
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_pos DD 020601H
	DD	030027206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\complexobject.c
xdata	ENDS
;	COMDAT complex_pos
_TEXT	SEGMENT
$T21764 = 48
v$ = 80
complex_pos PROC					; COMDAT

; 567  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 568  :     if (PyComplex_CheckExact(v)) {

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyComplex_Type
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00014	75 44		 jne	 SHORT $LN2@complex_po@2

; 569  :         Py_INCREF(v);

  00016	e8 00 00 00 00	 call	 _Py_PXCTX
  0001b	85 c0		 test	 eax, eax
  0001d	75 32		 jne	 SHORT $LN6@complex_po@2
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0002d	4c 8b cb	 mov	 r9, rbx
  00030	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00036	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0003e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00043	85 c0		 test	 eax, eax
  00045	75 06		 jne	 SHORT $LN5@complex_po@2
  00047	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0004b	74 04		 je	 SHORT $LN6@complex_po@2
$LN5@complex_po@2:
  0004d	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@complex_po@2:

; 570  :         return (PyObject *)v;

  00051	48 8b c3	 mov	 rax, rbx

; 574  : }

  00054	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
$LN2@complex_po@2:

; 571  :     }
; 572  :     else
; 573  :         return PyComplex_FromCComplex(v->cval);

  0005a	0f 10 41 60	 movups	 xmm0, XMMWORD PTR [rcx+96]
  0005e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T21764[rsp]
  00063	0f 29 44 24 30	 movaps	 XMMWORD PTR $T21764[rsp], xmm0
  00068	e8 00 00 00 00	 call	 PyComplex_FromCComplex

; 574  : }

  0006d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00071	5b		 pop	 rbx
  00072	c3		 ret	 0
complex_pos ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@OOMGPMGG@absolute?5value?5too?5large?$AA@ ; `string'
PUBLIC	$T21780
EXTRN	PyFloat_FromDouble:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_abs DD imagerel complex_abs
	DD	imagerel complex_abs+92
	DD	imagerel $unwind$complex_abs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_abs DD 031201H
	DD	036812H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_0BJ@OOMGPMGG@absolute?5value?5too?5large?$AA@
CONST	SEGMENT
??_C@_0BJ@OOMGPMGG@absolute?5value?5too?5large?$AA@ DB 'absolute value to'
	DB	'o large', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT complex_abs
_TEXT	SEGMENT
$T21780 = 32
v$ = 80
complex_abs PROC					; COMDAT

; 578  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 579  :     double result;
; 580  : 
; 581  :     PyFPE_START_PROTECT("complex_abs", return 0)
; 582  :     result = c_abs(v->cval);

  00004	0f 10 41 60	 movups	 xmm0, XMMWORD PTR [rcx+96]
  00008	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T21780[rsp]
  0000d	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6
  00012	0f 29 44 24 20	 movaps	 XMMWORD PTR $T21780[rsp], xmm0
  00017	e8 00 00 00 00	 call	 _Py_c_abs
  0001c	66 0f 28 f0	 movapd	 xmm6, xmm0

; 583  :     PyFPE_END_PROTECT(result)
; 584  : 
; 585  :     if (errno == ERANGE) {

  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00026	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  00029	75 1f		 jne	 SHORT $LN1@complex_ab

; 586  :         PyErr_SetString(PyExc_OverflowError,
; 587  :                         "absolute value too large");

  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@OOMGPMGG@absolute?5value?5too?5large?$AA@
  00039	e8 00 00 00 00	 call	 PyErr_SetString

; 588  :         return NULL;

  0003e	33 c0		 xor	 eax, eax

; 591  : }

  00040	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  00045	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00049	c3		 ret	 0
$LN1@complex_ab:

; 589  :     }
; 590  :     return PyFloat_FromDouble(result);

  0004a	66 0f 28 c6	 movapd	 xmm0, xmm6

; 591  : }

  0004e	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  00053	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00057	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
complex_abs ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT complex_bool
_TEXT	SEGMENT
v$ = 8
complex_bool PROC					; COMDAT

; 596  :     return v->cval.real != 0.0 || v->cval.imag != 0.0;

  00000	f2 0f 10 41 60	 movsdx	 xmm0, QWORD PTR [rcx+96]
  00005	66 0f 57 c9	 xorpd	 xmm1, xmm1
  00009	66 0f 2e c1	 ucomisd xmm0, xmm1
  0000d	7a 12		 jp	 SHORT $LN3@complex_bo
  0000f	75 10		 jne	 SHORT $LN3@complex_bo
  00011	f2 0f 10 41 68	 movsdx	 xmm0, QWORD PTR [rcx+104]
  00016	66 0f 2e c1	 ucomisd xmm0, xmm1
  0001a	7a 05		 jp	 SHORT $LN3@complex_bo
  0001c	75 03		 jne	 SHORT $LN3@complex_bo
  0001e	33 c0		 xor	 eax, eax

; 597  : }

  00020	c3		 ret	 0
$LN3@complex_bo:

; 596  :     return v->cval.real != 0.0 || v->cval.imag != 0.0;

  00021	b8 01 00 00 00	 mov	 eax, 1

; 597  : }

  00026	c3		 ret	 0
complex_bool ENDP
_TEXT	ENDS
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_Py_FalseStruct:BYTE
EXTRN	PyObject_RichCompare:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$complex_richcompare DD imagerel complex_richcompare
	DD	imagerel complex_richcompare+652
	DD	imagerel $unwind$complex_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_richcompare DD 061601H
	DD	0103416H
	DD	070129216H
	DD	050106011H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\complexobject.c
xdata	ENDS
;	COMDAT complex_richcompare
_TEXT	SEGMENT
i$ = 48
j$20699 = 64
v$ = 112
w$ = 120
op$ = 128
complex_richcompare PROC				; COMDAT

; 601  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00016	41 8b f0	 mov	 esi, r8d
  00019	48 8b da	 mov	 rbx, rdx
  0001c	48 8b f9	 mov	 rdi, rcx

; 602  :     PyObject *res;
; 603  :     Py_complex i;
; 604  :     int equal;
; 605  : 
; 606  :     if (op != Py_EQ && op != Py_NE) {

  0001f	41 83 f8 02	 cmp	 r8d, 2
  00023	74 0a		 je	 SHORT $LN22@complex_ri
  00025	41 83 f8 03	 cmp	 r8d, 3
  00029	0f 85 fb 00 00
	00		 jne	 $Unimplemented$20670
$LN22@complex_ri:

; 607  :         goto Unimplemented;
; 608  :     }
; 609  : 
; 610  :     assert(PyComplex_Check(v));
; 611  :     TO_COMPLEX(v, i);

  0002f	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PyComplex_Type
  00036	48 39 69 58	 cmp	 QWORD PTR [rcx+88], rbp
  0003a	74 38		 je	 SHORT $LN20@complex_ri
  0003c	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00040	48 8b d5	 mov	 rdx, rbp
  00043	e8 00 00 00 00	 call	 PyType_IsSubtype
  00048	85 c0		 test	 eax, eax
  0004a	75 28		 jne	 SHORT $LN20@complex_ri
  0004c	48 8d 54 24 30	 lea	 rdx, QWORD PTR i$[rsp]
  00051	48 8d 4c 24 70	 lea	 rcx, QWORD PTR v$[rsp]
  00056	e8 00 00 00 00	 call	 to_complex
  0005b	85 c0		 test	 eax, eax
  0005d	79 27		 jns	 SHORT $LN18@complex_ri
  0005f	48 8b 44 24 70	 mov	 rax, QWORD PTR v$[rsp]

; 654  : }

  00064	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  0006c	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00070	5f		 pop	 rdi
  00071	5e		 pop	 rsi
  00072	5d		 pop	 rbp
  00073	c3		 ret	 0
$LN20@complex_ri:

; 607  :         goto Unimplemented;
; 608  :     }
; 609  : 
; 610  :     assert(PyComplex_Check(v));
; 611  :     TO_COMPLEX(v, i);

  00074	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00078	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
  0007d	48 8b 47 68	 mov	 rax, QWORD PTR [rdi+104]
  00081	48 89 44 24 38	 mov	 QWORD PTR i$[rsp+8], rax
$LN18@complex_ri:

; 612  : 
; 613  :     if (PyLong_Check(w)) {

  00086	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  0008a	33 ff		 xor	 edi, edi
  0008c	f7 81 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rcx+256], 16777216 ; 01000000H
  00096	74 5b		 je	 SHORT $LN17@complex_ri

; 614  :         /* Check for 0.0 imaginary part first to avoid the rich
; 615  :          * comparison when possible.
; 616  :          */
; 617  :         if (i.imag == 0.0) {

  00098	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR i$[rsp+8]
  0009e	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  000a6	0f 8a 75 01 00
	00		 jp	 $LN25@complex_ri
  000ac	0f 85 6f 01 00
	00		 jne	 $LN25@complex_ri

; 618  :             PyObject *j, *sub_res;
; 619  :             j = PyFloat_FromDouble(i.real);

  000b2	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR i$[rsp]
  000b8	e8 00 00 00 00	 call	 PyFloat_FromDouble
  000bd	48 8b f8	 mov	 rdi, rax

; 620  :             if (j == NULL)

  000c0	48 85 c0	 test	 rax, rax
  000c3	75 10		 jne	 SHORT $LN15@complex_ri

; 654  : }

  000c5	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  000cd	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000d1	5f		 pop	 rdi
  000d2	5e		 pop	 rsi
  000d3	5d		 pop	 rbp
  000d4	c3		 ret	 0
$LN15@complex_ri:

; 621  :                 return NULL;
; 622  : 
; 623  :             sub_res = PyObject_RichCompare(j, w, op);

  000d5	44 8b c6	 mov	 r8d, esi
  000d8	48 8b d3	 mov	 rdx, rbx
  000db	48 8b c8	 mov	 rcx, rax
  000de	e8 00 00 00 00	 call	 PyObject_RichCompare

; 624  :             Py_DECREF(j);

  000e3	48 8b cf	 mov	 rcx, rdi
  000e6	48 8b d8	 mov	 rbx, rax
  000e9	e8 00 00 00 00	 call	 _Py_DecRef

; 625  :             return sub_res;

  000ee	e9 86 01 00 00	 jmp	 $LN30@complex_ri
$LN17@complex_ri:

; 626  :         }
; 627  :         else {
; 628  :             equal = 0;
; 629  :         }
; 630  :     }
; 631  :     else if (PyFloat_Check(w)) {

  000f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  000fa	48 3b ca	 cmp	 rcx, rdx
  000fd	0f 84 f1 00 00
	00		 je	 $LN11@complex_ri
  00103	e8 00 00 00 00	 call	 PyType_IsSubtype
  00108	85 c0		 test	 eax, eax
  0010a	0f 85 e4 00 00
	00		 jne	 $LN11@complex_ri

; 633  :     }
; 634  :     else if (PyComplex_Check(w)) {

  00110	48 39 6b 58	 cmp	 QWORD PTR [rbx+88], rbp
  00114	0f 84 aa 00 00
	00		 je	 $LN6@complex_ri
  0011a	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  0011e	48 8b d5	 mov	 rdx, rbp
  00121	e8 00 00 00 00	 call	 PyType_IsSubtype
  00126	85 c0		 test	 eax, eax
  00128	75 5c		 jne	 SHORT $LN8@complex_ri
$Unimplemented$20670:

; 651  : 
; 652  : Unimplemented:
; 653  :     Py_RETURN_NOTIMPLEMENTED;

  0012a	e8 00 00 00 00	 call	 _Py_PXCTX
  0012f	85 c0		 test	 eax, eax
  00131	75 3c		 jne	 SHORT $LN34@complex_ri
  00133	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  0013a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00141	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00148	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0014e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00156	e8 00 00 00 00	 call	 _PyParallel_Guard
  0015b	85 c0		 test	 eax, eax
  0015d	75 09		 jne	 SHORT $LN33@complex_ri
  0015f	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00166	74 07		 je	 SHORT $LN34@complex_ri
$LN33@complex_ri:
  00168	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN34@complex_ri:
  0016f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 654  : }

  00176	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  0017e	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00182	5f		 pop	 rdi
  00183	5e		 pop	 rsi
  00184	5d		 pop	 rbp
  00185	c3		 ret	 0
$LN8@complex_ri:

; 635  :         Py_complex j;
; 636  : 
; 637  :         TO_COMPLEX(w, j);

  00186	48 39 6b 58	 cmp	 QWORD PTR [rbx+88], rbp
  0018a	74 38		 je	 SHORT $LN6@complex_ri
  0018c	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00190	48 8b d5	 mov	 rdx, rbp
  00193	e8 00 00 00 00	 call	 PyType_IsSubtype
  00198	85 c0		 test	 eax, eax
  0019a	75 28		 jne	 SHORT $LN6@complex_ri
  0019c	48 8d 54 24 40	 lea	 rdx, QWORD PTR j$20699[rsp]
  001a1	48 8d 4c 24 78	 lea	 rcx, QWORD PTR w$[rsp]
  001a6	e8 00 00 00 00	 call	 to_complex
  001ab	85 c0		 test	 eax, eax
  001ad	79 27		 jns	 SHORT $LN4@complex_ri
  001af	48 8b 44 24 78	 mov	 rax, QWORD PTR w$[rsp]

; 654  : }

  001b4	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  001bc	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001c0	5f		 pop	 rdi
  001c1	5e		 pop	 rsi
  001c2	5d		 pop	 rbp
  001c3	c3		 ret	 0
$LN6@complex_ri:

; 635  :         Py_complex j;
; 636  : 
; 637  :         TO_COMPLEX(w, j);

  001c4	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  001c8	48 89 44 24 40	 mov	 QWORD PTR j$20699[rsp], rax
  001cd	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  001d1	48 89 44 24 48	 mov	 QWORD PTR j$20699[rsp+8], rax
$LN4@complex_ri:

; 638  :         equal = (i.real == j.real && i.imag == j.imag);

  001d6	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR i$[rsp]
  001dc	66 0f 2e 44 24
	40		 ucomisd xmm0, QWORD PTR j$20699[rsp]
  001e2	7a 3d		 jp	 SHORT $LN25@complex_ri
  001e4	75 3b		 jne	 SHORT $LN25@complex_ri
  001e6	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR i$[rsp+8]
  001ec	66 0f 2e 44 24
	48		 ucomisd xmm0, QWORD PTR j$20699[rsp+8]

; 639  :     }
; 640  :     else {

  001f2	eb 24		 jmp	 SHORT $LN40@complex_ri
$LN11@complex_ri:

; 632  :         equal = (i.real == PyFloat_AsDouble(w) && i.imag == 0.0);

  001f4	48 8b cb	 mov	 rcx, rbx
  001f7	e8 00 00 00 00	 call	 PyFloat_AsDouble
  001fc	f2 0f 10 4c 24
	30		 movsdx	 xmm1, QWORD PTR i$[rsp]
  00202	66 0f 2e c8	 ucomisd xmm1, xmm0
  00206	7a 19		 jp	 SHORT $LN25@complex_ri
  00208	75 17		 jne	 SHORT $LN25@complex_ri
  0020a	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR i$[rsp+8]
  00210	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
$LN40@complex_ri:
  00218	7a 07		 jp	 SHORT $LN25@complex_ri
  0021a	b8 01 00 00 00	 mov	 eax, 1
  0021f	74 02		 je	 SHORT $LN26@complex_ri
$LN25@complex_ri:
  00221	8b c7		 mov	 eax, edi
$LN26@complex_ri:

; 641  :         goto Unimplemented;
; 642  :     }
; 643  : 
; 644  :     if (equal == (op == Py_EQ))

  00223	83 fe 02	 cmp	 esi, 2
  00226	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  0022d	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_TrueStruct
  00234	40 0f 94 c7	 sete	 dil
  00238	3b c7		 cmp	 eax, edi
  0023a	48 0f 45 d9	 cmovne	 rbx, rcx

; 645  :          res = Py_True;
; 646  :     else
; 647  :          res = Py_False;
; 648  : 
; 649  :     Py_INCREF(res);

  0023e	e8 00 00 00 00	 call	 _Py_PXCTX
  00243	85 c0		 test	 eax, eax
  00245	75 32		 jne	 SHORT $LN30@complex_ri
  00247	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0024e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00255	4c 8b cb	 mov	 r9, rbx
  00258	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0025e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00266	e8 00 00 00 00	 call	 _PyParallel_Guard
  0026b	85 c0		 test	 eax, eax
  0026d	75 06		 jne	 SHORT $LN29@complex_ri
  0026f	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00273	74 04		 je	 SHORT $LN30@complex_ri
$LN29@complex_ri:
  00275	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN30@complex_ri:

; 650  :     return res;

  00279	48 8b c3	 mov	 rax, rbx

; 654  : }

  0027c	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  00284	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00288	5f		 pop	 rdi
  00289	5e		 pop	 rsi
  0028a	5d		 pop	 rbp
  0028b	c3		 ret	 0
complex_richcompare ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@BDCCKPHB@can?8t?5convert?5complex?5to?5int?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_int DD imagerel complex_int
	DD	imagerel complex_int+30
	DD	imagerel $unwind$complex_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_int DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BN@BDCCKPHB@can?8t?5convert?5complex?5to?5int?$AA@
CONST	SEGMENT
??_C@_0BN@BDCCKPHB@can?8t?5convert?5complex?5to?5int?$AA@ DB 'can''t conv'
	DB	'ert complex to int', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT complex_int
_TEXT	SEGMENT
v$ = 48
complex_int PROC					; COMDAT

; 658  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 659  :     PyErr_SetString(PyExc_TypeError,
; 660  :                "can't convert complex to int");

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@BDCCKPHB@can?8t?5convert?5complex?5to?5int?$AA@
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 661  :     return NULL;

  00017	33 c0		 xor	 eax, eax

; 662  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
complex_int ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@HOIFMJCC@can?8t?5convert?5complex?5to?5float?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_float DD imagerel complex_float
	DD	imagerel complex_float+30
	DD	imagerel $unwind$complex_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_float DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BP@HOIFMJCC@can?8t?5convert?5complex?5to?5float?$AA@
CONST	SEGMENT
??_C@_0BP@HOIFMJCC@can?8t?5convert?5complex?5to?5float?$AA@ DB 'can''t co'
	DB	'nvert complex to float', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT complex_float
_TEXT	SEGMENT
v$ = 48
complex_float PROC					; COMDAT

; 666  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 667  :     PyErr_SetString(PyExc_TypeError,
; 668  :                "can't convert complex to float");

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@HOIFMJCC@can?8t?5convert?5complex?5to?5float?$AA@
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 669  :     return NULL;

  00017	33 c0		 xor	 eax, eax

; 670  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
complex_float ENDP
_TEXT	ENDS
PUBLIC	$T21851
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_conjugate DD imagerel complex_conjugate
	DD	imagerel complex_conjugate+59
	DD	imagerel $unwind$complex_conjugate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_conjugate DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT complex_conjugate
_TEXT	SEGMENT
$T21851 = 32
c$ = 32
self$ = 64
complex_conjugate PROC					; COMDAT

; 674  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 675  :     Py_complex c;
; 676  :     c = ((PyComplexObject *)self)->cval;

  00004	0f 10 41 60	 movups	 xmm0, XMMWORD PTR [rcx+96]

; 677  :     c.imag = -c.imag;
; 678  :     return PyComplex_FromCComplex(c);

  00008	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T21851[rsp]
  0000d	0f 29 44 24 20	 movaps	 XMMWORD PTR c$[rsp], xmm0
  00012	f2 0f 10 4c 24
	28		 movsdx	 xmm1, QWORD PTR c$[rsp+8]
  00018	66 0f 57 0d 00
	00 00 00	 xorpd	 xmm1, QWORD PTR __mask@@NegDouble@
  00020	f2 0f 11 4c 24
	28		 movsdx	 QWORD PTR c$[rsp+8], xmm1
  00026	0f 28 44 24 20	 movaps	 xmm0, XMMWORD PTR c$[rsp]
  0002b	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR $T21851[rsp], xmm0
  00031	e8 00 00 00 00	 call	 PyComplex_FromCComplex

; 679  : }

  00036	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003a	c3		 ret	 0
complex_conjugate ENDP
_TEXT	ENDS
PUBLIC	??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@		; `string'
EXTRN	Py_BuildValue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_getnewargs DD imagerel complex_getnewargs
	DD	imagerel complex_getnewargs+60
	DD	imagerel $unwind$complex_getnewargs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_getnewargs DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@
CONST	SEGMENT
??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@ DB '(dd)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT complex_getnewargs
_TEXT	SEGMENT
c$ = 32
v$ = 64
complex_getnewargs PROC					; COMDAT

; 688  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 689  :     Py_complex c = v->cval;

  00004	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00008	48 89 44 24 20	 mov	 QWORD PTR c$[rsp], rax
  0000d	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]

; 690  :     return Py_BuildValue("(dd)", c.real, c.imag);

  00011	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@
  00018	f2 0f 10 4c 24
	20		 movsdx	 xmm1, QWORD PTR c$[rsp]
  0001e	48 89 44 24 28	 mov	 QWORD PTR c$[rsp+8], rax
  00023	66 48 0f 7e ca	 movd	 rdx, xmm1
  00028	f2 0f 10 54 24
	28		 movsdx	 xmm2, QWORD PTR c$[rsp+8]
  0002e	66 49 0f 7e d0	 movd	 r8, xmm2

; 691  : }

  00033	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00037	e9 00 00 00 00	 jmp	 Py_BuildValue
complex_getnewargs ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@EKIKMBMC@U?3__format__?$AA@		; `string'
EXTRN	_PyUnicodeWriter_Finish:PROC
EXTRN	_PyUnicodeWriter_Dealloc:PROC
EXTRN	_PyComplex_FormatAdvancedWriter:PROC
EXTRN	_PyUnicodeWriter_Init:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex__format__ DD imagerel complex__format__
	DD	imagerel complex__format__+118
	DD	imagerel $unwind$complex__format__
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex__format__ DD 020601H
	DD	03002d206H
xdata	ENDS
;	COMDAT ??_C@_0N@EKIKMBMC@U?3__format__?$AA@
CONST	SEGMENT
??_C@_0N@EKIKMBMC@U?3__format__?$AA@ DB 'U:__format__', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT complex__format__
_TEXT	SEGMENT
writer$ = 48
self$ = 128
args$ = 136
format_spec$ = 144
complex__format__ PROC					; COMDAT

; 700  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 701  :     PyObject *format_spec;
; 702  :     _PyUnicodeWriter writer;
; 703  :     int ret;
; 704  : 
; 705  :     if (!PyArg_ParseTuple(args, "U:__format__", &format_spec))

  0000c	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR format_spec$[rsp]
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@EKIKMBMC@U?3__format__?$AA@
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00023	85 c0		 test	 eax, eax

; 706  :         return NULL;

  00025	74 3c		 je	 SHORT $LN5@complex__f

; 707  : 
; 708  :     _PyUnicodeWriter_Init(&writer, 0);

  00027	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  0002c	33 d2		 xor	 edx, edx
  0002e	e8 00 00 00 00	 call	 _PyUnicodeWriter_Init

; 709  :     ret = _PyComplex_FormatAdvancedWriter(
; 710  :         &writer,
; 711  :         self,
; 712  :         format_spec, 0, PyUnicode_GET_LENGTH(format_spec));

  00033	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR format_spec$[rsp]
  0003b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  00040	49 8b 40 60	 mov	 rax, QWORD PTR [r8+96]
  00044	45 33 c9	 xor	 r9d, r9d
  00047	48 8b d3	 mov	 rdx, rbx
  0004a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004f	e8 00 00 00 00	 call	 _PyComplex_FormatAdvancedWriter

; 713  :     if (ret == -1) {
; 714  :         _PyUnicodeWriter_Dealloc(&writer);

  00054	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  00059	83 f8 ff	 cmp	 eax, -1
  0005c	75 0d		 jne	 SHORT $LN1@complex__f
  0005e	e8 00 00 00 00	 call	 _PyUnicodeWriter_Dealloc
$LN5@complex__f:

; 715  :         return NULL;

  00063	33 c0		 xor	 eax, eax

; 718  : }

  00065	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00069	5b		 pop	 rbx
  0006a	c3		 ret	 0
$LN1@complex__f:

; 716  :     }
; 717  :     return _PyUnicodeWriter_Finish(&writer);

  0006b	e8 00 00 00 00	 call	 _PyUnicodeWriter_Finish

; 718  : }

  00070	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00074	5b		 pop	 rbx
  00075	c3		 ret	 0
complex__format__ ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@CCMGNPBA@complex?$CI?$CJ?5arg?5is?5a?5malformed?5str@ ; `string'
PUBLIC	??_C@_0DA@LGCEOOP@complex?$CI?$CJ?5argument?5must?5be?5a?5str@ ; `string'
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyOS_string_to_double:PROC
EXTRN	_Py_ctype_table:BYTE
EXTRN	PyObject_AsCharBuffer:PROC
EXTRN	PyUnicode_AsUTF8AndSize:PROC
EXTRN	_PyUnicode_TransformDecimalAndSpaceToASCII:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_subtype_from_string DD imagerel complex_subtype_from_string
	DD	imagerel complex_subtype_from_string+783
	DD	imagerel $unwind$complex_subtype_from_string
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_subtype_from_string DD 0104101H
	DD	029841H
	DD	03883bH
	DD	047821H
	DD	05681cH
	DD	0123413H
	DD	0d00cb213H
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT ??_C@_0CE@CCMGNPBA@complex?$CI?$CJ?5arg?5is?5a?5malformed?5str@
CONST	SEGMENT
??_C@_0CE@CCMGNPBA@complex?$CI?$CJ?5arg?5is?5a?5malformed?5str@ DB 'compl'
	DB	'ex() arg is a malformed string', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@LGCEOOP@complex?$CI?$CJ?5argument?5must?5be?5a?5str@
CONST	SEGMENT
??_C@_0DA@LGCEOOP@complex?$CI?$CJ?5argument?5must?5be?5a?5str@ DB 'comple'
	DB	'x() argument must be a string or a number', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT complex_subtype_from_string
_TEXT	SEGMENT
type$ = 144
s$ = 152
v$ = 152
end$ = 160
len$ = 168
complex_subtype_from_string PROC			; COMDAT

; 759  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	48 8b ec	 mov	 rbp, rsp
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 760  :     const char *s, *start;
; 761  :     char *end;
; 762  :     double x=0.0, y=0.0, z;
; 763  :     int got_bracket=0;
; 764  :     PyObject *s_buffer = NULL;
; 765  :     Py_ssize_t len;
; 766  : 
; 767  :     if (PyUnicode_Check(v)) {

  00013	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00017	0f 29 74 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm6
  0001c	0f 29 7c 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm7
  00021	33 ff		 xor	 edi, edi
  00023	4c 8b ca	 mov	 r9, rdx
  00026	4c 8b e1	 mov	 r12, rcx
  00029	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00033	8b df		 mov	 ebx, edi
  00035	44 0f 29 44 24
	30		 movaps	 XMMWORD PTR [rsp+48], xmm8
  0003b	44 0f 29 4c 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm9
  00041	66 45 0f 57 c9	 xorpd	 xmm9, xmm9
  00046	66 45 0f 28 c1	 movapd	 xmm8, xmm9
  0004b	74 2e		 je	 SHORT $LN46@complex_su@3

; 768  :         s_buffer = _PyUnicode_TransformDecimalAndSpaceToASCII(v);

  0004d	48 8b ca	 mov	 rcx, rdx
  00050	e8 00 00 00 00	 call	 _PyUnicode_TransformDecimalAndSpaceToASCII
  00055	48 8b d8	 mov	 rbx, rax

; 769  :         if (s_buffer == NULL)

  00058	48 85 c0	 test	 rax, rax

; 770  :             return NULL;

  0005b	74 45		 je	 SHORT $LN66@complex_su@3

; 771  :         s = PyUnicode_AsUTF8AndSize(s_buffer, &len);

  0005d	48 8d 55 48	 lea	 rdx, QWORD PTR len$[rbp-96]
  00061	48 8b c8	 mov	 rcx, rax
  00064	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  00069	48 8b c8	 mov	 rcx, rax
  0006c	48 89 45 38	 mov	 QWORD PTR s$[rbp-96], rax

; 772  :         if (s == NULL)

  00070	48 85 c0	 test	 rax, rax
  00073	0f 84 15 02 00
	00		 je	 $error$20800

; 773  :             goto error;
; 774  :     }
; 775  :     else if (PyObject_AsCharBuffer(v, &s, &len)) {

  00079	eb 32		 jmp	 SHORT $LN42@complex_su@3
$LN46@complex_su@3:
  0007b	4c 8d 45 48	 lea	 r8, QWORD PTR len$[rbp-96]
  0007f	48 8d 55 38	 lea	 rdx, QWORD PTR s$[rbp-96]
  00083	49 8b c9	 mov	 rcx, r9
  00086	e8 00 00 00 00	 call	 PyObject_AsCharBuffer
  0008b	85 c0		 test	 eax, eax
  0008d	74 1a		 je	 SHORT $LN62@complex_su@3

; 776  :         PyErr_SetString(PyExc_TypeError,
; 777  :                         "complex() argument must be a string or a number");

  0008f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@LGCEOOP@complex?$CI?$CJ?5argument?5must?5be?5a?5str@
  0009d	e8 00 00 00 00	 call	 PyErr_SetString
$LN66@complex_su@3:

; 778  :         return NULL;

  000a2	33 c0		 xor	 eax, eax
  000a4	e9 3c 02 00 00	 jmp	 $LN47@complex_su@3
$LN62@complex_su@3:
  000a9	48 8b 4d 38	 mov	 rcx, QWORD PTR s$[rbp-96]
$LN42@complex_su@3:

; 779  :     }
; 780  : 
; 781  :     /* position on first nonblank */
; 782  :     start = s;
; 783  :     while (Py_ISSPACE(*s))

  000ad	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  000b0	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_ctype_table
  000b7	48 8b f1	 mov	 rsi, rcx
  000ba	41 f6 44 85 00
	08		 test	 BYTE PTR [r13+rax*4], 8
  000c0	74 20		 je	 SHORT $LN40@complex_su@3
  000c2	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL41@complex_su@3:

; 784  :         s++;

  000d0	48 ff c1	 inc	 rcx
  000d3	48 89 4d 38	 mov	 QWORD PTR s$[rbp-96], rcx
  000d7	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  000da	41 f6 44 85 00
	08		 test	 BYTE PTR [r13+rax*4], 8
  000e0	75 ee		 jne	 SHORT $LL41@complex_su@3
$LN40@complex_su@3:

; 785  :     if (*s == '(') {

  000e2	80 39 28	 cmp	 BYTE PTR [rcx], 40	; 00000028H
  000e5	75 2b		 jne	 SHORT $LN37@complex_su@3

; 786  :         /* Skip over possible bracket from repr(). */
; 787  :         got_bracket = 1;
; 788  :         s++;

  000e7	48 ff c1	 inc	 rcx
  000ea	bf 01 00 00 00	 mov	 edi, 1
  000ef	48 89 4d 38	 mov	 QWORD PTR s$[rbp-96], rcx

; 789  :         while (Py_ISSPACE(*s))

  000f3	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  000f6	41 f6 44 85 00
	08		 test	 BYTE PTR [r13+rax*4], 8
  000fc	74 14		 je	 SHORT $LN37@complex_su@3
  000fe	66 90		 npad	 2
$LL38@complex_su@3:

; 790  :             s++;

  00100	48 ff c1	 inc	 rcx
  00103	48 89 4d 38	 mov	 QWORD PTR s$[rbp-96], rcx
  00107	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  0010a	41 f6 44 85 00
	08		 test	 BYTE PTR [r13+rax*4], 8
  00110	75 ee		 jne	 SHORT $LL38@complex_su@3
$LN37@complex_su@3:

; 791  :     }
; 792  : 
; 793  :     /* a valid complex string usually takes one of the three forms:
; 794  : 
; 795  :          <float>                  - real part only
; 796  :          <float>j                 - imaginary part only
; 797  :          <float><signed-float>j   - real and imaginary parts
; 798  : 
; 799  :        where <float> represents any numeric string that's accepted by the
; 800  :        float constructor (including 'nan', 'inf', 'infinity', etc.), and
; 801  :        <signed-float> is any string of the form <float> whose first
; 802  :        character is '+' or '-'.
; 803  : 
; 804  :        For backwards compatibility, the extra forms
; 805  : 
; 806  :          <float><sign>j
; 807  :          <sign>j
; 808  :          j
; 809  : 
; 810  :        are also accepted, though support for these forms may be removed from
; 811  :        a future version of Python.
; 812  :     */
; 813  : 
; 814  :     /* first look for forms starting with <float> */
; 815  :     z = PyOS_string_to_double(s, &end, NULL);

  00112	48 8d 55 40	 lea	 rdx, QWORD PTR end$[rbp-96]
  00116	45 33 c0	 xor	 r8d, r8d
  00119	e8 00 00 00 00	 call	 PyOS_string_to_double

; 816  :     if (z == -1.0 && PyErr_Occurred()) {

  0011e	f2 0f 10 3d 00
	00 00 00	 movsdx	 xmm7, QWORD PTR __real@bff0000000000000
  00126	66 0f 2e c7	 ucomisd xmm0, xmm7
  0012a	66 0f 28 f0	 movapd	 xmm6, xmm0
  0012e	7a 25		 jp	 SHORT $LN34@complex_su@3
  00130	75 23		 jne	 SHORT $LN34@complex_su@3
  00132	e8 00 00 00 00	 call	 PyErr_Occurred
  00137	48 85 c0	 test	 rax, rax
  0013a	74 19		 je	 SHORT $LN34@complex_su@3

; 817  :         if (PyErr_ExceptionMatches(PyExc_ValueError))

  0013c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00143	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00148	85 c0		 test	 eax, eax
  0014a	0f 84 3e 01 00
	00		 je	 $error$20800

; 818  :             PyErr_Clear();

  00150	e8 00 00 00 00	 call	 PyErr_Clear
$LN34@complex_su@3:

; 819  :         else
; 820  :             goto error;
; 821  :     }
; 822  :     if (end != s) {

  00155	4c 8b 4d 40	 mov	 r9, QWORD PTR end$[rbp-96]
  00159	48 8b 4d 38	 mov	 rcx, QWORD PTR s$[rbp-96]
  0015d	4c 3b c9	 cmp	 r9, rcx
  00160	0f 84 39 01 00
	00		 je	 $LN33@complex_su@3

; 823  :         /* all 4 forms starting with <float> land here */
; 824  :         s = end;

  00166	49 8b c9	 mov	 rcx, r9
  00169	48 89 4d 38	 mov	 QWORD PTR s$[rbp-96], rcx

; 825  :         if (*s == '+' || *s == '-') {

  0016d	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00171	3c 2b		 cmp	 al, 43			; 0000002bH
  00173	74 21		 je	 SHORT $LN31@complex_su@3
  00175	3c 2d		 cmp	 al, 45			; 0000002dH
  00177	74 1d		 je	 SHORT $LN31@complex_su@3

; 841  :                 s++;
; 842  :             }
; 843  :             if (!(*s == 'j' || *s == 'J'))
; 844  :                 goto parse_error;
; 845  :             s++;
; 846  :         }
; 847  :         else if (*s == 'j' || *s == 'J') {

  00179	3c 6a		 cmp	 al, 106			; 0000006aH
  0017b	74 0e		 je	 SHORT $LN22@complex_su@3
  0017d	3c 4a		 cmp	 al, 74			; 0000004aH
  0017f	74 0a		 je	 SHORT $LN22@complex_su@3

; 853  :             /* <float> */
; 854  :             x = z;

  00181	66 44 0f 28 ce	 movapd	 xmm9, xmm6
  00186	e9 8d 00 00 00	 jmp	 $LN55@complex_su@3
$LN22@complex_su@3:

; 848  :             /* <float>j */
; 849  :             s++;

  0018b	49 8d 49 01	 lea	 rcx, QWORD PTR [r9+1]

; 850  :             y = z;

  0018f	66 44 0f 28 c6	 movapd	 xmm8, xmm6

; 851  :         }
; 852  :         else

  00194	eb 7e		 jmp	 SHORT $LN63@complex_su@3
$LN31@complex_su@3:

; 826  :             /* <float><signed-float>j | <float><sign>j */
; 827  :             x = z;
; 828  :             y = PyOS_string_to_double(s, &end, NULL);

  00196	48 8d 55 40	 lea	 rdx, QWORD PTR end$[rbp-96]
  0019a	45 33 c0	 xor	 r8d, r8d
  0019d	66 44 0f 28 ce	 movapd	 xmm9, xmm6
  001a2	e8 00 00 00 00	 call	 PyOS_string_to_double

; 829  :             if (y == -1.0 && PyErr_Occurred()) {

  001a7	66 0f 2e c7	 ucomisd xmm0, xmm7
  001ab	66 44 0f 28 c0	 movapd	 xmm8, xmm0
  001b0	7a 25		 jp	 SHORT $LN28@complex_su@3
  001b2	75 23		 jne	 SHORT $LN28@complex_su@3
  001b4	e8 00 00 00 00	 call	 PyErr_Occurred
  001b9	48 85 c0	 test	 rax, rax
  001bc	74 19		 je	 SHORT $LN28@complex_su@3

; 830  :                 if (PyErr_ExceptionMatches(PyExc_ValueError))

  001be	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001c5	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  001ca	85 c0		 test	 eax, eax
  001cc	0f 84 bc 00 00
	00		 je	 $error$20800

; 831  :                     PyErr_Clear();

  001d2	e8 00 00 00 00	 call	 PyErr_Clear
$LN28@complex_su@3:

; 832  :                 else
; 833  :                     goto error;
; 834  :             }
; 835  :             if (end != s)

  001d7	48 8b 45 40	 mov	 rax, QWORD PTR end$[rbp-96]
  001db	48 8b 4d 38	 mov	 rcx, QWORD PTR s$[rbp-96]
  001df	48 3b c1	 cmp	 rax, rcx
  001e2	74 09		 je	 SHORT $LN27@complex_su@3

; 836  :                 /* <float><signed-float>j */
; 837  :                 s = end;

  001e4	48 8b c8	 mov	 rcx, rax
  001e7	48 89 45 38	 mov	 QWORD PTR s$[rbp-96], rax

; 838  :             else {

  001eb	eb 19		 jmp	 SHORT $LN17@complex_su@3
$LN27@complex_su@3:

; 839  :                 /* <float><sign>j */
; 840  :                 y = *s == '+' ? 1.0 : -1.0;

  001ed	80 39 2b	 cmp	 BYTE PTR [rcx], 43	; 0000002bH
  001f0	0f 85 c6 00 00
	00		 jne	 $LN51@complex_su@3
$LN61@complex_su@3:

; 859  :             /* <sign>j */
; 860  :             y = *s == '+' ? 1.0 : -1.0;

  001f6	f2 44 0f 10 05
	00 00 00 00	 movsdx	 xmm8, QWORD PTR __real@3ff0000000000000
$LN52@complex_su@3:

; 861  :             s++;

  001ff	48 ff c1	 inc	 rcx
  00202	48 89 4d 38	 mov	 QWORD PTR s$[rbp-96], rcx
$LN17@complex_su@3:

; 866  :         if (!(*s == 'j' || *s == 'J'))

  00206	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00209	3c 6a		 cmp	 al, 106			; 0000006aH
  0020b	74 04		 je	 SHORT $LN16@complex_su@3
  0020d	3c 4a		 cmp	 al, 74			; 0000004aH
  0020f	75 6a		 jne	 SHORT $parse_error$20828
$LN16@complex_su@3:

; 867  :             goto parse_error;
; 868  :         s++;

  00211	48 ff c1	 inc	 rcx
$LN63@complex_su@3:
  00214	48 89 4d 38	 mov	 QWORD PTR s$[rbp-96], rcx
$LN55@complex_su@3:

; 869  :     }
; 870  : 
; 871  :     /* trailing whitespace and closing bracket */
; 872  :     while (Py_ISSPACE(*s))

  00218	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  0021b	41 f6 44 85 00
	08		 test	 BYTE PTR [r13+rax*4], 8
  00221	74 1f		 je	 SHORT $LN14@complex_su@3
  00223	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL15@complex_su@3:

; 873  :         s++;

  00230	48 ff c1	 inc	 rcx
  00233	48 89 4d 38	 mov	 QWORD PTR s$[rbp-96], rcx
  00237	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  0023a	41 f6 44 85 00
	08		 test	 BYTE PTR [r13+rax*4], 8
  00240	75 ee		 jne	 SHORT $LL15@complex_su@3
$LN14@complex_su@3:

; 874  :     if (got_bracket) {

  00242	85 ff		 test	 edi, edi
  00244	74 2c		 je	 SHORT $LN10@complex_su@3

; 875  :         /* if there was an opening parenthesis, then the corresponding
; 876  :            closing parenthesis should be right here */
; 877  :         if (*s != ')')

  00246	80 39 29	 cmp	 BYTE PTR [rcx], 41	; 00000029H
  00249	75 30		 jne	 SHORT $parse_error$20828

; 878  :             goto parse_error;
; 879  :         s++;

  0024b	48 ff c1	 inc	 rcx
  0024e	48 89 4d 38	 mov	 QWORD PTR s$[rbp-96], rcx

; 880  :         while (Py_ISSPACE(*s))

  00252	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00255	41 f6 44 85 00
	08		 test	 BYTE PTR [r13+rax*4], 8
  0025b	74 15		 je	 SHORT $LN10@complex_su@3
  0025d	0f 1f 00	 npad	 3
$LL11@complex_su@3:

; 881  :             s++;

  00260	48 ff c1	 inc	 rcx
  00263	48 89 4d 38	 mov	 QWORD PTR s$[rbp-96], rcx
  00267	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  0026a	41 f6 44 85 00
	08		 test	 BYTE PTR [r13+rax*4], 8
  00270	75 ee		 jne	 SHORT $LL11@complex_su@3
$LN10@complex_su@3:

; 882  :     }
; 883  : 
; 884  :     /* we should now be at the end of the string */
; 885  :     if (s-start != len)

  00272	48 2b ce	 sub	 rcx, rsi
  00275	48 3b 4d 48	 cmp	 rcx, QWORD PTR len$[rbp-96]
  00279	74 4b		 je	 SHORT $LN8@complex_su@3
$parse_error$20828:

; 890  : 
; 891  :   parse_error:
; 892  :     PyErr_SetString(PyExc_ValueError,
; 893  :                     "complex() arg is a malformed string");

  0027b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00282	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@CCMGNPBA@complex?$CI?$CJ?5arg?5is?5a?5malformed?5str@
  00289	e8 00 00 00 00	 call	 PyErr_SetString
$error$20800:

; 894  :   error:
; 895  :     Py_XDECREF(s_buffer);

  0028e	48 85 db	 test	 rbx, rbx
  00291	74 08		 je	 SHORT $LN3@complex_su@3
  00293	48 8b cb	 mov	 rcx, rbx
  00296	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@complex_su@3:

; 896  :     return NULL;

  0029b	33 c0		 xor	 eax, eax
  0029d	eb 46		 jmp	 SHORT $LN47@complex_su@3
$LN33@complex_su@3:

; 855  :     }
; 856  :     else {
; 857  :         /* not starting with <float>; must be <sign>j or j */
; 858  :         if (*s == '+' || *s == '-') {

  0029f	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  002a2	3c 2b		 cmp	 al, 43			; 0000002bH
  002a4	0f 84 4c ff ff
	ff		 je	 $LN61@complex_su@3
  002aa	3c 2d		 cmp	 al, 45			; 0000002dH
  002ac	74 0e		 je	 SHORT $LN51@complex_su@3

; 862  :         }
; 863  :         else
; 864  :             /* j */
; 865  :             y = 1.0;

  002ae	f2 44 0f 10 05
	00 00 00 00	 movsdx	 xmm8, QWORD PTR __real@3ff0000000000000
  002b7	e9 4a ff ff ff	 jmp	 $LN17@complex_su@3
$LN51@complex_su@3:

; 859  :             /* <sign>j */
; 860  :             y = *s == '+' ? 1.0 : -1.0;

  002bc	66 44 0f 28 c7	 movapd	 xmm8, xmm7
  002c1	e9 39 ff ff ff	 jmp	 $LN52@complex_su@3
$LN8@complex_su@3:

; 886  :         goto parse_error;
; 887  : 
; 888  :     Py_XDECREF(s_buffer);

  002c6	48 85 db	 test	 rbx, rbx
  002c9	74 08		 je	 SHORT $LN7@complex_su@3
  002cb	48 8b cb	 mov	 rcx, rbx
  002ce	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@complex_su@3:

; 889  :     return complex_subtype_from_doubles(type, x, y);

  002d3	66 41 0f 28 d0	 movapd	 xmm2, xmm8
  002d8	66 41 0f 28 c9	 movapd	 xmm1, xmm9
  002dd	49 8b cc	 mov	 rcx, r12
  002e0	e8 00 00 00 00	 call	 complex_subtype_from_doubles
$LN47@complex_su@3:

; 897  : }

  002e5	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  002ed	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  002f2	0f 28 7c 24 40	 movaps	 xmm7, XMMWORD PTR [rsp+64]
  002f7	44 0f 28 44 24
	30		 movaps	 xmm8, XMMWORD PTR [rsp+48]
  002fd	44 0f 28 4c 24
	20		 movaps	 xmm9, XMMWORD PTR [rsp+32]
  00303	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00307	41 5d		 pop	 r13
  00309	41 5c		 pop	 r12
  0030b	5f		 pop	 rdi
  0030c	5e		 pop	 rsi
  0030d	5d		 pop	 rbp
  0030e	c3		 ret	 0
complex_subtype_from_string ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@OHCJGELG@float?$CIr?$CJ?5didn?8t?5return?5a?5float?$AA@ ; `string'
PUBLIC	??_C@_0CH@KIMMAJKJ@complex?$CI?$CJ?5second?5arg?5can?8t?5be?5a?5@ ; `string'
PUBLIC	??_C@_0DF@DPNOAEGF@complex?$CI?$CJ?5can?8t?5take?5second?5arg?5@ ; `string'
PUBLIC	??_C@_0M@ICFMNLDM@?$HMOO?3complex?$AA@		; `string'
EXTRN	PyNumber_Float:PROC
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$complex_new DD imagerel complex_new
	DD	imagerel complex_new+121
	DD	imagerel $unwind$complex_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$complex_new DD imagerel complex_new+121
	DD	imagerel complex_new+398
	DD	imagerel $chain$0$complex_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$complex_new DD imagerel complex_new+398
	DD	imagerel complex_new+562
	DD	imagerel $chain$4$complex_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$complex_new DD imagerel complex_new+562
	DD	imagerel complex_new+585
	DD	imagerel $chain$5$complex_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$complex_new DD imagerel complex_new+585
	DD	imagerel complex_new+798
	DD	imagerel $chain$7$complex_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$complex_new DD imagerel complex_new+798
	DD	imagerel complex_new+837
	DD	imagerel $chain$8$complex_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$complex_new DD 020021H
	DD	017e400H
	DD	imagerel complex_new
	DD	imagerel complex_new+121
	DD	imagerel $unwind$complex_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$complex_new DD 0a0021H
	DD	058800H
	DD	067800H
	DD	076800H
	DD	017e400H
	DD	0163400H
	DD	imagerel complex_new
	DD	imagerel complex_new+121
	DD	imagerel $unwind$complex_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$complex_new DD 021H
	DD	imagerel complex_new+121
	DD	imagerel complex_new+398
	DD	imagerel $chain$0$complex_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$complex_new DD 081c21H
	DD	05881cH
	DD	067816H
	DD	07680dH
	DD	0163408H
	DD	imagerel complex_new+121
	DD	imagerel complex_new+398
	DD	imagerel $chain$0$complex_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$complex_new DD 020821H
	DD	017e408H
	DD	imagerel complex_new
	DD	imagerel complex_new+121
	DD	imagerel $unwind$complex_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$complex_new DD 061201H
	DD	0d008f212H
	DD	07004c006H
	DD	050026003H
xdata	ENDS
;	COMDAT ??_C@_0BP@OHCJGELG@float?$CIr?$CJ?5didn?8t?5return?5a?5float?$AA@
CONST	SEGMENT
??_C@_0BP@OHCJGELG@float?$CIr?$CJ?5didn?8t?5return?5a?5float?$AA@ DB 'flo'
	DB	'at(r) didn''t return a float', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KIMMAJKJ@complex?$CI?$CJ?5second?5arg?5can?8t?5be?5a?5@
CONST	SEGMENT
??_C@_0CH@KIMMAJKJ@complex?$CI?$CJ?5second?5arg?5can?8t?5be?5a?5@ DB 'com'
	DB	'plex() second arg can''t be a string', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@DPNOAEGF@complex?$CI?$CJ?5can?8t?5take?5second?5arg?5@
CONST	SEGMENT
??_C@_0DF@DPNOAEGF@complex?$CI?$CJ?5can?8t?5take?5second?5arg?5@ DB 'comp'
	DB	'lex() can''t take second arg if first is a string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ICFMNLDM@?$HMOO?3complex?$AA@
CONST	SEGMENT
??_C@_0M@ICFMNLDM@?$HMOO?3complex?$AA@ DB '|OO:complex', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT complex_new
_TEXT	SEGMENT
i$ = 48
ci$ = 56
cr$ = 56
type$ = 176
args$ = 184
kwds$ = 192
r$ = 200
complex_new PROC					; COMDAT

; 901  : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	48 8b ec	 mov	 rbp, rsp
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	4c 8b e1	 mov	 r12, rcx
  00015	49 8b c0	 mov	 rax, r8
  00018	4c 8b d2	 mov	 r10, rdx

; 902  :     PyObject *r, *i, *tmp;
; 903  :     PyNumberMethods *nbr, *nbi = NULL;

  0001b	33 f6		 xor	 esi, esi

; 904  :     Py_complex cr, ci;
; 905  :     int own_r = 0;
; 906  :     int cr_is_complex = 0;
; 907  :     int ci_is_complex = 0;
; 908  :     static char *kwlist[] = {"real", "imag", 0};
; 909  : 
; 910  :     r = Py_False;

  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct

; 911  :     i = NULL;
; 912  :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|OO:complex", kwlist,
; 913  :                                      &r, &i))

  00024	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??complex_new@@9@9
  0002b	48 89 4d 48	 mov	 QWORD PTR r$[rbp-128], rcx
  0002f	48 8d 4d b0	 lea	 rcx, QWORD PTR i$[rbp-128]
  00033	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@ICFMNLDM@?$HMOO?3complex?$AA@
  0003a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0003f	48 8d 4d 48	 lea	 rcx, QWORD PTR r$[rbp-128]
  00043	48 8b d0	 mov	 rdx, rax
  00046	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0004b	49 8b ca	 mov	 rcx, r10
  0004e	8b fe		 mov	 edi, esi
  00050	44 8b ee	 mov	 r13d, esi
  00053	48 89 75 b0	 mov	 QWORD PTR i$[rbp-128], rsi
  00057	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0005c	85 c0		 test	 eax, eax
  0005e	75 11		 jne	 SHORT $LN28@complex_ne

; 914  :         return NULL;

  00060	33 c0		 xor	 eax, eax

; 1030 : }

  00062	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00069	41 5d		 pop	 r13
  0006b	41 5c		 pop	 r12
  0006d	5f		 pop	 rdi
  0006e	5e		 pop	 rsi
  0006f	5d		 pop	 rbp
  00070	c3		 ret	 0
$LN28@complex_ne:

; 915  : 
; 916  :     /* Special-case for a single argument when type(arg) is complex. */
; 917  :     if (PyComplex_CheckExact(r) && i == NULL &&
; 918  :         type == &PyComplex_Type) {

  00071	48 8b 4d 48	 mov	 rcx, QWORD PTR r$[rbp-128]
  00075	48 8b 55 b0	 mov	 rdx, QWORD PTR i$[rbp-128]
  00079	4c 89 b4 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], r14
  00081	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:PyComplex_Type
  00088	4c 39 71 58	 cmp	 QWORD PTR [rcx+88], r14
  0008c	75 18		 jne	 SHORT $LN27@complex_ne
  0008e	48 85 d2	 test	 rdx, rdx
  00091	75 13		 jne	 SHORT $LN27@complex_ne
  00093	4d 3b e6	 cmp	 r12, r14
  00096	75 0e		 jne	 SHORT $LN27@complex_ne

; 919  :         /* Note that we can't know whether it's safe to return
; 920  :            a complex *subclass* instance as-is, hence the restriction
; 921  :            to exact complexes here.  If either the input or the
; 922  :            output is a complex subclass, it will be handled below
; 923  :            as a non-orthogonal vector.  */
; 924  :         Py_INCREF(r);

  00098	e8 00 00 00 00	 call	 _Py_IncRef

; 925  :         return r;

  0009d	48 8b 45 48	 mov	 rax, QWORD PTR r$[rbp-128]
  000a1	e9 8c 01 00 00	 jmp	 $LN36@complex_ne
$LN27@complex_ne:

; 926  :     }
; 927  :     if (PyUnicode_Check(r)) {

  000a6	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  000aa	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  000b4	74 2f		 je	 SHORT $LN26@complex_ne

; 928  :         if (i != NULL) {

  000b6	48 85 d2	 test	 rdx, rdx
  000b9	74 1a		 je	 SHORT $LN25@complex_ne

; 929  :             PyErr_SetString(PyExc_TypeError,
; 930  :                             "complex() can't take second arg"
; 931  :                             " if first is a string");

  000bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@DPNOAEGF@complex?$CI?$CJ?5can?8t?5take?5second?5arg?5@
  000c9	e8 00 00 00 00	 call	 PyErr_SetString

; 932  :             return NULL;

  000ce	33 c0		 xor	 eax, eax
  000d0	e9 5d 01 00 00	 jmp	 $LN36@complex_ne
$LN25@complex_ne:

; 933  :         }
; 934  :         return complex_subtype_from_string(type, r);

  000d5	48 8b d1	 mov	 rdx, rcx
  000d8	49 8b cc	 mov	 rcx, r12
  000db	e8 00 00 00 00	 call	 complex_subtype_from_string
  000e0	e9 4d 01 00 00	 jmp	 $LN36@complex_ne
$LN26@complex_ne:

; 935  :     }
; 936  :     if (i != NULL && PyUnicode_Check(i)) {

  000e5	48 85 d2	 test	 rdx, rdx
  000e8	74 2a		 je	 SHORT $LN24@complex_ne
  000ea	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  000ee	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  000f8	74 1a		 je	 SHORT $LN24@complex_ne

; 937  :         PyErr_SetString(PyExc_TypeError,
; 938  :                         "complex() second arg can't be a string");

  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00101	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@KIMMAJKJ@complex?$CI?$CJ?5second?5arg?5can?8t?5be?5a?5@
  00108	e8 00 00 00 00	 call	 PyErr_SetString

; 939  :         return NULL;

  0010d	33 c0		 xor	 eax, eax
  0010f	e9 1e 01 00 00	 jmp	 $LN36@complex_ne
$LN24@complex_ne:

; 940  :     }
; 941  : 
; 942  :     tmp = try_complex_special_method(r);

  00114	e8 00 00 00 00	 call	 try_complex_special_method
  00119	48 8b c8	 mov	 rcx, rax

; 943  :     if (tmp) {

  0011c	48 85 c0	 test	 rax, rax
  0011f	74 0b		 je	 SHORT $LN23@complex_ne

; 944  :         r = tmp;

  00121	48 89 45 48	 mov	 QWORD PTR r$[rbp-128], rax

; 945  :         own_r = 1;

  00125	bf 01 00 00 00	 mov	 edi, 1
  0012a	eb 12		 jmp	 SHORT $LN21@complex_ne
$LN23@complex_ne:

; 946  :     }
; 947  :     else if (PyErr_Occurred()) {

  0012c	e8 00 00 00 00	 call	 PyErr_Occurred
  00131	48 85 c0	 test	 rax, rax

; 948  :         return NULL;

  00134	0f 85 04 02 00
	00		 jne	 $LN16@complex_ne
  0013a	48 8b 4d 48	 mov	 rcx, QWORD PTR r$[rbp-128]
$LN21@complex_ne:

; 949  :     }
; 950  : 
; 951  :     nbr = r->ob_type->tp_as_number;

  0013e	4c 8b 49 58	 mov	 r9, QWORD PTR [rcx+88]

; 952  :     if (i != NULL)

  00142	4c 8b 45 b0	 mov	 r8, QWORD PTR i$[rbp-128]
  00146	49 8b 91 b8 00
	00 00		 mov	 rdx, QWORD PTR [r9+184]
  0014d	4d 85 c0	 test	 r8, r8
  00150	74 0b		 je	 SHORT $LN20@complex_ne

; 953  :         nbi = i->ob_type->tp_as_number;

  00152	49 8b 40 58	 mov	 rax, QWORD PTR [r8+88]
  00156	48 8b b0 b8 00
	00 00		 mov	 rsi, QWORD PTR [rax+184]
$LN20@complex_ne:

; 954  :     if (nbr == NULL || nbr->nb_float == NULL ||
; 955  :         ((i != NULL) && (nbi == NULL || nbi->nb_float == NULL))) {

  0015d	48 85 d2	 test	 rdx, rdx
  00160	0f 84 b8 01 00
	00		 je	 $LN17@complex_ne
  00166	4c 39 aa 90 00
	00 00		 cmp	 QWORD PTR [rdx+144], r13
  0016d	0f 84 ab 01 00
	00		 je	 $LN17@complex_ne
  00173	4d 85 c0	 test	 r8, r8
  00176	74 16		 je	 SHORT $LN19@complex_ne
  00178	48 85 f6	 test	 rsi, rsi
  0017b	0f 84 9d 01 00
	00		 je	 $LN17@complex_ne
  00181	4c 39 ae 90 00
	00 00		 cmp	 QWORD PTR [rsi+144], r13
  00188	0f 84 90 01 00
	00		 je	 $LN17@complex_ne
$LN19@complex_ne:
  0018e	48 89 9c 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rbx
  00196	0f 29 74 24 70	 movaps	 XMMWORD PTR [rsp+112], xmm6

; 962  :     }
; 963  : 
; 964  :     /* If we get this far, then the "real" and "imag" parts should
; 965  :        both be treated as numbers, and the constructor should return a
; 966  :        complex number equal to (real + imag*1j).
; 967  : 
; 968  :        Note that we do NOT assume the input to already be in canonical
; 969  :        form; the "real" and "imag" parts might themselves be complex
; 970  :        numbers, which slightly complicates the code below. */
; 971  :     if (PyComplex_Check(r)) {

  0019b	66 0f 57 f6	 xorpd	 xmm6, xmm6
  0019f	0f 29 7c 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm7
  001a4	44 0f 29 44 24
	50		 movaps	 XMMWORD PTR [rsp+80], xmm8
  001aa	4d 3b ce	 cmp	 r9, r14
  001ad	0f 84 b9 00 00
	00		 je	 $LN14@complex_ne
  001b3	49 8b d6	 mov	 rdx, r14
  001b6	49 8b c9	 mov	 rcx, r9
  001b9	e8 00 00 00 00	 call	 PyType_IsSubtype

; 979  :         }
; 980  :     }
; 981  :     else {
; 982  :         /* The "real" part really is entirely real, and contributes
; 983  :            nothing in the imaginary direction.
; 984  :            Just treat it as a double. */
; 985  :         tmp = PyNumber_Float(r);

  001be	48 8b 4d 48	 mov	 rcx, QWORD PTR r$[rbp-128]
  001c2	85 c0		 test	 eax, eax
  001c4	0f 85 9e 00 00
	00		 jne	 $LN33@complex_ne
  001ca	e8 00 00 00 00	 call	 PyNumber_Float
  001cf	48 8b d8	 mov	 rbx, rax

; 986  :         if (own_r) {

  001d2	85 ff		 test	 edi, edi
  001d4	74 09		 je	 SHORT $LN11@complex_ne

; 987  :             /* r was a newly created complex number, rather
; 988  :                than the original "real" argument. */
; 989  :             Py_DECREF(r);

  001d6	48 8b 4d 48	 mov	 rcx, QWORD PTR r$[rbp-128]
  001da	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@complex_ne:

; 990  :         }
; 991  :         if (tmp == NULL)

  001df	48 85 db	 test	 rbx, rbx

; 992  :             return NULL;

  001e2	74 34		 je	 SHORT $LN41@complex_ne

; 993  :         if (!PyFloat_Check(tmp)) {

  001e4	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  001e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  001ef	48 3b ca	 cmp	 rcx, rdx
  001f2	74 55		 je	 SHORT $LN9@complex_ne
  001f4	e8 00 00 00 00	 call	 PyType_IsSubtype
  001f9	85 c0		 test	 eax, eax
  001fb	75 4c		 jne	 SHORT $LN9@complex_ne

; 994  :             PyErr_SetString(PyExc_TypeError,
; 995  :                             "float(r) didn't return a float");

  001fd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00204	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@OHCJGELG@float?$CIr?$CJ?5didn?8t?5return?5a?5float?$AA@
  0020b	e8 00 00 00 00	 call	 PyErr_SetString

; 996  :             Py_DECREF(tmp);

  00210	48 8b cb	 mov	 rcx, rbx
  00213	e8 00 00 00 00	 call	 _Py_DecRef
$LN41@complex_ne:

; 997  :             return NULL;

  00218	33 c0		 xor	 eax, eax
$LN40@complex_ne:
  0021a	0f 28 7c 24 60	 movaps	 xmm7, XMMWORD PTR [rsp+96]
  0021f	0f 28 74 24 70	 movaps	 xmm6, XMMWORD PTR [rsp+112]
  00224	48 8b 9c 24 b0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+176]
  0022c	44 0f 28 44 24
	50		 movaps	 xmm8, XMMWORD PTR [rsp+80]
$LN36@complex_ne:
  00232	4c 8b b4 24 b8
	00 00 00	 mov	 r14, QWORD PTR [rsp+184]

; 1030 : }

  0023a	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00241	41 5d		 pop	 r13
  00243	41 5c		 pop	 r12
  00245	5f		 pop	 rdi
  00246	5e		 pop	 rsi
  00247	5d		 pop	 rbp
  00248	c3		 ret	 0
$LN9@complex_ne:

; 998  :         }
; 999  :         cr.real = PyFloat_AsDouble(tmp);

  00249	48 8b cb	 mov	 rcx, rbx
  0024c	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 1000 :         cr.imag = 0.0; /* Shut up compiler warning */
; 1001 :         Py_DECREF(tmp);

  00251	48 8b cb	 mov	 rcx, rbx
  00254	66 44 0f 28 c6	 movapd	 xmm8, xmm6
  00259	66 0f 28 f8	 movapd	 xmm7, xmm0
  0025d	e8 00 00 00 00	 call	 _Py_DecRef
  00262	4c 8b 45 b0	 mov	 r8, QWORD PTR i$[rbp-128]
  00266	eb 32		 jmp	 SHORT $LN13@complex_ne
$LN33@complex_ne:
  00268	4c 8b 45 b0	 mov	 r8, QWORD PTR i$[rbp-128]
$LN14@complex_ne:

; 972  :         /* Note that if r is of a complex subtype, we're only
; 973  :            retaining its real & imag parts here, and the return
; 974  :            value is (properly) of the builtin complex type. */
; 975  :         cr = ((PyComplexObject*)r)->cval;

  0026c	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]

; 976  :         cr_is_complex = 1;

  00270	41 bd 01 00 00
	00		 mov	 r13d, 1
  00276	48 89 45 b8	 mov	 QWORD PTR cr$[rbp-128], rax
  0027a	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
  0027e	48 89 45 c0	 mov	 QWORD PTR cr$[rbp-120], rax

; 977  :         if (own_r) {

  00282	85 ff		 test	 edi, edi
  00284	74 09		 je	 SHORT $LN34@complex_ne

; 978  :             Py_DECREF(r);

  00286	e8 00 00 00 00	 call	 _Py_DecRef
  0028b	4c 8b 45 b0	 mov	 r8, QWORD PTR i$[rbp-128]
$LN34@complex_ne:
  0028f	f2 0f 10 7d b8	 movsdx	 xmm7, QWORD PTR cr$[rbp-128]
  00294	f2 44 0f 10 45
	c0		 movsdx	 xmm8, QWORD PTR cr$[rbp-120]
$LN13@complex_ne:

; 1002 :     }
; 1003 :     if (i == NULL) {

  0029a	4d 85 c0	 test	 r8, r8
  0029d	74 60		 je	 SHORT $LN2@complex_ne

; 1004 :         ci.real = 0.0;
; 1005 :     }
; 1006 :     else if (PyComplex_Check(i)) {

  0029f	4d 39 70 58	 cmp	 QWORD PTR [r8+88], r14
  002a3	74 40		 je	 SHORT $LN5@complex_ne
  002a5	49 8b 48 58	 mov	 rcx, QWORD PTR [r8+88]
  002a9	49 8b d6	 mov	 rdx, r14
  002ac	e8 00 00 00 00	 call	 PyType_IsSubtype
  002b1	85 c0		 test	 eax, eax
  002b3	75 2c		 jne	 SHORT $LN35@complex_ne

; 1008 :         ci_is_complex = 1;
; 1009 :     } else {
; 1010 :         /* The "imag" part really is entirely imaginary, and
; 1011 :            contributes nothing in the real direction.
; 1012 :            Just treat it as a double. */
; 1013 :         tmp = (*nbi->nb_float)(i);

  002b5	48 8b 4d b0	 mov	 rcx, QWORD PTR i$[rbp-128]
  002b9	ff 96 90 00 00
	00		 call	 QWORD PTR [rsi+144]
  002bf	48 8b d8	 mov	 rbx, rax

; 1014 :         if (tmp == NULL)

  002c2	48 85 c0	 test	 rax, rax

; 1015 :             return NULL;

  002c5	0f 84 4d ff ff
	ff		 je	 $LN41@complex_ne

; 1016 :         ci.real = PyFloat_AsDouble(tmp);

  002cb	48 8b c8	 mov	 rcx, rax
  002ce	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 1017 :         Py_DECREF(tmp);

  002d3	48 8b cb	 mov	 rcx, rbx
  002d6	66 0f 28 f0	 movapd	 xmm6, xmm0
  002da	e8 00 00 00 00	 call	 _Py_DecRef
  002df	eb 1e		 jmp	 SHORT $LN2@complex_ne
$LN35@complex_ne:
  002e1	4c 8b 45 b0	 mov	 r8, QWORD PTR i$[rbp-128]
$LN5@complex_ne:

; 1007 :         ci = ((PyComplexObject*)i)->cval;

  002e5	49 8b 40 60	 mov	 rax, QWORD PTR [r8+96]
  002e9	48 89 45 b8	 mov	 QWORD PTR ci$[rbp-128], rax
  002ed	49 8b 40 68	 mov	 rax, QWORD PTR [r8+104]

; 1018 :     }
; 1019 :     /*  If the input was in canonical form, then the "real" and "imag"
; 1020 :         parts are real numbers, so that ci.imag and cr.imag are zero.
; 1021 :         We need this correction in case they were not real numbers. */
; 1022 : 
; 1023 :     if (ci_is_complex) {
; 1024 :         cr.real -= ci.imag;

  002f1	f2 0f 10 75 b8	 movsdx	 xmm6, QWORD PTR ci$[rbp-128]
  002f6	48 89 45 c0	 mov	 QWORD PTR ci$[rbp-120], rax
  002fa	f2 0f 5c 7d c0	 subsd	 xmm7, QWORD PTR ci$[rbp-120]
$LN2@complex_ne:

; 1025 :     }
; 1026 :     if (cr_is_complex) {

  002ff	45 85 ed	 test	 r13d, r13d
  00302	74 05		 je	 SHORT $LN1@complex_ne

; 1027 :         ci.real += cr.imag;

  00304	f2 41 0f 58 f0	 addsd	 xmm6, xmm8
$LN1@complex_ne:

; 1028 :     }
; 1029 :     return complex_subtype_from_doubles(type, cr.real, ci.real);

  00309	66 0f 28 d6	 movapd	 xmm2, xmm6
  0030d	66 0f 28 cf	 movapd	 xmm1, xmm7
  00311	49 8b cc	 mov	 rcx, r12
  00314	e8 00 00 00 00	 call	 complex_subtype_from_doubles
  00319	e9 fc fe ff ff	 jmp	 $LN40@complex_ne
$LN17@complex_ne:

; 956  :         PyErr_SetString(PyExc_TypeError,
; 957  :                    "complex() argument must be a string or a number");

  0031e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00325	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@LGCEOOP@complex?$CI?$CJ?5argument?5must?5be?5a?5str@
  0032c	e8 00 00 00 00	 call	 PyErr_SetString

; 958  :         if (own_r) {

  00331	85 ff		 test	 edi, edi
  00333	74 09		 je	 SHORT $LN16@complex_ne

; 959  :             Py_DECREF(r);

  00335	48 8b 4d 48	 mov	 rcx, QWORD PTR r$[rbp-128]
  00339	e8 00 00 00 00	 call	 _Py_DecRef
$LN16@complex_ne:

; 960  :         }
; 961  :         return NULL;

  0033e	33 c0		 xor	 eax, eax
  00340	e9 ed fe ff ff	 jmp	 $LN36@complex_ne
complex_new ENDP
_TEXT	ENDS
END
