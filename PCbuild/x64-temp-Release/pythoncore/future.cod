; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CF@KIGBMAPF@future?5feature?5?$CF?4100s?5is?5not?5def@ ; `string'
PUBLIC	??_C@_0N@JONJKGOD@not?5a?5chance?$AA@		; `string'
PUBLIC	??_C@_06PPJPPEGJ@braces?$AA@			; `string'
PUBLIC	??_C@_0P@CALPMJDK@barry_as_FLUFL?$AA@		; `string'
PUBLIC	??_C@_0BB@GAMIIIAF@unicode_literals?$AA@	; `string'
PUBLIC	??_C@_0P@HDJNLGM@print_function?$AA@		; `string'
PUBLIC	??_C@_0P@KAIBPEGC@with_statement?$AA@		; `string'
PUBLIC	??_C@_0BA@DKNAAIIE@absolute_import?$AA@		; `string'
PUBLIC	??_C@_08DHDHNDEI@division?$AA@			; `string'
PUBLIC	??_C@_0L@FCNMNMNJ@generators?$AA@		; `string'
PUBLIC	??_C@_0O@LEAFGNOD@nested_scopes?$AA@		; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyErr_SyntaxLocationEx:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_SyntaxError:QWORD
EXTRN	PyUnicode_AsUTF8:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\future.c
pdata	SEGMENT
$pdata$future_check_features DD imagerel future_check_features
	DD	imagerel future_check_features+376
	DD	imagerel $unwind$future_check_features
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$future_check_features DD 0c2f01H
	DD	0b742fH
	DD	0a641bH
	DD	0c3412H
	DD	0f00e3212H
	DD	0d00ae00cH
	DD	05006c008H
xdata	ENDS
;	COMDAT ??_C@_0CF@KIGBMAPF@future?5feature?5?$CF?4100s?5is?5not?5def@
CONST	SEGMENT
??_C@_0CF@KIGBMAPF@future?5feature?5?$CF?4100s?5is?5not?5def@ DB 'future '
	DB	'feature %.100s is not defined', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JONJKGOD@not?5a?5chance?$AA@
CONST	SEGMENT
??_C@_0N@JONJKGOD@not?5a?5chance?$AA@ DB 'not a chance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PPJPPEGJ@braces?$AA@
CONST	SEGMENT
??_C@_06PPJPPEGJ@braces?$AA@ DB 'braces', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CALPMJDK@barry_as_FLUFL?$AA@
CONST	SEGMENT
??_C@_0P@CALPMJDK@barry_as_FLUFL?$AA@ DB 'barry_as_FLUFL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GAMIIIAF@unicode_literals?$AA@
CONST	SEGMENT
??_C@_0BB@GAMIIIAF@unicode_literals?$AA@ DB 'unicode_literals', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HDJNLGM@print_function?$AA@
CONST	SEGMENT
??_C@_0P@HDJNLGM@print_function?$AA@ DB 'print_function', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KAIBPEGC@with_statement?$AA@
CONST	SEGMENT
??_C@_0P@KAIBPEGC@with_statement?$AA@ DB 'with_statement', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DKNAAIIE@absolute_import?$AA@
CONST	SEGMENT
??_C@_0BA@DKNAAIIE@absolute_import?$AA@ DB 'absolute_import', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DHDHNDEI@division?$AA@
CONST	SEGMENT
??_C@_08DHDHNDEI@division?$AA@ DB 'division', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FCNMNMNJ@generators?$AA@
CONST	SEGMENT
??_C@_0L@FCNMNMNJ@generators?$AA@ DB 'generators', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LEAFGNOD@nested_scopes?$AA@
CONST	SEGMENT
??_C@_0O@LEAFGNOD@nested_scopes?$AA@ DB 'nested_scopes', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT future_check_features
_TEXT	SEGMENT
ff$ = 80
s$ = 88
filename$ = 96
future_check_features PROC				; COMDAT

; 15   : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	41 56		 push	 r14
  0000c	41 57		 push	 r15
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 16   :     int i;
; 17   :     asdl_seq *names;
; 18   : 
; 19   :     assert(s->kind == ImportFrom_kind);
; 20   : 
; 21   :     names = s->v.ImportFrom.names;

  00012	4c 8b 6a 10	 mov	 r13, QWORD PTR [rdx+16]
  00016	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0001b	4d 8b f8	 mov	 r15, r8
  0001e	48 8b da	 mov	 rbx, rdx
  00021	4c 8b f1	 mov	 r14, rcx

; 22   :     for (i = 0; i < asdl_seq_LEN(names); i++) {

  00024	33 ed		 xor	 ebp, ebp
  00026	4d 8d 65 08	 lea	 r12, QWORD PTR [r13+8]
  0002a	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  0002f	90		 npad	 1
$LL22@future_che:
  00030	4d 85 ed	 test	 r13, r13
  00033	75 04		 jne	 SHORT $LN25@future_che
  00035	33 c9		 xor	 ecx, ecx
  00037	eb 04		 jmp	 SHORT $LN26@future_che
$LN25@future_che:
  00039	49 8b 4d 00	 mov	 rcx, QWORD PTR [r13]
$LN26@future_che:
  0003d	48 63 c5	 movsxd	 rax, ebp
  00040	48 3b c1	 cmp	 rax, rcx
  00043	0f 8d 0d 01 00
	00		 jge	 $LN20@future_che

; 23   :         alias_ty name = (alias_ty)asdl_seq_GET(names, i);

  00049	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]

; 24   :         const char *feature = _PyUnicode_AsString(name->name);

  0004d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00050	e8 00 00 00 00	 call	 PyUnicode_AsUTF8

; 25   :         if (!feature)

  00055	48 85 c0	 test	 rax, rax
  00058	0f 84 e3 00 00
	00		 je	 $LN28@future_che

; 26   :             return 0;
; 27   :         if (strcmp(feature, FUTURE_NESTED_SCOPES) == 0) {

  0005e	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0O@LEAFGNOD@nested_scopes?$AA@
  00065	48 8b f0	 mov	 rsi, rax
  00068	b9 0e 00 00 00	 mov	 ecx, 14
  0006d	f3 a6		 repe cmpsb
  0006f	0f 84 8c 00 00
	00		 je	 $LN21@future_che

; 28   :             continue;
; 29   :         } else if (strcmp(feature, FUTURE_GENERATORS) == 0) {

  00075	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0L@FCNMNMNJ@generators?$AA@
  0007c	48 8b f0	 mov	 rsi, rax
  0007f	b9 0b 00 00 00	 mov	 ecx, 11
  00084	f3 a6		 repe cmpsb
  00086	74 79		 je	 SHORT $LN21@future_che

; 30   :             continue;
; 31   :         } else if (strcmp(feature, FUTURE_DIVISION) == 0) {

  00088	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_08DHDHNDEI@division?$AA@
  0008f	48 8b f0	 mov	 rsi, rax
  00092	b9 09 00 00 00	 mov	 ecx, 9
  00097	f3 a6		 repe cmpsb
  00099	74 66		 je	 SHORT $LN21@future_che

; 32   :             continue;
; 33   :         } else if (strcmp(feature, FUTURE_ABSOLUTE_IMPORT) == 0) {

  0009b	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0BA@DKNAAIIE@absolute_import?$AA@
  000a2	48 8b f0	 mov	 rsi, rax
  000a5	b9 10 00 00 00	 mov	 ecx, 16
  000aa	f3 a6		 repe cmpsb
  000ac	74 53		 je	 SHORT $LN21@future_che

; 34   :             continue;
; 35   :         } else if (strcmp(feature, FUTURE_WITH_STATEMENT) == 0) {

  000ae	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0P@KAIBPEGC@with_statement?$AA@
  000b5	48 8b f0	 mov	 rsi, rax
  000b8	b9 0f 00 00 00	 mov	 ecx, 15
  000bd	f3 a6		 repe cmpsb
  000bf	74 40		 je	 SHORT $LN21@future_che

; 36   :             continue;
; 37   :         } else if (strcmp(feature, FUTURE_PRINT_FUNCTION) == 0) {

  000c1	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0P@HDJNLGM@print_function?$AA@
  000c8	48 8b f0	 mov	 rsi, rax
  000cb	b9 0f 00 00 00	 mov	 ecx, 15
  000d0	f3 a6		 repe cmpsb
  000d2	74 2d		 je	 SHORT $LN21@future_che

; 38   :             continue;
; 39   :         } else if (strcmp(feature, FUTURE_UNICODE_LITERALS) == 0) {

  000d4	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0BB@GAMIIIAF@unicode_literals?$AA@
  000db	48 8b f0	 mov	 rsi, rax
  000de	b9 11 00 00 00	 mov	 ecx, 17
  000e3	f3 a6		 repe cmpsb
  000e5	74 1a		 je	 SHORT $LN21@future_che

; 40   :             continue;
; 41   :         } else if (strcmp(feature, FUTURE_BARRY_AS_BDFL) == 0) {

  000e7	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0P@CALPMJDK@barry_as_FLUFL?$AA@
  000ee	48 8b f0	 mov	 rsi, rax
  000f1	b9 0f 00 00 00	 mov	 ecx, 15
  000f6	f3 a6		 repe cmpsb
  000f8	75 12		 jne	 SHORT $LN4@future_che

; 42   :             ff->ff_features |= CO_FUTURE_BARRY_AS_BDFL;

  000fa	41 81 0e 00 00
	04 00		 or	 DWORD PTR [r14], 262144	; 00040000H
$LN21@future_che:

; 22   :     for (i = 0; i < asdl_seq_LEN(names); i++) {

  00101	ff c5		 inc	 ebp
  00103	49 83 c4 08	 add	 r12, 8
  00107	e9 24 ff ff ff	 jmp	 $LL22@future_che
$LN4@future_che:

; 43   :         } else if (strcmp(feature, "braces") == 0) {

  0010c	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06PPJPPEGJ@braces?$AA@
  00113	48 8b f0	 mov	 rsi, rax
  00116	b9 07 00 00 00	 mov	 ecx, 7
  0011b	f3 a6		 repe cmpsb

; 44   :             PyErr_SetString(PyExc_SyntaxError,
; 45   :                             "not a chance");

  0011d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxError
  00124	75 1f		 jne	 SHORT $LN2@future_che
  00126	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@JONJKGOD@not?5a?5chance?$AA@
  0012d	e8 00 00 00 00	 call	 PyErr_SetString
$LN29@future_che:

; 46   :             PyErr_SyntaxLocationEx(filename, s->lineno, s->col_offset);

  00132	44 8b 43 44	 mov	 r8d, DWORD PTR [rbx+68]
  00136	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  00139	49 8b cf	 mov	 rcx, r15
  0013c	e8 00 00 00 00	 call	 PyErr_SyntaxLocationEx
$LN28@future_che:

; 47   :             return 0;

  00141	33 c0		 xor	 eax, eax
  00143	eb 16		 jmp	 SHORT $LN23@future_che
$LN2@future_che:

; 48   :         } else {
; 49   :             PyErr_Format(PyExc_SyntaxError,
; 50   :                          UNDEFINED_FUTURE_FEATURE, feature);

  00145	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@KIGBMAPF@future?5feature?5?$CF?4100s?5is?5not?5def@
  0014c	4c 8b c0	 mov	 r8, rax
  0014f	e8 00 00 00 00	 call	 PyErr_Format

; 51   :             PyErr_SyntaxLocationEx(filename, s->lineno, s->col_offset);
; 52   :             return 0;

  00154	eb dc		 jmp	 SHORT $LN29@future_che
$LN20@future_che:

; 53   :         }
; 54   :     }
; 55   :     return 1;

  00156	b8 01 00 00 00	 mov	 eax, 1
$LN23@future_che:
  0015b	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00160	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 56   : }

  00165	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0016a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016e	41 5f		 pop	 r15
  00170	41 5e		 pop	 r14
  00172	41 5d		 pop	 r13
  00174	41 5c		 pop	 r12
  00176	5d		 pop	 rbp
  00177	c3		 ret	 0
future_check_features ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EA@GLIDBFMH@from?5__future__?5imports?5must?5occ@ ; `string'
PUBLIC	??_C@_0L@GKAJCJCM@__future__?$AA@		; `string'
EXTRN	PyUnicode_CompareWithASCIIString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$future_parse DD imagerel future_parse
	DD	imagerel future_parse+328
	DD	imagerel $unwind$future_parse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$future_parse DD 0c4c01H
	DD	0d644cH
	DD	0b5447H
	DD	0a3442H
	DD	0f00e3212H
	DD	0d00ae00cH
	DD	07006c008H
xdata	ENDS
;	COMDAT ??_C@_0EA@GLIDBFMH@from?5__future__?5imports?5must?5occ@
CONST	SEGMENT
??_C@_0EA@GLIDBFMH@from?5__future__?5imports?5must?5occ@ DB 'from __futur'
	DB	'e__ imports must occur at the beginning of the file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GKAJCJCM@__future__?$AA@
CONST	SEGMENT
??_C@_0L@GKAJCJCM@__future__?$AA@ DB '__future__', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT future_parse
_TEXT	SEGMENT
ff$ = 80
mod$ = 88
filename$ = 96
future_parse PROC					; COMDAT

; 60   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	57		 push	 rdi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	41 56		 push	 r14
  0000c	41 57		 push	 r15
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 61   :     int i, found_docstring = 0, done = 0, prev_line = 0;
; 62   : 
; 63   :     if (!(mod->kind == Module_kind || mod->kind == Interactive_kind))

  00012	8b 02		 mov	 eax, DWORD PTR [rdx]
  00014	45 33 e4	 xor	 r12d, r12d
  00017	33 ff		 xor	 edi, edi
  00019	45 33 ed	 xor	 r13d, r13d
  0001c	4c 8b fa	 mov	 r15, rdx
  0001f	4c 8b f1	 mov	 r14, rcx
  00022	83 f8 01	 cmp	 eax, 1
  00025	74 16		 je	 SHORT $LN15@future_par
  00027	83 f8 02	 cmp	 eax, 2
  0002a	74 11		 je	 SHORT $LN15@future_par

; 64   :         return 1;

  0002c	8d 47 01	 lea	 eax, QWORD PTR [rdi+1]

; 116  : }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	41 5f		 pop	 r15
  00035	41 5e		 pop	 r14
  00037	41 5d		 pop	 r13
  00039	41 5c		 pop	 r12
  0003b	5f		 pop	 rdi
  0003c	c3		 ret	 0
$LN15@future_par:
  0003d	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00042	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  00047	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi

; 65   : 
; 66   :     /* A subsequent pass will detect future imports that don't
; 67   :        appear at the beginning of the file.  There's one case,
; 68   :        however, that is easier to handle here: A series of imports
; 69   :        joined by semi-colons, where the first import is a future
; 70   :        statement but some subsequent import has the future form
; 71   :        but is preceded by a regular import.
; 72   :     */
; 73   : 
; 74   : 
; 75   :     for (i = 0; i < asdl_seq_LEN(mod->v.Module.body); i++) {

  0004c	33 ed		 xor	 ebp, ebp
  0004e	33 f6		 xor	 esi, esi
$LL14@future_par:
  00050	49 8b 5f 08	 mov	 rbx, QWORD PTR [r15+8]
  00054	48 85 db	 test	 rbx, rbx
  00057	75 04		 jne	 SHORT $LN18@future_par
  00059	33 c9		 xor	 ecx, ecx
  0005b	eb 03		 jmp	 SHORT $LN19@future_par
$LN18@future_par:
  0005d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN19@future_par:
  00060	48 63 c5	 movsxd	 rax, ebp
  00063	48 3b c1	 cmp	 rax, rcx
  00066	0f 8d ba 00 00
	00		 jge	 $LN12@future_par

; 76   :         stmt_ty s = (stmt_ty)asdl_seq_GET(mod->v.Module.body, i);

  0006c	48 8b 5c 1e 08	 mov	 rbx, QWORD PTR [rsi+rbx+8]

; 77   : 
; 78   :         if (done && s->lineno > prev_line)

  00071	85 ff		 test	 edi, edi
  00073	74 0a		 je	 SHORT $LN11@future_par
  00075	44 39 6b 40	 cmp	 DWORD PTR [rbx+64], r13d
  00079	0f 8f a7 00 00
	00		 jg	 $LN12@future_par
$LN11@future_par:

; 79   :             return 1;
; 80   :         prev_line = s->lineno;
; 81   : 
; 82   :         /* The tests below will return from this function unless it is
; 83   :            still possible to find a future statement.  The only things
; 84   :            that can precede a future statement are another future
; 85   :            statement and a doc string.
; 86   :         */
; 87   : 
; 88   :         if (s->kind == ImportFrom_kind) {

  0007f	8b 03		 mov	 eax, DWORD PTR [rbx]
  00081	44 8b 6b 40	 mov	 r13d, DWORD PTR [rbx+64]
  00085	83 f8 0f	 cmp	 eax, 15
  00088	75 40		 jne	 SHORT $LN10@future_par

; 89   :             identifier modname = s->v.ImportFrom.module;

  0008a	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]

; 90   :             if (modname &&
; 91   :                 !PyUnicode_CompareWithASCIIString(modname, "__future__")) {

  0008e	48 85 c9	 test	 rcx, rcx
  00091	74 5b		 je	 SHORT $LN4@future_par
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@GKAJCJCM@__future__?$AA@
  0009a	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  0009f	85 c0		 test	 eax, eax
  000a1	75 4b		 jne	 SHORT $LN4@future_par

; 92   :                 if (done) {

  000a3	85 ff		 test	 edi, edi
  000a5	75 57		 jne	 SHORT $LN22@future_par

; 97   :                 }
; 98   :                 if (!future_check_features(ff, s, filename))

  000a7	4c 8b 44 24 60	 mov	 r8, QWORD PTR filename$[rsp]
  000ac	48 8b d3	 mov	 rdx, rbx
  000af	49 8b ce	 mov	 rcx, r14
  000b2	e8 00 00 00 00	 call	 future_check_features
  000b7	85 c0		 test	 eax, eax
  000b9	74 67		 je	 SHORT $LN23@future_par

; 99   :                     return 0;
; 100  :                 ff->ff_lineno = s->lineno;

  000bb	8b 43 40	 mov	 eax, DWORD PTR [rbx+64]
  000be	ff c5		 inc	 ebp
  000c0	48 83 c6 08	 add	 rsi, 8
  000c4	41 89 46 04	 mov	 DWORD PTR [r14+4], eax
  000c8	eb 86		 jmp	 SHORT $LL14@future_par
$LN10@future_par:

; 101  :             }
; 102  :             else
; 103  :                 done = 1;
; 104  :         }
; 105  :         else if (s->kind == Expr_kind && !found_docstring) {

  000ca	83 f8 12	 cmp	 eax, 18
  000cd	75 1f		 jne	 SHORT $LN4@future_par
  000cf	45 85 e4	 test	 r12d, r12d
  000d2	75 1a		 jne	 SHORT $LN4@future_par

; 106  :             expr_ty e = s->v.Expr.value;

  000d4	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]

; 107  :             if (e->kind != Str_kind)

  000d8	83 38 11	 cmp	 DWORD PTR [rax], 17

; 108  :                 done = 1;
; 109  :             else

  000db	75 11		 jne	 SHORT $LN4@future_par

; 110  :                 found_docstring = 1;

  000dd	ff c5		 inc	 ebp
  000df	41 bc 01 00 00
	00		 mov	 r12d, 1
  000e5	48 83 c6 08	 add	 rsi, 8
  000e9	e9 62 ff ff ff	 jmp	 $LL14@future_par
$LN4@future_par:

; 65   : 
; 66   :     /* A subsequent pass will detect future imports that don't
; 67   :        appear at the beginning of the file.  There's one case,
; 68   :        however, that is easier to handle here: A series of imports
; 69   :        joined by semi-colons, where the first import is a future
; 70   :        statement but some subsequent import has the future form
; 71   :        but is preceded by a regular import.
; 72   :     */
; 73   : 
; 74   : 
; 75   :     for (i = 0; i < asdl_seq_LEN(mod->v.Module.body); i++) {

  000ee	ff c5		 inc	 ebp

; 111  :         }
; 112  :         else
; 113  :             done = 1;

  000f0	bf 01 00 00 00	 mov	 edi, 1
  000f5	48 83 c6 08	 add	 rsi, 8
  000f9	e9 52 ff ff ff	 jmp	 $LL14@future_par
$LN22@future_par:

; 93   :                     PyErr_SetString(PyExc_SyntaxError,
; 94   :                                     ERR_LATE_FUTURE);

  000fe	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxError
  00105	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EA@GLIDBFMH@from?5__future__?5imports?5must?5occ@
  0010c	e8 00 00 00 00	 call	 PyErr_SetString

; 95   :                     PyErr_SyntaxLocationEx(filename, s->lineno, s->col_offset);

  00111	44 8b 43 44	 mov	 r8d, DWORD PTR [rbx+68]
  00115	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]
  00118	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filename$[rsp]
  0011d	e8 00 00 00 00	 call	 PyErr_SyntaxLocationEx
$LN23@future_par:

; 96   :                     return 0;

  00122	33 c0		 xor	 eax, eax
  00124	eb 05		 jmp	 SHORT $LN26@future_par
$LN12@future_par:

; 114  :     }
; 115  :     return 1;

  00126	b8 01 00 00 00	 mov	 eax, 1
$LN26@future_par:
  0012b	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00130	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00135	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]

; 116  : }

  0013a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013e	41 5f		 pop	 r15
  00140	41 5e		 pop	 r14
  00142	41 5d		 pop	 r13
  00144	41 5c		 pop	 r12
  00146	5f		 pop	 rdi
  00147	c3		 ret	 0
future_parse ENDP
_TEXT	ENDS
PUBLIC	PyFuture_FromAST
EXTRN	PyObject_Free:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyObject_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyFuture_FromAST DD imagerel $LN5
	DD	imagerel $LN5+138
	DD	imagerel $unwind$PyFuture_FromAST
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyFuture_FromAST DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyFuture_FromAST
_TEXT	SEGMENT
mod$ = 48
filename$ = 56
PyFuture_FromAST PROC					; COMDAT

; 121  : {

$LN5:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f1	 mov	 rsi, rcx

; 122  :     PyFutureFeatures *ff;
; 123  : 
; 124  :     ff = (PyFutureFeatures *)PyObject_Malloc(sizeof(PyFutureFeatures));

  00012	b9 08 00 00 00	 mov	 ecx, 8
  00017	48 8b fa	 mov	 rdi, rdx
  0001a	e8 00 00 00 00	 call	 PyObject_Malloc
  0001f	48 8b d8	 mov	 rbx, rax

; 125  :     if (ff == NULL) {

  00022	48 85 c0	 test	 rax, rax
  00025	75 17		 jne	 SHORT $LN2@PyFuture_F

; 126  :         PyErr_NoMemory();

  00027	e8 00 00 00 00	 call	 PyErr_NoMemory

; 127  :         return NULL;

  0002c	33 c0		 xor	 eax, eax

; 135  :     }
; 136  :     return ff;
; 137  : }

  0002e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00033	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5f		 pop	 rdi
  0003d	c3		 ret	 0
$LN2@PyFuture_F:

; 128  :     }
; 129  :     ff->ff_features = 0;
; 130  :     ff->ff_lineno = -1;
; 131  : 
; 132  :     if (!future_parse(ff, mod, filename)) {

  0003e	4c 8b c7	 mov	 r8, rdi
  00041	48 8b d6	 mov	 rdx, rsi
  00044	48 8b c8	 mov	 rcx, rax
  00047	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  0004d	c7 40 04 ff ff
	ff ff		 mov	 DWORD PTR [rax+4], -1
  00054	e8 00 00 00 00	 call	 future_parse
  00059	85 c0		 test	 eax, eax
  0005b	75 1a		 jne	 SHORT $LN1@PyFuture_F

; 133  :         PyObject_Free(ff);

  0005d	48 8b cb	 mov	 rcx, rbx
  00060	e8 00 00 00 00	 call	 PyObject_Free

; 134  :         return NULL;

  00065	33 c0		 xor	 eax, eax

; 135  :     }
; 136  :     return ff;
; 137  : }

  00067	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00071	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
$LN1@PyFuture_F:
  00077	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007c	48 8b c3	 mov	 rax, rbx
  0007f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00084	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00088	5f		 pop	 rdi
  00089	c3		 ret	 0
PyFuture_FromAST ENDP
_TEXT	ENDS
END
