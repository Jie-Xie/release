; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
no_grouping DB	07fH
_DATA	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@JJODEGPF@Unknown?5format?5code?5?8?2x?$CFx?8?5for?5o@ ; `string'
PUBLIC	??_C@_0DF@GEJEKBFN@Unknown?5format?5code?5?8?$CFc?8?5for?5obj@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_ValueError:QWORD
;	COMDAT ??_C@_0DH@JJODEGPF@Unknown?5format?5code?5?8?2x?$CFx?8?5for?5o@
; File c:\src\pyparallel\python\formatter_unicode.c
CONST	SEGMENT
??_C@_0DH@JJODEGPF@Unknown?5format?5code?5?8?2x?$CFx?8?5for?5o@ DB 'Unkno'
	DB	'wn format code ''\x%x'' for object of type ''%.200s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GEJEKBFN@Unknown?5format?5code?5?8?$CFc?8?5for?5obj@
CONST	SEGMENT
??_C@_0DF@GEJEKBFN@Unknown?5format?5code?5?8?$CFc?8?5for?5obj@ DB 'Unknow'
	DB	'n format code ''%c'' for object of type ''%.200s''', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unknown_presentation_type
_TEXT	SEGMENT
presentation_type$ = 8
type_name$ = 16
unknown_presentation_type PROC				; COMDAT

; 15   :     /* %c might be out-of-range, hence the two cases. */
; 16   :     if (presentation_type > 32 && presentation_type < 128)

  00000	8d 41 df	 lea	 eax, DWORD PTR [rcx-33]

; 17   :         PyErr_Format(PyExc_ValueError,
; 18   :                      "Unknown format code '%c' "
; 19   :                      "for object of type '%.200s'",
; 20   :                      (char)presentation_type,
; 21   :                      type_name);

  00003	4c 8b ca	 mov	 r9, rdx
  00006	83 f8 5e	 cmp	 eax, 94			; 0000005eH
  00009	77 17		 ja	 SHORT $LN2@unknown_pr
  0000b	44 0f be c1	 movsx	 r8d, cl

; 22   :     else
; 23   :         PyErr_Format(PyExc_ValueError,
; 24   :                      "Unknown format code '\\x%x' "
; 25   :                      "for object of type '%.200s'",
; 26   :                      (unsigned int)presentation_type,
; 27   :                      type_name);

  0000f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@GEJEKBFN@Unknown?5format?5code?5?8?$CFc?8?5for?5obj@

; 28   : }

  0001d	e9 00 00 00 00	 jmp	 PyErr_Format
$LN2@unknown_pr:

; 22   :     else
; 23   :         PyErr_Format(PyExc_ValueError,
; 24   :                      "Unknown format code '\\x%x' "
; 25   :                      "for object of type '%.200s'",
; 26   :                      (unsigned int)presentation_type,
; 27   :                      type_name);

  00022	44 8b c1	 mov	 r8d, ecx
  00025	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@JJODEGPF@Unknown?5format?5code?5?8?2x?$CFx?8?5for?5o@

; 28   : }

  00033	e9 00 00 00 00	 jmp	 PyErr_Format
unknown_presentation_type ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@KFPPEOBD@Cannot?5specify?5?8?0?8?5with?5?8?2x?$CFx?8?4?$AA@ ; `string'
PUBLIC	??_C@_0BO@MNAJLJIO@Cannot?5specify?5?8?0?8?5with?5?8?$CFc?8?4?$AA@ ; `string'
;	COMDAT ??_C@_0CA@KFPPEOBD@Cannot?5specify?5?8?0?8?5with?5?8?2x?$CFx?8?4?$AA@
CONST	SEGMENT
??_C@_0CA@KFPPEOBD@Cannot?5specify?5?8?0?8?5with?5?8?2x?$CFx?8?4?$AA@ DB 'C'
	DB	'annot specify '','' with ''\x%x''.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MNAJLJIO@Cannot?5specify?5?8?0?8?5with?5?8?$CFc?8?4?$AA@
CONST	SEGMENT
??_C@_0BO@MNAJLJIO@Cannot?5specify?5?8?0?8?5with?5?8?$CFc?8?4?$AA@ DB 'Ca'
	DB	'nnot specify '','' with ''%c''.', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT invalid_comma_type
_TEXT	SEGMENT
presentation_type$ = 8
invalid_comma_type PROC					; COMDAT

; 33   :     if (presentation_type > 32 && presentation_type < 128)

  00000	8d 41 df	 lea	 eax, DWORD PTR [rcx-33]
  00003	83 f8 5e	 cmp	 eax, 94			; 0000005eH
  00006	77 17		 ja	 SHORT $LN2@invalid_co

; 34   :         PyErr_Format(PyExc_ValueError,
; 35   :                      "Cannot specify ',' with '%c'.",
; 36   :                      (char)presentation_type);

  00008	44 0f be c1	 movsx	 r8d, cl

; 37   :     else
; 38   :         PyErr_Format(PyExc_ValueError,
; 39   :                      "Cannot specify ',' with '\\x%x'.",
; 40   :                      (unsigned int)presentation_type);

  0000c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@MNAJLJIO@Cannot?5specify?5?8?0?8?5with?5?8?$CFc?8?4?$AA@

; 41   : }

  0001a	e9 00 00 00 00	 jmp	 PyErr_Format
$LN2@invalid_co:

; 37   :     else
; 38   :         PyErr_Format(PyExc_ValueError,
; 39   :                      "Cannot specify ',' with '\\x%x'.",
; 40   :                      (unsigned int)presentation_type);

  0001f	44 8b c1	 mov	 r8d, ecx
  00022	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@KFPPEOBD@Cannot?5specify?5?8?0?8?5with?5?8?2x?$CFx?8?4?$AA@

; 41   : }

  00030	e9 00 00 00 00	 jmp	 PyErr_Format
invalid_comma_type ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@BALCLOM@Too?5many?5decimal?5digits?5in?5forma@ ; `string'
EXTRN	_PyUnicode_ToDecimalDigit:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_integer DD imagerel get_integer
	DD	imagerel get_integer+379
	DD	imagerel $unwind$get_integer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_integer DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT ??_C@_0CJ@BALCLOM@Too?5many?5decimal?5digits?5in?5forma@
CONST	SEGMENT
??_C@_0CJ@BALCLOM@Too?5many?5decimal?5digits?5in?5forma@ DB 'Too many dec'
	DB	'imal digits in format string', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT get_integer
_TEXT	SEGMENT
str$ = 80
pos$ = 88
end$ = 96
result$ = 104
get_integer PROC					; COMDAT

; 53   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 54   :     Py_ssize_t accumulator, digitval;
; 55   :     int numdigits;
; 56   :     accumulator = numdigits = 0;

  0001c	33 ed		 xor	 ebp, ebp
  0001e	4d 8b e9	 mov	 r13, r9
  00021	4d 8b e0	 mov	 r12, r8
  00024	48 8b fa	 mov	 rdi, rdx
  00027	48 8b d9	 mov	 rbx, rcx
  0002a	8b f5		 mov	 esi, ebp

; 57   :     for (;;(*pos)++, numdigits++) {
; 58   :         if (*pos >= end)

  0002c	4c 39 02	 cmp	 QWORD PTR [rdx], r8
  0002f	0f 8d 0b 01 00
	00		 jge	 $LN27@get_intege
  00035	49 be ff ff ff
	ff ff ff ff 7f	 mov	 r14, 9223372036854775807 ; 7fffffffffffffffH
  0003f	49 bf 67 66 66
	66 66 66 66 66	 mov	 r15, 7378697629483820647 ; 6666666666666667H
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@get_intege:

; 59   :             break;
; 60   :         digitval = Py_UNICODE_TODECIMAL(PyUnicode_READ_CHAR(str, *pos));

  00050	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00053	8b c8		 mov	 ecx, eax
  00055	c1 e9 02	 shr	 ecx, 2
  00058	83 e1 07	 and	 ecx, 7
  0005b	83 f9 01	 cmp	 ecx, 1
  0005e	75 3b		 jne	 SHORT $LN23@get_intege
  00060	a8 20		 test	 al, 32			; 00000020H
  00062	74 27		 je	 SHORT $LN11@get_intege
  00064	a8 40		 test	 al, 64			; 00000040H
  00066	74 13		 je	 SHORT $LN9@get_intege
  00068	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0006b	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  00072	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00076	e9 84 00 00 00	 jmp	 $LN22@get_intege
$LN9@get_intege:
  0007b	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0007e	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  00085	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00089	eb 74		 jmp	 SHORT $LN22@get_intege
$LN11@get_intege:
  0008b	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
  00092	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00095	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00099	eb 64		 jmp	 SHORT $LN22@get_intege
$LN23@get_intege:
  0009b	83 f9 02	 cmp	 ecx, 2
  0009e	75 38		 jne	 SHORT $LN21@get_intege
  000a0	a8 20		 test	 al, 32			; 00000020H
  000a2	74 24		 je	 SHORT $LN15@get_intege
  000a4	a8 40		 test	 al, 64			; 00000040H
  000a6	74 10		 je	 SHORT $LN13@get_intege
  000a8	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000ab	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  000b2	0f b7 0c 41	 movzx	 ecx, WORD PTR [rcx+rax*2]
  000b6	eb 47		 jmp	 SHORT $LN22@get_intege
$LN13@get_intege:
  000b8	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000bb	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  000c2	0f b7 0c 41	 movzx	 ecx, WORD PTR [rcx+rax*2]
  000c6	eb 37		 jmp	 SHORT $LN22@get_intege
$LN15@get_intege:
  000c8	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
  000cf	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000d2	0f b7 0c 41	 movzx	 ecx, WORD PTR [rcx+rax*2]
  000d6	eb 27		 jmp	 SHORT $LN22@get_intege
$LN21@get_intege:
  000d8	a8 20		 test	 al, 32			; 00000020H
  000da	74 16		 je	 SHORT $LN19@get_intege
  000dc	a8 40		 test	 al, 64			; 00000040H
  000de	74 09		 je	 SHORT $LN17@get_intege
  000e0	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  000e7	eb 10		 jmp	 SHORT $LN20@get_intege
$LN17@get_intege:
  000e9	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  000f0	eb 07		 jmp	 SHORT $LN20@get_intege
$LN19@get_intege:
  000f2	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
$LN20@get_intege:
  000f9	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000fc	8b 0c 81	 mov	 ecx, DWORD PTR [rcx+rax*4]
$LN22@get_intege:
  000ff	e8 00 00 00 00	 call	 _PyUnicode_ToDecimalDigit
  00104	4c 63 c0	 movsxd	 r8, eax

; 61   :         if (digitval < 0)

  00107	85 c0		 test	 eax, eax
  00109	78 35		 js	 SHORT $LN27@get_intege

; 62   :             break;
; 63   :         /*
; 64   :            Detect possible overflow before it happens:
; 65   : 
; 66   :               accumulator * 10 + digitval > PY_SSIZE_T_MAX if and only if
; 67   :               accumulator > (PY_SSIZE_T_MAX - digitval) / 10.
; 68   :         */
; 69   :         if (accumulator > (PY_SSIZE_T_MAX - digitval) / 10) {

  0010b	49 8b ce	 mov	 rcx, r14
  0010e	49 8b c7	 mov	 rax, r15
  00111	49 2b c8	 sub	 rcx, r8
  00114	48 f7 e9	 imul	 rcx
  00117	48 c1 fa 02	 sar	 rdx, 2
  0011b	48 8b c2	 mov	 rax, rdx
  0011e	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00122	48 03 d0	 add	 rdx, rax
  00125	48 3b f2	 cmp	 rsi, rdx
  00128	7f 39		 jg	 SHORT $LN29@get_intege

; 73   :         }
; 74   :         accumulator = accumulator * 10 + digitval;

  0012a	48 ff 07	 inc	 QWORD PTR [rdi]
  0012d	48 8d 04 b6	 lea	 rax, QWORD PTR [rsi+rsi*4]
  00131	ff c5		 inc	 ebp
  00133	49 8d 34 40	 lea	 rsi, QWORD PTR [r8+rax*2]
  00137	4c 39 27	 cmp	 QWORD PTR [rdi], r12
  0013a	0f 8c 10 ff ff
	ff		 jl	 $LL6@get_intege
$LN27@get_intege:

; 75   :     }
; 76   :     *result = accumulator;

  00140	49 89 75 00	 mov	 QWORD PTR [r13], rsi

; 77   :     return numdigits;

  00144	8b c5		 mov	 eax, ebp
$LN7@get_intege:

; 78   : }

  00146	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0014b	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00150	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00155	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00159	41 5f		 pop	 r15
  0015b	41 5e		 pop	 r14
  0015d	41 5d		 pop	 r13
  0015f	41 5c		 pop	 r12
  00161	5f		 pop	 rdi
  00162	c3		 ret	 0
$LN29@get_intege:

; 70   :             PyErr_Format(PyExc_ValueError,
; 71   :                          "Too many decimal digits in format string");

  00163	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0016a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@BALCLOM@Too?5many?5decimal?5digits?5in?5forma@
  00171	e8 00 00 00 00	 call	 PyErr_Format

; 72   :             return -1;

  00176	83 c8 ff	 or	 eax, -1
  00179	eb cb		 jmp	 SHORT $LN7@get_intege
get_integer ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT is_alignment_token
_TEXT	SEGMENT
c$ = 8
is_alignment_token PROC					; COMDAT

; 88   :     switch (c) {

  00000	83 f9 3c	 cmp	 ecx, 60			; 0000003cH
  00003	72 10		 jb	 SHORT $LN1@is_alignme
  00005	83 f9 3e	 cmp	 ecx, 62			; 0000003eH
  00008	76 05		 jbe	 SHORT $LN2@is_alignme
  0000a	83 f9 5e	 cmp	 ecx, 94			; 0000005eH
  0000d	75 06		 jne	 SHORT $LN1@is_alignme
$LN2@is_alignme:

; 89   :     case '<': case '>': case '=': case '^':
; 90   :         return 1;

  0000f	b8 01 00 00 00	 mov	 eax, 1

; 93   :     }
; 94   : }

  00014	c3		 ret	 0
$LN1@is_alignme:

; 91   :     default:
; 92   :         return 0;

  00015	33 c0		 xor	 eax, eax

; 93   :     }
; 94   : }

  00017	c3		 ret	 0
is_alignment_token ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT is_sign_element
_TEXT	SEGMENT
c$ = 8
is_sign_element PROC					; COMDAT

; 100  :     switch (c) {

  00000	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00003	74 0d		 je	 SHORT $LN2@is_sign_el
  00005	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  00008	74 08		 je	 SHORT $LN2@is_sign_el
  0000a	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  0000d	74 03		 je	 SHORT $LN2@is_sign_el

; 103  :     default:
; 104  :         return 0;

  0000f	33 c0		 xor	 eax, eax

; 105  :     }
; 106  : }

  00011	c3		 ret	 0
$LN2@is_sign_el:

; 101  :     case ' ': case '+': case '-':
; 102  :         return 1;

  00012	b8 01 00 00 00	 mov	 eax, 1

; 105  :     }
; 106  : }

  00017	c3		 ret	 0
is_sign_element ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@BLPJLLHL@Invalid?5format?5specifier?$AA@ ; `string'
PUBLIC	??_C@_0CD@POOGFIMB@Format?5specifier?5missing?5precisi@ ; `string'
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$parse_internal_render_format_spec DD imagerel parse_internal_render_format_spec
	DD	imagerel parse_internal_render_format_spec+2660
	DD	imagerel $unwind$parse_internal_render_format_spec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parse_internal_render_format_spec DD 081201H
	DD	0a5412H
	DD	083412H
	DD	0c00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT ??_C@_0BJ@BLPJLLHL@Invalid?5format?5specifier?$AA@
CONST	SEGMENT
??_C@_0BJ@BLPJLLHL@Invalid?5format?5specifier?$AA@ DB 'Invalid format spe'
	DB	'cifier', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@POOGFIMB@Format?5specifier?5missing?5precisi@
CONST	SEGMENT
??_C@_0CD@POOGFIMB@Format?5specifier?5missing?5precisi@ DB 'Format specif'
	DB	'ier missing precision', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT parse_internal_render_format_spec
_TEXT	SEGMENT
format_spec$ = 64
pos$ = 72
start$ = 72
end$ = 80
format$ = 88
default_type$ = 96
default_align$ = 104
parse_internal_render_format_spec PROC			; COMDAT

; 151  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 152  :     Py_ssize_t pos = start;
; 153  :     /* end-pos is used throughout this code to specify the length of
; 154  :        the input string */
; 155  : #define READ_spec(index) PyUnicode_READ_CHAR(format_spec, index)
; 156  : 
; 157  :     Py_ssize_t consumed;
; 158  :     int align_specified = 0;
; 159  : 
; 160  :     format->fill_char = '\0';
; 161  :     format->align = default_align;

  00012	0f be 44 24 68	 movsx	 eax, BYTE PTR default_align$[rsp]
  00017	45 33 db	 xor	 r11d, r11d

; 162  :     format->alternate = 0;
; 163  :     format->sign = '\0';
; 164  :     format->width = -1;
; 165  :     format->thousands_separators = 0;
; 166  :     format->precision = -1;
; 167  :     format->type = default_type;
; 168  : 
; 169  :     /* If the second char is an alignment token,
; 170  :        then parse the fill char */
; 171  :     if (end-pos >= 2 && is_alignment_token(READ_spec(pos+1))) {

  0001a	4d 8b d0	 mov	 r10, r8
  0001d	41 89 41 04	 mov	 DWORD PTR [r9+4], eax
  00021	0f be 44 24 60	 movsx	 eax, BYTE PTR default_type$[rsp]
  00026	4c 2b d2	 sub	 r10, rdx
  00029	49 8b f9	 mov	 rdi, r9
  0002c	49 8b f0	 mov	 rsi, r8
  0002f	48 8b d9	 mov	 rbx, rcx
  00032	41 89 41 28	 mov	 DWORD PTR [r9+40], eax
  00036	48 89 54 24 48	 mov	 QWORD PTR pos$[rsp], rdx
  0003b	45 89 19	 mov	 DWORD PTR [r9], r11d
  0003e	4d 89 59 08	 mov	 QWORD PTR [r9+8], r11
  00042	49 c7 41 10 ff
	ff ff ff	 mov	 QWORD PTR [r9+16], -1
  0004a	45 89 59 18	 mov	 DWORD PTR [r9+24], r11d
  0004e	49 c7 41 20 ff
	ff ff ff	 mov	 QWORD PTR [r9+32], -1
  00056	49 83 fa 02	 cmp	 r10, 2
  0005a	0f 8c 61 02 00
	00		 jl	 $LN20@parse_inte
  00060	44 8b 41 70	 mov	 r8d, DWORD PTR [rcx+112]
  00064	45 8b c8	 mov	 r9d, r8d
  00067	41 8b c8	 mov	 ecx, r8d
  0006a	41 c1 e9 02	 shr	 r9d, 2
  0006e	c1 e9 05	 shr	 ecx, 5
  00071	41 83 e1 07	 and	 r9d, 7
  00075	41 83 f9 01	 cmp	 r9d, 1
  00079	75 35		 jne	 SHORT $LN37@parse_inte
  0007b	41 23 c9	 and	 ecx, r9d
  0007e	74 22		 je	 SHORT $LN25@parse_inte
  00080	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00084	74 0e		 je	 SHORT $LN23@parse_inte
  00086	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  0008d	0f b6 44 10 01	 movzx	 eax, BYTE PTR [rax+rdx+1]
  00092	eb 7f		 jmp	 SHORT $LN36@parse_inte
$LN23@parse_inte:
  00094	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  0009b	0f b6 44 10 01	 movzx	 eax, BYTE PTR [rax+rdx+1]
  000a0	eb 71		 jmp	 SHORT $LN36@parse_inte
$LN25@parse_inte:
  000a2	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  000a9	0f b6 44 10 01	 movzx	 eax, BYTE PTR [rax+rdx+1]
  000ae	eb 63		 jmp	 SHORT $LN36@parse_inte
$LN37@parse_inte:
  000b0	41 83 f9 02	 cmp	 r9d, 2
  000b4	75 35		 jne	 SHORT $LN35@parse_inte
  000b6	83 e1 01	 and	 ecx, 1
  000b9	74 22		 je	 SHORT $LN29@parse_inte
  000bb	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  000bf	74 0e		 je	 SHORT $LN27@parse_inte
  000c1	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  000c8	0f b7 44 50 02	 movzx	 eax, WORD PTR [rax+rdx*2+2]
  000cd	eb 44		 jmp	 SHORT $LN36@parse_inte
$LN27@parse_inte:
  000cf	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  000d6	0f b7 44 50 02	 movzx	 eax, WORD PTR [rax+rdx*2+2]
  000db	eb 36		 jmp	 SHORT $LN36@parse_inte
$LN29@parse_inte:
  000dd	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  000e4	0f b7 44 50 02	 movzx	 eax, WORD PTR [rax+rdx*2+2]
  000e9	eb 28		 jmp	 SHORT $LN36@parse_inte
$LN35@parse_inte:
  000eb	83 e1 01	 and	 ecx, 1
  000ee	74 18		 je	 SHORT $LN33@parse_inte
  000f0	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  000f4	74 09		 je	 SHORT $LN31@parse_inte
  000f6	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  000fd	eb 10		 jmp	 SHORT $LN34@parse_inte
$LN31@parse_inte:
  000ff	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00106	eb 07		 jmp	 SHORT $LN34@parse_inte
$LN33@parse_inte:
  00108	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN34@parse_inte:
  0010f	8b 44 90 04	 mov	 eax, DWORD PTR [rax+rdx*4+4]
$LN36@parse_inte:
  00113	83 f8 3c	 cmp	 eax, 60			; 0000003cH
  00116	0f 82 a5 01 00
	00		 jb	 $LN20@parse_inte
  0011c	83 f8 3e	 cmp	 eax, 62			; 0000003eH
  0011f	76 09		 jbe	 SHORT $LN233@parse_inte
  00121	83 f8 5e	 cmp	 eax, 94			; 0000005eH
  00124	0f 85 97 01 00
	00		 jne	 $LN20@parse_inte
$LN233@parse_inte:

; 172  :         format->align = READ_spec(pos+1);

  0012a	41 83 f9 01	 cmp	 r9d, 1
  0012e	75 34		 jne	 SHORT $LN53@parse_inte
  00130	85 c9		 test	 ecx, ecx
  00132	74 22		 je	 SHORT $LN41@parse_inte
  00134	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00138	74 0e		 je	 SHORT $LN39@parse_inte
  0013a	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00141	0f b6 4c 10 01	 movzx	 ecx, BYTE PTR [rax+rdx+1]
  00146	eb 7d		 jmp	 SHORT $LN52@parse_inte
$LN39@parse_inte:
  00148	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  0014f	0f b6 4c 10 01	 movzx	 ecx, BYTE PTR [rax+rdx+1]
  00154	eb 6f		 jmp	 SHORT $LN52@parse_inte
$LN41@parse_inte:
  00156	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  0015d	0f b6 4c 10 01	 movzx	 ecx, BYTE PTR [rax+rdx+1]
  00162	eb 61		 jmp	 SHORT $LN52@parse_inte
$LN53@parse_inte:
  00164	41 83 f9 02	 cmp	 r9d, 2
  00168	75 34		 jne	 SHORT $LN51@parse_inte
  0016a	85 c9		 test	 ecx, ecx
  0016c	74 22		 je	 SHORT $LN45@parse_inte
  0016e	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00172	74 0e		 je	 SHORT $LN43@parse_inte
  00174	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  0017b	0f b7 4c 50 02	 movzx	 ecx, WORD PTR [rax+rdx*2+2]
  00180	eb 43		 jmp	 SHORT $LN52@parse_inte
$LN43@parse_inte:
  00182	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00189	0f b7 4c 50 02	 movzx	 ecx, WORD PTR [rax+rdx*2+2]
  0018e	eb 35		 jmp	 SHORT $LN52@parse_inte
$LN45@parse_inte:
  00190	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  00197	0f b7 4c 50 02	 movzx	 ecx, WORD PTR [rax+rdx*2+2]
  0019c	eb 27		 jmp	 SHORT $LN52@parse_inte
$LN51@parse_inte:
  0019e	85 c9		 test	 ecx, ecx
  001a0	74 18		 je	 SHORT $LN49@parse_inte
  001a2	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  001a6	74 09		 je	 SHORT $LN47@parse_inte
  001a8	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  001af	eb 10		 jmp	 SHORT $LN50@parse_inte
$LN47@parse_inte:
  001b1	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  001b8	eb 07		 jmp	 SHORT $LN50@parse_inte
$LN49@parse_inte:
  001ba	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN50@parse_inte:
  001c1	8b 4c 90 04	 mov	 ecx, DWORD PTR [rax+rdx*4+4]
$LN52@parse_inte:
  001c5	89 4f 04	 mov	 DWORD PTR [rdi+4], ecx

; 173  :         format->fill_char = READ_spec(pos);

  001c8	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  001cb	8b c8		 mov	 ecx, eax
  001cd	c1 e9 02	 shr	 ecx, 2
  001d0	83 e1 07	 and	 ecx, 7
  001d3	83 f9 01	 cmp	 ecx, 1
  001d6	75 4d		 jne	 SHORT $LN69@parse_inte
  001d8	a8 20		 test	 al, 32			; 00000020H
  001da	74 32		 je	 SHORT $LN57@parse_inte
  001dc	a8 40		 test	 al, 64			; 00000040H
  001de	74 17		 je	 SHORT $LN55@parse_inte
  001e0	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]

; 174  :         align_specified = 1;
; 175  :         pos += 2;

  001e7	48 83 c2 02	 add	 rdx, 2
  001eb	0f b6 4c 10 fe	 movzx	 ecx, BYTE PTR [rax+rdx-2]
  001f0	89 0f		 mov	 DWORD PTR [rdi], ecx
  001f2	e9 31 02 00 00	 jmp	 $LN239@parse_inte
$LN55@parse_inte:

; 173  :         format->fill_char = READ_spec(pos);

  001f7	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]

; 174  :         align_specified = 1;
; 175  :         pos += 2;

  001fe	48 83 c2 02	 add	 rdx, 2
  00202	0f b6 4c 10 fe	 movzx	 ecx, BYTE PTR [rax+rdx-2]
  00207	89 0f		 mov	 DWORD PTR [rdi], ecx
  00209	e9 1a 02 00 00	 jmp	 $LN239@parse_inte
$LN57@parse_inte:

; 173  :         format->fill_char = READ_spec(pos);

  0020e	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]

; 174  :         align_specified = 1;
; 175  :         pos += 2;

  00215	48 83 c2 02	 add	 rdx, 2
  00219	0f b6 4c 10 fe	 movzx	 ecx, BYTE PTR [rax+rdx-2]
  0021e	89 0f		 mov	 DWORD PTR [rdi], ecx
  00220	e9 03 02 00 00	 jmp	 $LN239@parse_inte
$LN69@parse_inte:

; 173  :         format->fill_char = READ_spec(pos);

  00225	83 f9 02	 cmp	 ecx, 2
  00228	75 4d		 jne	 SHORT $LN67@parse_inte
  0022a	a8 20		 test	 al, 32			; 00000020H
  0022c	74 32		 je	 SHORT $LN61@parse_inte
  0022e	a8 40		 test	 al, 64			; 00000040H
  00230	74 17		 je	 SHORT $LN59@parse_inte
  00232	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]

; 174  :         align_specified = 1;
; 175  :         pos += 2;

  00239	48 83 c2 02	 add	 rdx, 2
  0023d	0f b7 4c 50 fc	 movzx	 ecx, WORD PTR [rax+rdx*2-4]
  00242	89 0f		 mov	 DWORD PTR [rdi], ecx
  00244	e9 df 01 00 00	 jmp	 $LN239@parse_inte
$LN59@parse_inte:

; 173  :         format->fill_char = READ_spec(pos);

  00249	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]

; 174  :         align_specified = 1;
; 175  :         pos += 2;

  00250	48 83 c2 02	 add	 rdx, 2
  00254	0f b7 4c 50 fc	 movzx	 ecx, WORD PTR [rax+rdx*2-4]
  00259	89 0f		 mov	 DWORD PTR [rdi], ecx
  0025b	e9 c8 01 00 00	 jmp	 $LN239@parse_inte
$LN61@parse_inte:

; 173  :         format->fill_char = READ_spec(pos);

  00260	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]

; 174  :         align_specified = 1;
; 175  :         pos += 2;

  00267	48 83 c2 02	 add	 rdx, 2
  0026b	0f b7 4c 50 fc	 movzx	 ecx, WORD PTR [rax+rdx*2-4]
  00270	89 0f		 mov	 DWORD PTR [rdi], ecx
  00272	e9 b1 01 00 00	 jmp	 $LN239@parse_inte
$LN67@parse_inte:

; 173  :         format->fill_char = READ_spec(pos);

  00277	a8 20		 test	 al, 32			; 00000020H
  00279	74 30		 je	 SHORT $LN65@parse_inte
  0027b	a8 40		 test	 al, 64			; 00000040H
  0027d	74 16		 je	 SHORT $LN63@parse_inte
  0027f	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]

; 174  :         align_specified = 1;
; 175  :         pos += 2;

  00286	48 83 c2 02	 add	 rdx, 2
  0028a	8b 4c 90 f8	 mov	 ecx, DWORD PTR [rax+rdx*4-8]
  0028e	89 0f		 mov	 DWORD PTR [rdi], ecx
  00290	e9 93 01 00 00	 jmp	 $LN239@parse_inte
$LN63@parse_inte:

; 173  :         format->fill_char = READ_spec(pos);

  00295	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]

; 174  :         align_specified = 1;
; 175  :         pos += 2;

  0029c	48 83 c2 02	 add	 rdx, 2
  002a0	8b 4c 90 f8	 mov	 ecx, DWORD PTR [rax+rdx*4-8]
  002a4	89 0f		 mov	 DWORD PTR [rdi], ecx
  002a6	e9 7d 01 00 00	 jmp	 $LN239@parse_inte
$LN65@parse_inte:

; 173  :         format->fill_char = READ_spec(pos);

  002ab	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]

; 174  :         align_specified = 1;
; 175  :         pos += 2;

  002b2	48 83 c2 02	 add	 rdx, 2
  002b6	8b 4c 90 f8	 mov	 ecx, DWORD PTR [rax+rdx*4-8]
  002ba	89 0f		 mov	 DWORD PTR [rdi], ecx
  002bc	e9 67 01 00 00	 jmp	 $LN239@parse_inte
$LN20@parse_inte:

; 176  :     }
; 177  :     else if (end-pos >= 1 && is_alignment_token(READ_spec(pos))) {

  002c1	49 83 fa 01	 cmp	 r10, 1
  002c5	0f 8c 68 01 00
	00		 jl	 $LN18@parse_inte
  002cb	44 8b 43 70	 mov	 r8d, DWORD PTR [rbx+112]
  002cf	45 8b c8	 mov	 r9d, r8d
  002d2	41 8b c0	 mov	 eax, r8d
  002d5	41 c1 e9 02	 shr	 r9d, 2
  002d9	c1 e8 05	 shr	 eax, 5
  002dc	41 83 e1 07	 and	 r9d, 7
  002e0	41 83 f9 01	 cmp	 r9d, 1
  002e4	75 32		 jne	 SHORT $LN85@parse_inte
  002e6	41 23 c1	 and	 eax, r9d
  002e9	74 20		 je	 SHORT $LN73@parse_inte
  002eb	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  002ef	74 0d		 je	 SHORT $LN71@parse_inte
  002f1	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  002f8	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  002fc	eb 79		 jmp	 SHORT $LN84@parse_inte
$LN71@parse_inte:
  002fe	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  00305	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  00309	eb 6c		 jmp	 SHORT $LN84@parse_inte
$LN73@parse_inte:
  0030b	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
  00312	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  00316	eb 5f		 jmp	 SHORT $LN84@parse_inte
$LN85@parse_inte:
  00318	41 83 f9 02	 cmp	 r9d, 2
  0031c	75 32		 jne	 SHORT $LN83@parse_inte
  0031e	83 e0 01	 and	 eax, 1
  00321	74 20		 je	 SHORT $LN77@parse_inte
  00323	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00327	74 0d		 je	 SHORT $LN75@parse_inte
  00329	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  00330	0f b7 0c 51	 movzx	 ecx, WORD PTR [rcx+rdx*2]
  00334	eb 41		 jmp	 SHORT $LN84@parse_inte
$LN75@parse_inte:
  00336	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  0033d	0f b7 0c 51	 movzx	 ecx, WORD PTR [rcx+rdx*2]
  00341	eb 34		 jmp	 SHORT $LN84@parse_inte
$LN77@parse_inte:
  00343	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
  0034a	0f b7 0c 51	 movzx	 ecx, WORD PTR [rcx+rdx*2]
  0034e	eb 27		 jmp	 SHORT $LN84@parse_inte
$LN83@parse_inte:
  00350	83 e0 01	 and	 eax, 1
  00353	74 18		 je	 SHORT $LN81@parse_inte
  00355	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00359	74 09		 je	 SHORT $LN79@parse_inte
  0035b	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  00362	eb 10		 jmp	 SHORT $LN82@parse_inte
$LN79@parse_inte:
  00364	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  0036b	eb 07		 jmp	 SHORT $LN82@parse_inte
$LN81@parse_inte:
  0036d	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
$LN82@parse_inte:
  00374	8b 0c 91	 mov	 ecx, DWORD PTR [rcx+rdx*4]
$LN84@parse_inte:
  00377	83 f9 3c	 cmp	 ecx, 60			; 0000003cH
  0037a	0f 82 b3 00 00
	00		 jb	 $LN18@parse_inte
  00380	83 f9 3e	 cmp	 ecx, 62			; 0000003eH
  00383	76 09		 jbe	 SHORT $LN234@parse_inte
  00385	83 f9 5e	 cmp	 ecx, 94			; 0000005eH
  00388	0f 85 a5 00 00
	00		 jne	 $LN18@parse_inte
$LN234@parse_inte:

; 178  :         format->align = READ_spec(pos);

  0038e	41 83 f9 01	 cmp	 r9d, 1
  00392	75 31		 jne	 SHORT $LN101@parse_inte
  00394	85 c0		 test	 eax, eax
  00396	74 20		 je	 SHORT $LN89@parse_inte
  00398	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  0039c	74 0d		 je	 SHORT $LN87@parse_inte
  0039e	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  003a5	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]
  003a9	eb 77		 jmp	 SHORT $LN100@parse_inte
$LN87@parse_inte:
  003ab	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  003b2	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]
  003b6	eb 6a		 jmp	 SHORT $LN100@parse_inte
$LN89@parse_inte:
  003b8	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  003bf	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]
  003c3	eb 5d		 jmp	 SHORT $LN100@parse_inte
$LN101@parse_inte:
  003c5	41 83 f9 02	 cmp	 r9d, 2
  003c9	75 31		 jne	 SHORT $LN99@parse_inte
  003cb	85 c0		 test	 eax, eax
  003cd	74 20		 je	 SHORT $LN93@parse_inte
  003cf	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  003d3	74 0d		 je	 SHORT $LN91@parse_inte
  003d5	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  003dc	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  003e0	eb 40		 jmp	 SHORT $LN100@parse_inte
$LN91@parse_inte:
  003e2	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  003e9	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  003ed	eb 33		 jmp	 SHORT $LN100@parse_inte
$LN93@parse_inte:
  003ef	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  003f6	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  003fa	eb 26		 jmp	 SHORT $LN100@parse_inte
$LN99@parse_inte:
  003fc	85 c0		 test	 eax, eax
  003fe	74 18		 je	 SHORT $LN97@parse_inte
  00400	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00404	74 09		 je	 SHORT $LN95@parse_inte
  00406	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  0040d	eb 10		 jmp	 SHORT $LN98@parse_inte
$LN95@parse_inte:
  0040f	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00416	eb 07		 jmp	 SHORT $LN98@parse_inte
$LN97@parse_inte:
  00418	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN98@parse_inte:
  0041f	8b 0c 90	 mov	 ecx, DWORD PTR [rax+rdx*4]
$LN100@parse_inte:
  00422	89 4f 04	 mov	 DWORD PTR [rdi+4], ecx

; 179  :         align_specified = 1;
; 180  :         ++pos;

  00425	48 ff c2	 inc	 rdx
$LN239@parse_inte:
  00428	48 89 54 24 48	 mov	 QWORD PTR pos$[rsp], rdx
  0042d	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN18@parse_inte:

; 181  :     }
; 182  : 
; 183  :     /* Parse the various sign options */
; 184  :     if (end-pos >= 1 && is_sign_element(READ_spec(pos))) {

  00433	48 8b c6	 mov	 rax, rsi
  00436	48 2b c2	 sub	 rax, rdx
  00439	48 83 f8 01	 cmp	 rax, 1
  0043d	0f 8c 5e 01 00
	00		 jl	 $LN17@parse_inte
  00443	44 8b 43 70	 mov	 r8d, DWORD PTR [rbx+112]
  00447	45 8b c8	 mov	 r9d, r8d
  0044a	41 8b c0	 mov	 eax, r8d
  0044d	41 c1 e9 02	 shr	 r9d, 2
  00451	c1 e8 05	 shr	 eax, 5
  00454	41 83 e1 07	 and	 r9d, 7
  00458	41 83 f9 01	 cmp	 r9d, 1
  0045c	75 32		 jne	 SHORT $LN117@parse_inte
  0045e	41 23 c1	 and	 eax, r9d
  00461	74 20		 je	 SHORT $LN105@parse_inte
  00463	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00467	74 0d		 je	 SHORT $LN103@parse_inte
  00469	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  00470	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  00474	eb 79		 jmp	 SHORT $LN116@parse_inte
$LN103@parse_inte:
  00476	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  0047d	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  00481	eb 6c		 jmp	 SHORT $LN116@parse_inte
$LN105@parse_inte:
  00483	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
  0048a	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  0048e	eb 5f		 jmp	 SHORT $LN116@parse_inte
$LN117@parse_inte:
  00490	41 83 f9 02	 cmp	 r9d, 2
  00494	75 32		 jne	 SHORT $LN115@parse_inte
  00496	83 e0 01	 and	 eax, 1
  00499	74 20		 je	 SHORT $LN109@parse_inte
  0049b	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  0049f	74 0d		 je	 SHORT $LN107@parse_inte
  004a1	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  004a8	0f b7 0c 51	 movzx	 ecx, WORD PTR [rcx+rdx*2]
  004ac	eb 41		 jmp	 SHORT $LN116@parse_inte
$LN107@parse_inte:
  004ae	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  004b5	0f b7 0c 51	 movzx	 ecx, WORD PTR [rcx+rdx*2]
  004b9	eb 34		 jmp	 SHORT $LN116@parse_inte
$LN109@parse_inte:
  004bb	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
  004c2	0f b7 0c 51	 movzx	 ecx, WORD PTR [rcx+rdx*2]
  004c6	eb 27		 jmp	 SHORT $LN116@parse_inte
$LN115@parse_inte:
  004c8	83 e0 01	 and	 eax, 1
  004cb	74 18		 je	 SHORT $LN113@parse_inte
  004cd	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  004d1	74 09		 je	 SHORT $LN111@parse_inte
  004d3	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  004da	eb 10		 jmp	 SHORT $LN114@parse_inte
$LN111@parse_inte:
  004dc	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  004e3	eb 07		 jmp	 SHORT $LN114@parse_inte
$LN113@parse_inte:
  004e5	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
$LN114@parse_inte:
  004ec	8b 0c 91	 mov	 ecx, DWORD PTR [rcx+rdx*4]
$LN116@parse_inte:
  004ef	83 f9 20	 cmp	 ecx, 32			; 00000020H
  004f2	74 0e		 je	 SHORT $LN228@parse_inte
  004f4	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  004f7	74 09		 je	 SHORT $LN228@parse_inte
  004f9	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  004fc	0f 85 9f 00 00
	00		 jne	 $LN17@parse_inte
$LN228@parse_inte:

; 185  :         format->sign = READ_spec(pos);

  00502	41 83 f9 01	 cmp	 r9d, 1
  00506	75 31		 jne	 SHORT $LN133@parse_inte
  00508	85 c0		 test	 eax, eax
  0050a	74 20		 je	 SHORT $LN121@parse_inte
  0050c	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00510	74 0d		 je	 SHORT $LN119@parse_inte
  00512	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00519	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]
  0051d	eb 77		 jmp	 SHORT $LN132@parse_inte
$LN119@parse_inte:
  0051f	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00526	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]
  0052a	eb 6a		 jmp	 SHORT $LN132@parse_inte
$LN121@parse_inte:
  0052c	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  00533	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]
  00537	eb 5d		 jmp	 SHORT $LN132@parse_inte
$LN133@parse_inte:
  00539	41 83 f9 02	 cmp	 r9d, 2
  0053d	75 31		 jne	 SHORT $LN131@parse_inte
  0053f	85 c0		 test	 eax, eax
  00541	74 20		 je	 SHORT $LN125@parse_inte
  00543	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00547	74 0d		 je	 SHORT $LN123@parse_inte
  00549	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00550	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  00554	eb 40		 jmp	 SHORT $LN132@parse_inte
$LN123@parse_inte:
  00556	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  0055d	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  00561	eb 33		 jmp	 SHORT $LN132@parse_inte
$LN125@parse_inte:
  00563	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  0056a	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  0056e	eb 26		 jmp	 SHORT $LN132@parse_inte
$LN131@parse_inte:
  00570	85 c0		 test	 eax, eax
  00572	74 18		 je	 SHORT $LN129@parse_inte
  00574	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00578	74 09		 je	 SHORT $LN127@parse_inte
  0057a	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00581	eb 10		 jmp	 SHORT $LN130@parse_inte
$LN127@parse_inte:
  00583	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  0058a	eb 07		 jmp	 SHORT $LN130@parse_inte
$LN129@parse_inte:
  0058c	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN130@parse_inte:
  00593	8b 0c 90	 mov	 ecx, DWORD PTR [rax+rdx*4]
$LN132@parse_inte:

; 186  :         ++pos;

  00596	48 ff c2	 inc	 rdx
  00599	89 4f 0c	 mov	 DWORD PTR [rdi+12], ecx
  0059c	48 89 54 24 48	 mov	 QWORD PTR pos$[rsp], rdx
$LN17@parse_inte:

; 187  :     }
; 188  : 
; 189  :     /* If the next character is #, we're in alternate mode.  This only
; 190  :        applies to integers. */
; 191  :     if (end-pos >= 1 && READ_spec(pos) == '#') {

  005a1	48 8b c6	 mov	 rax, rsi
  005a4	48 2b c2	 sub	 rax, rdx
  005a7	48 83 f8 01	 cmp	 rax, 1
  005ab	0f 8c ab 00 00
	00		 jl	 $LN16@parse_inte
  005b1	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  005b4	8b c8		 mov	 ecx, eax
  005b6	c1 e9 02	 shr	 ecx, 2
  005b9	83 e1 07	 and	 ecx, 7
  005bc	83 f9 01	 cmp	 ecx, 1
  005bf	75 2f		 jne	 SHORT $LN149@parse_inte
  005c1	a8 20		 test	 al, 32			; 00000020H
  005c3	74 1e		 je	 SHORT $LN137@parse_inte
  005c5	a8 40		 test	 al, 64			; 00000040H
  005c7	74 0d		 je	 SHORT $LN135@parse_inte
  005c9	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  005d0	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]
  005d4	eb 72		 jmp	 SHORT $LN148@parse_inte
$LN135@parse_inte:
  005d6	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  005dd	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]
  005e1	eb 65		 jmp	 SHORT $LN148@parse_inte
$LN137@parse_inte:
  005e3	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  005ea	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]
  005ee	eb 58		 jmp	 SHORT $LN148@parse_inte
$LN149@parse_inte:
  005f0	83 f9 02	 cmp	 ecx, 2
  005f3	75 2f		 jne	 SHORT $LN147@parse_inte
  005f5	a8 20		 test	 al, 32			; 00000020H
  005f7	74 1e		 je	 SHORT $LN141@parse_inte
  005f9	a8 40		 test	 al, 64			; 00000040H
  005fb	74 0d		 je	 SHORT $LN139@parse_inte
  005fd	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00604	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  00608	eb 3e		 jmp	 SHORT $LN148@parse_inte
$LN139@parse_inte:
  0060a	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00611	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  00615	eb 31		 jmp	 SHORT $LN148@parse_inte
$LN141@parse_inte:
  00617	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  0061e	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  00622	eb 24		 jmp	 SHORT $LN148@parse_inte
$LN147@parse_inte:
  00624	a8 20		 test	 al, 32			; 00000020H
  00626	74 16		 je	 SHORT $LN145@parse_inte
  00628	a8 40		 test	 al, 64			; 00000040H
  0062a	74 09		 je	 SHORT $LN143@parse_inte
  0062c	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00633	eb 10		 jmp	 SHORT $LN146@parse_inte
$LN143@parse_inte:
  00635	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  0063c	eb 07		 jmp	 SHORT $LN146@parse_inte
$LN145@parse_inte:
  0063e	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN146@parse_inte:
  00645	8b 0c 90	 mov	 ecx, DWORD PTR [rax+rdx*4]
$LN148@parse_inte:
  00648	83 f9 23	 cmp	 ecx, 35			; 00000023H
  0064b	75 0f		 jne	 SHORT $LN16@parse_inte

; 192  :         format->alternate = 1;
; 193  :         ++pos;

  0064d	48 ff c2	 inc	 rdx
  00650	c7 47 08 01 00
	00 00		 mov	 DWORD PTR [rdi+8], 1
  00657	48 89 54 24 48	 mov	 QWORD PTR pos$[rsp], rdx
$LN16@parse_inte:

; 194  :     }
; 195  : 
; 196  :     /* The special case for 0-padding (backwards compat) */
; 197  :     if (format->fill_char == '\0' && end-pos >= 1 && READ_spec(pos) == '0') {

  0065c	83 3f 00	 cmp	 DWORD PTR [rdi], 0
  0065f	0f 85 c2 00 00
	00		 jne	 $LN15@parse_inte
  00665	48 8b c6	 mov	 rax, rsi
  00668	48 2b c2	 sub	 rax, rdx
  0066b	48 83 f8 01	 cmp	 rax, 1
  0066f	0f 8c b2 00 00
	00		 jl	 $LN15@parse_inte
  00675	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00678	8b c8		 mov	 ecx, eax
  0067a	c1 e9 02	 shr	 ecx, 2
  0067d	83 e1 07	 and	 ecx, 7
  00680	83 f9 01	 cmp	 ecx, 1
  00683	75 2f		 jne	 SHORT $LN165@parse_inte
  00685	a8 20		 test	 al, 32			; 00000020H
  00687	74 1e		 je	 SHORT $LN153@parse_inte
  00689	a8 40		 test	 al, 64			; 00000040H
  0068b	74 0d		 je	 SHORT $LN151@parse_inte
  0068d	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00694	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]
  00698	eb 72		 jmp	 SHORT $LN164@parse_inte
$LN151@parse_inte:
  0069a	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  006a1	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]
  006a5	eb 65		 jmp	 SHORT $LN164@parse_inte
$LN153@parse_inte:
  006a7	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  006ae	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]
  006b2	eb 58		 jmp	 SHORT $LN164@parse_inte
$LN165@parse_inte:
  006b4	83 f9 02	 cmp	 ecx, 2
  006b7	75 2f		 jne	 SHORT $LN163@parse_inte
  006b9	a8 20		 test	 al, 32			; 00000020H
  006bb	74 1e		 je	 SHORT $LN157@parse_inte
  006bd	a8 40		 test	 al, 64			; 00000040H
  006bf	74 0d		 je	 SHORT $LN155@parse_inte
  006c1	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  006c8	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  006cc	eb 3e		 jmp	 SHORT $LN164@parse_inte
$LN155@parse_inte:
  006ce	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  006d5	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  006d9	eb 31		 jmp	 SHORT $LN164@parse_inte
$LN157@parse_inte:
  006db	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  006e2	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]
  006e6	eb 24		 jmp	 SHORT $LN164@parse_inte
$LN163@parse_inte:
  006e8	a8 20		 test	 al, 32			; 00000020H
  006ea	74 16		 je	 SHORT $LN161@parse_inte
  006ec	a8 40		 test	 al, 64			; 00000040H
  006ee	74 09		 je	 SHORT $LN159@parse_inte
  006f0	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  006f7	eb 10		 jmp	 SHORT $LN162@parse_inte
$LN159@parse_inte:
  006f9	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00700	eb 07		 jmp	 SHORT $LN162@parse_inte
$LN161@parse_inte:
  00702	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN162@parse_inte:
  00709	8b 0c 90	 mov	 ecx, DWORD PTR [rax+rdx*4]
$LN164@parse_inte:
  0070c	83 f9 30	 cmp	 ecx, 48			; 00000030H
  0070f	75 16		 jne	 SHORT $LN15@parse_inte

; 198  :         format->fill_char = '0';

  00711	89 0f		 mov	 DWORD PTR [rdi], ecx

; 199  :         if (!align_specified) {

  00713	45 85 db	 test	 r11d, r11d
  00716	75 07		 jne	 SHORT $LN14@parse_inte

; 200  :             format->align = '=';

  00718	c7 47 04 3d 00
	00 00		 mov	 DWORD PTR [rdi+4], 61	; 0000003dH
$LN14@parse_inte:

; 201  :         }
; 202  :         ++pos;

  0071f	48 ff c2	 inc	 rdx
  00722	48 89 54 24 48	 mov	 QWORD PTR pos$[rsp], rdx
$LN15@parse_inte:

; 203  :     }
; 204  : 
; 205  :     consumed = get_integer(format_spec, &pos, end, &format->width);

  00727	4c 8d 4f 10	 lea	 r9, QWORD PTR [rdi+16]
  0072b	48 8d 54 24 48	 lea	 rdx, QWORD PTR pos$[rsp]
  00730	4c 8b c6	 mov	 r8, rsi
  00733	48 8b cb	 mov	 rcx, rbx
  00736	e8 00 00 00 00	 call	 get_integer

; 206  :     if (consumed == -1)

  0073b	83 f8 ff	 cmp	 eax, -1

; 207  :         /* Overflow error. Exception already set. */
; 208  :         return 0;

  0073e	0f 84 9d 01 00
	00		 je	 $LN242@parse_inte

; 209  : 
; 210  :     /* If consumed is 0, we didn't consume any characters for the
; 211  :        width. In that case, reset the width to -1, because
; 212  :        get_integer() will have set it to zero. -1 is how we record
; 213  :        that the width wasn't specified. */
; 214  :     if (consumed == 0)

  00744	85 c0		 test	 eax, eax
  00746	75 08		 jne	 SHORT $LN12@parse_inte

; 215  :         format->width = -1;

  00748	48 c7 47 10 ff
	ff ff ff	 mov	 QWORD PTR [rdi+16], -1
$LN12@parse_inte:

; 216  : 
; 217  :     /* Comma signifies add thousands separators */
; 218  :     if (end-pos && READ_spec(pos) == ',') {

  00750	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pos$[rsp]
  00755	48 3b f1	 cmp	 rsi, rcx
  00758	0f 84 8f 01 00
	00		 je	 $LN8@parse_inte
  0075e	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00761	8b d0		 mov	 edx, eax
  00763	c1 ea 02	 shr	 edx, 2
  00766	83 e2 07	 and	 edx, 7
  00769	83 fa 01	 cmp	 edx, 1
  0076c	75 2f		 jne	 SHORT $LN181@parse_inte
  0076e	a8 20		 test	 al, 32			; 00000020H
  00770	74 1e		 je	 SHORT $LN169@parse_inte
  00772	a8 40		 test	 al, 64			; 00000040H
  00774	74 0d		 je	 SHORT $LN167@parse_inte
  00776	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  0077d	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00781	eb 72		 jmp	 SHORT $LN180@parse_inte
$LN167@parse_inte:
  00783	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  0078a	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0078e	eb 65		 jmp	 SHORT $LN180@parse_inte
$LN169@parse_inte:
  00790	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  00797	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0079b	eb 58		 jmp	 SHORT $LN180@parse_inte
$LN181@parse_inte:
  0079d	83 fa 02	 cmp	 edx, 2
  007a0	75 2f		 jne	 SHORT $LN179@parse_inte
  007a2	a8 20		 test	 al, 32			; 00000020H
  007a4	74 1e		 je	 SHORT $LN173@parse_inte
  007a6	a8 40		 test	 al, 64			; 00000040H
  007a8	74 0d		 je	 SHORT $LN171@parse_inte
  007aa	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  007b1	0f b7 14 48	 movzx	 edx, WORD PTR [rax+rcx*2]
  007b5	eb 3e		 jmp	 SHORT $LN180@parse_inte
$LN171@parse_inte:
  007b7	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  007be	0f b7 14 48	 movzx	 edx, WORD PTR [rax+rcx*2]
  007c2	eb 31		 jmp	 SHORT $LN180@parse_inte
$LN173@parse_inte:
  007c4	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  007cb	0f b7 14 48	 movzx	 edx, WORD PTR [rax+rcx*2]
  007cf	eb 24		 jmp	 SHORT $LN180@parse_inte
$LN179@parse_inte:
  007d1	a8 20		 test	 al, 32			; 00000020H
  007d3	74 16		 je	 SHORT $LN177@parse_inte
  007d5	a8 40		 test	 al, 64			; 00000040H
  007d7	74 09		 je	 SHORT $LN175@parse_inte
  007d9	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  007e0	eb 10		 jmp	 SHORT $LN178@parse_inte
$LN175@parse_inte:
  007e2	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  007e9	eb 07		 jmp	 SHORT $LN178@parse_inte
$LN177@parse_inte:
  007eb	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN178@parse_inte:
  007f2	8b 14 88	 mov	 edx, DWORD PTR [rax+rcx*4]
$LN180@parse_inte:
  007f5	83 fa 2c	 cmp	 edx, 44			; 0000002cH
  007f8	75 0a		 jne	 SHORT $LN11@parse_inte

; 219  :         format->thousands_separators = 1;

  007fa	c7 47 18 01 00
	00 00		 mov	 DWORD PTR [rdi+24], 1

; 220  :         ++pos;

  00801	48 ff c1	 inc	 rcx
$LN11@parse_inte:

; 221  :     }
; 222  : 
; 223  :     /* Parse field precision */
; 224  :     if (end-pos && READ_spec(pos) == '.') {

  00804	48 3b f1	 cmp	 rsi, rcx
  00807	0f 84 e0 00 00
	00		 je	 $LN8@parse_inte
  0080d	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00810	8b d0		 mov	 edx, eax
  00812	c1 ea 02	 shr	 edx, 2
  00815	83 e2 07	 and	 edx, 7
  00818	83 fa 01	 cmp	 edx, 1
  0081b	75 2f		 jne	 SHORT $LN197@parse_inte
  0081d	a8 20		 test	 al, 32			; 00000020H
  0081f	74 1e		 je	 SHORT $LN185@parse_inte
  00821	a8 40		 test	 al, 64			; 00000040H
  00823	74 0d		 je	 SHORT $LN183@parse_inte
  00825	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  0082c	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00830	eb 72		 jmp	 SHORT $LN196@parse_inte
$LN183@parse_inte:
  00832	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00839	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0083d	eb 65		 jmp	 SHORT $LN196@parse_inte
$LN185@parse_inte:
  0083f	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  00846	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  0084a	eb 58		 jmp	 SHORT $LN196@parse_inte
$LN197@parse_inte:
  0084c	83 fa 02	 cmp	 edx, 2
  0084f	75 2f		 jne	 SHORT $LN195@parse_inte
  00851	a8 20		 test	 al, 32			; 00000020H
  00853	74 1e		 je	 SHORT $LN189@parse_inte
  00855	a8 40		 test	 al, 64			; 00000040H
  00857	74 0d		 je	 SHORT $LN187@parse_inte
  00859	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00860	0f b7 14 48	 movzx	 edx, WORD PTR [rax+rcx*2]
  00864	eb 3e		 jmp	 SHORT $LN196@parse_inte
$LN187@parse_inte:
  00866	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  0086d	0f b7 14 48	 movzx	 edx, WORD PTR [rax+rcx*2]
  00871	eb 31		 jmp	 SHORT $LN196@parse_inte
$LN189@parse_inte:
  00873	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  0087a	0f b7 14 48	 movzx	 edx, WORD PTR [rax+rcx*2]
  0087e	eb 24		 jmp	 SHORT $LN196@parse_inte
$LN195@parse_inte:
  00880	a8 20		 test	 al, 32			; 00000020H
  00882	74 16		 je	 SHORT $LN193@parse_inte
  00884	a8 40		 test	 al, 64			; 00000040H
  00886	74 09		 je	 SHORT $LN191@parse_inte
  00888	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  0088f	eb 10		 jmp	 SHORT $LN194@parse_inte
$LN191@parse_inte:
  00891	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00898	eb 07		 jmp	 SHORT $LN194@parse_inte
$LN193@parse_inte:
  0089a	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN194@parse_inte:
  008a1	8b 14 88	 mov	 edx, DWORD PTR [rax+rcx*4]
$LN196@parse_inte:
  008a4	83 fa 2e	 cmp	 edx, 46			; 0000002eH
  008a7	75 44		 jne	 SHORT $LN8@parse_inte

; 225  :         ++pos;

  008a9	48 ff c1	 inc	 rcx

; 226  : 
; 227  :         consumed = get_integer(format_spec, &pos, end, &format->precision);

  008ac	4c 8d 4f 20	 lea	 r9, QWORD PTR [rdi+32]
  008b0	48 8d 54 24 48	 lea	 rdx, QWORD PTR pos$[rsp]
  008b5	48 89 4c 24 48	 mov	 QWORD PTR pos$[rsp], rcx
  008ba	48 8b cb	 mov	 rcx, rbx
  008bd	4c 8b c6	 mov	 r8, rsi
  008c0	e8 00 00 00 00	 call	 get_integer

; 228  :         if (consumed == -1)

  008c5	83 f8 ff	 cmp	 eax, -1

; 229  :             /* Overflow error. Exception already set. */
; 230  :             return 0;

  008c8	74 17		 je	 SHORT $LN242@parse_inte

; 231  : 
; 232  :         /* Not having a precision after a dot is an error. */
; 233  :         if (consumed == 0) {

  008ca	85 c0		 test	 eax, eax
  008cc	75 1a		 jne	 SHORT $LN238@parse_inte

; 234  :             PyErr_Format(PyExc_ValueError,
; 235  :                          "Format specifier missing precision");

  008ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  008d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@POOGFIMB@Format?5specifier?5missing?5precisi@
  008dc	e8 00 00 00 00	 call	 PyErr_Format
$LN242@parse_inte:

; 236  :             return 0;

  008e1	33 c0		 xor	 eax, eax
  008e3	e9 f8 00 00 00	 jmp	 $LN21@parse_inte
$LN238@parse_inte:
  008e8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pos$[rsp]
$LN8@parse_inte:

; 237  :         }
; 238  : 
; 239  :     }
; 240  : 
; 241  :     /* Finally, parse the type field. */
; 242  : 
; 243  :     if (end-pos > 1) {

  008ed	48 2b f1	 sub	 rsi, rcx
  008f0	48 83 fe 01	 cmp	 rsi, 1
  008f4	7e 1a		 jle	 SHORT $LN241@parse_inte

; 244  :         /* More than one char remain, invalid format specifier. */
; 245  :         PyErr_Format(PyExc_ValueError, "Invalid format specifier");

  008f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  008fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@BLPJLLHL@Invalid?5format?5specifier?$AA@
  00904	e8 00 00 00 00	 call	 PyErr_Format

; 246  :         return 0;

  00909	33 c0		 xor	 eax, eax
  0090b	e9 d0 00 00 00	 jmp	 $LN21@parse_inte
$LN241@parse_inte:

; 247  :     }
; 248  : 
; 249  :     if (end-pos == 1) {

  00910	0f 85 91 00 00
	00		 jne	 $LN6@parse_inte

; 250  :         format->type = READ_spec(pos);

  00916	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00919	8b d0		 mov	 edx, eax
  0091b	c1 ea 02	 shr	 edx, 2
  0091e	83 e2 07	 and	 edx, 7
  00921	83 fa 01	 cmp	 edx, 1
  00924	75 2c		 jne	 SHORT $LN213@parse_inte
  00926	a8 20		 test	 al, 32			; 00000020H
  00928	74 1b		 je	 SHORT $LN201@parse_inte
  0092a	a8 40		 test	 al, 64			; 00000040H
  0092c	74 0a		 je	 SHORT $LN199@parse_inte
  0092e	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  00932	0f b6 04 0b	 movzx	 eax, BYTE PTR [rbx+rcx]
  00936	eb 6c		 jmp	 SHORT $LN212@parse_inte
$LN199@parse_inte:
  00938	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  0093f	0f b6 04 0b	 movzx	 eax, BYTE PTR [rbx+rcx]
  00943	eb 5f		 jmp	 SHORT $LN212@parse_inte
$LN201@parse_inte:
  00945	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
  0094c	0f b6 04 0b	 movzx	 eax, BYTE PTR [rbx+rcx]
  00950	eb 52		 jmp	 SHORT $LN212@parse_inte
$LN213@parse_inte:
  00952	83 fa 02	 cmp	 edx, 2
  00955	75 2c		 jne	 SHORT $LN211@parse_inte
  00957	a8 20		 test	 al, 32			; 00000020H
  00959	74 1b		 je	 SHORT $LN205@parse_inte
  0095b	a8 40		 test	 al, 64			; 00000040H
  0095d	74 0a		 je	 SHORT $LN203@parse_inte
  0095f	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  00963	0f b7 04 4b	 movzx	 eax, WORD PTR [rbx+rcx*2]
  00967	eb 3b		 jmp	 SHORT $LN212@parse_inte
$LN203@parse_inte:
  00969	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  00970	0f b7 04 4b	 movzx	 eax, WORD PTR [rbx+rcx*2]
  00974	eb 2e		 jmp	 SHORT $LN212@parse_inte
$LN205@parse_inte:
  00976	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
  0097d	0f b7 04 4b	 movzx	 eax, WORD PTR [rbx+rcx*2]
  00981	eb 21		 jmp	 SHORT $LN212@parse_inte
$LN211@parse_inte:
  00983	a8 20		 test	 al, 32			; 00000020H
  00985	74 13		 je	 SHORT $LN209@parse_inte
  00987	a8 40		 test	 al, 64			; 00000040H
  00989	74 06		 je	 SHORT $LN207@parse_inte
  0098b	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  0098f	eb 10		 jmp	 SHORT $LN210@parse_inte
$LN207@parse_inte:
  00991	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  00998	eb 07		 jmp	 SHORT $LN210@parse_inte
$LN209@parse_inte:
  0099a	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
$LN210@parse_inte:
  009a1	8b 04 8b	 mov	 eax, DWORD PTR [rbx+rcx*4]
$LN212@parse_inte:
  009a4	89 47 28	 mov	 DWORD PTR [rdi+40], eax
$LN6@parse_inte:

; 251  :         ++pos;
; 252  :     }
; 253  : 
; 254  :     /* Do as much validating as we can, just by looking at the format
; 255  :        specifier.  Do not take into account what type of formatting
; 256  :        we're doing (int, float, string). */
; 257  : 
; 258  :     if (format->thousands_separators) {

  009a7	83 7f 18 00	 cmp	 DWORD PTR [rdi+24], 0
  009ab	74 2e		 je	 SHORT $LN3@parse_inte

; 259  :         switch (format->type) {

  009ad	8b 4f 28	 mov	 ecx, DWORD PTR [rdi+40]
  009b0	83 f9 67	 cmp	 ecx, 103		; 00000067H
  009b3	77 1d		 ja	 SHORT $LN1@parse_inte
  009b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  009bc	41 0f b6 84 08
	00 00 00 00	 movzx	 eax, BYTE PTR $LN236@parse_inte[r8+rcx]
  009c5	41 8b 94 80 00
	00 00 00	 mov	 edx, DWORD PTR $LN237@parse_inte[r8+rax*4]
  009cd	49 03 d0	 add	 rdx, r8
  009d0	ff e2		 jmp	 rdx
$LN1@parse_inte:

; 260  :         case 'd':
; 261  :         case 'e':
; 262  :         case 'f':
; 263  :         case 'g':
; 264  :         case 'E':
; 265  :         case 'G':
; 266  :         case '%':
; 267  :         case 'F':
; 268  :         case '\0':
; 269  :             /* These are allowed. See PEP 378.*/
; 270  :             break;
; 271  :         default:
; 272  :             invalid_comma_type(format->type);

  009d2	e8 00 00 00 00	 call	 invalid_comma_type

; 273  :             return 0;

  009d7	33 c0		 xor	 eax, eax
  009d9	eb 05		 jmp	 SHORT $LN21@parse_inte
$LN3@parse_inte:

; 274  :         }
; 275  :     }
; 276  : 
; 277  :     assert (format->align <= 127);
; 278  :     assert (format->sign <= 127);
; 279  :     return 1;

  009db	b8 01 00 00 00	 mov	 eax, 1
$LN21@parse_inte:

; 280  : }

  009e0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  009e5	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  009ea	48 83 c4 20	 add	 rsp, 32			; 00000020H
  009ee	41 5c		 pop	 r12
  009f0	5f		 pop	 rdi
  009f1	5e		 pop	 rsi
  009f2	c3		 ret	 0
  009f3	90		 npad	 1
$LN237@parse_inte:
  009f4	00 00 00 00	 DD	 $LN3@parse_inte
  009f8	00 00 00 00	 DD	 $LN1@parse_inte
$LN236@parse_inte:
  009fc	00		 DB	 0
  009fd	01		 DB	 1
  009fe	01		 DB	 1
  009ff	01		 DB	 1
  00a00	01		 DB	 1
  00a01	01		 DB	 1
  00a02	01		 DB	 1
  00a03	01		 DB	 1
  00a04	01		 DB	 1
  00a05	01		 DB	 1
  00a06	01		 DB	 1
  00a07	01		 DB	 1
  00a08	01		 DB	 1
  00a09	01		 DB	 1
  00a0a	01		 DB	 1
  00a0b	01		 DB	 1
  00a0c	01		 DB	 1
  00a0d	01		 DB	 1
  00a0e	01		 DB	 1
  00a0f	01		 DB	 1
  00a10	01		 DB	 1
  00a11	01		 DB	 1
  00a12	01		 DB	 1
  00a13	01		 DB	 1
  00a14	01		 DB	 1
  00a15	01		 DB	 1
  00a16	01		 DB	 1
  00a17	01		 DB	 1
  00a18	01		 DB	 1
  00a19	01		 DB	 1
  00a1a	01		 DB	 1
  00a1b	01		 DB	 1
  00a1c	01		 DB	 1
  00a1d	01		 DB	 1
  00a1e	01		 DB	 1
  00a1f	01		 DB	 1
  00a20	01		 DB	 1
  00a21	00		 DB	 0
  00a22	01		 DB	 1
  00a23	01		 DB	 1
  00a24	01		 DB	 1
  00a25	01		 DB	 1
  00a26	01		 DB	 1
  00a27	01		 DB	 1
  00a28	01		 DB	 1
  00a29	01		 DB	 1
  00a2a	01		 DB	 1
  00a2b	01		 DB	 1
  00a2c	01		 DB	 1
  00a2d	01		 DB	 1
  00a2e	01		 DB	 1
  00a2f	01		 DB	 1
  00a30	01		 DB	 1
  00a31	01		 DB	 1
  00a32	01		 DB	 1
  00a33	01		 DB	 1
  00a34	01		 DB	 1
  00a35	01		 DB	 1
  00a36	01		 DB	 1
  00a37	01		 DB	 1
  00a38	01		 DB	 1
  00a39	01		 DB	 1
  00a3a	01		 DB	 1
  00a3b	01		 DB	 1
  00a3c	01		 DB	 1
  00a3d	01		 DB	 1
  00a3e	01		 DB	 1
  00a3f	01		 DB	 1
  00a40	01		 DB	 1
  00a41	00		 DB	 0
  00a42	00		 DB	 0
  00a43	00		 DB	 0
  00a44	01		 DB	 1
  00a45	01		 DB	 1
  00a46	01		 DB	 1
  00a47	01		 DB	 1
  00a48	01		 DB	 1
  00a49	01		 DB	 1
  00a4a	01		 DB	 1
  00a4b	01		 DB	 1
  00a4c	01		 DB	 1
  00a4d	01		 DB	 1
  00a4e	01		 DB	 1
  00a4f	01		 DB	 1
  00a50	01		 DB	 1
  00a51	01		 DB	 1
  00a52	01		 DB	 1
  00a53	01		 DB	 1
  00a54	01		 DB	 1
  00a55	01		 DB	 1
  00a56	01		 DB	 1
  00a57	01		 DB	 1
  00a58	01		 DB	 1
  00a59	01		 DB	 1
  00a5a	01		 DB	 1
  00a5b	01		 DB	 1
  00a5c	01		 DB	 1
  00a5d	01		 DB	 1
  00a5e	01		 DB	 1
  00a5f	01		 DB	 1
  00a60	00		 DB	 0
  00a61	00		 DB	 0
  00a62	00		 DB	 0
  00a63	00		 DB	 0
parse_internal_render_format_spec ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT calc_padding
_TEXT	SEGMENT
nchars$ = 8
width$ = 16
align$ = 24
n_lpadding$ = 32
n_rpadding$ = 40
n_total$ = 48
calc_padding PROC					; COMDAT

; 287  : {

  00000	4c 8b d1	 mov	 r10, rcx

; 288  :     if (width >= 0) {

  00003	48 85 d2	 test	 rdx, rdx
  00006	78 11		 js	 SHORT $LN11@calc_paddi

; 289  :         if (nchars > width)

  00008	48 3b ca	 cmp	 rcx, rdx
  0000b	48 0f 4f d1	 cmovg	 rdx, rcx
  0000f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n_total$[rsp]
  00014	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 290  :             *n_total = nchars;
; 291  :         else
; 292  :             *n_total = width;
; 293  :     }
; 294  :     else {

  00017	eb 08		 jmp	 SHORT $LN8@calc_paddi
$LN11@calc_paddi:

; 295  :         /* not specified, use all of the chars and no more */
; 296  :         *n_total = nchars;

  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n_total$[rsp]
  0001e	4c 89 11	 mov	 QWORD PTR [rcx], r10
$LN8@calc_paddi:

; 297  :     }
; 298  : 
; 299  :     /* Figure out how much leading space we need, based on the
; 300  :        aligning */
; 301  :     if (align == '>')

  00021	41 83 f8 3e	 cmp	 r8d, 62			; 0000003eH
  00025	75 1b		 jne	 SHORT $LN7@calc_paddi

; 302  :         *n_lpadding = *n_total - nchars;

  00027	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0002a	49 2b c2	 sub	 rax, r10
  0002d	49 89 01	 mov	 QWORD PTR [r9], rax

; 305  :     else if (align == '<' || align == '=')
; 306  :         *n_lpadding = 0;
; 307  :     else {
; 308  :         /* We should never have an unspecified alignment. */
; 309  :         *n_lpadding = 0;
; 310  :         assert(0);
; 311  :     }
; 312  : 
; 313  :     *n_rpadding = *n_total - nchars - *n_lpadding;

  00030	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00033	48 2b c8	 sub	 rcx, rax
  00036	48 8b 44 24 28	 mov	 rax, QWORD PTR n_rpadding$[rsp]
  0003b	49 2b ca	 sub	 rcx, r10
  0003e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 314  : }

  00041	c3		 ret	 0
$LN7@calc_paddi:

; 303  :     else if (align == '^')

  00042	41 83 f8 5e	 cmp	 r8d, 94			; 0000005eH
  00046	75 23		 jne	 SHORT $LN2@calc_paddi

; 304  :         *n_lpadding = (*n_total - nchars) / 2;

  00048	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0004b	49 2b c2	 sub	 rax, r10
  0004e	48 99		 cdq
  00050	48 2b c2	 sub	 rax, rdx
  00053	48 d1 f8	 sar	 rax, 1
  00056	49 89 01	 mov	 QWORD PTR [r9], rax

; 305  :     else if (align == '<' || align == '=')
; 306  :         *n_lpadding = 0;
; 307  :     else {
; 308  :         /* We should never have an unspecified alignment. */
; 309  :         *n_lpadding = 0;
; 310  :         assert(0);
; 311  :     }
; 312  : 
; 313  :     *n_rpadding = *n_total - nchars - *n_lpadding;

  00059	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0005c	48 2b c8	 sub	 rcx, rax
  0005f	48 8b 44 24 28	 mov	 rax, QWORD PTR n_rpadding$[rsp]
  00064	49 2b ca	 sub	 rcx, r10
  00067	48 89 08	 mov	 QWORD PTR [rax], rcx

; 314  : }

  0006a	c3		 ret	 0
$LN2@calc_paddi:

; 305  :     else if (align == '<' || align == '=')
; 306  :         *n_lpadding = 0;
; 307  :     else {
; 308  :         /* We should never have an unspecified alignment. */
; 309  :         *n_lpadding = 0;
; 310  :         assert(0);
; 311  :     }
; 312  : 
; 313  :     *n_rpadding = *n_total - nchars - *n_lpadding;

  0006b	48 8b 44 24 28	 mov	 rax, QWORD PTR n_rpadding$[rsp]
  00070	49 c7 01 00 00
	00 00		 mov	 QWORD PTR [r9], 0
  00077	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007a	49 2b 09	 sub	 rcx, QWORD PTR [r9]
  0007d	49 2b ca	 sub	 rcx, r10
  00080	48 89 08	 mov	 QWORD PTR [rax], rcx

; 314  : }

  00083	c3		 ret	 0
calc_padding ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_FastFill:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_padding DD imagerel fill_padding
	DD	imagerel fill_padding+113
	DD	imagerel $unwind$fill_padding
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_padding DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT fill_padding
_TEXT	SEGMENT
writer$ = 48
nchars$ = 56
fill_char$ = 64
n_lpadding$ = 72
n_rpadding$ = 80
fill_padding PROC					; COMDAT

; 323  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	49 8b f9	 mov	 rdi, r9
  00017	41 8b f0	 mov	 esi, r8d
  0001a	48 8b ea	 mov	 rbp, rdx
  0001d	48 8b d9	 mov	 rbx, rcx

; 324  :     Py_ssize_t pos;
; 325  : 
; 326  :     /* Pad on left. */
; 327  :     if (n_lpadding) {

  00020	4d 85 c9	 test	 r9, r9
  00023	74 12		 je	 SHORT $LN2@fill_paddi

; 328  :         pos = writer->pos;
; 329  :         _PyUnicode_FastFill(writer->buffer, pos, n_lpadding, fill_char);

  00025	48 8b 51 20	 mov	 rdx, QWORD PTR [rcx+32]
  00029	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002c	45 8b c8	 mov	 r9d, r8d
  0002f	4c 8b c7	 mov	 r8, rdi
  00032	e8 00 00 00 00	 call	 _PyUnicode_FastFill
$LN2@fill_paddi:

; 330  :     }
; 331  : 
; 332  :     /* Pad on right. */
; 333  :     if (n_rpadding) {

  00037	4c 8b 44 24 50	 mov	 r8, QWORD PTR n_rpadding$[rsp]
  0003c	4d 85 c0	 test	 r8, r8
  0003f	74 15		 je	 SHORT $LN1@fill_paddi

; 334  :         pos = writer->pos + nchars + n_lpadding;

  00041	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]

; 335  :         _PyUnicode_FastFill(writer->buffer, pos, n_rpadding, fill_char);

  00045	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00048	44 8b ce	 mov	 r9d, esi
  0004b	48 03 d5	 add	 rdx, rbp
  0004e	48 03 d7	 add	 rdx, rdi
  00051	e8 00 00 00 00	 call	 _PyUnicode_FastFill
$LN1@fill_paddi:

; 336  :     }
; 337  : 
; 338  :     /* Pointer to the user content. */
; 339  :     writer->pos += n_lpadding;

  00056	48 01 7b 20	 add	 QWORD PTR [rbx+32], rdi

; 340  :     return 0;
; 341  : }

  0005a	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0005f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00064	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00069	33 c0		 xor	 eax, eax
  0006b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006f	5f		 pop	 rdi
  00070	c3		 ret	 0
fill_padding ENDP
_TEXT	ENDS
EXTRN	_Py_ctype_table:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$parse_number DD imagerel parse_number
	DD	imagerel parse_number+21
	DD	imagerel $unwind$parse_number
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$parse_number DD imagerel parse_number+21
	DD	imagerel parse_number+239
	DD	imagerel $chain$0$parse_number
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$parse_number DD imagerel parse_number+239
	DD	imagerel parse_number+429
	DD	imagerel $chain$1$parse_number
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$parse_number DD 021H
	DD	imagerel parse_number
	DD	imagerel parse_number+21
	DD	imagerel $unwind$parse_number
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$parse_number DD 020521H
	DD	027405H
	DD	imagerel parse_number
	DD	imagerel parse_number+21
	DD	imagerel $unwind$parse_number
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parse_number DD 010201H
	DD	03002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT parse_number
_TEXT	SEGMENT
s$ = 16
pos$ = 24
end$ = 32
n_remainder$ = 40
has_decimal$ = 48
parse_number PROC					; COMDAT

; 401  : {

  00000	40 53		 push	 rbx
  00002	49 8b d9	 mov	 rbx, r9
  00005	4d 8b c8	 mov	 r9, r8

; 402  :     Py_ssize_t remainder;
; 403  : 
; 404  :     while (pos<end && Py_ISDIGIT(PyUnicode_READ_CHAR(s, pos)))

  00008	49 3b d0	 cmp	 rdx, r8
  0000b	0f 8d de 00 00
	00		 jge	 $LN42@parse_numb
  00011	44 8b 51 70	 mov	 r10d, DWORD PTR [rcx+112]
  00015	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi
  0001a	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_ctype_table
  00021	45 8b da	 mov	 r11d, r10d
  00024	41 c1 eb 02	 shr	 r11d, 2
  00028	41 83 e3 07	 and	 r11d, 7
  0002c	0f 1f 40 00	 npad	 4
$LL3@parse_numb:
  00030	41 83 fb 01	 cmp	 r11d, 1
  00034	75 39		 jne	 SHORT $LN20@parse_numb
  00036	41 f6 c2 20	 test	 r10b, 32		; 00000020H
  0003a	74 25		 je	 SHORT $LN8@parse_numb
  0003c	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  00040	74 11		 je	 SHORT $LN6@parse_numb
  00042	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  00049	44 0f b6 04 10	 movzx	 r8d, BYTE PTR [rax+rdx]
  0004e	e9 81 00 00 00	 jmp	 $LN19@parse_numb
$LN6@parse_numb:
  00053	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  0005a	44 0f b6 04 10	 movzx	 r8d, BYTE PTR [rax+rdx]
  0005f	eb 73		 jmp	 SHORT $LN19@parse_numb
$LN8@parse_numb:
  00061	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
  00068	44 0f b6 04 10	 movzx	 r8d, BYTE PTR [rax+rdx]
  0006d	eb 65		 jmp	 SHORT $LN19@parse_numb
$LN20@parse_numb:
  0006f	41 83 fb 02	 cmp	 r11d, 2
  00073	75 36		 jne	 SHORT $LN18@parse_numb
  00075	41 f6 c2 20	 test	 r10b, 32		; 00000020H
  00079	74 22		 je	 SHORT $LN12@parse_numb
  0007b	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  0007f	74 0e		 je	 SHORT $LN10@parse_numb
  00081	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  00088	44 0f b7 04 50	 movzx	 r8d, WORD PTR [rax+rdx*2]
  0008d	eb 45		 jmp	 SHORT $LN19@parse_numb
$LN10@parse_numb:
  0008f	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  00096	44 0f b7 04 50	 movzx	 r8d, WORD PTR [rax+rdx*2]
  0009b	eb 37		 jmp	 SHORT $LN19@parse_numb
$LN12@parse_numb:
  0009d	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
  000a4	44 0f b7 04 50	 movzx	 r8d, WORD PTR [rax+rdx*2]
  000a9	eb 29		 jmp	 SHORT $LN19@parse_numb
$LN18@parse_numb:
  000ab	41 f6 c2 20	 test	 r10b, 32		; 00000020H
  000af	74 18		 je	 SHORT $LN16@parse_numb
  000b1	41 f6 c2 40	 test	 r10b, 64		; 00000040H
  000b5	74 09		 je	 SHORT $LN14@parse_numb
  000b7	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  000be	eb 10		 jmp	 SHORT $LN17@parse_numb
$LN14@parse_numb:
  000c0	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  000c7	eb 07		 jmp	 SHORT $LN17@parse_numb
$LN16@parse_numb:
  000c9	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
$LN17@parse_numb:
  000d0	44 8b 04 90	 mov	 r8d, DWORD PTR [rax+rdx*4]
$LN19@parse_numb:
  000d4	41 0f b6 c0	 movzx	 eax, r8b
  000d8	f6 04 87 04	 test	 BYTE PTR [rdi+rax*4], 4
  000dc	74 0c		 je	 SHORT $LN43@parse_numb

; 405  :         ++pos;

  000de	48 ff c2	 inc	 rdx
  000e1	49 3b d1	 cmp	 rdx, r9
  000e4	0f 8c 46 ff ff
	ff		 jl	 $LL3@parse_numb
$LN43@parse_numb:
  000ea	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
$LN42@parse_numb:

; 406  :     remainder = pos;
; 407  : 
; 408  :     /* Does remainder start with a decimal point? */
; 409  :     *has_decimal = pos<end && PyUnicode_READ_CHAR(s, remainder) == '.';

  000ef	49 3b d1	 cmp	 rdx, r9
  000f2	0f 8d 9d 00 00
	00		 jge	 $LN38@parse_numb
  000f8	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  000fb	44 8b c0	 mov	 r8d, eax
  000fe	41 c1 e8 02	 shr	 r8d, 2
  00102	41 83 e0 07	 and	 r8d, 7
  00106	41 83 f8 01	 cmp	 r8d, 1
  0010a	75 2c		 jne	 SHORT $LN36@parse_numb
  0010c	a8 20		 test	 al, 32			; 00000020H
  0010e	74 1b		 je	 SHORT $LN24@parse_numb
  00110	a8 40		 test	 al, 64			; 00000040H
  00112	74 0a		 je	 SHORT $LN22@parse_numb
  00114	48 83 e9 80	 sub	 rcx, -128		; ffffffffffffff80H
  00118	0f b6 04 11	 movzx	 eax, BYTE PTR [rcx+rdx]
  0011c	eb 6d		 jmp	 SHORT $LN35@parse_numb
$LN22@parse_numb:
  0011e	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  00125	0f b6 04 11	 movzx	 eax, BYTE PTR [rcx+rdx]
  00129	eb 60		 jmp	 SHORT $LN35@parse_numb
$LN24@parse_numb:
  0012b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00132	0f b6 04 11	 movzx	 eax, BYTE PTR [rcx+rdx]
  00136	eb 53		 jmp	 SHORT $LN35@parse_numb
$LN36@parse_numb:
  00138	41 83 f8 02	 cmp	 r8d, 2
  0013c	75 2c		 jne	 SHORT $LN34@parse_numb
  0013e	a8 20		 test	 al, 32			; 00000020H
  00140	74 1b		 je	 SHORT $LN28@parse_numb
  00142	a8 40		 test	 al, 64			; 00000040H
  00144	74 0a		 je	 SHORT $LN26@parse_numb
  00146	48 83 e9 80	 sub	 rcx, -128		; ffffffffffffff80H
  0014a	0f b7 04 51	 movzx	 eax, WORD PTR [rcx+rdx*2]
  0014e	eb 3b		 jmp	 SHORT $LN35@parse_numb
$LN26@parse_numb:
  00150	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  00157	0f b7 04 51	 movzx	 eax, WORD PTR [rcx+rdx*2]
  0015b	eb 2e		 jmp	 SHORT $LN35@parse_numb
$LN28@parse_numb:
  0015d	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00164	0f b7 04 51	 movzx	 eax, WORD PTR [rcx+rdx*2]
  00168	eb 21		 jmp	 SHORT $LN35@parse_numb
$LN34@parse_numb:
  0016a	a8 20		 test	 al, 32			; 00000020H
  0016c	74 13		 je	 SHORT $LN32@parse_numb
  0016e	a8 40		 test	 al, 64			; 00000040H
  00170	74 06		 je	 SHORT $LN30@parse_numb
  00172	48 83 e9 80	 sub	 rcx, -128		; ffffffffffffff80H
  00176	eb 10		 jmp	 SHORT $LN33@parse_numb
$LN30@parse_numb:
  00178	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  0017f	eb 07		 jmp	 SHORT $LN33@parse_numb
$LN32@parse_numb:
  00181	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
$LN33@parse_numb:
  00188	8b 04 91	 mov	 eax, DWORD PTR [rcx+rdx*4]
$LN35@parse_numb:
  0018b	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0018e	75 05		 jne	 SHORT $LN38@parse_numb
  00190	8d 48 d3	 lea	 ecx, QWORD PTR [rax-45]
  00193	eb 02		 jmp	 SHORT $LN39@parse_numb
$LN38@parse_numb:
  00195	33 c9		 xor	 ecx, ecx
$LN39@parse_numb:
  00197	48 8b 44 24 30	 mov	 rax, QWORD PTR has_decimal$[rsp]
  0019c	89 08		 mov	 DWORD PTR [rax], ecx

; 410  : 
; 411  :     /* Skip the decimal point. */
; 412  :     if (*has_decimal)

  0019e	85 c9		 test	 ecx, ecx
  001a0	74 03		 je	 SHORT $LN1@parse_numb

; 413  :         remainder++;

  001a2	48 ff c2	 inc	 rdx
$LN1@parse_numb:

; 414  : 
; 415  :     *n_remainder = end - remainder;

  001a5	4c 2b ca	 sub	 r9, rdx
  001a8	4c 89 0b	 mov	 QWORD PTR [rbx], r9

; 416  : }

  001ab	5b		 pop	 rbx
  001ac	c3		 ret	 0
parse_number ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_InsertThousandsGrouping:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$calc_number_widths DD imagerel calc_number_widths
	DD	imagerel calc_number_widths+633
	DD	imagerel $unwind$calc_number_widths
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$calc_number_widths DD 0a1801H
	DD	0106418H
	DD	0f5418H
	DD	0e3418H
	DD	0d0149218H
	DD	07010c012H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT calc_number_widths
_TEXT	SEGMENT
spec$ = 112
n_prefix$ = 120
sign_char$ = 128
n_start$ = 136
n_end$ = 144
n_remainder$ = 152
grouping_maxchar$21167 = 160
has_decimal$ = 160
locale$ = 168
format$ = 176
maxchar$ = 184
calc_number_widths PROC					; COMDAT

; 428  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 429  :     Py_ssize_t n_non_digit_non_padding;
; 430  :     Py_ssize_t n_padding;
; 431  : 
; 432  :     spec->n_digits = n_end - n_start - n_remainder - (has_decimal?1:0);

  00018	44 8b 94 24 a0
	00 00 00	 mov	 r10d, DWORD PTR has_decimal$[rsp]

; 433  :     spec->n_lpadding = 0;
; 434  :     spec->n_prefix = n_prefix;
; 435  :     spec->n_decimal = has_decimal ? PyUnicode_GET_LENGTH(locale->decimal_point) : 0;

  00020	4c 8b a4 24 a8
	00 00 00	 mov	 r12, QWORD PTR locale$[rsp]
  00028	48 8b d9	 mov	 rbx, rcx
  0002b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR n_end$[rsp]
  00033	45 33 ed	 xor	 r13d, r13d
  00036	45 85 d2	 test	 r10d, r10d
  00039	41 8b c5	 mov	 eax, r13d
  0003c	0f 95 c0	 setne	 al
  0003f	45 8b d8	 mov	 r11d, r8d
  00042	48 2b c8	 sub	 rcx, rax
  00045	48 8b ea	 mov	 rbp, rdx
  00048	4c 89 2b	 mov	 QWORD PTR [rbx], r13
  0004b	49 2b c9	 sub	 rcx, r9
  0004e	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR n_remainder$[rsp]
  00056	48 89 53 08	 mov	 QWORD PTR [rbx+8], rdx
  0005a	49 2b c9	 sub	 rcx, r9
  0005d	48 89 4b 48	 mov	 QWORD PTR [rbx+72], rcx
  00061	45 85 d2	 test	 r10d, r10d
  00064	74 0a		 je	 SHORT $LN24@calc_numbe
  00066	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  0006a	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0006e	eb 03		 jmp	 SHORT $LN25@calc_numbe
$LN24@calc_numbe:
  00070	49 8b d5	 mov	 rdx, r13
$LN25@calc_numbe:

; 436  :     spec->n_remainder = n_remainder;
; 437  :     spec->n_spadding = 0;
; 438  :     spec->n_rpadding = 0;
; 439  :     spec->sign = '\0';
; 440  :     spec->n_sign = 0;
; 441  : 
; 442  :     /* the output will look like:
; 443  :        |                                                                                         |
; 444  :        | <lpadding> <sign> <prefix> <spadding> <grouped_digits> <decimal> <remainder> <rpadding> |
; 445  :        |                                                                                         |
; 446  : 
; 447  :        sign is computed from format->sign and the actual
; 448  :        sign of the number
; 449  : 
; 450  :        prefix is given (it's for the '0x' prefix)
; 451  : 
; 452  :        digits is already known
; 453  : 
; 454  :        the total width is either given, or computed from the
; 455  :        actual digits
; 456  : 
; 457  :        only one of lpadding, spadding, and rpadding can be non-zero,
; 458  :        and it's calculated from the width and other fields
; 459  :     */
; 460  : 
; 461  :     /* compute the various parts we're going to write */
; 462  :     switch (format->sign) {

  00073	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR format$[rsp]
  0007b	48 89 53 38	 mov	 QWORD PTR [rbx+56], rdx
  0007f	4c 89 4b 40	 mov	 QWORD PTR [rbx+64], r9
  00083	4c 89 6b 10	 mov	 QWORD PTR [rbx+16], r13
  00087	4c 89 6b 18	 mov	 QWORD PTR [rbx+24], r13
  0008b	44 88 6b 20	 mov	 BYTE PTR [rbx+32], r13b
  0008f	4c 89 6b 28	 mov	 QWORD PTR [rbx+40], r13
  00093	8b 46 0c	 mov	 eax, DWORD PTR [rsi+12]
  00096	83 f8 20	 cmp	 eax, 32			; 00000020H
  00099	74 18		 je	 SHORT $LN18@calc_numbe
  0009b	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0009e	74 0c		 je	 SHORT $LN19@calc_numbe

; 471  :         break;
; 472  :     default:
; 473  :         /* Not specified, or the default (-) */
; 474  :         if (sign_char == '-') {

  000a0	41 83 f8 2d	 cmp	 r8d, 45			; 0000002dH
  000a4	75 2a		 jne	 SHORT $LN16@calc_numbe

; 475  :             spec->n_sign = 1;
; 476  :             spec->sign = '-';

  000a6	44 88 43 20	 mov	 BYTE PTR [rbx+32], r8b
  000aa	eb 1c		 jmp	 SHORT $LN40@calc_numbe
$LN19@calc_numbe:

; 463  :     case '+':
; 464  :         /* always put a + or - */
; 465  :         spec->n_sign = 1;
; 466  :         spec->sign = (sign_char == '-' ? '-' : '+');

  000ac	b8 2b 00 00 00	 mov	 eax, 43			; 0000002bH

; 467  :         break;

  000b1	eb 05		 jmp	 SHORT $LN41@calc_numbe
$LN18@calc_numbe:

; 470  :         spec->sign = (sign_char == '-' ? '-' : ' ');

  000b3	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
$LN41@calc_numbe:
  000b8	41 b8 2d 00 00
	00		 mov	 r8d, 45			; 0000002dH
  000be	45 3b d8	 cmp	 r11d, r8d
  000c1	41 0f 44 c0	 cmove	 eax, r8d
  000c5	88 43 20	 mov	 BYTE PTR [rbx+32], al
$LN40@calc_numbe:

; 468  :     case ' ':
; 469  :         spec->n_sign = 1;

  000c8	48 c7 43 28 01
	00 00 00	 mov	 QWORD PTR [rbx+40], 1
$LN16@calc_numbe:

; 477  :         }
; 478  :     }
; 479  : 
; 480  :     /* The number of chars used for non-digits and non-padding. */
; 481  :     n_non_digit_non_padding = spec->n_sign + spec->n_prefix + spec->n_decimal +
; 482  :         spec->n_remainder;

  000d0	48 8b 7b 28	 mov	 rdi, QWORD PTR [rbx+40]
  000d4	48 03 fa	 add	 rdi, rdx
  000d7	48 03 fd	 add	 rdi, rbp
  000da	49 03 f9	 add	 rdi, r9

; 483  : 
; 484  :     /* min_width can go negative, that's okay. format->width == -1 means
; 485  :        we don't care. */
; 486  :     if (format->fill_char == '0' && format->align == '=')

  000dd	83 3e 30	 cmp	 DWORD PTR [rsi], 48	; 00000030H
  000e0	75 13		 jne	 SHORT $LN15@calc_numbe
  000e2	83 7e 04 3d	 cmp	 DWORD PTR [rsi+4], 61	; 0000003dH
  000e6	75 0d		 jne	 SHORT $LN15@calc_numbe

; 487  :         spec->n_min_width = format->width - n_non_digit_non_padding;

  000e8	48 8b 46 10	 mov	 rax, QWORD PTR [rsi+16]
  000ec	48 2b c7	 sub	 rax, rdi
  000ef	48 89 43 50	 mov	 QWORD PTR [rbx+80], rax

; 488  :     else

  000f3	eb 04		 jmp	 SHORT $LN14@calc_numbe
$LN15@calc_numbe:

; 489  :         spec->n_min_width = 0;

  000f5	4c 89 6b 50	 mov	 QWORD PTR [rbx+80], r13
$LN14@calc_numbe:

; 490  : 
; 491  :     if (spec->n_digits == 0)

  000f9	48 8b ac 24 b8
	00 00 00	 mov	 rbp, QWORD PTR maxchar$[rsp]
  00101	48 85 c9	 test	 rcx, rcx
  00104	75 06		 jne	 SHORT $LN13@calc_numbe

; 492  :         /* This case only occurs when using 'c' formatting, we need
; 493  :            to special case it because the grouping code always wants
; 494  :            to have at least one character. */
; 495  :         spec->n_grouped_digits = 0;

  00106	4c 89 6b 30	 mov	 QWORD PTR [rbx+48], r13

; 496  :     else {

  0010a	eb 54		 jmp	 SHORT $LN12@calc_numbe
$LN13@calc_numbe:

; 497  :         Py_UCS4 grouping_maxchar;
; 498  :         spec->n_grouped_digits = _PyUnicode_InsertThousandsGrouping(
; 499  :             NULL, 0,
; 500  :             0, NULL,
; 501  :             spec->n_digits, spec->n_min_width,
; 502  :             locale->grouping, locale->thousands_sep, &grouping_maxchar);

  0010c	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR grouping_maxchar$21167[rsp]
  00114	45 33 c9	 xor	 r9d, r9d
  00117	45 33 c0	 xor	 r8d, r8d
  0011a	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0011f	49 8b 44 24 08	 mov	 rax, QWORD PTR [r12+8]
  00124	33 d2		 xor	 edx, edx
  00126	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0012b	49 8b 44 24 10	 mov	 rax, QWORD PTR [r12+16]
  00130	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00135	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00139	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0013e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00143	33 c9		 xor	 ecx, ecx
  00145	e8 00 00 00 00	 call	 _PyUnicode_InsertThousandsGrouping

; 503  :         *maxchar = Py_MAX(*maxchar, grouping_maxchar);

  0014a	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR grouping_maxchar$21167[rsp]
  00151	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax
  00155	8b 45 00	 mov	 eax, DWORD PTR [rbp]
  00158	3b c1		 cmp	 eax, ecx
  0015a	0f 47 c8	 cmova	 ecx, eax
  0015d	89 4d 00	 mov	 DWORD PTR [rbp], ecx
$LN12@calc_numbe:

; 504  :     }
; 505  : 
; 506  :     /* Given the desired width and the total of digit and non-digit
; 507  :        space we consume, see if we need any padding. format->width can
; 508  :        be negative (meaning no padding), but this code still works in
; 509  :        that case. */
; 510  :     n_padding = format->width -
; 511  :                         (n_non_digit_non_padding + spec->n_grouped_digits);

  00160	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  00164	48 2b 4b 30	 sub	 rcx, QWORD PTR [rbx+48]
  00168	48 2b cf	 sub	 rcx, rdi

; 512  :     if (n_padding > 0) {

  0016b	48 85 c9	 test	 rcx, rcx
  0016e	7e 2f		 jle	 SHORT $LN9@calc_numbe

; 513  :         /* Some padding is needed. Determine if it's left, space, or right. */
; 514  :         switch (format->align) {

  00170	8b 56 04	 mov	 edx, DWORD PTR [rsi+4]
  00173	83 ea 3c	 sub	 edx, 60			; 0000003cH
  00176	74 23		 je	 SHORT $LN8@calc_numbe
  00178	ff ca		 dec	 edx
  0017a	74 68		 je	 SHORT $LN6@calc_numbe
  0017c	ff ca		 dec	 edx
  0017e	74 05		 je	 SHORT $LN5@calc_numbe
  00180	83 fa 20	 cmp	 edx, 32			; 00000020H
  00183	74 05		 je	 SHORT $LN7@calc_numbe
$LN5@calc_numbe:

; 525  :         case '>':
; 526  :             spec->n_lpadding = n_padding;
; 527  :             break;
; 528  :         default:
; 529  :             /* Shouldn't get here, but treat it as '>' */
; 530  :             spec->n_lpadding = n_padding;

  00185	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 531  :             assert(0);
; 532  :             break;

  00188	eb 15		 jmp	 SHORT $LN9@calc_numbe
$LN7@calc_numbe:

; 517  :             break;
; 518  :         case '^':
; 519  :             spec->n_lpadding = n_padding / 2;

  0018a	48 8b c1	 mov	 rax, rcx
  0018d	48 99		 cdq
  0018f	48 2b c2	 sub	 rax, rdx
  00192	48 d1 f8	 sar	 rax, 1
  00195	48 89 03	 mov	 QWORD PTR [rbx], rax

; 520  :             spec->n_rpadding = n_padding - spec->n_lpadding;

  00198	48 2b c8	 sub	 rcx, rax
$LN8@calc_numbe:

; 515  :         case '<':
; 516  :             spec->n_rpadding = n_padding;

  0019b	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx
$LN9@calc_numbe:

; 533  :         }
; 534  :     }
; 535  : 
; 536  :     if (spec->n_lpadding || spec->n_spadding || spec->n_rpadding)

  0019f	4c 39 2b	 cmp	 QWORD PTR [rbx], r13
  001a2	75 0c		 jne	 SHORT $LN2@calc_numbe
  001a4	4c 39 6b 10	 cmp	 QWORD PTR [rbx+16], r13
  001a8	75 06		 jne	 SHORT $LN2@calc_numbe
  001aa	4c 39 6b 18	 cmp	 QWORD PTR [rbx+24], r13
  001ae	74 0d		 je	 SHORT $LN3@calc_numbe
$LN2@calc_numbe:

; 537  :         *maxchar = Py_MAX(*maxchar, format->fill_char);

  001b0	8b 45 00	 mov	 eax, DWORD PTR [rbp]
  001b3	8b 0e		 mov	 ecx, DWORD PTR [rsi]
  001b5	3b c1		 cmp	 eax, ecx
  001b7	0f 47 c8	 cmova	 ecx, eax
  001ba	89 4d 00	 mov	 DWORD PTR [rbp], ecx
$LN3@calc_numbe:

; 538  : 
; 539  :     if (spec->n_decimal)

  001bd	4c 39 6b 38	 cmp	 QWORD PTR [rbx+56], r13
  001c1	74 7b		 je	 SHORT $LN1@calc_numbe

; 540  :         *maxchar = Py_MAX(*maxchar, PyUnicode_MAX_CHAR_VALUE(locale->decimal_point));

  001c3	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  001c7	41 b9 ff ff 00
	00		 mov	 r9d, 65535		; 0000ffffH
  001cd	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  001d0	44 8b c1	 mov	 r8d, ecx
  001d3	41 c1 e8 06	 shr	 r8d, 6
  001d7	41 83 e0 01	 and	 r8d, 1
  001db	74 0d		 je	 SHORT $LN32@calc_numbe
  001dd	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  001e2	eb 26		 jmp	 SHORT $LN31@calc_numbe
$LN6@calc_numbe:

; 521  :             break;
; 522  :         case '=':
; 523  :             spec->n_spadding = n_padding;

  001e4	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx

; 524  :             break;

  001e8	eb b5		 jmp	 SHORT $LN9@calc_numbe
$LN32@calc_numbe:

; 540  :         *maxchar = Py_MAX(*maxchar, PyUnicode_MAX_CHAR_VALUE(locale->decimal_point));

  001ea	8b c1		 mov	 eax, ecx
  001ec	c1 e8 02	 shr	 eax, 2
  001ef	83 e0 07	 and	 eax, 7
  001f2	83 f8 01	 cmp	 eax, 1
  001f5	75 07		 jne	 SHORT $LN30@calc_numbe
  001f7	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  001fc	eb 0c		 jmp	 SHORT $LN31@calc_numbe
$LN30@calc_numbe:
  001fe	ba ff ff 10 00	 mov	 edx, 1114111		; 0010ffffH
  00203	83 f8 02	 cmp	 eax, 2
  00206	41 0f 44 d1	 cmove	 edx, r9d
$LN31@calc_numbe:
  0020a	8b 45 00	 mov	 eax, DWORD PTR [rbp]
  0020d	3b c2		 cmp	 eax, edx
  0020f	77 2a		 ja	 SHORT $LN35@calc_numbe
  00211	45 85 c0	 test	 r8d, r8d
  00214	74 07		 je	 SHORT $LN36@calc_numbe
  00216	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  0021b	eb 1e		 jmp	 SHORT $LN35@calc_numbe
$LN36@calc_numbe:
  0021d	c1 e9 02	 shr	 ecx, 2
  00220	83 e1 07	 and	 ecx, 7
  00223	83 f9 01	 cmp	 ecx, 1
  00226	75 07		 jne	 SHORT $LN34@calc_numbe
  00228	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0022d	eb 0c		 jmp	 SHORT $LN35@calc_numbe
$LN34@calc_numbe:
  0022f	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH
  00234	83 f9 02	 cmp	 ecx, 2
  00237	41 0f 44 c1	 cmove	 eax, r9d
$LN35@calc_numbe:
  0023b	89 45 00	 mov	 DWORD PTR [rbp], eax
$LN1@calc_numbe:

; 541  : 
; 542  :     return spec->n_lpadding + spec->n_sign + spec->n_prefix +
; 543  :         spec->n_spadding + spec->n_grouped_digits + spec->n_decimal +
; 544  :         spec->n_remainder + spec->n_rpadding;

  0023e	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]

; 545  : }

  00242	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  00247	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  0024f	48 03 43 10	 add	 rax, QWORD PTR [rbx+16]
  00253	48 03 43 08	 add	 rax, QWORD PTR [rbx+8]
  00257	48 03 03	 add	 rax, QWORD PTR [rbx]
  0025a	48 03 43 40	 add	 rax, QWORD PTR [rbx+64]
  0025e	48 03 43 30	 add	 rax, QWORD PTR [rbx+48]
  00262	48 03 43 28	 add	 rax, QWORD PTR [rbx+40]
  00266	48 03 43 18	 add	 rax, QWORD PTR [rbx+24]
  0026a	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0026f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00273	41 5d		 pop	 r13
  00275	41 5c		 pop	 r12
  00277	5f		 pop	 rdi
  00278	c3		 ret	 0
calc_number_widths ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@PDACIMOE@non?9ascii?5grouped?5digit?$AA@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_SystemError:QWORD
EXTRN	PyMem_Free:PROC
EXTRN	_PyUnicode_AsKind:PROC
EXTRN	_PyUnicode_Ready:PROC
EXTRN	_Py_ctype_toupper:BYTE
EXTRN	_PyUnicode_FastCopyCharacters:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_number DD imagerel fill_number
	DD	imagerel fill_number+901
	DD	imagerel $unwind$fill_number
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_number DD 0a1b01H
	DD	013541bH
	DD	011341bH
	DD	0e017921bH
	DD	0c013d015H
	DD	060107011H
xdata	ENDS
;	COMDAT ??_C@_0BI@PDACIMOE@non?9ascii?5grouped?5digit?$AA@
CONST	SEGMENT
??_C@_0BI@PDACIMOE@non?9ascii?5grouped?5digit?$AA@ DB 'non-ascii grouped '
	DB	'digit', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fill_number
_TEXT	SEGMENT
d_pos$1$ = 128
writer$ = 128
spec$ = 136
digits$ = 144
d_start$ = 152
prefix$ = 160
p_start$ = 168
fill_char$ = 176
locale$ = 184
toupper$ = 192
fill_number PROC					; COMDAT

; 556  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	41 54		 push	 r12
  00013	41 55		 push	 r13
  00015	41 56		 push	 r14
  00017	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 557  :     /* Used to keep track of digits, decimal, and remainder. */
; 558  :     Py_ssize_t d_pos = d_start;
; 559  :     const enum PyUnicode_Kind kind = writer->kind;

  0001b	48 63 71 10	 movsxd	 rsi, DWORD PTR [rcx+16]

; 560  :     const void *data = writer->data;

  0001f	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]

; 561  :     Py_ssize_t r;
; 562  : 
; 563  :     if (spec->n_lpadding) {

  00023	44 8b b4 24 b0
	00 00 00	 mov	 r14d, DWORD PTR fill_char$[rsp]
  0002b	4d 8b e8	 mov	 r13, r8
  0002e	4c 8b 02	 mov	 r8, QWORD PTR [rdx]
  00031	4c 89 8c 24 80
	00 00 00	 mov	 QWORD PTR d_pos$1$[rsp], r9
  00039	48 8b ea	 mov	 rbp, rdx
  0003c	48 8b d9	 mov	 rbx, rcx
  0003f	4d 85 c0	 test	 r8, r8
  00042	74 17		 je	 SHORT $LN46@fill_numbe

; 564  :         _PyUnicode_FastFill(writer->buffer,
; 565  :                             writer->pos, spec->n_lpadding, fill_char);

  00044	48 8b 51 20	 mov	 rdx, QWORD PTR [rcx+32]
  00048	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004b	45 8b ce	 mov	 r9d, r14d
  0004e	e8 00 00 00 00	 call	 _PyUnicode_FastFill

; 566  :         writer->pos += spec->n_lpadding;

  00053	4c 8b 5d 00	 mov	 r11, QWORD PTR [rbp]
  00057	4c 01 5b 20	 add	 QWORD PTR [rbx+32], r11
$LN46@fill_numbe:

; 567  :     }
; 568  :     if (spec->n_sign == 1) {

  0005b	48 83 7d 28 01	 cmp	 QWORD PTR [rbp+40], 1
  00060	75 2c		 jne	 SHORT $LN45@fill_numbe

; 569  :         PyUnicode_WRITE(kind, data, writer->pos, spec->sign);

  00062	8b ce		 mov	 ecx, esi
  00064	ff c9		 dec	 ecx
  00066	74 17		 je	 SHORT $LN39@fill_numbe
  00068	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0006c	ff c9		 dec	 ecx
  0006e	0f be 4d 20	 movsx	 ecx, BYTE PTR [rbp+32]
  00072	74 05		 je	 SHORT $LN38@fill_numbe
  00074	89 0c 87	 mov	 DWORD PTR [rdi+rax*4], ecx
  00077	eb 11		 jmp	 SHORT $LN43@fill_numbe
$LN38@fill_numbe:
  00079	66 89 0c 47	 mov	 WORD PTR [rdi+rax*2], cx
  0007d	eb 0b		 jmp	 SHORT $LN43@fill_numbe
$LN39@fill_numbe:
  0007f	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00083	0f b6 45 20	 movzx	 eax, BYTE PTR [rbp+32]
  00087	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al
$LN43@fill_numbe:

; 570  :         writer->pos++;

  0008a	48 ff 43 20	 inc	 QWORD PTR [rbx+32]
$LN45@fill_numbe:

; 571  :     }
; 572  :     if (spec->n_prefix) {

  0008e	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  00092	45 33 e4	 xor	 r12d, r12d
  00095	48 85 c0	 test	 rax, rax
  00098	0f 84 99 00 00
	00		 je	 $LN36@fill_numbe

; 573  :         _PyUnicode_FastCopyCharacters(writer->buffer, writer->pos,
; 574  :                                       prefix, p_start,
; 575  :                                       spec->n_prefix);

  0009e	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR p_start$[rsp]
  000a6	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR prefix$[rsp]
  000ae	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  000b2	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000b5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ba	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 576  :         if (toupper) {

  000bf	44 39 a4 24 c0
	00 00 00	 cmp	 DWORD PTR toupper$[rsp], r12d
  000c7	74 66		 je	 SHORT $LN32@fill_numbe

; 577  :             Py_ssize_t t;
; 578  :             for (t = 0; t < spec->n_prefix; t++) {

  000c9	41 8b d4	 mov	 edx, r12d
  000cc	48 39 55 08	 cmp	 QWORD PTR [rbp+8], rdx
  000d0	7e 5d		 jle	 SHORT $LN32@fill_numbe
  000d2	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:_Py_ctype_toupper
  000d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL34@fill_numbe:

; 579  :                 Py_UCS4 c = PyUnicode_READ(kind, data, writer->pos + t);

  000e0	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  000e4	48 03 ca	 add	 rcx, rdx
  000e7	83 fe 01	 cmp	 esi, 1
  000ea	75 06		 jne	 SHORT $LN51@fill_numbe
  000ec	0f b6 04 39	 movzx	 eax, BYTE PTR [rcx+rdi]
  000f0	eb 0e		 jmp	 SHORT $LN50@fill_numbe
$LN51@fill_numbe:
  000f2	83 fe 02	 cmp	 esi, 2
  000f5	75 06		 jne	 SHORT $LN49@fill_numbe
  000f7	0f b7 04 4f	 movzx	 eax, WORD PTR [rdi+rcx*2]
  000fb	eb 03		 jmp	 SHORT $LN50@fill_numbe
$LN49@fill_numbe:
  000fd	8b 04 8f	 mov	 eax, DWORD PTR [rdi+rcx*4]
$LN50@fill_numbe:

; 580  :                 c = Py_TOUPPER(c);

  00100	0f b6 c0	 movzx	 eax, al

; 581  :                 assert (c <= 127);
; 582  :                 PyUnicode_WRITE(kind, data, writer->pos + t, c);

  00103	44 8b c6	 mov	 r8d, esi
  00106	41 ff c8	 dec	 r8d
  00109	46 0f b6 0c 10	 movzx	 r9d, BYTE PTR [rax+r10]
  0010e	74 12		 je	 SHORT $LN26@fill_numbe
  00110	41 ff c8	 dec	 r8d
  00113	74 06		 je	 SHORT $LN25@fill_numbe
  00115	44 89 0c 8f	 mov	 DWORD PTR [rdi+rcx*4], r9d
  00119	eb 0b		 jmp	 SHORT $LN30@fill_numbe
$LN25@fill_numbe:
  0011b	66 44 89 0c 4f	 mov	 WORD PTR [rdi+rcx*2], r9w
  00120	eb 04		 jmp	 SHORT $LN30@fill_numbe
$LN26@fill_numbe:
  00122	44 88 0c 39	 mov	 BYTE PTR [rcx+rdi], r9b
$LN30@fill_numbe:

; 577  :             Py_ssize_t t;
; 578  :             for (t = 0; t < spec->n_prefix; t++) {

  00126	48 ff c2	 inc	 rdx
  00129	48 3b 55 08	 cmp	 rdx, QWORD PTR [rbp+8]
  0012d	7c b1		 jl	 SHORT $LL34@fill_numbe
$LN32@fill_numbe:

; 583  :             }
; 584  :         }
; 585  :         writer->pos += spec->n_prefix;

  0012f	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  00133	48 01 43 20	 add	 QWORD PTR [rbx+32], rax
$LN36@fill_numbe:

; 586  :     }
; 587  :     if (spec->n_spadding) {

  00137	4c 8b 45 10	 mov	 r8, QWORD PTR [rbp+16]
  0013b	4d 85 c0	 test	 r8, r8
  0013e	74 17		 je	 SHORT $LN23@fill_numbe

; 588  :         _PyUnicode_FastFill(writer->buffer,
; 589  :                             writer->pos, spec->n_spadding, fill_char);

  00140	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00144	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00147	45 8b ce	 mov	 r9d, r14d
  0014a	e8 00 00 00 00	 call	 _PyUnicode_FastFill

; 590  :         writer->pos += spec->n_spadding;

  0014f	4c 8b 5d 10	 mov	 r11, QWORD PTR [rbp+16]
  00153	4c 01 5b 20	 add	 QWORD PTR [rbx+32], r11
$LN23@fill_numbe:

; 591  :     }
; 592  : 
; 593  :     /* Only for type 'c' special case, it has no digits. */
; 594  :     if (spec->n_digits != 0) {

  00157	4c 8b b4 24 b8
	00 00 00	 mov	 r14, QWORD PTR locale$[rsp]
  0015f	4c 39 65 48	 cmp	 QWORD PTR [rbp+72], r12
  00163	0f 84 eb 00 00
	00		 je	 $LN68@fill_numbe

; 595  :         /* Fill the digits with InsertThousandsGrouping. */
; 596  :         char *pdigits;
; 597  :         if (PyUnicode_READY(digits))

  00169	41 f6 45 70 80	 test	 BYTE PTR [r13+112], 128	; 00000080H
  0016e	75 10		 jne	 SHORT $LN21@fill_numbe
  00170	49 8b cd	 mov	 rcx, r13
  00173	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00178	85 c0		 test	 eax, eax

; 598  :             return -1;

  0017a	0f 85 00 02 00
	00		 jne	 $LN69@fill_numbe
$LN21@fill_numbe:

; 599  :         pdigits = PyUnicode_DATA(digits);

  00180	41 8b 45 70	 mov	 eax, DWORD PTR [r13+112]
  00184	a8 20		 test	 al, 32			; 00000020H
  00186	74 13		 je	 SHORT $LN57@fill_numbe
  00188	a8 40		 test	 al, 64			; 00000040H
  0018a	74 06		 je	 SHORT $LN55@fill_numbe
  0018c	49 83 ed 80	 sub	 r13, -128		; ffffffffffffff80H
  00190	eb 10		 jmp	 SHORT $LN58@fill_numbe
$LN55@fill_numbe:
  00192	49 81 c5 a0 00
	00 00		 add	 r13, 160		; 000000a0H
  00199	eb 07		 jmp	 SHORT $LN58@fill_numbe
$LN57@fill_numbe:
  0019b	4d 8b ad a0 00
	00 00		 mov	 r13, QWORD PTR [r13+160]
$LN58@fill_numbe:

; 600  :         if (PyUnicode_KIND(digits) < kind) {

  001a2	c1 e8 02	 shr	 eax, 2
  001a5	83 e0 07	 and	 eax, 7
  001a8	3b c6		 cmp	 eax, esi
  001aa	73 1b		 jae	 SHORT $LN19@fill_numbe

; 601  :             pdigits = _PyUnicode_AsKind(digits, kind);

  001ac	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR digits$[rsp]
  001b4	8b d6		 mov	 edx, esi
  001b6	e8 00 00 00 00	 call	 _PyUnicode_AsKind
  001bb	4c 8b e8	 mov	 r13, rax

; 602  :             if (pdigits == NULL)

  001be	48 85 c0	 test	 rax, rax

; 603  :                 return -1;

  001c1	0f 84 b9 01 00
	00		 je	 $LN69@fill_numbe
$LN19@fill_numbe:

; 604  :         }
; 605  :         r = _PyUnicode_InsertThousandsGrouping(
; 606  :                 writer->buffer, writer->pos,
; 607  :                 spec->n_grouped_digits,
; 608  :                 pdigits + kind * d_pos,
; 609  :                 spec->n_digits, spec->n_min_width,
; 610  :                 locale->grouping, locale->thousands_sep, NULL);

  001c7	49 8b 46 08	 mov	 rax, QWORD PTR [r14+8]
  001cb	4c 8b 45 30	 mov	 r8, QWORD PTR [rbp+48]
  001cf	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  001d3	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  001d6	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12
  001db	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  001e0	49 8b 46 10	 mov	 rax, QWORD PTR [r14+16]

; 611  :         if (r == -1)

  001e4	4c 8b ce	 mov	 r9, rsi
  001e7	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001ec	48 8b 45 50	 mov	 rax, QWORD PTR [rbp+80]
  001f0	4c 0f af 8c 24
	80 00 00 00	 imul	 r9, QWORD PTR d_pos$1$[rsp]
  001f9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001fe	48 8b 45 48	 mov	 rax, QWORD PTR [rbp+72]
  00202	4d 03 cd	 add	 r9, r13
  00205	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0020a	e8 00 00 00 00	 call	 _PyUnicode_InsertThousandsGrouping
  0020f	48 83 f8 ff	 cmp	 rax, -1

; 612  :             return -1;

  00213	0f 84 67 01 00
	00		 je	 $LN69@fill_numbe

; 613  :         assert(r == spec->n_grouped_digits);
; 614  :         if (PyUnicode_KIND(digits) < kind)

  00219	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR digits$[rsp]
  00221	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00224	c1 e8 02	 shr	 eax, 2
  00227	83 e0 07	 and	 eax, 7
  0022a	3b c6		 cmp	 eax, esi
  0022c	73 08		 jae	 SHORT $LN17@fill_numbe

; 615  :             PyMem_Free(pdigits);

  0022e	49 8b cd	 mov	 rcx, r13
  00231	e8 00 00 00 00	 call	 PyMem_Free
$LN17@fill_numbe:

; 616  :         d_pos += spec->n_digits;

  00236	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR d_pos$1$[rsp]
  0023e	4c 8b ac 24 90
	00 00 00	 mov	 r13, QWORD PTR digits$[rsp]
  00246	4c 03 4d 48	 add	 r9, QWORD PTR [rbp+72]
  0024a	4c 89 8c 24 80
	00 00 00	 mov	 QWORD PTR d_pos$1$[rsp], r9

; 637  :         d_pos += 1;

  00252	eb 08		 jmp	 SHORT $LN22@fill_numbe
$LN68@fill_numbe:
  00254	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR d_pos$1$[rsp]
$LN22@fill_numbe:

; 617  :     }
; 618  :     if (toupper) {

  0025c	44 39 a4 24 c0
	00 00 00	 cmp	 DWORD PTR toupper$[rsp], r12d
  00264	74 67		 je	 SHORT $LN13@fill_numbe

; 619  :         Py_ssize_t t;
; 620  :         for (t = 0; t < spec->n_grouped_digits; t++) {

  00266	4c 39 65 30	 cmp	 QWORD PTR [rbp+48], r12
  0026a	7e 61		 jle	 SHORT $LN13@fill_numbe
  0026c	0f 1f 40 00	 npad	 4
$LL15@fill_numbe:

; 621  :             Py_UCS4 c = PyUnicode_READ(kind, data, writer->pos + t);

  00270	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00274	49 03 cc	 add	 rcx, r12
  00277	83 fe 01	 cmp	 esi, 1
  0027a	75 06		 jne	 SHORT $LN61@fill_numbe
  0027c	0f b6 04 39	 movzx	 eax, BYTE PTR [rcx+rdi]
  00280	eb 0e		 jmp	 SHORT $LN60@fill_numbe
$LN61@fill_numbe:
  00282	83 fe 02	 cmp	 esi, 2
  00285	75 06		 jne	 SHORT $LN59@fill_numbe
  00287	0f b7 04 4f	 movzx	 eax, WORD PTR [rdi+rcx*2]
  0028b	eb 03		 jmp	 SHORT $LN60@fill_numbe
$LN59@fill_numbe:
  0028d	8b 04 8f	 mov	 eax, DWORD PTR [rdi+rcx*4]
$LN60@fill_numbe:

; 622  :             c = Py_TOUPPER(c);

  00290	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ctype_toupper
  00297	0f b6 c0	 movzx	 eax, al
  0029a	44 0f b6 04 10	 movzx	 r8d, BYTE PTR [rax+rdx]

; 623  :             if (c > 127) {

  0029f	41 83 f8 7f	 cmp	 r8d, 127		; 0000007fH
  002a3	0f 87 c4 00 00
	00		 ja	 $LN65@fill_numbe

; 626  :             }
; 627  :             PyUnicode_WRITE(kind, data, writer->pos + t, c);

  002a9	8b d6		 mov	 edx, esi
  002ab	ff ca		 dec	 edx
  002ad	74 11		 je	 SHORT $LN6@fill_numbe
  002af	ff ca		 dec	 edx
  002b1	74 06		 je	 SHORT $LN5@fill_numbe
  002b3	44 89 04 8f	 mov	 DWORD PTR [rdi+rcx*4], r8d
  002b7	eb 0b		 jmp	 SHORT $LN10@fill_numbe
$LN5@fill_numbe:
  002b9	66 44 89 04 4f	 mov	 WORD PTR [rdi+rcx*2], r8w
  002be	eb 04		 jmp	 SHORT $LN10@fill_numbe
$LN6@fill_numbe:
  002c0	44 88 04 39	 mov	 BYTE PTR [rcx+rdi], r8b
$LN10@fill_numbe:

; 619  :         Py_ssize_t t;
; 620  :         for (t = 0; t < spec->n_grouped_digits; t++) {

  002c4	49 ff c4	 inc	 r12
  002c7	4c 3b 65 30	 cmp	 r12, QWORD PTR [rbp+48]
  002cb	7c a3		 jl	 SHORT $LL15@fill_numbe
$LN13@fill_numbe:

; 628  :         }
; 629  :     }
; 630  :     writer->pos += spec->n_grouped_digits;

  002cd	48 8b 45 30	 mov	 rax, QWORD PTR [rbp+48]
  002d1	48 01 43 20	 add	 QWORD PTR [rbx+32], rax

; 631  : 
; 632  :     if (spec->n_decimal) {

  002d5	48 8b 45 38	 mov	 rax, QWORD PTR [rbp+56]
  002d9	48 85 c0	 test	 rax, rax
  002dc	74 2a		 je	 SHORT $LN3@fill_numbe

; 633  :         _PyUnicode_FastCopyCharacters(
; 634  :             writer->buffer, writer->pos,
; 635  :             locale->decimal_point, 0, spec->n_decimal);

  002de	4d 8b 06	 mov	 r8, QWORD PTR [r14]
  002e1	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  002e5	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  002e8	45 33 c9	 xor	 r9d, r9d
  002eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f0	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 636  :         writer->pos += spec->n_decimal;

  002f5	4c 8b 5d 38	 mov	 r11, QWORD PTR [rbp+56]

; 637  :         d_pos += 1;

  002f9	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR d_pos$1$[rsp]
  00301	4c 01 5b 20	 add	 QWORD PTR [rbx+32], r11
  00305	49 ff c1	 inc	 r9
$LN3@fill_numbe:

; 638  :     }
; 639  : 
; 640  :     if (spec->n_remainder) {

  00308	48 8b 45 40	 mov	 rax, QWORD PTR [rbp+64]
  0030c	48 85 c0	 test	 rax, rax
  0030f	74 1c		 je	 SHORT $LN2@fill_numbe

; 641  :         _PyUnicode_FastCopyCharacters(
; 642  :             writer->buffer, writer->pos,
; 643  :             digits, d_pos, spec->n_remainder);

  00311	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00315	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00318	4d 8b c5	 mov	 r8, r13
  0031b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00320	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters

; 644  :         writer->pos += spec->n_remainder;

  00325	4c 8b 5d 40	 mov	 r11, QWORD PTR [rbp+64]
  00329	4c 01 5b 20	 add	 QWORD PTR [rbx+32], r11
$LN2@fill_numbe:

; 645  :         /* d_pos += spec->n_remainder; */
; 646  :     }
; 647  : 
; 648  :     if (spec->n_rpadding) {

  0032d	4c 8b 45 18	 mov	 r8, QWORD PTR [rbp+24]
  00331	4d 85 c0	 test	 r8, r8
  00334	74 1c		 je	 SHORT $LN1@fill_numbe

; 649  :         _PyUnicode_FastFill(writer->buffer,
; 650  :                             writer->pos, spec->n_rpadding,
; 651  :                             fill_char);

  00336	44 8b 8c 24 b0
	00 00 00	 mov	 r9d, DWORD PTR fill_char$[rsp]
  0033e	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00342	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00345	e8 00 00 00 00	 call	 _PyUnicode_FastFill

; 652  :         writer->pos += spec->n_rpadding;

  0034a	4c 8b 5d 18	 mov	 r11, QWORD PTR [rbp+24]
  0034e	4c 01 5b 20	 add	 QWORD PTR [rbx+32], r11
$LN1@fill_numbe:

; 653  :     }
; 654  :     return 0;

  00352	33 c0		 xor	 eax, eax
$LN47@fill_numbe:

; 655  : }

  00354	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  00359	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  0035d	49 8b 6b 48	 mov	 rbp, QWORD PTR [r11+72]
  00361	49 8b e3	 mov	 rsp, r11
  00364	41 5e		 pop	 r14
  00366	41 5d		 pop	 r13
  00368	41 5c		 pop	 r12
  0036a	5f		 pop	 rdi
  0036b	5e		 pop	 rsi
  0036c	c3		 ret	 0
$LN65@fill_numbe:

; 624  :                 PyErr_SetString(PyExc_SystemError, "non-ascii grouped digit");

  0036d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00374	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PDACIMOE@non?9ascii?5grouped?5digit?$AA@
  0037b	e8 00 00 00 00	 call	 PyErr_SetString
$LN69@fill_numbe:

; 625  :                 return -1;

  00380	83 c8 ff	 or	 eax, -1
  00383	eb cf		 jmp	 SHORT $LN47@fill_numbe
fill_number ENDP
_TEXT	ENDS
PUBLIC	??_C@_01JFALLOMD@?$AD?$AA@			; `string'
EXTRN	PyUnicode_DecodeLocale:PROC
EXTRN	__imp_localeconv:PROC
EXTRN	PyUnicode_New:PROC
EXTRN	PyUnicode_FromOrdinal:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_locale_info DD imagerel get_locale_info
	DD	imagerel get_locale_info+283
	DD	imagerel $unwind$get_locale_info
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_locale_info DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_01JFALLOMD@?$AD?$AA@
CONST	SEGMENT
??_C@_01JFALLOMD@?$AD?$AA@ DB 03H, 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT get_locale_info
_TEXT	SEGMENT
type$ = 48
locale_info$ = 56
get_locale_info PROC					; COMDAT

; 665  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 666  :     switch (type) {

  0000d	85 c9		 test	 ecx, ecx
  0000f	0f 84 ac 00 00
	00		 je	 $LN26@get_locale
  00015	ff c9		 dec	 ecx
  00017	74 47		 je	 SHORT $LN23@get_locale
  00019	ff c9		 dec	 ecx
  0001b	0f 85 ed 00 00
	00		 jne	 $LN1@get_locale

; 693  :                                          (implicit) trailing 0 means repeat
; 694  :                                          infinitely. */
; 695  :         break;
; 696  :     case LT_NO_LOCALE:
; 697  :         locale_info->decimal_point = PyUnicode_FromOrdinal('.');

  00021	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  00026	e8 00 00 00 00	 call	 PyUnicode_FromOrdinal

; 698  :         locale_info->thousands_sep = PyUnicode_New(0, 0);

  0002b	33 d2		 xor	 edx, edx
  0002d	33 c9		 xor	 ecx, ecx
  0002f	48 89 03	 mov	 QWORD PTR [rbx], rax
  00032	e8 00 00 00 00	 call	 PyUnicode_New

; 699  :         if (!locale_info->decimal_point || !locale_info->thousands_sep) {

  00037	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0003a	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
  0003e	48 85 c9	 test	 rcx, rcx
  00041	74 62		 je	 SHORT $LN19@get_locale
  00043	48 85 c0	 test	 rax, rax
  00046	74 58		 je	 SHORT $LN20@get_locale

; 700  :             Py_XDECREF(locale_info->decimal_point);
; 701  :             Py_XDECREF(locale_info->thousands_sep);
; 702  :             return -1;
; 703  :         }
; 704  :         locale_info->grouping = no_grouping;

  00048	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:no_grouping
  0004f	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 705  :         break;
; 706  :     default:
; 707  :         assert(0);
; 708  :     }
; 709  :     return 0;

  00053	33 c0		 xor	 eax, eax

; 710  : }

  00055	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005e	5f		 pop	 rdi
  0005f	c3		 ret	 0
$LN23@get_locale:

; 682  :         break;
; 683  :     }
; 684  :     case LT_DEFAULT_LOCALE:
; 685  :         locale_info->decimal_point = PyUnicode_FromOrdinal('.');

  00060	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  00065	e8 00 00 00 00	 call	 PyUnicode_FromOrdinal

; 686  :         locale_info->thousands_sep = PyUnicode_FromOrdinal(',');

  0006a	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  0006f	48 89 03	 mov	 QWORD PTR [rbx], rax
  00072	e8 00 00 00 00	 call	 PyUnicode_FromOrdinal

; 687  :         if (!locale_info->decimal_point || !locale_info->thousands_sep) {

  00077	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0007a	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
  0007e	48 85 c9	 test	 rcx, rcx
  00081	74 22		 je	 SHORT $LN19@get_locale
  00083	48 85 c0	 test	 rax, rax
  00086	74 18		 je	 SHORT $LN20@get_locale

; 691  :         }
; 692  :         locale_info->grouping = "\3"; /* Group every 3 characters.  The

  00088	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01JFALLOMD@?$AD?$AA@
  0008f	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 705  :         break;
; 706  :     default:
; 707  :         assert(0);
; 708  :     }
; 709  :     return 0;

  00093	33 c0		 xor	 eax, eax

; 710  : }

  00095	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
$LN20@get_locale:

; 688  :             Py_XDECREF(locale_info->decimal_point);

  000a0	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@get_locale:

; 689  :             Py_XDECREF(locale_info->thousands_sep);

  000a5	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  000a9	48 85 c9	 test	 rcx, rcx
  000ac	74 4a		 je	 SHORT $LN32@get_locale
  000ae	e8 00 00 00 00	 call	 _Py_DecRef

; 690  :             return -1;

  000b3	83 c8 ff	 or	 eax, -1

; 710  : }

  000b6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000bb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bf	5f		 pop	 rdi
  000c0	c3		 ret	 0
$LN26@get_locale:

; 667  :     case LT_CURRENT_LOCALE: {
; 668  :         struct lconv *locale_data = localeconv();

  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_localeconv

; 669  :         locale_info->decimal_point = PyUnicode_DecodeLocale(
; 670  :                                          locale_data->decimal_point,
; 671  :                                          NULL);

  000c7	33 d2		 xor	 edx, edx
  000c9	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000cc	48 8b f8	 mov	 rdi, rax
  000cf	e8 00 00 00 00	 call	 PyUnicode_DecodeLocale
  000d4	48 89 03	 mov	 QWORD PTR [rbx], rax

; 672  :         if (locale_info->decimal_point == NULL)

  000d7	48 85 c0	 test	 rax, rax

; 673  :             return -1;

  000da	74 1c		 je	 SHORT $LN32@get_locale

; 674  :         locale_info->thousands_sep = PyUnicode_DecodeLocale(
; 675  :                                          locale_data->thousands_sep,
; 676  :                                          NULL);

  000dc	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  000e0	33 d2		 xor	 edx, edx
  000e2	e8 00 00 00 00	 call	 PyUnicode_DecodeLocale
  000e7	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 677  :         if (locale_info->thousands_sep == NULL) {

  000eb	48 85 c0	 test	 rax, rax
  000ee	75 16		 jne	 SHORT $LN24@get_locale

; 678  :             Py_DECREF(locale_info->decimal_point);

  000f0	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000f3	e8 00 00 00 00	 call	 _Py_DecRef
$LN32@get_locale:

; 679  :             return -1;

  000f8	83 c8 ff	 or	 eax, -1

; 710  : }

  000fb	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00100	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00104	5f		 pop	 rdi
  00105	c3		 ret	 0
$LN24@get_locale:

; 680  :         }
; 681  :         locale_info->grouping = locale_data->grouping;

  00106	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0010a	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
$LN1@get_locale:

; 705  :         break;
; 706  :     default:
; 707  :         assert(0);
; 708  :     }
; 709  :     return 0;

  0010e	33 c0		 xor	 eax, eax

; 710  : }

  00110	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00115	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00119	5f		 pop	 rdi
  0011a	c3		 ret	 0
get_locale_info ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$free_locale_info DD imagerel free_locale_info
	DD	imagerel free_locale_info+260
	DD	imagerel $unwind$free_locale_info
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$free_locale_info DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\formatter_unicode.c
xdata	ENDS
;	COMDAT free_locale_info
_TEXT	SEGMENT
locale_info$ = 64
free_locale_info PROC					; COMDAT

; 714  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 715  :     Py_XDECREF(locale_info->decimal_point);

  0000a	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	48 85 db	 test	 rbx, rbx
  00013	74 65		 je	 SHORT $LN7@free_local
  00015	e8 00 00 00 00	 call	 _Py_PXCTX
  0001a	85 c0		 test	 eax, eax
  0001c	75 5c		 jne	 SHORT $LN7@free_local
  0001e	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00022	a8 20		 test	 al, 32			; 00000020H
  00024	75 4c		 jne	 SHORT $LN15@free_local
  00026	84 c0		 test	 al, al
  00028	78 48		 js	 SHORT $LN15@free_local
  0002a	a8 02		 test	 al, 2
  0002c	75 4c		 jne	 SHORT $LN7@free_local
  0002e	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00032	75 46		 jne	 SHORT $LN7@free_local
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00042	4c 8b cb	 mov	 r9, rbx
  00045	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0004b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00053	e8 00 00 00 00	 call	 _PyParallel_Guard
  00058	48 8b cb	 mov	 rcx, rbx
  0005b	85 c0		 test	 eax, eax
  0005d	74 07		 je	 SHORT $LN20@free_local
  0005f	e8 00 00 00 00	 call	 _Px_Dealloc
  00064	eb 14		 jmp	 SHORT $LN7@free_local
$LN20@free_local:
  00066	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0006a	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00070	eb 08		 jmp	 SHORT $LN7@free_local
$LN15@free_local:
  00072	48 8b cb	 mov	 rcx, rbx
  00075	e8 00 00 00 00	 call	 Px_DecRef
$LN7@free_local:

; 716  :     Py_XDECREF(locale_info->thousands_sep);

  0007a	48 8b 5f 08	 mov	 rbx, QWORD PTR [rdi+8]
  0007e	48 85 db	 test	 rbx, rbx
  00081	74 76		 je	 SHORT $LN3@free_local
  00083	e8 00 00 00 00	 call	 _Py_PXCTX
  00088	85 c0		 test	 eax, eax
  0008a	75 6d		 jne	 SHORT $LN3@free_local
  0008c	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00090	a8 20		 test	 al, 32			; 00000020H
  00092	75 5d		 jne	 SHORT $LN26@free_local
  00094	84 c0		 test	 al, al
  00096	78 59		 js	 SHORT $LN26@free_local
  00098	a8 02		 test	 al, 2
  0009a	75 5d		 jne	 SHORT $LN3@free_local
  0009c	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000a0	75 57		 jne	 SHORT $LN3@free_local
  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000b0	4c 8b cb	 mov	 r9, rbx
  000b3	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000b9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000c1	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c6	48 8b cb	 mov	 rcx, rbx
  000c9	85 c0		 test	 eax, eax
  000cb	74 0f		 je	 SHORT $LN31@free_local

; 717  : }

  000cd	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d6	5f		 pop	 rdi
  000d7	e9 00 00 00 00	 jmp	 _Px_Dealloc

; 716  :     Py_XDECREF(locale_info->thousands_sep);

$LN31@free_local:
  000dc	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 717  : }

  000e0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e9	5f		 pop	 rdi
  000ea	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]

; 716  :     Py_XDECREF(locale_info->thousands_sep);

$LN26@free_local:
  000f1	48 8b cb	 mov	 rcx, rbx
  000f4	e8 00 00 00 00	 call	 Px_DecRef
$LN3@free_local:

; 717  : }

  000f9	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000fe	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00102	5f		 pop	 rdi
  00103	c3		 ret	 0
free_locale_info ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@ODACPFEC@?8?$DN?8?5alignment?5not?5allowed?5in?5str@ ; `string'
PUBLIC	??_C@_0DK@OJHILDCA@Alternate?5form?5?$CI?$CD?$CJ?5not?5allowed?5i@ ; `string'
PUBLIC	??_C@_0CM@IJMKBHPM@Sign?5not?5allowed?5in?5string?5forma@ ; `string'
EXTRN	_PyUnicodeWriter_PrepareInternal:PROC
EXTRN	_PyUnicode_FindMaxChar:PROC
EXTRN	_PyUnicodeWriter_WriteStr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$format_string_internal DD imagerel format_string_internal
	DD	imagerel format_string_internal+190
	DD	imagerel $unwind$format_string_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$format_string_internal DD imagerel format_string_internal+190
	DD	imagerel format_string_internal+413
	DD	imagerel $chain$0$format_string_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$format_string_internal DD imagerel format_string_internal+413
	DD	imagerel format_string_internal+427
	DD	imagerel $chain$1$format_string_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$format_string_internal DD 021H
	DD	imagerel format_string_internal
	DD	imagerel format_string_internal+190
	DD	imagerel $unwind$format_string_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$format_string_internal DD 020521H
	DD	0ed405H
	DD	imagerel format_string_internal
	DD	imagerel format_string_internal+190
	DD	imagerel $unwind$format_string_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_string_internal DD 060b01H
	DD	0c007520bH
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT ??_C@_0DF@ODACPFEC@?8?$DN?8?5alignment?5not?5allowed?5in?5str@
CONST	SEGMENT
??_C@_0DF@ODACPFEC@?8?$DN?8?5alignment?5not?5allowed?5in?5str@ DB '''='' '
	DB	'alignment not allowed in string format specifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@OJHILDCA@Alternate?5form?5?$CI?$CD?$CJ?5not?5allowed?5i@
CONST	SEGMENT
??_C@_0DK@OJHILDCA@Alternate?5form?5?$CI?$CD?$CJ?5not?5allowed?5i@ DB 'Al'
	DB	'ternate form (#) not allowed in string format specifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@IJMKBHPM@Sign?5not?5allowed?5in?5string?5forma@
CONST	SEGMENT
??_C@_0CM@IJMKBHPM@Sign?5not?5allowed?5in?5string?5forma@ DB 'Sign not al'
	DB	'lowed in string format specifier', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT format_string_internal
_TEXT	SEGMENT
lpad$ = 96
value$ = 96
rpad$ = 104
format$ = 104
writer$ = 112
total$ = 120
format_string_internal PROC				; COMDAT

; 726  : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 727  :     Py_ssize_t lpad;
; 728  :     Py_ssize_t rpad;
; 729  :     Py_ssize_t total;
; 730  :     Py_ssize_t len;
; 731  :     int result = -1;
; 732  :     Py_UCS4 maxchar;
; 733  : 
; 734  :     assert(PyUnicode_IS_READY(value));
; 735  :     len = PyUnicode_GET_LENGTH(value);

  0000b	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]
  0000f	41 83 cc ff	 or	 r12d, -1

; 736  : 
; 737  :     /* sign is not allowed on strings */
; 738  :     if (format->sign != '\0') {

  00013	83 7a 0c 00	 cmp	 DWORD PTR [rdx+12], 0
  00017	49 8b d8	 mov	 rbx, r8
  0001a	48 8b f2	 mov	 rsi, rdx
  0001d	48 8b e9	 mov	 rbp, rcx
  00020	74 21		 je	 SHORT $LN10@format_str

; 739  :         PyErr_SetString(PyExc_ValueError,
; 740  :                         "Sign not allowed in string format specifier");

  00022	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@IJMKBHPM@Sign?5not?5allowed?5in?5string?5forma@
  00030	e8 00 00 00 00	 call	 PyErr_SetString

; 795  : 
; 796  : done:
; 797  :     return result;

  00035	41 8b c4	 mov	 eax, r12d

; 798  : }

  00038	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003c	41 5c		 pop	 r12
  0003e	5f		 pop	 rdi
  0003f	5e		 pop	 rsi
  00040	5d		 pop	 rbp
  00041	5b		 pop	 rbx
  00042	c3		 ret	 0
$LN10@format_str:

; 741  :         goto done;
; 742  :     }
; 743  : 
; 744  :     /* alternate is not allowed on strings */
; 745  :     if (format->alternate) {

  00043	83 7a 08 00	 cmp	 DWORD PTR [rdx+8], 0
  00047	74 21		 je	 SHORT $LN9@format_str

; 746  :         PyErr_SetString(PyExc_ValueError,
; 747  :                         "Alternate form (#) not allowed in string format "
; 748  :                         "specifier");

  00049	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DK@OJHILDCA@Alternate?5form?5?$CI?$CD?$CJ?5not?5allowed?5i@
  00057	e8 00 00 00 00	 call	 PyErr_SetString

; 795  : 
; 796  : done:
; 797  :     return result;

  0005c	41 8b c4	 mov	 eax, r12d

; 798  : }

  0005f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00063	41 5c		 pop	 r12
  00065	5f		 pop	 rdi
  00066	5e		 pop	 rsi
  00067	5d		 pop	 rbp
  00068	5b		 pop	 rbx
  00069	c3		 ret	 0
$LN9@format_str:

; 749  :         goto done;
; 750  :     }
; 751  : 
; 752  :     /* '=' alignment not allowed on strings */
; 753  :     if (format->align == '=') {

  0006a	44 8b 42 04	 mov	 r8d, DWORD PTR [rdx+4]
  0006e	41 83 f8 3d	 cmp	 r8d, 61			; 0000003dH
  00072	75 21		 jne	 SHORT $LN8@format_str

; 754  :         PyErr_SetString(PyExc_ValueError,
; 755  :                         "'=' alignment not allowed "
; 756  :                         "in string format specifier");

  00074	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@ODACPFEC@?8?$DN?8?5alignment?5not?5allowed?5in?5str@
  00082	e8 00 00 00 00	 call	 PyErr_SetString

; 795  : 
; 796  : done:
; 797  :     return result;

  00087	41 8b c4	 mov	 eax, r12d

; 798  : }

  0008a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008e	41 5c		 pop	 r12
  00090	5f		 pop	 rdi
  00091	5e		 pop	 rsi
  00092	5d		 pop	 rbp
  00093	5b		 pop	 rbx
  00094	c3		 ret	 0
$LN8@format_str:

; 757  :         goto done;
; 758  :     }
; 759  : 
; 760  :     if (format->width == -1 && format->precision == -1) {

  00095	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00099	48 83 fa ff	 cmp	 rdx, -1
  0009d	75 1b		 jne	 SHORT $LN7@format_str
  0009f	48 39 56 20	 cmp	 QWORD PTR [rsi+32], rdx
  000a3	75 15		 jne	 SHORT $LN7@format_str

; 761  :         /* Fast path */
; 762  :         return _PyUnicodeWriter_WriteStr(writer, value);

  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b cb	 mov	 rcx, rbx

; 798  : }

  000ab	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000af	41 5c		 pop	 r12
  000b1	5f		 pop	 rdi
  000b2	5e		 pop	 rsi
  000b3	5d		 pop	 rbp
  000b4	5b		 pop	 rbx
  000b5	e9 00 00 00 00	 jmp	 _PyUnicodeWriter_WriteStr
$LN7@format_str:

; 763  :     }
; 764  : 
; 765  :     /* if precision is specified, output no more that format.precision
; 766  :        characters */
; 767  :     if (format->precision >= 0 && len >= format->precision) {

  000ba	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  000be	4c 89 6c 24 70	 mov	 QWORD PTR [rsp+112], r13
  000c3	48 85 c0	 test	 rax, rax
  000c6	78 07		 js	 SHORT $LN6@format_str
  000c8	48 3b f8	 cmp	 rdi, rax
  000cb	48 0f 4d f8	 cmovge	 rdi, rax
$LN6@format_str:

; 768  :         len = format->precision;
; 769  :     }
; 770  : 
; 771  :     calc_padding(len, format->width, format->align, &lpad, &rpad, &total);

  000cf	48 8d 44 24 78	 lea	 rax, QWORD PTR total$[rsp]
  000d4	4c 8d 4c 24 60	 lea	 r9, QWORD PTR lpad$[rsp]
  000d9	48 8b cf	 mov	 rcx, rdi
  000dc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000e1	48 8d 44 24 68	 lea	 rax, QWORD PTR rpad$[rsp]
  000e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000eb	e8 00 00 00 00	 call	 calc_padding

; 772  : 
; 773  :     maxchar = _PyUnicode_FindMaxChar(value, 0, len);

  000f0	4c 8b c7	 mov	 r8, rdi
  000f3	33 d2		 xor	 edx, edx
  000f5	48 8b cd	 mov	 rcx, rbp
  000f8	e8 00 00 00 00	 call	 _PyUnicode_FindMaxChar

; 774  :     if (lpad != 0 || rpad != 0)

  000fd	48 83 7c 24 60
	00		 cmp	 QWORD PTR lpad$[rsp], 0
  00103	4c 8b 6c 24 68	 mov	 r13, QWORD PTR rpad$[rsp]
  00108	44 8b c0	 mov	 r8d, eax
  0010b	75 05		 jne	 SHORT $LN4@format_str
  0010d	4d 85 ed	 test	 r13, r13
  00110	74 08		 je	 SHORT $LN14@format_str
$LN4@format_str:

; 775  :         maxchar = Py_MAX(maxchar, format->fill_char);

  00112	8b 0e		 mov	 ecx, DWORD PTR [rsi]
  00114	3b c1		 cmp	 eax, ecx
  00116	44 0f 46 c1	 cmovbe	 r8d, ecx
$LN14@format_str:

; 776  : 
; 777  :     /* allocate the resulting string */
; 778  :     if (_PyUnicodeWriter_Prepare(writer, total, maxchar) == -1)

  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR total$[rsp]
  0011f	44 3b 43 14	 cmp	 r8d, DWORD PTR [rbx+20]
  00123	77 0d		 ja	 SHORT $LN15@format_str
  00125	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  00129	48 2b 43 20	 sub	 rax, QWORD PTR [rbx+32]
  0012d	48 3b d0	 cmp	 rdx, rax
  00130	7e 12		 jle	 SHORT $LN21@format_str
$LN15@format_str:
  00132	48 85 d2	 test	 rdx, rdx
  00135	74 0d		 je	 SHORT $LN21@format_str
  00137	48 8b cb	 mov	 rcx, rbx
  0013a	e8 00 00 00 00	 call	 _PyUnicodeWriter_PrepareInternal
  0013f	83 f8 ff	 cmp	 eax, -1
  00142	74 54		 je	 SHORT $LN22@format_str
$LN21@format_str:

; 779  :         goto done;
; 780  : 
; 781  :     /* Write into that space. First the padding. */
; 782  :     result = fill_padding(writer, len,
; 783  :                           format->fill_char=='\0'?' ':format->fill_char,
; 784  :                           lpad, rpad);

  00144	44 8b 06	 mov	 r8d, DWORD PTR [rsi]
  00147	4c 8b 4c 24 60	 mov	 r9, QWORD PTR lpad$[rsp]
  0014c	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00151	45 85 c0	 test	 r8d, r8d
  00154	48 8b d7	 mov	 rdx, rdi
  00157	48 8b cb	 mov	 rcx, rbx
  0015a	44 0f 44 c0	 cmove	 r8d, eax
  0015e	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00163	e8 00 00 00 00	 call	 fill_padding
  00168	4c 8b e0	 mov	 r12, rax

; 785  :     if (result == -1)

  0016b	83 f8 ff	 cmp	 eax, -1
  0016e	74 28		 je	 SHORT $LN22@format_str

; 786  :         goto done;
; 787  : 
; 788  :     /* Then the source string. */
; 789  :     if (len) {

  00170	48 85 ff	 test	 rdi, rdi
  00173	74 17		 je	 SHORT $LN1@format_str

; 790  :         _PyUnicode_FastCopyCharacters(writer->buffer, writer->pos,
; 791  :                                       value, 0, len);

  00175	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00179	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0017c	45 33 c9	 xor	 r9d, r9d
  0017f	4c 8b c5	 mov	 r8, rbp
  00182	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00187	e8 00 00 00 00	 call	 _PyUnicode_FastCopyCharacters
$LN1@format_str:

; 792  :     }
; 793  :     writer->pos += (len + rpad);

  0018c	49 8d 44 3d 00	 lea	 rax, QWORD PTR [r13+rdi]
  00191	48 01 43 20	 add	 QWORD PTR [rbx+32], rax

; 794  :     result = 0;

  00195	45 33 e4	 xor	 r12d, r12d
$LN22@format_str:
  00198	4c 8b 6c 24 70	 mov	 r13, QWORD PTR [rsp+112]
$done$21426:

; 795  : 
; 796  : done:
; 797  :     return result;

  0019d	41 8b c4	 mov	 eax, r12d

; 798  : }

  001a0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001a4	41 5c		 pop	 r12
  001a6	5f		 pop	 rdi
  001a7	5e		 pop	 rsi
  001a8	5d		 pop	 rbp
  001a9	5b		 pop	 rbx
  001aa	c3		 ret	 0
format_string_internal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@CEOKNOOI@?$CFc?5arg?5not?5in?5range?$CI0x110000?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0DD@EICNLEJK@Sign?5not?5allowed?5with?5integer?5fo@ ; `string'
PUBLIC	??_C@_0DC@GFGFPDDC@Precision?5not?5allowed?5in?5integer@ ; `string'
EXTRN	_PyLong_Format:PROC
EXTRN	_PyLong_FormatWriter:PROC
EXTRN	PyLong_Type:BYTE
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsLong:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$format_long_internal DD imagerel format_long_internal
	DD	imagerel format_long_internal+994
	DD	imagerel $unwind$format_long_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_long_internal DD 0b1701H
	DD	0223417H
	DD	01a0117H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT ??_C@_0BO@CEOKNOOI@?$CFc?5arg?5not?5in?5range?$CI0x110000?$CJ?$AA@
CONST	SEGMENT
??_C@_0BO@CEOKNOOI@?$CFc?5arg?5not?5in?5range?$CI0x110000?$CJ?$AA@ DB '%c'
	DB	' arg not in range(0x110000)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EICNLEJK@Sign?5not?5allowed?5with?5integer?5fo@
CONST	SEGMENT
??_C@_0DD@EICNLEJK@Sign?5not?5allowed?5with?5integer?5fo@ DB 'Sign not al'
	DB	'lowed with integer format specifier ''c''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@GFGFPDDC@Precision?5not?5allowed?5in?5integer@
CONST	SEGMENT
??_C@_0DC@GFGFPDDC@Precision?5not?5allowed?5in?5integer@ DB 'Precision no'
	DB	't allowed in integer format specifier', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\formatter_unicode.c
CONST	ENDS
;	COMDAT format_long_internal
_TEXT	SEGMENT
n_prefix$1$ = 80
locale$ = 88
spec$ = 112
value$ = 272
maxchar$ = 280
format$ = 280
writer$ = 288
sign_char$1$ = 296
format_long_internal PROC				; COMDAT

; 808  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H

; 809  :     int result = -1;
; 810  :     Py_UCS4 maxchar = 127;
; 811  :     PyObject *tmp = NULL;
; 812  :     Py_ssize_t inumeric_chars;
; 813  :     Py_UCS4 sign_char = '\0';

  00017	33 ed		 xor	 ebp, ebp
  00019	41 83 cc ff	 or	 r12d, -1

; 814  :     Py_ssize_t n_digits;       /* count of digits need from the computed
; 815  :                                   string */
; 816  :     Py_ssize_t n_remainder = 0; /* Used only for 'c' formatting, which
; 817  :                                    produces non-digits */
; 818  :     Py_ssize_t n_prefix = 0;   /* Count of prefix chars, (e.g., '0x') */
; 819  :     Py_ssize_t n_total;
; 820  :     Py_ssize_t prefix = 0;
; 821  :     NumberFieldWidths spec;
; 822  :     long x;
; 823  : 
; 824  :     /* Locale settings, either from the actual locale or
; 825  :        from a hard-code pseudo-locale */
; 826  :     LocaleInfo locale = STATIC_LOCALE_INFO_INIT;
; 827  : 
; 828  :     /* no precision allowed on integers */
; 829  :     if (format->precision != -1) {

  0001d	48 83 7a 20 ff	 cmp	 QWORD PTR [rdx+32], -1
  00022	4d 8b f8	 mov	 r15, r8
  00025	48 8b f2	 mov	 rsi, rdx
  00028	4c 8b d1	 mov	 r10, rcx
  0002b	89 ac 24 28 01
	00 00		 mov	 DWORD PTR sign_char$1$[rsp], ebp
  00032	48 89 6c 24 50	 mov	 QWORD PTR n_prefix$1$[rsp], rbp
  00037	44 8b f5	 mov	 r14d, ebp
  0003a	48 89 6c 24 58	 mov	 QWORD PTR locale$[rsp], rbp
  0003f	48 89 6c 24 60	 mov	 QWORD PTR locale$[rsp+8], rbp
  00044	48 89 6c 24 68	 mov	 QWORD PTR locale$[rsp+16], rbp
  00049	c7 84 24 18 01
	00 00 7f 00 00
	00		 mov	 DWORD PTR maxchar$[rsp], 127 ; 0000007fH
  00054	74 18		 je	 SHORT $LN24@format_lon

; 830  :         PyErr_SetString(PyExc_ValueError,
; 831  :                         "Precision not allowed in integer format specifier");

  00056	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@GFGFPDDC@Precision?5not?5allowed?5in?5integer@
  00064	e8 00 00 00 00	 call	 PyErr_SetString

; 832  :         goto done;

  00069	e9 4c 03 00 00	 jmp	 $LN3@format_lon
$LN24@format_lon:

; 833  :     }
; 834  : 
; 835  :     /* special case for character formatting */
; 836  :     if (format->type == 'c') {

  0006e	8b 42 28	 mov	 eax, DWORD PTR [rdx+40]
  00071	83 f8 63	 cmp	 eax, 99			; 00000063H
  00074	0f 85 83 00 00
	00		 jne	 $LN23@format_lon

; 837  :         /* error to specify a sign */
; 838  :         if (format->sign != '\0') {

  0007a	39 6a 0c	 cmp	 DWORD PTR [rdx+12], ebp
  0007d	74 18		 je	 SHORT $LN22@format_lon

; 839  :             PyErr_SetString(PyExc_ValueError,
; 840  :                             "Sign not allowed with integer"
; 841  :                             " format specifier 'c'");

  0007f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@EICNLEJK@Sign?5not?5allowed?5with?5integer?5fo@
  0008d	e8 00 00 00 00	 call	 PyErr_SetString

; 842  :             goto done;

  00092	e9 23 03 00 00	 jmp	 $LN3@format_lon
$LN22@format_lon:

; 843  :         }
; 844  : 
; 845  :         /* taken from unicodeobject.c formatchar() */
; 846  :         /* Integer input truncated to a character */
; 847  :         x = PyLong_AsLong(value);

  00097	e8 00 00 00 00	 call	 PyLong_AsLong
  0009c	8b f8		 mov	 edi, eax

; 848  :         if (x == -1 && PyErr_Occurred())

  0009e	83 f8 ff	 cmp	 eax, -1
  000a1	75 26		 jne	 SHORT $LN21@format_lon
  000a3	e8 00 00 00 00	 call	 PyErr_Occurred
  000a8	48 85 c0	 test	 rax, rax
  000ab	0f 85 09 03 00
	00		 jne	 $LN3@format_lon
$LN19@format_lon:

; 851  :             PyErr_SetString(PyExc_OverflowError,
; 852  :                             "%c arg not in range(0x110000)");

  000b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@CEOKNOOI@?$CFc?5arg?5not?5in?5range?$CI0x110000?$CJ?$AA@
  000bf	e8 00 00 00 00	 call	 PyErr_SetString

; 853  :             goto done;

  000c4	e9 f1 02 00 00	 jmp	 $LN3@format_lon
$LN21@format_lon:

; 849  :             goto done;
; 850  :         if (x < 0 || x > 0x10ffff) {

  000c9	3d ff ff 10 00	 cmp	 eax, 1114111		; 0010ffffH
  000ce	77 e1		 ja	 SHORT $LN19@format_lon

; 854  :         }
; 855  :         tmp = PyUnicode_FromOrdinal(x);

  000d0	8b c8		 mov	 ecx, eax
  000d2	e8 00 00 00 00	 call	 PyUnicode_FromOrdinal

; 856  :         inumeric_chars = 0;
; 857  :         n_digits = 1;
; 858  :         maxchar = Py_MAX(maxchar, (Py_UCS4)x);

  000d7	83 ff 7f	 cmp	 edi, 127		; 0000007fH
  000da	41 bd 01 00 00
	00		 mov	 r13d, 1
  000e0	48 8b d8	 mov	 rbx, rax
  000e3	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  000e8	4c 8b e5	 mov	 r12, rbp
  000eb	0f 42 f8	 cmovb	 edi, eax
  000ee	89 bc 24 18 01
	00 00		 mov	 DWORD PTR maxchar$[rsp], edi

; 859  : 
; 860  :         /* As a sort-of hack, we tell calc_number_widths that we only
; 861  :            have "remainder" characters. calc_number_widths thinks
; 862  :            these are characters that don't get formatted, only copied
; 863  :            into the output string. We do this for 'c' formatting,
; 864  :            because the characters are likely to be non-digits. */
; 865  :         n_remainder = 1;

  000f5	41 8b fd	 mov	 edi, r13d

; 866  :     }
; 867  :     else {

  000f8	e9 65 01 00 00	 jmp	 $LN18@format_lon
$LN23@format_lon:

; 868  :         int base;
; 869  :         int leading_chars_to_skip = 0;  /* Number of characters added by

  000fd	8b fd		 mov	 edi, ebp

; 870  :                                            PyNumber_ToBase that we want to
; 871  :                                            skip over. */
; 872  : 
; 873  :         /* Compute the base and how many characters will be added by
; 874  :            PyNumber_ToBase */
; 875  :         switch (format->type) {

  000ff	83 f8 58	 cmp	 eax, 88			; 00000058H
  00102	74 26		 je	 SHORT $LN13@format_lon
  00104	83 f8 62	 cmp	 eax, 98			; 00000062H
  00107	74 18		 je	 SHORT $LN15@format_lon
  00109	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  0010c	74 0c		 je	 SHORT $LN14@format_lon
  0010e	83 f8 78	 cmp	 eax, 120		; 00000078H
  00111	74 17		 je	 SHORT $LN13@format_lon

; 888  :             break;
; 889  :         default:  /* shouldn't be needed, but stops a compiler warning */
; 890  :         case 'd':
; 891  :         case 'n':
; 892  :             base = 10;

  00113	ba 0a 00 00 00	 mov	 edx, 10

; 893  :             break;

  00118	eb 1a		 jmp	 SHORT $LN16@format_lon
$LN14@format_lon:

; 880  :         case 'o':
; 881  :             base = 8;

  0011a	ba 08 00 00 00	 mov	 edx, 8

; 882  :             leading_chars_to_skip = 2; /* 0o */
; 883  :             break;

  0011f	eb 0e		 jmp	 SHORT $LN68@format_lon
$LN15@format_lon:

; 876  :         case 'b':
; 877  :             base = 2;

  00121	bf 02 00 00 00	 mov	 edi, 2
  00126	8b d7		 mov	 edx, edi

; 878  :             leading_chars_to_skip = 2; /* 0b */
; 879  :             break;

  00128	eb 0a		 jmp	 SHORT $LN16@format_lon
$LN13@format_lon:

; 884  :         case 'x':
; 885  :         case 'X':
; 886  :             base = 16;

  0012a	ba 10 00 00 00	 mov	 edx, 16
$LN68@format_lon:

; 887  :             leading_chars_to_skip = 2; /* 0x */

  0012f	bf 02 00 00 00	 mov	 edi, 2
$LN16@format_lon:

; 894  :         }
; 895  : 
; 896  :         if (format->sign != '+' && format->sign != ' '
; 897  :             && format->width == -1
; 898  :             && format->type != 'X' && format->type != 'n'
; 899  :             && !format->thousands_separators
; 900  :             && PyLong_CheckExact(value))

  00134	8b 4e 0c	 mov	 ecx, DWORD PTR [rsi+12]
  00137	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  0013a	74 3f		 je	 SHORT $LN11@format_lon
  0013c	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0013f	74 3a		 je	 SHORT $LN11@format_lon
  00141	48 83 7e 10 ff	 cmp	 QWORD PTR [rsi+16], -1
  00146	75 33		 jne	 SHORT $LN11@format_lon
  00148	83 f8 58	 cmp	 eax, 88			; 00000058H
  0014b	74 2e		 je	 SHORT $LN11@format_lon
  0014d	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  00150	74 29		 je	 SHORT $LN11@format_lon
  00152	39 6e 18	 cmp	 DWORD PTR [rsi+24], ebp
  00155	75 24		 jne	 SHORT $LN11@format_lon
  00157	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  0015e	49 39 42 58	 cmp	 QWORD PTR [r10+88], rax
  00162	75 17		 jne	 SHORT $LN11@format_lon

; 901  :         {
; 902  :             /* Fast path */
; 903  :             return _PyLong_FormatWriter(writer, value, base, format->alternate);

  00164	44 8b 4e 08	 mov	 r9d, DWORD PTR [rsi+8]
  00168	44 8b c2	 mov	 r8d, edx
  0016b	49 8b cf	 mov	 rcx, r15
  0016e	49 8b d2	 mov	 rdx, r10
  00171	e8 00 00 00 00	 call	 _PyLong_FormatWriter
  00176	e9 4c 02 00 00	 jmp	 $LN25@format_lon
$LN11@format_lon:

; 904  :         }
; 905  : 
; 906  :         /* The number of prefix chars is the same as the leading
; 907  :            chars to skip */
; 908  :         if (format->alternate)

  0017b	39 6e 08	 cmp	 DWORD PTR [rsi+8], ebp
  0017e	74 08		 je	 SHORT $LN10@format_lon

; 909  :             n_prefix = leading_chars_to_skip;

  00180	48 63 c7	 movsxd	 rax, edi
  00183	48 89 44 24 50	 mov	 QWORD PTR n_prefix$1$[rsp], rax
$LN10@format_lon:

; 910  : 
; 911  :         /* Do the hard part, converting to a string in a given base */
; 912  :         tmp = _PyLong_Format(value, base);

  00188	49 8b ca	 mov	 rcx, r10
  0018b	e8 00 00 00 00	 call	 _PyLong_Format
  00190	48 8b d8	 mov	 rbx, rax

; 913  :         if (tmp == NULL || PyUnicode_READY(tmp) == -1)

  00193	48 85 c0	 test	 rax, rax
  00196	0f 84 1e 02 00
	00		 je	 $LN3@format_lon
  0019c	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  001a0	75 11		 jne	 SHORT $LN64@format_lon
  001a2	48 8b c8	 mov	 rcx, rax
  001a5	e8 00 00 00 00	 call	 _PyUnicode_Ready
  001aa	83 f8 ff	 cmp	 eax, -1
  001ad	0f 84 9b 01 00
	00		 je	 $done$21462
$LN64@format_lon:

; 914  :             goto done;
; 915  : 
; 916  :         inumeric_chars = 0;
; 917  :         n_digits = PyUnicode_GET_LENGTH(tmp);
; 918  : 
; 919  :         prefix = inumeric_chars;
; 920  : 
; 921  :         /* Is a sign character present in the output?  If so, remember it
; 922  :            and skip it */
; 923  :         if (PyUnicode_READ_CHAR(tmp, inumeric_chars) == '-') {

  001b3	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  001b6	4c 8b 6b 60	 mov	 r13, QWORD PTR [rbx+96]
  001ba	8b c8		 mov	 ecx, eax
  001bc	c1 e9 02	 shr	 ecx, 2
  001bf	83 e1 07	 and	 ecx, 7
  001c2	83 f9 01	 cmp	 ecx, 1
  001c5	75 2c		 jne	 SHORT $LN43@format_lon
  001c7	a8 20		 test	 al, 32			; 00000020H
  001c9	74 1c		 je	 SHORT $LN31@format_lon
  001cb	a8 40		 test	 al, 64			; 00000040H
  001cd	74 0c		 je	 SHORT $LN29@format_lon
  001cf	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  001d6	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  001d9	eb 6c		 jmp	 SHORT $LN42@format_lon
$LN29@format_lon:
  001db	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  001e2	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  001e5	eb 60		 jmp	 SHORT $LN42@format_lon
$LN31@format_lon:
  001e7	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  001ee	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  001f1	eb 54		 jmp	 SHORT $LN42@format_lon
$LN43@format_lon:
  001f3	83 f9 02	 cmp	 ecx, 2
  001f6	75 2c		 jne	 SHORT $LN41@format_lon
  001f8	a8 20		 test	 al, 32			; 00000020H
  001fa	74 1c		 je	 SHORT $LN35@format_lon
  001fc	a8 40		 test	 al, 64			; 00000040H
  001fe	74 0c		 je	 SHORT $LN33@format_lon
  00200	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00207	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  0020a	eb 3b		 jmp	 SHORT $LN42@format_lon
$LN33@format_lon:
  0020c	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00213	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00216	eb 2f		 jmp	 SHORT $LN42@format_lon
$LN35@format_lon:
  00218	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  0021f	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00222	eb 23		 jmp	 SHORT $LN42@format_lon
$LN41@format_lon:
  00224	a8 20		 test	 al, 32			; 00000020H
  00226	74 16		 je	 SHORT $LN39@format_lon
  00228	a8 40		 test	 al, 64			; 00000040H
  0022a	74 09		 je	 SHORT $LN37@format_lon
  0022c	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00233	eb 10		 jmp	 SHORT $LN40@format_lon
$LN37@format_lon:
  00235	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  0023c	eb 07		 jmp	 SHORT $LN40@format_lon
$LN39@format_lon:
  0023e	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN40@format_lon:
  00245	8b 08		 mov	 ecx, DWORD PTR [rax]
$LN42@format_lon:
  00247	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  0024a	75 0d		 jne	 SHORT $LN7@format_lon

; 924  :             sign_char = '-';

  0024c	89 8c 24 28 01
	00 00		 mov	 DWORD PTR sign_char$1$[rsp], ecx

; 925  :             ++prefix;

  00253	44 8d 71 d4	 lea	 r14d, QWORD PTR [rcx-44]

; 926  :             ++leading_chars_to_skip;

  00257	ff c7		 inc	 edi
$LN7@format_lon:

; 927  :         }
; 928  : 
; 929  :         /* Skip over the leading chars (0x, 0b, etc.) */
; 930  :         n_digits -= leading_chars_to_skip;

  00259	4c 63 e7	 movsxd	 r12, edi
  0025c	48 8b fd	 mov	 rdi, rbp
  0025f	4d 2b ec	 sub	 r13, r12
$LN18@format_lon:

; 931  :         inumeric_chars += leading_chars_to_skip;
; 932  :     }
; 933  : 
; 934  :     /* Determine the grouping, separator, and decimal point, if any. */
; 935  :     if (get_locale_info(format->type == 'n' ? LT_CURRENT_LOCALE :
; 936  :                         (format->thousands_separators ?
; 937  :                          LT_DEFAULT_LOCALE :
; 938  :                          LT_NO_LOCALE),
; 939  :                         &locale) == -1)

  00262	83 7e 28 6e	 cmp	 DWORD PTR [rsi+40], 110	; 0000006eH
  00266	75 04		 jne	 SHORT $LN45@format_lon
  00268	8b cd		 mov	 ecx, ebp
  0026a	eb 0a		 jmp	 SHORT $LN46@format_lon
$LN45@format_lon:
  0026c	8b 46 18	 mov	 eax, DWORD PTR [rsi+24]
  0026f	f7 d8		 neg	 eax
  00271	1b c9		 sbb	 ecx, ecx
  00273	83 c1 02	 add	 ecx, 2
$LN46@format_lon:
  00276	48 8d 54 24 58	 lea	 rdx, QWORD PTR locale$[rsp]
  0027b	e8 00 00 00 00	 call	 get_locale_info
  00280	83 f8 ff	 cmp	 eax, -1
  00283	0f 84 c1 00 00
	00		 je	 $LN67@format_lon

; 940  :         goto done;
; 941  : 
; 942  :     /* Calculate how much memory we'll need. */
; 943  :     n_total = calc_number_widths(&spec, n_prefix, sign_char, tmp, inumeric_chars,
; 944  :                                  inumeric_chars + n_digits, n_remainder, 0,
; 945  :                                  &locale, format, &maxchar);

  00289	44 8b 84 24 28
	01 00 00	 mov	 r8d, DWORD PTR sign_char$1$[rsp]
  00291	48 8b 54 24 50	 mov	 rdx, QWORD PTR n_prefix$1$[rsp]
  00296	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR maxchar$[rsp]
  0029e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002a3	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  002a8	48 8d 4c 24 58	 lea	 rcx, QWORD PTR locale$[rsp]
  002ad	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002b2	4b 8d 44 25 00	 lea	 rax, QWORD PTR [r13+r12]
  002b7	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  002bb	48 8d 4c 24 70	 lea	 rcx, QWORD PTR spec$[rsp]
  002c0	4d 8b cc	 mov	 r9, r12
  002c3	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  002c8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002cd	e8 00 00 00 00	 call	 calc_number_widths

; 946  : 
; 947  :     /* Allocate the memory. */
; 948  :     if (_PyUnicodeWriter_Prepare(writer, n_total, maxchar) == -1)

  002d2	44 8b 84 24 18
	01 00 00	 mov	 r8d, DWORD PTR maxchar$[rsp]
  002da	48 8b d0	 mov	 rdx, rax
  002dd	45 3b 47 14	 cmp	 r8d, DWORD PTR [r15+20]
  002e1	77 0d		 ja	 SHORT $LN47@format_lon
  002e3	49 8b 47 18	 mov	 rax, QWORD PTR [r15+24]
  002e7	49 2b 47 20	 sub	 rax, QWORD PTR [r15+32]
  002eb	48 3b d0	 cmp	 rdx, rax
  002ee	7e 12		 jle	 SHORT $LN65@format_lon
$LN47@format_lon:
  002f0	48 85 d2	 test	 rdx, rdx
  002f3	74 0d		 je	 SHORT $LN65@format_lon
  002f5	49 8b cf	 mov	 rcx, r15
  002f8	e8 00 00 00 00	 call	 _PyUnicodeWriter_PrepareInternal
  002fd	83 f8 ff	 cmp	 eax, -1
  00300	74 48		 je	 SHORT $LN67@format_lon
$LN65@format_lon:

; 949  :         goto done;
; 950  : 
; 951  :     /* Populate the memory. */
; 952  :     result = fill_number(writer, &spec,
; 953  :                          tmp, inumeric_chars, inumeric_chars + n_digits,
; 954  :                          tmp, prefix,
; 955  :                          format->fill_char == '\0' ? ' ' : format->fill_char,
; 956  :                          &locale, format->type == 'X');

  00302	8b 06		 mov	 eax, DWORD PTR [rsi]
  00304	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00309	48 8d 54 24 70	 lea	 rdx, QWORD PTR spec$[rsp]
  0030e	85 c0		 test	 eax, eax
  00310	4d 8b cc	 mov	 r9, r12
  00313	4c 8b c3	 mov	 r8, rbx
  00316	0f 44 c1	 cmove	 eax, ecx
  00319	83 7e 28 58	 cmp	 DWORD PTR [rsi+40], 88	; 00000058H
  0031d	48 8d 4c 24 58	 lea	 rcx, QWORD PTR locale$[rsp]
  00322	40 0f 94 c5	 sete	 bpl
  00326	89 6c 24 40	 mov	 DWORD PTR [rsp+64], ebp
  0032a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0032f	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00333	49 8b cf	 mov	 rcx, r15
  00336	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  0033b	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00340	e8 00 00 00 00	 call	 fill_number
  00345	44 8b e0	 mov	 r12d, eax
  00348	eb 04		 jmp	 SHORT $done$21462
$LN67@format_lon:
  0034a	41 83 cc ff	 or	 r12d, -1
$done$21462:

; 957  : 
; 958  : done:
; 959  :     Py_XDECREF(tmp);

  0034e	48 85 db	 test	 rbx, rbx
  00351	74 67		 je	 SHORT $LN3@format_lon
  00353	e8 00 00 00 00	 call	 _Py_PXCTX
  00358	85 c0		 test	 eax, eax
  0035a	75 5e		 jne	 SHORT $LN3@format_lon
  0035c	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00360	f6 c1 20	 test	 cl, 32			; 00000020H
  00363	75 4d		 jne	 SHORT $LN57@format_lon
  00365	84 c9		 test	 cl, cl
  00367	78 49		 js	 SHORT $LN57@format_lon
  00369	f6 c1 02	 test	 cl, 2
  0036c	75 4c		 jne	 SHORT $LN3@format_lon
  0036e	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00372	75 46		 jne	 SHORT $LN3@format_lon
  00374	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0037b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00382	4c 8b cb	 mov	 r9, rbx
  00385	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0038b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00393	e8 00 00 00 00	 call	 _PyParallel_Guard
  00398	48 8b cb	 mov	 rcx, rbx
  0039b	85 c0		 test	 eax, eax
  0039d	74 07		 je	 SHORT $LN62@format_lon
  0039f	e8 00 00 00 00	 call	 _Px_Dealloc
  003a4	eb 14		 jmp	 SHORT $LN3@format_lon
$LN62@format_lon:
  003a6	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  003aa	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  003b0	eb 08		 jmp	 SHORT $LN3@format_lon
$LN57@format_lon:
  003b2	48 8b cb	 mov	 rcx, rbx
  003b5	e8 00 00 00 00	 call	 Px_DecRef
$LN3@format_lon:

; 960  :     free_locale_info(&locale);

  003ba	48 8d 4c 24 58	 lea	 rcx, QWORD PTR locale$[rsp]
  003bf	e8 00 00 00 00	 call	 free_locale_info

; 961  :     return result;

  003c4	41 8b c4	 mov	 eax, r12d
$LN25@format_lon:

; 962  : }

  003c7	48 8b 9c 24 10
	01 00 00	 mov	 rbx, QWORD PTR [rsp+272]
  003cf	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  003d6	41 5f		 pop	 r15
  003d8	41 5e		 pop	 r14
  003da	41 5d		 pop	 r13
  003dc	41 5c		 pop	 r12
  003de	5f		 pop	 rdi
  003df	5e		 pop	 rsi
  003e0	5d		 pop	 rbp
  003e1	c3		 ret	 0
format_long_internal ENDP
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	__real@bff0000000000000
PUBLIC	??_C@_0BC@HOPAGEML@precision?5too?5big?$AA@	; `string'
EXTRN	_PyUnicode_FromASCII:PROC
EXTRN	PyOS_double_to_string:PROC
EXTRN	PyFloat_AsDouble:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$format_float_internal DD imagerel format_float_internal
	DD	imagerel format_float_internal+974
	DD	imagerel $unwind$format_float_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_float_internal DD 0d3101H
	DD	0e6831H
	DD	0263419H
	DD	01e0119H
	DD	0e010f012H
	DD	0c00cd00eH
	DD	06009700aH
	DD	05008H
xdata	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT ??_C@_0BC@HOPAGEML@precision?5too?5big?$AA@
CONST	SEGMENT
??_C@_0BC@HOPAGEML@precision?5too?5big?$AA@ DB 'precision too big', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\formatter_unicode.c
CONST	ENDS
;	COMDAT format_float_internal
_TEXT	SEGMENT
locale$ = 80
n_remainder$ = 104
float_type$ = 112
spec$ = 128
value$ = 304
maxchar$ = 312
format$ = 312
writer$ = 320
has_decimal$ = 328
format_float_internal PROC				; COMDAT

; 973  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	55		 push	 rbp
  00008	56		 push	 rsi
  00009	57		 push	 rdi
  0000a	41 54		 push	 r12
  0000c	41 55		 push	 r13
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H

; 974  :     char *buf = NULL;       /* buffer returned from PyOS_double_to_string */
; 975  :     Py_ssize_t n_digits;
; 976  :     Py_ssize_t n_remainder;
; 977  :     Py_ssize_t n_total;
; 978  :     int has_decimal;
; 979  :     double val;
; 980  :     Py_ssize_t precision;
; 981  :     Py_ssize_t default_precision = 6;
; 982  :     Py_UCS4 type = format->type;

  00019	8b 7a 28	 mov	 edi, DWORD PTR [rdx+40]
  0001c	48 8b ea	 mov	 rbp, rdx

; 983  :     int add_pct = 0;

  0001f	33 d2		 xor	 edx, edx

; 984  :     Py_ssize_t index;
; 985  :     NumberFieldWidths spec;
; 986  :     int flags = 0;
; 987  :     int result = -1;

  00021	49 83 cf ff	 or	 r15, -1

; 988  :     Py_UCS4 maxchar = 127;
; 989  :     Py_UCS4 sign_char = '\0';
; 990  :     int float_type; /* Used to see if we have a nan, inf, or regular float. */
; 991  :     PyObject *unicode_tmp = NULL;
; 992  : 
; 993  :     /* Locale settings, either from the actual locale or
; 994  :        from a hard-code pseudo-locale */
; 995  :     LocaleInfo locale = STATIC_LOCALE_INFO_INIT;
; 996  : 
; 997  :     if (format->precision > INT_MAX) {

  00025	48 81 7d 20 ff
	ff ff 7f	 cmp	 QWORD PTR [rbp+32], 2147483647 ; 7fffffffH
  0002d	0f 29 70 b8	 movaps	 XMMWORD PTR [rax-72], xmm6
  00031	4d 8b f0	 mov	 r14, r8
  00034	be 06 00 00 00	 mov	 esi, 6
  00039	44 8b ea	 mov	 r13d, edx
  0003c	c7 40 10 7f 00
	00 00		 mov	 DWORD PTR [rax+16], 127	; 0000007fH
  00043	48 89 54 24 50	 mov	 QWORD PTR locale$[rsp], rdx
  00048	48 89 54 24 58	 mov	 QWORD PTR locale$[rsp+8], rdx
  0004d	48 89 54 24 60	 mov	 QWORD PTR locale$[rsp+16], rdx
  00052	7e 18		 jle	 SHORT $LN20@format_flo

; 998  :         PyErr_SetString(PyExc_ValueError, "precision too big");

  00054	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@HOPAGEML@precision?5too?5big?$AA@
  00062	e8 00 00 00 00	 call	 PyErr_SetString

; 999  :         goto done;

  00067	e9 32 03 00 00	 jmp	 $LN3@format_flo
$LN20@format_flo:

; 1000 :     }
; 1001 :     precision = (int)format->precision;
; 1002 : 
; 1003 :     if (format->alternate)

  0006c	39 55 08	 cmp	 DWORD PTR [rbp+8], edx
  0006f	4c 63 65 20	 movsxd	 r12, DWORD PTR [rbp+32]
  00073	b8 04 00 00 00	 mov	 eax, 4
  00078	8b da		 mov	 ebx, edx
  0007a	0f 45 d8	 cmovne	 ebx, eax

; 1004 :         flags |= Py_DTSF_ALT;
; 1005 : 
; 1006 :     if (type == '\0') {

  0007d	b8 67 00 00 00	 mov	 eax, 103		; 00000067H
  00082	85 ff		 test	 edi, edi
  00084	75 0b		 jne	 SHORT $LN18@format_flo

; 1007 :         /* Omitted type specifier.  Behaves in the same way as repr(x)
; 1008 :            and str(x) if no precision is given, else like 'g', but with
; 1009 :            at least one digit after the decimal point. */
; 1010 :         flags |= Py_DTSF_ADD_DOT_0;

  00086	83 cb 02	 or	 ebx, 2

; 1011 :         type = 'r';

  00089	8d 78 0b	 lea	 edi, QWORD PTR [rax+11]

; 1012 :         default_precision = 0;

  0008c	48 8b f2	 mov	 rsi, rdx

; 1013 :     }
; 1014 : 
; 1015 :     if (type == 'n')

  0008f	eb 06		 jmp	 SHORT $LN17@format_flo
$LN18@format_flo:
  00091	83 ff 6e	 cmp	 edi, 110		; 0000006eH
  00094	0f 44 f8	 cmove	 edi, eax
$LN17@format_flo:

; 1016 :         /* 'n' is the same as 'g', except for the locale used to
; 1017 :            format the result. We take care of that later. */
; 1018 :         type = 'g';
; 1019 : 
; 1020 :     val = PyFloat_AsDouble(value);

  00097	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 1021 :     if (val == -1.0 && PyErr_Occurred())

  0009c	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  000a4	66 0f 28 f0	 movapd	 xmm6, xmm0
  000a8	7a 10		 jp	 SHORT $LN16@format_flo
  000aa	75 0e		 jne	 SHORT $LN16@format_flo
  000ac	e8 00 00 00 00	 call	 PyErr_Occurred
  000b1	48 85 c0	 test	 rax, rax
  000b4	0f 85 e4 02 00
	00		 jne	 $LN3@format_flo
$LN16@format_flo:

; 1022 :         goto done;
; 1023 : 
; 1024 :     if (type == '%') {

  000ba	83 ff 25	 cmp	 edi, 37			; 00000025H
  000bd	75 11		 jne	 SHORT $LN15@format_flo

; 1025 :         type = 'f';
; 1026 :         val *= 100;

  000bf	f2 0f 59 35 00
	00 00 00	 mulsd	 xmm6, QWORD PTR __real@4059000000000000
  000c7	bf 66 00 00 00	 mov	 edi, 102		; 00000066H

; 1027 :         add_pct = 1;

  000cc	44 8d 6f 9b	 lea	 r13d, QWORD PTR [rdi-101]
$LN15@format_flo:

; 1028 :     }
; 1029 : 
; 1030 :     if (precision < 0)

  000d0	4d 85 e4	 test	 r12, r12
  000d3	79 05		 jns	 SHORT $LN14@format_flo

; 1031 :         precision = default_precision;

  000d5	4c 8b e6	 mov	 r12, rsi
  000d8	eb 0b		 jmp	 SHORT $LN12@format_flo
$LN14@format_flo:

; 1032 :     else if (type == 'r')

  000da	83 ff 72	 cmp	 edi, 114		; 00000072H
  000dd	b8 67 00 00 00	 mov	 eax, 103		; 00000067H
  000e2	0f 44 f8	 cmove	 edi, eax
$LN12@format_flo:

; 1033 :         type = 'g';
; 1034 : 
; 1035 :     /* Cast "type", because if we're in unicode we need to pass a
; 1036 :        8-bit char. This is safe, because we've restricted what "type"
; 1037 :        can be. */
; 1038 :     buf = PyOS_double_to_string(val, (char)type, precision, flags,
; 1039 :                                 &float_type);

  000e5	48 8d 44 24 70	 lea	 rax, QWORD PTR float_type$[rsp]
  000ea	66 0f 28 c6	 movapd	 xmm0, xmm6
  000ee	44 8b cb	 mov	 r9d, ebx
  000f1	45 8b c4	 mov	 r8d, r12d
  000f4	40 0f b6 d7	 movzx	 edx, dil
  000f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fd	e8 00 00 00 00	 call	 PyOS_double_to_string
  00102	48 8b f0	 mov	 rsi, rax

; 1040 :     if (buf == NULL)

  00105	48 85 c0	 test	 rax, rax
  00108	0f 84 90 02 00
	00		 je	 $LN3@format_flo

; 1041 :         goto done;
; 1042 :     n_digits = strlen(buf);

  0010e	33 c0		 xor	 eax, eax
  00110	49 8b cf	 mov	 rcx, r15
  00113	48 8b fe	 mov	 rdi, rsi
  00116	f2 ae		 repne scasb
  00118	48 f7 d1	 not	 rcx
  0011b	48 8d 79 ff	 lea	 rdi, QWORD PTR [rcx-1]

; 1043 : 
; 1044 :     if (add_pct) {

  0011f	45 85 ed	 test	 r13d, r13d
  00122	74 08		 je	 SHORT $LN10@format_flo

; 1045 :         /* We know that buf has a trailing zero (since we just called
; 1046 :            strlen() on it), and we don't use that fact any more. So we
; 1047 :            can just write over the trailing zero. */
; 1048 :         buf[n_digits] = '%';

  00124	c6 44 31 ff 25	 mov	 BYTE PTR [rcx+rsi-1], 37 ; 00000025H

; 1049 :         n_digits += 1;

  00129	48 ff c7	 inc	 rdi
$LN10@format_flo:

; 1050 :     }
; 1051 : 
; 1052 :     /* Since there is no unicode version of PyOS_double_to_string,
; 1053 :        just use the 8 bit version and then convert to unicode. */
; 1054 :     unicode_tmp = _PyUnicode_FromASCII(buf, n_digits);

  0012c	48 8b d7	 mov	 rdx, rdi
  0012f	48 8b ce	 mov	 rcx, rsi
  00132	e8 00 00 00 00	 call	 _PyUnicode_FromASCII

; 1055 :     PyMem_Free(buf);

  00137	48 8b ce	 mov	 rcx, rsi
  0013a	48 8b d8	 mov	 rbx, rax
  0013d	e8 00 00 00 00	 call	 PyMem_Free

; 1056 :     if (unicode_tmp == NULL)

  00142	48 85 db	 test	 rbx, rbx
  00145	0f 84 53 02 00
	00		 je	 $LN3@format_flo

; 1057 :         goto done;
; 1058 : 
; 1059 :     if (format->sign != '+' && format->sign != ' '
; 1060 :         && format->width == -1
; 1061 :         && format->type != 'n'
; 1062 :         && !format->thousands_separators)

  0014b	8b 45 0c	 mov	 eax, DWORD PTR [rbp+12]
  0014e	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00151	74 34		 je	 SHORT $LN8@format_flo
  00153	83 f8 20	 cmp	 eax, 32			; 00000020H
  00156	74 2f		 je	 SHORT $LN8@format_flo
  00158	48 83 7d 10 ff	 cmp	 QWORD PTR [rbp+16], -1
  0015d	75 28		 jne	 SHORT $LN8@format_flo
  0015f	83 7d 28 6e	 cmp	 DWORD PTR [rbp+40], 110	; 0000006eH
  00163	74 22		 je	 SHORT $LN8@format_flo
  00165	83 7d 18 00	 cmp	 DWORD PTR [rbp+24], 0
  00169	75 1c		 jne	 SHORT $LN8@format_flo

; 1063 :     {
; 1064 :         /* Fast path */
; 1065 :         result = _PyUnicodeWriter_WriteStr(writer, unicode_tmp);

  0016b	48 8b d3	 mov	 rdx, rbx
  0016e	49 8b ce	 mov	 rcx, r14
  00171	e8 00 00 00 00	 call	 _PyUnicodeWriter_WriteStr

; 1066 :         Py_DECREF(unicode_tmp);

  00176	48 8b cb	 mov	 rcx, rbx
  00179	8b f8		 mov	 edi, eax
  0017b	e8 00 00 00 00	 call	 _Py_DecRef

; 1067 :         return result;

  00180	8b c7		 mov	 eax, edi
  00182	e9 24 02 00 00	 jmp	 $LN21@format_flo
$LN8@format_flo:

; 1068 :     }
; 1069 : 
; 1070 :     /* Is a sign character present in the output?  If so, remember it
; 1071 :        and skip it */
; 1072 :     index = 0;
; 1073 :     if (PyUnicode_READ_CHAR(unicode_tmp, index) == '-') {

  00187	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0018a	45 33 ed	 xor	 r13d, r13d
  0018d	8b c8		 mov	 ecx, eax
  0018f	41 8b f5	 mov	 esi, r13d
  00192	c1 e9 02	 shr	 ecx, 2
  00195	83 e1 07	 and	 ecx, 7
  00198	83 f9 01	 cmp	 ecx, 1
  0019b	75 2c		 jne	 SHORT $LN37@format_flo
  0019d	a8 20		 test	 al, 32			; 00000020H
  0019f	74 1c		 je	 SHORT $LN25@format_flo
  001a1	a8 40		 test	 al, 64			; 00000040H
  001a3	74 0c		 je	 SHORT $LN23@format_flo
  001a5	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  001ac	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  001af	eb 6c		 jmp	 SHORT $LN36@format_flo
$LN23@format_flo:
  001b1	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  001b8	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  001bb	eb 60		 jmp	 SHORT $LN36@format_flo
$LN25@format_flo:
  001bd	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  001c4	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  001c7	eb 54		 jmp	 SHORT $LN36@format_flo
$LN37@format_flo:
  001c9	83 f9 02	 cmp	 ecx, 2
  001cc	75 2c		 jne	 SHORT $LN35@format_flo
  001ce	a8 20		 test	 al, 32			; 00000020H
  001d0	74 1c		 je	 SHORT $LN29@format_flo
  001d2	a8 40		 test	 al, 64			; 00000040H
  001d4	74 0c		 je	 SHORT $LN27@format_flo
  001d6	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  001dd	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  001e0	eb 3b		 jmp	 SHORT $LN36@format_flo
$LN27@format_flo:
  001e2	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  001e9	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  001ec	eb 2f		 jmp	 SHORT $LN36@format_flo
$LN29@format_flo:
  001ee	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  001f5	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  001f8	eb 23		 jmp	 SHORT $LN36@format_flo
$LN35@format_flo:
  001fa	a8 20		 test	 al, 32			; 00000020H
  001fc	74 16		 je	 SHORT $LN33@format_flo
  001fe	a8 40		 test	 al, 64			; 00000040H
  00200	74 09		 je	 SHORT $LN31@format_flo
  00202	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00209	eb 10		 jmp	 SHORT $LN34@format_flo
$LN31@format_flo:
  0020b	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00212	eb 07		 jmp	 SHORT $LN34@format_flo
$LN33@format_flo:
  00214	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN34@format_flo:
  0021b	8b 08		 mov	 ecx, DWORD PTR [rax]
$LN36@format_flo:
  0021d	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  00220	75 0b		 jne	 SHORT $LN59@format_flo

; 1074 :         sign_char = '-';
; 1075 :         ++index;

  00222	8d 71 d4	 lea	 esi, QWORD PTR [rcx-44]
  00225	44 8b e1	 mov	 r12d, ecx

; 1076 :         --n_digits;

  00228	48 ff cf	 dec	 rdi
  0022b	eb 03		 jmp	 SHORT $LN7@format_flo
$LN59@format_flo:

; 1095 : 
; 1096 :     /* Allocate the memory. */
; 1097 :     if (_PyUnicodeWriter_Prepare(writer, n_total, maxchar) == -1)

  0022d	44 8b e6	 mov	 r12d, esi
$LN7@format_flo:

; 1077 :     }
; 1078 : 
; 1079 :     /* Determine if we have any "remainder" (after the digits, might include
; 1080 :        decimal or exponent or both (or neither)) */
; 1081 :     parse_number(unicode_tmp, index, index + n_digits, &n_remainder, &has_decimal);

  00230	48 8d 84 24 48
	01 00 00	 lea	 rax, QWORD PTR has_decimal$[rsp]
  00238	48 03 fe	 add	 rdi, rsi
  0023b	4c 8d 4c 24 68	 lea	 r9, QWORD PTR n_remainder$[rsp]
  00240	48 8b d6	 mov	 rdx, rsi
  00243	48 8b cb	 mov	 rcx, rbx
  00246	4c 8b c7	 mov	 r8, rdi
  00249	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0024e	e8 00 00 00 00	 call	 parse_number

; 1082 : 
; 1083 :     /* Determine the grouping, separator, and decimal point, if any. */
; 1084 :     if (get_locale_info(format->type == 'n' ? LT_CURRENT_LOCALE :
; 1085 :                         (format->thousands_separators ?
; 1086 :                          LT_DEFAULT_LOCALE :
; 1087 :                          LT_NO_LOCALE),
; 1088 :                         &locale) == -1)

  00253	83 7d 28 6e	 cmp	 DWORD PTR [rbp+40], 110	; 0000006eH
  00257	75 05		 jne	 SHORT $LN39@format_flo
  00259	41 8b cd	 mov	 ecx, r13d
  0025c	eb 0a		 jmp	 SHORT $LN40@format_flo
$LN39@format_flo:
  0025e	8b 45 18	 mov	 eax, DWORD PTR [rbp+24]
  00261	f7 d8		 neg	 eax
  00263	1b c9		 sbb	 ecx, ecx
  00265	83 c1 02	 add	 ecx, 2
$LN40@format_flo:
  00268	48 8d 54 24 50	 lea	 rdx, QWORD PTR locale$[rsp]
  0026d	e8 00 00 00 00	 call	 get_locale_info
  00272	83 f8 ff	 cmp	 eax, -1
  00275	0f 84 be 00 00
	00		 je	 $done$21579

; 1089 :         goto done;
; 1090 : 
; 1091 :     /* Calculate how much memory we'll need. */
; 1092 :     n_total = calc_number_widths(&spec, 0, sign_char, unicode_tmp, index,
; 1093 :                                  index + n_digits, n_remainder, has_decimal,
; 1094 :                                  &locale, format, &maxchar);

  0027b	48 8d 84 24 38
	01 00 00	 lea	 rax, QWORD PTR maxchar$[rsp]
  00283	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR spec$[rsp]
  0028b	4c 8b ce	 mov	 r9, rsi
  0028e	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00293	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00298	48 8d 44 24 50	 lea	 rax, QWORD PTR locale$[rsp]
  0029d	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  002a2	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR has_decimal$[rsp]
  002a9	45 8b c4	 mov	 r8d, r12d
  002ac	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  002b0	48 8b 44 24 68	 mov	 rax, QWORD PTR n_remainder$[rsp]
  002b5	33 d2		 xor	 edx, edx
  002b7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002bc	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  002c1	e8 00 00 00 00	 call	 calc_number_widths

; 1095 : 
; 1096 :     /* Allocate the memory. */
; 1097 :     if (_PyUnicodeWriter_Prepare(writer, n_total, maxchar) == -1)

  002c6	44 8b 84 24 38
	01 00 00	 mov	 r8d, DWORD PTR maxchar$[rsp]
  002ce	45 3b 46 14	 cmp	 r8d, DWORD PTR [r14+20]
  002d2	77 0d		 ja	 SHORT $LN41@format_flo
  002d4	49 8b 4e 18	 mov	 rcx, QWORD PTR [r14+24]
  002d8	49 2b 4e 20	 sub	 rcx, QWORD PTR [r14+32]
  002dc	48 3b c1	 cmp	 rax, rcx
  002df	7e 15		 jle	 SHORT $LN58@format_flo
$LN41@format_flo:
  002e1	48 85 c0	 test	 rax, rax
  002e4	74 10		 je	 SHORT $LN58@format_flo
  002e6	48 8b d0	 mov	 rdx, rax
  002e9	49 8b ce	 mov	 rcx, r14
  002ec	e8 00 00 00 00	 call	 _PyUnicodeWriter_PrepareInternal
  002f1	83 f8 ff	 cmp	 eax, -1
  002f4	74 43		 je	 SHORT $done$21579
$LN58@format_flo:

; 1098 :         goto done;
; 1099 : 
; 1100 :     /* Populate the memory. */
; 1101 :     result = fill_number(writer, &spec,
; 1102 :                          unicode_tmp, index, index + n_digits,
; 1103 :                          NULL, 0,
; 1104 :                          format->fill_char == '\0' ? ' ' : format->fill_char,
; 1105 :                          &locale, 0);

  002f6	8b 45 00	 mov	 eax, DWORD PTR [rbp]
  002f9	44 89 6c 24 40	 mov	 DWORD PTR [rsp+64], r13d
  002fe	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00303	85 c0		 test	 eax, eax
  00305	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR spec$[rsp]
  0030d	4c 8b ce	 mov	 r9, rsi
  00310	0f 44 c1	 cmove	 eax, ecx
  00313	48 8d 4c 24 50	 lea	 rcx, QWORD PTR locale$[rsp]
  00318	4c 8b c3	 mov	 r8, rbx
  0031b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00320	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00324	49 8b ce	 mov	 rcx, r14
  00327	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  0032c	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00331	e8 00 00 00 00	 call	 fill_number
  00336	44 8b f8	 mov	 r15d, eax
$done$21579:

; 1106 : 
; 1107 : done:
; 1108 :     Py_XDECREF(unicode_tmp);

  00339	e8 00 00 00 00	 call	 _Py_PXCTX
  0033e	85 c0		 test	 eax, eax
  00340	75 5c		 jne	 SHORT $LN3@format_flo
  00342	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00346	a8 20		 test	 al, 32			; 00000020H
  00348	75 4c		 jne	 SHORT $LN51@format_flo
  0034a	84 c0		 test	 al, al
  0034c	78 48		 js	 SHORT $LN51@format_flo
  0034e	a8 02		 test	 al, 2
  00350	75 4c		 jne	 SHORT $LN3@format_flo
  00352	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00356	75 46		 jne	 SHORT $LN3@format_flo
  00358	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0035f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00366	4c 8b cb	 mov	 r9, rbx
  00369	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0036f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00377	e8 00 00 00 00	 call	 _PyParallel_Guard
  0037c	48 8b cb	 mov	 rcx, rbx
  0037f	85 c0		 test	 eax, eax
  00381	74 07		 je	 SHORT $LN56@format_flo
  00383	e8 00 00 00 00	 call	 _Px_Dealloc
  00388	eb 14		 jmp	 SHORT $LN3@format_flo
$LN56@format_flo:
  0038a	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0038e	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00394	eb 08		 jmp	 SHORT $LN3@format_flo
$LN51@format_flo:
  00396	48 8b cb	 mov	 rcx, rbx
  00399	e8 00 00 00 00	 call	 Px_DecRef
$LN3@format_flo:

; 1109 :     free_locale_info(&locale);

  0039e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR locale$[rsp]
  003a3	e8 00 00 00 00	 call	 free_locale_info

; 1110 :     return result;

  003a8	41 8b c7	 mov	 eax, r15d
$LN21@format_flo:

; 1111 : }

  003ab	48 8b 9c 24 30
	01 00 00	 mov	 rbx, QWORD PTR [rsp+304]
  003b3	0f 28 b4 24 e0
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+224]
  003bb	48 81 c4 f0 00
	00 00		 add	 rsp, 240		; 000000f0H
  003c2	41 5f		 pop	 r15
  003c4	41 5e		 pop	 r14
  003c6	41 5d		 pop	 r13
  003c8	41 5c		 pop	 r12
  003ca	5f		 pop	 rdi
  003cb	5e		 pop	 rsi
  003cc	5d		 pop	 rbp
  003cd	c3		 ret	 0
format_float_internal ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	??_C@_0DO@NPLLENFG@?8?$DN?8?5alignment?5flag?5is?5not?5allowe@ ; `string'
PUBLIC	??_C@_0DI@EFPDCLGP@Zero?5padding?5is?5not?5allowed?5in?5c@ ; `string'
EXTRN	__imp__copysign:PROC
EXTRN	PyComplex_ImagAsDouble:PROC
EXTRN	PyComplex_RealAsDouble:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$format_complex_internal DD imagerel format_complex_internal
	DD	imagerel format_complex_internal+21
	DD	imagerel $unwind$format_complex_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$format_complex_internal DD imagerel format_complex_internal+21
	DD	imagerel format_complex_internal+261
	DD	imagerel $chain$5$format_complex_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$format_complex_internal DD imagerel format_complex_internal+261
	DD	imagerel format_complex_internal+1827
	DD	imagerel $chain$6$format_complex_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$format_complex_internal DD imagerel format_complex_internal+1827
	DD	imagerel format_complex_internal+1891
	DD	imagerel $chain$7$format_complex_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$format_complex_internal DD imagerel format_complex_internal+1891
	DD	imagerel format_complex_internal+2008
	DD	imagerel $chain$8$format_complex_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$format_complex_internal DD imagerel format_complex_internal+2008
	DD	imagerel format_complex_internal+2133
	DD	imagerel $chain$9$format_complex_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$format_complex_internal DD 021H
	DD	imagerel format_complex_internal
	DD	imagerel format_complex_internal+21
	DD	imagerel $unwind$format_complex_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$format_complex_internal DD 020021H
	DD	03cc400H
	DD	imagerel format_complex_internal
	DD	imagerel format_complex_internal+21
	DD	imagerel $unwind$format_complex_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$format_complex_internal DD 021H
	DD	imagerel format_complex_internal+21
	DD	imagerel format_complex_internal+261
	DD	imagerel $chain$5$format_complex_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$format_complex_internal DD 020821H
	DD	01c7808H
	DD	imagerel format_complex_internal+21
	DD	imagerel format_complex_internal+261
	DD	imagerel $chain$5$format_complex_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$format_complex_internal DD 0c1c21H
	DD	01b881cH
	DD	03ae414H
	DD	03bd410H
	DD	03cc40cH
	DD	03d7408H
	DD	0423404H
	DD	imagerel format_complex_internal
	DD	imagerel format_complex_internal+21
	DD	imagerel $unwind$format_complex_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_complex_internal DD 051501H
	DD	03e0115H
	DD	06005f007H
	DD	05004H
xdata	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_0DO@NPLLENFG@?8?$DN?8?5alignment?5flag?5is?5not?5allowe@
CONST	SEGMENT
??_C@_0DO@NPLLENFG@?8?$DN?8?5alignment?5flag?5is?5not?5allowe@ DB '''='' '
	DB	'alignment flag is not allowed in complex format specifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@EFPDCLGP@Zero?5padding?5is?5not?5allowed?5in?5c@
CONST	SEGMENT
??_C@_0DI@EFPDCLGP@Zero?5padding?5is?5not?5allowed?5in?5c@ DB 'Zero paddi'
	DB	'ng is not allowed in complex format specifier', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\formatter_unicode.c
CONST	ENDS
;	COMDAT format_complex_internal
_TEXT	SEGMENT
i_im$1$ = 80
n_re_digits$1$ = 80
default_precision$1$ = 80
add_parens$1$ = 88
re_sign_char$1$ = 92
im_sign_char$1$ = 96
rpad$ = 104
im_has_decimal$ = 104
i_re$1$ = 112
lpad$ = 120
re_has_decimal$ = 120
re_buf$1$ = 128
total$ = 136
n_im_remainder$ = 136
im_buf$1$ = 144
tv762 = 152
n_re_remainder$ = 152
locale$ = 160
tmp_format$ = 184
im_float_type$ = 232
re_float_type$ = 236
re_spec$ = 240
im_spec$ = 336
value$ = 528
maxchar$ = 536
format$ = 536
writer$ = 544
skip_re$1$ = 552
format_complex_internal PROC				; COMDAT

; 1121 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	56		 push	 rsi
  00005	41 57		 push	 r15
  00007	48 8d a8 f8 fe
	ff ff		 lea	 rbp, QWORD PTR [rax-264]
  0000e	48 81 ec f0 01
	00 00		 sub	 rsp, 496		; 000001f0H
  00015	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00019	48 89 78 e0	 mov	 QWORD PTR [rax-32], rdi
  0001d	4c 89 60 d8	 mov	 QWORD PTR [rax-40], r12
  00021	4c 89 68 d0	 mov	 QWORD PTR [rax-48], r13
  00025	4c 89 70 c8	 mov	 QWORD PTR [rax-56], r14
  00029	4c 8b e9	 mov	 r13, rcx
  0002c	44 0f 29 40 a8	 movaps	 XMMWORD PTR [rax-88], xmm8

; 1122 :     double re;
; 1123 :     double im;
; 1124 :     char *re_buf = NULL;       /* buffer returned from PyOS_double_to_string */
; 1125 :     char *im_buf = NULL;       /* buffer returned from PyOS_double_to_string */
; 1126 : 
; 1127 :     InternalFormatSpec tmp_format = *format;

  00031	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00034	33 c9		 xor	 ecx, ecx

; 1128 :     Py_ssize_t n_re_digits;
; 1129 :     Py_ssize_t n_im_digits;
; 1130 :     Py_ssize_t n_re_remainder;
; 1131 :     Py_ssize_t n_im_remainder;
; 1132 :     Py_ssize_t n_re_total;
; 1133 :     Py_ssize_t n_im_total;
; 1134 :     int re_has_decimal;
; 1135 :     int im_has_decimal;
; 1136 :     int precision;
; 1137 :     Py_ssize_t default_precision = 6;
; 1138 :     Py_UCS4 type = format->type;
; 1139 :     Py_ssize_t i_re;
; 1140 :     Py_ssize_t i_im;
; 1141 :     NumberFieldWidths re_spec;
; 1142 :     NumberFieldWidths im_spec;
; 1143 :     int flags = 0;
; 1144 :     int result = -1;

  00036	49 83 cf ff	 or	 r15, -1

; 1145 :     Py_UCS4 maxchar = 127;
; 1146 :     enum PyUnicode_Kind rkind;
; 1147 :     void *rdata;
; 1148 :     Py_UCS4 re_sign_char = '\0';
; 1149 :     Py_UCS4 im_sign_char = '\0';
; 1150 :     int re_float_type; /* Used to see if we have a nan, inf, or regular float. */
; 1151 :     int im_float_type;
; 1152 :     int add_parens = 0;
; 1153 :     int skip_re = 0;
; 1154 :     Py_ssize_t lpad;
; 1155 :     Py_ssize_t rpad;
; 1156 :     Py_ssize_t total;
; 1157 :     PyObject *re_unicode_tmp = NULL;
; 1158 :     PyObject *im_unicode_tmp = NULL;
; 1159 : 
; 1160 :     /* Locale settings, either from the actual locale or
; 1161 :        from a hard-code pseudo-locale */
; 1162 :     LocaleInfo locale = STATIC_LOCALE_INFO_INIT;
; 1163 : 
; 1164 :     if (format->precision > INT_MAX) {

  0003a	48 81 7a 20 ff
	ff ff 7f	 cmp	 QWORD PTR [rdx+32], 2147483647 ; 7fffffffH
  00042	48 89 45 b8	 mov	 QWORD PTR tmp_format$[rbp-256], rax
  00046	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0004a	48 89 45 c0	 mov	 QWORD PTR tmp_format$[rbp-248], rax
  0004e	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  00052	49 8b d8	 mov	 rbx, r8
  00055	48 89 45 c8	 mov	 QWORD PTR tmp_format$[rbp-240], rax
  00059	48 8b 42 18	 mov	 rax, QWORD PTR [rdx+24]
  0005d	4c 8b f2	 mov	 r14, rdx
  00060	48 89 45 d0	 mov	 QWORD PTR tmp_format$[rbp-232], rax
  00064	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  00068	48 89 4d 80	 mov	 QWORD PTR re_buf$1$[rbp-256], rcx
  0006c	48 89 45 d8	 mov	 QWORD PTR tmp_format$[rbp-224], rax
  00070	48 8b 42 28	 mov	 rax, QWORD PTR [rdx+40]
  00074	48 89 4d 90	 mov	 QWORD PTR im_buf$1$[rbp-256], rcx
  00078	48 c7 44 24 50
	06 00 00 00	 mov	 QWORD PTR default_precision$1$[rsp], 6
  00081	c7 85 18 01 00
	00 7f 00 00 00	 mov	 DWORD PTR maxchar$[rbp-256], 127 ; 0000007fH
  0008b	89 4c 24 5c	 mov	 DWORD PTR re_sign_char$1$[rsp], ecx
  0008f	48 89 45 e0	 mov	 QWORD PTR tmp_format$[rbp-216], rax
  00093	8b f8		 mov	 edi, eax
  00095	89 4c 24 60	 mov	 DWORD PTR im_sign_char$1$[rsp], ecx
  00099	89 4c 24 58	 mov	 DWORD PTR add_parens$1$[rsp], ecx
  0009d	89 8d 28 01 00
	00		 mov	 DWORD PTR skip_re$1$[rbp-256], ecx
  000a3	44 8b e1	 mov	 r12d, ecx
  000a6	8b f1		 mov	 esi, ecx
  000a8	48 89 4d a0	 mov	 QWORD PTR locale$[rbp-256], rcx
  000ac	48 89 4d a8	 mov	 QWORD PTR locale$[rbp-248], rcx
  000b0	48 89 4d b0	 mov	 QWORD PTR locale$[rbp-240], rcx
  000b4	7e 18		 jle	 SHORT $LN63@format_com

; 1165 :         PyErr_SetString(PyExc_ValueError, "precision too big");

  000b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@HOPAGEML@precision?5too?5big?$AA@
  000c4	e8 00 00 00 00	 call	 PyErr_SetString

; 1166 :         goto done;

  000c9	e9 55 06 00 00	 jmp	 $done$21701
$LN63@format_com:

; 1167 :     }
; 1168 :     precision = (int)format->precision;
; 1169 : 
; 1170 :     /* Zero padding is not allowed. */
; 1171 :     if (format->fill_char == '0') {

  000ce	83 3a 30	 cmp	 DWORD PTR [rdx], 48	; 00000030H
  000d1	44 8b 7a 20	 mov	 r15d, DWORD PTR [rdx+32]
  000d5	75 1c		 jne	 SHORT $LN62@format_com

; 1172 :         PyErr_SetString(PyExc_ValueError,
; 1173 :                         "Zero padding is not allowed in complex format "
; 1174 :                         "specifier");

  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DI@EFPDCLGP@Zero?5padding?5is?5not?5allowed?5in?5c@
$LN139@format_com:
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000e5	e8 00 00 00 00	 call	 PyErr_SetString

; 1175 :         goto done;

  000ea	49 83 cf ff	 or	 r15, -1
  000ee	e9 30 06 00 00	 jmp	 $done$21701
$LN62@format_com:

; 1176 :     }
; 1177 : 
; 1178 :     /* Neither is '=' alignment . */
; 1179 :     if (format->align == '=') {

  000f3	83 7a 04 3d	 cmp	 DWORD PTR [rdx+4], 61	; 0000003dH
  000f7	75 09		 jne	 SHORT $LN61@format_com

; 1180 :         PyErr_SetString(PyExc_ValueError,
; 1181 :                         "'=' alignment flag is not allowed in complex format "
; 1182 :                         "specifier");

  000f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DO@NPLLENFG@?8?$DN?8?5alignment?5flag?5is?5not?5allowe@

; 1183 :         goto done;

  00100	eb dc		 jmp	 SHORT $LN139@format_com
$LN61@format_com:

; 1184 :     }
; 1185 : 
; 1186 :     re = PyComplex_RealAsDouble(value);

  00102	49 8b cd	 mov	 rcx, r13
  00105	0f 29 bc 24 c0
	01 00 00	 movaps	 XMMWORD PTR [rsp+448], xmm7
  0010d	e8 00 00 00 00	 call	 PyComplex_RealAsDouble

; 1187 :     if (re == -1.0 && PyErr_Occurred())

  00112	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0011a	66 0f 28 f8	 movapd	 xmm7, xmm0
  0011e	7a 10		 jp	 SHORT $LN60@format_com
  00120	75 0e		 jne	 SHORT $LN60@format_com
  00122	e8 00 00 00 00	 call	 PyErr_Occurred
  00127	48 85 c0	 test	 rax, rax
  0012a	0f 85 e7 05 00
	00		 jne	 $LN135@format_com
$LN60@format_com:

; 1188 :         goto done;
; 1189 :     im = PyComplex_ImagAsDouble(value);

  00130	49 8b cd	 mov	 rcx, r13
  00133	e8 00 00 00 00	 call	 PyComplex_ImagAsDouble

; 1190 :     if (im == -1.0 && PyErr_Occurred())

  00138	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00140	66 44 0f 28 c0	 movapd	 xmm8, xmm0
  00145	7a 10		 jp	 SHORT $LN59@format_com
  00147	75 0e		 jne	 SHORT $LN59@format_com
  00149	e8 00 00 00 00	 call	 PyErr_Occurred
  0014e	48 85 c0	 test	 rax, rax
  00151	0f 85 c0 05 00
	00		 jne	 $LN135@format_com
$LN59@format_com:

; 1191 :         goto done;
; 1192 : 
; 1193 :     if (format->alternate)

  00157	33 c9		 xor	 ecx, ecx
  00159	b8 04 00 00 00	 mov	 eax, 4
  0015e	41 39 4e 08	 cmp	 DWORD PTR [r14+8], ecx
  00162	44 8b e9	 mov	 r13d, ecx
  00165	44 0f 45 e8	 cmovne	 r13d, eax

; 1194 :         flags |= Py_DTSF_ALT;
; 1195 : 
; 1196 :     if (type == '\0') {

  00169	8d 41 67	 lea	 eax, QWORD PTR [rcx+103]
  0016c	85 ff		 test	 edi, edi
  0016e	75 48		 jne	 SHORT $LN55@format_com

; 1197 :         /* Omitted type specifier. Should be like str(self). */
; 1198 :         type = 'r';
; 1199 :         default_precision = 0;
; 1200 :         if (re == 0.0 && copysign(1.0, re) == 1.0)

  00170	66 0f 2e 3d 00
	00 00 00	 ucomisd xmm7, QWORD PTR __real@0000000000000000
  00178	8d 79 72	 lea	 edi, QWORD PTR [rcx+114]
  0017b	48 89 4c 24 50	 mov	 QWORD PTR default_precision$1$[rsp], rcx
  00180	7a 2c		 jp	 SHORT $LN56@format_com
  00182	75 2a		 jne	 SHORT $LN56@format_com
  00184	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  0018c	66 0f 28 cf	 movapd	 xmm1, xmm7
  00190	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  00196	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  0019e	7a 0e		 jp	 SHORT $LN56@format_com
  001a0	75 0c		 jne	 SHORT $LN56@format_com

; 1201 :             skip_re = 1;

  001a2	c7 85 28 01 00
	00 01 00 00 00	 mov	 DWORD PTR skip_re$1$[rbp-256], 1

; 1202 :         else

  001ac	eb 10		 jmp	 SHORT $LN54@format_com
$LN56@format_com:

; 1203 :             add_parens = 1;

  001ae	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR add_parens$1$[rsp], 1

; 1204 :     }
; 1205 : 
; 1206 :     if (type == 'n')

  001b6	eb 06		 jmp	 SHORT $LN54@format_com
$LN55@format_com:
  001b8	83 ff 6e	 cmp	 edi, 110		; 0000006eH
  001bb	0f 44 f8	 cmove	 edi, eax
$LN54@format_com:

; 1207 :         /* 'n' is the same as 'g', except for the locale used to
; 1208 :            format the result. We take care of that later. */
; 1209 :         type = 'g';
; 1210 : 
; 1211 :     if (precision < 0)

  001be	45 85 ff	 test	 r15d, r15d
  001c1	79 07		 jns	 SHORT $LN53@format_com

; 1212 :         precision = default_precision;

  001c3	44 8b 7c 24 50	 mov	 r15d, DWORD PTR default_precision$1$[rsp]
  001c8	eb 0b		 jmp	 SHORT $LN51@format_com
$LN53@format_com:

; 1213 :     else if (type == 'r')

  001ca	83 ff 72	 cmp	 edi, 114		; 00000072H
  001cd	b8 67 00 00 00	 mov	 eax, 103		; 00000067H
  001d2	0f 44 f8	 cmove	 edi, eax
$LN51@format_com:

; 1214 :         type = 'g';
; 1215 : 
; 1216 :     /* Cast "type", because if we're in unicode we need to pass a
; 1217 :        8-bit char. This is safe, because we've restricted what "type"
; 1218 :        can be. */
; 1219 :     re_buf = PyOS_double_to_string(re, (char)type, precision, flags,
; 1220 :                                    &re_float_type);

  001d5	48 8d 45 ec	 lea	 rax, QWORD PTR re_float_type$[rbp-256]
  001d9	66 0f 28 c7	 movapd	 xmm0, xmm7
  001dd	45 8b cd	 mov	 r9d, r13d
  001e0	45 8b c7	 mov	 r8d, r15d
  001e3	40 0f b6 d7	 movzx	 edx, dil
  001e7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ec	e8 00 00 00 00	 call	 PyOS_double_to_string
  001f1	48 89 45 80	 mov	 QWORD PTR re_buf$1$[rbp-256], rax

; 1221 :     if (re_buf == NULL)

  001f5	48 85 c0	 test	 rax, rax
  001f8	0f 84 19 05 00
	00		 je	 $LN135@format_com

; 1222 :         goto done;
; 1223 :     im_buf = PyOS_double_to_string(im, (char)type, precision, flags,
; 1224 :                                    &im_float_type);

  001fe	48 8d 45 e8	 lea	 rax, QWORD PTR im_float_type$[rbp-256]
  00202	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  00207	45 8b cd	 mov	 r9d, r13d
  0020a	45 8b c7	 mov	 r8d, r15d
  0020d	40 0f b6 d7	 movzx	 edx, dil
  00211	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00216	e8 00 00 00 00	 call	 PyOS_double_to_string

; 1225 :     if (im_buf == NULL)
; 1226 :         goto done;
; 1227 : 
; 1228 :     n_re_digits = strlen(re_buf);

  0021b	49 83 cf ff	 or	 r15, -1
  0021f	48 8b d0	 mov	 rdx, rax
  00222	48 89 45 90	 mov	 QWORD PTR im_buf$1$[rbp-256], rax
  00226	48 85 c0	 test	 rax, rax
  00229	0f 84 ec 04 00
	00		 je	 $LN137@format_com
  0022f	4c 8b 45 80	 mov	 r8, QWORD PTR re_buf$1$[rbp-256]
  00233	33 c0		 xor	 eax, eax
  00235	49 8b cf	 mov	 rcx, r15
  00238	49 8b f8	 mov	 rdi, r8
  0023b	f2 ae		 repne scasb

; 1229 :     n_im_digits = strlen(im_buf);

  0023d	48 8b fa	 mov	 rdi, rdx
  00240	48 f7 d1	 not	 rcx
  00243	48 ff c9	 dec	 rcx
  00246	48 89 4c 24 50	 mov	 QWORD PTR n_re_digits$1$[rsp], rcx
  0024b	49 8b cf	 mov	 rcx, r15
  0024e	f2 ae		 repne scasb

; 1230 : 
; 1231 :     /* Since there is no unicode version of PyOS_double_to_string,
; 1232 :        just use the 8 bit version and then convert to unicode. */
; 1233 :     re_unicode_tmp = _PyUnicode_FromASCII(re_buf, n_re_digits);

  00250	48 8b 7c 24 50	 mov	 rdi, QWORD PTR n_re_digits$1$[rsp]
  00255	48 f7 d1	 not	 rcx
  00258	48 8b d7	 mov	 rdx, rdi
  0025b	4c 8d 69 ff	 lea	 r13, QWORD PTR [rcx-1]
  0025f	49 8b c8	 mov	 rcx, r8
  00262	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  00267	4c 8b e0	 mov	 r12, rax

; 1234 :     if (re_unicode_tmp == NULL)

  0026a	48 85 c0	 test	 rax, rax
  0026d	0f 84 a8 04 00
	00		 je	 $LN137@format_com

; 1235 :         goto done;
; 1236 :     i_re = 0;

  00273	33 c9		 xor	 ecx, ecx

; 1237 : 
; 1238 :     im_unicode_tmp = _PyUnicode_FromASCII(im_buf, n_im_digits);

  00275	49 8b d5	 mov	 rdx, r13
  00278	48 89 4c 24 70	 mov	 QWORD PTR i_re$1$[rsp], rcx
  0027d	48 8b 4d 90	 mov	 rcx, QWORD PTR im_buf$1$[rbp-256]
  00281	e8 00 00 00 00	 call	 _PyUnicode_FromASCII
  00286	48 8b f0	 mov	 rsi, rax

; 1239 :     if (im_unicode_tmp == NULL)

  00289	48 85 c0	 test	 rax, rax
  0028c	0f 84 89 04 00
	00		 je	 $LN137@format_com

; 1240 :         goto done;
; 1241 :     i_im = 0;

  00292	33 c0		 xor	 eax, eax
  00294	48 89 44 24 50	 mov	 QWORD PTR i_im$1$[rsp], rax

; 1242 : 
; 1243 :     /* Is a sign character present in the output?  If so, remember it
; 1244 :        and skip it */
; 1245 :     if (PyUnicode_READ_CHAR(re_unicode_tmp, i_re) == '-') {

  00299	41 8b 44 24 70	 mov	 eax, DWORD PTR [r12+112]
  0029e	8b c8		 mov	 ecx, eax
  002a0	c1 e9 02	 shr	 ecx, 2
  002a3	83 e1 07	 and	 ecx, 7
  002a6	83 f9 01	 cmp	 ecx, 1
  002a9	75 2f		 jne	 SHORT $LN80@format_com
  002ab	a8 20		 test	 al, 32			; 00000020H
  002ad	74 1e		 je	 SHORT $LN68@format_com
  002af	a8 40		 test	 al, 64			; 00000040H
  002b1	74 0d		 je	 SHORT $LN66@format_com
  002b3	49 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR [r12+128]
  002bb	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  002be	eb 74		 jmp	 SHORT $LN79@format_com
$LN66@format_com:
  002c0	49 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR [r12+160]
  002c8	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  002cb	eb 67		 jmp	 SHORT $LN79@format_com
$LN68@format_com:
  002cd	49 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR [r12+160]
  002d5	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  002d8	eb 5a		 jmp	 SHORT $LN79@format_com
$LN80@format_com:
  002da	83 f9 02	 cmp	 ecx, 2
  002dd	75 2f		 jne	 SHORT $LN78@format_com
  002df	a8 20		 test	 al, 32			; 00000020H
  002e1	74 1e		 je	 SHORT $LN72@format_com
  002e3	a8 40		 test	 al, 64			; 00000040H
  002e5	74 0d		 je	 SHORT $LN70@format_com
  002e7	49 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR [r12+128]
  002ef	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  002f2	eb 40		 jmp	 SHORT $LN79@format_com
$LN70@format_com:
  002f4	49 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR [r12+160]
  002fc	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  002ff	eb 33		 jmp	 SHORT $LN79@format_com
$LN72@format_com:
  00301	49 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR [r12+160]
  00309	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  0030c	eb 26		 jmp	 SHORT $LN79@format_com
$LN78@format_com:
  0030e	a8 20		 test	 al, 32			; 00000020H
  00310	74 18		 je	 SHORT $LN76@format_com
  00312	a8 40		 test	 al, 64			; 00000040H
  00314	74 0a		 je	 SHORT $LN74@format_com
  00316	49 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR [r12+128]
  0031e	eb 12		 jmp	 SHORT $LN77@format_com
$LN74@format_com:
  00320	49 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR [r12+160]
  00328	eb 08		 jmp	 SHORT $LN77@format_com
$LN76@format_com:
  0032a	49 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR [r12+160]
$LN77@format_com:
  00332	8b 08		 mov	 ecx, DWORD PTR [rax]
$LN79@format_com:
  00334	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  00337	75 13		 jne	 SHORT $LN136@format_com

; 1246 :         re_sign_char = '-';
; 1247 :         ++i_re;

  00339	ba 01 00 00 00	 mov	 edx, 1
  0033e	89 4c 24 5c	 mov	 DWORD PTR re_sign_char$1$[rsp], ecx

; 1248 :         --n_re_digits;

  00342	48 ff cf	 dec	 rdi
  00345	48 89 54 24 70	 mov	 QWORD PTR i_re$1$[rsp], rdx
  0034a	eb 05		 jmp	 SHORT $LN46@format_com
$LN136@format_com:

; 1246 :         re_sign_char = '-';
; 1247 :         ++i_re;

  0034c	48 8b 54 24 70	 mov	 rdx, QWORD PTR i_re$1$[rsp]
$LN46@format_com:

; 1249 :     }
; 1250 :     if (PyUnicode_READ_CHAR(im_unicode_tmp, i_im) == '-') {

  00351	8b 46 70	 mov	 eax, DWORD PTR [rsi+112]
  00354	8b c8		 mov	 ecx, eax
  00356	c1 e9 02	 shr	 ecx, 2
  00359	83 e1 07	 and	 ecx, 7
  0035c	83 f9 01	 cmp	 ecx, 1
  0035f	75 2c		 jne	 SHORT $LN96@format_com
  00361	a8 20		 test	 al, 32			; 00000020H
  00363	74 1c		 je	 SHORT $LN84@format_com
  00365	a8 40		 test	 al, 64			; 00000040H
  00367	74 0c		 je	 SHORT $LN82@format_com
  00369	48 8d 86 80 00
	00 00		 lea	 rax, QWORD PTR [rsi+128]
  00370	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00373	eb 6c		 jmp	 SHORT $LN95@format_com
$LN82@format_com:
  00375	48 8d 86 a0 00
	00 00		 lea	 rax, QWORD PTR [rsi+160]
  0037c	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0037f	eb 60		 jmp	 SHORT $LN95@format_com
$LN84@format_com:
  00381	48 8b 86 a0 00
	00 00		 mov	 rax, QWORD PTR [rsi+160]
  00388	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0038b	eb 54		 jmp	 SHORT $LN95@format_com
$LN96@format_com:
  0038d	83 f9 02	 cmp	 ecx, 2
  00390	75 2c		 jne	 SHORT $LN94@format_com
  00392	a8 20		 test	 al, 32			; 00000020H
  00394	74 1c		 je	 SHORT $LN88@format_com
  00396	a8 40		 test	 al, 64			; 00000040H
  00398	74 0c		 je	 SHORT $LN86@format_com
  0039a	48 8d 86 80 00
	00 00		 lea	 rax, QWORD PTR [rsi+128]
  003a1	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  003a4	eb 3b		 jmp	 SHORT $LN95@format_com
$LN86@format_com:
  003a6	48 8d 86 a0 00
	00 00		 lea	 rax, QWORD PTR [rsi+160]
  003ad	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  003b0	eb 2f		 jmp	 SHORT $LN95@format_com
$LN88@format_com:
  003b2	48 8b 86 a0 00
	00 00		 mov	 rax, QWORD PTR [rsi+160]
  003b9	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  003bc	eb 23		 jmp	 SHORT $LN95@format_com
$LN94@format_com:
  003be	a8 20		 test	 al, 32			; 00000020H
  003c0	74 16		 je	 SHORT $LN92@format_com
  003c2	a8 40		 test	 al, 64			; 00000040H
  003c4	74 09		 je	 SHORT $LN90@format_com
  003c6	48 8d 86 80 00
	00 00		 lea	 rax, QWORD PTR [rsi+128]
  003cd	eb 10		 jmp	 SHORT $LN93@format_com
$LN90@format_com:
  003cf	48 8d 86 a0 00
	00 00		 lea	 rax, QWORD PTR [rsi+160]
  003d6	eb 07		 jmp	 SHORT $LN93@format_com
$LN92@format_com:
  003d8	48 8b 86 a0 00
	00 00		 mov	 rax, QWORD PTR [rsi+160]
$LN93@format_com:
  003df	8b 08		 mov	 ecx, DWORD PTR [rax]
$LN95@format_com:
  003e1	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  003e4	75 10		 jne	 SHORT $LN45@format_com

; 1251 :         im_sign_char = '-';

  003e6	89 4c 24 60	 mov	 DWORD PTR im_sign_char$1$[rsp], ecx

; 1252 :         ++i_im;

  003ea	48 c7 44 24 50
	01 00 00 00	 mov	 QWORD PTR i_im$1$[rsp], 1

; 1253 :         --n_im_digits;

  003f3	49 ff cd	 dec	 r13
$LN45@format_com:

; 1254 :     }
; 1255 : 
; 1256 :     /* Determine if we have any "remainder" (after the digits, might include
; 1257 :        decimal or exponent or both (or neither)) */
; 1258 :     parse_number(re_unicode_tmp, i_re, i_re + n_re_digits,
; 1259 :                  &n_re_remainder, &re_has_decimal);

  003f6	48 03 fa	 add	 rdi, rdx
  003f9	48 8d 44 24 78	 lea	 rax, QWORD PTR re_has_decimal$[rsp]
  003fe	4c 8d 4d 98	 lea	 r9, QWORD PTR n_re_remainder$[rbp-256]
  00402	4c 8b c7	 mov	 r8, rdi
  00405	49 8b cc	 mov	 rcx, r12
  00408	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0040d	e8 00 00 00 00	 call	 parse_number

; 1260 :     parse_number(im_unicode_tmp, i_im, i_im + n_im_digits,
; 1261 :                  &n_im_remainder, &im_has_decimal);

  00412	48 8b 44 24 50	 mov	 rax, QWORD PTR i_im$1$[rsp]
  00417	48 8d 4c 24 68	 lea	 rcx, QWORD PTR im_has_decimal$[rsp]
  0041c	4c 03 e8	 add	 r13, rax
  0041f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00424	4c 8d 4d 88	 lea	 r9, QWORD PTR n_im_remainder$[rbp-256]
  00428	48 8b d0	 mov	 rdx, rax
  0042b	48 8b ce	 mov	 rcx, rsi
  0042e	4d 8b c5	 mov	 r8, r13
  00431	e8 00 00 00 00	 call	 parse_number

; 1262 : 
; 1263 :     /* Determine the grouping, separator, and decimal point, if any. */
; 1264 :     if (get_locale_info(format->type == 'n' ? LT_CURRENT_LOCALE :
; 1265 :                         (format->thousands_separators ?
; 1266 :                          LT_DEFAULT_LOCALE :
; 1267 :                          LT_NO_LOCALE),
; 1268 :                         &locale) == -1)

  00436	41 83 7e 28 6e	 cmp	 DWORD PTR [r14+40], 110	; 0000006eH
  0043b	75 06		 jne	 SHORT $LN98@format_com
  0043d	33 c0		 xor	 eax, eax
  0043f	8b c8		 mov	 ecx, eax
  00441	eb 0b		 jmp	 SHORT $LN99@format_com
$LN98@format_com:
  00443	41 8b 46 18	 mov	 eax, DWORD PTR [r14+24]
  00447	f7 d8		 neg	 eax
  00449	1b c9		 sbb	 ecx, ecx
  0044b	83 c1 02	 add	 ecx, 2
$LN99@format_com:
  0044e	48 8d 55 a0	 lea	 rdx, QWORD PTR locale$[rbp-256]
  00452	e8 00 00 00 00	 call	 get_locale_info
  00457	83 f8 ff	 cmp	 eax, -1
  0045a	0f 84 bb 02 00
	00		 je	 $LN137@format_com

; 1269 :         goto done;
; 1270 : 
; 1271 :     /* Turn off any padding. We'll do it later after we've composed
; 1272 :        the numbers without padding. */
; 1273 :     tmp_format.fill_char = '\0';
; 1274 :     tmp_format.align = '<';
; 1275 :     tmp_format.width = -1;
; 1276 : 
; 1277 :     /* Calculate how much memory we'll need. */
; 1278 :     n_re_total = calc_number_widths(&re_spec, 0, re_sign_char, re_unicode_tmp,
; 1279 :                                     i_re, i_re + n_re_digits, n_re_remainder,
; 1280 :                                     re_has_decimal, &locale, &tmp_format,
; 1281 :                                     &maxchar);

  00460	4c 8b 4c 24 70	 mov	 r9, QWORD PTR i_re$1$[rsp]
  00465	44 8b 44 24 5c	 mov	 r8d, DWORD PTR re_sign_char$1$[rsp]
  0046a	33 c0		 xor	 eax, eax
  0046c	89 45 b8	 mov	 DWORD PTR tmp_format$[rbp-256], eax
  0046f	48 8d 85 18 01
	00 00		 lea	 rax, QWORD PTR maxchar$[rbp-256]
  00476	48 8d 4d f0	 lea	 rcx, QWORD PTR re_spec$[rbp-256]
  0047a	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0047f	48 8d 45 b8	 lea	 rax, QWORD PTR tmp_format$[rbp-256]
  00483	33 d2		 xor	 edx, edx
  00485	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0048a	48 8d 45 a0	 lea	 rax, QWORD PTR locale$[rbp-256]
  0048e	c7 45 bc 3c 00
	00 00		 mov	 DWORD PTR tmp_format$[rbp-252], 60 ; 0000003cH
  00495	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0049a	8b 44 24 78	 mov	 eax, DWORD PTR re_has_decimal$[rsp]
  0049e	4c 89 7d c8	 mov	 QWORD PTR tmp_format$[rbp-240], r15
  004a2	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  004a6	48 8b 45 98	 mov	 rax, QWORD PTR n_re_remainder$[rbp-256]
  004aa	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004af	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  004b4	e8 00 00 00 00	 call	 calc_number_widths

; 1282 : 
; 1283 :     /* Same formatting, but always include a sign, unless the real part is
; 1284 :      * going to be omitted, in which case we use whatever sign convention was
; 1285 :      * requested by the original format. */
; 1286 :     if (!skip_re)

  004b9	8b 4d c4	 mov	 ecx, DWORD PTR tmp_format$[rbp-244]
  004bc	83 bd 28 01 00
	00 00		 cmp	 DWORD PTR skip_re$1$[rbp-256], 0

; 1287 :         tmp_format.sign = '+';
; 1288 :     n_im_total = calc_number_widths(&im_spec, 0, im_sign_char, im_unicode_tmp,
; 1289 :                                     i_im, i_im + n_im_digits, n_im_remainder,
; 1290 :                                     im_has_decimal, &locale, &tmp_format,
; 1291 :                                     &maxchar);

  004c3	4c 8b 4c 24 50	 mov	 r9, QWORD PTR i_im$1$[rsp]
  004c8	44 8b 44 24 60	 mov	 r8d, DWORD PTR im_sign_char$1$[rsp]
  004cd	48 8b f8	 mov	 rdi, rax
  004d0	b8 2b 00 00 00	 mov	 eax, 43			; 0000002bH
  004d5	0f 44 c8	 cmove	 ecx, eax
  004d8	48 8d 85 18 01
	00 00		 lea	 rax, QWORD PTR maxchar$[rbp-256]
  004df	33 d2		 xor	 edx, edx
  004e1	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  004e6	89 4d c4	 mov	 DWORD PTR tmp_format$[rbp-244], ecx
  004e9	8b 4c 24 68	 mov	 ecx, DWORD PTR im_has_decimal$[rsp]
  004ed	48 8d 45 b8	 lea	 rax, QWORD PTR tmp_format$[rbp-256]
  004f1	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  004f6	48 8d 45 a0	 lea	 rax, QWORD PTR locale$[rbp-256]
  004fa	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  004ff	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00503	48 8b 4d 88	 mov	 rcx, QWORD PTR n_im_remainder$[rbp-256]
  00507	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0050c	48 8d 4d 50	 lea	 rcx, QWORD PTR im_spec$[rbp-256]
  00510	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00515	e8 00 00 00 00	 call	 calc_number_widths

; 1292 : 
; 1293 :     if (skip_re)

  0051a	83 bd 28 01 00
	00 00		 cmp	 DWORD PTR skip_re$1$[rbp-256], 0

; 1294 :         n_re_total = 0;
; 1295 : 
; 1296 :     /* Add 1 for the 'j', and optionally 2 for parens. */
; 1297 :     calc_padding(n_re_total + n_im_total + 1 + add_parens * 2,
; 1298 :                  format->width, format->align, &lpad, &rpad, &total);

  00521	45 8b 46 04	 mov	 r8d, DWORD PTR [r14+4]
  00525	b9 00 00 00 00	 mov	 ecx, 0
  0052a	4c 8d 4c 24 78	 lea	 r9, QWORD PTR lpad$[rsp]
  0052f	48 0f 45 f9	 cmovne	 rdi, rcx
  00533	8b 4c 24 58	 mov	 ecx, DWORD PTR add_parens$1$[rsp]
  00537	03 c9		 add	 ecx, ecx
  00539	48 63 d1	 movsxd	 rdx, ecx
  0053c	48 8d 4d 88	 lea	 rcx, QWORD PTR total$[rbp-256]
  00540	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00545	48 03 d0	 add	 rdx, rax
  00548	48 8d 4c 24 68	 lea	 rcx, QWORD PTR rpad$[rsp]
  0054d	48 8d 44 3a 01	 lea	 rax, QWORD PTR [rdx+rdi+1]
  00552	49 8b 56 10	 mov	 rdx, QWORD PTR [r14+16]
  00556	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0055b	48 8b c8	 mov	 rcx, rax
  0055e	48 89 45 98	 mov	 QWORD PTR tv762[rbp-256], rax
  00562	e8 00 00 00 00	 call	 calc_padding

; 1299 : 
; 1300 :     if (lpad || rpad)

  00567	48 83 7c 24 78
	00		 cmp	 QWORD PTR lpad$[rsp], 0
  0056d	75 11		 jne	 SHORT $LN40@format_com
  0056f	48 83 7c 24 68
	00		 cmp	 QWORD PTR rpad$[rsp], 0
  00575	75 09		 jne	 SHORT $LN40@format_com

; 1301 :         maxchar = Py_MAX(maxchar, format->fill_char);

  00577	44 8b 85 18 01
	00 00		 mov	 r8d, DWORD PTR maxchar$[rbp-256]
  0057e	eb 11		 jmp	 SHORT $LN101@format_com
$LN40@format_com:
  00580	41 8b 06	 mov	 eax, DWORD PTR [r14]
  00583	44 8b 85 18 01
	00 00		 mov	 r8d, DWORD PTR maxchar$[rbp-256]
  0058a	44 3b c0	 cmp	 r8d, eax
  0058d	44 0f 46 c0	 cmovbe	 r8d, eax
$LN101@format_com:

; 1302 : 
; 1303 :     if (_PyUnicodeWriter_Prepare(writer, total, maxchar) == -1)

  00591	48 8b 55 88	 mov	 rdx, QWORD PTR total$[rbp-256]
  00595	44 3b 43 14	 cmp	 r8d, DWORD PTR [rbx+20]
  00599	77 0d		 ja	 SHORT $LN102@format_com
  0059b	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  0059f	48 2b 43 20	 sub	 rax, QWORD PTR [rbx+32]
  005a3	48 3b d0	 cmp	 rdx, rax
  005a6	7e 16		 jle	 SHORT $LN130@format_com
$LN102@format_com:
  005a8	48 85 d2	 test	 rdx, rdx
  005ab	74 11		 je	 SHORT $LN130@format_com
  005ad	48 8b cb	 mov	 rcx, rbx
  005b0	e8 00 00 00 00	 call	 _PyUnicodeWriter_PrepareInternal
  005b5	83 f8 ff	 cmp	 eax, -1
  005b8	0f 84 5d 01 00
	00		 je	 $LN137@format_com
$LN130@format_com:

; 1304 :         goto done;
; 1305 :     rkind = writer->kind;
; 1306 :     rdata = writer->data;
; 1307 : 
; 1308 :     /* Populate the memory. First, the padding. */
; 1309 :     result = fill_padding(writer,
; 1310 :                           n_re_total + n_im_total + 1 + add_parens * 2,
; 1311 :                           format->fill_char=='\0' ? ' ' : format->fill_char,
; 1312 :                           lpad, rpad);

  005be	45 8b 06	 mov	 r8d, DWORD PTR [r14]
  005c1	4c 8b 74 24 68	 mov	 r14, QWORD PTR rpad$[rsp]
  005c6	4c 8b 4c 24 78	 mov	 r9, QWORD PTR lpad$[rsp]
  005cb	48 8b 55 98	 mov	 rdx, QWORD PTR tv762[rbp-256]
  005cf	8b 7b 10	 mov	 edi, DWORD PTR [rbx+16]
  005d2	4c 8b 6b 08	 mov	 r13, QWORD PTR [rbx+8]
  005d6	45 85 c0	 test	 r8d, r8d
  005d9	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  005de	48 8b cb	 mov	 rcx, rbx
  005e1	44 0f 44 c0	 cmove	 r8d, eax
  005e5	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  005ea	e8 00 00 00 00	 call	 fill_padding
  005ef	44 8b f8	 mov	 r15d, eax

; 1313 :     if (result == -1)

  005f2	83 f8 ff	 cmp	 eax, -1
  005f5	0f 84 20 01 00
	00		 je	 $LN137@format_com

; 1314 :         goto done;
; 1315 : 
; 1316 :     if (add_parens) {

  005fb	83 7c 24 58 00	 cmp	 DWORD PTR add_parens$1$[rsp], 0
  00600	74 2c		 je	 SHORT $LN37@format_com

; 1317 :         PyUnicode_WRITE(rkind, rdata, writer->pos, '(');

  00602	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00606	8b cf		 mov	 ecx, edi
  00608	ff c9		 dec	 ecx
  0060a	74 18		 je	 SHORT $LN31@format_com
  0060c	ff c9		 dec	 ecx
  0060e	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00613	74 07		 je	 SHORT $LN30@format_com
  00615	41 89 4c 85 00	 mov	 DWORD PTR [r13+rax*4], ecx
  0061a	eb 0e		 jmp	 SHORT $LN35@format_com
$LN30@format_com:
  0061c	66 41 89 4c 45
	00		 mov	 WORD PTR [r13+rax*2], cx
  00622	eb 06		 jmp	 SHORT $LN35@format_com
$LN31@format_com:
  00624	41 c6 44 05 00
	28		 mov	 BYTE PTR [r13+rax], 40	; 00000028H
$LN35@format_com:

; 1318 :         writer->pos++;

  0062a	48 ff 43 20	 inc	 QWORD PTR [rbx+32]
$LN37@format_com:

; 1319 :     }
; 1320 : 
; 1321 :     if (!skip_re) {

  0062e	83 bd 28 01 00
	00 00		 cmp	 DWORD PTR skip_re$1$[rbp-256], 0
  00635	75 3d		 jne	 SHORT $LN27@format_com

; 1322 :         result = fill_number(writer, &re_spec,
; 1323 :                              re_unicode_tmp, i_re, i_re + n_re_digits,
; 1324 :                              NULL, 0,
; 1325 :                              0,
; 1326 :                              &locale, 0);

  00637	4c 8b 4c 24 70	 mov	 r9, QWORD PTR i_re$1$[rsp]
  0063c	33 c9		 xor	 ecx, ecx
  0063e	48 8d 45 a0	 lea	 rax, QWORD PTR locale$[rbp-256]
  00642	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00646	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0064b	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0064f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00654	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00659	48 8d 55 f0	 lea	 rdx, QWORD PTR re_spec$[rbp-256]
  0065d	48 8b cb	 mov	 rcx, rbx
  00660	4d 8b c4	 mov	 r8, r12
  00663	e8 00 00 00 00	 call	 fill_number
  00668	44 8b f8	 mov	 r15d, eax

; 1327 :         if (result == -1)

  0066b	83 f8 ff	 cmp	 eax, -1
  0066e	0f 84 a7 00 00
	00		 je	 $LN137@format_com
$LN27@format_com:

; 1328 :             goto done;
; 1329 :     }
; 1330 :     result = fill_number(writer, &im_spec,
; 1331 :                          im_unicode_tmp, i_im, i_im + n_im_digits,
; 1332 :                          NULL, 0,
; 1333 :                          0,
; 1334 :                          &locale, 0);

  00674	4c 8b 4c 24 50	 mov	 r9, QWORD PTR i_im$1$[rsp]
  00679	33 c9		 xor	 ecx, ecx
  0067b	48 8d 45 a0	 lea	 rax, QWORD PTR locale$[rbp-256]
  0067f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00683	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00688	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0068c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00691	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00696	48 8d 55 50	 lea	 rdx, QWORD PTR im_spec$[rbp-256]
  0069a	48 8b cb	 mov	 rcx, rbx
  0069d	4c 8b c6	 mov	 r8, rsi
  006a0	e8 00 00 00 00	 call	 fill_number
  006a5	44 8b f8	 mov	 r15d, eax

; 1335 :     if (result == -1)

  006a8	83 f8 ff	 cmp	 eax, -1
  006ab	74 6e		 je	 SHORT $LN137@format_com

; 1336 :         goto done;
; 1337 :     PyUnicode_WRITE(rkind, rdata, writer->pos, 'j');

  006ad	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  006b1	8b cf		 mov	 ecx, edi
  006b3	ff c9		 dec	 ecx
  006b5	74 18		 je	 SHORT $LN20@format_com
  006b7	ff c9		 dec	 ecx
  006b9	b9 6a 00 00 00	 mov	 ecx, 106		; 0000006aH
  006be	74 07		 je	 SHORT $LN19@format_com
  006c0	41 89 4c 85 00	 mov	 DWORD PTR [r13+rax*4], ecx
  006c5	eb 0e		 jmp	 SHORT $LN24@format_com
$LN19@format_com:
  006c7	66 41 89 4c 45
	00		 mov	 WORD PTR [r13+rax*2], cx
  006cd	eb 06		 jmp	 SHORT $LN24@format_com
$LN20@format_com:
  006cf	41 c6 44 05 00
	6a		 mov	 BYTE PTR [r13+rax], 106	; 0000006aH
$LN24@format_com:

; 1338 :     writer->pos++;

  006d5	48 ff 43 20	 inc	 QWORD PTR [rbx+32]

; 1339 : 
; 1340 :     if (add_parens) {

  006d9	83 7c 24 58 00	 cmp	 DWORD PTR add_parens$1$[rsp], 0
  006de	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  006e2	74 29		 je	 SHORT $LN17@format_com

; 1341 :         PyUnicode_WRITE(rkind, rdata, writer->pos, ')');

  006e4	ff cf		 dec	 edi
  006e6	74 18		 je	 SHORT $LN11@format_com
  006e8	ff cf		 dec	 edi
  006ea	b8 29 00 00 00	 mov	 eax, 41			; 00000029H
  006ef	74 07		 je	 SHORT $LN10@format_com
  006f1	41 89 44 8d 00	 mov	 DWORD PTR [r13+rcx*4], eax
  006f6	eb 0d		 jmp	 SHORT $LN15@format_com
$LN10@format_com:
  006f8	66 41 89 44 4d
	00		 mov	 WORD PTR [r13+rcx*2], ax
  006fe	eb 05		 jmp	 SHORT $LN15@format_com
$LN11@format_com:
  00700	42 c6 04 29 29	 mov	 BYTE PTR [rcx+r13], 41	; 00000029H
$LN15@format_com:

; 1342 :         writer->pos++;

  00705	48 ff 43 20	 inc	 QWORD PTR [rbx+32]
  00709	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
$LN17@format_com:

; 1343 :     }
; 1344 : 
; 1345 :     writer->pos += rpad;

  0070d	4a 8d 04 31	 lea	 rax, QWORD PTR [rcx+r14]
  00711	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  00715	eb 04		 jmp	 SHORT $LN137@format_com
$LN135@format_com:
  00717	49 83 cf ff	 or	 r15, -1
$LN137@format_com:
  0071b	0f 28 bc 24 c0
	01 00 00	 movaps	 xmm7, XMMWORD PTR [rsp+448]
$done$21701:

; 1346 : 
; 1347 : done:
; 1348 :     PyMem_Free(re_buf);

  00723	48 8b 4d 80	 mov	 rcx, QWORD PTR re_buf$1$[rbp-256]
  00727	e8 00 00 00 00	 call	 PyMem_Free

; 1349 :     PyMem_Free(im_buf);

  0072c	48 8b 4d 90	 mov	 rcx, QWORD PTR im_buf$1$[rbp-256]
  00730	e8 00 00 00 00	 call	 PyMem_Free
  00735	4c 8b b4 24 d0
	01 00 00	 mov	 r14, QWORD PTR [rsp+464]
  0073d	4c 8b ac 24 d8
	01 00 00	 mov	 r13, QWORD PTR [rsp+472]
  00745	44 0f 28 84 24
	b0 01 00 00	 movaps	 xmm8, XMMWORD PTR [rsp+432]
  0074e	48 8b bc 24 e8
	01 00 00	 mov	 rdi, QWORD PTR [rsp+488]
  00756	48 8b 9c 24 10
	02 00 00	 mov	 rbx, QWORD PTR [rsp+528]

; 1350 :     Py_XDECREF(re_unicode_tmp);

  0075e	4d 85 e4	 test	 r12, r12
  00761	74 68		 je	 SHORT $LN7@format_com
  00763	e8 00 00 00 00	 call	 _Py_PXCTX
  00768	85 c0		 test	 eax, eax
  0076a	75 5f		 jne	 SHORT $LN7@format_com
  0076c	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  00771	a8 20		 test	 al, 32			; 00000020H
  00773	75 4e		 jne	 SHORT $LN112@format_com
  00775	84 c0		 test	 al, al
  00777	78 4a		 js	 SHORT $LN112@format_com
  00779	a8 02		 test	 al, 2
  0077b	75 4e		 jne	 SHORT $LN7@format_com
  0077d	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  00782	75 47		 jne	 SHORT $LN7@format_com
  00784	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0078b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00792	4d 8b cc	 mov	 r9, r12
  00795	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0079b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  007a3	e8 00 00 00 00	 call	 _PyParallel_Guard
  007a8	49 8b cc	 mov	 rcx, r12
  007ab	85 c0		 test	 eax, eax
  007ad	74 07		 je	 SHORT $LN117@format_com
  007af	e8 00 00 00 00	 call	 _Px_Dealloc
  007b4	eb 15		 jmp	 SHORT $LN7@format_com
$LN117@format_com:
  007b6	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  007bb	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  007c1	eb 08		 jmp	 SHORT $LN7@format_com
$LN112@format_com:
  007c3	49 8b cc	 mov	 rcx, r12
  007c6	e8 00 00 00 00	 call	 Px_DecRef
$LN7@format_com:

; 1351 :     Py_XDECREF(im_unicode_tmp);

  007cb	4c 8b a4 24 e0
	01 00 00	 mov	 r12, QWORD PTR [rsp+480]
  007d3	48 85 f6	 test	 rsi, rsi
  007d6	74 65		 je	 SHORT $LN3@format_com
  007d8	e8 00 00 00 00	 call	 _Py_PXCTX
  007dd	85 c0		 test	 eax, eax
  007df	75 5c		 jne	 SHORT $LN3@format_com
  007e1	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  007e5	a8 20		 test	 al, 32			; 00000020H
  007e7	75 4c		 jne	 SHORT $LN123@format_com
  007e9	84 c0		 test	 al, al
  007eb	78 48		 js	 SHORT $LN123@format_com
  007ed	a8 02		 test	 al, 2
  007ef	75 4c		 jne	 SHORT $LN3@format_com
  007f1	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  007f5	75 46		 jne	 SHORT $LN3@format_com
  007f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  007fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00805	4c 8b ce	 mov	 r9, rsi
  00808	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0080e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00816	e8 00 00 00 00	 call	 _PyParallel_Guard
  0081b	48 8b ce	 mov	 rcx, rsi
  0081e	85 c0		 test	 eax, eax
  00820	74 07		 je	 SHORT $LN128@format_com
  00822	e8 00 00 00 00	 call	 _Px_Dealloc
  00827	eb 14		 jmp	 SHORT $LN3@format_com
$LN128@format_com:
  00829	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  0082d	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00833	eb 08		 jmp	 SHORT $LN3@format_com
$LN123@format_com:
  00835	48 8b ce	 mov	 rcx, rsi
  00838	e8 00 00 00 00	 call	 Px_DecRef
$LN3@format_com:

; 1352 :     free_locale_info(&locale);

  0083d	48 8d 4d a0	 lea	 rcx, QWORD PTR locale$[rbp-256]
  00841	e8 00 00 00 00	 call	 free_locale_info

; 1353 :     return result;

  00846	41 8b c7	 mov	 eax, r15d

; 1354 : }

  00849	48 81 c4 f0 01
	00 00		 add	 rsp, 496		; 000001f0H
  00850	41 5f		 pop	 r15
  00852	5e		 pop	 rsi
  00853	5d		 pop	 rbp
  00854	c3		 ret	 0
format_complex_internal ENDP
_TEXT	ENDS
EXTRN	PyObject_Str:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$format_obj DD imagerel format_obj
	DD	imagerel format_obj+74
	DD	imagerel $unwind$format_obj
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_obj DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT format_obj
_TEXT	SEGMENT
obj$ = 48
writer$ = 56
format_obj PROC						; COMDAT

; 1361 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 1362 :     PyObject *str;
; 1363 :     int err;
; 1364 : 
; 1365 :     str = PyObject_Str(obj);

  0000d	e8 00 00 00 00	 call	 PyObject_Str
  00012	48 8b f8	 mov	 rdi, rax

; 1366 :     if (str == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0e		 jne	 SHORT $LN1@format_obj

; 1367 :         return -1;

  0001a	83 c8 ff	 or	 eax, -1

; 1371 : }

  0001d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN1@format_obj:

; 1368 :     err = _PyUnicodeWriter_WriteStr(writer, str);

  00028	48 8b d0	 mov	 rdx, rax
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	e8 00 00 00 00	 call	 _PyUnicodeWriter_WriteStr

; 1369 :     Py_DECREF(str);

  00033	48 8b cf	 mov	 rcx, rdi
  00036	8b d8		 mov	 ebx, eax
  00038	e8 00 00 00 00	 call	 _Py_DecRef

; 1370 :     return err;

  0003d	8b c3		 mov	 eax, ebx

; 1371 : }

  0003f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5f		 pop	 rdi
  00049	c3		 ret	 0
format_obj ENDP
_TEXT	ENDS
PUBLIC	_PyUnicode_FormatAdvancedWriter
EXTRN	PyUnicode_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyUnicode_FormatAdvancedWriter DD imagerel $LN12
	DD	imagerel $LN12+177
	DD	imagerel $unwind$_PyUnicode_FormatAdvancedWriter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyUnicode_FormatAdvancedWriter DD 040a01H
	DD	0e340aH
	DD	07006b20aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyUnicode_FormatAdvancedWriter
_TEXT	SEGMENT
format$ = 48
writer$ = 112
obj$ = 120
format_spec$ = 128
start$ = 136
end$ = 144
_PyUnicode_FormatAdvancedWriter PROC			; COMDAT

; 1378 : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	4d 8b d0	 mov	 r10, r8

; 1379 :     InternalFormatSpec format;
; 1380 : 
; 1381 :     assert(PyUnicode_Check(obj));
; 1382 : 
; 1383 :     /* check for the special case of zero length format spec, make
; 1384 :        it equivalent to str(obj) */
; 1385 :     if (start == end) {

  0000d	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR end$[rsp]
  00015	49 8b c1	 mov	 rax, r9
  00018	48 8b da	 mov	 rbx, rdx
  0001b	48 8b f9	 mov	 rdi, rcx
  0001e	4d 3b c8	 cmp	 r9, r8
  00021	75 31		 jne	 SHORT $LN6@PyUnicode_

; 1386 :         if (PyUnicode_CheckExact(obj))

  00023	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  0002a	48 39 42 58	 cmp	 QWORD PTR [rdx+88], rax
  0002e	75 0f		 jne	 SHORT $LN7@PyUnicode_

; 1406 :     }
; 1407 : }

  00030	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00035	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00039	5f		 pop	 rdi
  0003a	e9 00 00 00 00	 jmp	 _PyUnicodeWriter_WriteStr
$LN7@PyUnicode_:

; 1387 :             return _PyUnicodeWriter_WriteStr(writer, obj);
; 1388 :         else
; 1389 :             return format_obj(obj, writer);

  0003f	48 8b d1	 mov	 rdx, rcx
  00042	48 8b cb	 mov	 rcx, rbx

; 1406 :     }
; 1407 : }

  00045	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0004a	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0004e	5f		 pop	 rdi
  0004f	e9 00 00 00 00	 jmp	 format_obj
$LN6@PyUnicode_:

; 1390 :     }
; 1391 : 
; 1392 :     /* parse the format_spec */
; 1393 :     if (!parse_internal_render_format_spec(format_spec, start, end,
; 1394 :                                            &format, 's', '<'))

  00054	4c 8d 4c 24 30	 lea	 r9, QWORD PTR format$[rsp]
  00059	48 8b d0	 mov	 rdx, rax
  0005c	49 8b ca	 mov	 rcx, r10
  0005f	c6 44 24 28 3c	 mov	 BYTE PTR [rsp+40], 60	; 0000003cH
  00064	c6 44 24 20 73	 mov	 BYTE PTR [rsp+32], 115	; 00000073H
  00069	e8 00 00 00 00	 call	 parse_internal_render_format_spec
  0006e	85 c0		 test	 eax, eax

; 1395 :         return -1;

  00070	74 16		 je	 SHORT $LN11@PyUnicode_

; 1396 : 
; 1397 :     /* type conversion? */
; 1398 :     switch (format.type) {

  00072	8b 4c 24 58	 mov	 ecx, DWORD PTR format$[rsp+40]
  00076	83 f9 73	 cmp	 ecx, 115		; 00000073H
  00079	74 1b		 je	 SHORT $LN2@PyUnicode_

; 1402 :     default:
; 1403 :         /* unknown */
; 1404 :         unknown_presentation_type(format.type, obj->ob_type->tp_name);

  0007b	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  0007f	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00083	e8 00 00 00 00	 call	 unknown_presentation_type
$LN11@PyUnicode_:

; 1405 :         return -1;

  00088	83 c8 ff	 or	 eax, -1

; 1406 :     }
; 1407 : }

  0008b	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00090	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00094	5f		 pop	 rdi
  00095	c3		 ret	 0
$LN2@PyUnicode_:

; 1399 :     case 's':
; 1400 :         /* no type conversion needed, already a string.  do the formatting */
; 1401 :         return format_string_internal(obj, &format, writer);

  00096	48 8d 54 24 30	 lea	 rdx, QWORD PTR format$[rsp]
  0009b	4c 8b c7	 mov	 r8, rdi
  0009e	48 8b cb	 mov	 rcx, rbx
  000a1	e8 00 00 00 00	 call	 format_string_internal

; 1406 :     }
; 1407 : }

  000a6	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  000ab	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000af	5f		 pop	 rdi
  000b0	c3		 ret	 0
_PyUnicode_FormatAdvancedWriter ENDP
_TEXT	ENDS
PUBLIC	_PyLong_FormatAdvancedWriter
EXTRN	PyNumber_Float:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_PyLong_FormatAdvancedWriter DD imagerel $LN45
	DD	imagerel $LN45+556
	DD	imagerel $unwind$_PyLong_FormatAdvancedWriter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_FormatAdvancedWriter DD 060f01H
	DD	0f640fH
	DD	0e340fH
	DD	0700bb20fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\formatter_unicode.c
xdata	ENDS
;	COMDAT _PyLong_FormatAdvancedWriter
_TEXT	SEGMENT
format$ = 48
writer$ = 112
obj$ = 120
format_spec$ = 128
start$ = 136
end$ = 144
_PyLong_FormatAdvancedWriter PROC			; COMDAT

; 1414 : {

$LN45:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	4d 8b d0	 mov	 r10, r8

; 1415 :     PyObject *tmp = NULL, *str = NULL;
; 1416 :     InternalFormatSpec format;
; 1417 :     int result = -1;
; 1418 : 
; 1419 :     /* check for the special case of zero length format spec, make
; 1420 :        it equivalent to str(obj) */
; 1421 :     if (start == end) {

  00012	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR end$[rsp]
  0001a	83 ce ff	 or	 esi, -1
  0001d	49 8b c1	 mov	 rax, r9
  00020	48 8b da	 mov	 rbx, rdx
  00023	48 8b f9	 mov	 rdi, rcx
  00026	4d 3b c8	 cmp	 r9, r8
  00029	75 42		 jne	 SHORT $LN16@PyLong_For

; 1422 :         if (PyLong_CheckExact(obj))

  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  00032	48 39 42 58	 cmp	 QWORD PTR [rdx+88], rax
  00036	75 1b		 jne	 SHORT $LN17@PyLong_For

; 1423 :             return _PyLong_FormatWriter(writer, obj, 10, 0);

  00038	44 8d 46 0b	 lea	 r8d, QWORD PTR [rsi+11]
  0003c	45 33 c9	 xor	 r9d, r9d

; 1470 : }

  0003f	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00044	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00049	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0004d	5f		 pop	 rdi
  0004e	e9 00 00 00 00	 jmp	 _PyLong_FormatWriter
$LN17@PyLong_For:

; 1424 :         else
; 1425 :             return format_obj(obj, writer);

  00053	48 8b d1	 mov	 rdx, rcx
  00056	48 8b cb	 mov	 rcx, rbx

; 1470 : }

  00059	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0005e	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00063	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00067	5f		 pop	 rdi
  00068	e9 00 00 00 00	 jmp	 format_obj
$LN16@PyLong_For:

; 1426 :     }
; 1427 : 
; 1428 :     /* parse the format_spec */
; 1429 :     if (!parse_internal_render_format_spec(format_spec, start, end,
; 1430 :                                            &format, 'd', '>'))

  0006d	4c 8d 4c 24 30	 lea	 r9, QWORD PTR format$[rsp]
  00072	48 8b d0	 mov	 rdx, rax
  00075	49 8b ca	 mov	 rcx, r10
  00078	c6 44 24 28 3e	 mov	 BYTE PTR [rsp+40], 62	; 0000003eH
  0007d	c6 44 24 20 64	 mov	 BYTE PTR [rsp+32], 100	; 00000064H
  00082	e8 00 00 00 00	 call	 parse_internal_render_format_spec
  00087	85 c0		 test	 eax, eax
  00089	0f 84 28 01 00
	00		 je	 $LN3@PyLong_For

; 1431 :         goto done;
; 1432 : 
; 1433 :     /* type conversion? */
; 1434 :     switch (format.type) {

  0008f	44 8b 44 24 58	 mov	 r8d, DWORD PTR format$[rsp+40]
  00094	41 8d 40 db	 lea	 eax, DWORD PTR [r8-37]
  00098	83 f8 53	 cmp	 eax, 83			; 00000053H
  0009b	0f 87 06 01 00
	00		 ja	 $LN9@PyLong_For
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  000a8	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN43@PyLong_For[rdx+rax]
  000b0	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN44@PyLong_For[rdx+rax*4]
  000b7	48 03 ca	 add	 rcx, rdx
  000ba	ff e1		 jmp	 rcx
$LN12@PyLong_For:

; 1435 :     case 'b':
; 1436 :     case 'c':
; 1437 :     case 'd':
; 1438 :     case 'o':
; 1439 :     case 'x':
; 1440 :     case 'X':
; 1441 :     case 'n':
; 1442 :         /* no type conversion needed, already an int.  do the formatting */
; 1443 :         result = format_long_internal(obj, &format, writer);

  000bc	48 8d 54 24 30	 lea	 rdx, QWORD PTR format$[rsp]
  000c1	4c 8b c7	 mov	 r8, rdi
  000c4	48 8b cb	 mov	 rcx, rbx
  000c7	e8 00 00 00 00	 call	 format_long_internal
  000cc	8b f0		 mov	 esi, eax

; 1470 : }

  000ce	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  000d3	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  000d8	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000dc	5f		 pop	 rdi
  000dd	c3		 ret	 0
$LN11@PyLong_For:

; 1444 :         break;
; 1445 : 
; 1446 :     case 'e':
; 1447 :     case 'E':
; 1448 :     case 'f':
; 1449 :     case 'F':
; 1450 :     case 'g':
; 1451 :     case 'G':
; 1452 :     case '%':
; 1453 :         /* convert to float */
; 1454 :         tmp = PyNumber_Float(obj);

  000de	48 8b cb	 mov	 rcx, rbx
  000e1	e8 00 00 00 00	 call	 PyNumber_Float
  000e6	48 8b d8	 mov	 rbx, rax

; 1455 :         if (tmp == NULL)

  000e9	48 85 c0	 test	 rax, rax
  000ec	0f 84 c5 00 00
	00		 je	 $LN3@PyLong_For

; 1456 :             goto done;
; 1457 :         result = format_float_internal(tmp, &format, writer);

  000f2	48 8d 54 24 30	 lea	 rdx, QWORD PTR format$[rsp]
  000f7	4c 8b c7	 mov	 r8, rdi
  000fa	48 8b c8	 mov	 rcx, rax
  000fd	e8 00 00 00 00	 call	 format_float_internal
$done$21951:
  00102	8b f0		 mov	 esi, eax

; 1463 :         goto done;
; 1464 :     }
; 1465 : 
; 1466 : done:
; 1467 :     Py_XDECREF(tmp);

  00104	e8 00 00 00 00	 call	 _Py_PXCTX
  00109	85 c0		 test	 eax, eax
  0010b	0f 85 a6 00 00
	00		 jne	 $LN3@PyLong_For
  00111	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00115	a8 20		 test	 al, 32			; 00000020H
  00117	75 74		 jne	 SHORT $LN25@PyLong_For
  00119	84 c0		 test	 al, al
  0011b	78 70		 js	 SHORT $LN25@PyLong_For
  0011d	a8 02		 test	 al, 2
  0011f	0f 85 92 00 00
	00		 jne	 $LN3@PyLong_For
  00125	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00129	0f 85 88 00 00
	00		 jne	 $LN3@PyLong_For
  0012f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0013d	4c 8b cb	 mov	 r9, rbx
  00140	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00146	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0014e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00153	48 8b cb	 mov	 rcx, rbx
  00156	85 c0		 test	 eax, eax
  00158	74 17		 je	 SHORT $LN30@PyLong_For
  0015a	e8 00 00 00 00	 call	 _Px_Dealloc

; 1468 :     Py_XDECREF(str);
; 1469 :     return result;

  0015f	8b c6		 mov	 eax, esi

; 1470 : }

  00161	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00166	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  0016b	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0016f	5f		 pop	 rdi
  00170	c3		 ret	 0

; 1463 :         goto done;
; 1464 :     }
; 1465 : 
; 1466 : done:
; 1467 :     Py_XDECREF(tmp);

$LN30@PyLong_For:
  00171	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00175	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 1468 :     Py_XDECREF(str);
; 1469 :     return result;

  0017b	8b c6		 mov	 eax, esi

; 1470 : }

  0017d	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00182	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00187	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0018b	5f		 pop	 rdi
  0018c	c3		 ret	 0

; 1463 :         goto done;
; 1464 :     }
; 1465 : 
; 1466 : done:
; 1467 :     Py_XDECREF(tmp);

$LN25@PyLong_For:
  0018d	48 8b cb	 mov	 rcx, rbx
  00190	e8 00 00 00 00	 call	 Px_DecRef

; 1468 :     Py_XDECREF(str);
; 1469 :     return result;

  00195	8b c6		 mov	 eax, esi

; 1470 : }

  00197	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0019c	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  001a1	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001a5	5f		 pop	 rdi
  001a6	c3		 ret	 0
$LN9@PyLong_For:

; 1458 :         break;
; 1459 : 
; 1460 :     default:
; 1461 :         /* unknown */
; 1462 :         unknown_presentation_type(format.type, obj->ob_type->tp_name);

  001a7	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  001ab	41 8b c8	 mov	 ecx, r8d
  001ae	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  001b2	e8 00 00 00 00	 call	 unknown_presentation_type
$LN3@PyLong_For:

; 1470 : }

  001b7	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  001bc	8b c6		 mov	 eax, esi
  001be	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  001c3	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001c7	5f		 pop	 rdi
  001c8	c3		 ret	 0
  001c9	0f 1f 00	 npad	 3
$LN44@PyLong_For:
  001cc	00 00 00 00	 DD	 $LN11@PyLong_For
  001d0	00 00 00 00	 DD	 $LN12@PyLong_For
  001d4	00 00 00 00	 DD	 $LN9@PyLong_For
$LN43@PyLong_For:
  001d8	00		 DB	 0
  001d9	02		 DB	 2
  001da	02		 DB	 2
  001db	02		 DB	 2
  001dc	02		 DB	 2
  001dd	02		 DB	 2
  001de	02		 DB	 2
  001df	02		 DB	 2
  001e0	02		 DB	 2
  001e1	02		 DB	 2
  001e2	02		 DB	 2
  001e3	02		 DB	 2
  001e4	02		 DB	 2
  001e5	02		 DB	 2
  001e6	02		 DB	 2
  001e7	02		 DB	 2
  001e8	02		 DB	 2
  001e9	02		 DB	 2
  001ea	02		 DB	 2
  001eb	02		 DB	 2
  001ec	02		 DB	 2
  001ed	02		 DB	 2
  001ee	02		 DB	 2
  001ef	02		 DB	 2
  001f0	02		 DB	 2
  001f1	02		 DB	 2
  001f2	02		 DB	 2
  001f3	02		 DB	 2
  001f4	02		 DB	 2
  001f5	02		 DB	 2
  001f6	02		 DB	 2
  001f7	02		 DB	 2
  001f8	00		 DB	 0
  001f9	00		 DB	 0
  001fa	00		 DB	 0
  001fb	02		 DB	 2
  001fc	02		 DB	 2
  001fd	02		 DB	 2
  001fe	02		 DB	 2
  001ff	02		 DB	 2
  00200	02		 DB	 2
  00201	02		 DB	 2
  00202	02		 DB	 2
  00203	02		 DB	 2
  00204	02		 DB	 2
  00205	02		 DB	 2
  00206	02		 DB	 2
  00207	02		 DB	 2
  00208	02		 DB	 2
  00209	02		 DB	 2
  0020a	02		 DB	 2
  0020b	01		 DB	 1
  0020c	02		 DB	 2
  0020d	02		 DB	 2
  0020e	02		 DB	 2
  0020f	02		 DB	 2
  00210	02		 DB	 2
  00211	02		 DB	 2
  00212	02		 DB	 2
  00213	02		 DB	 2
  00214	02		 DB	 2
  00215	01		 DB	 1
  00216	01		 DB	 1
  00217	01		 DB	 1
  00218	00		 DB	 0
  00219	00		 DB	 0
  0021a	00		 DB	 0
  0021b	02		 DB	 2
  0021c	02		 DB	 2
  0021d	02		 DB	 2
  0021e	02		 DB	 2
  0021f	02		 DB	 2
  00220	02		 DB	 2
  00221	01		 DB	 1
  00222	01		 DB	 1
  00223	02		 DB	 2
  00224	02		 DB	 2
  00225	02		 DB	 2
  00226	02		 DB	 2
  00227	02		 DB	 2
  00228	02		 DB	 2
  00229	02		 DB	 2
  0022a	02		 DB	 2
  0022b	01		 DB	 1
_PyLong_FormatAdvancedWriter ENDP
_TEXT	ENDS
PUBLIC	_PyFloat_FormatAdvancedWriter
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyFloat_FormatAdvancedWriter DD imagerel $LN12
	DD	imagerel $LN12+303
	DD	imagerel $unwind$_PyFloat_FormatAdvancedWriter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyFloat_FormatAdvancedWriter DD 040a01H
	DD	0e340aH
	DD	07006b20aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyFloat_FormatAdvancedWriter
_TEXT	SEGMENT
format$ = 48
writer$ = 112
obj$ = 120
format_spec$ = 128
start$ = 136
end$ = 144
_PyFloat_FormatAdvancedWriter PROC			; COMDAT

; 1477 : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	4d 8b d0	 mov	 r10, r8

; 1478 :     InternalFormatSpec format;
; 1479 : 
; 1480 :     /* check for the special case of zero length format spec, make
; 1481 :        it equivalent to str(obj) */
; 1482 :     if (start == end)

  0000d	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR end$[rsp]
  00015	49 8b c1	 mov	 rax, r9
  00018	48 8b da	 mov	 rbx, rdx
  0001b	48 8b f9	 mov	 rdi, rcx
  0001e	4d 3b c8	 cmp	 r9, r8
  00021	75 15		 jne	 SHORT $LN6@PyFloat_Fo

; 1483 :         return format_obj(obj, writer);

  00023	48 8b d1	 mov	 rdx, rcx
  00026	48 8b cb	 mov	 rcx, rbx

; 1508 :     }
; 1509 : }

  00029	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0002e	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00032	5f		 pop	 rdi
  00033	e9 00 00 00 00	 jmp	 format_obj
$LN6@PyFloat_Fo:

; 1484 : 
; 1485 :     /* parse the format_spec */
; 1486 :     if (!parse_internal_render_format_spec(format_spec, start, end,
; 1487 :                                            &format, '\0', '>'))

  00038	4c 8d 4c 24 30	 lea	 r9, QWORD PTR format$[rsp]
  0003d	48 8b d0	 mov	 rdx, rax
  00040	49 8b ca	 mov	 rcx, r10
  00043	c6 44 24 28 3e	 mov	 BYTE PTR [rsp+40], 62	; 0000003eH
  00048	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0004d	e8 00 00 00 00	 call	 parse_internal_render_format_spec
  00052	85 c0		 test	 eax, eax

; 1488 :         return -1;

  00054	74 52		 je	 SHORT $LN11@PyFloat_Fo

; 1489 : 
; 1490 :     /* type conversion? */
; 1491 :     switch (format.type) {

  00056	44 8b 44 24 58	 mov	 r8d, DWORD PTR format$[rsp+40]
  0005b	41 83 f8 6e	 cmp	 r8d, 110		; 0000006eH
  0005f	77 37		 ja	 SHORT $LN1@PyFloat_Fo
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00068	42 0f b6 84 02
	00 00 00 00	 movzx	 eax, BYTE PTR $LN9@PyFloat_Fo[rdx+r8]
  00071	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN10@PyFloat_Fo[rdx+rax*4]
  00078	48 03 ca	 add	 rcx, rdx
  0007b	ff e1		 jmp	 rcx
$LN2@PyFloat_Fo:

; 1492 :     case '\0': /* No format code: like 'g', but with at least one decimal. */
; 1493 :     case 'e':
; 1494 :     case 'E':
; 1495 :     case 'f':
; 1496 :     case 'F':
; 1497 :     case 'g':
; 1498 :     case 'G':
; 1499 :     case 'n':
; 1500 :     case '%':
; 1501 :         /* no conversion, already a float.  do the formatting */
; 1502 :         return format_float_internal(obj, &format, writer);

  0007d	48 8d 54 24 30	 lea	 rdx, QWORD PTR format$[rsp]
  00082	4c 8b c7	 mov	 r8, rdi
  00085	48 8b cb	 mov	 rcx, rbx
  00088	e8 00 00 00 00	 call	 format_float_internal

; 1508 :     }
; 1509 : }

  0008d	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00092	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
$LN1@PyFloat_Fo:

; 1503 : 
; 1504 :     default:
; 1505 :         /* unknown */
; 1506 :         unknown_presentation_type(format.type, obj->ob_type->tp_name);

  00098	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  0009c	41 8b c8	 mov	 ecx, r8d
  0009f	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  000a3	e8 00 00 00 00	 call	 unknown_presentation_type
$LN11@PyFloat_Fo:

; 1507 :         return -1;

  000a8	83 c8 ff	 or	 eax, -1

; 1508 :     }
; 1509 : }

  000ab	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  000b0	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000b4	5f		 pop	 rdi
  000b5	c3		 ret	 0
  000b6	66 90		 npad	 2
$LN10@PyFloat_Fo:
  000b8	00 00 00 00	 DD	 $LN2@PyFloat_Fo
  000bc	00 00 00 00	 DD	 $LN1@PyFloat_Fo
$LN9@PyFloat_Fo:
  000c0	00		 DB	 0
  000c1	01		 DB	 1
  000c2	01		 DB	 1
  000c3	01		 DB	 1
  000c4	01		 DB	 1
  000c5	01		 DB	 1
  000c6	01		 DB	 1
  000c7	01		 DB	 1
  000c8	01		 DB	 1
  000c9	01		 DB	 1
  000ca	01		 DB	 1
  000cb	01		 DB	 1
  000cc	01		 DB	 1
  000cd	01		 DB	 1
  000ce	01		 DB	 1
  000cf	01		 DB	 1
  000d0	01		 DB	 1
  000d1	01		 DB	 1
  000d2	01		 DB	 1
  000d3	01		 DB	 1
  000d4	01		 DB	 1
  000d5	01		 DB	 1
  000d6	01		 DB	 1
  000d7	01		 DB	 1
  000d8	01		 DB	 1
  000d9	01		 DB	 1
  000da	01		 DB	 1
  000db	01		 DB	 1
  000dc	01		 DB	 1
  000dd	01		 DB	 1
  000de	01		 DB	 1
  000df	01		 DB	 1
  000e0	01		 DB	 1
  000e1	01		 DB	 1
  000e2	01		 DB	 1
  000e3	01		 DB	 1
  000e4	01		 DB	 1
  000e5	00		 DB	 0
  000e6	01		 DB	 1
  000e7	01		 DB	 1
  000e8	01		 DB	 1
  000e9	01		 DB	 1
  000ea	01		 DB	 1
  000eb	01		 DB	 1
  000ec	01		 DB	 1
  000ed	01		 DB	 1
  000ee	01		 DB	 1
  000ef	01		 DB	 1
  000f0	01		 DB	 1
  000f1	01		 DB	 1
  000f2	01		 DB	 1
  000f3	01		 DB	 1
  000f4	01		 DB	 1
  000f5	01		 DB	 1
  000f6	01		 DB	 1
  000f7	01		 DB	 1
  000f8	01		 DB	 1
  000f9	01		 DB	 1
  000fa	01		 DB	 1
  000fb	01		 DB	 1
  000fc	01		 DB	 1
  000fd	01		 DB	 1
  000fe	01		 DB	 1
  000ff	01		 DB	 1
  00100	01		 DB	 1
  00101	01		 DB	 1
  00102	01		 DB	 1
  00103	01		 DB	 1
  00104	01		 DB	 1
  00105	00		 DB	 0
  00106	00		 DB	 0
  00107	00		 DB	 0
  00108	01		 DB	 1
  00109	01		 DB	 1
  0010a	01		 DB	 1
  0010b	01		 DB	 1
  0010c	01		 DB	 1
  0010d	01		 DB	 1
  0010e	01		 DB	 1
  0010f	01		 DB	 1
  00110	01		 DB	 1
  00111	01		 DB	 1
  00112	01		 DB	 1
  00113	01		 DB	 1
  00114	01		 DB	 1
  00115	01		 DB	 1
  00116	01		 DB	 1
  00117	01		 DB	 1
  00118	01		 DB	 1
  00119	01		 DB	 1
  0011a	01		 DB	 1
  0011b	01		 DB	 1
  0011c	01		 DB	 1
  0011d	01		 DB	 1
  0011e	01		 DB	 1
  0011f	01		 DB	 1
  00120	01		 DB	 1
  00121	01		 DB	 1
  00122	01		 DB	 1
  00123	01		 DB	 1
  00124	01		 DB	 1
  00125	00		 DB	 0
  00126	00		 DB	 0
  00127	00		 DB	 0
  00128	01		 DB	 1
  00129	01		 DB	 1
  0012a	01		 DB	 1
  0012b	01		 DB	 1
  0012c	01		 DB	 1
  0012d	01		 DB	 1
  0012e	00		 DB	 0
_PyFloat_FormatAdvancedWriter ENDP
_TEXT	ENDS
PUBLIC	_PyComplex_FormatAdvancedWriter
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyComplex_FormatAdvancedWriter DD imagerel $LN12
	DD	imagerel $LN12+303
	DD	imagerel $unwind$_PyComplex_FormatAdvancedWriter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyComplex_FormatAdvancedWriter DD 040a01H
	DD	0e340aH
	DD	07006b20aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyComplex_FormatAdvancedWriter
_TEXT	SEGMENT
format$ = 48
writer$ = 112
obj$ = 120
format_spec$ = 128
start$ = 136
end$ = 144
_PyComplex_FormatAdvancedWriter PROC			; COMDAT

; 1516 : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	4d 8b d0	 mov	 r10, r8

; 1517 :     InternalFormatSpec format;
; 1518 : 
; 1519 :     /* check for the special case of zero length format spec, make
; 1520 :        it equivalent to str(obj) */
; 1521 :     if (start == end)

  0000d	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR end$[rsp]
  00015	49 8b c1	 mov	 rax, r9
  00018	48 8b da	 mov	 rbx, rdx
  0001b	48 8b f9	 mov	 rdi, rcx
  0001e	4d 3b c8	 cmp	 r9, r8
  00021	75 15		 jne	 SHORT $LN6@PyComplex_

; 1522 :         return format_obj(obj, writer);

  00023	48 8b d1	 mov	 rdx, rcx
  00026	48 8b cb	 mov	 rcx, rbx

; 1546 :     }
; 1547 : }

  00029	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0002e	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00032	5f		 pop	 rdi
  00033	e9 00 00 00 00	 jmp	 format_obj
$LN6@PyComplex_:

; 1523 : 
; 1524 :     /* parse the format_spec */
; 1525 :     if (!parse_internal_render_format_spec(format_spec, start, end,
; 1526 :                                            &format, '\0', '>'))

  00038	4c 8d 4c 24 30	 lea	 r9, QWORD PTR format$[rsp]
  0003d	48 8b d0	 mov	 rdx, rax
  00040	49 8b ca	 mov	 rcx, r10
  00043	c6 44 24 28 3e	 mov	 BYTE PTR [rsp+40], 62	; 0000003eH
  00048	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0004d	e8 00 00 00 00	 call	 parse_internal_render_format_spec
  00052	85 c0		 test	 eax, eax

; 1527 :         return -1;

  00054	74 52		 je	 SHORT $LN11@PyComplex_

; 1528 : 
; 1529 :     /* type conversion? */
; 1530 :     switch (format.type) {

  00056	44 8b 44 24 58	 mov	 r8d, DWORD PTR format$[rsp+40]
  0005b	41 83 f8 6e	 cmp	 r8d, 110		; 0000006eH
  0005f	77 37		 ja	 SHORT $LN1@PyComplex_
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00068	42 0f b6 84 02
	00 00 00 00	 movzx	 eax, BYTE PTR $LN9@PyComplex_[rdx+r8]
  00071	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN10@PyComplex_[rdx+rax*4]
  00078	48 03 ca	 add	 rcx, rdx
  0007b	ff e1		 jmp	 rcx
$LN2@PyComplex_:

; 1531 :     case '\0': /* No format code: like 'g', but with at least one decimal. */
; 1532 :     case 'e':
; 1533 :     case 'E':
; 1534 :     case 'f':
; 1535 :     case 'F':
; 1536 :     case 'g':
; 1537 :     case 'G':
; 1538 :     case 'n':
; 1539 :         /* no conversion, already a complex.  do the formatting */
; 1540 :         return format_complex_internal(obj, &format, writer);

  0007d	48 8d 54 24 30	 lea	 rdx, QWORD PTR format$[rsp]
  00082	4c 8b c7	 mov	 r8, rdi
  00085	48 8b cb	 mov	 rcx, rbx
  00088	e8 00 00 00 00	 call	 format_complex_internal

; 1546 :     }
; 1547 : }

  0008d	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00092	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
$LN1@PyComplex_:

; 1541 : 
; 1542 :     default:
; 1543 :         /* unknown */
; 1544 :         unknown_presentation_type(format.type, obj->ob_type->tp_name);

  00098	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  0009c	41 8b c8	 mov	 ecx, r8d
  0009f	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  000a3	e8 00 00 00 00	 call	 unknown_presentation_type
$LN11@PyComplex_:

; 1545 :         return -1;

  000a8	83 c8 ff	 or	 eax, -1

; 1546 :     }
; 1547 : }

  000ab	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  000b0	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000b4	5f		 pop	 rdi
  000b5	c3		 ret	 0
  000b6	66 90		 npad	 2
$LN10@PyComplex_:
  000b8	00 00 00 00	 DD	 $LN2@PyComplex_
  000bc	00 00 00 00	 DD	 $LN1@PyComplex_
$LN9@PyComplex_:
  000c0	00		 DB	 0
  000c1	01		 DB	 1
  000c2	01		 DB	 1
  000c3	01		 DB	 1
  000c4	01		 DB	 1
  000c5	01		 DB	 1
  000c6	01		 DB	 1
  000c7	01		 DB	 1
  000c8	01		 DB	 1
  000c9	01		 DB	 1
  000ca	01		 DB	 1
  000cb	01		 DB	 1
  000cc	01		 DB	 1
  000cd	01		 DB	 1
  000ce	01		 DB	 1
  000cf	01		 DB	 1
  000d0	01		 DB	 1
  000d1	01		 DB	 1
  000d2	01		 DB	 1
  000d3	01		 DB	 1
  000d4	01		 DB	 1
  000d5	01		 DB	 1
  000d6	01		 DB	 1
  000d7	01		 DB	 1
  000d8	01		 DB	 1
  000d9	01		 DB	 1
  000da	01		 DB	 1
  000db	01		 DB	 1
  000dc	01		 DB	 1
  000dd	01		 DB	 1
  000de	01		 DB	 1
  000df	01		 DB	 1
  000e0	01		 DB	 1
  000e1	01		 DB	 1
  000e2	01		 DB	 1
  000e3	01		 DB	 1
  000e4	01		 DB	 1
  000e5	01		 DB	 1
  000e6	01		 DB	 1
  000e7	01		 DB	 1
  000e8	01		 DB	 1
  000e9	01		 DB	 1
  000ea	01		 DB	 1
  000eb	01		 DB	 1
  000ec	01		 DB	 1
  000ed	01		 DB	 1
  000ee	01		 DB	 1
  000ef	01		 DB	 1
  000f0	01		 DB	 1
  000f1	01		 DB	 1
  000f2	01		 DB	 1
  000f3	01		 DB	 1
  000f4	01		 DB	 1
  000f5	01		 DB	 1
  000f6	01		 DB	 1
  000f7	01		 DB	 1
  000f8	01		 DB	 1
  000f9	01		 DB	 1
  000fa	01		 DB	 1
  000fb	01		 DB	 1
  000fc	01		 DB	 1
  000fd	01		 DB	 1
  000fe	01		 DB	 1
  000ff	01		 DB	 1
  00100	01		 DB	 1
  00101	01		 DB	 1
  00102	01		 DB	 1
  00103	01		 DB	 1
  00104	01		 DB	 1
  00105	00		 DB	 0
  00106	00		 DB	 0
  00107	00		 DB	 0
  00108	01		 DB	 1
  00109	01		 DB	 1
  0010a	01		 DB	 1
  0010b	01		 DB	 1
  0010c	01		 DB	 1
  0010d	01		 DB	 1
  0010e	01		 DB	 1
  0010f	01		 DB	 1
  00110	01		 DB	 1
  00111	01		 DB	 1
  00112	01		 DB	 1
  00113	01		 DB	 1
  00114	01		 DB	 1
  00115	01		 DB	 1
  00116	01		 DB	 1
  00117	01		 DB	 1
  00118	01		 DB	 1
  00119	01		 DB	 1
  0011a	01		 DB	 1
  0011b	01		 DB	 1
  0011c	01		 DB	 1
  0011d	01		 DB	 1
  0011e	01		 DB	 1
  0011f	01		 DB	 1
  00120	01		 DB	 1
  00121	01		 DB	 1
  00122	01		 DB	 1
  00123	01		 DB	 1
  00124	01		 DB	 1
  00125	00		 DB	 0
  00126	00		 DB	 0
  00127	00		 DB	 0
  00128	01		 DB	 1
  00129	01		 DB	 1
  0012a	01		 DB	 1
  0012b	01		 DB	 1
  0012c	01		 DB	 1
  0012d	01		 DB	 1
  0012e	00		 DB	 0
_PyComplex_FormatAdvancedWriter ENDP
_TEXT	ENDS
END
