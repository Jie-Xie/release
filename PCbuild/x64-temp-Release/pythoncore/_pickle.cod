; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_07LOLKJPHM@_pickle?$AA@			; `string'
PUBLIC	??_C@_05OCDPKIEO@loads?$AA@			; `string'
PUBLIC	??_C@_05HFMFBBBE@dumps?$AA@			; `string'
PUBLIC	??_C@_05DFJCHPDH@input?$AA@			; `string'
PUBLIC	??_C@_03GJLPFLNF@obj?$AA@			; `string'
PUBLIC	??_C@_0BC@CBEKFMIK@_pickle?4Unpickler?$AA@	; `string'
PUBLIC	??_C@_0BL@NOBPPGDL@_pickle?4UnpicklerMemoProxy?$AA@ ; `string'
PUBLIC	??_C@_0BA@NNFEJGCF@persistent_load?$AA@		; `string'
PUBLIC	??_C@_06EOMHCNPI@errors?$AA@			; `string'
PUBLIC	??_C@_08MLPGAEIK@encoding?$AA@			; `string'
PUBLIC	??_C@_04EONOHKEP@load?$AA@			; `string'
PUBLIC	??_C@_08IBFKALI@__dict__?$AA@			; `string'
PUBLIC	??_C@_0N@MOOGCAMH@__setstate__?$AA@		; `string'
PUBLIC	??_C@_06PCICMFGG@append?$AA@			; `string'
PUBLIC	??_C@_07MEBHOIG@__new__?$AA@			; `string'
PUBLIC	??_C@_0BA@NHLJJDN@__getinitargs__?$AA@		; `string'
PUBLIC	??_C@_0L@BHOLNLBJ@find_class?$AA@		; `string'
PUBLIC	??_C@_0BA@LFIFMGAB@_pickle?4Pickler?$AA@	; `string'
PUBLIC	??_C@_04PGONJDDE@memo?$AA@			; `string'
PUBLIC	??_C@_04LBNBHAJC@fast?$AA@			; `string'
PUBLIC	??_C@_03PDOMKJON@bin?$AA@			; `string'
PUBLIC	??_C@_0BJ@DIPNHLKH@_pickle?4PicklerMemoProxy?$AA@ ; `string'
PUBLIC	??_C@_0L@NNMACJIG@__reduce__?$AA@		; `string'
PUBLIC	??_C@_04COAGEIMF@copy?$AA@			; `string'
PUBLIC	??_C@_05MEHLAELG@clear?$AA@			; `string'
PUBLIC	??_C@_0P@MAJNENGA@dispatch_table?$AA@		; `string'
PUBLIC	??_C@_0O@IGFLDCPG@persistent_id?$AA@		; `string'
PUBLIC	??_C@_0M@IDPAOKEI@fix_imports?$AA@		; `string'
PUBLIC	??_C@_08FCFPNNHF@protocol?$AA@			; `string'
PUBLIC	??_C@_04DAMGJPCA@file?$AA@			; `string'
PUBLIC	??_C@_0L@NFDPNOOM@clear_memo?$AA@		; `string'
PUBLIC	??_C@_04GGLOKIEE@dump?$AA@			; `string'
PUBLIC	??_C@_05CFHBDDLG@items?$AA@			; `string'
PUBLIC	??_C@_04EDFDKNFG@I01?6?$AA@			; `string'
PUBLIC	??_C@_04ECJBMHGB@I00?6?$AA@			; `string'
PUBLIC	??_C@_08KBCDPPMN@readline?$AA@			; `string'
PUBLIC	??_C@_04POLDLDMI@read?$AA@			; `string'
PUBLIC	??_C@_04EOCFELL@peek?$AA@			; `string'
PUBLIC	??_C@_05NGFEDHGN@write?$AA@			; `string'
PUBLIC	??_C@_0O@MBIDJBCI@_pickle?4Pdata?$AA@		; `string'
EXTRN	PyObject_GC_Del:PROC
EXTRN	PyType_GenericNew:PROC
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyObject_GenericSetAttr:PROC
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	PyObject_HashNotImplemented:PROC
_BSS	SEGMENT
PickleError DQ	01H DUP (?)
PicklingError DQ 01H DUP (?)
UnpicklingError DQ 01H DUP (?)
dispatch_table DQ 01H DUP (?)
extension_registry DQ 01H DUP (?)
inverted_registry DQ 01H DUP (?)
extension_cache DQ 01H DUP (?)
name_mapping_2to3 DQ 01H DUP (?)
import_mapping_2to3 DQ 01H DUP (?)
name_mapping_3to2 DQ 01H DUP (?)
import_mapping_3to2 DQ 01H DUP (?)
empty_tuple DQ	01H DUP (?)
two_tuple DQ	01H DUP (?)
?module_str@?1??whichmodule@@9@9 DQ 01H DUP (?)		; `whichmodule'::`2'::module_str
?main_str@?1??whichmodule@@9@9 DQ 01H DUP (?)		; `whichmodule'::`2'::main_str
?codecs_encode@?2??save_bytes@@9@9 DQ 01H DUP (?)	; `save_bytes'::`3'::codecs_encode
?latin1@?7??save_bytes@@9@9 DQ 01H DUP (?)		; `save_bytes'::`8'::latin1
?name_str@?1??save_global@@9@9 DQ 01H DUP (?)		; `save_global'::`2'::name_str
?newobj_str@?7??save_reduce@@9@9 DQ 01H DUP (?)		; `save_reduce'::`8'::newobj_str
?name_str@?7??save_reduce@@9@9 DQ 01H DUP (?)		; `save_reduce'::`8'::name_str
?reduce_str@?BL@??save@@9@9 DQ 01H DUP (?)		; `save'::`27'::reduce_str
?reduce_ex_str@?BL@??save@@9@9 DQ 01H DUP (?)		; `save'::`27'::reduce_ex_str
_BSS	ENDS
;	COMDAT ??_C@_07LOLKJPHM@_pickle?$AA@
CONST	SEGMENT
??_C@_07LOLKJPHM@_pickle?$AA@ DB '_pickle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OCDPKIEO@loads?$AA@
CONST	SEGMENT
??_C@_05OCDPKIEO@loads?$AA@ DB 'loads', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HFMFBBBE@dumps?$AA@
CONST	SEGMENT
??_C@_05HFMFBBBE@dumps?$AA@ DB 'dumps', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DFJCHPDH@input?$AA@
CONST	SEGMENT
??_C@_05DFJCHPDH@input?$AA@ DB 'input', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GJLPFLNF@obj?$AA@
CONST	SEGMENT
??_C@_03GJLPFLNF@obj?$AA@ DB 'obj', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CBEKFMIK@_pickle?4Unpickler?$AA@
CONST	SEGMENT
??_C@_0BC@CBEKFMIK@_pickle?4Unpickler?$AA@ DB '_pickle.Unpickler', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NOBPPGDL@_pickle?4UnpicklerMemoProxy?$AA@
CONST	SEGMENT
??_C@_0BL@NOBPPGDL@_pickle?4UnpicklerMemoProxy?$AA@ DB '_pickle.Unpickler'
	DB	'MemoProxy', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NNFEJGCF@persistent_load?$AA@
CONST	SEGMENT
??_C@_0BA@NNFEJGCF@persistent_load?$AA@ DB 'persistent_load', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EOMHCNPI@errors?$AA@
CONST	SEGMENT
??_C@_06EOMHCNPI@errors?$AA@ DB 'errors', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLPGAEIK@encoding?$AA@
CONST	SEGMENT
??_C@_08MLPGAEIK@encoding?$AA@ DB 'encoding', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04EONOHKEP@load?$AA@
CONST	SEGMENT
??_C@_04EONOHKEP@load?$AA@ DB 'load', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBFKALI@__dict__?$AA@
CONST	SEGMENT
??_C@_08IBFKALI@__dict__?$AA@ DB '__dict__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOOGCAMH@__setstate__?$AA@
CONST	SEGMENT
??_C@_0N@MOOGCAMH@__setstate__?$AA@ DB '__setstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PCICMFGG@append?$AA@
CONST	SEGMENT
??_C@_06PCICMFGG@append?$AA@ DB 'append', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MEBHOIG@__new__?$AA@
CONST	SEGMENT
??_C@_07MEBHOIG@__new__?$AA@ DB '__new__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NHLJJDN@__getinitargs__?$AA@
CONST	SEGMENT
??_C@_0BA@NHLJJDN@__getinitargs__?$AA@ DB '__getinitargs__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BHOLNLBJ@find_class?$AA@
CONST	SEGMENT
??_C@_0L@BHOLNLBJ@find_class?$AA@ DB 'find_class', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LFIFMGAB@_pickle?4Pickler?$AA@
CONST	SEGMENT
??_C@_0BA@LFIFMGAB@_pickle?4Pickler?$AA@ DB '_pickle.Pickler', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PGONJDDE@memo?$AA@
CONST	SEGMENT
??_C@_04PGONJDDE@memo?$AA@ DB 'memo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBNBHAJC@fast?$AA@
CONST	SEGMENT
??_C@_04LBNBHAJC@fast?$AA@ DB 'fast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PDOMKJON@bin?$AA@
CONST	SEGMENT
??_C@_03PDOMKJON@bin?$AA@ DB 'bin', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DIPNHLKH@_pickle?4PicklerMemoProxy?$AA@
CONST	SEGMENT
??_C@_0BJ@DIPNHLKH@_pickle?4PicklerMemoProxy?$AA@ DB '_pickle.PicklerMemo'
	DB	'Proxy', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNMACJIG@__reduce__?$AA@
CONST	SEGMENT
??_C@_0L@NNMACJIG@__reduce__?$AA@ DB '__reduce__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04COAGEIMF@copy?$AA@
CONST	SEGMENT
??_C@_04COAGEIMF@copy?$AA@ DB 'copy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEHLAELG@clear?$AA@
CONST	SEGMENT
??_C@_05MEHLAELG@clear?$AA@ DB 'clear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MAJNENGA@dispatch_table?$AA@
CONST	SEGMENT
??_C@_0P@MAJNENGA@dispatch_table?$AA@ DB 'dispatch_table', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IGFLDCPG@persistent_id?$AA@
CONST	SEGMENT
??_C@_0O@IGFLDCPG@persistent_id?$AA@ DB 'persistent_id', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IDPAOKEI@fix_imports?$AA@
CONST	SEGMENT
??_C@_0M@IDPAOKEI@fix_imports?$AA@ DB 'fix_imports', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FCFPNNHF@protocol?$AA@
CONST	SEGMENT
??_C@_08FCFPNNHF@protocol?$AA@ DB 'protocol', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DAMGJPCA@file?$AA@
CONST	SEGMENT
??_C@_04DAMGJPCA@file?$AA@ DB 'file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NFDPNOOM@clear_memo?$AA@
CONST	SEGMENT
??_C@_0L@NFDPNOOM@clear_memo?$AA@ DB 'clear_memo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04GGLOKIEE@dump?$AA@
CONST	SEGMENT
??_C@_04GGLOKIEE@dump?$AA@ DB 'dump', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFHBDDLG@items?$AA@
CONST	SEGMENT
??_C@_05CFHBDDLG@items?$AA@ DB 'items', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EDFDKNFG@I01?6?$AA@
CONST	SEGMENT
??_C@_04EDFDKNFG@I01?6?$AA@ DB 'I01', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ECJBMHGB@I00?6?$AA@
CONST	SEGMENT
??_C@_04ECJBMHGB@I00?6?$AA@ DB 'I00', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KBCDPPMN@readline?$AA@
CONST	SEGMENT
??_C@_08KBCDPPMN@readline?$AA@ DB 'readline', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04POLDLDMI@read?$AA@
CONST	SEGMENT
??_C@_04POLDLDMI@read?$AA@ DB 'read', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EOCFELL@peek?$AA@
CONST	SEGMENT
??_C@_04EOCFELL@peek?$AA@ DB 'peek', 00H		; `string'
CONST	ENDS
CONST	SEGMENT
READ_WHOLE_LINE DQ ffffffffffffffffH
CONST	ENDS
_TLS	SEGMENT
?PyId_persistent_load@?1??Unpickler_init@@9@9 DQ 0000000000000000H ; `Unpickler_init'::`2'::PyId_persistent_load
	DQ	FLAT:??_C@_0BA@NNFEJGCF@persistent_load?$AA@
	DQ	0000000000000000H
?PyId_dispatch_table@?1??Pickler_init@@9@9 DQ 0000000000000000H ; `Pickler_init'::`2'::PyId_dispatch_table
	DQ	FLAT:??_C@_0P@MAJNENGA@dispatch_table?$AA@
	DQ	0000000000000000H
?PyId_persistent_id@?1??Pickler_init@@9@9 DQ 0000000000000000H ; `Pickler_init'::`2'::PyId_persistent_id
	DQ	FLAT:??_C@_0O@IGFLDCPG@persistent_id?$AA@
	DQ	0000000000000000H
?PyId___dict__@?7??load_build@@9@9 DQ 0000000000000000H	; `load_build'::`8'::PyId___dict__
	DQ	FLAT:??_C@_08IBFKALI@__dict__?$AA@
	DQ	0000000000000000H
?PyId___setstate__@?1??load_build@@9@9 DQ 0000000000000000H ; `load_build'::`2'::PyId___setstate__
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	0000000000000000H
?PyId_append@?3??do_append@@9@9 DQ 0000000000000000H	; `do_append'::`4'::PyId_append
	DQ	FLAT:??_C@_06PCICMFGG@append?$AA@
	DQ	0000000000000000H
?PyId___new__@?3??instantiate@@9@9 DQ 0000000000000000H	; `instantiate'::`4'::PyId___new__
	DQ	FLAT:??_C@_07MEBHOIG@__new__?$AA@
	DQ	0000000000000000H
?PyId___getinitargs__@?1??instantiate@@9@9 DQ 0000000000000000H ; `instantiate'::`2'::PyId___getinitargs__
	DQ	FLAT:??_C@_0BA@NHLJJDN@__getinitargs__?$AA@
	DQ	0000000000000000H
?PyId_find_class@?1??find_class@@9@9 DQ 0000000000000000H ; `find_class'::`2'::PyId_find_class
	DQ	FLAT:??_C@_0L@BHOLNLBJ@find_class?$AA@
	DQ	0000000000000000H
?PyId_items@?7??save_dict@@9@9 DQ 0000000000000000H	; `save_dict'::`8'::PyId_items
	DQ	FLAT:??_C@_05CFHBDDLG@items?$AA@
	DQ	0000000000000000H
?PyId_readline@?1??_Unpickler_SetInputStream@@9@9 DQ 0000000000000000H ; `_Unpickler_SetInputStream'::`2'::PyId_readline
	DQ	FLAT:??_C@_08KBCDPPMN@readline?$AA@
	DQ	0000000000000000H
?PyId_read@?1??_Unpickler_SetInputStream@@9@9 DQ 0000000000000000H ; `_Unpickler_SetInputStream'::`2'::PyId_read
	DQ	FLAT:??_C@_04POLDLDMI@read?$AA@
	DQ	0000000000000000H
?PyId_peek@?1??_Unpickler_SetInputStream@@9@9 DQ 0000000000000000H ; `_Unpickler_SetInputStream'::`2'::PyId_peek
	DQ	FLAT:??_C@_04EOCFELL@peek?$AA@
	DQ	0000000000000000H
?PyId_write@?1??_Pickler_SetOutputStream@@9@9 DQ 0000000000000000H ; `_Pickler_SetOutputStream'::`2'::PyId_write
	DQ	FLAT:??_C@_05NGFEDHGN@write?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_05NGFEDHGN@write?$AA@
CONST	SEGMENT
??_C@_05NGFEDHGN@write?$AA@ DB 'write', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MBIDJBCI@_pickle?4Pdata?$AA@
CONST	SEGMENT
??_C@_0O@MBIDJBCI@_pickle?4Pdata?$AA@ DB '_pickle.Pdata', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
pickle_module_doc DB 'Optimized C implementation for the Python pickle mo'
	DB	'dule.', 00H
	ORG $+7
Pdata_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0O@MBIDJBCI@_pickle?4Pdata?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:Pdata_dealloc
	ORG $+336
?buf@?1??save_bool@@9@9 DQ FLAT:??_C@_04ECJBMHGB@I00?6?$AA@ ; `save_bool'::`2'::buf
	DQ	FLAT:??_C@_04EDFDKNFG@I01?6?$AA@
Pickler_clear_memo_doc DB 'clear_memo() -> None. Clears the pickler''s "m'
	DB	'emo".', 0aH, 'The memo is the data structure that remembers w'
	DB	'hich objects the', 0aH, 'pickler has already seen, so that sh'
	DB	'ared or recursive objects are', 0aH, 'pickled by reference an'
	DB	'd not by value.  This method is useful when', 0aH, 're-using '
	DB	'picklers.', 00H
	ORG $+5
Pickler_dump_doc DB 'dump(obj) -> None. Write a pickled representation of'
	DB	' obj to the open file.', 00H
	ORG $+5
Pickler_methods DQ FLAT:??_C@_04GGLOKIEE@dump?$AA@
	DQ	FLAT:Pickler_dump
	DD	01H
	ORG $+4
	DQ	FLAT:Pickler_dump_doc
	DQ	FLAT:??_C@_0L@NFDPNOOM@clear_memo?$AA@
	DQ	FLAT:Pickler_clear_memo
	DD	04H
	ORG $+4
	DQ	FLAT:Pickler_clear_memo_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
Pickler_doc DB	'Pickler(file, protocol=None)', 0aH, 'This takes a binary'
	DB	' file for writing a pickle data stream.', 0aH, 0aH, 'The opti'
	DB	'onal protocol argument tells the pickler to use the', 0aH, 'g'
	DB	'iven protocol; supported protocols are 0, 1, 2, 3.  The defau'
	DB	'lt', 0aH, 'protocol is 3; a backward-incompatible protocol de'
	DB	'signed for', 0aH, 'Python 3.0.', 0aH, 0aH, 'Specifying a nega'
	DB	'tive protocol version selects the highest', 0aH, 'protocol ve'
	DB	'rsion supported.  The higher the protocol used, the', 0aH, 'm'
	DB	'ore recent the version of Python needed to read the pickle', 0aH
	DB	'produced.', 0aH, 0aH, 'The file argument must have a write() '
	DB	'method that accepts a single', 0aH, 'bytes argument. It can t'
	DB	'hus be a file object opened for binary', 0aH, 'writing, a io.'
	DB	'BytesIO instance, or any other custom object that', 0aH, 'mee'
	DB	'ts this interface.', 0aH, 0aH, 'If fix_imports is True and pr'
	DB	'otocol is less than 3, pickle will try to', 0aH, 'map the new'
	DB	' Python 3.x names to the old module names used in Python', 0aH
	DB	'2.x, so that the pickle data stream is readable with Python 2'
	DB	'.x.', 0aH, 00H
	ORG $+1
?kwlist@?1??Pickler_init@@9@9 DQ FLAT:??_C@_04DAMGJPCA@file?$AA@ ; `Pickler_init'::`2'::kwlist
	DQ	FLAT:??_C@_08FCFPNNHF@protocol?$AA@
	DQ	FLAT:??_C@_0M@IDPAOKEI@fix_imports?$AA@
	DQ	0000000000000000H
pmp_clear_doc DB 'memo.clear() -> None.  Remove all items from memo.', 00H
	ORG $+5
pmp_copy_doc DB	'memo.copy() -> new_memo.  Copy the memo to a new object.'
	DB	00H
	ORG $+7
pmp_reduce_doc DB 'memo.__reduce__(). Pickling support.', 00H
	ORG $+11
picklerproxy_methods DQ FLAT:??_C@_05MEHLAELG@clear?$AA@
	DQ	FLAT:pmp_clear
	DD	04H
	ORG $+4
	DQ	FLAT:pmp_clear_doc
	DQ	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DQ	FLAT:pmp_copy
	DD	04H
	ORG $+4
	DQ	FLAT:pmp_copy_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:pmp_reduce
	DD	01H
	ORG $+4
	DQ	FLAT:pmp_reduce_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
PicklerMemoProxyType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BJ@DIPNHLKH@_pickle?4PicklerMemoProxy?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:PicklerMemoProxy_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_HashNotImplemented
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	FLAT:PyObject_GenericSetAttr
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:PicklerMemoProxy_traverse
	DQ	FLAT:PicklerMemoProxy_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:picklerproxy_methods
	ORG $+152
Pickler_members DQ FLAT:??_C@_03PDOMKJON@bin?$AA@
	DD	01H
	ORG $+4
	DQ	00000000000000a4H
	ORG $+16
	DQ	FLAT:??_C@_04LBNBHAJC@fast?$AA@
	DD	01H
	ORG $+4
	DQ	00000000000000b0H
	ORG $+16
	DQ	FLAT:??_C@_0P@MAJNENGA@dispatch_table?$AA@
	DD	010H
	ORG $+4
	DQ	0000000000000070H
	ORG $+16
	DQ	0000000000000000H
	ORG $+32
Pickler_getsets DQ FLAT:??_C@_04PGONJDDE@memo?$AA@
	DQ	FLAT:Pickler_get_memo
	DQ	FLAT:Pickler_set_memo
	ORG $+16
	DQ	FLAT:??_C@_0O@IGFLDCPG@persistent_id?$AA@
	DQ	FLAT:Pickler_get_persid
	DQ	FLAT:Pickler_set_persid
	ORG $+16
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
Pickler_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BA@LFIFMGAB@_pickle?4Pickler?$AA@
	DQ	00000000000000d0H
	DQ	0000000000000000H
	DQ	FLAT:Pickler_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:Pickler_doc
	DQ	FLAT:Pickler_traverse
	DQ	FLAT:Pickler_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:Pickler_methods
	DQ	FLAT:Pickler_members
	DQ	FLAT:Pickler_getsets
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:Pickler_init
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:PyType_GenericNew
	DQ	FLAT:PyObject_GC_Del
	DQ	0000000000000000H
	ORG $+56
Unpickler_load_doc DB 'load() -> object. Load a pickle.', 0aH, 'Read a pi'
	DB	'ckled object representation from the open file object given i'
	DB	'n', 0aH, 'the constructor, and return the reconstituted objec'
	DB	't hierarchy specified', 0aH, 'therein.', 0aH, 00H
	ORG $+4
Unpickler_find_class_doc DB 'find_class(module_name, global_name) -> obje'
	DB	'ct.', 0aH, 0aH, 'Return an object from a specified module, im'
	DB	'porting the module if', 0aH, 'necessary.  Subclasses may over'
	DB	'ride this method (e.g. to restrict', 0aH, 'unpickling of arbi'
	DB	'trary classes and functions).', 0aH, 0aH, 'This method is cal'
	DB	'led whenever a class or a function object is', 0aH, 'needed. '
	DB	' Both arguments passed are str objects.', 0aH, 00H
	ORG $+10
Unpickler_methods DQ FLAT:??_C@_04EONOHKEP@load?$AA@
	DQ	FLAT:Unpickler_load
	DD	04H
	ORG $+4
	DQ	FLAT:Unpickler_load_doc
	DQ	FLAT:??_C@_0L@BHOLNLBJ@find_class?$AA@
	DQ	FLAT:Unpickler_find_class
	DD	01H
	ORG $+4
	DQ	FLAT:Unpickler_find_class_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
Unpickler_doc DB 'Unpickler(file, *, encoding=''ASCII'', errors=''strict'''
	DB	')', 0aH, 'This takes a binary file for reading a pickle data '
	DB	'stream.', 0aH, 0aH, 'The protocol version of the pickle is de'
	DB	'tected automatically, so no', 0aH, 'proto argument is needed.'
	DB	0aH, 0aH, 'The file-like object must have two methods, a read('
	DB	') method', 0aH, 'that takes an integer argument, and a readli'
	DB	'ne() method that', 0aH, 'requires no arguments.  Both methods'
	DB	' should return bytes.', 0aH, 'Thus file-like object can be a '
	DB	'binary file object opened for', 0aH, 'reading, a BytesIO obje'
	DB	'ct, or any other custom object that', 0aH, 'meets this interf'
	DB	'ace.', 0aH, 0aH, 'Optional keyword arguments are *fix_imports'
	DB	'*, *encoding* and *errors*,', 0aH, 'which are used to control'
	DB	' compatiblity support for pickle stream', 0aH, 'generated by '
	DB	'Python 2.x.  If *fix_imports* is True, pickle will try to', 0aH
	DB	'map the old Python 2.x names to the new names used in Python '
	DB	'3.x.  The', 0aH, '*encoding* and *errors* tell pickle how to '
	DB	'decode 8-bit string', 0aH, 'instances pickled by Python 2.x; '
	DB	'these default to ''ASCII'' and', 0aH, '''strict'', respective'
	DB	'ly.', 0aH, 00H
	ORG $+1
?kwlist@?1??Unpickler_init@@9@9 DQ FLAT:??_C@_04DAMGJPCA@file?$AA@ ; `Unpickler_init'::`2'::kwlist
	DQ	FLAT:??_C@_0M@IDPAOKEI@fix_imports?$AA@
	DQ	FLAT:??_C@_08MLPGAEIK@encoding?$AA@
	DQ	FLAT:??_C@_06EOMHCNPI@errors?$AA@
	DQ	0000000000000000H
ump_clear_doc DB 'memo.clear() -> None.  Remove all items from memo.', 00H
	ORG $+5
ump_copy_doc DB	'memo.copy() -> new_memo.  Copy the memo to a new object.'
	DB	00H
	ORG $+7
ump_reduce_doc DB 'memo.__reduce__(). Pickling support.', 00H
	ORG $+11
unpicklerproxy_methods DQ FLAT:??_C@_05MEHLAELG@clear?$AA@
	DQ	FLAT:ump_clear
	DD	04H
	ORG $+4
	DQ	FLAT:ump_clear_doc
	DQ	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DQ	FLAT:ump_copy
	DD	04H
	ORG $+4
	DQ	FLAT:ump_copy_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:ump_reduce
	DD	01H
	ORG $+4
	DQ	FLAT:ump_reduce_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
UnpicklerMemoProxyType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BL@NOBPPGDL@_pickle?4UnpicklerMemoProxy?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:UnpicklerMemoProxy_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_HashNotImplemented
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	FLAT:PyObject_GenericSetAttr
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:UnpicklerMemoProxy_traverse
	DQ	FLAT:UnpicklerMemoProxy_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:unpicklerproxy_methods
	ORG $+152
Unpickler_getsets DQ FLAT:??_C@_04PGONJDDE@memo?$AA@
	DQ	FLAT:Unpickler_get_memo
	DQ	FLAT:Unpickler_set_memo
	ORG $+16
	DQ	FLAT:??_C@_0BA@NNFEJGCF@persistent_load?$AA@
	DQ	FLAT:Unpickler_get_persload
	DQ	FLAT:Unpickler_set_persload
	ORG $+16
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
Unpickler_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BC@CBEKFMIK@_pickle?4Unpickler?$AA@
	DQ	0000000000000150H
	DQ	0000000000000000H
	DQ	FLAT:Unpickler_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:Unpickler_doc
	DQ	FLAT:Unpickler_traverse
	DQ	FLAT:Unpickler_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:Unpickler_methods
	DQ	0000000000000000H
	DQ	FLAT:Unpickler_getsets
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:Unpickler_init
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:PyType_GenericNew
	DQ	FLAT:PyObject_GC_Del
	DQ	0000000000000000H
	ORG $+56
pickle_dump_doc DB 'dump(obj, file, protocol=None, *, fix_imports=True) -'
	DB	'> None', 0aH, 0aH, 'Write a pickled representation of obj to '
	DB	'the open file object file.  This', 0aH, 'is equivalent to ``P'
	DB	'ickler(file, protocol).dump(obj)``, but may be more', 0aH, 'e'
	DB	'fficient.', 0aH, 0aH, 'The optional protocol argument tells t'
	DB	'he pickler to use the given protocol;', 0aH, 'supported proto'
	DB	'cols are 0, 1, 2, 3.  The default protocol is 3; a', 0aH, 'ba'
	DB	'ckward-incompatible protocol designed for Python 3.0.', 0aH, 0aH
	DB	'Specifying a negative protocol version selects the highest pr'
	DB	'otocol version', 0aH, 'supported.  The higher the protocol us'
	DB	'ed, the more recent the version of', 0aH, 'Python needed to r'
	DB	'ead the pickle produced.', 0aH, 0aH, 'The file argument must '
	DB	'have a write() method that accepts a single bytes', 0aH, 'arg'
	DB	'ument.  It can thus be a file object opened for binary writin'
	DB	'g, a', 0aH, 'io.BytesIO instance, or any other custom object '
	DB	'that meets this interface.', 0aH, 0aH, 'If fix_imports is Tru'
	DB	'e and protocol is less than 3, pickle will try to', 0aH, 'map'
	DB	' the new Python 3.x names to the old module names used in Pyt'
	DB	'hon 2.x,', 0aH, 'so that the pickle data stream is readable w'
	DB	'ith Python 2.x.', 0aH, 00H
	ORG $+6
?kwlist@?1??pickle_dump@@9@9 DQ FLAT:??_C@_03GJLPFLNF@obj?$AA@ ; `pickle_dump'::`2'::kwlist
	DQ	FLAT:??_C@_04DAMGJPCA@file?$AA@
	DQ	FLAT:??_C@_08FCFPNNHF@protocol?$AA@
	DQ	FLAT:??_C@_0M@IDPAOKEI@fix_imports?$AA@
	DQ	0000000000000000H
	ORG $+8
pickle_dumps_doc DB 'dumps(obj, protocol=None, *, fix_imports=True) -> by'
	DB	'tes', 0aH, 0aH, 'Return the pickled representation of the obj'
	DB	'ect as a bytes', 0aH, 'object, instead of writing it to a fil'
	DB	'e.', 0aH, 0aH, 'The optional protocol argument tells the pick'
	DB	'ler to use the given protocol;', 0aH, 'supported protocols ar'
	DB	'e 0, 1, 2, 3.  The default protocol is 3; a', 0aH, 'backward-'
	DB	'incompatible protocol designed for Python 3.0.', 0aH, 0aH, 'S'
	DB	'pecifying a negative protocol version selects the highest pro'
	DB	'tocol version', 0aH, 'supported.  The higher the protocol use'
	DB	'd, the more recent the version of', 0aH, 'Python needed to re'
	DB	'ad the pickle produced.', 0aH, 0aH, 'If fix_imports is True a'
	DB	'nd *protocol* is less than 3, pickle will try to', 0aH, 'map '
	DB	'the new Python 3.x names to the old module names used in Pyth'
	DB	'on 2.x,', 0aH, 'so that the pickle data stream is readable wi'
	DB	'th Python 2.x.', 0aH, 00H
	ORG $+3
?kwlist@?1??pickle_dumps@@9@9 DQ FLAT:??_C@_03GJLPFLNF@obj?$AA@ ; `pickle_dumps'::`2'::kwlist
	DQ	FLAT:??_C@_08FCFPNNHF@protocol?$AA@
	DQ	FLAT:??_C@_0M@IDPAOKEI@fix_imports?$AA@
	DQ	0000000000000000H
	ORG $+8
pickle_load_doc DB 'load(file, *, fix_imports=True, encoding=''ASCII'', e'
	DB	'rrors=''strict'') -> object', 0aH, 0aH, 'Read a pickled objec'
	DB	't representation from the open file object file and', 0aH, 'r'
	DB	'eturn the reconstituted object hierarchy specified therein.  '
	DB	'This is', 0aH, 'equivalent to ``Unpickler(file).load()``, but'
	DB	' may be more efficient.', 0aH, 0aH, 'The protocol version of '
	DB	'the pickle is detected automatically, so no protocol', 0aH, 'a'
	DB	'rgument is needed.  Bytes past the pickled object''s represen'
	DB	'tation are', 0aH, 'ignored.', 0aH, 0aH, 'The argument file mu'
	DB	'st have two methods, a read() method that takes an', 0aH, 'in'
	DB	'teger argument, and a readline() method that requires no argu'
	DB	'ments.  Both', 0aH, 'methods should return bytes.  Thus *file'
	DB	'* can be a binary file object opened', 0aH, 'for reading, a B'
	DB	'ytesIO object, or any other custom object that meets this', 0aH
	DB	'interface.', 0aH, 0aH, 'Optional keyword arguments are fix_im'
	DB	'ports, encoding and errors,', 0aH, 'which are used to control'
	DB	' compatiblity support for pickle stream generated', 0aH, 'by '
	DB	'Python 2.x.  If fix_imports is True, pickle will try to map t'
	DB	'he old', 0aH, 'Python 2.x names to the new names used in Pyth'
	DB	'on 3.x.  The encoding and', 0aH, 'errors tell pickle how to d'
	DB	'ecode 8-bit string instances pickled by Python', 0aH, '2.x; t'
	DB	'hese default to ''ASCII'' and ''strict'', respectively.', 0aH
	DB	00H
	ORG $+1
?kwlist@?1??pickle_load@@9@9 DQ FLAT:??_C@_04DAMGJPCA@file?$AA@ ; `pickle_load'::`2'::kwlist
	DQ	FLAT:??_C@_0M@IDPAOKEI@fix_imports?$AA@
	DQ	FLAT:??_C@_08MLPGAEIK@encoding?$AA@
	DQ	FLAT:??_C@_06EOMHCNPI@errors?$AA@
	DQ	0000000000000000H
pickle_loads_doc DB 'loads(input, *, fix_imports=True, encoding=''ASCII'''
	DB	', errors=''strict'') -> object', 0aH, 0aH, 'Read a pickled ob'
	DB	'ject hierarchy from a bytes object and return the', 0aH, 'rec'
	DB	'onstituted object hierarchy specified therein', 0aH, 0aH, 'Th'
	DB	'e protocol version of the pickle is detected automatically, s'
	DB	'o no protocol', 0aH, 'argument is needed.  Bytes past the pic'
	DB	'kled object''s representation are', 0aH, 'ignored.', 0aH, 0aH
	DB	'Optional keyword arguments are fix_imports, encoding and erro'
	DB	'rs, which', 0aH, 'are used to control compatiblity support fo'
	DB	'r pickle stream generated', 0aH, 'by Python 2.x.  If fix_impo'
	DB	'rts is True, pickle will try to map the old', 0aH, 'Python 2.'
	DB	'x names to the new names used in Python 3.x.  The encoding an'
	DB	'd', 0aH, 'errors tell pickle how to decode 8-bit string insta'
	DB	'nces pickled by Python', 0aH, '2.x; these default to ''ASCII'''
	DB	' and ''strict'', respectively.', 0aH, 00H
	ORG $+4
?kwlist@?1??pickle_loads@@9@9 DQ FLAT:??_C@_05DFJCHPDH@input?$AA@ ; `pickle_loads'::`2'::kwlist
	DQ	FLAT:??_C@_0M@IDPAOKEI@fix_imports?$AA@
	DQ	FLAT:??_C@_08MLPGAEIK@encoding?$AA@
	DQ	FLAT:??_C@_06EOMHCNPI@errors?$AA@
	DQ	0000000000000000H
pickle_methods DQ FLAT:??_C@_04GGLOKIEE@dump?$AA@
	DQ	FLAT:pickle_dump
	DD	03H
	ORG $+4
	DQ	FLAT:pickle_dump_doc
	DQ	FLAT:??_C@_05HFMFBBBE@dumps?$AA@
	DQ	FLAT:pickle_dumps
	DD	03H
	ORG $+4
	DQ	FLAT:pickle_dumps_doc
	DQ	FLAT:??_C@_04EONOHKEP@load?$AA@
	DQ	FLAT:pickle_load
	DD	03H
	ORG $+4
	DQ	FLAT:pickle_load_doc
	DQ	FLAT:??_C@_05OCDPKIEO@loads?$AA@
	DQ	FLAT:pickle_loads
	DD	03H
	ORG $+4
	DQ	FLAT:pickle_loads_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
_picklemodule DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_07LOLKJPHM@_pickle?$AA@
	DQ	FLAT:pickle_module_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:pickle_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@LIPPOKPL@unpickling?5stack?5underflow?$AA@ ; `string'
EXTRN	PyErr_SetString:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_pickle.c
pdata	SEGMENT
$pdata$stack_underflow DD imagerel stack_underflow
	DD	imagerel stack_underflow+31
	DD	imagerel $unwind$stack_underflow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stack_underflow DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BL@LIPPOKPL@unpickling?5stack?5underflow?$AA@
CONST	SEGMENT
??_C@_0BL@LIPPOKPL@unpickling?5stack?5underflow?$AA@ DB 'unpickling stack'
	DB	' underflow', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT stack_underflow
_TEXT	SEGMENT
stack_underflow PROC					; COMDAT

; 141  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 142  :     PyErr_SetString(UnpicklingError, "unpickling stack underflow");

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@LIPPOKPL@unpickling?5stack?5underflow?$AA@
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 143  :     return -1;

  00017	83 c8 ff	 or	 eax, -1

; 144  : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
stack_underflow ENDP
_TEXT	ENDS
EXTRN	__imp_free:PROC
EXTRN	PyObject_Free:PROC
EXTRN	_PxMem_Free:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$Pdata_dealloc DD imagerel Pdata_dealloc
	DD	imagerel Pdata_dealloc+6
	DD	imagerel $unwind$Pdata_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$Pdata_dealloc DD imagerel Pdata_dealloc+6
	DD	imagerel Pdata_dealloc+27
	DD	imagerel $chain$0$Pdata_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$Pdata_dealloc DD imagerel Pdata_dealloc+27
	DD	imagerel Pdata_dealloc+151
	DD	imagerel $chain$1$Pdata_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$Pdata_dealloc DD imagerel Pdata_dealloc+151
	DD	imagerel Pdata_dealloc+169
	DD	imagerel $chain$2$Pdata_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$Pdata_dealloc DD imagerel Pdata_dealloc+169
	DD	imagerel Pdata_dealloc+206
	DD	imagerel $chain$3$Pdata_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$Pdata_dealloc DD 021H
	DD	imagerel Pdata_dealloc
	DD	imagerel Pdata_dealloc+6
	DD	imagerel $unwind$Pdata_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$Pdata_dealloc DD 021H
	DD	imagerel Pdata_dealloc+6
	DD	imagerel Pdata_dealloc+27
	DD	imagerel $chain$0$Pdata_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$Pdata_dealloc DD 020521H
	DD	083405H
	DD	imagerel Pdata_dealloc+6
	DD	imagerel Pdata_dealloc+27
	DD	imagerel $chain$0$Pdata_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$Pdata_dealloc DD 020521H
	DD	097405H
	DD	imagerel Pdata_dealloc
	DD	imagerel Pdata_dealloc+6
	DD	imagerel $unwind$Pdata_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pdata_dealloc DD 020601H
	DD	060025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT Pdata_dealloc
_TEXT	SEGMENT
self$ = 64
Pdata_dealloc PROC					; COMDAT

; 155  : {

  00000	40 56		 push	 rsi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 156  :     Py_ssize_t i = Py_SIZE(self);
; 157  :     while (--i >= 0) {

  0000b	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]
  0000f	48 8b f1	 mov	 rsi, rcx
  00012	48 ff cf	 dec	 rdi
  00015	0f 88 7c 00 00
	00		 js	 $LN1@Pdata_deal
  0001b	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
$LL2@Pdata_deal:

; 158  :         Py_DECREF(self->data[i]);

  00020	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  00024	48 8b 1c f8	 mov	 rbx, QWORD PTR [rax+rdi*8]
  00028	e8 00 00 00 00	 call	 _Py_PXCTX
  0002d	85 c0		 test	 eax, eax
  0002f	75 5c		 jne	 SHORT $LN17@Pdata_deal
  00031	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00035	a8 20		 test	 al, 32			; 00000020H
  00037	75 4c		 jne	 SHORT $LN11@Pdata_deal
  00039	84 c0		 test	 al, al
  0003b	78 48		 js	 SHORT $LN11@Pdata_deal
  0003d	a8 02		 test	 al, 2
  0003f	75 4c		 jne	 SHORT $LN17@Pdata_deal
  00041	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00045	75 46		 jne	 SHORT $LN17@Pdata_deal
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00055	4c 8b cb	 mov	 r9, rbx
  00058	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0005e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00066	e8 00 00 00 00	 call	 _PyParallel_Guard
  0006b	48 8b cb	 mov	 rcx, rbx
  0006e	85 c0		 test	 eax, eax
  00070	74 07		 je	 SHORT $LN16@Pdata_deal
  00072	e8 00 00 00 00	 call	 _Px_Dealloc
  00077	eb 14		 jmp	 SHORT $LN17@Pdata_deal
$LN16@Pdata_deal:
  00079	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0007d	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00083	eb 08		 jmp	 SHORT $LN17@Pdata_deal
$LN11@Pdata_deal:
  00085	48 8b cb	 mov	 rcx, rbx
  00088	e8 00 00 00 00	 call	 Px_DecRef
$LN17@Pdata_deal:

; 156  :     Py_ssize_t i = Py_SIZE(self);
; 157  :     while (--i >= 0) {

  0008d	48 ff cf	 dec	 rdi
  00090	79 8e		 jns	 SHORT $LL2@Pdata_deal
  00092	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN1@Pdata_deal:

; 159  :     }
; 160  :     PyMem_FREE(self->data);

  00097	e8 00 00 00 00	 call	 _Py_PXCTX
  0009c	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000a1	48 8b 4e 70	 mov	 rcx, QWORD PTR [rsi+112]
  000a5	85 c0		 test	 eax, eax
  000a7	74 12		 je	 SHORT $LN5@Pdata_deal
  000a9	e8 00 00 00 00	 call	 _PxMem_Free

; 161  :     PyObject_Del(self);

  000ae	48 8b ce	 mov	 rcx, rsi

; 162  : }

  000b1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b5	5e		 pop	 rsi
  000b6	e9 00 00 00 00	 jmp	 PyObject_Free
$LN5@Pdata_deal:

; 159  :     }
; 160  :     PyMem_FREE(self->data);

  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 161  :     PyObject_Del(self);

  000c1	48 8b ce	 mov	 rcx, rsi

; 162  : }

  000c4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c8	5e		 pop	 rsi
  000c9	e9 00 00 00 00	 jmp	 PyObject_Free
Pdata_dealloc ENDP
_TEXT	ENDS
EXTRN	PyErr_NoMemory:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	_PyObject_New:PROC
EXTRN	_PxObject_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pdata_New DD imagerel Pdata_New
	DD	imagerel Pdata_New+48
	DD	imagerel $unwind$Pdata_New
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$Pdata_New DD imagerel Pdata_New+48
	DD	imagerel Pdata_New+149
	DD	imagerel $chain$0$Pdata_New
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$Pdata_New DD imagerel Pdata_New+149
	DD	imagerel Pdata_New+176
	DD	imagerel $chain$1$Pdata_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$Pdata_New DD 021H
	DD	imagerel Pdata_New
	DD	imagerel Pdata_New+48
	DD	imagerel $unwind$Pdata_New
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$Pdata_New DD 020521H
	DD	067405H
	DD	imagerel Pdata_New
	DD	imagerel Pdata_New+48
	DD	imagerel $unwind$Pdata_New
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pdata_New DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT Pdata_New
_TEXT	SEGMENT
Pdata_New PROC						; COMDAT

; 174  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 175  :     Pdata *self;
; 176  : 
; 177  :     if (!(self = PyObject_New(Pdata, &Pdata_Type)))

  00006	e8 00 00 00 00	 call	 _Py_PXCTX
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Pdata_Type
  00012	85 c0		 test	 eax, eax
  00014	74 07		 je	 SHORT $LN5@Pdata_New
  00016	e8 00 00 00 00	 call	 _PxObject_New
  0001b	eb 05		 jmp	 SHORT $LN13@Pdata_New
$LN5@Pdata_New:
  0001d	e8 00 00 00 00	 call	 _PyObject_New
$LN13@Pdata_New:
  00022	48 8b d8	 mov	 rbx, rax
  00025	48 85 c0	 test	 rax, rax
  00028	75 06		 jne	 SHORT $LN2@Pdata_New

; 185  :     return PyErr_NoMemory();
; 186  : }

  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5b		 pop	 rbx
  0002f	c3		 ret	 0
$LN2@Pdata_New:
  00030	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 178  :         return NULL;
; 179  :     Py_SIZE(self) = 0;

  00035	33 ff		 xor	 edi, edi

; 180  :     self->allocated = 8;

  00037	48 c7 43 78 08
	00 00 00	 mov	 QWORD PTR [rbx+120], 8
  0003f	48 89 7b 60	 mov	 QWORD PTR [rbx+96], rdi

; 181  :     self->data = PyMem_MALLOC(self->allocated * sizeof(PyObject *));

  00043	e8 00 00 00 00	 call	 _Py_PXCTX
  00048	85 c0		 test	 eax, eax
  0004a	74 0f		 je	 SHORT $LN11@Pdata_New
  0004c	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  00050	48 c1 e1 03	 shl	 rcx, 3
  00054	e8 00 00 00 00	 call	 _PxMem_Malloc
  00059	eb 29		 jmp	 SHORT $LN14@Pdata_New
$LN11@Pdata_New:
  0005b	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]
  0005f	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00069	48 c1 e0 03	 shl	 rax, 3
  0006d	48 3b c1	 cmp	 rax, rcx
  00070	77 15		 ja	 SHORT $LN10@Pdata_New
  00072	48 85 c0	 test	 rax, rax
  00075	b9 01 00 00 00	 mov	 ecx, 1
  0007a	48 0f 45 c8	 cmovne	 rcx, rax
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN14@Pdata_New:
  00084	48 8b f8	 mov	 rdi, rax
$LN10@Pdata_New:
  00087	48 89 7b 70	 mov	 QWORD PTR [rbx+112], rdi

; 182  :     if (self->data)

  0008b	48 85 ff	 test	 rdi, rdi
  0008e	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00093	74 09		 je	 SHORT $LN1@Pdata_New

; 183  :         return (PyObject *)self;

  00095	48 8b c3	 mov	 rax, rbx

; 185  :     return PyErr_NoMemory();
; 186  : }

  00098	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009c	5b		 pop	 rbx
  0009d	c3		 ret	 0
$LN1@Pdata_New:

; 184  :     Py_DECREF(self);

  0009e	48 8b cb	 mov	 rcx, rbx
  000a1	e8 00 00 00 00	 call	 _Py_DecRef

; 185  :     return PyErr_NoMemory();
; 186  : }

  000a6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000aa	5b		 pop	 rbx
  000ab	e9 00 00 00 00	 jmp	 PyErr_NoMemory
Pdata_New ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@IIKMBICA@Pdata_clear?$AA@		; `string'
PUBLIC	??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$Pdata_clear DD imagerel Pdata_clear
	DD	imagerel Pdata_clear+71
	DD	imagerel $unwind$Pdata_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$Pdata_clear DD imagerel Pdata_clear+71
	DD	imagerel Pdata_clear+286
	DD	imagerel $chain$1$Pdata_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$Pdata_clear DD imagerel Pdata_clear+286
	DD	imagerel Pdata_clear+308
	DD	imagerel $chain$2$Pdata_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$Pdata_clear DD 021H
	DD	imagerel Pdata_clear
	DD	imagerel Pdata_clear+71
	DD	imagerel $unwind$Pdata_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$Pdata_clear DD 040d21H
	DD	08340dH
	DD	09c405H
	DD	imagerel Pdata_clear
	DD	imagerel Pdata_clear+71
	DD	imagerel $unwind$Pdata_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pdata_clear DD 060f01H
	DD	0b640fH
	DD	0a540fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0M@IIKMBICA@Pdata_clear?$AA@
CONST	SEGMENT
??_C@_0M@IIKMBICA@Pdata_clear?$AA@ DB 'Pdata_clear', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
CONST	SEGMENT
??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@ DB '..\Modules\_pickle.'
	DB	'c', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT Pdata_clear
_TEXT	SEGMENT
self$ = 64
clearto$ = 72
Pdata_clear PROC					; COMDAT

; 194  : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 195  :     Py_ssize_t i = Py_SIZE(self);

  0000f	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]
  00013	48 8b f2	 mov	 rsi, rdx
  00016	48 8b e9	 mov	 rbp, rcx

; 196  : 
; 197  :     if (clearto < 0)

  00019	48 85 d2	 test	 rdx, rdx
  0001c	79 14		 jns	 SHORT $LN8@Pdata_clea

; 206  :     return 0;
; 207  : }

  0001e	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00023	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00028	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002c	5f		 pop	 rdi
  0002d	e9 00 00 00 00	 jmp	 stack_underflow
$LN8@Pdata_clea:

; 198  :         return stack_underflow();
; 199  :     if (clearto >= i)

  00032	48 3b d7	 cmp	 rdx, rdi

; 200  :         return 0;

  00035	0f 8d e7 00 00
	00		 jge	 $LN23@Pdata_clea

; 201  : 
; 202  :     while (--i >= clearto) {

  0003b	48 ff cf	 dec	 rdi
  0003e	48 3b fa	 cmp	 rdi, rdx
  00041	0f 8c d7 00 00
	00		 jl	 $LN5@Pdata_clea
  00047	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  0004c	45 33 e4	 xor	 r12d, r12d
  0004f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00054	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL6@Pdata_clea:
  00060	4c 8b 4d 70	 mov	 r9, QWORD PTR [rbp+112]

; 203  :         Py_CLEAR(self->data[i]);

  00064	4d 39 24 f9	 cmp	 QWORD PTR [r9+rdi*8], r12
  00068	0f 84 9a 00 00
	00		 je	 $LN3@Pdata_clea
  0006e	4d 8b 0c f9	 mov	 r9, QWORD PTR [r9+rdi*8]
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@IIKMBICA@Pdata_clear?$AA@
  00080	41 b8 cb 00 00
	00		 mov	 r8d, 203		; 000000cbH
  00086	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0008e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00093	85 c0		 test	 eax, eax
  00095	75 71		 jne	 SHORT $LN3@Pdata_clea
  00097	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  0009b	48 8b 1c f8	 mov	 rbx, QWORD PTR [rax+rdi*8]
  0009f	4c 89 24 f8	 mov	 QWORD PTR [rax+rdi*8], r12
  000a3	e8 00 00 00 00	 call	 _Py_PXCTX
  000a8	85 c0		 test	 eax, eax
  000aa	75 5c		 jne	 SHORT $LN3@Pdata_clea
  000ac	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000b0	a8 20		 test	 al, 32			; 00000020H
  000b2	75 4c		 jne	 SHORT $LN15@Pdata_clea
  000b4	84 c0		 test	 al, al
  000b6	78 48		 js	 SHORT $LN15@Pdata_clea
  000b8	a8 02		 test	 al, 2
  000ba	75 4c		 jne	 SHORT $LN3@Pdata_clea
  000bc	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000c0	75 46		 jne	 SHORT $LN3@Pdata_clea
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000d0	4c 8b cb	 mov	 r9, rbx
  000d3	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000d9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000e1	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e6	48 8b cb	 mov	 rcx, rbx
  000e9	85 c0		 test	 eax, eax
  000eb	74 07		 je	 SHORT $LN20@Pdata_clea
  000ed	e8 00 00 00 00	 call	 _Px_Dealloc
  000f2	eb 14		 jmp	 SHORT $LN3@Pdata_clea
$LN20@Pdata_clea:
  000f4	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000f8	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000fe	eb 08		 jmp	 SHORT $LN3@Pdata_clea
$LN15@Pdata_clea:
  00100	48 8b cb	 mov	 rcx, rbx
  00103	e8 00 00 00 00	 call	 Px_DecRef
$LN3@Pdata_clea:

; 201  : 
; 202  :     while (--i >= clearto) {

  00108	48 ff cf	 dec	 rdi
  0010b	48 3b fe	 cmp	 rdi, rsi
  0010e	0f 8d 4c ff ff
	ff		 jge	 $LL6@Pdata_clea
  00114	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  00119	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN5@Pdata_clea:

; 204  :     }
; 205  :     Py_SIZE(self) = clearto;

  0011e	48 89 75 60	 mov	 QWORD PTR [rbp+96], rsi
$LN23@Pdata_clea:

; 206  :     return 0;
; 207  : }

  00122	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00127	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0012c	33 c0		 xor	 eax, eax
  0012e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00132	5f		 pop	 rdi
  00133	c3		 ret	 0
Pdata_clear ENDP
_TEXT	ENDS
EXTRN	__imp_realloc:PROC
EXTRN	_PxMem_Realloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pdata_grow DD imagerel Pdata_grow
	DD	imagerel Pdata_grow+188
	DD	imagerel $unwind$Pdata_grow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pdata_grow DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT Pdata_grow
_TEXT	SEGMENT
self$ = 48
Pdata_grow PROC						; COMDAT

; 211  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 212  :     PyObject **data = self->data;
; 213  :     Py_ssize_t allocated = self->allocated;

  00014	48 8b 51 78	 mov	 rdx, QWORD PTR [rcx+120]
  00018	48 8b 71 70	 mov	 rsi, QWORD PTR [rcx+112]

; 214  :     Py_ssize_t new_allocated;
; 215  : 
; 216  :     new_allocated = (allocated >> 3) + 6;
; 217  :     /* check for integer overflow */
; 218  :     if (new_allocated > PY_SSIZE_T_MAX - allocated)

  0001c	48 bd ff ff ff
	ff ff ff ff 7f	 mov	 rbp, 9223372036854775807 ; 7fffffffffffffffH
  00026	48 8b da	 mov	 rbx, rdx
  00029	48 8b c5	 mov	 rax, rbp
  0002c	48 8b f9	 mov	 rdi, rcx
  0002f	48 c1 fb 03	 sar	 rbx, 3
  00033	48 2b c2	 sub	 rax, rdx
  00036	48 83 c3 06	 add	 rbx, 6
  0003a	48 3b d8	 cmp	 rbx, rax
  0003d	7f 60		 jg	 SHORT $nomemory$20406

; 219  :         goto nomemory;
; 220  :     new_allocated += allocated;

  0003f	48 03 da	 add	 rbx, rdx

; 221  :     if (new_allocated > (PY_SSIZE_T_MAX / sizeof(PyObject *)))

  00042	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  0004c	48 3b d8	 cmp	 rbx, rax
  0004f	77 4e		 ja	 SHORT $nomemory$20406

; 222  :         goto nomemory;
; 223  :     data = PyMem_REALLOC(data, new_allocated * sizeof(PyObject *));

  00051	e8 00 00 00 00	 call	 _Py_PXCTX
  00056	85 c0		 test	 eax, eax
  00058	74 12		 je	 SHORT $LN10@Pdata_grow
  0005a	48 8d 14 dd 00
	00 00 00	 lea	 rdx, QWORD PTR [rbx*8]
  00062	48 8b ce	 mov	 rcx, rsi
  00065	e8 00 00 00 00	 call	 _PxMem_Realloc
  0006a	eb 22		 jmp	 SHORT $LN9@Pdata_grow
$LN10@Pdata_grow:
  0006c	48 8d 04 dd 00
	00 00 00	 lea	 rax, QWORD PTR [rbx*8]
  00074	48 3b c5	 cmp	 rax, rbp
  00077	77 26		 ja	 SHORT $nomemory$20406
  00079	48 85 c0	 test	 rax, rax
  0007c	ba 01 00 00 00	 mov	 edx, 1
  00081	48 8b ce	 mov	 rcx, rsi
  00084	48 0f 45 d0	 cmovne	 rdx, rax
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
$LN9@Pdata_grow:

; 224  :     if (data == NULL)

  0008e	48 85 c0	 test	 rax, rax
  00091	74 0c		 je	 SHORT $nomemory$20406

; 225  :         goto nomemory;
; 226  : 
; 227  :     self->data = data;

  00093	48 89 47 70	 mov	 QWORD PTR [rdi+112], rax

; 228  :     self->allocated = new_allocated;

  00097	48 89 5f 78	 mov	 QWORD PTR [rdi+120], rbx

; 229  :     return 0;

  0009b	33 c0		 xor	 eax, eax
  0009d	eb 08		 jmp	 SHORT $LN4@Pdata_grow
$nomemory$20406:

; 230  : 
; 231  :   nomemory:
; 232  :     PyErr_NoMemory();

  0009f	e8 00 00 00 00	 call	 PyErr_NoMemory

; 233  :     return -1;

  000a4	83 c8 ff	 or	 eax, -1
$LN4@Pdata_grow:

; 234  : }

  000a7	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ac	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000b1	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000b6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
Pdata_grow ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@CAKEIMA@bad?5pickle?5data?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pdata_pop DD imagerel Pdata_pop
	DD	imagerel Pdata_pop+62
	DD	imagerel $unwind$Pdata_pop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pdata_pop DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BA@CAKEIMA@bad?5pickle?5data?$AA@
CONST	SEGMENT
??_C@_0BA@CAKEIMA@bad?5pickle?5data?$AA@ DB 'bad pickle data', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT Pdata_pop
_TEXT	SEGMENT
self$ = 48
Pdata_pop PROC						; COMDAT

; 242  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b c1	 mov	 rax, rcx

; 243  :     if (Py_SIZE(self) == 0) {

  00007	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0000b	48 85 c9	 test	 rcx, rcx
  0000e	75 1a		 jne	 SHORT $LN1@Pdata_pop

; 244  :         PyErr_SetString(UnpicklingError, "bad pickle data");

  00010	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@CAKEIMA@bad?5pickle?5data?$AA@
  0001e	e8 00 00 00 00	 call	 PyErr_SetString

; 245  :         return NULL;

  00023	33 c0		 xor	 eax, eax

; 248  : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
$LN1@Pdata_pop:

; 246  :     }
; 247  :     return self->data[--Py_SIZE(self)];

  0002a	48 ff c9	 dec	 rcx
  0002d	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx
  00031	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00035	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]

; 248  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
Pdata_pop ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pdata_push DD imagerel Pdata_push
	DD	imagerel Pdata_push+78
	DD	imagerel $unwind$Pdata_push
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pdata_push DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT Pdata_push
_TEXT	SEGMENT
self$ = 48
obj$ = 56
Pdata_push PROC						; COMDAT

; 253  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 254  :     if (Py_SIZE(self) == self->allocated && Pdata_grow(self) < 0) {

  0000a	48 8b 41 78	 mov	 rax, QWORD PTR [rcx+120]
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  00018	75 17		 jne	 SHORT $LN1@Pdata_push
  0001a	e8 00 00 00 00	 call	 Pdata_grow
  0001f	85 c0		 test	 eax, eax
  00021	79 0e		 jns	 SHORT $LN1@Pdata_push

; 255  :         return -1;

  00023	83 c8 ff	 or	 eax, -1

; 258  :     return 0;
; 259  : }

  00026	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5f		 pop	 rdi
  00030	c3		 ret	 0
$LN1@Pdata_push:

; 256  :     }
; 257  :     self->data[Py_SIZE(self)++] = obj;

  00031	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00035	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  00039	48 89 3c c8	 mov	 QWORD PTR [rax+rcx*8], rdi
  0003d	48 ff 43 60	 inc	 QWORD PTR [rbx+96]

; 258  :     return 0;
; 259  : }

  00041	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00046	33 c0		 xor	 eax, eax
  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5f		 pop	 rdi
  0004d	c3		 ret	 0
Pdata_push ENDP
_TEXT	ENDS
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pdata_poptuple DD imagerel Pdata_poptuple
	DD	imagerel Pdata_poptuple+142
	DD	imagerel $unwind$Pdata_poptuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pdata_poptuple DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT Pdata_poptuple
_TEXT	SEGMENT
self$ = 48
start$ = 56
Pdata_poptuple PROC					; COMDAT

; 272  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 273  :     PyObject *tuple;
; 274  :     Py_ssize_t len, i, j;
; 275  : 
; 276  :     len = Py_SIZE(self) - start;

  0000f	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  00013	48 8b f9	 mov	 rdi, rcx
  00016	48 8b f2	 mov	 rsi, rdx
  00019	48 2b da	 sub	 rbx, rdx

; 277  :     tuple = PyTuple_New(len);

  0001c	48 8b cb	 mov	 rcx, rbx
  0001f	e8 00 00 00 00	 call	 PyTuple_New
  00024	4c 8b d8	 mov	 r11, rax

; 278  :     if (tuple == NULL)

  00027	48 85 c0	 test	 rax, rax
  0002a	75 10		 jne	 SHORT $LN4@Pdata_popt

; 282  : 
; 283  :     Py_SIZE(self) = start;
; 284  :     return tuple;
; 285  : }

  0002c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00031	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
$LN4@Pdata_popt:

; 279  :         return NULL;
; 280  :     for (i = start, j = 0; j < len; i++, j++)

  0003c	48 85 db	 test	 rbx, rbx
  0003f	7e 36		 jle	 SHORT $LN1@Pdata_popt
  00041	b8 0e 00 00 00	 mov	 eax, 14
  00046	48 8d 14 f5 00
	00 00 00	 lea	 rdx, QWORD PTR [rsi*8]
  0004e	48 2b c6	 sub	 rax, rsi
  00051	4d 8d 04 c3	 lea	 r8, QWORD PTR [r11+rax*8]
  00055	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL3@Pdata_popt:

; 281  :         PyTuple_SET_ITEM(tuple, j, self->data[i]);

  00060	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  00064	48 83 c2 08	 add	 rdx, 8
  00068	48 ff cb	 dec	 rbx
  0006b	48 8b 4c 02 f8	 mov	 rcx, QWORD PTR [rdx+rax-8]
  00070	49 89 4c 10 f8	 mov	 QWORD PTR [r8+rdx-8], rcx
  00075	75 e9		 jne	 SHORT $LL3@Pdata_popt
$LN1@Pdata_popt:

; 282  : 
; 283  :     Py_SIZE(self) = start;
; 284  :     return tuple;
; 285  : }

  00077	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007c	48 89 77 60	 mov	 QWORD PTR [rdi+96], rsi
  00080	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00085	49 8b c3	 mov	 rax, r11
  00088	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008c	5f		 pop	 rdi
  0008d	c3		 ret	 0
Pdata_poptuple ENDP
_TEXT	ENDS
EXTRN	PyList_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pdata_poplist DD imagerel Pdata_poplist
	DD	imagerel Pdata_poplist+133
	DD	imagerel $unwind$Pdata_poplist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pdata_poplist DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT Pdata_poplist
_TEXT	SEGMENT
self$ = 48
start$ = 56
Pdata_poplist PROC					; COMDAT

; 289  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 290  :     PyObject *list;
; 291  :     Py_ssize_t len, i, j;
; 292  : 
; 293  :     len = Py_SIZE(self) - start;

  0000f	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  00013	48 8b f1	 mov	 rsi, rcx
  00016	48 8b fa	 mov	 rdi, rdx
  00019	48 2b da	 sub	 rbx, rdx

; 294  :     list = PyList_New(len);

  0001c	48 8b cb	 mov	 rcx, rbx
  0001f	e8 00 00 00 00	 call	 PyList_New
  00024	4c 8b d8	 mov	 r11, rax

; 295  :     if (list == NULL)

  00027	48 85 c0	 test	 rax, rax
  0002a	75 10		 jne	 SHORT $LN4@Pdata_popl

; 299  : 
; 300  :     Py_SIZE(self) = start;
; 301  :     return list;
; 302  : }

  0002c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00031	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
$LN4@Pdata_popl:

; 296  :         return NULL;
; 297  :     for (i = start, j = 0; j < len; i++, j++)

  0003c	33 d2		 xor	 edx, edx
  0003e	48 85 db	 test	 rbx, rbx
  00041	7e 2b		 jle	 SHORT $LN1@Pdata_popl
  00043	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL3@Pdata_popl:

; 298  :         PyList_SET_ITEM(list, j, self->data[i]);

  00050	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  00054	49 8b 4b 70	 mov	 rcx, QWORD PTR [r11+112]
  00058	48 ff c2	 inc	 rdx
  0005b	48 8d 04 f8	 lea	 rax, QWORD PTR [rax+rdi*8]
  0005f	48 8b 44 d0 f8	 mov	 rax, QWORD PTR [rax+rdx*8-8]
  00064	48 89 44 d1 f8	 mov	 QWORD PTR [rcx+rdx*8-8], rax
  00069	48 3b d3	 cmp	 rdx, rbx
  0006c	7c e2		 jl	 SHORT $LL3@Pdata_popl
$LN1@Pdata_popl:

; 299  : 
; 300  :     Py_SIZE(self) = start;
; 301  :     return list;
; 302  : }

  0006e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00073	48 89 7e 60	 mov	 QWORD PTR [rsi+96], rdi
  00077	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007c	49 8b c3	 mov	 rax, r11
  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
Pdata_poplist ENDP
_TEXT	ENDS
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMemoTable_New DD imagerel PyMemoTable_New
	DD	imagerel PyMemoTable_New+174
	DD	imagerel $unwind$PyMemoTable_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoTable_New DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyMemoTable_New
_TEXT	SEGMENT
PyMemoTable_New PROC					; COMDAT

; 401  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 402  :     PyMemoTable *memo = PyMem_MALLOC(sizeof(PyMemoTable));

  00006	e8 00 00 00 00	 call	 _Py_PXCTX
  0000b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00010	85 c0		 test	 eax, eax
  00012	74 07		 je	 SHORT $LN5@PyMemoTabl
  00014	e8 00 00 00 00	 call	 _PxMem_Malloc
  00019	eb 06		 jmp	 SHORT $LN11@PyMemoTabl
$LN5@PyMemoTabl:
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN11@PyMemoTabl:
  00021	48 8b d8	 mov	 rbx, rax

; 403  :     if (memo == NULL) {

  00024	48 85 c0	 test	 rax, rax

; 404  :         PyErr_NoMemory();
; 405  :         return NULL;

  00027	74 5f		 je	 SHORT $LN10@PyMemoTabl

; 406  :     }
; 407  : 
; 408  :     memo->mt_used = 0;

  00029	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 409  :     memo->mt_allocated = MT_MINSIZE;

  00031	48 c7 40 10 08
	00 00 00	 mov	 QWORD PTR [rax+16], 8

; 410  :     memo->mt_mask = MT_MINSIZE - 1;

  00039	48 c7 00 07 00
	00 00		 mov	 QWORD PTR [rax], 7

; 411  :     memo->mt_table = PyMem_MALLOC(MT_MINSIZE * sizeof(PyMemoEntry));

  00040	e8 00 00 00 00	 call	 _Py_PXCTX
  00045	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0004a	85 c0		 test	 eax, eax
  0004c	74 07		 je	 SHORT $LN7@PyMemoTabl
  0004e	e8 00 00 00 00	 call	 _PxMem_Malloc
  00053	eb 06		 jmp	 SHORT $LN8@PyMemoTabl
$LN7@PyMemoTabl:
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN8@PyMemoTabl:
  0005b	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax

; 412  :     if (memo->mt_table == NULL) {

  0005f	48 85 c0	 test	 rax, rax
  00062	75 31		 jne	 SHORT $LN1@PyMemoTabl

; 413  :         PyMem_FREE(memo);

  00064	e8 00 00 00 00	 call	 _Py_PXCTX
  00069	48 8b cb	 mov	 rcx, rbx
  0006c	85 c0		 test	 eax, eax
  0006e	74 12		 je	 SHORT $LN9@PyMemoTabl
  00070	e8 00 00 00 00	 call	 _PxMem_Free

; 414  :         PyErr_NoMemory();

  00075	e8 00 00 00 00	 call	 PyErr_NoMemory

; 415  :         return NULL;

  0007a	33 c0		 xor	 eax, eax

; 420  : }

  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	5b		 pop	 rbx
  00081	c3		 ret	 0
$LN9@PyMemoTabl:

; 413  :         PyMem_FREE(memo);

  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN10@PyMemoTabl:

; 414  :         PyErr_NoMemory();

  00088	e8 00 00 00 00	 call	 PyErr_NoMemory

; 415  :         return NULL;

  0008d	33 c0		 xor	 eax, eax

; 420  : }

  0008f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00093	5b		 pop	 rbx
  00094	c3		 ret	 0
$LN1@PyMemoTabl:

; 416  :     }
; 417  :     memset(memo->mt_table, 0, MT_MINSIZE * sizeof(PyMemoEntry));

  00095	33 d2		 xor	 edx, edx
  00097	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  0009d	48 8b c8	 mov	 rcx, rax
  000a0	e8 00 00 00 00	 call	 memset

; 418  : 
; 419  :     return memo;

  000a5	48 8b c3	 mov	 rax, rbx

; 420  : }

  000a8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ac	5b		 pop	 rbx
  000ad	c3		 ret	 0
PyMemoTable_New ENDP
_TEXT	ENDS
EXTRN	memcpy:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyMemoTable_Copy DD imagerel PyMemoTable_Copy
	DD	imagerel PyMemoTable_Copy+41
	DD	imagerel $unwind$PyMemoTable_Copy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyMemoTable_Copy DD imagerel PyMemoTable_Copy+41
	DD	imagerel PyMemoTable_Copy+206
	DD	imagerel $chain$0$PyMemoTable_Copy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyMemoTable_Copy DD imagerel PyMemoTable_Copy+206
	DD	imagerel PyMemoTable_Copy+230
	DD	imagerel $chain$2$PyMemoTable_Copy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyMemoTable_Copy DD imagerel PyMemoTable_Copy+230
	DD	imagerel PyMemoTable_Copy+236
	DD	imagerel $chain$4$PyMemoTable_Copy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$PyMemoTable_Copy DD imagerel PyMemoTable_Copy+236
	DD	imagerel PyMemoTable_Copy+351
	DD	imagerel $chain$6$PyMemoTable_Copy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$PyMemoTable_Copy DD imagerel PyMemoTable_Copy+351
	DD	imagerel PyMemoTable_Copy+391
	DD	imagerel $chain$7$PyMemoTable_Copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$PyMemoTable_Copy DD 021H
	DD	imagerel PyMemoTable_Copy+230
	DD	imagerel PyMemoTable_Copy+236
	DD	imagerel $chain$4$PyMemoTable_Copy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$PyMemoTable_Copy DD 040a21H
	DD	0ac40aH
	DD	097405H
	DD	imagerel PyMemoTable_Copy+230
	DD	imagerel PyMemoTable_Copy+236
	DD	imagerel $chain$4$PyMemoTable_Copy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyMemoTable_Copy DD 020021H
	DD	085400H
	DD	imagerel PyMemoTable_Copy
	DD	imagerel PyMemoTable_Copy+41
	DD	imagerel $unwind$PyMemoTable_Copy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyMemoTable_Copy DD 020021H
	DD	085400H
	DD	imagerel PyMemoTable_Copy
	DD	imagerel PyMemoTable_Copy+41
	DD	imagerel $unwind$PyMemoTable_Copy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyMemoTable_Copy DD 020521H
	DD	085405H
	DD	imagerel PyMemoTable_Copy
	DD	imagerel PyMemoTable_Copy+41
	DD	imagerel $unwind$PyMemoTable_Copy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoTable_Copy DD 040a01H
	DD	0b340aH
	DD	06006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT PyMemoTable_Copy
_TEXT	SEGMENT
self$ = 64
PyMemoTable_Copy PROC					; COMDAT

; 424  : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b d9	 mov	 rbx, rcx

; 425  :     Py_ssize_t i;
; 426  :     PyMemoTable *new = PyMemoTable_New();

  0000d	e8 00 00 00 00	 call	 PyMemoTable_New
  00012	48 8b f0	 mov	 rsi, rax

; 427  :     if (new == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0b		 jne	 SHORT $LN9@PyMemoTabl@2

; 446  : 
; 447  :     return new;
; 448  : }

  0001a	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0001f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00023	5e		 pop	 rsi
  00024	c3		 ret	 0
$LN9@PyMemoTabl@2:

; 428  :         return NULL;
; 429  : 
; 430  :     new->mt_used = self->mt_used;

  00025	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00029	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  0002e	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax

; 431  :     new->mt_allocated = self->mt_allocated;

  00032	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00036	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax

; 432  :     new->mt_mask = self->mt_mask;

  0003a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003d	48 89 06	 mov	 QWORD PTR [rsi], rax

; 433  :     /* The table we get from _New() is probably smaller than we wanted.
; 434  :        Free it and allocate one that's the right size. */
; 435  :     PyMem_FREE(new->mt_table);

  00040	e8 00 00 00 00	 call	 _Py_PXCTX
  00045	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  00049	85 c0		 test	 eax, eax
  0004b	74 07		 je	 SHORT $LN12@PyMemoTabl@2
  0004d	e8 00 00 00 00	 call	 _PxMem_Free
  00052	eb 06		 jmp	 SHORT $LN13@PyMemoTabl@2
$LN12@PyMemoTabl@2:
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN13@PyMemoTabl@2:

; 436  :     new->mt_table = PyMem_MALLOC(self->mt_allocated * sizeof(PyMemoEntry));

  0005a	e8 00 00 00 00	 call	 _Py_PXCTX
  0005f	33 ed		 xor	 ebp, ebp
  00061	85 c0		 test	 eax, eax
  00063	74 0f		 je	 SHORT $LN18@PyMemoTabl@2
  00065	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00069	48 c1 e1 04	 shl	 rcx, 4
  0006d	e8 00 00 00 00	 call	 _PxMem_Malloc
  00072	eb 2e		 jmp	 SHORT $LN17@PyMemoTabl@2
$LN18@PyMemoTabl@2:
  00074	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00078	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00082	48 c1 e0 04	 shl	 rax, 4
  00086	48 3b c1	 cmp	 rax, rcx
  00089	76 05		 jbe	 SHORT $LN16@PyMemoTabl@2
  0008b	48 8b c5	 mov	 rax, rbp
  0008e	eb 12		 jmp	 SHORT $LN17@PyMemoTabl@2
$LN16@PyMemoTabl@2:
  00090	48 85 c0	 test	 rax, rax
  00093	b9 01 00 00 00	 mov	 ecx, 1
  00098	48 0f 45 c8	 cmovne	 rcx, rax
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN17@PyMemoTabl@2:
  000a2	48 89 46 18	 mov	 QWORD PTR [rsi+24], rax

; 437  :     if (new->mt_table == NULL) {

  000a6	48 85 c0	 test	 rax, rax
  000a9	75 3b		 jne	 SHORT $LN8@PyMemoTabl@2

; 438  :         PyMem_FREE(new);

  000ab	e8 00 00 00 00	 call	 _Py_PXCTX
  000b0	48 8b ce	 mov	 rcx, rsi
  000b3	85 c0		 test	 eax, eax
  000b5	74 17		 je	 SHORT $LN20@PyMemoTabl@2
  000b7	e8 00 00 00 00	 call	 _PxMem_Free
  000bc	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 439  :         return NULL;

  000c1	33 c0		 xor	 eax, eax

; 446  : 
; 447  :     return new;
; 448  : }

  000c3	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000c8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cc	5e		 pop	 rsi
  000cd	c3		 ret	 0
$LN20@PyMemoTabl@2:

; 438  :         PyMem_FREE(new);

  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  000d4	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 439  :         return NULL;

  000d9	33 c0		 xor	 eax, eax

; 446  : 
; 447  :     return new;
; 448  : }

  000db	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000e0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e4	5e		 pop	 rsi
  000e5	c3		 ret	 0
$LN8@PyMemoTabl@2:

; 440  :     }
; 441  :     for (i = 0; i < self->mt_allocated; i++) {

  000e6	48 39 6b 10	 cmp	 QWORD PTR [rbx+16], rbp
  000ea	7e 73		 jle	 SHORT $LN5@PyMemoTabl@2
  000ec	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  000f1	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  000f6	4c 8b e5	 mov	 r12, rbp
  000f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@PyMemoTabl@2:

; 442  :         Py_XINCREF(self->mt_table[i].me_key);

  00100	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  00104	49 8b 3c 04	 mov	 rdi, QWORD PTR [r12+rax]
  00108	48 85 ff	 test	 rdi, rdi
  0010b	74 3b		 je	 SHORT $LN3@PyMemoTabl@2
  0010d	e8 00 00 00 00	 call	 _Py_PXCTX
  00112	85 c0		 test	 eax, eax
  00114	75 32		 jne	 SHORT $LN3@PyMemoTabl@2
  00116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00124	4c 8b cf	 mov	 r9, rdi
  00127	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0012d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00135	e8 00 00 00 00	 call	 _PyParallel_Guard
  0013a	85 c0		 test	 eax, eax
  0013c	75 06		 jne	 SHORT $LN22@PyMemoTabl@2
  0013e	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00142	74 04		 je	 SHORT $LN3@PyMemoTabl@2
$LN22@PyMemoTabl@2:
  00144	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN3@PyMemoTabl@2:

; 440  :     }
; 441  :     for (i = 0; i < self->mt_allocated; i++) {

  00148	48 ff c5	 inc	 rbp
  0014b	49 83 c4 10	 add	 r12, 16
  0014f	48 3b 6b 10	 cmp	 rbp, QWORD PTR [rbx+16]
  00153	7c ab		 jl	 SHORT $LL7@PyMemoTabl@2
  00155	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  0015a	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
$LN5@PyMemoTabl@2:

; 443  :     }
; 444  :     memcpy(new->mt_table, self->mt_table,
; 445  :            sizeof(PyMemoEntry) * self->mt_allocated);

  0015f	4c 8b 43 10	 mov	 r8, QWORD PTR [rbx+16]
  00163	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00167	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  0016b	49 c1 e0 04	 shl	 r8, 4
  0016f	e8 00 00 00 00	 call	 memcpy
  00174	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 446  : 
; 447  :     return new;
; 448  : }

  00179	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0017e	48 8b c6	 mov	 rax, rsi
  00181	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00185	5e		 pop	 rsi
  00186	c3		 ret	 0
PyMemoTable_Copy ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT PyMemoTable_Size
_TEXT	SEGMENT
self$ = 8
PyMemoTable_Size PROC					; COMDAT

; 453  :     return self->mt_used;

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 454  : }

  00004	c3		 ret	 0
PyMemoTable_Size ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyMemoTable_Clear DD imagerel PyMemoTable_Clear
	DD	imagerel PyMemoTable_Clear+26
	DD	imagerel $unwind$PyMemoTable_Clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyMemoTable_Clear DD imagerel PyMemoTable_Clear+26
	DD	imagerel PyMemoTable_Clear+181
	DD	imagerel $chain$1$PyMemoTable_Clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyMemoTable_Clear DD imagerel PyMemoTable_Clear+181
	DD	imagerel PyMemoTable_Clear+221
	DD	imagerel $chain$2$PyMemoTable_Clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyMemoTable_Clear DD 021H
	DD	imagerel PyMemoTable_Clear
	DD	imagerel PyMemoTable_Clear+26
	DD	imagerel $unwind$PyMemoTable_Clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyMemoTable_Clear DD 040a21H
	DD	09640aH
	DD	083405H
	DD	imagerel PyMemoTable_Clear
	DD	imagerel PyMemoTable_Clear+26
	DD	imagerel $unwind$PyMemoTable_Clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoTable_Clear DD 040a01H
	DD	0a540aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT PyMemoTable_Clear
_TEXT	SEGMENT
self$ = 64
PyMemoTable_Clear PROC					; COMDAT

; 458  : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 460  : 
; 461  :     while (--i >= 0) {

  0000a	48 8b 79 10	 mov	 rdi, QWORD PTR [rcx+16]
  0000e	48 8b e9	 mov	 rbp, rcx
  00011	48 ff cf	 dec	 rdi
  00014	0f 88 9b 00 00
	00		 js	 $LN5@PyMemoTabl@3

; 459  :     Py_ssize_t i = self->mt_allocated;

  0001a	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0001f	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00024	48 8b f7	 mov	 rsi, rdi
  00027	48 c1 e6 04	 shl	 rsi, 4
  0002b	0f 1f 44 00 00	 npad	 5
$LL6@PyMemoTabl@3:

; 462  :         Py_XDECREF(self->mt_table[i].me_key);

  00030	48 8b 45 18	 mov	 rax, QWORD PTR [rbp+24]
  00034	48 8b 1c 06	 mov	 rbx, QWORD PTR [rsi+rax]
  00038	48 85 db	 test	 rbx, rbx
  0003b	74 65		 je	 SHORT $LN3@PyMemoTabl@3
  0003d	e8 00 00 00 00	 call	 _Py_PXCTX
  00042	85 c0		 test	 eax, eax
  00044	75 5c		 jne	 SHORT $LN3@PyMemoTabl@3
  00046	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0004a	a8 20		 test	 al, 32			; 00000020H
  0004c	75 4c		 jne	 SHORT $LN13@PyMemoTabl@3
  0004e	84 c0		 test	 al, al
  00050	78 48		 js	 SHORT $LN13@PyMemoTabl@3
  00052	a8 02		 test	 al, 2
  00054	75 4c		 jne	 SHORT $LN3@PyMemoTabl@3
  00056	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0005a	75 46		 jne	 SHORT $LN3@PyMemoTabl@3
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0006a	4c 8b cb	 mov	 r9, rbx
  0006d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00073	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0007b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00080	48 8b cb	 mov	 rcx, rbx
  00083	85 c0		 test	 eax, eax
  00085	74 07		 je	 SHORT $LN18@PyMemoTabl@3
  00087	e8 00 00 00 00	 call	 _Px_Dealloc
  0008c	eb 14		 jmp	 SHORT $LN3@PyMemoTabl@3
$LN18@PyMemoTabl@3:
  0008e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00092	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00098	eb 08		 jmp	 SHORT $LN3@PyMemoTabl@3
$LN13@PyMemoTabl@3:
  0009a	48 8b cb	 mov	 rcx, rbx
  0009d	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PyMemoTabl@3:

; 460  : 
; 461  :     while (--i >= 0) {

  000a2	48 83 ee 10	 sub	 rsi, 16
  000a6	48 ff cf	 dec	 rdi
  000a9	79 85		 jns	 SHORT $LL6@PyMemoTabl@3
  000ab	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN5@PyMemoTabl@3:

; 463  :     }
; 464  :     self->mt_used = 0;
; 465  :     memset(self->mt_table, 0, self->mt_allocated * sizeof(PyMemoEntry));

  000b5	4c 8b 45 10	 mov	 r8, QWORD PTR [rbp+16]
  000b9	48 8b 4d 18	 mov	 rcx, QWORD PTR [rbp+24]
  000bd	33 d2		 xor	 edx, edx
  000bf	49 c1 e0 04	 shl	 r8, 4
  000c3	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR [rbp+8], 0
  000cb	e8 00 00 00 00	 call	 memset

; 466  :     return 0;
; 467  : }

  000d0	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000d5	33 c0		 xor	 eax, eax
  000d7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000db	5f		 pop	 rdi
  000dc	c3		 ret	 0
PyMemoTable_Clear ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMemoTable_Del DD imagerel PyMemoTable_Del
	DD	imagerel PyMemoTable_Del+79
	DD	imagerel $unwind$PyMemoTable_Del
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoTable_Del DD 020a01H
	DD	03006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyMemoTable_Del
_TEXT	SEGMENT
self$ = 48
PyMemoTable_Del PROC					; COMDAT

; 472  :     if (self == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 48		 je	 SHORT $LN8@PyMemoTabl@4
  00005	53		 push	 rbx
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 471  : {

  0000a	48 8b d9	 mov	 rbx, rcx

; 473  :         return;
; 474  :     PyMemoTable_Clear(self);

  0000d	e8 00 00 00 00	 call	 PyMemoTable_Clear

; 475  : 
; 476  :     PyMem_FREE(self->mt_table);

  00012	e8 00 00 00 00	 call	 _Py_PXCTX
  00017	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  0001b	85 c0		 test	 eax, eax
  0001d	74 07		 je	 SHORT $LN4@PyMemoTabl@4
  0001f	e8 00 00 00 00	 call	 _PxMem_Free
  00024	eb 06		 jmp	 SHORT $LN5@PyMemoTabl@4
$LN4@PyMemoTabl@4:
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@PyMemoTabl@4:

; 477  :     PyMem_FREE(self);

  0002c	e8 00 00 00 00	 call	 _Py_PXCTX
  00031	48 8b cb	 mov	 rcx, rbx
  00034	85 c0		 test	 eax, eax
  00036	74 0a		 je	 SHORT $LN6@PyMemoTabl@4

; 478  : }

  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5b		 pop	 rbx
  0003d	e9 00 00 00 00	 jmp	 _PxMem_Free
$LN6@PyMemoTabl@4:

; 477  :     PyMem_FREE(self);

  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 478  : }

  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5b		 pop	 rbx
$LN8@PyMemoTabl@4:
  0004d	f3 c3		 fatret	 0
PyMemoTable_Del ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _PyMemoTable_Lookup
_TEXT	SEGMENT
self$ = 8
key$ = 16
_PyMemoTable_Lookup PROC				; COMDAT

; 485  :     size_t i;
; 486  :     size_t perturb;
; 487  :     size_t mask = (size_t)self->mt_mask;

  00000	4c 8b 11	 mov	 r10, QWORD PTR [rcx]

; 488  :     PyMemoEntry *table = self->mt_table;

  00003	4c 8b 59 18	 mov	 r11, QWORD PTR [rcx+24]

; 489  :     PyMemoEntry *entry;
; 490  :     Py_hash_t hash = (Py_hash_t)key >> 3;

  00007	4c 8b ca	 mov	 r9, rdx
  0000a	49 c1 f9 03	 sar	 r9, 3

; 491  : 
; 492  :     i = hash & mask;

  0000e	4d 8b c1	 mov	 r8, r9
  00011	4d 23 c2	 and	 r8, r10

; 493  :     entry = &table[i];

  00014	49 8b c0	 mov	 rax, r8
  00017	48 c1 e0 04	 shl	 rax, 4
  0001b	49 03 c3	 add	 rax, r11

; 494  :     if (entry->me_key == NULL || entry->me_key == key)

  0001e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00021	48 85 c9	 test	 rcx, rcx
  00024	74 51		 je	 SHORT $LN6@PyMemoTabl@5
  00026	48 3b ca	 cmp	 rcx, rdx
  00029	74 4c		 je	 SHORT $LN6@PyMemoTabl@5

; 495  :         return entry;
; 496  : 
; 497  :     for (perturb = hash; ; perturb >>= PERTURB_SHIFT) {
; 498  :         i = (i << 2) + i + perturb + 1;

  0002b	4b 8d 04 81	 lea	 rax, QWORD PTR [r9+r8*4]
  0002f	4d 8d 44 00 01	 lea	 r8, QWORD PTR [r8+rax+1]

; 499  :         entry = &table[i & mask];

  00034	49 8b c0	 mov	 rax, r8
  00037	49 23 c2	 and	 rax, r10
  0003a	48 c1 e0 04	 shl	 rax, 4
  0003e	49 03 c3	 add	 rax, r11

; 500  :         if (entry->me_key == NULL || entry->me_key == key)

  00041	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00044	48 85 c9	 test	 rcx, rcx
  00047	74 2e		 je	 SHORT $LN6@PyMemoTabl@5
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@PyMemoTabl@5:
  00050	48 3b ca	 cmp	 rcx, rdx
  00053	74 22		 je	 SHORT $LN6@PyMemoTabl@5

; 495  :         return entry;
; 496  : 
; 497  :     for (perturb = hash; ; perturb >>= PERTURB_SHIFT) {
; 498  :         i = (i << 2) + i + perturb + 1;

  00055	49 c1 e9 05	 shr	 r9, 5
  00059	4b 8d 04 81	 lea	 rax, QWORD PTR [r9+r8*4]
  0005d	4d 8d 44 00 01	 lea	 r8, QWORD PTR [r8+rax+1]

; 499  :         entry = &table[i & mask];

  00062	49 8b c0	 mov	 rax, r8
  00065	49 23 c2	 and	 rax, r10
  00068	48 c1 e0 04	 shl	 rax, 4
  0006c	49 03 c3	 add	 rax, r11

; 500  :         if (entry->me_key == NULL || entry->me_key == key)

  0006f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00072	48 85 c9	 test	 rcx, rcx
  00075	75 d9		 jne	 SHORT $LL5@PyMemoTabl@5
$LN6@PyMemoTabl@5:

; 501  :             return entry;
; 502  :     }
; 503  :     assert(0);  /* Never reached */
; 504  :     return NULL;
; 505  : }

  00077	f3 c3		 fatret	 0
_PyMemoTable_Lookup ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyMemoTable_ResizeTable DD imagerel _PyMemoTable_ResizeTable
	DD	imagerel _PyMemoTable_ResizeTable+313
	DD	imagerel $unwind$_PyMemoTable_ResizeTable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyMemoTable_ResizeTable DD 084a01H
	DD	07744aH
	DD	066441H
	DD	08340aH
	DD	05006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyMemoTable_ResizeTable
_TEXT	SEGMENT
self$ = 48
min_size$ = 56
_PyMemoTable_ResizeTable PROC				; COMDAT

; 510  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 511  :     PyMemoEntry *oldtable = NULL;
; 512  :     PyMemoEntry *oldentry, *newentry;
; 513  :     Py_ssize_t new_size = MT_MINSIZE;

  0000a	bb 08 00 00 00	 mov	 ebx, 8
  0000f	48 8b e9	 mov	 rbp, rcx

; 514  :     Py_ssize_t to_process;
; 515  : 
; 516  :     assert(min_size > 0);
; 517  : 
; 518  :     /* Find the smallest valid table size >= min_size. */
; 519  :     while (new_size < min_size && new_size > 0)

  00012	48 3b da	 cmp	 rbx, rdx
  00015	7d 25		 jge	 SHORT $LN6@PyMemoTabl@6
$LL8@PyMemoTabl@6:
  00017	48 85 db	 test	 rbx, rbx
  0001a	7e 0d		 jle	 SHORT $LN25@PyMemoTabl@6

; 520  :         new_size <<= 1;

  0001c	48 03 db	 add	 rbx, rbx
  0001f	48 3b da	 cmp	 rbx, rdx
  00022	7c f3		 jl	 SHORT $LL8@PyMemoTabl@6

; 521  :     if (new_size <= 0) {

  00024	48 85 db	 test	 rbx, rbx
  00027	7f 13		 jg	 SHORT $LN6@PyMemoTabl@6
$LN25@PyMemoTabl@6:

; 522  :         PyErr_NoMemory();

  00029	e8 00 00 00 00	 call	 PyErr_NoMemory

; 523  :         return -1;

  0002e	83 c8 ff	 or	 eax, -1

; 557  : }

  00031	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5d		 pop	 rbp
  0003b	c3		 ret	 0
$LN6@PyMemoTabl@6:
  0003c	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi

; 524  :     }
; 525  :     /* new_size needs to be a power of two. */
; 526  :     assert((new_size & (new_size - 1)) == 0);
; 527  : 
; 528  :     /* Allocate new table. */
; 529  :     oldtable = self->mt_table;

  00041	48 8b 71 18	 mov	 rsi, QWORD PTR [rcx+24]
  00045	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 530  :     self->mt_table = PyMem_MALLOC(new_size * sizeof(PyMemoEntry));

  0004a	e8 00 00 00 00	 call	 _Py_PXCTX
  0004f	48 8b fb	 mov	 rdi, rbx
  00052	48 c1 e7 04	 shl	 rdi, 4
  00056	85 c0		 test	 eax, eax
  00058	74 0a		 je	 SHORT $LN15@PyMemoTabl@6
  0005a	48 8b cf	 mov	 rcx, rdi
  0005d	e8 00 00 00 00	 call	 _PxMem_Malloc
  00062	eb 25		 jmp	 SHORT $LN28@PyMemoTabl@6
$LN15@PyMemoTabl@6:
  00064	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0006e	48 3b f8	 cmp	 rdi, rax
  00071	76 04		 jbe	 SHORT $LN13@PyMemoTabl@6
  00073	33 c9		 xor	 ecx, ecx
  00075	eb 15		 jmp	 SHORT $LN14@PyMemoTabl@6
$LN13@PyMemoTabl@6:
  00077	48 85 ff	 test	 rdi, rdi
  0007a	b9 01 00 00 00	 mov	 ecx, 1
  0007f	48 0f 45 cf	 cmovne	 rcx, rdi
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN28@PyMemoTabl@6:
  00089	48 8b c8	 mov	 rcx, rax
$LN14@PyMemoTabl@6:
  0008c	48 89 4d 18	 mov	 QWORD PTR [rbp+24], rcx

; 531  :     if (self->mt_table == NULL) {

  00090	48 85 c9	 test	 rcx, rcx
  00093	75 2b		 jne	 SHORT $LN5@PyMemoTabl@6

; 532  :         PyMem_FREE(oldtable);

  00095	e8 00 00 00 00	 call	 _Py_PXCTX
  0009a	48 8b ce	 mov	 rcx, rsi
  0009d	85 c0		 test	 eax, eax
  0009f	74 0f		 je	 SHORT $LN17@PyMemoTabl@6
  000a1	e8 00 00 00 00	 call	 _PxMem_Free

; 533  :         PyErr_NoMemory();

  000a6	e8 00 00 00 00	 call	 PyErr_NoMemory

; 534  :         return -1;

  000ab	83 c8 ff	 or	 eax, -1
  000ae	eb 74		 jmp	 SHORT $LN27@PyMemoTabl@6
$LN17@PyMemoTabl@6:

; 532  :         PyMem_FREE(oldtable);

  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 533  :         PyErr_NoMemory();

  000b6	e8 00 00 00 00	 call	 PyErr_NoMemory

; 534  :         return -1;

  000bb	83 c8 ff	 or	 eax, -1
  000be	eb 64		 jmp	 SHORT $LN27@PyMemoTabl@6
$LN5@PyMemoTabl@6:

; 535  :     }
; 536  :     self->mt_allocated = new_size;
; 537  :     self->mt_mask = new_size - 1;

  000c0	48 8d 43 ff	 lea	 rax, QWORD PTR [rbx-1]

; 538  :     memset(self->mt_table, 0, sizeof(PyMemoEntry) * new_size);

  000c4	4c 8b c7	 mov	 r8, rdi
  000c7	33 d2		 xor	 edx, edx
  000c9	48 89 45 00	 mov	 QWORD PTR [rbp], rax
  000cd	48 89 5d 10	 mov	 QWORD PTR [rbp+16], rbx
  000d1	e8 00 00 00 00	 call	 memset

; 539  : 
; 540  :     /* Copy entries from the old table. */
; 541  :     to_process = self->mt_used;

  000d6	48 8b 7d 08	 mov	 rdi, QWORD PTR [rbp+8]

; 542  :     for (oldentry = oldtable; to_process > 0; oldentry++) {

  000da	48 8b de	 mov	 rbx, rsi
  000dd	48 85 ff	 test	 rdi, rdi
  000e0	7e 27		 jle	 SHORT $LN2@PyMemoTabl@6
$LL4@PyMemoTabl@6:

; 543  :         if (oldentry->me_key != NULL) {

  000e2	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  000e5	48 85 d2	 test	 rdx, rdx
  000e8	74 16		 je	 SHORT $LN3@PyMemoTabl@6

; 544  :             to_process--;
; 545  :             /* newentry is a pointer to a chunk of the new
; 546  :                mt_table, so we're setting the key:value pair
; 547  :                in-place. */
; 548  :             newentry = _PyMemoTable_Lookup(self, oldentry->me_key);

  000ea	48 8b cd	 mov	 rcx, rbp
  000ed	48 ff cf	 dec	 rdi
  000f0	e8 00 00 00 00	 call	 _PyMemoTable_Lookup

; 549  :             newentry->me_key = oldentry->me_key;

  000f5	48 89 10	 mov	 QWORD PTR [rax], rdx

; 550  :             newentry->me_value = oldentry->me_value;

  000f8	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  000fc	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN3@PyMemoTabl@6:

; 542  :     for (oldentry = oldtable; to_process > 0; oldentry++) {

  00100	48 83 c3 10	 add	 rbx, 16
  00104	48 85 ff	 test	 rdi, rdi
  00107	7f d9		 jg	 SHORT $LL4@PyMemoTabl@6
$LN2@PyMemoTabl@6:

; 551  :         }
; 552  :     }
; 553  : 
; 554  :     /* Deallocate the old table. */
; 555  :     PyMem_FREE(oldtable);

  00109	e8 00 00 00 00	 call	 _Py_PXCTX
  0010e	48 8b ce	 mov	 rcx, rsi
  00111	85 c0		 test	 eax, eax
  00113	74 07		 je	 SHORT $LN19@PyMemoTabl@6
  00115	e8 00 00 00 00	 call	 _PxMem_Free
  0011a	eb 06		 jmp	 SHORT $LN20@PyMemoTabl@6
$LN19@PyMemoTabl@6:
  0011c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN20@PyMemoTabl@6:

; 556  :     return 0;

  00122	33 c0		 xor	 eax, eax
$LN27@PyMemoTabl@6:
  00124	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00129	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 557  : }

  0012e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00133	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00137	5d		 pop	 rbp
  00138	c3		 ret	 0
_PyMemoTable_ResizeTable ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMemoTable_Get DD imagerel PyMemoTable_Get
	DD	imagerel PyMemoTable_Get+31
	DD	imagerel $unwind$PyMemoTable_Get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoTable_Get DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyMemoTable_Get
_TEXT	SEGMENT
self$ = 48
key$ = 56
PyMemoTable_Get PROC					; COMDAT

; 562  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 563  :     PyMemoEntry *entry = _PyMemoTable_Lookup(self, key);

  00004	e8 00 00 00 00	 call	 _PyMemoTable_Lookup

; 564  :     if (entry->me_key == NULL)

  00009	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0000d	75 07		 jne	 SHORT $LN1@PyMemoTabl@7

; 565  :         return NULL;

  0000f	33 c0		 xor	 eax, eax

; 567  : }

  00011	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00015	c3		 ret	 0
$LN1@PyMemoTabl@7:

; 566  :     return &entry->me_value;

  00016	48 83 c0 08	 add	 rax, 8

; 567  : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
PyMemoTable_Get ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyMemoTable_Set DD imagerel PyMemoTable_Set
	DD	imagerel PyMemoTable_Set+54
	DD	imagerel $unwind$PyMemoTable_Set
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyMemoTable_Set DD imagerel PyMemoTable_Set+54
	DD	imagerel PyMemoTable_Set+191
	DD	imagerel $chain$0$PyMemoTable_Set
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyMemoTable_Set DD imagerel PyMemoTable_Set+191
	DD	imagerel PyMemoTable_Set+212
	DD	imagerel $chain$1$PyMemoTable_Set
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyMemoTable_Set DD 021H
	DD	imagerel PyMemoTable_Set
	DD	imagerel PyMemoTable_Set+54
	DD	imagerel $unwind$PyMemoTable_Set
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyMemoTable_Set DD 020521H
	DD	08c405H
	DD	imagerel PyMemoTable_Set
	DD	imagerel PyMemoTable_Set+54
	DD	imagerel $unwind$PyMemoTable_Set
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoTable_Set DD 081401H
	DD	0b6414H
	DD	0a5414H
	DD	093414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT PyMemoTable_Set
_TEXT	SEGMENT
self$ = 64
key$ = 72
value$ = 80
PyMemoTable_Set PROC					; COMDAT

; 572  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	49 8b f0	 mov	 rsi, r8
  00017	48 8b da	 mov	 rbx, rdx
  0001a	48 8b e9	 mov	 rbp, rcx

; 573  :     PyMemoEntry *entry;
; 574  : 
; 575  :     assert(key != NULL);
; 576  : 
; 577  :     entry = _PyMemoTable_Lookup(self, key);

  0001d	e8 00 00 00 00	 call	 _PyMemoTable_Lookup
  00022	48 8b f8	 mov	 rdi, rax

; 578  :     if (entry->me_key != NULL) {

  00025	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00029	74 0b		 je	 SHORT $LN2@PyMemoTabl@8

; 579  :         entry->me_value = value;

  0002b	48 89 70 08	 mov	 QWORD PTR [rax+8], rsi

; 580  :         return 0;

  0002f	33 c0		 xor	 eax, eax
  00031	e9 89 00 00 00	 jmp	 $LN3@PyMemoTabl@8
$LN2@PyMemoTabl@8:
  00036	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12

; 581  :     }
; 582  :     Py_INCREF(key);

  0003b	e8 00 00 00 00	 call	 _Py_PXCTX
  00040	41 bc 02 00 00
	00		 mov	 r12d, 2
  00046	85 c0		 test	 eax, eax
  00048	75 2f		 jne	 SHORT $LN6@PyMemoTabl@8
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00058	4c 8b cb	 mov	 r9, rbx
  0005b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00061	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  00066	e8 00 00 00 00	 call	 _PyParallel_Guard
  0006b	85 c0		 test	 eax, eax
  0006d	75 06		 jne	 SHORT $LN5@PyMemoTabl@8
  0006f	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00073	74 04		 je	 SHORT $LN6@PyMemoTabl@8
$LN5@PyMemoTabl@8:
  00075	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@PyMemoTabl@8:

; 583  :     entry->me_key = key;

  00079	48 89 1f	 mov	 QWORD PTR [rdi], rbx

; 584  :     entry->me_value = value;

  0007c	48 89 77 08	 mov	 QWORD PTR [rdi+8], rsi

; 585  :     self->mt_used++;

  00080	48 ff 45 08	 inc	 QWORD PTR [rbp+8]

; 586  : 
; 587  :     /* If we added a key, we can safely resize. Otherwise just return!
; 588  :      * If used >= 2/3 size, adjust size. Normally, this quaduples the size.
; 589  :      *
; 590  :      * Quadrupling the size improves average table sparseness
; 591  :      * (reducing collisions) at the cost of some memory. It also halves
; 592  :      * the number of expensive resize operations in a growing memo table.
; 593  :      *
; 594  :      * Very large memo tables (over 50K items) use doubling instead.
; 595  :      * This may help applications with severe memory constraints.
; 596  :      */
; 597  :     if (!(self->mt_used * 3 >= (self->mt_mask + 1) * 2))

  00084	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  00088	4c 8b 45 08	 mov	 r8, QWORD PTR [rbp+8]
  0008c	48 8d 4c 00 02	 lea	 rcx, QWORD PTR [rax+rax+2]
  00091	4b 8d 04 40	 lea	 rax, QWORD PTR [r8+r8*2]
  00095	48 3b c1	 cmp	 rax, rcx
  00098	7d 04		 jge	 SHORT $LN1@PyMemoTabl@8

; 598  :         return 0;

  0009a	33 c0		 xor	 eax, eax
  0009c	eb 1c		 jmp	 SHORT $LN9@PyMemoTabl@8
$LN1@PyMemoTabl@8:

; 599  :     return _PyMemoTable_ResizeTable(self,
; 600  :         (self->mt_used > 50000 ? 2 : 4) * self->mt_used);

  0009e	49 81 f8 50 c3
	00 00		 cmp	 r8, 50000		; 0000c350H
  000a5	ba 04 00 00 00	 mov	 edx, 4
  000aa	48 8b cd	 mov	 rcx, rbp
  000ad	49 0f 4f d4	 cmovg	 rdx, r12
  000b1	49 0f af d0	 imul	 rdx, r8
  000b5	e8 00 00 00 00	 call	 _PyMemoTable_ResizeTable
$LN9@PyMemoTabl@8:
  000ba	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]
$LN3@PyMemoTabl@8:

; 601  : }

  000bf	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000c4	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000c9	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  000ce	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
PyMemoTable_Set ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@OGGBOJLP@_Pickler_FastCall?$AA@	; `string'
EXTRN	PyObject_Call:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Pickler_FastCall DD imagerel _Pickler_FastCall
	DD	imagerel _Pickler_FastCall+539
	DD	imagerel $unwind$_Pickler_FastCall
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Pickler_FastCall DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT ??_C@_0BC@OGGBOJLP@_Pickler_FastCall?$AA@
CONST	SEGMENT
??_C@_0BC@OGGBOJLP@_Pickler_FastCall?$AA@ DB '_Pickler_FastCall', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT _Pickler_FastCall
_TEXT	SEGMENT
self$ = 64
func$ = 72
arg$ = 80
_Pickler_FastCall PROC					; COMDAT

; 652  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 653  :     PyObject *result = NULL;
; 654  : 
; 655  :     ARG_TUP(self, arg);

  00014	48 83 79 78 00	 cmp	 QWORD PTR [rcx+120], 0
  00019	49 8b f8	 mov	 rdi, r8
  0001c	48 8b ea	 mov	 rbp, rdx
  0001f	48 8b f1	 mov	 rsi, rcx
  00022	0f 85 8c 00 00
	00		 jne	 $LN14@Pickler_Fa
  00028	b9 01 00 00 00	 mov	 ecx, 1
  0002d	e8 00 00 00 00	 call	 PyTuple_New
  00032	48 89 46 78	 mov	 QWORD PTR [rsi+120], rax
  00036	48 85 c0	 test	 rax, rax
  00039	75 79		 jne	 SHORT $LN14@Pickler_Fa
  0003b	e8 00 00 00 00	 call	 _Py_PXCTX
  00040	85 c0		 test	 eax, eax
  00042	0f 85 e8 00 00
	00		 jne	 $LN18@Pickler_Fa
  00048	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0004c	a8 20		 test	 al, 32			; 00000020H
  0004e	75 5a		 jne	 SHORT $LN37@Pickler_Fa
  00050	84 c0		 test	 al, al
  00052	78 56		 js	 SHORT $LN37@Pickler_Fa
  00054	a8 02		 test	 al, 2
  00056	0f 85 d4 00 00
	00		 jne	 $LN18@Pickler_Fa
  0005c	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00060	0f 85 ca 00 00
	00		 jne	 $LN18@Pickler_Fa
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00074	4c 8b cf	 mov	 r9, rdi
  00077	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0007d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00085	e8 00 00 00 00	 call	 _PyParallel_Guard
  0008a	48 8b cf	 mov	 rcx, rdi
  0008d	85 c0		 test	 eax, eax
  0008f	74 0a		 je	 SHORT $LN42@Pickler_Fa
  00091	e8 00 00 00 00	 call	 _Px_Dealloc
  00096	e9 95 00 00 00	 jmp	 $LN18@Pickler_Fa
$LN42@Pickler_Fa:
  0009b	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0009f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000a5	e9 86 00 00 00	 jmp	 $LN18@Pickler_Fa
$LN37@Pickler_Fa:
  000aa	48 8b cf	 mov	 rcx, rdi
  000ad	e8 00 00 00 00	 call	 Px_DecRef
  000b2	eb 7c		 jmp	 SHORT $LN18@Pickler_Fa
$LN14@Pickler_Fa:
  000b4	48 8b 5e 78	 mov	 rbx, QWORD PTR [rsi+120]
  000b8	48 83 7b 70 00	 cmp	 QWORD PTR [rbx+112], 0
  000bd	74 69		 je	 SHORT $LN13@Pickler_Fa
  000bf	48 8b 5b 70	 mov	 rbx, QWORD PTR [rbx+112]
  000c3	e8 00 00 00 00	 call	 _Py_PXCTX
  000c8	85 c0		 test	 eax, eax
  000ca	75 5c		 jne	 SHORT $LN13@Pickler_Fa
  000cc	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000d0	a8 20		 test	 al, 32			; 00000020H
  000d2	75 4c		 jne	 SHORT $LN26@Pickler_Fa
  000d4	84 c0		 test	 al, al
  000d6	78 48		 js	 SHORT $LN26@Pickler_Fa
  000d8	a8 02		 test	 al, 2
  000da	75 4c		 jne	 SHORT $LN13@Pickler_Fa
  000dc	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000e0	75 46		 jne	 SHORT $LN13@Pickler_Fa
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000f0	4c 8b cb	 mov	 r9, rbx
  000f3	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000f9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00101	e8 00 00 00 00	 call	 _PyParallel_Guard
  00106	48 8b cb	 mov	 rcx, rbx
  00109	85 c0		 test	 eax, eax
  0010b	74 07		 je	 SHORT $LN31@Pickler_Fa
  0010d	e8 00 00 00 00	 call	 _Px_Dealloc
  00112	eb 14		 jmp	 SHORT $LN13@Pickler_Fa
$LN31@Pickler_Fa:
  00114	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00118	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0011e	eb 08		 jmp	 SHORT $LN13@Pickler_Fa
$LN26@Pickler_Fa:
  00120	48 8b cb	 mov	 rcx, rbx
  00123	e8 00 00 00 00	 call	 Px_DecRef
$LN13@Pickler_Fa:
  00128	48 8b 46 78	 mov	 rax, QWORD PTR [rsi+120]
  0012c	48 89 78 70	 mov	 QWORD PTR [rax+112], rdi
$LN18@Pickler_Fa:

; 656  :     if (self->arg) {

  00130	48 8b 56 78	 mov	 rdx, QWORD PTR [rsi+120]
  00134	48 85 d2	 test	 rdx, rdx
  00137	0f 84 c7 00 00
	00		 je	 $LN55@Pickler_Fa

; 657  :         result = PyObject_Call(func, self->arg, NULL);

  0013d	45 33 c0	 xor	 r8d, r8d
  00140	48 8b cd	 mov	 rcx, rbp
  00143	e8 00 00 00 00	 call	 PyObject_Call

; 658  :         FREE_ARG_TUP(self);

  00148	4c 8b 4e 78	 mov	 r9, QWORD PTR [rsi+120]
  0014c	49 83 79 50 01	 cmp	 QWORD PTR [r9+80], 1
  00151	48 8b f8	 mov	 rdi, rax
  00154	0f 8e a5 00 00
	00		 jle	 $LN2@Pickler_Fa
  0015a	4d 85 c9	 test	 r9, r9
  0015d	0f 84 9c 00 00
	00		 je	 $LN2@Pickler_Fa
  00163	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0016a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@OGGBOJLP@_Pickler_FastCall?$AA@
  00171	41 b8 92 02 00
	00		 mov	 r8d, 658		; 00000292H
  00177	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0017f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00184	85 c0		 test	 eax, eax
  00186	75 77		 jne	 SHORT $LN2@Pickler_Fa
  00188	48 8b 5e 78	 mov	 rbx, QWORD PTR [rsi+120]
  0018c	48 c7 46 78 00
	00 00 00	 mov	 QWORD PTR [rsi+120], 0
  00194	e8 00 00 00 00	 call	 _Py_PXCTX
  00199	85 c0		 test	 eax, eax
  0019b	75 62		 jne	 SHORT $LN2@Pickler_Fa
  0019d	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001a1	a8 20		 test	 al, 32			; 00000020H
  001a3	75 52		 jne	 SHORT $LN48@Pickler_Fa
  001a5	84 c0		 test	 al, al
  001a7	78 4e		 js	 SHORT $LN48@Pickler_Fa
  001a9	a8 02		 test	 al, 2
  001ab	75 52		 jne	 SHORT $LN2@Pickler_Fa
  001ad	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001b1	75 4c		 jne	 SHORT $LN2@Pickler_Fa
  001b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001c1	4c 8b cb	 mov	 r9, rbx
  001c4	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001ca	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001d2	e8 00 00 00 00	 call	 _PyParallel_Guard
  001d7	48 8b cb	 mov	 rcx, rbx
  001da	85 c0		 test	 eax, eax
  001dc	74 0a		 je	 SHORT $LN53@Pickler_Fa
  001de	e8 00 00 00 00	 call	 _Px_Dealloc

; 659  :     }
; 660  :     return result;

  001e3	48 8b c7	 mov	 rax, rdi
  001e6	eb 1e		 jmp	 SHORT $LN6@Pickler_Fa

; 658  :         FREE_ARG_TUP(self);

$LN53@Pickler_Fa:
  001e8	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001ec	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 659  :     }
; 660  :     return result;

  001f2	48 8b c7	 mov	 rax, rdi
  001f5	eb 0f		 jmp	 SHORT $LN6@Pickler_Fa

; 658  :         FREE_ARG_TUP(self);

$LN48@Pickler_Fa:
  001f7	48 8b cb	 mov	 rcx, rbx
  001fa	e8 00 00 00 00	 call	 Px_DecRef
$LN2@Pickler_Fa:

; 659  :     }
; 660  :     return result;

  001ff	48 8b c7	 mov	 rax, rdi
  00202	eb 02		 jmp	 SHORT $LN6@Pickler_Fa
$LN55@Pickler_Fa:
  00204	33 c0		 xor	 eax, eax
$LN6@Pickler_Fa:

; 661  : }

  00206	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0020b	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00210	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00215	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00219	5f		 pop	 rdi
  0021a	c3		 ret	 0
_Pickler_FastCall ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@HANIONFG@_Pickler_ClearBuffer?$AA@	; `string'
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Pickler_ClearBuffer DD imagerel _Pickler_ClearBuffer
	DD	imagerel _Pickler_ClearBuffer+66
	DD	imagerel $unwind$_Pickler_ClearBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_Pickler_ClearBuffer DD imagerel _Pickler_ClearBuffer+66
	DD	imagerel _Pickler_ClearBuffer+195
	DD	imagerel $chain$0$_Pickler_ClearBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_Pickler_ClearBuffer DD imagerel _Pickler_ClearBuffer+195
	DD	imagerel _Pickler_ClearBuffer+249
	DD	imagerel $chain$1$_Pickler_ClearBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_Pickler_ClearBuffer DD 021H
	DD	imagerel _Pickler_ClearBuffer
	DD	imagerel _Pickler_ClearBuffer+66
	DD	imagerel $unwind$_Pickler_ClearBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_Pickler_ClearBuffer DD 020521H
	DD	083405H
	DD	imagerel _Pickler_ClearBuffer
	DD	imagerel _Pickler_ClearBuffer+66
	DD	imagerel $unwind$_Pickler_ClearBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Pickler_ClearBuffer DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_0BF@HANIONFG@_Pickler_ClearBuffer?$AA@
CONST	SEGMENT
??_C@_0BF@HANIONFG@_Pickler_ClearBuffer?$AA@ DB '_Pickler_ClearBuffer', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT _Pickler_ClearBuffer
_TEXT	SEGMENT
self$ = 64
_Pickler_ClearBuffer PROC				; COMDAT

; 665  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 666  :     Py_CLEAR(self->output_buffer);

  00006	4c 8b 89 88 00
	00 00		 mov	 r9, QWORD PTR [rcx+136]
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	4d 85 c9	 test	 r9, r9
  00013	0f 84 aa 00 00
	00		 je	 $LN4@Pickler_Cl
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@HANIONFG@_Pickler_ClearBuffer?$AA@
  00027	41 b8 9a 02 00
	00		 mov	 r8d, 666		; 0000029aH
  0002d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00035	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003a	85 c0		 test	 eax, eax
  0003c	0f 85 81 00 00
	00		 jne	 $LN4@Pickler_Cl
  00042	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00047	48 8b 9f 88 00
	00 00		 mov	 rbx, QWORD PTR [rdi+136]
  0004e	48 c7 87 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rdi+136], 0
  00059	e8 00 00 00 00	 call	 _Py_PXCTX
  0005e	85 c0		 test	 eax, eax
  00060	75 5c		 jne	 SHORT $LN19@Pickler_Cl
  00062	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00066	a8 20		 test	 al, 32			; 00000020H
  00068	75 4c		 jne	 SHORT $LN12@Pickler_Cl
  0006a	84 c0		 test	 al, al
  0006c	78 48		 js	 SHORT $LN12@Pickler_Cl
  0006e	a8 02		 test	 al, 2
  00070	75 4c		 jne	 SHORT $LN19@Pickler_Cl
  00072	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00076	75 46		 jne	 SHORT $LN19@Pickler_Cl
  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00086	4c 8b cb	 mov	 r9, rbx
  00089	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0008f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00097	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009c	48 8b cb	 mov	 rcx, rbx
  0009f	85 c0		 test	 eax, eax
  000a1	74 07		 je	 SHORT $LN17@Pickler_Cl
  000a3	e8 00 00 00 00	 call	 _Px_Dealloc
  000a8	eb 14		 jmp	 SHORT $LN19@Pickler_Cl
$LN17@Pickler_Cl:
  000aa	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000ae	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000b4	eb 08		 jmp	 SHORT $LN19@Pickler_Cl
$LN12@Pickler_Cl:
  000b6	48 8b cb	 mov	 rcx, rbx
  000b9	e8 00 00 00 00	 call	 Px_DecRef
$LN19@Pickler_Cl:
  000be	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN4@Pickler_Cl:

; 667  :     self->output_buffer =
; 668  :         PyBytes_FromStringAndSize(NULL, self->max_output_len);

  000c3	48 8b 97 98 00
	00 00		 mov	 rdx, QWORD PTR [rdi+152]
  000ca	33 c9		 xor	 ecx, ecx
  000cc	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000d1	48 89 87 88 00
	00 00		 mov	 QWORD PTR [rdi+136], rax

; 669  :     if (self->output_buffer == NULL)

  000d8	48 85 c0	 test	 rax, rax
  000db	75 09		 jne	 SHORT $LN1@Pickler_Cl

; 670  :         return -1;

  000dd	83 c8 ff	 or	 eax, -1

; 673  : }

  000e0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e4	5f		 pop	 rdi
  000e5	c3		 ret	 0
$LN1@Pickler_Cl:

; 671  :     self->output_len = 0;

  000e6	48 c7 87 90 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rdi+144], 0

; 672  :     return 0;

  000f1	33 c0		 xor	 eax, eax

; 673  : }

  000f3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f7	5f		 pop	 rdi
  000f8	c3		 ret	 0
_Pickler_ClearBuffer ENDP
_TEXT	ENDS
EXTRN	_PyBytes_Resize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Pickler_GetString DD imagerel _Pickler_GetString
	DD	imagerel _Pickler_GetString+64
	DD	imagerel $unwind$_Pickler_GetString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Pickler_GetString DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _Pickler_GetString
_TEXT	SEGMENT
output_buffer$ = 48
self$ = 48
_Pickler_GetString PROC					; COMDAT

; 677  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 678  :     PyObject *output_buffer = self->output_buffer;

  00006	48 8b 81 88 00
	00 00		 mov	 rax, QWORD PTR [rcx+136]

; 679  : 
; 680  :     assert(self->output_buffer != NULL);
; 681  :     self->output_buffer = NULL;
; 682  :     /* Resize down to exact size */
; 683  :     if (_PyBytes_Resize(&output_buffer, self->output_len) < 0)

  0000d	48 8b 91 90 00
	00 00		 mov	 rdx, QWORD PTR [rcx+144]
  00014	33 db		 xor	 ebx, ebx
  00016	48 89 99 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rbx
  0001d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR output_buffer$[rsp]
  00022	48 89 44 24 30	 mov	 QWORD PTR output_buffer$[rsp], rax
  00027	e8 00 00 00 00	 call	 _PyBytes_Resize
  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR output_buffer$[rsp]
  00031	85 c0		 test	 eax, eax
  00033	48 0f 48 cb	 cmovs	 rcx, rbx
  00037	48 8b c1	 mov	 rax, rcx

; 684  :         return NULL;
; 685  :     return output_buffer;
; 686  : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	c3		 ret	 0
_Pickler_GetString ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Pickler_FlushToFile DD imagerel _Pickler_FlushToFile
	DD	imagerel _Pickler_FlushToFile+196
	DD	imagerel $unwind$_Pickler_FlushToFile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Pickler_FlushToFile DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT _Pickler_FlushToFile
_TEXT	SEGMENT
self$ = 64
_Pickler_FlushToFile PROC				; COMDAT

; 690  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 691  :     PyObject *output, *result;
; 692  : 
; 693  :     assert(self->write != NULL);
; 694  : 
; 695  :     output = _Pickler_GetString(self);

  00009	e8 00 00 00 00	 call	 _Pickler_GetString

; 696  :     if (output == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 09		 jne	 SHORT $LN5@Pickler_Fl

; 697  :         return -1;

  00013	83 c8 ff	 or	 eax, -1

; 702  : }

  00016	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001a	5b		 pop	 rbx
  0001b	c3		 ret	 0
$LN5@Pickler_Fl:

; 698  : 
; 699  :     result = _Pickler_FastCall(self, self->write, output);

  0001c	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  00023	4c 8b c0	 mov	 r8, rax
  00026	48 8b cb	 mov	 rcx, rbx
  00029	e8 00 00 00 00	 call	 _Pickler_FastCall
  0002e	48 8b d8	 mov	 rbx, rax

; 700  :     Py_XDECREF(result);

  00031	48 85 c0	 test	 rax, rax
  00034	74 7f		 je	 SHORT $LN3@Pickler_Fl
  00036	e8 00 00 00 00	 call	 _Py_PXCTX
  0003b	85 c0		 test	 eax, eax
  0003d	75 76		 jne	 SHORT $LN3@Pickler_Fl
  0003f	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00043	a8 20		 test	 al, 32			; 00000020H
  00045	75 66		 jne	 SHORT $LN12@Pickler_Fl
  00047	84 c0		 test	 al, al
  00049	78 62		 js	 SHORT $LN12@Pickler_Fl
  0004b	a8 02		 test	 al, 2
  0004d	75 66		 jne	 SHORT $LN3@Pickler_Fl
  0004f	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00053	75 60		 jne	 SHORT $LN3@Pickler_Fl
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00063	4c 8b cb	 mov	 r9, rbx
  00066	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0006c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00074	e8 00 00 00 00	 call	 _PyParallel_Guard
  00079	48 8b cb	 mov	 rcx, rbx
  0007c	85 c0		 test	 eax, eax
  0007e	74 14		 je	 SHORT $LN17@Pickler_Fl
  00080	e8 00 00 00 00	 call	 _Px_Dealloc

; 701  :     return (result == NULL) ? -1 : 0;

  00085	48 f7 db	 neg	 rbx
  00088	1b c0		 sbb	 eax, eax
  0008a	f7 d8		 neg	 eax
  0008c	ff c8		 dec	 eax

; 702  : }

  0008e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00092	5b		 pop	 rbx
  00093	c3		 ret	 0

; 700  :     Py_XDECREF(result);

$LN17@Pickler_Fl:
  00094	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00098	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 701  :     return (result == NULL) ? -1 : 0;

  0009e	48 f7 db	 neg	 rbx
  000a1	1b c0		 sbb	 eax, eax
  000a3	f7 d8		 neg	 eax
  000a5	ff c8		 dec	 eax

; 702  : }

  000a7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ab	5b		 pop	 rbx
  000ac	c3		 ret	 0

; 700  :     Py_XDECREF(result);

$LN12@Pickler_Fl:
  000ad	48 8b cb	 mov	 rcx, rbx
  000b0	e8 00 00 00 00	 call	 Px_DecRef
$LN3@Pickler_Fl:

; 701  :     return (result == NULL) ? -1 : 0;

  000b5	48 f7 db	 neg	 rbx
  000b8	1b c0		 sbb	 eax, eax
  000ba	f7 d8		 neg	 eax
  000bc	ff c8		 dec	 eax

; 702  : }

  000be	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c2	5b		 pop	 rbx
  000c3	c3		 ret	 0
_Pickler_FlushToFile ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Pickler_Write DD imagerel _Pickler_Write
	DD	imagerel _Pickler_Write+385
	DD	imagerel $unwind$_Pickler_Write
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Pickler_Write DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _Pickler_Write
_TEXT	SEGMENT
self$ = 48
s$ = 56
n$ = 64
_Pickler_Write PROC					; COMDAT

; 706  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 707  :     Py_ssize_t i, required;
; 708  :     char *buffer;
; 709  : 
; 710  :     assert(s != NULL);
; 711  : 
; 712  :     required = self->output_len + n;

  0000f	48 8b 81 90 00
	00 00		 mov	 rax, QWORD PTR [rcx+144]
  00016	48 8b d9	 mov	 rbx, rcx
  00019	49 8b f8	 mov	 rdi, r8
  0001c	49 8d 0c 00	 lea	 rcx, QWORD PTR [r8+rax]
  00020	48 8b f2	 mov	 rsi, rdx

; 713  :     if (required > self->max_output_len) {

  00023	48 3b 8b 98 00
	00 00		 cmp	 rcx, QWORD PTR [rbx+152]
  0002a	0f 8e ed 00 00
	00		 jle	 $LN6@Pickler_Wr

; 714  :         if (self->write != NULL && required > MAX_WRITE_BUF_SIZE) {

  00030	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00038	0f 84 86 00 00
	00		 je	 $LN14@Pickler_Wr
  0003e	48 81 f9 00 00
	01 00		 cmp	 rcx, 65536		; 00010000H
  00045	7e 1c		 jle	 SHORT $LN15@Pickler_Wr

; 715  :             /* XXX This reallocates a new buffer every time, which is a bit
; 716  :                wasteful. */
; 717  :             if (_Pickler_FlushToFile(self) < 0)

  00047	48 8b cb	 mov	 rcx, rbx
  0004a	e8 00 00 00 00	 call	 _Pickler_FlushToFile
  0004f	85 c0		 test	 eax, eax

; 718  :                 return -1;

  00051	0f 88 8b 00 00
	00		 js	 $LN24@Pickler_Wr

; 719  :             if (_Pickler_ClearBuffer(self) < 0)

  00057	48 8b cb	 mov	 rcx, rbx
  0005a	e8 00 00 00 00	 call	 _Pickler_ClearBuffer
  0005f	85 c0		 test	 eax, eax

; 720  :                 return -1;

  00061	78 7f		 js	 SHORT $LN24@Pickler_Wr
$LN15@Pickler_Wr:

; 721  :         }
; 722  :         if (self->write != NULL && n > MAX_WRITE_BUF_SIZE) {

  00063	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  0006b	74 57		 je	 SHORT $LN14@Pickler_Wr
  0006d	48 81 ff 00 00
	01 00		 cmp	 rdi, 65536		; 00010000H
  00074	7e 4e		 jle	 SHORT $LN14@Pickler_Wr

; 723  :             /* we already flushed above, so the buffer is empty */
; 724  :             PyObject *result;
; 725  :             /* XXX we could spare an intermediate copy and pass
; 726  :                a memoryview instead */
; 727  :             PyObject *output = PyBytes_FromStringAndSize(s, n);

  00076	48 8b d7	 mov	 rdx, rdi
  00079	48 8b ce	 mov	 rcx, rsi
  0007c	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 728  :             if (s == NULL)

  00081	48 85 f6	 test	 rsi, rsi

; 729  :                 return -1;

  00084	74 5c		 je	 SHORT $LN24@Pickler_Wr

; 730  :             result = _Pickler_FastCall(self, self->write, output);

  00086	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  0008d	4c 8b c0	 mov	 r8, rax
  00090	48 8b cb	 mov	 rcx, rbx
  00093	e8 00 00 00 00	 call	 _Pickler_FastCall
  00098	48 8b d8	 mov	 rbx, rax

; 731  :             Py_XDECREF(result);

  0009b	48 85 c0	 test	 rax, rax
  0009e	74 08		 je	 SHORT $LN11@Pickler_Wr
  000a0	48 8b c8	 mov	 rcx, rax
  000a3	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@Pickler_Wr:

; 732  :             return (result == NULL) ? -1 : 0;

  000a8	48 f7 db	 neg	 rbx
  000ab	48 1b c0	 sbb	 rax, rax
  000ae	48 f7 d8	 neg	 rax
  000b1	48 ff c8	 dec	 rax

; 755  :     return n;
; 756  : }

  000b4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b9	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000be	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c2	5f		 pop	 rdi
  000c3	c3		 ret	 0
$LN14@Pickler_Wr:

; 733  :         }
; 734  :         else {
; 735  :             if (self->output_len >= PY_SSIZE_T_MAX / 2 - n) {

  000c4	48 8b 8b 90 00
	00 00		 mov	 rcx, QWORD PTR [rbx+144]
  000cb	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  000d5	48 2b c7	 sub	 rax, rdi
  000d8	48 3b c8	 cmp	 rcx, rax
  000db	7c 19		 jl	 SHORT $LN7@Pickler_Wr

; 736  :                 PyErr_NoMemory();

  000dd	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN24@Pickler_Wr:

; 737  :                 return -1;

  000e2	48 83 c8 ff	 or	 rax, -1

; 755  :     return n;
; 756  : }

  000e6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000eb	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000f0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f4	5f		 pop	 rdi
  000f5	c3		 ret	 0
$LN7@Pickler_Wr:

; 738  :             }
; 739  :             self->max_output_len = (self->output_len + n) / 2 * 3;

  000f6	48 8d 04 39	 lea	 rax, QWORD PTR [rcx+rdi]

; 740  :             if (_PyBytes_Resize(&self->output_buffer, self->max_output_len) < 0)

  000fa	48 8d 8b 88 00
	00 00		 lea	 rcx, QWORD PTR [rbx+136]
  00101	48 99		 cdq
  00103	48 2b c2	 sub	 rax, rdx
  00106	48 d1 f8	 sar	 rax, 1
  00109	48 8d 14 40	 lea	 rdx, QWORD PTR [rax+rax*2]
  0010d	48 89 93 98 00
	00 00		 mov	 QWORD PTR [rbx+152], rdx
  00114	e8 00 00 00 00	 call	 _PyBytes_Resize
  00119	85 c0		 test	 eax, eax

; 741  :                 return -1;

  0011b	78 c5		 js	 SHORT $LN24@Pickler_Wr
$LN6@Pickler_Wr:

; 742  :         }
; 743  :     }
; 744  :     buffer = PyBytes_AS_STRING(self->output_buffer);

  0011d	4c 8b 8b 88 00
	00 00		 mov	 r9, QWORD PTR [rbx+136]

; 745  :     if (n < 8) {

  00124	48 83 ff 08	 cmp	 rdi, 8
  00128	7d 26		 jge	 SHORT $LN5@Pickler_Wr

; 746  :         /* This is faster than memcpy when the string is short. */
; 747  :         for (i = 0; i < n; i++) {

  0012a	45 33 c0	 xor	 r8d, r8d
  0012d	48 85 ff	 test	 rdi, rdi
  00130	7e 35		 jle	 SHORT $LN1@Pickler_Wr
$LL4@Pickler_Wr:

; 748  :             buffer[self->output_len + i] = s[i];

  00132	41 0f b6 04 30	 movzx	 eax, BYTE PTR [r8+rsi]
  00137	48 8b 8b 90 00
	00 00		 mov	 rcx, QWORD PTR [rbx+144]
  0013e	4b 8d 54 08 78	 lea	 rdx, QWORD PTR [r8+r9+120]
  00143	49 ff c0	 inc	 r8
  00146	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00149	4c 3b c7	 cmp	 r8, rdi
  0014c	7c e4		 jl	 SHORT $LL4@Pickler_Wr

; 749  :         }
; 750  :     }
; 751  :     else {

  0014e	eb 17		 jmp	 SHORT $LN1@Pickler_Wr
$LN5@Pickler_Wr:

; 752  :         memcpy(buffer + self->output_len, s, n);

  00150	48 8b 83 90 00
	00 00		 mov	 rax, QWORD PTR [rbx+144]
  00157	4c 8b c7	 mov	 r8, rdi
  0015a	48 8b d6	 mov	 rdx, rsi
  0015d	49 8d 4c 01 78	 lea	 rcx, QWORD PTR [r9+rax+120]
  00162	e8 00 00 00 00	 call	 memcpy
$LN1@Pickler_Wr:

; 753  :     }
; 754  :     self->output_len += n;

  00167	48 01 bb 90 00
	00 00		 add	 QWORD PTR [rbx+144], rdi

; 755  :     return n;
; 756  : }

  0016e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00173	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00178	48 8b c7	 mov	 rax, rdi
  0017b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0017f	5f		 pop	 rdi
  00180	c3		 ret	 0
_Pickler_Write ENDP
_TEXT	ENDS
EXTRN	_PyObject_GC_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Pickler_New DD imagerel _Pickler_New
	DD	imagerel _Pickler_New+48
	DD	imagerel $unwind$_Pickler_New
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_Pickler_New DD imagerel _Pickler_New+48
	DD	imagerel _Pickler_New+178
	DD	imagerel $chain$0$_Pickler_New
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_Pickler_New DD imagerel _Pickler_New+178
	DD	imagerel _Pickler_New+192
	DD	imagerel $chain$2$_Pickler_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_Pickler_New DD 020021H
	DD	067400H
	DD	imagerel _Pickler_New
	DD	imagerel _Pickler_New+48
	DD	imagerel $unwind$_Pickler_New
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_Pickler_New DD 020521H
	DD	067405H
	DD	imagerel _Pickler_New
	DD	imagerel _Pickler_New+48
	DD	imagerel $unwind$_Pickler_New
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Pickler_New DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _Pickler_New
_TEXT	SEGMENT
_Pickler_New PROC					; COMDAT

; 760  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 761  :     PicklerObject *self;
; 762  : 
; 763  :     self = PyObject_GC_New(PicklerObject, &Pickler_Type);

  00006	e8 00 00 00 00	 call	 _Py_PXCTX
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Pickler_Type
  00012	85 c0		 test	 eax, eax
  00014	74 07		 je	 SHORT $LN6@Pickler_Ne
  00016	e8 00 00 00 00	 call	 _PxObject_New
  0001b	eb 05		 jmp	 SHORT $LN9@Pickler_Ne
$LN6@Pickler_Ne:
  0001d	e8 00 00 00 00	 call	 _PyObject_GC_New
$LN9@Pickler_Ne:
  00022	48 8b d8	 mov	 rbx, rax

; 764  :     if (self == NULL)

  00025	48 85 c0	 test	 rax, rax
  00028	75 06		 jne	 SHORT $LN3@Pickler_Ne

; 792  : }

  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5b		 pop	 rbx
  0002f	c3		 ret	 0
$LN3@Pickler_Ne:
  00030	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 765  :         return NULL;
; 766  : 
; 767  :     self->pers_func = NULL;

  00035	33 ff		 xor	 edi, edi
  00037	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi

; 768  :     self->dispatch_table = NULL;

  0003b	48 89 7b 70	 mov	 QWORD PTR [rbx+112], rdi

; 769  :     self->arg = NULL;

  0003f	48 89 7b 78	 mov	 QWORD PTR [rbx+120], rdi

; 770  :     self->write = NULL;

  00043	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi

; 771  :     self->proto = 0;

  0004a	48 89 bb a0 00
	00 00		 mov	 QWORD PTR [rbx+160], rdi

; 772  :     self->bin = 0;
; 773  :     self->fast = 0;

  00051	48 89 bb b0 00
	00 00		 mov	 QWORD PTR [rbx+176], rdi

; 774  :     self->fast_nesting = 0;
; 775  :     self->fix_imports = 0;

  00058	89 bb b8 00 00
	00		 mov	 DWORD PTR [rbx+184], edi

; 776  :     self->fast_memo = NULL;

  0005e	48 89 bb c0 00
	00 00		 mov	 QWORD PTR [rbx+192], rdi

; 777  : 
; 778  :     self->memo = PyMemoTable_New();

  00065	e8 00 00 00 00	 call	 PyMemoTable_New
  0006a	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 779  :     if (self->memo == NULL) {

  0006e	48 85 c0	 test	 rax, rax

; 780  :         Py_DECREF(self);
; 781  :         return NULL;

  00071	74 2a		 je	 SHORT $LN10@Pickler_Ne

; 782  :     }
; 783  :     self->max_output_len = WRITE_BUF_SIZE;
; 784  :     self->output_len = 0;
; 785  :     self->output_buffer = PyBytes_FromStringAndSize(NULL,
; 786  :                                                     self->max_output_len);

  00073	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  00078	33 c9		 xor	 ecx, ecx
  0007a	48 c7 83 98 00
	00 00 00 10 00
	00		 mov	 QWORD PTR [rbx+152], 4096 ; 00001000H
  00085	48 89 bb 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rdi
  0008c	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00091	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 787  :     if (self->output_buffer == NULL) {

  00098	48 85 c0	 test	 rax, rax
  0009b	75 15		 jne	 SHORT $LN1@Pickler_Ne
$LN10@Pickler_Ne:

; 788  :         Py_DECREF(self);

  0009d	48 8b cb	 mov	 rcx, rbx
  000a0	e8 00 00 00 00	 call	 _Py_DecRef
  000a5	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 789  :         return NULL;

  000aa	33 c0		 xor	 eax, eax

; 792  : }

  000ac	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b0	5b		 pop	 rbx
  000b1	c3		 ret	 0
$LN1@Pickler_Ne:

; 790  :     }
; 791  :     return self;

  000b2	48 8b c3	 mov	 rax, rbx
  000b5	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 792  : }

  000ba	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000be	5b		 pop	 rbx
  000bf	c3		 ret	 0
_Pickler_New ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@HLBJPKP@pickle?5protocol?5must?5be?5?$DM?$DN?5?$CFd?$AA@ ; `string'
EXTRN	PyObject_IsTrue:PROC
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsLong:PROC
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Pickler_SetProtocol DD imagerel _Pickler_SetProtocol
	DD	imagerel _Pickler_SetProtocol+216
	DD	imagerel $unwind$_Pickler_SetProtocol
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Pickler_SetProtocol DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BO@HLBJPKP@pickle?5protocol?5must?5be?5?$DM?$DN?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@HLBJPKP@pickle?5protocol?5must?5be?5?$DM?$DN?5?$CFd?$AA@ DB 'pi'
	DB	'ckle protocol must be <= %d', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Pickler_SetProtocol
_TEXT	SEGMENT
self$ = 48
proto_obj$ = 56
fix_imports_obj$ = 64
_Pickler_SetProtocol PROC				; COMDAT

; 797  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f0	 mov	 rsi, r8
  00012	48 8b f9	 mov	 rdi, rcx

; 798  :     long proto = 0;
; 799  :     int fix_imports;
; 800  : 
; 801  :     if (proto_obj == NULL || proto_obj == Py_None)

  00015	48 85 d2	 test	 rdx, rdx
  00018	74 6d		 je	 SHORT $LN6@Pickler_Se
  0001a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00021	48 3b d0	 cmp	 rdx, rax
  00024	74 61		 je	 SHORT $LN6@Pickler_Se

; 803  :     else {
; 804  :         proto = PyLong_AsLong(proto_obj);

  00026	48 8b ca	 mov	 rcx, rdx
  00029	e8 00 00 00 00	 call	 PyLong_AsLong
  0002e	8b d8		 mov	 ebx, eax

; 805  :         if (proto == -1 && PyErr_Occurred())

  00030	83 f8 ff	 cmp	 eax, -1
  00033	75 1d		 jne	 SHORT $LN4@Pickler_Se
  00035	e8 00 00 00 00	 call	 PyErr_Occurred
  0003a	48 85 c0	 test	 rax, rax
  0003d	74 48		 je	 SHORT $LN6@Pickler_Se
$LN13@Pickler_Se:

; 806  :             return -1;

  0003f	83 c8 ff	 or	 eax, -1

; 822  : 
; 823  :     return 0;
; 824  : }

  00042	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00047	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5f		 pop	 rdi
  00051	c3		 ret	 0
$LN4@Pickler_Se:

; 807  :     }
; 808  :     if (proto < 0)

  00052	85 c0		 test	 eax, eax

; 809  :         proto = HIGHEST_PROTOCOL;
; 810  :     if (proto > HIGHEST_PROTOCOL) {

  00054	78 31		 js	 SHORT $LN6@Pickler_Se
  00056	83 f8 03	 cmp	 eax, 3
  00059	7e 31		 jle	 SHORT $LN2@Pickler_Se

; 811  :         PyErr_Format(PyExc_ValueError, "pickle protocol must be <= %d",
; 812  :                      HIGHEST_PROTOCOL);

  0005b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@HLBJPKP@pickle?5protocol?5must?5be?5?$DM?$DN?5?$CFd?$AA@
  00069	41 b8 03 00 00
	00		 mov	 r8d, 3
  0006f	e8 00 00 00 00	 call	 PyErr_Format

; 813  :         return -1;

  00074	83 c8 ff	 or	 eax, -1

; 822  : 
; 823  :     return 0;
; 824  : }

  00077	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00081	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00085	5f		 pop	 rdi
  00086	c3		 ret	 0
$LN6@Pickler_Se:

; 802  :         proto = DEFAULT_PROTOCOL;

  00087	bb 03 00 00 00	 mov	 ebx, 3
$LN2@Pickler_Se:

; 814  :     }
; 815  :     fix_imports = PyObject_IsTrue(fix_imports_obj);

  0008c	48 8b ce	 mov	 rcx, rsi
  0008f	e8 00 00 00 00	 call	 PyObject_IsTrue
  00094	44 8b d8	 mov	 r11d, eax

; 816  :     if (fix_imports == -1)

  00097	83 f8 ff	 cmp	 eax, -1

; 817  :         return -1;

  0009a	74 a3		 je	 SHORT $LN13@Pickler_Se

; 818  : 
; 819  :     self->proto = proto;
; 820  :     self->bin = proto > 0;

  0009c	33 c9		 xor	 ecx, ecx
  0009e	85 db		 test	 ebx, ebx
  000a0	89 9f a0 00 00
	00		 mov	 DWORD PTR [rdi+160], ebx
  000a6	8b c1		 mov	 eax, ecx
  000a8	0f 9f c0	 setg	 al
  000ab	89 87 a4 00 00
	00		 mov	 DWORD PTR [rdi+164], eax

; 821  :     self->fix_imports = fix_imports && proto < 3;

  000b1	45 85 db	 test	 r11d, r11d
  000b4	74 0a		 je	 SHORT $LN10@Pickler_Se
  000b6	83 fb 03	 cmp	 ebx, 3
  000b9	7d 05		 jge	 SHORT $LN10@Pickler_Se
  000bb	b9 01 00 00 00	 mov	 ecx, 1
$LN10@Pickler_Se:

; 822  : 
; 823  :     return 0;
; 824  : }

  000c0	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c5	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000ca	89 8f b8 00 00
	00		 mov	 DWORD PTR [rdi+184], ecx
  000d0	33 c0		 xor	 eax, eax
  000d2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d6	5f		 pop	 rdi
  000d7	c3		 ret	 0
_Pickler_SetProtocol ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@JBEHNELP@file?5must?5have?5a?5?8write?8?5attribu@ ; `string'
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_AttributeError:QWORD
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Pickler_SetOutputStream DD imagerel _Pickler_SetOutputStream
	DD	imagerel _Pickler_SetOutputStream+109
	DD	imagerel $unwind$_Pickler_SetOutputStream
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Pickler_SetOutputStream DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CD@JBEHNELP@file?5must?5have?5a?5?8write?8?5attribu@
CONST	SEGMENT
??_C@_0CD@JBEHNELP@file?5must?5have?5a?5?8write?8?5attribu@ DB 'file must'
	DB	' have a ''write'' attribute', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Pickler_SetOutputStream
_TEXT	SEGMENT
self$ = 48
file$ = 56
_Pickler_SetOutputStream PROC				; COMDAT

; 830  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 831  :     _Py_IDENTIFIER(write);
; 832  :     assert(file != NULL);
; 833  :     self->write = _PyObject_GetAttrId(file, &PyId_write);

  00006	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0000d	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00016	4c 8b ca	 mov	 r9, rdx
  00019	48 8b d9	 mov	 rbx, rcx
  0001c	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_write@?1??_Pickler_SetOutputStream@@9@9
  00021	49 8b c9	 mov	 rcx, r9
  00024	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00028	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  0002d	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax

; 834  :     if (self->write == NULL) {

  00034	48 85 c0	 test	 rax, rax
  00037	75 2c		 jne	 SHORT $LN2@Pickler_Se@2

; 835  :         if (PyErr_ExceptionMatches(PyExc_AttributeError))

  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00040	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00045	85 c0		 test	 eax, eax
  00047	74 13		 je	 SHORT $LN1@Pickler_Se@2

; 836  :             PyErr_SetString(PyExc_TypeError,
; 837  :                             "file must have a 'write' attribute");

  00049	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@JBEHNELP@file?5must?5have?5a?5?8write?8?5attribu@
  00057	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@Pickler_Se@2:

; 838  :         return -1;

  0005c	83 c8 ff	 or	 eax, -1

; 842  : }

  0005f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00063	5b		 pop	 rbx
  00064	c3		 ret	 0
$LN2@Pickler_Se@2:

; 839  :     }
; 840  : 
; 841  :     return 0;

  00065	33 c0		 xor	 eax, eax

; 842  : }

  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5b		 pop	 rbx
  0006c	c3		 ret	 0
_Pickler_SetOutputStream ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@PFNKPMMG@_Unpickler_FastCall?$AA@	; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Unpickler_FastCall DD imagerel _Unpickler_FastCall
	DD	imagerel _Unpickler_FastCall+539
	DD	imagerel $unwind$_Unpickler_FastCall
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_FastCall DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT ??_C@_0BE@PFNKPMMG@_Unpickler_FastCall?$AA@
CONST	SEGMENT
??_C@_0BE@PFNKPMMG@_Unpickler_FastCall?$AA@ DB '_Unpickler_FastCall', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT _Unpickler_FastCall
_TEXT	SEGMENT
self$ = 64
func$ = 72
arg$ = 80
_Unpickler_FastCall PROC				; COMDAT

; 847  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 848  :     PyObject *result = NULL;
; 849  : 
; 850  :     ARG_TUP(self, arg);

  00014	48 83 79 78 00	 cmp	 QWORD PTR [rcx+120], 0
  00019	49 8b f8	 mov	 rdi, r8
  0001c	48 8b ea	 mov	 rbp, rdx
  0001f	48 8b f1	 mov	 rsi, rcx
  00022	0f 85 8c 00 00
	00		 jne	 $LN14@Unpickler_
  00028	b9 01 00 00 00	 mov	 ecx, 1
  0002d	e8 00 00 00 00	 call	 PyTuple_New
  00032	48 89 46 78	 mov	 QWORD PTR [rsi+120], rax
  00036	48 85 c0	 test	 rax, rax
  00039	75 79		 jne	 SHORT $LN14@Unpickler_
  0003b	e8 00 00 00 00	 call	 _Py_PXCTX
  00040	85 c0		 test	 eax, eax
  00042	0f 85 e8 00 00
	00		 jne	 $LN18@Unpickler_
  00048	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0004c	a8 20		 test	 al, 32			; 00000020H
  0004e	75 5a		 jne	 SHORT $LN37@Unpickler_
  00050	84 c0		 test	 al, al
  00052	78 56		 js	 SHORT $LN37@Unpickler_
  00054	a8 02		 test	 al, 2
  00056	0f 85 d4 00 00
	00		 jne	 $LN18@Unpickler_
  0005c	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00060	0f 85 ca 00 00
	00		 jne	 $LN18@Unpickler_
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00074	4c 8b cf	 mov	 r9, rdi
  00077	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0007d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00085	e8 00 00 00 00	 call	 _PyParallel_Guard
  0008a	48 8b cf	 mov	 rcx, rdi
  0008d	85 c0		 test	 eax, eax
  0008f	74 0a		 je	 SHORT $LN42@Unpickler_
  00091	e8 00 00 00 00	 call	 _Px_Dealloc
  00096	e9 95 00 00 00	 jmp	 $LN18@Unpickler_
$LN42@Unpickler_:
  0009b	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0009f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000a5	e9 86 00 00 00	 jmp	 $LN18@Unpickler_
$LN37@Unpickler_:
  000aa	48 8b cf	 mov	 rcx, rdi
  000ad	e8 00 00 00 00	 call	 Px_DecRef
  000b2	eb 7c		 jmp	 SHORT $LN18@Unpickler_
$LN14@Unpickler_:
  000b4	48 8b 5e 78	 mov	 rbx, QWORD PTR [rsi+120]
  000b8	48 83 7b 70 00	 cmp	 QWORD PTR [rbx+112], 0
  000bd	74 69		 je	 SHORT $LN13@Unpickler_
  000bf	48 8b 5b 70	 mov	 rbx, QWORD PTR [rbx+112]
  000c3	e8 00 00 00 00	 call	 _Py_PXCTX
  000c8	85 c0		 test	 eax, eax
  000ca	75 5c		 jne	 SHORT $LN13@Unpickler_
  000cc	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000d0	a8 20		 test	 al, 32			; 00000020H
  000d2	75 4c		 jne	 SHORT $LN26@Unpickler_
  000d4	84 c0		 test	 al, al
  000d6	78 48		 js	 SHORT $LN26@Unpickler_
  000d8	a8 02		 test	 al, 2
  000da	75 4c		 jne	 SHORT $LN13@Unpickler_
  000dc	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000e0	75 46		 jne	 SHORT $LN13@Unpickler_
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000f0	4c 8b cb	 mov	 r9, rbx
  000f3	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000f9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00101	e8 00 00 00 00	 call	 _PyParallel_Guard
  00106	48 8b cb	 mov	 rcx, rbx
  00109	85 c0		 test	 eax, eax
  0010b	74 07		 je	 SHORT $LN31@Unpickler_
  0010d	e8 00 00 00 00	 call	 _Px_Dealloc
  00112	eb 14		 jmp	 SHORT $LN13@Unpickler_
$LN31@Unpickler_:
  00114	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00118	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0011e	eb 08		 jmp	 SHORT $LN13@Unpickler_
$LN26@Unpickler_:
  00120	48 8b cb	 mov	 rcx, rbx
  00123	e8 00 00 00 00	 call	 Px_DecRef
$LN13@Unpickler_:
  00128	48 8b 46 78	 mov	 rax, QWORD PTR [rsi+120]
  0012c	48 89 78 70	 mov	 QWORD PTR [rax+112], rdi
$LN18@Unpickler_:

; 851  :     if (self->arg) {

  00130	48 8b 56 78	 mov	 rdx, QWORD PTR [rsi+120]
  00134	48 85 d2	 test	 rdx, rdx
  00137	0f 84 c7 00 00
	00		 je	 $LN55@Unpickler_

; 852  :         result = PyObject_Call(func, self->arg, NULL);

  0013d	45 33 c0	 xor	 r8d, r8d
  00140	48 8b cd	 mov	 rcx, rbp
  00143	e8 00 00 00 00	 call	 PyObject_Call

; 853  :         FREE_ARG_TUP(self);

  00148	4c 8b 4e 78	 mov	 r9, QWORD PTR [rsi+120]
  0014c	49 83 79 50 01	 cmp	 QWORD PTR [r9+80], 1
  00151	48 8b f8	 mov	 rdi, rax
  00154	0f 8e a5 00 00
	00		 jle	 $LN2@Unpickler_
  0015a	4d 85 c9	 test	 r9, r9
  0015d	0f 84 9c 00 00
	00		 je	 $LN2@Unpickler_
  00163	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0016a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@PFNKPMMG@_Unpickler_FastCall?$AA@
  00171	41 b8 55 03 00
	00		 mov	 r8d, 853		; 00000355H
  00177	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0017f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00184	85 c0		 test	 eax, eax
  00186	75 77		 jne	 SHORT $LN2@Unpickler_
  00188	48 8b 5e 78	 mov	 rbx, QWORD PTR [rsi+120]
  0018c	48 c7 46 78 00
	00 00 00	 mov	 QWORD PTR [rsi+120], 0
  00194	e8 00 00 00 00	 call	 _Py_PXCTX
  00199	85 c0		 test	 eax, eax
  0019b	75 62		 jne	 SHORT $LN2@Unpickler_
  0019d	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001a1	a8 20		 test	 al, 32			; 00000020H
  001a3	75 52		 jne	 SHORT $LN48@Unpickler_
  001a5	84 c0		 test	 al, al
  001a7	78 4e		 js	 SHORT $LN48@Unpickler_
  001a9	a8 02		 test	 al, 2
  001ab	75 52		 jne	 SHORT $LN2@Unpickler_
  001ad	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001b1	75 4c		 jne	 SHORT $LN2@Unpickler_
  001b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001c1	4c 8b cb	 mov	 r9, rbx
  001c4	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001ca	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001d2	e8 00 00 00 00	 call	 _PyParallel_Guard
  001d7	48 8b cb	 mov	 rcx, rbx
  001da	85 c0		 test	 eax, eax
  001dc	74 0a		 je	 SHORT $LN53@Unpickler_
  001de	e8 00 00 00 00	 call	 _Px_Dealloc

; 854  :     }
; 855  :     return result;

  001e3	48 8b c7	 mov	 rax, rdi
  001e6	eb 1e		 jmp	 SHORT $LN6@Unpickler_

; 853  :         FREE_ARG_TUP(self);

$LN53@Unpickler_:
  001e8	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001ec	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 854  :     }
; 855  :     return result;

  001f2	48 8b c7	 mov	 rax, rdi
  001f5	eb 0f		 jmp	 SHORT $LN6@Unpickler_

; 853  :         FREE_ARG_TUP(self);

$LN48@Unpickler_:
  001f7	48 8b cb	 mov	 rcx, rbx
  001fa	e8 00 00 00 00	 call	 Px_DecRef
$LN2@Unpickler_:

; 854  :     }
; 855  :     return result;

  001ff	48 8b c7	 mov	 rax, rdi
  00202	eb 02		 jmp	 SHORT $LN6@Unpickler_
$LN55@Unpickler_:
  00204	33 c0		 xor	 eax, eax
$LN6@Unpickler_:

; 856  : }

  00206	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0020b	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00210	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00215	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00219	5f		 pop	 rdi
  0021a	c3		 ret	 0
_Unpickler_FastCall ENDP
_TEXT	ENDS
EXTRN	PyObject_GetBuffer:PROC
EXTRN	PyBuffer_Release:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_SetStringInput DD imagerel _Unpickler_SetStringInput
	DD	imagerel _Unpickler_SetStringInput+150
	DD	imagerel $unwind$_Unpickler_SetStringInput
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_SetStringInput DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _Unpickler_SetStringInput
_TEXT	SEGMENT
self$ = 48
input$ = 56
_Unpickler_SetStringInput PROC				; COMDAT

; 862  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 863  :     if (self->buffer.buf != NULL)

  0000f	48 83 b9 88 00
	00 00 00	 cmp	 QWORD PTR [rcx+136], 0
  00017	48 8b f2	 mov	 rsi, rdx
  0001a	48 8b d9	 mov	 rbx, rcx
  0001d	74 0c		 je	 SHORT $LN2@Unpickler_@2

; 864  :         PyBuffer_Release(&self->buffer);

  0001f	48 81 c1 88 00
	00 00		 add	 rcx, 136		; 00000088H
  00026	e8 00 00 00 00	 call	 PyBuffer_Release
$LN2@Unpickler_@2:

; 865  :     if (PyObject_GetBuffer(input, &self->buffer, PyBUF_CONTIG_RO) < 0)

  0002b	48 8d 93 88 00
	00 00		 lea	 rdx, QWORD PTR [rbx+136]
  00032	41 b8 08 00 00
	00		 mov	 r8d, 8
  00038	48 8b ce	 mov	 rcx, rsi
  0003b	e8 00 00 00 00	 call	 PyObject_GetBuffer
  00040	85 c0		 test	 eax, eax
  00042	79 14		 jns	 SHORT $LN1@Unpickler_@2

; 866  :         return -1;

  00044	48 83 c8 ff	 or	 rax, -1

; 868  :     self->input_len = self->buffer.len;
; 869  :     self->next_read_idx = 0;
; 870  :     self->prefetched_idx = self->input_len;
; 871  :     return self->input_len;
; 872  : }

  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
$LN1@Unpickler_@2:

; 867  :     self->input_buffer = self->buffer.buf;

  00058	48 8b 83 88 00
	00 00		 mov	 rax, QWORD PTR [rbx+136]

; 868  :     self->input_len = self->buffer.len;
; 869  :     self->next_read_idx = 0;
; 870  :     self->prefetched_idx = self->input_len;
; 871  :     return self->input_len;
; 872  : }

  0005f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00064	48 c7 83 f0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+240], 0
  0006f	48 89 83 d8 00
	00 00		 mov	 QWORD PTR [rbx+216], rax
  00076	48 8b 83 98 00
	00 00		 mov	 rax, QWORD PTR [rbx+152]
  0007d	48 89 83 e8 00
	00 00		 mov	 QWORD PTR [rbx+232], rax
  00084	48 89 83 f8 00
	00 00		 mov	 QWORD PTR [rbx+248], rax
  0008b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00090	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00094	5f		 pop	 rdi
  00095	c3		 ret	 0
_Unpickler_SetStringInput ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EFFIKLCJ@n?$AA@				; `string'
EXTRN	PyObject_CallFunction:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_SkipConsumed DD imagerel _Unpickler_SkipConsumed
	DD	imagerel _Unpickler_SkipConsumed+91
	DD	imagerel $unwind$_Unpickler_SkipConsumed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_SkipConsumed DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_01EFFIKLCJ@n?$AA@
CONST	SEGMENT
??_C@_01EFFIKLCJ@n?$AA@ DB 'n', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Unpickler_SkipConsumed
_TEXT	SEGMENT
self$ = 48
_Unpickler_SkipConsumed PROC				; COMDAT

; 876  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 877  :     Py_ssize_t consumed = self->next_read_idx - self->prefetched_idx;

  00006	4c 8b 81 f0 00
	00 00		 mov	 r8, QWORD PTR [rcx+240]
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	4c 2b 81 f8 00
	00 00		 sub	 r8, QWORD PTR [rcx+248]

; 878  : 
; 879  :     if (consumed > 0) {

  00017	4d 85 c0	 test	 r8, r8
  0001a	7e 37		 jle	 SHORT $LN2@Unpickler_@3

; 880  :         PyObject *r;
; 881  :         assert(self->peek);  /* otherwise we did something wrong */
; 882  :         /* This makes an useless copy... */
; 883  :         r = PyObject_CallFunction(self->read, "n", consumed);

  0001c	48 8b 89 00 01
	00 00		 mov	 rcx, QWORD PTR [rcx+256]
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EFFIKLCJ@n?$AA@
  0002a	e8 00 00 00 00	 call	 PyObject_CallFunction

; 884  :         if (r == NULL)

  0002f	48 85 c0	 test	 rax, rax
  00032	75 09		 jne	 SHORT $LN1@Unpickler_@3

; 885  :             return -1;

  00034	83 c8 ff	 or	 eax, -1

; 890  : }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
$LN1@Unpickler_@3:

; 886  :         Py_DECREF(r);

  0003d	48 8b c8	 mov	 rcx, rax
  00040	e8 00 00 00 00	 call	 _Py_DecRef

; 887  :         self->prefetched_idx = self->next_read_idx;

  00045	4c 8b 9b f0 00
	00 00		 mov	 r11, QWORD PTR [rbx+240]
  0004c	4c 89 9b f8 00
	00 00		 mov	 QWORD PTR [rbx+248], r11
$LN2@Unpickler_@3:

; 888  :     }
; 889  :     return 0;

  00053	33 c0		 xor	 eax, eax

; 890  : }

  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5b		 pop	 rbx
  0005a	c3		 ret	 0
_Unpickler_SkipConsumed ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@HFLJBJMA@_Unpickler_ReadFromFile?$AA@	; `string'
EXTRN	PyBytes_ConcatAndDel:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyExc_NotImplementedError:QWORD
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_ReadFromFile DD imagerel _Unpickler_ReadFromFile
	DD	imagerel _Unpickler_ReadFromFile+364
	DD	imagerel $unwind$_Unpickler_ReadFromFile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_ReadFromFile DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0BI@HFLJBJMA@_Unpickler_ReadFromFile?$AA@
CONST	SEGMENT
??_C@_0BI@HFLJBJMA@_Unpickler_ReadFromFile?$AA@ DB '_Unpickler_ReadFromFi'
	DB	'le', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Unpickler_ReadFromFile
_TEXT	SEGMENT
self$ = 64
n$ = 72
data$ = 80
_Unpickler_ReadFromFile PROC				; COMDAT

; 910  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b da	 mov	 rbx, rdx
  00012	48 8b f9	 mov	 rdi, rcx

; 911  :     PyObject *data;
; 912  :     Py_ssize_t read_size, prefetched_size = 0;

  00015	33 f6		 xor	 esi, esi

; 913  : 
; 914  :     assert(self->read != NULL);
; 915  : 
; 916  :     if (_Unpickler_SkipConsumed(self) < 0)

  00017	e8 00 00 00 00	 call	 _Unpickler_SkipConsumed
  0001c	85 c0		 test	 eax, eax

; 917  :         return -1;

  0001e	78 6d		 js	 SHORT $LN21@Unpickler_@4

; 918  : 
; 919  :     if (n == READ_WHOLE_LINE)

  00020	48 83 fb ff	 cmp	 rbx, -1
  00024	75 18		 jne	 SHORT $LN15@Unpickler_@4

; 920  :         data = PyObject_Call(self->readline, empty_tuple, NULL);

  00026	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR empty_tuple
  0002d	48 8b 8f 08 01
	00 00		 mov	 rcx, QWORD PTR [rdi+264]
  00034	45 33 c0	 xor	 r8d, r8d
  00037	e8 00 00 00 00	 call	 PyObject_Call

; 921  :     else {

  0003c	eb 1f		 jmp	 SHORT $LN20@Unpickler_@4
$LN15@Unpickler_@4:

; 922  :         PyObject *len = PyLong_FromSsize_t(n);

  0003e	48 8b cb	 mov	 rcx, rbx
  00041	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 923  :         if (len == NULL)

  00046	48 85 c0	 test	 rax, rax

; 924  :             return -1;

  00049	74 42		 je	 SHORT $LN21@Unpickler_@4

; 925  :         data = _Unpickler_FastCall(self, self->read, len);

  0004b	48 8b 97 00 01
	00 00		 mov	 rdx, QWORD PTR [rdi+256]
  00052	4c 8b c0	 mov	 r8, rax
  00055	48 8b cf	 mov	 rcx, rdi
  00058	e8 00 00 00 00	 call	 _Unpickler_FastCall
$LN20@Unpickler_@4:
  0005d	48 89 44 24 50	 mov	 QWORD PTR data$[rsp], rax

; 926  :     }
; 927  :     if (data == NULL)

  00062	48 85 c0	 test	 rax, rax

; 928  :         return -1;

  00065	74 26		 je	 SHORT $LN21@Unpickler_@4

; 929  : 
; 930  :     /* Prefetch some data without advancing the file pointer, if possible */
; 931  :     if (self->peek) {

  00067	48 39 b7 10 01
	00 00		 cmp	 QWORD PTR [rdi+272], rsi
  0006e	0f 84 c3 00 00
	00		 je	 $LN1@Unpickler_@4

; 932  :         PyObject *len, *prefetched;
; 933  :         len = PyLong_FromSsize_t(PREFETCH);

  00074	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00079	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 934  :         if (len == NULL) {

  0007e	48 85 c0	 test	 rax, rax
  00081	75 1e		 jne	 SHORT $LN10@Unpickler_@4
$LN8@Unpickler_@4:

; 935  :             Py_DECREF(data);

  00083	48 8b 4c 24 50	 mov	 rcx, QWORD PTR data$[rsp]
  00088	e8 00 00 00 00	 call	 _Py_DecRef
$LN21@Unpickler_@4:

; 936  :             return -1;

  0008d	48 83 c8 ff	 or	 rax, -1

; 961  :     self->prefetched_idx = read_size;
; 962  :     return read_size;
; 963  : }

  00091	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00096	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0009b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009f	5f		 pop	 rdi
  000a0	c3		 ret	 0
$LN10@Unpickler_@4:

; 937  :         }
; 938  :         prefetched = _Unpickler_FastCall(self, self->peek, len);

  000a1	48 8b 97 10 01
	00 00		 mov	 rdx, QWORD PTR [rdi+272]
  000a8	4c 8b c0	 mov	 r8, rax
  000ab	48 8b cf	 mov	 rcx, rdi
  000ae	e8 00 00 00 00	 call	 _Unpickler_FastCall

; 939  :         if (prefetched == NULL) {

  000b3	48 85 c0	 test	 rax, rax
  000b6	75 60		 jne	 SHORT $LN9@Unpickler_@4

; 940  :             if (PyErr_ExceptionMatches(PyExc_NotImplementedError)) {

  000b8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  000bf	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  000c4	85 c0		 test	 eax, eax
  000c6	74 bb		 je	 SHORT $LN8@Unpickler_@4

; 941  :                 /* peek() is probably not supported by the given file object */
; 942  :                 PyErr_Clear();

  000c8	e8 00 00 00 00	 call	 PyErr_Clear

; 943  :                 Py_CLEAR(self->peek);

  000cd	4c 8b 8f 10 01
	00 00		 mov	 r9, QWORD PTR [rdi+272]
  000d4	4d 85 c9	 test	 r9, r9
  000d7	74 38		 je	 SHORT $LN19@Unpickler_@4
  000d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@HFLJBJMA@_Unpickler_ReadFromFile?$AA@
  000e7	41 b8 af 03 00
	00		 mov	 r8d, 943		; 000003afH
  000ed	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000f5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000fa	85 c0		 test	 eax, eax
  000fc	75 13		 jne	 SHORT $LN19@Unpickler_@4
  000fe	48 8b 8f 10 01
	00 00		 mov	 rcx, QWORD PTR [rdi+272]
  00105	48 89 b7 10 01
	00 00		 mov	 QWORD PTR [rdi+272], rsi
  0010c	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@Unpickler_@4:

; 944  :             }
; 945  :             else {
; 946  :                 Py_DECREF(data);
; 947  :                 return -1;
; 948  :             }
; 949  :         }
; 950  :         else {

  00111	48 8b 44 24 50	 mov	 rax, QWORD PTR data$[rsp]
  00116	eb 1f		 jmp	 SHORT $LN1@Unpickler_@4
$LN9@Unpickler_@4:

; 951  :             assert(PyBytes_Check(prefetched));
; 952  :             prefetched_size = PyBytes_GET_SIZE(prefetched);

  00118	48 8b 70 60	 mov	 rsi, QWORD PTR [rax+96]

; 953  :             PyBytes_ConcatAndDel(&data, prefetched);

  0011c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR data$[rsp]
  00121	48 8b d0	 mov	 rdx, rax
  00124	e8 00 00 00 00	 call	 PyBytes_ConcatAndDel

; 954  :             if (data == NULL)

  00129	48 8b 44 24 50	 mov	 rax, QWORD PTR data$[rsp]
  0012e	48 85 c0	 test	 rax, rax

; 955  :                 return -1;

  00131	0f 84 56 ff ff
	ff		 je	 $LN21@Unpickler_@4
$LN1@Unpickler_@4:

; 956  :         }
; 957  :     }
; 958  : 
; 959  :     read_size = _Unpickler_SetStringInput(self, data) - prefetched_size;

  00137	48 8b d0	 mov	 rdx, rax
  0013a	48 8b cf	 mov	 rcx, rdi
  0013d	e8 00 00 00 00	 call	 _Unpickler_SetStringInput

; 960  :     Py_DECREF(data);

  00142	48 8b 4c 24 50	 mov	 rcx, QWORD PTR data$[rsp]
  00147	48 8b d8	 mov	 rbx, rax
  0014a	48 2b de	 sub	 rbx, rsi
  0014d	e8 00 00 00 00	 call	 _Py_DecRef

; 961  :     self->prefetched_idx = read_size;
; 962  :     return read_size;
; 963  : }

  00152	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00157	48 89 9f f8 00
	00 00		 mov	 QWORD PTR [rdi+248], rbx
  0015e	48 8b c3	 mov	 rax, rbx
  00161	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00166	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0016a	5f		 pop	 rdi
  0016b	c3		 ret	 0
_Unpickler_ReadFromFile ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@OILLHPME@Ran?5out?5of?5input?$AA@	; `string'
EXTRN	PyExc_EOFError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_Read DD imagerel _Unpickler_Read
	DD	imagerel _Unpickler_Read+190
	DD	imagerel $unwind$_Unpickler_Read
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_Read DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BB@OILLHPME@Ran?5out?5of?5input?$AA@
CONST	SEGMENT
??_C@_0BB@OILLHPME@Ran?5out?5of?5input?$AA@ DB 'Ran out of input', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Unpickler_Read
_TEXT	SEGMENT
self$ = 48
s$ = 56
n$ = 64
_Unpickler_Read PROC					; COMDAT

; 980  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b d9	 mov	 rbx, rcx

; 981  :     Py_ssize_t num_read;
; 982  : 
; 983  :     if (self->next_read_idx + n <= self->input_len) {

  00012	48 8b 89 f0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+240]
  00019	49 8b f8	 mov	 rdi, r8
  0001c	4a 8d 04 01	 lea	 rax, QWORD PTR [rcx+r8]
  00020	48 8b f2	 mov	 rsi, rdx
  00023	48 3b 83 e8 00
	00 00		 cmp	 rax, QWORD PTR [rbx+232]
  0002a	7f 28		 jg	 SHORT $LN4@Unpickler_@5

; 984  :         *s = self->input_buffer + self->next_read_idx;

  0002c	48 8b 83 d8 00
	00 00		 mov	 rax, QWORD PTR [rbx+216]
  00033	4c 8d 0c 01	 lea	 r9, QWORD PTR [rcx+rax]

; 985  :         self->next_read_idx += n;
; 986  :         return n;

  00037	49 8b c0	 mov	 rax, r8
  0003a	4c 89 0a	 mov	 QWORD PTR [rdx], r9
  0003d	4c 01 83 f0 00
	00 00		 add	 QWORD PTR [rbx+240], r8

; 1000 :     self->next_read_idx = n;
; 1001 :     return n;
; 1002 : }

  00044	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00049	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
$LN4@Unpickler_@5:

; 987  :     }
; 988  :     if (!self->read) {

  00054	48 83 bb 00 01
	00 00 00	 cmp	 QWORD PTR [rbx+256], 0
  0005c	75 27		 jne	 SHORT $LN3@Unpickler_@5
$LN8@Unpickler_@5:

; 989  :         PyErr_Format(PyExc_EOFError, "Ran out of input");

  0005e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_EOFError
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@OILLHPME@Ran?5out?5of?5input?$AA@
  0006c	e8 00 00 00 00	 call	 PyErr_Format
$LN7@Unpickler_@5:

; 990  :         return -1;

  00071	48 83 c8 ff	 or	 rax, -1

; 1000 :     self->next_read_idx = n;
; 1001 :     return n;
; 1002 : }

  00075	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
$LN3@Unpickler_@5:

; 991  :     }
; 992  :     num_read = _Unpickler_ReadFromFile(self, n);

  00085	49 8b d0	 mov	 rdx, r8
  00088	48 8b cb	 mov	 rcx, rbx
  0008b	e8 00 00 00 00	 call	 _Unpickler_ReadFromFile

; 993  :     if (num_read < 0)

  00090	48 85 c0	 test	 rax, rax

; 994  :         return -1;

  00093	78 dc		 js	 SHORT $LN7@Unpickler_@5

; 995  :     if (num_read < n) {

  00095	48 3b c7	 cmp	 rax, rdi

; 996  :         PyErr_Format(PyExc_EOFError, "Ran out of input");
; 997  :         return -1;

  00098	7c c4		 jl	 SHORT $LN8@Unpickler_@5

; 998  :     }
; 999  :     *s = self->input_buffer;

  0009a	48 8b 83 d8 00
	00 00		 mov	 rax, QWORD PTR [rbx+216]
  000a1	48 89 06	 mov	 QWORD PTR [rsi], rax

; 1000 :     self->next_read_idx = n;
; 1001 :     return n;
; 1002 : }

  000a4	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000a9	48 89 bb f0 00
	00 00		 mov	 QWORD PTR [rbx+240], rdi
  000b0	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b5	48 8b c7	 mov	 rax, rdi
  000b8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bc	5f		 pop	 rdi
  000bd	c3		 ret	 0
_Unpickler_Read ENDP
_TEXT	ENDS
EXTRN	PyMem_Realloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_CopyLine DD imagerel _Unpickler_CopyLine
	DD	imagerel _Unpickler_CopyLine+127
	DD	imagerel $unwind$_Unpickler_CopyLine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_CopyLine DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _Unpickler_CopyLine
_TEXT	SEGMENT
self$ = 48
line$ = 56
len$ = 64
result$ = 72
_Unpickler_CopyLine PROC				; COMDAT

; 1007 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	48 8b f1	 mov	 rsi, rcx

; 1008 :     char *input_line = PyMem_Realloc(self->input_line, len + 1);

  0001d	48 8b 89 e0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+224]
  00024	4c 8b e2	 mov	 r12, rdx
  00027	49 8d 50 01	 lea	 rdx, QWORD PTR [r8+1]
  0002b	49 8b e9	 mov	 rbp, r9
  0002e	49 8b f8	 mov	 rdi, r8
  00031	e8 00 00 00 00	 call	 PyMem_Realloc
  00036	48 8b d8	 mov	 rbx, rax

; 1009 :     if (input_line == NULL)

  00039	48 85 c0	 test	 rax, rax
  0003c	75 06		 jne	 SHORT $LN1@Unpickler_@6

; 1010 :         return -1;

  0003e	48 83 c8 ff	 or	 rax, -1
  00042	eb 20		 jmp	 SHORT $LN2@Unpickler_@6
$LN1@Unpickler_@6:

; 1011 : 
; 1012 :     memcpy(input_line, line, len);

  00044	4c 8b c7	 mov	 r8, rdi
  00047	49 8b d4	 mov	 rdx, r12
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	e8 00 00 00 00	 call	 memcpy

; 1013 :     input_line[len] = '\0';

  00052	c6 04 3b 00	 mov	 BYTE PTR [rbx+rdi], 0

; 1014 :     self->input_line = input_line;

  00056	48 89 9e e0 00
	00 00		 mov	 QWORD PTR [rsi+224], rbx

; 1015 :     *result = self->input_line;

  0005d	48 89 5d 00	 mov	 QWORD PTR [rbp], rbx

; 1016 :     return len;

  00061	48 8b c7	 mov	 rax, rdi
$LN2@Unpickler_@6:

; 1017 : }

  00064	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00069	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0006e	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00073	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00078	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007c	41 5c		 pop	 r12
  0007e	c3		 ret	 0
_Unpickler_CopyLine ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_Readline DD imagerel _Unpickler_Readline
	DD	imagerel _Unpickler_Readline+230
	DD	imagerel $unwind$_Unpickler_Readline
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_Readline DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _Unpickler_Readline
_TEXT	SEGMENT
self$ = 48
result$ = 56
_Unpickler_Readline PROC				; COMDAT

; 1025 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 1026 :     Py_ssize_t i, num_read;
; 1027 : 
; 1028 :     for (i = self->next_read_idx; i < self->input_len; i++) {

  0000d	48 8b 89 f0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+240]
  00014	48 8b fa	 mov	 rdi, rdx
  00017	4c 8b c9	 mov	 r9, rcx
  0001a	48 3b 8b e8 00
	00 00		 cmp	 rcx, QWORD PTR [rbx+232]
  00021	7d 20		 jge	 SHORT $LN4@Unpickler_@7
  00023	48 8b 83 d8 00
	00 00		 mov	 rax, QWORD PTR [rbx+216]
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL6@Unpickler_@7:

; 1029 :         if (self->input_buffer[i] == '\n') {

  00030	42 80 3c 08 0a	 cmp	 BYTE PTR [rax+r9], 10
  00035	74 36		 je	 SHORT $LN10@Unpickler_@7

; 1026 :     Py_ssize_t i, num_read;
; 1027 : 
; 1028 :     for (i = self->next_read_idx; i < self->input_len; i++) {

  00037	49 ff c1	 inc	 r9
  0003a	4c 3b 8b e8 00
	00 00		 cmp	 r9, QWORD PTR [rbx+232]
  00041	7c ed		 jl	 SHORT $LL6@Unpickler_@7
$LN4@Unpickler_@7:

; 1034 :         }
; 1035 :     }
; 1036 :     if (self->read) {

  00043	48 83 bb 00 01
	00 00 00	 cmp	 QWORD PTR [rbx+256], 0
  0004b	74 73		 je	 SHORT $LN2@Unpickler_@7

; 1037 :         num_read = _Unpickler_ReadFromFile(self, READ_WHOLE_LINE);

  0004d	48 83 ca ff	 or	 rdx, -1
  00051	48 8b cb	 mov	 rcx, rbx
  00054	e8 00 00 00 00	 call	 _Unpickler_ReadFromFile

; 1038 :         if (num_read < 0)

  00059	48 85 c0	 test	 rax, rax
  0005c	79 3c		 jns	 SHORT $LN1@Unpickler_@7

; 1039 :             return -1;

  0005e	48 83 c8 ff	 or	 rax, -1

; 1049 :     return num_read;
; 1050 : }

  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5f		 pop	 rdi
  0006c	c3		 ret	 0
$LN10@Unpickler_@7:

; 1030 :             char *line_start = self->input_buffer + self->next_read_idx;
; 1031 :             num_read = i - self->next_read_idx + 1;

  0006d	4d 8b c1	 mov	 r8, r9
  00070	48 8d 14 08	 lea	 rdx, QWORD PTR [rax+rcx]

; 1032 :             self->next_read_idx = i + 1;

  00074	49 8d 41 01	 lea	 rax, QWORD PTR [r9+1]
  00078	4c 2b c1	 sub	 r8, rcx

; 1033 :             return _Unpickler_CopyLine(self, line_start, num_read, result);

  0007b	4c 8b cf	 mov	 r9, rdi
  0007e	48 8b cb	 mov	 rcx, rbx
  00081	49 ff c0	 inc	 r8
  00084	48 89 83 f0 00
	00 00		 mov	 QWORD PTR [rbx+240], rax

; 1049 :     return num_read;
; 1050 : }

  0008b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00090	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00094	5f		 pop	 rdi
  00095	e9 00 00 00 00	 jmp	 _Unpickler_CopyLine
$LN1@Unpickler_@7:

; 1040 :         self->next_read_idx = num_read;
; 1041 :         return _Unpickler_CopyLine(self, self->input_buffer, num_read, result);

  0009a	48 8b 93 d8 00
	00 00		 mov	 rdx, QWORD PTR [rbx+216]
  000a1	4c 8b cf	 mov	 r9, rdi
  000a4	4c 8b c0	 mov	 r8, rax
  000a7	48 8b cb	 mov	 rcx, rbx
  000aa	48 89 83 f0 00
	00 00		 mov	 QWORD PTR [rbx+240], rax

; 1049 :     return num_read;
; 1050 : }

  000b1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ba	5f		 pop	 rdi
  000bb	e9 00 00 00 00	 jmp	 _Unpickler_CopyLine
$LN2@Unpickler_@7:

; 1042 :     }
; 1043 : 
; 1044 :     /* If we get here, we've run off the end of the input string. Return the
; 1045 :        remaining string and let the caller figure it out. */
; 1046 :     *result = self->input_buffer + self->next_read_idx;

  000c0	48 03 8b d8 00
	00 00		 add	 rcx, QWORD PTR [rbx+216]

; 1047 :     num_read = i - self->next_read_idx;

  000c7	49 8b c1	 mov	 rax, r9
  000ca	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  000cd	48 2b 83 f0 00
	00 00		 sub	 rax, QWORD PTR [rbx+240]

; 1048 :     self->next_read_idx = i;

  000d4	4c 89 8b f0 00
	00 00		 mov	 QWORD PTR [rbx+240], r9

; 1049 :     return num_read;
; 1050 : }

  000db	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000e0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e4	5f		 pop	 rdi
  000e5	c3		 ret	 0
_Unpickler_Readline ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_ResizeMemoList DD imagerel _Unpickler_ResizeMemoList
	DD	imagerel _Unpickler_ResizeMemoList+165
	DD	imagerel $unwind$_Unpickler_ResizeMemoList
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_ResizeMemoList DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _Unpickler_ResizeMemoList
_TEXT	SEGMENT
self$ = 48
new_size$ = 56
_Unpickler_ResizeMemoList PROC				; COMDAT

; 1056 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 1057 :     Py_ssize_t i;
; 1058 :     PyObject **memo;
; 1059 : 
; 1060 :     assert(new_size > self->memo_size);
; 1061 : 
; 1062 :     memo = PyMem_REALLOC(self->memo, new_size * sizeof(PyObject *));

  00010	e8 00 00 00 00	 call	 _Py_PXCTX
  00015	85 c0		 test	 eax, eax
  00017	74 13		 je	 SHORT $LN11@Unpickler_@8
  00019	48 8b 4f 68	 mov	 rcx, QWORD PTR [rdi+104]
  0001d	48 8d 14 dd 00
	00 00 00	 lea	 rdx, QWORD PTR [rbx*8]
  00025	e8 00 00 00 00	 call	 _PxMem_Realloc
  0002a	eb 2d		 jmp	 SHORT $LN10@Unpickler_@8
$LN11@Unpickler_@8:
  0002c	48 8d 04 dd 00
	00 00 00	 lea	 rax, QWORD PTR [rbx*8]
  00034	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  0003e	48 3b c1	 cmp	 rax, rcx
  00041	77 4f		 ja	 SHORT $LN15@Unpickler_@8
  00043	48 8b 4f 68	 mov	 rcx, QWORD PTR [rdi+104]
  00047	48 85 c0	 test	 rax, rax
  0004a	ba 01 00 00 00	 mov	 edx, 1
  0004f	48 0f 45 d0	 cmovne	 rdx, rax
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
$LN10@Unpickler_@8:

; 1063 :     if (memo == NULL) {

  00059	48 85 c0	 test	 rax, rax
  0005c	74 34		 je	 SHORT $LN15@Unpickler_@8

; 1065 :         return -1;
; 1066 :     }
; 1067 :     self->memo = memo;
; 1068 :     for (i = self->memo_size; i < new_size; i++)

  0005e	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  00062	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax
  00066	48 3b cb	 cmp	 rcx, rbx
  00069	7d 16		 jge	 SHORT $LN1@Unpickler_@8
  0006b	33 d2		 xor	 edx, edx
  0006d	0f 1f 00	 npad	 3
$LL3@Unpickler_@8:

; 1069 :         self->memo[i] = NULL;

  00070	48 8b 47 68	 mov	 rax, QWORD PTR [rdi+104]
  00074	48 ff c1	 inc	 rcx
  00077	48 89 54 c8 f8	 mov	 QWORD PTR [rax+rcx*8-8], rdx
  0007c	48 3b cb	 cmp	 rcx, rbx
  0007f	7c ef		 jl	 SHORT $LL3@Unpickler_@8
$LN1@Unpickler_@8:

; 1070 :     self->memo_size = new_size;

  00081	48 89 5f 70	 mov	 QWORD PTR [rdi+112], rbx

; 1071 :     return 0;

  00085	33 c0		 xor	 eax, eax

; 1072 : }

  00087	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00090	5f		 pop	 rdi
  00091	c3		 ret	 0
$LN15@Unpickler_@8:

; 1064 :         PyErr_NoMemory();

  00092	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1072 : }

  00097	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009c	83 c8 ff	 or	 eax, -1
  0009f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a3	5f		 pop	 rdi
  000a4	c3		 ret	 0
_Unpickler_ResizeMemoList ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _Unpickler_MemoGet
_TEXT	SEGMENT
self$ = 8
idx$ = 16
_Unpickler_MemoGet PROC					; COMDAT

; 1078 :     if (idx < 0 || idx >= self->memo_size)

  00000	48 85 d2	 test	 rdx, rdx
  00003	78 0f		 js	 SHORT $LN1@Unpickler_@9
  00005	48 3b 51 70	 cmp	 rdx, QWORD PTR [rcx+112]
  00009	7d 09		 jge	 SHORT $LN1@Unpickler_@9

; 1080 : 
; 1081 :     return self->memo[idx];

  0000b	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
  0000f	48 8b 04 d0	 mov	 rax, QWORD PTR [rax+rdx*8]

; 1082 : }

  00013	c3		 ret	 0
$LN1@Unpickler_@9:

; 1079 :         return NULL;

  00014	33 c0		 xor	 eax, eax

; 1082 : }

  00016	c3		 ret	 0
_Unpickler_MemoGet ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Unpickler_MemoPut DD imagerel _Unpickler_MemoPut
	DD	imagerel _Unpickler_MemoPut+292
	DD	imagerel $unwind$_Unpickler_MemoPut
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_MemoPut DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT _Unpickler_MemoPut
_TEXT	SEGMENT
self$ = 64
idx$ = 72
value$ = 80
_Unpickler_MemoPut PROC					; COMDAT

; 1088 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 1089 :     PyObject *old_item;
; 1090 : 
; 1091 :     if (idx >= self->memo_size) {

  00018	48 3b 51 70	 cmp	 rdx, QWORD PTR [rcx+112]
  0001c	7c 1f		 jl	 SHORT $LN5@Unpickler_@10

; 1092 :         if (_Unpickler_ResizeMemoList(self, idx * 2) < 0)

  0001e	48 03 d2	 add	 rdx, rdx
  00021	e8 00 00 00 00	 call	 _Unpickler_ResizeMemoList
  00026	85 c0		 test	 eax, eax
  00028	79 13		 jns	 SHORT $LN5@Unpickler_@10

; 1093 :             return -1;

  0002a	83 c8 ff	 or	 eax, -1

; 1101 : }

  0002d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00032	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00037	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003b	5f		 pop	 rdi
  0003c	c3		 ret	 0
$LN5@Unpickler_@10:

; 1094 :         assert(idx < self->memo_size);
; 1095 :     }
; 1096 :     Py_INCREF(value);

  0003d	e8 00 00 00 00	 call	 _Py_PXCTX
  00042	85 c0		 test	 eax, eax
  00044	75 32		 jne	 SHORT $LN10@Unpickler_@10
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00054	4c 8b cf	 mov	 r9, rdi
  00057	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0005d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00065	e8 00 00 00 00	 call	 _PyParallel_Guard
  0006a	85 c0		 test	 eax, eax
  0006c	75 06		 jne	 SHORT $LN9@Unpickler_@10
  0006e	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00072	74 04		 je	 SHORT $LN10@Unpickler_@10
$LN9@Unpickler_@10:
  00074	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN10@Unpickler_@10:

; 1097 :     old_item = self->memo[idx];

  00078	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  0007c	48 8b 1c f0	 mov	 rbx, QWORD PTR [rax+rsi*8]

; 1098 :     self->memo[idx] = value;

  00080	48 89 3c f0	 mov	 QWORD PTR [rax+rsi*8], rdi

; 1099 :     Py_XDECREF(old_item);

  00084	48 85 db	 test	 rbx, rbx
  00087	0f 84 85 00 00
	00		 je	 $LN3@Unpickler_@10
  0008d	e8 00 00 00 00	 call	 _Py_PXCTX
  00092	85 c0		 test	 eax, eax
  00094	75 7c		 jne	 SHORT $LN3@Unpickler_@10
  00096	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0009a	a8 20		 test	 al, 32			; 00000020H
  0009c	75 6c		 jne	 SHORT $LN17@Unpickler_@10
  0009e	84 c0		 test	 al, al
  000a0	78 68		 js	 SHORT $LN17@Unpickler_@10
  000a2	a8 02		 test	 al, 2
  000a4	75 6c		 jne	 SHORT $LN3@Unpickler_@10
  000a6	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000aa	75 66		 jne	 SHORT $LN3@Unpickler_@10
  000ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000ba	4c 8b cb	 mov	 r9, rbx
  000bd	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000c3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000cb	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d0	48 8b cb	 mov	 rcx, rbx
  000d3	85 c0		 test	 eax, eax
  000d5	74 17		 je	 SHORT $LN22@Unpickler_@10
  000d7	e8 00 00 00 00	 call	 _Px_Dealloc

; 1100 :     return 0;

  000dc	33 c0		 xor	 eax, eax

; 1101 : }

  000de	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e3	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000e8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ec	5f		 pop	 rdi
  000ed	c3		 ret	 0

; 1099 :     Py_XDECREF(old_item);

$LN22@Unpickler_@10:
  000ee	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000f2	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 1100 :     return 0;

  000f8	33 c0		 xor	 eax, eax

; 1101 : }

  000fa	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ff	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00104	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00108	5f		 pop	 rdi
  00109	c3		 ret	 0

; 1099 :     Py_XDECREF(old_item);

$LN17@Unpickler_@10:
  0010a	48 8b cb	 mov	 rcx, rbx
  0010d	e8 00 00 00 00	 call	 Px_DecRef
$LN3@Unpickler_@10:

; 1101 : }

  00112	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00117	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0011c	33 c0		 xor	 eax, eax
  0011e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00122	5f		 pop	 rdi
  00123	c3		 ret	 0
_Unpickler_MemoPut ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_NewMemo DD imagerel _Unpickler_NewMemo
	DD	imagerel _Unpickler_NewMemo+117
	DD	imagerel $unwind$_Unpickler_NewMemo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_NewMemo DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _Unpickler_NewMemo
_TEXT	SEGMENT
new_size$ = 48
_Unpickler_NewMemo PROC					; COMDAT

; 1105 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 1106 :     PyObject **memo = PyMem_MALLOC(new_size * sizeof(PyObject *));

  0000d	e8 00 00 00 00	 call	 _Py_PXCTX
  00012	48 c1 e3 03	 shl	 rbx, 3
  00016	85 c0		 test	 eax, eax
  00018	74 0a		 je	 SHORT $LN8@Unpickler_@11
  0001a	48 8b cb	 mov	 rcx, rbx
  0001d	e8 00 00 00 00	 call	 _PxMem_Malloc
  00022	eb 21		 jmp	 SHORT $LN11@Unpickler_@11
$LN8@Unpickler_@11:
  00024	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0002e	48 3b d8	 cmp	 rbx, rax
  00031	77 35		 ja	 SHORT $LN10@Unpickler_@11
  00033	48 85 db	 test	 rbx, rbx
  00036	b9 01 00 00 00	 mov	 ecx, 1
  0003b	48 0f 45 cb	 cmovne	 rcx, rbx
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN11@Unpickler_@11:
  00045	48 8b f8	 mov	 rdi, rax

; 1107 :     if (memo == NULL)

  00048	48 85 c0	 test	 rax, rax
  0004b	74 1b		 je	 SHORT $LN10@Unpickler_@11

; 1109 :     memset(memo, 0, new_size * sizeof(PyObject *));

  0004d	4c 8b c3	 mov	 r8, rbx
  00050	33 d2		 xor	 edx, edx
  00052	48 8b c8	 mov	 rcx, rax
  00055	e8 00 00 00 00	 call	 memset

; 1110 :     return memo;

  0005a	48 8b c7	 mov	 rax, rdi

; 1111 : }

  0005d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
$LN10@Unpickler_@11:

; 1108 :         return NULL;

  00068	33 c0		 xor	 eax, eax

; 1111 : }

  0006a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00073	5f		 pop	 rdi
  00074	c3		 ret	 0
_Unpickler_NewMemo ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Unpickler_MemoCleanup DD imagerel _Unpickler_MemoCleanup
	DD	imagerel _Unpickler_MemoCleanup+19
	DD	imagerel $unwind$_Unpickler_MemoCleanup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_Unpickler_MemoCleanup DD imagerel _Unpickler_MemoCleanup+19
	DD	imagerel _Unpickler_MemoCleanup+45
	DD	imagerel $chain$0$_Unpickler_MemoCleanup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_Unpickler_MemoCleanup DD imagerel _Unpickler_MemoCleanup+45
	DD	imagerel _Unpickler_MemoCleanup+170
	DD	imagerel $chain$1$_Unpickler_MemoCleanup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_Unpickler_MemoCleanup DD imagerel _Unpickler_MemoCleanup+170
	DD	imagerel _Unpickler_MemoCleanup+187
	DD	imagerel $chain$2$_Unpickler_MemoCleanup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_Unpickler_MemoCleanup DD imagerel _Unpickler_MemoCleanup+187
	DD	imagerel _Unpickler_MemoCleanup+209
	DD	imagerel $chain$3$_Unpickler_MemoCleanup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_Unpickler_MemoCleanup DD 021H
	DD	imagerel _Unpickler_MemoCleanup
	DD	imagerel _Unpickler_MemoCleanup+19
	DD	imagerel $unwind$_Unpickler_MemoCleanup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_Unpickler_MemoCleanup DD 021H
	DD	imagerel _Unpickler_MemoCleanup+19
	DD	imagerel _Unpickler_MemoCleanup+45
	DD	imagerel $chain$0$_Unpickler_MemoCleanup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_Unpickler_MemoCleanup DD 020521H
	DD	083405H
	DD	imagerel _Unpickler_MemoCleanup+19
	DD	imagerel _Unpickler_MemoCleanup+45
	DD	imagerel $chain$0$_Unpickler_MemoCleanup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_Unpickler_MemoCleanup DD 020521H
	DD	097405H
	DD	imagerel _Unpickler_MemoCleanup
	DD	imagerel _Unpickler_MemoCleanup+19
	DD	imagerel $unwind$_Unpickler_MemoCleanup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_MemoCleanup DD 020601H
	DD	060025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT _Unpickler_MemoCleanup
_TEXT	SEGMENT
self$ = 64
_Unpickler_MemoCleanup PROC				; COMDAT

; 1116 : {

  00000	40 56		 push	 rsi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1117 :     Py_ssize_t i;
; 1118 :     PyObject **memo = self->memo;

  00006	48 8b 71 68	 mov	 rsi, QWORD PTR [rcx+104]

; 1119 : 
; 1120 :     if (self->memo == NULL)

  0000a	48 85 f6	 test	 rsi, rsi
  0000d	0f 84 b8 00 00
	00		 je	 $LN11@Unpickler_@12

; 1121 :         return;
; 1122 :     self->memo = NULL;
; 1123 :     i = self->memo_size;
; 1124 :     while (--i >= 0) {

  00013	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00018	48 8b 79 70	 mov	 rdi, QWORD PTR [rcx+112]
  0001c	48 c7 41 68 00
	00 00 00	 mov	 QWORD PTR [rcx+104], 0
  00024	48 ff cf	 dec	 rdi
  00027	0f 88 7d 00 00
	00		 js	 $LN5@Unpickler_@12
  0002d	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
$LL6@Unpickler_@12:
  00032	48 8b 1c fe	 mov	 rbx, QWORD PTR [rsi+rdi*8]

; 1125 :         Py_XDECREF(memo[i]);

  00036	48 85 db	 test	 rbx, rbx
  00039	74 65		 je	 SHORT $LN3@Unpickler_@12
  0003b	e8 00 00 00 00	 call	 _Py_PXCTX
  00040	85 c0		 test	 eax, eax
  00042	75 5c		 jne	 SHORT $LN3@Unpickler_@12
  00044	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00048	a8 20		 test	 al, 32			; 00000020H
  0004a	75 4c		 jne	 SHORT $LN16@Unpickler_@12
  0004c	84 c0		 test	 al, al
  0004e	78 48		 js	 SHORT $LN16@Unpickler_@12
  00050	a8 02		 test	 al, 2
  00052	75 4c		 jne	 SHORT $LN3@Unpickler_@12
  00054	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00058	75 46		 jne	 SHORT $LN3@Unpickler_@12
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00068	4c 8b cb	 mov	 r9, rbx
  0006b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00071	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00079	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007e	48 8b cb	 mov	 rcx, rbx
  00081	85 c0		 test	 eax, eax
  00083	74 07		 je	 SHORT $LN21@Unpickler_@12
  00085	e8 00 00 00 00	 call	 _Px_Dealloc
  0008a	eb 14		 jmp	 SHORT $LN3@Unpickler_@12
$LN21@Unpickler_@12:
  0008c	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00090	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00096	eb 08		 jmp	 SHORT $LN3@Unpickler_@12
$LN16@Unpickler_@12:
  00098	48 8b cb	 mov	 rcx, rbx
  0009b	e8 00 00 00 00	 call	 Px_DecRef
$LN3@Unpickler_@12:

; 1121 :         return;
; 1122 :     self->memo = NULL;
; 1123 :     i = self->memo_size;
; 1124 :     while (--i >= 0) {

  000a0	48 ff cf	 dec	 rdi
  000a3	79 8d		 jns	 SHORT $LL6@Unpickler_@12
  000a5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN5@Unpickler_@12:

; 1126 :     }
; 1127 :     PyMem_FREE(memo);

  000aa	e8 00 00 00 00	 call	 _Py_PXCTX
  000af	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000b4	48 8b ce	 mov	 rcx, rsi
  000b7	85 c0		 test	 eax, eax
  000b9	74 0a		 je	 SHORT $LN10@Unpickler_@12

; 1128 : }

  000bb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000bf	5e		 pop	 rsi
  000c0	e9 00 00 00 00	 jmp	 _PxMem_Free
$LN10@Unpickler_@12:

; 1126 :     }
; 1127 :     PyMem_FREE(memo);

  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN11@Unpickler_@12:

; 1128 : }

  000cb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cf	5e		 pop	 rsi
  000d0	c3		 ret	 0
_Unpickler_MemoCleanup ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_New DD imagerel _Unpickler_New
	DD	imagerel _Unpickler_New+237
	DD	imagerel $unwind$_Unpickler_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_New DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _Unpickler_New
_TEXT	SEGMENT
_Unpickler_New PROC					; COMDAT

; 1132 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1133 :     UnpicklerObject *self;
; 1134 : 
; 1135 :     self = PyObject_GC_New(UnpicklerObject, &Unpickler_Type);

  00006	e8 00 00 00 00	 call	 _Py_PXCTX
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Unpickler_Type
  00012	85 c0		 test	 eax, eax
  00014	74 07		 je	 SHORT $LN6@Unpickler_@13
  00016	e8 00 00 00 00	 call	 _PxObject_New
  0001b	eb 05		 jmp	 SHORT $LN8@Unpickler_@13
$LN6@Unpickler_@13:
  0001d	e8 00 00 00 00	 call	 _PyObject_GC_New
$LN8@Unpickler_@13:
  00022	48 8b d8	 mov	 rbx, rax

; 1136 :     if (self == NULL)

  00025	48 85 c0	 test	 rax, rax

; 1137 :         return NULL;

  00028	74 16		 je	 SHORT $LN9@Unpickler_@13

; 1138 : 
; 1139 :     self->stack = (Pdata *)Pdata_New();

  0002a	e8 00 00 00 00	 call	 Pdata_New
  0002f	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 1140 :     if (self->stack == NULL) {

  00033	48 85 c0	 test	 rax, rax
  00036	75 10		 jne	 SHORT $LN2@Unpickler_@13
$LN10@Unpickler_@13:

; 1141 :         Py_DECREF(self);

  00038	48 8b cb	 mov	 rcx, rbx
  0003b	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@Unpickler_@13:

; 1142 :         return NULL;

  00040	33 c0		 xor	 eax, eax

; 1172 : }

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5b		 pop	 rbx
  00047	c3		 ret	 0
$LN2@Unpickler_@13:

; 1143 :     }
; 1144 :     memset(&self->buffer, 0, sizeof(Py_buffer));

  00048	33 d2		 xor	 edx, edx
  0004a	48 8d 8b 88 00
	00 00		 lea	 rcx, QWORD PTR [rbx+136]
  00051	44 8d 42 50	 lea	 r8d, QWORD PTR [rdx+80]
  00055	e8 00 00 00 00	 call	 memset

; 1145 : 
; 1146 :     self->memo_size = 32;
; 1147 :     self->memo = _Unpickler_NewMemo(self->memo_size);

  0005a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0005f	48 c7 43 70 20
	00 00 00	 mov	 QWORD PTR [rbx+112], 32	; 00000020H
  00067	e8 00 00 00 00	 call	 _Unpickler_NewMemo
  0006c	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax

; 1148 :     if (self->memo == NULL) {

  00070	48 85 c0	 test	 rax, rax

; 1149 :         Py_DECREF(self);
; 1150 :         return NULL;

  00073	74 c3		 je	 SHORT $LN10@Unpickler_@13

; 1151 :     }
; 1152 : 
; 1153 :     self->arg = NULL;

  00075	33 c0		 xor	 eax, eax
  00077	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 1154 :     self->pers_func = NULL;

  0007b	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax

; 1155 :     self->input_buffer = NULL;

  00082	48 89 83 d8 00
	00 00		 mov	 QWORD PTR [rbx+216], rax

; 1156 :     self->input_line = NULL;

  00089	48 89 83 e0 00
	00 00		 mov	 QWORD PTR [rbx+224], rax

; 1157 :     self->input_len = 0;

  00090	48 89 83 e8 00
	00 00		 mov	 QWORD PTR [rbx+232], rax

; 1158 :     self->next_read_idx = 0;

  00097	48 89 83 f0 00
	00 00		 mov	 QWORD PTR [rbx+240], rax

; 1159 :     self->prefetched_idx = 0;

  0009e	48 89 83 f8 00
	00 00		 mov	 QWORD PTR [rbx+248], rax

; 1160 :     self->read = NULL;

  000a5	48 89 83 00 01
	00 00		 mov	 QWORD PTR [rbx+256], rax

; 1161 :     self->readline = NULL;

  000ac	48 89 83 08 01
	00 00		 mov	 QWORD PTR [rbx+264], rax

; 1162 :     self->peek = NULL;

  000b3	48 89 83 10 01
	00 00		 mov	 QWORD PTR [rbx+272], rax

; 1163 :     self->encoding = NULL;

  000ba	48 89 83 18 01
	00 00		 mov	 QWORD PTR [rbx+280], rax

; 1164 :     self->errors = NULL;

  000c1	48 89 83 20 01
	00 00		 mov	 QWORD PTR [rbx+288], rax

; 1165 :     self->marks = NULL;

  000c8	48 89 83 28 01
	00 00		 mov	 QWORD PTR [rbx+296], rax

; 1166 :     self->num_marks = 0;

  000cf	48 89 83 30 01
	00 00		 mov	 QWORD PTR [rbx+304], rax

; 1167 :     self->marks_size = 0;

  000d6	48 89 83 38 01
	00 00		 mov	 QWORD PTR [rbx+312], rax

; 1168 :     self->proto = 0;

  000dd	48 89 83 40 01
	00 00		 mov	 QWORD PTR [rbx+320], rax

; 1169 :     self->fix_imports = 0;
; 1170 : 
; 1171 :     return self;

  000e4	48 8b c3	 mov	 rax, rbx

; 1172 : }

  000e7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000eb	5b		 pop	 rbx
  000ec	c3		 ret	 0
_Unpickler_New ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@JHFEHNHC@_Unpickler_SetInputStream?$AA@ ; `string'
PUBLIC	??_C@_0DA@COIFLMFN@file?5must?5have?5?8read?8?5and?5?8readl@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_SetInputStream DD imagerel _Unpickler_SetInputStream
	DD	imagerel _Unpickler_SetInputStream+433
	DD	imagerel $unwind$_Unpickler_SetInputStream
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_SetInputStream DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0BK@JHFEHNHC@_Unpickler_SetInputStream?$AA@
CONST	SEGMENT
??_C@_0BK@JHFEHNHC@_Unpickler_SetInputStream?$AA@ DB '_Unpickler_SetInput'
	DB	'Stream', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@COIFLMFN@file?5must?5have?5?8read?8?5and?5?8readl@
CONST	SEGMENT
??_C@_0DA@COIFLMFN@file?5must?5have?5?8read?8?5and?5?8readl@ DB 'file mus'
	DB	't have ''read'' and ''readline'' attributes', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Unpickler_SetInputStream
_TEXT	SEGMENT
self$ = 64
file$ = 72
_Unpickler_SetInputStream PROC				; COMDAT

; 1178 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1179 :     _Py_IDENTIFIER(peek);
; 1180 :     _Py_IDENTIFIER(read);
; 1181 :     _Py_IDENTIFIER(readline);
; 1182 : 
; 1183 :     self->peek = _PyObject_GetAttrId(file, &PyId_peek);

  0000f	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00016	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0001f	48 8b fa	 mov	 rdi, rdx
  00022	4a 8b 34 c0	 mov	 rsi, QWORD PTR [rax+r8*8]
  00026	48 8b d9	 mov	 rbx, rcx
  00029	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_peek@?1??_Unpickler_SetInputStream@@9@9
  0002e	48 03 d6	 add	 rdx, rsi
  00031	48 8b cf	 mov	 rcx, rdi
  00034	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00039	48 89 83 10 01
	00 00		 mov	 QWORD PTR [rbx+272], rax

; 1184 :     if (self->peek == NULL) {

  00040	48 85 c0	 test	 rax, rax
  00043	75 19		 jne	 SHORT $LN16@Unpickler_@14

; 1185 :         if (PyErr_ExceptionMatches(PyExc_AttributeError))

  00045	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0004c	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00051	85 c0		 test	 eax, eax
  00053	0f 84 45 01 00
	00		 je	 $LN3@Unpickler_@14

; 1186 :             PyErr_Clear();

  00059	e8 00 00 00 00	 call	 PyErr_Clear
$LN16@Unpickler_@14:

; 1187 :         else
; 1188 :             return -1;
; 1189 :     }
; 1190 :     self->read = _PyObject_GetAttrId(file, &PyId_read);

  0005e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_read@?1??_Unpickler_SetInputStream@@9@9
  00063	48 8b cf	 mov	 rcx, rdi
  00066	48 03 d6	 add	 rdx, rsi
  00069	e8 00 00 00 00	 call	 _PyObject_GetAttrId

; 1191 :     self->readline = _PyObject_GetAttrId(file, &PyId_readline);

  0006e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_readline@?1??_Unpickler_SetInputStream@@9@9
  00073	48 8b cf	 mov	 rcx, rdi
  00076	48 03 d6	 add	 rdx, rsi
  00079	48 89 83 00 01
	00 00		 mov	 QWORD PTR [rbx+256], rax
  00080	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00085	48 89 83 08 01
	00 00		 mov	 QWORD PTR [rbx+264], rax

; 1192 :     if (self->readline == NULL || self->read == NULL) {

  0008c	48 85 c0	 test	 rax, rax
  0008f	74 1c		 je	 SHORT $LN14@Unpickler_@14
  00091	48 83 bb 00 01
	00 00 00	 cmp	 QWORD PTR [rbx+256], 0
  00099	74 12		 je	 SHORT $LN14@Unpickler_@14

; 1199 :         return -1;
; 1200 :     }
; 1201 :     return 0;

  0009b	33 c0		 xor	 eax, eax

; 1202 : }

  0009d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a2	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000a7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ab	5f		 pop	 rdi
  000ac	c3		 ret	 0
$LN14@Unpickler_@14:

; 1193 :         if (PyErr_ExceptionMatches(PyExc_AttributeError))

  000ad	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  000b4	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  000b9	85 c0		 test	 eax, eax
  000bb	74 13		 je	 SHORT $LN12@Unpickler_@14

; 1194 :             PyErr_SetString(PyExc_TypeError,
; 1195 :                             "file must have 'read' and 'readline' attributes");

  000bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@COIFLMFN@file?5must?5have?5?8read?8?5and?5?8readl@
  000cb	e8 00 00 00 00	 call	 PyErr_SetString
$LN12@Unpickler_@14:

; 1196 :         Py_CLEAR(self->read);

  000d0	4c 8b 8b 00 01
	00 00		 mov	 r9, QWORD PTR [rbx+256]
  000d7	33 ff		 xor	 edi, edi
  000d9	4d 85 c9	 test	 r9, r9
  000dc	74 38		 je	 SHORT $LN11@Unpickler_@14
  000de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  000e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@JHFEHNHC@_Unpickler_SetInputStream?$AA@
  000ec	41 b8 ac 04 00
	00		 mov	 r8d, 1196		; 000004acH
  000f2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000fa	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ff	85 c0		 test	 eax, eax
  00101	75 13		 jne	 SHORT $LN11@Unpickler_@14
  00103	48 8b 8b 00 01
	00 00		 mov	 rcx, QWORD PTR [rbx+256]
  0010a	48 89 bb 00 01
	00 00		 mov	 QWORD PTR [rbx+256], rdi
  00111	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@Unpickler_@14:

; 1197 :         Py_CLEAR(self->readline);

  00116	4c 8b 8b 08 01
	00 00		 mov	 r9, QWORD PTR [rbx+264]
  0011d	4d 85 c9	 test	 r9, r9
  00120	74 38		 je	 SHORT $LN7@Unpickler_@14
  00122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@JHFEHNHC@_Unpickler_SetInputStream?$AA@
  00130	41 b8 ad 04 00
	00		 mov	 r8d, 1197		; 000004adH
  00136	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0013e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00143	85 c0		 test	 eax, eax
  00145	75 13		 jne	 SHORT $LN7@Unpickler_@14
  00147	48 8b 8b 08 01
	00 00		 mov	 rcx, QWORD PTR [rbx+264]
  0014e	48 89 bb 08 01
	00 00		 mov	 QWORD PTR [rbx+264], rdi
  00155	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@Unpickler_@14:

; 1198 :         Py_CLEAR(self->peek);

  0015a	4c 8b 8b 10 01
	00 00		 mov	 r9, QWORD PTR [rbx+272]
  00161	4d 85 c9	 test	 r9, r9
  00164	74 38		 je	 SHORT $LN3@Unpickler_@14
  00166	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@JHFEHNHC@_Unpickler_SetInputStream?$AA@
  00174	41 b8 ae 04 00
	00		 mov	 r8d, 1198		; 000004aeH
  0017a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00182	e8 00 00 00 00	 call	 _PyParallel_Guard
  00187	85 c0		 test	 eax, eax
  00189	75 13		 jne	 SHORT $LN3@Unpickler_@14
  0018b	48 8b 8b 10 01
	00 00		 mov	 rcx, QWORD PTR [rbx+272]
  00192	48 89 bb 10 01
	00 00		 mov	 QWORD PTR [rbx+272], rdi
  00199	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@Unpickler_@14:

; 1202 : }

  0019e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001a3	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  001a8	83 c8 ff	 or	 eax, -1
  001ab	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001af	5f		 pop	 rdi
  001b0	c3		 ret	 0
_Unpickler_SetInputStream ENDP
_TEXT	ENDS
PUBLIC	??_C@_06OLFOGHEN@strict?$AA@			; `string'
PUBLIC	??_C@_05CCNLIHFO@ASCII?$AA@			; `string'
EXTRN	__imp_strdup:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Unpickler_SetInputEncoding DD imagerel _Unpickler_SetInputEncoding
	DD	imagerel _Unpickler_SetInputEncoding+117
	DD	imagerel $unwind$_Unpickler_SetInputEncoding
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Unpickler_SetInputEncoding DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_06OLFOGHEN@strict?$AA@
CONST	SEGMENT
??_C@_06OLFOGHEN@strict?$AA@ DB 'strict', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCNLIHFO@ASCII?$AA@
CONST	SEGMENT
??_C@_05CCNLIHFO@ASCII?$AA@ DB 'ASCII', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Unpickler_SetInputEncoding
_TEXT	SEGMENT
self$ = 48
encoding$ = 56
errors$ = 64
_Unpickler_SetInputEncoding PROC			; COMDAT

; 1210 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 1211 :     if (encoding == NULL)

  0000d	48 85 d2	 test	 rdx, rdx
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05CCNLIHFO@ASCII?$AA@
  00017	48 0f 45 ca	 cmovne	 rcx, rdx

; 1212 :         encoding = "ASCII";
; 1213 :     if (errors == NULL)

  0001b	4d 85 c0	 test	 r8, r8
  0001e	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  00025	49 0f 45 d8	 cmovne	 rbx, r8

; 1214 :         errors = "strict";
; 1215 : 
; 1216 :     self->encoding = strdup(encoding);

  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup

; 1217 :     self->errors = strdup(errors);

  0002f	48 8b cb	 mov	 rcx, rbx
  00032	48 89 87 18 01
	00 00		 mov	 QWORD PTR [rdi+280], rax
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup

; 1218 :     if (self->encoding == NULL || self->errors == NULL) {

  0003f	48 83 bf 18 01
	00 00 00	 cmp	 QWORD PTR [rdi+280], 0
  00047	48 89 87 20 01
	00 00		 mov	 QWORD PTR [rdi+288], rax
  0004e	74 12		 je	 SHORT $LN1@Unpickler_@15
  00050	48 85 c0	 test	 rax, rax
  00053	74 0d		 je	 SHORT $LN1@Unpickler_@15

; 1220 :         return -1;
; 1221 :     }
; 1222 :     return 0;

  00055	33 c0		 xor	 eax, eax

; 1223 : }

  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5f		 pop	 rdi
  00061	c3		 ret	 0
$LN1@Unpickler_@15:

; 1219 :         PyErr_NoMemory();

  00062	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1223 : }

  00067	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006c	83 c8 ff	 or	 eax, -1
  0006f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00073	5f		 pop	 rdi
  00074	c3		 ret	 0
_Unpickler_SetInputEncoding ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@JBGEENKP@memo?5id?5too?5large?5for?5LONG_BINGE@ ; `string'
PUBLIC	??_C@_04GDNBDEFH@?$CFId?6?$AA@			; `string'
EXTRN	PyOS_snprintf:PROC
EXTRN	PyErr_SetObject:PROC
EXTRN	PyExc_KeyError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$memo_get DD imagerel memo_get
	DD	imagerel memo_get+81
	DD	imagerel $unwind$memo_get
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$memo_get DD imagerel memo_get+81
	DD	imagerel memo_get+117
	DD	imagerel $chain$0$memo_get
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$memo_get DD imagerel memo_get+117
	DD	imagerel memo_get+265
	DD	imagerel $chain$1$memo_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$memo_get DD 021H
	DD	imagerel memo_get
	DD	imagerel memo_get+81
	DD	imagerel $unwind$memo_get
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$memo_get DD 020521H
	DD	0a7405H
	DD	imagerel memo_get
	DD	imagerel memo_get+81
	DD	imagerel $unwind$memo_get
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memo_get DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT ??_C@_0CC@JBGEENKP@memo?5id?5too?5large?5for?5LONG_BINGE@
CONST	SEGMENT
??_C@_0CC@JBGEENKP@memo?5id?5too?5large?5for?5LONG_BINGE@ DB 'memo id too'
	DB	' large for LONG_BINGET', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GDNBDEFH@?$CFId?6?$AA@
CONST	SEGMENT
??_C@_04GDNBDEFH@?$CFId?6?$AA@ DB '%Id', 0aH, 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT memo_get
_TEXT	SEGMENT
pdata$ = 32
self$ = 80
key$ = 88
memo_get PROC						; COMDAT

; 1228 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8b d9	 mov	 rbx, rcx

; 1229 :     Py_ssize_t *value;
; 1230 :     char pdata[30];
; 1231 :     Py_ssize_t len;
; 1232 : 
; 1233 :     value = PyMemoTable_Get(self->memo, key);

  00009	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0000d	e8 00 00 00 00	 call	 PyMemoTable_Get
  00012	48 8b c8	 mov	 rcx, rax

; 1234 :     if (value == NULL)  {

  00015	48 85 c0	 test	 rax, rax
  00018	75 15		 jne	 SHORT $LN8@memo_get

; 1235 :         PyErr_SetObject(PyExc_KeyError, key);

  0001a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  00021	e8 00 00 00 00	 call	 PyErr_SetObject

; 1262 :             return -1;

  00026	83 c8 ff	 or	 eax, -1

; 1267 :         return -1;
; 1268 : 
; 1269 :     return 0;
; 1270 : }

  00029	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0002d	5b		 pop	 rbx
  0002e	c3		 ret	 0
$LN8@memo_get:

; 1236 :         return -1;
; 1237 :     }
; 1238 : 
; 1239 :     if (!self->bin) {

  0002f	83 bb a4 00 00
	00 00		 cmp	 DWORD PTR [rbx+164], 0
  00036	75 3d		 jne	 SHORT $LN7@memo_get

; 1240 :         pdata[0] = GET;

  00038	c6 44 24 20 67	 mov	 BYTE PTR pdata$[rsp], 103 ; 00000067H

; 1241 :         PyOS_snprintf(pdata + 1, sizeof(pdata) - 1,
; 1242 :                       "%" PY_FORMAT_SIZE_T "d\n", *value);

  0003d	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  00040	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04GDNBDEFH@?$CFId?6?$AA@
  00047	48 8d 4c 24 21	 lea	 rcx, QWORD PTR pdata$[rsp+1]
  0004c	ba 1d 00 00 00	 mov	 edx, 29
  00051	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00056	e8 00 00 00 00	 call	 PyOS_snprintf

; 1243 :         len = strlen(pdata);

  0005b	48 83 c9 ff	 or	 rcx, -1
  0005f	33 c0		 xor	 eax, eax
  00061	48 8d 7c 24 20	 lea	 rdi, QWORD PTR pdata$[rsp]
  00066	f2 ae		 repne scasb
  00068	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  0006d	48 f7 d1	 not	 rcx
  00070	48 ff c9	 dec	 rcx

; 1244 :     }
; 1245 :     else {

  00073	eb 57		 jmp	 SHORT $LN2@memo_get
$LN7@memo_get:

; 1246 :         if (*value < 256) {

  00075	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00078	48 3d 00 01 00
	00		 cmp	 rax, 256		; 00000100H
  0007e	7d 13		 jge	 SHORT $LN5@memo_get

; 1247 :             pdata[0] = BINGET;

  00080	c6 44 24 20 68	 mov	 BYTE PTR pdata$[rsp], 104 ; 00000068H

; 1248 :             pdata[1] = (unsigned char)(*value & 0xff);

  00085	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 1249 :             len = 2;

  00088	b9 02 00 00 00	 mov	 ecx, 2
  0008d	88 44 24 21	 mov	 BYTE PTR pdata$[rsp+1], al
  00091	eb 39		 jmp	 SHORT $LN2@memo_get
$LN5@memo_get:

; 1250 :         }
; 1251 :         else if (*value <= 0xffffffffL) {

  00093	ba ff ff ff ff	 mov	 edx, -1
  00098	48 3b c2	 cmp	 rax, rdx
  0009b	7f 50		 jg	 SHORT $LN3@memo_get

; 1252 :             pdata[0] = LONG_BINGET;

  0009d	c6 44 24 20 6a	 mov	 BYTE PTR pdata$[rsp], 106 ; 0000006aH

; 1253 :             pdata[1] = (unsigned char)(*value & 0xff);

  000a2	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  000a5	88 44 24 21	 mov	 BYTE PTR pdata$[rsp+1], al

; 1254 :             pdata[2] = (unsigned char)((*value >> 8) & 0xff);

  000a9	8b 01		 mov	 eax, DWORD PTR [rcx]
  000ab	48 c1 f8 08	 sar	 rax, 8
  000af	88 44 24 22	 mov	 BYTE PTR pdata$[rsp+2], al

; 1255 :             pdata[3] = (unsigned char)((*value >> 16) & 0xff);

  000b3	8b 01		 mov	 eax, DWORD PTR [rcx]
  000b5	48 c1 f8 10	 sar	 rax, 16
  000b9	88 44 24 23	 mov	 BYTE PTR pdata$[rsp+3], al

; 1256 :             pdata[4] = (unsigned char)((*value >> 24) & 0xff);

  000bd	8b 01		 mov	 eax, DWORD PTR [rcx]

; 1257 :             len = 5;

  000bf	b9 05 00 00 00	 mov	 ecx, 5
  000c4	48 c1 f8 18	 sar	 rax, 24
  000c8	88 44 24 24	 mov	 BYTE PTR pdata$[rsp+4], al
$LN2@memo_get:

; 1263 :         }
; 1264 :     }
; 1265 : 
; 1266 :     if (_Pickler_Write(self, pdata, len) < 0)

  000cc	4c 8b c1	 mov	 r8, rcx
  000cf	48 8d 54 24 20	 lea	 rdx, QWORD PTR pdata$[rsp]
  000d4	48 8b cb	 mov	 rcx, rbx
  000d7	e8 00 00 00 00	 call	 _Pickler_Write
  000dc	33 c9		 xor	 ecx, ecx
  000de	48 85 c0	 test	 rax, rax
  000e1	0f 99 c1	 setns	 cl
  000e4	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 1267 :         return -1;
; 1268 : 
; 1269 :     return 0;
; 1270 : }

  000e7	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000eb	5b		 pop	 rbx
  000ec	c3		 ret	 0
$LN3@memo_get:

; 1258 :         }
; 1259 :         else { /* unlikely */
; 1260 :             PyErr_SetString(PicklingError,
; 1261 :                             "memo id too large for LONG_BINGET");

  000ed	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  000f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@JBGEENKP@memo?5id?5too?5large?5for?5LONG_BINGE@
  000fb	e8 00 00 00 00	 call	 PyErr_SetString

; 1262 :             return -1;

  00100	83 c8 ff	 or	 eax, -1

; 1267 :         return -1;
; 1268 : 
; 1269 :     return 0;
; 1270 : }

  00103	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00107	5b		 pop	 rbx
  00108	c3		 ret	 0
memo_get ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@EAIMIBPJ@memo?5id?5too?5large?5for?5LONG_BINPU@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$memo_put DD imagerel memo_put
	DD	imagerel memo_put+40
	DD	imagerel $unwind$memo_put
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$memo_put DD imagerel memo_put+40
	DD	imagerel memo_put+252
	DD	imagerel $chain$0$memo_put
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$memo_put DD imagerel memo_put+252
	DD	imagerel memo_put+290
	DD	imagerel $chain$2$memo_put
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$memo_put DD 020021H
	DD	0a7400H
	DD	imagerel memo_put
	DD	imagerel memo_put+40
	DD	imagerel $unwind$memo_put
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$memo_put DD 020521H
	DD	0a7405H
	DD	imagerel memo_put
	DD	imagerel memo_put+40
	DD	imagerel $unwind$memo_put
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memo_put DD 040a01H
	DD	0b340aH
	DD	06006720aH
xdata	ENDS
;	COMDAT ??_C@_0CC@EAIMIBPJ@memo?5id?5too?5large?5for?5LONG_BINPU@
CONST	SEGMENT
??_C@_0CC@EAIMIBPJ@memo?5id?5too?5large?5for?5LONG_BINPU@ DB 'memo id too'
	DB	' large for LONG_BINPUT', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT memo_put
_TEXT	SEGMENT
pdata$ = 32
self$ = 80
obj$ = 88
memo_put PROC						; COMDAT

; 1276 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1277 :     Py_ssize_t x;
; 1278 :     char pdata[30];
; 1279 :     Py_ssize_t len;
; 1280 :     int status = 0;

  0000a	33 f6		 xor	 esi, esi
  0000c	48 8b d9	 mov	 rbx, rcx

; 1281 : 
; 1282 :     if (self->fast)

  0000f	39 b1 b0 00 00
	00		 cmp	 DWORD PTR [rcx+176], esi
  00015	74 0d		 je	 SHORT $LN10@memo_put

; 1283 :         return 0;

  00017	33 c0		 xor	 eax, eax

; 1325 : }

  00019	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0001e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00022	5e		 pop	 rsi
  00023	c3		 ret	 0
$LN10@memo_put:

; 1284 : 
; 1285 :     x = PyMemoTable_Size(self->memo);

  00024	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00028	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0002d	e8 00 00 00 00	 call	 PyMemoTable_Size

; 1286 :     if (PyMemoTable_Set(self->memo, obj, x) < 0)

  00032	4c 8b c0	 mov	 r8, rax
  00035	48 8b f8	 mov	 rdi, rax
  00038	e8 00 00 00 00	 call	 PyMemoTable_Set
  0003d	85 c0		 test	 eax, eax
  0003f	0f 88 a2 00 00
	00		 js	 $error$21281

; 1287 :         goto error;
; 1288 : 
; 1289 :     if (!self->bin) {

  00045	39 b3 a4 00 00
	00		 cmp	 DWORD PTR [rbx+164], esi
  0004b	75 33		 jne	 SHORT $LN8@memo_put

; 1290 :         pdata[0] = PUT;
; 1291 :         PyOS_snprintf(pdata + 1, sizeof(pdata) - 1,
; 1292 :                       "%" PY_FORMAT_SIZE_T "d\n", x);

  0004d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04GDNBDEFH@?$CFId?6?$AA@
  00054	48 8d 4c 24 21	 lea	 rcx, QWORD PTR pdata$[rsp+1]
  00059	4c 8b cf	 mov	 r9, rdi
  0005c	ba 1d 00 00 00	 mov	 edx, 29
  00061	c6 44 24 20 70	 mov	 BYTE PTR pdata$[rsp], 112 ; 00000070H
  00066	e8 00 00 00 00	 call	 PyOS_snprintf

; 1293 :         len = strlen(pdata);

  0006b	48 83 c9 ff	 or	 rcx, -1
  0006f	33 c0		 xor	 eax, eax
  00071	48 8d 7c 24 20	 lea	 rdi, QWORD PTR pdata$[rsp]
  00076	f2 ae		 repne scasb
  00078	48 f7 d1	 not	 rcx
  0007b	48 ff c9	 dec	 rcx

; 1294 :     }
; 1295 :     else {

  0007e	eb 52		 jmp	 SHORT $LN3@memo_put
$LN8@memo_put:

; 1296 :         if (x < 256) {

  00080	48 81 ff 00 01
	00 00		 cmp	 rdi, 256		; 00000100H
  00087	7d 11		 jge	 SHORT $LN6@memo_put

; 1297 :             pdata[0] = BINPUT;

  00089	c6 44 24 20 71	 mov	 BYTE PTR pdata$[rsp], 113 ; 00000071H

; 1298 :             pdata[1] = (unsigned char)x;

  0008e	40 88 7c 24 21	 mov	 BYTE PTR pdata$[rsp+1], dil

; 1299 :             len = 2;

  00093	b9 02 00 00 00	 mov	 ecx, 2
  00098	eb 38		 jmp	 SHORT $LN3@memo_put
$LN6@memo_put:

; 1300 :         }
; 1301 :         else if (x <= 0xffffffffL) {

  0009a	b8 ff ff ff ff	 mov	 eax, -1
  0009f	48 3b f8	 cmp	 rdi, rax
  000a2	7f 58		 jg	 SHORT $LN4@memo_put

; 1302 :             pdata[0] = LONG_BINPUT;
; 1303 :             pdata[1] = (unsigned char)(x & 0xff);
; 1304 :             pdata[2] = (unsigned char)((x >> 8) & 0xff);

  000a4	48 8b c7	 mov	 rax, rdi
  000a7	40 88 7c 24 21	 mov	 BYTE PTR pdata$[rsp+1], dil
  000ac	c6 44 24 20 72	 mov	 BYTE PTR pdata$[rsp], 114 ; 00000072H
  000b1	48 c1 f8 08	 sar	 rax, 8

; 1305 :             pdata[3] = (unsigned char)((x >> 16) & 0xff);
; 1306 :             pdata[4] = (unsigned char)((x >> 24) & 0xff);
; 1307 :             len = 5;

  000b5	b9 05 00 00 00	 mov	 ecx, 5
  000ba	88 44 24 22	 mov	 BYTE PTR pdata$[rsp+2], al
  000be	48 8b c7	 mov	 rax, rdi
  000c1	48 c1 f8 10	 sar	 rax, 16
  000c5	48 c1 ff 18	 sar	 rdi, 24
  000c9	40 88 7c 24 24	 mov	 BYTE PTR pdata$[rsp+4], dil
  000ce	88 44 24 23	 mov	 BYTE PTR pdata$[rsp+3], al
$LN3@memo_put:

; 1312 :             return -1;
; 1313 :         }
; 1314 :     }
; 1315 : 
; 1316 :     if (_Pickler_Write(self, pdata, len) < 0)

  000d2	4c 8b c1	 mov	 r8, rcx
  000d5	48 8d 54 24 20	 lea	 rdx, QWORD PTR pdata$[rsp]
  000da	48 8b cb	 mov	 rcx, rbx
  000dd	e8 00 00 00 00	 call	 _Pickler_Write
  000e2	48 85 c0	 test	 rax, rax
  000e5	79 03		 jns	 SHORT $LN2@memo_put
$error$21281:

; 1317 :         goto error;
; 1318 : 
; 1319 :     if (0) {
; 1320 :   error:
; 1321 :         status = -1;

  000e7	83 ce ff	 or	 esi, -1
$LN2@memo_put:

; 1322 :     }
; 1323 : 
; 1324 :     return status;

  000ea	8b c6		 mov	 eax, esi
  000ec	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 1325 : }

  000f1	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000f6	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000fa	5e		 pop	 rsi
  000fb	c3		 ret	 0
$LN4@memo_put:

; 1308 :         }
; 1309 :         else { /* unlikely */
; 1310 :             PyErr_SetString(PicklingError,
; 1311 :                             "memo id too large for LONG_BINPUT");

  000fc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  00103	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@EAIMIBPJ@memo?5id?5too?5large?5for?5LONG_BINPU@
  0010a	e8 00 00 00 00	 call	 PyErr_SetString
  0010f	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 1325 : }

  00114	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00119	83 c8 ff	 or	 eax, -1
  0011c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00120	5e		 pop	 rsi
  00121	c3		 ret	 0
memo_put ENDP
_TEXT	ENDS
PUBLIC	??_C@_07DFGEOAEG@modules?$AA@			; `string'
PUBLIC	??_C@_08EMKMIFM@__main__?$AA@			; `string'
PUBLIC	??_C@_0L@LNCJCPDP@__module__?$AA@		; `string'
EXTRN	PyObject_RichCompareBool:PROC
EXTRN	PyDict_Next:PROC
EXTRN	PySys_GetObject:PROC
EXTRN	PyObject_GetAttr:PROC
EXTRN	PyUnicode_InternFromString:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$whichmodule DD imagerel whichmodule
	DD	imagerel whichmodule+161
	DD	imagerel $unwind$whichmodule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$whichmodule DD imagerel whichmodule+161
	DD	imagerel whichmodule+191
	DD	imagerel $chain$0$whichmodule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$whichmodule DD imagerel whichmodule+191
	DD	imagerel whichmodule+446
	DD	imagerel $chain$3$whichmodule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$whichmodule DD imagerel whichmodule+446
	DD	imagerel whichmodule+453
	DD	imagerel $chain$4$whichmodule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$whichmodule DD imagerel whichmodule+453
	DD	imagerel whichmodule+472
	DD	imagerel $chain$5$whichmodule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$whichmodule DD imagerel whichmodule+472
	DD	imagerel whichmodule+489
	DD	imagerel $chain$7$whichmodule
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$whichmodule DD 040021H
	DD	086400H
	DD	0c3400H
	DD	imagerel whichmodule
	DD	imagerel whichmodule+161
	DD	imagerel $unwind$whichmodule
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$whichmodule DD 040021H
	DD	086400H
	DD	0c3400H
	DD	imagerel whichmodule
	DD	imagerel whichmodule+161
	DD	imagerel $unwind$whichmodule
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$whichmodule DD 021H
	DD	imagerel whichmodule
	DD	imagerel whichmodule+161
	DD	imagerel $unwind$whichmodule
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$whichmodule DD 041921H
	DD	0c3419H
	DD	086400H
	DD	imagerel whichmodule
	DD	imagerel whichmodule+161
	DD	imagerel $unwind$whichmodule
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$whichmodule DD 020521H
	DD	086405H
	DD	imagerel whichmodule
	DD	imagerel whichmodule+161
	DD	imagerel $unwind$whichmodule
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$whichmodule DD 030701H
	DD	070038207H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_07DFGEOAEG@modules?$AA@
CONST	SEGMENT
??_C@_07DFGEOAEG@modules?$AA@ DB 'modules', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EMKMIFM@__main__?$AA@
CONST	SEGMENT
??_C@_08EMKMIFM@__main__?$AA@ DB '__main__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LNCJCPDP@__module__?$AA@
CONST	SEGMENT
??_C@_0L@LNCJCPDP@__module__?$AA@ DB '__module__', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT whichmodule
_TEXT	SEGMENT
i$ = 48
global$ = 96
global_name$ = 104
module_name$ = 112
module$ = 120
whichmodule PROC					; COMDAT

; 1329 : {

  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00007	48 8b ea	 mov	 rbp, rdx

; 1330 :     Py_ssize_t i, j;
; 1331 :     static PyObject *module_str = NULL;
; 1332 :     static PyObject *main_str = NULL;
; 1333 :     PyObject *module_name;
; 1334 :     PyObject *modules_dict;
; 1335 :     PyObject *module;
; 1336 :     PyObject *obj;
; 1337 : 
; 1338 :     if (module_str == NULL) {

  0000a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?module_str@?1??whichmodule@@9@9
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 85 d2	 test	 rdx, rdx
  00017	75 40		 jne	 SHORT $LN14@whichmodul

; 1339 :         module_str = PyUnicode_InternFromString("__module__");

  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LNCJCPDP@__module__?$AA@
  00020	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00025	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?module_str@?1??whichmodule@@9@9, rax

; 1340 :         if (module_str == NULL)

  0002c	48 85 c0	 test	 rax, rax
  0002f	75 09		 jne	 SHORT $LN15@whichmodul
$LN33@whichmodul:

; 1341 :             return NULL;

  00031	33 c0		 xor	 eax, eax

; 1401 : }

  00033	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00037	5f		 pop	 rdi
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
$LN15@whichmodul:

; 1342 :         main_str = PyUnicode_InternFromString("__main__");

  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08EMKMIFM@__main__?$AA@
  00041	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00046	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?main_str@?1??whichmodule@@9@9, rax

; 1343 :         if (main_str == NULL)

  0004d	48 85 c0	 test	 rax, rax

; 1344 :             return NULL;

  00050	74 df		 je	 SHORT $LN33@whichmodul
  00052	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?module_str@?1??whichmodule@@9@9
$LN14@whichmodul:

; 1345 :     }
; 1346 : 
; 1347 :     module_name = PyObject_GetAttr(global, module_str);

  00059	48 8b cf	 mov	 rcx, rdi
  0005c	e8 00 00 00 00	 call	 PyObject_GetAttr

; 1348 : 
; 1349 :     /* In some rare cases (e.g., bound methods of extension types),
; 1350 :        __module__ can be None. If it is so, then search sys.modules
; 1351 :        for the module of global.  */
; 1352 :     if (module_name == Py_None) {

  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00068	48 89 44 24 70	 mov	 QWORD PTR module_name$[rsp], rax
  0006d	48 3b c1	 cmp	 rax, rcx
  00070	75 0a		 jne	 SHORT $LN13@whichmodul

; 1353 :         Py_DECREF(module_name);

  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 _Py_DecRef

; 1354 :         goto search;

  0007a	eb 1e		 jmp	 SHORT $search$21326
$LN13@whichmodul:

; 1355 :     }
; 1356 : 
; 1357 :     if (module_name) {

  0007c	48 85 c0	 test	 rax, rax

; 1358 :         return module_name;

  0007f	0f 85 39 01 00
	00		 jne	 $LN17@whichmodul

; 1359 :     }
; 1360 :     if (PyErr_ExceptionMatches(PyExc_AttributeError))

  00085	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0008c	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00091	85 c0		 test	 eax, eax
  00093	74 9c		 je	 SHORT $LN33@whichmodul

; 1361 :         PyErr_Clear();

  00095	e8 00 00 00 00	 call	 PyErr_Clear
$search$21326:

; 1362 :     else
; 1363 :         return NULL;
; 1364 : 
; 1365 :   search:
; 1366 :     modules_dict = PySys_GetObject("modules");

  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07DFGEOAEG@modules?$AA@
  000a1	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  000a6	e8 00 00 00 00	 call	 PySys_GetObject
  000ab	48 8b f0	 mov	 rsi, rax

; 1367 :     if (modules_dict == NULL)

  000ae	48 85 c0	 test	 rax, rax
  000b1	75 0c		 jne	 SHORT $LN9@whichmodul
  000b3	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 1401 : }

  000b8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bc	5f		 pop	 rdi
  000bd	5d		 pop	 rbp
  000be	c3		 ret	 0
$LN9@whichmodul:

; 1368 :         return NULL;
; 1369 : 
; 1370 :     i = 0;

  000bf	33 c0		 xor	 eax, eax

; 1371 :     module_name = NULL;
; 1372 :     while ((j = PyDict_Next(modules_dict, &i, &module_name, &module))) {

  000c1	4c 8d 4c 24 78	 lea	 r9, QWORD PTR module$[rsp]
  000c6	4c 8d 44 24 70	 lea	 r8, QWORD PTR module_name$[rsp]
  000cb	48 8d 54 24 30	 lea	 rdx, QWORD PTR i$[rsp]
  000d0	48 8b ce	 mov	 rcx, rsi
  000d3	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  000d8	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
  000dd	48 89 44 24 70	 mov	 QWORD PTR module_name$[rsp], rax
  000e2	e8 00 00 00 00	 call	 PyDict_Next
  000e7	48 63 d8	 movsxd	 rbx, eax
  000ea	85 c0		 test	 eax, eax
  000ec	74 7a		 je	 SHORT $LN30@whichmodul
  000ee	66 90		 npad	 2
$LL8@whichmodul:

; 1373 :         if (PyObject_RichCompareBool(module_name, main_str, Py_EQ) == 1)

  000f0	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?main_str@?1??whichmodule@@9@9
  000f7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR module_name$[rsp]
  000fc	41 b8 02 00 00
	00		 mov	 r8d, 2
  00102	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00107	83 f8 01	 cmp	 eax, 1
  0010a	74 3e		 je	 SHORT $LN26@whichmodul

; 1374 :             continue;
; 1375 : 
; 1376 :         obj = PyObject_GetAttr(module, global_name);

  0010c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR module$[rsp]
  00111	48 8b d5	 mov	 rdx, rbp
  00114	e8 00 00 00 00	 call	 PyObject_GetAttr

; 1377 :         if (obj == NULL) {

  00119	48 85 c0	 test	 rax, rax
  0011c	75 1b		 jne	 SHORT $LN5@whichmodul

; 1378 :             if (PyErr_ExceptionMatches(PyExc_AttributeError))

  0011e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00125	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0012a	85 c0		 test	 eax, eax
  0012c	0f 84 93 00 00
	00		 je	 $LN4@whichmodul

; 1379 :                 PyErr_Clear();

  00132	e8 00 00 00 00	 call	 PyErr_Clear

; 1382 :             continue;

  00137	eb 11		 jmp	 SHORT $LN26@whichmodul
$LN5@whichmodul:

; 1383 :         }
; 1384 : 
; 1385 :         if (obj != global) {
; 1386 :             Py_DECREF(obj);

  00139	48 8b c8	 mov	 rcx, rax
  0013c	48 3b c7	 cmp	 rax, rdi
  0013f	0f 84 93 00 00
	00		 je	 $LN2@whichmodul
  00145	e8 00 00 00 00	 call	 _Py_DecRef
$LN26@whichmodul:

; 1371 :     module_name = NULL;
; 1372 :     while ((j = PyDict_Next(modules_dict, &i, &module_name, &module))) {

  0014a	4c 8d 4c 24 78	 lea	 r9, QWORD PTR module$[rsp]
  0014f	4c 8d 44 24 70	 lea	 r8, QWORD PTR module_name$[rsp]
  00154	48 8d 54 24 30	 lea	 rdx, QWORD PTR i$[rsp]
  00159	48 8b ce	 mov	 rcx, rsi
  0015c	e8 00 00 00 00	 call	 PyDict_Next
  00161	48 63 d8	 movsxd	 rbx, eax
  00164	85 c0		 test	 eax, eax
  00166	75 88		 jne	 SHORT $LL8@whichmodul
$LN30@whichmodul:

; 1396 :         module_name = main_str;

  00168	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?main_str@?1??whichmodule@@9@9
  0016f	48 89 5c 24 70	 mov	 QWORD PTR module_name$[rsp], rbx
$LN1@whichmodul:

; 1397 :     }
; 1398 : 
; 1399 :     Py_INCREF(module_name);

  00174	e8 00 00 00 00	 call	 _Py_PXCTX
  00179	85 c0		 test	 eax, eax
  0017b	75 32		 jne	 SHORT $LN20@whichmodul
  0017d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00184	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0018b	4c 8b cb	 mov	 r9, rbx
  0018e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00194	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0019c	e8 00 00 00 00	 call	 _PyParallel_Guard
  001a1	85 c0		 test	 eax, eax
  001a3	75 06		 jne	 SHORT $LN19@whichmodul
  001a5	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  001a9	74 04		 je	 SHORT $LN20@whichmodul
$LN19@whichmodul:
  001ab	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN20@whichmodul:

; 1400 :     return module_name;

  001af	48 8b 44 24 70	 mov	 rax, QWORD PTR module_name$[rsp]
  001b4	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  001b9	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
$LN17@whichmodul:

; 1401 : }

  001be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c2	5f		 pop	 rdi
  001c3	5d		 pop	 rbp
  001c4	c3		 ret	 0
$LN4@whichmodul:
  001c5	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  001ca	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 1380 :             else
; 1381 :                 return NULL;

  001cf	33 c0		 xor	 eax, eax

; 1401 : }

  001d1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001d5	5f		 pop	 rdi
  001d6	5d		 pop	 rbp
  001d7	c3		 ret	 0
$LN2@whichmodul:

; 1387 :             continue;
; 1388 :         }
; 1389 : 
; 1390 :         Py_DECREF(obj);

  001d8	e8 00 00 00 00	 call	 _Py_DecRef

; 1391 :         break;
; 1392 :     }
; 1393 : 
; 1394 :     /* If no module is found, use __main__. */
; 1395 :     if (!j) {

  001dd	48 85 db	 test	 rbx, rbx
  001e0	74 86		 je	 SHORT $LN30@whichmodul

; 1396 :         module_name = main_str;

  001e2	48 8b 5c 24 70	 mov	 rbx, QWORD PTR module_name$[rsp]
  001e7	eb 8b		 jmp	 SHORT $LN1@whichmodul
whichmodule ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EK@PMPHMBHE@fast?5mode?3?5can?8t?5pickle?5cyclic?5o@ ; `string'
EXTRN	PyDict_SetItem:PROC
EXTRN	PyDict_GetItem:PROC
EXTRN	PyLong_FromVoidPtr:PROC
EXTRN	PyDict_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fast_save_enter DD imagerel fast_save_enter
	DD	imagerel fast_save_enter+257
	DD	imagerel $unwind$fast_save_enter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fast_save_enter DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0EK@PMPHMBHE@fast?5mode?3?5can?8t?5pickle?5cyclic?5o@
CONST	SEGMENT
??_C@_0EK@PMPHMBHE@fast?5mode?3?5can?8t?5pickle?5cyclic?5o@ DB 'fast mode'
	DB	': can''t pickle cyclic objects including object type %.200s a'
	DB	't %p', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fast_save_enter
_TEXT	SEGMENT
self$ = 48
obj$ = 56
fast_save_enter PROC					; COMDAT

; 1413 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1414 :     /* if fast_nesting < 0, we're doing an error exit. */
; 1415 :     if (++self->fast_nesting >= FAST_NESTING_LIMIT) {

  0000f	ff 81 b4 00 00
	00		 inc	 DWORD PTR [rcx+180]
  00015	83 b9 b4 00 00
	00 32		 cmp	 DWORD PTR [rcx+180], 50	; 00000032H
  0001c	48 8b f2	 mov	 rsi, rdx
  0001f	48 8b d9	 mov	 rbx, rcx
  00022	0f 8c c4 00 00
	00		 jl	 $LN6@fast_save_

; 1416 :         PyObject *key = NULL;
; 1417 :         if (self->fast_memo == NULL) {

  00028	48 83 b9 c0 00
	00 00 00	 cmp	 QWORD PTR [rcx+192], 0
  00030	75 11		 jne	 SHORT $LN4@fast_save_

; 1418 :             self->fast_memo = PyDict_New();

  00032	e8 00 00 00 00	 call	 PyDict_New
  00037	48 89 83 c0 00
	00 00		 mov	 QWORD PTR [rbx+192], rax

; 1419 :             if (self->fast_memo == NULL) {

  0003e	48 85 c0	 test	 rax, rax

; 1420 :                 self->fast_nesting = -1;
; 1421 :                 return 0;

  00041	74 4a		 je	 SHORT $LN10@fast_save_
$LN4@fast_save_:

; 1422 :             }
; 1423 :         }
; 1424 :         key = PyLong_FromVoidPtr(obj);

  00043	48 8b ce	 mov	 rcx, rsi
  00046	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
  0004b	48 8b f8	 mov	 rdi, rax

; 1425 :         if (key == NULL)

  0004e	48 85 c0	 test	 rax, rax

; 1426 :             return 0;

  00051	74 44		 je	 SHORT $LN9@fast_save_

; 1427 :         if (PyDict_GetItem(self->fast_memo, key)) {

  00053	48 8b 8b c0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+192]
  0005a	48 8b d0	 mov	 rdx, rax
  0005d	e8 00 00 00 00	 call	 PyDict_GetItem
  00062	48 85 c0	 test	 rax, rax
  00065	74 42		 je	 SHORT $LN2@fast_save_

; 1428 :             Py_DECREF(key);

  00067	48 8b cf	 mov	 rcx, rdi
  0006a	e8 00 00 00 00	 call	 _Py_DecRef

; 1429 :             PyErr_Format(PyExc_ValueError,
; 1430 :                          "fast mode: can't pickle cyclic objects "
; 1431 :                          "including object type %.200s at %p",
; 1432 :                          obj->ob_type->tp_name, obj);

  0006f	4c 8b 46 58	 mov	 r8, QWORD PTR [rsi+88]
  00073	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0007a	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EK@PMPHMBHE@fast?5mode?3?5can?8t?5pickle?5cyclic?5o@
  00085	4c 8b ce	 mov	 r9, rsi
  00088	e8 00 00 00 00	 call	 PyErr_Format
$LN10@fast_save_:

; 1433 :             self->fast_nesting = -1;

  0008d	c7 83 b4 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rbx+180], -1
$LN9@fast_save_:

; 1434 :             return 0;

  00097	33 c0		 xor	 eax, eax

; 1442 :     }
; 1443 :     return 1;
; 1444 : }

  00099	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000a3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a7	5f		 pop	 rdi
  000a8	c3		 ret	 0
$LN2@fast_save_:

; 1435 :         }
; 1436 :         if (PyDict_SetItem(self->fast_memo, key, Py_None) < 0) {

  000a9	48 8b 8b c0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+192]
  000b0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  000b7	48 8b d7	 mov	 rdx, rdi
  000ba	e8 00 00 00 00	 call	 PyDict_SetItem

; 1437 :             Py_DECREF(key);

  000bf	48 8b cf	 mov	 rcx, rdi
  000c2	85 c0		 test	 eax, eax
  000c4	79 21		 jns	 SHORT $LN1@fast_save_
  000c6	e8 00 00 00 00	 call	 _Py_DecRef

; 1438 :             self->fast_nesting = -1;

  000cb	c7 83 b4 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rbx+180], -1

; 1439 :             return 0;

  000d5	33 c0		 xor	 eax, eax

; 1442 :     }
; 1443 :     return 1;
; 1444 : }

  000d7	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000dc	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000e1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e5	5f		 pop	 rdi
  000e6	c3		 ret	 0
$LN1@fast_save_:

; 1440 :         }
; 1441 :         Py_DECREF(key);

  000e7	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@fast_save_:

; 1442 :     }
; 1443 :     return 1;
; 1444 : }

  000ec	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000f1	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000f6	b8 01 00 00 00	 mov	 eax, 1
  000fb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ff	5f		 pop	 rdi
  00100	c3		 ret	 0
fast_save_enter ENDP
_TEXT	ENDS
EXTRN	PyDict_DelItem:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fast_save_leave DD imagerel fast_save_leave
	DD	imagerel fast_save_leave+113
	DD	imagerel $unwind$fast_save_leave
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fast_save_leave DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT fast_save_leave
_TEXT	SEGMENT
self$ = 48
obj$ = 56
fast_save_leave PROC					; COMDAT

; 1448 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1449 :     if (self->fast_nesting-- >= FAST_NESTING_LIMIT) {

  0000a	44 8b 81 b4 00
	00 00		 mov	 r8d, DWORD PTR [rcx+180]
  00011	48 8b f9	 mov	 rdi, rcx
  00014	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  00018	89 81 b4 00 00
	00		 mov	 DWORD PTR [rcx+180], eax
  0001e	41 83 f8 32	 cmp	 r8d, 50			; 00000032H
  00022	7c 3d		 jl	 SHORT $LN3@fast_save_@2

; 1450 :         PyObject *key = PyLong_FromVoidPtr(obj);

  00024	48 8b ca	 mov	 rcx, rdx
  00027	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
  0002c	48 8b d8	 mov	 rbx, rax

; 1451 :         if (key == NULL)

  0002f	48 85 c0	 test	 rax, rax

; 1452 :             return 0;

  00032	74 1b		 je	 SHORT $LN6@fast_save_@2

; 1453 :         if (PyDict_DelItem(self->fast_memo, key) < 0) {

  00034	48 8b 8f c0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+192]
  0003b	48 8b d0	 mov	 rdx, rax
  0003e	e8 00 00 00 00	 call	 PyDict_DelItem

; 1454 :             Py_DECREF(key);

  00043	48 8b cb	 mov	 rcx, rbx
  00046	85 c0		 test	 eax, eax
  00048	79 12		 jns	 SHORT $LN1@fast_save_@2
  0004a	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@fast_save_@2:

; 1455 :             return 0;

  0004f	33 c0		 xor	 eax, eax

; 1460 : }

  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5f		 pop	 rdi
  0005b	c3		 ret	 0
$LN1@fast_save_@2:

; 1456 :         }
; 1457 :         Py_DECREF(key);

  0005c	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@fast_save_@2:

; 1458 :     }
; 1459 :     return 1;

  00061	b8 01 00 00 00	 mov	 eax, 1

; 1460 : }

  00066	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006f	5f		 pop	 rdi
  00070	c3		 ret	 0
fast_save_leave ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_none DD imagerel save_none
	DD	imagerel save_none+41
	DD	imagerel $unwind$save_none
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_none DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT save_none
_TEXT	SEGMENT
self$ = 48
none_op$ = 56
save_none PROC						; COMDAT

; 1464 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1465 :     const char none_op = NONE;
; 1466 :     if (_Pickler_Write(self, &none_op, 1) < 0)

  00004	48 8d 54 24 38	 lea	 rdx, QWORD PTR none_op$[rsp]
  00009	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000f	c6 44 24 38 4e	 mov	 BYTE PTR none_op$[rsp], 78 ; 0000004eH
  00014	e8 00 00 00 00	 call	 _Pickler_Write
  00019	33 c9		 xor	 ecx, ecx
  0001b	48 85 c0	 test	 rax, rax
  0001e	0f 99 c1	 setns	 cl
  00021	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 1467 :         return -1;
; 1468 : 
; 1469 :     return 0;
; 1470 : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
save_none ENDP
_TEXT	ENDS
EXTRN	_Py_TrueStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_bool DD imagerel save_bool
	DD	imagerel save_bool+104
	DD	imagerel $unwind$save_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_bool DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT save_bool
_TEXT	SEGMENT
bool_op$21406 = 48
len$ = 48
self$ = 48
obj$ = 56
save_bool PROC						; COMDAT

; 1474 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1475 :     static const char *buf[2] = { FALSE, TRUE };
; 1476 :     const char len[2] = {sizeof(FALSE) - 1, sizeof(TRUE) - 1};
; 1477 :     int p = (obj == Py_True);

  00004	33 c0		 xor	 eax, eax
  00006	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_TrueStruct
  0000d	66 c7 44 24 30
	04 04		 mov	 WORD PTR len$[rsp], 1028 ; 00000404H
  00014	49 3b d0	 cmp	 rdx, r8
  00017	0f 94 c0	 sete	 al

; 1478 : 
; 1479 :     if (self->proto >= 2) {

  0001a	83 b9 a0 00 00
	00 02		 cmp	 DWORD PTR [rcx+160], 2
  00021	7c 28		 jl	 SHORT $LN4@save_bool

; 1480 :         const char bool_op = p ? NEWTRUE : NEWFALSE;

  00023	85 c0		 test	 eax, eax

; 1481 :         if (_Pickler_Write(self, &bool_op, 1) < 0)

  00025	41 b8 01 00 00
	00		 mov	 r8d, 1
  0002b	48 8d 54 24 30	 lea	 rdx, QWORD PTR bool_op$21406[rsp]
  00030	0f 94 c0	 sete	 al
  00033	04 88		 add	 al, -120		; ffffffffffffff88H
  00035	88 44 24 30	 mov	 BYTE PTR bool_op$21406[rsp], al
$LN7@save_bool:
  00039	e8 00 00 00 00	 call	 _Pickler_Write
  0003e	48 85 c0	 test	 rax, rax
  00041	79 1e		 jns	 SHORT $LN1@save_bool

; 1482 :             return -1;

  00043	83 c8 ff	 or	 eax, -1

; 1488 : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
$LN4@save_bool:

; 1483 :     }
; 1484 :     else if (_Pickler_Write(self, buf[p], len[p]) < 0)

  0004b	48 63 d0	 movsxd	 rdx, eax
  0004e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?buf@?1??save_bool@@9@9
  00055	4c 0f be 44 14
	30		 movsx	 r8, BYTE PTR len$[rsp+rdx]
  0005b	48 8b 14 d0	 mov	 rdx, QWORD PTR [rax+rdx*8]

; 1485 :         return -1;

  0005f	eb d8		 jmp	 SHORT $LN7@save_bool
$LN1@save_bool:

; 1486 : 
; 1487 :     return 0;

  00061	33 c0		 xor	 eax, eax

; 1488 : }

  00063	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00067	c3		 ret	 0
save_bool ENDP
_TEXT	ENDS
PUBLIC	??_C@_05HCLFKMOP@?$CFldL?6?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_int DD imagerel save_int
	DD	imagerel save_int+38
	DD	imagerel $unwind$save_int
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$save_int DD imagerel save_int+38
	DD	imagerel save_int+96
	DD	imagerel $chain$0$save_int
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$save_int DD imagerel save_int+96
	DD	imagerel save_int+218
	DD	imagerel $chain$1$save_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$save_int DD 021H
	DD	imagerel save_int
	DD	imagerel save_int+38
	DD	imagerel $unwind$save_int
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$save_int DD 020521H
	DD	0a7405H
	DD	imagerel save_int
	DD	imagerel save_int+38
	DD	imagerel $unwind$save_int
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_int DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT ??_C@_05HCLFKMOP@?$CFldL?6?$AA@
CONST	SEGMENT
??_C@_05HCLFKMOP@?$CFldL?6?$AA@ DB '%ldL', 0aH, 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT save_int
_TEXT	SEGMENT
pdata$ = 32
self$ = 80
x$ = 88
save_int PROC						; COMDAT

; 1492 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1493 :     char pdata[32];
; 1494 :     Py_ssize_t len = 0;
; 1495 : 
; 1496 :     if (!self->bin
; 1497 : #if SIZEOF_LONG > 4
; 1498 :         || x > 0x7fffffffL || x < -0x80000000L
; 1499 : #endif
; 1500 :         ) {

  00006	83 b9 a4 00 00
	00 00		 cmp	 DWORD PTR [rcx+164], 0
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	75 57		 jne	 SHORT $LN8@save_int

; 1501 :         /* Text-mode pickle, or long too big to fit in the 4-byte
; 1502 :          * signed BININT format:  store as a string.
; 1503 :          */
; 1504 :         pdata[0] = LONG;        /* use LONG for consistency with pickle.py */
; 1505 :         PyOS_snprintf(pdata + 1, sizeof(pdata) - 1, "%ldL\n", x);

  00012	44 8b ca	 mov	 r9d, edx
  00015	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05HCLFKMOP@?$CFldL?6?$AA@
  0001c	48 8d 4c 24 21	 lea	 rcx, QWORD PTR pdata$[rsp+1]
  00021	ba 1f 00 00 00	 mov	 edx, 31
  00026	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0002b	c6 44 24 20 4c	 mov	 BYTE PTR pdata$[rsp], 76 ; 0000004cH
  00030	e8 00 00 00 00	 call	 PyOS_snprintf

; 1506 :         if (_Pickler_Write(self, pdata, strlen(pdata)) < 0)

  00035	48 83 c9 ff	 or	 rcx, -1
  00039	33 c0		 xor	 eax, eax
  0003b	48 8d 7c 24 20	 lea	 rdi, QWORD PTR pdata$[rsp]
  00040	48 8d 54 24 20	 lea	 rdx, QWORD PTR pdata$[rsp]
  00045	f2 ae		 repne scasb
  00047	48 f7 d1	 not	 rcx
  0004a	4c 8d 41 ff	 lea	 r8, QWORD PTR [rcx-1]
  0004e	48 8b cb	 mov	 rcx, rbx
  00051	e8 00 00 00 00	 call	 _Pickler_Write
  00056	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  0005b	48 85 c0	 test	 rax, rax
  0005e	79 72		 jns	 SHORT $LN1@save_int

; 1507 :             return -1;

  00060	83 c8 ff	 or	 eax, -1

; 1536 : }

  00063	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00067	5b		 pop	 rbx
  00068	c3		 ret	 0
$LN8@save_int:

; 1508 :     }
; 1509 :     else {
; 1510 :         /* Binary pickle and x fits in a signed 4-byte int. */
; 1511 :         pdata[1] = (unsigned char)(x & 0xff);
; 1512 :         pdata[2] = (unsigned char)((x >> 8) & 0xff);

  00069	8b c2		 mov	 eax, edx

; 1513 :         pdata[3] = (unsigned char)((x >> 16) & 0xff);

  0006b	8b ca		 mov	 ecx, edx
  0006d	88 54 24 21	 mov	 BYTE PTR pdata$[rsp+1], dl

; 1514 :         pdata[4] = (unsigned char)((x >> 24) & 0xff);

  00071	c1 fa 18	 sar	 edx, 24
  00074	c1 f8 08	 sar	 eax, 8
  00077	c1 f9 10	 sar	 ecx, 16
  0007a	88 44 24 22	 mov	 BYTE PTR pdata$[rsp+2], al
  0007e	88 4c 24 23	 mov	 BYTE PTR pdata$[rsp+3], cl
  00082	88 54 24 24	 mov	 BYTE PTR pdata$[rsp+4], dl

; 1515 : 
; 1516 :         if ((pdata[4] == 0) && (pdata[3] == 0)) {

  00086	84 d2		 test	 dl, dl
  00088	75 22		 jne	 SHORT $LN5@save_int
  0008a	84 c9		 test	 cl, cl
  0008c	75 1e		 jne	 SHORT $LN5@save_int

; 1517 :             if (pdata[2] == 0) {

  0008e	84 c0		 test	 al, al
  00090	75 0d		 jne	 SHORT $LN4@save_int

; 1518 :                 pdata[0] = BININT1;

  00092	c6 44 24 20 4b	 mov	 BYTE PTR pdata$[rsp], 75 ; 0000004bH

; 1519 :                 len = 2;

  00097	41 b8 02 00 00
	00		 mov	 r8d, 2

; 1520 :             }
; 1521 :             else {

  0009d	eb 18		 jmp	 SHORT $LN2@save_int
$LN4@save_int:

; 1522 :                 pdata[0] = BININT2;

  0009f	c6 44 24 20 4d	 mov	 BYTE PTR pdata$[rsp], 77 ; 0000004dH

; 1523 :                 len = 3;

  000a4	41 b8 03 00 00
	00		 mov	 r8d, 3

; 1524 :             }
; 1525 :         }
; 1526 :         else {

  000aa	eb 0b		 jmp	 SHORT $LN2@save_int
$LN5@save_int:

; 1527 :             pdata[0] = BININT;

  000ac	c6 44 24 20 4a	 mov	 BYTE PTR pdata$[rsp], 74 ; 0000004aH

; 1528 :             len = 5;

  000b1	41 b8 05 00 00
	00		 mov	 r8d, 5
$LN2@save_int:

; 1529 :         }
; 1530 : 
; 1531 :         if (_Pickler_Write(self, pdata, len) < 0)

  000b7	48 8d 54 24 20	 lea	 rdx, QWORD PTR pdata$[rsp]
  000bc	48 8b cb	 mov	 rcx, rbx
  000bf	e8 00 00 00 00	 call	 _Pickler_Write
  000c4	48 85 c0	 test	 rax, rax
  000c7	79 09		 jns	 SHORT $LN1@save_int

; 1532 :             return -1;

  000c9	83 c8 ff	 or	 eax, -1

; 1536 : }

  000cc	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000d0	5b		 pop	 rbx
  000d1	c3		 ret	 0
$LN1@save_int:

; 1533 :     }
; 1534 : 
; 1535 :     return 0;

  000d2	33 c0		 xor	 eax, eax

; 1536 : }

  000d4	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000d8	5b		 pop	 rbx
  000d9	c3		 ret	 0
save_int ENDP
_TEXT	ENDS
PUBLIC	??_C@_02IDNBLKMD@L?6?$AA@			; `string'
PUBLIC	??_C@_0BI@INABELJF@int?5too?5large?5to?5pickle?$AA@ ; `string'
EXTRN	PyUnicode_AsUTF8AndSize:PROC
EXTRN	PyObject_Repr:PROC
EXTRN	_PyLong_AsByteArray:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	_PyLong_NumBits:PROC
EXTRN	_PyLong_Sign:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_long DD imagerel save_long
	DD	imagerel save_long+63
	DD	imagerel $unwind$save_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$save_long DD imagerel save_long+63
	DD	imagerel save_long+168
	DD	imagerel $chain$1$save_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$save_long DD imagerel save_long+168
	DD	imagerel save_long+576
	DD	imagerel $chain$3$save_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$save_long DD imagerel save_long+576
	DD	imagerel save_long+597
	DD	imagerel $chain$4$save_long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$save_long DD 021H
	DD	imagerel save_long
	DD	imagerel save_long+63
	DD	imagerel $unwind$save_long
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$save_long DD 040021H
	DD	0fd400H
	DD	0ec400H
	DD	imagerel save_long
	DD	imagerel save_long+63
	DD	imagerel $unwind$save_long
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$save_long DD 040a21H
	DD	0fd40aH
	DD	0ec405H
	DD	imagerel save_long
	DD	imagerel save_long+63
	DD	imagerel $unwind$save_long
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_long DD 060b01H
	DD	0e007720bH
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT ??_C@_02IDNBLKMD@L?6?$AA@
CONST	SEGMENT
??_C@_02IDNBLKMD@L?6?$AA@ DB 'L', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@INABELJF@int?5too?5large?5to?5pickle?$AA@
CONST	SEGMENT
??_C@_0BI@INABELJF@int?5too?5large?5to?5pickle?$AA@ DB 'int too large to '
	DB	'pickle', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT save_long
_TEXT	SEGMENT
size$ = 48
self$ = 112
obj$ = 120
long_op$ = 128
header$21449 = 136
save_long PROC						; COMDAT

; 1540 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 56		 push	 r14
  00007	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000b	48 8b f1	 mov	 rsi, rcx

; 1541 :     PyObject *repr = NULL;
; 1542 :     Py_ssize_t size;
; 1543 :     long val = PyLong_AsLong(obj);

  0000e	48 8b ca	 mov	 rcx, rdx
  00011	48 8b ea	 mov	 rbp, rdx
  00014	33 ff		 xor	 edi, edi
  00016	e8 00 00 00 00	 call	 PyLong_AsLong

; 1544 :     int status = 0;

  0001b	44 8b f7	 mov	 r14d, edi
  0001e	8b d8		 mov	 ebx, eax

; 1545 : 
; 1546 :     const char long_op = LONG;

  00020	c6 84 24 80 00
	00 00 4c	 mov	 BYTE PTR long_op$[rsp], 76 ; 0000004cH

; 1547 : 
; 1548 :     if (val == -1 && PyErr_Occurred()) {

  00028	83 f8 ff	 cmp	 eax, -1
  0002b	0f 85 0f 02 00
	00		 jne	 $LN27@save_long
  00031	e8 00 00 00 00	 call	 PyErr_Occurred
  00036	48 85 c0	 test	 rax, rax
  00039	0f 84 01 02 00
	00		 je	 $LN27@save_long

; 1549 :         /* out of range for int pickling */
; 1550 :         PyErr_Clear();

  0003f	4c 89 64 24 70	 mov	 QWORD PTR [rsp+112], r12
  00044	4c 89 6c 24 78	 mov	 QWORD PTR [rsp+120], r13
  00049	e8 00 00 00 00	 call	 PyErr_Clear

; 1557 : 
; 1558 :     if (self->proto >= 2) {

  0004e	83 be a0 00 00
	00 02		 cmp	 DWORD PTR [rsi+160], 2

; 1559 :         /* Linear-time pickling. */
; 1560 :         size_t nbits;
; 1561 :         size_t nbytes;
; 1562 :         unsigned char *pdata;
; 1563 :         char header[5];
; 1564 :         int i;
; 1565 :         int sign = _PyLong_Sign(obj);

  00055	48 8b cd	 mov	 rcx, rbp
  00058	0f 8c 5d 01 00
	00		 jl	 $LN25@save_long
  0005e	e8 00 00 00 00	 call	 _PyLong_Sign
  00063	44 8b e0	 mov	 r12d, eax

; 1566 : 
; 1567 :         if (sign == 0) {

  00066	85 c0		 test	 eax, eax
  00068	75 3e		 jne	 SHORT $LN24@save_long

; 1568 :             header[0] = LONG1;
; 1569 :             header[1] = 0;      /* It's 0 -- an empty bytestring. */
; 1570 :             if (_Pickler_Write(self, header, 2) < 0)

  0006a	44 8d 47 02	 lea	 r8d, QWORD PTR [rdi+2]
  0006e	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR header$21449[rsp]
  00076	48 8b ce	 mov	 rcx, rsi
  00079	66 c7 84 24 88
	00 00 00 8a 00	 mov	 WORD PTR header$21449[rsp], 138 ; 0000008aH
  00083	e8 00 00 00 00	 call	 _Pickler_Write
  00088	48 85 c0	 test	 rax, rax
  0008b	0f 88 96 01 00
	00		 js	 $error$21454

; 1571 :                 goto error;
; 1572 :             return 0;

  00091	33 c0		 xor	 eax, eax
$LN38@save_long:
  00093	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]
  00098	4c 8b 6c 24 78	 mov	 r13, QWORD PTR [rsp+120]

; 1663 : }

  0009d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000a1	41 5e		 pop	 r14
  000a3	5f		 pop	 rdi
  000a4	5e		 pop	 rsi
  000a5	5d		 pop	 rbp
  000a6	5b		 pop	 rbx
  000a7	c3		 ret	 0
$LN24@save_long:

; 1573 :         }
; 1574 :         nbits = _PyLong_NumBits(obj);

  000a8	48 8b cd	 mov	 rcx, rbp
  000ab	e8 00 00 00 00	 call	 _PyLong_NumBits
  000b0	48 8b d8	 mov	 rbx, rax

; 1575 :         if (nbits == (size_t)-1 && PyErr_Occurred())

  000b3	48 83 f8 ff	 cmp	 rax, -1
  000b7	75 0e		 jne	 SHORT $LN22@save_long
  000b9	e8 00 00 00 00	 call	 PyErr_Occurred
  000be	48 85 c0	 test	 rax, rax
  000c1	0f 85 60 01 00
	00		 jne	 $error$21454
$LN22@save_long:

; 1576 :             goto error;
; 1577 :         /* How many bytes do we need?  There are nbits >> 3 full
; 1578 :          * bytes of data, and nbits & 7 leftover bits.  If there
; 1579 :          * are any leftover bits, then we clearly need another
; 1580 :          * byte.  Wnat's not so obvious is that we *probably*
; 1581 :          * need another byte even if there aren't any leftovers:
; 1582 :          * the most-significant bit of the most-significant byte
; 1583 :          * acts like a sign bit, and it's usually got a sense
; 1584 :          * opposite of the one we need.  The exception is ints
; 1585 :          * of the form -(2**(8*j-1)) for j > 0.  Such an int is
; 1586 :          * its own 256's-complement, so has the right sign bit
; 1587 :          * even without the extra byte.  That's a pain to check
; 1588 :          * for in advance, though, so we always grab an extra
; 1589 :          * byte at the start, and cut it back later if possible.
; 1590 :          */
; 1591 :         nbytes = (nbits >> 3) + 1;

  000c7	48 c1 eb 03	 shr	 rbx, 3
  000cb	48 ff c3	 inc	 rbx

; 1592 :         if (nbytes > 0x7fffffffL) {

  000ce	48 81 fb ff ff
	ff 7f		 cmp	 rbx, 2147483647		; 7fffffffH
  000d5	76 18		 jbe	 SHORT $LN21@save_long

; 1593 :             PyErr_SetString(PyExc_OverflowError,
; 1594 :                             "int too large to pickle");

  000d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@INABELJF@int?5too?5large?5to?5pickle?$AA@
  000e5	e8 00 00 00 00	 call	 PyErr_SetString

; 1595 :             goto error;

  000ea	e9 38 01 00 00	 jmp	 $error$21454
$LN21@save_long:

; 1596 :         }
; 1597 :         repr = PyBytes_FromStringAndSize(NULL, (Py_ssize_t)nbytes);

  000ef	48 8b d3	 mov	 rdx, rbx
  000f2	33 c9		 xor	 ecx, ecx
  000f4	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000f9	48 8b f8	 mov	 rdi, rax

; 1598 :         if (repr == NULL)

  000fc	48 85 c0	 test	 rax, rax
  000ff	0f 84 22 01 00
	00		 je	 $error$21454

; 1599 :             goto error;
; 1600 :         pdata = (unsigned char *)PyBytes_AS_STRING(repr);
; 1601 :         i = _PyLong_AsByteArray((PyLongObject *)obj,
; 1602 :                                 pdata, nbytes,
; 1603 :                                 1 /* little endian */ , 1 /* signed */ );

  00105	48 8d 50 78	 lea	 rdx, QWORD PTR [rax+120]
  00109	41 b9 01 00 00
	00		 mov	 r9d, 1
  0010f	4c 8b c3	 mov	 r8, rbx
  00112	48 8b cd	 mov	 rcx, rbp
  00115	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0011d	e8 00 00 00 00	 call	 _PyLong_AsByteArray

; 1604 :         if (i < 0)

  00122	85 c0		 test	 eax, eax
  00124	0f 88 fd 00 00
	00		 js	 $error$21454

; 1605 :             goto error;
; 1606 :         /* If the int is negative, this may be a byte more than
; 1607 :          * needed.  This is so iff the MSB is all redundant sign
; 1608 :          * bits.
; 1609 :          */
; 1610 :         if (sign < 0 &&
; 1611 :             nbytes > 1 &&
; 1612 :             pdata[nbytes - 1] == 0xff &&
; 1613 :             (pdata[nbytes - 2] & 0x80) != 0) {

  0012a	45 85 e4	 test	 r12d, r12d
  0012d	79 17		 jns	 SHORT $LN18@save_long
  0012f	48 83 fb 01	 cmp	 rbx, 1
  00133	76 11		 jbe	 SHORT $LN18@save_long
  00135	80 7c 1f 77 ff	 cmp	 BYTE PTR [rdi+rbx+119], 255 ; 000000ffH
  0013a	75 0a		 jne	 SHORT $LN18@save_long
  0013c	f6 44 1f 76 80	 test	 BYTE PTR [rdi+rbx+118], 128 ; 00000080H
  00141	74 03		 je	 SHORT $LN18@save_long

; 1614 :             nbytes--;

  00143	48 ff cb	 dec	 rbx
$LN18@save_long:

; 1615 :         }
; 1616 : 
; 1617 :         if (nbytes < 256) {
; 1618 :             header[0] = LONG1;
; 1619 :             header[1] = (unsigned char)nbytes;

  00146	88 9c 24 89 00
	00 00		 mov	 BYTE PTR header$21449[rsp+1], bl
  0014d	48 81 fb 00 01
	00 00		 cmp	 rbx, 256		; 00000100H
  00154	73 10		 jae	 SHORT $LN17@save_long

; 1620 :             size = 2;

  00156	c6 84 24 88 00
	00 00 8a	 mov	 BYTE PTR header$21449[rsp], -118 ; ffffffffffffff8aH
  0015e	41 b8 02 00 00
	00		 mov	 r8d, 2

; 1621 :         }
; 1622 :         else {

  00164	eb 32		 jmp	 SHORT $LN39@save_long
$LN17@save_long:

; 1623 :             header[0] = LONG4;
; 1624 :             size = (Py_ssize_t) nbytes;
; 1625 :             for (i = 1; i < 5; i++) {
; 1626 :                 header[i] = (unsigned char)(size & 0xff);
; 1627 :                 size >>= 8;

  00166	48 8b c3	 mov	 rax, rbx
  00169	c6 84 24 88 00
	00 00 8b	 mov	 BYTE PTR header$21449[rsp], -117 ; ffffffffffffff8bH

; 1628 :             }
; 1629 :             size = 5;

  00171	41 b8 05 00 00
	00		 mov	 r8d, 5
  00177	48 c1 f8 08	 sar	 rax, 8
  0017b	88 84 24 8a 00
	00 00		 mov	 BYTE PTR header$21449[rsp+2], al
  00182	48 c1 f8 08	 sar	 rax, 8
  00186	88 84 24 8b 00
	00 00		 mov	 BYTE PTR header$21449[rsp+3], al
  0018d	48 c1 f8 08	 sar	 rax, 8
  00191	88 84 24 8c 00
	00 00		 mov	 BYTE PTR header$21449[rsp+4], al
$LN39@save_long:

; 1630 :         }
; 1631 :         if (_Pickler_Write(self, header, size) < 0 ||
; 1632 :             _Pickler_Write(self, (char *)pdata, (int)nbytes) < 0)

  00198	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR header$21449[rsp]
  001a0	48 8b ce	 mov	 rcx, rsi
  001a3	4c 89 44 24 30	 mov	 QWORD PTR size$[rsp], r8
  001a8	e8 00 00 00 00	 call	 _Pickler_Write
  001ad	48 85 c0	 test	 rax, rax
  001b0	78 75		 js	 SHORT $error$21454
  001b2	4c 63 c3	 movsxd	 r8, ebx
  001b5	48 8d 57 78	 lea	 rdx, QWORD PTR [rdi+120]

; 1633 :             goto error;

  001b9	eb 5f		 jmp	 SHORT $LN41@save_long
$LN25@save_long:

; 1634 :     }
; 1635 :     else {
; 1636 :         char *string;
; 1637 : 
; 1638 :         /* proto < 2: write the repr and newline.  This is quadratic-time (in
; 1639 :            the number of digits), in both directions.  We add a trailing 'L'
; 1640 :            to the repr, for compatibility with Python 2.x. */
; 1641 : 
; 1642 :         repr = PyObject_Repr(obj);

  001bb	e8 00 00 00 00	 call	 PyObject_Repr
  001c0	48 8b f8	 mov	 rdi, rax

; 1643 :         if (repr == NULL)

  001c3	48 85 c0	 test	 rax, rax
  001c6	74 5f		 je	 SHORT $error$21454

; 1644 :             goto error;
; 1645 : 
; 1646 :         string = _PyUnicode_AsStringAndSize(repr, &size);

  001c8	48 8d 54 24 30	 lea	 rdx, QWORD PTR size$[rsp]
  001cd	48 8b c8	 mov	 rcx, rax
  001d0	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  001d5	48 8b d8	 mov	 rbx, rax

; 1647 :         if (string == NULL)

  001d8	48 85 c0	 test	 rax, rax
  001db	74 4a		 je	 SHORT $error$21454

; 1648 :             goto error;
; 1649 : 
; 1650 :         if (_Pickler_Write(self, &long_op, 1) < 0 ||
; 1651 :             _Pickler_Write(self, string, size) < 0 ||
; 1652 :             _Pickler_Write(self, "L\n", 2) < 0)

  001dd	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR long_op$[rsp]
  001e5	41 b8 01 00 00
	00		 mov	 r8d, 1
  001eb	48 8b ce	 mov	 rcx, rsi
  001ee	e8 00 00 00 00	 call	 _Pickler_Write
  001f3	48 85 c0	 test	 rax, rax
  001f6	78 2f		 js	 SHORT $error$21454
  001f8	4c 8b 44 24 30	 mov	 r8, QWORD PTR size$[rsp]
  001fd	48 8b d3	 mov	 rdx, rbx
  00200	48 8b ce	 mov	 rcx, rsi
  00203	e8 00 00 00 00	 call	 _Pickler_Write
  00208	48 85 c0	 test	 rax, rax
  0020b	78 1a		 js	 SHORT $error$21454
  0020d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00213	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02IDNBLKMD@L?6?$AA@
$LN41@save_long:
  0021a	48 8b ce	 mov	 rcx, rsi
  0021d	e8 00 00 00 00	 call	 _Pickler_Write
  00222	48 85 c0	 test	 rax, rax

; 1653 :             goto error;
; 1654 :     }
; 1655 : 
; 1656 :     if (0) {

  00225	79 04		 jns	 SHORT $LN4@save_long
$error$21454:

; 1657 :   error:
; 1658 :       status = -1;

  00227	41 83 ce ff	 or	 r14d, -1
$LN4@save_long:

; 1659 :     }
; 1660 :     Py_XDECREF(repr);

  0022b	48 85 ff	 test	 rdi, rdi
  0022e	74 08		 je	 SHORT $LN3@save_long
  00230	48 8b cf	 mov	 rcx, rdi
  00233	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@save_long:

; 1661 : 
; 1662 :     return status;

  00238	41 8b c6	 mov	 eax, r14d
  0023b	e9 53 fe ff ff	 jmp	 $LN38@save_long
$LN27@save_long:

; 1551 :     }
; 1552 :     else
; 1553 : #if SIZEOF_LONG > 4
; 1554 :         if (val <= 0x7fffffffL && val >= -0x80000000L)
; 1555 : #endif
; 1556 :             return save_int(self, val);

  00240	8b d3		 mov	 edx, ebx
  00242	48 8b ce	 mov	 rcx, rsi
  00245	e8 00 00 00 00	 call	 save_int

; 1663 : }

  0024a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0024e	41 5e		 pop	 r14
  00250	5f		 pop	 rdi
  00251	5e		 pop	 rsi
  00252	5d		 pop	 rbp
  00253	5b		 pop	 rbx
  00254	c3		 ret	 0
save_long ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
EXTRN	PyMem_Free:PROC
EXTRN	PyOS_double_to_string:PROC
EXTRN	_PyFloat_Pack8:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_float DD imagerel save_float
	DD	imagerel save_float+195
	DD	imagerel $unwind$save_float
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$save_float DD imagerel save_float+195
	DD	imagerel save_float+238
	DD	imagerel $chain$1$save_float
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$save_float DD imagerel save_float+238
	DD	imagerel save_float+296
	DD	imagerel $chain$2$save_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$save_float DD 021H
	DD	imagerel save_float
	DD	imagerel save_float+195
	DD	imagerel $unwind$save_float
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$save_float DD 020521H
	DD	0f7405H
	DD	imagerel save_float
	DD	imagerel save_float+195
	DD	imagerel $unwind$save_float
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_float DD 088b01H
	DD	010c48bH
	DD	046814H
	DD	060049208H
	DD	030025003H
xdata	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT save_float
_TEXT	SEGMENT
pdata$21506 = 48
op$21514 = 112
self$ = 112
obj$ = 120
save_float PROC						; COMDAT

; 1667 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 1668 :     double x = PyFloat_AS_DOUBLE((PyFloatObject *)obj);
; 1669 : 
; 1670 :     if (self->bin) {

  00008	83 b9 a4 00 00
	00 00		 cmp	 DWORD PTR [rcx+164], 0
  0000f	0f 29 74 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm6
  00014	f2 0f 10 72 60	 movsdx	 xmm6, QWORD PTR [rdx+96]
  00019	48 8b e9	 mov	 rbp, rcx
  0001c	74 56		 je	 SHORT $LN8@save_float

; 1671 :         char pdata[9];
; 1672 :         pdata[0] = BINFLOAT;
; 1673 :         if (_PyFloat_Pack8(x, (unsigned char *)&pdata[1], 0) < 0)

  0001e	48 8d 54 24 31	 lea	 rdx, QWORD PTR pdata$21506[rsp+1]
  00023	66 0f 28 c6	 movapd	 xmm0, xmm6
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	c6 44 24 30 47	 mov	 BYTE PTR pdata$21506[rsp], 71 ; 00000047H
  0002f	e8 00 00 00 00	 call	 _PyFloat_Pack8
  00034	85 c0		 test	 eax, eax
  00036	79 10		 jns	 SHORT $LN7@save_float

; 1674 :             return -1;

  00038	83 c8 ff	 or	 eax, -1

; 1702 :     }
; 1703 : 
; 1704 :     return 0;
; 1705 : }

  0003b	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  00040	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00044	5e		 pop	 rsi
  00045	5d		 pop	 rbp
  00046	5b		 pop	 rbx
  00047	c3		 ret	 0
$LN7@save_float:

; 1675 :         if (_Pickler_Write(self, pdata, 9) < 0)

  00048	48 8d 54 24 30	 lea	 rdx, QWORD PTR pdata$21506[rsp]
  0004d	41 b8 09 00 00
	00		 mov	 r8d, 9
  00053	48 8b cd	 mov	 rcx, rbp
  00056	e8 00 00 00 00	 call	 _Pickler_Write
  0005b	33 f6		 xor	 esi, esi
  0005d	48 85 c0	 test	 rax, rax
  00060	40 0f 99 c6	 setns	 sil
  00064	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]

; 1702 :     }
; 1703 : 
; 1704 :     return 0;
; 1705 : }

  00067	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  0006c	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00070	5e		 pop	 rsi
  00071	5d		 pop	 rbp
  00072	5b		 pop	 rbx
  00073	c3		 ret	 0
$LN8@save_float:

; 1676 :             return -1;
; 1677 :    }
; 1678 :     else {
; 1679 :         int result = -1;

  00074	48 83 cb ff	 or	 rbx, -1

; 1680 :         char *buf = NULL;
; 1681 :         char op = FLOAT;
; 1682 : 
; 1683 :         if (_Pickler_Write(self, &op, 1) < 0)

  00078	48 8d 54 24 70	 lea	 rdx, QWORD PTR op$21514[rsp]
  0007d	33 f6		 xor	 esi, esi
  0007f	44 8d 43 02	 lea	 r8d, QWORD PTR [rbx+2]
  00083	4c 89 a4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r12
  0008b	c6 44 24 70 46	 mov	 BYTE PTR op$21514[rsp], 70 ; 00000046H
  00090	44 8b e6	 mov	 r12d, esi
  00093	e8 00 00 00 00	 call	 _Pickler_Write
  00098	48 85 c0	 test	 rax, rax
  0009b	78 6c		 js	 SHORT $done$21516

; 1684 :             goto done;
; 1685 : 
; 1686 :         buf = PyOS_double_to_string(x, 'g', 17, 0, NULL);

  0009d	44 8d 43 12	 lea	 r8d, QWORD PTR [rbx+18]
  000a1	66 0f 28 c6	 movapd	 xmm0, xmm6
  000a5	45 33 c9	 xor	 r9d, r9d
  000a8	b2 67		 mov	 dl, 103			; 00000067H
  000aa	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  000af	e8 00 00 00 00	 call	 PyOS_double_to_string
  000b4	4c 8b e0	 mov	 r12, rax

; 1687 :         if (!buf) {

  000b7	48 85 c0	 test	 rax, rax
  000ba	75 07		 jne	 SHORT $LN3@save_float

; 1688 :             PyErr_NoMemory();

  000bc	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1689 :             goto done;

  000c1	eb 46		 jmp	 SHORT $done$21516
$LN3@save_float:
  000c3	48 89 7c 24 78	 mov	 QWORD PTR [rsp+120], rdi

; 1690 :         }
; 1691 : 
; 1692 :         if (_Pickler_Write(self, buf, strlen(buf)) < 0)

  000c8	33 c0		 xor	 eax, eax
  000ca	48 8b cb	 mov	 rcx, rbx
  000cd	49 8b fc	 mov	 rdi, r12
  000d0	49 8b d4	 mov	 rdx, r12
  000d3	f2 ae		 repne scasb
  000d5	48 f7 d1	 not	 rcx
  000d8	4c 8d 41 ff	 lea	 r8, QWORD PTR [rcx-1]
  000dc	48 8b cd	 mov	 rcx, rbp
  000df	e8 00 00 00 00	 call	 _Pickler_Write
  000e4	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]
  000e9	48 85 c0	 test	 rax, rax
  000ec	78 1b		 js	 SHORT $done$21516

; 1693 :             goto done;
; 1694 : 
; 1695 :         if (_Pickler_Write(self, "\n", 1) < 0)

  000ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  000f5	41 b8 01 00 00
	00		 mov	 r8d, 1
  000fb	48 8b cd	 mov	 rcx, rbp
  000fe	e8 00 00 00 00	 call	 _Pickler_Write
  00103	48 85 c0	 test	 rax, rax
  00106	0f 49 de	 cmovns	 ebx, esi
$done$21516:

; 1696 :             goto done;
; 1697 : 
; 1698 :         result = 0;
; 1699 : done:
; 1700 :         PyMem_Free(buf);

  00109	49 8b cc	 mov	 rcx, r12
  0010c	e8 00 00 00 00	 call	 PyMem_Free
  00111	4c 8b a4 24 80
	00 00 00	 mov	 r12, QWORD PTR [rsp+128]

; 1701 :         return result;

  00119	8b c3		 mov	 eax, ebx

; 1702 :     }
; 1703 : 
; 1704 :     return 0;
; 1705 : }

  0011b	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  00120	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00124	5e		 pop	 rsi
  00125	5d		 pop	 rbp
  00126	5b		 pop	 rbx
  00127	c3		 ret	 0
save_float ENDP
_TEXT	ENDS
EXTRN	Py_hexdigits:QWORD
EXTRN	_PyByteArray_empty_string:BYTE
EXTRN	PyByteArray_FromStringAndSize:PROC
EXTRN	_PyUnicode_Ready:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$raw_unicode_escape DD imagerel raw_unicode_escape
	DD	imagerel raw_unicode_escape+32
	DD	imagerel $unwind$raw_unicode_escape
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$raw_unicode_escape DD imagerel raw_unicode_escape+32
	DD	imagerel raw_unicode_escape+143
	DD	imagerel $chain$1$raw_unicode_escape
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$raw_unicode_escape DD imagerel raw_unicode_escape+143
	DD	imagerel raw_unicode_escape+684
	DD	imagerel $chain$4$raw_unicode_escape
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$raw_unicode_escape DD 060921H
	DD	075409H
	DD	086400H
	DD	063400H
	DD	imagerel raw_unicode_escape
	DD	imagerel raw_unicode_escape+32
	DD	imagerel $unwind$raw_unicode_escape
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$raw_unicode_escape DD 040d21H
	DD	08640dH
	DD	063405H
	DD	imagerel raw_unicode_escape
	DD	imagerel raw_unicode_escape+32
	DD	imagerel $unwind$raw_unicode_escape
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$raw_unicode_escape DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT raw_unicode_escape
_TEXT	SEGMENT
obj$ = 48
raw_unicode_escape PROC					; COMDAT

; 1812 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1813 :     PyObject *repr, *result;
; 1814 :     char *p;
; 1815 :     Py_ssize_t i, size, expandsize;
; 1816 :     void *data;
; 1817 :     unsigned int kind;
; 1818 : 
; 1819 :     if (PyUnicode_READY(obj))

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	75 11		 jne	 SHORT $LN14@raw_unicod
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	85 c0		 test	 eax, eax
  00016	74 08		 je	 SHORT $LN14@raw_unicod

; 1820 :         return NULL;

  00018	33 c0		 xor	 eax, eax

; 1873 : }

  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5f		 pop	 rdi
  0001f	c3		 ret	 0
$LN14@raw_unicod:
  00020	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1821 : 
; 1822 :     size = PyUnicode_GET_LENGTH(obj);
; 1823 :     data = PyUnicode_DATA(obj);

  00025	8b 5f 70	 mov	 ebx, DWORD PTR [rdi+112]
  00028	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0002d	48 8b 77 60	 mov	 rsi, QWORD PTR [rdi+96]
  00031	f6 c3 20	 test	 bl, 32			; 00000020H
  00034	74 14		 je	 SHORT $LN21@raw_unicod
  00036	f6 c3 40	 test	 bl, 64			; 00000040H
  00039	74 06		 je	 SHORT $LN19@raw_unicod
  0003b	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  0003f	eb 10		 jmp	 SHORT $LN22@raw_unicod
$LN19@raw_unicod:
  00041	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  00048	eb 07		 jmp	 SHORT $LN22@raw_unicod
$LN21@raw_unicod:
  0004a	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
$LN22@raw_unicod:

; 1824 :     kind = PyUnicode_KIND(obj);

  00051	c1 eb 02	 shr	 ebx, 2

; 1825 :     if (kind == PyUnicode_4BYTE_KIND)

  00054	b8 0a 00 00 00	 mov	 eax, 10
  00059	b9 06 00 00 00	 mov	 ecx, 6
  0005e	83 e3 07	 and	 ebx, 7
  00061	83 fb 04	 cmp	 ebx, 4
  00064	0f 44 c8	 cmove	 ecx, eax

; 1826 :         expandsize = 10;
; 1827 :     else
; 1828 :         expandsize = 6;
; 1829 : 
; 1830 :     if (size > PY_SSIZE_T_MAX / expandsize)

  00067	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00071	48 99		 cdq
  00073	48 f7 f9	 idiv	 rcx
  00076	48 3b f0	 cmp	 rsi, rax
  00079	7e 14		 jle	 SHORT $LN11@raw_unicod

; 1831 :         return PyErr_NoMemory();

  0007b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00080	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 1873 : }

  00085	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00089	5f		 pop	 rdi
  0008a	e9 00 00 00 00	 jmp	 PyErr_NoMemory
$LN11@raw_unicod:

; 1832 :     repr = PyByteArray_FromStringAndSize(NULL, expandsize * size);

  0008f	48 0f af ce	 imul	 rcx, rsi
  00093	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00098	48 8b d1	 mov	 rdx, rcx
  0009b	33 c9		 xor	 ecx, ecx
  0009d	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000a2	48 8b e8	 mov	 rbp, rax

; 1833 :     if (repr == NULL)

  000a5	48 85 c0	 test	 rax, rax
  000a8	0f 84 e9 01 00
	00		 je	 $LN37@raw_unicod
$LN10@raw_unicod:

; 1834 :         return NULL;
; 1835 :     if (size == 0)

  000ae	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:_PyByteArray_empty_string
  000b5	48 85 f6	 test	 rsi, rsi
  000b8	0f 84 b2 01 00
	00		 je	 $done$21637

; 1836 :         goto done;
; 1837 : 
; 1838 :     p = PyByteArray_AS_STRING(repr);

  000be	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000c3	74 09		 je	 SHORT $LN23@raw_unicod
  000c5	4c 8b 80 80 00
	00 00		 mov	 r8, QWORD PTR [rax+128]
  000cc	eb 03		 jmp	 SHORT $LN24@raw_unicod
$LN23@raw_unicod:
  000ce	4d 8b c2	 mov	 r8, r10
$LN24@raw_unicod:

; 1839 :     for (i=0; i < size; i++) {

  000d1	45 33 c9	 xor	 r9d, r9d
  000d4	48 85 f6	 test	 rsi, rsi
  000d7	0f 8e 7a 01 00
	00		 jle	 $LN6@raw_unicod
  000dd	0f 1f 00	 npad	 3
$LL8@raw_unicod:

; 1840 :         Py_UCS4 ch = PyUnicode_READ(kind, data, i);

  000e0	83 fb 01	 cmp	 ebx, 1
  000e3	75 07		 jne	 SHORT $LN27@raw_unicod
  000e5	41 0f b6 04 39	 movzx	 eax, BYTE PTR [r9+rdi]
  000ea	eb 10		 jmp	 SHORT $LN26@raw_unicod
$LN27@raw_unicod:
  000ec	83 fb 02	 cmp	 ebx, 2
  000ef	75 07		 jne	 SHORT $LN25@raw_unicod
  000f1	42 0f b7 04 4f	 movzx	 eax, WORD PTR [rdi+r9*2]
  000f6	eb 04		 jmp	 SHORT $LN26@raw_unicod
$LN25@raw_unicod:
  000f8	42 8b 04 8f	 mov	 eax, DWORD PTR [rdi+r9*4]
$LN26@raw_unicod:

; 1841 :         /* Map 32-bit characters to '\Uxxxxxxxx' */
; 1842 :         if (ch >= 0x10000) {

  000fc	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
  00101	0f 82 c5 00 00
	00		 jb	 $LN5@raw_unicod

; 1843 :             *p++ = '\\';

  00107	66 41 c7 00 5c
	55		 mov	 WORD PTR [r8], 21852	; 0000555cH

; 1844 :             *p++ = 'U';
; 1845 :             *p++ = Py_hexdigits[(ch >> 28) & 0xf];

  0010d	8b d0		 mov	 edx, eax
  0010f	8b c8		 mov	 ecx, eax
  00111	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00118	48 c1 e9 1c	 shr	 rcx, 28
  0011c	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00120	41 88 48 02	 mov	 BYTE PTR [r8+2], cl

; 1846 :             *p++ = Py_hexdigits[(ch >> 24) & 0xf];

  00124	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  0012b	8b ca		 mov	 ecx, edx
  0012d	48 c1 e9 18	 shr	 rcx, 24
  00131	83 e1 0f	 and	 ecx, 15
  00134	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00138	41 88 48 03	 mov	 BYTE PTR [r8+3], cl

; 1847 :             *p++ = Py_hexdigits[(ch >> 20) & 0xf];

  0013c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00143	8b ca		 mov	 ecx, edx
  00145	48 c1 e9 14	 shr	 rcx, 20
  00149	83 e1 0f	 and	 ecx, 15
  0014c	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00150	41 88 48 04	 mov	 BYTE PTR [r8+4], cl

; 1848 :             *p++ = Py_hexdigits[(ch >> 16) & 0xf];

  00154	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  0015b	8b ca		 mov	 ecx, edx
  0015d	48 c1 e9 10	 shr	 rcx, 16
  00161	83 e1 0f	 and	 ecx, 15
  00164	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00168	41 88 48 05	 mov	 BYTE PTR [r8+5], cl

; 1849 :             *p++ = Py_hexdigits[(ch >> 12) & 0xf];

  0016c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00173	8b ca		 mov	 ecx, edx
  00175	48 c1 e9 0c	 shr	 rcx, 12
  00179	83 e1 0f	 and	 ecx, 15
  0017c	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00180	41 88 48 06	 mov	 BYTE PTR [r8+6], cl

; 1850 :             *p++ = Py_hexdigits[(ch >> 8) & 0xf];

  00184	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  0018b	8b ca		 mov	 ecx, edx
  0018d	48 c1 e9 08	 shr	 rcx, 8
  00191	83 e1 0f	 and	 ecx, 15
  00194	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00198	41 88 48 07	 mov	 BYTE PTR [r8+7], cl

; 1851 :             *p++ = Py_hexdigits[(ch >> 4) & 0xf];

  0019c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  001a3	8b ca		 mov	 ecx, edx
  001a5	48 c1 e9 04	 shr	 rcx, 4

; 1852 :             *p++ = Py_hexdigits[ch & 15];

  001a9	83 e2 0f	 and	 edx, 15
  001ac	83 e1 0f	 and	 ecx, 15
  001af	49 83 c0 0a	 add	 r8, 10
  001b3	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  001b7	41 88 48 fe	 mov	 BYTE PTR [r8-2], cl
  001bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  001c2	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  001c6	41 88 48 ff	 mov	 BYTE PTR [r8-1], cl
  001ca	eb 7f		 jmp	 SHORT $LN7@raw_unicod
$LN5@raw_unicod:

; 1853 :         }
; 1854 :         /* Map 16-bit characters to '\uxxxx' */
; 1855 :         else if (ch >= 256 || ch == '\\' || ch == '\n') {

  001cc	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  001d1	73 12		 jae	 SHORT $LN2@raw_unicod
  001d3	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  001d6	74 0d		 je	 SHORT $LN2@raw_unicod
  001d8	83 f8 0a	 cmp	 eax, 10
  001db	74 08		 je	 SHORT $LN2@raw_unicod

; 1862 :         }
; 1863 :         /* Copy everything else as-is */
; 1864 :         else
; 1865 :             *p++ = (char) ch;

  001dd	41 88 00	 mov	 BYTE PTR [r8], al
  001e0	49 ff c0	 inc	 r8
  001e3	eb 66		 jmp	 SHORT $LN7@raw_unicod
$LN2@raw_unicod:

; 1856 :             *p++ = '\\';

  001e5	66 41 c7 00 5c
	75		 mov	 WORD PTR [r8], 30044	; 0000755cH

; 1857 :             *p++ = 'u';
; 1858 :             *p++ = Py_hexdigits[(ch >> 12) & 0xf];

  001eb	8b d0		 mov	 edx, eax
  001ed	8b c8		 mov	 ecx, eax
  001ef	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  001f6	48 c1 e9 0c	 shr	 rcx, 12
  001fa	83 e1 0f	 and	 ecx, 15
  001fd	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00201	41 88 48 02	 mov	 BYTE PTR [r8+2], cl

; 1859 :             *p++ = Py_hexdigits[(ch >> 8) & 0xf];

  00205	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  0020c	8b ca		 mov	 ecx, edx
  0020e	48 c1 e9 08	 shr	 rcx, 8
  00212	83 e1 0f	 and	 ecx, 15
  00215	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00219	41 88 48 03	 mov	 BYTE PTR [r8+3], cl

; 1860 :             *p++ = Py_hexdigits[(ch >> 4) & 0xf];

  0021d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00224	8b ca		 mov	 ecx, edx
  00226	48 c1 e9 04	 shr	 rcx, 4

; 1861 :             *p++ = Py_hexdigits[ch & 15];

  0022a	83 e2 0f	 and	 edx, 15
  0022d	83 e1 0f	 and	 ecx, 15
  00230	49 83 c0 06	 add	 r8, 6
  00234	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00238	41 88 48 fe	 mov	 BYTE PTR [r8-2], cl
  0023c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00243	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  00247	41 88 48 ff	 mov	 BYTE PTR [r8-1], cl
$LN7@raw_unicod:

; 1839 :     for (i=0; i < size; i++) {

  0024b	49 ff c1	 inc	 r9
  0024e	4c 3b ce	 cmp	 r9, rsi
  00251	0f 8c 89 fe ff
	ff		 jl	 $LL8@raw_unicod
$LN6@raw_unicod:

; 1866 :     }
; 1867 :     size = p - PyByteArray_AS_STRING(repr);

  00257	48 83 7d 60 00	 cmp	 QWORD PTR [rbp+96], 0
  0025c	74 09		 je	 SHORT $LN29@raw_unicod
  0025e	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR [rbp+128]
  00265	eb 03		 jmp	 SHORT $LN30@raw_unicod
$LN29@raw_unicod:
  00267	49 8b c2	 mov	 rax, r10
$LN30@raw_unicod:
  0026a	49 8b f0	 mov	 rsi, r8
  0026d	48 2b f0	 sub	 rsi, rax
$done$21637:

; 1868 : 
; 1869 : done:
; 1870 :     result = PyBytes_FromStringAndSize(PyByteArray_AS_STRING(repr), size);

  00270	48 83 7d 60 00	 cmp	 QWORD PTR [rbp+96], 0
  00275	74 07		 je	 SHORT $LN31@raw_unicod
  00277	4c 8b 95 80 00
	00 00		 mov	 r10, QWORD PTR [rbp+128]
$LN31@raw_unicod:
  0027e	48 8b d6	 mov	 rdx, rsi
  00281	49 8b ca	 mov	 rcx, r10
  00284	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 1871 :     Py_DECREF(repr);

  00289	48 8b cd	 mov	 rcx, rbp
  0028c	48 8b d8	 mov	 rbx, rax
  0028f	e8 00 00 00 00	 call	 _Py_DecRef

; 1872 :     return result;

  00294	48 8b c3	 mov	 rax, rbx
$LN37@raw_unicod:
  00297	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0029c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  002a1	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 1873 : }

  002a6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002aa	5f		 pop	 rdi
  002ab	c3		 ret	 0
raw_unicode_escape ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@LALEGHBC@cannot?5serialize?5a?5string?5larger@ ; `string'
PUBLIC	??_C@_05CAMHEFLG@utf?98?$AA@			; `string'
PUBLIC	??_C@_0O@BNPCNOJJ@surrogatepass?$AA@		; `string'
EXTRN	PyUnicode_AsEncodedString:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$save_unicode DD imagerel save_unicode
	DD	imagerel save_unicode+501
	DD	imagerel $unwind$save_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_unicode DD 060c01H
	DD	0b340cH
	DD	07008520cH
	DD	050066007H
xdata	ENDS
;	COMDAT ??_C@_0CM@LALEGHBC@cannot?5serialize?5a?5string?5larger@
CONST	SEGMENT
??_C@_0CM@LALEGHBC@cannot?5serialize?5a?5string?5larger@ DB 'cannot seria'
	DB	'lize a string larger than 4 GiB', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CAMHEFLG@utf?98?$AA@
CONST	SEGMENT
??_C@_05CAMHEFLG@utf?98?$AA@ DB 'utf-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNPCNOJJ@surrogatepass?$AA@
CONST	SEGMENT
??_C@_0O@BNPCNOJJ@surrogatepass?$AA@ DB 'surrogatepass', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT save_unicode
_TEXT	SEGMENT
unicode_op$21691 = 80
self$ = 80
obj$ = 88
pdata$21672 = 96
save_unicode PROC					; COMDAT

; 1877 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1878 :     Py_ssize_t size;
; 1879 :     PyObject *encoded = NULL;
; 1880 : 
; 1881 :     if (self->bin) {

  0000c	83 b9 a4 00 00
	00 00		 cmp	 DWORD PTR [rcx+164], 0
  00013	48 8b ea	 mov	 rbp, rdx
  00016	48 8b f9	 mov	 rdi, rcx
  00019	0f 84 0e 01 00
	00		 je	 $LN15@save_unico

; 1882 :         char pdata[5];
; 1883 : 
; 1884 :         encoded = PyUnicode_AsEncodedString(obj, "utf-8", "surrogatepass");

  0001f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNPCNOJJ@surrogatepass?$AA@
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  0002d	48 8b cd	 mov	 rcx, rbp
  00030	e8 00 00 00 00	 call	 PyUnicode_AsEncodedString
  00035	48 8b d8	 mov	 rbx, rax

; 1885 :         if (encoded == NULL)

  00038	48 85 c0	 test	 rax, rax
  0003b	0f 84 a4 01 00
	00		 je	 $LN3@save_unico

; 1886 :             goto error;
; 1887 : 
; 1888 :         size = PyBytes_GET_SIZE(encoded);

  00041	48 8b 70 60	 mov	 rsi, QWORD PTR [rax+96]

; 1889 :         if (size > 0xffffffffL) {

  00045	b8 ff ff ff ff	 mov	 eax, -1
  0004a	48 3b f0	 cmp	 rsi, rax
  0004d	0f 8e 8a 00 00
	00		 jle	 $LN13@save_unico

; 1890 :             PyErr_SetString(PyExc_OverflowError,
; 1891 :                             "cannot serialize a string larger than 4 GiB");

  00053	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@LALEGHBC@cannot?5serialize?5a?5string?5larger@
  00061	e8 00 00 00 00	 call	 PyErr_SetString
$error$21677:

; 1929 : 
; 1930 :   error:
; 1931 :     Py_XDECREF(encoded);

  00066	e8 00 00 00 00	 call	 _Py_PXCTX
  0006b	85 c0		 test	 eax, eax
  0006d	0f 85 72 01 00
	00		 jne	 $LN3@save_unico
  00073	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00077	a8 20		 test	 al, 32			; 00000020H
  00079	0f 85 5e 01 00
	00		 jne	 $LN22@save_unico
  0007f	84 c0		 test	 al, al
  00081	0f 88 56 01 00
	00		 js	 $LN22@save_unico
  00087	a8 02		 test	 al, 2
  00089	0f 85 56 01 00
	00		 jne	 $LN3@save_unico
  0008f	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00093	0f 85 4c 01 00
	00		 jne	 $LN3@save_unico
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000a7	4c 8b cb	 mov	 r9, rbx
  000aa	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000b0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000b8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000bd	48 8b cb	 mov	 rcx, rbx
  000c0	85 c0		 test	 eax, eax
  000c2	0f 84 fb 00 00
	00		 je	 $LN27@save_unico
  000c8	e8 00 00 00 00	 call	 _Px_Dealloc

; 1932 :     return -1;

  000cd	83 c8 ff	 or	 eax, -1

; 1933 : }

  000d0	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000d5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d9	5f		 pop	 rdi
  000da	5e		 pop	 rsi
  000db	5d		 pop	 rbp
  000dc	c3		 ret	 0
$LN13@save_unico:

; 1892 :             goto error;          /* string too large */
; 1893 :         }
; 1894 : 
; 1895 :         pdata[0] = BINUNICODE;
; 1896 :         pdata[1] = (unsigned char)(size & 0xff);
; 1897 :         pdata[2] = (unsigned char)((size >> 8) & 0xff);

  000dd	48 8b c6	 mov	 rax, rsi

; 1898 :         pdata[3] = (unsigned char)((size >> 16) & 0xff);
; 1899 :         pdata[4] = (unsigned char)((size >> 24) & 0xff);
; 1900 : 
; 1901 :         if (_Pickler_Write(self, pdata, 5) < 0)

  000e0	48 8d 54 24 60	 lea	 rdx, QWORD PTR pdata$21672[rsp]
  000e5	41 b8 05 00 00
	00		 mov	 r8d, 5
  000eb	48 c1 f8 08	 sar	 rax, 8
  000ef	48 8b cf	 mov	 rcx, rdi
  000f2	c6 44 24 60 58	 mov	 BYTE PTR pdata$21672[rsp], 88 ; 00000058H
  000f7	88 44 24 62	 mov	 BYTE PTR pdata$21672[rsp+2], al
  000fb	48 8b c6	 mov	 rax, rsi
  000fe	40 88 74 24 61	 mov	 BYTE PTR pdata$21672[rsp+1], sil
  00103	48 c1 f8 10	 sar	 rax, 16
  00107	88 44 24 63	 mov	 BYTE PTR pdata$21672[rsp+3], al
  0010b	48 8b c6	 mov	 rax, rsi
  0010e	48 c1 f8 18	 sar	 rax, 24
  00112	88 44 24 64	 mov	 BYTE PTR pdata$21672[rsp+4], al
  00116	e8 00 00 00 00	 call	 _Pickler_Write
  0011b	48 85 c0	 test	 rax, rax
  0011e	0f 88 42 ff ff
	ff		 js	 $error$21677

; 1902 :             goto error;
; 1903 : 
; 1904 :         if (_Pickler_Write(self, PyBytes_AS_STRING(encoded), size) < 0)

  00124	48 8d 53 78	 lea	 rdx, QWORD PTR [rbx+120]
  00128	4c 8b c6	 mov	 r8, rsi

; 1905 :             goto error;
; 1906 :     }
; 1907 :     else {

  0012b	eb 5b		 jmp	 SHORT $LN30@save_unico
$LN15@save_unico:

; 1908 :         const char unicode_op = UNICODE;
; 1909 : 
; 1910 :         encoded = raw_unicode_escape(obj);

  0012d	48 8b ca	 mov	 rcx, rdx
  00130	c6 44 24 50 56	 mov	 BYTE PTR unicode_op$21691[rsp], 86 ; 00000056H
  00135	e8 00 00 00 00	 call	 raw_unicode_escape
  0013a	48 8b d8	 mov	 rbx, rax

; 1911 :         if (encoded == NULL)

  0013d	48 85 c0	 test	 rax, rax
  00140	0f 84 9f 00 00
	00		 je	 $LN3@save_unico

; 1912 :             goto error;
; 1913 : 
; 1914 :         if (_Pickler_Write(self, &unicode_op, 1) < 0)

  00146	48 8d 54 24 50	 lea	 rdx, QWORD PTR unicode_op$21691[rsp]
  0014b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00151	48 8b cf	 mov	 rcx, rdi
  00154	e8 00 00 00 00	 call	 _Pickler_Write
  00159	48 85 c0	 test	 rax, rax
  0015c	0f 88 04 ff ff
	ff		 js	 $error$21677

; 1915 :             goto error;
; 1916 : 
; 1917 :         size = PyBytes_GET_SIZE(encoded);
; 1918 :         if (_Pickler_Write(self, PyBytes_AS_STRING(encoded), size) < 0)

  00162	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  00166	48 8d 53 78	 lea	 rdx, QWORD PTR [rbx+120]
  0016a	48 8b cf	 mov	 rcx, rdi
  0016d	e8 00 00 00 00	 call	 _Pickler_Write
  00172	48 85 c0	 test	 rax, rax
  00175	0f 88 eb fe ff
	ff		 js	 $error$21677

; 1919 :             goto error;
; 1920 : 
; 1921 :         if (_Pickler_Write(self, "\n", 1) < 0)

  0017b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00181	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
$LN30@save_unico:
  00188	48 8b cf	 mov	 rcx, rdi
  0018b	e8 00 00 00 00	 call	 _Pickler_Write
  00190	48 85 c0	 test	 rax, rax
  00193	0f 88 cd fe ff
	ff		 js	 $error$21677

; 1922 :             goto error;
; 1923 :     }
; 1924 :     if (memo_put(self, obj) < 0)

  00199	48 8b d5	 mov	 rdx, rbp
  0019c	48 8b cf	 mov	 rcx, rdi
  0019f	e8 00 00 00 00	 call	 memo_put
  001a4	85 c0		 test	 eax, eax
  001a6	0f 88 ba fe ff
	ff		 js	 $error$21677

; 1925 :         goto error;
; 1926 : 
; 1927 :     Py_DECREF(encoded);

  001ac	48 8b cb	 mov	 rcx, rbx
  001af	e8 00 00 00 00	 call	 _Py_DecRef

; 1928 :     return 0;

  001b4	33 c0		 xor	 eax, eax

; 1933 : }

  001b6	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  001bb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001bf	5f		 pop	 rdi
  001c0	5e		 pop	 rsi
  001c1	5d		 pop	 rbp
  001c2	c3		 ret	 0

; 1929 : 
; 1930 :   error:
; 1931 :     Py_XDECREF(encoded);

$LN27@save_unico:
  001c3	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001c7	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 1932 :     return -1;

  001cd	83 c8 ff	 or	 eax, -1

; 1933 : }

  001d0	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  001d5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001d9	5f		 pop	 rdi
  001da	5e		 pop	 rsi
  001db	5d		 pop	 rbp
  001dc	c3		 ret	 0

; 1929 : 
; 1930 :   error:
; 1931 :     Py_XDECREF(encoded);

$LN22@save_unico:
  001dd	48 8b cb	 mov	 rcx, rbx
  001e0	e8 00 00 00 00	 call	 Px_DecRef
$LN3@save_unico:

; 1932 :     return -1;

  001e5	83 c8 ff	 or	 eax, -1

; 1933 : }

  001e8	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  001ed	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001f1	5f		 pop	 rdi
  001f2	5e		 pop	 rsi
  001f3	5d		 pop	 rbp
  001f4	c3		 ret	 0
save_unicode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$store_tuple_elements DD imagerel store_tuple_elements
	DD	imagerel store_tuple_elements+100
	DD	imagerel $unwind$store_tuple_elements
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$store_tuple_elements DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT store_tuple_elements
_TEXT	SEGMENT
self$ = 48
t$ = 56
len$ = 64
store_tuple_elements PROC				; COMDAT

; 1938 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1939 :     Py_ssize_t i;
; 1940 : 
; 1941 :     assert(PyTuple_Size(t) == len);
; 1942 : 
; 1943 :     for (i = 0; i < len; i++) {

  00014	33 ff		 xor	 edi, edi
  00016	49 8b f0	 mov	 rsi, r8
  00019	48 8b e9	 mov	 rbp, rcx
  0001c	4d 85 c0	 test	 r8, r8
  0001f	7e 27		 jle	 SHORT $LN3@store_tupl
  00021	48 8d 5a 70	 lea	 rbx, QWORD PTR [rdx+112]
$LL5@store_tupl:

; 1944 :         PyObject *element = PyTuple_GET_ITEM(t, i);

  00025	48 8b 13	 mov	 rdx, QWORD PTR [rbx]

; 1945 : 
; 1946 :         if (element == NULL)

  00028	48 85 d2	 test	 rdx, rdx
  0002b	74 32		 je	 SHORT $LN9@store_tupl

; 1948 :         if (save(self, element, 0) < 0)

  0002d	45 33 c0	 xor	 r8d, r8d
  00030	48 8b cd	 mov	 rcx, rbp
  00033	e8 00 00 00 00	 call	 save
  00038	85 c0		 test	 eax, eax
  0003a	78 23		 js	 SHORT $LN9@store_tupl

; 1939 :     Py_ssize_t i;
; 1940 : 
; 1941 :     assert(PyTuple_Size(t) == len);
; 1942 : 
; 1943 :     for (i = 0; i < len; i++) {

  0003c	48 ff c7	 inc	 rdi
  0003f	48 83 c3 08	 add	 rbx, 8
  00043	48 3b fe	 cmp	 rdi, rsi
  00046	7c dd		 jl	 SHORT $LL5@store_tupl
$LN3@store_tupl:

; 1949 :             return -1;
; 1950 :     }
; 1951 : 
; 1952 :     return 0;

  00048	33 c0		 xor	 eax, eax
$LN6@store_tupl:

; 1953 : }

  0004a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004f	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00054	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5f		 pop	 rdi
  0005e	c3		 ret	 0
$LN9@store_tupl:

; 1947 :             return -1;

  0005f	83 c8 ff	 or	 eax, -1
  00062	eb e6		 jmp	 SHORT $LN6@store_tupl
store_tuple_elements ENDP
_TEXT	ENDS
EXTRN	PyTuple_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_tuple DD imagerel save_tuple
	DD	imagerel save_tuple+151
	DD	imagerel $unwind$save_tuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$save_tuple DD imagerel save_tuple+151
	DD	imagerel save_tuple+538
	DD	imagerel $chain$2$save_tuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$save_tuple DD imagerel save_tuple+538
	DD	imagerel save_tuple+557
	DD	imagerel $chain$3$save_tuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$save_tuple DD 021H
	DD	imagerel save_tuple
	DD	imagerel save_tuple+151
	DD	imagerel $unwind$save_tuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$save_tuple DD 020521H
	DD	0c5405H
	DD	imagerel save_tuple
	DD	imagerel save_tuple+151
	DD	imagerel $unwind$save_tuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_tuple DD 085101H
	DD	06c451H
	DD	07744cH
	DD	0d0057209H
	DD	030026003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT save_tuple
_TEXT	SEGMENT
pop_mark_op$ = 32
tuple_op$ = 33
pdata$21741 = 36
len2opcode$ = 40
self$ = 96
obj$ = 104
pop_op$ = 112
mark_op$ = 120
save_tuple PROC						; COMDAT

; 1963 : {

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	41 55		 push	 r13
  00005	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00009	48 8b f1	 mov	 rsi, rcx

; 1964 :     Py_ssize_t len, i;
; 1965 : 
; 1966 :     const char mark_op = MARK;
; 1967 :     const char tuple_op = TUPLE;
; 1968 :     const char pop_op = POP;
; 1969 :     const char pop_mark_op = POP_MARK;
; 1970 :     const char len2opcode[] = {EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3};
; 1971 : 
; 1972 :     if ((len = PyTuple_Size(obj)) < 0)

  0000c	48 8b ca	 mov	 rcx, rdx
  0000f	4c 8b ea	 mov	 r13, rdx
  00012	c6 44 24 78 28	 mov	 BYTE PTR mark_op$[rsp], 40 ; 00000028H
  00017	c6 44 24 21 74	 mov	 BYTE PTR tuple_op$[rsp], 116 ; 00000074H
  0001c	c6 44 24 70 30	 mov	 BYTE PTR pop_op$[rsp], 48 ; 00000030H
  00021	c6 44 24 20 31	 mov	 BYTE PTR pop_mark_op$[rsp], 49 ; 00000031H
  00026	c7 44 24 28 29
	85 86 87	 mov	 DWORD PTR len2opcode$[rsp], -2021227223 ; 87868529H
  0002e	e8 00 00 00 00	 call	 PyTuple_Size
  00033	48 8b d8	 mov	 rbx, rax
  00036	48 85 c0	 test	 rax, rax
  00039	79 0c		 jns	 SHORT $LN29@save_tuple

; 1973 :         return -1;

  0003b	83 c8 ff	 or	 eax, -1

; 2056 :         return -1;
; 2057 : 
; 2058 :     return 0;
; 2059 : }

  0003e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00042	41 5d		 pop	 r13
  00044	5e		 pop	 rsi
  00045	5b		 pop	 rbx
  00046	c3		 ret	 0
$LN29@save_tuple:
  00047	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0004c	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12

; 1974 : 
; 1975 :     if (len == 0) {

  00051	48 85 c0	 test	 rax, rax
  00054	75 41		 jne	 SHORT $LN28@save_tuple

; 1976 :         char pdata[2];
; 1977 : 
; 1978 :         if (self->proto) {

  00056	39 86 a0 00 00
	00		 cmp	 DWORD PTR [rsi+160], eax
  0005c	74 0b		 je	 SHORT $LN27@save_tuple

; 1979 :             pdata[0] = EMPTY_TUPLE;

  0005e	c6 44 24 24 29	 mov	 BYTE PTR pdata$21741[rsp], 41 ; 00000029H

; 1980 :             len = 1;

  00063	44 8d 60 01	 lea	 r12d, QWORD PTR [rax+1]

; 1981 :         }
; 1982 :         else {

  00067	eb 0d		 jmp	 SHORT $LN26@save_tuple
$LN27@save_tuple:

; 1983 :             pdata[0] = MARK;

  00069	66 c7 44 24 24
	28 74		 mov	 WORD PTR pdata$21741[rsp], 29736 ; 00007428H

; 1984 :             pdata[1] = TUPLE;
; 1985 :             len = 2;

  00070	41 bc 02 00 00
	00		 mov	 r12d, 2
$LN26@save_tuple:

; 1986 :         }
; 1987 :         if (_Pickler_Write(self, pdata, len) < 0)

  00076	48 8d 54 24 24	 lea	 rdx, QWORD PTR pdata$21741[rsp]
  0007b	4d 8b c4	 mov	 r8, r12
  0007e	48 8b ce	 mov	 rcx, rsi
  00081	e8 00 00 00 00	 call	 _Pickler_Write
  00086	33 ff		 xor	 edi, edi
  00088	48 85 c0	 test	 rax, rax
  0008b	40 0f 99 c7	 setns	 dil
  0008f	8d 47 ff	 lea	 eax, DWORD PTR [rdi-1]

; 1988 :             return -1;
; 1989 :         return 0;

  00092	e9 83 01 00 00	 jmp	 $LN39@save_tuple
$LN28@save_tuple:
  00097	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp

; 1990 :     }
; 1991 : 
; 1992 :     /* The tuple isn't in the memo now.  If it shows up there after
; 1993 :      * saving the tuple elements, the tuple must be recursive, in
; 1994 :      * which case we'll pop everything we put on the stack, and fetch
; 1995 :      * its value from the memo.
; 1996 :      */
; 1997 :     if (len <= 3 && self->proto >= 2) {

  0009c	48 83 f8 03	 cmp	 rax, 3
  000a0	0f 8f 9f 00 00
	00		 jg	 $LN24@save_tuple
  000a6	83 be a0 00 00
	00 02		 cmp	 DWORD PTR [rsi+160], 2
  000ad	0f 8c 92 00 00
	00		 jl	 $LN24@save_tuple

; 1998 :         /* Use TUPLE{1,2,3} opcodes. */
; 1999 :         if (store_tuple_elements(self, obj, len) < 0)

  000b3	4c 8b c0	 mov	 r8, rax
  000b6	49 8b d5	 mov	 rdx, r13
  000b9	48 8b ce	 mov	 rcx, rsi
  000bc	e8 00 00 00 00	 call	 store_tuple_elements
  000c1	85 c0		 test	 eax, eax

; 2000 :             return -1;

  000c3	0f 88 dd 00 00
	00		 js	 $LN35@save_tuple

; 2001 : 
; 2002 :         if (PyMemoTable_Get(self->memo, obj)) {

  000c9	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  000cd	49 8b d5	 mov	 rdx, r13
  000d0	e8 00 00 00 00	 call	 PyMemoTable_Get
  000d5	48 85 c0	 test	 rax, rax
  000d8	74 47		 je	 SHORT $LN22@save_tuple

; 2003 :             /* pop the len elements */
; 2004 :             for (i = 0; i < len; i++)

  000da	33 ff		 xor	 edi, edi
  000dc	8b ef		 mov	 ebp, edi
  000de	48 85 db	 test	 rbx, rbx
  000e1	7e 2e		 jle	 SHORT $LN19@save_tuple
  000e3	41 bc 01 00 00
	00		 mov	 r12d, 1
  000e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL21@save_tuple:

; 2005 :                 if (_Pickler_Write(self, &pop_op, 1) < 0)

  000f0	48 8d 54 24 70	 lea	 rdx, QWORD PTR pop_op$[rsp]
  000f5	4d 8b c4	 mov	 r8, r12
  000f8	48 8b ce	 mov	 rcx, rsi
  000fb	e8 00 00 00 00	 call	 _Pickler_Write
  00100	48 85 c0	 test	 rax, rax
  00103	0f 88 9d 00 00
	00		 js	 $LN35@save_tuple

; 2003 :             /* pop the len elements */
; 2004 :             for (i = 0; i < len; i++)

  00109	48 ff c5	 inc	 rbp
  0010c	48 3b eb	 cmp	 rbp, rbx
  0010f	7c df		 jl	 SHORT $LL21@save_tuple
$LN19@save_tuple:

; 2006 :                     return -1;
; 2007 :             /* fetch from memo */
; 2008 :             if (memo_get(self, obj) < 0)

  00111	49 8b d5	 mov	 rdx, r13
  00114	48 8b ce	 mov	 rcx, rsi
  00117	e8 00 00 00 00	 call	 memo_get

; 2009 :                 return -1;
; 2010 : 
; 2011 :             return 0;

  0011c	e9 eb 00 00 00	 jmp	 $LN41@save_tuple
$LN22@save_tuple:

; 2012 :         }
; 2013 :         else { /* Not recursive. */
; 2014 :             if (_Pickler_Write(self, len2opcode + len, 1) < 0)

  00121	48 8d 54 1c 28	 lea	 rdx, QWORD PTR len2opcode$[rsp+rbx]
  00126	41 b8 01 00 00
	00		 mov	 r8d, 1
  0012c	48 8b ce	 mov	 rcx, rsi
  0012f	e8 00 00 00 00	 call	 _Pickler_Write
  00134	48 85 c0	 test	 rax, rax
  00137	0f 89 c2 00 00
	00		 jns	 $memoize$21755

; 2015 :                 return -1;

  0013d	83 c8 ff	 or	 eax, -1
  00140	e9 d0 00 00 00	 jmp	 $LN40@save_tuple
$LN24@save_tuple:

; 2016 :         }
; 2017 :         goto memoize;
; 2018 :     }
; 2019 : 
; 2020 :     /* proto < 2 and len > 0, or proto >= 2 and len > 3.
; 2021 :      * Generate MARK e1 e2 ... TUPLE
; 2022 :      */
; 2023 :     if (_Pickler_Write(self, &mark_op, 1) < 0)

  00145	41 bc 01 00 00
	00		 mov	 r12d, 1
  0014b	48 8d 54 24 78	 lea	 rdx, QWORD PTR mark_op$[rsp]
  00150	48 8b ce	 mov	 rcx, rsi
  00153	45 8b c4	 mov	 r8d, r12d
  00156	e8 00 00 00 00	 call	 _Pickler_Write
  0015b	48 85 c0	 test	 rax, rax

; 2024 :         return -1;

  0015e	78 46		 js	 SHORT $LN35@save_tuple

; 2025 : 
; 2026 :     if (store_tuple_elements(self, obj, len) < 0)

  00160	4c 8b c3	 mov	 r8, rbx
  00163	49 8b d5	 mov	 rdx, r13
  00166	48 8b ce	 mov	 rcx, rsi
  00169	e8 00 00 00 00	 call	 store_tuple_elements
  0016e	85 c0		 test	 eax, eax

; 2027 :         return -1;

  00170	78 34		 js	 SHORT $LN35@save_tuple

; 2028 : 
; 2029 :     if (PyMemoTable_Get(self->memo, obj)) {

  00172	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  00176	49 8b d5	 mov	 rdx, r13
  00179	e8 00 00 00 00	 call	 PyMemoTable_Get
  0017e	48 85 c0	 test	 rax, rax
  00181	74 67		 je	 SHORT $LN12@save_tuple

; 2030 :         /* pop the stack stuff we pushed */
; 2031 :         if (self->bin) {

  00183	33 ff		 xor	 edi, edi
  00185	39 be a4 00 00
	00		 cmp	 DWORD PTR [rsi+164], edi
  0018b	74 1e		 je	 SHORT $LN11@save_tuple

; 2032 :             if (_Pickler_Write(self, &pop_mark_op, 1) < 0)

  0018d	48 8d 54 24 20	 lea	 rdx, QWORD PTR pop_mark_op$[rsp]
  00192	45 8b c4	 mov	 r8d, r12d
  00195	48 8b ce	 mov	 rcx, rsi
  00198	e8 00 00 00 00	 call	 _Pickler_Write
  0019d	48 85 c0	 test	 rax, rax
  001a0	0f 89 6b ff ff
	ff		 jns	 $LN19@save_tuple
$LN35@save_tuple:

; 2033 :                 return -1;

  001a6	83 c8 ff	 or	 eax, -1
  001a9	eb 6a		 jmp	 SHORT $LN40@save_tuple
$LN11@save_tuple:

; 2034 :         }
; 2035 :         else {
; 2036 :             /* Note that we pop one more than len, to remove
; 2037 :              * the MARK too.
; 2038 :              */
; 2039 :             for (i = 0; i <= len; i++)

  001ab	48 8b ef	 mov	 rbp, rdi
  001ae	48 85 db	 test	 rbx, rbx
  001b1	0f 88 5a ff ff
	ff		 js	 $LN19@save_tuple
  001b7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL8@save_tuple:

; 2040 :                 if (_Pickler_Write(self, &pop_op, 1) < 0)

  001c0	48 8d 54 24 70	 lea	 rdx, QWORD PTR pop_op$[rsp]
  001c5	4d 8b c4	 mov	 r8, r12
  001c8	48 8b ce	 mov	 rcx, rsi
  001cb	e8 00 00 00 00	 call	 _Pickler_Write
  001d0	48 85 c0	 test	 rax, rax
  001d3	78 d1		 js	 SHORT $LN35@save_tuple

; 2034 :         }
; 2035 :         else {
; 2036 :             /* Note that we pop one more than len, to remove
; 2037 :              * the MARK too.
; 2038 :              */
; 2039 :             for (i = 0; i <= len; i++)

  001d5	48 ff c5	 inc	 rbp
  001d8	48 3b eb	 cmp	 rbp, rbx
  001db	7e e3		 jle	 SHORT $LL8@save_tuple

; 2006 :                     return -1;
; 2007 :             /* fetch from memo */
; 2008 :             if (memo_get(self, obj) < 0)

  001dd	49 8b d5	 mov	 rdx, r13
  001e0	48 8b ce	 mov	 rcx, rsi
  001e3	e8 00 00 00 00	 call	 memo_get

; 2009 :                 return -1;
; 2010 : 
; 2011 :             return 0;

  001e8	eb 22		 jmp	 SHORT $LN41@save_tuple
$LN12@save_tuple:

; 2041 :                     return -1;
; 2042 :         }
; 2043 :         /* fetch from memo */
; 2044 :         if (memo_get(self, obj) < 0)
; 2045 :             return -1;
; 2046 : 
; 2047 :         return 0;
; 2048 :     }
; 2049 :     else { /* Not recursive. */
; 2050 :         if (_Pickler_Write(self, &tuple_op, 1) < 0)

  001ea	48 8d 54 24 21	 lea	 rdx, QWORD PTR tuple_op$[rsp]
  001ef	4d 8b c4	 mov	 r8, r12
  001f2	48 8b ce	 mov	 rcx, rsi
  001f5	e8 00 00 00 00	 call	 _Pickler_Write
  001fa	48 85 c0	 test	 rax, rax

; 2051 :             return -1;

  001fd	78 a7		 js	 SHORT $LN35@save_tuple
$memoize$21755:

; 2052 :     }
; 2053 : 
; 2054 :   memoize:
; 2055 :     if (memo_put(self, obj) < 0)

  001ff	49 8b d5	 mov	 rdx, r13
  00202	48 8b ce	 mov	 rcx, rsi
  00205	e8 00 00 00 00	 call	 memo_put
  0020a	33 ff		 xor	 edi, edi
$LN41@save_tuple:
  0020c	85 c0		 test	 eax, eax
  0020e	40 0f 99 c7	 setns	 dil
  00212	8d 47 ff	 lea	 eax, DWORD PTR [rdi-1]
$LN40@save_tuple:
  00215	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
$LN39@save_tuple:
  0021a	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  0021f	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]

; 2056 :         return -1;
; 2057 : 
; 2058 :     return 0;
; 2059 : }

  00224	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00228	41 5d		 pop	 r13
  0022a	5e		 pop	 rsi
  0022b	5b		 pop	 rbx
  0022c	c3		 ret	 0
save_tuple ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@BDEHMLLL@batch_list?$AA@		; `string'
EXTRN	PyIter_Next:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$batch_list DD imagerel batch_list
	DD	imagerel batch_list+268
	DD	imagerel $unwind$batch_list
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$batch_list DD imagerel batch_list+268
	DD	imagerel batch_list+1164
	DD	imagerel $chain$1$batch_list
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$batch_list DD 040a21H
	DD	06640aH
	DD	0d5405H
	DD	imagerel batch_list
	DD	imagerel batch_list+268
	DD	imagerel $unwind$batch_list
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$batch_list DD 050b01H
	DD	0d007620bH
	DD	07003c005H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_0L@BDEHMLLL@batch_list?$AA@
CONST	SEGMENT
??_C@_0L@BDEHMLLL@batch_list?$AA@ DB 'batch_list', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT batch_list
_TEXT	SEGMENT
append_op$ = 96
self$ = 96
iter$ = 104
mark_op$ = 112
appends_op$ = 120
batch_list PROC						; COMDAT

; 2069 : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2070 :     PyObject *obj = NULL;

  0000b	33 ff		 xor	 edi, edi
  0000d	4c 8b ea	 mov	 r13, rdx
  00010	4c 8b e1	 mov	 r12, rcx

; 2071 :     PyObject *firstitem = NULL;
; 2072 :     int i, n;
; 2073 : 
; 2074 :     const char mark_op = MARK;

  00013	c6 44 24 70 28	 mov	 BYTE PTR mark_op$[rsp], 40 ; 00000028H

; 2075 :     const char append_op = APPEND;

  00018	c6 44 24 60 61	 mov	 BYTE PTR append_op$[rsp], 97 ; 00000061H

; 2076 :     const char appends_op = APPENDS;

  0001d	c6 44 24 78 65	 mov	 BYTE PTR appends_op$[rsp], 101 ; 00000065H

; 2077 : 
; 2078 :     assert(iter != NULL);
; 2079 : 
; 2080 :     /* XXX: I think this function could be made faster by avoiding the
; 2081 :        iterator interface and fetching objects directly from list using
; 2082 :        PyList_GET_ITEM.
; 2083 :     */
; 2084 : 
; 2085 :     if (self->proto == 0) {

  00022	39 b9 a0 00 00
	00		 cmp	 DWORD PTR [rcx+160], edi
  00028	0f 85 de 00 00
	00		 jne	 $LN124@batch_list

; 2086 :         /* APPENDS isn't available; do one at a time. */
; 2087 :         for (;;) {
; 2088 :             obj = PyIter_Next(iter);

  0002e	48 8b ca	 mov	 rcx, rdx
  00031	e8 00 00 00 00	 call	 PyIter_Next
  00036	48 8b d8	 mov	 rbx, rax

; 2089 :             if (obj == NULL) {

  00039	48 85 c0	 test	 rax, rax
  0003c	0f 84 a7 00 00
	00		 je	 $LN106@batch_list
$LL44@batch_list:

; 2091 :                     return -1;
; 2092 :                 break;
; 2093 :             }
; 2094 :             i = save(self, obj, 0);

  00042	45 33 c0	 xor	 r8d, r8d
  00045	48 8b d3	 mov	 rdx, rbx
  00048	49 8b cc	 mov	 rcx, r12
  0004b	e8 00 00 00 00	 call	 save
  00050	8b f8		 mov	 edi, eax

; 2095 :             Py_DECREF(obj);

  00052	e8 00 00 00 00	 call	 _Py_PXCTX
  00057	85 c0		 test	 eax, eax
  00059	75 5e		 jne	 SHORT $LN58@batch_list
  0005b	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  0005f	f6 c1 20	 test	 cl, 32			; 00000020H
  00062	75 4d		 jne	 SHORT $LN52@batch_list
  00064	84 c9		 test	 cl, cl
  00066	78 49		 js	 SHORT $LN52@batch_list
  00068	f6 c1 02	 test	 cl, 2
  0006b	75 4c		 jne	 SHORT $LN58@batch_list
  0006d	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00071	75 46		 jne	 SHORT $LN58@batch_list
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00081	4c 8b cb	 mov	 r9, rbx
  00084	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0008a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00092	e8 00 00 00 00	 call	 _PyParallel_Guard
  00097	48 8b cb	 mov	 rcx, rbx
  0009a	85 c0		 test	 eax, eax
  0009c	74 07		 je	 SHORT $LN57@batch_list
  0009e	e8 00 00 00 00	 call	 _Px_Dealloc
  000a3	eb 14		 jmp	 SHORT $LN58@batch_list
$LN57@batch_list:
  000a5	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000a9	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000af	eb 08		 jmp	 SHORT $LN58@batch_list
$LN52@batch_list:
  000b1	48 8b cb	 mov	 rcx, rbx
  000b4	e8 00 00 00 00	 call	 Px_DecRef
$LN58@batch_list:

; 2096 :             if (i < 0)

  000b9	85 ff		 test	 edi, edi
  000bb	78 41		 js	 SHORT $LN107@batch_list

; 2098 :             if (_Pickler_Write(self, &append_op, 1) < 0)

  000bd	48 8d 54 24 60	 lea	 rdx, QWORD PTR append_op$[rsp]
  000c2	41 b8 01 00 00
	00		 mov	 r8d, 1
  000c8	49 8b cc	 mov	 rcx, r12
  000cb	e8 00 00 00 00	 call	 _Pickler_Write
  000d0	48 85 c0	 test	 rax, rax
  000d3	78 29		 js	 SHORT $LN107@batch_list

; 2086 :         /* APPENDS isn't available; do one at a time. */
; 2087 :         for (;;) {
; 2088 :             obj = PyIter_Next(iter);

  000d5	49 8b cd	 mov	 rcx, r13
  000d8	e8 00 00 00 00	 call	 PyIter_Next
  000dd	48 8b d8	 mov	 rbx, rax

; 2089 :             if (obj == NULL) {

  000e0	48 85 c0	 test	 rax, rax
  000e3	0f 85 59 ff ff
	ff		 jne	 $LL44@batch_list
$LN106@batch_list:

; 2090 :                 if (PyErr_Occurred())

  000e9	e8 00 00 00 00	 call	 PyErr_Occurred
  000ee	48 f7 d8	 neg	 rax
  000f1	1b c0		 sbb	 eax, eax

; 2170 : }

  000f3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f7	41 5d		 pop	 r13
  000f9	41 5c		 pop	 r12
  000fb	5f		 pop	 rdi
  000fc	5b		 pop	 rbx
  000fd	c3		 ret	 0
$LN107@batch_list:

; 2097 :                 return -1;

  000fe	83 c8 ff	 or	 eax, -1

; 2170 : }

  00101	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00105	41 5d		 pop	 r13
  00107	41 5c		 pop	 r12
  00109	5f		 pop	 rdi
  0010a	5b		 pop	 rbx
  0010b	c3		 ret	 0
$LN124@batch_list:
  0010c	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp
  00111	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
$LL38@batch_list:

; 2099 :                 return -1;
; 2100 :         }
; 2101 :         return 0;
; 2102 :     }
; 2103 : 
; 2104 :     /* proto > 0:  write in batches of BATCHSIZE. */
; 2105 :     do {
; 2106 :         /* Get first item */
; 2107 :         firstitem = PyIter_Next(iter);

  00116	49 8b cd	 mov	 rcx, r13
  00119	e8 00 00 00 00	 call	 PyIter_Next
  0011e	48 8b e8	 mov	 rbp, rax

; 2108 :         if (firstitem == NULL) {

  00121	48 85 c0	 test	 rax, rax
  00124	0f 84 28 03 00
	00		 je	 $LN112@batch_list

; 2110 :                 goto error;
; 2111 : 
; 2112 :             /* nothing more to add */
; 2113 :             break;
; 2114 :         }
; 2115 : 
; 2116 :         /* Try to get a second item */
; 2117 :         obj = PyIter_Next(iter);

  0012a	49 8b cd	 mov	 rcx, r13
  0012d	e8 00 00 00 00	 call	 PyIter_Next
  00132	48 8b f8	 mov	 rdi, rax

; 2118 :         if (obj == NULL) {

  00135	48 85 c0	 test	 rax, rax
  00138	0f 84 d5 01 00
	00		 je	 $LN113@batch_list

; 2128 :             break;
; 2129 :         }
; 2130 : 
; 2131 :         /* More than one item to write */
; 2132 : 
; 2133 :         /* Pump out MARK, items, APPENDS. */
; 2134 :         if (_Pickler_Write(self, &mark_op, 1) < 0)

  0013e	48 8d 54 24 70	 lea	 rdx, QWORD PTR mark_op$[rsp]
  00143	41 b8 01 00 00
	00		 mov	 r8d, 1
  00149	49 8b cc	 mov	 rcx, r12
  0014c	e8 00 00 00 00	 call	 _Pickler_Write
  00151	48 85 c0	 test	 rax, rax
  00154	0f 88 28 02 00
	00		 js	 $error$21802

; 2135 :             goto error;
; 2136 : 
; 2137 :         if (save(self, firstitem, 0) < 0)

  0015a	45 33 c0	 xor	 r8d, r8d
  0015d	48 8b d5	 mov	 rdx, rbp
  00160	49 8b cc	 mov	 rcx, r12
  00163	e8 00 00 00 00	 call	 save
  00168	85 c0		 test	 eax, eax
  0016a	0f 88 12 02 00
	00		 js	 $error$21802

; 2138 :             goto error;
; 2139 :         Py_CLEAR(firstitem);

  00170	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@BDEHMLLL@batch_list?$AA@
  0017e	4c 8b cd	 mov	 r9, rbp
  00181	41 b8 5b 08 00
	00		 mov	 r8d, 2139		; 0000085bH
  00187	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0018f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00194	85 c0		 test	 eax, eax
  00196	75 6a		 jne	 SHORT $LN22@batch_list
  00198	48 8b dd	 mov	 rbx, rbp
  0019b	33 ed		 xor	 ebp, ebp
  0019d	e8 00 00 00 00	 call	 _Py_PXCTX
  001a2	85 c0		 test	 eax, eax
  001a4	75 5c		 jne	 SHORT $LN22@batch_list
  001a6	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001aa	a8 20		 test	 al, 32			; 00000020H
  001ac	75 4c		 jne	 SHORT $LN63@batch_list
  001ae	84 c0		 test	 al, al
  001b0	78 48		 js	 SHORT $LN63@batch_list
  001b2	a8 02		 test	 al, 2
  001b4	75 4c		 jne	 SHORT $LN22@batch_list
  001b6	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001ba	75 46		 jne	 SHORT $LN22@batch_list
  001bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001ca	4c 8b cb	 mov	 r9, rbx
  001cd	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001d3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001db	e8 00 00 00 00	 call	 _PyParallel_Guard
  001e0	48 8b cb	 mov	 rcx, rbx
  001e3	85 c0		 test	 eax, eax
  001e5	74 07		 je	 SHORT $LN68@batch_list
  001e7	e8 00 00 00 00	 call	 _Px_Dealloc
  001ec	eb 14		 jmp	 SHORT $LN22@batch_list
$LN68@batch_list:
  001ee	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001f2	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001f8	eb 08		 jmp	 SHORT $LN22@batch_list
$LN63@batch_list:
  001fa	48 8b cb	 mov	 rcx, rbx
  001fd	e8 00 00 00 00	 call	 Px_DecRef
$LN22@batch_list:

; 2140 :         n = 1;

  00202	be 01 00 00 00	 mov	 esi, 1
  00207	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL19@batch_list:

; 2141 : 
; 2142 :         /* Fetch and save up to BATCHSIZE items */
; 2143 :         while (obj) {
; 2144 :             if (save(self, obj, 0) < 0)

  00210	45 33 c0	 xor	 r8d, r8d
  00213	48 8b d7	 mov	 rdx, rdi
  00216	49 8b cc	 mov	 rcx, r12
  00219	e8 00 00 00 00	 call	 save
  0021e	85 c0		 test	 eax, eax
  00220	0f 88 5c 01 00
	00		 js	 $error$21802

; 2145 :                 goto error;
; 2146 :             Py_CLEAR(obj);

  00226	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0022d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@BDEHMLLL@batch_list?$AA@
  00234	4c 8b cf	 mov	 r9, rdi
  00237	41 b8 62 08 00
	00		 mov	 r8d, 2146		; 00000862H
  0023d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00245	e8 00 00 00 00	 call	 _PyParallel_Guard
  0024a	85 c0		 test	 eax, eax
  0024c	75 6a		 jne	 SHORT $LN15@batch_list
  0024e	48 8b df	 mov	 rbx, rdi
  00251	33 ff		 xor	 edi, edi
  00253	e8 00 00 00 00	 call	 _Py_PXCTX
  00258	85 c0		 test	 eax, eax
  0025a	75 5c		 jne	 SHORT $LN15@batch_list
  0025c	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00260	a8 20		 test	 al, 32			; 00000020H
  00262	75 4c		 jne	 SHORT $LN74@batch_list
  00264	84 c0		 test	 al, al
  00266	78 48		 js	 SHORT $LN74@batch_list
  00268	a8 02		 test	 al, 2
  0026a	75 4c		 jne	 SHORT $LN15@batch_list
  0026c	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00270	75 46		 jne	 SHORT $LN15@batch_list
  00272	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00280	4c 8b cb	 mov	 r9, rbx
  00283	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00289	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00291	e8 00 00 00 00	 call	 _PyParallel_Guard
  00296	48 8b cb	 mov	 rcx, rbx
  00299	85 c0		 test	 eax, eax
  0029b	74 07		 je	 SHORT $LN79@batch_list
  0029d	e8 00 00 00 00	 call	 _Px_Dealloc
  002a2	eb 14		 jmp	 SHORT $LN15@batch_list
$LN79@batch_list:
  002a4	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  002a8	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002ae	eb 08		 jmp	 SHORT $LN15@batch_list
$LN74@batch_list:
  002b0	48 8b cb	 mov	 rcx, rbx
  002b3	e8 00 00 00 00	 call	 Px_DecRef
$LN15@batch_list:

; 2147 :             n += 1;

  002b8	ff c6		 inc	 esi

; 2148 : 
; 2149 :             if (n == BATCHSIZE)

  002ba	81 fe e8 03 00
	00		 cmp	 esi, 1000		; 000003e8H
  002c0	74 22		 je	 SHORT $LN10@batch_list

; 2150 :                 break;
; 2151 : 
; 2152 :             obj = PyIter_Next(iter);

  002c2	49 8b cd	 mov	 rcx, r13
  002c5	e8 00 00 00 00	 call	 PyIter_Next
  002ca	48 8b f8	 mov	 rdi, rax

; 2153 :             if (obj == NULL) {

  002cd	48 85 c0	 test	 rax, rax
  002d0	0f 85 3a ff ff
	ff		 jne	 $LL19@batch_list

; 2154 :                 if (PyErr_Occurred())

  002d6	e8 00 00 00 00	 call	 PyErr_Occurred
  002db	48 85 c0	 test	 rax, rax
  002de	0f 85 9e 00 00
	00		 jne	 $error$21802
$LN10@batch_list:

; 2155 :                     goto error;
; 2156 :                 break;
; 2157 :             }
; 2158 :         }
; 2159 : 
; 2160 :         if (_Pickler_Write(self, &appends_op, 1) < 0)

  002e4	48 8d 54 24 78	 lea	 rdx, QWORD PTR appends_op$[rsp]
  002e9	41 b8 01 00 00
	00		 mov	 r8d, 1
  002ef	49 8b cc	 mov	 rcx, r12
  002f2	e8 00 00 00 00	 call	 _Pickler_Write
  002f7	48 85 c0	 test	 rax, rax
  002fa	0f 88 82 00 00
	00		 js	 $error$21802

; 2161 :             goto error;
; 2162 : 
; 2163 :     } while (n == BATCHSIZE);

  00300	81 fe e8 03 00
	00		 cmp	 esi, 1000		; 000003e8H
  00306	0f 84 0a fe ff
	ff		 je	 $LL38@batch_list

; 2164 :     return 0;

  0030c	33 c0		 xor	 eax, eax
  0030e	e9 64 01 00 00	 jmp	 $LN127@batch_list
$LN113@batch_list:

; 2119 :             if (PyErr_Occurred())

  00313	e8 00 00 00 00	 call	 PyErr_Occurred
  00318	48 85 c0	 test	 rax, rax
  0031b	75 65		 jne	 SHORT $error$21802

; 2120 :                 goto error;
; 2121 : 
; 2122 :             /* Only one item to write */
; 2123 :             if (save(self, firstitem, 0) < 0)

  0031d	45 33 c0	 xor	 r8d, r8d
  00320	48 8b d5	 mov	 rdx, rbp
  00323	49 8b cc	 mov	 rcx, r12
  00326	e8 00 00 00 00	 call	 save
  0032b	85 c0		 test	 eax, eax
  0032d	78 53		 js	 SHORT $error$21802

; 2124 :                 goto error;
; 2125 :             if (_Pickler_Write(self, &append_op, 1) < 0)

  0032f	48 8d 54 24 60	 lea	 rdx, QWORD PTR append_op$[rsp]
  00334	41 b8 01 00 00
	00		 mov	 r8d, 1
  0033a	49 8b cc	 mov	 rcx, r12
  0033d	e8 00 00 00 00	 call	 _Pickler_Write
  00342	48 85 c0	 test	 rax, rax
  00345	78 3b		 js	 SHORT $error$21802

; 2126 :                 goto error;
; 2127 :             Py_CLEAR(firstitem);

  00347	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0034e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@BDEHMLLL@batch_list?$AA@
  00355	4c 8b cd	 mov	 r9, rbp
  00358	41 b8 4f 08 00
	00		 mov	 r8d, 2127		; 0000084fH
  0035e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00366	e8 00 00 00 00	 call	 _PyParallel_Guard
  0036b	85 c0		 test	 eax, eax
  0036d	0f 85 e9 00 00
	00		 jne	 $LN36@batch_list
  00373	48 8b cd	 mov	 rcx, rbp
  00376	e8 00 00 00 00	 call	 _Py_DecRef

; 2164 :     return 0;

  0037b	33 c0		 xor	 eax, eax
  0037d	e9 f5 00 00 00	 jmp	 $LN127@batch_list
$error$21802:

; 2165 : 
; 2166 :   error:
; 2167 :     Py_XDECREF(firstitem);

  00382	48 85 ed	 test	 rbp, rbp
  00385	74 57		 je	 SHORT $LN7@batch_list
  00387	e8 00 00 00 00	 call	 _Py_PXCTX
  0038c	85 c0		 test	 eax, eax
  0038e	75 4e		 jne	 SHORT $LN7@batch_list
  00390	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  00394	a8 20		 test	 al, 32			; 00000020H
  00396	0f 85 ac 00 00
	00		 jne	 $LN85@batch_list
  0039c	84 c0		 test	 al, al
  0039e	0f 88 a4 00 00
	00		 js	 $LN85@batch_list
  003a4	a8 02		 test	 al, 2
  003a6	75 36		 jne	 SHORT $LN7@batch_list
  003a8	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  003ac	75 30		 jne	 SHORT $LN7@batch_list
  003ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  003bc	4c 8b cd	 mov	 r9, rbp
  003bf	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  003c5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003cd	e8 00 00 00 00	 call	 _PyParallel_Guard
  003d2	48 8b cd	 mov	 rcx, rbp
  003d5	85 c0		 test	 eax, eax
  003d7	74 63		 je	 SHORT $LN90@batch_list
  003d9	e8 00 00 00 00	 call	 _Px_Dealloc
$LN7@batch_list:

; 2168 :     Py_XDECREF(obj);

  003de	48 85 ff	 test	 rdi, rdi
  003e1	0f 84 8d 00 00
	00		 je	 $LN3@batch_list
  003e7	e8 00 00 00 00	 call	 _Py_PXCTX
  003ec	85 c0		 test	 eax, eax
  003ee	0f 85 80 00 00
	00		 jne	 $LN3@batch_list
  003f4	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  003f8	a8 20		 test	 al, 32			; 00000020H
  003fa	75 70		 jne	 SHORT $LN96@batch_list
  003fc	84 c0		 test	 al, al
  003fe	78 6c		 js	 SHORT $LN96@batch_list
  00400	a8 02		 test	 al, 2
  00402	75 70		 jne	 SHORT $LN3@batch_list
  00404	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00408	75 6a		 jne	 SHORT $LN3@batch_list
  0040a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00411	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00418	4c 8b cf	 mov	 r9, rdi
  0041b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00421	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00429	e8 00 00 00 00	 call	 _PyParallel_Guard
  0042e	48 8b cf	 mov	 rcx, rdi
  00431	85 c0		 test	 eax, eax
  00433	74 2b		 je	 SHORT $LN101@batch_list
  00435	e8 00 00 00 00	 call	 _Px_Dealloc
  0043a	eb 38		 jmp	 SHORT $LN3@batch_list

; 2165 : 
; 2166 :   error:
; 2167 :     Py_XDECREF(firstitem);

$LN90@batch_list:
  0043c	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  00440	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00446	eb 96		 jmp	 SHORT $LN7@batch_list
$LN85@batch_list:
  00448	48 8b cd	 mov	 rcx, rbp
  0044b	e8 00 00 00 00	 call	 Px_DecRef
  00450	eb 8c		 jmp	 SHORT $LN7@batch_list
$LN112@batch_list:

; 2109 :             if (PyErr_Occurred())

  00452	e8 00 00 00 00	 call	 PyErr_Occurred
  00457	48 85 c0	 test	 rax, rax
  0045a	75 82		 jne	 SHORT $LN7@batch_list
$LN36@batch_list:

; 2164 :     return 0;

  0045c	33 c0		 xor	 eax, eax
  0045e	eb 17		 jmp	 SHORT $LN127@batch_list

; 2168 :     Py_XDECREF(obj);

$LN101@batch_list:
  00460	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00464	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0046a	eb 08		 jmp	 SHORT $LN3@batch_list
$LN96@batch_list:
  0046c	48 8b cf	 mov	 rcx, rdi
  0046f	e8 00 00 00 00	 call	 Px_DecRef
$LN3@batch_list:

; 2169 :     return -1;

  00474	83 c8 ff	 or	 eax, -1
$LN127@batch_list:
  00477	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  0047c	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 2170 : }

  00481	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00485	41 5d		 pop	 r13
  00487	41 5c		 pop	 r12
  00489	5f		 pop	 rdi
  0048a	5b		 pop	 rbx
  0048b	c3		 ret	 0
batch_list ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$batch_list_exact DD imagerel batch_list_exact
	DD	imagerel batch_list_exact+261
	DD	imagerel $unwind$batch_list_exact
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$batch_list_exact DD 087c01H
	DD	04747cH
	DD	053474H
	DD	0c0055209H
	DD	050026003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT batch_list_exact
_TEXT	SEGMENT
self$ = 80
append_op$ = 88
obj$ = 88
mark_op$ = 96
appends_op$ = 104
batch_list_exact PROC					; COMDAT

; 2185 : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	41 54		 push	 r12
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2186 :     PyObject *item = NULL;
; 2187 :     Py_ssize_t this_batch, total;
; 2188 : 
; 2189 :     const char append_op = APPEND;
; 2190 :     const char appends_op = APPENDS;
; 2191 :     const char mark_op = MARK;
; 2192 : 
; 2193 :     assert(obj != NULL);
; 2194 :     assert(self->proto > 0);
; 2195 :     assert(PyList_CheckExact(obj));
; 2196 : 
; 2197 :     if (PyList_GET_SIZE(obj) == 1) {

  00009	48 83 7a 60 01	 cmp	 QWORD PTR [rdx+96], 1
  0000e	48 8b f2	 mov	 rsi, rdx
  00011	48 8b e9	 mov	 rbp, rcx
  00014	c6 44 24 58 61	 mov	 BYTE PTR append_op$[rsp], 97 ; 00000061H
  00019	c6 44 24 68 65	 mov	 BYTE PTR appends_op$[rsp], 101 ; 00000065H
  0001e	c6 44 24 60 28	 mov	 BYTE PTR mark_op$[rsp], 40 ; 00000028H
  00023	75 4a		 jne	 SHORT $LN12@batch_list@2

; 2198 :         item = PyList_GET_ITEM(obj, 0);

  00025	48 8b 42 70	 mov	 rax, QWORD PTR [rdx+112]

; 2199 :         if (save(self, item, 0) < 0)

  00029	45 33 c0	 xor	 r8d, r8d
  0002c	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0002f	e8 00 00 00 00	 call	 save
  00034	85 c0		 test	 eax, eax
  00036	79 0c		 jns	 SHORT $LN11@batch_list@2

; 2200 :             return -1;

  00038	83 c8 ff	 or	 eax, -1

; 2226 : }

  0003b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003f	41 5c		 pop	 r12
  00041	5e		 pop	 rsi
  00042	5d		 pop	 rbp
  00043	c3		 ret	 0
$LN11@batch_list@2:

; 2201 :         if (_Pickler_Write(self, &append_op, 1) < 0)

  00044	48 8d 54 24 58	 lea	 rdx, QWORD PTR append_op$[rsp]
  00049	41 b8 01 00 00
	00		 mov	 r8d, 1
  0004f	48 8b cd	 mov	 rcx, rbp
  00052	e8 00 00 00 00	 call	 _Pickler_Write
  00057	45 33 e4	 xor	 r12d, r12d
  0005a	48 85 c0	 test	 rax, rax
  0005d	41 0f 99 c4	 setns	 r12b
  00061	41 8d 44 24 ff	 lea	 eax, DWORD PTR [r12-1]

; 2226 : }

  00066	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006a	41 5c		 pop	 r12
  0006c	5e		 pop	 rsi
  0006d	5d		 pop	 rbp
  0006e	c3		 ret	 0
$LN12@batch_list@2:
  0006f	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx

; 2202 :             return -1;
; 2203 :         return 0;
; 2204 :     }
; 2205 : 
; 2206 :     /* Write in batches of BATCHSIZE. */
; 2207 :     total = 0;

  00074	45 33 e4	 xor	 r12d, r12d
  00077	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0007c	41 8b dc	 mov	 ebx, r12d
  0007f	90		 npad	 1
$LL9@batch_list@2:

; 2208 :     do {
; 2209 :         this_batch = 0;
; 2210 :         if (_Pickler_Write(self, &mark_op, 1) < 0)

  00080	48 8d 54 24 60	 lea	 rdx, QWORD PTR mark_op$[rsp]
  00085	41 b8 01 00 00
	00		 mov	 r8d, 1
  0008b	48 8b cd	 mov	 rcx, rbp
  0008e	49 8b fc	 mov	 rdi, r12
  00091	e8 00 00 00 00	 call	 _Pickler_Write
  00096	48 85 c0	 test	 rax, rax
  00099	78 54		 js	 SHORT $LN19@batch_list@2

; 2212 :         while (total < PyList_GET_SIZE(obj)) {

  0009b	48 3b 5e 60	 cmp	 rbx, QWORD PTR [rsi+96]
  0009f	7d 2c		 jge	 SHORT $LN18@batch_list@2
$LL5@batch_list@2:

; 2213 :             item = PyList_GET_ITEM(obj, total);

  000a1	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]

; 2214 :             if (save(self, item, 0) < 0)

  000a5	45 33 c0	 xor	 r8d, r8d
  000a8	48 8b cd	 mov	 rcx, rbp
  000ab	48 8b 14 d8	 mov	 rdx, QWORD PTR [rax+rbx*8]
  000af	e8 00 00 00 00	 call	 save
  000b4	85 c0		 test	 eax, eax
  000b6	78 37		 js	 SHORT $LN19@batch_list@2

; 2215 :                 return -1;
; 2216 :             total++;
; 2217 :             if (++this_batch == BATCHSIZE)

  000b8	48 ff c7	 inc	 rdi
  000bb	48 ff c3	 inc	 rbx
  000be	48 81 ff e8 03
	00 00		 cmp	 rdi, 1000		; 000003e8H
  000c5	74 06		 je	 SHORT $LN18@batch_list@2

; 2212 :         while (total < PyList_GET_SIZE(obj)) {

  000c7	48 3b 5e 60	 cmp	 rbx, QWORD PTR [rsi+96]
  000cb	7c d4		 jl	 SHORT $LL5@batch_list@2
$LN18@batch_list@2:

; 2218 :                 break;
; 2219 :         }
; 2220 :         if (_Pickler_Write(self, &appends_op, 1) < 0)

  000cd	48 8d 54 24 68	 lea	 rdx, QWORD PTR appends_op$[rsp]
  000d2	41 b8 01 00 00
	00		 mov	 r8d, 1
  000d8	48 8b cd	 mov	 rcx, rbp
  000db	e8 00 00 00 00	 call	 _Pickler_Write
  000e0	48 85 c0	 test	 rax, rax
  000e3	78 0a		 js	 SHORT $LN19@batch_list@2

; 2221 :             return -1;
; 2222 : 
; 2223 :     } while (total < PyList_GET_SIZE(obj));

  000e5	48 3b 5e 60	 cmp	 rbx, QWORD PTR [rsi+96]
  000e9	7c 95		 jl	 SHORT $LL9@batch_list@2

; 2224 : 
; 2225 :     return 0;

  000eb	33 c0		 xor	 eax, eax
  000ed	eb 03		 jmp	 SHORT $LN23@batch_list@2
$LN19@batch_list@2:

; 2211 :             return -1;

  000ef	83 c8 ff	 or	 eax, -1
$LN23@batch_list@2:
  000f2	48 8b 5c 24 28	 mov	 rbx, QWORD PTR [rsp+40]
  000f7	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 2226 : }

  000fc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00100	41 5c		 pop	 r12
  00102	5e		 pop	 rsi
  00103	5d		 pop	 rbp
  00104	c3		 ret	 0
batch_list_exact ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@BNMNDPHJ@?5while?5pickling?5an?5object?$AA@ ; `string'
EXTRN	PyObject_GetIter:PROC
EXTRN	_Py_CheckRecursiveCall:PROC
EXTRN	_Py_CheckRecursionLimit:DWORD
EXTRN	_PyThreadState_Current:QWORD
EXTRN	_PyParallel_GetThreadState:PROC
EXTRN	PyList_Type:BYTE
EXTRN	PyList_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_list DD imagerel save_list
	DD	imagerel save_list+19
	DD	imagerel $unwind$save_list
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$save_list DD imagerel save_list+19
	DD	imagerel save_list+439
	DD	imagerel $chain$0$save_list
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$save_list DD imagerel save_list+439
	DD	imagerel save_list+472
	DD	imagerel $chain$1$save_list
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$save_list DD imagerel save_list+472
	DD	imagerel save_list+598
	DD	imagerel $chain$2$save_list
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$save_list DD 020021H
	DD	093400H
	DD	imagerel save_list
	DD	imagerel save_list+19
	DD	imagerel $unwind$save_list
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$save_list DD 021H
	DD	imagerel save_list
	DD	imagerel save_list+19
	DD	imagerel $unwind$save_list
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$save_list DD 020521H
	DD	093405H
	DD	imagerel save_list
	DD	imagerel save_list+19
	DD	imagerel $unwind$save_list
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_list DD 060d01H
	DD	0a540dH
	DD	0c009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT ??_C@_0BK@BNMNDPHJ@?5while?5pickling?5an?5object?$AA@
CONST	SEGMENT
??_C@_0BK@BNMNDPHJ@?5while?5pickling?5an?5object?$AA@ DB ' while pickling'
	DB	' an object', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT save_list
_TEXT	SEGMENT
header$ = 64
self$ = 64
obj$ = 72
save_list PROC						; COMDAT

; 2230 : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2231 :     char header[3];
; 2232 :     Py_ssize_t len;
; 2233 :     int status = 0;

  0000d	33 f6		 xor	 esi, esi

; 2234 : 
; 2235 :     if (self->fast && !fast_save_enter(self, obj))

  0000f	41 83 cc ff	 or	 r12d, -1
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 8b ea	 mov	 rbp, rdx
  0001b	48 8b f9	 mov	 rdi, rcx
  0001e	39 b1 b0 00 00
	00		 cmp	 DWORD PTR [rcx+176], esi
  00024	74 0d		 je	 SHORT $LN22@save_list
  00026	e8 00 00 00 00	 call	 fast_save_enter
  0002b	85 c0		 test	 eax, eax
  0002d	0f 84 73 01 00
	00		 je	 $error$21898
$LN22@save_list:

; 2236 :         goto error;
; 2237 : 
; 2238 :     /* Create an empty list. */
; 2239 :     if (self->bin) {

  00033	39 b7 a4 00 00
	00		 cmp	 DWORD PTR [rdi+164], esi
  00039	74 0d		 je	 SHORT $LN21@save_list

; 2240 :         header[0] = EMPTY_LIST;

  0003b	c6 44 24 40 5d	 mov	 BYTE PTR header$[rsp], 93 ; 0000005dH

; 2241 :         len = 1;

  00040	41 b8 01 00 00
	00		 mov	 r8d, 1

; 2242 :     }
; 2243 :     else {

  00046	eb 0d		 jmp	 SHORT $LN20@save_list
$LN21@save_list:

; 2244 :         header[0] = MARK;

  00048	66 c7 44 24 40
	28 6c		 mov	 WORD PTR header$[rsp], 27688 ; 00006c28H

; 2245 :         header[1] = LIST;
; 2246 :         len = 2;

  0004f	41 b8 02 00 00
	00		 mov	 r8d, 2
$LN20@save_list:

; 2247 :     }
; 2248 : 
; 2249 :     if (_Pickler_Write(self, header, len) < 0)

  00055	48 8d 54 24 40	 lea	 rdx, QWORD PTR header$[rsp]
  0005a	48 8b cf	 mov	 rcx, rdi
  0005d	e8 00 00 00 00	 call	 _Pickler_Write
  00062	48 85 c0	 test	 rax, rax
  00065	0f 88 3b 01 00
	00		 js	 $error$21898

; 2250 :         goto error;
; 2251 : 
; 2252 :     /* Get list length, and bow out early if empty. */
; 2253 :     if ((len = PyList_Size(obj)) < 0)

  0006b	48 8b cd	 mov	 rcx, rbp
  0006e	e8 00 00 00 00	 call	 PyList_Size
  00073	48 8b d8	 mov	 rbx, rax
  00076	48 85 c0	 test	 rax, rax
  00079	0f 88 27 01 00
	00		 js	 $error$21898

; 2254 :         goto error;
; 2255 : 
; 2256 :     if (memo_put(self, obj) < 0)

  0007f	48 8b d5	 mov	 rdx, rbp
  00082	48 8b cf	 mov	 rcx, rdi
  00085	e8 00 00 00 00	 call	 memo_put
  0008a	85 c0		 test	 eax, eax
  0008c	0f 88 14 01 00
	00		 js	 $error$21898

; 2257 :         goto error;
; 2258 : 
; 2259 :     if (len != 0) {

  00092	48 85 db	 test	 rbx, rbx
  00095	0f 84 0e 01 00
	00		 je	 $LN9@save_list

; 2260 :         /* Materialize the list elements. */
; 2261 :         if (PyList_CheckExact(obj) && self->proto > 0) {

  0009b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyList_Type
  000a2	48 39 45 58	 cmp	 QWORD PTR [rbp+88], rax
  000a6	0f 85 ad 00 00
	00		 jne	 $LN15@save_list
  000ac	39 b7 a0 00 00
	00		 cmp	 DWORD PTR [rdi+160], esi
  000b2	0f 8e a1 00 00
	00		 jle	 $LN15@save_list

; 2262 :             if (Py_EnterRecursiveCall(" while pickling an object"))

  000b8	e8 00 00 00 00	 call	 _Py_PXCTX
  000bd	85 c0		 test	 eax, eax
  000bf	74 07		 je	 SHORT $LN25@save_list
  000c1	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  000c6	eb 07		 jmp	 SHORT $LN26@save_list
$LN25@save_list:
  000c8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN26@save_list:
  000cf	ff 40 18	 inc	 DWORD PTR [rax+24]
  000d2	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000d5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  000db	7e 14		 jle	 SHORT $LN14@save_list
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNMNDPHJ@?5while?5pickling?5an?5object?$AA@
  000e4	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  000e9	85 c0		 test	 eax, eax
  000eb	0f 85 b5 00 00
	00		 jne	 $error$21898
$LN14@save_list:

; 2263 :                 goto error;
; 2264 :             status = batch_list_exact(self, obj);

  000f1	48 8b d5	 mov	 rdx, rbp
  000f4	48 8b cf	 mov	 rcx, rdi
  000f7	e8 00 00 00 00	 call	 batch_list_exact
  000fc	8b f0		 mov	 esi, eax

; 2265 :             Py_LeaveRecursiveCall();

  000fe	e8 00 00 00 00	 call	 _Py_PXCTX
  00103	85 c0		 test	 eax, eax
  00105	74 0a		 je	 SHORT $LN27@save_list
  00107	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0010c	4c 8b d8	 mov	 r11, rax
  0010f	eb 07		 jmp	 SHORT $LN28@save_list
$LN27@save_list:
  00111	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _PyThreadState_Current
$LN28@save_list:
  00118	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  0011e	83 f8 64	 cmp	 eax, 100		; 00000064H
  00121	7e 05		 jle	 SHORT $LN29@save_list
  00123	83 c0 ce	 add	 eax, -50		; ffffffffffffffceH
  00126	eb 06		 jmp	 SHORT $LN30@save_list
$LN29@save_list:
  00128	c1 f8 02	 sar	 eax, 2
  0012b	8d 04 40	 lea	 eax, DWORD PTR [rax+rax*2]
$LN30@save_list:
  0012e	41 ff 4b 18	 dec	 DWORD PTR [r11+24]
  00132	41 39 43 18	 cmp	 DWORD PTR [r11+24], eax
  00136	7d 71		 jge	 SHORT $LN9@save_list
  00138	e8 00 00 00 00	 call	 _Py_PXCTX
  0013d	85 c0		 test	 eax, eax
  0013f	74 0b		 je	 SHORT $LN31@save_list
  00141	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00146	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0

; 2266 :         } else {

  0014a	eb 5d		 jmp	 SHORT $LN9@save_list
$LN31@save_list:

; 2265 :             Py_LeaveRecursiveCall();

  0014c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
  00153	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0

; 2266 :         } else {

  00157	eb 50		 jmp	 SHORT $LN9@save_list
$LN15@save_list:

; 2267 :             PyObject *iter = PyObject_GetIter(obj);

  00159	48 8b cd	 mov	 rcx, rbp
  0015c	e8 00 00 00 00	 call	 PyObject_GetIter
  00161	48 8b d8	 mov	 rbx, rax

; 2268 :             if (iter == NULL)

  00164	48 85 c0	 test	 rax, rax
  00167	74 3d		 je	 SHORT $error$21898

; 2269 :                 goto error;
; 2270 : 
; 2271 :             if (Py_EnterRecursiveCall(" while pickling an object")) {

  00169	e8 00 00 00 00	 call	 _Py_PXCTX
  0016e	85 c0		 test	 eax, eax
  00170	74 07		 je	 SHORT $LN33@save_list
  00172	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00177	eb 07		 jmp	 SHORT $LN34@save_list
$LN33@save_list:
  00179	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN34@save_list:
  00180	ff 40 18	 inc	 DWORD PTR [rax+24]
  00183	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00186	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  0018c	7e 4a		 jle	 SHORT $LN7@save_list
  0018e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNMNDPHJ@?5while?5pickling?5an?5object?$AA@
  00195	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  0019a	85 c0		 test	 eax, eax
  0019c	74 3a		 je	 SHORT $LN7@save_list

; 2272 :                 Py_DECREF(iter);

  0019e	48 8b cb	 mov	 rcx, rbx
  001a1	e8 00 00 00 00	 call	 _Py_DecRef
$error$21898:

; 2278 :         }
; 2279 :     }
; 2280 :     if (0) {
; 2281 :   error:
; 2282 :         status = -1;

  001a6	41 8b f4	 mov	 esi, r12d
$LN9@save_list:

; 2283 :     }
; 2284 : 
; 2285 :     if (self->fast && !fast_save_leave(self, obj))

  001a9	83 bf b0 00 00
	00 00		 cmp	 DWORD PTR [rdi+176], 0
  001b0	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  001b5	74 11		 je	 SHORT $LN41@save_list
  001b7	48 8b d5	 mov	 rdx, rbp
  001ba	48 8b cf	 mov	 rcx, rdi
  001bd	e8 00 00 00 00	 call	 fast_save_leave
  001c2	85 c0		 test	 eax, eax
  001c4	41 0f 44 f4	 cmove	 esi, r12d
$LN41@save_list:

; 2286 :         status = -1;
; 2287 : 
; 2288 :     return status;

  001c8	8b c6		 mov	 eax, esi

; 2289 : }

  001ca	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  001cf	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001d3	41 5c		 pop	 r12
  001d5	5f		 pop	 rdi
  001d6	5e		 pop	 rsi
  001d7	c3		 ret	 0
$LN7@save_list:

; 2273 :                 goto error;
; 2274 :             }
; 2275 :             status = batch_list(self, iter);

  001d8	48 8b d3	 mov	 rdx, rbx
  001db	48 8b cf	 mov	 rcx, rdi
  001de	e8 00 00 00 00	 call	 batch_list
  001e3	8b f0		 mov	 esi, eax

; 2276 :             Py_LeaveRecursiveCall();

  001e5	e8 00 00 00 00	 call	 _Py_PXCTX
  001ea	85 c0		 test	 eax, eax
  001ec	74 0a		 je	 SHORT $LN35@save_list
  001ee	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  001f3	4c 8b d8	 mov	 r11, rax
  001f6	eb 07		 jmp	 SHORT $LN36@save_list
$LN35@save_list:
  001f8	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _PyThreadState_Current
$LN36@save_list:
  001ff	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  00205	83 f8 64	 cmp	 eax, 100		; 00000064H
  00208	7e 05		 jle	 SHORT $LN37@save_list
  0020a	83 c0 ce	 add	 eax, -50		; ffffffffffffffceH
  0020d	eb 06		 jmp	 SHORT $LN38@save_list
$LN37@save_list:
  0020f	c1 f8 02	 sar	 eax, 2
  00212	8d 04 40	 lea	 eax, DWORD PTR [rax+rax*2]
$LN38@save_list:
  00215	41 ff 4b 18	 dec	 DWORD PTR [r11+24]
  00219	41 39 43 18	 cmp	 DWORD PTR [r11+24], eax
  0021d	7d 2a		 jge	 SHORT $LN5@save_list
  0021f	e8 00 00 00 00	 call	 _Py_PXCTX
  00224	85 c0		 test	 eax, eax
  00226	74 16		 je	 SHORT $LN39@save_list
  00228	e8 00 00 00 00	 call	 _PyParallel_GetThreadState

; 2277 :             Py_DECREF(iter);

  0022d	48 8b cb	 mov	 rcx, rbx
  00230	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
  00234	e8 00 00 00 00	 call	 _Py_DecRef
  00239	e9 6b ff ff ff	 jmp	 $LN9@save_list
$LN39@save_list:

; 2276 :             Py_LeaveRecursiveCall();

  0023e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
  00245	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN5@save_list:

; 2277 :             Py_DECREF(iter);

  00249	48 8b cb	 mov	 rcx, rbx
  0024c	e8 00 00 00 00	 call	 _Py_DecRef
  00251	e9 53 ff ff ff	 jmp	 $LN9@save_list
save_list ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DPBBCDAK@batch_dict?$AA@		; `string'
PUBLIC	??_C@_0CJ@PFBFCAOH@dict?5items?5iterator?5must?5return?5@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$batch_dict DD imagerel batch_dict
	DD	imagerel batch_dict+345
	DD	imagerel $unwind$batch_dict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$batch_dict DD imagerel batch_dict+345
	DD	imagerel batch_dict+1403
	DD	imagerel $chain$1$batch_dict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$batch_dict DD 040a21H
	DD	06640aH
	DD	0d5405H
	DD	imagerel batch_dict
	DD	imagerel batch_dict+345
	DD	imagerel $unwind$batch_dict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$batch_dict DD 050b01H
	DD	0d007620bH
	DD	07003c005H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_0L@DPBBCDAK@batch_dict?$AA@
CONST	SEGMENT
??_C@_0L@DPBBCDAK@batch_dict?$AA@ DB 'batch_dict', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PFBFCAOH@dict?5items?5iterator?5must?5return?5@
CONST	SEGMENT
??_C@_0CJ@PFBFCAOH@dict?5items?5iterator?5must?5return?5@ DB 'dict items '
	DB	'iterator must return 2-tuples', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT batch_dict
_TEXT	SEGMENT
setitem_op$ = 96
self$ = 96
iter$ = 104
mark_op$ = 112
setitems_op$ = 120
batch_dict PROC						; COMDAT

; 2304 : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2305 :     PyObject *obj = NULL;

  0000b	33 ff		 xor	 edi, edi
  0000d	4c 8b ea	 mov	 r13, rdx
  00010	4c 8b e1	 mov	 r12, rcx

; 2306 :     PyObject *firstitem = NULL;
; 2307 :     int i, n;
; 2308 : 
; 2309 :     const char mark_op = MARK;

  00013	c6 44 24 70 28	 mov	 BYTE PTR mark_op$[rsp], 40 ; 00000028H

; 2310 :     const char setitem_op = SETITEM;

  00018	c6 44 24 60 73	 mov	 BYTE PTR setitem_op$[rsp], 115 ; 00000073H

; 2311 :     const char setitems_op = SETITEMS;

  0001d	c6 44 24 78 75	 mov	 BYTE PTR setitems_op$[rsp], 117 ; 00000075H

; 2312 : 
; 2313 :     assert(iter != NULL);
; 2314 : 
; 2315 :     if (self->proto == 0) {

  00022	39 b9 a0 00 00
	00		 cmp	 DWORD PTR [rcx+160], edi
  00028	0f 85 2b 01 00
	00		 jne	 $LN138@batch_dict

; 2316 :         /* SETITEMS isn't available; do one at a time. */
; 2317 :         for (;;) {
; 2318 :             obj = PyIter_Next(iter);

  0002e	48 8b ca	 mov	 rcx, rdx
  00031	e8 00 00 00 00	 call	 PyIter_Next
  00036	48 8b d8	 mov	 rbx, rax

; 2319 :             if (obj == NULL) {

  00039	48 85 c0	 test	 rax, rax
  0003c	0f 84 e1 00 00
	00		 je	 $LN116@batch_dict
$LL54@batch_dict:

; 2321 :                     return -1;
; 2322 :                 break;
; 2323 :             }
; 2324 :             if (!PyTuple_Check(obj) || PyTuple_Size(obj) != 2) {

  00042	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00046	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00050	0f 84 e2 00 00
	00		 je	 $LN49@batch_dict
  00056	48 8b cb	 mov	 rcx, rbx
  00059	e8 00 00 00 00	 call	 PyTuple_Size
  0005e	48 83 f8 02	 cmp	 rax, 2
  00062	0f 85 d0 00 00
	00		 jne	 $LN49@batch_dict

; 2328 :             }
; 2329 :             i = save(self, PyTuple_GET_ITEM(obj, 0), 0);

  00068	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
  0006c	45 33 c0	 xor	 r8d, r8d
  0006f	49 8b cc	 mov	 rcx, r12
  00072	e8 00 00 00 00	 call	 save
  00077	8b f8		 mov	 edi, eax

; 2330 :             if (i >= 0)

  00079	85 c0		 test	 eax, eax
  0007b	78 11		 js	 SHORT $LN48@batch_dict

; 2331 :                 i = save(self, PyTuple_GET_ITEM(obj, 1), 0);

  0007d	48 8b 53 78	 mov	 rdx, QWORD PTR [rbx+120]
  00081	45 33 c0	 xor	 r8d, r8d
  00084	49 8b cc	 mov	 rcx, r12
  00087	e8 00 00 00 00	 call	 save
  0008c	8b f8		 mov	 edi, eax
$LN48@batch_dict:

; 2332 :             Py_DECREF(obj);

  0008e	e8 00 00 00 00	 call	 _Py_PXCTX
  00093	85 c0		 test	 eax, eax
  00095	75 5c		 jne	 SHORT $LN68@batch_dict
  00097	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0009b	a8 20		 test	 al, 32			; 00000020H
  0009d	75 4c		 jne	 SHORT $LN62@batch_dict
  0009f	84 c0		 test	 al, al
  000a1	78 48		 js	 SHORT $LN62@batch_dict
  000a3	a8 02		 test	 al, 2
  000a5	75 4c		 jne	 SHORT $LN68@batch_dict
  000a7	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000ab	75 46		 jne	 SHORT $LN68@batch_dict
  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000bb	4c 8b cb	 mov	 r9, rbx
  000be	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000c4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000cc	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d1	48 8b cb	 mov	 rcx, rbx
  000d4	85 c0		 test	 eax, eax
  000d6	74 07		 je	 SHORT $LN67@batch_dict
  000d8	e8 00 00 00 00	 call	 _Px_Dealloc
  000dd	eb 14		 jmp	 SHORT $LN68@batch_dict
$LN67@batch_dict:
  000df	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000e3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000e9	eb 08		 jmp	 SHORT $LN68@batch_dict
$LN62@batch_dict:
  000eb	48 8b cb	 mov	 rcx, rbx
  000ee	e8 00 00 00 00	 call	 Px_DecRef
$LN68@batch_dict:

; 2333 :             if (i < 0)

  000f3	85 ff		 test	 edi, edi
  000f5	78 54		 js	 SHORT $LN118@batch_dict

; 2334 :                 return -1;
; 2335 :             if (_Pickler_Write(self, &setitem_op, 1) < 0)

  000f7	48 8d 54 24 60	 lea	 rdx, QWORD PTR setitem_op$[rsp]
  000fc	41 b8 01 00 00
	00		 mov	 r8d, 1
  00102	49 8b cc	 mov	 rcx, r12
  00105	e8 00 00 00 00	 call	 _Pickler_Write
  0010a	48 85 c0	 test	 rax, rax
  0010d	78 3c		 js	 SHORT $LN118@batch_dict

; 2316 :         /* SETITEMS isn't available; do one at a time. */
; 2317 :         for (;;) {
; 2318 :             obj = PyIter_Next(iter);

  0010f	49 8b cd	 mov	 rcx, r13
  00112	e8 00 00 00 00	 call	 PyIter_Next
  00117	48 8b d8	 mov	 rbx, rax

; 2319 :             if (obj == NULL) {

  0011a	48 85 c0	 test	 rax, rax
  0011d	0f 85 1f ff ff
	ff		 jne	 $LL54@batch_dict
$LN116@batch_dict:

; 2320 :                 if (PyErr_Occurred())

  00123	e8 00 00 00 00	 call	 PyErr_Occurred
  00128	48 f7 d8	 neg	 rax
  0012b	1b c0		 sbb	 eax, eax

; 2422 : }

  0012d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00131	41 5d		 pop	 r13
  00133	41 5c		 pop	 r12
  00135	5f		 pop	 rdi
  00136	5b		 pop	 rbx
  00137	c3		 ret	 0
$LN49@batch_dict:

; 2325 :                 PyErr_SetString(PyExc_TypeError, "dict items "
; 2326 :                                 "iterator must return 2-tuples");

  00138	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0013f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@PFBFCAOH@dict?5items?5iterator?5must?5return?5@
  00146	e8 00 00 00 00	 call	 PyErr_SetString
$LN118@batch_dict:

; 2327 :                 return -1;

  0014b	83 c8 ff	 or	 eax, -1

; 2422 : }

  0014e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00152	41 5d		 pop	 r13
  00154	41 5c		 pop	 r12
  00156	5f		 pop	 rdi
  00157	5b		 pop	 rbx
  00158	c3		 ret	 0
$LN138@batch_dict:
  00159	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp
  0015e	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
$LL45@batch_dict:

; 2336 :                 return -1;
; 2337 :         }
; 2338 :         return 0;
; 2339 :     }
; 2340 : 
; 2341 :     /* proto > 0:  write in batches of BATCHSIZE. */
; 2342 :     do {
; 2343 :         /* Get first item */
; 2344 :         firstitem = PyIter_Next(iter);

  00163	49 8b cd	 mov	 rcx, r13
  00166	e8 00 00 00 00	 call	 PyIter_Next
  0016b	48 8b e8	 mov	 rbp, rax

; 2345 :         if (firstitem == NULL) {

  0016e	48 85 c0	 test	 rax, rax
  00171	0f 84 ca 03 00
	00		 je	 $LN124@batch_dict

; 2347 :                 goto error;
; 2348 : 
; 2349 :             /* nothing more to add */
; 2350 :             break;
; 2351 :         }
; 2352 :         if (!PyTuple_Check(firstitem) || PyTuple_Size(firstitem) != 2) {

  00177	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0017b	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00185	0f 84 d3 02 00
	00		 je	 $LN39@batch_dict
  0018b	48 8b cd	 mov	 rcx, rbp
  0018e	e8 00 00 00 00	 call	 PyTuple_Size
  00193	48 83 f8 02	 cmp	 rax, 2
  00197	0f 85 c1 02 00
	00		 jne	 $LN39@batch_dict

; 2355 :             goto error;
; 2356 :         }
; 2357 : 
; 2358 :         /* Try to get a second item */
; 2359 :         obj = PyIter_Next(iter);

  0019d	49 8b cd	 mov	 rcx, r13
  001a0	e8 00 00 00 00	 call	 PyIter_Next
  001a5	48 8b f8	 mov	 rdi, rax

; 2360 :         if (obj == NULL) {

  001a8	48 85 c0	 test	 rax, rax
  001ab	0f 84 22 02 00
	00		 je	 $LN126@batch_dict

; 2372 :             break;
; 2373 :         }
; 2374 : 
; 2375 :         /* More than one item to write */
; 2376 : 
; 2377 :         /* Pump out MARK, items, SETITEMS. */
; 2378 :         if (_Pickler_Write(self, &mark_op, 1) < 0)

  001b1	48 8d 54 24 70	 lea	 rdx, QWORD PTR mark_op$[rsp]
  001b6	41 b8 01 00 00
	00		 mov	 r8d, 1
  001bc	49 8b cc	 mov	 rcx, r12
  001bf	e8 00 00 00 00	 call	 _Pickler_Write
  001c4	48 85 c0	 test	 rax, rax
  001c7	0f 88 a4 02 00
	00		 js	 $error$21971

; 2379 :             goto error;
; 2380 : 
; 2381 :         if (save(self, PyTuple_GET_ITEM(firstitem, 0), 0) < 0)

  001cd	48 8b 55 70	 mov	 rdx, QWORD PTR [rbp+112]
  001d1	45 33 c0	 xor	 r8d, r8d
  001d4	49 8b cc	 mov	 rcx, r12
  001d7	e8 00 00 00 00	 call	 save
  001dc	85 c0		 test	 eax, eax
  001de	0f 88 8d 02 00
	00		 js	 $error$21971

; 2382 :             goto error;
; 2383 :         if (save(self, PyTuple_GET_ITEM(firstitem, 1), 0) < 0)

  001e4	48 8b 55 78	 mov	 rdx, QWORD PTR [rbp+120]
  001e8	45 33 c0	 xor	 r8d, r8d
  001eb	49 8b cc	 mov	 rcx, r12
  001ee	e8 00 00 00 00	 call	 save
  001f3	85 c0		 test	 eax, eax
  001f5	0f 88 76 02 00
	00		 js	 $error$21971

; 2384 :             goto error;
; 2385 :         Py_CLEAR(firstitem);

  001fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DPBBCDAK@batch_dict?$AA@
  00209	4c 8b cd	 mov	 r9, rbp
  0020c	41 b8 51 09 00
	00		 mov	 r8d, 2385		; 00000951H
  00212	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0021a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0021f	85 c0		 test	 eax, eax
  00221	75 6a		 jne	 SHORT $LN25@batch_dict
  00223	48 8b dd	 mov	 rbx, rbp
  00226	33 ed		 xor	 ebp, ebp
  00228	e8 00 00 00 00	 call	 _Py_PXCTX
  0022d	85 c0		 test	 eax, eax
  0022f	75 5c		 jne	 SHORT $LN25@batch_dict
  00231	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00235	a8 20		 test	 al, 32			; 00000020H
  00237	75 4c		 jne	 SHORT $LN73@batch_dict
  00239	84 c0		 test	 al, al
  0023b	78 48		 js	 SHORT $LN73@batch_dict
  0023d	a8 02		 test	 al, 2
  0023f	75 4c		 jne	 SHORT $LN25@batch_dict
  00241	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00245	75 46		 jne	 SHORT $LN25@batch_dict
  00247	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0024e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00255	4c 8b cb	 mov	 r9, rbx
  00258	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0025e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00266	e8 00 00 00 00	 call	 _PyParallel_Guard
  0026b	48 8b cb	 mov	 rcx, rbx
  0026e	85 c0		 test	 eax, eax
  00270	74 07		 je	 SHORT $LN78@batch_dict
  00272	e8 00 00 00 00	 call	 _Px_Dealloc
  00277	eb 14		 jmp	 SHORT $LN25@batch_dict
$LN78@batch_dict:
  00279	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0027d	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00283	eb 08		 jmp	 SHORT $LN25@batch_dict
$LN73@batch_dict:
  00285	48 8b cb	 mov	 rcx, rbx
  00288	e8 00 00 00 00	 call	 Px_DecRef
$LN25@batch_dict:

; 2386 :         n = 1;

  0028d	be 01 00 00 00	 mov	 esi, 1
$LL22@batch_dict:

; 2387 : 
; 2388 :         /* Fetch and save up to BATCHSIZE items */
; 2389 :         while (obj) {
; 2390 :             if (!PyTuple_Check(obj) || PyTuple_Size(obj) != 2) {

  00292	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00296	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  002a0	0f 84 b8 01 00
	00		 je	 $LN39@batch_dict
  002a6	48 8b cf	 mov	 rcx, rdi
  002a9	e8 00 00 00 00	 call	 PyTuple_Size
  002ae	48 83 f8 02	 cmp	 rax, 2
  002b2	0f 85 a6 01 00
	00		 jne	 $LN39@batch_dict

; 2391 :                 PyErr_SetString(PyExc_TypeError, "dict items "
; 2392 :                     "iterator must return 2-tuples");
; 2393 :                 goto error;
; 2394 :             }
; 2395 :             if (save(self, PyTuple_GET_ITEM(obj, 0), 0) < 0 ||
; 2396 :                 save(self, PyTuple_GET_ITEM(obj, 1), 0) < 0)

  002b8	48 8b 57 70	 mov	 rdx, QWORD PTR [rdi+112]
  002bc	45 33 c0	 xor	 r8d, r8d
  002bf	49 8b cc	 mov	 rcx, r12
  002c2	e8 00 00 00 00	 call	 save
  002c7	85 c0		 test	 eax, eax
  002c9	0f 88 a2 01 00
	00		 js	 $error$21971
  002cf	48 8b 57 78	 mov	 rdx, QWORD PTR [rdi+120]
  002d3	45 33 c0	 xor	 r8d, r8d
  002d6	49 8b cc	 mov	 rcx, r12
  002d9	e8 00 00 00 00	 call	 save
  002de	85 c0		 test	 eax, eax
  002e0	0f 88 8b 01 00
	00		 js	 $error$21971

; 2397 :                 goto error;
; 2398 :             Py_CLEAR(obj);

  002e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  002ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DPBBCDAK@batch_dict?$AA@
  002f4	4c 8b cf	 mov	 r9, rdi
  002f7	41 b8 5e 09 00
	00		 mov	 r8d, 2398		; 0000095eH
  002fd	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00305	e8 00 00 00 00	 call	 _PyParallel_Guard
  0030a	85 c0		 test	 eax, eax
  0030c	75 6a		 jne	 SHORT $LN15@batch_dict
  0030e	48 8b df	 mov	 rbx, rdi
  00311	33 ff		 xor	 edi, edi
  00313	e8 00 00 00 00	 call	 _Py_PXCTX
  00318	85 c0		 test	 eax, eax
  0031a	75 5c		 jne	 SHORT $LN15@batch_dict
  0031c	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00320	a8 20		 test	 al, 32			; 00000020H
  00322	75 4c		 jne	 SHORT $LN84@batch_dict
  00324	84 c0		 test	 al, al
  00326	78 48		 js	 SHORT $LN84@batch_dict
  00328	a8 02		 test	 al, 2
  0032a	75 4c		 jne	 SHORT $LN15@batch_dict
  0032c	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00330	75 46		 jne	 SHORT $LN15@batch_dict
  00332	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00339	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00340	4c 8b cb	 mov	 r9, rbx
  00343	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00349	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00351	e8 00 00 00 00	 call	 _PyParallel_Guard
  00356	48 8b cb	 mov	 rcx, rbx
  00359	85 c0		 test	 eax, eax
  0035b	74 07		 je	 SHORT $LN89@batch_dict
  0035d	e8 00 00 00 00	 call	 _Px_Dealloc
  00362	eb 14		 jmp	 SHORT $LN15@batch_dict
$LN89@batch_dict:
  00364	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00368	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0036e	eb 08		 jmp	 SHORT $LN15@batch_dict
$LN84@batch_dict:
  00370	48 8b cb	 mov	 rcx, rbx
  00373	e8 00 00 00 00	 call	 Px_DecRef
$LN15@batch_dict:

; 2399 :             n += 1;

  00378	ff c6		 inc	 esi

; 2400 : 
; 2401 :             if (n == BATCHSIZE)

  0037a	81 fe e8 03 00
	00		 cmp	 esi, 1000		; 000003e8H
  00380	74 22		 je	 SHORT $LN10@batch_dict

; 2402 :                 break;
; 2403 : 
; 2404 :             obj = PyIter_Next(iter);

  00382	49 8b cd	 mov	 rcx, r13
  00385	e8 00 00 00 00	 call	 PyIter_Next
  0038a	48 8b f8	 mov	 rdi, rax

; 2405 :             if (obj == NULL) {

  0038d	48 85 c0	 test	 rax, rax
  00390	0f 85 fc fe ff
	ff		 jne	 $LL22@batch_dict

; 2406 :                 if (PyErr_Occurred())

  00396	e8 00 00 00 00	 call	 PyErr_Occurred
  0039b	48 85 c0	 test	 rax, rax
  0039e	0f 85 cd 00 00
	00		 jne	 $error$21971
$LN10@batch_dict:

; 2407 :                     goto error;
; 2408 :                 break;
; 2409 :             }
; 2410 :         }
; 2411 : 
; 2412 :         if (_Pickler_Write(self, &setitems_op, 1) < 0)

  003a4	48 8d 54 24 78	 lea	 rdx, QWORD PTR setitems_op$[rsp]
  003a9	41 b8 01 00 00
	00		 mov	 r8d, 1
  003af	49 8b cc	 mov	 rcx, r12
  003b2	e8 00 00 00 00	 call	 _Pickler_Write
  003b7	48 85 c0	 test	 rax, rax
  003ba	0f 88 b1 00 00
	00		 js	 $error$21971

; 2413 :             goto error;
; 2414 : 
; 2415 :     } while (n == BATCHSIZE);

  003c0	81 fe e8 03 00
	00		 cmp	 esi, 1000		; 000003e8H
  003c6	0f 84 97 fd ff
	ff		 je	 $LL45@batch_dict

; 2416 :     return 0;

  003cc	33 c0		 xor	 eax, eax
  003ce	e9 93 01 00 00	 jmp	 $LN141@batch_dict
$LN126@batch_dict:

; 2361 :             if (PyErr_Occurred())

  003d3	e8 00 00 00 00	 call	 PyErr_Occurred
  003d8	48 85 c0	 test	 rax, rax
  003db	0f 85 90 00 00
	00		 jne	 $error$21971

; 2362 :                 goto error;
; 2363 : 
; 2364 :             /* Only one item to write */
; 2365 :             if (save(self, PyTuple_GET_ITEM(firstitem, 0), 0) < 0)

  003e1	48 8b 55 70	 mov	 rdx, QWORD PTR [rbp+112]
  003e5	45 33 c0	 xor	 r8d, r8d
  003e8	49 8b cc	 mov	 rcx, r12
  003eb	e8 00 00 00 00	 call	 save
  003f0	85 c0		 test	 eax, eax
  003f2	0f 88 79 00 00
	00		 js	 $error$21971

; 2366 :                 goto error;
; 2367 :             if (save(self, PyTuple_GET_ITEM(firstitem, 1), 0) < 0)

  003f8	48 8b 55 78	 mov	 rdx, QWORD PTR [rbp+120]
  003fc	45 33 c0	 xor	 r8d, r8d
  003ff	49 8b cc	 mov	 rcx, r12
  00402	e8 00 00 00 00	 call	 save
  00407	85 c0		 test	 eax, eax
  00409	78 66		 js	 SHORT $error$21971

; 2368 :                 goto error;
; 2369 :             if (_Pickler_Write(self, &setitem_op, 1) < 0)

  0040b	48 8d 54 24 60	 lea	 rdx, QWORD PTR setitem_op$[rsp]
  00410	41 b8 01 00 00
	00		 mov	 r8d, 1
  00416	49 8b cc	 mov	 rcx, r12
  00419	e8 00 00 00 00	 call	 _Pickler_Write
  0041e	48 85 c0	 test	 rax, rax
  00421	78 4e		 js	 SHORT $error$21971

; 2370 :                 goto error;
; 2371 :             Py_CLEAR(firstitem);

  00423	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0042a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DPBBCDAK@batch_dict?$AA@
  00431	4c 8b cd	 mov	 r9, rbp
  00434	41 b8 43 09 00
	00		 mov	 r8d, 2371		; 00000943H
  0043a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00442	e8 00 00 00 00	 call	 _PyParallel_Guard
  00447	85 c0		 test	 eax, eax
  00449	0f 85 fc 00 00
	00		 jne	 $LN43@batch_dict
  0044f	48 8b cd	 mov	 rcx, rbp
  00452	e8 00 00 00 00	 call	 _Py_DecRef

; 2416 :     return 0;

  00457	33 c0		 xor	 eax, eax
  00459	e9 08 01 00 00	 jmp	 $LN141@batch_dict
$LN39@batch_dict:

; 2353 :             PyErr_SetString(PyExc_TypeError, "dict items "
; 2354 :                                 "iterator must return 2-tuples");

  0045e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00465	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@PFBFCAOH@dict?5items?5iterator?5must?5return?5@
  0046c	e8 00 00 00 00	 call	 PyErr_SetString
$error$21971:

; 2417 : 
; 2418 :   error:
; 2419 :     Py_XDECREF(firstitem);

  00471	48 85 ed	 test	 rbp, rbp
  00474	74 57		 je	 SHORT $LN7@batch_dict
  00476	e8 00 00 00 00	 call	 _Py_PXCTX
  0047b	85 c0		 test	 eax, eax
  0047d	75 4e		 jne	 SHORT $LN7@batch_dict
  0047f	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  00483	a8 20		 test	 al, 32			; 00000020H
  00485	0f 85 ac 00 00
	00		 jne	 $LN95@batch_dict
  0048b	84 c0		 test	 al, al
  0048d	0f 88 a4 00 00
	00		 js	 $LN95@batch_dict
  00493	a8 02		 test	 al, 2
  00495	75 36		 jne	 SHORT $LN7@batch_dict
  00497	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  0049b	75 30		 jne	 SHORT $LN7@batch_dict
  0049d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  004a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  004ab	4c 8b cd	 mov	 r9, rbp
  004ae	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  004b4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004bc	e8 00 00 00 00	 call	 _PyParallel_Guard
  004c1	48 8b cd	 mov	 rcx, rbp
  004c4	85 c0		 test	 eax, eax
  004c6	74 63		 je	 SHORT $LN100@batch_dict
  004c8	e8 00 00 00 00	 call	 _Px_Dealloc
$LN7@batch_dict:

; 2420 :     Py_XDECREF(obj);

  004cd	48 85 ff	 test	 rdi, rdi
  004d0	0f 84 8d 00 00
	00		 je	 $LN3@batch_dict
  004d6	e8 00 00 00 00	 call	 _Py_PXCTX
  004db	85 c0		 test	 eax, eax
  004dd	0f 85 80 00 00
	00		 jne	 $LN3@batch_dict
  004e3	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  004e7	a8 20		 test	 al, 32			; 00000020H
  004e9	75 70		 jne	 SHORT $LN106@batch_dict
  004eb	84 c0		 test	 al, al
  004ed	78 6c		 js	 SHORT $LN106@batch_dict
  004ef	a8 02		 test	 al, 2
  004f1	75 70		 jne	 SHORT $LN3@batch_dict
  004f3	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  004f7	75 6a		 jne	 SHORT $LN3@batch_dict
  004f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00500	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00507	4c 8b cf	 mov	 r9, rdi
  0050a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00510	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00518	e8 00 00 00 00	 call	 _PyParallel_Guard
  0051d	48 8b cf	 mov	 rcx, rdi
  00520	85 c0		 test	 eax, eax
  00522	74 2b		 je	 SHORT $LN111@batch_dict
  00524	e8 00 00 00 00	 call	 _Px_Dealloc
  00529	eb 38		 jmp	 SHORT $LN3@batch_dict

; 2417 : 
; 2418 :   error:
; 2419 :     Py_XDECREF(firstitem);

$LN100@batch_dict:
  0052b	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  0052f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00535	eb 96		 jmp	 SHORT $LN7@batch_dict
$LN95@batch_dict:
  00537	48 8b cd	 mov	 rcx, rbp
  0053a	e8 00 00 00 00	 call	 Px_DecRef
  0053f	eb 8c		 jmp	 SHORT $LN7@batch_dict
$LN124@batch_dict:

; 2346 :             if (PyErr_Occurred())

  00541	e8 00 00 00 00	 call	 PyErr_Occurred
  00546	48 85 c0	 test	 rax, rax
  00549	75 82		 jne	 SHORT $LN7@batch_dict
$LN43@batch_dict:

; 2416 :     return 0;

  0054b	33 c0		 xor	 eax, eax
  0054d	eb 17		 jmp	 SHORT $LN141@batch_dict

; 2420 :     Py_XDECREF(obj);

$LN111@batch_dict:
  0054f	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00553	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00559	eb 08		 jmp	 SHORT $LN3@batch_dict
$LN106@batch_dict:
  0055b	48 8b cf	 mov	 rcx, rdi
  0055e	e8 00 00 00 00	 call	 Px_DecRef
$LN3@batch_dict:

; 2421 :     return -1;

  00563	83 c8 ff	 or	 eax, -1
$LN141@batch_dict:
  00566	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  0056b	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 2422 : }

  00570	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00574	41 5d		 pop	 r13
  00576	41 5c		 pop	 r12
  00578	5f		 pop	 rdi
  00579	5b		 pop	 rbx
  0057a	c3		 ret	 0
batch_dict ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@KOANJCHL@dictionary?5changed?5size?5during?5i@ ; `string'
EXTRN	PyExc_RuntimeError:QWORD
EXTRN	PyDict_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$batch_dict_exact DD imagerel batch_dict_exact
	DD	imagerel batch_dict_exact+431
	DD	imagerel $unwind$batch_dict_exact
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$batch_dict_exact DD 08c001H
	DD	0c34c0H
	DD	0d540fH
	DD	0c00b720fH
	DD	060087009H
xdata	ENDS
;	COMDAT ??_C@_0CJ@KOANJCHL@dictionary?5changed?5size?5during?5i@
CONST	SEGMENT
??_C@_0CJ@KOANJCHL@dictionary?5changed?5size?5during?5i@ DB 'dictionary c'
	DB	'hanged size during iteration', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT batch_dict_exact
_TEXT	SEGMENT
setitems_op$ = 32
value$ = 40
key$ = 48
ppos$ = 56
self$ = 96
obj$ = 104
setitem_op$ = 112
mark_op$ = 120
batch_dict_exact PROC					; COMDAT

; 2435 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 2436 :     PyObject *key = NULL, *value = NULL;

  0000f	33 ed		 xor	 ebp, ebp
  00011	48 8b f9	 mov	 rdi, rcx

; 2437 :     int i;
; 2438 :     Py_ssize_t dict_size, ppos = 0;
; 2439 : 
; 2440 :     const char mark_op = MARK;
; 2441 :     const char setitem_op = SETITEM;
; 2442 :     const char setitems_op = SETITEMS;
; 2443 : 
; 2444 :     assert(obj != NULL);
; 2445 :     assert(self->proto > 0);
; 2446 : 
; 2447 :     dict_size = PyDict_Size(obj);

  00014	48 8b ca	 mov	 rcx, rdx
  00017	48 8b f2	 mov	 rsi, rdx
  0001a	c6 40 20 28	 mov	 BYTE PTR [rax+32], 40	; 00000028H
  0001e	c6 40 18 73	 mov	 BYTE PTR [rax+24], 115	; 00000073H
  00022	48 89 68 d8	 mov	 QWORD PTR [rax-40], rbp
  00026	48 89 68 d0	 mov	 QWORD PTR [rax-48], rbp
  0002a	48 89 68 e0	 mov	 QWORD PTR [rax-32], rbp
  0002e	c6 40 c8 75	 mov	 BYTE PTR [rax-56], 117	; 00000075H
  00032	e8 00 00 00 00	 call	 PyDict_Size
  00037	4c 8b e0	 mov	 r12, rax

; 2448 : 
; 2449 :     /* Special-case len(d) == 1 to save space. */
; 2450 :     if (dict_size == 1) {

  0003a	48 83 f8 01	 cmp	 rax, 1
  0003e	75 7b		 jne	 SHORT $LN29@batch_dict@2

; 2451 :         PyDict_Next(obj, &ppos, &key, &value);

  00040	4c 8d 4c 24 28	 lea	 r9, QWORD PTR value$[rsp]
  00045	4c 8d 44 24 30	 lea	 r8, QWORD PTR key$[rsp]
  0004a	48 8d 54 24 38	 lea	 rdx, QWORD PTR ppos$[rsp]
  0004f	48 8b ce	 mov	 rcx, rsi
  00052	e8 00 00 00 00	 call	 PyDict_Next

; 2452 :         if (save(self, key, 0) < 0)

  00057	48 8b 54 24 30	 mov	 rdx, QWORD PTR key$[rsp]
  0005c	45 33 c0	 xor	 r8d, r8d
  0005f	48 8b cf	 mov	 rcx, rdi
  00062	e8 00 00 00 00	 call	 save
  00067	85 c0		 test	 eax, eax
  00069	79 11		 jns	 SHORT $LN14@batch_dict@2
$LN32@batch_dict@2:

; 2453 :             return -1;

  0006b	83 c8 ff	 or	 eax, -1

; 2485 : }

  0006e	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00073	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00077	41 5c		 pop	 r12
  00079	5f		 pop	 rdi
  0007a	5e		 pop	 rsi
  0007b	c3		 ret	 0
$LN14@batch_dict@2:

; 2454 :         if (save(self, value, 0) < 0)

  0007c	48 8b 54 24 28	 mov	 rdx, QWORD PTR value$[rsp]
  00081	45 33 c0	 xor	 r8d, r8d
  00084	48 8b cf	 mov	 rcx, rdi
  00087	e8 00 00 00 00	 call	 save
  0008c	85 c0		 test	 eax, eax

; 2455 :             return -1;

  0008e	78 db		 js	 SHORT $LN32@batch_dict@2

; 2456 :         if (_Pickler_Write(self, &setitem_op, 1) < 0)

  00090	48 8d 54 24 70	 lea	 rdx, QWORD PTR setitem_op$[rsp]
  00095	41 b8 01 00 00
	00		 mov	 r8d, 1
  0009b	48 8b cf	 mov	 rcx, rdi
  0009e	e8 00 00 00 00	 call	 _Pickler_Write
  000a3	48 85 c0	 test	 rax, rax
  000a6	40 0f 99 c5	 setns	 bpl
  000aa	8d 45 ff	 lea	 eax, DWORD PTR [rbp-1]

; 2485 : }

  000ad	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  000b2	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000b6	41 5c		 pop	 r12
  000b8	5f		 pop	 rdi
  000b9	5e		 pop	 rsi
  000ba	c3		 ret	 0
$LN29@batch_dict@2:
  000bb	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
$LL11@batch_dict@2:

; 2457 :             return -1;
; 2458 :         return 0;
; 2459 :     }
; 2460 : 
; 2461 :     /* Write in batches of BATCHSIZE. */
; 2462 :     do {
; 2463 :         i = 0;
; 2464 :         if (_Pickler_Write(self, &mark_op, 1) < 0)

  000c0	48 8d 54 24 78	 lea	 rdx, QWORD PTR mark_op$[rsp]
  000c5	41 b8 01 00 00
	00		 mov	 r8d, 1
  000cb	48 8b cf	 mov	 rcx, rdi
  000ce	8b dd		 mov	 ebx, ebp
  000d0	e8 00 00 00 00	 call	 _Pickler_Write
  000d5	48 85 c0	 test	 rax, rax
  000d8	0f 88 bb 00 00
	00		 js	 $LN23@batch_dict@2

; 2466 :         while (PyDict_Next(obj, &ppos, &key, &value)) {

  000de	4c 8d 4c 24 28	 lea	 r9, QWORD PTR value$[rsp]
  000e3	4c 8d 44 24 30	 lea	 r8, QWORD PTR key$[rsp]
  000e8	48 8d 54 24 38	 lea	 rdx, QWORD PTR ppos$[rsp]
  000ed	48 8b ce	 mov	 rcx, rsi
  000f0	e8 00 00 00 00	 call	 PyDict_Next
  000f5	85 c0		 test	 eax, eax
  000f7	74 58		 je	 SHORT $LN22@batch_dict@2
  000f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@batch_dict@2:

; 2467 :             if (save(self, key, 0) < 0)

  00100	48 8b 54 24 30	 mov	 rdx, QWORD PTR key$[rsp]
  00105	45 33 c0	 xor	 r8d, r8d
  00108	48 8b cf	 mov	 rcx, rdi
  0010b	e8 00 00 00 00	 call	 save
  00110	85 c0		 test	 eax, eax
  00112	0f 88 81 00 00
	00		 js	 $LN23@batch_dict@2

; 2468 :                 return -1;
; 2469 :             if (save(self, value, 0) < 0)

  00118	48 8b 54 24 28	 mov	 rdx, QWORD PTR value$[rsp]
  0011d	45 33 c0	 xor	 r8d, r8d
  00120	48 8b cf	 mov	 rcx, rdi
  00123	e8 00 00 00 00	 call	 save
  00128	85 c0		 test	 eax, eax
  0012a	78 6d		 js	 SHORT $LN23@batch_dict@2

; 2470 :                 return -1;
; 2471 :             if (++i == BATCHSIZE)

  0012c	ff c3		 inc	 ebx
  0012e	81 fb e8 03 00
	00		 cmp	 ebx, 1000		; 000003e8H
  00134	74 1b		 je	 SHORT $LN22@batch_dict@2

; 2466 :         while (PyDict_Next(obj, &ppos, &key, &value)) {

  00136	4c 8d 4c 24 28	 lea	 r9, QWORD PTR value$[rsp]
  0013b	4c 8d 44 24 30	 lea	 r8, QWORD PTR key$[rsp]
  00140	48 8d 54 24 38	 lea	 rdx, QWORD PTR ppos$[rsp]
  00145	48 8b ce	 mov	 rcx, rsi
  00148	e8 00 00 00 00	 call	 PyDict_Next
  0014d	85 c0		 test	 eax, eax
  0014f	75 af		 jne	 SHORT $LL7@batch_dict@2
$LN22@batch_dict@2:

; 2472 :                 break;
; 2473 :         }
; 2474 :         if (_Pickler_Write(self, &setitems_op, 1) < 0)

  00151	48 8d 54 24 20	 lea	 rdx, QWORD PTR setitems_op$[rsp]
  00156	41 b8 01 00 00
	00		 mov	 r8d, 1
  0015c	48 8b cf	 mov	 rcx, rdi
  0015f	e8 00 00 00 00	 call	 _Pickler_Write
  00164	48 85 c0	 test	 rax, rax
  00167	78 30		 js	 SHORT $LN23@batch_dict@2

; 2475 :             return -1;
; 2476 :         if (PyDict_Size(obj) != dict_size) {

  00169	48 8b ce	 mov	 rcx, rsi
  0016c	e8 00 00 00 00	 call	 PyDict_Size
  00171	49 3b c4	 cmp	 rax, r12
  00174	75 10		 jne	 SHORT $LN26@batch_dict@2

; 2480 :             return -1;
; 2481 :         }
; 2482 : 
; 2483 :     } while (i == BATCHSIZE);

  00176	81 fb e8 03 00
	00		 cmp	 ebx, 1000		; 000003e8H
  0017c	0f 84 3e ff ff
	ff		 je	 $LL11@batch_dict@2

; 2484 :     return 0;

  00182	33 c0		 xor	 eax, eax
  00184	eb 16		 jmp	 SHORT $LN31@batch_dict@2
$LN26@batch_dict@2:

; 2477 :             PyErr_Format(
; 2478 :                 PyExc_RuntimeError,
; 2479 :                 "dictionary changed size during iteration");

  00186	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0018d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@KOANJCHL@dictionary?5changed?5size?5during?5i@
  00194	e8 00 00 00 00	 call	 PyErr_Format
$LN23@batch_dict@2:

; 2465 :             return -1;

  00199	83 c8 ff	 or	 eax, -1
$LN31@batch_dict@2:
  0019c	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 2485 : }

  001a1	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  001a6	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001aa	41 5c		 pop	 r12
  001ac	5f		 pop	 rdi
  001ad	5e		 pop	 rsi
  001ae	c3		 ret	 0
batch_dict_exact ENDP
_TEXT	ENDS
PUBLIC	??_C@_02HCKGKOFO@?$CI?$CJ?$AA@			; `string'
EXTRN	_PyObject_CallMethodId:PROC
EXTRN	PyDict_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_dict DD imagerel save_dict
	DD	imagerel save_dict+20
	DD	imagerel $unwind$save_dict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$save_dict DD imagerel save_dict+20
	DD	imagerel save_dict+523
	DD	imagerel $chain$1$save_dict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$save_dict DD imagerel save_dict+523
	DD	imagerel save_dict+557
	DD	imagerel $chain$2$save_dict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$save_dict DD imagerel save_dict+557
	DD	imagerel save_dict+683
	DD	imagerel $chain$3$save_dict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$save_dict DD 040021H
	DD	0a5400H
	DD	093400H
	DD	imagerel save_dict
	DD	imagerel save_dict+20
	DD	imagerel $unwind$save_dict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$save_dict DD 021H
	DD	imagerel save_dict
	DD	imagerel save_dict+20
	DD	imagerel $unwind$save_dict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$save_dict DD 040a21H
	DD	0a540aH
	DD	093405H
	DD	imagerel save_dict
	DD	imagerel save_dict+20
	DD	imagerel $unwind$save_dict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_dict DD 060e01H
	DD	0b640eH
	DD	0d00a320eH
	DD	07006c008H
xdata	ENDS
;	COMDAT ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_02HCKGKOFO@?$CI?$CJ?$AA@ DB '()', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT save_dict
_TEXT	SEGMENT
header$ = 64
self$ = 64
obj$ = 72
save_dict PROC						; COMDAT

; 2489 : {

  00000	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00005	57		 push	 rdi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2490 :     PyObject *items, *iter;
; 2491 :     char header[3];
; 2492 :     Py_ssize_t len;
; 2493 :     int status = 0;

  0000e	33 f6		 xor	 esi, esi

; 2494 : 
; 2495 :     if (self->fast && !fast_save_enter(self, obj))

  00010	41 83 cd ff	 or	 r13d, -1
  00014	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00019	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0001e	4c 8b e2	 mov	 r12, rdx
  00021	48 8b f9	 mov	 rdi, rcx
  00024	39 b1 b0 00 00
	00		 cmp	 DWORD PTR [rcx+176], esi
  0002a	74 0d		 je	 SHORT $LN24@save_dict
  0002c	e8 00 00 00 00	 call	 fast_save_enter
  00031	85 c0		 test	 eax, eax
  00033	0f 84 bc 01 00
	00		 je	 $error$22085
$LN24@save_dict:

; 2496 :         goto error;
; 2497 : 
; 2498 :     /* Create an empty dict. */
; 2499 :     if (self->bin) {

  00039	39 b7 a4 00 00
	00		 cmp	 DWORD PTR [rdi+164], esi
  0003f	74 0d		 je	 SHORT $LN23@save_dict

; 2500 :         header[0] = EMPTY_DICT;

  00041	c6 44 24 40 7d	 mov	 BYTE PTR header$[rsp], 125 ; 0000007dH

; 2501 :         len = 1;

  00046	41 b8 01 00 00
	00		 mov	 r8d, 1

; 2502 :     }
; 2503 :     else {

  0004c	eb 0d		 jmp	 SHORT $LN22@save_dict
$LN23@save_dict:

; 2504 :         header[0] = MARK;

  0004e	66 c7 44 24 40
	28 64		 mov	 WORD PTR header$[rsp], 25640 ; 00006428H

; 2505 :         header[1] = DICT;
; 2506 :         len = 2;

  00055	41 b8 02 00 00
	00		 mov	 r8d, 2
$LN22@save_dict:

; 2507 :     }
; 2508 : 
; 2509 :     if (_Pickler_Write(self, header, len) < 0)

  0005b	48 8d 54 24 40	 lea	 rdx, QWORD PTR header$[rsp]
  00060	48 8b cf	 mov	 rcx, rdi
  00063	e8 00 00 00 00	 call	 _Pickler_Write
  00068	48 85 c0	 test	 rax, rax
  0006b	0f 88 84 01 00
	00		 js	 $error$22085

; 2510 :         goto error;
; 2511 : 
; 2512 :     /* Get dict size, and bow out early if empty. */
; 2513 :     if ((len = PyDict_Size(obj)) < 0)

  00071	49 8b cc	 mov	 rcx, r12
  00074	e8 00 00 00 00	 call	 PyDict_Size
  00079	48 8b d8	 mov	 rbx, rax
  0007c	48 85 c0	 test	 rax, rax
  0007f	0f 88 70 01 00
	00		 js	 $error$22085

; 2514 :         goto error;
; 2515 : 
; 2516 :     if (memo_put(self, obj) < 0)

  00085	49 8b d4	 mov	 rdx, r12
  00088	48 8b cf	 mov	 rcx, rdi
  0008b	e8 00 00 00 00	 call	 memo_put
  00090	85 c0		 test	 eax, eax
  00092	0f 88 5d 01 00
	00		 js	 $error$22085

; 2517 :         goto error;
; 2518 : 
; 2519 :     if (len != 0) {

  00098	48 85 db	 test	 rbx, rbx
  0009b	0f 84 57 01 00
	00		 je	 $LN10@save_dict

; 2520 :         /* Save the dict items. */
; 2521 :         if (PyDict_CheckExact(obj) && self->proto > 0) {

  000a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  000a8	49 39 44 24 58	 cmp	 QWORD PTR [r12+88], rax
  000ad	74 0b		 je	 SHORT $LN16@save_dict
  000af	49 39 44 24 38	 cmp	 QWORD PTR [r12+56], rax
  000b4	0f 85 b7 00 00
	00		 jne	 $LN17@save_dict
$LN16@save_dict:
  000ba	39 b7 a0 00 00
	00		 cmp	 DWORD PTR [rdi+160], esi
  000c0	0f 8e ab 00 00
	00		 jle	 $LN17@save_dict

; 2522 :             /* We can take certain shortcuts if we know this is a dict and
; 2523 :                not a dict subclass. */
; 2524 :             if (Py_EnterRecursiveCall(" while pickling an object"))

  000c6	e8 00 00 00 00	 call	 _Py_PXCTX
  000cb	85 c0		 test	 eax, eax
  000cd	74 07		 je	 SHORT $LN27@save_dict
  000cf	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  000d4	eb 07		 jmp	 SHORT $LN28@save_dict
$LN27@save_dict:
  000d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN28@save_dict:
  000dd	ff 40 18	 inc	 DWORD PTR [rax+24]
  000e0	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000e3	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  000e9	7e 14		 jle	 SHORT $LN15@save_dict
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNMNDPHJ@?5while?5pickling?5an?5object?$AA@
  000f2	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  000f7	85 c0		 test	 eax, eax
  000f9	0f 85 f6 00 00
	00		 jne	 $error$22085
$LN15@save_dict:

; 2525 :                 goto error;
; 2526 :             status = batch_dict_exact(self, obj);

  000ff	49 8b d4	 mov	 rdx, r12
  00102	48 8b cf	 mov	 rcx, rdi
  00105	e8 00 00 00 00	 call	 batch_dict_exact
  0010a	8b f0		 mov	 esi, eax

; 2527 :             Py_LeaveRecursiveCall();

  0010c	e8 00 00 00 00	 call	 _Py_PXCTX
  00111	85 c0		 test	 eax, eax
  00113	74 0a		 je	 SHORT $LN29@save_dict
  00115	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0011a	4c 8b d8	 mov	 r11, rax
  0011d	eb 07		 jmp	 SHORT $LN30@save_dict
$LN29@save_dict:
  0011f	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _PyThreadState_Current
$LN30@save_dict:
  00126	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  0012c	83 f8 64	 cmp	 eax, 100		; 00000064H
  0012f	7e 05		 jle	 SHORT $LN31@save_dict
  00131	83 c0 ce	 add	 eax, -50		; ffffffffffffffceH
  00134	eb 06		 jmp	 SHORT $LN32@save_dict
$LN31@save_dict:
  00136	c1 f8 02	 sar	 eax, 2
  00139	8d 04 40	 lea	 eax, DWORD PTR [rax+rax*2]
$LN32@save_dict:
  0013c	41 ff 4b 18	 dec	 DWORD PTR [r11+24]
  00140	41 39 43 18	 cmp	 DWORD PTR [r11+24], eax
  00144	0f 8d ae 00 00
	00		 jge	 $LN10@save_dict
  0014a	e8 00 00 00 00	 call	 _Py_PXCTX
  0014f	85 c0		 test	 eax, eax
  00151	74 0e		 je	 SHORT $LN33@save_dict
  00153	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00158	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0

; 2528 :         } else {

  0015c	e9 97 00 00 00	 jmp	 $LN10@save_dict
$LN33@save_dict:

; 2527 :             Py_LeaveRecursiveCall();

  00161	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
  00168	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0

; 2528 :         } else {

  0016c	e9 87 00 00 00	 jmp	 $LN10@save_dict
$LN17@save_dict:

; 2529 :             _Py_IDENTIFIER(items);
; 2530 : 
; 2531 :             items = _PyObject_CallMethodId(obj, &PyId_items, "()");

  00171	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00177	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00180	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_items@?7??save_dict@@9@9
  00185	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00189	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00190	49 8b cc	 mov	 rcx, r12
  00193	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00198	48 8b d8	 mov	 rbx, rax

; 2532 :             if (items == NULL)

  0019b	48 85 c0	 test	 rax, rax
  0019e	74 55		 je	 SHORT $error$22085

; 2533 :                 goto error;
; 2534 :             iter = PyObject_GetIter(items);

  001a0	48 8b c8	 mov	 rcx, rax
  001a3	e8 00 00 00 00	 call	 PyObject_GetIter

; 2535 :             Py_DECREF(items);

  001a8	48 8b cb	 mov	 rcx, rbx
  001ab	48 8b e8	 mov	 rbp, rax
  001ae	e8 00 00 00 00	 call	 _Py_DecRef

; 2536 :             if (iter == NULL)

  001b3	48 85 ed	 test	 rbp, rbp
  001b6	74 3d		 je	 SHORT $error$22085

; 2537 :                 goto error;
; 2538 :             if (Py_EnterRecursiveCall(" while pickling an object")) {

  001b8	e8 00 00 00 00	 call	 _Py_PXCTX
  001bd	85 c0		 test	 eax, eax
  001bf	74 07		 je	 SHORT $LN35@save_dict
  001c1	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  001c6	eb 07		 jmp	 SHORT $LN36@save_dict
$LN35@save_dict:
  001c8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN36@save_dict:
  001cf	ff 40 18	 inc	 DWORD PTR [rax+24]
  001d2	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  001d5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  001db	7e 50		 jle	 SHORT $LN7@save_dict
  001dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNMNDPHJ@?5while?5pickling?5an?5object?$AA@
  001e4	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  001e9	85 c0		 test	 eax, eax
  001eb	74 40		 je	 SHORT $LN7@save_dict

; 2539 :                 Py_DECREF(iter);

  001ed	48 8b cd	 mov	 rcx, rbp
  001f0	e8 00 00 00 00	 call	 _Py_DecRef
$error$22085:

; 2545 :         }
; 2546 :     }
; 2547 : 
; 2548 :     if (0) {
; 2549 :   error:
; 2550 :         status = -1;

  001f5	41 8b f5	 mov	 esi, r13d
$LN10@save_dict:

; 2551 :     }
; 2552 : 
; 2553 :     if (self->fast && !fast_save_leave(self, obj))

  001f8	83 bf b0 00 00
	00 00		 cmp	 DWORD PTR [rdi+176], 0
  001ff	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00204	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00209	74 11		 je	 SHORT $LN43@save_dict
  0020b	49 8b d4	 mov	 rdx, r12
  0020e	48 8b cf	 mov	 rcx, rdi
  00211	e8 00 00 00 00	 call	 fast_save_leave
  00216	85 c0		 test	 eax, eax
  00218	41 0f 44 f5	 cmove	 esi, r13d
$LN43@save_dict:

; 2554 :         status = -1;
; 2555 : 
; 2556 :     return status;

  0021c	8b c6		 mov	 eax, esi

; 2557 : }

  0021e	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00223	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00227	41 5d		 pop	 r13
  00229	41 5c		 pop	 r12
  0022b	5f		 pop	 rdi
  0022c	c3		 ret	 0
$LN7@save_dict:

; 2540 :                 goto error;
; 2541 :             }
; 2542 :             status = batch_dict(self, iter);

  0022d	48 8b d5	 mov	 rdx, rbp
  00230	48 8b cf	 mov	 rcx, rdi
  00233	e8 00 00 00 00	 call	 batch_dict
  00238	8b f0		 mov	 esi, eax

; 2543 :             Py_LeaveRecursiveCall();

  0023a	e8 00 00 00 00	 call	 _Py_PXCTX
  0023f	85 c0		 test	 eax, eax
  00241	74 0a		 je	 SHORT $LN37@save_dict
  00243	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00248	4c 8b d8	 mov	 r11, rax
  0024b	eb 07		 jmp	 SHORT $LN38@save_dict
$LN37@save_dict:
  0024d	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _PyThreadState_Current
$LN38@save_dict:
  00254	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  0025a	83 f8 64	 cmp	 eax, 100		; 00000064H
  0025d	7e 05		 jle	 SHORT $LN39@save_dict
  0025f	83 c0 ce	 add	 eax, -50		; ffffffffffffffceH
  00262	eb 06		 jmp	 SHORT $LN40@save_dict
$LN39@save_dict:
  00264	c1 f8 02	 sar	 eax, 2
  00267	8d 04 40	 lea	 eax, DWORD PTR [rax+rax*2]
$LN40@save_dict:
  0026a	41 ff 4b 18	 dec	 DWORD PTR [r11+24]
  0026e	41 39 43 18	 cmp	 DWORD PTR [r11+24], eax
  00272	7d 2a		 jge	 SHORT $LN5@save_dict
  00274	e8 00 00 00 00	 call	 _Py_PXCTX
  00279	85 c0		 test	 eax, eax
  0027b	74 16		 je	 SHORT $LN41@save_dict
  0027d	e8 00 00 00 00	 call	 _PyParallel_GetThreadState

; 2544 :             Py_DECREF(iter);

  00282	48 8b cd	 mov	 rcx, rbp
  00285	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
  00289	e8 00 00 00 00	 call	 _Py_DecRef
  0028e	e9 65 ff ff ff	 jmp	 $LN10@save_dict
$LN41@save_dict:

; 2543 :             Py_LeaveRecursiveCall();

  00293	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
  0029a	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN5@save_dict:

; 2544 :             Py_DECREF(iter);

  0029e	48 8b cd	 mov	 rcx, rbp
  002a1	e8 00 00 00 00	 call	 _Py_DecRef
  002a6	e9 4d ff ff ff	 jmp	 $LN10@save_dict
save_dict ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@MLEIBFDL@can?8t?5pickle?5global?5identifier?5?8@ ; `string'
PUBLIC	??_C@_0DN@KMBOMFB@can?8t?5pickle?5module?5identifier?5?8@ ; `string'
PUBLIC	??_C@_0EL@NGOKECAH@_compat_pickle?4REVERSE_IMPORT_MA@ ; `string'
PUBLIC	??_C@_0EK@CHBHKAKA@_compat_pickle?4REVERSE_NAME_MAPP@ ; `string'
PUBLIC	??_C@_0FI@NLCPOHBE@_compat_pickle?4REVERSE_NAME_MAPP@ ; `string'
PUBLIC	??_C@_0M@BMDGBENA@save_global?$AA@		; `string'
PUBLIC	??_C@_0DE@DLEOMJHE@Can?8t?5pickle?5?$CFR?3?5extension?5code?5@ ; `string'
PUBLIC	??_C@_0DE@OEDIPGIM@Can?8t?5pickle?5?$CFR?3?5extension?5code?5@ ; `string'
PUBLIC	??_C@_0DD@GHBKBGK@Can?8t?5pickle?5?$CFR?3?5it?8s?5not?5the?5sa@ ; `string'
PUBLIC	??_C@_0CP@PKDHHGNG@Can?8t?5pickle?5?$CFR?3?5attribute?5looku@ ; `string'
PUBLIC	??_C@_0CM@FENKPBGJ@Can?8t?5pickle?5?$CFR?3?5import?5of?5modul@ ; `string'
PUBLIC	??_C@_08BHKDPDAA@__name__?$AA@			; `string'
EXTRN	PyExc_UnicodeEncodeError:QWORD
EXTRN	PyDict_GetItemWithError:PROC
EXTRN	PyTuple_Pack:PROC
EXTRN	PyUnicode_AsUTF8String:PROC
EXTRN	PyUnicode_AsASCIIString:PROC
EXTRN	PyImport_Import:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$save_global DD imagerel save_global
	DD	imagerel save_global+10
	DD	imagerel $unwind$save_global
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$save_global DD imagerel save_global+10
	DD	imagerel save_global+14
	DD	imagerel $chain$0$save_global
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$save_global DD imagerel save_global+14
	DD	imagerel save_global+1493
	DD	imagerel $chain$5$save_global
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$save_global DD imagerel save_global+1493
	DD	imagerel save_global+1607
	DD	imagerel $chain$6$save_global
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$save_global DD imagerel save_global+1607
	DD	imagerel save_global+1718
	DD	imagerel $chain$7$save_global
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$save_global DD imagerel save_global+1718
	DD	imagerel save_global+1848
	DD	imagerel $chain$8$save_global
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$save_global DD 021H
	DD	imagerel save_global
	DD	imagerel save_global+10
	DD	imagerel $unwind$save_global
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$save_global DD 021H
	DD	imagerel save_global+10
	DD	imagerel save_global+14
	DD	imagerel $chain$0$save_global
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$save_global DD 020021H
	DD	0107400H
	DD	imagerel save_global+10
	DD	imagerel save_global+14
	DD	imagerel $chain$0$save_global
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$save_global DD 0a1621H
	DD	08f416H
	DD	09e412H
	DD	0ad40eH
	DD	0107408H
	DD	0f6404H
	DD	imagerel save_global+10
	DD	imagerel save_global+14
	DD	imagerel $chain$0$save_global
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$save_global DD 020421H
	DD	0e3404H
	DD	imagerel save_global
	DD	imagerel save_global+10
	DD	imagerel $unwind$save_global
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_global DD 030a01H
	DD	0c006a20aH
	DD	05004H
xdata	ENDS
;	COMDAT ??_C@_0DN@MLEIBFDL@can?8t?5pickle?5global?5identifier?5?8@
CONST	SEGMENT
??_C@_0DN@MLEIBFDL@can?8t?5pickle?5global?5identifier?5?8@ DB 'can''t pic'
	DB	'kle global identifier ''%S'' using pickle protocol %i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@KMBOMFB@can?8t?5pickle?5module?5identifier?5?8@
CONST	SEGMENT
??_C@_0DN@KMBOMFB@can?8t?5pickle?5module?5identifier?5?8@ DB 'can''t pick'
	DB	'le module identifier ''%S'' using pickle protocol %i', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@NGOKECAH@_compat_pickle?4REVERSE_IMPORT_MA@
CONST	SEGMENT
??_C@_0EL@NGOKECAH@_compat_pickle?4REVERSE_IMPORT_MA@ DB '_compat_pickle.'
	DB	'REVERSE_IMPORT_MAPPING values should be strings, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@CHBHKAKA@_compat_pickle?4REVERSE_NAME_MAPP@
CONST	SEGMENT
??_C@_0EK@CHBHKAKA@_compat_pickle?4REVERSE_NAME_MAPP@ DB '_compat_pickle.'
	DB	'REVERSE_NAME_MAPPING values should be 2-tuples, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@NLCPOHBE@_compat_pickle?4REVERSE_NAME_MAPP@
CONST	SEGMENT
??_C@_0FI@NLCPOHBE@_compat_pickle?4REVERSE_NAME_MAPP@ DB '_compat_pickle.'
	DB	'REVERSE_NAME_MAPPING values should be pairs of str, not (%.20'
	DB	'0s, %.200s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BMDGBENA@save_global?$AA@
CONST	SEGMENT
??_C@_0M@BMDGBENA@save_global?$AA@ DB 'save_global', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@DLEOMJHE@Can?8t?5pickle?5?$CFR?3?5extension?5code?5@
CONST	SEGMENT
??_C@_0DE@DLEOMJHE@Can?8t?5pickle?5?$CFR?3?5extension?5code?5@ DB 'Can''t'
	DB	' pickle %R: extension code %ld is out of range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@OEDIPGIM@Can?8t?5pickle?5?$CFR?3?5extension?5code?5@
CONST	SEGMENT
??_C@_0DE@OEDIPGIM@Can?8t?5pickle?5?$CFR?3?5extension?5code?5@ DB 'Can''t'
	DB	' pickle %R: extension code %R isn''t an integer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@GHBKBGK@Can?8t?5pickle?5?$CFR?3?5it?8s?5not?5the?5sa@
CONST	SEGMENT
??_C@_0DD@GHBKBGK@Can?8t?5pickle?5?$CFR?3?5it?8s?5not?5the?5sa@ DB 'Can'''
	DB	't pickle %R: it''s not the same object as %S.%S', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@PKDHHGNG@Can?8t?5pickle?5?$CFR?3?5attribute?5looku@
CONST	SEGMENT
??_C@_0CP@PKDHHGNG@Can?8t?5pickle?5?$CFR?3?5attribute?5looku@ DB 'Can''t '
	DB	'pickle %R: attribute lookup %S.%S failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FENKPBGJ@Can?8t?5pickle?5?$CFR?3?5import?5of?5modul@
CONST	SEGMENT
??_C@_0CM@FENKPBGJ@Can?8t?5pickle?5?$CFR?3?5import?5of?5modul@ DB 'Can''t'
	DB	' pickle %R: import of module %R failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BHKDPDAA@__name__?$AA@
CONST	SEGMENT
??_C@_08BHKDPDAA@__name__?$AA@ DB '__name__', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT save_global
_TEXT	SEGMENT
unicode_encoder$1$ = 48
pdata$22172 = 48
self$ = 112
obj$ = 120
name$ = 128
global_op$ = 136
save_global PROC					; COMDAT

; 2561 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	41 54		 push	 r12
  00006	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0000a	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  0000e	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  00012	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi

; 2562 :     static PyObject *name_str = NULL;
; 2563 :     PyObject *global_name = NULL;

  00016	33 db		 xor	 ebx, ebx
  00018	4c 89 68 e8	 mov	 QWORD PTR [rax-24], r13
  0001c	4c 89 70 e0	 mov	 QWORD PTR [rax-32], r14
  00020	4c 89 78 d8	 mov	 QWORD PTR [rax-40], r15

; 2564 :     PyObject *module_name = NULL;
; 2565 :     PyObject *module = NULL;
; 2566 :     PyObject *cls;
; 2567 :     int status = 0;
; 2568 : 
; 2569 :     const char global_op = GLOBAL;

  00024	c6 40 20 63	 mov	 BYTE PTR [rax+32], 99	; 00000063H

; 2570 : 
; 2571 :     if (name_str == NULL) {

  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?name_str@?1??save_global@@9@9
  0002f	49 8b f0	 mov	 rsi, r8
  00032	4c 8b f2	 mov	 r14, rdx
  00035	4c 8b f9	 mov	 r15, rcx
  00038	8b fb		 mov	 edi, ebx
  0003a	8b eb		 mov	 ebp, ebx
  0003c	44 8b e3	 mov	 r12d, ebx
  0003f	48 85 c0	 test	 rax, rax
  00042	75 1c		 jne	 SHORT $LN70@save_globa

; 2572 :         name_str = PyUnicode_InternFromString("__name__");

  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08BHKDPDAA@__name__?$AA@
  0004b	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00050	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?name_str@?1??save_global@@9@9, rax

; 2573 :         if (name_str == NULL)

  00057	48 85 c0	 test	 rax, rax
  0005a	0f 84 58 05 00
	00		 je	 $error$22151
$LN70@save_globa:

; 2574 :             goto error;
; 2575 :     }
; 2576 : 
; 2577 :     if (name) {

  00060	41 bd 02 00 00
	00		 mov	 r13d, 2
  00066	48 85 f6	 test	 rsi, rsi
  00069	74 3d		 je	 SHORT $LN69@save_globa

; 2578 :         global_name = name;

  0006b	48 8b de	 mov	 rbx, rsi

; 2579 :         Py_INCREF(global_name);

  0006e	e8 00 00 00 00	 call	 _Py_PXCTX
  00073	85 c0		 test	 eax, eax
  00075	75 48		 jne	 SHORT $LN67@save_globa
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00085	4c 8b ce	 mov	 r9, rsi
  00088	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0008e	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  00093	e8 00 00 00 00	 call	 _PyParallel_Guard
  00098	85 c0		 test	 eax, eax
  0009a	75 06		 jne	 SHORT $LN74@save_globa
  0009c	f6 46 20 20	 test	 BYTE PTR [rsi+32], 32	; 00000020H
  000a0	74 1d		 je	 SHORT $LN67@save_globa
$LN74@save_globa:
  000a2	48 ff 46 50	 inc	 QWORD PTR [rsi+80]

; 2580 :     }
; 2581 :     else {

  000a6	eb 17		 jmp	 SHORT $LN67@save_globa
$LN69@save_globa:

; 2582 :         global_name = PyObject_GetAttr(obj, name_str);

  000a8	48 8b d0	 mov	 rdx, rax
  000ab	49 8b ce	 mov	 rcx, r14
  000ae	e8 00 00 00 00	 call	 PyObject_GetAttr
  000b3	48 8b d8	 mov	 rbx, rax

; 2583 :         if (global_name == NULL)

  000b6	48 85 c0	 test	 rax, rax
  000b9	0f 84 f9 04 00
	00		 je	 $error$22151
$LN67@save_globa:

; 2584 :             goto error;
; 2585 :     }
; 2586 : 
; 2587 :     module_name = whichmodule(obj, global_name);

  000bf	48 8b d3	 mov	 rdx, rbx
  000c2	49 8b ce	 mov	 rcx, r14
  000c5	e8 00 00 00 00	 call	 whichmodule
  000ca	48 8b f8	 mov	 rdi, rax

; 2588 :     if (module_name == NULL)

  000cd	48 85 c0	 test	 rax, rax
  000d0	0f 84 e2 04 00
	00		 je	 $error$22151

; 2589 :         goto error;
; 2590 : 
; 2591 :     /* XXX: Change to use the import C API directly with level=0 to disallow
; 2592 :        relative imports.
; 2593 : 
; 2594 :        XXX: PyImport_ImportModuleLevel could be used. However, this bypasses
; 2595 :        builtins.__import__. Therefore, _pickle, unlike pickle.py, will ignore
; 2596 :        custom import functions (IMHO, this would be a nice security
; 2597 :        feature). The import C API would need to be extended to support the
; 2598 :        extra parameters of __import__ to fix that. */
; 2599 :     module = PyImport_Import(module_name);

  000d6	48 8b c8	 mov	 rcx, rax
  000d9	e8 00 00 00 00	 call	 PyImport_Import
  000de	48 8b e8	 mov	 rbp, rax

; 2600 :     if (module == NULL) {

  000e1	48 85 c0	 test	 rax, rax
  000e4	75 1e		 jne	 SHORT $LN65@save_globa

; 2601 :         PyErr_Format(PicklingError,
; 2602 :                      "Can't pickle %R: import of module %R failed",
; 2603 :                      obj, module_name);

  000e6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  000ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@FENKPBGJ@Can?8t?5pickle?5?$CFR?3?5import?5of?5modul@
  000f4	4c 8b cf	 mov	 r9, rdi
  000f7	4d 8b c6	 mov	 r8, r14
  000fa	e8 00 00 00 00	 call	 PyErr_Format

; 2604 :         goto error;

  000ff	e9 b4 04 00 00	 jmp	 $error$22151
$LN65@save_globa:

; 2605 :     }
; 2606 :     cls = PyObject_GetAttr(module, global_name);

  00104	48 8b d3	 mov	 rdx, rbx
  00107	48 8b c8	 mov	 rcx, rax
  0010a	e8 00 00 00 00	 call	 PyObject_GetAttr

; 2607 :     if (cls == NULL) {

  0010f	48 85 c0	 test	 rax, rax
  00112	75 23		 jne	 SHORT $LN64@save_globa

; 2608 :         PyErr_Format(PicklingError,
; 2609 :                      "Can't pickle %R: attribute lookup %S.%S failed",
; 2610 :                      obj, module_name, global_name);

  00114	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  0011b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@PKDHHGNG@Can?8t?5pickle?5?$CFR?3?5attribute?5looku@
  00122	4c 8b cf	 mov	 r9, rdi
  00125	4d 8b c6	 mov	 r8, r14
  00128	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0012d	e8 00 00 00 00	 call	 PyErr_Format

; 2611 :         goto error;

  00132	e9 81 04 00 00	 jmp	 $error$22151
$LN64@save_globa:

; 2612 :     }
; 2613 :     if (cls != obj) {
; 2614 :         Py_DECREF(cls);

  00137	48 8b c8	 mov	 rcx, rax
  0013a	49 3b c6	 cmp	 rax, r14
  0013d	74 28		 je	 SHORT $LN63@save_globa
  0013f	e8 00 00 00 00	 call	 _Py_DecRef

; 2615 :         PyErr_Format(PicklingError,
; 2616 :                      "Can't pickle %R: it's not the same object as %S.%S",
; 2617 :                      obj, module_name, global_name);

  00144	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  0014b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@GHBKBGK@Can?8t?5pickle?5?$CFR?3?5it?8s?5not?5the?5sa@
  00152	4c 8b cf	 mov	 r9, rdi
  00155	4d 8b c6	 mov	 r8, r14
  00158	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0015d	e8 00 00 00 00	 call	 PyErr_Format

; 2618 :         goto error;

  00162	e9 51 04 00 00	 jmp	 $error$22151
$LN63@save_globa:

; 2619 :     }
; 2620 :     Py_DECREF(cls);

  00167	e8 00 00 00 00	 call	 _Py_DecRef

; 2621 : 
; 2622 :     if (self->proto >= 2) {

  0016c	45 39 af a0 00
	00 00		 cmp	 DWORD PTR [r15+160], r13d
  00173	0f 8c 02 01 00
	00		 jl	 $gen_global$22178

; 2623 :         /* See whether this is in the extension registry, and if
; 2624 :          * so generate an EXT opcode.
; 2625 :          */
; 2626 :         PyObject *code_obj;      /* extension code as Python object */
; 2627 :         long code;               /* extension code as C value */
; 2628 :         char pdata[5];
; 2629 :         Py_ssize_t n;
; 2630 : 
; 2631 :         PyTuple_SET_ITEM(two_tuple, 0, module_name);

  00179	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR two_tuple

; 2632 :         PyTuple_SET_ITEM(two_tuple, 1, global_name);
; 2633 :         code_obj = PyDict_GetItem(extension_registry, two_tuple);

  00180	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR extension_registry
  00187	48 89 7a 70	 mov	 QWORD PTR [rdx+112], rdi
  0018b	48 89 5a 78	 mov	 QWORD PTR [rdx+120], rbx
  0018f	e8 00 00 00 00	 call	 PyDict_GetItem

; 2634 :         /* The object is not registered in the extension registry.
; 2635 :            This is the most likely code path. */
; 2636 :         if (code_obj == NULL)

  00194	48 85 c0	 test	 rax, rax
  00197	0f 84 de 00 00
	00		 je	 $gen_global$22178

; 2637 :             goto gen_global;
; 2638 : 
; 2639 :         /* XXX: pickle.py doesn't check neither the type, nor the range
; 2640 :            of the value returned by the extension_registry. It should for
; 2641 :            consistency. */
; 2642 : 
; 2643 :         /* Verify code_obj has the right type and value. */
; 2644 :         if (!PyLong_Check(code_obj)) {

  0019d	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  001a1	f7 81 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rcx+256], 16777216 ; 01000000H
  001ab	75 1e		 jne	 SHORT $LN60@save_globa

; 2645 :             PyErr_Format(PicklingError,
; 2646 :                          "Can't pickle %R: extension code %R isn't an integer",
; 2647 :                          obj, code_obj);

  001ad	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  001b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@OEDIPGIM@Can?8t?5pickle?5?$CFR?3?5extension?5code?5@
  001bb	4c 8b c8	 mov	 r9, rax
  001be	4d 8b c6	 mov	 r8, r14
  001c1	e8 00 00 00 00	 call	 PyErr_Format

; 2648 :             goto error;

  001c6	e9 ed 03 00 00	 jmp	 $error$22151
$LN60@save_globa:

; 2649 :         }
; 2650 :         code = PyLong_AS_LONG(code_obj);

  001cb	48 8b c8	 mov	 rcx, rax
  001ce	e8 00 00 00 00	 call	 PyLong_AsLong
  001d3	8b f0		 mov	 esi, eax

; 2651 :         if (code <= 0 || code > 0x7fffffffL) {

  001d5	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  001d8	81 f9 fe ff ff
	7f		 cmp	 ecx, 2147483646		; 7ffffffeH
  001de	77 6f		 ja	 SHORT $LN58@save_globa

; 2662 :             pdata[1] = (unsigned char)code;

  001e0	88 44 24 31	 mov	 BYTE PTR pdata$22172[rsp+1], al
  001e4	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  001e9	7f 07		 jg	 SHORT $LN56@save_globa

; 2657 :         }
; 2658 : 
; 2659 :         /* Generate an EXT opcode. */
; 2660 :         if (code <= 0xff) {
; 2661 :             pdata[0] = EXT1;

  001eb	c6 44 24 30 82	 mov	 BYTE PTR pdata$22172[rsp], -126 ; ffffffffffffff82H

; 2663 :             n = 2;

  001f0	eb 3f		 jmp	 SHORT $LN53@save_globa
$LN56@save_globa:

; 2664 :         }
; 2665 :         else if (code <= 0xffff) {

  001f2	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  001f7	7f 15		 jg	 SHORT $LN54@save_globa

; 2666 :             pdata[0] = EXT2;
; 2667 :             pdata[1] = (unsigned char)(code & 0xff);
; 2668 :             pdata[2] = (unsigned char)((code >> 8) & 0xff);

  001f9	c1 fe 08	 sar	 esi, 8
  001fc	c6 44 24 30 83	 mov	 BYTE PTR pdata$22172[rsp], -125 ; ffffffffffffff83H

; 2669 :             n = 3;

  00201	41 bd 03 00 00
	00		 mov	 r13d, 3
  00207	40 88 74 24 32	 mov	 BYTE PTR pdata$22172[rsp+2], sil

; 2670 :         }
; 2671 :         else {

  0020c	eb 23		 jmp	 SHORT $LN53@save_globa
$LN54@save_globa:

; 2672 :             pdata[0] = EXT4;
; 2673 :             pdata[1] = (unsigned char)(code & 0xff);
; 2674 :             pdata[2] = (unsigned char)((code >> 8) & 0xff);

  0020e	c1 f8 08	 sar	 eax, 8
  00211	c6 44 24 30 84	 mov	 BYTE PTR pdata$22172[rsp], -124 ; ffffffffffffff84H

; 2675 :             pdata[3] = (unsigned char)((code >> 16) & 0xff);
; 2676 :             pdata[4] = (unsigned char)((code >> 24) & 0xff);
; 2677 :             n = 5;

  00216	41 bd 05 00 00
	00		 mov	 r13d, 5
  0021c	88 44 24 32	 mov	 BYTE PTR pdata$22172[rsp+2], al
  00220	8b c6		 mov	 eax, esi
  00222	c1 f8 10	 sar	 eax, 16
  00225	c1 fe 18	 sar	 esi, 24
  00228	40 88 74 24 34	 mov	 BYTE PTR pdata$22172[rsp+4], sil
  0022d	88 44 24 33	 mov	 BYTE PTR pdata$22172[rsp+3], al
$LN53@save_globa:

; 2678 :         }
; 2679 : 
; 2680 :         if (_Pickler_Write(self, pdata, n) < 0)

  00231	48 8d 54 24 30	 lea	 rdx, QWORD PTR pdata$22172[rsp]
  00236	4d 8b c5	 mov	 r8, r13
  00239	49 8b cf	 mov	 rcx, r15
  0023c	e8 00 00 00 00	 call	 _Pickler_Write
  00241	48 85 c0	 test	 rax, rax
  00244	0f 88 6e 03 00
	00		 js	 $error$22151

; 2681 :             goto error;
; 2682 :     }
; 2683 :     else {

  0024a	e9 6d 03 00 00	 jmp	 $LN12@save_globa
$LN58@save_globa:

; 2652 :             if (!PyErr_Occurred())

  0024f	e8 00 00 00 00	 call	 PyErr_Occurred
  00254	48 85 c0	 test	 rax, rax
  00257	0f 85 5b 03 00
	00		 jne	 $error$22151

; 2653 :                 PyErr_Format(PicklingError,
; 2654 :                              "Can't pickle %R: extension code %ld is out of range",
; 2655 :                              obj, code);

  0025d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  00264	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@DLEOMJHE@Can?8t?5pickle?5?$CFR?3?5extension?5code?5@
  0026b	44 8b ce	 mov	 r9d, esi
  0026e	4d 8b c6	 mov	 r8, r14
  00271	e8 00 00 00 00	 call	 PyErr_Format

; 2656 :             goto error;

  00276	e9 3d 03 00 00	 jmp	 $error$22151
$gen_global$22178:

; 2684 :         /* Generate a normal global opcode if we are using a pickle
; 2685 :            protocol <= 2, or if the object is not registered in the
; 2686 :            extension registry. */
; 2687 :         PyObject *encoded;
; 2688 :         PyObject *(*unicode_encoder)(PyObject *);
; 2689 : 
; 2690 :   gen_global:
; 2691 :         if (_Pickler_Write(self, &global_op, 1) < 0)

  0027b	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR global_op$[rsp]
  00283	41 b8 01 00 00
	00		 mov	 r8d, 1
  00289	49 8b cf	 mov	 rcx, r15
  0028c	e8 00 00 00 00	 call	 _Pickler_Write
  00291	48 85 c0	 test	 rax, rax
  00294	0f 88 1e 03 00
	00		 js	 $error$22151

; 2692 :             goto error;
; 2693 : 
; 2694 :         /* Since Python 3.0 now supports non-ASCII identifiers, we encode both
; 2695 :            the module name and the global name using UTF-8. We do so only when
; 2696 :            we are using the pickle protocol newer than version 3. This is to
; 2697 :            ensure compatibility with older Unpickler running on Python 2.x. */
; 2698 :         if (self->proto >= 3) {

  0029a	41 83 bf a0 00
	00 00 03	 cmp	 DWORD PTR [r15+160], 3
  002a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyUnicode_AsASCIIString
  002a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_AsUTF8String
  002b0	48 0f 4d c8	 cmovge	 rcx, rax
  002b4	48 89 4c 24 30	 mov	 QWORD PTR unicode_encoder$1$[rsp], rcx

; 2699 :             unicode_encoder = PyUnicode_AsUTF8String;
; 2700 :         }
; 2701 :         else {
; 2702 :             unicode_encoder = PyUnicode_AsASCIIString;
; 2703 :         }
; 2704 : 
; 2705 :         /* For protocol < 3 and if the user didn't request against doing so,
; 2706 :            we convert module names to the old 2.x module names. */
; 2707 :         if (self->fix_imports) {

  002b9	45 39 a7 b8 00
	00 00		 cmp	 DWORD PTR [r15+184], r12d
  002c0	0f 84 da 01 00
	00		 je	 $LN23@save_globa

; 2708 :             PyObject *key;
; 2709 :             PyObject *item;
; 2710 : 
; 2711 :             key = PyTuple_Pack(2, module_name, global_name);

  002c6	4c 8b c3	 mov	 r8, rbx
  002c9	48 8b d7	 mov	 rdx, rdi
  002cc	49 8b cd	 mov	 rcx, r13
  002cf	e8 00 00 00 00	 call	 PyTuple_Pack
  002d4	4c 8b e8	 mov	 r13, rax

; 2712 :             if (key == NULL)

  002d7	48 85 c0	 test	 rax, rax
  002da	0f 84 d8 02 00
	00		 je	 $error$22151

; 2713 :                 goto error;
; 2714 :             item = PyDict_GetItemWithError(name_mapping_3to2, key);

  002e0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR name_mapping_3to2
  002e7	48 8b d0	 mov	 rdx, rax
  002ea	e8 00 00 00 00	 call	 PyDict_GetItemWithError

; 2715 :             Py_DECREF(key);

  002ef	49 8b cd	 mov	 rcx, r13
  002f2	48 8b f0	 mov	 rsi, rax
  002f5	e8 00 00 00 00	 call	 _Py_DecRef

; 2716 :             if (item) {

  002fa	48 85 f6	 test	 rsi, rsi
  002fd	0f 84 00 01 00
	00		 je	 $LN45@save_globa

; 2717 :                 if (!PyTuple_Check(item) || PyTuple_GET_SIZE(item) != 2) {

  00303	4c 8b 46 58	 mov	 r8, QWORD PTR [rsi+88]
  00307	41 f7 80 00 01
	00 00 00 00 00
	04		 test	 DWORD PTR [r8+256], 67108864 ; 04000000H
  00312	0f 84 cf 00 00
	00		 je	 $LN43@save_globa
  00318	48 83 7e 60 02	 cmp	 QWORD PTR [rsi+96], 2
  0031d	0f 85 c4 00 00
	00		 jne	 $LN43@save_globa

; 2723 :                 }
; 2724 :                 Py_CLEAR(module_name);

  00323	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0032a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@BMDGBENA@save_global?$AA@
  00331	4c 8b cf	 mov	 r9, rdi
  00334	41 b8 a4 0a 00
	00		 mov	 r8d, 2724		; 00000aa4H
  0033a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00342	e8 00 00 00 00	 call	 _PyParallel_Guard
  00347	85 c0		 test	 eax, eax
  00349	75 08		 jne	 SHORT $LN41@save_globa
  0034b	48 8b cf	 mov	 rcx, rdi
  0034e	e8 00 00 00 00	 call	 _Py_DecRef
$LN41@save_globa:

; 2725 :                 Py_CLEAR(global_name);

  00353	48 85 db	 test	 rbx, rbx
  00356	74 30		 je	 SHORT $LN37@save_globa
  00358	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0035f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@BMDGBENA@save_global?$AA@
  00366	4c 8b cb	 mov	 r9, rbx
  00369	41 b8 a5 0a 00
	00		 mov	 r8d, 2725		; 00000aa5H
  0036f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00377	e8 00 00 00 00	 call	 _PyParallel_Guard
  0037c	85 c0		 test	 eax, eax
  0037e	75 08		 jne	 SHORT $LN37@save_globa
  00380	48 8b cb	 mov	 rcx, rbx
  00383	e8 00 00 00 00	 call	 _Py_DecRef
$LN37@save_globa:

; 2726 :                 module_name = PyTuple_GET_ITEM(item, 0);

  00388	48 8b 7e 70	 mov	 rdi, QWORD PTR [rsi+112]

; 2727 :                 global_name = PyTuple_GET_ITEM(item, 1);

  0038c	48 8b 5e 78	 mov	 rbx, QWORD PTR [rsi+120]

; 2728 :                 if (!PyUnicode_Check(module_name) ||
; 2729 :                     !PyUnicode_Check(global_name)) {

  00390	4c 8b 47 58	 mov	 r8, QWORD PTR [rdi+88]
  00394	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  0039f	74 22		 je	 SHORT $LN33@save_globa
  003a1	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  003a5	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  003af	74 12		 je	 SHORT $LN33@save_globa

; 2736 :                 }
; 2737 :                 Py_INCREF(module_name);

  003b1	48 8b cf	 mov	 rcx, rdi
  003b4	e8 00 00 00 00	 call	 _Py_IncRef

; 2738 :                 Py_INCREF(global_name);

  003b9	48 8b cb	 mov	 rcx, rbx
  003bc	e8 00 00 00 00	 call	 _Py_IncRef
  003c1	eb 4e		 jmp	 SHORT $LN31@save_globa
$LN33@save_globa:

; 2730 :                     PyErr_Format(PyExc_RuntimeError,
; 2731 :                                  "_compat_pickle.REVERSE_NAME_MAPPING values "
; 2732 :                                  "should be pairs of str, not (%.200s, %.200s)",
; 2733 :                                  Py_TYPE(module_name)->tp_name,
; 2734 :                                  Py_TYPE(global_name)->tp_name);

  003c3	4c 8b 4b 58	 mov	 r9, QWORD PTR [rbx+88]
  003c7	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  003cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  003d2	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  003d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FI@NLCPOHBE@_compat_pickle?4REVERSE_NAME_MAPP@
  003dd	e8 00 00 00 00	 call	 PyErr_Format

; 2735 :                     goto error;

  003e2	e9 d1 01 00 00	 jmp	 $error$22151
$LN43@save_globa:

; 2718 :                     PyErr_Format(PyExc_RuntimeError,
; 2719 :                                  "_compat_pickle.REVERSE_NAME_MAPPING values "
; 2720 :                                  "should be 2-tuples, not %.200s",
; 2721 :                                  Py_TYPE(item)->tp_name);

  003e7	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  003eb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  003f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EK@CHBHKAKA@_compat_pickle?4REVERSE_NAME_MAPP@
  003f9	e8 00 00 00 00	 call	 PyErr_Format

; 2722 :                     goto error;

  003fe	e9 b5 01 00 00	 jmp	 $error$22151
$LN45@save_globa:

; 2739 :             }
; 2740 :             else if (PyErr_Occurred()) {

  00403	e8 00 00 00 00	 call	 PyErr_Occurred
  00408	48 85 c0	 test	 rax, rax
  0040b	0f 85 a7 01 00
	00		 jne	 $error$22151
$LN31@save_globa:

; 2741 :                 goto error;
; 2742 :             }
; 2743 : 
; 2744 :             item = PyDict_GetItemWithError(import_mapping_3to2, module_name);

  00411	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR import_mapping_3to2
  00418	48 8b d7	 mov	 rdx, rdi
  0041b	e8 00 00 00 00	 call	 PyDict_GetItemWithError
  00420	48 8b f0	 mov	 rsi, rax

; 2745 :             if (item) {

  00423	48 85 c0	 test	 rax, rax
  00426	74 6a		 je	 SHORT $LN30@save_globa

; 2746 :                 if (!PyUnicode_Check(item)) {

  00428	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  0042c	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  00437	75 1c		 jne	 SHORT $LN28@save_globa

; 2747 :                     PyErr_Format(PyExc_RuntimeError,
; 2748 :                                  "_compat_pickle.REVERSE_IMPORT_MAPPING values "
; 2749 :                                  "should be strings, not %.200s",
; 2750 :                                  Py_TYPE(item)->tp_name);

  00439	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0043d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00444	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EL@NGOKECAH@_compat_pickle?4REVERSE_IMPORT_MA@
  0044b	e8 00 00 00 00	 call	 PyErr_Format

; 2751 :                     goto error;

  00450	e9 63 01 00 00	 jmp	 $error$22151
$LN28@save_globa:

; 2752 :                 }
; 2753 :                 Py_CLEAR(module_name);

  00455	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0045c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@BMDGBENA@save_global?$AA@
  00463	4c 8b cf	 mov	 r9, rdi
  00466	41 b8 c1 0a 00
	00		 mov	 r8d, 2753		; 00000ac1H
  0046c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00474	e8 00 00 00 00	 call	 _PyParallel_Guard
  00479	85 c0		 test	 eax, eax
  0047b	75 08		 jne	 SHORT $LN27@save_globa
  0047d	48 8b cf	 mov	 rcx, rdi
  00480	e8 00 00 00 00	 call	 _Py_DecRef
$LN27@save_globa:

; 2754 :                 module_name = item;
; 2755 :                 Py_INCREF(module_name);

  00485	48 8b ce	 mov	 rcx, rsi
  00488	48 8b fe	 mov	 rdi, rsi
  0048b	e8 00 00 00 00	 call	 _Py_IncRef
  00490	eb 0e		 jmp	 SHORT $LN23@save_globa
$LN30@save_globa:

; 2756 :             }
; 2757 :             else if (PyErr_Occurred()) {

  00492	e8 00 00 00 00	 call	 PyErr_Occurred
  00497	48 85 c0	 test	 rax, rax
  0049a	0f 85 18 01 00
	00		 jne	 $error$22151
$LN23@save_globa:

; 2758 :                 goto error;
; 2759 :             }
; 2760 :         }
; 2761 : 
; 2762 :         /* Save the name of the module. */
; 2763 :         encoded = unicode_encoder(module_name);

  004a0	4c 8b 6c 24 30	 mov	 r13, QWORD PTR unicode_encoder$1$[rsp]
  004a5	48 8b cf	 mov	 rcx, rdi
  004a8	41 ff d5	 call	 r13
  004ab	48 8b f0	 mov	 rsi, rax

; 2764 :         if (encoded == NULL) {

  004ae	48 85 c0	 test	 rax, rax
  004b1	75 36		 jne	 SHORT $LN22@save_globa

; 2765 :             if (PyErr_ExceptionMatches(PyExc_UnicodeEncodeError))

  004b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnicodeEncodeError
  004ba	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  004bf	85 c0		 test	 eax, eax
  004c1	0f 84 f1 00 00
	00		 je	 $error$22151

; 2766 :                 PyErr_Format(PicklingError,
; 2767 :                              "can't pickle module identifier '%S' using "
; 2768 :                              "pickle protocol %i", module_name, self->proto);

  004c7	45 8b 8f a0 00
	00 00		 mov	 r9d, DWORD PTR [r15+160]
  004ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  004d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@KMBOMFB@can?8t?5pickle?5module?5identifier?5?8@
  004dc	4c 8b c7	 mov	 r8, rdi
  004df	e8 00 00 00 00	 call	 PyErr_Format

; 2769 :             goto error;

  004e4	e9 cf 00 00 00	 jmp	 $error$22151
$LN22@save_globa:

; 2770 :         }
; 2771 :         if (_Pickler_Write(self, PyBytes_AS_STRING(encoded),
; 2772 :                           PyBytes_GET_SIZE(encoded)) < 0) {

  004e9	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  004ed	48 8d 50 78	 lea	 rdx, QWORD PTR [rax+120]
  004f1	49 8b cf	 mov	 rcx, r15
  004f4	e8 00 00 00 00	 call	 _Pickler_Write

; 2773 :             Py_DECREF(encoded);

  004f9	48 8b ce	 mov	 rcx, rsi
  004fc	48 85 c0	 test	 rax, rax
  004ff	79 0a		 jns	 SHORT $LN20@save_globa
  00501	e8 00 00 00 00	 call	 _Py_DecRef

; 2774 :             goto error;

  00506	e9 ad 00 00 00	 jmp	 $error$22151
$LN20@save_globa:

; 2775 :         }
; 2776 :         Py_DECREF(encoded);

  0050b	e8 00 00 00 00	 call	 _Py_DecRef

; 2777 :         if(_Pickler_Write(self, "\n", 1) < 0)

  00510	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00517	41 b8 01 00 00
	00		 mov	 r8d, 1
  0051d	49 8b cf	 mov	 rcx, r15
  00520	e8 00 00 00 00	 call	 _Pickler_Write
  00525	48 85 c0	 test	 rax, rax
  00528	0f 88 8a 00 00
	00		 js	 $error$22151

; 2778 :             goto error;
; 2779 : 
; 2780 :         /* Save the name of the module. */
; 2781 :         encoded = unicode_encoder(global_name);

  0052e	48 8b cb	 mov	 rcx, rbx
  00531	41 ff d5	 call	 r13
  00534	48 8b f0	 mov	 rsi, rax

; 2782 :         if (encoded == NULL) {

  00537	48 85 c0	 test	 rax, rax
  0053a	75 2f		 jne	 SHORT $LN18@save_globa

; 2783 :             if (PyErr_ExceptionMatches(PyExc_UnicodeEncodeError))

  0053c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnicodeEncodeError
  00543	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00548	85 c0		 test	 eax, eax
  0054a	74 6c		 je	 SHORT $error$22151

; 2784 :                 PyErr_Format(PicklingError,
; 2785 :                              "can't pickle global identifier '%S' using "
; 2786 :                              "pickle protocol %i", global_name, self->proto);

  0054c	45 8b 8f a0 00
	00 00		 mov	 r9d, DWORD PTR [r15+160]
  00553	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  0055a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@MLEIBFDL@can?8t?5pickle?5global?5identifier?5?8@
  00561	4c 8b c3	 mov	 r8, rbx
  00564	e8 00 00 00 00	 call	 PyErr_Format

; 2787 :             goto error;

  00569	eb 4d		 jmp	 SHORT $error$22151
$LN18@save_globa:

; 2788 :         }
; 2789 :         if (_Pickler_Write(self, PyBytes_AS_STRING(encoded),
; 2790 :                           PyBytes_GET_SIZE(encoded)) < 0) {

  0056b	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0056f	48 8d 50 78	 lea	 rdx, QWORD PTR [rax+120]
  00573	49 8b cf	 mov	 rcx, r15
  00576	e8 00 00 00 00	 call	 _Pickler_Write

; 2791 :             Py_DECREF(encoded);

  0057b	48 8b ce	 mov	 rcx, rsi
  0057e	48 85 c0	 test	 rax, rax
  00581	79 07		 jns	 SHORT $LN16@save_globa
  00583	e8 00 00 00 00	 call	 _Py_DecRef

; 2792 :             goto error;

  00588	eb 2e		 jmp	 SHORT $error$22151
$LN16@save_globa:

; 2793 :         }
; 2794 :         Py_DECREF(encoded);

  0058a	e8 00 00 00 00	 call	 _Py_DecRef

; 2795 :         if(_Pickler_Write(self, "\n", 1) < 0)

  0058f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00596	41 b8 01 00 00
	00		 mov	 r8d, 1
  0059c	49 8b cf	 mov	 rcx, r15
  0059f	e8 00 00 00 00	 call	 _Pickler_Write
  005a4	48 85 c0	 test	 rax, rax
  005a7	78 0f		 js	 SHORT $error$22151

; 2796 :             goto error;
; 2797 : 
; 2798 :         /* Memoize the object. */
; 2799 :         if (memo_put(self, obj) < 0)

  005a9	49 8b d6	 mov	 rdx, r14
  005ac	49 8b cf	 mov	 rcx, r15
  005af	e8 00 00 00 00	 call	 memo_put
  005b4	85 c0		 test	 eax, eax
  005b6	79 04		 jns	 SHORT $LN12@save_globa
$error$22151:

; 2800 :             goto error;
; 2801 :     }
; 2802 : 
; 2803 :     if (0) {
; 2804 :   error:
; 2805 :         status = -1;

  005b8	41 83 cc ff	 or	 r12d, -1
$LN12@save_globa:
  005bc	4c 8b 7c 24 40	 mov	 r15, QWORD PTR [rsp+64]
  005c1	4c 8b 74 24 48	 mov	 r14, QWORD PTR [rsp+72]
  005c6	4c 8b 6c 24 50	 mov	 r13, QWORD PTR [rsp+80]
  005cb	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]

; 2806 :     }
; 2807 :     Py_XDECREF(module_name);

  005d0	48 85 ff	 test	 rdi, rdi
  005d3	74 65		 je	 SHORT $LN11@save_globa
  005d5	e8 00 00 00 00	 call	 _Py_PXCTX
  005da	85 c0		 test	 eax, eax
  005dc	75 5c		 jne	 SHORT $LN11@save_globa
  005de	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  005e2	a8 20		 test	 al, 32			; 00000020H
  005e4	75 4c		 jne	 SHORT $LN82@save_globa
  005e6	84 c0		 test	 al, al
  005e8	78 48		 js	 SHORT $LN82@save_globa
  005ea	a8 02		 test	 al, 2
  005ec	75 4c		 jne	 SHORT $LN11@save_globa
  005ee	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  005f2	75 46		 jne	 SHORT $LN11@save_globa
  005f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  005fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00602	4c 8b cf	 mov	 r9, rdi
  00605	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0060b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00613	e8 00 00 00 00	 call	 _PyParallel_Guard
  00618	48 8b cf	 mov	 rcx, rdi
  0061b	85 c0		 test	 eax, eax
  0061d	74 07		 je	 SHORT $LN87@save_globa
  0061f	e8 00 00 00 00	 call	 _Px_Dealloc
  00624	eb 14		 jmp	 SHORT $LN11@save_globa
$LN87@save_globa:
  00626	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0062a	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00630	eb 08		 jmp	 SHORT $LN11@save_globa
$LN82@save_globa:
  00632	48 8b cf	 mov	 rcx, rdi
  00635	e8 00 00 00 00	 call	 Px_DecRef
$LN11@save_globa:

; 2808 :     Py_XDECREF(global_name);

  0063a	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR [rsp+128]
  00642	48 85 db	 test	 rbx, rbx
  00645	74 65		 je	 SHORT $LN7@save_globa
  00647	e8 00 00 00 00	 call	 _Py_PXCTX
  0064c	85 c0		 test	 eax, eax
  0064e	75 5c		 jne	 SHORT $LN7@save_globa
  00650	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00654	a8 20		 test	 al, 32			; 00000020H
  00656	75 4c		 jne	 SHORT $LN93@save_globa
  00658	84 c0		 test	 al, al
  0065a	78 48		 js	 SHORT $LN93@save_globa
  0065c	a8 02		 test	 al, 2
  0065e	75 4c		 jne	 SHORT $LN7@save_globa
  00660	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00664	75 46		 jne	 SHORT $LN7@save_globa
  00666	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0066d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00674	4c 8b cb	 mov	 r9, rbx
  00677	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0067d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00685	e8 00 00 00 00	 call	 _PyParallel_Guard
  0068a	48 8b cb	 mov	 rcx, rbx
  0068d	85 c0		 test	 eax, eax
  0068f	74 07		 je	 SHORT $LN98@save_globa
  00691	e8 00 00 00 00	 call	 _Px_Dealloc
  00696	eb 14		 jmp	 SHORT $LN7@save_globa
$LN98@save_globa:
  00698	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0069c	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  006a2	eb 08		 jmp	 SHORT $LN7@save_globa
$LN93@save_globa:
  006a4	48 8b cb	 mov	 rcx, rbx
  006a7	e8 00 00 00 00	 call	 Px_DecRef
$LN7@save_globa:

; 2809 :     Py_XDECREF(module);

  006ac	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  006b1	48 85 ed	 test	 rbp, rbp
  006b4	74 77		 je	 SHORT $LN113@save_globa
  006b6	e8 00 00 00 00	 call	 _Py_PXCTX
  006bb	85 c0		 test	 eax, eax
  006bd	75 6e		 jne	 SHORT $LN113@save_globa
  006bf	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  006c3	a8 20		 test	 al, 32			; 00000020H
  006c5	75 5e		 jne	 SHORT $LN104@save_globa
  006c7	84 c0		 test	 al, al
  006c9	78 5a		 js	 SHORT $LN104@save_globa
  006cb	a8 02		 test	 al, 2
  006cd	75 5e		 jne	 SHORT $LN113@save_globa
  006cf	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  006d3	75 58		 jne	 SHORT $LN113@save_globa
  006d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  006dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  006e3	4c 8b cd	 mov	 r9, rbp
  006e6	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  006ec	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  006f4	e8 00 00 00 00	 call	 _PyParallel_Guard
  006f9	48 8b cd	 mov	 rcx, rbp
  006fc	85 c0		 test	 eax, eax
  006fe	74 10		 je	 SHORT $LN109@save_globa
  00700	e8 00 00 00 00	 call	 _Px_Dealloc

; 2810 : 
; 2811 :     return status;

  00705	41 8b c4	 mov	 eax, r12d

; 2812 : }

  00708	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0070c	41 5c		 pop	 r12
  0070e	5d		 pop	 rbp
  0070f	c3		 ret	 0

; 2809 :     Py_XDECREF(module);

$LN109@save_globa:
  00710	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  00714	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 2810 : 
; 2811 :     return status;

  0071a	41 8b c4	 mov	 eax, r12d

; 2812 : }

  0071d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00721	41 5c		 pop	 r12
  00723	5d		 pop	 rbp
  00724	c3		 ret	 0

; 2809 :     Py_XDECREF(module);

$LN104@save_globa:
  00725	48 8b cd	 mov	 rcx, rbp
  00728	e8 00 00 00 00	 call	 Px_DecRef
$LN113@save_globa:

; 2810 : 
; 2811 :     return status;

  0072d	41 8b c4	 mov	 eax, r12d

; 2812 : }

  00730	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00734	41 5c		 pop	 r12
  00736	5d		 pop	 rbp
  00737	c3		 ret	 0
save_global ENDP
_TEXT	ENDS
PUBLIC	??_C@_08KKBGFFMJ@Ellipsis?$AA@			; `string'
EXTRN	_Py_EllipsisObject:BYTE
EXTRN	PyUnicode_FromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_ellipsis DD imagerel save_ellipsis
	DD	imagerel save_ellipsis+88
	DD	imagerel $unwind$save_ellipsis
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_ellipsis DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_08KKBGFFMJ@Ellipsis?$AA@
CONST	SEGMENT
??_C@_08KKBGFFMJ@Ellipsis?$AA@ DB 'Ellipsis', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT save_ellipsis
_TEXT	SEGMENT
self$ = 48
save_ellipsis PROC					; COMDAT

; 2816 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 2817 :     PyObject *str = PyUnicode_FromString("Ellipsis");

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08KKBGFFMJ@Ellipsis?$AA@
  00014	e8 00 00 00 00	 call	 PyUnicode_FromString
  00019	48 8b f8	 mov	 rdi, rax

; 2818 :     int res;
; 2819 :     if (str == NULL)

  0001c	48 85 c0	 test	 rax, rax
  0001f	75 0e		 jne	 SHORT $LN1@save_ellip

; 2820 :         return -1;

  00021	83 c8 ff	 or	 eax, -1

; 2824 : }

  00024	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5f		 pop	 rdi
  0002e	c3		 ret	 0
$LN1@save_ellip:

; 2821 :     res = save_global(self, Py_Ellipsis, str);

  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_EllipsisObject
  00036	4c 8b c0	 mov	 r8, rax
  00039	48 8b cb	 mov	 rcx, rbx
  0003c	e8 00 00 00 00	 call	 save_global

; 2822 :     Py_DECREF(str);

  00041	48 8b cf	 mov	 rcx, rdi
  00044	8b d8		 mov	 ebx, eax
  00046	e8 00 00 00 00	 call	 _Py_DecRef

; 2823 :     return res;

  0004b	8b c3		 mov	 eax, ebx

; 2824 : }

  0004d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
save_ellipsis ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@HCLFFHDH@NotImplemented?$AA@		; `string'
EXTRN	_Py_NotImplementedStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_notimplemented DD imagerel save_notimplemented
	DD	imagerel save_notimplemented+88
	DD	imagerel $unwind$save_notimplemented
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_notimplemented DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0P@HCLFFHDH@NotImplemented?$AA@
CONST	SEGMENT
??_C@_0P@HCLFFHDH@NotImplemented?$AA@ DB 'NotImplemented', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT save_notimplemented
_TEXT	SEGMENT
self$ = 48
save_notimplemented PROC				; COMDAT

; 2828 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 2829 :     PyObject *str = PyUnicode_FromString("NotImplemented");

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@HCLFFHDH@NotImplemented?$AA@
  00014	e8 00 00 00 00	 call	 PyUnicode_FromString
  00019	48 8b f8	 mov	 rdi, rax

; 2830 :     int res;
; 2831 :     if (str == NULL)

  0001c	48 85 c0	 test	 rax, rax
  0001f	75 0e		 jne	 SHORT $LN1@save_notim

; 2832 :         return -1;

  00021	83 c8 ff	 or	 eax, -1

; 2836 : }

  00024	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5f		 pop	 rdi
  0002e	c3		 ret	 0
$LN1@save_notim:

; 2833 :     res = save_global(self, Py_NotImplemented, str);

  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NotImplementedStruct
  00036	4c 8b c0	 mov	 r8, rax
  00039	48 8b cb	 mov	 rcx, rbx
  0003c	e8 00 00 00 00	 call	 save_global

; 2834 :     Py_DECREF(str);

  00041	48 8b cf	 mov	 rcx, rdi
  00044	8b d8		 mov	 ebx, eax
  00046	e8 00 00 00 00	 call	 _Py_DecRef

; 2835 :     return res;

  0004b	8b c3		 mov	 eax, ebx

; 2836 : }

  0004d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
save_notimplemented ENDP
_TEXT	ENDS
EXTRN	PyObject_Str:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$save_pers DD imagerel save_pers
	DD	imagerel save_pers+426
	DD	imagerel $unwind$save_pers
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_pers DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT save_pers
_TEXT	SEGMENT
persid_op$ = 48
size$22383 = 56
self$ = 80
obj$ = 88
func$ = 96
binpersid_op$ = 104
save_pers PROC						; COMDAT

; 2870 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	49 8b e8	 mov	 rbp, r8
  00017	48 8b da	 mov	 rbx, rdx
  0001a	48 8b f1	 mov	 rsi, rcx

; 2871 :     PyObject *pid = NULL;
; 2872 :     int status = 0;

  0001d	33 ff		 xor	 edi, edi

; 2873 : 
; 2874 :     const char persid_op = PERSID;

  0001f	c6 44 24 30 50	 mov	 BYTE PTR persid_op$[rsp], 80 ; 00000050H

; 2875 :     const char binpersid_op = BINPERSID;

  00024	c6 44 24 68 51	 mov	 BYTE PTR binpersid_op$[rsp], 81 ; 00000051H

; 2876 : 
; 2877 :     Py_INCREF(obj);

  00029	e8 00 00 00 00	 call	 _Py_PXCTX
  0002e	85 c0		 test	 eax, eax
  00030	75 32		 jne	 SHORT $LN19@save_pers
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00040	4c 8b cb	 mov	 r9, rbx
  00043	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00049	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00051	e8 00 00 00 00	 call	 _PyParallel_Guard
  00056	85 c0		 test	 eax, eax
  00058	75 06		 jne	 SHORT $LN18@save_pers
  0005a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0005e	74 04		 je	 SHORT $LN19@save_pers
$LN18@save_pers:
  00060	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN19@save_pers:

; 2878 :     pid = _Pickler_FastCall(self, func, obj);

  00064	4c 8b c3	 mov	 r8, rbx
  00067	48 8b d5	 mov	 rdx, rbp
  0006a	48 8b ce	 mov	 rcx, rsi
  0006d	e8 00 00 00 00	 call	 _Pickler_FastCall
  00072	48 8b d8	 mov	 rbx, rax

; 2879 :     if (pid == NULL)

  00075	48 85 c0	 test	 rax, rax
  00078	75 08		 jne	 SHORT $LN15@save_pers

; 2880 :         return -1;

  0007a	83 c8 ff	 or	 eax, -1
  0007d	e9 13 01 00 00	 jmp	 $LN16@save_pers
$LN15@save_pers:

; 2881 : 
; 2882 :     if (pid != Py_None) {

  00082	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00089	48 3b d8	 cmp	 rbx, rax
  0008c	0f 84 9c 00 00
	00		 je	 $LN4@save_pers

; 2883 :         if (self->bin) {

  00092	39 be a4 00 00
	00		 cmp	 DWORD PTR [rsi+164], edi
  00098	74 1e		 je	 SHORT $LN13@save_pers

; 2884 :             if (save(self, pid, 1) < 0 ||
; 2885 :                 _Pickler_Write(self, &binpersid_op, 1) < 0)

  0009a	bf 01 00 00 00	 mov	 edi, 1
  0009f	48 8b d3	 mov	 rdx, rbx
  000a2	48 8b ce	 mov	 rcx, rsi
  000a5	44 8b c7	 mov	 r8d, edi
  000a8	e8 00 00 00 00	 call	 save
  000ad	85 c0		 test	 eax, eax
  000af	78 7a		 js	 SHORT $error$22378
  000b1	48 8d 54 24 68	 lea	 rdx, QWORD PTR binpersid_op$[rsp]

; 2886 :                 goto error;

  000b6	eb 63		 jmp	 SHORT $LN34@save_pers
$LN13@save_pers:

; 2887 :         }
; 2888 :         else {
; 2889 :             PyObject *pid_str = NULL;
; 2890 :             char *pid_ascii_bytes;
; 2891 :             Py_ssize_t size;
; 2892 : 
; 2893 :             pid_str = PyObject_Str(pid);

  000b8	48 8b cb	 mov	 rcx, rbx
  000bb	e8 00 00 00 00	 call	 PyObject_Str
  000c0	48 8b f8	 mov	 rdi, rax

; 2894 :             if (pid_str == NULL)

  000c3	48 85 c0	 test	 rax, rax
  000c6	74 63		 je	 SHORT $error$22378

; 2895 :                 goto error;
; 2896 : 
; 2897 :             /* XXX: Should it check whether the persistent id only contains
; 2898 :                ASCII characters? And what if the pid contains embedded
; 2899 :                newlines? */
; 2900 :             pid_ascii_bytes = _PyUnicode_AsStringAndSize(pid_str, &size);

  000c8	48 8d 54 24 38	 lea	 rdx, QWORD PTR size$22383[rsp]
  000cd	48 8b c8	 mov	 rcx, rax
  000d0	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize

; 2901 :             Py_DECREF(pid_str);

  000d5	48 8b cf	 mov	 rcx, rdi
  000d8	48 8b e8	 mov	 rbp, rax
  000db	e8 00 00 00 00	 call	 _Py_DecRef

; 2902 :             if (pid_ascii_bytes == NULL)

  000e0	48 85 ed	 test	 rbp, rbp
  000e3	74 46		 je	 SHORT $error$22378

; 2903 :                 goto error;
; 2904 : 
; 2905 :             if (_Pickler_Write(self, &persid_op, 1) < 0 ||
; 2906 :                 _Pickler_Write(self, pid_ascii_bytes, size) < 0 ||
; 2907 :                 _Pickler_Write(self, "\n", 1) < 0)

  000e5	bf 01 00 00 00	 mov	 edi, 1
  000ea	48 8d 54 24 30	 lea	 rdx, QWORD PTR persid_op$[rsp]
  000ef	48 8b ce	 mov	 rcx, rsi
  000f2	44 8b c7	 mov	 r8d, edi
  000f5	e8 00 00 00 00	 call	 _Pickler_Write
  000fa	48 85 c0	 test	 rax, rax
  000fd	78 2c		 js	 SHORT $error$22378
  000ff	4c 8b 44 24 38	 mov	 r8, QWORD PTR size$22383[rsp]
  00104	48 8b d5	 mov	 rdx, rbp
  00107	48 8b ce	 mov	 rcx, rsi
  0010a	e8 00 00 00 00	 call	 _Pickler_Write
  0010f	48 85 c0	 test	 rax, rax
  00112	78 17		 js	 SHORT $error$22378
  00114	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
$LN34@save_pers:
  0011b	4c 8b c7	 mov	 r8, rdi
  0011e	48 8b ce	 mov	 rcx, rsi
  00121	e8 00 00 00 00	 call	 _Pickler_Write
  00126	48 85 c0	 test	 rax, rax

; 2908 :                 goto error;
; 2909 :         }
; 2910 :         status = 1;

  00129	79 03		 jns	 SHORT $LN4@save_pers
$error$22378:

; 2911 :     }
; 2912 : 
; 2913 :     if (0) {
; 2914 :   error:
; 2915 :         status = -1;

  0012b	83 cf ff	 or	 edi, -1
$LN4@save_pers:

; 2916 :     }
; 2917 :     Py_XDECREF(pid);

  0012e	e8 00 00 00 00	 call	 _Py_PXCTX
  00133	85 c0		 test	 eax, eax
  00135	75 5c		 jne	 SHORT $LN3@save_pers
  00137	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0013b	a8 20		 test	 al, 32			; 00000020H
  0013d	75 4c		 jne	 SHORT $LN26@save_pers
  0013f	84 c0		 test	 al, al
  00141	78 48		 js	 SHORT $LN26@save_pers
  00143	a8 02		 test	 al, 2
  00145	75 4c		 jne	 SHORT $LN3@save_pers
  00147	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0014b	75 46		 jne	 SHORT $LN3@save_pers
  0014d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00154	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0015b	4c 8b cb	 mov	 r9, rbx
  0015e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00164	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0016c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00171	48 8b cb	 mov	 rcx, rbx
  00174	85 c0		 test	 eax, eax
  00176	74 07		 je	 SHORT $LN31@save_pers
  00178	e8 00 00 00 00	 call	 _Px_Dealloc
  0017d	eb 14		 jmp	 SHORT $LN3@save_pers
$LN31@save_pers:
  0017f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00183	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00189	eb 08		 jmp	 SHORT $LN3@save_pers
$LN26@save_pers:
  0018b	48 8b cb	 mov	 rcx, rbx
  0018e	e8 00 00 00 00	 call	 Px_DecRef
$LN3@save_pers:

; 2918 : 
; 2919 :     return status;

  00193	8b c7		 mov	 eax, edi
$LN16@save_pers:

; 2920 : }

  00195	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0019a	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  0019f	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  001a4	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001a8	5f		 pop	 rdi
  001a9	c3		 ret	 0
save_pers ENDP
_TEXT	ENDS
PUBLIC	??_C@_09LFGACEKG@__class__?$AA@			; `string'
_BSS	SEGMENT
?str_class@?1??get_class@@9@9 DQ 01H DUP (?)		; `get_class'::`2'::str_class
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_class DD imagerel get_class
	DD	imagerel get_class+122
	DD	imagerel $unwind$get_class
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_class DD 043e01H
	DD	06343eH
	DD	070023206H
xdata	ENDS
;	COMDAT ??_C@_09LFGACEKG@__class__?$AA@
CONST	SEGMENT
??_C@_09LFGACEKG@__class__?$AA@ DB '__class__', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT get_class
_TEXT	SEGMENT
obj$ = 48
get_class PROC						; COMDAT

; 2924 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2925 :     PyObject *cls;
; 2926 :     static PyObject *str_class;
; 2927 : 
; 2928 :     if (str_class == NULL) {

  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?str_class@?1??get_class@@9@9
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	48 85 c0	 test	 rax, rax
  00013	75 1e		 jne	 SHORT $LN3@get_class

; 2929 :         str_class = PyUnicode_InternFromString("__class__");

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09LFGACEKG@__class__?$AA@
  0001c	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00021	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?str_class@?1??get_class@@9@9, rax

; 2930 :         if (str_class == NULL)

  00028	48 85 c0	 test	 rax, rax
  0002b	75 06		 jne	 SHORT $LN3@get_class

; 2942 : }

  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5f		 pop	 rdi
  00032	c3		 ret	 0
$LN3@get_class:

; 2931 :             return NULL;
; 2932 :     }
; 2933 :     cls = PyObject_GetAttr(obj, str_class);

  00033	48 8b d0	 mov	 rdx, rax
  00036	48 8b cf	 mov	 rcx, rdi
  00039	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0003e	e8 00 00 00 00	 call	 PyObject_GetAttr
  00043	48 8b d8	 mov	 rbx, rax

; 2934 :     if (cls == NULL) {

  00046	48 85 c0	 test	 rax, rax
  00049	75 21		 jne	 SHORT $LN1@get_class

; 2935 :         if (PyErr_ExceptionMatches(PyExc_AttributeError)) {

  0004b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00052	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00057	85 c0		 test	 eax, eax
  00059	74 11		 je	 SHORT $LN1@get_class

; 2936 :             PyErr_Clear();

  0005b	e8 00 00 00 00	 call	 PyErr_Clear

; 2937 :             cls = (PyObject *) Py_TYPE(obj);

  00060	48 8b 5f 58	 mov	 rbx, QWORD PTR [rdi+88]

; 2938 :             Py_INCREF(cls);

  00064	48 8b cb	 mov	 rcx, rbx
  00067	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@get_class:

; 2939 :         }
; 2940 :     }
; 2941 :     return cls;

  0006c	48 8b c3	 mov	 rax, rbx
  0006f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 2942 : }

  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
get_class ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DP@FFGPPFID@tuple?5returned?5by?5__reduce__?5mus@ ; `string'
PUBLIC	??_C@_0EP@LILNLFGN@fourth?5element?5of?5the?5tuple?5retu@ ; `string'
PUBLIC	??_C@_0EO@IJJFOKCF@fifth?5element?5of?5the?5tuple?5retur@ ; `string'
PUBLIC	??_C@_0DB@LEGKFGN@args?$FL0?$FN?5from?5__newobj__?5args?5has@ ; `string'
PUBLIC	??_C@_0CL@MPICCEHP@args?$FL0?$FN?5from?5__newobj__?5args?5is?5@ ; `string'
PUBLIC	??_C@_0BM@LCDLENIA@__newobj__?5arglist?5is?5empty?$AA@ ; `string'
PUBLIC	??_C@_0L@GEMAGKL@__newobj__?$AA@		; `string'
PUBLIC	??_C@_0EA@DFGACFMJ@second?5item?5of?5the?5tuple?5returne@ ; `string'
PUBLIC	??_C@_0EA@JJGKNCFD@first?5item?5of?5the?5tuple?5returned@ ; `string'
PUBLIC	??_C@_0M@GGIHMHGB@save_reduce?$AA@		; `string'
EXTRN	PyTuple_GetSlice:PROC
EXTRN	PyUnicode_Compare:PROC
EXTRN	_PyObject_NextNotImplemented:PROC
EXTRN	PyCallable_Check:PROC
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_reduce DD imagerel save_reduce
	DD	imagerel save_reduce+1044
	DD	imagerel $unwind$save_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_reduce DD 0a1c01H
	DD	018641cH
	DD	017341cH
	DD	0e012f21cH
	DD	0c00ed010H
	DD	0500b700cH
xdata	ENDS
;	COMDAT ??_C@_0DP@FFGPPFID@tuple?5returned?5by?5__reduce__?5mus@
CONST	SEGMENT
??_C@_0DP@FFGPPFID@tuple?5returned?5by?5__reduce__?5mus@ DB 'tuple return'
	DB	'ed by __reduce__ must contain 2 through 5 elements', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@LILNLFGN@fourth?5element?5of?5the?5tuple?5retu@
CONST	SEGMENT
??_C@_0EP@LILNLFGN@fourth?5element?5of?5the?5tuple?5retu@ DB 'fourth elem'
	DB	'ent of the tuple returned by __reduce__ must be an iterator, '
	DB	'not %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@IJJFOKCF@fifth?5element?5of?5the?5tuple?5retur@
CONST	SEGMENT
??_C@_0EO@IJJFOKCF@fifth?5element?5of?5the?5tuple?5retur@ DB 'fifth eleme'
	DB	'nt of the tuple returned by __reduce__ must be an iterator, n'
	DB	'ot %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LEGKFGN@args?$FL0?$FN?5from?5__newobj__?5args?5has@
CONST	SEGMENT
??_C@_0DB@LEGKFGN@args?$FL0?$FN?5from?5__newobj__?5args?5has@ DB 'args[0]'
	DB	' from __newobj__ args has the wrong class', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MPICCEHP@args?$FL0?$FN?5from?5__newobj__?5args?5is?5@
CONST	SEGMENT
??_C@_0CL@MPICCEHP@args?$FL0?$FN?5from?5__newobj__?5args?5is?5@ DB 'args['
	DB	'0] from __newobj__ args is not a type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LCDLENIA@__newobj__?5arglist?5is?5empty?$AA@
CONST	SEGMENT
??_C@_0BM@LCDLENIA@__newobj__?5arglist?5is?5empty?$AA@ DB '__newobj__ arg'
	DB	'list is empty', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GEMAGKL@__newobj__?$AA@
CONST	SEGMENT
??_C@_0L@GEMAGKL@__newobj__?$AA@ DB '__newobj__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@DFGACFMJ@second?5item?5of?5the?5tuple?5returne@
CONST	SEGMENT
??_C@_0EA@DFGACFMJ@second?5item?5of?5the?5tuple?5returne@ DB 'second item'
	DB	' of the tuple returned by __reduce__ must be a tuple', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@JJGKNCFD@first?5item?5of?5the?5tuple?5returned@
CONST	SEGMENT
??_C@_0EA@JJGKNCFD@first?5item?5of?5the?5tuple?5returned@ DB 'first item '
	DB	'of the tuple returned by __reduce__ must be callable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GGIHMHGB@save_reduce?$AA@
CONST	SEGMENT
??_C@_0M@GGIHMHGB@save_reduce?$AA@ DB 'save_reduce', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT save_reduce
_TEXT	SEGMENT
build_op$ = 80
argtup$ = 88
listitems$ = 96
dictitems$ = 104
state$ = 112
callable$ = 120
newobj_op$ = 176
self$ = 176
args$ = 184
obj$ = 192
reduce_op$ = 200
save_reduce PROC					; COMDAT

; 2949 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	48 8b ec	 mov	 rbp, rsp
  00015	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 2950 :     PyObject *callable;
; 2951 :     PyObject *argtup;
; 2952 :     PyObject *state = NULL;

  0001c	33 db		 xor	 ebx, ebx

; 2953 :     PyObject *listitems = Py_None;
; 2954 :     PyObject *dictitems = Py_None;
; 2955 :     Py_ssize_t size;
; 2956 : 
; 2957 :     int use_newobj = self->proto >= 2;

  0001e	83 b9 a0 00 00
	00 02		 cmp	 DWORD PTR [rcx+160], 2
  00025	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:_Py_NoneStruct
  0002c	48 8b f9	 mov	 rdi, rcx

; 2958 : 
; 2959 :     const char reduce_op = REDUCE;
; 2960 :     const char build_op = BUILD;
; 2961 :     const char newobj_op = NEWOBJ;
; 2962 : 
; 2963 :     size = PyTuple_Size(args);

  0002f	48 8b ca	 mov	 rcx, rdx
  00032	44 8b eb	 mov	 r13d, ebx
  00035	4d 8b e0	 mov	 r12, r8
  00038	48 8b f2	 mov	 rsi, rdx
  0003b	48 89 5d f0	 mov	 QWORD PTR state$[rbp-128], rbx
  0003f	41 0f 9d c5	 setge	 r13b
  00043	4c 89 75 e0	 mov	 QWORD PTR listitems$[rbp-128], r14
  00047	4c 89 75 e8	 mov	 QWORD PTR dictitems$[rbp-128], r14
  0004b	c6 45 48 52	 mov	 BYTE PTR reduce_op$[rbp-128], 82 ; 00000052H
  0004f	c6 45 d0 62	 mov	 BYTE PTR build_op$[rbp-128], 98 ; 00000062H
  00053	c6 45 30 81	 mov	 BYTE PTR newobj_op$[rbp-128], -127 ; ffffffffffffff81H
  00057	e8 00 00 00 00	 call	 PyTuple_Size

; 2964 :     if (size < 2 || size > 5) {

  0005c	48 83 c0 fe	 add	 rax, -2
  00060	48 83 f8 03	 cmp	 rax, 3
  00064	0f 87 78 03 00
	00		 ja	 $LN39@save_reduc

; 2968 :     }
; 2969 : 
; 2970 :     if (!PyArg_UnpackTuple(args, "save_reduce", 2, 5,
; 2971 :                            &callable, &argtup, &state, &listitems, &dictitems))

  0006a	48 8d 45 e8	 lea	 rax, QWORD PTR dictitems$[rbp-128]
  0006e	44 8d 4b 05	 lea	 r9d, QWORD PTR [rbx+5]
  00072	44 8d 43 02	 lea	 r8d, QWORD PTR [rbx+2]
  00076	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0007b	48 8d 45 e0	 lea	 rax, QWORD PTR listitems$[rbp-128]
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GGIHMHGB@save_reduce?$AA@
  00086	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0008b	48 8d 45 f0	 lea	 rax, QWORD PTR state$[rbp-128]
  0008f	48 8b ce	 mov	 rcx, rsi
  00092	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00097	48 8d 45 d8	 lea	 rax, QWORD PTR argtup$[rbp-128]
  0009b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000a0	48 8d 45 f8	 lea	 rax, QWORD PTR callable$[rbp-128]
  000a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a9	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  000ae	85 c0		 test	 eax, eax

; 2972 :         return -1;

  000b0	0f 84 3f 03 00
	00		 je	 $LN46@save_reduc

; 2973 : 
; 2974 :     if (!PyCallable_Check(callable)) {

  000b6	48 8b 4d f8	 mov	 rcx, QWORD PTR callable$[rbp-128]
  000ba	e8 00 00 00 00	 call	 PyCallable_Check
  000bf	85 c0		 test	 eax, eax
  000c1	75 0c		 jne	 SHORT $LN37@save_reduc

; 2975 :         PyErr_SetString(PicklingError, "first item of the tuple "
; 2976 :                         "returned by __reduce__ must be callable");

  000c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EA@JJGKNCFD@first?5item?5of?5the?5tuple?5returned@

; 2977 :         return -1;

  000ca	e9 1a 03 00 00	 jmp	 $LN47@save_reduc
$LN37@save_reduc:

; 2978 :     }
; 2979 :     if (!PyTuple_Check(argtup)) {

  000cf	48 8b 45 d8	 mov	 rax, QWORD PTR argtup$[rbp-128]
  000d3	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000d7	f7 81 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rcx+256], 67108864 ; 04000000H
  000e1	75 0c		 jne	 SHORT $LN36@save_reduc

; 2980 :         PyErr_SetString(PicklingError, "second item of the tuple "
; 2981 :                         "returned by __reduce__ must be a tuple");

  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EA@DFGACFMJ@second?5item?5of?5the?5tuple?5returne@

; 2982 :         return -1;

  000ea	e9 fa 02 00 00	 jmp	 $LN47@save_reduc
$LN36@save_reduc:

; 2983 :     }
; 2984 : 
; 2985 :     if (state == Py_None)

  000ef	48 8b 45 f0	 mov	 rax, QWORD PTR state$[rbp-128]

; 2986 :         state = NULL;
; 2987 : 
; 2988 :     if (listitems == Py_None)

  000f3	4c 8b 45 e0	 mov	 r8, QWORD PTR listitems$[rbp-128]
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyObject_NextNotImplemented
  000fe	49 3b c6	 cmp	 rax, r14
  00101	48 0f 44 c3	 cmove	 rax, rbx
  00105	48 89 45 f0	 mov	 QWORD PTR state$[rbp-128], rax
  00109	4d 3b c6	 cmp	 r8, r14
  0010c	75 06		 jne	 SHORT $LN34@save_reduc

; 2989 :         listitems = NULL;

  0010e	48 89 5d e0	 mov	 QWORD PTR listitems$[rbp-128], rbx
  00112	eb 1d		 jmp	 SHORT $LN32@save_reduc
$LN34@save_reduc:

; 2990 :     else if (!PyIter_Check(listitems)) {

  00114	4d 8b 40 58	 mov	 r8, QWORD PTR [r8+88]
  00118	49 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [r8+312]
  0011f	48 85 c0	 test	 rax, rax
  00122	0f 84 a1 02 00
	00		 je	 $LN31@save_reduc
  00128	48 3b c1	 cmp	 rax, rcx
  0012b	0f 84 98 02 00
	00		 je	 $LN31@save_reduc
$LN32@save_reduc:

; 2995 :     }
; 2996 : 
; 2997 :     if (dictitems == Py_None)

  00131	4c 8b 45 e8	 mov	 r8, QWORD PTR dictitems$[rbp-128]
  00135	4d 3b c6	 cmp	 r8, r14
  00138	75 06		 jne	 SHORT $LN30@save_reduc

; 2998 :         dictitems = NULL;

  0013a	48 89 5d e8	 mov	 QWORD PTR dictitems$[rbp-128], rbx
  0013e	eb 1d		 jmp	 SHORT $LN28@save_reduc
$LN30@save_reduc:

; 2999 :     else if (!PyIter_Check(dictitems)) {

  00140	4d 8b 40 58	 mov	 r8, QWORD PTR [r8+88]
  00144	49 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [r8+312]
  0014b	48 85 c0	 test	 rax, rax
  0014e	0f 84 5c 02 00
	00		 je	 $LN27@save_reduc
  00154	48 3b c1	 cmp	 rax, rcx
  00157	0f 84 53 02 00
	00		 je	 $LN27@save_reduc
$LN28@save_reduc:

; 3004 :     }
; 3005 : 
; 3006 :     /* Protocol 2 special case: if callable's name is __newobj__, use
; 3007 :        NEWOBJ. */
; 3008 :     if (use_newobj) {

  0015d	45 85 ed	 test	 r13d, r13d
  00160	74 7e		 je	 SHORT $LN18@save_reduc

; 3009 :         static PyObject *newobj_str = NULL, *name_str = NULL;
; 3010 :         PyObject *name;
; 3011 : 
; 3012 :         if (newobj_str == NULL) {

  00162	48 39 1d 00 00
	00 00		 cmp	 QWORD PTR ?newobj_str@?7??save_reduce@@9@9, rbx
  00169	75 3d		 jne	 SHORT $LN45@save_reduc

; 3013 :             newobj_str = PyUnicode_InternFromString("__newobj__");

  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@GEMAGKL@__newobj__?$AA@
  00172	e8 00 00 00 00	 call	 PyUnicode_InternFromString

; 3014 :             name_str = PyUnicode_InternFromString("__name__");

  00177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08BHKDPDAA@__name__?$AA@
  0017e	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?newobj_str@?7??save_reduce@@9@9, rax
  00185	e8 00 00 00 00	 call	 PyUnicode_InternFromString

; 3015 :             if (newobj_str == NULL || name_str == NULL)

  0018a	48 39 1d 00 00
	00 00		 cmp	 QWORD PTR ?newobj_str@?7??save_reduce@@9@9, rbx
  00191	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?name_str@?7??save_reduce@@9@9, rax
  00198	0f 84 57 02 00
	00		 je	 $LN46@save_reduc
  0019e	48 85 c0	 test	 rax, rax
  001a1	75 0c		 jne	 SHORT $LN24@save_reduc

; 3016 :                 return -1;

  001a3	e9 4d 02 00 00	 jmp	 $LN46@save_reduc
$LN45@save_reduc:
  001a8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?name_str@?7??save_reduce@@9@9
$LN24@save_reduc:

; 3017 :         }
; 3018 : 
; 3019 :         name = PyObject_GetAttr(callable, name_str);

  001af	48 8b 4d f8	 mov	 rcx, QWORD PTR callable$[rbp-128]
  001b3	48 8b d0	 mov	 rdx, rax
  001b6	e8 00 00 00 00	 call	 PyObject_GetAttr
  001bb	48 8b f0	 mov	 rsi, rax

; 3020 :         if (name == NULL) {

  001be	48 85 c0	 test	 rax, rax
  001c1	0f 85 ea 00 00
	00		 jne	 $LN22@save_reduc

; 3021 :             if (PyErr_ExceptionMatches(PyExc_AttributeError))

  001c7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  001ce	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  001d3	85 c0		 test	 eax, eax
  001d5	0f 84 1a 02 00
	00		 je	 $LN46@save_reduc

; 3022 :                 PyErr_Clear();

  001db	e8 00 00 00 00	 call	 PyErr_Clear
$LN18@save_reduc:

; 3105 :     }
; 3106 :     else { /* Not using NEWOBJ. */
; 3107 :         if (save(self, callable, 0) < 0 ||
; 3108 :             save(self, argtup, 0) < 0 ||
; 3109 :             _Pickler_Write(self, &reduce_op, 1) < 0)

  001e0	48 8b 55 f8	 mov	 rdx, QWORD PTR callable$[rbp-128]
  001e4	45 33 c0	 xor	 r8d, r8d
  001e7	48 8b cf	 mov	 rcx, rdi
  001ea	e8 00 00 00 00	 call	 save
  001ef	85 c0		 test	 eax, eax
  001f1	0f 88 fe 01 00
	00		 js	 $LN46@save_reduc
  001f7	48 8b 55 d8	 mov	 rdx, QWORD PTR argtup$[rbp-128]
  001fb	45 33 c0	 xor	 r8d, r8d
  001fe	48 8b cf	 mov	 rcx, rdi
  00201	e8 00 00 00 00	 call	 save
  00206	85 c0		 test	 eax, eax
  00208	0f 88 e7 01 00
	00		 js	 $LN46@save_reduc
  0020e	48 8d 55 48	 lea	 rdx, QWORD PTR reduce_op$[rbp-128]
  00212	41 b8 01 00 00
	00		 mov	 r8d, 1
  00218	48 8b cf	 mov	 rcx, rdi
  0021b	e8 00 00 00 00	 call	 _Pickler_Write
  00220	48 85 c0	 test	 rax, rax
  00223	0f 88 cc 01 00
	00		 js	 $LN46@save_reduc
$LN8@save_reduc:

; 3110 :             return -1;
; 3111 :     }
; 3112 : 
; 3113 :     /* obj can be NULL when save_reduce() is used directly. A NULL obj means
; 3114 :        the caller do not want to memoize the object. Not particularly useful,
; 3115 :        but that is to mimic the behavior save_reduce() in pickle.py when
; 3116 :        obj is None. */
; 3117 :     if (obj && memo_put(self, obj) < 0)

  00229	4d 85 e4	 test	 r12, r12
  0022c	74 13		 je	 SHORT $LN6@save_reduc
  0022e	49 8b d4	 mov	 rdx, r12
  00231	48 8b cf	 mov	 rcx, rdi
  00234	e8 00 00 00 00	 call	 memo_put
  00239	85 c0		 test	 eax, eax

; 3118 :         return -1;

  0023b	0f 88 b4 01 00
	00		 js	 $LN46@save_reduc
$LN6@save_reduc:

; 3119 : 
; 3120 :     if (listitems && batch_list(self, listitems) < 0)

  00241	48 8b 55 e0	 mov	 rdx, QWORD PTR listitems$[rbp-128]
  00245	48 85 d2	 test	 rdx, rdx
  00248	74 10		 je	 SHORT $LN5@save_reduc
  0024a	48 8b cf	 mov	 rcx, rdi
  0024d	e8 00 00 00 00	 call	 batch_list
  00252	85 c0		 test	 eax, eax

; 3121 :         return -1;

  00254	0f 88 9b 01 00
	00		 js	 $LN46@save_reduc
$LN5@save_reduc:

; 3122 : 
; 3123 :     if (dictitems && batch_dict(self, dictitems) < 0)

  0025a	48 8b 55 e8	 mov	 rdx, QWORD PTR dictitems$[rbp-128]
  0025e	48 85 d2	 test	 rdx, rdx
  00261	74 10		 je	 SHORT $LN4@save_reduc
  00263	48 8b cf	 mov	 rcx, rdi
  00266	e8 00 00 00 00	 call	 batch_dict
  0026b	85 c0		 test	 eax, eax

; 3124 :         return -1;

  0026d	0f 88 82 01 00
	00		 js	 $LN46@save_reduc
$LN4@save_reduc:

; 3125 : 
; 3126 :     if (state) {

  00273	48 8b 55 f0	 mov	 rdx, QWORD PTR state$[rbp-128]
  00277	48 85 d2	 test	 rdx, rdx
  0027a	74 2e		 je	 SHORT $LN2@save_reduc

; 3127 :         if (save(self, state, 0) < 0 ||
; 3128 :             _Pickler_Write(self, &build_op, 1) < 0)

  0027c	45 33 c0	 xor	 r8d, r8d
  0027f	48 8b cf	 mov	 rcx, rdi
  00282	e8 00 00 00 00	 call	 save
  00287	85 c0		 test	 eax, eax
  00289	0f 88 66 01 00
	00		 js	 $LN46@save_reduc
  0028f	48 8d 55 d0	 lea	 rdx, QWORD PTR build_op$[rbp-128]
  00293	41 b8 01 00 00
	00		 mov	 r8d, 1
  00299	48 8b cf	 mov	 rcx, rdi
  0029c	e8 00 00 00 00	 call	 _Pickler_Write
  002a1	48 85 c0	 test	 rax, rax

; 3129 :             return -1;

  002a4	0f 88 4b 01 00
	00		 js	 $LN46@save_reduc
$LN2@save_reduc:

; 3130 :     }
; 3131 : 
; 3132 :     return 0;

  002aa	33 c0		 xor	 eax, eax
  002ac	e9 47 01 00 00	 jmp	 $LN41@save_reduc
$LN22@save_reduc:

; 3023 :             else
; 3024 :                 return -1;
; 3025 :             use_newobj = 0;
; 3026 :         }
; 3027 :         else {
; 3028 :             use_newobj = PyUnicode_Check(name) &&
; 3029 :                          PyUnicode_Compare(name, newobj_str) == 0;

  002b1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002b5	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  002bf	74 16		 je	 SHORT $LN43@save_reduc
  002c1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?newobj_str@?7??save_reduce@@9@9
  002c8	48 8b ce	 mov	 rcx, rsi
  002cb	e8 00 00 00 00	 call	 PyUnicode_Compare
  002d0	85 c0		 test	 eax, eax
  002d2	75 03		 jne	 SHORT $LN43@save_reduc
  002d4	8d 58 01	 lea	 ebx, QWORD PTR [rax+1]
$LN43@save_reduc:

; 3030 :             Py_DECREF(name);

  002d7	48 8b ce	 mov	 rcx, rsi
  002da	e8 00 00 00 00	 call	 _Py_DecRef

; 3031 :         }
; 3032 :     }
; 3033 :     if (use_newobj) {

  002df	85 db		 test	 ebx, ebx
  002e1	0f 84 f9 fe ff
	ff		 je	 $LN18@save_reduc

; 3034 :         PyObject *cls;
; 3035 :         PyObject *newargtup;
; 3036 :         PyObject *obj_class;
; 3037 :         int p;
; 3038 : 
; 3039 :         /* Sanity checks. */
; 3040 :         if (Py_SIZE(argtup) < 1) {

  002e7	48 8b 75 d8	 mov	 rsi, QWORD PTR argtup$[rbp-128]
  002eb	48 83 7e 60 01	 cmp	 QWORD PTR [rsi+96], 1
  002f0	7d 0c		 jge	 SHORT $LN17@save_reduc

; 3041 :             PyErr_SetString(PicklingError, "__newobj__ arglist is empty");

  002f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@LCDLENIA@__newobj__?5arglist?5is?5empty?$AA@

; 3042 :             return -1;

  002f9	e9 eb 00 00 00	 jmp	 $LN47@save_reduc
$LN17@save_reduc:

; 3043 :         }
; 3044 : 
; 3045 :         cls = PyTuple_GET_ITEM(argtup, 0);

  002fe	48 8b 76 70	 mov	 rsi, QWORD PTR [rsi+112]

; 3046 :         if (!PyType_Check(cls)) {

  00302	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00306	f7 80 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rax+256], -2147483648 ; ffffffff80000000H
  00310	75 0c		 jne	 SHORT $LN16@save_reduc

; 3047 :             PyErr_SetString(PicklingError, "args[0] from "
; 3048 :                             "__newobj__ args is not a type");

  00312	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@MPICCEHP@args?$FL0?$FN?5from?5__newobj__?5args?5is?5@

; 3049 :             return -1;

  00319	e9 cb 00 00 00	 jmp	 $LN47@save_reduc
$LN16@save_reduc:

; 3050 :         }
; 3051 : 
; 3052 :         if (obj != NULL) {

  0031e	4d 85 e4	 test	 r12, r12
  00321	74 24		 je	 SHORT $LN14@save_reduc

; 3053 :             obj_class = get_class(obj);

  00323	49 8b cc	 mov	 rcx, r12
  00326	e8 00 00 00 00	 call	 get_class

; 3054 :             p = obj_class != cls;    /* true iff a problem */
; 3055 :             Py_DECREF(obj_class);

  0032b	48 8b c8	 mov	 rcx, rax
  0032e	48 8b d8	 mov	 rbx, rax
  00331	e8 00 00 00 00	 call	 _Py_DecRef
  00336	48 3b de	 cmp	 rbx, rsi

; 3056 :             if (p) {

  00339	74 0c		 je	 SHORT $LN14@save_reduc

; 3057 :                 PyErr_SetString(PicklingError, "args[0] from "
; 3058 :                                 "__newobj__ args has the wrong class");

  0033b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@LEGKFGN@args?$FL0?$FN?5from?5__newobj__?5args?5has@

; 3059 :                 return -1;

  00342	e9 a2 00 00 00	 jmp	 $LN47@save_reduc
$LN14@save_reduc:

; 3060 :             }
; 3061 :         }
; 3062 :         /* XXX: These calls save() are prone to infinite recursion. Imagine
; 3063 :            what happen if the value returned by the __reduce__() method of
; 3064 :            some extension type contains another object of the same type. Ouch!
; 3065 : 
; 3066 :            Here is a quick example, that I ran into, to illustrate what I
; 3067 :            mean:
; 3068 : 
; 3069 :              >>> import pickle, copyreg
; 3070 :              >>> copyreg.dispatch_table.pop(complex)
; 3071 :              >>> pickle.dumps(1+2j)
; 3072 :              Traceback (most recent call last):
; 3073 :                ...
; 3074 :              RuntimeError: maximum recursion depth exceeded
; 3075 : 
; 3076 :            Removing the complex class from copyreg.dispatch_table made the
; 3077 :            __reduce_ex__() method emit another complex object:
; 3078 : 
; 3079 :              >>> (1+1j).__reduce_ex__(2)
; 3080 :              (<function __newobj__ at 0xb7b71c3c>,
; 3081 :                (<class 'complex'>, (1+1j)), None, None, None)
; 3082 : 
; 3083 :            Thus when save() was called on newargstup (the 2nd item) recursion
; 3084 :            ensued. Of course, the bug was in the complex class which had a
; 3085 :            broken __getnewargs__() that emitted another complex object. But,
; 3086 :            the point, here, is it is quite easy to end up with a broken reduce
; 3087 :            function. */
; 3088 : 
; 3089 :         /* Save the class and its __new__ arguments. */
; 3090 :         if (save(self, cls, 0) < 0)

  00347	45 33 c0	 xor	 r8d, r8d
  0034a	48 8b d6	 mov	 rdx, rsi
  0034d	48 8b cf	 mov	 rcx, rdi
  00350	e8 00 00 00 00	 call	 save
  00355	85 c0		 test	 eax, eax

; 3091 :             return -1;

  00357	0f 88 98 00 00
	00		 js	 $LN46@save_reduc

; 3092 : 
; 3093 :         newargtup = PyTuple_GetSlice(argtup, 1, Py_SIZE(argtup));

  0035d	48 8b 4d d8	 mov	 rcx, QWORD PTR argtup$[rbp-128]
  00361	ba 01 00 00 00	 mov	 edx, 1
  00366	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  0036a	e8 00 00 00 00	 call	 PyTuple_GetSlice
  0036f	48 8b f0	 mov	 rsi, rax

; 3094 :         if (newargtup == NULL)

  00372	48 85 c0	 test	 rax, rax

; 3095 :             return -1;

  00375	74 7e		 je	 SHORT $LN46@save_reduc

; 3096 : 
; 3097 :         p = save(self, newargtup, 0);

  00377	45 33 c0	 xor	 r8d, r8d
  0037a	48 8b d0	 mov	 rdx, rax
  0037d	48 8b cf	 mov	 rcx, rdi
  00380	e8 00 00 00 00	 call	 save

; 3098 :         Py_DECREF(newargtup);

  00385	48 8b ce	 mov	 rcx, rsi
  00388	8b d8		 mov	 ebx, eax
  0038a	e8 00 00 00 00	 call	 _Py_DecRef

; 3099 :         if (p < 0)

  0038f	85 db		 test	 ebx, ebx

; 3100 :             return -1;

  00391	78 62		 js	 SHORT $LN46@save_reduc

; 3101 : 
; 3102 :         /* Add NEWOBJ opcode. */
; 3103 :         if (_Pickler_Write(self, &newobj_op, 1) < 0)

  00393	48 8d 55 30	 lea	 rdx, QWORD PTR newobj_op$[rbp-128]
  00397	41 b8 01 00 00
	00		 mov	 r8d, 1
  0039d	48 8b cf	 mov	 rcx, rdi
  003a0	e8 00 00 00 00	 call	 _Pickler_Write
  003a5	48 85 c0	 test	 rax, rax
  003a8	0f 89 7b fe ff
	ff		 jns	 $LN8@save_reduc

; 3104 :             return -1;

  003ae	eb 45		 jmp	 SHORT $LN46@save_reduc
$LN27@save_reduc:

; 3000 :         PyErr_Format(PicklingError, "fifth element of the tuple "
; 3001 :                      "returned by __reduce__ must be an iterator, not %s",
; 3002 :                      Py_TYPE(dictitems)->tp_name);

  003b0	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  003b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  003bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EO@IJJFOKCF@fifth?5element?5of?5the?5tuple?5retur@
  003c2	e8 00 00 00 00	 call	 PyErr_Format

; 3003 :         return -1;

  003c7	eb 2c		 jmp	 SHORT $LN46@save_reduc
$LN31@save_reduc:

; 2991 :         PyErr_Format(PicklingError, "fourth element of the tuple "
; 2992 :                      "returned by __reduce__ must be an iterator, not %s",
; 2993 :                      Py_TYPE(listitems)->tp_name);

  003c9	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  003cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  003d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EP@LILNLFGN@fourth?5element?5of?5the?5tuple?5retu@
  003db	e8 00 00 00 00	 call	 PyErr_Format

; 2994 :         return -1;

  003e0	eb 13		 jmp	 SHORT $LN46@save_reduc
$LN39@save_reduc:

; 2965 :         PyErr_SetString(PicklingError, "tuple returned by "
; 2966 :                         "__reduce__ must contain 2 through 5 elements");

  003e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DP@FFGPPFID@tuple?5returned?5by?5__reduce__?5mus@
$LN47@save_reduc:
  003e9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  003f0	e8 00 00 00 00	 call	 PyErr_SetString
$LN46@save_reduc:

; 2967 :         return -1;

  003f5	83 c8 ff	 or	 eax, -1
$LN41@save_reduc:

; 3133 : }

  003f8	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  00400	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00404	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  00408	49 8b e3	 mov	 rsp, r11
  0040b	41 5e		 pop	 r14
  0040d	41 5d		 pop	 r13
  0040f	41 5c		 pop	 r12
  00411	5f		 pop	 rdi
  00412	5d		 pop	 rbp
  00413	c3		 ret	 0
save_reduce ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$Pickler_clear_memo DD imagerel Pickler_clear_memo
	DD	imagerel Pickler_clear_memo+125
	DD	imagerel $unwind$Pickler_clear_memo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_clear_memo DD 031701H
	DD	063417H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT Pickler_clear_memo
_TEXT	SEGMENT
self$ = 64
Pickler_clear_memo PROC					; COMDAT

; 3377 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3378 :     if (self->memo)

  00004	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00008	48 85 c9	 test	 rcx, rcx
  0000b	74 05		 je	 SHORT $LN1@Pickler_cl

; 3379 :         PyMemoTable_Clear(self->memo);

  0000d	e8 00 00 00 00	 call	 PyMemoTable_Clear
$LN1@Pickler_cl:
  00012	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 3380 : 
; 3381 :     Py_RETURN_NONE;

  00017	e8 00 00 00 00	 call	 _Py_PXCTX
  0001c	85 c0		 test	 eax, eax
  0001e	75 4c		 jne	 SHORT $LN8@Pickler_cl
  00020	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00035	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0003b	4c 8b cb	 mov	 r9, rbx
  0003e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00046	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004b	85 c0		 test	 eax, eax
  0004d	75 09		 jne	 SHORT $LN4@Pickler_cl
  0004f	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00056	74 07		 je	 SHORT $LN10@Pickler_cl
$LN4@Pickler_cl:
  00058	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN10@Pickler_cl:
  0005f	48 8b c3	 mov	 rax, rbx
  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 3382 : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
$LN8@Pickler_cl:

; 3380 : 
; 3381 :     Py_RETURN_NONE;

  0006c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00073	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 3382 : }

  00078	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007c	c3		 ret	 0
Pickler_clear_memo ENDP
_TEXT	ENDS
EXTRN	PyObject_GC_UnTrack:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$Pickler_dealloc DD imagerel Pickler_dealloc
	DD	imagerel Pickler_dealloc+720
	DD	imagerel $unwind$Pickler_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT Pickler_dealloc
_TEXT	SEGMENT
self$ = 64
Pickler_dealloc PROC					; COMDAT

; 3427 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 3428 :     PyObject_GC_UnTrack(self);

  0000d	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 3429 : 
; 3430 :     Py_XDECREF(self->output_buffer);

  00012	48 8b 9f 88 00
	00 00		 mov	 rbx, QWORD PTR [rdi+136]
  00019	48 85 db	 test	 rbx, rbx
  0001c	74 65		 je	 SHORT $LN23@Pickler_de
  0001e	e8 00 00 00 00	 call	 _Py_PXCTX
  00023	85 c0		 test	 eax, eax
  00025	75 5c		 jne	 SHORT $LN23@Pickler_de
  00027	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0002b	a8 20		 test	 al, 32			; 00000020H
  0002d	75 4c		 jne	 SHORT $LN31@Pickler_de
  0002f	84 c0		 test	 al, al
  00031	78 48		 js	 SHORT $LN31@Pickler_de
  00033	a8 02		 test	 al, 2
  00035	75 4c		 jne	 SHORT $LN23@Pickler_de
  00037	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0003b	75 46		 jne	 SHORT $LN23@Pickler_de
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0004b	4c 8b cb	 mov	 r9, rbx
  0004e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00054	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0005c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00061	48 8b cb	 mov	 rcx, rbx
  00064	85 c0		 test	 eax, eax
  00066	74 07		 je	 SHORT $LN36@Pickler_de
  00068	e8 00 00 00 00	 call	 _Px_Dealloc
  0006d	eb 14		 jmp	 SHORT $LN23@Pickler_de
$LN36@Pickler_de:
  0006f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00073	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00079	eb 08		 jmp	 SHORT $LN23@Pickler_de
$LN31@Pickler_de:
  0007b	48 8b cb	 mov	 rcx, rbx
  0007e	e8 00 00 00 00	 call	 Px_DecRef
$LN23@Pickler_de:

; 3431 :     Py_XDECREF(self->write);

  00083	48 8b 9f 80 00
	00 00		 mov	 rbx, QWORD PTR [rdi+128]
  0008a	48 85 db	 test	 rbx, rbx
  0008d	74 65		 je	 SHORT $LN19@Pickler_de
  0008f	e8 00 00 00 00	 call	 _Py_PXCTX
  00094	85 c0		 test	 eax, eax
  00096	75 5c		 jne	 SHORT $LN19@Pickler_de
  00098	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0009c	a8 20		 test	 al, 32			; 00000020H
  0009e	75 4c		 jne	 SHORT $LN42@Pickler_de
  000a0	84 c0		 test	 al, al
  000a2	78 48		 js	 SHORT $LN42@Pickler_de
  000a4	a8 02		 test	 al, 2
  000a6	75 4c		 jne	 SHORT $LN19@Pickler_de
  000a8	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000ac	75 46		 jne	 SHORT $LN19@Pickler_de
  000ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000bc	4c 8b cb	 mov	 r9, rbx
  000bf	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000c5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000cd	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d2	48 8b cb	 mov	 rcx, rbx
  000d5	85 c0		 test	 eax, eax
  000d7	74 07		 je	 SHORT $LN47@Pickler_de
  000d9	e8 00 00 00 00	 call	 _Px_Dealloc
  000de	eb 14		 jmp	 SHORT $LN19@Pickler_de
$LN47@Pickler_de:
  000e0	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000e4	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000ea	eb 08		 jmp	 SHORT $LN19@Pickler_de
$LN42@Pickler_de:
  000ec	48 8b cb	 mov	 rcx, rbx
  000ef	e8 00 00 00 00	 call	 Px_DecRef
$LN19@Pickler_de:

; 3432 :     Py_XDECREF(self->pers_func);

  000f4	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
  000f8	48 85 db	 test	 rbx, rbx
  000fb	74 65		 je	 SHORT $LN15@Pickler_de
  000fd	e8 00 00 00 00	 call	 _Py_PXCTX
  00102	85 c0		 test	 eax, eax
  00104	75 5c		 jne	 SHORT $LN15@Pickler_de
  00106	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0010a	a8 20		 test	 al, 32			; 00000020H
  0010c	75 4c		 jne	 SHORT $LN53@Pickler_de
  0010e	84 c0		 test	 al, al
  00110	78 48		 js	 SHORT $LN53@Pickler_de
  00112	a8 02		 test	 al, 2
  00114	75 4c		 jne	 SHORT $LN15@Pickler_de
  00116	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0011a	75 46		 jne	 SHORT $LN15@Pickler_de
  0011c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0012a	4c 8b cb	 mov	 r9, rbx
  0012d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00133	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0013b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00140	48 8b cb	 mov	 rcx, rbx
  00143	85 c0		 test	 eax, eax
  00145	74 07		 je	 SHORT $LN58@Pickler_de
  00147	e8 00 00 00 00	 call	 _Px_Dealloc
  0014c	eb 14		 jmp	 SHORT $LN15@Pickler_de
$LN58@Pickler_de:
  0014e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00152	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00158	eb 08		 jmp	 SHORT $LN15@Pickler_de
$LN53@Pickler_de:
  0015a	48 8b cb	 mov	 rcx, rbx
  0015d	e8 00 00 00 00	 call	 Px_DecRef
$LN15@Pickler_de:

; 3433 :     Py_XDECREF(self->dispatch_table);

  00162	48 8b 5f 70	 mov	 rbx, QWORD PTR [rdi+112]
  00166	48 85 db	 test	 rbx, rbx
  00169	74 65		 je	 SHORT $LN11@Pickler_de
  0016b	e8 00 00 00 00	 call	 _Py_PXCTX
  00170	85 c0		 test	 eax, eax
  00172	75 5c		 jne	 SHORT $LN11@Pickler_de
  00174	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00178	a8 20		 test	 al, 32			; 00000020H
  0017a	75 4c		 jne	 SHORT $LN64@Pickler_de
  0017c	84 c0		 test	 al, al
  0017e	78 48		 js	 SHORT $LN64@Pickler_de
  00180	a8 02		 test	 al, 2
  00182	75 4c		 jne	 SHORT $LN11@Pickler_de
  00184	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00188	75 46		 jne	 SHORT $LN11@Pickler_de
  0018a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00191	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00198	4c 8b cb	 mov	 r9, rbx
  0019b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001a1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001a9	e8 00 00 00 00	 call	 _PyParallel_Guard
  001ae	48 8b cb	 mov	 rcx, rbx
  001b1	85 c0		 test	 eax, eax
  001b3	74 07		 je	 SHORT $LN69@Pickler_de
  001b5	e8 00 00 00 00	 call	 _Px_Dealloc
  001ba	eb 14		 jmp	 SHORT $LN11@Pickler_de
$LN69@Pickler_de:
  001bc	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001c0	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001c6	eb 08		 jmp	 SHORT $LN11@Pickler_de
$LN64@Pickler_de:
  001c8	48 8b cb	 mov	 rcx, rbx
  001cb	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Pickler_de:

; 3434 :     Py_XDECREF(self->arg);

  001d0	48 8b 5f 78	 mov	 rbx, QWORD PTR [rdi+120]
  001d4	48 85 db	 test	 rbx, rbx
  001d7	74 65		 je	 SHORT $LN7@Pickler_de
  001d9	e8 00 00 00 00	 call	 _Py_PXCTX
  001de	85 c0		 test	 eax, eax
  001e0	75 5c		 jne	 SHORT $LN7@Pickler_de
  001e2	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001e6	a8 20		 test	 al, 32			; 00000020H
  001e8	75 4c		 jne	 SHORT $LN75@Pickler_de
  001ea	84 c0		 test	 al, al
  001ec	78 48		 js	 SHORT $LN75@Pickler_de
  001ee	a8 02		 test	 al, 2
  001f0	75 4c		 jne	 SHORT $LN7@Pickler_de
  001f2	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001f6	75 46		 jne	 SHORT $LN7@Pickler_de
  001f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00206	4c 8b cb	 mov	 r9, rbx
  00209	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0020f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00217	e8 00 00 00 00	 call	 _PyParallel_Guard
  0021c	48 8b cb	 mov	 rcx, rbx
  0021f	85 c0		 test	 eax, eax
  00221	74 07		 je	 SHORT $LN80@Pickler_de
  00223	e8 00 00 00 00	 call	 _Px_Dealloc
  00228	eb 14		 jmp	 SHORT $LN7@Pickler_de
$LN80@Pickler_de:
  0022a	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0022e	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00234	eb 08		 jmp	 SHORT $LN7@Pickler_de
$LN75@Pickler_de:
  00236	48 8b cb	 mov	 rcx, rbx
  00239	e8 00 00 00 00	 call	 Px_DecRef
$LN7@Pickler_de:

; 3435 :     Py_XDECREF(self->fast_memo);

  0023e	48 8b 9f c0 00
	00 00		 mov	 rbx, QWORD PTR [rdi+192]
  00245	48 85 db	 test	 rbx, rbx
  00248	74 65		 je	 SHORT $LN3@Pickler_de
  0024a	e8 00 00 00 00	 call	 _Py_PXCTX
  0024f	85 c0		 test	 eax, eax
  00251	75 5c		 jne	 SHORT $LN3@Pickler_de
  00253	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00257	a8 20		 test	 al, 32			; 00000020H
  00259	75 4c		 jne	 SHORT $LN86@Pickler_de
  0025b	84 c0		 test	 al, al
  0025d	78 48		 js	 SHORT $LN86@Pickler_de
  0025f	a8 02		 test	 al, 2
  00261	75 4c		 jne	 SHORT $LN3@Pickler_de
  00263	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00267	75 46		 jne	 SHORT $LN3@Pickler_de
  00269	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00270	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00277	4c 8b cb	 mov	 r9, rbx
  0027a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00280	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00288	e8 00 00 00 00	 call	 _PyParallel_Guard
  0028d	48 8b cb	 mov	 rcx, rbx
  00290	85 c0		 test	 eax, eax
  00292	74 07		 je	 SHORT $LN91@Pickler_de
  00294	e8 00 00 00 00	 call	 _Px_Dealloc
  00299	eb 14		 jmp	 SHORT $LN3@Pickler_de
$LN91@Pickler_de:
  0029b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0029f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002a5	eb 08		 jmp	 SHORT $LN3@Pickler_de
$LN86@Pickler_de:
  002a7	48 8b cb	 mov	 rcx, rbx
  002aa	e8 00 00 00 00	 call	 Px_DecRef
$LN3@Pickler_de:

; 3436 : 
; 3437 :     PyMemoTable_Del(self->memo);

  002af	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  002b3	e8 00 00 00 00	 call	 PyMemoTable_Del

; 3438 : 
; 3439 :     Py_TYPE(self)->tp_free((PyObject *)self);

  002b8	4c 8b 5f 58	 mov	 r11, QWORD PTR [rdi+88]
  002bc	48 8b cf	 mov	 rcx, rdi

; 3440 : }

  002bf	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  002c4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002c8	5f		 pop	 rdi
  002c9	49 ff a3 98 01
	00 00		 rex_jmp QWORD PTR [r11+408]
Pickler_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@KPCLNAPO@Pickler_traverse?$AA@	; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pickler_traverse DD imagerel Pickler_traverse
	DD	imagerel Pickler_traverse+331
	DD	imagerel $unwind$Pickler_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BB@KPCLNAPO@Pickler_traverse?$AA@
CONST	SEGMENT
??_C@_0BB@KPCLNAPO@Pickler_traverse?$AA@ DB 'Pickler_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT Pickler_traverse
_TEXT	SEGMENT
self$ = 48
visit$ = 56
arg$ = 64
Pickler_traverse PROC					; COMDAT

; 3444 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 3445 :     Py_VISIT(self->write);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN27@Pickler_tr
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KPCLNAPO@Pickler_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 75 0d 00
	00		 mov	 r8d, 3445		; 00000d75H
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN27@Pickler_tr:
  0003d	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00044	48 85 c9	 test	 rcx, rcx
  00047	74 0d		 je	 SHORT $LN29@Pickler_tr
  00049	48 8b d7	 mov	 rdx, rdi
  0004c	ff d6		 call	 rsi
  0004e	85 c0		 test	 eax, eax
  00050	0f 85 e5 00 00
	00		 jne	 $LN31@Pickler_tr
$LN29@Pickler_tr:

; 3446 :     Py_VISIT(self->pers_func);

  00056	e8 00 00 00 00	 call	 _Py_PXCTX
  0005b	85 c0		 test	 eax, eax
  0005d	74 1c		 je	 SHORT $LN21@Pickler_tr
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KPCLNAPO@Pickler_traverse?$AA@
  0006d	45 33 c9	 xor	 r9d, r9d
  00070	41 b8 76 0d 00
	00		 mov	 r8d, 3446		; 00000d76H
  00076	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN21@Pickler_tr:
  0007b	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  0007f	48 85 c9	 test	 rcx, rcx
  00082	74 0d		 je	 SHORT $LN23@Pickler_tr
  00084	48 8b d7	 mov	 rdx, rdi
  00087	ff d6		 call	 rsi
  00089	85 c0		 test	 eax, eax
  0008b	0f 85 aa 00 00
	00		 jne	 $LN31@Pickler_tr
$LN23@Pickler_tr:

; 3447 :     Py_VISIT(self->dispatch_table);

  00091	e8 00 00 00 00	 call	 _Py_PXCTX
  00096	85 c0		 test	 eax, eax
  00098	74 1c		 je	 SHORT $LN15@Pickler_tr
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KPCLNAPO@Pickler_traverse?$AA@
  000a8	45 33 c9	 xor	 r9d, r9d
  000ab	41 b8 77 0d 00
	00		 mov	 r8d, 3447		; 00000d77H
  000b1	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN15@Pickler_tr:
  000b6	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  000ba	48 85 c9	 test	 rcx, rcx
  000bd	74 09		 je	 SHORT $LN17@Pickler_tr
  000bf	48 8b d7	 mov	 rdx, rdi
  000c2	ff d6		 call	 rsi
  000c4	85 c0		 test	 eax, eax
  000c6	75 73		 jne	 SHORT $LN31@Pickler_tr
$LN17@Pickler_tr:

; 3448 :     Py_VISIT(self->arg);

  000c8	e8 00 00 00 00	 call	 _Py_PXCTX
  000cd	85 c0		 test	 eax, eax
  000cf	74 1c		 je	 SHORT $LN9@Pickler_tr
  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KPCLNAPO@Pickler_traverse?$AA@
  000df	45 33 c9	 xor	 r9d, r9d
  000e2	41 b8 78 0d 00
	00		 mov	 r8d, 3448		; 00000d78H
  000e8	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@Pickler_tr:
  000ed	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  000f1	48 85 c9	 test	 rcx, rcx
  000f4	74 09		 je	 SHORT $LN11@Pickler_tr
  000f6	48 8b d7	 mov	 rdx, rdi
  000f9	ff d6		 call	 rsi
  000fb	85 c0		 test	 eax, eax
  000fd	75 3c		 jne	 SHORT $LN31@Pickler_tr
$LN11@Pickler_tr:

; 3449 :     Py_VISIT(self->fast_memo);

  000ff	e8 00 00 00 00	 call	 _Py_PXCTX
  00104	85 c0		 test	 eax, eax
  00106	74 1c		 je	 SHORT $LN3@Pickler_tr
  00108	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0010f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KPCLNAPO@Pickler_traverse?$AA@
  00116	45 33 c9	 xor	 r9d, r9d
  00119	41 b8 79 0d 00
	00		 mov	 r8d, 3449		; 00000d79H
  0011f	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@Pickler_tr:
  00124	48 8b 8b c0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+192]
  0012b	48 85 c9	 test	 rcx, rcx
  0012e	74 09		 je	 SHORT $LN5@Pickler_tr
  00130	48 8b d7	 mov	 rdx, rdi
  00133	ff d6		 call	 rsi
  00135	85 c0		 test	 eax, eax
  00137	75 02		 jne	 SHORT $LN31@Pickler_tr
$LN5@Pickler_tr:

; 3450 :     return 0;

  00139	33 c0		 xor	 eax, eax
$LN31@Pickler_tr:

; 3451 : }

  0013b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00140	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00145	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00149	5f		 pop	 rdi
  0014a	c3		 ret	 0
Pickler_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@MAJBEHNL@Pickler_clear?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$Pickler_clear DD imagerel Pickler_clear
	DD	imagerel Pickler_clear+19
	DD	imagerel $unwind$Pickler_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$Pickler_clear DD imagerel Pickler_clear+19
	DD	imagerel Pickler_clear+1015
	DD	imagerel $chain$0$Pickler_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$Pickler_clear DD imagerel Pickler_clear+1015
	DD	imagerel Pickler_clear+1037
	DD	imagerel $chain$1$Pickler_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$Pickler_clear DD 021H
	DD	imagerel Pickler_clear
	DD	imagerel Pickler_clear+19
	DD	imagerel $unwind$Pickler_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$Pickler_clear DD 020521H
	DD	083405H
	DD	imagerel Pickler_clear
	DD	imagerel Pickler_clear+19
	DD	imagerel $unwind$Pickler_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_clear DD 040a01H
	DD	09640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0O@MAJBEHNL@Pickler_clear?$AA@
CONST	SEGMENT
??_C@_0O@MAJBEHNL@Pickler_clear?$AA@ DB 'Pickler_clear', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT Pickler_clear
_TEXT	SEGMENT
self$ = 64
Pickler_clear PROC					; COMDAT

; 3455 : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3456 :     Py_CLEAR(self->output_buffer);

  0000a	4c 8b 89 88 00
	00 00		 mov	 r9, QWORD PTR [rcx+136]
  00011	33 f6		 xor	 esi, esi
  00013	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	4d 85 c9	 test	 r9, r9
  0001e	0f 84 98 00 00
	00		 je	 $LN24@Pickler_cl@2
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MAJBEHNL@Pickler_clear?$AA@
  00032	41 b8 80 0d 00
	00		 mov	 r8d, 3456		; 00000d80H
  00038	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00040	e8 00 00 00 00	 call	 _PyParallel_Guard
  00045	85 c0		 test	 eax, eax
  00047	75 73		 jne	 SHORT $LN24@Pickler_cl@2
  00049	48 8b 9f 88 00
	00 00		 mov	 rbx, QWORD PTR [rdi+136]
  00050	48 89 b7 88 00
	00 00		 mov	 QWORD PTR [rdi+136], rsi
  00057	e8 00 00 00 00	 call	 _Py_PXCTX
  0005c	85 c0		 test	 eax, eax
  0005e	75 5c		 jne	 SHORT $LN24@Pickler_cl@2
  00060	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00064	a8 20		 test	 al, 32			; 00000020H
  00066	75 4c		 jne	 SHORT $LN32@Pickler_cl@2
  00068	84 c0		 test	 al, al
  0006a	78 48		 js	 SHORT $LN32@Pickler_cl@2
  0006c	a8 02		 test	 al, 2
  0006e	75 4c		 jne	 SHORT $LN24@Pickler_cl@2
  00070	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00074	75 46		 jne	 SHORT $LN24@Pickler_cl@2
  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00084	4c 8b cb	 mov	 r9, rbx
  00087	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0008d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00095	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009a	48 8b cb	 mov	 rcx, rbx
  0009d	85 c0		 test	 eax, eax
  0009f	74 07		 je	 SHORT $LN37@Pickler_cl@2
  000a1	e8 00 00 00 00	 call	 _Px_Dealloc
  000a6	eb 14		 jmp	 SHORT $LN24@Pickler_cl@2
$LN37@Pickler_cl@2:
  000a8	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000ac	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000b2	eb 08		 jmp	 SHORT $LN24@Pickler_cl@2
$LN32@Pickler_cl@2:
  000b4	48 8b cb	 mov	 rcx, rbx
  000b7	e8 00 00 00 00	 call	 Px_DecRef
$LN24@Pickler_cl@2:

; 3457 :     Py_CLEAR(self->write);

  000bc	4c 8b 8f 80 00
	00 00		 mov	 r9, QWORD PTR [rdi+128]
  000c3	4d 85 c9	 test	 r9, r9
  000c6	0f 84 98 00 00
	00		 je	 $LN20@Pickler_cl@2
  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  000d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MAJBEHNL@Pickler_clear?$AA@
  000da	41 b8 81 0d 00
	00		 mov	 r8d, 3457		; 00000d81H
  000e0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000e8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ed	85 c0		 test	 eax, eax
  000ef	75 73		 jne	 SHORT $LN20@Pickler_cl@2
  000f1	48 8b 9f 80 00
	00 00		 mov	 rbx, QWORD PTR [rdi+128]
  000f8	48 89 b7 80 00
	00 00		 mov	 QWORD PTR [rdi+128], rsi
  000ff	e8 00 00 00 00	 call	 _Py_PXCTX
  00104	85 c0		 test	 eax, eax
  00106	75 5c		 jne	 SHORT $LN20@Pickler_cl@2
  00108	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0010c	a8 20		 test	 al, 32			; 00000020H
  0010e	75 4c		 jne	 SHORT $LN43@Pickler_cl@2
  00110	84 c0		 test	 al, al
  00112	78 48		 js	 SHORT $LN43@Pickler_cl@2
  00114	a8 02		 test	 al, 2
  00116	75 4c		 jne	 SHORT $LN20@Pickler_cl@2
  00118	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0011c	75 46		 jne	 SHORT $LN20@Pickler_cl@2
  0011e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0012c	4c 8b cb	 mov	 r9, rbx
  0012f	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00135	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0013d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00142	48 8b cb	 mov	 rcx, rbx
  00145	85 c0		 test	 eax, eax
  00147	74 07		 je	 SHORT $LN48@Pickler_cl@2
  00149	e8 00 00 00 00	 call	 _Px_Dealloc
  0014e	eb 14		 jmp	 SHORT $LN20@Pickler_cl@2
$LN48@Pickler_cl@2:
  00150	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00154	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0015a	eb 08		 jmp	 SHORT $LN20@Pickler_cl@2
$LN43@Pickler_cl@2:
  0015c	48 8b cb	 mov	 rcx, rbx
  0015f	e8 00 00 00 00	 call	 Px_DecRef
$LN20@Pickler_cl@2:

; 3458 :     Py_CLEAR(self->pers_func);

  00164	4c 8b 4f 68	 mov	 r9, QWORD PTR [rdi+104]
  00168	4d 85 c9	 test	 r9, r9
  0016b	0f 84 92 00 00
	00		 je	 $LN16@Pickler_cl@2
  00171	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00178	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MAJBEHNL@Pickler_clear?$AA@
  0017f	41 b8 82 0d 00
	00		 mov	 r8d, 3458		; 00000d82H
  00185	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0018d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00192	85 c0		 test	 eax, eax
  00194	75 6d		 jne	 SHORT $LN16@Pickler_cl@2
  00196	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
  0019a	48 89 77 68	 mov	 QWORD PTR [rdi+104], rsi
  0019e	e8 00 00 00 00	 call	 _Py_PXCTX
  001a3	85 c0		 test	 eax, eax
  001a5	75 5c		 jne	 SHORT $LN16@Pickler_cl@2
  001a7	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001ab	a8 20		 test	 al, 32			; 00000020H
  001ad	75 4c		 jne	 SHORT $LN54@Pickler_cl@2
  001af	84 c0		 test	 al, al
  001b1	78 48		 js	 SHORT $LN54@Pickler_cl@2
  001b3	a8 02		 test	 al, 2
  001b5	75 4c		 jne	 SHORT $LN16@Pickler_cl@2
  001b7	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001bb	75 46		 jne	 SHORT $LN16@Pickler_cl@2
  001bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001cb	4c 8b cb	 mov	 r9, rbx
  001ce	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001d4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001dc	e8 00 00 00 00	 call	 _PyParallel_Guard
  001e1	48 8b cb	 mov	 rcx, rbx
  001e4	85 c0		 test	 eax, eax
  001e6	74 07		 je	 SHORT $LN59@Pickler_cl@2
  001e8	e8 00 00 00 00	 call	 _Px_Dealloc
  001ed	eb 14		 jmp	 SHORT $LN16@Pickler_cl@2
$LN59@Pickler_cl@2:
  001ef	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001f3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001f9	eb 08		 jmp	 SHORT $LN16@Pickler_cl@2
$LN54@Pickler_cl@2:
  001fb	48 8b cb	 mov	 rcx, rbx
  001fe	e8 00 00 00 00	 call	 Px_DecRef
$LN16@Pickler_cl@2:

; 3459 :     Py_CLEAR(self->dispatch_table);

  00203	4c 8b 4f 70	 mov	 r9, QWORD PTR [rdi+112]
  00207	4d 85 c9	 test	 r9, r9
  0020a	0f 84 92 00 00
	00		 je	 $LN12@Pickler_cl@2
  00210	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00217	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MAJBEHNL@Pickler_clear?$AA@
  0021e	41 b8 83 0d 00
	00		 mov	 r8d, 3459		; 00000d83H
  00224	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0022c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00231	85 c0		 test	 eax, eax
  00233	75 6d		 jne	 SHORT $LN12@Pickler_cl@2
  00235	48 8b 5f 70	 mov	 rbx, QWORD PTR [rdi+112]
  00239	48 89 77 70	 mov	 QWORD PTR [rdi+112], rsi
  0023d	e8 00 00 00 00	 call	 _Py_PXCTX
  00242	85 c0		 test	 eax, eax
  00244	75 5c		 jne	 SHORT $LN12@Pickler_cl@2
  00246	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0024a	a8 20		 test	 al, 32			; 00000020H
  0024c	75 4c		 jne	 SHORT $LN65@Pickler_cl@2
  0024e	84 c0		 test	 al, al
  00250	78 48		 js	 SHORT $LN65@Pickler_cl@2
  00252	a8 02		 test	 al, 2
  00254	75 4c		 jne	 SHORT $LN12@Pickler_cl@2
  00256	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0025a	75 46		 jne	 SHORT $LN12@Pickler_cl@2
  0025c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00263	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0026a	4c 8b cb	 mov	 r9, rbx
  0026d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00273	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0027b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00280	48 8b cb	 mov	 rcx, rbx
  00283	85 c0		 test	 eax, eax
  00285	74 07		 je	 SHORT $LN70@Pickler_cl@2
  00287	e8 00 00 00 00	 call	 _Px_Dealloc
  0028c	eb 14		 jmp	 SHORT $LN12@Pickler_cl@2
$LN70@Pickler_cl@2:
  0028e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00292	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00298	eb 08		 jmp	 SHORT $LN12@Pickler_cl@2
$LN65@Pickler_cl@2:
  0029a	48 8b cb	 mov	 rcx, rbx
  0029d	e8 00 00 00 00	 call	 Px_DecRef
$LN12@Pickler_cl@2:

; 3460 :     Py_CLEAR(self->arg);

  002a2	4c 8b 4f 78	 mov	 r9, QWORD PTR [rdi+120]
  002a6	4d 85 c9	 test	 r9, r9
  002a9	0f 84 92 00 00
	00		 je	 $LN8@Pickler_cl@2
  002af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  002b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MAJBEHNL@Pickler_clear?$AA@
  002bd	41 b8 84 0d 00
	00		 mov	 r8d, 3460		; 00000d84H
  002c3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002cb	e8 00 00 00 00	 call	 _PyParallel_Guard
  002d0	85 c0		 test	 eax, eax
  002d2	75 6d		 jne	 SHORT $LN8@Pickler_cl@2
  002d4	48 8b 5f 78	 mov	 rbx, QWORD PTR [rdi+120]
  002d8	48 89 77 78	 mov	 QWORD PTR [rdi+120], rsi
  002dc	e8 00 00 00 00	 call	 _Py_PXCTX
  002e1	85 c0		 test	 eax, eax
  002e3	75 5c		 jne	 SHORT $LN8@Pickler_cl@2
  002e5	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  002e9	a8 20		 test	 al, 32			; 00000020H
  002eb	75 4c		 jne	 SHORT $LN76@Pickler_cl@2
  002ed	84 c0		 test	 al, al
  002ef	78 48		 js	 SHORT $LN76@Pickler_cl@2
  002f1	a8 02		 test	 al, 2
  002f3	75 4c		 jne	 SHORT $LN8@Pickler_cl@2
  002f5	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  002f9	75 46		 jne	 SHORT $LN8@Pickler_cl@2
  002fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00302	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00309	4c 8b cb	 mov	 r9, rbx
  0030c	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00312	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0031a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0031f	48 8b cb	 mov	 rcx, rbx
  00322	85 c0		 test	 eax, eax
  00324	74 07		 je	 SHORT $LN81@Pickler_cl@2
  00326	e8 00 00 00 00	 call	 _Px_Dealloc
  0032b	eb 14		 jmp	 SHORT $LN8@Pickler_cl@2
$LN81@Pickler_cl@2:
  0032d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00331	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00337	eb 08		 jmp	 SHORT $LN8@Pickler_cl@2
$LN76@Pickler_cl@2:
  00339	48 8b cb	 mov	 rcx, rbx
  0033c	e8 00 00 00 00	 call	 Px_DecRef
$LN8@Pickler_cl@2:

; 3461 :     Py_CLEAR(self->fast_memo);

  00341	4c 8b 8f c0 00
	00 00		 mov	 r9, QWORD PTR [rdi+192]
  00348	4d 85 c9	 test	 r9, r9
  0034b	0f 84 98 00 00
	00		 je	 $LN4@Pickler_cl@2
  00351	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00358	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MAJBEHNL@Pickler_clear?$AA@
  0035f	41 b8 85 0d 00
	00		 mov	 r8d, 3461		; 00000d85H
  00365	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0036d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00372	85 c0		 test	 eax, eax
  00374	75 73		 jne	 SHORT $LN4@Pickler_cl@2
  00376	48 8b 9f c0 00
	00 00		 mov	 rbx, QWORD PTR [rdi+192]
  0037d	48 89 b7 c0 00
	00 00		 mov	 QWORD PTR [rdi+192], rsi
  00384	e8 00 00 00 00	 call	 _Py_PXCTX
  00389	85 c0		 test	 eax, eax
  0038b	75 5c		 jne	 SHORT $LN4@Pickler_cl@2
  0038d	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00391	a8 20		 test	 al, 32			; 00000020H
  00393	75 4c		 jne	 SHORT $LN87@Pickler_cl@2
  00395	84 c0		 test	 al, al
  00397	78 48		 js	 SHORT $LN87@Pickler_cl@2
  00399	a8 02		 test	 al, 2
  0039b	75 4c		 jne	 SHORT $LN4@Pickler_cl@2
  0039d	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  003a1	75 46		 jne	 SHORT $LN4@Pickler_cl@2
  003a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  003b1	4c 8b cb	 mov	 r9, rbx
  003b4	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  003ba	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003c2	e8 00 00 00 00	 call	 _PyParallel_Guard
  003c7	48 8b cb	 mov	 rcx, rbx
  003ca	85 c0		 test	 eax, eax
  003cc	74 07		 je	 SHORT $LN92@Pickler_cl@2
  003ce	e8 00 00 00 00	 call	 _Px_Dealloc
  003d3	eb 14		 jmp	 SHORT $LN4@Pickler_cl@2
$LN92@Pickler_cl@2:
  003d5	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  003d9	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  003df	eb 08		 jmp	 SHORT $LN4@Pickler_cl@2
$LN87@Pickler_cl@2:
  003e1	48 8b cb	 mov	 rcx, rbx
  003e4	e8 00 00 00 00	 call	 Px_DecRef
$LN4@Pickler_cl@2:

; 3462 : 
; 3463 :     if (self->memo != NULL) {

  003e9	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  003ed	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  003f2	48 85 c9	 test	 rcx, rcx
  003f5	74 09		 je	 SHORT $LN94@Pickler_cl@2

; 3464 :         PyMemoTable *memo = self->memo;
; 3465 :         self->memo = NULL;

  003f7	48 89 77 60	 mov	 QWORD PTR [rdi+96], rsi

; 3466 :         PyMemoTable_Del(memo);

  003fb	e8 00 00 00 00	 call	 PyMemoTable_Del
$LN94@Pickler_cl@2:

; 3467 :     }
; 3468 :     return 0;

  00400	33 c0		 xor	 eax, eax

; 3469 : }

  00402	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00407	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0040b	5f		 pop	 rdi
  0040c	c3		 ret	 0
Pickler_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@NDEHFBIC@O?$HMOO?3Pickler?$AA@		; `string'
EXTRN	_PyObject_HasAttrId:PROC
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pickler_init DD imagerel Pickler_init
	DD	imagerel Pickler_init+251
	DD	imagerel $unwind$Pickler_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$Pickler_init DD imagerel Pickler_init+251
	DD	imagerel Pickler_init+405
	DD	imagerel $chain$1$Pickler_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$Pickler_init DD 040e21H
	DD	0d740eH
	DD	0c6405H
	DD	imagerel Pickler_init
	DD	imagerel Pickler_init+251
	DD	imagerel $unwind$Pickler_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_init DD 040c01H
	DD	0e340cH
	DD	05008920cH
xdata	ENDS
;	COMDAT ??_C@_0N@NDEHFBIC@O?$HMOO?3Pickler?$AA@
CONST	SEGMENT
??_C@_0N@NDEHFBIC@O?$HMOO?3Pickler?$AA@ DB 'O|OO:Pickler', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT Pickler_init
_TEXT	SEGMENT
proto_obj$ = 64
file$ = 72
self$ = 96
args$ = 104
kwds$ = 112
fix_imports$ = 120
Pickler_init PROC					; COMDAT

; 3498 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 18	 mov	 QWORD PTR [r11+24], rbx
  00007	55		 push	 rbp
  00008	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000c	48 8b d9	 mov	 rbx, rcx
  0000f	49 8b c0	 mov	 rax, r8
  00012	4c 8b d2	 mov	 r10, rdx

; 3499 :     static char *kwlist[] = {"file", "protocol", "fix_imports", 0};
; 3500 :     PyObject *file;
; 3501 :     PyObject *proto_obj = NULL;
; 3502 :     PyObject *fix_imports = Py_True;

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct

; 3503 :     _Py_IDENTIFIER(persistent_id);
; 3504 :     _Py_IDENTIFIER(dispatch_table);
; 3505 : 
; 3506 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|OO:Pickler",
; 3507 :                                      kwlist, &file, &proto_obj, &fix_imports))

  0001c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??Pickler_init@@9@9
  00023	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@NDEHFBIC@O?$HMOO?3Pickler?$AA@
  0002a	49 89 4b 20	 mov	 QWORD PTR [r11+32], rcx
  0002e	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00032	33 ed		 xor	 ebp, ebp
  00034	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  00038	49 8d 4b e8	 lea	 rcx, QWORD PTR [r11-24]
  0003c	48 8b d0	 mov	 rdx, rax
  0003f	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  00043	49 8d 4b f0	 lea	 rcx, QWORD PTR [r11-16]
  00047	49 89 6b e8	 mov	 QWORD PTR [r11-24], rbp
  0004b	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  0004f	49 8b ca	 mov	 rcx, r10
  00052	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00057	85 c0		 test	 eax, eax
  00059	75 0e		 jne	 SHORT $LN12@Pickler_in
$LN18@Pickler_in:

; 3508 :         return -1;

  0005b	83 c8 ff	 or	 eax, -1

; 3554 : }

  0005e	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00063	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00067	5d		 pop	 rbp
  00068	c3		 ret	 0
$LN12@Pickler_in:

; 3509 : 
; 3510 :     /* In case of multiple __init__() calls, clear previous content. */
; 3511 :     if (self->write != NULL)

  00069	48 39 ab 80 00
	00 00		 cmp	 QWORD PTR [rbx+128], rbp
  00070	74 08		 je	 SHORT $LN11@Pickler_in

; 3512 :         (void)Pickler_clear(self);

  00072	48 8b cb	 mov	 rcx, rbx
  00075	e8 00 00 00 00	 call	 Pickler_clear
$LN11@Pickler_in:

; 3513 : 
; 3514 :     if (_Pickler_SetProtocol(self, proto_obj, fix_imports) < 0)

  0007a	4c 8b 44 24 78	 mov	 r8, QWORD PTR fix_imports$[rsp]
  0007f	48 8b 54 24 40	 mov	 rdx, QWORD PTR proto_obj$[rsp]
  00084	48 8b cb	 mov	 rcx, rbx
  00087	e8 00 00 00 00	 call	 _Pickler_SetProtocol
  0008c	85 c0		 test	 eax, eax

; 3515 :         return -1;

  0008e	78 cb		 js	 SHORT $LN18@Pickler_in

; 3516 : 
; 3517 :     if (_Pickler_SetOutputStream(self, file) < 0)

  00090	48 8b 54 24 48	 mov	 rdx, QWORD PTR file$[rsp]
  00095	48 8b cb	 mov	 rcx, rbx
  00098	e8 00 00 00 00	 call	 _Pickler_SetOutputStream
  0009d	85 c0		 test	 eax, eax

; 3518 :         return -1;

  0009f	78 ba		 js	 SHORT $LN18@Pickler_in

; 3519 : 
; 3520 :     /* memo and output_buffer may have already been created in _Pickler_New */
; 3521 :     if (self->memo == NULL) {

  000a1	48 39 6b 60	 cmp	 QWORD PTR [rbx+96], rbp
  000a5	75 0e		 jne	 SHORT $LN7@Pickler_in

; 3522 :         self->memo = PyMemoTable_New();

  000a7	e8 00 00 00 00	 call	 PyMemoTable_New
  000ac	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 3523 :         if (self->memo == NULL)

  000b0	48 85 c0	 test	 rax, rax

; 3524 :             return -1;

  000b3	74 a6		 je	 SHORT $LN18@Pickler_in
$LN7@Pickler_in:

; 3525 :     }
; 3526 :     self->output_len = 0;

  000b5	48 89 ab 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rbp

; 3527 :     if (self->output_buffer == NULL) {

  000bc	48 39 ab 88 00
	00 00		 cmp	 QWORD PTR [rbx+136], rbp
  000c3	75 27		 jne	 SHORT $LN5@Pickler_in

; 3528 :         self->max_output_len = WRITE_BUF_SIZE;
; 3529 :         self->output_buffer = PyBytes_FromStringAndSize(NULL,
; 3530 :                                                         self->max_output_len);

  000c5	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  000ca	33 c9		 xor	 ecx, ecx
  000cc	48 c7 83 98 00
	00 00 00 10 00
	00		 mov	 QWORD PTR [rbx+152], 4096 ; 00001000H
  000d7	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000dc	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 3531 :         if (self->output_buffer == NULL)

  000e3	48 85 c0	 test	 rax, rax

; 3532 :             return -1;

  000e6	0f 84 6f ff ff
	ff		 je	 $LN18@Pickler_in
$LN5@Pickler_in:

; 3533 :     }
; 3534 : 
; 3535 :     self->arg = NULL;
; 3536 :     self->fast = 0;
; 3537 :     self->fast_nesting = 0;
; 3538 :     self->fast_memo = NULL;
; 3539 :     self->pers_func = NULL;
; 3540 :     if (_PyObject_HasAttrId((PyObject *)self, &PyId_persistent_id)) {

  000ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000f2	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000fb	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00100	48 8b 34 c8	 mov	 rsi, QWORD PTR [rax+rcx*8]
  00104	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  00109	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:?PyId_persistent_id@?1??Pickler_init@@9@9
  0010e	48 03 fe	 add	 rdi, rsi
  00111	48 8b cb	 mov	 rcx, rbx
  00114	48 89 6b 78	 mov	 QWORD PTR [rbx+120], rbp
  00118	48 8b d7	 mov	 rdx, rdi
  0011b	48 89 ab b0 00
	00 00		 mov	 QWORD PTR [rbx+176], rbp
  00122	48 89 ab c0 00
	00 00		 mov	 QWORD PTR [rbx+192], rbp
  00129	48 89 6b 68	 mov	 QWORD PTR [rbx+104], rbp
  0012d	e8 00 00 00 00	 call	 _PyObject_HasAttrId
  00132	85 c0		 test	 eax, eax
  00134	74 14		 je	 SHORT $LN3@Pickler_in

; 3541 :         self->pers_func = _PyObject_GetAttrId((PyObject *)self,
; 3542 :                                               &PyId_persistent_id);

  00136	48 8b d7	 mov	 rdx, rdi
  00139	48 8b cb	 mov	 rcx, rbx
  0013c	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00141	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax

; 3543 :         if (self->pers_func == NULL)

  00145	48 85 c0	 test	 rax, rax

; 3544 :             return -1;

  00148	74 2f		 je	 SHORT $LN17@Pickler_in
$LN3@Pickler_in:

; 3545 :     }
; 3546 :     self->dispatch_table = NULL;
; 3547 :     if (_PyObject_HasAttrId((PyObject *)self, &PyId_dispatch_table)) {

  0014a	bf 00 00 00 00	 mov	 edi, OFFSET FLAT:?PyId_dispatch_table@?1??Pickler_init@@9@9
  0014f	48 8b cb	 mov	 rcx, rbx
  00152	48 89 6b 70	 mov	 QWORD PTR [rbx+112], rbp
  00156	48 03 fe	 add	 rdi, rsi
  00159	48 8b d7	 mov	 rdx, rdi
  0015c	e8 00 00 00 00	 call	 _PyObject_HasAttrId
  00161	85 c0		 test	 eax, eax
  00163	74 19		 je	 SHORT $LN1@Pickler_in

; 3548 :         self->dispatch_table = _PyObject_GetAttrId((PyObject *)self,
; 3549 :                                                    &PyId_dispatch_table);

  00165	48 8b d7	 mov	 rdx, rdi
  00168	48 8b cb	 mov	 rcx, rbx
  0016b	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00170	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 3550 :         if (self->dispatch_table == NULL)

  00174	48 85 c0	 test	 rax, rax
  00177	75 05		 jne	 SHORT $LN1@Pickler_in
$LN17@Pickler_in:

; 3551 :             return -1;

  00179	83 c8 ff	 or	 eax, -1
  0017c	eb 02		 jmp	 SHORT $LN16@Pickler_in
$LN1@Pickler_in:

; 3552 :     }
; 3553 :     return 0;

  0017e	33 c0		 xor	 eax, eax
$LN16@Pickler_in:
  00180	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00185	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]

; 3554 : }

  0018a	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0018f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00193	5d		 pop	 rbp
  00194	c3		 ret	 0
Pickler_init ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$pmp_clear DD imagerel pmp_clear
	DD	imagerel pmp_clear+129
	DD	imagerel $unwind$pmp_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pmp_clear DD 031b01H
	DD	06341bH
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT pmp_clear
_TEXT	SEGMENT
self$ = 64
pmp_clear PROC						; COMDAT

; 3576 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3577 :     if (self->pickler->memo)

  00004	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00008	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0000c	48 85 c9	 test	 rcx, rcx
  0000f	74 05		 je	 SHORT $LN1@pmp_clear

; 3578 :         PyMemoTable_Clear(self->pickler->memo);

  00011	e8 00 00 00 00	 call	 PyMemoTable_Clear
$LN1@pmp_clear:
  00016	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 3579 :     Py_RETURN_NONE;

  0001b	e8 00 00 00 00	 call	 _Py_PXCTX
  00020	85 c0		 test	 eax, eax
  00022	75 4c		 jne	 SHORT $LN8@pmp_clear
  00024	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00039	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0003f	4c 8b cb	 mov	 r9, rbx
  00042	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0004a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004f	85 c0		 test	 eax, eax
  00051	75 09		 jne	 SHORT $LN4@pmp_clear
  00053	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0005a	74 07		 je	 SHORT $LN10@pmp_clear
$LN4@pmp_clear:
  0005c	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN10@pmp_clear:
  00063	48 8b c3	 mov	 rax, rbx
  00066	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 3580 : }

  0006b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006f	c3		 ret	 0
$LN8@pmp_clear:

; 3579 :     Py_RETURN_NONE;

  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00077	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 3580 : }

  0007c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00080	c3		 ret	 0
pmp_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_02DFBGJDAN@nO?$AA@			; `string'
EXTRN	Py_BuildValue:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$pmp_copy DD imagerel pmp_copy
	DD	imagerel pmp_copy+36
	DD	imagerel $unwind$pmp_copy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$pmp_copy DD imagerel pmp_copy+36
	DD	imagerel pmp_copy+233
	DD	imagerel $chain$4$pmp_copy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$pmp_copy DD imagerel pmp_copy+233
	DD	imagerel pmp_copy+570
	DD	imagerel $chain$6$pmp_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$pmp_copy DD 0a0021H
	DD	06e400H
	DD	0dd400H
	DD	0c7400H
	DD	0b6400H
	DD	0a5400H
	DD	imagerel pmp_copy
	DD	imagerel pmp_copy+36
	DD	imagerel $unwind$pmp_copy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$pmp_copy DD 0a1921H
	DD	06e419H
	DD	0dd414H
	DD	0c740fH
	DD	0b640aH
	DD	0a5405H
	DD	imagerel pmp_copy
	DD	imagerel pmp_copy+36
	DD	imagerel $unwind$pmp_copy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pmp_copy DD 030801H
	DD	0c0046208H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_02DFBGJDAN@nO?$AA@
CONST	SEGMENT
??_C@_02DFBGJDAN@nO?$AA@ DB 'nO', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT pmp_copy
_TEXT	SEGMENT
self$ = 80
pmp_copy PROC						; COMDAT

; 3587 : {

  00000	40 53		 push	 rbx
  00002	41 54		 push	 r12
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00008	48 8b d9	 mov	 rbx, rcx

; 3588 :     Py_ssize_t i;
; 3589 :     PyMemoTable *memo;
; 3590 :     PyObject *new_memo = PyDict_New();

  0000b	e8 00 00 00 00	 call	 PyDict_New
  00010	4c 8b e0	 mov	 r12, rax

; 3591 :     if (new_memo == NULL)

  00013	48 85 c0	 test	 rax, rax
  00016	75 08		 jne	 SHORT $LN20@pmp_copy

; 3621 : }

  00018	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001c	41 5c		 pop	 r12
  0001e	5b		 pop	 rbx
  0001f	c3		 ret	 0
$LN20@pmp_copy:

; 3592 :         return NULL;
; 3593 : 
; 3594 :     memo = self->pickler->memo;

  00020	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  00024	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00029	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  0002e	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00033	4c 89 6c 24 68	 mov	 QWORD PTR [rsp+104], r13
  00038	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  0003d	4c 8b 70 60	 mov	 r14, QWORD PTR [rax+96]

; 3595 :     for (i = 0; i < memo->mt_allocated; ++i) {

  00041	33 ed		 xor	 ebp, ebp
  00043	49 39 6e 10	 cmp	 QWORD PTR [r14+16], rbp
  00047	7e 7c		 jle	 SHORT $LN60@pmp_copy

; 3592 :         return NULL;
; 3593 : 
; 3594 :     memo = self->pickler->memo;

  00049	8b fd		 mov	 edi, ebp
  0004b	0f 1f 44 00 00	 npad	 5
$LL19@pmp_copy:

; 3596 :         PyMemoEntry entry = memo->mt_table[i];

  00050	49 8b 46 18	 mov	 rax, QWORD PTR [r14+24]
  00054	48 8b 1c 07	 mov	 rbx, QWORD PTR [rdi+rax]
  00058	48 8b 74 07 08	 mov	 rsi, QWORD PTR [rdi+rax+8]

; 3597 :         if (entry.me_key != NULL) {

  0005d	48 85 db	 test	 rbx, rbx
  00060	74 56		 je	 SHORT $LN18@pmp_copy

; 3598 :             int status;
; 3599 :             PyObject *key, *value;
; 3600 : 
; 3601 :             key = PyLong_FromVoidPtr(entry.me_key);

  00062	48 8b cb	 mov	 rcx, rbx
  00065	e8 00 00 00 00	 call	 PyLong_FromVoidPtr

; 3602 :             value = Py_BuildValue("nO", entry.me_value, entry.me_key);

  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DFBGJDAN@nO?$AA@
  00071	4c 8b c3	 mov	 r8, rbx
  00074	48 8b d6	 mov	 rdx, rsi
  00077	4c 8b e8	 mov	 r13, rax
  0007a	e8 00 00 00 00	 call	 Py_BuildValue
  0007f	48 8b f0	 mov	 rsi, rax

; 3603 : 
; 3604 :             if (key == NULL || value == NULL) {

  00082	4d 85 ed	 test	 r13, r13
  00085	0f 84 cc 00 00
	00		 je	 $LN12@pmp_copy
  0008b	48 85 c0	 test	 rax, rax
  0008e	74 59		 je	 SHORT $LN13@pmp_copy

; 3607 :                 goto error;
; 3608 :             }
; 3609 :             status = PyDict_SetItem(new_memo, key, value);

  00090	4c 8b c0	 mov	 r8, rax
  00093	49 8b d5	 mov	 rdx, r13
  00096	49 8b cc	 mov	 rcx, r12
  00099	e8 00 00 00 00	 call	 PyDict_SetItem

; 3610 :             Py_DECREF(key);

  0009e	49 8b cd	 mov	 rcx, r13
  000a1	8b d8		 mov	 ebx, eax
  000a3	e8 00 00 00 00	 call	 _Py_DecRef

; 3611 :             Py_DECREF(value);

  000a8	48 8b ce	 mov	 rcx, rsi
  000ab	e8 00 00 00 00	 call	 _Py_DecRef

; 3612 :             if (status < 0)

  000b0	85 db		 test	 ebx, ebx
  000b2	0f 88 09 01 00
	00		 js	 $error$22938
$LN18@pmp_copy:

; 3595 :     for (i = 0; i < memo->mt_allocated; ++i) {

  000b8	48 ff c5	 inc	 rbp
  000bb	48 83 c7 10	 add	 rdi, 16
  000bf	49 3b 6e 10	 cmp	 rbp, QWORD PTR [r14+16]
  000c3	7c 8b		 jl	 SHORT $LL19@pmp_copy
$LN60@pmp_copy:

; 3613 :                 goto error;
; 3614 :         }
; 3615 :     }
; 3616 :     return new_memo;

  000c5	49 8b c4	 mov	 rax, r12
$LN65@pmp_copy:
  000c8	4c 8b 6c 24 68	 mov	 r13, QWORD PTR [rsp+104]
  000cd	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  000d2	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  000d7	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000dc	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]

; 3621 : }

  000e1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e5	41 5c		 pop	 r12
  000e7	5b		 pop	 rbx
  000e8	c3		 ret	 0
$LN13@pmp_copy:

; 3605 :                 Py_XDECREF(key);

  000e9	e8 00 00 00 00	 call	 _Py_PXCTX
  000ee	85 c0		 test	 eax, eax
  000f0	0f 85 cb 00 00
	00		 jne	 $error$22938
  000f6	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  000fa	a8 20		 test	 al, 32			; 00000020H
  000fc	75 54		 jne	 SHORT $LN27@pmp_copy
  000fe	84 c0		 test	 al, al
  00100	78 50		 js	 SHORT $LN27@pmp_copy
  00102	a8 02		 test	 al, 2
  00104	0f 85 b7 00 00
	00		 jne	 $error$22938
  0010a	49 ff 4d 50	 dec	 QWORD PTR [r13+80]
  0010e	0f 85 ad 00 00
	00		 jne	 $error$22938
  00114	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0011b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00122	4d 8b cd	 mov	 r9, r13
  00125	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0012b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00133	e8 00 00 00 00	 call	 _PyParallel_Guard
  00138	49 8b cd	 mov	 rcx, r13
  0013b	85 c0		 test	 eax, eax
  0013d	74 07		 je	 SHORT $LN32@pmp_copy
  0013f	e8 00 00 00 00	 call	 _Px_Dealloc
  00144	eb 7b		 jmp	 SHORT $error$22938
$LN32@pmp_copy:
  00146	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  0014a	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00150	eb 6f		 jmp	 SHORT $error$22938
$LN27@pmp_copy:
  00152	49 8b cd	 mov	 rcx, r13

; 3606 :                 Py_XDECREF(value);

  00155	eb 65		 jmp	 SHORT $LN66@pmp_copy
$LN12@pmp_copy:
  00157	48 85 c0	 test	 rax, rax
  0015a	74 65		 je	 SHORT $error$22938
  0015c	e8 00 00 00 00	 call	 _Py_PXCTX
  00161	85 c0		 test	 eax, eax
  00163	75 5c		 jne	 SHORT $error$22938
  00165	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  00169	a8 20		 test	 al, 32			; 00000020H
  0016b	75 4c		 jne	 SHORT $LN38@pmp_copy
  0016d	84 c0		 test	 al, al
  0016f	78 48		 js	 SHORT $LN38@pmp_copy
  00171	a8 02		 test	 al, 2
  00173	75 4c		 jne	 SHORT $error$22938
  00175	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  00179	75 46		 jne	 SHORT $error$22938
  0017b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00182	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00189	4c 8b ce	 mov	 r9, rsi
  0018c	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00192	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0019a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0019f	48 8b ce	 mov	 rcx, rsi
  001a2	85 c0		 test	 eax, eax
  001a4	74 07		 je	 SHORT $LN43@pmp_copy
  001a6	e8 00 00 00 00	 call	 _Px_Dealloc
  001ab	eb 14		 jmp	 SHORT $error$22938
$LN43@pmp_copy:
  001ad	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  001b1	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001b7	eb 08		 jmp	 SHORT $error$22938
$LN38@pmp_copy:
  001b9	48 8b ce	 mov	 rcx, rsi
$LN66@pmp_copy:
  001bc	e8 00 00 00 00	 call	 Px_DecRef
$error$22938:

; 3617 : 
; 3618 :   error:
; 3619 :     Py_XDECREF(new_memo);

  001c1	e8 00 00 00 00	 call	 _Py_PXCTX
  001c6	85 c0		 test	 eax, eax
  001c8	75 69		 jne	 SHORT $LN3@pmp_copy
  001ca	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  001cf	a8 20		 test	 al, 32			; 00000020H
  001d1	75 58		 jne	 SHORT $LN49@pmp_copy
  001d3	84 c0		 test	 al, al
  001d5	78 54		 js	 SHORT $LN49@pmp_copy
  001d7	a8 02		 test	 al, 2
  001d9	75 58		 jne	 SHORT $LN3@pmp_copy
  001db	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  001e0	75 51		 jne	 SHORT $LN3@pmp_copy
  001e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001f0	4d 8b cc	 mov	 r9, r12
  001f3	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001f9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00201	e8 00 00 00 00	 call	 _PyParallel_Guard
  00206	49 8b cc	 mov	 rcx, r12
  00209	85 c0		 test	 eax, eax
  0020b	74 0c		 je	 SHORT $LN54@pmp_copy
  0020d	e8 00 00 00 00	 call	 _Px_Dealloc

; 3620 :     return NULL;

  00212	33 c0		 xor	 eax, eax
  00214	e9 af fe ff ff	 jmp	 $LN65@pmp_copy

; 3617 : 
; 3618 :   error:
; 3619 :     Py_XDECREF(new_memo);

$LN54@pmp_copy:
  00219	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  0021e	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 3620 :     return NULL;

  00224	33 c0		 xor	 eax, eax
  00226	e9 9d fe ff ff	 jmp	 $LN65@pmp_copy

; 3617 : 
; 3618 :   error:
; 3619 :     Py_XDECREF(new_memo);

$LN49@pmp_copy:
  0022b	49 8b cc	 mov	 rcx, r12
  0022e	e8 00 00 00 00	 call	 Px_DecRef
$LN3@pmp_copy:

; 3620 :     return NULL;

  00233	33 c0		 xor	 eax, eax
  00235	e9 8e fe ff ff	 jmp	 $LN65@pmp_copy
pmp_copy ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$pmp_reduce DD imagerel pmp_reduce
	DD	imagerel pmp_reduce+30
	DD	imagerel $unwind$pmp_reduce
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pmp_reduce DD imagerel pmp_reduce+30
	DD	imagerel pmp_reduce+69
	DD	imagerel $chain$0$pmp_reduce
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$pmp_reduce DD imagerel pmp_reduce+69
	DD	imagerel pmp_reduce+126
	DD	imagerel $chain$3$pmp_reduce
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$pmp_reduce DD imagerel pmp_reduce+126
	DD	imagerel pmp_reduce+229
	DD	imagerel $chain$5$pmp_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$pmp_reduce DD 040021H
	DD	096400H
	DD	083400H
	DD	imagerel pmp_reduce
	DD	imagerel pmp_reduce+30
	DD	imagerel $unwind$pmp_reduce
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$pmp_reduce DD 040a21H
	DD	09640aH
	DD	083400H
	DD	imagerel pmp_reduce
	DD	imagerel pmp_reduce+30
	DD	imagerel $unwind$pmp_reduce
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pmp_reduce DD 020521H
	DD	083405H
	DD	imagerel pmp_reduce
	DD	imagerel pmp_reduce+30
	DD	imagerel $unwind$pmp_reduce
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pmp_reduce DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT pmp_reduce
_TEXT	SEGMENT
self$ = 64
args$ = 72
pmp_reduce PROC						; COMDAT

; 3628 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3629 :     PyObject *reduce_value, *dict_args;
; 3630 :     PyObject *contents = pmp_copy(self);

  00006	e8 00 00 00 00	 call	 pmp_copy
  0000b	48 8b f8	 mov	 rdi, rax

; 3631 :     if (contents == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 06		 jne	 SHORT $LN3@pmp_reduce

; 3650 : }

  00013	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00017	5f		 pop	 rdi
  00018	c3		 ret	 0
$LN3@pmp_reduce:

; 3632 :         return NULL;
; 3633 : 
; 3634 :     reduce_value = PyTuple_New(2);

  00019	b9 02 00 00 00	 mov	 ecx, 2
  0001e	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00023	e8 00 00 00 00	 call	 PyTuple_New
  00028	48 8b d8	 mov	 rbx, rax

; 3635 :     if (reduce_value == NULL) {

  0002b	48 85 c0	 test	 rax, rax
  0002e	75 15		 jne	 SHORT $LN2@pmp_reduce

; 3636 :         Py_DECREF(contents);

  00030	48 8b cf	 mov	 rcx, rdi
  00033	e8 00 00 00 00	 call	 _Py_DecRef
  00038	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 3637 :         return NULL;

  0003d	33 c0		 xor	 eax, eax

; 3650 : }

  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
$LN2@pmp_reduce:

; 3638 :     }
; 3639 :     dict_args = PyTuple_New(1);

  00045	b9 01 00 00 00	 mov	 ecx, 1
  0004a	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  0004f	e8 00 00 00 00	 call	 PyTuple_New
  00054	48 8b f0	 mov	 rsi, rax

; 3640 :     if (dict_args == NULL) {

  00057	48 85 c0	 test	 rax, rax
  0005a	75 22		 jne	 SHORT $LN1@pmp_reduce

; 3641 :         Py_DECREF(contents);

  0005c	48 8b cf	 mov	 rcx, rdi
  0005f	e8 00 00 00 00	 call	 _Py_DecRef

; 3642 :         Py_DECREF(reduce_value);

  00064	48 8b cb	 mov	 rcx, rbx
  00067	e8 00 00 00 00	 call	 _Py_DecRef
  0006c	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00071	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 3643 :         return NULL;

  00076	33 c0		 xor	 eax, eax

; 3650 : }

  00078	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007c	5f		 pop	 rdi
  0007d	c3		 ret	 0
$LN1@pmp_reduce:

; 3644 :     }
; 3645 :     PyTuple_SET_ITEM(dict_args, 0, contents);

  0007e	48 89 78 70	 mov	 QWORD PTR [rax+112], rdi

; 3646 :     Py_INCREF((PyObject *)&PyDict_Type);

  00082	e8 00 00 00 00	 call	 _Py_PXCTX
  00087	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:PyDict_Type
  0008e	85 c0		 test	 eax, eax
  00090	75 38		 jne	 SHORT $LN7@pmp_reduce
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000a0	4c 8b cf	 mov	 r9, rdi
  000a3	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b1	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b6	85 c0		 test	 eax, eax
  000b8	75 09		 jne	 SHORT $LN6@pmp_reduce
  000ba	f6 05 20 00 00
	00 20		 test	 BYTE PTR PyDict_Type+32, 32 ; 00000020H
  000c1	74 07		 je	 SHORT $LN7@pmp_reduce
$LN6@pmp_reduce:
  000c3	48 ff 05 50 00
	00 00		 inc	 QWORD PTR PyDict_Type+80
$LN7@pmp_reduce:

; 3647 :     PyTuple_SET_ITEM(reduce_value, 0, (PyObject *)&PyDict_Type);
; 3648 :     PyTuple_SET_ITEM(reduce_value, 1, dict_args);

  000ca	48 89 73 78	 mov	 QWORD PTR [rbx+120], rsi
  000ce	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000d3	48 89 7b 70	 mov	 QWORD PTR [rbx+112], rdi

; 3649 :     return reduce_value;

  000d7	48 8b c3	 mov	 rax, rbx
  000da	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 3650 : }

  000df	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e3	5f		 pop	 rdi
  000e4	c3		 ret	 0
pmp_reduce ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PicklerMemoProxy_dealloc DD imagerel PicklerMemoProxy_dealloc
	DD	imagerel PicklerMemoProxy_dealloc+182
	DD	imagerel $unwind$PicklerMemoProxy_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PicklerMemoProxy_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT PicklerMemoProxy_dealloc
_TEXT	SEGMENT
self$ = 64
PicklerMemoProxy_dealloc PROC				; COMDAT

; 3661 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 3662 :     PyObject_GC_UnTrack(self);

  0000d	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 3663 :     Py_XDECREF(self->pickler);

  00012	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  00016	48 85 db	 test	 rbx, rbx
  00019	0f 84 85 00 00
	00		 je	 $LN3@PicklerMem
  0001f	e8 00 00 00 00	 call	 _Py_PXCTX
  00024	85 c0		 test	 eax, eax
  00026	75 7c		 jne	 SHORT $LN3@PicklerMem
  00028	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0002c	a8 20		 test	 al, 32			; 00000020H
  0002e	75 6c		 jne	 SHORT $LN11@PicklerMem
  00030	84 c0		 test	 al, al
  00032	78 68		 js	 SHORT $LN11@PicklerMem
  00034	a8 02		 test	 al, 2
  00036	75 6c		 jne	 SHORT $LN3@PicklerMem
  00038	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0003c	75 66		 jne	 SHORT $LN3@PicklerMem
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0004c	4c 8b cb	 mov	 r9, rbx
  0004f	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00055	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0005d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00062	48 8b cb	 mov	 rcx, rbx
  00065	85 c0		 test	 eax, eax
  00067	74 17		 je	 SHORT $LN16@PicklerMem
  00069	e8 00 00 00 00	 call	 _Px_Dealloc

; 3664 :     PyObject_GC_Del((PyObject *)self);

  0006e	48 8b cf	 mov	 rcx, rdi

; 3665 : }

  00071	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00076	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007a	5f		 pop	 rdi
  0007b	e9 00 00 00 00	 jmp	 PyObject_GC_Del

; 3663 :     Py_XDECREF(self->pickler);

$LN16@PicklerMem:
  00080	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00084	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 3664 :     PyObject_GC_Del((PyObject *)self);

  0008a	48 8b cf	 mov	 rcx, rdi

; 3665 : }

  0008d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00092	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00096	5f		 pop	 rdi
  00097	e9 00 00 00 00	 jmp	 PyObject_GC_Del

; 3663 :     Py_XDECREF(self->pickler);

$LN11@PicklerMem:
  0009c	48 8b cb	 mov	 rcx, rbx
  0009f	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PicklerMem:

; 3664 :     PyObject_GC_Del((PyObject *)self);

  000a4	48 8b cf	 mov	 rcx, rdi

; 3665 : }

  000a7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b0	5f		 pop	 rdi
  000b1	e9 00 00 00 00	 jmp	 PyObject_GC_Del
PicklerMemoProxy_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@IANMMKJD@PicklerMemoProxy_traverse?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$PicklerMemoProxy_traverse DD imagerel PicklerMemoProxy_traverse
	DD	imagerel PicklerMemoProxy_traverse+97
	DD	imagerel $unwind$PicklerMemoProxy_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PicklerMemoProxy_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BK@IANMMKJD@PicklerMemoProxy_traverse?$AA@
CONST	SEGMENT
??_C@_0BK@IANMMKJD@PicklerMemoProxy_traverse?$AA@ DB 'PicklerMemoProxy_tr'
	DB	'averse', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PicklerMemoProxy_traverse
_TEXT	SEGMENT
self$ = 48
visit$ = 56
arg$ = 64
PicklerMemoProxy_traverse PROC				; COMDAT

; 3670 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 3671 :     Py_VISIT(self->pickler);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN3@PicklerMem@2
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@IANMMKJD@PicklerMemoProxy_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 57 0e 00
	00		 mov	 r8d, 3671		; 00000e57H
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@PicklerMem@2:
  0003d	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00041	48 85 c9	 test	 rcx, rcx
  00044	74 09		 je	 SHORT $LN5@PicklerMem@2
  00046	48 8b d7	 mov	 rdx, rdi
  00049	ff d6		 call	 rsi
  0004b	85 c0		 test	 eax, eax
  0004d	75 02		 jne	 SHORT $LN7@PicklerMem@2
$LN5@PicklerMem@2:

; 3672 :     return 0;

  0004f	33 c0		 xor	 eax, eax
$LN7@PicklerMem@2:

; 3673 : }

  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
PicklerMemoProxy_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@BKPDCCH@PicklerMemoProxy_clear?$AA@	; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PicklerMemoProxy_clear DD imagerel PicklerMemoProxy_clear
	DD	imagerel PicklerMemoProxy_clear+63
	DD	imagerel $unwind$PicklerMemoProxy_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PicklerMemoProxy_clear DD imagerel PicklerMemoProxy_clear+63
	DD	imagerel PicklerMemoProxy_clear+172
	DD	imagerel $chain$0$PicklerMemoProxy_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PicklerMemoProxy_clear DD imagerel PicklerMemoProxy_clear+172
	DD	imagerel PicklerMemoProxy_clear+195
	DD	imagerel $chain$2$PicklerMemoProxy_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PicklerMemoProxy_clear DD imagerel PicklerMemoProxy_clear+195
	DD	imagerel PicklerMemoProxy_clear+208
	DD	imagerel $chain$4$PicklerMemoProxy_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PicklerMemoProxy_clear DD imagerel PicklerMemoProxy_clear+208
	DD	imagerel PicklerMemoProxy_clear+216
	DD	imagerel $chain$5$PicklerMemoProxy_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PicklerMemoProxy_clear DD 021H
	DD	imagerel PicklerMemoProxy_clear
	DD	imagerel PicklerMemoProxy_clear+63
	DD	imagerel $unwind$PicklerMemoProxy_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PicklerMemoProxy_clear DD 020021H
	DD	083400H
	DD	imagerel PicklerMemoProxy_clear
	DD	imagerel PicklerMemoProxy_clear+63
	DD	imagerel $unwind$PicklerMemoProxy_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PicklerMemoProxy_clear DD 020021H
	DD	083400H
	DD	imagerel PicklerMemoProxy_clear
	DD	imagerel PicklerMemoProxy_clear+63
	DD	imagerel $unwind$PicklerMemoProxy_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PicklerMemoProxy_clear DD 020521H
	DD	083405H
	DD	imagerel PicklerMemoProxy_clear
	DD	imagerel PicklerMemoProxy_clear+63
	DD	imagerel $unwind$PicklerMemoProxy_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PicklerMemoProxy_clear DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_0BH@BKPDCCH@PicklerMemoProxy_clear?$AA@
CONST	SEGMENT
??_C@_0BH@BKPDCCH@PicklerMemoProxy_clear?$AA@ DB 'PicklerMemoProxy_clear', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT PicklerMemoProxy_clear
_TEXT	SEGMENT
self$ = 64
PicklerMemoProxy_clear PROC				; COMDAT

; 3677 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3678 :     Py_CLEAR(self->pickler);

  00006	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	4d 85 c9	 test	 r9, r9
  00010	0f 84 ba 00 00
	00		 je	 $LN21@PicklerMem@3
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@BKPDCCH@PicklerMemoProxy_clear?$AA@
  00024	41 b8 5e 0e 00
	00		 mov	 r8d, 3678		; 00000e5eH
  0002a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00032	e8 00 00 00 00	 call	 _PyParallel_Guard
  00037	85 c0		 test	 eax, eax
  00039	0f 85 91 00 00
	00		 jne	 $LN21@PicklerMem@3
  0003f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00044	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  00048	48 c7 47 60 00
	00 00 00	 mov	 QWORD PTR [rdi+96], 0
  00050	e8 00 00 00 00	 call	 _Py_PXCTX
  00055	85 c0		 test	 eax, eax
  00057	75 72		 jne	 SHORT $LN22@PicklerMem@3
  00059	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0005d	a8 20		 test	 al, 32			; 00000020H
  0005f	75 62		 jne	 SHORT $LN11@PicklerMem@3
  00061	84 c0		 test	 al, al
  00063	78 5e		 js	 SHORT $LN11@PicklerMem@3
  00065	a8 02		 test	 al, 2
  00067	75 62		 jne	 SHORT $LN22@PicklerMem@3
  00069	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0006d	75 5c		 jne	 SHORT $LN22@PicklerMem@3
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0007d	4c 8b cb	 mov	 r9, rbx
  00080	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00086	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0008e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00093	48 8b cb	 mov	 rcx, rbx
  00096	85 c0		 test	 eax, eax
  00098	74 12		 je	 SHORT $LN16@PicklerMem@3
  0009a	e8 00 00 00 00	 call	 _Px_Dealloc
  0009f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 3679 :     return 0;

  000a4	33 c0		 xor	 eax, eax

; 3680 : }

  000a6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0

; 3678 :     Py_CLEAR(self->pickler);

$LN16@PicklerMem@3:
  000ac	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000b0	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000b6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 3679 :     return 0;

  000bb	33 c0		 xor	 eax, eax

; 3680 : }

  000bd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0

; 3678 :     Py_CLEAR(self->pickler);

$LN11@PicklerMem@3:
  000c3	48 8b cb	 mov	 rcx, rbx
  000c6	e8 00 00 00 00	 call	 Px_DecRef
$LN22@PicklerMem@3:
  000cb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN21@PicklerMem@3:

; 3679 :     return 0;

  000d0	33 c0		 xor	 eax, eax

; 3680 : }

  000d2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d6	5f		 pop	 rdi
  000d7	c3		 ret	 0
PicklerMemoProxy_clear ENDP
_TEXT	ENDS
EXTRN	PyObject_GC_Track:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PicklerMemoProxy_New DD imagerel PicklerMemoProxy_New
	DD	imagerel PicklerMemoProxy_New+145
	DD	imagerel $unwind$PicklerMemoProxy_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PicklerMemoProxy_New DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT PicklerMemoProxy_New
_TEXT	SEGMENT
pickler$ = 64
PicklerMemoProxy_New PROC				; COMDAT

; 3715 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 3716 :     PicklerMemoProxyObject *self;
; 3717 : 
; 3718 :     self = PyObject_GC_New(PicklerMemoProxyObject, &PicklerMemoProxyType);

  0000d	e8 00 00 00 00	 call	 _Py_PXCTX
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PicklerMemoProxyType
  00019	85 c0		 test	 eax, eax
  0001b	74 07		 je	 SHORT $LN4@PicklerMem@4
  0001d	e8 00 00 00 00	 call	 _PxObject_New
  00022	eb 05		 jmp	 SHORT $LN10@PicklerMem@4
$LN4@PicklerMem@4:
  00024	e8 00 00 00 00	 call	 _PyObject_GC_New
$LN10@PicklerMem@4:
  00029	48 8b d8	 mov	 rbx, rax

; 3719 :     if (self == NULL)

  0002c	48 85 c0	 test	 rax, rax
  0002f	75 0b		 jne	 SHORT $LN1@PicklerMem@4

; 3725 : }

  00031	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00036	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
$LN1@PicklerMem@4:

; 3720 :         return NULL;
; 3721 :     Py_INCREF(pickler);

  0003c	e8 00 00 00 00	 call	 _Py_PXCTX
  00041	85 c0		 test	 eax, eax
  00043	75 32		 jne	 SHORT $LN7@PicklerMem@4
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00053	4c 8b cf	 mov	 r9, rdi
  00056	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0005c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00064	e8 00 00 00 00	 call	 _PyParallel_Guard
  00069	85 c0		 test	 eax, eax
  0006b	75 06		 jne	 SHORT $LN6@PicklerMem@4
  0006d	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00071	74 04		 je	 SHORT $LN7@PicklerMem@4
$LN6@PicklerMem@4:
  00073	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN7@PicklerMem@4:

; 3722 :     self->pickler = pickler;
; 3723 :     PyObject_GC_Track(self);

  00077	48 8b cb	 mov	 rcx, rbx
  0007a	48 89 7b 60	 mov	 QWORD PTR [rbx+96], rdi
  0007e	e8 00 00 00 00	 call	 PyObject_GC_Track

; 3724 :     return (PyObject *)self;

  00083	48 8b c3	 mov	 rax, rbx

; 3725 : }

  00086	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0008b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008f	5f		 pop	 rdi
  00090	c3		 ret	 0
PicklerMemoProxy_New ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT Pickler_get_memo
_TEXT	SEGMENT
self$ = 8
Pickler_get_memo PROC					; COMDAT

; 3732 :     return PicklerMemoProxy_New(self);
; 3733 : }

  00000	e9 00 00 00 00	 jmp	 PicklerMemoProxy_New
Pickler_get_memo ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EH@DMODCLIB@?8memo?8?5attribute?5must?5be?5an?5Pick@ ; `string'
PUBLIC	??_C@_0CE@JMGPAAF@?8memo?8?5values?5must?5be?52?9item?5tup@ ; `string'
PUBLIC	??_C@_0CE@KNPPJDNH@attribute?5deletion?5is?5not?5suppor@ ; `string'
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pickler_set_memo DD imagerel Pickler_set_memo
	DD	imagerel Pickler_set_memo+58
	DD	imagerel $unwind$Pickler_set_memo
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$Pickler_set_memo DD imagerel Pickler_set_memo+58
	DD	imagerel Pickler_set_memo+130
	DD	imagerel $chain$1$Pickler_set_memo
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$Pickler_set_memo DD imagerel Pickler_set_memo+130
	DD	imagerel Pickler_set_memo+392
	DD	imagerel $chain$3$Pickler_set_memo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$Pickler_set_memo DD 040021H
	DD	047400H
	DD	083400H
	DD	imagerel Pickler_set_memo
	DD	imagerel Pickler_set_memo+58
	DD	imagerel $unwind$Pickler_set_memo
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$Pickler_set_memo DD 040a21H
	DD	04740aH
	DD	083405H
	DD	imagerel Pickler_set_memo
	DD	imagerel Pickler_set_memo+58
	DD	imagerel $unwind$Pickler_set_memo
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_set_memo DD 030701H
	DD	060034207H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0EH@DMODCLIB@?8memo?8?5attribute?5must?5be?5an?5Pick@
CONST	SEGMENT
??_C@_0EH@DMODCLIB@?8memo?8?5attribute?5must?5be?5an?5Pick@ DB '''memo'' '
	DB	'attribute must be an PicklerMemoProxy objector dict, not %.20'
	DB	'0s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JMGPAAF@?8memo?8?5values?5must?5be?52?9item?5tup@
CONST	SEGMENT
??_C@_0CE@JMGPAAF@?8memo?8?5values?5must?5be?52?9item?5tup@ DB '''memo'' '
	DB	'values must be 2-item tuples', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KNPPJDNH@attribute?5deletion?5is?5not?5suppor@
CONST	SEGMENT
??_C@_0CE@KNPPJDNH@attribute?5deletion?5is?5not?5suppor@ DB 'attribute de'
	DB	'letion is not supported', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT Pickler_set_memo
_TEXT	SEGMENT
self$ = 64
value$23081 = 72
obj$ = 72
i$23079 = 80
key$23080 = 88
Pickler_set_memo PROC					; COMDAT

; 3737 : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00007	48 8b f2	 mov	 rsi, rdx
  0000a	48 8b e9	 mov	 rbp, rcx

; 3738 :     PyMemoTable *new_memo = NULL;
; 3739 : 
; 3740 :     if (obj == NULL) {

  0000d	48 85 d2	 test	 rdx, rdx
  00010	75 1d		 jne	 SHORT $LN14@Pickler_se

; 3741 :         PyErr_SetString(PyExc_TypeError,
; 3742 :                         "attribute deletion is not supported");

  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KNPPJDNH@attribute?5deletion?5is?5not?5suppor@
  00020	e8 00 00 00 00	 call	 PyErr_SetString

; 3743 :         return -1;

  00025	83 c8 ff	 or	 eax, -1

; 3795 : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	5e		 pop	 rsi
  0002d	5d		 pop	 rbp
  0002e	c3		 ret	 0
$LN14@Pickler_se:

; 3744 :     }
; 3745 : 
; 3746 :     if (Py_TYPE(obj) == &PicklerMemoProxyType) {

  0002f	4c 8b 42 58	 mov	 r8, QWORD PTR [rdx+88]
  00033	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PicklerMemoProxyType
  0003a	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0003f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00044	4c 3b c0	 cmp	 r8, rax
  00047	75 39		 jne	 SHORT $LN13@Pickler_se

; 3747 :         PicklerObject *pickler =
; 3748 :             ((PicklerMemoProxyObject *)obj)->pickler;

  00049	48 8b 4a 60	 mov	 rcx, QWORD PTR [rdx+96]

; 3749 : 
; 3750 :         new_memo = PyMemoTable_Copy(pickler->memo);

  0004d	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00051	e8 00 00 00 00	 call	 PyMemoTable_Copy
  00056	48 8b f8	 mov	 rdi, rax

; 3751 :         if (new_memo == NULL)

  00059	48 85 c0	 test	 rax, rax
  0005c	0f 84 12 01 00
	00		 je	 $LN23@Pickler_se
$LN7@Pickler_se:

; 3784 :     }
; 3785 : 
; 3786 :     PyMemoTable_Del(self->memo);

  00062	48 8b 4d 60	 mov	 rcx, QWORD PTR [rbp+96]
  00066	e8 00 00 00 00	 call	 PyMemoTable_Del
  0006b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 3787 :     self->memo = new_memo;

  00070	48 89 7d 60	 mov	 QWORD PTR [rbp+96], rdi
  00074	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 3788 : 
; 3789 :     return 0;

  00079	33 c0		 xor	 eax, eax

; 3795 : }

  0007b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007f	5e		 pop	 rsi
  00080	5d		 pop	 rbp
  00081	c3		 ret	 0
$LN13@Pickler_se:

; 3752 :             return -1;
; 3753 :     }
; 3754 :     else if (PyDict_Check(obj)) {

  00082	41 f7 80 00 01
	00 00 00 00 00
	20		 test	 DWORD PTR [r8+256], 536870912 ; 20000000H
  0008d	0f 84 ca 00 00
	00		 je	 $LN10@Pickler_se

; 3755 :         Py_ssize_t i = 0;

  00093	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR i$23079[rsp], 0

; 3756 :         PyObject *key, *value;
; 3757 : 
; 3758 :         new_memo = PyMemoTable_New();

  0009c	e8 00 00 00 00	 call	 PyMemoTable_New
  000a1	48 8b f8	 mov	 rdi, rax

; 3759 :         if (new_memo == NULL)

  000a4	48 85 c0	 test	 rax, rax

; 3760 :             return -1;

  000a7	0f 84 c7 00 00
	00		 je	 $LN23@Pickler_se

; 3761 : 
; 3762 :         while (PyDict_Next(obj, &i, &key, &value)) {

  000ad	4c 8d 4c 24 48	 lea	 r9, QWORD PTR value$23081[rsp]
  000b2	4c 8d 44 24 58	 lea	 r8, QWORD PTR key$23080[rsp]
  000b7	48 8d 54 24 50	 lea	 rdx, QWORD PTR i$23079[rsp]
  000bc	48 8b ce	 mov	 rcx, rsi
  000bf	e8 00 00 00 00	 call	 PyDict_Next
  000c4	85 c0		 test	 eax, eax
  000c6	74 9a		 je	 SHORT $LN7@Pickler_se
  000c8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL8@Pickler_se:

; 3763 :             Py_ssize_t memo_id;
; 3764 :             PyObject *memo_obj;
; 3765 : 
; 3766 :             if (!PyTuple_Check(value) || Py_SIZE(value) != 2) {

  000d0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR value$23081[rsp]
  000d5	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  000d9	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  000e3	74 5b		 je	 SHORT $LN5@Pickler_se
  000e5	48 83 79 60 02	 cmp	 QWORD PTR [rcx+96], 2
  000ea	75 54		 jne	 SHORT $LN5@Pickler_se

; 3769 :                 goto error;
; 3770 :             }
; 3771 :             memo_id = PyLong_AsSsize_t(PyTuple_GET_ITEM(value, 0));

  000ec	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  000f0	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  000f5	48 8b d8	 mov	 rbx, rax

; 3772 :             if (memo_id == -1 && PyErr_Occurred())

  000f8	48 83 f8 ff	 cmp	 rax, -1
  000fc	75 0a		 jne	 SHORT $LN4@Pickler_se
  000fe	e8 00 00 00 00	 call	 PyErr_Occurred
  00103	48 85 c0	 test	 rax, rax
  00106	75 4b		 jne	 SHORT $error$23094
$LN4@Pickler_se:

; 3773 :                 goto error;
; 3774 :             memo_obj = PyTuple_GET_ITEM(value, 1);

  00108	48 8b 4c 24 48	 mov	 rcx, QWORD PTR value$23081[rsp]

; 3775 :             if (PyMemoTable_Set(new_memo, memo_obj, memo_id) < 0)

  0010d	4c 8b c3	 mov	 r8, rbx
  00110	48 8b 51 78	 mov	 rdx, QWORD PTR [rcx+120]
  00114	48 8b cf	 mov	 rcx, rdi
  00117	e8 00 00 00 00	 call	 PyMemoTable_Set
  0011c	85 c0		 test	 eax, eax
  0011e	78 33		 js	 SHORT $error$23094

; 3761 : 
; 3762 :         while (PyDict_Next(obj, &i, &key, &value)) {

  00120	4c 8d 4c 24 48	 lea	 r9, QWORD PTR value$23081[rsp]
  00125	4c 8d 44 24 58	 lea	 r8, QWORD PTR key$23080[rsp]
  0012a	48 8d 54 24 50	 lea	 rdx, QWORD PTR i$23079[rsp]
  0012f	48 8b ce	 mov	 rcx, rsi
  00132	e8 00 00 00 00	 call	 PyDict_Next
  00137	85 c0		 test	 eax, eax
  00139	75 95		 jne	 SHORT $LL8@Pickler_se

; 3775 :             if (PyMemoTable_Set(new_memo, memo_obj, memo_id) < 0)

  0013b	e9 22 ff ff ff	 jmp	 $LN7@Pickler_se
$LN5@Pickler_se:

; 3767 :                 PyErr_SetString(PyExc_TypeError,
; 3768 :                                 "'memo' values must be 2-item tuples");

  00140	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00147	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@JMGPAAF@?8memo?8?5values?5must?5be?52?9item?5tup@
  0014e	e8 00 00 00 00	 call	 PyErr_SetString
$error$23094:

; 3790 : 
; 3791 :   error:
; 3792 :     if (new_memo)
; 3793 :         PyMemoTable_Del(new_memo);

  00153	48 8b cf	 mov	 rcx, rdi
  00156	e8 00 00 00 00	 call	 PyMemoTable_Del

; 3794 :     return -1;

  0015b	eb 17		 jmp	 SHORT $LN23@Pickler_se
$LN10@Pickler_se:

; 3776 :                 goto error;
; 3777 :         }
; 3778 :     }
; 3779 :     else {
; 3780 :         PyErr_Format(PyExc_TypeError,
; 3781 :                      "'memo' attribute must be an PicklerMemoProxy object"
; 3782 :                      "or dict, not %.200s", Py_TYPE(obj)->tp_name);

  0015d	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00161	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00168	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EH@DMODCLIB@?8memo?8?5attribute?5must?5be?5an?5Pick@
  0016f	e8 00 00 00 00	 call	 PyErr_Format
$LN23@Pickler_se:

; 3783 :         return -1;

  00174	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00179	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  0017e	83 c8 ff	 or	 eax, -1

; 3795 : }

  00181	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00185	5e		 pop	 rsi
  00186	5d		 pop	 rbp
  00187	c3		 ret	 0
Pickler_set_memo ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$Pickler_get_persid DD imagerel Pickler_get_persid
	DD	imagerel Pickler_get_persid+130
	DD	imagerel $unwind$Pickler_get_persid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_get_persid DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT Pickler_get_persid
_TEXT	SEGMENT
self$ = 64
Pickler_get_persid PROC					; COMDAT

; 3799 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3800 :     if (self->pers_func == NULL)

  0000a	48 8b 79 68	 mov	 rdi, QWORD PTR [rcx+104]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	48 85 ff	 test	 rdi, rdi
  00014	75 22		 jne	 SHORT $LN2@Pickler_ge

; 3801 :         PyErr_SetString(PyExc_AttributeError, "persistent_id");

  00016	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@IGFLDCPG@persistent_id?$AA@
  00024	e8 00 00 00 00	 call	 PyErr_SetString

; 3804 :     return self->pers_func;

  00029	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]

; 3805 : }

  0002d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00032	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
$LN2@Pickler_ge:

; 3802 :     else
; 3803 :         Py_INCREF(self->pers_func);

  00038	e8 00 00 00 00	 call	 _Py_PXCTX
  0003d	85 c0		 test	 eax, eax
  0003f	75 32		 jne	 SHORT $LN9@Pickler_ge
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0004f	4c 8b cf	 mov	 r9, rdi
  00052	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00058	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00060	e8 00 00 00 00	 call	 _PyParallel_Guard
  00065	85 c0		 test	 eax, eax
  00067	75 06		 jne	 SHORT $LN5@Pickler_ge
  00069	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0006d	74 04		 je	 SHORT $LN9@Pickler_ge
$LN5@Pickler_ge:
  0006f	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN9@Pickler_ge:

; 3804 :     return self->pers_func;

  00073	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]

; 3805 : }

  00077	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0007c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
Pickler_get_persid ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@GNJKJGDK@persistent_id?5must?5be?5a?5callable@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$Pickler_set_persid DD imagerel Pickler_set_persid
	DD	imagerel Pickler_set_persid+202
	DD	imagerel $unwind$Pickler_set_persid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_set_persid DD 066801H
	DD	087468H
	DD	09340aH
	DD	06006520aH
xdata	ENDS
;	COMDAT ??_C@_0DF@GNJKJGDK@persistent_id?5must?5be?5a?5callable@
CONST	SEGMENT
??_C@_0DF@GNJKJGDK@persistent_id?5must?5be?5a?5callable@ DB 'persistent_i'
	DB	'd must be a callable taking one argument', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT Pickler_set_persid
_TEXT	SEGMENT
self$ = 64
value$ = 72
Pickler_set_persid PROC					; COMDAT

; 3809 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f1	 mov	 rsi, rcx

; 3810 :     PyObject *tmp;
; 3811 : 
; 3812 :     if (value == NULL) {

  00010	48 85 d2	 test	 rdx, rdx
  00013	75 21		 jne	 SHORT $LN6@Pickler_se@2

; 3813 :         PyErr_SetString(PyExc_TypeError,
; 3814 :                         "attribute deletion is not supported");

  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KNPPJDNH@attribute?5deletion?5is?5not?5suppor@
  00023	e8 00 00 00 00	 call	 PyErr_SetString

; 3815 :         return -1;

  00028	83 c8 ff	 or	 eax, -1

; 3827 : 
; 3828 :     return 0;
; 3829 : }

  0002b	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00030	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00034	5e		 pop	 rsi
  00035	c3		 ret	 0
$LN6@Pickler_se@2:

; 3816 :     }
; 3817 :     if (!PyCallable_Check(value)) {

  00036	48 8b ca	 mov	 rcx, rdx
  00039	e8 00 00 00 00	 call	 PyCallable_Check
  0003e	85 c0		 test	 eax, eax
  00040	75 21		 jne	 SHORT $LN5@Pickler_se@2

; 3818 :         PyErr_SetString(PyExc_TypeError,
; 3819 :                         "persistent_id must be a callable taking one argument");

  00042	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@GNJKJGDK@persistent_id?5must?5be?5a?5callable@
  00050	e8 00 00 00 00	 call	 PyErr_SetString

; 3820 :         return -1;

  00055	83 c8 ff	 or	 eax, -1

; 3827 : 
; 3828 :     return 0;
; 3829 : }

  00058	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5e		 pop	 rsi
  00062	c3		 ret	 0
$LN5@Pickler_se@2:
  00063	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 3821 :     }
; 3822 : 
; 3823 :     tmp = self->pers_func;

  00068	48 8b 7e 68	 mov	 rdi, QWORD PTR [rsi+104]

; 3824 :     Py_INCREF(value);

  0006c	e8 00 00 00 00	 call	 _Py_PXCTX
  00071	85 c0		 test	 eax, eax
  00073	75 32		 jne	 SHORT $LN10@Pickler_se@2
  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00083	4c 8b cb	 mov	 r9, rbx
  00086	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0008c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00094	e8 00 00 00 00	 call	 _PyParallel_Guard
  00099	85 c0		 test	 eax, eax
  0009b	75 06		 jne	 SHORT $LN9@Pickler_se@2
  0009d	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000a1	74 04		 je	 SHORT $LN10@Pickler_se@2
$LN9@Pickler_se@2:
  000a3	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN10@Pickler_se@2:

; 3825 :     self->pers_func = value;

  000a7	48 89 5e 68	 mov	 QWORD PTR [rsi+104], rbx

; 3826 :     Py_XDECREF(tmp);      /* self->pers_func can be NULL, so be careful. */

  000ab	48 85 ff	 test	 rdi, rdi
  000ae	74 08		 je	 SHORT $LN3@Pickler_se@2
  000b0	48 8b cf	 mov	 rcx, rdi
  000b3	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@Pickler_se@2:

; 3827 : 
; 3828 :     return 0;
; 3829 : }

  000b8	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000bd	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000c2	33 c0		 xor	 eax, eax
  000c4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c8	5e		 pop	 rsi
  000c9	c3		 ret	 0
Pickler_set_persid ENDP
_TEXT	ENDS
PUBLIC	??_C@_02MJJLPNK@OO?$AA@				; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$find_class DD imagerel find_class
	DD	imagerel find_class+57
	DD	imagerel $unwind$find_class
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$find_class DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_02MJJLPNK@OO?$AA@
CONST	SEGMENT
??_C@_02MJJLPNK@OO?$AA@ DB 'OO', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT find_class
_TEXT	SEGMENT
self$ = 64
module_name$ = 72
global_name$ = 80
find_class PROC						; COMDAT

; 3898 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3899 :     _Py_IDENTIFIER(find_class);
; 3900 : 
; 3901 :     return _PyObject_CallMethodId((PyObject *)self, &PyId_find_class, "OO",
; 3902 :                                   module_name, global_name);

  00004	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR _tls_index
  0000b	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00014	4c 8b d2	 mov	 r10, rdx
  00017	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  0001c	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_find_class@?1??find_class@@9@9
  00021	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02MJJLPNK@OO?$AA@
  00028	4a 03 14 c8	 add	 rdx, QWORD PTR [rax+r9*8]
  0002c	4d 8b ca	 mov	 r9, r10
  0002f	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 3903 : }

  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
find_class ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@FHCIFDJG@could?5not?5find?5MARK?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$marker DD imagerel marker
	DD	imagerel marker+74
	DD	imagerel $unwind$marker
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$marker DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BE@FHCIFDJG@could?5not?5find?5MARK?$AA@
CONST	SEGMENT
??_C@_0BE@FHCIFDJG@could?5not?5find?5MARK?$AA@ DB 'could not find MARK', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT marker
_TEXT	SEGMENT
self$ = 48
marker	PROC						; COMDAT

; 3907 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b c1	 mov	 rax, rcx

; 3908 :     if (self->num_marks < 1) {

  00007	48 8b 89 30 01
	00 00		 mov	 rcx, QWORD PTR [rcx+304]
  0000e	48 83 f9 01	 cmp	 rcx, 1
  00012	7d 1c		 jge	 SHORT $LN1@marker

; 3909 :         PyErr_SetString(UnpicklingError, "could not find MARK");

  00014	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@FHCIFDJG@could?5not?5find?5MARK?$AA@
  00022	e8 00 00 00 00	 call	 PyErr_SetString

; 3910 :         return -1;

  00027	48 83 c8 ff	 or	 rax, -1

; 3914 : }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
$LN1@marker:

; 3911 :     }
; 3912 : 
; 3913 :     return self->marks[--self->num_marks];

  00030	48 ff c9	 dec	 rcx
  00033	48 89 88 30 01
	00 00		 mov	 QWORD PTR [rax+304], rcx
  0003a	48 8b 80 28 01
	00 00		 mov	 rax, QWORD PTR [rax+296]
  00041	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]

; 3914 : }

  00045	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00049	c3		 ret	 0
marker	ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$load_none DD imagerel load_none
	DD	imagerel load_none+110
	DD	imagerel $unwind$load_none
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_none DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT load_none
_TEXT	SEGMENT
self$ = 64
load_none PROC						; COMDAT

; 3918 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 3919 :     PDATA_APPEND(self->stack, Py_None, -1);

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 3c		 jne	 SHORT $LN8@load_none
  00012	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00027	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0002d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00035	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003a	85 c0		 test	 eax, eax
  0003c	75 09		 jne	 SHORT $LN7@load_none
  0003e	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00045	74 07		 je	 SHORT $LN8@load_none
$LN7@load_none:
  00047	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN8@load_none:
  0004e	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  00059	e8 00 00 00 00	 call	 Pdata_push
  0005e	33 c9		 xor	 ecx, ecx
  00060	85 c0		 test	 eax, eax
  00062	0f 99 c1	 setns	 cl
  00065	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 3920 :     return 0;
; 3921 : }

  00068	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006c	5b		 pop	 rbx
  0006d	c3		 ret	 0
load_none ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@FOBFDGN@pickle?5data?5was?5truncated?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bad_readline DD imagerel bad_readline
	DD	imagerel bad_readline+31
	DD	imagerel $unwind$bad_readline
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bad_readline DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BK@FOBFDGN@pickle?5data?5was?5truncated?$AA@
CONST	SEGMENT
??_C@_0BK@FOBFDGN@pickle?5data?5was?5truncated?$AA@ DB 'pickle data was t'
	DB	'runcated', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bad_readline
_TEXT	SEGMENT
bad_readline PROC					; COMDAT

; 3925 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3926 :     PyErr_SetString(UnpicklingError, "pickle data was truncated");

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@FOBFDGN@pickle?5data?5was?5truncated?$AA@
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 3927 :     return -1;

  00017	83 c8 ff	 or	 eax, -1

; 3928 : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
bad_readline ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@BGNJIDPO@could?5not?5convert?5string?5to?5int?$AA@ ; `string'
EXTRN	PyLong_FromString:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyBool_FromLong:PROC
EXTRN	__imp_strtol:PROC
EXTRN	__imp__errno:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_int DD imagerel load_int
	DD	imagerel load_int+56
	DD	imagerel $unwind$load_int
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$load_int DD imagerel load_int+56
	DD	imagerel load_int+170
	DD	imagerel $chain$1$load_int
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$load_int DD imagerel load_int+170
	DD	imagerel load_int+202
	DD	imagerel $chain$3$load_int
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$load_int DD imagerel load_int+202
	DD	imagerel load_int+269
	DD	imagerel $chain$5$load_int
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$load_int DD imagerel load_int+269
	DD	imagerel load_int+307
	DD	imagerel $chain$7$load_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$load_int DD 040021H
	DD	046400H
	DD	083400H
	DD	imagerel load_int
	DD	imagerel load_int+56
	DD	imagerel $unwind$load_int
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$load_int DD 040021H
	DD	046400H
	DD	083400H
	DD	imagerel load_int
	DD	imagerel load_int+56
	DD	imagerel $unwind$load_int
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$load_int DD 040021H
	DD	046400H
	DD	083400H
	DD	imagerel load_int
	DD	imagerel load_int+56
	DD	imagerel $unwind$load_int
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$load_int DD 040a21H
	DD	04640aH
	DD	083405H
	DD	imagerel load_int
	DD	imagerel load_int+56
	DD	imagerel $unwind$load_int
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_int DD 030701H
	DD	070034207H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0CA@BGNJIDPO@could?5not?5convert?5string?5to?5int?$AA@
CONST	SEGMENT
??_C@_0CA@BGNJIDPO@could?5not?5convert?5string?5to?5int?$AA@ DB 'could no'
	DB	't convert string to int', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT load_int
_TEXT	SEGMENT
self$ = 64
s$ = 72
endptr$ = 80
load_int PROC						; COMDAT

; 3932 : {

  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3933 :     PyObject *value;
; 3934 :     char *endptr, *s;
; 3935 :     Py_ssize_t len;
; 3936 :     long x;
; 3937 : 
; 3938 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00007	48 8d 54 24 48	 lea	 rdx, QWORD PTR s$[rsp]
  0000c	48 8b e9	 mov	 rbp, rcx
  0000f	e8 00 00 00 00	 call	 _Unpickler_Readline
  00014	48 8b f8	 mov	 rdi, rax
  00017	48 85 c0	 test	 rax, rax
  0001a	79 0a		 jns	 SHORT $LN15@load_int

; 3939 :         return -1;

  0001c	83 c8 ff	 or	 eax, -1

; 3972 :     return 0;
; 3973 : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	5f		 pop	 rdi
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
$LN15@load_int:

; 3940 :     if (len < 2)

  00026	48 83 f8 02	 cmp	 rax, 2
  0002a	7d 0c		 jge	 SHORT $LN14@load_int

; 3941 :         return bad_readline();

  0002c	e8 00 00 00 00	 call	 bad_readline

; 3972 :     return 0;
; 3973 : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	5f		 pop	 rdi
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
$LN14@load_int:
  00038	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0003d	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi

; 3942 : 
; 3943 :     errno = 0;

  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 3944 :     /* XXX: Should the base argument of strtol() be explicitly set to 10?
; 3945 :        XXX(avassalotti): Should this uses PyOS_strtol()? */
; 3946 :     x = strtol(s, &endptr, 0);

  00048	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0004d	48 8d 54 24 50	 lea	 rdx, QWORD PTR endptr$[rsp]
  00052	33 f6		 xor	 esi, esi
  00054	45 33 c0	 xor	 r8d, r8d
  00057	89 30		 mov	 DWORD PTR [rax], esi
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtol
  0005f	8b d8		 mov	 ebx, eax

; 3947 : 
; 3948 :     if (errno || (*endptr != '\n' && *endptr != '\0')) {

  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00067	39 30		 cmp	 DWORD PTR [rax], esi
  00069	75 5f		 jne	 SHORT $LN12@load_int
  0006b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR endptr$[rsp]
  00070	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00073	3c 0a		 cmp	 al, 10
  00075	74 04		 je	 SHORT $LN13@load_int
  00077	84 c0		 test	 al, al
  00079	75 4f		 jne	 SHORT $LN12@load_int
$LN13@load_int:

; 3958 :         }
; 3959 :     }
; 3960 :     else {
; 3961 :         if (len == 3 && (x == 0 || x == 1)) {

  0007b	48 83 ff 03	 cmp	 rdi, 3
  0007f	75 29		 jne	 SHORT $LN9@load_int
  00081	85 db		 test	 ebx, ebx
  00083	74 05		 je	 SHORT $LN8@load_int
  00085	83 fb 01	 cmp	 ebx, 1
  00088	75 20		 jne	 SHORT $LN9@load_int
$LN8@load_int:

; 3962 :             if ((value = PyBool_FromLong(x)) == NULL)

  0008a	8b cb		 mov	 ecx, ebx
  0008c	e8 00 00 00 00	 call	 PyBool_FromLong
  00091	48 85 c0	 test	 rax, rax
  00094	75 77		 jne	 SHORT $LN4@load_int

; 3963 :                 return -1;

  00096	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009b	48 8b 74 24 20	 mov	 rsi, QWORD PTR [rsp+32]
  000a0	83 c8 ff	 or	 eax, -1

; 3972 :     return 0;
; 3973 : }

  000a3	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a7	5f		 pop	 rdi
  000a8	5d		 pop	 rbp
  000a9	c3		 ret	 0
$LN9@load_int:

; 3964 :         }
; 3965 :         else {
; 3966 :             if ((value = PyLong_FromLong(x)) == NULL)

  000aa	8b cb		 mov	 ecx, ebx
  000ac	e8 00 00 00 00	 call	 PyLong_FromLong
  000b1	48 85 c0	 test	 rax, rax
  000b4	75 57		 jne	 SHORT $LN4@load_int

; 3967 :                 return -1;

  000b6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000bb	48 8b 74 24 20	 mov	 rsi, QWORD PTR [rsp+32]
  000c0	83 c8 ff	 or	 eax, -1

; 3972 :     return 0;
; 3973 : }

  000c3	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000c7	5f		 pop	 rdi
  000c8	5d		 pop	 rbp
  000c9	c3		 ret	 0
$LN12@load_int:

; 3949 :         /* Hm, maybe we've got something long.  Let's try reading
; 3950 :          * it as a Python int object. */
; 3951 :         errno = 0;

  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 3952 :         /* XXX: Same thing about the base here. */
; 3953 :         value = PyLong_FromString(s, NULL, 0);

  000d0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  000d5	45 33 c0	 xor	 r8d, r8d
  000d8	33 d2		 xor	 edx, edx
  000da	89 30		 mov	 DWORD PTR [rax], esi
  000dc	e8 00 00 00 00	 call	 PyLong_FromString

; 3954 :         if (value == NULL) {

  000e1	48 85 c0	 test	 rax, rax
  000e4	75 27		 jne	 SHORT $LN4@load_int

; 3955 :             PyErr_SetString(PyExc_ValueError,
; 3956 :                             "could not convert string to int");

  000e6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@BGNJIDPO@could?5not?5convert?5string?5to?5int?$AA@
  000f4	e8 00 00 00 00	 call	 PyErr_SetString
  000f9	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000fe	48 8b 74 24 20	 mov	 rsi, QWORD PTR [rsp+32]

; 3957 :             return -1;

  00103	83 c8 ff	 or	 eax, -1

; 3972 :     return 0;
; 3973 : }

  00106	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010a	5f		 pop	 rdi
  0010b	5d		 pop	 rbp
  0010c	c3		 ret	 0
$LN4@load_int:

; 3968 :         }
; 3969 :     }
; 3970 : 
; 3971 :     PDATA_PUSH(self->stack, value, -1);

  0010d	48 8b 4d 60	 mov	 rcx, QWORD PTR [rbp+96]
  00111	48 8b d0	 mov	 rdx, rax
  00114	e8 00 00 00 00	 call	 Pdata_push
  00119	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0011e	85 c0		 test	 eax, eax
  00120	40 0f 99 c6	 setns	 sil
  00124	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  00127	48 8b 74 24 20	 mov	 rsi, QWORD PTR [rsp+32]

; 3972 :     return 0;
; 3973 : }

  0012c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00130	5f		 pop	 rdi
  00131	5d		 pop	 rbp
  00132	c3		 ret	 0
load_int ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$load_bool DD imagerel load_bool
	DD	imagerel load_bool+108
	DD	imagerel $unwind$load_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_bool DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT load_bool
_TEXT	SEGMENT
self$ = 64
boolean$ = 72
load_bool PROC						; COMDAT

; 3977 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 3978 :     assert(boolean == Py_True || boolean == Py_False);
; 3979 :     PDATA_APPEND(self->stack, boolean, -1);

  00010	e8 00 00 00 00	 call	 _Py_PXCTX
  00015	85 c0		 test	 eax, eax
  00017	75 32		 jne	 SHORT $LN8@load_bool
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00027	4c 8b cb	 mov	 r9, rbx
  0002a	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00030	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00038	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003d	85 c0		 test	 eax, eax
  0003f	75 06		 jne	 SHORT $LN7@load_bool
  00041	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00045	74 04		 je	 SHORT $LN8@load_bool
$LN7@load_bool:
  00047	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN8@load_bool:
  0004b	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  0004f	48 8b d3	 mov	 rdx, rbx
  00052	e8 00 00 00 00	 call	 Pdata_push

; 3980 :     return 0;
; 3981 : }

  00057	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0005c	33 c9		 xor	 ecx, ecx
  0005e	85 c0		 test	 eax, eax
  00060	0f 99 c1	 setns	 cl
  00063	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  00066	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006a	5f		 pop	 rdi
  0006b	c3		 ret	 0
load_bool ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT calc_binsize
_TEXT	SEGMENT
bytes$ = 8
calc_binsize PROC					; COMDAT

; 3989 :     unsigned char *s = (unsigned char *)bytes;
; 3990 :     size_t x = 0;
; 3991 : 
; 3992 :     assert(size == 4);
; 3993 : 
; 3994 :     x =  (size_t) s[0];
; 3995 :     x |= (size_t) s[1] << 8;
; 3996 :     x |= (size_t) s[2] << 16;
; 3997 :     x |= (size_t) s[3] << 24;

  00000	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  00004	44 0f b6 41 03	 movzx	 r8d, BYTE PTR [rcx+3]
  00009	0f b6 51 01	 movzx	 edx, BYTE PTR [rcx+1]
  0000d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00010	49 c1 e0 08	 shl	 r8, 8
  00014	4c 0b c0	 or	 r8, rax

; 3998 : 
; 3999 :     if (x > PY_SSIZE_T_MAX)

  00017	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00021	49 c1 e0 08	 shl	 r8, 8
  00025	4c 0b c2	 or	 r8, rdx
  00028	49 c1 e0 08	 shl	 r8, 8
  0002c	4c 0b c1	 or	 r8, rcx
  0002f	48 83 c9 ff	 or	 rcx, -1
  00033	4c 3b c0	 cmp	 r8, rax
  00036	4c 0f 47 c1	 cmova	 r8, rcx
  0003a	49 8b c0	 mov	 rax, r8

; 4000 :         return -1;
; 4001 :     else
; 4002 :         return (Py_ssize_t) x;
; 4003 : }

  0003d	c3		 ret	 0
calc_binsize ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT calc_binint
_TEXT	SEGMENT
bytes$ = 8
size$ = 16
calc_binint PROC					; COMDAT

; 4013 :     unsigned char *s = (unsigned char *)bytes;
; 4014 :     int i = size;
; 4015 :     long x = 0;

  00000	33 c0		 xor	 eax, eax
  00002	4c 8b c1	 mov	 r8, rcx

; 4016 : 
; 4017 :     for (i = 0; i < size; i++) {

  00005	85 d2		 test	 edx, edx
  00007	7e 1a		 jle	 SHORT $LN9@calc_binin

; 4013 :     unsigned char *s = (unsigned char *)bytes;
; 4014 :     int i = size;
; 4015 :     long x = 0;

  00009	8b c8		 mov	 ecx, eax
  0000b	44 8b ca	 mov	 r9d, edx
  0000e	66 90		 npad	 2
$LL4@calc_binin:

; 4018 :         x |= (long)s[i] << (i * 8);

  00010	41 0f b6 10	 movzx	 edx, BYTE PTR [r8]
  00014	49 ff c0	 inc	 r8
  00017	d3 e2		 shl	 edx, cl
  00019	83 c1 08	 add	 ecx, 8
  0001c	0b c2		 or	 eax, edx
  0001e	49 ff c9	 dec	 r9
  00021	75 ed		 jne	 SHORT $LL4@calc_binin
$LN9@calc_binin:

; 4019 :     }
; 4020 : 
; 4021 :     /* Unlike BININT1 and BININT2, BININT (more accurately BININT4)
; 4022 :      * is signed, so on a box with longs bigger than 4 bytes we need
; 4023 :      * to extend a BININT's sign bit to the full width.
; 4024 :      */
; 4025 :     if (SIZEOF_LONG > 4 && size == 4) {
; 4026 :         x |= -(x & (1L << 31));
; 4027 :     }
; 4028 : 
; 4029 :     return x;
; 4030 : }

  00023	f3 c3		 fatret	 0
calc_binint ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binintx DD imagerel load_binintx
	DD	imagerel load_binintx+72
	DD	imagerel $unwind$load_binintx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binintx DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_binintx
_TEXT	SEGMENT
self$ = 48
s$ = 56
size$ = 64
load_binintx PROC					; COMDAT

; 4034 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 4035 :     PyObject *value;
; 4036 :     long x;
; 4037 : 
; 4038 :     x = calc_binint(s, size);

  0000c	41 8b d0	 mov	 edx, r8d
  0000f	48 8b c8	 mov	 rcx, rax
  00012	e8 00 00 00 00	 call	 calc_binint

; 4039 : 
; 4040 :     if ((value = PyLong_FromLong(x)) == NULL)

  00017	8b c8		 mov	 ecx, eax
  00019	e8 00 00 00 00	 call	 PyLong_FromLong
  0001e	48 85 c0	 test	 rax, rax
  00021	75 09		 jne	 SHORT $LN4@load_binin

; 4041 :         return -1;

  00023	83 c8 ff	 or	 eax, -1

; 4044 :     return 0;
; 4045 : }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
$LN4@load_binin:

; 4042 : 
; 4043 :     PDATA_PUSH(self->stack, value, -1);

  0002c	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00030	48 8b d0	 mov	 rdx, rax
  00033	e8 00 00 00 00	 call	 Pdata_push
  00038	33 c9		 xor	 ecx, ecx
  0003a	85 c0		 test	 eax, eax
  0003c	0f 99 c1	 setns	 cl
  0003f	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4044 :     return 0;
; 4045 : }

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5b		 pop	 rbx
  00047	c3		 ret	 0
load_binintx ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binint DD imagerel load_binint
	DD	imagerel load_binint+63
	DD	imagerel $unwind$load_binint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binint DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_binint
_TEXT	SEGMENT
self$ = 48
s$ = 56
load_binint PROC					; COMDAT

; 4049 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4050 :     char *s;
; 4051 : 
; 4052 :     if (_Unpickler_Read(self, &s, 4) < 0)

  00006	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00011	48 8b d9	 mov	 rbx, rcx
  00014	e8 00 00 00 00	 call	 _Unpickler_Read
  00019	48 85 c0	 test	 rax, rax
  0001c	79 09		 jns	 SHORT $LN1@load_binin@2

; 4053 :         return -1;

  0001e	83 c8 ff	 or	 eax, -1

; 4056 : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
$LN1@load_binin@2:

; 4054 : 
; 4055 :     return load_binintx(self, s, 4);

  00027	48 8b 54 24 38	 mov	 rdx, QWORD PTR s$[rsp]
  0002c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00032	48 8b cb	 mov	 rcx, rbx

; 4056 : }

  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5b		 pop	 rbx
  0003a	e9 00 00 00 00	 jmp	 load_binintx
load_binint ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binint1 DD imagerel load_binint1
	DD	imagerel load_binint1+63
	DD	imagerel $unwind$load_binint1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binint1 DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_binint1
_TEXT	SEGMENT
self$ = 48
s$ = 56
load_binint1 PROC					; COMDAT

; 4060 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4061 :     char *s;
; 4062 : 
; 4063 :     if (_Unpickler_Read(self, &s, 1) < 0)

  00006	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00011	48 8b d9	 mov	 rbx, rcx
  00014	e8 00 00 00 00	 call	 _Unpickler_Read
  00019	48 85 c0	 test	 rax, rax
  0001c	79 09		 jns	 SHORT $LN1@load_binin@3

; 4064 :         return -1;

  0001e	83 c8 ff	 or	 eax, -1

; 4067 : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
$LN1@load_binin@3:

; 4065 : 
; 4066 :     return load_binintx(self, s, 1);

  00027	48 8b 54 24 38	 mov	 rdx, QWORD PTR s$[rsp]
  0002c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00032	48 8b cb	 mov	 rcx, rbx

; 4067 : }

  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5b		 pop	 rbx
  0003a	e9 00 00 00 00	 jmp	 load_binintx
load_binint1 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binint2 DD imagerel load_binint2
	DD	imagerel load_binint2+63
	DD	imagerel $unwind$load_binint2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binint2 DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_binint2
_TEXT	SEGMENT
self$ = 48
s$ = 56
load_binint2 PROC					; COMDAT

; 4071 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4072 :     char *s;
; 4073 : 
; 4074 :     if (_Unpickler_Read(self, &s, 2) < 0)

  00006	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00011	48 8b d9	 mov	 rbx, rcx
  00014	e8 00 00 00 00	 call	 _Unpickler_Read
  00019	48 85 c0	 test	 rax, rax
  0001c	79 09		 jns	 SHORT $LN1@load_binin@4

; 4075 :         return -1;

  0001e	83 c8 ff	 or	 eax, -1

; 4078 : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
$LN1@load_binin@4:

; 4076 : 
; 4077 :     return load_binintx(self, s, 2);

  00027	48 8b 54 24 38	 mov	 rdx, QWORD PTR s$[rsp]
  0002c	41 b8 02 00 00
	00		 mov	 r8d, 2
  00032	48 8b cb	 mov	 rcx, rbx

; 4078 : }

  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5b		 pop	 rbx
  0003a	e9 00 00 00 00	 jmp	 load_binintx
load_binint2 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_long DD imagerel load_long
	DD	imagerel load_long+109
	DD	imagerel $unwind$load_long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_long DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_long
_TEXT	SEGMENT
self$ = 48
s$ = 56
load_long PROC						; COMDAT

; 4082 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4083 :     PyObject *value;
; 4084 :     char *s;
; 4085 :     Py_ssize_t len;
; 4086 : 
; 4087 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00006	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	e8 00 00 00 00	 call	 _Unpickler_Readline
  00013	48 85 c0	 test	 rax, rax
  00016	79 09		 jns	 SHORT $LN8@load_long
$LN11@load_long:

; 4088 :         return -1;

  00018	83 c8 ff	 or	 eax, -1

; 4104 :     return 0;
; 4105 : }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
$LN8@load_long:

; 4089 :     if (len < 2)

  00021	48 83 f8 02	 cmp	 rax, 2
  00025	7d 0a		 jge	 SHORT $LN7@load_long

; 4104 :     return 0;
; 4105 : }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx
  0002c	e9 00 00 00 00	 jmp	 bad_readline
$LN7@load_long:

; 4090 :         return bad_readline();
; 4091 : 
; 4092 :     /* s[len-2] will usually be 'L' (and s[len-1] is '\n'); we need to remove
; 4093 :        the 'L' before calling PyLong_FromString.  In order to maintain
; 4094 :        compatibility with Python 3.0.0, we don't actually *require*
; 4095 :        the 'L' to be present. */
; 4096 :     if (s[len-2] == 'L')

  00031	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00036	80 7c 01 fe 4c	 cmp	 BYTE PTR [rcx+rax-2], 76 ; 0000004cH
  0003b	75 05		 jne	 SHORT $LN6@load_long

; 4097 :         s[len-2] = '\0';

  0003d	c6 44 01 fe 00	 mov	 BYTE PTR [rcx+rax-2], 0
$LN6@load_long:

; 4098 :     /* XXX: Should the base argument explicitly set to 10? */
; 4099 :     value = PyLong_FromString(s, NULL, 0);

  00042	45 33 c0	 xor	 r8d, r8d
  00045	33 d2		 xor	 edx, edx
  00047	e8 00 00 00 00	 call	 PyLong_FromString

; 4100 :     if (value == NULL)

  0004c	48 85 c0	 test	 rax, rax

; 4101 :         return -1;

  0004f	74 c7		 je	 SHORT $LN11@load_long

; 4102 : 
; 4103 :     PDATA_PUSH(self->stack, value, -1);

  00051	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00055	48 8b d0	 mov	 rdx, rax
  00058	e8 00 00 00 00	 call	 Pdata_push
  0005d	33 c9		 xor	 ecx, ecx
  0005f	85 c0		 test	 eax, eax
  00061	0f 99 c1	 setns	 cl
  00064	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4104 :     return 0;
; 4105 : }

  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5b		 pop	 rbx
  0006c	c3		 ret	 0
load_long ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@IHNPBLEL@LONG?5pickle?5has?5negative?5byte?5co@ ; `string'
EXTRN	_PyLong_FromByteArray:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_counted_long DD imagerel load_counted_long
	DD	imagerel load_counted_long+178
	DD	imagerel $unwind$load_counted_long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_counted_long DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0CE@IHNPBLEL@LONG?5pickle?5has?5negative?5byte?5co@
CONST	SEGMENT
??_C@_0CE@IHNPBLEL@LONG?5pickle?5has?5negative?5byte?5co@ DB 'LONG pickle'
	DB	' has negative byte count', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT load_counted_long
_TEXT	SEGMENT
self$ = 48
size$ = 56
pdata$ = 64
nbytes$ = 64
load_counted_long PROC					; COMDAT

; 4112 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 da	 movsxd	 rbx, edx

; 4113 :     PyObject *value;
; 4114 :     char *nbytes;
; 4115 :     char *pdata;
; 4116 : 
; 4117 :     assert(size == 1 || size == 4);
; 4118 :     if (_Unpickler_Read(self, &nbytes, size) < 0)

  0000d	48 8d 54 24 40	 lea	 rdx, QWORD PTR nbytes$[rsp]
  00012	48 8b f9	 mov	 rdi, rcx
  00015	4c 8b c3	 mov	 r8, rbx
  00018	e8 00 00 00 00	 call	 _Unpickler_Read
  0001d	48 85 c0	 test	 rax, rax

; 4119 :         return -1;

  00020	78 23		 js	 SHORT $LN14@load_count

; 4120 : 
; 4121 :     size = calc_binint(nbytes, size);

  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR nbytes$[rsp]
  00027	8b d3		 mov	 edx, ebx
  00029	e8 00 00 00 00	 call	 calc_binint

; 4122 :     if (size < 0) {

  0002e	85 c0		 test	 eax, eax
  00030	79 21		 jns	 SHORT $LN13@load_count

; 4123 :         /* Corrupt or hostile pickle -- we never write one like this */
; 4124 :         PyErr_SetString(UnpicklingError,
; 4125 :                         "LONG pickle has negative byte count");

  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@IHNPBLEL@LONG?5pickle?5has?5negative?5byte?5co@
  00040	e8 00 00 00 00	 call	 PyErr_SetString
$LN14@load_count:

; 4126 :         return -1;

  00045	83 c8 ff	 or	 eax, -1

; 4141 :     return 0;
; 4142 : }

  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
$LN13@load_count:

; 4127 :     }
; 4128 : 
; 4129 :     if (size == 0)

  00053	75 09		 jne	 SHORT $LN8@load_count

; 4130 :         value = PyLong_FromLong(0L);

  00055	33 c9		 xor	 ecx, ecx
  00057	e8 00 00 00 00	 call	 PyLong_FromLong

; 4131 :     else {

  0005c	eb 2e		 jmp	 SHORT $LN7@load_count
$LN8@load_count:

; 4132 :         /* Read the raw little-endian bytes and convert. */
; 4133 :         if (_Unpickler_Read(self, &pdata, size) < 0)

  0005e	48 63 d8	 movsxd	 rbx, eax
  00061	48 8d 54 24 40	 lea	 rdx, QWORD PTR pdata$[rsp]
  00066	48 8b cf	 mov	 rcx, rdi
  00069	4c 8b c3	 mov	 r8, rbx
  0006c	e8 00 00 00 00	 call	 _Unpickler_Read
  00071	48 85 c0	 test	 rax, rax

; 4134 :             return -1;

  00074	78 cf		 js	 SHORT $LN14@load_count

; 4135 :         value = _PyLong_FromByteArray((unsigned char *)pdata, (size_t)size,
; 4136 :                                       1 /* little endian */ , 1 /* signed */ );

  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pdata$[rsp]
  0007b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00081	48 8b d3	 mov	 rdx, rbx
  00084	45 8b c1	 mov	 r8d, r9d
  00087	e8 00 00 00 00	 call	 _PyLong_FromByteArray
$LN7@load_count:

; 4137 :     }
; 4138 :     if (value == NULL)

  0008c	48 85 c0	 test	 rax, rax

; 4139 :         return -1;

  0008f	74 b4		 je	 SHORT $LN14@load_count

; 4140 :     PDATA_PUSH(self->stack, value, -1);

  00091	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  00095	48 8b d0	 mov	 rdx, rax
  00098	e8 00 00 00 00	 call	 Pdata_push

; 4141 :     return 0;
; 4142 : }

  0009d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a2	33 c9		 xor	 ecx, ecx
  000a4	85 c0		 test	 eax, eax
  000a6	0f 99 c1	 setns	 cl
  000a9	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  000ac	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b0	5f		 pop	 rdi
  000b1	c3		 ret	 0
load_counted_long ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@PAEGCELO@could?5not?5convert?5string?5to?5floa@ ; `string'
PUBLIC	__real@bff0000000000000
EXTRN	PyFloat_FromDouble:PROC
EXTRN	PyOS_string_to_double:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_float DD imagerel load_float
	DD	imagerel load_float+50
	DD	imagerel $unwind$load_float
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$load_float DD imagerel load_float+50
	DD	imagerel load_float+173
	DD	imagerel $chain$1$load_float
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$load_float DD imagerel load_float+173
	DD	imagerel load_float+223
	DD	imagerel $chain$3$load_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$load_float DD 040021H
	DD	026800H
	DD	083400H
	DD	imagerel load_float
	DD	imagerel load_float+50
	DD	imagerel $unwind$load_float
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$load_float DD 040a21H
	DD	02680aH
	DD	083405H
	DD	imagerel load_float
	DD	imagerel load_float+50
	DD	imagerel $unwind$load_float
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_float DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_0CC@PAEGCELO@could?5not?5convert?5string?5to?5floa@
CONST	SEGMENT
??_C@_0CC@PAEGCELO@could?5not?5convert?5string?5to?5floa@ DB 'could not c'
	DB	'onvert string to float', 00H		; `string'
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT load_float
_TEXT	SEGMENT
self$ = 64
s$ = 72
endptr$ = 80
load_float PROC						; COMDAT

; 4146 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 4147 :     PyObject *value;
; 4148 :     char *endptr, *s;
; 4149 :     Py_ssize_t len;
; 4150 :     double d;
; 4151 : 
; 4152 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00006	48 8d 54 24 48	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	48 8b f9	 mov	 rdi, rcx
  0000e	e8 00 00 00 00	 call	 _Unpickler_Readline
  00013	48 85 c0	 test	 rax, rax
  00016	79 09		 jns	 SHORT $LN9@load_float

; 4153 :         return -1;

  00018	83 c8 ff	 or	 eax, -1

; 4170 :     return 0;
; 4171 : }

  0001b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001f	5f		 pop	 rdi
  00020	c3		 ret	 0
$LN9@load_float:

; 4154 :     if (len < 2)

  00021	48 83 f8 02	 cmp	 rax, 2
  00025	7d 0b		 jge	 SHORT $LN8@load_float

; 4155 :         return bad_readline();

  00027	e8 00 00 00 00	 call	 bad_readline

; 4170 :     return 0;
; 4171 : }

  0002c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN8@load_float:
  00032	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00037	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6

; 4156 : 
; 4157 :     errno = 0;

  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 4158 :     d = PyOS_string_to_double(s, &endptr, PyExc_OverflowError);

  00042	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00047	33 db		 xor	 ebx, ebx
  00049	48 8d 54 24 50	 lea	 rdx, QWORD PTR endptr$[rsp]
  0004e	89 18		 mov	 DWORD PTR [rax], ebx
  00050	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR PyExc_OverflowError
  00057	e8 00 00 00 00	 call	 PyOS_string_to_double

; 4159 :     if (d == -1.0 && PyErr_Occurred())

  0005c	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00064	66 0f 28 f0	 movapd	 xmm6, xmm0
  00068	7a 0c		 jp	 SHORT $LN7@load_float
  0006a	75 0a		 jne	 SHORT $LN7@load_float
  0006c	e8 00 00 00 00	 call	 PyErr_Occurred
  00071	48 85 c0	 test	 rax, rax

; 4160 :         return -1;

  00074	75 24		 jne	 SHORT $LN14@load_float
$LN7@load_float:

; 4161 :     if ((endptr[0] != '\n') && (endptr[0] != '\0')) {

  00076	48 8b 44 24 50	 mov	 rax, QWORD PTR endptr$[rsp]
  0007b	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0007e	80 f9 0a	 cmp	 cl, 10
  00081	74 2a		 je	 SHORT $LN6@load_float
  00083	84 c9		 test	 cl, cl
  00085	74 26		 je	 SHORT $LN6@load_float

; 4162 :         PyErr_SetString(PyExc_ValueError, "could not convert string to float");

  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@PAEGCELO@could?5not?5convert?5string?5to?5floa@
  00095	e8 00 00 00 00	 call	 PyErr_SetString
$LN14@load_float:

; 4163 :         return -1;

  0009a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009f	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000a4	83 c8 ff	 or	 eax, -1

; 4170 :     return 0;
; 4171 : }

  000a7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ab	5f		 pop	 rdi
  000ac	c3		 ret	 0
$LN6@load_float:

; 4164 :     }
; 4165 :     value = PyFloat_FromDouble(d);

  000ad	66 0f 28 c6	 movapd	 xmm0, xmm6
  000b1	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 4166 :     if (value == NULL)

  000b6	48 85 c0	 test	 rax, rax

; 4167 :         return -1;

  000b9	74 df		 je	 SHORT $LN14@load_float

; 4168 : 
; 4169 :     PDATA_PUSH(self->stack, value, -1);

  000bb	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  000bf	48 8b d0	 mov	 rdx, rax
  000c2	e8 00 00 00 00	 call	 Pdata_push
  000c7	85 c0		 test	 eax, eax
  000c9	0f 99 c3	 setns	 bl
  000cc	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000d1	8d 43 ff	 lea	 eax, DWORD PTR [rbx-1]
  000d4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 4170 :     return 0;
; 4171 : }

  000d9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000dd	5f		 pop	 rdi
  000de	c3		 ret	 0
load_float ENDP
_TEXT	ENDS
EXTRN	_PyFloat_Unpack8:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binfloat DD imagerel load_binfloat
	DD	imagerel load_binfloat+46
	DD	imagerel $unwind$load_binfloat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$load_binfloat DD imagerel load_binfloat+46
	DD	imagerel load_binfloat+110
	DD	imagerel $chain$0$load_binfloat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$load_binfloat DD imagerel load_binfloat+110
	DD	imagerel load_binfloat+143
	DD	imagerel $chain$2$load_binfloat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$load_binfloat DD 020021H
	DD	026800H
	DD	imagerel load_binfloat
	DD	imagerel load_binfloat+46
	DD	imagerel $unwind$load_binfloat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$load_binfloat DD 020521H
	DD	026805H
	DD	imagerel load_binfloat
	DD	imagerel load_binfloat+46
	DD	imagerel $unwind$load_binfloat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binfloat DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_binfloat
_TEXT	SEGMENT
self$ = 64
s$ = 72
load_binfloat PROC					; COMDAT

; 4175 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 4176 :     PyObject *value;
; 4177 :     double x;
; 4178 :     char *s;
; 4179 : 
; 4180 :     if (_Unpickler_Read(self, &s, 8) < 0)

  00006	48 8d 54 24 48	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	41 b8 08 00 00
	00		 mov	 r8d, 8
  00011	48 8b d9	 mov	 rbx, rcx
  00014	e8 00 00 00 00	 call	 _Unpickler_Read
  00019	48 85 c0	 test	 rax, rax
  0001c	79 09		 jns	 SHORT $LN7@load_binfl

; 4181 :         return -1;

  0001e	83 c8 ff	 or	 eax, -1

; 4191 :     return 0;
; 4192 : }

  00021	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
$LN7@load_binfl:

; 4182 : 
; 4183 :     x = _PyFloat_Unpack8((unsigned char *)s, 0);

  00027	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	33 d2		 xor	 edx, edx
  0002e	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  00033	e8 00 00 00 00	 call	 _PyFloat_Unpack8

; 4184 :     if (x == -1.0 && PyErr_Occurred())

  00038	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00040	66 0f 28 f0	 movapd	 xmm6, xmm0
  00044	7a 0c		 jp	 SHORT $LN6@load_binfl
  00046	75 0a		 jne	 SHORT $LN6@load_binfl
  00048	e8 00 00 00 00	 call	 PyErr_Occurred
  0004d	48 85 c0	 test	 rax, rax

; 4185 :         return -1;

  00050	75 0e		 jne	 SHORT $LN11@load_binfl
$LN6@load_binfl:

; 4186 : 
; 4187 :     if ((value = PyFloat_FromDouble(x)) == NULL)

  00052	66 0f 28 c6	 movapd	 xmm0, xmm6
  00056	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0005b	48 85 c0	 test	 rax, rax
  0005e	75 0e		 jne	 SHORT $LN4@load_binfl
$LN11@load_binfl:

; 4188 :         return -1;

  00060	83 c8 ff	 or	 eax, -1
  00063	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]

; 4191 :     return 0;
; 4192 : }

  00068	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006c	5b		 pop	 rbx
  0006d	c3		 ret	 0
$LN4@load_binfl:

; 4189 : 
; 4190 :     PDATA_PUSH(self->stack, value, -1);

  0006e	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00072	48 8b d0	 mov	 rdx, rax
  00075	e8 00 00 00 00	 call	 Pdata_push
  0007a	33 c9		 xor	 ecx, ecx
  0007c	85 c0		 test	 eax, eax
  0007e	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00083	0f 99 c1	 setns	 cl
  00086	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4191 :     return 0;
; 4192 : }

  00089	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008d	5b		 pop	 rbx
  0008e	c3		 ret	 0
load_binfloat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@PIAJHIOC@insecure?5string?5pickle?$AA@ ; `string'
EXTRN	PyUnicode_FromEncodedObject:PROC
EXTRN	PyBytes_DecodeEscape:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_string DD imagerel load_string
	DD	imagerel load_string+60
	DD	imagerel $unwind$load_string
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$load_string DD imagerel load_string+60
	DD	imagerel load_string+99
	DD	imagerel $chain$0$load_string
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$load_string DD imagerel load_string+99
	DD	imagerel load_string+284
	DD	imagerel $chain$4$load_string
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$load_string DD imagerel load_string+284
	DD	imagerel load_string+307
	DD	imagerel $chain$6$load_string
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$load_string DD imagerel load_string+307
	DD	imagerel load_string+350
	DD	imagerel $chain$7$load_string
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$load_string DD 020021H
	DD	0c7400H
	DD	imagerel load_string
	DD	imagerel load_string+60
	DD	imagerel $unwind$load_string
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$load_string DD 060021H
	DD	06c400H
	DD	0c7400H
	DD	0a6400H
	DD	imagerel load_string
	DD	imagerel load_string+60
	DD	imagerel $unwind$load_string
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$load_string DD 065f21H
	DD	06c45fH
	DD	0a6447H
	DD	0c7400H
	DD	imagerel load_string
	DD	imagerel load_string+60
	DD	imagerel $unwind$load_string
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$load_string DD 020521H
	DD	0c7405H
	DD	imagerel load_string
	DD	imagerel load_string+60
	DD	imagerel $unwind$load_string
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_string DD 030701H
	DD	050036207H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_0BH@PIAJHIOC@insecure?5string?5pickle?$AA@
CONST	SEGMENT
??_C@_0BH@PIAJHIOC@insecure?5string?5pickle?$AA@ DB 'insecure string pick'
	DB	'le', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT load_string
_TEXT	SEGMENT
self$ = 80
s$ = 88
load_string PROC					; COMDAT

; 4196 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4197 :     PyObject *bytes;
; 4198 :     PyObject *str = NULL;
; 4199 :     Py_ssize_t len;
; 4200 :     char *s, *p;
; 4201 : 
; 4202 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00007	48 8d 54 24 58	 lea	 rdx, QWORD PTR s$[rsp]
  0000c	48 8b e9	 mov	 rbp, rcx
  0000f	e8 00 00 00 00	 call	 _Unpickler_Readline
  00014	48 8b d8	 mov	 rbx, rax
  00017	48 85 c0	 test	 rax, rax
  0001a	79 0a		 jns	 SHORT $LN15@load_strin

; 4203 :         return -1;

  0001c	83 c8 ff	 or	 eax, -1

; 4243 : }

  0001f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00023	5d		 pop	 rbp
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
$LN15@load_strin:

; 4204 :     if (len < 2)

  00026	48 83 f8 02	 cmp	 rax, 2
  0002a	7d 0b		 jge	 SHORT $LN14@load_strin

; 4243 : }

  0002c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00030	5d		 pop	 rbp
  00031	5b		 pop	 rbx
  00032	e9 00 00 00 00	 jmp	 bad_readline
$LN14@load_strin:

; 4205 :         return bad_readline();
; 4206 :     if ((s = strdup(s)) == NULL) {

  00037	48 8b 4c 24 58	 mov	 rcx, QWORD PTR s$[rsp]
  0003c	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00047	48 8b f8	 mov	 rdi, rax
  0004a	48 85 c0	 test	 rax, rax
  0004d	75 14		 jne	 SHORT $LN18@load_strin

; 4207 :         PyErr_NoMemory();

  0004f	e8 00 00 00 00	 call	 PyErr_NoMemory
  00054	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]

; 4208 :         return -1;

  00059	83 c8 ff	 or	 eax, -1

; 4243 : }

  0005c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00060	5d		 pop	 rbp
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
$LN18@load_strin:

; 4209 :     }
; 4210 : 
; 4211 :     /* Strip outermost quotes */
; 4212 :     while (len > 0 && s[len - 1] <= ' ')

  00063	48 85 db	 test	 rbx, rbx
  00066	7e 0f		 jle	 SHORT $LN20@load_strin
$LL12@load_strin:
  00068	80 7c 18 ff 20	 cmp	 BYTE PTR [rax+rbx-1], 32 ; 00000020H
  0006d	7f 08		 jg	 SHORT $LN20@load_strin

; 4213 :         len--;

  0006f	48 ff cb	 dec	 rbx
  00072	48 85 db	 test	 rbx, rbx
  00075	7f f1		 jg	 SHORT $LL12@load_strin
$LN20@load_strin:

; 4214 :     if (len > 1 && s[0] == '"' && s[len - 1] == '"') {

  00077	48 83 fb 01	 cmp	 rbx, 1
  0007b	0f 8e b2 00 00
	00		 jle	 $LN8@load_strin
  00081	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00084	3c 22		 cmp	 al, 34			; 00000022H
  00086	75 06		 jne	 SHORT $LN10@load_strin
  00088	38 44 1f ff	 cmp	 BYTE PTR [rdi+rbx-1], al

; 4215 :         s[len - 1] = '\0';
; 4216 :         p = s + 1;
; 4217 :         len -= 2;

  0008c	74 12		 je	 SHORT $LN24@load_strin
$LN10@load_strin:

; 4218 :     }
; 4219 :     else if (len > 1 && s[0] == '\'' && s[len - 1] == '\'') {

  0008e	3c 27		 cmp	 al, 39			; 00000027H
  00090	0f 85 9d 00 00
	00		 jne	 $LN8@load_strin
  00096	38 44 1f ff	 cmp	 BYTE PTR [rdi+rbx-1], al
  0009a	0f 85 93 00 00
	00		 jne	 $LN8@load_strin
$LN24@load_strin:

; 4220 :         s[len - 1] = '\0';

  000a0	c6 44 1f ff 00	 mov	 BYTE PTR [rdi+rbx-1], 0
  000a5	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi

; 4221 :         p = s + 1;
; 4222 :         len -= 2;

  000aa	48 83 eb 02	 sub	 rbx, 2
  000ae	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]

; 4228 :     }
; 4229 : 
; 4230 :     /* Use the PyBytes API to decode the string, since that is what is used
; 4231 :        to encode, and then coerce the result to Unicode. */
; 4232 :     bytes = PyBytes_DecodeEscape(p, len, NULL, 0, NULL);

  000b2	33 f6		 xor	 esi, esi
  000b4	45 33 c9	 xor	 r9d, r9d
  000b7	48 8b d3	 mov	 rdx, rbx
  000ba	45 33 c0	 xor	 r8d, r8d
  000bd	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  000c2	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  000c7	e8 00 00 00 00	 call	 PyBytes_DecodeEscape

; 4233 :     free(s);

  000cc	48 8b cf	 mov	 rcx, rdi
  000cf	4c 8b e0	 mov	 r12, rax
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4234 :     if (bytes == NULL)

  000d8	4d 85 e4	 test	 r12, r12

; 4235 :         return -1;

  000db	74 26		 je	 SHORT $LN25@load_strin

; 4236 :     str = PyUnicode_FromEncodedObject(bytes, self->encoding, self->errors);

  000dd	4c 8b 85 20 01
	00 00		 mov	 r8, QWORD PTR [rbp+288]
  000e4	48 8b 95 18 01
	00 00		 mov	 rdx, QWORD PTR [rbp+280]
  000eb	49 8b cc	 mov	 rcx, r12
  000ee	e8 00 00 00 00	 call	 PyUnicode_FromEncodedObject

; 4237 :     Py_DECREF(bytes);

  000f3	49 8b cc	 mov	 rcx, r12
  000f6	48 8b d8	 mov	 rbx, rax
  000f9	e8 00 00 00 00	 call	 _Py_DecRef

; 4238 :     if (str == NULL)

  000fe	48 85 db	 test	 rbx, rbx
  00101	75 19		 jne	 SHORT $LN4@load_strin
$LN25@load_strin:

; 4239 :         return -1;

  00103	83 c8 ff	 or	 eax, -1
$LN23@load_strin:
  00106	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0010b	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]
  00110	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]

; 4243 : }

  00115	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00119	5d		 pop	 rbp
  0011a	5b		 pop	 rbx
  0011b	c3		 ret	 0
$LN4@load_strin:

; 4240 : 
; 4241 :     PDATA_PUSH(self->stack, str, -1);

  0011c	48 8b 4d 60	 mov	 rcx, QWORD PTR [rbp+96]
  00120	48 8b d3	 mov	 rdx, rbx
  00123	e8 00 00 00 00	 call	 Pdata_push
  00128	85 c0		 test	 eax, eax
  0012a	40 0f 99 c6	 setns	 sil
  0012e	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]

; 4242 :     return 0;

  00131	eb d3		 jmp	 SHORT $LN23@load_strin
$LN8@load_strin:

; 4223 :     }
; 4224 :     else {
; 4225 :         free(s);

  00133	48 8b cf	 mov	 rcx, rdi
  00136	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4226 :         PyErr_SetString(PyExc_ValueError, "insecure string pickle");

  0013c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@PIAJHIOC@insecure?5string?5pickle?$AA@
  0014a	e8 00 00 00 00	 call	 PyErr_SetString
  0014f	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]

; 4227 :         return -1;

  00154	83 c8 ff	 or	 eax, -1

; 4243 : }

  00157	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0015b	5d		 pop	 rbp
  0015c	5b		 pop	 rbx
  0015d	c3		 ret	 0
load_string ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@FALDIICK@BINBYTES?5exceeds?5system?8s?5maximu@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binbytes DD imagerel load_binbytes
	DD	imagerel load_binbytes+44
	DD	imagerel $unwind$load_binbytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$load_binbytes DD imagerel load_binbytes+44
	DD	imagerel load_binbytes+105
	DD	imagerel $chain$0$load_binbytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$load_binbytes DD imagerel load_binbytes+105
	DD	imagerel load_binbytes+177
	DD	imagerel $chain$2$load_binbytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$load_binbytes DD 020021H
	DD	063400H
	DD	imagerel load_binbytes
	DD	imagerel load_binbytes+44
	DD	imagerel $unwind$load_binbytes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$load_binbytes DD 020521H
	DD	063405H
	DD	imagerel load_binbytes
	DD	imagerel load_binbytes+44
	DD	imagerel $unwind$load_binbytes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binbytes DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT ??_C@_0DE@FALDIICK@BINBYTES?5exceeds?5system?8s?5maximu@
CONST	SEGMENT
??_C@_0DE@FALDIICK@BINBYTES?5exceeds?5system?8s?5maximu@ DB 'BINBYTES exc'
	DB	'eeds system''s maximum size of %zd bytes', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT load_binbytes
_TEXT	SEGMENT
self$ = 48
s$ = 56
load_binbytes PROC					; COMDAT

; 4247 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4248 :     PyObject *bytes;
; 4249 :     Py_ssize_t x;
; 4250 :     char *s;
; 4251 : 
; 4252 :     if (_Unpickler_Read(self, &s, 4) < 0)

  00006	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00011	48 8b f9	 mov	 rdi, rcx
  00014	e8 00 00 00 00	 call	 _Unpickler_Read
  00019	48 85 c0	 test	 rax, rax
  0001c	79 09		 jns	 SHORT $LN8@load_binby

; 4253 :         return -1;

  0001e	83 c8 ff	 or	 eax, -1

; 4271 :     return 0;
; 4272 : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5f		 pop	 rdi
  00026	c3		 ret	 0
$LN8@load_binby:

; 4254 : 
; 4255 :     x = calc_binsize(s, 4);

  00027	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00031	e8 00 00 00 00	 call	 calc_binsize
  00036	48 8b d8	 mov	 rbx, rax

; 4256 :     if (x < 0) {

  00039	48 85 c0	 test	 rax, rax
  0003c	79 2b		 jns	 SHORT $LN7@load_binby

; 4257 :         PyErr_Format(PyExc_OverflowError,
; 4258 :                      "BINBYTES exceeds system's maximum size of %zd bytes",
; 4259 :                      PY_SSIZE_T_MAX
; 4260 :                     );

  0003e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@FALDIICK@BINBYTES?5exceeds?5system?8s?5maximu@
  0004c	49 b8 ff ff ff
	ff ff ff ff 7f	 mov	 r8, 9223372036854775807	; 7fffffffffffffffH
  00056	e8 00 00 00 00	 call	 PyErr_Format
$LN12@load_binby:

; 4261 :         return -1;

  0005b	83 c8 ff	 or	 eax, -1
  0005e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 4271 :     return 0;
; 4272 : }

  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
$LN7@load_binby:

; 4262 :     }
; 4263 : 
; 4264 :     if (_Unpickler_Read(self, &s, x) < 0)

  00069	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  0006e	4c 8b c0	 mov	 r8, rax
  00071	48 8b cf	 mov	 rcx, rdi
  00074	e8 00 00 00 00	 call	 _Unpickler_Read
  00079	48 85 c0	 test	 rax, rax

; 4265 :         return -1;

  0007c	78 dd		 js	 SHORT $LN12@load_binby

; 4266 :     bytes = PyBytes_FromStringAndSize(s, x);

  0007e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00083	48 8b d3	 mov	 rdx, rbx
  00086	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 4267 :     if (bytes == NULL)

  0008b	48 85 c0	 test	 rax, rax

; 4268 :         return -1;

  0008e	74 cb		 je	 SHORT $LN12@load_binby

; 4269 : 
; 4270 :     PDATA_PUSH(self->stack, bytes, -1);

  00090	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  00094	48 8b d0	 mov	 rdx, rax
  00097	e8 00 00 00 00	 call	 Pdata_push
  0009c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a1	33 c9		 xor	 ecx, ecx
  000a3	85 c0		 test	 eax, eax
  000a5	0f 99 c1	 setns	 cl
  000a8	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4271 :     return 0;
; 4272 : }

  000ab	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000af	5f		 pop	 rdi
  000b0	c3		 ret	 0
load_binbytes ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_short_binbytes DD imagerel load_short_binbytes
	DD	imagerel load_short_binbytes+44
	DD	imagerel $unwind$load_short_binbytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$load_short_binbytes DD imagerel load_short_binbytes+44
	DD	imagerel load_short_binbytes+104
	DD	imagerel $chain$0$load_short_binbytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$load_short_binbytes DD imagerel load_short_binbytes+104
	DD	imagerel load_short_binbytes+137
	DD	imagerel $chain$2$load_short_binbytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$load_short_binbytes DD 020021H
	DD	067400H
	DD	imagerel load_short_binbytes
	DD	imagerel load_short_binbytes+44
	DD	imagerel $unwind$load_short_binbytes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$load_short_binbytes DD 020521H
	DD	067405H
	DD	imagerel load_short_binbytes
	DD	imagerel load_short_binbytes+44
	DD	imagerel $unwind$load_short_binbytes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_short_binbytes DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_short_binbytes
_TEXT	SEGMENT
self$ = 48
s$ = 56
load_short_binbytes PROC				; COMDAT

; 4276 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4277 :     PyObject *bytes;
; 4278 :     Py_ssize_t x;
; 4279 :     char *s;
; 4280 : 
; 4281 :     if (_Unpickler_Read(self, &s, 1) < 0)

  00006	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00011	48 8b d9	 mov	 rbx, rcx
  00014	e8 00 00 00 00	 call	 _Unpickler_Read
  00019	48 85 c0	 test	 rax, rax
  0001c	79 09		 jns	 SHORT $LN7@load_short

; 4282 :         return -1;

  0001e	83 c8 ff	 or	 eax, -1

; 4294 :     return 0;
; 4295 : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
$LN7@load_short:

; 4283 : 
; 4284 :     x = (unsigned char)s[0];

  00027	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0002c	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 4285 : 
; 4286 :     if (_Unpickler_Read(self, &s, x) < 0)

  00031	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  00036	0f b6 38	 movzx	 edi, BYTE PTR [rax]
  00039	48 8b cb	 mov	 rcx, rbx
  0003c	44 8b c7	 mov	 r8d, edi
  0003f	e8 00 00 00 00	 call	 _Unpickler_Read
  00044	48 85 c0	 test	 rax, rax

; 4287 :         return -1;

  00047	78 11		 js	 SHORT $LN11@load_short

; 4288 : 
; 4289 :     bytes = PyBytes_FromStringAndSize(s, x);

  00049	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0004e	8b d7		 mov	 edx, edi
  00050	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 4290 :     if (bytes == NULL)

  00055	48 85 c0	 test	 rax, rax
  00058	75 0e		 jne	 SHORT $LN4@load_short
$LN11@load_short:

; 4291 :         return -1;

  0005a	83 c8 ff	 or	 eax, -1
  0005d	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 4294 :     return 0;
; 4295 : }

  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5b		 pop	 rbx
  00067	c3		 ret	 0
$LN4@load_short:

; 4292 : 
; 4293 :     PDATA_PUSH(self->stack, bytes, -1);

  00068	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  0006c	48 8b d0	 mov	 rdx, rax
  0006f	e8 00 00 00 00	 call	 Pdata_push
  00074	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00079	33 c9		 xor	 ecx, ecx
  0007b	85 c0		 test	 eax, eax
  0007d	0f 99 c1	 setns	 cl
  00080	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4294 :     return 0;
; 4295 : }

  00083	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00087	5b		 pop	 rbx
  00088	c3		 ret	 0
load_short_binbytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@KLBLDIIH@BINSTRING?5pickle?5has?5negative?5by@ ; `string'
EXTRN	PyUnicode_Decode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binstring DD imagerel load_binstring
	DD	imagerel load_binstring+49
	DD	imagerel $unwind$load_binstring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$load_binstring DD imagerel load_binstring+49
	DD	imagerel load_binstring+99
	DD	imagerel $chain$0$load_binstring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$load_binstring DD imagerel load_binstring+99
	DD	imagerel load_binstring+185
	DD	imagerel $chain$2$load_binstring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$load_binstring DD 020021H
	DD	067400H
	DD	imagerel load_binstring
	DD	imagerel load_binstring+49
	DD	imagerel $unwind$load_binstring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$load_binstring DD 020521H
	DD	067405H
	DD	imagerel load_binstring
	DD	imagerel load_binstring+49
	DD	imagerel $unwind$load_binstring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binstring DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CJ@KLBLDIIH@BINSTRING?5pickle?5has?5negative?5by@
CONST	SEGMENT
??_C@_0CJ@KLBLDIIH@BINSTRING?5pickle?5has?5negative?5by@ DB 'BINSTRING pi'
	DB	'ckle has negative byte count', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT load_binstring
_TEXT	SEGMENT
self$ = 48
s$ = 56
load_binstring PROC					; COMDAT

; 4299 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4300 :     PyObject *str;
; 4301 :     Py_ssize_t x;
; 4302 :     char *s;
; 4303 : 
; 4304 :     if (_Unpickler_Read(self, &s, 4) < 0)

  00006	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00011	48 8b d9	 mov	 rbx, rcx
  00014	e8 00 00 00 00	 call	 _Unpickler_Read
  00019	48 85 c0	 test	 rax, rax
  0001c	79 09		 jns	 SHORT $LN8@load_binst

; 4305 :         return -1;

  0001e	83 c8 ff	 or	 eax, -1

; 4323 :     return 0;
; 4324 : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
$LN8@load_binst:

; 4306 : 
; 4307 :     x = calc_binint(s, 4);

  00027	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	ba 04 00 00 00	 mov	 edx, 4
  00031	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00036	e8 00 00 00 00	 call	 calc_binint
  0003b	48 63 f8	 movsxd	 rdi, eax

; 4308 :     if (x < 0) {

  0003e	85 c0		 test	 eax, eax
  00040	79 21		 jns	 SHORT $LN7@load_binst

; 4309 :         PyErr_SetString(UnpicklingError,
; 4310 :                         "BINSTRING pickle has negative byte count");

  00042	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@KLBLDIIH@BINSTRING?5pickle?5has?5negative?5by@
  00050	e8 00 00 00 00	 call	 PyErr_SetString
$LN12@load_binst:

; 4311 :         return -1;

  00055	83 c8 ff	 or	 eax, -1
  00058	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 4323 :     return 0;
; 4324 : }

  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
$LN7@load_binst:

; 4312 :     }
; 4313 : 
; 4314 :     if (_Unpickler_Read(self, &s, x) < 0)

  00063	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  00068	4c 8b c7	 mov	 r8, rdi
  0006b	48 8b cb	 mov	 rcx, rbx
  0006e	e8 00 00 00 00	 call	 _Unpickler_Read
  00073	48 85 c0	 test	 rax, rax

; 4315 :         return -1;

  00076	78 dd		 js	 SHORT $LN12@load_binst

; 4316 : 
; 4317 :     /* Convert Python 2.x strings to unicode. */
; 4318 :     str = PyUnicode_Decode(s, x, self->encoding, self->errors);

  00078	4c 8b 8b 20 01
	00 00		 mov	 r9, QWORD PTR [rbx+288]
  0007f	4c 8b 83 18 01
	00 00		 mov	 r8, QWORD PTR [rbx+280]
  00086	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0008b	48 8b d7	 mov	 rdx, rdi
  0008e	e8 00 00 00 00	 call	 PyUnicode_Decode

; 4319 :     if (str == NULL)

  00093	48 85 c0	 test	 rax, rax

; 4320 :         return -1;

  00096	74 bd		 je	 SHORT $LN12@load_binst

; 4321 : 
; 4322 :     PDATA_PUSH(self->stack, str, -1);

  00098	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  0009c	48 8b d0	 mov	 rdx, rax
  0009f	e8 00 00 00 00	 call	 Pdata_push
  000a4	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  000a9	33 c9		 xor	 ecx, ecx
  000ab	85 c0		 test	 eax, eax
  000ad	0f 99 c1	 setns	 cl
  000b0	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4323 :     return 0;
; 4324 : }

  000b3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b7	5b		 pop	 rbx
  000b8	c3		 ret	 0
load_binstring ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_short_binstring DD imagerel load_short_binstring
	DD	imagerel load_short_binstring+44
	DD	imagerel $unwind$load_short_binstring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$load_short_binstring DD imagerel load_short_binstring+44
	DD	imagerel load_short_binstring+118
	DD	imagerel $chain$0$load_short_binstring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$load_short_binstring DD imagerel load_short_binstring+118
	DD	imagerel load_short_binstring+151
	DD	imagerel $chain$2$load_short_binstring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$load_short_binstring DD 020021H
	DD	067400H
	DD	imagerel load_short_binstring
	DD	imagerel load_short_binstring+44
	DD	imagerel $unwind$load_short_binstring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$load_short_binstring DD 020521H
	DD	067405H
	DD	imagerel load_short_binstring
	DD	imagerel load_short_binstring+44
	DD	imagerel $unwind$load_short_binstring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_short_binstring DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_short_binstring
_TEXT	SEGMENT
self$ = 48
s$ = 56
load_short_binstring PROC				; COMDAT

; 4328 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4329 :     PyObject *str;
; 4330 :     Py_ssize_t x;
; 4331 :     char *s;
; 4332 : 
; 4333 :     if (_Unpickler_Read(self, &s, 1) < 0)

  00006	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00011	48 8b d9	 mov	 rbx, rcx
  00014	e8 00 00 00 00	 call	 _Unpickler_Read
  00019	48 85 c0	 test	 rax, rax
  0001c	79 09		 jns	 SHORT $LN7@load_short@2

; 4334 :         return -1;

  0001e	83 c8 ff	 or	 eax, -1

; 4347 :     return 0;
; 4348 : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
$LN7@load_short@2:

; 4335 : 
; 4336 :     x = (unsigned char)s[0];

  00027	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0002c	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 4337 : 
; 4338 :     if (_Unpickler_Read(self, &s, x) < 0)

  00031	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  00036	0f b6 38	 movzx	 edi, BYTE PTR [rax]
  00039	48 8b cb	 mov	 rcx, rbx
  0003c	44 8b c7	 mov	 r8d, edi
  0003f	e8 00 00 00 00	 call	 _Unpickler_Read
  00044	48 85 c0	 test	 rax, rax

; 4339 :         return -1;

  00047	78 1f		 js	 SHORT $LN11@load_short@2

; 4340 : 
; 4341 :     /* Convert Python 2.x strings to unicode. */
; 4342 :     str = PyUnicode_Decode(s, x, self->encoding, self->errors);

  00049	4c 8b 8b 20 01
	00 00		 mov	 r9, QWORD PTR [rbx+288]
  00050	4c 8b 83 18 01
	00 00		 mov	 r8, QWORD PTR [rbx+280]
  00057	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0005c	8b d7		 mov	 edx, edi
  0005e	e8 00 00 00 00	 call	 PyUnicode_Decode

; 4343 :     if (str == NULL)

  00063	48 85 c0	 test	 rax, rax
  00066	75 0e		 jne	 SHORT $LN4@load_short@2
$LN11@load_short@2:

; 4344 :         return -1;

  00068	83 c8 ff	 or	 eax, -1
  0006b	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 4347 :     return 0;
; 4348 : }

  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5b		 pop	 rbx
  00075	c3		 ret	 0
$LN4@load_short@2:

; 4345 : 
; 4346 :     PDATA_PUSH(self->stack, str, -1);

  00076	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  0007a	48 8b d0	 mov	 rdx, rax
  0007d	e8 00 00 00 00	 call	 Pdata_push
  00082	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00087	33 c9		 xor	 ecx, ecx
  00089	85 c0		 test	 eax, eax
  0008b	0f 99 c1	 setns	 cl
  0008e	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4347 :     return 0;
; 4348 : }

  00091	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00095	5b		 pop	 rbx
  00096	c3		 ret	 0
load_short_binstring ENDP
_TEXT	ENDS
EXTRN	PyUnicode_DecodeRawUnicodeEscape:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_unicode DD imagerel load_unicode
	DD	imagerel load_unicode+99
	DD	imagerel $unwind$load_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_unicode DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_unicode
_TEXT	SEGMENT
self$ = 48
s$ = 56
load_unicode PROC					; COMDAT

; 4352 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4353 :     PyObject *str;
; 4354 :     Py_ssize_t len;
; 4355 :     char *s;
; 4356 : 
; 4357 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00006	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	e8 00 00 00 00	 call	 _Unpickler_Readline
  00013	48 85 c0	 test	 rax, rax
  00016	79 09		 jns	 SHORT $LN7@load_unico
$LN10@load_unico:

; 4358 :         return -1;

  00018	83 c8 ff	 or	 eax, -1

; 4367 :     return 0;
; 4368 : }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
$LN7@load_unico:

; 4359 :     if (len < 1)

  00021	48 83 f8 01	 cmp	 rax, 1
  00025	7d 0a		 jge	 SHORT $LN6@load_unico

; 4367 :     return 0;
; 4368 : }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx
  0002c	e9 00 00 00 00	 jmp	 bad_readline
$LN6@load_unico:

; 4360 :         return bad_readline();
; 4361 : 
; 4362 :     str = PyUnicode_DecodeRawUnicodeEscape(s, len - 1, NULL);

  00031	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00036	48 8d 50 ff	 lea	 rdx, QWORD PTR [rax-1]
  0003a	45 33 c0	 xor	 r8d, r8d
  0003d	e8 00 00 00 00	 call	 PyUnicode_DecodeRawUnicodeEscape

; 4363 :     if (str == NULL)

  00042	48 85 c0	 test	 rax, rax

; 4364 :         return -1;

  00045	74 d1		 je	 SHORT $LN10@load_unico

; 4365 : 
; 4366 :     PDATA_PUSH(self->stack, str, -1);

  00047	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  0004b	48 8b d0	 mov	 rdx, rax
  0004e	e8 00 00 00 00	 call	 Pdata_push
  00053	33 c9		 xor	 ecx, ecx
  00055	85 c0		 test	 eax, eax
  00057	0f 99 c1	 setns	 cl
  0005a	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4367 :     return 0;
; 4368 : }

  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
load_unicode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@OMCKIKHC@BINUNICODE?5exceeds?5system?8s?5maxi@ ; `string'
EXTRN	PyUnicode_DecodeUTF8:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binunicode DD imagerel load_binunicode
	DD	imagerel load_binunicode+44
	DD	imagerel $unwind$load_binunicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$load_binunicode DD imagerel load_binunicode+44
	DD	imagerel load_binunicode+105
	DD	imagerel $chain$0$load_binunicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$load_binunicode DD imagerel load_binunicode+105
	DD	imagerel load_binunicode+184
	DD	imagerel $chain$2$load_binunicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$load_binunicode DD 020021H
	DD	063400H
	DD	imagerel load_binunicode
	DD	imagerel load_binunicode+44
	DD	imagerel $unwind$load_binunicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$load_binunicode DD 020521H
	DD	063405H
	DD	imagerel load_binunicode
	DD	imagerel load_binunicode+44
	DD	imagerel $unwind$load_binunicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binunicode DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT ??_C@_0DG@OMCKIKHC@BINUNICODE?5exceeds?5system?8s?5maxi@
CONST	SEGMENT
??_C@_0DG@OMCKIKHC@BINUNICODE?5exceeds?5system?8s?5maxi@ DB 'BINUNICODE e'
	DB	'xceeds system''s maximum size of %zd bytes', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT load_binunicode
_TEXT	SEGMENT
self$ = 48
s$ = 56
load_binunicode PROC					; COMDAT

; 4372 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4373 :     PyObject *str;
; 4374 :     Py_ssize_t size;
; 4375 :     char *s;
; 4376 : 
; 4377 :     if (_Unpickler_Read(self, &s, 4) < 0)

  00006	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00011	48 8b f9	 mov	 rdi, rcx
  00014	e8 00 00 00 00	 call	 _Unpickler_Read
  00019	48 85 c0	 test	 rax, rax
  0001c	79 09		 jns	 SHORT $LN8@load_binun

; 4378 :         return -1;

  0001e	83 c8 ff	 or	 eax, -1

; 4398 :     return 0;
; 4399 : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5f		 pop	 rdi
  00026	c3		 ret	 0
$LN8@load_binun:

; 4379 : 
; 4380 :     size = calc_binsize(s, 4);

  00027	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00031	e8 00 00 00 00	 call	 calc_binsize
  00036	48 8b d8	 mov	 rbx, rax

; 4381 :     if (size < 0) {

  00039	48 85 c0	 test	 rax, rax
  0003c	79 2b		 jns	 SHORT $LN7@load_binun

; 4382 :         PyErr_Format(PyExc_OverflowError,
; 4383 :                      "BINUNICODE exceeds system's maximum size of %zd bytes",
; 4384 :                      PY_SSIZE_T_MAX
; 4385 :                     );

  0003e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@OMCKIKHC@BINUNICODE?5exceeds?5system?8s?5maxi@
  0004c	49 b8 ff ff ff
	ff ff ff ff 7f	 mov	 r8, 9223372036854775807	; 7fffffffffffffffH
  00056	e8 00 00 00 00	 call	 PyErr_Format
$LN12@load_binun:

; 4386 :         return -1;

  0005b	83 c8 ff	 or	 eax, -1
  0005e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 4398 :     return 0;
; 4399 : }

  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
$LN7@load_binun:

; 4387 :     }
; 4388 : 
; 4389 : 
; 4390 :     if (_Unpickler_Read(self, &s, size) < 0)

  00069	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  0006e	4c 8b c0	 mov	 r8, rax
  00071	48 8b cf	 mov	 rcx, rdi
  00074	e8 00 00 00 00	 call	 _Unpickler_Read
  00079	48 85 c0	 test	 rax, rax

; 4391 :         return -1;

  0007c	78 dd		 js	 SHORT $LN12@load_binun

; 4392 : 
; 4393 :     str = PyUnicode_DecodeUTF8(s, size, "surrogatepass");

  0007e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00083	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNPCNOJJ@surrogatepass?$AA@
  0008a	48 8b d3	 mov	 rdx, rbx
  0008d	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8

; 4394 :     if (str == NULL)

  00092	48 85 c0	 test	 rax, rax

; 4395 :         return -1;

  00095	74 c4		 je	 SHORT $LN12@load_binun

; 4396 : 
; 4397 :     PDATA_PUSH(self->stack, str, -1);

  00097	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  0009b	48 8b d0	 mov	 rdx, rax
  0009e	e8 00 00 00 00	 call	 Pdata_push
  000a3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a8	33 c9		 xor	 ecx, ecx
  000aa	85 c0		 test	 eax, eax
  000ac	0f 99 c1	 setns	 cl
  000af	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4398 :     return 0;
; 4399 : }

  000b2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b6	5f		 pop	 rdi
  000b7	c3		 ret	 0
load_binunicode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_tuple DD imagerel load_tuple
	DD	imagerel load_tuple+73
	DD	imagerel $unwind$load_tuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_tuple DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_tuple
_TEXT	SEGMENT
self$ = 48
load_tuple PROC						; COMDAT

; 4403 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 4404 :     PyObject *tuple;
; 4405 :     Py_ssize_t i;
; 4406 : 
; 4407 :     if ((i = marker(self)) < 0)

  00009	e8 00 00 00 00	 call	 marker
  0000e	48 85 c0	 test	 rax, rax
  00011	79 09		 jns	 SHORT $LN6@load_tuple
$LN9@load_tuple:

; 4408 :         return -1;

  00013	83 c8 ff	 or	 eax, -1

; 4414 :     return 0;
; 4415 : }

  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5b		 pop	 rbx
  0001b	c3		 ret	 0
$LN6@load_tuple:

; 4409 : 
; 4410 :     tuple = Pdata_poptuple(self->stack, i);

  0001c	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00020	48 8b d0	 mov	 rdx, rax
  00023	e8 00 00 00 00	 call	 Pdata_poptuple

; 4411 :     if (tuple == NULL)

  00028	48 85 c0	 test	 rax, rax

; 4412 :         return -1;

  0002b	74 e6		 je	 SHORT $LN9@load_tuple

; 4413 :     PDATA_PUSH(self->stack, tuple, -1);

  0002d	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00031	48 8b d0	 mov	 rdx, rax
  00034	e8 00 00 00 00	 call	 Pdata_push
  00039	33 c9		 xor	 ecx, ecx
  0003b	85 c0		 test	 eax, eax
  0003d	0f 99 c1	 setns	 cl
  00040	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4414 :     return 0;
; 4415 : }

  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5b		 pop	 rbx
  00048	c3		 ret	 0
load_tuple ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_counted_tuple DD imagerel load_counted_tuple
	DD	imagerel load_counted_tuple+58
	DD	imagerel $unwind$load_counted_tuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$load_counted_tuple DD imagerel load_counted_tuple+58
	DD	imagerel load_counted_tuple+149
	DD	imagerel $chain$0$load_counted_tuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$load_counted_tuple DD imagerel load_counted_tuple+149
	DD	imagerel load_counted_tuple+154
	DD	imagerel $chain$2$load_counted_tuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$load_counted_tuple DD 020021H
	DD	067400H
	DD	imagerel load_counted_tuple
	DD	imagerel load_counted_tuple+58
	DD	imagerel $unwind$load_counted_tuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$load_counted_tuple DD 020521H
	DD	067405H
	DD	imagerel load_counted_tuple
	DD	imagerel load_counted_tuple+58
	DD	imagerel $unwind$load_counted_tuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_counted_tuple DD 060f01H
	DD	08540fH
	DD	07340fH
	DD	0600b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_counted_tuple
_TEXT	SEGMENT
self$ = 48
len$ = 56
load_counted_tuple PROC					; COMDAT

; 4419 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 63 da	 movsxd	 rbx, edx
  00012	48 8b f1	 mov	 rsi, rcx

; 4420 :     PyObject *tuple;
; 4421 : 
; 4422 :     tuple = PyTuple_New(len);

  00015	48 8b cb	 mov	 rcx, rbx
  00018	e8 00 00 00 00	 call	 PyTuple_New
  0001d	48 8b e8	 mov	 rbp, rax

; 4423 :     if (tuple == NULL)

  00020	48 85 c0	 test	 rax, rax
  00023	75 13		 jne	 SHORT $LN14@load_count@2

; 4424 :         return -1;

  00025	83 c8 ff	 or	 eax, -1

; 4435 :     return 0;
; 4436 : }

  00028	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0002d	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5e		 pop	 rsi
  00037	c3		 ret	 0
$LN14@load_count@2:

; 4425 : 
; 4426 :     while (--len >= 0) {

  00038	ff cb		 dec	 ebx
  0003a	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0003f	48 63 db	 movsxd	 rbx, ebx
  00042	78 26		 js	 SHORT $LN4@load_count@2
  00044	48 8d 7c d8 70	 lea	 rdi, QWORD PTR [rax+rbx*8+112]
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@load_count@2:

; 4427 :         PyObject *item;
; 4428 : 
; 4429 :         PDATA_POP(self->stack, item);

  00050	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  00054	e8 00 00 00 00	 call	 Pdata_pop

; 4430 :         if (item == NULL)

  00059	48 85 c0	 test	 rax, rax
  0005c	74 37		 je	 SHORT $LN15@load_count@2

; 4432 :         PyTuple_SET_ITEM(tuple, len, item);

  0005e	48 89 07	 mov	 QWORD PTR [rdi], rax
  00061	48 83 ef 08	 sub	 rdi, 8
  00065	48 ff cb	 dec	 rbx
  00068	79 e6		 jns	 SHORT $LL10@load_count@2
$LN4@load_count@2:

; 4433 :     }
; 4434 :     PDATA_PUSH(self->stack, tuple, -1);

  0006a	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  0006e	48 8b d5	 mov	 rdx, rbp
  00071	e8 00 00 00 00	 call	 Pdata_push
  00076	33 c9		 xor	 ecx, ecx
  00078	85 c0		 test	 eax, eax
  0007a	0f 99 c1	 setns	 cl
  0007d	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
$LN17@load_count@2:

; 4435 :     return 0;
; 4436 : }

  00080	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00085	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0008a	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0008f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00093	5e		 pop	 rsi
  00094	c3		 ret	 0
$LN15@load_count@2:

; 4431 :             return -1;

  00095	83 c8 ff	 or	 eax, -1
  00098	eb e6		 jmp	 SHORT $LN17@load_count@2
load_counted_tuple ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_empty_list DD imagerel load_empty_list
	DD	imagerel load_empty_list+58
	DD	imagerel $unwind$load_empty_list
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_empty_list DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_empty_list
_TEXT	SEGMENT
self$ = 48
load_empty_list PROC					; COMDAT

; 4440 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 4441 :     PyObject *list;
; 4442 : 
; 4443 :     if ((list = PyList_New(0)) == NULL)

  00009	33 c9		 xor	 ecx, ecx
  0000b	e8 00 00 00 00	 call	 PyList_New
  00010	48 85 c0	 test	 rax, rax
  00013	75 09		 jne	 SHORT $LN4@load_empty

; 4444 :         return -1;

  00015	83 c8 ff	 or	 eax, -1

; 4446 :     return 0;
; 4447 : }

  00018	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001c	5b		 pop	 rbx
  0001d	c3		 ret	 0
$LN4@load_empty:

; 4445 :     PDATA_PUSH(self->stack, list, -1);

  0001e	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00022	48 8b d0	 mov	 rdx, rax
  00025	e8 00 00 00 00	 call	 Pdata_push
  0002a	33 c9		 xor	 ecx, ecx
  0002c	85 c0		 test	 eax, eax
  0002e	0f 99 c1	 setns	 cl
  00031	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4446 :     return 0;
; 4447 : }

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
load_empty_list ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_empty_dict DD imagerel load_empty_dict
	DD	imagerel load_empty_dict+56
	DD	imagerel $unwind$load_empty_dict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_empty_dict DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_empty_dict
_TEXT	SEGMENT
self$ = 48
load_empty_dict PROC					; COMDAT

; 4451 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 4452 :     PyObject *dict;
; 4453 : 
; 4454 :     if ((dict = PyDict_New()) == NULL)

  00009	e8 00 00 00 00	 call	 PyDict_New
  0000e	48 85 c0	 test	 rax, rax
  00011	75 09		 jne	 SHORT $LN4@load_empty@2

; 4455 :         return -1;

  00013	83 c8 ff	 or	 eax, -1

; 4457 :     return 0;
; 4458 : }

  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5b		 pop	 rbx
  0001b	c3		 ret	 0
$LN4@load_empty@2:

; 4456 :     PDATA_PUSH(self->stack, dict, -1);

  0001c	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00020	48 8b d0	 mov	 rdx, rax
  00023	e8 00 00 00 00	 call	 Pdata_push
  00028	33 c9		 xor	 ecx, ecx
  0002a	85 c0		 test	 eax, eax
  0002c	0f 99 c1	 setns	 cl
  0002f	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4457 :     return 0;
; 4458 : }

  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5b		 pop	 rbx
  00037	c3		 ret	 0
load_empty_dict ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_list DD imagerel load_list
	DD	imagerel load_list+73
	DD	imagerel $unwind$load_list
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_list DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_list
_TEXT	SEGMENT
self$ = 48
load_list PROC						; COMDAT

; 4462 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 4463 :     PyObject *list;
; 4464 :     Py_ssize_t i;
; 4465 : 
; 4466 :     if ((i = marker(self)) < 0)

  00009	e8 00 00 00 00	 call	 marker
  0000e	48 85 c0	 test	 rax, rax
  00011	79 09		 jns	 SHORT $LN6@load_list
$LN9@load_list:

; 4467 :         return -1;

  00013	83 c8 ff	 or	 eax, -1

; 4473 :     return 0;
; 4474 : }

  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5b		 pop	 rbx
  0001b	c3		 ret	 0
$LN6@load_list:

; 4468 : 
; 4469 :     list = Pdata_poplist(self->stack, i);

  0001c	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00020	48 8b d0	 mov	 rdx, rax
  00023	e8 00 00 00 00	 call	 Pdata_poplist

; 4470 :     if (list == NULL)

  00028	48 85 c0	 test	 rax, rax

; 4471 :         return -1;

  0002b	74 e6		 je	 SHORT $LN9@load_list

; 4472 :     PDATA_PUSH(self->stack, list, -1);

  0002d	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00031	48 8b d0	 mov	 rdx, rax
  00034	e8 00 00 00 00	 call	 Pdata_push
  00039	33 c9		 xor	 ecx, ecx
  0003b	85 c0		 test	 eax, eax
  0003d	0f 99 c1	 setns	 cl
  00040	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4473 :     return 0;
; 4474 : }

  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5b		 pop	 rbx
  00048	c3		 ret	 0
load_list ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_dict DD imagerel load_dict
	DD	imagerel load_dict+46
	DD	imagerel $unwind$load_dict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$load_dict DD imagerel load_dict+46
	DD	imagerel load_dict+78
	DD	imagerel $chain$1$load_dict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$load_dict DD imagerel load_dict+78
	DD	imagerel load_dict+173
	DD	imagerel $chain$2$load_dict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$load_dict DD imagerel load_dict+173
	DD	imagerel load_dict+195
	DD	imagerel $chain$3$load_dict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$load_dict DD imagerel load_dict+195
	DD	imagerel load_dict+208
	DD	imagerel $chain$5$load_dict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$load_dict DD 060021H
	DD	087400H
	DD	075400H
	DD	063400H
	DD	imagerel load_dict
	DD	imagerel load_dict+46
	DD	imagerel $unwind$load_dict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$load_dict DD 021H
	DD	imagerel load_dict+46
	DD	imagerel load_dict+78
	DD	imagerel $chain$1$load_dict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$load_dict DD 020521H
	DD	063405H
	DD	imagerel load_dict+46
	DD	imagerel load_dict+78
	DD	imagerel $chain$1$load_dict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$load_dict DD 040a21H
	DD	08740aH
	DD	075405H
	DD	imagerel load_dict
	DD	imagerel load_dict+46
	DD	imagerel $unwind$load_dict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_dict DD 040b01H
	DD	09640bH
	DD	0c007320bH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_dict
_TEXT	SEGMENT
self$ = 48
load_dict PROC						; COMDAT

; 4478 : {

  00000	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00005	41 54		 push	 r12
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000b	48 8b f1	 mov	 rsi, rcx

; 4479 :     PyObject *dict, *key, *value;
; 4480 :     Py_ssize_t i, j, k;
; 4481 : 
; 4482 :     if ((i = marker(self)) < 0)

  0000e	e8 00 00 00 00	 call	 marker
  00013	4c 8b e0	 mov	 r12, rax
  00016	48 85 c0	 test	 rax, rax
  00019	79 0f		 jns	 SHORT $LN10@load_dict

; 4483 :         return -1;

  0001b	83 c8 ff	 or	 eax, -1

; 4499 :     return 0;
; 4500 : }

  0001e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	41 5c		 pop	 r12
  00029	c3		 ret	 0
$LN10@load_dict:

; 4484 :     j = Py_SIZE(self->stack);

  0002a	48 8b 46 60	 mov	 rax, QWORD PTR [rsi+96]
  0002e	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00033	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00038	48 8b 78 60	 mov	 rdi, QWORD PTR [rax+96]

; 4485 : 
; 4486 :     if ((dict = PyDict_New()) == NULL)

  0003c	e8 00 00 00 00	 call	 PyDict_New
  00041	48 8b e8	 mov	 rbp, rax
  00044	48 85 c0	 test	 rax, rax
  00047	75 05		 jne	 SHORT $LN9@load_dict

; 4487 :         return -1;

  00049	83 c8 ff	 or	 eax, -1
  0004c	eb 5f		 jmp	 SHORT $LN17@load_dict
$LN9@load_dict:
  0004e	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 4488 : 
; 4489 :     for (k = i + 1; k < j; k += 2) {

  00053	49 8d 5c 24 01	 lea	 rbx, QWORD PTR [r12+1]
  00058	48 3b df	 cmp	 rbx, rdi
  0005b	7d 29		 jge	 SHORT $LN6@load_dict
  0005d	0f 1f 00	 npad	 3
$LL8@load_dict:
  00060	48 8b 46 60	 mov	 rax, QWORD PTR [rsi+96]

; 4490 :         key = self->stack->data[k - 1];
; 4491 :         value = self->stack->data[k];
; 4492 :         if (PyDict_SetItem(dict, key, value) < 0) {

  00064	48 8b cd	 mov	 rcx, rbp
  00067	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  0006b	49 8b 54 d8 f8	 mov	 rdx, QWORD PTR [r8+rbx*8-8]
  00070	4d 8b 04 d8	 mov	 r8, QWORD PTR [r8+rbx*8]
  00074	e8 00 00 00 00	 call	 PyDict_SetItem
  00079	85 c0		 test	 eax, eax
  0007b	78 46		 js	 SHORT $LN14@load_dict

; 4488 : 
; 4489 :     for (k = i + 1; k < j; k += 2) {

  0007d	48 83 c3 02	 add	 rbx, 2
  00081	48 3b df	 cmp	 rbx, rdi
  00084	7c da		 jl	 SHORT $LL8@load_dict
$LN6@load_dict:

; 4495 :         }
; 4496 :     }
; 4497 :     Pdata_clear(self->stack, i);

  00086	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  0008a	49 8b d4	 mov	 rdx, r12
  0008d	e8 00 00 00 00	 call	 Pdata_clear

; 4498 :     PDATA_PUSH(self->stack, dict, -1);

  00092	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  00096	48 8b d5	 mov	 rdx, rbp
  00099	e8 00 00 00 00	 call	 Pdata_push
  0009e	33 c9		 xor	 ecx, ecx
  000a0	85 c0		 test	 eax, eax
  000a2	0f 99 c1	 setns	 cl
  000a5	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
$LN18@load_dict:
  000a8	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN17@load_dict:
  000ad	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000b2	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 4499 :     return 0;
; 4500 : }

  000b7	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000bc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c0	41 5c		 pop	 r12
  000c2	c3		 ret	 0
$LN14@load_dict:

; 4493 :             Py_DECREF(dict);

  000c3	48 8b cd	 mov	 rcx, rbp
  000c6	e8 00 00 00 00	 call	 _Py_DecRef

; 4494 :             return -1;

  000cb	83 c8 ff	 or	 eax, -1
  000ce	eb d8		 jmp	 SHORT $LN18@load_dict
load_dict ENDP
_TEXT	ENDS
PUBLIC	??_C@_01MJMHLOMK@O?$AA@				; `string'
EXTRN	PyObject_CallObject:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$instantiate DD imagerel instantiate
	DD	imagerel instantiate+148
	DD	imagerel $unwind$instantiate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$instantiate DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_01MJMHLOMK@O?$AA@
CONST	SEGMENT
??_C@_01MJMHLOMK@O?$AA@ DB 'O', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT instantiate
_TEXT	SEGMENT
cls$ = 48
args$ = 56
instantiate PROC					; COMDAT

; 4504 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4505 :     PyObject *result = NULL;
; 4506 :     _Py_IDENTIFIER(__getinitargs__);
; 4507 :     /* Caller must assure args are a tuple.  Normally, args come from
; 4508 :        Pdata_poptuple which packs objects from the top of the stack
; 4509 :        into a newly created tuple. */
; 4510 :     assert(PyTuple_Check(args));
; 4511 :     if (Py_SIZE(args) > 0 || !PyType_Check(cls) ||
; 4512 :         _PyObject_HasAttrId(cls, &PyId___getinitargs__)) {

  0000f	48 83 7a 60 00	 cmp	 QWORD PTR [rdx+96], 0
  00014	48 8b fa	 mov	 rdi, rdx
  00017	48 8b d9	 mov	 rbx, rcx
  0001a	7f 5e		 jg	 SHORT $LN2@instantiat
  0001c	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00020	f7 80 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rax+256], -2147483648 ; ffffffff80000000H
  0002a	74 4e		 je	 SHORT $LN2@instantiat
  0002c	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00033	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0003c	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___getinitargs__@?1??instantiate@@9@9
  00041	4a 8b 34 c0	 mov	 rsi, QWORD PTR [rax+r8*8]
  00045	48 03 d6	 add	 rdx, rsi
  00048	e8 00 00 00 00	 call	 _PyObject_HasAttrId
  0004d	85 c0		 test	 eax, eax
  0004f	75 29		 jne	 SHORT $LN2@instantiat

; 4514 :     }
; 4515 :     else {
; 4516 :         _Py_IDENTIFIER(__new__);
; 4517 : 
; 4518 :         result = _PyObject_CallMethodId(cls, &PyId___new__, "O", cls);

  00051	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___new__@?3??instantiate@@9@9
  00056	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  0005d	4c 8b cb	 mov	 r9, rbx
  00060	48 03 d6	 add	 rdx, rsi
  00063	48 8b cb	 mov	 rcx, rbx

; 4519 :     }
; 4520 :     return result;
; 4521 : }

  00066	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5f		 pop	 rdi
  00075	e9 00 00 00 00	 jmp	 _PyObject_CallMethodId
$LN2@instantiat:

; 4513 :         result = PyObject_CallObject(cls, args);

  0007a	48 8b d7	 mov	 rdx, rdi
  0007d	48 8b cb	 mov	 rcx, rbx

; 4519 :     }
; 4520 :     return result;
; 4521 : }

  00080	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00085	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5f		 pop	 rdi
  0008f	e9 00 00 00 00	 jmp	 PyObject_CallObject
instantiate ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_obj DD imagerel load_obj
	DD	imagerel load_obj+81
	DD	imagerel $unwind$load_obj
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$load_obj DD imagerel load_obj+81
	DD	imagerel load_obj+139
	DD	imagerel $chain$1$load_obj
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$load_obj DD imagerel load_obj+139
	DD	imagerel load_obj+186
	DD	imagerel $chain$2$load_obj
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$load_obj DD 021H
	DD	imagerel load_obj
	DD	imagerel load_obj+81
	DD	imagerel $unwind$load_obj
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$load_obj DD 020521H
	DD	065405H
	DD	imagerel load_obj
	DD	imagerel load_obj+81
	DD	imagerel $unwind$load_obj
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_obj DD 084001H
	DD	07c440H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_obj
_TEXT	SEGMENT
self$ = 48
load_obj PROC						; COMDAT

; 4525 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4526 :     PyObject *cls, *args, *obj = NULL;

  0000f	33 ff		 xor	 edi, edi
  00011	48 8b d9	 mov	 rbx, rcx
  00014	8b f7		 mov	 esi, edi

; 4527 :     Py_ssize_t i;
; 4528 : 
; 4529 :     if ((i = marker(self)) < 0)

  00016	e8 00 00 00 00	 call	 marker
  0001b	48 85 c0	 test	 rax, rax
  0001e	79 13		 jns	 SHORT $LN11@load_obj

; 4530 :         return -1;

  00020	83 c8 ff	 or	 eax, -1

; 4546 :     return 0;
; 4547 : }

  00023	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00028	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5f		 pop	 rdi
  00032	c3		 ret	 0
$LN11@load_obj:

; 4531 : 
; 4532 :     args = Pdata_poptuple(self->stack, i + 1);

  00033	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00037	48 8d 50 01	 lea	 rdx, QWORD PTR [rax+1]
  0003b	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  00040	e8 00 00 00 00	 call	 Pdata_poptuple
  00045	4c 8b e0	 mov	 r12, rax

; 4533 :     if (args == NULL)

  00048	48 85 c0	 test	 rax, rax

; 4534 :         return -1;

  0004b	74 3e		 je	 SHORT $LN15@load_obj

; 4535 : 
; 4536 :     PDATA_POP(self->stack, cls);

  0004d	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00051	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00056	e8 00 00 00 00	 call	 Pdata_pop
  0005b	48 8b e8	 mov	 rbp, rax

; 4537 :     if (cls) {

  0005e	48 85 c0	 test	 rax, rax
  00061	74 16		 je	 SHORT $LN6@load_obj

; 4538 :         obj = instantiate(cls, args);

  00063	49 8b d4	 mov	 rdx, r12
  00066	48 8b c8	 mov	 rcx, rax
  00069	e8 00 00 00 00	 call	 instantiate

; 4539 :         Py_DECREF(cls);

  0006e	48 8b cd	 mov	 rcx, rbp
  00071	48 8b f0	 mov	 rsi, rax
  00074	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@load_obj:

; 4540 :     }
; 4541 :     Py_DECREF(args);

  00079	49 8b cc	 mov	 rcx, r12
  0007c	e8 00 00 00 00	 call	 _Py_DecRef
  00081	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 4542 :     if (obj == NULL)

  00086	48 85 f6	 test	 rsi, rsi
  00089	75 05		 jne	 SHORT $LN4@load_obj
$LN15@load_obj:

; 4543 :         return -1;

  0008b	83 c8 ff	 or	 eax, -1
  0008e	eb 15		 jmp	 SHORT $LN14@load_obj
$LN4@load_obj:

; 4544 : 
; 4545 :     PDATA_PUSH(self->stack, obj, -1);

  00090	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00094	48 8b d6	 mov	 rdx, rsi
  00097	e8 00 00 00 00	 call	 Pdata_push
  0009c	85 c0		 test	 eax, eax
  0009e	40 0f 99 c7	 setns	 dil
  000a2	8d 47 ff	 lea	 eax, DWORD PTR [rdi-1]
$LN14@load_obj:

; 4546 :     return 0;
; 4547 : }

  000a5	4c 8b 64 24 38	 mov	 r12, QWORD PTR [rsp+56]
  000aa	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000af	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0
load_obj ENDP
_TEXT	ENDS
EXTRN	PyUnicode_DecodeASCII:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_inst DD imagerel load_inst
	DD	imagerel load_inst+106
	DD	imagerel $unwind$load_inst
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$load_inst DD imagerel load_inst+106
	DD	imagerel load_inst+173
	DD	imagerel $chain$0$load_inst
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$load_inst DD imagerel load_inst+173
	DD	imagerel load_inst+189
	DD	imagerel $chain$2$load_inst
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$load_inst DD imagerel load_inst+189
	DD	imagerel load_inst+237
	DD	imagerel $chain$3$load_inst
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$load_inst DD imagerel load_inst+237
	DD	imagerel load_inst+325
	DD	imagerel $chain$4$load_inst
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$load_inst DD imagerel load_inst+325
	DD	imagerel load_inst+362
	DD	imagerel $chain$6$load_inst
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$load_inst DD 020021H
	DD	0a5400H
	DD	imagerel load_inst
	DD	imagerel load_inst+106
	DD	imagerel $unwind$load_inst
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$load_inst DD 021H
	DD	imagerel load_inst+173
	DD	imagerel load_inst+189
	DD	imagerel $chain$2$load_inst
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$load_inst DD 020521H
	DD	0ce405H
	DD	imagerel load_inst+173
	DD	imagerel load_inst+189
	DD	imagerel $chain$2$load_inst
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$load_inst DD 020021H
	DD	0a5400H
	DD	imagerel load_inst
	DD	imagerel load_inst+106
	DD	imagerel $unwind$load_inst
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$load_inst DD 020521H
	DD	0a5405H
	DD	imagerel load_inst
	DD	imagerel load_inst+106
	DD	imagerel $unwind$load_inst
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_inst DD 060c01H
	DD	0d008320cH
	DD	07004c006H
	DD	030026003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_inst
_TEXT	SEGMENT
self$ = 80
s$ = 88
load_inst PROC						; COMDAT

; 4551 : {

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4552 :     PyObject *cls = NULL;

  0000c	33 db		 xor	 ebx, ebx
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	8b f3		 mov	 esi, ebx

; 4553 :     PyObject *args = NULL;
; 4554 :     PyObject *obj = NULL;

  00013	44 8b e3	 mov	 r12d, ebx

; 4555 :     PyObject *module_name;
; 4556 :     PyObject *class_name;
; 4557 :     Py_ssize_t len;
; 4558 :     Py_ssize_t i;
; 4559 :     char *s;
; 4560 : 
; 4561 :     if ((i = marker(self)) < 0)

  00016	e8 00 00 00 00	 call	 marker
  0001b	4c 8b e8	 mov	 r13, rax
  0001e	48 85 c0	 test	 rax, rax
  00021	79 0f		 jns	 SHORT $LN14@load_inst
$LN20@load_inst:

; 4562 :         return -1;

  00023	83 c8 ff	 or	 eax, -1

; 4599 :     return 0;
; 4600 : }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	41 5d		 pop	 r13
  0002c	41 5c		 pop	 r12
  0002e	5f		 pop	 rdi
  0002f	5e		 pop	 rsi
  00030	5b		 pop	 rbx
  00031	c3		 ret	 0
$LN14@load_inst:

; 4563 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00032	48 8d 54 24 58	 lea	 rdx, QWORD PTR s$[rsp]
  00037	48 8b cf	 mov	 rcx, rdi
  0003a	e8 00 00 00 00	 call	 _Unpickler_Readline
  0003f	48 85 c0	 test	 rax, rax

; 4564 :         return -1;

  00042	78 df		 js	 SHORT $LN20@load_inst

; 4565 :     if (len < 2)

  00044	48 83 f8 02	 cmp	 rax, 2
  00048	7d 10		 jge	 SHORT $LN12@load_inst

; 4599 :     return 0;
; 4600 : }

  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	41 5d		 pop	 r13
  00050	41 5c		 pop	 r12
  00052	5f		 pop	 rdi
  00053	5e		 pop	 rsi
  00054	5b		 pop	 rbx
  00055	e9 00 00 00 00	 jmp	 bad_readline
$LN12@load_inst:

; 4566 :         return bad_readline();
; 4567 : 
; 4568 :     /* Here it is safe to use PyUnicode_DecodeASCII(), even though non-ASCII
; 4569 :        identifiers are permitted in Python 3.0, since the INST opcode is only
; 4570 :        supported by older protocols on Python 2.x. */
; 4571 :     module_name = PyUnicode_DecodeASCII(s, len - 1, "strict");

  0005a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR s$[rsp]
  0005f	48 8d 50 ff	 lea	 rdx, QWORD PTR [rax-1]
  00063	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  0006a	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0006f	e8 00 00 00 00	 call	 PyUnicode_DecodeASCII
  00074	48 8b e8	 mov	 rbp, rax

; 4572 :     if (module_name == NULL)

  00077	48 85 c0	 test	 rax, rax

; 4573 :         return -1;

  0007a	0f 84 b1 00 00
	00		 je	 $LN19@load_inst

; 4574 : 
; 4575 :     if ((len = _Unpickler_Readline(self, &s)) >= 0) {

  00080	48 8d 54 24 58	 lea	 rdx, QWORD PTR s$[rsp]
  00085	48 8b cf	 mov	 rcx, rdi
  00088	e8 00 00 00 00	 call	 _Unpickler_Readline
  0008d	48 85 c0	 test	 rax, rax
  00090	78 5b		 js	 SHORT $LN8@load_inst

; 4576 :         if (len < 2)

  00092	48 83 f8 02	 cmp	 rax, 2
  00096	7d 15		 jge	 SHORT $LN9@load_inst
  00098	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 4599 :     return 0;
; 4600 : }

  0009d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a1	41 5d		 pop	 r13
  000a3	41 5c		 pop	 r12
  000a5	5f		 pop	 rdi
  000a6	5e		 pop	 rsi
  000a7	5b		 pop	 rbx
  000a8	e9 00 00 00 00	 jmp	 bad_readline
$LN9@load_inst:

; 4577 :             return bad_readline();
; 4578 :         class_name = PyUnicode_DecodeASCII(s, len - 1, "strict");

  000ad	48 8b 4c 24 58	 mov	 rcx, QWORD PTR s$[rsp]
  000b2	48 8d 50 ff	 lea	 rdx, QWORD PTR [rax-1]
  000b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  000bd	4c 89 74 24 60	 mov	 QWORD PTR [rsp+96], r14
  000c2	e8 00 00 00 00	 call	 PyUnicode_DecodeASCII
  000c7	4c 8b f0	 mov	 r14, rax

; 4579 :         if (class_name != NULL) {

  000ca	48 85 c0	 test	 rax, rax
  000cd	74 19		 je	 SHORT $LN18@load_inst

; 4580 :             cls = find_class(self, module_name, class_name);

  000cf	4c 8b c0	 mov	 r8, rax
  000d2	48 8b d5	 mov	 rdx, rbp
  000d5	48 8b cf	 mov	 rcx, rdi
  000d8	e8 00 00 00 00	 call	 find_class

; 4581 :             Py_DECREF(class_name);

  000dd	49 8b ce	 mov	 rcx, r14
  000e0	48 8b f0	 mov	 rsi, rax
  000e3	e8 00 00 00 00	 call	 _Py_DecRef
$LN18@load_inst:
  000e8	4c 8b 74 24 60	 mov	 r14, QWORD PTR [rsp+96]
$LN8@load_inst:

; 4582 :         }
; 4583 :     }
; 4584 :     Py_DECREF(module_name);

  000ed	48 8b cd	 mov	 rcx, rbp
  000f0	e8 00 00 00 00	 call	 _Py_DecRef

; 4585 : 
; 4586 :     if (cls == NULL)

  000f5	48 85 f6	 test	 rsi, rsi

; 4587 :         return -1;

  000f8	74 37		 je	 SHORT $LN19@load_inst

; 4588 : 
; 4589 :     if ((args = Pdata_poptuple(self->stack, i)) != NULL) {

  000fa	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  000fe	49 8b d5	 mov	 rdx, r13
  00101	e8 00 00 00 00	 call	 Pdata_poptuple
  00106	48 8b e8	 mov	 rbp, rax
  00109	48 85 c0	 test	 rax, rax
  0010c	74 16		 je	 SHORT $LN6@load_inst

; 4590 :         obj = instantiate(cls, args);

  0010e	48 8b d0	 mov	 rdx, rax
  00111	48 8b ce	 mov	 rcx, rsi
  00114	e8 00 00 00 00	 call	 instantiate

; 4591 :         Py_DECREF(args);

  00119	48 8b cd	 mov	 rcx, rbp
  0011c	4c 8b e0	 mov	 r12, rax
  0011f	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@load_inst:

; 4592 :     }
; 4593 :     Py_DECREF(cls);

  00124	48 8b ce	 mov	 rcx, rsi
  00127	e8 00 00 00 00	 call	 _Py_DecRef

; 4594 : 
; 4595 :     if (obj == NULL)

  0012c	4d 85 e4	 test	 r12, r12
  0012f	75 14		 jne	 SHORT $LN4@load_inst
$LN19@load_inst:

; 4596 :         return -1;

  00131	83 c8 ff	 or	 eax, -1
  00134	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 4599 :     return 0;
; 4600 : }

  00139	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013d	41 5d		 pop	 r13
  0013f	41 5c		 pop	 r12
  00141	5f		 pop	 rdi
  00142	5e		 pop	 rsi
  00143	5b		 pop	 rbx
  00144	c3		 ret	 0
$LN4@load_inst:

; 4597 : 
; 4598 :     PDATA_PUSH(self->stack, obj, -1);

  00145	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  00149	49 8b d4	 mov	 rdx, r12
  0014c	e8 00 00 00 00	 call	 Pdata_push
  00151	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00156	85 c0		 test	 eax, eax
  00158	0f 99 c3	 setns	 bl
  0015b	8d 43 ff	 lea	 eax, DWORD PTR [rbx-1]

; 4599 :     return 0;
; 4600 : }

  0015e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00162	41 5d		 pop	 r13
  00164	41 5c		 pop	 r12
  00166	5f		 pop	 rdi
  00167	5e		 pop	 rsi
  00168	5b		 pop	 rbx
  00169	c3		 ret	 0
load_inst ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@INAOHFPP@NEWOBJ?5class?5argument?5has?5NULL?5t@ ; `string'
PUBLIC	??_C@_0CK@PKCLLMEF@NEWOBJ?5class?5argument?5isn?8t?5a?5ty@ ; `string'
PUBLIC	??_C@_0BO@CHFKLHLD@NEWOBJ?5expected?5an?5arg?5tuple?4?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$load_newobj DD imagerel load_newobj
	DD	imagerel load_newobj+487
	DD	imagerel $unwind$load_newobj
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_newobj DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
xdata	ENDS
;	COMDAT ??_C@_0CG@INAOHFPP@NEWOBJ?5class?5argument?5has?5NULL?5t@
CONST	SEGMENT
??_C@_0CG@INAOHFPP@NEWOBJ?5class?5argument?5has?5NULL?5t@ DB 'NEWOBJ clas'
	DB	's argument has NULL tp_new', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PKCLLMEF@NEWOBJ?5class?5argument?5isn?8t?5a?5ty@
CONST	SEGMENT
??_C@_0CK@PKCLLMEF@NEWOBJ?5class?5argument?5isn?8t?5a?5ty@ DB 'NEWOBJ cla'
	DB	'ss argument isn''t a type object', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CHFKLHLD@NEWOBJ?5expected?5an?5arg?5tuple?4?$AA@
CONST	SEGMENT
??_C@_0BO@CHFKLHLD@NEWOBJ?5expected?5an?5arg?5tuple?4?$AA@ DB 'NEWOBJ exp'
	DB	'ected an arg tuple.', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT load_newobj
_TEXT	SEGMENT
self$ = 64
load_newobj PROC					; COMDAT

; 4604 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001a	48 8b f1	 mov	 rsi, rcx

; 4605 :     PyObject *args = NULL;
; 4606 :     PyObject *clsraw = NULL;
; 4607 :     PyTypeObject *cls;          /* clsraw cast to its true type */
; 4608 :     PyObject *obj;
; 4609 : 
; 4610 :     /* Stack is ... cls argtuple, and we want to call
; 4611 :      * cls.__new__(cls, *argtuple).
; 4612 :      */
; 4613 :     PDATA_POP(self->stack, args);

  0001d	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00021	33 ed		 xor	 ebp, ebp
  00023	8b dd		 mov	 ebx, ebp
  00025	e8 00 00 00 00	 call	 Pdata_pop
  0002a	48 8b f8	 mov	 rdi, rax

; 4614 :     if (args == NULL)

  0002d	48 85 c0	 test	 rax, rax
  00030	0f 84 93 01 00
	00		 je	 $LN3@load_newob

; 4615 :         goto error;
; 4616 :     if (!PyTuple_Check(args)) {

  00036	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003a	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00044	75 7f		 jne	 SHORT $LN19@load_newob

; 4617 :         PyErr_SetString(UnpicklingError, "NEWOBJ expected an arg " "tuple.");

  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@CHFKLHLD@NEWOBJ?5expected?5an?5arg?5tuple?4?$AA@
$LN49@load_newob:

; 4626 :         PyErr_SetString(UnpicklingError, "NEWOBJ class argument "
; 4627 :                         "isn't a type object");

  0004d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  00054	e8 00 00 00 00	 call	 PyErr_SetString
$error$23713:

; 4644 :     return 0;
; 4645 : 
; 4646 :   error:
; 4647 :     Py_XDECREF(args);

  00059	e8 00 00 00 00	 call	 _Py_PXCTX
  0005e	85 c0		 test	 eax, eax
  00060	0f 85 f9 00 00
	00		 jne	 $LN7@load_newob
  00066	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0006a	a8 20		 test	 al, 32			; 00000020H
  0006c	0f 85 e5 00 00
	00		 jne	 $LN31@load_newob
  00072	84 c0		 test	 al, al
  00074	0f 88 dd 00 00
	00		 js	 $LN31@load_newob
  0007a	a8 02		 test	 al, 2
  0007c	0f 85 dd 00 00
	00		 jne	 $LN7@load_newob
  00082	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00086	0f 85 d3 00 00
	00		 jne	 $LN7@load_newob
  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0009a	4c 8b cf	 mov	 r9, rdi
  0009d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000a3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ab	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b0	48 8b cf	 mov	 rcx, rdi
  000b3	85 c0		 test	 eax, eax
  000b5	0f 84 90 00 00
	00		 je	 $LN36@load_newob
  000bb	e8 00 00 00 00	 call	 _Px_Dealloc
  000c0	e9 9a 00 00 00	 jmp	 $LN7@load_newob
$LN19@load_newob:

; 4618 :         goto error;
; 4619 :     }
; 4620 : 
; 4621 :     PDATA_POP(self->stack, clsraw);

  000c5	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  000c9	e8 00 00 00 00	 call	 Pdata_pop
  000ce	48 8b d8	 mov	 rbx, rax

; 4622 :     cls = (PyTypeObject *)clsraw;
; 4623 :     if (cls == NULL)

  000d1	48 85 c0	 test	 rax, rax
  000d4	74 83		 je	 SHORT $error$23713

; 4624 :         goto error;
; 4625 :     if (!PyType_Check(cls)) {

  000d6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000da	f7 80 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rax+256], -2147483648 ; ffffffff80000000H
  000e4	75 0c		 jne	 SHORT $LN15@load_newob

; 4626 :         PyErr_SetString(UnpicklingError, "NEWOBJ class argument "
; 4627 :                         "isn't a type object");

  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@PKCLLMEF@NEWOBJ?5class?5argument?5isn?8t?5a?5ty@

; 4628 :         goto error;

  000ed	e9 5b ff ff ff	 jmp	 $LN49@load_newob
$LN15@load_newob:

; 4629 :     }
; 4630 :     if (cls->tp_new == NULL) {

  000f2	48 8b 83 90 01
	00 00		 mov	 rax, QWORD PTR [rbx+400]
  000f9	48 85 c0	 test	 rax, rax
  000fc	75 0c		 jne	 SHORT $LN14@load_newob

; 4631 :         PyErr_SetString(UnpicklingError, "NEWOBJ class argument "
; 4632 :                         "has NULL tp_new");

  000fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@INAOHFPP@NEWOBJ?5class?5argument?5has?5NULL?5t@

; 4633 :         goto error;

  00105	e9 43 ff ff ff	 jmp	 $LN49@load_newob
$LN14@load_newob:

; 4634 :     }
; 4635 : 
; 4636 :     /* Call __new__. */
; 4637 :     obj = cls->tp_new(cls, args, NULL);

  0010a	45 33 c0	 xor	 r8d, r8d
  0010d	48 8b d7	 mov	 rdx, rdi
  00110	48 8b cb	 mov	 rcx, rbx
  00113	ff d0		 call	 rax
  00115	4c 8b e0	 mov	 r12, rax

; 4638 :     if (obj == NULL)

  00118	48 85 c0	 test	 rax, rax
  0011b	0f 84 38 ff ff
	ff		 je	 $error$23713

; 4639 :         goto error;
; 4640 : 
; 4641 :     Py_DECREF(args);

  00121	48 8b cf	 mov	 rcx, rdi
  00124	e8 00 00 00 00	 call	 _Py_DecRef

; 4642 :     Py_DECREF(clsraw);

  00129	48 8b cb	 mov	 rcx, rbx
  0012c	e8 00 00 00 00	 call	 _Py_DecRef

; 4643 :     PDATA_PUSH(self->stack, obj, -1);

  00131	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  00135	49 8b d4	 mov	 rdx, r12
  00138	e8 00 00 00 00	 call	 Pdata_push
  0013d	85 c0		 test	 eax, eax
  0013f	40 0f 99 c5	 setns	 bpl
  00143	8d 45 ff	 lea	 eax, DWORD PTR [rbp-1]
  00146	e9 81 00 00 00	 jmp	 $LN11@load_newob

; 4644 :     return 0;
; 4645 : 
; 4646 :   error:
; 4647 :     Py_XDECREF(args);

$LN36@load_newob:
  0014b	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0014f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00155	eb 08		 jmp	 SHORT $LN7@load_newob
$LN31@load_newob:
  00157	48 8b cf	 mov	 rcx, rdi
  0015a	e8 00 00 00 00	 call	 Px_DecRef
$LN7@load_newob:

; 4648 :     Py_XDECREF(clsraw);

  0015f	48 85 db	 test	 rbx, rbx
  00162	74 65		 je	 SHORT $LN3@load_newob
  00164	e8 00 00 00 00	 call	 _Py_PXCTX
  00169	85 c0		 test	 eax, eax
  0016b	75 5c		 jne	 SHORT $LN3@load_newob
  0016d	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00171	a8 20		 test	 al, 32			; 00000020H
  00173	75 4c		 jne	 SHORT $LN42@load_newob
  00175	84 c0		 test	 al, al
  00177	78 48		 js	 SHORT $LN42@load_newob
  00179	a8 02		 test	 al, 2
  0017b	75 4c		 jne	 SHORT $LN3@load_newob
  0017d	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00181	75 46		 jne	 SHORT $LN3@load_newob
  00183	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0018a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00191	4c 8b cb	 mov	 r9, rbx
  00194	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0019a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001a2	e8 00 00 00 00	 call	 _PyParallel_Guard
  001a7	48 8b cb	 mov	 rcx, rbx
  001aa	85 c0		 test	 eax, eax
  001ac	74 07		 je	 SHORT $LN47@load_newob
  001ae	e8 00 00 00 00	 call	 _Px_Dealloc
  001b3	eb 14		 jmp	 SHORT $LN3@load_newob
$LN47@load_newob:
  001b5	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001b9	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001bf	eb 08		 jmp	 SHORT $LN3@load_newob
$LN42@load_newob:
  001c1	48 8b cb	 mov	 rcx, rbx
  001c4	e8 00 00 00 00	 call	 Px_DecRef
$LN3@load_newob:

; 4649 :     return -1;

  001c9	83 c8 ff	 or	 eax, -1
$LN11@load_newob:

; 4650 : }

  001cc	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001d1	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001d6	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001db	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  001e0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001e4	41 5c		 pop	 r12
  001e6	c3		 ret	 0
load_newobj ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_global DD imagerel load_global
	DD	imagerel load_global+75
	DD	imagerel $unwind$load_global
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$load_global DD imagerel load_global+75
	DD	imagerel load_global+142
	DD	imagerel $chain$0$load_global
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$load_global DD imagerel load_global+142
	DD	imagerel load_global+158
	DD	imagerel $chain$2$load_global
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$load_global DD imagerel load_global+158
	DD	imagerel load_global+206
	DD	imagerel $chain$3$load_global
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$load_global DD imagerel load_global+206
	DD	imagerel load_global+235
	DD	imagerel $chain$4$load_global
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$load_global DD imagerel load_global+235
	DD	imagerel load_global+269
	DD	imagerel $chain$6$load_global
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$load_global DD 020021H
	DD	083400H
	DD	imagerel load_global
	DD	imagerel load_global+75
	DD	imagerel $unwind$load_global
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$load_global DD 021H
	DD	imagerel load_global+142
	DD	imagerel load_global+158
	DD	imagerel $chain$2$load_global
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$load_global DD 020521H
	DD	0ac405H
	DD	imagerel load_global+142
	DD	imagerel load_global+158
	DD	imagerel $chain$2$load_global
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$load_global DD 020021H
	DD	083400H
	DD	imagerel load_global
	DD	imagerel load_global+75
	DD	imagerel $unwind$load_global
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$load_global DD 020521H
	DD	083405H
	DD	imagerel load_global
	DD	imagerel load_global+75
	DD	imagerel $unwind$load_global
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_global DD 040801H
	DD	070043208H
	DD	050026003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_global
_TEXT	SEGMENT
self$ = 64
s$ = 72
load_global PROC					; COMDAT

; 4654 : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4655 :     PyObject *global = NULL;
; 4656 :     PyObject *module_name;
; 4657 :     PyObject *global_name;
; 4658 :     Py_ssize_t len;
; 4659 :     char *s;
; 4660 : 
; 4661 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00008	48 8d 54 24 48	 lea	 rdx, QWORD PTR s$[rsp]
  0000d	33 ff		 xor	 edi, edi
  0000f	48 8b f1	 mov	 rsi, rcx
  00012	8b ef		 mov	 ebp, edi
  00014	e8 00 00 00 00	 call	 _Unpickler_Readline
  00019	48 85 c0	 test	 rax, rax
  0001c	79 0b		 jns	 SHORT $LN11@load_globa

; 4662 :         return -1;

  0001e	83 c8 ff	 or	 eax, -1

; 4685 :     return 0;
; 4686 : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5f		 pop	 rdi
  00026	5e		 pop	 rsi
  00027	5d		 pop	 rbp
  00028	c3		 ret	 0
$LN11@load_globa:

; 4663 :     if (len < 2)

  00029	48 83 f8 02	 cmp	 rax, 2
  0002d	7d 0c		 jge	 SHORT $LN10@load_globa

; 4685 :     return 0;
; 4686 : }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	5e		 pop	 rsi
  00035	5d		 pop	 rbp
  00036	e9 00 00 00 00	 jmp	 bad_readline
$LN10@load_globa:

; 4664 :         return bad_readline();
; 4665 :     module_name = PyUnicode_DecodeUTF8(s, len - 1, "strict");

  0003b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00040	48 8d 50 ff	 lea	 rdx, QWORD PTR [rax-1]
  00044	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  0004b	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00050	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8
  00055	48 8b d8	 mov	 rbx, rax

; 4666 :     if (!module_name)

  00058	48 85 c0	 test	 rax, rax

; 4667 :         return -1;

  0005b	74 7e		 je	 SHORT $LN16@load_globa

; 4668 : 
; 4669 :     if ((len = _Unpickler_Readline(self, &s)) >= 0) {

  0005d	48 8d 54 24 48	 lea	 rdx, QWORD PTR s$[rsp]
  00062	48 8b ce	 mov	 rcx, rsi
  00065	e8 00 00 00 00	 call	 _Unpickler_Readline
  0006a	48 85 c0	 test	 rax, rax
  0006d	78 5f		 js	 SHORT $LN6@load_globa

; 4670 :         if (len < 2) {

  0006f	48 83 f8 02	 cmp	 rax, 2
  00073	7d 19		 jge	 SHORT $LN7@load_globa

; 4671 :             Py_DECREF(module_name);

  00075	48 8b cb	 mov	 rcx, rbx
  00078	e8 00 00 00 00	 call	 _Py_DecRef

; 4672 :             return bad_readline();

  0007d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 4685 :     return 0;
; 4686 : }

  00082	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00086	5f		 pop	 rdi
  00087	5e		 pop	 rsi
  00088	5d		 pop	 rbp
  00089	e9 00 00 00 00	 jmp	 bad_readline
$LN7@load_globa:

; 4673 :         }
; 4674 :         global_name = PyUnicode_DecodeUTF8(s, len - 1, "strict");

  0008e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00093	48 8d 50 ff	 lea	 rdx, QWORD PTR [rax-1]
  00097	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  0009e	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  000a3	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8
  000a8	4c 8b e0	 mov	 r12, rax

; 4675 :         if (global_name) {

  000ab	48 85 c0	 test	 rax, rax
  000ae	74 19		 je	 SHORT $LN15@load_globa

; 4676 :             global = find_class(self, module_name, global_name);

  000b0	4c 8b c0	 mov	 r8, rax
  000b3	48 8b d3	 mov	 rdx, rbx
  000b6	48 8b ce	 mov	 rcx, rsi
  000b9	e8 00 00 00 00	 call	 find_class

; 4677 :             Py_DECREF(global_name);

  000be	49 8b cc	 mov	 rcx, r12
  000c1	48 8b e8	 mov	 rbp, rax
  000c4	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@load_globa:
  000c9	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
$LN6@load_globa:

; 4678 :         }
; 4679 :     }
; 4680 :     Py_DECREF(module_name);

  000ce	48 8b cb	 mov	 rcx, rbx
  000d1	e8 00 00 00 00	 call	 _Py_DecRef

; 4681 : 
; 4682 :     if (global == NULL)

  000d6	48 85 ed	 test	 rbp, rbp
  000d9	75 10		 jne	 SHORT $LN4@load_globa
$LN16@load_globa:

; 4683 :         return -1;

  000db	83 c8 ff	 or	 eax, -1
  000de	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 4685 :     return 0;
; 4686 : }

  000e3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e7	5f		 pop	 rdi
  000e8	5e		 pop	 rsi
  000e9	5d		 pop	 rbp
  000ea	c3		 ret	 0
$LN4@load_globa:

; 4684 :     PDATA_PUSH(self->stack, global, -1);

  000eb	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  000ef	48 8b d5	 mov	 rdx, rbp
  000f2	e8 00 00 00 00	 call	 Pdata_push
  000f7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000fc	85 c0		 test	 eax, eax
  000fe	40 0f 99 c7	 setns	 dil
  00102	8d 47 ff	 lea	 eax, DWORD PTR [rdi-1]

; 4685 :     return 0;
; 4686 : }

  00105	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00109	5f		 pop	 rdi
  0010a	5e		 pop	 rsi
  0010b	5d		 pop	 rbp
  0010c	c3		 ret	 0
load_global ENDP
_TEXT	ENDS
PUBLIC	??_C@_0GB@HJMGCJMN@A?5load?5persistent?5id?5instruction@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_persid DD imagerel load_persid
	DD	imagerel load_persid+148
	DD	imagerel $unwind$load_persid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_persid DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0GB@HJMGCJMN@A?5load?5persistent?5id?5instruction@
CONST	SEGMENT
??_C@_0GB@HJMGCJMN@A?5load?5persistent?5id?5instruction@ DB 'A load persi'
	DB	'stent id instruction was encountered,', 0aH, 'but no persiste'
	DB	'nt_load function was specified.', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT load_persid
_TEXT	SEGMENT
s$ = 48
self$ = 48
load_persid PROC					; COMDAT

; 4690 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4691 :     PyObject *pid;
; 4692 :     Py_ssize_t len;
; 4693 :     char *s;
; 4694 : 
; 4695 :     if (self->pers_func) {

  00006	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	74 65		 je	 SHORT $LN10@load_persi

; 4696 :         if ((len = _Unpickler_Readline(self, &s)) < 0)

  00013	48 8d 54 24 30	 lea	 rdx, QWORD PTR s$[rsp]
  00018	e8 00 00 00 00	 call	 _Unpickler_Readline
  0001d	48 85 c0	 test	 rax, rax

; 4697 :             return -1;

  00020	78 69		 js	 SHORT $LN13@load_persi

; 4698 :         if (len < 1)

  00022	48 83 f8 01	 cmp	 rax, 1
  00026	7d 0a		 jge	 SHORT $LN8@load_persi

; 4719 :     }
; 4720 : }

  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5b		 pop	 rbx
  0002d	e9 00 00 00 00	 jmp	 bad_readline
$LN8@load_persi:

; 4699 :             return bad_readline();
; 4700 : 
; 4701 :         pid = PyBytes_FromStringAndSize(s, len - 1);

  00032	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00037	48 8d 50 ff	 lea	 rdx, QWORD PTR [rax-1]
  0003b	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 4702 :         if (pid == NULL)

  00040	48 85 c0	 test	 rax, rax

; 4703 :             return -1;

  00043	74 46		 je	 SHORT $LN13@load_persi

; 4704 : 
; 4705 :         /* Ugh... this does not leak since _Unpickler_FastCall() steals the
; 4706 :            reference to pid first. */
; 4707 :         pid = _Unpickler_FastCall(self, self->pers_func, pid);

  00045	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  0004c	4c 8b c0	 mov	 r8, rax
  0004f	48 8b cb	 mov	 rcx, rbx
  00052	e8 00 00 00 00	 call	 _Unpickler_FastCall

; 4708 :         if (pid == NULL)

  00057	48 85 c0	 test	 rax, rax

; 4709 :             return -1;

  0005a	74 2f		 je	 SHORT $LN13@load_persi

; 4710 : 
; 4711 :         PDATA_PUSH(self->stack, pid, -1);

  0005c	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00060	48 8b d0	 mov	 rdx, rax
  00063	e8 00 00 00 00	 call	 Pdata_push
  00068	33 c9		 xor	 ecx, ecx
  0006a	85 c0		 test	 eax, eax
  0006c	0f 99 c1	 setns	 cl
  0006f	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4719 :     }
; 4720 : }

  00072	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00076	5b		 pop	 rbx
  00077	c3		 ret	 0
$LN10@load_persi:

; 4712 :         return 0;
; 4713 :     }
; 4714 :     else {
; 4715 :         PyErr_SetString(UnpicklingError,
; 4716 :                         "A load persistent id instruction was encountered,\n"
; 4717 :                         "but no persistent_load function was specified.");

  00078	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GB@HJMGCJMN@A?5load?5persistent?5id?5instruction@
  00086	e8 00 00 00 00	 call	 PyErr_SetString
$LN13@load_persi:

; 4718 :         return -1;

  0008b	83 c8 ff	 or	 eax, -1

; 4719 :     }
; 4720 : }

  0008e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00092	5b		 pop	 rbx
  00093	c3		 ret	 0
load_persid ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binpersid DD imagerel load_binpersid
	DD	imagerel load_binpersid+112
	DD	imagerel $unwind$load_binpersid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binpersid DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_binpersid
_TEXT	SEGMENT
self$ = 48
load_binpersid PROC					; COMDAT

; 4724 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4725 :     PyObject *pid;
; 4726 : 
; 4727 :     if (self->pers_func) {

  00006	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	74 41		 je	 SHORT $LN11@load_binpe

; 4728 :         PDATA_POP(self->stack, pid);

  00013	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00017	e8 00 00 00 00	 call	 Pdata_pop

; 4729 :         if (pid == NULL)

  0001c	48 85 c0	 test	 rax, rax

; 4730 :             return -1;

  0001f	74 46		 je	 SHORT $LN14@load_binpe

; 4731 : 
; 4732 :         /* Ugh... this does not leak since _Unpickler_FastCall() steals the
; 4733 :            reference to pid first. */
; 4734 :         pid = _Unpickler_FastCall(self, self->pers_func, pid);

  00021	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  00028	4c 8b c0	 mov	 r8, rax
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	e8 00 00 00 00	 call	 _Unpickler_FastCall

; 4735 :         if (pid == NULL)

  00033	48 85 c0	 test	 rax, rax

; 4736 :             return -1;

  00036	74 2f		 je	 SHORT $LN14@load_binpe

; 4737 : 
; 4738 :         PDATA_PUSH(self->stack, pid, -1);

  00038	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  0003c	48 8b d0	 mov	 rdx, rax
  0003f	e8 00 00 00 00	 call	 Pdata_push
  00044	33 c9		 xor	 ecx, ecx
  00046	85 c0		 test	 eax, eax
  00048	0f 99 c1	 setns	 cl
  0004b	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4746 :     }
; 4747 : }

  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5b		 pop	 rbx
  00053	c3		 ret	 0
$LN11@load_binpe:

; 4739 :         return 0;
; 4740 :     }
; 4741 :     else {
; 4742 :         PyErr_SetString(UnpicklingError,
; 4743 :                         "A load persistent id instruction was encountered,\n"
; 4744 :                         "but no persistent_load function was specified.");

  00054	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GB@HJMGCJMN@A?5load?5persistent?5id?5instruction@
  00062	e8 00 00 00 00	 call	 PyErr_SetString
$LN14@load_binpe:

; 4745 :         return -1;

  00067	83 c8 ff	 or	 eax, -1

; 4746 :     }
; 4747 : }

  0006a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006e	5b		 pop	 rbx
  0006f	c3		 ret	 0
load_binpersid ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_pop DD imagerel load_pop
	DD	imagerel load_pop+128
	DD	imagerel $unwind$load_pop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_pop DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_pop
_TEXT	SEGMENT
self$ = 48
load_pop PROC						; COMDAT

; 4751 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4752 :     Py_ssize_t len = Py_SIZE(self->stack);

  0000a	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  0000e	48 8b f9	 mov	 rdi, rcx

; 4753 : 
; 4754 :     /* Note that we split the (pickle.py) stack into two stacks,
; 4755 :      * an object stack and a mark stack. We have to be clever and
; 4756 :      * pop the right one. We do this by looking at the top of the
; 4757 :      * mark stack first, and only signalling a stack underflow if
; 4758 :      * the object stack is empty and the mark stack doesn't match
; 4759 :      * our expectations.
; 4760 :      */
; 4761 :     if (self->num_marks > 0 && self->marks[self->num_marks - 1] == len) {

  00011	48 8b 89 30 01
	00 00		 mov	 rcx, QWORD PTR [rcx+304]
  00018	48 8b 5a 60	 mov	 rbx, QWORD PTR [rdx+96]
  0001c	48 85 c9	 test	 rcx, rcx
  0001f	7e 26		 jle	 SHORT $LN4@load_pop
  00021	48 8b 87 28 01
	00 00		 mov	 rax, QWORD PTR [rdi+296]
  00028	48 39 5c c8 f8	 cmp	 QWORD PTR [rax+rcx*8-8], rbx
  0002d	75 18		 jne	 SHORT $LN4@load_pop

; 4762 :         self->num_marks--;

  0002f	48 8d 41 ff	 lea	 rax, QWORD PTR [rcx-1]
  00033	48 89 87 30 01
	00 00		 mov	 QWORD PTR [rdi+304], rax

; 4767 :     } else {
; 4768 :         return stack_underflow();
; 4769 :     }
; 4770 :     return 0;

  0003a	33 c0		 xor	 eax, eax

; 4771 : }

  0003c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
$LN4@load_pop:

; 4763 :     } else if (len > 0) {

  00047	48 85 db	 test	 rbx, rbx
  0004a	7e 25		 jle	 SHORT $LN2@load_pop

; 4764 :         len--;
; 4765 :         Py_DECREF(self->stack->data[len]);

  0004c	48 8b 4a 70	 mov	 rcx, QWORD PTR [rdx+112]
  00050	48 ff cb	 dec	 rbx
  00053	48 8b 0c d9	 mov	 rcx, QWORD PTR [rcx+rbx*8]
  00057	e8 00 00 00 00	 call	 _Py_DecRef

; 4766 :         Py_SIZE(self->stack) = len;

  0005c	4c 8b 5f 60	 mov	 r11, QWORD PTR [rdi+96]

; 4767 :     } else {
; 4768 :         return stack_underflow();
; 4769 :     }
; 4770 :     return 0;

  00060	33 c0		 xor	 eax, eax
  00062	49 89 5b 60	 mov	 QWORD PTR [r11+96], rbx

; 4771 : }

  00066	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006f	5f		 pop	 rdi
  00070	c3		 ret	 0
$LN2@load_pop:
  00071	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00076	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007a	5f		 pop	 rdi
  0007b	e9 00 00 00 00	 jmp	 stack_underflow
load_pop ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_pop_mark DD imagerel load_pop_mark
	DD	imagerel load_pop_mark+48
	DD	imagerel $unwind$load_pop_mark
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_pop_mark DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_pop_mark
_TEXT	SEGMENT
self$ = 48
load_pop_mark PROC					; COMDAT

; 4775 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 4776 :     Py_ssize_t i;
; 4777 : 
; 4778 :     if ((i = marker(self)) < 0)

  00009	e8 00 00 00 00	 call	 marker
  0000e	48 85 c0	 test	 rax, rax
  00011	79 09		 jns	 SHORT $LN1@load_pop_m

; 4779 :         return -1;

  00013	83 c8 ff	 or	 eax, -1

; 4784 : }

  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5b		 pop	 rbx
  0001b	c3		 ret	 0
$LN1@load_pop_m:

; 4780 : 
; 4781 :     Pdata_clear(self->stack, i);

  0001c	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00020	48 8b d0	 mov	 rdx, rax
  00023	e8 00 00 00 00	 call	 Pdata_clear

; 4782 : 
; 4783 :     return 0;

  00028	33 c0		 xor	 eax, eax

; 4784 : }

  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5b		 pop	 rbx
  0002f	c3		 ret	 0
load_pop_mark ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$load_dup DD imagerel load_dup
	DD	imagerel load_dup+142
	DD	imagerel $unwind$load_dup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_dup DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT load_dup
_TEXT	SEGMENT
self$ = 64
load_dup PROC						; COMDAT

; 4788 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 4789 :     PyObject *last;
; 4790 :     Py_ssize_t len;
; 4791 : 
; 4792 :     if ((len = Py_SIZE(self->stack)) <= 0)

  0000a	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 8b 58 60	 mov	 rbx, QWORD PTR [rax+96]
  00015	48 85 db	 test	 rbx, rbx
  00018	7f 0f		 jg	 SHORT $LN5@load_dup

; 4796 :     return 0;
; 4797 : }

  0001a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0001f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00023	5f		 pop	 rdi
  00024	e9 00 00 00 00	 jmp	 stack_underflow
$LN5@load_dup:

; 4793 :         return stack_underflow();
; 4794 :     last = self->stack->data[len - 1];

  00029	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0002d	48 8b 5c d8 f8	 mov	 rbx, QWORD PTR [rax+rbx*8-8]

; 4795 :     PDATA_APPEND(self->stack, last, -1);

  00032	e8 00 00 00 00	 call	 _Py_PXCTX
  00037	85 c0		 test	 eax, eax
  00039	75 32		 jne	 SHORT $LN9@load_dup
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00049	4c 8b cb	 mov	 r9, rbx
  0004c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00052	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0005a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005f	85 c0		 test	 eax, eax
  00061	75 06		 jne	 SHORT $LN8@load_dup
  00063	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00067	74 04		 je	 SHORT $LN9@load_dup
$LN8@load_dup:
  00069	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN9@load_dup:
  0006d	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  00071	48 8b d3	 mov	 rdx, rbx
  00074	e8 00 00 00 00	 call	 Pdata_push

; 4796 :     return 0;
; 4797 : }

  00079	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0007e	33 c9		 xor	 ecx, ecx
  00080	85 c0		 test	 eax, eax
  00082	0f 99 c1	 setns	 cl
  00085	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  00088	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008c	5f		 pop	 rdi
  0008d	c3		 ret	 0
load_dup ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$load_get DD imagerel load_get
	DD	imagerel load_get+56
	DD	imagerel $unwind$load_get
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$load_get DD imagerel load_get+56
	DD	imagerel load_get+92
	DD	imagerel $chain$0$load_get
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$load_get DD imagerel load_get+92
	DD	imagerel load_get+195
	DD	imagerel $chain$3$load_get
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$load_get DD imagerel load_get+195
	DD	imagerel load_get+300
	DD	imagerel $chain$5$load_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$load_get DD 040021H
	DD	0a7400H
	DD	083400H
	DD	imagerel load_get
	DD	imagerel load_get+56
	DD	imagerel $unwind$load_get
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$load_get DD 040821H
	DD	0a7408H
	DD	083400H
	DD	imagerel load_get
	DD	imagerel load_get+56
	DD	imagerel $unwind$load_get
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$load_get DD 020521H
	DD	083405H
	DD	imagerel load_get
	DD	imagerel load_get+56
	DD	imagerel $unwind$load_get
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_get DD 020601H
	DD	060025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT load_get
_TEXT	SEGMENT
self$ = 64
s$ = 72
load_get PROC						; COMDAT

; 4801 : {

  00000	40 56		 push	 rsi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 4802 :     PyObject *key, *value;
; 4803 :     Py_ssize_t idx;
; 4804 :     Py_ssize_t len;
; 4805 :     char *s;
; 4806 : 
; 4807 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00006	48 8d 54 24 48	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	48 8b f1	 mov	 rsi, rcx
  0000e	e8 00 00 00 00	 call	 _Unpickler_Readline
  00013	48 85 c0	 test	 rax, rax
  00016	79 09		 jns	 SHORT $LN10@load_get

; 4808 :         return -1;

  00018	83 c8 ff	 or	 eax, -1

; 4831 :     return 0;
; 4832 : }

  0001b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001f	5e		 pop	 rsi
  00020	c3		 ret	 0
$LN10@load_get:

; 4809 :     if (len < 2)

  00021	48 83 f8 02	 cmp	 rax, 2
  00025	7d 0a		 jge	 SHORT $LN9@load_get

; 4831 :     return 0;
; 4832 : }

  00027	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002b	5e		 pop	 rsi
  0002c	e9 00 00 00 00	 jmp	 bad_readline
$LN9@load_get:

; 4810 :         return bad_readline();
; 4811 : 
; 4812 :     key = PyLong_FromString(s, NULL, 10);

  00031	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00036	33 d2		 xor	 edx, edx
  00038	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0003d	44 8d 42 0a	 lea	 r8d, QWORD PTR [rdx+10]
  00041	e8 00 00 00 00	 call	 PyLong_FromString
  00046	48 8b d8	 mov	 rbx, rax

; 4813 :     if (key == NULL)

  00049	48 85 c0	 test	 rax, rax
  0004c	75 0e		 jne	 SHORT $LN8@load_get

; 4814 :         return -1;

  0004e	83 c8 ff	 or	 eax, -1
  00051	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 4831 :     return 0;
; 4832 : }

  00056	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005a	5e		 pop	 rsi
  0005b	c3		 ret	 0
$LN8@load_get:

; 4815 :     idx = PyLong_AsSsize_t(key);

  0005c	48 8b c8	 mov	 rcx, rax
  0005f	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00064	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00069	48 8b f8	 mov	 rdi, rax

; 4816 :     if (idx == -1 && PyErr_Occurred()) {

  0006c	48 83 f8 ff	 cmp	 rax, -1
  00070	75 0a		 jne	 SHORT $LN7@load_get
  00072	e8 00 00 00 00	 call	 PyErr_Occurred
  00077	48 85 c0	 test	 rax, rax

; 4817 :         Py_DECREF(key);
; 4818 :         return -1;

  0007a	75 2c		 jne	 SHORT $LN5@load_get
$LN7@load_get:

; 4819 :     }
; 4820 : 
; 4821 :     value = _Unpickler_MemoGet(self, idx);

  0007c	48 8b d7	 mov	 rdx, rdi
  0007f	48 8b ce	 mov	 rcx, rsi
  00082	e8 00 00 00 00	 call	 _Unpickler_MemoGet
  00087	48 8b f8	 mov	 rdi, rax

; 4822 :     if (value == NULL) {

  0008a	48 85 c0	 test	 rax, rax
  0008d	75 34		 jne	 SHORT $LN6@load_get

; 4823 :         if (!PyErr_Occurred())

  0008f	e8 00 00 00 00	 call	 PyErr_Occurred
  00094	48 85 c0	 test	 rax, rax
  00097	75 0f		 jne	 SHORT $LN5@load_get

; 4824 :             PyErr_SetObject(PyExc_KeyError, key);

  00099	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  000a0	48 8b d3	 mov	 rdx, rbx
  000a3	e8 00 00 00 00	 call	 PyErr_SetObject
$LN5@load_get:

; 4825 :         Py_DECREF(key);

  000a8	48 8b cb	 mov	 rcx, rbx
  000ab	e8 00 00 00 00	 call	 _Py_DecRef
  000b0	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  000b5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 4826 :         return -1;

  000ba	83 c8 ff	 or	 eax, -1

; 4831 :     return 0;
; 4832 : }

  000bd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c1	5e		 pop	 rsi
  000c2	c3		 ret	 0
$LN6@load_get:

; 4827 :     }
; 4828 :     Py_DECREF(key);

  000c3	48 8b cb	 mov	 rcx, rbx
  000c6	e8 00 00 00 00	 call	 _Py_DecRef

; 4829 : 
; 4830 :     PDATA_APPEND(self->stack, value, -1);

  000cb	e8 00 00 00 00	 call	 _Py_PXCTX
  000d0	85 c0		 test	 eax, eax
  000d2	75 32		 jne	 SHORT $LN14@load_get
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000e2	4c 8b cf	 mov	 r9, rdi
  000e5	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000eb	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000f3	e8 00 00 00 00	 call	 _PyParallel_Guard
  000f8	85 c0		 test	 eax, eax
  000fa	75 06		 jne	 SHORT $LN13@load_get
  000fc	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00100	74 04		 je	 SHORT $LN14@load_get
$LN13@load_get:
  00102	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN14@load_get:
  00106	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  0010a	48 8b d7	 mov	 rdx, rdi
  0010d	e8 00 00 00 00	 call	 Pdata_push
  00112	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00117	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0011c	33 c9		 xor	 ecx, ecx
  0011e	85 c0		 test	 eax, eax
  00120	0f 99 c1	 setns	 cl
  00123	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4831 :     return 0;
; 4832 : }

  00126	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0012a	5e		 pop	 rsi
  0012b	c3		 ret	 0
load_get ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$load_binget DD imagerel load_binget
	DD	imagerel load_binget+47
	DD	imagerel $unwind$load_binget
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$load_binget DD imagerel load_binget+47
	DD	imagerel load_binget+120
	DD	imagerel $chain$0$load_binget
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$load_binget DD imagerel load_binget+120
	DD	imagerel load_binget+212
	DD	imagerel $chain$2$load_binget
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$load_binget DD 020021H
	DD	083400H
	DD	imagerel load_binget
	DD	imagerel load_binget+47
	DD	imagerel $unwind$load_binget
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$load_binget DD 020521H
	DD	083405H
	DD	imagerel load_binget
	DD	imagerel load_binget+47
	DD	imagerel $unwind$load_binget
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binget DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT load_binget
_TEXT	SEGMENT
self$ = 64
s$ = 72
load_binget PROC					; COMDAT

; 4836 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 4837 :     PyObject *value;
; 4838 :     Py_ssize_t idx;
; 4839 :     char *s;
; 4840 : 
; 4841 :     if (_Unpickler_Read(self, &s, 1) < 0)

  00006	48 8d 54 24 48	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00011	48 8b f9	 mov	 rdi, rcx
  00014	e8 00 00 00 00	 call	 _Unpickler_Read
  00019	48 85 c0	 test	 rax, rax
  0001c	79 09		 jns	 SHORT $LN7@load_binge

; 4842 :         return -1;

  0001e	83 c8 ff	 or	 eax, -1

; 4857 :     return 0;
; 4858 : }

  00021	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00025	5f		 pop	 rdi
  00026	c3		 ret	 0
$LN7@load_binge:

; 4843 : 
; 4844 :     idx = Py_CHARMASK(s[0]);

  00027	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]

; 4845 : 
; 4846 :     value = _Unpickler_MemoGet(self, idx);

  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00034	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00037	e8 00 00 00 00	 call	 _Unpickler_MemoGet
  0003c	48 8b d8	 mov	 rbx, rax

; 4847 :     if (value == NULL) {

  0003f	48 85 c0	 test	 rax, rax
  00042	75 34		 jne	 SHORT $LN4@load_binge

; 4848 :         PyObject *key = PyLong_FromSsize_t(idx);

  00044	8b ca		 mov	 ecx, edx
  00046	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  0004b	48 8b d8	 mov	 rbx, rax

; 4849 :         if (key != NULL) {

  0004e	48 85 c0	 test	 rax, rax
  00051	74 17		 je	 SHORT $LN5@load_binge

; 4850 :             PyErr_SetObject(PyExc_KeyError, key);

  00053	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  0005a	48 8b d0	 mov	 rdx, rax
  0005d	e8 00 00 00 00	 call	 PyErr_SetObject

; 4851 :             Py_DECREF(key);

  00062	48 8b cb	 mov	 rcx, rbx
  00065	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@load_binge:

; 4852 :         }
; 4853 :         return -1;

  0006a	83 c8 ff	 or	 eax, -1
  0006d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 4857 :     return 0;
; 4858 : }

  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
$LN4@load_binge:

; 4854 :     }
; 4855 : 
; 4856 :     PDATA_APPEND(self->stack, value, -1);

  00078	e8 00 00 00 00	 call	 _Py_PXCTX
  0007d	85 c0		 test	 eax, eax
  0007f	75 32		 jne	 SHORT $LN11@load_binge
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0008f	4c 8b cb	 mov	 r9, rbx
  00092	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00098	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a0	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a5	85 c0		 test	 eax, eax
  000a7	75 06		 jne	 SHORT $LN10@load_binge
  000a9	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000ad	74 04		 je	 SHORT $LN11@load_binge
$LN10@load_binge:
  000af	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN11@load_binge:
  000b3	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  000b7	48 8b d3	 mov	 rdx, rbx
  000ba	e8 00 00 00 00	 call	 Pdata_push
  000bf	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c4	33 c9		 xor	 ecx, ecx
  000c6	85 c0		 test	 eax, eax
  000c8	0f 99 c1	 setns	 cl
  000cb	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4857 :     return 0;
; 4858 : }

  000ce	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
load_binget ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$load_long_binget DD imagerel load_long_binget
	DD	imagerel load_long_binget+44
	DD	imagerel $unwind$load_long_binget
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$load_long_binget DD imagerel load_long_binget+44
	DD	imagerel load_long_binget+126
	DD	imagerel $chain$0$load_long_binget
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$load_long_binget DD imagerel load_long_binget+126
	DD	imagerel load_long_binget+218
	DD	imagerel $chain$2$load_long_binget
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$load_long_binget DD 020021H
	DD	083400H
	DD	imagerel load_long_binget
	DD	imagerel load_long_binget+44
	DD	imagerel $unwind$load_long_binget
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$load_long_binget DD 020521H
	DD	083405H
	DD	imagerel load_long_binget
	DD	imagerel load_long_binget+44
	DD	imagerel $unwind$load_long_binget
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_long_binget DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT load_long_binget
_TEXT	SEGMENT
self$ = 64
s$ = 72
load_long_binget PROC					; COMDAT

; 4862 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 4863 :     PyObject *value;
; 4864 :     Py_ssize_t idx;
; 4865 :     char *s;
; 4866 : 
; 4867 :     if (_Unpickler_Read(self, &s, 4) < 0)

  00006	48 8d 54 24 48	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00011	48 8b f9	 mov	 rdi, rcx
  00014	e8 00 00 00 00	 call	 _Unpickler_Read
  00019	48 85 c0	 test	 rax, rax
  0001c	79 09		 jns	 SHORT $LN7@load_long_@2

; 4868 :         return -1;

  0001e	83 c8 ff	 or	 eax, -1

; 4883 :     return 0;
; 4884 : }

  00021	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00025	5f		 pop	 rdi
  00026	c3		 ret	 0
$LN7@load_long_@2:

; 4869 : 
; 4870 :     idx = calc_binsize(s, 4);

  00027	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00031	e8 00 00 00 00	 call	 calc_binsize

; 4871 : 
; 4872 :     value = _Unpickler_MemoGet(self, idx);

  00036	48 8b cf	 mov	 rcx, rdi
  00039	48 8b d0	 mov	 rdx, rax
  0003c	e8 00 00 00 00	 call	 _Unpickler_MemoGet
  00041	48 8b d8	 mov	 rbx, rax

; 4873 :     if (value == NULL) {

  00044	48 85 c0	 test	 rax, rax
  00047	75 35		 jne	 SHORT $LN4@load_long_@2

; 4874 :         PyObject *key = PyLong_FromSsize_t(idx);

  00049	48 8b ca	 mov	 rcx, rdx
  0004c	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00051	48 8b d8	 mov	 rbx, rax

; 4875 :         if (key != NULL) {

  00054	48 85 c0	 test	 rax, rax
  00057	74 17		 je	 SHORT $LN5@load_long_@2

; 4876 :             PyErr_SetObject(PyExc_KeyError, key);

  00059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  00060	48 8b d0	 mov	 rdx, rax
  00063	e8 00 00 00 00	 call	 PyErr_SetObject

; 4877 :             Py_DECREF(key);

  00068	48 8b cb	 mov	 rcx, rbx
  0006b	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@load_long_@2:

; 4878 :         }
; 4879 :         return -1;

  00070	83 c8 ff	 or	 eax, -1
  00073	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 4883 :     return 0;
; 4884 : }

  00078	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007c	5f		 pop	 rdi
  0007d	c3		 ret	 0
$LN4@load_long_@2:

; 4880 :     }
; 4881 : 
; 4882 :     PDATA_APPEND(self->stack, value, -1);

  0007e	e8 00 00 00 00	 call	 _Py_PXCTX
  00083	85 c0		 test	 eax, eax
  00085	75 32		 jne	 SHORT $LN11@load_long_@2
  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00095	4c 8b cb	 mov	 r9, rbx
  00098	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0009e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a6	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ab	85 c0		 test	 eax, eax
  000ad	75 06		 jne	 SHORT $LN10@load_long_@2
  000af	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000b3	74 04		 je	 SHORT $LN11@load_long_@2
$LN10@load_long_@2:
  000b5	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN11@load_long_@2:
  000b9	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  000bd	48 8b d3	 mov	 rdx, rbx
  000c0	e8 00 00 00 00	 call	 Pdata_push
  000c5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ca	33 c9		 xor	 ecx, ecx
  000cc	85 c0		 test	 eax, eax
  000ce	0f 99 c1	 setns	 cl
  000d1	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4883 :     return 0;
; 4884 : }

  000d4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d8	5f		 pop	 rdi
  000d9	c3		 ret	 0
load_long_binget ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@FKFPALO@_inverted_registry?$FL?$CFld?$FN?5isn?8t?5a?5@ ; `string'
PUBLIC	??_C@_0CA@MCHHKMHE@unregistered?5extension?5code?5?$CFld?$AA@ ; `string'
PUBLIC	??_C@_0BI@NHAIMOIL@EXT?5specifies?5code?5?$DM?$DN?50?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$load_extension DD imagerel load_extension
	DD	imagerel load_extension+55
	DD	imagerel $unwind$load_extension
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$load_extension DD imagerel load_extension+55
	DD	imagerel load_extension+109
	DD	imagerel $chain$0$load_extension
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$load_extension DD imagerel load_extension+109
	DD	imagerel load_extension+498
	DD	imagerel $chain$3$load_extension
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$load_extension DD 040721H
	DD	097407H
	DD	086400H
	DD	imagerel load_extension
	DD	imagerel load_extension+55
	DD	imagerel $unwind$load_extension
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$load_extension DD 020521H
	DD	086405H
	DD	imagerel load_extension
	DD	imagerel load_extension+55
	DD	imagerel $unwind$load_extension
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_extension DD 040a01H
	DD	0b340aH
	DD	05006520aH
xdata	ENDS
;	COMDAT ??_C@_0DD@FKFPALO@_inverted_registry?$FL?$CFld?$FN?5isn?8t?5a?5@
CONST	SEGMENT
??_C@_0DD@FKFPALO@_inverted_registry?$FL?$CFld?$FN?5isn?8t?5a?5@ DB '_inv'
	DB	'erted_registry[%ld] isn''t a 2-tuple of strings', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@MCHHKMHE@unregistered?5extension?5code?5?$CFld?$AA@
CONST	SEGMENT
??_C@_0CA@MCHHKMHE@unregistered?5extension?5code?5?$CFld?$AA@ DB 'unregis'
	DB	'tered extension code %ld', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NHAIMOIL@EXT?5specifies?5code?5?$DM?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BI@NHAIMOIL@EXT?5specifies?5code?5?$DM?$DN?50?$AA@ DB 'EXT specifi'
	DB	'es code <= 0', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT load_extension
_TEXT	SEGMENT
self$ = 64
nbytes$ = 72
codebytes$ = 80
load_extension PROC					; COMDAT

; 4891 : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 63 da	 movsxd	 rbx, edx

; 4892 :     char *codebytes;            /* the nbytes bytes after the opcode */
; 4893 :     long code;                  /* calc_binint returns long */
; 4894 :     PyObject *py_code;          /* code as a Python int */
; 4895 :     PyObject *obj;              /* the object to push */
; 4896 :     PyObject *pair;             /* (module_name, class_name) */
; 4897 :     PyObject *module_name, *class_name;
; 4898 : 
; 4899 :     assert(nbytes == 1 || nbytes == 2 || nbytes == 4);
; 4900 :     if (_Unpickler_Read(self, &codebytes, nbytes) < 0)

  0000d	48 8d 54 24 50	 lea	 rdx, QWORD PTR codebytes$[rsp]
  00012	48 8b e9	 mov	 rbp, rcx
  00015	4c 8b c3	 mov	 r8, rbx
  00018	e8 00 00 00 00	 call	 _Unpickler_Read
  0001d	48 85 c0	 test	 rax, rax
  00020	79 0e		 jns	 SHORT $LN17@load_exten

; 4901 :         return -1;

  00022	83 c8 ff	 or	 eax, -1

; 4955 : }

  00025	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0002a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002e	5d		 pop	 rbp
  0002f	c3		 ret	 0
$LN17@load_exten:

; 4902 :     code = calc_binint(codebytes, nbytes);

  00030	48 8b 4c 24 50	 mov	 rcx, QWORD PTR codebytes$[rsp]
  00035	8b d3		 mov	 edx, ebx
  00037	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0003c	e8 00 00 00 00	 call	 calc_binint
  00041	8b f0		 mov	 esi, eax

; 4903 :     if (code <= 0) {            /* note that 0 is forbidden */

  00043	85 c0		 test	 eax, eax
  00045	7f 26		 jg	 SHORT $LN16@load_exten

; 4904 :         /* Corrupt or hostile pickle. */
; 4905 :         PyErr_SetString(UnpicklingError, "EXT specifies code <= 0");

  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@NHAIMOIL@EXT?5specifies?5code?5?$DM?$DN?50?$AA@
  00055	e8 00 00 00 00	 call	 PyErr_SetString
  0005a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 4906 :         return -1;

  0005f	83 c8 ff	 or	 eax, -1

; 4955 : }

  00062	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00067	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006b	5d		 pop	 rbp
  0006c	c3		 ret	 0
$LN16@load_exten:

; 4907 :     }
; 4908 : 
; 4909 :     /* Look for the code in the cache. */
; 4910 :     py_code = PyLong_FromLong(code);

  0006d	8b c8		 mov	 ecx, eax
  0006f	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00074	e8 00 00 00 00	 call	 PyLong_FromLong
  00079	48 8b f8	 mov	 rdi, rax

; 4911 :     if (py_code == NULL)

  0007c	48 85 c0	 test	 rax, rax

; 4912 :         return -1;

  0007f	0f 84 55 01 00
	00		 je	 $LN26@load_exten

; 4913 :     obj = PyDict_GetItem(extension_cache, py_code);

  00085	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR extension_cache
  0008c	48 8b d0	 mov	 rdx, rax
  0008f	e8 00 00 00 00	 call	 PyDict_GetItem
  00094	48 8b d8	 mov	 rbx, rax

; 4914 :     if (obj != NULL) {

  00097	48 85 c0	 test	 rax, rax
  0009a	74 4b		 je	 SHORT $LN14@load_exten

; 4915 :         /* Bingo. */
; 4916 :         Py_DECREF(py_code);

  0009c	48 8b cf	 mov	 rcx, rdi
  0009f	e8 00 00 00 00	 call	 _Py_DecRef

; 4917 :         PDATA_APPEND(self->stack, obj, -1);

  000a4	e8 00 00 00 00	 call	 _Py_PXCTX
  000a9	85 c0		 test	 eax, eax
  000ab	75 32		 jne	 SHORT $LN21@load_exten
  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000bb	4c 8b cb	 mov	 r9, rbx
  000be	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000c4	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000cc	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d1	85 c0		 test	 eax, eax
  000d3	75 06		 jne	 SHORT $LN20@load_exten
  000d5	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000d9	74 04		 je	 SHORT $LN21@load_exten
$LN20@load_exten:
  000db	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN21@load_exten:
  000df	48 8b d3	 mov	 rdx, rbx

; 4918 :         return 0;

  000e2	e9 c0 00 00 00	 jmp	 $LN28@load_exten
$LN14@load_exten:

; 4919 :     }
; 4920 : 
; 4921 :     /* Look up the (module_name, class_name) pair. */
; 4922 :     pair = PyDict_GetItem(inverted_registry, py_code);

  000e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR inverted_registry
  000ee	48 8b d7	 mov	 rdx, rdi
  000f1	e8 00 00 00 00	 call	 PyDict_GetItem
  000f6	48 8b d8	 mov	 rbx, rax

; 4923 :     if (pair == NULL) {

  000f9	48 85 c0	 test	 rax, rax
  000fc	75 14		 jne	 SHORT $LN9@load_exten

; 4924 :         Py_DECREF(py_code);

  000fe	48 8b cf	 mov	 rcx, rdi
  00101	e8 00 00 00 00	 call	 _Py_DecRef

; 4925 :         PyErr_Format(PyExc_ValueError, "unregistered extension "
; 4926 :                      "code %ld", code);

  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@MCHHKMHE@unregistered?5extension?5code?5?$CFld?$AA@

; 4927 :         return -1;

  0010d	e9 b9 00 00 00	 jmp	 $LN27@load_exten
$LN9@load_exten:

; 4928 :     }
; 4929 :     /* Since the extension registry is manipulable via Python code,
; 4930 :      * confirm that pair is really a 2-tuple of strings.
; 4931 :      */
; 4932 :     if (!PyTuple_Check(pair) || PyTuple_Size(pair) != 2 ||
; 4933 :         !PyUnicode_Check(module_name = PyTuple_GET_ITEM(pair, 0)) ||
; 4934 :         !PyUnicode_Check(class_name = PyTuple_GET_ITEM(pair, 1))) {

  00112	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00116	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00120	0f 84 96 00 00
	00		 je	 $LN7@load_exten
  00126	48 8b cb	 mov	 rcx, rbx
  00129	e8 00 00 00 00	 call	 PyTuple_Size
  0012e	48 83 f8 02	 cmp	 rax, 2
  00132	0f 85 84 00 00
	00		 jne	 $LN7@load_exten
  00138	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
  0013c	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00140	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0014a	74 70		 je	 SHORT $LN7@load_exten
  0014c	4c 8b 43 78	 mov	 r8, QWORD PTR [rbx+120]
  00150	49 8b 40 58	 mov	 rax, QWORD PTR [r8+88]
  00154	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0015e	74 5c		 je	 SHORT $LN7@load_exten

; 4939 :     }
; 4940 :     /* Load the object. */
; 4941 :     obj = find_class(self, module_name, class_name);

  00160	48 8b cd	 mov	 rcx, rbp
  00163	e8 00 00 00 00	 call	 find_class
  00168	48 8b f0	 mov	 rsi, rax

; 4942 :     if (obj == NULL) {

  0016b	48 85 c0	 test	 rax, rax
  0016e	75 0a		 jne	 SHORT $LN6@load_exten

; 4943 :         Py_DECREF(py_code);

  00170	48 8b cf	 mov	 rcx, rdi
  00173	e8 00 00 00 00	 call	 _Py_DecRef

; 4944 :         return -1;

  00178	eb 60		 jmp	 SHORT $LN26@load_exten
$LN6@load_exten:

; 4945 :     }
; 4946 :     /* Cache code -> obj. */
; 4947 :     code = PyDict_SetItem(extension_cache, py_code, obj);

  0017a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR extension_cache
  00181	4c 8b c0	 mov	 r8, rax
  00184	48 8b d7	 mov	 rdx, rdi
  00187	e8 00 00 00 00	 call	 PyDict_SetItem

; 4948 :     Py_DECREF(py_code);

  0018c	48 8b cf	 mov	 rcx, rdi
  0018f	8b d8		 mov	 ebx, eax
  00191	e8 00 00 00 00	 call	 _Py_DecRef

; 4949 :     if (code < 0) {

  00196	85 db		 test	 ebx, ebx
  00198	79 0a		 jns	 SHORT $LN4@load_exten

; 4950 :         Py_DECREF(obj);

  0019a	48 8b ce	 mov	 rcx, rsi
  0019d	e8 00 00 00 00	 call	 _Py_DecRef

; 4951 :         return -1;

  001a2	eb 36		 jmp	 SHORT $LN26@load_exten
$LN4@load_exten:

; 4952 :     }
; 4953 :     PDATA_PUSH(self->stack, obj, -1);

  001a4	48 8b d6	 mov	 rdx, rsi
$LN28@load_exten:
  001a7	48 8b 4d 60	 mov	 rcx, QWORD PTR [rbp+96]
  001ab	e8 00 00 00 00	 call	 Pdata_push
  001b0	33 c9		 xor	 ecx, ecx
  001b2	85 c0		 test	 eax, eax
  001b4	0f 99 c1	 setns	 cl
  001b7	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 4954 :     return 0;

  001ba	eb 21		 jmp	 SHORT $LN25@load_exten
$LN7@load_exten:

; 4935 :         Py_DECREF(py_code);

  001bc	48 8b cf	 mov	 rcx, rdi
  001bf	e8 00 00 00 00	 call	 _Py_DecRef

; 4936 :         PyErr_Format(PyExc_ValueError, "_inverted_registry[%ld] "
; 4937 :                      "isn't a 2-tuple of strings", code);

  001c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@FKFPALO@_inverted_registry?$FL?$CFld?$FN?5isn?8t?5a?5@
$LN27@load_exten:
  001cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001d2	44 8b c6	 mov	 r8d, esi
  001d5	e8 00 00 00 00	 call	 PyErr_Format
$LN26@load_exten:

; 4938 :         return -1;

  001da	83 c8 ff	 or	 eax, -1
$LN25@load_exten:
  001dd	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  001e2	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 4955 : }

  001e7	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  001ec	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001f0	5d		 pop	 rbp
  001f1	c3		 ret	 0
load_extension ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@FMJDFNLA@negative?5PUT?5argument?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_put DD imagerel load_put
	DD	imagerel load_put+80
	DD	imagerel $unwind$load_put
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$load_put DD imagerel load_put+80
	DD	imagerel load_put+136
	DD	imagerel $chain$1$load_put
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$load_put DD imagerel load_put+136
	DD	imagerel load_put+234
	DD	imagerel $chain$4$load_put
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$load_put DD 060821H
	DD	097408H
	DD	086400H
	DD	065400H
	DD	imagerel load_put
	DD	imagerel load_put+80
	DD	imagerel $unwind$load_put
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$load_put DD 041821H
	DD	086418H
	DD	065405H
	DD	imagerel load_put
	DD	imagerel load_put+80
	DD	imagerel $unwind$load_put
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_put DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BG@FMJDFNLA@negative?5PUT?5argument?$AA@
CONST	SEGMENT
??_C@_0BG@FMJDFNLA@negative?5PUT?5argument?$AA@ DB 'negative PUT argument'
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT load_put
_TEXT	SEGMENT
self$ = 48
s$ = 56
load_put PROC						; COMDAT

; 4959 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4960 :     PyObject *key, *value;
; 4961 :     Py_ssize_t idx;
; 4962 :     Py_ssize_t len;
; 4963 :     char *s;
; 4964 : 
; 4965 :     if ((len = _Unpickler_Readline(self, &s)) < 0)

  00006	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	e8 00 00 00 00	 call	 _Unpickler_Readline
  00013	48 85 c0	 test	 rax, rax
  00016	79 09		 jns	 SHORT $LN6@load_put

; 4966 :         return -1;

  00018	83 c8 ff	 or	 eax, -1

; 4986 : }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
$LN6@load_put:

; 4967 :     if (len < 2)

  00021	48 83 f8 02	 cmp	 rax, 2
  00025	7d 0a		 jge	 SHORT $LN5@load_put

; 4986 : }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx
  0002c	e9 00 00 00 00	 jmp	 bad_readline
$LN5@load_put:

; 4968 :         return bad_readline();
; 4969 :     if (Py_SIZE(self->stack) <= 0)

  00031	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  00035	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0003a	7f 0a		 jg	 SHORT $LN4@load_put

; 4986 : }

  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5b		 pop	 rbx
  00041	e9 00 00 00 00	 jmp	 stack_underflow
$LN4@load_put:

; 4970 :         return stack_underflow();
; 4971 :     value = self->stack->data[Py_SIZE(self->stack) - 1];

  00046	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0004a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]

; 4972 : 
; 4973 :     key = PyLong_FromString(s, NULL, 10);

  0004e	33 d2		 xor	 edx, edx
  00050	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00055	48 8b 6c c8 f8	 mov	 rbp, QWORD PTR [rax+rcx*8-8]
  0005a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0005f	44 8d 42 0a	 lea	 r8d, QWORD PTR [rdx+10]
  00063	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00068	e8 00 00 00 00	 call	 PyLong_FromString
  0006d	48 8b f0	 mov	 rsi, rax

; 4974 :     if (key == NULL)

  00070	48 85 c0	 test	 rax, rax
  00073	75 13		 jne	 SHORT $LN3@load_put

; 4975 :         return -1;

  00075	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0007a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0007f	83 c8 ff	 or	 eax, -1

; 4986 : }

  00082	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00086	5b		 pop	 rbx
  00087	c3		 ret	 0
$LN3@load_put:

; 4976 :     idx = PyLong_AsSsize_t(key);

  00088	48 8b c8	 mov	 rcx, rax
  0008b	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00090	e8 00 00 00 00	 call	 PyLong_AsSsize_t

; 4977 :     Py_DECREF(key);

  00095	48 8b ce	 mov	 rcx, rsi
  00098	48 8b f8	 mov	 rdi, rax
  0009b	e8 00 00 00 00	 call	 _Py_DecRef

; 4978 :     if (idx < 0) {

  000a0	48 85 ff	 test	 rdi, rdi
  000a3	79 22		 jns	 SHORT $LN2@load_put

; 4979 :         if (!PyErr_Occurred())

  000a5	e8 00 00 00 00	 call	 PyErr_Occurred
  000aa	48 85 c0	 test	 rax, rax
  000ad	75 13		 jne	 SHORT $LN1@load_put

; 4980 :             PyErr_SetString(PyExc_ValueError,
; 4981 :                             "negative PUT argument");

  000af	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@FMJDFNLA@negative?5PUT?5argument?$AA@
  000bd	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@load_put:

; 4982 :         return -1;

  000c2	83 c8 ff	 or	 eax, -1
  000c5	eb 0e		 jmp	 SHORT $LN11@load_put
$LN2@load_put:

; 4983 :     }
; 4984 : 
; 4985 :     return _Unpickler_MemoPut(self, idx, value);

  000c7	4c 8b c5	 mov	 r8, rbp
  000ca	48 8b d7	 mov	 rdx, rdi
  000cd	48 8b cb	 mov	 rcx, rbx
  000d0	e8 00 00 00 00	 call	 _Unpickler_MemoPut
$LN11@load_put:
  000d5	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000da	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  000df	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 4986 : }

  000e4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e8	5b		 pop	 rbx
  000e9	c3		 ret	 0
load_put ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_binput DD imagerel load_binput
	DD	imagerel load_binput+94
	DD	imagerel $unwind$load_binput
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_binput DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_binput
_TEXT	SEGMENT
self$ = 48
s$ = 56
load_binput PROC					; COMDAT

; 4990 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4991 :     PyObject *value;
; 4992 :     Py_ssize_t idx;
; 4993 :     char *s;
; 4994 : 
; 4995 :     if (_Unpickler_Read(self, &s, 1) < 0)

  00006	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00011	48 8b d9	 mov	 rbx, rcx
  00014	e8 00 00 00 00	 call	 _Unpickler_Read
  00019	48 85 c0	 test	 rax, rax
  0001c	79 09		 jns	 SHORT $LN2@load_binpu

; 4996 :         return -1;

  0001e	83 c8 ff	 or	 eax, -1

; 5005 : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
$LN2@load_binpu:

; 4997 : 
; 4998 :     if (Py_SIZE(self->stack) <= 0)

  00027	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  0002b	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00030	7f 0a		 jg	 SHORT $LN1@load_binpu

; 5005 : }

  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5b		 pop	 rbx
  00037	e9 00 00 00 00	 jmp	 stack_underflow
$LN1@load_binpu:

; 4999 :         return stack_underflow();
; 5000 :     value = self->stack->data[Py_SIZE(self->stack) - 1];

  0003c	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00040	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00044	4c 8b 44 c8 f8	 mov	 r8, QWORD PTR [rax+rcx*8-8]

; 5001 : 
; 5002 :     idx = Py_CHARMASK(s[0]);

  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]

; 5003 : 
; 5004 :     return _Unpickler_MemoPut(self, idx, value);

  0004e	48 8b cb	 mov	 rcx, rbx
  00051	0f b6 10	 movzx	 edx, BYTE PTR [rax]

; 5005 : }

  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5b		 pop	 rbx
  00059	e9 00 00 00 00	 jmp	 _Unpickler_MemoPut
load_binput ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@KDGICMDO@negative?5LONG_BINPUT?5argument?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_long_binput DD imagerel load_long_binput
	DD	imagerel load_long_binput+126
	DD	imagerel $unwind$load_long_binput
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_long_binput DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BO@KDGICMDO@negative?5LONG_BINPUT?5argument?$AA@
CONST	SEGMENT
??_C@_0BO@KDGICMDO@negative?5LONG_BINPUT?5argument?$AA@ DB 'negative LONG'
	DB	'_BINPUT argument', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT load_long_binput
_TEXT	SEGMENT
self$ = 48
s$ = 56
load_long_binput PROC					; COMDAT

; 5009 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5010 :     PyObject *value;
; 5011 :     Py_ssize_t idx;
; 5012 :     char *s;
; 5013 : 
; 5014 :     if (_Unpickler_Read(self, &s, 4) < 0)

  00006	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00011	48 8b d9	 mov	 rbx, rcx
  00014	e8 00 00 00 00	 call	 _Unpickler_Read
  00019	48 85 c0	 test	 rax, rax

; 5015 :         return -1;

  0001c	78 44		 js	 SHORT $LN6@load_long_@3

; 5016 : 
; 5017 :     if (Py_SIZE(self->stack) <= 0)

  0001e	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  00022	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00027	7f 0a		 jg	 SHORT $LN2@load_long_@3

; 5029 : }

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5b		 pop	 rbx
  0002e	e9 00 00 00 00	 jmp	 stack_underflow
$LN2@load_long_@3:

; 5018 :         return stack_underflow();
; 5019 :     value = self->stack->data[Py_SIZE(self->stack) - 1];

  00033	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00037	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0003b	4c 8b 4c c8 f8	 mov	 r9, QWORD PTR [rax+rcx*8-8]

; 5020 : 
; 5021 :     idx = calc_binsize(s, 4);

  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00045	e8 00 00 00 00	 call	 calc_binsize

; 5022 :     if (idx < 0) {

  0004a	48 85 c0	 test	 rax, rax
  0004d	79 1c		 jns	 SHORT $LN1@load_long_@3

; 5023 :         PyErr_SetString(PyExc_ValueError,
; 5024 :                         "negative LONG_BINPUT argument");

  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@KDGICMDO@negative?5LONG_BINPUT?5argument?$AA@
  0005d	e8 00 00 00 00	 call	 PyErr_SetString
$LN6@load_long_@3:

; 5025 :         return -1;

  00062	83 c8 ff	 or	 eax, -1

; 5029 : }

  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	5b		 pop	 rbx
  0006a	c3		 ret	 0
$LN1@load_long_@3:

; 5026 :     }
; 5027 : 
; 5028 :     return _Unpickler_MemoPut(self, idx, value);

  0006b	4d 8b c1	 mov	 r8, r9
  0006e	48 8b d0	 mov	 rdx, rax
  00071	48 8b cb	 mov	 rcx, rbx

; 5029 : }

  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5b		 pop	 rbx
  00079	e9 00 00 00 00	 jmp	 _Unpickler_MemoPut
load_long_binput ENDP
_TEXT	ENDS
EXTRN	PyList_SetSlice:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_append DD imagerel do_append
	DD	imagerel do_append+74
	DD	imagerel $unwind$do_append
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$do_append DD imagerel do_append+74
	DD	imagerel do_append+183
	DD	imagerel $chain$0$do_append
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$do_append DD imagerel do_append+183
	DD	imagerel do_append+291
	DD	imagerel $chain$1$do_append
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$do_append DD imagerel do_append+291
	DD	imagerel do_append+312
	DD	imagerel $chain$2$do_append
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$do_append DD imagerel do_append+312
	DD	imagerel do_append+346
	DD	imagerel $chain$4$do_append
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$do_append DD imagerel do_append+346
	DD	imagerel do_append+366
	DD	imagerel $chain$5$do_append
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$do_append DD 021H
	DD	imagerel do_append
	DD	imagerel do_append+74
	DD	imagerel $unwind$do_append
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$do_append DD 040021H
	DD	07c400H
	DD	063400H
	DD	imagerel do_append
	DD	imagerel do_append+74
	DD	imagerel $unwind$do_append
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$do_append DD 021H
	DD	imagerel do_append+74
	DD	imagerel do_append+183
	DD	imagerel $chain$0$do_append
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$do_append DD 020521H
	DD	07c405H
	DD	imagerel do_append+74
	DD	imagerel do_append+183
	DD	imagerel $chain$0$do_append
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$do_append DD 020521H
	DD	063405H
	DD	imagerel do_append
	DD	imagerel do_append+74
	DD	imagerel $unwind$do_append
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_append DD 060f01H
	DD	09640fH
	DD	08540fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT do_append
_TEXT	SEGMENT
self$ = 48
x$ = 56
do_append PROC						; COMDAT

; 5033 : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b e9	 mov	 rbp, rcx

; 5034 :     PyObject *value;
; 5035 :     PyObject *list;
; 5036 :     Py_ssize_t len, i;
; 5037 : 
; 5038 :     len = Py_SIZE(self->stack);

  00012	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00016	48 8b fa	 mov	 rdi, rdx
  00019	48 8b 71 60	 mov	 rsi, QWORD PTR [rcx+96]

; 5039 :     if (x > len || x <= 0)

  0001d	48 3b d6	 cmp	 rdx, rsi
  00020	0f 8f 34 01 00
	00		 jg	 $LN10@do_append
  00026	48 85 d2	 test	 rdx, rdx
  00029	0f 8e 2b 01 00
	00		 jle	 $LN10@do_append

; 5040 :         return stack_underflow();
; 5041 :     if (len == x)  /* nothing to do */

  0002f	48 3b f2	 cmp	 rsi, rdx
  00032	75 12		 jne	 SHORT $LN9@do_append

; 5042 :         return 0;

  00034	33 c0		 xor	 eax, eax

; 5084 : }

  00036	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0003b	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
$LN9@do_append:

; 5043 : 
; 5044 :     list = self->stack->data[x - 1];

  00046	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  0004a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0004f	48 8b 5c d0 f8	 mov	 rbx, QWORD PTR [rax+rdx*8-8]

; 5045 : 
; 5046 :     if (PyList_Check(list)) {

  00054	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00058	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  00062	74 38		 je	 SHORT $LN8@do_append

; 5047 :         PyObject *slice;
; 5048 :         Py_ssize_t list_len;
; 5049 :         int ret;
; 5050 : 
; 5051 :         slice = Pdata_poplist(self->stack, x);

  00064	e8 00 00 00 00	 call	 Pdata_poplist
  00069	48 8b f8	 mov	 rdi, rax

; 5052 :         if (!slice)

  0006c	48 85 c0	 test	 rax, rax
  0006f	75 08		 jne	 SHORT $LN7@do_append

; 5053 :             return -1;

  00071	83 c8 ff	 or	 eax, -1
  00074	e9 aa 00 00 00	 jmp	 $LN17@do_append
$LN7@do_append:

; 5054 :         list_len = PyList_GET_SIZE(list);

  00079	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]

; 5055 :         ret = PyList_SetSlice(list, list_len, list_len, slice);

  0007d	4c 8b c8	 mov	 r9, rax
  00080	48 8b cb	 mov	 rcx, rbx
  00083	4c 8b c2	 mov	 r8, rdx
  00086	e8 00 00 00 00	 call	 PyList_SetSlice

; 5056 :         Py_DECREF(slice);

  0008b	48 8b cf	 mov	 rcx, rdi
  0008e	8b d8		 mov	 ebx, eax
  00090	e8 00 00 00 00	 call	 _Py_DecRef

; 5057 :         return ret;

  00095	8b c3		 mov	 eax, ebx
  00097	e9 87 00 00 00	 jmp	 $LN17@do_append
$LN8@do_append:

; 5058 :     }
; 5059 :     else {
; 5060 :         PyObject *append_func;
; 5061 :         _Py_IDENTIFIER(append);
; 5062 : 
; 5063 :         append_func = _PyObject_GetAttrId(list, &PyId_append);

  0009c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000a2	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000ab	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_append@?3??do_append@@9@9
  000b0	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000b4	48 8b cb	 mov	 rcx, rbx
  000b7	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  000bc	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  000c1	4c 8b e0	 mov	 r12, rax

; 5064 :         if (append_func == NULL)

  000c4	48 85 c0	 test	 rax, rax

; 5065 :             return -1;

  000c7	0f 84 88 00 00
	00		 je	 $LN19@do_append

; 5066 :         for (i = x; i < len; i++) {

  000cd	48 8b df	 mov	 rbx, rdi
  000d0	48 3b fe	 cmp	 rdi, rsi
  000d3	7d 37		 jge	 SHORT $LN2@do_append
  000d5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@do_append:

; 5067 :             PyObject *result;
; 5068 : 
; 5069 :             value = self->stack->data[i];

  000e0	48 8b 45 60	 mov	 rax, QWORD PTR [rbp+96]

; 5070 :             result = _Unpickler_FastCall(self, append_func, value);

  000e4	49 8b d4	 mov	 rdx, r12
  000e7	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  000eb	4c 8b 04 d9	 mov	 r8, QWORD PTR [rcx+rbx*8]
  000ef	48 8b cd	 mov	 rcx, rbp
  000f2	e8 00 00 00 00	 call	 _Unpickler_FastCall

; 5071 :             if (result == NULL) {

  000f7	48 85 c0	 test	 rax, rax
  000fa	74 3c		 je	 SHORT $LN15@do_append

; 5076 :             }
; 5077 :             Py_DECREF(result);

  000fc	48 8b c8	 mov	 rcx, rax
  000ff	e8 00 00 00 00	 call	 _Py_DecRef
  00104	48 ff c3	 inc	 rbx
  00107	48 3b de	 cmp	 rbx, rsi
  0010a	7c d4		 jl	 SHORT $LL4@do_append
$LN2@do_append:

; 5078 :         }
; 5079 :         Py_SIZE(self->stack) = x;

  0010c	48 8b 45 60	 mov	 rax, QWORD PTR [rbp+96]

; 5080 :         Py_DECREF(append_func);

  00110	49 8b cc	 mov	 rcx, r12
  00113	48 89 78 60	 mov	 QWORD PTR [rax+96], rdi
  00117	e8 00 00 00 00	 call	 _Py_DecRef

; 5081 :     }
; 5082 : 
; 5083 :     return 0;

  0011c	33 c0		 xor	 eax, eax
$LN18@do_append:
  0011e	4c 8b 64 24 38	 mov	 r12, QWORD PTR [rsp+56]
$LN17@do_append:
  00123	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 5084 : }

  00128	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0012d	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00132	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00136	5f		 pop	 rdi
  00137	c3		 ret	 0
$LN15@do_append:

; 5072 :                 Pdata_clear(self->stack, i + 1);

  00138	48 8b 4d 60	 mov	 rcx, QWORD PTR [rbp+96]
  0013c	48 8d 53 01	 lea	 rdx, QWORD PTR [rbx+1]
  00140	e8 00 00 00 00	 call	 Pdata_clear

; 5073 :                 Py_SIZE(self->stack) = x;

  00145	4c 8b 5d 60	 mov	 r11, QWORD PTR [rbp+96]

; 5074 :                 Py_DECREF(append_func);

  00149	49 8b cc	 mov	 rcx, r12
  0014c	49 89 7b 60	 mov	 QWORD PTR [r11+96], rdi
  00150	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@do_append:

; 5075 :                 return -1;

  00155	83 c8 ff	 or	 eax, -1
  00158	eb c4		 jmp	 SHORT $LN18@do_append
$LN10@do_append:

; 5084 : }

  0015a	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0015f	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00164	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00168	5f		 pop	 rdi
  00169	e9 00 00 00 00	 jmp	 stack_underflow
do_append ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT load_append
_TEXT	SEGMENT
self$ = 8
load_append PROC					; COMDAT

; 5089 :     return do_append(self, Py_SIZE(self->stack) - 1);

  00000	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00004	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00008	48 ff ca	 dec	 rdx

; 5090 : }

  0000b	e9 00 00 00 00	 jmp	 do_append
load_append ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_appends DD imagerel load_appends
	DD	imagerel load_appends+30
	DD	imagerel $unwind$load_appends
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_appends DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_appends
_TEXT	SEGMENT
self$ = 48
load_appends PROC					; COMDAT

; 5094 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 5095 :     return do_append(self, marker(self));

  00009	e8 00 00 00 00	 call	 marker
  0000e	48 8b cb	 mov	 rcx, rbx
  00011	48 8b d0	 mov	 rdx, rax

; 5096 : }

  00014	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00018	5b		 pop	 rbx
  00019	e9 00 00 00 00	 jmp	 do_append
load_appends ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@LEPMKFJ@odd?5number?5of?5items?5for?5SETITEMS@ ; `string'
EXTRN	PyObject_SetItem:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_setitems DD imagerel do_setitems
	DD	imagerel do_setitems+127
	DD	imagerel $unwind$do_setitems
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$do_setitems DD imagerel do_setitems+127
	DD	imagerel do_setitems+243
	DD	imagerel $chain$1$do_setitems
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$do_setitems DD imagerel do_setitems+243
	DD	imagerel do_setitems+261
	DD	imagerel $chain$2$do_setitems
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$do_setitems DD 021H
	DD	imagerel do_setitems
	DD	imagerel do_setitems+127
	DD	imagerel $unwind$do_setitems
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$do_setitems DD 040e21H
	DD	09d40eH
	DD	083405H
	DD	imagerel do_setitems
	DD	imagerel do_setitems+127
	DD	imagerel $unwind$do_setitems
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_setitems DD 060d01H
	DD	0a540dH
	DD	0c009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT ??_C@_0CB@LEPMKFJ@odd?5number?5of?5items?5for?5SETITEMS@
CONST	SEGMENT
??_C@_0CB@LEPMKFJ@odd?5number?5of?5items?5for?5SETITEMS@ DB 'odd number o'
	DB	'f items for SETITEMS', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT do_setitems
_TEXT	SEGMENT
self$ = 64
x$ = 72
do_setitems PROC					; COMDAT

; 5100 : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000d	4c 8b e1	 mov	 r12, rcx

; 5101 :     PyObject *value, *key;
; 5102 :     PyObject *dict;
; 5103 :     Py_ssize_t len, i;
; 5104 :     int status = 0;
; 5105 : 
; 5106 :     len = Py_SIZE(self->stack);

  00010	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00014	33 ed		 xor	 ebp, ebp
  00016	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]
  0001a	48 8b f2	 mov	 rsi, rdx

; 5107 :     if (x > len || x <= 0)

  0001d	48 3b d7	 cmp	 rdx, rdi
  00020	0f 8f cd 00 00
	00		 jg	 $LN7@do_setitem
  00026	48 85 d2	 test	 rdx, rdx
  00029	0f 8e c4 00 00
	00		 jle	 $LN7@do_setitem

; 5108 :         return stack_underflow();
; 5109 :     if (len == x)  /* nothing to do */

  0002f	48 3b fa	 cmp	 rdi, rdx
  00032	75 10		 jne	 SHORT $LN6@do_setitem

; 5110 :         return 0;

  00034	33 c0		 xor	 eax, eax

; 5132 : }

  00036	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	41 5c		 pop	 r12
  00041	5f		 pop	 rdi
  00042	5e		 pop	 rsi
  00043	c3		 ret	 0
$LN6@do_setitem:

; 5111 :     if ((len - x) % 2 != 0) {

  00044	48 8b c7	 mov	 rax, rdi
  00047	48 2b c2	 sub	 rax, rdx
  0004a	48 99		 cdq
  0004c	83 e0 01	 and	 eax, 1
  0004f	48 33 c2	 xor	 rax, rdx
  00052	48 3b c2	 cmp	 rax, rdx
  00055	74 24		 je	 SHORT $LN5@do_setitem

; 5112 :         /* Currupt or hostile pickle -- we never write one like this. */
; 5113 :         PyErr_SetString(UnpicklingError, "odd number of items for SETITEMS");

  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@LEPMKFJ@odd?5number?5of?5items?5for?5SETITEMS@
  00065	e8 00 00 00 00	 call	 PyErr_SetString

; 5114 :         return -1;

  0006a	83 c8 ff	 or	 eax, -1

; 5132 : }

  0006d	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00072	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00076	41 5c		 pop	 r12
  00078	5f		 pop	 rdi
  00079	5e		 pop	 rsi
  0007a	c3		 ret	 0
$LN5@do_setitem:

; 5115 :     }
; 5116 : 
; 5117 :     /* Here, dict does not actually need to be a PyDict; it could be anything
; 5118 :        that supports the __setitem__ attribute. */
; 5119 :     dict = self->stack->data[x - 1];

  0007b	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  0007f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 5120 : 
; 5121 :     for (i = x + 1; i < len; i += 2) {

  00084	48 8d 5e 01	 lea	 rbx, QWORD PTR [rsi+1]
  00088	4c 89 6c 24 48	 mov	 QWORD PTR [rsp+72], r13
  0008d	4c 8b 6c f0 f8	 mov	 r13, QWORD PTR [rax+rsi*8-8]
  00092	48 3b df	 cmp	 rbx, rdi
  00095	7d 35		 jge	 SHORT $LN2@do_setitem
  00097	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@do_setitem:
  000a0	49 8b 44 24 60	 mov	 rax, QWORD PTR [r12+96]

; 5122 :         key = self->stack->data[i - 1];
; 5123 :         value = self->stack->data[i];
; 5124 :         if (PyObject_SetItem(dict, key, value) < 0) {

  000a5	49 8b cd	 mov	 rcx, r13
  000a8	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000ac	49 8b 54 d8 f8	 mov	 rdx, QWORD PTR [r8+rbx*8-8]
  000b1	4d 8b 04 d8	 mov	 r8, QWORD PTR [r8+rbx*8]
  000b5	e8 00 00 00 00	 call	 PyObject_SetItem
  000ba	85 c0		 test	 eax, eax
  000bc	78 0b		 js	 SHORT $LN12@do_setitem

; 5120 : 
; 5121 :     for (i = x + 1; i < len; i += 2) {

  000be	48 83 c3 02	 add	 rbx, 2
  000c2	48 3b df	 cmp	 rbx, rdi
  000c5	7c d9		 jl	 SHORT $LL4@do_setitem

; 5122 :         key = self->stack->data[i - 1];
; 5123 :         value = self->stack->data[i];
; 5124 :         if (PyObject_SetItem(dict, key, value) < 0) {

  000c7	eb 03		 jmp	 SHORT $LN2@do_setitem
$LN12@do_setitem:

; 5125 :             status = -1;

  000c9	83 cd ff	 or	 ebp, -1
$LN2@do_setitem:

; 5126 :             break;
; 5127 :         }
; 5128 :     }
; 5129 : 
; 5130 :     Pdata_clear(self->stack, x);

  000cc	49 8b 4c 24 60	 mov	 rcx, QWORD PTR [r12+96]
  000d1	48 8b d6	 mov	 rdx, rsi
  000d4	e8 00 00 00 00	 call	 Pdata_clear
  000d9	4c 8b 6c 24 48	 mov	 r13, QWORD PTR [rsp+72]
  000de	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 5131 :     return status;

  000e3	8b c5		 mov	 eax, ebp

; 5132 : }

  000e5	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000ea	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ee	41 5c		 pop	 r12
  000f0	5f		 pop	 rdi
  000f1	5e		 pop	 rsi
  000f2	c3		 ret	 0
$LN7@do_setitem:
  000f3	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000f8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fc	41 5c		 pop	 r12
  000fe	5f		 pop	 rdi
  000ff	5e		 pop	 rsi
  00100	e9 00 00 00 00	 jmp	 stack_underflow
do_setitems ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT load_setitem
_TEXT	SEGMENT
self$ = 8
load_setitem PROC					; COMDAT

; 5137 :     return do_setitems(self, Py_SIZE(self->stack) - 2);

  00000	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00004	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00008	48 83 ea 02	 sub	 rdx, 2

; 5138 : }

  0000c	e9 00 00 00 00	 jmp	 do_setitems
load_setitem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_setitems DD imagerel load_setitems
	DD	imagerel load_setitems+30
	DD	imagerel $unwind$load_setitems
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_setitems DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_setitems
_TEXT	SEGMENT
self$ = 48
load_setitems PROC					; COMDAT

; 5142 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 5143 :     return do_setitems(self, marker(self));

  00009	e8 00 00 00 00	 call	 marker
  0000e	48 8b cb	 mov	 rcx, rbx
  00011	48 8b d0	 mov	 rdx, rax

; 5144 : }

  00014	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00018	5b		 pop	 rbx
  00019	e9 00 00 00 00	 jmp	 do_setitems
load_setitems ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@BKAEOMIB@slot?5state?5is?5not?5a?5dictionary?$AA@ ; `string'
PUBLIC	??_C@_0BK@BPIFALMC@state?5is?5not?5a?5dictionary?$AA@ ; `string'
EXTRN	PyObject_SetAttr:PROC
EXTRN	PyUnicode_InternInPlace:PROC
EXTRN	PyUnicode_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_build DD imagerel load_build
	DD	imagerel load_build+34
	DD	imagerel $unwind$load_build
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$load_build DD imagerel load_build+34
	DD	imagerel load_build+67
	DD	imagerel $chain$0$load_build
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$load_build DD imagerel load_build+67
	DD	imagerel load_build+720
	DD	imagerel $chain$5$load_build
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$load_build DD 081b21H
	DD	07d41bH
	DD	08c40eH
	DD	0a6409H
	DD	097400H
	DD	imagerel load_build
	DD	imagerel load_build+34
	DD	imagerel $unwind$load_build
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$load_build DD 020521H
	DD	097405H
	DD	imagerel load_build
	DD	imagerel load_build+34
	DD	imagerel $unwind$load_build
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_build DD 030701H
	DD	05003a207H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_0BP@BKAEOMIB@slot?5state?5is?5not?5a?5dictionary?$AA@
CONST	SEGMENT
??_C@_0BP@BKAEOMIB@slot?5state?5is?5not?5a?5dictionary?$AA@ DB 'slot stat'
	DB	'e is not a dictionary', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BPIFALMC@state?5is?5not?5a?5dictionary?$AA@
CONST	SEGMENT
??_C@_0BK@BPIFALMC@state?5is?5not?5a?5dictionary?$AA@ DB 'state is not a '
	DB	'dictionary', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT load_build
_TEXT	SEGMENT
d_key$24151 = 32
i$24153 = 40
d_key$24127 = 112
self$ = 112
d_value$24128 = 120
i$24129 = 128
d_value$24152 = 136
load_build PROC						; COMDAT

; 5148 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00007	48 8b d9	 mov	 rbx, rcx

; 5149 :     PyObject *state, *inst, *slotstate;
; 5150 :     PyObject *setstate;
; 5151 :     int status = 0;
; 5152 :     _Py_IDENTIFIER(__setstate__);
; 5153 : 
; 5154 :     /* Stack is ... instance, state.  We want to leave instance at
; 5155 :      * the stack top, possibly mutated via instance.__setstate__(state).
; 5156 :      */
; 5157 :     if (Py_SIZE(self->stack) < 2)

  0000a	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0000e	33 ed		 xor	 ebp, ebp
  00010	48 83 79 60 02	 cmp	 QWORD PTR [rcx+96], 2
  00015	7d 0b		 jge	 SHORT $LN28@load_build

; 5260 : }

  00017	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0001b	5d		 pop	 rbp
  0001c	5b		 pop	 rbx
  0001d	e9 00 00 00 00	 jmp	 stack_underflow
$LN28@load_build:
  00022	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 5158 :         return stack_underflow();
; 5159 : 
; 5160 :     PDATA_POP(self->stack, state);

  00027	e8 00 00 00 00	 call	 Pdata_pop
  0002c	48 8b f8	 mov	 rdi, rax

; 5161 :     if (state == NULL)

  0002f	48 85 c0	 test	 rax, rax
  00032	75 0f		 jne	 SHORT $LN25@load_build

; 5162 :         return -1;

  00034	83 c8 ff	 or	 eax, -1
  00037	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 5260 : }

  0003c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00040	5d		 pop	 rbp
  00041	5b		 pop	 rbx
  00042	c3		 ret	 0
$LN25@load_build:

; 5163 : 
; 5164 :     inst = self->stack->data[Py_SIZE(self->stack) - 1];

  00043	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  00047	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0004c	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12
  00051	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00055	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00059	4c 89 6c 24 38	 mov	 QWORD PTR [rsp+56], r13
  0005e	4c 8b 6c c8 f8	 mov	 r13, QWORD PTR [rax+rcx*8-8]

; 5165 : 
; 5166 :     setstate = _PyObject_GetAttrId(inst, &PyId___setstate__);

  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00069	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00072	4c 8b 24 c8	 mov	 r12, QWORD PTR [rax+rcx*8]
  00076	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___setstate__@?1??load_build@@9@9
  0007b	49 8b cd	 mov	 rcx, r13
  0007e	49 03 d4	 add	 rdx, r12
  00081	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00086	48 8b f0	 mov	 rsi, rax

; 5167 :     if (setstate == NULL) {

  00089	48 85 c0	 test	 rax, rax
  0008c	0f 85 fb 01 00
	00		 jne	 $LN24@load_build

; 5168 :         if (PyErr_ExceptionMatches(PyExc_AttributeError))

  00092	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00099	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0009e	85 c0		 test	 eax, eax
  000a0	0f 84 da 01 00
	00		 je	 $LN23@load_build

; 5169 :             PyErr_Clear();

  000a6	e8 00 00 00 00	 call	 PyErr_Clear

; 5187 :     }
; 5188 : 
; 5189 :     /* A default __setstate__.  First see whether state embeds a
; 5190 :      * slot state dict too (a proto 2 addition).
; 5191 :      */
; 5192 :     if (PyTuple_Check(state) && Py_SIZE(state) == 2) {

  000ab	4c 8b 5f 58	 mov	 r11, QWORD PTR [rdi+88]
  000af	41 f7 83 00 01
	00 00 00 00 00
	04		 test	 DWORD PTR [r11+256], 67108864 ; 04000000H
  000ba	74 2c		 je	 SHORT $LN19@load_build
  000bc	48 83 7f 60 02	 cmp	 QWORD PTR [rdi+96], 2
  000c1	75 25		 jne	 SHORT $LN19@load_build

; 5193 :         PyObject *tmp = state;

  000c3	48 8b df	 mov	 rbx, rdi

; 5194 : 
; 5195 :         state = PyTuple_GET_ITEM(tmp, 0);

  000c6	48 8b 7f 70	 mov	 rdi, QWORD PTR [rdi+112]

; 5196 :         slotstate = PyTuple_GET_ITEM(tmp, 1);

  000ca	48 8b 73 78	 mov	 rsi, QWORD PTR [rbx+120]

; 5197 :         Py_INCREF(state);

  000ce	48 8b cf	 mov	 rcx, rdi
  000d1	e8 00 00 00 00	 call	 _Py_IncRef

; 5198 :         Py_INCREF(slotstate);

  000d6	48 8b ce	 mov	 rcx, rsi
  000d9	e8 00 00 00 00	 call	 _Py_IncRef

; 5199 :         Py_DECREF(tmp);

  000de	48 8b cb	 mov	 rcx, rbx
  000e1	e8 00 00 00 00	 call	 _Py_DecRef

; 5200 :     }
; 5201 :     else

  000e6	eb 03		 jmp	 SHORT $LN18@load_build
$LN19@load_build:

; 5202 :         slotstate = NULL;

  000e8	48 8b f5	 mov	 rsi, rbp
$LN18@load_build:

; 5203 : 
; 5204 :     /* Set inst.__dict__ from the state dict (if any). */
; 5205 :     if (state != Py_None) {

  000eb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000f2	48 3b f8	 cmp	 rdi, rax
  000f5	0f 84 ec 00 00
	00		 je	 $LN17@load_build

; 5206 :         PyObject *dict;
; 5207 :         PyObject *d_key, *d_value;
; 5208 :         Py_ssize_t i;
; 5209 :         _Py_IDENTIFIER(__dict__);
; 5210 : 
; 5211 :         if (!PyDict_Check(state)) {

  000fb	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  000ff	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  00109	75 32		 jne	 SHORT $LN16@load_build

; 5212 :             PyErr_SetString(UnpicklingError, "state is not a dictionary");

  0010b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@BPIFALMC@state?5is?5not?5a?5dictionary?$AA@
$LN41@load_build:

; 5241 :             PyErr_SetString(UnpicklingError,
; 5242 :                             "slot state is not a dictionary");

  00112	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  00119	e8 00 00 00 00	 call	 PyErr_SetString
$error$24136:

; 5248 :                 goto error;
; 5249 :         }
; 5250 :     }
; 5251 : 
; 5252 :     if (0) {
; 5253 :   error:
; 5254 :         status = -1;

  0011e	83 cd ff	 or	 ebp, -1
$LN7@load_build:

; 5255 :     }
; 5256 : 
; 5257 :     Py_DECREF(state);

  00121	48 8b cf	 mov	 rcx, rdi
  00124	e8 00 00 00 00	 call	 _Py_DecRef

; 5258 :     Py_XDECREF(slotstate);

  00129	48 85 f6	 test	 rsi, rsi
  0012c	74 08		 je	 SHORT $LN3@load_build
  0012e	48 8b ce	 mov	 rcx, rsi
  00131	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@load_build:

; 5259 :     return status;

  00136	8b c5		 mov	 eax, ebp
  00138	e9 78 01 00 00	 jmp	 $LN40@load_build
$LN16@load_build:

; 5213 :             goto error;
; 5214 :         }
; 5215 :         dict = _PyObject_GetAttrId(inst, &PyId___dict__);

  0013d	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___dict__@?7??load_build@@9@9
  00142	49 8b cd	 mov	 rcx, r13
  00145	49 03 d4	 add	 rdx, r12
  00148	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  0014d	48 8b d8	 mov	 rbx, rax

; 5216 :         if (dict == NULL)

  00150	48 85 c0	 test	 rax, rax
  00153	74 c9		 je	 SHORT $error$24136

; 5217 :             goto error;
; 5218 : 
; 5219 :         i = 0;
; 5220 :         while (PyDict_Next(state, &i, &d_key, &d_value)) {

  00155	4c 8d 4c 24 78	 lea	 r9, QWORD PTR d_value$24128[rsp]
  0015a	4c 8d 44 24 70	 lea	 r8, QWORD PTR d_key$24127[rsp]
  0015f	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR i$24129[rsp]
  00167	48 8b cf	 mov	 rcx, rdi
  0016a	48 89 ac 24 80
	00 00 00	 mov	 QWORD PTR i$24129[rsp], rbp
  00172	e8 00 00 00 00	 call	 PyDict_Next
  00177	85 c0		 test	 eax, eax
  00179	74 64		 je	 SHORT $LN13@load_build
  0017b	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:PyUnicode_Type
$LL14@load_build:

; 5221 :             /* normally the keys for instance attributes are
; 5222 :                interned.  we should try to do that here. */
; 5223 :             Py_INCREF(d_key);

  00182	48 8b 4c 24 70	 mov	 rcx, QWORD PTR d_key$24127[rsp]
  00187	e8 00 00 00 00	 call	 _Py_IncRef

; 5224 :             if (PyUnicode_CheckExact(d_key))

  0018c	48 8b 54 24 70	 mov	 rdx, QWORD PTR d_key$24127[rsp]
  00191	4c 39 62 58	 cmp	 QWORD PTR [rdx+88], r12
  00195	75 0f		 jne	 SHORT $LN12@load_build

; 5225 :                 PyUnicode_InternInPlace(&d_key);

  00197	48 8d 4c 24 70	 lea	 rcx, QWORD PTR d_key$24127[rsp]
  0019c	e8 00 00 00 00	 call	 PyUnicode_InternInPlace
  001a1	48 8b 54 24 70	 mov	 rdx, QWORD PTR d_key$24127[rsp]
$LN12@load_build:

; 5226 :             if (PyObject_SetItem(dict, d_key, d_value) < 0) {

  001a6	4c 8b 44 24 78	 mov	 r8, QWORD PTR d_value$24128[rsp]
  001ab	48 8b cb	 mov	 rcx, rbx
  001ae	e8 00 00 00 00	 call	 PyObject_SetItem

; 5229 :             }
; 5230 :             Py_DECREF(d_key);

  001b3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR d_key$24127[rsp]
  001b8	85 c0		 test	 eax, eax
  001ba	78 50		 js	 SHORT $LN34@load_build
  001bc	e8 00 00 00 00	 call	 _Py_DecRef
  001c1	4c 8d 4c 24 78	 lea	 r9, QWORD PTR d_value$24128[rsp]
  001c6	4c 8d 44 24 70	 lea	 r8, QWORD PTR d_key$24127[rsp]
  001cb	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR i$24129[rsp]
  001d3	48 8b cf	 mov	 rcx, rdi
  001d6	e8 00 00 00 00	 call	 PyDict_Next
  001db	85 c0		 test	 eax, eax
  001dd	75 a3		 jne	 SHORT $LL14@load_build
$LN13@load_build:

; 5231 :         }
; 5232 :         Py_DECREF(dict);

  001df	48 8b cb	 mov	 rcx, rbx
  001e2	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@load_build:

; 5233 :     }
; 5234 : 
; 5235 :     /* Also set instance attributes from the slotstate dict (if any). */
; 5236 :     if (slotstate != NULL) {

  001e7	48 85 f6	 test	 rsi, rsi
  001ea	0f 84 31 ff ff
	ff		 je	 $LN7@load_build

; 5237 :         PyObject *d_key, *d_value;
; 5238 :         Py_ssize_t i;
; 5239 : 
; 5240 :         if (!PyDict_Check(slotstate)) {

  001f0	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  001f4	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  001fe	75 16		 jne	 SHORT $LN9@load_build

; 5241 :             PyErr_SetString(UnpicklingError,
; 5242 :                             "slot state is not a dictionary");

  00200	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@BKAEOMIB@slot?5state?5is?5not?5a?5dictionary?$AA@

; 5243 :             goto error;

  00207	e9 06 ff ff ff	 jmp	 $LN41@load_build
$LN34@load_build:

; 5227 :                 Py_DECREF(d_key);

  0020c	e8 00 00 00 00	 call	 _Py_DecRef

; 5228 :                 goto error;

  00211	e9 08 ff ff ff	 jmp	 $error$24136
$LN9@load_build:

; 5244 :         }
; 5245 :         i = 0;
; 5246 :         while (PyDict_Next(slotstate, &i, &d_key, &d_value)) {

  00216	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR d_value$24152[rsp]
  0021e	4c 8d 44 24 20	 lea	 r8, QWORD PTR d_key$24151[rsp]
  00223	48 8d 54 24 28	 lea	 rdx, QWORD PTR i$24153[rsp]
  00228	48 8b ce	 mov	 rcx, rsi
  0022b	48 89 6c 24 28	 mov	 QWORD PTR i$24153[rsp], rbp
  00230	e8 00 00 00 00	 call	 PyDict_Next
  00235	85 c0		 test	 eax, eax
  00237	0f 84 e4 fe ff
	ff		 je	 $LN7@load_build
  0023d	0f 1f 00	 npad	 3
$LL8@load_build:

; 5247 :             if (PyObject_SetAttr(inst, d_key, d_value) < 0)

  00240	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR d_value$24152[rsp]
  00248	48 8b 54 24 20	 mov	 rdx, QWORD PTR d_key$24151[rsp]
  0024d	49 8b cd	 mov	 rcx, r13
  00250	e8 00 00 00 00	 call	 PyObject_SetAttr
  00255	85 c0		 test	 eax, eax
  00257	0f 88 c1 fe ff
	ff		 js	 $error$24136

; 5244 :         }
; 5245 :         i = 0;
; 5246 :         while (PyDict_Next(slotstate, &i, &d_key, &d_value)) {

  0025d	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR d_value$24152[rsp]
  00265	4c 8d 44 24 20	 lea	 r8, QWORD PTR d_key$24151[rsp]
  0026a	48 8d 54 24 28	 lea	 rdx, QWORD PTR i$24153[rsp]
  0026f	48 8b ce	 mov	 rcx, rsi
  00272	e8 00 00 00 00	 call	 PyDict_Next
  00277	85 c0		 test	 eax, eax
  00279	75 c5		 jne	 SHORT $LL8@load_build

; 5247 :             if (PyObject_SetAttr(inst, d_key, d_value) < 0)

  0027b	e9 a1 fe ff ff	 jmp	 $LN7@load_build
$LN23@load_build:

; 5170 :         else {
; 5171 :             Py_DECREF(state);

  00280	48 8b cf	 mov	 rcx, rdi
  00283	e8 00 00 00 00	 call	 _Py_DecRef
$LN42@load_build:

; 5172 :             return -1;

  00288	83 c8 ff	 or	 eax, -1
  0028b	eb 28		 jmp	 SHORT $LN40@load_build
$LN24@load_build:

; 5173 :         }
; 5174 :     }
; 5175 :     else {
; 5176 :         PyObject *result;
; 5177 : 
; 5178 :         /* The explicit __setstate__ is responsible for everything. */
; 5179 :         /* Ugh... this does not leak since _Unpickler_FastCall() steals the
; 5180 :            reference to state first. */
; 5181 :         result = _Unpickler_FastCall(self, setstate, state);

  0028d	4c 8b c7	 mov	 r8, rdi
  00290	48 8b d0	 mov	 rdx, rax
  00293	48 8b cb	 mov	 rcx, rbx
  00296	e8 00 00 00 00	 call	 _Unpickler_FastCall

; 5182 :         Py_DECREF(setstate);

  0029b	48 8b ce	 mov	 rcx, rsi
  0029e	48 8b d8	 mov	 rbx, rax
  002a1	e8 00 00 00 00	 call	 _Py_DecRef

; 5183 :         if (result == NULL)

  002a6	48 85 db	 test	 rbx, rbx

; 5184 :             return -1;

  002a9	74 dd		 je	 SHORT $LN42@load_build

; 5185 :         Py_DECREF(result);

  002ab	48 8b cb	 mov	 rcx, rbx
  002ae	e8 00 00 00 00	 call	 _Py_DecRef

; 5186 :         return 0;

  002b3	33 c0		 xor	 eax, eax
$LN40@load_build:
  002b5	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]
  002ba	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  002bf	4c 8b 6c 24 38	 mov	 r13, QWORD PTR [rsp+56]
  002c4	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 5260 : }

  002c9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002cd	5d		 pop	 rbp
  002ce	5b		 pop	 rbx
  002cf	c3		 ret	 0
load_build ENDP
_TEXT	ENDS
EXTRN	PyMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_mark DD imagerel load_mark
	DD	imagerel load_mark+182
	DD	imagerel $unwind$load_mark
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_mark DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_mark
_TEXT	SEGMENT
self$ = 48
load_mark PROC						; COMDAT

; 5264 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5265 : 
; 5266 :     /* Note that we split the (pickle.py) stack into two stacks, an
; 5267 :      * object stack and a mark stack. Here we push a mark onto the
; 5268 :      * mark stack.
; 5269 :      */
; 5270 : 
; 5271 :     if ((self->num_marks + 1) >= self->marks_size) {

  0000a	48 8b b9 30 01
	00 00		 mov	 rdi, QWORD PTR [rcx+304]
  00011	48 8b d9	 mov	 rbx, rcx
  00014	48 8d 47 01	 lea	 rax, QWORD PTR [rdi+1]
  00018	48 3b 81 38 01
	00 00		 cmp	 rax, QWORD PTR [rcx+312]
  0001f	7c 54		 jl	 SHORT $LN6@load_mark

; 5272 :         size_t alloc;
; 5273 :         Py_ssize_t *marks;
; 5274 : 
; 5275 :         /* Use the size_t type to check for overflow. */
; 5276 :         alloc = ((size_t)self->num_marks << 1) + 20;

  00021	48 8d 7c 3f 14	 lea	 rdi, QWORD PTR [rdi+rdi+20]

; 5277 :         if (alloc > (PY_SSIZE_T_MAX / sizeof(Py_ssize_t)) ||
; 5278 :             alloc <= ((size_t)self->num_marks + 1)) {

  00026	48 b9 ff ff ff
	ff ff ff ff 0f	 mov	 rcx, 1152921504606846975 ; 0fffffffffffffffH
  00030	48 3b f9	 cmp	 rdi, rcx
  00033	77 6e		 ja	 SHORT $LN4@load_mark
  00035	48 3b f8	 cmp	 rdi, rax
  00038	76 69		 jbe	 SHORT $LN4@load_mark

; 5280 :             return -1;
; 5281 :         }
; 5282 : 
; 5283 :         if (self->marks == NULL)

  0003a	48 8b 8b 28 01
	00 00		 mov	 rcx, QWORD PTR [rbx+296]
  00041	48 85 c9	 test	 rcx, rcx
  00044	75 0f		 jne	 SHORT $LN3@load_mark

; 5284 :             marks = (Py_ssize_t *) PyMem_Malloc(alloc * sizeof(Py_ssize_t));

  00046	48 8d 0c fd 00
	00 00 00	 lea	 rcx, QWORD PTR [rdi*8]
  0004e	e8 00 00 00 00	 call	 PyMem_Malloc

; 5285 :         else

  00053	eb 0d		 jmp	 SHORT $LN2@load_mark
$LN3@load_mark:

; 5286 :             marks = (Py_ssize_t *) PyMem_Realloc(self->marks,
; 5287 :                                                  alloc * sizeof(Py_ssize_t));

  00055	48 8d 14 fd 00
	00 00 00	 lea	 rdx, QWORD PTR [rdi*8]
  0005d	e8 00 00 00 00	 call	 PyMem_Realloc
$LN2@load_mark:

; 5288 :         if (marks == NULL) {

  00062	48 85 c0	 test	 rax, rax

; 5289 :             PyErr_NoMemory();
; 5290 :             return -1;

  00065	74 3c		 je	 SHORT $LN4@load_mark

; 5291 :         }
; 5292 :         self->marks = marks;

  00067	48 89 83 28 01
	00 00		 mov	 QWORD PTR [rbx+296], rax

; 5293 :         self->marks_size = (Py_ssize_t)alloc;

  0006e	48 89 bb 38 01
	00 00		 mov	 QWORD PTR [rbx+312], rdi
$LN6@load_mark:

; 5294 :     }
; 5295 : 
; 5296 :     self->marks[self->num_marks++] = Py_SIZE(self->stack);

  00075	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  00079	48 8b 93 30 01
	00 00		 mov	 rdx, QWORD PTR [rbx+304]
  00080	48 8b 8b 28 01
	00 00		 mov	 rcx, QWORD PTR [rbx+296]
  00087	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0008b	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  0008f	48 ff 83 30 01
	00 00		 inc	 QWORD PTR [rbx+304]

; 5297 : 
; 5298 :     return 0;

  00096	33 c0		 xor	 eax, eax

; 5299 : }

  00098	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a1	5f		 pop	 rdi
  000a2	c3		 ret	 0
$LN4@load_mark:

; 5279 :             PyErr_NoMemory();

  000a3	e8 00 00 00 00	 call	 PyErr_NoMemory

; 5299 : }

  000a8	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ad	83 c8 ff	 or	 eax, -1
  000b0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b4	5f		 pop	 rdi
  000b5	c3		 ret	 0
load_mark ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_reduce DD imagerel load_reduce
	DD	imagerel load_reduce+55
	DD	imagerel $unwind$load_reduce
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$load_reduce DD imagerel load_reduce+55
	DD	imagerel load_reduce+113
	DD	imagerel $chain$0$load_reduce
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$load_reduce DD imagerel load_reduce+113
	DD	imagerel load_reduce+156
	DD	imagerel $chain$1$load_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$load_reduce DD 021H
	DD	imagerel load_reduce
	DD	imagerel load_reduce+55
	DD	imagerel $unwind$load_reduce
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$load_reduce DD 020521H
	DD	065405H
	DD	imagerel load_reduce
	DD	imagerel load_reduce+55
	DD	imagerel $unwind$load_reduce
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_reduce DD 081501H
	DD	097415H
	DD	086415H
	DD	073415H
	DD	0c0113215H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_reduce
_TEXT	SEGMENT
self$ = 48
load_reduce PROC					; COMDAT

; 5303 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00015	4c 8b e1	 mov	 r12, rcx

; 5304 :     PyObject *callable = NULL;
; 5305 :     PyObject *argtup = NULL;
; 5306 :     PyObject *obj = NULL;
; 5307 : 
; 5308 :     PDATA_POP(self->stack, argtup);

  00018	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0001c	33 db		 xor	 ebx, ebx
  0001e	8b fb		 mov	 edi, ebx
  00020	e8 00 00 00 00	 call	 Pdata_pop
  00025	48 8b f0	 mov	 rsi, rax

; 5309 :     if (argtup == NULL)

  00028	48 85 c0	 test	 rax, rax
  0002b	75 05		 jne	 SHORT $LN9@load_reduc
$LN16@load_reduc:

; 5310 :         return -1;

  0002d	83 c8 ff	 or	 eax, -1
  00030	eb 54		 jmp	 SHORT $LN3@load_reduc
$LN9@load_reduc:

; 5311 :     PDATA_POP(self->stack, callable);

  00032	49 8b 4c 24 60	 mov	 rcx, QWORD PTR [r12+96]
  00037	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0003c	e8 00 00 00 00	 call	 Pdata_pop
  00041	48 8b e8	 mov	 rbp, rax

; 5312 :     if (callable) {

  00044	48 85 c0	 test	 rax, rax
  00047	74 16		 je	 SHORT $LN6@load_reduc

; 5313 :         obj = PyObject_CallObject(callable, argtup);

  00049	48 8b d6	 mov	 rdx, rsi
  0004c	48 8b c8	 mov	 rcx, rax
  0004f	e8 00 00 00 00	 call	 PyObject_CallObject

; 5314 :         Py_DECREF(callable);

  00054	48 8b cd	 mov	 rcx, rbp
  00057	48 8b f8	 mov	 rdi, rax
  0005a	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@load_reduc:

; 5315 :     }
; 5316 :     Py_DECREF(argtup);

  0005f	48 8b ce	 mov	 rcx, rsi
  00062	e8 00 00 00 00	 call	 _Py_DecRef
  00067	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 5317 : 
; 5318 :     if (obj == NULL)

  0006c	48 85 ff	 test	 rdi, rdi

; 5319 :         return -1;

  0006f	74 bc		 je	 SHORT $LN16@load_reduc

; 5320 : 
; 5321 :     PDATA_PUSH(self->stack, obj, -1);

  00071	49 8b 4c 24 60	 mov	 rcx, QWORD PTR [r12+96]
  00076	48 8b d7	 mov	 rdx, rdi
  00079	e8 00 00 00 00	 call	 Pdata_push
  0007e	85 c0		 test	 eax, eax
  00080	0f 99 c3	 setns	 bl
  00083	8d 43 ff	 lea	 eax, DWORD PTR [rbx-1]
$LN3@load_reduc:

; 5322 :     return 0;
; 5323 : }

  00086	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0008b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00090	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	41 5c		 pop	 r12
  0009b	c3		 ret	 0
load_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@BKMFGIKD@unsupported?5pickle?5protocol?3?5?$CFd?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_proto DD imagerel load_proto
	DD	imagerel load_proto+88
	DD	imagerel $unwind$load_proto
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_proto DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CA@BKMFGIKD@unsupported?5pickle?5protocol?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0CA@BKMFGIKD@unsupported?5pickle?5protocol?3?5?$CFd?$AA@ DB 'unsupp'
	DB	'orted pickle protocol: %d', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT load_proto
_TEXT	SEGMENT
self$ = 48
s$ = 56
load_proto PROC						; COMDAT

; 5330 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5331 :     char *s;
; 5332 :     int i;
; 5333 : 
; 5334 :     if (_Unpickler_Read(self, &s, 1) < 0)

  00006	48 8d 54 24 38	 lea	 rdx, QWORD PTR s$[rsp]
  0000b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00011	48 8b d9	 mov	 rbx, rcx
  00014	e8 00 00 00 00	 call	 _Unpickler_Read
  00019	48 85 c0	 test	 rax, rax

; 5335 :         return -1;

  0001c	78 31		 js	 SHORT $LN5@load_proto

; 5336 : 
; 5337 :     i = (unsigned char)s[0];

  0001e	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00023	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]

; 5338 :     if (i <= HIGHEST_PROTOCOL) {

  00027	41 83 f8 03	 cmp	 r8d, 3
  0002b	7f 0f		 jg	 SHORT $LN1@load_proto

; 5339 :         self->proto = i;

  0002d	44 89 83 40 01
	00 00		 mov	 DWORD PTR [rbx+320], r8d

; 5340 :         return 0;

  00034	33 c0		 xor	 eax, eax

; 5345 : }

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
$LN1@load_proto:

; 5341 :     }
; 5342 : 
; 5343 :     PyErr_Format(PyExc_ValueError, "unsupported pickle protocol: %d", i);

  0003c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@BKMFGIKD@unsupported?5pickle?5protocol?3?5?$CFd?$AA@
  0004a	e8 00 00 00 00	 call	 PyErr_Format
$LN5@load_proto:

; 5344 :     return -1;

  0004f	83 c8 ff	 or	 eax, -1

; 5345 : }

  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5b		 pop	 rbx
  00057	c3		 ret	 0
load_proto ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@OJGEENPH@invalid?5load?5key?0?5?8?$CFc?8?4?$AA@ ; `string'
EXTRN	PyErr_SetNone:PROC
EXTRN	_Py_FalseStruct:BYTE
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$load DD	imagerel load
	DD	imagerel load+1490
	DD	imagerel $unwind$load
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load DD	043901H
	DD	077439H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BI@OJGEENPH@invalid?5load?5key?0?5?8?$CFc?8?4?$AA@
CONST	SEGMENT
??_C@_0BI@OJGEENPH@invalid?5load?5key?0?5?8?$CFc?8?4?$AA@ DB 'invalid loa'
	DB	'd key, ''%c''.', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT load
_TEXT	SEGMENT
s$ = 48
self$ = 48
load	PROC						; COMDAT

; 5349 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5350 :     PyObject *err;
; 5351 :     PyObject *value = NULL;
; 5352 :     char *s;
; 5353 : 
; 5354 :     self->num_marks = 0;

  00006	48 c7 81 30 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rcx+304], 0
  00011	48 8b d9	 mov	 rbx, rcx

; 5355 :     if (Py_SIZE(self->stack))

  00014	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00018	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  0001d	74 07		 je	 SHORT $LN180@load

; 5356 :         Pdata_clear(self->stack, 0);

  0001f	33 d2		 xor	 edx, edx
  00021	e8 00 00 00 00	 call	 Pdata_clear
$LN180@load:

; 5357 : 
; 5358 :     /* Convenient macros for the dispatch while-switch loop just below. */
; 5359 : #define OP(opcode, load_func) \
; 5360 :     case opcode: if (load_func(self) < 0) break; continue;
; 5361 : 
; 5362 : #define OP_ARG(opcode, load_func, arg) \
; 5363 :     case opcode: if (load_func(self, (arg)) < 0) break; continue;
; 5364 : 
; 5365 :     while (1) {
; 5366 :         if (_Unpickler_Read(self, &s, 1) < 0)

  00026	48 8d 54 24 30	 lea	 rdx, QWORD PTR s$[rsp]
  0002b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00031	48 8b cb	 mov	 rcx, rbx
  00034	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00039	e8 00 00 00 00	 call	 _Unpickler_Read
  0003e	48 85 c0	 test	 rax, rax
  00041	0f 88 20 03 00
	00		 js	 $LN181@load
  00047	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:__ImageBase
  0004e	66 90		 npad	 2
$LL123@load:

; 5367 :             break;
; 5368 : 
; 5369 :         switch ((enum opcode)s[0]) {

  00050	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$[rsp]
  00055	0f be 02	 movsx	 eax, BYTE PTR [rdx]
  00058	83 e8 80	 sub	 eax, -128		; ffffffffffffff80H
  0005b	3d fd 00 00 00	 cmp	 eax, 253		; 000000fdH
  00060	0f 87 35 03 00
	00		 ja	 $LN9@load
  00066	48 98		 cdqe
  00068	0f b6 84 07 00
	00 00 00	 movzx	 eax, BYTE PTR $LN236@load[rdi+rax]
  00070	8b 8c 87 00 00
	00 00		 mov	 ecx, DWORD PTR $LN237@load[rdi+rax*4]
  00077	48 03 cf	 add	 rcx, rdi
  0007a	ff e1		 jmp	 rcx
$LN118@load:

; 5370 :         OP(NONE, load_none)

  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	e8 00 00 00 00	 call	 load_none
  00084	e9 be 02 00 00	 jmp	 $LN239@load
$LN116@load:

; 5371 :         OP(BININT, load_binint)

  00089	48 8b cb	 mov	 rcx, rbx
  0008c	e8 00 00 00 00	 call	 load_binint
  00091	e9 b1 02 00 00	 jmp	 $LN239@load
$LN114@load:

; 5372 :         OP(BININT1, load_binint1)

  00096	48 8b cb	 mov	 rcx, rbx
  00099	e8 00 00 00 00	 call	 load_binint1
  0009e	e9 a4 02 00 00	 jmp	 $LN239@load
$LN112@load:

; 5373 :         OP(BININT2, load_binint2)

  000a3	48 8b cb	 mov	 rcx, rbx
  000a6	e8 00 00 00 00	 call	 load_binint2
  000ab	e9 97 02 00 00	 jmp	 $LN239@load
$LN110@load:

; 5374 :         OP(INT, load_int)

  000b0	48 8b cb	 mov	 rcx, rbx
  000b3	e8 00 00 00 00	 call	 load_int
  000b8	e9 8a 02 00 00	 jmp	 $LN239@load
$LN108@load:

; 5375 :         OP(LONG, load_long)

  000bd	48 8b cb	 mov	 rcx, rbx
  000c0	e8 00 00 00 00	 call	 load_long
  000c5	e9 7d 02 00 00	 jmp	 $LN239@load
$LN106@load:

; 5376 :         OP_ARG(LONG1, load_counted_long, 1)

  000ca	ba 01 00 00 00	 mov	 edx, 1
  000cf	48 8b cb	 mov	 rcx, rbx
  000d2	e8 00 00 00 00	 call	 load_counted_long
  000d7	e9 6b 02 00 00	 jmp	 $LN239@load
$LN104@load:

; 5377 :         OP_ARG(LONG4, load_counted_long, 4)

  000dc	ba 04 00 00 00	 mov	 edx, 4
  000e1	48 8b cb	 mov	 rcx, rbx
  000e4	e8 00 00 00 00	 call	 load_counted_long
  000e9	e9 59 02 00 00	 jmp	 $LN239@load
$LN102@load:

; 5378 :         OP(FLOAT, load_float)

  000ee	48 8b cb	 mov	 rcx, rbx
  000f1	e8 00 00 00 00	 call	 load_float
  000f6	e9 4c 02 00 00	 jmp	 $LN239@load
$LN100@load:

; 5379 :         OP(BINFLOAT, load_binfloat)

  000fb	48 8b cb	 mov	 rcx, rbx
  000fe	e8 00 00 00 00	 call	 load_binfloat
  00103	e9 3f 02 00 00	 jmp	 $LN239@load
$LN98@load:

; 5380 :         OP(BINBYTES, load_binbytes)

  00108	48 8b cb	 mov	 rcx, rbx
  0010b	e8 00 00 00 00	 call	 load_binbytes
  00110	e9 32 02 00 00	 jmp	 $LN239@load
$LN96@load:

; 5381 :         OP(SHORT_BINBYTES, load_short_binbytes)

  00115	48 8b cb	 mov	 rcx, rbx
  00118	e8 00 00 00 00	 call	 load_short_binbytes
  0011d	e9 25 02 00 00	 jmp	 $LN239@load
$LN94@load:

; 5382 :         OP(BINSTRING, load_binstring)

  00122	48 8b cb	 mov	 rcx, rbx
  00125	e8 00 00 00 00	 call	 load_binstring
  0012a	e9 18 02 00 00	 jmp	 $LN239@load
$LN92@load:

; 5383 :         OP(SHORT_BINSTRING, load_short_binstring)

  0012f	48 8b cb	 mov	 rcx, rbx
  00132	e8 00 00 00 00	 call	 load_short_binstring
  00137	e9 0b 02 00 00	 jmp	 $LN239@load
$LN90@load:

; 5384 :         OP(STRING, load_string)

  0013c	48 8b cb	 mov	 rcx, rbx
  0013f	e8 00 00 00 00	 call	 load_string
  00144	e9 fe 01 00 00	 jmp	 $LN239@load
$LN88@load:

; 5385 :         OP(UNICODE, load_unicode)

  00149	48 8b cb	 mov	 rcx, rbx
  0014c	e8 00 00 00 00	 call	 load_unicode
  00151	e9 f1 01 00 00	 jmp	 $LN239@load
$LN86@load:

; 5386 :         OP(BINUNICODE, load_binunicode)

  00156	48 8b cb	 mov	 rcx, rbx
  00159	e8 00 00 00 00	 call	 load_binunicode
  0015e	e9 e4 01 00 00	 jmp	 $LN239@load
$LN84@load:

; 5387 :         OP_ARG(EMPTY_TUPLE, load_counted_tuple, 0)

  00163	33 d2		 xor	 edx, edx
  00165	48 8b cb	 mov	 rcx, rbx
  00168	e8 00 00 00 00	 call	 load_counted_tuple
  0016d	e9 d5 01 00 00	 jmp	 $LN239@load
$LN82@load:

; 5388 :         OP_ARG(TUPLE1, load_counted_tuple, 1)

  00172	ba 01 00 00 00	 mov	 edx, 1
  00177	48 8b cb	 mov	 rcx, rbx
  0017a	e8 00 00 00 00	 call	 load_counted_tuple
  0017f	e9 c3 01 00 00	 jmp	 $LN239@load
$LN80@load:

; 5389 :         OP_ARG(TUPLE2, load_counted_tuple, 2)

  00184	ba 02 00 00 00	 mov	 edx, 2
  00189	48 8b cb	 mov	 rcx, rbx
  0018c	e8 00 00 00 00	 call	 load_counted_tuple
  00191	e9 b1 01 00 00	 jmp	 $LN239@load
$LN78@load:

; 5390 :         OP_ARG(TUPLE3, load_counted_tuple, 3)

  00196	ba 03 00 00 00	 mov	 edx, 3
  0019b	48 8b cb	 mov	 rcx, rbx
  0019e	e8 00 00 00 00	 call	 load_counted_tuple
  001a3	e9 9f 01 00 00	 jmp	 $LN239@load
$LN76@load:

; 5391 :         OP(TUPLE, load_tuple)

  001a8	48 8b cb	 mov	 rcx, rbx
  001ab	e8 00 00 00 00	 call	 load_tuple
  001b0	e9 92 01 00 00	 jmp	 $LN239@load
$LN74@load:

; 5392 :         OP(EMPTY_LIST, load_empty_list)

  001b5	48 8b cb	 mov	 rcx, rbx
  001b8	e8 00 00 00 00	 call	 load_empty_list
  001bd	e9 85 01 00 00	 jmp	 $LN239@load
$LN72@load:

; 5393 :         OP(LIST, load_list)

  001c2	48 8b cb	 mov	 rcx, rbx
  001c5	e8 00 00 00 00	 call	 load_list
  001ca	e9 78 01 00 00	 jmp	 $LN239@load
$LN70@load:

; 5394 :         OP(EMPTY_DICT, load_empty_dict)

  001cf	48 8b cb	 mov	 rcx, rbx
  001d2	e8 00 00 00 00	 call	 load_empty_dict
  001d7	e9 6b 01 00 00	 jmp	 $LN239@load
$LN68@load:

; 5395 :         OP(DICT, load_dict)

  001dc	48 8b cb	 mov	 rcx, rbx
  001df	e8 00 00 00 00	 call	 load_dict
  001e4	e9 5e 01 00 00	 jmp	 $LN239@load
$LN66@load:

; 5396 :         OP(OBJ, load_obj)

  001e9	48 8b cb	 mov	 rcx, rbx
  001ec	e8 00 00 00 00	 call	 load_obj
  001f1	e9 51 01 00 00	 jmp	 $LN239@load
$LN64@load:

; 5397 :         OP(INST, load_inst)

  001f6	48 8b cb	 mov	 rcx, rbx
  001f9	e8 00 00 00 00	 call	 load_inst
  001fe	e9 44 01 00 00	 jmp	 $LN239@load
$LN62@load:

; 5398 :         OP(NEWOBJ, load_newobj)

  00203	48 8b cb	 mov	 rcx, rbx
  00206	e8 00 00 00 00	 call	 load_newobj
  0020b	e9 37 01 00 00	 jmp	 $LN239@load
$LN60@load:

; 5399 :         OP(GLOBAL, load_global)

  00210	48 8b cb	 mov	 rcx, rbx
  00213	e8 00 00 00 00	 call	 load_global
  00218	e9 2a 01 00 00	 jmp	 $LN239@load
$LN58@load:

; 5400 :         OP(APPEND, load_append)

  0021d	48 8b cb	 mov	 rcx, rbx
  00220	e8 00 00 00 00	 call	 load_append
  00225	e9 1d 01 00 00	 jmp	 $LN239@load
$LN56@load:

; 5401 :         OP(APPENDS, load_appends)

  0022a	48 8b cb	 mov	 rcx, rbx
  0022d	e8 00 00 00 00	 call	 load_appends
  00232	e9 10 01 00 00	 jmp	 $LN239@load
$LN54@load:

; 5402 :         OP(BUILD, load_build)

  00237	48 8b cb	 mov	 rcx, rbx
  0023a	e8 00 00 00 00	 call	 load_build
  0023f	e9 03 01 00 00	 jmp	 $LN239@load
$LN52@load:

; 5403 :         OP(DUP, load_dup)

  00244	48 8b cb	 mov	 rcx, rbx
  00247	e8 00 00 00 00	 call	 load_dup
  0024c	e9 f6 00 00 00	 jmp	 $LN239@load
$LN50@load:

; 5404 :         OP(BINGET, load_binget)

  00251	48 8b cb	 mov	 rcx, rbx
  00254	e8 00 00 00 00	 call	 load_binget
  00259	e9 e9 00 00 00	 jmp	 $LN239@load
$LN48@load:

; 5405 :         OP(LONG_BINGET, load_long_binget)

  0025e	48 8b cb	 mov	 rcx, rbx
  00261	e8 00 00 00 00	 call	 load_long_binget
  00266	e9 dc 00 00 00	 jmp	 $LN239@load
$LN46@load:

; 5406 :         OP(GET, load_get)

  0026b	48 8b cb	 mov	 rcx, rbx
  0026e	e8 00 00 00 00	 call	 load_get
  00273	e9 cf 00 00 00	 jmp	 $LN239@load
$LN44@load:

; 5407 :         OP(MARK, load_mark)

  00278	48 8b cb	 mov	 rcx, rbx
  0027b	e8 00 00 00 00	 call	 load_mark
  00280	e9 c2 00 00 00	 jmp	 $LN239@load
$LN42@load:

; 5408 :         OP(BINPUT, load_binput)

  00285	48 8b cb	 mov	 rcx, rbx
  00288	e8 00 00 00 00	 call	 load_binput
  0028d	e9 b5 00 00 00	 jmp	 $LN239@load
$LN40@load:

; 5409 :         OP(LONG_BINPUT, load_long_binput)

  00292	48 8b cb	 mov	 rcx, rbx
  00295	e8 00 00 00 00	 call	 load_long_binput
  0029a	e9 a8 00 00 00	 jmp	 $LN239@load
$LN38@load:

; 5410 :         OP(PUT, load_put)

  0029f	48 8b cb	 mov	 rcx, rbx
  002a2	e8 00 00 00 00	 call	 load_put
  002a7	e9 9b 00 00 00	 jmp	 $LN239@load
$LN36@load:

; 5411 :         OP(POP, load_pop)

  002ac	48 8b cb	 mov	 rcx, rbx
  002af	e8 00 00 00 00	 call	 load_pop
  002b4	e9 8e 00 00 00	 jmp	 $LN239@load
$LN34@load:

; 5412 :         OP(POP_MARK, load_pop_mark)

  002b9	48 8b cb	 mov	 rcx, rbx
  002bc	e8 00 00 00 00	 call	 load_pop_mark
  002c1	e9 81 00 00 00	 jmp	 $LN239@load
$LN32@load:

; 5413 :         OP(SETITEM, load_setitem)

  002c6	48 8b cb	 mov	 rcx, rbx
  002c9	e8 00 00 00 00	 call	 load_setitem
  002ce	eb 77		 jmp	 SHORT $LN239@load
$LN30@load:

; 5414 :         OP(SETITEMS, load_setitems)

  002d0	48 8b cb	 mov	 rcx, rbx
  002d3	e8 00 00 00 00	 call	 load_setitems
  002d8	eb 6d		 jmp	 SHORT $LN239@load
$LN28@load:

; 5415 :         OP(PERSID, load_persid)

  002da	48 8b cb	 mov	 rcx, rbx
  002dd	e8 00 00 00 00	 call	 load_persid
  002e2	eb 63		 jmp	 SHORT $LN239@load
$LN26@load:

; 5416 :         OP(BINPERSID, load_binpersid)

  002e4	48 8b cb	 mov	 rcx, rbx
  002e7	e8 00 00 00 00	 call	 load_binpersid
  002ec	eb 59		 jmp	 SHORT $LN239@load
$LN24@load:

; 5417 :         OP(REDUCE, load_reduce)

  002ee	48 8b cb	 mov	 rcx, rbx
  002f1	e8 00 00 00 00	 call	 load_reduce
  002f6	eb 4f		 jmp	 SHORT $LN239@load
$LN22@load:

; 5418 :         OP(PROTO, load_proto)

  002f8	48 8b cb	 mov	 rcx, rbx
  002fb	e8 00 00 00 00	 call	 load_proto
  00300	eb 45		 jmp	 SHORT $LN239@load
$LN20@load:

; 5419 :         OP_ARG(EXT1, load_extension, 1)

  00302	ba 01 00 00 00	 mov	 edx, 1
  00307	48 8b cb	 mov	 rcx, rbx
  0030a	e8 00 00 00 00	 call	 load_extension
  0030f	eb 36		 jmp	 SHORT $LN239@load
$LN18@load:

; 5420 :         OP_ARG(EXT2, load_extension, 2)

  00311	ba 02 00 00 00	 mov	 edx, 2
  00316	48 8b cb	 mov	 rcx, rbx
  00319	e8 00 00 00 00	 call	 load_extension
  0031e	eb 27		 jmp	 SHORT $LN239@load
$LN16@load:

; 5421 :         OP_ARG(EXT4, load_extension, 4)

  00320	ba 04 00 00 00	 mov	 edx, 4
  00325	48 8b cb	 mov	 rcx, rbx
  00328	e8 00 00 00 00	 call	 load_extension
  0032d	eb 18		 jmp	 SHORT $LN239@load
$LN14@load:

; 5422 :         OP_ARG(NEWTRUE, load_bool, Py_True)

  0032f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_TrueStruct
  00336	eb 07		 jmp	 SHORT $LN240@load
$LN12@load:

; 5423 :         OP_ARG(NEWFALSE, load_bool, Py_False)

  00338	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_FalseStruct
$LN240@load:
  0033f	48 8b cb	 mov	 rcx, rbx
  00342	e8 00 00 00 00	 call	 load_bool
$LN239@load:
  00347	85 c0		 test	 eax, eax
  00349	78 1c		 js	 SHORT $LN181@load

; 5357 : 
; 5358 :     /* Convenient macros for the dispatch while-switch loop just below. */
; 5359 : #define OP(opcode, load_func) \
; 5360 :     case opcode: if (load_func(self) < 0) break; continue;
; 5361 : 
; 5362 : #define OP_ARG(opcode, load_func, arg) \
; 5363 :     case opcode: if (load_func(self, (arg)) < 0) break; continue;
; 5364 : 
; 5365 :     while (1) {
; 5366 :         if (_Unpickler_Read(self, &s, 1) < 0)

  0034b	48 8d 54 24 30	 lea	 rdx, QWORD PTR s$[rsp]
  00350	41 b8 01 00 00
	00		 mov	 r8d, 1
  00356	48 8b cb	 mov	 rcx, rbx
  00359	e8 00 00 00 00	 call	 _Unpickler_Read
  0035e	48 85 c0	 test	 rax, rax
  00361	0f 89 e9 fc ff
	ff		 jns	 $LL123@load
$LN181@load:

; 5435 :         }
; 5436 : 
; 5437 :         break;                  /* and we are done! */
; 5438 :     }
; 5439 : 
; 5440 :     if (_Unpickler_SkipConsumed(self) < 0)

  00367	48 8b cb	 mov	 rcx, rbx
  0036a	e8 00 00 00 00	 call	 _Unpickler_SkipConsumed
  0036f	85 c0		 test	 eax, eax

; 5441 :         return NULL;

  00371	78 1b		 js	 SHORT $LN4@load

; 5442 : 
; 5443 :     /* XXX: It is not clear what this is actually for. */
; 5444 :     if ((err = PyErr_Occurred())) {

  00373	e8 00 00 00 00	 call	 PyErr_Occurred
  00378	48 85 c0	 test	 rax, rax
  0037b	74 62		 je	 SHORT $LN3@load

; 5445 :         if (err == PyExc_EOFError) {

  0037d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_EOFError
  00384	48 3b c1	 cmp	 rax, rcx
  00387	75 05		 jne	 SHORT $LN4@load

; 5446 :             PyErr_SetNone(PyExc_EOFError);

  00389	e8 00 00 00 00	 call	 PyErr_SetNone
$LN4@load:

; 5447 :         }
; 5448 :         return NULL;

  0038e	33 c0		 xor	 eax, eax
  00390	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 5452 :     return value;
; 5453 : }

  00395	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00399	5b		 pop	 rbx
  0039a	c3		 ret	 0
$LN9@load:

; 5424 : 
; 5425 :         case STOP:
; 5426 :             break;
; 5427 : 
; 5428 :         default:
; 5429 :             if (s[0] == '\0')

  0039b	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  0039e	84 c0		 test	 al, al
  003a0	75 19		 jne	 SHORT $LN8@load

; 5430 :                 PyErr_SetNone(PyExc_EOFError);

  003a2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_EOFError
  003a9	e8 00 00 00 00	 call	 PyErr_SetNone

; 5434 :             return NULL;

  003ae	33 c0		 xor	 eax, eax
  003b0	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 5452 :     return value;
; 5453 : }

  003b5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  003b9	5b		 pop	 rbx
  003ba	c3		 ret	 0
$LN8@load:

; 5431 :             else
; 5432 :                 PyErr_Format(UnpicklingError,
; 5433 :                              "invalid load key, '%c'.", s[0]);

  003bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  003c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@OJGEENPH@invalid?5load?5key?0?5?8?$CFc?8?4?$AA@
  003c9	44 0f be c0	 movsx	 r8d, al
  003cd	e8 00 00 00 00	 call	 PyErr_Format

; 5434 :             return NULL;

  003d2	33 c0		 xor	 eax, eax
  003d4	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 5452 :     return value;
; 5453 : }

  003d9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  003dd	5b		 pop	 rbx
  003de	c3		 ret	 0
$LN3@load:

; 5449 :     }
; 5450 : 
; 5451 :     PDATA_POP(self->stack, value);

  003df	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  003e3	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 5452 :     return value;
; 5453 : }

  003e8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  003ec	5b		 pop	 rbx
  003ed	e9 00 00 00 00	 jmp	 Pdata_pop
  003f2	66 90		 npad	 2
$LN237@load:
  003f4	00 00 00 00	 DD	 $LN22@load
  003f8	00 00 00 00	 DD	 $LN62@load
  003fc	00 00 00 00	 DD	 $LN20@load
  00400	00 00 00 00	 DD	 $LN18@load
  00404	00 00 00 00	 DD	 $LN16@load
  00408	00 00 00 00	 DD	 $LN82@load
  0040c	00 00 00 00	 DD	 $LN80@load
  00410	00 00 00 00	 DD	 $LN78@load
  00414	00 00 00 00	 DD	 $LN14@load
  00418	00 00 00 00	 DD	 $LN12@load
  0041c	00 00 00 00	 DD	 $LN106@load
  00420	00 00 00 00	 DD	 $LN104@load
  00424	00 00 00 00	 DD	 $LN44@load
  00428	00 00 00 00	 DD	 $LN84@load
  0042c	00 00 00 00	 DD	 $LN181@load
  00430	00 00 00 00	 DD	 $LN36@load
  00434	00 00 00 00	 DD	 $LN34@load
  00438	00 00 00 00	 DD	 $LN52@load
  0043c	00 00 00 00	 DD	 $LN98@load
  00440	00 00 00 00	 DD	 $LN96@load
  00444	00 00 00 00	 DD	 $LN102@load
  00448	00 00 00 00	 DD	 $LN100@load
  0044c	00 00 00 00	 DD	 $LN110@load
  00450	00 00 00 00	 DD	 $LN116@load
  00454	00 00 00 00	 DD	 $LN114@load
  00458	00 00 00 00	 DD	 $LN108@load
  0045c	00 00 00 00	 DD	 $LN112@load
  00460	00 00 00 00	 DD	 $LN118@load
  00464	00 00 00 00	 DD	 $LN28@load
  00468	00 00 00 00	 DD	 $LN26@load
  0046c	00 00 00 00	 DD	 $LN24@load
  00470	00 00 00 00	 DD	 $LN90@load
  00474	00 00 00 00	 DD	 $LN94@load
  00478	00 00 00 00	 DD	 $LN92@load
  0047c	00 00 00 00	 DD	 $LN88@load
  00480	00 00 00 00	 DD	 $LN86@load
  00484	00 00 00 00	 DD	 $LN74@load
  00488	00 00 00 00	 DD	 $LN58@load
  0048c	00 00 00 00	 DD	 $LN54@load
  00490	00 00 00 00	 DD	 $LN60@load
  00494	00 00 00 00	 DD	 $LN68@load
  00498	00 00 00 00	 DD	 $LN56@load
  0049c	00 00 00 00	 DD	 $LN46@load
  004a0	00 00 00 00	 DD	 $LN50@load
  004a4	00 00 00 00	 DD	 $LN64@load
  004a8	00 00 00 00	 DD	 $LN48@load
  004ac	00 00 00 00	 DD	 $LN72@load
  004b0	00 00 00 00	 DD	 $LN66@load
  004b4	00 00 00 00	 DD	 $LN38@load
  004b8	00 00 00 00	 DD	 $LN42@load
  004bc	00 00 00 00	 DD	 $LN40@load
  004c0	00 00 00 00	 DD	 $LN32@load
  004c4	00 00 00 00	 DD	 $LN76@load
  004c8	00 00 00 00	 DD	 $LN30@load
  004cc	00 00 00 00	 DD	 $LN70@load
  004d0	00 00 00 00	 DD	 $LN9@load
$LN236@load:
  004d4	00		 DB	 0
  004d5	01		 DB	 1
  004d6	02		 DB	 2
  004d7	03		 DB	 3
  004d8	04		 DB	 4
  004d9	05		 DB	 5
  004da	06		 DB	 6
  004db	07		 DB	 7
  004dc	08		 DB	 8
  004dd	09		 DB	 9
  004de	0a		 DB	 10
  004df	0b		 DB	 11
  004e0	37		 DB	 55			; 00000037H
  004e1	37		 DB	 55			; 00000037H
  004e2	37		 DB	 55			; 00000037H
  004e3	37		 DB	 55			; 00000037H
  004e4	37		 DB	 55			; 00000037H
  004e5	37		 DB	 55			; 00000037H
  004e6	37		 DB	 55			; 00000037H
  004e7	37		 DB	 55			; 00000037H
  004e8	37		 DB	 55			; 00000037H
  004e9	37		 DB	 55			; 00000037H
  004ea	37		 DB	 55			; 00000037H
  004eb	37		 DB	 55			; 00000037H
  004ec	37		 DB	 55			; 00000037H
  004ed	37		 DB	 55			; 00000037H
  004ee	37		 DB	 55			; 00000037H
  004ef	37		 DB	 55			; 00000037H
  004f0	37		 DB	 55			; 00000037H
  004f1	37		 DB	 55			; 00000037H
  004f2	37		 DB	 55			; 00000037H
  004f3	37		 DB	 55			; 00000037H
  004f4	37		 DB	 55			; 00000037H
  004f5	37		 DB	 55			; 00000037H
  004f6	37		 DB	 55			; 00000037H
  004f7	37		 DB	 55			; 00000037H
  004f8	37		 DB	 55			; 00000037H
  004f9	37		 DB	 55			; 00000037H
  004fa	37		 DB	 55			; 00000037H
  004fb	37		 DB	 55			; 00000037H
  004fc	37		 DB	 55			; 00000037H
  004fd	37		 DB	 55			; 00000037H
  004fe	37		 DB	 55			; 00000037H
  004ff	37		 DB	 55			; 00000037H
  00500	37		 DB	 55			; 00000037H
  00501	37		 DB	 55			; 00000037H
  00502	37		 DB	 55			; 00000037H
  00503	37		 DB	 55			; 00000037H
  00504	37		 DB	 55			; 00000037H
  00505	37		 DB	 55			; 00000037H
  00506	37		 DB	 55			; 00000037H
  00507	37		 DB	 55			; 00000037H
  00508	37		 DB	 55			; 00000037H
  00509	37		 DB	 55			; 00000037H
  0050a	37		 DB	 55			; 00000037H
  0050b	37		 DB	 55			; 00000037H
  0050c	37		 DB	 55			; 00000037H
  0050d	37		 DB	 55			; 00000037H
  0050e	37		 DB	 55			; 00000037H
  0050f	37		 DB	 55			; 00000037H
  00510	37		 DB	 55			; 00000037H
  00511	37		 DB	 55			; 00000037H
  00512	37		 DB	 55			; 00000037H
  00513	37		 DB	 55			; 00000037H
  00514	37		 DB	 55			; 00000037H
  00515	37		 DB	 55			; 00000037H
  00516	37		 DB	 55			; 00000037H
  00517	37		 DB	 55			; 00000037H
  00518	37		 DB	 55			; 00000037H
  00519	37		 DB	 55			; 00000037H
  0051a	37		 DB	 55			; 00000037H
  0051b	37		 DB	 55			; 00000037H
  0051c	37		 DB	 55			; 00000037H
  0051d	37		 DB	 55			; 00000037H
  0051e	37		 DB	 55			; 00000037H
  0051f	37		 DB	 55			; 00000037H
  00520	37		 DB	 55			; 00000037H
  00521	37		 DB	 55			; 00000037H
  00522	37		 DB	 55			; 00000037H
  00523	37		 DB	 55			; 00000037H
  00524	37		 DB	 55			; 00000037H
  00525	37		 DB	 55			; 00000037H
  00526	37		 DB	 55			; 00000037H
  00527	37		 DB	 55			; 00000037H
  00528	37		 DB	 55			; 00000037H
  00529	37		 DB	 55			; 00000037H
  0052a	37		 DB	 55			; 00000037H
  0052b	37		 DB	 55			; 00000037H
  0052c	37		 DB	 55			; 00000037H
  0052d	37		 DB	 55			; 00000037H
  0052e	37		 DB	 55			; 00000037H
  0052f	37		 DB	 55			; 00000037H
  00530	37		 DB	 55			; 00000037H
  00531	37		 DB	 55			; 00000037H
  00532	37		 DB	 55			; 00000037H
  00533	37		 DB	 55			; 00000037H
  00534	37		 DB	 55			; 00000037H
  00535	37		 DB	 55			; 00000037H
  00536	37		 DB	 55			; 00000037H
  00537	37		 DB	 55			; 00000037H
  00538	37		 DB	 55			; 00000037H
  00539	37		 DB	 55			; 00000037H
  0053a	37		 DB	 55			; 00000037H
  0053b	37		 DB	 55			; 00000037H
  0053c	37		 DB	 55			; 00000037H
  0053d	37		 DB	 55			; 00000037H
  0053e	37		 DB	 55			; 00000037H
  0053f	37		 DB	 55			; 00000037H
  00540	37		 DB	 55			; 00000037H
  00541	37		 DB	 55			; 00000037H
  00542	37		 DB	 55			; 00000037H
  00543	37		 DB	 55			; 00000037H
  00544	37		 DB	 55			; 00000037H
  00545	37		 DB	 55			; 00000037H
  00546	37		 DB	 55			; 00000037H
  00547	37		 DB	 55			; 00000037H
  00548	37		 DB	 55			; 00000037H
  00549	37		 DB	 55			; 00000037H
  0054a	37		 DB	 55			; 00000037H
  0054b	37		 DB	 55			; 00000037H
  0054c	37		 DB	 55			; 00000037H
  0054d	37		 DB	 55			; 00000037H
  0054e	37		 DB	 55			; 00000037H
  0054f	37		 DB	 55			; 00000037H
  00550	37		 DB	 55			; 00000037H
  00551	37		 DB	 55			; 00000037H
  00552	37		 DB	 55			; 00000037H
  00553	37		 DB	 55			; 00000037H
  00554	37		 DB	 55			; 00000037H
  00555	37		 DB	 55			; 00000037H
  00556	37		 DB	 55			; 00000037H
  00557	37		 DB	 55			; 00000037H
  00558	37		 DB	 55			; 00000037H
  00559	37		 DB	 55			; 00000037H
  0055a	37		 DB	 55			; 00000037H
  0055b	37		 DB	 55			; 00000037H
  0055c	37		 DB	 55			; 00000037H
  0055d	37		 DB	 55			; 00000037H
  0055e	37		 DB	 55			; 00000037H
  0055f	37		 DB	 55			; 00000037H
  00560	37		 DB	 55			; 00000037H
  00561	37		 DB	 55			; 00000037H
  00562	37		 DB	 55			; 00000037H
  00563	37		 DB	 55			; 00000037H
  00564	37		 DB	 55			; 00000037H
  00565	37		 DB	 55			; 00000037H
  00566	37		 DB	 55			; 00000037H
  00567	37		 DB	 55			; 00000037H
  00568	37		 DB	 55			; 00000037H
  00569	37		 DB	 55			; 00000037H
  0056a	37		 DB	 55			; 00000037H
  0056b	37		 DB	 55			; 00000037H
  0056c	37		 DB	 55			; 00000037H
  0056d	37		 DB	 55			; 00000037H
  0056e	37		 DB	 55			; 00000037H
  0056f	37		 DB	 55			; 00000037H
  00570	37		 DB	 55			; 00000037H
  00571	37		 DB	 55			; 00000037H
  00572	37		 DB	 55			; 00000037H
  00573	37		 DB	 55			; 00000037H
  00574	37		 DB	 55			; 00000037H
  00575	37		 DB	 55			; 00000037H
  00576	37		 DB	 55			; 00000037H
  00577	37		 DB	 55			; 00000037H
  00578	37		 DB	 55			; 00000037H
  00579	37		 DB	 55			; 00000037H
  0057a	37		 DB	 55			; 00000037H
  0057b	37		 DB	 55			; 00000037H
  0057c	0c		 DB	 12
  0057d	0d		 DB	 13
  0057e	37		 DB	 55			; 00000037H
  0057f	37		 DB	 55			; 00000037H
  00580	37		 DB	 55			; 00000037H
  00581	37		 DB	 55			; 00000037H
  00582	0e		 DB	 14
  00583	37		 DB	 55			; 00000037H
  00584	0f		 DB	 15
  00585	10		 DB	 16
  00586	11		 DB	 17
  00587	37		 DB	 55			; 00000037H
  00588	37		 DB	 55			; 00000037H
  00589	37		 DB	 55			; 00000037H
  0058a	37		 DB	 55			; 00000037H
  0058b	37		 DB	 55			; 00000037H
  0058c	37		 DB	 55			; 00000037H
  0058d	37		 DB	 55			; 00000037H
  0058e	37		 DB	 55			; 00000037H
  0058f	37		 DB	 55			; 00000037H
  00590	37		 DB	 55			; 00000037H
  00591	37		 DB	 55			; 00000037H
  00592	37		 DB	 55			; 00000037H
  00593	37		 DB	 55			; 00000037H
  00594	37		 DB	 55			; 00000037H
  00595	37		 DB	 55			; 00000037H
  00596	12		 DB	 18
  00597	13		 DB	 19
  00598	37		 DB	 55			; 00000037H
  00599	37		 DB	 55			; 00000037H
  0059a	14		 DB	 20
  0059b	15		 DB	 21
  0059c	37		 DB	 55			; 00000037H
  0059d	16		 DB	 22
  0059e	17		 DB	 23
  0059f	18		 DB	 24
  005a0	19		 DB	 25
  005a1	1a		 DB	 26
  005a2	1b		 DB	 27
  005a3	37		 DB	 55			; 00000037H
  005a4	1c		 DB	 28
  005a5	1d		 DB	 29
  005a6	1e		 DB	 30
  005a7	1f		 DB	 31
  005a8	20		 DB	 32			; 00000020H
  005a9	21		 DB	 33			; 00000021H
  005aa	22		 DB	 34			; 00000022H
  005ab	37		 DB	 55			; 00000037H
  005ac	23		 DB	 35			; 00000023H
  005ad	37		 DB	 55			; 00000037H
  005ae	37		 DB	 55			; 00000037H
  005af	37		 DB	 55			; 00000037H
  005b0	37		 DB	 55			; 00000037H
  005b1	24		 DB	 36			; 00000024H
  005b2	37		 DB	 55			; 00000037H
  005b3	37		 DB	 55			; 00000037H
  005b4	37		 DB	 55			; 00000037H
  005b5	25		 DB	 37			; 00000025H
  005b6	26		 DB	 38			; 00000026H
  005b7	27		 DB	 39			; 00000027H
  005b8	28		 DB	 40			; 00000028H
  005b9	29		 DB	 41			; 00000029H
  005ba	37		 DB	 55			; 00000037H
  005bb	2a		 DB	 42			; 0000002aH
  005bc	2b		 DB	 43			; 0000002bH
  005bd	2c		 DB	 44			; 0000002cH
  005be	2d		 DB	 45			; 0000002dH
  005bf	37		 DB	 55			; 00000037H
  005c0	2e		 DB	 46			; 0000002eH
  005c1	37		 DB	 55			; 00000037H
  005c2	37		 DB	 55			; 00000037H
  005c3	2f		 DB	 47			; 0000002fH
  005c4	30		 DB	 48			; 00000030H
  005c5	31		 DB	 49			; 00000031H
  005c6	32		 DB	 50			; 00000032H
  005c7	33		 DB	 51			; 00000033H
  005c8	34		 DB	 52			; 00000034H
  005c9	35		 DB	 53			; 00000035H
  005ca	37		 DB	 55			; 00000037H
  005cb	37		 DB	 55			; 00000037H
  005cc	37		 DB	 55			; 00000037H
  005cd	37		 DB	 55			; 00000037H
  005ce	37		 DB	 55			; 00000037H
  005cf	37		 DB	 55			; 00000037H
  005d0	37		 DB	 55			; 00000037H
  005d1	36		 DB	 54			; 00000036H
load	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@GLAKAKP@Unpickler?4__init__?$CI?$CJ?5was?5not?5cal@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Unpickler_load DD imagerel Unpickler_load
	DD	imagerel Unpickler_load+57
	DD	imagerel $unwind$Unpickler_load
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_load DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0DF@GLAKAKP@Unpickler?4__init__?$CI?$CJ?5was?5not?5cal@
CONST	SEGMENT
??_C@_0DF@GLAKAKP@Unpickler?4__init__?$CI?$CJ?5was?5not?5cal@ DB 'Unpickl'
	DB	'er.__init__() was not called by %s.__init__()', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT Unpickler_load
_TEXT	SEGMENT
self$ = 48
Unpickler_load PROC					; COMDAT

; 5464 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 5465 :     /* Check whether the Unpickler was initialized correctly. This prevents
; 5466 :        segfaulting if a subclass overridden __init__ with a function that does
; 5467 :        not call Unpickler.__init__(). Here, we simply ensure that self->read
; 5468 :        is not NULL. */
; 5469 :     if (self->read == NULL) {

  00004	48 83 b9 00 01
	00 00 00	 cmp	 QWORD PTR [rcx+256], 0
  0000c	75 22		 jne	 SHORT $LN1@Unpickler_@16

; 5470 :         PyErr_Format(UnpicklingError,
; 5471 :                      "Unpickler.__init__() was not called by %s.__init__()",
; 5472 :                      Py_TYPE(self)->tp_name);

  0000e	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR UnpicklingError
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@GLAKAKP@Unpickler?4__init__?$CI?$CJ?5was?5not?5cal@
  00020	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00024	e8 00 00 00 00	 call	 PyErr_Format

; 5473 :         return NULL;

  00029	33 c0		 xor	 eax, eax

; 5474 :     }
; 5475 : 
; 5476 :     return load(self);
; 5477 : }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
$LN1@Unpickler_@16:
  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	e9 00 00 00 00	 jmp	 load
Unpickler_load ENDP
_TEXT	ENDS
PUBLIC	??_C@_0ED@DGNEEHFG@_compat_pickle?4IMPORT_MAPPING?5va@ ; `string'
PUBLIC	??_C@_0EC@MMPLOPKK@_compat_pickle?4NAME_MAPPING?5valu@ ; `string'
PUBLIC	??_C@_0FA@NKGOBDJL@_compat_pickle?4NAME_MAPPING?5valu@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Unpickler_find_class DD imagerel Unpickler_find_class
	DD	imagerel Unpickler_find_class+75
	DD	imagerel $unwind$Unpickler_find_class
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$Unpickler_find_class DD imagerel Unpickler_find_class+75
	DD	imagerel Unpickler_find_class+285
	DD	imagerel $chain$0$Unpickler_find_class
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$Unpickler_find_class DD imagerel Unpickler_find_class+285
	DD	imagerel Unpickler_find_class+321
	DD	imagerel $chain$2$Unpickler_find_class
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$Unpickler_find_class DD imagerel Unpickler_find_class+321
	DD	imagerel Unpickler_find_class+406
	DD	imagerel $chain$4$Unpickler_find_class
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$Unpickler_find_class DD imagerel Unpickler_find_class+406
	DD	imagerel Unpickler_find_class+524
	DD	imagerel $chain$6$Unpickler_find_class
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$Unpickler_find_class DD imagerel Unpickler_find_class+524
	DD	imagerel Unpickler_find_class+551
	DD	imagerel $chain$8$Unpickler_find_class
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$Unpickler_find_class DD 020021H
	DD	087400H
	DD	imagerel Unpickler_find_class
	DD	imagerel Unpickler_find_class+75
	DD	imagerel $unwind$Unpickler_find_class
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$Unpickler_find_class DD 020021H
	DD	087400H
	DD	imagerel Unpickler_find_class
	DD	imagerel Unpickler_find_class+75
	DD	imagerel $unwind$Unpickler_find_class
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$Unpickler_find_class DD 020021H
	DD	087400H
	DD	imagerel Unpickler_find_class
	DD	imagerel Unpickler_find_class+75
	DD	imagerel $unwind$Unpickler_find_class
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$Unpickler_find_class DD 020021H
	DD	087400H
	DD	imagerel Unpickler_find_class
	DD	imagerel Unpickler_find_class+75
	DD	imagerel $unwind$Unpickler_find_class
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$Unpickler_find_class DD 020521H
	DD	087405H
	DD	imagerel Unpickler_find_class
	DD	imagerel Unpickler_find_class+75
	DD	imagerel $unwind$Unpickler_find_class
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_find_class DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0ED@DGNEEHFG@_compat_pickle?4IMPORT_MAPPING?5va@
CONST	SEGMENT
??_C@_0ED@DGNEEHFG@_compat_pickle?4IMPORT_MAPPING?5va@ DB '_compat_pickle'
	DB	'.IMPORT_MAPPING values should be strings, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@MMPLOPKK@_compat_pickle?4NAME_MAPPING?5valu@
CONST	SEGMENT
??_C@_0EC@MMPLOPKK@_compat_pickle?4NAME_MAPPING?5valu@ DB '_compat_pickle'
	DB	'.NAME_MAPPING values should be 2-tuples, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@NKGOBDJL@_compat_pickle?4NAME_MAPPING?5valu@
CONST	SEGMENT
??_C@_0FA@NKGOBDJL@_compat_pickle?4NAME_MAPPING?5valu@ DB '_compat_pickle'
	DB	'.NAME_MAPPING values should be pairs of str, not (%.200s, %.2'
	DB	'00s)', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT Unpickler_find_class
_TEXT	SEGMENT
self$ = 64
args$ = 72
module_name$ = 80
global_name$ = 88
Unpickler_find_class PROC				; COMDAT

; 5495 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 5496 :     PyObject *global;
; 5497 :     PyObject *modules_dict;
; 5498 :     PyObject *module;
; 5499 :     PyObject *module_name, *global_name;
; 5500 : 
; 5501 :     if (!PyArg_UnpackTuple(args, "find_class", 2, 2,
; 5502 :                            &module_name, &global_name))

  0000c	48 8d 4c 24 58	 lea	 rcx, QWORD PTR global_name$[rsp]
  00011	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00016	48 8d 4c 24 50	 lea	 rcx, QWORD PTR module_name$[rsp]
  0001b	41 b9 02 00 00
	00		 mov	 r9d, 2
  00021	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@BHOLNLBJ@find_class?$AA@
  0002d	48 8b c8	 mov	 rcx, rax
  00030	45 8b c1	 mov	 r8d, r9d
  00033	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00038	85 c0		 test	 eax, eax
  0003a	75 08		 jne	 SHORT $LN19@Unpickler_@17

; 5503 :         return NULL;

  0003c	33 c0		 xor	 eax, eax

; 5576 : }

  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	5b		 pop	 rbx
  00043	c3		 ret	 0
$LN19@Unpickler_@17:

; 5504 : 
; 5505 :     /* Try to map the old names used in Python 2.x to the new ones used in
; 5506 :        Python 3.x.  We do this only with old pickle protocols and when the
; 5507 :        user has not disabled the feature. */
; 5508 :     if (self->proto < 3 && self->fix_imports) {

  00044	83 bb 40 01 00
	00 03		 cmp	 DWORD PTR [rbx+320], 3
  0004b	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00050	0f 8d 51 01 00
	00		 jge	 $LN6@Unpickler_@17
  00056	83 bb 44 01 00
	00 00		 cmp	 DWORD PTR [rbx+324], 0
  0005d	0f 84 44 01 00
	00		 je	 $LN6@Unpickler_@17

; 5509 :         PyObject *key;
; 5510 :         PyObject *item;
; 5511 : 
; 5512 :         /* Check if the global (i.e., a function or a class) was renamed
; 5513 :            or moved to another module. */
; 5514 :         key = PyTuple_Pack(2, module_name, global_name);

  00063	4c 8b 44 24 58	 mov	 r8, QWORD PTR global_name$[rsp]
  00068	48 8b 54 24 50	 mov	 rdx, QWORD PTR module_name$[rsp]
  0006d	b9 02 00 00 00	 mov	 ecx, 2
  00072	e8 00 00 00 00	 call	 PyTuple_Pack
  00077	48 8b f8	 mov	 rdi, rax

; 5515 :         if (key == NULL)

  0007a	48 85 c0	 test	 rax, rax

; 5516 :             return NULL;

  0007d	0f 84 06 01 00
	00		 je	 $LN24@Unpickler_@17

; 5517 :         item = PyDict_GetItemWithError(name_mapping_2to3, key);

  00083	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR name_mapping_2to3
  0008a	48 8b d0	 mov	 rdx, rax
  0008d	e8 00 00 00 00	 call	 PyDict_GetItemWithError

; 5518 :         Py_DECREF(key);

  00092	48 8b cf	 mov	 rcx, rdi
  00095	48 8b d8	 mov	 rbx, rax
  00098	e8 00 00 00 00	 call	 _Py_DecRef

; 5519 :         if (item) {

  0009d	48 85 db	 test	 rbx, rbx
  000a0	0f 84 9b 00 00
	00		 je	 $LN16@Unpickler_@17

; 5520 :             if (!PyTuple_Check(item) || PyTuple_GET_SIZE(item) != 2) {

  000a6	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  000aa	41 f7 80 00 01
	00 00 00 00 00
	04		 test	 DWORD PTR [r8+256], 67108864 ; 04000000H
  000b5	74 66		 je	 SHORT $LN14@Unpickler_@17
  000b7	48 83 7b 60 02	 cmp	 QWORD PTR [rbx+96], 2
  000bc	75 5f		 jne	 SHORT $LN14@Unpickler_@17

; 5525 :             }
; 5526 :             module_name = PyTuple_GET_ITEM(item, 0);

  000be	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
  000c2	48 89 54 24 50	 mov	 QWORD PTR module_name$[rsp], rdx

; 5527 :             global_name = PyTuple_GET_ITEM(item, 1);

  000c7	4c 8b 4b 78	 mov	 r9, QWORD PTR [rbx+120]
  000cb	4c 89 4c 24 58	 mov	 QWORD PTR global_name$[rsp], r9

; 5528 :             if (!PyUnicode_Check(module_name) ||
; 5529 :                 !PyUnicode_Check(global_name)) {

  000d0	4c 8b 42 58	 mov	 r8, QWORD PTR [rdx+88]
  000d4	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  000df	74 10		 je	 SHORT $LN12@Unpickler_@17
  000e1	49 8b 41 58	 mov	 rax, QWORD PTR [r9+88]
  000e5	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  000ef	75 5f		 jne	 SHORT $LN10@Unpickler_@17
$LN12@Unpickler_@17:

; 5530 :                 PyErr_Format(PyExc_RuntimeError,
; 5531 :                              "_compat_pickle.NAME_MAPPING values should be "
; 5532 :                              "pairs of str, not (%.200s, %.200s)",
; 5533 :                              Py_TYPE(module_name)->tp_name,
; 5534 :                              Py_TYPE(global_name)->tp_name);

  000f1	4d 8b 49 58	 mov	 r9, QWORD PTR [r9+88]
  000f5	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000f9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00100	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  00104	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FA@NKGOBDJL@_compat_pickle?4NAME_MAPPING?5valu@
  0010b	e8 00 00 00 00	 call	 PyErr_Format
  00110	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 5535 :                 return NULL;

  00115	33 c0		 xor	 eax, eax

; 5576 : }

  00117	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011b	5b		 pop	 rbx
  0011c	c3		 ret	 0
$LN14@Unpickler_@17:

; 5521 :                 PyErr_Format(PyExc_RuntimeError,
; 5522 :                              "_compat_pickle.NAME_MAPPING values should be "
; 5523 :                              "2-tuples, not %.200s", Py_TYPE(item)->tp_name);

  0011d	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00121	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00128	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@MMPLOPKK@_compat_pickle?4NAME_MAPPING?5valu@
  0012f	e8 00 00 00 00	 call	 PyErr_Format
  00134	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 5524 :                 return NULL;

  00139	33 c0		 xor	 eax, eax

; 5576 : }

  0013b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0013f	5b		 pop	 rbx
  00140	c3		 ret	 0
$LN16@Unpickler_@17:

; 5536 :             }
; 5537 :         }
; 5538 :         else if (PyErr_Occurred()) {

  00141	e8 00 00 00 00	 call	 PyErr_Occurred
  00146	48 85 c0	 test	 rax, rax

; 5539 :             return NULL;

  00149	75 3e		 jne	 SHORT $LN24@Unpickler_@17
  0014b	48 8b 54 24 50	 mov	 rdx, QWORD PTR module_name$[rsp]
$LN10@Unpickler_@17:

; 5540 :         }
; 5541 : 
; 5542 :         /* Check if the module was renamed. */
; 5543 :         item = PyDict_GetItemWithError(import_mapping_2to3, module_name);

  00150	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR import_mapping_2to3
  00157	e8 00 00 00 00	 call	 PyDict_GetItemWithError

; 5544 :         if (item) {

  0015c	48 85 c0	 test	 rax, rax
  0015f	74 3c		 je	 SHORT $LN9@Unpickler_@17

; 5545 :             if (!PyUnicode_Check(item)) {

  00161	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00165	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  00170	75 24		 jne	 SHORT $LN8@Unpickler_@17

; 5546 :                 PyErr_Format(PyExc_RuntimeError,
; 5547 :                              "_compat_pickle.IMPORT_MAPPING values should be "
; 5548 :                              "strings, not %.200s", Py_TYPE(item)->tp_name);

  00172	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00176	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0017d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0ED@DGNEEHFG@_compat_pickle?4IMPORT_MAPPING?5va@
  00184	e8 00 00 00 00	 call	 PyErr_Format
$LN24@Unpickler_@17:

; 5549 :                 return NULL;

  00189	33 c0		 xor	 eax, eax
  0018b	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 5576 : }

  00190	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00194	5b		 pop	 rbx
  00195	c3		 ret	 0
$LN8@Unpickler_@17:

; 5550 :             }
; 5551 :             module_name = item;

  00196	48 89 44 24 50	 mov	 QWORD PTR module_name$[rsp], rax
  0019b	eb 0a		 jmp	 SHORT $LN6@Unpickler_@17
$LN9@Unpickler_@17:

; 5552 :         }
; 5553 :         else if (PyErr_Occurred()) {

  0019d	e8 00 00 00 00	 call	 PyErr_Occurred
  001a2	48 85 c0	 test	 rax, rax

; 5554 :             return NULL;

  001a5	75 e2		 jne	 SHORT $LN24@Unpickler_@17
$LN6@Unpickler_@17:

; 5555 :         }
; 5556 :     }
; 5557 : 
; 5558 :     modules_dict = PySys_GetObject("modules");

  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07DFGEOAEG@modules?$AA@
  001ae	e8 00 00 00 00	 call	 PySys_GetObject

; 5559 :     if (modules_dict == NULL)

  001b3	48 85 c0	 test	 rax, rax

; 5560 :         return NULL;

  001b6	74 d1		 je	 SHORT $LN24@Unpickler_@17

; 5561 : 
; 5562 :     module = PyDict_GetItemWithError(modules_dict, module_name);

  001b8	48 8b 54 24 50	 mov	 rdx, QWORD PTR module_name$[rsp]
  001bd	48 8b c8	 mov	 rcx, rax
  001c0	e8 00 00 00 00	 call	 PyDict_GetItemWithError

; 5563 :     if (module == NULL) {

  001c5	48 85 c0	 test	 rax, rax
  001c8	75 42		 jne	 SHORT $LN4@Unpickler_@17

; 5564 :         if (PyErr_Occurred())

  001ca	e8 00 00 00 00	 call	 PyErr_Occurred
  001cf	48 85 c0	 test	 rax, rax

; 5565 :             return NULL;

  001d2	75 b5		 jne	 SHORT $LN24@Unpickler_@17

; 5566 :         module = PyImport_Import(module_name);

  001d4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR module_name$[rsp]
  001d9	e8 00 00 00 00	 call	 PyImport_Import
  001de	48 8b d8	 mov	 rbx, rax

; 5567 :         if (module == NULL)

  001e1	48 85 c0	 test	 rax, rax

; 5568 :             return NULL;

  001e4	74 a3		 je	 SHORT $LN24@Unpickler_@17

; 5569 :         global = PyObject_GetAttr(module, global_name);

  001e6	48 8b 54 24 58	 mov	 rdx, QWORD PTR global_name$[rsp]
  001eb	48 8b c8	 mov	 rcx, rax
  001ee	e8 00 00 00 00	 call	 PyObject_GetAttr

; 5570 :         Py_DECREF(module);

  001f3	48 8b cb	 mov	 rcx, rbx
  001f6	48 8b f8	 mov	 rdi, rax
  001f9	e8 00 00 00 00	 call	 _Py_DecRef

; 5574 :     }
; 5575 :     return global;

  001fe	48 8b c7	 mov	 rax, rdi
  00201	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 5576 : }

  00206	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0020a	5b		 pop	 rbx
  0020b	c3		 ret	 0
$LN4@Unpickler_@17:

; 5571 :     }
; 5572 :     else {
; 5573 :         global = PyObject_GetAttr(module, global_name);

  0020c	48 8b 54 24 58	 mov	 rdx, QWORD PTR global_name$[rsp]
  00211	48 8b c8	 mov	 rcx, rax
  00214	e8 00 00 00 00	 call	 PyObject_GetAttr
  00219	48 8b f8	 mov	 rdi, rax
  0021c	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 5576 : }

  00221	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00225	5b		 pop	 rbx
  00226	c3		 ret	 0
Unpickler_find_class ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$Unpickler_dealloc DD imagerel Unpickler_dealloc
	DD	imagerel Unpickler_dealloc+805
	DD	imagerel $unwind$Unpickler_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT Unpickler_dealloc
_TEXT	SEGMENT
self$ = 64
Unpickler_dealloc PROC					; COMDAT

; 5588 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 5589 :     PyObject_GC_UnTrack((PyObject *)self);

  0000d	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 5590 :     Py_XDECREF(self->readline);

  00012	48 8b 9f 08 01
	00 00		 mov	 rbx, QWORD PTR [rdi+264]
  00019	48 85 db	 test	 rbx, rbx
  0001c	74 65		 je	 SHORT $LN24@Unpickler_@18
  0001e	e8 00 00 00 00	 call	 _Py_PXCTX
  00023	85 c0		 test	 eax, eax
  00025	75 5c		 jne	 SHORT $LN24@Unpickler_@18
  00027	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0002b	a8 20		 test	 al, 32			; 00000020H
  0002d	75 4c		 jne	 SHORT $LN32@Unpickler_@18
  0002f	84 c0		 test	 al, al
  00031	78 48		 js	 SHORT $LN32@Unpickler_@18
  00033	a8 02		 test	 al, 2
  00035	75 4c		 jne	 SHORT $LN24@Unpickler_@18
  00037	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0003b	75 46		 jne	 SHORT $LN24@Unpickler_@18
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0004b	4c 8b cb	 mov	 r9, rbx
  0004e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00054	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0005c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00061	48 8b cb	 mov	 rcx, rbx
  00064	85 c0		 test	 eax, eax
  00066	74 07		 je	 SHORT $LN37@Unpickler_@18
  00068	e8 00 00 00 00	 call	 _Px_Dealloc
  0006d	eb 14		 jmp	 SHORT $LN24@Unpickler_@18
$LN37@Unpickler_@18:
  0006f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00073	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00079	eb 08		 jmp	 SHORT $LN24@Unpickler_@18
$LN32@Unpickler_@18:
  0007b	48 8b cb	 mov	 rcx, rbx
  0007e	e8 00 00 00 00	 call	 Px_DecRef
$LN24@Unpickler_@18:

; 5591 :     Py_XDECREF(self->read);

  00083	48 8b 9f 00 01
	00 00		 mov	 rbx, QWORD PTR [rdi+256]
  0008a	48 85 db	 test	 rbx, rbx
  0008d	74 65		 je	 SHORT $LN20@Unpickler_@18
  0008f	e8 00 00 00 00	 call	 _Py_PXCTX
  00094	85 c0		 test	 eax, eax
  00096	75 5c		 jne	 SHORT $LN20@Unpickler_@18
  00098	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0009c	a8 20		 test	 al, 32			; 00000020H
  0009e	75 4c		 jne	 SHORT $LN43@Unpickler_@18
  000a0	84 c0		 test	 al, al
  000a2	78 48		 js	 SHORT $LN43@Unpickler_@18
  000a4	a8 02		 test	 al, 2
  000a6	75 4c		 jne	 SHORT $LN20@Unpickler_@18
  000a8	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000ac	75 46		 jne	 SHORT $LN20@Unpickler_@18
  000ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000bc	4c 8b cb	 mov	 r9, rbx
  000bf	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000c5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000cd	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d2	48 8b cb	 mov	 rcx, rbx
  000d5	85 c0		 test	 eax, eax
  000d7	74 07		 je	 SHORT $LN48@Unpickler_@18
  000d9	e8 00 00 00 00	 call	 _Px_Dealloc
  000de	eb 14		 jmp	 SHORT $LN20@Unpickler_@18
$LN48@Unpickler_@18:
  000e0	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000e4	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000ea	eb 08		 jmp	 SHORT $LN20@Unpickler_@18
$LN43@Unpickler_@18:
  000ec	48 8b cb	 mov	 rcx, rbx
  000ef	e8 00 00 00 00	 call	 Px_DecRef
$LN20@Unpickler_@18:

; 5592 :     Py_XDECREF(self->peek);

  000f4	48 8b 9f 10 01
	00 00		 mov	 rbx, QWORD PTR [rdi+272]
  000fb	48 85 db	 test	 rbx, rbx
  000fe	74 65		 je	 SHORT $LN16@Unpickler_@18
  00100	e8 00 00 00 00	 call	 _Py_PXCTX
  00105	85 c0		 test	 eax, eax
  00107	75 5c		 jne	 SHORT $LN16@Unpickler_@18
  00109	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0010d	a8 20		 test	 al, 32			; 00000020H
  0010f	75 4c		 jne	 SHORT $LN54@Unpickler_@18
  00111	84 c0		 test	 al, al
  00113	78 48		 js	 SHORT $LN54@Unpickler_@18
  00115	a8 02		 test	 al, 2
  00117	75 4c		 jne	 SHORT $LN16@Unpickler_@18
  00119	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0011d	75 46		 jne	 SHORT $LN16@Unpickler_@18
  0011f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0012d	4c 8b cb	 mov	 r9, rbx
  00130	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00136	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0013e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00143	48 8b cb	 mov	 rcx, rbx
  00146	85 c0		 test	 eax, eax
  00148	74 07		 je	 SHORT $LN59@Unpickler_@18
  0014a	e8 00 00 00 00	 call	 _Px_Dealloc
  0014f	eb 14		 jmp	 SHORT $LN16@Unpickler_@18
$LN59@Unpickler_@18:
  00151	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00155	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0015b	eb 08		 jmp	 SHORT $LN16@Unpickler_@18
$LN54@Unpickler_@18:
  0015d	48 8b cb	 mov	 rcx, rbx
  00160	e8 00 00 00 00	 call	 Px_DecRef
$LN16@Unpickler_@18:

; 5593 :     Py_XDECREF(self->stack);

  00165	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  00169	48 85 db	 test	 rbx, rbx
  0016c	74 65		 je	 SHORT $LN12@Unpickler_@18
  0016e	e8 00 00 00 00	 call	 _Py_PXCTX
  00173	85 c0		 test	 eax, eax
  00175	75 5c		 jne	 SHORT $LN12@Unpickler_@18
  00177	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0017b	a8 20		 test	 al, 32			; 00000020H
  0017d	75 4c		 jne	 SHORT $LN65@Unpickler_@18
  0017f	84 c0		 test	 al, al
  00181	78 48		 js	 SHORT $LN65@Unpickler_@18
  00183	a8 02		 test	 al, 2
  00185	75 4c		 jne	 SHORT $LN12@Unpickler_@18
  00187	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0018b	75 46		 jne	 SHORT $LN12@Unpickler_@18
  0018d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0019b	4c 8b cb	 mov	 r9, rbx
  0019e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001ac	e8 00 00 00 00	 call	 _PyParallel_Guard
  001b1	48 8b cb	 mov	 rcx, rbx
  001b4	85 c0		 test	 eax, eax
  001b6	74 07		 je	 SHORT $LN70@Unpickler_@18
  001b8	e8 00 00 00 00	 call	 _Px_Dealloc
  001bd	eb 14		 jmp	 SHORT $LN12@Unpickler_@18
$LN70@Unpickler_@18:
  001bf	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001c3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001c9	eb 08		 jmp	 SHORT $LN12@Unpickler_@18
$LN65@Unpickler_@18:
  001cb	48 8b cb	 mov	 rcx, rbx
  001ce	e8 00 00 00 00	 call	 Px_DecRef
$LN12@Unpickler_@18:

; 5594 :     Py_XDECREF(self->pers_func);

  001d3	48 8b 9f 80 00
	00 00		 mov	 rbx, QWORD PTR [rdi+128]
  001da	48 85 db	 test	 rbx, rbx
  001dd	74 65		 je	 SHORT $LN8@Unpickler_@18
  001df	e8 00 00 00 00	 call	 _Py_PXCTX
  001e4	85 c0		 test	 eax, eax
  001e6	75 5c		 jne	 SHORT $LN8@Unpickler_@18
  001e8	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001ec	a8 20		 test	 al, 32			; 00000020H
  001ee	75 4c		 jne	 SHORT $LN76@Unpickler_@18
  001f0	84 c0		 test	 al, al
  001f2	78 48		 js	 SHORT $LN76@Unpickler_@18
  001f4	a8 02		 test	 al, 2
  001f6	75 4c		 jne	 SHORT $LN8@Unpickler_@18
  001f8	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001fc	75 46		 jne	 SHORT $LN8@Unpickler_@18
  001fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00205	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0020c	4c 8b cb	 mov	 r9, rbx
  0020f	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00215	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0021d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00222	48 8b cb	 mov	 rcx, rbx
  00225	85 c0		 test	 eax, eax
  00227	74 07		 je	 SHORT $LN81@Unpickler_@18
  00229	e8 00 00 00 00	 call	 _Px_Dealloc
  0022e	eb 14		 jmp	 SHORT $LN8@Unpickler_@18
$LN81@Unpickler_@18:
  00230	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00234	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0023a	eb 08		 jmp	 SHORT $LN8@Unpickler_@18
$LN76@Unpickler_@18:
  0023c	48 8b cb	 mov	 rcx, rbx
  0023f	e8 00 00 00 00	 call	 Px_DecRef
$LN8@Unpickler_@18:

; 5595 :     Py_XDECREF(self->arg);

  00244	48 8b 5f 78	 mov	 rbx, QWORD PTR [rdi+120]
  00248	48 85 db	 test	 rbx, rbx
  0024b	74 65		 je	 SHORT $LN4@Unpickler_@18
  0024d	e8 00 00 00 00	 call	 _Py_PXCTX
  00252	85 c0		 test	 eax, eax
  00254	75 5c		 jne	 SHORT $LN4@Unpickler_@18
  00256	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0025a	a8 20		 test	 al, 32			; 00000020H
  0025c	75 4c		 jne	 SHORT $LN87@Unpickler_@18
  0025e	84 c0		 test	 al, al
  00260	78 48		 js	 SHORT $LN87@Unpickler_@18
  00262	a8 02		 test	 al, 2
  00264	75 4c		 jne	 SHORT $LN4@Unpickler_@18
  00266	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0026a	75 46		 jne	 SHORT $LN4@Unpickler_@18
  0026c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00273	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0027a	4c 8b cb	 mov	 r9, rbx
  0027d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00283	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0028b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00290	48 8b cb	 mov	 rcx, rbx
  00293	85 c0		 test	 eax, eax
  00295	74 07		 je	 SHORT $LN92@Unpickler_@18
  00297	e8 00 00 00 00	 call	 _Px_Dealloc
  0029c	eb 14		 jmp	 SHORT $LN4@Unpickler_@18
$LN92@Unpickler_@18:
  0029e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  002a2	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002a8	eb 08		 jmp	 SHORT $LN4@Unpickler_@18
$LN87@Unpickler_@18:
  002aa	48 8b cb	 mov	 rcx, rbx
  002ad	e8 00 00 00 00	 call	 Px_DecRef
$LN4@Unpickler_@18:

; 5596 :     if (self->buffer.buf != NULL) {

  002b2	48 83 bf 88 00
	00 00 00	 cmp	 QWORD PTR [rdi+136], 0
  002ba	74 17		 je	 SHORT $LN1@Unpickler_@18

; 5597 :         PyBuffer_Release(&self->buffer);

  002bc	48 8d 8f 88 00
	00 00		 lea	 rcx, QWORD PTR [rdi+136]
  002c3	e8 00 00 00 00	 call	 PyBuffer_Release

; 5598 :         self->buffer.buf = NULL;

  002c8	48 c7 87 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rdi+136], 0
$LN1@Unpickler_@18:

; 5599 :     }
; 5600 : 
; 5601 :     _Unpickler_MemoCleanup(self);

  002d3	48 8b cf	 mov	 rcx, rdi
  002d6	e8 00 00 00 00	 call	 _Unpickler_MemoCleanup

; 5602 :     PyMem_Free(self->marks);

  002db	48 8b 8f 28 01
	00 00		 mov	 rcx, QWORD PTR [rdi+296]
  002e2	e8 00 00 00 00	 call	 PyMem_Free

; 5603 :     PyMem_Free(self->input_line);

  002e7	48 8b 8f e0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+224]
  002ee	e8 00 00 00 00	 call	 PyMem_Free

; 5604 :     free(self->encoding);

  002f3	48 8b 8f 18 01
	00 00		 mov	 rcx, QWORD PTR [rdi+280]
  002fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5605 :     free(self->errors);

  00300	48 8b 8f 20 01
	00 00		 mov	 rcx, QWORD PTR [rdi+288]
  00307	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5606 : 
; 5607 :     Py_TYPE(self)->tp_free((PyObject *)self);

  0030d	4c 8b 5f 58	 mov	 r11, QWORD PTR [rdi+88]
  00311	48 8b cf	 mov	 rcx, rdi

; 5608 : }

  00314	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00319	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0031d	5f		 pop	 rdi
  0031e	49 ff a3 98 01
	00 00		 rex_jmp QWORD PTR [r11+408]
Unpickler_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Unpickler_traverse DD imagerel Unpickler_traverse
	DD	imagerel Unpickler_traverse+396
	DD	imagerel $unwind$Unpickler_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@
CONST	SEGMENT
??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@ DB 'Unpickler_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT Unpickler_traverse
_TEXT	SEGMENT
self$ = 48
visit$ = 56
arg$ = 64
Unpickler_traverse PROC					; COMDAT

; 5612 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 5613 :     Py_VISIT(self->readline);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN33@Unpickler_@19
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 ed 15 00
	00		 mov	 r8d, 5613		; 000015edH
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN33@Unpickler_@19:
  0003d	48 8b 8b 08 01
	00 00		 mov	 rcx, QWORD PTR [rbx+264]
  00044	48 85 c9	 test	 rcx, rcx
  00047	74 0d		 je	 SHORT $LN35@Unpickler_@19
  00049	48 8b d7	 mov	 rdx, rdi
  0004c	ff d6		 call	 rsi
  0004e	85 c0		 test	 eax, eax
  00050	0f 85 26 01 00
	00		 jne	 $LN37@Unpickler_@19
$LN35@Unpickler_@19:

; 5614 :     Py_VISIT(self->read);

  00056	e8 00 00 00 00	 call	 _Py_PXCTX
  0005b	85 c0		 test	 eax, eax
  0005d	74 1c		 je	 SHORT $LN27@Unpickler_@19
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@
  0006d	45 33 c9	 xor	 r9d, r9d
  00070	41 b8 ee 15 00
	00		 mov	 r8d, 5614		; 000015eeH
  00076	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN27@Unpickler_@19:
  0007b	48 8b 8b 00 01
	00 00		 mov	 rcx, QWORD PTR [rbx+256]
  00082	48 85 c9	 test	 rcx, rcx
  00085	74 0d		 je	 SHORT $LN29@Unpickler_@19
  00087	48 8b d7	 mov	 rdx, rdi
  0008a	ff d6		 call	 rsi
  0008c	85 c0		 test	 eax, eax
  0008e	0f 85 e8 00 00
	00		 jne	 $LN37@Unpickler_@19
$LN29@Unpickler_@19:

; 5615 :     Py_VISIT(self->peek);

  00094	e8 00 00 00 00	 call	 _Py_PXCTX
  00099	85 c0		 test	 eax, eax
  0009b	74 1c		 je	 SHORT $LN21@Unpickler_@19
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@
  000ab	45 33 c9	 xor	 r9d, r9d
  000ae	41 b8 ef 15 00
	00		 mov	 r8d, 5615		; 000015efH
  000b4	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN21@Unpickler_@19:
  000b9	48 8b 8b 10 01
	00 00		 mov	 rcx, QWORD PTR [rbx+272]
  000c0	48 85 c9	 test	 rcx, rcx
  000c3	74 0d		 je	 SHORT $LN23@Unpickler_@19
  000c5	48 8b d7	 mov	 rdx, rdi
  000c8	ff d6		 call	 rsi
  000ca	85 c0		 test	 eax, eax
  000cc	0f 85 aa 00 00
	00		 jne	 $LN37@Unpickler_@19
$LN23@Unpickler_@19:

; 5616 :     Py_VISIT(self->stack);

  000d2	e8 00 00 00 00	 call	 _Py_PXCTX
  000d7	85 c0		 test	 eax, eax
  000d9	74 1c		 je	 SHORT $LN15@Unpickler_@19
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@
  000e9	45 33 c9	 xor	 r9d, r9d
  000ec	41 b8 f0 15 00
	00		 mov	 r8d, 5616		; 000015f0H
  000f2	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN15@Unpickler_@19:
  000f7	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  000fb	48 85 c9	 test	 rcx, rcx
  000fe	74 09		 je	 SHORT $LN17@Unpickler_@19
  00100	48 8b d7	 mov	 rdx, rdi
  00103	ff d6		 call	 rsi
  00105	85 c0		 test	 eax, eax
  00107	75 73		 jne	 SHORT $LN37@Unpickler_@19
$LN17@Unpickler_@19:

; 5617 :     Py_VISIT(self->pers_func);

  00109	e8 00 00 00 00	 call	 _Py_PXCTX
  0010e	85 c0		 test	 eax, eax
  00110	74 1c		 je	 SHORT $LN9@Unpickler_@19
  00112	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@
  00120	45 33 c9	 xor	 r9d, r9d
  00123	41 b8 f1 15 00
	00		 mov	 r8d, 5617		; 000015f1H
  00129	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@Unpickler_@19:
  0012e	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00135	48 85 c9	 test	 rcx, rcx
  00138	74 09		 je	 SHORT $LN11@Unpickler_@19
  0013a	48 8b d7	 mov	 rdx, rdi
  0013d	ff d6		 call	 rsi
  0013f	85 c0		 test	 eax, eax
  00141	75 39		 jne	 SHORT $LN37@Unpickler_@19
$LN11@Unpickler_@19:

; 5618 :     Py_VISIT(self->arg);

  00143	e8 00 00 00 00	 call	 _Py_PXCTX
  00148	85 c0		 test	 eax, eax
  0014a	74 1c		 je	 SHORT $LN3@Unpickler_@19
  0014c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MEJFKJH@Unpickler_traverse?$AA@
  0015a	45 33 c9	 xor	 r9d, r9d
  0015d	41 b8 f2 15 00
	00		 mov	 r8d, 5618		; 000015f2H
  00163	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@Unpickler_@19:
  00168	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  0016c	48 85 c9	 test	 rcx, rcx
  0016f	74 09		 je	 SHORT $LN5@Unpickler_@19
  00171	48 8b d7	 mov	 rdx, rdi
  00174	ff d6		 call	 rsi
  00176	85 c0		 test	 eax, eax
  00178	75 02		 jne	 SHORT $LN37@Unpickler_@19
$LN5@Unpickler_@19:

; 5619 :     return 0;

  0017a	33 c0		 xor	 eax, eax
$LN37@Unpickler_@19:

; 5620 : }

  0017c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00181	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00186	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0018a	5f		 pop	 rdi
  0018b	c3		 ret	 0
Unpickler_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$Unpickler_clear DD imagerel Unpickler_clear
	DD	imagerel Unpickler_clear+1142
	DD	imagerel $unwind$Unpickler_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_clear DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@
CONST	SEGMENT
??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@ DB 'Unpickler_clear', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT Unpickler_clear
_TEXT	SEGMENT
self$ = 64
Unpickler_clear PROC					; COMDAT

; 5624 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 5625 :     Py_CLEAR(self->readline);

  0000f	4c 8b 89 08 01
	00 00		 mov	 r9, QWORD PTR [rcx+264]
  00016	33 f6		 xor	 esi, esi
  00018	48 8b d9	 mov	 rbx, rcx
  0001b	4d 85 c9	 test	 r9, r9
  0001e	0f 84 98 00 00
	00		 je	 $LN24@Unpickler_@20
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@
  00032	41 b8 f9 15 00
	00		 mov	 r8d, 5625		; 000015f9H
  00038	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00040	e8 00 00 00 00	 call	 _PyParallel_Guard
  00045	85 c0		 test	 eax, eax
  00047	75 73		 jne	 SHORT $LN24@Unpickler_@20
  00049	48 8b bb 08 01
	00 00		 mov	 rdi, QWORD PTR [rbx+264]
  00050	48 89 b3 08 01
	00 00		 mov	 QWORD PTR [rbx+264], rsi
  00057	e8 00 00 00 00	 call	 _Py_PXCTX
  0005c	85 c0		 test	 eax, eax
  0005e	75 5c		 jne	 SHORT $LN24@Unpickler_@20
  00060	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00064	a8 20		 test	 al, 32			; 00000020H
  00066	75 4c		 jne	 SHORT $LN32@Unpickler_@20
  00068	84 c0		 test	 al, al
  0006a	78 48		 js	 SHORT $LN32@Unpickler_@20
  0006c	a8 02		 test	 al, 2
  0006e	75 4c		 jne	 SHORT $LN24@Unpickler_@20
  00070	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00074	75 46		 jne	 SHORT $LN24@Unpickler_@20
  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00084	4c 8b cf	 mov	 r9, rdi
  00087	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0008d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00095	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009a	48 8b cf	 mov	 rcx, rdi
  0009d	85 c0		 test	 eax, eax
  0009f	74 07		 je	 SHORT $LN37@Unpickler_@20
  000a1	e8 00 00 00 00	 call	 _Px_Dealloc
  000a6	eb 14		 jmp	 SHORT $LN24@Unpickler_@20
$LN37@Unpickler_@20:
  000a8	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  000ac	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000b2	eb 08		 jmp	 SHORT $LN24@Unpickler_@20
$LN32@Unpickler_@20:
  000b4	48 8b cf	 mov	 rcx, rdi
  000b7	e8 00 00 00 00	 call	 Px_DecRef
$LN24@Unpickler_@20:

; 5626 :     Py_CLEAR(self->read);

  000bc	4c 8b 8b 00 01
	00 00		 mov	 r9, QWORD PTR [rbx+256]
  000c3	4d 85 c9	 test	 r9, r9
  000c6	0f 84 98 00 00
	00		 je	 $LN20@Unpickler_@20
  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  000d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@
  000da	41 b8 fa 15 00
	00		 mov	 r8d, 5626		; 000015faH
  000e0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000e8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ed	85 c0		 test	 eax, eax
  000ef	75 73		 jne	 SHORT $LN20@Unpickler_@20
  000f1	48 8b bb 00 01
	00 00		 mov	 rdi, QWORD PTR [rbx+256]
  000f8	48 89 b3 00 01
	00 00		 mov	 QWORD PTR [rbx+256], rsi
  000ff	e8 00 00 00 00	 call	 _Py_PXCTX
  00104	85 c0		 test	 eax, eax
  00106	75 5c		 jne	 SHORT $LN20@Unpickler_@20
  00108	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0010c	a8 20		 test	 al, 32			; 00000020H
  0010e	75 4c		 jne	 SHORT $LN43@Unpickler_@20
  00110	84 c0		 test	 al, al
  00112	78 48		 js	 SHORT $LN43@Unpickler_@20
  00114	a8 02		 test	 al, 2
  00116	75 4c		 jne	 SHORT $LN20@Unpickler_@20
  00118	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0011c	75 46		 jne	 SHORT $LN20@Unpickler_@20
  0011e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0012c	4c 8b cf	 mov	 r9, rdi
  0012f	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00135	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0013d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00142	48 8b cf	 mov	 rcx, rdi
  00145	85 c0		 test	 eax, eax
  00147	74 07		 je	 SHORT $LN48@Unpickler_@20
  00149	e8 00 00 00 00	 call	 _Px_Dealloc
  0014e	eb 14		 jmp	 SHORT $LN20@Unpickler_@20
$LN48@Unpickler_@20:
  00150	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00154	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0015a	eb 08		 jmp	 SHORT $LN20@Unpickler_@20
$LN43@Unpickler_@20:
  0015c	48 8b cf	 mov	 rcx, rdi
  0015f	e8 00 00 00 00	 call	 Px_DecRef
$LN20@Unpickler_@20:

; 5627 :     Py_CLEAR(self->peek);

  00164	4c 8b 8b 10 01
	00 00		 mov	 r9, QWORD PTR [rbx+272]
  0016b	4d 85 c9	 test	 r9, r9
  0016e	0f 84 98 00 00
	00		 je	 $LN16@Unpickler_@20
  00174	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0017b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@
  00182	41 b8 fb 15 00
	00		 mov	 r8d, 5627		; 000015fbH
  00188	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00190	e8 00 00 00 00	 call	 _PyParallel_Guard
  00195	85 c0		 test	 eax, eax
  00197	75 73		 jne	 SHORT $LN16@Unpickler_@20
  00199	48 8b bb 10 01
	00 00		 mov	 rdi, QWORD PTR [rbx+272]
  001a0	48 89 b3 10 01
	00 00		 mov	 QWORD PTR [rbx+272], rsi
  001a7	e8 00 00 00 00	 call	 _Py_PXCTX
  001ac	85 c0		 test	 eax, eax
  001ae	75 5c		 jne	 SHORT $LN16@Unpickler_@20
  001b0	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  001b4	a8 20		 test	 al, 32			; 00000020H
  001b6	75 4c		 jne	 SHORT $LN54@Unpickler_@20
  001b8	84 c0		 test	 al, al
  001ba	78 48		 js	 SHORT $LN54@Unpickler_@20
  001bc	a8 02		 test	 al, 2
  001be	75 4c		 jne	 SHORT $LN16@Unpickler_@20
  001c0	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  001c4	75 46		 jne	 SHORT $LN16@Unpickler_@20
  001c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001d4	4c 8b cf	 mov	 r9, rdi
  001d7	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001dd	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001e5	e8 00 00 00 00	 call	 _PyParallel_Guard
  001ea	48 8b cf	 mov	 rcx, rdi
  001ed	85 c0		 test	 eax, eax
  001ef	74 07		 je	 SHORT $LN59@Unpickler_@20
  001f1	e8 00 00 00 00	 call	 _Px_Dealloc
  001f6	eb 14		 jmp	 SHORT $LN16@Unpickler_@20
$LN59@Unpickler_@20:
  001f8	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001fc	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00202	eb 08		 jmp	 SHORT $LN16@Unpickler_@20
$LN54@Unpickler_@20:
  00204	48 8b cf	 mov	 rcx, rdi
  00207	e8 00 00 00 00	 call	 Px_DecRef
$LN16@Unpickler_@20:

; 5628 :     Py_CLEAR(self->stack);

  0020c	4c 8b 4b 60	 mov	 r9, QWORD PTR [rbx+96]
  00210	4d 85 c9	 test	 r9, r9
  00213	0f 84 92 00 00
	00		 je	 $LN12@Unpickler_@20
  00219	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00220	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@
  00227	41 b8 fc 15 00
	00		 mov	 r8d, 5628		; 000015fcH
  0022d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00235	e8 00 00 00 00	 call	 _PyParallel_Guard
  0023a	85 c0		 test	 eax, eax
  0023c	75 6d		 jne	 SHORT $LN12@Unpickler_@20
  0023e	48 8b 7b 60	 mov	 rdi, QWORD PTR [rbx+96]
  00242	48 89 73 60	 mov	 QWORD PTR [rbx+96], rsi
  00246	e8 00 00 00 00	 call	 _Py_PXCTX
  0024b	85 c0		 test	 eax, eax
  0024d	75 5c		 jne	 SHORT $LN12@Unpickler_@20
  0024f	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00253	a8 20		 test	 al, 32			; 00000020H
  00255	75 4c		 jne	 SHORT $LN65@Unpickler_@20
  00257	84 c0		 test	 al, al
  00259	78 48		 js	 SHORT $LN65@Unpickler_@20
  0025b	a8 02		 test	 al, 2
  0025d	75 4c		 jne	 SHORT $LN12@Unpickler_@20
  0025f	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00263	75 46		 jne	 SHORT $LN12@Unpickler_@20
  00265	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0026c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00273	4c 8b cf	 mov	 r9, rdi
  00276	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0027c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00284	e8 00 00 00 00	 call	 _PyParallel_Guard
  00289	48 8b cf	 mov	 rcx, rdi
  0028c	85 c0		 test	 eax, eax
  0028e	74 07		 je	 SHORT $LN70@Unpickler_@20
  00290	e8 00 00 00 00	 call	 _Px_Dealloc
  00295	eb 14		 jmp	 SHORT $LN12@Unpickler_@20
$LN70@Unpickler_@20:
  00297	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0029b	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002a1	eb 08		 jmp	 SHORT $LN12@Unpickler_@20
$LN65@Unpickler_@20:
  002a3	48 8b cf	 mov	 rcx, rdi
  002a6	e8 00 00 00 00	 call	 Px_DecRef
$LN12@Unpickler_@20:

; 5629 :     Py_CLEAR(self->pers_func);

  002ab	4c 8b 8b 80 00
	00 00		 mov	 r9, QWORD PTR [rbx+128]
  002b2	4d 85 c9	 test	 r9, r9
  002b5	0f 84 98 00 00
	00		 je	 $LN8@Unpickler_@20
  002bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  002c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@
  002c9	41 b8 fd 15 00
	00		 mov	 r8d, 5629		; 000015fdH
  002cf	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002d7	e8 00 00 00 00	 call	 _PyParallel_Guard
  002dc	85 c0		 test	 eax, eax
  002de	75 73		 jne	 SHORT $LN8@Unpickler_@20
  002e0	48 8b bb 80 00
	00 00		 mov	 rdi, QWORD PTR [rbx+128]
  002e7	48 89 b3 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rsi
  002ee	e8 00 00 00 00	 call	 _Py_PXCTX
  002f3	85 c0		 test	 eax, eax
  002f5	75 5c		 jne	 SHORT $LN8@Unpickler_@20
  002f7	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  002fb	a8 20		 test	 al, 32			; 00000020H
  002fd	75 4c		 jne	 SHORT $LN76@Unpickler_@20
  002ff	84 c0		 test	 al, al
  00301	78 48		 js	 SHORT $LN76@Unpickler_@20
  00303	a8 02		 test	 al, 2
  00305	75 4c		 jne	 SHORT $LN8@Unpickler_@20
  00307	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0030b	75 46		 jne	 SHORT $LN8@Unpickler_@20
  0030d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00314	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0031b	4c 8b cf	 mov	 r9, rdi
  0031e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00324	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0032c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00331	48 8b cf	 mov	 rcx, rdi
  00334	85 c0		 test	 eax, eax
  00336	74 07		 je	 SHORT $LN81@Unpickler_@20
  00338	e8 00 00 00 00	 call	 _Px_Dealloc
  0033d	eb 14		 jmp	 SHORT $LN8@Unpickler_@20
$LN81@Unpickler_@20:
  0033f	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00343	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00349	eb 08		 jmp	 SHORT $LN8@Unpickler_@20
$LN76@Unpickler_@20:
  0034b	48 8b cf	 mov	 rcx, rdi
  0034e	e8 00 00 00 00	 call	 Px_DecRef
$LN8@Unpickler_@20:

; 5630 :     Py_CLEAR(self->arg);

  00353	4c 8b 4b 78	 mov	 r9, QWORD PTR [rbx+120]
  00357	4d 85 c9	 test	 r9, r9
  0035a	0f 84 92 00 00
	00		 je	 $LN4@Unpickler_@20
  00360	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00367	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@CNLIEFHF@Unpickler_clear?$AA@
  0036e	41 b8 fe 15 00
	00		 mov	 r8d, 5630		; 000015feH
  00374	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0037c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00381	85 c0		 test	 eax, eax
  00383	75 6d		 jne	 SHORT $LN4@Unpickler_@20
  00385	48 8b 7b 78	 mov	 rdi, QWORD PTR [rbx+120]
  00389	48 89 73 78	 mov	 QWORD PTR [rbx+120], rsi
  0038d	e8 00 00 00 00	 call	 _Py_PXCTX
  00392	85 c0		 test	 eax, eax
  00394	75 5c		 jne	 SHORT $LN4@Unpickler_@20
  00396	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0039a	a8 20		 test	 al, 32			; 00000020H
  0039c	75 4c		 jne	 SHORT $LN87@Unpickler_@20
  0039e	84 c0		 test	 al, al
  003a0	78 48		 js	 SHORT $LN87@Unpickler_@20
  003a2	a8 02		 test	 al, 2
  003a4	75 4c		 jne	 SHORT $LN4@Unpickler_@20
  003a6	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  003aa	75 46		 jne	 SHORT $LN4@Unpickler_@20
  003ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  003ba	4c 8b cf	 mov	 r9, rdi
  003bd	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  003c3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003cb	e8 00 00 00 00	 call	 _PyParallel_Guard
  003d0	48 8b cf	 mov	 rcx, rdi
  003d3	85 c0		 test	 eax, eax
  003d5	74 07		 je	 SHORT $LN92@Unpickler_@20
  003d7	e8 00 00 00 00	 call	 _Px_Dealloc
  003dc	eb 14		 jmp	 SHORT $LN4@Unpickler_@20
$LN92@Unpickler_@20:
  003de	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  003e2	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  003e8	eb 08		 jmp	 SHORT $LN4@Unpickler_@20
$LN87@Unpickler_@20:
  003ea	48 8b cf	 mov	 rcx, rdi
  003ed	e8 00 00 00 00	 call	 Px_DecRef
$LN4@Unpickler_@20:

; 5631 :     if (self->buffer.buf != NULL) {

  003f2	48 39 b3 88 00
	00 00		 cmp	 QWORD PTR [rbx+136], rsi
  003f9	74 13		 je	 SHORT $LN1@Unpickler_@20

; 5632 :         PyBuffer_Release(&self->buffer);

  003fb	48 8d 8b 88 00
	00 00		 lea	 rcx, QWORD PTR [rbx+136]
  00402	e8 00 00 00 00	 call	 PyBuffer_Release

; 5633 :         self->buffer.buf = NULL;

  00407	48 89 b3 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rsi
$LN1@Unpickler_@20:

; 5634 :     }
; 5635 : 
; 5636 :     _Unpickler_MemoCleanup(self);

  0040e	48 8b cb	 mov	 rcx, rbx
  00411	e8 00 00 00 00	 call	 _Unpickler_MemoCleanup

; 5637 :     PyMem_Free(self->marks);

  00416	48 8b 8b 28 01
	00 00		 mov	 rcx, QWORD PTR [rbx+296]
  0041d	e8 00 00 00 00	 call	 PyMem_Free

; 5638 :     self->marks = NULL;
; 5639 :     PyMem_Free(self->input_line);

  00422	48 8b 8b e0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+224]
  00429	48 89 b3 28 01
	00 00		 mov	 QWORD PTR [rbx+296], rsi
  00430	e8 00 00 00 00	 call	 PyMem_Free

; 5640 :     self->input_line = NULL;
; 5641 :     free(self->encoding);

  00435	48 8b 8b 18 01
	00 00		 mov	 rcx, QWORD PTR [rbx+280]
  0043c	48 89 b3 e0 00
	00 00		 mov	 QWORD PTR [rbx+224], rsi
  00443	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5642 :     self->encoding = NULL;
; 5643 :     free(self->errors);

  00449	48 8b 8b 20 01
	00 00		 mov	 rcx, QWORD PTR [rbx+288]
  00450	48 89 b3 18 01
	00 00		 mov	 QWORD PTR [rbx+280], rsi
  00457	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5644 :     self->errors = NULL;

  0045d	48 89 b3 20 01
	00 00		 mov	 QWORD PTR [rbx+288], rsi

; 5645 : 
; 5646 :     return 0;
; 5647 : }

  00464	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00469	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0046e	33 c0		 xor	 eax, eax
  00470	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00474	5f		 pop	 rdi
  00475	c3		 ret	 0
Unpickler_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@ECPOKLMD@O?$HMOss?3Unpickler?$AA@	; `string'
PUBLIC	??_C@_0DF@EKMCJKEL@?$CFs?5takes?5exactly?5one?5positional?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Unpickler_init DD imagerel Unpickler_init
	DD	imagerel Unpickler_init+263
	DD	imagerel $unwind$Unpickler_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$Unpickler_init DD imagerel Unpickler_init+263
	DD	imagerel Unpickler_init+337
	DD	imagerel $chain$0$Unpickler_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$Unpickler_init DD imagerel Unpickler_init+337
	DD	imagerel Unpickler_init+413
	DD	imagerel $chain$2$Unpickler_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$Unpickler_init DD 020021H
	DD	0c7400H
	DD	imagerel Unpickler_init
	DD	imagerel Unpickler_init+263
	DD	imagerel $unwind$Unpickler_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$Unpickler_init DD 020521H
	DD	0c7405H
	DD	imagerel Unpickler_init
	DD	imagerel Unpickler_init+263
	DD	imagerel $unwind$Unpickler_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_init DD 040a01H
	DD	0e340aH
	DD	06006920aH
xdata	ENDS
;	COMDAT ??_C@_0BA@ECPOKLMD@O?$HMOss?3Unpickler?$AA@
CONST	SEGMENT
??_C@_0BA@ECPOKLMD@O?$HMOss?3Unpickler?$AA@ DB 'O|Oss:Unpickler', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EKMCJKEL@?$CFs?5takes?5exactly?5one?5positional?5@
CONST	SEGMENT
??_C@_0DF@EKMCJKEL@?$CFs?5takes?5exactly?5one?5positional?5@ DB '%s takes'
	DB	' exactly one positional argument (%zd given)', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT Unpickler_init
_TEXT	SEGMENT
fix_imports$ = 64
file$ = 72
self$ = 96
errors$ = 104
args$ = 104
kwds$ = 112
encoding$ = 120
Unpickler_init PROC					; COMDAT

; 5674 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 5675 :     static char *kwlist[] = {"file", "fix_imports", "encoding", "errors", 0};
; 5676 :     PyObject *file;
; 5677 :     PyObject *fix_imports = Py_True;
; 5678 :     char *encoding = NULL;
; 5679 :     char *errors = NULL;
; 5680 :     _Py_IDENTIFIER(persistent_load);
; 5681 : 
; 5682 :     /* XXX: That is an horrible error message. But, I don't know how to do
; 5683 :        better... */
; 5684 :     if (Py_SIZE(args) != 1) {

  0000a	4c 8b 4a 60	 mov	 r9, QWORD PTR [rdx+96]
  0000e	33 f6		 xor	 esi, esi
  00010	48 8b d9	 mov	 rbx, rcx
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  0001a	4d 8b d0	 mov	 r10, r8
  0001d	48 8b c2	 mov	 rax, rdx
  00020	48 89 74 24 78	 mov	 QWORD PTR encoding$[rsp], rsi
  00025	48 89 74 24 68	 mov	 QWORD PTR errors$[rsp], rsi
  0002a	48 89 4c 24 40	 mov	 QWORD PTR fix_imports$[rsp], rcx
  0002f	49 83 f9 01	 cmp	 r9, 1
  00033	74 29		 je	 SHORT $LN11@Unpickler_@21

; 5685 :         PyErr_Format(PyExc_TypeError,
; 5686 :                      "%s takes exactly one positional argument (%zd given)",
; 5687 :                      Py_TYPE(self)->tp_name, Py_SIZE(args));

  00035	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@EKMCJKEL@?$CFs?5takes?5exactly?5one?5positional?5@
  00047	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0004b	e8 00 00 00 00	 call	 PyErr_Format
$LN16@Unpickler_@21:

; 5688 :         return -1;

  00050	83 c8 ff	 or	 eax, -1

; 5736 : 
; 5737 :     return 0;
; 5738 : }

  00053	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00058	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0005c	5e		 pop	 rsi
  0005d	c3		 ret	 0
$LN11@Unpickler_@21:

; 5689 :     }
; 5690 : 
; 5691 :     /* Arguments parsing needs to be done in the __init__() method to allow
; 5692 :        subclasses to define their own __init__() method, which may (or may
; 5693 :        not) support Unpickler arguments. However, this means we need to be
; 5694 :        extra careful in the other Unpickler methods, since a subclass could
; 5695 :        forget to call Unpickler.__init__() thus breaking our internal
; 5696 :        invariants. */
; 5697 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|Oss:Unpickler", kwlist,
; 5698 :                                      &file, &fix_imports, &encoding, &errors))

  0005e	48 8d 4c 24 68	 lea	 rcx, QWORD PTR errors$[rsp]
  00063	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??Unpickler_init@@9@9
  0006a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@ECPOKLMD@O?$HMOss?3Unpickler?$AA@
  00071	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00076	48 8d 4c 24 78	 lea	 rcx, QWORD PTR encoding$[rsp]
  0007b	49 8b d2	 mov	 rdx, r10
  0007e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00083	48 8d 4c 24 40	 lea	 rcx, QWORD PTR fix_imports$[rsp]
  00088	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0008d	48 8d 4c 24 48	 lea	 rcx, QWORD PTR file$[rsp]
  00092	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00097	48 8b c8	 mov	 rcx, rax
  0009a	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0009f	85 c0		 test	 eax, eax

; 5699 :         return -1;

  000a1	74 ad		 je	 SHORT $LN16@Unpickler_@21

; 5700 : 
; 5701 :     /* In case of multiple __init__() calls, clear previous content. */
; 5702 :     if (self->read != NULL)

  000a3	48 39 b3 00 01
	00 00		 cmp	 QWORD PTR [rbx+256], rsi
  000aa	74 08		 je	 SHORT $LN9@Unpickler_@21

; 5703 :         (void)Unpickler_clear(self);

  000ac	48 8b cb	 mov	 rcx, rbx
  000af	e8 00 00 00 00	 call	 Unpickler_clear
$LN9@Unpickler_@21:

; 5704 : 
; 5705 :     if (_Unpickler_SetInputStream(self, file) < 0)

  000b4	48 8b 54 24 48	 mov	 rdx, QWORD PTR file$[rsp]
  000b9	48 8b cb	 mov	 rcx, rbx
  000bc	e8 00 00 00 00	 call	 _Unpickler_SetInputStream
  000c1	85 c0		 test	 eax, eax

; 5706 :         return -1;

  000c3	78 8b		 js	 SHORT $LN16@Unpickler_@21

; 5707 : 
; 5708 :     if (_Unpickler_SetInputEncoding(self, encoding, errors) < 0)

  000c5	4c 8b 44 24 68	 mov	 r8, QWORD PTR errors$[rsp]
  000ca	48 8b 54 24 78	 mov	 rdx, QWORD PTR encoding$[rsp]
  000cf	48 8b cb	 mov	 rcx, rbx
  000d2	e8 00 00 00 00	 call	 _Unpickler_SetInputEncoding
  000d7	85 c0		 test	 eax, eax

; 5709 :         return -1;

  000d9	0f 88 71 ff ff
	ff		 js	 $LN16@Unpickler_@21

; 5710 : 
; 5711 :     self->fix_imports = PyObject_IsTrue(fix_imports);

  000df	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fix_imports$[rsp]
  000e4	e8 00 00 00 00	 call	 PyObject_IsTrue
  000e9	89 83 44 01 00
	00		 mov	 DWORD PTR [rbx+324], eax

; 5712 :     if (self->fix_imports == -1)

  000ef	83 f8 ff	 cmp	 eax, -1

; 5713 :         return -1;

  000f2	0f 84 58 ff ff
	ff		 je	 $LN16@Unpickler_@21

; 5714 : 
; 5715 :     if (_PyObject_HasAttrId((PyObject *)self, &PyId_persistent_load)) {

  000f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000fe	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00107	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  0010c	48 8b 3c c8	 mov	 rdi, QWORD PTR [rax+rcx*8]
  00110	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_persistent_load@?1??Unpickler_init@@9@9
  00115	48 8b cb	 mov	 rcx, rbx
  00118	48 03 fa	 add	 rdi, rdx
  0011b	48 8b d7	 mov	 rdx, rdi
  0011e	e8 00 00 00 00	 call	 _PyObject_HasAttrId
  00123	85 c0		 test	 eax, eax
  00125	74 2a		 je	 SHORT $LN5@Unpickler_@21

; 5716 :         self->pers_func = _PyObject_GetAttrId((PyObject *)self,
; 5717 :                                               &PyId_persistent_load);

  00127	48 8b d7	 mov	 rdx, rdi
  0012a	48 8b cb	 mov	 rcx, rbx
  0012d	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00132	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax

; 5718 :         if (self->pers_func == NULL)

  00139	48 85 c0	 test	 rax, rax
  0013c	75 1a		 jne	 SHORT $LN3@Unpickler_@21
$LN15@Unpickler_@21:

; 5719 :             return -1;

  0013e	83 c8 ff	 or	 eax, -1
  00141	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]

; 5736 : 
; 5737 :     return 0;
; 5738 : }

  00146	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0014b	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0014f	5e		 pop	 rsi
  00150	c3		 ret	 0
$LN5@Unpickler_@21:

; 5720 :     }
; 5721 :     else {
; 5722 :         self->pers_func = NULL;

  00151	48 89 b3 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rsi
$LN3@Unpickler_@21:

; 5723 :     }
; 5724 : 
; 5725 :     self->stack = (Pdata *)Pdata_New();

  00158	e8 00 00 00 00	 call	 Pdata_New
  0015d	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 5726 :     if (self->stack == NULL)

  00161	48 85 c0	 test	 rax, rax

; 5727 :         return -1;

  00164	74 d8		 je	 SHORT $LN15@Unpickler_@21

; 5728 : 
; 5729 :     self->memo_size = 32;
; 5730 :     self->memo = _Unpickler_NewMemo(self->memo_size);

  00166	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0016b	48 c7 43 70 20
	00 00 00	 mov	 QWORD PTR [rbx+112], 32	; 00000020H
  00173	e8 00 00 00 00	 call	 _Unpickler_NewMemo
  00178	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax

; 5731 :     if (self->memo == NULL)

  0017c	48 85 c0	 test	 rax, rax

; 5732 :         return -1;

  0017f	74 bd		 je	 SHORT $LN15@Unpickler_@21

; 5733 : 
; 5734 :     self->arg = NULL;

  00181	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00186	48 89 73 78	 mov	 QWORD PTR [rbx+120], rsi

; 5735 :     self->proto = 0;

  0018a	89 b3 40 01 00
	00		 mov	 DWORD PTR [rbx+320], esi

; 5736 : 
; 5737 :     return 0;
; 5738 : }

  00190	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00195	33 c0		 xor	 eax, eax
  00197	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0019b	5e		 pop	 rsi
  0019c	c3		 ret	 0
Unpickler_init ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ump_clear DD imagerel ump_clear
	DD	imagerel ump_clear+140
	DD	imagerel $unwind$ump_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ump_clear DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT ump_clear
_TEXT	SEGMENT
self$ = 64
ump_clear PROC						; COMDAT

; 5763 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 5764 :     _Unpickler_MemoCleanup(self->unpickler);

  00009	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0000d	e8 00 00 00 00	 call	 _Unpickler_MemoCleanup

; 5765 :     self->unpickler->memo = _Unpickler_NewMemo(self->unpickler->memo_size);

  00012	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00016	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0001a	e8 00 00 00 00	 call	 _Unpickler_NewMemo
  0001f	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  00023	48 89 42 68	 mov	 QWORD PTR [rdx+104], rax

; 5766 :     if (self->unpickler->memo == NULL)

  00027	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  0002b	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00030	75 08		 jne	 SHORT $LN1@ump_clear

; 5767 :         return NULL;

  00032	33 c0		 xor	 eax, eax

; 5769 : }

  00034	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
$LN1@ump_clear:

; 5768 :     Py_RETURN_NONE;

  0003a	e8 00 00 00 00	 call	 _Py_PXCTX
  0003f	85 c0		 test	 eax, eax
  00041	75 3c		 jne	 SHORT $LN5@ump_clear
  00043	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00058	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0005e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00066	e8 00 00 00 00	 call	 _PyParallel_Guard
  0006b	85 c0		 test	 eax, eax
  0006d	75 09		 jne	 SHORT $LN4@ump_clear
  0006f	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00076	74 07		 je	 SHORT $LN5@ump_clear
$LN4@ump_clear:
  00078	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@ump_clear:
  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 5769 : }

  00086	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008a	5b		 pop	 rbx
  0008b	c3		 ret	 0
ump_clear ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ump_copy DD imagerel ump_copy
	DD	imagerel ump_copy+43
	DD	imagerel $unwind$ump_copy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ump_copy DD imagerel ump_copy+43
	DD	imagerel ump_copy+166
	DD	imagerel $chain$2$ump_copy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ump_copy DD imagerel ump_copy+166
	DD	imagerel ump_copy+178
	DD	imagerel $chain$4$ump_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ump_copy DD 060021H
	DD	087400H
	DD	076400H
	DD	063400H
	DD	imagerel ump_copy
	DD	imagerel ump_copy+43
	DD	imagerel $unwind$ump_copy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ump_copy DD 060f21H
	DD	08740fH
	DD	07640aH
	DD	063405H
	DD	imagerel ump_copy
	DD	imagerel ump_copy+43
	DD	imagerel $unwind$ump_copy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ump_copy DD 040b01H
	DD	09540bH
	DD	0c007320bH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ump_copy
_TEXT	SEGMENT
self$ = 48
ump_copy PROC						; COMDAT

; 5776 : {

  00000	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00005	41 54		 push	 r12
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000b	48 8b e9	 mov	 rbp, rcx

; 5777 :     Py_ssize_t i;
; 5778 :     PyObject *new_memo = PyDict_New();

  0000e	e8 00 00 00 00	 call	 PyDict_New
  00013	4c 8b e0	 mov	 r12, rax

; 5779 :     if (new_memo == NULL)

  00016	48 85 c0	 test	 rax, rax
  00019	75 0c		 jne	 SHORT $LN7@ump_copy

; 5803 : }

  0001b	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	41 5c		 pop	 r12
  00026	c3		 ret	 0
$LN7@ump_copy:

; 5780 :         return NULL;
; 5781 : 
; 5782 :     for (i = 0; i < self->unpickler->memo_size; i++) {

  00027	48 8b 45 60	 mov	 rax, QWORD PTR [rbp+96]
  0002b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00030	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00035	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0003a	33 ff		 xor	 edi, edi
  0003c	48 39 78 70	 cmp	 QWORD PTR [rax+112], rdi
  00040	7e 46		 jle	 SHORT $LN14@ump_copy
$LL6@ump_copy:

; 5783 :         int status;
; 5784 :         PyObject *key, *value;
; 5785 : 
; 5786 :         value = self->unpickler->memo[i];

  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 8b 1c f8	 mov	 rbx, QWORD PTR [rax+rdi*8]

; 5787 :         if (value == NULL)

  0004a	48 85 db	 test	 rbx, rbx
  0004d	74 2c		 je	 SHORT $LN5@ump_copy

; 5788 :             continue;
; 5789 : 
; 5790 :         key = PyLong_FromSsize_t(i);

  0004f	48 8b cf	 mov	 rcx, rdi
  00052	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00057	48 8b f0	 mov	 rsi, rax

; 5791 :         if (key == NULL)

  0005a	48 85 c0	 test	 rax, rax
  0005d	74 47		 je	 SHORT $error$24693

; 5792 :             goto error;
; 5793 :         status = PyDict_SetItem(new_memo, key, value);

  0005f	4c 8b c3	 mov	 r8, rbx
  00062	48 8b d0	 mov	 rdx, rax
  00065	49 8b cc	 mov	 rcx, r12
  00068	e8 00 00 00 00	 call	 PyDict_SetItem

; 5794 :         Py_DECREF(key);

  0006d	48 8b ce	 mov	 rcx, rsi
  00070	8b d8		 mov	 ebx, eax
  00072	e8 00 00 00 00	 call	 _Py_DecRef

; 5795 :         if (status < 0)

  00077	85 db		 test	 ebx, ebx
  00079	78 2b		 js	 SHORT $error$24693
$LN5@ump_copy:

; 5780 :         return NULL;
; 5781 : 
; 5782 :     for (i = 0; i < self->unpickler->memo_size; i++) {

  0007b	48 8b 45 60	 mov	 rax, QWORD PTR [rbp+96]
  0007f	48 ff c7	 inc	 rdi
  00082	48 3b 78 70	 cmp	 rdi, QWORD PTR [rax+112]
  00086	7c ba		 jl	 SHORT $LL6@ump_copy
$LN14@ump_copy:

; 5796 :             goto error;
; 5797 :     }
; 5798 :     return new_memo;

  00088	49 8b c4	 mov	 rax, r12
$LN17@ump_copy:
  0008b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00090	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00095	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 5803 : }

  0009a	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0009f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a3	41 5c		 pop	 r12
  000a5	c3		 ret	 0
$error$24693:

; 5799 : 
; 5800 : error:
; 5801 :     Py_DECREF(new_memo);

  000a6	49 8b cc	 mov	 rcx, r12
  000a9	e8 00 00 00 00	 call	 _Py_DecRef

; 5802 :     return NULL;

  000ae	33 c0		 xor	 eax, eax
  000b0	eb d9		 jmp	 SHORT $LN17@ump_copy
ump_copy ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ump_reduce DD imagerel ump_reduce
	DD	imagerel ump_reduce+30
	DD	imagerel $unwind$ump_reduce
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ump_reduce DD imagerel ump_reduce+30
	DD	imagerel ump_reduce+69
	DD	imagerel $chain$0$ump_reduce
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ump_reduce DD imagerel ump_reduce+69
	DD	imagerel ump_reduce+126
	DD	imagerel $chain$3$ump_reduce
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$ump_reduce DD imagerel ump_reduce+126
	DD	imagerel ump_reduce+229
	DD	imagerel $chain$5$ump_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$ump_reduce DD 040021H
	DD	096400H
	DD	083400H
	DD	imagerel ump_reduce
	DD	imagerel ump_reduce+30
	DD	imagerel $unwind$ump_reduce
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ump_reduce DD 040a21H
	DD	09640aH
	DD	083400H
	DD	imagerel ump_reduce
	DD	imagerel ump_reduce+30
	DD	imagerel $unwind$ump_reduce
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ump_reduce DD 020521H
	DD	083405H
	DD	imagerel ump_reduce
	DD	imagerel ump_reduce+30
	DD	imagerel $unwind$ump_reduce
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ump_reduce DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT ump_reduce
_TEXT	SEGMENT
self$ = 64
args$ = 72
ump_reduce PROC						; COMDAT

; 5810 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 5811 :     PyObject *reduce_value;
; 5812 :     PyObject *constructor_args;
; 5813 :     PyObject *contents = ump_copy(self);

  00006	e8 00 00 00 00	 call	 ump_copy
  0000b	48 8b f8	 mov	 rdi, rax

; 5814 :     if (contents == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 06		 jne	 SHORT $LN3@ump_reduce

; 5833 : }

  00013	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00017	5f		 pop	 rdi
  00018	c3		 ret	 0
$LN3@ump_reduce:

; 5815 :         return NULL;
; 5816 : 
; 5817 :     reduce_value = PyTuple_New(2);

  00019	b9 02 00 00 00	 mov	 ecx, 2
  0001e	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00023	e8 00 00 00 00	 call	 PyTuple_New
  00028	48 8b d8	 mov	 rbx, rax

; 5818 :     if (reduce_value == NULL) {

  0002b	48 85 c0	 test	 rax, rax
  0002e	75 15		 jne	 SHORT $LN2@ump_reduce

; 5819 :         Py_DECREF(contents);

  00030	48 8b cf	 mov	 rcx, rdi
  00033	e8 00 00 00 00	 call	 _Py_DecRef
  00038	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 5820 :         return NULL;

  0003d	33 c0		 xor	 eax, eax

; 5833 : }

  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
$LN2@ump_reduce:

; 5821 :     }
; 5822 :     constructor_args = PyTuple_New(1);

  00045	b9 01 00 00 00	 mov	 ecx, 1
  0004a	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  0004f	e8 00 00 00 00	 call	 PyTuple_New
  00054	48 8b f0	 mov	 rsi, rax

; 5823 :     if (constructor_args == NULL) {

  00057	48 85 c0	 test	 rax, rax
  0005a	75 22		 jne	 SHORT $LN1@ump_reduce

; 5824 :         Py_DECREF(contents);

  0005c	48 8b cf	 mov	 rcx, rdi
  0005f	e8 00 00 00 00	 call	 _Py_DecRef

; 5825 :         Py_DECREF(reduce_value);

  00064	48 8b cb	 mov	 rcx, rbx
  00067	e8 00 00 00 00	 call	 _Py_DecRef
  0006c	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00071	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 5826 :         return NULL;

  00076	33 c0		 xor	 eax, eax

; 5833 : }

  00078	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007c	5f		 pop	 rdi
  0007d	c3		 ret	 0
$LN1@ump_reduce:

; 5827 :     }
; 5828 :     PyTuple_SET_ITEM(constructor_args, 0, contents);

  0007e	48 89 78 70	 mov	 QWORD PTR [rax+112], rdi

; 5829 :     Py_INCREF((PyObject *)&PyDict_Type);

  00082	e8 00 00 00 00	 call	 _Py_PXCTX
  00087	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:PyDict_Type
  0008e	85 c0		 test	 eax, eax
  00090	75 38		 jne	 SHORT $LN7@ump_reduce
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000a0	4c 8b cf	 mov	 r9, rdi
  000a3	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b1	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b6	85 c0		 test	 eax, eax
  000b8	75 09		 jne	 SHORT $LN6@ump_reduce
  000ba	f6 05 20 00 00
	00 20		 test	 BYTE PTR PyDict_Type+32, 32 ; 00000020H
  000c1	74 07		 je	 SHORT $LN7@ump_reduce
$LN6@ump_reduce:
  000c3	48 ff 05 50 00
	00 00		 inc	 QWORD PTR PyDict_Type+80
$LN7@ump_reduce:

; 5830 :     PyTuple_SET_ITEM(reduce_value, 0, (PyObject *)&PyDict_Type);
; 5831 :     PyTuple_SET_ITEM(reduce_value, 1, constructor_args);

  000ca	48 89 73 78	 mov	 QWORD PTR [rbx+120], rsi
  000ce	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000d3	48 89 7b 70	 mov	 QWORD PTR [rbx+112], rdi

; 5832 :     return reduce_value;

  000d7	48 8b c3	 mov	 rax, rbx
  000da	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 5833 : }

  000df	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e3	5f		 pop	 rdi
  000e4	c3		 ret	 0
ump_reduce ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$UnpicklerMemoProxy_dealloc DD imagerel UnpicklerMemoProxy_dealloc
	DD	imagerel UnpicklerMemoProxy_dealloc+182
	DD	imagerel $unwind$UnpicklerMemoProxy_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnpicklerMemoProxy_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT UnpicklerMemoProxy_dealloc
_TEXT	SEGMENT
self$ = 64
UnpicklerMemoProxy_dealloc PROC				; COMDAT

; 5844 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 5845 :     PyObject_GC_UnTrack(self);

  0000d	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 5846 :     Py_XDECREF(self->unpickler);

  00012	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  00016	48 85 db	 test	 rbx, rbx
  00019	0f 84 85 00 00
	00		 je	 $LN3@UnpicklerM
  0001f	e8 00 00 00 00	 call	 _Py_PXCTX
  00024	85 c0		 test	 eax, eax
  00026	75 7c		 jne	 SHORT $LN3@UnpicklerM
  00028	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0002c	a8 20		 test	 al, 32			; 00000020H
  0002e	75 6c		 jne	 SHORT $LN11@UnpicklerM
  00030	84 c0		 test	 al, al
  00032	78 68		 js	 SHORT $LN11@UnpicklerM
  00034	a8 02		 test	 al, 2
  00036	75 6c		 jne	 SHORT $LN3@UnpicklerM
  00038	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0003c	75 66		 jne	 SHORT $LN3@UnpicklerM
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0004c	4c 8b cb	 mov	 r9, rbx
  0004f	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00055	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0005d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00062	48 8b cb	 mov	 rcx, rbx
  00065	85 c0		 test	 eax, eax
  00067	74 17		 je	 SHORT $LN16@UnpicklerM
  00069	e8 00 00 00 00	 call	 _Px_Dealloc

; 5847 :     PyObject_GC_Del((PyObject *)self);

  0006e	48 8b cf	 mov	 rcx, rdi

; 5848 : }

  00071	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00076	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007a	5f		 pop	 rdi
  0007b	e9 00 00 00 00	 jmp	 PyObject_GC_Del

; 5846 :     Py_XDECREF(self->unpickler);

$LN16@UnpicklerM:
  00080	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00084	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 5847 :     PyObject_GC_Del((PyObject *)self);

  0008a	48 8b cf	 mov	 rcx, rdi

; 5848 : }

  0008d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00092	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00096	5f		 pop	 rdi
  00097	e9 00 00 00 00	 jmp	 PyObject_GC_Del

; 5846 :     Py_XDECREF(self->unpickler);

$LN11@UnpicklerM:
  0009c	48 8b cb	 mov	 rcx, rbx
  0009f	e8 00 00 00 00	 call	 Px_DecRef
$LN3@UnpicklerM:

; 5847 :     PyObject_GC_Del((PyObject *)self);

  000a4	48 8b cf	 mov	 rcx, rdi

; 5848 : }

  000a7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b0	5f		 pop	 rdi
  000b1	e9 00 00 00 00	 jmp	 PyObject_GC_Del
UnpicklerMemoProxy_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@DBEGFKPC@UnpicklerMemoProxy_traverse?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$UnpicklerMemoProxy_traverse DD imagerel UnpicklerMemoProxy_traverse
	DD	imagerel UnpicklerMemoProxy_traverse+97
	DD	imagerel $unwind$UnpicklerMemoProxy_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnpicklerMemoProxy_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BM@DBEGFKPC@UnpicklerMemoProxy_traverse?$AA@
CONST	SEGMENT
??_C@_0BM@DBEGFKPC@UnpicklerMemoProxy_traverse?$AA@ DB 'UnpicklerMemoProx'
	DB	'y_traverse', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT UnpicklerMemoProxy_traverse
_TEXT	SEGMENT
self$ = 48
visit$ = 56
arg$ = 64
UnpicklerMemoProxy_traverse PROC			; COMDAT

; 5853 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 5854 :     Py_VISIT(self->unpickler);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN3@UnpicklerM@2
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@DBEGFKPC@UnpicklerMemoProxy_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 de 16 00
	00		 mov	 r8d, 5854		; 000016deH
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@UnpicklerM@2:
  0003d	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00041	48 85 c9	 test	 rcx, rcx
  00044	74 09		 je	 SHORT $LN5@UnpicklerM@2
  00046	48 8b d7	 mov	 rdx, rdi
  00049	ff d6		 call	 rsi
  0004b	85 c0		 test	 eax, eax
  0004d	75 02		 jne	 SHORT $LN7@UnpicklerM@2
$LN5@UnpicklerM@2:

; 5855 :     return 0;

  0004f	33 c0		 xor	 eax, eax
$LN7@UnpicklerM@2:

; 5856 : }

  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
UnpicklerMemoProxy_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@JPBDBIDH@UnpicklerMemoProxy_clear?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$UnpicklerMemoProxy_clear DD imagerel UnpicklerMemoProxy_clear
	DD	imagerel UnpicklerMemoProxy_clear+63
	DD	imagerel $unwind$UnpicklerMemoProxy_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$UnpicklerMemoProxy_clear DD imagerel UnpicklerMemoProxy_clear+63
	DD	imagerel UnpicklerMemoProxy_clear+172
	DD	imagerel $chain$0$UnpicklerMemoProxy_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$UnpicklerMemoProxy_clear DD imagerel UnpicklerMemoProxy_clear+172
	DD	imagerel UnpicklerMemoProxy_clear+195
	DD	imagerel $chain$2$UnpicklerMemoProxy_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$UnpicklerMemoProxy_clear DD imagerel UnpicklerMemoProxy_clear+195
	DD	imagerel UnpicklerMemoProxy_clear+208
	DD	imagerel $chain$4$UnpicklerMemoProxy_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$UnpicklerMemoProxy_clear DD imagerel UnpicklerMemoProxy_clear+208
	DD	imagerel UnpicklerMemoProxy_clear+216
	DD	imagerel $chain$5$UnpicklerMemoProxy_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$UnpicklerMemoProxy_clear DD 021H
	DD	imagerel UnpicklerMemoProxy_clear
	DD	imagerel UnpicklerMemoProxy_clear+63
	DD	imagerel $unwind$UnpicklerMemoProxy_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$UnpicklerMemoProxy_clear DD 020021H
	DD	083400H
	DD	imagerel UnpicklerMemoProxy_clear
	DD	imagerel UnpicklerMemoProxy_clear+63
	DD	imagerel $unwind$UnpicklerMemoProxy_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$UnpicklerMemoProxy_clear DD 020021H
	DD	083400H
	DD	imagerel UnpicklerMemoProxy_clear
	DD	imagerel UnpicklerMemoProxy_clear+63
	DD	imagerel $unwind$UnpicklerMemoProxy_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$UnpicklerMemoProxy_clear DD 020521H
	DD	083405H
	DD	imagerel UnpicklerMemoProxy_clear
	DD	imagerel UnpicklerMemoProxy_clear+63
	DD	imagerel $unwind$UnpicklerMemoProxy_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnpicklerMemoProxy_clear DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_0BJ@JPBDBIDH@UnpicklerMemoProxy_clear?$AA@
CONST	SEGMENT
??_C@_0BJ@JPBDBIDH@UnpicklerMemoProxy_clear?$AA@ DB 'UnpicklerMemoProxy_c'
	DB	'lear', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT UnpicklerMemoProxy_clear
_TEXT	SEGMENT
self$ = 64
UnpicklerMemoProxy_clear PROC				; COMDAT

; 5860 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 5861 :     Py_CLEAR(self->unpickler);

  00006	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	4d 85 c9	 test	 r9, r9
  00010	0f 84 ba 00 00
	00		 je	 $LN21@UnpicklerM@3
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@JPBDBIDH@UnpicklerMemoProxy_clear?$AA@
  00024	41 b8 e5 16 00
	00		 mov	 r8d, 5861		; 000016e5H
  0002a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00032	e8 00 00 00 00	 call	 _PyParallel_Guard
  00037	85 c0		 test	 eax, eax
  00039	0f 85 91 00 00
	00		 jne	 $LN21@UnpicklerM@3
  0003f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00044	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  00048	48 c7 47 60 00
	00 00 00	 mov	 QWORD PTR [rdi+96], 0
  00050	e8 00 00 00 00	 call	 _Py_PXCTX
  00055	85 c0		 test	 eax, eax
  00057	75 72		 jne	 SHORT $LN22@UnpicklerM@3
  00059	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0005d	a8 20		 test	 al, 32			; 00000020H
  0005f	75 62		 jne	 SHORT $LN11@UnpicklerM@3
  00061	84 c0		 test	 al, al
  00063	78 5e		 js	 SHORT $LN11@UnpicklerM@3
  00065	a8 02		 test	 al, 2
  00067	75 62		 jne	 SHORT $LN22@UnpicklerM@3
  00069	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0006d	75 5c		 jne	 SHORT $LN22@UnpicklerM@3
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0007d	4c 8b cb	 mov	 r9, rbx
  00080	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00086	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0008e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00093	48 8b cb	 mov	 rcx, rbx
  00096	85 c0		 test	 eax, eax
  00098	74 12		 je	 SHORT $LN16@UnpicklerM@3
  0009a	e8 00 00 00 00	 call	 _Px_Dealloc
  0009f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 5862 :     return 0;

  000a4	33 c0		 xor	 eax, eax

; 5863 : }

  000a6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0

; 5861 :     Py_CLEAR(self->unpickler);

$LN16@UnpicklerM@3:
  000ac	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000b0	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000b6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 5862 :     return 0;

  000bb	33 c0		 xor	 eax, eax

; 5863 : }

  000bd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0

; 5861 :     Py_CLEAR(self->unpickler);

$LN11@UnpicklerM@3:
  000c3	48 8b cb	 mov	 rcx, rbx
  000c6	e8 00 00 00 00	 call	 Px_DecRef
$LN22@UnpicklerM@3:
  000cb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN21@UnpicklerM@3:

; 5862 :     return 0;

  000d0	33 c0		 xor	 eax, eax

; 5863 : }

  000d2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d6	5f		 pop	 rdi
  000d7	c3		 ret	 0
UnpicklerMemoProxy_clear ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$UnpicklerMemoProxy_New DD imagerel UnpicklerMemoProxy_New
	DD	imagerel UnpicklerMemoProxy_New+145
	DD	imagerel $unwind$UnpicklerMemoProxy_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnpicklerMemoProxy_New DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT UnpicklerMemoProxy_New
_TEXT	SEGMENT
unpickler$ = 64
UnpicklerMemoProxy_New PROC				; COMDAT

; 5898 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 5899 :     UnpicklerMemoProxyObject *self;
; 5900 : 
; 5901 :     self = PyObject_GC_New(UnpicklerMemoProxyObject,
; 5902 :                            &UnpicklerMemoProxyType);

  0000d	e8 00 00 00 00	 call	 _Py_PXCTX
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UnpicklerMemoProxyType
  00019	85 c0		 test	 eax, eax
  0001b	74 07		 je	 SHORT $LN4@UnpicklerM@4
  0001d	e8 00 00 00 00	 call	 _PxObject_New
  00022	eb 05		 jmp	 SHORT $LN10@UnpicklerM@4
$LN4@UnpicklerM@4:
  00024	e8 00 00 00 00	 call	 _PyObject_GC_New
$LN10@UnpicklerM@4:
  00029	48 8b d8	 mov	 rbx, rax

; 5903 :     if (self == NULL)

  0002c	48 85 c0	 test	 rax, rax
  0002f	75 0b		 jne	 SHORT $LN1@UnpicklerM@4

; 5909 : }

  00031	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00036	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
$LN1@UnpicklerM@4:

; 5904 :         return NULL;
; 5905 :     Py_INCREF(unpickler);

  0003c	e8 00 00 00 00	 call	 _Py_PXCTX
  00041	85 c0		 test	 eax, eax
  00043	75 32		 jne	 SHORT $LN7@UnpicklerM@4
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00053	4c 8b cf	 mov	 r9, rdi
  00056	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0005c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00064	e8 00 00 00 00	 call	 _PyParallel_Guard
  00069	85 c0		 test	 eax, eax
  0006b	75 06		 jne	 SHORT $LN6@UnpicklerM@4
  0006d	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00071	74 04		 je	 SHORT $LN7@UnpicklerM@4
$LN6@UnpicklerM@4:
  00073	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN7@UnpicklerM@4:

; 5906 :     self->unpickler = unpickler;
; 5907 :     PyObject_GC_Track(self);

  00077	48 8b cb	 mov	 rcx, rbx
  0007a	48 89 7b 60	 mov	 QWORD PTR [rbx+96], rdi
  0007e	e8 00 00 00 00	 call	 PyObject_GC_Track

; 5908 :     return (PyObject *)self;

  00083	48 8b c3	 mov	 rax, rbx

; 5909 : }

  00086	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0008b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008f	5f		 pop	 rdi
  00090	c3		 ret	 0
UnpicklerMemoProxy_New ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT Unpickler_get_memo
_TEXT	SEGMENT
self$ = 8
Unpickler_get_memo PROC					; COMDAT

; 5917 :     return UnpicklerMemoProxy_New(self);
; 5918 : }

  00000	e9 00 00 00 00	 jmp	 UnpicklerMemoProxy_New
Unpickler_get_memo ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EJ@JNONLCFC@?8memo?8?5attribute?5must?5be?5an?5Unpi@ ; `string'
PUBLIC	??_C@_0BK@DHOABPGF@memo?5key?5must?5be?5integers?$AA@ ; `string'
PUBLIC	??_C@_0CE@EFMIHDJD@memo?5key?5must?5be?5positive?5intege@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$Unpickler_set_memo DD imagerel Unpickler_set_memo
	DD	imagerel Unpickler_set_memo+584
	DD	imagerel $unwind$Unpickler_set_memo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_set_memo DD 0b5001H
	DD	06c450H
	DD	07744bH
	DD	08543fH
	DD	0c343aH
	DD	0d0048208H
	DD	06002H
xdata	ENDS
;	COMDAT ??_C@_0EJ@JNONLCFC@?8memo?8?5attribute?5must?5be?5an?5Unpi@
CONST	SEGMENT
??_C@_0EJ@JNONLCFC@?8memo?8?5attribute?5must?5be?5an?5Unpi@ DB '''memo'' '
	DB	'attribute must be an UnpicklerMemoProxy objector dict, not %.'
	DB	'200s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DHOABPGF@memo?5key?5must?5be?5integers?$AA@
CONST	SEGMENT
??_C@_0BK@DHOABPGF@memo?5key?5must?5be?5integers?$AA@ DB 'memo key must b'
	DB	'e integers', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EFMIHDJD@memo?5key?5must?5be?5positive?5intege@
CONST	SEGMENT
??_C@_0CE@EFMIHDJD@memo?5key?5must?5be?5positive?5intege@ DB 'memo key mu'
	DB	'st be positive integers.', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT Unpickler_set_memo
_TEXT	SEGMENT
self$ = 96
value$24837 = 104
obj$ = 104
key$24836 = 112
i$24835 = 120
Unpickler_set_memo PROC					; COMDAT

; 5922 : {

  00000	40 56		 push	 rsi
  00002	41 55		 push	 r13
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00008	48 8b f2	 mov	 rsi, rdx
  0000b	4c 8b e9	 mov	 r13, rcx

; 5923 :     PyObject **new_memo;
; 5924 :     Py_ssize_t new_memo_size = 0;
; 5925 :     Py_ssize_t i;
; 5926 : 
; 5927 :     if (obj == NULL) {

  0000e	48 85 d2	 test	 rdx, rdx
  00011	75 1e		 jne	 SHORT $LN27@Unpickler_@22

; 5928 :         PyErr_SetString(PyExc_TypeError,
; 5929 :                         "attribute deletion is not supported");

  00013	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KNPPJDNH@attribute?5deletion?5is?5not?5suppor@
  00021	e8 00 00 00 00	 call	 PyErr_SetString

; 5930 :         return -1;

  00026	83 c8 ff	 or	 eax, -1

; 5997 : }

  00029	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0002d	41 5d		 pop	 r13
  0002f	5e		 pop	 rsi
  00030	c3		 ret	 0
$LN27@Unpickler_@22:

; 5931 :     }
; 5932 : 
; 5933 :     if (Py_TYPE(obj) == &UnpicklerMemoProxyType) {

  00031	4c 8b 42 58	 mov	 r8, QWORD PTR [rdx+88]
  00035	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  0003a	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:UnpicklerMemoProxyType
  00046	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0004b	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  00050	4c 3b c0	 cmp	 r8, rax
  00053	0f 85 a0 00 00
	00		 jne	 $LN26@Unpickler_@22

; 5934 :         UnpicklerObject *unpickler =
; 5935 :             ((UnpicklerMemoProxyObject *)obj)->unpickler;

  00059	4c 8b 62 60	 mov	 r12, QWORD PTR [rdx+96]

; 5936 : 
; 5937 :         new_memo_size = unpickler->memo_size;

  0005d	49 8b 6c 24 70	 mov	 rbp, QWORD PTR [r12+112]

; 5938 :         new_memo = _Unpickler_NewMemo(new_memo_size);

  00062	48 8b cd	 mov	 rcx, rbp
  00065	e8 00 00 00 00	 call	 _Unpickler_NewMemo
  0006a	48 8b f8	 mov	 rdi, rax

; 5939 :         if (new_memo == NULL)

  0006d	48 85 c0	 test	 rax, rax

; 5940 :             return -1;

  00070	0f 84 b3 01 00
	00		 je	 $LN50@Unpickler_@22

; 5941 : 
; 5942 :         for (i = 0; i < new_memo_size; i++) {

  00076	33 db		 xor	 ebx, ebx
  00078	48 85 ed	 test	 rbp, rbp
  0007b	7e 65		 jle	 SHORT $LN13@Unpickler_@22
  0007d	0f 1f 00	 npad	 3
$LL24@Unpickler_@22:
  00080	49 8b 74 24 68	 mov	 rsi, QWORD PTR [r12+104]

; 5943 :             Py_XINCREF(unpickler->memo[i]);

  00085	48 83 3c de 00	 cmp	 QWORD PTR [rsi+rbx*8], 0
  0008a	74 3f		 je	 SHORT $LN20@Unpickler_@22
  0008c	48 8b 34 de	 mov	 rsi, QWORD PTR [rsi+rbx*8]
  00090	e8 00 00 00 00	 call	 _Py_PXCTX
  00095	85 c0		 test	 eax, eax
  00097	75 32		 jne	 SHORT $LN20@Unpickler_@22
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000a7	4c 8b ce	 mov	 r9, rsi
  000aa	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000b0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000bd	85 c0		 test	 eax, eax
  000bf	75 06		 jne	 SHORT $LN32@Unpickler_@22
  000c1	f6 46 20 20	 test	 BYTE PTR [rsi+32], 32	; 00000020H
  000c5	74 04		 je	 SHORT $LN20@Unpickler_@22
$LN32@Unpickler_@22:
  000c7	48 ff 46 50	 inc	 QWORD PTR [rsi+80]
$LN20@Unpickler_@22:

; 5944 :             new_memo[i] = unpickler->memo[i];

  000cb	49 8b 44 24 68	 mov	 rax, QWORD PTR [r12+104]
  000d0	48 ff c3	 inc	 rbx
  000d3	48 8b 4c d8 f8	 mov	 rcx, QWORD PTR [rax+rbx*8-8]
  000d8	48 89 4c df f8	 mov	 QWORD PTR [rdi+rbx*8-8], rcx
  000dd	48 3b dd	 cmp	 rbx, rbp
  000e0	7c 9e		 jl	 SHORT $LL24@Unpickler_@22
$LN13@Unpickler_@22:

; 5980 :     }
; 5981 : 
; 5982 :     _Unpickler_MemoCleanup(self);

  000e2	49 8b cd	 mov	 rcx, r13
  000e5	e8 00 00 00 00	 call	 _Unpickler_MemoCleanup

; 5983 :     self->memo_size = new_memo_size;

  000ea	49 89 6d 70	 mov	 QWORD PTR [r13+112], rbp

; 5984 :     self->memo = new_memo;

  000ee	49 89 7d 68	 mov	 QWORD PTR [r13+104], rdi

; 5985 : 
; 5986 :     return 0;

  000f2	33 c0		 xor	 eax, eax
  000f4	e9 33 01 00 00	 jmp	 $LN49@Unpickler_@22
$LN26@Unpickler_@22:

; 5945 :         }
; 5946 :     }
; 5947 :     else if (PyDict_Check(obj)) {

  000f9	41 f7 80 00 01
	00 00 00 00 00
	20		 test	 DWORD PTR [r8+256], 536870912 ; 20000000H
  00104	0f 84 08 01 00
	00		 je	 $LN16@Unpickler_@22

; 5948 :         Py_ssize_t i = 0;

  0010a	33 db		 xor	 ebx, ebx

; 5949 :         PyObject *key, *value;
; 5950 : 
; 5951 :         new_memo_size = PyDict_Size(obj);

  0010c	48 8b ca	 mov	 rcx, rdx
  0010f	48 89 5c 24 78	 mov	 QWORD PTR i$24835[rsp], rbx
  00114	e8 00 00 00 00	 call	 PyDict_Size

; 5952 :         new_memo = _Unpickler_NewMemo(new_memo_size);

  00119	48 8b c8	 mov	 rcx, rax
  0011c	48 8b e8	 mov	 rbp, rax
  0011f	e8 00 00 00 00	 call	 _Unpickler_NewMemo
  00124	48 8b f8	 mov	 rdi, rax

; 5953 :         if (new_memo == NULL)

  00127	48 85 c0	 test	 rax, rax

; 5954 :             return -1;

  0012a	0f 84 f9 00 00
	00		 je	 $LN50@Unpickler_@22

; 5955 : 
; 5956 :         while (PyDict_Next(obj, &i, &key, &value)) {

  00130	4c 8d 4c 24 68	 lea	 r9, QWORD PTR value$24837[rsp]
  00135	4c 8d 44 24 70	 lea	 r8, QWORD PTR key$24836[rsp]
  0013a	48 8d 54 24 78	 lea	 rdx, QWORD PTR i$24835[rsp]
  0013f	48 8b ce	 mov	 rcx, rsi
  00142	e8 00 00 00 00	 call	 PyDict_Next
  00147	85 c0		 test	 eax, eax
  00149	74 97		 je	 SHORT $LN13@Unpickler_@22
  0014b	0f 1f 44 00 00	 npad	 5
$LL14@Unpickler_@22:

; 5957 :             Py_ssize_t idx;
; 5958 :             if (!PyLong_Check(key)) {

  00150	48 8b 4c 24 70	 mov	 rcx, QWORD PTR key$24836[rsp]
  00155	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00159	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00163	74 5e		 je	 SHORT $LN39@Unpickler_@22

; 5961 :                 goto error;
; 5962 :             }
; 5963 :             idx = PyLong_AsSsize_t(key);

  00165	e8 00 00 00 00	 call	 PyLong_AsSsize_t

; 5964 :             if (idx == -1 && PyErr_Occurred())

  0016a	48 83 f8 ff	 cmp	 rax, -1
  0016e	74 39		 je	 SHORT $LN44@Unpickler_@22

; 5965 :                 goto error;
; 5966 :             if (idx < 0) {

  00170	48 85 c0	 test	 rax, rax
  00173	78 3e		 js	 SHORT $LN41@Unpickler_@22

; 5969 :                 goto error;
; 5970 :             }
; 5971 :             if (_Unpickler_MemoPut(self, idx, value) < 0)

  00175	4c 8b 44 24 68	 mov	 r8, QWORD PTR value$24837[rsp]
  0017a	48 8b d0	 mov	 rdx, rax
  0017d	49 8b cd	 mov	 rcx, r13
  00180	e8 00 00 00 00	 call	 _Unpickler_MemoPut
  00185	85 c0		 test	 eax, eax
  00187	78 4d		 js	 SHORT $error$24847

; 5955 : 
; 5956 :         while (PyDict_Next(obj, &i, &key, &value)) {

  00189	4c 8d 4c 24 68	 lea	 r9, QWORD PTR value$24837[rsp]
  0018e	4c 8d 44 24 70	 lea	 r8, QWORD PTR key$24836[rsp]
  00193	48 8d 54 24 78	 lea	 rdx, QWORD PTR i$24835[rsp]
  00198	48 8b ce	 mov	 rcx, rsi
  0019b	e8 00 00 00 00	 call	 PyDict_Next
  001a0	85 c0		 test	 eax, eax
  001a2	75 ac		 jne	 SHORT $LL14@Unpickler_@22
  001a4	e9 39 ff ff ff	 jmp	 $LN13@Unpickler_@22
$LN44@Unpickler_@22:

; 5964 :             if (idx == -1 && PyErr_Occurred())

  001a9	e8 00 00 00 00	 call	 PyErr_Occurred
  001ae	48 85 c0	 test	 rax, rax
  001b1	75 23		 jne	 SHORT $error$24847
$LN41@Unpickler_@22:

; 5967 :                 PyErr_SetString(PyExc_ValueError,
; 5968 :                                 "memo key must be positive integers.");

  001b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@EFMIHDJD@memo?5key?5must?5be?5positive?5intege@
  001c1	eb 0e		 jmp	 SHORT $LN51@Unpickler_@22
$LN39@Unpickler_@22:

; 5959 :                 PyErr_SetString(PyExc_TypeError,
; 5960 :                                 "memo key must be integers");

  001c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@DHOABPGF@memo?5key?5must?5be?5integers?$AA@
$LN51@Unpickler_@22:
  001d1	e8 00 00 00 00	 call	 PyErr_SetString
$error$24847:

; 5987 : 
; 5988 :   error:
; 5989 :     if (new_memo_size) {

  001d6	48 85 ed	 test	 rbp, rbp
  001d9	74 4e		 je	 SHORT $LN50@Unpickler_@22

; 5990 :         i = new_memo_size;
; 5991 :         while (--i >= 0) {

  001db	48 8d 5d ff	 lea	 rbx, QWORD PTR [rbp-1]
  001df	48 85 db	 test	 rbx, rbx
  001e2	78 13		 js	 SHORT $LN5@Unpickler_@22
$LL6@Unpickler_@22:
  001e4	48 8b 0c df	 mov	 rcx, QWORD PTR [rdi+rbx*8]

; 5992 :             Py_XDECREF(new_memo[i]);

  001e8	48 85 c9	 test	 rcx, rcx
  001eb	74 05		 je	 SHORT $LN3@Unpickler_@22
  001ed	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@Unpickler_@22:

; 5990 :         i = new_memo_size;
; 5991 :         while (--i >= 0) {

  001f2	48 ff cb	 dec	 rbx
  001f5	79 ed		 jns	 SHORT $LL6@Unpickler_@22
$LN5@Unpickler_@22:

; 5993 :         }
; 5994 :         PyMem_FREE(new_memo);

  001f7	e8 00 00 00 00	 call	 _Py_PXCTX
  001fc	48 8b cf	 mov	 rcx, rdi
  001ff	85 c0		 test	 eax, eax
  00201	74 07		 je	 SHORT $LN30@Unpickler_@22
  00203	e8 00 00 00 00	 call	 _PxMem_Free
  00208	eb 1f		 jmp	 SHORT $LN50@Unpickler_@22
$LN30@Unpickler_@22:
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5995 :     }
; 5996 :     return -1;

  00210	eb 17		 jmp	 SHORT $LN50@Unpickler_@22
$LN16@Unpickler_@22:

; 5972 :                 goto error;
; 5973 :         }
; 5974 :     }
; 5975 :     else {
; 5976 :         PyErr_Format(PyExc_TypeError,
; 5977 :                      "'memo' attribute must be an UnpicklerMemoProxy object"
; 5978 :                      "or dict, not %.200s", Py_TYPE(obj)->tp_name);

  00212	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00216	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0021d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EJ@JNONLCFC@?8memo?8?5attribute?5must?5be?5an?5Unpi@
  00224	e8 00 00 00 00	 call	 PyErr_Format
$LN50@Unpickler_@22:

; 5979 :         return -1;

  00229	83 c8 ff	 or	 eax, -1
$LN49@Unpickler_@22:
  0022c	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00231	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00236	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0023b	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]

; 5997 : }

  00240	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00244	41 5d		 pop	 r13
  00246	5e		 pop	 rsi
  00247	c3		 ret	 0
Unpickler_set_memo ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$Unpickler_get_persload DD imagerel Unpickler_get_persload
	DD	imagerel Unpickler_get_persload+139
	DD	imagerel $unwind$Unpickler_get_persload
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_get_persload DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
xdata	ENDS
;	COMDAT Unpickler_get_persload
_TEXT	SEGMENT
self$ = 64
Unpickler_get_persload PROC				; COMDAT

; 6001 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 6002 :     if (self->pers_func == NULL)

  0000a	48 8b b9 80 00
	00 00		 mov	 rdi, QWORD PTR [rcx+128]
  00011	48 8b d9	 mov	 rbx, rcx
  00014	48 85 ff	 test	 rdi, rdi
  00017	75 25		 jne	 SHORT $LN2@Unpickler_@23

; 6003 :         PyErr_SetString(PyExc_AttributeError, "persistent_load");

  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@NNFEJGCF@persistent_load?$AA@
  00027	e8 00 00 00 00	 call	 PyErr_SetString

; 6006 :     return self->pers_func;

  0002c	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]

; 6007 : }

  00033	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00038	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003c	5f		 pop	 rdi
  0003d	c3		 ret	 0
$LN2@Unpickler_@23:

; 6004 :     else
; 6005 :         Py_INCREF(self->pers_func);

  0003e	e8 00 00 00 00	 call	 _Py_PXCTX
  00043	85 c0		 test	 eax, eax
  00045	75 32		 jne	 SHORT $LN9@Unpickler_@23
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00055	4c 8b cf	 mov	 r9, rdi
  00058	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0005e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00066	e8 00 00 00 00	 call	 _PyParallel_Guard
  0006b	85 c0		 test	 eax, eax
  0006d	75 06		 jne	 SHORT $LN5@Unpickler_@23
  0006f	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00073	74 04		 je	 SHORT $LN9@Unpickler_@23
$LN5@Unpickler_@23:
  00075	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN9@Unpickler_@23:

; 6006 :     return self->pers_func;

  00079	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]

; 6007 : }

  00080	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00085	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00089	5f		 pop	 rdi
  0008a	c3		 ret	 0
Unpickler_get_persload ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@GNLPJLNO@persistent_load?5must?5be?5a?5callab@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$Unpickler_set_persload DD imagerel Unpickler_set_persload
	DD	imagerel Unpickler_set_persload+208
	DD	imagerel $unwind$Unpickler_set_persload
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Unpickler_set_persload DD 066801H
	DD	087468H
	DD	09340aH
	DD	06006520aH
xdata	ENDS
;	COMDAT ??_C@_0DH@GNLPJLNO@persistent_load?5must?5be?5a?5callab@
CONST	SEGMENT
??_C@_0DH@GNLPJLNO@persistent_load?5must?5be?5a?5callab@ DB 'persistent_l'
	DB	'oad must be a callable taking one argument', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT Unpickler_set_persload
_TEXT	SEGMENT
self$ = 64
value$ = 72
Unpickler_set_persload PROC				; COMDAT

; 6011 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f1	 mov	 rsi, rcx

; 6012 :     PyObject *tmp;
; 6013 : 
; 6014 :     if (value == NULL) {

  00010	48 85 d2	 test	 rdx, rdx
  00013	75 21		 jne	 SHORT $LN6@Unpickler_@24

; 6015 :         PyErr_SetString(PyExc_TypeError,
; 6016 :                         "attribute deletion is not supported");

  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KNPPJDNH@attribute?5deletion?5is?5not?5suppor@
  00023	e8 00 00 00 00	 call	 PyErr_SetString

; 6017 :         return -1;

  00028	83 c8 ff	 or	 eax, -1

; 6030 : 
; 6031 :     return 0;
; 6032 : }

  0002b	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00030	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00034	5e		 pop	 rsi
  00035	c3		 ret	 0
$LN6@Unpickler_@24:

; 6018 :     }
; 6019 :     if (!PyCallable_Check(value)) {

  00036	48 8b ca	 mov	 rcx, rdx
  00039	e8 00 00 00 00	 call	 PyCallable_Check
  0003e	85 c0		 test	 eax, eax
  00040	75 21		 jne	 SHORT $LN5@Unpickler_@24

; 6020 :         PyErr_SetString(PyExc_TypeError,
; 6021 :                         "persistent_load must be a callable taking "
; 6022 :                         "one argument");

  00042	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@GNLPJLNO@persistent_load?5must?5be?5a?5callab@
  00050	e8 00 00 00 00	 call	 PyErr_SetString

; 6023 :         return -1;

  00055	83 c8 ff	 or	 eax, -1

; 6030 : 
; 6031 :     return 0;
; 6032 : }

  00058	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5e		 pop	 rsi
  00062	c3		 ret	 0
$LN5@Unpickler_@24:
  00063	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 6024 :     }
; 6025 : 
; 6026 :     tmp = self->pers_func;

  00068	48 8b be 80 00
	00 00		 mov	 rdi, QWORD PTR [rsi+128]

; 6027 :     Py_INCREF(value);

  0006f	e8 00 00 00 00	 call	 _Py_PXCTX
  00074	85 c0		 test	 eax, eax
  00076	75 32		 jne	 SHORT $LN10@Unpickler_@24
  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00086	4c 8b cb	 mov	 r9, rbx
  00089	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0008f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00097	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009c	85 c0		 test	 eax, eax
  0009e	75 06		 jne	 SHORT $LN9@Unpickler_@24
  000a0	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000a4	74 04		 je	 SHORT $LN10@Unpickler_@24
$LN9@Unpickler_@24:
  000a6	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN10@Unpickler_@24:

; 6028 :     self->pers_func = value;

  000aa	48 89 9e 80 00
	00 00		 mov	 QWORD PTR [rsi+128], rbx

; 6029 :     Py_XDECREF(tmp);      /* self->pers_func can be NULL, so be careful. */

  000b1	48 85 ff	 test	 rdi, rdi
  000b4	74 08		 je	 SHORT $LN3@Unpickler_@24
  000b6	48 8b cf	 mov	 rcx, rdi
  000b9	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@Unpickler_@24:

; 6030 : 
; 6031 :     return 0;
; 6032 : }

  000be	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000c3	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000c8	33 c0		 xor	 eax, eax
  000ca	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ce	5e		 pop	 rsi
  000cf	c3		 ret	 0
Unpickler_set_persload ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@BBCLAAFJ@O?$HMOss?3load?$AA@		; `string'
PUBLIC	??_C@_0EA@PAKCFPIA@pickle?4load?$CI?$CJ?5takes?5exactly?5one?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pickle_load DD imagerel pickle_load
	DD	imagerel pickle_load+139
	DD	imagerel $unwind$pickle_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$pickle_load DD imagerel pickle_load+139
	DD	imagerel pickle_load+259
	DD	imagerel $chain$1$pickle_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$pickle_load DD imagerel pickle_load+259
	DD	imagerel pickle_load+279
	DD	imagerel $chain$3$pickle_load
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$pickle_load DD 020021H
	DD	0a7400H
	DD	imagerel pickle_load
	DD	imagerel pickle_load+139
	DD	imagerel $unwind$pickle_load
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$pickle_load DD 045621H
	DD	0c3456H
	DD	0a7405H
	DD	imagerel pickle_load
	DD	imagerel pickle_load+139
	DD	imagerel $unwind$pickle_load
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pickle_load DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0L@BBCLAAFJ@O?$HMOss?3load?$AA@
CONST	SEGMENT
??_C@_0L@BBCLAAFJ@O?$HMOss?3load?$AA@ DB 'O|Oss:load', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@PAKCFPIA@pickle?4load?$CI?$CJ?5takes?5exactly?5one?5@
CONST	SEGMENT
??_C@_0EA@PAKCFPIA@pickle?4load?$CI?$CJ?5takes?5exactly?5one?5@ DB 'pickl'
	DB	'e.load() takes exactly one positional argument (%zd given)', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT pickle_load
_TEXT	SEGMENT
fix_imports$ = 64
file$ = 72
self$ = 96
errors$ = 104
args$ = 104
kwds$ = 112
encoding$ = 120
pickle_load PROC					; COMDAT

; 6238 : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 6239 :     static char *kwlist[] = {"file", "fix_imports", "encoding", "errors", 0};
; 6240 :     PyObject *file;
; 6241 :     PyObject *fix_imports = Py_True;

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  0000b	4d 8b d0	 mov	 r10, r8

; 6242 :     PyObject *result;
; 6243 :     char *encoding = NULL;
; 6244 :     char *errors = NULL;
; 6245 :     UnpicklerObject *unpickler;
; 6246 : 
; 6247 :     /* fix_imports, encoding and errors are a keyword-only argument.  */
; 6248 :     if (Py_SIZE(args) != 1) {

  0000e	4c 8b 42 60	 mov	 r8, QWORD PTR [rdx+96]
  00012	48 89 4c 24 40	 mov	 QWORD PTR fix_imports$[rsp], rcx
  00017	33 c9		 xor	 ecx, ecx
  00019	48 8b c2	 mov	 rax, rdx
  0001c	48 89 4c 24 78	 mov	 QWORD PTR encoding$[rsp], rcx
  00021	48 89 4c 24 68	 mov	 QWORD PTR errors$[rsp], rcx
  00026	49 83 f8 01	 cmp	 r8, 1
  0002a	74 1a		 je	 SHORT $LN10@pickle_loa

; 6249 :         PyErr_Format(PyExc_TypeError,
; 6250 :                      "pickle.load() takes exactly one positional "
; 6251 :                      "argument (%zd given)", Py_SIZE(args));

  0002c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EA@PAKCFPIA@pickle?4load?$CI?$CJ?5takes?5exactly?5one?5@
  0003a	e8 00 00 00 00	 call	 PyErr_Format
$LN15@pickle_loa:

; 6252 :         return NULL;

  0003f	33 c0		 xor	 eax, eax

; 6280 : }

  00041	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00045	c3		 ret	 0
$LN10@pickle_loa:

; 6253 :     }
; 6254 : 
; 6255 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|Oss:load", kwlist,
; 6256 :                                      &file, &fix_imports, &encoding, &errors))

  00046	48 8d 4c 24 68	 lea	 rcx, QWORD PTR errors$[rsp]
  0004b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pickle_load@@9@9
  00052	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@BBCLAAFJ@O?$HMOss?3load?$AA@
  00059	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0005e	48 8d 4c 24 78	 lea	 rcx, QWORD PTR encoding$[rsp]
  00063	49 8b d2	 mov	 rdx, r10
  00066	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0006b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR fix_imports$[rsp]
  00070	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00075	48 8d 4c 24 48	 lea	 rcx, QWORD PTR file$[rsp]
  0007a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0007f	48 8b c8	 mov	 rcx, rax
  00082	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00087	85 c0		 test	 eax, eax

; 6257 :         return NULL;

  00089	74 b4		 je	 SHORT $LN15@pickle_loa

; 6258 : 
; 6259 :     unpickler = _Unpickler_New();

  0008b	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00090	e8 00 00 00 00	 call	 _Unpickler_New
  00095	48 8b f8	 mov	 rdi, rax

; 6260 :     if (unpickler == NULL)

  00098	48 85 c0	 test	 rax, rax

; 6261 :         return NULL;

  0009b	74 6e		 je	 SHORT $LN14@pickle_loa

; 6262 : 
; 6263 :     if (_Unpickler_SetInputStream(unpickler, file) < 0)

  0009d	48 8b 54 24 48	 mov	 rdx, QWORD PTR file$[rsp]
  000a2	48 8b c8	 mov	 rcx, rax
  000a5	e8 00 00 00 00	 call	 _Unpickler_SetInputStream
  000aa	85 c0		 test	 eax, eax
  000ac	78 55		 js	 SHORT $error$25028

; 6264 :         goto error;
; 6265 : 
; 6266 :     if (_Unpickler_SetInputEncoding(unpickler, encoding, errors) < 0)

  000ae	4c 8b 44 24 68	 mov	 r8, QWORD PTR errors$[rsp]
  000b3	48 8b 54 24 78	 mov	 rdx, QWORD PTR encoding$[rsp]
  000b8	48 8b cf	 mov	 rcx, rdi
  000bb	e8 00 00 00 00	 call	 _Unpickler_SetInputEncoding
  000c0	85 c0		 test	 eax, eax
  000c2	78 3f		 js	 SHORT $error$25028

; 6267 :         goto error;
; 6268 : 
; 6269 :     unpickler->fix_imports = PyObject_IsTrue(fix_imports);

  000c4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fix_imports$[rsp]
  000c9	e8 00 00 00 00	 call	 PyObject_IsTrue
  000ce	89 87 44 01 00
	00		 mov	 DWORD PTR [rdi+324], eax

; 6270 :     if (unpickler->fix_imports == -1)

  000d4	83 f8 ff	 cmp	 eax, -1
  000d7	74 2a		 je	 SHORT $error$25028

; 6271 :         goto error;
; 6272 : 
; 6273 :     result = load(unpickler);

  000d9	48 8b cf	 mov	 rcx, rdi
  000dc	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  000e1	e8 00 00 00 00	 call	 load

; 6274 :     Py_DECREF(unpickler);

  000e6	48 8b cf	 mov	 rcx, rdi
  000e9	48 8b d8	 mov	 rbx, rax
  000ec	e8 00 00 00 00	 call	 _Py_DecRef
  000f1	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 6275 :     return result;

  000f6	48 8b c3	 mov	 rax, rbx
  000f9	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 6280 : }

  000fe	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00102	c3		 ret	 0
$error$25028:

; 6276 : 
; 6277 :   error:
; 6278 :     Py_XDECREF(unpickler);

  00103	48 8b cf	 mov	 rcx, rdi
  00106	e8 00 00 00 00	 call	 _Py_DecRef
$LN14@pickle_loa:

; 6279 :     return NULL;

  0010b	33 c0		 xor	 eax, eax
  0010d	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 6280 : }

  00112	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00116	c3		 ret	 0
pickle_load ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@BGLEOIGF@O?$HMOss?3loads?$AA@		; `string'
PUBLIC	??_C@_0EB@MCKAECFB@pickle?4loads?$CI?$CJ?5takes?5exactly?5one@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pickle_loads DD imagerel pickle_loads
	DD	imagerel pickle_loads+139
	DD	imagerel $unwind$pickle_loads
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$pickle_loads DD imagerel pickle_loads+139
	DD	imagerel pickle_loads+260
	DD	imagerel $chain$1$pickle_loads
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$pickle_loads DD imagerel pickle_loads+260
	DD	imagerel pickle_loads+280
	DD	imagerel $chain$3$pickle_loads
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$pickle_loads DD 020021H
	DD	0a7400H
	DD	imagerel pickle_loads
	DD	imagerel pickle_loads+139
	DD	imagerel $unwind$pickle_loads
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$pickle_loads DD 045721H
	DD	0c3457H
	DD	0a7405H
	DD	imagerel pickle_loads
	DD	imagerel pickle_loads+139
	DD	imagerel $unwind$pickle_loads
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pickle_loads DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0M@BGLEOIGF@O?$HMOss?3loads?$AA@
CONST	SEGMENT
??_C@_0M@BGLEOIGF@O?$HMOss?3loads?$AA@ DB 'O|Oss:loads', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@MCKAECFB@pickle?4loads?$CI?$CJ?5takes?5exactly?5one@
CONST	SEGMENT
??_C@_0EB@MCKAECFB@pickle?4loads?$CI?$CJ?5takes?5exactly?5one@ DB 'pickle'
	DB	'.loads() takes exactly one positional argument (%zd given)', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT pickle_loads
_TEXT	SEGMENT
fix_imports$ = 64
input$ = 72
self$ = 96
errors$ = 104
args$ = 104
kwds$ = 112
encoding$ = 120
pickle_loads PROC					; COMDAT

; 6301 : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 6302 :     static char *kwlist[] = {"input", "fix_imports", "encoding", "errors", 0};
; 6303 :     PyObject *input;
; 6304 :     PyObject *fix_imports = Py_True;

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  0000b	4d 8b d0	 mov	 r10, r8

; 6305 :     PyObject *result;
; 6306 :     char *encoding = NULL;
; 6307 :     char *errors = NULL;
; 6308 :     UnpicklerObject *unpickler;
; 6309 : 
; 6310 :     /* fix_imports, encoding and errors are a keyword-only argument.  */
; 6311 :     if (Py_SIZE(args) != 1) {

  0000e	4c 8b 42 60	 mov	 r8, QWORD PTR [rdx+96]
  00012	48 89 4c 24 40	 mov	 QWORD PTR fix_imports$[rsp], rcx
  00017	33 c9		 xor	 ecx, ecx
  00019	48 8b c2	 mov	 rax, rdx
  0001c	48 89 4c 24 78	 mov	 QWORD PTR encoding$[rsp], rcx
  00021	48 89 4c 24 68	 mov	 QWORD PTR errors$[rsp], rcx
  00026	49 83 f8 01	 cmp	 r8, 1
  0002a	74 1a		 je	 SHORT $LN10@pickle_loa@2

; 6312 :         PyErr_Format(PyExc_TypeError,
; 6313 :                      "pickle.loads() takes exactly one positional "
; 6314 :                      "argument (%zd given)", Py_SIZE(args));

  0002c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EB@MCKAECFB@pickle?4loads?$CI?$CJ?5takes?5exactly?5one@
  0003a	e8 00 00 00 00	 call	 PyErr_Format
$LN15@pickle_loa@2:

; 6315 :         return NULL;

  0003f	33 c0		 xor	 eax, eax

; 6343 : }

  00041	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00045	c3		 ret	 0
$LN10@pickle_loa@2:

; 6316 :     }
; 6317 : 
; 6318 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|Oss:loads", kwlist,
; 6319 :                                      &input, &fix_imports, &encoding, &errors))

  00046	48 8d 4c 24 68	 lea	 rcx, QWORD PTR errors$[rsp]
  0004b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pickle_loads@@9@9
  00052	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@BGLEOIGF@O?$HMOss?3loads?$AA@
  00059	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0005e	48 8d 4c 24 78	 lea	 rcx, QWORD PTR encoding$[rsp]
  00063	49 8b d2	 mov	 rdx, r10
  00066	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0006b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR fix_imports$[rsp]
  00070	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00075	48 8d 4c 24 48	 lea	 rcx, QWORD PTR input$[rsp]
  0007a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0007f	48 8b c8	 mov	 rcx, rax
  00082	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00087	85 c0		 test	 eax, eax

; 6320 :         return NULL;

  00089	74 b4		 je	 SHORT $LN15@pickle_loa@2

; 6321 : 
; 6322 :     unpickler = _Unpickler_New();

  0008b	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00090	e8 00 00 00 00	 call	 _Unpickler_New
  00095	48 8b f8	 mov	 rdi, rax

; 6323 :     if (unpickler == NULL)

  00098	48 85 c0	 test	 rax, rax

; 6324 :         return NULL;

  0009b	74 6f		 je	 SHORT $LN14@pickle_loa@2

; 6325 : 
; 6326 :     if (_Unpickler_SetStringInput(unpickler, input) < 0)

  0009d	48 8b 54 24 48	 mov	 rdx, QWORD PTR input$[rsp]
  000a2	48 8b c8	 mov	 rcx, rax
  000a5	e8 00 00 00 00	 call	 _Unpickler_SetStringInput
  000aa	48 85 c0	 test	 rax, rax
  000ad	78 55		 js	 SHORT $error$25071

; 6327 :         goto error;
; 6328 : 
; 6329 :     if (_Unpickler_SetInputEncoding(unpickler, encoding, errors) < 0)

  000af	4c 8b 44 24 68	 mov	 r8, QWORD PTR errors$[rsp]
  000b4	48 8b 54 24 78	 mov	 rdx, QWORD PTR encoding$[rsp]
  000b9	48 8b cf	 mov	 rcx, rdi
  000bc	e8 00 00 00 00	 call	 _Unpickler_SetInputEncoding
  000c1	85 c0		 test	 eax, eax
  000c3	78 3f		 js	 SHORT $error$25071

; 6330 :         goto error;
; 6331 : 
; 6332 :     unpickler->fix_imports = PyObject_IsTrue(fix_imports);

  000c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fix_imports$[rsp]
  000ca	e8 00 00 00 00	 call	 PyObject_IsTrue
  000cf	89 87 44 01 00
	00		 mov	 DWORD PTR [rdi+324], eax

; 6333 :     if (unpickler->fix_imports == -1)

  000d5	83 f8 ff	 cmp	 eax, -1
  000d8	74 2a		 je	 SHORT $error$25071

; 6334 :         goto error;
; 6335 : 
; 6336 :     result = load(unpickler);

  000da	48 8b cf	 mov	 rcx, rdi
  000dd	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  000e2	e8 00 00 00 00	 call	 load

; 6337 :     Py_DECREF(unpickler);

  000e7	48 8b cf	 mov	 rcx, rdi
  000ea	48 8b d8	 mov	 rbx, rax
  000ed	e8 00 00 00 00	 call	 _Py_DecRef
  000f2	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 6338 :     return result;

  000f7	48 8b c3	 mov	 rax, rbx
  000fa	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 6343 : }

  000ff	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00103	c3		 ret	 0
$error$25071:

; 6339 : 
; 6340 :   error:
; 6341 :     Py_XDECREF(unpickler);

  00104	48 8b cf	 mov	 rcx, rdi
  00107	e8 00 00 00 00	 call	 _Py_DecRef
$LN14@pickle_loa@2:

; 6342 :     return NULL;

  0010c	33 c0		 xor	 eax, eax
  0010e	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 6343 : }

  00113	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00117	c3		 ret	 0
pickle_loads ENDP
_TEXT	ENDS
PUBLIC	??_C@_0ED@DMHCPNOG@_compat_pickle?4REVERSE_IMPORT_MA@ ; `string'
PUBLIC	??_C@_0BH@HCNJFHFO@REVERSE_IMPORT_MAPPING?$AA@	; `string'
PUBLIC	??_C@_0EB@EGJAAION@_compat_pickle?4REVERSE_NAME_MAPP@ ; `string'
PUBLIC	??_C@_0BF@PCKAADLD@REVERSE_NAME_MAPPING?$AA@	; `string'
PUBLIC	??_C@_0DL@IBPPHGMJ@_compat_pickle?4IMPORT_MAPPING?5sh@ ; `string'
PUBLIC	??_C@_0P@FDAEMEFC@IMPORT_MAPPING?$AA@		; `string'
PUBLIC	??_C@_0DJ@IKFMBBAC@_compat_pickle?4NAME_MAPPING?5shou@ ; `string'
PUBLIC	??_C@_0N@JDNLMJCA@NAME_MAPPING?$AA@		; `string'
PUBLIC	??_C@_0P@NENAADEG@_compat_pickle?$AA@		; `string'
PUBLIC	??_C@_0L@NCMCMGNH@initmodule?$AA@		; `string'
PUBLIC	??_C@_0BB@JFMPGNNF@_extension_cache?$AA@	; `string'
PUBLIC	??_C@_0BD@FFNJNBHB@_inverted_registry?$AA@	; `string'
PUBLIC	??_C@_0BE@PCFNLJJD@_extension_registry?$AA@	; `string'
PUBLIC	??_C@_07ODDBKIAB@copyreg?$AA@			; `string'
EXTRN	PyObject_GetAttrString:PROC
EXTRN	PyImport_ImportModule:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$initmodule DD imagerel initmodule
	DD	imagerel initmodule+2688
	DD	imagerel $unwind$initmodule
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$initmodule DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT ??_C@_0ED@DMHCPNOG@_compat_pickle?4REVERSE_IMPORT_MA@
CONST	SEGMENT
??_C@_0ED@DMHCPNOG@_compat_pickle?4REVERSE_IMPORT_MA@ DB '_compat_pickle.'
	DB	'REVERSE_IMPORT_MAPPING should be a dict, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HCNJFHFO@REVERSE_IMPORT_MAPPING?$AA@
CONST	SEGMENT
??_C@_0BH@HCNJFHFO@REVERSE_IMPORT_MAPPING?$AA@ DB 'REVERSE_IMPORT_MAPPING'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@EGJAAION@_compat_pickle?4REVERSE_NAME_MAPP@
CONST	SEGMENT
??_C@_0EB@EGJAAION@_compat_pickle?4REVERSE_NAME_MAPP@ DB '_compat_pickle.'
	DB	'REVERSE_NAME_MAPPING should be a dict, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PCKAADLD@REVERSE_NAME_MAPPING?$AA@
CONST	SEGMENT
??_C@_0BF@PCKAADLD@REVERSE_NAME_MAPPING?$AA@ DB 'REVERSE_NAME_MAPPING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@IBPPHGMJ@_compat_pickle?4IMPORT_MAPPING?5sh@
CONST	SEGMENT
??_C@_0DL@IBPPHGMJ@_compat_pickle?4IMPORT_MAPPING?5sh@ DB '_compat_pickle'
	DB	'.IMPORT_MAPPING should be a dict, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FDAEMEFC@IMPORT_MAPPING?$AA@
CONST	SEGMENT
??_C@_0P@FDAEMEFC@IMPORT_MAPPING?$AA@ DB 'IMPORT_MAPPING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@IKFMBBAC@_compat_pickle?4NAME_MAPPING?5shou@
CONST	SEGMENT
??_C@_0DJ@IKFMBBAC@_compat_pickle?4NAME_MAPPING?5shou@ DB '_compat_pickle'
	DB	'.NAME_MAPPING should be a dict, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JDNLMJCA@NAME_MAPPING?$AA@
CONST	SEGMENT
??_C@_0N@JDNLMJCA@NAME_MAPPING?$AA@ DB 'NAME_MAPPING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NENAADEG@_compat_pickle?$AA@
CONST	SEGMENT
??_C@_0P@NENAADEG@_compat_pickle?$AA@ DB '_compat_pickle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NCMCMGNH@initmodule?$AA@
CONST	SEGMENT
??_C@_0L@NCMCMGNH@initmodule?$AA@ DB 'initmodule', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JFMPGNNF@_extension_cache?$AA@
CONST	SEGMENT
??_C@_0BB@JFMPGNNF@_extension_cache?$AA@ DB '_extension_cache', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FFNJNBHB@_inverted_registry?$AA@
CONST	SEGMENT
??_C@_0BD@FFNJNBHB@_inverted_registry?$AA@ DB '_inverted_registry', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PCFNLJJD@_extension_registry?$AA@
CONST	SEGMENT
??_C@_0BE@PCFNLJJD@_extension_registry?$AA@ DB '_extension_registry', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ODDBKIAB@copyreg?$AA@
CONST	SEGMENT
??_C@_07ODDBKIAB@copyreg?$AA@ DB 'copyreg', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT initmodule
_TEXT	SEGMENT
initmodule PROC						; COMDAT

; 6360 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 6361 :     PyObject *copyreg = NULL;
; 6362 :     PyObject *compat_pickle = NULL;
; 6363 : 
; 6364 :     /* XXX: We should ensure that the types of the dictionaries imported are
; 6365 :        exactly PyDict objects. Otherwise, it is possible to crash the pickle
; 6366 :        since we use the PyDict API directly to access these dictionaries. */
; 6367 : 
; 6368 :     copyreg = PyImport_ImportModule("copyreg");

  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07ODDBKIAB@copyreg?$AA@
  0001b	33 ed		 xor	 ebp, ebp
  0001d	8b fd		 mov	 edi, ebp
  0001f	e8 00 00 00 00	 call	 PyImport_ImportModule
  00024	48 8b d8	 mov	 rbx, rax

; 6369 :     if (!copyreg)

  00027	48 85 c0	 test	 rax, rax
  0002a	0f 84 f4 02 00
	00		 je	 $LN47@initmodule

; 6370 :         goto error;
; 6371 :     dispatch_table = PyObject_GetAttrString(copyreg, "dispatch_table");

  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@MAJNENGA@dispatch_table?$AA@
  00037	48 8b c8	 mov	 rcx, rax
  0003a	e8 00 00 00 00	 call	 PyObject_GetAttrString
  0003f	48 89 05 00 00
	00 00		 mov	 QWORD PTR dispatch_table, rax

; 6372 :     if (!dispatch_table)

  00046	48 85 c0	 test	 rax, rax
  00049	0f 84 f3 00 00
	00		 je	 $error$25099

; 6373 :         goto error;
; 6374 :     extension_registry = \
; 6375 :         PyObject_GetAttrString(copyreg, "_extension_registry");

  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@PCFNLJJD@_extension_registry?$AA@
  00056	48 8b cb	 mov	 rcx, rbx
  00059	e8 00 00 00 00	 call	 PyObject_GetAttrString
  0005e	48 89 05 00 00
	00 00		 mov	 QWORD PTR extension_registry, rax

; 6376 :     if (!extension_registry)

  00065	48 85 c0	 test	 rax, rax
  00068	0f 84 d4 00 00
	00		 je	 $error$25099

; 6377 :         goto error;
; 6378 :     inverted_registry = PyObject_GetAttrString(copyreg, "_inverted_registry");

  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@FFNJNBHB@_inverted_registry?$AA@
  00075	48 8b cb	 mov	 rcx, rbx
  00078	e8 00 00 00 00	 call	 PyObject_GetAttrString
  0007d	48 89 05 00 00
	00 00		 mov	 QWORD PTR inverted_registry, rax

; 6379 :     if (!inverted_registry)

  00084	48 85 c0	 test	 rax, rax
  00087	0f 84 b5 00 00
	00		 je	 $error$25099

; 6380 :         goto error;
; 6381 :     extension_cache = PyObject_GetAttrString(copyreg, "_extension_cache");

  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@JFMPGNNF@_extension_cache?$AA@
  00094	48 8b cb	 mov	 rcx, rbx
  00097	e8 00 00 00 00	 call	 PyObject_GetAttrString
  0009c	48 89 05 00 00
	00 00		 mov	 QWORD PTR extension_cache, rax

; 6382 :     if (!extension_cache)

  000a3	48 85 c0	 test	 rax, rax
  000a6	0f 84 96 00 00
	00		 je	 $error$25099

; 6383 :         goto error;
; 6384 :     Py_CLEAR(copyreg);

  000ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  000ba	4c 8b cb	 mov	 r9, rbx
  000bd	41 b8 f0 18 00
	00		 mov	 r8d, 6384		; 000018f0H
  000c3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000cb	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d0	85 c0		 test	 eax, eax
  000d2	75 0a		 jne	 SHORT $LN66@initmodule
  000d4	48 8b cb	 mov	 rcx, rbx
  000d7	8b dd		 mov	 ebx, ebp
  000d9	e8 00 00 00 00	 call	 _Py_DecRef
$LN66@initmodule:

; 6385 : 
; 6386 :     /* Load the 2.x -> 3.x stdlib module mapping tables */
; 6387 :     compat_pickle = PyImport_ImportModule("_compat_pickle");

  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@NENAADEG@_compat_pickle?$AA@
  000e5	e8 00 00 00 00	 call	 PyImport_ImportModule
  000ea	48 8b f8	 mov	 rdi, rax

; 6388 :     if (!compat_pickle)

  000ed	48 85 c0	 test	 rax, rax
  000f0	74 50		 je	 SHORT $error$25099

; 6389 :         goto error;
; 6390 :     name_mapping_2to3 = PyObject_GetAttrString(compat_pickle, "NAME_MAPPING");

  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@JDNLMJCA@NAME_MAPPING?$AA@
  000f9	48 8b c8	 mov	 rcx, rax
  000fc	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00101	48 89 05 00 00
	00 00		 mov	 QWORD PTR name_mapping_2to3, rax

; 6391 :     if (!name_mapping_2to3)

  00108	48 85 c0	 test	 rax, rax
  0010b	74 35		 je	 SHORT $error$25099

; 6392 :         goto error;
; 6393 :     if (!PyDict_CheckExact(name_mapping_2to3)) {

  0010d	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00111	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyDict_Type
  00118	4c 3b c6	 cmp	 r8, rsi
  0011b	0f 84 c2 00 00
	00		 je	 $LN61@initmodule
  00121	48 39 70 38	 cmp	 QWORD PTR [rax+56], rsi
  00125	0f 84 b8 00 00
	00		 je	 $LN61@initmodule

; 6394 :         PyErr_Format(PyExc_RuntimeError,
; 6395 :                      "_compat_pickle.NAME_MAPPING should be a dict, not %.200s",
; 6396 :                      Py_TYPE(name_mapping_2to3)->tp_name);

  0012b	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0012f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DJ@IKFMBBAC@_compat_pickle?4NAME_MAPPING?5shou@
$LN229@initmodule:

; 6404 :         PyErr_Format(PyExc_RuntimeError,
; 6405 :                      "_compat_pickle.IMPORT_MAPPING should be a dict, "
; 6406 :                      "not %.200s", Py_TYPE(import_mapping_2to3)->tp_name);

  00136	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0013d	e8 00 00 00 00	 call	 PyErr_Format
$error$25099:

; 6445 : 
; 6446 :   error:
; 6447 :     Py_CLEAR(copyreg);

  00142	48 85 db	 test	 rbx, rbx
  00145	0f 84 d9 01 00
	00		 je	 $LN47@initmodule
  0014b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00152	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  00159	4c 8b cb	 mov	 r9, rbx
  0015c	41 b8 2f 19 00
	00		 mov	 r8d, 6447		; 0000192fH
  00162	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0016a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0016f	85 c0		 test	 eax, eax
  00171	0f 85 ad 01 00
	00		 jne	 $LN47@initmodule
  00177	e8 00 00 00 00	 call	 _Py_PXCTX
  0017c	85 c0		 test	 eax, eax
  0017e	0f 85 a0 01 00
	00		 jne	 $LN47@initmodule
  00184	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00188	a8 20		 test	 al, 32			; 00000020H
  0018a	0f 85 8c 01 00
	00		 jne	 $LN79@initmodule
  00190	84 c0		 test	 al, al
  00192	0f 88 84 01 00
	00		 js	 $LN79@initmodule
  00198	a8 02		 test	 al, 2
  0019a	0f 85 84 01 00
	00		 jne	 $LN47@initmodule
  001a0	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001a4	0f 85 7a 01 00
	00		 jne	 $LN47@initmodule
  001aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001b8	4c 8b cb	 mov	 r9, rbx
  001bb	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001c1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001c9	e8 00 00 00 00	 call	 _PyParallel_Guard
  001ce	48 8b cb	 mov	 rcx, rbx
  001d1	85 c0		 test	 eax, eax
  001d3	0f 84 37 01 00
	00		 je	 $LN84@initmodule
  001d9	e8 00 00 00 00	 call	 _Px_Dealloc
  001de	e9 41 01 00 00	 jmp	 $LN47@initmodule
$LN61@initmodule:

; 6397 :         goto error;
; 6398 :     }
; 6399 :     import_mapping_2to3 = PyObject_GetAttrString(compat_pickle,
; 6400 :                                                  "IMPORT_MAPPING");

  001e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@FDAEMEFC@IMPORT_MAPPING?$AA@
  001ea	48 8b cf	 mov	 rcx, rdi
  001ed	e8 00 00 00 00	 call	 PyObject_GetAttrString
  001f2	48 89 05 00 00
	00 00		 mov	 QWORD PTR import_mapping_2to3, rax

; 6401 :     if (!import_mapping_2to3)

  001f9	48 85 c0	 test	 rax, rax
  001fc	0f 84 40 ff ff
	ff		 je	 $error$25099

; 6402 :         goto error;
; 6403 :     if (!PyDict_CheckExact(import_mapping_2to3)) {

  00202	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00206	4c 3b c6	 cmp	 r8, rsi
  00209	74 16		 je	 SHORT $LN59@initmodule
  0020b	48 39 70 38	 cmp	 QWORD PTR [rax+56], rsi
  0020f	74 10		 je	 SHORT $LN59@initmodule

; 6404 :         PyErr_Format(PyExc_RuntimeError,
; 6405 :                      "_compat_pickle.IMPORT_MAPPING should be a dict, "
; 6406 :                      "not %.200s", Py_TYPE(import_mapping_2to3)->tp_name);

  00211	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00215	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@IBPPHGMJ@_compat_pickle?4IMPORT_MAPPING?5sh@

; 6407 :         goto error;

  0021c	e9 15 ff ff ff	 jmp	 $LN229@initmodule
$LN59@initmodule:

; 6408 :     }
; 6409 :     /* ... and the 3.x -> 2.x mapping tables */
; 6410 :     name_mapping_3to2 = PyObject_GetAttrString(compat_pickle,
; 6411 :                                                "REVERSE_NAME_MAPPING");

  00221	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@PCKAADLD@REVERSE_NAME_MAPPING?$AA@
  00228	48 8b cf	 mov	 rcx, rdi
  0022b	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00230	48 89 05 00 00
	00 00		 mov	 QWORD PTR name_mapping_3to2, rax

; 6412 :     if (!name_mapping_3to2)

  00237	48 85 c0	 test	 rax, rax
  0023a	0f 84 02 ff ff
	ff		 je	 $error$25099

; 6413 :         goto error;
; 6414 :     if (!PyDict_CheckExact(name_mapping_3to2)) {

  00240	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00244	4c 3b c6	 cmp	 r8, rsi
  00247	74 16		 je	 SHORT $LN57@initmodule
  00249	48 39 70 38	 cmp	 QWORD PTR [rax+56], rsi
  0024d	74 10		 je	 SHORT $LN57@initmodule

; 6415 :         PyErr_Format(PyExc_RuntimeError,
; 6416 :                      "_compat_pickle.REVERSE_NAME_MAPPING should be a dict, "
; 6417 :                      "not %.200s", Py_TYPE(name_mapping_3to2)->tp_name);

  0024f	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00253	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EB@EGJAAION@_compat_pickle?4REVERSE_NAME_MAPP@

; 6418 :         goto error;

  0025a	e9 d7 fe ff ff	 jmp	 $LN229@initmodule
$LN57@initmodule:

; 6419 :     }
; 6420 :     import_mapping_3to2 = PyObject_GetAttrString(compat_pickle,
; 6421 :                                                  "REVERSE_IMPORT_MAPPING");

  0025f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@HCNJFHFO@REVERSE_IMPORT_MAPPING?$AA@
  00266	48 8b cf	 mov	 rcx, rdi
  00269	e8 00 00 00 00	 call	 PyObject_GetAttrString
  0026e	48 89 05 00 00
	00 00		 mov	 QWORD PTR import_mapping_3to2, rax

; 6422 :     if (!import_mapping_3to2)

  00275	48 85 c0	 test	 rax, rax
  00278	0f 84 c4 fe ff
	ff		 je	 $error$25099

; 6423 :         goto error;
; 6424 :     if (!PyDict_CheckExact(import_mapping_3to2)) {

  0027e	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00282	4c 3b c6	 cmp	 r8, rsi
  00285	74 16		 je	 SHORT $LN54@initmodule
  00287	48 39 70 38	 cmp	 QWORD PTR [rax+56], rsi
  0028b	74 10		 je	 SHORT $LN54@initmodule

; 6425 :         PyErr_Format(PyExc_RuntimeError,
; 6426 :                      "_compat_pickle.REVERSE_IMPORT_MAPPING should be a dict, "
; 6427 :                      "not %.200s", Py_TYPE(import_mapping_3to2)->tp_name);

  0028d	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00291	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0ED@DMHCPNOG@_compat_pickle?4REVERSE_IMPORT_MA@

; 6428 :         goto error;

  00298	e9 99 fe ff ff	 jmp	 $LN229@initmodule
$LN54@initmodule:

; 6429 :     }
; 6430 :     Py_CLEAR(compat_pickle);

  0029d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  002a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  002ab	4c 8b cf	 mov	 r9, rdi
  002ae	41 b8 1e 19 00
	00		 mov	 r8d, 6430		; 0000191eH
  002b4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002bc	e8 00 00 00 00	 call	 _PyParallel_Guard
  002c1	85 c0		 test	 eax, eax
  002c3	75 0b		 jne	 SHORT $LN53@initmodule
  002c5	48 8b cf	 mov	 rcx, rdi
  002c8	48 8b fd	 mov	 rdi, rbp
  002cb	e8 00 00 00 00	 call	 _Py_DecRef
$LN53@initmodule:

; 6431 : 
; 6432 :     empty_tuple = PyTuple_New(0);

  002d0	33 c9		 xor	 ecx, ecx
  002d2	e8 00 00 00 00	 call	 PyTuple_New
  002d7	48 89 05 00 00
	00 00		 mov	 QWORD PTR empty_tuple, rax

; 6433 :     if (empty_tuple == NULL)

  002de	48 85 c0	 test	 rax, rax
  002e1	0f 84 5b fe ff
	ff		 je	 $error$25099

; 6434 :         goto error;
; 6435 :     two_tuple = PyTuple_New(2);

  002e7	b9 02 00 00 00	 mov	 ecx, 2
  002ec	e8 00 00 00 00	 call	 PyTuple_New
  002f1	48 89 05 00 00
	00 00		 mov	 QWORD PTR two_tuple, rax

; 6436 :     if (two_tuple == NULL)

  002f8	48 85 c0	 test	 rax, rax
  002fb	0f 84 41 fe ff
	ff		 je	 $error$25099

; 6437 :         goto error;
; 6438 :     /* We use this temp container with no regard to refcounts, or to
; 6439 :      * keeping containees alive.  Exempt from GC, because we don't
; 6440 :      * want anything looking at two_tuple() by magic.
; 6441 :      */
; 6442 :     PyObject_GC_UnTrack(two_tuple);

  00301	48 8b c8	 mov	 rcx, rax
  00304	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 6443 : 
; 6444 :     return 0;

  00309	33 c0		 xor	 eax, eax
  0030b	e9 5b 07 00 00	 jmp	 $LN73@initmodule

; 6445 : 
; 6446 :   error:
; 6447 :     Py_CLEAR(copyreg);

$LN84@initmodule:
  00310	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00314	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0031a	eb 08		 jmp	 SHORT $LN47@initmodule
$LN79@initmodule:
  0031c	48 8b cb	 mov	 rcx, rbx
  0031f	e8 00 00 00 00	 call	 Px_DecRef
$LN47@initmodule:

; 6448 :     Py_CLEAR(dispatch_table);

  00324	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR dispatch_table
  0032b	48 85 c0	 test	 rax, rax
  0032e	0f 84 9b 00 00
	00		 je	 $LN43@initmodule
  00334	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0033b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  00342	4c 8b c8	 mov	 r9, rax
  00345	41 b8 30 19 00
	00		 mov	 r8d, 6448		; 00001930H
  0034b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00353	e8 00 00 00 00	 call	 _PyParallel_Guard
  00358	85 c0		 test	 eax, eax
  0035a	75 73		 jne	 SHORT $LN43@initmodule
  0035c	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR dispatch_table
  00363	48 89 2d 00 00
	00 00		 mov	 QWORD PTR dispatch_table, rbp
  0036a	e8 00 00 00 00	 call	 _Py_PXCTX
  0036f	85 c0		 test	 eax, eax
  00371	75 5c		 jne	 SHORT $LN43@initmodule
  00373	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00377	a8 20		 test	 al, 32			; 00000020H
  00379	75 4c		 jne	 SHORT $LN90@initmodule
  0037b	84 c0		 test	 al, al
  0037d	78 48		 js	 SHORT $LN90@initmodule
  0037f	a8 02		 test	 al, 2
  00381	75 4c		 jne	 SHORT $LN43@initmodule
  00383	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00387	75 46		 jne	 SHORT $LN43@initmodule
  00389	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00390	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00397	4c 8b cb	 mov	 r9, rbx
  0039a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  003a0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003a8	e8 00 00 00 00	 call	 _PyParallel_Guard
  003ad	48 8b cb	 mov	 rcx, rbx
  003b0	85 c0		 test	 eax, eax
  003b2	74 07		 je	 SHORT $LN95@initmodule
  003b4	e8 00 00 00 00	 call	 _Px_Dealloc
  003b9	eb 14		 jmp	 SHORT $LN43@initmodule
$LN95@initmodule:
  003bb	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  003bf	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  003c5	eb 08		 jmp	 SHORT $LN43@initmodule
$LN90@initmodule:
  003c7	48 8b cb	 mov	 rcx, rbx
  003ca	e8 00 00 00 00	 call	 Px_DecRef
$LN43@initmodule:

; 6449 :     Py_CLEAR(extension_registry);

  003cf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR extension_registry
  003d6	48 85 c0	 test	 rax, rax
  003d9	0f 84 9b 00 00
	00		 je	 $LN39@initmodule
  003df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  003e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  003ed	4c 8b c8	 mov	 r9, rax
  003f0	41 b8 31 19 00
	00		 mov	 r8d, 6449		; 00001931H
  003f6	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003fe	e8 00 00 00 00	 call	 _PyParallel_Guard
  00403	85 c0		 test	 eax, eax
  00405	75 73		 jne	 SHORT $LN39@initmodule
  00407	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR extension_registry
  0040e	48 89 2d 00 00
	00 00		 mov	 QWORD PTR extension_registry, rbp
  00415	e8 00 00 00 00	 call	 _Py_PXCTX
  0041a	85 c0		 test	 eax, eax
  0041c	75 5c		 jne	 SHORT $LN39@initmodule
  0041e	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00422	a8 20		 test	 al, 32			; 00000020H
  00424	75 4c		 jne	 SHORT $LN101@initmodule
  00426	84 c0		 test	 al, al
  00428	78 48		 js	 SHORT $LN101@initmodule
  0042a	a8 02		 test	 al, 2
  0042c	75 4c		 jne	 SHORT $LN39@initmodule
  0042e	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00432	75 46		 jne	 SHORT $LN39@initmodule
  00434	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0043b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00442	4c 8b cb	 mov	 r9, rbx
  00445	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0044b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00453	e8 00 00 00 00	 call	 _PyParallel_Guard
  00458	48 8b cb	 mov	 rcx, rbx
  0045b	85 c0		 test	 eax, eax
  0045d	74 07		 je	 SHORT $LN106@initmodule
  0045f	e8 00 00 00 00	 call	 _Px_Dealloc
  00464	eb 14		 jmp	 SHORT $LN39@initmodule
$LN106@initmodule:
  00466	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0046a	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00470	eb 08		 jmp	 SHORT $LN39@initmodule
$LN101@initmodule:
  00472	48 8b cb	 mov	 rcx, rbx
  00475	e8 00 00 00 00	 call	 Px_DecRef
$LN39@initmodule:

; 6450 :     Py_CLEAR(inverted_registry);

  0047a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR inverted_registry
  00481	48 85 c0	 test	 rax, rax
  00484	0f 84 9b 00 00
	00		 je	 $LN35@initmodule
  0048a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00491	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  00498	4c 8b c8	 mov	 r9, rax
  0049b	41 b8 32 19 00
	00		 mov	 r8d, 6450		; 00001932H
  004a1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004a9	e8 00 00 00 00	 call	 _PyParallel_Guard
  004ae	85 c0		 test	 eax, eax
  004b0	75 73		 jne	 SHORT $LN35@initmodule
  004b2	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR inverted_registry
  004b9	48 89 2d 00 00
	00 00		 mov	 QWORD PTR inverted_registry, rbp
  004c0	e8 00 00 00 00	 call	 _Py_PXCTX
  004c5	85 c0		 test	 eax, eax
  004c7	75 5c		 jne	 SHORT $LN35@initmodule
  004c9	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  004cd	a8 20		 test	 al, 32			; 00000020H
  004cf	75 4c		 jne	 SHORT $LN112@initmodule
  004d1	84 c0		 test	 al, al
  004d3	78 48		 js	 SHORT $LN112@initmodule
  004d5	a8 02		 test	 al, 2
  004d7	75 4c		 jne	 SHORT $LN35@initmodule
  004d9	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  004dd	75 46		 jne	 SHORT $LN35@initmodule
  004df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  004e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  004ed	4c 8b cb	 mov	 r9, rbx
  004f0	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  004f6	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004fe	e8 00 00 00 00	 call	 _PyParallel_Guard
  00503	48 8b cb	 mov	 rcx, rbx
  00506	85 c0		 test	 eax, eax
  00508	74 07		 je	 SHORT $LN117@initmodule
  0050a	e8 00 00 00 00	 call	 _Px_Dealloc
  0050f	eb 14		 jmp	 SHORT $LN35@initmodule
$LN117@initmodule:
  00511	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00515	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0051b	eb 08		 jmp	 SHORT $LN35@initmodule
$LN112@initmodule:
  0051d	48 8b cb	 mov	 rcx, rbx
  00520	e8 00 00 00 00	 call	 Px_DecRef
$LN35@initmodule:

; 6451 :     Py_CLEAR(extension_cache);

  00525	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR extension_cache
  0052c	48 85 c0	 test	 rax, rax
  0052f	0f 84 9b 00 00
	00		 je	 $LN31@initmodule
  00535	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0053c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  00543	4c 8b c8	 mov	 r9, rax
  00546	41 b8 33 19 00
	00		 mov	 r8d, 6451		; 00001933H
  0054c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00554	e8 00 00 00 00	 call	 _PyParallel_Guard
  00559	85 c0		 test	 eax, eax
  0055b	75 73		 jne	 SHORT $LN31@initmodule
  0055d	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR extension_cache
  00564	48 89 2d 00 00
	00 00		 mov	 QWORD PTR extension_cache, rbp
  0056b	e8 00 00 00 00	 call	 _Py_PXCTX
  00570	85 c0		 test	 eax, eax
  00572	75 5c		 jne	 SHORT $LN31@initmodule
  00574	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00578	a8 20		 test	 al, 32			; 00000020H
  0057a	75 4c		 jne	 SHORT $LN123@initmodule
  0057c	84 c0		 test	 al, al
  0057e	78 48		 js	 SHORT $LN123@initmodule
  00580	a8 02		 test	 al, 2
  00582	75 4c		 jne	 SHORT $LN31@initmodule
  00584	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00588	75 46		 jne	 SHORT $LN31@initmodule
  0058a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00591	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00598	4c 8b cb	 mov	 r9, rbx
  0059b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  005a1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  005a9	e8 00 00 00 00	 call	 _PyParallel_Guard
  005ae	48 8b cb	 mov	 rcx, rbx
  005b1	85 c0		 test	 eax, eax
  005b3	74 07		 je	 SHORT $LN128@initmodule
  005b5	e8 00 00 00 00	 call	 _Px_Dealloc
  005ba	eb 14		 jmp	 SHORT $LN31@initmodule
$LN128@initmodule:
  005bc	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  005c0	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  005c6	eb 08		 jmp	 SHORT $LN31@initmodule
$LN123@initmodule:
  005c8	48 8b cb	 mov	 rcx, rbx
  005cb	e8 00 00 00 00	 call	 Px_DecRef
$LN31@initmodule:

; 6452 :     Py_CLEAR(compat_pickle);

  005d0	48 85 ff	 test	 rdi, rdi
  005d3	0f 84 8d 00 00
	00		 je	 $LN27@initmodule
  005d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  005e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  005e7	4c 8b cf	 mov	 r9, rdi
  005ea	41 b8 34 19 00
	00		 mov	 r8d, 6452		; 00001934H
  005f0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  005f8	e8 00 00 00 00	 call	 _PyParallel_Guard
  005fd	85 c0		 test	 eax, eax
  005ff	75 65		 jne	 SHORT $LN27@initmodule
  00601	e8 00 00 00 00	 call	 _Py_PXCTX
  00606	85 c0		 test	 eax, eax
  00608	75 5c		 jne	 SHORT $LN27@initmodule
  0060a	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0060e	a8 20		 test	 al, 32			; 00000020H
  00610	75 4c		 jne	 SHORT $LN134@initmodule
  00612	84 c0		 test	 al, al
  00614	78 48		 js	 SHORT $LN134@initmodule
  00616	a8 02		 test	 al, 2
  00618	75 4c		 jne	 SHORT $LN27@initmodule
  0061a	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0061e	75 46		 jne	 SHORT $LN27@initmodule
  00620	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00627	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0062e	4c 8b cf	 mov	 r9, rdi
  00631	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00637	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0063f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00644	48 8b cf	 mov	 rcx, rdi
  00647	85 c0		 test	 eax, eax
  00649	74 07		 je	 SHORT $LN139@initmodule
  0064b	e8 00 00 00 00	 call	 _Px_Dealloc
  00650	eb 14		 jmp	 SHORT $LN27@initmodule
$LN139@initmodule:
  00652	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00656	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0065c	eb 08		 jmp	 SHORT $LN27@initmodule
$LN134@initmodule:
  0065e	48 8b cf	 mov	 rcx, rdi
  00661	e8 00 00 00 00	 call	 Px_DecRef
$LN27@initmodule:

; 6453 :     Py_CLEAR(name_mapping_2to3);

  00666	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR name_mapping_2to3
  0066d	48 85 c0	 test	 rax, rax
  00670	0f 84 9b 00 00
	00		 je	 $LN23@initmodule
  00676	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0067d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  00684	4c 8b c8	 mov	 r9, rax
  00687	41 b8 35 19 00
	00		 mov	 r8d, 6453		; 00001935H
  0068d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00695	e8 00 00 00 00	 call	 _PyParallel_Guard
  0069a	85 c0		 test	 eax, eax
  0069c	75 73		 jne	 SHORT $LN23@initmodule
  0069e	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR name_mapping_2to3
  006a5	48 89 2d 00 00
	00 00		 mov	 QWORD PTR name_mapping_2to3, rbp
  006ac	e8 00 00 00 00	 call	 _Py_PXCTX
  006b1	85 c0		 test	 eax, eax
  006b3	75 5c		 jne	 SHORT $LN23@initmodule
  006b5	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  006b9	a8 20		 test	 al, 32			; 00000020H
  006bb	75 4c		 jne	 SHORT $LN145@initmodule
  006bd	84 c0		 test	 al, al
  006bf	78 48		 js	 SHORT $LN145@initmodule
  006c1	a8 02		 test	 al, 2
  006c3	75 4c		 jne	 SHORT $LN23@initmodule
  006c5	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  006c9	75 46		 jne	 SHORT $LN23@initmodule
  006cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  006d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  006d9	4c 8b cb	 mov	 r9, rbx
  006dc	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  006e2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  006ea	e8 00 00 00 00	 call	 _PyParallel_Guard
  006ef	48 8b cb	 mov	 rcx, rbx
  006f2	85 c0		 test	 eax, eax
  006f4	74 07		 je	 SHORT $LN150@initmodule
  006f6	e8 00 00 00 00	 call	 _Px_Dealloc
  006fb	eb 14		 jmp	 SHORT $LN23@initmodule
$LN150@initmodule:
  006fd	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00701	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00707	eb 08		 jmp	 SHORT $LN23@initmodule
$LN145@initmodule:
  00709	48 8b cb	 mov	 rcx, rbx
  0070c	e8 00 00 00 00	 call	 Px_DecRef
$LN23@initmodule:

; 6454 :     Py_CLEAR(import_mapping_2to3);

  00711	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR import_mapping_2to3
  00718	48 85 c0	 test	 rax, rax
  0071b	0f 84 9b 00 00
	00		 je	 $LN19@initmodule
  00721	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00728	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  0072f	4c 8b c8	 mov	 r9, rax
  00732	41 b8 36 19 00
	00		 mov	 r8d, 6454		; 00001936H
  00738	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00740	e8 00 00 00 00	 call	 _PyParallel_Guard
  00745	85 c0		 test	 eax, eax
  00747	75 73		 jne	 SHORT $LN19@initmodule
  00749	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR import_mapping_2to3
  00750	48 89 2d 00 00
	00 00		 mov	 QWORD PTR import_mapping_2to3, rbp
  00757	e8 00 00 00 00	 call	 _Py_PXCTX
  0075c	85 c0		 test	 eax, eax
  0075e	75 5c		 jne	 SHORT $LN19@initmodule
  00760	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00764	a8 20		 test	 al, 32			; 00000020H
  00766	75 4c		 jne	 SHORT $LN156@initmodule
  00768	84 c0		 test	 al, al
  0076a	78 48		 js	 SHORT $LN156@initmodule
  0076c	a8 02		 test	 al, 2
  0076e	75 4c		 jne	 SHORT $LN19@initmodule
  00770	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00774	75 46		 jne	 SHORT $LN19@initmodule
  00776	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0077d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00784	4c 8b cb	 mov	 r9, rbx
  00787	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0078d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00795	e8 00 00 00 00	 call	 _PyParallel_Guard
  0079a	48 8b cb	 mov	 rcx, rbx
  0079d	85 c0		 test	 eax, eax
  0079f	74 07		 je	 SHORT $LN161@initmodule
  007a1	e8 00 00 00 00	 call	 _Px_Dealloc
  007a6	eb 14		 jmp	 SHORT $LN19@initmodule
$LN161@initmodule:
  007a8	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  007ac	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  007b2	eb 08		 jmp	 SHORT $LN19@initmodule
$LN156@initmodule:
  007b4	48 8b cb	 mov	 rcx, rbx
  007b7	e8 00 00 00 00	 call	 Px_DecRef
$LN19@initmodule:

; 6455 :     Py_CLEAR(name_mapping_3to2);

  007bc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR name_mapping_3to2
  007c3	48 85 c0	 test	 rax, rax
  007c6	0f 84 9b 00 00
	00		 je	 $LN15@initmodule
  007cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  007d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  007da	4c 8b c8	 mov	 r9, rax
  007dd	41 b8 37 19 00
	00		 mov	 r8d, 6455		; 00001937H
  007e3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  007eb	e8 00 00 00 00	 call	 _PyParallel_Guard
  007f0	85 c0		 test	 eax, eax
  007f2	75 73		 jne	 SHORT $LN15@initmodule
  007f4	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR name_mapping_3to2
  007fb	48 89 2d 00 00
	00 00		 mov	 QWORD PTR name_mapping_3to2, rbp
  00802	e8 00 00 00 00	 call	 _Py_PXCTX
  00807	85 c0		 test	 eax, eax
  00809	75 5c		 jne	 SHORT $LN15@initmodule
  0080b	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0080f	a8 20		 test	 al, 32			; 00000020H
  00811	75 4c		 jne	 SHORT $LN167@initmodule
  00813	84 c0		 test	 al, al
  00815	78 48		 js	 SHORT $LN167@initmodule
  00817	a8 02		 test	 al, 2
  00819	75 4c		 jne	 SHORT $LN15@initmodule
  0081b	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0081f	75 46		 jne	 SHORT $LN15@initmodule
  00821	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00828	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0082f	4c 8b cb	 mov	 r9, rbx
  00832	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00838	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00840	e8 00 00 00 00	 call	 _PyParallel_Guard
  00845	48 8b cb	 mov	 rcx, rbx
  00848	85 c0		 test	 eax, eax
  0084a	74 07		 je	 SHORT $LN172@initmodule
  0084c	e8 00 00 00 00	 call	 _Px_Dealloc
  00851	eb 14		 jmp	 SHORT $LN15@initmodule
$LN172@initmodule:
  00853	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00857	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0085d	eb 08		 jmp	 SHORT $LN15@initmodule
$LN167@initmodule:
  0085f	48 8b cb	 mov	 rcx, rbx
  00862	e8 00 00 00 00	 call	 Px_DecRef
$LN15@initmodule:

; 6456 :     Py_CLEAR(import_mapping_3to2);

  00867	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR import_mapping_3to2
  0086e	48 85 c0	 test	 rax, rax
  00871	0f 84 9b 00 00
	00		 je	 $LN11@initmodule
  00877	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  0087e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  00885	4c 8b c8	 mov	 r9, rax
  00888	41 b8 38 19 00
	00		 mov	 r8d, 6456		; 00001938H
  0088e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00896	e8 00 00 00 00	 call	 _PyParallel_Guard
  0089b	85 c0		 test	 eax, eax
  0089d	75 73		 jne	 SHORT $LN11@initmodule
  0089f	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR import_mapping_3to2
  008a6	48 89 2d 00 00
	00 00		 mov	 QWORD PTR import_mapping_3to2, rbp
  008ad	e8 00 00 00 00	 call	 _Py_PXCTX
  008b2	85 c0		 test	 eax, eax
  008b4	75 5c		 jne	 SHORT $LN11@initmodule
  008b6	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  008ba	a8 20		 test	 al, 32			; 00000020H
  008bc	75 4c		 jne	 SHORT $LN178@initmodule
  008be	84 c0		 test	 al, al
  008c0	78 48		 js	 SHORT $LN178@initmodule
  008c2	a8 02		 test	 al, 2
  008c4	75 4c		 jne	 SHORT $LN11@initmodule
  008c6	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  008ca	75 46		 jne	 SHORT $LN11@initmodule
  008cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  008d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  008da	4c 8b cb	 mov	 r9, rbx
  008dd	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  008e3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  008eb	e8 00 00 00 00	 call	 _PyParallel_Guard
  008f0	48 8b cb	 mov	 rcx, rbx
  008f3	85 c0		 test	 eax, eax
  008f5	74 07		 je	 SHORT $LN183@initmodule
  008f7	e8 00 00 00 00	 call	 _Px_Dealloc
  008fc	eb 14		 jmp	 SHORT $LN11@initmodule
$LN183@initmodule:
  008fe	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00902	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00908	eb 08		 jmp	 SHORT $LN11@initmodule
$LN178@initmodule:
  0090a	48 8b cb	 mov	 rcx, rbx
  0090d	e8 00 00 00 00	 call	 Px_DecRef
$LN11@initmodule:

; 6457 :     Py_CLEAR(empty_tuple);

  00912	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR empty_tuple
  00919	48 85 c0	 test	 rax, rax
  0091c	0f 84 9b 00 00
	00		 je	 $LN7@initmodule
  00922	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  00929	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  00930	4c 8b c8	 mov	 r9, rax
  00933	41 b8 39 19 00
	00		 mov	 r8d, 6457		; 00001939H
  00939	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00941	e8 00 00 00 00	 call	 _PyParallel_Guard
  00946	85 c0		 test	 eax, eax
  00948	75 73		 jne	 SHORT $LN7@initmodule
  0094a	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR empty_tuple
  00951	48 89 2d 00 00
	00 00		 mov	 QWORD PTR empty_tuple, rbp
  00958	e8 00 00 00 00	 call	 _Py_PXCTX
  0095d	85 c0		 test	 eax, eax
  0095f	75 5c		 jne	 SHORT $LN7@initmodule
  00961	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00965	a8 20		 test	 al, 32			; 00000020H
  00967	75 4c		 jne	 SHORT $LN189@initmodule
  00969	84 c0		 test	 al, al
  0096b	78 48		 js	 SHORT $LN189@initmodule
  0096d	a8 02		 test	 al, 2
  0096f	75 4c		 jne	 SHORT $LN7@initmodule
  00971	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00975	75 46		 jne	 SHORT $LN7@initmodule
  00977	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0097e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00985	4c 8b cb	 mov	 r9, rbx
  00988	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0098e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00996	e8 00 00 00 00	 call	 _PyParallel_Guard
  0099b	48 8b cb	 mov	 rcx, rbx
  0099e	85 c0		 test	 eax, eax
  009a0	74 07		 je	 SHORT $LN194@initmodule
  009a2	e8 00 00 00 00	 call	 _Px_Dealloc
  009a7	eb 14		 jmp	 SHORT $LN7@initmodule
$LN194@initmodule:
  009a9	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  009ad	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  009b3	eb 08		 jmp	 SHORT $LN7@initmodule
$LN189@initmodule:
  009b5	48 8b cb	 mov	 rcx, rbx
  009b8	e8 00 00 00 00	 call	 Px_DecRef
$LN7@initmodule:

; 6458 :     Py_CLEAR(two_tuple);

  009bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR two_tuple
  009c4	48 85 c0	 test	 rax, rax
  009c7	0f 84 9b 00 00
	00		 je	 $LN3@initmodule
  009cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEFJBIHO@?4?4?2Modules?2_pickle?4c?$AA@
  009d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NCMCMGNH@initmodule?$AA@
  009db	4c 8b c8	 mov	 r9, rax
  009de	41 b8 3a 19 00
	00		 mov	 r8d, 6458		; 0000193aH
  009e4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  009ec	e8 00 00 00 00	 call	 _PyParallel_Guard
  009f1	85 c0		 test	 eax, eax
  009f3	75 73		 jne	 SHORT $LN3@initmodule
  009f5	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR two_tuple
  009fc	48 89 2d 00 00
	00 00		 mov	 QWORD PTR two_tuple, rbp
  00a03	e8 00 00 00 00	 call	 _Py_PXCTX
  00a08	85 c0		 test	 eax, eax
  00a0a	75 5c		 jne	 SHORT $LN3@initmodule
  00a0c	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00a10	a8 20		 test	 al, 32			; 00000020H
  00a12	75 4c		 jne	 SHORT $LN200@initmodule
  00a14	84 c0		 test	 al, al
  00a16	78 48		 js	 SHORT $LN200@initmodule
  00a18	a8 02		 test	 al, 2
  00a1a	75 4c		 jne	 SHORT $LN3@initmodule
  00a1c	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00a20	75 46		 jne	 SHORT $LN3@initmodule
  00a22	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00a29	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00a30	4c 8b cb	 mov	 r9, rbx
  00a33	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00a39	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00a41	e8 00 00 00 00	 call	 _PyParallel_Guard
  00a46	48 8b cb	 mov	 rcx, rbx
  00a49	85 c0		 test	 eax, eax
  00a4b	74 07		 je	 SHORT $LN205@initmodule
  00a4d	e8 00 00 00 00	 call	 _Px_Dealloc
  00a52	eb 14		 jmp	 SHORT $LN3@initmodule
$LN205@initmodule:
  00a54	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00a58	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00a5e	eb 08		 jmp	 SHORT $LN3@initmodule
$LN200@initmodule:
  00a60	48 8b cb	 mov	 rcx, rbx
  00a63	e8 00 00 00 00	 call	 Px_DecRef
$LN3@initmodule:

; 6459 :     return -1;

  00a68	83 c8 ff	 or	 eax, -1
$LN73@initmodule:

; 6460 : }

  00a6b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00a70	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00a75	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00a7a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00a7e	5f		 pop	 rdi
  00a7f	c3		 ret	 0
initmodule ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@LCGBPENE@UnpicklingError?$AA@		; `string'
PUBLIC	??_C@_0O@FPEIPGHK@PicklingError?$AA@		; `string'
PUBLIC	??_C@_0M@GKNHGKJD@PickleError?$AA@		; `string'
PUBLIC	??_C@_0BI@EPOMPDOP@_pickle?4UnpicklingError?$AA@ ; `string'
PUBLIC	??_C@_0BG@HEBJMGDJ@_pickle?4PicklingError?$AA@	; `string'
PUBLIC	??_C@_0BE@NFLINNFO@_pickle?4PickleError?$AA@	; `string'
PUBLIC	??_C@_09CHPAHJLJ@Unpickler?$AA@			; `string'
PUBLIC	??_C@_07JDLCLLMK@Pickler?$AA@			; `string'
PUBLIC	PyInit__pickle
EXTRN	PyErr_NewException:PROC
EXTRN	PyModule_AddObject:PROC
EXTRN	PyModule_Create2:PROC
EXTRN	PyType_Ready:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyInit__pickle DD imagerel $LN29
	DD	imagerel $LN29+103
	DD	imagerel $unwind$PyInit__pickle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyInit__pickle DD imagerel $LN29+103
	DD	imagerel $LN29+510
	DD	imagerel $chain$0$PyInit__pickle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyInit__pickle DD imagerel $LN29+510
	DD	imagerel $LN29+536
	DD	imagerel $chain$2$PyInit__pickle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyInit__pickle DD 020021H
	DD	063400H
	DD	imagerel $LN29
	DD	imagerel $LN29+103
	DD	imagerel $unwind$PyInit__pickle
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyInit__pickle DD 020521H
	DD	063405H
	DD	imagerel $LN29
	DD	imagerel $LN29+103
	DD	imagerel $unwind$PyInit__pickle
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__pickle DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0BA@LCGBPENE@UnpicklingError?$AA@
CONST	SEGMENT
??_C@_0BA@LCGBPENE@UnpicklingError?$AA@ DB 'UnpicklingError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FPEIPGHK@PicklingError?$AA@
CONST	SEGMENT
??_C@_0O@FPEIPGHK@PicklingError?$AA@ DB 'PicklingError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GKNHGKJD@PickleError?$AA@
CONST	SEGMENT
??_C@_0M@GKNHGKJD@PickleError?$AA@ DB 'PickleError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EPOMPDOP@_pickle?4UnpicklingError?$AA@
CONST	SEGMENT
??_C@_0BI@EPOMPDOP@_pickle?4UnpicklingError?$AA@ DB '_pickle.UnpicklingEr'
	DB	'ror', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HEBJMGDJ@_pickle?4PicklingError?$AA@
CONST	SEGMENT
??_C@_0BG@HEBJMGDJ@_pickle?4PicklingError?$AA@ DB '_pickle.PicklingError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NFLINNFO@_pickle?4PickleError?$AA@
CONST	SEGMENT
??_C@_0BE@NFLINNFO@_pickle?4PickleError?$AA@ DB '_pickle.PickleError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CHPAHJLJ@Unpickler?$AA@
CONST	SEGMENT
??_C@_09CHPAHJLJ@Unpickler?$AA@ DB 'Unpickler', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JDLCLLMK@Pickler?$AA@
CONST	SEGMENT
??_C@_07JDLCLLMK@Pickler?$AA@ DB 'Pickler', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT PyInit__pickle
_TEXT	SEGMENT
PyInit__pickle PROC					; COMDAT

; 6476 : {

$LN29:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6477 :     PyObject *m;
; 6478 : 
; 6479 :     if (PyType_Ready(&Unpickler_Type) < 0)

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Unpickler_Type
  0000b	e8 00 00 00 00	 call	 PyType_Ready
  00010	85 c0		 test	 eax, eax
  00012	79 07		 jns	 SHORT $LN15@PyInit__pi
$LN28@PyInit__pi:

; 6480 :         return NULL;

  00014	33 c0		 xor	 eax, eax

; 6523 :         return NULL;
; 6524 : 
; 6525 :     return m;
; 6526 : }

  00016	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001a	c3		 ret	 0
$LN15@PyInit__pi:

; 6481 :     if (PyType_Ready(&Pickler_Type) < 0)

  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Pickler_Type
  00022	e8 00 00 00 00	 call	 PyType_Ready
  00027	85 c0		 test	 eax, eax

; 6482 :         return NULL;

  00029	78 e9		 js	 SHORT $LN28@PyInit__pi

; 6483 :     if (PyType_Ready(&Pdata_Type) < 0)

  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Pdata_Type
  00032	e8 00 00 00 00	 call	 PyType_Ready
  00037	85 c0		 test	 eax, eax

; 6484 :         return NULL;

  00039	78 d9		 js	 SHORT $LN28@PyInit__pi

; 6485 :     if (PyType_Ready(&PicklerMemoProxyType) < 0)

  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PicklerMemoProxyType
  00042	e8 00 00 00 00	 call	 PyType_Ready
  00047	85 c0		 test	 eax, eax

; 6486 :         return NULL;

  00049	78 c9		 js	 SHORT $LN28@PyInit__pi

; 6487 :     if (PyType_Ready(&UnpicklerMemoProxyType) < 0)

  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UnpicklerMemoProxyType
  00052	e8 00 00 00 00	 call	 PyType_Ready
  00057	85 c0		 test	 eax, eax

; 6488 :         return NULL;

  00059	78 b9		 js	 SHORT $LN28@PyInit__pi

; 6489 : 
; 6490 :     /* Create the module and add the functions. */
; 6491 :     m = PyModule_Create(&_picklemodule);

  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_picklemodule
  00062	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00067	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0006c	e8 00 00 00 00	 call	 PyModule_Create2
  00071	48 8b d8	 mov	 rbx, rax

; 6492 :     if (m == NULL)

  00074	48 85 c0	 test	 rax, rax

; 6493 :         return NULL;

  00077	0f 84 75 01 00
	00		 je	 $LN27@PyInit__pi

; 6494 : 
; 6495 :     Py_INCREF(&Pickler_Type);

  0007d	e8 00 00 00 00	 call	 _Py_PXCTX
  00082	85 c0		 test	 eax, eax
  00084	75 3c		 jne	 SHORT $LN19@PyInit__pi
  00086	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:Pickler_Type
  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0009b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a1	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ae	85 c0		 test	 eax, eax
  000b0	75 09		 jne	 SHORT $LN18@PyInit__pi
  000b2	f6 05 20 00 00
	00 20		 test	 BYTE PTR Pickler_Type+32, 32 ; 00000020H
  000b9	74 07		 je	 SHORT $LN19@PyInit__pi
$LN18@PyInit__pi:
  000bb	48 ff 05 50 00
	00 00		 inc	 QWORD PTR Pickler_Type+80
$LN19@PyInit__pi:

; 6496 :     if (PyModule_AddObject(m, "Pickler", (PyObject *)&Pickler_Type) < 0)

  000c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:Pickler_Type
  000c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07JDLCLLMK@Pickler?$AA@
  000d0	48 8b cb	 mov	 rcx, rbx
  000d3	e8 00 00 00 00	 call	 PyModule_AddObject
  000d8	85 c0		 test	 eax, eax

; 6497 :         return NULL;

  000da	0f 88 12 01 00
	00		 js	 $LN27@PyInit__pi

; 6498 :     Py_INCREF(&Unpickler_Type);

  000e0	e8 00 00 00 00	 call	 _Py_PXCTX
  000e5	85 c0		 test	 eax, eax
  000e7	75 3c		 jne	 SHORT $LN23@PyInit__pi
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:Unpickler_Type
  000f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000fe	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00104	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0010c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00111	85 c0		 test	 eax, eax
  00113	75 09		 jne	 SHORT $LN22@PyInit__pi
  00115	f6 05 20 00 00
	00 20		 test	 BYTE PTR Unpickler_Type+32, 32 ; 00000020H
  0011c	74 07		 je	 SHORT $LN23@PyInit__pi
$LN22@PyInit__pi:
  0011e	48 ff 05 50 00
	00 00		 inc	 QWORD PTR Unpickler_Type+80
$LN23@PyInit__pi:

; 6499 :     if (PyModule_AddObject(m, "Unpickler", (PyObject *)&Unpickler_Type) < 0)

  00125	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:Unpickler_Type
  0012c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09CHPAHJLJ@Unpickler?$AA@
  00133	48 8b cb	 mov	 rcx, rbx
  00136	e8 00 00 00 00	 call	 PyModule_AddObject
  0013b	85 c0		 test	 eax, eax

; 6500 :         return NULL;

  0013d	0f 88 af 00 00
	00		 js	 $LN27@PyInit__pi

; 6501 : 
; 6502 :     /* Initialize the exceptions. */
; 6503 :     PickleError = PyErr_NewException("_pickle.PickleError", NULL, NULL);

  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@NFLINNFO@_pickle?4PickleError?$AA@
  0014a	45 33 c0	 xor	 r8d, r8d
  0014d	33 d2		 xor	 edx, edx
  0014f	e8 00 00 00 00	 call	 PyErr_NewException
  00154	48 89 05 00 00
	00 00		 mov	 QWORD PTR PickleError, rax

; 6504 :     if (PickleError == NULL)

  0015b	48 85 c0	 test	 rax, rax

; 6505 :         return NULL;

  0015e	0f 84 8e 00 00
	00		 je	 $LN27@PyInit__pi

; 6506 :     PicklingError = \
; 6507 :         PyErr_NewException("_pickle.PicklingError", PickleError, NULL);

  00164	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@HEBJMGDJ@_pickle?4PicklingError?$AA@
  0016b	45 33 c0	 xor	 r8d, r8d
  0016e	48 8b d0	 mov	 rdx, rax
  00171	e8 00 00 00 00	 call	 PyErr_NewException
  00176	48 89 05 00 00
	00 00		 mov	 QWORD PTR PicklingError, rax

; 6508 :     if (PicklingError == NULL)

  0017d	48 85 c0	 test	 rax, rax

; 6509 :         return NULL;

  00180	74 70		 je	 SHORT $LN27@PyInit__pi

; 6510 :     UnpicklingError = \
; 6511 :         PyErr_NewException("_pickle.UnpicklingError", PickleError, NULL);

  00182	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PickleError
  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EPOMPDOP@_pickle?4UnpicklingError?$AA@
  00190	45 33 c0	 xor	 r8d, r8d
  00193	e8 00 00 00 00	 call	 PyErr_NewException
  00198	48 89 05 00 00
	00 00		 mov	 QWORD PTR UnpicklingError, rax

; 6512 :     if (UnpicklingError == NULL)

  0019f	48 85 c0	 test	 rax, rax

; 6513 :         return NULL;

  001a2	74 4e		 je	 SHORT $LN27@PyInit__pi

; 6514 : 
; 6515 :     if (PyModule_AddObject(m, "PickleError", PickleError) < 0)

  001a4	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR PickleError
  001ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GKNHGKJD@PickleError?$AA@
  001b2	48 8b cb	 mov	 rcx, rbx
  001b5	e8 00 00 00 00	 call	 PyModule_AddObject
  001ba	85 c0		 test	 eax, eax

; 6516 :         return NULL;

  001bc	78 34		 js	 SHORT $LN27@PyInit__pi

; 6517 :     if (PyModule_AddObject(m, "PicklingError", PicklingError) < 0)

  001be	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR PicklingError
  001c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@FPEIPGHK@PicklingError?$AA@
  001cc	48 8b cb	 mov	 rcx, rbx
  001cf	e8 00 00 00 00	 call	 PyModule_AddObject
  001d4	85 c0		 test	 eax, eax

; 6518 :         return NULL;

  001d6	78 1a		 js	 SHORT $LN27@PyInit__pi

; 6519 :     if (PyModule_AddObject(m, "UnpicklingError", UnpicklingError) < 0)

  001d8	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR UnpicklingError
  001df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@LCGBPENE@UnpicklingError?$AA@
  001e6	48 8b cb	 mov	 rcx, rbx
  001e9	e8 00 00 00 00	 call	 PyModule_AddObject
  001ee	85 c0		 test	 eax, eax
  001f0	79 0c		 jns	 SHORT $LN2@PyInit__pi
$LN27@PyInit__pi:

; 6520 :         return NULL;

  001f2	33 c0		 xor	 eax, eax
  001f4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 6523 :         return NULL;
; 6524 : 
; 6525 :     return m;
; 6526 : }

  001f9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001fd	c3		 ret	 0
$LN2@PyInit__pi:

; 6521 : 
; 6522 :     if (initmodule() < 0)

  001fe	e8 00 00 00 00	 call	 initmodule
  00203	33 c9		 xor	 ecx, ecx
  00205	85 c0		 test	 eax, eax
  00207	48 0f 48 d9	 cmovs	 rbx, rcx
  0020b	48 8b c3	 mov	 rax, rbx
  0020e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 6523 :         return NULL;
; 6524 : 
; 6525 :     return m;
; 6526 : }

  00213	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00217	c3		 ret	 0
PyInit__pickle ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@CDNPLJMA@cannot?5serialize?5a?5bytes?5object?5@ ; `string'
PUBLIC	??_C@_07IDPMLOMJ@?$CIO?$CIOO?$CJ?$CJ?$AA@	; `string'
PUBLIC	??_C@_06CDEFMFPB@latin1?$AA@			; `string'
PUBLIC	??_C@_05GJDNHDMK@?$CIO?$CI?$CJ?$CJ?$AA@		; `string'
PUBLIC	??_C@_06GDGADLDP@encode?$AA@			; `string'
PUBLIC	??_C@_06PKGECIG@codecs?$AA@			; `string'
EXTRN	PyUnicode_DecodeLatin1:PROC
EXTRN	PyBytes_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_bytes DD imagerel save_bytes
	DD	imagerel save_bytes+116
	DD	imagerel $unwind$save_bytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$save_bytes DD imagerel save_bytes+116
	DD	imagerel save_bytes+275
	DD	imagerel $chain$0$save_bytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$save_bytes DD imagerel save_bytes+275
	DD	imagerel save_bytes+303
	DD	imagerel $chain$2$save_bytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$save_bytes DD imagerel save_bytes+303
	DD	imagerel save_bytes+506
	DD	imagerel $chain$3$save_bytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$save_bytes DD 021H
	DD	imagerel save_bytes
	DD	imagerel save_bytes+116
	DD	imagerel $unwind$save_bytes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$save_bytes DD 020021H
	DD	076400H
	DD	imagerel save_bytes
	DD	imagerel save_bytes+116
	DD	imagerel $unwind$save_bytes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$save_bytes DD 020521H
	DD	076405H
	DD	imagerel save_bytes
	DD	imagerel save_bytes+116
	DD	imagerel $unwind$save_bytes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_bytes DD 060f01H
	DD	09540fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0DC@CDNPLJMA@cannot?5serialize?5a?5bytes?5object?5@
CONST	SEGMENT
??_C@_0DC@CDNPLJMA@cannot?5serialize?5a?5bytes?5object?5@ DB 'cannot seri'
	DB	'alize a bytes object larger than 4 GiB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IDPMLOMJ@?$CIO?$CIOO?$CJ?$CJ?$AA@
CONST	SEGMENT
??_C@_07IDPMLOMJ@?$CIO?$CIOO?$CJ?$CJ?$AA@ DB '(O(OO))', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CDEFMFPB@latin1?$AA@
CONST	SEGMENT
??_C@_06CDEFMFPB@latin1?$AA@ DB 'latin1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GJDNHDMK@?$CIO?$CI?$CJ?$CJ?$AA@
CONST	SEGMENT
??_C@_05GJDNHDMK@?$CIO?$CI?$CJ?$CJ?$AA@ DB '(O())', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GDGADLDP@encode?$AA@
CONST	SEGMENT
??_C@_06GDGADLDP@encode?$AA@ DB 'encode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PKGECIG@codecs?$AA@
CONST	SEGMENT
??_C@_06PKGECIG@codecs?$AA@ DB 'codecs', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT save_bytes
_TEXT	SEGMENT
header$21573 = 48
self$ = 48
obj$ = 56
save_bytes PROC						; COMDAT

; 1709 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1710 :     if (self->proto < 3) {

  0000f	83 b9 a0 00 00
	00 03		 cmp	 DWORD PTR [rcx+160], 3
  00016	48 8b fa	 mov	 rdi, rdx
  00019	48 8b e9	 mov	 rbp, rcx
  0001c	0f 8d 0d 01 00
	00		 jge	 $LN19@save_bytes

; 1711 :         /* Older pickle protocols do not have an opcode for pickling bytes
; 1712 :            objects. Therefore, we need to fake the copy protocol (i.e.,
; 1713 :            the __reduce__ method) to permit bytes object unpickling.
; 1714 : 
; 1715 :            Here we use a hack to be compatible with Python 2. Since in Python
; 1716 :            2 'bytes' is just an alias for 'str' (which has different
; 1717 :            parameters than the actual bytes object), we use codecs.encode
; 1718 :            to create the appropriate 'str' object when unpickled using
; 1719 :            Python 2 *and* the appropriate 'bytes' object when unpickled
; 1720 :            using Python 3. Again this is a hack and we don't need to do this
; 1721 :            with newer protocols. */
; 1722 :         static PyObject *codecs_encode = NULL;
; 1723 :         PyObject *reduce_value = NULL;
; 1724 :         int status;
; 1725 : 
; 1726 :         if (codecs_encode == NULL) {

  00022	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?codecs_encode@?2??save_bytes@@9@9, 0
  0002a	75 44		 jne	 SHORT $LN16@save_bytes

; 1727 :             PyObject *codecs_module = PyImport_ImportModule("codecs");

  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06PKGECIG@codecs?$AA@
  00033	e8 00 00 00 00	 call	 PyImport_ImportModule
  00038	48 8b d8	 mov	 rbx, rax

; 1728 :             if (codecs_module == NULL) {

  0003b	48 85 c0	 test	 rax, rax

; 1729 :                 return -1;

  0003e	0f 84 a3 01 00
	00		 je	 $LN25@save_bytes

; 1730 :             }
; 1731 :             codecs_encode = PyObject_GetAttrString(codecs_module, "encode");

  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06GDGADLDP@encode?$AA@
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	e8 00 00 00 00	 call	 PyObject_GetAttrString

; 1732 :             Py_DECREF(codecs_module);

  00053	48 8b cb	 mov	 rcx, rbx
  00056	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?codecs_encode@?2??save_bytes@@9@9, rax
  0005d	e8 00 00 00 00	 call	 _Py_DecRef

; 1733 :             if (codecs_encode == NULL) {

  00062	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?codecs_encode@?2??save_bytes@@9@9, 0

; 1734 :                 return -1;

  0006a	0f 84 77 01 00
	00		 je	 $LN25@save_bytes
$LN16@save_bytes:

; 1735 :             }
; 1736 :         }
; 1737 : 
; 1738 :         if (PyBytes_GET_SIZE(obj) == 0) {

  00070	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]
  00074	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00079	48 85 d2	 test	 rdx, rdx
  0007c	75 18		 jne	 SHORT $LN15@save_bytes

; 1739 :             reduce_value = Py_BuildValue("(O())", (PyObject*)&PyBytes_Type);

  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyBytes_Type
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05GJDNHDMK@?$CIO?$CI?$CJ?$CJ?$AA@
  0008c	e8 00 00 00 00	 call	 Py_BuildValue
  00091	48 8b f0	 mov	 rsi, rax

; 1740 :         }
; 1741 :         else {

  00094	eb 60		 jmp	 SHORT $LN14@save_bytes
$LN15@save_bytes:

; 1742 :             static PyObject *latin1 = NULL;
; 1743 :             PyObject *unicode_str =
; 1744 :                 PyUnicode_DecodeLatin1(PyBytes_AS_STRING(obj),
; 1745 :                                        PyBytes_GET_SIZE(obj),
; 1746 :                                        "strict");

  00096	48 8d 4f 78	 lea	 rcx, QWORD PTR [rdi+120]
  0009a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  000a1	e8 00 00 00 00	 call	 PyUnicode_DecodeLatin1
  000a6	48 8b d8	 mov	 rbx, rax

; 1747 :             if (unicode_str == NULL)

  000a9	48 85 c0	 test	 rax, rax

; 1748 :                 return -1;

  000ac	74 4d		 je	 SHORT $LN24@save_bytes

; 1749 :             if (latin1 == NULL) {

  000ae	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?latin1@?7??save_bytes@@9@9
  000b5	48 85 c0	 test	 rax, rax
  000b8	75 18		 jne	 SHORT $LN11@save_bytes

; 1750 :                 latin1 = PyUnicode_InternFromString("latin1");

  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06CDEFMFPB@latin1?$AA@
  000c1	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  000c6	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?latin1@?7??save_bytes@@9@9, rax

; 1751 :                 if (latin1 == NULL)

  000cd	48 85 c0	 test	 rax, rax

; 1752 :                     return -1;

  000d0	74 29		 je	 SHORT $LN24@save_bytes
$LN11@save_bytes:

; 1753 :             }
; 1754 :             reduce_value = Py_BuildValue("(O(OO))",
; 1755 :                                          codecs_encode, unicode_str, latin1);

  000d2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?codecs_encode@?2??save_bytes@@9@9
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07IDPMLOMJ@?$CIO?$CIOO?$CJ?$CJ?$AA@
  000e0	4c 8b c8	 mov	 r9, rax
  000e3	4c 8b c3	 mov	 r8, rbx
  000e6	e8 00 00 00 00	 call	 Py_BuildValue

; 1756 :             Py_DECREF(unicode_str);

  000eb	48 8b cb	 mov	 rcx, rbx
  000ee	48 8b f0	 mov	 rsi, rax
  000f1	e8 00 00 00 00	 call	 _Py_DecRef
$LN14@save_bytes:

; 1757 :         }
; 1758 : 
; 1759 :         if (reduce_value == NULL)

  000f6	48 85 f6	 test	 rsi, rsi
  000f9	75 18		 jne	 SHORT $LN10@save_bytes
$LN24@save_bytes:

; 1760 :             return -1;

  000fb	83 c8 ff	 or	 eax, -1
$LN22@save_bytes:
  000fe	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 1802 :             return -1;
; 1803 : 
; 1804 :         return 0;
; 1805 :     }
; 1806 : }

  00103	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00108	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0010d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00111	5f		 pop	 rdi
  00112	c3		 ret	 0
$LN10@save_bytes:

; 1761 : 
; 1762 :         /* save_reduce() will memoize the object automatically. */
; 1763 :         status = save_reduce(self, reduce_value, obj);

  00113	4c 8b c7	 mov	 r8, rdi
  00116	48 8b d6	 mov	 rdx, rsi
  00119	48 8b cd	 mov	 rcx, rbp
  0011c	e8 00 00 00 00	 call	 save_reduce

; 1764 :         Py_DECREF(reduce_value);

  00121	48 8b ce	 mov	 rcx, rsi
  00124	8b d8		 mov	 ebx, eax
  00126	e8 00 00 00 00	 call	 _Py_DecRef

; 1765 :         return status;

  0012b	8b c3		 mov	 eax, ebx
  0012d	eb cf		 jmp	 SHORT $LN22@save_bytes
$LN19@save_bytes:

; 1766 :     }
; 1767 :     else {
; 1768 :         Py_ssize_t size;
; 1769 :         char header[5];
; 1770 :         Py_ssize_t len;
; 1771 : 
; 1772 :         size = PyBytes_GET_SIZE(obj);

  0012f	48 8b 5a 60	 mov	 rbx, QWORD PTR [rdx+96]

; 1773 :         if (size < 0)

  00133	48 85 db	 test	 rbx, rbx

; 1774 :             return -1;

  00136	0f 88 ab 00 00
	00		 js	 $LN25@save_bytes

; 1775 : 
; 1776 :         if (size < 256) {

  0013c	48 81 fb 00 01
	00 00		 cmp	 rbx, 256		; 00000100H
  00143	7d 0d		 jge	 SHORT $LN7@save_bytes

; 1777 :             header[0] = SHORT_BINBYTES;

  00145	c6 44 24 30 43	 mov	 BYTE PTR header$21573[rsp], 67 ; 00000043H

; 1778 :             header[1] = (unsigned char)size;
; 1779 :             len = 2;

  0014a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00150	eb 36		 jmp	 SHORT $LN23@save_bytes
$LN7@save_bytes:

; 1780 :         }
; 1781 :         else if (size <= 0xffffffffL) {

  00152	b8 ff ff ff ff	 mov	 eax, -1
  00157	48 3b d8	 cmp	 rbx, rax
  0015a	7f 78		 jg	 SHORT $LN5@save_bytes

; 1782 :             header[0] = BINBYTES;
; 1783 :             header[1] = (unsigned char)(size & 0xff);
; 1784 :             header[2] = (unsigned char)((size >> 8) & 0xff);

  0015c	48 8b c3	 mov	 rax, rbx
  0015f	c6 44 24 30 42	 mov	 BYTE PTR header$21573[rsp], 66 ; 00000042H

; 1785 :             header[3] = (unsigned char)((size >> 16) & 0xff);
; 1786 :             header[4] = (unsigned char)((size >> 24) & 0xff);
; 1787 :             len = 5;

  00164	41 b8 05 00 00
	00		 mov	 r8d, 5
  0016a	48 c1 f8 08	 sar	 rax, 8
  0016e	88 44 24 32	 mov	 BYTE PTR header$21573[rsp+2], al
  00172	48 8b c3	 mov	 rax, rbx
  00175	48 c1 f8 10	 sar	 rax, 16
  00179	88 44 24 33	 mov	 BYTE PTR header$21573[rsp+3], al
  0017d	48 8b c3	 mov	 rax, rbx
  00180	48 c1 f8 18	 sar	 rax, 24
  00184	88 44 24 34	 mov	 BYTE PTR header$21573[rsp+4], al
$LN23@save_bytes:

; 1792 :             return -1;          /* string too large */
; 1793 :         }
; 1794 : 
; 1795 :         if (_Pickler_Write(self, header, len) < 0)

  00188	48 8d 54 24 30	 lea	 rdx, QWORD PTR header$21573[rsp]
  0018d	88 5c 24 31	 mov	 BYTE PTR header$21573[rsp+1], bl
  00191	e8 00 00 00 00	 call	 _Pickler_Write
  00196	48 85 c0	 test	 rax, rax

; 1796 :             return -1;

  00199	78 4c		 js	 SHORT $LN25@save_bytes

; 1797 : 
; 1798 :         if (_Pickler_Write(self, PyBytes_AS_STRING(obj), size) < 0)

  0019b	48 8d 57 78	 lea	 rdx, QWORD PTR [rdi+120]
  0019f	4c 8b c3	 mov	 r8, rbx
  001a2	48 8b cd	 mov	 rcx, rbp
  001a5	e8 00 00 00 00	 call	 _Pickler_Write
  001aa	48 85 c0	 test	 rax, rax

; 1799 :             return -1;

  001ad	78 38		 js	 SHORT $LN25@save_bytes

; 1800 : 
; 1801 :         if (memo_put(self, obj) < 0)

  001af	48 8b d7	 mov	 rdx, rdi
  001b2	48 8b cd	 mov	 rcx, rbp
  001b5	e8 00 00 00 00	 call	 memo_put
  001ba	33 c9		 xor	 ecx, ecx
  001bc	85 c0		 test	 eax, eax
  001be	0f 99 c1	 setns	 cl
  001c1	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 1802 :             return -1;
; 1803 : 
; 1804 :         return 0;
; 1805 :     }
; 1806 : }

  001c4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001c9	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001ce	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001d2	5f		 pop	 rdi
  001d3	c3		 ret	 0
$LN5@save_bytes:

; 1788 :         }
; 1789 :         else {
; 1790 :             PyErr_SetString(PyExc_OverflowError,
; 1791 :                             "cannot serialize a bytes object larger than 4 GiB");

  001d4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  001db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@CDNPLJMA@cannot?5serialize?5a?5bytes?5object?5@
  001e2	e8 00 00 00 00	 call	 PyErr_SetString
$LN25@save_bytes:

; 1802 :             return -1;
; 1803 : 
; 1804 :         return 0;
; 1805 :     }
; 1806 : }

  001e7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001ec	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001f1	83 c8 ff	 or	 eax, -1
  001f4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001f8	5f		 pop	 rdi
  001f9	c3		 ret	 0
save_bytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_04LJHIBFLN@O?$CIO?$CJ?$AA@		; `string'
EXTRN	PyType_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_singleton_type DD imagerel save_singleton_type
	DD	imagerel save_singleton_type+109
	DD	imagerel $unwind$save_singleton_type
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_singleton_type DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_04LJHIBFLN@O?$CIO?$CJ?$AA@
CONST	SEGMENT
??_C@_04LJHIBFLN@O?$CIO?$CJ?$AA@ DB 'O(O)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT save_singleton_type
_TEXT	SEGMENT
self$ = 48
obj$ = 56
singleton$ = 64
save_singleton_type PROC				; COMDAT

; 2840 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b da	 mov	 rbx, rdx
  00012	48 8b f1	 mov	 rsi, rcx

; 2841 :     PyObject *reduce_value;
; 2842 :     int status;
; 2843 : 
; 2844 :     reduce_value = Py_BuildValue("O(O)", &PyType_Type, singleton);

  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyType_Type
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LJHIBFLN@O?$CIO?$CJ?$AA@
  00023	e8 00 00 00 00	 call	 Py_BuildValue
  00028	48 8b f8	 mov	 rdi, rax

; 2845 :     if (reduce_value == NULL) {

  0002b	48 85 c0	 test	 rax, rax
  0002e	75 13		 jne	 SHORT $LN1@save_singl

; 2846 :         return -1;

  00030	83 c8 ff	 or	 eax, -1

; 2850 :     return status;
; 2851 : }

  00033	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00038	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
$LN1@save_singl:

; 2847 :     }
; 2848 :     status = save_reduce(self, reduce_value, obj);

  00043	4c 8b c3	 mov	 r8, rbx
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8b ce	 mov	 rcx, rsi
  0004c	e8 00 00 00 00	 call	 save_reduce

; 2849 :     Py_DECREF(reduce_value);

  00051	48 8b cf	 mov	 rcx, rdi
  00054	8b d8		 mov	 ebx, eax
  00056	e8 00 00 00 00	 call	 _Py_DecRef

; 2850 :     return status;
; 2851 : }

  0005b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00060	8b c3		 mov	 eax, ebx
  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5f		 pop	 rdi
  0006c	c3		 ret	 0
save_singleton_type ENDP
_TEXT	ENDS
EXTRN	_PyNotImplemented_Type:BYTE
EXTRN	PyEllipsis_Type:BYTE
EXTRN	_PyNone_Type:BYTE
; Function compile flags: /Ogtpy
;	COMDAT save_type
_TEXT	SEGMENT
self$ = 8
obj$ = 16
save_type PROC						; COMDAT

; 2856 :     if (obj == (PyObject *)&_PyNone_Type) {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyNone_Type
  00007	48 3b d0	 cmp	 rdx, rax
  0000a	75 0c		 jne	 SHORT $LN5@save_type

; 2857 :         return save_singleton_type(self, obj, Py_None);

  0000c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct

; 2866 : }

  00013	e9 00 00 00 00	 jmp	 save_singleton_type
$LN5@save_type:

; 2858 :     }
; 2859 :     else if (obj == (PyObject *)&PyEllipsis_Type) {

  00018	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyEllipsis_Type
  0001f	48 3b d0	 cmp	 rdx, rax
  00022	75 0c		 jne	 SHORT $LN3@save_type

; 2860 :         return save_singleton_type(self, obj, Py_Ellipsis);

  00024	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_EllipsisObject

; 2866 : }

  0002b	e9 00 00 00 00	 jmp	 save_singleton_type
$LN3@save_type:

; 2861 :     }
; 2862 :     else if (obj == (PyObject *)&_PyNotImplemented_Type) {

  00030	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyNotImplemented_Type
  00037	48 3b d0	 cmp	 rdx, rax
  0003a	75 0c		 jne	 SHORT $LN1@save_type

; 2863 :         return save_singleton_type(self, obj, Py_NotImplemented);

  0003c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NotImplementedStruct

; 2866 : }

  00043	e9 00 00 00 00	 jmp	 save_singleton_type
$LN1@save_type:

; 2864 :     }
; 2865 :     return save_global(self, obj, NULL);

  00048	45 33 c0	 xor	 r8d, r8d

; 2866 : }

  0004b	e9 00 00 00 00	 jmp	 save_global
save_type ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@NPKDNCPF@__reduce__?5must?5return?5a?5string?5@ ; `string'
PUBLIC	??_C@_0CB@HIPCBBLL@can?8t?5pickle?5?8?$CF?4200s?8?5object?3?5?$CFR@ ; `string'
PUBLIC	??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@		; `string'
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyObject_GetItem:PROC
EXTRN	PyCFunction_Type:BYTE
EXTRN	PyFunction_Type:BYTE
EXTRN	PyTuple_Type:BYTE
EXTRN	PyFloat_Type:BYTE
EXTRN	PyLong_Type:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$save DD	imagerel save
	DD	imagerel save+103
	DD	imagerel $unwind$save
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$save DD imagerel save+103
	DD	imagerel save+1077
	DD	imagerel $chain$0$save
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$save DD imagerel save+1077
	DD	imagerel save+1395
	DD	imagerel $chain$1$save
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$save DD 021H
	DD	imagerel save
	DD	imagerel save+103
	DD	imagerel $unwind$save
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$save DD 020521H
	DD	0ae405H
	DD	imagerel save
	DD	imagerel save+103
	DD	imagerel $unwind$save
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save DD	0a1801H
	DD	0d6418H
	DD	0c5418H
	DD	0b3418H
	DD	0d0145218H
	DD	07010c012H
xdata	ENDS
;	COMDAT ??_C@_0CJ@NPKDNCPF@__reduce__?5must?5return?5a?5string?5@
CONST	SEGMENT
??_C@_0CJ@NPKDNCPF@__reduce__?5must?5return?5a?5string?5@ DB '__reduce__ '
	DB	'must return a string or tuple', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HIPCBBLL@can?8t?5pickle?5?8?$CF?4200s?8?5object?3?5?$CFR@
CONST	SEGMENT
??_C@_0CB@HIPCBBLL@can?8t?5pickle?5?8?$CF?4200s?8?5object?3?5?$CFR@ DB 'c'
	DB	'an''t pickle ''%.200s'' object: %R', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@
CONST	SEGMENT
??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@ DB '__reduce_ex__', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_pickle.c
CONST	ENDS
;	COMDAT save
_TEXT	SEGMENT
self$ = 80
obj$ = 88
pers_save$ = 96
save	PROC						; COMDAT

; 3137 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3138 :     PyTypeObject *type;
; 3139 :     PyObject *reduce_func = NULL;

  00018	45 33 e4	 xor	 r12d, r12d
  0001b	41 8b e8	 mov	 ebp, r8d
  0001e	48 8b da	 mov	 rbx, rdx

; 3140 :     PyObject *reduce_value = NULL;

  00021	45 8b ec	 mov	 r13d, r12d

; 3141 :     int status = 0;

  00024	41 8b fc	 mov	 edi, r12d
  00027	48 8b f1	 mov	 rsi, rcx

; 3142 : 
; 3143 :     if (Py_EnterRecursiveCall(" while pickling an object"))

  0002a	e8 00 00 00 00	 call	 _Py_PXCTX
  0002f	85 c0		 test	 eax, eax
  00031	74 07		 je	 SHORT $LN76@save
  00033	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00038	eb 07		 jmp	 SHORT $LN77@save
$LN76@save:
  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN77@save:
  00041	ff 40 18	 inc	 DWORD PTR [rax+24]
  00044	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00047	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  0004d	7e 18		 jle	 SHORT $LN73@save
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNMNDPHJ@?5while?5pickling?5an?5object?$AA@
  00056	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  0005b	85 c0		 test	 eax, eax
  0005d	74 08		 je	 SHORT $LN73@save

; 3144 :         return -1;

  0005f	83 c8 ff	 or	 eax, -1
  00062	e9 f3 04 00 00	 jmp	 $LN74@save
$LN73@save:
  00067	4c 89 74 24 50	 mov	 QWORD PTR [rsp+80], r14

; 3145 : 
; 3146 :     /* The extra pers_save argument is necessary to avoid calling save_pers()
; 3147 :        on its returned object. */
; 3148 :     if (!pers_save && self->pers_func) {

  0006c	85 ed		 test	 ebp, ebp
  0006e	75 1e		 jne	 SHORT $LN71@save
  00070	4c 8b 46 68	 mov	 r8, QWORD PTR [rsi+104]
  00074	4d 85 c0	 test	 r8, r8
  00077	74 15		 je	 SHORT $LN71@save

; 3149 :         /* save_pers() returns:
; 3150 :             -1   to signal an error;
; 3151 :              0   if it did nothing successfully;
; 3152 :              1   if a persistent id was saved.
; 3153 :          */
; 3154 :         if ((status = save_pers(self, obj, self->pers_func)) != 0)

  00079	48 8b d3	 mov	 rdx, rbx
  0007c	48 8b ce	 mov	 rcx, rsi
  0007f	e8 00 00 00 00	 call	 save_pers
  00084	8b f8		 mov	 edi, eax
  00086	85 c0		 test	 eax, eax
  00088	0f 85 99 03 00
	00		 jne	 $done$22534
$LN71@save:

; 3155 :             goto done;
; 3156 :     }
; 3157 : 
; 3158 :     type = Py_TYPE(obj);

  0008e	48 8b 6b 58	 mov	 rbp, QWORD PTR [rbx+88]

; 3159 : 
; 3160 :     /* The old cPickle had an optimization that used switch-case statement
; 3161 :        dispatching on the first letter of the type name.  This has was removed
; 3162 :        since benchmarks shown that this optimization was actually slowing
; 3163 :        things down. */
; 3164 : 
; 3165 :     /* Atom types; these aren't memoized, so don't check the memo. */
; 3166 : 
; 3167 :     if (obj == Py_None) {

  00092	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00099	48 3b d8	 cmp	 rbx, rax
  0009c	75 0d		 jne	 SHORT $LN70@save

; 3168 :         status = save_none(self, obj);

  0009e	48 8b ce	 mov	 rcx, rsi
  000a1	e8 00 00 00 00	 call	 save_none

; 3169 :         goto done;

  000a6	e9 7a 03 00 00	 jmp	 $LN108@save
$LN70@save:

; 3170 :     }
; 3171 :     else if (obj == Py_Ellipsis) {

  000ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_EllipsisObject
  000b2	48 3b d8	 cmp	 rbx, rax
  000b5	75 0d		 jne	 SHORT $LN68@save

; 3172 :         status = save_ellipsis(self, obj);

  000b7	48 8b ce	 mov	 rcx, rsi
  000ba	e8 00 00 00 00	 call	 save_ellipsis

; 3173 :         goto done;

  000bf	e9 61 03 00 00	 jmp	 $LN108@save
$LN68@save:

; 3174 :     }
; 3175 :     else if (obj == Py_NotImplemented) {

  000c4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000cb	48 3b d8	 cmp	 rbx, rax
  000ce	75 0d		 jne	 SHORT $LN66@save

; 3176 :         status = save_notimplemented(self, obj);

  000d0	48 8b ce	 mov	 rcx, rsi
  000d3	e8 00 00 00 00	 call	 save_notimplemented

; 3177 :         goto done;

  000d8	e9 48 03 00 00	 jmp	 $LN108@save
$LN66@save:

; 3178 :     }
; 3179 :     else if (obj == Py_False || obj == Py_True) {

  000dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  000e4	48 3b d8	 cmp	 rbx, rax
  000e7	0f 84 2d 03 00
	00		 je	 $LN63@save
  000ed	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  000f4	48 3b d8	 cmp	 rbx, rax
  000f7	0f 84 1d 03 00
	00		 je	 $LN63@save

; 3181 :         goto done;
; 3182 :     }
; 3183 :     else if (type == &PyLong_Type) {

  000fd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type

; 3184 :         status = save_long(self, obj);

  00104	48 8b d3	 mov	 rdx, rbx
  00107	48 3b e8	 cmp	 rbp, rax
  0010a	75 0d		 jne	 SHORT $LN61@save
  0010c	48 8b ce	 mov	 rcx, rsi
  0010f	e8 00 00 00 00	 call	 save_long

; 3185 :         goto done;

  00114	e9 0c 03 00 00	 jmp	 $LN108@save
$LN61@save:

; 3186 :     }
; 3187 :     else if (type == &PyFloat_Type) {

  00119	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00120	48 3b e8	 cmp	 rbp, rax
  00123	75 0d		 jne	 SHORT $LN59@save

; 3188 :         status = save_float(self, obj);

  00125	48 8b ce	 mov	 rcx, rsi
  00128	e8 00 00 00 00	 call	 save_float

; 3189 :         goto done;

  0012d	e9 f3 02 00 00	 jmp	 $LN108@save
$LN59@save:

; 3190 :     }
; 3191 : 
; 3192 :     /* Check the memo to see if it has the object. If so, generate
; 3193 :        a GET (or BINGET) opcode, instead of pickling the object
; 3194 :        once again. */
; 3195 :     if (PyMemoTable_Get(self->memo, obj)) {

  00132	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  00136	e8 00 00 00 00	 call	 PyMemoTable_Get
  0013b	48 85 c0	 test	 rax, rax
  0013e	74 18		 je	 SHORT $LN58@save

; 3196 :         if (memo_get(self, obj) < 0)

  00140	48 8b ce	 mov	 rcx, rsi
  00143	e8 00 00 00 00	 call	 memo_get
  00148	85 c0		 test	 eax, eax
  0014a	0f 89 d7 02 00
	00		 jns	 $done$22534
$error$22552:

; 3334 :   error:
; 3335 :         status = -1;

  00150	83 cf ff	 or	 edi, -1
  00153	e9 cf 02 00 00	 jmp	 $done$22534
$LN58@save:

; 3197 :             goto error;
; 3198 :         goto done;
; 3199 :     }
; 3200 : 
; 3201 :     if (type == &PyBytes_Type) {

  00158	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  0015f	48 3b e8	 cmp	 rbp, rax
  00162	75 0d		 jne	 SHORT $LN56@save

; 3202 :         status = save_bytes(self, obj);

  00164	48 8b ce	 mov	 rcx, rsi
  00167	e8 00 00 00 00	 call	 save_bytes

; 3203 :         goto done;

  0016c	e9 b4 02 00 00	 jmp	 $LN108@save
$LN56@save:

; 3204 :     }
; 3205 :     else if (type == &PyUnicode_Type) {

  00171	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00178	48 3b e8	 cmp	 rbp, rax
  0017b	75 0d		 jne	 SHORT $LN54@save

; 3206 :         status = save_unicode(self, obj);

  0017d	48 8b ce	 mov	 rcx, rsi
  00180	e8 00 00 00 00	 call	 save_unicode

; 3207 :         goto done;

  00185	e9 9b 02 00 00	 jmp	 $LN108@save
$LN54@save:

; 3208 :     }
; 3209 :     else if (type == &PyDict_Type) {

  0018a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00191	48 3b e8	 cmp	 rbp, rax
  00194	75 0d		 jne	 SHORT $LN52@save

; 3210 :         status = save_dict(self, obj);

  00196	48 8b ce	 mov	 rcx, rsi
  00199	e8 00 00 00 00	 call	 save_dict

; 3211 :         goto done;

  0019e	e9 82 02 00 00	 jmp	 $LN108@save
$LN52@save:

; 3212 :     }
; 3213 :     else if (type == &PyList_Type) {

  001a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyList_Type
  001aa	48 3b e8	 cmp	 rbp, rax
  001ad	75 0d		 jne	 SHORT $LN50@save

; 3214 :         status = save_list(self, obj);

  001af	48 8b ce	 mov	 rcx, rsi
  001b2	e8 00 00 00 00	 call	 save_list

; 3215 :         goto done;

  001b7	e9 69 02 00 00	 jmp	 $LN108@save
$LN50@save:

; 3216 :     }
; 3217 :     else if (type == &PyTuple_Type) {

  001bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_Type
  001c3	48 3b e8	 cmp	 rbp, rax
  001c6	75 0d		 jne	 SHORT $LN48@save

; 3218 :         status = save_tuple(self, obj);

  001c8	48 8b ce	 mov	 rcx, rsi
  001cb	e8 00 00 00 00	 call	 save_tuple

; 3219 :         goto done;

  001d0	e9 50 02 00 00	 jmp	 $LN108@save
$LN48@save:

; 3220 :     }
; 3221 :     else if (type == &PyType_Type) {

  001d5	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:PyType_Type
  001dc	49 3b ee	 cmp	 rbp, r14
  001df	75 0d		 jne	 SHORT $LN46@save

; 3222 :         status = save_type(self, obj);

  001e1	48 8b ce	 mov	 rcx, rsi
  001e4	e8 00 00 00 00	 call	 save_type

; 3223 :         goto done;

  001e9	e9 37 02 00 00	 jmp	 $LN108@save
$LN46@save:

; 3224 :     }
; 3225 :     else if (type == &PyFunction_Type) {

  001ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFunction_Type
  001f5	48 3b e8	 cmp	 rbp, rax
  001f8	0f 85 a7 00 00
	00		 jne	 $LN44@save

; 3226 :         status = save_global(self, obj, NULL);

  001fe	45 33 c0	 xor	 r8d, r8d
  00201	48 8b ce	 mov	 rcx, rsi
  00204	e8 00 00 00 00	 call	 save_global
  00209	8b f8		 mov	 edi, eax

; 3227 :         if (status < 0 && PyErr_ExceptionMatches(PickleError)) {

  0020b	85 c0		 test	 eax, eax
  0020d	0f 89 14 02 00
	00		 jns	 $done$22534
  00213	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PickleError
  0021a	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0021f	85 c0		 test	 eax, eax
  00221	0f 84 00 02 00
	00		 je	 $done$22534

; 3228 :             /* fall back to reduce */
; 3229 :             PyErr_Clear();

  00227	e8 00 00 00 00	 call	 PyErr_Clear
$LN40@save:

; 3238 :     }
; 3239 : 
; 3240 :     /* XXX: This part needs some unit tests. */
; 3241 : 
; 3242 :     /* Get a reduction callable, and call it.  This may come from
; 3243 :      * self.dispatch_table, copyreg.dispatch_table, the object's
; 3244 :      * __reduce_ex__ method, or the object's __reduce__ method.
; 3245 :      */
; 3246 :     if (self->dispatch_table == NULL) {

  0022c	48 8b 4e 70	 mov	 rcx, QWORD PTR [rsi+112]

; 3247 :         reduce_func = PyDict_GetItem(dispatch_table, (PyObject *)type);

  00230	48 8b d5	 mov	 rdx, rbp
  00233	48 85 c9	 test	 rcx, rcx
  00236	0f 85 89 00 00
	00		 jne	 $LN39@save
  0023c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dispatch_table
  00243	e8 00 00 00 00	 call	 PyDict_GetItem
  00248	4c 8b e0	 mov	 r12, rax

; 3248 :         /* PyDict_GetItem() unlike PyObject_GetItem() and
; 3249 :            PyObject_GetAttr() returns a borrowed ref */
; 3250 :         Py_XINCREF(reduce_func);

  0024b	48 85 c0	 test	 rax, rax
  0024e	0f 84 97 00 00
	00		 je	 $LN30@save
  00254	48 8b c8	 mov	 rcx, rax
  00257	e8 00 00 00 00	 call	 _Py_IncRef
$LN31@save:

; 3256 :             else
; 3257 :                 goto error;
; 3258 :         }
; 3259 :     }
; 3260 :     if (reduce_func != NULL) {
; 3261 :         Py_INCREF(obj);

  0025c	48 8b cb	 mov	 rcx, rbx
  0025f	e8 00 00 00 00	 call	 _Py_IncRef

; 3262 :         reduce_value = _Pickler_FastCall(self, reduce_func, obj);

  00264	4c 8b c3	 mov	 r8, rbx
$LN109@save:
  00267	49 8b d4	 mov	 rdx, r12
  0026a	48 8b ce	 mov	 rcx, rsi
  0026d	e8 00 00 00 00	 call	 _Pickler_FastCall
$LN110@save:
  00272	4c 8b e8	 mov	 r13, rax

; 3312 :                 goto error;
; 3313 :             }
; 3314 :         }
; 3315 :     }
; 3316 : 
; 3317 :     if (reduce_value == NULL)

  00275	48 85 c0	 test	 rax, rax
  00278	0f 84 d2 fe ff
	ff		 je	 $error$22552

; 3318 :         goto error;
; 3319 : 
; 3320 :     if (PyUnicode_Check(reduce_value)) {

  0027e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00282	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  00288	0f ba e1 1c	 bt	 ecx, 28
  0028c	0f 83 5a 01 00
	00		 jae	 $LN15@save

; 3321 :         status = save_global(self, obj, reduce_value);

  00292	4d 8b c5	 mov	 r8, r13
  00295	48 8b d3	 mov	 rdx, rbx
  00298	48 8b ce	 mov	 rcx, rsi
  0029b	e8 00 00 00 00	 call	 save_global

; 3322 :         goto done;

  002a0	e9 80 01 00 00	 jmp	 $LN108@save
$LN44@save:

; 3230 :         }
; 3231 :         else {
; 3232 :             goto done;
; 3233 :         }
; 3234 :     }
; 3235 :     else if (type == &PyCFunction_Type) {

  002a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyCFunction_Type
  002ac	48 3b e8	 cmp	 rbp, rax
  002af	0f 85 77 ff ff
	ff		 jne	 $LN40@save

; 3236 :         status = save_global(self, obj, NULL);

  002b5	45 33 c0	 xor	 r8d, r8d
  002b8	48 8b ce	 mov	 rcx, rsi
  002bb	e8 00 00 00 00	 call	 save_global

; 3237 :         goto done;

  002c0	e9 60 01 00 00	 jmp	 $LN108@save
$LN39@save:

; 3251 :     } else {
; 3252 :         reduce_func = PyObject_GetItem(self->dispatch_table, (PyObject *)type);

  002c5	e8 00 00 00 00	 call	 PyObject_GetItem
  002ca	4c 8b e0	 mov	 r12, rax

; 3253 :         if (reduce_func == NULL) {

  002cd	48 85 c0	 test	 rax, rax
  002d0	75 8a		 jne	 SHORT $LN31@save

; 3254 :             if (PyErr_ExceptionMatches(PyExc_KeyError))

  002d2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  002d9	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  002de	85 c0		 test	 eax, eax
  002e0	0f 84 6a fe ff
	ff		 je	 $error$22552

; 3255 :                 PyErr_Clear();

  002e6	e8 00 00 00 00	 call	 PyErr_Clear
$LN30@save:

; 3263 :     }
; 3264 :     else if (PyType_IsSubtype(type, &PyType_Type)) {

  002eb	49 8b d6	 mov	 rdx, r14
  002ee	48 8b cd	 mov	 rcx, rbp
  002f1	e8 00 00 00 00	 call	 PyType_IsSubtype
  002f6	85 c0		 test	 eax, eax
  002f8	74 13		 je	 SHORT $LN28@save

; 3265 :         status = save_global(self, obj, NULL);

  002fa	45 33 c0	 xor	 r8d, r8d
  002fd	48 8b d3	 mov	 rdx, rbx
  00300	48 8b ce	 mov	 rcx, rsi
  00303	e8 00 00 00 00	 call	 save_global

; 3266 :         goto done;

  00308	e9 18 01 00 00	 jmp	 $LN108@save
$LN28@save:

; 3267 :     }
; 3268 :     else {
; 3269 :         static PyObject *reduce_str = NULL;
; 3270 :         static PyObject *reduce_ex_str = NULL;
; 3271 : 
; 3272 :         /* Cache the name of the reduce methods. */
; 3273 :         if (reduce_str == NULL) {

  0030d	4c 39 2d 00 00
	00 00		 cmp	 QWORD PTR ?reduce_str@?BL@??save@@9@9, r13
  00314	75 3a		 jne	 SHORT $LN107@save

; 3274 :             reduce_str = PyUnicode_InternFromString("__reduce__");

  00316	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
  0031d	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00322	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?reduce_str@?BL@??save@@9@9, rax

; 3275 :             if (reduce_str == NULL)

  00329	48 85 c0	 test	 rax, rax
  0032c	0f 84 1e fe ff
	ff		 je	 $error$22552

; 3276 :                 goto error;
; 3277 :             reduce_ex_str = PyUnicode_InternFromString("__reduce_ex__");

  00332	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@
  00339	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0033e	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?reduce_ex_str@?BL@??save@@9@9, rax

; 3278 :             if (reduce_ex_str == NULL)

  00345	48 85 c0	 test	 rax, rax
  00348	0f 84 02 fe ff
	ff		 je	 $error$22552
  0034e	eb 07		 jmp	 SHORT $LN24@save
$LN107@save:
  00350	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?reduce_ex_str@?BL@??save@@9@9
$LN24@save:

; 3279 :                 goto error;
; 3280 :         }
; 3281 : 
; 3282 :         /* XXX: If the __reduce__ method is defined, __reduce_ex__ is
; 3283 :            automatically defined as __reduce__. While this is convenient, this
; 3284 :            make it impossible to know which method was actually called. Of
; 3285 :            course, this is not a big deal. But still, it would be nice to let
; 3286 :            the user know which method was called when something go
; 3287 :            wrong. Incidentally, this means if __reduce_ex__ is not defined, we
; 3288 :            don't actually have to check for a __reduce__ method. */
; 3289 : 
; 3290 :         /* Check for a __reduce_ex__ method. */
; 3291 :         reduce_func = PyObject_GetAttr(obj, reduce_ex_str);

  00357	48 8b d0	 mov	 rdx, rax
  0035a	48 8b cb	 mov	 rcx, rbx
  0035d	e8 00 00 00 00	 call	 PyObject_GetAttr
  00362	4c 8b e0	 mov	 r12, rax

; 3292 :         if (reduce_func != NULL) {

  00365	48 85 c0	 test	 rax, rax
  00368	74 1c		 je	 SHORT $LN23@save

; 3293 :             PyObject *proto;
; 3294 :             proto = PyLong_FromLong(self->proto);

  0036a	8b 8e a0 00 00
	00		 mov	 ecx, DWORD PTR [rsi+160]
  00370	e8 00 00 00 00	 call	 PyLong_FromLong

; 3295 :             if (proto != NULL) {

  00375	48 85 c0	 test	 rax, rax
  00378	0f 84 d2 fd ff
	ff		 je	 $error$22552

; 3296 :                 reduce_value = _Pickler_FastCall(self, reduce_func, proto);

  0037e	4c 8b c0	 mov	 r8, rax

; 3297 :             }
; 3298 :         }
; 3299 :         else {

  00381	e9 e1 fe ff ff	 jmp	 $LN109@save
$LN23@save:

; 3300 :             if (PyErr_ExceptionMatches(PyExc_AttributeError))

  00386	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0038d	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00392	85 c0		 test	 eax, eax
  00394	0f 84 b6 fd ff
	ff		 je	 $error$22552

; 3301 :                 PyErr_Clear();

  0039a	e8 00 00 00 00	 call	 PyErr_Clear

; 3302 :             else
; 3303 :                 goto error;
; 3304 :             /* Check for a __reduce__ method. */
; 3305 :             reduce_func = PyObject_GetAttr(obj, reduce_str);

  0039f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?reduce_str@?BL@??save@@9@9
  003a6	48 8b cb	 mov	 rcx, rbx
  003a9	e8 00 00 00 00	 call	 PyObject_GetAttr
  003ae	4c 8b e0	 mov	 r12, rax

; 3306 :             if (reduce_func != NULL) {

  003b1	48 85 c0	 test	 rax, rax
  003b4	74 17		 je	 SHORT $LN18@save

; 3307 :                 reduce_value = PyObject_Call(reduce_func, empty_tuple, NULL);

  003b6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR empty_tuple
  003bd	45 33 c0	 xor	 r8d, r8d
  003c0	48 8b c8	 mov	 rcx, rax
  003c3	e8 00 00 00 00	 call	 PyObject_Call
  003c8	e9 a5 fe ff ff	 jmp	 $LN110@save
$LN18@save:

; 3308 :             }
; 3309 :             else {
; 3310 :                 PyErr_Format(PicklingError, "can't pickle '%.200s' object: %R",
; 3311 :                              type->tp_name, obj);

  003cd	4c 8b 45 70	 mov	 r8, QWORD PTR [rbp+112]
  003d1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  003d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@HIPCBBLL@can?8t?5pickle?5?8?$CF?4200s?8?5object?3?5?$CFR@
  003df	4c 8b cb	 mov	 r9, rbx
  003e2	e8 00 00 00 00	 call	 PyErr_Format

; 3334 :   error:
; 3335 :         status = -1;

  003e7	83 cf ff	 or	 edi, -1
  003ea	eb 3b		 jmp	 SHORT $done$22534
$LN15@save:

; 3323 :     }
; 3324 : 
; 3325 :     if (!PyTuple_Check(reduce_value)) {

  003ec	0f ba e1 1a	 bt	 ecx, 26
  003f0	72 18		 jb	 SHORT $LN14@save

; 3326 :         PyErr_SetString(PicklingError,
; 3327 :                         "__reduce__ must return a string or tuple");

  003f2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  003f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@NPKDNCPF@__reduce__?5must?5return?5a?5string?5@
  00400	e8 00 00 00 00	 call	 PyErr_SetString

; 3334 :   error:
; 3335 :         status = -1;

  00405	83 cf ff	 or	 edi, -1
  00408	eb 1d		 jmp	 SHORT $done$22534
$LN14@save:

; 3328 :         goto error;
; 3329 :     }
; 3330 : 
; 3331 :     status = save_reduce(self, reduce_value, obj);

  0040a	4c 8b c3	 mov	 r8, rbx
  0040d	49 8b d5	 mov	 rdx, r13
  00410	48 8b ce	 mov	 rcx, rsi
  00413	e8 00 00 00 00	 call	 save_reduce

; 3332 : 
; 3333 :     if (0) {

  00418	eb 0b		 jmp	 SHORT $LN108@save
$LN63@save:

; 3180 :         status = save_bool(self, obj);

  0041a	48 8b d3	 mov	 rdx, rbx
  0041d	48 8b ce	 mov	 rcx, rsi
  00420	e8 00 00 00 00	 call	 save_bool
$LN108@save:
  00425	8b f8		 mov	 edi, eax
$done$22534:

; 3336 :     }
; 3337 :   done:
; 3338 :     Py_LeaveRecursiveCall();

  00427	e8 00 00 00 00	 call	 _Py_PXCTX
  0042c	4c 8b 74 24 50	 mov	 r14, QWORD PTR [rsp+80]
  00431	85 c0		 test	 eax, eax
  00433	74 0a		 je	 SHORT $LN78@save
  00435	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0043a	4c 8b d8	 mov	 r11, rax
  0043d	eb 07		 jmp	 SHORT $LN79@save
$LN78@save:
  0043f	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _PyThreadState_Current
$LN79@save:
  00446	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  0044c	83 f8 64	 cmp	 eax, 100		; 00000064H
  0044f	7e 05		 jle	 SHORT $LN80@save
  00451	83 c0 ce	 add	 eax, -50		; ffffffffffffffceH
  00454	eb 06		 jmp	 SHORT $LN81@save
$LN80@save:
  00456	c1 f8 02	 sar	 eax, 2
  00459	8d 04 40	 lea	 eax, DWORD PTR [rax+rax*2]
$LN81@save:
  0045c	41 ff 4b 18	 dec	 DWORD PTR [r11+24]
  00460	41 39 43 18	 cmp	 DWORD PTR [r11+24], eax
  00464	7d 1b		 jge	 SHORT $LN11@save
  00466	e8 00 00 00 00	 call	 _Py_PXCTX
  0046b	85 c0		 test	 eax, eax
  0046d	74 07		 je	 SHORT $LN82@save
  0046f	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00474	eb 07		 jmp	 SHORT $LN83@save
$LN82@save:
  00476	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN83@save:
  0047d	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN11@save:

; 3339 :     Py_XDECREF(reduce_func);

  00481	4d 85 e4	 test	 r12, r12
  00484	74 68		 je	 SHORT $LN7@save
  00486	e8 00 00 00 00	 call	 _Py_PXCTX
  0048b	85 c0		 test	 eax, eax
  0048d	75 5f		 jne	 SHORT $LN7@save
  0048f	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  00494	a8 20		 test	 al, 32			; 00000020H
  00496	75 4e		 jne	 SHORT $LN88@save
  00498	84 c0		 test	 al, al
  0049a	78 4a		 js	 SHORT $LN88@save
  0049c	a8 02		 test	 al, 2
  0049e	75 4e		 jne	 SHORT $LN7@save
  004a0	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  004a5	75 47		 jne	 SHORT $LN7@save
  004a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  004ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  004b5	4d 8b cc	 mov	 r9, r12
  004b8	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  004be	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004c6	e8 00 00 00 00	 call	 _PyParallel_Guard
  004cb	49 8b cc	 mov	 rcx, r12
  004ce	85 c0		 test	 eax, eax
  004d0	74 07		 je	 SHORT $LN93@save
  004d2	e8 00 00 00 00	 call	 _Px_Dealloc
  004d7	eb 15		 jmp	 SHORT $LN7@save
$LN93@save:
  004d9	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  004de	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  004e4	eb 08		 jmp	 SHORT $LN7@save
$LN88@save:
  004e6	49 8b cc	 mov	 rcx, r12
  004e9	e8 00 00 00 00	 call	 Px_DecRef
$LN7@save:

; 3340 :     Py_XDECREF(reduce_value);

  004ee	4d 85 ed	 test	 r13, r13
  004f1	74 65		 je	 SHORT $LN3@save
  004f3	e8 00 00 00 00	 call	 _Py_PXCTX
  004f8	85 c0		 test	 eax, eax
  004fa	75 5c		 jne	 SHORT $LN3@save
  004fc	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  00500	a8 20		 test	 al, 32			; 00000020H
  00502	75 4c		 jne	 SHORT $LN99@save
  00504	84 c0		 test	 al, al
  00506	78 48		 js	 SHORT $LN99@save
  00508	a8 02		 test	 al, 2
  0050a	75 4c		 jne	 SHORT $LN3@save
  0050c	49 ff 4d 50	 dec	 QWORD PTR [r13+80]
  00510	75 46		 jne	 SHORT $LN3@save
  00512	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00519	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00520	4d 8b cd	 mov	 r9, r13
  00523	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00529	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00531	e8 00 00 00 00	 call	 _PyParallel_Guard
  00536	49 8b cd	 mov	 rcx, r13
  00539	85 c0		 test	 eax, eax
  0053b	74 07		 je	 SHORT $LN104@save
  0053d	e8 00 00 00 00	 call	 _Px_Dealloc
  00542	eb 14		 jmp	 SHORT $LN3@save
$LN104@save:
  00544	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  00548	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0054e	eb 08		 jmp	 SHORT $LN3@save
$LN99@save:
  00550	49 8b cd	 mov	 rcx, r13
  00553	e8 00 00 00 00	 call	 Px_DecRef
$LN3@save:

; 3341 : 
; 3342 :     return status;

  00558	8b c7		 mov	 eax, edi
$LN74@save:

; 3343 : }

  0055a	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0055f	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00564	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00569	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0056d	41 5d		 pop	 r13
  0056f	41 5c		 pop	 r12
  00571	5f		 pop	 rdi
  00572	c3		 ret	 0
save	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dump DD	imagerel dump
	DD	imagerel dump+136
	DD	imagerel $unwind$dump
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dump DD	040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT dump
_TEXT	SEGMENT
stop_op$ = 48
self$ = 48
obj$ = 56
header$22652 = 64
dump	PROC						; COMDAT

; 3347 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3348 :     const char stop_op = STOP;
; 3349 : 
; 3350 :     if (self->proto >= 2) {

  0000a	83 b9 a0 00 00
	00 02		 cmp	 DWORD PTR [rcx+160], 2
  00011	48 8b fa	 mov	 rdi, rdx
  00014	48 8b d9	 mov	 rbx, rcx
  00017	c6 44 24 30 2e	 mov	 BYTE PTR stop_op$[rsp], 46 ; 0000002eH
  0001c	7c 25		 jl	 SHORT $LN3@dump

; 3351 :         char header[2];
; 3352 : 
; 3353 :         header[0] = PROTO;
; 3354 :         assert(self->proto >= 0 && self->proto < 256);
; 3355 :         header[1] = (unsigned char)self->proto;

  0001e	0f b6 81 a0 00
	00 00		 movzx	 eax, BYTE PTR [rcx+160]

; 3356 :         if (_Pickler_Write(self, header, 2) < 0)

  00025	48 8d 54 24 40	 lea	 rdx, QWORD PTR header$22652[rsp]
  0002a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00030	88 44 24 41	 mov	 BYTE PTR header$22652[rsp+1], al
  00034	c6 44 24 40 80	 mov	 BYTE PTR header$22652[rsp], -128 ; ffffffffffffff80H
  00039	e8 00 00 00 00	 call	 _Pickler_Write
  0003e	48 85 c0	 test	 rax, rax

; 3357 :             return -1;

  00041	78 37		 js	 SHORT $LN1@dump
$LN3@dump:

; 3358 :     }
; 3359 : 
; 3360 :     if (save(self, obj, 0) < 0 ||
; 3361 :         _Pickler_Write(self, &stop_op, 1) < 0)

  00043	45 33 c0	 xor	 r8d, r8d
  00046	48 8b d7	 mov	 rdx, rdi
  00049	48 8b cb	 mov	 rcx, rbx
  0004c	e8 00 00 00 00	 call	 save
  00051	85 c0		 test	 eax, eax
  00053	78 25		 js	 SHORT $LN1@dump
  00055	48 8d 54 24 30	 lea	 rdx, QWORD PTR stop_op$[rsp]
  0005a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00060	48 8b cb	 mov	 rcx, rbx
  00063	e8 00 00 00 00	 call	 _Pickler_Write
  00068	48 85 c0	 test	 rax, rax
  0006b	78 0d		 js	 SHORT $LN1@dump

; 3363 : 
; 3364 :     return 0;

  0006d	33 c0		 xor	 eax, eax

; 3365 : }

  0006f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
$LN1@dump:

; 3362 :         return -1;

  0007a	83 c8 ff	 or	 eax, -1

; 3365 : }

  0007d	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00082	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00086	5f		 pop	 rdi
  00087	c3		 ret	 0
dump	ENDP
_TEXT	ENDS
PUBLIC	??_C@_06CKFCKBHM@O?3dump?$AA@			; `string'
PUBLIC	??_C@_0DD@EIOLGLN@Pickler?4__init__?$CI?$CJ?5was?5not?5calle@ ; `string'
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Pickler_dump DD imagerel Pickler_dump
	DD	imagerel Pickler_dump+147
	DD	imagerel $unwind$Pickler_dump
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Pickler_dump DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_06CKFCKBHM@O?3dump?$AA@
CONST	SEGMENT
??_C@_06CKFCKBHM@O?3dump?$AA@ DB 'O:dump', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@EIOLGLN@Pickler?4__init__?$CI?$CJ?5was?5not?5calle@
CONST	SEGMENT
??_C@_0DD@EIOLGLN@Pickler?4__init__?$CI?$CJ?5was?5not?5calle@ DB 'Pickler'
	DB	'.__init__() was not called by %s.__init__()', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT Pickler_dump
_TEXT	SEGMENT
obj$ = 48
self$ = 48
args$ = 56
Pickler_dump PROC					; COMDAT

; 3389 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3390 :     PyObject *obj;
; 3391 : 
; 3392 :     /* Check whether the Pickler was initialized correctly (issue3664).
; 3393 :        Developers often forget to call __init__() in their subclasses, which
; 3394 :        would trigger a segfault without this check. */
; 3395 :     if (self->write == NULL) {

  00006	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  0000e	48 8b c2	 mov	 rax, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	75 23		 jne	 SHORT $LN5@Pickler_du

; 3396 :         PyErr_Format(PicklingError,
; 3397 :                      "Pickler.__init__() was not called by %s.__init__()",
; 3398 :                      Py_TYPE(self)->tp_name);

  00016	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  0001a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PicklingError
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@EIOLGLN@Pickler?4__init__?$CI?$CJ?5was?5not?5calle@
  00028	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0002c	e8 00 00 00 00	 call	 PyErr_Format
$LN8@Pickler_du:

; 3399 :         return NULL;

  00031	33 c0		 xor	 eax, eax

; 3415 : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5b		 pop	 rbx
  00038	c3		 ret	 0
$LN5@Pickler_du:

; 3400 :     }
; 3401 : 
; 3402 :     if (!PyArg_ParseTuple(args, "O:dump", &obj))

  00039	4c 8d 44 24 30	 lea	 r8, QWORD PTR obj$[rsp]
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06CKFCKBHM@O?3dump?$AA@
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0004d	85 c0		 test	 eax, eax

; 3403 :         return NULL;

  0004f	74 e0		 je	 SHORT $LN8@Pickler_du

; 3404 : 
; 3405 :     if (_Pickler_ClearBuffer(self) < 0)

  00051	48 8b cb	 mov	 rcx, rbx
  00054	e8 00 00 00 00	 call	 _Pickler_ClearBuffer
  00059	85 c0		 test	 eax, eax

; 3406 :         return NULL;

  0005b	78 d4		 js	 SHORT $LN8@Pickler_du

; 3407 : 
; 3408 :     if (dump(self, obj) < 0)

  0005d	48 8b 54 24 30	 mov	 rdx, QWORD PTR obj$[rsp]
  00062	48 8b cb	 mov	 rcx, rbx
  00065	e8 00 00 00 00	 call	 dump
  0006a	85 c0		 test	 eax, eax

; 3409 :         return NULL;

  0006c	78 c3		 js	 SHORT $LN8@Pickler_du

; 3410 : 
; 3411 :     if (_Pickler_FlushToFile(self) < 0)

  0006e	48 8b cb	 mov	 rcx, rbx
  00071	e8 00 00 00 00	 call	 _Pickler_FlushToFile
  00076	85 c0		 test	 eax, eax

; 3412 :         return NULL;

  00078	78 b7		 js	 SHORT $LN8@Pickler_du

; 3413 : 
; 3414 :     Py_RETURN_NONE;

  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00081	e8 00 00 00 00	 call	 _Py_IncRef
  00086	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 3415 : }

  0008d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00091	5b		 pop	 rbx
  00092	c3		 ret	 0
Pickler_dump ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@BAJCJOGK@OO?$HMOO?3dump?$AA@		; `string'
PUBLIC	??_C@_0DO@NPFJLKNJ@pickle?4dump?$CI?$CJ?5takes?5at?5most?53?5po@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pickle_dump DD imagerel pickle_dump
	DD	imagerel pickle_dump+136
	DD	imagerel $unwind$pickle_dump
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pickle_dump DD imagerel pickle_dump+136
	DD	imagerel pickle_dump+259
	DD	imagerel $chain$0$pickle_dump
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$pickle_dump DD imagerel pickle_dump+259
	DD	imagerel pickle_dump+279
	DD	imagerel $chain$2$pickle_dump
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$pickle_dump DD 020021H
	DD	0a3400H
	DD	imagerel pickle_dump
	DD	imagerel pickle_dump+136
	DD	imagerel $unwind$pickle_dump
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pickle_dump DD 020521H
	DD	0a3405H
	DD	imagerel pickle_dump
	DD	imagerel pickle_dump+136
	DD	imagerel $unwind$pickle_dump
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pickle_dump DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0L@BAJCJOGK@OO?$HMOO?3dump?$AA@
CONST	SEGMENT
??_C@_0L@BAJCJOGK@OO?$HMOO?3dump?$AA@ DB 'OO|OO:dump', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@NPFJLKNJ@pickle?4dump?$CI?$CJ?5takes?5at?5most?53?5po@
CONST	SEGMENT
??_C@_0DO@NPFJLKNJ@pickle?4dump?$CI?$CJ?5takes?5at?5most?53?5po@ DB 'pick'
	DB	'le.dump() takes at most 3 positional argument (%zd given)', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT pickle_dump
_TEXT	SEGMENT
file$ = 64
obj$ = 72
self$ = 96
fix_imports$ = 104
args$ = 104
kwds$ = 112
proto$ = 120
pickle_dump PROC					; COMDAT

; 6109 : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00004	4d 8b d0	 mov	 r10, r8

; 6110 :     static char *kwlist[] = {"obj", "file", "protocol", "fix_imports", 0};
; 6111 :     PyObject *obj;
; 6112 :     PyObject *file;
; 6113 :     PyObject *proto = NULL;
; 6114 :     PyObject *fix_imports = Py_True;
; 6115 :     PicklerObject *pickler;
; 6116 : 
; 6117 :     /* fix_imports is a keyword-only argument.  */
; 6118 :     if (Py_SIZE(args) > 3) {

  00007	4c 8b 42 60	 mov	 r8, QWORD PTR [rdx+96]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00012	48 8b c2	 mov	 rax, rdx
  00015	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR proto$[rsp], 0
  0001e	48 89 4c 24 68	 mov	 QWORD PTR fix_imports$[rsp], rcx
  00023	49 83 f8 03	 cmp	 r8, 3
  00027	7e 1a		 jle	 SHORT $LN11@pickle_dum

; 6119 :         PyErr_Format(PyExc_TypeError,
; 6120 :                      "pickle.dump() takes at most 3 positional "
; 6121 :                      "argument (%zd given)", Py_SIZE(args));

  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DO@NPFJLKNJ@pickle?4dump?$CI?$CJ?5takes?5at?5most?53?5po@
  00037	e8 00 00 00 00	 call	 PyErr_Format
$LN16@pickle_dum:

; 6122 :         return NULL;

  0003c	33 c0		 xor	 eax, eax

; 6151 : }

  0003e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00042	c3		 ret	 0
$LN11@pickle_dum:

; 6123 :     }
; 6124 : 
; 6125 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO|OO:dump", kwlist,
; 6126 :                                      &obj, &file, &proto, &fix_imports))

  00043	48 8d 4c 24 68	 lea	 rcx, QWORD PTR fix_imports$[rsp]
  00048	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pickle_dump@@9@9
  0004f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@BAJCJOGK@OO?$HMOO?3dump?$AA@
  00056	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0005b	48 8d 4c 24 78	 lea	 rcx, QWORD PTR proto$[rsp]
  00060	49 8b d2	 mov	 rdx, r10
  00063	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00068	48 8d 4c 24 40	 lea	 rcx, QWORD PTR file$[rsp]
  0006d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00072	48 8d 4c 24 48	 lea	 rcx, QWORD PTR obj$[rsp]
  00077	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0007c	48 8b c8	 mov	 rcx, rax
  0007f	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00084	85 c0		 test	 eax, eax

; 6127 :         return NULL;

  00086	74 b4		 je	 SHORT $LN16@pickle_dum

; 6128 : 
; 6129 :     pickler = _Pickler_New();

  00088	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0008d	e8 00 00 00 00	 call	 _Pickler_New
  00092	48 8b d8	 mov	 rbx, rax

; 6130 :     if (pickler == NULL)

  00095	48 85 c0	 test	 rax, rax

; 6131 :         return NULL;

  00098	74 71		 je	 SHORT $LN15@pickle_dum

; 6132 : 
; 6133 :     if (_Pickler_SetProtocol(pickler, proto, fix_imports) < 0)

  0009a	4c 8b 44 24 68	 mov	 r8, QWORD PTR fix_imports$[rsp]
  0009f	48 8b 54 24 78	 mov	 rdx, QWORD PTR proto$[rsp]
  000a4	48 8b c8	 mov	 rcx, rax
  000a7	e8 00 00 00 00	 call	 _Pickler_SetProtocol
  000ac	85 c0		 test	 eax, eax
  000ae	78 53		 js	 SHORT $error$24945

; 6134 :         goto error;
; 6135 : 
; 6136 :     if (_Pickler_SetOutputStream(pickler, file) < 0)

  000b0	48 8b 54 24 40	 mov	 rdx, QWORD PTR file$[rsp]
  000b5	48 8b cb	 mov	 rcx, rbx
  000b8	e8 00 00 00 00	 call	 _Pickler_SetOutputStream
  000bd	85 c0		 test	 eax, eax
  000bf	78 42		 js	 SHORT $error$24945

; 6137 :         goto error;
; 6138 : 
; 6139 :     if (dump(pickler, obj) < 0)

  000c1	48 8b 54 24 48	 mov	 rdx, QWORD PTR obj$[rsp]
  000c6	48 8b cb	 mov	 rcx, rbx
  000c9	e8 00 00 00 00	 call	 dump
  000ce	85 c0		 test	 eax, eax
  000d0	78 31		 js	 SHORT $error$24945

; 6140 :         goto error;
; 6141 : 
; 6142 :     if (_Pickler_FlushToFile(pickler) < 0)

  000d2	48 8b cb	 mov	 rcx, rbx
  000d5	e8 00 00 00 00	 call	 _Pickler_FlushToFile
  000da	85 c0		 test	 eax, eax
  000dc	78 25		 js	 SHORT $error$24945

; 6143 :         goto error;
; 6144 : 
; 6145 :     Py_DECREF(pickler);

  000de	48 8b cb	 mov	 rcx, rbx
  000e1	e8 00 00 00 00	 call	 _Py_DecRef

; 6146 :     Py_RETURN_NONE;

  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000ed	e8 00 00 00 00	 call	 _Py_IncRef
  000f2	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 6151 : }

  000fe	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00102	c3		 ret	 0
$error$24945:

; 6147 : 
; 6148 :   error:
; 6149 :     Py_XDECREF(pickler);

  00103	48 8b cb	 mov	 rcx, rbx
  00106	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@pickle_dum:

; 6150 :     return NULL;

  0010b	33 c0		 xor	 eax, eax
  0010d	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 6151 : }

  00112	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00116	c3		 ret	 0
pickle_dump ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@PLMAGPOP@O?$HMOO?3dumps?$AA@		; `string'
PUBLIC	??_C@_0DP@IGIBAAHF@pickle?4dumps?$CI?$CJ?5takes?5at?5most?52?5p@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pickle_dumps DD imagerel pickle_dumps
	DD	imagerel pickle_dumps+126
	DD	imagerel $unwind$pickle_dumps
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$pickle_dumps DD imagerel pickle_dumps+126
	DD	imagerel pickle_dumps+225
	DD	imagerel $chain$1$pickle_dumps
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$pickle_dumps DD imagerel pickle_dumps+225
	DD	imagerel pickle_dumps+245
	DD	imagerel $chain$3$pickle_dumps
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$pickle_dumps DD 020021H
	DD	0a7400H
	DD	imagerel pickle_dumps
	DD	imagerel pickle_dumps+126
	DD	imagerel $unwind$pickle_dumps
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$pickle_dumps DD 044121H
	DD	0c3441H
	DD	0a7405H
	DD	imagerel pickle_dumps
	DD	imagerel pickle_dumps+126
	DD	imagerel $unwind$pickle_dumps
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pickle_dumps DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0L@PLMAGPOP@O?$HMOO?3dumps?$AA@
CONST	SEGMENT
??_C@_0L@PLMAGPOP@O?$HMOO?3dumps?$AA@ DB 'O|OO:dumps', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@IGIBAAHF@pickle?4dumps?$CI?$CJ?5takes?5at?5most?52?5p@
CONST	SEGMENT
??_C@_0DP@IGIBAAHF@pickle?4dumps?$CI?$CJ?5takes?5at?5most?52?5p@ DB 'pick'
	DB	'le.dumps() takes at most 2 positional argument (%zd given)', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT pickle_dumps
_TEXT	SEGMENT
obj$ = 64
self$ = 96
fix_imports$ = 104
args$ = 104
kwds$ = 112
proto$ = 120
pickle_dumps PROC					; COMDAT

; 6173 : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00004	4d 8b d0	 mov	 r10, r8

; 6174 :     static char *kwlist[] = {"obj", "protocol", "fix_imports", 0};
; 6175 :     PyObject *obj;
; 6176 :     PyObject *proto = NULL;
; 6177 :     PyObject *result;
; 6178 :     PyObject *fix_imports = Py_True;
; 6179 :     PicklerObject *pickler;
; 6180 : 
; 6181 :     /* fix_imports is a keyword-only argument.  */
; 6182 :     if (Py_SIZE(args) > 2) {

  00007	4c 8b 42 60	 mov	 r8, QWORD PTR [rdx+96]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00012	48 8b c2	 mov	 rax, rdx
  00015	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR proto$[rsp], 0
  0001e	48 89 4c 24 68	 mov	 QWORD PTR fix_imports$[rsp], rcx
  00023	49 83 f8 02	 cmp	 r8, 2
  00027	7e 1a		 jle	 SHORT $LN9@pickle_dum@2

; 6183 :         PyErr_Format(PyExc_TypeError,
; 6184 :                      "pickle.dumps() takes at most 2 positional "
; 6185 :                      "argument (%zd given)", Py_SIZE(args));

  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DP@IGIBAAHF@pickle?4dumps?$CI?$CJ?5takes?5at?5most?52?5p@
  00037	e8 00 00 00 00	 call	 PyErr_Format
$LN14@pickle_dum@2:

; 6186 :         return NULL;

  0003c	33 c0		 xor	 eax, eax

; 6210 : }

  0003e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00042	c3		 ret	 0
$LN9@pickle_dum@2:

; 6187 :     }
; 6188 : 
; 6189 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|OO:dumps", kwlist,
; 6190 :                                      &obj, &proto, &fix_imports))

  00043	48 8d 4c 24 68	 lea	 rcx, QWORD PTR fix_imports$[rsp]
  00048	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pickle_dumps@@9@9
  0004f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@PLMAGPOP@O?$HMOO?3dumps?$AA@
  00056	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005b	48 8d 4c 24 78	 lea	 rcx, QWORD PTR proto$[rsp]
  00060	49 8b d2	 mov	 rdx, r10
  00063	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00068	48 8d 4c 24 40	 lea	 rcx, QWORD PTR obj$[rsp]
  0006d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0007a	85 c0		 test	 eax, eax

; 6191 :         return NULL;

  0007c	74 be		 je	 SHORT $LN14@pickle_dum@2

; 6192 : 
; 6193 :     pickler = _Pickler_New();

  0007e	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00083	e8 00 00 00 00	 call	 _Pickler_New
  00088	48 8b f8	 mov	 rdi, rax

; 6194 :     if (pickler == NULL)

  0008b	48 85 c0	 test	 rax, rax

; 6195 :         return NULL;

  0008e	74 59		 je	 SHORT $LN13@pickle_dum@2

; 6196 : 
; 6197 :     if (_Pickler_SetProtocol(pickler, proto, fix_imports) < 0)

  00090	4c 8b 44 24 68	 mov	 r8, QWORD PTR fix_imports$[rsp]
  00095	48 8b 54 24 78	 mov	 rdx, QWORD PTR proto$[rsp]
  0009a	48 8b c8	 mov	 rcx, rax
  0009d	e8 00 00 00 00	 call	 _Pickler_SetProtocol
  000a2	85 c0		 test	 eax, eax
  000a4	78 3b		 js	 SHORT $error$24987

; 6198 :         goto error;
; 6199 : 
; 6200 :     if (dump(pickler, obj) < 0)

  000a6	48 8b 54 24 40	 mov	 rdx, QWORD PTR obj$[rsp]
  000ab	48 8b cf	 mov	 rcx, rdi
  000ae	e8 00 00 00 00	 call	 dump
  000b3	85 c0		 test	 eax, eax
  000b5	78 2a		 js	 SHORT $error$24987

; 6201 :         goto error;
; 6202 : 
; 6203 :     result = _Pickler_GetString(pickler);

  000b7	48 8b cf	 mov	 rcx, rdi
  000ba	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  000bf	e8 00 00 00 00	 call	 _Pickler_GetString

; 6204 :     Py_DECREF(pickler);

  000c4	48 8b cf	 mov	 rcx, rdi
  000c7	48 8b d8	 mov	 rbx, rax
  000ca	e8 00 00 00 00	 call	 _Py_DecRef
  000cf	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 6205 :     return result;

  000d4	48 8b c3	 mov	 rax, rbx
  000d7	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 6210 : }

  000dc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e0	c3		 ret	 0
$error$24987:

; 6206 : 
; 6207 :   error:
; 6208 :     Py_XDECREF(pickler);

  000e1	48 8b cf	 mov	 rcx, rdi
  000e4	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@pickle_dum@2:

; 6209 :     return NULL;

  000e9	33 c0		 xor	 eax, eax
  000eb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 6210 : }

  000f0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f4	c3		 ret	 0
pickle_dumps ENDP
_TEXT	ENDS
END
