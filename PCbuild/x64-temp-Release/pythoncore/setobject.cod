; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_09FNPENIBB@frozenset?$AA@			; `string'
PUBLIC	??_C@_03KCHOJKKI@set?$AA@			; `string'
PUBLIC	??_C@_06HDLLMMEJ@update?$AA@			; `string'
PUBLIC	??_C@_05MNALHJLP@union?$AA@			; `string'
PUBLIC	??_C@_0BM@OJODNHLP@symmetric_difference_update?$AA@ ; `string'
PUBLIC	??_C@_0BF@NMFMJDIP@symmetric_difference?$AA@	; `string'
PUBLIC	??_C@_0L@HOGGIPGN@__sizeof__?$AA@		; `string'
PUBLIC	??_C@_06LEMKAMD@remove?$AA@			; `string'
PUBLIC	??_C@_03NJDAHFJE@pop?$AA@			; `string'
PUBLIC	??_C@_0L@MEIHPPPH@issuperset?$AA@		; `string'
PUBLIC	??_C@_08NCLBICHP@issubset?$AA@			; `string'
PUBLIC	??_C@_0L@EMANFHEK@isdisjoint?$AA@		; `string'
PUBLIC	??_C@_0BE@EMPOGGNJ@intersection_update?$AA@	; `string'
PUBLIC	??_C@_0N@JIFGGPLM@intersection?$AA@		; `string'
PUBLIC	??_C@_0BC@LNEPHBNC@difference_update?$AA@	; `string'
PUBLIC	??_C@_0L@CHCOIIBP@difference?$AA@		; `string'
PUBLIC	??_C@_07FGAIHHOI@discard?$AA@			; `string'
PUBLIC	??_C@_04COAGEIMF@copy?$AA@			; `string'
PUBLIC	??_C@_0N@MCIOADFH@__contains__?$AA@		; `string'
PUBLIC	??_C@_05MEHLAELG@clear?$AA@			; `string'
PUBLIC	??_C@_03BDGOHNNK@add?$AA@			; `string'
PUBLIC	??_C@_08IBFKALI@__dict__?$AA@			; `string'
PUBLIC	??_C@_0N@BIJDNHNJ@set_iterator?$AA@		; `string'
PUBLIC	??_C@_0L@NNMACJIG@__reduce__?$AA@		; `string'
PUBLIC	??_C@_0BA@BJLPBKGK@__length_hint__?$AA@		; `string'
PUBLIC	PySetIter_Type
PUBLIC	PySet_Type
PUBLIC	PyFrozenSet_Type
EXTRN	PyObject_GC_Del:PROC
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyObject_HashNotImplemented:PROC
EXTRN	PyObject_SelfIter:PROC
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	PyType_Type:BYTE
_BSS	SEGMENT
dummy	DQ	01H DUP (?)
numfree	DD	01H DUP (?)
	ALIGN	8

emptyfrozenset DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_09FNPENIBB@frozenset?$AA@
CONST	SEGMENT
??_C@_09FNPENIBB@frozenset?$AA@ DB 'frozenset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03KCHOJKKI@set?$AA@
CONST	SEGMENT
??_C@_03KCHOJKKI@set?$AA@ DB 'set', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06HDLLMMEJ@update?$AA@
CONST	SEGMENT
??_C@_06HDLLMMEJ@update?$AA@ DB 'update', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MNALHJLP@union?$AA@
CONST	SEGMENT
??_C@_05MNALHJLP@union?$AA@ DB 'union', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OJODNHLP@symmetric_difference_update?$AA@
CONST	SEGMENT
??_C@_0BM@OJODNHLP@symmetric_difference_update?$AA@ DB 'symmetric_differe'
	DB	'nce_update', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NMFMJDIP@symmetric_difference?$AA@
CONST	SEGMENT
??_C@_0BF@NMFMJDIP@symmetric_difference?$AA@ DB 'symmetric_difference', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGGIPGN@__sizeof__?$AA@
CONST	SEGMENT
??_C@_0L@HOGGIPGN@__sizeof__?$AA@ DB '__sizeof__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LEMKAMD@remove?$AA@
CONST	SEGMENT
??_C@_06LEMKAMD@remove?$AA@ DB 'remove', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJDAHFJE@pop?$AA@
CONST	SEGMENT
??_C@_03NJDAHFJE@pop?$AA@ DB 'pop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MEIHPPPH@issuperset?$AA@
CONST	SEGMENT
??_C@_0L@MEIHPPPH@issuperset?$AA@ DB 'issuperset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NCLBICHP@issubset?$AA@
CONST	SEGMENT
??_C@_08NCLBICHP@issubset?$AA@ DB 'issubset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EMANFHEK@isdisjoint?$AA@
CONST	SEGMENT
??_C@_0L@EMANFHEK@isdisjoint?$AA@ DB 'isdisjoint', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMPOGGNJ@intersection_update?$AA@
CONST	SEGMENT
??_C@_0BE@EMPOGGNJ@intersection_update?$AA@ DB 'intersection_update', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JIFGGPLM@intersection?$AA@
CONST	SEGMENT
??_C@_0N@JIFGGPLM@intersection?$AA@ DB 'intersection', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LNEPHBNC@difference_update?$AA@
CONST	SEGMENT
??_C@_0BC@LNEPHBNC@difference_update?$AA@ DB 'difference_update', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CHCOIIBP@difference?$AA@
CONST	SEGMENT
??_C@_0L@CHCOIIBP@difference?$AA@ DB 'difference', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07FGAIHHOI@discard?$AA@
CONST	SEGMENT
??_C@_07FGAIHHOI@discard?$AA@ DB 'discard', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04COAGEIMF@copy?$AA@
CONST	SEGMENT
??_C@_04COAGEIMF@copy?$AA@ DB 'copy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MCIOADFH@__contains__?$AA@
CONST	SEGMENT
??_C@_0N@MCIOADFH@__contains__?$AA@ DB '__contains__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEHLAELG@clear?$AA@
CONST	SEGMENT
??_C@_05MEHLAELG@clear?$AA@ DB 'clear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BDGOHNNK@add?$AA@
CONST	SEGMENT
??_C@_03BDGOHNNK@add?$AA@ DB 'add', 00H			; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId___dict__@?1??set_reduce@@9@9 DQ 0000000000000000H	; `set_reduce'::`2'::PyId___dict__
	DQ	FLAT:??_C@_08IBFKALI@__dict__?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_08IBFKALI@__dict__?$AA@
CONST	SEGMENT
??_C@_08IBFKALI@__dict__?$AA@ DB '__dict__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BIJDNHNJ@set_iterator?$AA@
CONST	SEGMENT
??_C@_0N@BIJDNHNJ@set_iterator?$AA@ DB 'set_iterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNMACJIG@__reduce__?$AA@
CONST	SEGMENT
??_C@_0L@NNMACJIG@__reduce__?$AA@ DB '__reduce__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
CONST	SEGMENT
??_C@_0BA@BJLPBKGK@__length_hint__?$AA@ DB '__length_hint__', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
pop_doc	DB	'Remove and return an arbitrary set element.', 0aH, 'Rais'
	DB	'es KeyError if the set is empty.', 00H
	ORG $+7
length_hint_doc DB 'Private method returning an estimate of len(list(it))'
	DB	'.', 00H
	ORG $+1
reduce_doc DB	'Return state information for pickling.', 00H
	ORG $+9
setiter_methods DQ FLAT:??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
	DQ	FLAT:setiter_len
	DD	04H
	ORG $+4
	DQ	FLAT:length_hint_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:setiter_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
PySetIter_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0N@BIJDNHNJ@set_iterator?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:setiter_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:setiter_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:setiter_iternext
	DQ	FLAT:setiter_methods
	DQ	0000000000000000H
	ORG $+144
update_doc DB	'Update a set with the union of itself and others.', 00H
	ORG $+6
copy_doc DB	'Return a shallow copy of a set.', 00H
clear_doc DB	'Remove all elements from this set.', 00H
	ORG $+5
union_doc DB	'Return the union of sets as a new set.', 0aH, 0aH, '(i.e'
	DB	'. all elements that are in either set.)', 00H
	ORG $+12
intersection_doc DB 'Return the intersection of two sets as a new set.', 0aH
	DB	0aH, '(i.e. all elements that are in both sets.)', 00H
	ORG $+2
intersection_update_doc DB 'Update a set with the intersection of itself '
	DB	'and another.', 00H
	ORG $+6
isdisjoint_doc DB 'Return True if two sets have a null intersection.', 00H
	ORG $+6
difference_update_doc DB 'Remove all elements of another set from this se'
	DB	't.', 00H
	ORG $+6
difference_doc DB 'Return the difference of two or more sets as a new set'
	DB	'.', 0aH, 0aH, '(i.e. all elements that are in this set but no'
	DB	't the others.)', 00H
	ORG $+10
symmetric_difference_update_doc DB 'Update a set with the symmetric diffe'
	DB	'rence of itself and another.', 00H
	ORG $+14
symmetric_difference_doc DB 'Return the symmetric difference of two sets '
	DB	'as a new set.', 0aH, 0aH, '(i.e. all elements that are in exa'
	DB	'ctly one of the sets.)', 00H
	ORG $+4
issubset_doc DB	'Report whether another set contains this set.', 00H
	ORG $+2
issuperset_doc DB 'Report whether this set contains another set.', 00H
	ORG $+10
add_doc	DB	'Add an element to a set.', 0aH, 0aH, 'This has no effect'
	DB	' if the element is already present.', 00H
contains_doc DB	'x.__contains__(y) <==> y in x.', 00H
	ORG $+1
remove_doc DB	'Remove an element from a set; it must be a member.', 0aH
	DB	0aH, 'If the element is not a member, raise a KeyError.', 00H
	ORG $+10
discard_doc DB	'Remove an element from a set if it is a member.', 0aH, 0aH
	DB	'If the element is not a member, do nothing.', 00H
	ORG $+3
sizeof_doc DB	'S.__sizeof__() -> size of S in memory, in bytes', 00H
set_as_sequence DQ FLAT:set_len
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:set_contains
	ORG $+16
set_methods DQ	FLAT:??_C@_03BDGOHNNK@add?$AA@
	DQ	FLAT:set_add
	DD	08H
	ORG $+4
	DQ	FLAT:add_doc
	DQ	FLAT:??_C@_05MEHLAELG@clear?$AA@
	DQ	FLAT:set_clear
	DD	04H
	ORG $+4
	DQ	FLAT:clear_doc
	DQ	FLAT:??_C@_0N@MCIOADFH@__contains__?$AA@
	DQ	FLAT:set_direct_contains
	DD	048H
	ORG $+4
	DQ	FLAT:contains_doc
	DQ	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DQ	FLAT:set_copy
	DD	04H
	ORG $+4
	DQ	FLAT:copy_doc
	DQ	FLAT:??_C@_07FGAIHHOI@discard?$AA@
	DQ	FLAT:set_discard
	DD	08H
	ORG $+4
	DQ	FLAT:discard_doc
	DQ	FLAT:??_C@_0L@CHCOIIBP@difference?$AA@
	DQ	FLAT:set_difference_multi
	DD	01H
	ORG $+4
	DQ	FLAT:difference_doc
	DQ	FLAT:??_C@_0BC@LNEPHBNC@difference_update?$AA@
	DQ	FLAT:set_difference_update
	DD	01H
	ORG $+4
	DQ	FLAT:difference_update_doc
	DQ	FLAT:??_C@_0N@JIFGGPLM@intersection?$AA@
	DQ	FLAT:set_intersection_multi
	DD	01H
	ORG $+4
	DQ	FLAT:intersection_doc
	DQ	FLAT:??_C@_0BE@EMPOGGNJ@intersection_update?$AA@
	DQ	FLAT:set_intersection_update_multi
	DD	01H
	ORG $+4
	DQ	FLAT:intersection_update_doc
	DQ	FLAT:??_C@_0L@EMANFHEK@isdisjoint?$AA@
	DQ	FLAT:set_isdisjoint
	DD	08H
	ORG $+4
	DQ	FLAT:isdisjoint_doc
	DQ	FLAT:??_C@_08NCLBICHP@issubset?$AA@
	DQ	FLAT:set_issubset
	DD	08H
	ORG $+4
	DQ	FLAT:issubset_doc
	DQ	FLAT:??_C@_0L@MEIHPPPH@issuperset?$AA@
	DQ	FLAT:set_issuperset
	DD	08H
	ORG $+4
	DQ	FLAT:issuperset_doc
	DQ	FLAT:??_C@_03NJDAHFJE@pop?$AA@
	DQ	FLAT:set_pop
	DD	04H
	ORG $+4
	DQ	FLAT:pop_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:set_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_06LEMKAMD@remove?$AA@
	DQ	FLAT:set_remove
	DD	08H
	ORG $+4
	DQ	FLAT:remove_doc
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:set_sizeof
	DD	04H
	ORG $+4
	DQ	FLAT:sizeof_doc
	DQ	FLAT:??_C@_0BF@NMFMJDIP@symmetric_difference?$AA@
	DQ	FLAT:set_symmetric_difference
	DD	08H
	ORG $+4
	DQ	FLAT:symmetric_difference_doc
	DQ	FLAT:??_C@_0BM@OJODNHLP@symmetric_difference_update?$AA@
	DQ	FLAT:set_symmetric_difference_update
	DD	08H
	ORG $+4
	DQ	FLAT:symmetric_difference_update_doc
	DQ	FLAT:??_C@_05MNALHJLP@union?$AA@
	DQ	FLAT:set_union
	DD	01H
	ORG $+4
	DQ	FLAT:union_doc
	DQ	FLAT:??_C@_06HDLLMMEJ@update?$AA@
	DQ	FLAT:set_update
	DD	01H
	ORG $+4
	DQ	FLAT:update_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
set_as_number DQ 0000000000000000H
	DQ	FLAT:set_sub
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:set_and
	DQ	FLAT:set_xor
	DQ	FLAT:set_or
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:set_isub
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:set_iand
	DQ	FLAT:set_ixor
	DQ	FLAT:set_ior
	ORG $+40
set_doc	DB	'set() -> new empty set object', 0aH, 'set(iterable) -> n'
	DB	'ew set object', 0aH, 0aH, 'Build an unordered collection of u'
	DB	'nique elements.', 00H
	ORG $+15
PySet_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_03KCHOJKKI@set?$AA@
	DQ	0000000000000120H
	DQ	0000000000000000H
	DQ	FLAT:set_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:set_repr
	DQ	FLAT:set_as_number
	DQ	FLAT:set_as_sequence
	DQ	0000000000000000H
	DQ	FLAT:PyObject_HashNotImplemented
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:set_doc
	DQ	FLAT:set_traverse
	DQ	FLAT:set_clear_internal
	DQ	FLAT:set_richcompare
	DQ	0000000000000110H
	DQ	FLAT:set_iter
	DQ	0000000000000000H
	DQ	FLAT:set_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:set_init
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:set_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
frozenset_methods DQ FLAT:??_C@_0N@MCIOADFH@__contains__?$AA@
	DQ	FLAT:set_direct_contains
	DD	048H
	ORG $+4
	DQ	FLAT:contains_doc
	DQ	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DQ	FLAT:frozenset_copy
	DD	04H
	ORG $+4
	DQ	FLAT:copy_doc
	DQ	FLAT:??_C@_0L@CHCOIIBP@difference?$AA@
	DQ	FLAT:set_difference_multi
	DD	01H
	ORG $+4
	DQ	FLAT:difference_doc
	DQ	FLAT:??_C@_0N@JIFGGPLM@intersection?$AA@
	DQ	FLAT:set_intersection_multi
	DD	01H
	ORG $+4
	DQ	FLAT:intersection_doc
	DQ	FLAT:??_C@_0L@EMANFHEK@isdisjoint?$AA@
	DQ	FLAT:set_isdisjoint
	DD	08H
	ORG $+4
	DQ	FLAT:isdisjoint_doc
	DQ	FLAT:??_C@_08NCLBICHP@issubset?$AA@
	DQ	FLAT:set_issubset
	DD	08H
	ORG $+4
	DQ	FLAT:issubset_doc
	DQ	FLAT:??_C@_0L@MEIHPPPH@issuperset?$AA@
	DQ	FLAT:set_issuperset
	DD	08H
	ORG $+4
	DQ	FLAT:issuperset_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:set_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:set_sizeof
	DD	04H
	ORG $+4
	DQ	FLAT:sizeof_doc
	DQ	FLAT:??_C@_0BF@NMFMJDIP@symmetric_difference?$AA@
	DQ	FLAT:set_symmetric_difference
	DD	08H
	ORG $+4
	DQ	FLAT:symmetric_difference_doc
	DQ	FLAT:??_C@_05MNALHJLP@union?$AA@
	DQ	FLAT:set_union
	DD	01H
	ORG $+4
	DQ	FLAT:union_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
frozenset_as_number DQ 0000000000000000H
	DQ	FLAT:set_sub
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:set_and
	DQ	FLAT:set_xor
	DQ	FLAT:set_or
	ORG $+144
frozenset_doc DB 'frozenset() -> empty frozenset object', 0aH, 'frozenset'
	DB	'(iterable) -> frozenset object', 0aH, 0aH, 'Build an immutabl'
	DB	'e unordered collection of unique elements.', 00H
	ORG $+5
PyFrozenSet_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_09FNPENIBB@frozenset?$AA@
	DQ	0000000000000120H
	DQ	0000000000000000H
	DQ	FLAT:set_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:set_repr
	DQ	FLAT:frozenset_as_number
	DQ	FLAT:set_as_sequence
	DQ	0000000000000000H
	DQ	FLAT:frozenset_hash
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:frozenset_doc
	DQ	FLAT:set_traverse
	DQ	FLAT:set_clear_internal
	DQ	FLAT:set_richcompare
	DQ	0000000000000110H
	DQ	FLAT:set_iter
	DQ	0000000000000000H
	DQ	FLAT:frozenset_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:frozenset_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
_DATA	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_Ready:PROC
EXTRN	memcmp:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\eq.h
pdata	SEGMENT
$pdata$unicode_eq DD imagerel unicode_eq
	DD	imagerel unicode_eq+219
	DD	imagerel $unwind$unicode_eq
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_eq DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unicode_eq
_TEXT	SEGMENT
aa$ = 48
bb$ = 56
unicode_eq PROC						; COMDAT

; 8    : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 9    :     register PyUnicodeObject *a = (PyUnicodeObject *)aa;
; 10   :     register PyUnicodeObject *b = (PyUnicodeObject *)bb;
; 11   : 
; 12   :     if (PyUnicode_READY(a) == -1 || PyUnicode_READY(b) == -1) {

  0000a	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000e	48 8b da	 mov	 rbx, rdx
  00011	48 8b f9	 mov	 rdi, rcx
  00014	75 0a		 jne	 SHORT $LN20@unicode_eq
  00016	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0001b	83 f8 ff	 cmp	 eax, -1
  0001e	74 1d		 je	 SHORT $LN22@unicode_eq
$LN20@unicode_eq:
  00020	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00024	75 0d		 jne	 SHORT $LN21@unicode_eq
  00026	48 8b cb	 mov	 rcx, rbx
  00029	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0002e	83 f8 ff	 cmp	 eax, -1

; 13   :         assert(0 && "unicode_eq ready fail");
; 14   :         return 0;

  00031	74 0a		 je	 SHORT $LN22@unicode_eq
$LN21@unicode_eq:

; 15   :     }
; 16   : 
; 17   :     if (PyUnicode_GET_LENGTH(a) != PyUnicode_GET_LENGTH(b))

  00033	4c 8b 4f 60	 mov	 r9, QWORD PTR [rdi+96]
  00037	4c 3b 4b 60	 cmp	 r9, QWORD PTR [rbx+96]
  0003b	74 0d		 je	 SHORT $LN3@unicode_eq
$LN22@unicode_eq:

; 18   :         return 0;

  0003d	33 c0		 xor	 eax, eax

; 25   : }

  0003f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5f		 pop	 rdi
  00049	c3		 ret	 0
$LN3@unicode_eq:

; 19   :     if (PyUnicode_GET_LENGTH(a) == 0)

  0004a	4d 85 c9	 test	 r9, r9
  0004d	75 0f		 jne	 SHORT $LN2@unicode_eq

; 20   :         return 1;

  0004f	41 8d 41 01	 lea	 eax, QWORD PTR [r9+1]

; 25   : }

  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
$LN2@unicode_eq:

; 21   :     if (PyUnicode_KIND(a) != PyUnicode_KIND(b))

  0005e	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00061	44 8b 47 70	 mov	 r8d, DWORD PTR [rdi+112]
  00065	8b c1		 mov	 eax, ecx
  00067	41 33 c0	 xor	 eax, r8d
  0006a	a8 1c		 test	 al, 28

; 22   :         return 0;

  0006c	75 cf		 jne	 SHORT $LN22@unicode_eq

; 23   :     return memcmp(PyUnicode_1BYTE_DATA(a), PyUnicode_1BYTE_DATA(b),
; 24   :                   PyUnicode_GET_LENGTH(a) * PyUnicode_KIND(a)) == 0;

  0006e	f6 c1 20	 test	 cl, 32			; 00000020H
  00071	74 17		 je	 SHORT $LN14@unicode_eq
  00073	f6 c1 40	 test	 cl, 64			; 00000040H
  00076	74 09		 je	 SHORT $LN12@unicode_eq
  00078	48 8d 93 80 00
	00 00		 lea	 rdx, QWORD PTR [rbx+128]
  0007f	eb 10		 jmp	 SHORT $LN15@unicode_eq
$LN12@unicode_eq:
  00081	48 8d 93 a0 00
	00 00		 lea	 rdx, QWORD PTR [rbx+160]
  00088	eb 07		 jmp	 SHORT $LN15@unicode_eq
$LN14@unicode_eq:
  0008a	48 8b 93 a0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+160]
$LN15@unicode_eq:
  00091	41 f6 c0 20	 test	 r8b, 32			; 00000020H
  00095	74 18		 je	 SHORT $LN18@unicode_eq
  00097	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  0009b	74 09		 je	 SHORT $LN16@unicode_eq
  0009d	48 8d 8f 80 00
	00 00		 lea	 rcx, QWORD PTR [rdi+128]
  000a4	eb 10		 jmp	 SHORT $LN19@unicode_eq
$LN16@unicode_eq:
  000a6	48 8d 8f a0 00
	00 00		 lea	 rcx, QWORD PTR [rdi+160]
  000ad	eb 07		 jmp	 SHORT $LN19@unicode_eq
$LN18@unicode_eq:
  000af	48 8b 8f a0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+160]
$LN19@unicode_eq:
  000b6	49 c1 e8 02	 shr	 r8, 2
  000ba	41 83 e0 07	 and	 r8d, 7
  000be	4d 0f af c1	 imul	 r8, r9
  000c2	e8 00 00 00 00	 call	 memcmp

; 25   : }

  000c7	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000cc	33 c9		 xor	 ecx, ecx
  000ce	85 c0		 test	 eax, eax
  000d0	0f 94 c1	 sete	 cl
  000d3	8b c1		 mov	 eax, ecx
  000d5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
unicode_eq ENDP
_TEXT	ENDS
EXTRN	PyErr_SetObject:PROC
EXTRN	PyExc_KeyError:QWORD
EXTRN	PyTuple_Pack:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\setobject.c
pdata	SEGMENT
$pdata$set_key_error DD imagerel set_key_error
	DD	imagerel set_key_error+56
	DD	imagerel $unwind$set_key_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_key_error DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_key_error
_TEXT	SEGMENT
arg$ = 48
set_key_error PROC					; COMDAT

; 19   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 20   :     PyObject *tup;
; 21   :     tup = PyTuple_Pack(1, arg);

  00006	48 8b d1	 mov	 rdx, rcx
  00009	b9 01 00 00 00	 mov	 ecx, 1
  0000e	e8 00 00 00 00	 call	 PyTuple_Pack
  00013	48 8b d8	 mov	 rbx, rax

; 22   :     if (!tup)

  00016	48 85 c0	 test	 rax, rax
  00019	74 17		 je	 SHORT $LN2@set_key_er

; 23   :         return; /* caller will expect error to be set anyway */
; 24   :     PyErr_SetObject(PyExc_KeyError, tup);

  0001b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  00022	48 8b d0	 mov	 rdx, rax
  00025	e8 00 00 00 00	 call	 PyErr_SetObject

; 25   :     Py_DECREF(tup);

  0002a	48 8b cb	 mov	 rcx, rbx
  0002d	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@set_key_er:

; 26   : }

  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5b		 pop	 rbx
  00037	c3		 ret	 0
set_key_error ENDP
_TEXT	ENDS
EXTRN	PyObject_RichCompareBool:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_lookkey DD imagerel set_lookkey
	DD	imagerel set_lookkey+465
	DD	imagerel $unwind$set_lookkey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_lookkey DD 0a1e01H
	DD	0f341eH
	DD	0f01a321eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_lookkey
_TEXT	SEGMENT
so$ = 96
key$ = 104
mask$1$ = 112
hash$ = 112
set_lookkey PROC					; COMDAT

; 79   : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 54		 push	 r12
  00014	41 55		 push	 r13
  00016	41 56		 push	 r14
  00018	41 57		 push	 r15
  0001a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 84   :     setentry *table = so->table;

  0001e	4c 8b 69 78	 mov	 r13, QWORD PTR [rcx+120]
  00022	4d 8b f8	 mov	 r15, r8
  00025	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]

; 85   :     register setentry *entry;
; 86   :     register int cmp;
; 87   :     PyObject *startkey;
; 88   : 
; 89   :     i = (size_t)hash & mask;

  00029	4d 8b f0	 mov	 r14, r8
  0002c	48 8b ea	 mov	 rbp, rdx
  0002f	4c 89 44 24 70	 mov	 QWORD PTR mask$1$[rsp], r8
  00034	4d 23 f7	 and	 r14, r15

; 90   :     entry = &table[i];

  00037	49 8b de	 mov	 rbx, r14
  0003a	48 c1 e3 04	 shl	 rbx, 4
  0003e	49 03 dd	 add	 rbx, r13

; 91   :     if (entry->key == NULL || entry->key == key)

  00041	48 8b 7b 08	 mov	 rdi, QWORD PTR [rbx+8]
  00045	48 85 ff	 test	 rdi, rdi
  00048	0f 84 5a 01 00
	00		 je	 $LN21@set_lookke
  0004e	66 90		 npad	 2
$LL25@set_lookke:
  00050	48 3b fd	 cmp	 rdi, rbp
  00053	0f 84 4f 01 00
	00		 je	 $LN21@set_lookke

; 93   : 
; 94   :     if (entry->key == dummy)

  00059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  00060	48 3b f9	 cmp	 rdi, rcx
  00063	74 5f		 je	 SHORT $LN19@set_lookke

; 95   :         freeslot = entry;
; 96   :     else {
; 97   :         if (entry->hash == hash) {

  00065	4c 39 3b	 cmp	 QWORD PTR [rbx], r15
  00068	75 58		 jne	 SHORT $LN14@set_lookke

; 98   :             startkey = entry->key;
; 99   :             Py_INCREF(startkey);

  0006a	48 8b cf	 mov	 rcx, rdi
  0006d	e8 00 00 00 00	 call	 _Py_IncRef

; 100  :             cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);

  00072	41 b8 02 00 00
	00		 mov	 r8d, 2
  00078	48 8b d5	 mov	 rdx, rbp
  0007b	48 8b cf	 mov	 rcx, rdi
  0007e	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 101  :             Py_DECREF(startkey);

  00083	48 8b cf	 mov	 rcx, rdi
  00086	8b f0		 mov	 esi, eax
  00088	e8 00 00 00 00	 call	 _Py_DecRef

; 102  :             if (cmp < 0)

  0008d	85 f6		 test	 esi, esi
  0008f	0f 88 2b 01 00
	00		 js	 $LN34@set_lookke

; 104  :             if (table == so->table && entry->key == startkey) {

  00095	48 8b 54 24 60	 mov	 rdx, QWORD PTR so$[rsp]
  0009a	4c 3b 6a 78	 cmp	 r13, QWORD PTR [rdx+120]
  0009e	0f 85 da 00 00
	00		 jne	 $LN5@set_lookke
  000a4	48 39 7b 08	 cmp	 QWORD PTR [rbx+8], rdi
  000a8	0f 85 d0 00 00
	00		 jne	 $LN5@set_lookke

; 105  :                 if (cmp > 0)

  000ae	85 f6		 test	 esi, esi
  000b0	0f 8f f2 00 00
	00		 jg	 $LN21@set_lookke
  000b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  000bd	4c 8b 44 24 70	 mov	 r8, QWORD PTR mask$1$[rsp]
$LN14@set_lookke:

; 106  :                     return entry;
; 107  :             }
; 108  :             else {
; 109  :                 /* The compare did major nasty stuff to the
; 110  :                  * set:  start over.
; 111  :                  */
; 112  :                 return set_lookkey(so, key, hash);
; 113  :             }
; 114  :         }
; 115  :         freeslot = NULL;

  000c2	33 db		 xor	 ebx, ebx
$LN19@set_lookke:

; 116  :     }
; 117  : 
; 118  :     /* In the loop, key == dummy is by far (factor of 100s) the
; 119  :        least likely outcome, so test for that last. */
; 120  :     for (perturb = hash; ; perturb >>= PERTURB_SHIFT) {

  000c4	4d 8b e7	 mov	 r12, r15
  000c7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL13@set_lookke:

; 121  :         i = (i << 2) + i + perturb + 1;

  000d0	4b 8d 04 b4	 lea	 rax, QWORD PTR [r12+r14*4]
  000d4	4d 8d 74 06 01	 lea	 r14, QWORD PTR [r14+rax+1]

; 122  :         entry = &table[i & mask];

  000d9	49 8b f6	 mov	 rsi, r14
  000dc	49 23 f0	 and	 rsi, r8
  000df	48 c1 e6 04	 shl	 rsi, 4
  000e3	49 03 f5	 add	 rsi, r13

; 123  :         if (entry->key == NULL) {

  000e6	48 8b 7e 08	 mov	 rdi, QWORD PTR [rsi+8]
  000ea	48 85 ff	 test	 rdi, rdi
  000ed	0f 84 d1 00 00
	00		 je	 $LN29@set_lookke

; 126  :             break;
; 127  :         }
; 128  :         if (entry->key == key)

  000f3	48 3b fd	 cmp	 rdi, rbp
  000f6	0f 84 d0 00 00
	00		 je	 $LN32@set_lookke

; 129  :             break;
; 130  :         if (entry->hash == hash && entry->key != dummy) {

  000fc	4c 39 3e	 cmp	 QWORD PTR [rsi], r15
  000ff	75 63		 jne	 SHORT $LN7@set_lookke
  00101	48 3b f9	 cmp	 rdi, rcx
  00104	74 63		 je	 SHORT $LN41@set_lookke

; 131  :             startkey = entry->key;
; 132  :             Py_INCREF(startkey);

  00106	48 8b cf	 mov	 rcx, rdi
  00109	e8 00 00 00 00	 call	 _Py_IncRef

; 133  :             cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);

  0010e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00114	48 8b d5	 mov	 rdx, rbp
  00117	48 8b cf	 mov	 rcx, rdi
  0011a	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 134  :             Py_DECREF(startkey);

  0011f	48 8b cf	 mov	 rcx, rdi
  00122	8b e8		 mov	 ebp, eax
  00124	e8 00 00 00 00	 call	 _Py_DecRef

; 135  :             if (cmp < 0)

  00129	85 ed		 test	 ebp, ebp
  0012b	0f 88 8f 00 00
	00		 js	 $LN34@set_lookke

; 136  :                 return NULL;
; 137  :             if (table == so->table && entry->key == startkey) {

  00131	48 8b 54 24 60	 mov	 rdx, QWORD PTR so$[rsp]
  00136	4c 3b 6a 78	 cmp	 r13, QWORD PTR [rdx+120]
  0013a	75 3d		 jne	 SHORT $LN39@set_lookke
  0013c	48 39 7e 08	 cmp	 QWORD PTR [rsi+8], rdi
  00140	75 37		 jne	 SHORT $LN39@set_lookke

; 138  :                 if (cmp > 0)

  00142	85 ed		 test	 ebp, ebp
  00144	0f 8f 82 00 00
	00		 jg	 $LN32@set_lookke

; 139  :                     break;
; 140  :             }
; 141  :             else {
; 142  :                 /* The compare did major nasty stuff to the
; 143  :                  * set:  start over.
; 144  :                  */
; 145  :                 return set_lookkey(so, key, hash);
; 146  :             }

  0014a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  00151	48 8b 6c 24 68	 mov	 rbp, QWORD PTR key$[rsp]
  00156	4c 8b 44 24 70	 mov	 r8, QWORD PTR mask$1$[rsp]
  0015b	49 c1 ec 05	 shr	 r12, 5
  0015f	e9 6c ff ff ff	 jmp	 $LL13@set_lookke
$LN7@set_lookke:

; 147  :         }
; 148  :         else if (entry->key == dummy && freeslot == NULL)

  00164	48 3b f9	 cmp	 rdi, rcx
  00167	75 07		 jne	 SHORT $LN12@set_lookke
$LN41@set_lookke:
  00169	48 85 db	 test	 rbx, rbx
  0016c	48 0f 44 de	 cmove	 rbx, rsi
$LN12@set_lookke:

; 116  :     }
; 117  : 
; 118  :     /* In the loop, key == dummy is by far (factor of 100s) the
; 119  :        least likely outcome, so test for that last. */
; 120  :     for (perturb = hash; ; perturb >>= PERTURB_SHIFT) {

  00170	49 c1 ec 05	 shr	 r12, 5
  00174	e9 57 ff ff ff	 jmp	 $LL13@set_lookke
$LN39@set_lookke:

; 79   : {

  00179	48 8b 6c 24 68	 mov	 rbp, QWORD PTR key$[rsp]
$LN5@set_lookke:

; 80   :     register size_t i;  /* Unsigned for defined overflow behavior. */
; 81   :     register size_t perturb;
; 82   :     register setentry *freeslot;
; 83   :     register size_t mask = so->mask;

  0017e	4c 8b 42 70	 mov	 r8, QWORD PTR [rdx+112]

; 84   :     setentry *table = so->table;

  00182	4c 8b 6a 78	 mov	 r13, QWORD PTR [rdx+120]

; 85   :     register setentry *entry;
; 86   :     register int cmp;
; 87   :     PyObject *startkey;
; 88   : 
; 89   :     i = (size_t)hash & mask;

  00186	4d 8b f0	 mov	 r14, r8
  00189	4c 89 44 24 70	 mov	 QWORD PTR mask$1$[rsp], r8
  0018e	4d 23 f7	 and	 r14, r15

; 90   :     entry = &table[i];

  00191	49 8b de	 mov	 rbx, r14
  00194	48 c1 e3 04	 shl	 rbx, 4
  00198	49 03 dd	 add	 rbx, r13

; 91   :     if (entry->key == NULL || entry->key == key)

  0019b	48 8b 7b 08	 mov	 rdi, QWORD PTR [rbx+8]
  0019f	48 85 ff	 test	 rdi, rdi
  001a2	0f 85 a8 fe ff
	ff		 jne	 $LL25@set_lookke
$LN21@set_lookke:

; 92   :         return entry;

  001a8	48 8b c3	 mov	 rax, rbx
$LN23@set_lookke:

; 152  : }

  001ab	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  001b0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001b4	41 5f		 pop	 r15
  001b6	41 5e		 pop	 r14
  001b8	41 5d		 pop	 r13
  001ba	41 5c		 pop	 r12
  001bc	5f		 pop	 rdi
  001bd	5e		 pop	 rsi
  001be	5d		 pop	 rbp
  001bf	c3		 ret	 0
$LN34@set_lookke:

; 103  :                 return NULL;

  001c0	33 c0		 xor	 eax, eax
  001c2	eb e7		 jmp	 SHORT $LN23@set_lookke
$LN29@set_lookke:

; 124  :             if (freeslot != NULL)

  001c4	48 85 db	 test	 rbx, rbx
  001c7	74 03		 je	 SHORT $LN32@set_lookke

; 125  :                 entry = freeslot;

  001c9	48 8b f3	 mov	 rsi, rbx
$LN32@set_lookke:

; 149  :             freeslot = entry;
; 150  :     }
; 151  :     return entry;

  001cc	48 8b c6	 mov	 rax, rsi
  001cf	eb da		 jmp	 SHORT $LN23@set_lookke
set_lookkey ENDP
_TEXT	ENDS
EXTRN	PyUnicode_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_lookkey_unicode DD imagerel set_lookkey_unicode
	DD	imagerel set_lookkey_unicode+67
	DD	imagerel $unwind$set_lookkey_unicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$set_lookkey_unicode DD imagerel set_lookkey_unicode+67
	DD	imagerel set_lookkey_unicode+162
	DD	imagerel $chain$1$set_lookkey_unicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$set_lookkey_unicode DD imagerel set_lookkey_unicode+162
	DD	imagerel set_lookkey_unicode+313
	DD	imagerel $chain$3$set_lookkey_unicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$set_lookkey_unicode DD imagerel set_lookkey_unicode+313
	DD	imagerel set_lookkey_unicode+334
	DD	imagerel $chain$4$set_lookkey_unicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$set_lookkey_unicode DD imagerel set_lookkey_unicode+334
	DD	imagerel set_lookkey_unicode+339
	DD	imagerel $chain$6$set_lookkey_unicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$set_lookkey_unicode DD imagerel set_lookkey_unicode+339
	DD	imagerel set_lookkey_unicode+344
	DD	imagerel $chain$7$set_lookkey_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$set_lookkey_unicode DD 040021H
	DD	0b7400H
	DD	0a3400H
	DD	imagerel set_lookkey_unicode
	DD	imagerel set_lookkey_unicode+67
	DD	imagerel $unwind$set_lookkey_unicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$set_lookkey_unicode DD 080021H
	DD	04f400H
	DD	0cc400H
	DD	0b7400H
	DD	0a3400H
	DD	imagerel set_lookkey_unicode
	DD	imagerel set_lookkey_unicode+67
	DD	imagerel $unwind$set_lookkey_unicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$set_lookkey_unicode DD 021H
	DD	imagerel set_lookkey_unicode+67
	DD	imagerel set_lookkey_unicode+162
	DD	imagerel $chain$1$set_lookkey_unicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$set_lookkey_unicode DD 040a21H
	DD	04f40aH
	DD	0cc405H
	DD	imagerel set_lookkey_unicode+67
	DD	imagerel set_lookkey_unicode+162
	DD	imagerel $chain$1$set_lookkey_unicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$set_lookkey_unicode DD 040a21H
	DD	0b740aH
	DD	0a3405H
	DD	imagerel set_lookkey_unicode
	DD	imagerel set_lookkey_unicode+67
	DD	imagerel $unwind$set_lookkey_unicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_lookkey_unicode DD 050b01H
	DD	0e007420bH
	DD	06003d005H
	DD	05002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_lookkey_unicode
_TEXT	SEGMENT
so$ = 80
key$ = 88
hash$ = 96
set_lookkey_unicode PROC				; COMDAT

; 161  : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	41 55		 push	 r13
  00005	41 56		 push	 r14
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 162  :     register size_t i;  /* Unsigned for defined overflow behavior. */
; 163  :     register size_t perturb;
; 164  :     register setentry *freeslot;
; 165  :     register size_t mask = so->mask;

  0000b	4c 8b 69 70	 mov	 r13, QWORD PTR [rcx+112]

; 166  :     setentry *table = so->table;

  0000f	4c 8b 71 78	 mov	 r14, QWORD PTR [rcx+120]

; 167  :     register setentry *entry;
; 168  : 
; 169  :     /* Make sure this function doesn't have to handle non-unicode keys,
; 170  :        including subclasses of str; e.g., one reason to subclass
; 171  :        strings is to override __eq__, and for speed we don't cater to
; 172  :        that here. */
; 173  :     if (!PyUnicode_CheckExact(key)) {

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  0001a	49 8b e8	 mov	 rbp, r8
  0001d	48 8b f2	 mov	 rsi, rdx
  00020	48 39 42 58	 cmp	 QWORD PTR [rdx+88], rax
  00024	74 1d		 je	 SHORT $LN13@set_lookke@2

; 174  :         so->lookup = set_lookkey;

  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:set_lookkey
  0002d	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 202  :             freeslot = entry;
; 203  :     }
; 204  :     assert(0);          /* NOT REACHED */
; 205  :     return 0;
; 206  : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	41 5e		 pop	 r14
  0003a	41 5d		 pop	 r13
  0003c	5e		 pop	 rsi
  0003d	5d		 pop	 rbp
  0003e	e9 00 00 00 00	 jmp	 set_lookkey
$LN13@set_lookke@2:
  00043	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00048	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi

; 175  :         return set_lookkey(so, key, hash);
; 176  :     }
; 177  :     i = (size_t)hash & mask;

  0004d	49 8b fd	 mov	 rdi, r13
  00050	49 23 f8	 and	 rdi, r8

; 178  :     entry = &table[i];

  00053	48 8b df	 mov	 rbx, rdi
  00056	48 c1 e3 04	 shl	 rbx, 4
  0005a	49 03 de	 add	 rbx, r14

; 179  :     if (entry->key == NULL || entry->key == key)

  0005d	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00061	48 85 c0	 test	 rax, rax
  00064	0f 84 e9 00 00
	00		 je	 $LN11@set_lookke@2
  0006a	48 3b c2	 cmp	 rax, rdx
  0006d	0f 84 e0 00 00
	00		 je	 $LN11@set_lookke@2

; 181  :     if (entry->key == dummy)

  00073	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  0007a	48 3b c1	 cmp	 rax, rcx
  0007d	74 1e		 je	 SHORT $LN9@set_lookke@2

; 182  :         freeslot = entry;
; 183  :     else {
; 184  :         if (entry->hash == hash && unicode_eq(entry->key, key))

  0007f	4c 39 03	 cmp	 QWORD PTR [rbx], r8
  00082	75 17		 jne	 SHORT $LN8@set_lookke@2
  00084	48 8b c8	 mov	 rcx, rax
  00087	e8 00 00 00 00	 call	 unicode_eq
  0008c	85 c0		 test	 eax, eax

; 185  :             return entry;

  0008e	0f 85 bf 00 00
	00		 jne	 $LN11@set_lookke@2
  00094	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
$LN8@set_lookke@2:

; 186  :         freeslot = NULL;

  0009b	33 db		 xor	 ebx, ebx
$LN9@set_lookke@2:

; 187  :     }
; 188  : 
; 189  :     /* In the loop, key == dummy is by far (factor of 100s) the
; 190  :        least likely outcome, so test for that last. */
; 191  :     for (perturb = hash; ; perturb >>= PERTURB_SHIFT) {
; 192  :         i = (i << 2) + i + perturb + 1;

  0009d	48 8d 44 bd 00	 lea	 rax, QWORD PTR [rbp+rdi*4]
  000a2	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  000a7	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  000ac	4c 8d 64 07 01	 lea	 r12, QWORD PTR [rdi+rax+1]
  000b1	4c 8b fd	 mov	 r15, rbp

; 193  :         entry = &table[i & mask];

  000b4	49 8b fc	 mov	 rdi, r12
  000b7	49 23 fd	 and	 rdi, r13
  000ba	48 c1 e7 04	 shl	 rdi, 4
  000be	49 03 fe	 add	 rdi, r14

; 194  :         if (entry->key == NULL)

  000c1	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  000c5	48 85 c0	 test	 rax, rax
  000c8	74 5b		 je	 SHORT $LN17@set_lookke@2
  000ca	66 0f 1f 44 00
	00		 npad	 6
$LL7@set_lookke@2:

; 196  :         if (entry->key == key
; 197  :             || (entry->hash == hash
; 198  :             && entry->key != dummy
; 199  :             && unicode_eq(entry->key, key)))

  000d0	48 3b c6	 cmp	 rax, rsi
  000d3	74 79		 je	 SHORT $LN18@set_lookke@2
  000d5	48 39 2f	 cmp	 QWORD PTR [rdi], rbp
  000d8	75 1b		 jne	 SHORT $LN3@set_lookke@2
  000da	48 3b c1	 cmp	 rax, rcx
  000dd	74 1c		 je	 SHORT $LN20@set_lookke@2
  000df	48 8b d6	 mov	 rdx, rsi
  000e2	48 8b c8	 mov	 rcx, rax
  000e5	e8 00 00 00 00	 call	 unicode_eq
  000ea	85 c0		 test	 eax, eax
  000ec	75 60		 jne	 SHORT $LN18@set_lookke@2
  000ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
$LN3@set_lookke@2:

; 201  :         if (entry->key == dummy && freeslot == NULL)

  000f5	48 39 4f 08	 cmp	 QWORD PTR [rdi+8], rcx
  000f9	75 07		 jne	 SHORT $LN6@set_lookke@2
$LN20@set_lookke@2:
  000fb	48 85 db	 test	 rbx, rbx
  000fe	48 0f 44 df	 cmove	 rbx, rdi
$LN6@set_lookke@2:

; 187  :     }
; 188  : 
; 189  :     /* In the loop, key == dummy is by far (factor of 100s) the
; 190  :        least likely outcome, so test for that last. */
; 191  :     for (perturb = hash; ; perturb >>= PERTURB_SHIFT) {
; 192  :         i = (i << 2) + i + perturb + 1;

  00102	49 c1 ef 05	 shr	 r15, 5
  00106	4b 8d 04 a7	 lea	 rax, QWORD PTR [r15+r12*4]
  0010a	4d 8d 64 04 01	 lea	 r12, QWORD PTR [r12+rax+1]

; 193  :         entry = &table[i & mask];

  0010f	49 8b fc	 mov	 rdi, r12
  00112	49 23 fd	 and	 rdi, r13
  00115	48 c1 e7 04	 shl	 rdi, 4
  00119	49 03 fe	 add	 rdi, r14

; 194  :         if (entry->key == NULL)

  0011c	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00120	48 85 c0	 test	 rax, rax
  00123	75 ab		 jne	 SHORT $LL7@set_lookke@2
$LN17@set_lookke@2:

; 195  :             return freeslot == NULL ? entry : freeslot;

  00125	48 85 db	 test	 rbx, rbx
  00128	48 0f 44 df	 cmove	 rbx, rdi
  0012c	48 8b c3	 mov	 rax, rbx
$LN25@set_lookke@2:
  0012f	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]
  00134	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
$LN23@set_lookke@2:
  00139	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0013e	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]

; 202  :             freeslot = entry;
; 203  :     }
; 204  :     assert(0);          /* NOT REACHED */
; 205  :     return 0;
; 206  : }

  00143	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00147	41 5e		 pop	 r14
  00149	41 5d		 pop	 r13
  0014b	5e		 pop	 rsi
  0014c	5d		 pop	 rbp
  0014d	c3		 ret	 0
$LN18@set_lookke@2:

; 200  :             return entry;

  0014e	48 8b c7	 mov	 rax, rdi
  00151	eb dc		 jmp	 SHORT $LN25@set_lookke@2
$LN11@set_lookke@2:

; 180  :         return entry;

  00153	48 8b c3	 mov	 rax, rbx
  00156	eb e1		 jmp	 SHORT $LN23@set_lookke@2
set_lookkey_unicode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_insert_key DD imagerel set_insert_key
	DD	imagerel set_insert_key+150
	DD	imagerel $unwind$set_insert_key
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_insert_key DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_insert_key
_TEXT	SEGMENT
so$ = 48
key$ = 56
hash$ = 64
set_insert_key PROC					; COMDAT

; 215  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	49 8b f0	 mov	 rsi, r8
  00015	48 8b fa	 mov	 rdi, rdx

; 216  :     register setentry *entry;
; 217  : 
; 218  :     assert(so->lookup != NULL);
; 219  :     entry = so->lookup(so, key, hash);

  00018	ff 93 80 00 00
	00		 call	 QWORD PTR [rbx+128]

; 220  :     if (entry == NULL)

  0001e	48 85 c0	 test	 rax, rax
  00021	75 13		 jne	 SHORT $LN5@set_insert

; 221  :         return -1;

  00023	83 c8 ff	 or	 eax, -1

; 239  : }

  00026	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
$LN5@set_insert:

; 222  :     if (entry->key == NULL) {

  00036	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0003a	48 85 c9	 test	 rcx, rcx
  0003d	75 21		 jne	 SHORT $LN4@set_insert

; 223  :         /* UNUSED */
; 224  :         so->fill++;

  0003f	48 ff 43 60	 inc	 QWORD PTR [rbx+96]

; 225  :         entry->key = key;

  00043	48 89 78 08	 mov	 QWORD PTR [rax+8], rdi

; 226  :         entry->hash = hash;

  00047	48 89 30	 mov	 QWORD PTR [rax], rsi

; 227  :         so->used++;

  0004a	48 ff 43 68	 inc	 QWORD PTR [rbx+104]

; 237  :     }
; 238  :     return 0;

  0004e	33 c0		 xor	 eax, eax

; 239  : }

  00050	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00055	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005e	5f		 pop	 rdi
  0005f	c3		 ret	 0
$LN4@set_insert:

; 228  :     } else if (entry->key == dummy) {

  00060	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR dummy
  00067	48 3b ca	 cmp	 rcx, rdx
  0006a	75 10		 jne	 SHORT $LN2@set_insert

; 229  :         /* DUMMY */
; 230  :         entry->key = key;

  0006c	48 89 78 08	 mov	 QWORD PTR [rax+8], rdi

; 231  :         entry->hash = hash;

  00070	48 89 30	 mov	 QWORD PTR [rax], rsi

; 232  :         so->used++;

  00073	48 ff 43 68	 inc	 QWORD PTR [rbx+104]

; 233  :         Py_DECREF(dummy);

  00077	48 8b ca	 mov	 rcx, rdx

; 234  :     } else {

  0007a	eb 03		 jmp	 SHORT $LN8@set_insert
$LN2@set_insert:

; 235  :         /* ACTIVE */
; 236  :         Py_DECREF(key);

  0007c	48 8b cf	 mov	 rcx, rdi
$LN8@set_insert:
  0007f	e8 00 00 00 00	 call	 _Py_DecRef

; 239  : }

  00084	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00089	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0008e	33 c0		 xor	 eax, eax
  00090	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00094	5f		 pop	 rdi
  00095	c3		 ret	 0
set_insert_key ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_insert_clean DD imagerel set_insert_clean
	DD	imagerel set_insert_clean+102
	DD	imagerel $unwind$set_insert_clean
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_insert_clean DD 020501H
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_insert_clean
_TEXT	SEGMENT
so$ = 8
key$ = 16
hash$ = 24
set_insert_clean PROC					; COMDAT

; 251  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 252  :     register size_t i;
; 253  :     register size_t perturb;
; 254  :     register size_t mask = (size_t)so->mask;

  00005	4c 8b 59 70	 mov	 r11, QWORD PTR [rcx+112]
  00009	48 8b da	 mov	 rbx, rdx

; 255  :     setentry *table = so->table;

  0000c	48 8b 51 78	 mov	 rdx, QWORD PTR [rcx+120]

; 256  :     register setentry *entry;
; 257  : 
; 258  :     i = (size_t)hash & mask;

  00010	4d 8b cb	 mov	 r9, r11

; 259  :     entry = &table[i];
; 260  :     for (perturb = hash; entry->key != NULL; perturb >>= PERTURB_SHIFT) {

  00013	4d 8b d0	 mov	 r10, r8
  00016	4d 23 c8	 and	 r9, r8
  00019	49 8b c1	 mov	 rax, r9
  0001c	48 c1 e0 04	 shl	 rax, 4
  00020	48 03 c2	 add	 rax, rdx
  00023	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00028	74 27		 je	 SHORT $LN1@set_insert@2
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL3@set_insert@2:

; 261  :         i = (i << 2) + i + perturb + 1;

  00030	4b 8d 04 8a	 lea	 rax, QWORD PTR [r10+r9*4]
  00034	49 c1 ea 05	 shr	 r10, 5
  00038	4d 8d 4c 01 01	 lea	 r9, QWORD PTR [r9+rax+1]

; 262  :         entry = &table[i & mask];

  0003d	49 8b c1	 mov	 rax, r9
  00040	49 23 c3	 and	 rax, r11
  00043	48 c1 e0 04	 shl	 rax, 4
  00047	48 03 c2	 add	 rax, rdx
  0004a	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0004f	75 df		 jne	 SHORT $LL3@set_insert@2
$LN1@set_insert@2:

; 263  :     }
; 264  :     so->fill++;

  00051	48 ff 41 60	 inc	 QWORD PTR [rcx+96]

; 265  :     entry->key = key;

  00055	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx

; 266  :     entry->hash = hash;
; 267  :     so->used++;
; 268  : }

  00059	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0005e	4c 89 00	 mov	 QWORD PTR [rax], r8
  00061	48 ff 41 68	 inc	 QWORD PTR [rcx+104]
  00065	c3		 ret	 0
set_insert_clean ENDP
_TEXT	ENDS
EXTRN	__imp_free:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	memset:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_table_resize DD imagerel set_table_resize
	DD	imagerel set_table_resize+349
	DD	imagerel $unwind$set_table_resize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$set_table_resize DD imagerel set_table_resize+349
	DD	imagerel set_table_resize+568
	DD	imagerel $chain$3$set_table_resize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$set_table_resize DD imagerel set_table_resize+568
	DD	imagerel set_table_resize+641
	DD	imagerel $chain$4$set_table_resize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$set_table_resize DD 021H
	DD	imagerel set_table_resize
	DD	imagerel set_table_resize+349
	DD	imagerel $unwind$set_table_resize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$set_table_resize DD 020821H
	DD	01a6408H
	DD	imagerel set_table_resize
	DD	imagerel set_table_resize+349
	DD	imagerel $unwind$set_table_resize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_table_resize DD 0a6001H
	DD	016d460H
	DD	01cc44dH
	DD	01b7443H
	DD	017010aH
	DD	030025003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_table_resize
_TEXT	SEGMENT
small_copy$ = 48
so$ = 208
minused$ = 216
set_table_resize PROC					; COMDAT

; 277  : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 278  :     Py_ssize_t newsize;
; 279  :     setentry *oldtable, *newtable, *entry;
; 280  :     Py_ssize_t i;
; 281  :     int is_oldtable_malloced;
; 282  :     setentry small_copy[PySet_MINSIZE];
; 283  : 
; 284  :     assert(minused >= 0);
; 285  : 
; 286  :     /* Find the smallest table size > minused. */
; 287  :     for (newsize = PySet_MINSIZE;
; 288  :          newsize <= minused && newsize > 0;
; 289  :          newsize <<= 1)

  0000a	bb 08 00 00 00	 mov	 ebx, 8
  0000f	48 8b e9	 mov	 rbp, rcx
  00012	48 3b da	 cmp	 rbx, rdx
  00015	7f 24		 jg	 SHORT $LN14@set_table_
$LL17@set_table_:
  00017	48 85 db	 test	 rbx, rbx
  0001a	7e 0d		 jle	 SHORT $LN45@set_table_
  0001c	48 03 db	 add	 rbx, rbx
  0001f	48 3b da	 cmp	 rbx, rdx
  00022	7e f3		 jle	 SHORT $LL17@set_table_

; 290  :         ;
; 291  :     if (newsize <= 0) {

  00024	48 85 db	 test	 rbx, rbx
  00027	7f 12		 jg	 SHORT $LN14@set_table_
$LN45@set_table_:

; 292  :         PyErr_NoMemory();

  00029	e8 00 00 00 00	 call	 PyErr_NoMemory

; 293  :         return -1;

  0002e	83 c8 ff	 or	 eax, -1

; 358  : }

  00031	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00038	5d		 pop	 rbp
  00039	5b		 pop	 rbx
  0003a	c3		 ret	 0
$LN14@set_table_:
  0003b	48 89 bc 24 d8
	00 00 00	 mov	 QWORD PTR [rsp+216], rdi

; 294  :     }
; 295  : 
; 296  :     /* Get space for a new table. */
; 297  :     oldtable = so->table;
; 298  :     assert(oldtable != NULL);
; 299  :     is_oldtable_malloced = oldtable != so->smalltable;

  00043	33 ff		 xor	 edi, edi
  00045	4c 89 a4 24 e0
	00 00 00	 mov	 QWORD PTR [rsp+224], r12
  0004d	4c 8b 61 78	 mov	 r12, QWORD PTR [rcx+120]
  00051	48 81 c1 88 00
	00 00		 add	 rcx, 136		; 00000088H
  00058	4c 89 ac 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], r13
  00060	4c 3b e1	 cmp	 r12, rcx
  00063	44 8b ef	 mov	 r13d, edi
  00066	41 0f 95 c5	 setne	 r13b

; 300  : 
; 301  :     if (newsize == PySet_MINSIZE) {

  0006a	48 83 fb 08	 cmp	 rbx, 8
  0006e	75 7e		 jne	 SHORT $LN13@set_table_

; 302  :         /* A large table is shrinking, or we can't get any smaller. */
; 303  :         newtable = so->smalltable;
; 304  :         if (newtable == oldtable) {

  00070	49 3b cc	 cmp	 rcx, r12
  00073	0f 85 d7 00 00
	00		 jne	 $LN9@set_table_

; 305  :             if (so->fill == so->used) {

  00079	48 8b 45 68	 mov	 rax, QWORD PTR [rbp+104]
  0007d	48 39 45 60	 cmp	 QWORD PTR [rbp+96], rax

; 306  :                 /* No dummies, so no point doing anything. */
; 307  :                 return 0;

  00081	0f 84 cc 01 00
	00		 je	 $LN29@set_table_

; 308  :             }
; 309  :             /* We're not going to resize it, but rebuild the
; 310  :                table anyway to purge old dummy entries.
; 311  :                Subtle:  This is *necessary* if fill==size,
; 312  :                as set_lookkey needs at least one virgin slot to
; 313  :                terminate failing searches.  If fill < size, it's
; 314  :                merely desirable, as dummies slow searches. */
; 315  :             assert(so->fill > so->used);
; 316  :             memcpy(small_copy, oldtable, sizeof(small_copy));

  00087	41 0f 10 04 24	 movups	 xmm0, XMMWORD PTR [r12]
  0008c	0f 29 44 24 30	 movaps	 XMMWORD PTR small_copy$[rsp], xmm0
  00091	41 0f 10 4c 24
	10		 movups	 xmm1, XMMWORD PTR [r12+16]
  00097	0f 29 4c 24 40	 movaps	 XMMWORD PTR small_copy$[rsp+16], xmm1
  0009c	41 0f 10 44 24
	20		 movups	 xmm0, XMMWORD PTR [r12+32]
  000a2	0f 29 44 24 50	 movaps	 XMMWORD PTR small_copy$[rsp+32], xmm0
  000a7	41 0f 10 4c 24
	30		 movups	 xmm1, XMMWORD PTR [r12+48]
  000ad	0f 29 4c 24 60	 movaps	 XMMWORD PTR small_copy$[rsp+48], xmm1
  000b2	41 0f 10 44 24
	40		 movups	 xmm0, XMMWORD PTR [r12+64]
  000b8	0f 29 44 24 70	 movaps	 XMMWORD PTR small_copy$[rsp+64], xmm0
  000bd	41 0f 10 4c 24
	50		 movups	 xmm1, XMMWORD PTR [r12+80]
  000c3	0f 29 8c 24 80
	00 00 00	 movaps	 XMMWORD PTR small_copy$[rsp+80], xmm1
  000cb	41 0f 10 44 24
	60		 movups	 xmm0, XMMWORD PTR [r12+96]
  000d1	0f 29 84 24 90
	00 00 00	 movaps	 XMMWORD PTR small_copy$[rsp+96], xmm0
  000d9	41 0f 10 4c 24
	70		 movups	 xmm1, XMMWORD PTR [r12+112]

; 317  :             oldtable = small_copy;

  000df	4c 8d 64 24 30	 lea	 r12, QWORD PTR small_copy$[rsp]
  000e4	0f 29 8c 24 a0
	00 00 00	 movaps	 XMMWORD PTR small_copy$[rsp+112], xmm1

; 318  :         }
; 319  :     }
; 320  :     else {

  000ec	eb 62		 jmp	 SHORT $LN9@set_table_
$LN13@set_table_:

; 321  :         newtable = PyMem_NEW(setentry, newsize);

  000ee	48 b8 ff ff ff
	ff ff ff ff 07	 mov	 rax, 576460752303423487	; 07ffffffffffffffH
  000f8	48 3b d8	 cmp	 rbx, rax
  000fb	0f 87 56 01 00
	00		 ja	 $LN46@set_table_
  00101	e8 00 00 00 00	 call	 _Py_PXCTX
  00106	85 c0		 test	 eax, eax
  00108	74 0e		 je	 SHORT $LN24@set_table_
  0010a	48 8b cb	 mov	 rcx, rbx
  0010d	48 c1 e1 04	 shl	 rcx, 4
  00111	e8 00 00 00 00	 call	 _PxMem_Malloc
  00116	eb 2c		 jmp	 SHORT $LN51@set_table_
$LN24@set_table_:
  00118	48 8b c3	 mov	 rax, rbx
  0011b	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00125	48 c1 e0 04	 shl	 rax, 4
  00129	48 3b c1	 cmp	 rax, rcx
  0012c	0f 87 25 01 00
	00		 ja	 $LN46@set_table_
  00132	48 85 c0	 test	 rax, rax
  00135	b9 01 00 00 00	 mov	 ecx, 1
  0013a	48 0f 45 c8	 cmovne	 rcx, rax
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN51@set_table_:
  00144	48 8b c8	 mov	 rcx, rax

; 322  :         if (newtable == NULL) {

  00147	48 85 c0	 test	 rax, rax
  0014a	0f 84 07 01 00
	00		 je	 $LN46@set_table_
$LN9@set_table_:

; 331  :     so->mask = newsize - 1;

  00150	48 8d 43 ff	 lea	 rax, QWORD PTR [rbx-1]

; 332  :     memset(newtable, 0, sizeof(setentry) * newsize);

  00154	48 c1 e3 04	 shl	 rbx, 4
  00158	33 d2		 xor	 edx, edx
  0015a	4c 8b c3	 mov	 r8, rbx
  0015d	48 89 b4 24 d0
	00 00 00	 mov	 QWORD PTR [rsp+208], rsi
  00165	48 89 4d 78	 mov	 QWORD PTR [rbp+120], rcx
  00169	48 89 45 70	 mov	 QWORD PTR [rbp+112], rax
  0016d	e8 00 00 00 00	 call	 memset

; 333  :     so->used = 0;
; 334  :     i = so->fill;

  00172	48 8b 75 60	 mov	 rsi, QWORD PTR [rbp+96]
  00176	48 89 7d 68	 mov	 QWORD PTR [rbp+104], rdi

; 335  :     so->fill = 0;

  0017a	48 89 7d 60	 mov	 QWORD PTR [rbp+96], rdi

; 336  : 
; 337  :     /* Copy the data over; this is refcount-neutral for active entries;
; 338  :        dummy entries aren't copied over, of course */
; 339  :     for (entry = oldtable; i > 0; entry++) {

  0017e	48 85 f6	 test	 rsi, rsi
  00181	0f 8e a4 00 00
	00		 jle	 $LN6@set_table_

; 325  :         }
; 326  :     }
; 327  : 
; 328  :     /* Make the set empty, using the new table. */
; 329  :     assert(newtable != oldtable);
; 330  :     so->table = newtable;

  00187	49 8d 7c 24 08	 lea	 rdi, QWORD PTR [r12+8]
  0018c	0f 1f 40 00	 npad	 4
$LL8@set_table_:

; 340  :         if (entry->key == NULL) {

  00190	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00193	48 85 db	 test	 rbx, rbx
  00196	0f 84 82 00 00
	00		 je	 $LN7@set_table_

; 341  :             /* UNUSED */
; 342  :             ;
; 343  :         } else if (entry->key == dummy) {
; 344  :             /* DUMMY */
; 345  :             --i;

  0019c	48 ff ce	 dec	 rsi
  0019f	48 3b 1d 00 00
	00 00		 cmp	 rbx, QWORD PTR dummy
  001a6	75 67		 jne	 SHORT $LN3@set_table_

; 346  :             assert(entry->key == dummy);
; 347  :             Py_DECREF(entry->key);

  001a8	e8 00 00 00 00	 call	 _Py_PXCTX
  001ad	85 c0		 test	 eax, eax
  001af	75 6d		 jne	 SHORT $LN7@set_table_
  001b1	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001b5	a8 20		 test	 al, 32			; 00000020H
  001b7	75 4c		 jne	 SHORT $LN34@set_table_
  001b9	84 c0		 test	 al, al
  001bb	78 48		 js	 SHORT $LN34@set_table_
  001bd	a8 02		 test	 al, 2
  001bf	75 5d		 jne	 SHORT $LN7@set_table_
  001c1	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001c5	75 57		 jne	 SHORT $LN7@set_table_
  001c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001d5	4c 8b cb	 mov	 r9, rbx
  001d8	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001de	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001e6	e8 00 00 00 00	 call	 _PyParallel_Guard
  001eb	48 8b cb	 mov	 rcx, rbx
  001ee	85 c0		 test	 eax, eax
  001f0	74 07		 je	 SHORT $LN39@set_table_
  001f2	e8 00 00 00 00	 call	 _Px_Dealloc
  001f7	eb 25		 jmp	 SHORT $LN7@set_table_
$LN39@set_table_:
  001f9	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001fd	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00203	eb 19		 jmp	 SHORT $LN7@set_table_
$LN34@set_table_:
  00205	48 8b cb	 mov	 rcx, rbx
  00208	e8 00 00 00 00	 call	 Px_DecRef

; 348  :         } else {

  0020d	eb 0f		 jmp	 SHORT $LN7@set_table_
$LN3@set_table_:

; 349  :             /* ACTIVE */
; 350  :             --i;
; 351  :             set_insert_clean(so, entry->key, entry->hash);

  0020f	4c 8b 47 f8	 mov	 r8, QWORD PTR [rdi-8]
  00213	48 8b d3	 mov	 rdx, rbx
  00216	48 8b cd	 mov	 rcx, rbp
  00219	e8 00 00 00 00	 call	 set_insert_clean
$LN7@set_table_:

; 336  : 
; 337  :     /* Copy the data over; this is refcount-neutral for active entries;
; 338  :        dummy entries aren't copied over, of course */
; 339  :     for (entry = oldtable; i > 0; entry++) {

  0021e	48 83 c7 10	 add	 rdi, 16
  00222	48 85 f6	 test	 rsi, rsi
  00225	0f 8f 65 ff ff
	ff		 jg	 $LL8@set_table_
$LN6@set_table_:
  0022b	48 8b b4 24 d0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+208]

; 352  :         }
; 353  :     }
; 354  : 
; 355  :     if (is_oldtable_malloced)

  00233	45 85 ed	 test	 r13d, r13d
  00236	74 1b		 je	 SHORT $LN29@set_table_

; 356  :         PyMem_DEL(oldtable);

  00238	e8 00 00 00 00	 call	 _Py_PXCTX
  0023d	49 8b cc	 mov	 rcx, r12
  00240	85 c0		 test	 eax, eax
  00242	74 09		 je	 SHORT $LN28@set_table_
  00244	e8 00 00 00 00	 call	 _PxMem_Free

; 357  :     return 0;

  00249	33 c0		 xor	 eax, eax
  0024b	eb 12		 jmp	 SHORT $LN50@set_table_
$LN28@set_table_:

; 356  :         PyMem_DEL(oldtable);

  0024d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN29@set_table_:

; 357  :     return 0;

  00253	33 c0		 xor	 eax, eax
  00255	eb 08		 jmp	 SHORT $LN50@set_table_
$LN46@set_table_:

; 323  :             PyErr_NoMemory();

  00257	e8 00 00 00 00	 call	 PyErr_NoMemory

; 324  :             return -1;

  0025c	83 c8 ff	 or	 eax, -1
$LN50@set_table_:
  0025f	4c 8b a4 24 e0
	00 00 00	 mov	 r12, QWORD PTR [rsp+224]
  00267	48 8b bc 24 d8
	00 00 00	 mov	 rdi, QWORD PTR [rsp+216]
  0026f	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR [rsp+176]

; 358  : }

  00277	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0027e	5d		 pop	 rbp
  0027f	5b		 pop	 rbx
  00280	c3		 ret	 0
set_table_resize ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_add_entry DD imagerel set_add_entry
	DD	imagerel set_add_entry+210
	DD	imagerel $unwind$set_add_entry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_add_entry DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_add_entry
_TEXT	SEGMENT
so$ = 64
entry$ = 72
set_add_entry PROC					; COMDAT

; 364  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 365  :     register Py_ssize_t n_used;
; 366  :     PyObject *key = entry->key;

  00014	48 8b 5a 08	 mov	 rbx, QWORD PTR [rdx+8]

; 367  :     Py_hash_t hash = entry->hash;

  00018	48 8b 2a	 mov	 rbp, QWORD PTR [rdx]

; 368  : 
; 369  :     assert(so->fill <= so->mask);  /* at least one empty slot */
; 370  :     n_used = so->used;

  0001b	48 8b 71 68	 mov	 rsi, QWORD PTR [rcx+104]
  0001f	48 8b f9	 mov	 rdi, rcx

; 371  :     Py_INCREF(key);

  00022	e8 00 00 00 00	 call	 _Py_PXCTX
  00027	85 c0		 test	 eax, eax
  00029	75 32		 jne	 SHORT $LN9@set_add_en
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00039	4c 8b cb	 mov	 r9, rbx
  0003c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00042	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0004a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004f	85 c0		 test	 eax, eax
  00051	75 06		 jne	 SHORT $LN8@set_add_en
  00053	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00057	74 04		 je	 SHORT $LN9@set_add_en
$LN8@set_add_en:
  00059	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN9@set_add_en:

; 372  :     if (set_insert_key(so, key, hash) == -1) {

  0005d	4c 8b c5	 mov	 r8, rbp
  00060	48 8b d3	 mov	 rdx, rbx
  00063	48 8b cf	 mov	 rcx, rdi
  00066	e8 00 00 00 00	 call	 set_insert_key
  0006b	83 f8 ff	 cmp	 eax, -1
  0006e	75 0d		 jne	 SHORT $LN3@set_add_en

; 373  :         Py_DECREF(key);

  00070	48 8b cb	 mov	 rcx, rbx
  00073	e8 00 00 00 00	 call	 _Py_DecRef

; 374  :         return -1;

  00078	83 c8 ff	 or	 eax, -1
  0007b	eb 40		 jmp	 SHORT $LN4@set_add_en
$LN3@set_add_en:

; 375  :     }
; 376  :     if (!(so->used > n_used && so->fill*3 >= (so->mask+1)*2))

  0007d	4c 8b 47 68	 mov	 r8, QWORD PTR [rdi+104]
  00081	4c 3b c6	 cmp	 r8, rsi
  00084	7e 35		 jle	 SHORT $LN1@set_add_en
  00086	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  0008a	48 8d 54 00 02	 lea	 rdx, QWORD PTR [rax+rax+2]
  0008f	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00093	48 8d 0c 40	 lea	 rcx, QWORD PTR [rax+rax*2]
  00097	48 3b ca	 cmp	 rcx, rdx
  0009a	7c 1f		 jl	 SHORT $LN1@set_add_en

; 378  :     return set_table_resize(so, so->used>50000 ? so->used*2 : so->used*4);

  0009c	4b 8d 14 00	 lea	 rdx, QWORD PTR [r8+r8]
  000a0	49 81 f8 50 c3
	00 00		 cmp	 r8, 50000		; 0000c350H
  000a7	7f 08		 jg	 SHORT $LN7@set_add_en
  000a9	4a 8d 14 85 00
	00 00 00	 lea	 rdx, QWORD PTR [r8*4]
$LN7@set_add_en:
  000b1	48 8b cf	 mov	 rcx, rdi
  000b4	e8 00 00 00 00	 call	 set_table_resize
  000b9	eb 02		 jmp	 SHORT $LN4@set_add_en
$LN1@set_add_en:

; 377  :         return 0;

  000bb	33 c0		 xor	 eax, eax
$LN4@set_add_en:

; 379  : }

  000bd	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c2	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000c7	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000cc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d0	5f		 pop	 rdi
  000d1	c3		 ret	 0
set_add_entry ENDP
_TEXT	ENDS
EXTRN	PyObject_Hash:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_add_key DD imagerel set_add_key
	DD	imagerel set_add_key+264
	DD	imagerel $unwind$set_add_key
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_add_key DD 085401H
	DD	085454H
	DD	0a640fH
	DD	09340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_add_key
_TEXT	SEGMENT
so$ = 64
key$ = 72
set_add_key PROC					; COMDAT

; 383  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 384  :     register Py_hash_t hash;
; 385  :     register Py_ssize_t n_used;
; 386  : 
; 387  :     if (!PyUnicode_CheckExact(key) ||
; 388  :         (hash = ((PyASCIIObject *) key)->hash) == -1) {

  0000f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00016	48 8b da	 mov	 rbx, rdx
  00019	48 8b f9	 mov	 rdi, rcx
  0001c	48 39 42 58	 cmp	 QWORD PTR [rdx+88], rax
  00020	75 0a		 jne	 SHORT $LN5@set_add_ke
  00022	48 8b 72 68	 mov	 rsi, QWORD PTR [rdx+104]
  00026	48 83 fe ff	 cmp	 rsi, -1
  0002a	75 23		 jne	 SHORT $LN4@set_add_ke
$LN5@set_add_ke:

; 389  :         hash = PyObject_Hash(key);

  0002c	48 8b ca	 mov	 rcx, rdx
  0002f	e8 00 00 00 00	 call	 PyObject_Hash
  00034	48 8b f0	 mov	 rsi, rax

; 390  :         if (hash == -1)

  00037	48 83 f8 ff	 cmp	 rax, -1
  0003b	75 12		 jne	 SHORT $LN4@set_add_ke

; 391  :             return -1;

  0003d	0b c0		 or	 eax, eax

; 403  : }

  0003f	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00044	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00049	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
$LN4@set_add_ke:
  0004f	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp

; 392  :     }
; 393  :     assert(so->fill <= so->mask);  /* at least one empty slot */
; 394  :     n_used = so->used;

  00054	48 8b 6f 68	 mov	 rbp, QWORD PTR [rdi+104]

; 395  :     Py_INCREF(key);

  00058	e8 00 00 00 00	 call	 _Py_PXCTX
  0005d	85 c0		 test	 eax, eax
  0005f	75 32		 jne	 SHORT $LN12@set_add_ke
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0006f	4c 8b cb	 mov	 r9, rbx
  00072	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00078	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00080	e8 00 00 00 00	 call	 _PyParallel_Guard
  00085	85 c0		 test	 eax, eax
  00087	75 06		 jne	 SHORT $LN11@set_add_ke
  00089	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0008d	74 04		 je	 SHORT $LN12@set_add_ke
$LN11@set_add_ke:
  0008f	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN12@set_add_ke:

; 396  :     if (set_insert_key(so, key, hash) == -1) {

  00093	4c 8b c6	 mov	 r8, rsi
  00096	48 8b d3	 mov	 rdx, rbx
  00099	48 8b cf	 mov	 rcx, rdi
  0009c	e8 00 00 00 00	 call	 set_insert_key
  000a1	83 f8 ff	 cmp	 eax, -1
  000a4	75 0d		 jne	 SHORT $LN3@set_add_ke

; 397  :         Py_DECREF(key);

  000a6	48 8b cb	 mov	 rcx, rbx
  000a9	e8 00 00 00 00	 call	 _Py_DecRef

; 398  :         return -1;

  000ae	83 c8 ff	 or	 eax, -1
  000b1	eb 40		 jmp	 SHORT $LN15@set_add_ke
$LN3@set_add_ke:

; 399  :     }
; 400  :     if (!(so->used > n_used && so->fill*3 >= (so->mask+1)*2))

  000b3	4c 8b 47 68	 mov	 r8, QWORD PTR [rdi+104]
  000b7	4c 3b c5	 cmp	 r8, rbp
  000ba	7e 35		 jle	 SHORT $LN1@set_add_ke
  000bc	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  000c0	48 8d 54 00 02	 lea	 rdx, QWORD PTR [rax+rax+2]
  000c5	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  000c9	48 8d 0c 40	 lea	 rcx, QWORD PTR [rax+rax*2]
  000cd	48 3b ca	 cmp	 rcx, rdx
  000d0	7c 1f		 jl	 SHORT $LN1@set_add_ke

; 402  :     return set_table_resize(so, so->used>50000 ? so->used*2 : so->used*4);

  000d2	4b 8d 14 00	 lea	 rdx, QWORD PTR [r8+r8]
  000d6	49 81 f8 50 c3
	00 00		 cmp	 r8, 50000		; 0000c350H
  000dd	7f 08		 jg	 SHORT $LN10@set_add_ke
  000df	4a 8d 14 85 00
	00 00 00	 lea	 rdx, QWORD PTR [r8*4]
$LN10@set_add_ke:
  000e7	48 8b cf	 mov	 rcx, rdi
  000ea	e8 00 00 00 00	 call	 set_table_resize
  000ef	eb 02		 jmp	 SHORT $LN15@set_add_ke
$LN1@set_add_ke:

; 401  :         return 0;

  000f1	33 c0		 xor	 eax, eax
$LN15@set_add_ke:
  000f3	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 403  : }

  000f8	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000fd	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00102	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00106	5f		 pop	 rdi
  00107	c3		 ret	 0
set_add_key ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_discard_entry DD imagerel set_discard_entry
	DD	imagerel set_discard_entry+48
	DD	imagerel $unwind$set_discard_entry
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$set_discard_entry DD imagerel set_discard_entry+48
	DD	imagerel set_discard_entry+123
	DD	imagerel $chain$0$set_discard_entry
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$set_discard_entry DD imagerel set_discard_entry+123
	DD	imagerel set_discard_entry+141
	DD	imagerel $chain$2$set_discard_entry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$set_discard_entry DD 020021H
	DD	063400H
	DD	imagerel set_discard_entry
	DD	imagerel set_discard_entry+48
	DD	imagerel $unwind$set_discard_entry
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$set_discard_entry DD 020521H
	DD	063405H
	DD	imagerel set_discard_entry
	DD	imagerel set_discard_entry+48
	DD	imagerel $unwind$set_discard_entry
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_discard_entry DD 040a01H
	DD	07640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_discard_entry
_TEXT	SEGMENT
so$ = 48
oldentry$ = 56
set_discard_entry PROC					; COMDAT

; 410  : {       register setentry *entry;

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 411  :     PyObject *old_key;
; 412  : 
; 413  :     entry = (so->lookup)(so, oldentry->key, oldentry->hash);

  0000a	4c 8b 02	 mov	 r8, QWORD PTR [rdx]
  0000d	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00011	48 8b f1	 mov	 rsi, rcx
  00014	ff 96 80 00 00
	00		 call	 QWORD PTR [rsi+128]
  0001a	48 8b f8	 mov	 rdi, rax

; 414  :     if (entry == NULL)

  0001d	48 85 c0	 test	 rax, rax
  00020	75 0e		 jne	 SHORT $LN3@set_discar

; 415  :         return -1;

  00022	83 c8 ff	 or	 eax, -1

; 424  : }

  00025	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
$LN3@set_discar:
  00030	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 416  :     if (entry->key == NULL  ||  entry->key == dummy)

  00035	48 8b 58 08	 mov	 rbx, QWORD PTR [rax+8]
  00039	48 85 db	 test	 rbx, rbx
  0003c	74 3d		 je	 SHORT $LN1@set_discar
  0003e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  00045	48 3b d9	 cmp	 rbx, rcx
  00048	74 31		 je	 SHORT $LN1@set_discar

; 417  :         return DISCARD_NOTFOUND;
; 418  :     old_key = entry->key;
; 419  :     Py_INCREF(dummy);

  0004a	e8 00 00 00 00	 call	 _Py_IncRef

; 420  :     entry->key = dummy;

  0004f	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR dummy

; 421  :     so->used--;
; 422  :     Py_DECREF(old_key);

  00056	48 8b cb	 mov	 rcx, rbx
  00059	4c 89 5f 08	 mov	 QWORD PTR [rdi+8], r11
  0005d	48 ff 4e 68	 dec	 QWORD PTR [rsi+104]
  00061	e8 00 00 00 00	 call	 _Py_DecRef
  00066	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 423  :     return DISCARD_FOUND;

  0006b	b8 01 00 00 00	 mov	 eax, 1

; 424  : }

  00070	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5f		 pop	 rdi
  0007a	c3		 ret	 0
$LN1@set_discar:
  0007b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00080	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00085	33 c0		 xor	 eax, eax
  00087	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
set_discard_entry ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_discard_key DD imagerel set_discard_key
	DD	imagerel set_discard_key+75
	DD	imagerel $unwind$set_discard_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$set_discard_key DD imagerel set_discard_key+75
	DD	imagerel set_discard_key+113
	DD	imagerel $chain$0$set_discard_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$set_discard_key DD imagerel set_discard_key+113
	DD	imagerel set_discard_key+183
	DD	imagerel $chain$2$set_discard_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$set_discard_key DD imagerel set_discard_key+183
	DD	imagerel set_discard_key+201
	DD	imagerel $chain$4$set_discard_key
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$set_discard_key DD 020021H
	DD	067400H
	DD	imagerel set_discard_key
	DD	imagerel set_discard_key+75
	DD	imagerel $unwind$set_discard_key
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$set_discard_key DD 020021H
	DD	067400H
	DD	imagerel set_discard_key
	DD	imagerel set_discard_key+75
	DD	imagerel $unwind$set_discard_key
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$set_discard_key DD 020521H
	DD	067405H
	DD	imagerel set_discard_key
	DD	imagerel set_discard_key+75
	DD	imagerel $unwind$set_discard_key
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_discard_key DD 040a01H
	DD	07340aH
	DD	06006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_discard_key
_TEXT	SEGMENT
so$ = 48
key$ = 56
set_discard_key PROC					; COMDAT

; 428  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 429  :     register Py_hash_t hash;
; 430  :     register setentry *entry;
; 431  :     PyObject *old_key;
; 432  : 
; 433  :     assert (PyAnySet_Check(so));
; 434  : 
; 435  :     if (!PyUnicode_CheckExact(key) ||
; 436  :         (hash = ((PyASCIIObject *) key)->hash) == -1) {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00011	48 8b da	 mov	 rbx, rdx
  00014	48 8b f1	 mov	 rsi, rcx
  00017	48 39 42 58	 cmp	 QWORD PTR [rdx+88], rax
  0001b	75 0a		 jne	 SHORT $LN5@set_discar@2
  0001d	48 8b 42 68	 mov	 rax, QWORD PTR [rdx+104]
  00021	48 83 f8 ff	 cmp	 rax, -1
  00025	75 1b		 jne	 SHORT $LN4@set_discar@2
$LN5@set_discar@2:

; 437  :         hash = PyObject_Hash(key);

  00027	48 8b ca	 mov	 rcx, rdx
  0002a	e8 00 00 00 00	 call	 PyObject_Hash

; 438  :         if (hash == -1)

  0002f	48 83 f8 ff	 cmp	 rax, -1
  00033	75 0d		 jne	 SHORT $LN4@set_discar@2

; 439  :             return -1;

  00035	0b c0		 or	 eax, eax

; 452  : }

  00037	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5e		 pop	 rsi
  00041	c3		 ret	 0
$LN4@set_discar@2:

; 440  :     }
; 441  :     entry = (so->lookup)(so, key, hash);

  00042	4c 8b c0	 mov	 r8, rax
  00045	48 8b d3	 mov	 rdx, rbx
  00048	48 8b ce	 mov	 rcx, rsi
  0004b	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00050	ff 96 80 00 00
	00		 call	 QWORD PTR [rsi+128]
  00056	48 8b f8	 mov	 rdi, rax

; 442  :     if (entry == NULL)

  00059	48 85 c0	 test	 rax, rax
  0005c	75 13		 jne	 SHORT $LN3@set_discar@2

; 443  :         return -1;

  0005e	83 c8 ff	 or	 eax, -1
  00061	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 452  : }

  00066	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0006b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006f	5e		 pop	 rsi
  00070	c3		 ret	 0
$LN3@set_discar@2:

; 444  :     if (entry->key == NULL  ||  entry->key == dummy)

  00071	48 8b 58 08	 mov	 rbx, QWORD PTR [rax+8]
  00075	48 85 db	 test	 rbx, rbx
  00078	74 3d		 je	 SHORT $LN1@set_discar@2
  0007a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  00081	48 3b d9	 cmp	 rbx, rcx
  00084	74 31		 je	 SHORT $LN1@set_discar@2

; 445  :         return DISCARD_NOTFOUND;
; 446  :     old_key = entry->key;
; 447  :     Py_INCREF(dummy);

  00086	e8 00 00 00 00	 call	 _Py_IncRef

; 448  :     entry->key = dummy;

  0008b	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR dummy

; 449  :     so->used--;
; 450  :     Py_DECREF(old_key);

  00092	48 8b cb	 mov	 rcx, rbx
  00095	4c 89 5f 08	 mov	 QWORD PTR [rdi+8], r11
  00099	48 ff 4e 68	 dec	 QWORD PTR [rsi+104]
  0009d	e8 00 00 00 00	 call	 _Py_DecRef
  000a2	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 451  :     return DISCARD_FOUND;

  000a7	b8 01 00 00 00	 mov	 eax, 1

; 452  : }

  000ac	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000b1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b5	5e		 pop	 rsi
  000b6	c3		 ret	 0
$LN1@set_discar@2:
  000b7	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  000bc	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000c1	33 c0		 xor	 eax, eax
  000c3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c7	5e		 pop	 rsi
  000c8	c3		 ret	 0
set_discard_key ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_clear_internal DD imagerel set_clear_internal
	DD	imagerel set_clear_internal+381
	DD	imagerel $unwind$set_clear_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_clear_internal DD 0b1b01H
	DD	01c641bH
	DD	01b541bH
	DD	01a341bH
	DD	016011bH
	DD	0c012d014H
	DD	07010H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_clear_internal
_TEXT	SEGMENT
small_copy$ = 48
so$ = 208
set_clear_internal PROC					; COMDAT

; 456  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H

; 457  :     setentry *entry, *table;
; 458  :     int table_is_malloced;
; 459  :     Py_ssize_t fill;
; 460  :     setentry small_copy[PySet_MINSIZE];
; 461  : #ifdef Py_DEBUG
; 462  :     Py_ssize_t i, n;
; 463  :     assert (PyAnySet_Check(so));
; 464  : 
; 465  :     n = so->mask + 1;
; 466  :     i = 0;
; 467  : #endif
; 468  : 
; 469  :     table = so->table;

  0001b	48 8b 69 78	 mov	 rbp, QWORD PTR [rcx+120]

; 470  :     assert(table != NULL);
; 471  :     table_is_malloced = table != so->smalltable;
; 472  : 
; 473  :     /* This is delicate.  During the process of clearing the set,
; 474  :      * decrefs can cause the set to mutate.  To avoid fatal confusion
; 475  :      * (voice of experience), we have to make the set empty before
; 476  :      * clearing the slots, and never refer to anything via so->ref while
; 477  :      * clearing.
; 478  :      */
; 479  :     fill = so->fill;

  0001f	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]
  00023	45 33 ed	 xor	 r13d, r13d
  00026	45 8b e5	 mov	 r12d, r13d
  00029	48 8d b1 88 00
	00 00		 lea	 rsi, QWORD PTR [rcx+136]
  00030	48 8b d9	 mov	 rbx, rcx
  00033	48 3b ee	 cmp	 rbp, rsi
  00036	41 0f 95 c4	 setne	 r12b

; 480  :     if (table_is_malloced)

  0003a	45 85 e4	 test	 r12d, r12d

; 481  :         EMPTY_TO_MINSIZE(so);
; 482  : 
; 483  :     else if (fill > 0) {

  0003d	75 50		 jne	 SHORT $LN39@set_clear_
  0003f	48 85 ff	 test	 rdi, rdi
  00042	0f 8e f8 00 00
	00		 jle	 $LN3@set_clear_

; 484  :         /* It's a small table with something that needs to be cleared.
; 485  :          * Afraid the only safe way is to copy the set entries into
; 486  :          * another small table first.
; 487  :          */
; 488  :         memcpy(small_copy, table, sizeof(small_copy));

  00048	0f 10 45 00	 movups	 xmm0, XMMWORD PTR [rbp]
  0004c	0f 29 44 24 30	 movaps	 XMMWORD PTR small_copy$[rsp], xmm0
  00051	0f 10 4d 10	 movups	 xmm1, XMMWORD PTR [rbp+16]
  00055	0f 29 4c 24 40	 movaps	 XMMWORD PTR small_copy$[rsp+16], xmm1
  0005a	0f 10 45 20	 movups	 xmm0, XMMWORD PTR [rbp+32]
  0005e	0f 29 40 88	 movaps	 XMMWORD PTR [rax-120], xmm0
  00062	0f 10 4d 30	 movups	 xmm1, XMMWORD PTR [rbp+48]
  00066	0f 29 48 98	 movaps	 XMMWORD PTR [rax-104], xmm1
  0006a	0f 10 45 40	 movups	 xmm0, XMMWORD PTR [rbp+64]
  0006e	0f 29 40 a8	 movaps	 XMMWORD PTR [rax-88], xmm0
  00072	0f 10 4d 50	 movups	 xmm1, XMMWORD PTR [rbp+80]
  00076	0f 29 48 b8	 movaps	 XMMWORD PTR [rax-72], xmm1
  0007a	0f 10 45 60	 movups	 xmm0, XMMWORD PTR [rbp+96]
  0007e	0f 29 40 c8	 movaps	 XMMWORD PTR [rax-56], xmm0
  00082	0f 10 4d 70	 movups	 xmm1, XMMWORD PTR [rbp+112]

; 489  :         table = small_copy;

  00086	48 8d 6c 24 30	 lea	 rbp, QWORD PTR small_copy$[rsp]
  0008b	0f 29 48 d8	 movaps	 XMMWORD PTR [rax-40], xmm1
$LN39@set_clear_:

; 490  :         EMPTY_TO_MINSIZE(so);

  0008f	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00095	33 d2		 xor	 edx, edx
  00097	48 8b ce	 mov	 rcx, rsi
  0009a	e8 00 00 00 00	 call	 memset
  0009f	48 c7 83 08 01
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rbx+264], -1
  000aa	48 c7 43 70 07
	00 00 00	 mov	 QWORD PTR [rbx+112], 7
  000b2	48 89 73 78	 mov	 QWORD PTR [rbx+120], rsi
  000b6	4c 89 6b 68	 mov	 QWORD PTR [rbx+104], r13
  000ba	4c 89 6b 60	 mov	 QWORD PTR [rbx+96], r13

; 491  :     }
; 492  :     /* else it's a small table that's already empty */
; 493  : 
; 494  :     /* Now we can finally clear things.  If C had refcounts, we could
; 495  :      * assert that the refcount on table is 1 now, i.e. that this function
; 496  :      * has unique access to it, so decref side-effects can't alter it.
; 497  :      */
; 498  :     for (entry = table; fill > 0; ++entry) {

  000be	48 85 ff	 test	 rdi, rdi
  000c1	7e 7d		 jle	 SHORT $LN3@set_clear_
  000c3	48 8d 75 08	 lea	 rsi, QWORD PTR [rbp+8]
$LL5@set_clear_:

; 499  : #ifdef Py_DEBUG
; 500  :         assert(i < n);
; 501  :         ++i;
; 502  : #endif
; 503  :         if (entry->key) {

  000c7	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
  000ca	48 85 db	 test	 rbx, rbx
  000cd	74 68		 je	 SHORT $LN4@set_clear_

; 504  :             --fill;

  000cf	48 ff cf	 dec	 rdi

; 505  :             Py_DECREF(entry->key);

  000d2	e8 00 00 00 00	 call	 _Py_PXCTX
  000d7	85 c0		 test	 eax, eax
  000d9	75 5c		 jne	 SHORT $LN4@set_clear_
  000db	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000df	a8 20		 test	 al, 32			; 00000020H
  000e1	75 4c		 jne	 SHORT $LN29@set_clear_
  000e3	84 c0		 test	 al, al
  000e5	78 48		 js	 SHORT $LN29@set_clear_
  000e7	a8 02		 test	 al, 2
  000e9	75 4c		 jne	 SHORT $LN4@set_clear_
  000eb	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000ef	75 46		 jne	 SHORT $LN4@set_clear_
  000f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000ff	4c 8b cb	 mov	 r9, rbx
  00102	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00108	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00110	e8 00 00 00 00	 call	 _PyParallel_Guard
  00115	48 8b cb	 mov	 rcx, rbx
  00118	85 c0		 test	 eax, eax
  0011a	74 07		 je	 SHORT $LN34@set_clear_
  0011c	e8 00 00 00 00	 call	 _Px_Dealloc
  00121	eb 14		 jmp	 SHORT $LN4@set_clear_
$LN34@set_clear_:
  00123	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00127	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0012d	eb 08		 jmp	 SHORT $LN4@set_clear_
$LN29@set_clear_:
  0012f	48 8b cb	 mov	 rcx, rbx
  00132	e8 00 00 00 00	 call	 Px_DecRef
$LN4@set_clear_:

; 491  :     }
; 492  :     /* else it's a small table that's already empty */
; 493  : 
; 494  :     /* Now we can finally clear things.  If C had refcounts, we could
; 495  :      * assert that the refcount on table is 1 now, i.e. that this function
; 496  :      * has unique access to it, so decref side-effects can't alter it.
; 497  :      */
; 498  :     for (entry = table; fill > 0; ++entry) {

  00137	48 83 c6 10	 add	 rsi, 16
  0013b	48 85 ff	 test	 rdi, rdi
  0013e	7f 87		 jg	 SHORT $LL5@set_clear_
$LN3@set_clear_:

; 506  :         }
; 507  : #ifdef Py_DEBUG
; 508  :         else
; 509  :             assert(entry->key == NULL);
; 510  : #endif
; 511  :     }
; 512  : 
; 513  :     if (table_is_malloced)

  00140	45 85 e4	 test	 r12d, r12d
  00143	74 19		 je	 SHORT $LN38@set_clear_

; 514  :         PyMem_DEL(table);

  00145	e8 00 00 00 00	 call	 _Py_PXCTX
  0014a	48 8b cd	 mov	 rcx, rbp
  0014d	85 c0		 test	 eax, eax
  0014f	74 07		 je	 SHORT $LN23@set_clear_
  00151	e8 00 00 00 00	 call	 _PxMem_Free
  00156	eb 06		 jmp	 SHORT $LN38@set_clear_
$LN23@set_clear_:
  00158	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN38@set_clear_:

; 515  :     return 0;
; 516  : }

  0015e	4c 8d 9c 24 b0
	00 00 00	 lea	 r11, QWORD PTR [rsp+176]
  00166	33 c0		 xor	 eax, eax
  00168	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  0016c	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  00170	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  00174	49 8b e3	 mov	 rsp, r11
  00177	41 5d		 pop	 r13
  00179	41 5c		 pop	 r12
  0017b	5f		 pop	 rdi
  0017c	c3		 ret	 0
set_clear_internal ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_next DD imagerel set_next
	DD	imagerel set_next+114
	DD	imagerel $unwind$set_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_next DD 020501H
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_next
_TEXT	SEGMENT
so$ = 8
pos_ptr$ = 16
entry_ptr$ = 24
set_next PROC						; COMDAT

; 533  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 534  :     Py_ssize_t i;
; 535  :     Py_ssize_t mask;
; 536  :     register setentry *table;
; 537  : 
; 538  :     assert (PyAnySet_Check(so));
; 539  :     i = *pos_ptr;

  00005	4c 8b 0a	 mov	 r9, QWORD PTR [rdx]

; 540  :     assert(i >= 0);
; 541  :     table = so->table;
; 542  :     mask = so->mask;

  00008	4c 8b 51 70	 mov	 r10, QWORD PTR [rcx+112]
  0000c	49 8b d8	 mov	 rbx, r8
  0000f	4c 8b c2	 mov	 r8, rdx
  00012	48 8b 51 78	 mov	 rdx, QWORD PTR [rcx+120]

; 543  :     while (i <= mask && (table[i].key == NULL || table[i].key == dummy))

  00016	4d 3b ca	 cmp	 r9, r10
  00019	7f 2e		 jg	 SHORT $LN9@set_next

; 534  :     Py_ssize_t i;
; 535  :     Py_ssize_t mask;
; 536  :     register setentry *table;
; 537  : 
; 538  :     assert (PyAnySet_Check(so));
; 539  :     i = *pos_ptr;

  0001b	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR dummy
  00022	49 8b c1	 mov	 rax, r9
  00025	48 03 c0	 add	 rax, rax
  00028	48 8d 4c c2 08	 lea	 rcx, QWORD PTR [rdx+rax*8+8]
  0002d	0f 1f 00	 npad	 3
$LL4@set_next:

; 543  :     while (i <= mask && (table[i].key == NULL || table[i].key == dummy))

  00030	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00033	48 85 c0	 test	 rax, rax
  00036	74 05		 je	 SHORT $LN2@set_next
  00038	49 3b c3	 cmp	 rax, r11
  0003b	75 0c		 jne	 SHORT $LN9@set_next
$LN2@set_next:

; 544  :         i++;

  0003d	49 ff c1	 inc	 r9
  00040	48 83 c1 10	 add	 rcx, 16
  00044	4d 3b ca	 cmp	 r9, r10
  00047	7e e7		 jle	 SHORT $LL4@set_next
$LN9@set_next:

; 545  :     *pos_ptr = i+1;

  00049	49 8d 41 01	 lea	 rax, QWORD PTR [r9+1]
  0004d	49 89 00	 mov	 QWORD PTR [r8], rax

; 546  :     if (i > mask)

  00050	4d 3b ca	 cmp	 r9, r10
  00053	7e 08		 jle	 SHORT $LN1@set_next

; 547  :         return 0;

  00055	33 c0		 xor	 eax, eax

; 551  : }

  00057	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0005c	c3		 ret	 0
$LN1@set_next:

; 548  :     assert(table[i].key != NULL);
; 549  :     *entry_ptr = &table[i];

  0005d	49 c1 e1 04	 shl	 r9, 4

; 550  :     return 1;

  00061	b8 01 00 00 00	 mov	 eax, 1
  00066	4c 03 ca	 add	 r9, rdx
  00069	4c 89 0b	 mov	 QWORD PTR [rbx], r9

; 551  : }

  0006c	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00071	c3		 ret	 0
set_next ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@MKNKIMNJ@set_dealloc?$AA@		; `string'
PUBLIC	??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@ ; `string'
EXTRN	_PyTrash_thread_deposit_object:PROC
EXTRN	_PyTrash_thread_destroy_chain:PROC
EXTRN	PyObject_ClearWeakRefs:PROC
EXTRN	_PyThreadState_Current:QWORD
EXTRN	_PyParallel_GetThreadState:PROC
EXTRN	PyObject_GC_UnTrack:PROC
EXTRN	_PyParallel_ContextGuardFailure:PROC
_BSS	SEGMENT
free_list DQ	050H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_dealloc DD imagerel set_dealloc
	DD	imagerel set_dealloc+111
	DD	imagerel $unwind$set_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$set_dealloc DD imagerel set_dealloc+111
	DD	imagerel set_dealloc+153
	DD	imagerel $chain$0$set_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$set_dealloc DD imagerel set_dealloc+153
	DD	imagerel set_dealloc+288
	DD	imagerel $chain$1$set_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$set_dealloc DD imagerel set_dealloc+288
	DD	imagerel set_dealloc+306
	DD	imagerel $chain$2$set_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$set_dealloc DD imagerel set_dealloc+306
	DD	imagerel set_dealloc+477
	DD	imagerel $chain$3$set_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$set_dealloc DD 021H
	DD	imagerel set_dealloc
	DD	imagerel set_dealloc+111
	DD	imagerel $unwind$set_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$set_dealloc DD 021H
	DD	imagerel set_dealloc+111
	DD	imagerel set_dealloc+153
	DD	imagerel $chain$0$set_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$set_dealloc DD 020521H
	DD	083405H
	DD	imagerel set_dealloc+111
	DD	imagerel set_dealloc+153
	DD	imagerel $chain$0$set_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$set_dealloc DD 020521H
	DD	096405H
	DD	imagerel set_dealloc
	DD	imagerel set_dealloc+111
	DD	imagerel $unwind$set_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_dealloc DD 061001H
	DD	0b7410H
	DD	0a5410H
	DD	0c00c5210H
xdata	ENDS
;	COMDAT ??_C@_0M@MKNKIMNJ@set_dealloc?$AA@
CONST	SEGMENT
??_C@_0M@MKNKIMNJ@set_dealloc?$AA@ DB 'set_dealloc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
CONST	SEGMENT
??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@ DB '..\Objects\setobj'
	DB	'ect.c', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
CONST	ENDS
;	COMDAT set_dealloc
_TEXT	SEGMENT
so$ = 64
set_dealloc PROC					; COMDAT

; 555  : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000a	41 54		 push	 r12
  0000c	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 556  :     register setentry *entry;
; 557  :     Py_ssize_t fill = so->fill;

  00010	4c 8b 61 60	 mov	 r12, QWORD PTR [rcx+96]
  00014	48 8b f9	 mov	 rdi, rcx

; 558  :     Py_GUARD

  00017	e8 00 00 00 00	 call	 _Py_PXCTX
  0001c	85 c0		 test	 eax, eax
  0001e	74 1c		 je	 SHORT $LN16@set_deallo
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@MKNKIMNJ@set_dealloc?$AA@
  0002e	45 33 c9	 xor	 r9d, r9d
  00031	41 b8 2e 02 00
	00		 mov	 r8d, 558		; 0000022eH
  00037	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN16@set_deallo:

; 559  :     PyObject_GC_UnTrack(so);

  0003c	48 8b cf	 mov	 rcx, rdi
  0003f	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 560  :     Py_TRASHCAN_SAFE_BEGIN(so)

  00044	e8 00 00 00 00	 call	 _Py_PXCTX
  00049	85 c0		 test	 eax, eax
  0004b	74 0a		 je	 SHORT $LN19@set_deallo
  0004d	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00052	48 8b e8	 mov	 rbp, rax
  00055	eb 07		 jmp	 SHORT $LN20@set_deallo
$LN19@set_deallo:
  00057	48 8b 2d 00 00
	00 00		 mov	 rbp, QWORD PTR _PyThreadState_Current
$LN20@set_deallo:
  0005e	8b 85 94 00 00
	00		 mov	 eax, DWORD PTR [rbp+148]
  00064	83 f8 32	 cmp	 eax, 50			; 00000032H
  00067	0f 8d 57 01 00
	00		 jge	 $LN12@set_deallo
  0006d	ff c0		 inc	 eax
  0006f	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00074	89 85 94 00 00
	00		 mov	 DWORD PTR [rbp+148], eax

; 561  :     if (so->weakreflist != NULL)

  0007a	48 83 bf 10 01
	00 00 00	 cmp	 QWORD PTR [rdi+272], 0
  00082	74 08		 je	 SHORT $LN11@set_deallo

; 562  :         PyObject_ClearWeakRefs((PyObject *) so);

  00084	48 8b cf	 mov	 rcx, rdi
  00087	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN11@set_deallo:

; 563  : 
; 564  :     for (entry = so->table; fill > 0; entry++) {

  0008c	48 8b 77 78	 mov	 rsi, QWORD PTR [rdi+120]
  00090	4d 85 e4	 test	 r12, r12
  00093	0f 8e 87 00 00
	00		 jle	 $LN8@set_deallo
  00099	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0009e	48 83 c6 08	 add	 rsi, 8
$LL10@set_deallo:

; 565  :         if (entry->key) {

  000a2	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
  000a5	48 85 db	 test	 rbx, rbx
  000a8	74 68		 je	 SHORT $LN9@set_deallo

; 566  :             --fill;

  000aa	49 ff cc	 dec	 r12

; 567  :             Py_DECREF(entry->key);

  000ad	e8 00 00 00 00	 call	 _Py_PXCTX
  000b2	85 c0		 test	 eax, eax
  000b4	75 5c		 jne	 SHORT $LN9@set_deallo
  000b6	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000ba	a8 20		 test	 al, 32			; 00000020H
  000bc	75 4c		 jne	 SHORT $LN27@set_deallo
  000be	84 c0		 test	 al, al
  000c0	78 48		 js	 SHORT $LN27@set_deallo
  000c2	a8 02		 test	 al, 2
  000c4	75 4c		 jne	 SHORT $LN9@set_deallo
  000c6	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000ca	75 46		 jne	 SHORT $LN9@set_deallo
  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000da	4c 8b cb	 mov	 r9, rbx
  000dd	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000e3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000eb	e8 00 00 00 00	 call	 _PyParallel_Guard
  000f0	48 8b cb	 mov	 rcx, rbx
  000f3	85 c0		 test	 eax, eax
  000f5	74 07		 je	 SHORT $LN32@set_deallo
  000f7	e8 00 00 00 00	 call	 _Px_Dealloc
  000fc	eb 14		 jmp	 SHORT $LN9@set_deallo
$LN32@set_deallo:
  000fe	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00102	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00108	eb 08		 jmp	 SHORT $LN9@set_deallo
$LN27@set_deallo:
  0010a	48 8b cb	 mov	 rcx, rbx
  0010d	e8 00 00 00 00	 call	 Px_DecRef
$LN9@set_deallo:

; 563  : 
; 564  :     for (entry = so->table; fill > 0; entry++) {

  00112	48 83 c6 10	 add	 rsi, 16
  00116	4d 85 e4	 test	 r12, r12
  00119	7f 87		 jg	 SHORT $LL10@set_deallo
  0011b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN8@set_deallo:
  00120	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 568  :         }
; 569  :     }
; 570  :     if (so->table != so->smalltable)

  00125	48 8d 87 88 00
	00 00		 lea	 rax, QWORD PTR [rdi+136]
  0012c	48 39 47 78	 cmp	 QWORD PTR [rdi+120], rax
  00130	74 1a		 je	 SHORT $LN22@set_deallo

; 571  :         PyMem_DEL(so->table);

  00132	e8 00 00 00 00	 call	 _Py_PXCTX
  00137	48 8b 4f 78	 mov	 rcx, QWORD PTR [rdi+120]
  0013b	85 c0		 test	 eax, eax
  0013d	74 07		 je	 SHORT $LN21@set_deallo
  0013f	e8 00 00 00 00	 call	 _PxMem_Free
  00144	eb 06		 jmp	 SHORT $LN22@set_deallo
$LN21@set_deallo:
  00146	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN22@set_deallo:

; 572  :     if (numfree < PySet_MAXFREELIST && PyAnySet_CheckExact(so))

  0014c	48 63 0d 00 00
	00 00		 movsxd	 rcx, DWORD PTR numfree
  00153	83 f9 50	 cmp	 ecx, 80			; 00000050H
  00156	7d 31		 jge	 SHORT $LN5@set_deallo
  00158	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0015c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00163	48 3b c2	 cmp	 rax, rdx
  00166	74 0c		 je	 SHORT $LN4@set_deallo
  00168	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  0016f	48 3b c2	 cmp	 rax, rdx
  00172	75 15		 jne	 SHORT $LN5@set_deallo
$LN4@set_deallo:

; 573  :         free_list[numfree++] = so;

  00174	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:free_list
  0017b	48 89 3c ca	 mov	 QWORD PTR [rdx+rcx*8], rdi
  0017f	ff c1		 inc	 ecx
  00181	89 0d 00 00 00
	00		 mov	 DWORD PTR numfree, ecx

; 574  :     else

  00187	eb 0d		 jmp	 SHORT $LN3@set_deallo
$LN5@set_deallo:

; 575  :         Py_TYPE(so)->tp_free(so);

  00189	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0018d	48 8b cf	 mov	 rcx, rdi
  00190	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]
$LN3@set_deallo:

; 576  :     Py_TRASHCAN_SAFE_END(so)

  00196	ff 8d 94 00 00
	00		 dec	 DWORD PTR [rbp+148]
  0019c	48 83 bd 98 00
	00 00 00	 cmp	 QWORD PTR [rbp+152], 0
  001a4	74 26		 je	 SHORT $LN14@set_deallo
  001a6	83 bd 94 00 00
	00 00		 cmp	 DWORD PTR [rbp+148], 0
  001ad	7f 1d		 jg	 SHORT $LN14@set_deallo

; 577  : }

  001af	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  001b4	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  001b9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001bd	41 5c		 pop	 r12
  001bf	e9 00 00 00 00	 jmp	 _PyTrash_thread_destroy_chain
$LN12@set_deallo:

; 576  :     Py_TRASHCAN_SAFE_END(so)

  001c4	48 8b cf	 mov	 rcx, rdi
  001c7	e8 00 00 00 00	 call	 _PyTrash_thread_deposit_object
$LN14@set_deallo:

; 577  : }

  001cc	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  001d1	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  001d6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001da	41 5c		 pop	 r12
  001dc	c3		 ret	 0
set_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_04NANFGNNA@?$HL?$CFU?$HN?$AA@		; `string'
PUBLIC	??_C@_08IDGFALDL@?$CFs?$CI?$HL?$CFU?$HN?$CJ?$AA@ ; `string'
PUBLIC	??_C@_04DLGOCPFH@?$CFs?$CI?$CJ?$AA@		; `string'
PUBLIC	??_C@_07FFLNLMCA@?$CFs?$CI?4?4?4?$CJ?$AA@	; `string'
EXTRN	PyUnicode_Substring:PROC
EXTRN	PyObject_Repr:PROC
EXTRN	PySequence_List:PROC
EXTRN	Py_ReprLeave:PROC
EXTRN	PyUnicode_FromFormat:PROC
EXTRN	Py_ReprEnter:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_repr DD imagerel set_repr
	DD	imagerel set_repr+138
	DD	imagerel $unwind$set_repr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$set_repr DD imagerel set_repr+138
	DD	imagerel set_repr+268
	DD	imagerel $chain$1$set_repr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$set_repr DD imagerel set_repr+268
	DD	imagerel set_repr+295
	DD	imagerel $chain$2$set_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$set_repr DD 021H
	DD	imagerel set_repr
	DD	imagerel set_repr+138
	DD	imagerel $unwind$set_repr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$set_repr DD 020521H
	DD	065405H
	DD	imagerel set_repr
	DD	imagerel set_repr+138
	DD	imagerel $unwind$set_repr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_repr DD 067601H
	DD	077476H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT ??_C@_04NANFGNNA@?$HL?$CFU?$HN?$AA@
CONST	SEGMENT
??_C@_04NANFGNNA@?$HL?$CFU?$HN?$AA@ DB '{%U}', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDGFALDL@?$CFs?$CI?$HL?$CFU?$HN?$CJ?$AA@
CONST	SEGMENT
??_C@_08IDGFALDL@?$CFs?$CI?$HL?$CFU?$HN?$CJ?$AA@ DB '%s({%U})', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DLGOCPFH@?$CFs?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_04DLGOCPFH@?$CFs?$CI?$CJ?$AA@ DB '%s()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07FFLNLMCA@?$CFs?$CI?4?4?4?$CJ?$AA@
CONST	SEGMENT
??_C@_07FFLNLMCA@?$CFs?$CI?4?4?4?$CJ?$AA@ DB '%s(...)', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT set_repr
_TEXT	SEGMENT
so$ = 48
set_repr PROC						; COMDAT

; 581  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 582  :     PyObject *result=NULL, *keys, *listrepr, *tmp;

  0000d	33 f6		 xor	 esi, esi

; 583  :     int status = Py_ReprEnter((PyObject*)so);

  0000f	e8 00 00 00 00	 call	 Py_ReprEnter

; 584  : 
; 585  :     if (status != 0) {

  00014	85 c0		 test	 eax, eax
  00016	74 2d		 je	 SHORT $LN8@set_repr

; 586  :         if (status < 0)

  00018	79 0d		 jns	 SHORT $LN7@set_repr

; 587  :             return NULL;

  0001a	33 c0		 xor	 eax, eax

; 621  :     return result;
; 622  : }

  0001c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5e		 pop	 rsi
  00026	c3		 ret	 0
$LN7@set_repr:

; 588  :         return PyUnicode_FromFormat("%s(...)", Py_TYPE(so)->tp_name);

  00027	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07FFLNLMCA@?$CFs?$CI?4?4?4?$CJ?$AA@
  00032	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]

; 621  :     return result;
; 622  : }

  00036	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5e		 pop	 rsi
  00040	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
$LN8@set_repr:

; 589  :     }
; 590  : 
; 591  :     /* shortcut for the empty set */
; 592  :     if (!so->used) {
; 593  :         Py_ReprLeave((PyObject*)so);

  00045	48 8b cb	 mov	 rcx, rbx
  00048	48 39 73 68	 cmp	 QWORD PTR [rbx+104], rsi
  0004c	75 23		 jne	 SHORT $LN6@set_repr
  0004e	e8 00 00 00 00	 call	 Py_ReprLeave

; 594  :         return PyUnicode_FromFormat("%s()", Py_TYPE(so)->tp_name);

  00053	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04DLGOCPFH@?$CFs?$CI?$CJ?$AA@
  0005e	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]

; 621  :     return result;
; 622  : }

  00062	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5e		 pop	 rsi
  0006c	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
$LN6@set_repr:
  00071	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 595  :     }
; 596  : 
; 597  :     keys = PySequence_List((PyObject *)so);

  00076	e8 00 00 00 00	 call	 PySequence_List
  0007b	48 8b f8	 mov	 rdi, rax

; 598  :     if (keys == NULL)

  0007e	48 85 c0	 test	 rax, rax
  00081	0f 84 85 00 00
	00		 je	 $done$20661

; 599  :         goto done;
; 600  : 
; 601  :     /* repr(keys)[1:-1] */
; 602  :     listrepr = PyObject_Repr(keys);

  00087	48 8b c8	 mov	 rcx, rax
  0008a	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0008f	e8 00 00 00 00	 call	 PyObject_Repr

; 603  :     Py_DECREF(keys);

  00094	48 8b cf	 mov	 rcx, rdi
  00097	48 8b e8	 mov	 rbp, rax
  0009a	e8 00 00 00 00	 call	 _Py_DecRef

; 604  :     if (listrepr == NULL)

  0009f	48 85 ed	 test	 rbp, rbp
  000a2	74 63		 je	 SHORT $LN11@set_repr

; 605  :         goto done;
; 606  :     tmp = PyUnicode_Substring(listrepr, 1, PyUnicode_GET_LENGTH(listrepr)-1);

  000a4	4c 8b 45 60	 mov	 r8, QWORD PTR [rbp+96]
  000a8	ba 01 00 00 00	 mov	 edx, 1
  000ad	48 8b cd	 mov	 rcx, rbp
  000b0	49 ff c8	 dec	 r8
  000b3	e8 00 00 00 00	 call	 PyUnicode_Substring

; 607  :     Py_DECREF(listrepr);

  000b8	48 8b cd	 mov	 rcx, rbp
  000bb	48 8b f8	 mov	 rdi, rax
  000be	e8 00 00 00 00	 call	 _Py_DecRef

; 608  :     if (tmp == NULL)

  000c3	48 85 ff	 test	 rdi, rdi
  000c6	74 3f		 je	 SHORT $LN11@set_repr

; 609  :         goto done;
; 610  :     listrepr = tmp;
; 611  : 
; 612  :     if (Py_TYPE(so) != &PySet_Type)

  000c8	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  000cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  000d3	48 3b d0	 cmp	 rdx, rax
  000d6	74 15		 je	 SHORT $LN2@set_repr

; 613  :         result = PyUnicode_FromFormat("%s({%U})",
; 614  :                                       Py_TYPE(so)->tp_name,
; 615  :                                       listrepr);

  000d8	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08IDGFALDL@?$CFs?$CI?$HL?$CFU?$HN?$CJ?$AA@
  000e3	4c 8b c7	 mov	 r8, rdi
  000e6	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 616  :     else

  000eb	eb 0f		 jmp	 SHORT $LN12@set_repr
$LN2@set_repr:

; 617  :         result = PyUnicode_FromFormat("{%U}", listrepr);

  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04NANFGNNA@?$HL?$CFU?$HN?$AA@
  000f4	48 8b d7	 mov	 rdx, rdi
  000f7	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN12@set_repr:

; 618  :     Py_DECREF(listrepr);

  000fc	48 8b cf	 mov	 rcx, rdi
  000ff	48 8b f0	 mov	 rsi, rax
  00102	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@set_repr:
  00107	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
$done$20661:

; 619  : done:
; 620  :     Py_ReprLeave((PyObject*)so);

  0010c	48 8b cb	 mov	 rcx, rbx
  0010f	e8 00 00 00 00	 call	 Py_ReprLeave
  00114	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 621  :     return result;
; 622  : }

  00119	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0011e	48 8b c6	 mov	 rax, rsi
  00121	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00125	5e		 pop	 rsi
  00126	c3		 ret	 0
set_repr ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT set_len
_TEXT	SEGMENT
so$ = 8
set_len	PROC						; COMDAT

; 627  :     return ((PySetObject *)so)->used;

  00000	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]

; 628  : }

  00004	c3		 ret	 0
set_len	ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_merge DD imagerel set_merge
	DD	imagerel set_merge+92
	DD	imagerel $unwind$set_merge
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$set_merge DD imagerel set_merge+92
	DD	imagerel set_merge+276
	DD	imagerel $chain$3$set_merge
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$set_merge DD imagerel set_merge+276
	DD	imagerel set_merge+289
	DD	imagerel $chain$5$set_merge
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$set_merge DD imagerel set_merge+289
	DD	imagerel set_merge+299
	DD	imagerel $chain$6$set_merge
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$set_merge DD 021H
	DD	imagerel set_merge
	DD	imagerel set_merge+92
	DD	imagerel $unwind$set_merge
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$set_merge DD 080021H
	DD	06d400H
	DD	0c7400H
	DD	0b6400H
	DD	0a3400H
	DD	imagerel set_merge
	DD	imagerel set_merge+92
	DD	imagerel $unwind$set_merge
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$set_merge DD 081621H
	DD	06d416H
	DD	0c740fH
	DD	0b640aH
	DD	0a3405H
	DD	imagerel set_merge
	DD	imagerel set_merge+92
	DD	imagerel $unwind$set_merge
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_merge DD 030801H
	DD	0c0046208H
	DD	05002H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_merge
_TEXT	SEGMENT
so$ = 80
otherset$ = 88
set_merge PROC						; COMDAT

; 632  : {

  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00008	48 8b ea	 mov	 rbp, rdx
  0000b	4c 8b e1	 mov	 r12, rcx

; 633  :     PySetObject *other;
; 634  :     PyObject *key;
; 635  :     Py_hash_t hash;
; 636  :     register Py_ssize_t i;
; 637  :     register setentry *entry;
; 638  : 
; 639  :     assert (PyAnySet_Check(so));
; 640  :     assert (PyAnySet_Check(otherset));
; 641  : 
; 642  :     other = (PySetObject*)otherset;
; 643  :     if (other == so || other->used == 0)

  0000e	48 3b d1	 cmp	 rdx, rcx
  00011	0f 84 0a 01 00
	00		 je	 $LN8@set_merge
  00017	4c 8b 52 68	 mov	 r10, QWORD PTR [rdx+104]
  0001b	4d 85 d2	 test	 r10, r10
  0001e	0f 84 fd 00 00
	00		 je	 $LN8@set_merge

; 646  :     /* Do one big resize at the start, rather than
; 647  :      * incrementally resizing as we insert new keys.  Expect
; 648  :      * that there will be no (or few) overlapping keys.
; 649  :      */
; 650  :     if ((so->fill + other->used)*3 >= (so->mask+1)*2) {

  00024	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00028	4d 8d 04 02	 lea	 r8, QWORD PTR [r10+rax]
  0002c	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00030	48 8d 44 00 02	 lea	 rax, QWORD PTR [rax+rax+2]
  00035	4f 8d 0c 40	 lea	 r9, QWORD PTR [r8+r8*2]
  00039	4c 3b c8	 cmp	 r9, rax
  0003c	7c 1e		 jl	 SHORT $LN6@set_merge

; 651  :        if (set_table_resize(so, (so->used + other->used)*2) != 0)

  0003e	48 8b 51 68	 mov	 rdx, QWORD PTR [rcx+104]
  00042	49 03 d2	 add	 rdx, r10
  00045	48 03 d2	 add	 rdx, rdx
  00048	e8 00 00 00 00	 call	 set_table_resize
  0004d	85 c0		 test	 eax, eax
  0004f	74 0b		 je	 SHORT $LN6@set_merge

; 652  :            return -1;

  00051	83 c8 ff	 or	 eax, -1

; 668  : }

  00054	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00058	41 5c		 pop	 r12
  0005a	5d		 pop	 rbp
  0005b	c3		 ret	 0
$LN6@set_merge:
  0005c	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00061	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  00066	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi

; 653  :     }
; 654  :     for (i = 0; i <= other->mask; i++) {

  0006b	33 ff		 xor	 edi, edi
  0006d	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  00072	48 39 7d 70	 cmp	 QWORD PTR [rbp+112], rdi
  00076	0f 8c 7a 00 00
	00		 jl	 $LN19@set_merge
  0007c	8b f7		 mov	 esi, edi
  0007e	66 90		 npad	 2
$LL5@set_merge:
  00080	48 8b 45 78	 mov	 rax, QWORD PTR [rbp+120]

; 655  :         entry = &other->table[i];
; 656  :         key = entry->key;

  00084	48 8b 5c 06 08	 mov	 rbx, QWORD PTR [rsi+rax+8]

; 657  :         hash = entry->hash;

  00089	4c 8b 2c 06	 mov	 r13, QWORD PTR [rsi+rax]

; 658  :         if (key != NULL &&
; 659  :             key != dummy) {

  0008d	48 85 db	 test	 rbx, rbx
  00090	74 57		 je	 SHORT $LN4@set_merge
  00092	48 3b 1d 00 00
	00 00		 cmp	 rbx, QWORD PTR dummy
  00099	74 4e		 je	 SHORT $LN4@set_merge

; 660  :             Py_INCREF(key);

  0009b	e8 00 00 00 00	 call	 _Py_PXCTX
  000a0	85 c0		 test	 eax, eax
  000a2	75 32		 jne	 SHORT $LN13@set_merge
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000b2	4c 8b cb	 mov	 r9, rbx
  000b5	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000bb	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000c3	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c8	85 c0		 test	 eax, eax
  000ca	75 06		 jne	 SHORT $LN12@set_merge
  000cc	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000d0	74 04		 je	 SHORT $LN13@set_merge
$LN12@set_merge:
  000d2	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN13@set_merge:

; 661  :             if (set_insert_key(so, key, hash) == -1) {

  000d6	4d 8b c5	 mov	 r8, r13
  000d9	48 8b d3	 mov	 rdx, rbx
  000dc	49 8b cc	 mov	 rcx, r12
  000df	e8 00 00 00 00	 call	 set_insert_key
  000e4	83 f8 ff	 cmp	 eax, -1
  000e7	74 2b		 je	 SHORT $LN17@set_merge
$LN4@set_merge:

; 653  :     }
; 654  :     for (i = 0; i <= other->mask; i++) {

  000e9	48 ff c7	 inc	 rdi
  000ec	48 83 c6 10	 add	 rsi, 16
  000f0	48 3b 7d 70	 cmp	 rdi, QWORD PTR [rbp+112]
  000f4	7e 8a		 jle	 SHORT $LL5@set_merge
$LN19@set_merge:

; 664  :             }
; 665  :         }
; 666  :     }
; 667  :     return 0;

  000f6	33 c0		 xor	 eax, eax
$LN23@set_merge:
  000f8	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  000fd	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00102	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00107	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]

; 668  : }

  0010c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00110	41 5c		 pop	 r12
  00112	5d		 pop	 rbp
  00113	c3		 ret	 0
$LN17@set_merge:

; 662  :                 Py_DECREF(key);

  00114	48 8b cb	 mov	 rcx, rbx
  00117	e8 00 00 00 00	 call	 _Py_DecRef

; 663  :                 return -1;

  0011c	83 c8 ff	 or	 eax, -1
  0011f	eb d7		 jmp	 SHORT $LN23@set_merge
$LN8@set_merge:

; 644  :         /* a.update(a) or a.update({}); nothing to do */
; 645  :         return 0;

  00121	33 c0		 xor	 eax, eax

; 668  : }

  00123	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00127	41 5c		 pop	 r12
  00129	5d		 pop	 rbp
  0012a	c3		 ret	 0
set_merge ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_contains_key DD imagerel set_contains_key
	DD	imagerel set_contains_key+134
	DD	imagerel $unwind$set_contains_key
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_contains_key DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_contains_key
_TEXT	SEGMENT
so$ = 48
key$ = 56
set_contains_key PROC					; COMDAT

; 672  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 673  :     Py_hash_t hash;
; 674  :     setentry *entry;
; 675  : 
; 676  :     if (!PyUnicode_CheckExact(key) ||
; 677  :         (hash = ((PyASCIIObject *) key)->hash) == -1) {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00011	48 8b da	 mov	 rbx, rdx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	48 39 42 58	 cmp	 QWORD PTR [rdx+88], rax
  0001b	75 0a		 jne	 SHORT $LN3@set_contai
  0001d	48 8b 42 68	 mov	 rax, QWORD PTR [rdx+104]
  00021	48 83 f8 ff	 cmp	 rax, -1
  00025	75 1c		 jne	 SHORT $LN2@set_contai
$LN3@set_contai:

; 678  :         hash = PyObject_Hash(key);

  00027	48 8b ca	 mov	 rcx, rdx
  0002a	e8 00 00 00 00	 call	 PyObject_Hash

; 679  :         if (hash == -1)

  0002f	48 83 f8 ff	 cmp	 rax, -1
  00033	75 0e		 jne	 SHORT $LN2@set_contai
$LN9@set_contai:

; 680  :             return -1;

  00035	83 c8 ff	 or	 eax, -1

; 687  : }

  00038	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
$LN2@set_contai:

; 681  :     }
; 682  :     entry = (so->lookup)(so, key, hash);

  00043	4c 8b c0	 mov	 r8, rax
  00046	48 8b d3	 mov	 rdx, rbx
  00049	48 8b cf	 mov	 rcx, rdi
  0004c	ff 97 80 00 00
	00		 call	 QWORD PTR [rdi+128]

; 683  :     if (entry == NULL)

  00052	48 85 c0	 test	 rax, rax

; 684  :         return -1;

  00055	74 de		 je	 SHORT $LN9@set_contai

; 685  :     key = entry->key;

  00057	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 686  :     return key != NULL && key != dummy;

  0005b	48 85 c0	 test	 rax, rax
  0005e	74 19		 je	 SHORT $LN7@set_contai
  00060	48 3b 05 00 00
	00 00		 cmp	 rax, QWORD PTR dummy
  00067	74 10		 je	 SHORT $LN7@set_contai
  00069	b8 01 00 00 00	 mov	 eax, 1

; 687  : }

  0006e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
$LN7@set_contai:

; 686  :     return key != NULL && key != dummy;

  00079	33 c0		 xor	 eax, eax

; 687  : }

  0007b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00080	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00084	5f		 pop	 rdi
  00085	c3		 ret	 0
set_contains_key ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_contains_entry DD imagerel set_contains_entry
	DD	imagerel set_contains_entry+68
	DD	imagerel $unwind$set_contains_entry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_contains_entry DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_contains_entry
_TEXT	SEGMENT
so$ = 48
entry$ = 56
set_contains_entry PROC					; COMDAT

; 691  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 692  :     PyObject *key;
; 693  :     setentry *lu_entry;
; 694  : 
; 695  :     lu_entry = (so->lookup)(so, entry->key, entry->hash);

  00004	4c 8b 02	 mov	 r8, QWORD PTR [rdx]
  00007	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  0000b	48 8b c1	 mov	 rax, rcx
  0000e	ff 90 80 00 00
	00		 call	 QWORD PTR [rax+128]

; 696  :     if (lu_entry == NULL)

  00014	48 85 c0	 test	 rax, rax
  00017	75 08		 jne	 SHORT $LN1@set_contai@2

; 697  :         return -1;

  00019	83 c8 ff	 or	 eax, -1

; 700  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
$LN1@set_contai@2:

; 698  :     key = lu_entry->key;

  00021	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 699  :     return key != NULL && key != dummy;

  00025	48 85 c0	 test	 rax, rax
  00028	74 13		 je	 SHORT $LN4@set_contai@2
  0002a	48 3b 05 00 00
	00 00		 cmp	 rax, QWORD PTR dummy
  00031	74 0a		 je	 SHORT $LN4@set_contai@2
  00033	b8 01 00 00 00	 mov	 eax, 1

; 700  : }

  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	c3		 ret	 0
$LN4@set_contai@2:

; 699  :     return key != NULL && key != dummy;

  0003d	33 c0		 xor	 eax, eax

; 700  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
set_contains_entry ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@MMGMMGKJ@pop?5from?5an?5empty?5set?$AA@ ; `string'
EXTRN	PyErr_SetString:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_pop DD imagerel set_pop
	DD	imagerel set_pop+280
	DD	imagerel $unwind$set_pop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_pop DD 0a5301H
	DD	0ac453H
	DD	09744eH
	DD	08643eH
	DD	0b340aH
	DD	05006520aH
xdata	ENDS
;	COMDAT ??_C@_0BG@MMGMMGKJ@pop?5from?5an?5empty?5set?$AA@
CONST	SEGMENT
??_C@_0BG@MMGMMGKJ@pop?5from?5an?5empty?5set?$AA@ DB 'pop from an empty s'
	DB	'et', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
CONST	ENDS
;	COMDAT set_pop
_TEXT	SEGMENT
so$ = 64
set_pop	PROC						; COMDAT

; 704  : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 705  :     register Py_ssize_t i = 0;

  0000a	33 db		 xor	 ebx, ebx
  0000c	48 8b e9	 mov	 rbp, rcx

; 706  :     register setentry *entry;
; 707  :     PyObject *key;
; 708  : 
; 709  :     assert (PyAnySet_Check(so));
; 710  :     if (so->used == 0) {

  0000f	48 39 59 68	 cmp	 QWORD PTR [rcx+104], rbx
  00013	75 20		 jne	 SHORT $LN9@set_pop

; 711  :         PyErr_SetString(PyExc_KeyError, "pop from an empty set");

  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@MMGMMGKJ@pop?5from?5an?5empty?5set?$AA@
  00023	e8 00 00 00 00	 call	 PyErr_SetString

; 712  :         return NULL;

  00028	33 c0		 xor	 eax, eax

; 742  :     return key;
; 743  : }

  0002a	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0002f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
$LN9@set_pop:

; 713  :     }
; 714  : 
; 715  :     /* Set entry to "the first" unused or dummy set entry.  We abuse
; 716  :      * the hash field of slot 0 to hold a search finger:
; 717  :      * If slot 0 has a value, use slot 0.
; 718  :      * Else slot 0 is being used to hold a search finger,
; 719  :      * and we use its hash value as the first index to look.
; 720  :      */
; 721  :     entry = &so->table[0];

  00035	48 8b 51 78	 mov	 rdx, QWORD PTR [rcx+120]
  00039	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi

; 722  :     if (entry->key == NULL || entry->key == dummy) {

  0003e	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR dummy
  00045	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00049	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0004e	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  00053	48 8b fa	 mov	 rdi, rdx
  00056	48 85 c0	 test	 rax, rax
  00059	74 05		 je	 SHORT $LN7@set_pop
  0005b	48 3b c6	 cmp	 rax, rsi
  0005e	75 42		 jne	 SHORT $LN21@set_pop
$LN7@set_pop:

; 723  :         i = entry->hash;

  00060	48 8b 1a	 mov	 rbx, QWORD PTR [rdx]

; 724  :         /* The hash field may be a real hash value, or it may be a
; 725  :          * legit search finger, or it may be a once-legit search
; 726  :          * finger that's out of bounds now because it wrapped around
; 727  :          * or the table shrunk -- simply make sure it's in bounds now.
; 728  :          */
; 729  :         if (i > so->mask || i < 1)

  00063	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00067	48 3b d9	 cmp	 rbx, rcx
  0006a	7f 06		 jg	 SHORT $LN5@set_pop
  0006c	48 83 fb 01	 cmp	 rbx, 1
  00070	7d 0e		 jge	 SHORT $LL4@set_pop
$LN5@set_pop:

; 730  :             i = 1;              /* skip slot 0 */

  00072	bb 01 00 00 00	 mov	 ebx, 1
  00077	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@set_pop:

; 731  :         while ((entry = &so->table[i])->key == NULL || entry->key==dummy) {

  00080	48 8b fb	 mov	 rdi, rbx
  00083	48 c1 e7 04	 shl	 rdi, 4
  00087	48 03 fa	 add	 rdi, rdx
  0008a	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  0008e	48 85 c0	 test	 rax, rax
  00091	74 05		 je	 SHORT $LN2@set_pop
  00093	48 3b c6	 cmp	 rax, rsi
  00096	75 0a		 jne	 SHORT $LN21@set_pop
$LN2@set_pop:

; 732  :             i++;

  00098	48 ff c3	 inc	 rbx

; 733  :             if (i > so->mask)

  0009b	48 3b d9	 cmp	 rbx, rcx
  0009e	7e e0		 jle	 SHORT $LL4@set_pop

; 734  :                 i = 1;
; 735  :         }

  000a0	eb d0		 jmp	 SHORT $LN5@set_pop
$LN21@set_pop:

; 736  :     }
; 737  :     key = entry->key;

  000a2	4c 8b 67 08	 mov	 r12, QWORD PTR [rdi+8]

; 738  :     Py_INCREF(dummy);

  000a6	e8 00 00 00 00	 call	 _Py_PXCTX
  000ab	85 c0		 test	 eax, eax
  000ad	75 32		 jne	 SHORT $LN13@set_pop
  000af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000bd	4c 8b ce	 mov	 r9, rsi
  000c0	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000c6	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000ce	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d3	85 c0		 test	 eax, eax
  000d5	75 06		 jne	 SHORT $LN12@set_pop
  000d7	f6 46 20 20	 test	 BYTE PTR [rsi+32], 32	; 00000020H
  000db	74 04		 je	 SHORT $LN13@set_pop
$LN12@set_pop:
  000dd	48 ff 46 50	 inc	 QWORD PTR [rsi+80]
$LN13@set_pop:

; 739  :     entry->key = dummy;

  000e1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR dummy
  000e8	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 740  :     so->used--;
; 741  :     so->table[0].hash = i + 1;  /* next place to start */

  000ed	48 8d 53 01	 lea	 rdx, QWORD PTR [rbx+1]

; 742  :     return key;
; 743  : }

  000f1	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000f6	48 89 4f 08	 mov	 QWORD PTR [rdi+8], rcx
  000fa	48 8b 4d 78	 mov	 rcx, QWORD PTR [rbp+120]
  000fe	48 ff 4d 68	 dec	 QWORD PTR [rbp+104]
  00102	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00107	49 8b c4	 mov	 rax, r12
  0010a	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  0010f	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00112	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00116	5d		 pop	 rbp
  00117	c3		 ret	 0
set_pop	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@CMPJDKOD@set_traverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_traverse DD imagerel set_traverse
	DD	imagerel set_traverse+154
	DD	imagerel $unwind$set_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_traverse DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0N@CMPJDKOD@set_traverse?$AA@
CONST	SEGMENT
??_C@_0N@CMPJDKOD@set_traverse?$AA@ DB 'set_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT set_traverse
_TEXT	SEGMENT
pos$ = 32
so$ = 64
visit$ = 72
arg$ = 80
entry$ = 88
set_traverse PROC					; COMDAT

; 750  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx

; 751  :     Py_ssize_t pos = 0;
; 752  :     setentry *entry;
; 753  : 
; 754  :     while (set_next(so, &pos, &entry))

  00015	4c 8d 44 24 58	 lea	 r8, QWORD PTR entry$[rsp]
  0001a	48 8d 54 24 20	 lea	 rdx, QWORD PTR pos$[rsp]
  0001f	48 8b d9	 mov	 rbx, rcx
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR pos$[rsp], 0
  0002b	e8 00 00 00 00	 call	 set_next
  00030	85 c0		 test	 eax, eax
  00032	74 54		 je	 SHORT $LN13@set_traver
$LL8@set_traver:

; 755  :         Py_VISIT(entry->key);

  00034	e8 00 00 00 00	 call	 _Py_PXCTX
  00039	85 c0		 test	 eax, eax
  0003b	74 1c		 je	 SHORT $LN3@set_traver
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@CMPJDKOD@set_traverse?$AA@
  0004b	45 33 c9	 xor	 r9d, r9d
  0004e	41 b8 f3 02 00
	00		 mov	 r8d, 755		; 000002f3H
  00054	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@set_traver:
  00059	48 8b 4c 24 58	 mov	 rcx, QWORD PTR entry$[rsp]
  0005e	48 83 79 08 00	 cmp	 QWORD PTR [rcx+8], 0
  00063	74 0d		 je	 SHORT $LN5@set_traver
  00065	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00069	48 8b d7	 mov	 rdx, rdi
  0006c	ff d6		 call	 rsi
  0006e	85 c0		 test	 eax, eax
  00070	75 18		 jne	 SHORT $LN9@set_traver
$LN5@set_traver:

; 751  :     Py_ssize_t pos = 0;
; 752  :     setentry *entry;
; 753  : 
; 754  :     while (set_next(so, &pos, &entry))

  00072	4c 8d 44 24 58	 lea	 r8, QWORD PTR entry$[rsp]
  00077	48 8d 54 24 20	 lea	 rdx, QWORD PTR pos$[rsp]
  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	e8 00 00 00 00	 call	 set_next
  00084	85 c0		 test	 eax, eax
  00086	75 ac		 jne	 SHORT $LL8@set_traver
$LN13@set_traver:

; 756  :     return 0;

  00088	33 c0		 xor	 eax, eax
$LN9@set_traver:

; 757  : }

  0008a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0008f	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00094	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00098	5f		 pop	 rdi
  00099	c3		 ret	 0
set_traverse ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$frozenset_hash DD imagerel frozenset_hash
	DD	imagerel frozenset_hash+35
	DD	imagerel $unwind$frozenset_hash
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$frozenset_hash DD imagerel frozenset_hash+35
	DD	imagerel frozenset_hash+73
	DD	imagerel $chain$0$frozenset_hash
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$frozenset_hash DD imagerel frozenset_hash+73
	DD	imagerel frozenset_hash+154
	DD	imagerel $chain$1$frozenset_hash
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$frozenset_hash DD imagerel frozenset_hash+154
	DD	imagerel frozenset_hash+196
	DD	imagerel $chain$2$frozenset_hash
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$frozenset_hash DD imagerel frozenset_hash+196
	DD	imagerel frozenset_hash+202
	DD	imagerel $chain$3$frozenset_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$frozenset_hash DD 021H
	DD	imagerel frozenset_hash
	DD	imagerel frozenset_hash+35
	DD	imagerel $unwind$frozenset_hash
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$frozenset_hash DD 021H
	DD	imagerel frozenset_hash+35
	DD	imagerel frozenset_hash+73
	DD	imagerel $chain$0$frozenset_hash
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$frozenset_hash DD 020521H
	DD	096405H
	DD	imagerel frozenset_hash+35
	DD	imagerel frozenset_hash+73
	DD	imagerel $chain$0$frozenset_hash
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$frozenset_hash DD 020521H
	DD	083405H
	DD	imagerel frozenset_hash
	DD	imagerel frozenset_hash+35
	DD	imagerel $unwind$frozenset_hash
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$frozenset_hash DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT frozenset_hash
_TEXT	SEGMENT
entry$ = 48
self$ = 48
pos$ = 56
frozenset_hash PROC					; COMDAT

; 761  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 762  :     PySetObject *so = (PySetObject *)self;
; 763  :     Py_uhash_t h, hash = 1927868237UL;
; 764  :     setentry *entry;
; 765  :     Py_ssize_t pos = 0;
; 766  : 
; 767  :     if (so->hash != -1)

  00006	48 8b 81 08 01
	00 00		 mov	 rax, QWORD PTR [rcx+264]
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR pos$[rsp], 0
  00019	48 83 f8 ff	 cmp	 rax, -1

; 768  :         return so->hash;

  0001d	0f 85 a1 00 00
	00		 jne	 $LN5@frozenset_

; 769  : 
; 770  :     hash *= (Py_uhash_t)PySet_GET_SIZE(self) + 1;

  00023	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00028	48 8b 59 68	 mov	 rbx, QWORD PTR [rcx+104]

; 771  :     while (set_next(so, &pos, &entry)) {

  0002c	4c 8d 44 24 30	 lea	 r8, QWORD PTR entry$[rsp]
  00031	48 8d 54 24 38	 lea	 rdx, QWORD PTR pos$[rsp]
  00036	48 ff c3	 inc	 rbx
  00039	48 69 db 4d ef
	e8 72		 imul	 rbx, 1927868237		; 72e8ef4dH
  00040	e8 00 00 00 00	 call	 set_next
  00045	85 c0		 test	 eax, eax
  00047	74 51		 je	 SHORT $LN2@frozenset_
  00049	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  0004e	be d7 34 3f d9	 mov	 esi, -650169129		; d93f34d7H
  00053	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL3@frozenset_:

; 772  :         /* Work to increase the bit dispersion for closely spaced hash
; 773  :            values.  The is important because some use cases have many
; 774  :            combinations of a small number of elements with nearby
; 775  :            hashes so that many distinct combinations collapse to only
; 776  :            a handful of distinct hash values. */
; 777  :         h = entry->hash;

  00060	48 8b 44 24 30	 mov	 rax, QWORD PTR entry$[rsp]
  00065	4c 8d 44 24 30	 lea	 r8, QWORD PTR entry$[rsp]
  0006a	48 8d 54 24 38	 lea	 rdx, QWORD PTR pos$[rsp]
  0006f	48 8b 08	 mov	 rcx, QWORD PTR [rax]

; 778  :         hash ^= (h ^ (h << 16) ^ 89869747UL)  * 3644798167UL;

  00072	48 8b c1	 mov	 rax, rcx
  00075	48 c1 e0 10	 shl	 rax, 16
  00079	48 33 c1	 xor	 rax, rcx
  0007c	48 8b cf	 mov	 rcx, rdi
  0007f	48 35 b3 4d 5b
	05		 xor	 rax, 89869747		; 055b4db3H
  00085	48 0f af c6	 imul	 rax, rsi
  00089	48 33 d8	 xor	 rbx, rax
  0008c	e8 00 00 00 00	 call	 set_next
  00091	85 c0		 test	 eax, eax
  00093	75 cb		 jne	 SHORT $LL3@frozenset_
  00095	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
$LN2@frozenset_:

; 779  :     }
; 780  :     hash = hash * 69069U + 907133923UL;

  0009a	48 69 db cd 0d
	01 00		 imul	 rbx, 69069		; 00010dcdH

; 781  :     if (hash == -1)

  000a1	b8 c1 c7 38 23	 mov	 eax, 590923713		; 2338c7c1H
  000a6	48 81 c3 e3 c3
	11 36		 add	 rbx, 907133923		; 3611c3e3H
  000ad	48 83 fb ff	 cmp	 rbx, -1
  000b1	48 0f 44 d8	 cmove	 rbx, rax

; 782  :         hash = 590923713UL;
; 783  :     so->hash = hash;

  000b5	48 89 9f 08 01
	00 00		 mov	 QWORD PTR [rdi+264], rbx

; 784  :     return hash;

  000bc	48 8b c3	 mov	 rax, rbx
  000bf	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN5@frozenset_:

; 785  : }

  000c4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c8	5f		 pop	 rdi
  000c9	c3		 ret	 0
frozenset_hash ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$setiter_dealloc DD imagerel setiter_dealloc
	DD	imagerel setiter_dealloc+177
	DD	imagerel $unwind$setiter_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setiter_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT setiter_dealloc
_TEXT	SEGMENT
si$ = 64
setiter_dealloc PROC					; COMDAT

; 799  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 800  :     Py_XDECREF(si->si_set);

  0000a	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 85 db	 test	 rbx, rbx
  00014	0f 84 85 00 00
	00		 je	 $LN3@setiter_de
  0001a	e8 00 00 00 00	 call	 _Py_PXCTX
  0001f	85 c0		 test	 eax, eax
  00021	75 7c		 jne	 SHORT $LN3@setiter_de
  00023	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00027	a8 20		 test	 al, 32			; 00000020H
  00029	75 6c		 jne	 SHORT $LN11@setiter_de
  0002b	84 c0		 test	 al, al
  0002d	78 68		 js	 SHORT $LN11@setiter_de
  0002f	a8 02		 test	 al, 2
  00031	75 6c		 jne	 SHORT $LN3@setiter_de
  00033	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00037	75 66		 jne	 SHORT $LN3@setiter_de
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00047	4c 8b cb	 mov	 r9, rbx
  0004a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00050	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00058	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005d	48 8b cb	 mov	 rcx, rbx
  00060	85 c0		 test	 eax, eax
  00062	74 17		 je	 SHORT $LN16@setiter_de
  00064	e8 00 00 00 00	 call	 _Px_Dealloc

; 801  :     PyObject_GC_Del(si);

  00069	48 8b cf	 mov	 rcx, rdi

; 802  : }

  0006c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00071	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00075	5f		 pop	 rdi
  00076	e9 00 00 00 00	 jmp	 PyObject_GC_Del

; 800  :     Py_XDECREF(si->si_set);

$LN16@setiter_de:
  0007b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0007f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 801  :     PyObject_GC_Del(si);

  00085	48 8b cf	 mov	 rcx, rdi

; 802  : }

  00088	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0008d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00091	5f		 pop	 rdi
  00092	e9 00 00 00 00	 jmp	 PyObject_GC_Del

; 800  :     Py_XDECREF(si->si_set);

$LN11@setiter_de:
  00097	48 8b cb	 mov	 rcx, rbx
  0009a	e8 00 00 00 00	 call	 Px_DecRef
$LN3@setiter_de:

; 801  :     PyObject_GC_Del(si);

  0009f	48 8b cf	 mov	 rcx, rdi

; 802  : }

  000a2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ab	5f		 pop	 rdi
  000ac	e9 00 00 00 00	 jmp	 PyObject_GC_Del
setiter_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@KFDJELAH@setiter_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$setiter_traverse DD imagerel setiter_traverse
	DD	imagerel setiter_traverse+97
	DD	imagerel $unwind$setiter_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setiter_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BB@KFDJELAH@setiter_traverse?$AA@
CONST	SEGMENT
??_C@_0BB@KFDJELAH@setiter_traverse?$AA@ DB 'setiter_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT setiter_traverse
_TEXT	SEGMENT
si$ = 48
visit$ = 56
arg$ = 64
setiter_traverse PROC					; COMDAT

; 806  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 807  :     Py_VISIT(si->si_set);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN3@setiter_tr
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KFDJELAH@setiter_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 27 03 00
	00		 mov	 r8d, 807		; 00000327H
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@setiter_tr:
  0003d	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00041	48 85 c9	 test	 rcx, rcx
  00044	74 09		 je	 SHORT $LN5@setiter_tr
  00046	48 8b d7	 mov	 rdx, rdi
  00049	ff d6		 call	 rsi
  0004b	85 c0		 test	 eax, eax
  0004d	75 02		 jne	 SHORT $LN7@setiter_tr
$LN5@setiter_tr:

; 808  :     return 0;

  0004f	33 c0		 xor	 eax, eax
$LN7@setiter_tr:

; 809  : }

  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
setiter_traverse ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSsize_t:PROC
; Function compile flags: /Ogtpy
;	COMDAT setiter_len
_TEXT	SEGMENT
si$ = 8
setiter_len PROC					; COMDAT

; 814  :     Py_ssize_t len = 0;
; 815  :     if (si->si_set != NULL && si->si_used == si->si_set->used)

  00000	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00004	33 d2		 xor	 edx, edx
  00006	48 85 c0	 test	 rax, rax
  00009	74 0e		 je	 SHORT $LN1@setiter_le
  0000b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0000f	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  00013	75 04		 jne	 SHORT $LN1@setiter_le

; 816  :         len = si->len;

  00015	48 8b 51 78	 mov	 rdx, QWORD PTR [rcx+120]
$LN1@setiter_le:

; 817  :     return PyLong_FromSsize_t(len);

  00019	48 8b ca	 mov	 rcx, rdx

; 818  : }

  0001c	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
setiter_len ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@CCFGNEIP@Set?5changed?5size?5during?5iteratio@ ; `string'
EXTRN	PyExc_RuntimeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$setiter_iternext DD imagerel setiter_iternext
	DD	imagerel setiter_iternext+71
	DD	imagerel $unwind$setiter_iternext
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$setiter_iternext DD imagerel setiter_iternext+71
	DD	imagerel setiter_iternext+167
	DD	imagerel $chain$0$setiter_iternext
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$setiter_iternext DD imagerel setiter_iternext+167
	DD	imagerel setiter_iternext+201
	DD	imagerel $chain$2$setiter_iternext
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$setiter_iternext DD 020021H
	DD	063400H
	DD	imagerel setiter_iternext
	DD	imagerel setiter_iternext+71
	DD	imagerel $unwind$setiter_iternext
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$setiter_iternext DD 020521H
	DD	063405H
	DD	imagerel setiter_iternext
	DD	imagerel setiter_iternext+71
	DD	imagerel $unwind$setiter_iternext
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setiter_iternext DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT ??_C@_0CC@CCFGNEIP@Set?5changed?5size?5during?5iteratio@
CONST	SEGMENT
??_C@_0CC@CCFGNEIP@Set?5changed?5size?5during?5iteratio@ DB 'Set changed '
	DB	'size during iteration', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT setiter_iternext
_TEXT	SEGMENT
si$ = 48
setiter_iternext PROC					; COMDAT

; 871  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f9	 mov	 rdi, rcx

; 872  :     PyObject *key;
; 873  :     register Py_ssize_t i, mask;
; 874  :     register setentry *entry;
; 875  :     PySetObject *so = si->si_set;

  00009	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]

; 876  : 
; 877  :     if (so == NULL)

  0000d	48 85 c9	 test	 rcx, rcx

; 878  :         return NULL;

  00010	74 25		 je	 SHORT $LN13@setiter_it

; 879  :     assert (PyAnySet_Check(so));
; 880  : 
; 881  :     if (si->si_used != so->used) {

  00012	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
  00016	48 39 47 68	 cmp	 QWORD PTR [rdi+104], rax
  0001a	74 23		 je	 SHORT $LN5@setiter_it

; 882  :         PyErr_SetString(PyExc_RuntimeError,
; 883  :                         "Set changed size during iteration");

  0001c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@CCFGNEIP@Set?5changed?5size?5during?5iteratio@
  0002a	e8 00 00 00 00	 call	 PyErr_SetString

; 884  :         si->si_used = -1; /* Make this state sticky */

  0002f	48 c7 47 68 ff
	ff ff ff	 mov	 QWORD PTR [rdi+104], -1
$LN13@setiter_it:

; 885  :         return NULL;

  00037	33 c0		 xor	 eax, eax

; 906  : }

  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
$LN5@setiter_it:

; 889  :     assert(i>=0);
; 890  :     entry = so->table;
; 891  :     mask = so->mask;

  0003f	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  00043	4c 8b 51 78	 mov	 r10, QWORD PTR [rcx+120]
  00047	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0004c	48 8b 5f 70	 mov	 rbx, QWORD PTR [rdi+112]

; 892  :     while (i <= mask && (entry[i].key == NULL || entry[i].key == dummy))

  00050	49 3b d8	 cmp	 rbx, r8
  00053	7f 2b		 jg	 SHORT $LN11@setiter_it

; 886  :     }
; 887  : 
; 888  :     i = si->si_pos;

  00055	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR dummy
  0005c	48 8b c3	 mov	 rax, rbx
  0005f	48 03 c0	 add	 rax, rax
  00062	49 8d 54 c2 08	 lea	 rdx, QWORD PTR [r10+rax*8+8]
$LL4@setiter_it:

; 892  :     while (i <= mask && (entry[i].key == NULL || entry[i].key == dummy))

  00067	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0006a	48 85 c0	 test	 rax, rax
  0006d	74 05		 je	 SHORT $LN2@setiter_it
  0006f	49 3b c1	 cmp	 rax, r9
  00072	75 0c		 jne	 SHORT $LN11@setiter_it
$LN2@setiter_it:

; 893  :         i++;

  00074	48 ff c3	 inc	 rbx
  00077	48 83 c2 10	 add	 rdx, 16
  0007b	49 3b d8	 cmp	 rbx, r8
  0007e	7e e7		 jle	 SHORT $LL4@setiter_it
$LN11@setiter_it:

; 894  :     si->si_pos = i+1;

  00080	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
  00084	48 89 47 70	 mov	 QWORD PTR [rdi+112], rax

; 895  :     if (i > mask)

  00088	49 3b d8	 cmp	 rbx, r8
  0008b	7e 1a		 jle	 SHORT $LN1@setiter_it
$fail$20914:

; 901  : 
; 902  : fail:
; 903  :     Py_DECREF(so);

  0008d	e8 00 00 00 00	 call	 _Py_DecRef
  00092	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 904  :     si->si_set = NULL;

  00097	48 c7 47 60 00
	00 00 00	 mov	 QWORD PTR [rdi+96], 0

; 905  :     return NULL;

  0009f	33 c0		 xor	 eax, eax

; 906  : }

  000a1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a5	5f		 pop	 rdi
  000a6	c3		 ret	 0
$LN1@setiter_it:

; 896  :         goto fail;
; 897  :     si->len--;

  000a7	48 ff 4f 78	 dec	 QWORD PTR [rdi+120]

; 898  :     key = entry[i].key;

  000ab	48 03 db	 add	 rbx, rbx
  000ae	49 8b 5c da 08	 mov	 rbx, QWORD PTR [r10+rbx*8+8]

; 899  :     Py_INCREF(key);

  000b3	48 8b cb	 mov	 rcx, rbx
  000b6	e8 00 00 00 00	 call	 _Py_IncRef

; 900  :     return key;

  000bb	48 8b c3	 mov	 rax, rbx
  000be	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 906  : }

  000c3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c7	5f		 pop	 rdi
  000c8	c3		 ret	 0
setiter_iternext ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ ; `string'
PUBLIC	??_C@_08IOEGMEMM@set_iter?$AA@			; `string'
EXTRN	_PyGC_generation0:QWORD
EXTRN	Py_FatalError:PROC
EXTRN	_PyObject_GC_New:PROC
EXTRN	_PxObject_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_iter DD imagerel set_iter
	DD	imagerel set_iter+319
	DD	imagerel $unwind$set_iter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_iter DD 064101H
	DD	083441H
	DD	09640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
CONST	SEGMENT
??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ DB 'GC object alread'
	DB	'y tracked', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08IOEGMEMM@set_iter?$AA@
CONST	SEGMENT
??_C@_08IOEGMEMM@set_iter?$AA@ DB 'set_iter', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
CONST	ENDS
;	COMDAT set_iter
_TEXT	SEGMENT
so$ = 64
set_iter PROC						; COMDAT

; 943  : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f1	 mov	 rsi, rcx

; 944  :     setiterobject *si = PyObject_GC_New(setiterobject, &PySetIter_Type);

  0000d	e8 00 00 00 00	 call	 _Py_PXCTX
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PySetIter_Type
  00019	85 c0		 test	 eax, eax
  0001b	74 07		 je	 SHORT $LN9@set_iter
  0001d	e8 00 00 00 00	 call	 _PxObject_New
  00022	eb 05		 jmp	 SHORT $LN17@set_iter
$LN9@set_iter:
  00024	e8 00 00 00 00	 call	 _PyObject_GC_New
$LN17@set_iter:
  00029	48 8b f8	 mov	 rdi, rax

; 945  :     if (si == NULL)

  0002c	48 85 c0	 test	 rax, rax
  0002f	75 0b		 jne	 SHORT $LN6@set_iter

; 953  :     return (PyObject *)si;
; 954  : }

  00031	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00036	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
$LN6@set_iter:
  0003c	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 946  :         return NULL;
; 947  :     Py_INCREF(so);

  00041	e8 00 00 00 00	 call	 _Py_PXCTX
  00046	85 c0		 test	 eax, eax
  00048	75 32		 jne	 SHORT $LN14@set_iter
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00058	4c 8b ce	 mov	 r9, rsi
  0005b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00061	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00069	e8 00 00 00 00	 call	 _PyParallel_Guard
  0006e	85 c0		 test	 eax, eax
  00070	75 06		 jne	 SHORT $LN13@set_iter
  00072	f6 46 20 20	 test	 BYTE PTR [rsi+32], 32	; 00000020H
  00076	74 04		 je	 SHORT $LN14@set_iter
$LN13@set_iter:
  00078	48 ff 46 50	 inc	 QWORD PTR [rsi+80]
$LN14@set_iter:

; 948  :     si->si_set = so;

  0007c	48 89 77 60	 mov	 QWORD PTR [rdi+96], rsi

; 949  :     si->si_used = so->used;

  00080	48 8b 46 68	 mov	 rax, QWORD PTR [rsi+104]

; 950  :     si->si_pos = 0;

  00084	33 db		 xor	 ebx, ebx
  00086	48 89 5f 70	 mov	 QWORD PTR [rdi+112], rbx
  0008a	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax

; 951  :     si->len = so->used;

  0008e	48 8b 46 68	 mov	 rax, QWORD PTR [rsi+104]

; 952  :     _PyObject_GC_TRACK(si);

  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08IOEGMEMM@set_iter?$AA@
  000a0	4c 8b cf	 mov	 r9, rdi
  000a3	41 b8 b8 03 00
	00		 mov	 r8d, 952		; 000003b8H
  000a9	48 89 47 78	 mov	 QWORD PTR [rdi+120], rax
  000ad	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000b5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ba	85 c0		 test	 eax, eax
  000bc	75 6e		 jne	 SHORT $LN2@set_iter
  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08IOEGMEMM@set_iter?$AA@
  000cc	4c 8b cf	 mov	 r9, rdi
  000cf	41 b8 b8 03 00
	00		 mov	 r8d, 952		; 000003b8H
  000d5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000dd	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e2	85 c0		 test	 eax, eax
  000e4	75 04		 jne	 SHORT $LN12@set_iter
  000e6	48 8d 5f e8	 lea	 rbx, QWORD PTR [rdi-24]
$LN12@set_iter:
  000ea	48 83 7b 10 fe	 cmp	 QWORD PTR [rbx+16], -2
  000ef	74 0c		 je	 SHORT $LN1@set_iter
  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
  000f8	e8 00 00 00 00	 call	 Py_FatalError
$LN1@set_iter:
  000fd	48 c7 43 10 fd
	ff ff ff	 mov	 QWORD PTR [rbx+16], -3
  00105	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  0010c	48 89 03	 mov	 QWORD PTR [rbx], rax
  0010f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  00116	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0011a	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx
  0011e	48 89 19	 mov	 QWORD PTR [rcx], rbx
  00121	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  00128	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
$LN2@set_iter:

; 953  :     return (PyObject *)si;
; 954  : }

  0012c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00131	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00136	48 8b c7	 mov	 rax, rdi
  00139	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0013d	5f		 pop	 rdi
  0013e	c3		 ret	 0
set_iter ENDP
_TEXT	ENDS
EXTRN	_PyDict_Next:PROC
EXTRN	PyDict_Size:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyIter_Next:PROC
EXTRN	PyObject_GetIter:PROC
EXTRN	PyDict_Type:BYTE
EXTRN	PyType_IsSubtype:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_update_internal DD imagerel set_update_internal
	DD	imagerel set_update_internal+485
	DD	imagerel $unwind$set_update_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_update_internal DD 040801H
	DD	070049208H
	DD	030026003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_update_internal
_TEXT	SEGMENT
value$20976 = 48
an_entry$20986 = 56
so$ = 112
key$ = 120
other$ = 120
hash$20978 = 128
pos$20977 = 136
set_update_internal PROC				; COMDAT

; 958  : {

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00008	48 8b f9	 mov	 rdi, rcx

; 959  :     PyObject *key, *it;
; 960  : 
; 961  :     if (PyAnySet_Check(other))

  0000b	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  0000f	48 8b da	 mov	 rbx, rdx
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00019	48 3b ca	 cmp	 rcx, rdx
  0001c	0f 84 b0 01 00
	00		 je	 $LN14@set_update
  00022	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFrozenSet_Type
  00029	48 3b ce	 cmp	 rcx, rsi
  0002c	0f 84 a0 01 00
	00		 je	 $LN14@set_update
  00032	e8 00 00 00 00	 call	 PyType_IsSubtype
  00037	85 c0		 test	 eax, eax
  00039	0f 85 93 01 00
	00		 jne	 $LN14@set_update
  0003f	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00043	48 8b d6	 mov	 rdx, rsi
  00046	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004b	85 c0		 test	 eax, eax
  0004d	0f 85 7f 01 00
	00		 jne	 $LN14@set_update

; 963  : 
; 964  :     if (PyDict_CheckExact(other)) {

  00053	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  0005a	48 39 43 58	 cmp	 QWORD PTR [rbx+88], rax
  0005e	0f 84 8f 00 00
	00		 je	 $LN12@set_update
  00064	48 39 43 38	 cmp	 QWORD PTR [rbx+56], rax
  00068	0f 84 85 00 00
	00		 je	 $LN12@set_update

; 989  :     }
; 990  : 
; 991  :     it = PyObject_GetIter(other);

  0006e	48 8b cb	 mov	 rcx, rbx
  00071	e8 00 00 00 00	 call	 PyObject_GetIter
  00076	48 8b d8	 mov	 rbx, rax

; 992  :     if (it == NULL)

  00079	48 85 c0	 test	 rax, rax

; 993  :         return -1;

  0007c	74 6a		 je	 SHORT $LN23@set_update

; 994  : 
; 995  :     while ((key = PyIter_Next(it)) != NULL) {

  0007e	48 8b c8	 mov	 rcx, rax
  00081	e8 00 00 00 00	 call	 PyIter_Next
  00086	48 89 44 24 78	 mov	 QWORD PTR key$[rsp], rax
  0008b	48 85 c0	 test	 rax, rax
  0008e	74 2c		 je	 SHORT $LN3@set_update
$LL4@set_update:

; 996  :         if (set_add_key(so, key) == -1) {

  00090	48 8b d0	 mov	 rdx, rax
  00093	48 8b cf	 mov	 rcx, rdi
  00096	e8 00 00 00 00	 call	 set_add_key
  0009b	83 f8 ff	 cmp	 eax, -1
  0009e	74 36		 je	 SHORT $LN20@set_update

; 1000 :         }
; 1001 :         Py_DECREF(key);

  000a0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  000a5	e8 00 00 00 00	 call	 _Py_DecRef
  000aa	48 8b cb	 mov	 rcx, rbx
  000ad	e8 00 00 00 00	 call	 PyIter_Next
  000b2	48 89 44 24 78	 mov	 QWORD PTR key$[rsp], rax
  000b7	48 85 c0	 test	 rax, rax
  000ba	75 d4		 jne	 SHORT $LL4@set_update
$LN3@set_update:

; 1002 :     }
; 1003 :     Py_DECREF(it);

  000bc	48 8b cb	 mov	 rcx, rbx
  000bf	e8 00 00 00 00	 call	 _Py_DecRef

; 1004 :     if (PyErr_Occurred())

  000c4	e8 00 00 00 00	 call	 PyErr_Occurred
  000c9	48 f7 d8	 neg	 rax
  000cc	1b c0		 sbb	 eax, eax

; 1005 :         return -1;
; 1006 :     return 0;
; 1007 : }

  000ce	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000d2	5f		 pop	 rdi
  000d3	5e		 pop	 rsi
  000d4	5b		 pop	 rbx
  000d5	c3		 ret	 0
$LN20@set_update:

; 997  :             Py_DECREF(it);

  000d6	48 8b cb	 mov	 rcx, rbx
  000d9	e8 00 00 00 00	 call	 _Py_DecRef

; 998  :             Py_DECREF(key);

  000de	48 8b 4c 24 78	 mov	 rcx, QWORD PTR key$[rsp]
  000e3	e8 00 00 00 00	 call	 _Py_DecRef
$LN23@set_update:

; 999  :             return -1;

  000e8	83 c8 ff	 or	 eax, -1

; 1005 :         return -1;
; 1006 :     return 0;
; 1007 : }

  000eb	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000ef	5f		 pop	 rdi
  000f0	5e		 pop	 rsi
  000f1	5b		 pop	 rbx
  000f2	c3		 ret	 0
$LN12@set_update:

; 965  :         PyObject *value;
; 966  :         Py_ssize_t pos = 0;
; 967  :         Py_hash_t hash;
; 968  :         Py_ssize_t dictsize = PyDict_Size(other);

  000f3	48 8b cb	 mov	 rcx, rbx
  000f6	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pos$20977[rsp], 0
  00102	e8 00 00 00 00	 call	 PyDict_Size
  00107	4c 8b d8	 mov	 r11, rax

; 969  : 
; 970  :         /* Do one big resize at the start, rather than
; 971  :         * incrementally resizing as we insert new keys.  Expect
; 972  :         * that there will be no (or few) overlapping keys.
; 973  :         */
; 974  :         if (dictsize == -1)

  0010a	48 83 f8 ff	 cmp	 rax, -1

; 975  :             return -1;

  0010e	74 d8		 je	 SHORT $LN23@set_update

; 976  :         if ((so->fill + dictsize)*3 >= (so->mask+1)*2) {

  00110	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00114	49 8d 0c 03	 lea	 rcx, QWORD PTR [r11+rax]
  00118	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  0011c	48 8d 44 00 02	 lea	 rax, QWORD PTR [rax+rax+2]
  00121	48 8d 14 49	 lea	 rdx, QWORD PTR [rcx+rcx*2]
  00125	48 3b d0	 cmp	 rdx, rax
  00128	7c 16		 jl	 SHORT $LN19@set_update

; 977  :             if (set_table_resize(so, (so->used + dictsize)*2) != 0)

  0012a	48 8b 57 68	 mov	 rdx, QWORD PTR [rdi+104]
  0012e	48 8b cf	 mov	 rcx, rdi
  00131	49 03 d3	 add	 rdx, r11
  00134	48 03 d2	 add	 rdx, rdx
  00137	e8 00 00 00 00	 call	 set_table_resize
  0013c	85 c0		 test	 eax, eax

; 978  :                 return -1;

  0013e	75 a8		 jne	 SHORT $LN23@set_update
$LN19@set_update:

; 979  :         }
; 980  :         while (_PyDict_Next(other, &pos, &key, &value, &hash)) {

  00140	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR hash$20978[rsp]
  00148	4c 8d 4c 24 30	 lea	 r9, QWORD PTR value$20976[rsp]
  0014d	4c 8d 44 24 78	 lea	 r8, QWORD PTR key$[rsp]
  00152	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR pos$20977[rsp]
  0015a	48 8b cb	 mov	 rcx, rbx
  0015d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00162	e8 00 00 00 00	 call	 _PyDict_Next
  00167	85 c0		 test	 eax, eax
  00169	74 5d		 je	 SHORT $LN7@set_update
  0016b	0f 1f 44 00 00	 npad	 5
$LL8@set_update:

; 981  :             setentry an_entry;
; 982  : 
; 983  :             an_entry.hash = hash;

  00170	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR hash$20978[rsp]

; 984  :             an_entry.key = key;
; 985  :             if (set_add_entry(so, &an_entry) == -1)

  00178	48 8d 54 24 38	 lea	 rdx, QWORD PTR an_entry$20986[rsp]
  0017d	48 8b cf	 mov	 rcx, rdi
  00180	48 89 44 24 38	 mov	 QWORD PTR an_entry$20986[rsp], rax
  00185	48 8b 44 24 78	 mov	 rax, QWORD PTR key$[rsp]
  0018a	48 89 44 24 40	 mov	 QWORD PTR an_entry$20986[rsp+8], rax
  0018f	e8 00 00 00 00	 call	 set_add_entry
  00194	83 f8 ff	 cmp	 eax, -1
  00197	0f 84 4b ff ff
	ff		 je	 $LN23@set_update

; 979  :         }
; 980  :         while (_PyDict_Next(other, &pos, &key, &value, &hash)) {

  0019d	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR hash$20978[rsp]
  001a5	4c 8d 4c 24 30	 lea	 r9, QWORD PTR value$20976[rsp]
  001aa	4c 8d 44 24 78	 lea	 r8, QWORD PTR key$[rsp]
  001af	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR pos$20977[rsp]
  001b7	48 8b cb	 mov	 rcx, rbx
  001ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001bf	e8 00 00 00 00	 call	 _PyDict_Next
  001c4	85 c0		 test	 eax, eax
  001c6	75 a8		 jne	 SHORT $LL8@set_update
$LN7@set_update:

; 986  :                 return -1;
; 987  :         }
; 988  :         return 0;

  001c8	33 c0		 xor	 eax, eax

; 1005 :         return -1;
; 1006 :     return 0;
; 1007 : }

  001ca	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001ce	5f		 pop	 rdi
  001cf	5e		 pop	 rsi
  001d0	5b		 pop	 rbx
  001d1	c3		 ret	 0
$LN14@set_update:

; 962  :         return set_merge(so, other);

  001d2	48 8b d3	 mov	 rdx, rbx
  001d5	48 8b cf	 mov	 rcx, rdi
  001d8	e8 00 00 00 00	 call	 set_merge

; 1005 :         return -1;
; 1006 :     return 0;
; 1007 : }

  001dd	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001e1	5f		 pop	 rdi
  001e2	5e		 pop	 rsi
  001e3	5b		 pop	 rbx
  001e4	c3		 ret	 0
set_update_internal ENDP
_TEXT	ENDS
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_update DD imagerel set_update
	DD	imagerel set_update+178
	DD	imagerel $unwind$set_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_update DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_update
_TEXT	SEGMENT
so$ = 64
args$ = 72
set_update PROC						; COMDAT

; 1011 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1012 :     Py_ssize_t i;
; 1013 : 
; 1014 :     for (i=0 ; i<PyTuple_GET_SIZE(args) ; i++) {

  00014	33 db		 xor	 ebx, ebx
  00016	48 8b f2	 mov	 rsi, rdx
  00019	48 8b e9	 mov	 rbp, rcx
  0001c	48 39 5a 60	 cmp	 QWORD PTR [rdx+96], rbx
  00020	7e 2b		 jle	 SHORT $LN2@set_update@2
  00022	48 8d 7a 70	 lea	 rdi, QWORD PTR [rdx+112]
  00026	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@set_update@2:

; 1015 :         PyObject *other = PyTuple_GET_ITEM(args, i);
; 1016 :         if (set_update_internal(so, other) == -1)

  00030	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00033	48 8b cd	 mov	 rcx, rbp
  00036	e8 00 00 00 00	 call	 set_update_internal
  0003b	83 f8 ff	 cmp	 eax, -1
  0003e	74 6e		 je	 SHORT $LN12@set_update@2

; 1012 :     Py_ssize_t i;
; 1013 : 
; 1014 :     for (i=0 ; i<PyTuple_GET_SIZE(args) ; i++) {

  00040	48 ff c3	 inc	 rbx
  00043	48 83 c7 08	 add	 rdi, 8
  00047	48 3b 5e 60	 cmp	 rbx, QWORD PTR [rsi+96]
  0004b	7c e3		 jl	 SHORT $LL4@set_update@2
$LN2@set_update@2:

; 1018 :     }
; 1019 :     Py_RETURN_NONE;

  0004d	e8 00 00 00 00	 call	 _Py_PXCTX
  00052	85 c0		 test	 eax, eax
  00054	75 3c		 jne	 SHORT $LN8@set_update@2
  00056	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0006b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00071	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00079	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007e	85 c0		 test	 eax, eax
  00080	75 09		 jne	 SHORT $LN7@set_update@2
  00082	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00089	74 07		 je	 SHORT $LN8@set_update@2
$LN7@set_update@2:
  0008b	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN8@set_update@2:
  00092	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN5@set_update@2:

; 1020 : }

  00099	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009e	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000a3	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000a8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ac	5f		 pop	 rdi
  000ad	c3		 ret	 0
$LN12@set_update@2:

; 1017 :             return NULL;

  000ae	33 c0		 xor	 eax, eax
  000b0	eb e7		 jmp	 SHORT $LN5@set_update@2
set_update ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@CPDNHNDG@make_new_set?$AA@		; `string'
PUBLIC	??_C@_0M@FAFKDOL@?$DMdummy?5key?$DO?$AA@	; `string'
EXTRN	PyObject_GC_Track:PROC
EXTRN	_Px_NewReference:PROC
EXTRN	PyUnicode_FromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$make_new_set DD imagerel make_new_set
	DD	imagerel make_new_set+61
	DD	imagerel $unwind$make_new_set
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$make_new_set DD imagerel make_new_set+61
	DD	imagerel make_new_set+396
	DD	imagerel $chain$0$make_new_set
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$make_new_set DD imagerel make_new_set+396
	DD	imagerel make_new_set+415
	DD	imagerel $chain$2$make_new_set
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$make_new_set DD 020021H
	DD	087400H
	DD	imagerel make_new_set
	DD	imagerel make_new_set+61
	DD	imagerel $unwind$make_new_set
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$make_new_set DD 020521H
	DD	087405H
	DD	imagerel make_new_set
	DD	imagerel make_new_set+61
	DD	imagerel $unwind$make_new_set
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$make_new_set DD 040a01H
	DD	09340aH
	DD	06006520aH
xdata	ENDS
;	COMDAT ??_C@_0N@CPDNHNDG@make_new_set?$AA@
CONST	SEGMENT
??_C@_0N@CPDNHNDG@make_new_set?$AA@ DB 'make_new_set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FAFKDOL@?$DMdummy?5key?$DO?$AA@
CONST	SEGMENT
??_C@_0M@FAFKDOL@?$DMdummy?5key?$DO?$AA@ DB '<dummy key>', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT make_new_set
_TEXT	SEGMENT
type$ = 64
iterable$ = 72
make_new_set PROC					; COMDAT

; 1027 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1028 :     register PySetObject *so = NULL;
; 1029 : 
; 1030 :     if (dummy == NULL) { /* Auto-initialize dummy */

  0000a	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR dummy, 0
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx
  00018	75 23		 jne	 SHORT $LN16@make_new_s

; 1031 :         dummy = PyUnicode_FromString("<dummy key>");

  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@FAFKDOL@?$DMdummy?5key?$DO?$AA@
  00021	e8 00 00 00 00	 call	 PyUnicode_FromString
  00026	48 89 05 00 00
	00 00		 mov	 QWORD PTR dummy, rax

; 1032 :         if (dummy == NULL)

  0002d	48 85 c0	 test	 rax, rax
  00030	75 0b		 jne	 SHORT $LN16@make_new_s

; 1061 :         }
; 1062 :     }
; 1063 : 
; 1064 :     return (PyObject *)so;
; 1065 : }

  00032	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00037	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003b	5e		 pop	 rsi
  0003c	c3		 ret	 0
$LN16@make_new_s:
  0003d	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 1033 :             return NULL;
; 1034 :     }
; 1035 : 
; 1036 :     /* create PySetObject structure */
; 1037 :     if (!Py_PXCTX && numfree &&
; 1038 :         (type == &PySet_Type  ||  type == &PyFrozenSet_Type)) {

  00042	e8 00 00 00 00	 call	 _Py_PXCTX
  00047	85 c0		 test	 eax, eax
  00049	0f 85 c5 00 00
	00		 jne	 $LN15@make_new_s
  0004f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numfree
  00055	85 c0		 test	 eax, eax
  00057	0f 84 b7 00 00
	00		 je	 $LN15@make_new_s
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PySet_Type
  00064	48 3b d9	 cmp	 rbx, rcx
  00067	74 10		 je	 SHORT $LN14@make_new_s
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFrozenSet_Type
  00070	48 3b d9	 cmp	 rbx, rcx
  00073	0f 85 9b 00 00
	00		 jne	 $LN15@make_new_s
$LN14@make_new_s:

; 1039 :         so = free_list[--numfree];

  00079	ff c8		 dec	 eax
  0007b	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:free_list

; 1040 :         assert (so != NULL && PyAnySet_CheckExact(so));
; 1041 :         Py_TYPE(so) = type;
; 1042 :         _Py_NewReference((PyObject *)so);

  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00089	89 05 00 00 00
	00		 mov	 DWORD PTR numfree, eax
  0008f	48 98		 cdqe
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@CPDNHNDG@make_new_set?$AA@
  00098	48 8b 3c c7	 mov	 rdi, QWORD PTR [rdi+rax*8]
  0009c	41 b8 12 04 00
	00		 mov	 r8d, 1042		; 00000412H
  000a2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000aa	4c 8b cf	 mov	 r9, rdi
  000ad	48 89 5f 58	 mov	 QWORD PTR [rdi+88], rbx
  000b1	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b6	85 c0		 test	 eax, eax
  000b8	74 0a		 je	 SHORT $LN20@make_new_s
  000ba	48 8b cf	 mov	 rcx, rdi
  000bd	e8 00 00 00 00	 call	 _Px_NewReference
  000c2	eb 08		 jmp	 SHORT $LN13@make_new_s
$LN20@make_new_s:
  000c4	48 c7 47 50 01
	00 00 00	 mov	 QWORD PTR [rdi+80], 1
$LN13@make_new_s:

; 1043 :         EMPTY_TO_MINSIZE(so);

  000cc	48 8d 9f 88 00
	00 00		 lea	 rbx, QWORD PTR [rdi+136]
  000d3	33 d2		 xor	 edx, edx
  000d5	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  000db	48 8b cb	 mov	 rcx, rbx
  000de	e8 00 00 00 00	 call	 memset

; 1044 :         PyObject_GC_Track(so);

  000e3	48 8b cf	 mov	 rcx, rdi
  000e6	48 c7 47 60 00
	00 00 00	 mov	 QWORD PTR [rdi+96], 0
  000ee	48 c7 47 68 00
	00 00 00	 mov	 QWORD PTR [rdi+104], 0
  000f6	48 89 5f 78	 mov	 QWORD PTR [rdi+120], rbx
  000fa	48 c7 47 70 07
	00 00 00	 mov	 QWORD PTR [rdi+112], 7
  00102	48 c7 87 08 01
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rdi+264], -1
  0010d	e8 00 00 00 00	 call	 PyObject_GC_Track

; 1045 :     } else {

  00112	eb 30		 jmp	 SHORT $LN3@make_new_s
$LN15@make_new_s:

; 1046 :         so = (PySetObject *)type->tp_alloc(type, 0);

  00114	33 d2		 xor	 edx, edx
  00116	48 8b cb	 mov	 rcx, rbx
  00119	ff 93 88 01 00
	00		 call	 QWORD PTR [rbx+392]
  0011f	48 8b f8	 mov	 rdi, rax

; 1047 :         if (so == NULL)

  00122	48 85 c0	 test	 rax, rax

; 1048 :             return NULL;

  00125	74 53		 je	 SHORT $LN23@make_new_s

; 1049 :         /* tp_alloc has already zeroed the structure */
; 1050 :         assert(so->table == NULL && so->fill == 0 && so->used == 0);
; 1051 :         INIT_NONZERO_SET_SLOTS(so);

  00127	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  0012d	48 c7 47 70 07
	00 00 00	 mov	 QWORD PTR [rdi+112], 7
  00135	48 c7 87 08 01
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rdi+264], -1
  00140	48 89 47 78	 mov	 QWORD PTR [rdi+120], rax
$LN3@make_new_s:

; 1052 :     }
; 1053 : 
; 1054 :     so->lookup = set_lookkey_unicode;

  00144	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:set_lookkey_unicode

; 1055 :     so->weakreflist = NULL;

  0014b	48 c7 87 10 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rdi+272], 0
  00156	48 89 87 80 00
	00 00		 mov	 QWORD PTR [rdi+128], rax

; 1056 : 
; 1057 :     if (iterable != NULL) {

  0015d	48 85 f6	 test	 rsi, rsi
  00160	74 2a		 je	 SHORT $LN1@make_new_s

; 1058 :         if (set_update_internal(so, iterable) == -1) {

  00162	48 8b d6	 mov	 rdx, rsi
  00165	48 8b cf	 mov	 rcx, rdi
  00168	e8 00 00 00 00	 call	 set_update_internal
  0016d	83 f8 ff	 cmp	 eax, -1
  00170	75 1a		 jne	 SHORT $LN1@make_new_s

; 1059 :             Py_DECREF(so);

  00172	48 8b cf	 mov	 rcx, rdi
  00175	e8 00 00 00 00	 call	 _Py_DecRef
$LN23@make_new_s:

; 1060 :             return NULL;

  0017a	33 c0		 xor	 eax, eax
  0017c	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 1061 :         }
; 1062 :     }
; 1063 : 
; 1064 :     return (PyObject *)so;
; 1065 : }

  00181	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00186	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0018a	5e		 pop	 rsi
  0018b	c3		 ret	 0
$LN1@make_new_s:
  0018c	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00191	48 8b c7	 mov	 rax, rdi
  00194	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00199	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019d	5e		 pop	 rsi
  0019e	c3		 ret	 0
make_new_set ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$make_new_set_basetype DD imagerel make_new_set_basetype
	DD	imagerel make_new_set_basetype+25
	DD	imagerel $unwind$make_new_set_basetype
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$make_new_set_basetype DD imagerel make_new_set_basetype+25
	DD	imagerel make_new_set_basetype+64
	DD	imagerel $chain$0$make_new_set_basetype
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$make_new_set_basetype DD imagerel make_new_set_basetype+64
	DD	imagerel make_new_set_basetype+82
	DD	imagerel $chain$1$make_new_set_basetype
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$make_new_set_basetype DD 021H
	DD	imagerel make_new_set_basetype
	DD	imagerel make_new_set_basetype+25
	DD	imagerel $unwind$make_new_set_basetype
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$make_new_set_basetype DD 020521H
	DD	067405H
	DD	imagerel make_new_set_basetype
	DD	imagerel make_new_set_basetype+25
	DD	imagerel $unwind$make_new_set_basetype
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$make_new_set_basetype DD 040a01H
	DD	07340aH
	DD	06006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT make_new_set_basetype
_TEXT	SEGMENT
type$ = 48
iterable$ = 56
make_new_set_basetype PROC				; COMDAT

; 1069 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1070 :     if (type != &PySet_Type && type != &PyFrozenSet_Type) {

  0000a	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PySet_Type
  00011	48 8b da	 mov	 rbx, rdx
  00014	48 3b ce	 cmp	 rcx, rsi
  00017	74 27		 je	 SHORT $LN2@make_new_s@2
  00019	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0001e	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:PyFrozenSet_Type
  00025	48 3b cf	 cmp	 rcx, rdi
  00028	74 11		 je	 SHORT $LN6@make_new_s@2

; 1071 :         if (PyType_IsSubtype(type, &PySet_Type))

  0002a	48 8b d6	 mov	 rdx, rsi
  0002d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00032	48 8b ce	 mov	 rcx, rsi
  00035	85 c0		 test	 eax, eax
  00037	48 0f 44 cf	 cmove	 rcx, rdi
$LN6@make_new_s@2:
  0003b	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN2@make_new_s@2:

; 1072 :             type = &PySet_Type;
; 1073 :         else
; 1074 :             type = &PyFrozenSet_Type;
; 1075 :     }
; 1076 :     return make_new_set(type, iterable);

  00040	48 8b d3	 mov	 rdx, rbx

; 1077 : }

  00043	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5e		 pop	 rsi
  0004d	e9 00 00 00 00	 jmp	 make_new_set
make_new_set_basetype ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@KJMJKMLB@frozenset?$CI?$CJ?$AA@	; `string'
EXTRN	PyArg_UnpackTuple:PROC
EXTRN	_PyArg_NoKeywords:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$frozenset_new DD imagerel frozenset_new
	DD	imagerel frozenset_new+338
	DD	imagerel $unwind$frozenset_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$frozenset_new DD 060f01H
	DD	0a640fH
	DD	09340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0M@KJMJKMLB@frozenset?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0M@KJMJKMLB@frozenset?$CI?$CJ?$AA@ DB 'frozenset()', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
CONST	ENDS
;	COMDAT frozenset_new
_TEXT	SEGMENT
iterable$ = 64
type$ = 64
args$ = 72
kwds$ = 80
frozenset_new PROC					; COMDAT

; 1084 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1085 :     PyObject *iterable = NULL, *result;
; 1086 : 
; 1087 :     if (type == &PyFrozenSet_Type && !_PyArg_NoKeywords("frozenset()", kwds))

  0000f	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFrozenSet_Type
  00016	48 8b da	 mov	 rbx, rdx
  00019	48 8b f9	 mov	 rdi, rcx
  0001c	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR iterable$[rsp], 0
  00025	48 3b ce	 cmp	 rcx, rsi
  00028	75 25		 jne	 SHORT $LN12@frozenset_@2
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@KJMJKMLB@frozenset?$CI?$CJ?$AA@
  00031	49 8b d0	 mov	 rdx, r8
  00034	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  00039	85 c0		 test	 eax, eax
  0003b	75 12		 jne	 SHORT $LN12@frozenset_@2
$LN21@frozenset_@2:

; 1088 :         return NULL;

  0003d	33 c0		 xor	 eax, eax

; 1112 : }

  0003f	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00044	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00049	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
$LN12@frozenset_@2:

; 1089 : 
; 1090 :     if (!PyArg_UnpackTuple(args, type->tp_name, 0, 1, &iterable))

  0004f	48 8b 57 70	 mov	 rdx, QWORD PTR [rdi+112]
  00053	48 8d 44 24 40	 lea	 rax, QWORD PTR iterable$[rsp]
  00058	41 b9 01 00 00
	00		 mov	 r9d, 1
  0005e	45 33 c0	 xor	 r8d, r8d
  00061	48 8b cb	 mov	 rcx, rbx
  00064	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00069	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0006e	85 c0		 test	 eax, eax

; 1091 :         return NULL;

  00070	74 cb		 je	 SHORT $LN21@frozenset_@2

; 1092 : 
; 1093 :     if (type != &PyFrozenSet_Type)
; 1094 :         return make_new_set(type, iterable);

  00072	48 8b 54 24 40	 mov	 rdx, QWORD PTR iterable$[rsp]
  00077	48 3b fe	 cmp	 rdi, rsi
  0007a	74 18		 je	 SHORT $LN10@frozenset_@2
  0007c	48 8b cf	 mov	 rcx, rdi
  0007f	e8 00 00 00 00	 call	 make_new_set

; 1112 : }

  00084	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00089	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0008e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00092	5f		 pop	 rdi
  00093	c3		 ret	 0
$LN10@frozenset_@2:

; 1095 : 
; 1096 :     if (iterable != NULL) {

  00094	48 85 d2	 test	 rdx, rdx
  00097	74 3f		 je	 SHORT $LN9@frozenset_@2

; 1097 :         /* frozenset(f) is idempotent */
; 1098 :         if (PyFrozenSet_CheckExact(iterable)) {

  00099	48 39 72 58	 cmp	 QWORD PTR [rdx+88], rsi
  0009d	75 1d		 jne	 SHORT $LN8@frozenset_@2

; 1099 :             Py_INCREF(iterable);

  0009f	48 8b ca	 mov	 rcx, rdx
  000a2	e8 00 00 00 00	 call	 _Py_IncRef

; 1100 :             return iterable;

  000a7	48 8b 44 24 40	 mov	 rax, QWORD PTR iterable$[rsp]

; 1112 : }

  000ac	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000b1	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000b6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
$LN8@frozenset_@2:

; 1101 :         }
; 1102 :         result = make_new_set(type, iterable);

  000bc	48 8b cf	 mov	 rcx, rdi
  000bf	e8 00 00 00 00	 call	 make_new_set

; 1103 :         if (result == NULL || PySet_GET_SIZE(result))

  000c4	48 85 c0	 test	 rax, rax
  000c7	74 79		 je	 SHORT $LN13@frozenset_@2
  000c9	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000ce	75 72		 jne	 SHORT $LN13@frozenset_@2

; 1104 :             return result;
; 1105 :         Py_DECREF(result);

  000d0	48 8b c8	 mov	 rcx, rax
  000d3	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@frozenset_@2:

; 1106 :     }
; 1107 :     /* The empty frozenset is a singleton */
; 1108 :     if (emptyfrozenset == NULL)

  000d8	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR emptyfrozenset
  000df	48 85 db	 test	 rbx, rbx
  000e2	75 19		 jne	 SHORT $LN19@frozenset_@2

; 1109 :         emptyfrozenset = make_new_set(type, NULL);

  000e4	33 d2		 xor	 edx, edx
  000e6	48 8b cf	 mov	 rcx, rdi
  000e9	e8 00 00 00 00	 call	 make_new_set
  000ee	48 8b d8	 mov	 rbx, rax
  000f1	48 89 05 00 00
	00 00		 mov	 QWORD PTR emptyfrozenset, rax

; 1110 :     Py_XINCREF(emptyfrozenset);

  000f8	48 85 c0	 test	 rax, rax
  000fb	74 42		 je	 SHORT $LN3@frozenset_@2
$LN19@frozenset_@2:
  000fd	e8 00 00 00 00	 call	 _Py_PXCTX
  00102	85 c0		 test	 eax, eax
  00104	75 32		 jne	 SHORT $LN20@frozenset_@2
  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0010d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00114	4c 8b cb	 mov	 r9, rbx
  00117	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0011d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00125	e8 00 00 00 00	 call	 _PyParallel_Guard
  0012a	85 c0		 test	 eax, eax
  0012c	75 06		 jne	 SHORT $LN15@frozenset_@2
  0012e	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00132	74 04		 je	 SHORT $LN20@frozenset_@2
$LN15@frozenset_@2:
  00134	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN20@frozenset_@2:
  00138	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR emptyfrozenset
$LN3@frozenset_@2:

; 1111 :     return emptyfrozenset;

  0013f	48 8b c3	 mov	 rax, rbx
$LN13@frozenset_@2:

; 1112 : }

  00142	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00147	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0014c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00150	5f		 pop	 rdi
  00151	c3		 ret	 0
frozenset_new ENDP
_TEXT	ENDS
PUBLIC	PySet_ClearFreeList
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySet_ClearFreeList DD imagerel $LN8
	DD	imagerel $LN8+39
	DD	imagerel $unwind$PySet_ClearFreeList
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PySet_ClearFreeList DD imagerel $LN8+39
	DD	imagerel $LN8+99
	DD	imagerel $chain$0$PySet_ClearFreeList
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PySet_ClearFreeList DD imagerel $LN8+99
	DD	imagerel $LN8+107
	DD	imagerel $chain$1$PySet_ClearFreeList
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PySet_ClearFreeList DD 021H
	DD	imagerel $LN8
	DD	imagerel $LN8+39
	DD	imagerel $unwind$PySet_ClearFreeList
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PySet_ClearFreeList DD 020521H
	DD	067405H
	DD	imagerel $LN8
	DD	imagerel $LN8+39
	DD	imagerel $unwind$PySet_ClearFreeList
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySet_ClearFreeList DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PySet_ClearFreeList
_TEXT	SEGMENT
PySet_ClearFreeList PROC				; COMDAT

; 1116 : {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1117 :     int freelist_size = numfree;

  00006	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR numfree

; 1118 :     PySetObject *so;
; 1119 :     if (Py_PXCTX)

  0000c	e8 00 00 00 00	 call	 _Py_PXCTX
  00011	85 c0		 test	 eax, eax
  00013	74 08		 je	 SHORT $LN6@PySet_Clea

; 1120 :         return 0;

  00015	33 c0		 xor	 eax, eax

; 1128 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
$LN6@PySet_Clea:

; 1121 : 
; 1122 :     while (numfree) {

  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR numfree
  00023	85 c9		 test	 ecx, ecx
  00025	74 3c		 je	 SHORT $LN1@PySet_Clea
  00027	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0002c	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:free_list
  00033	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL2@PySet_Clea:

; 1123 :         numfree--;

  00040	ff c9		 dec	 ecx
  00042	89 0d 00 00 00
	00		 mov	 DWORD PTR numfree, ecx

; 1124 :         so = free_list[numfree];
; 1125 :         PyObject_GC_Del(so);

  00048	48 63 c9	 movsxd	 rcx, ecx
  0004b	48 8b 0c cf	 mov	 rcx, QWORD PTR [rdi+rcx*8]
  0004f	e8 00 00 00 00	 call	 PyObject_GC_Del
  00054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR numfree
  0005a	85 c9		 test	 ecx, ecx
  0005c	75 e2		 jne	 SHORT $LL2@PySet_Clea
  0005e	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN1@PySet_Clea:

; 1126 :     }
; 1127 :     return freelist_size;

  00063	8b c3		 mov	 eax, ebx

; 1128 : }

  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	5b		 pop	 rbx
  0006a	c3		 ret	 0
PySet_ClearFreeList ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@LHFKIDLH@PySet_Fini?$AA@		; `string'
PUBLIC	PySet_Fini
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PySet_Fini DD imagerel $LN33
	DD	imagerel $LN33+368
	DD	imagerel $unwind$PySet_Fini
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySet_Fini DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@LHFKIDLH@PySet_Fini?$AA@
CONST	SEGMENT
??_C@_0L@LHFKIDLH@PySet_Fini?$AA@ DB 'PySet_Fini', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
CONST	ENDS
;	COMDAT PySet_Fini
_TEXT	SEGMENT
PySet_Fini PROC						; COMDAT

; 1132 : {

$LN33:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1133 :     PySet_ClearFreeList();

  00006	e8 00 00 00 00	 call	 PySet_ClearFreeList

; 1134 :     Py_CLEAR(dummy);

  0000b	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR dummy
  00012	4d 85 c9	 test	 r9, r9
  00015	0f 84 9c 00 00
	00		 je	 $LN7@PySet_Fini
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LHFKIDLH@PySet_Fini?$AA@
  00029	41 b8 6e 04 00
	00		 mov	 r8d, 1134		; 0000046eH
  0002f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00037	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003c	85 c0		 test	 eax, eax
  0003e	75 77		 jne	 SHORT $LN7@PySet_Fini
  00040	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR dummy
  00047	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR dummy, 0
  00052	e8 00 00 00 00	 call	 _Py_PXCTX
  00057	85 c0		 test	 eax, eax
  00059	75 5c		 jne	 SHORT $LN7@PySet_Fini
  0005b	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0005f	a8 20		 test	 al, 32			; 00000020H
  00061	75 4c		 jne	 SHORT $LN15@PySet_Fini
  00063	84 c0		 test	 al, al
  00065	78 48		 js	 SHORT $LN15@PySet_Fini
  00067	a8 02		 test	 al, 2
  00069	75 4c		 jne	 SHORT $LN7@PySet_Fini
  0006b	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0006f	75 46		 jne	 SHORT $LN7@PySet_Fini
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0007f	4c 8b cb	 mov	 r9, rbx
  00082	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00088	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00090	e8 00 00 00 00	 call	 _PyParallel_Guard
  00095	48 8b cb	 mov	 rcx, rbx
  00098	85 c0		 test	 eax, eax
  0009a	74 07		 je	 SHORT $LN20@PySet_Fini
  0009c	e8 00 00 00 00	 call	 _Px_Dealloc
  000a1	eb 14		 jmp	 SHORT $LN7@PySet_Fini
$LN20@PySet_Fini:
  000a3	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000a7	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000ad	eb 08		 jmp	 SHORT $LN7@PySet_Fini
$LN15@PySet_Fini:
  000af	48 8b cb	 mov	 rcx, rbx
  000b2	e8 00 00 00 00	 call	 Px_DecRef
$LN7@PySet_Fini:

; 1135 :     Py_CLEAR(emptyfrozenset);

  000b7	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR emptyfrozenset
  000be	4d 85 c9	 test	 r9, r9
  000c1	0f 84 a3 00 00
	00		 je	 $LN3@PySet_Fini
  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LHFKIDLH@PySet_Fini?$AA@
  000d5	41 b8 6f 04 00
	00		 mov	 r8d, 1135		; 0000046fH
  000db	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000e3	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e8	85 c0		 test	 eax, eax
  000ea	75 7e		 jne	 SHORT $LN3@PySet_Fini
  000ec	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR emptyfrozenset
  000f3	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR emptyfrozenset, 0
  000fe	e8 00 00 00 00	 call	 _Py_PXCTX
  00103	85 c0		 test	 eax, eax
  00105	75 63		 jne	 SHORT $LN3@PySet_Fini
  00107	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0010b	a8 20		 test	 al, 32			; 00000020H
  0010d	75 53		 jne	 SHORT $LN26@PySet_Fini
  0010f	84 c0		 test	 al, al
  00111	78 4f		 js	 SHORT $LN26@PySet_Fini
  00113	a8 02		 test	 al, 2
  00115	75 53		 jne	 SHORT $LN3@PySet_Fini
  00117	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0011b	75 4d		 jne	 SHORT $LN3@PySet_Fini
  0011d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00124	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0012b	4c 8b cb	 mov	 r9, rbx
  0012e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00134	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0013c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00141	48 8b cb	 mov	 rcx, rbx
  00144	85 c0		 test	 eax, eax
  00146	74 0a		 je	 SHORT $LN31@PySet_Fini

; 1136 : }

  00148	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014c	5b		 pop	 rbx
  0014d	e9 00 00 00 00	 jmp	 _Px_Dealloc

; 1135 :     Py_CLEAR(emptyfrozenset);

$LN31@PySet_Fini:
  00152	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 1136 : }

  00156	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0015a	5b		 pop	 rbx
  0015b	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]

; 1135 :     Py_CLEAR(emptyfrozenset);

$LN26@PySet_Fini:
  00162	48 8b cb	 mov	 rcx, rbx
  00165	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PySet_Fini:

; 1136 : }

  0016a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0016e	5b		 pop	 rbx
  0016f	c3		 ret	 0
PySet_Fini ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@IMKAHDMA@free?5PySetObject?$AA@	; `string'
PUBLIC	_PySet_DebugMallocStats
EXTRN	_PyDebugAllocatorStats:PROC
;	COMDAT ??_C@_0BB@IMKAHDMA@free?5PySetObject?$AA@
CONST	SEGMENT
??_C@_0BB@IMKAHDMA@free?5PySetObject?$AA@ DB 'free PySetObject', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PySet_DebugMallocStats
_TEXT	SEGMENT
out$ = 8
_PySet_DebugMallocStats PROC				; COMDAT

; 1142 :     _PyDebugAllocatorStats(out,
; 1143 :                            "free PySetObject",
; 1144 :                            numfree, sizeof(PySetObject));

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR numfree
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@IMKAHDMA@free?5PySetObject?$AA@
  0000e	41 b9 20 01 00
	00		 mov	 r9d, 288		; 00000120H

; 1145 : }

  00014	e9 00 00 00 00	 jmp	 _PyDebugAllocatorStats
_PySet_DebugMallocStats ENDP
_TEXT	ENDS
PUBLIC	??_C@_05EBMGGHG@set?$CI?$CJ?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_new DD imagerel set_new
	DD	imagerel set_new+63
	DD	imagerel $unwind$set_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_new DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_05EBMGGHG@set?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_05EBMGGHG@set?$CI?$CJ?$AA@ DB 'set()', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT set_new
_TEXT	SEGMENT
type$ = 48
args$ = 56
kwds$ = 64
set_new	PROC						; COMDAT

; 1150 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1151 :     if (type == &PySet_Type && !_PyArg_NoKeywords("set()", kwds))

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySet_Type
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 3b c8	 cmp	 rcx, rax
  00013	75 1b		 jne	 SHORT $LN1@set_new
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05EBMGGHG@set?$CI?$CJ?$AA@
  0001c	49 8b d0	 mov	 rdx, r8
  0001f	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  00024	85 c0		 test	 eax, eax
  00026	75 08		 jne	 SHORT $LN1@set_new

; 1152 :         return NULL;

  00028	33 c0		 xor	 eax, eax

; 1155 : }

  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5b		 pop	 rbx
  0002f	c3		 ret	 0
$LN1@set_new:

; 1153 : 
; 1154 :     return make_new_set(type, NULL);

  00030	33 d2		 xor	 edx, edx
  00032	48 8b cb	 mov	 rcx, rbx

; 1155 : }

  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5b		 pop	 rbx
  0003a	e9 00 00 00 00	 jmp	 make_new_set
set_new	ENDP
_TEXT	ENDS
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_swap_bodies DD imagerel set_swap_bodies
	DD	imagerel set_swap_bodies+452
	DD	imagerel $unwind$set_swap_bodies
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_swap_bodies DD 071201H
	DD	0176412H
	DD	0163412H
	DD	0140112H
	DD	0700bH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_swap_bodies
_TEXT	SEGMENT
tab$1$ = 32
tab$2$ = 48
tab$3$ = 64
tab$4$ = 80
tab$5$ = 96
tab$6$ = 112
tab$7$ = 128
tab$8$ = 144
a$ = 176
b$ = 184
set_swap_bodies PROC					; COMDAT

; 1172 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 1173 :     Py_ssize_t t;
; 1174 :     setentry *u;
; 1175 :     setentry *(*f)(PySetObject *so, PyObject *key, Py_ssize_t hash);
; 1176 :     setentry tab[PySet_MINSIZE];
; 1177 :     Py_hash_t h;
; 1178 : 
; 1179 :     t = a->fill;     a->fill   = b->fill;        b->fill  = t;

  00012	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  00016	48 8b 42 60	 mov	 rax, QWORD PTR [rdx+96]
  0001a	48 8b f9	 mov	 rdi, rcx
  0001d	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 1180 :     t = a->used;     a->used   = b->used;        b->used  = t;

  00021	48 8b 42 68	 mov	 rax, QWORD PTR [rdx+104]
  00025	4c 89 42 60	 mov	 QWORD PTR [rdx+96], r8
  00029	4c 8b 41 68	 mov	 r8, QWORD PTR [rcx+104]
  0002d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 1181 :     t = a->mask;     a->mask   = b->mask;        b->mask  = t;

  00031	48 8b 42 70	 mov	 rax, QWORD PTR [rdx+112]
  00035	4c 89 42 68	 mov	 QWORD PTR [rdx+104], r8
  00039	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0003d	48 89 47 70	 mov	 QWORD PTR [rdi+112], rax
  00041	48 89 4a 70	 mov	 QWORD PTR [rdx+112], rcx

; 1182 : 
; 1183 :     u = a->table;

  00045	48 8b 4f 78	 mov	 rcx, QWORD PTR [rdi+120]
  00049	48 8b da	 mov	 rbx, rdx

; 1184 :     if (a->table == a->smalltable)

  0004c	48 8d 97 88 00
	00 00		 lea	 rdx, QWORD PTR [rdi+136]
  00053	48 3b ca	 cmp	 rcx, rdx
  00056	75 07		 jne	 SHORT $LN6@set_swap_b

; 1185 :         u = b->smalltable;

  00058	48 8d 8b 88 00
	00 00		 lea	 rcx, QWORD PTR [rbx+136]
$LN6@set_swap_b:

; 1186 :     a->table  = b->table;

  0005f	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]

; 1187 :     if (b->table == b->smalltable)

  00063	48 8d b3 88 00
	00 00		 lea	 rsi, QWORD PTR [rbx+136]
  0006a	48 89 47 78	 mov	 QWORD PTR [rdi+120], rax
  0006e	48 39 73 78	 cmp	 QWORD PTR [rbx+120], rsi
  00072	75 04		 jne	 SHORT $LN5@set_swap_b

; 1188 :         a->table = a->smalltable;

  00074	48 89 57 78	 mov	 QWORD PTR [rdi+120], rdx
$LN5@set_swap_b:

; 1189 :     b->table = u;
; 1190 : 
; 1191 :     f = a->lookup;   a->lookup = b->lookup;      b->lookup = f;

  00078	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]
  0007f	48 89 4b 78	 mov	 QWORD PTR [rbx+120], rcx
  00083	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  0008a	48 89 87 80 00
	00 00		 mov	 QWORD PTR [rdi+128], rax
  00091	48 89 8b 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rcx

; 1192 : 
; 1193 :     if (a->table == a->smalltable || b->table == b->smalltable) {

  00098	48 39 57 78	 cmp	 QWORD PTR [rdi+120], rdx
  0009c	74 0a		 je	 SHORT $LN3@set_swap_b
  0009e	48 39 73 78	 cmp	 QWORD PTR [rbx+120], rsi
  000a2	0f 85 ab 00 00
	00		 jne	 $LN4@set_swap_b
$LN3@set_swap_b:

; 1194 :         memcpy(tab, a->smalltable, sizeof(tab));

  000a8	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]

; 1195 :         memcpy(a->smalltable, b->smalltable, sizeof(tab));

  000ab	48 8b ca	 mov	 rcx, rdx
  000ae	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  000b4	0f 11 44 24 20	 movups	 XMMWORD PTR tab$1$[rsp], xmm0
  000b9	0f 10 42 10	 movups	 xmm0, XMMWORD PTR [rdx+16]
  000bd	0f 11 44 24 30	 movups	 XMMWORD PTR tab$2$[rsp], xmm0
  000c2	0f 10 42 20	 movups	 xmm0, XMMWORD PTR [rdx+32]
  000c6	0f 11 44 24 40	 movups	 XMMWORD PTR tab$3$[rsp], xmm0
  000cb	0f 10 42 30	 movups	 xmm0, XMMWORD PTR [rdx+48]
  000cf	0f 11 44 24 50	 movups	 XMMWORD PTR tab$4$[rsp], xmm0
  000d4	0f 10 42 40	 movups	 xmm0, XMMWORD PTR [rdx+64]
  000d8	0f 11 44 24 60	 movups	 XMMWORD PTR tab$5$[rsp], xmm0
  000dd	0f 10 42 50	 movups	 xmm0, XMMWORD PTR [rdx+80]
  000e1	0f 11 44 24 70	 movups	 XMMWORD PTR tab$6$[rsp], xmm0
  000e6	0f 10 42 60	 movups	 xmm0, XMMWORD PTR [rdx+96]
  000ea	0f 11 84 24 80
	00 00 00	 movups	 XMMWORD PTR tab$7$[rsp], xmm0
  000f2	0f 10 42 70	 movups	 xmm0, XMMWORD PTR [rdx+112]
  000f6	48 8b d6	 mov	 rdx, rsi
  000f9	0f 11 84 24 90
	00 00 00	 movups	 XMMWORD PTR tab$8$[rsp], xmm0
  00101	e8 00 00 00 00	 call	 memcpy

; 1196 :         memcpy(b->smalltable, tab, sizeof(tab));

  00106	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR tab$1$[rsp]
  0010b	0f 10 4c 24 30	 movups	 xmm1, XMMWORD PTR tab$2$[rsp]
  00110	0f 11 06	 movups	 XMMWORD PTR [rsi], xmm0
  00113	0f 10 44 24 40	 movups	 xmm0, XMMWORD PTR tab$3$[rsp]
  00118	0f 11 4e 10	 movups	 XMMWORD PTR [rsi+16], xmm1
  0011c	0f 10 4c 24 50	 movups	 xmm1, XMMWORD PTR tab$4$[rsp]
  00121	0f 11 46 20	 movups	 XMMWORD PTR [rsi+32], xmm0
  00125	0f 10 44 24 60	 movups	 xmm0, XMMWORD PTR tab$5$[rsp]
  0012a	0f 11 4e 30	 movups	 XMMWORD PTR [rsi+48], xmm1
  0012e	0f 10 4c 24 70	 movups	 xmm1, XMMWORD PTR tab$6$[rsp]
  00133	0f 11 46 40	 movups	 XMMWORD PTR [rsi+64], xmm0
  00137	0f 10 84 24 80
	00 00 00	 movups	 xmm0, XMMWORD PTR tab$7$[rsp]
  0013f	0f 11 4e 50	 movups	 XMMWORD PTR [rsi+80], xmm1
  00143	0f 10 8c 24 90
	00 00 00	 movups	 xmm1, XMMWORD PTR tab$8$[rsp]
  0014b	0f 11 46 60	 movups	 XMMWORD PTR [rsi+96], xmm0
  0014f	0f 11 4e 70	 movups	 XMMWORD PTR [rsi+112], xmm1
$LN4@set_swap_b:

; 1197 :     }
; 1198 : 
; 1199 :     if (PyType_IsSubtype(Py_TYPE(a), &PyFrozenSet_Type)  &&
; 1200 :         PyType_IsSubtype(Py_TYPE(b), &PyFrozenSet_Type)) {

  00153	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00157	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  0015e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00163	85 c0		 test	 eax, eax
  00165	74 32		 je	 SHORT $LN2@set_swap_b
  00167	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  0016b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00172	e8 00 00 00 00	 call	 PyType_IsSubtype
  00177	85 c0		 test	 eax, eax
  00179	74 1e		 je	 SHORT $LN2@set_swap_b

; 1201 :         h = a->hash;     a->hash = b->hash;  b->hash = h;

  0017b	48 8b 83 08 01
	00 00		 mov	 rax, QWORD PTR [rbx+264]
  00182	48 8b 8f 08 01
	00 00		 mov	 rcx, QWORD PTR [rdi+264]
  00189	48 89 87 08 01
	00 00		 mov	 QWORD PTR [rdi+264], rax
  00190	48 89 8b 08 01
	00 00		 mov	 QWORD PTR [rbx+264], rcx

; 1202 :     } else {

  00197	eb 16		 jmp	 SHORT $LN1@set_swap_b
$LN2@set_swap_b:

; 1203 :         a->hash = -1;

  00199	48 c7 87 08 01
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rdi+264], -1

; 1204 :         b->hash = -1;

  001a4	48 c7 83 08 01
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rbx+264], -1
$LN1@set_swap_b:

; 1205 :     }
; 1206 : }

  001af	4c 8d 9c 24 a0
	00 00 00	 lea	 r11, QWORD PTR [rsp+160]
  001b7	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  001bb	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  001bf	49 8b e3	 mov	 rsp, r11
  001c2	5f		 pop	 rdi
  001c3	c3		 ret	 0
set_swap_bodies ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT set_copy
_TEXT	SEGMENT
so$ = 8
set_copy PROC						; COMDAT

; 1211 :     return make_new_set_basetype(Py_TYPE(so), (PyObject *)so);

  00000	48 8b d1	 mov	 rdx, rcx
  00003	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]

; 1212 : }

  00007	e9 00 00 00 00	 jmp	 make_new_set_basetype
set_copy ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$frozenset_copy DD imagerel frozenset_copy
	DD	imagerel frozenset_copy+100
	DD	imagerel $unwind$frozenset_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$frozenset_copy DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT frozenset_copy
_TEXT	SEGMENT
so$ = 64
frozenset_copy PROC					; COMDAT

; 1216 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1217 :     if (PyFrozenSet_CheckExact(so)) {

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFrozenSet_Type
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00014	75 44		 jne	 SHORT $LN1@frozenset_@3

; 1218 :         Py_INCREF(so);

  00016	e8 00 00 00 00	 call	 _Py_PXCTX
  0001b	85 c0		 test	 eax, eax
  0001d	75 32		 jne	 SHORT $LN5@frozenset_@3
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0002d	4c 8b cb	 mov	 r9, rbx
  00030	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00036	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0003e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00043	85 c0		 test	 eax, eax
  00045	75 06		 jne	 SHORT $LN4@frozenset_@3
  00047	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0004b	74 04		 je	 SHORT $LN5@frozenset_@3
$LN4@frozenset_@3:
  0004d	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN5@frozenset_@3:

; 1219 :         return (PyObject *)so;

  00051	48 8b c3	 mov	 rax, rbx

; 1220 :     }
; 1221 :     return set_copy(so);
; 1222 : }

  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
$LN1@frozenset_@3:
  0005a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005e	5b		 pop	 rbx
  0005f	e9 00 00 00 00	 jmp	 set_copy
frozenset_copy ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_clear DD imagerel set_clear
	DD	imagerel set_clear+105
	DD	imagerel $unwind$set_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_clear DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_clear
_TEXT	SEGMENT
so$ = 64
set_clear PROC						; COMDAT

; 1228 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1229 :     set_clear_internal(so);

  00006	e8 00 00 00 00	 call	 set_clear_internal

; 1230 :     Py_RETURN_NONE;

  0000b	e8 00 00 00 00	 call	 _Py_PXCTX
  00010	85 c0		 test	 eax, eax
  00012	75 48		 jne	 SHORT $LN7@set_clear
  00014	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00029	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0002f	4c 8b cb	 mov	 r9, rbx
  00032	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0003a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003f	85 c0		 test	 eax, eax
  00041	75 09		 jne	 SHORT $LN3@set_clear
  00043	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0004a	74 07		 je	 SHORT $LN9@set_clear
$LN3@set_clear:
  0004c	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN9@set_clear:
  00053	48 8b c3	 mov	 rax, rbx

; 1231 : }

  00056	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005a	5b		 pop	 rbx
  0005b	c3		 ret	 0
$LN7@set_clear:

; 1230 :     Py_RETURN_NONE;

  0005c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1231 : }

  00063	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00067	5b		 pop	 rbx
  00068	c3		 ret	 0
set_clear ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_union DD imagerel set_union
	DD	imagerel set_union+52
	DD	imagerel $unwind$set_union
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$set_union DD imagerel set_union+52
	DD	imagerel set_union+144
	DD	imagerel $chain$1$set_union
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$set_union DD imagerel set_union+144
	DD	imagerel set_union+156
	DD	imagerel $chain$3$set_union
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$set_union DD 040021H
	DD	077400H
	DD	063400H
	DD	imagerel set_union
	DD	imagerel set_union+52
	DD	imagerel $unwind$set_union
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$set_union DD 040c21H
	DD	07740cH
	DD	063405H
	DD	imagerel set_union
	DD	imagerel set_union+52
	DD	imagerel $unwind$set_union
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_union DD 061001H
	DD	096410H
	DD	085410H
	DD	0c00c3210H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_union
_TEXT	SEGMENT
so$ = 48
args$ = 56
set_union PROC						; COMDAT

; 1237 : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	41 54		 push	 r12
  0000c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00010	48 8b f2	 mov	 rsi, rdx
  00013	4c 8b e1	 mov	 r12, rcx

; 1238 :     PySetObject *result;
; 1239 :     PyObject *other;
; 1240 :     Py_ssize_t i;
; 1241 : 
; 1242 :     result = (PySetObject *)set_copy(so);

  00016	e8 00 00 00 00	 call	 set_copy
  0001b	48 8b e8	 mov	 rbp, rax

; 1243 :     if (result == NULL)

  0001e	48 85 c0	 test	 rax, rax
  00021	75 11		 jne	 SHORT $LN6@set_union

; 1256 : }

  00023	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00028	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	41 5c		 pop	 r12
  00033	c3		 ret	 0
$LN6@set_union:
  00034	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1244 :         return NULL;
; 1245 : 
; 1246 :     for (i=0 ; i<PyTuple_GET_SIZE(args) ; i++) {

  00039	33 db		 xor	 ebx, ebx
  0003b	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00040	48 39 5e 60	 cmp	 QWORD PTR [rsi+96], rbx
  00044	7e 2c		 jle	 SHORT $LN12@set_union
  00046	48 8d 7e 70	 lea	 rdi, QWORD PTR [rsi+112]
  0004a	66 0f 1f 44 00
	00		 npad	 6
$LL5@set_union:

; 1247 :         other = PyTuple_GET_ITEM(args, i);

  00050	48 8b 17	 mov	 rdx, QWORD PTR [rdi]

; 1248 :         if ((PyObject *)so == other)

  00053	4c 3b e2	 cmp	 r12, rdx
  00056	74 0d		 je	 SHORT $LN4@set_union

; 1249 :             continue;
; 1250 :         if (set_update_internal(result, other) == -1) {

  00058	48 8b cd	 mov	 rcx, rbp
  0005b	e8 00 00 00 00	 call	 set_update_internal
  00060	83 f8 ff	 cmp	 eax, -1
  00063	74 2b		 je	 SHORT $LN10@set_union
$LN4@set_union:

; 1244 :         return NULL;
; 1245 : 
; 1246 :     for (i=0 ; i<PyTuple_GET_SIZE(args) ; i++) {

  00065	48 ff c3	 inc	 rbx
  00068	48 83 c7 08	 add	 rdi, 8
  0006c	48 3b 5e 60	 cmp	 rbx, QWORD PTR [rsi+96]
  00070	7c de		 jl	 SHORT $LL5@set_union
$LN12@set_union:

; 1253 :         }
; 1254 :     }
; 1255 :     return (PyObject *)result;

  00072	48 8b c5	 mov	 rax, rbp
$LN14@set_union:
  00075	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007a	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1256 : }

  0007f	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00084	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00089	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008d	41 5c		 pop	 r12
  0008f	c3		 ret	 0
$LN10@set_union:

; 1251 :             Py_DECREF(result);

  00090	48 8b cd	 mov	 rcx, rbp
  00093	e8 00 00 00 00	 call	 _Py_DecRef

; 1252 :             return NULL;

  00098	33 c0		 xor	 eax, eax
  0009a	eb d9		 jmp	 SHORT $LN14@set_union
set_union ENDP
_TEXT	ENDS
EXTRN	_Py_NotImplementedStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_or DD imagerel set_or
	DD	imagerel set_or+275
	DD	imagerel $unwind$set_or
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_or DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_or
_TEXT	SEGMENT
so$ = 64
other$ = 72
set_or	PROC						; COMDAT

; 1265 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f1	 mov	 rsi, rcx

; 1266 :     PySetObject *result;
; 1267 : 
; 1268 :     if (!PyAnySet_Check(so) || !PyAnySet_Check(other))

  00017	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0001b	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PySet_Type
  00022	48 8b fa	 mov	 rdi, rdx
  00025	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:PyFrozenSet_Type
  0002c	48 3b cd	 cmp	 rcx, rbp
  0002f	74 21		 je	 SHORT $LN4@set_or
  00031	48 3b cb	 cmp	 rcx, rbx
  00034	74 1c		 je	 SHORT $LN4@set_or
  00036	48 8b d5	 mov	 rdx, rbp
  00039	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003e	85 c0		 test	 eax, eax
  00040	75 10		 jne	 SHORT $LN4@set_or
  00042	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  00046	48 8b d3	 mov	 rdx, rbx
  00049	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004e	85 c0		 test	 eax, eax
  00050	74 2a		 je	 SHORT $LN5@set_or
$LN4@set_or:
  00052	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00056	48 3b cd	 cmp	 rcx, rbp
  00059	74 6f		 je	 SHORT $LN6@set_or
  0005b	48 3b cb	 cmp	 rcx, rbx
  0005e	74 6a		 je	 SHORT $LN6@set_or
  00060	48 8b d5	 mov	 rdx, rbp
  00063	e8 00 00 00 00	 call	 PyType_IsSubtype
  00068	85 c0		 test	 eax, eax
  0006a	75 5e		 jne	 SHORT $LN6@set_or
  0006c	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00070	48 8b d3	 mov	 rdx, rbx
  00073	e8 00 00 00 00	 call	 PyType_IsSubtype
  00078	85 c0		 test	 eax, eax
  0007a	75 4e		 jne	 SHORT $LN6@set_or
$LN5@set_or:

; 1269 :         Py_RETURN_NOTIMPLEMENTED;

  0007c	e8 00 00 00 00	 call	 _Py_PXCTX
  00081	85 c0		 test	 eax, eax
  00083	75 3c		 jne	 SHORT $LN10@set_or
  00085	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0009a	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ad	85 c0		 test	 eax, eax
  000af	75 09		 jne	 SHORT $LN9@set_or
  000b1	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  000b8	74 07		 je	 SHORT $LN10@set_or
$LN9@set_or:
  000ba	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN10@set_or:
  000c1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000c8	eb 34		 jmp	 SHORT $LN7@set_or
$LN6@set_or:

; 1270 : 
; 1271 :     result = (PySetObject *)set_copy(so);

  000ca	48 8b ce	 mov	 rcx, rsi
  000cd	e8 00 00 00 00	 call	 set_copy
  000d2	48 8b d8	 mov	 rbx, rax

; 1272 :     if (result == NULL)

  000d5	48 85 c0	 test	 rax, rax

; 1273 :         return NULL;

  000d8	74 1d		 je	 SHORT $LN13@set_or

; 1274 :     if ((PyObject *)so == other)

  000da	48 3b f7	 cmp	 rsi, rdi

; 1275 :         return (PyObject *)result;

  000dd	74 1f		 je	 SHORT $LN7@set_or

; 1276 :     if (set_update_internal(result, other) == -1) {

  000df	48 8b d7	 mov	 rdx, rdi
  000e2	48 8b c8	 mov	 rcx, rax
  000e5	e8 00 00 00 00	 call	 set_update_internal
  000ea	83 f8 ff	 cmp	 eax, -1
  000ed	75 0c		 jne	 SHORT $LN1@set_or

; 1277 :         Py_DECREF(result);

  000ef	48 8b cb	 mov	 rcx, rbx
  000f2	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@set_or:

; 1278 :         return NULL;

  000f7	33 c0		 xor	 eax, eax
  000f9	eb 03		 jmp	 SHORT $LN7@set_or
$LN1@set_or:

; 1279 :     }
; 1280 :     return (PyObject *)result;

  000fb	48 8b c3	 mov	 rax, rbx
$LN7@set_or:

; 1281 : }

  000fe	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00103	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00108	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0010d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00111	5f		 pop	 rdi
  00112	c3		 ret	 0
set_or	ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_ior DD imagerel set_ior
	DD	imagerel set_ior+221
	DD	imagerel $unwind$set_ior
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_ior DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_ior
_TEXT	SEGMENT
so$ = 64
other$ = 72
set_ior	PROC						; COMDAT

; 1285 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b d9	 mov	 rbx, rcx

; 1286 :     if (!PyAnySet_Check(other))

  00012	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00016	48 8b fa	 mov	 rdi, rdx
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00020	48 3b ca	 cmp	 rcx, rdx
  00023	74 48		 je	 SHORT $LN2@set_ior
  00025	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFrozenSet_Type
  0002c	48 3b ce	 cmp	 rcx, rsi
  0002f	74 3c		 je	 SHORT $LN2@set_ior
  00031	e8 00 00 00 00	 call	 PyType_IsSubtype
  00036	85 c0		 test	 eax, eax
  00038	75 33		 jne	 SHORT $LN2@set_ior
  0003a	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  0003e	48 8b d6	 mov	 rdx, rsi
  00041	e8 00 00 00 00	 call	 PyType_IsSubtype
  00046	85 c0		 test	 eax, eax
  00048	75 23		 jne	 SHORT $LN2@set_ior

; 1287 :         Py_RETURN_NOTIMPLEMENTED;

  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00051	e8 00 00 00 00	 call	 _Py_IncRef
  00056	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 1292 :     return (PyObject *)so;
; 1293 : }

  0005d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00062	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00067	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006b	5f		 pop	 rdi
  0006c	c3		 ret	 0
$LN2@set_ior:

; 1288 : 
; 1289 :     if (set_update_internal(so, other) == -1)

  0006d	48 8b d7	 mov	 rdx, rdi
  00070	48 8b cb	 mov	 rcx, rbx
  00073	e8 00 00 00 00	 call	 set_update_internal
  00078	83 f8 ff	 cmp	 eax, -1
  0007b	75 12		 jne	 SHORT $LN1@set_ior

; 1290 :         return NULL;

  0007d	33 c0		 xor	 eax, eax

; 1292 :     return (PyObject *)so;
; 1293 : }

  0007f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00084	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00089	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
$LN1@set_ior:

; 1291 :     Py_INCREF(so);

  0008f	e8 00 00 00 00	 call	 _Py_PXCTX
  00094	85 c0		 test	 eax, eax
  00096	75 32		 jne	 SHORT $LN6@set_ior
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000a6	4c 8b cb	 mov	 r9, rbx
  000a9	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000af	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b7	e8 00 00 00 00	 call	 _PyParallel_Guard
  000bc	85 c0		 test	 eax, eax
  000be	75 06		 jne	 SHORT $LN5@set_ior
  000c0	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000c4	74 04		 je	 SHORT $LN6@set_ior
$LN5@set_ior:
  000c6	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@set_ior:

; 1292 :     return (PyObject *)so;
; 1293 : }

  000ca	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000cf	48 8b c3	 mov	 rax, rbx
  000d2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000db	5f		 pop	 rdi
  000dc	c3		 ret	 0
set_ior	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_intersection DD imagerel set_intersection
	DD	imagerel set_intersection+35
	DD	imagerel $unwind$set_intersection
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$set_intersection DD imagerel set_intersection+35
	DD	imagerel set_intersection+65
	DD	imagerel $chain$0$set_intersection
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$set_intersection DD imagerel set_intersection+65
	DD	imagerel set_intersection+313
	DD	imagerel $chain$3$set_intersection
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$set_intersection DD imagerel set_intersection+313
	DD	imagerel set_intersection+356
	DD	imagerel $chain$5$set_intersection
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$set_intersection DD imagerel set_intersection+356
	DD	imagerel set_intersection+507
	DD	imagerel $chain$7$set_intersection
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$set_intersection DD 040021H
	DD	067400H
	DD	0c6400H
	DD	imagerel set_intersection
	DD	imagerel set_intersection+35
	DD	imagerel $unwind$set_intersection
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$set_intersection DD 040021H
	DD	067400H
	DD	0c6400H
	DD	imagerel set_intersection
	DD	imagerel set_intersection+35
	DD	imagerel $unwind$set_intersection
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$set_intersection DD 041021H
	DD	0c6410H
	DD	067400H
	DD	imagerel set_intersection
	DD	imagerel set_intersection+35
	DD	imagerel $unwind$set_intersection
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$set_intersection DD 020521H
	DD	067405H
	DD	imagerel set_intersection
	DD	imagerel set_intersection+35
	DD	imagerel $unwind$set_intersection
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_intersection DD 030701H
	DD	050036207H
	DD	03002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_intersection
_TEXT	SEGMENT
entry$21322 = 32
entry$21294 = 80
so$ = 80
pos$21293 = 88
other$ = 88
set_intersection PROC					; COMDAT

; 1297 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00007	48 8b da	 mov	 rbx, rdx
  0000a	48 8b e9	 mov	 rbp, rcx

; 1298 :     PySetObject *result;
; 1299 :     PyObject *key, *it, *tmp;
; 1300 : 
; 1301 :     if ((PyObject *)so == other)

  0000d	48 3b ca	 cmp	 rcx, rdx
  00010	75 0b		 jne	 SHORT $LN18@set_inters

; 1372 :         Py_DECREF(result);
; 1373 :         return NULL;
; 1374 :     }
; 1375 :     return (PyObject *)result;
; 1376 : }

  00012	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00016	5d		 pop	 rbp
  00017	5b		 pop	 rbx
  00018	e9 00 00 00 00	 jmp	 set_copy
$LN18@set_inters:

; 1302 :         return set_copy(so);
; 1303 : 
; 1304 :     result = (PySetObject *)make_new_set_basetype(Py_TYPE(so), NULL);

  0001d	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00021	33 d2		 xor	 edx, edx
  00023	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00028	e8 00 00 00 00	 call	 make_new_set_basetype
  0002d	48 8b f8	 mov	 rdi, rax

; 1305 :     if (result == NULL)

  00030	48 85 c0	 test	 rax, rax
  00033	75 0c		 jne	 SHORT $LN17@set_inters
  00035	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1372 :         Py_DECREF(result);
; 1373 :         return NULL;
; 1374 :     }
; 1375 :     return (PyObject *)result;
; 1376 : }

  0003a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003e	5d		 pop	 rbp
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
$LN17@set_inters:

; 1306 :         return NULL;
; 1307 : 
; 1308 :     if (PyAnySet_Check(other)) {

  00041	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0004c	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00051	48 3b ca	 cmp	 rcx, rdx
  00054	0f 84 0a 01 00
	00		 je	 $LN15@set_inters
  0005a	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFrozenSet_Type
  00061	48 3b ce	 cmp	 rcx, rsi
  00064	0f 84 fa 00 00
	00		 je	 $LN15@set_inters
  0006a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0006f	85 c0		 test	 eax, eax
  00071	0f 85 ed 00 00
	00		 jne	 $LN15@set_inters
  00077	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  0007b	48 8b d6	 mov	 rdx, rsi
  0007e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00083	85 c0		 test	 eax, eax
  00085	0f 85 d9 00 00
	00		 jne	 $LN15@set_inters

; 1332 :     }
; 1333 : 
; 1334 :     it = PyObject_GetIter(other);

  0008b	48 8b cb	 mov	 rcx, rbx
  0008e	e8 00 00 00 00	 call	 PyObject_GetIter
  00093	48 8b f0	 mov	 rsi, rax

; 1335 :     if (it == NULL) {

  00096	48 85 c0	 test	 rax, rax

; 1336 :         Py_DECREF(result);
; 1337 :         return NULL;

  00099	0f 84 7f 00 00
	00		 je	 $LN26@set_inters

; 1338 :     }
; 1339 : 
; 1340 :     while ((key = PyIter_Next(it)) != NULL) {

  0009f	48 8b c8	 mov	 rcx, rax
  000a2	e8 00 00 00 00	 call	 PyIter_Next
  000a7	48 8b d8	 mov	 rbx, rax
  000aa	48 85 c0	 test	 rax, rax
  000ad	74 59		 je	 SHORT $LN6@set_inters
  000af	90		 npad	 1
$LL7@set_inters:

; 1341 :         int rv;
; 1342 :         setentry entry;
; 1343 :         Py_hash_t hash = PyObject_Hash(key);

  000b0	48 8b cb	 mov	 rcx, rbx
  000b3	e8 00 00 00 00	 call	 PyObject_Hash

; 1344 : 
; 1345 :         if (hash == -1) {

  000b8	48 83 f8 ff	 cmp	 rax, -1
  000bc	74 7b		 je	 SHORT $LN23@set_inters

; 1350 :         }
; 1351 :         entry.hash = hash;
; 1352 :         entry.key = key;
; 1353 :         rv = set_contains_entry(so, &entry);

  000be	48 8d 54 24 20	 lea	 rdx, QWORD PTR entry$21322[rsp]
  000c3	48 8b cd	 mov	 rcx, rbp
  000c6	48 89 44 24 20	 mov	 QWORD PTR entry$21322[rsp], rax
  000cb	48 89 5c 24 28	 mov	 QWORD PTR entry$21322[rsp+8], rbx
  000d0	e8 00 00 00 00	 call	 set_contains_entry

; 1354 :         if (rv == -1) {

  000d5	83 f8 ff	 cmp	 eax, -1
  000d8	74 5f		 je	 SHORT $LN23@set_inters

; 1355 :             Py_DECREF(it);
; 1356 :             Py_DECREF(result);
; 1357 :             Py_DECREF(key);
; 1358 :             return NULL;
; 1359 :         }
; 1360 :         if (rv) {

  000da	85 c0		 test	 eax, eax
  000dc	74 12		 je	 SHORT $LN2@set_inters

; 1361 :             if (set_add_entry(result, &entry) == -1) {

  000de	48 8d 54 24 20	 lea	 rdx, QWORD PTR entry$21322[rsp]
  000e3	48 8b cf	 mov	 rcx, rdi
  000e6	e8 00 00 00 00	 call	 set_add_entry
  000eb	83 f8 ff	 cmp	 eax, -1
  000ee	74 49		 je	 SHORT $LN23@set_inters
$LN2@set_inters:

; 1362 :                 Py_DECREF(it);
; 1363 :                 Py_DECREF(result);
; 1364 :                 Py_DECREF(key);
; 1365 :                 return NULL;
; 1366 :             }
; 1367 :         }
; 1368 :         Py_DECREF(key);

  000f0	48 8b cb	 mov	 rcx, rbx
  000f3	e8 00 00 00 00	 call	 _Py_DecRef
  000f8	48 8b ce	 mov	 rcx, rsi
  000fb	e8 00 00 00 00	 call	 PyIter_Next
  00100	48 8b d8	 mov	 rbx, rax
  00103	48 85 c0	 test	 rax, rax
  00106	75 a8		 jne	 SHORT $LL7@set_inters
$LN6@set_inters:

; 1369 :     }
; 1370 :     Py_DECREF(it);

  00108	48 8b ce	 mov	 rcx, rsi
  0010b	e8 00 00 00 00	 call	 _Py_DecRef

; 1371 :     if (PyErr_Occurred()) {

  00110	e8 00 00 00 00	 call	 PyErr_Occurred
  00115	48 85 c0	 test	 rax, rax
  00118	0f 84 c9 00 00
	00		 je	 $LN12@set_inters
$LN26@set_inters:

; 1321 :                 Py_DECREF(result);

  0011e	48 8b cf	 mov	 rcx, rdi
  00121	e8 00 00 00 00	 call	 _Py_DecRef
  00126	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0012b	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1322 :                 return NULL;

  00130	33 c0		 xor	 eax, eax

; 1372 :         Py_DECREF(result);
; 1373 :         return NULL;
; 1374 :     }
; 1375 :     return (PyObject *)result;
; 1376 : }

  00132	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00136	5d		 pop	 rbp
  00137	5b		 pop	 rbx
  00138	c3		 ret	 0
$LN23@set_inters:

; 1346 :             Py_DECREF(it);

  00139	48 8b ce	 mov	 rcx, rsi
  0013c	e8 00 00 00 00	 call	 _Py_DecRef

; 1347 :             Py_DECREF(result);

  00141	48 8b cf	 mov	 rcx, rdi
  00144	e8 00 00 00 00	 call	 _Py_DecRef

; 1348 :             Py_DECREF(key);

  00149	48 8b cb	 mov	 rcx, rbx
  0014c	e8 00 00 00 00	 call	 _Py_DecRef
  00151	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00156	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1349 :             return NULL;

  0015b	33 c0		 xor	 eax, eax

; 1372 :         Py_DECREF(result);
; 1373 :         return NULL;
; 1374 :     }
; 1375 :     return (PyObject *)result;
; 1376 : }

  0015d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00161	5d		 pop	 rbp
  00162	5b		 pop	 rbx
  00163	c3		 ret	 0
$LN15@set_inters:

; 1309 :         Py_ssize_t pos = 0;
; 1310 :         setentry *entry;
; 1311 : 
; 1312 :         if (PySet_GET_SIZE(other) > PySet_GET_SIZE(so)) {

  00164	48 8b 45 68	 mov	 rax, QWORD PTR [rbp+104]
  00168	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR pos$21293[rsp], 0
  00171	48 39 43 68	 cmp	 QWORD PTR [rbx+104], rax
  00175	7e 09		 jle	 SHORT $LN22@set_inters

; 1313 :             tmp = (PyObject *)so;

  00177	48 8b c5	 mov	 rax, rbp

; 1314 :             so = (PySetObject *)other;

  0017a	48 8b eb	 mov	 rbp, rbx

; 1315 :             other = tmp;

  0017d	48 8b d8	 mov	 rbx, rax
$LN22@set_inters:

; 1316 :         }
; 1317 : 
; 1318 :         while (set_next((PySetObject *)other, &pos, &entry)) {

  00180	4c 8d 44 24 50	 lea	 r8, QWORD PTR entry$21294[rsp]
  00185	48 8d 54 24 58	 lea	 rdx, QWORD PTR pos$21293[rsp]
  0018a	48 8b cb	 mov	 rcx, rbx
  0018d	e8 00 00 00 00	 call	 set_next
  00192	85 c0		 test	 eax, eax
  00194	74 51		 je	 SHORT $LN12@set_inters
  00196	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL13@set_inters:

; 1319 :             int rv = set_contains_entry(so, entry);

  001a0	48 8b 74 24 50	 mov	 rsi, QWORD PTR entry$21294[rsp]
  001a5	48 8b cd	 mov	 rcx, rbp
  001a8	48 8b d6	 mov	 rdx, rsi
  001ab	e8 00 00 00 00	 call	 set_contains_entry

; 1320 :             if (rv == -1) {

  001b0	83 f8 ff	 cmp	 eax, -1
  001b3	0f 84 65 ff ff
	ff		 je	 $LN26@set_inters

; 1323 :             }
; 1324 :             if (rv) {

  001b9	85 c0		 test	 eax, eax
  001bb	74 14		 je	 SHORT $LN9@set_inters

; 1325 :                 if (set_add_entry(result, entry) == -1) {

  001bd	48 8b d6	 mov	 rdx, rsi
  001c0	48 8b cf	 mov	 rcx, rdi
  001c3	e8 00 00 00 00	 call	 set_add_entry
  001c8	83 f8 ff	 cmp	 eax, -1
  001cb	0f 84 4d ff ff
	ff		 je	 $LN26@set_inters
$LN9@set_inters:

; 1316 :         }
; 1317 : 
; 1318 :         while (set_next((PySetObject *)other, &pos, &entry)) {

  001d1	4c 8d 44 24 50	 lea	 r8, QWORD PTR entry$21294[rsp]
  001d6	48 8d 54 24 58	 lea	 rdx, QWORD PTR pos$21293[rsp]
  001db	48 8b cb	 mov	 rcx, rbx
  001de	e8 00 00 00 00	 call	 set_next
  001e3	85 c0		 test	 eax, eax
  001e5	75 b9		 jne	 SHORT $LL13@set_inters
$LN12@set_inters:
  001e7	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]

; 1326 :                     Py_DECREF(result);
; 1327 :                     return NULL;
; 1328 :                 }
; 1329 :             }
; 1330 :         }
; 1331 :         return (PyObject *)result;

  001ec	48 8b c7	 mov	 rax, rdi
  001ef	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1372 :         Py_DECREF(result);
; 1373 :         return NULL;
; 1374 :     }
; 1375 :     return (PyObject *)result;
; 1376 : }

  001f4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001f8	5d		 pop	 rbp
  001f9	5b		 pop	 rbx
  001fa	c3		 ret	 0
set_intersection ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_intersection_multi DD imagerel set_intersection_multi
	DD	imagerel set_intersection_multi+40
	DD	imagerel $unwind$set_intersection_multi
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$set_intersection_multi DD imagerel set_intersection_multi+40
	DD	imagerel set_intersection_multi+202
	DD	imagerel $chain$2$set_intersection_multi
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$set_intersection_multi DD imagerel set_intersection_multi+202
	DD	imagerel set_intersection_multi+211
	DD	imagerel $chain$4$set_intersection_multi
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$set_intersection_multi DD 060021H
	DD	0a7400H
	DD	096400H
	DD	085400H
	DD	imagerel set_intersection_multi
	DD	imagerel set_intersection_multi+40
	DD	imagerel $unwind$set_intersection_multi
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$set_intersection_multi DD 064c21H
	DD	09644cH
	DD	085447H
	DD	0a7405H
	DD	imagerel set_intersection_multi
	DD	imagerel set_intersection_multi+40
	DD	imagerel $unwind$set_intersection_multi
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_intersection_multi DD 040b01H
	DD	0b340bH
	DD	0c007520bH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_intersection_multi
_TEXT	SEGMENT
so$ = 64
args$ = 72
set_intersection_multi PROC				; COMDAT

; 1380 : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	41 54		 push	 r12
  00007	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1381 :     Py_ssize_t i;
; 1382 :     PyObject *result = (PyObject *)so;
; 1383 : 
; 1384 :     if (PyTuple_GET_SIZE(args) == 0)

  0000b	48 83 7a 60 00	 cmp	 QWORD PTR [rdx+96], 0
  00010	4c 8b e2	 mov	 r12, rdx
  00013	48 8b d9	 mov	 rbx, rcx
  00016	75 10		 jne	 SHORT $LN5@set_inters@2

; 1399 : }

  00018	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0001d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00021	41 5c		 pop	 r12
  00023	e9 00 00 00 00	 jmp	 set_copy
$LN5@set_inters@2:
  00028	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi

; 1385 :         return set_copy(so);
; 1386 : 
; 1387 :     Py_INCREF(so);

  0002d	e8 00 00 00 00	 call	 _Py_PXCTX
  00032	85 c0		 test	 eax, eax
  00034	75 32		 jne	 SHORT $LN9@set_inters@2
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00044	4c 8b cb	 mov	 r9, rbx
  00047	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0004d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00055	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005a	85 c0		 test	 eax, eax
  0005c	75 06		 jne	 SHORT $LN8@set_inters@2
  0005e	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00062	74 04		 je	 SHORT $LN9@set_inters@2
$LN8@set_inters@2:
  00064	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN9@set_inters@2:

; 1388 :     for (i=0 ; i<PyTuple_GET_SIZE(args) ; i++) {

  00068	33 ff		 xor	 edi, edi
  0006a	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  0006f	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00074	49 39 7c 24 60	 cmp	 QWORD PTR [r12+96], rdi
  00079	7e 31		 jle	 SHORT $LN2@set_inters@2
  0007b	49 8d 74 24 70	 lea	 rsi, QWORD PTR [r12+112]
$LL4@set_inters@2:

; 1389 :         PyObject *other = PyTuple_GET_ITEM(args, i);
; 1390 :         PyObject *newresult = set_intersection((PySetObject *)result, other);

  00080	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  00083	48 8b cb	 mov	 rcx, rbx
  00086	e8 00 00 00 00	 call	 set_intersection

; 1394 :         }
; 1395 :         Py_DECREF(result);

  0008b	48 8b cb	 mov	 rcx, rbx
  0008e	48 8b e8	 mov	 rbp, rax
  00091	48 85 c0	 test	 rax, rax
  00094	74 34		 je	 SHORT $LN13@set_inters@2
  00096	e8 00 00 00 00	 call	 _Py_DecRef
  0009b	48 ff c7	 inc	 rdi
  0009e	48 83 c6 08	 add	 rsi, 8

; 1396 :         result = newresult;

  000a2	48 8b dd	 mov	 rbx, rbp
  000a5	49 3b 7c 24 60	 cmp	 rdi, QWORD PTR [r12+96]
  000aa	7c d4		 jl	 SHORT $LL4@set_inters@2
$LN2@set_inters@2:

; 1397 :     }
; 1398 :     return result;

  000ac	48 8b c3	 mov	 rax, rbx
$LN17@set_inters@2:
  000af	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b4	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000b9	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 1399 : }

  000be	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000c3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c7	41 5c		 pop	 r12
  000c9	c3		 ret	 0
$LN13@set_inters@2:

; 1391 :         if (newresult == NULL) {
; 1392 :             Py_DECREF(result);

  000ca	e8 00 00 00 00	 call	 _Py_DecRef

; 1393 :             return NULL;

  000cf	33 c0		 xor	 eax, eax
  000d1	eb dc		 jmp	 SHORT $LN17@set_inters@2
set_intersection_multi ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_intersection_update DD imagerel set_intersection_update
	DD	imagerel set_intersection_update+143
	DD	imagerel $unwind$set_intersection_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_intersection_update DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_intersection_update
_TEXT	SEGMENT
so$ = 64
other$ = 72
set_intersection_update PROC				; COMDAT

; 1408 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 1409 :     PyObject *tmp;
; 1410 : 
; 1411 :     tmp = set_intersection(so, other);

  0000d	e8 00 00 00 00	 call	 set_intersection
  00012	48 8b d8	 mov	 rbx, rax

; 1412 :     if (tmp == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0b		 jne	 SHORT $LN1@set_inters@3

; 1417 : }

  0001a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0001f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
$LN1@set_inters@3:

; 1413 :         return NULL;
; 1414 :     set_swap_bodies(so, (PySetObject *)tmp);

  00025	48 8b d0	 mov	 rdx, rax
  00028	48 8b cf	 mov	 rcx, rdi
  0002b	e8 00 00 00 00	 call	 set_swap_bodies

; 1415 :     Py_DECREF(tmp);

  00030	48 8b cb	 mov	 rcx, rbx
  00033	e8 00 00 00 00	 call	 _Py_DecRef

; 1416 :     Py_RETURN_NONE;

  00038	e8 00 00 00 00	 call	 _Py_PXCTX
  0003d	85 c0		 test	 eax, eax
  0003f	75 3c		 jne	 SHORT $LN5@set_inters@3
  00041	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00056	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0005c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00064	e8 00 00 00 00	 call	 _PyParallel_Guard
  00069	85 c0		 test	 eax, eax
  0006b	75 09		 jne	 SHORT $LN4@set_inters@3
  0006d	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00074	74 07		 je	 SHORT $LN5@set_inters@3
$LN4@set_inters@3:
  00076	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@set_inters@3:
  0007d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1417 : }

  00084	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00089	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
set_intersection_update ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_intersection_update_multi DD imagerel set_intersection_update_multi
	DD	imagerel set_intersection_update_multi+143
	DD	imagerel $unwind$set_intersection_update_multi
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_intersection_update_multi DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_intersection_update_multi
_TEXT	SEGMENT
so$ = 64
args$ = 72
set_intersection_update_multi PROC			; COMDAT

; 1421 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 1422 :     PyObject *tmp;
; 1423 : 
; 1424 :     tmp = set_intersection_multi(so, args);

  0000d	e8 00 00 00 00	 call	 set_intersection_multi
  00012	48 8b d8	 mov	 rbx, rax

; 1425 :     if (tmp == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0b		 jne	 SHORT $LN1@set_inters@4

; 1430 : }

  0001a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0001f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
$LN1@set_inters@4:

; 1426 :         return NULL;
; 1427 :     set_swap_bodies(so, (PySetObject *)tmp);

  00025	48 8b d0	 mov	 rdx, rax
  00028	48 8b cf	 mov	 rcx, rdi
  0002b	e8 00 00 00 00	 call	 set_swap_bodies

; 1428 :     Py_DECREF(tmp);

  00030	48 8b cb	 mov	 rcx, rbx
  00033	e8 00 00 00 00	 call	 _Py_DecRef

; 1429 :     Py_RETURN_NONE;

  00038	e8 00 00 00 00	 call	 _Py_PXCTX
  0003d	85 c0		 test	 eax, eax
  0003f	75 3c		 jne	 SHORT $LN5@set_inters@4
  00041	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00056	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0005c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00064	e8 00 00 00 00	 call	 _PyParallel_Guard
  00069	85 c0		 test	 eax, eax
  0006b	75 09		 jne	 SHORT $LN4@set_inters@4
  0006d	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00074	74 07		 je	 SHORT $LN5@set_inters@4
$LN4@set_inters@4:
  00076	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@set_inters@4:
  0007d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1430 : }

  00084	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00089	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
set_intersection_update_multi ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_and DD imagerel set_and
	DD	imagerel set_and+234
	DD	imagerel $unwind$set_and
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_and DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_and
_TEXT	SEGMENT
so$ = 64
other$ = 72
set_and	PROC						; COMDAT

; 1437 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f9	 mov	 rdi, rcx

; 1438 :     if (!PyAnySet_Check(so) || !PyAnySet_Check(other))

  00017	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0001b	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PySet_Type
  00022	48 8b da	 mov	 rbx, rdx
  00025	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFrozenSet_Type
  0002c	48 3b cd	 cmp	 rcx, rbp
  0002f	74 21		 je	 SHORT $LN1@set_and
  00031	48 3b ce	 cmp	 rcx, rsi
  00034	74 1c		 je	 SHORT $LN1@set_and
  00036	48 8b d5	 mov	 rdx, rbp
  00039	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003e	85 c0		 test	 eax, eax
  00040	75 10		 jne	 SHORT $LN1@set_and
  00042	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00046	48 8b d6	 mov	 rdx, rsi
  00049	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004e	85 c0		 test	 eax, eax
  00050	74 2a		 je	 SHORT $LN2@set_and
$LN1@set_and:
  00052	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00056	48 3b cd	 cmp	 rcx, rbp
  00059	74 6f		 je	 SHORT $LN3@set_and
  0005b	48 3b ce	 cmp	 rcx, rsi
  0005e	74 6a		 je	 SHORT $LN3@set_and
  00060	48 8b d5	 mov	 rdx, rbp
  00063	e8 00 00 00 00	 call	 PyType_IsSubtype
  00068	85 c0		 test	 eax, eax
  0006a	75 5e		 jne	 SHORT $LN3@set_and
  0006c	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00070	48 8b d6	 mov	 rdx, rsi
  00073	e8 00 00 00 00	 call	 PyType_IsSubtype
  00078	85 c0		 test	 eax, eax
  0007a	75 4e		 jne	 SHORT $LN3@set_and
$LN2@set_and:

; 1439 :         Py_RETURN_NOTIMPLEMENTED;

  0007c	e8 00 00 00 00	 call	 _Py_PXCTX
  00081	85 c0		 test	 eax, eax
  00083	75 3c		 jne	 SHORT $LN7@set_and
  00085	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0009a	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ad	85 c0		 test	 eax, eax
  000af	75 09		 jne	 SHORT $LN6@set_and
  000b1	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  000b8	74 07		 je	 SHORT $LN7@set_and
$LN6@set_and:
  000ba	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN7@set_and:
  000c1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000c8	eb 0b		 jmp	 SHORT $LN4@set_and
$LN3@set_and:

; 1440 :     return set_intersection(so, other);

  000ca	48 8b d3	 mov	 rdx, rbx
  000cd	48 8b cf	 mov	 rcx, rdi
  000d0	e8 00 00 00 00	 call	 set_intersection
$LN4@set_and:

; 1441 : }

  000d5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000da	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000df	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000e4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e8	5f		 pop	 rdi
  000e9	c3		 ret	 0
set_and	ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_iand DD imagerel set_iand
	DD	imagerel set_iand+227
	DD	imagerel $unwind$set_iand
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_iand DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_iand
_TEXT	SEGMENT
so$ = 64
other$ = 72
set_iand PROC						; COMDAT

; 1445 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b d9	 mov	 rbx, rcx

; 1446 :     PyObject *result;
; 1447 : 
; 1448 :     if (!PyAnySet_Check(other))

  00012	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00016	48 8b fa	 mov	 rdi, rdx
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00020	48 3b ca	 cmp	 rcx, rdx
  00023	74 48		 je	 SHORT $LN2@set_iand
  00025	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFrozenSet_Type
  0002c	48 3b ce	 cmp	 rcx, rsi
  0002f	74 3c		 je	 SHORT $LN2@set_iand
  00031	e8 00 00 00 00	 call	 PyType_IsSubtype
  00036	85 c0		 test	 eax, eax
  00038	75 33		 jne	 SHORT $LN2@set_iand
  0003a	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  0003e	48 8b d6	 mov	 rdx, rsi
  00041	e8 00 00 00 00	 call	 PyType_IsSubtype
  00046	85 c0		 test	 eax, eax
  00048	75 23		 jne	 SHORT $LN2@set_iand

; 1449 :         Py_RETURN_NOTIMPLEMENTED;

  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00051	e8 00 00 00 00	 call	 _Py_IncRef
  00056	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 1455 :     return (PyObject *)so;
; 1456 : }

  0005d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00062	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00067	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006b	5f		 pop	 rdi
  0006c	c3		 ret	 0
$LN2@set_iand:

; 1450 :     result = set_intersection_update(so, other);

  0006d	48 8b d7	 mov	 rdx, rdi
  00070	48 8b cb	 mov	 rcx, rbx
  00073	e8 00 00 00 00	 call	 set_intersection_update

; 1451 :     if (result == NULL)

  00078	48 85 c0	 test	 rax, rax
  0007b	75 10		 jne	 SHORT $LN1@set_iand

; 1455 :     return (PyObject *)so;
; 1456 : }

  0007d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00082	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00087	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
$LN1@set_iand:

; 1452 :         return NULL;
; 1453 :     Py_DECREF(result);

  0008d	48 8b c8	 mov	 rcx, rax
  00090	e8 00 00 00 00	 call	 _Py_DecRef

; 1454 :     Py_INCREF(so);

  00095	e8 00 00 00 00	 call	 _Py_PXCTX
  0009a	85 c0		 test	 eax, eax
  0009c	75 32		 jne	 SHORT $LN6@set_iand
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000ac	4c 8b cb	 mov	 r9, rbx
  000af	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000b5	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000bd	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c2	85 c0		 test	 eax, eax
  000c4	75 06		 jne	 SHORT $LN5@set_iand
  000c6	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000ca	74 04		 je	 SHORT $LN6@set_iand
$LN5@set_iand:
  000cc	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@set_iand:

; 1455 :     return (PyObject *)so;
; 1456 : }

  000d0	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000d5	48 8b c3	 mov	 rax, rbx
  000d8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000dd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e1	5f		 pop	 rdi
  000e2	c3		 ret	 0
set_iand ENDP
_TEXT	ENDS
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_isdisjoint DD imagerel set_isdisjoint
	DD	imagerel set_isdisjoint+234
	DD	imagerel $unwind$set_isdisjoint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$set_isdisjoint DD imagerel set_isdisjoint+234
	DD	imagerel set_isdisjoint+264
	DD	imagerel $chain$0$set_isdisjoint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$set_isdisjoint DD imagerel set_isdisjoint+264
	DD	imagerel set_isdisjoint+418
	DD	imagerel $chain$3$set_isdisjoint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$set_isdisjoint DD imagerel set_isdisjoint+418
	DD	imagerel set_isdisjoint+459
	DD	imagerel $chain$5$set_isdisjoint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$set_isdisjoint DD imagerel set_isdisjoint+459
	DD	imagerel set_isdisjoint+494
	DD	imagerel $chain$7$set_isdisjoint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$set_isdisjoint DD imagerel set_isdisjoint+494
	DD	imagerel set_isdisjoint+767
	DD	imagerel $chain$8$set_isdisjoint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$set_isdisjoint DD 021H
	DD	imagerel set_isdisjoint
	DD	imagerel set_isdisjoint+234
	DD	imagerel $unwind$set_isdisjoint
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$set_isdisjoint DD 040021H
	DD	087400H
	DD	0e5400H
	DD	imagerel set_isdisjoint
	DD	imagerel set_isdisjoint+234
	DD	imagerel $unwind$set_isdisjoint
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$set_isdisjoint DD 040021H
	DD	087400H
	DD	0e5400H
	DD	imagerel set_isdisjoint
	DD	imagerel set_isdisjoint+234
	DD	imagerel $unwind$set_isdisjoint
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$set_isdisjoint DD 040821H
	DD	0e5408H
	DD	087400H
	DD	imagerel set_isdisjoint
	DD	imagerel set_isdisjoint+234
	DD	imagerel $unwind$set_isdisjoint
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$set_isdisjoint DD 020521H
	DD	087405H
	DD	imagerel set_isdisjoint
	DD	imagerel set_isdisjoint+234
	DD	imagerel $unwind$set_isdisjoint
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_isdisjoint DD 030701H
	DD	060038207H
	DD	03002H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_isdisjoint
_TEXT	SEGMENT
entry$21489 = 48
entry$21461 = 96
so$ = 96
pos$21460 = 104
other$ = 104
set_isdisjoint PROC					; COMDAT

; 1460 : {

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00007	48 8b da	 mov	 rbx, rdx
  0000a	48 8b f1	 mov	 rsi, rcx

; 1461 :     PyObject *key, *it, *tmp;
; 1462 : 
; 1463 :     if ((PyObject *)so == other) {

  0000d	48 3b ca	 cmp	 rcx, rdx
  00010	0f 85 ad 00 00
	00		 jne	 $LN15@set_isdisj

; 1464 :         if (PySet_GET_SIZE(so) == 0)

  00016	48 83 79 68 00	 cmp	 QWORD PTR [rcx+104], 0
  0001b	75 53		 jne	 SHORT $LN16@set_isdisj

; 1465 :             Py_RETURN_TRUE;

  0001d	e8 00 00 00 00	 call	 _Py_PXCTX
  00022	85 c0		 test	 eax, eax
  00024	75 3c		 jne	 SHORT $LN21@set_isdisj
  00026	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_TrueStruct
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0003b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00041	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00049	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004e	85 c0		 test	 eax, eax
  00050	75 09		 jne	 SHORT $LN20@set_isdisj
  00052	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  00059	74 07		 je	 SHORT $LN21@set_isdisj
$LN20@set_isdisj:
  0005b	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80
$LN21@set_isdisj:
  00062	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct

; 1520 : }

  00069	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006d	5e		 pop	 rsi
  0006e	5b		 pop	 rbx
  0006f	c3		 ret	 0
$LN16@set_isdisj:

; 1466 :         else
; 1467 :             Py_RETURN_FALSE;

  00070	e8 00 00 00 00	 call	 _Py_PXCTX
  00075	85 c0		 test	 eax, eax
  00077	75 3c		 jne	 SHORT $LN25@set_isdisj
  00079	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0008e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00094	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0009c	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a1	85 c0		 test	 eax, eax
  000a3	75 09		 jne	 SHORT $LN24@set_isdisj
  000a5	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  000ac	74 07		 je	 SHORT $LN25@set_isdisj
$LN24@set_isdisj:
  000ae	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN25@set_isdisj:
  000b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct

; 1520 : }

  000bc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c0	5e		 pop	 rsi
  000c1	5b		 pop	 rbx
  000c2	c3		 ret	 0
$LN15@set_isdisj:

; 1468 :     }
; 1469 : 
; 1470 :     if (PyAnySet_CheckExact(other)) {

  000c3	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PySet_Type
  000ce	48 3b c1	 cmp	 rax, rcx
  000d1	0f 84 17 01 00
	00		 je	 $LN13@set_isdisj
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFrozenSet_Type
  000de	48 3b c1	 cmp	 rax, rcx
  000e1	0f 84 07 01 00
	00		 je	 $LN13@set_isdisj

; 1487 :     }
; 1488 : 
; 1489 :     it = PyObject_GetIter(other);

  000e7	48 8b ca	 mov	 rcx, rdx
  000ea	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  000ef	e8 00 00 00 00	 call	 PyObject_GetIter
  000f4	48 8b f8	 mov	 rdi, rax

; 1490 :     if (it == NULL)

  000f7	48 85 c0	 test	 rax, rax
  000fa	75 0c		 jne	 SHORT $LN36@set_isdisj
  000fc	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 1520 : }

  00101	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00105	5e		 pop	 rsi
  00106	5b		 pop	 rbx
  00107	c3		 ret	 0
$LN36@set_isdisj:

; 1491 :         return NULL;
; 1492 : 
; 1493 :     while ((key = PyIter_Next(it)) != NULL) {

  00108	48 8b c8	 mov	 rcx, rax
  0010b	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  00110	e8 00 00 00 00	 call	 PyIter_Next
  00115	48 8b d8	 mov	 rbx, rax
  00118	48 85 c0	 test	 rax, rax
  0011b	74 4f		 je	 SHORT $LN5@set_isdisj
  0011d	0f 1f 00	 npad	 3
$LL6@set_isdisj:

; 1494 :         int rv;
; 1495 :         setentry entry;
; 1496 :         Py_hash_t hash = PyObject_Hash(key);

  00120	48 8b cb	 mov	 rcx, rbx
  00123	e8 00 00 00 00	 call	 PyObject_Hash

; 1497 : 
; 1498 :         if (hash == -1) {

  00128	48 83 f8 ff	 cmp	 rax, -1
  0012c	0f 84 99 00 00
	00		 je	 $LN38@set_isdisj

; 1502 :         }
; 1503 :         entry.hash = hash;
; 1504 :         entry.key = key;
; 1505 :         rv = set_contains_entry(so, &entry);

  00132	48 8d 54 24 30	 lea	 rdx, QWORD PTR entry$21489[rsp]
  00137	48 8b ce	 mov	 rcx, rsi
  0013a	48 89 44 24 30	 mov	 QWORD PTR entry$21489[rsp], rax
  0013f	48 89 5c 24 38	 mov	 QWORD PTR entry$21489[rsp+8], rbx
  00144	e8 00 00 00 00	 call	 set_contains_entry

; 1506 :         Py_DECREF(key);

  00149	48 8b cb	 mov	 rcx, rbx
  0014c	8b e8		 mov	 ebp, eax
  0014e	e8 00 00 00 00	 call	 _Py_DecRef
  00153	48 8b cf	 mov	 rcx, rdi

; 1507 :         if (rv == -1) {

  00156	83 fd ff	 cmp	 ebp, -1
  00159	74 7b		 je	 SHORT $LN39@set_isdisj

; 1508 :             Py_DECREF(it);
; 1509 :             return NULL;
; 1510 :         }
; 1511 :         if (rv) {

  0015b	85 ed		 test	 ebp, ebp
  0015d	75 43		 jne	 SHORT $LN40@set_isdisj

; 1491 :         return NULL;
; 1492 : 
; 1493 :     while ((key = PyIter_Next(it)) != NULL) {

  0015f	e8 00 00 00 00	 call	 PyIter_Next
  00164	48 8b d8	 mov	 rbx, rax
  00167	48 85 c0	 test	 rax, rax
  0016a	75 b4		 jne	 SHORT $LL6@set_isdisj
$LN5@set_isdisj:

; 1514 :         }
; 1515 :     }
; 1516 :     Py_DECREF(it);

  0016c	48 8b cf	 mov	 rcx, rdi
  0016f	e8 00 00 00 00	 call	 _Py_DecRef

; 1517 :     if (PyErr_Occurred())

  00174	e8 00 00 00 00	 call	 PyErr_Occurred
  00179	48 85 c0	 test	 rax, rax

; 1518 :         return NULL;

  0017c	75 5d		 jne	 SHORT $LN45@set_isdisj

; 1519 :     Py_RETURN_TRUE;

  0017e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00185	e8 00 00 00 00	 call	 _Py_IncRef
  0018a	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  0018f	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00194	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct

; 1520 : }

  0019b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0019f	5e		 pop	 rsi
  001a0	5b		 pop	 rbx
  001a1	c3		 ret	 0
$LN40@set_isdisj:

; 1512 :             Py_DECREF(it);

  001a2	e8 00 00 00 00	 call	 _Py_DecRef

; 1513 :             Py_RETURN_FALSE;

  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  001ae	e8 00 00 00 00	 call	 _Py_IncRef
  001b3	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  001b8	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  001bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct

; 1520 : }

  001c4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c8	5e		 pop	 rsi
  001c9	5b		 pop	 rbx
  001ca	c3		 ret	 0
$LN38@set_isdisj:

; 1499 :             Py_DECREF(key);

  001cb	48 8b cb	 mov	 rcx, rbx
  001ce	e8 00 00 00 00	 call	 _Py_DecRef

; 1500 :             Py_DECREF(it);

  001d3	48 8b cf	 mov	 rcx, rdi
$LN39@set_isdisj:
  001d6	e8 00 00 00 00	 call	 _Py_DecRef
$LN45@set_isdisj:
  001db	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  001e0	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 1501 :             return NULL;

  001e5	33 c0		 xor	 eax, eax

; 1520 : }

  001e7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001eb	5e		 pop	 rsi
  001ec	5b		 pop	 rbx
  001ed	c3		 ret	 0
$LN13@set_isdisj:

; 1471 :         Py_ssize_t pos = 0;
; 1472 :         setentry *entry;
; 1473 : 
; 1474 :         if (PySet_GET_SIZE(other) > PySet_GET_SIZE(so)) {

  001ee	48 8b 46 68	 mov	 rax, QWORD PTR [rsi+104]
  001f2	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR pos$21460[rsp], 0
  001fb	48 39 42 68	 cmp	 QWORD PTR [rdx+104], rax
  001ff	7e 06		 jle	 SHORT $LN37@set_isdisj

; 1475 :             tmp = (PyObject *)so;
; 1476 :             so = (PySetObject *)other;
; 1477 :             other = tmp;

  00201	48 8b de	 mov	 rbx, rsi
  00204	48 8b f2	 mov	 rsi, rdx
$LN37@set_isdisj:

; 1478 :         }
; 1479 :         while (set_next((PySetObject *)other, &pos, &entry)) {

  00207	4c 8d 44 24 60	 lea	 r8, QWORD PTR entry$21461[rsp]
  0020c	48 8d 54 24 68	 lea	 rdx, QWORD PTR pos$21460[rsp]
  00211	48 8b cb	 mov	 rcx, rbx
  00214	e8 00 00 00 00	 call	 set_next
  00219	85 c0		 test	 eax, eax
  0021b	74 33		 je	 SHORT $LN10@set_isdisj
  0021d	0f 1f 00	 npad	 3
$LL11@set_isdisj:

; 1480 :             int rv = set_contains_entry(so, entry);

  00220	48 8b 54 24 60	 mov	 rdx, QWORD PTR entry$21461[rsp]
  00225	48 8b ce	 mov	 rcx, rsi
  00228	e8 00 00 00 00	 call	 set_contains_entry

; 1481 :             if (rv == -1)

  0022d	83 f8 ff	 cmp	 eax, -1
  00230	0f 84 c0 00 00
	00		 je	 $LN41@set_isdisj

; 1483 :             if (rv)

  00236	85 c0		 test	 eax, eax
  00238	75 69		 jne	 SHORT $LN42@set_isdisj

; 1478 :         }
; 1479 :         while (set_next((PySetObject *)other, &pos, &entry)) {

  0023a	4c 8d 44 24 60	 lea	 r8, QWORD PTR entry$21461[rsp]
  0023f	48 8d 54 24 68	 lea	 rdx, QWORD PTR pos$21460[rsp]
  00244	48 8b cb	 mov	 rcx, rbx
  00247	e8 00 00 00 00	 call	 set_next
  0024c	85 c0		 test	 eax, eax
  0024e	75 d0		 jne	 SHORT $LL11@set_isdisj
$LN10@set_isdisj:

; 1485 :         }
; 1486 :         Py_RETURN_TRUE;

  00250	e8 00 00 00 00	 call	 _Py_PXCTX
  00255	85 c0		 test	 eax, eax
  00257	75 3c		 jne	 SHORT $LN33@set_isdisj
  00259	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_TrueStruct
  00260	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00267	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0026e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00274	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0027c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00281	85 c0		 test	 eax, eax
  00283	75 09		 jne	 SHORT $LN32@set_isdisj
  00285	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  0028c	74 07		 je	 SHORT $LN33@set_isdisj
$LN32@set_isdisj:
  0028e	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80
$LN33@set_isdisj:
  00295	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct

; 1520 : }

  0029c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002a0	5e		 pop	 rsi
  002a1	5b		 pop	 rbx
  002a2	c3		 ret	 0
$LN42@set_isdisj:

; 1484 :                 Py_RETURN_FALSE;

  002a3	e8 00 00 00 00	 call	 _Py_PXCTX
  002a8	85 c0		 test	 eax, eax
  002aa	75 3c		 jne	 SHORT $LN29@set_isdisj
  002ac	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  002b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  002c1	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  002c7	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  002cf	e8 00 00 00 00	 call	 _PyParallel_Guard
  002d4	85 c0		 test	 eax, eax
  002d6	75 09		 jne	 SHORT $LN28@set_isdisj
  002d8	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  002df	74 07		 je	 SHORT $LN29@set_isdisj
$LN28@set_isdisj:
  002e1	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN29@set_isdisj:
  002e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct

; 1520 : }

  002ef	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002f3	5e		 pop	 rsi
  002f4	5b		 pop	 rbx
  002f5	c3		 ret	 0
$LN41@set_isdisj:

; 1482 :                 return NULL;

  002f6	33 c0		 xor	 eax, eax

; 1520 : }

  002f8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002fc	5e		 pop	 rsi
  002fd	5b		 pop	 rbx
  002fe	c3		 ret	 0
set_isdisjoint ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_difference_update_internal DD imagerel set_difference_update_internal
	DD	imagerel set_difference_update_internal+47
	DD	imagerel $unwind$set_difference_update_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$set_difference_update_internal DD imagerel set_difference_update_internal+47
	DD	imagerel set_difference_update_internal+221
	DD	imagerel $chain$0$set_difference_update_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$set_difference_update_internal DD imagerel set_difference_update_internal+221
	DD	imagerel set_difference_update_internal+256
	DD	imagerel $chain$2$set_difference_update_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$set_difference_update_internal DD imagerel set_difference_update_internal+256
	DD	imagerel set_difference_update_internal+367
	DD	imagerel $chain$4$set_difference_update_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$set_difference_update_internal DD imagerel set_difference_update_internal+367
	DD	imagerel set_difference_update_internal+411
	DD	imagerel $chain$6$set_difference_update_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$set_difference_update_internal DD 020021H
	DD	086400H
	DD	imagerel set_difference_update_internal
	DD	imagerel set_difference_update_internal+47
	DD	imagerel $unwind$set_difference_update_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$set_difference_update_internal DD 020021H
	DD	086400H
	DD	imagerel set_difference_update_internal
	DD	imagerel set_difference_update_internal+47
	DD	imagerel $unwind$set_difference_update_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$set_difference_update_internal DD 020021H
	DD	086400H
	DD	imagerel set_difference_update_internal
	DD	imagerel set_difference_update_internal+47
	DD	imagerel $unwind$set_difference_update_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$set_difference_update_internal DD 020521H
	DD	086405H
	DD	imagerel set_difference_update_internal
	DD	imagerel set_difference_update_internal+47
	DD	imagerel $unwind$set_difference_update_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_difference_update_internal DD 040a01H
	DD	09340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_difference_update_internal
_TEXT	SEGMENT
entry$21525 = 48
so$ = 48
pos$21526 = 56
other$ = 56
set_difference_update_internal PROC			; COMDAT

; 1527 : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 1528 :     if ((PyObject *)so == other)

  00010	48 3b ca	 cmp	 rcx, rdx
  00013	75 0f		 jne	 SHORT $LN13@set_differ

; 1560 : }

  00015	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5f		 pop	 rdi
  0001f	e9 00 00 00 00	 jmp	 set_clear_internal
$LN13@set_differ:

; 1529 :         return set_clear_internal(so);
; 1530 : 
; 1531 :     if (PyAnySet_Check(other)) {

  00024	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0002f	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00034	48 3b ca	 cmp	 rcx, rdx
  00037	0f 84 c3 00 00
	00		 je	 $LN11@set_differ
  0003d	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFrozenSet_Type
  00044	48 3b ce	 cmp	 rcx, rsi
  00047	0f 84 b3 00 00
	00		 je	 $LN11@set_differ
  0004d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00052	85 c0		 test	 eax, eax
  00054	0f 85 a6 00 00
	00		 jne	 $LN11@set_differ
  0005a	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  0005e	48 8b d6	 mov	 rdx, rsi
  00061	e8 00 00 00 00	 call	 PyType_IsSubtype
  00066	85 c0		 test	 eax, eax
  00068	0f 85 92 00 00
	00		 jne	 $LN11@set_differ

; 1537 :                 return -1;
; 1538 :     } else {
; 1539 :         PyObject *key, *it;
; 1540 :         it = PyObject_GetIter(other);

  0006e	48 8b cb	 mov	 rcx, rbx
  00071	e8 00 00 00 00	 call	 PyObject_GetIter
  00076	48 8b f0	 mov	 rsi, rax

; 1541 :         if (it == NULL)

  00079	48 85 c0	 test	 rax, rax

; 1542 :             return -1;

  0007c	74 4c		 je	 SHORT $LN21@set_differ

; 1543 : 
; 1544 :         while ((key = PyIter_Next(it)) != NULL) {

  0007e	48 8b c8	 mov	 rcx, rax
  00081	e8 00 00 00 00	 call	 PyIter_Next
  00086	48 8b d8	 mov	 rbx, rax
  00089	48 85 c0	 test	 rax, rax
  0008c	74 2a		 je	 SHORT $LN4@set_differ
  0008e	66 90		 npad	 2
$LL5@set_differ:

; 1545 :             if (set_discard_key(so, key) == -1) {

  00090	48 8b d3	 mov	 rdx, rbx
  00093	48 8b cf	 mov	 rcx, rdi
  00096	e8 00 00 00 00	 call	 set_discard_key
  0009b	83 f8 ff	 cmp	 eax, -1
  0009e	74 3d		 je	 SHORT $LN20@set_differ

; 1549 :             }
; 1550 :             Py_DECREF(key);

  000a0	48 8b cb	 mov	 rcx, rbx
  000a3	e8 00 00 00 00	 call	 _Py_DecRef
  000a8	48 8b ce	 mov	 rcx, rsi
  000ab	e8 00 00 00 00	 call	 PyIter_Next
  000b0	48 8b d8	 mov	 rbx, rax
  000b3	48 85 c0	 test	 rax, rax
  000b6	75 d8		 jne	 SHORT $LL5@set_differ
$LN4@set_differ:

; 1551 :         }
; 1552 :         Py_DECREF(it);

  000b8	48 8b ce	 mov	 rcx, rsi
  000bb	e8 00 00 00 00	 call	 _Py_DecRef

; 1553 :         if (PyErr_Occurred())

  000c0	e8 00 00 00 00	 call	 PyErr_Occurred
  000c5	48 85 c0	 test	 rax, rax
  000c8	74 7e		 je	 SHORT $LN9@set_differ
$LN21@set_differ:

; 1554 :             return -1;

  000ca	83 c8 ff	 or	 eax, -1
  000cd	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 1560 : }

  000d2	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000d7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000db	5f		 pop	 rdi
  000dc	c3		 ret	 0
$LN20@set_differ:

; 1546 :                 Py_DECREF(it);

  000dd	48 8b ce	 mov	 rcx, rsi
  000e0	e8 00 00 00 00	 call	 _Py_DecRef

; 1547 :                 Py_DECREF(key);

  000e5	48 8b cb	 mov	 rcx, rbx
  000e8	e8 00 00 00 00	 call	 _Py_DecRef
  000ed	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 1548 :                 return -1;

  000f2	83 c8 ff	 or	 eax, -1

; 1560 : }

  000f5	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000fa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fe	5f		 pop	 rdi
  000ff	c3		 ret	 0
$LN11@set_differ:

; 1532 :         setentry *entry;
; 1533 :         Py_ssize_t pos = 0;
; 1534 : 
; 1535 :         while (set_next((PySetObject *)other, &pos, &entry))

  00100	4c 8d 44 24 30	 lea	 r8, QWORD PTR entry$21525[rsp]
  00105	48 8d 54 24 38	 lea	 rdx, QWORD PTR pos$21526[rsp]
  0010a	48 8b cb	 mov	 rcx, rbx
  0010d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR pos$21526[rsp], 0
  00116	e8 00 00 00 00	 call	 set_next
  0011b	85 c0		 test	 eax, eax
  0011d	74 29		 je	 SHORT $LN9@set_differ
  0011f	90		 npad	 1
$LL10@set_differ:

; 1536 :             if (set_discard_entry(so, entry) == -1)

  00120	48 8b 54 24 30	 mov	 rdx, QWORD PTR entry$21525[rsp]
  00125	48 8b cf	 mov	 rcx, rdi
  00128	e8 00 00 00 00	 call	 set_discard_entry
  0012d	83 f8 ff	 cmp	 eax, -1
  00130	74 98		 je	 SHORT $LN21@set_differ

; 1532 :         setentry *entry;
; 1533 :         Py_ssize_t pos = 0;
; 1534 : 
; 1535 :         while (set_next((PySetObject *)other, &pos, &entry))

  00132	4c 8d 44 24 30	 lea	 r8, QWORD PTR entry$21525[rsp]
  00137	48 8d 54 24 38	 lea	 rdx, QWORD PTR pos$21526[rsp]
  0013c	48 8b cb	 mov	 rcx, rbx
  0013f	e8 00 00 00 00	 call	 set_next
  00144	85 c0		 test	 eax, eax
  00146	75 d8		 jne	 SHORT $LL10@set_differ
$LN9@set_differ:

; 1555 :     }
; 1556 :     /* If more than 1/5 are dummies, then resize them away. */
; 1557 :     if ((so->fill - so->used) * 5 < so->mask)

  00148	48 8b 4f 68	 mov	 rcx, QWORD PTR [rdi+104]
  0014c	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00150	48 2b c1	 sub	 rax, rcx
  00153	48 8d 04 80	 lea	 rax, QWORD PTR [rax+rax*4]
  00157	48 3b 47 70	 cmp	 rax, QWORD PTR [rdi+112]
  0015b	7d 12		 jge	 SHORT $LN1@set_differ

; 1558 :         return 0;

  0015d	33 c0		 xor	 eax, eax
  0015f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 1560 : }

  00164	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00169	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016d	5f		 pop	 rdi
  0016e	c3		 ret	 0
$LN1@set_differ:

; 1559 :     return set_table_resize(so, so->used>50000 ? so->used*2 : so->used*4);

  0016f	48 8d 14 09	 lea	 rdx, QWORD PTR [rcx+rcx]
  00173	48 81 f9 50 c3
	00 00		 cmp	 rcx, 50000		; 0000c350H
  0017a	7f 08		 jg	 SHORT $LN17@set_differ
  0017c	48 8d 14 8d 00
	00 00 00	 lea	 rdx, QWORD PTR [rcx*4]
$LN17@set_differ:
  00184	48 8b cf	 mov	 rcx, rdi
  00187	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 1560 : }

  0018c	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00191	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00195	5f		 pop	 rdi
  00196	e9 00 00 00 00	 jmp	 set_table_resize
set_difference_update_internal ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_difference_update DD imagerel set_difference_update
	DD	imagerel set_difference_update+178
	DD	imagerel $unwind$set_difference_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_difference_update DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_difference_update
_TEXT	SEGMENT
so$ = 64
args$ = 72
set_difference_update PROC				; COMDAT

; 1564 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1565 :     Py_ssize_t i;
; 1566 : 
; 1567 :     for (i=0 ; i<PyTuple_GET_SIZE(args) ; i++) {

  00014	33 db		 xor	 ebx, ebx
  00016	48 8b f2	 mov	 rsi, rdx
  00019	48 8b e9	 mov	 rbp, rcx
  0001c	48 39 5a 60	 cmp	 QWORD PTR [rdx+96], rbx
  00020	7e 2b		 jle	 SHORT $LN2@set_differ@2
  00022	48 8d 7a 70	 lea	 rdi, QWORD PTR [rdx+112]
  00026	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@set_differ@2:

; 1568 :         PyObject *other = PyTuple_GET_ITEM(args, i);
; 1569 :         if (set_difference_update_internal(so, other) == -1)

  00030	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00033	48 8b cd	 mov	 rcx, rbp
  00036	e8 00 00 00 00	 call	 set_difference_update_internal
  0003b	83 f8 ff	 cmp	 eax, -1
  0003e	74 6e		 je	 SHORT $LN12@set_differ@2

; 1565 :     Py_ssize_t i;
; 1566 : 
; 1567 :     for (i=0 ; i<PyTuple_GET_SIZE(args) ; i++) {

  00040	48 ff c3	 inc	 rbx
  00043	48 83 c7 08	 add	 rdi, 8
  00047	48 3b 5e 60	 cmp	 rbx, QWORD PTR [rsi+96]
  0004b	7c e3		 jl	 SHORT $LL4@set_differ@2
$LN2@set_differ@2:

; 1571 :     }
; 1572 :     Py_RETURN_NONE;

  0004d	e8 00 00 00 00	 call	 _Py_PXCTX
  00052	85 c0		 test	 eax, eax
  00054	75 3c		 jne	 SHORT $LN8@set_differ@2
  00056	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0006b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00071	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00079	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007e	85 c0		 test	 eax, eax
  00080	75 09		 jne	 SHORT $LN7@set_differ@2
  00082	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00089	74 07		 je	 SHORT $LN8@set_differ@2
$LN7@set_differ@2:
  0008b	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN8@set_differ@2:
  00092	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN5@set_differ@2:

; 1573 : }

  00099	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009e	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000a3	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000a8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ac	5f		 pop	 rdi
  000ad	c3		 ret	 0
$LN12@set_differ@2:

; 1570 :             return NULL;

  000ae	33 c0		 xor	 eax, eax
  000b0	eb e7		 jmp	 SHORT $LN5@set_differ@2
set_difference_update ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_copy_and_difference DD imagerel set_copy_and_difference
	DD	imagerel set_copy_and_difference+77
	DD	imagerel $unwind$set_copy_and_difference
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_copy_and_difference DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_copy_and_difference
_TEXT	SEGMENT
so$ = 48
other$ = 56
set_copy_and_difference PROC				; COMDAT

; 1580 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx

; 1581 :     PyObject *result;
; 1582 : 
; 1583 :     result = set_copy(so);

  0000d	e8 00 00 00 00	 call	 set_copy
  00012	48 8b d8	 mov	 rbx, rax

; 1584 :     if (result == NULL)

  00015	48 85 c0	 test	 rax, rax

; 1585 :         return NULL;

  00018	74 26		 je	 SHORT $LN5@set_copy_a

; 1586 :     if (set_difference_update_internal((PySetObject *) result, other) != -1)

  0001a	48 8b d7	 mov	 rdx, rdi
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 set_difference_update_internal
  00025	83 f8 ff	 cmp	 eax, -1
  00028	74 0e		 je	 SHORT $LN1@set_copy_a

; 1587 :         return result;

  0002a	48 8b c3	 mov	 rax, rbx

; 1590 : }

  0002d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
$LN1@set_copy_a:

; 1588 :     Py_DECREF(result);

  00038	48 8b cb	 mov	 rcx, rbx
  0003b	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@set_copy_a:

; 1589 :     return NULL;

  00040	33 c0		 xor	 eax, eax

; 1590 : }

  00042	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
set_copy_and_difference ENDP
_TEXT	ENDS
EXTRN	_PyDict_Contains:PROC
EXTRN	PyObject_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_difference DD imagerel set_difference
	DD	imagerel set_difference+433
	DD	imagerel $unwind$set_difference
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_difference DD 060c01H
	DD	0a340cH
	DD	07008520cH
	DD	050066007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_difference
_TEXT	SEGMENT
entrycopy$21609 = 32
so$ = 80
entry$ = 88
other$ = 88
pos$ = 96
set_difference PROC					; COMDAT

; 1594 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000c	48 8b e9	 mov	 rbp, rcx

; 1595 :     PyObject *result;
; 1596 :     setentry *entry;
; 1597 :     Py_ssize_t pos = 0;
; 1598 : 
; 1599 :     if (!PyAnySet_Check(other)  && !PyDict_CheckExact(other)) {

  0000f	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00013	48 8b f2	 mov	 rsi, rdx
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0001d	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR pos$[rsp], 0
  00026	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:PyDict_Type
  0002d	48 3b ca	 cmp	 rcx, rdx
  00030	74 48		 je	 SHORT $LN14@set_differ@3
  00032	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:PyFrozenSet_Type
  00039	48 3b cb	 cmp	 rcx, rbx
  0003c	74 3c		 je	 SHORT $LN14@set_differ@3
  0003e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00043	85 c0		 test	 eax, eax
  00045	75 33		 jne	 SHORT $LN14@set_differ@3
  00047	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  0004b	48 8b d3	 mov	 rdx, rbx
  0004e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00053	85 c0		 test	 eax, eax
  00055	75 23		 jne	 SHORT $LN14@set_differ@3
  00057	48 39 7e 58	 cmp	 QWORD PTR [rsi+88], rdi
  0005b	74 1d		 je	 SHORT $LN14@set_differ@3
  0005d	48 39 7e 38	 cmp	 QWORD PTR [rsi+56], rdi
  00061	74 17		 je	 SHORT $LN14@set_differ@3
$LN24@set_differ@3:

; 1600 :         return set_copy_and_difference(so, other);

  00063	48 8b d6	 mov	 rdx, rsi
  00066	48 8b cd	 mov	 rcx, rbp

; 1637 :                 Py_DECREF(result);
; 1638 :                 return NULL;
; 1639 :             }
; 1640 :         }
; 1641 :     }
; 1642 :     return result;
; 1643 : }

  00069	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0006e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00072	5f		 pop	 rdi
  00073	5e		 pop	 rsi
  00074	5d		 pop	 rbp
  00075	e9 00 00 00 00	 jmp	 set_copy_and_difference
$LN14@set_differ@3:

; 1601 :     }
; 1602 : 
; 1603 :     /* If len(so) much more than len(other), it's more efficient to simply copy
; 1604 :      * so and then iterate other looking for common elements. */
; 1605 :     if ((PySet_GET_SIZE(so) >> 2) > PyObject_Size(other)) {

  0007a	48 8b ce	 mov	 rcx, rsi
  0007d	e8 00 00 00 00	 call	 PyObject_Size
  00082	48 8b 4d 68	 mov	 rcx, QWORD PTR [rbp+104]
  00086	48 c1 f9 02	 sar	 rcx, 2
  0008a	48 3b c8	 cmp	 rcx, rax

; 1606 :         return set_copy_and_difference(so, other);

  0008d	7f d4		 jg	 SHORT $LN24@set_differ@3

; 1607 :     }
; 1608 : 
; 1609 :     result = make_new_set_basetype(Py_TYPE(so), NULL);

  0008f	48 8b 4d 58	 mov	 rcx, QWORD PTR [rbp+88]
  00093	33 d2		 xor	 edx, edx
  00095	e8 00 00 00 00	 call	 make_new_set_basetype
  0009a	48 8b d8	 mov	 rbx, rax

; 1610 :     if (result == NULL)

  0009d	48 85 c0	 test	 rax, rax

; 1611 :         return NULL;

  000a0	0f 84 fc 00 00
	00		 je	 $LN25@set_differ@3

; 1612 : 
; 1613 :     if (PyDict_CheckExact(other)) {

  000a6	48 39 7e 58	 cmp	 QWORD PTR [rsi+88], rdi
  000aa	74 7b		 je	 SHORT $LN18@set_differ@3
  000ac	48 39 7e 38	 cmp	 QWORD PTR [rsi+56], rdi
  000b0	74 75		 je	 SHORT $LN18@set_differ@3

; 1626 :     }
; 1627 : 
; 1628 :     /* Iterate over so, checking for common elements in other. */
; 1629 :     while (set_next(so, &pos, &entry)) {

  000b2	4c 8d 44 24 58	 lea	 r8, QWORD PTR entry$[rsp]
  000b7	48 8d 54 24 60	 lea	 rdx, QWORD PTR pos$[rsp]
  000bc	48 8b cd	 mov	 rcx, rbp
  000bf	e8 00 00 00 00	 call	 set_next
  000c4	85 c0		 test	 eax, eax
  000c6	74 4f		 je	 SHORT $LN23@set_differ@3
  000c8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@set_differ@3:

; 1630 :         int rv = set_contains_entry((PySetObject *)other, entry);

  000d0	48 8b 7c 24 58	 mov	 rdi, QWORD PTR entry$[rsp]
  000d5	48 8b ce	 mov	 rcx, rsi
  000d8	48 8b d7	 mov	 rdx, rdi
  000db	e8 00 00 00 00	 call	 set_contains_entry

; 1631 :         if (rv == -1) {

  000e0	83 f8 ff	 cmp	 eax, -1
  000e3	0f 84 b1 00 00
	00		 je	 $LN21@set_differ@3

; 1632 :             Py_DECREF(result);
; 1633 :             return NULL;
; 1634 :         }
; 1635 :         if (!rv) {

  000e9	85 c0		 test	 eax, eax
  000eb	75 14		 jne	 SHORT $LN1@set_differ@3

; 1636 :             if (set_add_entry((PySetObject *)result, entry) == -1) {

  000ed	48 8b d7	 mov	 rdx, rdi
  000f0	48 8b cb	 mov	 rcx, rbx
  000f3	e8 00 00 00 00	 call	 set_add_entry
  000f8	83 f8 ff	 cmp	 eax, -1
  000fb	0f 84 99 00 00
	00		 je	 $LN21@set_differ@3
$LN1@set_differ@3:

; 1626 :     }
; 1627 : 
; 1628 :     /* Iterate over so, checking for common elements in other. */
; 1629 :     while (set_next(so, &pos, &entry)) {

  00101	4c 8d 44 24 58	 lea	 r8, QWORD PTR entry$[rsp]
  00106	48 8d 54 24 60	 lea	 rdx, QWORD PTR pos$[rsp]
  0010b	48 8b cd	 mov	 rcx, rbp
  0010e	e8 00 00 00 00	 call	 set_next
  00113	85 c0		 test	 eax, eax
  00115	75 b9		 jne	 SHORT $LL5@set_differ@3
$LN23@set_differ@3:

; 1622 :                 }
; 1623 :             }
; 1624 :         }
; 1625 :         return result;

  00117	48 8b c3	 mov	 rax, rbx

; 1637 :                 Py_DECREF(result);
; 1638 :                 return NULL;
; 1639 :             }
; 1640 :         }
; 1641 :     }
; 1642 :     return result;
; 1643 : }

  0011a	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0011f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00123	5f		 pop	 rdi
  00124	5e		 pop	 rsi
  00125	5d		 pop	 rbp
  00126	c3		 ret	 0
$LN18@set_differ@3:

; 1614 :         while (set_next(so, &pos, &entry)) {

  00127	4c 8d 44 24 58	 lea	 r8, QWORD PTR entry$[rsp]
  0012c	48 8d 54 24 60	 lea	 rdx, QWORD PTR pos$[rsp]
  00131	48 8b cd	 mov	 rcx, rbp
  00134	e8 00 00 00 00	 call	 set_next
  00139	85 c0		 test	 eax, eax
  0013b	74 da		 je	 SHORT $LN23@set_differ@3
  0013d	0f 1f 00	 npad	 3
$LL9@set_differ@3:

; 1615 :             setentry entrycopy;
; 1616 :             entrycopy.hash = entry->hash;

  00140	48 8b 44 24 58	 mov	 rax, QWORD PTR entry$[rsp]

; 1617 :             entrycopy.key = entry->key;
; 1618 :             if (!_PyDict_Contains(other, entry->key, entry->hash)) {

  00145	48 8b ce	 mov	 rcx, rsi
  00148	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  0014b	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0014f	4c 89 44 24 20	 mov	 QWORD PTR entrycopy$21609[rsp], r8
  00154	48 89 54 24 28	 mov	 QWORD PTR entrycopy$21609[rsp+8], rdx
  00159	e8 00 00 00 00	 call	 _PyDict_Contains
  0015e	85 c0		 test	 eax, eax
  00160	75 12		 jne	 SHORT $LN6@set_differ@3

; 1619 :                 if (set_add_entry((PySetObject *)result, &entrycopy) == -1) {

  00162	48 8d 54 24 20	 lea	 rdx, QWORD PTR entrycopy$21609[rsp]
  00167	48 8b cb	 mov	 rcx, rbx
  0016a	e8 00 00 00 00	 call	 set_add_entry
  0016f	83 f8 ff	 cmp	 eax, -1
  00172	74 26		 je	 SHORT $LN21@set_differ@3
$LN6@set_differ@3:

; 1614 :         while (set_next(so, &pos, &entry)) {

  00174	4c 8d 44 24 58	 lea	 r8, QWORD PTR entry$[rsp]
  00179	48 8d 54 24 60	 lea	 rdx, QWORD PTR pos$[rsp]
  0017e	48 8b cd	 mov	 rcx, rbp
  00181	e8 00 00 00 00	 call	 set_next
  00186	85 c0		 test	 eax, eax
  00188	75 b6		 jne	 SHORT $LL9@set_differ@3

; 1622 :                 }
; 1623 :             }
; 1624 :         }
; 1625 :         return result;

  0018a	48 8b c3	 mov	 rax, rbx

; 1637 :                 Py_DECREF(result);
; 1638 :                 return NULL;
; 1639 :             }
; 1640 :         }
; 1641 :     }
; 1642 :     return result;
; 1643 : }

  0018d	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00192	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00196	5f		 pop	 rdi
  00197	5e		 pop	 rsi
  00198	5d		 pop	 rbp
  00199	c3		 ret	 0
$LN21@set_differ@3:

; 1620 :                     Py_DECREF(result);

  0019a	48 8b cb	 mov	 rcx, rbx
  0019d	e8 00 00 00 00	 call	 _Py_DecRef
$LN25@set_differ@3:

; 1621 :                     return NULL;

  001a2	33 c0		 xor	 eax, eax

; 1637 :                 Py_DECREF(result);
; 1638 :                 return NULL;
; 1639 :             }
; 1640 :         }
; 1641 :     }
; 1642 :     return result;
; 1643 : }

  001a4	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001a9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001ad	5f		 pop	 rdi
  001ae	5e		 pop	 rsi
  001af	5d		 pop	 rbp
  001b0	c3		 ret	 0
set_difference ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_difference_multi DD imagerel set_difference_multi
	DD	imagerel set_difference_multi+30
	DD	imagerel $unwind$set_difference_multi
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$set_difference_multi DD imagerel set_difference_multi+30
	DD	imagerel set_difference_multi+59
	DD	imagerel $chain$0$set_difference_multi
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$set_difference_multi DD imagerel set_difference_multi+59
	DD	imagerel set_difference_multi+137
	DD	imagerel $chain$4$set_difference_multi
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$set_difference_multi DD imagerel set_difference_multi+137
	DD	imagerel set_difference_multi+149
	DD	imagerel $chain$6$set_difference_multi
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$set_difference_multi DD 060021H
	DD	087400H
	DD	075400H
	DD	063400H
	DD	imagerel set_difference_multi
	DD	imagerel set_difference_multi+30
	DD	imagerel $unwind$set_difference_multi
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$set_difference_multi DD 060f21H
	DD	08740fH
	DD	063405H
	DD	075400H
	DD	imagerel set_difference_multi
	DD	imagerel set_difference_multi+30
	DD	imagerel $unwind$set_difference_multi
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$set_difference_multi DD 020521H
	DD	075405H
	DD	imagerel set_difference_multi
	DD	imagerel set_difference_multi+30
	DD	imagerel $unwind$set_difference_multi
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_difference_multi DD 020601H
	DD	060023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_difference_multi
_TEXT	SEGMENT
so$ = 48
args$ = 56
set_difference_multi PROC				; COMDAT

; 1647 : {

  00000	40 56		 push	 rsi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1648 :     Py_ssize_t i;
; 1649 :     PyObject *result, *other;
; 1650 : 
; 1651 :     if (PyTuple_GET_SIZE(args) == 0)

  00006	48 83 7a 60 00	 cmp	 QWORD PTR [rdx+96], 0
  0000b	48 8b f2	 mov	 rsi, rdx
  0000e	75 0a		 jne	 SHORT $LN6@set_differ@4

; 1667 : }

  00010	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00014	5e		 pop	 rsi
  00015	e9 00 00 00 00	 jmp	 set_copy
$LN6@set_differ@4:

; 1652 :         return set_copy(so);
; 1653 : 
; 1654 :     other = PyTuple_GET_ITEM(args, 0);
; 1655 :     result = set_difference(so, other);

  0001a	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0001e	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00023	e8 00 00 00 00	 call	 set_difference
  00028	48 8b e8	 mov	 rbp, rax

; 1656 :     if (result == NULL)

  0002b	48 85 c0	 test	 rax, rax
  0002e	75 0b		 jne	 SHORT $LN5@set_differ@4
  00030	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 1667 : }

  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5e		 pop	 rsi
  0003a	c3		 ret	 0
$LN5@set_differ@4:
  0003b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1657 :         return NULL;
; 1658 : 
; 1659 :     for (i=1 ; i<PyTuple_GET_SIZE(args) ; i++) {

  00040	bb 01 00 00 00	 mov	 ebx, 1
  00045	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0004a	48 3b 5e 60	 cmp	 rbx, QWORD PTR [rsi+96]
  0004e	7d 21		 jge	 SHORT $LN2@set_differ@4
  00050	48 8d 7e 78	 lea	 rdi, QWORD PTR [rsi+120]
$LL4@set_differ@4:

; 1660 :         other = PyTuple_GET_ITEM(args, i);
; 1661 :         if (set_difference_update_internal((PySetObject *)result, other) == -1) {

  00054	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00057	48 8b cd	 mov	 rcx, rbp
  0005a	e8 00 00 00 00	 call	 set_difference_update_internal
  0005f	83 f8 ff	 cmp	 eax, -1
  00062	74 25		 je	 SHORT $LN10@set_differ@4

; 1657 :         return NULL;
; 1658 : 
; 1659 :     for (i=1 ; i<PyTuple_GET_SIZE(args) ; i++) {

  00064	48 ff c3	 inc	 rbx
  00067	48 83 c7 08	 add	 rdi, 8
  0006b	48 3b 5e 60	 cmp	 rbx, QWORD PTR [rsi+96]
  0006f	7c e3		 jl	 SHORT $LL4@set_differ@4
$LN2@set_differ@4:

; 1664 :         }
; 1665 :     }
; 1666 :     return result;

  00071	48 8b c5	 mov	 rax, rbp
$LN14@set_differ@4:
  00074	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00079	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  0007e	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 1667 : }

  00083	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00087	5e		 pop	 rsi
  00088	c3		 ret	 0
$LN10@set_differ@4:

; 1662 :             Py_DECREF(result);

  00089	48 8b cd	 mov	 rcx, rbp
  0008c	e8 00 00 00 00	 call	 _Py_DecRef

; 1663 :             return NULL;

  00091	33 c0		 xor	 eax, eax
  00093	eb df		 jmp	 SHORT $LN14@set_differ@4
set_difference_multi ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_sub DD imagerel set_sub
	DD	imagerel set_sub+234
	DD	imagerel $unwind$set_sub
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_sub DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_sub
_TEXT	SEGMENT
so$ = 64
other$ = 72
set_sub	PROC						; COMDAT

; 1675 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f9	 mov	 rdi, rcx

; 1676 :     if (!PyAnySet_Check(so) || !PyAnySet_Check(other))

  00017	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0001b	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PySet_Type
  00022	48 8b da	 mov	 rbx, rdx
  00025	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFrozenSet_Type
  0002c	48 3b cd	 cmp	 rcx, rbp
  0002f	74 21		 je	 SHORT $LN1@set_sub
  00031	48 3b ce	 cmp	 rcx, rsi
  00034	74 1c		 je	 SHORT $LN1@set_sub
  00036	48 8b d5	 mov	 rdx, rbp
  00039	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003e	85 c0		 test	 eax, eax
  00040	75 10		 jne	 SHORT $LN1@set_sub
  00042	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00046	48 8b d6	 mov	 rdx, rsi
  00049	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004e	85 c0		 test	 eax, eax
  00050	74 2a		 je	 SHORT $LN2@set_sub
$LN1@set_sub:
  00052	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00056	48 3b cd	 cmp	 rcx, rbp
  00059	74 6f		 je	 SHORT $LN3@set_sub
  0005b	48 3b ce	 cmp	 rcx, rsi
  0005e	74 6a		 je	 SHORT $LN3@set_sub
  00060	48 8b d5	 mov	 rdx, rbp
  00063	e8 00 00 00 00	 call	 PyType_IsSubtype
  00068	85 c0		 test	 eax, eax
  0006a	75 5e		 jne	 SHORT $LN3@set_sub
  0006c	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00070	48 8b d6	 mov	 rdx, rsi
  00073	e8 00 00 00 00	 call	 PyType_IsSubtype
  00078	85 c0		 test	 eax, eax
  0007a	75 4e		 jne	 SHORT $LN3@set_sub
$LN2@set_sub:

; 1677 :         Py_RETURN_NOTIMPLEMENTED;

  0007c	e8 00 00 00 00	 call	 _Py_PXCTX
  00081	85 c0		 test	 eax, eax
  00083	75 3c		 jne	 SHORT $LN7@set_sub
  00085	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0009a	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ad	85 c0		 test	 eax, eax
  000af	75 09		 jne	 SHORT $LN6@set_sub
  000b1	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  000b8	74 07		 je	 SHORT $LN7@set_sub
$LN6@set_sub:
  000ba	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN7@set_sub:
  000c1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000c8	eb 0b		 jmp	 SHORT $LN4@set_sub
$LN3@set_sub:

; 1678 :     return set_difference(so, other);

  000ca	48 8b d3	 mov	 rdx, rbx
  000cd	48 8b cf	 mov	 rcx, rdi
  000d0	e8 00 00 00 00	 call	 set_difference
$LN4@set_sub:

; 1679 : }

  000d5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000da	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000df	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000e4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e8	5f		 pop	 rdi
  000e9	c3		 ret	 0
set_sub	ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_isub DD imagerel set_isub
	DD	imagerel set_isub+221
	DD	imagerel $unwind$set_isub
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_isub DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_isub
_TEXT	SEGMENT
so$ = 64
other$ = 72
set_isub PROC						; COMDAT

; 1683 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b d9	 mov	 rbx, rcx

; 1684 :     if (!PyAnySet_Check(other))

  00012	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00016	48 8b fa	 mov	 rdi, rdx
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00020	48 3b ca	 cmp	 rcx, rdx
  00023	74 48		 je	 SHORT $LN2@set_isub
  00025	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFrozenSet_Type
  0002c	48 3b ce	 cmp	 rcx, rsi
  0002f	74 3c		 je	 SHORT $LN2@set_isub
  00031	e8 00 00 00 00	 call	 PyType_IsSubtype
  00036	85 c0		 test	 eax, eax
  00038	75 33		 jne	 SHORT $LN2@set_isub
  0003a	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  0003e	48 8b d6	 mov	 rdx, rsi
  00041	e8 00 00 00 00	 call	 PyType_IsSubtype
  00046	85 c0		 test	 eax, eax
  00048	75 23		 jne	 SHORT $LN2@set_isub

; 1685 :         Py_RETURN_NOTIMPLEMENTED;

  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00051	e8 00 00 00 00	 call	 _Py_IncRef
  00056	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 1689 :     return (PyObject *)so;
; 1690 : }

  0005d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00062	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00067	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006b	5f		 pop	 rdi
  0006c	c3		 ret	 0
$LN2@set_isub:

; 1686 :     if (set_difference_update_internal(so, other) == -1)

  0006d	48 8b d7	 mov	 rdx, rdi
  00070	48 8b cb	 mov	 rcx, rbx
  00073	e8 00 00 00 00	 call	 set_difference_update_internal
  00078	83 f8 ff	 cmp	 eax, -1
  0007b	75 12		 jne	 SHORT $LN1@set_isub

; 1687 :         return NULL;

  0007d	33 c0		 xor	 eax, eax

; 1689 :     return (PyObject *)so;
; 1690 : }

  0007f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00084	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00089	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
$LN1@set_isub:

; 1688 :     Py_INCREF(so);

  0008f	e8 00 00 00 00	 call	 _Py_PXCTX
  00094	85 c0		 test	 eax, eax
  00096	75 32		 jne	 SHORT $LN6@set_isub
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000a6	4c 8b cb	 mov	 r9, rbx
  000a9	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000af	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b7	e8 00 00 00 00	 call	 _PyParallel_Guard
  000bc	85 c0		 test	 eax, eax
  000be	75 06		 jne	 SHORT $LN5@set_isub
  000c0	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000c4	74 04		 je	 SHORT $LN6@set_isub
$LN5@set_isub:
  000c6	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@set_isub:

; 1689 :     return (PyObject *)so;
; 1690 : }

  000ca	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000cf	48 8b c3	 mov	 rax, rbx
  000d2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000db	5f		 pop	 rdi
  000dc	c3		 ret	 0
set_isub ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_symmetric_difference_update DD imagerel set_symmetric_difference_update
	DD	imagerel set_symmetric_difference_update+54
	DD	imagerel $unwind$set_symmetric_difference_update
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$set_symmetric_difference_update DD imagerel set_symmetric_difference_update+54
	DD	imagerel set_symmetric_difference_update+160
	DD	imagerel $chain$0$set_symmetric_difference_update
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$set_symmetric_difference_update DD imagerel set_symmetric_difference_update+160
	DD	imagerel set_symmetric_difference_update+300
	DD	imagerel $chain$2$set_symmetric_difference_update
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$set_symmetric_difference_update DD imagerel set_symmetric_difference_update+300
	DD	imagerel set_symmetric_difference_update+693
	DD	imagerel $chain$4$set_symmetric_difference_update
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$set_symmetric_difference_update DD imagerel set_symmetric_difference_update+693
	DD	imagerel set_symmetric_difference_update+717
	DD	imagerel $chain$6$set_symmetric_difference_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$set_symmetric_difference_update DD 020021H
	DD	093400H
	DD	imagerel set_symmetric_difference_update
	DD	imagerel set_symmetric_difference_update+54
	DD	imagerel $unwind$set_symmetric_difference_update
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$set_symmetric_difference_update DD 020021H
	DD	093400H
	DD	imagerel set_symmetric_difference_update
	DD	imagerel set_symmetric_difference_update+54
	DD	imagerel $unwind$set_symmetric_difference_update
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$set_symmetric_difference_update DD 020021H
	DD	093400H
	DD	imagerel set_symmetric_difference_update
	DD	imagerel set_symmetric_difference_update+54
	DD	imagerel $unwind$set_symmetric_difference_update
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$set_symmetric_difference_update DD 020521H
	DD	093405H
	DD	imagerel set_symmetric_difference_update
	DD	imagerel set_symmetric_difference_update+54
	DD	imagerel $unwind$set_symmetric_difference_update
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_symmetric_difference_update DD 040b01H
	DD	07004920bH
	DD	050026003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_symmetric_difference_update
_TEXT	SEGMENT
an_entry$21709 = 48
key$ = 112
so$ = 112
pos$ = 120
other$ = 120
entry$ = 128
hash$21705 = 128
value$21703 = 136
set_symmetric_difference_update PROC			; COMDAT

; 1694 : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 8b ec	 mov	 rbp, rsp
  00007	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000b	48 8b fa	 mov	 rdi, rdx
  0000e	48 8b f1	 mov	 rsi, rcx

; 1695 :     PySetObject *otherset;
; 1696 :     PyObject *key;
; 1697 :     Py_ssize_t pos = 0;

  00011	48 c7 45 28 00
	00 00 00	 mov	 QWORD PTR pos$[rbp-80], 0

; 1698 :     setentry *entry;
; 1699 : 
; 1700 :     if ((PyObject *)so == other)

  00019	48 3b ca	 cmp	 rcx, rdx
  0001c	75 0d		 jne	 SHORT $LN17@set_symmet

; 1701 :         return set_clear(so);

  0001e	e8 00 00 00 00	 call	 set_clear

; 1754 : }

  00023	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00027	5f		 pop	 rdi
  00028	5e		 pop	 rsi
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
$LN17@set_symmet:

; 1702 : 
; 1703 :     if (PyDict_CheckExact(other)) {

  0002b	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  0002f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00036	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  0003b	48 3b c8	 cmp	 rcx, rax
  0003e	0f 84 e8 00 00
	00		 je	 $LN40@set_symmet
  00044	48 39 42 38	 cmp	 QWORD PTR [rdx+56], rax
  00048	0f 84 de 00 00
	00		 je	 $LN40@set_symmet

; 1728 :     }
; 1729 : 
; 1730 :     if (PyAnySet_Check(other)) {

  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00055	48 3b ca	 cmp	 rcx, rdx
  00058	74 46		 je	 SHORT $LN8@set_symmet
  0005a	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:PyFrozenSet_Type
  00061	48 3b cb	 cmp	 rcx, rbx
  00064	74 3a		 je	 SHORT $LN8@set_symmet
  00066	e8 00 00 00 00	 call	 PyType_IsSubtype
  0006b	85 c0		 test	 eax, eax
  0006d	75 31		 jne	 SHORT $LN8@set_symmet
  0006f	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00073	48 8b d3	 mov	 rdx, rbx
  00076	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007b	85 c0		 test	 eax, eax
  0007d	75 21		 jne	 SHORT $LN8@set_symmet

; 1732 :         otherset = (PySetObject *)other;
; 1733 :     } else {
; 1734 :         otherset = (PySetObject *)make_new_set_basetype(Py_TYPE(so), other);

  0007f	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  00083	48 8b d7	 mov	 rdx, rdi
  00086	e8 00 00 00 00	 call	 make_new_set_basetype
  0008b	48 8b f8	 mov	 rdi, rax

; 1735 :         if (otherset == NULL)

  0008e	48 85 c0	 test	 rax, rax
  00091	75 15		 jne	 SHORT $LN39@set_symmet
  00093	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]

; 1754 : }

  00098	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0009c	5f		 pop	 rdi
  0009d	5e		 pop	 rsi
  0009e	5d		 pop	 rbp
  0009f	c3		 ret	 0
$LN8@set_symmet:

; 1731 :         Py_INCREF(other);

  000a0	48 8b cf	 mov	 rcx, rdi
  000a3	e8 00 00 00 00	 call	 _Py_IncRef
$LN39@set_symmet:

; 1736 :             return NULL;
; 1737 :     }
; 1738 : 
; 1739 :     while (set_next(otherset, &pos, &entry)) {

  000a8	4c 8d 45 30	 lea	 r8, QWORD PTR entry$[rbp-80]
  000ac	48 8d 55 28	 lea	 rdx, QWORD PTR pos$[rbp-80]
  000b0	48 8b cf	 mov	 rcx, rdi
  000b3	e8 00 00 00 00	 call	 set_next
  000b8	85 c0		 test	 eax, eax
  000ba	74 40		 je	 SHORT $LN4@set_symmet
  000bc	0f 1f 40 00	 npad	 4
$LL5@set_symmet:

; 1740 :         int rv = set_discard_entry(so, entry);

  000c0	48 8b 5d 30	 mov	 rbx, QWORD PTR entry$[rbp-80]
  000c4	48 8b ce	 mov	 rcx, rsi
  000c7	48 8b d3	 mov	 rdx, rbx
  000ca	e8 00 00 00 00	 call	 set_discard_entry

; 1741 :         if (rv == -1) {

  000cf	83 f8 ff	 cmp	 eax, -1
  000d2	74 41		 je	 SHORT $LN41@set_symmet

; 1744 :         }
; 1745 :         if (rv == DISCARD_NOTFOUND) {

  000d4	85 c0		 test	 eax, eax
  000d6	75 10		 jne	 SHORT $LN1@set_symmet

; 1746 :             if (set_add_entry(so, entry) == -1) {

  000d8	48 8b d3	 mov	 rdx, rbx
  000db	48 8b ce	 mov	 rcx, rsi
  000de	e8 00 00 00 00	 call	 set_add_entry
  000e3	83 f8 ff	 cmp	 eax, -1
  000e6	74 2d		 je	 SHORT $LN41@set_symmet
$LN1@set_symmet:

; 1736 :             return NULL;
; 1737 :     }
; 1738 : 
; 1739 :     while (set_next(otherset, &pos, &entry)) {

  000e8	4c 8d 45 30	 lea	 r8, QWORD PTR entry$[rbp-80]
  000ec	48 8d 55 28	 lea	 rdx, QWORD PTR pos$[rbp-80]
  000f0	48 8b cf	 mov	 rcx, rdi
  000f3	e8 00 00 00 00	 call	 set_next
  000f8	85 c0		 test	 eax, eax
  000fa	75 c4		 jne	 SHORT $LL5@set_symmet
$LN4@set_symmet:

; 1747 :                 Py_DECREF(otherset);
; 1748 :                 return NULL;
; 1749 :             }
; 1750 :         }
; 1751 :     }
; 1752 :     Py_DECREF(otherset);

  000fc	48 8b cf	 mov	 rcx, rdi
  000ff	e8 00 00 00 00	 call	 _Py_DecRef

; 1753 :     Py_RETURN_NONE;

  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0010b	e8 00 00 00 00	 call	 _Py_IncRef
  00110	e9 8c 01 00 00	 jmp	 $LN36@set_symmet
$LN41@set_symmet:

; 1742 :             Py_DECREF(otherset);

  00115	48 8b cf	 mov	 rcx, rdi
  00118	e8 00 00 00 00	 call	 _Py_DecRef
  0011d	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]

; 1743 :             return NULL;

  00122	33 c0		 xor	 eax, eax

; 1754 : }

  00124	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00128	5f		 pop	 rdi
  00129	5e		 pop	 rsi
  0012a	5d		 pop	 rbp
  0012b	c3		 ret	 0
$LN40@set_symmet:

; 1704 :         PyObject *value;
; 1705 :         int rv;
; 1706 :         Py_hash_t hash;
; 1707 :         while (_PyDict_Next(other, &pos, &key, &value, &hash)) {

  0012c	48 8d 45 30	 lea	 rax, QWORD PTR hash$21705[rbp-80]
  00130	4c 8d 4d 38	 lea	 r9, QWORD PTR value$21703[rbp-80]
  00134	4c 8d 45 20	 lea	 r8, QWORD PTR key$[rbp-80]
  00138	48 8d 55 28	 lea	 rdx, QWORD PTR pos$[rbp-80]
  0013c	48 8b cf	 mov	 rcx, rdi
  0013f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00144	e8 00 00 00 00	 call	 _PyDict_Next
  00149	85 c0		 test	 eax, eax
  0014b	0f 84 0b 01 00
	00		 je	 $LN13@set_symmet
$LL14@set_symmet:

; 1708 :             setentry an_entry;
; 1709 : 
; 1710 :             Py_INCREF(key);

  00151	48 8b 5d 20	 mov	 rbx, QWORD PTR key$[rbp-80]
  00155	e8 00 00 00 00	 call	 _Py_PXCTX
  0015a	85 c0		 test	 eax, eax
  0015c	75 32		 jne	 SHORT $LN21@set_symmet
  0015e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0016c	4c 8b cb	 mov	 r9, rbx
  0016f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00175	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0017d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00182	85 c0		 test	 eax, eax
  00184	75 06		 jne	 SHORT $LN20@set_symmet
  00186	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0018a	74 04		 je	 SHORT $LN21@set_symmet
$LN20@set_symmet:
  0018c	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN21@set_symmet:

; 1711 :             an_entry.hash = hash;

  00190	48 8b 45 30	 mov	 rax, QWORD PTR hash$21705[rbp-80]

; 1712 :             an_entry.key = key;
; 1713 : 
; 1714 :             rv = set_discard_entry(so, &an_entry);

  00194	48 8d 55 e0	 lea	 rdx, QWORD PTR an_entry$21709[rbp-80]
  00198	48 8b ce	 mov	 rcx, rsi
  0019b	48 89 45 e0	 mov	 QWORD PTR an_entry$21709[rbp-80], rax
  0019f	48 8b 45 20	 mov	 rax, QWORD PTR key$[rbp-80]
  001a3	48 89 45 e8	 mov	 QWORD PTR an_entry$21709[rbp-72], rax
  001a7	e8 00 00 00 00	 call	 set_discard_entry

; 1715 :             if (rv == -1) {

  001ac	83 f8 ff	 cmp	 eax, -1
  001af	0f 84 00 01 00
	00		 je	 $LN43@set_symmet

; 1718 :             }
; 1719 :             if (rv == DISCARD_NOTFOUND) {

  001b5	85 c0		 test	 eax, eax
  001b7	75 15		 jne	 SHORT $LN10@set_symmet

; 1720 :                 if (set_add_entry(so, &an_entry) == -1) {

  001b9	48 8d 55 e0	 lea	 rdx, QWORD PTR an_entry$21709[rbp-80]
  001bd	48 8b ce	 mov	 rcx, rsi
  001c0	e8 00 00 00 00	 call	 set_add_entry
  001c5	83 f8 ff	 cmp	 eax, -1
  001c8	0f 84 e7 00 00
	00		 je	 $LN43@set_symmet
$LN10@set_symmet:

; 1721 :                     Py_DECREF(key);
; 1722 :                     return NULL;
; 1723 :                 }
; 1724 :             }
; 1725 :             Py_DECREF(key);

  001ce	48 8b 5d 20	 mov	 rbx, QWORD PTR key$[rbp-80]
  001d2	e8 00 00 00 00	 call	 _Py_PXCTX
  001d7	85 c0		 test	 eax, eax
  001d9	75 5c		 jne	 SHORT $LN34@set_symmet
  001db	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001df	a8 20		 test	 al, 32			; 00000020H
  001e1	75 4c		 jne	 SHORT $LN28@set_symmet
  001e3	84 c0		 test	 al, al
  001e5	78 48		 js	 SHORT $LN28@set_symmet
  001e7	a8 02		 test	 al, 2
  001e9	75 4c		 jne	 SHORT $LN34@set_symmet
  001eb	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001ef	75 46		 jne	 SHORT $LN34@set_symmet
  001f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001ff	4c 8b cb	 mov	 r9, rbx
  00202	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00208	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00210	e8 00 00 00 00	 call	 _PyParallel_Guard
  00215	48 8b cb	 mov	 rcx, rbx
  00218	85 c0		 test	 eax, eax
  0021a	74 07		 je	 SHORT $LN33@set_symmet
  0021c	e8 00 00 00 00	 call	 _Px_Dealloc
  00221	eb 14		 jmp	 SHORT $LN34@set_symmet
$LN33@set_symmet:
  00223	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00227	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0022d	eb 08		 jmp	 SHORT $LN34@set_symmet
$LN28@set_symmet:
  0022f	48 8b cb	 mov	 rcx, rbx
  00232	e8 00 00 00 00	 call	 Px_DecRef
$LN34@set_symmet:

; 1704 :         PyObject *value;
; 1705 :         int rv;
; 1706 :         Py_hash_t hash;
; 1707 :         while (_PyDict_Next(other, &pos, &key, &value, &hash)) {

  00237	48 8d 45 30	 lea	 rax, QWORD PTR hash$21705[rbp-80]
  0023b	4c 8d 4d 38	 lea	 r9, QWORD PTR value$21703[rbp-80]
  0023f	4c 8d 45 20	 lea	 r8, QWORD PTR key$[rbp-80]
  00243	48 8d 55 28	 lea	 rdx, QWORD PTR pos$[rbp-80]
  00247	48 8b cf	 mov	 rcx, rdi
  0024a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0024f	e8 00 00 00 00	 call	 _PyDict_Next
  00254	85 c0		 test	 eax, eax
  00256	0f 85 f5 fe ff
	ff		 jne	 $LL14@set_symmet
$LN13@set_symmet:

; 1726 :         }
; 1727 :         Py_RETURN_NONE;

  0025c	e8 00 00 00 00	 call	 _Py_PXCTX
  00261	85 c0		 test	 eax, eax
  00263	75 3c		 jne	 SHORT $LN36@set_symmet
  00265	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0026c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00273	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0027a	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00280	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00288	e8 00 00 00 00	 call	 _PyParallel_Guard
  0028d	85 c0		 test	 eax, eax
  0028f	75 09		 jne	 SHORT $LN35@set_symmet
  00291	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00298	74 07		 je	 SHORT $LN36@set_symmet
$LN35@set_symmet:
  0029a	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN36@set_symmet:
  002a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  002a8	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]

; 1754 : }

  002ad	48 83 c4 50	 add	 rsp, 80			; 00000050H
  002b1	5f		 pop	 rdi
  002b2	5e		 pop	 rsi
  002b3	5d		 pop	 rbp
  002b4	c3		 ret	 0
$LN43@set_symmet:

; 1716 :                 Py_DECREF(key);

  002b5	48 8b 4d 20	 mov	 rcx, QWORD PTR key$[rbp-80]
  002b9	e8 00 00 00 00	 call	 _Py_DecRef
  002be	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]

; 1717 :                 return NULL;

  002c3	33 c0		 xor	 eax, eax

; 1754 : }

  002c5	48 83 c4 50	 add	 rsp, 80			; 00000050H
  002c9	5f		 pop	 rdi
  002ca	5e		 pop	 rsi
  002cb	5d		 pop	 rbp
  002cc	c3		 ret	 0
set_symmetric_difference_update ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_symmetric_difference DD imagerel set_symmetric_difference
	DD	imagerel set_symmetric_difference+81
	DD	imagerel $unwind$set_symmetric_difference
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_symmetric_difference DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_symmetric_difference
_TEXT	SEGMENT
so$ = 48
other$ = 56
set_symmetric_difference PROC				; COMDAT

; 1761 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 1762 :     PyObject *rv;
; 1763 :     PySetObject *otherset;
; 1764 : 
; 1765 :     otherset = (PySetObject *)make_new_set_basetype(Py_TYPE(so), other);

  0000d	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00011	e8 00 00 00 00	 call	 make_new_set_basetype
  00016	48 8b d8	 mov	 rbx, rax

; 1766 :     if (otherset == NULL)

  00019	48 85 c0	 test	 rax, rax
  0001c	75 0d		 jne	 SHORT $LN2@set_symmet@2
$LN5@set_symmet@2:

; 1767 :         return NULL;

  0001e	33 c0		 xor	 eax, eax

; 1773 : }

  00020	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN2@set_symmet@2:

; 1768 :     rv = set_symmetric_difference_update(otherset, (PyObject *)so);

  0002b	48 8b d7	 mov	 rdx, rdi
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 set_symmetric_difference_update

; 1769 :     if (rv == NULL)

  00036	48 85 c0	 test	 rax, rax

; 1770 :         return NULL;

  00039	74 e3		 je	 SHORT $LN5@set_symmet@2

; 1771 :     Py_DECREF(rv);

  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 _Py_DecRef

; 1772 :     return (PyObject *)otherset;

  00043	48 8b c3	 mov	 rax, rbx

; 1773 : }

  00046	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
set_symmetric_difference ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_xor DD imagerel set_xor
	DD	imagerel set_xor+234
	DD	imagerel $unwind$set_xor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_xor DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_xor
_TEXT	SEGMENT
so$ = 64
other$ = 72
set_xor	PROC						; COMDAT

; 1782 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f9	 mov	 rdi, rcx

; 1783 :     if (!PyAnySet_Check(so) || !PyAnySet_Check(other))

  00017	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0001b	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PySet_Type
  00022	48 8b da	 mov	 rbx, rdx
  00025	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFrozenSet_Type
  0002c	48 3b cd	 cmp	 rcx, rbp
  0002f	74 21		 je	 SHORT $LN1@set_xor
  00031	48 3b ce	 cmp	 rcx, rsi
  00034	74 1c		 je	 SHORT $LN1@set_xor
  00036	48 8b d5	 mov	 rdx, rbp
  00039	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003e	85 c0		 test	 eax, eax
  00040	75 10		 jne	 SHORT $LN1@set_xor
  00042	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00046	48 8b d6	 mov	 rdx, rsi
  00049	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004e	85 c0		 test	 eax, eax
  00050	74 2a		 je	 SHORT $LN2@set_xor
$LN1@set_xor:
  00052	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00056	48 3b cd	 cmp	 rcx, rbp
  00059	74 6f		 je	 SHORT $LN3@set_xor
  0005b	48 3b ce	 cmp	 rcx, rsi
  0005e	74 6a		 je	 SHORT $LN3@set_xor
  00060	48 8b d5	 mov	 rdx, rbp
  00063	e8 00 00 00 00	 call	 PyType_IsSubtype
  00068	85 c0		 test	 eax, eax
  0006a	75 5e		 jne	 SHORT $LN3@set_xor
  0006c	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00070	48 8b d6	 mov	 rdx, rsi
  00073	e8 00 00 00 00	 call	 PyType_IsSubtype
  00078	85 c0		 test	 eax, eax
  0007a	75 4e		 jne	 SHORT $LN3@set_xor
$LN2@set_xor:

; 1784 :         Py_RETURN_NOTIMPLEMENTED;

  0007c	e8 00 00 00 00	 call	 _Py_PXCTX
  00081	85 c0		 test	 eax, eax
  00083	75 3c		 jne	 SHORT $LN7@set_xor
  00085	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0009a	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ad	85 c0		 test	 eax, eax
  000af	75 09		 jne	 SHORT $LN6@set_xor
  000b1	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  000b8	74 07		 je	 SHORT $LN7@set_xor
$LN6@set_xor:
  000ba	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN7@set_xor:
  000c1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000c8	eb 0b		 jmp	 SHORT $LN4@set_xor
$LN3@set_xor:

; 1785 :     return set_symmetric_difference(so, other);

  000ca	48 8b d3	 mov	 rdx, rbx
  000cd	48 8b cf	 mov	 rcx, rdi
  000d0	e8 00 00 00 00	 call	 set_symmetric_difference
$LN4@set_xor:

; 1786 : }

  000d5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000da	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000df	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000e4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e8	5f		 pop	 rdi
  000e9	c3		 ret	 0
set_xor	ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_ixor DD imagerel set_ixor
	DD	imagerel set_ixor+227
	DD	imagerel $unwind$set_ixor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_ixor DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_ixor
_TEXT	SEGMENT
so$ = 64
other$ = 72
set_ixor PROC						; COMDAT

; 1790 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b d9	 mov	 rbx, rcx

; 1791 :     PyObject *result;
; 1792 : 
; 1793 :     if (!PyAnySet_Check(other))

  00012	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00016	48 8b fa	 mov	 rdi, rdx
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00020	48 3b ca	 cmp	 rcx, rdx
  00023	74 48		 je	 SHORT $LN2@set_ixor
  00025	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFrozenSet_Type
  0002c	48 3b ce	 cmp	 rcx, rsi
  0002f	74 3c		 je	 SHORT $LN2@set_ixor
  00031	e8 00 00 00 00	 call	 PyType_IsSubtype
  00036	85 c0		 test	 eax, eax
  00038	75 33		 jne	 SHORT $LN2@set_ixor
  0003a	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  0003e	48 8b d6	 mov	 rdx, rsi
  00041	e8 00 00 00 00	 call	 PyType_IsSubtype
  00046	85 c0		 test	 eax, eax
  00048	75 23		 jne	 SHORT $LN2@set_ixor

; 1794 :         Py_RETURN_NOTIMPLEMENTED;

  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00051	e8 00 00 00 00	 call	 _Py_IncRef
  00056	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 1800 :     return (PyObject *)so;
; 1801 : }

  0005d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00062	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00067	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006b	5f		 pop	 rdi
  0006c	c3		 ret	 0
$LN2@set_ixor:

; 1795 :     result = set_symmetric_difference_update(so, other);

  0006d	48 8b d7	 mov	 rdx, rdi
  00070	48 8b cb	 mov	 rcx, rbx
  00073	e8 00 00 00 00	 call	 set_symmetric_difference_update

; 1796 :     if (result == NULL)

  00078	48 85 c0	 test	 rax, rax
  0007b	75 10		 jne	 SHORT $LN1@set_ixor

; 1800 :     return (PyObject *)so;
; 1801 : }

  0007d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00082	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00087	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
$LN1@set_ixor:

; 1797 :         return NULL;
; 1798 :     Py_DECREF(result);

  0008d	48 8b c8	 mov	 rcx, rax
  00090	e8 00 00 00 00	 call	 _Py_DecRef

; 1799 :     Py_INCREF(so);

  00095	e8 00 00 00 00	 call	 _Py_PXCTX
  0009a	85 c0		 test	 eax, eax
  0009c	75 32		 jne	 SHORT $LN6@set_ixor
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000ac	4c 8b cb	 mov	 r9, rbx
  000af	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000b5	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000bd	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c2	85 c0		 test	 eax, eax
  000c4	75 06		 jne	 SHORT $LN5@set_ixor
  000c6	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000ca	74 04		 je	 SHORT $LN6@set_ixor
$LN5@set_ixor:
  000cc	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@set_ixor:

; 1800 :     return (PyObject *)so;
; 1801 : }

  000d0	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000d5	48 8b c3	 mov	 rax, rbx
  000d8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000dd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e1	5f		 pop	 rdi
  000e2	c3		 ret	 0
set_ixor ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_issubset DD imagerel set_issubset
	DD	imagerel set_issubset+514
	DD	imagerel $unwind$set_issubset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_issubset DD 060c01H
	DD	0a340cH
	DD	07008520cH
	DD	050066007H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_issubset
_TEXT	SEGMENT
so$ = 80
entry$ = 88
other$ = 88
pos$ = 96
set_issubset PROC					; COMDAT

; 1805 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000c	48 8b f9	 mov	 rdi, rcx

; 1806 :     setentry *entry;
; 1807 :     Py_ssize_t pos = 0;
; 1808 : 
; 1809 :     if (!PyAnySet_Check(other)) {

  0000f	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00013	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PySet_Type
  0001a	48 8b da	 mov	 rbx, rdx
  0001d	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR pos$[rsp], 0
  00026	48 3b ce	 cmp	 rcx, rsi
  00029	74 70		 je	 SHORT $LN7@set_issubs
  0002b	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PyFrozenSet_Type
  00032	48 3b cd	 cmp	 rcx, rbp
  00035	74 64		 je	 SHORT $LN7@set_issubs
  00037	48 8b d6	 mov	 rdx, rsi
  0003a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003f	85 c0		 test	 eax, eax
  00041	75 58		 jne	 SHORT $LN7@set_issubs
  00043	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00047	48 8b d5	 mov	 rdx, rbp
  0004a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004f	85 c0		 test	 eax, eax
  00051	75 48		 jne	 SHORT $LN7@set_issubs

; 1810 :         PyObject *tmp, *result;
; 1811 :         tmp = make_new_set(&PySet_Type, other);

  00053	48 8b d3	 mov	 rdx, rbx
  00056	48 8b ce	 mov	 rcx, rsi
  00059	e8 00 00 00 00	 call	 make_new_set
  0005e	48 8b f0	 mov	 rsi, rax

; 1812 :         if (tmp == NULL)

  00061	48 85 c0	 test	 rax, rax
  00064	75 0f		 jne	 SHORT $LN6@set_issubs
$LN23@set_issubs:

; 1813 :             return NULL;

  00066	33 c0		 xor	 eax, eax

; 1829 : }

  00068	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0006d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00071	5f		 pop	 rdi
  00072	5e		 pop	 rsi
  00073	5d		 pop	 rbp
  00074	c3		 ret	 0
$LN6@set_issubs:

; 1814 :         result = set_issubset(so, tmp);

  00075	48 8b d0	 mov	 rdx, rax
  00078	48 8b cf	 mov	 rcx, rdi
  0007b	e8 00 00 00 00	 call	 set_issubset

; 1815 :         Py_DECREF(tmp);

  00080	48 8b ce	 mov	 rcx, rsi
  00083	48 8b d8	 mov	 rbx, rax
  00086	e8 00 00 00 00	 call	 _Py_DecRef

; 1816 :         return result;

  0008b	48 8b c3	 mov	 rax, rbx

; 1829 : }

  0008e	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00093	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00097	5f		 pop	 rdi
  00098	5e		 pop	 rsi
  00099	5d		 pop	 rbp
  0009a	c3		 ret	 0
$LN7@set_issubs:

; 1817 :     }
; 1818 :     if (PySet_GET_SIZE(so) > PySet_GET_SIZE(other))

  0009b	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  0009f	48 39 47 68	 cmp	 QWORD PTR [rdi+104], rax
  000a3	7e 59		 jle	 SHORT $LN22@set_issubs

; 1819 :         Py_RETURN_FALSE;

  000a5	e8 00 00 00 00	 call	 _Py_PXCTX
  000aa	85 c0		 test	 eax, eax
  000ac	75 3c		 jne	 SHORT $LN11@set_issubs
  000ae	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000c3	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000c9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000d1	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d6	85 c0		 test	 eax, eax
  000d8	75 09		 jne	 SHORT $LN10@set_issubs
  000da	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  000e1	74 07		 je	 SHORT $LN11@set_issubs
$LN10@set_issubs:
  000e3	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN11@set_issubs:
  000ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct

; 1829 : }

  000f1	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000f6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fa	5f		 pop	 rdi
  000fb	5e		 pop	 rsi
  000fc	5d		 pop	 rbp
  000fd	c3		 ret	 0
$LN22@set_issubs:

; 1820 : 
; 1821 :     while (set_next(so, &pos, &entry)) {

  000fe	4c 8d 44 24 58	 lea	 r8, QWORD PTR entry$[rsp]
  00103	48 8d 54 24 60	 lea	 rdx, QWORD PTR pos$[rsp]
  00108	48 8b cf	 mov	 rcx, rdi
  0010b	e8 00 00 00 00	 call	 set_next
  00110	85 c0		 test	 eax, eax
  00112	74 3c		 je	 SHORT $LN3@set_issubs
  00114	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@set_issubs:

; 1822 :         int rv = set_contains_entry((PySetObject *)other, entry);

  00120	48 8b 54 24 58	 mov	 rdx, QWORD PTR entry$[rsp]
  00125	48 8b cb	 mov	 rcx, rbx
  00128	e8 00 00 00 00	 call	 set_contains_entry

; 1823 :         if (rv == -1)

  0012d	83 f8 ff	 cmp	 eax, -1
  00130	0f 84 30 ff ff
	ff		 je	 $LN23@set_issubs

; 1824 :             return NULL;
; 1825 :         if (!rv)

  00136	85 c0		 test	 eax, eax
  00138	74 6f		 je	 SHORT $LN24@set_issubs

; 1820 : 
; 1821 :     while (set_next(so, &pos, &entry)) {

  0013a	4c 8d 44 24 58	 lea	 r8, QWORD PTR entry$[rsp]
  0013f	48 8d 54 24 60	 lea	 rdx, QWORD PTR pos$[rsp]
  00144	48 8b cf	 mov	 rcx, rdi
  00147	e8 00 00 00 00	 call	 set_next
  0014c	85 c0		 test	 eax, eax
  0014e	75 d0		 jne	 SHORT $LL4@set_issubs
$LN3@set_issubs:

; 1827 :     }
; 1828 :     Py_RETURN_TRUE;

  00150	e8 00 00 00 00	 call	 _Py_PXCTX
  00155	85 c0		 test	 eax, eax
  00157	75 3c		 jne	 SHORT $LN19@set_issubs
  00159	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_TrueStruct
  00160	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0016e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00174	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0017c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00181	85 c0		 test	 eax, eax
  00183	75 09		 jne	 SHORT $LN18@set_issubs
  00185	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  0018c	74 07		 je	 SHORT $LN19@set_issubs
$LN18@set_issubs:
  0018e	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80
$LN19@set_issubs:
  00195	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct

; 1829 : }

  0019c	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001a1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001a5	5f		 pop	 rdi
  001a6	5e		 pop	 rsi
  001a7	5d		 pop	 rbp
  001a8	c3		 ret	 0
$LN24@set_issubs:

; 1826 :             Py_RETURN_FALSE;

  001a9	e8 00 00 00 00	 call	 _Py_PXCTX
  001ae	85 c0		 test	 eax, eax
  001b0	75 3c		 jne	 SHORT $LN15@set_issubs
  001b2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  001b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  001c7	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  001cd	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001d5	e8 00 00 00 00	 call	 _PyParallel_Guard
  001da	85 c0		 test	 eax, eax
  001dc	75 09		 jne	 SHORT $LN14@set_issubs
  001de	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  001e5	74 07		 je	 SHORT $LN15@set_issubs
$LN14@set_issubs:
  001e7	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN15@set_issubs:
  001ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct

; 1829 : }

  001f5	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001fa	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001fe	5f		 pop	 rdi
  001ff	5e		 pop	 rsi
  00200	5d		 pop	 rbp
  00201	c3		 ret	 0
set_issubset ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_issuperset DD imagerel set_issuperset
	DD	imagerel set_issuperset+160
	DD	imagerel $unwind$set_issuperset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_issuperset DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_issuperset
_TEXT	SEGMENT
so$ = 48
other$ = 56
set_issuperset PROC					; COMDAT

; 1835 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b f1	 mov	 rsi, rcx

; 1836 :     PyObject *tmp, *result;
; 1837 : 
; 1838 :     if (!PyAnySet_Check(other)) {

  00017	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  0001b	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:PySet_Type
  00022	48 8b da	 mov	 rbx, rdx
  00025	48 3b cf	 cmp	 rcx, rdi
  00028	74 56		 je	 SHORT $LN2@set_issupe
  0002a	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PyFrozenSet_Type
  00031	48 3b cd	 cmp	 rcx, rbp
  00034	74 4a		 je	 SHORT $LN2@set_issupe
  00036	48 8b d7	 mov	 rdx, rdi
  00039	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003e	85 c0		 test	 eax, eax
  00040	75 3e		 jne	 SHORT $LN2@set_issupe
  00042	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00046	48 8b d5	 mov	 rdx, rbp
  00049	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004e	85 c0		 test	 eax, eax
  00050	75 2e		 jne	 SHORT $LN2@set_issupe

; 1839 :         tmp = make_new_set(&PySet_Type, other);

  00052	48 8b d3	 mov	 rdx, rbx
  00055	48 8b cf	 mov	 rcx, rdi
  00058	e8 00 00 00 00	 call	 make_new_set
  0005d	48 8b f8	 mov	 rdi, rax

; 1840 :         if (tmp == NULL)

  00060	48 85 c0	 test	 rax, rax
  00063	74 26		 je	 SHORT $LN3@set_issupe
$LN1@set_issupe:

; 1841 :             return NULL;
; 1842 :         result = set_issuperset(so, tmp);

  00065	48 8b d0	 mov	 rdx, rax
  00068	48 8b ce	 mov	 rcx, rsi
  0006b	e8 00 00 00 00	 call	 set_issuperset

; 1843 :         Py_DECREF(tmp);

  00070	48 8b cf	 mov	 rcx, rdi
  00073	48 8b d8	 mov	 rbx, rax
  00076	e8 00 00 00 00	 call	 _Py_DecRef

; 1844 :         return result;

  0007b	48 8b c3	 mov	 rax, rbx
  0007e	eb 0b		 jmp	 SHORT $LN3@set_issupe
$LN2@set_issupe:

; 1845 :     }
; 1846 :     return set_issubset((PySetObject *)other, (PyObject *)so);

  00080	48 8b d6	 mov	 rdx, rsi
  00083	48 8b cb	 mov	 rcx, rbx
  00086	e8 00 00 00 00	 call	 set_issubset
$LN3@set_issupe:

; 1847 : }

  0008b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00090	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00095	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
set_issuperset ENDP
_TEXT	ENDS
EXTRN	PyBool_FromLong:PROC
EXTRN	PyObject_Not:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_richcompare DD imagerel set_richcompare
	DD	imagerel set_richcompare+432
	DD	imagerel $unwind$set_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_richcompare DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_richcompare
_TEXT	SEGMENT
v$ = 64
w$ = 72
op$ = 80
set_richcompare PROC					; COMDAT

; 1853 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f9	 mov	 rdi, rcx

; 1854 :     PyObject *r1, *r2;
; 1855 : 
; 1856 :     if(!PyAnySet_Check(w))

  00017	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  0001b	48 8b da	 mov	 rbx, rdx
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00025	49 63 f0	 movsxd	 rsi, r8d
  00028	48 3b ca	 cmp	 rcx, rdx
  0002b	74 36		 je	 SHORT $LN14@set_richco
  0002d	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PyFrozenSet_Type
  00034	48 3b cd	 cmp	 rcx, rbp
  00037	74 2a		 je	 SHORT $LN14@set_richco
  00039	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003e	85 c0		 test	 eax, eax
  00040	75 21		 jne	 SHORT $LN14@set_richco
  00042	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00046	48 8b d5	 mov	 rdx, rbp
  00049	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004e	85 c0		 test	 eax, eax
  00050	75 11		 jne	 SHORT $LN14@set_richco

; 1857 :         Py_RETURN_NOTIMPLEMENTED;

  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00059	e8 00 00 00 00	 call	 _Py_IncRef
  0005e	e9 19 01 00 00	 jmp	 $LN18@set_richco
$LN14@set_richco:

; 1858 : 
; 1859 :     switch (op) {

  00063	83 fe 05	 cmp	 esi, 5
  00066	0f 87 cb 00 00
	00		 ja	 $LN12@set_richco
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00073	8b 8c b2 00 00
	00 00		 mov	 ecx, DWORD PTR $LN21@set_richco[rdx+rsi*4]
  0007a	48 03 ca	 add	 rcx, rdx
  0007d	ff e1		 jmp	 rcx
$LN11@set_richco:

; 1860 :     case Py_EQ:
; 1861 :         if (PySet_GET_SIZE(v) != PySet_GET_SIZE(w))

  0007f	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00083	48 39 47 68	 cmp	 QWORD PTR [rdi+104], rax
  00087	74 18		 je	 SHORT $LN10@set_richco
$LN22@set_richco:

; 1862 :             Py_RETURN_FALSE;

  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00090	e8 00 00 00 00	 call	 _Py_IncRef
  00095	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0009c	e9 e2 00 00 00	 jmp	 $LN15@set_richco
$LN10@set_richco:

; 1863 :         if (v->hash != -1  &&
; 1864 :             ((PySetObject *)w)->hash != -1 &&
; 1865 :             v->hash != ((PySetObject *)w)->hash)

  000a1	48 8b 87 08 01
	00 00		 mov	 rax, QWORD PTR [rdi+264]
  000a8	48 83 f8 ff	 cmp	 rax, -1
  000ac	74 12		 je	 SHORT $LN9@set_richco
  000ae	48 8b 8b 08 01
	00 00		 mov	 rcx, QWORD PTR [rbx+264]
  000b5	48 83 f9 ff	 cmp	 rcx, -1
  000b9	74 05		 je	 SHORT $LN9@set_richco
  000bb	48 3b c1	 cmp	 rax, rcx

; 1866 :             Py_RETURN_FALSE;

  000be	75 c9		 jne	 SHORT $LN22@set_richco
$LN9@set_richco:

; 1867 :         return set_issubset(v, w);

  000c0	48 8b d3	 mov	 rdx, rbx
  000c3	48 8b cf	 mov	 rcx, rdi
  000c6	e8 00 00 00 00	 call	 set_issubset
  000cb	e9 b3 00 00 00	 jmp	 $LN15@set_richco
$LN8@set_richco:

; 1868 :     case Py_NE:
; 1869 :         r1 = set_richcompare(v, w, Py_EQ);

  000d0	41 b8 02 00 00
	00		 mov	 r8d, 2
  000d6	48 8b d3	 mov	 rdx, rbx
  000d9	48 8b cf	 mov	 rcx, rdi
  000dc	e8 00 00 00 00	 call	 set_richcompare
  000e1	48 8b f8	 mov	 rdi, rax

; 1870 :         if (r1 == NULL)

  000e4	48 85 c0	 test	 rax, rax
  000e7	0f 84 96 00 00
	00		 je	 $LN15@set_richco
$LN7@set_richco:

; 1871 :             return NULL;
; 1872 :         r2 = PyBool_FromLong(PyObject_Not(r1));

  000ed	48 8b c8	 mov	 rcx, rax
  000f0	e8 00 00 00 00	 call	 PyObject_Not
  000f5	8b c8		 mov	 ecx, eax
  000f7	e8 00 00 00 00	 call	 PyBool_FromLong

; 1873 :         Py_DECREF(r1);

  000fc	48 8b cf	 mov	 rcx, rdi
  000ff	48 8b d8	 mov	 rbx, rax
  00102	e8 00 00 00 00	 call	 _Py_DecRef

; 1874 :         return r2;

  00107	48 8b c3	 mov	 rax, rbx
  0010a	eb 77		 jmp	 SHORT $LN15@set_richco
$LN5@set_richco:

; 1875 :     case Py_LE:
; 1876 :         return set_issubset(v, w);
; 1877 :     case Py_GE:
; 1878 :         return set_issuperset(v, w);

  0010c	48 8b d3	 mov	 rdx, rbx
  0010f	48 8b cf	 mov	 rcx, rdi
  00112	e8 00 00 00 00	 call	 set_issuperset
  00117	eb 6a		 jmp	 SHORT $LN15@set_richco
$LN4@set_richco:

; 1879 :     case Py_LT:
; 1880 :         if (PySet_GET_SIZE(v) >= PySet_GET_SIZE(w))

  00119	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  0011d	48 39 47 68	 cmp	 QWORD PTR [rdi+104], rax
  00121	7c 9d		 jl	 SHORT $LN9@set_richco

; 1881 :             Py_RETURN_FALSE;

  00123	e9 61 ff ff ff	 jmp	 $LN22@set_richco
$LN2@set_richco:

; 1882 :         return set_issubset(v, w);
; 1883 :     case Py_GT:
; 1884 :         if (PySet_GET_SIZE(v) <= PySet_GET_SIZE(w))

  00128	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  0012c	48 39 47 68	 cmp	 QWORD PTR [rdi+104], rax
  00130	7f da		 jg	 SHORT $LN5@set_richco

; 1885 :             Py_RETURN_FALSE;

  00132	e9 52 ff ff ff	 jmp	 $LN22@set_richco
$LN12@set_richco:

; 1886 :         return set_issuperset(v, w);
; 1887 :     }
; 1888 :     Py_RETURN_NOTIMPLEMENTED;

  00137	e8 00 00 00 00	 call	 _Py_PXCTX
  0013c	85 c0		 test	 eax, eax
  0013e	75 3c		 jne	 SHORT $LN18@set_richco
  00140	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00147	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00155	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0015b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00163	e8 00 00 00 00	 call	 _PyParallel_Guard
  00168	85 c0		 test	 eax, eax
  0016a	75 09		 jne	 SHORT $LN17@set_richco
  0016c	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00173	74 07		 je	 SHORT $LN18@set_richco
$LN17@set_richco:
  00175	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN18@set_richco:
  0017c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
$LN15@set_richco:

; 1889 : }

  00183	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00188	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0018d	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00192	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00196	5f		 pop	 rdi
  00197	c3		 ret	 0
$LN21@set_richco:
  00198	00 00 00 00	 DD	 $LN4@set_richco
  0019c	00 00 00 00	 DD	 $LN9@set_richco
  001a0	00 00 00 00	 DD	 $LN11@set_richco
  001a4	00 00 00 00	 DD	 $LN8@set_richco
  001a8	00 00 00 00	 DD	 $LN2@set_richco
  001ac	00 00 00 00	 DD	 $LN5@set_richco
set_richcompare ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_add DD imagerel set_add
	DD	imagerel set_add+102
	DD	imagerel $unwind$set_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_add DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_add
_TEXT	SEGMENT
so$ = 64
key$ = 72
set_add	PROC						; COMDAT

; 1893 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1894 :     if (set_add_key(so, key) == -1)

  00004	e8 00 00 00 00	 call	 set_add_key
  00009	83 f8 ff	 cmp	 eax, -1
  0000c	75 07		 jne	 SHORT $LN1@set_add

; 1895 :         return NULL;

  0000e	33 c0		 xor	 eax, eax

; 1897 : }

  00010	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00014	c3		 ret	 0
$LN1@set_add:

; 1896 :     Py_RETURN_NONE;

  00015	e8 00 00 00 00	 call	 _Py_PXCTX
  0001a	85 c0		 test	 eax, eax
  0001c	75 3c		 jne	 SHORT $LN5@set_add
  0001e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00039	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00041	e8 00 00 00 00	 call	 _PyParallel_Guard
  00046	85 c0		 test	 eax, eax
  00048	75 09		 jne	 SHORT $LN4@set_add
  0004a	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00051	74 07		 je	 SHORT $LN5@set_add
$LN4@set_add:
  00053	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@set_add:
  0005a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1897 : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
set_add	ENDP
_TEXT	ENDS
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_contains DD imagerel set_contains
	DD	imagerel set_contains+160
	DD	imagerel $unwind$set_contains
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_contains DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_contains
_TEXT	SEGMENT
so$ = 48
key$ = 56
set_contains PROC					; COMDAT

; 1906 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	48 8b f1	 mov	 rsi, rcx

; 1907 :     PyObject *tmpkey;
; 1908 :     int rv;
; 1909 : 
; 1910 :     rv = set_contains_key(so, key);

  00015	e8 00 00 00 00	 call	 set_contains_key
  0001a	8b d8		 mov	 ebx, eax

; 1911 :     if (rv == -1) {

  0001c	83 f8 ff	 cmp	 eax, -1
  0001f	75 6d		 jne	 SHORT $LN5@set_contai@3

; 1912 :         if (!PySet_Check(key) || !PyErr_ExceptionMatches(PyExc_TypeError))

  00021	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0002c	48 3b ca	 cmp	 rcx, rdx
  0002f	74 09		 je	 SHORT $LN2@set_contai@3
  00031	e8 00 00 00 00	 call	 PyType_IsSubtype
  00036	85 c0		 test	 eax, eax
  00038	74 10		 je	 SHORT $LN3@set_contai@3
$LN2@set_contai@3:
  0003a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00041	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00046	85 c0		 test	 eax, eax
  00048	75 13		 jne	 SHORT $LN4@set_contai@3
$LN3@set_contai@3:

; 1913 :             return -1;

  0004a	83 c8 ff	 or	 eax, -1

; 1920 :     }
; 1921 :     return rv;
; 1922 : }

  0004d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00052	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00057	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005b	5f		 pop	 rdi
  0005c	c3		 ret	 0
$LN4@set_contai@3:

; 1914 :         PyErr_Clear();

  0005d	e8 00 00 00 00	 call	 PyErr_Clear

; 1915 :         tmpkey = make_new_set(&PyFrozenSet_Type, key);

  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFrozenSet_Type
  00069	48 8b d7	 mov	 rdx, rdi
  0006c	e8 00 00 00 00	 call	 make_new_set
  00071	48 8b f8	 mov	 rdi, rax

; 1916 :         if (tmpkey == NULL)

  00074	48 85 c0	 test	 rax, rax

; 1917 :             return -1;

  00077	74 d1		 je	 SHORT $LN3@set_contai@3

; 1918 :         rv = set_contains_key(so, tmpkey);

  00079	48 8b d0	 mov	 rdx, rax
  0007c	48 8b ce	 mov	 rcx, rsi
  0007f	e8 00 00 00 00	 call	 set_contains_key

; 1919 :         Py_DECREF(tmpkey);

  00084	48 8b cf	 mov	 rcx, rdi
  00087	8b d8		 mov	 ebx, eax
  00089	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@set_contai@3:

; 1920 :     }
; 1921 :     return rv;
; 1922 : }

  0008e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00093	8b c3		 mov	 eax, ebx
  00095	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
set_contains ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_direct_contains DD imagerel set_direct_contains
	DD	imagerel set_direct_contains+32
	DD	imagerel $unwind$set_direct_contains
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_direct_contains DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_direct_contains
_TEXT	SEGMENT
so$ = 48
key$ = 56
set_direct_contains PROC				; COMDAT

; 1926 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1927 :     long result;
; 1928 : 
; 1929 :     result = set_contains(so, key);

  00004	e8 00 00 00 00	 call	 set_contains

; 1930 :     if (result == -1)

  00009	83 f8 ff	 cmp	 eax, -1
  0000c	75 07		 jne	 SHORT $LN1@set_direct

; 1931 :         return NULL;

  0000e	33 c0		 xor	 eax, eax

; 1933 : }

  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
$LN1@set_direct:

; 1932 :     return PyBool_FromLong(result);

  00015	8b c8		 mov	 ecx, eax

; 1933 : }

  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	e9 00 00 00 00	 jmp	 PyBool_FromLong
set_direct_contains ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_remove DD imagerel set_remove
	DD	imagerel set_remove+246
	DD	imagerel $unwind$set_remove
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_remove DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_remove
_TEXT	SEGMENT
so$ = 64
key$ = 72
set_remove PROC						; COMDAT

; 1939 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b da	 mov	 rbx, rdx
  00017	48 8b e9	 mov	 rbp, rcx

; 1940 :     PyObject *tmpkey;
; 1941 :     int rv;
; 1942 : 
; 1943 :     rv = set_discard_key(so, key);

  0001a	e8 00 00 00 00	 call	 set_discard_key
  0001f	8b f8		 mov	 edi, eax

; 1944 :     if (rv == -1) {

  00021	83 f8 ff	 cmp	 eax, -1
  00024	75 5f		 jne	 SHORT $LN2@set_remove

; 1945 :         if (!PySet_Check(key) || !PyErr_ExceptionMatches(PyExc_TypeError))

  00026	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00031	48 3b ca	 cmp	 rcx, rdx
  00034	74 09		 je	 SHORT $LN4@set_remove
  00036	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003b	85 c0		 test	 eax, eax
  0003d	74 52		 je	 SHORT $LN5@set_remove
$LN4@set_remove:
  0003f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00046	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0004b	85 c0		 test	 eax, eax

; 1946 :             return NULL;

  0004d	74 42		 je	 SHORT $LN5@set_remove

; 1947 :         PyErr_Clear();

  0004f	e8 00 00 00 00	 call	 PyErr_Clear

; 1948 :         tmpkey = make_new_set(&PyFrozenSet_Type, key);

  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFrozenSet_Type
  0005b	48 8b d3	 mov	 rdx, rbx
  0005e	e8 00 00 00 00	 call	 make_new_set
  00063	48 8b f0	 mov	 rsi, rax

; 1949 :         if (tmpkey == NULL)

  00066	48 85 c0	 test	 rax, rax

; 1950 :             return NULL;

  00069	74 26		 je	 SHORT $LN5@set_remove

; 1951 :         rv = set_discard_key(so, tmpkey);

  0006b	48 8b d0	 mov	 rdx, rax
  0006e	48 8b cd	 mov	 rcx, rbp
  00071	e8 00 00 00 00	 call	 set_discard_key

; 1952 :         Py_DECREF(tmpkey);

  00076	48 8b ce	 mov	 rcx, rsi
  00079	8b f8		 mov	 edi, eax
  0007b	e8 00 00 00 00	 call	 _Py_DecRef

; 1953 :         if (rv == -1)

  00080	83 ff ff	 cmp	 edi, -1

; 1954 :             return NULL;

  00083	74 0c		 je	 SHORT $LN5@set_remove
$LN2@set_remove:

; 1955 :     }
; 1956 : 
; 1957 :     if (rv == DISCARD_NOTFOUND) {

  00085	85 ff		 test	 edi, edi
  00087	75 0c		 jne	 SHORT $LN1@set_remove

; 1958 :         set_key_error(key);

  00089	48 8b cb	 mov	 rcx, rbx
  0008c	e8 00 00 00 00	 call	 set_key_error
$LN5@set_remove:

; 1959 :         return NULL;

  00091	33 c0		 xor	 eax, eax
  00093	eb 4c		 jmp	 SHORT $LN8@set_remove
$LN1@set_remove:

; 1960 :     }
; 1961 :     Py_RETURN_NONE;

  00095	e8 00 00 00 00	 call	 _Py_PXCTX
  0009a	85 c0		 test	 eax, eax
  0009c	75 3c		 jne	 SHORT $LN11@set_remove
  0009e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000b3	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000b9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000c1	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c6	85 c0		 test	 eax, eax
  000c8	75 09		 jne	 SHORT $LN10@set_remove
  000ca	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000d1	74 07		 je	 SHORT $LN11@set_remove
$LN10@set_remove:
  000d3	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN11@set_remove:
  000da	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN8@set_remove:

; 1962 : }

  000e1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e6	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000eb	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000f0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f4	5f		 pop	 rdi
  000f5	c3		 ret	 0
set_remove ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_discard DD imagerel set_discard
	DD	imagerel set_discard+236
	DD	imagerel $unwind$set_discard
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_discard DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_discard
_TEXT	SEGMENT
so$ = 64
key$ = 72
set_discard PROC					; COMDAT

; 1971 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b da	 mov	 rbx, rdx
  00012	48 8b f1	 mov	 rsi, rcx

; 1972 :     PyObject *tmpkey;
; 1973 :     int rv;
; 1974 : 
; 1975 :     rv = set_discard_key(so, key);

  00015	e8 00 00 00 00	 call	 set_discard_key

; 1976 :     if (rv == -1) {

  0001a	83 f8 ff	 cmp	 eax, -1
  0001d	75 71		 jne	 SHORT $LN1@set_discar@3

; 1977 :         if (!PySet_Check(key) || !PyErr_ExceptionMatches(PyExc_TypeError))

  0001f	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0002a	48 3b ca	 cmp	 rcx, rdx
  0002d	74 09		 je	 SHORT $LN3@set_discar@3
  0002f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00034	85 c0		 test	 eax, eax
  00036	74 10		 je	 SHORT $LN4@set_discar@3
$LN3@set_discar@3:
  00038	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0003f	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00044	85 c0		 test	 eax, eax
  00046	75 12		 jne	 SHORT $LN5@set_discar@3
$LN4@set_discar@3:

; 1978 :             return NULL;

  00048	33 c0		 xor	 eax, eax

; 1989 : }

  0004a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0004f	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
$LN5@set_discar@3:

; 1979 :         PyErr_Clear();

  0005a	e8 00 00 00 00	 call	 PyErr_Clear

; 1980 :         tmpkey = make_new_set(&PyFrozenSet_Type, key);

  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFrozenSet_Type
  00066	48 8b d3	 mov	 rdx, rbx
  00069	e8 00 00 00 00	 call	 make_new_set
  0006e	48 8b f8	 mov	 rdi, rax

; 1981 :         if (tmpkey == NULL)

  00071	48 85 c0	 test	 rax, rax

; 1982 :             return NULL;

  00074	74 d2		 je	 SHORT $LN4@set_discar@3

; 1983 :         rv = set_discard_key(so, tmpkey);

  00076	48 8b d0	 mov	 rdx, rax
  00079	48 8b ce	 mov	 rcx, rsi
  0007c	e8 00 00 00 00	 call	 set_discard_key

; 1984 :         Py_DECREF(tmpkey);

  00081	48 8b cf	 mov	 rcx, rdi
  00084	8b d8		 mov	 ebx, eax
  00086	e8 00 00 00 00	 call	 _Py_DecRef

; 1985 :         if (rv == -1)

  0008b	83 fb ff	 cmp	 ebx, -1

; 1986 :             return NULL;

  0008e	74 b8		 je	 SHORT $LN4@set_discar@3
$LN1@set_discar@3:

; 1987 :     }
; 1988 :     Py_RETURN_NONE;

  00090	e8 00 00 00 00	 call	 _Py_PXCTX
  00095	85 c0		 test	 eax, eax
  00097	75 3c		 jne	 SHORT $LN10@set_discar@3
  00099	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000ae	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000b4	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000bc	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c1	85 c0		 test	 eax, eax
  000c3	75 09		 jne	 SHORT $LN9@set_discar@3
  000c5	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000cc	74 07		 je	 SHORT $LN10@set_discar@3
$LN9@set_discar@3:
  000ce	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN10@set_discar@3:

; 1989 : }

  000d5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000da	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000e6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ea	5f		 pop	 rdi
  000eb	c3		 ret	 0
set_discard ENDP
_TEXT	ENDS
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$set_reduce DD imagerel set_reduce
	DD	imagerel set_reduce+51
	DD	imagerel $unwind$set_reduce
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$set_reduce DD imagerel set_reduce+51
	DD	imagerel set_reduce+272
	DD	imagerel $chain$0$set_reduce
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$set_reduce DD imagerel set_reduce+272
	DD	imagerel set_reduce+495
	DD	imagerel $chain$1$set_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$set_reduce DD 021H
	DD	imagerel set_reduce
	DD	imagerel set_reduce+51
	DD	imagerel $unwind$set_reduce
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$set_reduce DD 020521H
	DD	085405H
	DD	imagerel set_reduce
	DD	imagerel set_reduce+51
	DD	imagerel $unwind$set_reduce
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_reduce DD 081501H
	DD	0b7415H
	DD	0a6415H
	DD	093415H
	DD	0c0115215H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
xdata	ENDS
;	COMDAT set_reduce
_TEXT	SEGMENT
so$ = 64
set_reduce PROC						; COMDAT

; 1998 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1999 :     PyObject *keys=NULL, *args=NULL, *result=NULL, *dict=NULL;

  00015	33 db		 xor	 ebx, ebx
  00017	4c 8b e1	 mov	 r12, rcx
  0001a	8b fb		 mov	 edi, ebx

; 2000 :     _Py_IDENTIFIER(__dict__);
; 2001 : 
; 2002 :     keys = PySequence_List((PyObject *)so);

  0001c	e8 00 00 00 00	 call	 PySequence_List
  00021	48 8b f0	 mov	 rsi, rax

; 2003 :     if (keys == NULL)

  00024	48 85 c0	 test	 rax, rax
  00027	0f 84 a9 01 00
	00		 je	 $LN55@set_reduce

; 2004 :         goto done;
; 2005 :     args = PyTuple_Pack(1, keys);

  0002d	8d 4b 01	 lea	 ecx, QWORD PTR [rbx+1]
  00030	48 8b d0	 mov	 rdx, rax
  00033	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00038	e8 00 00 00 00	 call	 PyTuple_Pack
  0003d	48 8b e8	 mov	 rbp, rax

; 2006 :     if (args == NULL)

  00040	48 85 c0	 test	 rax, rax
  00043	0f 84 b9 00 00
	00		 je	 $LN11@set_reduce

; 2007 :         goto done;
; 2008 :     dict = _PyObject_GetAttrId((PyObject *)so, &PyId___dict__);

  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0004f	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00058	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___dict__@?1??set_reduce@@9@9
  0005d	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00061	49 8b cc	 mov	 rcx, r12
  00064	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00069	48 8b f8	 mov	 rdi, rax

; 2009 :     if (dict == NULL) {

  0006c	48 85 c0	 test	 rax, rax
  0006f	75 14		 jne	 SHORT $LN13@set_reduce

; 2010 :         PyErr_Clear();

  00071	e8 00 00 00 00	 call	 PyErr_Clear

; 2011 :         dict = Py_None;

  00076	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct

; 2012 :         Py_INCREF(dict);

  0007d	48 8b cf	 mov	 rcx, rdi
  00080	e8 00 00 00 00	 call	 _Py_IncRef
$LN13@set_reduce:

; 2013 :     }
; 2014 :     result = PyTuple_Pack(3, Py_TYPE(so), args, dict);

  00085	49 8b 54 24 58	 mov	 rdx, QWORD PTR [r12+88]
  0008a	4c 8b cf	 mov	 r9, rdi
  0008d	4c 8b c5	 mov	 r8, rbp
  00090	b9 03 00 00 00	 mov	 ecx, 3
  00095	e8 00 00 00 00	 call	 PyTuple_Pack
$done$22023:
  0009a	48 8b d8	 mov	 rbx, rax

; 2015 : done:
; 2016 :     Py_XDECREF(args);

  0009d	e8 00 00 00 00	 call	 _Py_PXCTX
  000a2	85 c0		 test	 eax, eax
  000a4	75 5c		 jne	 SHORT $LN11@set_reduce
  000a6	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  000aa	a8 20		 test	 al, 32			; 00000020H
  000ac	75 4c		 jne	 SHORT $LN22@set_reduce
  000ae	84 c0		 test	 al, al
  000b0	78 48		 js	 SHORT $LN22@set_reduce
  000b2	a8 02		 test	 al, 2
  000b4	75 4c		 jne	 SHORT $LN11@set_reduce
  000b6	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  000ba	75 46		 jne	 SHORT $LN11@set_reduce
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000ca	4c 8b cd	 mov	 r9, rbp
  000cd	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000d3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000db	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e0	48 8b cd	 mov	 rcx, rbp
  000e3	85 c0		 test	 eax, eax
  000e5	74 07		 je	 SHORT $LN27@set_reduce
  000e7	e8 00 00 00 00	 call	 _Px_Dealloc
  000ec	eb 14		 jmp	 SHORT $LN11@set_reduce
$LN27@set_reduce:
  000ee	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  000f2	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000f8	eb 08		 jmp	 SHORT $LN11@set_reduce
$LN22@set_reduce:
  000fa	48 8b cd	 mov	 rcx, rbp
  000fd	e8 00 00 00 00	 call	 Px_DecRef
$LN11@set_reduce:

; 2017 :     Py_XDECREF(keys);

  00102	e8 00 00 00 00	 call	 _Py_PXCTX
  00107	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0010c	85 c0		 test	 eax, eax
  0010e	75 5c		 jne	 SHORT $LN7@set_reduce
  00110	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  00114	a8 20		 test	 al, 32			; 00000020H
  00116	75 4c		 jne	 SHORT $LN33@set_reduce
  00118	84 c0		 test	 al, al
  0011a	78 48		 js	 SHORT $LN33@set_reduce
  0011c	a8 02		 test	 al, 2
  0011e	75 4c		 jne	 SHORT $LN7@set_reduce
  00120	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  00124	75 46		 jne	 SHORT $LN7@set_reduce
  00126	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00134	4c 8b ce	 mov	 r9, rsi
  00137	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0013d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00145	e8 00 00 00 00	 call	 _PyParallel_Guard
  0014a	48 8b ce	 mov	 rcx, rsi
  0014d	85 c0		 test	 eax, eax
  0014f	74 07		 je	 SHORT $LN38@set_reduce
  00151	e8 00 00 00 00	 call	 _Px_Dealloc
  00156	eb 14		 jmp	 SHORT $LN7@set_reduce
$LN38@set_reduce:
  00158	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  0015c	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00162	eb 08		 jmp	 SHORT $LN7@set_reduce
$LN33@set_reduce:
  00164	48 8b ce	 mov	 rcx, rsi
  00167	e8 00 00 00 00	 call	 Px_DecRef
$LN7@set_reduce:

; 2018 :     Py_XDECREF(dict);

  0016c	48 85 ff	 test	 rdi, rdi
  0016f	74 65		 je	 SHORT $LN55@set_reduce
  00171	e8 00 00 00 00	 call	 _Py_PXCTX
  00176	85 c0		 test	 eax, eax
  00178	75 5c		 jne	 SHORT $LN55@set_reduce
  0017a	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0017e	a8 20		 test	 al, 32			; 00000020H
  00180	75 4c		 jne	 SHORT $LN44@set_reduce
  00182	84 c0		 test	 al, al
  00184	78 48		 js	 SHORT $LN44@set_reduce
  00186	a8 02		 test	 al, 2
  00188	75 4c		 jne	 SHORT $LN55@set_reduce
  0018a	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0018e	75 46		 jne	 SHORT $LN55@set_reduce
  00190	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00197	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0019e	4c 8b cf	 mov	 r9, rdi
  001a1	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001a7	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001af	e8 00 00 00 00	 call	 _PyParallel_Guard
  001b4	48 8b cf	 mov	 rcx, rdi
  001b7	85 c0		 test	 eax, eax
  001b9	74 07		 je	 SHORT $LN49@set_reduce
  001bb	e8 00 00 00 00	 call	 _Px_Dealloc
  001c0	eb 14		 jmp	 SHORT $LN55@set_reduce
$LN49@set_reduce:
  001c2	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001c6	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001cc	eb 08		 jmp	 SHORT $LN55@set_reduce
$LN44@set_reduce:
  001ce	48 8b cf	 mov	 rcx, rdi
  001d1	e8 00 00 00 00	 call	 Px_DecRef
$LN55@set_reduce:

; 2019 :     return result;
; 2020 : }

  001d6	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001db	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  001e0	48 8b c3	 mov	 rax, rbx
  001e3	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  001e8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001ec	41 5c		 pop	 r12
  001ee	c3		 ret	 0
set_reduce ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT set_sizeof
_TEXT	SEGMENT
so$ = 8
set_sizeof PROC						; COMDAT

; 2024 : {

  00000	48 8b d1	 mov	 rdx, rcx

; 2025 :     Py_ssize_t res;
; 2026 : 
; 2027 :     res = sizeof(PySetObject);

  00003	b9 20 01 00 00	 mov	 ecx, 288		; 00000120H

; 2028 :     if (so->table != so->smalltable)

  00008	48 8d 82 88 00
	00 00		 lea	 rax, QWORD PTR [rdx+136]
  0000f	48 39 42 78	 cmp	 QWORD PTR [rdx+120], rax
  00013	74 0c		 je	 SHORT $LN1@set_sizeof

; 2029 :         res = res + (so->mask + 1) * sizeof(setentry);

  00015	48 8b 4a 70	 mov	 rcx, QWORD PTR [rdx+112]
  00019	48 83 c1 13	 add	 rcx, 19
  0001d	48 c1 e1 04	 shl	 rcx, 4
$LN1@set_sizeof:

; 2030 :     return PyLong_FromSsize_t(res);
; 2031 : }

  00021	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
set_sizeof ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_init DD imagerel set_init
	DD	imagerel set_init+236
	DD	imagerel $unwind$set_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_init DD 081201H
	DD	0c5412H
	DD	0b3412H
	DD	0c00e5212H
	DD	0600b700cH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT set_init
_TEXT	SEGMENT
iterable$ = 80
self$ = 80
args$ = 88
kwds$ = 96
set_init PROC						; COMDAT

; 2036 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00012	48 8b d9	 mov	 rbx, rcx

; 2037 :     PyObject *iterable = NULL;
; 2038 : 
; 2039 :     if (!PyAnySet_Check(self))

  00015	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00019	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PySet_Type
  00020	49 8b f8	 mov	 rdi, r8
  00023	48 8b f2	 mov	 rsi, rdx
  00026	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR iterable$[rsp], 0
  0002f	48 3b cd	 cmp	 rcx, rbp
  00032	74 2d		 je	 SHORT $LN5@set_init
  00034	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:PyFrozenSet_Type
  0003b	49 3b cc	 cmp	 rcx, r12
  0003e	74 21		 je	 SHORT $LN5@set_init
  00040	48 8b d5	 mov	 rdx, rbp
  00043	e8 00 00 00 00	 call	 PyType_IsSubtype
  00048	85 c0		 test	 eax, eax
  0004a	75 15		 jne	 SHORT $LN5@set_init
  0004c	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00050	49 8b d4	 mov	 rdx, r12
  00053	e8 00 00 00 00	 call	 PyType_IsSubtype
  00058	85 c0		 test	 eax, eax
  0005a	75 05		 jne	 SHORT $LN5@set_init
$LN8@set_init:

; 2040 :         return -1;

  0005c	83 c8 ff	 or	 eax, -1
  0005f	eb 78		 jmp	 SHORT $LN6@set_init
$LN5@set_init:

; 2041 :     if (PySet_Check(self) && !_PyArg_NoKeywords("set()", kwds))

  00061	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00065	48 3b cd	 cmp	 rcx, rbp
  00068	74 0c		 je	 SHORT $LN3@set_init
  0006a	48 8b d5	 mov	 rdx, rbp
  0006d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00072	85 c0		 test	 eax, eax
  00074	74 13		 je	 SHORT $LN4@set_init
$LN3@set_init:
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05EBMGGHG@set?$CI?$CJ?$AA@
  0007d	48 8b d7	 mov	 rdx, rdi
  00080	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  00085	85 c0		 test	 eax, eax

; 2042 :         return -1;

  00087	74 d3		 je	 SHORT $LN8@set_init
$LN4@set_init:

; 2043 :     if (!PyArg_UnpackTuple(args, Py_TYPE(self)->tp_name, 0, 1, &iterable))

  00089	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  0008d	48 8d 44 24 50	 lea	 rax, QWORD PTR iterable$[rsp]
  00092	41 b9 01 00 00
	00		 mov	 r9d, 1
  00098	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0009c	45 33 c0	 xor	 r8d, r8d
  0009f	48 8b ce	 mov	 rcx, rsi
  000a2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a7	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  000ac	85 c0		 test	 eax, eax

; 2044 :         return -1;

  000ae	74 ac		 je	 SHORT $LN8@set_init

; 2045 :     set_clear_internal(self);

  000b0	48 8b cb	 mov	 rcx, rbx
  000b3	e8 00 00 00 00	 call	 set_clear_internal

; 2046 :     self->hash = -1;
; 2047 :     if (iterable == NULL)

  000b8	48 8b 54 24 50	 mov	 rdx, QWORD PTR iterable$[rsp]
  000bd	48 c7 83 08 01
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rbx+264], -1
  000c8	48 85 d2	 test	 rdx, rdx
  000cb	75 04		 jne	 SHORT $LN1@set_init

; 2048 :         return 0;

  000cd	33 c0		 xor	 eax, eax
  000cf	eb 08		 jmp	 SHORT $LN6@set_init
$LN1@set_init:

; 2049 :     return set_update_internal(self, iterable);

  000d1	48 8b cb	 mov	 rcx, rbx
  000d4	e8 00 00 00 00	 call	 set_update_internal
$LN6@set_init:

; 2050 : }

  000d9	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000de	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  000e3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e7	41 5c		 pop	 r12
  000e9	5f		 pop	 rdi
  000ea	5e		 pop	 rsi
  000eb	c3		 ret	 0
set_init ENDP
_TEXT	ENDS
PUBLIC	PySet_New
; Function compile flags: /Ogtpy
;	COMDAT PySet_New
_TEXT	SEGMENT
iterable$ = 8
PySet_New PROC						; COMDAT

; 2306 :     return make_new_set(&PySet_Type, iterable);

  00000	48 8b d1	 mov	 rdx, rcx
  00003	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PySet_Type

; 2307 : }

  0000a	e9 00 00 00 00	 jmp	 make_new_set
PySet_New ENDP
_TEXT	ENDS
PUBLIC	PyFrozenSet_New
; Function compile flags: /Ogtpy
;	COMDAT PyFrozenSet_New
_TEXT	SEGMENT
iterable$ = 8
PyFrozenSet_New PROC					; COMDAT

; 2312 :     return make_new_set(&PyFrozenSet_Type, iterable);

  00000	48 8b d1	 mov	 rdx, rcx
  00003	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFrozenSet_Type

; 2313 : }

  0000a	e9 00 00 00 00	 jmp	 make_new_set
PyFrozenSet_New ENDP
_TEXT	ENDS
PUBLIC	PySet_Size
EXTRN	_PyErr_BadInternalCall:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySet_Size DD imagerel $LN4
	DD	imagerel $LN4+113
	DD	imagerel $unwind$PySet_Size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySet_Size DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PySet_Size
_TEXT	SEGMENT
anyset$ = 48
PySet_Size PROC						; COMDAT

; 2317 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 2318 :     if (!PyAnySet_Check(anyset)) {

  0000d	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00018	48 3b ca	 cmp	 rcx, rdx
  0001b	74 45		 je	 SHORT $LN1@PySet_Size
  0001d	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:PyFrozenSet_Type
  00024	48 3b cf	 cmp	 rcx, rdi
  00027	74 39		 je	 SHORT $LN1@PySet_Size
  00029	e8 00 00 00 00	 call	 PyType_IsSubtype
  0002e	85 c0		 test	 eax, eax
  00030	75 30		 jne	 SHORT $LN1@PySet_Size
  00032	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00036	48 8b d7	 mov	 rdx, rdi
  00039	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003e	85 c0		 test	 eax, eax
  00040	75 20		 jne	 SHORT $LN1@PySet_Size

; 2319 :         PyErr_BadInternalCall();

  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00049	ba 0f 09 00 00	 mov	 edx, 2319		; 0000090fH
  0004e	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2320 :         return -1;

  00053	48 83 c8 ff	 or	 rax, -1

; 2323 : }

  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5f		 pop	 rdi
  00061	c3		 ret	 0
$LN1@PySet_Size:

; 2321 :     }
; 2322 :     return PySet_GET_SIZE(anyset);

  00062	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]

; 2323 : }

  00066	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006f	5f		 pop	 rdi
  00070	c3		 ret	 0
PySet_Size ENDP
_TEXT	ENDS
PUBLIC	PySet_Clear
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySet_Clear DD imagerel $LN4
	DD	imagerel $LN4+73
	DD	imagerel $unwind$PySet_Clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySet_Clear DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PySet_Clear
_TEXT	SEGMENT
set$ = 48
PySet_Clear PROC					; COMDAT

; 2327 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 2328 :     if (!PySet_Check(set)) {

  00009	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00014	48 3b ca	 cmp	 rcx, rdx
  00017	74 23		 je	 SHORT $LN1@PySet_Clea@2
  00019	e8 00 00 00 00	 call	 PyType_IsSubtype
  0001e	85 c0		 test	 eax, eax
  00020	75 1a		 jne	 SHORT $LN1@PySet_Clea@2

; 2329 :         PyErr_BadInternalCall();

  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00029	ba 19 09 00 00	 mov	 edx, 2329		; 00000919H
  0002e	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2330 :         return -1;

  00033	83 c8 ff	 or	 eax, -1

; 2333 : }

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
$LN1@PySet_Clea@2:

; 2331 :     }
; 2332 :     return set_clear_internal((PySetObject *)set);

  0003c	48 8b cb	 mov	 rcx, rbx

; 2333 : }

  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5b		 pop	 rbx
  00044	e9 00 00 00 00	 jmp	 set_clear_internal
PySet_Clear ENDP
_TEXT	ENDS
PUBLIC	PySet_Contains
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySet_Contains DD imagerel $LN4
	DD	imagerel $LN4+136
	DD	imagerel $unwind$PySet_Contains
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySet_Contains DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PySet_Contains
_TEXT	SEGMENT
anyset$ = 48
key$ = 56
PySet_Contains PROC					; COMDAT

; 2337 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b d9	 mov	 rbx, rcx

; 2338 :     if (!PyAnySet_Check(anyset)) {

  00012	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00016	48 8b fa	 mov	 rdi, rdx
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00020	48 3b ca	 cmp	 rcx, rdx
  00023	74 49		 je	 SHORT $LN1@PySet_Cont
  00025	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFrozenSet_Type
  0002c	48 3b ce	 cmp	 rcx, rsi
  0002f	74 3d		 je	 SHORT $LN1@PySet_Cont
  00031	e8 00 00 00 00	 call	 PyType_IsSubtype
  00036	85 c0		 test	 eax, eax
  00038	75 34		 jne	 SHORT $LN1@PySet_Cont
  0003a	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  0003e	48 8b d6	 mov	 rdx, rsi
  00041	e8 00 00 00 00	 call	 PyType_IsSubtype
  00046	85 c0		 test	 eax, eax
  00048	75 24		 jne	 SHORT $LN1@PySet_Cont

; 2339 :         PyErr_BadInternalCall();

  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00051	ba 23 09 00 00	 mov	 edx, 2339		; 00000923H
  00056	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2340 :         return -1;

  0005b	83 c8 ff	 or	 eax, -1

; 2343 : }

  0005e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00063	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00068	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006c	5f		 pop	 rdi
  0006d	c3		 ret	 0
$LN1@PySet_Cont:

; 2341 :     }
; 2342 :     return set_contains_key((PySetObject *)anyset, key);

  0006e	48 8b d7	 mov	 rdx, rdi
  00071	48 8b cb	 mov	 rcx, rbx

; 2343 : }

  00074	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00079	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5f		 pop	 rdi
  00083	e9 00 00 00 00	 jmp	 set_contains_key
PySet_Contains ENDP
_TEXT	ENDS
PUBLIC	PySet_Discard
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySet_Discard DD imagerel $LN4
	DD	imagerel $LN4+93
	DD	imagerel $unwind$PySet_Discard
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySet_Discard DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PySet_Discard
_TEXT	SEGMENT
set$ = 48
key$ = 56
PySet_Discard PROC					; COMDAT

; 2347 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 2348 :     if (!PySet_Check(set)) {

  0000d	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00011	48 8b fa	 mov	 rdi, rdx
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0001b	48 3b ca	 cmp	 rcx, rdx
  0001e	74 28		 je	 SHORT $LN1@PySet_Disc
  00020	e8 00 00 00 00	 call	 PyType_IsSubtype
  00025	85 c0		 test	 eax, eax
  00027	75 1f		 jne	 SHORT $LN1@PySet_Disc

; 2349 :         PyErr_BadInternalCall();

  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00030	ba 2d 09 00 00	 mov	 edx, 2349		; 0000092dH
  00035	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2350 :         return -1;

  0003a	83 c8 ff	 or	 eax, -1

; 2353 : }

  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
$LN1@PySet_Disc:

; 2351 :     }
; 2352 :     return set_discard_key((PySetObject *)set, key);

  00048	48 8b d7	 mov	 rdx, rdi
  0004b	48 8b cb	 mov	 rcx, rbx

; 2353 : }

  0004e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	e9 00 00 00 00	 jmp	 set_discard_key
PySet_Discard ENDP
_TEXT	ENDS
PUBLIC	PySet_Add
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySet_Add DD imagerel $LN6
	DD	imagerel $LN6+125
	DD	imagerel $unwind$PySet_Add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySet_Add DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PySet_Add
_TEXT	SEGMENT
anyset$ = 48
key$ = 56
PySet_Add PROC						; COMDAT

; 2357 : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 2358 :     if (!PySet_Check(anyset) &&
; 2359 :         (!PyFrozenSet_Check(anyset) || Py_REFCNT(anyset) != 1)) {

  0000d	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00011	48 8b fa	 mov	 rdi, rdx
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0001b	48 3b ca	 cmp	 rcx, rdx
  0001e	74 48		 je	 SHORT $LN3@PySet_Add
  00020	e8 00 00 00 00	 call	 PyType_IsSubtype
  00025	85 c0		 test	 eax, eax
  00027	75 3f		 jne	 SHORT $LN3@PySet_Add
  00029	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFrozenSet_Type
  00034	48 3b ca	 cmp	 rcx, rdx
  00037	74 09		 je	 SHORT $LN1@PySet_Add
  00039	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003e	85 c0		 test	 eax, eax
  00040	74 07		 je	 SHORT $LN2@PySet_Add
$LN1@PySet_Add:
  00042	48 83 7b 50 01	 cmp	 QWORD PTR [rbx+80], 1
  00047	74 1f		 je	 SHORT $LN3@PySet_Add
$LN2@PySet_Add:

; 2360 :         PyErr_BadInternalCall();

  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00050	ba 38 09 00 00	 mov	 edx, 2360		; 00000938H
  00055	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2361 :         return -1;

  0005a	83 c8 ff	 or	 eax, -1

; 2364 : }

  0005d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
$LN3@PySet_Add:

; 2362 :     }
; 2363 :     return set_add_key((PySetObject *)anyset, key);

  00068	48 8b d7	 mov	 rdx, rdi
  0006b	48 8b cb	 mov	 rcx, rbx

; 2364 : }

  0006e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5f		 pop	 rdi
  00078	e9 00 00 00 00	 jmp	 set_add_key
PySet_Add ENDP
_TEXT	ENDS
PUBLIC	_PySet_NextEntry
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PySet_NextEntry DD imagerel $LN5
	DD	imagerel $LN5+167
	DD	imagerel $unwind$_PySet_NextEntry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PySet_NextEntry DD 081201H
	DD	0a5412H
	DD	093412H
	DD	0c00e3212H
	DD	0600b700cH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PySet_NextEntry
_TEXT	SEGMENT
entry$ = 64
set$ = 64
pos$ = 72
key$ = 80
hash$ = 88
_PySet_NextEntry PROC					; COMDAT

; 2368 : {

$LN5:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00012	48 8b d9	 mov	 rbx, rcx

; 2369 :     setentry *entry;
; 2370 : 
; 2371 :     if (!PyAnySet_Check(set)) {

  00015	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00019	48 8b ea	 mov	 rbp, rdx
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00023	49 8b f9	 mov	 rdi, r9
  00026	49 8b f0	 mov	 rsi, r8
  00029	48 3b ca	 cmp	 rcx, rdx
  0002c	74 3b		 je	 SHORT $LN2@PySet_Next
  0002e	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:PyFrozenSet_Type
  00035	49 3b cc	 cmp	 rcx, r12
  00038	74 2f		 je	 SHORT $LN2@PySet_Next
  0003a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003f	85 c0		 test	 eax, eax
  00041	75 26		 jne	 SHORT $LN2@PySet_Next
  00043	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00047	49 8b d4	 mov	 rdx, r12
  0004a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004f	85 c0		 test	 eax, eax
  00051	75 16		 jne	 SHORT $LN2@PySet_Next

; 2372 :         PyErr_BadInternalCall();

  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  0005a	ba 44 09 00 00	 mov	 edx, 2372		; 00000944H
  0005f	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2373 :         return -1;

  00064	83 c8 ff	 or	 eax, -1
  00067	eb 2b		 jmp	 SHORT $LN3@PySet_Next
$LN2@PySet_Next:

; 2374 :     }
; 2375 :     if (set_next((PySetObject *)set, pos, &entry) == 0)

  00069	4c 8d 44 24 40	 lea	 r8, QWORD PTR entry$[rsp]
  0006e	48 8b d5	 mov	 rdx, rbp
  00071	48 8b cb	 mov	 rcx, rbx
  00074	e8 00 00 00 00	 call	 set_next
  00079	85 c0		 test	 eax, eax
  0007b	74 17		 je	 SHORT $LN3@PySet_Next
$LN1@PySet_Next:

; 2376 :         return 0;
; 2377 :     *key = entry->key;

  0007d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR entry$[rsp]
  00082	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00086	48 89 06	 mov	 QWORD PTR [rsi], rax

; 2378 :     *hash = entry->hash;

  00089	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0008c	48 89 07	 mov	 QWORD PTR [rdi], rax

; 2379 :     return 1;

  0008f	b8 01 00 00 00	 mov	 eax, 1
$LN3@PySet_Next:

; 2380 : }

  00094	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00099	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0009e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a2	41 5c		 pop	 r12
  000a4	5f		 pop	 rdi
  000a5	5e		 pop	 rsi
  000a6	c3		 ret	 0
_PySet_NextEntry ENDP
_TEXT	ENDS
PUBLIC	PySet_Pop
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySet_Pop DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$PySet_Pop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySet_Pop DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PySet_Pop
_TEXT	SEGMENT
set$ = 48
PySet_Pop PROC						; COMDAT

; 2384 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 2385 :     if (!PySet_Check(set)) {

  00009	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  00014	48 3b ca	 cmp	 rcx, rdx
  00017	74 22		 je	 SHORT $LN1@PySet_Pop
  00019	e8 00 00 00 00	 call	 PyType_IsSubtype
  0001e	85 c0		 test	 eax, eax
  00020	75 19		 jne	 SHORT $LN1@PySet_Pop

; 2386 :         PyErr_BadInternalCall();

  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00029	ba 52 09 00 00	 mov	 edx, 2386		; 00000952H
  0002e	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2387 :         return NULL;

  00033	33 c0		 xor	 eax, eax

; 2390 : }

  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5b		 pop	 rbx
  0003a	c3		 ret	 0
$LN1@PySet_Pop:

; 2388 :     }
; 2389 :     return set_pop((PySetObject *)set);

  0003b	48 8b cb	 mov	 rcx, rbx

; 2390 : }

  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5b		 pop	 rbx
  00043	e9 00 00 00 00	 jmp	 set_pop
PySet_Pop ENDP
_TEXT	ENDS
PUBLIC	_PySet_Update
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PySet_Update DD imagerel $LN4
	DD	imagerel $LN4+93
	DD	imagerel $unwind$_PySet_Update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PySet_Update DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PySet_Update
_TEXT	SEGMENT
set$ = 48
iterable$ = 56
_PySet_Update PROC					; COMDAT

; 2394 : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 2395 :     if (!PySet_Check(set)) {

  0000d	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00011	48 8b fa	 mov	 rdi, rdx
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PySet_Type
  0001b	48 3b ca	 cmp	 rcx, rdx
  0001e	74 28		 je	 SHORT $LN1@PySet_Upda
  00020	e8 00 00 00 00	 call	 PyType_IsSubtype
  00025	85 c0		 test	 eax, eax
  00027	75 1f		 jne	 SHORT $LN1@PySet_Upda

; 2396 :         PyErr_BadInternalCall();

  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LJPFHPFA@?4?4?2Objects?2setobject?4c?$AA@
  00030	ba 5c 09 00 00	 mov	 edx, 2396		; 0000095cH
  00035	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2397 :         return -1;

  0003a	83 c8 ff	 or	 eax, -1

; 2400 : }

  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
$LN1@PySet_Upda:

; 2398 :     }
; 2399 :     return set_update_internal((PySetObject *)set, iterable);

  00048	48 8b d7	 mov	 rdx, rdi
  0004b	48 8b cb	 mov	 rcx, rbx

; 2400 : }

  0004e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	e9 00 00 00 00	 jmp	 set_update_internal
_PySet_Update ENDP
_TEXT	ENDS
PUBLIC	??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@		; `string'
PUBLIC	??_C@_04BKLHDIKK@iter?$AA@			; `string'
EXTRN	Py_BuildValue:PROC
EXTRN	_PyObject_GetBuiltin:PROC
EXTRN	PyList_Append:PROC
EXTRN	PyList_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$setiter_reduce DD imagerel setiter_reduce
	DD	imagerel setiter_reduce+495
	DD	imagerel $unwind$setiter_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setiter_reduce DD 050d01H
	DD	018340dH
	DD	016010dH
	DD	07006H
xdata	ENDS
;	COMDAT ??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@
CONST	SEGMENT
??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@ DB 'N(N)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKLHDIKK@iter?$AA@
CONST	SEGMENT
??_C@_04BKLHDIKK@iter?$AA@ DB 'iter', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\setobject.c
CONST	ENDS
;	COMDAT setiter_reduce
_TEXT	SEGMENT
tmp$ = 48
si$ = 192
setiter_reduce PROC					; COMDAT

; 826  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  0000d	48 8b d9	 mov	 rbx, rcx

; 827  :     PyObject *list;
; 828  :     setiterobject tmp;
; 829  : 
; 830  :     list = PyList_New(0);

  00010	33 c9		 xor	 ecx, ecx
  00012	e8 00 00 00 00	 call	 PyList_New
  00017	48 8b f8	 mov	 rdi, rax

; 831  :     if (!list)

  0001a	48 85 c0	 test	 rax, rax

; 832  :         return NULL;

  0001d	0f 84 8b 01 00
	00		 je	 $LN9@setiter_re

; 833  : 
; 834  :     /* copy the iterator state */
; 835  :     tmp = *si;

  00023	0f 28 03	 movaps	 xmm0, XMMWORD PTR [rbx]
  00026	0f 28 4b 10	 movaps	 xmm1, XMMWORD PTR [rbx+16]
  0002a	0f 29 44 24 30	 movaps	 XMMWORD PTR tmp$[rsp], xmm0
  0002f	0f 28 43 20	 movaps	 xmm0, XMMWORD PTR [rbx+32]
  00033	0f 29 4c 24 40	 movaps	 XMMWORD PTR tmp$[rsp+16], xmm1
  00038	0f 28 4b 30	 movaps	 xmm1, XMMWORD PTR [rbx+48]
  0003c	0f 29 44 24 50	 movaps	 XMMWORD PTR tmp$[rsp+32], xmm0
  00041	0f 28 43 40	 movaps	 xmm0, XMMWORD PTR [rbx+64]
  00045	0f 29 4c 24 60	 movaps	 XMMWORD PTR tmp$[rsp+48], xmm1
  0004a	0f 28 4b 50	 movaps	 xmm1, XMMWORD PTR [rbx+80]
  0004e	0f 29 44 24 70	 movaps	 XMMWORD PTR tmp$[rsp+64], xmm0
  00053	0f 28 43 60	 movaps	 xmm0, XMMWORD PTR [rbx+96]
  00057	0f 29 8c 24 80
	00 00 00	 movaps	 XMMWORD PTR tmp$[rsp+80], xmm1
  0005f	0f 28 4b 70	 movaps	 xmm1, XMMWORD PTR [rbx+112]
  00063	0f 29 84 24 90
	00 00 00	 movaps	 XMMWORD PTR tmp$[rsp+96], xmm0
  0006b	0f 29 8c 24 a0
	00 00 00	 movaps	 XMMWORD PTR tmp$[rsp+112], xmm1

; 836  :     Py_XINCREF(tmp.si_set);

  00073	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR tmp$[rsp+96]
  0007b	48 85 db	 test	 rbx, rbx
  0007e	74 3b		 je	 SHORT $LN17@setiter_re
  00080	e8 00 00 00 00	 call	 _Py_PXCTX
  00085	85 c0		 test	 eax, eax
  00087	75 32		 jne	 SHORT $LN17@setiter_re
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00097	4c 8b cb	 mov	 r9, rbx
  0009a	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ad	85 c0		 test	 eax, eax
  000af	75 06		 jne	 SHORT $LN22@setiter_re
  000b1	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000b5	74 04		 je	 SHORT $LN17@setiter_re
$LN22@setiter_re:
  000b7	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN17@setiter_re:

; 837  : 
; 838  :     /* iterate the temporary into a list */
; 839  :     for(;;) {
; 840  :         PyObject *element = setiter_iternext(&tmp);

  000bb	48 8d 4c 24 30	 lea	 rcx, QWORD PTR tmp$[rsp]
  000c0	e8 00 00 00 00	 call	 setiter_iternext
  000c5	48 8b d8	 mov	 rbx, rax

; 841  :         if (element) {

  000c8	48 85 c0	 test	 rax, rax
  000cb	0f 84 8e 00 00
	00		 je	 $LN5@setiter_re
$LL14@setiter_re:

; 842  :             if (PyList_Append(list, element)) {

  000d1	48 8b d3	 mov	 rdx, rbx
  000d4	48 8b cf	 mov	 rcx, rdi
  000d7	e8 00 00 00 00	 call	 PyList_Append
  000dc	85 c0		 test	 eax, eax
  000de	0f 85 a8 00 00
	00		 jne	 $LN38@setiter_re

; 847  :             }
; 848  :             Py_DECREF(element);

  000e4	e8 00 00 00 00	 call	 _Py_PXCTX
  000e9	85 c0		 test	 eax, eax
  000eb	75 5c		 jne	 SHORT $LN36@setiter_re
  000ed	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000f1	a8 20		 test	 al, 32			; 00000020H
  000f3	75 4c		 jne	 SHORT $LN30@setiter_re
  000f5	84 c0		 test	 al, al
  000f7	78 48		 js	 SHORT $LN30@setiter_re
  000f9	a8 02		 test	 al, 2
  000fb	75 4c		 jne	 SHORT $LN36@setiter_re
  000fd	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00101	75 46		 jne	 SHORT $LN36@setiter_re
  00103	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00111	4c 8b cb	 mov	 r9, rbx
  00114	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0011a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00122	e8 00 00 00 00	 call	 _PyParallel_Guard
  00127	48 8b cb	 mov	 rcx, rbx
  0012a	85 c0		 test	 eax, eax
  0012c	74 07		 je	 SHORT $LN35@setiter_re
  0012e	e8 00 00 00 00	 call	 _Px_Dealloc
  00133	eb 14		 jmp	 SHORT $LN36@setiter_re
$LN35@setiter_re:
  00135	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00139	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0013f	eb 08		 jmp	 SHORT $LN36@setiter_re
$LN30@setiter_re:
  00141	48 8b cb	 mov	 rcx, rbx
  00144	e8 00 00 00 00	 call	 Px_DecRef
$LN36@setiter_re:

; 837  : 
; 838  :     /* iterate the temporary into a list */
; 839  :     for(;;) {
; 840  :         PyObject *element = setiter_iternext(&tmp);

  00149	48 8d 4c 24 30	 lea	 rcx, QWORD PTR tmp$[rsp]
  0014e	e8 00 00 00 00	 call	 setiter_iternext
  00153	48 8b d8	 mov	 rbx, rax

; 841  :         if (element) {

  00156	48 85 c0	 test	 rax, rax
  00159	0f 85 72 ff ff
	ff		 jne	 $LL14@setiter_re
$LN5@setiter_re:

; 849  :         } else
; 850  :             break;
; 851  :     }
; 852  :     Py_XDECREF(tmp.si_set);

  0015f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tmp$[rsp+96]
  00167	48 85 c9	 test	 rcx, rcx
  0016a	74 55		 je	 SHORT $LN1@setiter_re
  0016c	e8 00 00 00 00	 call	 _Py_DecRef

; 853  :     /* check for error */
; 854  :     if (tmp.si_set != NULL) {
; 855  :         /* we have an error */
; 856  :         Py_DECREF(list);

  00171	48 8b cf	 mov	 rcx, rdi
  00174	e8 00 00 00 00	 call	 _Py_DecRef

; 857  :         return NULL;

  00179	33 c0		 xor	 eax, eax

; 860  : }

  0017b	48 8b 9c 24 c0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+192]
  00183	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  0018a	5f		 pop	 rdi
  0018b	c3		 ret	 0
$LN38@setiter_re:

; 843  :                 Py_DECREF(element);

  0018c	48 8b cb	 mov	 rcx, rbx
  0018f	e8 00 00 00 00	 call	 _Py_DecRef

; 844  :                 Py_DECREF(list);

  00194	48 8b cf	 mov	 rcx, rdi
  00197	e8 00 00 00 00	 call	 _Py_DecRef

; 845  :                 Py_XDECREF(tmp.si_set);

  0019c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tmp$[rsp+96]
  001a4	48 85 c9	 test	 rcx, rcx
  001a7	74 05		 je	 SHORT $LN9@setiter_re
  001a9	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@setiter_re:

; 846  :                 return NULL;

  001ae	33 c0		 xor	 eax, eax

; 860  : }

  001b0	48 8b 9c 24 c0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+192]
  001b8	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  001bf	5f		 pop	 rdi
  001c0	c3		 ret	 0
$LN1@setiter_re:

; 858  :     }
; 859  :     return Py_BuildValue("N(N)", _PyObject_GetBuiltin("iter"), list);

  001c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BKLHDIKK@iter?$AA@
  001c8	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  001cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@
  001d4	4c 8b c7	 mov	 r8, rdi
  001d7	48 8b d0	 mov	 rdx, rax

; 860  : }

  001da	48 8b 9c 24 c0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+192]
  001e2	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  001e9	5f		 pop	 rdi
  001ea	e9 00 00 00 00	 jmp	 Py_BuildValue
setiter_reduce ENDP
_TEXT	ENDS
END
