; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
CONST	ENDS
PUBLIC	inflateReset
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\zlib\inflate.c
;	COMDAT inflateReset
_TEXT	SEGMENT
strm$ = 8
inflateReset PROC					; COMDAT

; 106  :     struct inflate_state FAR *state;
; 107  : 
; 108  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 68		 je	 SHORT $LN1@inflateRes
  00005	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]
  00009	48 85 d2	 test	 rdx, rdx
  0000c	74 5f		 je	 SHORT $LN1@inflateRes

; 109  :     state = (struct inflate_state FAR *)strm->state;
; 110  :     strm->total_in = strm->total_out = state->total = 0;

  0000e	33 c0		 xor	 eax, eax
  00010	89 42 1c	 mov	 DWORD PTR [rdx+28], eax
  00013	89 41 1c	 mov	 DWORD PTR [rcx+28], eax
  00016	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 111  :     strm->msg = Z_NULL;

  00019	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 112  :     strm->adler = 1;        /* to support ill-conceived Java test suite */

  0001d	c7 41 4c 01 00
	00 00		 mov	 DWORD PTR [rcx+76], 1

; 113  :     state->mode = HEAD;

  00024	48 89 02	 mov	 QWORD PTR [rdx], rax

; 114  :     state->last = 0;
; 115  :     state->havedict = 0;

  00027	89 42 0c	 mov	 DWORD PTR [rdx+12], eax

; 116  :     state->dmax = 32768U;
; 117  :     state->head = Z_NULL;

  0002a	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax

; 118  :     state->wsize = 0;

  0002e	48 89 42 2c	 mov	 QWORD PTR [rdx+44], rax

; 119  :     state->whave = 0;
; 120  :     state->wnext = 0;

  00032	89 42 34	 mov	 DWORD PTR [rdx+52], eax

; 121  :     state->hold = 0;

  00035	48 89 42 40	 mov	 QWORD PTR [rdx+64], rax

; 122  :     state->bits = 0;
; 123  :     state->lencode = state->distcode = state->next = state->codes;

  00039	48 8d 82 48 05
	00 00		 lea	 rax, QWORD PTR [rdx+1352]
  00040	48 89 82 80 00
	00 00		 mov	 QWORD PTR [rdx+128], rax
  00047	48 89 42 60	 mov	 QWORD PTR [rdx+96], rax
  0004b	48 89 42 58	 mov	 QWORD PTR [rdx+88], rax

; 124  :     state->sane = 1;
; 125  :     state->back = -1;
; 126  :     Tracev((stderr, "inflate: reset\n"));
; 127  :     return Z_OK;

  0004f	33 c0		 xor	 eax, eax
  00051	c7 42 14 00 80
	00 00		 mov	 DWORD PTR [rdx+20], 32768 ; 00008000H
  00058	c7 82 d8 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rdx+7128], 1
  00062	c7 82 dc 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rdx+7132], -1

; 128  : }

  0006c	c3		 ret	 0
$LN1@inflateRes:

; 106  :     struct inflate_state FAR *state;
; 107  : 
; 108  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0006d	b8 fe ff ff ff	 mov	 eax, -2

; 128  : }

  00072	c3		 ret	 0
inflateReset ENDP
_TEXT	ENDS
PUBLIC	inflateReset2
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset2 DD imagerel $LN12
	DD	imagerel $LN12+34
	DD	imagerel $unwind$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflateReset2 DD imagerel $LN12+34
	DD	imagerel $LN12+104
	DD	imagerel $chain$0$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateReset2 DD imagerel $LN12+104
	DD	imagerel $LN12+149
	DD	imagerel $chain$2$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateReset2 DD imagerel $LN12+149
	DD	imagerel $LN12+170
	DD	imagerel $chain$3$inflateReset2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateReset2 DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+34
	DD	imagerel $unwind$inflateReset2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateReset2 DD 020021H
	DD	065400H
	DD	imagerel $LN12
	DD	imagerel $LN12+34
	DD	imagerel $unwind$inflateReset2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflateReset2 DD 020521H
	DD	065405H
	DD	imagerel $LN12
	DD	imagerel $LN12+34
	DD	imagerel $unwind$inflateReset2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset2 DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflateReset2
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
inflateReset2 PROC					; COMDAT

; 133  : {

$LN12:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b da		 mov	 ebx, edx
  00011	48 8b f1	 mov	 rsi, rcx

; 134  :     int wrap;
; 135  :     struct inflate_state FAR *state;
; 136  : 
; 137  :     /* get the state */
; 138  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00014	48 85 c9	 test	 rcx, rcx
  00017	74 7c		 je	 SHORT $LN7@inflateRes@2
  00019	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  0001d	48 85 ff	 test	 rdi, rdi
  00020	74 73		 je	 SHORT $LN7@inflateRes@2

; 139  :     state = (struct inflate_state FAR *)strm->state;
; 140  : 
; 141  :     /* extract wrap request from windowBits parameter */
; 142  :     if (windowBits < 0) {

  00022	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00027	85 d2		 test	 edx, edx
  00029	79 06		 jns	 SHORT $LN6@inflateRes@2

; 143  :         wrap = 0;

  0002b	33 ed		 xor	 ebp, ebp

; 144  :         windowBits = -windowBits;

  0002d	f7 db		 neg	 ebx

; 145  :     }
; 146  :     else {

  0002f	eb 0f		 jmp	 SHORT $LN4@inflateRes@2
$LN6@inflateRes@2:

; 147  :         wrap = (windowBits >> 4) + 1;

  00031	8b ea		 mov	 ebp, edx
  00033	c1 fd 04	 sar	 ebp, 4
  00036	ff c5		 inc	 ebp

; 148  : #ifdef GUNZIP
; 149  :         if (windowBits < 48)

  00038	83 fa 30	 cmp	 edx, 48			; 00000030H
  0003b	7d 03		 jge	 SHORT $LN4@inflateRes@2

; 150  :             windowBits &= 15;

  0003d	83 e3 0f	 and	 ebx, 15
$LN4@inflateRes@2:

; 151  : #endif
; 152  :     }
; 153  : 
; 154  :     /* set number of window bits, free window if different */
; 155  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00040	85 db		 test	 ebx, ebx
  00042	74 24		 je	 SHORT $LN3@inflateRes@2
  00044	83 fb 08	 cmp	 ebx, 8
  00047	7c 05		 jl	 SHORT $LN2@inflateRes@2
  00049	83 fb 0f	 cmp	 ebx, 15
  0004c	7e 1a		 jle	 SHORT $LN3@inflateRes@2
$LN2@inflateRes@2:

; 156  :         return Z_STREAM_ERROR;

  0004e	b8 fe ff ff ff	 mov	 eax, -2
$LN11@inflateRes@2:
  00053	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 166  : }

  00058	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0005d	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
$LN3@inflateRes@2:

; 157  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00068	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  0006c	48 85 d2	 test	 rdx, rdx
  0006f	74 14		 je	 SHORT $LN1@inflateRes@2
  00071	39 5f 28	 cmp	 DWORD PTR [rdi+40], ebx
  00074	74 0f		 je	 SHORT $LN1@inflateRes@2

; 158  :         ZFREE(strm, state->window);

  00076	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0007a	ff 56 38	 call	 QWORD PTR [rsi+56]

; 159  :         state->window = Z_NULL;

  0007d	48 c7 47 38 00
	00 00 00	 mov	 QWORD PTR [rdi+56], 0
$LN1@inflateRes@2:

; 160  :     }
; 161  : 
; 162  :     /* update state and reset the rest of it */
; 163  :     state->wrap = wrap;
; 164  :     state->wbits = (unsigned)windowBits;
; 165  :     return inflateReset(strm);

  00085	48 8b ce	 mov	 rcx, rsi
  00088	89 6f 08	 mov	 DWORD PTR [rdi+8], ebp
  0008b	89 5f 28	 mov	 DWORD PTR [rdi+40], ebx
  0008e	e8 00 00 00 00	 call	 inflateReset
  00093	eb be		 jmp	 SHORT $LN11@inflateRes@2
$LN7@inflateRes@2:

; 166  : }

  00095	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0009a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009f	b8 fe ff ff ff	 mov	 eax, -2
  000a4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a8	5f		 pop	 rdi
  000a9	c3		 ret	 0
inflateReset2 ENDP
_TEXT	ENDS
PUBLIC	inflateInit2_
EXTRN	zcfree:PROC
EXTRN	zcalloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit2_ DD imagerel $LN12
	DD	imagerel $LN12+63
	DD	imagerel $unwind$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateInit2_ DD imagerel $LN12+63
	DD	imagerel $LN12+172
	DD	imagerel $chain$1$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateInit2_ DD imagerel $LN12+172
	DD	imagerel $LN12+214
	DD	imagerel $chain$3$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateInit2_ DD imagerel $LN12+214
	DD	imagerel $LN12+230
	DD	imagerel $chain$4$inflateInit2_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateInit2_ DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+63
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateInit2_ DD 040021H
	DD	076400H
	DD	065400H
	DD	imagerel $LN12
	DD	imagerel $LN12+63
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateInit2_ DD 040c21H
	DD	07640cH
	DD	065405H
	DD	imagerel $LN12
	DD	imagerel $LN12+63
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit2_ DD 040a01H
	DD	08340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflateInit2_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
version$ = 64
stream_size$ = 72
inflateInit2_ PROC					; COMDAT

; 173  : {

$LN12:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b fa		 mov	 edi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 174  :     int ret;
; 175  :     struct inflate_state FAR *state;
; 176  : 
; 177  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 178  :         stream_size != (int)(sizeof(z_stream)))

  0000f	4d 85 c0	 test	 r8, r8
  00012	0f 84 be 00 00
	00		 je	 $LN6@inflateIni
  00018	41 80 38 31	 cmp	 BYTE PTR [r8], 49	; 00000031H
  0001c	0f 85 b4 00 00
	00		 jne	 $LN6@inflateIni
  00022	41 83 f9 58	 cmp	 r9d, 88			; 00000058H
  00026	0f 85 aa 00 00
	00		 jne	 $LN6@inflateIni

; 180  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  0002c	48 85 c9	 test	 rcx, rcx
  0002f	75 0e		 jne	 SHORT $LN5@inflateIni
  00031	8d 41 fe	 lea	 eax, QWORD PTR [rcx-2]

; 199  : }

  00034	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
$LN5@inflateIni:
  0003f	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp

; 181  :     strm->msg = Z_NULL;                 /* in case we return an error */

  00044	33 ed		 xor	 ebp, ebp
  00046	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0004b	48 89 69 20	 mov	 QWORD PTR [rcx+32], rbp

; 182  :     if (strm->zalloc == (alloc_func)0) {

  0004f	48 39 69 30	 cmp	 QWORD PTR [rcx+48], rbp
  00053	75 0f		 jne	 SHORT $LN4@inflateIni

; 183  :         strm->zalloc = zcalloc;

  00055	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 184  :         strm->opaque = (voidpf)0;

  0005c	48 89 69 40	 mov	 QWORD PTR [rcx+64], rbp
  00060	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN4@inflateIni:

; 185  :     }
; 186  :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  00064	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zcfree

; 187  :     state = (struct inflate_state FAR *)
; 188  :             ZALLOC(strm, 1, sizeof(struct inflate_state));

  0006f	ba 01 00 00 00	 mov	 edx, 1
  00074	48 3b c5	 cmp	 rax, rbp
  00077	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  0007d	48 0f 44 c1	 cmove	 rax, rcx
  00081	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00085	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
  00089	ff 53 30	 call	 QWORD PTR [rbx+48]
  0008c	48 8b f0	 mov	 rsi, rax

; 189  :     if (state == Z_NULL) return Z_MEM_ERROR;

  0008f	48 85 c0	 test	 rax, rax
  00092	75 18		 jne	 SHORT $LN2@inflateIni
  00094	8d 46 fc	 lea	 eax, QWORD PTR [rsi-4]
$LN11@inflateIni:
  00097	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0009c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 199  : }

  000a1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
$LN2@inflateIni:

; 190  :     Tracev((stderr, "inflate: allocated\n"));
; 191  :     strm->state = (struct internal_state FAR *)state;

  000ac	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 192  :     state->window = Z_NULL;
; 193  :     ret = inflateReset2(strm, windowBits);

  000b0	8b d7		 mov	 edx, edi
  000b2	48 8b cb	 mov	 rcx, rbx
  000b5	48 89 68 38	 mov	 QWORD PTR [rax+56], rbp
  000b9	e8 00 00 00 00	 call	 inflateReset2
  000be	8b f8		 mov	 edi, eax

; 194  :     if (ret != Z_OK) {

  000c0	85 c0		 test	 eax, eax
  000c2	74 0e		 je	 SHORT $LN1@inflateIni

; 195  :         ZFREE(strm, state);

  000c4	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000c8	48 8b d6	 mov	 rdx, rsi
  000cb	ff 53 38	 call	 QWORD PTR [rbx+56]

; 196  :         strm->state = Z_NULL;

  000ce	48 89 6b 28	 mov	 QWORD PTR [rbx+40], rbp
$LN1@inflateIni:

; 197  :     }
; 198  :     return ret;

  000d2	8b c7		 mov	 eax, edi
  000d4	eb c1		 jmp	 SHORT $LN11@inflateIni
$LN6@inflateIni:

; 179  :         return Z_VERSION_ERROR;

  000d6	b8 fa ff ff ff	 mov	 eax, -6

; 199  : }

  000db	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e4	5f		 pop	 rdi
  000e5	c3		 ret	 0
inflateInit2_ ENDP
_TEXT	ENDS
PUBLIC	inflateInit_
; Function compile flags: /Ogtpy
;	COMDAT inflateInit_
_TEXT	SEGMENT
strm$ = 8
version$ = 16
stream_size$ = 24
inflateInit_ PROC					; COMDAT

; 206  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00000	45 8b c8	 mov	 r9d, r8d
  00003	4c 8b c2	 mov	 r8, rdx
  00006	ba 0f 00 00 00	 mov	 edx, 15

; 207  : }

  0000b	e9 00 00 00 00	 jmp	 inflateInit2_
inflateInit_ ENDP
_TEXT	ENDS
PUBLIC	inflatePrime
; Function compile flags: /Ogtpy
;	COMDAT inflatePrime
_TEXT	SEGMENT
strm$ = 8
bits$ = 16
value$ = 24
inflatePrime PROC					; COMDAT

; 213  : {

  00000	45 8b d8	 mov	 r11d, r8d

; 214  :     struct inflate_state FAR *state;
; 215  : 
; 216  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	48 85 c9	 test	 rcx, rcx
  00006	74 45		 je	 SHORT $LN4@inflatePri
  00008	4c 8b 49 28	 mov	 r9, QWORD PTR [rcx+40]
  0000c	4d 85 c9	 test	 r9, r9
  0000f	74 3c		 je	 SHORT $LN4@inflatePri

; 217  :     state = (struct inflate_state FAR *)strm->state;
; 218  :     if (bits < 0) {

  00011	85 d2		 test	 edx, edx
  00013	79 07		 jns	 SHORT $LN3@inflatePri

; 219  :         state->hold = 0;

  00015	33 c0		 xor	 eax, eax
  00017	49 89 41 40	 mov	 QWORD PTR [r9+64], rax

; 228  : }

  0001b	c3		 ret	 0
$LN3@inflatePri:

; 220  :         state->bits = 0;
; 221  :         return Z_OK;
; 222  :     }
; 223  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  0001c	83 fa 10	 cmp	 edx, 16
  0001f	7f 2c		 jg	 SHORT $LN4@inflatePri
  00021	45 8b 41 44	 mov	 r8d, DWORD PTR [r9+68]
  00025	45 8d 14 10	 lea	 r10d, DWORD PTR [r8+rdx]
  00029	41 83 fa 20	 cmp	 r10d, 32		; 00000020H
  0002d	77 1e		 ja	 SHORT $LN4@inflatePri

; 224  :     value &= (1L << bits) - 1;

  0002f	8b ca		 mov	 ecx, edx
  00031	b8 01 00 00 00	 mov	 eax, 1

; 225  :     state->hold += value << state->bits;
; 226  :     state->bits += bits;

  00036	45 89 51 44	 mov	 DWORD PTR [r9+68], r10d
  0003a	d3 e0		 shl	 eax, cl
  0003c	41 8b c8	 mov	 ecx, r8d
  0003f	ff c8		 dec	 eax
  00041	41 23 c3	 and	 eax, r11d
  00044	d3 e0		 shl	 eax, cl
  00046	41 01 41 40	 add	 DWORD PTR [r9+64], eax

; 227  :     return Z_OK;

  0004a	33 c0		 xor	 eax, eax

; 228  : }

  0004c	c3		 ret	 0
$LN4@inflatePri:

; 214  :     struct inflate_state FAR *state;
; 215  : 
; 216  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0004d	b8 fe ff ff ff	 mov	 eax, -2

; 228  : }

  00052	c3		 ret	 0
inflatePrime ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 243  : #ifdef BUILDFIXED
; 244  :     static int virgin = 1;
; 245  :     static code *lenfix, *distfix;
; 246  :     static code fixed[544];
; 247  : 
; 248  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 249  :     if (virgin) {
; 250  :         unsigned sym, bits;
; 251  :         static code *next;
; 252  : 
; 253  :         /* literal/length table */
; 254  :         sym = 0;
; 255  :         while (sym < 144) state->lens[sym++] = 8;
; 256  :         while (sym < 256) state->lens[sym++] = 9;
; 257  :         while (sym < 280) state->lens[sym++] = 7;
; 258  :         while (sym < 288) state->lens[sym++] = 8;
; 259  :         next = fixed;
; 260  :         lenfix = next;
; 261  :         bits = 9;
; 262  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 263  : 
; 264  :         /* distance table */
; 265  :         sym = 0;
; 266  :         while (sym < 32) state->lens[sym++] = 5;
; 267  :         distfix = next;
; 268  :         bits = 5;
; 269  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 270  : 
; 271  :         /* do this just once */
; 272  :         virgin = 0;
; 273  :     }
; 274  : #else /* !BUILDFIXED */
; 275  : #   include "inffixed.h"
; 276  : #endif /* BUILDFIXED */
; 277  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 278  :     state->lenbits = 9;

  00007	c7 41 68 09 00
	00 00		 mov	 DWORD PTR [rcx+104], 9

; 279  :     state->distcode = distfix;
; 280  :     state->distbits = 5;

  0000e	c7 41 6c 05 00
	00 00		 mov	 DWORD PTR [rcx+108], 5
  00015	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax
  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00020	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 281  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$updatewindow DD imagerel updatewindow
	DD	imagerel updatewindow+74
	DD	imagerel $unwind$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$updatewindow DD imagerel updatewindow+74
	DD	imagerel updatewindow+234
	DD	imagerel $chain$0$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$updatewindow DD imagerel updatewindow+234
	DD	imagerel updatewindow+255
	DD	imagerel $chain$1$updatewindow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$updatewindow DD 021H
	DD	imagerel updatewindow
	DD	imagerel updatewindow+74
	DD	imagerel $unwind$updatewindow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$updatewindow DD 020521H
	DD	06c405H
	DD	imagerel updatewindow
	DD	imagerel updatewindow+74
	DD	imagerel $unwind$updatewindow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$updatewindow DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT updatewindow
_TEXT	SEGMENT
strm$ = 48
out$ = 56
updatewindow PROC					; COMDAT

; 361  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 362  :     struct inflate_state FAR *state;
; 363  :     unsigned copy, dist;
; 364  : 
; 365  :     state = (struct inflate_state FAR *)strm->state;

  00014	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  00018	8b ea		 mov	 ebp, edx
  0001a	48 8b f1	 mov	 rsi, rcx

; 366  : 
; 367  :     /* if it hasn't been done already, allocate space for the window */
; 368  :     if (state->window == Z_NULL) {

  0001d	48 83 7b 38 00	 cmp	 QWORD PTR [rbx+56], 0
  00022	bf 01 00 00 00	 mov	 edi, 1
  00027	75 21		 jne	 SHORT $LN9@updatewind

; 369  :         state->window = (unsigned char FAR *)
; 370  :                         ZALLOC(strm, 1U << state->wbits,
; 371  :                                sizeof(unsigned char));

  00029	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0002c	8b d7		 mov	 edx, edi
  0002e	44 8b c7	 mov	 r8d, edi
  00031	d3 e2		 shl	 edx, cl
  00033	48 8b 4e 40	 mov	 rcx, QWORD PTR [rsi+64]
  00037	ff 56 30	 call	 QWORD PTR [rsi+48]
  0003a	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 372  :         if (state->window == Z_NULL) return 1;

  0003e	48 85 c0	 test	 rax, rax
  00041	75 07		 jne	 SHORT $LN9@updatewind
  00043	8b c7		 mov	 eax, edi
  00045	e9 a0 00 00 00	 jmp	 $LN11@updatewind
$LN9@updatewind:
  0004a	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12

; 373  :     }
; 374  : 
; 375  :     /* if window not in use yet, initialize */
; 376  :     if (state->wsize == 0) {

  0004f	45 33 e4	 xor	 r12d, r12d
  00052	44 39 63 2c	 cmp	 DWORD PTR [rbx+44], r12d
  00056	75 0c		 jne	 SHORT $LN8@updatewind

; 377  :         state->wsize = 1U << state->wbits;

  00058	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 378  :         state->wnext = 0;

  0005b	4c 89 63 30	 mov	 QWORD PTR [rbx+48], r12
  0005f	d3 e7		 shl	 edi, cl
  00061	89 7b 2c	 mov	 DWORD PTR [rbx+44], edi
$LN8@updatewind:

; 379  :         state->whave = 0;
; 380  :     }
; 381  : 
; 382  :     /* copy state->wsize or less output bytes into the circular window */
; 383  :     copy = out - strm->avail_out;

  00064	2b 6e 18	 sub	 ebp, DWORD PTR [rsi+24]

; 384  :     if (copy >= state->wsize) {

  00067	8b 7b 2c	 mov	 edi, DWORD PTR [rbx+44]

; 385  :         zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);

  0006a	48 8b 56 10	 mov	 rdx, QWORD PTR [rsi+16]
  0006e	3b ef		 cmp	 ebp, edi
  00070	72 18		 jb	 SHORT $LN7@updatewind
  00072	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00076	44 8b c7	 mov	 r8d, edi
  00079	48 2b d7	 sub	 rdx, rdi
  0007c	e8 00 00 00 00	 call	 memcpy

; 386  :         state->wnext = 0;
; 387  :         state->whave = state->wsize;

  00081	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  00084	44 89 63 34	 mov	 DWORD PTR [rbx+52], r12d

; 388  :     }
; 389  :     else {

  00088	eb 56		 jmp	 SHORT $LN13@updatewind
$LN7@updatewind:

; 390  :         dist = state->wsize - state->wnext;

  0008a	2b 7b 34	 sub	 edi, DWORD PTR [rbx+52]

; 391  :         if (dist > copy) dist = copy;
; 392  :         zmemcpy(state->window + state->wnext, strm->next_out - copy, dist);

  0008d	8b 4b 34	 mov	 ecx, DWORD PTR [rbx+52]
  00090	8b c5		 mov	 eax, ebp
  00092	3b fd		 cmp	 edi, ebp
  00094	0f 47 fd	 cmova	 edi, ebp
  00097	48 03 4b 38	 add	 rcx, QWORD PTR [rbx+56]
  0009b	48 2b d0	 sub	 rdx, rax
  0009e	44 8b c7	 mov	 r8d, edi
  000a1	e8 00 00 00 00	 call	 memcpy

; 393  :         copy -= dist;

  000a6	2b ef		 sub	 ebp, edi

; 394  :         if (copy) {

  000a8	74 1b		 je	 SHORT $LN4@updatewind

; 395  :             zmemcpy(state->window, strm->next_out - copy, copy);

  000aa	48 8b 56 10	 mov	 rdx, QWORD PTR [rsi+16]
  000ae	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  000b2	44 8b c5	 mov	 r8d, ebp
  000b5	49 2b d0	 sub	 rdx, r8
  000b8	e8 00 00 00 00	 call	 memcpy

; 396  :             state->wnext = copy;
; 397  :             state->whave = state->wsize;

  000bd	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  000c0	89 6b 34	 mov	 DWORD PTR [rbx+52], ebp

; 398  :         }
; 399  :         else {

  000c3	eb 1b		 jmp	 SHORT $LN13@updatewind
$LN4@updatewind:

; 400  :             state->wnext += dist;

  000c5	01 7b 34	 add	 DWORD PTR [rbx+52], edi

; 401  :             if (state->wnext == state->wsize) state->wnext = 0;

  000c8	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  000cb	8b 4b 2c	 mov	 ecx, DWORD PTR [rbx+44]
  000ce	3b c1		 cmp	 eax, ecx
  000d0	41 0f 44 c4	 cmove	 eax, r12d
  000d4	89 43 34	 mov	 DWORD PTR [rbx+52], eax

; 402  :             if (state->whave < state->wsize) state->whave += dist;

  000d7	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]
  000da	3b c1		 cmp	 eax, ecx
  000dc	73 05		 jae	 SHORT $LN1@updatewind
  000de	03 c7		 add	 eax, edi
$LN13@updatewind:
  000e0	89 43 30	 mov	 DWORD PTR [rbx+48], eax
$LN1@updatewind:
  000e3	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]

; 403  :         }
; 404  :     }
; 405  :     return 0;

  000e8	33 c0		 xor	 eax, eax
$LN11@updatewind:

; 406  : }

  000ea	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000ef	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000f4	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000f9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fd	5f		 pop	 rdi
  000fe	c3		 ret	 0
updatewindow ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	inflate
EXTRN	inflate_fast:PROC
EXTRN	inflate_table:PROC
EXTRN	adler32:PROC
EXTRN	crc32:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate DD imagerel $LN825
	DD	imagerel $LN825+78
	DD	imagerel $unwind$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflate DD imagerel $LN825+78
	DD	imagerel $LN825+2273
	DD	imagerel $chain$4$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$inflate DD imagerel $LN825+2273
	DD	imagerel $LN825+5708
	DD	imagerel $chain$6$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$inflate DD imagerel $LN825+5708
	DD	imagerel $LN825+5728
	DD	imagerel $chain$7$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$inflate DD imagerel $LN825+5728
	DD	imagerel $LN825+5852
	DD	imagerel $chain$8$inflate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$inflate DD 0a0021H
	DD	0bf400H
	DD	0cd400H
	DD	0dc400H
	DD	0e7400H
	DD	0f6400H
	DD	imagerel $LN825
	DD	imagerel $LN825+78
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$inflate DD 021H
	DD	imagerel $LN825
	DD	imagerel $LN825+78
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$inflate DD 0a0021H
	DD	0bf400H
	DD	0cd400H
	DD	0dc400H
	DD	0e7400H
	DD	0f6400H
	DD	imagerel $LN825
	DD	imagerel $LN825+78
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflate DD 0a2c21H
	DD	0bf42cH
	DD	0cd41bH
	DD	0dc413H
	DD	0e740aH
	DD	0f6405H
	DD	imagerel $LN825
	DD	imagerel $LN825+78
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate DD 041701H
	DD	0e00df217H
	DD	0500a300bH
xdata	ENDS
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT inflate
_TEXT	SEGMENT
hbuf$ = 48
last$ = 52
here$ = 52
out$1$ = 56
in$1$ = 60
put$1$ = 64
strm$ = 160
flush$ = 168
ret$1$ = 176
left$1$ = 184
inflate	PROC						; COMDAT

; 592  : {

$LN825:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	53		 push	 rbx
  0000b	41 56		 push	 r14
  0000d	48 8b ec	 mov	 rbp, rsp
  00010	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00017	48 8b d9	 mov	 rbx, rcx

; 593  :     struct inflate_state FAR *state;
; 594  :     unsigned char FAR *next;    /* next input */
; 595  :     unsigned char FAR *put;     /* next output */
; 596  :     unsigned have, left;        /* available input and output */
; 597  :     unsigned long hold;         /* bit buffer */
; 598  :     unsigned bits;              /* bits in bit buffer */
; 599  :     unsigned in, out;           /* save starting available input and output */
; 600  :     unsigned copy;              /* number of stored or match bytes to copy */
; 601  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 602  :     code here;                  /* current decoding table entry */
; 603  :     code last;                  /* parent table entry */
; 604  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 605  :     int ret;                    /* return code */
; 606  : #ifdef GUNZIP
; 607  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 608  : #endif
; 609  :     static const unsigned short order[19] = /* permutation of code lengths */
; 610  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 611  : 
; 612  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
; 613  :         (strm->next_in == Z_NULL && strm->avail_in != 0))

  0001a	48 85 c9	 test	 rcx, rcx
  0001d	0f 84 29 16 00
	00		 je	 $LN506@inflate
  00023	4c 8b 71 28	 mov	 r14, QWORD PTR [rcx+40]
  00027	4d 85 f6	 test	 r14, r14
  0002a	0f 84 1c 16 00
	00		 je	 $LN506@inflate
  00030	48 83 79 10 00	 cmp	 QWORD PTR [rcx+16], 0
  00035	0f 84 11 16 00
	00		 je	 $LN506@inflate
  0003b	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  0003f	75 0a		 jne	 SHORT $LN507@inflate
  00041	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00045	0f 85 01 16 00
	00		 jne	 $LN506@inflate
$LN507@inflate:

; 615  : 
; 616  :     state = (struct inflate_state FAR *)strm->state;
; 617  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  0004b	41 8b 06	 mov	 eax, DWORD PTR [r14]
  0004e	48 89 74 24 78	 mov	 QWORD PTR [rsp+120], rsi
  00053	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi

; 618  :     LOAD();

  00058	41 8b 7e 44	 mov	 edi, DWORD PTR [r14+68]
  0005c	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  00061	83 f8 0b	 cmp	 eax, 11
  00064	4c 89 6c 24 60	 mov	 QWORD PTR [rsp+96], r13
  00069	45 8b 6e 40	 mov	 r13d, DWORD PTR [r14+64]
  0006d	b9 0c 00 00 00	 mov	 ecx, 12
  00072	0f 44 c1	 cmove	 eax, ecx
  00075	4c 89 7c 24 58	 mov	 QWORD PTR [rsp+88], r15

; 619  :     in = have;
; 620  :     out = left;
; 621  :     ret = Z_OK;

  0007a	45 33 ff	 xor	 r15d, r15d
  0007d	41 89 06	 mov	 DWORD PTR [r14], eax
  00080	44 8b 53 18	 mov	 r10d, DWORD PTR [rbx+24]
  00084	4c 8b 4b 10	 mov	 r9, QWORD PTR [rbx+16]
  00088	8b 73 08	 mov	 esi, DWORD PTR [rbx+8]
  0008b	4c 8b 23	 mov	 r12, QWORD PTR [rbx]
  0008e	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9
  00092	44 89 55 38	 mov	 DWORD PTR left$1$[rbp-128], r10d
  00096	89 75 bc	 mov	 DWORD PTR in$1$[rbp-128], esi
  00099	45 8b c2	 mov	 r8d, r10d
  0009c	44 89 55 b8	 mov	 DWORD PTR out$1$[rbp-128], r10d
  000a0	44 89 7d 30	 mov	 DWORD PTR ret$1$[rbp-128], r15d

; 622  :     for (;;)
; 623  :         switch (state->mode) {

  000a4	83 f8 1e	 cmp	 eax, 30
  000a7	0f 87 95 15 00
	00		 ja	 $LN11@inflate
$LN823@inflate:
  000ad	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  000b4	48 98		 cdqe
  000b6	41 8b 8c 83 00
	00 00 00	 mov	 ecx, DWORD PTR $LN684@inflate[r11+rax*4]
  000be	49 03 cb	 add	 rcx, r11
  000c1	ff e1		 jmp	 rcx
$LN497@inflate:

; 624  :         case HEAD:
; 625  :             if (state->wrap == 0) {

  000c3	41 8b 56 08	 mov	 edx, DWORD PTR [r14+8]
  000c7	85 d2		 test	 edx, edx
  000c9	75 0c		 jne	 SHORT $LN495@inflate

; 626  :                 state->mode = TYPEDO;

  000cb	41 c7 06 0c 00
	00 00		 mov	 DWORD PTR [r14], 12

; 627  :                 break;

  000d2	e9 08 06 00 00	 jmp	 $LN498@inflate
$LN495@inflate:

; 628  :             }
; 629  :             NEEDBITS(16);

  000d7	83 ff 10	 cmp	 edi, 16
  000da	73 25		 jae	 SHORT $LN494@inflate
  000dc	0f 1f 40 00	 npad	 4
$LL492@inflate:
  000e0	85 f6		 test	 esi, esi
  000e2	0f 84 75 07 00
	00		 je	 $LN782@inflate
  000e8	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  000ed	8b cf		 mov	 ecx, edi
  000ef	83 c7 08	 add	 edi, 8
  000f2	d3 e0		 shl	 eax, cl
  000f4	ff ce		 dec	 esi
  000f6	49 ff c4	 inc	 r12
  000f9	44 03 e8	 add	 r13d, eax
  000fc	83 ff 10	 cmp	 edi, 16
  000ff	72 df		 jb	 SHORT $LL492@inflate
$LN494@inflate:

; 630  : #ifdef GUNZIP
; 631  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  00101	f6 c2 02	 test	 dl, 2
  00104	74 47		 je	 SHORT $LN486@inflate
  00106	41 81 fd 1f 8b
	00 00		 cmp	 r13d, 35615		; 00008b1fH
  0010d	75 3e		 jne	 SHORT $LN486@inflate

; 632  :                 state->check = crc32(0L, Z_NULL, 0);

  0010f	45 33 c0	 xor	 r8d, r8d
  00112	33 d2		 xor	 edx, edx
  00114	33 c9		 xor	 ecx, ecx
  00116	e8 00 00 00 00	 call	 crc32

; 633  :                 CRC2(state->check, hold);

  0011b	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  0011f	41 b8 02 00 00
	00		 mov	 r8d, 2
  00125	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
  00129	66 44 89 6d b0	 mov	 WORD PTR hbuf$[rbp-128], r13w
  0012e	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  00132	e8 00 00 00 00	 call	 crc32

; 634  :                 INITBITS();

  00137	45 8b ef	 mov	 r13d, r15d
  0013a	41 8b ff	 mov	 edi, r15d
  0013d	41 89 46 18	 mov	 DWORD PTR [r14+24], eax

; 635  :                 state->mode = FLAGS;

  00141	41 c7 06 01 00
	00 00		 mov	 DWORD PTR [r14], 1

; 636  :                 break;

  00148	e9 8a 05 00 00	 jmp	 $LN745@inflate
$LN486@inflate:

; 637  :             }
; 638  :             state->flags = 0;           /* expect zlib header */
; 639  :             if (state->head != Z_NULL)

  0014d	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  00151	45 89 7e 10	 mov	 DWORD PTR [r14+16], r15d
  00155	48 85 c0	 test	 rax, rax
  00158	74 07		 je	 SHORT $LN479@inflate

; 640  :                 state->head->done = -1;

  0015a	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
$LN479@inflate:

; 641  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
; 642  : #else
; 643  :             if (
; 644  : #endif
; 645  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {

  00161	41 f6 46 08 01	 test	 BYTE PTR [r14+8], 1
  00166	0f 84 be 00 00
	00		 je	 $LN477@inflate
  0016c	41 0f b6 cd	 movzx	 ecx, r13b
  00170	41 8b c5	 mov	 eax, r13d
  00173	c1 e8 08	 shr	 eax, 8
  00176	c1 e1 08	 shl	 ecx, 8
  00179	03 c8		 add	 ecx, eax
  0017b	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H
  00180	f7 e1		 mul	 ecx
  00182	8b c1		 mov	 eax, ecx
  00184	2b c2		 sub	 eax, edx
  00186	d1 e8		 shr	 eax, 1
  00188	03 c2		 add	 eax, edx
  0018a	c1 e8 04	 shr	 eax, 4
  0018d	6b c0 1f	 imul	 eax, 31
  00190	3b c8		 cmp	 ecx, eax
  00192	0f 85 92 00 00
	00		 jne	 $LN477@inflate

; 649  :             }
; 650  :             if (BITS(4) != Z_DEFLATED) {

  00198	41 8b c5	 mov	 eax, r13d
  0019b	24 0f		 and	 al, 15
  0019d	3c 08		 cmp	 al, 8
  0019f	74 17		 je	 SHORT $LN475@inflate
$LN821@inflate:

; 651  :                 strm->msg = (char *)"unknown compression method";

  001a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  001a8	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 652  :                 state->mode = BAD;

  001ac	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 653  :                 break;

  001b3	e9 27 05 00 00	 jmp	 $LN498@inflate
$LN475@inflate:

; 654  :             }
; 655  :             DROPBITS(4);
; 656  :             len = BITS(4) + 8;
; 657  :             if (state->wbits == 0)

  001b8	41 8b 46 28	 mov	 eax, DWORD PTR [r14+40]
  001bc	41 c1 ed 04	 shr	 r13d, 4
  001c0	83 c7 fc	 add	 edi, -4			; fffffffcH
  001c3	41 8b cd	 mov	 ecx, r13d
  001c6	83 e1 0f	 and	 ecx, 15
  001c9	83 c1 08	 add	 ecx, 8
  001cc	85 c0		 test	 eax, eax
  001ce	75 3f		 jne	 SHORT $LN472@inflate

; 658  :                 state->wbits = len;

  001d0	41 89 4e 28	 mov	 DWORD PTR [r14+40], ecx
$LN470@inflate:

; 663  :             }
; 664  :             state->dmax = 1U << len;

  001d4	b8 01 00 00 00	 mov	 eax, 1

; 665  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 666  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001d9	45 33 c0	 xor	 r8d, r8d
  001dc	33 d2		 xor	 edx, edx
  001de	d3 e0		 shl	 eax, cl
  001e0	33 c9		 xor	 ecx, ecx
  001e2	41 89 46 14	 mov	 DWORD PTR [r14+20], eax
  001e6	e8 00 00 00 00	 call	 adler32

; 667  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  001eb	41 c1 ed 08	 shr	 r13d, 8
  001ef	41 f7 d5	 not	 r13d
  001f2	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
  001f6	89 43 4c	 mov	 DWORD PTR [rbx+76], eax
  001f9	41 83 e5 02	 and	 r13d, 2

; 668  :             INITBITS();

  001fd	41 8b ff	 mov	 edi, r15d
  00200	41 83 cd 09	 or	 r13d, 9
  00204	45 89 2e	 mov	 DWORD PTR [r14], r13d
  00207	45 8b ef	 mov	 r13d, r15d

; 669  :             break;

  0020a	e9 c8 04 00 00	 jmp	 $LN745@inflate
$LN472@inflate:

; 659  :             else if (len > state->wbits) {

  0020f	3b c8		 cmp	 ecx, eax
  00211	76 c1		 jbe	 SHORT $LN470@inflate

; 660  :                 strm->msg = (char *)"invalid window size";

  00213	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
  0021a	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 661  :                 state->mode = BAD;

  0021e	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 662  :                 break;

  00225	e9 b5 04 00 00	 jmp	 $LN498@inflate
$LN477@inflate:

; 646  :                 strm->msg = (char *)"incorrect header check";

  0022a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
  00231	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 647  :                 state->mode = BAD;

  00235	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 648  :                 break;

  0023c	e9 9e 04 00 00	 jmp	 $LN498@inflate
$LN465@inflate:

; 670  : #ifdef GUNZIP
; 671  :         case FLAGS:
; 672  :             NEEDBITS(16);

  00241	83 ff 10	 cmp	 edi, 16
  00244	73 21		 jae	 SHORT $LN464@inflate
$LL462@inflate:
  00246	85 f6		 test	 esi, esi
  00248	0f 84 0f 06 00
	00		 je	 $LN782@inflate
  0024e	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00253	8b cf		 mov	 ecx, edi
  00255	83 c7 08	 add	 edi, 8
  00258	d3 e0		 shl	 eax, cl
  0025a	ff ce		 dec	 esi
  0025c	49 ff c4	 inc	 r12
  0025f	44 03 e8	 add	 r13d, eax
  00262	83 ff 10	 cmp	 edi, 16
  00265	72 df		 jb	 SHORT $LL462@inflate
$LN464@inflate:

; 673  :             state->flags = (int)(hold);

  00267	45 89 6e 10	 mov	 DWORD PTR [r14+16], r13d

; 674  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  0026b	41 80 fd 08	 cmp	 r13b, 8

; 675  :                 strm->msg = (char *)"unknown compression method";
; 676  :                 state->mode = BAD;
; 677  :                 break;

  0026f	0f 85 2c ff ff
	ff		 jne	 $LN821@inflate

; 678  :             }
; 679  :             if (state->flags & 0xe000) {

  00275	41 f7 c5 00 e0
	00 00		 test	 r13d, 57344		; 0000e000H
  0027c	74 17		 je	 SHORT $LN455@inflate

; 680  :                 strm->msg = (char *)"unknown header flags set";

  0027e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
  00285	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  00289	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29
  00290	e9 4a 04 00 00	 jmp	 $LN498@inflate
$LN455@inflate:

; 681  :                 state->mode = BAD;
; 682  :                 break;
; 683  :             }
; 684  :             if (state->head != Z_NULL)

  00295	49 8b 4e 20	 mov	 rcx, QWORD PTR [r14+32]
  00299	48 85 c9	 test	 rcx, rcx
  0029c	74 0b		 je	 SHORT $LN454@inflate

; 685  :                 state->head->text = (int)((hold >> 8) & 1);

  0029e	41 8b c5	 mov	 eax, r13d
  002a1	c1 e8 08	 shr	 eax, 8
  002a4	83 e0 01	 and	 eax, 1
  002a7	89 01		 mov	 DWORD PTR [rcx], eax
$LN454@inflate:

; 686  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  002a9	41 f7 46 10 00
	02 00 00	 test	 DWORD PTR [r14+16], 512	; 00000200H
  002b1	74 23		 je	 SHORT $LN450@inflate
  002b3	44 88 6d b0	 mov	 BYTE PTR hbuf$[rbp-128], r13b
  002b7	41 c1 ed 08	 shr	 r13d, 8
  002bb	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  002bf	44 88 6d b1	 mov	 BYTE PTR hbuf$[rbp-127], r13b
  002c3	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  002c7	41 b8 02 00 00
	00		 mov	 r8d, 2
  002cd	e8 00 00 00 00	 call	 crc32
  002d2	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
$LN450@inflate:

; 687  :             INITBITS();

  002d6	45 8b ef	 mov	 r13d, r15d
  002d9	41 8b ff	 mov	 edi, r15d

; 688  :             state->mode = TIME;

  002dc	41 c7 06 02 00
	00 00		 mov	 DWORD PTR [r14], 2

; 689  :         case TIME:
; 690  :             NEEDBITS(32);

  002e3	eb 0b		 jmp	 SHORT $LL442@inflate
$LN445@inflate:
  002e5	83 ff 20	 cmp	 edi, 32			; 00000020H
  002e8	73 27		 jae	 SHORT $LN444@inflate
  002ea	66 0f 1f 44 00
	00		 npad	 6
$LL442@inflate:
  002f0	85 f6		 test	 esi, esi
  002f2	0f 84 65 05 00
	00		 je	 $LN782@inflate
  002f8	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  002fd	8b cf		 mov	 ecx, edi
  002ff	83 c7 08	 add	 edi, 8
  00302	d3 e0		 shl	 eax, cl
  00304	ff ce		 dec	 esi
  00306	49 ff c4	 inc	 r12
  00309	44 03 e8	 add	 r13d, eax
  0030c	83 ff 20	 cmp	 edi, 32			; 00000020H
  0030f	72 df		 jb	 SHORT $LL442@inflate
$LN444@inflate:

; 691  :             if (state->head != Z_NULL)

  00311	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  00315	48 85 c0	 test	 rax, rax
  00318	74 04		 je	 SHORT $LN436@inflate

; 692  :                 state->head->time = hold;

  0031a	44 89 68 04	 mov	 DWORD PTR [rax+4], r13d
$LN436@inflate:

; 693  :             if (state->flags & 0x0200) CRC4(state->check, hold);

  0031e	41 f7 46 10 00
	02 00 00	 test	 DWORD PTR [r14+16], 512	; 00000200H
  00326	74 35		 je	 SHORT $LN432@inflate
  00328	41 8b c5	 mov	 eax, r13d
  0032b	44 88 6d b0	 mov	 BYTE PTR hbuf$[rbp-128], r13b
  0032f	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  00333	c1 e8 08	 shr	 eax, 8
  00336	41 b8 04 00 00
	00		 mov	 r8d, 4
  0033c	88 45 b1	 mov	 BYTE PTR hbuf$[rbp-127], al
  0033f	41 8b c5	 mov	 eax, r13d
  00342	41 c1 ed 18	 shr	 r13d, 24
  00346	c1 e8 10	 shr	 eax, 16
  00349	44 88 6d b3	 mov	 BYTE PTR hbuf$[rbp-125], r13b
  0034d	88 45 b2	 mov	 BYTE PTR hbuf$[rbp-126], al
  00350	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  00354	e8 00 00 00 00	 call	 crc32
  00359	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
$LN432@inflate:

; 694  :             INITBITS();

  0035d	45 8b ef	 mov	 r13d, r15d
  00360	41 8b ff	 mov	 edi, r15d

; 695  :             state->mode = OS;

  00363	41 c7 06 03 00
	00 00		 mov	 DWORD PTR [r14], 3

; 696  :         case OS:
; 697  :             NEEDBITS(16);

  0036a	eb 05		 jmp	 SHORT $LL424@inflate
$LN427@inflate:
  0036c	83 ff 10	 cmp	 edi, 16
  0036f	73 21		 jae	 SHORT $LN426@inflate
$LL424@inflate:
  00371	85 f6		 test	 esi, esi
  00373	0f 84 e4 04 00
	00		 je	 $LN782@inflate
  00379	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  0037e	8b cf		 mov	 ecx, edi
  00380	83 c7 08	 add	 edi, 8
  00383	d3 e0		 shl	 eax, cl
  00385	ff ce		 dec	 esi
  00387	49 ff c4	 inc	 r12
  0038a	44 03 e8	 add	 r13d, eax
  0038d	83 ff 10	 cmp	 edi, 16
  00390	72 df		 jb	 SHORT $LL424@inflate
$LN426@inflate:

; 698  :             if (state->head != Z_NULL) {

  00392	49 8b 4e 20	 mov	 rcx, QWORD PTR [r14+32]
  00396	48 85 c9	 test	 rcx, rcx
  00399	74 14		 je	 SHORT $LN418@inflate

; 699  :                 state->head->xflags = (int)(hold & 0xff);

  0039b	41 0f b6 c5	 movzx	 eax, r13b
  0039f	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 700  :                 state->head->os = (int)(hold >> 8);

  003a2	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  003a6	41 8b cd	 mov	 ecx, r13d
  003a9	c1 e9 08	 shr	 ecx, 8
  003ac	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN418@inflate:

; 701  :             }
; 702  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  003af	41 f7 46 10 00
	02 00 00	 test	 DWORD PTR [r14+16], 512	; 00000200H
  003b7	74 23		 je	 SHORT $LN414@inflate
  003b9	44 88 6d b0	 mov	 BYTE PTR hbuf$[rbp-128], r13b
  003bd	41 c1 ed 08	 shr	 r13d, 8
  003c1	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  003c5	44 88 6d b1	 mov	 BYTE PTR hbuf$[rbp-127], r13b
  003c9	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  003cd	41 b8 02 00 00
	00		 mov	 r8d, 2
  003d3	e8 00 00 00 00	 call	 crc32
  003d8	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
$LN414@inflate:

; 703  :             INITBITS();

  003dc	45 8b ef	 mov	 r13d, r15d
  003df	41 8b ff	 mov	 edi, r15d

; 704  :             state->mode = EXLEN;

  003e2	41 c7 06 04 00
	00 00		 mov	 DWORD PTR [r14], 4
$LN410@inflate:

; 705  :         case EXLEN:
; 706  :             if (state->flags & 0x0400) {

  003e9	41 f7 46 10 00
	04 00 00	 test	 DWORD PTR [r14+16], 1024 ; 00000400H
  003f1	74 6c		 je	 SHORT $LN409@inflate

; 707  :                 NEEDBITS(16);

  003f3	83 ff 10	 cmp	 edi, 16
  003f6	73 21		 jae	 SHORT $LN407@inflate
$LL405@inflate:
  003f8	85 f6		 test	 esi, esi
  003fa	0f 84 5d 04 00
	00		 je	 $LN782@inflate
  00400	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00405	8b cf		 mov	 ecx, edi
  00407	83 c7 08	 add	 edi, 8
  0040a	d3 e0		 shl	 eax, cl
  0040c	ff ce		 dec	 esi
  0040e	49 ff c4	 inc	 r12
  00411	44 03 e8	 add	 r13d, eax
  00414	83 ff 10	 cmp	 edi, 16
  00417	72 df		 jb	 SHORT $LL405@inflate
$LN407@inflate:

; 708  :                 state->length = (unsigned)(hold);
; 709  :                 if (state->head != Z_NULL)

  00419	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  0041d	45 89 6e 48	 mov	 DWORD PTR [r14+72], r13d
  00421	48 85 c0	 test	 rax, rax
  00424	74 04		 je	 SHORT $LN399@inflate

; 710  :                     state->head->extra_len = (unsigned)hold;

  00426	44 89 68 18	 mov	 DWORD PTR [rax+24], r13d
$LN399@inflate:

; 711  :                 if (state->flags & 0x0200) CRC2(state->check, hold);

  0042a	41 f7 46 10 00
	02 00 00	 test	 DWORD PTR [r14+16], 512	; 00000200H
  00432	74 23		 je	 SHORT $LN395@inflate
  00434	44 88 6d b0	 mov	 BYTE PTR hbuf$[rbp-128], r13b
  00438	41 c1 ed 08	 shr	 r13d, 8
  0043c	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  00440	44 88 6d b1	 mov	 BYTE PTR hbuf$[rbp-127], r13b
  00444	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  00448	41 b8 02 00 00
	00		 mov	 r8d, 2
  0044e	e8 00 00 00 00	 call	 crc32
  00453	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
$LN395@inflate:

; 712  :                 INITBITS();

  00457	45 8b ef	 mov	 r13d, r15d
  0045a	41 8b ff	 mov	 edi, r15d

; 713  :             }
; 714  :             else if (state->head != Z_NULL)

  0045d	eb 0d		 jmp	 SHORT $LN390@inflate
$LN409@inflate:
  0045f	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  00463	48 85 c0	 test	 rax, rax
  00466	74 04		 je	 SHORT $LN390@inflate

; 715  :                 state->head->extra = Z_NULL;

  00468	4c 89 78 10	 mov	 QWORD PTR [rax+16], r15
$LN390@inflate:

; 716  :             state->mode = EXTRA;

  0046c	41 c7 06 05 00
	00 00		 mov	 DWORD PTR [r14], 5
$LN389@inflate:

; 717  :         case EXTRA:
; 718  :             if (state->flags & 0x0400) {

  00473	41 f7 46 10 00
	04 00 00	 test	 DWORD PTR [r14+16], 1024 ; 00000400H
  0047b	74 79		 je	 SHORT $LN383@inflate

; 719  :                 copy = state->length;

  0047d	41 8b 4e 48	 mov	 ecx, DWORD PTR [r14+72]

; 720  :                 if (copy > have) copy = have;

  00481	3b ce		 cmp	 ecx, esi
  00483	8b d9		 mov	 ebx, ecx
  00485	0f 47 de	 cmova	 ebx, esi

; 721  :                 if (copy) {

  00488	85 db		 test	 ebx, ebx
  0048a	74 5f		 je	 SHORT $LN386@inflate

; 722  :                     if (state->head != Z_NULL &&
; 723  :                         state->head->extra != Z_NULL) {

  0048c	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  00490	48 85 c0	 test	 rax, rax
  00493	74 2e		 je	 SHORT $LN385@inflate
  00495	4c 8b 48 10	 mov	 r9, QWORD PTR [rax+16]
  00499	4d 85 c9	 test	 r9, r9
  0049c	74 25		 je	 SHORT $LN385@inflate

; 724  :                         len = state->head->extra_len - state->length;

  0049e	8b 50 18	 mov	 edx, DWORD PTR [rax+24]
  004a1	2b d1		 sub	 edx, ecx

; 725  :                         zmemcpy(state->head->extra + len, next,
; 726  :                                 len + copy > state->head->extra_max ?
; 727  :                                 state->head->extra_max - len : copy);

  004a3	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  004a6	8d 04 13	 lea	 eax, DWORD PTR [rbx+rdx]
  004a9	3b c1		 cmp	 eax, ecx
  004ab	76 04		 jbe	 SHORT $LN510@inflate
  004ad	2b ca		 sub	 ecx, edx
  004af	eb 02		 jmp	 SHORT $LN511@inflate
$LN510@inflate:
  004b1	8b cb		 mov	 ecx, ebx
$LN511@inflate:
  004b3	44 8b c1	 mov	 r8d, ecx
  004b6	8b ca		 mov	 ecx, edx
  004b8	49 8b d4	 mov	 rdx, r12
  004bb	49 03 c9	 add	 rcx, r9
  004be	e8 00 00 00 00	 call	 memcpy
$LN385@inflate:

; 728  :                     }
; 729  :                     if (state->flags & 0x0200)

  004c3	41 f7 46 10 00
	02 00 00	 test	 DWORD PTR [r14+16], 512	; 00000200H
  004cb	74 13		 je	 SHORT $LN384@inflate

; 730  :                         state->check = crc32(state->check, next, copy);

  004cd	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  004d1	44 8b c3	 mov	 r8d, ebx
  004d4	49 8b d4	 mov	 rdx, r12
  004d7	e8 00 00 00 00	 call	 crc32
  004dc	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
$LN384@inflate:

; 731  :                     have -= copy;
; 732  :                     next += copy;

  004e0	8b c3		 mov	 eax, ebx
  004e2	2b f3		 sub	 esi, ebx
  004e4	4c 03 e0	 add	 r12, rax

; 733  :                     state->length -= copy;

  004e7	41 29 5e 48	 sub	 DWORD PTR [r14+72], ebx
$LN386@inflate:

; 734  :                 }
; 735  :                 if (state->length) goto inf_leave;

  004eb	41 83 7e 48 00	 cmp	 DWORD PTR [r14+72], 0
  004f0	0f 85 67 03 00
	00		 jne	 $LN782@inflate
$LN383@inflate:

; 736  :             }
; 737  :             state->length = 0;

  004f6	45 89 7e 48	 mov	 DWORD PTR [r14+72], r15d

; 738  :             state->mode = NAME;

  004fa	41 c7 06 06 00
	00 00		 mov	 DWORD PTR [r14], 6
$LN382@inflate:

; 739  :         case NAME:
; 740  :             if (state->flags & 0x0800) {

  00501	41 f7 46 10 00
	08 00 00	 test	 DWORD PTR [r14+16], 2048 ; 00000800H
  00509	74 7d		 je	 SHORT $LN381@inflate

; 741  :                 if (have == 0) goto inf_leave;

  0050b	85 f6		 test	 esi, esi
  0050d	0f 84 4a 03 00
	00		 je	 $LN782@inflate

; 742  :                 copy = 0;

  00513	4d 8b c4	 mov	 r8, r12
  00516	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL379@inflate:

; 743  :                 do {
; 744  :                     len = (unsigned)(next[copy++]);
; 745  :                     if (state->head != Z_NULL &&
; 746  :                             state->head->name != Z_NULL &&
; 747  :                             state->length < state->head->name_max)

  00520	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  00524	41 0f b6 18	 movzx	 ebx, BYTE PTR [r8]
  00528	41 ff c7	 inc	 r15d
  0052b	49 ff c0	 inc	 r8
  0052e	48 85 c0	 test	 rax, rax
  00531	74 19		 je	 SHORT $LN378@inflate
  00533	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00537	48 85 d2	 test	 rdx, rdx
  0053a	74 10		 je	 SHORT $LN378@inflate
  0053c	41 8b 4e 48	 mov	 ecx, DWORD PTR [r14+72]
  00540	3b 48 28	 cmp	 ecx, DWORD PTR [rax+40]
  00543	73 07		 jae	 SHORT $LN378@inflate

; 748  :                         state->head->name[state->length++] = len;

  00545	88 1c 11	 mov	 BYTE PTR [rcx+rdx], bl
  00548	41 ff 46 48	 inc	 DWORD PTR [r14+72]
$LN378@inflate:

; 749  :                 } while (len && copy < have);

  0054c	85 db		 test	 ebx, ebx
  0054e	74 05		 je	 SHORT $LN375@inflate
  00550	44 3b fe	 cmp	 r15d, esi
  00553	72 cb		 jb	 SHORT $LL379@inflate
$LN375@inflate:

; 750  :                 if (state->flags & 0x0200)

  00555	41 f7 46 10 00
	02 00 00	 test	 DWORD PTR [r14+16], 512	; 00000200H
  0055d	74 13		 je	 SHORT $LN374@inflate

; 751  :                     state->check = crc32(state->check, next, copy);

  0055f	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  00563	45 8b c7	 mov	 r8d, r15d
  00566	49 8b d4	 mov	 rdx, r12
  00569	e8 00 00 00 00	 call	 crc32
  0056e	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
$LN374@inflate:

; 752  :                 have -= copy;
; 753  :                 next += copy;

  00572	41 8b c7	 mov	 eax, r15d
  00575	41 2b f7	 sub	 esi, r15d
  00578	4c 03 e0	 add	 r12, rax

; 754  :                 if (len) goto inf_leave;

  0057b	85 db		 test	 ebx, ebx
  0057d	0f 85 da 02 00
	00		 jne	 $LN782@inflate

; 755  :             }
; 756  :             else if (state->head != Z_NULL)

  00583	45 33 ff	 xor	 r15d, r15d
  00586	eb 0d		 jmp	 SHORT $LN371@inflate
$LN381@inflate:
  00588	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  0058c	48 85 c0	 test	 rax, rax
  0058f	74 04		 je	 SHORT $LN371@inflate

; 757  :                 state->head->name = Z_NULL;

  00591	4c 89 78 20	 mov	 QWORD PTR [rax+32], r15
$LN371@inflate:

; 758  :             state->length = 0;

  00595	45 89 7e 48	 mov	 DWORD PTR [r14+72], r15d

; 759  :             state->mode = COMMENT;

  00599	41 c7 06 07 00
	00 00		 mov	 DWORD PTR [r14], 7
$LN370@inflate:

; 760  :         case COMMENT:
; 761  :             if (state->flags & 0x1000) {

  005a0	41 f7 46 10 00
	10 00 00	 test	 DWORD PTR [r14+16], 4096 ; 00001000H
  005a8	74 7e		 je	 SHORT $LN369@inflate

; 762  :                 if (have == 0) goto inf_leave;

  005aa	85 f6		 test	 esi, esi
  005ac	0f 84 ab 02 00
	00		 je	 $LN782@inflate

; 763  :                 copy = 0;

  005b2	4d 8b c4	 mov	 r8, r12
  005b5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL367@inflate:

; 766  :                     if (state->head != Z_NULL &&
; 767  :                             state->head->comment != Z_NULL &&
; 768  :                             state->length < state->head->comm_max)

  005c0	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  005c4	41 0f b6 18	 movzx	 ebx, BYTE PTR [r8]
  005c8	41 ff c7	 inc	 r15d
  005cb	49 ff c0	 inc	 r8
  005ce	48 85 c0	 test	 rax, rax
  005d1	74 19		 je	 SHORT $LN366@inflate
  005d3	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  005d7	48 85 d2	 test	 rdx, rdx
  005da	74 10		 je	 SHORT $LN366@inflate
  005dc	41 8b 4e 48	 mov	 ecx, DWORD PTR [r14+72]
  005e0	3b 48 38	 cmp	 ecx, DWORD PTR [rax+56]
  005e3	73 07		 jae	 SHORT $LN366@inflate

; 769  :                         state->head->comment[state->length++] = len;

  005e5	88 1c 11	 mov	 BYTE PTR [rcx+rdx], bl
  005e8	41 ff 46 48	 inc	 DWORD PTR [r14+72]
$LN366@inflate:

; 770  :                 } while (len && copy < have);

  005ec	85 db		 test	 ebx, ebx
  005ee	74 05		 je	 SHORT $LN363@inflate
  005f0	44 3b fe	 cmp	 r15d, esi
  005f3	72 cb		 jb	 SHORT $LL367@inflate
$LN363@inflate:

; 771  :                 if (state->flags & 0x0200)

  005f5	41 f7 46 10 00
	02 00 00	 test	 DWORD PTR [r14+16], 512	; 00000200H
  005fd	74 13		 je	 SHORT $LN362@inflate

; 772  :                     state->check = crc32(state->check, next, copy);

  005ff	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  00603	45 8b c7	 mov	 r8d, r15d
  00606	49 8b d4	 mov	 rdx, r12
  00609	e8 00 00 00 00	 call	 crc32
  0060e	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
$LN362@inflate:

; 773  :                 have -= copy;
; 774  :                 next += copy;

  00612	41 8b c7	 mov	 eax, r15d
  00615	41 2b f7	 sub	 esi, r15d
  00618	4c 03 e0	 add	 r12, rax

; 775  :                 if (len) goto inf_leave;

  0061b	85 db		 test	 ebx, ebx
  0061d	0f 85 3a 02 00
	00		 jne	 $LN782@inflate

; 776  :             }
; 777  :             else if (state->head != Z_NULL)

  00623	45 33 ff	 xor	 r15d, r15d
  00626	eb 0d		 jmp	 SHORT $LN359@inflate
$LN369@inflate:
  00628	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  0062c	48 85 c0	 test	 rax, rax
  0062f	74 04		 je	 SHORT $LN359@inflate

; 778  :                 state->head->comment = Z_NULL;

  00631	4c 89 78 30	 mov	 QWORD PTR [rax+48], r15
$LN359@inflate:
  00635	48 8b 5d 20	 mov	 rbx, QWORD PTR strm$[rbp-128]
  00639	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  0063d	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]

; 779  :             state->mode = HCRC;

  00641	41 c7 06 08 00
	00 00		 mov	 DWORD PTR [r14], 8
$LN358@inflate:

; 780  :         case HCRC:
; 781  :             if (state->flags & 0x0200) {

  00648	41 f7 46 10 00
	02 00 00	 test	 DWORD PTR [r14+16], 512	; 00000200H
  00650	74 4a		 je	 SHORT $LN344@inflate

; 782  :                 NEEDBITS(16);

  00652	83 ff 10	 cmp	 edi, 16
  00655	73 21		 jae	 SHORT $LN355@inflate
$LL353@inflate:
  00657	85 f6		 test	 esi, esi
  00659	0f 84 fe 01 00
	00		 je	 $LN782@inflate
  0065f	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00664	8b cf		 mov	 ecx, edi
  00666	83 c7 08	 add	 edi, 8
  00669	d3 e0		 shl	 eax, cl
  0066b	ff ce		 dec	 esi
  0066d	49 ff c4	 inc	 r12
  00670	44 03 e8	 add	 r13d, eax
  00673	83 ff 10	 cmp	 edi, 16
  00676	72 df		 jb	 SHORT $LL353@inflate
$LN355@inflate:

; 783  :                 if (hold != (state->check & 0xffff)) {

  00678	41 0f b7 46 18	 movzx	 eax, WORD PTR [r14+24]
  0067d	44 3b e8	 cmp	 r13d, eax
  00680	74 14		 je	 SHORT $LN346@inflate

; 784  :                     strm->msg = (char *)"header crc mismatch";

  00682	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
  00689	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  0068d	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29
  00694	eb 49		 jmp	 SHORT $LN498@inflate
$LN346@inflate:

; 785  :                     state->mode = BAD;
; 786  :                     break;
; 787  :                 }
; 788  :                 INITBITS();

  00696	45 8b ef	 mov	 r13d, r15d
  00699	41 8b ff	 mov	 edi, r15d
$LN344@inflate:

; 789  :             }
; 790  :             if (state->head != Z_NULL) {

  0069c	49 8b 4e 20	 mov	 rcx, QWORD PTR [r14+32]
  006a0	48 85 c9	 test	 rcx, rcx
  006a3	74 18		 je	 SHORT $LN343@inflate

; 791  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  006a5	41 8b 46 10	 mov	 eax, DWORD PTR [r14+16]
  006a9	c1 f8 09	 sar	 eax, 9
  006ac	83 e0 01	 and	 eax, 1
  006af	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 792  :                 state->head->done = 1;

  006b2	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  006b6	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1
$LN343@inflate:

; 793  :             }
; 794  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  006bd	45 33 c0	 xor	 r8d, r8d
  006c0	33 d2		 xor	 edx, edx
  006c2	33 c9		 xor	 ecx, ecx
  006c4	e8 00 00 00 00	 call	 crc32
  006c9	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
  006cd	89 43 4c	 mov	 DWORD PTR [rbx+76], eax
$LN820@inflate:

; 1045 :                 state->mode = TYPE;

  006d0	41 c7 06 0b 00
	00 00		 mov	 DWORD PTR [r14], 11
$LN745@inflate:

; 939  :                             break;

  006d7	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  006db	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]
$LN498@inflate:

; 622  :     for (;;)
; 623  :         switch (state->mode) {

  006df	41 8b 06	 mov	 eax, DWORD PTR [r14]
  006e2	83 f8 1e	 cmp	 eax, 30
  006e5	0f 87 57 0f 00
	00		 ja	 $LN11@inflate
  006eb	44 8b 45 b8	 mov	 r8d, DWORD PTR out$1$[rbp-128]
  006ef	8b 55 28	 mov	 edx, DWORD PTR flush$[rbp-128]
  006f2	45 33 ff	 xor	 r15d, r15d
  006f5	e9 b3 f9 ff ff	 jmp	 $LN823@inflate
$LN341@inflate:

; 795  :             state->mode = TYPE;
; 796  :             break;
; 797  : #endif
; 798  :         case DICTID:
; 799  :             NEEDBITS(32);

  006fa	83 ff 20	 cmp	 edi, 32			; 00000020H
  006fd	73 22		 jae	 SHORT $LN340@inflate
  006ff	90		 npad	 1
$LL338@inflate:
  00700	85 f6		 test	 esi, esi
  00702	0f 84 55 01 00
	00		 je	 $LN782@inflate
  00708	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  0070d	8b cf		 mov	 ecx, edi
  0070f	83 c7 08	 add	 edi, 8
  00712	d3 e0		 shl	 eax, cl
  00714	ff ce		 dec	 esi
  00716	49 ff c4	 inc	 r12
  00719	44 03 e8	 add	 r13d, eax
  0071c	83 ff 20	 cmp	 edi, 32			; 00000020H
  0071f	72 df		 jb	 SHORT $LL338@inflate
$LN340@inflate:

; 800  :             strm->adler = state->check = REVERSE(hold);

  00721	41 8b cd	 mov	 ecx, r13d
  00724	41 8b c5	 mov	 eax, r13d

; 801  :             INITBITS();

  00727	41 8b ff	 mov	 edi, r15d
  0072a	c1 e0 10	 shl	 eax, 16
  0072d	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00733	03 c8		 add	 ecx, eax
  00735	41 8b c5	 mov	 eax, r13d
  00738	41 c1 ed 18	 shr	 r13d, 24
  0073c	c1 e8 08	 shr	 eax, 8
  0073f	c1 e1 08	 shl	 ecx, 8
  00742	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00747	03 c1		 add	 eax, ecx
  00749	41 03 c5	 add	 eax, r13d
  0074c	45 8b ef	 mov	 r13d, r15d
  0074f	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
  00753	89 43 4c	 mov	 DWORD PTR [rbx+76], eax

; 802  :             state->mode = DICT;

  00756	41 c7 06 0a 00
	00 00		 mov	 DWORD PTR [r14], 10
$LN329@inflate:

; 803  :         case DICT:
; 804  :             if (state->havedict == 0) {

  0075d	41 83 7e 0c 00	 cmp	 DWORD PTR [r14+12], 0
  00762	0f 84 dd 0d 00
	00		 je	 $LN589@inflate

; 807  :             }
; 808  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00768	45 33 c0	 xor	 r8d, r8d
  0076b	33 d2		 xor	 edx, edx
  0076d	33 c9		 xor	 ecx, ecx
  0076f	e8 00 00 00 00	 call	 adler32
  00774	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  00778	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]
  0077c	8b 55 28	 mov	 edx, DWORD PTR flush$[rbp-128]
  0077f	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
  00783	89 43 4c	 mov	 DWORD PTR [rbx+76], eax

; 809  :             state->mode = TYPE;

  00786	41 c7 06 0b 00
	00 00		 mov	 DWORD PTR [r14], 11
$LN324@inflate:

; 810  :         case TYPE:
; 811  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  0078d	83 fa 05	 cmp	 edx, 5
  00790	0f 84 c7 00 00
	00		 je	 $LN782@inflate
  00796	83 fa 06	 cmp	 edx, 6
  00799	0f 84 be 00 00
	00		 je	 $LN782@inflate
$LN323@inflate:

; 812  :         case TYPEDO:
; 813  :             if (state->last) {

  0079f	41 83 7e 04 00	 cmp	 DWORD PTR [r14+4], 0
  007a4	74 16		 je	 SHORT $LN316@inflate

; 814  :                 BYTEBITS();

  007a6	8b cf		 mov	 ecx, edi

; 815  :                 state->mode = CHECK;

  007a8	41 c7 06 1a 00
	00 00		 mov	 DWORD PTR [r14], 26
  007af	83 e1 07	 and	 ecx, 7
  007b2	41 d3 ed	 shr	 r13d, cl
  007b5	2b f9		 sub	 edi, ecx

; 816  :                 break;

  007b7	e9 23 ff ff ff	 jmp	 $LN498@inflate
$LN316@inflate:

; 817  :             }
; 818  :             NEEDBITS(3);

  007bc	83 ff 03	 cmp	 edi, 3
  007bf	73 21		 jae	 SHORT $LN315@inflate
$LL313@inflate:
  007c1	85 f6		 test	 esi, esi
  007c3	0f 84 94 00 00
	00		 je	 $LN782@inflate
  007c9	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  007ce	8b cf		 mov	 ecx, edi
  007d0	83 c7 08	 add	 edi, 8
  007d3	d3 e0		 shl	 eax, cl
  007d5	ff ce		 dec	 esi
  007d7	49 ff c4	 inc	 r12
  007da	44 03 e8	 add	 r13d, eax
  007dd	83 ff 03	 cmp	 edi, 3
  007e0	72 df		 jb	 SHORT $LL313@inflate
$LN315@inflate:

; 819  :             state->last = BITS(1);

  007e2	41 8b c5	 mov	 eax, r13d

; 820  :             DROPBITS(1);

  007e5	41 d1 ed	 shr	 r13d, 1
  007e8	ff cf		 dec	 edi
  007ea	83 e0 01	 and	 eax, 1
  007ed	41 89 46 04	 mov	 DWORD PTR [r14+4], eax

; 821  :             switch (BITS(2)) {

  007f1	41 8b c5	 mov	 eax, r13d
  007f4	83 e0 03	 and	 eax, 3
  007f7	0f 84 e4 00 00
	00		 je	 $LN302@inflate
  007fd	ff c8		 dec	 eax
  007ff	74 3d		 je	 SHORT $LN301@inflate
  00801	ff c8		 dec	 eax
  00803	74 26		 je	 SHORT $LN296@inflate
  00805	ff c8		 dec	 eax
  00807	0f 85 db 00 00
	00		 jne	 $LN294@inflate

; 834  :                     goto inf_leave;
; 835  :                 }
; 836  :                 break;
; 837  :             case 2:                             /* dynamic block */
; 838  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 839  :                         state->last ? " (last)" : ""));
; 840  :                 state->mode = TABLE;
; 841  :                 break;
; 842  :             case 3:
; 843  :                 strm->msg = (char *)"invalid block type";

  0080d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 844  :                 state->mode = BAD;
; 845  :             }
; 846  :             DROPBITS(2);

  00814	41 c1 ed 02	 shr	 r13d, 2
  00818	83 c7 fe	 add	 edi, -2			; fffffffeH
  0081b	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  0081f	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 847  :             break;

  00826	e9 b4 fe ff ff	 jmp	 $LN498@inflate
$LN296@inflate:

; 844  :                 state->mode = BAD;
; 845  :             }
; 846  :             DROPBITS(2);

  0082b	41 c1 ed 02	 shr	 r13d, 2
  0082f	41 c7 06 10 00
	00 00		 mov	 DWORD PTR [r14], 16
  00836	83 c7 fe	 add	 edi, -2			; fffffffeH

; 847  :             break;

  00839	e9 a1 fe ff ff	 jmp	 $LN498@inflate
$LN301@inflate:

; 826  :                 break;
; 827  :             case 1:                             /* fixed block */
; 828  :                 fixedtables(state);

  0083e	49 8b ce	 mov	 rcx, r14
  00841	e8 00 00 00 00	 call	 fixedtables

; 829  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 830  :                         state->last ? " (last)" : ""));
; 831  :                 state->mode = LEN_;             /* decode codes */

  00846	41 c7 06 13 00
	00 00		 mov	 DWORD PTR [r14], 19

; 832  :                 if (flush == Z_TREES) {

  0084d	83 fa 06	 cmp	 edx, 6
  00850	0f 85 92 00 00
	00		 jne	 $LN294@inflate

; 833  :                     DROPBITS(2);

  00856	41 c1 ed 02	 shr	 r13d, 2
  0085a	83 c7 fe	 add	 edi, -2			; fffffffeH
$LN782@inflate:

; 993  :             state->distbits = 6;
; 994  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 995  :                             &(state->next), &(state->distbits), state->work);

  0085d	44 8b 7d 30	 mov	 r15d, DWORD PTR ret$1$[rbp-128]
$inf_leave$5023:

; 1207 :         }
; 1208 : 
; 1209 :     /*
; 1210 :        Return from inflate(), updating the total counts and the check value.
; 1211 :        If there was no progress during the inflate() call, return a buffer
; 1212 :        error.  Call updatewindow() to create and/or update the window state.
; 1213 :        Note: a memory error from inflate() is non-recoverable.
; 1214 :      */
; 1215 :   inf_leave:
; 1216 :     RESTORE();

  00861	48 8b 5d 20	 mov	 rbx, QWORD PTR strm$[rbp-128]
  00865	48 8b 45 c0	 mov	 rax, QWORD PTR put$1$[rbp-128]
  00869	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
  0086d	8b 45 38	 mov	 eax, DWORD PTR left$1$[rbp-128]
  00870	4c 89 23	 mov	 QWORD PTR [rbx], r12
  00873	89 43 18	 mov	 DWORD PTR [rbx+24], eax
  00876	89 73 08	 mov	 DWORD PTR [rbx+8], esi

; 1217 :     if (state->wsize || (state->mode < CHECK && out != strm->avail_out))

  00879	41 83 7e 2c 00	 cmp	 DWORD PTR [r14+44], 0
  0087e	41 89 7e 44	 mov	 DWORD PTR [r14+68], edi
  00882	8b 7d b8	 mov	 edi, DWORD PTR out$1$[rbp-128]
  00885	45 89 6e 40	 mov	 DWORD PTR [r14+64], r13d
  00889	75 13		 jne	 SHORT $LN6@inflate
  0088b	41 83 3e 1a	 cmp	 DWORD PTR [r14], 26
  0088f	0f 8d f3 0c 00
	00		 jge	 $LN5@inflate
  00895	3b 7b 18	 cmp	 edi, DWORD PTR [rbx+24]
  00898	0f 84 ea 0c 00
	00		 je	 $LN5@inflate
$LN6@inflate:

; 1218 :         if (updatewindow(strm, out)) {

  0089e	8b d7		 mov	 edx, edi
  008a0	48 8b cb	 mov	 rcx, rbx
  008a3	e8 00 00 00 00	 call	 updatewindow
  008a8	85 c0		 test	 eax, eax
  008aa	0f 84 d8 0c 00
	00		 je	 $LN5@inflate

; 1219 :             state->mode = MEM;

  008b0	41 c7 06 1e 00
	00 00		 mov	 DWORD PTR [r14], 30
$LN12@inflate:

; 1220 :             return Z_MEM_ERROR;

  008b7	b8 fc ff ff ff	 mov	 eax, -4
$LN816@inflate:
  008bc	4c 8b 6c 24 60	 mov	 r13, QWORD PTR [rsp+96]
  008c1	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  008c6	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
  008cb	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  008d0	4c 8b 7c 24 58	 mov	 r15, QWORD PTR [rsp+88]

; 1236 : }

  008d5	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  008dc	41 5e		 pop	 r14
  008de	5b		 pop	 rbx
  008df	5d		 pop	 rbp
  008e0	c3		 ret	 0
$LN302@inflate:

; 822  :             case 0:                             /* stored block */
; 823  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 824  :                         state->last ? " (last)" : ""));
; 825  :                 state->mode = STORED;

  008e1	41 c7 06 0d 00
	00 00		 mov	 DWORD PTR [r14], 13
$LN294@inflate:

; 844  :                 state->mode = BAD;
; 845  :             }
; 846  :             DROPBITS(2);

  008e8	41 c1 ed 02	 shr	 r13d, 2
  008ec	83 c7 fe	 add	 edi, -2			; fffffffeH

; 847  :             break;

  008ef	e9 eb fd ff ff	 jmp	 $LN498@inflate
$LN290@inflate:

; 848  :         case STORED:
; 849  :             BYTEBITS();                         /* go to byte boundary */

  008f4	8b cf		 mov	 ecx, edi
  008f6	83 e1 07	 and	 ecx, 7
  008f9	2b f9		 sub	 edi, ecx
  008fb	41 d3 ed	 shr	 r13d, cl

; 850  :             NEEDBITS(32);

  008fe	83 ff 20	 cmp	 edi, 32			; 00000020H
  00901	73 21		 jae	 SHORT $LN286@inflate
$LL284@inflate:
  00903	85 f6		 test	 esi, esi
  00905	0f 84 52 ff ff
	ff		 je	 $LN782@inflate
  0090b	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00910	8b cf		 mov	 ecx, edi
  00912	83 c7 08	 add	 edi, 8
  00915	d3 e0		 shl	 eax, cl
  00917	ff ce		 dec	 esi
  00919	49 ff c4	 inc	 r12
  0091c	44 03 e8	 add	 r13d, eax
  0091f	83 ff 20	 cmp	 edi, 32			; 00000020H
  00922	72 df		 jb	 SHORT $LL284@inflate
$LN286@inflate:

; 851  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  00924	41 8b c5	 mov	 eax, r13d
  00927	41 0f b7 cd	 movzx	 ecx, r13w
  0092b	f7 d0		 not	 eax
  0092d	c1 e8 10	 shr	 eax, 16
  00930	3b c8		 cmp	 ecx, eax
  00932	74 17		 je	 SHORT $LN278@inflate

; 852  :                 strm->msg = (char *)"invalid stored block lengths";

  00934	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  0093b	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  0093f	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29
  00946	e9 94 fd ff ff	 jmp	 $LN498@inflate
$LN278@inflate:

; 853  :                 state->mode = BAD;
; 854  :                 break;
; 855  :             }
; 856  :             state->length = (unsigned)hold & 0xffff;

  0094b	41 89 4e 48	 mov	 DWORD PTR [r14+72], ecx

; 857  :             Tracev((stderr, "inflate:       stored length %u\n",
; 858  :                     state->length));
; 859  :             INITBITS();

  0094f	45 8b ef	 mov	 r13d, r15d
  00952	41 8b ff	 mov	 edi, r15d

; 860  :             state->mode = COPY_;

  00955	41 c7 06 0e 00
	00 00		 mov	 DWORD PTR [r14], 14

; 861  :             if (flush == Z_TREES) goto inf_leave;

  0095c	83 fa 06	 cmp	 edx, 6
  0095f	0f 84 f8 fe ff
	ff		 je	 $LN782@inflate
$LN274@inflate:

; 862  :         case COPY_:
; 863  :             state->mode = COPY;

  00965	41 c7 06 0f 00
	00 00		 mov	 DWORD PTR [r14], 15
$LN272@inflate:

; 864  :         case COPY:
; 865  :             copy = state->length;

  0096c	45 8b 7e 48	 mov	 r15d, DWORD PTR [r14+72]

; 866  :             if (copy) {

  00970	45 85 ff	 test	 r15d, r15d
  00973	74 51		 je	 SHORT $LN271@inflate

; 867  :                 if (copy > have) copy = have;

  00975	44 3b fe	 cmp	 r15d, esi
  00978	44 0f 47 fe	 cmova	 r15d, esi

; 868  :                 if (copy > left) copy = left;

  0097c	45 3b fa	 cmp	 r15d, r10d
  0097f	45 0f 47 fa	 cmova	 r15d, r10d

; 869  :                 if (copy == 0) goto inf_leave;

  00983	45 85 ff	 test	 r15d, r15d
  00986	0f 84 d1 fe ff
	ff		 je	 $LN782@inflate

; 870  :                 zmemcpy(put, next, copy);

  0098c	45 8b c7	 mov	 r8d, r15d
  0098f	49 8b d4	 mov	 rdx, r12
  00992	49 8b c9	 mov	 rcx, r9
  00995	41 8b df	 mov	 ebx, r15d
  00998	e8 00 00 00 00	 call	 memcpy

; 871  :                 have -= copy;
; 872  :                 next += copy;
; 873  :                 left -= copy;

  0099d	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]

; 874  :                 put += copy;

  009a1	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  009a5	45 2b d7	 sub	 r10d, r15d
  009a8	4c 03 e3	 add	 r12, rbx
  009ab	4c 03 cb	 add	 r9, rbx

; 875  :                 state->length -= copy;
; 876  :                 break;

  009ae	48 8b 5d 20	 mov	 rbx, QWORD PTR strm$[rbp-128]
  009b2	41 2b f7	 sub	 esi, r15d
  009b5	45 29 7e 48	 sub	 DWORD PTR [r14+72], r15d
  009b9	44 89 55 38	 mov	 DWORD PTR left$1$[rbp-128], r10d
  009bd	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9
  009c1	e9 19 fd ff ff	 jmp	 $LN498@inflate
$LN271@inflate:

; 877  :             }
; 878  :             Tracev((stderr, "inflate:       stored end\n"));
; 879  :             state->mode = TYPE;

  009c6	41 c7 06 0b 00
	00 00		 mov	 DWORD PTR [r14], 11

; 880  :             break;

  009cd	e9 0d fd ff ff	 jmp	 $LN498@inflate
$LN266@inflate:

; 881  :         case TABLE:
; 882  :             NEEDBITS(14);

  009d2	83 ff 0e	 cmp	 edi, 14
  009d5	73 21		 jae	 SHORT $LN265@inflate
$LL263@inflate:
  009d7	85 f6		 test	 esi, esi
  009d9	0f 84 7e fe ff
	ff		 je	 $LN782@inflate
  009df	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  009e4	8b cf		 mov	 ecx, edi
  009e6	83 c7 08	 add	 edi, 8
  009e9	d3 e0		 shl	 eax, cl
  009eb	ff ce		 dec	 esi
  009ed	49 ff c4	 inc	 r12
  009f0	44 03 e8	 add	 r13d, eax
  009f3	83 ff 0e	 cmp	 edi, 14
  009f6	72 df		 jb	 SHORT $LL263@inflate
$LN265@inflate:

; 883  :             state->nlen = BITS(5) + 257;

  009f8	41 8b cd	 mov	 ecx, r13d

; 884  :             DROPBITS(5);

  009fb	41 c1 ed 05	 shr	 r13d, 5

; 885  :             state->ndist = BITS(5) + 1;
; 886  :             DROPBITS(5);
; 887  :             state->ncode = BITS(4) + 4;
; 888  :             DROPBITS(4);

  009ff	83 c7 f2	 add	 edi, -14		; fffffff2H
  00a02	41 8b d5	 mov	 edx, r13d
  00a05	41 c1 ed 05	 shr	 r13d, 5
  00a09	83 e1 1f	 and	 ecx, 31
  00a0c	41 8b c5	 mov	 eax, r13d
  00a0f	83 e2 1f	 and	 edx, 31
  00a12	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00a18	83 e0 0f	 and	 eax, 15
  00a1b	ff c2		 inc	 edx
  00a1d	41 c1 ed 04	 shr	 r13d, 4
  00a21	83 c0 04	 add	 eax, 4
  00a24	41 89 4e 74	 mov	 DWORD PTR [r14+116], ecx
  00a28	41 89 56 78	 mov	 DWORD PTR [r14+120], edx
  00a2c	41 89 46 70	 mov	 DWORD PTR [r14+112], eax

; 889  : #ifndef PKZIP_BUG_WORKAROUND
; 890  :             if (state->nlen > 286 || state->ndist > 30) {

  00a30	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  00a36	0f 87 05 01 00
	00		 ja	 $LN247@inflate
  00a3c	83 fa 1e	 cmp	 edx, 30
  00a3f	0f 87 fc 00 00
	00		 ja	 $LN247@inflate

; 892  :                 state->mode = BAD;
; 893  :                 break;
; 894  :             }
; 895  : #endif
; 896  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 897  :             state->have = 0;

  00a45	45 89 7e 7c	 mov	 DWORD PTR [r14+124], r15d

; 898  :             state->mode = LENLENS;

  00a49	41 c7 06 11 00
	00 00		 mov	 DWORD PTR [r14], 17
$LN533@inflate:

; 899  :         case LENLENS:
; 900  :             while (state->have < state->ncode) {

  00a50	41 8b 46 70	 mov	 eax, DWORD PTR [r14+112]
  00a54	41 39 46 7c	 cmp	 DWORD PTR [r14+124], eax
  00a58	73 5f		 jae	 SHORT $LN535@inflate
  00a5a	66 0f 1f 44 00
	00		 npad	 6
$LL245@inflate:

; 901  :                 NEEDBITS(3);

  00a60	83 ff 03	 cmp	 edi, 3
  00a63	73 21		 jae	 SHORT $LN242@inflate
$LL240@inflate:
  00a65	85 f6		 test	 esi, esi
  00a67	0f 84 f0 fd ff
	ff		 je	 $LN782@inflate
  00a6d	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00a72	8b cf		 mov	 ecx, edi
  00a74	83 c7 08	 add	 edi, 8
  00a77	d3 e0		 shl	 eax, cl
  00a79	ff ce		 dec	 esi
  00a7b	49 ff c4	 inc	 r12
  00a7e	44 03 e8	 add	 r13d, eax
  00a81	83 ff 03	 cmp	 edi, 3
  00a84	72 df		 jb	 SHORT $LL240@inflate
$LN242@inflate:

; 902  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00a86	41 8b 46 7c	 mov	 eax, DWORD PTR [r14+124]
  00a8a	41 0f b7 cd	 movzx	 ecx, r13w

; 903  :                 DROPBITS(3);

  00a8e	83 c7 fd	 add	 edi, -3			; fffffffdH
  00a91	41 0f b7 84 43
	00 00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[r11+rax*2]
  00a9a	66 83 e1 07	 and	 cx, 7
  00a9e	41 c1 ed 03	 shr	 r13d, 3
  00aa2	66 41 89 8c 46
	88 00 00 00	 mov	 WORD PTR [r14+rax*2+136], cx
  00aab	41 ff 46 7c	 inc	 DWORD PTR [r14+124]
  00aaf	41 8b 46 70	 mov	 eax, DWORD PTR [r14+112]
  00ab3	41 39 46 7c	 cmp	 DWORD PTR [r14+124], eax
  00ab7	72 a7		 jb	 SHORT $LL245@inflate
$LN535@inflate:

; 904  :             }
; 905  :             while (state->have < 19)

  00ab9	41 83 7e 7c 13	 cmp	 DWORD PTR [r14+124], 19
  00abe	73 21		 jae	 SHORT $LN230@inflate
$LL231@inflate:

; 906  :                 state->lens[order[state->have++]] = 0;

  00ac0	41 8b 46 7c	 mov	 eax, DWORD PTR [r14+124]
  00ac4	41 0f b7 84 43
	00 00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[r11+rax*2]
  00acd	66 45 89 bc 46
	88 00 00 00	 mov	 WORD PTR [r14+rax*2+136], r15w
  00ad6	41 ff 46 7c	 inc	 DWORD PTR [r14+124]
  00ada	41 83 7e 7c 13	 cmp	 DWORD PTR [r14+124], 19
  00adf	72 df		 jb	 SHORT $LL231@inflate
$LN230@inflate:

; 907  :             state->next = state->codes;
; 908  :             state->lencode = (code const FAR *)(state->next);
; 909  :             state->lenbits = 7;

  00ae1	49 8d 4e 68	 lea	 rcx, QWORD PTR [r14+104]
  00ae5	49 8d 86 48 05
	00 00		 lea	 rax, QWORD PTR [r14+1352]
  00aec	4d 8d 8e 80 00
	00 00		 lea	 r9, QWORD PTR [r14+128]
  00af3	49 89 01	 mov	 QWORD PTR [r9], rax
  00af6	49 89 46 58	 mov	 QWORD PTR [r14+88], rax

; 910  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 911  :                                 &(state->lenbits), state->work);

  00afa	49 8d 86 08 03
	00 00		 lea	 rax, QWORD PTR [r14+776]
  00b01	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00b06	c7 01 07 00 00
	00		 mov	 DWORD PTR [rcx], 7
  00b0c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00b11	33 c9		 xor	 ecx, ecx
  00b13	49 8d 96 88 00
	00 00		 lea	 rdx, QWORD PTR [r14+136]
  00b1a	44 8d 41 13	 lea	 r8d, QWORD PTR [rcx+19]
  00b1e	e8 00 00 00 00	 call	 inflate_table
  00b23	89 45 30	 mov	 DWORD PTR ret$1$[rbp-128], eax

; 912  :             if (ret) {

  00b26	85 c0		 test	 eax, eax
  00b28	74 2e		 je	 SHORT $LN229@inflate

; 913  :                 strm->msg = (char *)"invalid code lengths set";

  00b2a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
  00b31	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 914  :                 state->mode = BAD;

  00b35	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 915  :                 break;

  00b3c	e9 96 fb ff ff	 jmp	 $LN745@inflate
$LN247@inflate:

; 891  :                 strm->msg = (char *)"too many length or distance symbols";

  00b41	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
  00b48	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  00b4c	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29
  00b53	e9 87 fb ff ff	 jmp	 $LN498@inflate
$LN229@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 918  :             state->have = 0;

  00b58	45 89 7e 7c	 mov	 DWORD PTR [r14+124], r15d

; 919  :             state->mode = CODELENS;

  00b5c	41 c7 06 12 00
	00 00		 mov	 DWORD PTR [r14], 18
$LN536@inflate:

; 920  :         case CODELENS:
; 921  :             while (state->have < state->nlen + state->ndist) {

  00b63	41 8b 46 78	 mov	 eax, DWORD PTR [r14+120]
  00b67	41 03 46 74	 add	 eax, DWORD PTR [r14+116]
  00b6b	41 39 46 7c	 cmp	 DWORD PTR [r14+124], eax
  00b6f	0f 83 33 02 00
	00		 jae	 $LN226@inflate
  00b75	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL227@inflate:

; 922  :                 for (;;) {
; 923  :                     here = state->lencode[BITS(state->lenbits)];

  00b80	41 8b 4e 68	 mov	 ecx, DWORD PTR [r14+104]
  00b84	b8 01 00 00 00	 mov	 eax, 1
  00b89	d3 e0		 shl	 eax, cl
  00b8b	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00b8e	41 8b c5	 mov	 eax, r13d
  00b91	48 23 c8	 and	 rcx, rax
  00b94	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  00b98	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]

; 924  :                     if ((unsigned)(here.bits) <= bits) break;

  00b9b	8b c8		 mov	 ecx, eax
  00b9d	89 45 b4	 mov	 DWORD PTR here$[rbp-128], eax
  00ba0	c1 e9 08	 shr	 ecx, 8
  00ba3	0f b6 c9	 movzx	 ecx, cl
  00ba6	3b cf		 cmp	 ecx, edi
  00ba8	76 4c		 jbe	 SHORT $LN564@inflate
  00baa	66 0f 1f 44 00
	00		 npad	 6
$LL225@inflate:

; 925  :                     PULLBYTE();

  00bb0	85 f6		 test	 esi, esi
  00bb2	0f 84 a5 fc ff
	ff		 je	 $LN782@inflate
  00bb8	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00bbd	8b cf		 mov	 ecx, edi
  00bbf	83 c7 08	 add	 edi, 8
  00bc2	d3 e0		 shl	 eax, cl
  00bc4	41 8b 4e 68	 mov	 ecx, DWORD PTR [r14+104]
  00bc8	ff ce		 dec	 esi
  00bca	44 03 e8	 add	 r13d, eax
  00bcd	b8 01 00 00 00	 mov	 eax, 1
  00bd2	49 ff c4	 inc	 r12
  00bd5	d3 e0		 shl	 eax, cl
  00bd7	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00bda	41 8b c5	 mov	 eax, r13d
  00bdd	48 23 c8	 and	 rcx, rax
  00be0	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  00be4	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00be7	8b c8		 mov	 ecx, eax
  00be9	89 45 b4	 mov	 DWORD PTR here$[rbp-128], eax
  00bec	c1 e9 08	 shr	 ecx, 8
  00bef	0f b6 c9	 movzx	 ecx, cl
  00bf2	3b cf		 cmp	 ecx, edi
  00bf4	77 ba		 ja	 SHORT $LL225@inflate
$LN564@inflate:

; 926  :                 }
; 927  :                 if (here.val < 16) {

  00bf6	8b c8		 mov	 ecx, eax
  00bf8	c1 e9 10	 shr	 ecx, 16
  00bfb	66 83 f9 10	 cmp	 cx, 16
  00bff	73 54		 jae	 SHORT $LN218@inflate

; 928  :                     NEEDBITS(here.bits);

  00c01	0f b6 55 b5	 movzx	 edx, BYTE PTR here$[rbp-127]
  00c05	c1 e8 08	 shr	 eax, 8
  00c08	0f b6 c8	 movzx	 ecx, al
  00c0b	3b f9		 cmp	 edi, ecx
  00c0d	73 24		 jae	 SHORT $LN216@inflate
  00c0f	90		 npad	 1
$LL214@inflate:
  00c10	85 f6		 test	 esi, esi
  00c12	0f 84 45 fc ff
	ff		 je	 $LN782@inflate
  00c18	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00c1d	8b cf		 mov	 ecx, edi
  00c1f	83 c7 08	 add	 edi, 8
  00c22	d3 e0		 shl	 eax, cl
  00c24	ff ce		 dec	 esi
  00c26	49 ff c4	 inc	 r12
  00c29	44 03 e8	 add	 r13d, eax
  00c2c	0f b6 c2	 movzx	 eax, dl
  00c2f	3b f8		 cmp	 edi, eax
  00c31	72 dd		 jb	 SHORT $LL214@inflate
$LN216@inflate:

; 929  :                     DROPBITS(here.bits);
; 930  :                     state->lens[state->have++] = here.val;

  00c33	0f b7 45 b6	 movzx	 eax, WORD PTR here$[rbp-126]
  00c37	0f b6 ca	 movzx	 ecx, dl
  00c3a	41 d3 ed	 shr	 r13d, cl
  00c3d	2b f9		 sub	 edi, ecx
  00c3f	41 8b 4e 7c	 mov	 ecx, DWORD PTR [r14+124]
  00c43	66 41 89 84 4e
	88 00 00 00	 mov	 WORD PTR [r14+rcx*2+136], ax
  00c4c	41 ff 46 7c	 inc	 DWORD PTR [r14+124]

; 931  :                 }
; 932  :                 else {

  00c50	e9 41 01 00 00	 jmp	 $LN614@inflate
$LN218@inflate:

; 933  :                     if (here.val == 16) {

  00c55	0f b7 45 b6	 movzx	 eax, WORD PTR here$[rbp-126]
  00c59	66 83 f8 10	 cmp	 ax, 16
  00c5d	75 68		 jne	 SHORT $LN204@inflate

; 934  :                         NEEDBITS(here.bits + 2);

  00c5f	44 0f b6 45 b5	 movzx	 r8d, BYTE PTR here$[rbp-127]
  00c64	41 8d 50 02	 lea	 edx, DWORD PTR [r8+2]
  00c68	3b fa		 cmp	 edi, edx
  00c6a	73 24		 jae	 SHORT $LN202@inflate
  00c6c	0f 1f 40 00	 npad	 4
$LL200@inflate:
  00c70	85 f6		 test	 esi, esi
  00c72	0f 84 e5 fb ff
	ff		 je	 $LN782@inflate
  00c78	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00c7d	8b cf		 mov	 ecx, edi
  00c7f	83 c7 08	 add	 edi, 8
  00c82	d3 e0		 shl	 eax, cl
  00c84	ff ce		 dec	 esi
  00c86	49 ff c4	 inc	 r12
  00c89	44 03 e8	 add	 r13d, eax
  00c8c	3b fa		 cmp	 edi, edx
  00c8e	72 e0		 jb	 SHORT $LL200@inflate
$LN202@inflate:

; 935  :                         DROPBITS(here.bits);
; 936  :                         if (state->have == 0) {

  00c90	41 8b 46 7c	 mov	 eax, DWORD PTR [r14+124]
  00c94	41 8b c8	 mov	 ecx, r8d
  00c97	41 2b f8	 sub	 edi, r8d
  00c9a	41 d3 ed	 shr	 r13d, cl
  00c9d	85 c0		 test	 eax, eax
  00c9f	0f 84 2f 01 00
	00		 je	 $LN570@inflate

; 940  :                         }
; 941  :                         len = state->lens[state->have - 1];
; 942  :                         copy = 3 + BITS(2);

  00ca5	45 8b c5	 mov	 r8d, r13d
  00ca8	ff c8		 dec	 eax

; 943  :                         DROPBITS(2);

  00caa	41 c1 ed 02	 shr	 r13d, 2
  00cae	45 0f b7 8c 46
	88 00 00 00	 movzx	 r9d, WORD PTR [r14+rax*2+136]
  00cb7	41 83 e0 03	 and	 r8d, 3
  00cbb	41 83 c0 03	 add	 r8d, 3
  00cbf	83 c7 fe	 add	 edi, -2			; fffffffeH

; 944  :                     }
; 945  :                     else if (here.val == 17) {

  00cc2	e9 9f 00 00 00	 jmp	 $LN155@inflate
$LN204@inflate:

; 764  :                 do {
; 765  :                     len = (unsigned)(next[copy++]);

  00cc7	44 0f b6 55 b5	 movzx	 r10d, BYTE PTR here$[rbp-127]

; 944  :                     }
; 945  :                     else if (here.val == 17) {

  00ccc	66 83 f8 11	 cmp	 ax, 17
  00cd0	75 4a		 jne	 SHORT $LN169@inflate

; 946  :                         NEEDBITS(here.bits + 3);

  00cd2	41 8d 52 03	 lea	 edx, DWORD PTR [r10+3]
  00cd6	3b fa		 cmp	 edi, edx
  00cd8	73 26		 jae	 SHORT $LN184@inflate
  00cda	66 0f 1f 44 00
	00		 npad	 6
$LL182@inflate:
  00ce0	85 f6		 test	 esi, esi
  00ce2	0f 84 75 fb ff
	ff		 je	 $LN782@inflate
  00ce8	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00ced	8b cf		 mov	 ecx, edi
  00cef	83 c7 08	 add	 edi, 8
  00cf2	d3 e0		 shl	 eax, cl
  00cf4	ff ce		 dec	 esi
  00cf6	49 ff c4	 inc	 r12
  00cf9	44 03 e8	 add	 r13d, eax
  00cfc	3b fa		 cmp	 edi, edx
  00cfe	72 e0		 jb	 SHORT $LL182@inflate
$LN184@inflate:

; 947  :                         DROPBITS(here.bits);

  00d00	41 8b ca	 mov	 ecx, r10d

; 948  :                         len = 0;
; 949  :                         copy = 3 + BITS(3);
; 950  :                         DROPBITS(3);

  00d03	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00d08	41 d3 ed	 shr	 r13d, cl
  00d0b	45 8b c5	 mov	 r8d, r13d
  00d0e	41 83 e0 07	 and	 r8d, 7
  00d12	41 83 c0 03	 add	 r8d, 3
  00d16	41 c1 ed 03	 shr	 r13d, 3

; 951  :                     }
; 952  :                     else {

  00d1a	eb 42		 jmp	 SHORT $LN817@inflate
$LN169@inflate:

; 953  :                         NEEDBITS(here.bits + 7);

  00d1c	41 8d 52 07	 lea	 edx, DWORD PTR [r10+7]
  00d20	3b fa		 cmp	 edi, edx
  00d22	73 20		 jae	 SHORT $LN168@inflate
$LL166@inflate:
  00d24	85 f6		 test	 esi, esi
  00d26	0f 84 31 fb ff
	ff		 je	 $LN782@inflate
  00d2c	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00d31	8b cf		 mov	 ecx, edi
  00d33	83 c7 08	 add	 edi, 8
  00d36	d3 e0		 shl	 eax, cl
  00d38	ff ce		 dec	 esi
  00d3a	49 ff c4	 inc	 r12
  00d3d	44 03 e8	 add	 r13d, eax
  00d40	3b fa		 cmp	 edi, edx
  00d42	72 e0		 jb	 SHORT $LL166@inflate
$LN168@inflate:

; 954  :                         DROPBITS(here.bits);

  00d44	41 8b ca	 mov	 ecx, r10d

; 955  :                         len = 0;
; 956  :                         copy = 11 + BITS(7);
; 957  :                         DROPBITS(7);

  00d47	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  00d4c	41 d3 ed	 shr	 r13d, cl
  00d4f	45 8b c5	 mov	 r8d, r13d
  00d52	41 83 e0 7f	 and	 r8d, 127		; 0000007fH
  00d56	41 83 c0 0b	 add	 r8d, 11
  00d5a	41 c1 ed 07	 shr	 r13d, 7
$LN817@inflate:
  00d5e	41 2b c2	 sub	 eax, r10d
  00d61	45 8b cf	 mov	 r9d, r15d
  00d64	03 f8		 add	 edi, eax
$LN155@inflate:

; 958  :                     }
; 959  :                     if (state->have + copy > state->nlen + state->ndist) {

  00d66	41 8b 56 78	 mov	 edx, DWORD PTR [r14+120]
  00d6a	41 8b 46 7c	 mov	 eax, DWORD PTR [r14+124]
  00d6e	41 03 56 74	 add	 edx, DWORD PTR [r14+116]
  00d72	41 8d 0c 00	 lea	 ecx, DWORD PTR [r8+rax]
  00d76	3b ca		 cmp	 ecx, edx
  00d78	77 5a		 ja	 SHORT $LN570@inflate

; 960  :                         strm->msg = (char *)"invalid bit length repeat";
; 961  :                         state->mode = BAD;
; 962  :                         break;
; 963  :                     }
; 964  :                     while (copy--)

  00d7a	45 85 c0	 test	 r8d, r8d
  00d7d	74 17		 je	 SHORT $LN614@inflate
  00d7f	90		 npad	 1
$LL153@inflate:

; 965  :                         state->lens[state->have++] = (unsigned short)len;

  00d80	41 8b 46 7c	 mov	 eax, DWORD PTR [r14+124]
  00d84	66 45 89 8c 46
	88 00 00 00	 mov	 WORD PTR [r14+rax*2+136], r9w
  00d8d	41 ff 46 7c	 inc	 DWORD PTR [r14+124]
  00d91	41 ff c8	 dec	 r8d
  00d94	75 ea		 jne	 SHORT $LL153@inflate
$LN614@inflate:

; 920  :         case CODELENS:
; 921  :             while (state->have < state->nlen + state->ndist) {

  00d96	41 8b 46 78	 mov	 eax, DWORD PTR [r14+120]
  00d9a	41 03 46 74	 add	 eax, DWORD PTR [r14+116]
  00d9e	41 39 46 7c	 cmp	 DWORD PTR [r14+124], eax
  00da2	0f 82 d8 fd ff
	ff		 jb	 $LL227@inflate
$LN226@inflate:

; 966  :                 }
; 967  :             }
; 968  : 
; 969  :             /* handle error breaks in while */
; 970  :             if (state->mode == BAD) break;

  00da8	41 83 3e 1d	 cmp	 DWORD PTR [r14], 29
  00dac	0f 84 25 f9 ff
	ff		 je	 $LN745@inflate

; 971  : 
; 972  :             /* check for end-of-block code (better have one) */
; 973  :             if (state->lens[256] == 0) {

  00db2	66 41 83 be 88
	02 00 00 00	 cmp	 WORD PTR [r14+648], 0
  00dbb	75 2e		 jne	 SHORT $LN150@inflate

; 974  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00dbd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
  00dc4	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 975  :                 state->mode = BAD;

  00dc8	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 976  :                 break;

  00dcf	e9 03 f9 ff ff	 jmp	 $LN745@inflate
$LN570@inflate:

; 937  :                             strm->msg = (char *)"invalid bit length repeat";

  00dd4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  00ddb	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 938  :                             state->mode = BAD;

  00ddf	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 939  :                             break;

  00de6	e9 ec f8 ff ff	 jmp	 $LN745@inflate
$LN150@inflate:

; 977  :             }
; 978  : 
; 979  :             /* build code tables -- note: do not change the lenbits or distbits
; 980  :                values here (9 and 6) without reading the comments in inftrees.h
; 981  :                concerning the ENOUGH constants, which depend on those values */
; 982  :             state->next = state->codes;
; 983  :             state->lencode = (code const FAR *)(state->next);
; 984  :             state->lenbits = 9;
; 985  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 986  :                                 &(state->lenbits), state->work);

  00deb	45 8b 46 74	 mov	 r8d, DWORD PTR [r14+116]
  00def	49 8d 86 48 05
	00 00		 lea	 rax, QWORD PTR [r14+1352]
  00df6	4d 8d be 08 03
	00 00		 lea	 r15, QWORD PTR [r14+776]
  00dfd	49 89 86 80 00
	00 00		 mov	 QWORD PTR [r14+128], rax
  00e04	49 89 46 58	 mov	 QWORD PTR [r14+88], rax
  00e08	49 8d 46 68	 lea	 rax, QWORD PTR [r14+104]
  00e0c	49 8d 96 88 00
	00 00		 lea	 rdx, QWORD PTR [r14+136]
  00e13	4d 8d 8e 80 00
	00 00		 lea	 r9, QWORD PTR [r14+128]
  00e1a	b9 01 00 00 00	 mov	 ecx, 1
  00e1f	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  00e24	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9
  00e2a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e2f	e8 00 00 00 00	 call	 inflate_table
  00e34	89 45 30	 mov	 DWORD PTR ret$1$[rbp-128], eax

; 987  :             if (ret) {

  00e37	85 c0		 test	 eax, eax
  00e39	74 1b		 je	 SHORT $LN149@inflate

; 988  :                 strm->msg = (char *)"invalid literal/lengths set";

  00e3b	48 8b 5d 20	 mov	 rbx, QWORD PTR strm$[rbp-128]
  00e3f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
  00e46	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 989  :                 state->mode = BAD;

  00e4a	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 990  :                 break;

  00e51	e9 81 f8 ff ff	 jmp	 $LN745@inflate
$LN149@inflate:

; 991  :             }
; 992  :             state->distcode = (code const FAR *)(state->next);

  00e56	49 8b 86 80 00
	00 00		 mov	 rax, QWORD PTR [r14+128]

; 993  :             state->distbits = 6;
; 994  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 995  :                             &(state->next), &(state->distbits), state->work);

  00e5d	45 8b 46 78	 mov	 r8d, DWORD PTR [r14+120]
  00e61	49 8d 4e 6c	 lea	 rcx, QWORD PTR [r14+108]
  00e65	49 89 46 60	 mov	 QWORD PTR [r14+96], rax
  00e69	41 8b 46 74	 mov	 eax, DWORD PTR [r14+116]
  00e6d	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  00e73	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  00e78	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00e7d	4d 8d 8e 80 00
	00 00		 lea	 r9, QWORD PTR [r14+128]
  00e84	49 8d 94 46 88
	00 00 00	 lea	 rdx, QWORD PTR [r14+rax*2+136]
  00e8c	b9 02 00 00 00	 mov	 ecx, 2
  00e91	e8 00 00 00 00	 call	 inflate_table
  00e96	44 8b f8	 mov	 r15d, eax
  00e99	89 45 30	 mov	 DWORD PTR ret$1$[rbp-128], eax

; 996  :             if (ret) {

  00e9c	85 c0		 test	 eax, eax
  00e9e	74 1b		 je	 SHORT $LN148@inflate

; 997  :                 strm->msg = (char *)"invalid distances set";

  00ea0	48 8b 5d 20	 mov	 rbx, QWORD PTR strm$[rbp-128]
  00ea4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
  00eab	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 998  :                 state->mode = BAD;

  00eaf	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 999  :                 break;

  00eb6	e9 1c f8 ff ff	 jmp	 $LN745@inflate
$LN148@inflate:

; 1000 :             }
; 1001 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1002 :             state->mode = LEN_;
; 1003 :             if (flush == Z_TREES) goto inf_leave;

  00ebb	83 7d 28 06	 cmp	 DWORD PTR flush$[rbp-128], 6
  00ebf	41 c7 06 13 00
	00 00		 mov	 DWORD PTR [r14], 19
  00ec6	0f 84 95 f9 ff
	ff		 je	 $inf_leave$5023
  00ecc	48 8b 5d 20	 mov	 rbx, QWORD PTR strm$[rbp-128]
  00ed0	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  00ed4	44 8b 45 b8	 mov	 r8d, DWORD PTR out$1$[rbp-128]
  00ed8	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]
  00edc	45 33 ff	 xor	 r15d, r15d
$LN147@inflate:

; 1004 :         case LEN_:
; 1005 :             state->mode = LEN;

  00edf	41 c7 06 14 00
	00 00		 mov	 DWORD PTR [r14], 20
$LN145@inflate:

; 1006 :         case LEN:
; 1007 :             if (have >= 6 && left >= 258) {

  00ee6	83 fe 06	 cmp	 esi, 6
  00ee9	72 62		 jb	 SHORT $LN144@inflate
  00eeb	41 81 fa 02 01
	00 00		 cmp	 r10d, 258		; 00000102H
  00ef2	72 59		 jb	 SHORT $LN144@inflate

; 1008 :                 RESTORE();

  00ef4	4c 89 4b 10	 mov	 QWORD PTR [rbx+16], r9
  00ef8	44 89 53 18	 mov	 DWORD PTR [rbx+24], r10d
  00efc	4c 89 23	 mov	 QWORD PTR [rbx], r12
  00eff	89 73 08	 mov	 DWORD PTR [rbx+8], esi

; 1009 :                 inflate_fast(strm, out);

  00f02	41 8b d0	 mov	 edx, r8d
  00f05	48 8b cb	 mov	 rcx, rbx
  00f08	45 89 6e 40	 mov	 DWORD PTR [r14+64], r13d
  00f0c	41 89 7e 44	 mov	 DWORD PTR [r14+68], edi
  00f10	e8 00 00 00 00	 call	 inflate_fast

; 1010 :                 LOAD();
; 1011 :                 if (state->mode == TYPE)

  00f15	41 83 3e 0b	 cmp	 DWORD PTR [r14], 11
  00f19	4c 8b 4b 10	 mov	 r9, QWORD PTR [rbx+16]
  00f1d	44 8b 53 18	 mov	 r10d, DWORD PTR [rbx+24]
  00f21	4c 8b 23	 mov	 r12, QWORD PTR [rbx]
  00f24	8b 73 08	 mov	 esi, DWORD PTR [rbx+8]
  00f27	45 8b 6e 40	 mov	 r13d, DWORD PTR [r14+64]
  00f2b	41 8b 7e 44	 mov	 edi, DWORD PTR [r14+68]
  00f2f	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9
  00f33	44 89 55 38	 mov	 DWORD PTR left$1$[rbp-128], r10d
  00f37	0f 85 a2 f7 ff
	ff		 jne	 $LN498@inflate

; 1012 :                     state->back = -1;

  00f3d	41 c7 86 dc 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r14+7132], -1

; 1013 :                 break;

  00f48	e9 92 f7 ff ff	 jmp	 $LN498@inflate
$LN144@inflate:

; 1014 :             }
; 1015 :             state->back = 0;
; 1016 :             for (;;) {
; 1017 :                 here = state->lencode[BITS(state->lenbits)];

  00f4d	41 8b 4e 68	 mov	 ecx, DWORD PTR [r14+104]
  00f51	4d 8b 5e 58	 mov	 r11, QWORD PTR [r14+88]
  00f55	b8 01 00 00 00	 mov	 eax, 1
  00f5a	d3 e0		 shl	 eax, cl
  00f5c	45 89 be dc 1b
	00 00		 mov	 DWORD PTR [r14+7132], r15d
  00f63	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00f66	41 8b c5	 mov	 eax, r13d
  00f69	48 23 c8	 and	 rcx, rax
  00f6c	41 8b 04 8b	 mov	 eax, DWORD PTR [r11+rcx*4]

; 1018 :                 if ((unsigned)(here.bits) <= bits) break;

  00f70	8b c8		 mov	 ecx, eax
  00f72	c1 e9 08	 shr	 ecx, 8
  00f75	0f b6 c9	 movzx	 ecx, cl
  00f78	3b cf		 cmp	 ecx, edi
  00f7a	76 47		 jbe	 SHORT $LN572@inflate
  00f7c	0f 1f 40 00	 npad	 4
$LL136@inflate:

; 1019 :                 PULLBYTE();

  00f80	85 f6		 test	 esi, esi
  00f82	0f 84 d5 f8 ff
	ff		 je	 $LN782@inflate
  00f88	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00f8d	8b cf		 mov	 ecx, edi
  00f8f	83 c7 08	 add	 edi, 8
  00f92	d3 e0		 shl	 eax, cl
  00f94	41 8b 4e 68	 mov	 ecx, DWORD PTR [r14+104]
  00f98	ff ce		 dec	 esi
  00f9a	44 03 e8	 add	 r13d, eax
  00f9d	b8 01 00 00 00	 mov	 eax, 1
  00fa2	49 ff c4	 inc	 r12
  00fa5	d3 e0		 shl	 eax, cl
  00fa7	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00faa	41 8b c5	 mov	 eax, r13d
  00fad	48 23 c8	 and	 rcx, rax
  00fb0	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  00fb4	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00fb7	8b c8		 mov	 ecx, eax
  00fb9	c1 e9 08	 shr	 ecx, 8
  00fbc	0f b6 c9	 movzx	 ecx, cl
  00fbf	3b cf		 cmp	 ecx, edi
  00fc1	77 bd		 ja	 SHORT $LL136@inflate
$LN572@inflate:

; 1020 :             }
; 1021 :             if (here.op && (here.op & 0xf0) == 0) {

  00fc3	84 c0		 test	 al, al
  00fc5	0f 84 c7 00 00
	00		 je	 $LN118@inflate
  00fcb	a8 f0		 test	 al, 240			; 000000f0H
  00fcd	0f 85 bf 00 00
	00		 jne	 $LN118@inflate

; 1022 :                 last = here;
; 1023 :                 for (;;) {
; 1024 :                     here = state->lencode[last.val +
; 1025 :                             (BITS(last.bits + last.op) >> last.bits)];

  00fd3	44 8b d0	 mov	 r10d, eax
  00fd6	0f b6 c8	 movzx	 ecx, al
  00fd9	89 45 b4	 mov	 DWORD PTR last$[rbp-128], eax
  00fdc	41 c1 ea 08	 shr	 r10d, 8
  00fe0	41 b9 01 00 00
	00		 mov	 r9d, 1
  00fe6	8b d0		 mov	 edx, eax
  00fe8	45 0f b6 c2	 movzx	 r8d, r10b
  00fec	c1 e8 10	 shr	 eax, 16
  00fef	41 03 c8	 add	 ecx, r8d
  00ff2	41 d3 e1	 shl	 r9d, cl
  00ff5	41 8b c8	 mov	 ecx, r8d
  00ff8	41 ff c9	 dec	 r9d
  00ffb	45 23 cd	 and	 r9d, r13d
  00ffe	41 d3 e9	 shr	 r9d, cl
  01001	44 03 c8	 add	 r9d, eax
  01004	43 8b 04 8b	 mov	 eax, DWORD PTR [r11+r9*4]

; 1026 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01008	44 0f b6 5d b5	 movzx	 r11d, BYTE PTR last$[rbp-127]
  0100d	8b c8		 mov	 ecx, eax
  0100f	c1 e9 08	 shr	 ecx, 8
  01012	44 0f b6 c1	 movzx	 r8d, cl
  01016	41 0f b6 ca	 movzx	 ecx, r10b
  0101a	44 03 c1	 add	 r8d, ecx
  0101d	44 3b c7	 cmp	 r8d, edi
  01020	76 60		 jbe	 SHORT $LN121@inflate
  01022	44 0f b7 55 b6	 movzx	 r10d, WORD PTR last$[rbp-126]
$LL128@inflate:

; 1027 :                     PULLBYTE();

  01027	85 f6		 test	 esi, esi
  01029	0f 84 2e f8 ff
	ff		 je	 $LN782@inflate
  0102f	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  01034	8b cf		 mov	 ecx, edi
  01036	45 0f b6 cb	 movzx	 r9d, r11b
  0103a	d3 e0		 shl	 eax, cl
  0103c	41 b8 01 00 00
	00		 mov	 r8d, 1
  01042	0f b6 ca	 movzx	 ecx, dl
  01045	41 03 c9	 add	 ecx, r9d
  01048	44 03 e8	 add	 r13d, eax
  0104b	41 0f b7 c2	 movzx	 eax, r10w
  0104f	41 d3 e0	 shl	 r8d, cl
  01052	41 8b c9	 mov	 ecx, r9d
  01055	83 c7 08	 add	 edi, 8
  01058	41 ff c8	 dec	 r8d
  0105b	ff ce		 dec	 esi
  0105d	49 ff c4	 inc	 r12
  01060	45 23 c5	 and	 r8d, r13d
  01063	41 d3 e8	 shr	 r8d, cl
  01066	44 03 c0	 add	 r8d, eax
  01069	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  0106d	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  01071	8b c8		 mov	 ecx, eax
  01073	c1 e9 08	 shr	 ecx, 8
  01076	44 0f b6 c1	 movzx	 r8d, cl
  0107a	45 03 c1	 add	 r8d, r9d
  0107d	44 3b c7	 cmp	 r8d, edi
  01080	77 a5		 ja	 SHORT $LL128@inflate
$LN121@inflate:

; 1028 :                 }
; 1029 :                 DROPBITS(last.bits);

  01082	41 0f b6 cb	 movzx	 ecx, r11b
  01086	41 d3 ed	 shr	 r13d, cl
  01089	2b f9		 sub	 edi, ecx

; 1030 :                 state->back += last.bits;

  0108b	41 89 8e dc 1b
	00 00		 mov	 DWORD PTR [r14+7132], ecx
$LN118@inflate:

; 1031 :             }
; 1032 :             DROPBITS(here.bits);

  01092	8b c8		 mov	 ecx, eax
  01094	c1 e9 08	 shr	 ecx, 8
  01097	0f b6 c9	 movzx	 ecx, cl

; 1033 :             state->back += here.bits;

  0109a	41 01 8e dc 1b
	00 00		 add	 DWORD PTR [r14+7132], ecx
  010a1	41 d3 ed	 shr	 r13d, cl
  010a4	2b f9		 sub	 edi, ecx

; 1034 :             state->length = (unsigned)here.val;

  010a6	8b c8		 mov	 ecx, eax
  010a8	c1 e9 10	 shr	 ecx, 16
  010ab	41 89 4e 48	 mov	 DWORD PTR [r14+72], ecx

; 1035 :             if ((int)(here.op) == 0) {

  010af	84 c0		 test	 al, al
  010b1	75 0c		 jne	 SHORT $LN115@inflate

; 1036 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1037 :                         "inflate:         literal '%c'\n" :
; 1038 :                         "inflate:         literal 0x%02x\n", here.val));
; 1039 :                 state->mode = LIT;

  010b3	41 c7 06 19 00
	00 00		 mov	 DWORD PTR [r14], 25

; 1040 :                 break;

  010ba	e9 18 f6 ff ff	 jmp	 $LN745@inflate
$LN115@inflate:

; 1041 :             }
; 1042 :             if (here.op & 32) {

  010bf	a8 20		 test	 al, 32			; 00000020H
  010c1	74 10		 je	 SHORT $LN114@inflate

; 1043 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1044 :                 state->back = -1;

  010c3	41 c7 86 dc 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r14+7132], -1

; 1046 :                 break;

  010ce	e9 fd f5 ff ff	 jmp	 $LN820@inflate
$LN114@inflate:

; 1047 :             }
; 1048 :             if (here.op & 64) {

  010d3	a8 40		 test	 al, 64			; 00000040H
  010d5	74 17		 je	 SHORT $LN113@inflate

; 1049 :                 strm->msg = (char *)"invalid literal/length code";

  010d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  010de	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 1050 :                 state->mode = BAD;

  010e2	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 1051 :                 break;

  010e9	e9 e9 f5 ff ff	 jmp	 $LN745@inflate
$LN113@inflate:

; 1052 :             }
; 1053 :             state->extra = (unsigned)(here.op) & 15;

  010ee	0f b6 c8	 movzx	 ecx, al

; 1054 :             state->mode = LENEXT;

  010f1	41 c7 06 15 00
	00 00		 mov	 DWORD PTR [r14], 21
  010f8	83 e1 0f	 and	 ecx, 15
  010fb	41 89 4e 50	 mov	 DWORD PTR [r14+80], ecx
$LN112@inflate:

; 1055 :         case LENEXT:
; 1056 :             if (state->extra) {

  010ff	41 8b 56 50	 mov	 edx, DWORD PTR [r14+80]
  01103	85 d2		 test	 edx, edx
  01105	74 49		 je	 SHORT $LN111@inflate

; 1057 :                 NEEDBITS(state->extra);

  01107	3b fa		 cmp	 edi, edx
  01109	73 27		 jae	 SHORT $LN109@inflate
  0110b	0f 1f 44 00 00	 npad	 5
$LL107@inflate:
  01110	85 f6		 test	 esi, esi
  01112	0f 84 45 f7 ff
	ff		 je	 $LN782@inflate
  01118	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  0111d	8b cf		 mov	 ecx, edi
  0111f	83 c7 08	 add	 edi, 8
  01122	d3 e0		 shl	 eax, cl
  01124	ff ce		 dec	 esi
  01126	49 ff c4	 inc	 r12
  01129	44 03 e8	 add	 r13d, eax
  0112c	41 3b 7e 50	 cmp	 edi, DWORD PTR [r14+80]
  01130	72 de		 jb	 SHORT $LL107@inflate
$LN109@inflate:

; 1058 :                 state->length += BITS(state->extra);

  01132	8b ca		 mov	 ecx, edx
  01134	b8 01 00 00 00	 mov	 eax, 1

; 1059 :                 DROPBITS(state->extra);

  01139	2b fa		 sub	 edi, edx
  0113b	d3 e0		 shl	 eax, cl
  0113d	ff c8		 dec	 eax
  0113f	41 23 c5	 and	 eax, r13d
  01142	41 d3 ed	 shr	 r13d, cl
  01145	41 01 46 48	 add	 DWORD PTR [r14+72], eax

; 1060 :                 state->back += state->extra;

  01149	41 01 96 dc 1b
	00 00		 add	 DWORD PTR [r14+7132], edx
$LN111@inflate:

; 1061 :             }
; 1062 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1063 :             state->was = state->length;

  01150	41 8b 46 48	 mov	 eax, DWORD PTR [r14+72]

; 1064 :             state->mode = DIST;

  01154	41 c7 06 16 00
	00 00		 mov	 DWORD PTR [r14], 22
  0115b	41 89 86 e0 1b
	00 00		 mov	 DWORD PTR [r14+7136], eax
$LN546@inflate:

; 1065 :         case DIST:
; 1066 :             for (;;) {
; 1067 :                 here = state->distcode[BITS(state->distbits)];

  01162	41 8b 4e 6c	 mov	 ecx, DWORD PTR [r14+108]
  01166	4d 8b 5e 60	 mov	 r11, QWORD PTR [r14+96]
  0116a	b8 01 00 00 00	 mov	 eax, 1
  0116f	d3 e0		 shl	 eax, cl
  01171	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  01174	41 8b c5	 mov	 eax, r13d
  01177	48 23 c8	 and	 rcx, rax
  0117a	41 8b 04 8b	 mov	 eax, DWORD PTR [r11+rcx*4]

; 1068 :                 if ((unsigned)(here.bits) <= bits) break;

  0117e	8b c8		 mov	 ecx, eax
  01180	c1 e9 08	 shr	 ecx, 8
  01183	0f b6 c9	 movzx	 ecx, cl
  01186	3b cf		 cmp	 ecx, edi
  01188	76 49		 jbe	 SHORT $LN577@inflate
  0118a	66 0f 1f 44 00
	00		 npad	 6
$LL97@inflate:

; 1069 :                 PULLBYTE();

  01190	85 f6		 test	 esi, esi
  01192	0f 84 c5 f6 ff
	ff		 je	 $LN782@inflate
  01198	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  0119d	8b cf		 mov	 ecx, edi
  0119f	83 c7 08	 add	 edi, 8
  011a2	d3 e0		 shl	 eax, cl
  011a4	41 8b 4e 6c	 mov	 ecx, DWORD PTR [r14+108]
  011a8	ff ce		 dec	 esi
  011aa	44 03 e8	 add	 r13d, eax
  011ad	b8 01 00 00 00	 mov	 eax, 1
  011b2	49 ff c4	 inc	 r12
  011b5	d3 e0		 shl	 eax, cl
  011b7	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  011ba	41 8b c5	 mov	 eax, r13d
  011bd	48 23 c8	 and	 rcx, rax
  011c0	49 8b 46 60	 mov	 rax, QWORD PTR [r14+96]
  011c4	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  011c7	8b c8		 mov	 ecx, eax
  011c9	c1 e9 08	 shr	 ecx, 8
  011cc	0f b6 c9	 movzx	 ecx, cl
  011cf	3b cf		 cmp	 ecx, edi
  011d1	77 bd		 ja	 SHORT $LL97@inflate
$LN577@inflate:

; 1070 :             }
; 1071 :             if ((here.op & 0xf0) == 0) {

  011d3	a8 f0		 test	 al, 240			; 000000f0H
  011d5	0f 85 c0 00 00
	00		 jne	 $LN79@inflate

; 1072 :                 last = here;
; 1073 :                 for (;;) {
; 1074 :                     here = state->distcode[last.val +
; 1075 :                             (BITS(last.bits + last.op) >> last.bits)];

  011db	44 8b d0	 mov	 r10d, eax
  011de	0f b6 c8	 movzx	 ecx, al
  011e1	89 45 b4	 mov	 DWORD PTR last$[rbp-128], eax
  011e4	41 c1 ea 08	 shr	 r10d, 8
  011e8	41 b9 01 00 00
	00		 mov	 r9d, 1
  011ee	8b d0		 mov	 edx, eax
  011f0	45 0f b6 c2	 movzx	 r8d, r10b
  011f4	c1 e8 10	 shr	 eax, 16
  011f7	41 03 c8	 add	 ecx, r8d
  011fa	41 d3 e1	 shl	 r9d, cl
  011fd	41 8b c8	 mov	 ecx, r8d
  01200	41 ff c9	 dec	 r9d
  01203	45 23 cd	 and	 r9d, r13d
  01206	41 d3 e9	 shr	 r9d, cl
  01209	44 03 c8	 add	 r9d, eax
  0120c	43 8b 04 8b	 mov	 eax, DWORD PTR [r11+r9*4]

; 1076 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01210	44 0f b6 5d b5	 movzx	 r11d, BYTE PTR last$[rbp-127]
  01215	8b c8		 mov	 ecx, eax
  01217	c1 e9 08	 shr	 ecx, 8
  0121a	44 0f b6 c1	 movzx	 r8d, cl
  0121e	41 0f b6 ca	 movzx	 ecx, r10b
  01222	44 03 c1	 add	 r8d, ecx
  01225	44 3b c7	 cmp	 r8d, edi
  01228	76 61		 jbe	 SHORT $LN82@inflate
  0122a	44 0f b7 55 b6	 movzx	 r10d, WORD PTR last$[rbp-126]
  0122f	90		 npad	 1
$LL89@inflate:

; 1077 :                     PULLBYTE();

  01230	85 f6		 test	 esi, esi
  01232	0f 84 25 f6 ff
	ff		 je	 $LN782@inflate
  01238	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  0123d	8b cf		 mov	 ecx, edi
  0123f	45 0f b6 cb	 movzx	 r9d, r11b
  01243	d3 e0		 shl	 eax, cl
  01245	41 b8 01 00 00
	00		 mov	 r8d, 1
  0124b	0f b6 ca	 movzx	 ecx, dl
  0124e	41 03 c9	 add	 ecx, r9d
  01251	44 03 e8	 add	 r13d, eax
  01254	41 0f b7 c2	 movzx	 eax, r10w
  01258	41 d3 e0	 shl	 r8d, cl
  0125b	41 8b c9	 mov	 ecx, r9d
  0125e	83 c7 08	 add	 edi, 8
  01261	41 ff c8	 dec	 r8d
  01264	ff ce		 dec	 esi
  01266	49 ff c4	 inc	 r12
  01269	45 23 c5	 and	 r8d, r13d
  0126c	41 d3 e8	 shr	 r8d, cl
  0126f	44 03 c0	 add	 r8d, eax
  01272	49 8b 46 60	 mov	 rax, QWORD PTR [r14+96]
  01276	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  0127a	8b c8		 mov	 ecx, eax
  0127c	c1 e9 08	 shr	 ecx, 8
  0127f	44 0f b6 c1	 movzx	 r8d, cl
  01283	45 03 c1	 add	 r8d, r9d
  01286	44 3b c7	 cmp	 r8d, edi
  01289	77 a5		 ja	 SHORT $LL89@inflate
$LN82@inflate:

; 1078 :                 }
; 1079 :                 DROPBITS(last.bits);

  0128b	41 0f b6 cb	 movzx	 ecx, r11b
  0128f	41 d3 ed	 shr	 r13d, cl
  01292	2b f9		 sub	 edi, ecx

; 1080 :                 state->back += last.bits;

  01294	41 01 8e dc 1b
	00 00		 add	 DWORD PTR [r14+7132], ecx
$LN79@inflate:

; 1081 :             }
; 1082 :             DROPBITS(here.bits);
; 1083 :             state->back += here.bits;
; 1084 :             if (here.op & 64) {
; 1085 :                 strm->msg = (char *)"invalid distance code";
; 1086 :                 state->mode = BAD;
; 1087 :                 break;

  0129b	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  0129f	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]
  012a3	8b c8		 mov	 ecx, eax
  012a5	c1 e9 08	 shr	 ecx, 8
  012a8	0f b6 c9	 movzx	 ecx, cl
  012ab	41 01 8e dc 1b
	00 00		 add	 DWORD PTR [r14+7132], ecx
  012b2	41 d3 ed	 shr	 r13d, cl
  012b5	2b f9		 sub	 edi, ecx
  012b7	a8 40		 test	 al, 64			; 00000040H
  012b9	74 17		 je	 SHORT $LN76@inflate

; 651  :                 strm->msg = (char *)"unknown compression method";

  012bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  012c2	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 652  :                 state->mode = BAD;

  012c6	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29

; 653  :                 break;

  012cd	e9 0d f4 ff ff	 jmp	 $LN498@inflate
$LN76@inflate:
  012d2	44 8b 45 b8	 mov	 r8d, DWORD PTR out$1$[rbp-128]

; 1088 :             }
; 1089 :             state->offset = (unsigned)here.val;

  012d6	8b c8		 mov	 ecx, eax

; 1090 :             state->extra = (unsigned)(here.op) & 15;
; 1091 :             state->mode = DISTEXT;

  012d8	41 c7 06 17 00
	00 00		 mov	 DWORD PTR [r14], 23
  012df	c1 e9 10	 shr	 ecx, 16
  012e2	41 89 4e 4c	 mov	 DWORD PTR [r14+76], ecx
  012e6	0f b6 c8	 movzx	 ecx, al
  012e9	83 e1 0f	 and	 ecx, 15
  012ec	41 89 4e 50	 mov	 DWORD PTR [r14+80], ecx
$LN75@inflate:

; 1092 :         case DISTEXT:
; 1093 :             if (state->extra) {

  012f0	41 8b 56 50	 mov	 edx, DWORD PTR [r14+80]
  012f4	85 d2		 test	 edx, edx
  012f6	74 48		 je	 SHORT $LN74@inflate

; 1094 :                 NEEDBITS(state->extra);

  012f8	3b fa		 cmp	 edi, edx
  012fa	73 26		 jae	 SHORT $LN72@inflate
  012fc	0f 1f 40 00	 npad	 4
$LL70@inflate:
  01300	85 f6		 test	 esi, esi
  01302	0f 84 55 f5 ff
	ff		 je	 $LN782@inflate
  01308	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  0130d	8b cf		 mov	 ecx, edi
  0130f	83 c7 08	 add	 edi, 8
  01312	d3 e0		 shl	 eax, cl
  01314	ff ce		 dec	 esi
  01316	49 ff c4	 inc	 r12
  01319	44 03 e8	 add	 r13d, eax
  0131c	41 3b 7e 50	 cmp	 edi, DWORD PTR [r14+80]
  01320	72 de		 jb	 SHORT $LL70@inflate
$LN72@inflate:

; 1095 :                 state->offset += BITS(state->extra);

  01322	8b ca		 mov	 ecx, edx
  01324	b8 01 00 00 00	 mov	 eax, 1

; 1096 :                 DROPBITS(state->extra);

  01329	2b fa		 sub	 edi, edx
  0132b	d3 e0		 shl	 eax, cl
  0132d	ff c8		 dec	 eax
  0132f	41 23 c5	 and	 eax, r13d
  01332	41 d3 ed	 shr	 r13d, cl
  01335	41 01 46 4c	 add	 DWORD PTR [r14+76], eax

; 1097 :                 state->back += state->extra;

  01339	41 01 96 dc 1b
	00 00		 add	 DWORD PTR [r14+7132], edx
$LN74@inflate:

; 1098 :             }
; 1099 : #ifdef INFLATE_STRICT
; 1100 :             if (state->offset > state->dmax) {
; 1101 :                 strm->msg = (char *)"invalid distance too far back";
; 1102 :                 state->mode = BAD;
; 1103 :                 break;
; 1104 :             }
; 1105 : #endif
; 1106 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1107 :             state->mode = MATCH;

  01340	41 c7 06 18 00
	00 00		 mov	 DWORD PTR [r14], 24
$LN61@inflate:

; 1108 :         case MATCH:
; 1109 :             if (left == 0) goto inf_leave;

  01347	45 85 d2	 test	 r10d, r10d
  0134a	0f 84 0d f5 ff
	ff		 je	 $LN782@inflate

; 1110 :             copy = out - left;
; 1111 :             if (state->offset > copy) {         /* copy from window */

  01350	41 8b 4e 4c	 mov	 ecx, DWORD PTR [r14+76]
  01354	41 8b c0	 mov	 eax, r8d
  01357	41 2b c2	 sub	 eax, r10d
  0135a	3b c8		 cmp	 ecx, eax
  0135c	76 4d		 jbe	 SHORT $LN59@inflate

; 1112 :                 copy = state->offset - copy;

  0135e	2b c8		 sub	 ecx, eax

; 1113 :                 if (copy > state->whave) {

  01360	41 3b 4e 30	 cmp	 ecx, DWORD PTR [r14+48]
  01364	76 21		 jbe	 SHORT $LN57@inflate

; 1114 :                     if (state->sane) {

  01366	41 83 be d8 1b
	00 00 00	 cmp	 DWORD PTR [r14+7128], 0
  0136e	74 17		 je	 SHORT $LN57@inflate

; 1115 :                         strm->msg = (char *)"invalid distance too far back";

  01370	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  01377	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  0137b	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29
  01382	e9 58 f3 ff ff	 jmp	 $LN498@inflate
$LN57@inflate:

; 1116 :                         state->mode = BAD;
; 1117 :                         break;
; 1118 :                     }
; 1119 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1120 :                     Trace((stderr, "inflate.c too far\n"));
; 1121 :                     copy -= state->whave;
; 1122 :                     if (copy > state->length) copy = state->length;
; 1123 :                     if (copy > left) copy = left;
; 1124 :                     left -= copy;
; 1125 :                     state->length -= copy;
; 1126 :                     do {
; 1127 :                         *put++ = 0;
; 1128 :                     } while (--copy);
; 1129 :                     if (state->length == 0) state->mode = LEN;
; 1130 :                     break;
; 1131 : #endif
; 1132 :                 }
; 1133 :                 if (copy > state->wnext) {

  01387	41 8b 46 34	 mov	 eax, DWORD PTR [r14+52]
  0138b	3b c8		 cmp	 ecx, eax
  0138d	76 0a		 jbe	 SHORT $LN56@inflate

; 1134 :                     copy -= state->wnext;
; 1135 :                     from = state->window + (state->wsize - copy);

  0138f	41 8b 56 2c	 mov	 edx, DWORD PTR [r14+44]
  01393	2b c8		 sub	 ecx, eax
  01395	2b d1		 sub	 edx, ecx

; 1136 :                 }
; 1137 :                 else

  01397	eb 04		 jmp	 SHORT $LN818@inflate
$LN56@inflate:

; 1138 :                     from = state->window + (state->wnext - copy);

  01399	2b c1		 sub	 eax, ecx
  0139b	8b d0		 mov	 edx, eax
$LN818@inflate:

; 1139 :                 if (copy > state->length) copy = state->length;

  0139d	41 8b 46 48	 mov	 eax, DWORD PTR [r14+72]
  013a1	49 03 56 38	 add	 rdx, QWORD PTR [r14+56]
  013a5	3b c8		 cmp	 ecx, eax
  013a7	76 0e		 jbe	 SHORT $LN53@inflate

; 1140 :             }
; 1141 :             else {                              /* copy from output */

  013a9	eb 0a		 jmp	 SHORT $LN819@inflate
$LN59@inflate:

; 1142 :                 from = put - state->offset;
; 1143 :                 copy = state->length;

  013ab	41 8b 46 48	 mov	 eax, DWORD PTR [r14+72]
  013af	49 8b d1	 mov	 rdx, r9
  013b2	48 2b d1	 sub	 rdx, rcx
$LN819@inflate:
  013b5	8b c8		 mov	 ecx, eax
$LN53@inflate:

; 1144 :             }
; 1145 :             if (copy > left) copy = left;

  013b7	41 3b ca	 cmp	 ecx, r10d
  013ba	41 0f 47 ca	 cmova	 ecx, r10d

; 1146 :             left -= copy;

  013be	44 2b d1	 sub	 r10d, ecx

; 1147 :             state->length -= copy;

  013c1	2b c1		 sub	 eax, ecx

; 1150 :             } while (--copy);

  013c3	49 2b d1	 sub	 rdx, r9
  013c6	44 89 55 38	 mov	 DWORD PTR left$1$[rbp-128], r10d
  013ca	41 89 46 48	 mov	 DWORD PTR [r14+72], eax
  013ce	66 90		 npad	 2
$LL51@inflate:

; 1148 :             do {
; 1149 :                 *put++ = *from++;

  013d0	42 0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+r9]
  013d5	49 ff c1	 inc	 r9

; 1150 :             } while (--copy);

  013d8	ff c9		 dec	 ecx
  013da	41 88 41 ff	 mov	 BYTE PTR [r9-1], al
  013de	75 f0		 jne	 SHORT $LL51@inflate

; 1151 :             if (state->length == 0) state->mode = LEN;

  013e0	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9
  013e4	41 39 4e 48	 cmp	 DWORD PTR [r14+72], ecx
  013e8	0f 85 f1 f2 ff
	ff		 jne	 $LN498@inflate
  013ee	41 c7 06 14 00
	00 00		 mov	 DWORD PTR [r14], 20

; 1152 :             break;

  013f5	e9 e5 f2 ff ff	 jmp	 $LN498@inflate
$LN47@inflate:

; 1153 :         case LIT:
; 1154 :             if (left == 0) goto inf_leave;

  013fa	45 85 d2	 test	 r10d, r10d
  013fd	0f 84 5a f4 ff
	ff		 je	 $LN782@inflate

; 1155 :             *put++ = (unsigned char)(state->length);

  01403	41 0f b6 46 48	 movzx	 eax, BYTE PTR [r14+72]
  01408	49 ff c1	 inc	 r9

; 1156 :             left--;

  0140b	41 ff ca	 dec	 r10d
  0140e	41 88 41 ff	 mov	 BYTE PTR [r9-1], al
  01412	44 89 55 38	 mov	 DWORD PTR left$1$[rbp-128], r10d
  01416	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9

; 1157 :             state->mode = LEN;

  0141a	41 c7 06 14 00
	00 00		 mov	 DWORD PTR [r14], 20

; 1158 :             break;

  01421	e9 b9 f2 ff ff	 jmp	 $LN498@inflate
$LN45@inflate:

; 1159 :         case CHECK:
; 1160 :             if (state->wrap) {

  01426	41 83 7e 08 00	 cmp	 DWORD PTR [r14+8], 0
  0142b	0f 84 bc 00 00
	00		 je	 $LN30@inflate

; 1161 :                 NEEDBITS(32);

  01431	83 ff 20	 cmp	 edi, 32			; 00000020H
  01434	73 21		 jae	 SHORT $LN42@inflate
$LL40@inflate:
  01436	85 f6		 test	 esi, esi
  01438	0f 84 1f f4 ff
	ff		 je	 $LN782@inflate
  0143e	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  01443	8b cf		 mov	 ecx, edi
  01445	83 c7 08	 add	 edi, 8
  01448	d3 e0		 shl	 eax, cl
  0144a	ff ce		 dec	 esi
  0144c	49 ff c4	 inc	 r12
  0144f	44 03 e8	 add	 r13d, eax
  01452	83 ff 20	 cmp	 edi, 32			; 00000020H
  01455	72 df		 jb	 SHORT $LL40@inflate
$LN42@inflate:

; 1162 :                 out -= left;

  01457	45 2b c2	 sub	 r8d, r10d

; 1163 :                 strm->total_out += out;

  0145a	44 01 43 1c	 add	 DWORD PTR [rbx+28], r8d

; 1164 :                 state->total += out;

  0145e	45 01 46 1c	 add	 DWORD PTR [r14+28], r8d

; 1165 :                 if (out)

  01462	45 85 c0	 test	 r8d, r8d
  01465	74 2f		 je	 SHORT $LN34@inflate

; 1166 :                     strm->adler = state->check =
; 1167 :                         UPDATE(state->check, put - out, out);

  01467	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  0146b	41 8b c0	 mov	 eax, r8d
  0146e	49 8b d1	 mov	 rdx, r9
  01471	48 2b d0	 sub	 rdx, rax
  01474	41 83 7e 10 00	 cmp	 DWORD PTR [r14+16], 0
  01479	74 07		 je	 SHORT $LN512@inflate
  0147b	e8 00 00 00 00	 call	 crc32
  01480	eb 05		 jmp	 SHORT $LN513@inflate
$LN512@inflate:
  01482	e8 00 00 00 00	 call	 adler32
$LN513@inflate:
  01487	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  0148b	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]
  0148f	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
  01493	89 43 4c	 mov	 DWORD PTR [rbx+76], eax
$LN34@inflate:

; 1168 :                 out = left;
; 1169 :                 if ((
; 1170 : #ifdef GUNZIP
; 1171 :                      state->flags ? hold :
; 1172 : #endif
; 1173 :                      REVERSE(hold)) != state->check) {

  01496	41 83 7e 10 00	 cmp	 DWORD PTR [r14+16], 0
  0149b	44 89 55 b8	 mov	 DWORD PTR out$1$[rbp-128], r10d
  0149f	41 8b cd	 mov	 ecx, r13d
  014a2	75 26		 jne	 SHORT $LN515@inflate
  014a4	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  014aa	41 8b c5	 mov	 eax, r13d
  014ad	c1 e0 10	 shl	 eax, 16
  014b0	03 c8		 add	 ecx, eax
  014b2	41 8b c5	 mov	 eax, r13d
  014b5	c1 e8 08	 shr	 eax, 8
  014b8	c1 e1 08	 shl	 ecx, 8
  014bb	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  014c0	03 c8		 add	 ecx, eax
  014c2	41 8b c5	 mov	 eax, r13d
  014c5	c1 e8 18	 shr	 eax, 24
  014c8	03 c8		 add	 ecx, eax
$LN515@inflate:
  014ca	41 3b 4e 18	 cmp	 ecx, DWORD PTR [r14+24]
  014ce	74 17		 je	 SHORT $LN32@inflate

; 1174 :                     strm->msg = (char *)"incorrect data check";

  014d0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
  014d7	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  014db	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29
  014e2	e9 f8 f1 ff ff	 jmp	 $LN498@inflate
$LN32@inflate:

; 1175 :                     state->mode = BAD;
; 1176 :                     break;
; 1177 :                 }
; 1178 :                 INITBITS();

  014e7	45 8b ef	 mov	 r13d, r15d
  014ea	41 8b ff	 mov	 edi, r15d
$LN30@inflate:

; 1179 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1180 :             }
; 1181 : #ifdef GUNZIP
; 1182 :             state->mode = LENGTH;

  014ed	41 c7 06 1b 00
	00 00		 mov	 DWORD PTR [r14], 27
$LN29@inflate:

; 1183 :         case LENGTH:
; 1184 :             if (state->wrap && state->flags) {

  014f4	41 83 7e 08 00	 cmp	 DWORD PTR [r14+8], 0
  014f9	74 70		 je	 SHORT $LN15@inflate
  014fb	41 83 7e 10 00	 cmp	 DWORD PTR [r14+16], 0
  01500	74 69		 je	 SHORT $LN15@inflate

; 1185 :                 NEEDBITS(32);

  01502	83 ff 20	 cmp	 edi, 32			; 00000020H
  01505	73 21		 jae	 SHORT $LN26@inflate
$LL24@inflate:
  01507	85 f6		 test	 esi, esi
  01509	0f 84 4e f3 ff
	ff		 je	 $LN782@inflate
  0150f	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  01514	8b cf		 mov	 ecx, edi
  01516	83 c7 08	 add	 edi, 8
  01519	d3 e0		 shl	 eax, cl
  0151b	ff ce		 dec	 esi
  0151d	49 ff c4	 inc	 r12
  01520	44 03 e8	 add	 r13d, eax
  01523	83 ff 20	 cmp	 edi, 32			; 00000020H
  01526	72 df		 jb	 SHORT $LL24@inflate
$LN26@inflate:

; 1186 :                 if (hold != (state->total & 0xffffffffUL)) {

  01528	45 3b 6e 1c	 cmp	 r13d, DWORD PTR [r14+28]
  0152c	74 37		 je	 SHORT $LN17@inflate

; 1187 :                     strm->msg = (char *)"incorrect length check";

  0152e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
  01535	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  01539	41 c7 06 1d 00
	00 00		 mov	 DWORD PTR [r14], 29
  01540	e9 9a f1 ff ff	 jmp	 $LN498@inflate
$LN589@inflate:

; 805  :                 RESTORE();

  01545	4c 89 4b 10	 mov	 QWORD PTR [rbx+16], r9
  01549	44 89 53 18	 mov	 DWORD PTR [rbx+24], r10d
  0154d	4c 89 23	 mov	 QWORD PTR [rbx], r12
  01550	89 73 08	 mov	 DWORD PTR [rbx+8], esi

; 806  :                 return Z_NEED_DICT;

  01553	b8 02 00 00 00	 mov	 eax, 2
  01558	45 89 6e 40	 mov	 DWORD PTR [r14+64], r13d
  0155c	41 89 7e 44	 mov	 DWORD PTR [r14+68], edi
  01560	e9 57 f3 ff ff	 jmp	 $LN816@inflate
$LN17@inflate:

; 1188 :                     state->mode = BAD;
; 1189 :                     break;
; 1190 :                 }
; 1191 :                 INITBITS();

  01565	45 8b ef	 mov	 r13d, r15d
  01568	41 8b ff	 mov	 edi, r15d
$LN15@inflate:

; 1192 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1193 :             }
; 1194 : #endif
; 1195 :             state->mode = DONE;

  0156b	41 c7 06 1c 00
	00 00		 mov	 DWORD PTR [r14], 28
$LN14@inflate:

; 1196 :         case DONE:
; 1197 :             ret = Z_STREAM_END;

  01572	41 bf 01 00 00
	00		 mov	 r15d, 1

; 1198 :             goto inf_leave;

  01578	e9 e4 f2 ff ff	 jmp	 $inf_leave$5023
$LN13@inflate:

; 1199 :         case BAD:
; 1200 :             ret = Z_DATA_ERROR;

  0157d	41 bf fd ff ff
	ff		 mov	 r15d, -3

; 993  :             state->distbits = 6;
; 994  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 995  :                             &(state->next), &(state->distbits), state->work);

  01583	e9 d9 f2 ff ff	 jmp	 $inf_leave$5023
$LN5@inflate:

; 1221 :         }
; 1222 :     in -= strm->avail_in;
; 1223 :     out -= strm->avail_out;

  01588	2b 7b 18	 sub	 edi, DWORD PTR [rbx+24]
  0158b	44 8b 55 bc	 mov	 r10d, DWORD PTR in$1$[rbp-128]
  0158f	44 2b 53 08	 sub	 r10d, DWORD PTR [rbx+8]

; 1224 :     strm->total_in += in;
; 1225 :     strm->total_out += out;

  01593	01 7b 1c	 add	 DWORD PTR [rbx+28], edi
  01596	44 01 53 0c	 add	 DWORD PTR [rbx+12], r10d

; 1226 :     state->total += out;

  0159a	41 01 7e 1c	 add	 DWORD PTR [r14+28], edi

; 1227 :     if (state->wrap && out)

  0159e	41 83 7e 08 00	 cmp	 DWORD PTR [r14+8], 0
  015a3	44 89 55 bc	 mov	 DWORD PTR in$1$[rbp-128], r10d
  015a7	74 32		 je	 SHORT $LN4@inflate
  015a9	85 ff		 test	 edi, edi
  015ab	74 2e		 je	 SHORT $LN4@inflate

; 1228 :         strm->adler = state->check =
; 1229 :             UPDATE(state->check, strm->next_out - out, out);

  015ad	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  015b1	41 8b 4e 18	 mov	 ecx, DWORD PTR [r14+24]
  015b5	8b c7		 mov	 eax, edi
  015b7	48 2b d0	 sub	 rdx, rax
  015ba	41 83 7e 10 00	 cmp	 DWORD PTR [r14+16], 0
  015bf	44 8b c7	 mov	 r8d, edi
  015c2	74 07		 je	 SHORT $LN516@inflate
  015c4	e8 00 00 00 00	 call	 crc32
  015c9	eb 05		 jmp	 SHORT $LN517@inflate
$LN516@inflate:
  015cb	e8 00 00 00 00	 call	 adler32
$LN517@inflate:
  015d0	44 8b 55 bc	 mov	 r10d, DWORD PTR in$1$[rbp-128]
  015d4	41 89 46 18	 mov	 DWORD PTR [r14+24], eax
  015d8	89 43 4c	 mov	 DWORD PTR [rbx+76], eax
$LN4@inflate:

; 1230 :     strm->data_type = state->bits + (state->last ? 64 : 0) +
; 1231 :                       (state->mode == TYPE ? 128 : 0) +
; 1232 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);

  015db	41 8b 16	 mov	 edx, DWORD PTR [r14]
  015de	83 fa 13	 cmp	 edx, 19
  015e1	74 0d		 je	 SHORT $LN518@inflate
  015e3	83 fa 0e	 cmp	 edx, 14
  015e6	74 08		 je	 SHORT $LN518@inflate
  015e8	45 33 c9	 xor	 r9d, r9d
  015eb	45 8b c1	 mov	 r8d, r9d
  015ee	eb 09		 jmp	 SHORT $LN519@inflate
$LN518@inflate:
  015f0	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  015f6	45 33 c9	 xor	 r9d, r9d
$LN519@inflate:
  015f9	41 8b 46 04	 mov	 eax, DWORD PTR [r14+4]
  015fd	f7 d8		 neg	 eax
  015ff	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  01604	1b c9		 sbb	 ecx, ecx
  01606	83 e1 40	 and	 ecx, 64			; 00000040H
  01609	83 fa 0b	 cmp	 edx, 11
  0160c	44 0f 44 c8	 cmove	 r9d, eax
  01610	41 8d 04 08	 lea	 eax, DWORD PTR [r8+rcx]
  01614	44 03 c8	 add	 r9d, eax
  01617	45 03 4e 44	 add	 r9d, DWORD PTR [r14+68]
  0161b	44 89 4b 48	 mov	 DWORD PTR [rbx+72], r9d

; 1233 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  0161f	45 85 d2	 test	 r10d, r10d
  01622	75 04		 jne	 SHORT $LN1@inflate
  01624	85 ff		 test	 edi, edi
  01626	74 06		 je	 SHORT $LN2@inflate
$LN1@inflate:
  01628	83 7d 28 04	 cmp	 DWORD PTR flush$[rbp-128], 4
  0162c	75 0c		 jne	 SHORT $LN3@inflate
$LN2@inflate:
  0162e	b8 fb ff ff ff	 mov	 eax, -5
  01633	45 85 ff	 test	 r15d, r15d
  01636	44 0f 44 f8	 cmove	 r15d, eax
$LN3@inflate:

; 1234 :         ret = Z_BUF_ERROR;
; 1235 :     return ret;

  0163a	41 8b c7	 mov	 eax, r15d
  0163d	e9 7a f2 ff ff	 jmp	 $LN816@inflate
$LN11@inflate:

; 1201 :             goto inf_leave;
; 1202 :         case MEM:
; 1203 :             return Z_MEM_ERROR;
; 1204 :         case SYNC:
; 1205 :         default:
; 1206 :             return Z_STREAM_ERROR;

  01642	b8 fe ff ff ff	 mov	 eax, -2
  01647	e9 70 f2 ff ff	 jmp	 $LN816@inflate
$LN506@inflate:

; 614  :         return Z_STREAM_ERROR;

  0164c	b8 fe ff ff ff	 mov	 eax, -2

; 1236 : }

  01651	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  01658	41 5e		 pop	 r14
  0165a	5b		 pop	 rbx
  0165b	5d		 pop	 rbp
  0165c	c3		 ret	 0
  0165d	0f 1f 00	 npad	 3
$LN684@inflate:
  01660	00 00 00 00	 DD	 $LN497@inflate
  01664	00 00 00 00	 DD	 $LN465@inflate
  01668	00 00 00 00	 DD	 $LN445@inflate
  0166c	00 00 00 00	 DD	 $LN427@inflate
  01670	00 00 00 00	 DD	 $LN410@inflate
  01674	00 00 00 00	 DD	 $LN389@inflate
  01678	00 00 00 00	 DD	 $LN382@inflate
  0167c	00 00 00 00	 DD	 $LN370@inflate
  01680	00 00 00 00	 DD	 $LN358@inflate
  01684	00 00 00 00	 DD	 $LN341@inflate
  01688	00 00 00 00	 DD	 $LN329@inflate
  0168c	00 00 00 00	 DD	 $LN324@inflate
  01690	00 00 00 00	 DD	 $LN323@inflate
  01694	00 00 00 00	 DD	 $LN290@inflate
  01698	00 00 00 00	 DD	 $LN274@inflate
  0169c	00 00 00 00	 DD	 $LN272@inflate
  016a0	00 00 00 00	 DD	 $LN266@inflate
  016a4	00 00 00 00	 DD	 $LN533@inflate
  016a8	00 00 00 00	 DD	 $LN536@inflate
  016ac	00 00 00 00	 DD	 $LN147@inflate
  016b0	00 00 00 00	 DD	 $LN145@inflate
  016b4	00 00 00 00	 DD	 $LN112@inflate
  016b8	00 00 00 00	 DD	 $LN546@inflate
  016bc	00 00 00 00	 DD	 $LN75@inflate
  016c0	00 00 00 00	 DD	 $LN61@inflate
  016c4	00 00 00 00	 DD	 $LN47@inflate
  016c8	00 00 00 00	 DD	 $LN45@inflate
  016cc	00 00 00 00	 DD	 $LN29@inflate
  016d0	00 00 00 00	 DD	 $LN14@inflate
  016d4	00 00 00 00	 DD	 $LN13@inflate
  016d8	00 00 00 00	 DD	 $LN12@inflate
inflate	ENDP
_TEXT	ENDS
PUBLIC	inflateEnd
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateEnd DD imagerel $LN6
	DD	imagerel $LN6+86
	DD	imagerel $unwind$inflateEnd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateEnd DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflateEnd
_TEXT	SEGMENT
strm$ = 48
inflateEnd PROC						; COMDAT

; 1240 : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1241 :     struct inflate_state FAR *state;
; 1242 :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 3d		 je	 SHORT $LN2@inflateEnd
  0000e	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00012	48 85 c0	 test	 rax, rax
  00015	74 34		 je	 SHORT $LN2@inflateEnd
  00017	4c 8b 41 38	 mov	 r8, QWORD PTR [rcx+56]
  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 2b		 je	 SHORT $LN2@inflateEnd

; 1244 :     state = (struct inflate_state FAR *)strm->state;
; 1245 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  00020	48 8b 50 38	 mov	 rdx, QWORD PTR [rax+56]
  00024	48 85 d2	 test	 rdx, rdx
  00027	74 07		 je	 SHORT $LN1@inflateEnd
  00029	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0002d	41 ff d0	 call	 r8
$LN1@inflateEnd:

; 1246 :     ZFREE(strm, strm->state);

  00030	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
  00034	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00038	ff 53 38	 call	 QWORD PTR [rbx+56]

; 1247 :     strm->state = Z_NULL;

  0003b	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 1248 :     Tracev((stderr, "inflate: end\n"));
; 1249 :     return Z_OK;

  00043	33 c0		 xor	 eax, eax

; 1250 : }

  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
$LN2@inflateEnd:

; 1243 :         return Z_STREAM_ERROR;

  0004b	b8 fe ff ff ff	 mov	 eax, -2

; 1250 : }

  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5b		 pop	 rbx
  00055	c3		 ret	 0
inflateEnd ENDP
_TEXT	ENDS
PUBLIC	inflateSetDictionary
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSetDictionary DD imagerel $LN12
	DD	imagerel $LN12+234
	DD	imagerel $unwind$inflateSetDictionary
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSetDictionary DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflateSetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
inflateSetDictionary PROC				; COMDAT

; 1256 : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	41 8b f0	 mov	 esi, r8d
  00017	48 8b ea	 mov	 rbp, rdx
  0001a	48 8b f9	 mov	 rdi, rcx

; 1257 :     struct inflate_state FAR *state;
; 1258 :     unsigned long id;
; 1259 : 
; 1260 :     /* check state */
; 1261 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0001d	48 85 c9	 test	 rcx, rcx
  00020	74 14		 je	 SHORT $LN7@inflateSet
  00022	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  00026	48 85 db	 test	 rbx, rbx
  00029	74 0b		 je	 SHORT $LN7@inflateSet

; 1262 :     state = (struct inflate_state FAR *)strm->state;
; 1263 :     if (state->wrap != 0 && state->mode != DICT)

  0002b	83 7b 08 00	 cmp	 DWORD PTR [rbx+8], 0
  0002f	74 1f		 je	 SHORT $LN6@inflateSet
  00031	83 3b 0a	 cmp	 DWORD PTR [rbx], 10
  00034	74 1f		 je	 SHORT $LN11@inflateSet
$LN7@inflateSet:

; 1257 :     struct inflate_state FAR *state;
; 1258 :     unsigned long id;
; 1259 : 
; 1260 :     /* check state */
; 1261 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00036	b8 fe ff ff ff	 mov	 eax, -2
$LN9@inflateSet:

; 1292 : }

  0003b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00040	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00045	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
$LN6@inflateSet:

; 1264 :         return Z_STREAM_ERROR;
; 1265 : 
; 1266 :     /* check for correct dictionary id */
; 1267 :     if (state->mode == DICT) {

  00050	83 3b 0a	 cmp	 DWORD PTR [rbx], 10
  00053	75 25		 jne	 SHORT $LN4@inflateSet
$LN11@inflateSet:

; 1268 :         id = adler32(0L, Z_NULL, 0);

  00055	45 33 c0	 xor	 r8d, r8d
  00058	33 d2		 xor	 edx, edx
  0005a	33 c9		 xor	 ecx, ecx
  0005c	e8 00 00 00 00	 call	 adler32

; 1269 :         id = adler32(id, dictionary, dictLength);

  00061	44 8b c6	 mov	 r8d, esi
  00064	48 8b d5	 mov	 rdx, rbp
  00067	8b c8		 mov	 ecx, eax
  00069	e8 00 00 00 00	 call	 adler32

; 1270 :         if (id != state->check)

  0006e	3b 43 18	 cmp	 eax, DWORD PTR [rbx+24]
  00071	74 07		 je	 SHORT $LN4@inflateSet

; 1271 :             return Z_DATA_ERROR;

  00073	b8 fd ff ff ff	 mov	 eax, -3
  00078	eb c1		 jmp	 SHORT $LN9@inflateSet
$LN4@inflateSet:

; 1272 :     }
; 1273 : 
; 1274 :     /* copy dictionary to window */
; 1275 :     if (updatewindow(strm, strm->avail_out)) {

  0007a	8b 57 18	 mov	 edx, DWORD PTR [rdi+24]
  0007d	48 8b cf	 mov	 rcx, rdi
  00080	e8 00 00 00 00	 call	 updatewindow
  00085	85 c0		 test	 eax, eax
  00087	74 0d		 je	 SHORT $LN3@inflateSet

; 1276 :         state->mode = MEM;

  00089	c7 03 1e 00 00
	00		 mov	 DWORD PTR [rbx], 30

; 1277 :         return Z_MEM_ERROR;

  0008f	b8 fc ff ff ff	 mov	 eax, -4
  00094	eb a5		 jmp	 SHORT $LN9@inflateSet
$LN3@inflateSet:

; 1278 :     }
; 1279 :     if (dictLength > state->wsize) {

  00096	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]

; 1280 :         zmemcpy(state->window, dictionary + dictLength - state->wsize,
; 1281 :                 state->wsize);

  00099	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  0009d	3b f0		 cmp	 esi, eax
  0009f	76 27		 jbe	 SHORT $LN2@inflateSet
  000a1	48 8b d6	 mov	 rdx, rsi
  000a4	44 8b c0	 mov	 r8d, eax
  000a7	48 2b d0	 sub	 rdx, rax
  000aa	48 03 d5	 add	 rdx, rbp
  000ad	e8 00 00 00 00	 call	 memcpy

; 1282 :         state->whave = state->wsize;

  000b2	44 8b 5b 2c	 mov	 r11d, DWORD PTR [rbx+44]

; 1288 :     }
; 1289 :     state->havedict = 1;

  000b6	c7 43 0c 01 00
	00 00		 mov	 DWORD PTR [rbx+12], 1
  000bd	44 89 5b 30	 mov	 DWORD PTR [rbx+48], r11d

; 1290 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1291 :     return Z_OK;

  000c1	33 c0		 xor	 eax, eax
  000c3	e9 73 ff ff ff	 jmp	 $LN9@inflateSet
$LN2@inflateSet:

; 1283 :     }
; 1284 :     else {
; 1285 :         zmemcpy(state->window + state->wsize - dictLength, dictionary,
; 1286 :                 dictLength);

  000c8	48 2b ce	 sub	 rcx, rsi
  000cb	4c 8b c6	 mov	 r8, rsi
  000ce	48 8b d5	 mov	 rdx, rbp
  000d1	48 03 c8	 add	 rcx, rax
  000d4	e8 00 00 00 00	 call	 memcpy

; 1287 :         state->whave = dictLength;

  000d9	89 73 30	 mov	 DWORD PTR [rbx+48], esi

; 1288 :     }
; 1289 :     state->havedict = 1;

  000dc	c7 43 0c 01 00
	00 00		 mov	 DWORD PTR [rbx+12], 1

; 1290 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1291 :     return Z_OK;

  000e3	33 c0		 xor	 eax, eax
  000e5	e9 51 ff ff ff	 jmp	 $LN9@inflateSet
inflateSetDictionary ENDP
_TEXT	ENDS
PUBLIC	inflateGetHeader
; Function compile flags: /Ogtpy
;	COMDAT inflateGetHeader
_TEXT	SEGMENT
strm$ = 8
head$ = 16
inflateGetHeader PROC					; COMDAT

; 1298 :     struct inflate_state FAR *state;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 1d		 je	 SHORT $LN2@inflateGet
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 14		 je	 SHORT $LN2@inflateGet

; 1302 :     state = (struct inflate_state FAR *)strm->state;
; 1303 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  0000e	f6 40 08 02	 test	 BYTE PTR [rax+8], 2
  00012	74 0e		 je	 SHORT $LN2@inflateGet

; 1304 : 
; 1305 :     /* save header structure */
; 1306 :     state->head = head;

  00014	48 89 50 20	 mov	 QWORD PTR [rax+32], rdx

; 1307 :     head->done = 0;

  00018	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [rdx+64], 0

; 1308 :     return Z_OK;

  0001f	33 c0		 xor	 eax, eax

; 1309 : }

  00021	c3		 ret	 0
$LN2@inflateGet:

; 1298 :     struct inflate_state FAR *state;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00022	b8 fe ff ff ff	 mov	 eax, -2

; 1309 : }

  00027	c3		 ret	 0
inflateGetHeader ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$syncsearch DD imagerel syncsearch
	DD	imagerel syncsearch+106
	DD	imagerel $unwind$syncsearch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$syncsearch DD 020501H
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT syncsearch
_TEXT	SEGMENT
have$ = 8
buf$ = 16
len$ = 24
syncsearch PROC						; COMDAT

; 1326 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 1327 :     unsigned got;
; 1328 :     unsigned next;
; 1329 : 
; 1330 :     got = *have;

  00005	44 8b 09	 mov	 r9d, DWORD PTR [rcx]

; 1331 :     next = 0;

  00008	33 db		 xor	 ebx, ebx
  0000a	4c 8b d9	 mov	 r11, rcx
  0000d	44 8b d3	 mov	 r10d, ebx

; 1332 :     while (next < len && got < 4) {

  00010	45 85 c0	 test	 r8d, r8d
  00013	74 49		 je	 SHORT $LN11@syncsearch
$LL6@syncsearch:
  00015	41 83 f9 04	 cmp	 r9d, 4
  00019	73 37		 jae	 SHORT $LN12@syncsearch

; 1333 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  0001b	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
  0001e	41 83 f9 02	 cmp	 r9d, 2
  00022	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00027	0f 42 c3	 cmovb	 eax, ebx
  0002a	3b c8		 cmp	 ecx, eax
  0002c	75 05		 jne	 SHORT $LN4@syncsearch

; 1334 :             got++;

  0002e	41 ff c1	 inc	 r9d
  00031	eb 14		 jmp	 SHORT $LN1@syncsearch
$LN4@syncsearch:

; 1335 :         else if (buf[next])

  00033	84 c9		 test	 cl, cl
  00035	74 05		 je	 SHORT $LN2@syncsearch

; 1336 :             got = 0;

  00037	44 8b cb	 mov	 r9d, ebx

; 1337 :         else

  0003a	eb 0b		 jmp	 SHORT $LN1@syncsearch
$LN2@syncsearch:

; 1338 :             got = 4 - got;

  0003c	b9 04 00 00 00	 mov	 ecx, 4
  00041	41 2b c9	 sub	 ecx, r9d
  00044	44 8b c9	 mov	 r9d, ecx
$LN1@syncsearch:

; 1339 :         next++;

  00047	41 ff c2	 inc	 r10d
  0004a	48 ff c2	 inc	 rdx
  0004d	45 3b d0	 cmp	 r10d, r8d
  00050	72 c3		 jb	 SHORT $LL6@syncsearch
$LN12@syncsearch:

; 1340 :     }
; 1341 :     *have = got;

  00052	45 89 0b	 mov	 DWORD PTR [r11], r9d

; 1342 :     return next;

  00055	41 8b c2	 mov	 eax, r10d

; 1343 : }

  00058	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0005d	c3		 ret	 0
$LN11@syncsearch:
  0005e	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00063	44 89 09	 mov	 DWORD PTR [rcx], r9d
  00066	41 8b c2	 mov	 eax, r10d
  00069	c3		 ret	 0
syncsearch ENDP
_TEXT	ENDS
PUBLIC	inflateSync
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSync DD imagerel $LN12
	DD	imagerel $LN12+66
	DD	imagerel $unwind$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflateSync DD imagerel $LN12+66
	DD	imagerel $LN12+204
	DD	imagerel $chain$0$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateSync DD imagerel $LN12+204
	DD	imagerel $LN12+275
	DD	imagerel $chain$1$inflateSync
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateSync DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+66
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflateSync DD 020521H
	DD	073405H
	DD	imagerel $LN12
	DD	imagerel $LN12+66
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSync DD 040a01H
	DD	08640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflateSync
_TEXT	SEGMENT
buf$ = 48
strm$ = 48
inflateSync PROC					; COMDAT

; 1347 : {

$LN12:
  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f1	 mov	 rsi, rcx

; 1348 :     unsigned len;               /* number of bytes to look at or looked at */
; 1349 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1350 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1351 :     struct inflate_state FAR *state;
; 1352 : 
; 1353 :     /* check parameters */
; 1354 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0000d	48 85 c9	 test	 rcx, rcx
  00010	0f 84 ed 00 00
	00		 je	 $LN6@inflateSyn
  00016	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  0001a	48 85 ff	 test	 rdi, rdi
  0001d	0f 84 e0 00 00
	00		 je	 $LN6@inflateSyn

; 1355 :     state = (struct inflate_state FAR *)strm->state;
; 1356 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  00023	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00027	75 16		 jne	 SHORT $LN5@inflateSyn
  00029	83 7f 44 08	 cmp	 DWORD PTR [rdi+68], 8
  0002d	73 10		 jae	 SHORT $LN5@inflateSyn
  0002f	b8 fb ff ff ff	 mov	 eax, -5

; 1386 : }

  00034	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
$LN5@inflateSyn:

; 1357 : 
; 1358 :     /* if first time, start search in bit buffer */
; 1359 :     if (state->mode != SYNC) {

  0003f	83 3f 1f	 cmp	 DWORD PTR [rdi], 31
  00042	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  00047	74 59		 je	 SHORT $LN4@inflateSyn

; 1360 :         state->mode = SYNC;
; 1361 :         state->hold <<= state->bits & 7;

  00049	8b 57 44	 mov	 edx, DWORD PTR [rdi+68]

; 1362 :         state->bits -= state->bits & 7;
; 1363 :         len = 0;

  0004c	45 33 c0	 xor	 r8d, r8d
  0004f	c7 07 1f 00 00
	00		 mov	 DWORD PTR [rdi], 31
  00055	8b ca		 mov	 ecx, edx
  00057	83 e1 07	 and	 ecx, 7
  0005a	d3 67 40	 shl	 DWORD PTR [rdi+64], cl
  0005d	2b d1		 sub	 edx, ecx
  0005f	89 57 44	 mov	 DWORD PTR [rdi+68], edx

; 1364 :         while (state->bits >= 8) {

  00062	83 fa 08	 cmp	 edx, 8
  00065	72 27		 jb	 SHORT $LN2@inflateSyn
  00067	8b 4f 40	 mov	 ecx, DWORD PTR [rdi+64]
  0006a	4c 8d 4c 24 30	 lea	 r9, QWORD PTR buf$[rsp]
  0006f	90		 npad	 1
$LL3@inflateSyn:

; 1365 :             buf[len++] = (unsigned char)(state->hold);

  00070	0f b6 47 40	 movzx	 eax, BYTE PTR [rdi+64]

; 1366 :             state->hold >>= 8;
; 1367 :             state->bits -= 8;

  00074	83 c2 f8	 add	 edx, -8			; fffffff8H
  00077	c1 e9 08	 shr	 ecx, 8
  0007a	41 88 01	 mov	 BYTE PTR [r9], al
  0007d	49 ff c1	 inc	 r9
  00080	41 ff c0	 inc	 r8d
  00083	89 4f 40	 mov	 DWORD PTR [rdi+64], ecx
  00086	89 57 44	 mov	 DWORD PTR [rdi+68], edx
  00089	83 fa 08	 cmp	 edx, 8
  0008c	73 e2		 jae	 SHORT $LL3@inflateSyn
$LN2@inflateSyn:

; 1368 :         }
; 1369 :         state->have = 0;

  0008e	48 8d 4f 7c	 lea	 rcx, QWORD PTR [rdi+124]

; 1370 :         syncsearch(&(state->have), buf, len);

  00092	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  00097	c7 01 00 00 00
	00		 mov	 DWORD PTR [rcx], 0
  0009d	e8 00 00 00 00	 call	 syncsearch
$LN4@inflateSyn:

; 1371 :     }
; 1372 : 
; 1373 :     /* search available input */
; 1374 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  000a2	44 8b 46 08	 mov	 r8d, DWORD PTR [rsi+8]
  000a6	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  000a9	48 8d 4f 7c	 lea	 rcx, QWORD PTR [rdi+124]
  000ad	e8 00 00 00 00	 call	 syncsearch
  000b2	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]

; 1375 :     strm->avail_in -= len;
; 1376 :     strm->next_in += len;
; 1377 :     strm->total_in += len;

  000b7	01 46 0c	 add	 DWORD PTR [rsi+12], eax
  000ba	29 46 08	 sub	 DWORD PTR [rsi+8], eax
  000bd	44 8b 4e 0c	 mov	 r9d, DWORD PTR [rsi+12]
  000c1	8b c8		 mov	 ecx, eax
  000c3	48 01 0e	 add	 QWORD PTR [rsi], rcx

; 1378 : 
; 1379 :     /* return no joy or set up to restart inflate() on a new block */
; 1380 :     if (state->have != 4) return Z_DATA_ERROR;

  000c6	83 7f 7c 04	 cmp	 DWORD PTR [rdi+124], 4
  000ca	74 10		 je	 SHORT $LN1@inflateSyn
  000cc	b8 fd ff ff ff	 mov	 eax, -3

; 1386 : }

  000d1	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000d6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000da	5f		 pop	 rdi
  000db	c3		 ret	 0
$LN1@inflateSyn:

; 1381 :     in = strm->total_in;  out = strm->total_out;

  000dc	44 8b 46 1c	 mov	 r8d, DWORD PTR [rsi+28]

; 1382 :     inflateReset(strm);

  000e0	48 8b ce	 mov	 rcx, rsi
  000e3	e8 00 00 00 00	 call	 inflateReset

; 1383 :     strm->total_in = in;  strm->total_out = out;

  000e8	44 89 4e 0c	 mov	 DWORD PTR [rsi+12], r9d
  000ec	44 89 46 1c	 mov	 DWORD PTR [rsi+28], r8d

; 1384 :     state->mode = TYPE;

  000f0	c7 07 0b 00 00
	00		 mov	 DWORD PTR [rdi], 11

; 1385 :     return Z_OK;

  000f6	33 c0		 xor	 eax, eax

; 1386 : }

  000f8	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000fd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00101	5f		 pop	 rdi
  00102	c3		 ret	 0
$LN6@inflateSyn:

; 1348 :     unsigned len;               /* number of bytes to look at or looked at */
; 1349 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1350 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1351 :     struct inflate_state FAR *state;
; 1352 : 
; 1353 :     /* check parameters */
; 1354 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00103	b8 fe ff ff ff	 mov	 eax, -2

; 1386 : }

  00108	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0010d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00111	5f		 pop	 rdi
  00112	c3		 ret	 0
inflateSync ENDP
_TEXT	ENDS
PUBLIC	inflateSyncPoint
; Function compile flags: /Ogtpy
;	COMDAT inflateSyncPoint
_TEXT	SEGMENT
strm$ = 8
inflateSyncPoint PROC					; COMDAT

; 1399 :     struct inflate_state FAR *state;
; 1400 : 
; 1401 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 1d		 je	 SHORT $LN1@inflateSyn@2
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 14		 je	 SHORT $LN1@inflateSyn@2

; 1402 :     state = (struct inflate_state FAR *)strm->state;
; 1403 :     return state->mode == STORED && state->bits == 0;

  0000e	83 38 0d	 cmp	 DWORD PTR [rax], 13
  00011	75 0c		 jne	 SHORT $LN5@inflateSyn@2
  00013	83 78 44 00	 cmp	 DWORD PTR [rax+68], 0
  00017	75 06		 jne	 SHORT $LN5@inflateSyn@2
  00019	b8 01 00 00 00	 mov	 eax, 1

; 1404 : }

  0001e	c3		 ret	 0
$LN5@inflateSyn@2:

; 1402 :     state = (struct inflate_state FAR *)strm->state;
; 1403 :     return state->mode == STORED && state->bits == 0;

  0001f	33 c0		 xor	 eax, eax

; 1404 : }

  00021	c3		 ret	 0
$LN1@inflateSyn@2:

; 1399 :     struct inflate_state FAR *state;
; 1400 : 
; 1401 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00022	b8 fe ff ff ff	 mov	 eax, -2

; 1404 : }

  00027	c3		 ret	 0
inflateSyncPoint ENDP
_TEXT	ENDS
PUBLIC	inflateCopy
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCopy DD imagerel $LN13
	DD	imagerel $LN13+74
	DD	imagerel $unwind$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateCopy DD imagerel $LN13+74
	DD	imagerel $LN13+114
	DD	imagerel $chain$1$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateCopy DD imagerel $LN13+114
	DD	imagerel $LN13+171
	DD	imagerel $chain$2$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateCopy DD imagerel $LN13+171
	DD	imagerel $LN13+190
	DD	imagerel $chain$3$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflateCopy DD imagerel $LN13+190
	DD	imagerel $LN13+384
	DD	imagerel $chain$5$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$inflateCopy DD imagerel $LN13+384
	DD	imagerel $LN13+398
	DD	imagerel $chain$6$inflateCopy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$inflateCopy DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+74
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflateCopy DD 060021H
	DD	0ad400H
	DD	096400H
	DD	085400H
	DD	imagerel $LN13
	DD	imagerel $LN13+74
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateCopy DD 021H
	DD	imagerel $LN13+74
	DD	imagerel $LN13+114
	DD	imagerel $chain$1$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateCopy DD 020521H
	DD	085405H
	DD	imagerel $LN13+74
	DD	imagerel $LN13+114
	DD	imagerel $chain$1$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateCopy DD 040a21H
	DD	0ad40aH
	DD	096405H
	DD	imagerel $LN13
	DD	imagerel $LN13+74
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCopy DD 040901H
	DD	0c0053209H
	DD	030027003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT inflateCopy
_TEXT	SEGMENT
dest$ = 64
source$ = 72
inflateCopy PROC					; COMDAT

; 1409 : {

$LN13:
  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00009	48 8b da	 mov	 rbx, rdx
  0000c	4c 8b e1	 mov	 r12, rcx

; 1410 :     struct inflate_state FAR *state;
; 1411 :     struct inflate_state FAR *copy;
; 1412 :     unsigned char FAR *window;
; 1413 :     unsigned wsize;
; 1414 : 
; 1415 :     /* check input */
; 1416 :     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
; 1417 :         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	0f 84 68 01 00
	00		 je	 $LN6@inflateCop
  00018	48 85 d2	 test	 rdx, rdx
  0001b	0f 84 5f 01 00
	00		 je	 $LN6@inflateCop
  00021	48 8b 7a 28	 mov	 rdi, QWORD PTR [rdx+40]
  00025	48 85 ff	 test	 rdi, rdi
  00028	0f 84 52 01 00
	00		 je	 $LN6@inflateCop
  0002e	48 8b 42 30	 mov	 rax, QWORD PTR [rdx+48]
  00032	48 85 c0	 test	 rax, rax
  00035	0f 84 45 01 00
	00		 je	 $LN6@inflateCop
  0003b	48 83 7a 38 00	 cmp	 QWORD PTR [rdx+56], 0
  00040	0f 84 3a 01 00
	00		 je	 $LN6@inflateCop

; 1419 :     state = (struct inflate_state FAR *)source->state;
; 1420 : 
; 1421 :     /* allocate space */
; 1422 :     copy = (struct inflate_state FAR *)
; 1423 :            ZALLOC(source, 1, sizeof(struct inflate_state));

  00046	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0004a	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  0004f	4c 89 6c 24 50	 mov	 QWORD PTR [rsp+80], r13
  00054	41 bd 01 00 00
	00		 mov	 r13d, 1
  0005a	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  00060	41 8b d5	 mov	 edx, r13d
  00063	ff d0		 call	 rax
  00065	48 8b f0	 mov	 rsi, rax

; 1424 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00068	48 85 c0	 test	 rax, rax
  0006b	75 05		 jne	 SHORT $LN5@inflateCop
  0006d	8d 46 fc	 lea	 eax, QWORD PTR [rsi-4]
  00070	eb 39		 jmp	 SHORT $LN11@inflateCop
$LN5@inflateCop:
  00072	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp

; 1425 :     window = Z_NULL;

  00077	33 ed		 xor	 ebp, ebp

; 1426 :     if (state->window != Z_NULL) {

  00079	48 39 6f 38	 cmp	 QWORD PTR [rdi+56], rbp
  0007d	74 3f		 je	 SHORT $LN3@inflateCop

; 1427 :         window = (unsigned char FAR *)
; 1428 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));

  0007f	8b 4f 28	 mov	 ecx, DWORD PTR [rdi+40]
  00082	41 8b d5	 mov	 edx, r13d
  00085	45 8b c5	 mov	 r8d, r13d
  00088	d3 e2		 shl	 edx, cl
  0008a	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0008e	ff 53 30	 call	 QWORD PTR [rbx+48]
  00091	48 8b e8	 mov	 rbp, rax

; 1429 :         if (window == Z_NULL) {

  00094	48 85 c0	 test	 rax, rax
  00097	75 25		 jne	 SHORT $LN3@inflateCop

; 1430 :             ZFREE(source, copy);

  00099	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0009d	48 8b d6	 mov	 rdx, rsi
  000a0	ff 53 38	 call	 QWORD PTR [rbx+56]

; 1431 :             return Z_MEM_ERROR;

  000a3	8d 45 fc	 lea	 eax, QWORD PTR [rbp-4]
$LN12@inflateCop:
  000a6	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
$LN11@inflateCop:
  000ab	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b0	4c 8b 6c 24 50	 mov	 r13, QWORD PTR [rsp+80]

; 1451 : }

  000b5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b9	41 5c		 pop	 r12
  000bb	5f		 pop	 rdi
  000bc	5b		 pop	 rbx
  000bd	c3		 ret	 0
$LN3@inflateCop:

; 1432 :         }
; 1433 :     }
; 1434 : 
; 1435 :     /* copy state */
; 1436 :     zmemcpy(dest, source, sizeof(z_stream));

  000be	49 8b cc	 mov	 rcx, r12
  000c1	48 8b d3	 mov	 rdx, rbx
  000c4	41 b8 58 00 00
	00		 mov	 r8d, 88			; 00000058H
  000ca	e8 00 00 00 00	 call	 memcpy

; 1437 :     zmemcpy(copy, state, sizeof(struct inflate_state));

  000cf	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  000d5	48 8b d7	 mov	 rdx, rdi
  000d8	48 8b ce	 mov	 rcx, rsi
  000db	e8 00 00 00 00	 call	 memcpy

; 1438 :     if (state->lencode >= state->codes &&
; 1439 :         state->lencode <= state->codes + ENOUGH - 1) {

  000e0	4c 8b 5f 58	 mov	 r11, QWORD PTR [rdi+88]
  000e4	48 8d 87 48 05
	00 00		 lea	 rax, QWORD PTR [rdi+1352]
  000eb	4c 3b d8	 cmp	 r11, rax
  000ee	72 43		 jb	 SHORT $LN2@inflateCop
  000f0	48 8d 87 d4 1b
	00 00		 lea	 rax, QWORD PTR [rdi+7124]
  000f7	4c 3b d8	 cmp	 r11, rax
  000fa	77 37		 ja	 SHORT $LN2@inflateCop

; 1440 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  000fc	4c 2b df	 sub	 r11, rdi
  000ff	49 81 eb 48 05
	00 00		 sub	 r11, 1352		; 00000548H
  00106	49 c1 fb 02	 sar	 r11, 2
  0010a	4a 8d 84 9e 48
	05 00 00	 lea	 rax, QWORD PTR [rsi+r11*4+1352]
  00112	48 89 46 58	 mov	 QWORD PTR [rsi+88], rax

; 1441 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  00116	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  0011a	48 2b c7	 sub	 rax, rdi
  0011d	48 2d 48 05 00
	00		 sub	 rax, 1352		; 00000548H
  00123	48 c1 f8 02	 sar	 rax, 2
  00127	48 8d 84 86 48
	05 00 00	 lea	 rax, QWORD PTR [rsi+rax*4+1352]
  0012f	48 89 46 60	 mov	 QWORD PTR [rsi+96], rax
$LN2@inflateCop:

; 1442 :     }
; 1443 :     copy->next = copy->codes + (state->next - state->codes);

  00133	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  0013a	48 2b c7	 sub	 rax, rdi
  0013d	48 2d 48 05 00
	00		 sub	 rax, 1352		; 00000548H
  00143	48 c1 f8 02	 sar	 rax, 2
  00147	48 8d 84 86 48
	05 00 00	 lea	 rax, QWORD PTR [rsi+rax*4+1352]
  0014f	48 89 86 80 00
	00 00		 mov	 QWORD PTR [rsi+128], rax

; 1444 :     if (window != Z_NULL) {

  00156	48 85 ed	 test	 rbp, rbp
  00159	74 15		 je	 SHORT $LN1@inflateCop

; 1445 :         wsize = 1U << state->wbits;

  0015b	8b 4f 28	 mov	 ecx, DWORD PTR [rdi+40]

; 1446 :         zmemcpy(window, state->window, wsize);

  0015e	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  00162	41 d3 e5	 shl	 r13d, cl
  00165	48 8b cd	 mov	 rcx, rbp
  00168	45 8b c5	 mov	 r8d, r13d
  0016b	e8 00 00 00 00	 call	 memcpy
$LN1@inflateCop:

; 1447 :     }
; 1448 :     copy->window = window;

  00170	48 89 6e 38	 mov	 QWORD PTR [rsi+56], rbp

; 1449 :     dest->state = (struct internal_state FAR *)copy;
; 1450 :     return Z_OK;

  00174	33 c0		 xor	 eax, eax
  00176	49 89 74 24 28	 mov	 QWORD PTR [r12+40], rsi
  0017b	e9 26 ff ff ff	 jmp	 $LN12@inflateCop
$LN6@inflateCop:

; 1418 :         return Z_STREAM_ERROR;

  00180	b8 fe ff ff ff	 mov	 eax, -2

; 1451 : }

  00185	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00189	41 5c		 pop	 r12
  0018b	5f		 pop	 rdi
  0018c	5b		 pop	 rbx
  0018d	c3		 ret	 0
inflateCopy ENDP
_TEXT	ENDS
PUBLIC	inflateUndermine
; Function compile flags: /Ogtpy
;	COMDAT inflateUndermine
_TEXT	SEGMENT
strm$ = 8
subvert$ = 16
inflateUndermine PROC					; COMDAT

; 1457 :     struct inflate_state FAR *state;
; 1458 : 
; 1459 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 19		 je	 SHORT $LN1@inflateUnd
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 10		 je	 SHORT $LN1@inflateUnd

; 1460 :     state = (struct inflate_state FAR *)strm->state;
; 1461 :     state->sane = !subvert;
; 1462 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1463 :     return Z_OK;
; 1464 : #else
; 1465 :     state->sane = 1;

  0000e	c7 80 d8 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+7128], 1

; 1466 :     return Z_DATA_ERROR;

  00018	b8 fd ff ff ff	 mov	 eax, -3

; 1467 : #endif
; 1468 : }

  0001d	c3		 ret	 0
$LN1@inflateUnd:

; 1457 :     struct inflate_state FAR *state;
; 1458 : 
; 1459 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0001e	b8 fe ff ff ff	 mov	 eax, -2

; 1467 : #endif
; 1468 : }

  00023	c3		 ret	 0
inflateUndermine ENDP
_TEXT	ENDS
PUBLIC	inflateMark
; Function compile flags: /Ogtpy
;	COMDAT inflateMark
_TEXT	SEGMENT
strm$ = 8
inflateMark PROC					; COMDAT

; 1473 :     struct inflate_state FAR *state;
; 1474 : 
; 1475 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 47		 je	 SHORT $LN1@inflateMar
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 3e		 je	 SHORT $LN1@inflateMar

; 1476 :     state = (struct inflate_state FAR *)strm->state;
; 1477 :     return ((long)(state->back) << 16) +
; 1478 :         (state->mode == COPY ? state->length :
; 1479 :             (state->mode == MATCH ? state->was - state->length : 0));

  0000e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00010	83 f9 0f	 cmp	 ecx, 15
  00013	75 0f		 jne	 SHORT $LN7@inflateMar
  00015	8b 48 48	 mov	 ecx, DWORD PTR [rax+72]
  00018	8b 80 dc 1b 00
	00		 mov	 eax, DWORD PTR [rax+7132]
  0001e	c1 e0 10	 shl	 eax, 16
  00021	03 c1		 add	 eax, ecx

; 1480 : }

  00023	c3		 ret	 0
$LN7@inflateMar:

; 1476 :     state = (struct inflate_state FAR *)strm->state;
; 1477 :     return ((long)(state->back) << 16) +
; 1478 :         (state->mode == COPY ? state->length :
; 1479 :             (state->mode == MATCH ? state->was - state->length : 0));

  00024	83 f9 18	 cmp	 ecx, 24
  00027	75 15		 jne	 SHORT $LN5@inflateMar
  00029	8b 88 e0 1b 00
	00		 mov	 ecx, DWORD PTR [rax+7136]
  0002f	2b 48 48	 sub	 ecx, DWORD PTR [rax+72]
  00032	8b 80 dc 1b 00
	00		 mov	 eax, DWORD PTR [rax+7132]
  00038	c1 e0 10	 shl	 eax, 16
  0003b	03 c1		 add	 eax, ecx

; 1480 : }

  0003d	c3		 ret	 0
$LN5@inflateMar:

; 1476 :     state = (struct inflate_state FAR *)strm->state;
; 1477 :     return ((long)(state->back) << 16) +
; 1478 :         (state->mode == COPY ? state->length :
; 1479 :             (state->mode == MATCH ? state->was - state->length : 0));

  0003e	8b 80 dc 1b 00
	00		 mov	 eax, DWORD PTR [rax+7132]
  00044	33 c9		 xor	 ecx, ecx
  00046	c1 e0 10	 shl	 eax, 16
  00049	03 c1		 add	 eax, ecx

; 1480 : }

  0004b	c3		 ret	 0
$LN1@inflateMar:

; 1473 :     struct inflate_state FAR *state;
; 1474 : 
; 1475 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  0004c	b8 00 00 ff ff	 mov	 eax, -65536		; ffffffffffff0000H

; 1480 : }

  00051	c3		 ret	 0
inflateMark ENDP
_TEXT	ENDS
END
