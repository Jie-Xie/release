; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@LGHHEPFB@no?5mem?5for?5next?5token?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@IGILJKKH@with?5Barry?5as?5BDFL?0?5use?5?8?$DM?$DO?8?5ins@ ; `string'
PUBLIC	??_C@_02GMAKCBGE@?$DM?$DO?$AA@			; `string'
PUBLIC	??_C@_02FDNJECIE@?$CB?$DN?$AA@			; `string'
PUBLIC	??_C@_0BH@PCOGNDBL@no?5mem?5for?5new?5parser?6?$AA@ ; `string'
EXTRN	__imp_free:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	PyNode_New:PROC
EXTRN	PyParser_Delete:PROC
EXTRN	PyNode_Free:PROC
EXTRN	PyObject_Free:PROC
EXTRN	PyParser_AddToken:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	PyObject_Malloc:PROC
EXTRN	PyTokenizer_Get:PROC
EXTRN	PyTokenizer_Free:PROC
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
EXTRN	PyParser_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\parser\parsetok.c
pdata	SEGMENT
$pdata$parsetok DD imagerel parsetok
	DD	imagerel parsetok+132
	DD	imagerel $unwind$parsetok
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$parsetok DD imagerel parsetok+132
	DD	imagerel parsetok+728
	DD	imagerel $chain$2$parsetok
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$parsetok DD imagerel parsetok+728
	DD	imagerel parsetok+1046
	DD	imagerel $chain$3$parsetok
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$parsetok DD 021H
	DD	imagerel parsetok
	DD	imagerel parsetok+132
	DD	imagerel $unwind$parsetok
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$parsetok DD 020821H
	DD	012c408H
	DD	imagerel parsetok
	DD	imagerel parsetok+132
	DD	imagerel $unwind$parsetok
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parsetok DD 0a7901H
	DD	0117479H
	DD	0105471H
	DD	0f009920dH
	DD	0d005e007H
	DD	030026003H
xdata	ENDS
;	COMDAT ??_C@_0BH@LGHHEPFB@no?5mem?5for?5next?5token?6?$AA@
CONST	SEGMENT
??_C@_0BH@LGHHEPFB@no?5mem?5for?5next?5token?6?$AA@ DB 'no mem for next t'
	DB	'oken', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IGILJKKH@with?5Barry?5as?5BDFL?0?5use?5?8?$DM?$DO?8?5ins@
CONST	SEGMENT
??_C@_0CN@IGILJKKH@with?5Barry?5as?5BDFL?0?5use?5?8?$DM?$DO?8?5ins@ DB 'w'
	DB	'ith Barry as BDFL, use ''<>'' instead of ''!=''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMAKCBGE@?$DM?$DO?$AA@
CONST	SEGMENT
??_C@_02GMAKCBGE@?$DM?$DO?$AA@ DB '<>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02FDNJECIE@?$CB?$DN?$AA@
CONST	SEGMENT
??_C@_02FDNJECIE@?$CB?$DN?$AA@ DB '!=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PCOGNDBL@no?5mem?5for?5new?5parser?6?$AA@
CONST	SEGMENT
??_C@_0BH@PCOGNDBL@no?5mem?5for?5new?5parser?6?$AA@ DB 'no mem for new pa'
	DB	'rser', 0aH, 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT parsetok
_TEXT	SEGMENT
a$20902 = 48
ps$1$ = 56
b$20903 = 64
tok$ = 128
g$ = 136
start$ = 144
err_ret$ = 152
flags$ = 160
parsetok PROC						; COMDAT

; 135  : {

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	41 55		 push	 r13
  00005	41 56		 push	 r14
  00007	41 57		 push	 r15
  00009	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000d	48 8b c2	 mov	 rax, rdx
  00010	48 8b d9	 mov	 rbx, rcx

; 136  :     parser_state *ps;
; 137  :     node *n;
; 138  :     int started = 0;
; 139  : 
; 140  :     if ((ps = PyParser_New(g, start)) == NULL) {

  00013	41 8b d0	 mov	 edx, r8d
  00016	48 8b c8	 mov	 rcx, rax
  00019	4d 8b f1	 mov	 r14, r9
  0001c	45 8b f8	 mov	 r15d, r8d
  0001f	45 33 ed	 xor	 r13d, r13d
  00022	e8 00 00 00 00	 call	 PyParser_New
  00027	48 8b f0	 mov	 rsi, rax
  0002a	48 89 44 24 38	 mov	 QWORD PTR ps$1$[rsp], rax
  0002f	48 85 c0	 test	 rax, rax
  00032	75 35		 jne	 SHORT $LN41@parsetok

; 141  :         fprintf(stderr, "no mem for new parser\n");

  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@PCOGNDBL@no?5mem?5for?5new?5parser?6?$AA@
  00041	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 142  :         err_ret->error = E_NOMEM;
; 143  :         PyTokenizer_Free(tok);

  0004b	48 8b cb	 mov	 rcx, rbx
  0004e	41 c7 06 0f 00
	00 00		 mov	 DWORD PTR [r14], 15
  00055	e8 00 00 00 00	 call	 PyTokenizer_Free

; 144  :         return NULL;

  0005a	33 c0		 xor	 eax, eax

; 308  : }

  0005c	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00060	41 5f		 pop	 r15
  00062	41 5e		 pop	 r14
  00064	41 5d		 pop	 r13
  00066	5e		 pop	 rsi
  00067	5b		 pop	 rbx
  00068	c3		 ret	 0
$LN41@parsetok:
  00069	48 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbp
  00071	48 89 bc 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rdi

; 145  :     }
; 146  : #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
; 147  :     if (*flags & PyPARSE_BARRY_AS_BDFL)

  00079	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR flags$[rsp]
  00081	f6 07 20	 test	 BYTE PTR [rdi], 32	; 00000020H
  00084	4c 89 a4 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], r12
  0008c	74 0a		 je	 SHORT $LN48@parsetok

; 148  :         ps->p_flags |= CO_FUTURE_BARRY_AS_BDFL;

  0008e	81 88 b8 8c 00
	00 00 00 04 00	 or	 DWORD PTR [rax+36024], 262144 ; 00040000H
$LN48@parsetok:

; 149  : #endif
; 150  : 
; 151  :     for (;;) {
; 152  :         char *a, *b;
; 153  :         int type;
; 154  :         size_t len;
; 155  :         char *str;
; 156  :         int col_offset;
; 157  : 
; 158  :         type = PyTokenizer_Get(tok, &a, &b);

  00098	4c 8d 44 24 40	 lea	 r8, QWORD PTR b$20903[rsp]
  0009d	48 8d 54 24 30	 lea	 rdx, QWORD PTR a$20902[rsp]
  000a2	48 8b cb	 mov	 rcx, rbx
  000a5	e8 00 00 00 00	 call	 PyTokenizer_Get
  000aa	44 8b e0	 mov	 r12d, eax

; 159  :         if (type == ERRORTOKEN) {

  000ad	83 f8 35	 cmp	 eax, 53			; 00000035H
  000b0	0f 84 90 01 00
	00		 je	 $LN54@parsetok
$LL39@parsetok:

; 161  :             break;
; 162  :         }
; 163  :         if (type == ENDMARKER && started) {

  000b6	45 85 e4	 test	 r12d, r12d
  000b9	75 28		 jne	 SHORT $LN36@parsetok
  000bb	45 85 ed	 test	 r13d, r13d
  000be	74 23		 je	 SHORT $LN36@parsetok

; 164  :             type = NEWLINE; /* Add an extra newline */
; 165  :             started = 0;
; 166  :             /* Add the right number of dedent tokens,
; 167  :                except if a certain flag is given --
; 168  :                codeop.py uses this. */
; 169  :             if (tok->indent &&
; 170  :                 !(*flags & PyPARSE_DONT_IMPLY_DEDENT))

  000c0	8b 43 3c	 mov	 eax, DWORD PTR [rbx+60]
  000c3	45 33 ed	 xor	 r13d, r13d
  000c6	41 bc 04 00 00
	00		 mov	 r12d, 4
  000cc	85 c0		 test	 eax, eax
  000ce	74 19		 je	 SHORT $LN34@parsetok
  000d0	f6 07 02	 test	 BYTE PTR [rdi], 2
  000d3	75 14		 jne	 SHORT $LN34@parsetok

; 171  :             {
; 172  :                 tok->pendin = -tok->indent;

  000d5	f7 d8		 neg	 eax

; 173  :                 tok->indent = 0;

  000d7	44 89 6b 3c	 mov	 DWORD PTR [rbx+60], r13d
  000db	89 83 d4 01 00
	00		 mov	 DWORD PTR [rbx+468], eax

; 174  :             }
; 175  :         }
; 176  :         else

  000e1	eb 06		 jmp	 SHORT $LN34@parsetok
$LN36@parsetok:

; 177  :             started = 1;

  000e3	41 bd 01 00 00
	00		 mov	 r13d, 1
$LN34@parsetok:

; 178  :         len = b - a; /* XXX this may compute NULL - NULL */

  000e9	48 8b 7c 24 40	 mov	 rdi, QWORD PTR b$20903[rsp]
  000ee	48 2b 7c 24 30	 sub	 rdi, QWORD PTR a$20902[rsp]

; 179  :         str = (char *) PyObject_MALLOC(len + 1);

  000f3	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
  000f7	e8 00 00 00 00	 call	 PyObject_Malloc
  000fc	48 8b e8	 mov	 rbp, rax

; 180  :         if (str == NULL) {

  000ff	48 85 c0	 test	 rax, rax
  00102	0f 84 1e 01 00
	00		 je	 $LN55@parsetok

; 184  :         }
; 185  :         if (len > 0)

  00108	48 85 ff	 test	 rdi, rdi
  0010b	74 11		 je	 SHORT $LN32@parsetok

; 186  :             strncpy(str, a, len);

  0010d	48 8b 54 24 30	 mov	 rdx, QWORD PTR a$20902[rsp]
  00112	4c 8b c7	 mov	 r8, rdi
  00115	48 8b c8	 mov	 rcx, rax
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
$LN32@parsetok:

; 187  :         str[len] = '\0';

  0011e	c6 04 2f 00	 mov	 BYTE PTR [rdi+rbp], 0

; 188  : 
; 189  : #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
; 190  :         if (type == NOTEQUAL) {

  00122	41 83 fc 1c	 cmp	 r12d, 28
  00126	75 3f		 jne	 SHORT $LN28@parsetok

; 191  :             if (!(ps->p_flags & CO_FUTURE_BARRY_AS_BDFL) &&
; 192  :                             strcmp(str, "!=")) {

  00128	8b 86 b8 8c 00
	00		 mov	 eax, DWORD PTR [rsi+36024]
  0012e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00133	75 17		 jne	 SHORT $LN30@parsetok
  00135	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_02FDNJECIE@?$CB?$DN?$AA@
  0013c	48 8b f5	 mov	 rsi, rbp
  0013f	b9 03 00 00 00	 mov	 ecx, 3
  00144	f3 a6		 repe cmpsb
  00146	0f 85 8a 00 00
	00		 jne	 $LN56@parsetok
$LN30@parsetok:

; 196  :             }
; 197  :             else if ((ps->p_flags & CO_FUTURE_BARRY_AS_BDFL) &&
; 198  :                             strcmp(str, "<>")) {

  0014c	85 c0		 test	 eax, eax
  0014e	74 17		 je	 SHORT $LN28@parsetok
  00150	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_02GMAKCBGE@?$DM?$DO?$AA@
  00157	48 8b f5	 mov	 rsi, rbp
  0015a	b9 03 00 00 00	 mov	 ecx, 3
  0015f	f3 a6		 repe cmpsb
  00161	0f 85 88 00 00
	00		 jne	 $LN57@parsetok
$LN28@parsetok:

; 204  :             }
; 205  :         }
; 206  : #endif
; 207  :         if (a >= tok->line_start)

  00167	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$20902[rsp]
  0016c	48 3b 8b b0 03
	00 00		 cmp	 rcx, QWORD PTR [rbx+944]
  00173	72 08		 jb	 SHORT $LN27@parsetok

; 208  :             col_offset = a - tok->line_start;

  00175	2b 8b b0 03 00
	00		 sub	 ecx, DWORD PTR [rbx+944]

; 209  :         else

  0017b	eb 03		 jmp	 SHORT $LN26@parsetok
$LN27@parsetok:

; 210  :             col_offset = -1;

  0017d	83 c9 ff	 or	 ecx, -1
$LN26@parsetok:

; 211  : 
; 212  :         if ((err_ret->error =
; 213  :              PyParser_AddToken(ps, (int)type, str,
; 214  :                                tok->lineno, col_offset,
; 215  :                                &(err_ret->expected))) != E_OK) {

  00180	48 8b 74 24 38	 mov	 rsi, QWORD PTR ps$1$[rsp]
  00185	44 8b 8b e8 01
	00 00		 mov	 r9d, DWORD PTR [rbx+488]
  0018c	49 8d 46 24	 lea	 rax, QWORD PTR [r14+36]
  00190	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00195	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00199	4c 8b c5	 mov	 r8, rbp
  0019c	48 8b ce	 mov	 rcx, rsi
  0019f	41 8b d4	 mov	 edx, r12d
  001a2	e8 00 00 00 00	 call	 PyParser_AddToken
  001a7	41 89 06	 mov	 DWORD PTR [r14], eax
  001aa	83 f8 0a	 cmp	 eax, 10
  001ad	75 64		 jne	 SHORT $LN58@parsetok

; 149  : #endif
; 150  : 
; 151  :     for (;;) {
; 152  :         char *a, *b;
; 153  :         int type;
; 154  :         size_t len;
; 155  :         char *str;
; 156  :         int col_offset;
; 157  : 
; 158  :         type = PyTokenizer_Get(tok, &a, &b);

  001af	4c 8d 44 24 40	 lea	 r8, QWORD PTR b$20903[rsp]
  001b4	48 8d 54 24 30	 lea	 rdx, QWORD PTR a$20902[rsp]
  001b9	48 8b cb	 mov	 rcx, rbx
  001bc	e8 00 00 00 00	 call	 PyTokenizer_Get
  001c1	44 8b e0	 mov	 r12d, eax

; 159  :         if (type == ERRORTOKEN) {

  001c4	83 f8 35	 cmp	 eax, 53			; 00000035H
  001c7	74 7d		 je	 SHORT $LN54@parsetok
  001c9	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR flags$[rsp]
  001d1	e9 e0 fe ff ff	 jmp	 $LL39@parsetok
$LN56@parsetok:

; 193  :                 PyObject_FREE(str);

  001d6	48 8b cd	 mov	 rcx, rbp
  001d9	e8 00 00 00 00	 call	 PyObject_Free

; 194  :                 err_ret->error = E_SYNTAX;
; 195  :                 break;

  001de	48 8b 74 24 38	 mov	 rsi, QWORD PTR ps$1$[rsp]
  001e3	41 c7 06 0e 00
	00 00		 mov	 DWORD PTR [r14], 14
  001ea	e9 c2 00 00 00	 jmp	 $LN23@parsetok
$LN57@parsetok:

; 199  :                 PyObject_FREE(str);

  001ef	48 8b cd	 mov	 rcx, rbp
  001f2	e8 00 00 00 00	 call	 PyObject_Free

; 200  :                 err_ret->text = "with Barry as BDFL, use '<>' "
; 201  :                                 "instead of '!='";
; 202  :                 err_ret->error = E_SYNTAX;
; 203  :                 break;

  001f7	48 8b 74 24 38	 mov	 rsi, QWORD PTR ps$1$[rsp]
  001fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@IGILJKKH@with?5Barry?5as?5BDFL?0?5use?5?8?$DM?$DO?8?5ins@
  00203	49 89 56 18	 mov	 QWORD PTR [r14+24], rdx
  00207	41 c7 06 0e 00
	00 00		 mov	 DWORD PTR [r14], 14
  0020e	e9 9e 00 00 00	 jmp	 $LN23@parsetok
$LN58@parsetok:

; 216  :             if (err_ret->error != E_DONE) {

  00213	83 f8 10	 cmp	 eax, 16
  00216	74 3a		 je	 SHORT $LN62@parsetok

; 217  :                 PyObject_FREE(str);

  00218	48 8b cd	 mov	 rcx, rbp
  0021b	e8 00 00 00 00	 call	 PyObject_Free

; 218  :                 err_ret->token = type;

  00220	45 89 66 20	 mov	 DWORD PTR [r14+32], r12d
  00224	eb 26		 jmp	 SHORT $LN24@parsetok
$LN55@parsetok:

; 181  :             fprintf(stderr, "no mem for next token\n");

  00226	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0022c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LGHHEPFB@no?5mem?5for?5next?5token?6?$AA@
  00233	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00237	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 182  :             err_ret->error = E_NOMEM;

  0023d	41 c7 06 0f 00
	00 00		 mov	 DWORD PTR [r14], 15

; 183  :             break;

  00244	eb 6b		 jmp	 SHORT $LN23@parsetok
$LN54@parsetok:

; 160  :             err_ret->error = tok->done;

  00246	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  00249	41 89 06	 mov	 DWORD PTR [r14], eax
$LN24@parsetok:

; 219  :             }
; 220  :             break;
; 221  :         }
; 222  :     }
; 223  : 
; 224  :     if (err_ret->error == E_DONE) {

  0024c	41 83 3e 10	 cmp	 DWORD PTR [r14], 16
  00250	75 5f		 jne	 SHORT $LN23@parsetok
$LN62@parsetok:

; 225  :         n = ps->p_tree;

  00252	48 8b ae b0 8c
	00 00		 mov	 rbp, QWORD PTR [rsi+36016]

; 226  :         ps->p_tree = NULL;

  00259	48 c7 86 b0 8c
	00 00 00 00 00
	00		 mov	 QWORD PTR [rsi+36016], 0

; 227  : 
; 228  : #ifndef PGEN
; 229  :         /* Check that the source for a single input statement really
; 230  :            is a single statement by looking at what is left in the
; 231  :            buffer after parsing.  Trailing whitespace and comments
; 232  :            are OK.  */
; 233  :         if (start == single_input) {

  00264	41 81 ff 00 01
	00 00		 cmp	 r15d, 256		; 00000100H
  0026b	75 46		 jne	 SHORT $LN12@parsetok

; 234  :             char *cur = tok->cur;

  0026d	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
$LN65@parsetok:

; 235  :             char c = *tok->cur;

  00271	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
$LL19@parsetok:

; 236  : 
; 237  :             for (;;) {
; 238  :                 while (c == ' ' || c == '\t' || c == '\n' || c == '\014')

  00274	3c 20		 cmp	 al, 32			; 00000020H
  00276	74 0c		 je	 SHORT $LN17@parsetok
  00278	3c 09		 cmp	 al, 9
  0027a	74 08		 je	 SHORT $LN17@parsetok
  0027c	3c 0a		 cmp	 al, 10
  0027e	74 04		 je	 SHORT $LN17@parsetok
  00280	3c 0c		 cmp	 al, 12
  00282	75 05		 jne	 SHORT $LN18@parsetok
$LN17@parsetok:

; 239  :                     c = *++cur;

  00284	48 ff c1	 inc	 rcx
  00287	eb e8		 jmp	 SHORT $LN65@parsetok
$LN18@parsetok:

; 240  : 
; 241  :                 if (!c)

  00289	84 c0		 test	 al, al
  0028b	74 26		 je	 SHORT $LN12@parsetok

; 242  :                     break;
; 243  : 
; 244  :                 if (c != '#') {

  0028d	3c 23		 cmp	 al, 35			; 00000023H
  0028f	75 11		 jne	 SHORT $LN60@parsetok
$LL14@parsetok:

; 247  :                     n = NULL;
; 248  :                     break;
; 249  :                 }
; 250  : 
; 251  :                 /* Suck up comment. */
; 252  :                 while (c && c != '\n')

  00291	3c 0a		 cmp	 al, 10
  00293	74 df		 je	 SHORT $LL19@parsetok

; 253  :                     c = *++cur;

  00295	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00299	48 ff c1	 inc	 rcx
  0029c	84 c0		 test	 al, al
  0029e	75 f1		 jne	 SHORT $LL14@parsetok

; 191  :             if (!(ps->p_flags & CO_FUTURE_BARRY_AS_BDFL) &&
; 192  :                             strcmp(str, "!=")) {

  002a0	eb d2		 jmp	 SHORT $LL19@parsetok
$LN60@parsetok:

; 245  :                     err_ret->error = E_BADSINGLE;
; 246  :                     PyNode_Free(n);

  002a2	48 8b cd	 mov	 rcx, rbp
  002a5	41 c7 06 1b 00
	00 00		 mov	 DWORD PTR [r14], 27
  002ac	e8 00 00 00 00	 call	 PyNode_Free
$LN23@parsetok:

; 254  :             }
; 255  :         }
; 256  : #endif
; 257  :     }
; 258  :     else
; 259  :         n = NULL;

  002b1	33 ed		 xor	 ebp, ebp
$LN12@parsetok:

; 260  : 
; 261  : #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
; 262  :     *flags = ps->p_flags;

  002b3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR flags$[rsp]
  002bb	8b 86 b8 8c 00
	00		 mov	 eax, DWORD PTR [rsi+36024]
  002c1	89 01		 mov	 DWORD PTR [rcx], eax

; 263  : #endif
; 264  :     PyParser_Delete(ps);

  002c3	48 8b ce	 mov	 rcx, rsi
  002c6	e8 00 00 00 00	 call	 PyParser_Delete
  002cb	4c 8b a4 24 90
	00 00 00	 mov	 r12, QWORD PTR [rsp+144]

; 265  : 
; 266  :     if (n == NULL) {

  002d3	48 85 ed	 test	 rbp, rbp
  002d6	75 68		 jne	 SHORT $LN11@parsetok

; 267  :         if (tok->done == E_EOF)

  002d8	83 7b 28 0b	 cmp	 DWORD PTR [rbx+40], 11
  002dc	75 07		 jne	 SHORT $LN10@parsetok

; 268  :             err_ret->error = E_EOF;

  002de	41 c7 06 0b 00
	00 00		 mov	 DWORD PTR [r14], 11
$LN10@parsetok:

; 269  :         err_ret->lineno = tok->lineno;

  002e5	8b 83 e8 01 00
	00		 mov	 eax, DWORD PTR [rbx+488]
  002eb	41 89 46 10	 mov	 DWORD PTR [r14+16], eax

; 270  :         if (tok->buf != NULL) {

  002ef	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  002f3	0f 84 f5 00 00
	00		 je	 $done$20970

; 271  :             size_t len;
; 272  :             assert(tok->cur - tok->buf < INT_MAX);
; 273  :             err_ret->offset = (int)(tok->cur - tok->buf);

  002f9	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  002fc	2b 03		 sub	 eax, DWORD PTR [rbx]
  002fe	41 89 46 14	 mov	 DWORD PTR [r14+20], eax

; 274  :             len = tok->inp - tok->buf;

  00302	48 8b 7b 10	 mov	 rdi, QWORD PTR [rbx+16]
  00306	48 2b 3b	 sub	 rdi, QWORD PTR [rbx]

; 275  :             err_ret->text = (char *) PyObject_MALLOC(len + 1);

  00309	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
  0030d	e8 00 00 00 00	 call	 PyObject_Malloc
  00312	49 89 46 18	 mov	 QWORD PTR [r14+24], rax

; 276  :             if (err_ret->text != NULL) {

  00316	48 85 c0	 test	 rax, rax
  00319	0f 84 cf 00 00
	00		 je	 $done$20970

; 277  :                 if (len > 0)

  0031f	48 85 ff	 test	 rdi, rdi
  00322	74 0f		 je	 SHORT $LN7@parsetok

; 278  :                     strncpy(err_ret->text, tok->buf, len);

  00324	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00327	4c 8b c7	 mov	 r8, rdi
  0032a	48 8b c8	 mov	 rcx, rax
  0032d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
$LN7@parsetok:

; 279  :                 err_ret->text[len] = '\0';

  00333	49 8b 46 18	 mov	 rax, QWORD PTR [r14+24]
  00337	c6 04 07 00	 mov	 BYTE PTR [rdi+rax], 0

; 280  :             }
; 281  :         }

  0033b	e9 ae 00 00 00	 jmp	 $done$20970
$LN11@parsetok:

; 282  :     } else if (tok->encoding != NULL) {

  00340	48 83 bb a0 03
	00 00 00	 cmp	 QWORD PTR [rbx+928], 0
  00348	0f 84 a0 00 00
	00		 je	 $done$20970

; 283  :         /* 'nodes->n_str' uses PyObject_*, while 'tok->encoding' was
; 284  :          * allocated using PyMem_
; 285  :          */
; 286  :         node* r = PyNode_New(encoding_decl);

  0034e	b9 4f 01 00 00	 mov	 ecx, 335		; 0000014fH
  00353	e8 00 00 00 00	 call	 PyNode_New
  00358	48 8b f0	 mov	 rsi, rax

; 287  :         if (r)

  0035b	48 85 c0	 test	 rax, rax
  0035e	0f 84 74 00 00
	00		 je	 $LN2@parsetok

; 288  :             r->n_str = PyObject_MALLOC(strlen(tok->encoding)+1);

  00364	48 8b bb a0 03
	00 00		 mov	 rdi, QWORD PTR [rbx+928]
  0036b	48 83 c9 ff	 or	 rcx, -1
  0036f	33 c0		 xor	 eax, eax
  00371	f2 ae		 repne scasb
  00373	48 f7 d1	 not	 rcx
  00376	e8 00 00 00 00	 call	 PyObject_Malloc
  0037b	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax

; 289  :         if (!r || !r->n_str) {

  0037f	48 85 c0	 test	 rax, rax
  00382	74 54		 je	 SHORT $LN2@parsetok

; 294  :             goto done;
; 295  :         }
; 296  :         strcpy(r->n_str, tok->encoding);

  00384	48 8b 93 a0 03
	00 00		 mov	 rdx, QWORD PTR [rbx+928]
  0038b	0f 1f 44 00 00	 npad	 5
$LL44@parsetok:
  00390	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
  00393	48 ff c0	 inc	 rax
  00396	48 ff c2	 inc	 rdx
  00399	88 48 ff	 mov	 BYTE PTR [rax-1], cl
  0039c	84 c9		 test	 cl, cl
  0039e	75 f0		 jne	 SHORT $LL44@parsetok

; 297  :         PyMem_FREE(tok->encoding);

  003a0	e8 00 00 00 00	 call	 _Py_PXCTX
  003a5	48 8b 8b a0 03
	00 00		 mov	 rcx, QWORD PTR [rbx+928]
  003ac	85 c0		 test	 eax, eax
  003ae	74 07		 je	 SHORT $LN45@parsetok
  003b0	e8 00 00 00 00	 call	 _PxMem_Free
  003b5	eb 06		 jmp	 SHORT $LN46@parsetok
$LN45@parsetok:
  003b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN46@parsetok:

; 298  :         tok->encoding = NULL;

  003bd	48 c7 83 a0 03
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+928], 0

; 299  :         r->n_nchildren = 1;
; 300  :         r->n_child = n;

  003c8	48 89 6e 20	 mov	 QWORD PTR [rsi+32], rbp

; 301  :         n = r;

  003cc	48 8b ee	 mov	 rbp, rsi
  003cf	c7 46 18 01 00
	00 00		 mov	 DWORD PTR [rsi+24], 1
  003d6	eb 16		 jmp	 SHORT $done$20970
$LN2@parsetok:

; 290  :             err_ret->error = E_NOMEM;

  003d8	41 c7 06 0f 00
	00 00		 mov	 DWORD PTR [r14], 15

; 291  :             if (r)

  003df	48 85 f6	 test	 rsi, rsi
  003e2	74 08		 je	 SHORT $LN1@parsetok

; 292  :                 PyObject_FREE(r);

  003e4	48 8b ce	 mov	 rcx, rsi
  003e7	e8 00 00 00 00	 call	 PyObject_Free
$LN1@parsetok:

; 293  :             n = NULL;

  003ec	33 ed		 xor	 ebp, ebp
$done$20970:

; 302  :     }
; 303  : 
; 304  : done:
; 305  :     PyTokenizer_Free(tok);

  003ee	48 8b cb	 mov	 rcx, rbx
  003f1	e8 00 00 00 00	 call	 PyTokenizer_Free
  003f6	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR [rsp+136]

; 306  : 
; 307  :     return n;

  003fe	48 8b c5	 mov	 rax, rbp
  00401	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]

; 308  : }

  00409	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0040d	41 5f		 pop	 r15
  0040f	41 5e		 pop	 r14
  00411	41 5d		 pop	 r13
  00413	5e		 pop	 rsi
  00414	5b		 pop	 rbx
  00415	c3		 ret	 0
parsetok ENDP
_TEXT	ENDS
PUBLIC	??_C@_08OOGHEFMC@?$DMstring?$DO?$AA@		; `string'
EXTRN	PyUnicode_FromString:PROC
EXTRN	PyUnicode_DecodeFSDefault:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$initerr DD imagerel initerr
	DD	imagerel initerr+92
	DD	imagerel $unwind$initerr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$initerr DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_08OOGHEFMC@?$DMstring?$DO?$AA@
CONST	SEGMENT
??_C@_08OOGHEFMC@?$DMstring?$DO?$AA@ DB '<string>', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT initerr
_TEXT	SEGMENT
err_ret$ = 48
filename$ = 56
initerr	PROC						; COMDAT

; 312  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 313  :     err_ret->error = E_OK;
; 314  :     err_ret->lineno = 0;

  00006	33 c0		 xor	 eax, eax
  00008	48 8b d9	 mov	 rbx, rcx
  0000b	c7 01 0a 00 00
	00		 mov	 DWORD PTR [rcx], 10

; 315  :     err_ret->offset = 0;
; 316  :     err_ret->text = NULL;
; 317  :     err_ret->token = -1;

  00011	48 c7 41 20 ff
	ff ff ff	 mov	 QWORD PTR [rcx+32], -1
  00019	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  0001d	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 318  :     err_ret->expected = -1;
; 319  : #ifndef PGEN
; 320  :     if (filename)

  00021	48 85 d2	 test	 rdx, rdx
  00024	74 0a		 je	 SHORT $LN3@initerr

; 321  :         err_ret->filename = PyUnicode_DecodeFSDefault(filename);

  00026	48 8b ca	 mov	 rcx, rdx
  00029	e8 00 00 00 00	 call	 PyUnicode_DecodeFSDefault

; 322  :     else

  0002e	eb 0c		 jmp	 SHORT $LN6@initerr
$LN3@initerr:

; 323  :         err_ret->filename = PyUnicode_FromString("<string>");

  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08OOGHEFMC@?$DMstring?$DO?$AA@
  00037	e8 00 00 00 00	 call	 PyUnicode_FromString
$LN6@initerr:
  0003c	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 324  :     if (err_ret->filename == NULL) {

  00040	48 85 c0	 test	 rax, rax
  00043	75 0f		 jne	 SHORT $LN1@initerr

; 325  :         err_ret->error = E_ERROR;

  00045	c7 03 11 00 00
	00		 mov	 DWORD PTR [rbx], 17

; 326  :         return -1;

  0004b	83 c8 ff	 or	 eax, -1

; 330  : }

  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5b		 pop	 rbx
  00053	c3		 ret	 0
$LN1@initerr:

; 327  :     }
; 328  : #endif
; 329  :     return 0;

  00054	33 c0		 xor	 eax, eax

; 330  : }

  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5b		 pop	 rbx
  0005b	c3		 ret	 0
initerr	ENDP
_TEXT	ENDS
PUBLIC	PyParser_ParseStringFlagsFilenameEx
EXTRN	PyErr_Occurred:PROC
EXTRN	PyTokenizer_FromString:PROC
EXTRN	PyTokenizer_FromUTF8:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyParser_ParseStringFlagsFilenameEx DD imagerel $LN13
	DD	imagerel $LN13+64
	DD	imagerel $unwind$PyParser_ParseStringFlagsFilenameEx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyParser_ParseStringFlagsFilenameEx DD imagerel $LN13+64
	DD	imagerel $LN13+233
	DD	imagerel $chain$0$PyParser_ParseStringFlagsFilenameEx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyParser_ParseStringFlagsFilenameEx DD imagerel $LN13+233
	DD	imagerel $LN13+253
	DD	imagerel $chain$1$PyParser_ParseStringFlagsFilenameEx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyParser_ParseStringFlagsFilenameEx DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+64
	DD	imagerel $unwind$PyParser_ParseStringFlagsFilenameEx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyParser_ParseStringFlagsFilenameEx DD 020521H
	DD	0a5405H
	DD	imagerel $LN13
	DD	imagerel $LN13+64
	DD	imagerel $unwind$PyParser_ParseStringFlagsFilenameEx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_ParseStringFlagsFilenameEx DD 081301H
	DD	0c6413H
	DD	0b3413H
	DD	0d00f5213H
	DD	0700bc00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\parser\parsetok.c
xdata	ENDS
;	COMDAT PyParser_ParseStringFlagsFilenameEx
_TEXT	SEGMENT
s$ = 80
filename$ = 88
g$ = 96
start$ = 104
err_ret$ = 112
flags$ = 120
PyParser_ParseStringFlagsFilenameEx PROC		; COMDAT

; 47   : {

$LN13:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 48   :     struct tok_state *tok;
; 49   :     int exec_input = start == file_input;
; 50   : 
; 51   :     if (initerr(err_ret, filename) < 0)

  00013	48 8b 74 24 70	 mov	 rsi, QWORD PTR err_ret$[rsp]
  00018	33 db		 xor	 ebx, ebx
  0001a	48 8b f9	 mov	 rdi, rcx
  0001d	41 81 f9 01 01
	00 00		 cmp	 r9d, 257		; 00000101H
  00024	48 8b ce	 mov	 rcx, rsi
  00027	45 8b e1	 mov	 r12d, r9d
  0002a	4d 8b e8	 mov	 r13, r8
  0002d	0f 94 c3	 sete	 bl
  00030	e8 00 00 00 00	 call	 initerr
  00035	85 c0		 test	 eax, eax
  00037	79 07		 jns	 SHORT $LN4@PyParser_P

; 52   :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 a9 00 00 00	 jmp	 $LN5@PyParser_P
$LN4@PyParser_P:
  00040	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp

; 53   : 
; 54   :     if (*flags & PyPARSE_IGNORE_COOKIE)

  00045	48 8b 6c 24 78	 mov	 rbp, QWORD PTR flags$[rsp]

; 55   :         tok = PyTokenizer_FromUTF8(s, exec_input);

  0004a	8b d3		 mov	 edx, ebx
  0004c	f6 45 00 10	 test	 BYTE PTR [rbp], 16
  00050	48 8b cf	 mov	 rcx, rdi
  00053	74 07		 je	 SHORT $LN3@PyParser_P
  00055	e8 00 00 00 00	 call	 PyTokenizer_FromUTF8

; 56   :     else

  0005a	eb 05		 jmp	 SHORT $LN12@PyParser_P
$LN3@PyParser_P:

; 57   :         tok = PyTokenizer_FromString(s, exec_input);

  0005c	e8 00 00 00 00	 call	 PyTokenizer_FromString
$LN12@PyParser_P:
  00061	48 8b f8	 mov	 rdi, rax

; 58   :     if (tok == NULL) {

  00064	48 85 c0	 test	 rax, rax
  00067	75 1b		 jne	 SHORT $LN1@PyParser_P

; 59   :         err_ret->error = PyErr_Occurred() ? E_DECODE : E_NOMEM;

  00069	e8 00 00 00 00	 call	 PyErr_Occurred
  0006e	b9 0f 00 00 00	 mov	 ecx, 15
  00073	ba 16 00 00 00	 mov	 edx, 22
  00078	48 85 c0	 test	 rax, rax
  0007b	0f 45 ca	 cmovne	 ecx, edx

; 60   :         return NULL;

  0007e	33 c0		 xor	 eax, eax
  00080	89 0e		 mov	 DWORD PTR [rsi], ecx
  00082	eb 60		 jmp	 SHORT $LN11@PyParser_P
$LN1@PyParser_P:

; 61   :     }
; 62   : 
; 63   : #ifndef PGEN
; 64   :     Py_INCREF(err_ret->filename);

  00084	48 8b 5e 08	 mov	 rbx, QWORD PTR [rsi+8]
  00088	e8 00 00 00 00	 call	 _Py_PXCTX
  0008d	85 c0		 test	 eax, eax
  0008f	75 32		 jne	 SHORT $LN8@PyParser_P
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0009f	4c 8b cb	 mov	 r9, rbx
  000a2	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a8	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b0	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b5	85 c0		 test	 eax, eax
  000b7	75 06		 jne	 SHORT $LN7@PyParser_P
  000b9	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000bd	74 04		 je	 SHORT $LN8@PyParser_P
$LN7@PyParser_P:
  000bf	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN8@PyParser_P:

; 65   :     tok->filename = err_ret->filename;

  000c3	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]

; 66   : #endif
; 67   :     return parsetok(tok, g, start, err_ret, flags);

  000c7	4c 8b ce	 mov	 r9, rsi
  000ca	45 8b c4	 mov	 r8d, r12d
  000cd	49 8b d5	 mov	 rdx, r13
  000d0	48 8b cf	 mov	 rcx, rdi
  000d3	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  000d8	48 89 87 f0 01
	00 00		 mov	 QWORD PTR [rdi+496], rax
  000df	e8 00 00 00 00	 call	 parsetok
$LN11@PyParser_P:
  000e4	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
$LN5@PyParser_P:

; 68   : }

  000e9	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000ee	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000f3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f7	41 5d		 pop	 r13
  000f9	41 5c		 pop	 r12
  000fb	5f		 pop	 rdi
  000fc	c3		 ret	 0
PyParser_ParseStringFlagsFilenameEx ENDP
_TEXT	ENDS
PUBLIC	PyParser_ParseFileFlagsEx
EXTRN	PyTokenizer_FromFile:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyParser_ParseFileFlagsEx DD imagerel $LN10
	DD	imagerel $LN10+212
	DD	imagerel $unwind$PyParser_ParseFileFlagsEx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_ParseFileFlagsEx DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\parser\parsetok.c
xdata	ENDS
;	COMDAT PyParser_ParseFileFlagsEx
_TEXT	SEGMENT
fp$ = 64
filename$ = 72
enc$ = 80
g$ = 88
start$ = 96
ps1$ = 104
ps2$ = 112
err_ret$ = 120
flags$ = 128
PyParser_ParseFileFlagsEx PROC				; COMDAT

; 94   : {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 95   :     struct tok_state *tok;
; 96   : 
; 97   :     if (initerr(err_ret, filename) < 0)

  00014	48 8b 7c 24 78	 mov	 rdi, QWORD PTR err_ret$[rsp]
  00019	48 8b f1	 mov	 rsi, rcx
  0001c	49 8b e9	 mov	 rbp, r9
  0001f	48 8b cf	 mov	 rcx, rdi
  00022	49 8b d8	 mov	 rbx, r8
  00025	e8 00 00 00 00	 call	 initerr
  0002a	85 c0		 test	 eax, eax

; 98   :         return NULL;

  0002c	78 23		 js	 SHORT $LN9@PyParser_P@2

; 99   : 
; 100  :     if ((tok = PyTokenizer_FromFile(fp, (char *)enc, ps1, ps2)) == NULL) {

  0002e	4c 8b 4c 24 70	 mov	 r9, QWORD PTR ps2$[rsp]
  00033	4c 8b 44 24 68	 mov	 r8, QWORD PTR ps1$[rsp]
  00038	48 8b d3	 mov	 rdx, rbx
  0003b	48 8b ce	 mov	 rcx, rsi
  0003e	e8 00 00 00 00	 call	 PyTokenizer_FromFile
  00043	48 8b f0	 mov	 rsi, rax
  00046	48 85 c0	 test	 rax, rax
  00049	75 0a		 jne	 SHORT $LN1@PyParser_P@2

; 101  :         err_ret->error = E_NOMEM;

  0004b	c7 07 0f 00 00
	00		 mov	 DWORD PTR [rdi], 15
$LN9@PyParser_P@2:

; 102  :         return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	eb 6a		 jmp	 SHORT $LN3@PyParser_P@2
$LN1@PyParser_P@2:

; 103  :     }
; 104  : #ifndef PGEN
; 105  :     Py_INCREF(err_ret->filename);

  00055	48 8b 5f 08	 mov	 rbx, QWORD PTR [rdi+8]
  00059	e8 00 00 00 00	 call	 _Py_PXCTX
  0005e	85 c0		 test	 eax, eax
  00060	75 32		 jne	 SHORT $LN6@PyParser_P@2
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00070	4c 8b cb	 mov	 r9, rbx
  00073	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00079	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00081	e8 00 00 00 00	 call	 _PyParallel_Guard
  00086	85 c0		 test	 eax, eax
  00088	75 06		 jne	 SHORT $LN5@PyParser_P@2
  0008a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0008e	74 04		 je	 SHORT $LN6@PyParser_P@2
$LN5@PyParser_P@2:
  00090	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@PyParser_P@2:

; 106  :     tok->filename = err_ret->filename;

  00094	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]

; 107  : #endif
; 108  :     return parsetok(tok, g, start, err_ret, flags);

  00098	44 8b 44 24 60	 mov	 r8d, DWORD PTR start$[rsp]
  0009d	4c 8b cf	 mov	 r9, rdi
  000a0	48 89 86 f0 01
	00 00		 mov	 QWORD PTR [rsi+496], rax
  000a7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR flags$[rsp]
  000af	48 8b d5	 mov	 rdx, rbp
  000b2	48 8b ce	 mov	 rcx, rsi
  000b5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ba	e8 00 00 00 00	 call	 parsetok
$LN3@PyParser_P@2:

; 109  : }

  000bf	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c4	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000c9	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000ce	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
PyParser_ParseFileFlagsEx ENDP
_TEXT	ENDS
PUBLIC	PyParser_ParseStringFlagsFilename
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyParser_ParseStringFlagsFilename DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$PyParser_ParseStringFlagsFilename
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_ParseStringFlagsFilename DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyParser_ParseStringFlagsFilename
_TEXT	SEGMENT
s$ = 64
filename$ = 72
g$ = 80
start$ = 88
err_ret$ = 96
iflags$ = 104
flags$ = 104
PyParser_ParseStringFlagsFilename PROC			; COMDAT

; 37   : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 38   :     int iflags = flags;

  00004	8b 44 24 68	 mov	 eax, DWORD PTR flags$[rsp]
  00008	89 44 24 68	 mov	 DWORD PTR iflags$[rsp], eax

; 39   :     return PyParser_ParseStringFlagsFilenameEx(s, filename, g, start,
; 40   :                                                err_ret, &iflags);

  0000c	48 8d 44 24 68	 lea	 rax, QWORD PTR iflags$[rsp]
  00011	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00016	48 8b 44 24 60	 mov	 rax, QWORD PTR err_ret$[rsp]
  0001b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00020	e8 00 00 00 00	 call	 PyParser_ParseStringFlagsFilenameEx

; 41   : }

  00025	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00029	c3		 ret	 0
PyParser_ParseStringFlagsFilename ENDP
_TEXT	ENDS
PUBLIC	PyParser_ParseFileFlags
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyParser_ParseFileFlags DD imagerel $LN3
	DD	imagerel $LN3+83
	DD	imagerel $unwind$PyParser_ParseFileFlags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_ParseFileFlags DD 010701H
	DD	0a207H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyParser_ParseFileFlags
_TEXT	SEGMENT
fp$ = 96
filename$ = 104
enc$ = 112
g$ = 120
start$ = 128
ps1$ = 136
ps2$ = 144
err_ret$ = 152
flags$ = 160
PyParser_ParseFileFlags PROC				; COMDAT

; 84   : {

$LN3:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 85   :     int iflags = flags;

  00007	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  0000e	41 89 43 48	 mov	 DWORD PTR [r11+72], eax

; 86   :     return PyParser_ParseFileFlagsEx(fp, filename, enc, g, start, ps1,
; 87   :                                      ps2, err_ret, &iflags);

  00012	49 8d 43 48	 lea	 rax, QWORD PTR [r11+72]
  00016	49 89 43 e8	 mov	 QWORD PTR [r11-24], rax
  0001a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  00022	49 89 43 e0	 mov	 QWORD PTR [r11-32], rax
  00026	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ps2$[rsp]
  0002e	49 89 43 d8	 mov	 QWORD PTR [r11-40], rax
  00032	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ps1$[rsp]
  0003a	49 89 43 d0	 mov	 QWORD PTR [r11-48], rax
  0003e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR start$[rsp]
  00045	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00049	e8 00 00 00 00	 call	 PyParser_ParseFileFlagsEx

; 88   : }

  0004e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00052	c3		 ret	 0
PyParser_ParseFileFlags ENDP
_TEXT	ENDS
PUBLIC	PyParser_ParseString
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyParser_ParseString DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$PyParser_ParseString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_ParseString DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyParser_ParseString
_TEXT	SEGMENT
s$ = 64
g$ = 72
start$ = 80
err_ret$ = 88
PyParser_ParseString PROC				; COMDAT

; 21   : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 22   :     return PyParser_ParseStringFlagsFilename(s, NULL, g, start, err_ret, 0);

  00004	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0000c	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00011	45 8b c8	 mov	 r9d, r8d
  00014	4c 8b c2	 mov	 r8, rdx
  00017	33 d2		 xor	 edx, edx
  00019	e8 00 00 00 00	 call	 PyParser_ParseStringFlagsFilename

; 23   : }

  0001e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00022	c3		 ret	 0
PyParser_ParseString ENDP
_TEXT	ENDS
PUBLIC	PyParser_ParseStringFlags
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyParser_ParseStringFlags DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$PyParser_ParseStringFlags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_ParseStringFlags DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyParser_ParseStringFlags
_TEXT	SEGMENT
s$ = 64
g$ = 72
start$ = 80
err_ret$ = 88
flags$ = 96
PyParser_ParseStringFlags PROC				; COMDAT

; 28   : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 29   :     return PyParser_ParseStringFlagsFilename(s, NULL,
; 30   :                                              g, start, err_ret, flags);

  00004	8b 44 24 60	 mov	 eax, DWORD PTR flags$[rsp]
  00008	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0000c	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00011	45 8b c8	 mov	 r9d, r8d
  00014	4c 8b c2	 mov	 r8, rdx
  00017	33 d2		 xor	 edx, edx
  00019	e8 00 00 00 00	 call	 PyParser_ParseStringFlagsFilename

; 31   : }

  0001e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00022	c3		 ret	 0
PyParser_ParseStringFlags ENDP
_TEXT	ENDS
PUBLIC	PyParser_ParseFile
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyParser_ParseFile DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$PyParser_ParseFile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_ParseFile DD 010401H
	DD	0a204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyParser_ParseFile
_TEXT	SEGMENT
fp$ = 96
filename$ = 104
g$ = 112
start$ = 120
ps1$ = 128
ps2$ = 136
err_ret$ = 144
PyParser_ParseFile PROC					; COMDAT

; 75   : {

$LN3:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 76   :     return PyParser_ParseFileFlags(fp, filename, NULL,
; 77   :                                    g, start, ps1, ps2, err_ret, 0);

  00004	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  0000c	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR [rsp+64], 0
  00014	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00019	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ps2$[rsp]
  00021	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00026	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ps1$[rsp]
  0002e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00033	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00038	4d 8b c8	 mov	 r9, r8
  0003b	45 33 c0	 xor	 r8d, r8d
  0003e	e8 00 00 00 00	 call	 PyParser_ParseFileFlags

; 78   : }

  00043	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00047	c3		 ret	 0
PyParser_ParseFile ENDP
_TEXT	ENDS
END
