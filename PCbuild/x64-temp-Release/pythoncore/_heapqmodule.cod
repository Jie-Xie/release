; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06ODDEHMFE@_heapq?$AA@			; `string'
PUBLIC	??_C@_09EOLCJGMG@nsmallest?$AA@			; `string'
PUBLIC	??_C@_08FLDGCJJP@nlargest?$AA@			; `string'
PUBLIC	??_C@_07IOKOAJEO@heapify?$AA@			; `string'
PUBLIC	??_C@_0M@PEOLKNFI@heapreplace?$AA@		; `string'
PUBLIC	??_C@_07HNKMJBJN@heappop?$AA@			; `string'
PUBLIC	??_C@_0M@HEAOMNAP@heappushpop?$AA@		; `string'
PUBLIC	??_C@_08BOAFKLGF@heappush?$AA@			; `string'
;	COMDAT ??_C@_06ODDEHMFE@_heapq?$AA@
CONST	SEGMENT
??_C@_06ODDEHMFE@_heapq?$AA@ DB '_heapq', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EOLCJGMG@nsmallest?$AA@
CONST	SEGMENT
??_C@_09EOLCJGMG@nsmallest?$AA@ DB 'nsmallest', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FLDGCJJP@nlargest?$AA@
CONST	SEGMENT
??_C@_08FLDGCJJP@nlargest?$AA@ DB 'nlargest', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IOKOAJEO@heapify?$AA@
CONST	SEGMENT
??_C@_07IOKOAJEO@heapify?$AA@ DB 'heapify', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PEOLKNFI@heapreplace?$AA@
CONST	SEGMENT
??_C@_0M@PEOLKNFI@heapreplace?$AA@ DB 'heapreplace', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HNKMJBJN@heappop?$AA@
CONST	SEGMENT
??_C@_07HNKMJBJN@heappop?$AA@ DB 'heappop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HEAOMNAP@heappushpop?$AA@
CONST	SEGMENT
??_C@_0M@HEAOMNAP@heappushpop?$AA@ DB 'heappushpop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BOAFKLGF@heappush?$AA@
CONST	SEGMENT
??_C@_08BOAFKLGF@heappush?$AA@ DB 'heappush', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
heappush_doc DB	'heappush(heap, item) -> None. Push item onto heap, maint'
	DB	'aining the heap invariant.', 00H
	ORG $+13
heappop_doc DB	'Pop the smallest item off the heap, maintaining the heap'
	DB	' invariant.', 00H
	ORG $+12
heapreplace_doc DB 'heapreplace(heap, item) -> value. Pop and return the '
	DB	'current smallest value, and add the new item.', 0aH, 0aH, 'Th'
	DB	'is is more efficient than heappop() followed by heappush(), a'
	DB	'nd can be', 0aH, 'more appropriate when using a fixed-size he'
	DB	'ap.  Note that the value', 0aH, 'returned may be larger than '
	DB	'item!  That constrains reasonable uses of', 0aH, 'this routin'
	DB	'e unless written as part of a conditional replacement:', 0aH, 0aH
	DB	'    if item > heap[0]:', 0aH, '        item = heapreplace(hea'
	DB	'p, item)', 0aH, 00H
	ORG $+7
heappushpop_doc DB 'heappushpop(heap, item) -> value. Push item on the he'
	DB	'ap, then pop and return the smallest item', 0aH, 'from the he'
	DB	'ap. The combined action runs more efficiently than', 0aH, 'he'
	DB	'appush() followed by a separate call to heappop().', 00H
	ORG $+6
heapify_doc DB	'Transform list into a heap, in-place, in O(len(heap)) ti'
	DB	'me.', 00H
	ORG $+12
nlargest_doc DB	'Find the n largest elements in a dataset.', 0aH, 0aH, 'E'
	DB	'quivalent to:  sorted(iterable, reverse=True)[:n]', 0aH, 00H
	ORG $+1
nsmallest_doc DB 'Find the n smallest elements in a dataset.', 0aH, 0aH, 'E'
	DB	'quivalent to:  sorted(iterable)[:n]', 0aH, 00H
	ORG $+14
heapq_methods DQ FLAT:??_C@_08BOAFKLGF@heappush?$AA@
	DQ	FLAT:heappush
	DD	01H
	ORG $+4
	DQ	FLAT:heappush_doc
	DQ	FLAT:??_C@_0M@HEAOMNAP@heappushpop?$AA@
	DQ	FLAT:heappushpop
	DD	01H
	ORG $+4
	DQ	FLAT:heappushpop_doc
	DQ	FLAT:??_C@_07HNKMJBJN@heappop?$AA@
	DQ	FLAT:heappop
	DD	08H
	ORG $+4
	DQ	FLAT:heappop_doc
	DQ	FLAT:??_C@_0M@PEOLKNFI@heapreplace?$AA@
	DQ	FLAT:heapreplace
	DD	01H
	ORG $+4
	DQ	FLAT:heapreplace_doc
	DQ	FLAT:??_C@_07IOKOAJEO@heapify?$AA@
	DQ	FLAT:heapify
	DD	08H
	ORG $+4
	DQ	FLAT:heapify_doc
	DQ	FLAT:??_C@_08FLDGCJJP@nlargest?$AA@
	DQ	FLAT:nlargest
	DD	01H
	ORG $+4
	DQ	FLAT:nlargest_doc
	DQ	FLAT:??_C@_09EOLCJGMG@nsmallest?$AA@
	DQ	FLAT:nsmallest
	DD	01H
	ORG $+4
	DQ	FLAT:nsmallest_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
module_doc DB	'Heap queue algorithm (a.k.a. priority queue).', 0aH, 0aH
	DB	'Heaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k'
	DB	'+2] for', 0aH, 'all k, counting elements from 0.  For the sak'
	DB	'e of comparison,', 0aH, 'non-existing elements are considered'
	DB	' to be infinite.  The interesting', 0aH, 'property of a heap '
	DB	'is that a[0] is always its smallest element.', 0aH, 0aH, 'Usa'
	DB	'ge:', 0aH, 0aH, 'heap = []            # creates an empty heap'
	DB	0aH, 'heappush(heap, item) # pushes a new item on the heap', 0aH
	DB	'item = heappop(heap) # pops the smallest item from the heap', 0aH
	DB	'item = heap[0]       # smallest item on the heap without popp'
	DB	'ing it', 0aH, 'heapify(x)           # transforms list into a '
	DB	'heap, in-place, in linear time', 0aH, 'item = heapreplace(hea'
	DB	'p, item) # pops and returns smallest item, and adds', 0aH, ' '
	DB	'                              # new item; the heap size is un'
	DB	'changed', 0aH, 0aH, 'Our API differs from textbook heap algor'
	DB	'ithms as follows:', 0aH, 0aH, '- We use 0-based indexing.  Th'
	DB	'is makes the relationship between the', 0aH, '  index for a n'
	DB	'ode and the indexes for its children slightly less', 0aH, '  '
	DB	'obvious, but is more suitable since Python uses 0-based index'
	DB	'ing.', 0aH, 0aH, '- Our heappop() method returns the smallest'
	DB	' item, not the largest.', 0aH, 0aH, 'These two make it possib'
	DB	'le to view the heap as a regular Python list', 0aH, 'without '
	DB	'surprises: heap[0] is the smallest item, and heap.sort()', 0aH
	DB	'maintains the heap invariant!', 0aH, 00H
__about__ DB	'Heap queues', 0aH, 0aH, '[explanation by Fran', 0c3H, 0a7H
	DB	'ois Pinard]', 0aH, 0aH, 'Heaps are arrays for which a[k] <= a'
	DB	'[2*k+1] and a[k] <= a[2*k+2] for', 0aH, 'all k, counting elem'
	DB	'ents from 0.  For the sake of comparison,', 0aH, 'non-existin'
	DB	'g elements are considered to be infinite.  The interesting', 0aH
	DB	'property of a heap is that a[0] is always its smallest elemen'
	DB	't.', 0aH, 0aH, 'The strange invariant above is meant to be an'
	DB	' efficient memory', 0aH, 'representation for a tournament.  T'
	DB	'he numbers below are `k'', not a[k]:', 0aH, 0aH, '           '
	DB	'                        0', 0aH, 0aH, '                  1   '
	DB	'                              2', 0aH, 0aH, '          3     '
	DB	'          4                5               6', 0aH, 0aH, '   '
	DB	'   7       8       9       10      11      12      13      14'
	DB	0aH, 0aH, '    15 16   17 18   19 20   21 22   23 24   25 26  '
	DB	' 27 28   29 30', 0aH, 0aH, 0aH, 'In the tree above, each cell'
	DB	' `k'' is topping `2*k+1'' and `2*k+2''.  In', 0aH, 'an usual '
	DB	'binary tournament we see in sports, each cell is the winner', 0aH
	DB	'over the two cells it tops, and we can trace the winner down '
	DB	'the tree', 0aH, 'to see all opponents s/he had.  However, in '
	DB	'many computer applications', 0aH, 'of such tournaments, we do'
	DB	' not need to trace the history of a winner.', 0aH, 'To be mor'
	DB	'e memory efficient, when a winner is promoted, we try to', 0aH
	DB	'replace it by something else at a lower level, and the rule b'
	DB	'ecomes', 0aH, 'that a cell and the two cells it tops contain '
	DB	'three different items,', 0aH, 'but the top cell "wins" over t'
	DB	'he two topped cells.', 0aH, 0aH, 'If this heap invariant is p'
	DB	'rotected at all time, index 0 is clearly', 0aH, 'the overall '
	DB	'winner.  The simplest algorithmic way to remove it and', 0aH, 'f'
	DB	'ind the "next" winner is to move some loser (let''s say cell '
	DB	'30 in the', 0aH, 'diagram above) into the 0 position, and the'
	DB	'n percolate this new 0 down', 0aH, 'the tree, exchanging valu'
	DB	'es, until the invariant is re-established.', 0aH, 'This is cl'
	DB	'early logarithmic on the total number of items in the tree.', 0aH
	DB	'By iterating over all items, you get an O(n ln n) sort.', 0aH
	DB	0aH, 'A nice feature of this sort is that you can efficiently '
	DB	'insert new', 0aH, 'items while the sort is going on, provided'
	DB	' that the inserted items are', 0aH, 'not "better" than the la'
	DB	'st 0''th element you extracted.  This is', 0aH, 'especially u'
	DB	'seful in simulation contexts, where the tree holds all', 0aH, 'i'
	DB	'ncoming events, and the "win" condition means the smallest sc'
	DB	'heduled', 0aH, 'time.  When an event schedule other events fo'
	DB	'r execution, they are', 0aH, 'scheduled into the future, so t'
	DB	'hey can easily go into the heap.  So, a', 0aH, 'heap is a goo'
	DB	'd structure for implementing schedulers (this is what I', 0aH
	DB	'used for my MIDI sequencer :-).', 0aH, 0aH, 'Various structur'
	DB	'es for implementing schedulers have been extensively', 0aH, 's'
	DB	'tudied, and heaps are good for this, as they are reasonably s'
	DB	'peedy,', 0aH, 'the speed is almost constant, and the worst ca'
	DB	'se is not much different', 0aH, 'than the average case.  Howe'
	DB	'ver, there are other representations which', 0aH, 'are more e'
	DB	'fficient overall, yet the worst cases might be terrible.', 0aH
	DB	0aH, 'Heaps are also very useful in big disk sorts.  You most '
	DB	'probably all', 0aH, 'know that a big sort implies producing "'
	DB	'runs" (which are pre-sorted', 0aH, 'sequences, which size is '
	DB	'usually related to the amount of CPU memory),', 0aH, 'followe'
	DB	'd by a merging passes for these runs, which merging is often', 0aH
	DB	'very cleverly organised[1].  It is very important that the in'
	DB	'itial', 0aH, 'sort produces the longest runs possible.  Tourn'
	DB	'aments are a good way', 0aH, 'to that.  If, using all the mem'
	DB	'ory available to hold a tournament, you', 0aH, 'replace and p'
	DB	'ercolate items that happen to fit the current run, you''ll', 0aH
	DB	'produce runs which are twice the size of the memory for rando'
	DB	'm input,', 0aH, 'and much better for input fuzzily ordered.', 0aH
	DB	0aH, 'Moreover, if you output the 0''th item on disk and get a'
	DB	'n input which', 0aH, 'may not fit in the current tournament ('
	DB	'because the value "wins" over', 0aH, 'the last output value),'
	DB	' it cannot fit in the heap, so the size of the', 0aH, 'heap d'
	DB	'ecreases.  The freed memory could be cleverly reused immediat'
	DB	'ely', 0aH, 'for progressively building a second heap, which g'
	DB	'rows at exactly the', 0aH, 'same rate the first heap is melti'
	DB	'ng.  When the first heap completely', 0aH, 'vanishes, you swi'
	DB	'tch heaps and start a new run.  Clever and quite', 0aH, 'effe'
	DB	'ctive!', 0aH, 0aH, 'In a word, heaps are useful memory struct'
	DB	'ures to know.  I use them in', 0aH, 'a few applications, and '
	DB	'I think it is good to keep a `heap'' module', 0aH, 'around. :'
	DB	'-)', 0aH, 0aH, '--------------------', 0aH, '[1] The disk bal'
	DB	'ancing algorithms which are current, nowadays, are', 0aH, 'mo'
	DB	're annoying than clever, and this is a consequence of the see'
	DB	'king', 0aH, 'capabilities of the disks.  On devices which can'
	DB	'not seek, like big', 0aH, 'tape drives, the story was quite d'
	DB	'ifferent, and one had to be very', 0aH, 'clever to ensure (fa'
	DB	'r in advance) that each tape movement will be the', 0aH, 'mos'
	DB	't effective possible (that is, will best participate at', 0aH
	DB	'"progressing" the merge).  Some tapes were even able to read', 0aH
	DB	'backwards, and this was also used to avoid the rewinding time'
	DB	'.', 0aH, 'Believe me, real good tape sorts were quite spectac'
	DB	'ular to watch!', 0aH, 'From all times, sorting has always bee'
	DB	'n a Great Art! :-)', 0aH, 00H
	ORG $+15
_heapqmodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_06ODDEHMFE@_heapq?$AA@
	DQ	FLAT:module_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:heapq_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@OEDFOECO@list?5changed?5size?5during?5iterati@ ; `string'
PUBLIC	??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@	; `string'
EXTRN	PyExc_RuntimeError:QWORD
EXTRN	PyObject_RichCompareBool:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_IndexError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_siftdown DD imagerel _siftdown
	DD	imagerel _siftdown+66
	DD	imagerel $unwind$_siftdown
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_siftdown DD imagerel _siftdown+66
	DD	imagerel _siftdown+461
	DD	imagerel $chain$3$_siftdown
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$_siftdown DD imagerel _siftdown+461
	DD	imagerel _siftdown+506
	DD	imagerel $chain$5$_siftdown
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$_siftdown DD 080021H
	DD	06d400H
	DD	0ec400H
	DD	0d7400H
	DD	0c3400H
	DD	imagerel _siftdown
	DD	imagerel _siftdown+66
	DD	imagerel $unwind$_siftdown
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_siftdown DD 085621H
	DD	06d456H
	DD	0d7451H
	DD	0c344cH
	DD	0ec405H
	DD	imagerel _siftdown
	DD	imagerel _siftdown+66
	DD	imagerel $unwind$_siftdown
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_siftdown DD 050b01H
	DD	0f007620bH
	DD	06003e005H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0CD@OEDFOECO@list?5changed?5size?5during?5iterati@
CONST	SEGMENT
??_C@_0CD@OEDFOECO@list?5changed?5size?5during?5iterati@ DB 'list changed'
	DB	' size during iteration', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@ DB 'index out of range', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_heapqmodule.c
CONST	ENDS
;	COMDAT _siftdown
_TEXT	SEGMENT
heap$ = 96
startpos$ = 104
pos$ = 112
_siftdown PROC						; COMDAT

; 13   : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	41 56		 push	 r14
  00005	41 57		 push	 r15
  00007	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 14   :     PyObject *newitem, *parent, *olditem;
; 15   :     int cmp;
; 16   :     Py_ssize_t parentpos;
; 17   :     Py_ssize_t size;
; 18   : 
; 19   :     assert(PyList_Check(heap));
; 20   :     size = PyList_GET_SIZE(heap);

  0000b	4c 8b 71 60	 mov	 r14, QWORD PTR [rcx+96]
  0000f	49 8b f0	 mov	 rsi, r8
  00012	4c 8b fa	 mov	 r15, rdx
  00015	48 8b e9	 mov	 rbp, rcx

; 21   :     if (pos >= size) {

  00018	4d 3b c6	 cmp	 r8, r14
  0001b	7c 21		 jl	 SHORT $LN7@siftdown

; 22   :         PyErr_SetString(PyExc_IndexError, "index out of range");

  0001d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@
  0002b	e8 00 00 00 00	 call	 PyErr_SetString

; 23   :         return -1;

  00030	83 c8 ff	 or	 eax, -1

; 60   : }

  00033	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00037	41 5f		 pop	 r15
  00039	41 5e		 pop	 r14
  0003b	5e		 pop	 rsi
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
$LN7@siftdown:

; 24   :     }
; 25   : 
; 26   :     newitem = PyList_GET_ITEM(heap, pos);

  0003e	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00042	4c 89 64 24 70	 mov	 QWORD PTR [rsp+112], r12
  00047	4e 8b 24 c0	 mov	 r12, QWORD PTR [rax+r8*8]

; 27   :     Py_INCREF(newitem);

  0004b	e8 00 00 00 00	 call	 _Py_PXCTX
  00050	85 c0		 test	 eax, eax
  00052	75 35		 jne	 SHORT $LN29@siftdown
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00062	4d 8b cc	 mov	 r9, r12
  00065	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0006b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00073	e8 00 00 00 00	 call	 _PyParallel_Guard
  00078	85 c0		 test	 eax, eax
  0007a	75 08		 jne	 SHORT $LN10@siftdown
  0007c	41 f6 44 24 20
	20		 test	 BYTE PTR [r12+32], 32	; 00000020H
  00082	74 05		 je	 SHORT $LN29@siftdown
$LN10@siftdown:
  00084	49 ff 44 24 50	 inc	 QWORD PTR [r12+80]
$LN29@siftdown:
  00089	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  0008e	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  00093	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13

; 28   :     /* Follow the path to the root, moving parents down until finding
; 29   :        a place newitem fits. */
; 30   :     while (pos > startpos){

  00098	49 3b f7	 cmp	 rsi, r15
  0009b	0f 8e f6 00 00
	00		 jle	 $LN5@siftdown
$LL6@siftdown:

; 31   :         parentpos = (pos - 1) >> 1;
; 32   :         parent = PyList_GET_ITEM(heap, parentpos);

  000a1	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  000a5	4c 8d 6e ff	 lea	 r13, QWORD PTR [rsi-1]

; 33   :         cmp = PyObject_RichCompareBool(newitem, parent, Py_LT);

  000a9	45 33 c0	 xor	 r8d, r8d
  000ac	49 d1 fd	 sar	 r13, 1
  000af	49 8b cc	 mov	 rcx, r12
  000b2	4a 8b 3c e8	 mov	 rdi, QWORD PTR [rax+r13*8]
  000b6	48 8b d7	 mov	 rdx, rdi
  000b9	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 34   :         if (cmp == -1) {

  000be	83 f8 ff	 cmp	 eax, -1
  000c1	0f 84 26 01 00
	00		 je	 $LN30@siftdown

; 37   :         }
; 38   :         if (size != PyList_GET_SIZE(heap)) {

  000c7	4c 3b 75 60	 cmp	 r14, QWORD PTR [rbp+96]
  000cb	0f 85 fc 00 00
	00		 jne	 $LN31@siftdown

; 43   :         }
; 44   :         if (cmp == 0)

  000d1	85 c0		 test	 eax, eax
  000d3	0f 84 be 00 00
	00		 je	 $LN5@siftdown

; 45   :             break;
; 46   :         Py_INCREF(parent);

  000d9	e8 00 00 00 00	 call	 _Py_PXCTX
  000de	85 c0		 test	 eax, eax
  000e0	75 32		 jne	 SHORT $LN15@siftdown
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000f0	4c 8b cf	 mov	 r9, rdi
  000f3	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000f9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00101	e8 00 00 00 00	 call	 _PyParallel_Guard
  00106	85 c0		 test	 eax, eax
  00108	75 06		 jne	 SHORT $LN14@siftdown
  0010a	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0010e	74 04		 je	 SHORT $LN15@siftdown
$LN14@siftdown:
  00110	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN15@siftdown:

; 47   :         olditem = PyList_GET_ITEM(heap, pos);

  00114	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  00118	48 8b 1c f0	 mov	 rbx, QWORD PTR [rax+rsi*8]

; 48   :         PyList_SET_ITEM(heap, pos, parent);

  0011c	48 89 3c f0	 mov	 QWORD PTR [rax+rsi*8], rdi

; 49   :         Py_DECREF(olditem);

  00120	e8 00 00 00 00	 call	 _Py_PXCTX
  00125	85 c0		 test	 eax, eax
  00127	75 5c		 jne	 SHORT $LN28@siftdown
  00129	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0012d	a8 20		 test	 al, 32			; 00000020H
  0012f	75 4c		 jne	 SHORT $LN22@siftdown
  00131	84 c0		 test	 al, al
  00133	78 48		 js	 SHORT $LN22@siftdown
  00135	a8 02		 test	 al, 2
  00137	75 4c		 jne	 SHORT $LN28@siftdown
  00139	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0013d	75 46		 jne	 SHORT $LN28@siftdown
  0013f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00146	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0014d	4c 8b cb	 mov	 r9, rbx
  00150	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00156	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0015e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00163	48 8b cb	 mov	 rcx, rbx
  00166	85 c0		 test	 eax, eax
  00168	74 07		 je	 SHORT $LN27@siftdown
  0016a	e8 00 00 00 00	 call	 _Px_Dealloc
  0016f	eb 14		 jmp	 SHORT $LN28@siftdown
$LN27@siftdown:
  00171	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00175	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0017b	eb 08		 jmp	 SHORT $LN28@siftdown
$LN22@siftdown:
  0017d	48 8b cb	 mov	 rcx, rbx
  00180	e8 00 00 00 00	 call	 Px_DecRef
$LN28@siftdown:

; 50   :         pos = parentpos;

  00185	49 8b f5	 mov	 rsi, r13

; 51   :         if (size != PyList_GET_SIZE(heap)) {

  00188	4c 3b 75 60	 cmp	 r14, QWORD PTR [rbp+96]
  0018c	75 47		 jne	 SHORT $LN33@siftdown

; 28   :     /* Follow the path to the root, moving parents down until finding
; 29   :        a place newitem fits. */
; 30   :     while (pos > startpos){

  0018e	4d 3b ef	 cmp	 r13, r15
  00191	0f 8f 0a ff ff
	ff		 jg	 $LL6@siftdown
$LN5@siftdown:

; 52   :             PyErr_SetString(PyExc_RuntimeError,
; 53   :                             "list changed size during iteration");
; 54   :             return -1;
; 55   :         }
; 56   :     }
; 57   :     Py_DECREF(PyList_GET_ITEM(heap, pos));

  00197	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  0019b	48 8b 0c f1	 mov	 rcx, QWORD PTR [rcx+rsi*8]
  0019f	e8 00 00 00 00	 call	 _Py_DecRef

; 58   :     PyList_SET_ITEM(heap, pos, newitem);

  001a4	4c 8b 5d 70	 mov	 r11, QWORD PTR [rbp+112]

; 59   :     return 0;

  001a8	33 c0		 xor	 eax, eax
  001aa	4d 89 24 f3	 mov	 QWORD PTR [r11+rsi*8], r12
$LN37@siftdown:
  001ae	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  001b3	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  001b8	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]
  001bd	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]

; 60   : }

  001c2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001c6	41 5f		 pop	 r15
  001c8	41 5e		 pop	 r14
  001ca	5e		 pop	 rsi
  001cb	5d		 pop	 rbp
  001cc	c3		 ret	 0
$LN31@siftdown:

; 39   :             Py_DECREF(newitem);

  001cd	49 8b cc	 mov	 rcx, r12
  001d0	e8 00 00 00 00	 call	 _Py_DecRef
$LN33@siftdown:

; 40   :             PyErr_SetString(PyExc_RuntimeError,
; 41   :                             "list changed size during iteration");

  001d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  001dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@OEDFOECO@list?5changed?5size?5during?5iterati@
  001e3	e8 00 00 00 00	 call	 PyErr_SetString

; 42   :             return -1;

  001e8	83 c8 ff	 or	 eax, -1
  001eb	eb c1		 jmp	 SHORT $LN37@siftdown
$LN30@siftdown:

; 35   :             Py_DECREF(newitem);

  001ed	49 8b cc	 mov	 rcx, r12
  001f0	e8 00 00 00 00	 call	 _Py_DecRef

; 36   :             return -1;

  001f5	83 c8 ff	 or	 eax, -1
  001f8	eb b4		 jmp	 SHORT $LN37@siftdown
_siftdown ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_siftup DD imagerel _siftup
	DD	imagerel _siftup+68
	DD	imagerel $unwind$_siftup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_siftup DD imagerel _siftup+68
	DD	imagerel _siftup+497
	DD	imagerel $chain$3$_siftup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$_siftup DD imagerel _siftup+497
	DD	imagerel _siftup+542
	DD	imagerel $chain$5$_siftup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$_siftup DD 080021H
	DD	06e400H
	DD	0e7400H
	DD	0d6400H
	DD	0c3400H
	DD	imagerel _siftup
	DD	imagerel _siftup+68
	DD	imagerel $unwind$_siftup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_siftup DD 085921H
	DD	0e7459H
	DD	0c3454H
	DD	06e40aH
	DD	0d6405H
	DD	imagerel _siftup
	DD	imagerel _siftup+68
	DD	imagerel $unwind$_siftup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_siftup DD 050c01H
	DD	0f008620cH
	DD	0c004d006H
	DD	05002H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_heapqmodule.c
xdata	ENDS
;	COMDAT _siftup
_TEXT	SEGMENT
heap$ = 96
pos$ = 104
_siftup	PROC						; COMDAT

; 64   : {

  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	41 57		 push	 r15
  00008	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 65   :     Py_ssize_t startpos, endpos, childpos, rightpos;
; 66   :     int cmp;
; 67   :     PyObject *newitem, *tmp, *olditem;
; 68   :     Py_ssize_t size;
; 69   : 
; 70   :     assert(PyList_Check(heap));
; 71   :     size = PyList_GET_SIZE(heap);

  0000c	4c 8b 69 60	 mov	 r13, QWORD PTR [rcx+96]
  00010	48 8b ea	 mov	 rbp, rdx
  00013	4c 8b e1	 mov	 r12, rcx

; 72   :     endpos = size;
; 73   :     startpos = pos;

  00016	4c 8b fa	 mov	 r15, rdx

; 74   :     if (pos >= endpos) {

  00019	49 3b d5	 cmp	 rdx, r13
  0001c	7c 22		 jl	 SHORT $LN8@siftup

; 75   :         PyErr_SetString(PyExc_IndexError, "index out of range");

  0001e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@
  0002c	e8 00 00 00 00	 call	 PyErr_SetString

; 76   :         return -1;

  00031	83 c8 ff	 or	 eax, -1

; 124  : }

  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	41 5f		 pop	 r15
  0003a	41 5d		 pop	 r13
  0003c	41 5c		 pop	 r12
  0003e	5d		 pop	 rbp
  0003f	c3		 ret	 0
$LN8@siftup:

; 77   :     }
; 78   :     newitem = PyList_GET_ITEM(heap, pos);

  00040	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00044	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  00049	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  0004e	4c 8b 34 d0	 mov	 r14, QWORD PTR [rax+rdx*8]

; 79   :     Py_INCREF(newitem);

  00052	e8 00 00 00 00	 call	 _Py_PXCTX
  00057	85 c0		 test	 eax, eax
  00059	75 33		 jne	 SHORT $LN12@siftup
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00069	4d 8b ce	 mov	 r9, r14
  0006c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00072	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007f	85 c0		 test	 eax, eax
  00081	75 07		 jne	 SHORT $LN11@siftup
  00083	41 f6 46 20 20	 test	 BYTE PTR [r14+32], 32	; 00000020H
  00088	74 04		 je	 SHORT $LN12@siftup
$LN11@siftup:
  0008a	49 ff 46 50	 inc	 QWORD PTR [r14+80]
$LN12@siftup:

; 80   : 
; 81   :     /* Bubble up the smaller child until hitting a leaf. */
; 82   :     childpos = 2*pos + 1;    /* leftmost child position  */

  0008e	48 8d 74 2d 01	 lea	 rsi, QWORD PTR [rbp+rbp+1]
  00093	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00098	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi

; 83   :     while (childpos < endpos) {

  0009d	49 3b f5	 cmp	 rsi, r13
  000a0	0f 8d 06 01 00
	00		 jge	 $LN6@siftup
$LL7@siftup:

; 84   :         /* Set childpos to index of smaller child.   */
; 85   :         rightpos = childpos + 1;

  000a6	48 8d 5e 01	 lea	 rbx, QWORD PTR [rsi+1]

; 86   :         if (rightpos < endpos) {

  000aa	49 3b dd	 cmp	 rbx, r13
  000ad	7d 24		 jge	 SHORT $LN3@siftup

; 87   :             cmp = PyObject_RichCompareBool(
; 88   :                 PyList_GET_ITEM(heap, childpos),
; 89   :                 PyList_GET_ITEM(heap, rightpos),
; 90   :                 Py_LT);

  000af	49 8b 4c 24 70	 mov	 rcx, QWORD PTR [r12+112]
  000b4	45 33 c0	 xor	 r8d, r8d
  000b7	48 8b 14 d9	 mov	 rdx, QWORD PTR [rcx+rbx*8]
  000bb	48 8b 0c f1	 mov	 rcx, QWORD PTR [rcx+rsi*8]
  000bf	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 91   :             if (cmp == -1) {

  000c4	83 f8 ff	 cmp	 eax, -1
  000c7	0f 84 24 01 00
	00		 je	 $LN31@siftup

; 94   :             }
; 95   :             if (cmp == 0)

  000cd	85 c0		 test	 eax, eax
  000cf	48 0f 44 f3	 cmove	 rsi, rbx
$LN3@siftup:

; 96   :                 childpos = rightpos;
; 97   :         }
; 98   :         if (size != PyList_GET_SIZE(heap)) {

  000d3	4d 3b 6c 24 60	 cmp	 r13, QWORD PTR [r12+96]
  000d8	0f 85 20 01 00
	00		 jne	 $LN32@siftup

; 103  :         }
; 104  :         /* Move the smaller child up. */
; 105  :         tmp = PyList_GET_ITEM(heap, childpos);

  000de	49 8b 44 24 70	 mov	 rax, QWORD PTR [r12+112]
  000e3	48 8b 3c f0	 mov	 rdi, QWORD PTR [rax+rsi*8]

; 106  :         Py_INCREF(tmp);

  000e7	e8 00 00 00 00	 call	 _Py_PXCTX
  000ec	85 c0		 test	 eax, eax
  000ee	75 32		 jne	 SHORT $LN16@siftup
  000f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000fe	4c 8b cf	 mov	 r9, rdi
  00101	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00107	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0010f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00114	85 c0		 test	 eax, eax
  00116	75 06		 jne	 SHORT $LN15@siftup
  00118	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0011c	74 04		 je	 SHORT $LN16@siftup
$LN15@siftup:
  0011e	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN16@siftup:

; 107  :         olditem = PyList_GET_ITEM(heap, pos);

  00122	49 8b 44 24 70	 mov	 rax, QWORD PTR [r12+112]
  00127	48 8b 1c e8	 mov	 rbx, QWORD PTR [rax+rbp*8]

; 108  :         PyList_SET_ITEM(heap, pos, tmp);

  0012b	48 89 3c e8	 mov	 QWORD PTR [rax+rbp*8], rdi

; 109  :         Py_DECREF(olditem);

  0012f	e8 00 00 00 00	 call	 _Py_PXCTX
  00134	85 c0		 test	 eax, eax
  00136	75 5c		 jne	 SHORT $LN29@siftup
  00138	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0013c	a8 20		 test	 al, 32			; 00000020H
  0013e	75 4c		 jne	 SHORT $LN23@siftup
  00140	84 c0		 test	 al, al
  00142	78 48		 js	 SHORT $LN23@siftup
  00144	a8 02		 test	 al, 2
  00146	75 4c		 jne	 SHORT $LN29@siftup
  00148	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0014c	75 46		 jne	 SHORT $LN29@siftup
  0014e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00155	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0015c	4c 8b cb	 mov	 r9, rbx
  0015f	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00165	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0016d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00172	48 8b cb	 mov	 rcx, rbx
  00175	85 c0		 test	 eax, eax
  00177	74 07		 je	 SHORT $LN28@siftup
  00179	e8 00 00 00 00	 call	 _Px_Dealloc
  0017e	eb 14		 jmp	 SHORT $LN29@siftup
$LN28@siftup:
  00180	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00184	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0018a	eb 08		 jmp	 SHORT $LN29@siftup
$LN23@siftup:
  0018c	48 8b cb	 mov	 rcx, rbx
  0018f	e8 00 00 00 00	 call	 Px_DecRef
$LN29@siftup:

; 110  :         pos = childpos;

  00194	48 8b ee	 mov	 rbp, rsi

; 111  :         childpos = 2*pos + 1;

  00197	48 8d 74 36 01	 lea	 rsi, QWORD PTR [rsi+rsi+1]

; 112  :         if (size != PyList_GET_SIZE(heap)) {

  0019c	4d 3b 6c 24 60	 cmp	 r13, QWORD PTR [r12+96]
  001a1	75 63		 jne	 SHORT $LN33@siftup

; 83   :     while (childpos < endpos) {

  001a3	49 3b f5	 cmp	 rsi, r13
  001a6	0f 8c fa fe ff
	ff		 jl	 $LL7@siftup
$LN6@siftup:

; 113  :             PyErr_SetString(PyExc_RuntimeError,
; 114  :                             "list changed size during iteration");
; 115  :             return -1;
; 116  :         }
; 117  :     }
; 118  : 
; 119  :     /* The leaf at pos is empty now.  Put newitem there, and bubble
; 120  :        it up to its final resting place (by sifting its parents down). */
; 121  :     Py_DECREF(PyList_GET_ITEM(heap, pos));

  001ac	49 8b 4c 24 70	 mov	 rcx, QWORD PTR [r12+112]
  001b1	48 8b 0c e9	 mov	 rcx, QWORD PTR [rcx+rbp*8]
  001b5	e8 00 00 00 00	 call	 _Py_DecRef

; 122  :     PyList_SET_ITEM(heap, pos, newitem);

  001ba	4d 8b 5c 24 70	 mov	 r11, QWORD PTR [r12+112]

; 123  :     return _siftdown(heap, startpos, pos);

  001bf	4c 8b c5	 mov	 r8, rbp
  001c2	49 8b d7	 mov	 rdx, r15
  001c5	49 8b cc	 mov	 rcx, r12
  001c8	4d 89 34 eb	 mov	 QWORD PTR [r11+rbp*8], r14
  001cc	e8 00 00 00 00	 call	 _siftdown
$LN38@siftup:
  001d1	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
  001d6	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  001db	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  001e0	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]

; 124  : }

  001e5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001e9	41 5f		 pop	 r15
  001eb	41 5d		 pop	 r13
  001ed	41 5c		 pop	 r12
  001ef	5d		 pop	 rbp
  001f0	c3		 ret	 0
$LN31@siftup:

; 92   :                 Py_DECREF(newitem);

  001f1	49 8b ce	 mov	 rcx, r14
  001f4	e8 00 00 00 00	 call	 _Py_DecRef

; 93   :                 return -1;

  001f9	83 c8 ff	 or	 eax, -1
  001fc	eb d3		 jmp	 SHORT $LN38@siftup
$LN32@siftup:

; 99   :             Py_DECREF(newitem);

  001fe	49 8b ce	 mov	 rcx, r14
  00201	e8 00 00 00 00	 call	 _Py_DecRef
$LN33@siftup:

; 100  :             PyErr_SetString(PyExc_RuntimeError,
; 101  :                             "list changed size during iteration");

  00206	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0020d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@OEDFOECO@list?5changed?5size?5during?5iterati@
  00214	e8 00 00 00 00	 call	 PyErr_SetString

; 102  :             return -1;

  00219	83 c8 ff	 or	 eax, -1
  0021c	eb b3		 jmp	 SHORT $LN38@siftup
_siftup	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@OEOCFJLB@heap?5argument?5must?5be?5a?5list?$AA@ ; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyList_Append:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$heappush DD imagerel heappush
	DD	imagerel heappush+165
	DD	imagerel $unwind$heappush
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$heappush DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0BN@OEOCFJLB@heap?5argument?5must?5be?5a?5list?$AA@
CONST	SEGMENT
??_C@_0BN@OEOCFJLB@heap?5argument?5must?5be?5a?5list?$AA@ DB 'heap argume'
	DB	'nt must be a list', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT heappush
_TEXT	SEGMENT
self$ = 64
args$ = 72
heap$ = 80
item$ = 88
heappush PROC						; COMDAT

; 128  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 8b c2	 mov	 rax, rdx

; 129  :     PyObject *heap, *item;
; 130  : 
; 131  :     if (!PyArg_UnpackTuple(args, "heappush", 2, 2, &heap, &item))

  00007	48 8d 4c 24 58	 lea	 rcx, QWORD PTR item$[rsp]
  0000c	41 b9 02 00 00
	00		 mov	 r9d, 2
  00012	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00017	48 8d 4c 24 50	 lea	 rcx, QWORD PTR heap$[rsp]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08BOAFKLGF@heappush?$AA@
  00023	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00028	48 8b c8	 mov	 rcx, rax
  0002b	45 8b c1	 mov	 r8d, r9d
  0002e	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00033	85 c0		 test	 eax, eax

; 132  :         return NULL;

  00035	74 28		 je	 SHORT $LN7@heappush

; 133  : 
; 134  :     if (!PyList_Check(heap)) {

  00037	48 8b 4c 24 50	 mov	 rcx, QWORD PTR heap$[rsp]
  0003c	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00040	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  0004a	75 1a		 jne	 SHORT $LN3@heappush

; 135  :         PyErr_SetString(PyExc_TypeError, "heap argument must be a list");

  0004c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OEOCFJLB@heap?5argument?5must?5be?5a?5list?$AA@
  0005a	e8 00 00 00 00	 call	 PyErr_SetString
$LN7@heappush:

; 136  :         return NULL;

  0005f	33 c0		 xor	 eax, eax

; 146  : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
$LN3@heappush:

; 137  :     }
; 138  : 
; 139  :     if (PyList_Append(heap, item) == -1)

  00066	48 8b 54 24 58	 mov	 rdx, QWORD PTR item$[rsp]
  0006b	e8 00 00 00 00	 call	 PyList_Append
  00070	83 f8 ff	 cmp	 eax, -1

; 140  :         return NULL;

  00073	74 ea		 je	 SHORT $LN7@heappush

; 141  : 
; 142  :     if (_siftdown((PyListObject *)heap, 0, PyList_GET_SIZE(heap)-1) == -1)

  00075	48 8b 4c 24 50	 mov	 rcx, QWORD PTR heap$[rsp]
  0007a	33 d2		 xor	 edx, edx
  0007c	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  00080	49 ff c8	 dec	 r8
  00083	e8 00 00 00 00	 call	 _siftdown
  00088	83 f8 ff	 cmp	 eax, -1

; 143  :         return NULL;

  0008b	74 d2		 je	 SHORT $LN7@heappush

; 144  :     Py_INCREF(Py_None);

  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00094	e8 00 00 00 00	 call	 _Py_IncRef

; 145  :     return Py_None;

  00099	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 146  : }

  000a0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a4	c3		 ret	 0
heappush ENDP
_TEXT	ENDS
EXTRN	PyList_SetSlice:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$heappop DD imagerel heappop
	DD	imagerel heappop+52
	DD	imagerel $unwind$heappop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$heappop DD imagerel heappop+52
	DD	imagerel heappop+98
	DD	imagerel $chain$0$heappop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$heappop DD imagerel heappop+98
	DD	imagerel heappop+268
	DD	imagerel $chain$4$heappop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$heappop DD 060e21H
	DD	0a740eH
	DD	083409H
	DD	095400H
	DD	imagerel heappop
	DD	imagerel heappop+52
	DD	imagerel $unwind$heappop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$heappop DD 020521H
	DD	095405H
	DD	imagerel heappop
	DD	imagerel heappop+52
	DD	imagerel $unwind$heappop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$heappop DD 020601H
	DD	060025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_heapqmodule.c
xdata	ENDS
;	COMDAT heappop
_TEXT	SEGMENT
self$ = 64
heap$ = 72
heappop	PROC						; COMDAT

; 153  : {

  00000	40 56		 push	 rsi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 154  :     PyObject *lastelt, *returnitem;
; 155  :     Py_ssize_t n;
; 156  : 
; 157  :     if (!PyList_Check(heap)) {

  00006	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0000a	48 8b f2	 mov	 rsi, rdx
  0000d	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  00017	75 1b		 jne	 SHORT $LN4@heappop

; 158  :         PyErr_SetString(PyExc_TypeError, "heap argument must be a list");

  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OEOCFJLB@heap?5argument?5must?5be?5a?5list?$AA@
  00027	e8 00 00 00 00	 call	 PyErr_SetString

; 159  :         return NULL;

  0002c	33 c0		 xor	 eax, eax

; 183  : }

  0002e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00032	5e		 pop	 rsi
  00033	c3		 ret	 0
$LN4@heappop:
  00034	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp

; 160  :     }
; 161  : 
; 162  :     /* # raises appropriate IndexError if heap is empty */
; 163  :     n = PyList_GET_SIZE(heap);

  00039	48 8b 6a 60	 mov	 rbp, QWORD PTR [rdx+96]

; 164  :     if (n == 0) {

  0003d	48 85 ed	 test	 rbp, rbp
  00040	75 20		 jne	 SHORT $LN3@heappop

; 165  :         PyErr_SetString(PyExc_IndexError, "index out of range");

  00042	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@
  00050	e8 00 00 00 00	 call	 PyErr_SetString
  00055	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 166  :         return NULL;

  0005a	33 c0		 xor	 eax, eax

; 183  : }

  0005c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00060	5e		 pop	 rsi
  00061	c3		 ret	 0
$LN3@heappop:

; 167  :     }
; 168  : 
; 169  :     lastelt = PyList_GET_ITEM(heap, n-1) ;

  00062	48 8b 42 70	 mov	 rax, QWORD PTR [rdx+112]
  00066	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0006b	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00070	48 8b 7c e8 f8	 mov	 rdi, QWORD PTR [rax+rbp*8-8]

; 170  :     Py_INCREF(lastelt);

  00075	e8 00 00 00 00	 call	 _Py_PXCTX
  0007a	85 c0		 test	 eax, eax
  0007c	75 32		 jne	 SHORT $LN8@heappop
  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0008c	4c 8b cf	 mov	 r9, rdi
  0008f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00095	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0009d	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a2	85 c0		 test	 eax, eax
  000a4	75 06		 jne	 SHORT $LN7@heappop
  000a6	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  000aa	74 04		 je	 SHORT $LN8@heappop
$LN7@heappop:
  000ac	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN8@heappop:

; 171  :     PyList_SetSlice(heap, n-1, n, NULL);

  000b0	48 8d 5d ff	 lea	 rbx, QWORD PTR [rbp-1]
  000b4	45 33 c9	 xor	 r9d, r9d
  000b7	4c 8b c5	 mov	 r8, rbp
  000ba	48 8b d3	 mov	 rdx, rbx
  000bd	48 8b ce	 mov	 rcx, rsi
  000c0	e8 00 00 00 00	 call	 PyList_SetSlice

; 172  :     n--;
; 173  : 
; 174  :     if (!n)

  000c5	48 85 db	 test	 rbx, rbx
  000c8	75 05		 jne	 SHORT $LN2@heappop

; 175  :         return lastelt;

  000ca	48 8b c7	 mov	 rax, rdi
  000cd	eb 28		 jmp	 SHORT $LN13@heappop
$LN2@heappop:

; 176  :     returnitem = PyList_GET_ITEM(heap, 0);

  000cf	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]

; 177  :     PyList_SET_ITEM(heap, 0, lastelt);
; 178  :     if (_siftup((PyListObject *)heap, 0) == -1) {

  000d3	33 d2		 xor	 edx, edx
  000d5	48 8b ce	 mov	 rcx, rsi
  000d8	48 8b 18	 mov	 rbx, QWORD PTR [rax]
  000db	48 89 38	 mov	 QWORD PTR [rax], rdi
  000de	e8 00 00 00 00	 call	 _siftup
  000e3	83 f8 ff	 cmp	 eax, -1
  000e6	75 0c		 jne	 SHORT $LN1@heappop

; 179  :         Py_DECREF(returnitem);

  000e8	48 8b cb	 mov	 rcx, rbx
  000eb	e8 00 00 00 00	 call	 _Py_DecRef

; 180  :         return NULL;

  000f0	33 c0		 xor	 eax, eax
  000f2	eb 03		 jmp	 SHORT $LN13@heappop
$LN1@heappop:

; 181  :     }
; 182  :     return returnitem;

  000f4	48 8b c3	 mov	 rax, rbx
$LN13@heappop:
  000f7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000fc	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00101	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 183  : }

  00106	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010a	5e		 pop	 rsi
  0010b	c3		 ret	 0
heappop	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$heapreplace DD imagerel heapreplace
	DD	imagerel heapreplace+144
	DD	imagerel $unwind$heapreplace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$heapreplace DD imagerel heapreplace+144
	DD	imagerel heapreplace+211
	DD	imagerel $chain$0$heapreplace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$heapreplace DD imagerel heapreplace+211
	DD	imagerel heapreplace+224
	DD	imagerel $chain$2$heapreplace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$heapreplace DD 020021H
	DD	063400H
	DD	imagerel heapreplace
	DD	imagerel heapreplace+144
	DD	imagerel $unwind$heapreplace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$heapreplace DD 020521H
	DD	063405H
	DD	imagerel heapreplace
	DD	imagerel heapreplace+144
	DD	imagerel $unwind$heapreplace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$heapreplace DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT heapreplace
_TEXT	SEGMENT
self$ = 64
args$ = 72
heap$ = 80
item$ = 88
heapreplace PROC					; COMDAT

; 190  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 8b c2	 mov	 rax, rdx

; 191  :     PyObject *heap, *item, *returnitem;
; 192  : 
; 193  :     if (!PyArg_UnpackTuple(args, "heapreplace", 2, 2, &heap, &item))

  00007	48 8d 4c 24 58	 lea	 rcx, QWORD PTR item$[rsp]
  0000c	41 b9 02 00 00
	00		 mov	 r9d, 2
  00012	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00017	48 8d 4c 24 50	 lea	 rcx, QWORD PTR heap$[rsp]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@PEOLKNFI@heapreplace?$AA@
  00023	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00028	48 8b c8	 mov	 rcx, rax
  0002b	45 8b c1	 mov	 r8d, r9d
  0002e	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00033	85 c0		 test	 eax, eax

; 194  :         return NULL;

  00035	74 28		 je	 SHORT $LN8@heapreplac

; 195  : 
; 196  :     if (!PyList_Check(heap)) {

  00037	48 8b 4c 24 50	 mov	 rcx, QWORD PTR heap$[rsp]
  0003c	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00040	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  0004a	75 1a		 jne	 SHORT $LN3@heapreplac

; 197  :         PyErr_SetString(PyExc_TypeError, "heap argument must be a list");

  0004c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OEOCFJLB@heap?5argument?5must?5be?5a?5list?$AA@
  0005a	e8 00 00 00 00	 call	 PyErr_SetString
$LN8@heapreplac:

; 198  :         return NULL;

  0005f	33 c0		 xor	 eax, eax

; 214  : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
$LN3@heapreplac:

; 199  :     }
; 200  : 
; 201  :     if (PyList_GET_SIZE(heap) < 1) {

  00066	48 83 79 60 01	 cmp	 QWORD PTR [rcx+96], 1
  0006b	7d 1a		 jge	 SHORT $LN2@heapreplac

; 202  :         PyErr_SetString(PyExc_IndexError, "index out of range");

  0006d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@
  0007b	e8 00 00 00 00	 call	 PyErr_SetString

; 203  :         return NULL;

  00080	33 c0		 xor	 eax, eax

; 214  : }

  00082	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00086	c3		 ret	 0
$LN2@heapreplac:

; 204  :     }
; 205  : 
; 206  :     returnitem = PyList_GET_ITEM(heap, 0);

  00087	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]

; 207  :     Py_INCREF(item);

  0008b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR item$[rsp]
  00090	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00095	48 8b 18	 mov	 rbx, QWORD PTR [rax]
  00098	e8 00 00 00 00	 call	 _Py_IncRef

; 208  :     PyList_SET_ITEM(heap, 0, item);

  0009d	4c 8b 5c 24 50	 mov	 r11, QWORD PTR heap$[rsp]
  000a2	49 8b 53 70	 mov	 rdx, QWORD PTR [r11+112]
  000a6	48 8b 44 24 58	 mov	 rax, QWORD PTR item$[rsp]
  000ab	48 89 02	 mov	 QWORD PTR [rdx], rax

; 209  :     if (_siftup((PyListObject *)heap, 0) == -1) {

  000ae	48 8b 4c 24 50	 mov	 rcx, QWORD PTR heap$[rsp]
  000b3	33 d2		 xor	 edx, edx
  000b5	e8 00 00 00 00	 call	 _siftup
  000ba	83 f8 ff	 cmp	 eax, -1
  000bd	75 14		 jne	 SHORT $LN1@heapreplac

; 210  :         Py_DECREF(returnitem);

  000bf	48 8b cb	 mov	 rcx, rbx
  000c2	e8 00 00 00 00	 call	 _Py_DecRef
  000c7	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 211  :         return NULL;

  000cc	33 c0		 xor	 eax, eax

; 214  : }

  000ce	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d2	c3		 ret	 0
$LN1@heapreplac:

; 212  :     }
; 213  :     return returnitem;

  000d3	48 8b c3	 mov	 rax, rbx
  000d6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 214  : }

  000db	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000df	c3		 ret	 0
heapreplace ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$heappushpop DD imagerel heappushpop
	DD	imagerel heappushpop+163
	DD	imagerel $unwind$heappushpop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$heappushpop DD imagerel heappushpop+163
	DD	imagerel heappushpop+239
	DD	imagerel $chain$0$heappushpop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$heappushpop DD imagerel heappushpop+239
	DD	imagerel heappushpop+252
	DD	imagerel $chain$2$heappushpop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$heappushpop DD 020021H
	DD	063400H
	DD	imagerel heappushpop
	DD	imagerel heappushpop+163
	DD	imagerel $unwind$heappushpop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$heappushpop DD 020521H
	DD	063405H
	DD	imagerel heappushpop
	DD	imagerel heappushpop+163
	DD	imagerel $unwind$heappushpop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$heappushpop DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT heappushpop
_TEXT	SEGMENT
self$ = 64
args$ = 72
item$ = 80
heap$ = 88
heappushpop PROC					; COMDAT

; 228  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 8b c2	 mov	 rax, rdx

; 229  :     PyObject *heap, *item, *returnitem;
; 230  :     int cmp;
; 231  : 
; 232  :     if (!PyArg_UnpackTuple(args, "heappushpop", 2, 2, &heap, &item))

  00007	48 8d 4c 24 50	 lea	 rcx, QWORD PTR item$[rsp]
  0000c	41 b9 02 00 00
	00		 mov	 r9d, 2
  00012	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00017	48 8d 4c 24 58	 lea	 rcx, QWORD PTR heap$[rsp]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@HEAOMNAP@heappushpop?$AA@
  00023	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00028	48 8b c8	 mov	 rcx, rax
  0002b	45 8b c1	 mov	 r8d, r9d
  0002e	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00033	85 c0		 test	 eax, eax

; 233  :         return NULL;

  00035	74 28		 je	 SHORT $LN10@heappushpo

; 234  : 
; 235  :     if (!PyList_Check(heap)) {

  00037	48 8b 4c 24 58	 mov	 rcx, QWORD PTR heap$[rsp]
  0003c	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00040	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  0004a	75 1a		 jne	 SHORT $LN5@heappushpo

; 236  :         PyErr_SetString(PyExc_TypeError, "heap argument must be a list");

  0004c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OEOCFJLB@heap?5argument?5must?5be?5a?5list?$AA@
  0005a	e8 00 00 00 00	 call	 PyErr_SetString
$LN10@heappushpo:

; 237  :         return NULL;

  0005f	33 c0		 xor	 eax, eax

; 261  : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
$LN5@heappushpo:

; 238  :     }
; 239  : 
; 240  :     if (PyList_GET_SIZE(heap) < 1) {

  00066	48 83 79 60 01	 cmp	 QWORD PTR [rcx+96], 1
  0006b	7d 14		 jge	 SHORT $LN4@heappushpo
$LN11@heappushpo:

; 241  :         Py_INCREF(item);

  0006d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR item$[rsp]
  00072	e8 00 00 00 00	 call	 _Py_IncRef

; 242  :         return item;

  00077	48 8b 44 24 50	 mov	 rax, QWORD PTR item$[rsp]

; 261  : }

  0007c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00080	c3		 ret	 0
$LN4@heappushpo:

; 243  :     }
; 244  : 
; 245  :     cmp = PyObject_RichCompareBool(PyList_GET_ITEM(heap, 0), item, Py_LT);

  00081	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00085	48 8b 54 24 50	 mov	 rdx, QWORD PTR item$[rsp]
  0008a	45 33 c0	 xor	 r8d, r8d
  0008d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00090	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 246  :     if (cmp == -1)

  00095	83 f8 ff	 cmp	 eax, -1

; 247  :         return NULL;

  00098	74 c5		 je	 SHORT $LN10@heappushpo

; 248  :     if (cmp == 0) {

  0009a	85 c0		 test	 eax, eax

; 249  :         Py_INCREF(item);
; 250  :         return item;

  0009c	74 cf		 je	 SHORT $LN11@heappushpo

; 251  :     }
; 252  : 
; 253  :     returnitem = PyList_GET_ITEM(heap, 0);

  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR heap$[rsp]
  000a3	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  000a8	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  000ac	48 8b 19	 mov	 rbx, QWORD PTR [rcx]

; 254  :     Py_INCREF(item);

  000af	48 8b 4c 24 50	 mov	 rcx, QWORD PTR item$[rsp]
  000b4	e8 00 00 00 00	 call	 _Py_IncRef

; 255  :     PyList_SET_ITEM(heap, 0, item);

  000b9	4c 8b 5c 24 58	 mov	 r11, QWORD PTR heap$[rsp]
  000be	48 8b 44 24 50	 mov	 rax, QWORD PTR item$[rsp]
  000c3	49 8b 53 70	 mov	 rdx, QWORD PTR [r11+112]
  000c7	48 89 02	 mov	 QWORD PTR [rdx], rax

; 256  :     if (_siftup((PyListObject *)heap, 0) == -1) {

  000ca	48 8b 4c 24 58	 mov	 rcx, QWORD PTR heap$[rsp]
  000cf	33 d2		 xor	 edx, edx
  000d1	e8 00 00 00 00	 call	 _siftup
  000d6	83 f8 ff	 cmp	 eax, -1
  000d9	75 14		 jne	 SHORT $LN1@heappushpo

; 257  :         Py_DECREF(returnitem);

  000db	48 8b cb	 mov	 rcx, rbx
  000de	e8 00 00 00 00	 call	 _Py_DecRef
  000e3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 258  :         return NULL;

  000e8	33 c0		 xor	 eax, eax

; 261  : }

  000ea	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ee	c3		 ret	 0
$LN1@heappushpo:

; 259  :     }
; 260  :     return returnitem;

  000ef	48 8b c3	 mov	 rax, rbx
  000f2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 261  : }

  000f7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fb	c3		 ret	 0
heappushpop ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$heapify DD imagerel heapify
	DD	imagerel heapify+56
	DD	imagerel $unwind$heapify
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$heapify DD imagerel heapify+56
	DD	imagerel heapify+188
	DD	imagerel $chain$0$heapify
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$heapify DD imagerel heapify+188
	DD	imagerel heapify+201
	DD	imagerel $chain$2$heapify
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$heapify DD 020021H
	DD	083400H
	DD	imagerel heapify
	DD	imagerel heapify+56
	DD	imagerel $unwind$heapify
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$heapify DD 020521H
	DD	083405H
	DD	imagerel heapify
	DD	imagerel heapify+56
	DD	imagerel $unwind$heapify
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$heapify DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_heapqmodule.c
xdata	ENDS
;	COMDAT heapify
_TEXT	SEGMENT
self$ = 64
heap$ = 72
heapify	PROC						; COMDAT

; 270  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 271  :     Py_ssize_t i, n;
; 272  : 
; 273  :     if (!PyList_Check(heap)) {

  00006	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  00017	75 1b		 jne	 SHORT $LN5@heapify

; 274  :         PyErr_SetString(PyExc_TypeError, "heap argument must be a list");

  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OEOCFJLB@heap?5argument?5must?5be?5a?5list?$AA@
  00027	e8 00 00 00 00	 call	 PyErr_SetString

; 275  :         return NULL;

  0002c	33 c0		 xor	 eax, eax

; 291  : }

  0002e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00032	5f		 pop	 rdi
  00033	c3		 ret	 0
$LN5@heapify:

; 276  :     }
; 277  : 
; 278  :     n = PyList_GET_SIZE(heap);
; 279  :     /* Transform bottom-up.  The largest index there's any point to
; 280  :        looking at is the largest with a child index in-range, so must
; 281  :        have 2*i + 1 < n, or i < (n-1)/2.  If n is even = 2*j, this is
; 282  :        (2*j-1)/2 = j-1/2 so j-1 is the largest, which is n//2 - 1.  If
; 283  :        n is odd = 2*j+1, this is (2*j+1-1)/2 = j so j-1 is the largest,
; 284  :        and that's again n//2-1.
; 285  :     */
; 286  :     for (i=n/2-1 ; i>=0 ; i--)

  00034	48 8b 42 60	 mov	 rax, QWORD PTR [rdx+96]
  00038	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0003d	48 99		 cdq
  0003f	48 2b c2	 sub	 rax, rdx
  00042	48 d1 f8	 sar	 rax, 1
  00045	48 8b d8	 mov	 rbx, rax
  00048	48 ff cb	 dec	 rbx
  0004b	78 18		 js	 SHORT $LN2@heapify
  0004d	0f 1f 00	 npad	 3
$LL4@heapify:

; 287  :         if(_siftup((PyListObject *)heap, i) == -1)

  00050	48 8b d3	 mov	 rdx, rbx
  00053	48 8b cf	 mov	 rcx, rdi
  00056	e8 00 00 00 00	 call	 _siftup
  0005b	83 f8 ff	 cmp	 eax, -1
  0005e	74 5c		 je	 SHORT $LN13@heapify

; 276  :     }
; 277  : 
; 278  :     n = PyList_GET_SIZE(heap);
; 279  :     /* Transform bottom-up.  The largest index there's any point to
; 280  :        looking at is the largest with a child index in-range, so must
; 281  :        have 2*i + 1 < n, or i < (n-1)/2.  If n is even = 2*j, this is
; 282  :        (2*j-1)/2 = j-1/2 so j-1 is the largest, which is n//2 - 1.  If
; 283  :        n is odd = 2*j+1, this is (2*j+1-1)/2 = j so j-1 is the largest,
; 284  :        and that's again n//2-1.
; 285  :     */
; 286  :     for (i=n/2-1 ; i>=0 ; i--)

  00060	48 ff cb	 dec	 rbx
  00063	79 eb		 jns	 SHORT $LL4@heapify
$LN2@heapify:

; 289  :     Py_INCREF(Py_None);

  00065	e8 00 00 00 00	 call	 _Py_PXCTX
  0006a	85 c0		 test	 eax, eax
  0006c	75 3c		 jne	 SHORT $LN9@heapify
  0006e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00083	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00089	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00091	e8 00 00 00 00	 call	 _PyParallel_Guard
  00096	85 c0		 test	 eax, eax
  00098	75 09		 jne	 SHORT $LN8@heapify
  0009a	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000a1	74 07		 je	 SHORT $LN9@heapify
$LN8@heapify:
  000a3	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN9@heapify:

; 290  :     return Py_None;

  000aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000b1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 291  : }

  000b6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
$LN13@heapify:

; 288  :             return NULL;

  000bc	33 c0		 xor	 eax, eax
  000be	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 291  : }

  000c3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c7	5f		 pop	 rdi
  000c8	c3		 ret	 0
heapify	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@DNOILLJA@nO?3nlargest?$AA@		; `string'
EXTRN	PyList_Reverse:PROC
EXTRN	PyList_Sort:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyIter_Next:PROC
EXTRN	PyList_New:PROC
EXTRN	PyObject_GetIter:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$nlargest DD imagerel nlargest
	DD	imagerel nlargest+45
	DD	imagerel $unwind$nlargest
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$nlargest DD imagerel nlargest+45
	DD	imagerel nlargest+73
	DD	imagerel $chain$0$nlargest
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$nlargest DD imagerel nlargest+73
	DD	imagerel nlargest+870
	DD	imagerel $chain$5$nlargest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$nlargest DD 081121H
	DD	067411H
	DD	07640cH
	DD	0a3405H
	DD	085400H
	DD	imagerel nlargest
	DD	imagerel nlargest+45
	DD	imagerel $unwind$nlargest
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$nlargest DD 020521H
	DD	085405H
	DD	imagerel nlargest
	DD	imagerel nlargest+45
	DD	imagerel $unwind$nlargest
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nlargest DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_0M@DNOILLJA@nO?3nlargest?$AA@
CONST	SEGMENT
??_C@_0M@DNOILLJA@nO?3nlargest?$AA@ DB 'nO:nlargest', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_heapqmodule.c
CONST	ENDS
;	COMDAT nlargest
_TEXT	SEGMENT
self$ = 80
args$ = 88
n$ = 96
iterable$ = 104
nlargest PROC						; COMDAT

; 298  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 299  :     PyObject *heap=NULL, *elem, *iterable, *sol, *it, *oldelem;
; 300  :     Py_ssize_t i, n;
; 301  :     int cmp;
; 302  : 
; 303  :     if (!PyArg_ParseTuple(args, "nO:nlargest", &n, &iterable))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 4c 24 68	 lea	 r9, QWORD PTR iterable$[rsp]
  0000c	4c 8d 44 24 60	 lea	 r8, QWORD PTR n$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@DNOILLJA@nO?3nlargest?$AA@
  00018	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN29@nlargest

; 304  :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 372  : }

  00023	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00027	c3		 ret	 0
$LN29@nlargest:

; 305  : 
; 306  :     it = PyObject_GetIter(iterable);

  00028	48 8b 4c 24 68	 mov	 rcx, QWORD PTR iterable$[rsp]
  0002d	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00032	e8 00 00 00 00	 call	 PyObject_GetIter
  00037	48 8b e8	 mov	 rbp, rax

; 307  :     if (it == NULL)

  0003a	48 85 c0	 test	 rax, rax
  0003d	75 0a		 jne	 SHORT $LN28@nlargest
  0003f	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 372  : }

  00044	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00048	c3		 ret	 0
$LN28@nlargest:
  00049	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx

; 308  :         return NULL;
; 309  : 
; 310  :     heap = PyList_New(0);

  0004e	33 c9		 xor	 ecx, ecx
  00050	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00055	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0005a	e8 00 00 00 00	 call	 PyList_New
  0005f	48 8b f0	 mov	 rsi, rax

; 311  :     if (heap == NULL)

  00062	48 85 c0	 test	 rax, rax
  00065	0f 84 11 02 00
	00		 je	 $fail$20411

; 312  :         goto fail;
; 313  : 
; 314  :     for (i=0 ; i<n ; i++ ){

  0006b	48 8b 44 24 60	 mov	 rax, QWORD PTR n$[rsp]
  00070	33 ff		 xor	 edi, edi
  00072	48 85 c0	 test	 rax, rax
  00075	7e 3d		 jle	 SHORT $LN24@nlargest
$LL26@nlargest:

; 315  :         elem = PyIter_Next(it);

  00077	48 8b cd	 mov	 rcx, rbp
  0007a	e8 00 00 00 00	 call	 PyIter_Next
  0007f	48 8b d8	 mov	 rbx, rax

; 316  :         if (elem == NULL) {

  00082	48 85 c0	 test	 rax, rax
  00085	0f 84 b5 01 00
	00		 je	 $LN84@nlargest

; 317  :             if (PyErr_Occurred())
; 318  :                 goto fail;
; 319  :             else
; 320  :                 goto sortit;
; 321  :         }
; 322  :         if (PyList_Append(heap, elem) == -1) {

  0008b	48 8b d0	 mov	 rdx, rax
  0008e	48 8b ce	 mov	 rcx, rsi
  00091	e8 00 00 00 00	 call	 PyList_Append

; 323  :             Py_DECREF(elem);
; 324  :             goto fail;
; 325  :         }
; 326  :         Py_DECREF(elem);

  00096	48 8b cb	 mov	 rcx, rbx
  00099	83 f8 ff	 cmp	 eax, -1
  0009c	0f 84 d5 01 00
	00		 je	 $LN82@nlargest
  000a2	e8 00 00 00 00	 call	 _Py_DecRef
  000a7	48 8b 44 24 60	 mov	 rax, QWORD PTR n$[rsp]
  000ac	48 ff c7	 inc	 rdi
  000af	48 3b f8	 cmp	 rdi, rax
  000b2	7c c3		 jl	 SHORT $LL26@nlargest
$LN24@nlargest:

; 327  :     }
; 328  :     if (PyList_GET_SIZE(heap) == 0)

  000b4	48 83 7e 60 00	 cmp	 QWORD PTR [rsi+96], 0
  000b9	0f 84 8b 01 00
	00		 je	 $sortit$20419

; 329  :         goto sortit;
; 330  : 
; 331  :     for (i=n/2-1 ; i>=0 ; i--)

  000bf	48 99		 cdq
  000c1	48 2b c2	 sub	 rax, rdx
  000c4	48 d1 f8	 sar	 rax, 1
  000c7	48 8b d8	 mov	 rbx, rax
  000ca	48 ff cb	 dec	 rbx
  000cd	78 1a		 js	 SHORT $LN16@nlargest
  000cf	90		 npad	 1
$LL18@nlargest:

; 332  :         if(_siftup((PyListObject *)heap, i) == -1)

  000d0	48 8b d3	 mov	 rdx, rbx
  000d3	48 8b ce	 mov	 rcx, rsi
  000d6	e8 00 00 00 00	 call	 _siftup
  000db	83 f8 ff	 cmp	 eax, -1
  000de	0f 84 98 01 00
	00		 je	 $fail$20411

; 329  :         goto sortit;
; 330  : 
; 331  :     for (i=n/2-1 ; i>=0 ; i--)

  000e4	48 ff cb	 dec	 rbx
  000e7	79 e7		 jns	 SHORT $LL18@nlargest
$LN16@nlargest:

; 333  :             goto fail;
; 334  : 
; 335  :     sol = PyList_GET_ITEM(heap, 0);

  000e9	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]

; 336  :     while (1) {
; 337  :         elem = PyIter_Next(it);

  000ed	48 8b cd	 mov	 rcx, rbp
  000f0	48 8b 38	 mov	 rdi, QWORD PTR [rax]
  000f3	e8 00 00 00 00	 call	 PyIter_Next
  000f8	48 8b d8	 mov	 rbx, rax

; 338  :         if (elem == NULL) {

  000fb	48 85 c0	 test	 rax, rax
  000fe	0f 84 3c 01 00
	00		 je	 $LN84@nlargest
  00104	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL14@nlargest:

; 340  :                 goto fail;
; 341  :             else
; 342  :                 goto sortit;
; 343  :         }
; 344  :         cmp = PyObject_RichCompareBool(sol, elem, Py_LT);

  00110	45 33 c0	 xor	 r8d, r8d
  00113	48 8b d3	 mov	 rdx, rbx
  00116	48 8b cf	 mov	 rcx, rdi
  00119	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 345  :         if (cmp == -1) {

  0011e	83 f8 ff	 cmp	 eax, -1
  00121	0f 84 4d 01 00
	00		 je	 $LN85@nlargest

; 347  :             goto fail;
; 348  :         }
; 349  :         if (cmp == 0) {

  00127	85 c0		 test	 eax, eax
  00129	75 7c		 jne	 SHORT $LN8@nlargest

; 350  :             Py_DECREF(elem);

  0012b	e8 00 00 00 00	 call	 _Py_PXCTX
  00130	85 c0		 test	 eax, eax
  00132	0f 85 f4 00 00
	00		 jne	 $LN89@nlargest
  00138	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0013c	a8 20		 test	 al, 32			; 00000020H
  0013e	75 5a		 jne	 SHORT $LN36@nlargest
  00140	84 c0		 test	 al, al
  00142	78 56		 js	 SHORT $LN36@nlargest
  00144	a8 02		 test	 al, 2
  00146	0f 85 e0 00 00
	00		 jne	 $LN89@nlargest
  0014c	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00150	0f 85 d6 00 00
	00		 jne	 $LN89@nlargest
  00156	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0015d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00164	4c 8b cb	 mov	 r9, rbx
  00167	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0016d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00175	e8 00 00 00 00	 call	 _PyParallel_Guard
  0017a	48 8b cb	 mov	 rcx, rbx
  0017d	85 c0		 test	 eax, eax
  0017f	74 0a		 je	 SHORT $LN41@nlargest
  00181	e8 00 00 00 00	 call	 _Px_Dealloc
  00186	e9 a1 00 00 00	 jmp	 $LN89@nlargest
$LN41@nlargest:
  0018b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0018f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00195	e9 92 00 00 00	 jmp	 $LN89@nlargest
$LN36@nlargest:
  0019a	48 8b cb	 mov	 rcx, rbx
  0019d	e8 00 00 00 00	 call	 Px_DecRef

; 351  :             continue;

  001a2	e9 85 00 00 00	 jmp	 $LN89@nlargest
$LN8@nlargest:

; 352  :         }
; 353  :         oldelem = PyList_GET_ITEM(heap, 0);

  001a7	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  001ab	48 8b 38	 mov	 rdi, QWORD PTR [rax]

; 354  :         PyList_SET_ITEM(heap, 0, elem);

  001ae	48 89 18	 mov	 QWORD PTR [rax], rbx

; 355  :         Py_DECREF(oldelem);

  001b1	e8 00 00 00 00	 call	 _Py_PXCTX
  001b6	85 c0		 test	 eax, eax
  001b8	75 5c		 jne	 SHORT $LN53@nlargest
  001ba	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  001be	a8 20		 test	 al, 32			; 00000020H
  001c0	75 4c		 jne	 SHORT $LN47@nlargest
  001c2	84 c0		 test	 al, al
  001c4	78 48		 js	 SHORT $LN47@nlargest
  001c6	a8 02		 test	 al, 2
  001c8	75 4c		 jne	 SHORT $LN53@nlargest
  001ca	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  001ce	75 46		 jne	 SHORT $LN53@nlargest
  001d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001de	4c 8b cf	 mov	 r9, rdi
  001e1	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001e7	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001ef	e8 00 00 00 00	 call	 _PyParallel_Guard
  001f4	48 8b cf	 mov	 rcx, rdi
  001f7	85 c0		 test	 eax, eax
  001f9	74 07		 je	 SHORT $LN52@nlargest
  001fb	e8 00 00 00 00	 call	 _Px_Dealloc
  00200	eb 14		 jmp	 SHORT $LN53@nlargest
$LN52@nlargest:
  00202	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00206	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0020c	eb 08		 jmp	 SHORT $LN53@nlargest
$LN47@nlargest:
  0020e	48 8b cf	 mov	 rcx, rdi
  00211	e8 00 00 00 00	 call	 Px_DecRef
$LN53@nlargest:

; 356  :         if (_siftup((PyListObject *)heap, 0) == -1)

  00216	33 d2		 xor	 edx, edx
  00218	48 8b ce	 mov	 rcx, rsi
  0021b	e8 00 00 00 00	 call	 _siftup
  00220	83 f8 ff	 cmp	 eax, -1
  00223	74 57		 je	 SHORT $fail$20411

; 357  :             goto fail;
; 358  :         sol = PyList_GET_ITEM(heap, 0);

  00225	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  00229	48 8b 38	 mov	 rdi, QWORD PTR [rax]
$LN89@nlargest:

; 336  :     while (1) {
; 337  :         elem = PyIter_Next(it);

  0022c	48 8b cd	 mov	 rcx, rbp
  0022f	e8 00 00 00 00	 call	 PyIter_Next
  00234	48 8b d8	 mov	 rbx, rax

; 338  :         if (elem == NULL) {

  00237	48 85 c0	 test	 rax, rax
  0023a	0f 85 d0 fe ff
	ff		 jne	 $LL14@nlargest
$LN84@nlargest:

; 339  :             if (PyErr_Occurred())

  00240	e8 00 00 00 00	 call	 PyErr_Occurred
  00245	48 85 c0	 test	 rax, rax
  00248	75 32		 jne	 SHORT $fail$20411
$sortit$20419:

; 359  :     }
; 360  : sortit:
; 361  :     if (PyList_Sort(heap) == -1)

  0024a	48 8b ce	 mov	 rcx, rsi
  0024d	e8 00 00 00 00	 call	 PyList_Sort
  00252	83 f8 ff	 cmp	 eax, -1
  00255	74 25		 je	 SHORT $fail$20411

; 362  :         goto fail;
; 363  :     if (PyList_Reverse(heap) == -1)

  00257	48 8b ce	 mov	 rcx, rsi
  0025a	e8 00 00 00 00	 call	 PyList_Reverse
  0025f	83 f8 ff	 cmp	 eax, -1
  00262	74 18		 je	 SHORT $fail$20411

; 364  :         goto fail;
; 365  :     Py_DECREF(it);

  00264	48 8b cd	 mov	 rcx, rbp
  00267	e8 00 00 00 00	 call	 _Py_DecRef

; 366  :     return heap;

  0026c	48 8b c6	 mov	 rax, rsi
  0026f	e9 d9 00 00 00	 jmp	 $LN93@nlargest
$LN85@nlargest:

; 346  :             Py_DECREF(elem);

  00274	48 8b cb	 mov	 rcx, rbx
$LN82@nlargest:
  00277	e8 00 00 00 00	 call	 _Py_DecRef
$fail$20411:

; 367  : 
; 368  : fail:
; 369  :     Py_DECREF(it);

  0027c	e8 00 00 00 00	 call	 _Py_PXCTX
  00281	85 c0		 test	 eax, eax
  00283	75 5c		 jne	 SHORT $LN4@nlargest
  00285	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  00289	a8 20		 test	 al, 32			; 00000020H
  0028b	75 4c		 jne	 SHORT $LN58@nlargest
  0028d	84 c0		 test	 al, al
  0028f	78 48		 js	 SHORT $LN58@nlargest
  00291	a8 02		 test	 al, 2
  00293	75 4c		 jne	 SHORT $LN4@nlargest
  00295	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  00299	75 46		 jne	 SHORT $LN4@nlargest
  0029b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  002a9	4c 8b cd	 mov	 r9, rbp
  002ac	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  002b2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002ba	e8 00 00 00 00	 call	 _PyParallel_Guard
  002bf	48 8b cd	 mov	 rcx, rbp
  002c2	85 c0		 test	 eax, eax
  002c4	74 07		 je	 SHORT $LN63@nlargest
  002c6	e8 00 00 00 00	 call	 _Px_Dealloc
  002cb	eb 14		 jmp	 SHORT $LN4@nlargest
$LN63@nlargest:
  002cd	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  002d1	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002d7	eb 08		 jmp	 SHORT $LN4@nlargest
$LN58@nlargest:
  002d9	48 8b cd	 mov	 rcx, rbp
  002dc	e8 00 00 00 00	 call	 Px_DecRef
$LN4@nlargest:

; 370  :     Py_XDECREF(heap);

  002e1	48 85 f6	 test	 rsi, rsi
  002e4	74 65		 je	 SHORT $LN3@nlargest
  002e6	e8 00 00 00 00	 call	 _Py_PXCTX
  002eb	85 c0		 test	 eax, eax
  002ed	75 5c		 jne	 SHORT $LN3@nlargest
  002ef	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  002f3	a8 20		 test	 al, 32			; 00000020H
  002f5	75 4c		 jne	 SHORT $LN69@nlargest
  002f7	84 c0		 test	 al, al
  002f9	78 48		 js	 SHORT $LN69@nlargest
  002fb	a8 02		 test	 al, 2
  002fd	75 4c		 jne	 SHORT $LN3@nlargest
  002ff	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  00303	75 46		 jne	 SHORT $LN3@nlargest
  00305	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0030c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00313	4c 8b ce	 mov	 r9, rsi
  00316	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0031c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00324	e8 00 00 00 00	 call	 _PyParallel_Guard
  00329	48 8b ce	 mov	 rcx, rsi
  0032c	85 c0		 test	 eax, eax
  0032e	74 07		 je	 SHORT $LN74@nlargest
  00330	e8 00 00 00 00	 call	 _Px_Dealloc
  00335	eb 14		 jmp	 SHORT $LN3@nlargest
$LN74@nlargest:
  00337	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  0033b	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00341	eb 08		 jmp	 SHORT $LN3@nlargest
$LN69@nlargest:
  00343	48 8b ce	 mov	 rcx, rsi
  00346	e8 00 00 00 00	 call	 Px_DecRef
$LN3@nlargest:

; 371  :     return NULL;

  0034b	33 c0		 xor	 eax, eax
$LN93@nlargest:
  0034d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00352	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00357	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  0035c	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 372  : }

  00361	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00365	c3		 ret	 0
nlargest ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_siftdownmax DD imagerel _siftdownmax
	DD	imagerel _siftdownmax+59
	DD	imagerel $unwind$_siftdownmax
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_siftdownmax DD imagerel _siftdownmax+59
	DD	imagerel _siftdownmax+446
	DD	imagerel $chain$3$_siftdownmax
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$_siftdownmax DD imagerel _siftdownmax+446
	DD	imagerel _siftdownmax+459
	DD	imagerel $chain$5$_siftdownmax
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$_siftdownmax DD 080021H
	DD	0dd400H
	DD	0cc400H
	DD	0b7400H
	DD	0a3400H
	DD	imagerel _siftdownmax
	DD	imagerel _siftdownmax+59
	DD	imagerel $unwind$_siftdownmax
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_siftdownmax DD 085621H
	DD	0dd456H
	DD	0b7451H
	DD	0a344cH
	DD	0cc405H
	DD	imagerel _siftdownmax
	DD	imagerel _siftdownmax+59
	DD	imagerel $unwind$_siftdownmax
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_siftdownmax DD 040901H
	DD	0e0055209H
	DD	050026003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_heapqmodule.c
xdata	ENDS
;	COMDAT _siftdownmax
_TEXT	SEGMENT
heap$ = 80
startpos$ = 88
pos$ = 96
_siftdownmax PROC					; COMDAT

; 381  : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	41 56		 push	 r14
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	49 8b f0	 mov	 rsi, r8
  0000c	4c 8b f2	 mov	 r14, rdx
  0000f	48 8b e9	 mov	 rbp, rcx

; 382  :     PyObject *newitem, *parent;
; 383  :     int cmp;
; 384  :     Py_ssize_t parentpos;
; 385  : 
; 386  :     assert(PyList_Check(heap));
; 387  :     if (pos >= PyList_GET_SIZE(heap)) {

  00012	4c 3b 41 60	 cmp	 r8, QWORD PTR [rcx+96]
  00016	7c 1f		 jl	 SHORT $LN5@siftdownma

; 388  :         PyErr_SetString(PyExc_IndexError, "index out of range");

  00018	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@
  00026	e8 00 00 00 00	 call	 PyErr_SetString

; 389  :         return -1;

  0002b	83 c8 ff	 or	 eax, -1

; 414  : }

  0002e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00032	41 5e		 pop	 r14
  00034	5e		 pop	 rsi
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
$LN5@siftdownma:

; 390  :     }
; 391  : 
; 392  :     newitem = PyList_GET_ITEM(heap, pos);

  00037	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  0003b	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  00040	4e 8b 24 c0	 mov	 r12, QWORD PTR [rax+r8*8]

; 393  :     Py_INCREF(newitem);

  00044	e8 00 00 00 00	 call	 _Py_PXCTX
  00049	85 c0		 test	 eax, eax
  0004b	75 35		 jne	 SHORT $LN27@siftdownma
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0005b	4d 8b cc	 mov	 r9, r12
  0005e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00064	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0006c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00071	85 c0		 test	 eax, eax
  00073	75 08		 jne	 SHORT $LN8@siftdownma
  00075	41 f6 44 24 20
	20		 test	 BYTE PTR [r12+32], 32	; 00000020H
  0007b	74 05		 je	 SHORT $LN27@siftdownma
$LN8@siftdownma:
  0007d	49 ff 44 24 50	 inc	 QWORD PTR [r12+80]
$LN27@siftdownma:
  00082	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00087	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  0008c	4c 89 6c 24 68	 mov	 QWORD PTR [rsp+104], r13

; 394  :     /* Follow the path to the root, moving parents down until finding
; 395  :        a place newitem fits. */
; 396  :     while (pos > startpos){

  00091	49 3b f6	 cmp	 rsi, r14
  00094	0f 8e f0 00 00
	00		 jle	 $LN29@siftdownma
  0009a	66 0f 1f 44 00
	00		 npad	 6
$LL4@siftdownma:

; 397  :         parentpos = (pos - 1) >> 1;
; 398  :         parent = PyList_GET_ITEM(heap, parentpos);

  000a0	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  000a4	4c 8d 6e ff	 lea	 r13, QWORD PTR [rsi-1]

; 399  :         cmp = PyObject_RichCompareBool(parent, newitem, Py_LT);

  000a8	45 33 c0	 xor	 r8d, r8d
  000ab	49 d1 fd	 sar	 r13, 1
  000ae	49 8b d4	 mov	 rdx, r12
  000b1	4a 8b 3c e8	 mov	 rdi, QWORD PTR [rax+r13*8]
  000b5	48 8b cf	 mov	 rcx, rdi
  000b8	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 400  :         if (cmp == -1) {

  000bd	83 f8 ff	 cmp	 eax, -1
  000c0	0f 84 f8 00 00
	00		 je	 $LN28@siftdownma

; 403  :         }
; 404  :         if (cmp == 0)

  000c6	85 c0		 test	 eax, eax
  000c8	0f 84 bc 00 00
	00		 je	 $LN29@siftdownma

; 405  :             break;
; 406  :         Py_INCREF(parent);

  000ce	e8 00 00 00 00	 call	 _Py_PXCTX
  000d3	85 c0		 test	 eax, eax
  000d5	75 32		 jne	 SHORT $LN13@siftdownma
  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000e5	4c 8b cf	 mov	 r9, rdi
  000e8	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000ee	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000f6	e8 00 00 00 00	 call	 _PyParallel_Guard
  000fb	85 c0		 test	 eax, eax
  000fd	75 06		 jne	 SHORT $LN12@siftdownma
  000ff	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00103	74 04		 je	 SHORT $LN13@siftdownma
$LN12@siftdownma:
  00105	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN13@siftdownma:

; 407  :         Py_DECREF(PyList_GET_ITEM(heap, pos));

  00109	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  0010d	48 8b 1c f0	 mov	 rbx, QWORD PTR [rax+rsi*8]
  00111	e8 00 00 00 00	 call	 _Py_PXCTX
  00116	85 c0		 test	 eax, eax
  00118	75 5c		 jne	 SHORT $LN26@siftdownma
  0011a	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0011e	a8 20		 test	 al, 32			; 00000020H
  00120	75 4c		 jne	 SHORT $LN20@siftdownma
  00122	84 c0		 test	 al, al
  00124	78 48		 js	 SHORT $LN20@siftdownma
  00126	a8 02		 test	 al, 2
  00128	75 4c		 jne	 SHORT $LN26@siftdownma
  0012a	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0012e	75 46		 jne	 SHORT $LN26@siftdownma
  00130	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00137	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0013e	4c 8b cb	 mov	 r9, rbx
  00141	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00147	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0014f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00154	48 8b cb	 mov	 rcx, rbx
  00157	85 c0		 test	 eax, eax
  00159	74 07		 je	 SHORT $LN25@siftdownma
  0015b	e8 00 00 00 00	 call	 _Px_Dealloc
  00160	eb 14		 jmp	 SHORT $LN26@siftdownma
$LN25@siftdownma:
  00162	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00166	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0016c	eb 08		 jmp	 SHORT $LN26@siftdownma
$LN20@siftdownma:
  0016e	48 8b cb	 mov	 rcx, rbx
  00171	e8 00 00 00 00	 call	 Px_DecRef
$LN26@siftdownma:

; 408  :         PyList_SET_ITEM(heap, pos, parent);

  00176	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  0017a	48 89 3c f0	 mov	 QWORD PTR [rax+rsi*8], rdi

; 409  :         pos = parentpos;

  0017e	49 8b f5	 mov	 rsi, r13
  00181	4d 3b ee	 cmp	 r13, r14
  00184	0f 8f 16 ff ff
	ff		 jg	 $LL4@siftdownma
$LN29@siftdownma:

; 410  :     }
; 411  :     Py_DECREF(PyList_GET_ITEM(heap, pos));

  0018a	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  0018e	48 8b 0c f1	 mov	 rcx, QWORD PTR [rcx+rsi*8]
  00192	e8 00 00 00 00	 call	 _Py_DecRef

; 412  :     PyList_SET_ITEM(heap, pos, newitem);

  00197	4c 8b 5d 70	 mov	 r11, QWORD PTR [rbp+112]

; 413  :     return 0;

  0019b	33 c0		 xor	 eax, eax
  0019d	4d 89 24 f3	 mov	 QWORD PTR [r11+rsi*8], r12
$LN34@siftdownma:
  001a1	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001a6	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  001ab	4c 8b 6c 24 68	 mov	 r13, QWORD PTR [rsp+104]
  001b0	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]

; 414  : }

  001b5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b9	41 5e		 pop	 r14
  001bb	5e		 pop	 rsi
  001bc	5d		 pop	 rbp
  001bd	c3		 ret	 0
$LN28@siftdownma:

; 401  :             Py_DECREF(newitem);

  001be	49 8b cc	 mov	 rcx, r12
  001c1	e8 00 00 00 00	 call	 _Py_DecRef

; 402  :             return -1;

  001c6	83 c8 ff	 or	 eax, -1
  001c9	eb d6		 jmp	 SHORT $LN34@siftdownma
_siftdownmax ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_siftupmax DD imagerel _siftupmax
	DD	imagerel _siftupmax+68
	DD	imagerel $unwind$_siftupmax
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_siftupmax DD imagerel _siftupmax+68
	DD	imagerel _siftupmax+478
	DD	imagerel $chain$3$_siftupmax
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$_siftupmax DD imagerel _siftupmax+478
	DD	imagerel _siftupmax+491
	DD	imagerel $chain$5$_siftupmax
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$_siftupmax DD 080021H
	DD	06e400H
	DD	0e7400H
	DD	0d6400H
	DD	0c3400H
	DD	imagerel _siftupmax
	DD	imagerel _siftupmax+68
	DD	imagerel $unwind$_siftupmax
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_siftupmax DD 085921H
	DD	0d6459H
	DD	0c3454H
	DD	06e40aH
	DD	0e7405H
	DD	imagerel _siftupmax
	DD	imagerel _siftupmax+68
	DD	imagerel $unwind$_siftupmax
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_siftupmax DD 050c01H
	DD	0f008620cH
	DD	0c004d006H
	DD	05002H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_heapqmodule.c
xdata	ENDS
;	COMDAT _siftupmax
_TEXT	SEGMENT
heap$ = 96
pos$ = 104
_siftupmax PROC						; COMDAT

; 418  : {

  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	41 57		 push	 r15
  00008	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 419  :     Py_ssize_t startpos, endpos, childpos, rightpos;
; 420  :     int cmp;
; 421  :     PyObject *newitem, *tmp;
; 422  : 
; 423  :     assert(PyList_Check(heap));
; 424  :     endpos = PyList_GET_SIZE(heap);

  0000c	4c 8b 69 60	 mov	 r13, QWORD PTR [rcx+96]
  00010	4c 8b e2	 mov	 r12, rdx
  00013	48 8b e9	 mov	 rbp, rcx

; 425  :     startpos = pos;

  00016	4c 8b fa	 mov	 r15, rdx

; 426  :     if (pos >= endpos) {

  00019	49 3b d5	 cmp	 rdx, r13
  0001c	7c 22		 jl	 SHORT $LN6@siftupmax

; 427  :         PyErr_SetString(PyExc_IndexError, "index out of range");

  0001e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@ILOGJALA@index?5out?5of?5range?$AA@
  0002c	e8 00 00 00 00	 call	 PyErr_SetString

; 428  :         return -1;

  00031	83 c8 ff	 or	 eax, -1

; 464  : }

  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	41 5f		 pop	 r15
  0003a	41 5d		 pop	 r13
  0003c	41 5c		 pop	 r12
  0003e	5d		 pop	 rbp
  0003f	c3		 ret	 0
$LN6@siftupmax:

; 429  :     }
; 430  :     newitem = PyList_GET_ITEM(heap, pos);

  00040	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00044	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi
  00049	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  0004e	4c 8b 34 d0	 mov	 r14, QWORD PTR [rax+rdx*8]

; 431  :     Py_INCREF(newitem);

  00052	e8 00 00 00 00	 call	 _Py_PXCTX
  00057	85 c0		 test	 eax, eax
  00059	75 33		 jne	 SHORT $LN10@siftupmax
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00069	4d 8b ce	 mov	 r9, r14
  0006c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00072	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007f	85 c0		 test	 eax, eax
  00081	75 07		 jne	 SHORT $LN9@siftupmax
  00083	41 f6 46 20 20	 test	 BYTE PTR [r14+32], 32	; 00000020H
  00088	74 04		 je	 SHORT $LN10@siftupmax
$LN9@siftupmax:
  0008a	49 ff 46 50	 inc	 QWORD PTR [r14+80]
$LN10@siftupmax:

; 432  : 
; 433  :     /* Bubble up the smaller child until hitting a leaf. */
; 434  :     childpos = 2*pos + 1;    /* leftmost child position  */

  0008e	4b 8d 7c 24 01	 lea	 rdi, QWORD PTR [r12+r12+1]
  00093	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00098	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi

; 435  :     while (childpos < endpos) {

  0009d	49 3b fd	 cmp	 rdi, r13
  000a0	0f 8d f5 00 00
	00		 jge	 $LN31@siftupmax
$LL5@siftupmax:

; 436  :         /* Set childpos to index of smaller child.   */
; 437  :         rightpos = childpos + 1;

  000a6	48 8d 5f 01	 lea	 rbx, QWORD PTR [rdi+1]

; 438  :         if (rightpos < endpos) {

  000aa	49 3b dd	 cmp	 rbx, r13
  000ad	7d 23		 jge	 SHORT $LN1@siftupmax

; 439  :             cmp = PyObject_RichCompareBool(
; 440  :                 PyList_GET_ITEM(heap, rightpos),
; 441  :                 PyList_GET_ITEM(heap, childpos),
; 442  :                 Py_LT);

  000af	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  000b3	45 33 c0	 xor	 r8d, r8d
  000b6	48 8b 14 f9	 mov	 rdx, QWORD PTR [rcx+rdi*8]
  000ba	48 8b 0c d9	 mov	 rcx, QWORD PTR [rcx+rbx*8]
  000be	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 443  :             if (cmp == -1) {

  000c3	83 f8 ff	 cmp	 eax, -1
  000c6	0f 84 12 01 00
	00		 je	 $LN29@siftupmax

; 446  :             }
; 447  :             if (cmp == 0)

  000cc	85 c0		 test	 eax, eax
  000ce	48 0f 44 fb	 cmove	 rdi, rbx
$LN1@siftupmax:

; 448  :                 childpos = rightpos;
; 449  :         }
; 450  :         /* Move the smaller child up. */
; 451  :         tmp = PyList_GET_ITEM(heap, childpos);

  000d2	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  000d6	48 8b 34 f8	 mov	 rsi, QWORD PTR [rax+rdi*8]

; 452  :         Py_INCREF(tmp);

  000da	e8 00 00 00 00	 call	 _Py_PXCTX
  000df	85 c0		 test	 eax, eax
  000e1	75 32		 jne	 SHORT $LN14@siftupmax
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000f1	4c 8b ce	 mov	 r9, rsi
  000f4	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000fa	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00102	e8 00 00 00 00	 call	 _PyParallel_Guard
  00107	85 c0		 test	 eax, eax
  00109	75 06		 jne	 SHORT $LN13@siftupmax
  0010b	f6 46 20 20	 test	 BYTE PTR [rsi+32], 32	; 00000020H
  0010f	74 04		 je	 SHORT $LN14@siftupmax
$LN13@siftupmax:
  00111	48 ff 46 50	 inc	 QWORD PTR [rsi+80]
$LN14@siftupmax:

; 453  :         Py_DECREF(PyList_GET_ITEM(heap, pos));

  00115	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  00119	4a 8b 1c e0	 mov	 rbx, QWORD PTR [rax+r12*8]
  0011d	e8 00 00 00 00	 call	 _Py_PXCTX
  00122	85 c0		 test	 eax, eax
  00124	75 5c		 jne	 SHORT $LN27@siftupmax
  00126	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0012a	a8 20		 test	 al, 32			; 00000020H
  0012c	75 4c		 jne	 SHORT $LN21@siftupmax
  0012e	84 c0		 test	 al, al
  00130	78 48		 js	 SHORT $LN21@siftupmax
  00132	a8 02		 test	 al, 2
  00134	75 4c		 jne	 SHORT $LN27@siftupmax
  00136	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0013a	75 46		 jne	 SHORT $LN27@siftupmax
  0013c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0014a	4c 8b cb	 mov	 r9, rbx
  0014d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00153	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0015b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00160	48 8b cb	 mov	 rcx, rbx
  00163	85 c0		 test	 eax, eax
  00165	74 07		 je	 SHORT $LN26@siftupmax
  00167	e8 00 00 00 00	 call	 _Px_Dealloc
  0016c	eb 14		 jmp	 SHORT $LN27@siftupmax
$LN26@siftupmax:
  0016e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00172	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00178	eb 08		 jmp	 SHORT $LN27@siftupmax
$LN21@siftupmax:
  0017a	48 8b cb	 mov	 rcx, rbx
  0017d	e8 00 00 00 00	 call	 Px_DecRef
$LN27@siftupmax:

; 454  :         PyList_SET_ITEM(heap, pos, tmp);

  00182	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  00186	4a 89 34 e0	 mov	 QWORD PTR [rax+r12*8], rsi

; 455  :         pos = childpos;

  0018a	4c 8b e7	 mov	 r12, rdi

; 456  :         childpos = 2*pos + 1;

  0018d	48 8d 7c 3f 01	 lea	 rdi, QWORD PTR [rdi+rdi+1]
  00192	49 3b fd	 cmp	 rdi, r13
  00195	0f 8c 0b ff ff
	ff		 jl	 $LL5@siftupmax
$LN31@siftupmax:

; 457  :     }
; 458  : 
; 459  :     /* The leaf at pos is empty now.  Put newitem there, and bubble
; 460  :        it up to its final resting place (by sifting its parents down). */
; 461  :     Py_DECREF(PyList_GET_ITEM(heap, pos));

  0019b	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  0019f	4a 8b 0c e1	 mov	 rcx, QWORD PTR [rcx+r12*8]
  001a3	e8 00 00 00 00	 call	 _Py_DecRef

; 462  :     PyList_SET_ITEM(heap, pos, newitem);

  001a8	4c 8b 5d 70	 mov	 r11, QWORD PTR [rbp+112]

; 463  :     return _siftdownmax(heap, startpos, pos);

  001ac	4d 8b c4	 mov	 r8, r12
  001af	49 8b d7	 mov	 rdx, r15
  001b2	48 8b cd	 mov	 rcx, rbp
  001b5	4f 89 34 e3	 mov	 QWORD PTR [r11+r12*8], r14
  001b9	e8 00 00 00 00	 call	 _siftdownmax
$LN35@siftupmax:
  001be	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  001c3	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  001c8	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
  001cd	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]

; 464  : }

  001d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001d6	41 5f		 pop	 r15
  001d8	41 5d		 pop	 r13
  001da	41 5c		 pop	 r12
  001dc	5d		 pop	 rbp
  001dd	c3		 ret	 0
$LN29@siftupmax:

; 444  :                 Py_DECREF(newitem);

  001de	49 8b ce	 mov	 rcx, r14
  001e1	e8 00 00 00 00	 call	 _Py_DecRef

; 445  :                 return -1;

  001e6	83 c8 ff	 or	 eax, -1
  001e9	eb d3		 jmp	 SHORT $LN35@siftupmax
_siftupmax ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@NOGLFFMF@nO?3nsmallest?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$nsmallest DD imagerel nsmallest
	DD	imagerel nsmallest+45
	DD	imagerel $unwind$nsmallest
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$nsmallest DD imagerel nsmallest+45
	DD	imagerel nsmallest+73
	DD	imagerel $chain$0$nsmallest
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$nsmallest DD imagerel nsmallest+73
	DD	imagerel nsmallest+857
	DD	imagerel $chain$5$nsmallest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$nsmallest DD 081121H
	DD	067411H
	DD	07640cH
	DD	0a3405H
	DD	085400H
	DD	imagerel nsmallest
	DD	imagerel nsmallest+45
	DD	imagerel $unwind$nsmallest
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$nsmallest DD 020521H
	DD	085405H
	DD	imagerel nsmallest
	DD	imagerel nsmallest+45
	DD	imagerel $unwind$nsmallest
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nsmallest DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_0N@NOGLFFMF@nO?3nsmallest?$AA@
CONST	SEGMENT
??_C@_0N@NOGLFFMF@nO?3nsmallest?$AA@ DB 'nO:nsmallest', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_heapqmodule.c
CONST	ENDS
;	COMDAT nsmallest
_TEXT	SEGMENT
self$ = 80
args$ = 88
n$ = 96
iterable$ = 104
nsmallest PROC						; COMDAT

; 468  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 469  :     PyObject *heap=NULL, *elem, *iterable, *los, *it, *oldelem;
; 470  :     Py_ssize_t i, n;
; 471  :     int cmp;
; 472  : 
; 473  :     if (!PyArg_ParseTuple(args, "nO:nsmallest", &n, &iterable))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 4c 24 68	 lea	 r9, QWORD PTR iterable$[rsp]
  0000c	4c 8d 44 24 60	 lea	 r8, QWORD PTR n$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@NOGLFFMF@nO?3nsmallest?$AA@
  00018	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN28@nsmallest

; 474  :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 543  : }

  00023	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00027	c3		 ret	 0
$LN28@nsmallest:

; 475  : 
; 476  :     it = PyObject_GetIter(iterable);

  00028	48 8b 4c 24 68	 mov	 rcx, QWORD PTR iterable$[rsp]
  0002d	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00032	e8 00 00 00 00	 call	 PyObject_GetIter
  00037	48 8b e8	 mov	 rbp, rax

; 477  :     if (it == NULL)

  0003a	48 85 c0	 test	 rax, rax
  0003d	75 0a		 jne	 SHORT $LN27@nsmallest
  0003f	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 543  : }

  00044	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00048	c3		 ret	 0
$LN27@nsmallest:
  00049	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx

; 478  :         return NULL;
; 479  : 
; 480  :     heap = PyList_New(0);

  0004e	33 c9		 xor	 ecx, ecx
  00050	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00055	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0005a	e8 00 00 00 00	 call	 PyList_New
  0005f	48 8b f0	 mov	 rsi, rax

; 481  :     if (heap == NULL)

  00062	48 85 c0	 test	 rax, rax
  00065	0f 84 04 02 00
	00		 je	 $fail$20549

; 482  :         goto fail;
; 483  : 
; 484  :     for (i=0 ; i<n ; i++ ){

  0006b	33 ff		 xor	 edi, edi
  0006d	48 39 7c 24 60	 cmp	 QWORD PTR n$[rsp], rdi
  00072	7e 3a		 jle	 SHORT $LN23@nsmallest
$LL25@nsmallest:

; 485  :         elem = PyIter_Next(it);

  00074	48 8b cd	 mov	 rcx, rbp
  00077	e8 00 00 00 00	 call	 PyIter_Next
  0007c	48 8b d8	 mov	 rbx, rax

; 486  :         if (elem == NULL) {

  0007f	48 85 c0	 test	 rax, rax
  00082	0f 84 b8 01 00
	00		 je	 $LN83@nsmallest

; 487  :             if (PyErr_Occurred())
; 488  :                 goto fail;
; 489  :             else
; 490  :                 goto sortit;
; 491  :         }
; 492  :         if (PyList_Append(heap, elem) == -1) {

  00088	48 8b d0	 mov	 rdx, rax
  0008b	48 8b ce	 mov	 rcx, rsi
  0008e	e8 00 00 00 00	 call	 PyList_Append

; 493  :             Py_DECREF(elem);
; 494  :             goto fail;
; 495  :         }
; 496  :         Py_DECREF(elem);

  00093	48 8b cb	 mov	 rcx, rbx
  00096	83 f8 ff	 cmp	 eax, -1
  00099	0f 84 cb 01 00
	00		 je	 $LN81@nsmallest
  0009f	e8 00 00 00 00	 call	 _Py_DecRef
  000a4	48 ff c7	 inc	 rdi
  000a7	48 3b 7c 24 60	 cmp	 rdi, QWORD PTR n$[rsp]
  000ac	7c c6		 jl	 SHORT $LL25@nsmallest
$LN23@nsmallest:

; 497  :     }
; 498  :     n = PyList_GET_SIZE(heap);

  000ae	48 8b 46 60	 mov	 rax, QWORD PTR [rsi+96]
  000b2	48 89 44 24 60	 mov	 QWORD PTR n$[rsp], rax

; 499  :     if (n == 0)

  000b7	48 85 c0	 test	 rax, rax
  000ba	0f 84 8a 01 00
	00		 je	 $sortit$20557

; 500  :         goto sortit;
; 501  : 
; 502  :     for (i=n/2-1 ; i>=0 ; i--)

  000c0	48 99		 cdq
  000c2	48 2b c2	 sub	 rax, rdx
  000c5	48 d1 f8	 sar	 rax, 1
  000c8	48 8b d8	 mov	 rbx, rax
  000cb	48 ff cb	 dec	 rbx
  000ce	78 19		 js	 SHORT $LN15@nsmallest
$LL17@nsmallest:

; 503  :         if(_siftupmax((PyListObject *)heap, i) == -1)

  000d0	48 8b d3	 mov	 rdx, rbx
  000d3	48 8b ce	 mov	 rcx, rsi
  000d6	e8 00 00 00 00	 call	 _siftupmax
  000db	83 f8 ff	 cmp	 eax, -1
  000de	0f 84 8b 01 00
	00		 je	 $fail$20549

; 500  :         goto sortit;
; 501  : 
; 502  :     for (i=n/2-1 ; i>=0 ; i--)

  000e4	48 ff cb	 dec	 rbx
  000e7	79 e7		 jns	 SHORT $LL17@nsmallest
$LN15@nsmallest:

; 504  :             goto fail;
; 505  : 
; 506  :     los = PyList_GET_ITEM(heap, 0);

  000e9	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]

; 507  :     while (1) {
; 508  :         elem = PyIter_Next(it);

  000ed	48 8b cd	 mov	 rcx, rbp
  000f0	48 8b 38	 mov	 rdi, QWORD PTR [rax]
  000f3	e8 00 00 00 00	 call	 PyIter_Next
  000f8	48 8b d8	 mov	 rbx, rax

; 509  :         if (elem == NULL) {

  000fb	48 85 c0	 test	 rax, rax
  000fe	0f 84 3c 01 00
	00		 je	 $LN83@nsmallest
  00104	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL13@nsmallest:

; 511  :                 goto fail;
; 512  :             else
; 513  :                 goto sortit;
; 514  :         }
; 515  :         cmp = PyObject_RichCompareBool(elem, los, Py_LT);

  00110	45 33 c0	 xor	 r8d, r8d
  00113	48 8b d7	 mov	 rdx, rdi
  00116	48 8b cb	 mov	 rcx, rbx
  00119	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 516  :         if (cmp == -1) {

  0011e	83 f8 ff	 cmp	 eax, -1
  00121	0f 84 40 01 00
	00		 je	 $LN84@nsmallest

; 518  :             goto fail;
; 519  :         }
; 520  :         if (cmp == 0) {

  00127	85 c0		 test	 eax, eax
  00129	75 7c		 jne	 SHORT $LN7@nsmallest

; 521  :             Py_DECREF(elem);

  0012b	e8 00 00 00 00	 call	 _Py_PXCTX
  00130	85 c0		 test	 eax, eax
  00132	0f 85 f4 00 00
	00		 jne	 $LN88@nsmallest
  00138	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0013c	a8 20		 test	 al, 32			; 00000020H
  0013e	75 5a		 jne	 SHORT $LN35@nsmallest
  00140	84 c0		 test	 al, al
  00142	78 56		 js	 SHORT $LN35@nsmallest
  00144	a8 02		 test	 al, 2
  00146	0f 85 e0 00 00
	00		 jne	 $LN88@nsmallest
  0014c	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00150	0f 85 d6 00 00
	00		 jne	 $LN88@nsmallest
  00156	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0015d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00164	4c 8b cb	 mov	 r9, rbx
  00167	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0016d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00175	e8 00 00 00 00	 call	 _PyParallel_Guard
  0017a	48 8b cb	 mov	 rcx, rbx
  0017d	85 c0		 test	 eax, eax
  0017f	74 0a		 je	 SHORT $LN40@nsmallest
  00181	e8 00 00 00 00	 call	 _Px_Dealloc
  00186	e9 a1 00 00 00	 jmp	 $LN88@nsmallest
$LN40@nsmallest:
  0018b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0018f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00195	e9 92 00 00 00	 jmp	 $LN88@nsmallest
$LN35@nsmallest:
  0019a	48 8b cb	 mov	 rcx, rbx
  0019d	e8 00 00 00 00	 call	 Px_DecRef

; 522  :             continue;

  001a2	e9 85 00 00 00	 jmp	 $LN88@nsmallest
$LN7@nsmallest:

; 523  :         }
; 524  : 
; 525  :         oldelem = PyList_GET_ITEM(heap, 0);

  001a7	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  001ab	48 8b 38	 mov	 rdi, QWORD PTR [rax]

; 526  :         PyList_SET_ITEM(heap, 0, elem);

  001ae	48 89 18	 mov	 QWORD PTR [rax], rbx

; 527  :         Py_DECREF(oldelem);

  001b1	e8 00 00 00 00	 call	 _Py_PXCTX
  001b6	85 c0		 test	 eax, eax
  001b8	75 5c		 jne	 SHORT $LN52@nsmallest
  001ba	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  001be	a8 20		 test	 al, 32			; 00000020H
  001c0	75 4c		 jne	 SHORT $LN46@nsmallest
  001c2	84 c0		 test	 al, al
  001c4	78 48		 js	 SHORT $LN46@nsmallest
  001c6	a8 02		 test	 al, 2
  001c8	75 4c		 jne	 SHORT $LN52@nsmallest
  001ca	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  001ce	75 46		 jne	 SHORT $LN52@nsmallest
  001d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001de	4c 8b cf	 mov	 r9, rdi
  001e1	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001e7	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001ef	e8 00 00 00 00	 call	 _PyParallel_Guard
  001f4	48 8b cf	 mov	 rcx, rdi
  001f7	85 c0		 test	 eax, eax
  001f9	74 07		 je	 SHORT $LN51@nsmallest
  001fb	e8 00 00 00 00	 call	 _Px_Dealloc
  00200	eb 14		 jmp	 SHORT $LN52@nsmallest
$LN51@nsmallest:
  00202	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00206	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0020c	eb 08		 jmp	 SHORT $LN52@nsmallest
$LN46@nsmallest:
  0020e	48 8b cf	 mov	 rcx, rdi
  00211	e8 00 00 00 00	 call	 Px_DecRef
$LN52@nsmallest:

; 528  :         if (_siftupmax((PyListObject *)heap, 0) == -1)

  00216	33 d2		 xor	 edx, edx
  00218	48 8b ce	 mov	 rcx, rsi
  0021b	e8 00 00 00 00	 call	 _siftupmax
  00220	83 f8 ff	 cmp	 eax, -1
  00223	74 4a		 je	 SHORT $fail$20549

; 529  :             goto fail;
; 530  :         los = PyList_GET_ITEM(heap, 0);

  00225	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  00229	48 8b 38	 mov	 rdi, QWORD PTR [rax]
$LN88@nsmallest:

; 507  :     while (1) {
; 508  :         elem = PyIter_Next(it);

  0022c	48 8b cd	 mov	 rcx, rbp
  0022f	e8 00 00 00 00	 call	 PyIter_Next
  00234	48 8b d8	 mov	 rbx, rax

; 509  :         if (elem == NULL) {

  00237	48 85 c0	 test	 rax, rax
  0023a	0f 85 d0 fe ff
	ff		 jne	 $LL13@nsmallest
$LN83@nsmallest:

; 510  :             if (PyErr_Occurred())

  00240	e8 00 00 00 00	 call	 PyErr_Occurred
  00245	48 85 c0	 test	 rax, rax
  00248	75 25		 jne	 SHORT $fail$20549
$sortit$20557:

; 531  :     }
; 532  : 
; 533  : sortit:
; 534  :     if (PyList_Sort(heap) == -1)

  0024a	48 8b ce	 mov	 rcx, rsi
  0024d	e8 00 00 00 00	 call	 PyList_Sort
  00252	83 f8 ff	 cmp	 eax, -1
  00255	74 18		 je	 SHORT $fail$20549

; 535  :         goto fail;
; 536  :     Py_DECREF(it);

  00257	48 8b cd	 mov	 rcx, rbp
  0025a	e8 00 00 00 00	 call	 _Py_DecRef

; 537  :     return heap;

  0025f	48 8b c6	 mov	 rax, rsi
  00262	e9 d9 00 00 00	 jmp	 $LN92@nsmallest
$LN84@nsmallest:

; 517  :             Py_DECREF(elem);

  00267	48 8b cb	 mov	 rcx, rbx
$LN81@nsmallest:
  0026a	e8 00 00 00 00	 call	 _Py_DecRef
$fail$20549:

; 538  : 
; 539  : fail:
; 540  :     Py_DECREF(it);

  0026f	e8 00 00 00 00	 call	 _Py_PXCTX
  00274	85 c0		 test	 eax, eax
  00276	75 5c		 jne	 SHORT $LN4@nsmallest
  00278	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  0027c	a8 20		 test	 al, 32			; 00000020H
  0027e	75 4c		 jne	 SHORT $LN57@nsmallest
  00280	84 c0		 test	 al, al
  00282	78 48		 js	 SHORT $LN57@nsmallest
  00284	a8 02		 test	 al, 2
  00286	75 4c		 jne	 SHORT $LN4@nsmallest
  00288	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  0028c	75 46		 jne	 SHORT $LN4@nsmallest
  0028e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00295	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0029c	4c 8b cd	 mov	 r9, rbp
  0029f	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  002a5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002ad	e8 00 00 00 00	 call	 _PyParallel_Guard
  002b2	48 8b cd	 mov	 rcx, rbp
  002b5	85 c0		 test	 eax, eax
  002b7	74 07		 je	 SHORT $LN62@nsmallest
  002b9	e8 00 00 00 00	 call	 _Px_Dealloc
  002be	eb 14		 jmp	 SHORT $LN4@nsmallest
$LN62@nsmallest:
  002c0	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  002c4	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002ca	eb 08		 jmp	 SHORT $LN4@nsmallest
$LN57@nsmallest:
  002cc	48 8b cd	 mov	 rcx, rbp
  002cf	e8 00 00 00 00	 call	 Px_DecRef
$LN4@nsmallest:

; 541  :     Py_XDECREF(heap);

  002d4	48 85 f6	 test	 rsi, rsi
  002d7	74 65		 je	 SHORT $LN3@nsmallest
  002d9	e8 00 00 00 00	 call	 _Py_PXCTX
  002de	85 c0		 test	 eax, eax
  002e0	75 5c		 jne	 SHORT $LN3@nsmallest
  002e2	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  002e6	a8 20		 test	 al, 32			; 00000020H
  002e8	75 4c		 jne	 SHORT $LN68@nsmallest
  002ea	84 c0		 test	 al, al
  002ec	78 48		 js	 SHORT $LN68@nsmallest
  002ee	a8 02		 test	 al, 2
  002f0	75 4c		 jne	 SHORT $LN3@nsmallest
  002f2	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  002f6	75 46		 jne	 SHORT $LN3@nsmallest
  002f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00306	4c 8b ce	 mov	 r9, rsi
  00309	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0030f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00317	e8 00 00 00 00	 call	 _PyParallel_Guard
  0031c	48 8b ce	 mov	 rcx, rsi
  0031f	85 c0		 test	 eax, eax
  00321	74 07		 je	 SHORT $LN73@nsmallest
  00323	e8 00 00 00 00	 call	 _Px_Dealloc
  00328	eb 14		 jmp	 SHORT $LN3@nsmallest
$LN73@nsmallest:
  0032a	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  0032e	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00334	eb 08		 jmp	 SHORT $LN3@nsmallest
$LN68@nsmallest:
  00336	48 8b ce	 mov	 rcx, rsi
  00339	e8 00 00 00 00	 call	 Px_DecRef
$LN3@nsmallest:

; 542  :     return NULL;

  0033e	33 c0		 xor	 eax, eax
$LN92@nsmallest:
  00340	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00345	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0034a	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  0034f	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 543  : }

  00354	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00358	c3		 ret	 0
nsmallest ENDP
_TEXT	ENDS
PUBLIC	??_C@_09IPOHPEOP@__about__?$AA@			; `string'
PUBLIC	PyInit__heapq
EXTRN	PyModule_AddObject:PROC
EXTRN	PyUnicode_DecodeUTF8:PROC
EXTRN	PyModule_Create2:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit__heapq DD imagerel $LN4
	DD	imagerel $LN4+111
	DD	imagerel $unwind$PyInit__heapq
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__heapq DD 042e01H
	DD	06742eH
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_09IPOHPEOP@__about__?$AA@
CONST	SEGMENT
??_C@_09IPOHPEOP@__about__?$AA@ DB '__about__', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyInit__heapq
_TEXT	SEGMENT
PyInit__heapq PROC					; COMDAT

; 708  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 709  :     PyObject *m, *about;
; 710  : 
; 711  :     m = PyModule_Create(&_heapqmodule);

  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_heapqmodule
  0000d	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00012	e8 00 00 00 00	 call	 PyModule_Create2
  00017	48 8b d8	 mov	 rbx, rax

; 712  :     if (m == NULL)

  0001a	48 85 c0	 test	 rax, rax
  0001d	75 06		 jne	 SHORT $LN1@PyInit__he

; 717  : }

  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5b		 pop	 rbx
  00024	c3		 ret	 0
$LN1@PyInit__he:

; 713  :         return NULL;
; 714  :     about = PyUnicode_DecodeUTF8(__about__, strlen(__about__), NULL);

  00025	48 83 c9 ff	 or	 rcx, -1
  00029	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0002e	33 c0		 xor	 eax, eax
  00030	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:__about__
  00037	45 33 c0	 xor	 r8d, r8d
  0003a	f2 ae		 repne scasb
  0003c	48 f7 d1	 not	 rcx
  0003f	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__about__
  0004a	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8

; 715  :     PyModule_AddObject(m, "__about__", about);

  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09IPOHPEOP@__about__?$AA@
  00056	48 8b cb	 mov	 rcx, rbx
  00059	4c 8b c0	 mov	 r8, rax
  0005c	e8 00 00 00 00	 call	 PyModule_AddObject
  00061	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 716  :     return m;

  00066	48 8b c3	 mov	 rax, rbx

; 717  : }

  00069	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006d	5b		 pop	 rbx
  0006e	c3		 ret	 0
PyInit__heapq ENDP
_TEXT	ENDS
END
