; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_04KHDNNOGM@_md5?$AA@			; `string'
PUBLIC	??_C@_03PKBIKOHH@md5?$AA@			; `string'
PUBLIC	??_C@_06ICGJLFIM@string?$AA@			; `string'
PUBLIC	??_C@_08IOOPDBIF@_md5?4md5?$AA@			; `string'
PUBLIC	??_C@_0M@NPLIJFCD@digest_size?$AA@		; `string'
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
PUBLIC	??_C@_0L@EHHMJOPG@block_size?$AA@		; `string'
PUBLIC	??_C@_06HDLLMMEJ@update?$AA@			; `string'
PUBLIC	??_C@_09NNAIGNDA@hexdigest?$AA@			; `string'
PUBLIC	??_C@_06IJPNAHC@digest?$AA@			; `string'
PUBLIC	??_C@_04COAGEIMF@copy?$AA@			; `string'
;	COMDAT ??_C@_04KHDNNOGM@_md5?$AA@
CONST	SEGMENT
??_C@_04KHDNNOGM@_md5?$AA@ DB '_md5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PKBIKOHH@md5?$AA@
CONST	SEGMENT
??_C@_03PKBIKOHH@md5?$AA@ DB 'md5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICGJLFIM@string?$AA@
CONST	SEGMENT
??_C@_06ICGJLFIM@string?$AA@ DB 'string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IOOPDBIF@_md5?4md5?$AA@
CONST	SEGMENT
??_C@_08IOOPDBIF@_md5?4md5?$AA@ DB '_md5.md5', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NPLIJFCD@digest_size?$AA@
CONST	SEGMENT
??_C@_0M@NPLIJFCD@digest_size?$AA@ DB 'digest_size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EHHMJOPG@block_size?$AA@
CONST	SEGMENT
??_C@_0L@EHHMJOPG@block_size?$AA@ DB 'block_size', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HDLLMMEJ@update?$AA@
CONST	SEGMENT
??_C@_06HDLLMMEJ@update?$AA@ DB 'update', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NNAIGNDA@hexdigest?$AA@
CONST	SEGMENT
??_C@_09NNAIGNDA@hexdigest?$AA@ DB 'hexdigest', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IJPNAHC@digest?$AA@
CONST	SEGMENT
??_C@_06IJPNAHC@digest?$AA@ DB 'digest', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04COAGEIMF@copy?$AA@
CONST	SEGMENT
??_C@_04COAGEIMF@copy?$AA@ DB 'copy', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
MD5_copy__doc__ DB 'Return a copy of the hash object.', 00H
	ORG $+6
MD5_digest__doc__ DB 'Return the digest value as a string of binary data.'
	DB	00H
	ORG $+4
MD5_hexdigest__doc__ DB 'Return the digest value as a string of hexadecim'
	DB	'al digits.', 00H
	ORG $+5
MD5_update__doc__ DB 'Update this hash object''s state with the provided '
	DB	'string.', 00H
	ORG $+6
MD5_methods DQ	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DQ	FLAT:MD5_copy
	DD	04H
	ORG $+4
	DQ	FLAT:MD5_copy__doc__
	DQ	FLAT:??_C@_06IJPNAHC@digest?$AA@
	DQ	FLAT:MD5_digest
	DD	04H
	ORG $+4
	DQ	FLAT:MD5_digest__doc__
	DQ	FLAT:??_C@_09NNAIGNDA@hexdigest?$AA@
	DQ	FLAT:MD5_hexdigest
	DD	04H
	ORG $+4
	DQ	FLAT:MD5_hexdigest__doc__
	DQ	FLAT:??_C@_06HDLLMMEJ@update?$AA@
	DQ	FLAT:MD5_update
	DD	01H
	ORG $+4
	DQ	FLAT:MD5_update__doc__
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
MD5_getseters DQ FLAT:??_C@_0L@EHHMJOPG@block_size?$AA@
	DQ	FLAT:MD5_get_block_size
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:??_C@_04MEMAJGDJ@name?$AA@
	DQ	FLAT:MD5_get_name
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0M@NPLIJFCD@digest_size?$AA@
	DQ	FLAT:md5_get_digest_size
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+32
MD5type	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_08IOOPDBIF@_md5?4md5?$AA@
	DQ	00000000000000c0H
	DQ	0000000000000000H
	DQ	FLAT:MD5_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040000H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:MD5_methods
	DQ	0000000000000000H
	DQ	FLAT:MD5_getseters
	ORG $+136
MD5_new__doc__ DB 'Return a new MD5 hash object; optionally initialized w'
	DB	'ith a string.', 00H
	ORG $+4
?kwlist@?1??MD5_new@@9@9 DQ FLAT:??_C@_06ICGJLFIM@string?$AA@ ; `MD5_new'::`2'::kwlist
	DQ	0000000000000000H
	ORG $+8
MD5_functions DQ FLAT:??_C@_03PKBIKOHH@md5?$AA@
	DQ	FLAT:MD5_new
	DD	03H
	ORG $+4
	DQ	FLAT:MD5_new__doc__
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
_md5module DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_04KHDNNOGM@_md5?$AA@
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	FLAT:MD5_functions
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\md5module.c
pdata	SEGMENT
$pdata$md5_compress DD imagerel md5_compress
	DD	imagerel md5_compress+2115
	DD	imagerel $unwind$md5_compress
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$md5_compress DD 0c2001H
	DD	0116420H
	DD	0105420H
	DD	0f3420H
	DD	0f01c7220H
	DD	0d018e01aH
	DD	07014c016H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT md5_compress
_TEXT	SEGMENT
W$ = 0
md5$ = 112
buf$ = 120
md5_compress PROC					; COMDAT

; 120  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00007	48 89 68 18	 mov	 QWORD PTR [rax+24], rbp
  0000b	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  0000f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00013	57		 push	 rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	41 57		 push	 r15
  0001c	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 121  :     MD5_INT32 i, W[16], a, b, c, d;
; 122  : 
; 123  :     assert(md5 != NULL);
; 124  :     assert(buf != NULL);
; 125  : 
; 126  :     /* copy the state into 512-bits into W[0..15] */
; 127  :     for (i = 0; i < 16; i++) {

  00020	4c 8d 0c 24	 lea	 r9, QWORD PTR W$[rsp]
  00024	4c 8d 50 9a	 lea	 r10, QWORD PTR [rax-102]
  00028	4c 8d 58 9e	 lea	 r11, QWORD PTR [rax-98]
  0002c	4c 2b ca	 sub	 r9, rdx
  0002f	4c 2b d2	 sub	 r10, rdx
  00032	4c 2b da	 sub	 r11, rdx
  00035	48 8d 58 a2	 lea	 rbx, QWORD PTR [rax-94]
  00039	4c 8d 42 02	 lea	 r8, QWORD PTR [rdx+2]
  0003d	48 8b f9	 mov	 rdi, rcx
  00040	48 2b da	 sub	 rbx, rdx
  00043	ba 04 00 00 00	 mov	 edx, 4
  00048	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL3@md5_compre:

; 128  :         LOAD32L(W[i], buf + (4*i));

  00050	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00054	41 0f b6 48 01	 movzx	 ecx, BYTE PTR [r8+1]
  00059	49 83 c0 10	 add	 r8, 16
  0005d	c1 e1 08	 shl	 ecx, 8
  00060	0b c8		 or	 ecx, eax
  00062	41 0f b6 40 ef	 movzx	 eax, BYTE PTR [r8-17]
  00067	c1 e1 08	 shl	 ecx, 8
  0006a	0b c8		 or	 ecx, eax
  0006c	41 0f b6 40 ee	 movzx	 eax, BYTE PTR [r8-18]
  00071	c1 e1 08	 shl	 ecx, 8
  00074	0b c8		 or	 ecx, eax
  00076	41 0f b6 40 f4	 movzx	 eax, BYTE PTR [r8-12]
  0007b	43 89 4c 01 ee	 mov	 DWORD PTR [r9+r8-18], ecx
  00080	41 0f b6 48 f5	 movzx	 ecx, BYTE PTR [r8-11]
  00085	c1 e1 08	 shl	 ecx, 8
  00088	0b c8		 or	 ecx, eax
  0008a	41 0f b6 40 f3	 movzx	 eax, BYTE PTR [r8-13]
  0008f	c1 e1 08	 shl	 ecx, 8
  00092	0b c8		 or	 ecx, eax
  00094	41 0f b6 40 f2	 movzx	 eax, BYTE PTR [r8-14]
  00099	c1 e1 08	 shl	 ecx, 8
  0009c	0b c8		 or	 ecx, eax
  0009e	41 0f b6 40 f8	 movzx	 eax, BYTE PTR [r8-8]
  000a3	43 89 4c 02 f0	 mov	 DWORD PTR [r10+r8-16], ecx
  000a8	41 0f b6 48 f9	 movzx	 ecx, BYTE PTR [r8-7]
  000ad	c1 e1 08	 shl	 ecx, 8
  000b0	0b c8		 or	 ecx, eax
  000b2	41 0f b6 40 f7	 movzx	 eax, BYTE PTR [r8-9]
  000b7	c1 e1 08	 shl	 ecx, 8
  000ba	0b c8		 or	 ecx, eax
  000bc	41 0f b6 40 f6	 movzx	 eax, BYTE PTR [r8-10]
  000c1	c1 e1 08	 shl	 ecx, 8
  000c4	0b c8		 or	 ecx, eax
  000c6	41 0f b6 40 fc	 movzx	 eax, BYTE PTR [r8-4]
  000cb	43 89 4c 03 f0	 mov	 DWORD PTR [r11+r8-16], ecx
  000d0	41 0f b6 48 fd	 movzx	 ecx, BYTE PTR [r8-3]
  000d5	c1 e1 08	 shl	 ecx, 8
  000d8	0b c8		 or	 ecx, eax
  000da	41 0f b6 40 fb	 movzx	 eax, BYTE PTR [r8-5]
  000df	c1 e1 08	 shl	 ecx, 8
  000e2	0b c8		 or	 ecx, eax
  000e4	41 0f b6 40 fa	 movzx	 eax, BYTE PTR [r8-6]
  000e9	c1 e1 08	 shl	 ecx, 8
  000ec	0b c8		 or	 ecx, eax
  000ee	48 ff ca	 dec	 rdx
  000f1	42 89 4c 03 f0	 mov	 DWORD PTR [rbx+r8-16], ecx
  000f6	0f 85 54 ff ff
	ff		 jne	 $LL3@md5_compre

; 129  :     }
; 130  : 
; 131  :     /* copy state */
; 132  :     a = md5->state[0];
; 133  :     b = md5->state[1];

  000fc	44 8b 4f 0c	 mov	 r9d, DWORD PTR [rdi+12]

; 134  :     c = md5->state[2];

  00100	44 8b 47 10	 mov	 r8d, DWORD PTR [rdi+16]

; 135  :     d = md5->state[3];

  00104	8b 57 14	 mov	 edx, DWORD PTR [rdi+20]

; 136  : 
; 137  :     FF(a,b,c,d,W[0],7,0xd76aa478UL)

  00107	8b 0c 24	 mov	 ecx, DWORD PTR W$[rsp]

; 138  :     FF(d,a,b,c,W[1],12,0xe8c7b756UL)
; 139  :     FF(c,d,a,b,W[2],17,0x242070dbUL)
; 140  :     FF(b,c,d,a,W[3],22,0xc1bdceeeUL)
; 141  :     FF(a,b,c,d,W[4],7,0xf57c0fafUL)
; 142  :     FF(d,a,b,c,W[5],12,0x4787c62aUL)

  0010a	44 8b 74 24 14	 mov	 r14d, DWORD PTR W$[rsp+20]

; 143  :     FF(c,d,a,b,W[6],17,0xa8304613UL)
; 144  :     FF(b,c,d,a,W[7],22,0xfd469501UL)

  0010f	8b 6c 24 1c	 mov	 ebp, DWORD PTR W$[rsp+28]

; 145  :     FF(a,b,c,d,W[8],7,0x698098d8UL)

  00113	44 8b 7c 24 20	 mov	 r15d, DWORD PTR W$[rsp+32]
  00118	8b c2		 mov	 eax, edx
  0011a	41 33 c0	 xor	 eax, r8d
  0011d	41 23 c1	 and	 eax, r9d
  00120	33 c2		 xor	 eax, edx
  00122	03 47 08	 add	 eax, DWORD PTR [rdi+8]
  00125	8d 8c 08 78 a4
	6a d7		 lea	 ecx, DWORD PTR [rax+rcx-680876936]
  0012c	41 8b c0	 mov	 eax, r8d
  0012f	41 33 c1	 xor	 eax, r9d
  00132	c1 c1 07	 rol	 ecx, 7
  00135	41 03 c9	 add	 ecx, r9d
  00138	23 c1		 and	 eax, ecx
  0013a	41 33 c0	 xor	 eax, r8d
  0013d	03 44 24 04	 add	 eax, DWORD PTR W$[rsp+4]
  00141	8d 94 10 56 b7
	c7 e8		 lea	 edx, DWORD PTR [rax+rdx-389564586]
  00148	41 8b c1	 mov	 eax, r9d
  0014b	33 c1		 xor	 eax, ecx
  0014d	c1 c2 0c	 rol	 edx, 12
  00150	03 d1		 add	 edx, ecx
  00152	23 c2		 and	 eax, edx
  00154	41 33 c1	 xor	 eax, r9d
  00157	03 44 24 08	 add	 eax, DWORD PTR W$[rsp+8]
  0015b	46 8d 84 00 db
	70 20 24	 lea	 r8d, DWORD PTR [rax+r8+606105819]
  00163	8b c2		 mov	 eax, edx
  00165	33 c1		 xor	 eax, ecx
  00167	41 c1 c8 0f	 ror	 r8d, 15
  0016b	44 03 c2	 add	 r8d, edx
  0016e	41 23 c0	 and	 eax, r8d
  00171	33 c1		 xor	 eax, ecx
  00173	03 44 24 0c	 add	 eax, DWORD PTR W$[rsp+12]
  00177	46 8d 8c 08 ee
	ce bd c1	 lea	 r9d, DWORD PTR [rax+r9-1044525330]
  0017f	8b c2		 mov	 eax, edx
  00181	41 33 c0	 xor	 eax, r8d
  00184	41 c1 c9 0a	 ror	 r9d, 10
  00188	45 03 c8	 add	 r9d, r8d
  0018b	41 23 c1	 and	 eax, r9d
  0018e	33 c2		 xor	 eax, edx
  00190	03 44 24 10	 add	 eax, DWORD PTR W$[rsp+16]
  00194	44 8d 94 08 af
	0f 7c f5	 lea	 r10d, DWORD PTR [rax+rcx-176418897]
  0019c	41 8b c0	 mov	 eax, r8d
  0019f	41 33 c1	 xor	 eax, r9d
  001a2	41 c1 c2 07	 rol	 r10d, 7
  001a6	45 03 d1	 add	 r10d, r9d
  001a9	41 23 c2	 and	 eax, r10d
  001ac	41 33 c0	 xor	 eax, r8d
  001af	41 03 c6	 add	 eax, r14d
  001b2	8d 8c 10 2a c6
	87 47		 lea	 ecx, DWORD PTR [rax+rdx+1200080426]
  001b9	41 8b c1	 mov	 eax, r9d
  001bc	41 33 c2	 xor	 eax, r10d
  001bf	c1 c1 0c	 rol	 ecx, 12
  001c2	41 03 ca	 add	 ecx, r10d
  001c5	23 c1		 and	 eax, ecx
  001c7	41 33 c1	 xor	 eax, r9d
  001ca	03 44 24 18	 add	 eax, DWORD PTR W$[rsp+24]
  001ce	42 8d 94 00 13
	46 30 a8	 lea	 edx, DWORD PTR [rax+r8-1473231341]
  001d6	8b c1		 mov	 eax, ecx
  001d8	41 33 c2	 xor	 eax, r10d
  001db	c1 ca 0f	 ror	 edx, 15
  001de	03 d1		 add	 edx, ecx
  001e0	23 c2		 and	 eax, edx
  001e2	41 33 c2	 xor	 eax, r10d
  001e5	03 c5		 add	 eax, ebp
  001e7	46 8d 84 08 01
	95 46 fd	 lea	 r8d, DWORD PTR [rax+r9-45705983]
  001ef	8b c1		 mov	 eax, ecx
  001f1	33 c2		 xor	 eax, edx
  001f3	41 c1 c8 0a	 ror	 r8d, 10
  001f7	44 03 c2	 add	 r8d, edx
  001fa	41 23 c0	 and	 eax, r8d
  001fd	33 c1		 xor	 eax, ecx
  001ff	41 03 c7	 add	 eax, r15d
  00202	46 8d 8c 10 d8
	98 80 69	 lea	 r9d, DWORD PTR [rax+r10+1770035416]

; 146  :     FF(d,a,b,c,W[9],12,0x8b44f7afUL)

  0020a	8b c2		 mov	 eax, edx
  0020c	41 c1 c1 07	 rol	 r9d, 7
  00210	45 03 c8	 add	 r9d, r8d
  00213	41 33 c0	 xor	 eax, r8d
  00216	41 23 c1	 and	 eax, r9d

; 147  :     FF(c,d,a,b,W[10],17,0xffff5bb1UL)

  00219	44 8b 64 24 28	 mov	 r12d, DWORD PTR W$[rsp+40]

; 148  :     FF(b,c,d,a,W[11],22,0x895cd7beUL)
; 149  :     FF(a,b,c,d,W[12],7,0x6b901122UL)

  0021e	8b 7c 24 30	 mov	 edi, DWORD PTR W$[rsp+48]
  00222	33 c2		 xor	 eax, edx

; 150  :     FF(d,a,b,c,W[13],12,0xfd987193UL)

  00224	44 8b 6c 24 34	 mov	 r13d, DWORD PTR W$[rsp+52]

; 151  :     FF(c,d,a,b,W[14],17,0xa679438eUL)

  00229	8b 5c 24 38	 mov	 ebx, DWORD PTR W$[rsp+56]
  0022d	03 44 24 24	 add	 eax, DWORD PTR W$[rsp+36]

; 152  :     FF(b,c,d,a,W[15],22,0x49b40821UL)

  00231	8b 74 24 3c	 mov	 esi, DWORD PTR W$[rsp+60]
  00235	44 8d 94 08 af
	f7 44 8b	 lea	 r10d, DWORD PTR [rax+rcx-1958414417]
  0023d	41 8b c0	 mov	 eax, r8d
  00240	41 33 c1	 xor	 eax, r9d
  00243	41 c1 c2 0c	 rol	 r10d, 12
  00247	45 03 d1	 add	 r10d, r9d
  0024a	41 23 c2	 and	 eax, r10d
  0024d	41 33 c0	 xor	 eax, r8d
  00250	41 03 c4	 add	 eax, r12d
  00253	8d 8c 10 b1 5b
	ff ff		 lea	 ecx, DWORD PTR [rax+rdx-42063]
  0025a	41 8b c2	 mov	 eax, r10d
  0025d	41 33 c1	 xor	 eax, r9d
  00260	c1 c9 0f	 ror	 ecx, 15
  00263	41 03 ca	 add	 ecx, r10d
  00266	23 c1		 and	 eax, ecx
  00268	41 33 c1	 xor	 eax, r9d
  0026b	03 44 24 2c	 add	 eax, DWORD PTR W$[rsp+44]
  0026f	46 8d 9c 00 be
	d7 5c 89	 lea	 r11d, DWORD PTR [rax+r8-1990404162]
  00277	41 8b c2	 mov	 eax, r10d
  0027a	33 c1		 xor	 eax, ecx
  0027c	41 c1 cb 0a	 ror	 r11d, 10
  00280	44 03 d9	 add	 r11d, ecx
  00283	41 23 c3	 and	 eax, r11d
  00286	41 33 c2	 xor	 eax, r10d
  00289	03 c7		 add	 eax, edi
  0028b	42 8d 94 08 22
	11 90 6b	 lea	 edx, DWORD PTR [rax+r9+1804603682]
  00293	8b c1		 mov	 eax, ecx
  00295	41 33 c3	 xor	 eax, r11d
  00298	c1 c2 07	 rol	 edx, 7
  0029b	41 03 d3	 add	 edx, r11d
  0029e	23 c2		 and	 eax, edx
  002a0	33 c1		 xor	 eax, ecx
  002a2	41 03 c5	 add	 eax, r13d
  002a5	46 8d 84 10 93
	71 98 fd	 lea	 r8d, DWORD PTR [rax+r10-40341101]
  002ad	41 8b c3	 mov	 eax, r11d
  002b0	33 c2		 xor	 eax, edx
  002b2	41 c1 c0 0c	 rol	 r8d, 12
  002b6	44 03 c2	 add	 r8d, edx
  002b9	41 23 c0	 and	 eax, r8d
  002bc	41 33 c3	 xor	 eax, r11d
  002bf	03 c3		 add	 eax, ebx
  002c1	44 8d 8c 08 8e
	43 79 a6	 lea	 r9d, DWORD PTR [rax+rcx-1502002290]
  002c9	41 8b c0	 mov	 eax, r8d
  002cc	33 c2		 xor	 eax, edx
  002ce	41 c1 c9 0f	 ror	 r9d, 15
  002d2	45 03 c8	 add	 r9d, r8d
  002d5	41 23 c1	 and	 eax, r9d
  002d8	33 c2		 xor	 eax, edx
  002da	03 c6		 add	 eax, esi
  002dc	42 8d 8c 18 21
	08 b4 49	 lea	 ecx, DWORD PTR [rax+r11+1236535329]

; 153  :     GG(a,b,c,d,W[1],5,0xf61e2562UL)

  002e4	41 8b c1	 mov	 eax, r9d
  002e7	c1 c9 0a	 ror	 ecx, 10
  002ea	41 03 c9	 add	 ecx, r9d
  002ed	33 c1		 xor	 eax, ecx
  002ef	41 23 c0	 and	 eax, r8d
  002f2	41 33 c1	 xor	 eax, r9d
  002f5	03 44 24 04	 add	 eax, DWORD PTR W$[rsp+4]
  002f9	8d 94 10 62 25
	1e f6		 lea	 edx, DWORD PTR [rax+rdx-165796510]

; 154  :     GG(d,a,b,c,W[6],9,0xc040b340UL)

  00300	8b c1		 mov	 eax, ecx
  00302	c1 c2 05	 rol	 edx, 5
  00305	03 d1		 add	 edx, ecx
  00307	33 c2		 xor	 eax, edx
  00309	41 23 c1	 and	 eax, r9d
  0030c	33 c1		 xor	 eax, ecx
  0030e	03 44 24 18	 add	 eax, DWORD PTR W$[rsp+24]
  00312	46 8d 84 00 40
	b3 40 c0	 lea	 r8d, DWORD PTR [rax+r8-1069501632]
  0031a	41 c1 c0 09	 rol	 r8d, 9
  0031e	44 03 c2	 add	 r8d, edx

; 155  :     GG(c,d,a,b,W[11],14,0x265e5a51UL)

  00321	41 8b c0	 mov	 eax, r8d
  00324	33 c2		 xor	 eax, edx
  00326	23 c1		 and	 eax, ecx
  00328	33 c2		 xor	 eax, edx
  0032a	03 44 24 2c	 add	 eax, DWORD PTR W$[rsp+44]
  0032e	46 8d 8c 08 51
	5a 5e 26	 lea	 r9d, DWORD PTR [rax+r9+643717713]
  00336	41 c1 c1 0e	 rol	 r9d, 14

; 156  :     GG(b,c,d,a,W[0],20,0xe9b6c7aaUL)

  0033a	41 8b c0	 mov	 eax, r8d
  0033d	45 03 c8	 add	 r9d, r8d
  00340	41 33 c1	 xor	 eax, r9d
  00343	23 c2		 and	 eax, edx
  00345	41 33 c0	 xor	 eax, r8d
  00348	03 04 24	 add	 eax, DWORD PTR W$[rsp]
  0034b	44 8d 94 08 aa
	c7 b6 e9	 lea	 r10d, DWORD PTR [rax+rcx-373897302]

; 157  :     GG(a,b,c,d,W[5],5,0xd62f105dUL)

  00353	41 8b c1	 mov	 eax, r9d
  00356	41 c1 ca 0c	 ror	 r10d, 12
  0035a	45 03 d1	 add	 r10d, r9d
  0035d	41 33 c2	 xor	 eax, r10d
  00360	41 23 c0	 and	 eax, r8d
  00363	41 33 c1	 xor	 eax, r9d
  00366	41 03 c6	 add	 eax, r14d
  00369	8d 8c 10 5d 10
	2f d6		 lea	 ecx, DWORD PTR [rax+rdx-701558691]

; 158  :     GG(d,a,b,c,W[10],9,0x02441453UL)

  00370	41 8b c2	 mov	 eax, r10d
  00373	c1 c1 05	 rol	 ecx, 5
  00376	41 03 ca	 add	 ecx, r10d
  00379	33 c1		 xor	 eax, ecx
  0037b	41 23 c1	 and	 eax, r9d
  0037e	41 33 c2	 xor	 eax, r10d
  00381	41 03 c4	 add	 eax, r12d
  00384	42 8d 94 00 53
	14 44 02	 lea	 edx, DWORD PTR [rax+r8+38016083]
  0038c	c1 c2 09	 rol	 edx, 9
  0038f	03 d1		 add	 edx, ecx

; 159  :     GG(c,d,a,b,W[15],14,0xd8a1e681UL)

  00391	8b c2		 mov	 eax, edx
  00393	33 c1		 xor	 eax, ecx
  00395	41 23 c2	 and	 eax, r10d
  00398	33 c1		 xor	 eax, ecx
  0039a	03 c6		 add	 eax, esi
  0039c	46 8d 84 08 81
	e6 a1 d8	 lea	 r8d, DWORD PTR [rax+r9-660478335]

; 160  :     GG(b,c,d,a,W[4],20,0xe7d3fbc8UL)

  003a4	8b c2		 mov	 eax, edx
  003a6	41 c1 c0 0e	 rol	 r8d, 14
  003aa	44 03 c2	 add	 r8d, edx
  003ad	41 33 c0	 xor	 eax, r8d
  003b0	23 c1		 and	 eax, ecx
  003b2	33 c2		 xor	 eax, edx
  003b4	03 44 24 10	 add	 eax, DWORD PTR W$[rsp+16]
  003b8	46 8d 8c 10 c8
	fb d3 e7	 lea	 r9d, DWORD PTR [rax+r10-405537848]

; 161  :     GG(a,b,c,d,W[9],5,0x21e1cde6UL)

  003c0	41 8b c0	 mov	 eax, r8d
  003c3	41 c1 c9 0c	 ror	 r9d, 12
  003c7	45 03 c8	 add	 r9d, r8d
  003ca	41 33 c1	 xor	 eax, r9d
  003cd	23 c2		 and	 eax, edx
  003cf	41 33 c0	 xor	 eax, r8d
  003d2	03 44 24 24	 add	 eax, DWORD PTR W$[rsp+36]
  003d6	44 8d 94 08 e6
	cd e1 21	 lea	 r10d, DWORD PTR [rax+rcx+568446438]

; 162  :     GG(d,a,b,c,W[14],9,0xc33707d6UL)

  003de	41 8b c1	 mov	 eax, r9d
  003e1	41 c1 c2 05	 rol	 r10d, 5
  003e5	45 03 d1	 add	 r10d, r9d
  003e8	41 33 c2	 xor	 eax, r10d
  003eb	41 23 c0	 and	 eax, r8d
  003ee	41 33 c1	 xor	 eax, r9d
  003f1	03 c3		 add	 eax, ebx
  003f3	8d 8c 10 d6 07
	37 c3		 lea	 ecx, DWORD PTR [rax+rdx-1019803690]
  003fa	c1 c1 09	 rol	 ecx, 9
  003fd	41 03 ca	 add	 ecx, r10d

; 163  :     GG(c,d,a,b,W[3],14,0xf4d50d87UL)

  00400	8b c1		 mov	 eax, ecx
  00402	41 33 c2	 xor	 eax, r10d
  00405	41 23 c1	 and	 eax, r9d
  00408	41 33 c2	 xor	 eax, r10d
  0040b	03 44 24 0c	 add	 eax, DWORD PTR W$[rsp+12]
  0040f	42 8d 94 00 87
	0d d5 f4	 lea	 edx, DWORD PTR [rax+r8-187363961]

; 164  :     GG(b,c,d,a,W[8],20,0x455a14edUL)

  00417	8b c1		 mov	 eax, ecx
  00419	c1 c2 0e	 rol	 edx, 14
  0041c	03 d1		 add	 edx, ecx
  0041e	33 c2		 xor	 eax, edx
  00420	41 23 c2	 and	 eax, r10d
  00423	33 c1		 xor	 eax, ecx
  00425	41 03 c7	 add	 eax, r15d
  00428	46 8d 9c 08 ed
	14 5a 45	 lea	 r11d, DWORD PTR [rax+r9+1163531501]

; 165  :     GG(a,b,c,d,W[13],5,0xa9e3e905UL)

  00430	8b c2		 mov	 eax, edx
  00432	41 c1 cb 0c	 ror	 r11d, 12
  00436	44 03 da	 add	 r11d, edx
  00439	41 33 c3	 xor	 eax, r11d
  0043c	23 c1		 and	 eax, ecx
  0043e	33 c2		 xor	 eax, edx
  00440	41 03 c5	 add	 eax, r13d
  00443	46 8d 84 10 05
	e9 e3 a9	 lea	 r8d, DWORD PTR [rax+r10-1444681467]
  0044b	41 c1 c0 05	 rol	 r8d, 5
  0044f	45 03 c3	 add	 r8d, r11d

; 166  :     GG(d,a,b,c,W[2],9,0xfcefa3f8UL)

  00452	41 8b c3	 mov	 eax, r11d
  00455	41 33 c0	 xor	 eax, r8d
  00458	23 c2		 and	 eax, edx
  0045a	41 33 c3	 xor	 eax, r11d
  0045d	03 44 24 08	 add	 eax, DWORD PTR W$[rsp+8]
  00461	44 8d 8c 08 f8
	a3 ef fc	 lea	 r9d, DWORD PTR [rax+rcx-51403784]
  00469	41 c1 c1 09	 rol	 r9d, 9
  0046d	45 03 c8	 add	 r9d, r8d

; 167  :     GG(c,d,a,b,W[7],14,0x676f02d9UL)

  00470	41 8b c1	 mov	 eax, r9d

; 168  :     GG(b,c,d,a,W[12],20,0x8d2a4c8aUL)

  00473	41 8b c9	 mov	 ecx, r9d
  00476	41 33 c0	 xor	 eax, r8d
  00479	41 23 c3	 and	 eax, r11d
  0047c	41 33 c0	 xor	 eax, r8d
  0047f	03 c5		 add	 eax, ebp
  00481	44 8d 94 10 d9
	02 6f 67	 lea	 r10d, DWORD PTR [rax+rdx+1735328473]
  00489	41 c1 c2 0e	 rol	 r10d, 14
  0048d	45 03 d1	 add	 r10d, r9d
  00490	41 33 ca	 xor	 ecx, r10d
  00493	8b c1		 mov	 eax, ecx
  00495	41 23 c0	 and	 eax, r8d
  00498	41 33 c1	 xor	 eax, r9d
  0049b	03 c7		 add	 eax, edi
  0049d	42 8d 94 18 8a
	4c 2a 8d	 lea	 edx, DWORD PTR [rax+r11-1926607734]

; 169  :     HH(a,b,c,d,W[5],4,0xfffa3942UL)
; 170  :     HH(d,a,b,c,W[8],11,0x8771f681UL)

  004a5	41 8b c2	 mov	 eax, r10d
  004a8	c1 ca 0c	 ror	 edx, 12
  004ab	41 03 d2	 add	 edx, r10d
  004ae	33 c2		 xor	 eax, edx
  004b0	33 ca		 xor	 ecx, edx
  004b2	41 03 ce	 add	 ecx, r14d
  004b5	46 8d 84 01 42
	39 fa ff	 lea	 r8d, DWORD PTR [rcx+r8-378558]
  004bd	41 c1 c0 04	 rol	 r8d, 4
  004c1	44 03 c2	 add	 r8d, edx
  004c4	41 33 c0	 xor	 eax, r8d
  004c7	41 03 c7	 add	 eax, r15d
  004ca	46 8d 8c 08 81
	f6 71 87	 lea	 r9d, DWORD PTR [rax+r9-2022574463]
  004d2	41 c1 c1 0b	 rol	 r9d, 11
  004d6	45 03 c8	 add	 r9d, r8d

; 171  :     HH(c,d,a,b,W[11],16,0x6d9d6122UL)

  004d9	41 8b c1	 mov	 eax, r9d

; 172  :     HH(b,c,d,a,W[14],23,0xfde5380cUL)

  004dc	41 8b c9	 mov	 ecx, r9d
  004df	33 c2		 xor	 eax, edx
  004e1	41 33 c0	 xor	 eax, r8d
  004e4	03 44 24 2c	 add	 eax, DWORD PTR W$[rsp+44]
  004e8	46 8d 94 10 22
	61 9d 6d	 lea	 r10d, DWORD PTR [rax+r10+1839030562]
  004f0	41 c1 c2 10	 rol	 r10d, 16
  004f4	45 03 d1	 add	 r10d, r9d
  004f7	41 33 ca	 xor	 ecx, r10d
  004fa	8b c1		 mov	 eax, ecx
  004fc	41 33 c0	 xor	 eax, r8d
  004ff	03 c3		 add	 eax, ebx
  00501	44 8d 9c 10 0c
	38 e5 fd	 lea	 r11d, DWORD PTR [rax+rdx-35309556]

; 173  :     HH(a,b,c,d,W[1],4,0xa4beea44UL)
; 174  :     HH(d,a,b,c,W[4],11,0x4bdecfa9UL)

  00509	41 8b c2	 mov	 eax, r10d
  0050c	41 c1 cb 09	 ror	 r11d, 9
  00510	45 03 da	 add	 r11d, r10d
  00513	41 33 c3	 xor	 eax, r11d
  00516	41 33 cb	 xor	 ecx, r11d
  00519	03 4c 24 04	 add	 ecx, DWORD PTR W$[rsp+4]
  0051d	42 8d 94 01 44
	ea be a4	 lea	 edx, DWORD PTR [rcx+r8-1530992060]
  00525	c1 c2 04	 rol	 edx, 4
  00528	41 03 d3	 add	 edx, r11d
  0052b	33 c2		 xor	 eax, edx
  0052d	03 44 24 10	 add	 eax, DWORD PTR W$[rsp+16]
  00531	46 8d 84 08 a9
	cf de 4b	 lea	 r8d, DWORD PTR [rax+r9+1272893353]
  00539	41 c1 c0 0b	 rol	 r8d, 11
  0053d	44 03 c2	 add	 r8d, edx

; 175  :     HH(c,d,a,b,W[7],16,0xf6bb4b60UL)

  00540	41 8b c0	 mov	 eax, r8d

; 176  :     HH(b,c,d,a,W[10],23,0xbebfbc70UL)

  00543	41 8b c8	 mov	 ecx, r8d
  00546	41 33 c3	 xor	 eax, r11d
  00549	33 c2		 xor	 eax, edx
  0054b	03 c5		 add	 eax, ebp
  0054d	46 8d 8c 10 60
	4b bb f6	 lea	 r9d, DWORD PTR [rax+r10-155497632]
  00555	41 c1 c1 10	 rol	 r9d, 16
  00559	45 03 c8	 add	 r9d, r8d
  0055c	41 33 c9	 xor	 ecx, r9d
  0055f	8b c1		 mov	 eax, ecx
  00561	33 c2		 xor	 eax, edx
  00563	41 03 c4	 add	 eax, r12d
  00566	46 8d 94 18 70
	bc bf be	 lea	 r10d, DWORD PTR [rax+r11-1094730640]
  0056e	41 c1 ca 09	 ror	 r10d, 9
  00572	45 03 d1	 add	 r10d, r9d

; 177  :     HH(a,b,c,d,W[13],4,0x289b7ec6UL)

  00575	41 33 ca	 xor	 ecx, r10d
  00578	41 03 cd	 add	 ecx, r13d

; 178  :     HH(d,a,b,c,W[0],11,0xeaa127faUL)

  0057b	41 8b c1	 mov	 eax, r9d
  0057e	41 33 c2	 xor	 eax, r10d
  00581	44 8d 9c 11 c6
	7e 9b 28	 lea	 r11d, DWORD PTR [rcx+rdx+681279174]
  00589	41 c1 c3 04	 rol	 r11d, 4
  0058d	45 03 da	 add	 r11d, r10d
  00590	41 33 c3	 xor	 eax, r11d
  00593	03 04 24	 add	 eax, DWORD PTR W$[rsp]
  00596	46 8d 84 00 fa
	27 a1 ea	 lea	 r8d, DWORD PTR [rax+r8-358537222]
  0059e	41 c1 c0 0b	 rol	 r8d, 11
  005a2	45 03 c3	 add	 r8d, r11d

; 179  :     HH(c,d,a,b,W[3],16,0xd4ef3085UL)

  005a5	41 8b c0	 mov	 eax, r8d

; 180  :     HH(b,c,d,a,W[6],23,0x04881d05UL)

  005a8	41 8b c8	 mov	 ecx, r8d
  005ab	41 33 c2	 xor	 eax, r10d
  005ae	41 33 c3	 xor	 eax, r11d
  005b1	03 44 24 0c	 add	 eax, DWORD PTR W$[rsp+12]
  005b5	46 8d 8c 08 85
	30 ef d4	 lea	 r9d, DWORD PTR [rax+r9-722521979]
  005bd	41 c1 c1 10	 rol	 r9d, 16
  005c1	45 03 c8	 add	 r9d, r8d
  005c4	41 33 c9	 xor	 ecx, r9d
  005c7	8b c1		 mov	 eax, ecx
  005c9	41 33 c3	 xor	 eax, r11d
  005cc	03 44 24 18	 add	 eax, DWORD PTR W$[rsp+24]
  005d0	42 8d 94 10 05
	1d 88 04	 lea	 edx, DWORD PTR [rax+r10+76029189]

; 181  :     HH(a,b,c,d,W[9],4,0xd9d4d039UL)
; 182  :     HH(d,a,b,c,W[12],11,0xe6db99e5UL)

  005d8	41 8b c1	 mov	 eax, r9d
  005db	c1 ca 09	 ror	 edx, 9
  005de	41 03 d1	 add	 edx, r9d
  005e1	33 c2		 xor	 eax, edx
  005e3	33 ca		 xor	 ecx, edx
  005e5	03 4c 24 24	 add	 ecx, DWORD PTR W$[rsp+36]
  005e9	46 8d 94 19 39
	d0 d4 d9	 lea	 r10d, DWORD PTR [rcx+r11-640364487]
  005f1	41 c1 c2 04	 rol	 r10d, 4
  005f5	44 03 d2	 add	 r10d, edx
  005f8	41 33 c2	 xor	 eax, r10d
  005fb	03 c7		 add	 eax, edi
  005fd	42 8d 8c 00 e5
	99 db e6	 lea	 ecx, DWORD PTR [rax+r8-421815835]
  00605	c1 c1 0b	 rol	 ecx, 11
  00608	41 03 ca	 add	 ecx, r10d

; 183  :     HH(c,d,a,b,W[15],16,0x1fa27cf8UL)

  0060b	8b c1		 mov	 eax, ecx
  0060d	33 c2		 xor	 eax, edx
  0060f	41 33 c2	 xor	 eax, r10d
  00612	03 c6		 add	 eax, esi
  00614	46 8d 84 08 f8
	7c a2 1f	 lea	 r8d, DWORD PTR [rax+r9+530742520]

; 184  :     HH(b,c,d,a,W[2],23,0xc4ac5665UL)

  0061c	8b c1		 mov	 eax, ecx
  0061e	41 c1 c0 10	 rol	 r8d, 16
  00622	44 03 c1	 add	 r8d, ecx
  00625	41 33 c0	 xor	 eax, r8d
  00628	41 33 c2	 xor	 eax, r10d
  0062b	03 44 24 08	 add	 eax, DWORD PTR W$[rsp+8]
  0062f	44 8d 8c 10 65
	56 ac c4	 lea	 r9d, DWORD PTR [rax+rdx-995338651]

; 185  :     II(a,b,c,d,W[0],6,0xf4292244UL)

  00637	8b c1		 mov	 eax, ecx
  00639	f7 d0		 not	 eax
  0063b	41 c1 c9 09	 ror	 r9d, 9
  0063f	45 03 c8	 add	 r9d, r8d
  00642	41 0b c1	 or	 eax, r9d
  00645	41 33 c0	 xor	 eax, r8d
  00648	03 04 24	 add	 eax, DWORD PTR W$[rsp]
  0064b	42 8d 94 10 44
	22 29 f4	 lea	 edx, DWORD PTR [rax+r10-198630844]

; 186  :     II(d,a,b,c,W[7],10,0x432aff97UL)

  00653	41 8b c0	 mov	 eax, r8d
  00656	f7 d0		 not	 eax
  00658	c1 c2 06	 rol	 edx, 6
  0065b	41 03 d1	 add	 edx, r9d
  0065e	0b c2		 or	 eax, edx
  00660	41 33 c1	 xor	 eax, r9d
  00663	03 c5		 add	 eax, ebp
  00665	44 8d 94 08 97
	ff 2a 43	 lea	 r10d, DWORD PTR [rax+rcx+1126891415]

; 187  :     II(c,d,a,b,W[14],15,0xab9423a7UL)

  0066d	41 8b c1	 mov	 eax, r9d
  00670	f7 d0		 not	 eax
  00672	41 c1 c2 0a	 rol	 r10d, 10
  00676	44 03 d2	 add	 r10d, edx
  00679	41 0b c2	 or	 eax, r10d
  0067c	33 c2		 xor	 eax, edx
  0067e	03 c3		 add	 eax, ebx
  00680	42 8d 8c 00 a7
	23 94 ab	 lea	 ecx, DWORD PTR [rax+r8-1416354905]

; 188  :     II(b,c,d,a,W[5],21,0xfc93a039UL)

  00688	8b c2		 mov	 eax, edx
  0068a	f7 d0		 not	 eax
  0068c	c1 c1 0f	 rol	 ecx, 15
  0068f	41 03 ca	 add	 ecx, r10d
  00692	0b c1		 or	 eax, ecx
  00694	41 33 c2	 xor	 eax, r10d
  00697	41 03 c6	 add	 eax, r14d
  0069a	46 8d 84 08 39
	a0 93 fc	 lea	 r8d, DWORD PTR [rax+r9-57434055]

; 189  :     II(a,b,c,d,W[12],6,0x655b59c3UL)

  006a2	41 8b c2	 mov	 eax, r10d
  006a5	f7 d0		 not	 eax
  006a7	41 c1 c8 0b	 ror	 r8d, 11
  006ab	44 03 c1	 add	 r8d, ecx
  006ae	41 0b c0	 or	 eax, r8d
  006b1	33 c1		 xor	 eax, ecx
  006b3	03 c7		 add	 eax, edi
  006b5	44 8d 8c 10 c3
	59 5b 65	 lea	 r9d, DWORD PTR [rax+rdx+1700485571]

; 190  :     II(d,a,b,c,W[3],10,0x8f0ccc92UL)

  006bd	8b c1		 mov	 eax, ecx
  006bf	f7 d0		 not	 eax
  006c1	41 c1 c1 06	 rol	 r9d, 6
  006c5	45 03 c8	 add	 r9d, r8d
  006c8	41 0b c1	 or	 eax, r9d
  006cb	41 33 c0	 xor	 eax, r8d
  006ce	03 44 24 0c	 add	 eax, DWORD PTR W$[rsp+12]
  006d2	42 8d 94 10 92
	cc 0c 8f	 lea	 edx, DWORD PTR [rax+r10-1894986606]

; 191  :     II(c,d,a,b,W[10],15,0xffeff47dUL)

  006da	41 8b c0	 mov	 eax, r8d
  006dd	f7 d0		 not	 eax
  006df	c1 c2 0a	 rol	 edx, 10
  006e2	41 03 d1	 add	 edx, r9d
  006e5	0b c2		 or	 eax, edx
  006e7	41 33 c1	 xor	 eax, r9d
  006ea	41 03 c4	 add	 eax, r12d
  006ed	44 8d 94 08 7d
	f4 ef ff	 lea	 r10d, DWORD PTR [rax+rcx-1051523]

; 192  :     II(b,c,d,a,W[1],21,0x85845dd1UL)

  006f5	41 8b c1	 mov	 eax, r9d
  006f8	f7 d0		 not	 eax
  006fa	41 c1 c2 0f	 rol	 r10d, 15
  006fe	44 03 d2	 add	 r10d, edx
  00701	41 0b c2	 or	 eax, r10d
  00704	33 c2		 xor	 eax, edx
  00706	03 44 24 04	 add	 eax, DWORD PTR W$[rsp+4]
  0070a	42 8d 8c 00 d1
	5d 84 85	 lea	 ecx, DWORD PTR [rax+r8-2054922799]

; 193  :     II(a,b,c,d,W[8],6,0x6fa87e4fUL)

  00712	8b c2		 mov	 eax, edx
  00714	f7 d0		 not	 eax
  00716	c1 c9 0b	 ror	 ecx, 11
  00719	41 03 ca	 add	 ecx, r10d
  0071c	0b c1		 or	 eax, ecx
  0071e	41 33 c2	 xor	 eax, r10d
  00721	41 03 c7	 add	 eax, r15d
  00724	46 8d 84 08 4f
	7e a8 6f	 lea	 r8d, DWORD PTR [rax+r9+1873313359]

; 194  :     II(d,a,b,c,W[15],10,0xfe2ce6e0UL)

  0072c	41 8b c2	 mov	 eax, r10d
  0072f	f7 d0		 not	 eax
  00731	41 c1 c0 06	 rol	 r8d, 6
  00735	44 03 c1	 add	 r8d, ecx
  00738	41 0b c0	 or	 eax, r8d
  0073b	33 c1		 xor	 eax, ecx
  0073d	03 c6		 add	 eax, esi
  0073f	44 8d 8c 10 e0
	e6 2c fe	 lea	 r9d, DWORD PTR [rax+rdx-30611744]

; 195  :     II(c,d,a,b,W[6],15,0xa3014314UL)

  00747	8b c1		 mov	 eax, ecx
  00749	f7 d0		 not	 eax
  0074b	41 c1 c1 0a	 rol	 r9d, 10
  0074f	45 03 c8	 add	 r9d, r8d
  00752	41 0b c1	 or	 eax, r9d
  00755	41 33 c0	 xor	 eax, r8d
  00758	03 44 24 18	 add	 eax, DWORD PTR W$[rsp+24]
  0075c	46 8d 9c 10 14
	43 01 a3	 lea	 r11d, DWORD PTR [rax+r10-1560198380]

; 196  :     II(b,c,d,a,W[13],21,0x4e0811a1UL)

  00764	41 8b c0	 mov	 eax, r8d
  00767	f7 d0		 not	 eax
  00769	41 c1 c3 0f	 rol	 r11d, 15
  0076d	45 03 d9	 add	 r11d, r9d
  00770	41 0b c3	 or	 eax, r11d
  00773	41 33 c1	 xor	 eax, r9d
  00776	41 03 c5	 add	 eax, r13d
  00779	44 8d 94 08 a1
	11 08 4e	 lea	 r10d, DWORD PTR [rax+rcx+1309151649]

; 197  :     II(a,b,c,d,W[4],6,0xf7537e82UL)

  00781	41 8b c1	 mov	 eax, r9d
  00784	f7 d0		 not	 eax
  00786	41 c1 ca 0b	 ror	 r10d, 11
  0078a	45 03 d3	 add	 r10d, r11d
  0078d	41 0b c2	 or	 eax, r10d
  00790	41 33 c3	 xor	 eax, r11d
  00793	03 44 24 10	 add	 eax, DWORD PTR W$[rsp+16]
  00797	46 8d 84 00 82
	7e 53 f7	 lea	 r8d, DWORD PTR [rax+r8-145523070]

; 198  :     II(d,a,b,c,W[11],10,0xbd3af235UL)

  0079f	41 8b c3	 mov	 eax, r11d
  007a2	f7 d0		 not	 eax
  007a4	41 c1 c0 06	 rol	 r8d, 6
  007a8	45 03 c2	 add	 r8d, r10d
  007ab	41 0b c0	 or	 eax, r8d
  007ae	41 33 c2	 xor	 eax, r10d
  007b1	03 44 24 2c	 add	 eax, DWORD PTR W$[rsp+44]
  007b5	42 8d 94 08 35
	f2 3a bd	 lea	 edx, DWORD PTR [rax+r9-1120210379]

; 199  :     II(c,d,a,b,W[2],15,0x2ad7d2bbUL)
; 200  :     II(b,c,d,a,W[9],21,0xeb86d391UL)
; 201  : 
; 202  :     md5->state[0] = md5->state[0] + a;

  007bd	4c 8b 4c 24 70	 mov	 r9, QWORD PTR md5$[rsp]
  007c2	c1 c2 0a	 rol	 edx, 10
  007c5	41 8b c2	 mov	 eax, r10d
  007c8	f7 d0		 not	 eax
  007ca	41 03 d0	 add	 edx, r8d
  007cd	0b c2		 or	 eax, edx
  007cf	41 33 c0	 xor	 eax, r8d
  007d2	03 44 24 08	 add	 eax, DWORD PTR W$[rsp+8]
  007d6	42 8d 8c 18 bb
	d2 d7 2a	 lea	 ecx, DWORD PTR [rax+r11+718787259]
  007de	41 8b 41 08	 mov	 eax, DWORD PTR [r9+8]

; 203  :     md5->state[1] = md5->state[1] + b;
; 204  :     md5->state[2] = md5->state[2] + c;
; 205  :     md5->state[3] = md5->state[3] + d;
; 206  : }

  007e2	4c 8d 5c 24 40	 lea	 r11, QWORD PTR [rsp+64]
  007e7	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  007eb	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  007ef	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  007f3	41 03 c0	 add	 eax, r8d
  007f6	c1 c1 0f	 rol	 ecx, 15
  007f9	41 f7 d0	 not	 r8d
  007fc	41 89 41 08	 mov	 DWORD PTR [r9+8], eax
  00800	03 ca		 add	 ecx, edx
  00802	44 0b c1	 or	 r8d, ecx
  00805	44 33 c2	 xor	 r8d, edx
  00808	44 03 44 24 24	 add	 r8d, DWORD PTR W$[rsp+36]
  0080d	43 8d 84 10 91
	d3 86 eb	 lea	 eax, DWORD PTR [r8+r10-343485551]
  00815	c1 c8 0b	 ror	 eax, 11
  00818	41 03 41 0c	 add	 eax, DWORD PTR [r9+12]
  0081c	03 c1		 add	 eax, ecx
  0081e	41 89 41 0c	 mov	 DWORD PTR [r9+12], eax
  00822	41 8b 41 10	 mov	 eax, DWORD PTR [r9+16]
  00826	03 c1		 add	 eax, ecx
  00828	41 89 41 10	 mov	 DWORD PTR [r9+16], eax
  0082c	41 8b 41 14	 mov	 eax, DWORD PTR [r9+20]
  00830	03 c2		 add	 eax, edx
  00832	41 89 41 14	 mov	 DWORD PTR [r9+20], eax
  00836	49 8b e3	 mov	 rsp, r11
  00839	41 5f		 pop	 r15
  0083b	41 5e		 pop	 r14
  0083d	41 5d		 pop	 r13
  0083f	41 5c		 pop	 r12
  00841	5f		 pop	 rdi
  00842	c3		 ret	 0
md5_compress ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT md5_init
_TEXT	SEGMENT
md5$ = 8
md5_init PROC						; COMDAT

; 216  :     assert(md5 != NULL);
; 217  :     md5->state[0] = 0x67452301UL;
; 218  :     md5->state[1] = 0xefcdab89UL;
; 219  :     md5->state[2] = 0x98badcfeUL;
; 220  :     md5->state[3] = 0x10325476UL;
; 221  :     md5->curlen = 0;

  00000	33 c0		 xor	 eax, eax
  00002	c7 41 08 01 23
	45 67		 mov	 DWORD PTR [rcx+8], 1732584193 ; 67452301H
  00009	c7 41 0c 89 ab
	cd ef		 mov	 DWORD PTR [rcx+12], -271733879 ; efcdab89H
  00010	c7 41 10 fe dc
	ba 98		 mov	 DWORD PTR [rcx+16], -1732584194 ; 98badcfeH
  00017	48 c7 41 14 76
	54 32 10	 mov	 QWORD PTR [rcx+20], 271733878 ; 10325476H

; 222  :     md5->length = 0;

  0001f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 223  : }

  00022	c3		 ret	 0
md5_init ENDP
_TEXT	ENDS
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$md5_process DD imagerel md5_process
	DD	imagerel md5_process+24
	DD	imagerel $unwind$md5_process
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$md5_process DD imagerel md5_process+24
	DD	imagerel md5_process+190
	DD	imagerel $chain$1$md5_process
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$md5_process DD imagerel md5_process+190
	DD	imagerel md5_process+192
	DD	imagerel $chain$2$md5_process
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$md5_process DD 021H
	DD	imagerel md5_process
	DD	imagerel md5_process+24
	DD	imagerel $unwind$md5_process
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$md5_process DD 041321H
	DD	063413H
	DD	07c405H
	DD	imagerel md5_process
	DD	imagerel md5_process+24
	DD	imagerel $unwind$md5_process
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$md5_process DD 061801H
	DD	096418H
	DD	085418H
	DD	070143218H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT md5_process
_TEXT	SEGMENT
md5$ = 48
in$ = 56
inlen$ = 64
md5_process PROC					; COMDAT

; 234  :     Py_ssize_t n;
; 235  : 
; 236  :     assert(md5 != NULL);
; 237  :     assert(in != NULL);
; 238  :     assert(md5->curlen <= sizeof(md5->buf));
; 239  : 
; 240  :     while (inlen > 0) {

  00000	4d 85 c0	 test	 r8, r8
  00003	0f 8e b5 00 00
	00		 jle	 $LN11@md5_proces
  00009	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000e	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00013	57		 push	 rdi
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00018	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12

; 233  : {

  0001d	49 8b f0	 mov	 rsi, r8
  00020	48 8b ea	 mov	 rbp, rdx

; 234  :     Py_ssize_t n;
; 235  : 
; 236  :     assert(md5 != NULL);
; 237  :     assert(in != NULL);
; 238  :     assert(md5->curlen <= sizeof(md5->buf));
; 239  : 
; 240  :     while (inlen > 0) {

  00023	45 33 e4	 xor	 r12d, r12d
  00026	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0002b	48 8b f9	 mov	 rdi, rcx
  0002e	66 90		 npad	 2
$LL5@md5_proces:

; 241  :         if (md5->curlen == 0 && inlen >= MD5_BLOCKSIZE) {

  00030	8b 4f 18	 mov	 ecx, DWORD PTR [rdi+24]
  00033	85 c9		 test	 ecx, ecx
  00035	75 22		 jne	 SHORT $LN3@md5_proces
  00037	48 83 fe 40	 cmp	 rsi, 64			; 00000040H
  0003b	7c 1c		 jl	 SHORT $LN3@md5_proces

; 242  :            md5_compress(md5, (unsigned char *)in);

  0003d	48 8b d5	 mov	 rdx, rbp
  00040	48 8b cf	 mov	 rcx, rdi
  00043	e8 00 00 00 00	 call	 md5_compress

; 243  :            md5->length    += MD5_BLOCKSIZE * 8;

  00048	48 81 07 00 02
	00 00		 add	 QWORD PTR [rdi], 512	; 00000200H

; 244  :            in             += MD5_BLOCKSIZE;

  0004f	48 83 c5 40	 add	 rbp, 64			; 00000040H

; 245  :            inlen          -= MD5_BLOCKSIZE;

  00053	48 83 ee 40	 sub	 rsi, 64			; 00000040H

; 246  :         } else {

  00057	eb 47		 jmp	 SHORT $LN1@md5_proces
$LN3@md5_proces:

; 247  :            n = MIN(inlen, (Py_ssize_t)(MD5_BLOCKSIZE - md5->curlen));
; 248  :            memcpy(md5->buf + md5->curlen, in, (size_t)n);

  00059	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  0005c	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H
  00061	48 8b d5	 mov	 rdx, rbp
  00064	2b d9		 sub	 ebx, ecx
  00066	48 8d 4c 38 1c	 lea	 rcx, QWORD PTR [rax+rdi+28]
  0006b	48 3b f3	 cmp	 rsi, rbx
  0006e	48 0f 4c de	 cmovl	 rbx, rsi
  00072	4c 8b c3	 mov	 r8, rbx
  00075	e8 00 00 00 00	 call	 memcpy

; 249  :            md5->curlen    += n;

  0007a	01 5f 18	 add	 DWORD PTR [rdi+24], ebx

; 250  :            in             += n;

  0007d	48 03 eb	 add	 rbp, rbx

; 251  :            inlen          -= n;

  00080	48 2b f3	 sub	 rsi, rbx

; 252  :            if (md5->curlen == MD5_BLOCKSIZE) {

  00083	83 7f 18 40	 cmp	 DWORD PTR [rdi+24], 64	; 00000040H
  00087	75 17		 jne	 SHORT $LN1@md5_proces

; 253  :               md5_compress(md5, md5->buf);

  00089	48 8d 57 1c	 lea	 rdx, QWORD PTR [rdi+28]
  0008d	48 8b cf	 mov	 rcx, rdi
  00090	e8 00 00 00 00	 call	 md5_compress

; 254  :               md5->length += 8*MD5_BLOCKSIZE;

  00095	48 81 07 00 02
	00 00		 add	 QWORD PTR [rdi], 512	; 00000200H

; 255  :               md5->curlen = 0;

  0009c	44 89 67 18	 mov	 DWORD PTR [rdi+24], r12d
$LN1@md5_proces:

; 234  :     Py_ssize_t n;
; 235  : 
; 236  :     assert(md5 != NULL);
; 237  :     assert(in != NULL);
; 238  :     assert(md5->curlen <= sizeof(md5->buf));
; 239  : 
; 240  :     while (inlen > 0) {

  000a0	48 85 f6	 test	 rsi, rsi
  000a3	7f 8b		 jg	 SHORT $LL5@md5_proces

; 256  :            }
; 257  :        }
; 258  :     }
; 259  : }

  000a5	4c 8b 64 24 38	 mov	 r12, QWORD PTR [rsp+56]
  000aa	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000af	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000b4	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bd	5f		 pop	 rdi
$LN11@md5_proces:
  000be	f3 c3		 fatret	 0
md5_process ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$md5_done DD imagerel md5_done
	DD	imagerel md5_done+341
	DD	imagerel $unwind$md5_done
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$md5_done DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT md5_done
_TEXT	SEGMENT
md5$ = 48
out$ = 56
md5_done PROC						; COMDAT

; 268  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 269  :     int i;
; 270  : 
; 271  :     assert(md5 != NULL);
; 272  :     assert(out != NULL);
; 273  :     assert(md5->curlen < sizeof(md5->buf));
; 274  : 
; 275  :     /* increase the length of the message */
; 276  :     md5->length += md5->curlen * 8;

  0000a	44 8b 49 18	 mov	 r9d, DWORD PTR [rcx+24]
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	46 8d 04 cd 00
	00 00 00	 lea	 r8d, DWORD PTR [r9*8]
  0001c	4c 01 01	 add	 QWORD PTR [rcx], r8

; 277  : 
; 278  :     /* append the '1' bit */
; 279  :     md5->buf[md5->curlen++] = (unsigned char)0x80;

  0001f	41 c6 44 09 1c
	80		 mov	 BYTE PTR [r9+rcx+28], 128 ; 00000080H
  00025	ff 41 18	 inc	 DWORD PTR [rcx+24]
  00028	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]

; 280  : 
; 281  :     /* if the length is currently above 56 bytes we append zeros
; 282  :      * then compress.  Then we can fall back to padding zeros and length
; 283  :      * encoding like normal.
; 284  :      */
; 285  :     if (md5->curlen > 56) {

  0002b	83 f8 38	 cmp	 eax, 56			; 00000038H
  0002e	76 30		 jbe	 SHORT $LN12@md5_done

; 286  :         while (md5->curlen < 64) {

  00030	83 f8 40	 cmp	 eax, 64			; 00000040H
  00033	73 1b		 jae	 SHORT $LN6@md5_done
  00035	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL7@md5_done:

; 287  :             md5->buf[md5->curlen++] = (unsigned char)0;

  00040	c6 44 08 1c 00	 mov	 BYTE PTR [rax+rcx+28], 0
  00045	ff 41 18	 inc	 DWORD PTR [rcx+24]
  00048	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  0004b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0004e	72 f0		 jb	 SHORT $LL7@md5_done
$LN6@md5_done:

; 288  :         }
; 289  :         md5_compress(md5, md5->buf);

  00050	48 8d 51 1c	 lea	 rdx, QWORD PTR [rcx+28]
  00054	e8 00 00 00 00	 call	 md5_compress

; 290  :         md5->curlen = 0;

  00059	c7 43 18 00 00
	00 00		 mov	 DWORD PTR [rbx+24], 0
$LN12@md5_done:

; 291  :     }
; 292  : 
; 293  :     /* pad upto 56 bytes of zeroes */
; 294  :     while (md5->curlen < 56) {

  00060	83 7b 18 38	 cmp	 DWORD PTR [rbx+24], 56	; 00000038H
  00064	73 1b		 jae	 SHORT $LN4@md5_done
  00066	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL5@md5_done:

; 295  :         md5->buf[md5->curlen++] = (unsigned char)0;

  00070	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  00073	c6 44 18 1c 00	 mov	 BYTE PTR [rax+rbx+28], 0
  00078	ff 43 18	 inc	 DWORD PTR [rbx+24]
  0007b	83 7b 18 38	 cmp	 DWORD PTR [rbx+24], 56	; 00000038H
  0007f	72 ef		 jb	 SHORT $LL5@md5_done
$LN4@md5_done:

; 296  :     }
; 297  : 
; 298  :     /* store length */
; 299  :     STORE64L(md5->length, md5->buf+56);

  00081	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]

; 300  :     md5_compress(md5, md5->buf);

  00084	48 8d 53 1c	 lea	 rdx, QWORD PTR [rbx+28]
  00088	48 8b c1	 mov	 rax, rcx
  0008b	48 c1 f8 38	 sar	 rax, 56			; 00000038H
  0008f	88 43 5b	 mov	 BYTE PTR [rbx+91], al
  00092	48 8b c1	 mov	 rax, rcx
  00095	48 c1 f8 30	 sar	 rax, 48			; 00000030H
  00099	88 43 5a	 mov	 BYTE PTR [rbx+90], al
  0009c	48 8b c1	 mov	 rax, rcx
  0009f	48 c1 f8 28	 sar	 rax, 40			; 00000028H
  000a3	88 43 59	 mov	 BYTE PTR [rbx+89], al
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 c1 f8 20	 sar	 rax, 32			; 00000020H
  000ad	88 43 58	 mov	 BYTE PTR [rbx+88], al
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	48 c1 f8 18	 sar	 rax, 24
  000b7	88 43 57	 mov	 BYTE PTR [rbx+87], al
  000ba	48 8b c1	 mov	 rax, rcx
  000bd	48 c1 f9 08	 sar	 rcx, 8
  000c1	48 c1 f8 10	 sar	 rax, 16
  000c5	88 4b 55	 mov	 BYTE PTR [rbx+85], cl
  000c8	48 8b cb	 mov	 rcx, rbx
  000cb	88 43 56	 mov	 BYTE PTR [rbx+86], al
  000ce	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000d1	88 43 54	 mov	 BYTE PTR [rbx+84], al
  000d4	e8 00 00 00 00	 call	 md5_compress

; 301  : 
; 302  :     /* copy output */
; 303  :     for (i = 0; i < 4; i++) {
; 304  :         STORE32L(md5->state[i], out+(4*i));

  000d9	44 0f b6 5b 0b	 movzx	 r11d, BYTE PTR [rbx+11]
  000de	44 88 5f 03	 mov	 BYTE PTR [rdi+3], r11b
  000e2	0f b6 43 0a	 movzx	 eax, BYTE PTR [rbx+10]
  000e6	88 47 02	 mov	 BYTE PTR [rdi+2], al
  000e9	0f b6 43 09	 movzx	 eax, BYTE PTR [rbx+9]
  000ed	88 47 01	 mov	 BYTE PTR [rdi+1], al
  000f0	0f b6 43 08	 movzx	 eax, BYTE PTR [rbx+8]
  000f4	88 07		 mov	 BYTE PTR [rdi], al
  000f6	0f b6 43 0f	 movzx	 eax, BYTE PTR [rbx+15]
  000fa	88 47 07	 mov	 BYTE PTR [rdi+7], al
  000fd	0f b6 43 0e	 movzx	 eax, BYTE PTR [rbx+14]
  00101	88 47 06	 mov	 BYTE PTR [rdi+6], al
  00104	0f b6 43 0d	 movzx	 eax, BYTE PTR [rbx+13]
  00108	88 47 05	 mov	 BYTE PTR [rdi+5], al
  0010b	0f b6 43 0c	 movzx	 eax, BYTE PTR [rbx+12]
  0010f	88 47 04	 mov	 BYTE PTR [rdi+4], al
  00112	0f b6 43 13	 movzx	 eax, BYTE PTR [rbx+19]
  00116	88 47 0b	 mov	 BYTE PTR [rdi+11], al
  00119	0f b6 43 12	 movzx	 eax, BYTE PTR [rbx+18]
  0011d	88 47 0a	 mov	 BYTE PTR [rdi+10], al
  00120	0f b6 43 11	 movzx	 eax, BYTE PTR [rbx+17]
  00124	88 47 09	 mov	 BYTE PTR [rdi+9], al
  00127	0f b6 43 10	 movzx	 eax, BYTE PTR [rbx+16]
  0012b	88 47 08	 mov	 BYTE PTR [rdi+8], al
  0012e	0f b6 43 17	 movzx	 eax, BYTE PTR [rbx+23]
  00132	88 47 0f	 mov	 BYTE PTR [rdi+15], al
  00135	0f b6 43 16	 movzx	 eax, BYTE PTR [rbx+22]
  00139	88 47 0e	 mov	 BYTE PTR [rdi+14], al
  0013c	0f b6 43 15	 movzx	 eax, BYTE PTR [rbx+21]
  00140	88 47 0d	 mov	 BYTE PTR [rdi+13], al
  00143	0f b6 43 14	 movzx	 eax, BYTE PTR [rbx+20]

; 305  :     }
; 306  : }

  00147	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0014c	88 47 0c	 mov	 BYTE PTR [rdi+12], al
  0014f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00153	5f		 pop	 rdi
  00154	c3		 ret	 0
md5_done ENDP
_TEXT	ENDS
EXTRN	_PyObject_New:PROC
EXTRN	_PxObject_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$newMD5object DD imagerel newMD5object
	DD	imagerel newMD5object+38
	DD	imagerel $unwind$newMD5object
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newMD5object DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT newMD5object
_TEXT	SEGMENT
newMD5object PROC					; COMDAT

; 323  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 324  :     return (MD5object *)PyObject_New(MD5object, &MD5type);

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:MD5type
  00010	85 c0		 test	 eax, eax
  00012	74 09		 je	 SHORT $LN3@newMD5obje

; 325  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	e9 00 00 00 00	 jmp	 _PxObject_New
$LN3@newMD5obje:
  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	e9 00 00 00 00	 jmp	 _PyObject_New
newMD5object ENDP
_TEXT	ENDS
EXTRN	PyObject_Free:PROC
; Function compile flags: /Ogtpy
;	COMDAT MD5_dealloc
_TEXT	SEGMENT
ptr$ = 8
MD5_dealloc PROC					; COMDAT

; 333  :     PyObject_Del(ptr);
; 334  : }

  00000	e9 00 00 00 00	 jmp	 PyObject_Free
MD5_dealloc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MD5_copy DD imagerel MD5_copy
	DD	imagerel MD5_copy+77
	DD	imagerel $unwind$MD5_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MD5_copy DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT MD5_copy
_TEXT	SEGMENT
self$ = 48
unused$ = 56
MD5_copy PROC						; COMDAT

; 343  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 344  :     MD5object *newobj;
; 345  : 
; 346  :     if (Py_TYPE(self) == &MD5type) {

  0000d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:MD5type

; 347  :         if ( (newobj = newMD5object())==NULL)

  00014	e8 00 00 00 00	 call	 newMD5object
  00019	48 8b d8	 mov	 rbx, rax
  0001c	48 85 c0	 test	 rax, rax
  0001f	75 0b		 jne	 SHORT $LN1@MD5_copy

; 356  : }

  00021	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5f		 pop	 rdi
  0002b	c3		 ret	 0
$LN1@MD5_copy:

; 348  :             return NULL;
; 349  :     } else {
; 350  :         if ( (newobj = newMD5object())==NULL)
; 351  :             return NULL;
; 352  :     }
; 353  : 
; 354  :     newobj->hash_state = self->hash_state;

  0002c	48 8d 4b 60	 lea	 rcx, QWORD PTR [rbx+96]
  00030	48 8d 57 60	 lea	 rdx, QWORD PTR [rdi+96]
  00034	41 b8 60 00 00
	00		 mov	 r8d, 96			; 00000060H
  0003a	e8 00 00 00 00	 call	 memcpy

; 355  :     return (PyObject *)newobj;

  0003f	48 8b c3	 mov	 rax, rbx

; 356  : }

  00042	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
MD5_copy ENDP
_TEXT	ENDS
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$MD5_digest DD imagerel MD5_digest
	DD	imagerel MD5_digest+106
	DD	imagerel $unwind$MD5_digest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MD5_digest DD 020a01H
	DD	013010aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT MD5_digest
_TEXT	SEGMENT
digest$ = 32
self$ = 160
unused$ = 168
MD5_digest PROC						; COMDAT

; 363  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 364  :     unsigned char digest[MD5_DIGESTSIZE];
; 365  :     struct md5_state temp;
; 366  : 
; 367  :     temp = self->hash_state;

  0000a	0f 10 41 60	 movups	 xmm0, XMMWORD PTR [rcx+96]
  0000e	0f 10 49 70	 movups	 xmm1, XMMWORD PTR [rcx+112]

; 368  :     md5_done(&temp, digest);

  00012	48 8d 50 88	 lea	 rdx, QWORD PTR [rax-120]
  00016	0f 29 40 98	 movaps	 XMMWORD PTR [rax-104], xmm0
  0001a	0f 29 48 a8	 movaps	 XMMWORD PTR [rax-88], xmm1
  0001e	0f 10 81 80 00
	00 00		 movups	 xmm0, XMMWORD PTR [rcx+128]
  00025	0f 10 89 90 00
	00 00		 movups	 xmm1, XMMWORD PTR [rcx+144]
  0002c	0f 29 40 b8	 movaps	 XMMWORD PTR [rax-72], xmm0
  00030	0f 29 48 c8	 movaps	 XMMWORD PTR [rax-56], xmm1
  00034	0f 10 81 a0 00
	00 00		 movups	 xmm0, XMMWORD PTR [rcx+160]
  0003b	0f 10 89 b0 00
	00 00		 movups	 xmm1, XMMWORD PTR [rcx+176]
  00042	48 8d 48 98	 lea	 rcx, QWORD PTR [rax-104]
  00046	0f 29 40 d8	 movaps	 XMMWORD PTR [rax-40], xmm0
  0004a	0f 29 48 e8	 movaps	 XMMWORD PTR [rax-24], xmm1
  0004e	e8 00 00 00 00	 call	 md5_done

; 369  :     return PyBytes_FromStringAndSize((const char *)digest, MD5_DIGESTSIZE);

  00053	48 8d 4c 24 20	 lea	 rcx, QWORD PTR digest$[rsp]
  00058	ba 10 00 00 00	 mov	 edx, 16
  0005d	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 370  : }

  00062	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00069	c3		 ret	 0
MD5_digest ENDP
_TEXT	ENDS
EXTRN	Py_hexdigits:QWORD
EXTRN	PyUnicode_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$MD5_hexdigest DD imagerel MD5_hexdigest
	DD	imagerel MD5_hexdigest+229
	DD	imagerel $unwind$MD5_hexdigest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MD5_hexdigest DD 020a01H
	DD	013010aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT MD5_hexdigest
_TEXT	SEGMENT
digest$ = 32
self$ = 160
unused$ = 168
MD5_hexdigest PROC					; COMDAT

; 377  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 378  :     unsigned char digest[MD5_DIGESTSIZE];
; 379  :     struct md5_state temp;
; 380  :     PyObject *retval;
; 381  :     Py_UCS1 *hex_digest;
; 382  :     int i, j;
; 383  : 
; 384  :     /* Get the raw (binary) digest value */
; 385  :     temp = self->hash_state;

  0000a	0f 10 41 60	 movups	 xmm0, XMMWORD PTR [rcx+96]
  0000e	0f 10 49 70	 movups	 xmm1, XMMWORD PTR [rcx+112]

; 386  :     md5_done(&temp, digest);

  00012	48 8d 50 88	 lea	 rdx, QWORD PTR [rax-120]
  00016	0f 29 40 98	 movaps	 XMMWORD PTR [rax-104], xmm0
  0001a	0f 29 48 a8	 movaps	 XMMWORD PTR [rax-88], xmm1
  0001e	0f 10 81 80 00
	00 00		 movups	 xmm0, XMMWORD PTR [rcx+128]
  00025	0f 10 89 90 00
	00 00		 movups	 xmm1, XMMWORD PTR [rcx+144]
  0002c	0f 29 40 b8	 movaps	 XMMWORD PTR [rax-72], xmm0
  00030	0f 29 48 c8	 movaps	 XMMWORD PTR [rax-56], xmm1
  00034	0f 10 81 a0 00
	00 00		 movups	 xmm0, XMMWORD PTR [rcx+160]
  0003b	0f 10 89 b0 00
	00 00		 movups	 xmm1, XMMWORD PTR [rcx+176]
  00042	48 8d 48 98	 lea	 rcx, QWORD PTR [rax-104]
  00046	0f 29 40 d8	 movaps	 XMMWORD PTR [rax-40], xmm0
  0004a	0f 29 48 e8	 movaps	 XMMWORD PTR [rax-24], xmm1
  0004e	e8 00 00 00 00	 call	 md5_done

; 387  : 
; 388  :     /* Create a new string */
; 389  :     retval = PyUnicode_New(MD5_DIGESTSIZE * 2, 127);

  00053	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00058	8d 4a a1	 lea	 ecx, QWORD PTR [rdx-95]
  0005b	e8 00 00 00 00	 call	 PyUnicode_New
  00060	4c 8b d8	 mov	 r11, rax

; 390  :     if (!retval)

  00063	48 85 c0	 test	 rax, rax
  00066	75 08		 jne	 SHORT $LN4@MD5_hexdig

; 406  : }

  00068	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0006f	c3		 ret	 0
$LN4@MD5_hexdig:

; 391  :             return NULL;
; 392  :     hex_digest = PyUnicode_1BYTE_DATA(retval);

  00070	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00073	a8 20		 test	 al, 32			; 00000020H
  00075	74 16		 je	 SHORT $LN9@MD5_hexdig
  00077	a8 40		 test	 al, 64			; 00000040H
  00079	74 09		 je	 SHORT $LN7@MD5_hexdig
  0007b	4d 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [r11+128]
  00082	eb 10		 jmp	 SHORT $LN10@MD5_hexdig
$LN7@MD5_hexdig:
  00084	4d 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [r11+160]
  0008b	eb 07		 jmp	 SHORT $LN10@MD5_hexdig
$LN9@MD5_hexdig:
  0008d	4d 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [r11+160]
$LN10@MD5_hexdig:

; 393  : 
; 394  :     /* Make hex version of the digest */
; 395  :     for(i=j=0; i<MD5_DIGESTSIZE; i++) {

  00094	45 33 c9	 xor	 r9d, r9d
  00097	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL3@MD5_hexdig:

; 396  :         unsigned char c;
; 397  :         c = (digest[i] >> 4) & 0xf;
; 398  :         hex_digest[j++] = Py_hexdigits[c];

  000a0	42 0f b6 54 0c
	20		 movzx	 edx, BYTE PTR digest$[rsp+r9]
  000a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  000ad	49 ff c1	 inc	 r9
  000b0	8b ca		 mov	 ecx, edx

; 399  :         c = (digest[i] & 0xf);

  000b2	83 e2 0f	 and	 edx, 15

; 400  :         hex_digest[j++] = Py_hexdigits[c];

  000b5	49 83 c0 02	 add	 r8, 2
  000b9	48 c1 e9 04	 shr	 rcx, 4
  000bd	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  000c1	41 88 48 fe	 mov	 BYTE PTR [r8-2], cl
  000c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  000cc	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  000d0	41 88 48 ff	 mov	 BYTE PTR [r8-1], cl
  000d4	49 83 f9 10	 cmp	 r9, 16
  000d8	7c c6		 jl	 SHORT $LL3@MD5_hexdig

; 401  :     }
; 402  : #ifdef Py_DEBUG
; 403  :     assert(_PyUnicode_CheckConsistency(retval, 1));
; 404  : #endif
; 405  :     return retval;

  000da	49 8b c3	 mov	 rax, r11

; 406  : }

  000dd	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  000e4	c3		 ret	 0
MD5_hexdigest ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@NHOOCGGK@object?5supporting?5the?5buffer?5API@ ; `string'
PUBLIC	??_C@_0CA@DGKHNIN@Buffer?5must?5be?5single?5dimension?$AA@ ; `string'
PUBLIC	??_C@_0CP@IBHDLOCD@Unicode?9objects?5must?5be?5encoded?5@ ; `string'
PUBLIC	??_C@_08BNPIIEPK@O?3update?$AA@			; `string'
EXTRN	PyExc_TypeError:QWORD
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyBuffer_Release:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_BufferError:QWORD
EXTRN	PyObject_GetBuffer:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$MD5_update DD imagerel MD5_update
	DD	imagerel MD5_update+321
	DD	imagerel $unwind$MD5_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MD5_update DD 020901H
	DD	03002f209H
xdata	ENDS
;	COMDAT ??_C@_0CK@NHOOCGGK@object?5supporting?5the?5buffer?5API@
CONST	SEGMENT
??_C@_0CK@NHOOCGGK@object?5supporting?5the?5buffer?5API@ DB 'object suppo'
	DB	'rting the buffer API required', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DGKHNIN@Buffer?5must?5be?5single?5dimension?$AA@
CONST	SEGMENT
??_C@_0CA@DGKHNIN@Buffer?5must?5be?5single?5dimension?$AA@ DB 'Buffer mus'
	DB	't be single dimension', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@IBHDLOCD@Unicode?9objects?5must?5be?5encoded?5@
CONST	SEGMENT
??_C@_0CP@IBHDLOCD@Unicode?9objects?5must?5be?5encoded?5@ DB 'Unicode-obj'
	DB	'ects must be encoded before hashing', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BNPIIEPK@O?3update?$AA@
CONST	SEGMENT
??_C@_08BNPIIEPK@O?3update?$AA@ DB 'O:update', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\md5module.c
CONST	ENDS
;	COMDAT MD5_update
_TEXT	SEGMENT
buf$ = 48
self$ = 144
args$ = 152
obj$ = 160
MD5_update PROC						; COMDAT

; 413  : {

  00000	40 53		 push	 rbx
  00002	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00009	48 8b c2	 mov	 rax, rdx
  0000c	48 8b d9	 mov	 rbx, rcx

; 414  :     PyObject *obj;
; 415  :     Py_buffer buf;
; 416  : 
; 417  :     if (!PyArg_ParseTuple(args, "O:update", &obj))

  0000f	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR obj$[rsp]
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08BNPIIEPK@O?3update?$AA@
  0001e	48 8b c8	 mov	 rcx, rax
  00021	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00026	85 c0		 test	 eax, eax

; 418  :         return NULL;

  00028	0f 84 08 01 00
	00		 je	 $LN16@MD5_update

; 419  : 
; 420  :     GET_BUFFER_VIEW_OR_ERROUT(obj, &buf);

  0002e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  00036	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0003a	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00044	74 0c		 je	 SHORT $LN5@MD5_update
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@IBHDLOCD@Unicode?9objects?5must?5be?5encoded?5@
  0004d	e9 d8 00 00 00	 jmp	 $LN17@MD5_update
$LN5@MD5_update:
  00052	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  00059	48 85 c0	 test	 rax, rax
  0005c	0f 84 c1 00 00
	00		 je	 $LN3@MD5_update
  00062	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00066	0f 84 b7 00 00
	00		 je	 $LN3@MD5_update
  0006c	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  00071	45 33 c0	 xor	 r8d, r8d
  00074	e8 00 00 00 00	 call	 PyObject_GetBuffer
  00079	83 f8 ff	 cmp	 eax, -1
  0007c	0f 84 b4 00 00
	00		 je	 $LN16@MD5_update
  00082	83 7c 24 54 01	 cmp	 DWORD PTR buf$[rsp+36], 1
  00087	7e 28		 jle	 SHORT $LN7@MD5_update
  00089	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@DGKHNIN@Buffer?5must?5be?5single?5dimension?$AA@
  00097	e8 00 00 00 00	 call	 PyErr_SetString
  0009c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  000a1	e8 00 00 00 00	 call	 PyBuffer_Release
  000a6	33 c0		 xor	 eax, eax

; 427  : }

  000a8	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000af	5b		 pop	 rbx
  000b0	c3		 ret	 0
$LN7@MD5_update:

; 421  : 
; 422  :     md5_process(&self->hash_state, buf.buf, buf.len);

  000b1	4c 8b 44 24 40	 mov	 r8, QWORD PTR buf$[rsp+16]
  000b6	48 8b 54 24 30	 mov	 rdx, QWORD PTR buf$[rsp]
  000bb	48 8d 4b 60	 lea	 rcx, QWORD PTR [rbx+96]
  000bf	e8 00 00 00 00	 call	 md5_process

; 423  : 
; 424  :     PyBuffer_Release(&buf);

  000c4	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  000c9	e8 00 00 00 00	 call	 PyBuffer_Release

; 425  :     Py_INCREF(Py_None);

  000ce	e8 00 00 00 00	 call	 _Py_PXCTX
  000d3	85 c0		 test	 eax, eax
  000d5	75 3c		 jne	 SHORT $LN13@MD5_update
  000d7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000ec	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000f2	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000fa	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ff	85 c0		 test	 eax, eax
  00101	75 09		 jne	 SHORT $LN12@MD5_update
  00103	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0010a	74 07		 je	 SHORT $LN13@MD5_update
$LN12@MD5_update:
  0010c	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN13@MD5_update:

; 426  :     return Py_None;

  00113	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 427  : }

  0011a	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00121	5b		 pop	 rbx
  00122	c3		 ret	 0
$LN3@MD5_update:

; 419  : 
; 420  :     GET_BUFFER_VIEW_OR_ERROUT(obj, &buf);

  00123	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@NHOOCGGK@object?5supporting?5the?5buffer?5API@
$LN17@MD5_update:
  0012a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00131	e8 00 00 00 00	 call	 PyErr_SetString
$LN16@MD5_update:
  00136	33 c0		 xor	 eax, eax

; 427  : }

  00138	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0013f	5b		 pop	 rbx
  00140	c3		 ret	 0
MD5_update ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT MD5_get_block_size
_TEXT	SEGMENT
self$ = 8
closure$ = 16
MD5_get_block_size PROC					; COMDAT

; 440  :     return PyLong_FromLong(MD5_BLOCKSIZE);

  00000	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H

; 441  : }

  00005	e9 00 00 00 00	 jmp	 PyLong_FromLong
MD5_get_block_size ENDP
_TEXT	ENDS
PUBLIC	??_C@_03GCGHEHKJ@MD5?$AA@			; `string'
EXTRN	PyUnicode_FromStringAndSize:PROC
;	COMDAT ??_C@_03GCGHEHKJ@MD5?$AA@
CONST	SEGMENT
??_C@_03GCGHEHKJ@MD5?$AA@ DB 'MD5', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT MD5_get_name
_TEXT	SEGMENT
self$ = 8
closure$ = 16
MD5_get_name PROC					; COMDAT

; 446  :     return PyUnicode_FromStringAndSize("MD5", 3);

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03GCGHEHKJ@MD5?$AA@
  00007	ba 03 00 00 00	 mov	 edx, 3

; 447  : }

  0000c	e9 00 00 00 00	 jmp	 PyUnicode_FromStringAndSize
MD5_get_name ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT md5_get_digest_size
_TEXT	SEGMENT
self$ = 8
closure$ = 16
md5_get_digest_size PROC				; COMDAT

; 452  :     return PyLong_FromLong(MD5_DIGESTSIZE);

  00000	b9 10 00 00 00	 mov	 ecx, 16

; 453  : }

  00005	e9 00 00 00 00	 jmp	 PyLong_FromLong
md5_get_digest_size ENDP
_TEXT	ENDS
PUBLIC	??_C@_06KJFPOEIK@?$HMO?3new?$AA@		; `string'
EXTRN	PyErr_Occurred:PROC
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$MD5_new DD imagerel MD5_new
	DD	imagerel MD5_new+234
	DD	imagerel $unwind$MD5_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$MD5_new DD imagerel MD5_new+234
	DD	imagerel MD5_new+293
	DD	imagerel $chain$0$MD5_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$MD5_new DD imagerel MD5_new+293
	DD	imagerel MD5_new+420
	DD	imagerel $chain$3$MD5_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$MD5_new DD 040c21H
	DD	010740cH
	DD	0123400H
	DD	imagerel MD5_new
	DD	imagerel MD5_new+234
	DD	imagerel $unwind$MD5_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$MD5_new DD 020821H
	DD	0123408H
	DD	imagerel MD5_new
	DD	imagerel MD5_new+234
	DD	imagerel $unwind$MD5_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MD5_new DD 020a01H
	DD	011010aH
xdata	ENDS
;	COMDAT ??_C@_06KJFPOEIK@?$HMO?3new?$AA@
CONST	SEGMENT
??_C@_06KJFPOEIK@?$HMO?3new?$AA@ DB '|O:new', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT MD5_new
_TEXT	SEGMENT
buf$ = 48
self$ = 144
args$ = 152
kwdict$ = 160
data_obj$ = 168
MD5_new	PROC						; COMDAT

; 514  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 515  :     static char *kwlist[] = {"string", NULL};
; 516  :     MD5object *new;
; 517  :     PyObject *data_obj = NULL;
; 518  :     Py_buffer buf;
; 519  : 
; 520  :     if (!PyArg_ParseTupleAndKeywords(args, kwdict, "|O:new", kwlist,
; 521  :                                      &data_obj)) {

  0000a	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0000e	49 8b c0	 mov	 rax, r8
  00011	4c 8b d2	 mov	 r10, rdx
  00014	49 89 4b 98	 mov	 QWORD PTR [r11-104], rcx
  00018	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??MD5_new@@9@9
  0001f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06KJFPOEIK@?$HMO?3new?$AA@
  00026	49 8b ca	 mov	 rcx, r10
  00029	48 8b d0	 mov	 rdx, rax
  0002c	49 c7 43 20 00
	00 00 00	 mov	 QWORD PTR [r11+32], 0
  00034	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00039	85 c0		 test	 eax, eax

; 522  :         return NULL;

  0003b	74 34		 je	 SHORT $LN20@MD5_new

; 523  :     }
; 524  : 
; 525  :     if (data_obj)

  0003d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR data_obj$[rsp]
  00045	48 85 c9	 test	 rcx, rcx
  00048	0f 84 9c 00 00
	00		 je	 $LN11@MD5_new

; 526  :         GET_BUFFER_VIEW_OR_ERROUT(data_obj, &buf);

  0004e	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00052	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0005c	74 1d		 je	 SHORT $LN10@MD5_new
  0005e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@IBHDLOCD@Unicode?9objects?5must?5be?5encoded?5@
  0006c	e8 00 00 00 00	 call	 PyErr_SetString
$LN20@MD5_new:
  00071	33 c0		 xor	 eax, eax

; 548  : }

  00073	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0007a	c3		 ret	 0
$LN10@MD5_new:

; 526  :         GET_BUFFER_VIEW_OR_ERROUT(data_obj, &buf);

  0007b	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  00082	48 85 c0	 test	 rax, rax
  00085	74 46		 je	 SHORT $LN8@MD5_new
  00087	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0008b	74 40		 je	 SHORT $LN8@MD5_new
  0008d	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  00092	45 33 c0	 xor	 r8d, r8d
  00095	e8 00 00 00 00	 call	 PyObject_GetBuffer
  0009a	83 f8 ff	 cmp	 eax, -1
  0009d	74 d2		 je	 SHORT $LN20@MD5_new
  0009f	83 7c 24 54 01	 cmp	 DWORD PTR buf$[rsp+36], 1
  000a4	7e 44		 jle	 SHORT $LN11@MD5_new
  000a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@DGKHNIN@Buffer?5must?5be?5single?5dimension?$AA@
  000b4	e8 00 00 00 00	 call	 PyErr_SetString
  000b9	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  000be	e8 00 00 00 00	 call	 PyBuffer_Release
  000c3	33 c0		 xor	 eax, eax

; 548  : }

  000c5	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  000cc	c3		 ret	 0
$LN8@MD5_new:

; 526  :         GET_BUFFER_VIEW_OR_ERROUT(data_obj, &buf);

  000cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@NHOOCGGK@object?5supporting?5the?5buffer?5API@
  000db	e8 00 00 00 00	 call	 PyErr_SetString
  000e0	33 c0		 xor	 eax, eax

; 548  : }

  000e2	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  000e9	c3		 ret	 0
$LN11@MD5_new:
  000ea	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx

; 527  : 
; 528  :     if ((new = newMD5object()) == NULL) {

  000f2	e8 00 00 00 00	 call	 newMD5object
  000f7	48 8b d8	 mov	 rbx, rax
  000fa	48 85 c0	 test	 rax, rax
  000fd	75 26		 jne	 SHORT $LN5@MD5_new

; 529  :         if (data_obj)

  000ff	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR data_obj$[rsp], rax
  00107	74 0a		 je	 SHORT $LN4@MD5_new

; 530  :             PyBuffer_Release(&buf);

  00109	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  0010e	e8 00 00 00 00	 call	 PyBuffer_Release
$LN4@MD5_new:

; 531  :         return NULL;

  00113	33 c0		 xor	 eax, eax
  00115	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]

; 548  : }

  0011d	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00124	c3		 ret	 0
$LN5@MD5_new:

; 532  :     }
; 533  : 
; 534  :     md5_init(&new->hash_state);

  00125	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00129	48 89 bc 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rdi
  00131	e8 00 00 00 00	 call	 md5_init

; 535  : 
; 536  :     if (PyErr_Occurred()) {

  00136	e8 00 00 00 00	 call	 PyErr_Occurred
  0013b	48 85 c0	 test	 rax, rax
  0013e	74 21		 je	 SHORT $LN3@MD5_new

; 537  :         Py_DECREF(new);

  00140	48 8b cb	 mov	 rcx, rbx
  00143	e8 00 00 00 00	 call	 _Py_DecRef

; 538  :         if (data_obj)

  00148	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR data_obj$[rsp], 0
  00151	74 0a		 je	 SHORT $LN2@MD5_new

; 539  :             PyBuffer_Release(&buf);

  00153	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  00158	e8 00 00 00 00	 call	 PyBuffer_Release
$LN2@MD5_new:

; 540  :         return NULL;

  0015d	33 c0		 xor	 eax, eax
  0015f	eb 2b		 jmp	 SHORT $LN19@MD5_new
$LN3@MD5_new:

; 541  :     }
; 542  :     if (data_obj) {

  00161	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR data_obj$[rsp], 0
  0016a	74 1d		 je	 SHORT $LN1@MD5_new

; 543  :         md5_process(&new->hash_state, buf.buf, buf.len);

  0016c	4c 8b 44 24 40	 mov	 r8, QWORD PTR buf$[rsp+16]
  00171	48 8b 54 24 30	 mov	 rdx, QWORD PTR buf$[rsp]
  00176	48 8d 4b 60	 lea	 rcx, QWORD PTR [rbx+96]
  0017a	e8 00 00 00 00	 call	 md5_process

; 544  :         PyBuffer_Release(&buf);

  0017f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  00184	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@MD5_new:

; 545  :     }
; 546  : 
; 547  :     return (PyObject *)new;

  00189	48 8b c3	 mov	 rax, rbx
$LN19@MD5_new:
  0018c	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR [rsp+128]
  00194	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]

; 548  : }

  0019c	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001a3	c3		 ret	 0
MD5_new	ENDP
_TEXT	ENDS
PUBLIC	PyInit__md5
EXTRN	PyModule_Create2:PROC
EXTRN	PyType_Ready:PROC
EXTRN	PyType_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit__md5 DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$PyInit__md5
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__md5 DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyInit__md5
_TEXT	SEGMENT
PyInit__md5 PROC					; COMDAT

; 578  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 579  :     Py_TYPE(&MD5type) = &PyType_Type;

  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyType_Type

; 580  :     if (PyType_Ready(&MD5type) < 0)

  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:MD5type
  00012	48 89 05 58 00
	00 00		 mov	 QWORD PTR MD5type+88, rax
  00019	e8 00 00 00 00	 call	 PyType_Ready
  0001e	85 c0		 test	 eax, eax
  00020	79 07		 jns	 SHORT $LN1@PyInit__md

; 581  :         return NULL;

  00022	33 c0		 xor	 eax, eax

; 583  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
$LN1@PyInit__md:

; 582  :     return PyModule_Create(&_md5module);

  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_md5module
  00030	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H

; 583  : }

  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	e9 00 00 00 00	 jmp	 PyModule_Create2
PyInit__md5 ENDP
_TEXT	ENDS
END
