; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05MKDOIIA@False?$AA@			; `string'
PUBLIC	??_C@_04HPMIDMKH@True?$AA@			; `string'
PUBLIC	??_C@_04OHJIHAFH@None?$AA@			; `string'
_DATA	SEGMENT
FORBIDDEN DQ	FLAT:??_C@_04OHJIHAFH@None?$AA@
	DQ	FLAT:??_C@_04HPMIDMKH@True?$AA@
	DQ	FLAT:??_C@_05MKDOIIA@False?$AA@
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ??_C@_05MKDOIIA@False?$AA@
CONST	SEGMENT
??_C@_05MKDOIIA@False?$AA@ DB 'False', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HPMIDMKH@True?$AA@
CONST	SEGMENT
??_C@_04HPMIDMKH@True?$AA@ DB 'True', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHJIHAFH@None?$AA@
CONST	SEGMENT
??_C@_04OHJIHAFH@None?$AA@ DB 'None', 00H		; `string'
CONST	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@FOMOKEA@comprehension?5with?5no?5generators@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\python\ast.c
pdata	SEGMENT
$pdata$validate_comprehension DD imagerel validate_comprehension
	DD	imagerel validate_comprehension+28
	DD	imagerel $unwind$validate_comprehension
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$validate_comprehension DD imagerel validate_comprehension+28
	DD	imagerel validate_comprehension+147
	DD	imagerel $chain$2$validate_comprehension
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$validate_comprehension DD imagerel validate_comprehension+147
	DD	imagerel validate_comprehension+154
	DD	imagerel $chain$4$validate_comprehension
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$validate_comprehension DD imagerel validate_comprehension+154
	DD	imagerel validate_comprehension+181
	DD	imagerel $chain$5$validate_comprehension
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$validate_comprehension DD 021H
	DD	imagerel validate_comprehension
	DD	imagerel validate_comprehension+28
	DD	imagerel $unwind$validate_comprehension
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$validate_comprehension DD 060021H
	DD	087400H
	DD	075400H
	DD	063400H
	DD	imagerel validate_comprehension
	DD	imagerel validate_comprehension+28
	DD	imagerel $unwind$validate_comprehension
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$validate_comprehension DD 061321H
	DD	075413H
	DD	08740aH
	DD	063405H
	DD	imagerel validate_comprehension
	DD	imagerel validate_comprehension+28
	DD	imagerel $unwind$validate_comprehension
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_comprehension DD 020601H
	DD	060023206H
xdata	ENDS
;	COMDAT ??_C@_0CB@FOMOKEA@comprehension?5with?5no?5generators@
CONST	SEGMENT
??_C@_0CB@FOMOKEA@comprehension?5with?5no?5generators@ DB 'comprehension '
	DB	'with no generators', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT validate_comprehension
_TEXT	SEGMENT
gens$ = 48
validate_comprehension PROC				; COMDAT

; 22   : {

  00000	40 56		 push	 rsi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f1	 mov	 rsi, rcx

; 23   :     int i;
; 24   :     if (!asdl_seq_LEN(gens)) {

  00009	48 85 c9	 test	 rcx, rcx
  0000c	0f 84 88 00 00
	00		 je	 $LN15@validate_c
  00012	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00016	0f 84 7e 00 00
	00		 je	 $LN15@validate_c

; 27   :     }
; 28   :     for (i = 0; i < asdl_seq_LEN(gens); i++) {

  0001c	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00021	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00026	48 8d 79 08	 lea	 rdi, QWORD PTR [rcx+8]
  0002a	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  0002f	33 db		 xor	 ebx, ebx
$LL5@validate_c:
  00031	48 63 c3	 movsxd	 rax, ebx
  00034	48 3b 06	 cmp	 rax, QWORD PTR [rsi]
  00037	7d 5a		 jge	 SHORT $LN3@validate_c

; 29   :         comprehension_ty comp = asdl_seq_GET(gens, i);

  00039	48 8b 2f	 mov	 rbp, QWORD PTR [rdi]

; 30   :         if (!validate_expr(comp->target, Store) ||
; 31   :             !validate_expr(comp->iter, Load) ||
; 32   :             !validate_exprs(comp->ifs, Load, 0))

  0003c	ba 02 00 00 00	 mov	 edx, 2
  00041	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
  00045	e8 00 00 00 00	 call	 validate_expr
  0004a	85 c0		 test	 eax, eax
  0004c	74 2e		 je	 SHORT $LN14@validate_c
  0004e	48 8b 4d 08	 mov	 rcx, QWORD PTR [rbp+8]
  00052	ba 01 00 00 00	 mov	 edx, 1
  00057	e8 00 00 00 00	 call	 validate_expr
  0005c	85 c0		 test	 eax, eax
  0005e	74 1c		 je	 SHORT $LN14@validate_c
  00060	48 8b 4d 10	 mov	 rcx, QWORD PTR [rbp+16]
  00064	45 33 c0	 xor	 r8d, r8d
  00067	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  0006b	e8 00 00 00 00	 call	 validate_exprs
  00070	85 c0		 test	 eax, eax
  00072	74 08		 je	 SHORT $LN14@validate_c

; 27   :     }
; 28   :     for (i = 0; i < asdl_seq_LEN(gens); i++) {

  00074	ff c3		 inc	 ebx
  00076	48 83 c7 08	 add	 rdi, 8
  0007a	eb b5		 jmp	 SHORT $LL5@validate_c
$LN14@validate_c:

; 33   :             return 0;

  0007c	33 c0		 xor	 eax, eax
$LN18@validate_c:
  0007e	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00083	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00088	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 36   : }

  0008d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00091	5e		 pop	 rsi
  00092	c3		 ret	 0
$LN3@validate_c:

; 34   :     }
; 35   :     return 1;

  00093	b8 01 00 00 00	 mov	 eax, 1
  00098	eb e4		 jmp	 SHORT $LN18@validate_c
$LN15@validate_c:

; 25   :         PyErr_SetString(PyExc_ValueError, "comprehension with no generators");

  0009a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FOMOKEA@comprehension?5with?5no?5generators@
  000a8	e8 00 00 00 00	 call	 PyErr_SetString

; 26   :         return 0;

  000ad	33 c0		 xor	 eax, eax

; 36   : }

  000af	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b3	5e		 pop	 rsi
  000b4	c3		 ret	 0
validate_comprehension ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_keywords DD imagerel validate_keywords
	DD	imagerel validate_keywords+112
	DD	imagerel $unwind$validate_keywords
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_keywords DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT validate_keywords
_TEXT	SEGMENT
keywords$ = 48
validate_keywords PROC					; COMDAT

; 65   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f1	 mov	 rsi, rcx

; 66   :     int i;
; 67   :     for (i = 0; i < asdl_seq_LEN(keywords); i++)

  00012	33 db		 xor	 ebx, ebx
  00014	48 8d 79 08	 lea	 rdi, QWORD PTR [rcx+8]
$LL4@validate_k:
  00018	48 85 f6	 test	 rsi, rsi
  0001b	75 04		 jne	 SHORT $LN7@validate_k
  0001d	33 d2		 xor	 edx, edx
  0001f	eb 03		 jmp	 SHORT $LN8@validate_k
$LN7@validate_k:
  00021	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
$LN8@validate_k:
  00024	48 63 c3	 movsxd	 rax, ebx
  00027	48 3b c2	 cmp	 rax, rdx
  0002a	7d 2f		 jge	 SHORT $LN2@validate_k

; 68   :         if (!validate_expr(((keyword_ty)asdl_seq_GET(keywords, i))->value, Load))

  0002c	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0002f	ba 01 00 00 00	 mov	 edx, 1
  00034	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00038	e8 00 00 00 00	 call	 validate_expr
  0003d	85 c0		 test	 eax, eax
  0003f	74 08		 je	 SHORT $LN10@validate_k

; 66   :     int i;
; 67   :     for (i = 0; i < asdl_seq_LEN(keywords); i++)

  00041	ff c3		 inc	 ebx
  00043	48 83 c7 08	 add	 rdi, 8
  00047	eb cf		 jmp	 SHORT $LL4@validate_k
$LN10@validate_k:

; 69   :             return 0;

  00049	33 c0		 xor	 eax, eax

; 70   :     return 1;
; 71   : }

  0004b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00050	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
$LN2@validate_k:
  0005b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00060	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00065	b8 01 00 00 00	 mov	 eax, 1
  0006a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006e	5f		 pop	 rdi
  0006f	c3		 ret	 0
validate_keywords ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_args DD imagerel validate_args
	DD	imagerel validate_args+117
	DD	imagerel $unwind$validate_args
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_args DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT validate_args
_TEXT	SEGMENT
args$ = 48
validate_args PROC					; COMDAT

; 75   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f1	 mov	 rsi, rcx

; 76   :     int i;
; 77   :     for (i = 0; i < asdl_seq_LEN(args); i++) {

  00012	33 db		 xor	 ebx, ebx
  00014	48 8d 79 08	 lea	 rdi, QWORD PTR [rcx+8]
$LL4@validate_a:
  00018	48 85 f6	 test	 rsi, rsi
  0001b	75 04		 jne	 SHORT $LN7@validate_a
  0001d	33 d2		 xor	 edx, edx
  0001f	eb 03		 jmp	 SHORT $LN8@validate_a
$LN7@validate_a:
  00021	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
$LN8@validate_a:
  00024	48 63 c3	 movsxd	 rax, ebx
  00027	48 3b c2	 cmp	 rax, rdx
  0002a	7d 34		 jge	 SHORT $LN2@validate_a

; 78   :         arg_ty arg = asdl_seq_GET(args, i);

  0002c	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 79   :         if (arg->annotation && !validate_expr(arg->annotation, Load))

  0002f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00033	48 85 c9	 test	 rcx, rcx
  00036	74 0e		 je	 SHORT $LN3@validate_a
  00038	ba 01 00 00 00	 mov	 edx, 1
  0003d	e8 00 00 00 00	 call	 validate_expr
  00042	85 c0		 test	 eax, eax
  00044	74 08		 je	 SHORT $LN10@validate_a
$LN3@validate_a:

; 76   :     int i;
; 77   :     for (i = 0; i < asdl_seq_LEN(args); i++) {

  00046	ff c3		 inc	 ebx
  00048	48 83 c7 08	 add	 rdi, 8
  0004c	eb ca		 jmp	 SHORT $LL4@validate_a
$LN10@validate_a:

; 80   :             return 0;

  0004e	33 c0		 xor	 eax, eax

; 81   :     }
; 82   :     return 1;
; 83   : }

  00050	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00055	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005e	5f		 pop	 rdi
  0005f	c3		 ret	 0
$LN2@validate_a:
  00060	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00065	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0006a	b8 01 00 00 00	 mov	 eax, 1
  0006f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00073	5f		 pop	 rdi
  00074	c3		 ret	 0
validate_args ENDP
_TEXT	ENDS
PUBLIC	??_C@_09GPGAJHPD@?$CIunknown?$CJ?$AA@		; `string'
PUBLIC	??_C@_05LOJBNELM@Param?$AA@			; `string'
PUBLIC	??_C@_08NAEMOJFF@AugStore?$AA@			; `string'
PUBLIC	??_C@_07GCIJHPCC@AugLoad?$AA@			; `string'
PUBLIC	??_C@_03ENJJMCOJ@Del?$AA@			; `string'
PUBLIC	??_C@_05OEMPKGID@Store?$AA@			; `string'
PUBLIC	??_C@_04IPBPFFEL@Load?$AA@			; `string'
EXTRN	__ImageBase:BYTE
;	COMDAT ??_C@_09GPGAJHPD@?$CIunknown?$CJ?$AA@
CONST	SEGMENT
??_C@_09GPGAJHPD@?$CIunknown?$CJ?$AA@ DB '(unknown)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05LOJBNELM@Param?$AA@
CONST	SEGMENT
??_C@_05LOJBNELM@Param?$AA@ DB 'Param', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NAEMOJFF@AugStore?$AA@
CONST	SEGMENT
??_C@_08NAEMOJFF@AugStore?$AA@ DB 'AugStore', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GCIJHPCC@AugLoad?$AA@
CONST	SEGMENT
??_C@_07GCIJHPCC@AugLoad?$AA@ DB 'AugLoad', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03ENJJMCOJ@Del?$AA@
CONST	SEGMENT
??_C@_03ENJJMCOJ@Del?$AA@ DB 'Del', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OEMPKGID@Store?$AA@
CONST	SEGMENT
??_C@_05OEMPKGID@Store?$AA@ DB 'Store', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IPBPFFEL@Load?$AA@
CONST	SEGMENT
??_C@_04IPBPFFEL@Load?$AA@ DB 'Load', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT expr_context_name
_TEXT	SEGMENT
ctx$ = 8
expr_context_name PROC					; COMDAT

; 88   :     switch (ctx) {

  00000	ff c9		 dec	 ecx
  00002	83 f9 05	 cmp	 ecx, 5
  00005	77 46		 ja	 SHORT $LN1@expr_conte
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  0000e	48 63 c1	 movsxd	 rax, ecx
  00011	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN12@expr_conte[rdx+rax*4]
  00018	48 03 ca	 add	 rcx, rdx
  0001b	ff e1		 jmp	 rcx
$LN7@expr_conte:

; 89   :     case Load:
; 90   :         return "Load";

  0001d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04IPBPFFEL@Load?$AA@

; 104  :     }
; 105  : }

  00024	c3		 ret	 0
$LN6@expr_conte:

; 91   :     case Store:
; 92   :         return "Store";

  00025	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05OEMPKGID@Store?$AA@

; 104  :     }
; 105  : }

  0002c	c3		 ret	 0
$LN5@expr_conte:

; 93   :     case Del:
; 94   :         return "Del";

  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03ENJJMCOJ@Del?$AA@

; 104  :     }
; 105  : }

  00034	c3		 ret	 0
$LN4@expr_conte:

; 95   :     case AugLoad:
; 96   :         return "AugLoad";

  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07GCIJHPCC@AugLoad?$AA@

; 104  :     }
; 105  : }

  0003c	c3		 ret	 0
$LN3@expr_conte:

; 97   :     case AugStore:
; 98   :         return "AugStore";

  0003d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08NAEMOJFF@AugStore?$AA@

; 104  :     }
; 105  : }

  00044	c3		 ret	 0
$LN2@expr_conte:

; 99   :     case Param:
; 100  :         return "Param";

  00045	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05LOJBNELM@Param?$AA@

; 104  :     }
; 105  : }

  0004c	c3		 ret	 0
$LN1@expr_conte:

; 101  :     default:
; 102  :         assert(0);
; 103  :         return "(unknown)";

  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_09GPGAJHPD@?$CIunknown?$CJ?$AA@

; 104  :     }
; 105  : }

  00054	c3		 ret	 0
  00055	0f 1f 00	 npad	 3
$LN12@expr_conte:
  00058	00 00 00 00	 DD	 $LN7@expr_conte
  0005c	00 00 00 00	 DD	 $LN6@expr_conte
  00060	00 00 00 00	 DD	 $LN5@expr_conte
  00064	00 00 00 00	 DD	 $LN4@expr_conte
  00068	00 00 00 00	 DD	 $LN3@expr_conte
  0006c	00 00 00 00	 DD	 $LN2@expr_conte
expr_context_name ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EB@KMIALOCA@length?5of?5kwonlyargs?5is?5not?5the?5@ ; `string'
PUBLIC	??_C@_0DA@BMNOANML@more?5positional?5defaults?5than?5ar@ ; `string'
PUBLIC	??_C@_0CK@OLHMKKCI@kwargannotation?5but?5no?5kwarg?5on?5@ ; `string'
PUBLIC	??_C@_0CM@FFNDHJIA@varargannotation?5but?5no?5vararg?5o@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_arguments DD imagerel validate_arguments
	DD	imagerel validate_arguments+31
	DD	imagerel $unwind$validate_arguments
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$validate_arguments DD imagerel validate_arguments+31
	DD	imagerel validate_arguments+85
	DD	imagerel $chain$0$validate_arguments
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$validate_arguments DD imagerel validate_arguments+85
	DD	imagerel validate_arguments+165
	DD	imagerel $chain$2$validate_arguments
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$validate_arguments DD imagerel validate_arguments+165
	DD	imagerel validate_arguments+240
	DD	imagerel $chain$4$validate_arguments
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$validate_arguments DD imagerel validate_arguments+240
	DD	imagerel validate_arguments+305
	DD	imagerel $chain$6$validate_arguments
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$validate_arguments DD imagerel validate_arguments+305
	DD	imagerel validate_arguments+355
	DD	imagerel $chain$8$validate_arguments
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$validate_arguments DD 020021H
	DD	067400H
	DD	imagerel validate_arguments
	DD	imagerel validate_arguments+31
	DD	imagerel $unwind$validate_arguments
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$validate_arguments DD 020021H
	DD	067400H
	DD	imagerel validate_arguments
	DD	imagerel validate_arguments+31
	DD	imagerel $unwind$validate_arguments
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$validate_arguments DD 020021H
	DD	067400H
	DD	imagerel validate_arguments
	DD	imagerel validate_arguments+31
	DD	imagerel $unwind$validate_arguments
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$validate_arguments DD 020021H
	DD	067400H
	DD	imagerel validate_arguments
	DD	imagerel validate_arguments+31
	DD	imagerel $unwind$validate_arguments
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$validate_arguments DD 020521H
	DD	067405H
	DD	imagerel validate_arguments
	DD	imagerel validate_arguments+31
	DD	imagerel $unwind$validate_arguments
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_arguments DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0EB@KMIALOCA@length?5of?5kwonlyargs?5is?5not?5the?5@
CONST	SEGMENT
??_C@_0EB@KMIALOCA@length?5of?5kwonlyargs?5is?5not?5the?5@ DB 'length of '
	DB	'kwonlyargs is not the same as kw_defaults on arguments', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BMNOANML@more?5positional?5defaults?5than?5ar@
CONST	SEGMENT
??_C@_0DA@BMNOANML@more?5positional?5defaults?5than?5ar@ DB 'more positio'
	DB	'nal defaults than args on arguments', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OLHMKKCI@kwargannotation?5but?5no?5kwarg?5on?5@
CONST	SEGMENT
??_C@_0CK@OLHMKKCI@kwargannotation?5but?5no?5kwarg?5on?5@ DB 'kwargannota'
	DB	'tion but no kwarg on arguments', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FFNDHJIA@varargannotation?5but?5no?5vararg?5o@
CONST	SEGMENT
??_C@_0CM@FFNDHJIA@varargannotation?5but?5no?5vararg?5o@ DB 'varargannota'
	DB	'tion but no vararg on arguments', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT validate_arguments
_TEXT	SEGMENT
args$ = 48
validate_arguments PROC					; COMDAT

; 109  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 110  :     if (!validate_args(args->args))

  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	e8 00 00 00 00	 call	 validate_args
  00011	85 c0		 test	 eax, eax
  00013	75 06		 jne	 SHORT $LN10@validate_a@2

; 140  : }

  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5b		 pop	 rbx
  0001a	c3		 ret	 0
$LN10@validate_a@2:

; 111  :         return 0;
; 112  :     if (args->varargannotation) {

  0001b	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0001f	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00024	bf 01 00 00 00	 mov	 edi, 1
  00029	48 85 c9	 test	 rcx, rcx
  0002c	74 36		 je	 SHORT $LN7@validate_a@2

; 113  :         if (!args->vararg) {

  0002e	48 83 7b 08 00	 cmp	 QWORD PTR [rbx+8], 0
  00033	75 20		 jne	 SHORT $LN8@validate_a@2

; 114  :             PyErr_SetString(PyExc_ValueError, "varargannotation but no vararg on arguments");

  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@FFNDHJIA@varargannotation?5but?5no?5vararg?5o@
  00043	e8 00 00 00 00	 call	 PyErr_SetString
  00048	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 115  :             return 0;

  0004d	33 c0		 xor	 eax, eax

; 140  : }

  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5b		 pop	 rbx
  00054	c3		 ret	 0
$LN8@validate_a@2:

; 116  :         }
; 117  :         if (!validate_expr(args->varargannotation, Load))

  00055	8b d7		 mov	 edx, edi
  00057	e8 00 00 00 00	 call	 validate_expr
  0005c	85 c0		 test	 eax, eax

; 118  :             return 0;

  0005e	0f 84 c0 00 00
	00		 je	 $LN24@validate_a@2
$LN7@validate_a@2:

; 119  :     }
; 120  :     if (!validate_args(args->kwonlyargs))

  00064	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  00068	e8 00 00 00 00	 call	 validate_args
  0006d	85 c0		 test	 eax, eax

; 121  :         return 0;

  0006f	0f 84 af 00 00
	00		 je	 $LN24@validate_a@2

; 122  :     if (args->kwargannotation) {

  00075	48 8b 4b 28	 mov	 rcx, QWORD PTR [rbx+40]
  00079	48 85 c9	 test	 rcx, rcx
  0007c	74 32		 je	 SHORT $LN3@validate_a@2

; 123  :         if (!args->kwarg) {

  0007e	48 83 7b 20 00	 cmp	 QWORD PTR [rbx+32], 0
  00083	75 20		 jne	 SHORT $LN4@validate_a@2

; 124  :             PyErr_SetString(PyExc_ValueError, "kwargannotation but no kwarg on arguments");

  00085	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@OLHMKKCI@kwargannotation?5but?5no?5kwarg?5on?5@
  00093	e8 00 00 00 00	 call	 PyErr_SetString
  00098	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 125  :             return 0;

  0009d	33 c0		 xor	 eax, eax

; 140  : }

  0009f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a3	5b		 pop	 rbx
  000a4	c3		 ret	 0
$LN4@validate_a@2:

; 126  :         }
; 127  :         if (!validate_expr(args->kwargannotation, Load))

  000a5	8b d7		 mov	 edx, edi
  000a7	e8 00 00 00 00	 call	 validate_expr
  000ac	85 c0		 test	 eax, eax

; 128  :             return 0;

  000ae	74 74		 je	 SHORT $LN24@validate_a@2
$LN3@validate_a@2:

; 129  :     }
; 130  :     if (asdl_seq_LEN(args->defaults) > asdl_seq_LEN(args->args)) {

  000b0	4c 8b 4b 30	 mov	 r9, QWORD PTR [rbx+48]
  000b4	4d 85 c9	 test	 r9, r9
  000b7	75 04		 jne	 SHORT $LN13@validate_a@2
  000b9	33 c0		 xor	 eax, eax
  000bb	eb 03		 jmp	 SHORT $LN14@validate_a@2
$LN13@validate_a@2:
  000bd	49 8b 01	 mov	 rax, QWORD PTR [r9]
$LN14@validate_a@2:
  000c0	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000c3	48 85 c9	 test	 rcx, rcx
  000c6	74 03		 je	 SHORT $LN16@validate_a@2
$LN15@validate_a@2:
  000c8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN16@validate_a@2:
  000cb	48 3b c1	 cmp	 rax, rcx
  000ce	7e 20		 jle	 SHORT $LN2@validate_a@2

; 131  :         PyErr_SetString(PyExc_ValueError, "more positional defaults than args on arguments");

  000d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@BMNOANML@more?5positional?5defaults?5than?5ar@
  000de	e8 00 00 00 00	 call	 PyErr_SetString
  000e3	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 132  :         return 0;

  000e8	33 c0		 xor	 eax, eax

; 140  : }

  000ea	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ee	5b		 pop	 rbx
  000ef	c3		 ret	 0
$LN2@validate_a@2:

; 133  :     }
; 134  :     if (asdl_seq_LEN(args->kw_defaults) != asdl_seq_LEN(args->kwonlyargs)) {

  000f0	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  000f4	48 85 c0	 test	 rax, rax
  000f7	75 04		 jne	 SHORT $LN17@validate_a@2
  000f9	33 c9		 xor	 ecx, ecx
  000fb	eb 03		 jmp	 SHORT $LN18@validate_a@2
$LN17@validate_a@2:
  000fd	48 8b 08	 mov	 rcx, QWORD PTR [rax]
$LN18@validate_a@2:
  00100	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  00104	48 85 c0	 test	 rax, rax
  00107	74 03		 je	 SHORT $LN20@validate_a@2
$LN19@validate_a@2:
  00109	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN20@validate_a@2:
  0010c	48 3b c8	 cmp	 rcx, rax
  0010f	74 20		 je	 SHORT $LN1@validate_a@2

; 135  :         PyErr_SetString(PyExc_ValueError, "length of kwonlyargs is not the same as "
; 136  :                         "kw_defaults on arguments");

  00111	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00118	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EB@KMIALOCA@length?5of?5kwonlyargs?5is?5not?5the?5@
  0011f	e8 00 00 00 00	 call	 PyErr_SetString
$LN24@validate_a@2:

; 137  :         return 0;

  00124	33 c0		 xor	 eax, eax
  00126	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 140  : }

  0012b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0012f	5b		 pop	 rbx
  00130	c3		 ret	 0
$LN1@validate_a@2:

; 138  :     }
; 139  :     return validate_exprs(args->defaults, Load, 0) && validate_exprs(args->kw_defaults, Load, 1);

  00131	45 33 c0	 xor	 r8d, r8d
  00134	8b d7		 mov	 edx, edi
  00136	49 8b c9	 mov	 rcx, r9
  00139	e8 00 00 00 00	 call	 validate_exprs
  0013e	85 c0		 test	 eax, eax
  00140	74 12		 je	 SHORT $LN21@validate_a@2
  00142	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00146	44 8b c7	 mov	 r8d, edi
  00149	8b d7		 mov	 edx, edi
  0014b	e8 00 00 00 00	 call	 validate_exprs
  00150	85 c0		 test	 eax, eax
  00152	75 02		 jne	 SHORT $LN22@validate_a@2
$LN21@validate_a@2:
  00154	33 ff		 xor	 edi, edi
$LN22@validate_a@2:
  00156	8b c7		 mov	 eax, edi
  00158	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 140  : }

  0015d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00161	5b		 pop	 rbx
  00162	c3		 ret	 0
validate_arguments ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@FFDKEMAL@empty?5?$CFs?5on?5?$CFs?$AA@	; `string'
EXTRN	PyErr_Format:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_nonempty_seq DD imagerel validate_nonempty_seq
	DD	imagerel validate_nonempty_seq+57
	DD	imagerel $unwind$validate_nonempty_seq
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_nonempty_seq DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0P@FFDKEMAL@empty?5?$CFs?5on?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@FFDKEMAL@empty?5?$CFs?5on?5?$CFs?$AA@ DB 'empty %s on %s', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT validate_nonempty_seq
_TEXT	SEGMENT
seq$ = 48
what$ = 56
owner$ = 64
validate_nonempty_seq PROC				; COMDAT

; 295  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 296  :     if (asdl_seq_LEN(seq))

  00004	48 85 c9	 test	 rcx, rcx
  00007	74 10		 je	 SHORT $LN1@validate_n
  00009	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  0000d	74 0a		 je	 SHORT $LN1@validate_n

; 297  :         return 1;

  0000f	b8 01 00 00 00	 mov	 eax, 1

; 300  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
$LN1@validate_n:

; 298  :     PyErr_Format(PyExc_ValueError, "empty %s on %s", what, owner);

  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00020	4d 8b c8	 mov	 r9, r8
  00023	4c 8b c2	 mov	 r8, rdx
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@FFDKEMAL@empty?5?$CFs?5on?5?$CFs?$AA@
  0002d	e8 00 00 00 00	 call	 PyErr_Format

; 299  :     return 0;

  00032	33 c0		 xor	 eax, eax

; 300  : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
validate_nonempty_seq ENDP
_TEXT	ENDS
PUBLIC	??_C@_04IEJGKNJ@body?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_body DD imagerel validate_body
	DD	imagerel validate_body+59
	DD	imagerel $unwind$validate_body
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_body DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_04IEJGKNJ@body?$AA@
CONST	SEGMENT
??_C@_04IEJGKNJ@body?$AA@ DB 'body', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT validate_body
_TEXT	SEGMENT
body$ = 48
owner$ = 56
validate_body PROC					; COMDAT

; 311  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 312  :     return validate_nonempty_seq(body, "body", owner) && validate_stmts(body);

  00006	4c 8b c2	 mov	 r8, rdx
  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04IEJGKNJ@body?$AA@
  00010	48 8b d9	 mov	 rbx, rcx
  00013	e8 00 00 00 00	 call	 validate_nonempty_seq
  00018	85 c0		 test	 eax, eax
  0001a	74 17		 je	 SHORT $LN3@validate_b
  0001c	48 8b cb	 mov	 rcx, rbx
  0001f	e8 00 00 00 00	 call	 validate_stmts
  00024	85 c0		 test	 eax, eax
  00026	74 0b		 je	 SHORT $LN3@validate_b
  00028	b8 01 00 00 00	 mov	 eax, 1

; 313  : }

  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5b		 pop	 rbx
  00032	c3		 ret	 0
$LN3@validate_b:

; 312  :     return validate_nonempty_seq(body, "body", owner) && validate_stmts(body);

  00033	33 c0		 xor	 eax, eax

; 313  : }

  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5b		 pop	 rbx
  0003a	c3		 ret	 0
validate_body ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@KCNADAJK@init_normalization?$AA@	; `string'
PUBLIC	??_C@_0BA@DHFJPBFM@?4?4?2Python?2ast?4c?$AA@	; `string'
PUBLIC	??_C@_04IPKEFMHE@?$CIsN?$CJ?$AA@		; `string'
PUBLIC	??_C@_04MHPKJHMM@NFKC?$AA@			; `string'
PUBLIC	??_C@_09MMDNNKKJ@normalize?$AA@			; `string'
PUBLIC	??_C@_0M@JMEAHPBI@unicodedata?$AA@		; `string'
EXTRN	Py_BuildValue:PROC
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyObject_GetAttrString:PROC
EXTRN	PyImport_ImportModuleNoBlock:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$init_normalization DD imagerel init_normalization
	DD	imagerel init_normalization+206
	DD	imagerel $unwind$init_normalization
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init_normalization DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0BD@KCNADAJK@init_normalization?$AA@
CONST	SEGMENT
??_C@_0BD@KCNADAJK@init_normalization?$AA@ DB 'init_normalization', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DHFJPBFM@?4?4?2Python?2ast?4c?$AA@
CONST	SEGMENT
??_C@_0BA@DHFJPBFM@?4?4?2Python?2ast?4c?$AA@ DB '..\Python\ast.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IPKEFMHE@?$CIsN?$CJ?$AA@
CONST	SEGMENT
??_C@_04IPKEFMHE@?$CIsN?$CJ?$AA@ DB '(sN)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MHPKJHMM@NFKC?$AA@
CONST	SEGMENT
??_C@_04MHPKJHMM@NFKC?$AA@ DB 'NFKC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MMDNNKKJ@normalize?$AA@
CONST	SEGMENT
??_C@_09MMDNNKKJ@normalize?$AA@ DB 'normalize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JMEAHPBI@unicodedata?$AA@
CONST	SEGMENT
??_C@_0M@JMEAHPBI@unicodedata?$AA@ DB 'unicodedata', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT init_normalization
_TEXT	SEGMENT
c$ = 64
init_normalization PROC					; COMDAT

; 529  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b d9	 mov	 rbx, rcx

; 530  :     PyObject *m = PyImport_ImportModuleNoBlock("unicodedata");

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@JMEAHPBI@unicodedata?$AA@
  00014	e8 00 00 00 00	 call	 PyImport_ImportModuleNoBlock
  00019	48 8b f8	 mov	 rdi, rax

; 531  :     if (!m)

  0001c	48 85 c0	 test	 rax, rax

; 532  :         return 0;

  0001f	0f 84 84 00 00
	00		 je	 $LN3@init_norma

; 533  :     c->c_normalize = PyObject_GetAttrString(m, "normalize");

  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09MMDNNKKJ@normalize?$AA@
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	e8 00 00 00 00	 call	 PyObject_GetAttrString

; 534  :     Py_DECREF(m);

  00034	48 8b cf	 mov	 rcx, rdi
  00037	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
  0003b	e8 00 00 00 00	 call	 _Py_DecRef

; 535  :     if (!c->c_normalize)

  00040	48 83 7b 18 00	 cmp	 QWORD PTR [rbx+24], 0

; 536  :         return 0;

  00045	74 62		 je	 SHORT $LN3@init_norma

; 537  :     c->c_normalize_args = Py_BuildValue("(sN)", "NFKC", Py_None);

  00047	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04MHPKJHMM@NFKC?$AA@
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04IPKEFMHE@?$CIsN?$CJ?$AA@
  0005c	e8 00 00 00 00	 call	 Py_BuildValue
  00061	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 538  :     if (!c->c_normalize_args) {

  00065	48 85 c0	 test	 rax, rax
  00068	75 4c		 jne	 SHORT $LN5@init_norma

; 539  :         Py_CLEAR(c->c_normalize);

  0006a	4c 8b 4b 18	 mov	 r9, QWORD PTR [rbx+24]
  0006e	4d 85 c9	 test	 r9, r9
  00071	74 36		 je	 SHORT $LN3@init_norma
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@DHFJPBFM@?4?4?2Python?2ast?4c?$AA@
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@KCNADAJK@init_normalization?$AA@
  00081	41 b8 1b 02 00
	00		 mov	 r8d, 539		; 0000021bH
  00087	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0008f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00094	85 c0		 test	 eax, eax
  00096	75 11		 jne	 SHORT $LN3@init_norma
  00098	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  0009c	48 c7 43 18 00
	00 00 00	 mov	 QWORD PTR [rbx+24], 0
  000a4	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@init_norma:

; 540  :         return 0;

  000a9	33 c0		 xor	 eax, eax

; 541  :     }
; 542  :     PyTuple_SET_ITEM(c->c_normalize_args, 1, NULL);
; 543  :     return 1;
; 544  : }

  000ab	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b4	5f		 pop	 rdi
  000b5	c3		 ret	 0
$LN5@init_norma:
  000b6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000bb	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0
  000c3	b8 01 00 00 00	 mov	 eax, 1
  000c8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cc	5f		 pop	 rdi
  000cd	c3		 ret	 0
init_normalization ENDP
_TEXT	ENDS
EXTRN	PyArena_AddPyObject:PROC
EXTRN	PyUnicode_InternInPlace:PROC
EXTRN	PyObject_Call:PROC
EXTRN	PyUnicode_DecodeUTF8:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$new_identifier DD imagerel new_identifier
	DD	imagerel new_identifier+198
	DD	imagerel $unwind$new_identifier
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_identifier DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT new_identifier
_TEXT	SEGMENT
n$ = 48
c$ = 56
id$ = 64
new_identifier PROC					; COMDAT

; 548  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	4c 8b c9	 mov	 r9, rcx

; 549  :     PyObject *id = PyUnicode_DecodeUTF8(n, strlen(n), NULL);

  0000d	48 83 c9 ff	 or	 rcx, -1
  00011	33 c0		 xor	 eax, eax
  00013	49 8b f9	 mov	 rdi, r9
  00016	48 8b da	 mov	 rbx, rdx
  00019	45 33 c0	 xor	 r8d, r8d
  0001c	f2 ae		 repne scasb
  0001e	48 f7 d1	 not	 rcx
  00021	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  00025	49 8b c9	 mov	 rcx, r9
  00028	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8
  0002d	48 8b d0	 mov	 rdx, rax
  00030	48 89 44 24 40	 mov	 QWORD PTR id$[rsp], rax

; 550  :     if (!id)

  00035	48 85 c0	 test	 rax, rax

; 551  :         return NULL;

  00038	74 23		 je	 SHORT $LN8@new_identi

; 552  :     /* PyUnicode_DecodeUTF8 should always return a ready string. */
; 553  :     assert(PyUnicode_IS_READY(id));
; 554  :     /* Check whether there are non-ASCII characters in the
; 555  :        identifier; if so, normalize to NFKC. */
; 556  :     if (!PyUnicode_IS_ASCII(id)) {

  0003a	f6 40 70 40	 test	 BYTE PTR [rax+112], 64	; 00000040H
  0003e	75 5e		 jne	 SHORT $LN3@new_identi

; 557  :         PyObject *id2;
; 558  :         if (!c->c_normalize && !init_normalization(c)) {

  00040	48 83 7b 18 00	 cmp	 QWORD PTR [rbx+24], 0
  00045	75 28		 jne	 SHORT $LN2@new_identi
  00047	48 8b cb	 mov	 rcx, rbx
  0004a	e8 00 00 00 00	 call	 init_normalization
  0004f	85 c0		 test	 eax, eax
  00051	75 17		 jne	 SHORT $LN7@new_identi

; 559  :             Py_DECREF(id);

  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR id$[rsp]
  00058	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@new_identi:

; 560  :             return NULL;

  0005d	33 c0		 xor	 eax, eax

; 572  : }

  0005f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00064	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00068	5f		 pop	 rdi
  00069	c3		 ret	 0
$LN7@new_identi:

; 560  :             return NULL;

  0006a	48 8b 54 24 40	 mov	 rdx, QWORD PTR id$[rsp]
$LN2@new_identi:

; 561  :         }
; 562  :         PyTuple_SET_ITEM(c->c_normalize_args, 1, id);

  0006f	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]

; 563  :         id2 = PyObject_Call(c->c_normalize, c->c_normalize_args, NULL);

  00073	45 33 c0	 xor	 r8d, r8d
  00076	48 89 50 78	 mov	 QWORD PTR [rax+120], rdx
  0007a	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  0007e	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  00082	e8 00 00 00 00	 call	 PyObject_Call

; 564  :         Py_DECREF(id);

  00087	48 8b 4c 24 40	 mov	 rcx, QWORD PTR id$[rsp]
  0008c	48 8b f8	 mov	 rdi, rax
  0008f	e8 00 00 00 00	 call	 _Py_DecRef

; 565  :         if (!id2)

  00094	48 85 ff	 test	 rdi, rdi

; 566  :             return NULL;

  00097	74 c4		 je	 SHORT $LN8@new_identi

; 567  :         id = id2;

  00099	48 89 7c 24 40	 mov	 QWORD PTR id$[rsp], rdi
$LN3@new_identi:

; 568  :     }
; 569  :     PyUnicode_InternInPlace(&id);

  0009e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR id$[rsp]
  000a3	e8 00 00 00 00	 call	 PyUnicode_InternInPlace

; 570  :     PyArena_AddPyObject(c->c_arena, id);

  000a8	48 8b 54 24 40	 mov	 rdx, QWORD PTR id$[rsp]
  000ad	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  000b1	e8 00 00 00 00	 call	 PyArena_AddPyObject

; 571  :     return id;

  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR id$[rsp]

; 572  : }

  000bb	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c4	5f		 pop	 rdi
  000c5	c3		 ret	 0
new_identifier ENDP
_TEXT	ENDS
PUBLIC	??_C@_06EHNNKOPC@?$CINiiN?$CJ?$AA@		; `string'
EXTRN	PyErr_SetObject:PROC
EXTRN	PyExc_SyntaxError:QWORD
EXTRN	PyTuple_Pack:PROC
EXTRN	PyUnicode_FromString:PROC
EXTRN	PyUnicode_DecodeFSDefault:PROC
EXTRN	PyErr_ProgramText:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ast_error DD imagerel ast_error
	DD	imagerel ast_error+369
	DD	imagerel $unwind$ast_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_error DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
xdata	ENDS
;	COMDAT ??_C@_06EHNNKOPC@?$CINiiN?$CJ?$AA@
CONST	SEGMENT
??_C@_06EHNNKOPC@?$CINiiN?$CJ?$AA@ DB '(NiiN)', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ast.c
CONST	ENDS
;	COMDAT ast_error
_TEXT	SEGMENT
c$ = 64
n$ = 72
errmsg$ = 80
ast_error PROC						; COMDAT

; 578  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001a	48 8b ea	 mov	 rbp, rdx

; 579  :     PyObject *value, *errstr, *loc, *tmp;
; 580  :     PyObject *filename_obj;
; 581  : 
; 582  :     loc = PyErr_ProgramText(c->c_filename, LINENO(n));

  0001d	8b 52 10	 mov	 edx, DWORD PTR [rdx+16]
  00020	48 8b f1	 mov	 rsi, rcx
  00023	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00027	4d 8b e0	 mov	 r12, r8
  0002a	e8 00 00 00 00	 call	 PyErr_ProgramText

; 583  :     if (!loc) {

  0002f	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  00036	48 8b f8	 mov	 rdi, rax
  00039	48 85 c0	 test	 rax, rax
  0003c	75 44		 jne	 SHORT $LN7@ast_error

; 584  :         Py_INCREF(Py_None);

  0003e	e8 00 00 00 00	 call	 _Py_PXCTX
  00043	85 c0		 test	 eax, eax
  00045	75 38		 jne	 SHORT $LN11@ast_error
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00055	4c 8b cb	 mov	 r9, rbx
  00058	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0005e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00066	e8 00 00 00 00	 call	 _PyParallel_Guard
  0006b	85 c0		 test	 eax, eax
  0006d	75 09		 jne	 SHORT $LN10@ast_error
  0006f	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00076	74 07		 je	 SHORT $LN11@ast_error
$LN10@ast_error:
  00078	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN11@ast_error:

; 585  :         loc = Py_None;

  0007f	48 8b fb	 mov	 rdi, rbx
$LN7@ast_error:

; 586  :     }
; 587  :     if (c->c_filename) {

  00082	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  00086	48 85 c9	 test	 rcx, rcx
  00089	74 15		 je	 SHORT $LN6@ast_error

; 588  :         filename_obj = PyUnicode_DecodeFSDefault(c->c_filename);

  0008b	e8 00 00 00 00	 call	 PyUnicode_DecodeFSDefault
  00090	48 8b d8	 mov	 rbx, rax

; 589  :         if (!filename_obj) {

  00093	48 85 c0	 test	 rax, rax
  00096	75 49		 jne	 SHORT $LN15@ast_error
$LN19@ast_error:

; 590  :             Py_DECREF(loc);

  00098	48 8b cf	 mov	 rcx, rdi

; 591  :             return 0;

  0009b	e9 af 00 00 00	 jmp	 $LN18@ast_error
$LN6@ast_error:

; 592  :         }
; 593  :     } else {
; 594  :         Py_INCREF(Py_None);

  000a0	e8 00 00 00 00	 call	 _Py_PXCTX
  000a5	85 c0		 test	 eax, eax
  000a7	75 38		 jne	 SHORT $LN15@ast_error
  000a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000b7	4c 8b cb	 mov	 r9, rbx
  000ba	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000c0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000c8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000cd	85 c0		 test	 eax, eax
  000cf	75 09		 jne	 SHORT $LN14@ast_error
  000d1	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000d8	74 07		 je	 SHORT $LN15@ast_error
$LN14@ast_error:
  000da	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN15@ast_error:

; 595  :         filename_obj = Py_None;
; 596  :     }
; 597  :     tmp = Py_BuildValue("(NiiN)", filename_obj, LINENO(n), n->n_col_offset, loc);

  000e1	44 8b 4d 14	 mov	 r9d, DWORD PTR [rbp+20]
  000e5	44 8b 45 10	 mov	 r8d, DWORD PTR [rbp+16]
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06EHNNKOPC@?$CINiiN?$CJ?$AA@
  000f0	48 8b d3	 mov	 rdx, rbx
  000f3	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  000f8	e8 00 00 00 00	 call	 Py_BuildValue
  000fd	48 8b f8	 mov	 rdi, rax

; 598  :     if (!tmp)

  00100	48 85 c0	 test	 rax, rax

; 599  :         return 0;

  00103	74 4f		 je	 SHORT $LN1@ast_error

; 600  :     errstr = PyUnicode_FromString(errmsg);

  00105	49 8b cc	 mov	 rcx, r12
  00108	e8 00 00 00 00	 call	 PyUnicode_FromString
  0010d	48 8b f0	 mov	 rsi, rax

; 601  :     if (!errstr) {

  00110	48 85 c0	 test	 rax, rax

; 602  :         Py_DECREF(tmp);
; 603  :         return 0;

  00113	74 83		 je	 SHORT $LN19@ast_error

; 604  :     }
; 605  :     value = PyTuple_Pack(2, errstr, tmp);

  00115	4c 8b c7	 mov	 r8, rdi
  00118	48 8b d0	 mov	 rdx, rax
  0011b	b9 02 00 00 00	 mov	 ecx, 2
  00120	e8 00 00 00 00	 call	 PyTuple_Pack

; 606  :     Py_DECREF(errstr);

  00125	48 8b ce	 mov	 rcx, rsi
  00128	48 8b d8	 mov	 rbx, rax
  0012b	e8 00 00 00 00	 call	 _Py_DecRef

; 607  :     Py_DECREF(tmp);

  00130	48 8b cf	 mov	 rcx, rdi
  00133	e8 00 00 00 00	 call	 _Py_DecRef

; 608  :     if (value) {

  00138	48 85 db	 test	 rbx, rbx
  0013b	74 17		 je	 SHORT $LN1@ast_error

; 609  :         PyErr_SetObject(PyExc_SyntaxError, value);

  0013d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxError
  00144	48 8b d3	 mov	 rdx, rbx
  00147	e8 00 00 00 00	 call	 PyErr_SetObject

; 610  :         Py_DECREF(value);

  0014c	48 8b cb	 mov	 rcx, rbx
$LN18@ast_error:
  0014f	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@ast_error:

; 611  :     }
; 612  :     return 0;
; 613  : }

  00154	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00159	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0015e	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00163	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00168	33 c0		 xor	 eax, eax
  0016a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0016e	41 5c		 pop	 r12
  00170	c3		 ret	 0
ast_error ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@JJDIMLMN@Non?9statement?5found?3?5?$CFd?5?$CFd?$AA@ ; `string'
EXTRN	Py_FatalError:PROC
EXTRN	__imp_sprintf:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$num_stmts DD imagerel num_stmts
	DD	imagerel num_stmts+238
	DD	imagerel $unwind$num_stmts
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$num_stmts DD imagerel num_stmts+238
	DD	imagerel num_stmts+299
	DD	imagerel $chain$0$num_stmts
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$num_stmts DD imagerel num_stmts+299
	DD	imagerel num_stmts+406
	DD	imagerel $chain$1$num_stmts
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$num_stmts DD 021H
	DD	imagerel num_stmts
	DD	imagerel num_stmts+238
	DD	imagerel $unwind$num_stmts
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$num_stmts DD 020821H
	DD	0165408H
	DD	imagerel num_stmts
	DD	imagerel num_stmts+238
	DD	imagerel $unwind$num_stmts
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$num_stmts DD 071201H
	DD	0186412H
	DD	0173412H
	DD	0140112H
	DD	0700bH
xdata	ENDS
;	COMDAT ??_C@_0BL@JJDIMLMN@Non?9statement?5found?3?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BL@JJDIMLMN@Non?9statement?5found?3?5?$CFd?5?$CFd?$AA@ DB 'Non-sta'
	DB	'tement found: %d %d', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT num_stmts
_TEXT	SEGMENT
buf$22212 = 32
n$ = 176
num_stmts PROC						; COMDAT

; 631  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 632  :     int i, l;
; 633  :     node *ch;
; 634  : 
; 635  :     switch (TYPE(n)) {

  00012	0f bf 01	 movsx	 eax, WORD PTR [rcx]
  00015	48 8b d9	 mov	 rbx, rcx
  00018	2d 00 01 00 00	 sub	 eax, 256		; 00000100H
  0001d	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00020	77 47		 ja	 SHORT $LN5@num_stmts
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL23@num_stmts:
  00030	48 98		 cdqe
  00032	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN31@num_stmts[rdx+rax]
  0003a	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN32@num_stmts[rdx+rax*4]
  00041	48 03 ca	 add	 rcx, rdx
  00044	ff e1		 jmp	 rcx
$LN18@num_stmts:

; 636  :         case single_input:
; 637  :             if (TYPE(CHILD(n, 0)) == NEWLINE)

  00046	48 8b 5b 20	 mov	 rbx, QWORD PTR [rbx+32]
  0004a	66 83 3b 04	 cmp	 WORD PTR [rbx], 4
  0004e	74 3d		 je	 SHORT $LN27@num_stmts

; 638  :                 return 0;
; 639  :             else
; 640  :                 return num_stmts(CHILD(n, 0));

  00050	eb 0a		 jmp	 SHORT $LN28@num_stmts
$LN7@num_stmts:

; 655  :         case suite:
; 656  :             if (NCH(n) == 1)

  00052	83 7b 18 01	 cmp	 DWORD PTR [rbx+24], 1
  00056	75 4c		 jne	 SHORT $LN6@num_stmts
$LN10@num_stmts:

; 657  :                 return num_stmts(CHILD(n, 0));

  00058	48 8b 5b 20	 mov	 rbx, QWORD PTR [rbx+32]
$LN28@num_stmts:

; 632  :     int i, l;
; 633  :     node *ch;
; 634  : 
; 635  :     switch (TYPE(n)) {

  0005c	0f bf 03	 movsx	 eax, WORD PTR [rbx]
  0005f	2d 00 01 00 00	 sub	 eax, 256		; 00000100H
  00064	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00067	76 c7		 jbe	 SHORT $LL23@num_stmts
$LN5@num_stmts:

; 663  :             }
; 664  :         default: {
; 665  :             char buf[128];
; 666  : 
; 667  :             sprintf(buf, "Non-statement found: %d %d",
; 668  :                     TYPE(n), NCH(n));

  00069	44 0f bf 03	 movsx	 r8d, WORD PTR [rbx]
  0006d	44 8b 4b 18	 mov	 r9d, DWORD PTR [rbx+24]
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@JJDIMLMN@Non?9statement?5found?3?5?$CFd?5?$CFd?$AA@
  00078	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$22212[rsp]
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 669  :             Py_FatalError(buf);

  00083	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$22212[rsp]
  00088	e8 00 00 00 00	 call	 Py_FatalError
$LN27@num_stmts:

; 670  :         }
; 671  :     }
; 672  :     assert(0);
; 673  :     return 0;

  0008d	33 c0		 xor	 eax, eax
$LN21@num_stmts:

; 674  : }

  0008f	4c 8d 9c 24 a0
	00 00 00	 lea	 r11, QWORD PTR [rsp+160]
  00097	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  0009b	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  0009f	49 8b e3	 mov	 rsp, r11
  000a2	5f		 pop	 rdi
  000a3	c3		 ret	 0
$LN6@num_stmts:

; 658  :             else {
; 659  :                 l = 0;
; 660  :                 for (i = 2; i < (NCH(n) - 1); i++)

  000a4	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  000a7	bf 02 00 00 00	 mov	 edi, 2
  000ac	33 f6		 xor	 esi, esi
  000ae	ff c8		 dec	 eax
  000b0	3b c7		 cmp	 eax, edi
  000b2	7e 2d		 jle	 SHORT $LN2@num_stmts
  000b4	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@num_stmts:

; 661  :                     l += num_stmts(CHILD(n, i));

  000c0	48 63 cf	 movsxd	 rcx, edi
  000c3	48 8d 14 89	 lea	 rdx, QWORD PTR [rcx+rcx*4]
  000c7	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  000cb	48 8d 0c d1	 lea	 rcx, QWORD PTR [rcx+rdx*8]
  000cf	e8 00 00 00 00	 call	 num_stmts
  000d4	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  000d7	ff c7		 inc	 edi
  000d9	ff c9		 dec	 ecx
  000db	03 f0		 add	 esi, eax
  000dd	3b f9		 cmp	 edi, ecx
  000df	7c df		 jl	 SHORT $LL4@num_stmts
$LN2@num_stmts:

; 662  :                 return l;

  000e1	8b c6		 mov	 eax, esi
  000e3	eb aa		 jmp	 SHORT $LN21@num_stmts
$LN16@num_stmts:

; 641  :         case file_input:
; 642  :             l = 0;

  000e5	33 f6		 xor	 esi, esi

; 643  :             for (i = 0; i < NCH(n); i++) {

  000e7	8b fe		 mov	 edi, esi
  000e9	39 73 18	 cmp	 DWORD PTR [rbx+24], esi
  000ec	7e 3d		 jle	 SHORT $LN12@num_stmts

; 641  :         case file_input:
; 642  :             l = 0;

  000ee	48 89 ac 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rbp
  000f6	ba 0c 01 00 00	 mov	 edx, 268		; 0000010cH
  000fb	8b ee		 mov	 ebp, esi
  000fd	0f 1f 00	 npad	 3
$LL14@num_stmts:

; 644  :                 ch = CHILD(n, i);

  00100	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00104	48 03 cd	 add	 rcx, rbp

; 645  :                 if (TYPE(ch) == stmt)

  00107	66 39 11	 cmp	 WORD PTR [rcx], dx
  0010a	75 0c		 jne	 SHORT $LN13@num_stmts

; 646  :                     l += num_stmts(ch);

  0010c	e8 00 00 00 00	 call	 num_stmts
  00111	ba 0c 01 00 00	 mov	 edx, 268		; 0000010cH
  00116	03 f0		 add	 esi, eax
$LN13@num_stmts:

; 643  :             for (i = 0; i < NCH(n); i++) {

  00118	ff c7		 inc	 edi
  0011a	48 83 c5 28	 add	 rbp, 40			; 00000028H
  0011e	3b 7b 18	 cmp	 edi, DWORD PTR [rbx+24]
  00121	7c dd		 jl	 SHORT $LL14@num_stmts
  00123	48 8b ac 24 b0
	00 00 00	 mov	 rbp, QWORD PTR [rsp+176]
$LN12@num_stmts:

; 647  :             }
; 648  :             return l;

  0012b	8b c6		 mov	 eax, esi
  0012d	e9 5d ff ff ff	 jmp	 $LN21@num_stmts
$LN9@num_stmts:

; 649  :         case stmt:
; 650  :             return num_stmts(CHILD(n, 0));
; 651  :         case compound_stmt:
; 652  :             return 1;

  00132	b8 01 00 00 00	 mov	 eax, 1
  00137	e9 53 ff ff ff	 jmp	 $LN21@num_stmts
$LN8@num_stmts:

; 653  :         case simple_stmt:
; 654  :             return NCH(n) / 2; /* Divide by 2 to remove count of semi-colons */

  0013c	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  0013f	99		 cdq
  00140	2b c2		 sub	 eax, edx
  00142	d1 f8		 sar	 eax, 1
  00144	e9 46 ff ff ff	 jmp	 $LN21@num_stmts
  00149	0f 1f 00	 npad	 3
$LN32@num_stmts:

; 674  : }

  0014c	00 00 00 00	 DD	 $LN18@num_stmts
  00150	00 00 00 00	 DD	 $LN16@num_stmts
  00154	00 00 00 00	 DD	 $LN10@num_stmts
  00158	00 00 00 00	 DD	 $LN8@num_stmts
  0015c	00 00 00 00	 DD	 $LN9@num_stmts
  00160	00 00 00 00	 DD	 $LN7@num_stmts
  00164	00 00 00 00	 DD	 $LN5@num_stmts
$LN31@num_stmts:
  00168	00		 DB	 0
  00169	01		 DB	 1
  0016a	06		 DB	 6
  0016b	06		 DB	 6
  0016c	06		 DB	 6
  0016d	06		 DB	 6
  0016e	06		 DB	 6
  0016f	06		 DB	 6
  00170	06		 DB	 6
  00171	06		 DB	 6
  00172	06		 DB	 6
  00173	06		 DB	 6
  00174	02		 DB	 2
  00175	03		 DB	 3
  00176	06		 DB	 6
  00177	06		 DB	 6
  00178	06		 DB	 6
  00179	06		 DB	 6
  0017a	06		 DB	 6
  0017b	06		 DB	 6
  0017c	06		 DB	 6
  0017d	06		 DB	 6
  0017e	06		 DB	 6
  0017f	06		 DB	 6
  00180	06		 DB	 6
  00181	06		 DB	 6
  00182	06		 DB	 6
  00183	06		 DB	 6
  00184	06		 DB	 6
  00185	06		 DB	 6
  00186	06		 DB	 6
  00187	06		 DB	 6
  00188	06		 DB	 6
  00189	06		 DB	 6
  0018a	06		 DB	 6
  0018b	06		 DB	 6
  0018c	06		 DB	 6
  0018d	04		 DB	 4
  0018e	06		 DB	 6
  0018f	06		 DB	 6
  00190	06		 DB	 6
  00191	06		 DB	 6
  00192	06		 DB	 6
  00193	06		 DB	 6
  00194	06		 DB	 6
  00195	05		 DB	 5
num_stmts ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT get_operator
_TEXT	SEGMENT
n$ = 8
get_operator PROC					; COMDAT

; 810  :     switch (TYPE(n)) {

  00000	0f bf 01	 movsx	 eax, WORD PTR [rcx]
  00003	83 c0 f2	 add	 eax, -14
  00006	83 f8 21	 cmp	 eax, 33			; 00000021H
  00009	77 5f		 ja	 SHORT $LN1@get_operat
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00012	48 98		 cdqe
  00014	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN17@get_operat[rdx+rax]
  0001c	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN18@get_operat[rdx+rax*4]
  00023	48 03 ca	 add	 rcx, rdx
  00026	ff e1		 jmp	 rcx
$LN12@get_operat:

; 811  :         case VBAR:
; 812  :             return BitOr;

  00028	b8 09 00 00 00	 mov	 eax, 9

; 835  :     }
; 836  : }

  0002d	c3		 ret	 0
$LN11@get_operat:

; 813  :         case CIRCUMFLEX:
; 814  :             return BitXor;

  0002e	b8 0a 00 00 00	 mov	 eax, 10

; 835  :     }
; 836  : }

  00033	c3		 ret	 0
$LN10@get_operat:

; 815  :         case AMPER:
; 816  :             return BitAnd;

  00034	b8 0b 00 00 00	 mov	 eax, 11

; 835  :     }
; 836  : }

  00039	c3		 ret	 0
$LN9@get_operat:

; 817  :         case LEFTSHIFT:
; 818  :             return LShift;

  0003a	b8 07 00 00 00	 mov	 eax, 7

; 835  :     }
; 836  : }

  0003f	c3		 ret	 0
$LN8@get_operat:

; 819  :         case RIGHTSHIFT:
; 820  :             return RShift;

  00040	b8 08 00 00 00	 mov	 eax, 8

; 835  :     }
; 836  : }

  00045	c3		 ret	 0
$LN7@get_operat:

; 821  :         case PLUS:
; 822  :             return Add;

  00046	b8 01 00 00 00	 mov	 eax, 1

; 835  :     }
; 836  : }

  0004b	c3		 ret	 0
$LN6@get_operat:

; 823  :         case MINUS:
; 824  :             return Sub;

  0004c	b8 02 00 00 00	 mov	 eax, 2

; 835  :     }
; 836  : }

  00051	c3		 ret	 0
$LN5@get_operat:

; 825  :         case STAR:
; 826  :             return Mult;

  00052	b8 03 00 00 00	 mov	 eax, 3

; 835  :     }
; 836  : }

  00057	c3		 ret	 0
$LN4@get_operat:

; 827  :         case SLASH:
; 828  :             return Div;

  00058	b8 04 00 00 00	 mov	 eax, 4

; 835  :     }
; 836  : }

  0005d	c3		 ret	 0
$LN3@get_operat:

; 829  :         case DOUBLESLASH:
; 830  :             return FloorDiv;

  0005e	b8 0c 00 00 00	 mov	 eax, 12

; 835  :     }
; 836  : }

  00063	c3		 ret	 0
$LN2@get_operat:

; 831  :         case PERCENT:
; 832  :             return Mod;

  00064	b8 05 00 00 00	 mov	 eax, 5

; 835  :     }
; 836  : }

  00069	c3		 ret	 0
$LN1@get_operat:

; 833  :         default:
; 834  :             return (operator_ty)0;

  0006a	33 c0		 xor	 eax, eax

; 835  :     }
; 836  : }

  0006c	c3		 ret	 0
  0006d	0f 1f 00	 npad	 3
$LN18@get_operat:
  00070	00 00 00 00	 DD	 $LN7@get_operat
  00074	00 00 00 00	 DD	 $LN6@get_operat
  00078	00 00 00 00	 DD	 $LN5@get_operat
  0007c	00 00 00 00	 DD	 $LN4@get_operat
  00080	00 00 00 00	 DD	 $LN12@get_operat
  00084	00 00 00 00	 DD	 $LN10@get_operat
  00088	00 00 00 00	 DD	 $LN2@get_operat
  0008c	00 00 00 00	 DD	 $LN11@get_operat
  00090	00 00 00 00	 DD	 $LN9@get_operat
  00094	00 00 00 00	 DD	 $LN8@get_operat
  00098	00 00 00 00	 DD	 $LN3@get_operat
  0009c	00 00 00 00	 DD	 $LN1@get_operat
$LN17@get_operat:
  000a0	00		 DB	 0
  000a1	01		 DB	 1
  000a2	02		 DB	 2
  000a3	03		 DB	 3
  000a4	04		 DB	 4
  000a5	05		 DB	 5
  000a6	0b		 DB	 11
  000a7	0b		 DB	 11
  000a8	0b		 DB	 11
  000a9	0b		 DB	 11
  000aa	06		 DB	 6
  000ab	0b		 DB	 11
  000ac	0b		 DB	 11
  000ad	0b		 DB	 11
  000ae	0b		 DB	 11
  000af	0b		 DB	 11
  000b0	0b		 DB	 11
  000b1	0b		 DB	 11
  000b2	07		 DB	 7
  000b3	08		 DB	 8
  000b4	09		 DB	 9
  000b5	0b		 DB	 11
  000b6	0b		 DB	 11
  000b7	0b		 DB	 11
  000b8	0b		 DB	 11
  000b9	0b		 DB	 11
  000ba	0b		 DB	 11
  000bb	0b		 DB	 11
  000bc	0b		 DB	 11
  000bd	0b		 DB	 11
  000be	0b		 DB	 11
  000bf	0b		 DB	 11
  000c0	0b		 DB	 11
  000c1	0a		 DB	 10
get_operator ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@DOGDIKCJ@assignment?5to?5keyword?$AA@	; `string'
PUBLIC	??_C@_09PMJCCPKK@__debug__?$AA@			; `string'
EXTRN	PyUnicode_CompareWithASCIIString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$forbidden_name DD imagerel forbidden_name
	DD	imagerel forbidden_name+145
	DD	imagerel $unwind$forbidden_name
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$forbidden_name DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_0BG@DOGDIKCJ@assignment?5to?5keyword?$AA@
CONST	SEGMENT
??_C@_0BG@DOGDIKCJ@assignment?5to?5keyword?$AA@ DB 'assignment to keyword'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09PMJCCPKK@__debug__?$AA@
CONST	SEGMENT
??_C@_09PMJCCPKK@__debug__?$AA@ DB '__debug__', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT forbidden_name
_TEXT	SEGMENT
c$ = 48
name$ = 56
n$ = 64
full_checks$ = 72
forbidden_name PROC					; COMDAT

; 847  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fa	 mov	 rdi, rdx
  00017	48 8b e9	 mov	 rbp, rcx

; 848  :     assert(PyUnicode_Check(name));
; 849  :     if (PyUnicode_CompareWithASCIIString(name, "__debug__") == 0) {

  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09PMJCCPKK@__debug__?$AA@
  00021	48 8b cf	 mov	 rcx, rdi
  00024	41 8b d9	 mov	 ebx, r9d
  00027	49 8b f0	 mov	 rsi, r8
  0002a	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  0002f	85 c0		 test	 eax, eax
  00031	75 19		 jne	 SHORT $LN6@forbidden_
$LN10@forbidden_:

; 850  :         ast_error(c, n, "assignment to keyword");

  00033	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BG@DOGDIKCJ@assignment?5to?5keyword?$AA@
  0003a	48 8b d6	 mov	 rdx, rsi
  0003d	48 8b cd	 mov	 rcx, rbp
  00040	e8 00 00 00 00	 call	 ast_error

; 851  :         return 1;

  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	eb 30		 jmp	 SHORT $LN7@forbidden_
$LN6@forbidden_:

; 852  :     }
; 853  :     if (full_checks) {

  0004c	85 db		 test	 ebx, ebx
  0004e	74 2a		 je	 SHORT $LN2@forbidden_

; 854  :         const char **p;
; 855  :         for (p = FORBIDDEN; *p; p++) {

  00050	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR FORBIDDEN, 0
  00058	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:FORBIDDEN
  0005f	74 19		 je	 SHORT $LN2@forbidden_
$LL4@forbidden_:

; 856  :             if (PyUnicode_CompareWithASCIIString(name, *p) == 0) {

  00061	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00064	48 8b cf	 mov	 rcx, rdi
  00067	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  0006c	85 c0		 test	 eax, eax
  0006e	74 c3		 je	 SHORT $LN10@forbidden_

; 854  :         const char **p;
; 855  :         for (p = FORBIDDEN; *p; p++) {

  00070	48 83 c3 08	 add	 rbx, 8
  00074	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00078	75 e7		 jne	 SHORT $LL4@forbidden_
$LN2@forbidden_:

; 857  :                 ast_error(c, n, "assignment to keyword");
; 858  :                 return 1;
; 859  :             }
; 860  :         }
; 861  :     }
; 862  :     return 0;

  0007a	33 c0		 xor	 eax, eax
$LN7@forbidden_:

; 863  : }

  0007c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00081	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00086	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0008b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008f	5f		 pop	 rdi
  00090	c3		 ret	 0
forbidden_name ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@BFFKDNIK@unexpected?5expression?5in?5assignm@ ; `string'
PUBLIC	??_C@_0M@PHBALMFF@can?8t?5?$CFs?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_06FOBLBEIN@delete?$AA@			; `string'
PUBLIC	??_C@_09PFNDHGIG@assign?5to?$AA@		; `string'
PUBLIC	??_C@_0BH@JNJLIJED@conditional?5expression?$AA@	; `string'
PUBLIC	??_C@_0L@ECKICNFF@comparison?$AA@		; `string'
PUBLIC	??_C@_08KKBGFFMJ@Ellipsis?$AA@			; `string'
PUBLIC	??_C@_07IDLNMGBF@literal?$AA@			; `string'
PUBLIC	??_C@_0BD@MGEJOJHP@dict?5comprehension?$AA@	; `string'
PUBLIC	??_C@_0BC@GCKMFGBM@set?5comprehension?$AA@	; `string'
PUBLIC	??_C@_0BD@NILJGNIH@list?5comprehension?$AA@	; `string'
PUBLIC	??_C@_0BB@BIJIBHEI@yield?5expression?$AA@	; `string'
PUBLIC	??_C@_0BF@DBHAFLDO@generator?5expression?$AA@	; `string'
PUBLIC	??_C@_08LHJFAFGD@operator?$AA@			; `string'
PUBLIC	??_C@_0O@PKNENLIP@function?5call?$AA@		; `string'
PUBLIC	??_C@_06COJIGPIB@lambda?$AA@			; `string'
PUBLIC	??_C@_02HCKGKOFO@?$CI?$CJ?$AA@			; `string'
EXTRN	PyExc_SystemError:QWORD
EXTRN	PyOS_snprintf:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_context DD imagerel set_context
	DD	imagerel set_context+636
	DD	imagerel $unwind$set_context
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_context DD 071901H
	DD	0313419H
	DD	02c0119H
	DD	060117012H
	DD	05010H
xdata	ENDS
;	COMDAT ??_C@_0DB@BFFKDNIK@unexpected?5expression?5in?5assignm@
CONST	SEGMENT
??_C@_0DB@BFFKDNIK@unexpected?5expression?5in?5assignm@ DB 'unexpected ex'
	DB	'pression in assignment %d (line %d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PHBALMFF@can?8t?5?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0M@PHBALMFF@can?8t?5?$CFs?5?$CFs?$AA@ DB 'can''t %s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FOBLBEIN@delete?$AA@
CONST	SEGMENT
??_C@_06FOBLBEIN@delete?$AA@ DB 'delete', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PFNDHGIG@assign?5to?$AA@
CONST	SEGMENT
??_C@_09PFNDHGIG@assign?5to?$AA@ DB 'assign to', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JNJLIJED@conditional?5expression?$AA@
CONST	SEGMENT
??_C@_0BH@JNJLIJED@conditional?5expression?$AA@ DB 'conditional expressio'
	DB	'n', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ECKICNFF@comparison?$AA@
CONST	SEGMENT
??_C@_0L@ECKICNFF@comparison?$AA@ DB 'comparison', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KKBGFFMJ@Ellipsis?$AA@
CONST	SEGMENT
??_C@_08KKBGFFMJ@Ellipsis?$AA@ DB 'Ellipsis', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IDLNMGBF@literal?$AA@
CONST	SEGMENT
??_C@_07IDLNMGBF@literal?$AA@ DB 'literal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MGEJOJHP@dict?5comprehension?$AA@
CONST	SEGMENT
??_C@_0BD@MGEJOJHP@dict?5comprehension?$AA@ DB 'dict comprehension', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GCKMFGBM@set?5comprehension?$AA@
CONST	SEGMENT
??_C@_0BC@GCKMFGBM@set?5comprehension?$AA@ DB 'set comprehension', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NILJGNIH@list?5comprehension?$AA@
CONST	SEGMENT
??_C@_0BD@NILJGNIH@list?5comprehension?$AA@ DB 'list comprehension', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BIJIBHEI@yield?5expression?$AA@
CONST	SEGMENT
??_C@_0BB@BIJIBHEI@yield?5expression?$AA@ DB 'yield expression', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DBHAFLDO@generator?5expression?$AA@
CONST	SEGMENT
??_C@_0BF@DBHAFLDO@generator?5expression?$AA@ DB 'generator expression', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LHJFAFGD@operator?$AA@
CONST	SEGMENT
??_C@_08LHJFAFGD@operator?$AA@ DB 'operator', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PKNENLIP@function?5call?$AA@
CONST	SEGMENT
??_C@_0O@PKNENLIP@function?5call?$AA@ DB 'function call', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06COJIGPIB@lambda?$AA@
CONST	SEGMENT
??_C@_06COJIGPIB@lambda?$AA@ DB 'lambda', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_02HCKGKOFO@?$CI?$CJ?$AA@ DB '()', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT set_context
_TEXT	SEGMENT
buf$22393 = 48
c$ = 384
e$ = 392
ctx$ = 400
n$ = 408
set_context PROC					; COMDAT

; 874  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 81 ec 60 01
	00 00		 sub	 rsp, 352		; 00000160H
  00019	41 8b f0	 mov	 esi, r8d

; 875  :     asdl_seq *s = NULL;
; 876  :     /* If a particular expression type can't be used for assign / delete,
; 877  :        set expr_name to its name and an error message will be generated.
; 878  :     */
; 879  :     const char* expr_name = NULL;
; 880  : 
; 881  :     /* The ast defines augmented store and load contexts, but the
; 882  :        implementation here doesn't actually use them.  The code may be
; 883  :        a little more complex than necessary as a result.  It also means
; 884  :        that expressions in an augmented assignment have a Store context.
; 885  :        Consider restructuring so that augmented assignment uses
; 886  :        set_context(), too.
; 887  :     */
; 888  :     assert(ctx != AugStore && ctx != AugLoad);
; 889  : 
; 890  :     switch (e->kind) {

  0001c	44 8b 02	 mov	 r8d, DWORD PTR [rdx]
  0001f	4d 8b d9	 mov	 r11, r9
  00022	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  00026	48 8b da	 mov	 rbx, rdx
  00029	83 f8 18	 cmp	 eax, 24
  0002c	0f 87 b8 01 00
	00		 ja	 $LN7@set_contex
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00039	48 98		 cdqe
  0003b	44 8b 94 82 00
	00 00 00	 mov	 r10d, DWORD PTR $LN43@set_contex[rdx+rax*4]
  00043	4c 03 d2	 add	 r10, rdx
  00046	41 ff e2	 jmp	 r10
$LN31@set_contex:

; 891  :         case Attribute_kind:
; 892  :             e->v.Attribute.ctx = ctx;

  00049	89 73 18	 mov	 DWORD PTR [rbx+24], esi

; 893  :             if (ctx == Store && forbidden_name(c, e->v.Attribute.attr, n, 1))

  0004c	83 fe 02	 cmp	 esi, 2
  0004f	75 18		 jne	 SHORT $LN2@set_contex
  00051	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  00055	44 8d 4e ff	 lea	 r9d, QWORD PTR [rsi-1]
  00059	4d 8b c3	 mov	 r8, r11
  0005c	e8 00 00 00 00	 call	 forbidden_name
  00061	85 c0		 test	 eax, eax
  00063	0f 85 98 01 00
	00		 jne	 $LN44@set_contex
$LN2@set_contex:

; 991  :                 return 0;
; 992  :         }
; 993  :     }
; 994  :     return 1;

  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	e9 90 01 00 00	 jmp	 $LN34@set_contex
$LN29@set_contex:

; 894  :                 return 0;
; 895  :             break;
; 896  :         case Subscript_kind:
; 897  :             e->v.Subscript.ctx = ctx;

  00073	89 73 18	 mov	 DWORD PTR [rbx+24], esi

; 991  :                 return 0;
; 992  :         }
; 993  :     }
; 994  :     return 1;

  00076	b8 01 00 00 00	 mov	 eax, 1
  0007b	e9 83 01 00 00	 jmp	 $LN34@set_contex
$LN28@set_contex:

; 898  :             break;
; 899  :         case Starred_kind:
; 900  :             e->v.Starred.ctx = ctx;
; 901  :             if (!set_context(c, e->v.Starred.value, ctx, n))

  00080	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00084	44 8b c6	 mov	 r8d, esi
  00087	89 73 10	 mov	 DWORD PTR [rbx+16], esi
  0008a	e8 00 00 00 00	 call	 set_context
  0008f	85 c0		 test	 eax, eax
  00091	75 d6		 jne	 SHORT $LN2@set_contex

; 902  :                 return 0;

  00093	e9 69 01 00 00	 jmp	 $LN44@set_contex
$LN26@set_contex:

; 903  :             break;
; 904  :         case Name_kind:
; 905  :             if (ctx == Store) {

  00098	83 fe 02	 cmp	 esi, 2
  0009b	75 18		 jne	 SHORT $LN24@set_contex

; 906  :                 if (forbidden_name(c, e->v.Name.id, n, 1))

  0009d	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  000a1	44 8d 4e ff	 lea	 r9d, QWORD PTR [rsi-1]
  000a5	4d 8b c3	 mov	 r8, r11
  000a8	e8 00 00 00 00	 call	 forbidden_name
  000ad	85 c0		 test	 eax, eax

; 907  :                     return 0; /* forbidden_name() calls ast_error() */

  000af	0f 85 4c 01 00
	00		 jne	 $LN44@set_contex
$LN24@set_contex:

; 908  :             }
; 909  :             e->v.Name.ctx = ctx;

  000b5	89 73 10	 mov	 DWORD PTR [rbx+16], esi

; 991  :                 return 0;
; 992  :         }
; 993  :     }
; 994  :     return 1;

  000b8	b8 01 00 00 00	 mov	 eax, 1
  000bd	e9 41 01 00 00	 jmp	 $LN34@set_contex
$LN23@set_contex:

; 910  :             break;
; 911  :         case List_kind:
; 912  :             e->v.List.ctx = ctx;
; 913  :             s = e->v.List.elts;

  000c2	48 8b 6b 08	 mov	 rbp, QWORD PTR [rbx+8]

; 914  :             break;

  000c6	eb 10		 jmp	 SHORT $LN45@set_contex
$LN22@set_contex:

; 915  :         case Tuple_kind:
; 916  :             if (asdl_seq_LEN(e->v.Tuple.elts))  {

  000c8	48 8b 6b 08	 mov	 rbp, QWORD PTR [rbx+8]
  000cc	48 85 ed	 test	 rbp, rbp
  000cf	74 5a		 je	 SHORT $LN21@set_contex
  000d1	48 83 7d 00 00	 cmp	 QWORD PTR [rbp], 0
  000d6	74 53		 je	 SHORT $LN21@set_contex
$LN45@set_contex:

; 917  :                 e->v.Tuple.ctx = ctx;

  000d8	89 73 10	 mov	 DWORD PTR [rbx+16], esi

; 981  :     }
; 982  : 
; 983  :     /* If the LHS is a list or tuple, we need to set the assignment
; 984  :        context for all the contained elements.
; 985  :     */
; 986  :     if (s) {

  000db	48 85 ed	 test	 rbp, rbp
  000de	74 89		 je	 SHORT $LN2@set_contex

; 987  :         int i;
; 988  : 
; 989  :         for (i = 0; i < asdl_seq_LEN(s); i++) {

  000e0	33 db		 xor	 ebx, ebx
  000e2	48 8d 7d 08	 lea	 rdi, QWORD PTR [rbp+8]
  000e6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@set_contex:
  000f0	48 63 c3	 movsxd	 rax, ebx
  000f3	48 3b 45 00	 cmp	 rax, QWORD PTR [rbp]
  000f7	0f 8d 6c ff ff
	ff		 jge	 $LN2@set_contex

; 990  :             if (!set_context(c, (expr_ty)asdl_seq_GET(s, i), ctx, n))

  000fd	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00100	4d 8b cb	 mov	 r9, r11
  00103	44 8b c6	 mov	 r8d, esi
  00106	e8 00 00 00 00	 call	 set_context
  0010b	85 c0		 test	 eax, eax
  0010d	0f 84 ee 00 00
	00		 je	 $LN44@set_contex

; 987  :         int i;
; 988  : 
; 989  :         for (i = 0; i < asdl_seq_LEN(s); i++) {

  00113	4c 8b 9c 24 98
	01 00 00	 mov	 r11, QWORD PTR n$[rsp]
  0011b	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00123	ff c3		 inc	 ebx
  00125	48 83 c7 08	 add	 rdi, 8
  00129	eb c5		 jmp	 SHORT $LL4@set_contex
$LN21@set_contex:

; 918  :                 s = e->v.Tuple.elts;
; 919  :             }
; 920  :             else {
; 921  :                 expr_name = "()";

  0012b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@

; 922  :             }
; 923  :             break;

  00132	eb 6a		 jmp	 SHORT $LN42@set_contex
$LN19@set_contex:

; 924  :         case Lambda_kind:
; 925  :             expr_name = "lambda";

  00134	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06COJIGPIB@lambda?$AA@

; 926  :             break;

  0013b	eb 61		 jmp	 SHORT $LN42@set_contex
$LN18@set_contex:

; 927  :         case Call_kind:
; 928  :             expr_name = "function call";

  0013d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0O@PKNENLIP@function?5call?$AA@

; 929  :             break;

  00144	eb 58		 jmp	 SHORT $LN42@set_contex
$LN17@set_contex:

; 930  :         case BoolOp_kind:
; 931  :         case BinOp_kind:
; 932  :         case UnaryOp_kind:
; 933  :             expr_name = "operator";

  00146	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08LHJFAFGD@operator?$AA@

; 934  :             break;

  0014d	eb 4f		 jmp	 SHORT $LN42@set_contex
$LN16@set_contex:

; 935  :         case GeneratorExp_kind:
; 936  :             expr_name = "generator expression";

  0014f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@DBHAFLDO@generator?5expression?$AA@

; 937  :             break;

  00156	eb 46		 jmp	 SHORT $LN42@set_contex
$LN15@set_contex:

; 938  :         case Yield_kind:
; 939  :         case YieldFrom_kind:
; 940  :             expr_name = "yield expression";

  00158	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BB@BIJIBHEI@yield?5expression?$AA@

; 941  :             break;

  0015f	eb 3d		 jmp	 SHORT $LN42@set_contex
$LN14@set_contex:

; 942  :         case ListComp_kind:
; 943  :             expr_name = "list comprehension";

  00161	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@NILJGNIH@list?5comprehension?$AA@

; 944  :             break;

  00168	eb 34		 jmp	 SHORT $LN42@set_contex
$LN13@set_contex:

; 945  :         case SetComp_kind:
; 946  :             expr_name = "set comprehension";

  0016a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@GCKMFGBM@set?5comprehension?$AA@

; 947  :             break;

  00171	eb 2b		 jmp	 SHORT $LN42@set_contex
$LN12@set_contex:

; 948  :         case DictComp_kind:
; 949  :             expr_name = "dict comprehension";

  00173	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@MGEJOJHP@dict?5comprehension?$AA@

; 950  :             break;

  0017a	eb 22		 jmp	 SHORT $LN42@set_contex
$LN11@set_contex:

; 951  :         case Dict_kind:
; 952  :         case Set_kind:
; 953  :         case Num_kind:
; 954  :         case Str_kind:
; 955  :         case Bytes_kind:
; 956  :             expr_name = "literal";

  0017c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07IDLNMGBF@literal?$AA@

; 957  :             break;

  00183	eb 19		 jmp	 SHORT $LN42@set_contex
$LN10@set_contex:

; 958  :         case Ellipsis_kind:
; 959  :             expr_name = "Ellipsis";

  00185	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08KKBGFFMJ@Ellipsis?$AA@

; 960  :             break;

  0018c	eb 10		 jmp	 SHORT $LN42@set_contex
$LN9@set_contex:

; 961  :         case Compare_kind:
; 962  :             expr_name = "comparison";

  0018e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0L@ECKICNFF@comparison?$AA@

; 963  :             break;

  00195	eb 07		 jmp	 SHORT $LN42@set_contex
$LN8@set_contex:

; 964  :         case IfExp_kind:
; 965  :             expr_name = "conditional expression";

  00197	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@JNJLIJED@conditional?5expression?$AA@
$LN42@set_contex:

; 972  :     }
; 973  :     /* Check for error string set by switch */
; 974  :     if (expr_name) {
; 975  :         char buf[300];
; 976  :         PyOS_snprintf(buf, sizeof(buf),
; 977  :                       "can't %s %s",
; 978  :                       ctx == Store ? "assign to" : "delete",
; 979  :                       expr_name);

  0019e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09PFNDHGIG@assign?5to?$AA@
  001a5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_06FOBLBEIN@delete?$AA@
  001ac	83 fe 02	 cmp	 esi, 2
  001af	4c 0f 44 c9	 cmove	 r9, rcx
  001b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@PHBALMFF@can?8t?5?$CFs?5?$CFs?$AA@
  001ba	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$22393[rsp]
  001bf	ba 2c 01 00 00	 mov	 edx, 300		; 0000012cH
  001c4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c9	e8 00 00 00 00	 call	 PyOS_snprintf

; 980  :         return ast_error(c, n, buf);

  001ce	48 8b 94 24 98
	01 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  001d6	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001de	4c 8d 44 24 30	 lea	 r8, QWORD PTR buf$22393[rsp]
  001e3	e8 00 00 00 00	 call	 ast_error
  001e8	eb 19		 jmp	 SHORT $LN34@set_contex
$LN7@set_contex:

; 966  :             break;
; 967  :         default:
; 968  :             PyErr_Format(PyExc_SystemError,
; 969  :                          "unexpected expression in assignment %d (line %d)",
; 970  :                          e->kind, e->lineno);

  001ea	44 8b 4b 30	 mov	 r9d, DWORD PTR [rbx+48]
  001ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  001f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@BFFKDNIK@unexpected?5expression?5in?5assignm@
  001fc	e8 00 00 00 00	 call	 PyErr_Format
$LN44@set_contex:

; 971  :             return 0;

  00201	33 c0		 xor	 eax, eax
$LN34@set_contex:

; 995  : }

  00203	48 8b 9c 24 88
	01 00 00	 mov	 rbx, QWORD PTR [rsp+392]
  0020b	48 81 c4 60 01
	00 00		 add	 rsp, 352		; 00000160H
  00212	5f		 pop	 rdi
  00213	5e		 pop	 rsi
  00214	5d		 pop	 rbp
  00215	c3		 ret	 0
  00216	66 90		 npad	 2
$LN43@set_contex:
  00218	00 00 00 00	 DD	 $LN17@set_contex
  0021c	00 00 00 00	 DD	 $LN17@set_contex
  00220	00 00 00 00	 DD	 $LN17@set_contex
  00224	00 00 00 00	 DD	 $LN19@set_contex
  00228	00 00 00 00	 DD	 $LN8@set_contex
  0022c	00 00 00 00	 DD	 $LN11@set_contex
  00230	00 00 00 00	 DD	 $LN11@set_contex
  00234	00 00 00 00	 DD	 $LN14@set_contex
  00238	00 00 00 00	 DD	 $LN13@set_contex
  0023c	00 00 00 00	 DD	 $LN12@set_contex
  00240	00 00 00 00	 DD	 $LN16@set_contex
  00244	00 00 00 00	 DD	 $LN15@set_contex
  00248	00 00 00 00	 DD	 $LN15@set_contex
  0024c	00 00 00 00	 DD	 $LN9@set_contex
  00250	00 00 00 00	 DD	 $LN18@set_contex
  00254	00 00 00 00	 DD	 $LN11@set_contex
  00258	00 00 00 00	 DD	 $LN11@set_contex
  0025c	00 00 00 00	 DD	 $LN11@set_contex
  00260	00 00 00 00	 DD	 $LN10@set_contex
  00264	00 00 00 00	 DD	 $LN31@set_contex
  00268	00 00 00 00	 DD	 $LN29@set_contex
  0026c	00 00 00 00	 DD	 $LN28@set_contex
  00270	00 00 00 00	 DD	 $LN26@set_contex
  00274	00 00 00 00	 DD	 $LN23@set_contex
  00278	00 00 00 00	 DD	 $LN22@set_contex
set_context ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@BNGEDCBG@invalid?5augassign?3?5?$CFs?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_augassign DD imagerel ast_for_augassign
	DD	imagerel ast_for_augassign+344
	DD	imagerel $unwind$ast_for_augassign
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_augassign DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BG@BNGEDCBG@invalid?5augassign?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BG@BNGEDCBG@invalid?5augassign?3?5?$CFs?$AA@ DB 'invalid augassign'
	DB	': %s', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ast_for_augassign
_TEXT	SEGMENT
n$ = 48
ast_for_augassign PROC					; COMDAT

; 999  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1000 :     REQ(n, augassign);
; 1001 :     n = CHILD(n, 0);

  00004	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]

; 1002 :     switch (STR(n)[0]) {

  00008	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0000c	41 0f be 00	 movsx	 eax, BYTE PTR [r8]
  00010	83 c0 db	 add	 eax, -37		; ffffffffffffffdbH
  00013	83 f8 57	 cmp	 eax, 87			; 00000057H
  00016	0f 87 9b 00 00
	00		 ja	 $LN2@ast_for_au
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00023	48 98		 cdqe
  00025	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN20@ast_for_au[rdx+rax]
  0002d	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN21@ast_for_au[rdx+rax*4]
  00034	48 03 ca	 add	 rcx, rdx
  00037	ff e1		 jmp	 rcx
$LN15@ast_for_au:

; 1003 :         case '+':
; 1004 :             return Add;

  00039	b8 01 00 00 00	 mov	 eax, 1

; 1032 :     }
; 1033 : }

  0003e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00042	c3		 ret	 0
$LN14@ast_for_au:

; 1005 :         case '-':
; 1006 :             return Sub;

  00043	b8 02 00 00 00	 mov	 eax, 2

; 1032 :     }
; 1033 : }

  00048	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004c	c3		 ret	 0
$LN13@ast_for_au:

; 1007 :         case '/':
; 1008 :             if (STR(n)[1] == '/')

  0004d	41 80 78 01 2f	 cmp	 BYTE PTR [r8+1], 47	; 0000002fH
  00052	b8 04 00 00 00	 mov	 eax, 4
  00057	b9 0c 00 00 00	 mov	 ecx, 12
  0005c	0f 44 c1	 cmove	 eax, ecx

; 1032 :     }
; 1033 : }

  0005f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00063	c3		 ret	 0
$LN11@ast_for_au:

; 1009 :                 return FloorDiv;
; 1010 :             else
; 1011 :                 return Div;
; 1012 :         case '%':
; 1013 :             return Mod;

  00064	b8 05 00 00 00	 mov	 eax, 5

; 1032 :     }
; 1033 : }

  00069	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006d	c3		 ret	 0
$LN9@ast_for_au:

; 1014 :         case '<':
; 1015 :             return LShift;

  0006e	b8 07 00 00 00	 mov	 eax, 7

; 1032 :     }
; 1033 : }

  00073	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00077	c3		 ret	 0
$LN8@ast_for_au:

; 1016 :         case '>':
; 1017 :             return RShift;

  00078	b8 08 00 00 00	 mov	 eax, 8

; 1032 :     }
; 1033 : }

  0007d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00081	c3		 ret	 0
$LN7@ast_for_au:

; 1018 :         case '&':
; 1019 :             return BitAnd;

  00082	b8 0b 00 00 00	 mov	 eax, 11

; 1032 :     }
; 1033 : }

  00087	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008b	c3		 ret	 0
$LN6@ast_for_au:

; 1020 :         case '^':
; 1021 :             return BitXor;

  0008c	b8 0a 00 00 00	 mov	 eax, 10

; 1032 :     }
; 1033 : }

  00091	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00095	c3		 ret	 0
$LN5@ast_for_au:

; 1022 :         case '|':
; 1023 :             return BitOr;

  00096	b8 09 00 00 00	 mov	 eax, 9

; 1032 :     }
; 1033 : }

  0009b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009f	c3		 ret	 0
$LN4@ast_for_au:

; 1024 :         case '*':
; 1025 :             if (STR(n)[1] == '*')

  000a0	41 80 78 01 2a	 cmp	 BYTE PTR [r8+1], 42	; 0000002aH
  000a5	b8 03 00 00 00	 mov	 eax, 3
  000aa	b9 06 00 00 00	 mov	 ecx, 6
  000af	0f 44 c1	 cmove	 eax, ecx

; 1032 :     }
; 1033 : }

  000b2	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b6	c3		 ret	 0
$LN2@ast_for_au:

; 1026 :                 return Pow;
; 1027 :             else
; 1028 :                 return Mult;
; 1029 :         default:
; 1030 :             PyErr_Format(PyExc_SystemError, "invalid augassign: %s", STR(n));

  000b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@BNGEDCBG@invalid?5augassign?3?5?$CFs?$AA@
  000c5	e8 00 00 00 00	 call	 PyErr_Format

; 1031 :             return (operator_ty)0;

  000ca	33 c0		 xor	 eax, eax

; 1032 :     }
; 1033 : }

  000cc	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d0	c3		 ret	 0
  000d1	0f 1f 00	 npad	 3
$LN21@ast_for_au:
  000d4	00 00 00 00	 DD	 $LN11@ast_for_au
  000d8	00 00 00 00	 DD	 $LN7@ast_for_au
  000dc	00 00 00 00	 DD	 $LN4@ast_for_au
  000e0	00 00 00 00	 DD	 $LN15@ast_for_au
  000e4	00 00 00 00	 DD	 $LN14@ast_for_au
  000e8	00 00 00 00	 DD	 $LN13@ast_for_au
  000ec	00 00 00 00	 DD	 $LN9@ast_for_au
  000f0	00 00 00 00	 DD	 $LN8@ast_for_au
  000f4	00 00 00 00	 DD	 $LN6@ast_for_au
  000f8	00 00 00 00	 DD	 $LN5@ast_for_au
  000fc	00 00 00 00	 DD	 $LN2@ast_for_au
$LN20@ast_for_au:
  00100	00		 DB	 0
  00101	01		 DB	 1
  00102	0a		 DB	 10
  00103	0a		 DB	 10
  00104	0a		 DB	 10
  00105	02		 DB	 2
  00106	03		 DB	 3
  00107	0a		 DB	 10
  00108	04		 DB	 4
  00109	0a		 DB	 10
  0010a	05		 DB	 5
  0010b	0a		 DB	 10
  0010c	0a		 DB	 10
  0010d	0a		 DB	 10
  0010e	0a		 DB	 10
  0010f	0a		 DB	 10
  00110	0a		 DB	 10
  00111	0a		 DB	 10
  00112	0a		 DB	 10
  00113	0a		 DB	 10
  00114	0a		 DB	 10
  00115	0a		 DB	 10
  00116	0a		 DB	 10
  00117	06		 DB	 6
  00118	0a		 DB	 10
  00119	07		 DB	 7
  0011a	0a		 DB	 10
  0011b	0a		 DB	 10
  0011c	0a		 DB	 10
  0011d	0a		 DB	 10
  0011e	0a		 DB	 10
  0011f	0a		 DB	 10
  00120	0a		 DB	 10
  00121	0a		 DB	 10
  00122	0a		 DB	 10
  00123	0a		 DB	 10
  00124	0a		 DB	 10
  00125	0a		 DB	 10
  00126	0a		 DB	 10
  00127	0a		 DB	 10
  00128	0a		 DB	 10
  00129	0a		 DB	 10
  0012a	0a		 DB	 10
  0012b	0a		 DB	 10
  0012c	0a		 DB	 10
  0012d	0a		 DB	 10
  0012e	0a		 DB	 10
  0012f	0a		 DB	 10
  00130	0a		 DB	 10
  00131	0a		 DB	 10
  00132	0a		 DB	 10
  00133	0a		 DB	 10
  00134	0a		 DB	 10
  00135	0a		 DB	 10
  00136	0a		 DB	 10
  00137	0a		 DB	 10
  00138	0a		 DB	 10
  00139	08		 DB	 8
  0013a	0a		 DB	 10
  0013b	0a		 DB	 10
  0013c	0a		 DB	 10
  0013d	0a		 DB	 10
  0013e	0a		 DB	 10
  0013f	0a		 DB	 10
  00140	0a		 DB	 10
  00141	0a		 DB	 10
  00142	0a		 DB	 10
  00143	0a		 DB	 10
  00144	0a		 DB	 10
  00145	0a		 DB	 10
  00146	0a		 DB	 10
  00147	0a		 DB	 10
  00148	0a		 DB	 10
  00149	0a		 DB	 10
  0014a	0a		 DB	 10
  0014b	0a		 DB	 10
  0014c	0a		 DB	 10
  0014d	0a		 DB	 10
  0014e	0a		 DB	 10
  0014f	0a		 DB	 10
  00150	0a		 DB	 10
  00151	0a		 DB	 10
  00152	0a		 DB	 10
  00153	0a		 DB	 10
  00154	0a		 DB	 10
  00155	0a		 DB	 10
  00156	0a		 DB	 10
  00157	09		 DB	 9
ast_for_augassign ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@DJMGDDDJ@invalid?5comp_op?3?5has?5?$CFd?5children@ ; `string'
PUBLIC	??_C@_0BH@PIIGKMIP@invalid?5comp_op?3?5?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BE@KEKDOHCG@invalid?5comp_op?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_02EDKKPMHH@is?$AA@			; `string'
PUBLIC	??_C@_02LMMGJAGL@in?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_comp_op DD imagerel ast_for_comp_op
	DD	imagerel ast_for_comp_op+502
	DD	imagerel $unwind$ast_for_comp_op
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_comp_op DD 040a01H
	DD	06640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0CB@DJMGDDDJ@invalid?5comp_op?3?5has?5?$CFd?5children@
CONST	SEGMENT
??_C@_0CB@DJMGDDDJ@invalid?5comp_op?3?5has?5?$CFd?5children@ DB 'invalid '
	DB	'comp_op: has %d children', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PIIGKMIP@invalid?5comp_op?3?5?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BH@PIIGKMIP@invalid?5comp_op?3?5?$CFs?5?$CFs?$AA@ DB 'invalid comp'
	DB	'_op: %s %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KEKDOHCG@invalid?5comp_op?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BE@KEKDOHCG@invalid?5comp_op?3?5?$CFs?$AA@ DB 'invalid comp_op: %s'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02EDKKPMHH@is?$AA@
CONST	SEGMENT
??_C@_02EDKKPMHH@is?$AA@ DB 'is', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGJAGL@in?$AA@
CONST	SEGMENT
??_C@_02LMMGJAGL@in?$AA@ DB 'in', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ast_for_comp_op
_TEXT	SEGMENT
n$ = 48
ast_for_comp_op PROC					; COMDAT

; 1037 : {

  00000	48 89 74 24 08	 mov	 QWORD PTR [rsp+8], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1038 :     /* comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'
; 1039 :                |'is' 'not'
; 1040 :     */
; 1041 :     REQ(n, comp_op);
; 1042 :     if (NCH(n) == 1) {

  0000a	44 8b 41 18	 mov	 r8d, DWORD PTR [rcx+24]
  0000e	41 83 f8 01	 cmp	 r8d, 1
  00012	0f 85 fe 00 00
	00		 jne	 $LN21@ast_for_co

; 1043 :         n = CHILD(n, 0);

  00018	4c 8b 41 20	 mov	 r8, QWORD PTR [rcx+32]

; 1044 :         switch (TYPE(n)) {

  0001c	41 0f bf 00	 movsx	 eax, WORD PTR [r8]
  00020	ff c8		 dec	 eax
  00022	83 f8 1d	 cmp	 eax, 29
  00025	0f 87 c7 00 00
	00		 ja	 $LN10@ast_for_co
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00032	48 98		 cdqe
  00034	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN24@ast_for_co[rdx+rax]
  0003c	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN25@ast_for_co[rdx+rax*4]
  00043	48 03 ca	 add	 rcx, rdx
  00046	ff e1		 jmp	 rcx
$LN18@ast_for_co:

; 1045 :             case LESS:
; 1046 :                 return Lt;

  00048	b8 03 00 00 00	 mov	 eax, 3

; 1085 : }

  0004d	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
$LN17@ast_for_co:

; 1047 :             case GREATER:
; 1048 :                 return Gt;

  00058	b8 05 00 00 00	 mov	 eax, 5

; 1085 : }

  0005d	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
$LN16@ast_for_co:

; 1049 :             case EQEQUAL:                       /* == */
; 1050 :                 return Eq;

  00068	b8 01 00 00 00	 mov	 eax, 1

; 1085 : }

  0006d	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00072	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
$LN15@ast_for_co:

; 1051 :             case LESSEQUAL:
; 1052 :                 return LtE;

  00078	b8 04 00 00 00	 mov	 eax, 4

; 1085 : }

  0007d	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00082	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00086	5f		 pop	 rdi
  00087	c3		 ret	 0
$LN14@ast_for_co:

; 1053 :             case GREATEREQUAL:
; 1054 :                 return GtE;

  00088	b8 06 00 00 00	 mov	 eax, 6

; 1085 : }

  0008d	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00092	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
$LN13@ast_for_co:

; 1055 :             case NOTEQUAL:
; 1056 :                 return NotEq;

  00098	b8 02 00 00 00	 mov	 eax, 2

; 1085 : }

  0009d	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000a2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a6	5f		 pop	 rdi
  000a7	c3		 ret	 0
$LN12@ast_for_co:

; 1057 :             case NAME:
; 1058 :                 if (strcmp(STR(n), "in") == 0)

  000a8	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  000ac	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_02LMMGJAGL@in?$AA@
  000b3	b9 03 00 00 00	 mov	 ecx, 3
  000b8	48 8b f0	 mov	 rsi, rax
  000bb	f3 a6		 repe cmpsb
  000bd	75 10		 jne	 SHORT $LN11@ast_for_co

; 1059 :                     return In;

  000bf	b8 09 00 00 00	 mov	 eax, 9

; 1085 : }

  000c4	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000c9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cd	5f		 pop	 rdi
  000ce	c3		 ret	 0
$LN11@ast_for_co:

; 1060 :                 if (strcmp(STR(n), "is") == 0)

  000cf	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_02EDKKPMHH@is?$AA@
  000d6	48 8b f0	 mov	 rsi, rax
  000d9	b9 03 00 00 00	 mov	 ecx, 3
  000de	f3 a6		 repe cmpsb
  000e0	75 10		 jne	 SHORT $LN10@ast_for_co

; 1061 :                     return Is;

  000e2	b8 07 00 00 00	 mov	 eax, 7

; 1085 : }

  000e7	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000ec	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f0	5f		 pop	 rdi
  000f1	c3		 ret	 0
$LN10@ast_for_co:

; 1062 :             default:
; 1063 :                 PyErr_Format(PyExc_SystemError, "invalid comp_op: %s",
; 1064 :                              STR(n));

  000f2	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  000f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@KEKDOHCG@invalid?5comp_op?3?5?$CFs?$AA@
  00104	e8 00 00 00 00	 call	 PyErr_Format

; 1084 :     return (cmpop_ty)0;

  00109	33 c0		 xor	 eax, eax

; 1085 : }

  0010b	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00110	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00114	5f		 pop	 rdi
  00115	c3		 ret	 0
$LN21@ast_for_co:

; 1065 :                 return (cmpop_ty)0;
; 1066 :         }
; 1067 :     }
; 1068 :     else if (NCH(n) == 2) {

  00116	41 83 f8 02	 cmp	 r8d, 2
  0011a	75 7c		 jne	 SHORT $LN5@ast_for_co

; 1069 :         /* handle "not in" and "is not" */
; 1070 :         switch (TYPE(CHILD(n, 0))) {

  0011c	4c 8b 41 20	 mov	 r8, QWORD PTR [rcx+32]
  00120	41 0f bf 08	 movsx	 ecx, WORD PTR [r8]
  00124	ff c9		 dec	 ecx
  00126	75 48		 jne	 SHORT $LN2@ast_for_co

; 1071 :             case NAME:
; 1072 :                 if (strcmp(STR(CHILD(n, 1)), "in") == 0)

  00128	49 8b 70 30	 mov	 rsi, QWORD PTR [r8+48]
  0012c	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_02LMMGJAGL@in?$AA@
  00133	b9 03 00 00 00	 mov	 ecx, 3
  00138	f3 a6		 repe cmpsb
  0013a	75 10		 jne	 SHORT $LN3@ast_for_co

; 1073 :                     return NotIn;

  0013c	b8 0a 00 00 00	 mov	 eax, 10

; 1085 : }

  00141	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00146	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0014a	5f		 pop	 rdi
  0014b	c3		 ret	 0
$LN3@ast_for_co:

; 1074 :                 if (strcmp(STR(CHILD(n, 0)), "is") == 0)

  0014c	49 8b 70 08	 mov	 rsi, QWORD PTR [r8+8]
  00150	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_02EDKKPMHH@is?$AA@
  00157	b9 03 00 00 00	 mov	 ecx, 3
  0015c	f3 a6		 repe cmpsb
  0015e	75 10		 jne	 SHORT $LN2@ast_for_co

; 1075 :                     return IsNot;

  00160	b8 08 00 00 00	 mov	 eax, 8

; 1085 : }

  00165	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0016a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016e	5f		 pop	 rdi
  0016f	c3		 ret	 0
$LN2@ast_for_co:

; 1076 :             default:
; 1077 :                 PyErr_Format(PyExc_SystemError, "invalid comp_op: %s %s",
; 1078 :                              STR(CHILD(n, 0)), STR(CHILD(n, 1)));

  00170	4d 8b 48 30	 mov	 r9, QWORD PTR [r8+48]
  00174	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0017b	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  0017f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@PIIGKMIP@invalid?5comp_op?3?5?$CFs?5?$CFs?$AA@
  00186	e8 00 00 00 00	 call	 PyErr_Format

; 1084 :     return (cmpop_ty)0;

  0018b	33 c0		 xor	 eax, eax

; 1085 : }

  0018d	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00192	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00196	5f		 pop	 rdi
  00197	c3		 ret	 0
$LN5@ast_for_co:

; 1079 :                 return (cmpop_ty)0;
; 1080 :         }
; 1081 :     }
; 1082 :     PyErr_Format(PyExc_SystemError, "invalid comp_op: has %d children",
; 1083 :                  NCH(n));

  00198	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0019f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@DJMGDDDJ@invalid?5comp_op?3?5has?5?$CFd?5children@
  001a6	e8 00 00 00 00	 call	 PyErr_Format

; 1085 : }

  001ab	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  001b0	33 c0		 xor	 eax, eax
  001b2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001b6	5f		 pop	 rdi
  001b7	c3		 ret	 0
$LN25@ast_for_co:
  001b8	00 00 00 00	 DD	 $LN12@ast_for_co
  001bc	00 00 00 00	 DD	 $LN18@ast_for_co
  001c0	00 00 00 00	 DD	 $LN17@ast_for_co
  001c4	00 00 00 00	 DD	 $LN16@ast_for_co
  001c8	00 00 00 00	 DD	 $LN13@ast_for_co
  001cc	00 00 00 00	 DD	 $LN15@ast_for_co
  001d0	00 00 00 00	 DD	 $LN14@ast_for_co
  001d4	00 00 00 00	 DD	 $LN10@ast_for_co
$LN24@ast_for_co:
  001d8	00		 DB	 0
  001d9	07		 DB	 7
  001da	07		 DB	 7
  001db	07		 DB	 7
  001dc	07		 DB	 7
  001dd	07		 DB	 7
  001de	07		 DB	 7
  001df	07		 DB	 7
  001e0	07		 DB	 7
  001e1	07		 DB	 7
  001e2	07		 DB	 7
  001e3	07		 DB	 7
  001e4	07		 DB	 7
  001e5	07		 DB	 7
  001e6	07		 DB	 7
  001e7	07		 DB	 7
  001e8	07		 DB	 7
  001e9	07		 DB	 7
  001ea	07		 DB	 7
  001eb	01		 DB	 1
  001ec	02		 DB	 2
  001ed	07		 DB	 7
  001ee	07		 DB	 7
  001ef	07		 DB	 7
  001f0	07		 DB	 7
  001f1	07		 DB	 7
  001f2	03		 DB	 3
  001f3	04		 DB	 4
  001f4	05		 DB	 5
  001f5	06		 DB	 6
ast_for_comp_op ENDP
_TEXT	ENDS
EXTRN	asdl_seq_new:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$seq_for_testlist DD imagerel seq_for_testlist
	DD	imagerel seq_for_testlist+67
	DD	imagerel $unwind$seq_for_testlist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$seq_for_testlist DD imagerel seq_for_testlist+67
	DD	imagerel seq_for_testlist+158
	DD	imagerel $chain$0$seq_for_testlist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$seq_for_testlist DD imagerel seq_for_testlist+158
	DD	imagerel seq_for_testlist+160
	DD	imagerel $chain$2$seq_for_testlist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$seq_for_testlist DD 020021H
	DD	063400H
	DD	imagerel seq_for_testlist
	DD	imagerel seq_for_testlist+67
	DD	imagerel $unwind$seq_for_testlist
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$seq_for_testlist DD 020521H
	DD	063405H
	DD	imagerel seq_for_testlist
	DD	imagerel seq_for_testlist+67
	DD	imagerel $unwind$seq_for_testlist
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$seq_for_testlist DD 060f01H
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT seq_for_testlist
_TEXT	SEGMENT
c$ = 48
n$ = 56
seq_for_testlist PROC					; COMDAT

; 1089 : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1090 :     /* testlist: test (',' test)* [',']
; 1091 :        testlist_star_expr: test|star_expr (',' test|star_expr)* [',']
; 1092 :     */
; 1093 :     asdl_seq *seq;
; 1094 :     expr_ty expression;
; 1095 :     int i;
; 1096 :     assert(TYPE(n) == testlist || TYPE(n) == testlist_star_expr || TYPE(n) == testlist_comp);
; 1097 : 
; 1098 :     seq = asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);

  0000f	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b e9	 mov	 rbp, rcx
  00018	ff c0		 inc	 eax
  0001a	99		 cdq
  0001b	2b c2		 sub	 eax, edx
  0001d	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
  00021	d1 f8		 sar	 eax, 1
  00023	48 63 c8	 movsxd	 rcx, eax
  00026	e8 00 00 00 00	 call	 asdl_seq_new
  0002b	48 8b f0	 mov	 rsi, rax

; 1099 :     if (!seq)

  0002e	48 85 c0	 test	 rax, rax
  00031	75 10		 jne	 SHORT $LN5@seq_for_te

; 1114 : }

  00033	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00038	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
$LN5@seq_for_te:
  00043	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1100 :         return NULL;
; 1101 : 
; 1102 :     for (i = 0; i < NCH(n); i += 2) {

  00048	33 db		 xor	 ebx, ebx
  0004a	39 5f 18	 cmp	 DWORD PTR [rdi+24], ebx
  0004d	7e 37		 jle	 SHORT $LN2@seq_for_te
  0004f	90		 npad	 1
$LL4@seq_for_te:

; 1103 :         const node *ch = CHILD(n, i);

  00050	48 63 c3	 movsxd	 rax, ebx
  00053	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00057	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0005b	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]

; 1104 :         assert(TYPE(ch) == test || TYPE(ch) == test_nocond || TYPE(ch) == star_expr);
; 1105 : 
; 1106 :         expression = ast_for_expr(c, ch);

  0005f	48 8b cd	 mov	 rcx, rbp
  00062	e8 00 00 00 00	 call	 ast_for_expr
  00067	4c 8b d8	 mov	 r11, rax

; 1107 :         if (!expression)

  0006a	48 85 c0	 test	 rax, rax
  0006d	74 2f		 je	 SHORT $LN9@seq_for_te

; 1109 : 
; 1110 :         assert(i / 2 < seq->size);
; 1111 :         asdl_seq_SET(seq, i / 2, expression);

  0006f	8b c3		 mov	 eax, ebx
  00071	83 c3 02	 add	 ebx, 2
  00074	99		 cdq
  00075	2b c2		 sub	 eax, edx
  00077	d1 f8		 sar	 eax, 1
  00079	48 63 c8	 movsxd	 rcx, eax
  0007c	4c 89 5c ce 08	 mov	 QWORD PTR [rsi+rcx*8+8], r11
  00081	3b 5f 18	 cmp	 ebx, DWORD PTR [rdi+24]
  00084	7c ca		 jl	 SHORT $LL4@seq_for_te
$LN2@seq_for_te:

; 1112 :     }
; 1113 :     return seq;

  00086	48 8b c6	 mov	 rax, rsi
$LN11@seq_for_te:
  00089	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1114 : }

  0008e	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00093	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00098	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
$LN9@seq_for_te:

; 1108 :             return NULL;

  0009e	eb e9		 jmp	 SHORT $LN11@seq_for_te
seq_for_testlist ENDP
_TEXT	ENDS
EXTRN	_Py_arg:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_arg DD imagerel ast_for_arg
	DD	imagerel ast_for_arg+163
	DD	imagerel $unwind$ast_for_arg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_arg DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_arg
_TEXT	SEGMENT
c$ = 48
n$ = 56
ast_for_arg PROC					; COMDAT

; 1118 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1119 :     identifier name;
; 1120 :     expr_ty annotation = NULL;
; 1121 :     node *ch;
; 1122 : 
; 1123 :     assert(TYPE(n) == tfpdef || TYPE(n) == vfpdef);
; 1124 :     ch = CHILD(n, 0);

  0001a	4c 8b 62 20	 mov	 r12, QWORD PTR [rdx+32]
  0001e	48 8b da	 mov	 rbx, rdx
  00021	48 8b f1	 mov	 rsi, rcx

; 1125 :     name = NEW_IDENTIFIER(ch);

  00024	48 8b d1	 mov	 rdx, rcx
  00027	49 8b 4c 24 08	 mov	 rcx, QWORD PTR [r12+8]
  0002c	33 ff		 xor	 edi, edi
  0002e	e8 00 00 00 00	 call	 new_identifier
  00033	48 8b e8	 mov	 rbp, rax

; 1126 :     if (!name)

  00036	48 85 c0	 test	 rax, rax
  00039	75 04		 jne	 SHORT $LN4@ast_for_ar
$LN7@ast_for_ar:

; 1127 :         return NULL;

  0003b	33 c0		 xor	 eax, eax
  0003d	eb 49		 jmp	 SHORT $LN5@ast_for_ar
$LN4@ast_for_ar:

; 1128 :     if (forbidden_name(c, name, ch, 0))

  0003f	45 33 c9	 xor	 r9d, r9d
  00042	4d 8b c4	 mov	 r8, r12
  00045	48 8b d0	 mov	 rdx, rax
  00048	48 8b ce	 mov	 rcx, rsi
  0004b	e8 00 00 00 00	 call	 forbidden_name
  00050	85 c0		 test	 eax, eax

; 1129 :         return NULL;

  00052	75 e7		 jne	 SHORT $LN7@ast_for_ar

; 1130 : 
; 1131 :     if (NCH(n) == 3 && TYPE(CHILD(n, 1)) == COLON) {

  00054	83 7b 18 03	 cmp	 DWORD PTR [rbx+24], 3
  00058	75 1f		 jne	 SHORT $LN1@ast_for_ar
  0005a	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  0005e	66 83 7a 28 0b	 cmp	 WORD PTR [rdx+40], 11
  00063	75 14		 jne	 SHORT $LN1@ast_for_ar

; 1132 :         annotation = ast_for_expr(c, CHILD(n, 2));

  00065	48 83 c2 50	 add	 rdx, 80			; 00000050H
  00069	48 8b ce	 mov	 rcx, rsi
  0006c	e8 00 00 00 00	 call	 ast_for_expr
  00071	48 8b f8	 mov	 rdi, rax

; 1133 :         if (!annotation)

  00074	48 85 c0	 test	 rax, rax

; 1134 :             return NULL;

  00077	74 c2		 je	 SHORT $LN7@ast_for_ar
$LN1@ast_for_ar:

; 1135 :     }
; 1136 : 
; 1137 :     return arg(name, annotation, c->c_arena);

  00079	4c 8b 46 08	 mov	 r8, QWORD PTR [rsi+8]
  0007d	48 8b d7	 mov	 rdx, rdi
  00080	48 8b cd	 mov	 rcx, rbp
  00083	e8 00 00 00 00	 call	 _Py_arg
$LN5@ast_for_ar:

; 1138 : }

  00088	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008d	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00092	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00097	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0009c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a0	41 5c		 pop	 r12
  000a2	c3		 ret	 0
ast_for_arg ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@JBKEEOMC@unexpected?5node?$AA@	; `string'
PUBLIC	??_C@_0CD@MPPDOCEK@named?5arguments?5must?5follow?5bare@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$handle_keywordonly_args DD imagerel handle_keywordonly_args
	DD	imagerel handle_keywordonly_args+539
	DD	imagerel $unwind$handle_keywordonly_args
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$handle_keywordonly_args DD 0106a01H
	DD	06f46aH
	DD	07e465H
	DD	08d460H
	DD	09c45bH
	DD	0a7456H
	DD	0b6451H
	DD	010544cH
	DD	0300bb20fH
xdata	ENDS
;	COMDAT ??_C@_0BA@JBKEEOMC@unexpected?5node?$AA@
CONST	SEGMENT
??_C@_0BA@JBKEEOMC@unexpected?5node?$AA@ DB 'unexpected node', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MPPDOCEK@named?5arguments?5must?5follow?5bare@
CONST	SEGMENT
??_C@_0CD@MPPDOCEK@named?5arguments?5must?5follow?5bare@ DB 'named argume'
	DB	'nts must follow bare *', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT handle_keywordonly_args
_TEXT	SEGMENT
ch$1$ = 32
c$ = 112
n$ = 120
start$ = 128
kwonlyargs$ = 136
kwdefaults$ = 144
handle_keywordonly_args PROC				; COMDAT

; 1149 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	4d 8b d9	 mov	 r11, r9
  00012	49 63 d8	 movsxd	 rbx, r8d
  00015	4c 8b d2	 mov	 r10, rdx
  00018	4c 8b c9	 mov	 r9, rcx

; 1150 :     PyObject *argname;
; 1151 :     node *ch;
; 1152 :     expr_ty expression, annotation;
; 1153 :     arg_ty arg;
; 1154 :     int i = start;
; 1155 :     int j = 0; /* index for kwdefaults and kwonlyargs */
; 1156 : 
; 1157 :     if (kwonlyargs == NULL) {

  0001b	4d 85 db	 test	 r11, r11
  0001e	75 21		 jne	 SHORT $LN20@handle_key

; 1158 :         ast_error(c, CHILD(n, start), "named arguments must follow bare *");

  00020	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  00024	4c 8d 04 9b	 lea	 r8, QWORD PTR [rbx+rbx*4]
  00028	4a 8d 14 c0	 lea	 rdx, QWORD PTR [rax+r8*8]
  0002c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CD@MPPDOCEK@named?5arguments?5must?5follow?5bare@
  00033	e8 00 00 00 00	 call	 ast_error

; 1159 :         return -1;

  00038	83 c8 ff	 or	 eax, -1

; 1208 : }

  0003b	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
$LN20@handle_key:

; 1160 :     }
; 1161 :     assert(kwdefaults != NULL);
; 1162 :     while (i < NCH(n)) {

  00041	8b 52 18	 mov	 edx, DWORD PTR [rdx+24]
  00044	48 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbp
  0004c	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  00051	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00056	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  0005b	4c 89 6c 24 40	 mov	 QWORD PTR [rsp+64], r13
  00060	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  00065	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  0006a	3b da		 cmp	 ebx, edx
  0006c	0f 8d 7b 01 00
	00		 jge	 $LN15@handle_key
  00072	48 8d 04 9b	 lea	 rax, QWORD PTR [rbx+rbx*4]
  00076	44 8d 7b 02	 lea	 r15d, DWORD PTR [rbx+2]
  0007a	44 8d 6b 01	 lea	 r13d, DWORD PTR [rbx+1]
  0007e	4c 8d 34 c5 00
	00 00 00	 lea	 r14, QWORD PTR [rax*8]
  00086	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR kwdefaults$[rsp]
  0008e	4c 2b d8	 sub	 r11, rax
  00091	49 8d 6e 28	 lea	 rbp, QWORD PTR [r14+40]
  00095	48 8d 70 08	 lea	 rsi, QWORD PTR [rax+8]
  00099	4c 89 9c 24 88
	00 00 00	 mov	 QWORD PTR kwonlyargs$[rsp], r11
  000a1	66 66 66 66 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL16@handle_key:

; 1163 :         ch = CHILD(n, i);

  000b0	4d 8b 42 20	 mov	 r8, QWORD PTR [r10+32]

; 1164 :         switch (TYPE(ch)) {

  000b4	43 0f bf 0c 06	 movsx	 ecx, WORD PTR [r14+r8]
  000b9	83 e9 23	 sub	 ecx, 35			; 00000023H
  000bc	4b 8d 3c 06	 lea	 rdi, QWORD PTR [r14+r8]
  000c0	0f 84 27 01 00
	00		 je	 $LN15@handle_key
  000c6	81 e9 e6 00 00
	00		 sub	 ecx, 230		; 000000e6H
  000cc	74 09		 je	 SHORT $LN12@handle_key
  000ce	83 f9 02	 cmp	 ecx, 2
  000d1	0f 85 ff 00 00
	00		 jne	 $LN26@handle_key
$LN12@handle_key:

; 1165 :             case vfpdef:
; 1166 :             case tfpdef:
; 1167 :                 if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {

  000d7	44 3b ea	 cmp	 r13d, edx
  000da	7d 41		 jge	 SHORT $LN11@handle_key
  000dc	66 41 83 3c 28
	16		 cmp	 WORD PTR [r8+rbp], 22
  000e2	75 39		 jne	 SHORT $LN11@handle_key

; 1168 :                     expression = ast_for_expr(c, CHILD(n, i + 2));

  000e4	49 63 c7	 movsxd	 rax, r15d
  000e7	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  000eb	49 8d 14 c8	 lea	 rdx, QWORD PTR [r8+rcx*8]
  000ef	49 8b c9	 mov	 rcx, r9
  000f2	e8 00 00 00 00	 call	 ast_for_expr

; 1169 :                     if (!expression)

  000f7	48 85 c0	 test	 rax, rax
  000fa	0f 84 e8 00 00
	00		 je	 $error$22543

; 1170 :                         goto error;
; 1171 :                     asdl_seq_SET(kwdefaults, j, expression);
; 1172 :                     i += 2; /* '=' and test */
; 1173 :                 }
; 1174 :                 else { /* setting NULL if no default value exists */

  00100	4c 8b 4c 24 70	 mov	 r9, QWORD PTR c$[rsp]
  00105	83 c3 02	 add	 ebx, 2
  00108	41 83 c5 02	 add	 r13d, 2
  0010c	41 83 c7 02	 add	 r15d, 2
  00110	49 83 c6 50	 add	 r14, 80			; 00000050H
  00114	48 89 06	 mov	 QWORD PTR [rsi], rax
  00117	48 83 c5 50	 add	 rbp, 80			; 00000050H
  0011b	eb 07		 jmp	 SHORT $LN9@handle_key
$LN11@handle_key:

; 1175 :                     asdl_seq_SET(kwdefaults, j, NULL);

  0011d	48 c7 06 00 00
	00 00		 mov	 QWORD PTR [rsi], 0
$LN9@handle_key:

; 1176 :                 }
; 1177 :                 if (NCH(ch) == 3) {

  00124	83 7f 18 03	 cmp	 DWORD PTR [rdi+24], 3
  00128	75 1e		 jne	 SHORT $LN8@handle_key

; 1178 :                     /* ch is NAME ':' test */
; 1179 :                     annotation = ast_for_expr(c, CHILD(ch, 2));

  0012a	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  0012e	49 8b c9	 mov	 rcx, r9
  00131	48 83 c2 50	 add	 rdx, 80			; 00000050H
  00135	e8 00 00 00 00	 call	 ast_for_expr
  0013a	4c 8b e0	 mov	 r12, rax

; 1180 :                     if (!annotation)

  0013d	48 85 c0	 test	 rax, rax
  00140	0f 84 a2 00 00
	00		 je	 $error$22543

; 1181 :                         goto error;
; 1182 :                 }
; 1183 :                 else {

  00146	eb 03		 jmp	 SHORT $LN6@handle_key
$LN8@handle_key:

; 1184 :                     annotation = NULL;

  00148	45 33 e4	 xor	 r12d, r12d
$LN6@handle_key:

; 1185 :                 }
; 1186 :                 ch = CHILD(ch, 0);

  0014b	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]

; 1187 :                 argname = NEW_IDENTIFIER(ch);

  0014f	48 8b 54 24 70	 mov	 rdx, QWORD PTR c$[rsp]
  00154	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00158	48 89 44 24 20	 mov	 QWORD PTR ch$1$[rsp], rax
  0015d	e8 00 00 00 00	 call	 new_identifier
  00162	48 8b f8	 mov	 rdi, rax

; 1188 :                 if (!argname)

  00165	48 85 c0	 test	 rax, rax
  00168	74 7e		 je	 SHORT $error$22543

; 1189 :                     goto error;
; 1190 :                 if (forbidden_name(c, argname, ch, 0))

  0016a	4c 8b 44 24 20	 mov	 r8, QWORD PTR ch$1$[rsp]
  0016f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00174	45 33 c9	 xor	 r9d, r9d
  00177	48 8b d0	 mov	 rdx, rax
  0017a	e8 00 00 00 00	 call	 forbidden_name
  0017f	85 c0		 test	 eax, eax
  00181	75 65		 jne	 SHORT $error$22543

; 1191 :                     goto error;
; 1192 :                 arg = arg(argname, annotation, c->c_arena);

  00183	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00188	49 8b d4	 mov	 rdx, r12
  0018b	48 8b cf	 mov	 rcx, rdi
  0018e	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00192	e8 00 00 00 00	 call	 _Py_arg

; 1193 :                 if (!arg)

  00197	48 85 c0	 test	 rax, rax
  0019a	74 4c		 je	 SHORT $error$22543

; 1194 :                     goto error;
; 1195 :                 asdl_seq_SET(kwonlyargs, j++, arg);

  0019c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kwonlyargs$[rsp]
  001a4	4c 8b 54 24 78	 mov	 r10, QWORD PTR n$[rsp]

; 1196 :                 i += 2; /* the name and the comma */

  001a9	83 c3 02	 add	 ebx, 2
  001ac	48 89 04 31	 mov	 QWORD PTR [rcx+rsi], rax
  001b0	41 8b 52 18	 mov	 edx, DWORD PTR [r10+24]
  001b4	48 83 c6 08	 add	 rsi, 8
  001b8	41 83 c5 02	 add	 r13d, 2
  001bc	41 83 c7 02	 add	 r15d, 2
  001c0	49 83 c6 50	 add	 r14, 80			; 00000050H
  001c4	48 83 c5 50	 add	 rbp, 80			; 00000050H
  001c8	3b da		 cmp	 ebx, edx
  001ca	7d 21		 jge	 SHORT $LN15@handle_key

; 1160 :     }
; 1161 :     assert(kwdefaults != NULL);
; 1162 :     while (i < NCH(n)) {

  001cc	4c 8b 4c 24 70	 mov	 r9, QWORD PTR c$[rsp]
  001d1	e9 da fe ff ff	 jmp	 $LL16@handle_key
$LN26@handle_key:

; 1197 :                 break;
; 1198 :             case DOUBLESTAR:
; 1199 :                 return i;
; 1200 :             default:
; 1201 :                 ast_error(c, ch, "unexpected node");

  001d6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@JBKEEOMC@unexpected?5node?$AA@
  001dd	48 8b d7	 mov	 rdx, rdi
  001e0	49 8b c9	 mov	 rcx, r9
  001e3	e8 00 00 00 00	 call	 ast_error
$error$22543:

; 1206 :  error:
; 1207 :     return -1;

  001e8	83 c8 ff	 or	 eax, -1
  001eb	eb 02		 jmp	 SHORT $LN34@handle_key
$LN15@handle_key:

; 1202 :                 goto error;
; 1203 :         }
; 1204 :     }
; 1205 :     return i;

  001ed	8b c3		 mov	 eax, ebx
$LN34@handle_key:
  001ef	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]
  001f4	4c 8b 6c 24 40	 mov	 r13, QWORD PTR [rsp+64]
  001f9	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  001fe	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00203	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00208	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]
  00210	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]

; 1208 : }

  00215	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00219	5b		 pop	 rbx
  0021a	c3		 ret	 0
handle_keywordonly_args ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@BBDJNKDC@non?9default?5argument?5follows?5def@ ; `string'
PUBLIC	??_C@_0CI@EMEDAENJ@unexpected?5node?5in?5varargslist?3?5@ ; `string'
PUBLIC	??_C@_0BI@ENJBOKKG@more?5than?5255?5arguments?$AA@ ; `string'
EXTRN	_Py_arguments:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_arguments DD imagerel ast_for_arguments
	DD	imagerel ast_for_arguments+307
	DD	imagerel $unwind$ast_for_arguments
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ast_for_arguments DD imagerel ast_for_arguments+307
	DD	imagerel ast_for_arguments+1322
	DD	imagerel $chain$0$ast_for_arguments
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ast_for_arguments DD imagerel ast_for_arguments+1322
	DD	imagerel ast_for_arguments+1340
	DD	imagerel $chain$1$ast_for_arguments
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ast_for_arguments DD 021H
	DD	imagerel ast_for_arguments
	DD	imagerel ast_for_arguments+307
	DD	imagerel $unwind$ast_for_arguments
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ast_for_arguments DD 020821H
	DD	018e408H
	DD	imagerel ast_for_arguments
	DD	imagerel ast_for_arguments+307
	DD	imagerel $unwind$ast_for_arguments
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_arguments DD 081201H
	DD	0f00bf212H
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT ??_C@_0CO@BBDJNKDC@non?9default?5argument?5follows?5def@
CONST	SEGMENT
??_C@_0CO@BBDJNKDC@non?9default?5argument?5follows?5def@ DB 'non-default '
	DB	'argument follows default argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@EMEDAENJ@unexpected?5node?5in?5varargslist?3?5@
CONST	SEGMENT
??_C@_0CI@EMEDAENJ@unexpected?5node?5in?5varargslist?3?5@ DB 'unexpected '
	DB	'node in varargslist: %d @ %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ENJBOKKG@more?5than?5255?5arguments?$AA@
CONST	SEGMENT
??_C@_0BI@ENJBOKKG@more?5than?5255?5arguments?$AA@ DB 'more than 255 argu'
	DB	'ments', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ast_for_arguments
_TEXT	SEGMENT
vararg$1$ = 80
posdefaults$1$ = 88
kwargannotation$1$ = 96
varargannotation$1$ = 104
posargs$1$ = 112
c$ = 192
kwdefaults$1$ = 200
n$ = 200
kwonlyargs$1$ = 208
kwarg$1$ = 216
ast_for_arguments PROC					; COMDAT

; 1214 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 57		 push	 r15
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 1215 :     /* This function handles both typedargslist (function definition)
; 1216 :        and varargslist (lambda definition).
; 1217 : 
; 1218 :        parameters: '(' [typedargslist] ')'
; 1219 :        typedargslist: ((tfpdef ['=' test] ',')*
; 1220 :            ('*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef]
; 1221 :            | '**' tfpdef)
; 1222 :            | tfpdef ['=' test] (',' tfpdef ['=' test])* [','])
; 1223 :        tfpdef: NAME [':' test]
; 1224 :        varargslist: ((vfpdef ['=' test] ',')*
; 1225 :            ('*' [vfpdef] (',' vfpdef ['=' test])*  [',' '**' vfpdef]
; 1226 :            | '**' vfpdef)
; 1227 :            | vfpdef ['=' test] (',' vfpdef ['=' test])* [','])
; 1228 :        vfpdef: NAME
; 1229 :     */
; 1230 :     int i, j, k, nposargs = 0, nkwonlyargs = 0;

  00012	45 33 ed	 xor	 r13d, r13d

; 1231 :     int nposdefaults = 0, found_default = 0;
; 1232 :     asdl_seq *posargs, *posdefaults, *kwonlyargs, *kwdefaults;
; 1233 :     identifier vararg = NULL, kwarg = NULL;
; 1234 :     arg_ty arg;
; 1235 :     expr_ty varargannotation = NULL, kwargannotation = NULL;
; 1236 :     node *ch;
; 1237 : 
; 1238 :     if (TYPE(n) == parameters) {

  00015	b8 07 01 00 00	 mov	 eax, 263		; 00000107H
  0001a	48 8b ea	 mov	 rbp, rdx
  0001d	4c 8b e1	 mov	 r12, rcx
  00020	41 8b fd	 mov	 edi, r13d
  00023	41 8b dd	 mov	 ebx, r13d
  00026	41 8b f5	 mov	 esi, r13d
  00029	45 8b fd	 mov	 r15d, r13d
  0002c	4c 89 6c 24 50	 mov	 QWORD PTR vararg$1$[rsp], r13
  00031	4c 89 ac 24 d8
	00 00 00	 mov	 QWORD PTR kwarg$1$[rsp], r13
  00039	4c 89 6c 24 68	 mov	 QWORD PTR varargannotation$1$[rsp], r13
  0003e	4c 89 6c 24 60	 mov	 QWORD PTR kwargannotation$1$[rsp], r13
  00043	66 39 02	 cmp	 WORD PTR [rdx], ax
  00046	75 3f		 jne	 SHORT $LN51@ast_for_ar@2

; 1239 :         if (NCH(n) == 2) /* () as argument list */

  00048	83 7a 18 02	 cmp	 DWORD PTR [rdx+24], 2
  0004c	75 31		 jne	 SHORT $LN50@ast_for_ar@2

; 1240 :             return arguments(NULL, NULL, NULL, NULL, NULL, NULL, NULL,
; 1241 :                              NULL, c->c_arena);

  0004e	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00052	45 33 c9	 xor	 r9d, r9d
  00055	45 33 c0	 xor	 r8d, r8d
  00058	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0005d	4c 89 6c 24 38	 mov	 QWORD PTR [rsp+56], r13
  00062	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  00067	33 d2		 xor	 edx, edx
  00069	33 c9		 xor	 ecx, ecx
  0006b	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  00070	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00075	e8 00 00 00 00	 call	 _Py_arguments
  0007a	e9 ab 04 00 00	 jmp	 $LN52@ast_for_ar@2
$LN50@ast_for_ar@2:

; 1242 :         n = CHILD(n, 1);

  0007f	48 8b 6a 20	 mov	 rbp, QWORD PTR [rdx+32]
  00083	48 83 c5 28	 add	 rbp, 40			; 00000028H
$LN51@ast_for_ar@2:

; 1243 :     }
; 1244 :     assert(TYPE(n) == typedargslist || TYPE(n) == varargslist);
; 1245 : 
; 1246 :     /* First count the number of positional args & defaults.  The
; 1247 :        variable i is the loop index for this for loop and the next.
; 1248 :        The next loop picks up where the first leaves off.
; 1249 :     */
; 1250 :     for (i = 0; i < NCH(n); i++) {

  00087	44 8b 4d 18	 mov	 r9d, DWORD PTR [rbp+24]
  0008b	41 ba 0b 01 00
	00		 mov	 r10d, 267		; 0000010bH
  00091	41 8b d5	 mov	 edx, r13d
  00094	45 8d 5a fe	 lea	 r11d, QWORD PTR [r10-2]
  00098	45 85 c9	 test	 r9d, r9d
  0009b	7e 5a		 jle	 SHORT $LN45@ast_for_ar@2
  0009d	4c 8b 45 20	 mov	 r8, QWORD PTR [rbp+32]
  000a1	49 8b c8	 mov	 rcx, r8
$LL49@ast_for_ar@2:

; 1251 :         ch = CHILD(n, i);
; 1252 :         if (TYPE(ch) == STAR) {

  000a4	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  000a7	66 83 f8 10	 cmp	 ax, 16
  000ab	74 29		 je	 SHORT $LN65@ast_for_ar@2

; 1259 :             }
; 1260 :             break;
; 1261 :         }
; 1262 :         if (TYPE(ch) == DOUBLESTAR) break;

  000ad	66 83 f8 23	 cmp	 ax, 35			; 00000023H
  000b1	74 44		 je	 SHORT $LN45@ast_for_ar@2

; 1263 :         if (TYPE(ch) == vfpdef || TYPE(ch) == tfpdef) nposargs++;

  000b3	66 41 3b c2	 cmp	 ax, r10w
  000b7	74 06		 je	 SHORT $LN41@ast_for_ar@2
  000b9	66 41 3b c3	 cmp	 ax, r11w
  000bd	75 02		 jne	 SHORT $LN42@ast_for_ar@2
$LN41@ast_for_ar@2:
  000bf	ff c7		 inc	 edi
$LN42@ast_for_ar@2:

; 1264 :         if (TYPE(ch) == EQUAL) nposdefaults++;

  000c1	66 83 f8 16	 cmp	 ax, 22
  000c5	75 02		 jne	 SHORT $LN48@ast_for_ar@2
  000c7	ff c6		 inc	 esi
$LN48@ast_for_ar@2:

; 1243 :     }
; 1244 :     assert(TYPE(n) == typedargslist || TYPE(n) == varargslist);
; 1245 : 
; 1246 :     /* First count the number of positional args & defaults.  The
; 1247 :        variable i is the loop index for this for loop and the next.
; 1248 :        The next loop picks up where the first leaves off.
; 1249 :     */
; 1250 :     for (i = 0; i < NCH(n); i++) {

  000c9	ff c2		 inc	 edx
  000cb	48 83 c1 28	 add	 rcx, 40			; 00000028H
  000cf	41 3b d1	 cmp	 edx, r9d
  000d2	7c d0		 jl	 SHORT $LL49@ast_for_ar@2

; 1364 :                         if (res == -1) return NULL;

  000d4	eb 21		 jmp	 SHORT $LN45@ast_for_ar@2
$LN65@ast_for_ar@2:

; 1253 :             /* skip star */
; 1254 :             i++;

  000d6	ff c2		 inc	 edx

; 1255 :             if (i < NCH(n) && /* skip argument following star */
; 1256 :                 (TYPE(CHILD(n, i)) == tfpdef ||
; 1257 :                  TYPE(CHILD(n, i)) == vfpdef)) {

  000d8	41 3b d1	 cmp	 edx, r9d
  000db	7d 1a		 jge	 SHORT $LN45@ast_for_ar@2
  000dd	48 63 c2	 movsxd	 rax, edx
  000e0	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  000e4	41 0f b7 04 c8	 movzx	 eax, WORD PTR [r8+rcx*8]
  000e9	66 41 3b c3	 cmp	 ax, r11w
  000ed	74 06		 je	 SHORT $LN44@ast_for_ar@2
  000ef	66 41 3b c2	 cmp	 ax, r10w
  000f3	75 02		 jne	 SHORT $LN45@ast_for_ar@2
$LN44@ast_for_ar@2:

; 1258 :                 i++;

  000f5	ff c2		 inc	 edx
$LN45@ast_for_ar@2:
  000f7	48 63 c2	 movsxd	 rax, edx

; 1265 :     }
; 1266 :     /* count the number of keyword only args &
; 1267 :        defaults for keyword only args */
; 1268 :     for ( ; i < NCH(n); ++i) {

  000fa	41 3b d1	 cmp	 edx, r9d
  000fd	7d 34		 jge	 SHORT $LN88@ast_for_ar@2
  000ff	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00103	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  00107	4c 8d 04 c8	 lea	 r8, QWORD PTR [rax+rcx*8]
  0010b	0f 1f 44 00 00	 npad	 5
$LL39@ast_for_ar@2:

; 1269 :         ch = CHILD(n, i);
; 1270 :         if (TYPE(ch) == DOUBLESTAR) break;

  00110	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
  00114	66 83 f8 23	 cmp	 ax, 35			; 00000023H
  00118	74 19		 je	 SHORT $LN88@ast_for_ar@2

; 1271 :         if (TYPE(ch) == tfpdef || TYPE(ch) == vfpdef) nkwonlyargs++;

  0011a	66 41 3b c3	 cmp	 ax, r11w
  0011e	74 06		 je	 SHORT $LN34@ast_for_ar@2
  00120	66 41 3b c2	 cmp	 ax, r10w
  00124	75 02		 jne	 SHORT $LN38@ast_for_ar@2
$LN34@ast_for_ar@2:
  00126	ff c3		 inc	 ebx
$LN38@ast_for_ar@2:

; 1265 :     }
; 1266 :     /* count the number of keyword only args &
; 1267 :        defaults for keyword only args */
; 1268 :     for ( ; i < NCH(n); ++i) {

  00128	ff c2		 inc	 edx
  0012a	49 83 c0 28	 add	 r8, 40			; 00000028H
  0012e	41 3b d1	 cmp	 edx, r9d
  00131	7c dd		 jl	 SHORT $LL39@ast_for_ar@2
$LN88@ast_for_ar@2:
  00133	4c 89 b4 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], r14

; 1272 :     }
; 1273 :     posargs = (nposargs ? asdl_seq_new(nposargs, c->c_arena) : NULL);

  0013b	85 ff		 test	 edi, edi
  0013d	74 1f		 je	 SHORT $LN54@ast_for_ar@2
  0013f	49 8b 54 24 08	 mov	 rdx, QWORD PTR [r12+8]
  00144	48 63 cf	 movsxd	 rcx, edi
  00147	e8 00 00 00 00	 call	 asdl_seq_new
  0014c	4c 8b f0	 mov	 r14, rax
  0014f	48 89 44 24 70	 mov	 QWORD PTR posargs$1$[rsp], rax

; 1274 :     if (!posargs && nposargs)

  00154	48 85 c0	 test	 rax, rax
  00157	75 0d		 jne	 SHORT $LN33@ast_for_ar@2

; 1275 :         return NULL;

  00159	e9 c4 03 00 00	 jmp	 $LN92@ast_for_ar@2
$LN54@ast_for_ar@2:

; 1272 :     }
; 1273 :     posargs = (nposargs ? asdl_seq_new(nposargs, c->c_arena) : NULL);

  0015e	4d 8b f5	 mov	 r14, r13
  00161	4c 89 6c 24 70	 mov	 QWORD PTR posargs$1$[rsp], r13
$LN33@ast_for_ar@2:

; 1276 :     kwonlyargs = (nkwonlyargs ?
; 1277 :                    asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);

  00166	85 db		 test	 ebx, ebx
  00168	74 1f		 je	 SHORT $LN56@ast_for_ar@2
  0016a	49 8b 54 24 08	 mov	 rdx, QWORD PTR [r12+8]
  0016f	48 63 cb	 movsxd	 rcx, ebx
  00172	e8 00 00 00 00	 call	 asdl_seq_new
  00177	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR kwonlyargs$1$[rsp], rax

; 1278 :     if (!kwonlyargs && nkwonlyargs)

  0017f	48 85 c0	 test	 rax, rax
  00182	75 0d		 jne	 SHORT $LN32@ast_for_ar@2

; 1279 :         return NULL;

  00184	e9 99 03 00 00	 jmp	 $LN92@ast_for_ar@2
$LN56@ast_for_ar@2:

; 1276 :     kwonlyargs = (nkwonlyargs ?
; 1277 :                    asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);

  00189	4c 89 ac 24 d0
	00 00 00	 mov	 QWORD PTR kwonlyargs$1$[rsp], r13
$LN32@ast_for_ar@2:

; 1280 :     posdefaults = (nposdefaults ?
; 1281 :                     asdl_seq_new(nposdefaults, c->c_arena) : NULL);

  00191	85 f6		 test	 esi, esi
  00193	74 1f		 je	 SHORT $LN58@ast_for_ar@2
  00195	49 8b 54 24 08	 mov	 rdx, QWORD PTR [r12+8]
  0019a	48 63 ce	 movsxd	 rcx, esi
  0019d	e8 00 00 00 00	 call	 asdl_seq_new
  001a2	48 8b f0	 mov	 rsi, rax
  001a5	48 89 44 24 58	 mov	 QWORD PTR posdefaults$1$[rsp], rax

; 1282 :     if (!posdefaults && nposdefaults)

  001aa	48 85 c0	 test	 rax, rax
  001ad	75 0d		 jne	 SHORT $LN31@ast_for_ar@2

; 1283 :         return NULL;

  001af	e9 6e 03 00 00	 jmp	 $LN92@ast_for_ar@2
$LN58@ast_for_ar@2:

; 1280 :     posdefaults = (nposdefaults ?
; 1281 :                     asdl_seq_new(nposdefaults, c->c_arena) : NULL);

  001b4	49 8b f5	 mov	 rsi, r13
  001b7	4c 89 6c 24 58	 mov	 QWORD PTR posdefaults$1$[rsp], r13
$LN31@ast_for_ar@2:

; 1284 :     /* The length of kwonlyargs and kwdefaults are same
; 1285 :        since we set NULL as default for keyword only argument w/o default
; 1286 :        - we have sequence data structure, but no dictionary */
; 1287 :     kwdefaults = (nkwonlyargs ?
; 1288 :                    asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);

  001bc	85 db		 test	 ebx, ebx
  001be	74 22		 je	 SHORT $LN60@ast_for_ar@2
  001c0	49 8b 54 24 08	 mov	 rdx, QWORD PTR [r12+8]
  001c5	48 63 cb	 movsxd	 rcx, ebx
  001c8	e8 00 00 00 00	 call	 asdl_seq_new
  001cd	4c 8b c8	 mov	 r9, rax
  001d0	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR kwdefaults$1$[rsp], rax

; 1289 :     if (!kwdefaults && nkwonlyargs)

  001d8	48 85 c0	 test	 rax, rax
  001db	75 10		 jne	 SHORT $LN30@ast_for_ar@2

; 1290 :         return NULL;

  001dd	e9 40 03 00 00	 jmp	 $LN92@ast_for_ar@2
$LN60@ast_for_ar@2:

; 1284 :     /* The length of kwonlyargs and kwdefaults are same
; 1285 :        since we set NULL as default for keyword only argument w/o default
; 1286 :        - we have sequence data structure, but no dictionary */
; 1287 :     kwdefaults = (nkwonlyargs ?
; 1288 :                    asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);

  001e2	4d 8b cd	 mov	 r9, r13
  001e5	4c 89 ac 24 c8
	00 00 00	 mov	 QWORD PTR kwdefaults$1$[rsp], r13
$LN30@ast_for_ar@2:

; 1291 : 
; 1292 :     if (nposargs + nkwonlyargs > 255) {

  001ed	8d 04 3b	 lea	 eax, DWORD PTR [rbx+rdi]
  001f0	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  001f5	7e 19		 jle	 SHORT $LN29@ast_for_ar@2

; 1293 :         ast_error(c, n, "more than 255 arguments");

  001f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BI@ENJBOKKG@more?5than?5255?5arguments?$AA@
  001fe	48 8b d5	 mov	 rdx, rbp
  00201	49 8b cc	 mov	 rcx, r12
  00204	e8 00 00 00 00	 call	 ast_error

; 1294 :         return NULL;

  00209	33 c0		 xor	 eax, eax
  0020b	e9 12 03 00 00	 jmp	 $LN92@ast_for_ar@2
$LN29@ast_for_ar@2:

; 1301 :     j = 0;  /* index for defaults */
; 1302 :     k = 0;  /* index for args */
; 1303 :     while (i < NCH(n)) {

  00210	8b 55 18	 mov	 edx, DWORD PTR [rbp+24]
  00213	41 8b dd	 mov	 ebx, r13d
  00216	85 d2		 test	 edx, edx
  00218	0f 8e b2 02 00
	00		 jle	 $LN89@ast_for_ar@2

; 1295 :     }
; 1296 : 
; 1297 :     /* tfpdef: NAME [':' test]
; 1298 :        vfpdef: NAME
; 1299 :     */
; 1300 :     i = 0;

  0021e	49 83 c6 08	 add	 r14, 8
  00222	4c 8d 7e 08	 lea	 r15, QWORD PTR [rsi+8]
  00226	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL28@ast_for_ar@2:

; 1304 :         ch = CHILD(n, i);

  00230	48 8b 7d 20	 mov	 rdi, QWORD PTR [rbp+32]
  00234	4c 63 c3	 movsxd	 r8, ebx
  00237	4b 8d 04 80	 lea	 rax, QWORD PTR [r8+r8*4]

; 1305 :         switch (TYPE(ch)) {

  0023b	0f bf 0c c7	 movsx	 ecx, WORD PTR [rdi+rax*8]
  0023f	48 8d 34 c7	 lea	 rsi, QWORD PTR [rdi+rax*8]
  00243	83 e9 10	 sub	 ecx, 16
  00246	0f 84 1f 01 00
	00		 je	 $LN18@ast_for_ar@2
  0024c	83 e9 13	 sub	 ecx, 19
  0024f	0f 84 99 00 00
	00		 je	 $LN6@ast_for_ar@2
  00255	81 e9 e6 00 00
	00		 sub	 ecx, 230		; 000000e6H
  0025b	74 09		 je	 SHORT $LN24@ast_for_ar@2
  0025d	83 f9 02	 cmp	 ecx, 2
  00260	0f 85 0e 02 00
	00		 jne	 $LN86@ast_for_ar@2
$LN24@ast_for_ar@2:

; 1306 :             case tfpdef:
; 1307 :             case vfpdef:
; 1308 :                 /* XXX Need to worry about checking if TYPE(CHILD(n, i+1)) is
; 1309 :                    anything other than EQUAL or a comma? */
; 1310 :                 /* XXX Should NCH(n) check be made a separate check? */
; 1311 :                 if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {

  00266	8d 43 01	 lea	 eax, DWORD PTR [rbx+1]
  00269	3b c2		 cmp	 eax, edx
  0026b	7d 3a		 jge	 SHORT $LN23@ast_for_ar@2
  0026d	4b 8d 44 80 05	 lea	 rax, QWORD PTR [r8+r8*4+5]
  00272	66 83 3c c7 16	 cmp	 WORD PTR [rdi+rax*8], 22
  00277	75 2e		 jne	 SHORT $LN23@ast_for_ar@2

; 1312 :                     expr_ty expression = ast_for_expr(c, CHILD(n, i + 2));

  00279	83 c3 02	 add	 ebx, 2
  0027c	48 63 c3	 movsxd	 rax, ebx
  0027f	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00283	48 8d 14 cf	 lea	 rdx, QWORD PTR [rdi+rcx*8]
  00287	49 8b cc	 mov	 rcx, r12
  0028a	e8 00 00 00 00	 call	 ast_for_expr

; 1313 :                     if (!expression)

  0028f	48 85 c0	 test	 rax, rax
  00292	0f 84 34 02 00
	00		 je	 $LN76@ast_for_ar@2

; 1314 :                         return NULL;
; 1315 :                     assert(posdefaults != NULL);
; 1316 :                     asdl_seq_SET(posdefaults, j++, expression);

  00298	49 89 07	 mov	 QWORD PTR [r15], rax
  0029b	49 83 c7 08	 add	 r15, 8

; 1317 :                     i += 2;
; 1318 :                     found_default = 1;

  0029f	41 bd 01 00 00
	00		 mov	 r13d, 1
  002a5	eb 09		 jmp	 SHORT $LN20@ast_for_ar@2
$LN23@ast_for_ar@2:

; 1319 :                 }
; 1320 :                 else if (found_default) {

  002a7	45 85 ed	 test	 r13d, r13d
  002aa	0f 85 e5 01 00
	00		 jne	 $LN69@ast_for_ar@2
$LN20@ast_for_ar@2:

; 1324 :                 }
; 1325 :                 arg = ast_for_arg(c, ch);

  002b0	48 8b d6	 mov	 rdx, rsi
  002b3	49 8b cc	 mov	 rcx, r12
  002b6	e8 00 00 00 00	 call	 ast_for_arg

; 1326 :                 if (!arg)

  002bb	48 85 c0	 test	 rax, rax
  002be	0f 84 08 02 00
	00		 je	 $LN76@ast_for_ar@2

; 1327 :                     return NULL;
; 1328 :                 asdl_seq_SET(posargs, k++, arg);

  002c4	49 89 06	 mov	 QWORD PTR [r14], rax
  002c7	49 83 c6 08	 add	 r14, 8

; 1329 :                 i += 2; /* the name and the comma */

  002cb	83 c3 02	 add	 ebx, 2
$LN91@ast_for_ar@2:

; 1344 :                     i = res; /* res has new position to process */
; 1345 :                 }
; 1346 :                 else {

  002ce	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR kwdefaults$1$[rsp]
$LN9@ast_for_ar@2:

; 1301 :     j = 0;  /* index for defaults */
; 1302 :     k = 0;  /* index for args */
; 1303 :     while (i < NCH(n)) {

  002d6	8b 55 18	 mov	 edx, DWORD PTR [rbp+24]
  002d9	3b da		 cmp	 ebx, edx
  002db	0f 8d ca 01 00
	00		 jge	 $LN87@ast_for_ar@2
  002e1	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR kwdefaults$1$[rsp]
  002e9	e9 42 ff ff ff	 jmp	 $LL28@ast_for_ar@2
$LN6@ast_for_ar@2:

; 1366 :                     }
; 1367 :                 }
; 1368 :                 break;
; 1369 :             case DOUBLESTAR:
; 1370 :                 ch = CHILD(n, i+1);  /* tfpdef */

  002ee	8d 43 01	 lea	 eax, DWORD PTR [rbx+1]

; 1371 :                 assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);
; 1372 :                 kwarg = NEW_IDENTIFIER(CHILD(ch, 0));

  002f1	49 8b d4	 mov	 rdx, r12
  002f4	48 63 c8	 movsxd	 rcx, eax
  002f7	48 8d 34 89	 lea	 rsi, QWORD PTR [rcx+rcx*4]
  002fb	48 8b 4c f7 20	 mov	 rcx, QWORD PTR [rdi+rsi*8+32]
  00300	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00304	e8 00 00 00 00	 call	 new_identifier
  00309	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR kwarg$1$[rsp], rax

; 1373 :                 if (!kwarg)

  00311	48 85 c0	 test	 rax, rax
  00314	0f 84 b2 01 00
	00		 je	 $LN76@ast_for_ar@2

; 1374 :                     return NULL;
; 1375 :                 if (NCH(ch) > 1) {

  0031a	83 7c f7 18 01	 cmp	 DWORD PTR [rdi+rsi*8+24], 1
  0031f	7e 27		 jle	 SHORT $LN3@ast_for_ar@2

; 1376 :                     /* there is an annotation on the kwarg */
; 1377 :                     kwargannotation = ast_for_expr(c, CHILD(ch, 2));

  00321	48 8b 54 f7 20	 mov	 rdx, QWORD PTR [rdi+rsi*8+32]
  00326	49 8b cc	 mov	 rcx, r12
  00329	48 83 c2 50	 add	 rdx, 80			; 00000050H
  0032d	e8 00 00 00 00	 call	 ast_for_expr
  00332	48 89 44 24 60	 mov	 QWORD PTR kwargannotation$1$[rsp], rax

; 1378 :                     if (!kwargannotation)

  00337	48 85 c0	 test	 rax, rax
  0033a	0f 84 8c 01 00
	00		 je	 $LN76@ast_for_ar@2
  00340	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR kwarg$1$[rsp]
$LN3@ast_for_ar@2:

; 1379 :                         return NULL;
; 1380 :                 }
; 1381 :                 if (forbidden_name(c, kwarg, CHILD(ch, 0), 0))

  00348	4c 8b 44 f7 20	 mov	 r8, QWORD PTR [rdi+rsi*8+32]
  0034d	45 33 c9	 xor	 r9d, r9d
  00350	48 8b d0	 mov	 rdx, rax
  00353	49 8b cc	 mov	 rcx, r12
  00356	e8 00 00 00 00	 call	 forbidden_name
  0035b	85 c0		 test	 eax, eax
  0035d	0f 85 69 01 00
	00		 jne	 $LN76@ast_for_ar@2

; 1382 :                     return NULL;
; 1383 :                 i += 3;

  00363	83 c3 03	 add	 ebx, 3

; 1384 :                 break;

  00366	e9 63 ff ff ff	 jmp	 $LN91@ast_for_ar@2
$LN18@ast_for_ar@2:

; 1330 :                 break;
; 1331 :             case STAR:
; 1332 :                 if (i+1 >= NCH(n)) {

  0036b	8d 43 01	 lea	 eax, DWORD PTR [rbx+1]
  0036e	3b c2		 cmp	 eax, edx
  00370	0f 8d 3c 01 00
	00		 jge	 $LN74@ast_for_ar@2

; 1336 :                 }
; 1337 :                 ch = CHILD(n, i+1);  /* tfpdef or COMMA */

  00376	48 98		 cdqe
  00378	48 8d 34 80	 lea	 rsi, QWORD PTR [rax+rax*4]

; 1338 :                 if (TYPE(ch) == COMMA) {

  0037c	66 83 3c f7 0c	 cmp	 WORD PTR [rdi+rsi*8], 12
  00381	75 2c		 jne	 SHORT $LN16@ast_for_ar@2

; 1339 :                     int res = 0;
; 1340 :                     i += 2; /* now follows keyword only arguments */
; 1341 :                     res = handle_keywordonly_args(c, n, i,
; 1342 :                                                   kwonlyargs, kwdefaults);

  00383	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00388	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR kwonlyargs$1$[rsp]
  00390	44 8d 43 02	 lea	 r8d, DWORD PTR [rbx+2]
  00394	48 8b d5	 mov	 rdx, rbp
  00397	49 8b cc	 mov	 rcx, r12
  0039a	e8 00 00 00 00	 call	 handle_keywordonly_args
  0039f	8b d8		 mov	 ebx, eax

; 1343 :                     if (res == -1) return NULL;

  003a1	83 f8 ff	 cmp	 eax, -1
  003a4	0f 84 22 01 00
	00		 je	 $LN76@ast_for_ar@2

; 1344 :                     i = res; /* res has new position to process */
; 1345 :                 }
; 1346 :                 else {

  003aa	e9 1f ff ff ff	 jmp	 $LN91@ast_for_ar@2
$LN16@ast_for_ar@2:

; 1347 :                     vararg = NEW_IDENTIFIER(CHILD(ch, 0));

  003af	48 8b 4c f7 20	 mov	 rcx, QWORD PTR [rdi+rsi*8+32]
  003b4	49 8b d4	 mov	 rdx, r12
  003b7	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  003bb	e8 00 00 00 00	 call	 new_identifier
  003c0	48 89 44 24 50	 mov	 QWORD PTR vararg$1$[rsp], rax

; 1348 :                     if (!vararg)

  003c5	48 85 c0	 test	 rax, rax
  003c8	0f 84 fe 00 00
	00		 je	 $LN76@ast_for_ar@2

; 1349 :                         return NULL;
; 1350 :                     if (forbidden_name(c, vararg, CHILD(ch, 0), 0))

  003ce	4c 8b 44 f7 20	 mov	 r8, QWORD PTR [rdi+rsi*8+32]
  003d3	45 33 c9	 xor	 r9d, r9d
  003d6	48 8b d0	 mov	 rdx, rax
  003d9	49 8b cc	 mov	 rcx, r12
  003dc	e8 00 00 00 00	 call	 forbidden_name
  003e1	85 c0		 test	 eax, eax
  003e3	0f 85 e3 00 00
	00		 jne	 $LN76@ast_for_ar@2

; 1351 :                         return NULL;
; 1352 :                     if (NCH(ch) > 1) {

  003e9	83 7c f7 18 01	 cmp	 DWORD PTR [rdi+rsi*8+24], 1
  003ee	7e 1f		 jle	 SHORT $LN10@ast_for_ar@2

; 1353 :                         /* there is an annotation on the vararg */
; 1354 :                         varargannotation = ast_for_expr(c, CHILD(ch, 2));

  003f0	48 8b 54 f7 20	 mov	 rdx, QWORD PTR [rdi+rsi*8+32]
  003f5	49 8b cc	 mov	 rcx, r12
  003f8	48 83 c2 50	 add	 rdx, 80			; 00000050H
  003fc	e8 00 00 00 00	 call	 ast_for_expr
  00401	48 89 44 24 68	 mov	 QWORD PTR varargannotation$1$[rsp], rax

; 1355 :                         if (!varargannotation)

  00406	48 85 c0	 test	 rax, rax
  00409	0f 84 bd 00 00
	00		 je	 $LN76@ast_for_ar@2
$LN10@ast_for_ar@2:

; 1356 :                             return NULL;
; 1357 :                     }
; 1358 :                     i += 3;

  0040f	83 c3 03	 add	 ebx, 3

; 1359 :                     if (i < NCH(n) && (TYPE(CHILD(n, i)) == tfpdef
; 1360 :                                     || TYPE(CHILD(n, i)) == vfpdef)) {

  00412	3b 5d 18	 cmp	 ebx, DWORD PTR [rbp+24]
  00415	0f 8d b3 fe ff
	ff		 jge	 $LN91@ast_for_ar@2
  0041b	48 63 cb	 movsxd	 rcx, ebx
  0041e	b8 09 01 00 00	 mov	 eax, 265		; 00000109H
  00423	48 8d 14 89	 lea	 rdx, QWORD PTR [rcx+rcx*4]
  00427	48 8b 4d 20	 mov	 rcx, QWORD PTR [rbp+32]
  0042b	44 0f b7 04 d1	 movzx	 r8d, WORD PTR [rcx+rdx*8]
  00430	66 44 3b c0	 cmp	 r8w, ax
  00434	74 0f		 je	 SHORT $LN8@ast_for_ar@2
  00436	b8 0b 01 00 00	 mov	 eax, 267		; 0000010bH
  0043b	66 44 3b c0	 cmp	 r8w, ax
  0043f	0f 85 89 fe ff
	ff		 jne	 $LN91@ast_for_ar@2
$LN8@ast_for_ar@2:

; 1361 :                         int res = 0;
; 1362 :                         res = handle_keywordonly_args(c, n, i,
; 1363 :                                                       kwonlyargs, kwdefaults);

  00445	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR kwdefaults$1$[rsp]
  0044d	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR kwonlyargs$1$[rsp]
  00455	44 8b c3	 mov	 r8d, ebx
  00458	48 8b d5	 mov	 rdx, rbp
  0045b	49 8b cc	 mov	 rcx, r12
  0045e	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00463	e8 00 00 00 00	 call	 handle_keywordonly_args
  00468	8b d8		 mov	 ebx, eax

; 1364 :                         if (res == -1) return NULL;

  0046a	83 f8 ff	 cmp	 eax, -1
  0046d	74 5d		 je	 SHORT $LN76@ast_for_ar@2

; 1365 :                         i = res; /* res has new position to process */

  0046f	e9 62 fe ff ff	 jmp	 $LN9@ast_for_ar@2
$LN86@ast_for_ar@2:

; 1385 :             default:
; 1386 :                 PyErr_Format(PyExc_SystemError,
; 1387 :                              "unexpected node in varargslist: %d @ %d",
; 1388 :                              TYPE(ch), i);

  00474	44 0f bf 06	 movsx	 r8d, WORD PTR [rsi]
  00478	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0047f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@EMEDAENJ@unexpected?5node?5in?5varargslist?3?5@
  00486	44 8b cb	 mov	 r9d, ebx
  00489	e8 00 00 00 00	 call	 PyErr_Format

; 1389 :                 return NULL;

  0048e	33 c0		 xor	 eax, eax
  00490	e9 8d 00 00 00	 jmp	 $LN92@ast_for_ar@2
$LN69@ast_for_ar@2:

; 1321 :                     ast_error(c, n,
; 1322 :                              "non-default argument follows default argument");

  00495	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CO@BBDJNKDC@non?9default?5argument?5follows?5def@
  0049c	48 8b d5	 mov	 rdx, rbp
  0049f	49 8b cc	 mov	 rcx, r12
  004a2	e8 00 00 00 00	 call	 ast_error

; 1323 :                     return NULL;

  004a7	33 c0		 xor	 eax, eax
  004a9	eb 77		 jmp	 SHORT $LN92@ast_for_ar@2
$LN87@ast_for_ar@2:

; 1364 :                         if (res == -1) return NULL;

  004ab	4c 8b 7c 24 50	 mov	 r15, QWORD PTR vararg$1$[rsp]
  004b0	eb 26		 jmp	 SHORT $LN27@ast_for_ar@2
$LN74@ast_for_ar@2:

; 1333 :                     ast_error(c, CHILD(n, i),
; 1334 :                         "named arguments must follow bare *");

  004b2	48 63 c3	 movsxd	 rax, ebx
  004b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CD@MPPDOCEK@named?5arguments?5must?5follow?5bare@
  004bc	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  004c0	48 8d 14 cf	 lea	 rdx, QWORD PTR [rdi+rcx*8]
  004c4	49 8b cc	 mov	 rcx, r12
  004c7	e8 00 00 00 00	 call	 ast_error
$LN76@ast_for_ar@2:

; 1335 :                     return NULL;

  004cc	33 c0		 xor	 eax, eax
  004ce	eb 52		 jmp	 SHORT $LN92@ast_for_ar@2
$LN89@ast_for_ar@2:
  004d0	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR kwdefaults$1$[rsp]
$LN27@ast_for_ar@2:

; 1390 :         }
; 1391 :     }
; 1392 :     return arguments(posargs, vararg, varargannotation, kwonlyargs, kwarg,
; 1393 :                     kwargannotation, posdefaults, kwdefaults, c->c_arena);

  004d8	49 8b 44 24 08	 mov	 rax, QWORD PTR [r12+8]
  004dd	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR kwonlyargs$1$[rsp]
  004e5	4c 8b 44 24 68	 mov	 r8, QWORD PTR varargannotation$1$[rsp]
  004ea	48 8b 4c 24 70	 mov	 rcx, QWORD PTR posargs$1$[rsp]
  004ef	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  004f4	48 8b 44 24 58	 mov	 rax, QWORD PTR posdefaults$1$[rsp]
  004f9	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  004fe	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00503	48 8b 44 24 60	 mov	 rax, QWORD PTR kwargannotation$1$[rsp]
  00508	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0050d	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR kwarg$1$[rsp]
  00515	49 8b d7	 mov	 rdx, r15
  00518	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0051d	e8 00 00 00 00	 call	 _Py_arguments
$LN92@ast_for_ar@2:
  00522	4c 8b b4 24 c0
	00 00 00	 mov	 r14, QWORD PTR [rsp+192]
$LN52@ast_for_ar@2:

; 1394 : }

  0052a	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00531	41 5f		 pop	 r15
  00533	41 5d		 pop	 r13
  00535	41 5c		 pop	 r12
  00537	5f		 pop	 rdi
  00538	5e		 pop	 rsi
  00539	5d		 pop	 rbp
  0053a	5b		 pop	 rbx
  0053b	c3		 ret	 0
ast_for_arguments ENDP
_TEXT	ENDS
EXTRN	_Py_Attribute:PROC
EXTRN	_Py_Name:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_dotted_name DD imagerel ast_for_dotted_name
	DD	imagerel ast_for_dotted_name+82
	DD	imagerel $unwind$ast_for_dotted_name
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ast_for_dotted_name DD imagerel ast_for_dotted_name+82
	DD	imagerel ast_for_dotted_name+105
	DD	imagerel $chain$0$ast_for_dotted_name
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ast_for_dotted_name DD imagerel ast_for_dotted_name+105
	DD	imagerel ast_for_dotted_name+219
	DD	imagerel $chain$2$ast_for_dotted_name
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ast_for_dotted_name DD imagerel ast_for_dotted_name+219
	DD	imagerel ast_for_dotted_name+239
	DD	imagerel $chain$3$ast_for_dotted_name
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$ast_for_dotted_name DD imagerel ast_for_dotted_name+239
	DD	imagerel ast_for_dotted_name+243
	DD	imagerel $chain$5$ast_for_dotted_name
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$ast_for_dotted_name DD 060021H
	DD	0cc400H
	DD	0b7400H
	DD	0a3400H
	DD	imagerel ast_for_dotted_name
	DD	imagerel ast_for_dotted_name+82
	DD	imagerel $unwind$ast_for_dotted_name
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ast_for_dotted_name DD 021H
	DD	imagerel ast_for_dotted_name+82
	DD	imagerel ast_for_dotted_name+105
	DD	imagerel $chain$0$ast_for_dotted_name
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ast_for_dotted_name DD 040f21H
	DD	0b740fH
	DD	0a3405H
	DD	imagerel ast_for_dotted_name+82
	DD	imagerel ast_for_dotted_name+105
	DD	imagerel $chain$0$ast_for_dotted_name
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ast_for_dotted_name DD 020521H
	DD	0cc405H
	DD	imagerel ast_for_dotted_name
	DD	imagerel ast_for_dotted_name+82
	DD	imagerel $unwind$ast_for_dotted_name
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_dotted_name DD 060e01H
	DD	0d540eH
	DD	0e00a520eH
	DD	06006d008H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_dotted_name
_TEXT	SEGMENT
c$ = 80
n$ = 88
ast_for_dotted_name PROC				; COMDAT

; 1398 : {

  00000	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00005	56		 push	 rsi
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1399 :     expr_ty e;
; 1400 :     identifier id;
; 1401 :     int lineno, col_offset;
; 1402 :     int i;
; 1403 : 
; 1404 :     REQ(n, dotted_name);
; 1405 : 
; 1406 :     lineno = LINENO(n);

  0000e	44 8b 6a 10	 mov	 r13d, DWORD PTR [rdx+16]

; 1407 :     col_offset = n->n_col_offset;

  00012	44 8b 72 14	 mov	 r14d, DWORD PTR [rdx+20]
  00016	48 8b e9	 mov	 rbp, rcx

; 1408 : 
; 1409 :     id = NEW_IDENTIFIER(CHILD(n, 0));

  00019	48 8b 4a 20	 mov	 rcx, QWORD PTR [rdx+32]
  0001d	48 8b f2	 mov	 rsi, rdx
  00020	48 8b d5	 mov	 rdx, rbp
  00023	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00027	e8 00 00 00 00	 call	 new_identifier
  0002c	48 8b c8	 mov	 rcx, rax

; 1410 :     if (!id)

  0002f	48 85 c0	 test	 rax, rax
  00032	75 0f		 jne	 SHORT $LN7@ast_for_do

; 1426 : }

  00034	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00039	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003d	41 5e		 pop	 r14
  0003f	41 5d		 pop	 r13
  00041	5e		 pop	 rsi
  00042	c3		 ret	 0
$LN7@ast_for_do:

; 1411 :         return NULL;
; 1412 :     e = Name(id, Load, lineno, col_offset, c->c_arena);

  00043	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  00047	45 8b ce	 mov	 r9d, r14d
  0004a	45 8b c5	 mov	 r8d, r13d
  0004d	ba 01 00 00 00	 mov	 edx, 1
  00052	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  00057	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005c	e8 00 00 00 00	 call	 _Py_Name
  00061	4c 8b e0	 mov	 r12, rax

; 1413 :     if (!e)

  00064	48 85 c0	 test	 rax, rax
  00067	74 72		 je	 SHORT $LN14@ast_for_do
$LN6@ast_for_do:
  00069	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx

; 1414 :         return NULL;
; 1415 : 
; 1416 :     for (i = 2; i < NCH(n); i+=2) {

  0006e	bb 02 00 00 00	 mov	 ebx, 2
  00073	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  00078	39 5e 18	 cmp	 DWORD PTR [rsi+24], ebx
  0007b	7e 51		 jle	 SHORT $LN3@ast_for_do
  0007d	bf 50 00 00 00	 mov	 edi, 80			; 00000050H
$LL5@ast_for_do:

; 1417 :         id = NEW_IDENTIFIER(CHILD(n, i));

  00082	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]
  00086	48 8b d5	 mov	 rdx, rbp
  00089	48 8b 4c 39 08	 mov	 rcx, QWORD PTR [rcx+rdi+8]
  0008e	e8 00 00 00 00	 call	 new_identifier

; 1418 :         if (!id)

  00093	48 85 c0	 test	 rax, rax
  00096	74 57		 je	 SHORT $LN11@ast_for_do

; 1420 :         e = Attribute(e, id, Load, lineno, col_offset, c->c_arena);

  00098	48 8b 4d 08	 mov	 rcx, QWORD PTR [rbp+8]
  0009c	45 8b cd	 mov	 r9d, r13d
  0009f	41 b8 01 00 00
	00		 mov	 r8d, 1
  000a5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000aa	49 8b cc	 mov	 rcx, r12
  000ad	48 8b d0	 mov	 rdx, rax
  000b0	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  000b5	e8 00 00 00 00	 call	 _Py_Attribute
  000ba	4c 8b e0	 mov	 r12, rax

; 1421 :         if (!e)

  000bd	48 85 c0	 test	 rax, rax
  000c0	74 2d		 je	 SHORT $LN11@ast_for_do

; 1414 :         return NULL;
; 1415 : 
; 1416 :     for (i = 2; i < NCH(n); i+=2) {

  000c2	83 c3 02	 add	 ebx, 2
  000c5	48 83 c7 50	 add	 rdi, 80			; 00000050H
  000c9	3b 5e 18	 cmp	 ebx, DWORD PTR [rsi+24]
  000cc	7c b4		 jl	 SHORT $LL5@ast_for_do
$LN3@ast_for_do:

; 1422 :             return NULL;
; 1423 :     }
; 1424 : 
; 1425 :     return e;

  000ce	49 8b c4	 mov	 rax, r12
$LN16@ast_for_do:
  000d1	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000d6	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
$LN14@ast_for_do:
  000db	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]

; 1426 : }

  000e0	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  000e5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e9	41 5e		 pop	 r14
  000eb	41 5d		 pop	 r13
  000ed	5e		 pop	 rsi
  000ee	c3		 ret	 0
$LN11@ast_for_do:

; 1419 :             return NULL;

  000ef	33 c0		 xor	 eax, eax
  000f1	eb de		 jmp	 SHORT $LN16@ast_for_do
ast_for_dotted_name ENDP
_TEXT	ENDS
EXTRN	_Py_Lambda:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_lambdef DD imagerel ast_for_lambdef
	DD	imagerel ast_for_lambdef+221
	DD	imagerel $unwind$ast_for_lambdef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_lambdef DD 061001H
	DD	0d6410H
	DD	0c3410H
	DD	0700c9210H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_lambdef
_TEXT	SEGMENT
c$ = 96
n$ = 104
ast_for_lambdef PROC					; COMDAT

; 1551 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00007	49 89 73 10	 mov	 QWORD PTR [r11+16], rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 1552 :     /* lambdef: 'lambda' [varargslist] ':' test
; 1553 :        lambdef_nocond: 'lambda' [varargslist] ':' test_nocond */
; 1554 :     arguments_ty args;
; 1555 :     expr_ty expression;
; 1556 : 
; 1557 :     if (NCH(n) == 3) {

  00010	83 7a 18 03	 cmp	 DWORD PTR [rdx+24], 3
  00014	48 8b da	 mov	 rbx, rdx
  00017	48 8b f9	 mov	 rdi, rcx
  0001a	75 5b		 jne	 SHORT $LN6@ast_for_la

; 1558 :         args = arguments(NULL, NULL, NULL, NULL, NULL, NULL, NULL,
; 1559 :                          NULL, c->c_arena);

  0001c	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00020	45 33 c9	 xor	 r9d, r9d
  00023	45 33 c0	 xor	 r8d, r8d
  00026	49 89 43 e8	 mov	 QWORD PTR [r11-24], rax
  0002a	33 c0		 xor	 eax, eax
  0002c	33 d2		 xor	 edx, edx
  0002e	49 89 43 e0	 mov	 QWORD PTR [r11-32], rax
  00032	49 89 43 d8	 mov	 QWORD PTR [r11-40], rax
  00036	49 89 43 d0	 mov	 QWORD PTR [r11-48], rax
  0003a	33 c9		 xor	 ecx, ecx
  0003c	49 89 43 c8	 mov	 QWORD PTR [r11-56], rax
  00040	e8 00 00 00 00	 call	 _Py_arguments
  00045	48 8b f0	 mov	 rsi, rax

; 1560 :         if (!args)

  00048	48 85 c0	 test	 rax, rax

; 1561 :             return NULL;

  0004b	74 18		 je	 SHORT $LN9@ast_for_la

; 1562 :         expression = ast_for_expr(c, CHILD(n, 2));

  0004d	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00051	48 8b cf	 mov	 rcx, rdi
  00054	48 83 c2 50	 add	 rdx, 80			; 00000050H
  00058	e8 00 00 00 00	 call	 ast_for_expr
  0005d	48 8b d0	 mov	 rdx, rax

; 1563 :         if (!expression)

  00060	48 85 c0	 test	 rax, rax
  00063	75 4f		 jne	 SHORT $LN1@ast_for_la
$LN9@ast_for_la:

; 1564 :             return NULL;

  00065	33 c0		 xor	 eax, eax

; 1576 : }

  00067	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0006c	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00071	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
$LN6@ast_for_la:

; 1565 :     }
; 1566 :     else {
; 1567 :         args = ast_for_arguments(c, CHILD(n, 1));

  00077	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  0007b	48 83 c2 28	 add	 rdx, 40			; 00000028H
  0007f	e8 00 00 00 00	 call	 ast_for_arguments
  00084	48 8b f0	 mov	 rsi, rax

; 1568 :         if (!args)

  00087	48 85 c0	 test	 rax, rax

; 1569 :             return NULL;

  0008a	74 d9		 je	 SHORT $LN9@ast_for_la

; 1570 :         expression = ast_for_expr(c, CHILD(n, 3));

  0008c	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00090	48 8b cf	 mov	 rcx, rdi
  00093	48 83 c2 78	 add	 rdx, 120		; 00000078H
  00097	e8 00 00 00 00	 call	 ast_for_expr
  0009c	48 8b d0	 mov	 rdx, rax

; 1571 :         if (!expression)

  0009f	48 85 c0	 test	 rax, rax
  000a2	75 10		 jne	 SHORT $LN1@ast_for_la

; 1576 : }

  000a4	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000a9	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  000ae	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000b2	5f		 pop	 rdi
  000b3	c3		 ret	 0
$LN1@ast_for_la:

; 1572 :             return NULL;
; 1573 :     }
; 1574 : 
; 1575 :     return Lambda(args, expression, LINENO(n), n->n_col_offset, c->c_arena);

  000b4	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  000b8	44 8b 4b 14	 mov	 r9d, DWORD PTR [rbx+20]
  000bc	44 8b 43 10	 mov	 r8d, DWORD PTR [rbx+16]
  000c0	48 8b ce	 mov	 rcx, rsi
  000c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c8	e8 00 00 00 00	 call	 _Py_Lambda

; 1576 : }

  000cd	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000d2	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  000d7	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000db	5f		 pop	 rdi
  000dc	c3		 ret	 0
ast_for_lambdef ENDP
_TEXT	ENDS
EXTRN	_Py_IfExp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_ifexpr DD imagerel ast_for_ifexpr
	DD	imagerel ast_for_ifexpr+166
	DD	imagerel $unwind$ast_for_ifexpr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_ifexpr DD 084201H
	DD	086442H
	DD	0a540fH
	DD	09340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_ifexpr
_TEXT	SEGMENT
c$ = 64
n$ = 72
ast_for_ifexpr PROC					; COMDAT

; 1580 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b da	 mov	 rbx, rdx

; 1581 :     /* test: or_test 'if' or_test 'else' test */
; 1582 :     expr_ty expression, body, orelse;
; 1583 : 
; 1584 :     assert(NCH(n) == 5);
; 1585 :     body = ast_for_expr(c, CHILD(n, 0));

  00012	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00016	48 8b f9	 mov	 rdi, rcx
  00019	e8 00 00 00 00	 call	 ast_for_expr
  0001e	48 8b e8	 mov	 rbp, rax

; 1586 :     if (!body)

  00021	48 85 c0	 test	 rax, rax
  00024	75 10		 jne	 SHORT $LN3@ast_for_if

; 1596 : }

  00026	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0002b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00030	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
$LN3@ast_for_if:

; 1587 :         return NULL;
; 1588 :     expression = ast_for_expr(c, CHILD(n, 2));

  00036	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  0003a	48 8b cf	 mov	 rcx, rdi
  0003d	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00042	48 83 c2 50	 add	 rdx, 80			; 00000050H
  00046	e8 00 00 00 00	 call	 ast_for_expr
  0004b	48 8b f0	 mov	 rsi, rax

; 1589 :     if (!expression)

  0004e	48 85 c0	 test	 rax, rax

; 1590 :         return NULL;

  00051	74 1b		 je	 SHORT $LN7@ast_for_if

; 1591 :     orelse = ast_for_expr(c, CHILD(n, 4));

  00053	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00057	48 8b cf	 mov	 rcx, rdi
  0005a	48 81 c2 a0 00
	00 00		 add	 rdx, 160		; 000000a0H
  00061	e8 00 00 00 00	 call	 ast_for_expr
  00066	4c 8b c0	 mov	 r8, rax

; 1592 :     if (!orelse)

  00069	48 85 c0	 test	 rax, rax
  0006c	75 04		 jne	 SHORT $LN1@ast_for_if
$LN7@ast_for_if:

; 1593 :         return NULL;

  0006e	33 c0		 xor	 eax, eax
  00070	eb 1f		 jmp	 SHORT $LN6@ast_for_if
$LN1@ast_for_if:

; 1594 :     return IfExp(expression, body, orelse, LINENO(n), n->n_col_offset,
; 1595 :                  c->c_arena);

  00072	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00076	44 8b 4b 10	 mov	 r9d, DWORD PTR [rbx+16]
  0007a	48 8b d5	 mov	 rdx, rbp
  0007d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00082	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  00085	48 8b ce	 mov	 rcx, rsi
  00088	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0008c	e8 00 00 00 00	 call	 _Py_IfExp
$LN6@ast_for_if:

; 1596 : }

  00091	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00096	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0009b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000a0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a4	5f		 pop	 rdi
  000a5	c3		 ret	 0
ast_for_ifexpr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@PJBBHOMK@logic?5error?5in?5count_comp_fors?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$count_comp_fors DD imagerel count_comp_fors
	DD	imagerel count_comp_fors+123
	DD	imagerel $unwind$count_comp_fors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$count_comp_fors DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BP@PJBBHOMK@logic?5error?5in?5count_comp_fors?$AA@
CONST	SEGMENT
??_C@_0BP@PJBBHOMK@logic?5error?5in?5count_comp_fors?$AA@ DB 'logic error'
	DB	' in count_comp_fors', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT count_comp_fors
_TEXT	SEGMENT
n$ = 48
count_comp_fors PROC					; COMDAT

; 1606 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1611 :     REQ(n, comp_for);
; 1612 :     if (NCH(n) == 5)

  00004	83 79 18 05	 cmp	 DWORD PTR [rcx+24], 5
  00008	ba 01 00 00 00	 mov	 edx, 1
  0000d	75 4a		 jne	 SHORT $LN15@count_comp
  0000f	41 b9 4d 01 00
	00		 mov	 r9d, 333		; 0000014dH
  00015	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$count_comp_for$22838:

; 1616 :   count_comp_iter:
; 1617 :     REQ(n, comp_iter);
; 1618 :     n = CHILD(n, 0);

  00020	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
  00024	48 8b 88 c0 00
	00 00		 mov	 rcx, QWORD PTR [rax+192]

; 1619 :     if (TYPE(n) == comp_for)

  0002b	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  0002e	66 41 3b c1	 cmp	 ax, r9w
  00032	74 1d		 je	 SHORT $LN13@count_comp
$count_comp_iter$22842:

; 1620 :         goto count_comp_for;
; 1621 :     else if (TYPE(n) == comp_if) {

  00034	66 41 3b c0	 cmp	 ax, r8w
  00038	75 26		 jne	 SHORT $LN1@count_comp

; 1622 :         if (NCH(n) == 3) {

  0003a	83 79 18 03	 cmp	 DWORD PTR [rcx+24], 3
  0003e	75 19		 jne	 SHORT $LN15@count_comp

; 1616 :   count_comp_iter:
; 1617 :     REQ(n, comp_iter);
; 1618 :     n = CHILD(n, 0);

  00040	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
  00044	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]

; 1619 :     if (TYPE(n) == comp_for)

  00048	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  0004b	66 41 3b c1	 cmp	 ax, r9w
  0004f	75 e3		 jne	 SHORT $count_comp_iter$22842
$LN13@count_comp:

; 1607 :     int n_fors = 0;
; 1608 : 
; 1609 :   count_comp_for:
; 1610 :     n_fors++;

  00051	ff c2		 inc	 edx

; 1611 :     REQ(n, comp_for);
; 1612 :     if (NCH(n) == 5)

  00053	83 79 18 05	 cmp	 DWORD PTR [rcx+24], 5
  00057	74 c7		 je	 SHORT $count_comp_for$22838
$LN15@count_comp:

; 1613 :         n = CHILD(n, 4);
; 1614 :     else
; 1615 :         return n_fors;

  00059	8b c2		 mov	 eax, edx

; 1634 : }

  0005b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005f	c3		 ret	 0
$LN1@count_comp:

; 1623 :             n = CHILD(n, 2);
; 1624 :             goto count_comp_iter;
; 1625 :         }
; 1626 :         else
; 1627 :             return n_fors;
; 1628 :     }
; 1629 : 
; 1630 :     /* Should never be reached */
; 1631 :     PyErr_SetString(PyExc_SystemError,
; 1632 :                     "logic error in count_comp_fors");

  00060	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@PJBBHOMK@logic?5error?5in?5count_comp_fors?$AA@
  0006e	e8 00 00 00 00	 call	 PyErr_SetString

; 1633 :     return -1;

  00073	83 c8 ff	 or	 eax, -1

; 1634 : }

  00076	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007a	c3		 ret	 0
count_comp_fors ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT count_comp_ifs
_TEXT	SEGMENT
n$ = 8
count_comp_ifs PROC					; COMDAT

; 1644 :     int n_ifs = 0;
; 1645 : 
; 1646 :     while (1) {
; 1647 :         REQ(n, comp_iter);
; 1648 :         if (TYPE(CHILD(n, 0)) == comp_for)

  00000	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
  00004	b9 4d 01 00 00	 mov	 ecx, 333		; 0000014dH
  00009	33 d2		 xor	 edx, edx
  0000b	66 39 08	 cmp	 WORD PTR [rax], cx
  0000e	74 15		 je	 SHORT $LN9@count_comp@2
$LL4@count_comp@2:

; 1650 :         n = CHILD(n, 0);
; 1651 :         REQ(n, comp_if);
; 1652 :         n_ifs++;

  00010	ff c2		 inc	 edx

; 1653 :         if (NCH(n) == 2)

  00012	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  00016	74 0d		 je	 SHORT $LN9@count_comp@2

; 1654 :             return n_ifs;
; 1655 :         n = CHILD(n, 2);

  00018	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001c	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00020	66 39 08	 cmp	 WORD PTR [rax], cx
  00023	75 eb		 jne	 SHORT $LL4@count_comp@2
$LN9@count_comp@2:

; 1649 :             return n_ifs;

  00025	8b c2		 mov	 eax, edx

; 1656 :     }
; 1657 : }

  00027	c3		 ret	 0
count_comp_ifs ENDP
_TEXT	ENDS
EXTRN	_Py_Slice:PROC
EXTRN	_Py_Index:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_slice DD imagerel ast_for_slice
	DD	imagerel ast_for_slice+308
	DD	imagerel $unwind$ast_for_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_slice DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0e01a321eH
	DD	0c016d018H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_slice
_TEXT	SEGMENT
c$ = 64
n$ = 72
ast_for_slice PROC					; COMDAT

; 1969 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1970 :     node *ch;
; 1971 :     expr_ty lower = NULL, upper = NULL, step = NULL;
; 1972 : 
; 1973 :     REQ(n, subscript);
; 1974 : 
; 1975 :     /*
; 1976 :        subscript: test | [test] ':' [test] [sliceop]
; 1977 :        sliceop: ':' [test]
; 1978 :     */
; 1979 :     ch = CHILD(n, 0);

  0001e	48 8b 5a 20	 mov	 rbx, QWORD PTR [rdx+32]
  00022	45 33 ed	 xor	 r13d, r13d

; 1980 :     if (NCH(n) == 1 && TYPE(ch) == test) {

  00025	83 7a 18 01	 cmp	 DWORD PTR [rdx+24], 1
  00029	45 8b e5	 mov	 r12d, r13d
  0002c	45 8b f5	 mov	 r14d, r13d
  0002f	48 8b f2	 mov	 rsi, rdx
  00032	48 8b f9	 mov	 rdi, rcx
  00035	bd 2e 01 00 00	 mov	 ebp, 302		; 0000012eH
  0003a	75 23		 jne	 SHORT $LN16@ast_for_sl
  0003c	66 39 2b	 cmp	 WORD PTR [rbx], bp
  0003f	75 33		 jne	 SHORT $LN13@ast_for_sl

; 1981 :         /* 'step' variable hold no significance in terms of being used over
; 1982 :            other vars */
; 1983 :         step = ast_for_expr(c, ch);

  00041	48 8b d3	 mov	 rdx, rbx
  00044	e8 00 00 00 00	 call	 ast_for_expr

; 1984 :         if (!step)

  00049	48 85 c0	 test	 rax, rax

; 1985 :             return NULL;

  0004c	74 4f		 je	 SHORT $LN19@ast_for_sl

; 1986 : 
; 1987 :         return Index(step, c->c_arena);

  0004e	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  00052	48 8b c8	 mov	 rcx, rax
  00055	e8 00 00 00 00	 call	 _Py_Index
  0005a	e9 b6 00 00 00	 jmp	 $LN17@ast_for_sl
$LN16@ast_for_sl:

; 1988 :     }
; 1989 : 
; 1990 :     if (TYPE(ch) == test) {

  0005f	66 39 2b	 cmp	 WORD PTR [rbx], bp
  00062	75 10		 jne	 SHORT $LN13@ast_for_sl

; 1991 :         lower = ast_for_expr(c, ch);

  00064	48 8b d3	 mov	 rdx, rbx
  00067	e8 00 00 00 00	 call	 ast_for_expr
  0006c	4c 8b e8	 mov	 r13, rax

; 1992 :         if (!lower)

  0006f	48 85 c0	 test	 rax, rax

; 1993 :             return NULL;

  00072	74 29		 je	 SHORT $LN19@ast_for_sl
$LN13@ast_for_sl:

; 1994 :     }
; 1995 : 
; 1996 :     /* If there's an upper bound it's in the second or third position. */
; 1997 :     if (TYPE(ch) == COLON) {

  00074	66 83 3b 0b	 cmp	 WORD PTR [rbx], 11
  00078	75 27		 jne	 SHORT $LN12@ast_for_sl

; 1998 :         if (NCH(n) > 1) {

  0007a	83 7e 18 01	 cmp	 DWORD PTR [rsi+24], 1
  0007e	7e 44		 jle	 SHORT $LN5@ast_for_sl

; 1999 :             node *n2 = CHILD(n, 1);

  00080	48 8b 56 20	 mov	 rdx, QWORD PTR [rsi+32]
  00084	48 83 c2 28	 add	 rdx, 40			; 00000028H

; 2000 : 
; 2001 :             if (TYPE(n2) == test) {

  00088	66 39 2a	 cmp	 WORD PTR [rdx], bp
  0008b	75 37		 jne	 SHORT $LN5@ast_for_sl

; 2002 :                 upper = ast_for_expr(c, n2);

  0008d	48 8b cf	 mov	 rcx, rdi
  00090	e8 00 00 00 00	 call	 ast_for_expr
  00095	4c 8b e0	 mov	 r12, rax

; 2003 :                 if (!upper)

  00098	48 85 c0	 test	 rax, rax
  0009b	75 27		 jne	 SHORT $LN5@ast_for_sl
$LN19@ast_for_sl:

; 2004 :                     return NULL;

  0009d	33 c0		 xor	 eax, eax
  0009f	eb 74		 jmp	 SHORT $LN17@ast_for_sl
$LN12@ast_for_sl:

; 2005 :             }
; 2006 :         }
; 2007 :     } else if (NCH(n) > 2) {

  000a1	83 7e 18 02	 cmp	 DWORD PTR [rsi+24], 2
  000a5	7e 1d		 jle	 SHORT $LN5@ast_for_sl

; 2008 :         node *n2 = CHILD(n, 2);

  000a7	48 8b 56 20	 mov	 rdx, QWORD PTR [rsi+32]
  000ab	48 83 c2 50	 add	 rdx, 80			; 00000050H

; 2009 : 
; 2010 :         if (TYPE(n2) == test) {

  000af	66 39 2a	 cmp	 WORD PTR [rdx], bp
  000b2	75 10		 jne	 SHORT $LN5@ast_for_sl

; 2011 :             upper = ast_for_expr(c, n2);

  000b4	48 8b cf	 mov	 rcx, rdi
  000b7	e8 00 00 00 00	 call	 ast_for_expr
  000bc	4c 8b e0	 mov	 r12, rax

; 2012 :             if (!upper)

  000bf	48 85 c0	 test	 rax, rax
  000c2	74 51		 je	 SHORT $LN17@ast_for_sl
$LN5@ast_for_sl:

; 2013 :                 return NULL;
; 2014 :         }
; 2015 :     }
; 2016 : 
; 2017 :     ch = CHILD(n, NCH(n) - 1);

  000c4	8b 46 18	 mov	 eax, DWORD PTR [rsi+24]

; 2018 :     if (TYPE(ch) == sliceop) {

  000c7	b9 45 01 00 00	 mov	 ecx, 325		; 00000145H
  000cc	ff c8		 dec	 eax
  000ce	48 98		 cdqe
  000d0	48 8d 14 80	 lea	 rdx, QWORD PTR [rax+rax*4]
  000d4	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  000d8	66 39 0c d0	 cmp	 WORD PTR [rax+rdx*8], cx
  000dc	75 25		 jne	 SHORT $LN1@ast_for_sl

; 2019 :         if (NCH(ch) != 1) {

  000de	83 7c d0 18 01	 cmp	 DWORD PTR [rax+rdx*8+24], 1
  000e3	74 1e		 je	 SHORT $LN1@ast_for_sl

; 2020 :             ch = CHILD(ch, 1);

  000e5	48 8b 54 d0 20	 mov	 rdx, QWORD PTR [rax+rdx*8+32]
  000ea	48 83 c2 28	 add	 rdx, 40			; 00000028H

; 2021 :             if (TYPE(ch) == test) {

  000ee	66 39 2a	 cmp	 WORD PTR [rdx], bp
  000f1	75 10		 jne	 SHORT $LN1@ast_for_sl

; 2022 :                 step = ast_for_expr(c, ch);

  000f3	48 8b cf	 mov	 rcx, rdi
  000f6	e8 00 00 00 00	 call	 ast_for_expr
  000fb	4c 8b f0	 mov	 r14, rax

; 2023 :                 if (!step)

  000fe	48 85 c0	 test	 rax, rax

; 2024 :                     return NULL;

  00101	74 9a		 je	 SHORT $LN19@ast_for_sl
$LN1@ast_for_sl:

; 2025 :             }
; 2026 :         }
; 2027 :     }
; 2028 : 
; 2029 :     return Slice(lower, upper, step, c->c_arena);

  00103	4c 8b 4f 08	 mov	 r9, QWORD PTR [rdi+8]
  00107	4d 8b c6	 mov	 r8, r14
  0010a	49 8b d4	 mov	 rdx, r12
  0010d	49 8b cd	 mov	 rcx, r13
  00110	e8 00 00 00 00	 call	 _Py_Slice
$LN17@ast_for_sl:

; 2030 : }

  00115	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0011a	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0011f	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00124	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00129	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0012d	41 5e		 pop	 r14
  0012f	41 5d		 pop	 r13
  00131	41 5c		 pop	 r12
  00133	c3		 ret	 0
ast_for_slice ENDP
_TEXT	ENDS
EXTRN	_Py_BinOp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_binop DD imagerel ast_for_binop
	DD	imagerel ast_for_binop+130
	DD	imagerel $unwind$ast_for_binop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ast_for_binop DD imagerel ast_for_binop+130
	DD	imagerel ast_for_binop+347
	DD	imagerel $chain$4$ast_for_binop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$ast_for_binop DD imagerel ast_for_binop+347
	DD	imagerel ast_for_binop+351
	DD	imagerel $chain$6$ast_for_binop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$ast_for_binop DD 0a0021H
	DD	06f400H
	DD	07d400H
	DD	0fc400H
	DD	0e7400H
	DD	0c6400H
	DD	imagerel ast_for_binop
	DD	imagerel ast_for_binop+130
	DD	imagerel $unwind$ast_for_binop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ast_for_binop DD 0a1c21H
	DD	06f41cH
	DD	07d416H
	DD	0fc411H
	DD	0e740aH
	DD	0c6405H
	DD	imagerel ast_for_binop
	DD	imagerel ast_for_binop+130
	DD	imagerel $unwind$ast_for_binop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_binop DD 040901H
	DD	0e0057209H
	DD	030025003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_binop
_TEXT	SEGMENT
c$ = 96
result$1$ = 104
n$ = 104
ast_for_binop PROC					; COMDAT

; 2034 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	41 56		 push	 r14
  00005	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00009	48 8b ea	 mov	 rbp, rdx

; 2035 :     /* Must account for a sequence of expressions.
; 2036 :        How should A op B op C by represented?
; 2037 :        BinOp(BinOp(A, op, B), op, C).
; 2038 :     */
; 2039 : 
; 2040 :     int i, nops;
; 2041 :     expr_ty expr1, expr2, result;
; 2042 :     operator_ty newoperator;
; 2043 : 
; 2044 :     expr1 = ast_for_expr(c, CHILD(n, 0));

  0000c	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00010	4c 8b f1	 mov	 r14, rcx
  00013	e8 00 00 00 00	 call	 ast_for_expr
  00018	48 8b d8	 mov	 rbx, rax

; 2045 :     if (!expr1)

  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0b		 jne	 SHORT $LN10@ast_for_bi
$LN23@ast_for_bi:

; 2046 :         return NULL;

  00020	33 c0		 xor	 eax, eax

; 2082 : }

  00022	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00026	41 5e		 pop	 r14
  00028	5d		 pop	 rbp
  00029	5b		 pop	 rbx
  0002a	c3		 ret	 0
$LN10@ast_for_bi:

; 2047 : 
; 2048 :     expr2 = ast_for_expr(c, CHILD(n, 2));

  0002b	48 8b 55 20	 mov	 rdx, QWORD PTR [rbp+32]
  0002f	49 8b ce	 mov	 rcx, r14
  00032	48 83 c2 50	 add	 rdx, 80			; 00000050H
  00036	e8 00 00 00 00	 call	 ast_for_expr
  0003b	4c 8b c0	 mov	 r8, rax

; 2049 :     if (!expr2)

  0003e	48 85 c0	 test	 rax, rax

; 2050 :         return NULL;

  00041	74 dd		 je	 SHORT $LN23@ast_for_bi

; 2051 : 
; 2052 :     newoperator = get_operator(CHILD(n, 1));

  00043	48 8b 4d 20	 mov	 rcx, QWORD PTR [rbp+32]
  00047	48 83 c1 28	 add	 rcx, 40			; 00000028H
  0004b	e8 00 00 00 00	 call	 get_operator
  00050	8b d0		 mov	 edx, eax

; 2053 :     if (!newoperator)

  00052	85 c0		 test	 eax, eax

; 2054 :         return NULL;

  00054	74 ca		 je	 SHORT $LN23@ast_for_bi

; 2055 : 
; 2056 :     result = BinOp(expr1, newoperator, expr2, LINENO(n), n->n_col_offset,
; 2057 :                    c->c_arena);

  00056	49 8b 46 08	 mov	 rax, QWORD PTR [r14+8]
  0005a	44 8b 4d 10	 mov	 r9d, DWORD PTR [rbp+16]
  0005e	48 8b cb	 mov	 rcx, rbx
  00061	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00066	8b 45 14	 mov	 eax, DWORD PTR [rbp+20]
  00069	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0006d	e8 00 00 00 00	 call	 _Py_BinOp
  00072	48 8b c8	 mov	 rcx, rax
  00075	48 89 44 24 68	 mov	 QWORD PTR result$1$[rsp], rax

; 2058 :     if (!result)

  0007a	48 85 c0	 test	 rax, rax

; 2059 :         return NULL;

  0007d	74 a1		 je	 SHORT $LN23@ast_for_bi

; 2060 : 
; 2061 :     nops = (NCH(n) - 1) / 2;

  0007f	8b 45 18	 mov	 eax, DWORD PTR [rbp+24]
  00082	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00087	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi
  0008c	ff c8		 dec	 eax
  0008e	4c 89 64 24 78	 mov	 QWORD PTR [rsp+120], r12
  00093	4c 89 6c 24 38	 mov	 QWORD PTR [rsp+56], r13
  00098	99		 cdq
  00099	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15

; 2062 :     for (i = 1; i < nops; i++) {

  0009e	bb 01 00 00 00	 mov	 ebx, 1
  000a3	2b c2		 sub	 eax, edx
  000a5	d1 f8		 sar	 eax, 1
  000a7	4c 63 f8	 movsxd	 r15, eax
  000aa	49 3b df	 cmp	 rbx, r15
  000ad	0f 8d 83 00 00
	00		 jge	 $LN4@ast_for_bi

; 2060 : 
; 2061 :     nops = (NCH(n) - 1) / 2;

  000b3	8d 73 03	 lea	 esi, QWORD PTR [rbx+3]
  000b6	bf 78 00 00 00	 mov	 edi, 120		; 00000078H
  000bb	0f 1f 44 00 00	 npad	 5
$LL6@ast_for_bi:

; 2063 :         expr_ty tmp_result, tmp;
; 2064 :         const node* next_oper = CHILD(n, i * 2 + 1);

  000c0	4c 8b 45 20	 mov	 r8, QWORD PTR [rbp+32]
  000c4	4e 8d 24 07	 lea	 r12, QWORD PTR [rdi+r8]

; 2065 : 
; 2066 :         newoperator = get_operator(next_oper);

  000c8	49 8b cc	 mov	 rcx, r12
  000cb	e8 00 00 00 00	 call	 get_operator
  000d0	44 8b e8	 mov	 r13d, eax

; 2067 :         if (!newoperator)

  000d3	85 c0		 test	 eax, eax
  000d5	0f 84 80 00 00
	00		 je	 $LN14@ast_for_bi

; 2069 : 
; 2070 :         tmp = ast_for_expr(c, CHILD(n, i * 2 + 2));

  000db	48 63 ce	 movsxd	 rcx, esi
  000de	48 8d 14 89	 lea	 rdx, QWORD PTR [rcx+rcx*4]
  000e2	49 8b ce	 mov	 rcx, r14
  000e5	49 8d 14 d0	 lea	 rdx, QWORD PTR [r8+rdx*8]
  000e9	e8 00 00 00 00	 call	 ast_for_expr

; 2071 :         if (!tmp)

  000ee	48 85 c0	 test	 rax, rax
  000f1	74 68		 je	 SHORT $LN14@ast_for_bi

; 2072 :             return NULL;
; 2073 : 
; 2074 :         tmp_result = BinOp(result, newoperator, tmp,
; 2075 :                            LINENO(next_oper), next_oper->n_col_offset,
; 2076 :                            c->c_arena);

  000f3	49 8b 4e 08	 mov	 rcx, QWORD PTR [r14+8]
  000f7	45 8b 4c 24 10	 mov	 r9d, DWORD PTR [r12+16]
  000fc	4c 8b c0	 mov	 r8, rax
  000ff	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00104	41 8b 4c 24 14	 mov	 ecx, DWORD PTR [r12+20]
  00109	41 8b d5	 mov	 edx, r13d
  0010c	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00110	48 8b 4c 24 68	 mov	 rcx, QWORD PTR result$1$[rsp]
  00115	e8 00 00 00 00	 call	 _Py_BinOp
  0011a	48 8b c8	 mov	 rcx, rax
  0011d	48 89 44 24 68	 mov	 QWORD PTR result$1$[rsp], rax

; 2077 :         if (!tmp_result)

  00122	48 85 c0	 test	 rax, rax
  00125	74 34		 je	 SHORT $LN14@ast_for_bi

; 2062 :     for (i = 1; i < nops; i++) {

  00127	48 ff c3	 inc	 rbx
  0012a	83 c6 02	 add	 esi, 2
  0012d	48 83 c7 50	 add	 rdi, 80			; 00000050H
  00131	49 3b df	 cmp	 rbx, r15
  00134	7c 8a		 jl	 SHORT $LL6@ast_for_bi
$LN4@ast_for_bi:

; 2078 :             return NULL;
; 2079 :         result = tmp_result;
; 2080 :     }
; 2081 :     return result;

  00136	48 8b c1	 mov	 rax, rcx
$LN22@ast_for_bi:
  00139	4c 8b 6c 24 38	 mov	 r13, QWORD PTR [rsp+56]
  0013e	4c 8b 64 24 78	 mov	 r12, QWORD PTR [rsp+120]
  00143	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
  00148	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0014d	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]

; 2082 : }

  00152	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00156	41 5e		 pop	 r14
  00158	5d		 pop	 rbp
  00159	5b		 pop	 rbx
  0015a	c3		 ret	 0
$LN14@ast_for_bi:

; 2068 :             return NULL;

  0015b	33 c0		 xor	 eax, eax
  0015d	eb da		 jmp	 SHORT $LN22@ast_for_bi
ast_for_binop ENDP
_TEXT	ENDS
EXTRN	_Py_Tuple:PROC
EXTRN	_Py_ExtSlice:PROC
EXTRN	_Py_Subscript:PROC
EXTRN	_Py_Call:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_trailer DD imagerel ast_for_trailer
	DD	imagerel ast_for_trailer+288
	DD	imagerel $unwind$ast_for_trailer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ast_for_trailer DD imagerel ast_for_trailer+288
	DD	imagerel ast_for_trailer+335
	DD	imagerel $chain$1$ast_for_trailer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ast_for_trailer DD imagerel ast_for_trailer+335
	DD	imagerel ast_for_trailer+601
	DD	imagerel $chain$2$ast_for_trailer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ast_for_trailer DD imagerel ast_for_trailer+601
	DD	imagerel ast_for_trailer+625
	DD	imagerel $chain$3$ast_for_trailer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ast_for_trailer DD 021H
	DD	imagerel ast_for_trailer+288
	DD	imagerel ast_for_trailer+335
	DD	imagerel $chain$1$ast_for_trailer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ast_for_trailer DD 020521H
	DD	0dc405H
	DD	imagerel ast_for_trailer+288
	DD	imagerel ast_for_trailer+335
	DD	imagerel $chain$1$ast_for_trailer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ast_for_trailer DD 040a21H
	DD	0ed40aH
	DD	0c5405H
	DD	imagerel ast_for_trailer
	DD	imagerel ast_for_trailer+288
	DD	imagerel $unwind$ast_for_trailer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_trailer DD 060d01H
	DD	0f340dH
	DD	0e009720dH
	DD	060067007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_trailer
_TEXT	SEGMENT
c$ = 96
n$ = 104
left_expr$ = 112
ast_for_trailer PROC					; COMDAT

; 2086 : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 56		 push	 r14
  00009	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 2087 :     /* trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
; 2088 :        subscriptlist: subscript (',' subscript)* [',']
; 2089 :        subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]
; 2090 :      */
; 2091 :     REQ(n, trailer);
; 2092 :     if (TYPE(CHILD(n, 0)) == LPAR) {

  0000d	48 8b 7a 20	 mov	 rdi, QWORD PTR [rdx+32]
  00011	4d 8b f0	 mov	 r14, r8
  00014	48 8b da	 mov	 rbx, rdx
  00017	0f b7 07	 movzx	 eax, WORD PTR [rdi]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	66 83 f8 07	 cmp	 ax, 7
  00021	75 58		 jne	 SHORT $LN22@ast_for_tr

; 2093 :         if (NCH(n) == 2)

  00023	83 7a 18 02	 cmp	 DWORD PTR [rdx+24], 2
  00027	75 3c		 jne	 SHORT $LN21@ast_for_tr

; 2094 :             return Call(left_expr, NULL, NULL, NULL, NULL, LINENO(n),
; 2095 :                         n->n_col_offset, c->c_arena);

  00029	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  0002d	33 db		 xor	 ebx, ebx
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00037	8b 42 14	 mov	 eax, DWORD PTR [rdx+20]
  0003a	45 33 c0	 xor	 r8d, r8d
  0003d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00041	8b 42 10	 mov	 eax, DWORD PTR [rdx+16]
  00044	33 d2		 xor	 edx, edx
  00046	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0004a	49 8b ce	 mov	 rcx, r14
  0004d	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00052	e8 00 00 00 00	 call	 _Py_Call

; 2156 :         }
; 2157 :     }
; 2158 : }

  00057	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  0005c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00060	41 5e		 pop	 r14
  00062	5f		 pop	 rdi
  00063	5e		 pop	 rsi
  00064	c3		 ret	 0
$LN21@ast_for_tr:

; 2096 :         else
; 2097 :             return ast_for_call(c, CHILD(n, 1), left_expr);

  00065	48 8d 57 28	 lea	 rdx, QWORD PTR [rdi+40]

; 2156 :         }
; 2157 :     }
; 2158 : }

  00069	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  0006e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00072	41 5e		 pop	 r14
  00074	5f		 pop	 rdi
  00075	5e		 pop	 rsi
  00076	e9 00 00 00 00	 jmp	 ast_for_call
$LN22@ast_for_tr:

; 2098 :     }
; 2099 :     else if (TYPE(CHILD(n, 0)) == DOT ) {

  0007b	66 83 f8 17	 cmp	 ax, 23
  0007f	75 54		 jne	 SHORT $LN18@ast_for_tr

; 2100 :         PyObject *attr_id = NEW_IDENTIFIER(CHILD(n, 1));

  00081	48 8b d1	 mov	 rdx, rcx
  00084	48 8b 4f 30	 mov	 rcx, QWORD PTR [rdi+48]
  00088	e8 00 00 00 00	 call	 new_identifier
  0008d	48 8b d0	 mov	 rdx, rax

; 2101 :         if (!attr_id)

  00090	48 85 c0	 test	 rax, rax
  00093	75 10		 jne	 SHORT $LN17@ast_for_tr
$LN38@ast_for_tr:

; 2102 :             return NULL;

  00095	33 c0		 xor	 eax, eax

; 2156 :         }
; 2157 :     }
; 2158 : }

  00097	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  0009c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000a0	41 5e		 pop	 r14
  000a2	5f		 pop	 rdi
  000a3	5e		 pop	 rsi
  000a4	c3		 ret	 0
$LN17@ast_for_tr:

; 2103 :         return Attribute(left_expr, attr_id, Load,
; 2104 :                          LINENO(n), n->n_col_offset, c->c_arena);

  000a5	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  000a9	44 8b 4b 10	 mov	 r9d, DWORD PTR [rbx+16]
  000ad	41 b8 01 00 00
	00		 mov	 r8d, 1
  000b3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b8	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  000bb	49 8b ce	 mov	 rcx, r14
  000be	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000c2	e8 00 00 00 00	 call	 _Py_Attribute

; 2156 :         }
; 2157 :     }
; 2158 : }

  000c7	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  000cc	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000d0	41 5e		 pop	 r14
  000d2	5f		 pop	 rdi
  000d3	5e		 pop	 rsi
  000d4	c3		 ret	 0
$LN18@ast_for_tr:

; 2105 :     }
; 2106 :     else {
; 2107 :         REQ(CHILD(n, 0), LSQB);
; 2108 :         REQ(CHILD(n, 2), RSQB);
; 2109 :         n = CHILD(n, 1);
; 2110 :         if (NCH(n) == 1) {

  000d5	8b 47 40	 mov	 eax, DWORD PTR [rdi+64]
  000d8	83 f8 01	 cmp	 eax, 1
  000db	75 41		 jne	 SHORT $LN15@ast_for_tr

; 2111 :             slice_ty slc = ast_for_slice(c, CHILD(n, 0));

  000dd	48 8b 57 48	 mov	 rdx, QWORD PTR [rdi+72]
  000e1	e8 00 00 00 00	 call	 ast_for_slice
  000e6	48 8b d0	 mov	 rdx, rax

; 2112 :             if (!slc)

  000e9	48 85 c0	 test	 rax, rax

; 2113 :                 return NULL;

  000ec	74 a7		 je	 SHORT $LN38@ast_for_tr

; 2114 :             return Subscript(left_expr, slc, Load, LINENO(n), n->n_col_offset,
; 2115 :                              c->c_arena);

  000ee	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  000f2	44 8b 4f 38	 mov	 r9d, DWORD PTR [rdi+56]
  000f6	41 b8 01 00 00
	00		 mov	 r8d, 1
  000fc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00101	8b 47 3c	 mov	 eax, DWORD PTR [rdi+60]
  00104	49 8b ce	 mov	 rcx, r14
  00107	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0010b	e8 00 00 00 00	 call	 _Py_Subscript

; 2156 :         }
; 2157 :     }
; 2158 : }

  00110	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  00115	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00119	41 5e		 pop	 r14
  0011b	5f		 pop	 rdi
  0011c	5e		 pop	 rsi
  0011d	c3		 ret	 0
$LN15@ast_for_tr:

; 2116 :         }
; 2117 :         else {
; 2118 :             /* The grammar is ambiguous here. The ambiguity is resolved
; 2119 :                by treating the sequence as a tuple literal if there are
; 2120 :                no slice features.
; 2121 :             */
; 2122 :             int j;
; 2123 :             slice_ty slc;
; 2124 :             expr_ty e;
; 2125 :             int simple = 1;
; 2126 :             asdl_seq *slices, *elts;
; 2127 :             slices = asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);

  0011e	ff c0		 inc	 eax
  00120	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  00125	4c 89 6c 24 70	 mov	 QWORD PTR [rsp+112], r13
  0012a	99		 cdq
  0012b	41 bd 01 00 00
	00		 mov	 r13d, 1
  00131	2b c2		 sub	 eax, edx
  00133	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  00137	d1 f8		 sar	 eax, 1
  00139	48 63 c8	 movsxd	 rcx, eax
  0013c	e8 00 00 00 00	 call	 asdl_seq_new
  00141	48 8b e8	 mov	 rbp, rax

; 2128 :             if (!slices)

  00144	48 85 c0	 test	 rax, rax
  00147	0f 84 0c 01 00
	00		 je	 $LN34@ast_for_tr
$LN12@ast_for_tr:

; 2129 :                 return NULL;
; 2130 :             for (j = 0; j < NCH(n); j += 2) {

  0014d	33 db		 xor	 ebx, ebx
  0014f	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  00154	44 8b e3	 mov	 r12d, ebx
  00157	39 5f 40	 cmp	 DWORD PTR [rdi+64], ebx
  0015a	7e 5e		 jle	 SHORT $LN6@ast_for_tr
  0015c	0f 1f 40 00	 npad	 4
$LL11@ast_for_tr:

; 2131 :                 slc = ast_for_slice(c, CHILD(n, j));

  00160	49 63 c4	 movsxd	 rax, r12d
  00163	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00167	48 8b 47 48	 mov	 rax, QWORD PTR [rdi+72]
  0016b	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  0016f	48 8b ce	 mov	 rcx, rsi
  00172	e8 00 00 00 00	 call	 ast_for_slice
  00177	4c 8b d8	 mov	 r11, rax

; 2132 :                 if (!slc)

  0017a	48 85 c0	 test	 rax, rax
  0017d	0f 84 9d 00 00
	00		 je	 $LN37@ast_for_tr

; 2133 :                     return NULL;
; 2134 :                 if (slc->kind != Index_kind)

  00183	83 38 03	 cmp	 DWORD PTR [rax], 3

; 2135 :                     simple = 0;
; 2136 :                 asdl_seq_SET(slices, j / 2, slc);

  00186	41 8b c4	 mov	 eax, r12d
  00189	44 0f 45 eb	 cmovne	 r13d, ebx
  0018d	99		 cdq
  0018e	41 83 c4 02	 add	 r12d, 2
  00192	2b c2		 sub	 eax, edx
  00194	d1 f8		 sar	 eax, 1
  00196	48 63 c8	 movsxd	 rcx, eax
  00199	4c 89 5c cd 08	 mov	 QWORD PTR [rbp+rcx*8+8], r11
  0019e	44 3b 67 40	 cmp	 r12d, DWORD PTR [rdi+64]
  001a2	7c bc		 jl	 SHORT $LL11@ast_for_tr

; 2137 :             }
; 2138 :             if (!simple) {

  001a4	45 85 ed	 test	 r13d, r13d
  001a7	75 11		 jne	 SHORT $LN6@ast_for_tr

; 2139 :                 return Subscript(left_expr, ExtSlice(slices, c->c_arena),
; 2140 :                                  Load, LINENO(n), n->n_col_offset, c->c_arena);

  001a9	48 8b 5e 08	 mov	 rbx, QWORD PTR [rsi+8]
  001ad	48 8b cd	 mov	 rcx, rbp
  001b0	48 8b d3	 mov	 rdx, rbx
  001b3	e8 00 00 00 00	 call	 _Py_ExtSlice
  001b8	eb 79		 jmp	 SHORT $LN36@ast_for_tr
$LN6@ast_for_tr:

; 2141 :             }
; 2142 :             /* extract Index values and put them in a Tuple */
; 2143 :             elts = asdl_seq_new(asdl_seq_LEN(slices), c->c_arena);

  001ba	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  001be	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
  001c2	e8 00 00 00 00	 call	 asdl_seq_new
  001c7	4c 8b d8	 mov	 r11, rax

; 2144 :             if (!elts)

  001ca	48 85 c0	 test	 rax, rax

; 2145 :                 return NULL;

  001cd	74 51		 je	 SHORT $LN37@ast_for_tr

; 2146 :             for (j = 0; j < asdl_seq_LEN(slices); ++j) {

  001cf	4c 8b c5	 mov	 r8, rbp
  001d2	48 8d 50 08	 lea	 rdx, QWORD PTR [rax+8]
  001d6	4c 2b c0	 sub	 r8, rax
  001d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@ast_for_tr:
  001e0	48 63 c3	 movsxd	 rax, ebx
  001e3	48 3b 45 00	 cmp	 rax, QWORD PTR [rbp]
  001e7	7d 14		 jge	 SHORT $LN2@ast_for_tr

; 2147 :                 slc = (slice_ty)asdl_seq_GET(slices, j);
; 2148 :                 assert(slc->kind == Index_kind  && slc->v.Index.value);
; 2149 :                 asdl_seq_SET(elts, j, slc->v.Index.value);

  001e9	49 8b 04 10	 mov	 rax, QWORD PTR [r8+rdx]
  001ed	ff c3		 inc	 ebx
  001ef	48 83 c2 08	 add	 rdx, 8
  001f3	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  001f7	48 89 4a f8	 mov	 QWORD PTR [rdx-8], rcx
  001fb	eb e3		 jmp	 SHORT $LL4@ast_for_tr
$LN2@ast_for_tr:

; 2150 :             }
; 2151 :             e = Tuple(elts, Load, LINENO(n), n->n_col_offset, c->c_arena);

  001fd	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  00201	44 8b 4f 3c	 mov	 r9d, DWORD PTR [rdi+60]
  00205	44 8b 47 38	 mov	 r8d, DWORD PTR [rdi+56]
  00209	ba 01 00 00 00	 mov	 edx, 1
  0020e	49 8b cb	 mov	 rcx, r11
  00211	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00216	e8 00 00 00 00	 call	 _Py_Tuple

; 2152 :             if (!e)

  0021b	48 85 c0	 test	 rax, rax
  0021e	75 04		 jne	 SHORT $LN1@ast_for_tr
$LN37@ast_for_tr:

; 2153 :                 return NULL;

  00220	33 c0		 xor	 eax, eax
  00222	eb 30		 jmp	 SHORT $LN35@ast_for_tr
$LN1@ast_for_tr:

; 2154 :             return Subscript(left_expr, Index(e, c->c_arena),
; 2155 :                              Load, LINENO(n), n->n_col_offset, c->c_arena);

  00224	48 8b 5e 08	 mov	 rbx, QWORD PTR [rsi+8]
  00228	48 8b c8	 mov	 rcx, rax
  0022b	48 8b d3	 mov	 rdx, rbx
  0022e	e8 00 00 00 00	 call	 _Py_Index
$LN36@ast_for_tr:
  00233	44 8b 4f 38	 mov	 r9d, DWORD PTR [rdi+56]
  00237	48 8b d0	 mov	 rdx, rax
  0023a	8b 47 3c	 mov	 eax, DWORD PTR [rdi+60]
  0023d	41 b8 01 00 00
	00		 mov	 r8d, 1
  00243	49 8b ce	 mov	 rcx, r14
  00246	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
  0024b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0024f	e8 00 00 00 00	 call	 _Py_Subscript
$LN35@ast_for_tr:
  00254	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
$LN34@ast_for_tr:
  00259	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  0025e	4c 8b 6c 24 70	 mov	 r13, QWORD PTR [rsp+112]

; 2156 :         }
; 2157 :     }
; 2158 : }

  00263	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  00268	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0026c	41 5e		 pop	 r14
  0026e	5f		 pop	 rdi
  0026f	5e		 pop	 rsi
  00270	c3		 ret	 0
ast_for_trailer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@MFDCCJEE@unhandled?5factor?3?5?$CFd?$AA@ ; `string'
EXTRN	_Py_UnaryOp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_factor DD imagerel ast_for_factor
	DD	imagerel ast_for_factor+146
	DD	imagerel $unwind$ast_for_factor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_factor DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0BF@MFDCCJEE@unhandled?5factor?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BF@MFDCCJEE@unhandled?5factor?3?5?$CFd?$AA@ DB 'unhandled factor: '
	DB	'%d', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ast_for_factor
_TEXT	SEGMENT
c$ = 64
n$ = 72
ast_for_factor PROC					; COMDAT

; 2162 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b da	 mov	 rbx, rdx

; 2163 :     expr_ty expression;
; 2164 : 
; 2165 :     expression = ast_for_expr(c, CHILD(n, 1));

  0000d	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 83 c2 28	 add	 rdx, 40			; 00000028H
  00018	e8 00 00 00 00	 call	 ast_for_expr
  0001d	48 8b d0	 mov	 rdx, rax

; 2166 :     if (!expression)

  00020	48 85 c0	 test	 rax, rax

; 2167 :         return NULL;

  00023	74 2c		 je	 SHORT $LN10@ast_for_fa

; 2168 : 
; 2169 :     switch (TYPE(CHILD(n, 0))) {

  00025	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00029	44 0f bf 00	 movsx	 r8d, WORD PTR [rax]
  0002d	41 8b c8	 mov	 ecx, r8d
  00030	83 e9 0e	 sub	 ecx, 14
  00033	74 37		 je	 SHORT $LN3@ast_for_fa
  00035	ff c9		 dec	 ecx
  00037	74 2c		 je	 SHORT $LN2@ast_for_fa
  00039	83 f9 10	 cmp	 ecx, 16
  0003c	74 20		 je	 SHORT $LN1@ast_for_fa

; 2179 :     }
; 2180 :     PyErr_Format(PyExc_SystemError, "unhandled factor: %d",
; 2181 :                  TYPE(CHILD(n, 0)));

  0003e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@MFDCCJEE@unhandled?5factor?3?5?$CFd?$AA@
  0004c	e8 00 00 00 00	 call	 PyErr_Format
$LN10@ast_for_fa:

; 2182 :     return NULL;

  00051	33 c0		 xor	 eax, eax

; 2183 : }

  00053	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00058	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
$LN1@ast_for_fa:

; 2176 :         case TILDE:
; 2177 :             return UnaryOp(Invert, expression, LINENO(n),
; 2178 :                            n->n_col_offset, c->c_arena);

  0005e	b9 01 00 00 00	 mov	 ecx, 1
  00063	eb 0c		 jmp	 SHORT $LN9@ast_for_fa
$LN2@ast_for_fa:

; 2173 :         case MINUS:
; 2174 :             return UnaryOp(USub, expression, LINENO(n), n->n_col_offset,
; 2175 :                            c->c_arena);

  00065	b9 04 00 00 00	 mov	 ecx, 4
  0006a	eb 05		 jmp	 SHORT $LN9@ast_for_fa
$LN3@ast_for_fa:

; 2170 :         case PLUS:
; 2171 :             return UnaryOp(UAdd, expression, LINENO(n), n->n_col_offset,
; 2172 :                            c->c_arena);

  0006c	b9 03 00 00 00	 mov	 ecx, 3
$LN9@ast_for_fa:
  00071	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00075	44 8b 4b 14	 mov	 r9d, DWORD PTR [rbx+20]
  00079	44 8b 43 10	 mov	 r8d, DWORD PTR [rbx+16]
  0007d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00082	e8 00 00 00 00	 call	 _Py_UnaryOp

; 2183 : }

  00087	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0008c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00090	5f		 pop	 rdi
  00091	c3		 ret	 0
ast_for_factor ENDP
_TEXT	ENDS
EXTRN	_Py_Starred:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_starred DD imagerel ast_for_starred
	DD	imagerel ast_for_starred+86
	DD	imagerel $unwind$ast_for_starred
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_starred DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_starred
_TEXT	SEGMENT
c$ = 64
n$ = 72
ast_for_starred PROC					; COMDAT

; 2223 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b da	 mov	 rbx, rdx

; 2224 :     expr_ty tmp;
; 2225 :     REQ(n, star_expr);
; 2226 : 
; 2227 :     tmp = ast_for_expr(c, CHILD(n, 1));

  0000d	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 83 c2 28	 add	 rdx, 40			; 00000028H
  00018	e8 00 00 00 00	 call	 ast_for_expr
  0001d	48 8b c8	 mov	 rcx, rax

; 2228 :     if (!tmp)

  00020	48 85 c0	 test	 rax, rax
  00023	75 0b		 jne	 SHORT $LN1@ast_for_st

; 2233 : }

  00025	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0002a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
$LN1@ast_for_st:

; 2229 :         return NULL;
; 2230 : 
; 2231 :     /* The Load context is changed later. */
; 2232 :     return Starred(tmp, Load, LINENO(n), n->n_col_offset, c->c_arena);

  00030	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00034	44 8b 4b 14	 mov	 r9d, DWORD PTR [rbx+20]
  00038	44 8b 43 10	 mov	 r8d, DWORD PTR [rbx+16]
  0003c	ba 01 00 00 00	 mov	 edx, 1
  00041	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00046	e8 00 00 00 00	 call	 _Py_Starred

; 2233 : }

  0004b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00050	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00054	5f		 pop	 rdi
  00055	c3		 ret	 0
ast_for_starred ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_testlist DD imagerel ast_for_testlist
	DD	imagerel ast_for_testlist+103
	DD	imagerel $unwind$ast_for_testlist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_testlist DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_testlist
_TEXT	SEGMENT
c$ = 64
n$ = 72
ast_for_testlist PROC					; COMDAT

; 2536 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2537 :     /* testlist_comp: test (comp_for | (',' test)* [',']) */
; 2538 :     /* testlist: test (',' test)* [','] */
; 2539 :     assert(NCH(n) > 0);
; 2540 :     if (TYPE(n) == testlist_comp) {
; 2541 :         if (NCH(n) > 1)
; 2542 :             assert(TYPE(CHILD(n, 1)) != comp_for);
; 2543 :     }
; 2544 :     else {
; 2545 :         assert(TYPE(n) == testlist ||
; 2546 :                TYPE(n) == testlist_star_expr);
; 2547 :     }
; 2548 :     if (NCH(n) == 1)

  0000a	83 7a 18 01	 cmp	 DWORD PTR [rdx+24], 1
  0000e	48 8b da	 mov	 rbx, rdx
  00011	48 8b f9	 mov	 rdi, rcx
  00014	75 13		 jne	 SHORT $LN3@ast_for_te

; 2549 :         return ast_for_expr(c, CHILD(n, 0));

  00016	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]

; 2555 :     }
; 2556 : }

  0001a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0001f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00023	5f		 pop	 rdi
  00024	e9 00 00 00 00	 jmp	 ast_for_expr
$LN3@ast_for_te:

; 2550 :     else {
; 2551 :         asdl_seq *tmp = seq_for_testlist(c, n);

  00029	e8 00 00 00 00	 call	 seq_for_testlist
  0002e	48 8b c8	 mov	 rcx, rax

; 2552 :         if (!tmp)

  00031	48 85 c0	 test	 rax, rax
  00034	75 0b		 jne	 SHORT $LN1@ast_for_te

; 2555 :     }
; 2556 : }

  00036	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0003b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
$LN1@ast_for_te:

; 2553 :             return NULL;
; 2554 :         return Tuple(tmp, Load, LINENO(n), n->n_col_offset, c->c_arena);

  00041	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00045	44 8b 4b 14	 mov	 r9d, DWORD PTR [rbx+20]
  00049	44 8b 43 10	 mov	 r8d, DWORD PTR [rbx+16]
  0004d	ba 01 00 00 00	 mov	 edx, 1
  00052	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00057	e8 00 00 00 00	 call	 _Py_Tuple

; 2555 :     }
; 2556 : }

  0005c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5f		 pop	 rdi
  00066	c3		 ret	 0
ast_for_testlist ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_exprlist DD imagerel ast_for_exprlist
	DD	imagerel ast_for_exprlist+68
	DD	imagerel $unwind$ast_for_exprlist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ast_for_exprlist DD imagerel ast_for_exprlist+68
	DD	imagerel ast_for_exprlist+209
	DD	imagerel $chain$1$ast_for_exprlist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ast_for_exprlist DD imagerel ast_for_exprlist+209
	DD	imagerel ast_for_exprlist+213
	DD	imagerel $chain$3$ast_for_exprlist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ast_for_exprlist DD 040021H
	DD	096400H
	DD	083400H
	DD	imagerel ast_for_exprlist
	DD	imagerel ast_for_exprlist+68
	DD	imagerel $unwind$ast_for_exprlist
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ast_for_exprlist DD 040c21H
	DD	09640cH
	DD	083405H
	DD	imagerel ast_for_exprlist
	DD	imagerel ast_for_exprlist+68
	DD	imagerel $unwind$ast_for_exprlist
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_exprlist DD 060e01H
	DD	0a540eH
	DD	0d00a320eH
	DD	07006c008H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_exprlist
_TEXT	SEGMENT
c$ = 64
n$ = 72
context$ = 80
ast_for_exprlist PROC					; COMDAT

; 2657 : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	57		 push	 rdi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2658 :     asdl_seq *seq;
; 2659 :     int i;
; 2660 :     expr_ty e;
; 2661 : 
; 2662 :     REQ(n, exprlist);
; 2663 : 
; 2664 :     seq = asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);

  0000e	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  00011	48 8b fa	 mov	 rdi, rdx
  00014	4c 8b e9	 mov	 r13, rcx
  00017	ff c0		 inc	 eax
  00019	45 8b e0	 mov	 r12d, r8d
  0001c	99		 cdq
  0001d	2b c2		 sub	 eax, edx
  0001f	49 8b 55 08	 mov	 rdx, QWORD PTR [r13+8]
  00023	d1 f8		 sar	 eax, 1
  00025	48 63 c8	 movsxd	 rcx, eax
  00028	e8 00 00 00 00	 call	 asdl_seq_new
  0002d	48 8b e8	 mov	 rbp, rax

; 2665 :     if (!seq)

  00030	48 85 c0	 test	 rax, rax
  00033	75 0f		 jne	 SHORT $LN6@ast_for_ex

; 2676 : }

  00035	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	41 5d		 pop	 r13
  00040	41 5c		 pop	 r12
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
$LN6@ast_for_ex:
  00044	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 2666 :         return NULL;
; 2667 :     for (i = 0; i < NCH(n); i += 2) {

  00049	33 db		 xor	 ebx, ebx
  0004b	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00050	39 5f 18	 cmp	 DWORD PTR [rdi+24], ebx
  00053	7e 60		 jle	 SHORT $LN3@ast_for_ex
  00055	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL5@ast_for_ex:

; 2668 :         e = ast_for_expr(c, CHILD(n, i));

  00060	48 63 c3	 movsxd	 rax, ebx
  00063	49 8b cd	 mov	 rcx, r13
  00066	48 8d 34 80	 lea	 rsi, QWORD PTR [rax+rax*4]
  0006a	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0006e	48 8d 14 f0	 lea	 rdx, QWORD PTR [rax+rsi*8]
  00072	e8 00 00 00 00	 call	 ast_for_expr
  00077	4c 8b d8	 mov	 r11, rax

; 2669 :         if (!e)

  0007a	48 85 c0	 test	 rax, rax
  0007d	74 52		 je	 SHORT $LN10@ast_for_ex

; 2671 :         asdl_seq_SET(seq, i / 2, e);

  0007f	8b c3		 mov	 eax, ebx
  00081	99		 cdq
  00082	2b c2		 sub	 eax, edx
  00084	d1 f8		 sar	 eax, 1
  00086	48 63 c8	 movsxd	 rcx, eax
  00089	4c 89 5c cd 08	 mov	 QWORD PTR [rbp+rcx*8+8], r11

; 2672 :         if (context && !set_context(c, e, context, CHILD(n, i)))

  0008e	45 85 e4	 test	 r12d, r12d
  00091	74 1a		 je	 SHORT $LN4@ast_for_ex
  00093	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  00097	45 8b c4	 mov	 r8d, r12d
  0009a	49 8b d3	 mov	 rdx, r11
  0009d	4c 8d 0c f1	 lea	 r9, QWORD PTR [rcx+rsi*8]
  000a1	49 8b cd	 mov	 rcx, r13
  000a4	e8 00 00 00 00	 call	 set_context
  000a9	85 c0		 test	 eax, eax
  000ab	74 24		 je	 SHORT $LN10@ast_for_ex
$LN4@ast_for_ex:

; 2666 :         return NULL;
; 2667 :     for (i = 0; i < NCH(n); i += 2) {

  000ad	83 c3 02	 add	 ebx, 2
  000b0	3b 5f 18	 cmp	 ebx, DWORD PTR [rdi+24]
  000b3	7c ab		 jl	 SHORT $LL5@ast_for_ex
$LN3@ast_for_ex:

; 2673 :             return NULL;
; 2674 :     }
; 2675 :     return seq;

  000b5	48 8b c5	 mov	 rax, rbp
$LN15@ast_for_ex:
  000b8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000bd	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 2676 : }

  000c2	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000c7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cb	41 5d		 pop	 r13
  000cd	41 5c		 pop	 r12
  000cf	5f		 pop	 rdi
  000d0	c3		 ret	 0
$LN10@ast_for_ex:

; 2670 :             return NULL;

  000d1	33 c0		 xor	 eax, eax
  000d3	eb e3		 jmp	 SHORT $LN15@ast_for_ex
ast_for_exprlist ENDP
_TEXT	ENDS
EXTRN	_Py_Delete:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_del_stmt DD imagerel ast_for_del_stmt
	DD	imagerel ast_for_del_stmt+80
	DD	imagerel $unwind$ast_for_del_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_del_stmt DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_del_stmt
_TEXT	SEGMENT
c$ = 48
n$ = 56
ast_for_del_stmt PROC					; COMDAT

; 2680 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 2681 :     asdl_seq *expr_list;
; 2682 : 
; 2683 :     /* del_stmt: 'del' exprlist */
; 2684 :     REQ(n, del_stmt);
; 2685 : 
; 2686 :     expr_list = ast_for_exprlist(c, CHILD(n, 1), Del);

  0000d	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00011	41 b8 03 00 00
	00		 mov	 r8d, 3
  00017	48 83 c2 28	 add	 rdx, 40			; 00000028H
  0001b	48 8b f9	 mov	 rdi, rcx
  0001e	e8 00 00 00 00	 call	 ast_for_exprlist

; 2687 :     if (!expr_list)

  00023	48 85 c0	 test	 rax, rax
  00026	75 0b		 jne	 SHORT $LN1@ast_for_de

; 2690 : }

  00028	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5f		 pop	 rdi
  00032	c3		 ret	 0
$LN1@ast_for_de:

; 2688 :         return NULL;
; 2689 :     return Delete(expr_list, LINENO(n), n->n_col_offset, c->c_arena);

  00033	4c 8b 4f 08	 mov	 r9, QWORD PTR [rdi+8]
  00037	44 8b 43 14	 mov	 r8d, DWORD PTR [rbx+20]
  0003b	8b 53 10	 mov	 edx, DWORD PTR [rbx+16]
  0003e	48 8b c8	 mov	 rcx, rax

; 2690 : }

  00041	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5f		 pop	 rdi
  0004b	e9 00 00 00 00	 jmp	 _Py_Delete
ast_for_del_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_01NBENCBCI@?$CK?$AA@			; `string'
PUBLIC	??_C@_0BL@LEDBAIDM@unexpected?5import?5name?3?5?$CFd?$AA@ ; `string'
EXTRN	_Py_alias:PROC
EXTRN	PyUnicode_InternFromString:PROC
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$alias_for_import_name DD imagerel alias_for_import_name
	DD	imagerel alias_for_import_name+739
	DD	imagerel $unwind$alias_for_import_name
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$alias_for_import_name DD 061a01H
	DD	0a741aH
	DD	06008320cH
	DD	030065007H
xdata	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK?$AA@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK?$AA@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LEDBAIDM@unexpected?5import?5name?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BL@LEDBAIDM@unexpected?5import?5name?3?5?$CFd?$AA@ DB 'unexpected '
	DB	'import name: %d', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT alias_for_import_name
_TEXT	SEGMENT
c$ = 64
str$ = 72
n$ = 72
store$ = 80
alias_for_import_name PROC				; COMDAT

; 2756 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000c	41 8b e8	 mov	 ebp, r8d
  0000f	48 8b da	 mov	 rbx, rdx
  00012	48 8b f1	 mov	 rsi, rcx
  00015	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0001a	66 0f 1f 44 00
	00		 npad	 6
$loop$23593:

; 2757 :     /*
; 2758 :       import_as_name: NAME ['as' NAME]
; 2759 :       dotted_as_name: dotted_name ['as' NAME]
; 2760 :       dotted_name: NAME ('.' NAME)*
; 2761 :     */
; 2762 :     identifier str, name;
; 2763 : 
; 2764 :  loop:
; 2765 :     switch (TYPE(n)) {

  00020	0f bf 0b	 movsx	 ecx, WORD PTR [rbx]
  00023	83 e9 10	 sub	 ecx, 16
  00026	0f 84 7d 02 00
	00		 je	 $LN2@alias_for_
  0002c	81 e9 0d 01 00
	00		 sub	 ecx, 269		; 0000010dH
  00032	0f 84 e7 01 00
	00		 je	 $LN29@alias_for_
  00038	ff c9		 dec	 ecx
  0003a	75 6d		 jne	 SHORT $LN41@alias_for_

; 2785 :         }
; 2786 :         case dotted_as_name:
; 2787 :             if (NCH(n) == 1) {

  0003c	83 7b 18 01	 cmp	 DWORD PTR [rbx+24], 1
  00040	75 06		 jne	 SHORT $LN21@alias_for_

; 2788 :                 n = CHILD(n, 0);

  00042	48 8b 5b 20	 mov	 rbx, QWORD PTR [rbx+32]

; 2789 :                 goto loop;

  00046	eb d8		 jmp	 SHORT $loop$23593
$LN21@alias_for_:

; 2790 :             }
; 2791 :             else {
; 2792 :                 node *asname_node = CHILD(n, 2);

  00048	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]

; 2793 :                 alias_ty a = alias_for_import_name(c, CHILD(n, 0), 0);

  0004c	45 33 c0	 xor	 r8d, r8d
  0004f	48 8b ce	 mov	 rcx, rsi
  00052	48 8d 5a 50	 lea	 rbx, QWORD PTR [rdx+80]
  00056	e8 00 00 00 00	 call	 alias_for_import_name
  0005b	48 8b f8	 mov	 rdi, rax

; 2794 :                 if (!a)

  0005e	48 85 c0	 test	 rax, rax

; 2795 :                     return NULL;

  00061	0f 84 18 02 00
	00		 je	 $LN46@alias_for_

; 2796 :                 assert(!a->asname);
; 2797 :                 a->asname = NEW_IDENTIFIER(asname_node);

  00067	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0006b	48 8b d6	 mov	 rdx, rsi
  0006e	e8 00 00 00 00	 call	 new_identifier
  00073	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax

; 2798 :                 if (!a->asname)

  00077	48 85 c0	 test	 rax, rax

; 2799 :                     return NULL;

  0007a	0f 84 ff 01 00
	00		 je	 $LN46@alias_for_

; 2800 :                 if (forbidden_name(c, a->asname, asname_node, 0))

  00080	45 33 c9	 xor	 r9d, r9d
  00083	4c 8b c3	 mov	 r8, rbx
  00086	48 8b d0	 mov	 rdx, rax
  00089	48 8b ce	 mov	 rcx, rsi
  0008c	e8 00 00 00 00	 call	 forbidden_name
  00091	33 f6		 xor	 esi, esi
  00093	85 c0		 test	 eax, eax
  00095	48 0f 45 fe	 cmovne	 rdi, rsi
  00099	48 8b c7	 mov	 rax, rdi
  0009c	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 2860 :             return NULL;
; 2861 :     }
; 2862 : 
; 2863 :     PyErr_SetString(PyExc_SystemError, "unhandled import name condition");
; 2864 :     return NULL;
; 2865 : }

  000a1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a5	5e		 pop	 rsi
  000a6	5d		 pop	 rbp
  000a7	5b		 pop	 rbx
  000a8	c3		 ret	 0
$LN41@alias_for_:

; 2757 :     /*
; 2758 :       import_as_name: NAME ['as' NAME]
; 2759 :       dotted_as_name: dotted_name ['as' NAME]
; 2760 :       dotted_name: NAME ('.' NAME)*
; 2761 :     */
; 2762 :     identifier str, name;
; 2763 : 
; 2764 :  loop:
; 2765 :     switch (TYPE(n)) {

  000a9	83 f9 03	 cmp	 ecx, 3
  000ac	74 26		 je	 SHORT $LN16@alias_for_

; 2857 :         default:
; 2858 :             PyErr_Format(PyExc_SystemError,
; 2859 :                          "unexpected import name: %d", TYPE(n));

  000ae	44 0f bf 03	 movsx	 r8d, WORD PTR [rbx]
  000b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@LEDBAIDM@unexpected?5import?5name?3?5?$CFd?$AA@
  000c0	e8 00 00 00 00	 call	 PyErr_Format
  000c5	33 c0		 xor	 eax, eax
  000c7	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 2860 :             return NULL;
; 2861 :     }
; 2862 : 
; 2863 :     PyErr_SetString(PyExc_SystemError, "unhandled import name condition");
; 2864 :     return NULL;
; 2865 : }

  000cc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d0	5e		 pop	 rsi
  000d1	5d		 pop	 rbp
  000d2	5b		 pop	 rbx
  000d3	c3		 ret	 0
$LN16@alias_for_:

; 2801 :                     return NULL;
; 2802 :                 return a;
; 2803 :             }
; 2804 :             break;
; 2805 :         case dotted_name:
; 2806 :             if (NCH(n) == 1) {

  000d4	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  000d7	83 f8 01	 cmp	 eax, 1
  000da	75 41		 jne	 SHORT $LN15@alias_for_

; 2807 :                 node *name_node = CHILD(n, 0);

  000dc	48 8b 5b 20	 mov	 rbx, QWORD PTR [rbx+32]

; 2808 :                 name = NEW_IDENTIFIER(name_node);

  000e0	48 8b d6	 mov	 rdx, rsi
  000e3	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  000e7	e8 00 00 00 00	 call	 new_identifier
  000ec	48 8b f8	 mov	 rdi, rax

; 2809 :                 if (!name)

  000ef	48 85 c0	 test	 rax, rax

; 2810 :                     return NULL;

  000f2	0f 84 87 01 00
	00		 je	 $LN46@alias_for_

; 2811 :                 if (store && forbidden_name(c, name, name_node, 0))

  000f8	85 ed		 test	 ebp, ebp
  000fa	74 19		 je	 SHORT $LN13@alias_for_
  000fc	45 33 c9	 xor	 r9d, r9d
  000ff	4c 8b c3	 mov	 r8, rbx
  00102	48 8b d0	 mov	 rdx, rax
  00105	48 8b ce	 mov	 rcx, rsi
  00108	e8 00 00 00 00	 call	 forbidden_name
  0010d	85 c0		 test	 eax, eax

; 2812 :                     return NULL;

  0010f	0f 85 6a 01 00
	00		 jne	 $LN46@alias_for_
$LN13@alias_for_:

; 2813 :                 return alias(name, NULL, c->c_arena);

  00115	48 8b cf	 mov	 rcx, rdi
  00118	e9 ae 01 00 00	 jmp	 $LN43@alias_for_
$LN15@alias_for_:

; 2814 :             }
; 2815 :             else {
; 2816 :                 /* Create a string of the form "a.b.c" */
; 2817 :                 int i;
; 2818 :                 size_t len;
; 2819 :                 char *s;
; 2820 :                 PyObject *uni;
; 2821 : 
; 2822 :                 len = 0;

  0011d	33 f6		 xor	 esi, esi
  0011f	44 8b c6	 mov	 r8d, esi

; 2823 :                 for (i = 0; i < NCH(n); i += 2)

  00122	85 c0		 test	 eax, eax
  00124	7e 34		 jle	 SHORT $LN9@alias_for_

; 2814 :             }
; 2815 :             else {
; 2816 :                 /* Create a string of the form "a.b.c" */
; 2817 :                 int i;
; 2818 :                 size_t len;
; 2819 :                 char *s;
; 2820 :                 PyObject *uni;
; 2821 : 
; 2822 :                 len = 0;

  00126	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  0012a	44 8d 48 ff	 lea	 r9d, DWORD PTR [rax-1]
  0012e	41 d1 e9	 shr	 r9d, 1
  00131	48 83 c2 08	 add	 rdx, 8
  00135	41 ff c1	 inc	 r9d
  00138	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL11@alias_for_:

; 2824 :                     /* length of string plus one for the dot */
; 2825 :                     len += strlen(STR(CHILD(n, i))) + 1;

  00140	48 8b 3a	 mov	 rdi, QWORD PTR [rdx]
  00143	48 83 c9 ff	 or	 rcx, -1
  00147	33 c0		 xor	 eax, eax
  00149	f2 ae		 repne scasb
  0014b	48 83 c2 50	 add	 rdx, 80			; 00000050H
  0014f	48 f7 d1	 not	 rcx
  00152	4c 03 c1	 add	 r8, rcx
  00155	49 ff c9	 dec	 r9
  00158	75 e6		 jne	 SHORT $LL11@alias_for_
$LN9@alias_for_:

; 2826 :                 len--; /* the last name doesn't have a dot */

  0015a	49 8d 50 ff	 lea	 rdx, QWORD PTR [r8-1]

; 2827 :                 str = PyBytes_FromStringAndSize(NULL, len);

  0015e	33 c9		 xor	 ecx, ecx
  00160	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00165	48 89 44 24 48	 mov	 QWORD PTR str$[rsp], rax

; 2828 :                 if (!str)

  0016a	48 85 c0	 test	 rax, rax

; 2829 :                     return NULL;

  0016d	0f 84 0c 01 00
	00		 je	 $LN46@alias_for_

; 2830 :                 s = PyBytes_AS_STRING(str);

  00173	4c 8d 40 78	 lea	 r8, QWORD PTR [rax+120]

; 2831 :                 if (!s)

  00177	4d 85 c0	 test	 r8, r8

; 2832 :                     return NULL;

  0017a	0f 84 ff 00 00
	00		 je	 $LN46@alias_for_

; 2833 :                 for (i = 0; i < NCH(n); i += 2) {

  00180	39 73 18	 cmp	 DWORD PTR [rbx+24], esi
  00183	7e 50		 jle	 SHORT $LN4@alias_for_
  00185	4c 8b ce	 mov	 r9, rsi
  00188	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL6@alias_for_:

; 2834 :                     char *sch = STR(CHILD(n, i));

  00190	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]

; 2835 :                     strcpy(s, STR(CHILD(n, i)));

  00194	49 8b d0	 mov	 rdx, r8
  00197	4a 8b 7c 08 08	 mov	 rdi, QWORD PTR [rax+r9+8]
  0019c	48 8b cf	 mov	 rcx, rdi
  0019f	90		 npad	 1
$LL34@alias_for_:
  001a0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  001a3	48 ff c2	 inc	 rdx
  001a6	48 ff c1	 inc	 rcx
  001a9	88 42 ff	 mov	 BYTE PTR [rdx-1], al
  001ac	84 c0		 test	 al, al
  001ae	75 f0		 jne	 SHORT $LL34@alias_for_

; 2836 :                     s += strlen(sch);

  001b0	48 83 c9 ff	 or	 rcx, -1
  001b4	33 c0		 xor	 eax, eax
  001b6	83 c6 02	 add	 esi, 2
  001b9	f2 ae		 repne scasb
  001bb	49 83 c1 50	 add	 r9, 80			; 00000050H
  001bf	48 f7 d1	 not	 rcx
  001c2	48 ff c9	 dec	 rcx
  001c5	4c 03 c1	 add	 r8, rcx

; 2837 :                     *s++ = '.';

  001c8	49 ff c0	 inc	 r8
  001cb	41 c6 40 ff 2e	 mov	 BYTE PTR [r8-1], 46	; 0000002eH
  001d0	3b 73 18	 cmp	 esi, DWORD PTR [rbx+24]
  001d3	7c bb		 jl	 SHORT $LL6@alias_for_
$LN4@alias_for_:

; 2838 :                 }
; 2839 :                 --s;
; 2840 :                 *s = '\0';

  001d5	41 c6 40 ff 00	 mov	 BYTE PTR [r8-1], 0

; 2841 :                 uni = PyUnicode_DecodeUTF8(PyBytes_AS_STRING(str),
; 2842 :                                            PyBytes_GET_SIZE(str),
; 2843 :                                            NULL);

  001da	48 8b 54 24 48	 mov	 rdx, QWORD PTR str$[rsp]
  001df	45 33 c0	 xor	 r8d, r8d
  001e2	48 8d 4a 78	 lea	 rcx, QWORD PTR [rdx+120]
  001e6	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  001ea	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8

; 2844 :                 Py_DECREF(str);

  001ef	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$[rsp]
  001f4	48 8b f8	 mov	 rdi, rax
  001f7	e8 00 00 00 00	 call	 _Py_DecRef

; 2845 :                 if (!uni)

  001fc	48 85 ff	 test	 rdi, rdi

; 2846 :                     return NULL;

  001ff	74 7e		 je	 SHORT $LN46@alias_for_

; 2847 :                 str = uni;
; 2848 :                 PyUnicode_InternInPlace(&str);

  00201	48 8d 4c 24 48	 lea	 rcx, QWORD PTR str$[rsp]
  00206	48 89 7c 24 48	 mov	 QWORD PTR str$[rsp], rdi
  0020b	e8 00 00 00 00	 call	 PyUnicode_InternInPlace

; 2849 :                 PyArena_AddPyObject(c->c_arena, str);

  00210	48 8b 54 24 48	 mov	 rdx, QWORD PTR str$[rsp]
  00215	48 8b 74 24 40	 mov	 rsi, QWORD PTR c$[rsp]

; 2850 :                 return alias(str, NULL, c->c_arena);

  0021a	e9 9e 00 00 00	 jmp	 $LN44@alias_for_
$LN29@alias_for_:

; 2766 :         case import_as_name: {
; 2767 :             node *name_node = CHILD(n, 0);

  0021f	48 8b 7b 20	 mov	 rdi, QWORD PTR [rbx+32]

; 2768 :             str = NULL;
; 2769 :             name = NEW_IDENTIFIER(name_node);

  00223	48 8b 54 24 40	 mov	 rdx, QWORD PTR c$[rsp]
  00228	33 f6		 xor	 esi, esi
  0022a	48 89 74 24 48	 mov	 QWORD PTR str$[rsp], rsi
  0022f	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00233	e8 00 00 00 00	 call	 new_identifier
  00238	48 8b f0	 mov	 rsi, rax

; 2770 :             if (!name)

  0023b	48 85 c0	 test	 rax, rax

; 2771 :                 return NULL;

  0023e	74 3f		 je	 SHORT $LN46@alias_for_

; 2772 :             if (NCH(n) == 3) {

  00240	83 7b 18 03	 cmp	 DWORD PTR [rbx+24], 3
  00244	75 48		 jne	 SHORT $LN27@alias_for_

; 2773 :                 node *str_node = CHILD(n, 2);

  00246	48 8b 7b 20	 mov	 rdi, QWORD PTR [rbx+32]

; 2774 :                 str = NEW_IDENTIFIER(str_node);

  0024a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR c$[rsp]
  0024f	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00253	48 8b d3	 mov	 rdx, rbx
  00256	e8 00 00 00 00	 call	 new_identifier
  0025b	48 89 44 24 48	 mov	 QWORD PTR str$[rsp], rax

; 2775 :                 if (!str)

  00260	48 85 c0	 test	 rax, rax

; 2776 :                     return NULL;

  00263	74 1a		 je	 SHORT $LN46@alias_for_

; 2777 :                 if (store && forbidden_name(c, str, str_node, 0))

  00265	85 ed		 test	 ebp, ebp
  00267	74 34		 je	 SHORT $LN23@alias_for_
  00269	4c 8d 47 50	 lea	 r8, QWORD PTR [rdi+80]
$LN48@alias_for_:
  0026d	48 8b d0	 mov	 rdx, rax
  00270	45 33 c9	 xor	 r9d, r9d
  00273	48 8b cb	 mov	 rcx, rbx
  00276	e8 00 00 00 00	 call	 forbidden_name
  0027b	85 c0		 test	 eax, eax
  0027d	74 19		 je	 SHORT $LN42@alias_for_
$LN46@alias_for_:

; 2778 :                     return NULL;

  0027f	33 c0		 xor	 eax, eax
  00281	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 2860 :             return NULL;
; 2861 :     }
; 2862 : 
; 2863 :     PyErr_SetString(PyExc_SystemError, "unhandled import name condition");
; 2864 :     return NULL;
; 2865 : }

  00286	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0028a	5e		 pop	 rsi
  0028b	5d		 pop	 rbp
  0028c	5b		 pop	 rbx
  0028d	c3		 ret	 0
$LN27@alias_for_:

; 2779 :             }
; 2780 :             else {
; 2781 :                 if (forbidden_name(c, name, name_node, 0))

  0028e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR c$[rsp]
  00293	4c 8b c7	 mov	 r8, rdi

; 2782 :                     return NULL;

  00296	eb d5		 jmp	 SHORT $LN48@alias_for_
$LN42@alias_for_:
  00298	48 8b 44 24 48	 mov	 rax, QWORD PTR str$[rsp]
$LN23@alias_for_:

; 2783 :             }
; 2784 :             return alias(name, str, c->c_arena);

  0029d	4c 8b 43 08	 mov	 r8, QWORD PTR [rbx+8]
  002a1	48 8b d0	 mov	 rdx, rax
  002a4	48 8b ce	 mov	 rcx, rsi
  002a7	eb 28		 jmp	 SHORT $LN45@alias_for_
$LN2@alias_for_:

; 2851 :             }
; 2852 :             break;
; 2853 :         case STAR:
; 2854 :             str = PyUnicode_InternFromString("*");

  002a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01NBENCBCI@?$CK?$AA@
  002b0	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  002b5	48 89 44 24 48	 mov	 QWORD PTR str$[rsp], rax

; 2855 :             PyArena_AddPyObject(c->c_arena, str);

  002ba	48 8b d0	 mov	 rdx, rax
$LN44@alias_for_:
  002bd	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  002c1	e8 00 00 00 00	 call	 PyArena_AddPyObject

; 2856 :             return alias(str, NULL, c->c_arena);

  002c6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$[rsp]
$LN43@alias_for_:
  002cb	4c 8b 46 08	 mov	 r8, QWORD PTR [rsi+8]
  002cf	33 d2		 xor	 edx, edx
$LN45@alias_for_:
  002d1	e8 00 00 00 00	 call	 _Py_alias
  002d6	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 2860 :             return NULL;
; 2861 :     }
; 2862 : 
; 2863 :     PyErr_SetString(PyExc_SystemError, "unhandled import name condition");
; 2864 :     return NULL;
; 2865 : }

  002db	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002df	5e		 pop	 rsi
  002e0	5d		 pop	 rbp
  002e1	5b		 pop	 rbx
  002e2	c3		 ret	 0
alias_for_import_name ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@FCJHOKGM@unknown?5import?5statement?3?5starts@ ; `string'
PUBLIC	??_C@_0DL@FACCMHDI@trailing?5comma?5not?5allowed?5witho@ ; `string'
PUBLIC	??_C@_0CE@KFALHAEB@Unexpected?5node?9type?5in?5from?9imp@ ; `string'
EXTRN	_Py_ImportFrom:PROC
EXTRN	_Py_Import:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_import_stmt DD imagerel ast_for_import_stmt
	DD	imagerel ast_for_import_stmt+225
	DD	imagerel $unwind$ast_for_import_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ast_for_import_stmt DD imagerel ast_for_import_stmt+225
	DD	imagerel ast_for_import_stmt+392
	DD	imagerel $chain$0$ast_for_import_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ast_for_import_stmt DD imagerel ast_for_import_stmt+392
	DD	imagerel ast_for_import_stmt+415
	DD	imagerel $chain$1$ast_for_import_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ast_for_import_stmt DD imagerel ast_for_import_stmt+415
	DD	imagerel ast_for_import_stmt+671
	DD	imagerel $chain$2$ast_for_import_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ast_for_import_stmt DD imagerel ast_for_import_stmt+671
	DD	imagerel ast_for_import_stmt+706
	DD	imagerel $chain$3$ast_for_import_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ast_for_import_stmt DD 021H
	DD	imagerel ast_for_import_stmt
	DD	imagerel ast_for_import_stmt+225
	DD	imagerel $unwind$ast_for_import_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ast_for_import_stmt DD 020021H
	DD	0ce400H
	DD	imagerel ast_for_import_stmt
	DD	imagerel ast_for_import_stmt+225
	DD	imagerel $unwind$ast_for_import_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ast_for_import_stmt DD 021H
	DD	imagerel ast_for_import_stmt
	DD	imagerel ast_for_import_stmt+225
	DD	imagerel $unwind$ast_for_import_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ast_for_import_stmt DD 020521H
	DD	0ce405H
	DD	imagerel ast_for_import_stmt
	DD	imagerel ast_for_import_stmt+225
	DD	imagerel $unwind$ast_for_import_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_import_stmt DD 0a1601H
	DD	0f5416H
	DD	0e3416H
	DD	0f0125216H
	DD	0c00ed010H
	DD	0600b700cH
xdata	ENDS
;	COMDAT ??_C@_0DD@FCJHOKGM@unknown?5import?5statement?3?5starts@
CONST	SEGMENT
??_C@_0DD@FCJHOKGM@unknown?5import?5statement?3?5starts@ DB 'unknown impo'
	DB	'rt statement: starts with command ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@FACCMHDI@trailing?5comma?5not?5allowed?5witho@
CONST	SEGMENT
??_C@_0DL@FACCMHDI@trailing?5comma?5not?5allowed?5witho@ DB 'trailing com'
	DB	'ma not allowed without surrounding parentheses', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KFALHAEB@Unexpected?5node?9type?5in?5from?9imp@
CONST	SEGMENT
??_C@_0CE@KFALHAEB@Unexpected?5node?9type?5in?5from?9imp@ DB 'Unexpected '
	DB	'node-type in from-import', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ast_for_import_stmt
_TEXT	SEGMENT
c$ = 96
col_offset$1$ = 104
n$ = 104
ast_for_import_stmt PROC				; COMDAT

; 2869 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 57		 push	 r15
  00012	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2870 :     /*
; 2871 :       import_stmt: import_name | import_from
; 2872 :       import_name: 'import' dotted_as_names
; 2873 :       import_from: 'from' (('.' | '...')* dotted_name | ('.' | '...')+)
; 2874 :                    'import' ('*' | '(' import_as_names ')' | import_as_names)
; 2875 :     */
; 2876 :     int lineno;
; 2877 :     int col_offset;
; 2878 :     int i;
; 2879 :     asdl_seq *aliases;
; 2880 : 
; 2881 :     REQ(n, import_stmt);
; 2882 :     lineno = LINENO(n);
; 2883 :     col_offset = n->n_col_offset;
; 2884 :     n = CHILD(n, 0);

  00016	4c 8b 62 20	 mov	 r12, QWORD PTR [rdx+32]
  0001a	8b 6a 14	 mov	 ebp, DWORD PTR [rdx+20]
  0001d	44 8b 7a 10	 mov	 r15d, DWORD PTR [rdx+16]

; 2885 :     if (TYPE(n) == import_name) {

  00021	41 0f b7 04 24	 movzx	 eax, WORD PTR [r12]
  00026	4c 8b e9	 mov	 r13, rcx
  00029	b9 1b 01 00 00	 mov	 ecx, 283		; 0000011bH
  0002e	89 6c 24 68	 mov	 DWORD PTR col_offset$1$[rsp], ebp
  00032	66 3b c1	 cmp	 ax, cx
  00035	0f 85 8c 00 00
	00		 jne	 $LN33@ast_for_im

; 2886 :         n = CHILD(n, 1);

  0003b	49 8b 5c 24 20	 mov	 rbx, QWORD PTR [r12+32]

; 2887 :         REQ(n, dotted_as_names);
; 2888 :         aliases = asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);

  00040	8b 43 40	 mov	 eax, DWORD PTR [rbx+64]
  00043	ff c0		 inc	 eax
  00045	99		 cdq
  00046	2b c2		 sub	 eax, edx
  00048	49 8b 55 08	 mov	 rdx, QWORD PTR [r13+8]
  0004c	d1 f8		 sar	 eax, 1
  0004e	48 63 c8	 movsxd	 rcx, eax
  00051	e8 00 00 00 00	 call	 asdl_seq_new
  00056	48 8b f8	 mov	 rdi, rax

; 2889 :         if (!aliases)

  00059	48 85 c0	 test	 rax, rax

; 2890 :                 return NULL;

  0005c	0f 84 59 02 00
	00		 je	 $LN39@ast_for_im

; 2891 :         for (i = 0; i < NCH(n); i += 2) {

  00062	33 f6		 xor	 esi, esi
  00064	39 73 40	 cmp	 DWORD PTR [rbx+64], esi
  00067	7e 47		 jle	 SHORT $LN29@ast_for_im
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL31@ast_for_im:

; 2892 :             alias_ty import_alias = alias_for_import_name(c, CHILD(n, i), 1);

  00070	48 63 c6	 movsxd	 rax, esi
  00073	41 b8 01 00 00
	00		 mov	 r8d, 1
  00079	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  0007d	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00081	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  00085	49 8b cd	 mov	 rcx, r13
  00088	e8 00 00 00 00	 call	 alias_for_import_name
  0008d	4c 8b d8	 mov	 r11, rax

; 2893 :             if (!import_alias)

  00090	48 85 c0	 test	 rax, rax
  00093	0f 84 22 02 00
	00		 je	 $LN39@ast_for_im

; 2894 :                 return NULL;
; 2895 :             asdl_seq_SET(aliases, i / 2, import_alias);

  00099	8b c6		 mov	 eax, esi
  0009b	83 c6 02	 add	 esi, 2
  0009e	99		 cdq
  0009f	2b c2		 sub	 eax, edx
  000a1	d1 f8		 sar	 eax, 1
  000a3	48 63 c8	 movsxd	 rcx, eax
  000a6	4c 89 5c cf 08	 mov	 QWORD PTR [rdi+rcx*8+8], r11
  000ab	3b 73 40	 cmp	 esi, DWORD PTR [rbx+64]
  000ae	7c c0		 jl	 SHORT $LL31@ast_for_im
$LN29@ast_for_im:

; 2896 :         }
; 2897 :         return Import(aliases, lineno, col_offset, c->c_arena);

  000b0	4d 8b 4d 08	 mov	 r9, QWORD PTR [r13+8]
  000b4	44 8b c5	 mov	 r8d, ebp
  000b7	41 8b d7	 mov	 edx, r15d
  000ba	48 8b cf	 mov	 rcx, rdi
  000bd	e8 00 00 00 00	 call	 _Py_Import
  000c2	e9 c1 00 00 00	 jmp	 $LN34@ast_for_im
$LN33@ast_for_im:

; 2898 :     }
; 2899 :     else if (TYPE(n) == import_from) {

  000c7	b9 1c 01 00 00	 mov	 ecx, 284		; 0000011cH
  000cc	66 3b c1	 cmp	 ax, cx
  000cf	0f 85 ca 01 00
	00		 jne	 $LN26@ast_for_im

; 2902 :         alias_ty mod = NULL;
; 2903 :         identifier modname = NULL;
; 2904 : 
; 2905 :        /* Count the number of dots (for relative imports) and check for the
; 2906 :           optional module name */
; 2907 :         for (idx = 1; idx < NCH(n); idx++) {

  000d5	41 8b 54 24 18	 mov	 edx, DWORD PTR [r12+24]
  000da	33 f6		 xor	 esi, esi
  000dc	bb 01 00 00 00	 mov	 ebx, 1
  000e1	4c 89 74 24 60	 mov	 QWORD PTR [rsp+96], r14
  000e6	8b ee		 mov	 ebp, esi
  000e8	44 8b f6	 mov	 r14d, esi
  000eb	3b d3		 cmp	 edx, ebx
  000ed	7e 59		 jle	 SHORT $LN41@ast_for_im

; 2900 :         int n_children;
; 2901 :         int idx, ndots = 0;

  000ef	4d 8b 44 24 20	 mov	 r8, QWORD PTR [r12+32]
  000f4	41 b9 21 01 00
	00		 mov	 r9d, 289		; 00000121H
  000fa	49 8d 48 28	 lea	 rcx, QWORD PTR [r8+40]
  000fe	66 90		 npad	 2
$LL25@ast_for_im:

; 2908 :             if (TYPE(CHILD(n, idx)) == dotted_name) {

  00100	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00103	66 41 3b c1	 cmp	 ax, r9w
  00107	74 1f		 je	 SHORT $LN40@ast_for_im

; 2913 :                 break;
; 2914 :             } else if (TYPE(CHILD(n, idx)) == ELLIPSIS) {

  00109	66 83 f8 33	 cmp	 ax, 51			; 00000033H
  0010d	75 05		 jne	 SHORT $LN19@ast_for_im

; 2915 :                 /* three consecutive dots are tokenized as one ELLIPSIS */
; 2916 :                 ndots += 3;

  0010f	83 c5 03	 add	 ebp, 3

; 2917 :                 continue;

  00112	eb 08		 jmp	 SHORT $LN24@ast_for_im
$LN19@ast_for_im:

; 2918 :             } else if (TYPE(CHILD(n, idx)) != DOT) {

  00114	66 83 f8 17	 cmp	 ax, 23
  00118	75 2e		 jne	 SHORT $LN41@ast_for_im

; 2919 :                 break;
; 2920 :             }
; 2921 :             ndots++;

  0011a	ff c5		 inc	 ebp
$LN24@ast_for_im:

; 2902 :         alias_ty mod = NULL;
; 2903 :         identifier modname = NULL;
; 2904 : 
; 2905 :        /* Count the number of dots (for relative imports) and check for the
; 2906 :           optional module name */
; 2907 :         for (idx = 1; idx < NCH(n); idx++) {

  0011c	ff c3		 inc	 ebx
  0011e	48 83 c1 28	 add	 rcx, 40			; 00000028H
  00122	3b da		 cmp	 ebx, edx
  00124	7c da		 jl	 SHORT $LL25@ast_for_im

; 2964 :                 if (!import_alias)

  00126	eb 20		 jmp	 SHORT $LN41@ast_for_im
$LN40@ast_for_im:

; 2909 :                 mod = alias_for_import_name(c, CHILD(n, idx), 0);

  00128	48 63 c3	 movsxd	 rax, ebx
  0012b	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  0012f	49 8d 14 c8	 lea	 rdx, QWORD PTR [r8+rcx*8]
  00133	45 33 c0	 xor	 r8d, r8d
  00136	49 8b cd	 mov	 rcx, r13
  00139	e8 00 00 00 00	 call	 alias_for_import_name
  0013e	4c 8b f0	 mov	 r14, rax

; 2910 :                 if (!mod)

  00141	48 85 c0	 test	 rax, rax

; 2911 :                     return NULL;

  00144	74 3b		 je	 SHORT $LN42@ast_for_im

; 2912 :                 idx++;

  00146	ff c3		 inc	 ebx
$LN41@ast_for_im:

; 2922 :         }
; 2923 :         idx++; /* skip over the 'import' keyword */
; 2924 :         switch (TYPE(CHILD(n, idx))) {

  00148	49 8b 54 24 20	 mov	 rdx, QWORD PTR [r12+32]
  0014d	ff c3		 inc	 ebx
  0014f	48 63 c3	 movsxd	 rax, ebx
  00152	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00156	0f bf 04 ca	 movsx	 eax, WORD PTR [rdx+rcx*8]
  0015a	48 8d 3c ca	 lea	 rdi, QWORD PTR [rdx+rcx*8]
  0015e	83 f8 07	 cmp	 eax, 7
  00161	74 66		 je	 SHORT $LN13@ast_for_im
  00163	83 f8 10	 cmp	 eax, 16
  00166	74 5a		 je	 SHORT $LN14@ast_for_im
  00168	3d 1f 01 00 00	 cmp	 eax, 287		; 0000011fH
  0016d	74 30		 je	 SHORT $LN12@ast_for_im

; 2943 :             }
; 2944 :             break;
; 2945 :         default:
; 2946 :             ast_error(c, n, "Unexpected node-type in from-import");

  0016f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CE@KFALHAEB@Unexpected?5node?9type?5in?5from?9imp@
  00176	49 8b d4	 mov	 rdx, r12
$LN48@ast_for_im:
  00179	49 8b cd	 mov	 rcx, r13
  0017c	e8 00 00 00 00	 call	 ast_error
$LN42@ast_for_im:

; 2947 :             return NULL;

  00181	33 c0		 xor	 eax, eax
$LN47@ast_for_im:
  00183	4c 8b 74 24 60	 mov	 r14, QWORD PTR [rsp+96]
$LN34@ast_for_im:

; 2978 : }

  00188	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0018d	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  00192	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00196	41 5f		 pop	 r15
  00198	41 5d		 pop	 r13
  0019a	41 5c		 pop	 r12
  0019c	5f		 pop	 rdi
  0019d	5e		 pop	 rsi
  0019e	c3		 ret	 0
$LN12@ast_for_im:

; 2934 :             break;
; 2935 :         case import_as_names:
; 2936 :             /* from ... import x, y, z */
; 2937 :             n = CHILD(n, idx);
; 2938 :             n_children = NCH(n);

  0019f	8b 4f 18	 mov	 ecx, DWORD PTR [rdi+24]

; 2939 :             if (n_children % 2 == 0) {

  001a2	8b c1		 mov	 eax, ecx
  001a4	25 01 00 00 80	 and	 eax, -2147483647	; ffffffff80000001H
  001a9	7d 07		 jge	 SHORT $LN46@ast_for_im
  001ab	ff c8		 dec	 eax
  001ad	83 c8 fe	 or	 eax, -2
  001b0	ff c0		 inc	 eax
$LN46@ast_for_im:
  001b2	85 c0		 test	 eax, eax
  001b4	75 25		 jne	 SHORT $LN15@ast_for_im

; 2940 :                 ast_error(c, n, "trailing comma not allowed without"
; 2941 :                              " surrounding parentheses");

  001b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0DL@FACCMHDI@trailing?5comma?5not?5allowed?5witho@
  001bd	48 8b d7	 mov	 rdx, rdi

; 2942 :                 return NULL;

  001c0	eb b7		 jmp	 SHORT $LN48@ast_for_im
$LN14@ast_for_im:

; 2925 :         case STAR:
; 2926 :             /* from ... import * */
; 2927 :             n = CHILD(n, idx);
; 2928 :             n_children = 1;

  001c2	b9 01 00 00 00	 mov	 ecx, 1

; 2929 :             break;

  001c7	eb 12		 jmp	 SHORT $LN15@ast_for_im
$LN13@ast_for_im:

; 2930 :         case LPAR:
; 2931 :             /* from ... import (x, y, z) */
; 2932 :             n = CHILD(n, idx + 1);

  001c9	8d 43 01	 lea	 eax, DWORD PTR [rbx+1]
  001cc	48 63 c8	 movsxd	 rcx, eax
  001cf	48 8d 04 89	 lea	 rax, QWORD PTR [rcx+rcx*4]

; 2933 :             n_children = NCH(n);

  001d3	8b 4c c2 18	 mov	 ecx, DWORD PTR [rdx+rax*8+24]
  001d7	48 8d 3c c2	 lea	 rdi, QWORD PTR [rdx+rax*8]
$LN15@ast_for_im:

; 2948 :         }
; 2949 : 
; 2950 :         aliases = asdl_seq_new((n_children + 1) / 2, c->c_arena);

  001db	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  001de	99		 cdq
  001df	2b c2		 sub	 eax, edx
  001e1	49 8b 55 08	 mov	 rdx, QWORD PTR [r13+8]
  001e5	d1 f8		 sar	 eax, 1
  001e7	48 63 c8	 movsxd	 rcx, eax
  001ea	e8 00 00 00 00	 call	 asdl_seq_new
  001ef	4c 8b e0	 mov	 r12, rax

; 2951 :         if (!aliases)

  001f2	48 85 c0	 test	 rax, rax

; 2952 :             return NULL;

  001f5	74 8a		 je	 SHORT $LN42@ast_for_im

; 2953 : 
; 2954 :         /* handle "from ... import *" special b/c there's no children */
; 2955 :         if (TYPE(n) == STAR) {

  001f7	66 83 3f 10	 cmp	 WORD PTR [rdi], 16
  001fb	75 21		 jne	 SHORT $LN8@ast_for_im

; 2956 :             alias_ty import_alias = alias_for_import_name(c, n, 1);

  001fd	41 b8 01 00 00
	00		 mov	 r8d, 1
  00203	48 8b d7	 mov	 rdx, rdi
  00206	49 8b cd	 mov	 rcx, r13
  00209	e8 00 00 00 00	 call	 alias_for_import_name

; 2957 :             if (!import_alias)

  0020e	48 85 c0	 test	 rax, rax

; 2958 :                 return NULL;

  00211	0f 84 6a ff ff
	ff		 je	 $LN42@ast_for_im

; 2959 :                 asdl_seq_SET(aliases, 0, import_alias);

  00217	49 89 44 24 08	 mov	 QWORD PTR [r12+8], rax

; 2960 :         }
; 2961 :         else {

  0021c	eb 52		 jmp	 SHORT $LN3@ast_for_im
$LN8@ast_for_im:

; 2962 :             for (i = 0; i < NCH(n); i += 2) {

  0021e	8b de		 mov	 ebx, esi
  00220	39 5f 18	 cmp	 DWORD PTR [rdi+24], ebx
  00223	7e 4b		 jle	 SHORT $LN3@ast_for_im
  00225	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL5@ast_for_im:

; 2963 :                 alias_ty import_alias = alias_for_import_name(c, CHILD(n, i), 1);

  00230	48 63 c3	 movsxd	 rax, ebx
  00233	41 b8 01 00 00
	00		 mov	 r8d, 1
  00239	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  0023d	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00241	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  00245	49 8b cd	 mov	 rcx, r13
  00248	e8 00 00 00 00	 call	 alias_for_import_name
  0024d	4c 8b d8	 mov	 r11, rax

; 2964 :                 if (!import_alias)

  00250	48 85 c0	 test	 rax, rax
  00253	0f 84 28 ff ff
	ff		 je	 $LN42@ast_for_im

; 2965 :                     return NULL;
; 2966 :                     asdl_seq_SET(aliases, i / 2, import_alias);

  00259	8b c3		 mov	 eax, ebx
  0025b	83 c3 02	 add	 ebx, 2
  0025e	99		 cdq
  0025f	2b c2		 sub	 eax, edx
  00261	d1 f8		 sar	 eax, 1
  00263	48 63 c8	 movsxd	 rcx, eax
  00266	4d 89 5c cc 08	 mov	 QWORD PTR [r12+rcx*8+8], r11
  0026b	3b 5f 18	 cmp	 ebx, DWORD PTR [rdi+24]
  0026e	7c c0		 jl	 SHORT $LL5@ast_for_im
$LN3@ast_for_im:

; 2967 :             }
; 2968 :         }
; 2969 :         if (mod != NULL)

  00270	4d 85 f6	 test	 r14, r14
  00273	74 03		 je	 SHORT $LN1@ast_for_im

; 2970 :             modname = mod->name;

  00275	49 8b 36	 mov	 rsi, QWORD PTR [r14]
$LN1@ast_for_im:

; 2971 :         return ImportFrom(modname, aliases, ndots, lineno, col_offset,
; 2972 :                           c->c_arena);

  00278	49 8b 45 08	 mov	 rax, QWORD PTR [r13+8]
  0027c	45 8b cf	 mov	 r9d, r15d
  0027f	44 8b c5	 mov	 r8d, ebp
  00282	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00287	8b 44 24 68	 mov	 eax, DWORD PTR col_offset$1$[rsp]
  0028b	49 8b d4	 mov	 rdx, r12
  0028e	48 8b ce	 mov	 rcx, rsi
  00291	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00295	e8 00 00 00 00	 call	 _Py_ImportFrom
  0029a	e9 e4 fe ff ff	 jmp	 $LN47@ast_for_im
$LN26@ast_for_im:

; 2973 :     }
; 2974 :     PyErr_Format(PyExc_SystemError,
; 2975 :                  "unknown import statement: starts with command '%s'",
; 2976 :                  STR(CHILD(n, 0)));

  0029f	4d 8b 44 24 20	 mov	 r8, QWORD PTR [r12+32]
  002a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  002ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@FCJHOKGM@unknown?5import?5statement?3?5starts@
  002b2	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  002b6	e8 00 00 00 00	 call	 PyErr_Format
$LN39@ast_for_im:

; 2977 :     return NULL;

  002bb	33 c0		 xor	 eax, eax
  002bd	e9 c6 fe ff ff	 jmp	 $LN34@ast_for_im
ast_for_import_stmt ENDP
_TEXT	ENDS
EXTRN	_Py_Global:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_global_stmt DD imagerel ast_for_global_stmt
	DD	imagerel ast_for_global_stmt+67
	DD	imagerel $unwind$ast_for_global_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ast_for_global_stmt DD imagerel ast_for_global_stmt+67
	DD	imagerel ast_for_global_stmt+194
	DD	imagerel $chain$1$ast_for_global_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ast_for_global_stmt DD imagerel ast_for_global_stmt+194
	DD	imagerel ast_for_global_stmt+196
	DD	imagerel $chain$3$ast_for_global_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ast_for_global_stmt DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel ast_for_global_stmt
	DD	imagerel ast_for_global_stmt+67
	DD	imagerel $unwind$ast_for_global_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ast_for_global_stmt DD 040f21H
	DD	07740fH
	DD	066405H
	DD	imagerel ast_for_global_stmt
	DD	imagerel ast_for_global_stmt+67
	DD	imagerel $unwind$ast_for_global_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_global_stmt DD 061001H
	DD	095410H
	DD	083410H
	DD	0c00c3210H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_global_stmt
_TEXT	SEGMENT
c$ = 48
n$ = 56
ast_for_global_stmt PROC				; COMDAT

; 2982 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	41 54		 push	 r12
  0000c	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2983 :     /* global_stmt: 'global' NAME (',' NAME)* */
; 2984 :     identifier name;
; 2985 :     asdl_seq *s;
; 2986 :     int i;
; 2987 : 
; 2988 :     REQ(n, global_stmt);
; 2989 :     s = asdl_seq_new(NCH(n) / 2, c->c_arena);

  00010	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  00013	48 8b da	 mov	 rbx, rdx
  00016	48 8b e9	 mov	 rbp, rcx
  00019	99		 cdq
  0001a	2b c2		 sub	 eax, edx
  0001c	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
  00020	d1 f8		 sar	 eax, 1
  00022	48 63 c8	 movsxd	 rcx, eax
  00025	e8 00 00 00 00	 call	 asdl_seq_new
  0002a	4c 8b e0	 mov	 r12, rax

; 2990 :     if (!s)

  0002d	48 85 c0	 test	 rax, rax
  00030	75 11		 jne	 SHORT $LN5@ast_for_gl

; 2999 : }

  00032	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00037	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	41 5c		 pop	 r12
  00042	c3		 ret	 0
$LN5@ast_for_gl:
  00043	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi

; 2991 :         return NULL;
; 2992 :     for (i = 1; i < NCH(n); i += 2) {

  00048	be 01 00 00 00	 mov	 esi, 1
  0004d	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00052	39 73 18	 cmp	 DWORD PTR [rbx+24], esi
  00055	7e 3d		 jle	 SHORT $LN2@ast_for_gl
  00057	bf 28 00 00 00	 mov	 edi, 40			; 00000028H
  0005c	0f 1f 40 00	 npad	 4
$LL4@ast_for_gl:

; 2993 :         name = NEW_IDENTIFIER(CHILD(n, i));

  00060	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00064	48 8b d5	 mov	 rdx, rbp
  00067	48 8b 4c 0f 08	 mov	 rcx, QWORD PTR [rdi+rcx+8]
  0006c	e8 00 00 00 00	 call	 new_identifier
  00071	4c 8b d8	 mov	 r11, rax

; 2994 :         if (!name)

  00074	48 85 c0	 test	 rax, rax
  00077	74 49		 je	 SHORT $LN9@ast_for_gl

; 2996 :         asdl_seq_SET(s, i / 2, name);

  00079	8b c6		 mov	 eax, esi
  0007b	83 c6 02	 add	 esi, 2
  0007e	48 83 c7 50	 add	 rdi, 80			; 00000050H
  00082	99		 cdq
  00083	2b c2		 sub	 eax, edx
  00085	d1 f8		 sar	 eax, 1
  00087	48 63 c8	 movsxd	 rcx, eax
  0008a	4d 89 5c cc 08	 mov	 QWORD PTR [r12+rcx*8+8], r11
  0008f	3b 73 18	 cmp	 esi, DWORD PTR [rbx+24]
  00092	7c cc		 jl	 SHORT $LL4@ast_for_gl
$LN2@ast_for_gl:

; 2997 :     }
; 2998 :     return Global(s, LINENO(n), n->n_col_offset, c->c_arena);

  00094	4c 8b 4d 08	 mov	 r9, QWORD PTR [rbp+8]
  00098	44 8b 43 14	 mov	 r8d, DWORD PTR [rbx+20]
  0009c	8b 53 10	 mov	 edx, DWORD PTR [rbx+16]
  0009f	49 8b cc	 mov	 rcx, r12
  000a2	e8 00 00 00 00	 call	 _Py_Global
$LN12@ast_for_gl:

; 2999 : }

  000a7	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000ac	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  000b1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b6	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000bb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bf	41 5c		 pop	 r12
  000c1	c3		 ret	 0
$LN9@ast_for_gl:

; 2995 :             return NULL;

  000c2	eb e3		 jmp	 SHORT $LN12@ast_for_gl
ast_for_global_stmt ENDP
_TEXT	ENDS
EXTRN	_Py_Nonlocal:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_nonlocal_stmt DD imagerel ast_for_nonlocal_stmt
	DD	imagerel ast_for_nonlocal_stmt+67
	DD	imagerel $unwind$ast_for_nonlocal_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ast_for_nonlocal_stmt DD imagerel ast_for_nonlocal_stmt+67
	DD	imagerel ast_for_nonlocal_stmt+194
	DD	imagerel $chain$1$ast_for_nonlocal_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ast_for_nonlocal_stmt DD imagerel ast_for_nonlocal_stmt+194
	DD	imagerel ast_for_nonlocal_stmt+196
	DD	imagerel $chain$3$ast_for_nonlocal_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ast_for_nonlocal_stmt DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel ast_for_nonlocal_stmt
	DD	imagerel ast_for_nonlocal_stmt+67
	DD	imagerel $unwind$ast_for_nonlocal_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ast_for_nonlocal_stmt DD 040f21H
	DD	07740fH
	DD	066405H
	DD	imagerel ast_for_nonlocal_stmt
	DD	imagerel ast_for_nonlocal_stmt+67
	DD	imagerel $unwind$ast_for_nonlocal_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_nonlocal_stmt DD 061001H
	DD	095410H
	DD	083410H
	DD	0c00c3210H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_nonlocal_stmt
_TEXT	SEGMENT
c$ = 48
n$ = 56
ast_for_nonlocal_stmt PROC				; COMDAT

; 3003 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	41 54		 push	 r12
  0000c	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3004 :     /* nonlocal_stmt: 'nonlocal' NAME (',' NAME)* */
; 3005 :     identifier name;
; 3006 :     asdl_seq *s;
; 3007 :     int i;
; 3008 : 
; 3009 :     REQ(n, nonlocal_stmt);
; 3010 :     s = asdl_seq_new(NCH(n) / 2, c->c_arena);

  00010	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  00013	48 8b da	 mov	 rbx, rdx
  00016	48 8b e9	 mov	 rbp, rcx
  00019	99		 cdq
  0001a	2b c2		 sub	 eax, edx
  0001c	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
  00020	d1 f8		 sar	 eax, 1
  00022	48 63 c8	 movsxd	 rcx, eax
  00025	e8 00 00 00 00	 call	 asdl_seq_new
  0002a	4c 8b e0	 mov	 r12, rax

; 3011 :     if (!s)

  0002d	48 85 c0	 test	 rax, rax
  00030	75 11		 jne	 SHORT $LN5@ast_for_no

; 3020 : }

  00032	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00037	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	41 5c		 pop	 r12
  00042	c3		 ret	 0
$LN5@ast_for_no:
  00043	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi

; 3012 :         return NULL;
; 3013 :     for (i = 1; i < NCH(n); i += 2) {

  00048	be 01 00 00 00	 mov	 esi, 1
  0004d	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00052	39 73 18	 cmp	 DWORD PTR [rbx+24], esi
  00055	7e 3d		 jle	 SHORT $LN2@ast_for_no
  00057	bf 28 00 00 00	 mov	 edi, 40			; 00000028H
  0005c	0f 1f 40 00	 npad	 4
$LL4@ast_for_no:

; 3014 :         name = NEW_IDENTIFIER(CHILD(n, i));

  00060	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00064	48 8b d5	 mov	 rdx, rbp
  00067	48 8b 4c 0f 08	 mov	 rcx, QWORD PTR [rdi+rcx+8]
  0006c	e8 00 00 00 00	 call	 new_identifier
  00071	4c 8b d8	 mov	 r11, rax

; 3015 :         if (!name)

  00074	48 85 c0	 test	 rax, rax
  00077	74 49		 je	 SHORT $LN9@ast_for_no

; 3017 :         asdl_seq_SET(s, i / 2, name);

  00079	8b c6		 mov	 eax, esi
  0007b	83 c6 02	 add	 esi, 2
  0007e	48 83 c7 50	 add	 rdi, 80			; 00000050H
  00082	99		 cdq
  00083	2b c2		 sub	 eax, edx
  00085	d1 f8		 sar	 eax, 1
  00087	48 63 c8	 movsxd	 rcx, eax
  0008a	4d 89 5c cc 08	 mov	 QWORD PTR [r12+rcx*8+8], r11
  0008f	3b 73 18	 cmp	 esi, DWORD PTR [rbx+24]
  00092	7c cc		 jl	 SHORT $LL4@ast_for_no
$LN2@ast_for_no:

; 3018 :     }
; 3019 :     return Nonlocal(s, LINENO(n), n->n_col_offset, c->c_arena);

  00094	4c 8b 4d 08	 mov	 r9, QWORD PTR [rbp+8]
  00098	44 8b 43 14	 mov	 r8d, DWORD PTR [rbx+20]
  0009c	8b 53 10	 mov	 edx, DWORD PTR [rbx+16]
  0009f	49 8b cc	 mov	 rcx, r12
  000a2	e8 00 00 00 00	 call	 _Py_Nonlocal
$LN12@ast_for_no:

; 3020 : }

  000a7	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000ac	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  000b1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b6	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000bb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bf	41 5c		 pop	 r12
  000c1	c3		 ret	 0
$LN9@ast_for_no:

; 3016 :             return NULL;

  000c2	eb e3		 jmp	 SHORT $LN12@ast_for_no
ast_for_nonlocal_stmt ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_suite DD imagerel ast_for_suite
	DD	imagerel ast_for_suite+83
	DD	imagerel $unwind$ast_for_suite
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ast_for_suite DD imagerel ast_for_suite+83
	DD	imagerel ast_for_suite+260
	DD	imagerel $chain$2$ast_for_suite
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ast_for_suite DD imagerel ast_for_suite+260
	DD	imagerel ast_for_suite+519
	DD	imagerel $chain$4$ast_for_suite
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ast_for_suite DD 060021H
	DD	05f400H
	DD	066400H
	DD	075400H
	DD	imagerel ast_for_suite
	DD	imagerel ast_for_suite+83
	DD	imagerel $unwind$ast_for_suite
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ast_for_suite DD 061921H
	DD	05f419H
	DD	06640fH
	DD	075405H
	DD	imagerel ast_for_suite
	DD	imagerel ast_for_suite+83
	DD	imagerel $unwind$ast_for_suite
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_suite DD 061601H
	DD	0e0127216H
	DD	0c00ed010H
	DD	0300b700cH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_suite
_TEXT	SEGMENT
c$ = 112
n$ = 120
seq$1$ = 128
tv349 = 136
ast_for_suite PROC					; COMDAT

; 3053 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00016	48 8b d9	 mov	 rbx, rcx

; 3054 :     /* suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT */
; 3055 :     asdl_seq *seq;
; 3056 :     stmt_ty s;
; 3057 :     int i, total, num, end, pos = 0;

  00019	45 33 f6	 xor	 r14d, r14d

; 3058 :     node *ch;
; 3059 : 
; 3060 :     REQ(n, suite);
; 3061 : 
; 3062 :     total = num_stmts(n);

  0001c	48 8b ca	 mov	 rcx, rdx
  0001f	45 8b ee	 mov	 r13d, r14d
  00022	4c 8b e2	 mov	 r12, rdx
  00025	e8 00 00 00 00	 call	 num_stmts

; 3063 :     seq = asdl_seq_new(total, c->c_arena);

  0002a	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  0002e	48 63 c8	 movsxd	 rcx, eax
  00031	e8 00 00 00 00	 call	 asdl_seq_new
  00036	48 8b f8	 mov	 rdi, rax
  00039	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR seq$1$[rsp], rax

; 3064 :     if (!seq)

  00041	48 85 c0	 test	 rax, rax
  00044	75 0d		 jne	 SHORT $LN19@ast_for_su

; 3115 : }

  00046	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0004a	41 5e		 pop	 r14
  0004c	41 5d		 pop	 r13
  0004e	41 5c		 pop	 r12
  00050	5f		 pop	 rdi
  00051	5b		 pop	 rbx
  00052	c3		 ret	 0
$LN19@ast_for_su:
  00053	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp

; 3065 :         return NULL;
; 3066 :     if (TYPE(CHILD(n, 0)) == simple_stmt) {

  00058	49 8b 6c 24 20	 mov	 rbp, QWORD PTR [r12+32]
  0005d	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00062	b8 0d 01 00 00	 mov	 eax, 269		; 0000010dH
  00067	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  0006c	49 8b f6	 mov	 rsi, r14
  0006f	66 39 45 00	 cmp	 WORD PTR [rbp], ax
  00073	0f 85 8b 00 00
	00		 jne	 $LN18@ast_for_su

; 3067 :         n = CHILD(n, 0);
; 3068 :         /* simple_stmt always ends with a NEWLINE,
; 3069 :            and may have a trailing SEMI
; 3070 :         */
; 3071 :         end = NCH(n) - 1;

  00079	8b 7d 18	 mov	 edi, DWORD PTR [rbp+24]
  0007c	ff cf		 dec	 edi

; 3072 :         if (TYPE(CHILD(n, end - 1)) == SEMI)

  0007e	48 63 c7	 movsxd	 rax, edi
  00081	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00085	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  00089	66 83 7c c8 d8
	0d		 cmp	 WORD PTR [rax+rcx*8-40], 13
  0008f	75 02		 jne	 SHORT $LN17@ast_for_su

; 3073 :             end--;

  00091	ff cf		 dec	 edi
$LN17@ast_for_su:

; 3074 :         /* loop by 2 to skip semi-colons */
; 3075 :         for (i = 0; i < end; i += 2) {

  00093	85 ff		 test	 edi, edi
  00095	7e 49		 jle	 SHORT $LN32@ast_for_su
  00097	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR seq$1$[rsp]
  0009f	48 8b 74 24 70	 mov	 rsi, QWORD PTR c$[rsp]
  000a4	48 83 c3 08	 add	 rbx, 8
  000a8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL16@ast_for_su:

; 3076 :             ch = CHILD(n, i);

  000b0	49 63 c6	 movsxd	 rax, r14d
  000b3	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  000b7	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  000bb	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]

; 3077 :             s = ast_for_stmt(c, ch);

  000bf	48 8b ce	 mov	 rcx, rsi
  000c2	e8 00 00 00 00	 call	 ast_for_stmt

; 3078 :             if (!s)

  000c7	48 85 c0	 test	 rax, rax
  000ca	0f 84 30 01 00
	00		 je	 $LN27@ast_for_su

; 3079 :                 return NULL;
; 3080 :             asdl_seq_SET(seq, pos++, s);

  000d0	41 83 c6 02	 add	 r14d, 2
  000d4	48 89 03	 mov	 QWORD PTR [rbx], rax
  000d7	48 83 c3 08	 add	 rbx, 8
  000db	44 3b f7	 cmp	 r14d, edi
  000de	7c d0		 jl	 SHORT $LL16@ast_for_su
$LN32@ast_for_su:

; 3109 :                 }
; 3110 :             }
; 3111 :         }
; 3112 :     }
; 3113 :     assert(pos == seq->size);
; 3114 :     return seq;

  000e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR seq$1$[rsp]
$LN38@ast_for_su:
  000e8	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000ed	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000f2	4c 8b 7c 24 28	 mov	 r15, QWORD PTR [rsp+40]

; 3115 : }

  000f7	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000fb	41 5e		 pop	 r14
  000fd	41 5d		 pop	 r13
  000ff	41 5c		 pop	 r12
  00101	5f		 pop	 rdi
  00102	5b		 pop	 rbx
  00103	c3		 ret	 0
$LN18@ast_for_su:

; 3081 :         }
; 3082 :     }
; 3083 :     else {
; 3084 :         for (i = 2; i < (NCH(n) - 1); i++) {

  00104	41 8b 44 24 18	 mov	 eax, DWORD PTR [r12+24]
  00109	41 bf 02 00 00
	00		 mov	 r15d, 2
  0010f	ff c8		 dec	 eax
  00111	41 3b c7	 cmp	 eax, r15d
  00114	7e ca		 jle	 SHORT $LN32@ast_for_su
  00116	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  0011b	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR tv349[rsp], rcx
$LL11@ast_for_su:

; 3085 :             ch = CHILD(n, i);

  00123	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  00128	4c 8d 24 01	 lea	 r12, QWORD PTR [rcx+rax]

; 3086 :             REQ(ch, stmt);
; 3087 :             num = num_stmts(ch);

  0012c	49 8b cc	 mov	 rcx, r12
  0012f	e8 00 00 00 00	 call	 num_stmts

; 3088 :             if (num == 1) {

  00134	83 f8 01	 cmp	 eax, 1
  00137	75 21		 jne	 SHORT $LN8@ast_for_su

; 3089 :                 /* small_stmt or compound_stmt with only one child */
; 3090 :                 s = ast_for_stmt(c, ch);

  00139	49 8b d4	 mov	 rdx, r12
  0013c	48 8b cb	 mov	 rcx, rbx
  0013f	e8 00 00 00 00	 call	 ast_for_stmt

; 3091 :                 if (!s)

  00144	48 85 c0	 test	 rax, rax
  00147	0f 84 b3 00 00
	00		 je	 $LN27@ast_for_su

; 3092 :                     return NULL;
; 3093 :                 asdl_seq_SET(seq, pos++, s);

  0014d	48 89 44 f7 08	 mov	 QWORD PTR [rdi+rsi*8+8], rax
  00152	41 ff c5	 inc	 r13d
  00155	48 ff c6	 inc	 rsi

; 3094 :             }
; 3095 :             else {

  00158	eb 75		 jmp	 SHORT $LN10@ast_for_su
$LN8@ast_for_su:

; 3096 :                 int j;
; 3097 :                 ch = CHILD(ch, 0);

  0015a	4d 8b 64 24 20	 mov	 r12, QWORD PTR [r12+32]

; 3098 :                 REQ(ch, simple_stmt);
; 3099 :                 for (j = 0; j < NCH(ch); j += 2) {

  0015f	41 8b de	 mov	 ebx, r14d
  00162	41 39 5c 24 18	 cmp	 DWORD PTR [r12+24], ebx
  00167	7e 61		 jle	 SHORT $LN33@ast_for_su

; 3096 :                 int j;
; 3097 :                 ch = CHILD(ch, 0);

  00169	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR seq$1$[rsp]
  00171	49 8b fe	 mov	 rdi, r14
  00174	48 8d 6c f0 08	 lea	 rbp, QWORD PTR [rax+rsi*8+8]
  00179	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@ast_for_su:

; 3100 :                     /* statement terminates with a semi-colon ';' */
; 3101 :                     if (NCH(CHILD(ch, j)) == 0) {

  00180	49 8b 54 24 20	 mov	 rdx, QWORD PTR [r12+32]
  00185	44 39 74 17 18	 cmp	 DWORD PTR [rdi+rdx+24], r14d
  0018a	74 36		 je	 SHORT $LN35@ast_for_su

; 3102 :                         assert((j + 1) == NCH(ch));
; 3103 :                         break;
; 3104 :                     }
; 3105 :                     s = ast_for_stmt(c, CHILD(ch, j));

  0018c	48 63 c3	 movsxd	 rax, ebx
  0018f	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00193	48 8d 14 ca	 lea	 rdx, QWORD PTR [rdx+rcx*8]
  00197	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0019c	e8 00 00 00 00	 call	 ast_for_stmt

; 3106 :                     if (!s)

  001a1	48 85 c0	 test	 rax, rax
  001a4	74 5a		 je	 SHORT $LN27@ast_for_su

; 3108 :                     asdl_seq_SET(seq, pos++, s);

  001a6	48 89 45 00	 mov	 QWORD PTR [rbp], rax
  001aa	83 c3 02	 add	 ebx, 2
  001ad	41 ff c5	 inc	 r13d
  001b0	48 ff c6	 inc	 rsi
  001b3	48 83 c5 08	 add	 rbp, 8
  001b7	48 83 c7 50	 add	 rdi, 80			; 00000050H
  001bb	41 3b 5c 24 18	 cmp	 ebx, DWORD PTR [r12+24]
  001c0	7c be		 jl	 SHORT $LL5@ast_for_su
$LN35@ast_for_su:

; 3053 : {

  001c2	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR seq$1$[rsp]
$LN33@ast_for_su:
  001ca	48 8b 5c 24 70	 mov	 rbx, QWORD PTR c$[rsp]
$LN10@ast_for_su:

; 3081 :         }
; 3082 :     }
; 3083 :     else {
; 3084 :         for (i = 2; i < (NCH(n) - 1); i++) {

  001cf	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv349[rsp]
  001d7	4c 8b 64 24 78	 mov	 r12, QWORD PTR n$[rsp]
  001dc	41 ff c7	 inc	 r15d
  001df	41 8b 44 24 18	 mov	 eax, DWORD PTR [r12+24]
  001e4	48 83 c1 28	 add	 rcx, 40			; 00000028H
  001e8	ff c8		 dec	 eax
  001ea	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR tv349[rsp], rcx
  001f2	44 3b f8	 cmp	 r15d, eax
  001f5	0f 8c 28 ff ff
	ff		 jl	 $LL11@ast_for_su
  001fb	e9 e0 fe ff ff	 jmp	 $LN32@ast_for_su
$LN27@ast_for_su:

; 3107 :                         return NULL;

  00200	33 c0		 xor	 eax, eax
  00202	e9 e1 fe ff ff	 jmp	 $LN38@ast_for_su
ast_for_suite ENDP
_TEXT	ENDS
EXTRN	_Py_For:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_for_stmt DD imagerel ast_for_for_stmt
	DD	imagerel ast_for_for_stmt+112
	DD	imagerel $unwind$ast_for_for_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ast_for_for_stmt DD imagerel ast_for_for_stmt+112
	DD	imagerel ast_for_for_stmt+252
	DD	imagerel $chain$1$ast_for_for_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ast_for_for_stmt DD imagerel ast_for_for_stmt+252
	DD	imagerel ast_for_for_stmt+273
	DD	imagerel $chain$2$ast_for_for_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ast_for_for_stmt DD 021H
	DD	imagerel ast_for_for_stmt
	DD	imagerel ast_for_for_stmt+112
	DD	imagerel $unwind$ast_for_for_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ast_for_for_stmt DD 020521H
	DD	0bc405H
	DD	imagerel ast_for_for_stmt
	DD	imagerel ast_for_for_stmt+112
	DD	imagerel $unwind$ast_for_for_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_for_stmt DD 084a01H
	DD	0a644aH
	DD	0d540fH
	DD	0c340fH
	DD	0700b720fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_for_stmt
_TEXT	SEGMENT
c$ = 80
n$ = 88
ast_for_for_stmt PROC					; COMDAT

; 3280 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 3281 :     asdl_seq *_target, *seq = NULL, *suite_seq;

  0000f	33 ed		 xor	 ebp, ebp

; 3282 :     expr_ty expression;
; 3283 :     expr_ty target, first;
; 3284 :     const node *node_target;
; 3285 :     /* for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite] */
; 3286 :     REQ(n, for_stmt);
; 3287 : 
; 3288 :     if (NCH(n) == 9) {

  00011	83 7a 18 09	 cmp	 DWORD PTR [rdx+24], 9
  00015	48 8b da	 mov	 rbx, rdx
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	75 28		 jne	 SHORT $LN6@ast_for_fo

; 3289 :         seq = ast_for_suite(c, CHILD(n, 8));

  0001d	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00021	48 81 c2 40 01
	00 00		 add	 rdx, 320		; 00000140H
  00028	e8 00 00 00 00	 call	 ast_for_suite
  0002d	48 8b e8	 mov	 rbp, rax

; 3290 :         if (!seq)

  00030	48 85 c0	 test	 rax, rax
  00033	75 10		 jne	 SHORT $LN6@ast_for_fo

; 3315 : }

  00035	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0003a	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  0003f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
$LN6@ast_for_fo:
  00045	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi

; 3291 :             return NULL;
; 3292 :     }
; 3293 : 
; 3294 :     node_target = CHILD(n, 1);

  0004a	48 8b 73 20	 mov	 rsi, QWORD PTR [rbx+32]

; 3295 :     _target = ast_for_exprlist(c, node_target, Store);

  0004e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00054	48 8d 56 28	 lea	 rdx, QWORD PTR [rsi+40]
  00058	48 8b cf	 mov	 rcx, rdi
  0005b	e8 00 00 00 00	 call	 ast_for_exprlist
  00060	48 8b c8	 mov	 rcx, rax

; 3296 :     if (!_target)

  00063	48 85 c0	 test	 rax, rax
  00066	0f 84 90 00 00
	00		 je	 $LN10@ast_for_fo
$LN5@ast_for_fo:

; 3297 :         return NULL;
; 3298 :     /* Check the # of children rather than the length of _target, since
; 3299 :        for x, in ... has 1 element in _target, but still requires a Tuple. */
; 3300 :     first = (expr_ty)asdl_seq_GET(_target, 0);
; 3301 :     if (NCH(node_target) == 1)

  0006c	83 7e 40 01	 cmp	 DWORD PTR [rsi+64], 1
  00070	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12
  00075	4c 8b 60 08	 mov	 r12, QWORD PTR [rax+8]
  00079	74 20		 je	 SHORT $LN3@ast_for_fo

; 3302 :         target = first;
; 3303 :     else
; 3304 :         target = Tuple(_target, Store, first->lineno, first->col_offset, c->c_arena);

  0007b	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  0007f	45 8b 4c 24 34	 mov	 r9d, DWORD PTR [r12+52]
  00084	45 8b 44 24 30	 mov	 r8d, DWORD PTR [r12+48]
  00089	ba 02 00 00 00	 mov	 edx, 2
  0008e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00093	e8 00 00 00 00	 call	 _Py_Tuple
  00098	4c 8b e0	 mov	 r12, rax
$LN3@ast_for_fo:

; 3305 : 
; 3306 :     expression = ast_for_testlist(c, CHILD(n, 3));

  0009b	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  0009f	48 8b cf	 mov	 rcx, rdi
  000a2	48 83 c2 78	 add	 rdx, 120		; 00000078H
  000a6	e8 00 00 00 00	 call	 ast_for_testlist
  000ab	48 8b f0	 mov	 rsi, rax

; 3307 :     if (!expression)

  000ae	48 85 c0	 test	 rax, rax

; 3308 :         return NULL;

  000b1	74 1b		 je	 SHORT $LN12@ast_for_fo

; 3309 :     suite_seq = ast_for_suite(c, CHILD(n, 5));

  000b3	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  000b7	48 8b cf	 mov	 rcx, rdi
  000ba	48 81 c2 c8 00
	00 00		 add	 rdx, 200		; 000000c8H
  000c1	e8 00 00 00 00	 call	 ast_for_suite
  000c6	4c 8b c0	 mov	 r8, rax

; 3310 :     if (!suite_seq)

  000c9	48 85 c0	 test	 rax, rax
  000cc	75 04		 jne	 SHORT $LN1@ast_for_fo
$LN12@ast_for_fo:

; 3311 :         return NULL;

  000ce	33 c0		 xor	 eax, eax
  000d0	eb 25		 jmp	 SHORT $LN11@ast_for_fo
$LN1@ast_for_fo:

; 3312 : 
; 3313 :     return For(target, expression, suite_seq, seq, LINENO(n), n->n_col_offset,
; 3314 :                c->c_arena);

  000d2	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  000d6	4c 8b cd	 mov	 r9, rbp
  000d9	48 8b d6	 mov	 rdx, rsi
  000dc	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000e1	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  000e4	49 8b cc	 mov	 rcx, r12
  000e7	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000eb	8b 43 10	 mov	 eax, DWORD PTR [rbx+16]
  000ee	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000f2	e8 00 00 00 00	 call	 _Py_For
$LN11@ast_for_fo:
  000f7	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]
$LN10@ast_for_fo:
  000fc	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 3315 : }

  00101	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00106	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  0010b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0010f	5f		 pop	 rdi
  00110	c3		 ret	 0
ast_for_for_stmt ENDP
_TEXT	ENDS
PUBLIC	$T25842
PUBLIC	__real@bff0000000000000
EXTRN	PyFloat_FromDouble:PROC
EXTRN	PyComplex_FromCComplex:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyOS_string_to_double:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyOS_strtol:PROC
EXTRN	PyLong_FromString:PROC
EXTRN	PyOS_strtoul:PROC
EXTRN	__imp__errno:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$parsenumber DD imagerel parsenumber
	DD	imagerel parsenumber+306
	DD	imagerel $unwind$parsenumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$parsenumber DD imagerel parsenumber+306
	DD	imagerel parsenumber+376
	DD	imagerel $chain$0$parsenumber
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$parsenumber DD 020521H
	DD	036805H
	DD	imagerel parsenumber
	DD	imagerel parsenumber+306
	DD	imagerel $unwind$parsenumber
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parsenumber DD 060f01H
	DD	0c640fH
	DD	0b340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT parsenumber
_TEXT	SEGMENT
$T25842 = 32
compl$ = 32
end$ = 80
s$ = 80
parsenumber PROC					; COMDAT

; 3623 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b d9	 mov	 rbx, rcx

; 3624 :     const char *end;
; 3625 :     long x;
; 3626 :     double dx;
; 3627 :     Py_complex compl;
; 3628 :     int imflag;
; 3629 : 
; 3630 :     assert(s != NULL);
; 3631 :     errno = 0;

  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 3632 :     end = s + strlen(s) - 1;

  00018	48 83 c9 ff	 or	 rcx, -1
  0001c	33 f6		 xor	 esi, esi
  0001e	48 8b fb	 mov	 rdi, rbx
  00021	89 30		 mov	 DWORD PTR [rax], esi
  00023	33 c0		 xor	 eax, eax
  00025	f2 ae		 repne scasb
  00027	48 f7 d1	 not	 rcx
  0002a	48 ff c9	 dec	 rcx
  0002d	48 8d 44 19 ff	 lea	 rax, QWORD PTR [rcx+rbx-1]
  00032	48 89 44 24 50	 mov	 QWORD PTR end$[rsp], rax

; 3633 :     imflag = *end == 'j' || *end == 'J';

  00037	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0003a	80 f9 6a	 cmp	 cl, 106			; 0000006aH
  0003d	74 05		 je	 SHORT $LN12@parsenumbe
  0003f	80 f9 4a	 cmp	 cl, 74			; 0000004aH
  00042	75 05		 jne	 SHORT $LN13@parsenumbe
$LN12@parsenumbe:
  00044	be 01 00 00 00	 mov	 esi, 1
$LN13@parsenumbe:

; 3634 :     if (s[0] == '0') {
; 3635 :         x = (long) PyOS_strtoul((char *)s, (char **)&end, 0);

  00049	45 33 c0	 xor	 r8d, r8d
  0004c	80 3b 30	 cmp	 BYTE PTR [rbx], 48	; 00000030H
  0004f	48 8d 54 24 50	 lea	 rdx, QWORD PTR end$[rsp]
  00054	48 8b cb	 mov	 rcx, rbx
  00057	75 33		 jne	 SHORT $LN9@parsenumbe
  00059	e8 00 00 00 00	 call	 PyOS_strtoul
  0005e	8b f8		 mov	 edi, eax

; 3636 :         if (x < 0 && errno == 0) {

  00060	85 c0		 test	 eax, eax
  00062	79 2f		 jns	 SHORT $LN7@parsenumbe
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0006a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0006d	75 24		 jne	 SHORT $LN7@parsenumbe
$LN15@parsenumbe:

; 3637 :             return PyLong_FromString((char *)s,
; 3638 :                                      (char **)0,
; 3639 :                                      0);

  0006f	45 33 c0	 xor	 r8d, r8d
  00072	33 d2		 xor	 edx, edx
  00074	48 8b cb	 mov	 rcx, rbx
  00077	e8 00 00 00 00	 call	 PyLong_FromString

; 3663 :     }
; 3664 : }

  0007c	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00081	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00086	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0008a	5f		 pop	 rdi
  0008b	c3		 ret	 0
$LN9@parsenumbe:

; 3640 :         }
; 3641 :     }
; 3642 :     else
; 3643 :         x = PyOS_strtol((char *)s, (char **)&end, 0);

  0008c	e8 00 00 00 00	 call	 PyOS_strtol
  00091	8b f8		 mov	 edi, eax
$LN7@parsenumbe:

; 3644 :     if (*end == '\0') {

  00093	48 8b 44 24 50	 mov	 rax, QWORD PTR end$[rsp]
  00098	80 38 00	 cmp	 BYTE PTR [rax], 0
  0009b	75 22		 jne	 SHORT $LN6@parsenumbe

; 3645 :         if (errno != 0)

  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a3	83 38 00	 cmp	 DWORD PTR [rax], 0

; 3646 :             return PyLong_FromString((char *)s, (char **)0, 0);

  000a6	75 c7		 jne	 SHORT $LN15@parsenumbe

; 3647 :         return PyLong_FromLong(x);

  000a8	8b cf		 mov	 ecx, edi
  000aa	e8 00 00 00 00	 call	 PyLong_FromLong

; 3663 :     }
; 3664 : }

  000af	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000b4	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000b9	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000bd	5f		 pop	 rdi
  000be	c3		 ret	 0
$LN6@parsenumbe:

; 3648 :     }
; 3649 :     /* XXX Huge floats may silently fail */
; 3650 :     if (imflag) {
; 3651 :         compl.real = 0.;
; 3652 :         compl.imag = PyOS_string_to_double(s, (char **)&end, NULL);

  000bf	45 33 c0	 xor	 r8d, r8d
  000c2	48 8b cb	 mov	 rcx, rbx
  000c5	85 f6		 test	 esi, esi
  000c7	74 67		 je	 SHORT $LN4@parsenumbe
  000c9	66 0f 57 c0	 xorpd	 xmm0, xmm0
  000cd	48 8d 54 24 50	 lea	 rdx, QWORD PTR end$[rsp]
  000d2	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR compl$[rsp], xmm0
  000d8	e8 00 00 00 00	 call	 PyOS_string_to_double

; 3653 :         if (compl.imag == -1.0 && PyErr_Occurred())

  000dd	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  000e5	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR compl$[rsp+8], xmm0
  000eb	7a 1e		 jp	 SHORT $LN3@parsenumbe
  000ed	75 1c		 jne	 SHORT $LN3@parsenumbe
  000ef	e8 00 00 00 00	 call	 PyErr_Occurred
  000f4	48 85 c0	 test	 rax, rax
  000f7	74 12		 je	 SHORT $LN3@parsenumbe

; 3654 :             return NULL;

  000f9	33 c0		 xor	 eax, eax

; 3663 :     }
; 3664 : }

  000fb	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00100	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00105	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00109	5f		 pop	 rdi
  0010a	c3		 ret	 0
$LN3@parsenumbe:

; 3655 :         return PyComplex_FromCComplex(compl);

  0010b	0f 28 44 24 20	 movaps	 xmm0, XMMWORD PTR compl$[rsp]
  00110	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T25842[rsp]
  00115	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR $T25842[rsp], xmm0
  0011b	e8 00 00 00 00	 call	 PyComplex_FromCComplex

; 3663 :     }
; 3664 : }

  00120	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00125	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0012a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0012e	5f		 pop	 rdi
  0012f	c3		 ret	 0
$LN4@parsenumbe:

; 3656 :     }
; 3657 :     else
; 3658 :     {
; 3659 :         dx = PyOS_string_to_double(s, NULL, NULL);

  00130	33 d2		 xor	 edx, edx
  00132	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6
  00137	e8 00 00 00 00	 call	 PyOS_string_to_double

; 3660 :         if (dx == -1.0 && PyErr_Occurred())

  0013c	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00144	66 0f 28 f0	 movapd	 xmm6, xmm0
  00148	7a 10		 jp	 SHORT $LN1@parsenumbe
  0014a	75 0e		 jne	 SHORT $LN1@parsenumbe
  0014c	e8 00 00 00 00	 call	 PyErr_Occurred
  00151	48 85 c0	 test	 rax, rax
  00154	74 04		 je	 SHORT $LN1@parsenumbe

; 3661 :             return NULL;

  00156	33 c0		 xor	 eax, eax
  00158	eb 09		 jmp	 SHORT $LN14@parsenumbe
$LN1@parsenumbe:

; 3662 :         return PyFloat_FromDouble(dx);

  0015a	66 0f 28 c6	 movapd	 xmm0, xmm6
  0015e	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN14@parsenumbe:

; 3663 :     }
; 3664 : }

  00163	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  00168	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0016d	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00172	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00176	5f		 pop	 rdi
  00177	c3		 ret	 0
parsenumber ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT decode_utf8
_TEXT	SEGMENT
sPtr$ = 8
end$ = 16
decode_utf8 PROC					; COMDAT

; 3668 : {

  00000	48 8b c2	 mov	 rax, rdx

; 3669 :     char *s, *t;
; 3670 :     t = s = (char *)*sPtr;

  00003	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00006	4c 8b ca	 mov	 r9, rdx

; 3671 :     /* while (s < end && *s != '\\') s++; */ /* inefficient for u".." */
; 3672 :     while (s < end && (*s & 0x80)) s++;

  00009	48 3b d0	 cmp	 rdx, rax
  0000c	73 0f		 jae	 SHORT $LN1@decode_utf
  0000e	66 90		 npad	 2
$LL2@decode_utf:
  00010	f6 02 80	 test	 BYTE PTR [rdx], 128	; 00000080H
  00013	74 08		 je	 SHORT $LN1@decode_utf
  00015	48 ff c2	 inc	 rdx
  00018	48 3b d0	 cmp	 rdx, rax
  0001b	72 f3		 jb	 SHORT $LL2@decode_utf
$LN1@decode_utf:

; 3673 :     *sPtr = s;

  0001d	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 3674 :     return PyUnicode_DecodeUTF8(t, s - t, NULL);

  00020	45 33 c0	 xor	 r8d, r8d
  00023	49 2b d1	 sub	 rdx, r9
  00026	49 8b c9	 mov	 rcx, r9

; 3675 : }

  00029	e9 00 00 00 00	 jmp	 PyUnicode_DecodeUTF8
decode_utf8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_06OODBCFAF@?2U?$CF08x?$AA@		; `string'
PUBLIC	??_C@_05CIKIJNBG@u005c?$AA@			; `string'
EXTRN	PyUnicode_DecodeUnicodeEscape:PROC
EXTRN	PyUnicode_DecodeRawUnicodeEscape:PROC
EXTRN	PyBytes_AsString:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$decode_unicode DD imagerel decode_unicode
	DD	imagerel decode_unicode+562
	DD	imagerel $unwind$decode_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$decode_unicode DD 0a1e01H
	DD	0f341eH
	DD	0f01a521eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
xdata	ENDS
;	COMDAT ??_C@_06OODBCFAF@?2U?$CF08x?$AA@
CONST	SEGMENT
??_C@_06OODBCFAF@?2U?$CF08x?$AA@ DB '\U%08x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CIKIJNBG@u005c?$AA@
CONST	SEGMENT
??_C@_05CIKIJNBG@u005c?$AA@ DB 'u005c', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ast.c
CONST	ENDS
;	COMDAT decode_unicode
_TEXT	SEGMENT
s$ = 112
len$ = 120
rawmode$ = 128
buf$1$ = 136
encoding$ = 136
decode_unicode PROC					; COMDAT

; 3679 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 54		 push	 r12
  00014	41 55		 push	 r13
  00016	41 56		 push	 r14
  00018	41 57		 push	 r15
  0001a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001e	41 8b e8	 mov	 ebp, r8d
  00021	48 8b fa	 mov	 rdi, rdx
  00024	48 8b d9	 mov	 rbx, rcx

; 3680 :     PyObject *v, *u;
; 3681 :     char *buf;
; 3682 :     char *p;
; 3683 :     const char *end;
; 3684 : 
; 3685 :     if (encoding == NULL) {

  00027	4d 85 c9	 test	 r9, r9
  0002a	75 08		 jne	 SHORT $LN20@decode_uni

; 3686 :         u = NULL;

  0002c	45 33 ed	 xor	 r13d, r13d

; 3687 :     } else {

  0002f	e9 54 01 00 00	 jmp	 $LN19@decode_uni
$LN20@decode_uni:

; 3688 :         /* check for integer overflow */
; 3689 :         if (len > PY_SIZE_MAX / 6)

  00034	48 b8 aa aa aa
	aa aa aa aa 2a	 mov	 rax, 3074457345618258602 ; 2aaaaaaaaaaaaaaaH
  0003e	48 3b d0	 cmp	 rdx, rax

; 3690 :             return NULL;

  00041	0f 87 5d 01 00
	00		 ja	 $LN49@decode_uni

; 3691 :         /* "" (2 bytes) may become "\U000000E4" (10 bytes), or 1:5
; 3692 :            "\" (3 bytes) may become "\u005c\U000000E4" (16 bytes), or ~1:6 */
; 3693 :         u = PyBytes_FromStringAndSize((char *)NULL, len * 6);

  00047	48 8d 14 52	 lea	 rdx, QWORD PTR [rdx+rdx*2]
  0004b	33 c9		 xor	 ecx, ecx
  0004d	48 03 d2	 add	 rdx, rdx
  00050	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00055	4c 8b e8	 mov	 r13, rax

; 3694 :         if (u == NULL)

  00058	48 85 c0	 test	 rax, rax

; 3695 :             return NULL;

  0005b	0f 84 43 01 00
	00		 je	 $LN49@decode_uni

; 3696 :         p = buf = PyBytes_AsString(u);

  00061	48 8b c8	 mov	 rcx, rax
  00064	e8 00 00 00 00	 call	 PyBytes_AsString

; 3697 :         end = s + len;

  00069	4c 8d 3c 3b	 lea	 r15, QWORD PTR [rbx+rdi]
  0006d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR buf$1$[rsp], rax
  00075	48 8b f0	 mov	 rsi, rax

; 3698 :         while (s < end) {

  00078	49 3b df	 cmp	 rbx, r15
  0007b	0f 83 fe 00 00
	00		 jae	 $LN46@decode_uni
$LL16@decode_uni:

; 3699 :             if (*s == '\\') {

  00081	80 3b 5c	 cmp	 BYTE PTR [rbx], 92	; 0000005cH
  00084	75 2b		 jne	 SHORT $LN13@decode_uni

; 3700 :                 *p++ = *s++;

  00086	48 ff c3	 inc	 rbx
  00089	c6 06 5c	 mov	 BYTE PTR [rsi], 92	; 0000005cH
  0008c	48 ff c6	 inc	 rsi

; 3701 :                 if (*s & 0x80) {

  0008f	f6 03 80	 test	 BYTE PTR [rbx], 128	; 00000080H
  00092	48 89 5c 24 70	 mov	 QWORD PTR s$[rsp], rbx
  00097	74 18		 je	 SHORT $LN13@decode_uni

; 3702 :                     strcpy(p, "u005c");

  00099	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_05CIKIJNBG@u005c?$AA@

; 3703 :                     p += 5;

  0009f	48 83 c6 05	 add	 rsi, 5
  000a3	89 46 fb	 mov	 DWORD PTR [rsi-5], eax
  000a6	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05CIKIJNBG@u005c?$AA@+4
  000ad	66 89 46 ff	 mov	 WORD PTR [rsi-1], ax
$LN13@decode_uni:

; 3704 :                 }
; 3705 :             }
; 3706 :             if (*s & 0x80) { /* XXX inefficient */

  000b1	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000b4	84 c0		 test	 al, al
  000b6	0f 89 9e 00 00
	00		 jns	 $LN12@decode_uni

; 3707 :                 PyObject *w;
; 3708 :                 int kind;
; 3709 :                 void *data;
; 3710 :                 Py_ssize_t len, i;
; 3711 :                 w = decode_utf8(c, &s, end);

  000bc	48 8d 4c 24 70	 lea	 rcx, QWORD PTR s$[rsp]
  000c1	49 8b d7	 mov	 rdx, r15
  000c4	e8 00 00 00 00	 call	 decode_utf8
  000c9	4c 8b e0	 mov	 r12, rax

; 3712 :                 if (w == NULL) {

  000cc	48 85 c0	 test	 rax, rax
  000cf	0f 84 c7 00 00
	00		 je	 $LN44@decode_uni

; 3715 :                 }
; 3716 :                 kind = PyUnicode_KIND(w);

  000d5	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  000d8	8b d1		 mov	 edx, ecx
  000da	c1 ea 02	 shr	 edx, 2
  000dd	83 e2 07	 and	 edx, 7

; 3717 :                 data = PyUnicode_DATA(w);

  000e0	f6 c1 20	 test	 cl, 32			; 00000020H
  000e3	74 17		 je	 SHORT $LN25@decode_uni
  000e5	f6 c1 40	 test	 cl, 64			; 00000040H
  000e8	74 09		 je	 SHORT $LN23@decode_uni
  000ea	48 8d b8 80 00
	00 00		 lea	 rdi, QWORD PTR [rax+128]
  000f1	eb 10		 jmp	 SHORT $LN26@decode_uni
$LN23@decode_uni:
  000f3	48 8d b8 a0 00
	00 00		 lea	 rdi, QWORD PTR [rax+160]
  000fa	eb 07		 jmp	 SHORT $LN26@decode_uni
$LN25@decode_uni:
  000fc	48 8b b8 a0 00
	00 00		 mov	 rdi, QWORD PTR [rax+160]
$LN26@decode_uni:

; 3718 :                 len = PyUnicode_GET_LENGTH(w);

  00103	4c 8b 70 60	 mov	 r14, QWORD PTR [rax+96]

; 3719 :                 for (i = 0; i < len; i++) {

  00107	33 db		 xor	 ebx, ebx

; 3720 :                     Py_UCS4 chr = PyUnicode_READ(kind, data, i);

  00109	48 63 ea	 movsxd	 rbp, edx
  0010c	4d 85 f6	 test	 r14, r14
  0010f	7e 3a		 jle	 SHORT $LN8@decode_uni
$LL10@decode_uni:
  00111	48 83 fd 01	 cmp	 rbp, 1
  00115	75 07		 jne	 SHORT $LN29@decode_uni
  00117	44 0f b6 04 3b	 movzx	 r8d, BYTE PTR [rbx+rdi]
  0011c	eb 11		 jmp	 SHORT $LN28@decode_uni
$LN29@decode_uni:
  0011e	48 83 fd 02	 cmp	 rbp, 2
  00122	75 07		 jne	 SHORT $LN27@decode_uni
  00124	44 0f b7 04 5f	 movzx	 r8d, WORD PTR [rdi+rbx*2]
  00129	eb 04		 jmp	 SHORT $LN28@decode_uni
$LN27@decode_uni:
  0012b	44 8b 04 9f	 mov	 r8d, DWORD PTR [rdi+rbx*4]
$LN28@decode_uni:

; 3721 :                     sprintf(p, "\\U%08x", chr);

  0012f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06OODBCFAF@?2U?$CF08x?$AA@
  00136	48 8b ce	 mov	 rcx, rsi
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf
  0013f	48 ff c3	 inc	 rbx

; 3722 :                     p += 10;

  00142	48 83 c6 0a	 add	 rsi, 10
  00146	49 3b de	 cmp	 rbx, r14
  00149	7c c6		 jl	 SHORT $LL10@decode_uni
$LN8@decode_uni:

; 3723 :                 }
; 3724 :                 /* Should be impossible to overflow */
; 3725 :                 assert(p - buf <= Py_SIZE(u));
; 3726 :                 Py_DECREF(w);

  0014b	49 8b cc	 mov	 rcx, r12
  0014e	e8 00 00 00 00	 call	 _Py_DecRef

; 3727 :             } else {

  00153	48 8b 5c 24 70	 mov	 rbx, QWORD PTR s$[rsp]
  00158	eb 0d		 jmp	 SHORT $LN7@decode_uni
$LN12@decode_uni:

; 3728 :                 *p++ = *s++;

  0015a	88 06		 mov	 BYTE PTR [rsi], al
  0015c	48 ff c6	 inc	 rsi
  0015f	48 ff c3	 inc	 rbx
  00162	48 89 5c 24 70	 mov	 QWORD PTR s$[rsp], rbx
$LN7@decode_uni:

; 3698 :         while (s < end) {

  00167	49 3b df	 cmp	 rbx, r15
  0016a	0f 82 11 ff ff
	ff		 jb	 $LL16@decode_uni

; 3696 :         p = buf = PyBytes_AsString(u);

  00170	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$1$[rsp]
  00178	8b ac 24 80 00
	00 00		 mov	 ebp, DWORD PTR rawmode$[rsp]
$LN46@decode_uni:

; 3729 :             }
; 3730 :         }
; 3731 :         len = p - buf;

  0017f	48 8b fe	 mov	 rdi, rsi

; 3732 :         s = buf;

  00182	48 8b d8	 mov	 rbx, rax
  00185	48 2b f8	 sub	 rdi, rax
$LN19@decode_uni:

; 3733 :     }
; 3734 :     if (rawmode)
; 3735 :         v = PyUnicode_DecodeRawUnicodeEscape(s, len, NULL);

  00188	45 33 c0	 xor	 r8d, r8d
  0018b	48 8b d7	 mov	 rdx, rdi
  0018e	48 8b cb	 mov	 rcx, rbx
  00191	85 ed		 test	 ebp, ebp
  00193	74 13		 je	 SHORT $LN6@decode_uni
  00195	e8 00 00 00 00	 call	 PyUnicode_DecodeRawUnicodeEscape

; 3736 :     else

  0019a	eb 11		 jmp	 SHORT $LN48@decode_uni
$LN44@decode_uni:

; 3713 :                     Py_DECREF(u);

  0019c	49 8b cd	 mov	 rcx, r13
  0019f	e8 00 00 00 00	 call	 _Py_DecRef
$LN49@decode_uni:

; 3714 :                     return NULL;

  001a4	33 c0		 xor	 eax, eax
  001a6	eb 75		 jmp	 SHORT $LN21@decode_uni
$LN6@decode_uni:

; 3737 :         v = PyUnicode_DecodeUnicodeEscape(s, len, NULL);

  001a8	e8 00 00 00 00	 call	 PyUnicode_DecodeUnicodeEscape
$LN48@decode_uni:
  001ad	48 8b d8	 mov	 rbx, rax

; 3738 :     Py_XDECREF(u);

  001b0	4d 85 ed	 test	 r13, r13
  001b3	74 65		 je	 SHORT $LN3@decode_uni
  001b5	e8 00 00 00 00	 call	 _Py_PXCTX
  001ba	85 c0		 test	 eax, eax
  001bc	75 5c		 jne	 SHORT $LN3@decode_uni
  001be	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  001c2	a8 20		 test	 al, 32			; 00000020H
  001c4	75 4c		 jne	 SHORT $LN35@decode_uni
  001c6	84 c0		 test	 al, al
  001c8	78 48		 js	 SHORT $LN35@decode_uni
  001ca	a8 02		 test	 al, 2
  001cc	75 4c		 jne	 SHORT $LN3@decode_uni
  001ce	49 ff 4d 50	 dec	 QWORD PTR [r13+80]
  001d2	75 46		 jne	 SHORT $LN3@decode_uni
  001d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001e2	4d 8b cd	 mov	 r9, r13
  001e5	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001eb	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001f3	e8 00 00 00 00	 call	 _PyParallel_Guard
  001f8	49 8b cd	 mov	 rcx, r13
  001fb	85 c0		 test	 eax, eax
  001fd	74 07		 je	 SHORT $LN40@decode_uni
  001ff	e8 00 00 00 00	 call	 _Px_Dealloc
  00204	eb 14		 jmp	 SHORT $LN3@decode_uni
$LN40@decode_uni:
  00206	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  0020a	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00210	eb 08		 jmp	 SHORT $LN3@decode_uni
$LN35@decode_uni:
  00212	49 8b cd	 mov	 rcx, r13
  00215	e8 00 00 00 00	 call	 Px_DecRef
$LN3@decode_uni:

; 3739 :     return v;

  0021a	48 8b c3	 mov	 rax, rbx
$LN21@decode_uni:

; 3740 : }

  0021d	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  00222	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00226	41 5f		 pop	 r15
  00228	41 5e		 pop	 r14
  0022a	41 5d		 pop	 r13
  0022c	41 5c		 pop	 r12
  0022e	5f		 pop	 rdi
  0022f	5e		 pop	 rsi
  00230	5d		 pop	 rbp
  00231	c3		 ret	 0
decode_unicode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@IOCBPCNE@bytes?5can?5only?5contain?5ASCII?5lit@ ; `string'
PUBLIC	??_C@_05CAMHEFLG@utf?98?$AA@			; `string'
PUBLIC	??_C@_0BM@LLDDPBAC@string?5to?5parse?5is?5too?5long?$AA@ ; `string'
EXTRN	PyUnicode_DecodeLatin1:PROC
EXTRN	PyUnicode_FromStringAndSize:PROC
EXTRN	PyUnicode_AsEncodedString:PROC
EXTRN	PyBytes_DecodeEscape:PROC
EXTRN	__imp_strchr:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	_PyErr_BadInternalCall:PROC
EXTRN	_Py_ctype_table:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$parsestr DD imagerel parsestr
	DD	imagerel parsestr+178
	DD	imagerel $unwind$parsestr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$parsestr DD imagerel parsestr+178
	DD	imagerel parsestr+651
	DD	imagerel $chain$1$parsestr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$parsestr DD imagerel parsestr+651
	DD	imagerel parsestr+672
	DD	imagerel $chain$2$parsestr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$parsestr DD 021H
	DD	imagerel parsestr
	DD	imagerel parsestr+178
	DD	imagerel $unwind$parsestr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$parsestr DD 040a21H
	DD	0b740aH
	DD	0a5405H
	DD	imagerel parsestr
	DD	imagerel parsestr+178
	DD	imagerel $unwind$parsestr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parsestr DD 081401H
	DD	0d6414H
	DD	0c3414H
	DD	0e0105214H
	DD	0c00cd00eH
xdata	ENDS
;	COMDAT ??_C@_0DB@IOCBPCNE@bytes?5can?5only?5contain?5ASCII?5lit@
CONST	SEGMENT
??_C@_0DB@IOCBPCNE@bytes?5can?5only?5contain?5ASCII?5lit@ DB 'bytes can o'
	DB	'nly contain ASCII literal characters.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CAMHEFLG@utf?98?$AA@
CONST	SEGMENT
??_C@_05CAMHEFLG@utf?98?$AA@ DB 'utf-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LLDDPBAC@string?5to?5parse?5is?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BM@LLDDPBAC@string?5to?5parse?5is?5too?5long?$AA@ DB 'string to pa'
	DB	'rse is too long', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT parsestr
_TEXT	SEGMENT
c$ = 80
n$ = 88
bytesmode$ = 96
parsestr PROC						; COMDAT

; 3748 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	41 54		 push	 r12
  0000c	41 55		 push	 r13
  0000e	41 56		 push	 r14
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3749 :     size_t len;
; 3750 :     const char *s = STR(n);

  00014	48 8b 5a 08	 mov	 rbx, QWORD PTR [rdx+8]

; 3751 :     int quote = Py_CHARMASK(*s);
; 3752 :     int rawmode = 0;

  00018	45 33 f6	 xor	 r14d, r14d
  0001b	48 8b f2	 mov	 rsi, rdx
  0001e	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  00021	4c 8b e9	 mov	 r13, rcx

; 3753 :     int need_encoding;
; 3754 :     if (Py_ISALPHA(quote)) {

  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0002b	f6 04 91 03	 test	 BYTE PTR [rcx+rdx*4], 3
  0002f	4d 8b e0	 mov	 r12, r8
  00032	45 8b c6	 mov	 r8d, r14d
  00035	74 52		 je	 SHORT $LN48@parsestr
$LL34@parsestr:

; 3755 :         while (!*bytesmode || !rawmode) {

  00037	45 39 34 24	 cmp	 DWORD PTR [r12], r14d
  0003b	74 05		 je	 SHORT $LN32@parsestr
  0003d	45 85 c0	 test	 r8d, r8d
  00040	75 47		 jne	 SHORT $LN48@parsestr
$LN32@parsestr:

; 3756 :             if (quote == 'b' || quote == 'B') {

  00042	83 fa 62	 cmp	 edx, 98			; 00000062H
  00045	74 31		 je	 SHORT $LN30@parsestr
  00047	83 fa 42	 cmp	 edx, 66			; 00000042H
  0004a	74 2c		 je	 SHORT $LN30@parsestr

; 3759 :             }
; 3760 :             else if (quote == 'u' || quote == 'U') {

  0004c	83 fa 75	 cmp	 edx, 117		; 00000075H
  0004f	74 1e		 je	 SHORT $LN27@parsestr
  00051	83 fa 55	 cmp	 edx, 85			; 00000055H
  00054	74 19		 je	 SHORT $LN27@parsestr

; 3762 :             }
; 3763 :             else if (quote == 'r' || quote == 'R') {

  00056	83 fa 72	 cmp	 edx, 114		; 00000072H
  00059	74 05		 je	 SHORT $LN24@parsestr
  0005b	83 fa 52	 cmp	 edx, 82			; 00000052H
  0005e	75 29		 jne	 SHORT $LN48@parsestr
$LN24@parsestr:

; 3764 :                 quote = *++s;

  00060	0f be 53 01	 movsx	 edx, BYTE PTR [rbx+1]
  00064	48 ff c3	 inc	 rbx

; 3765 :                 rawmode = 1;

  00067	41 b8 01 00 00
	00		 mov	 r8d, 1

; 3766 :             }
; 3767 :             else {

  0006d	eb c8		 jmp	 SHORT $LL34@parsestr
$LN27@parsestr:

; 3761 :                 quote = *++s;

  0006f	0f be 53 01	 movsx	 edx, BYTE PTR [rbx+1]
  00073	48 ff c3	 inc	 rbx
  00076	eb bf		 jmp	 SHORT $LL34@parsestr
$LN30@parsestr:

; 3757 :                 quote = *++s;

  00078	0f be 53 01	 movsx	 edx, BYTE PTR [rbx+1]
  0007c	48 ff c3	 inc	 rbx

; 3758 :                 *bytesmode = 1;

  0007f	41 c7 04 24 01
	00 00 00	 mov	 DWORD PTR [r12], 1

; 3768 :                 break;
; 3769 :             }
; 3770 :         }

  00087	eb ae		 jmp	 SHORT $LL34@parsestr
$LN48@parsestr:

; 3771 :     }
; 3772 :     if (quote != '\'' && quote != '\"') {

  00089	83 fa 27	 cmp	 edx, 39			; 00000027H
  0008c	74 1d		 je	 SHORT $LN22@parsestr
  0008e	83 fa 22	 cmp	 edx, 34			; 00000022H
  00091	74 18		 je	 SHORT $LN22@parsestr

; 3773 :         PyErr_BadInternalCall();

  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@DHFJPBFM@?4?4?2Python?2ast?4c?$AA@
  0009a	ba bd 0e 00 00	 mov	 edx, 3773		; 00000ebdH
  0009f	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 3774 :         return NULL;

  000a4	33 c0		 xor	 eax, eax
  000a6	e9 e0 01 00 00	 jmp	 $LN36@parsestr
$LN22@parsestr:

; 3775 :     }
; 3776 :     s++;
; 3777 :     len = strlen(s);

  000ab	48 83 c9 ff	 or	 rcx, -1
  000af	48 ff c3	 inc	 rbx
  000b2	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  000b7	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  000bc	33 c0		 xor	 eax, eax
  000be	48 8b fb	 mov	 rdi, rbx
  000c1	f2 ae		 repne scasb
  000c3	48 f7 d1	 not	 rcx
  000c6	48 ff c9	 dec	 rcx
  000c9	48 8b e9	 mov	 rbp, rcx

; 3778 :     if (len > INT_MAX) {

  000cc	48 81 f9 ff ff
	ff 7f		 cmp	 rcx, 2147483647		; 7fffffffH
  000d3	76 1a		 jbe	 SHORT $LN21@parsestr

; 3779 :         PyErr_SetString(PyExc_OverflowError,
; 3780 :                         "string to parse is too long");

  000d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@LLDDPBAC@string?5to?5parse?5is?5too?5long?$AA@
  000e3	e8 00 00 00 00	 call	 PyErr_SetString

; 3781 :         return NULL;

  000e8	33 c0		 xor	 eax, eax
  000ea	e9 92 01 00 00	 jmp	 $LN50@parsestr
$LN21@parsestr:

; 3782 :     }
; 3783 :     if (s[--len] != quote) {

  000ef	0f be 44 2b ff	 movsx	 eax, BYTE PTR [rbx+rbp-1]
  000f4	48 ff cd	 dec	 rbp
  000f7	3b c2		 cmp	 eax, edx
  000f9	74 18		 je	 SHORT $LN20@parsestr

; 3784 :         PyErr_BadInternalCall();

  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@DHFJPBFM@?4?4?2Python?2ast?4c?$AA@
  00102	ba c8 0e 00 00	 mov	 edx, 3784		; 00000ec8H
  00107	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 3785 :         return NULL;

  0010c	33 c0		 xor	 eax, eax
  0010e	e9 6e 01 00 00	 jmp	 $LN50@parsestr
$LN20@parsestr:

; 3786 :     }
; 3787 :     if (len >= 4 && s[0] == quote && s[1] == quote) {

  00113	48 83 fd 04	 cmp	 rbp, 4
  00117	72 41		 jb	 SHORT $LN18@parsestr
  00119	0f be 03	 movsx	 eax, BYTE PTR [rbx]
  0011c	3b c2		 cmp	 eax, edx
  0011e	75 3a		 jne	 SHORT $LN18@parsestr
  00120	0f be 43 01	 movsx	 eax, BYTE PTR [rbx+1]
  00124	3b c2		 cmp	 eax, edx
  00126	75 32		 jne	 SHORT $LN18@parsestr

; 3788 :         s += 2;
; 3789 :         len -= 2;
; 3790 :         if (s[--len] != quote || s[--len] != quote) {

  00128	0f be 44 2b ff	 movsx	 eax, BYTE PTR [rbx+rbp-1]
  0012d	48 83 c3 02	 add	 rbx, 2
  00131	3b c2		 cmp	 eax, edx
  00133	75 0d		 jne	 SHORT $LN17@parsestr
  00135	0f be 44 2b fc	 movsx	 eax, BYTE PTR [rbx+rbp-4]
  0013a	48 83 ed 04	 sub	 rbp, 4
  0013e	3b c2		 cmp	 eax, edx
  00140	74 18		 je	 SHORT $LN18@parsestr
$LN17@parsestr:

; 3791 :             PyErr_BadInternalCall();

  00142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@DHFJPBFM@?4?4?2Python?2ast?4c?$AA@
  00149	ba cf 0e 00 00	 mov	 edx, 3791		; 00000ecfH
  0014e	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 3792 :             return NULL;

  00153	33 c0		 xor	 eax, eax
  00155	e9 27 01 00 00	 jmp	 $LN50@parsestr
$LN18@parsestr:

; 3793 :         }
; 3794 :     }
; 3795 :     if (!*bytesmode && !rawmode) {

  0015a	41 8b 14 24	 mov	 edx, DWORD PTR [r12]
  0015e	85 d2		 test	 edx, edx
  00160	75 19		 jne	 SHORT $LN46@parsestr
  00162	45 85 c0	 test	 r8d, r8d
  00165	75 31		 jne	 SHORT $LN47@parsestr

; 3796 :         return decode_unicode(c, s, len, rawmode, c->c_encoding);

  00167	4d 8b 4d 00	 mov	 r9, QWORD PTR [r13]
  0016b	48 8b d5	 mov	 rdx, rbp
  0016e	48 8b cb	 mov	 rcx, rbx
  00171	e8 00 00 00 00	 call	 decode_unicode
  00176	e9 06 01 00 00	 jmp	 $LN50@parsestr
$LN46@parsestr:

; 3797 :     }
; 3798 :     if (*bytesmode) {
; 3799 :         /* Disallow non-ascii characters (but not escapes) */
; 3800 :         const char *ch;
; 3801 :         for (ch = s; *ch; ch++) {

  0017b	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  0017e	48 8b cb	 mov	 rcx, rbx
  00181	84 c0		 test	 al, al
  00183	74 0f		 je	 SHORT $LN12@parsestr
$LL14@parsestr:

; 3802 :             if (Py_CHARMASK(*ch) >= 0x80) {

  00185	3c 80		 cmp	 al, 128			; 00000080H
  00187	73 6d		 jae	 SHORT $LN44@parsestr

; 3797 :     }
; 3798 :     if (*bytesmode) {
; 3799 :         /* Disallow non-ascii characters (but not escapes) */
; 3800 :         const char *ch;
; 3801 :         for (ch = s; *ch; ch++) {

  00189	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0018d	48 ff c1	 inc	 rcx
  00190	84 c0		 test	 al, al
  00192	75 f1		 jne	 SHORT $LL14@parsestr
$LN12@parsestr:

; 3806 :             }
; 3807 :         }
; 3808 :     }
; 3809 :     need_encoding = (!*bytesmode && c->c_encoding != NULL &&
; 3810 :                      strcmp(c->c_encoding, "utf-8") != 0);

  00194	85 d2		 test	 edx, edx
  00196	75 1e		 jne	 SHORT $LN38@parsestr
$LN47@parsestr:
  00198	49 8b 75 00	 mov	 rsi, QWORD PTR [r13]
  0019c	48 85 f6	 test	 rsi, rsi
  0019f	74 15		 je	 SHORT $LN38@parsestr
  001a1	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  001a8	b9 06 00 00 00	 mov	 ecx, 6
  001ad	f3 a6		 repe cmpsb
  001af	bf 01 00 00 00	 mov	 edi, 1
  001b4	75 03		 jne	 SHORT $LN39@parsestr
$LN38@parsestr:
  001b6	41 8b fe	 mov	 edi, r14d
$LN39@parsestr:

; 3811 :     if (rawmode || strchr(s, '\\') == NULL) {

  001b9	45 85 c0	 test	 r8d, r8d
  001bc	75 4e		 jne	 SHORT $LN9@parsestr
  001be	41 8d 50 5c	 lea	 edx, QWORD PTR [r8+92]
  001c2	48 8b cb	 mov	 rcx, rbx
  001c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  001cb	48 85 c0	 test	 rax, rax
  001ce	74 3c		 je	 SHORT $LN9@parsestr

; 3825 :         }
; 3826 :     }
; 3827 :     return PyBytes_DecodeEscape(s, len, NULL, 1,
; 3828 :                                  need_encoding ? c->c_encoding : NULL);

  001d0	85 ff		 test	 edi, edi
  001d2	74 04		 je	 SHORT $LN40@parsestr
  001d4	4d 8b 75 00	 mov	 r14, QWORD PTR [r13]
$LN40@parsestr:
  001d8	41 b9 01 00 00
	00		 mov	 r9d, 1
  001de	45 33 c0	 xor	 r8d, r8d
  001e1	48 8b d5	 mov	 rdx, rbp
  001e4	48 8b cb	 mov	 rcx, rbx
  001e7	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  001ec	e8 00 00 00 00	 call	 PyBytes_DecodeEscape
  001f1	e9 8b 00 00 00	 jmp	 $LN50@parsestr
$LN44@parsestr:

; 3803 :                 ast_error(c, n, "bytes can only contain ASCII "
; 3804 :                           "literal characters.");

  001f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0DB@IOCBPCNE@bytes?5can?5only?5contain?5ASCII?5lit@
  001fd	48 8b d6	 mov	 rdx, rsi
  00200	49 8b cd	 mov	 rcx, r13
  00203	e8 00 00 00 00	 call	 ast_error

; 3805 :                 return NULL;

  00208	33 c0		 xor	 eax, eax
  0020a	eb 75		 jmp	 SHORT $LN50@parsestr
$LN9@parsestr:

; 3812 :         if (need_encoding) {
; 3813 :             PyObject *v, *u = PyUnicode_DecodeUTF8(s, len, NULL);

  0020c	48 8b d5	 mov	 rdx, rbp
  0020f	85 ff		 test	 edi, edi
  00211	74 38		 je	 SHORT $LN8@parsestr
  00213	45 33 c0	 xor	 r8d, r8d
  00216	48 8b cb	 mov	 rcx, rbx
  00219	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8
  0021e	48 8b f0	 mov	 rsi, rax

; 3814 :             if (u == NULL || !*bytesmode)

  00221	48 85 c0	 test	 rax, rax
  00224	74 5b		 je	 SHORT $LN50@parsestr
  00226	45 39 34 24	 cmp	 DWORD PTR [r12], r14d
  0022a	74 55		 je	 SHORT $LN50@parsestr

; 3815 :                 return u;
; 3816 :             v = PyUnicode_AsEncodedString(u, c->c_encoding, NULL);

  0022c	49 8b 55 00	 mov	 rdx, QWORD PTR [r13]
  00230	45 33 c0	 xor	 r8d, r8d
  00233	48 8b c8	 mov	 rcx, rax
  00236	e8 00 00 00 00	 call	 PyUnicode_AsEncodedString

; 3817 :             Py_DECREF(u);

  0023b	48 8b ce	 mov	 rcx, rsi
  0023e	48 8b f8	 mov	 rdi, rax
  00241	e8 00 00 00 00	 call	 _Py_DecRef

; 3818 :             return v;

  00246	48 8b c7	 mov	 rax, rdi
  00249	eb 36		 jmp	 SHORT $LN50@parsestr
$LN8@parsestr:

; 3819 :         } else if (*bytesmode) {

  0024b	45 39 34 24	 cmp	 DWORD PTR [r12], r14d
  0024f	74 0a		 je	 SHORT $LN4@parsestr

; 3820 :             return PyBytes_FromStringAndSize(s, len);

  00251	48 8b cb	 mov	 rcx, rbx
  00254	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00259	eb 26		 jmp	 SHORT $LN50@parsestr
$LN4@parsestr:

; 3821 :         } else if (strcmp(c->c_encoding, "utf-8") == 0) {

  0025b	49 8b 75 00	 mov	 rsi, QWORD PTR [r13]
  0025f	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  00266	b9 06 00 00 00	 mov	 ecx, 6
  0026b	f3 a6		 repe cmpsb

; 3822 :             return PyUnicode_FromStringAndSize(s, len);

  0026d	48 8b cb	 mov	 rcx, rbx
  00270	75 07		 jne	 SHORT $LN2@parsestr
  00272	e8 00 00 00 00	 call	 PyUnicode_FromStringAndSize
  00277	eb 08		 jmp	 SHORT $LN50@parsestr
$LN2@parsestr:

; 3823 :         } else {
; 3824 :             return PyUnicode_DecodeLatin1(s, len, NULL);

  00279	45 33 c0	 xor	 r8d, r8d
  0027c	e8 00 00 00 00	 call	 PyUnicode_DecodeLatin1
$LN50@parsestr:
  00281	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00286	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
$LN36@parsestr:

; 3829 : }

  0028b	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00290	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00295	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00299	41 5e		 pop	 r14
  0029b	41 5d		 pop	 r13
  0029d	41 5c		 pop	 r12
  0029f	c3		 ret	 0
parsestr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@HOOKFABC@cannot?5mix?5bytes?5and?5nonbytes?5li@ ; `string'
EXTRN	PyUnicode_Concat:PROC
EXTRN	PyBytes_ConcatAndDel:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$parsestrplus DD imagerel parsestrplus
	DD	imagerel parsestrplus+433
	DD	imagerel $unwind$parsestrplus
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parsestrplus DD 0a1601H
	DD	0e5416H
	DD	0c3416H
	DD	0e0125216H
	DD	0c00ed010H
	DD	0600b700cH
xdata	ENDS
;	COMDAT ??_C@_0CH@HOOKFABC@cannot?5mix?5bytes?5and?5nonbytes?5li@
CONST	SEGMENT
??_C@_0CH@HOOKFABC@cannot?5mix?5bytes?5and?5nonbytes?5li@ DB 'cannot mix '
	DB	'bytes and nonbytes literals', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ast.c
CONST	ENDS
;	COMDAT parsestrplus
_TEXT	SEGMENT
c$ = 96
subbm$24388 = 104
n$ = 104
bytesmode$ = 112
v$ = 120
parsestrplus PROC					; COMDAT

; 3837 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00016	48 8b ea	 mov	 rbp, rdx

; 3838 :     PyObject *v;
; 3839 :     int i;
; 3840 :     REQ(CHILD(n, 0), STRING);
; 3841 :     v = parsestr(c, CHILD(n, 0), bytesmode);

  00019	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  0001d	4d 8b e0	 mov	 r12, r8
  00020	4c 8b e9	 mov	 r13, rcx
  00023	e8 00 00 00 00	 call	 parsestr
  00028	48 8b f8	 mov	 rdi, rax
  0002b	48 89 44 24 78	 mov	 QWORD PTR v$[rsp], rax

; 3842 :     if (v != NULL) {

  00030	48 85 c0	 test	 rax, rax
  00033	0f 84 c4 00 00
	00		 je	 $LN11@parsestrpl

; 3843 :         /* String literal concatenation */
; 3844 :         for (i = 1; i < NCH(n); i++) {

  00039	bb 01 00 00 00	 mov	 ebx, 1
  0003e	39 5d 18	 cmp	 DWORD PTR [rbp+24], ebx
  00041	0f 8e b6 00 00
	00		 jle	 $LN11@parsestrpl
  00047	45 33 f6	 xor	 r14d, r14d
  0004a	66 0f 1f 44 00
	00		 npad	 6
$LL13@parsestrpl:

; 3845 :             PyObject *s;
; 3846 :             int subbm = 0;
; 3847 :             s = parsestr(c, CHILD(n, i), &subbm);

  00050	48 63 c3	 movsxd	 rax, ebx
  00053	4c 8d 44 24 68	 lea	 r8, QWORD PTR subbm$24388[rsp]
  00058	44 89 74 24 68	 mov	 DWORD PTR subbm$24388[rsp], r14d
  0005d	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00061	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  00065	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  00069	49 8b cd	 mov	 rcx, r13
  0006c	e8 00 00 00 00	 call	 parsestr
  00071	48 8b f0	 mov	 rsi, rax

; 3848 :             if (s == NULL)

  00074	48 85 c0	 test	 rax, rax
  00077	0f 84 b4 00 00
	00		 je	 $onError$24391

; 3849 :                 goto onError;
; 3850 :             if (*bytesmode != subbm) {

  0007d	8b 4c 24 68	 mov	 ecx, DWORD PTR subbm$24388[rsp]
  00081	41 39 0c 24	 cmp	 DWORD PTR [r12], ecx
  00085	0f 85 8c 00 00
	00		 jne	 $LN30@parsestrpl

; 3853 :                 goto onError;
; 3854 :             }
; 3855 :             if (PyBytes_Check(v) && PyBytes_Check(s)) {

  0008b	48 8b 44 24 78	 mov	 rax, QWORD PTR v$[rsp]
  00090	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00094	f7 81 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rcx+256], 134217728 ; 08000000H
  0009e	74 24		 je	 SHORT $LN8@parsestrpl
  000a0	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  000a4	f7 81 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rcx+256], 134217728 ; 08000000H
  000ae	74 14		 je	 SHORT $LN8@parsestrpl

; 3856 :                 PyBytes_ConcatAndDel(&v, s);

  000b0	48 8d 4c 24 78	 lea	 rcx, QWORD PTR v$[rsp]
  000b5	48 8b d6	 mov	 rdx, rsi
  000b8	e8 00 00 00 00	 call	 PyBytes_ConcatAndDel

; 3857 :                 if (v == NULL)

  000bd	48 8b 7c 24 78	 mov	 rdi, QWORD PTR v$[rsp]

; 3858 :                     goto onError;
; 3859 :             }
; 3860 :             else {

  000c2	eb 25		 jmp	 SHORT $LN35@parsestrpl
$LN8@parsestrpl:

; 3861 :                 PyObject *temp = PyUnicode_Concat(v, s);

  000c4	48 8b d6	 mov	 rdx, rsi
  000c7	48 8b c8	 mov	 rcx, rax
  000ca	e8 00 00 00 00	 call	 PyUnicode_Concat

; 3862 :                 Py_DECREF(s);

  000cf	48 8b ce	 mov	 rcx, rsi
  000d2	48 8b f8	 mov	 rdi, rax
  000d5	e8 00 00 00 00	 call	 _Py_DecRef

; 3863 :                 Py_DECREF(v);

  000da	48 8b 4c 24 78	 mov	 rcx, QWORD PTR v$[rsp]
  000df	e8 00 00 00 00	 call	 _Py_DecRef

; 3864 :                 v = temp;

  000e4	48 89 7c 24 78	 mov	 QWORD PTR v$[rsp], rdi
$LN35@parsestrpl:

; 3865 :                 if (v == NULL)

  000e9	48 85 ff	 test	 rdi, rdi
  000ec	0f 84 b8 00 00
	00		 je	 $LN3@parsestrpl

; 3843 :         /* String literal concatenation */
; 3844 :         for (i = 1; i < NCH(n); i++) {

  000f2	ff c3		 inc	 ebx
  000f4	3b 5d 18	 cmp	 ebx, DWORD PTR [rbp+24]
  000f7	0f 8c 53 ff ff
	ff		 jl	 $LL13@parsestrpl
$LN11@parsestrpl:

; 3866 :                     goto onError;
; 3867 :             }
; 3868 :         }
; 3869 :     }
; 3870 :     return v;

  000fd	48 8b c7	 mov	 rax, rdi
$LN15@parsestrpl:

; 3875 : }

  00100	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00105	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  0010a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010e	41 5e		 pop	 r14
  00110	41 5d		 pop	 r13
  00112	41 5c		 pop	 r12
  00114	5f		 pop	 rdi
  00115	5e		 pop	 rsi
  00116	c3		 ret	 0
$LN30@parsestrpl:

; 3851 :                 ast_error(c, n, "cannot mix bytes and nonbytes literals");

  00117	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CH@HOOKFABC@cannot?5mix?5bytes?5and?5nonbytes?5li@
  0011e	48 8b d5	 mov	 rdx, rbp
  00121	49 8b cd	 mov	 rcx, r13
  00124	e8 00 00 00 00	 call	 ast_error

; 3852 :                 Py_DECREF(s);

  00129	48 8b ce	 mov	 rcx, rsi
  0012c	e8 00 00 00 00	 call	 _Py_DecRef
$onError$24391:

; 3871 : 
; 3872 :   onError:
; 3873 :     Py_XDECREF(v);

  00131	48 8b 5c 24 78	 mov	 rbx, QWORD PTR v$[rsp]
  00136	48 85 db	 test	 rbx, rbx
  00139	74 6f		 je	 SHORT $LN3@parsestrpl
  0013b	e8 00 00 00 00	 call	 _Py_PXCTX
  00140	85 c0		 test	 eax, eax
  00142	75 66		 jne	 SHORT $LN3@parsestrpl
  00144	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00148	a8 20		 test	 al, 32			; 00000020H
  0014a	75 56		 jne	 SHORT $LN21@parsestrpl
  0014c	84 c0		 test	 al, al
  0014e	78 52		 js	 SHORT $LN21@parsestrpl
  00150	a8 02		 test	 al, 2
  00152	75 56		 jne	 SHORT $LN3@parsestrpl
  00154	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00158	75 50		 jne	 SHORT $LN3@parsestrpl
  0015a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00168	4c 8b cb	 mov	 r9, rbx
  0016b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00171	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00179	e8 00 00 00 00	 call	 _PyParallel_Guard
  0017e	48 8b cb	 mov	 rcx, rbx
  00181	85 c0		 test	 eax, eax
  00183	74 0c		 je	 SHORT $LN26@parsestrpl
  00185	e8 00 00 00 00	 call	 _Px_Dealloc

; 3874 :     return NULL;

  0018a	33 c0		 xor	 eax, eax
  0018c	e9 6f ff ff ff	 jmp	 $LN15@parsestrpl

; 3871 : 
; 3872 :   onError:
; 3873 :     Py_XDECREF(v);

$LN26@parsestrpl:
  00191	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00195	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 3874 :     return NULL;

  0019b	33 c0		 xor	 eax, eax
  0019d	e9 5e ff ff ff	 jmp	 $LN15@parsestrpl

; 3871 : 
; 3872 :   onError:
; 3873 :     Py_XDECREF(v);

$LN21@parsestrpl:
  001a2	48 8b cb	 mov	 rcx, rbx
  001a5	e8 00 00 00 00	 call	 Px_DecRef
$LN3@parsestrpl:

; 3874 :     return NULL;

  001aa	33 c0		 xor	 eax, eax
  001ac	e9 4f ff ff ff	 jmp	 $LN15@parsestrpl
parsestrplus ENDP
_TEXT	ENDS
PUBLIC	??_C@_04FHFMBDKA@dims?$AA@			; `string'
PUBLIC	??_C@_08CIIMGBAD@ExtSlice?$AA@			; `string'
PUBLIC	??_C@_0BD@PJEHJOKI@unknown?5slice?5node?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_slice DD imagerel validate_slice
	DD	imagerel validate_slice+116
	DD	imagerel $unwind$validate_slice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$validate_slice DD imagerel validate_slice+116
	DD	imagerel validate_slice+198
	DD	imagerel $chain$1$validate_slice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$validate_slice DD imagerel validate_slice+198
	DD	imagerel validate_slice+205
	DD	imagerel $chain$3$validate_slice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$validate_slice DD imagerel validate_slice+205
	DD	imagerel validate_slice+307
	DD	imagerel $chain$4$validate_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$validate_slice DD 021H
	DD	imagerel validate_slice
	DD	imagerel validate_slice+116
	DD	imagerel $unwind$validate_slice
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$validate_slice DD 040021H
	DD	076400H
	DD	063400H
	DD	imagerel validate_slice
	DD	imagerel validate_slice+116
	DD	imagerel $unwind$validate_slice
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$validate_slice DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel validate_slice
	DD	imagerel validate_slice+116
	DD	imagerel $unwind$validate_slice
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_slice DD 040a01H
	DD	08540aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_04FHFMBDKA@dims?$AA@
CONST	SEGMENT
??_C@_04FHFMBDKA@dims?$AA@ DB 'dims', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CIIMGBAD@ExtSlice?$AA@
CONST	SEGMENT
??_C@_08CIIMGBAD@ExtSlice?$AA@ DB 'ExtSlice', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJEHJOKI@unknown?5slice?5node?$AA@
CONST	SEGMENT
??_C@_0BD@PJEHJOKI@unknown?5slice?5node?$AA@ DB 'unknown slice node', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT validate_slice
_TEXT	SEGMENT
slice$ = 48
validate_slice PROC					; COMDAT

; 40   : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 41   :     switch (slice->kind) {

  0000a	8b 11		 mov	 edx, DWORD PTR [rcx]
  0000c	48 8b f9	 mov	 rdi, rcx
  0000f	ff ca		 dec	 edx
  00011	0f 84 b6 00 00
	00		 je	 $LN9@validate_s
  00017	ff ca		 dec	 edx
  00019	74 3c		 je	 SHORT $LN8@validate_s
  0001b	ff ca		 dec	 edx
  0001d	74 20		 je	 SHORT $LN2@validate_s

; 57   :     default:
; 58   :         PyErr_SetString(PyExc_SystemError, "unknown slice node");

  0001f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@PJEHJOKI@unknown?5slice?5node?$AA@
  0002d	e8 00 00 00 00	 call	 PyErr_SetString
$LN25@validate_s:

; 59   :         return 0;

  00032	33 c0		 xor	 eax, eax

; 60   :     }
; 61   : }

  00034	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
$LN2@validate_s:

; 54   :     }
; 55   :     case Index_kind:
; 56   :         return validate_expr(slice->v.Index.value, Load);

  0003f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00043	ba 01 00 00 00	 mov	 edx, 1

; 60   :     }
; 61   : }

  00048	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5f		 pop	 rdi
  00052	e9 00 00 00 00	 jmp	 validate_expr
$LN8@validate_s:

; 46   :     case ExtSlice_kind: {
; 47   :         int i;
; 48   :         if (!validate_nonempty_seq(slice->v.ExtSlice.dims, "dims", "ExtSlice"))

  00057	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0005b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08CIIMGBAD@ExtSlice?$AA@
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04FHFMBDKA@dims?$AA@
  00069	e8 00 00 00 00	 call	 validate_nonempty_seq
  0006e	85 c0		 test	 eax, eax

; 49   :             return 0;

  00070	74 c0		 je	 SHORT $LN25@validate_s

; 50   :         for (i = 0; i < asdl_seq_LEN(slice->v.ExtSlice.dims); i++)

  00072	33 ed		 xor	 ebp, ebp
  00074	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00079	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0007e	8b dd		 mov	 ebx, ebp
  00080	8b f5		 mov	 esi, ebp
$LL6@validate_s:
  00082	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00086	48 8b d5	 mov	 rdx, rbp
  00089	48 85 c9	 test	 rcx, rcx
  0008c	74 03		 je	 SHORT $LN20@validate_s
  0008e	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
$LN20@validate_s:
  00091	48 63 c3	 movsxd	 rax, ebx
  00094	48 3b c2	 cmp	 rax, rdx
  00097	7d 2d		 jge	 SHORT $LN4@validate_s

; 51   :             if (!validate_slice(asdl_seq_GET(slice->v.ExtSlice.dims, i)))

  00099	48 8b 4c 0e 08	 mov	 rcx, QWORD PTR [rsi+rcx+8]
  0009e	e8 00 00 00 00	 call	 validate_slice
  000a3	85 c0		 test	 eax, eax
  000a5	74 08		 je	 SHORT $LN22@validate_s

; 50   :         for (i = 0; i < asdl_seq_LEN(slice->v.ExtSlice.dims); i++)

  000a7	ff c3		 inc	 ebx
  000a9	48 83 c6 08	 add	 rsi, 8
  000ad	eb d3		 jmp	 SHORT $LL6@validate_s
$LN22@validate_s:

; 52   :                 return 0;

  000af	33 c0		 xor	 eax, eax
$LN24@validate_s:
  000b1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b6	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 60   :     }
; 61   : }

  000bb	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000c0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c4	5f		 pop	 rdi
  000c5	c3		 ret	 0
$LN4@validate_s:

; 53   :         return 1;

  000c6	b8 01 00 00 00	 mov	 eax, 1
  000cb	eb e4		 jmp	 SHORT $LN24@validate_s
$LN9@validate_s:

; 42   :     case Slice_kind:
; 43   :         return (!slice->v.Slice.lower || validate_expr(slice->v.Slice.lower, Load)) &&
; 44   :             (!slice->v.Slice.upper || validate_expr(slice->v.Slice.upper, Load)) &&
; 45   :             (!slice->v.Slice.step || validate_expr(slice->v.Slice.step, Load));

  000cd	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000d1	48 85 c9	 test	 rcx, rcx
  000d4	74 0e		 je	 SHORT $LN14@validate_s
  000d6	ba 01 00 00 00	 mov	 edx, 1
  000db	e8 00 00 00 00	 call	 validate_expr
  000e0	85 c0		 test	 eax, eax
  000e2	74 2e		 je	 SHORT $LN16@validate_s
$LN14@validate_s:
  000e4	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  000e8	48 85 c9	 test	 rcx, rcx
  000eb	74 0e		 je	 SHORT $LN15@validate_s
  000ed	ba 01 00 00 00	 mov	 edx, 1
  000f2	e8 00 00 00 00	 call	 validate_expr
  000f7	85 c0		 test	 eax, eax
  000f9	74 17		 je	 SHORT $LN16@validate_s
$LN15@validate_s:
  000fb	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  000ff	48 85 c9	 test	 rcx, rcx
  00102	74 1d		 je	 SHORT $LN17@validate_s
  00104	ba 01 00 00 00	 mov	 edx, 1
  00109	e8 00 00 00 00	 call	 validate_expr
  0010e	85 c0		 test	 eax, eax
  00110	75 0f		 jne	 SHORT $LN17@validate_s
$LN16@validate_s:
  00112	33 ed		 xor	 ebp, ebp
  00114	8b c5		 mov	 eax, ebp

; 60   :     }
; 61   : }

  00116	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0011b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011f	5f		 pop	 rdi
  00120	c3		 ret	 0
$LN17@validate_s:

; 42   :     case Slice_kind:
; 43   :         return (!slice->v.Slice.lower || validate_expr(slice->v.Slice.lower, Load)) &&
; 44   :             (!slice->v.Slice.upper || validate_expr(slice->v.Slice.upper, Load)) &&
; 45   :             (!slice->v.Slice.step || validate_expr(slice->v.Slice.step, Load));

  00121	bd 01 00 00 00	 mov	 ebp, 1
  00126	8b c5		 mov	 eax, ebp

; 60   :     }
; 61   : }

  00128	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0012d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00131	5f		 pop	 rdi
  00132	c3		 ret	 0
validate_slice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@FLEFGDAH@expression?5which?5can?8t?5be?5assign@ ; `string'
PUBLIC	??_C@_0BG@PAKLMHBH@unexpected?5expression?$AA@	; `string'
PUBLIC	??_C@_0BI@DPNNPPHI@non?9bytes?5type?5in?5Bytes?$AA@ ; `string'
PUBLIC	??_C@_0BH@JMHKCIPG@non?9string?5type?5in?5Str?$AA@ ; `string'
PUBLIC	??_C@_0BI@ECNBNEHA@non?9numeric?5type?5in?5Num?$AA@ ; `string'
PUBLIC	??_C@_0BM@HPPBDCNI@Compare?5with?5no?5comparators?$AA@ ; `string'
PUBLIC	??_C@_0DL@IEHCCJP@Compare?5has?5a?5different?5number?5o@ ; `string'
PUBLIC	??_C@_0DE@EGPJELGA@Dict?5doesn?8t?5have?5the?5same?5numbe@ ; `string'
PUBLIC	??_C@_0BP@DJACLLDP@BoolOp?5with?5less?5than?52?5values?$AA@ ; `string'
PUBLIC	??_C@_0DD@JOHDCPHG@expression?5must?5have?5?$CFs?5context?5@ ; `string'
EXTRN	PyBytes_Type:BYTE
EXTRN	PyUnicode_Type:BYTE
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyComplex_Type:BYTE
EXTRN	PyFloat_Type:BYTE
EXTRN	PyLong_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_expr DD imagerel validate_expr
	DD	imagerel validate_expr+1636
	DD	imagerel $unwind$validate_expr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_expr DD 062101H
	DD	066421H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0DE@FLEFGDAH@expression?5which?5can?8t?5be?5assign@
CONST	SEGMENT
??_C@_0DE@FLEFGDAH@expression?5which?5can?8t?5be?5assign@ DB 'expression '
	DB	'which can''t be assigned to in %s context', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PAKLMHBH@unexpected?5expression?$AA@
CONST	SEGMENT
??_C@_0BG@PAKLMHBH@unexpected?5expression?$AA@ DB 'unexpected expression', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DPNNPPHI@non?9bytes?5type?5in?5Bytes?$AA@
CONST	SEGMENT
??_C@_0BI@DPNNPPHI@non?9bytes?5type?5in?5Bytes?$AA@ DB 'non-bytes type in'
	DB	' Bytes', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JMHKCIPG@non?9string?5type?5in?5Str?$AA@
CONST	SEGMENT
??_C@_0BH@JMHKCIPG@non?9string?5type?5in?5Str?$AA@ DB 'non-string type in'
	DB	' Str', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ECNBNEHA@non?9numeric?5type?5in?5Num?$AA@
CONST	SEGMENT
??_C@_0BI@ECNBNEHA@non?9numeric?5type?5in?5Num?$AA@ DB 'non-numeric type '
	DB	'in Num', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HPPBDCNI@Compare?5with?5no?5comparators?$AA@
CONST	SEGMENT
??_C@_0BM@HPPBDCNI@Compare?5with?5no?5comparators?$AA@ DB 'Compare with n'
	DB	'o comparators', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@IEHCCJP@Compare?5has?5a?5different?5number?5o@
CONST	SEGMENT
??_C@_0DL@IEHCCJP@Compare?5has?5a?5different?5number?5o@ DB 'Compare has '
	DB	'a different number of comparators and operands', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@EGPJELGA@Dict?5doesn?8t?5have?5the?5same?5numbe@
CONST	SEGMENT
??_C@_0DE@EGPJELGA@Dict?5doesn?8t?5have?5the?5same?5numbe@ DB 'Dict doesn'
	DB	'''t have the same number of keys as values', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJACLLDP@BoolOp?5with?5less?5than?52?5values?$AA@
CONST	SEGMENT
??_C@_0BP@DJACLLDP@BoolOp?5with?5less?5than?52?5values?$AA@ DB 'BoolOp wi'
	DB	'th less than 2 values', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JOHDCPHG@expression?5must?5have?5?$CFs?5context?5@
CONST	SEGMENT
??_C@_0DD@JOHDCPHG@expression?5must?5have?5?$CFs?5context?5@ DB 'expressi'
	DB	'on must have %s context but has %s instead', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT validate_expr
_TEXT	SEGMENT
exp$ = 48
ctx$ = 56
validate_expr PROC					; COMDAT

; 144  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	44 8b d2	 mov	 r10d, edx
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00017	bb 01 00 00 00	 mov	 ebx, 1
  0001c	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
$LL86@validate_e:

; 145  :     int check_ctx = 1;
; 146  :     expr_context_ty actual_ctx;
; 147  : 
; 148  :     /* First check expression context. */
; 149  :     switch (exp->kind) {

  00021	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00023	8d 41 ec	 lea	 eax, DWORD PTR [rcx-20]
  00026	83 f8 05	 cmp	 eax, 5
  00029	77 56		 ja	 SHORT $LN37@validate_e
  0002b	48 98		 cdqe
  0002d	41 8b 94 80 00
	00 00 00	 mov	 edx, DWORD PTR $LN94@validate_e[r8+rax*4]
  00035	49 03 d0	 add	 rdx, r8
  00038	ff e2		 jmp	 rdx
$LN43@validate_e:

; 150  :     case Attribute_kind:
; 151  :         actual_ctx = exp->v.Attribute.ctx;

  0003a	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]

; 152  :         break;

  0003d	eb 03		 jmp	 SHORT $LN90@validate_e
$LN38@validate_e:

; 153  :     case Subscript_kind:
; 154  :         actual_ctx = exp->v.Subscript.ctx;
; 155  :         break;
; 156  :     case Starred_kind:
; 157  :         actual_ctx = exp->v.Starred.ctx;
; 158  :         break;
; 159  :     case Name_kind:
; 160  :         actual_ctx = exp->v.Name.ctx;
; 161  :         break;
; 162  :     case List_kind:
; 163  :         actual_ctx = exp->v.List.ctx;
; 164  :         break;
; 165  :     case Tuple_kind:
; 166  :         actual_ctx = exp->v.Tuple.ctx;

  0003f	8b 47 10	 mov	 eax, DWORD PTR [rdi+16]
$LN90@validate_e:

; 172  :             return 0;
; 173  :         }
; 174  :         check_ctx = 0;
; 175  :     }
; 176  :     if (check_ctx && actual_ctx != ctx) {

  00042	41 3b c2	 cmp	 eax, r10d
  00045	74 43		 je	 SHORT $LN35@validate_e

; 177  :         PyErr_Format(PyExc_ValueError, "expression must have %s context but has %s instead",
; 178  :                      expr_context_name(ctx), expr_context_name(actual_ctx));

  00047	8b c8		 mov	 ecx, eax
  00049	e8 00 00 00 00	 call	 expr_context_name
  0004e	41 8b ca	 mov	 ecx, r10d
  00051	4c 8b c8	 mov	 r9, rax
  00054	e8 00 00 00 00	 call	 expr_context_name
  00059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@JOHDCPHG@expression?5must?5have?5?$CFs?5context?5@
  00067	4c 8b c0	 mov	 r8, rax
  0006a	e8 00 00 00 00	 call	 PyErr_Format
  0006f	33 c0		 xor	 eax, eax
  00071	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  00076	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
$LN37@validate_e:

; 167  :         break;
; 168  :     default:
; 169  :         if (ctx != Load) {

  00081	44 3b d3	 cmp	 r10d, ebx
  00084	0f 85 2d 05 00
	00		 jne	 $LN88@validate_e
$LN35@validate_e:

; 179  :         return 0;
; 180  :     }
; 181  : 
; 182  :     /* Now validate expression. */
; 183  :     switch (exp->kind) {

  0008a	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  0008d	83 f8 18	 cmp	 eax, 24
  00090	0f 87 fc 04 00
	00		 ja	 $LN1@validate_e
  00096	48 98		 cdqe
  00098	41 8b 8c 80 00
	00 00 00	 mov	 ecx, DWORD PTR $LN93@validate_e[r8+rax*4]
  000a0	49 03 c8	 add	 rcx, r8
  000a3	ff e1		 jmp	 rcx
$LN29@validate_e:

; 193  :     case UnaryOp_kind:
; 194  :         return validate_expr(exp->v.UnaryOp.operand, Load);

  000a5	48 8b 7f 10	 mov	 rdi, QWORD PTR [rdi+16]
  000a9	44 8b d3	 mov	 r10d, ebx
  000ac	e9 70 ff ff ff	 jmp	 $LL86@validate_e
$LN18@validate_e:

; 226  :     case YieldFrom_kind:
; 227  :         return validate_expr(exp->v.YieldFrom.value, Load);

  000b1	44 8b d3	 mov	 r10d, ebx
$LN5@validate_e:
  000b4	48 8b 7f 08	 mov	 rdi, QWORD PTR [rdi+8]
  000b8	e9 64 ff ff ff	 jmp	 $LL86@validate_e
$LN32@validate_e:

; 184  :     case BoolOp_kind:
; 185  :         if (asdl_seq_LEN(exp->v.BoolOp.values) < 2) {

  000bd	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  000c1	48 85 c9	 test	 rcx, rcx
  000c4	74 1f		 je	 SHORT $LN91@validate_e
  000c6	48 83 39 02	 cmp	 QWORD PTR [rcx], 2
  000ca	7c 19		 jl	 SHORT $LN91@validate_e

; 187  :             return 0;
; 188  :         }
; 189  :         return validate_exprs(exp->v.BoolOp.values, Load, 0);

  000cc	45 33 c0	 xor	 r8d, r8d
  000cf	8b d3		 mov	 edx, ebx
  000d1	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  000d6	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000db	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000df	5f		 pop	 rdi
  000e0	e9 00 00 00 00	 jmp	 validate_exprs
$LN91@validate_e:

; 186  :             PyErr_SetString(PyExc_ValueError, "BoolOp with less than 2 values");

  000e5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@DJACLLDP@BoolOp?5with?5less?5than?52?5values?$AA@
  000f3	e8 00 00 00 00	 call	 PyErr_SetString
  000f8	33 c0		 xor	 eax, eax
  000fa	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  000ff	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00104	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00108	5f		 pop	 rdi
  00109	c3		 ret	 0
$LN30@validate_e:

; 190  :     case BinOp_kind:
; 191  :         return validate_expr(exp->v.BinOp.left, Load) &&
; 192  :             validate_expr(exp->v.BinOp.right, Load);

  0010a	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  0010e	8b d3		 mov	 edx, ebx
  00110	e8 00 00 00 00	 call	 validate_expr
  00115	85 c0		 test	 eax, eax
  00117	74 0f		 je	 SHORT $LN50@validate_e
  00119	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  0011d	8b d3		 mov	 edx, ebx
  0011f	e8 00 00 00 00	 call	 validate_expr
  00124	85 c0		 test	 eax, eax
  00126	75 04		 jne	 SHORT $LN51@validate_e
$LN50@validate_e:
  00128	33 f6		 xor	 esi, esi
  0012a	8b de		 mov	 ebx, esi
$LN51@validate_e:
  0012c	8b c3		 mov	 eax, ebx
  0012e	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  00133	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00138	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013c	5f		 pop	 rdi
  0013d	c3		 ret	 0
$LN28@validate_e:

; 195  :     case Lambda_kind:
; 196  :         return validate_arguments(exp->v.Lambda.args) &&
; 197  :             validate_expr(exp->v.Lambda.body, Load);

  0013e	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00142	e8 00 00 00 00	 call	 validate_arguments
  00147	85 c0		 test	 eax, eax
  00149	74 0f		 je	 SHORT $LN52@validate_e
  0014b	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  0014f	8b d3		 mov	 edx, ebx
  00151	e8 00 00 00 00	 call	 validate_expr
  00156	85 c0		 test	 eax, eax
  00158	75 04		 jne	 SHORT $LN53@validate_e
$LN52@validate_e:
  0015a	33 f6		 xor	 esi, esi
  0015c	8b de		 mov	 ebx, esi
$LN53@validate_e:
  0015e	8b c3		 mov	 eax, ebx
  00160	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  00165	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0016a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016e	5f		 pop	 rdi
  0016f	c3		 ret	 0
$LN27@validate_e:

; 198  :     case IfExp_kind:
; 199  :         return validate_expr(exp->v.IfExp.test, Load) &&
; 200  :             validate_expr(exp->v.IfExp.body, Load) &&
; 201  :             validate_expr(exp->v.IfExp.orelse, Load);

  00170	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00174	8b d3		 mov	 edx, ebx
  00176	e8 00 00 00 00	 call	 validate_expr
  0017b	85 c0		 test	 eax, eax
  0017d	74 1e		 je	 SHORT $LN54@validate_e
  0017f	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00183	8b d3		 mov	 edx, ebx
  00185	e8 00 00 00 00	 call	 validate_expr
  0018a	85 c0		 test	 eax, eax
  0018c	74 0f		 je	 SHORT $LN54@validate_e
  0018e	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00192	8b d3		 mov	 edx, ebx
  00194	e8 00 00 00 00	 call	 validate_expr
  00199	85 c0		 test	 eax, eax
  0019b	75 04		 jne	 SHORT $LN55@validate_e
$LN54@validate_e:
  0019d	33 f6		 xor	 esi, esi
  0019f	8b de		 mov	 ebx, esi
$LN55@validate_e:
  001a1	8b c3		 mov	 eax, ebx
  001a3	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  001a8	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  001ad	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001b1	5f		 pop	 rdi
  001b2	c3		 ret	 0
$LN26@validate_e:

; 202  :     case Dict_kind:
; 203  :         if (asdl_seq_LEN(exp->v.Dict.keys) != asdl_seq_LEN(exp->v.Dict.values)) {

  001b3	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  001b7	33 f6		 xor	 esi, esi
  001b9	8b c6		 mov	 eax, esi
  001bb	48 85 c9	 test	 rcx, rcx
  001be	74 03		 je	 SHORT $LN57@validate_e
  001c0	48 8b 01	 mov	 rax, QWORD PTR [rcx]
$LN57@validate_e:
  001c3	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  001c7	48 85 d2	 test	 rdx, rdx
  001ca	75 05		 jne	 SHORT $LN58@validate_e
  001cc	48 8b d6	 mov	 rdx, rsi
  001cf	eb 03		 jmp	 SHORT $LN59@validate_e
$LN58@validate_e:
  001d1	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN59@validate_e:
  001d4	48 3b c2	 cmp	 rax, rdx
  001d7	74 25		 je	 SHORT $LN25@validate_e

; 204  :             PyErr_SetString(PyExc_ValueError,
; 205  :                             "Dict doesn't have the same number of keys as values");

  001d9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@EGPJELGA@Dict?5doesn?8t?5have?5the?5same?5numbe@
  001e7	e8 00 00 00 00	 call	 PyErr_SetString
  001ec	33 c0		 xor	 eax, eax
  001ee	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  001f3	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  001f8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001fc	5f		 pop	 rdi
  001fd	c3		 ret	 0
$LN25@validate_e:

; 206  :             return 0;
; 207  :         }
; 208  :         return validate_exprs(exp->v.Dict.keys, Load, 0) &&
; 209  :             validate_exprs(exp->v.Dict.values, Load, 0);

  001fe	45 33 c0	 xor	 r8d, r8d
  00201	8b d3		 mov	 edx, ebx
  00203	e8 00 00 00 00	 call	 validate_exprs
  00208	85 c0		 test	 eax, eax
  0020a	74 12		 je	 SHORT $LN60@validate_e
  0020c	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00210	45 33 c0	 xor	 r8d, r8d
  00213	8b d3		 mov	 edx, ebx
  00215	e8 00 00 00 00	 call	 validate_exprs
  0021a	85 c0		 test	 eax, eax
  0021c	75 02		 jne	 SHORT $LN61@validate_e
$LN60@validate_e:
  0021e	8b de		 mov	 ebx, esi
$LN61@validate_e:
  00220	8b c3		 mov	 eax, ebx
  00222	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  00227	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0022c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00230	5f		 pop	 rdi
  00231	c3		 ret	 0
$LN24@validate_e:

; 210  :     case Set_kind:
; 211  :         return validate_exprs(exp->v.Set.elts, Load, 0);

  00232	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00236	45 33 c0	 xor	 r8d, r8d
  00239	8b d3		 mov	 edx, ebx
  0023b	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  00240	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00245	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00249	5f		 pop	 rdi
  0024a	e9 00 00 00 00	 jmp	 validate_exprs
$LN23@validate_e:

; 212  : #define COMP(NAME) \
; 213  :         case NAME ## _kind: \
; 214  :             return validate_comprehension(exp->v.NAME.generators) && \
; 215  :                 validate_expr(exp->v.NAME.elt, Load);
; 216  :     COMP(ListComp)

  0024f	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00253	e8 00 00 00 00	 call	 validate_comprehension
  00258	85 c0		 test	 eax, eax
  0025a	74 0f		 je	 SHORT $LN62@validate_e
  0025c	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00260	8b d3		 mov	 edx, ebx
  00262	e8 00 00 00 00	 call	 validate_expr
  00267	85 c0		 test	 eax, eax
  00269	75 04		 jne	 SHORT $LN63@validate_e
$LN62@validate_e:
  0026b	33 f6		 xor	 esi, esi
  0026d	8b de		 mov	 ebx, esi
$LN63@validate_e:
  0026f	8b c3		 mov	 eax, ebx
  00271	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  00276	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0027b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0027f	5f		 pop	 rdi
  00280	c3		 ret	 0
$LN22@validate_e:

; 217  :     COMP(SetComp)

  00281	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00285	e8 00 00 00 00	 call	 validate_comprehension
  0028a	85 c0		 test	 eax, eax
  0028c	74 0f		 je	 SHORT $LN64@validate_e
  0028e	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00292	8b d3		 mov	 edx, ebx
  00294	e8 00 00 00 00	 call	 validate_expr
  00299	85 c0		 test	 eax, eax
  0029b	75 04		 jne	 SHORT $LN65@validate_e
$LN64@validate_e:
  0029d	33 f6		 xor	 esi, esi
  0029f	8b de		 mov	 ebx, esi
$LN65@validate_e:
  002a1	8b c3		 mov	 eax, ebx
  002a3	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  002a8	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  002ad	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002b1	5f		 pop	 rdi
  002b2	c3		 ret	 0
$LN21@validate_e:

; 218  :     COMP(GeneratorExp)

  002b3	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  002b7	e8 00 00 00 00	 call	 validate_comprehension
  002bc	85 c0		 test	 eax, eax
  002be	74 0f		 je	 SHORT $LN66@validate_e
  002c0	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  002c4	8b d3		 mov	 edx, ebx
  002c6	e8 00 00 00 00	 call	 validate_expr
  002cb	85 c0		 test	 eax, eax
  002cd	75 04		 jne	 SHORT $LN67@validate_e
$LN66@validate_e:
  002cf	33 f6		 xor	 esi, esi
  002d1	8b de		 mov	 ebx, esi
$LN67@validate_e:
  002d3	8b c3		 mov	 eax, ebx
  002d5	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  002da	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  002df	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002e3	5f		 pop	 rdi
  002e4	c3		 ret	 0
$LN20@validate_e:

; 219  : #undef COMP
; 220  :     case DictComp_kind:
; 221  :         return validate_comprehension(exp->v.DictComp.generators) &&
; 222  :             validate_expr(exp->v.DictComp.key, Load) &&
; 223  :             validate_expr(exp->v.DictComp.value, Load);

  002e5	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  002e9	e8 00 00 00 00	 call	 validate_comprehension
  002ee	85 c0		 test	 eax, eax
  002f0	74 1e		 je	 SHORT $LN68@validate_e
  002f2	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  002f6	8b d3		 mov	 edx, ebx
  002f8	e8 00 00 00 00	 call	 validate_expr
  002fd	85 c0		 test	 eax, eax
  002ff	74 0f		 je	 SHORT $LN68@validate_e
  00301	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00305	8b d3		 mov	 edx, ebx
  00307	e8 00 00 00 00	 call	 validate_expr
  0030c	85 c0		 test	 eax, eax
  0030e	75 04		 jne	 SHORT $LN69@validate_e
$LN68@validate_e:
  00310	33 f6		 xor	 esi, esi
  00312	8b de		 mov	 ebx, esi
$LN69@validate_e:
  00314	8b c3		 mov	 eax, ebx
  00316	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  0031b	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00320	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00324	5f		 pop	 rdi
  00325	c3		 ret	 0
$LN19@validate_e:

; 224  :     case Yield_kind:
; 225  :         return !exp->v.Yield.value || validate_expr(exp->v.Yield.value, Load);

  00326	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  0032a	48 85 c9	 test	 rcx, rcx
  0032d	74 1f		 je	 SHORT $LN70@validate_e
  0032f	8b d3		 mov	 edx, ebx
  00331	e8 00 00 00 00	 call	 validate_expr
  00336	85 c0		 test	 eax, eax
  00338	75 14		 jne	 SHORT $LN70@validate_e
  0033a	33 f6		 xor	 esi, esi
  0033c	8b c6		 mov	 eax, esi
  0033e	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  00343	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00348	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0034c	5f		 pop	 rdi
  0034d	c3		 ret	 0
$LN70@validate_e:

; 224  :     case Yield_kind:
; 225  :         return !exp->v.Yield.value || validate_expr(exp->v.Yield.value, Load);

  0034e	8b f3		 mov	 esi, ebx
  00350	8b c3		 mov	 eax, ebx
  00352	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  00357	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0035c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00360	5f		 pop	 rdi
  00361	c3		 ret	 0
$LN17@validate_e:

; 228  :     case Compare_kind:
; 229  :         if (!asdl_seq_LEN(exp->v.Compare.comparators)) {

  00362	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00366	48 85 c9	 test	 rcx, rcx
  00369	74 75		 je	 SHORT $LN92@validate_e
  0036b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0036e	48 85 c0	 test	 rax, rax
  00371	74 6d		 je	 SHORT $LN92@validate_e

; 231  :             return 0;
; 232  :         }
; 233  :         if (asdl_seq_LEN(exp->v.Compare.comparators) !=
; 234  :             asdl_seq_LEN(exp->v.Compare.ops)) {

  00373	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00377	33 f6		 xor	 esi, esi
  00379	48 85 d2	 test	 rdx, rdx
  0037c	75 04		 jne	 SHORT $LN76@validate_e
  0037e	8b d6		 mov	 edx, esi
  00380	eb 03		 jmp	 SHORT $LN77@validate_e
$LN76@validate_e:
  00382	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN77@validate_e:
  00385	48 3b c2	 cmp	 rax, rdx
  00388	74 25		 je	 SHORT $LN15@validate_e

; 235  :             PyErr_SetString(PyExc_ValueError, "Compare has a different number "
; 236  :                             "of comparators and operands");

  0038a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00391	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@IEHCCJP@Compare?5has?5a?5different?5number?5o@
  00398	e8 00 00 00 00	 call	 PyErr_SetString
  0039d	33 c0		 xor	 eax, eax
  0039f	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  003a4	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  003a9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  003ad	5f		 pop	 rdi
  003ae	c3		 ret	 0
$LN15@validate_e:

; 237  :             return 0;
; 238  :         }
; 239  :         return validate_exprs(exp->v.Compare.comparators, Load, 0) &&
; 240  :             validate_expr(exp->v.Compare.left, Load);

  003af	45 33 c0	 xor	 r8d, r8d
  003b2	8b d3		 mov	 edx, ebx
  003b4	e8 00 00 00 00	 call	 validate_exprs
  003b9	85 c0		 test	 eax, eax
  003bb	74 0f		 je	 SHORT $LN78@validate_e
  003bd	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  003c1	8b d3		 mov	 edx, ebx
  003c3	e8 00 00 00 00	 call	 validate_expr
  003c8	85 c0		 test	 eax, eax
  003ca	75 02		 jne	 SHORT $LN79@validate_e
$LN78@validate_e:
  003cc	8b de		 mov	 ebx, esi
$LN79@validate_e:
  003ce	8b c3		 mov	 eax, ebx
  003d0	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  003d5	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  003da	48 83 c4 20	 add	 rsp, 32			; 00000020H
  003de	5f		 pop	 rdi
  003df	c3		 ret	 0
$LN92@validate_e:

; 230  :             PyErr_SetString(PyExc_ValueError, "Compare with no comparators");

  003e0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  003e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@HPPBDCNI@Compare?5with?5no?5comparators?$AA@
  003ee	e8 00 00 00 00	 call	 PyErr_SetString
  003f3	33 c0		 xor	 eax, eax
  003f5	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  003fa	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  003ff	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00403	5f		 pop	 rdi
  00404	c3		 ret	 0
$LN14@validate_e:

; 241  :     case Call_kind:
; 242  :         return validate_expr(exp->v.Call.func, Load) &&
; 243  :             validate_exprs(exp->v.Call.args, Load, 0) &&
; 244  :             validate_keywords(exp->v.Call.keywords) &&
; 245  :             (!exp->v.Call.starargs || validate_expr(exp->v.Call.starargs, Load)) &&
; 246  :             (!exp->v.Call.kwargs || validate_expr(exp->v.Call.kwargs, Load));

  00405	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00409	8b d3		 mov	 edx, ebx
  0040b	e8 00 00 00 00	 call	 validate_expr
  00410	85 c0		 test	 eax, eax
  00412	74 47		 je	 SHORT $LN80@validate_e
  00414	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00418	45 33 c0	 xor	 r8d, r8d
  0041b	8b d3		 mov	 edx, ebx
  0041d	e8 00 00 00 00	 call	 validate_exprs
  00422	85 c0		 test	 eax, eax
  00424	74 35		 je	 SHORT $LN80@validate_e
  00426	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  0042a	e8 00 00 00 00	 call	 validate_keywords
  0042f	85 c0		 test	 eax, eax
  00431	74 28		 je	 SHORT $LN80@validate_e
  00433	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  00437	48 85 c9	 test	 rcx, rcx
  0043a	74 0b		 je	 SHORT $LN81@validate_e
  0043c	8b d3		 mov	 edx, ebx
  0043e	e8 00 00 00 00	 call	 validate_expr
  00443	85 c0		 test	 eax, eax
  00445	74 14		 je	 SHORT $LN80@validate_e
$LN81@validate_e:
  00447	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  0044b	48 85 c9	 test	 rcx, rcx
  0044e	74 0f		 je	 SHORT $LN83@validate_e
  00450	8b d3		 mov	 edx, ebx
  00452	e8 00 00 00 00	 call	 validate_expr
  00457	85 c0		 test	 eax, eax
  00459	75 04		 jne	 SHORT $LN83@validate_e
$LN80@validate_e:
  0045b	33 f6		 xor	 esi, esi
  0045d	8b de		 mov	 ebx, esi
$LN83@validate_e:
  0045f	8b c3		 mov	 eax, ebx
  00461	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  00466	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0046b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0046f	5f		 pop	 rdi
  00470	c3		 ret	 0
$LN13@validate_e:

; 247  :     case Num_kind: {
; 248  :         PyObject *n = exp->v.Num.n;

  00471	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]

; 249  :         if (!PyLong_CheckExact(n) && !PyFloat_CheckExact(n) &&
; 250  :             !PyComplex_CheckExact(n)) {

  00475	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00479	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  00480	48 3b c8	 cmp	 rcx, rax
  00483	0f 84 a3 fc ff
	ff		 je	 $LN51@validate_e
  00489	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00490	48 3b c8	 cmp	 rcx, rax
  00493	0f 84 93 fc ff
	ff		 je	 $LN51@validate_e
  00499	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyComplex_Type
  004a0	48 3b c8	 cmp	 rcx, rax
  004a3	0f 84 83 fc ff
	ff		 je	 $LN51@validate_e

; 251  :             PyErr_SetString(PyExc_TypeError, "non-numeric type in Num");

  004a9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  004b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@ECNBNEHA@non?9numeric?5type?5in?5Num?$AA@
  004b7	e8 00 00 00 00	 call	 PyErr_SetString
  004bc	33 c0		 xor	 eax, eax
  004be	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  004c3	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  004c8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  004cc	5f		 pop	 rdi
  004cd	c3		 ret	 0
$LN11@validate_e:

; 252  :             return 0;
; 253  :         }
; 254  :         return 1;
; 255  :     }
; 256  :     case Str_kind: {
; 257  :         PyObject *s = exp->v.Str.s;
; 258  :         if (!PyUnicode_CheckExact(s)) {

  004ce	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  004d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyUnicode_Type
  004d9	48 39 48 58	 cmp	 QWORD PTR [rax+88], rcx
  004dd	0f 84 49 fc ff
	ff		 je	 $LN51@validate_e

; 259  :             PyErr_SetString(PyExc_TypeError, "non-string type in Str");

  004e3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  004ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@JMHKCIPG@non?9string?5type?5in?5Str?$AA@
  004f1	e8 00 00 00 00	 call	 PyErr_SetString
  004f6	33 c0		 xor	 eax, eax
  004f8	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  004fd	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00502	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00506	5f		 pop	 rdi
  00507	c3		 ret	 0
$LN9@validate_e:

; 260  :             return 0;
; 261  :         }
; 262  :         return 1;
; 263  :     }
; 264  :     case Bytes_kind: {
; 265  :         PyObject *b = exp->v.Bytes.s;
; 266  :         if (!PyBytes_CheckExact(b)) {

  00508	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  0050c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBytes_Type
  00513	48 39 48 58	 cmp	 QWORD PTR [rax+88], rcx
  00517	0f 84 0f fc ff
	ff		 je	 $LN51@validate_e

; 267  :             PyErr_SetString(PyExc_TypeError, "non-bytes type in Bytes");

  0051d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00524	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@DPNNPPHI@non?9bytes?5type?5in?5Bytes?$AA@
  0052b	e8 00 00 00 00	 call	 PyErr_SetString
  00530	33 c0		 xor	 eax, eax
  00532	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  00537	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0053c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00540	5f		 pop	 rdi
  00541	c3		 ret	 0
$LN6@validate_e:

; 268  :             return 0;
; 269  :         }
; 270  :         return 1;
; 271  :     }
; 272  :     case Attribute_kind:
; 273  :         return validate_expr(exp->v.Attribute.value, Load);
; 274  :     case Subscript_kind:
; 275  :         return validate_slice(exp->v.Subscript.slice) &&
; 276  :             validate_expr(exp->v.Subscript.value, Load);

  00542	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00546	e8 00 00 00 00	 call	 validate_slice
  0054b	85 c0		 test	 eax, eax
  0054d	74 0f		 je	 SHORT $LN84@validate_e
  0054f	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00553	8b d3		 mov	 edx, ebx
  00555	e8 00 00 00 00	 call	 validate_expr
  0055a	85 c0		 test	 eax, eax
  0055c	75 04		 jne	 SHORT $LN85@validate_e
$LN84@validate_e:
  0055e	33 f6		 xor	 esi, esi
  00560	8b de		 mov	 ebx, esi
$LN85@validate_e:
  00562	8b c3		 mov	 eax, ebx
  00564	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  00569	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0056e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00572	5f		 pop	 rdi
  00573	c3		 ret	 0
$LN4@validate_e:

; 277  :     case Starred_kind:
; 278  :         return validate_expr(exp->v.Starred.value, ctx);
; 279  :     case List_kind:
; 280  :         return validate_exprs(exp->v.List.elts, ctx, 0);

  00574	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00578	45 33 c0	 xor	 r8d, r8d
  0057b	41 8b d2	 mov	 edx, r10d
  0057e	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  00583	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00588	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0058c	5f		 pop	 rdi
  0058d	e9 00 00 00 00	 jmp	 validate_exprs
$LN1@validate_e:

; 281  :     case Tuple_kind:
; 282  :         return validate_exprs(exp->v.Tuple.elts, ctx, 0);
; 283  :     /* These last cases don't have any checking. */
; 284  :     case Name_kind:
; 285  :     case Ellipsis_kind:
; 286  :         return 1;
; 287  :     default:
; 288  :         PyErr_SetString(PyExc_SystemError, "unexpected expression");

  00592	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00599	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PAKLMHBH@unexpected?5expression?$AA@
  005a0	e8 00 00 00 00	 call	 PyErr_SetString
  005a5	33 c0		 xor	 eax, eax
  005a7	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  005ac	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  005b1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  005b5	5f		 pop	 rdi
  005b6	c3		 ret	 0
$LN88@validate_e:

; 170  :             PyErr_Format(PyExc_ValueError, "expression which can't be "
; 171  :                          "assigned to in %s context", expr_context_name(ctx));

  005b7	41 8b ca	 mov	 ecx, r10d
  005ba	e8 00 00 00 00	 call	 expr_context_name
  005bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  005c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@FLEFGDAH@expression?5which?5can?8t?5be?5assign@
  005cd	4c 8b c0	 mov	 r8, rax
  005d0	e8 00 00 00 00	 call	 PyErr_Format
  005d5	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 289  :         return 0;
; 290  :     }
; 291  : }

  005da	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  005df	33 c0		 xor	 eax, eax
  005e1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  005e5	5f		 pop	 rdi
  005e6	c3		 ret	 0
  005e7	90		 npad	 1
$LN94@validate_e:
  005e8	00 00 00 00	 DD	 $LN43@validate_e
  005ec	00 00 00 00	 DD	 $LN43@validate_e
  005f0	00 00 00 00	 DD	 $LN38@validate_e
  005f4	00 00 00 00	 DD	 $LN38@validate_e
  005f8	00 00 00 00	 DD	 $LN38@validate_e
  005fc	00 00 00 00	 DD	 $LN38@validate_e
$LN93@validate_e:
  00600	00 00 00 00	 DD	 $LN32@validate_e
  00604	00 00 00 00	 DD	 $LN30@validate_e
  00608	00 00 00 00	 DD	 $LN29@validate_e
  0060c	00 00 00 00	 DD	 $LN28@validate_e
  00610	00 00 00 00	 DD	 $LN27@validate_e
  00614	00 00 00 00	 DD	 $LN26@validate_e
  00618	00 00 00 00	 DD	 $LN24@validate_e
  0061c	00 00 00 00	 DD	 $LN23@validate_e
  00620	00 00 00 00	 DD	 $LN22@validate_e
  00624	00 00 00 00	 DD	 $LN20@validate_e
  00628	00 00 00 00	 DD	 $LN21@validate_e
  0062c	00 00 00 00	 DD	 $LN19@validate_e
  00630	00 00 00 00	 DD	 $LN18@validate_e
  00634	00 00 00 00	 DD	 $LN17@validate_e
  00638	00 00 00 00	 DD	 $LN14@validate_e
  0063c	00 00 00 00	 DD	 $LN13@validate_e
  00640	00 00 00 00	 DD	 $LN11@validate_e
  00644	00 00 00 00	 DD	 $LN9@validate_e
  00648	00 00 00 00	 DD	 $LN51@validate_e
  0064c	00 00 00 00	 DD	 $LN18@validate_e
  00650	00 00 00 00	 DD	 $LN6@validate_e
  00654	00 00 00 00	 DD	 $LN5@validate_e
  00658	00 00 00 00	 DD	 $LN51@validate_e
  0065c	00 00 00 00	 DD	 $LN4@validate_e
  00660	00 00 00 00	 DD	 $LN4@validate_e
validate_expr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@MDELEHKM@None?5disallowed?5in?5expression?5li@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_exprs DD imagerel validate_exprs
	DD	imagerel validate_exprs+164
	DD	imagerel $unwind$validate_exprs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_exprs DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
xdata	ENDS
;	COMDAT ??_C@_0CD@MDELEHKM@None?5disallowed?5in?5expression?5li@
CONST	SEGMENT
??_C@_0CD@MDELEHKM@None?5disallowed?5in?5expression?5li@ DB 'None disallo'
	DB	'wed in expression list', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT validate_exprs
_TEXT	SEGMENT
exprs$ = 48
ctx$ = 56
null_ok$ = 64
validate_exprs PROC					; COMDAT

; 448  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	41 8b e8	 mov	 ebp, r8d
  0001d	44 8b e2	 mov	 r12d, edx
  00020	48 8b f1	 mov	 rsi, rcx

; 449  :     int i;
; 450  :     for (i = 0; i < asdl_seq_LEN(exprs); i++) {

  00023	33 ff		 xor	 edi, edi
  00025	48 8d 59 08	 lea	 rbx, QWORD PTR [rcx+8]
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@validate_e@2:
  00030	48 85 f6	 test	 rsi, rsi
  00033	75 05		 jne	 SHORT $LN10@validate_e@2
  00035	45 33 c9	 xor	 r9d, r9d
  00038	eb 03		 jmp	 SHORT $LN11@validate_e@2
$LN10@validate_e@2:
  0003a	4c 8b 0e	 mov	 r9, QWORD PTR [rsi]
$LN11@validate_e@2:
  0003d	48 63 c7	 movsxd	 rax, edi
  00040	49 3b c1	 cmp	 rax, r9
  00043	7d 3f		 jge	 SHORT $LN5@validate_e@2

; 451  :         expr_ty expr = asdl_seq_GET(exprs, i);

  00045	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]

; 452  :         if (expr) {

  00048	48 85 c9	 test	 rcx, rcx
  0004b	74 14		 je	 SHORT $LN4@validate_e@2

; 453  :             if (!validate_expr(expr, ctx))

  0004d	41 8b d4	 mov	 edx, r12d
  00050	e8 00 00 00 00	 call	 validate_expr
  00055	85 c0		 test	 eax, eax
  00057	74 27		 je	 SHORT $LN13@validate_e@2

; 449  :     int i;
; 450  :     for (i = 0; i < asdl_seq_LEN(exprs); i++) {

  00059	ff c7		 inc	 edi
  0005b	48 83 c3 08	 add	 rbx, 8
  0005f	eb cf		 jmp	 SHORT $LL7@validate_e@2
$LN4@validate_e@2:

; 454  :                 return 0;
; 455  :         }
; 456  :         else if (!null_ok) {

  00061	85 ed		 test	 ebp, ebp
  00063	74 08		 je	 SHORT $LN14@validate_e@2

; 449  :     int i;
; 450  :     for (i = 0; i < asdl_seq_LEN(exprs); i++) {

  00065	ff c7		 inc	 edi
  00067	48 83 c3 08	 add	 rbx, 8
  0006b	eb c3		 jmp	 SHORT $LL7@validate_e@2
$LN14@validate_e@2:

; 457  :             PyErr_SetString(PyExc_ValueError,
; 458  :                             "None disallowed in expression list");

  0006d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@MDELEHKM@None?5disallowed?5in?5expression?5li@
  0007b	e8 00 00 00 00	 call	 PyErr_SetString
$LN13@validate_e@2:

; 459  :             return 0;

  00080	33 c0		 xor	 eax, eax
  00082	eb 05		 jmp	 SHORT $LN8@validate_e@2
$LN5@validate_e@2:

; 460  :         }
; 461  :             
; 462  :     }
; 463  :     return 1;

  00084	b8 01 00 00 00	 mov	 eax, 1
$LN8@validate_e@2:

; 464  : }

  00089	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008e	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00093	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00098	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0009d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a1	41 5c		 pop	 r12
  000a3	c3		 ret	 0
validate_exprs ENDP
_TEXT	ENDS
EXTRN	_Py_comprehension:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_comprehension DD imagerel ast_for_comprehension
	DD	imagerel ast_for_comprehension+41
	DD	imagerel $unwind$ast_for_comprehension
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ast_for_comprehension DD imagerel ast_for_comprehension+41
	DD	imagerel ast_for_comprehension+91
	DD	imagerel $chain$0$ast_for_comprehension
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$ast_for_comprehension DD imagerel ast_for_comprehension+91
	DD	imagerel ast_for_comprehension+559
	DD	imagerel $chain$7$ast_for_comprehension
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$ast_for_comprehension DD 0c2521H
	DD	08f425H
	DD	09e414H
	DD	0ac40fH
	DD	0b640aH
	DD	0c5405H
	DD	0103400H
	DD	imagerel ast_for_comprehension
	DD	imagerel ast_for_comprehension+41
	DD	imagerel $unwind$ast_for_comprehension
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ast_for_comprehension DD 020821H
	DD	0103408H
	DD	imagerel ast_for_comprehension
	DD	imagerel ast_for_comprehension+41
	DD	imagerel $unwind$ast_for_comprehension
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_comprehension DD 030801H
	DD	0d004c208H
	DD	07002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_comprehension
_TEXT	SEGMENT
$T26156 = 48
comps$1$ = 56
c$ = 128
n$ = 136
$T26155 = 144
tv354 = 152
ast_for_comprehension PROC				; COMDAT

; 1661 : {

  00000	40 57		 push	 rdi
  00002	41 55		 push	 r13
  00004	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00008	4c 8b e9	 mov	 r13, rcx

; 1662 :     int i, n_fors;
; 1663 :     asdl_seq *comps;
; 1664 : 
; 1665 :     n_fors = count_comp_fors(c, n);

  0000b	48 8b ca	 mov	 rcx, rdx
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	e8 00 00 00 00	 call	 count_comp_fors

; 1666 :     if (n_fors == -1)

  00016	83 f8 ff	 cmp	 eax, -1
  00019	75 0a		 jne	 SHORT $LN19@ast_for_co@2

; 1667 :         return NULL;

  0001b	33 c0		 xor	 eax, eax

; 1732 :     }
; 1733 :     return comps;
; 1734 : }

  0001d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00021	41 5d		 pop	 r13
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
$LN19@ast_for_co@2:

; 1668 : 
; 1669 :     comps = asdl_seq_new(n_fors, c->c_arena);

  00025	49 8b 55 08	 mov	 rdx, QWORD PTR [r13+8]
  00029	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbx
  00031	48 63 d8	 movsxd	 rbx, eax
  00034	48 8b cb	 mov	 rcx, rbx
  00037	48 89 5c 24 30	 mov	 QWORD PTR $T26156[rsp], rbx
  0003c	e8 00 00 00 00	 call	 asdl_seq_new
  00041	48 89 44 24 38	 mov	 QWORD PTR comps$1$[rsp], rax

; 1670 :     if (!comps)

  00046	48 85 c0	 test	 rax, rax
  00049	75 10		 jne	 SHORT $LN18@ast_for_co@2
  0004b	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]

; 1732 :     }
; 1733 :     return comps;
; 1734 : }

  00053	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00057	41 5d		 pop	 r13
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
$LN18@ast_for_co@2:
  0005b	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  00060	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  00065	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  0006a	4c 89 74 24 48	 mov	 QWORD PTR [rsp+72], r14

; 1671 :         return NULL;
; 1672 : 
; 1673 :     for (i = 0; i < n_fors; i++) {

  0006f	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR $T26155[rsp], 0
  0007b	4c 89 7c 24 40	 mov	 QWORD PTR [rsp+64], r15
  00080	48 85 db	 test	 rbx, rbx
  00083	0f 8e 7d 01 00
	00		 jle	 $LN15@ast_for_co@2
  00089	4c 8d 78 08	 lea	 r15, QWORD PTR [rax+8]
  0008d	4c 89 bc 24 98
	00 00 00	 mov	 QWORD PTR tv354[rsp], r15
  00095	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL17@ast_for_co@2:

; 1674 :         comprehension_ty comp;
; 1675 :         asdl_seq *t;
; 1676 :         expr_ty expression, first;
; 1677 :         node *for_ch;
; 1678 : 
; 1679 :         REQ(n, comp_for);
; 1680 : 
; 1681 :         for_ch = CHILD(n, 1);

  000a0	48 8b 5f 20	 mov	 rbx, QWORD PTR [rdi+32]

; 1682 :         t = ast_for_exprlist(c, for_ch, Store);

  000a4	41 b8 02 00 00
	00		 mov	 r8d, 2
  000aa	49 8b cd	 mov	 rcx, r13
  000ad	48 8d 53 28	 lea	 rdx, QWORD PTR [rbx+40]
  000b1	e8 00 00 00 00	 call	 ast_for_exprlist
  000b6	48 8b f0	 mov	 rsi, rax

; 1683 :         if (!t)

  000b9	48 85 c0	 test	 rax, rax
  000bc	0f 84 42 01 00
	00		 je	 $LN25@ast_for_co@2

; 1685 :         expression = ast_for_expr(c, CHILD(n, 3));

  000c2	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  000c6	49 8b cd	 mov	 rcx, r13
  000c9	48 83 c2 78	 add	 rdx, 120		; 00000078H
  000cd	e8 00 00 00 00	 call	 ast_for_expr
  000d2	4c 8b e0	 mov	 r12, rax

; 1686 :         if (!expression)

  000d5	48 85 c0	 test	 rax, rax
  000d8	0f 84 26 01 00
	00		 je	 $LN25@ast_for_co@2

; 1687 :             return NULL;
; 1688 : 
; 1689 :         /* Check the # of children rather than the length of t, since
; 1690 :            (x for x, in ...) has 1 element in t, but still requires a Tuple. */
; 1691 :         first = (expr_ty)asdl_seq_GET(t, 0);
; 1692 :         if (NCH(for_ch) == 1)

  000de	83 7b 40 01	 cmp	 DWORD PTR [rbx+64], 1
  000e2	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  000e6	75 06		 jne	 SHORT $LN12@ast_for_co@2

; 1693 :             comp = comprehension(first, expression, NULL, c->c_arena);

  000e8	4d 8b 4d 08	 mov	 r9, QWORD PTR [r13+8]

; 1694 :         else

  000ec	eb 21		 jmp	 SHORT $LN39@ast_for_co@2
$LN12@ast_for_co@2:

; 1695 :             comp = comprehension(Tuple(t, Store, first->lineno, first->col_offset,
; 1696 :                                      c->c_arena),
; 1697 :                                expression, NULL, c->c_arena);

  000ee	49 8b 5d 08	 mov	 rbx, QWORD PTR [r13+8]
  000f2	44 8b 48 34	 mov	 r9d, DWORD PTR [rax+52]
  000f6	44 8b 40 30	 mov	 r8d, DWORD PTR [rax+48]
  000fa	ba 02 00 00 00	 mov	 edx, 2
  000ff	48 8b ce	 mov	 rcx, rsi
  00102	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00107	e8 00 00 00 00	 call	 _Py_Tuple
  0010c	4c 8b cb	 mov	 r9, rbx
$LN39@ast_for_co@2:
  0010f	45 33 c0	 xor	 r8d, r8d
  00112	49 8b d4	 mov	 rdx, r12
  00115	48 8b c8	 mov	 rcx, rax
  00118	e8 00 00 00 00	 call	 _Py_comprehension
  0011d	4c 8b f0	 mov	 r14, rax

; 1698 :         if (!comp)

  00120	48 85 c0	 test	 rax, rax
  00123	0f 84 db 00 00
	00		 je	 $LN25@ast_for_co@2

; 1699 :             return NULL;
; 1700 : 
; 1701 :         if (NCH(n) == 5) {

  00129	83 7f 18 05	 cmp	 DWORD PTR [rdi+24], 5
  0012d	0f 85 9d 00 00
	00		 jne	 $LN9@ast_for_co@2

; 1702 :             int j, n_ifs;
; 1703 :             asdl_seq *ifs;
; 1704 : 
; 1705 :             n = CHILD(n, 4);

  00133	48 8b 7f 20	 mov	 rdi, QWORD PTR [rdi+32]
  00137	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H

; 1706 :             n_ifs = count_comp_ifs(c, n);

  0013e	48 8b cf	 mov	 rcx, rdi
  00141	e8 00 00 00 00	 call	 count_comp_ifs

; 1707 :             if (n_ifs == -1)

  00146	83 f8 ff	 cmp	 eax, -1
  00149	0f 84 b5 00 00
	00		 je	 $LN25@ast_for_co@2

; 1708 :                 return NULL;
; 1709 : 
; 1710 :             ifs = asdl_seq_new(n_ifs, c->c_arena);

  0014f	49 8b 55 08	 mov	 rdx, QWORD PTR [r13+8]
  00153	4c 63 e0	 movsxd	 r12, eax
  00156	49 8b cc	 mov	 rcx, r12
  00159	e8 00 00 00 00	 call	 asdl_seq_new
  0015e	4c 8b f8	 mov	 r15, rax

; 1711 :             if (!ifs)

  00161	48 85 c0	 test	 rax, rax
  00164	0f 84 9a 00 00
	00		 je	 $LN25@ast_for_co@2

; 1712 :                 return NULL;
; 1713 : 
; 1714 :             for (j = 0; j < n_ifs; j++) {

  0016a	33 f6		 xor	 esi, esi
  0016c	4d 85 e4	 test	 r12, r12
  0016f	7e 45		 jle	 SHORT $LN4@ast_for_co@2
  00171	48 8d 58 08	 lea	 rbx, QWORD PTR [rax+8]
  00175	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL6@ast_for_co@2:

; 1715 :                 REQ(n, comp_iter);
; 1716 :                 n = CHILD(n, 0);

  00180	48 8b 7f 20	 mov	 rdi, QWORD PTR [rdi+32]

; 1717 :                 REQ(n, comp_if);
; 1718 : 
; 1719 :                 expression = ast_for_expr(c, CHILD(n, 1));

  00184	49 8b cd	 mov	 rcx, r13
  00187	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  0018b	48 83 c2 28	 add	 rdx, 40			; 00000028H
  0018f	e8 00 00 00 00	 call	 ast_for_expr

; 1720 :                 if (!expression)

  00194	48 85 c0	 test	 rax, rax
  00197	74 6b		 je	 SHORT $LN25@ast_for_co@2

; 1721 :                     return NULL;
; 1722 :                 asdl_seq_SET(ifs, j, expression);

  00199	48 89 03	 mov	 QWORD PTR [rbx], rax

; 1723 :                 if (NCH(n) == 3)

  0019c	83 7f 18 03	 cmp	 DWORD PTR [rdi+24], 3
  001a0	75 08		 jne	 SHORT $LN5@ast_for_co@2

; 1724 :                     n = CHILD(n, 2);

  001a2	48 8b 7f 20	 mov	 rdi, QWORD PTR [rdi+32]
  001a6	48 83 c7 50	 add	 rdi, 80			; 00000050H
$LN5@ast_for_co@2:

; 1712 :                 return NULL;
; 1713 : 
; 1714 :             for (j = 0; j < n_ifs; j++) {

  001aa	48 ff c6	 inc	 rsi
  001ad	48 83 c3 08	 add	 rbx, 8
  001b1	49 3b f4	 cmp	 rsi, r12
  001b4	7c ca		 jl	 SHORT $LL6@ast_for_co@2
$LN4@ast_for_co@2:

; 1725 :             }
; 1726 :             /* on exit, must guarantee that n is a comp_for */
; 1727 :             if (TYPE(n) == comp_iter)

  001b6	b8 4c 01 00 00	 mov	 eax, 332		; 0000014cH
  001bb	66 39 07	 cmp	 WORD PTR [rdi], ax
  001be	75 04		 jne	 SHORT $LN1@ast_for_co@2

; 1728 :                 n = CHILD(n, 0);

  001c0	48 8b 7f 20	 mov	 rdi, QWORD PTR [rdi+32]
$LN1@ast_for_co@2:

; 1729 :             comp->ifs = ifs;

  001c4	4d 89 7e 10	 mov	 QWORD PTR [r14+16], r15
  001c8	4c 8b bc 24 98
	00 00 00	 mov	 r15, QWORD PTR tv354[rsp]
$LN9@ast_for_co@2:

; 1730 :         }
; 1731 :         asdl_seq_SET(comps, i, comp);

  001d0	4c 8b a4 24 90
	00 00 00	 mov	 r12, QWORD PTR $T26155[rsp]
  001d8	4d 89 37	 mov	 QWORD PTR [r15], r14
  001db	49 83 c7 08	 add	 r15, 8
  001df	49 ff c4	 inc	 r12
  001e2	4c 89 bc 24 98
	00 00 00	 mov	 QWORD PTR tv354[rsp], r15
  001ea	4c 89 a4 24 90
	00 00 00	 mov	 QWORD PTR $T26155[rsp], r12
  001f2	4c 3b 64 24 30	 cmp	 r12, QWORD PTR $T26156[rsp]
  001f7	0f 8c a3 fe ff
	ff		 jl	 $LL17@ast_for_co@2

; 1711 :             if (!ifs)

  001fd	48 8b 44 24 38	 mov	 rax, QWORD PTR comps$1$[rsp]
  00202	eb 02		 jmp	 SHORT $LN15@ast_for_co@2
$LN25@ast_for_co@2:

; 1684 :             return NULL;

  00204	33 c0		 xor	 eax, eax
$LN15@ast_for_co@2:
  00206	4c 8b 74 24 48	 mov	 r14, QWORD PTR [rsp+72]
  0020b	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  00210	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00215	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  0021a	4c 8b 7c 24 40	 mov	 r15, QWORD PTR [rsp+64]
  0021f	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]

; 1732 :     }
; 1733 :     return comps;
; 1734 : }

  00227	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0022b	41 5d		 pop	 r13
  0022d	5f		 pop	 rdi
  0022e	c3		 ret	 0
ast_for_comprehension ENDP
_TEXT	ENDS
EXTRN	_Py_SetComp:PROC
EXTRN	_Py_ListComp:PROC
EXTRN	_Py_GeneratorExp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_itercomp DD imagerel ast_for_itercomp
	DD	imagerel ast_for_itercomp+188
	DD	imagerel $unwind$ast_for_itercomp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_itercomp DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_itercomp
_TEXT	SEGMENT
c$ = 64
n$ = 72
type$ = 80
ast_for_itercomp PROC					; COMDAT

; 1738 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b fa	 mov	 rdi, rdx

; 1739 :     /* testlist_comp: test ( comp_for | (',' test)* [','] )
; 1740 :        argument: [test '='] test [comp_for]       # Really [keyword '='] test */
; 1741 :     expr_ty elt;
; 1742 :     asdl_seq *comps;
; 1743 : 
; 1744 :     assert(NCH(n) > 1);
; 1745 : 
; 1746 :     elt = ast_for_expr(c, CHILD(n, 0));

  00017	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  0001b	41 8b d8	 mov	 ebx, r8d
  0001e	48 8b f1	 mov	 rsi, rcx
  00021	e8 00 00 00 00	 call	 ast_for_expr
  00026	48 8b e8	 mov	 rbp, rax

; 1747 :     if (!elt)

  00029	48 85 c0	 test	 rax, rax

; 1748 :         return NULL;

  0002c	74 77		 je	 SHORT $LN2@ast_for_it

; 1749 : 
; 1750 :     comps = ast_for_comprehension(c, CHILD(n, 1));

  0002e	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  00032	48 8b ce	 mov	 rcx, rsi
  00035	48 83 c2 28	 add	 rdx, 40			; 00000028H
  00039	e8 00 00 00 00	 call	 ast_for_comprehension
  0003e	48 8b d0	 mov	 rdx, rax

; 1751 :     if (!comps)

  00041	48 85 c0	 test	 rax, rax

; 1752 :         return NULL;

  00044	74 5f		 je	 SHORT $LN2@ast_for_it

; 1753 : 
; 1754 :     if (type == COMP_GENEXP)

  00046	85 db		 test	 ebx, ebx
  00048	75 1b		 jne	 SHORT $LN6@ast_for_it

; 1755 :         return GeneratorExp(elt, comps, LINENO(n), n->n_col_offset, c->c_arena);

  0004a	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  0004e	44 8b 4f 14	 mov	 r9d, DWORD PTR [rdi+20]
  00052	44 8b 47 10	 mov	 r8d, DWORD PTR [rdi+16]
  00056	48 8b cd	 mov	 rcx, rbp
  00059	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005e	e8 00 00 00 00	 call	 _Py_GeneratorExp
  00063	eb 42		 jmp	 SHORT $LN1@ast_for_it
$LN6@ast_for_it:

; 1756 :     else if (type == COMP_LISTCOMP)

  00065	83 fb 01	 cmp	 ebx, 1
  00068	75 1b		 jne	 SHORT $LN4@ast_for_it

; 1757 :         return ListComp(elt, comps, LINENO(n), n->n_col_offset, c->c_arena);

  0006a	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  0006e	44 8b 4f 14	 mov	 r9d, DWORD PTR [rdi+20]
  00072	44 8b 47 10	 mov	 r8d, DWORD PTR [rdi+16]
  00076	48 8b cd	 mov	 rcx, rbp
  00079	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007e	e8 00 00 00 00	 call	 _Py_ListComp
  00083	eb 22		 jmp	 SHORT $LN1@ast_for_it
$LN4@ast_for_it:

; 1758 :     else if (type == COMP_SETCOMP)

  00085	83 fb 02	 cmp	 ebx, 2
  00088	75 1b		 jne	 SHORT $LN2@ast_for_it

; 1759 :         return SetComp(elt, comps, LINENO(n), n->n_col_offset, c->c_arena);

  0008a	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  0008e	44 8b 4f 14	 mov	 r9d, DWORD PTR [rdi+20]
  00092	44 8b 47 10	 mov	 r8d, DWORD PTR [rdi+16]
  00096	48 8b cd	 mov	 rcx, rbp
  00099	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009e	e8 00 00 00 00	 call	 _Py_SetComp
  000a3	eb 02		 jmp	 SHORT $LN1@ast_for_it
$LN2@ast_for_it:

; 1760 :     else
; 1761 :         /* Should never happen */
; 1762 :         return NULL;

  000a5	33 c0		 xor	 eax, eax
$LN1@ast_for_it:

; 1763 : }

  000a7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ac	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000b1	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000b6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
ast_for_itercomp ENDP
_TEXT	ENDS
EXTRN	_Py_DictComp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_dictcomp DD imagerel ast_for_dictcomp
	DD	imagerel ast_for_dictcomp+163
	DD	imagerel $unwind$ast_for_dictcomp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_dictcomp DD 084201H
	DD	086442H
	DD	0a540fH
	DD	09340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_dictcomp
_TEXT	SEGMENT
c$ = 64
n$ = 72
ast_for_dictcomp PROC					; COMDAT

; 1767 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b da	 mov	 rbx, rdx

; 1768 :     expr_ty key, value;
; 1769 :     asdl_seq *comps;
; 1770 : 
; 1771 :     assert(NCH(n) > 3);
; 1772 :     REQ(CHILD(n, 1), COLON);
; 1773 : 
; 1774 :     key = ast_for_expr(c, CHILD(n, 0));

  00012	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00016	48 8b f9	 mov	 rdi, rcx
  00019	e8 00 00 00 00	 call	 ast_for_expr
  0001e	48 8b e8	 mov	 rbp, rax

; 1775 :     if (!key)

  00021	48 85 c0	 test	 rax, rax
  00024	75 10		 jne	 SHORT $LN3@ast_for_di

; 1786 : }

  00026	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0002b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00030	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
$LN3@ast_for_di:

; 1776 :         return NULL;
; 1777 :     value = ast_for_expr(c, CHILD(n, 2));

  00036	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  0003a	48 8b cf	 mov	 rcx, rdi
  0003d	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00042	48 83 c2 50	 add	 rdx, 80			; 00000050H
  00046	e8 00 00 00 00	 call	 ast_for_expr
  0004b	48 8b f0	 mov	 rsi, rax

; 1778 :     if (!value)

  0004e	48 85 c0	 test	 rax, rax

; 1779 :         return NULL;

  00051	74 18		 je	 SHORT $LN7@ast_for_di

; 1780 : 
; 1781 :     comps = ast_for_comprehension(c, CHILD(n, 3));

  00053	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00057	48 8b cf	 mov	 rcx, rdi
  0005a	48 83 c2 78	 add	 rdx, 120		; 00000078H
  0005e	e8 00 00 00 00	 call	 ast_for_comprehension
  00063	4c 8b c0	 mov	 r8, rax

; 1782 :     if (!comps)

  00066	48 85 c0	 test	 rax, rax
  00069	75 04		 jne	 SHORT $LN1@ast_for_di
$LN7@ast_for_di:

; 1783 :         return NULL;

  0006b	33 c0		 xor	 eax, eax
  0006d	eb 1f		 jmp	 SHORT $LN6@ast_for_di
$LN1@ast_for_di:

; 1784 : 
; 1785 :     return DictComp(key, value, comps, LINENO(n), n->n_col_offset, c->c_arena);

  0006f	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00073	44 8b 4b 10	 mov	 r9d, DWORD PTR [rbx+16]
  00077	48 8b d6	 mov	 rdx, rsi
  0007a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0007f	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  00082	48 8b cd	 mov	 rcx, rbp
  00085	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00089	e8 00 00 00 00	 call	 _Py_DictComp
$LN6@ast_for_di:

; 1786 : }

  0008e	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00093	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00098	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0009d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a1	5f		 pop	 rdi
  000a2	c3		 ret	 0
ast_for_dictcomp ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ast_for_genexp
_TEXT	SEGMENT
c$ = 8
n$ = 16
ast_for_genexp PROC					; COMDAT

; 1791 :     assert(TYPE(n) == (testlist_comp) || TYPE(n) == (argument));
; 1792 :     return ast_for_itercomp(c, n, COMP_GENEXP);

  00000	45 33 c0	 xor	 r8d, r8d

; 1793 : }

  00003	e9 00 00 00 00	 jmp	 ast_for_itercomp
ast_for_genexp ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ast_for_listcomp
_TEXT	SEGMENT
c$ = 8
n$ = 16
ast_for_listcomp PROC					; COMDAT

; 1798 :     assert(TYPE(n) == (testlist_comp));
; 1799 :     return ast_for_itercomp(c, n, COMP_LISTCOMP);

  00000	41 b8 01 00 00
	00		 mov	 r8d, 1

; 1800 : }

  00006	e9 00 00 00 00	 jmp	 ast_for_itercomp
ast_for_listcomp ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ast_for_setcomp
_TEXT	SEGMENT
c$ = 8
n$ = 16
ast_for_setcomp PROC					; COMDAT

; 1805 :     assert(TYPE(n) == (dictorsetmaker));
; 1806 :     return ast_for_itercomp(c, n, COMP_SETCOMP);

  00000	41 b8 02 00 00
	00		 mov	 r8d, 2

; 1807 : }

  00006	e9 00 00 00 00	 jmp	 ast_for_itercomp
ast_for_setcomp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@OKEJGOIF@unhandled?5atom?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0BD@PNBHIMCO@?$CI?$CFs?$CJ?5unknown?5error?$AA@ ; `string'
PUBLIC	??_C@_07PGAKHMFE@?$CI?$CFs?$CJ?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0M@LMMBHDGD@value?5error?$AA@		; `string'
PUBLIC	??_C@_0O@PKBKOBHA@unicode?5error?$AA@		; `string'
EXTRN	_Py_Set:PROC
EXTRN	_Py_Dict:PROC
EXTRN	_Py_List:PROC
EXTRN	_Py_Ellipsis:PROC
EXTRN	_Py_Num:PROC
EXTRN	_Py_Str:PROC
EXTRN	_Py_Bytes:PROC
EXTRN	PyUnicode_AsUTF8:PROC
EXTRN	PyObject_Str:PROC
EXTRN	PyErr_Fetch:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_UnicodeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_atom DD imagerel ast_for_atom
	DD	imagerel ast_for_atom+912
	DD	imagerel $unwind$ast_for_atom
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ast_for_atom DD imagerel ast_for_atom+912
	DD	imagerel ast_for_atom+1006
	DD	imagerel $chain$0$ast_for_atom
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ast_for_atom DD imagerel ast_for_atom+1006
	DD	imagerel ast_for_atom+1073
	DD	imagerel $chain$1$ast_for_atom
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ast_for_atom DD imagerel ast_for_atom+1073
	DD	imagerel ast_for_atom+1218
	DD	imagerel $chain$2$ast_for_atom
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ast_for_atom DD imagerel ast_for_atom+1218
	DD	imagerel ast_for_atom+1226
	DD	imagerel $chain$3$ast_for_atom
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ast_for_atom DD imagerel ast_for_atom+1226
	DD	imagerel ast_for_atom+1246
	DD	imagerel $chain$4$ast_for_atom
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$ast_for_atom DD imagerel ast_for_atom+1246
	DD	imagerel ast_for_atom+1250
	DD	imagerel $chain$6$ast_for_atom
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$ast_for_atom DD imagerel ast_for_atom+1250
	DD	imagerel ast_for_atom+1381
	DD	imagerel $chain$7$ast_for_atom
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$ast_for_atom DD imagerel ast_for_atom+1381
	DD	imagerel ast_for_atom+1499
	DD	imagerel $chain$8$ast_for_atom
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$ast_for_atom DD 021H
	DD	imagerel ast_for_atom
	DD	imagerel ast_for_atom+912
	DD	imagerel $unwind$ast_for_atom
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$ast_for_atom DD 020021H
	DD	018c400H
	DD	imagerel ast_for_atom
	DD	imagerel ast_for_atom+912
	DD	imagerel $unwind$ast_for_atom
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$ast_for_atom DD 060021H
	DD	016e400H
	DD	017d400H
	DD	018c400H
	DD	imagerel ast_for_atom
	DD	imagerel ast_for_atom+912
	DD	imagerel $unwind$ast_for_atom
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ast_for_atom DD 021H
	DD	imagerel ast_for_atom+912
	DD	imagerel ast_for_atom+1006
	DD	imagerel $chain$0$ast_for_atom
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ast_for_atom DD 021H
	DD	imagerel ast_for_atom+1006
	DD	imagerel ast_for_atom+1073
	DD	imagerel $chain$1$ast_for_atom
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ast_for_atom DD 020821H
	DD	017d408H
	DD	imagerel ast_for_atom+1006
	DD	imagerel ast_for_atom+1073
	DD	imagerel $chain$1$ast_for_atom
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ast_for_atom DD 020821H
	DD	016e408H
	DD	imagerel ast_for_atom+912
	DD	imagerel ast_for_atom+1006
	DD	imagerel $chain$0$ast_for_atom
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ast_for_atom DD 020821H
	DD	018c408H
	DD	imagerel ast_for_atom
	DD	imagerel ast_for_atom+912
	DD	imagerel $unwind$ast_for_atom
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_atom DD 060c01H
	DD	019010cH
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT ??_C@_0BC@OKEJGOIF@unhandled?5atom?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BC@OKEJGOIF@unhandled?5atom?5?$CFd?$AA@ DB 'unhandled atom %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PNBHIMCO@?$CI?$CFs?$CJ?5unknown?5error?$AA@
CONST	SEGMENT
??_C@_0BD@PNBHIMCO@?$CI?$CFs?$CJ?5unknown?5error?$AA@ DB '(%s) unknown er'
	DB	'ror', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07PGAKHMFE@?$CI?$CFs?$CJ?5?$CFs?$AA@
CONST	SEGMENT
??_C@_07PGAKHMFE@?$CI?$CFs?$CJ?5?$CFs?$AA@ DB '(%s) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LMMBHDGD@value?5error?$AA@
CONST	SEGMENT
??_C@_0M@LMMBHDGD@value?5error?$AA@ DB 'value error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PKBKOBHA@unicode?5error?$AA@
CONST	SEGMENT
??_C@_0O@PKBKOBHA@unicode?5error?$AA@ DB 'unicode error', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ast_for_atom
_TEXT	SEGMENT
buf$23001 = 48
c$ = 240
value$23003 = 248
bytesmode$ = 248
n$ = 248
type$23002 = 256
tback$23004 = 264
ast_for_atom PROC					; COMDAT

; 1812 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 1813 :     /* atom: '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']'
; 1814 :        | '{' [dictmaker|testlist_comp] '}' | NAME | NUMBER | STRING+
; 1815 :        | '...' | 'None' | 'True' | 'False'
; 1816 :     */
; 1817 :     node *ch = CHILD(n, 0);

  0000c	48 8b 6a 20	 mov	 rbp, QWORD PTR [rdx+32]

; 1818 :     int bytesmode = 0;

  00010	33 ff		 xor	 edi, edi
  00012	48 8b f2	 mov	 rsi, rdx

; 1819 : 
; 1820 :     switch (TYPE(ch)) {

  00015	44 0f bf 45 00	 movsx	 r8d, WORD PTR [rbp]
  0001a	48 8b d9	 mov	 rbx, rcx
  0001d	89 bc 24 f8 00
	00 00		 mov	 DWORD PTR bytesmode$[rsp], edi
  00024	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  00028	83 f8 32	 cmp	 eax, 50			; 00000032H
  0002b	0f 87 34 05 00
	00		 ja	 $LN9@ast_for_at
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00038	48 98		 cdqe
  0003a	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN65@ast_for_at[rcx+rax]
  00042	8b 94 81 00 00
	00 00		 mov	 edx, DWORD PTR $LN66@ast_for_at[rcx+rax*4]
  00049	48 03 d1	 add	 rdx, rcx
  0004c	ff e2		 jmp	 rdx
$LN52@ast_for_at:

; 1821 :     case NAME: {
; 1822 :         /* All names start in Load context, but may later be
; 1823 :            changed. */
; 1824 :         PyObject *name = NEW_IDENTIFIER(ch);

  0004e	48 8b 4d 08	 mov	 rcx, QWORD PTR [rbp+8]
  00052	48 8b d3	 mov	 rdx, rbx
  00055	e8 00 00 00 00	 call	 new_identifier
  0005a	48 8b c8	 mov	 rcx, rax

; 1825 :         if (!name)

  0005d	48 85 c0	 test	 rax, rax

; 1826 :             return NULL;

  00060	0f 84 31 01 00
	00		 je	 $LN40@ast_for_at

; 1827 :         return Name(name, Load, LINENO(n), n->n_col_offset, c->c_arena);

  00066	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0006a	44 8b 4e 14	 mov	 r9d, DWORD PTR [rsi+20]
  0006e	44 8b 46 10	 mov	 r8d, DWORD PTR [rsi+16]
  00072	ba 01 00 00 00	 mov	 edx, 1
  00077	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007c	e8 00 00 00 00	 call	 _Py_Name

; 1964 :     }
; 1965 : }

  00081	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00088	5f		 pop	 rdi
  00089	5e		 pop	 rsi
  0008a	5d		 pop	 rbp
  0008b	5b		 pop	 rbx
  0008c	c3		 ret	 0
$LN50@ast_for_at:

; 1828 :     }
; 1829 :     case STRING: {
; 1830 :         PyObject *str = parsestrplus(c, n, &bytesmode);

  0008d	4c 8d 84 24 f8
	00 00 00	 lea	 r8, QWORD PTR bytesmode$[rsp]
  00095	48 8b d6	 mov	 rdx, rsi
  00098	48 8b cb	 mov	 rcx, rbx
  0009b	e8 00 00 00 00	 call	 parsestrplus
  000a0	48 8b f8	 mov	 rdi, rax

; 1831 :         if (!str) {

  000a3	48 85 c0	 test	 rax, rax
  000a6	0f 85 f9 00 00
	00		 jne	 $LN49@ast_for_at

; 1832 :             const char *errtype = NULL;
; 1833 :             if (PyErr_ExceptionMatches(PyExc_UnicodeError))

  000ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnicodeError
  000b3	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  000b8	85 c0		 test	 eax, eax
  000ba	74 09		 je	 SHORT $LN48@ast_for_at

; 1834 :                 errtype = "unicode error";

  000bc	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0O@PKBKOBHA@unicode?5error?$AA@
  000c3	eb 1b		 jmp	 SHORT $LN64@ast_for_at
$LN48@ast_for_at:

; 1835 :             else if (PyErr_ExceptionMatches(PyExc_ValueError))

  000c5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000cc	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  000d1	85 c0		 test	 eax, eax
  000d3	0f 84 be 00 00
	00		 je	 $LN40@ast_for_at

; 1836 :                 errtype = "value error";

  000d9	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0M@LMMBHDGD@value?5error?$AA@
$LN64@ast_for_at:

; 1837 :             if (errtype) {
; 1838 :                 char buf[128];
; 1839 :                 PyObject *type, *value, *tback, *errstr;
; 1840 :                 PyErr_Fetch(&type, &value, &tback);

  000e0	4c 8d 84 24 08
	01 00 00	 lea	 r8, QWORD PTR tback$23004[rsp]
  000e8	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR value$23003[rsp]
  000f0	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR type$23002[rsp]
  000f8	e8 00 00 00 00	 call	 PyErr_Fetch

; 1841 :                 errstr = PyObject_Str(value);

  000fd	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR value$23003[rsp]
  00105	e8 00 00 00 00	 call	 PyObject_Str
  0010a	48 8b e8	 mov	 rbp, rax

; 1842 :                 if (errstr) {

  0010d	48 85 c0	 test	 rax, rax
  00110	74 30		 je	 SHORT $LN44@ast_for_at

; 1843 :                     char *s = _PyUnicode_AsString(errstr);

  00112	48 8b c8	 mov	 rcx, rax
  00115	e8 00 00 00 00	 call	 PyUnicode_AsUTF8

; 1844 :                     PyOS_snprintf(buf, sizeof(buf), "(%s) %s", errtype, s);

  0011a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07PGAKHMFE@?$CI?$CFs?$CJ?5?$CFs?$AA@
  00121	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$23001[rsp]
  00126	4c 8b cf	 mov	 r9, rdi
  00129	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0012e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00133	e8 00 00 00 00	 call	 PyOS_snprintf

; 1845 :                     Py_DECREF(errstr);

  00138	48 8b cd	 mov	 rcx, rbp
  0013b	e8 00 00 00 00	 call	 _Py_DecRef

; 1846 :                 } else {

  00140	eb 19		 jmp	 SHORT $LN43@ast_for_at
$LN44@ast_for_at:

; 1847 :                     PyOS_snprintf(buf, sizeof(buf), "(%s) unknown error", errtype);

  00142	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BD@PNBHIMCO@?$CI?$CFs?$CJ?5unknown?5error?$AA@
  00149	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$23001[rsp]
  0014e	4c 8b cf	 mov	 r9, rdi
  00151	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00156	e8 00 00 00 00	 call	 PyOS_snprintf
$LN43@ast_for_at:

; 1848 :                 }
; 1849 :                 ast_error(c, n, buf);

  0015b	4c 8d 44 24 30	 lea	 r8, QWORD PTR buf$23001[rsp]
  00160	48 8b d6	 mov	 rdx, rsi
  00163	48 8b cb	 mov	 rcx, rbx
  00166	e8 00 00 00 00	 call	 ast_error

; 1850 :                 Py_DECREF(type);

  0016b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR type$23002[rsp]
  00173	e8 00 00 00 00	 call	 _Py_DecRef

; 1851 :                 Py_DECREF(value);

  00178	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR value$23003[rsp]
  00180	e8 00 00 00 00	 call	 _Py_DecRef

; 1852 :                 Py_XDECREF(tback);

  00185	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tback$23004[rsp]
  0018d	48 85 c9	 test	 rcx, rcx
  00190	74 05		 je	 SHORT $LN40@ast_for_at
  00192	e8 00 00 00 00	 call	 _Py_DecRef
$LN40@ast_for_at:

; 1853 :             }
; 1854 :             return NULL;

  00197	33 c0		 xor	 eax, eax

; 1964 :     }
; 1965 : }

  00199	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  001a0	5f		 pop	 rdi
  001a1	5e		 pop	 rsi
  001a2	5d		 pop	 rbp
  001a3	5b		 pop	 rbx
  001a4	c3		 ret	 0
$LN49@ast_for_at:

; 1855 :         }
; 1856 :         PyArena_AddPyObject(c->c_arena, str);

  001a5	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  001a9	48 8b d0	 mov	 rdx, rax
  001ac	e8 00 00 00 00	 call	 PyArena_AddPyObject

; 1857 :         if (bytesmode)

  001b1	83 bc 24 f8 00
	00 00 00	 cmp	 DWORD PTR bytesmode$[rsp], 0

; 1858 :             return Bytes(str, LINENO(n), n->n_col_offset, c->c_arena);

  001b9	4c 8b 4b 08	 mov	 r9, QWORD PTR [rbx+8]
  001bd	44 8b 46 14	 mov	 r8d, DWORD PTR [rsi+20]
  001c1	8b 56 10	 mov	 edx, DWORD PTR [rsi+16]
  001c4	48 8b cf	 mov	 rcx, rdi
  001c7	74 10		 je	 SHORT $LN38@ast_for_at

; 1964 :     }
; 1965 : }

  001c9	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  001d0	5f		 pop	 rdi
  001d1	5e		 pop	 rsi
  001d2	5d		 pop	 rbp
  001d3	5b		 pop	 rbx
  001d4	e9 00 00 00 00	 jmp	 _Py_Bytes
$LN38@ast_for_at:
  001d9	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  001e0	5f		 pop	 rdi
  001e1	5e		 pop	 rsi
  001e2	5d		 pop	 rbp
  001e3	5b		 pop	 rbx
  001e4	e9 00 00 00 00	 jmp	 _Py_Str
$LN37@ast_for_at:

; 1859 :         else
; 1860 :             return Str(str, LINENO(n), n->n_col_offset, c->c_arena);
; 1861 :     }
; 1862 :     case NUMBER: {
; 1863 :         PyObject *pynum = parsenumber(c, STR(ch));

  001e9	48 8b 4d 08	 mov	 rcx, QWORD PTR [rbp+8]
  001ed	e8 00 00 00 00	 call	 parsenumber
  001f2	48 8b f8	 mov	 rdi, rax

; 1864 :         if (!pynum)

  001f5	48 85 c0	 test	 rax, rax

; 1865 :             return NULL;

  001f8	74 9d		 je	 SHORT $LN40@ast_for_at

; 1866 : 
; 1867 :         PyArena_AddPyObject(c->c_arena, pynum);

  001fa	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  001fe	48 8b d0	 mov	 rdx, rax
  00201	e8 00 00 00 00	 call	 PyArena_AddPyObject

; 1868 :         return Num(pynum, LINENO(n), n->n_col_offset, c->c_arena);

  00206	4c 8b 4b 08	 mov	 r9, QWORD PTR [rbx+8]
  0020a	44 8b 46 14	 mov	 r8d, DWORD PTR [rsi+20]
  0020e	8b 56 10	 mov	 edx, DWORD PTR [rsi+16]
  00211	48 8b cf	 mov	 rcx, rdi

; 1964 :     }
; 1965 : }

  00214	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0021b	5f		 pop	 rdi
  0021c	5e		 pop	 rsi
  0021d	5d		 pop	 rbp
  0021e	5b		 pop	 rbx
  0021f	e9 00 00 00 00	 jmp	 _Py_Num
$LN34@ast_for_at:

; 1869 :     }
; 1870 :     case ELLIPSIS: /* Ellipsis */
; 1871 :         return Ellipsis(LINENO(n), n->n_col_offset, c->c_arena);

  00224	4c 8b 43 08	 mov	 r8, QWORD PTR [rbx+8]
  00228	8b 56 14	 mov	 edx, DWORD PTR [rsi+20]
  0022b	8b 4e 10	 mov	 ecx, DWORD PTR [rsi+16]

; 1964 :     }
; 1965 : }

  0022e	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00235	5f		 pop	 rdi
  00236	5e		 pop	 rsi
  00237	5d		 pop	 rbp
  00238	5b		 pop	 rbx
  00239	e9 00 00 00 00	 jmp	 _Py_Ellipsis
$LN33@ast_for_at:

; 1872 :     case LPAR: /* some parenthesized expressions */
; 1873 :         ch = CHILD(n, 1);
; 1874 : 
; 1875 :         if (TYPE(ch) == RPAR)

  0023e	0f b7 45 28	 movzx	 eax, WORD PTR [rbp+40]
  00242	48 8d 55 28	 lea	 rdx, QWORD PTR [rbp+40]
  00246	66 83 f8 08	 cmp	 ax, 8
  0024a	75 29		 jne	 SHORT $LN32@ast_for_at

; 1876 :             return Tuple(NULL, Load, LINENO(n), n->n_col_offset, c->c_arena);

  0024c	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00250	44 8b 4e 14	 mov	 r9d, DWORD PTR [rsi+20]
  00254	44 8b 46 10	 mov	 r8d, DWORD PTR [rsi+16]
  00258	ba 01 00 00 00	 mov	 edx, 1
  0025d	33 c9		 xor	 ecx, ecx
  0025f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00264	e8 00 00 00 00	 call	 _Py_Tuple

; 1964 :     }
; 1965 : }

  00269	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00270	5f		 pop	 rdi
  00271	5e		 pop	 rsi
  00272	5d		 pop	 rbp
  00273	5b		 pop	 rbx
  00274	c3		 ret	 0
$LN32@ast_for_at:

; 1877 : 
; 1878 :         if (TYPE(ch) == yield_expr)

  00275	b9 50 01 00 00	 mov	 ecx, 336		; 00000150H
  0027a	66 3b c1	 cmp	 ax, cx
  0027d	75 13		 jne	 SHORT $LN31@ast_for_at

; 1879 :             return ast_for_expr(c, ch);

  0027f	48 8b cb	 mov	 rcx, rbx

; 1964 :     }
; 1965 : }

  00282	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00289	5f		 pop	 rdi
  0028a	5e		 pop	 rsi
  0028b	5d		 pop	 rbp
  0028c	5b		 pop	 rbx
  0028d	e9 00 00 00 00	 jmp	 ast_for_expr
$LN31@ast_for_at:

; 1880 : 
; 1881 :         /* testlist_comp: test ( comp_for | (',' test)* [','] ) */
; 1882 :         if ((NCH(ch) > 1) && (TYPE(CHILD(ch, 1)) == comp_for))

  00292	83 7a 18 01	 cmp	 DWORD PTR [rdx+24], 1
  00296	7e 22		 jle	 SHORT $LN30@ast_for_at
  00298	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  0029c	b9 4d 01 00 00	 mov	 ecx, 333		; 0000014dH
  002a1	66 39 48 28	 cmp	 WORD PTR [rax+40], cx
  002a5	75 13		 jne	 SHORT $LN30@ast_for_at

; 1883 :             return ast_for_genexp(c, ch);

  002a7	48 8b cb	 mov	 rcx, rbx

; 1964 :     }
; 1965 : }

  002aa	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  002b1	5f		 pop	 rdi
  002b2	5e		 pop	 rsi
  002b3	5d		 pop	 rbp
  002b4	5b		 pop	 rbx
  002b5	e9 00 00 00 00	 jmp	 ast_for_genexp
$LN30@ast_for_at:

; 1884 : 
; 1885 :         return ast_for_testlist(c, ch);

  002ba	48 8b cb	 mov	 rcx, rbx

; 1964 :     }
; 1965 : }

  002bd	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  002c4	5f		 pop	 rdi
  002c5	5e		 pop	 rsi
  002c6	5d		 pop	 rbp
  002c7	5b		 pop	 rbx
  002c8	e9 00 00 00 00	 jmp	 ast_for_testlist
$LN29@ast_for_at:

; 1886 :     case LSQB: /* list (or list comprehension) */
; 1887 :         ch = CHILD(n, 1);
; 1888 : 
; 1889 :         if (TYPE(ch) == RSQB)

  002cd	66 83 7d 28 0a	 cmp	 WORD PTR [rbp+40], 10
  002d2	48 8d 55 28	 lea	 rdx, QWORD PTR [rbp+40]
  002d6	75 29		 jne	 SHORT $LN28@ast_for_at

; 1890 :             return List(NULL, Load, LINENO(n), n->n_col_offset, c->c_arena);

  002d8	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  002dc	44 8b 4e 14	 mov	 r9d, DWORD PTR [rsi+20]
  002e0	44 8b 46 10	 mov	 r8d, DWORD PTR [rsi+16]
  002e4	ba 01 00 00 00	 mov	 edx, 1
  002e9	33 c9		 xor	 ecx, ecx
  002eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f0	e8 00 00 00 00	 call	 _Py_List

; 1964 :     }
; 1965 : }

  002f5	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  002fc	5f		 pop	 rdi
  002fd	5e		 pop	 rsi
  002fe	5d		 pop	 rbp
  002ff	5b		 pop	 rbx
  00300	c3		 ret	 0
$LN28@ast_for_at:

; 1891 : 
; 1892 :         REQ(ch, testlist_comp);
; 1893 :         if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == COMMA) {

  00301	83 7a 18 01	 cmp	 DWORD PTR [rdx+24], 1
  00305	74 1e		 je	 SHORT $LN26@ast_for_at
  00307	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  0030b	66 83 78 28 0c	 cmp	 WORD PTR [rax+40], 12
  00310	74 13		 je	 SHORT $LN26@ast_for_at

; 1899 :         }
; 1900 :         else
; 1901 :             return ast_for_listcomp(c, ch);

  00312	48 8b cb	 mov	 rcx, rbx

; 1964 :     }
; 1965 : }

  00315	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0031c	5f		 pop	 rdi
  0031d	5e		 pop	 rsi
  0031e	5d		 pop	 rbp
  0031f	5b		 pop	 rbx
  00320	e9 00 00 00 00	 jmp	 ast_for_listcomp
$LN26@ast_for_at:

; 1894 :             asdl_seq *elts = seq_for_testlist(c, ch);

  00325	48 8b cb	 mov	 rcx, rbx
  00328	e8 00 00 00 00	 call	 seq_for_testlist
  0032d	48 8b c8	 mov	 rcx, rax

; 1895 :             if (!elts)

  00330	48 85 c0	 test	 rax, rax

; 1896 :                 return NULL;

  00333	0f 84 5e fe ff
	ff		 je	 $LN40@ast_for_at

; 1897 : 
; 1898 :             return List(elts, Load, LINENO(n), n->n_col_offset, c->c_arena);

  00339	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0033d	44 8b 4e 14	 mov	 r9d, DWORD PTR [rsi+20]
  00341	44 8b 46 10	 mov	 r8d, DWORD PTR [rsi+16]
  00345	ba 01 00 00 00	 mov	 edx, 1
  0034a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0034f	e8 00 00 00 00	 call	 _Py_List

; 1964 :     }
; 1965 : }

  00354	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0035b	5f		 pop	 rdi
  0035c	5e		 pop	 rsi
  0035d	5d		 pop	 rbp
  0035e	5b		 pop	 rbx
  0035f	c3		 ret	 0
$LN24@ast_for_at:

; 1902 :     case LBRACE: {
; 1903 :         /* dictorsetmaker: test ':' test (',' test ':' test)* [','] |
; 1904 :          *                 test (gen_for | (',' test)* [','])  */
; 1905 :         int i, size;
; 1906 :         asdl_seq *keys, *values;
; 1907 : 
; 1908 :         ch = CHILD(n, 1);
; 1909 :         if (TYPE(ch) == RBRACE) {

  00360	66 83 7d 28 1a	 cmp	 WORD PTR [rbp+40], 26
  00365	75 26		 jne	 SHORT $LN22@ast_for_at

; 1910 :             /* it's an empty dict */
; 1911 :             return Dict(NULL, NULL, LINENO(n), n->n_col_offset, c->c_arena);

  00367	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0036b	44 8b 4e 14	 mov	 r9d, DWORD PTR [rsi+20]
  0036f	44 8b 46 10	 mov	 r8d, DWORD PTR [rsi+16]
  00373	33 d2		 xor	 edx, edx
  00375	33 c9		 xor	 ecx, ecx
  00377	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0037c	e8 00 00 00 00	 call	 _Py_Dict

; 1964 :     }
; 1965 : }

  00381	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00388	5f		 pop	 rdi
  00389	5e		 pop	 rsi
  0038a	5d		 pop	 rbp
  0038b	5b		 pop	 rbx
  0038c	c3		 ret	 0
$LN22@ast_for_at:

; 1912 :         } else if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == COMMA) {

  0038d	8b 45 40	 mov	 eax, DWORD PTR [rbp+64]
  00390	4c 89 a4 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], r12
  00398	83 f8 01	 cmp	 eax, 1
  0039b	0f 84 41 01 00
	00		 je	 $LN19@ast_for_at
  003a1	4c 8b 45 48	 mov	 r8, QWORD PTR [rbp+72]
  003a5	41 0f b7 50 28	 movzx	 edx, WORD PTR [r8+40]
  003aa	66 83 fa 0c	 cmp	 dx, 12
  003ae	0f 84 2e 01 00
	00		 je	 $LN19@ast_for_at

; 1927 :         } else if (TYPE(CHILD(ch, 1)) == comp_for) {

  003b4	b9 4d 01 00 00	 mov	 ecx, 333		; 0000014dH
  003b9	66 3b d1	 cmp	 dx, cx
  003bc	75 11		 jne	 SHORT $LN12@ast_for_at

; 1928 :             /* it's a set comprehension */
; 1929 :             return ast_for_setcomp(c, ch);

  003be	48 8d 55 28	 lea	 rdx, QWORD PTR [rbp+40]
  003c2	48 8b cb	 mov	 rcx, rbx
  003c5	e8 00 00 00 00	 call	 ast_for_setcomp
  003ca	e9 fb 00 00 00	 jmp	 $LN67@ast_for_at
$LN12@ast_for_at:

; 1930 :         } else if (NCH(ch) > 3 && TYPE(CHILD(ch, 3)) == comp_for) {

  003cf	83 f8 03	 cmp	 eax, 3
  003d2	7e 18		 jle	 SHORT $LN10@ast_for_at
  003d4	66 41 39 48 78	 cmp	 WORD PTR [r8+120], cx
  003d9	75 11		 jne	 SHORT $LN10@ast_for_at

; 1931 :             return ast_for_dictcomp(c, ch);

  003db	48 8d 55 28	 lea	 rdx, QWORD PTR [rbp+40]
  003df	48 8b cb	 mov	 rcx, rbx
  003e2	e8 00 00 00 00	 call	 ast_for_dictcomp
  003e7	e9 de 00 00 00	 jmp	 $LN67@ast_for_at
$LN10@ast_for_at:

; 1932 :         } else {
; 1933 :             /* it's a dict */
; 1934 :             size = (NCH(ch) + 1) / 4; /* +1 in case no trailing comma */

  003ec	ff c0		 inc	 eax
  003ee	4c 89 b4 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], r14
  003f6	99		 cdq
  003f7	83 e2 03	 and	 edx, 3
  003fa	03 c2		 add	 eax, edx

; 1935 :             keys = asdl_seq_new(size, c->c_arena);

  003fc	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00400	c1 f8 02	 sar	 eax, 2
  00403	4c 63 e0	 movsxd	 r12, eax
  00406	49 8b cc	 mov	 rcx, r12
  00409	e8 00 00 00 00	 call	 asdl_seq_new
  0040e	4c 8b f0	 mov	 r14, rax

; 1936 :             if (!keys)

  00411	48 85 c0	 test	 rax, rax

; 1937 :                 return NULL;

  00414	74 14		 je	 SHORT $LN70@ast_for_at

; 1938 : 
; 1939 :             values = asdl_seq_new(size, c->c_arena);

  00416	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  0041a	49 8b cc	 mov	 rcx, r12
  0041d	e8 00 00 00 00	 call	 asdl_seq_new
  00422	4c 8b e0	 mov	 r12, rax

; 1940 :             if (!values)

  00425	48 85 c0	 test	 rax, rax
  00428	75 07		 jne	 SHORT $LN7@ast_for_at
$LN70@ast_for_at:

; 1941 :                 return NULL;

  0042a	33 c0		 xor	 eax, eax
  0042c	e9 91 00 00 00	 jmp	 $LN68@ast_for_at
$LN7@ast_for_at:
  00431	4c 89 ac 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], r13

; 1942 : 
; 1943 :             for (i = 0; i < NCH(ch); i += 4) {

  00439	39 7d 40	 cmp	 DWORD PTR [rbp+64], edi
  0043c	7e 60		 jle	 SHORT $LN4@ast_for_at
  0043e	66 90		 npad	 2
$LL6@ast_for_at:

; 1944 :                 expr_ty expression;
; 1945 : 
; 1946 :                 expression = ast_for_expr(c, CHILD(ch, i));

  00440	48 63 c7	 movsxd	 rax, edi
  00443	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00447	48 8b 45 48	 mov	 rax, QWORD PTR [rbp+72]
  0044b	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  0044f	48 8b cb	 mov	 rcx, rbx
  00452	e8 00 00 00 00	 call	 ast_for_expr
  00457	4c 8b d8	 mov	 r11, rax

; 1947 :                 if (!expression)

  0045a	48 85 c0	 test	 rax, rax
  0045d	74 7f		 je	 SHORT $LN59@ast_for_at

; 1949 : 
; 1950 :                 asdl_seq_SET(keys, i / 4, expression);

  0045f	8b c7		 mov	 eax, edi
  00461	99		 cdq
  00462	83 e2 03	 and	 edx, 3
  00465	03 c2		 add	 eax, edx
  00467	c1 f8 02	 sar	 eax, 2
  0046a	4c 63 e8	 movsxd	 r13, eax

; 1951 : 
; 1952 :                 expression = ast_for_expr(c, CHILD(ch, i + 2));

  0046d	8d 47 02	 lea	 eax, DWORD PTR [rdi+2]
  00470	48 63 c8	 movsxd	 rcx, eax
  00473	4f 89 5c ee 08	 mov	 QWORD PTR [r14+r13*8+8], r11
  00478	48 8b 45 48	 mov	 rax, QWORD PTR [rbp+72]
  0047c	48 8d 14 89	 lea	 rdx, QWORD PTR [rcx+rcx*4]
  00480	48 8b cb	 mov	 rcx, rbx
  00483	48 8d 14 d0	 lea	 rdx, QWORD PTR [rax+rdx*8]
  00487	e8 00 00 00 00	 call	 ast_for_expr

; 1953 :                 if (!expression)

  0048c	48 85 c0	 test	 rax, rax
  0048f	74 4d		 je	 SHORT $LN59@ast_for_at

; 1954 :                     return NULL;
; 1955 : 
; 1956 :                 asdl_seq_SET(values, i / 4, expression);

  00491	83 c7 04	 add	 edi, 4
  00494	4b 89 44 ec 08	 mov	 QWORD PTR [r12+r13*8+8], rax
  00499	3b 7d 40	 cmp	 edi, DWORD PTR [rbp+64]
  0049c	7c a2		 jl	 SHORT $LL6@ast_for_at
$LN4@ast_for_at:

; 1957 :             }
; 1958 :             return Dict(keys, values, LINENO(n), n->n_col_offset, c->c_arena);

  0049e	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  004a2	44 8b 4e 14	 mov	 r9d, DWORD PTR [rsi+20]
  004a6	44 8b 46 10	 mov	 r8d, DWORD PTR [rsi+16]
  004aa	49 8b d4	 mov	 rdx, r12
  004ad	49 8b ce	 mov	 rcx, r14
  004b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004b5	e8 00 00 00 00	 call	 _Py_Dict
$LN69@ast_for_at:
  004ba	4c 8b ac 24 b8
	00 00 00	 mov	 r13, QWORD PTR [rsp+184]
$LN68@ast_for_at:
  004c2	4c 8b b4 24 b0
	00 00 00	 mov	 r14, QWORD PTR [rsp+176]
$LN67@ast_for_at:
  004ca	4c 8b a4 24 c0
	00 00 00	 mov	 r12, QWORD PTR [rsp+192]

; 1964 :     }
; 1965 : }

  004d2	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  004d9	5f		 pop	 rdi
  004da	5e		 pop	 rsi
  004db	5d		 pop	 rbp
  004dc	5b		 pop	 rbx
  004dd	c3		 ret	 0
$LN59@ast_for_at:

; 1948 :                     return NULL;

  004de	33 c0		 xor	 eax, eax
  004e0	eb d8		 jmp	 SHORT $LN69@ast_for_at
$LN19@ast_for_at:

; 1913 :             /* it's a simple set */
; 1914 :             asdl_seq *elts;
; 1915 :             size = (NCH(ch) + 1) / 2; /* +1 in case no trailing comma */

  004e2	ff c0		 inc	 eax
  004e4	99		 cdq
  004e5	2b c2		 sub	 eax, edx

; 1916 :             elts = asdl_seq_new(size, c->c_arena);

  004e7	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  004eb	d1 f8		 sar	 eax, 1
  004ed	48 63 c8	 movsxd	 rcx, eax
  004f0	e8 00 00 00 00	 call	 asdl_seq_new
  004f5	4c 8b e0	 mov	 r12, rax

; 1917 :             if (!elts)

  004f8	48 85 c0	 test	 rax, rax

; 1918 :                 return NULL;

  004fb	74 61		 je	 SHORT $LN61@ast_for_at

; 1919 :             for (i = 0; i < NCH(ch); i += 2) {

  004fd	39 7d 40	 cmp	 DWORD PTR [rbp+64], edi
  00500	7e 44		 jle	 SHORT $LN15@ast_for_at
  00502	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL17@ast_for_at:

; 1920 :                 expr_ty expression;
; 1921 :                 expression = ast_for_expr(c, CHILD(ch, i));

  00510	48 63 c7	 movsxd	 rax, edi
  00513	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00517	48 8b 45 48	 mov	 rax, QWORD PTR [rbp+72]
  0051b	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  0051f	48 8b cb	 mov	 rcx, rbx
  00522	e8 00 00 00 00	 call	 ast_for_expr
  00527	4c 8b d8	 mov	 r11, rax

; 1922 :                 if (!expression)

  0052a	48 85 c0	 test	 rax, rax
  0052d	74 2f		 je	 SHORT $LN61@ast_for_at

; 1924 :                 asdl_seq_SET(elts, i / 2, expression);

  0052f	8b c7		 mov	 eax, edi
  00531	83 c7 02	 add	 edi, 2
  00534	99		 cdq
  00535	2b c2		 sub	 eax, edx
  00537	d1 f8		 sar	 eax, 1
  00539	48 63 c8	 movsxd	 rcx, eax
  0053c	4d 89 5c cc 08	 mov	 QWORD PTR [r12+rcx*8+8], r11
  00541	3b 7d 40	 cmp	 edi, DWORD PTR [rbp+64]
  00544	7c ca		 jl	 SHORT $LL17@ast_for_at
$LN15@ast_for_at:

; 1925 :             }
; 1926 :             return Set(elts, LINENO(n), n->n_col_offset, c->c_arena);

  00546	4c 8b 4b 08	 mov	 r9, QWORD PTR [rbx+8]
  0054a	44 8b 46 14	 mov	 r8d, DWORD PTR [rsi+20]
  0054e	8b 56 10	 mov	 edx, DWORD PTR [rsi+16]
  00551	49 8b cc	 mov	 rcx, r12
  00554	e8 00 00 00 00	 call	 _Py_Set
  00559	e9 6c ff ff ff	 jmp	 $LN67@ast_for_at
$LN61@ast_for_at:

; 1923 :                     return NULL;

  0055e	33 c0		 xor	 eax, eax
  00560	e9 65 ff ff ff	 jmp	 $LN67@ast_for_at
$LN9@ast_for_at:

; 1959 :         }
; 1960 :     }
; 1961 :     default:
; 1962 :         PyErr_Format(PyExc_SystemError, "unhandled atom %d", TYPE(ch));

  00565	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0056c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@OKEJGOIF@unhandled?5atom?5?$CFd?$AA@
  00573	e8 00 00 00 00	 call	 PyErr_Format

; 1963 :         return NULL;

  00578	33 c0		 xor	 eax, eax

; 1964 :     }
; 1965 : }

  0057a	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00581	5f		 pop	 rdi
  00582	5e		 pop	 rsi
  00583	5d		 pop	 rbp
  00584	5b		 pop	 rbx
  00585	c3		 ret	 0
  00586	66 90		 npad	 2
$LN66@ast_for_at:
  00588	00 00 00 00	 DD	 $LN52@ast_for_at
  0058c	00 00 00 00	 DD	 $LN37@ast_for_at
  00590	00 00 00 00	 DD	 $LN50@ast_for_at
  00594	00 00 00 00	 DD	 $LN33@ast_for_at
  00598	00 00 00 00	 DD	 $LN29@ast_for_at
  0059c	00 00 00 00	 DD	 $LN24@ast_for_at
  005a0	00 00 00 00	 DD	 $LN34@ast_for_at
  005a4	00 00 00 00	 DD	 $LN9@ast_for_at
$LN65@ast_for_at:
  005a8	00		 DB	 0
  005a9	01		 DB	 1
  005aa	02		 DB	 2
  005ab	07		 DB	 7
  005ac	07		 DB	 7
  005ad	07		 DB	 7
  005ae	03		 DB	 3
  005af	07		 DB	 7
  005b0	04		 DB	 4
  005b1	07		 DB	 7
  005b2	07		 DB	 7
  005b3	07		 DB	 7
  005b4	07		 DB	 7
  005b5	07		 DB	 7
  005b6	07		 DB	 7
  005b7	07		 DB	 7
  005b8	07		 DB	 7
  005b9	07		 DB	 7
  005ba	07		 DB	 7
  005bb	07		 DB	 7
  005bc	07		 DB	 7
  005bd	07		 DB	 7
  005be	07		 DB	 7
  005bf	07		 DB	 7
  005c0	05		 DB	 5
  005c1	07		 DB	 7
  005c2	07		 DB	 7
  005c3	07		 DB	 7
  005c4	07		 DB	 7
  005c5	07		 DB	 7
  005c6	07		 DB	 7
  005c7	07		 DB	 7
  005c8	07		 DB	 7
  005c9	07		 DB	 7
  005ca	07		 DB	 7
  005cb	07		 DB	 7
  005cc	07		 DB	 7
  005cd	07		 DB	 7
  005ce	07		 DB	 7
  005cf	07		 DB	 7
  005d0	07		 DB	 7
  005d1	07		 DB	 7
  005d2	07		 DB	 7
  005d3	07		 DB	 7
  005d4	07		 DB	 7
  005d5	07		 DB	 7
  005d6	07		 DB	 7
  005d7	07		 DB	 7
  005d8	07		 DB	 7
  005d9	07		 DB	 7
  005da	06		 DB	 6
ast_for_atom ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_power DD imagerel ast_for_power
	DD	imagerel ast_for_power+281
	DD	imagerel $unwind$ast_for_power
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_power DD 0a5101H
	DD	0cd451H
	DD	0b644cH
	DD	0a5442H
	DD	0c0055209H
	DD	030027003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_power
_TEXT	SEGMENT
c$ = 80
n$ = 88
ast_for_power PROC					; COMDAT

; 2187 : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	48 8b fa	 mov	 rdi, rdx

; 2188 :     /* power: atom trailer* ('**' factor)*
; 2189 :      */
; 2190 :     int i;
; 2191 :     expr_ty e, tmp;
; 2192 :     REQ(n, power);
; 2193 :     e = ast_for_atom(c, CHILD(n, 0));

  0000c	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00010	4c 8b e1	 mov	 r12, rcx
  00013	e8 00 00 00 00	 call	 ast_for_atom
  00018	48 8b d8	 mov	 rbx, rax

; 2194 :     if (!e)

  0001b	48 85 c0	 test	 rax, rax
  0001e	75 09		 jne	 SHORT $LN10@ast_for_po

; 2219 : }

  00020	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00024	41 5c		 pop	 r12
  00026	5f		 pop	 rdi
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
$LN10@ast_for_po:

; 2195 :         return NULL;
; 2196 :     if (NCH(n) == 1)

  00029	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	75 0c		 jne	 SHORT $LN9@ast_for_po

; 2197 :         return e;

  00031	48 8b c3	 mov	 rax, rbx

; 2219 : }

  00034	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00038	41 5c		 pop	 r12
  0003a	5f		 pop	 rdi
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
$LN9@ast_for_po:
  0003d	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp

; 2198 :     for (i = 1; i < NCH(n); i++) {

  00042	bd 01 00 00 00	 mov	 ebp, 1
  00047	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  0004c	4c 89 6c 24 60	 mov	 QWORD PTR [rsp+96], r13
  00051	3b c5		 cmp	 eax, ebp
  00053	7e 44		 jle	 SHORT $LN6@ast_for_po
  00055	be 28 00 00 00	 mov	 esi, 40			; 00000028H
  0005a	41 bd 42 01 00
	00		 mov	 r13d, 322		; 00000142H
$LL8@ast_for_po:

; 2199 :         node *ch = CHILD(n, i);

  00060	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]

; 2200 :         if (TYPE(ch) != trailer)

  00064	66 44 39 2c 06	 cmp	 WORD PTR [rsi+rax], r13w
  00069	48 8d 14 06	 lea	 rdx, QWORD PTR [rsi+rax]
  0006d	75 2a		 jne	 SHORT $LN6@ast_for_po

; 2201 :             break;
; 2202 :         tmp = ast_for_trailer(c, ch, e);

  0006f	4c 8b c3	 mov	 r8, rbx
  00072	49 8b cc	 mov	 rcx, r12
  00075	e8 00 00 00 00	 call	 ast_for_trailer

; 2203 :         if (!tmp)

  0007a	48 85 c0	 test	 rax, rax
  0007d	74 7b		 je	 SHORT $LN20@ast_for_po

; 2204 :             return NULL;
; 2205 :         tmp->lineno = e->lineno;

  0007f	8b 4b 30	 mov	 ecx, DWORD PTR [rbx+48]
  00082	ff c5		 inc	 ebp
  00084	48 83 c6 28	 add	 rsi, 40			; 00000028H
  00088	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 2206 :         tmp->col_offset = e->col_offset;

  0008b	8b 4b 34	 mov	 ecx, DWORD PTR [rbx+52]

; 2207 :         e = tmp;

  0008e	48 8b d8	 mov	 rbx, rax
  00091	89 48 34	 mov	 DWORD PTR [rax+52], ecx
  00094	3b 6f 18	 cmp	 ebp, DWORD PTR [rdi+24]
  00097	7c c7		 jl	 SHORT $LL8@ast_for_po
$LN6@ast_for_po:

; 2208 :     }
; 2209 :     if (TYPE(CHILD(n, NCH(n) - 1)) == factor) {

  00099	48 63 57 18	 movsxd	 rdx, DWORD PTR [rdi+24]
  0009d	4c 8b 47 20	 mov	 r8, QWORD PTR [rdi+32]
  000a1	b8 3e 01 00 00	 mov	 eax, 318		; 0000013eH
  000a6	48 8d 0c 92	 lea	 rcx, QWORD PTR [rdx+rdx*4]
  000aa	66 41 39 44 c8
	d8		 cmp	 WORD PTR [r8+rcx*8-40], ax
  000b0	75 4c		 jne	 SHORT $LN1@ast_for_po

; 2210 :         expr_ty f = ast_for_expr(c, CHILD(n, NCH(n) - 1));

  000b2	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  000b5	48 63 c8	 movsxd	 rcx, eax
  000b8	48 8d 04 89	 lea	 rax, QWORD PTR [rcx+rcx*4]
  000bc	49 8b cc	 mov	 rcx, r12
  000bf	49 8d 14 c0	 lea	 rdx, QWORD PTR [r8+rax*8]
  000c3	e8 00 00 00 00	 call	 ast_for_expr
  000c8	4c 8b c0	 mov	 r8, rax

; 2211 :         if (!f)

  000cb	48 85 c0	 test	 rax, rax

; 2212 :             return NULL;

  000ce	74 2a		 je	 SHORT $LN20@ast_for_po

; 2213 :         tmp = BinOp(e, Pow, f, LINENO(n), n->n_col_offset, c->c_arena);

  000d0	49 8b 44 24 08	 mov	 rax, QWORD PTR [r12+8]
  000d5	44 8b 4f 10	 mov	 r9d, DWORD PTR [rdi+16]
  000d9	ba 06 00 00 00	 mov	 edx, 6
  000de	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000e3	8b 47 14	 mov	 eax, DWORD PTR [rdi+20]
  000e6	48 8b cb	 mov	 rcx, rbx
  000e9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000ed	e8 00 00 00 00	 call	 _Py_BinOp
  000f2	48 8b d8	 mov	 rbx, rax

; 2214 :         if (!tmp)

  000f5	48 85 c0	 test	 rax, rax
  000f8	75 04		 jne	 SHORT $LN1@ast_for_po
$LN20@ast_for_po:

; 2215 :             return NULL;

  000fa	33 c0		 xor	 eax, eax
  000fc	eb 03		 jmp	 SHORT $LN19@ast_for_po
$LN1@ast_for_po:

; 2216 :         e = tmp;
; 2217 :     }
; 2218 :     return e;

  000fe	48 8b c3	 mov	 rax, rbx
$LN19@ast_for_po:
  00101	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00106	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0010b	4c 8b 6c 24 60	 mov	 r13, QWORD PTR [rsp+96]

; 2219 : }

  00110	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00114	41 5c		 pop	 r12
  00116	5f		 pop	 rdi
  00117	5b		 pop	 rbx
  00118	c3		 ret	 0
ast_for_power ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@JJCKBAKO@unhandled?5expr?3?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_03BOPJPIAM@and?$AA@			; `string'
EXTRN	_Py_Yield:PROC
EXTRN	_Py_YieldFrom:PROC
EXTRN	_Py_Compare:PROC
EXTRN	asdl_int_seq_new:PROC
EXTRN	_Py_BoolOp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_expr DD imagerel ast_for_expr
	DD	imagerel ast_for_expr+1111
	DD	imagerel $unwind$ast_for_expr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_expr DD 060c01H
	DD	0a340cH
	DD	07008520cH
	DD	050066007H
xdata	ENDS
;	COMDAT ??_C@_0BD@JJCKBAKO@unhandled?5expr?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@JJCKBAKO@unhandled?5expr?3?5?$CFd?$AA@ DB 'unhandled expr: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BOPJPIAM@and?$AA@
CONST	SEGMENT
??_C@_03BOPJPIAM@and?$AA@ DB 'and', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ast_for_expr
_TEXT	SEGMENT
c$ = 80
ops$1$ = 88
seq$1$ = 88
n$ = 88
cmps$1$ = 96
ast_for_expr PROC					; COMDAT

; 2241 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2242 :     /* handle the full range of simple expressions
; 2243 :        test: or_test ['if' or_test 'else' test] | lambdef
; 2244 :        test_nocond: or_test | lambdef_nocond
; 2245 :        or_test: and_test ('or' and_test)*
; 2246 :        and_test: not_test ('and' not_test)*
; 2247 :        not_test: 'not' not_test | comparison
; 2248 :        comparison: expr (comp_op expr)*
; 2249 :        expr: xor_expr ('|' xor_expr)*
; 2250 :        xor_expr: and_expr ('^' and_expr)*
; 2251 :        and_expr: shift_expr ('&' shift_expr)*
; 2252 :        shift_expr: arith_expr (('<<'|'>>') arith_expr)*
; 2253 :        arith_expr: term (('+'|'-') term)*
; 2254 :        term: factor (('*'|'/'|'%'|'//') factor)*
; 2255 :        factor: ('+'|'-'|'~') factor | power
; 2256 :        power: atom trailer* ('**' factor)*
; 2257 :     */
; 2258 : 
; 2259 :     asdl_seq *seq;
; 2260 :     int i;
; 2261 : 
; 2262 :  loop:
; 2263 :     switch (TYPE(n)) {

  0000c	0f bf 02	 movsx	 eax, WORD PTR [rdx]
  0000f	48 8b da	 mov	 rbx, rdx
  00012	48 8b e9	 mov	 rbp, rcx
  00015	2d 2e 01 00 00	 sub	 eax, 302		; 0000012eH
  0001a	83 f8 22	 cmp	 eax, 34			; 00000022H
  0001d	0f 87 ad 02 00
	00		 ja	 $LN1@ast_for_ex@2
  00023	be 30 01 00 00	 mov	 esi, 304		; 00000130H
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  0002f	8d 7e 01	 lea	 edi, QWORD PTR [rsi+1]
$loop$23267:
  00032	48 98		 cdqe
  00034	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN62@ast_for_ex@2[rdx+rax]
  0003c	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN63@ast_for_ex@2[rdx+rax*4]
  00043	48 03 ca	 add	 rcx, rdx
  00046	ff e1		 jmp	 rcx
$LN42@ast_for_ex@2:

; 2264 :         case test:
; 2265 :         case test_nocond:
; 2266 :             if (TYPE(CHILD(n, 0)) == lambdef ||
; 2267 :                 TYPE(CHILD(n, 0)) == lambdef_nocond)

  00048	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0004c	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  0004f	66 3b ce	 cmp	 cx, si
  00052	0f 84 b5 02 00
	00		 je	 $LN40@ast_for_ex@2
  00058	66 3b cf	 cmp	 cx, di
  0005b	0f 84 ac 02 00
	00		 je	 $LN40@ast_for_ex@2

; 2269 :             else if (NCH(n) > 1)

  00061	83 7b 18 01	 cmp	 DWORD PTR [rbx+24], 1
  00065	0f 8f 8b 02 00
	00		 jg	 $LN55@ast_for_ex@2
$LN38@ast_for_ex@2:

; 2271 :             /* Fallthrough */
; 2272 :         case or_test:
; 2273 :         case and_test:
; 2274 :             if (NCH(n) == 1) {

  0006b	83 7b 18 01	 cmp	 DWORD PTR [rbx+24], 1
  0006f	0f 84 46 02 00
	00		 je	 $LN65@ast_for_ex@2

; 2275 :                 n = CHILD(n, 0);
; 2276 :                 goto loop;
; 2277 :             }
; 2278 :             seq = asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);

  00075	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  00078	ff c0		 inc	 eax
  0007a	99		 cdq
  0007b	2b c2		 sub	 eax, edx
  0007d	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
  00081	d1 f8		 sar	 eax, 1
  00083	48 63 c8	 movsxd	 rcx, eax
  00086	e8 00 00 00 00	 call	 asdl_seq_new
  0008b	48 8b d0	 mov	 rdx, rax
  0008e	48 89 44 24 58	 mov	 QWORD PTR seq$1$[rsp], rax

; 2279 :             if (!seq)

  00093	48 85 c0	 test	 rax, rax

; 2280 :                 return NULL;

  00096	0f 84 4b 02 00
	00		 je	 $LN66@ast_for_ex@2

; 2281 :             for (i = 0; i < NCH(n); i += 2) {

  0009c	33 f6		 xor	 esi, esi
  0009e	39 73 18	 cmp	 DWORD PTR [rbx+24], esi
  000a1	7e 4c		 jle	 SHORT $LN32@ast_for_ex@2
  000a3	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL34@ast_for_ex@2:

; 2282 :                 expr_ty e = ast_for_expr(c, CHILD(n, i));

  000b0	48 63 c6	 movsxd	 rax, esi
  000b3	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  000b7	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000bb	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  000bf	48 8b cd	 mov	 rcx, rbp
  000c2	e8 00 00 00 00	 call	 ast_for_expr
  000c7	48 8b f8	 mov	 rdi, rax

; 2283 :                 if (!e)

  000ca	48 85 c0	 test	 rax, rax
  000cd	0f 84 14 02 00
	00		 je	 $LN66@ast_for_ex@2

; 2284 :                     return NULL;
; 2285 :                 asdl_seq_SET(seq, i / 2, e);

  000d3	8b c6		 mov	 eax, esi
  000d5	83 c6 02	 add	 esi, 2
  000d8	99		 cdq
  000d9	2b c2		 sub	 eax, edx
  000db	48 8b 54 24 58	 mov	 rdx, QWORD PTR seq$1$[rsp]
  000e0	d1 f8		 sar	 eax, 1
  000e2	48 63 c8	 movsxd	 rcx, eax
  000e5	48 89 7c ca 08	 mov	 QWORD PTR [rdx+rcx*8+8], rdi
  000ea	3b 73 18	 cmp	 esi, DWORD PTR [rbx+24]
  000ed	7c c1		 jl	 SHORT $LL34@ast_for_ex@2
$LN32@ast_for_ex@2:

; 2286 :             }
; 2287 :             if (!strcmp(STR(CHILD(n, 1)), "and"))

  000ef	48 8b 73 20	 mov	 rsi, QWORD PTR [rbx+32]

; 2288 :                 return BoolOp(And, seq, LINENO(n), n->n_col_offset,
; 2289 :                               c->c_arena);

  000f3	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  000f7	44 8b 4b 14	 mov	 r9d, DWORD PTR [rbx+20]
  000fb	48 8b 76 30	 mov	 rsi, QWORD PTR [rsi+48]
  000ff	44 8b 43 10	 mov	 r8d, DWORD PTR [rbx+16]
  00103	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_03BOPJPIAM@and?$AA@
  0010a	b9 04 00 00 00	 mov	 ecx, 4
  0010f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00114	f3 a6		 repe cmpsb
  00116	0f 85 08 02 00
	00		 jne	 $LN30@ast_for_ex@2
  0011c	b9 01 00 00 00	 mov	 ecx, 1
  00121	e8 00 00 00 00	 call	 _Py_BoolOp

; 2397 :     }
; 2398 :     /* should never get here unless if error is set */
; 2399 :     return NULL;
; 2400 : }

  00126	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0012b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0012f	5f		 pop	 rdi
  00130	5e		 pop	 rsi
  00131	5d		 pop	 rbp
  00132	c3		 ret	 0
$LN29@ast_for_ex@2:

; 2292 :         case not_test:
; 2293 :             if (NCH(n) == 1) {

  00133	83 7b 18 01	 cmp	 DWORD PTR [rbx+24], 1
  00137	0f 84 7e 01 00
	00		 je	 $LN65@ast_for_ex@2

; 2294 :                 n = CHILD(n, 0);
; 2295 :                 goto loop;
; 2296 :             }
; 2297 :             else {
; 2298 :                 expr_ty expression = ast_for_expr(c, CHILD(n, 1));

  0013d	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00141	48 8b cd	 mov	 rcx, rbp
  00144	48 83 c2 28	 add	 rdx, 40			; 00000028H
  00148	e8 00 00 00 00	 call	 ast_for_expr
  0014d	48 8b d0	 mov	 rdx, rax

; 2299 :                 if (!expression)

  00150	48 85 c0	 test	 rax, rax

; 2300 :                     return NULL;

  00153	0f 84 8e 01 00
	00		 je	 $LN66@ast_for_ex@2

; 2301 : 
; 2302 :                 return UnaryOp(Not, expression, LINENO(n), n->n_col_offset,
; 2303 :                                c->c_arena);

  00159	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  0015d	44 8b 4b 14	 mov	 r9d, DWORD PTR [rbx+20]
  00161	44 8b 43 10	 mov	 r8d, DWORD PTR [rbx+16]
  00165	b9 02 00 00 00	 mov	 ecx, 2
  0016a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016f	e8 00 00 00 00	 call	 _Py_UnaryOp

; 2397 :     }
; 2398 :     /* should never get here unless if error is set */
; 2399 :     return NULL;
; 2400 : }

  00174	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00179	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0017d	5f		 pop	 rdi
  0017e	5e		 pop	 rsi
  0017f	5d		 pop	 rbp
  00180	c3		 ret	 0
$LN27@ast_for_ex@2:

; 2304 :             }
; 2305 :         case comparison:
; 2306 :             if (NCH(n) == 1) {

  00181	83 7b 18 01	 cmp	 DWORD PTR [rbx+24], 1
  00185	0f 84 30 01 00
	00		 je	 $LN65@ast_for_ex@2

; 2307 :                 n = CHILD(n, 0);
; 2308 :                 goto loop;
; 2309 :             }
; 2310 :             else {
; 2311 :                 expr_ty expression;
; 2312 :                 asdl_int_seq *ops;
; 2313 :                 asdl_seq *cmps;
; 2314 :                 ops = asdl_int_seq_new(NCH(n) / 2, c->c_arena);

  0018b	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  0018e	99		 cdq
  0018f	2b c2		 sub	 eax, edx
  00191	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
  00195	d1 f8		 sar	 eax, 1
  00197	48 63 c8	 movsxd	 rcx, eax
  0019a	e8 00 00 00 00	 call	 asdl_int_seq_new
  0019f	48 8b f0	 mov	 rsi, rax
  001a2	48 89 44 24 58	 mov	 QWORD PTR ops$1$[rsp], rax

; 2315 :                 if (!ops)

  001a7	48 85 c0	 test	 rax, rax

; 2316 :                     return NULL;

  001aa	0f 84 37 01 00
	00		 je	 $LN66@ast_for_ex@2

; 2317 :                 cmps = asdl_seq_new(NCH(n) / 2, c->c_arena);

  001b0	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  001b3	99		 cdq
  001b4	2b c2		 sub	 eax, edx
  001b6	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
  001ba	d1 f8		 sar	 eax, 1
  001bc	48 63 c8	 movsxd	 rcx, eax
  001bf	e8 00 00 00 00	 call	 asdl_seq_new
  001c4	48 89 44 24 60	 mov	 QWORD PTR cmps$1$[rsp], rax

; 2318 :                 if (!cmps) {

  001c9	48 85 c0	 test	 rax, rax

; 2319 :                     return NULL;

  001cc	0f 84 15 01 00
	00		 je	 $LN66@ast_for_ex@2

; 2320 :                 }
; 2321 :                 for (i = 1; i < NCH(n); i += 2) {

  001d2	bf 01 00 00 00	 mov	 edi, 1
  001d7	39 7b 18	 cmp	 DWORD PTR [rbx+24], edi
  001da	7e 72		 jle	 SHORT $LN18@ast_for_ex@2
  001dc	0f 1f 40 00	 npad	 4
$LL20@ast_for_ex@2:

; 2322 :                     cmpop_ty newoperator;
; 2323 : 
; 2324 :                     newoperator = ast_for_comp_op(c, CHILD(n, i));

  001e0	48 63 c7	 movsxd	 rax, edi
  001e3	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  001e7	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001eb	48 8d 0c c8	 lea	 rcx, QWORD PTR [rax+rcx*8]
  001ef	e8 00 00 00 00	 call	 ast_for_comp_op
  001f4	8b f0		 mov	 esi, eax

; 2325 :                     if (!newoperator) {

  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 e9 00 00
	00		 je	 $LN66@ast_for_ex@2

; 2326 :                         return NULL;
; 2327 :                     }
; 2328 : 
; 2329 :                     expression = ast_for_expr(c, CHILD(n, i + 1));

  001fe	8d 4f 01	 lea	 ecx, DWORD PTR [rdi+1]
  00201	48 63 d1	 movsxd	 rdx, ecx
  00204	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00208	48 8d 14 92	 lea	 rdx, QWORD PTR [rdx+rdx*4]
  0020c	48 8d 14 d1	 lea	 rdx, QWORD PTR [rcx+rdx*8]
  00210	48 8b cd	 mov	 rcx, rbp
  00213	e8 00 00 00 00	 call	 ast_for_expr
  00218	4c 8b d8	 mov	 r11, rax

; 2330 :                     if (!expression) {

  0021b	48 85 c0	 test	 rax, rax
  0021e	0f 84 c3 00 00
	00		 je	 $LN66@ast_for_ex@2

; 2331 :                         return NULL;
; 2332 :                     }
; 2333 : 
; 2334 :                     asdl_seq_SET(ops, i / 2, newoperator);

  00224	8b c7		 mov	 eax, edi
  00226	83 c7 02	 add	 edi, 2
  00229	99		 cdq
  0022a	2b c2		 sub	 eax, edx
  0022c	d1 f8		 sar	 eax, 1
  0022e	48 63 c8	 movsxd	 rcx, eax
  00231	48 8b 44 24 58	 mov	 rax, QWORD PTR ops$1$[rsp]
  00236	89 74 88 08	 mov	 DWORD PTR [rax+rcx*4+8], esi

; 2335 :                     asdl_seq_SET(cmps, i / 2, expression);

  0023a	48 8b 44 24 60	 mov	 rax, QWORD PTR cmps$1$[rsp]
  0023f	4c 89 5c c8 08	 mov	 QWORD PTR [rax+rcx*8+8], r11
  00244	3b 7b 18	 cmp	 edi, DWORD PTR [rbx+24]
  00247	7c 97		 jl	 SHORT $LL20@ast_for_ex@2

; 2330 :                     if (!expression) {

  00249	48 8b 74 24 58	 mov	 rsi, QWORD PTR ops$1$[rsp]
$LN18@ast_for_ex@2:

; 2336 :                 }
; 2337 :                 expression = ast_for_expr(c, CHILD(n, 0));

  0024e	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00252	48 8b cd	 mov	 rcx, rbp
  00255	e8 00 00 00 00	 call	 ast_for_expr
  0025a	48 8b c8	 mov	 rcx, rax

; 2338 :                 if (!expression) {

  0025d	48 85 c0	 test	 rax, rax

; 2339 :                     return NULL;

  00260	0f 84 81 00 00
	00		 je	 $LN66@ast_for_ex@2

; 2340 :                 }
; 2341 : 
; 2342 :                 return Compare(expression, ops, cmps, LINENO(n),
; 2343 :                                n->n_col_offset, c->c_arena);

  00266	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  0026a	44 8b 4b 10	 mov	 r9d, DWORD PTR [rbx+16]
  0026e	4c 8b 44 24 60	 mov	 r8, QWORD PTR cmps$1$[rsp]
  00273	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00278	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  0027b	48 8b d6	 mov	 rdx, rsi
  0027e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00282	e8 00 00 00 00	 call	 _Py_Compare

; 2397 :     }
; 2398 :     /* should never get here unless if error is set */
; 2399 :     return NULL;
; 2400 : }

  00287	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0028c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00290	5f		 pop	 rdi
  00291	5e		 pop	 rsi
  00292	5d		 pop	 rbp
  00293	c3		 ret	 0
$LN13@ast_for_ex@2:

; 2349 :         /* The next five cases all handle BinOps.  The main body of code
; 2350 :            is the same in each case, but the switch turned inside out to
; 2351 :            reuse the code for each type of operator.
; 2352 :          */
; 2353 :         case expr:
; 2354 :         case xor_expr:
; 2355 :         case and_expr:
; 2356 :         case shift_expr:
; 2357 :         case arith_expr:
; 2358 :         case term:
; 2359 :             if (NCH(n) == 1) {

  00294	83 7b 18 01	 cmp	 DWORD PTR [rbx+24], 1
  00298	74 21		 je	 SHORT $LN65@ast_for_ex@2

; 2360 :                 n = CHILD(n, 0);
; 2361 :                 goto loop;
; 2362 :             }
; 2363 :             return ast_for_binop(c, n);

  0029a	48 8b d3	 mov	 rdx, rbx
  0029d	48 8b cd	 mov	 rcx, rbp

; 2397 :     }
; 2398 :     /* should never get here unless if error is set */
; 2399 :     return NULL;
; 2400 : }

  002a0	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  002a5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002a9	5f		 pop	 rdi
  002aa	5e		 pop	 rsi
  002ab	5d		 pop	 rbp
  002ac	e9 00 00 00 00	 jmp	 ast_for_binop
$LN4@ast_for_ex@2:

; 2385 :         }
; 2386 :         case factor:
; 2387 :             if (NCH(n) == 1) {

  002b1	83 7b 18 01	 cmp	 DWORD PTR [rbx+24], 1
  002b5	0f 85 80 00 00
	00		 jne	 $LN3@ast_for_ex@2
$LN65@ast_for_ex@2:

; 2388 :                 n = CHILD(n, 0);

  002bb	48 8b 5b 20	 mov	 rbx, QWORD PTR [rbx+32]
  002bf	0f bf 03	 movsx	 eax, WORD PTR [rbx]
  002c2	2d 2e 01 00 00	 sub	 eax, 302		; 0000012eH
  002c7	83 f8 22	 cmp	 eax, 34			; 00000022H
  002ca	0f 86 62 fd ff
	ff		 jbe	 $loop$23267
$LN1@ast_for_ex@2:

; 2394 :         default:
; 2395 :             PyErr_Format(PyExc_SystemError, "unhandled expr: %d", TYPE(n));

  002d0	44 0f bf 03	 movsx	 r8d, WORD PTR [rbx]
  002d4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  002db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@JJCKBAKO@unhandled?5expr?3?5?$CFd?$AA@
  002e2	e8 00 00 00 00	 call	 PyErr_Format
$LN66@ast_for_ex@2:

; 2396 :             return NULL;

  002e7	33 c0		 xor	 eax, eax

; 2397 :     }
; 2398 :     /* should never get here unless if error is set */
; 2399 :     return NULL;
; 2400 : }

  002e9	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  002ee	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002f2	5f		 pop	 rdi
  002f3	5e		 pop	 rsi
  002f4	5d		 pop	 rbp
  002f5	c3		 ret	 0
$LN55@ast_for_ex@2:

; 2270 :                 return ast_for_ifexpr(c, n);

  002f6	48 8b d3	 mov	 rdx, rbx
  002f9	48 8b cd	 mov	 rcx, rbp

; 2397 :     }
; 2398 :     /* should never get here unless if error is set */
; 2399 :     return NULL;
; 2400 : }

  002fc	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00301	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00305	5f		 pop	 rdi
  00306	5e		 pop	 rsi
  00307	5d		 pop	 rbp
  00308	e9 00 00 00 00	 jmp	 ast_for_ifexpr
$LN40@ast_for_ex@2:

; 2268 :                 return ast_for_lambdef(c, CHILD(n, 0));

  0030d	48 8b d0	 mov	 rdx, rax
  00310	48 8b cd	 mov	 rcx, rbp

; 2397 :     }
; 2398 :     /* should never get here unless if error is set */
; 2399 :     return NULL;
; 2400 : }

  00313	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00318	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0031c	5f		 pop	 rdi
  0031d	5e		 pop	 rsi
  0031e	5d		 pop	 rbp
  0031f	e9 00 00 00 00	 jmp	 ast_for_lambdef
$LN30@ast_for_ex@2:

; 2290 :             assert(!strcmp(STR(CHILD(n, 1)), "or"));
; 2291 :             return BoolOp(Or, seq, LINENO(n), n->n_col_offset, c->c_arena);

  00324	b9 02 00 00 00	 mov	 ecx, 2
  00329	e8 00 00 00 00	 call	 _Py_BoolOp

; 2397 :     }
; 2398 :     /* should never get here unless if error is set */
; 2399 :     return NULL;
; 2400 : }

  0032e	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00333	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00337	5f		 pop	 rdi
  00338	5e		 pop	 rsi
  00339	5d		 pop	 rbp
  0033a	c3		 ret	 0
$LN3@ast_for_ex@2:

; 2389 :                 goto loop;
; 2390 :             }
; 2391 :             return ast_for_factor(c, n);

  0033b	48 8b d3	 mov	 rdx, rbx
  0033e	48 8b cd	 mov	 rcx, rbp

; 2397 :     }
; 2398 :     /* should never get here unless if error is set */
; 2399 :     return NULL;
; 2400 : }

  00341	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00346	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0034a	5f		 pop	 rdi
  0034b	5e		 pop	 rsi
  0034c	5d		 pop	 rbp
  0034d	e9 00 00 00 00	 jmp	 ast_for_factor
$LN14@ast_for_ex@2:

; 2344 :             }
; 2345 :             break;
; 2346 : 
; 2347 :         case star_expr:
; 2348 :             return ast_for_starred(c, n);

  00352	48 8b d3	 mov	 rdx, rbx
  00355	48 8b cd	 mov	 rcx, rbp

; 2397 :     }
; 2398 :     /* should never get here unless if error is set */
; 2399 :     return NULL;
; 2400 : }

  00358	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0035d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00361	5f		 pop	 rdi
  00362	5e		 pop	 rsi
  00363	5d		 pop	 rbp
  00364	e9 00 00 00 00	 jmp	 ast_for_starred
$LN11@ast_for_ex@2:

; 2364 :         case yield_expr: {
; 2365 :             node *an = NULL;
; 2366 :             node *en = NULL;
; 2367 :             int is_from = 0;

  00369	33 f6		 xor	 esi, esi

; 2368 :             expr_ty exp = NULL;
; 2369 :             if (NCH(n) > 1)

  0036b	83 7b 18 01	 cmp	 DWORD PTR [rbx+24], 1
  0036f	8b c6		 mov	 eax, esi
  00371	7e 63		 jle	 SHORT $LN5@ast_for_ex@2

; 2370 :                 an = CHILD(n, 1); /* yield_arg */

  00373	4c 8b 43 20	 mov	 r8, QWORD PTR [rbx+32]
  00377	49 83 c0 28	 add	 r8, 40			; 00000028H

; 2371 :             if (an) {

  0037b	74 59		 je	 SHORT $LN5@ast_for_ex@2

; 2372 :                 en = CHILD(an, NCH(an) - 1);

  0037d	41 8b 78 18	 mov	 edi, DWORD PTR [r8+24]
  00381	8d 47 ff	 lea	 eax, DWORD PTR [rdi-1]
  00384	48 63 c8	 movsxd	 rcx, eax
  00387	49 8b 40 20	 mov	 rax, QWORD PTR [r8+32]
  0038b	48 8d 14 89	 lea	 rdx, QWORD PTR [rcx+rcx*4]

; 2373 :                 if (NCH(an) == 2) {
; 2374 :                     is_from = 1;
; 2375 :                     exp = ast_for_expr(c, en);

  0038f	48 8b cd	 mov	 rcx, rbp
  00392	48 8d 14 d0	 lea	 rdx, QWORD PTR [rax+rdx*8]
  00396	83 ff 02	 cmp	 edi, 2
  00399	75 0a		 jne	 SHORT $LN8@ast_for_ex@2
  0039b	8d 77 ff	 lea	 esi, QWORD PTR [rdi-1]
  0039e	e8 00 00 00 00	 call	 ast_for_expr

; 2376 :                 }
; 2377 :                 else

  003a3	eb 05		 jmp	 SHORT $LN7@ast_for_ex@2
$LN8@ast_for_ex@2:

; 2378 :                     exp = ast_for_testlist(c, en);

  003a5	e8 00 00 00 00	 call	 ast_for_testlist
$LN7@ast_for_ex@2:

; 2379 :                 if (!exp)

  003aa	48 85 c0	 test	 rax, rax

; 2380 :                     return NULL;

  003ad	0f 84 34 ff ff
	ff		 je	 $LN66@ast_for_ex@2

; 2381 :             }
; 2382 :             if (is_from)

  003b3	85 f6		 test	 esi, esi
  003b5	74 1f		 je	 SHORT $LN5@ast_for_ex@2

; 2383 :                 return YieldFrom(exp, LINENO(n), n->n_col_offset, c->c_arena);

  003b7	4c 8b 4d 08	 mov	 r9, QWORD PTR [rbp+8]
  003bb	44 8b 43 14	 mov	 r8d, DWORD PTR [rbx+20]
  003bf	8b 53 10	 mov	 edx, DWORD PTR [rbx+16]
  003c2	48 8b c8	 mov	 rcx, rax

; 2397 :     }
; 2398 :     /* should never get here unless if error is set */
; 2399 :     return NULL;
; 2400 : }

  003c5	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  003ca	48 83 c4 30	 add	 rsp, 48			; 00000030H
  003ce	5f		 pop	 rdi
  003cf	5e		 pop	 rsi
  003d0	5d		 pop	 rbp
  003d1	e9 00 00 00 00	 jmp	 _Py_YieldFrom
$LN5@ast_for_ex@2:

; 2384 :             return Yield(exp, LINENO(n), n->n_col_offset, c->c_arena);

  003d6	4c 8b 4d 08	 mov	 r9, QWORD PTR [rbp+8]
  003da	44 8b 43 14	 mov	 r8d, DWORD PTR [rbx+20]
  003de	8b 53 10	 mov	 edx, DWORD PTR [rbx+16]
  003e1	48 8b c8	 mov	 rcx, rax

; 2397 :     }
; 2398 :     /* should never get here unless if error is set */
; 2399 :     return NULL;
; 2400 : }

  003e4	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  003e9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  003ed	5f		 pop	 rdi
  003ee	5e		 pop	 rsi
  003ef	5d		 pop	 rbp
  003f0	e9 00 00 00 00	 jmp	 _Py_Yield
$LN2@ast_for_ex@2:

; 2392 :         case power:
; 2393 :             return ast_for_power(c, n);

  003f5	48 8b d3	 mov	 rdx, rbx
  003f8	48 8b cd	 mov	 rcx, rbp

; 2397 :     }
; 2398 :     /* should never get here unless if error is set */
; 2399 :     return NULL;
; 2400 : }

  003fb	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00400	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00404	5f		 pop	 rdi
  00405	5e		 pop	 rsi
  00406	5d		 pop	 rbp
  00407	e9 00 00 00 00	 jmp	 ast_for_power
$LN63@ast_for_ex@2:
  0040c	00 00 00 00	 DD	 $LN42@ast_for_ex@2
  00410	00 00 00 00	 DD	 $LN38@ast_for_ex@2
  00414	00 00 00 00	 DD	 $LN29@ast_for_ex@2
  00418	00 00 00 00	 DD	 $LN27@ast_for_ex@2
  0041c	00 00 00 00	 DD	 $LN14@ast_for_ex@2
  00420	00 00 00 00	 DD	 $LN13@ast_for_ex@2
  00424	00 00 00 00	 DD	 $LN4@ast_for_ex@2
  00428	00 00 00 00	 DD	 $LN2@ast_for_ex@2
  0042c	00 00 00 00	 DD	 $LN11@ast_for_ex@2
  00430	00 00 00 00	 DD	 $LN1@ast_for_ex@2
$LN62@ast_for_ex@2:
  00434	00		 DB	 0
  00435	00		 DB	 0
  00436	09		 DB	 9
  00437	09		 DB	 9
  00438	01		 DB	 1
  00439	01		 DB	 1
  0043a	02		 DB	 2
  0043b	03		 DB	 3
  0043c	09		 DB	 9
  0043d	04		 DB	 4
  0043e	05		 DB	 5
  0043f	05		 DB	 5
  00440	05		 DB	 5
  00441	05		 DB	 5
  00442	05		 DB	 5
  00443	05		 DB	 5
  00444	06		 DB	 6
  00445	07		 DB	 7
  00446	09		 DB	 9
  00447	09		 DB	 9
  00448	09		 DB	 9
  00449	09		 DB	 9
  0044a	09		 DB	 9
  0044b	09		 DB	 9
  0044c	09		 DB	 9
  0044d	09		 DB	 9
  0044e	09		 DB	 9
  0044f	09		 DB	 9
  00450	09		 DB	 9
  00451	09		 DB	 9
  00452	09		 DB	 9
  00453	09		 DB	 9
  00454	09		 DB	 9
  00455	09		 DB	 9
  00456	08		 DB	 8
ast_for_expr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@FBIGLNOA@lambda?5cannot?5contain?5assignment@ ; `string'
PUBLIC	??_C@_0BP@GJBMLMAG@keyword?5can?8t?5be?5an?5expression?$AA@ ; `string'
PUBLIC	??_C@_0BK@CEBEDAAO@keyword?5argument?5repeated?$AA@ ; `string'
PUBLIC	??_C@_0CC@JMBPEODL@non?9keyword?5arg?5after?5keyword?5ar@ ; `string'
PUBLIC	??_C@_0CM@FHHDCLIK@only?5named?5arguments?5may?5follow?5@ ; `string'
PUBLIC	??_C@_0EA@PMHIDDOH@Generator?5expression?5must?5be?5par@ ; `string'
EXTRN	_Py_keyword:PROC
EXTRN	PyUnicode_Compare:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_call DD imagerel ast_for_call
	DD	imagerel ast_for_call+278
	DD	imagerel $unwind$ast_for_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ast_for_call DD imagerel ast_for_call+278
	DD	imagerel ast_for_call+895
	DD	imagerel $chain$1$ast_for_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ast_for_call DD imagerel ast_for_call+895
	DD	imagerel ast_for_call+990
	DD	imagerel $chain$3$ast_for_call
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ast_for_call DD 040021H
	DD	0ef400H
	DD	016c400H
	DD	imagerel ast_for_call
	DD	imagerel ast_for_call+278
	DD	imagerel $unwind$ast_for_call
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ast_for_call DD 040d21H
	DD	0ef40dH
	DD	016c408H
	DD	imagerel ast_for_call
	DD	imagerel ast_for_call+278
	DD	imagerel $unwind$ast_for_call
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_call DD 071601H
	DD	0e012e216H
	DD	0700ed010H
	DD	0500c600dH
	DD	0300bH
xdata	ENDS
;	COMDAT ??_C@_0CB@FBIGLNOA@lambda?5cannot?5contain?5assignment@
CONST	SEGMENT
??_C@_0CB@FBIGLNOA@lambda?5cannot?5contain?5assignment@ DB 'lambda cannot'
	DB	' contain assignment', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GJBMLMAG@keyword?5can?8t?5be?5an?5expression?$AA@
CONST	SEGMENT
??_C@_0BP@GJBMLMAG@keyword?5can?8t?5be?5an?5expression?$AA@ DB 'keyword c'
	DB	'an''t be an expression', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CEBEDAAO@keyword?5argument?5repeated?$AA@
CONST	SEGMENT
??_C@_0BK@CEBEDAAO@keyword?5argument?5repeated?$AA@ DB 'keyword argument '
	DB	'repeated', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JMBPEODL@non?9keyword?5arg?5after?5keyword?5ar@
CONST	SEGMENT
??_C@_0CC@JMBPEODL@non?9keyword?5arg?5after?5keyword?5ar@ DB 'non-keyword'
	DB	' arg after keyword arg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FHHDCLIK@only?5named?5arguments?5may?5follow?5@
CONST	SEGMENT
??_C@_0CM@FHHDCLIK@only?5named?5arguments?5may?5follow?5@ DB 'only named '
	DB	'arguments may follow *expression', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@PMHIDDOH@Generator?5expression?5must?5be?5par@
CONST	SEGMENT
??_C@_0EA@PMHIDDOH@Generator?5expression?5must?5be?5par@ DB 'Generator ex'
	DB	'pression must be parenthesized if not sole argument', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ast_for_call
_TEXT	SEGMENT
tv640 = 64
vararg$1$ = 72
tv641 = 80
kwarg$1$ = 88
args$1$ = 96
c$ = 176
n$ = 184
func$ = 192
keywords$1$ = 200
ast_for_call PROC					; COMDAT

; 2404 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2415 : 
; 2416 :     REQ(n, arglist);
; 2417 : 
; 2418 :     nargs = 0;
; 2419 :     nkeywords = 0;
; 2420 :     ngens = 0;
; 2421 :     for (i = 0; i < NCH(n); i++) {

  00016	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  00019	45 33 f6	 xor	 r14d, r14d
  0001c	33 ff		 xor	 edi, edi
  0001e	4d 8b e8	 mov	 r13, r8
  00021	41 b8 4b 01 00
	00		 mov	 r8d, 331		; 0000014bH
  00027	45 33 d2	 xor	 r10d, r10d
  0002a	33 db		 xor	 ebx, ebx
  0002c	45 33 c9	 xor	 r9d, r9d
  0002f	48 8b f2	 mov	 rsi, rdx
  00032	48 8b e9	 mov	 rbp, rcx
  00035	4c 89 74 24 48	 mov	 QWORD PTR vararg$1$[rsp], r14
  0003a	48 89 7c 24 58	 mov	 QWORD PTR kwarg$1$[rsp], rdi
  0003f	45 8d 58 02	 lea	 r11d, QWORD PTR [r8+2]
  00043	85 c0		 test	 eax, eax
  00045	7e 6a		 jle	 SHORT $LN36@ast_for_ca

; 2405 :     /*
; 2406 :       arglist: (argument ',')* (argument [',']| '*' test [',' '**' test]
; 2407 :                | '**' test)
; 2408 :       argument: [test '='] (test) [comp_for]        # Really [keyword '='] test
; 2409 :     */
; 2410 : 
; 2411 :     int i, nargs, nkeywords, ngens;
; 2412 :     asdl_seq *args;
; 2413 :     asdl_seq *keywords;
; 2414 :     expr_ty vararg = NULL, kwarg = NULL;

  00047	48 8b 4a 20	 mov	 rcx, QWORD PTR [rdx+32]
  0004b	8b d0		 mov	 edx, eax
  0004d	0f 1f 00	 npad	 3
$LL44@ast_for_ca:

; 2422 :         node *ch = CHILD(n, i);
; 2423 :         if (TYPE(ch) == argument) {

  00050	66 44 39 01	 cmp	 WORD PTR [rcx], r8w
  00054	75 1d		 jne	 SHORT $LN43@ast_for_ca

; 2424 :             if (NCH(ch) == 1)

  00056	83 79 18 01	 cmp	 DWORD PTR [rcx+24], 1
  0005a	75 05		 jne	 SHORT $LN40@ast_for_ca

; 2425 :                 nargs++;

  0005c	41 ff c2	 inc	 r10d
  0005f	eb 12		 jmp	 SHORT $LN43@ast_for_ca
$LN40@ast_for_ca:

; 2426 :             else if (TYPE(CHILD(ch, 1)) == comp_for)

  00061	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
  00065	66 44 39 58 28	 cmp	 WORD PTR [rax+40], r11w
  0006a	75 05		 jne	 SHORT $LN38@ast_for_ca

; 2427 :                 ngens++;

  0006c	41 ff c1	 inc	 r9d

; 2428 :             else

  0006f	eb 02		 jmp	 SHORT $LN43@ast_for_ca
$LN38@ast_for_ca:

; 2429 :                 nkeywords++;

  00071	ff c3		 inc	 ebx
$LN43@ast_for_ca:

; 2415 : 
; 2416 :     REQ(n, arglist);
; 2417 : 
; 2418 :     nargs = 0;
; 2419 :     nkeywords = 0;
; 2420 :     ngens = 0;
; 2421 :     for (i = 0; i < NCH(n); i++) {

  00073	48 83 c1 28	 add	 rcx, 40			; 00000028H
  00077	48 ff ca	 dec	 rdx
  0007a	75 d4		 jne	 SHORT $LL44@ast_for_ca

; 2430 :         }
; 2431 :     }
; 2432 :     if (ngens > 1 || (ngens && (nargs || nkeywords))) {

  0007c	41 83 f9 01	 cmp	 r9d, 1
  00080	7f 0e		 jg	 SHORT $LN34@ast_for_ca
  00082	45 85 c9	 test	 r9d, r9d
  00085	74 2a		 je	 SHORT $LN36@ast_for_ca
  00087	45 85 d2	 test	 r10d, r10d
  0008a	75 04		 jne	 SHORT $LN34@ast_for_ca
  0008c	85 db		 test	 ebx, ebx
  0008e	74 21		 je	 SHORT $LN36@ast_for_ca
$LN34@ast_for_ca:

; 2433 :         ast_error(c, n, "Generator expression must be parenthesized "
; 2434 :                   "if not sole argument");

  00090	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0EA@PMHIDDOH@Generator?5expression?5must?5be?5par@
  00097	48 8b d6	 mov	 rdx, rsi
  0009a	48 8b cd	 mov	 rcx, rbp
  0009d	e8 00 00 00 00	 call	 ast_error

; 2435 :         return NULL;

  000a2	33 c0		 xor	 eax, eax

; 2532 : }

  000a4	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000a8	41 5e		 pop	 r14
  000aa	41 5d		 pop	 r13
  000ac	5f		 pop	 rdi
  000ad	5e		 pop	 rsi
  000ae	5d		 pop	 rbp
  000af	5b		 pop	 rbx
  000b0	c3		 ret	 0
$LN36@ast_for_ca:

; 2436 :     }
; 2437 : 
; 2438 :     if (nargs + nkeywords + ngens > 255) {

  000b1	41 8d 04 19	 lea	 eax, DWORD PTR [r9+rbx]
  000b5	41 03 c2	 add	 eax, r10d
  000b8	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000bd	7e 21		 jle	 SHORT $LN33@ast_for_ca

; 2439 :         ast_error(c, n, "more than 255 arguments");

  000bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BI@ENJBOKKG@more?5than?5255?5arguments?$AA@
  000c6	48 8b d6	 mov	 rdx, rsi
  000c9	48 8b cd	 mov	 rcx, rbp
  000cc	e8 00 00 00 00	 call	 ast_error
$LN74@ast_for_ca:

; 2440 :         return NULL;

  000d1	33 c0		 xor	 eax, eax

; 2532 : }

  000d3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000d7	41 5e		 pop	 r14
  000d9	41 5d		 pop	 r13
  000db	5f		 pop	 rdi
  000dc	5e		 pop	 rsi
  000dd	5d		 pop	 rbp
  000de	5b		 pop	 rbx
  000df	c3		 ret	 0
$LN33@ast_for_ca:

; 2441 :     }
; 2442 : 
; 2443 :     args = asdl_seq_new(nargs + ngens, c->c_arena);

  000e0	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
  000e4	43 8d 04 11	 lea	 eax, DWORD PTR [r9+r10]
  000e8	48 63 c8	 movsxd	 rcx, eax
  000eb	e8 00 00 00 00	 call	 asdl_seq_new
  000f0	48 89 44 24 60	 mov	 QWORD PTR args$1$[rsp], rax

; 2444 :     if (!args)

  000f5	48 85 c0	 test	 rax, rax

; 2445 :         return NULL;

  000f8	74 d7		 je	 SHORT $LN74@ast_for_ca

; 2446 :     keywords = asdl_seq_new(nkeywords, c->c_arena);

  000fa	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
  000fe	48 63 cb	 movsxd	 rcx, ebx
  00101	e8 00 00 00 00	 call	 asdl_seq_new
  00106	48 8b c8	 mov	 rcx, rax
  00109	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR keywords$1$[rsp], rax

; 2447 :     if (!keywords)

  00111	48 85 c0	 test	 rax, rax

; 2448 :         return NULL;

  00114	74 bb		 je	 SHORT $LN74@ast_for_ca

; 2450 :     nkeywords = 0;
; 2451 :     for (i = 0; i < NCH(n); i++) {

  00116	4c 89 a4 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], r12
  0011e	4c 89 7c 24 70	 mov	 QWORD PTR [rsp+112], r15
  00123	45 33 ff	 xor	 r15d, r15d
  00126	45 33 e4	 xor	 r12d, r12d
  00129	39 7e 18	 cmp	 DWORD PTR [rsi+24], edi
  0012c	0f 8e 02 02 00
	00		 jle	 $LN67@ast_for_ca

; 2449 :     nargs = 0;

  00132	48 8b 5c 24 60	 mov	 rbx, QWORD PTR args$1$[rsp]
  00137	45 8d 6f 01	 lea	 r13d, QWORD PTR [r15+1]
  0013b	48 89 7c 24 50	 mov	 QWORD PTR tv641[rsp], rdi
  00140	48 83 c3 08	 add	 rbx, 8
  00144	41 b8 4b 01 00
	00		 mov	 r8d, 331		; 0000014bH
  0014a	48 89 5c 24 40	 mov	 QWORD PTR tv640[rsp], rbx
  0014f	90		 npad	 1
$LL30@ast_for_ca:

; 2452 :         node *ch = CHILD(n, i);

  00150	48 8b 56 20	 mov	 rdx, QWORD PTR [rsi+32]

; 2453 :         if (TYPE(ch) == argument) {

  00154	0f b7 04 17	 movzx	 eax, WORD PTR [rdi+rdx]
  00158	48 8d 34 17	 lea	 rsi, QWORD PTR [rdi+rdx]
  0015c	66 41 3b c0	 cmp	 ax, r8w
  00160	0f 85 3e 01 00
	00		 jne	 $LN27@ast_for_ca

; 2454 :             expr_ty e;
; 2455 :             if (NCH(ch) == 1) {

  00166	83 7e 18 01	 cmp	 DWORD PTR [rsi+24], 1

; 2465 :                 }
; 2466 :                 e = ast_for_expr(c, CHILD(ch, 0));

  0016a	48 8b 56 20	 mov	 rdx, QWORD PTR [rsi+32]
  0016e	48 8b cd	 mov	 rcx, rbp
  00171	75 31		 jne	 SHORT $LN26@ast_for_ca

; 2456 :                 if (nkeywords) {

  00173	4d 85 e4	 test	 r12, r12
  00176	0f 85 13 02 00
	00		 jne	 $LN51@ast_for_ca

; 2460 :                 }
; 2461 :                 if (vararg) {

  0017c	4d 85 f6	 test	 r14, r14
  0017f	0f 85 fa 01 00
	00		 jne	 $LN52@ast_for_ca

; 2465 :                 }
; 2466 :                 e = ast_for_expr(c, CHILD(ch, 0));

  00185	e8 00 00 00 00	 call	 ast_for_expr

; 2467 :                 if (!e)

  0018a	48 85 c0	 test	 rax, rax
  0018d	0f 84 47 02 00
	00		 je	 $LN62@ast_for_ca

; 2468 :                     return NULL;
; 2469 :                 asdl_seq_SET(args, nargs++, e);

  00193	48 89 03	 mov	 QWORD PTR [rbx], rax
  00196	48 83 c3 08	 add	 rbx, 8
  0019a	48 89 5c 24 40	 mov	 QWORD PTR tv640[rsp], rbx
  0019f	e9 54 01 00 00	 jmp	 $LN71@ast_for_ca
$LN26@ast_for_ca:

; 2470 :             }
; 2471 :             else if (TYPE(CHILD(ch, 1)) == comp_for) {

  001a4	b8 4d 01 00 00	 mov	 eax, 333		; 0000014dH
  001a9	66 39 42 28	 cmp	 WORD PTR [rdx+40], ax
  001ad	75 22		 jne	 SHORT $LN21@ast_for_ca

; 2472 :                 e = ast_for_genexp(c, ch);

  001af	48 8b d6	 mov	 rdx, rsi
  001b2	e8 00 00 00 00	 call	 ast_for_genexp

; 2473 :                 if (!e)

  001b7	48 85 c0	 test	 rax, rax
  001ba	0f 84 1a 02 00
	00		 je	 $LN62@ast_for_ca

; 2474 :                     return NULL;
; 2475 :                 asdl_seq_SET(args, nargs++, e);

  001c0	48 89 03	 mov	 QWORD PTR [rbx], rax
  001c3	48 83 c3 08	 add	 rbx, 8
  001c7	48 89 5c 24 40	 mov	 QWORD PTR tv640[rsp], rbx

; 2476 :             }
; 2477 :             else {

  001cc	e9 27 01 00 00	 jmp	 $LN71@ast_for_ca
$LN21@ast_for_ca:

; 2478 :                 keyword_ty kw;
; 2479 :                 identifier key, tmp;
; 2480 :                 int k;
; 2481 : 
; 2482 :                 /* CHILD(ch, 0) is test, but must be an identifier? */
; 2483 :                 e = ast_for_expr(c, CHILD(ch, 0));

  001d1	e8 00 00 00 00	 call	 ast_for_expr
  001d6	48 8b d8	 mov	 rbx, rax

; 2484 :                 if (!e)

  001d9	48 85 c0	 test	 rax, rax
  001dc	0f 84 f8 01 00
	00		 je	 $LN62@ast_for_ca

; 2485 :                     return NULL;
; 2486 :                 /* f(lambda x: x[0] = 3) ends up getting parsed with
; 2487 :                  * LHS test = lambda x: x[0], and RHS test = 3.
; 2488 :                  * SF bug 132313 points out that complaining about a keyword
; 2489 :                  * then is very confusing.
; 2490 :                  */
; 2491 :                 if (e->kind == Lambda_kind) {

  001e2	8b 00		 mov	 eax, DWORD PTR [rax]

; 2497 :                 } else if (forbidden_name(c, e->v.Name.id, ch, 1)) {

  001e4	48 8b cd	 mov	 rcx, rbp
  001e7	83 f8 04	 cmp	 eax, 4
  001ea	0f 84 da 01 00
	00		 je	 $LN56@ast_for_ca

; 2494 :                 } else if (e->kind != Name_kind) {

  001f0	83 f8 17	 cmp	 eax, 23
  001f3	0f 85 bd 01 00
	00		 jne	 $LN57@ast_for_ca

; 2497 :                 } else if (forbidden_name(c, e->v.Name.id, ch, 1)) {

  001f9	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  001fd	44 8d 48 ea	 lea	 r9d, QWORD PTR [rax-22]
  00201	4c 8b c6	 mov	 r8, rsi
  00204	e8 00 00 00 00	 call	 forbidden_name
  00209	85 c0		 test	 eax, eax
  0020b	0f 85 c9 01 00
	00		 jne	 $LN62@ast_for_ca

; 2498 :                     return NULL;
; 2499 :                 }
; 2500 :                 key = e->v.Name.id;

  00211	4c 8b 73 08	 mov	 r14, QWORD PTR [rbx+8]

; 2501 :                 for (k = 0; k < nkeywords; k++) {

  00215	33 db		 xor	 ebx, ebx
  00217	4d 85 e4	 test	 r12, r12
  0021a	7e 3b		 jle	 SHORT $LN10@ast_for_ca

; 2498 :                     return NULL;
; 2499 :                 }
; 2500 :                 key = e->v.Name.id;

  0021c	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR keywords$1$[rsp]
  00224	48 83 c7 08	 add	 rdi, 8
  00228	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL12@ast_for_ca:

; 2502 :                     tmp = ((keyword_ty)asdl_seq_GET(keywords, k))->arg;

  00230	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 2503 :                     if (!PyUnicode_Compare(tmp, key)) {

  00233	49 8b d6	 mov	 rdx, r14
  00236	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00239	e8 00 00 00 00	 call	 PyUnicode_Compare
  0023e	85 c0		 test	 eax, eax
  00240	0f 84 59 01 00
	00		 je	 $LN50@ast_for_ca

; 2501 :                 for (k = 0; k < nkeywords; k++) {

  00246	48 ff c3	 inc	 rbx
  00249	48 83 c7 08	 add	 rdi, 8
  0024d	49 3b dc	 cmp	 rbx, r12
  00250	7c de		 jl	 SHORT $LL12@ast_for_ca
  00252	48 8b 7c 24 50	 mov	 rdi, QWORD PTR tv641[rsp]
$LN10@ast_for_ca:

; 2506 :                     }
; 2507 :                 }
; 2508 :                 e = ast_for_expr(c, CHILD(ch, 2));

  00257	48 8b 56 20	 mov	 rdx, QWORD PTR [rsi+32]
  0025b	48 8b cd	 mov	 rcx, rbp
  0025e	48 83 c2 50	 add	 rdx, 80			; 00000050H
  00262	e8 00 00 00 00	 call	 ast_for_expr

; 2509 :                 if (!e)

  00267	48 85 c0	 test	 rax, rax
  0026a	0f 84 6a 01 00
	00		 je	 $LN62@ast_for_ca

; 2510 :                     return NULL;
; 2511 :                 kw = keyword(key, e, c->c_arena);

  00270	4c 8b 45 08	 mov	 r8, QWORD PTR [rbp+8]
  00274	48 8b d0	 mov	 rdx, rax
  00277	49 8b ce	 mov	 rcx, r14
  0027a	e8 00 00 00 00	 call	 _Py_keyword

; 2512 :                 if (!kw)

  0027f	48 85 c0	 test	 rax, rax
  00282	0f 84 52 01 00
	00		 je	 $LN62@ast_for_ca

; 2513 :                     return NULL;
; 2514 :                 asdl_seq_SET(keywords, nkeywords++, kw);

  00288	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR keywords$1$[rsp]

; 2515 :             }

  00290	48 8b 5c 24 40	 mov	 rbx, QWORD PTR tv640[rsp]
  00295	4c 8b 74 24 48	 mov	 r14, QWORD PTR vararg$1$[rsp]
  0029a	4a 89 44 e1 08	 mov	 QWORD PTR [rcx+r12*8+8], rax
  0029f	49 ff c4	 inc	 r12
  002a2	eb 5c		 jmp	 SHORT $LN72@ast_for_ca
$LN27@ast_for_ca:

; 2516 :         }
; 2517 :         else if (TYPE(ch) == STAR) {

  002a4	66 83 f8 10	 cmp	 ax, 16
  002a8	75 1d		 jne	 SHORT $LN5@ast_for_ca

; 2518 :             vararg = ast_for_expr(c, CHILD(n, i+1));

  002aa	49 63 c5	 movsxd	 rax, r13d
  002ad	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  002b1	48 8d 14 ca	 lea	 rdx, QWORD PTR [rdx+rcx*8]
  002b5	48 8b cd	 mov	 rcx, rbp
  002b8	e8 00 00 00 00	 call	 ast_for_expr
  002bd	4c 8b f0	 mov	 r14, rax
  002c0	48 89 44 24 48	 mov	 QWORD PTR vararg$1$[rsp], rax

; 2519 :             if (!vararg)
; 2520 :                 return NULL;
; 2521 :             i++;

  002c5	eb 1e		 jmp	 SHORT $LN76@ast_for_ca
$LN5@ast_for_ca:

; 2522 :         }
; 2523 :         else if (TYPE(ch) == DOUBLESTAR) {

  002c7	66 83 f8 23	 cmp	 ax, 35			; 00000023H
  002cb	75 39		 jne	 SHORT $LN29@ast_for_ca

; 2524 :             kwarg = ast_for_expr(c, CHILD(n, i+1));

  002cd	49 63 c5	 movsxd	 rax, r13d
  002d0	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  002d4	48 8d 14 ca	 lea	 rdx, QWORD PTR [rdx+rcx*8]
  002d8	48 8b cd	 mov	 rcx, rbp
  002db	e8 00 00 00 00	 call	 ast_for_expr
  002e0	48 89 44 24 58	 mov	 QWORD PTR kwarg$1$[rsp], rax
$LN76@ast_for_ca:

; 2525 :             if (!kwarg)

  002e5	48 85 c0	 test	 rax, rax
  002e8	0f 84 ec 00 00
	00		 je	 $LN62@ast_for_ca

; 2526 :                 return NULL;
; 2527 :             i++;

  002ee	41 ff c7	 inc	 r15d
  002f1	41 ff c5	 inc	 r13d
  002f4	48 83 c7 28	 add	 rdi, 40			; 00000028H
$LN71@ast_for_ca:
  002f8	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR keywords$1$[rsp]
$LN72@ast_for_ca:
  00300	41 b8 4b 01 00
	00		 mov	 r8d, 331		; 0000014bH
$LN29@ast_for_ca:

; 2450 :     nkeywords = 0;
; 2451 :     for (i = 0; i < NCH(n); i++) {

  00306	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR n$[rsp]
  0030e	48 83 c7 28	 add	 rdi, 40			; 00000028H
  00312	41 ff c7	 inc	 r15d
  00315	41 ff c5	 inc	 r13d
  00318	48 89 7c 24 50	 mov	 QWORD PTR tv641[rsp], rdi
  0031d	44 3b 7e 18	 cmp	 r15d, DWORD PTR [rsi+24]
  00321	0f 8c 29 fe ff
	ff		 jl	 $LL30@ast_for_ca

; 2405 :     /*
; 2406 :       arglist: (argument ',')* (argument [',']| '*' test [',' '**' test]
; 2407 :                | '**' test)
; 2408 :       argument: [test '='] (test) [comp_for]        # Really [keyword '='] test
; 2409 :     */
; 2410 : 
; 2411 :     int i, nargs, nkeywords, ngens;
; 2412 :     asdl_seq *args;
; 2413 :     asdl_seq *keywords;
; 2414 :     expr_ty vararg = NULL, kwarg = NULL;

  00327	48 8b 7c 24 58	 mov	 rdi, QWORD PTR kwarg$1$[rsp]
  0032c	4c 8b ac 24 c0
	00 00 00	 mov	 r13, QWORD PTR func$[rsp]
$LN67@ast_for_ca:

; 2528 :         }
; 2529 :     }
; 2530 : 
; 2531 :     return Call(func, args, keywords, vararg, kwarg, func->lineno, func->col_offset, c->c_arena);

  00334	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  00338	48 8b 54 24 60	 mov	 rdx, QWORD PTR args$1$[rsp]
  0033d	4c 8b c1	 mov	 r8, rcx
  00340	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00345	41 8b 45 34	 mov	 eax, DWORD PTR [r13+52]
  00349	4d 8b ce	 mov	 r9, r14
  0034c	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00350	41 8b 45 30	 mov	 eax, DWORD PTR [r13+48]
  00354	49 8b cd	 mov	 rcx, r13
  00357	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0035b	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00360	e8 00 00 00 00	 call	 _Py_Call
$LN70@ast_for_ca:
  00365	4c 8b a4 24 b0
	00 00 00	 mov	 r12, QWORD PTR [rsp+176]
  0036d	4c 8b 7c 24 70	 mov	 r15, QWORD PTR [rsp+112]

; 2532 : }

  00372	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00376	41 5e		 pop	 r14
  00378	41 5d		 pop	 r13
  0037a	5f		 pop	 rdi
  0037b	5e		 pop	 rsi
  0037c	5d		 pop	 rbp
  0037d	5b		 pop	 rbx
  0037e	c3		 ret	 0
$LN52@ast_for_ca:

; 2462 :                     ast_error(c, CHILD(ch, 0),
; 2463 :                               "only named arguments may follow *expression");

  0037f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CM@FHHDCLIK@only?5named?5arguments?5may?5follow?5@
  00386	e8 00 00 00 00	 call	 ast_error

; 2464 :                     return NULL;

  0038b	33 c0		 xor	 eax, eax
  0038d	eb d6		 jmp	 SHORT $LN70@ast_for_ca
$LN51@ast_for_ca:

; 2457 :                     ast_error(c, CHILD(ch, 0),
; 2458 :                               "non-keyword arg after keyword arg");

  0038f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CC@JMBPEODL@non?9keyword?5arg?5after?5keyword?5ar@
  00396	e8 00 00 00 00	 call	 ast_error

; 2459 :                     return NULL;

  0039b	33 c0		 xor	 eax, eax
  0039d	eb c6		 jmp	 SHORT $LN70@ast_for_ca
$LN50@ast_for_ca:

; 2504 :                         ast_error(c, CHILD(ch, 0), "keyword argument repeated");

  0039f	48 8b 56 20	 mov	 rdx, QWORD PTR [rsi+32]
  003a3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BK@CEBEDAAO@keyword?5argument?5repeated?$AA@
  003aa	48 8b cd	 mov	 rcx, rbp
  003ad	e8 00 00 00 00	 call	 ast_error

; 2505 :                         return NULL;

  003b2	33 c0		 xor	 eax, eax
  003b4	eb af		 jmp	 SHORT $LN70@ast_for_ca
$LN57@ast_for_ca:

; 2495 :                     ast_error(c, CHILD(ch, 0), "keyword can't be an expression");

  003b6	48 8b 56 20	 mov	 rdx, QWORD PTR [rsi+32]
  003ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BP@GJBMLMAG@keyword?5can?8t?5be?5an?5expression?$AA@
  003c1	e8 00 00 00 00	 call	 ast_error

; 2496 :                     return NULL;

  003c6	33 c0		 xor	 eax, eax
  003c8	eb 9b		 jmp	 SHORT $LN70@ast_for_ca
$LN56@ast_for_ca:

; 2492 :                     ast_error(c, CHILD(ch, 0), "lambda cannot contain assignment");

  003ca	48 8b 56 20	 mov	 rdx, QWORD PTR [rsi+32]
  003ce	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CB@FBIGLNOA@lambda?5cannot?5contain?5assignment@
  003d5	e8 00 00 00 00	 call	 ast_error
$LN62@ast_for_ca:

; 2493 :                     return NULL;

  003da	33 c0		 xor	 eax, eax
  003dc	eb 87		 jmp	 SHORT $LN70@ast_for_ca
ast_for_call ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@CPDJBKPL@assignment?5to?5yield?5expression?5n@ ; `string'
PUBLIC	??_C@_0CM@DDDJCEPJ@illegal?5expression?5for?5augmented@ ; `string'
EXTRN	_Py_Assign:PROC
EXTRN	_Py_AugAssign:PROC
EXTRN	_Py_Expr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_expr_stmt DD imagerel ast_for_expr_stmt
	DD	imagerel ast_for_expr_stmt+67
	DD	imagerel $unwind$ast_for_expr_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ast_for_expr_stmt DD imagerel ast_for_expr_stmt+67
	DD	imagerel ast_for_expr_stmt+273
	DD	imagerel $chain$1$ast_for_expr_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ast_for_expr_stmt DD imagerel ast_for_expr_stmt+273
	DD	imagerel ast_for_expr_stmt+310
	DD	imagerel $chain$3$ast_for_expr_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$ast_for_expr_stmt DD imagerel ast_for_expr_stmt+310
	DD	imagerel ast_for_expr_stmt+349
	DD	imagerel $chain$6$ast_for_expr_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$ast_for_expr_stmt DD imagerel ast_for_expr_stmt+349
	DD	imagerel ast_for_expr_stmt+586
	DD	imagerel $chain$8$ast_for_expr_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$ast_for_expr_stmt DD imagerel ast_for_expr_stmt+586
	DD	imagerel ast_for_expr_stmt+608
	DD	imagerel $chain$9$ast_for_expr_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$ast_for_expr_stmt DD 021H
	DD	imagerel ast_for_expr_stmt+310
	DD	imagerel ast_for_expr_stmt+349
	DD	imagerel $chain$6$ast_for_expr_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$ast_for_expr_stmt DD 040d21H
	DD	06e40dH
	DD	0cc405H
	DD	imagerel ast_for_expr_stmt+310
	DD	imagerel ast_for_expr_stmt+349
	DD	imagerel $chain$6$ast_for_expr_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$ast_for_expr_stmt DD 060621H
	DD	0dd406H
	DD	0b6400H
	DD	0a5400H
	DD	imagerel ast_for_expr_stmt
	DD	imagerel ast_for_expr_stmt+67
	DD	imagerel $unwind$ast_for_expr_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ast_for_expr_stmt DD 040021H
	DD	0b6400H
	DD	0a5400H
	DD	imagerel ast_for_expr_stmt
	DD	imagerel ast_for_expr_stmt+67
	DD	imagerel $unwind$ast_for_expr_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ast_for_expr_stmt DD 040a21H
	DD	0b640aH
	DD	0a5405H
	DD	imagerel ast_for_expr_stmt
	DD	imagerel ast_for_expr_stmt+67
	DD	imagerel $unwind$ast_for_expr_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_expr_stmt DD 030701H
	DD	070036207H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_0CM@CPDJBKPL@assignment?5to?5yield?5expression?5n@
CONST	SEGMENT
??_C@_0CM@CPDJBKPL@assignment?5to?5yield?5expression?5n@ DB 'assignment t'
	DB	'o yield expression not possible', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DDDJCEPJ@illegal?5expression?5for?5augmented@
CONST	SEGMENT
??_C@_0CM@DDDJCEPJ@illegal?5expression?5for?5augmented@ DB 'illegal expre'
	DB	'ssion for augmented assignment', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ast_for_expr_stmt
_TEXT	SEGMENT
c$ = 80
n$ = 88
ast_for_expr_stmt PROC					; COMDAT

; 2560 : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2561 :     REQ(n, expr_stmt);
; 2562 :     /* expr_stmt: testlist_star_expr (augassign (yield_expr|testlist)
; 2563 :                 | ('=' (yield_expr|testlist))*)
; 2564 :        testlist_star_expr: (test|star_expr) (',' test|star_expr)* [',']
; 2565 :        augassign: '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^='
; 2566 :                 | '<<=' | '>>=' | '**=' | '//='
; 2567 :        test: ... here starts the operator precendence dance
; 2568 :      */
; 2569 : 
; 2570 :     if (NCH(n) == 1) {

  00007	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	83 f8 01	 cmp	 eax, 1
  00013	75 2e		 jne	 SHORT $LN25@ast_for_ex@3

; 2571 :         expr_ty e = ast_for_testlist(c, CHILD(n, 0));

  00015	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00019	e8 00 00 00 00	 call	 ast_for_testlist

; 2572 :         if (!e)

  0001e	48 85 c0	 test	 rax, rax
  00021	75 07		 jne	 SHORT $LN24@ast_for_ex@3

; 2651 :     }
; 2652 : }

  00023	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00027	5f		 pop	 rdi
  00028	5b		 pop	 rbx
  00029	c3		 ret	 0
$LN24@ast_for_ex@3:

; 2573 :             return NULL;
; 2574 : 
; 2575 :         return Expr(e, LINENO(n), n->n_col_offset, c->c_arena);

  0002a	4c 8b 4f 08	 mov	 r9, QWORD PTR [rdi+8]
  0002e	44 8b 43 14	 mov	 r8d, DWORD PTR [rbx+20]
  00032	8b 53 10	 mov	 edx, DWORD PTR [rbx+16]
  00035	48 8b c8	 mov	 rcx, rax

; 2651 :     }
; 2652 : }

  00038	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003c	5f		 pop	 rdi
  0003d	5b		 pop	 rbx
  0003e	e9 00 00 00 00	 jmp	 _Py_Expr
$LN25@ast_for_ex@3:
  00043	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00048	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi

; 2576 :     }
; 2577 :     else if (TYPE(CHILD(n, 1)) == augassign) {

  0004d	48 8b 72 20	 mov	 rsi, QWORD PTR [rdx+32]
  00051	b9 11 01 00 00	 mov	 ecx, 273		; 00000111H
  00056	66 39 4e 28	 cmp	 WORD PTR [rsi+40], cx
  0005a	0f 85 d6 00 00
	00		 jne	 $LN22@ast_for_ex@3

; 2578 :         expr_ty expr1, expr2;
; 2579 :         operator_ty newoperator;
; 2580 :         node *ch = CHILD(n, 0);
; 2581 : 
; 2582 :         expr1 = ast_for_testlist(c, ch);

  00060	48 8b d6	 mov	 rdx, rsi
  00063	48 8b cf	 mov	 rcx, rdi
  00066	e8 00 00 00 00	 call	 ast_for_testlist
  0006b	48 8b e8	 mov	 rbp, rax

; 2583 :         if (!expr1)

  0006e	48 85 c0	 test	 rax, rax

; 2584 :             return NULL;

  00071	0f 84 ac 00 00
	00		 je	 $LN41@ast_for_ex@3

; 2585 :         if(!set_context(c, expr1, Store, ch))

  00077	4c 8b ce	 mov	 r9, rsi
  0007a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00080	48 8b d0	 mov	 rdx, rax
  00083	48 8b cf	 mov	 rcx, rdi
  00086	e8 00 00 00 00	 call	 set_context
  0008b	85 c0		 test	 eax, eax

; 2586 :             return NULL;

  0008d	0f 84 90 00 00
	00		 je	 $LN41@ast_for_ex@3

; 2587 :         /* set_context checks that most expressions are not the left side.
; 2588 :           Augmented assignments can only have a name, a subscript, or an
; 2589 :           attribute on the left, though, so we have to explicitly check for
; 2590 :           those. */
; 2591 :         switch (expr1->kind) {

  00093	8b 45 00	 mov	 eax, DWORD PTR [rbp]
  00096	83 f8 14	 cmp	 eax, 20
  00099	7c 76		 jl	 SHORT $LN16@ast_for_ex@3
  0009b	83 f8 15	 cmp	 eax, 21
  0009e	7e 05		 jle	 SHORT $LN17@ast_for_ex@3
  000a0	83 f8 17	 cmp	 eax, 23
  000a3	75 6c		 jne	 SHORT $LN16@ast_for_ex@3
$LN17@ast_for_ex@3:

; 2599 :         }
; 2600 : 
; 2601 :         ch = CHILD(n, 2);

  000a5	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]

; 2602 :         if (TYPE(ch) == testlist)

  000a9	b8 47 01 00 00	 mov	 eax, 327		; 00000147H

; 2603 :             expr2 = ast_for_testlist(c, ch);

  000ae	48 8b cf	 mov	 rcx, rdi
  000b1	48 83 c2 50	 add	 rdx, 80			; 00000050H
  000b5	66 39 02	 cmp	 WORD PTR [rdx], ax
  000b8	75 07		 jne	 SHORT $LN15@ast_for_ex@3
  000ba	e8 00 00 00 00	 call	 ast_for_testlist

; 2604 :         else

  000bf	eb 05		 jmp	 SHORT $LN38@ast_for_ex@3
$LN15@ast_for_ex@3:

; 2605 :             expr2 = ast_for_expr(c, ch);

  000c1	e8 00 00 00 00	 call	 ast_for_expr
$LN38@ast_for_ex@3:
  000c6	48 8b f0	 mov	 rsi, rax

; 2606 :         if (!expr2)

  000c9	48 85 c0	 test	 rax, rax

; 2607 :             return NULL;

  000cc	74 55		 je	 SHORT $LN41@ast_for_ex@3

; 2608 : 
; 2609 :         newoperator = ast_for_augassign(c, CHILD(n, 1));

  000ce	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  000d2	48 83 c1 28	 add	 rcx, 40			; 00000028H
  000d6	e8 00 00 00 00	 call	 ast_for_augassign
  000db	8b d0		 mov	 edx, eax

; 2610 :         if (!newoperator)

  000dd	85 c0		 test	 eax, eax

; 2611 :             return NULL;

  000df	74 42		 je	 SHORT $LN41@ast_for_ex@3

; 2612 : 
; 2613 :         return AugAssign(expr1, newoperator, expr2, LINENO(n), n->n_col_offset, c->c_arena);

  000e1	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  000e5	44 8b 4b 10	 mov	 r9d, DWORD PTR [rbx+16]
  000e9	4c 8b c6	 mov	 r8, rsi
  000ec	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f1	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  000f4	48 8b cd	 mov	 rcx, rbp
  000f7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000fb	e8 00 00 00 00	 call	 _Py_AugAssign
  00100	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00105	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]

; 2651 :     }
; 2652 : }

  0010a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0010e	5f		 pop	 rdi
  0010f	5b		 pop	 rbx
  00110	c3		 ret	 0
$LN16@ast_for_ex@3:

; 2592 :             case Name_kind:
; 2593 :             case Attribute_kind:
; 2594 :             case Subscript_kind:
; 2595 :                 break;
; 2596 :             default:
; 2597 :                 ast_error(c, ch, "illegal expression for augmented assignment");

  00111	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CM@DDDJCEPJ@illegal?5expression?5for?5augmented@
  00118	48 8b d6	 mov	 rdx, rsi
  0011b	48 8b cf	 mov	 rcx, rdi
  0011e	e8 00 00 00 00	 call	 ast_error
$LN41@ast_for_ex@3:

; 2598 :                 return NULL;

  00123	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00128	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0012d	33 c0		 xor	 eax, eax

; 2651 :     }
; 2652 : }

  0012f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00133	5f		 pop	 rdi
  00134	5b		 pop	 rbx
  00135	c3		 ret	 0
$LN22@ast_for_ex@3:

; 2614 :     }
; 2615 :     else {
; 2616 :         int i;
; 2617 :         asdl_seq *targets;
; 2618 :         node *value;
; 2619 :         expr_ty expression;
; 2620 : 
; 2621 :         /* a normal assignment */
; 2622 :         REQ(CHILD(n, 1), EQUAL);
; 2623 :         targets = asdl_seq_new(NCH(n) / 2, c->c_arena);

  00136	99		 cdq
  00137	4c 89 6c 24 68	 mov	 QWORD PTR [rsp+104], r13
  0013c	2b c2		 sub	 eax, edx
  0013e	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  00142	d1 f8		 sar	 eax, 1
  00144	48 63 c8	 movsxd	 rcx, eax
  00147	e8 00 00 00 00	 call	 asdl_seq_new
  0014c	4c 8b e8	 mov	 r13, rax

; 2624 :         if (!targets)

  0014f	48 85 c0	 test	 rax, rax
  00152	0f 84 f2 00 00
	00		 je	 $LN35@ast_for_ex@3
$LN10@ast_for_ex@3:

; 2625 :             return NULL;
; 2626 :         for (i = 0; i < NCH(n) - 2; i += 2) {

  00158	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  0015b	33 f6		 xor	 esi, esi
  0015d	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  00162	83 e8 02	 sub	 eax, 2
  00165	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  0016a	85 c0		 test	 eax, eax
  0016c	7e 75		 jle	 SHORT $LN7@ast_for_ex@3
  0016e	44 8b e6	 mov	 r12d, esi
  00171	41 be 50 01 00
	00		 mov	 r14d, 336		; 00000150H
  00177	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL9@ast_for_ex@3:

; 2627 :             expr_ty e;
; 2628 :             node *ch = CHILD(n, i);

  00180	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]

; 2632 :             }
; 2633 :             e = ast_for_testlist(c, ch);

  00184	48 8b cf	 mov	 rcx, rdi
  00187	66 45 39 34 04	 cmp	 WORD PTR [r12+rax], r14w
  0018c	49 8d 14 04	 lea	 rdx, QWORD PTR [r12+rax]
  00190	74 78		 je	 SHORT $LN29@ast_for_ex@3
  00192	e8 00 00 00 00	 call	 ast_for_testlist
  00197	48 8b e8	 mov	 rbp, rax

; 2634 :             if (!e)

  0019a	48 85 c0	 test	 rax, rax
  0019d	74 77		 je	 SHORT $LN40@ast_for_ex@3

; 2635 :               return NULL;
; 2636 : 
; 2637 :             /* set context to assign */
; 2638 :             if (!set_context(c, e, Store, CHILD(n, i)))

  0019f	48 63 ce	 movsxd	 rcx, esi
  001a2	41 b8 02 00 00
	00		 mov	 r8d, 2
  001a8	48 8d 14 89	 lea	 rdx, QWORD PTR [rcx+rcx*4]
  001ac	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  001b0	4c 8d 0c d1	 lea	 r9, QWORD PTR [rcx+rdx*8]
  001b4	48 8b d0	 mov	 rdx, rax
  001b7	48 8b cf	 mov	 rcx, rdi
  001ba	e8 00 00 00 00	 call	 set_context
  001bf	85 c0		 test	 eax, eax
  001c1	74 53		 je	 SHORT $LN40@ast_for_ex@3

; 2639 :               return NULL;
; 2640 : 
; 2641 :             asdl_seq_SET(targets, i / 2, e);

  001c3	8b c6		 mov	 eax, esi
  001c5	83 c6 02	 add	 esi, 2
  001c8	49 83 c4 50	 add	 r12, 80			; 00000050H
  001cc	99		 cdq
  001cd	2b c2		 sub	 eax, edx
  001cf	d1 f8		 sar	 eax, 1
  001d1	48 63 c8	 movsxd	 rcx, eax
  001d4	49 89 6c cd 08	 mov	 QWORD PTR [r13+rcx*8+8], rbp
  001d9	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  001dc	83 e8 02	 sub	 eax, 2
  001df	3b f0		 cmp	 esi, eax
  001e1	7c 9d		 jl	 SHORT $LL9@ast_for_ex@3
$LN7@ast_for_ex@3:

; 2642 :         }
; 2643 :         value = CHILD(n, NCH(n) - 1);

  001e3	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  001e6	ff c8		 dec	 eax
  001e8	48 98		 cdqe
  001ea	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  001ee	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001f2	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]

; 2644 :         if (TYPE(value) == testlist_star_expr)

  001f6	b8 10 01 00 00	 mov	 eax, 272		; 00000110H

; 2645 :             expression = ast_for_testlist(c, value);

  001fb	48 8b cf	 mov	 rcx, rdi
  001fe	66 39 02	 cmp	 WORD PTR [rdx], ax
  00201	75 17		 jne	 SHORT $LN3@ast_for_ex@3
  00203	e8 00 00 00 00	 call	 ast_for_testlist

; 2646 :         else

  00208	eb 15		 jmp	 SHORT $LN39@ast_for_ex@3
$LN29@ast_for_ex@3:

; 2629 :             if (TYPE(ch) == yield_expr) {
; 2630 :                 ast_error(c, ch, "assignment to yield expression not possible");

  0020a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CM@CPDJBKPL@assignment?5to?5yield?5expression?5n@
  00211	e8 00 00 00 00	 call	 ast_error
$LN40@ast_for_ex@3:

; 2631 :                 return NULL;

  00216	33 c0		 xor	 eax, eax
  00218	eb 26		 jmp	 SHORT $LN37@ast_for_ex@3
$LN3@ast_for_ex@3:

; 2647 :             expression = ast_for_expr(c, value);

  0021a	e8 00 00 00 00	 call	 ast_for_expr
$LN39@ast_for_ex@3:
  0021f	48 8b d0	 mov	 rdx, rax

; 2648 :         if (!expression)

  00222	48 85 c0	 test	 rax, rax

; 2649 :             return NULL;

  00225	74 ef		 je	 SHORT $LN40@ast_for_ex@3

; 2650 :         return Assign(targets, expression, LINENO(n), n->n_col_offset, c->c_arena);

  00227	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  0022b	44 8b 4b 14	 mov	 r9d, DWORD PTR [rbx+20]
  0022f	44 8b 43 10	 mov	 r8d, DWORD PTR [rbx+16]
  00233	49 8b cd	 mov	 rcx, r13
  00236	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023b	e8 00 00 00 00	 call	 _Py_Assign
$LN37@ast_for_ex@3:
  00240	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]
  00245	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]
$LN35@ast_for_ex@3:
  0024a	4c 8b 6c 24 68	 mov	 r13, QWORD PTR [rsp+104]
  0024f	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00254	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]

; 2651 :     }
; 2652 : }

  00259	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0025d	5f		 pop	 rdi
  0025e	5b		 pop	 rbx
  0025f	c3		 ret	 0
ast_for_expr_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@GBCOJIIK@unexpected?5flow_stmt?3?5?$CFd?$AA@ ; `string'
EXTRN	_Py_Break:PROC
EXTRN	_Py_Continue:PROC
EXTRN	_Py_Return:PROC
EXTRN	_Py_Raise:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_flow_stmt DD imagerel ast_for_flow_stmt
	DD	imagerel ast_for_flow_stmt+139
	DD	imagerel $unwind$ast_for_flow_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ast_for_flow_stmt DD imagerel ast_for_flow_stmt+139
	DD	imagerel ast_for_flow_stmt+229
	DD	imagerel $chain$1$ast_for_flow_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ast_for_flow_stmt DD imagerel ast_for_flow_stmt+229
	DD	imagerel ast_for_flow_stmt+259
	DD	imagerel $chain$3$ast_for_flow_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ast_for_flow_stmt DD imagerel ast_for_flow_stmt+259
	DD	imagerel ast_for_flow_stmt+508
	DD	imagerel $chain$4$ast_for_flow_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ast_for_flow_stmt DD 021H
	DD	imagerel ast_for_flow_stmt
	DD	imagerel ast_for_flow_stmt+139
	DD	imagerel $unwind$ast_for_flow_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ast_for_flow_stmt DD 040021H
	DD	09c400H
	DD	085400H
	DD	imagerel ast_for_flow_stmt
	DD	imagerel ast_for_flow_stmt+139
	DD	imagerel $unwind$ast_for_flow_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ast_for_flow_stmt DD 041121H
	DD	09c411H
	DD	085405H
	DD	imagerel ast_for_flow_stmt
	DD	imagerel ast_for_flow_stmt+139
	DD	imagerel $unwind$ast_for_flow_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_flow_stmt DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0BJ@GBCOJIIK@unexpected?5flow_stmt?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BJ@GBCOJIIK@unexpected?5flow_stmt?3?5?$CFd?$AA@ DB 'unexpected flo'
	DB	'w_stmt: %d', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ast_for_flow_stmt
_TEXT	SEGMENT
c$ = 64
n$ = 72
ast_for_flow_stmt PROC					; COMDAT

; 2694 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2695 :     /*
; 2696 :       flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt
; 2697 :                  | yield_stmt
; 2698 :       break_stmt: 'break'
; 2699 :       continue_stmt: 'continue'
; 2700 :       return_stmt: 'return' [testlist]
; 2701 :       yield_stmt: yield_expr
; 2702 :       yield_expr: 'yield' testlist | 'yield' 'from' test
; 2703 :       raise_stmt: 'raise' [test [',' test [',' test]]]
; 2704 :     */
; 2705 :     node *ch;
; 2706 : 
; 2707 :     REQ(n, flow_stmt);
; 2708 :     ch = CHILD(n, 0);

  0000f	48 8b 7a 20	 mov	 rdi, QWORD PTR [rdx+32]
  00013	48 8b f1	 mov	 rsi, rcx
  00016	48 8b da	 mov	 rbx, rdx

; 2709 :     switch (TYPE(ch)) {

  00019	0f bf 0f	 movsx	 ecx, WORD PTR [rdi]
  0001c	44 8b c1	 mov	 r8d, ecx
  0001f	41 81 e8 15 01
	00 00		 sub	 r8d, 277		; 00000115H
  00026	0f 84 b2 01 00
	00		 je	 $LN16@ast_for_fl
  0002c	41 ff c8	 dec	 r8d
  0002f	0f 84 8b 01 00
	00		 je	 $LN15@ast_for_fl
  00035	41 ff c8	 dec	 r8d
  00038	0f 84 20 01 00
	00		 je	 $LN12@ast_for_fl
  0003e	41 ff c8	 dec	 r8d
  00041	0f 84 e4 00 00
	00		 je	 $LN14@ast_for_fl
  00047	41 ff c8	 dec	 r8d
  0004a	0f 85 b3 00 00
	00		 jne	 $LN5@ast_for_fl

; 2728 :             }
; 2729 :         case raise_stmt:
; 2730 :             if (NCH(ch) == 1)

  00050	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  00053	83 f8 01	 cmp	 eax, 1
  00056	75 2a		 jne	 SHORT $LN7@ast_for_fl

; 2731 :                 return Raise(NULL, NULL, LINENO(n), n->n_col_offset, c->c_arena);

  00058	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  0005c	44 8b 4a 14	 mov	 r9d, DWORD PTR [rdx+20]
  00060	44 8b 42 10	 mov	 r8d, DWORD PTR [rdx+16]
  00064	33 d2		 xor	 edx, edx
  00066	33 c9		 xor	 ecx, ecx
  00068	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006d	e8 00 00 00 00	 call	 _Py_Raise

; 2748 :     }
; 2749 : 
; 2750 :     PyErr_SetString(PyExc_SystemError, "unhandled flow statement");
; 2751 :     return NULL;
; 2752 : }

  00072	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00077	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0007c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
$LN7@ast_for_fl:

; 2732 :             else if (NCH(ch) >= 2) {

  00082	83 f8 02	 cmp	 eax, 2
  00085	7c 7c		 jl	 SHORT $LN5@ast_for_fl

; 2733 :                 expr_ty cause = NULL;
; 2734 :                 expr_ty expression = ast_for_expr(c, CHILD(ch, 1));

  00087	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  0008b	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00090	48 8b ce	 mov	 rcx, rsi
  00093	48 83 c2 28	 add	 rdx, 40			; 00000028H
  00097	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  0009c	33 ed		 xor	 ebp, ebp
  0009e	e8 00 00 00 00	 call	 ast_for_expr
  000a3	4c 8b e0	 mov	 r12, rax

; 2735 :                 if (!expression)

  000a6	48 85 c0	 test	 rax, rax

; 2736 :                     return NULL;

  000a9	74 1e		 je	 SHORT $LN23@ast_for_fl

; 2737 :                 if (NCH(ch) == 4) {

  000ab	83 7f 18 04	 cmp	 DWORD PTR [rdi+24], 4
  000af	75 34		 jne	 SHORT $LN2@ast_for_fl

; 2738 :                     cause = ast_for_expr(c, CHILD(ch, 3));

  000b1	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  000b5	48 8b ce	 mov	 rcx, rsi
  000b8	48 83 c2 78	 add	 rdx, 120		; 00000078H
  000bc	e8 00 00 00 00	 call	 ast_for_expr
  000c1	48 8b e8	 mov	 rbp, rax

; 2739 :                     if (!cause)

  000c4	48 85 c0	 test	 rax, rax
  000c7	75 1c		 jne	 SHORT $LN2@ast_for_fl
$LN23@ast_for_fl:

; 2740 :                         return NULL;

  000c9	33 c0		 xor	 eax, eax
$LN22@ast_for_fl:
  000cb	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000d0	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]

; 2748 :     }
; 2749 : 
; 2750 :     PyErr_SetString(PyExc_SystemError, "unhandled flow statement");
; 2751 :     return NULL;
; 2752 : }

  000d5	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000da	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  000df	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e3	5f		 pop	 rdi
  000e4	c3		 ret	 0
$LN2@ast_for_fl:

; 2741 :                 }
; 2742 :                 return Raise(expression, cause, LINENO(n), n->n_col_offset, c->c_arena);

  000e5	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  000e9	44 8b 4b 14	 mov	 r9d, DWORD PTR [rbx+20]
  000ed	44 8b 43 10	 mov	 r8d, DWORD PTR [rbx+16]
  000f1	48 8b d5	 mov	 rdx, rbp
  000f4	49 8b cc	 mov	 rcx, r12
  000f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fc	e8 00 00 00 00	 call	 _Py_Raise
  00101	eb c8		 jmp	 SHORT $LN22@ast_for_fl
$LN5@ast_for_fl:

; 2743 :             }
; 2744 :         default:
; 2745 :             PyErr_Format(PyExc_SystemError,
; 2746 :                          "unexpected flow_stmt: %d", TYPE(ch));

  00103	44 8b c1	 mov	 r8d, ecx
  00106	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0010d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@GBCOJIIK@unexpected?5flow_stmt?3?5?$CFd?$AA@
  00114	e8 00 00 00 00	 call	 PyErr_Format
$LN24@ast_for_fl:

; 2747 :             return NULL;

  00119	33 c0		 xor	 eax, eax

; 2748 :     }
; 2749 : 
; 2750 :     PyErr_SetString(PyExc_SystemError, "unhandled flow statement");
; 2751 :     return NULL;
; 2752 : }

  0011b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00120	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00125	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00129	5f		 pop	 rdi
  0012a	c3		 ret	 0
$LN14@ast_for_fl:

; 2714 :         case yield_stmt: { /* will reduce to yield_expr */
; 2715 :             expr_ty exp = ast_for_expr(c, CHILD(ch, 0));

  0012b	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  0012f	48 8b ce	 mov	 rcx, rsi
  00132	e8 00 00 00 00	 call	 ast_for_expr

; 2716 :             if (!exp)

  00137	48 85 c0	 test	 rax, rax

; 2717 :                 return NULL;

  0013a	74 dd		 je	 SHORT $LN24@ast_for_fl

; 2718 :             return Expr(exp, LINENO(n), n->n_col_offset, c->c_arena);

  0013c	4c 8b 4e 08	 mov	 r9, QWORD PTR [rsi+8]
  00140	44 8b 43 14	 mov	 r8d, DWORD PTR [rbx+20]
  00144	8b 53 10	 mov	 edx, DWORD PTR [rbx+16]
  00147	48 8b c8	 mov	 rcx, rax

; 2748 :     }
; 2749 : 
; 2750 :     PyErr_SetString(PyExc_SystemError, "unhandled flow statement");
; 2751 :     return NULL;
; 2752 : }

  0014a	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0014f	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00154	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00158	5f		 pop	 rdi
  00159	e9 00 00 00 00	 jmp	 _Py_Expr
$LN12@ast_for_fl:

; 2719 :         }
; 2720 :         case return_stmt:
; 2721 :             if (NCH(ch) == 1)

  0015e	83 7f 18 01	 cmp	 DWORD PTR [rdi+24], 1
  00162	75 21		 jne	 SHORT $LN11@ast_for_fl

; 2722 :                 return Return(NULL, LINENO(n), n->n_col_offset, c->c_arena);

  00164	44 8b 42 14	 mov	 r8d, DWORD PTR [rdx+20]
  00168	4c 8b 4e 08	 mov	 r9, QWORD PTR [rsi+8]
  0016c	8b 52 10	 mov	 edx, DWORD PTR [rdx+16]
  0016f	33 c9		 xor	 ecx, ecx

; 2748 :     }
; 2749 : 
; 2750 :     PyErr_SetString(PyExc_SystemError, "unhandled flow statement");
; 2751 :     return NULL;
; 2752 : }

  00171	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00176	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0017b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0017f	5f		 pop	 rdi
  00180	e9 00 00 00 00	 jmp	 _Py_Return
$LN11@ast_for_fl:

; 2723 :             else {
; 2724 :                 expr_ty expression = ast_for_testlist(c, CHILD(ch, 1));

  00185	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  00189	48 8b ce	 mov	 rcx, rsi
  0018c	48 83 c2 28	 add	 rdx, 40			; 00000028H
  00190	e8 00 00 00 00	 call	 ast_for_testlist

; 2725 :                 if (!expression)

  00195	48 85 c0	 test	 rax, rax

; 2726 :                     return NULL;

  00198	0f 84 7b ff ff
	ff		 je	 $LN24@ast_for_fl

; 2727 :                 return Return(expression, LINENO(n), n->n_col_offset, c->c_arena);

  0019e	4c 8b 4e 08	 mov	 r9, QWORD PTR [rsi+8]
  001a2	44 8b 43 14	 mov	 r8d, DWORD PTR [rbx+20]
  001a6	8b 53 10	 mov	 edx, DWORD PTR [rbx+16]
  001a9	48 8b c8	 mov	 rcx, rax

; 2748 :     }
; 2749 : 
; 2750 :     PyErr_SetString(PyExc_SystemError, "unhandled flow statement");
; 2751 :     return NULL;
; 2752 : }

  001ac	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001b1	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  001b6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001ba	5f		 pop	 rdi
  001bb	e9 00 00 00 00	 jmp	 _Py_Return
$LN15@ast_for_fl:

; 2712 :         case continue_stmt:
; 2713 :             return Continue(LINENO(n), n->n_col_offset, c->c_arena);

  001c0	4c 8b 46 08	 mov	 r8, QWORD PTR [rsi+8]
  001c4	8b 52 14	 mov	 edx, DWORD PTR [rdx+20]
  001c7	8b 4b 10	 mov	 ecx, DWORD PTR [rbx+16]

; 2748 :     }
; 2749 : 
; 2750 :     PyErr_SetString(PyExc_SystemError, "unhandled flow statement");
; 2751 :     return NULL;
; 2752 : }

  001ca	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001cf	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  001d4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001d8	5f		 pop	 rdi
  001d9	e9 00 00 00 00	 jmp	 _Py_Continue
$LN16@ast_for_fl:

; 2710 :         case break_stmt:
; 2711 :             return Break(LINENO(n), n->n_col_offset, c->c_arena);

  001de	4c 8b 46 08	 mov	 r8, QWORD PTR [rsi+8]
  001e2	8b 52 14	 mov	 edx, DWORD PTR [rdx+20]
  001e5	8b 4b 10	 mov	 ecx, DWORD PTR [rbx+16]

; 2748 :     }
; 2749 : 
; 2750 :     PyErr_SetString(PyExc_SystemError, "unhandled flow statement");
; 2751 :     return NULL;
; 2752 : }

  001e8	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001ed	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  001f2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001f6	5f		 pop	 rdi
  001f7	e9 00 00 00 00	 jmp	 _Py_Break
ast_for_flow_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@MLKGHAGN@improper?5number?5of?5parts?5to?5?8ass@ ; `string'
EXTRN	_Py_Assert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_assert_stmt DD imagerel ast_for_assert_stmt
	DD	imagerel ast_for_assert_stmt+96
	DD	imagerel $unwind$ast_for_assert_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ast_for_assert_stmt DD imagerel ast_for_assert_stmt+96
	DD	imagerel ast_for_assert_stmt+160
	DD	imagerel $chain$0$ast_for_assert_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ast_for_assert_stmt DD imagerel ast_for_assert_stmt+160
	DD	imagerel ast_for_assert_stmt+201
	DD	imagerel $chain$2$ast_for_assert_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ast_for_assert_stmt DD imagerel ast_for_assert_stmt+201
	DD	imagerel ast_for_assert_stmt+233
	DD	imagerel $chain$3$ast_for_assert_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ast_for_assert_stmt DD 021H
	DD	imagerel ast_for_assert_stmt
	DD	imagerel ast_for_assert_stmt+96
	DD	imagerel $unwind$ast_for_assert_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ast_for_assert_stmt DD 020021H
	DD	086400H
	DD	imagerel ast_for_assert_stmt
	DD	imagerel ast_for_assert_stmt+96
	DD	imagerel $unwind$ast_for_assert_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ast_for_assert_stmt DD 020521H
	DD	086405H
	DD	imagerel ast_for_assert_stmt
	DD	imagerel ast_for_assert_stmt+96
	DD	imagerel $unwind$ast_for_assert_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_assert_stmt DD 040a01H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0DD@MLKGHAGN@improper?5number?5of?5parts?5to?5?8ass@
CONST	SEGMENT
??_C@_0DD@MLKGHAGN@improper?5number?5of?5parts?5to?5?8ass@ DB 'improper n'
	DB	'umber of parts to ''assert'' statement: %d', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ast_for_assert_stmt
_TEXT	SEGMENT
c$ = 64
n$ = 72
ast_for_assert_stmt PROC				; COMDAT

; 3024 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3025 :     /* assert_stmt: 'assert' test [',' test] */
; 3026 :     REQ(n, assert_stmt);
; 3027 :     if (NCH(n) == 2) {

  0000a	44 8b 42 18	 mov	 r8d, DWORD PTR [rdx+24]
  0000e	48 8b da	 mov	 rbx, rdx
  00011	48 8b f9	 mov	 rdi, rcx
  00014	41 83 f8 02	 cmp	 r8d, 2
  00018	75 3c		 jne	 SHORT $LN6@ast_for_as

; 3028 :         expr_ty expression = ast_for_expr(c, CHILD(n, 1));

  0001a	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  0001e	48 83 c2 28	 add	 rdx, 40			; 00000028H
  00022	e8 00 00 00 00	 call	 ast_for_expr
  00027	48 8b c8	 mov	 rcx, rax

; 3029 :         if (!expression)

  0002a	48 85 c0	 test	 rax, rax

; 3030 :             return NULL;

  0002d	0f 84 a9 00 00
	00		 je	 $LN11@ast_for_as

; 3031 :         return Assert(expression, NULL, LINENO(n), n->n_col_offset, c->c_arena);

  00033	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00037	44 8b 4b 14	 mov	 r9d, DWORD PTR [rbx+20]
  0003b	44 8b 43 10	 mov	 r8d, DWORD PTR [rbx+16]
  0003f	33 d2		 xor	 edx, edx
  00041	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00046	e8 00 00 00 00	 call	 _Py_Assert

; 3049 : }

  0004b	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00050	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00054	5f		 pop	 rdi
  00055	c3		 ret	 0
$LN6@ast_for_as:

; 3032 :     }
; 3033 :     else if (NCH(n) == 4) {

  00056	41 83 f8 04	 cmp	 r8d, 4
  0005a	75 6d		 jne	 SHORT $LN3@ast_for_as

; 3034 :         expr_ty expr1, expr2;
; 3035 : 
; 3036 :         expr1 = ast_for_expr(c, CHILD(n, 1));

  0005c	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00060	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00065	48 83 c2 28	 add	 rdx, 40			; 00000028H
  00069	e8 00 00 00 00	 call	 ast_for_expr
  0006e	48 8b f0	 mov	 rsi, rax

; 3037 :         if (!expr1)

  00071	48 85 c0	 test	 rax, rax

; 3038 :             return NULL;

  00074	74 18		 je	 SHORT $LN10@ast_for_as

; 3039 :         expr2 = ast_for_expr(c, CHILD(n, 3));

  00076	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  0007a	48 8b cf	 mov	 rcx, rdi
  0007d	48 83 c2 78	 add	 rdx, 120		; 00000078H
  00081	e8 00 00 00 00	 call	 ast_for_expr
  00086	48 8b d0	 mov	 rdx, rax

; 3040 :         if (!expr2)

  00089	48 85 c0	 test	 rax, rax
  0008c	75 12		 jne	 SHORT $LN1@ast_for_as
$LN10@ast_for_as:

; 3041 :             return NULL;

  0008e	33 c0		 xor	 eax, eax
  00090	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 3049 : }

  00095	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0009a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
$LN1@ast_for_as:

; 3042 : 
; 3043 :         return Assert(expr1, expr2, LINENO(n), n->n_col_offset, c->c_arena);

  000a0	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  000a4	44 8b 4b 14	 mov	 r9d, DWORD PTR [rbx+20]
  000a8	44 8b 43 10	 mov	 r8d, DWORD PTR [rbx+16]
  000ac	48 8b ce	 mov	 rcx, rsi
  000af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b4	e8 00 00 00 00	 call	 _Py_Assert
  000b9	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 3049 : }

  000be	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000c3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c7	5f		 pop	 rdi
  000c8	c3		 ret	 0
$LN3@ast_for_as:

; 3044 :     }
; 3045 :     PyErr_Format(PyExc_SystemError,
; 3046 :                  "improper number of parts to 'assert' statement: %d",
; 3047 :                  NCH(n));

  000c9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@MLKGHAGN@improper?5number?5of?5parts?5to?5?8ass@
  000d7	e8 00 00 00 00	 call	 PyErr_Format
$LN11@ast_for_as:

; 3048 :     return NULL;

  000dc	33 c0		 xor	 eax, eax

; 3049 : }

  000de	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000e3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e7	5f		 pop	 rdi
  000e8	c3		 ret	 0
ast_for_assert_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@DBODNALO@unexpected?5token?5in?5?8if?8?5stateme@ ; `string'
EXTRN	_Py_If:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_if_stmt DD imagerel ast_for_if_stmt
	DD	imagerel ast_for_if_stmt+120
	DD	imagerel $unwind$ast_for_if_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ast_for_if_stmt DD imagerel ast_for_if_stmt+120
	DD	imagerel ast_for_if_stmt+269
	DD	imagerel $chain$0$ast_for_if_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ast_for_if_stmt DD imagerel ast_for_if_stmt+269
	DD	imagerel ast_for_if_stmt+544
	DD	imagerel $chain$4$ast_for_if_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$ast_for_if_stmt DD imagerel ast_for_if_stmt+544
	DD	imagerel ast_for_if_stmt+828
	DD	imagerel $chain$6$ast_for_if_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$ast_for_if_stmt DD imagerel ast_for_if_stmt+828
	DD	imagerel ast_for_if_stmt+851
	DD	imagerel $chain$7$ast_for_if_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$ast_for_if_stmt DD imagerel ast_for_if_stmt+851
	DD	imagerel ast_for_if_stmt+884
	DD	imagerel $chain$9$ast_for_if_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$ast_for_if_stmt DD imagerel ast_for_if_stmt+884
	DD	imagerel ast_for_if_stmt+918
	DD	imagerel $chain$10$ast_for_if_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$ast_for_if_stmt DD 020021H
	DD	0c5400H
	DD	imagerel ast_for_if_stmt
	DD	imagerel ast_for_if_stmt+120
	DD	imagerel $unwind$ast_for_if_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$ast_for_if_stmt DD 0a0021H
	DD	06f400H
	DD	07e400H
	DD	0fd400H
	DD	0ec400H
	DD	0c5400H
	DD	imagerel ast_for_if_stmt
	DD	imagerel ast_for_if_stmt+120
	DD	imagerel $unwind$ast_for_if_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$ast_for_if_stmt DD 021H
	DD	imagerel ast_for_if_stmt+269
	DD	imagerel ast_for_if_stmt+544
	DD	imagerel $chain$4$ast_for_if_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$ast_for_if_stmt DD 040a21H
	DD	07e40aH
	DD	0fd405H
	DD	imagerel ast_for_if_stmt+269
	DD	imagerel ast_for_if_stmt+544
	DD	imagerel $chain$4$ast_for_if_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ast_for_if_stmt DD 064421H
	DD	0ec444H
	DD	06f411H
	DD	0c5400H
	DD	imagerel ast_for_if_stmt
	DD	imagerel ast_for_if_stmt+120
	DD	imagerel $unwind$ast_for_if_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ast_for_if_stmt DD 020521H
	DD	0c5405H
	DD	imagerel ast_for_if_stmt
	DD	imagerel ast_for_if_stmt+120
	DD	imagerel $unwind$ast_for_if_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_if_stmt DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT ??_C@_0CH@DBODNALO@unexpected?5token?5in?5?8if?8?5stateme@
CONST	SEGMENT
??_C@_0CH@DBODNALO@unexpected?5token?5in?5?8if?8?5stateme@ DB 'unexpected'
	DB	' token in ''if'' statement: %s', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ast_for_if_stmt
_TEXT	SEGMENT
c$ = 96
$T26589 = 104
n$ = 104
ast_for_if_stmt PROC					; COMDAT

; 3119 : {

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00008	48 8b da	 mov	 rbx, rdx

; 3120 :     /* if_stmt: 'if' test ':' suite ('elif' test ':' suite)*
; 3121 :        ['else' ':' suite]
; 3122 :     */
; 3123 :     char *s;
; 3124 : 
; 3125 :     REQ(n, if_stmt);
; 3126 : 
; 3127 :     if (NCH(n) == 4) {

  0000b	8b 52 18	 mov	 edx, DWORD PTR [rdx+24]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	83 fa 04	 cmp	 edx, 4
  00014	75 5e		 jne	 SHORT $LN23@ast_for_if@2

; 3128 :         expr_ty expression;
; 3129 :         asdl_seq *suite_seq;
; 3130 : 
; 3131 :         expression = ast_for_expr(c, CHILD(n, 1));

  00016	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  0001a	48 83 c2 28	 add	 rdx, 40			; 00000028H
  0001e	e8 00 00 00 00	 call	 ast_for_expr
  00023	48 8b f0	 mov	 rsi, rax

; 3132 :         if (!expression)

  00026	48 85 c0	 test	 rax, rax
  00029	75 0a		 jne	 SHORT $LN22@ast_for_if@2
$LN39@ast_for_if@2:

; 3133 :             return NULL;

  0002b	33 c0		 xor	 eax, eax

; 3235 : }

  0002d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00031	5f		 pop	 rdi
  00032	5e		 pop	 rsi
  00033	5b		 pop	 rbx
  00034	c3		 ret	 0
$LN22@ast_for_if@2:

; 3134 :         suite_seq = ast_for_suite(c, CHILD(n, 3));

  00035	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00039	48 8b cf	 mov	 rcx, rdi
  0003c	48 83 c2 78	 add	 rdx, 120		; 00000078H
  00040	e8 00 00 00 00	 call	 ast_for_suite
  00045	48 8b d0	 mov	 rdx, rax

; 3135 :         if (!suite_seq)

  00048	48 85 c0	 test	 rax, rax

; 3136 :             return NULL;

  0004b	74 de		 je	 SHORT $LN39@ast_for_if@2

; 3137 : 
; 3138 :         return If(expression, suite_seq, NULL, LINENO(n), n->n_col_offset,
; 3139 :                   c->c_arena);

  0004d	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00051	44 8b 4b 10	 mov	 r9d, DWORD PTR [rbx+16]
  00055	45 33 c0	 xor	 r8d, r8d
  00058	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0005d	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  00060	48 8b ce	 mov	 rcx, rsi
  00063	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00067	e8 00 00 00 00	 call	 _Py_If

; 3235 : }

  0006c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00070	5f		 pop	 rdi
  00071	5e		 pop	 rsi
  00072	5b		 pop	 rbx
  00073	c3		 ret	 0
$LN23@ast_for_if@2:

; 3140 :     }
; 3141 : 
; 3142 :     s = STR(CHILD(n, 4));

  00074	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00078	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  0007d	4c 8b 80 a8 00
	00 00		 mov	 r8, QWORD PTR [rax+168]

; 3143 :     /* s[2], the third character in the string, will be
; 3144 :        's' for el_s_e, or
; 3145 :        'i' for el_i_f
; 3146 :     */
; 3147 :     if (s[2] == 's') {

  00084	41 0f b6 48 02	 movzx	 ecx, BYTE PTR [r8+2]
  00089	80 f9 73	 cmp	 cl, 115			; 00000073H
  0008c	75 7f		 jne	 SHORT $LN20@ast_for_if@2

; 3148 :         expr_ty expression;
; 3149 :         asdl_seq *seq1, *seq2;
; 3150 : 
; 3151 :         expression = ast_for_expr(c, CHILD(n, 1));

  0008e	48 8d 50 28	 lea	 rdx, QWORD PTR [rax+40]
  00092	48 8b cf	 mov	 rcx, rdi
  00095	e8 00 00 00 00	 call	 ast_for_expr
  0009a	48 8b f0	 mov	 rsi, rax

; 3152 :         if (!expression)

  0009d	48 85 c0	 test	 rax, rax

; 3153 :             return NULL;

  000a0	0f 84 e1 02 00
	00		 je	 $LN38@ast_for_if@2

; 3154 :         seq1 = ast_for_suite(c, CHILD(n, 3));

  000a6	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  000aa	48 8b cf	 mov	 rcx, rdi
  000ad	48 83 c2 78	 add	 rdx, 120		; 00000078H
  000b1	e8 00 00 00 00	 call	 ast_for_suite
  000b6	48 8b e8	 mov	 rbp, rax

; 3155 :         if (!seq1)

  000b9	48 85 c0	 test	 rax, rax

; 3156 :             return NULL;

  000bc	0f 84 c5 02 00
	00		 je	 $LN38@ast_for_if@2

; 3157 :         seq2 = ast_for_suite(c, CHILD(n, 6));

  000c2	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  000c6	48 8b cf	 mov	 rcx, rdi
  000c9	48 81 c2 f0 00
	00 00		 add	 rdx, 240		; 000000f0H
  000d0	e8 00 00 00 00	 call	 ast_for_suite
  000d5	4c 8b c0	 mov	 r8, rax

; 3158 :         if (!seq2)

  000d8	48 85 c0	 test	 rax, rax

; 3159 :             return NULL;

  000db	0f 84 a6 02 00
	00		 je	 $LN38@ast_for_if@2

; 3160 : 
; 3161 :         return If(expression, seq1, seq2, LINENO(n), n->n_col_offset,
; 3162 :                   c->c_arena);

  000e1	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  000e5	44 8b 4b 10	 mov	 r9d, DWORD PTR [rbx+16]
  000e9	48 8b d5	 mov	 rdx, rbp
  000ec	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f1	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  000f4	48 8b ce	 mov	 rcx, rsi
  000f7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000fb	e8 00 00 00 00	 call	 _Py_If
  00100	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]

; 3235 : }

  00105	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00109	5f		 pop	 rdi
  0010a	5e		 pop	 rsi
  0010b	5b		 pop	 rbx
  0010c	c3		 ret	 0
$LN20@ast_for_if@2:

; 3163 :     }
; 3164 :     else if (s[2] == 'i') {

  0010d	80 f9 69	 cmp	 cl, 105			; 00000069H
  00110	0f 85 5e 02 00
	00		 jne	 $LN15@ast_for_if@2

; 3165 :         int i, n_elif, has_else = 0;
; 3166 :         expr_ty expression;
; 3167 :         asdl_seq *suite_seq;
; 3168 :         asdl_seq *orelse = NULL;
; 3169 :         n_elif = NCH(n) - 4;

  00116	83 c2 fc	 add	 edx, -4
  00119	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  0011e	45 33 ff	 xor	 r15d, r15d

; 3170 :         /* must reference the child n_elif+1 since 'else' token is third,
; 3171 :            not fourth, child from the end. */
; 3172 :         if (TYPE(CHILD(n, (n_elif + 1))) == NAME
; 3173 :             && STR(CHILD(n, (n_elif + 1)))[2] == 's') {

  00121	48 63 ca	 movsxd	 rcx, edx
  00124	4c 89 7c 24 68	 mov	 QWORD PTR $T26589[rsp], r15
  00129	45 8b c7	 mov	 r8d, r15d
  0012c	48 8d 4c 89 05	 lea	 rcx, QWORD PTR [rcx+rcx*4+5]
  00131	66 83 3c c8 01	 cmp	 WORD PTR [rax+rcx*8], 1
  00136	75 12		 jne	 SHORT $LN14@ast_for_if@2
  00138	48 8b 4c c8 08	 mov	 rcx, QWORD PTR [rax+rcx*8+8]
  0013d	80 79 02 73	 cmp	 BYTE PTR [rcx+2], 115	; 00000073H
  00141	75 07		 jne	 SHORT $LN14@ast_for_if@2

; 3174 :             has_else = 1;

  00143	45 8d 47 01	 lea	 r8d, QWORD PTR [r15+1]

; 3175 :             n_elif -= 3;

  00147	83 ea 03	 sub	 edx, 3
$LN14@ast_for_if@2:

; 3176 :         }
; 3177 :         n_elif /= 4;

  0014a	8b c2		 mov	 eax, edx
  0014c	4c 89 64 24 70	 mov	 QWORD PTR [rsp+112], r12
  00151	99		 cdq
  00152	83 e2 03	 and	 edx, 3
  00155	8d 2c 02	 lea	 ebp, DWORD PTR [rdx+rax]
  00158	c1 fd 02	 sar	 ebp, 2

; 3178 : 
; 3179 :         if (has_else) {

  0015b	45 85 c0	 test	 r8d, r8d
  0015e	0f 84 bc 00 00
	00		 je	 $LN13@ast_for_if@2

; 3180 :             asdl_seq *suite_seq2;
; 3181 : 
; 3182 :             orelse = asdl_seq_new(1, c->c_arena);

  00164	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  00168	b9 01 00 00 00	 mov	 ecx, 1
  0016d	e8 00 00 00 00	 call	 asdl_seq_new
  00172	4c 8b f8	 mov	 r15, rax

; 3183 :             if (!orelse)

  00175	48 85 c0	 test	 rax, rax

; 3184 :                 return NULL;

  00178	74 6b		 je	 SHORT $LN37@ast_for_if@2

; 3185 :             expression = ast_for_expr(c, CHILD(n, NCH(n) - 6));

  0017a	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  0017d	83 e8 06	 sub	 eax, 6
  00180	48 98		 cdqe
  00182	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00186	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0018a	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  0018e	48 8b cf	 mov	 rcx, rdi
  00191	e8 00 00 00 00	 call	 ast_for_expr
  00196	4c 8b e0	 mov	 r12, rax

; 3186 :             if (!expression)

  00199	48 85 c0	 test	 rax, rax

; 3187 :                 return NULL;

  0019c	74 47		 je	 SHORT $LN37@ast_for_if@2

; 3188 :             suite_seq = ast_for_suite(c, CHILD(n, NCH(n) - 4));

  0019e	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  001a1	83 e8 04	 sub	 eax, 4
  001a4	48 98		 cdqe
  001a6	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  001aa	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001ae	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  001b2	48 8b cf	 mov	 rcx, rdi
  001b5	e8 00 00 00 00	 call	 ast_for_suite
  001ba	48 8b f0	 mov	 rsi, rax

; 3189 :             if (!suite_seq)

  001bd	48 85 c0	 test	 rax, rax

; 3190 :                 return NULL;

  001c0	74 23		 je	 SHORT $LN37@ast_for_if@2

; 3191 :             suite_seq2 = ast_for_suite(c, CHILD(n, NCH(n) - 1));

  001c2	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  001c5	ff c8		 dec	 eax
  001c7	48 98		 cdqe
  001c9	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  001cd	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001d1	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  001d5	48 8b cf	 mov	 rcx, rdi
  001d8	e8 00 00 00 00	 call	 ast_for_suite
  001dd	4c 8b c0	 mov	 r8, rax

; 3192 :             if (!suite_seq2)

  001e0	48 85 c0	 test	 rax, rax
  001e3	75 07		 jne	 SHORT $LN9@ast_for_if@2
$LN37@ast_for_if@2:

; 3193 :                 return NULL;

  001e5	33 c0		 xor	 eax, eax
  001e7	e9 50 01 00 00	 jmp	 $LN33@ast_for_if@2
$LN9@ast_for_if@2:

; 3194 : 
; 3195 :             asdl_seq_SET(orelse, 0,
; 3196 :                          If(expression, suite_seq, suite_seq2,
; 3197 :                             LINENO(CHILD(n, NCH(n) - 6)),
; 3198 :                             CHILD(n, NCH(n) - 6)->n_col_offset,
; 3199 :                             c->c_arena));

  001ec	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  001f0	48 63 43 18	 movsxd	 rax, DWORD PTR [rbx+24]
  001f4	48 8d 54 80 e2	 lea	 rdx, QWORD PTR [rax+rax*4-30]
  001f9	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  001fd	44 8b 4c d1 10	 mov	 r9d, DWORD PTR [rcx+rdx*8+16]
  00202	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00207	8b 44 d1 14	 mov	 eax, DWORD PTR [rcx+rdx*8+20]
  0020b	48 8b d6	 mov	 rdx, rsi
  0020e	49 8b cc	 mov	 rcx, r12
  00211	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00215	e8 00 00 00 00	 call	 _Py_If

; 3200 :             /* the just-created orelse handled the last elif */
; 3201 :             n_elif--;

  0021a	ff cd		 dec	 ebp
  0021c	49 89 47 08	 mov	 QWORD PTR [r15+8], rax
$LN13@ast_for_if@2:
  00220	4c 89 6c 24 78	 mov	 QWORD PTR [rsp+120], r13
  00225	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  0022a	4c 63 f5	 movsxd	 r14, ebp

; 3202 :         }
; 3203 : 
; 3204 :         for (i = 0; i < n_elif; i++) {

  0022d	85 ed		 test	 ebp, ebp
  0022f	0f 8e cb 00 00
	00		 jle	 $LN6@ast_for_if@2
  00235	4f 8d 2c b6	 lea	 r13, QWORD PTR [r14+r14*4]
  00239	8d 2c ad 01 00
	00 00		 lea	 ebp, DWORD PTR [rbp*4+1]
  00240	49 c1 e5 05	 shl	 r13, 5
  00244	49 83 c5 28	 add	 r13, 40			; 00000028H
  00248	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL8@ast_for_if@2:

; 3205 :             int off = 5 + (n_elif - i - 1) * 4;
; 3206 :             asdl_seq *newobj = asdl_seq_new(1, c->c_arena);

  00250	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  00254	b9 01 00 00 00	 mov	 ecx, 1
  00259	e8 00 00 00 00	 call	 asdl_seq_new
  0025e	48 8b f0	 mov	 rsi, rax

; 3207 :             if (!newobj)

  00261	48 85 c0	 test	 rax, rax
  00264	0f 84 c6 00 00
	00		 je	 $LN36@ast_for_if@2

; 3208 :                 return NULL;
; 3209 :             expression = ast_for_expr(c, CHILD(n, off));

  0026a	48 63 cd	 movsxd	 rcx, ebp
  0026d	48 8d 14 89	 lea	 rdx, QWORD PTR [rcx+rcx*4]
  00271	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00275	48 8d 14 d1	 lea	 rdx, QWORD PTR [rcx+rdx*8]
  00279	48 8b cf	 mov	 rcx, rdi
  0027c	e8 00 00 00 00	 call	 ast_for_expr
  00281	4c 8b e0	 mov	 r12, rax

; 3210 :             if (!expression)

  00284	48 85 c0	 test	 rax, rax
  00287	0f 84 a3 00 00
	00		 je	 $LN36@ast_for_if@2

; 3211 :                 return NULL;
; 3212 :             suite_seq = ast_for_suite(c, CHILD(n, off + 2));

  0028d	8d 4d 02	 lea	 ecx, DWORD PTR [rbp+2]
  00290	48 63 d1	 movsxd	 rdx, ecx
  00293	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00297	4c 8d 04 92	 lea	 r8, QWORD PTR [rdx+rdx*4]
  0029b	4a 8d 14 c1	 lea	 rdx, QWORD PTR [rcx+r8*8]
  0029f	48 8b cf	 mov	 rcx, rdi
  002a2	e8 00 00 00 00	 call	 ast_for_suite

; 3213 :             if (!suite_seq)

  002a7	48 85 c0	 test	 rax, rax
  002aa	0f 84 80 00 00
	00		 je	 $LN36@ast_for_if@2

; 3214 :                 return NULL;
; 3215 : 
; 3216 :             asdl_seq_SET(newobj, 0,
; 3217 :                          If(expression, suite_seq, orelse,
; 3218 :                             LINENO(CHILD(n, off)),
; 3219 :                             CHILD(n, off)->n_col_offset, c->c_arena));

  002b0	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  002b4	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  002b8	4d 8b c7	 mov	 r8, r15
  002bb	45 8b 4c 15 10	 mov	 r9d, DWORD PTR [r13+rdx+16]
  002c0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c5	41 8b 4c 15 14	 mov	 ecx, DWORD PTR [r13+rdx+20]
  002ca	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  002ce	48 8b d0	 mov	 rdx, rax
  002d1	49 8b cc	 mov	 rcx, r12
  002d4	e8 00 00 00 00	 call	 _Py_If
  002d9	4c 8b 64 24 68	 mov	 r12, QWORD PTR $T26589[rsp]
  002de	83 ed 04	 sub	 ebp, 4
  002e1	49 ff c4	 inc	 r12
  002e4	49 81 ed a0 00
	00 00		 sub	 r13, 160		; 000000a0H

; 3220 :             orelse = newobj;

  002eb	4c 8b fe	 mov	 r15, rsi
  002ee	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax
  002f2	4c 89 64 24 68	 mov	 QWORD PTR $T26589[rsp], r12
  002f7	4d 3b e6	 cmp	 r12, r14
  002fa	0f 8c 50 ff ff
	ff		 jl	 $LL8@ast_for_if@2
$LN6@ast_for_if@2:

; 3221 :         }
; 3222 :         expression = ast_for_expr(c, CHILD(n, 1));

  00300	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00304	48 8b cf	 mov	 rcx, rdi
  00307	48 83 c2 28	 add	 rdx, 40			; 00000028H
  0030b	e8 00 00 00 00	 call	 ast_for_expr
  00310	48 8b f0	 mov	 rsi, rax

; 3223 :         if (!expression)

  00313	48 85 c0	 test	 rax, rax

; 3224 :             return NULL;

  00316	74 18		 je	 SHORT $LN36@ast_for_if@2

; 3225 :         suite_seq = ast_for_suite(c, CHILD(n, 3));

  00318	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  0031c	48 8b cf	 mov	 rcx, rdi
  0031f	48 83 c2 78	 add	 rdx, 120		; 00000078H
  00323	e8 00 00 00 00	 call	 ast_for_suite
  00328	48 8b d0	 mov	 rdx, rax

; 3226 :         if (!suite_seq)

  0032b	48 85 c0	 test	 rax, rax
  0032e	75 23		 jne	 SHORT $LN1@ast_for_if@2
$LN36@ast_for_if@2:

; 3227 :             return NULL;

  00330	33 c0		 xor	 eax, eax
$LN35@ast_for_if@2:
  00332	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]
  00337	4c 8b 6c 24 78	 mov	 r13, QWORD PTR [rsp+120]
$LN33@ast_for_if@2:
  0033c	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]
  00341	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]
  00346	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]

; 3235 : }

  0034b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0034f	5f		 pop	 rdi
  00350	5e		 pop	 rsi
  00351	5b		 pop	 rbx
  00352	c3		 ret	 0
$LN1@ast_for_if@2:

; 3228 :         return If(expression, suite_seq, orelse,
; 3229 :                   LINENO(n), n->n_col_offset, c->c_arena);

  00353	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00357	44 8b 4b 10	 mov	 r9d, DWORD PTR [rbx+16]
  0035b	4d 8b c7	 mov	 r8, r15
  0035e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00363	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  00366	48 8b ce	 mov	 rcx, rsi
  00369	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0036d	e8 00 00 00 00	 call	 _Py_If
  00372	eb be		 jmp	 SHORT $LN35@ast_for_if@2
$LN15@ast_for_if@2:

; 3230 :     }
; 3231 : 
; 3232 :     PyErr_Format(PyExc_SystemError,
; 3233 :                  "unexpected token in 'if' statement: %s", s);

  00374	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0037b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@DBODNALO@unexpected?5token?5in?5?8if?8?5stateme@
  00382	e8 00 00 00 00	 call	 PyErr_Format
$LN38@ast_for_if@2:

; 3234 :     return NULL;

  00387	33 c0		 xor	 eax, eax
  00389	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]

; 3235 : }

  0038e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00392	5f		 pop	 rdi
  00393	5e		 pop	 rsi
  00394	5b		 pop	 rbx
  00395	c3		 ret	 0
ast_for_if_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@BBLJCPPH@wrong?5number?5of?5tokens?5for?5?8whil@ ; `string'
EXTRN	_Py_While:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_while_stmt DD imagerel ast_for_while_stmt
	DD	imagerel ast_for_while_stmt+173
	DD	imagerel $unwind$ast_for_while_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ast_for_while_stmt DD imagerel ast_for_while_stmt+173
	DD	imagerel ast_for_while_stmt+245
	DD	imagerel $chain$0$ast_for_while_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ast_for_while_stmt DD imagerel ast_for_while_stmt+245
	DD	imagerel ast_for_while_stmt+278
	DD	imagerel $chain$2$ast_for_while_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ast_for_while_stmt DD imagerel ast_for_while_stmt+278
	DD	imagerel ast_for_while_stmt+315
	DD	imagerel $chain$3$ast_for_while_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ast_for_while_stmt DD 021H
	DD	imagerel ast_for_while_stmt
	DD	imagerel ast_for_while_stmt+173
	DD	imagerel $unwind$ast_for_while_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ast_for_while_stmt DD 020021H
	DD	085400H
	DD	imagerel ast_for_while_stmt
	DD	imagerel ast_for_while_stmt+173
	DD	imagerel $unwind$ast_for_while_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ast_for_while_stmt DD 020521H
	DD	085405H
	DD	imagerel ast_for_while_stmt
	DD	imagerel ast_for_while_stmt+173
	DD	imagerel $unwind$ast_for_while_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_while_stmt DD 060f01H
	DD	0a640fH
	DD	09340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0DB@BBLJCPPH@wrong?5number?5of?5tokens?5for?5?8whil@
CONST	SEGMENT
??_C@_0DB@BBLJCPPH@wrong?5number?5of?5tokens?5for?5?8whil@ DB 'wrong numb'
	DB	'er of tokens for ''while'' statement: %d', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ast_for_while_stmt
_TEXT	SEGMENT
c$ = 64
n$ = 72
ast_for_while_stmt PROC					; COMDAT

; 3239 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3240 :     /* while_stmt: 'while' test ':' suite ['else' ':' suite] */
; 3241 :     REQ(n, while_stmt);
; 3242 : 
; 3243 :     if (NCH(n) == 4) {

  0000f	44 8b 42 18	 mov	 r8d, DWORD PTR [rdx+24]
  00013	48 8b da	 mov	 rbx, rdx
  00016	48 8b f9	 mov	 rdi, rcx
  00019	41 83 f8 04	 cmp	 r8d, 4
  0001d	75 64		 jne	 SHORT $LN8@ast_for_wh

; 3244 :         expr_ty expression;
; 3245 :         asdl_seq *suite_seq;
; 3246 : 
; 3247 :         expression = ast_for_expr(c, CHILD(n, 1));

  0001f	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00023	48 83 c2 28	 add	 rdx, 40			; 00000028H
  00027	e8 00 00 00 00	 call	 ast_for_expr
  0002c	48 8b f0	 mov	 rsi, rax

; 3248 :         if (!expression)

  0002f	48 85 c0	 test	 rax, rax

; 3249 :             return NULL;

  00032	0f 84 f1 00 00
	00		 je	 $LN13@ast_for_wh

; 3250 :         suite_seq = ast_for_suite(c, CHILD(n, 3));

  00038	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  0003c	48 8b cf	 mov	 rcx, rdi
  0003f	48 83 c2 78	 add	 rdx, 120		; 00000078H
  00043	e8 00 00 00 00	 call	 ast_for_suite
  00048	48 8b d0	 mov	 rdx, rax

; 3251 :         if (!suite_seq)

  0004b	48 85 c0	 test	 rax, rax

; 3252 :             return NULL;

  0004e	0f 84 d5 00 00
	00		 je	 $LN13@ast_for_wh

; 3253 :         return While(expression, suite_seq, NULL, LINENO(n), n->n_col_offset, c->c_arena);

  00054	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00058	44 8b 4b 10	 mov	 r9d, DWORD PTR [rbx+16]
  0005c	45 33 c0	 xor	 r8d, r8d
  0005f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00064	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  00067	48 8b ce	 mov	 rcx, rsi
  0006a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0006e	e8 00 00 00 00	 call	 _Py_While

; 3275 :     return NULL;
; 3276 : }

  00073	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00078	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0007d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00081	5f		 pop	 rdi
  00082	c3		 ret	 0
$LN8@ast_for_wh:

; 3254 :     }
; 3255 :     else if (NCH(n) == 7) {

  00083	41 83 f8 07	 cmp	 r8d, 7
  00087	0f 85 89 00 00
	00		 jne	 $LN4@ast_for_wh

; 3256 :         expr_ty expression;
; 3257 :         asdl_seq *seq1, *seq2;
; 3258 : 
; 3259 :         expression = ast_for_expr(c, CHILD(n, 1));

  0008d	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00091	48 83 c2 28	 add	 rdx, 40			; 00000028H
  00095	e8 00 00 00 00	 call	 ast_for_expr
  0009a	48 8b f0	 mov	 rsi, rax

; 3260 :         if (!expression)

  0009d	48 85 c0	 test	 rax, rax

; 3261 :             return NULL;

  000a0	0f 84 83 00 00
	00		 je	 $LN13@ast_for_wh

; 3262 :         seq1 = ast_for_suite(c, CHILD(n, 3));

  000a6	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  000aa	48 8b cf	 mov	 rcx, rdi
  000ad	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  000b2	48 83 c2 78	 add	 rdx, 120		; 00000078H
  000b6	e8 00 00 00 00	 call	 ast_for_suite
  000bb	48 8b e8	 mov	 rbp, rax

; 3263 :         if (!seq1)

  000be	48 85 c0	 test	 rax, rax

; 3264 :             return NULL;

  000c1	74 1b		 je	 SHORT $LN12@ast_for_wh

; 3265 :         seq2 = ast_for_suite(c, CHILD(n, 6));

  000c3	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  000c7	48 8b cf	 mov	 rcx, rdi
  000ca	48 81 c2 f0 00
	00 00		 add	 rdx, 240		; 000000f0H
  000d1	e8 00 00 00 00	 call	 ast_for_suite
  000d6	4c 8b c0	 mov	 r8, rax

; 3266 :         if (!seq2)

  000d9	48 85 c0	 test	 rax, rax
  000dc	75 17		 jne	 SHORT $LN1@ast_for_wh
$LN12@ast_for_wh:

; 3267 :             return NULL;

  000de	33 c0		 xor	 eax, eax
$LN11@ast_for_wh:
  000e0	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 3275 :     return NULL;
; 3276 : }

  000e5	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000ea	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000ef	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f3	5f		 pop	 rdi
  000f4	c3		 ret	 0
$LN1@ast_for_wh:

; 3268 : 
; 3269 :         return While(expression, seq1, seq2, LINENO(n), n->n_col_offset, c->c_arena);

  000f5	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  000f9	44 8b 4b 10	 mov	 r9d, DWORD PTR [rbx+16]
  000fd	48 8b d5	 mov	 rdx, rbp
  00100	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00105	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  00108	48 8b ce	 mov	 rcx, rsi
  0010b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0010f	e8 00 00 00 00	 call	 _Py_While
  00114	eb ca		 jmp	 SHORT $LN11@ast_for_wh
$LN4@ast_for_wh:

; 3270 :     }
; 3271 : 
; 3272 :     PyErr_Format(PyExc_SystemError,
; 3273 :                  "wrong number of tokens for 'while' statement: %d",
; 3274 :                  NCH(n));

  00116	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0011d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@BBLJCPPH@wrong?5number?5of?5tokens?5for?5?8whil@
  00124	e8 00 00 00 00	 call	 PyErr_Format
$LN13@ast_for_wh:

; 3275 :     return NULL;
; 3276 : }

  00129	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0012e	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00133	33 c0		 xor	 eax, eax
  00135	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00139	5f		 pop	 rdi
  0013a	c3		 ret	 0
ast_for_while_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@ODIINJEH@wrong?5number?5of?5children?5for?5?8ex@ ; `string'
EXTRN	_Py_ExceptHandler:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_except_clause DD imagerel ast_for_except_clause
	DD	imagerel ast_for_except_clause+111
	DD	imagerel $unwind$ast_for_except_clause
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ast_for_except_clause DD imagerel ast_for_except_clause+111
	DD	imagerel ast_for_except_clause+280
	DD	imagerel $chain$0$ast_for_except_clause
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ast_for_except_clause DD imagerel ast_for_except_clause+280
	DD	imagerel ast_for_except_clause+328
	DD	imagerel $chain$1$ast_for_except_clause
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ast_for_except_clause DD imagerel ast_for_except_clause+328
	DD	imagerel ast_for_except_clause+349
	DD	imagerel $chain$2$ast_for_except_clause
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ast_for_except_clause DD imagerel ast_for_except_clause+349
	DD	imagerel ast_for_except_clause+382
	DD	imagerel $chain$4$ast_for_except_clause
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$ast_for_except_clause DD imagerel ast_for_except_clause+382
	DD	imagerel ast_for_except_clause+405
	DD	imagerel $chain$5$ast_for_except_clause
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$ast_for_except_clause DD 020021H
	DD	085400H
	DD	imagerel ast_for_except_clause
	DD	imagerel ast_for_except_clause+111
	DD	imagerel $unwind$ast_for_except_clause
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ast_for_except_clause DD 040021H
	DD	09c400H
	DD	085400H
	DD	imagerel ast_for_except_clause
	DD	imagerel ast_for_except_clause+111
	DD	imagerel $unwind$ast_for_except_clause
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ast_for_except_clause DD 021H
	DD	imagerel ast_for_except_clause+111
	DD	imagerel ast_for_except_clause+280
	DD	imagerel $chain$0$ast_for_except_clause
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ast_for_except_clause DD 020521H
	DD	09c405H
	DD	imagerel ast_for_except_clause+111
	DD	imagerel ast_for_except_clause+280
	DD	imagerel $chain$0$ast_for_except_clause
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ast_for_except_clause DD 020521H
	DD	085405H
	DD	imagerel ast_for_except_clause
	DD	imagerel ast_for_except_clause+111
	DD	imagerel $unwind$ast_for_except_clause
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_except_clause DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0DB@ODIINJEH@wrong?5number?5of?5children?5for?5?8ex@
CONST	SEGMENT
??_C@_0DB@ODIINJEH@wrong?5number?5of?5children?5for?5?8ex@ DB 'wrong numb'
	DB	'er of children for ''except'' clause: %d', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ast_for_except_clause
_TEXT	SEGMENT
c$ = 64
exc$ = 72
body$ = 80
ast_for_except_clause PROC				; COMDAT

; 3319 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	49 8b f0	 mov	 rsi, r8

; 3320 :     /* except_clause: 'except' [test ['as' test]] */
; 3321 :     REQ(exc, except_clause);
; 3322 :     REQ(body, suite);
; 3323 : 
; 3324 :     if (NCH(exc) == 1) {

  00012	44 8b 42 18	 mov	 r8d, DWORD PTR [rdx+24]
  00016	48 8b fa	 mov	 rdi, rdx
  00019	48 8b d9	 mov	 rbx, rcx
  0001c	41 83 f8 01	 cmp	 r8d, 1
  00020	75 4d		 jne	 SHORT $LN12@ast_for_ex@4

; 3325 :         asdl_seq *suite_seq = ast_for_suite(c, body);

  00022	48 8b d6	 mov	 rdx, rsi
  00025	e8 00 00 00 00	 call	 ast_for_suite
  0002a	4c 8b c0	 mov	 r8, rax

; 3326 :         if (!suite_seq)

  0002d	48 85 c0	 test	 rax, rax
  00030	75 10		 jne	 SHORT $LN11@ast_for_ex@4

; 3369 : }

  00032	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00037	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0003c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
$LN11@ast_for_ex@4:

; 3327 :             return NULL;
; 3328 : 
; 3329 :         return ExceptHandler(NULL, NULL, suite_seq, LINENO(exc),
; 3330 :                              exc->n_col_offset, c->c_arena);

  00042	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00046	44 8b 4f 10	 mov	 r9d, DWORD PTR [rdi+16]
  0004a	33 d2		 xor	 edx, edx
  0004c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00051	8b 47 14	 mov	 eax, DWORD PTR [rdi+20]
  00054	33 c9		 xor	 ecx, ecx
  00056	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0005a	e8 00 00 00 00	 call	 _Py_ExceptHandler

; 3369 : }

  0005f	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00064	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00069	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
$LN12@ast_for_ex@4:
  0006f	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp

; 3331 :     }
; 3332 :     else if (NCH(exc) == 2) {

  00074	41 83 f8 02	 cmp	 r8d, 2
  00078	75 50		 jne	 SHORT $LN9@ast_for_ex@4

; 3333 :         expr_ty expression;
; 3334 :         asdl_seq *suite_seq;
; 3335 : 
; 3336 :         expression = ast_for_expr(c, CHILD(exc, 1));

  0007a	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  0007e	48 83 c2 28	 add	 rdx, 40			; 00000028H
  00082	e8 00 00 00 00	 call	 ast_for_expr
  00087	48 8b e8	 mov	 rbp, rax

; 3337 :         if (!expression)

  0008a	48 85 c0	 test	 rax, rax

; 3338 :             return NULL;

  0008d	0f 84 fe 00 00
	00		 je	 $LN18@ast_for_ex@4

; 3339 :         suite_seq = ast_for_suite(c, body);

  00093	48 8b d6	 mov	 rdx, rsi
  00096	48 8b cb	 mov	 rcx, rbx
  00099	e8 00 00 00 00	 call	 ast_for_suite
  0009e	4c 8b c0	 mov	 r8, rax

; 3340 :         if (!suite_seq)

  000a1	48 85 c0	 test	 rax, rax

; 3341 :             return NULL;

  000a4	0f 84 e7 00 00
	00		 je	 $LN18@ast_for_ex@4

; 3342 : 
; 3343 :         return ExceptHandler(expression, NULL, suite_seq, LINENO(exc),
; 3344 :                              exc->n_col_offset, c->c_arena);

  000aa	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000ae	44 8b 4f 10	 mov	 r9d, DWORD PTR [rdi+16]
  000b2	33 d2		 xor	 edx, edx
  000b4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b9	8b 47 14	 mov	 eax, DWORD PTR [rdi+20]
  000bc	48 8b cd	 mov	 rcx, rbp
  000bf	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000c3	e8 00 00 00 00	 call	 _Py_ExceptHandler
  000c8	eb 7e		 jmp	 SHORT $LN15@ast_for_ex@4
$LN9@ast_for_ex@4:

; 3345 :     }
; 3346 :     else if (NCH(exc) == 4) {

  000ca	41 83 f8 04	 cmp	 r8d, 4
  000ce	0f 85 aa 00 00
	00		 jne	 $LN5@ast_for_ex@4

; 3347 :         asdl_seq *suite_seq;
; 3348 :         expr_ty expression;
; 3349 :         identifier e = NEW_IDENTIFIER(CHILD(exc, 3));

  000d4	48 8b 4a 20	 mov	 rcx, QWORD PTR [rdx+32]
  000d8	48 8b d3	 mov	 rdx, rbx
  000db	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  000e2	e8 00 00 00 00	 call	 new_identifier
  000e7	48 8b e8	 mov	 rbp, rax

; 3350 :         if (!e)

  000ea	48 85 c0	 test	 rax, rax

; 3351 :             return NULL;

  000ed	0f 84 9e 00 00
	00		 je	 $LN18@ast_for_ex@4

; 3352 :         if (forbidden_name(c, e, CHILD(exc, 3), 0))

  000f3	4c 8b 47 20	 mov	 r8, QWORD PTR [rdi+32]
  000f7	45 33 c9	 xor	 r9d, r9d
  000fa	48 8b d0	 mov	 rdx, rax
  000fd	49 83 c0 78	 add	 r8, 120			; 00000078H
  00101	48 8b cb	 mov	 rcx, rbx
  00104	e8 00 00 00 00	 call	 forbidden_name
  00109	85 c0		 test	 eax, eax

; 3353 :             return NULL;

  0010b	0f 85 80 00 00
	00		 jne	 $LN18@ast_for_ex@4

; 3354 :         expression = ast_for_expr(c, CHILD(exc, 1));

  00111	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  00115	48 8b cb	 mov	 rcx, rbx
  00118	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  0011d	48 83 c2 28	 add	 rdx, 40			; 00000028H
  00121	e8 00 00 00 00	 call	 ast_for_expr
  00126	4c 8b e0	 mov	 r12, rax

; 3355 :         if (!expression)

  00129	48 85 c0	 test	 rax, rax

; 3356 :             return NULL;

  0012c	74 13		 je	 SHORT $LN17@ast_for_ex@4

; 3357 :         suite_seq = ast_for_suite(c, body);

  0012e	48 8b d6	 mov	 rdx, rsi
  00131	48 8b cb	 mov	 rcx, rbx
  00134	e8 00 00 00 00	 call	 ast_for_suite
  00139	4c 8b c0	 mov	 r8, rax

; 3358 :         if (!suite_seq)

  0013c	48 85 c0	 test	 rax, rax
  0013f	75 1c		 jne	 SHORT $LN1@ast_for_ex@4
$LN17@ast_for_ex@4:

; 3359 :             return NULL;

  00141	33 c0		 xor	 eax, eax
$LN16@ast_for_ex@4:
  00143	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
$LN15@ast_for_ex@4:
  00148	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 3369 : }

  0014d	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00152	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00157	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0015b	5f		 pop	 rdi
  0015c	c3		 ret	 0
$LN1@ast_for_ex@4:

; 3360 : 
; 3361 :         return ExceptHandler(expression, e, suite_seq, LINENO(exc),
; 3362 :                              exc->n_col_offset, c->c_arena);

  0015d	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00161	44 8b 4f 10	 mov	 r9d, DWORD PTR [rdi+16]
  00165	48 8b d5	 mov	 rdx, rbp
  00168	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0016d	8b 47 14	 mov	 eax, DWORD PTR [rdi+20]
  00170	49 8b cc	 mov	 rcx, r12
  00173	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00177	e8 00 00 00 00	 call	 _Py_ExceptHandler
  0017c	eb c5		 jmp	 SHORT $LN16@ast_for_ex@4
$LN5@ast_for_ex@4:

; 3363 :     }
; 3364 : 
; 3365 :     PyErr_Format(PyExc_SystemError,
; 3366 :                  "wrong number of children for 'except' clause: %d",
; 3367 :                  NCH(exc));

  0017e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00185	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@ODIINJEH@wrong?5number?5of?5children?5for?5?8ex@
  0018c	e8 00 00 00 00	 call	 PyErr_Format
$LN18@ast_for_ex@4:

; 3368 :     return NULL;

  00191	33 c0		 xor	 eax, eax
  00193	eb b3		 jmp	 SHORT $LN15@ast_for_ex@4
ast_for_except_clause ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@MKJMBJFL@malformed?5?8try?8?5statement?$AA@ ; `string'
PUBLIC	??_C@_07MKBLAIAL@finally?$AA@			; `string'
EXTRN	_Py_Try:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_try_stmt DD imagerel ast_for_try_stmt
	DD	imagerel ast_for_try_stmt+112
	DD	imagerel $unwind$ast_for_try_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ast_for_try_stmt DD imagerel ast_for_try_stmt+112
	DD	imagerel ast_for_try_stmt+518
	DD	imagerel $chain$1$ast_for_try_stmt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ast_for_try_stmt DD imagerel ast_for_try_stmt+518
	DD	imagerel ast_for_try_stmt+554
	DD	imagerel $chain$3$ast_for_try_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ast_for_try_stmt DD 040021H
	DD	087400H
	DD	0106400H
	DD	imagerel ast_for_try_stmt
	DD	imagerel ast_for_try_stmt+112
	DD	imagerel $unwind$ast_for_try_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ast_for_try_stmt DD 041621H
	DD	087416H
	DD	0106408H
	DD	imagerel ast_for_try_stmt
	DD	imagerel ast_for_try_stmt+112
	DD	imagerel $unwind$ast_for_try_stmt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_try_stmt DD 070f01H
	DD	0f00b820fH
	DD	0d007e009H
	DD	05003c005H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_0BK@MKJMBJFL@malformed?5?8try?8?5statement?$AA@
CONST	SEGMENT
??_C@_0BK@MKJMBJFL@malformed?5?8try?8?5statement?$AA@ DB 'malformed ''try'
	DB	''' statement', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07MKBLAIAL@finally?$AA@
CONST	SEGMENT
??_C@_07MKBLAIAL@finally?$AA@ DB 'finally', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ast_for_try_stmt
_TEXT	SEGMENT
c$ = 128
orelse$1$ = 136
n$ = 136
finally$1$ = 144
body$1$ = 152
ast_for_try_stmt PROC					; COMDAT

; 3373 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	41 57		 push	 r15
  0000b	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3374 :     const int nch = NCH(n);

  0000f	4c 63 6a 18	 movsxd	 r13, DWORD PTR [rdx+24]
  00013	4c 8b f2	 mov	 r14, rdx
  00016	4c 8b e1	 mov	 r12, rcx

; 3375 :     int n_except = (nch - 3)/3;
; 3376 :     asdl_seq *body, *handlers = NULL, *orelse = NULL, *finally = NULL;

  00019	33 db		 xor	 ebx, ebx
  0001b	41 8d 4d fd	 lea	 ecx, DWORD PTR [r13-3]
  0001f	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00024	44 8b fb	 mov	 r15d, ebx
  00027	48 89 9c 24 88
	00 00 00	 mov	 QWORD PTR orelse$1$[rsp], rbx
  0002f	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR finally$1$[rsp], rbx
  00037	f7 e9		 imul	 ecx
  00039	8b ea		 mov	 ebp, edx

; 3377 : 
; 3378 :     REQ(n, try_stmt);
; 3379 : 
; 3380 :     body = ast_for_suite(c, CHILD(n, 2));

  0003b	49 8b cc	 mov	 rcx, r12
  0003e	c1 ed 1f	 shr	 ebp, 31
  00041	03 ea		 add	 ebp, edx
  00043	49 8b 56 20	 mov	 rdx, QWORD PTR [r14+32]
  00047	48 83 c2 50	 add	 rdx, 80			; 00000050H
  0004b	e8 00 00 00 00	 call	 ast_for_suite
  00050	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR body$1$[rsp], rax

; 3381 :     if (body == NULL)

  00058	48 85 c0	 test	 rax, rax
  0005b	75 0f		 jne	 SHORT $LN16@ast_for_tr@2

; 3433 : }

  0005d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00061	41 5f		 pop	 r15
  00063	41 5e		 pop	 r14
  00065	41 5d		 pop	 r13
  00067	41 5c		 pop	 r12
  00069	5d		 pop	 rbp
  0006a	5b		 pop	 rbx
  0006b	c3		 ret	 0
$LN16@ast_for_tr@2:

; 3382 :         return NULL;
; 3383 : 
; 3384 :     if (TYPE(CHILD(n, nch - 3)) == NAME) {

  0006c	49 8b 56 20	 mov	 rdx, QWORD PTR [r14+32]
  00070	48 89 b4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rsi
  00078	4b 8d 74 ad f1	 lea	 rsi, QWORD PTR [r13+r13*4-15]
  0007d	0f b7 0c f2	 movzx	 ecx, WORD PTR [rdx+rsi*8]
  00081	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00086	66 83 f9 01	 cmp	 cx, 1
  0008a	0f 85 76 01 00
	00		 jne	 $LN15@ast_for_tr@2

; 3385 :         if (strcmp(STR(CHILD(n, nch - 3)), "finally") == 0) {

  00090	48 8b 74 f2 08	 mov	 rsi, QWORD PTR [rdx+rsi*8+8]
  00095	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_07MKBLAIAL@finally?$AA@
  0009c	b9 08 00 00 00	 mov	 ecx, 8
  000a1	f3 a6		 repe cmpsb
  000a3	75 69		 jne	 SHORT $LN14@ast_for_tr@2

; 3386 :             if (nch >= 9 && TYPE(CHILD(n, nch - 6)) == NAME) {

  000a5	41 83 fd 09	 cmp	 r13d, 9
  000a9	7c 36		 jl	 SHORT $LN13@ast_for_tr@2
  000ab	4b 8d 44 ad e2	 lea	 rax, QWORD PTR [r13+r13*4-30]
  000b0	66 83 3c c2 01	 cmp	 WORD PTR [rdx+rax*8], 1
  000b5	75 2a		 jne	 SHORT $LN13@ast_for_tr@2

; 3387 :                 /* we can assume it's an "else",
; 3388 :                    because nch >= 9 for try-else-finally and
; 3389 :                    it would otherwise have a type of except_clause */
; 3390 :                 orelse = ast_for_suite(c, CHILD(n, nch - 4));

  000b7	41 8d 45 fc	 lea	 eax, DWORD PTR [r13-4]
  000bb	48 63 c8	 movsxd	 rcx, eax
  000be	48 8d 04 89	 lea	 rax, QWORD PTR [rcx+rcx*4]
  000c2	49 8b cc	 mov	 rcx, r12
  000c5	48 8d 14 c2	 lea	 rdx, QWORD PTR [rdx+rax*8]
  000c9	e8 00 00 00 00	 call	 ast_for_suite
  000ce	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR orelse$1$[rsp], rax

; 3391 :                 if (orelse == NULL)

  000d6	48 85 c0	 test	 rax, rax

; 3392 :                     return NULL;

  000d9	0f 84 47 01 00
	00		 je	 $LN20@ast_for_tr@2

; 3393 :                 n_except--;

  000df	ff cd		 dec	 ebp
$LN13@ast_for_tr@2:

; 3394 :             }
; 3395 : 
; 3396 :             finally = ast_for_suite(c, CHILD(n, nch - 1));

  000e1	41 8d 45 ff	 lea	 eax, DWORD PTR [r13-1]
  000e5	48 63 c8	 movsxd	 rcx, eax
  000e8	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  000ec	48 8d 14 89	 lea	 rdx, QWORD PTR [rcx+rcx*4]
  000f0	49 8b cc	 mov	 rcx, r12
  000f3	48 8d 14 d0	 lea	 rdx, QWORD PTR [rax+rdx*8]
  000f7	e8 00 00 00 00	 call	 ast_for_suite
  000fc	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR finally$1$[rsp], rax

; 3397 :             if (finally == NULL)

  00104	48 85 c0	 test	 rax, rax
  00107	75 2d		 jne	 SHORT $LN9@ast_for_tr@2

; 3398 :                 return NULL;

  00109	e9 dc 00 00 00	 jmp	 $LN23@ast_for_tr@2
$LN14@ast_for_tr@2:

; 3399 :             n_except--;
; 3400 :         }
; 3401 :         else {
; 3402 :             /* we can assume it's an "else",
; 3403 :                otherwise it would have a type of except_clause */
; 3404 :             orelse = ast_for_suite(c, CHILD(n, nch - 1));

  0010e	41 8d 45 ff	 lea	 eax, DWORD PTR [r13-1]
  00112	48 63 c8	 movsxd	 rcx, eax
  00115	48 8d 04 89	 lea	 rax, QWORD PTR [rcx+rcx*4]
  00119	49 8b cc	 mov	 rcx, r12
  0011c	48 8d 14 c2	 lea	 rdx, QWORD PTR [rdx+rax*8]
  00120	e8 00 00 00 00	 call	 ast_for_suite
  00125	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR orelse$1$[rsp], rax

; 3405 :             if (orelse == NULL)

  0012d	48 85 c0	 test	 rax, rax

; 3406 :                 return NULL;

  00130	0f 84 f0 00 00
	00		 je	 $LN20@ast_for_tr@2
$LN9@ast_for_tr@2:

; 3407 :             n_except--;

  00136	ff cd		 dec	 ebp
$LN7@ast_for_tr@2:

; 3413 :     }
; 3414 : 
; 3415 :     if (n_except > 0) {

  00138	85 ed		 test	 ebp, ebp
  0013a	7e 74		 jle	 SHORT $LN2@ast_for_tr@2

; 3416 :         int i;
; 3417 :         /* process except statements to create a try ... except */
; 3418 :         handlers = asdl_seq_new(n_except, c->c_arena);

  0013c	49 8b 54 24 08	 mov	 rdx, QWORD PTR [r12+8]
  00141	48 63 ed	 movsxd	 rbp, ebp
  00144	48 8b cd	 mov	 rcx, rbp
  00147	e8 00 00 00 00	 call	 asdl_seq_new
  0014c	4c 8b f8	 mov	 r15, rax

; 3419 :         if (handlers == NULL)

  0014f	48 85 c0	 test	 rax, rax

; 3420 :             return NULL;

  00152	0f 84 ce 00 00
	00		 je	 $LN20@ast_for_tr@2

; 3421 : 
; 3422 :         for (i = 0; i < n_except; i++) {

  00158	48 85 ed	 test	 rbp, rbp
  0015b	7e 53		 jle	 SHORT $LN2@ast_for_tr@2
  0015d	be 03 00 00 00	 mov	 esi, 3
  00162	48 8d 78 08	 lea	 rdi, QWORD PTR [rax+8]
  00166	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@ast_for_tr@2:

; 3423 :             excepthandler_ty e = ast_for_except_clause(c, CHILD(n, 3 + i * 3),
; 3424 :                                                        CHILD(n, 5 + i * 3));

  00170	49 8b 56 20	 mov	 rdx, QWORD PTR [r14+32]
  00174	8d 46 02	 lea	 eax, DWORD PTR [rsi+2]
  00177	48 63 c8	 movsxd	 rcx, eax
  0017a	48 8d 04 89	 lea	 rax, QWORD PTR [rcx+rcx*4]
  0017e	4c 8d 04 c2	 lea	 r8, QWORD PTR [rdx+rax*8]
  00182	48 63 c6	 movsxd	 rax, esi
  00185	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00189	48 8d 14 ca	 lea	 rdx, QWORD PTR [rdx+rcx*8]
  0018d	49 8b cc	 mov	 rcx, r12
  00190	e8 00 00 00 00	 call	 ast_for_except_clause

; 3425 :             if (!e)

  00195	48 85 c0	 test	 rax, rax
  00198	0f 84 88 00 00
	00		 je	 $LN20@ast_for_tr@2

; 3426 :                 return NULL;
; 3427 :             asdl_seq_SET(handlers, i, e);

  0019e	48 ff c3	 inc	 rbx
  001a1	48 89 07	 mov	 QWORD PTR [rdi], rax
  001a4	83 c6 03	 add	 esi, 3
  001a7	48 83 c7 08	 add	 rdi, 8
  001ab	48 3b dd	 cmp	 rbx, rbp
  001ae	7c c0		 jl	 SHORT $LL4@ast_for_tr@2
$LN2@ast_for_tr@2:

; 3428 :         }
; 3429 :     }
; 3430 : 
; 3431 :     assert(finally != NULL || asdl_seq_LEN(handlers));
; 3432 :     return Try(body, handlers, orelse, finally, LINENO(n), n->n_col_offset, c->c_arena);

  001b0	49 8b 44 24 08	 mov	 rax, QWORD PTR [r12+8]
  001b5	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR finally$1$[rsp]
  001bd	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR orelse$1$[rsp]
  001c5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR body$1$[rsp]
  001cd	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001d2	41 8b 46 14	 mov	 eax, DWORD PTR [r14+20]
  001d6	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001da	41 8b 46 10	 mov	 eax, DWORD PTR [r14+16]
  001de	49 8b d7	 mov	 rdx, r15
  001e1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001e5	e8 00 00 00 00	 call	 _Py_Try
$LN23@ast_for_tr@2:
  001ea	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  001f2	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 3433 : }

  001f7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001fb	41 5f		 pop	 r15
  001fd	41 5e		 pop	 r14
  001ff	41 5d		 pop	 r13
  00201	41 5c		 pop	 r12
  00203	5d		 pop	 rbp
  00204	5b		 pop	 rbx
  00205	c3		 ret	 0
$LN15@ast_for_tr@2:

; 3408 :         }
; 3409 :     }
; 3410 :     else if (TYPE(CHILD(n, nch - 3)) != except_clause) {

  00206	b8 2c 01 00 00	 mov	 eax, 300		; 0000012cH
  0020b	66 3b c8	 cmp	 cx, ax
  0020e	0f 84 24 ff ff
	ff		 je	 $LN7@ast_for_tr@2

; 3411 :         ast_error(c, n, "malformed 'try' statement");

  00214	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BK@MKJMBJFL@malformed?5?8try?8?5statement?$AA@
  0021b	49 8b d6	 mov	 rdx, r14
  0021e	49 8b cc	 mov	 rcx, r12
  00221	e8 00 00 00 00	 call	 ast_error
$LN20@ast_for_tr@2:

; 3412 :         return NULL;

  00226	33 c0		 xor	 eax, eax
  00228	eb c0		 jmp	 SHORT $LN23@ast_for_tr@2
ast_for_try_stmt ENDP
_TEXT	ENDS
EXTRN	_Py_withitem:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_with_item DD imagerel ast_for_with_item
	DD	imagerel ast_for_with_item+139
	DD	imagerel $unwind$ast_for_with_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_with_item DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_with_item
_TEXT	SEGMENT
c$ = 48
n$ = 56
ast_for_with_item PROC					; COMDAT

; 3438 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b da	 mov	 rbx, rdx

; 3439 :     expr_ty context_expr, optional_vars = NULL;
; 3440 : 
; 3441 :     REQ(n, with_item);
; 3442 :     context_expr = ast_for_expr(c, CHILD(n, 0));

  00017	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  0001b	48 8b f1	 mov	 rsi, rcx
  0001e	33 ff		 xor	 edi, edi
  00020	e8 00 00 00 00	 call	 ast_for_expr
  00025	48 8b e8	 mov	 rbp, rax

; 3443 :     if (!context_expr)

  00028	48 85 c0	 test	 rax, rax
  0002b	75 04		 jne	 SHORT $LN4@ast_for_wi
$LN7@ast_for_wi:

; 3444 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 45		 jmp	 SHORT $LN5@ast_for_wi
$LN4@ast_for_wi:

; 3445 :     if (NCH(n) == 3) {

  00031	83 7b 18 03	 cmp	 DWORD PTR [rbx+24], 3
  00035	75 30		 jne	 SHORT $LN1@ast_for_wi

; 3446 :         optional_vars = ast_for_expr(c, CHILD(n, 2));

  00037	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  0003b	48 8b ce	 mov	 rcx, rsi
  0003e	48 83 c2 50	 add	 rdx, 80			; 00000050H
  00042	e8 00 00 00 00	 call	 ast_for_expr
  00047	48 8b f8	 mov	 rdi, rax

; 3447 : 
; 3448 :         if (!optional_vars) {

  0004a	48 85 c0	 test	 rax, rax

; 3449 :             return NULL;

  0004d	74 de		 je	 SHORT $LN7@ast_for_wi

; 3450 :         }
; 3451 :         if (!set_context(c, optional_vars, Store, n)) {

  0004f	4c 8b cb	 mov	 r9, rbx
  00052	41 b8 02 00 00
	00		 mov	 r8d, 2
  00058	48 8b d0	 mov	 rdx, rax
  0005b	48 8b ce	 mov	 rcx, rsi
  0005e	e8 00 00 00 00	 call	 set_context
  00063	85 c0		 test	 eax, eax

; 3452 :             return NULL;

  00065	74 c6		 je	 SHORT $LN7@ast_for_wi
$LN1@ast_for_wi:

; 3453 :         }
; 3454 :     }
; 3455 : 
; 3456 :     return withitem(context_expr, optional_vars, c->c_arena);

  00067	4c 8b 46 08	 mov	 r8, QWORD PTR [rsi+8]
  0006b	48 8b d7	 mov	 rdx, rdi
  0006e	48 8b cd	 mov	 rcx, rbp
  00071	e8 00 00 00 00	 call	 _Py_withitem
$LN5@ast_for_wi:

; 3457 : }

  00076	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007b	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00080	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00085	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00089	5f		 pop	 rdi
  0008a	c3		 ret	 0
ast_for_with_item ENDP
_TEXT	ENDS
EXTRN	_Py_With:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_with_stmt DD imagerel ast_for_with_stmt
	DD	imagerel ast_for_with_stmt+241
	DD	imagerel $unwind$ast_for_with_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_with_stmt DD 084c01H
	DD	08344cH
	DD	0a640fH
	DD	09540fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_with_stmt
_TEXT	SEGMENT
c$ = 64
n$ = 72
ast_for_with_stmt PROC					; COMDAT

; 3462 : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3463 :     int i, n_items;
; 3464 :     asdl_seq *items, *body;
; 3465 : 
; 3466 :     REQ(n, with_stmt);
; 3467 : 
; 3468 :     n_items = (NCH(n) - 2) / 2;

  0000f	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b f1	 mov	 rsi, rcx
  00018	83 e8 02	 sub	 eax, 2
  0001b	99		 cdq
  0001c	2b c2		 sub	 eax, edx

; 3469 :     items = asdl_seq_new(n_items, c->c_arena);

  0001e	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  00022	d1 f8		 sar	 eax, 1
  00024	48 63 c8	 movsxd	 rcx, eax
  00027	e8 00 00 00 00	 call	 asdl_seq_new
  0002c	48 8b e8	 mov	 rbp, rax

; 3470 :     if (!items)

  0002f	48 85 c0	 test	 rax, rax
  00032	75 10		 jne	 SHORT $LN6@ast_for_wi@2

; 3484 : }

  00034	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00039	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
$LN6@ast_for_wi@2:

; 3471 :         return NULL;
; 3472 :     for (i = 1; i < NCH(n) - 2; i += 2) {

  00044	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  00047	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0004c	bb 01 00 00 00	 mov	 ebx, 1
  00051	83 e8 02	 sub	 eax, 2
  00054	3b c3		 cmp	 eax, ebx
  00056	7e 44		 jle	 SHORT $LN3@ast_for_wi@2
  00058	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@ast_for_wi@2:

; 3473 :         withitem_ty item = ast_for_with_item(c, CHILD(n, i));

  00060	48 63 c3	 movsxd	 rax, ebx
  00063	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00067	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0006b	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  0006f	48 8b ce	 mov	 rcx, rsi
  00072	e8 00 00 00 00	 call	 ast_for_with_item
  00077	4c 8b d8	 mov	 r11, rax

; 3474 :         if (!item)

  0007a	48 85 c0	 test	 rax, rax
  0007d	74 40		 je	 SHORT $LN10@ast_for_wi@2

; 3475 :             return NULL;
; 3476 :         asdl_seq_SET(items, (i - 1) / 2, item);

  0007f	8d 43 ff	 lea	 eax, DWORD PTR [rbx-1]
  00082	83 c3 02	 add	 ebx, 2
  00085	99		 cdq
  00086	2b c2		 sub	 eax, edx
  00088	d1 f8		 sar	 eax, 1
  0008a	48 63 c8	 movsxd	 rcx, eax
  0008d	4c 89 5c cd 08	 mov	 QWORD PTR [rbp+rcx*8+8], r11
  00092	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  00095	83 e8 02	 sub	 eax, 2
  00098	3b d8		 cmp	 ebx, eax
  0009a	7c c4		 jl	 SHORT $LL5@ast_for_wi@2
$LN3@ast_for_wi@2:

; 3477 :     }
; 3478 : 
; 3479 :     body = ast_for_suite(c, CHILD(n, NCH(n) - 1));

  0009c	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  0009f	ff c8		 dec	 eax
  000a1	48 98		 cdqe
  000a3	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  000a7	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000ab	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  000af	48 8b ce	 mov	 rcx, rsi
  000b2	e8 00 00 00 00	 call	 ast_for_suite
  000b7	48 8b d0	 mov	 rdx, rax

; 3480 :     if (!body)

  000ba	48 85 c0	 test	 rax, rax
  000bd	75 04		 jne	 SHORT $LN1@ast_for_wi@2
$LN10@ast_for_wi@2:

; 3481 :         return NULL;

  000bf	33 c0		 xor	 eax, eax
  000c1	eb 19		 jmp	 SHORT $LN12@ast_for_wi@2
$LN1@ast_for_wi@2:

; 3482 : 
; 3483 :     return With(items, body, LINENO(n), n->n_col_offset, c->c_arena);

  000c3	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  000c7	44 8b 4f 14	 mov	 r9d, DWORD PTR [rdi+20]
  000cb	44 8b 47 10	 mov	 r8d, DWORD PTR [rdi+16]
  000cf	48 8b cd	 mov	 rcx, rbp
  000d2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d7	e8 00 00 00 00	 call	 _Py_With
$LN12@ast_for_wi@2:

; 3484 : }

  000dc	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e1	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000e6	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000eb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ef	5f		 pop	 rdi
  000f0	c3		 ret	 0
ast_for_with_stmt ENDP
_TEXT	ENDS
EXTRN	_Py_ClassDef:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_classdef DD imagerel ast_for_classdef
	DD	imagerel ast_for_classdef+250
	DD	imagerel $unwind$ast_for_classdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ast_for_classdef DD imagerel ast_for_classdef+250
	DD	imagerel ast_for_classdef+435
	DD	imagerel $chain$0$ast_for_classdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ast_for_classdef DD imagerel ast_for_classdef+435
	DD	imagerel ast_for_classdef+457
	DD	imagerel $chain$1$ast_for_classdef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ast_for_classdef DD 021H
	DD	imagerel ast_for_classdef
	DD	imagerel ast_for_classdef+250
	DD	imagerel $unwind$ast_for_classdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ast_for_classdef DD 020521H
	DD	0ed405H
	DD	imagerel ast_for_classdef
	DD	imagerel ast_for_classdef+250
	DD	imagerel $unwind$ast_for_classdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_classdef DD 081201H
	DD	0105412H
	DD	0f3412H
	DD	0c00e9212H
	DD	0600b700cH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_classdef
_TEXT	SEGMENT
c$ = 112
n$ = 120
decorator_seq$ = 128
ast_for_classdef PROC					; COMDAT

; 3488 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 3489 :     /* classdef: 'class' NAME ['(' arglist ')'] ':' suite */
; 3490 :     PyObject *classname;
; 3491 :     asdl_seq *s;
; 3492 :     expr_ty call;
; 3493 : 
; 3494 :     REQ(n, classdef);
; 3495 : 
; 3496 :     if (NCH(n) == 4) { /* class NAME ':' suite */

  00012	83 7a 18 04	 cmp	 DWORD PTR [rdx+24], 4
  00016	4d 8b e0	 mov	 r12, r8
  00019	48 8b da	 mov	 rbx, rdx
  0001c	48 8b f9	 mov	 rdi, rcx
  0001f	0f 85 8d 00 00
	00		 jne	 $LN13@ast_for_cl

; 3497 :         s = ast_for_suite(c, CHILD(n, 3));

  00025	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00029	48 83 c2 78	 add	 rdx, 120		; 00000078H
$LN20@ast_for_cl:
  0002d	e8 00 00 00 00	 call	 ast_for_suite
  00032	48 8b e8	 mov	 rbp, rax

; 3498 :         if (!s)

  00035	48 85 c0	 test	 rax, rax
  00038	75 07		 jne	 SHORT $LN12@ast_for_cl
$LN18@ast_for_cl:

; 3499 :             return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	e9 72 01 00 00	 jmp	 $LN14@ast_for_cl
$LN12@ast_for_cl:

; 3500 :         classname = NEW_IDENTIFIER(CHILD(n, 1));

  00041	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00045	48 8b d7	 mov	 rdx, rdi
  00048	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0004c	e8 00 00 00 00	 call	 new_identifier
  00051	48 8b f0	 mov	 rsi, rax

; 3501 :         if (!classname)

  00054	48 85 c0	 test	 rax, rax

; 3502 :             return NULL;

  00057	74 e1		 je	 SHORT $LN18@ast_for_cl

; 3503 :         if (forbidden_name(c, classname, CHILD(n, 3), 0))

  00059	4c 8b 43 20	 mov	 r8, QWORD PTR [rbx+32]
  0005d	45 33 c9	 xor	 r9d, r9d
  00060	48 8b d0	 mov	 rdx, rax
  00063	49 83 c0 78	 add	 r8, 120			; 00000078H
  00067	48 8b cf	 mov	 rcx, rdi
  0006a	e8 00 00 00 00	 call	 forbidden_name
  0006f	85 c0		 test	 eax, eax

; 3504 :             return NULL;

  00071	75 c7		 jne	 SHORT $LN18@ast_for_cl

; 3505 :         return ClassDef(classname, NULL, NULL, NULL, NULL, s, decorator_seq,
; 3506 :                         LINENO(n), n->n_col_offset, c->c_arena);

  00073	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00077	45 33 c9	 xor	 r9d, r9d
  0007a	45 33 c0	 xor	 r8d, r8d
  0007d	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00082	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  00085	33 d2		 xor	 edx, edx
  00087	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0008b	8b 43 10	 mov	 eax, DWORD PTR [rbx+16]
  0008e	48 8b ce	 mov	 rcx, rsi
  00091	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00095	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  0009a	48 89 6c 24 28	 mov	 QWORD PTR [rsp+40], rbp
  0009f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000a8	e8 00 00 00 00	 call	 _Py_ClassDef
  000ad	e9 01 01 00 00	 jmp	 $LN14@ast_for_cl
$LN13@ast_for_cl:

; 3507 :     }
; 3508 : 
; 3509 :     if (TYPE(CHILD(n, 3)) == RPAR) { /* class NAME '(' ')' ':' suite */

  000b2	48 8b 4a 20	 mov	 rcx, QWORD PTR [rdx+32]
  000b6	66 83 79 78 08	 cmp	 WORD PTR [rcx+120], 8
  000bb	75 0f		 jne	 SHORT $LN9@ast_for_cl

; 3510 :         s = ast_for_suite(c, CHILD(n,5));

  000bd	48 8d 91 c8 00
	00 00		 lea	 rdx, QWORD PTR [rcx+200]
  000c4	48 8b cf	 mov	 rcx, rdi

; 3511 :         if (!s)
; 3512 :             return NULL;

  000c7	e9 61 ff ff ff	 jmp	 $LN20@ast_for_cl
$LN9@ast_for_cl:

; 3513 :         classname = NEW_IDENTIFIER(CHILD(n, 1));
; 3514 :         if (!classname)
; 3515 :             return NULL;
; 3516 :         if (forbidden_name(c, classname, CHILD(n, 3), 0))
; 3517 :             return NULL;
; 3518 :         return ClassDef(classname, NULL, NULL, NULL, NULL, s, decorator_seq,
; 3519 :                         LINENO(n), n->n_col_offset, c->c_arena);
; 3520 :     }
; 3521 : 
; 3522 :     /* class NAME '(' arglist ')' ':' suite */
; 3523 :     /* build up a fake Call node so we can extract its pieces */
; 3524 :     {
; 3525 :         PyObject *dummy_name;
; 3526 :         expr_ty dummy;
; 3527 :         dummy_name = NEW_IDENTIFIER(CHILD(n, 1));

  000cc	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000d0	48 8b d7	 mov	 rdx, rdi
  000d3	e8 00 00 00 00	 call	 new_identifier
  000d8	48 8b c8	 mov	 rcx, rax

; 3528 :         if (!dummy_name)

  000db	48 85 c0	 test	 rax, rax

; 3529 :             return NULL;

  000de	0f 84 56 ff ff
	ff		 je	 $LN18@ast_for_cl

; 3530 :         dummy = Name(dummy_name, Load, LINENO(n), n->n_col_offset, c->c_arena);

  000e4	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  000e8	44 8b 4b 14	 mov	 r9d, DWORD PTR [rbx+20]
  000ec	44 8b 43 10	 mov	 r8d, DWORD PTR [rbx+16]
  000f0	ba 01 00 00 00	 mov	 edx, 1
  000f5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fa	4c 89 6c 24 70	 mov	 QWORD PTR [rsp+112], r13
  000ff	e8 00 00 00 00	 call	 _Py_Name

; 3531 :         call = ast_for_call(c, CHILD(n, 3), dummy);

  00104	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00108	48 8b cf	 mov	 rcx, rdi
  0010b	48 83 c2 78	 add	 rdx, 120		; 00000078H
  0010f	4c 8b c0	 mov	 r8, rax
  00112	e8 00 00 00 00	 call	 ast_for_call
  00117	4c 8b e8	 mov	 r13, rax

; 3532 :         if (!call)

  0011a	48 85 c0	 test	 rax, rax

; 3533 :             return NULL;

  0011d	74 4d		 je	 SHORT $LN17@ast_for_cl

; 3534 :     }
; 3535 :     s = ast_for_suite(c, CHILD(n, 6));

  0011f	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00123	48 8b cf	 mov	 rcx, rdi
  00126	48 81 c2 f0 00
	00 00		 add	 rdx, 240		; 000000f0H
  0012d	e8 00 00 00 00	 call	 ast_for_suite
  00132	48 8b e8	 mov	 rbp, rax

; 3536 :     if (!s)

  00135	48 85 c0	 test	 rax, rax

; 3537 :         return NULL;

  00138	74 32		 je	 SHORT $LN17@ast_for_cl

; 3538 :     classname = NEW_IDENTIFIER(CHILD(n, 1));

  0013a	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  0013e	48 8b d7	 mov	 rdx, rdi
  00141	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00145	e8 00 00 00 00	 call	 new_identifier
  0014a	48 8b f0	 mov	 rsi, rax

; 3539 :     if (!classname)

  0014d	48 85 c0	 test	 rax, rax

; 3540 :         return NULL;

  00150	74 1a		 je	 SHORT $LN17@ast_for_cl

; 3541 :     if (forbidden_name(c, classname, CHILD(n, 1), 0))

  00152	4c 8b 43 20	 mov	 r8, QWORD PTR [rbx+32]
  00156	45 33 c9	 xor	 r9d, r9d
  00159	48 8b d0	 mov	 rdx, rax
  0015c	49 83 c0 28	 add	 r8, 40			; 00000028H
  00160	48 8b cf	 mov	 rcx, rdi
  00163	e8 00 00 00 00	 call	 forbidden_name
  00168	85 c0		 test	 eax, eax
  0016a	74 04		 je	 SHORT $LN1@ast_for_cl
$LN17@ast_for_cl:

; 3542 :         return NULL;

  0016c	33 c0		 xor	 eax, eax
  0016e	eb 3e		 jmp	 SHORT $LN16@ast_for_cl
$LN1@ast_for_cl:

; 3543 : 
; 3544 :     return ClassDef(classname, call->v.Call.args, call->v.Call.keywords,
; 3545 :                     call->v.Call.starargs, call->v.Call.kwargs, s,
; 3546 :                     decorator_seq, LINENO(n), n->n_col_offset, c->c_arena);

  00170	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00174	4d 8b 4d 20	 mov	 r9, QWORD PTR [r13+32]
  00178	4d 8b 45 18	 mov	 r8, QWORD PTR [r13+24]
  0017c	49 8b 55 10	 mov	 rdx, QWORD PTR [r13+16]
  00180	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00185	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  00188	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0018c	8b 43 10	 mov	 eax, DWORD PTR [rbx+16]
  0018f	48 8b ce	 mov	 rcx, rsi
  00192	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00196	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  0019a	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  0019f	48 89 6c 24 28	 mov	 QWORD PTR [rsp+40], rbp
  001a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a9	e8 00 00 00 00	 call	 _Py_ClassDef
$LN16@ast_for_cl:
  001ae	4c 8b 6c 24 70	 mov	 r13, QWORD PTR [rsp+112]
$LN14@ast_for_cl:

; 3547 : }

  001b3	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  001b8	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]
  001c0	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001c4	41 5c		 pop	 r12
  001c6	5f		 pop	 rdi
  001c7	5e		 pop	 rsi
  001c8	c3		 ret	 0
ast_for_classdef ENDP
_TEXT	ENDS
PUBLIC	??_C@_07KJOMBCLC@targets?$AA@			; `string'
PUBLIC	??_C@_06EDODJIDJ@Assign?$AA@			; `string'
PUBLIC	??_C@_06JBKGCNBB@Delete?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_assignlist DD imagerel validate_assignlist
	DD	imagerel validate_assignlist+98
	DD	imagerel $unwind$validate_assignlist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_assignlist DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_07KJOMBCLC@targets?$AA@
CONST	SEGMENT
??_C@_07KJOMBCLC@targets?$AA@ DB 'targets', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EDODJIDJ@Assign?$AA@
CONST	SEGMENT
??_C@_06EDODJIDJ@Assign?$AA@ DB 'Assign', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JBKGCNBB@Delete?$AA@
CONST	SEGMENT
??_C@_06JBKGCNBB@Delete?$AA@ DB 'Delete', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT validate_assignlist
_TEXT	SEGMENT
targets$ = 48
ctx$ = 56
validate_assignlist PROC				; COMDAT

; 304  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 305  :     return validate_nonempty_seq(targets, "targets", ctx == Del ? "Delete" : "Assign") &&
; 306  :         validate_exprs(targets, ctx, 0);

  0000a	83 fa 03	 cmp	 edx, 3
  0000d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06JBKGCNBB@Delete?$AA@
  00014	8b da		 mov	 ebx, edx
  00016	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06EDODJIDJ@Assign?$AA@
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07KJOMBCLC@targets?$AA@
  00024	48 8b f9	 mov	 rdi, rcx
  00027	4c 0f 44 c0	 cmove	 r8, rax
  0002b	e8 00 00 00 00	 call	 validate_nonempty_seq
  00030	85 c0		 test	 eax, eax
  00032	74 21		 je	 SHORT $LN3@validate_a@3
  00034	45 33 c0	 xor	 r8d, r8d
  00037	8b d3		 mov	 edx, ebx
  00039	48 8b cf	 mov	 rcx, rdi
  0003c	e8 00 00 00 00	 call	 validate_exprs
  00041	85 c0		 test	 eax, eax
  00043	74 10		 je	 SHORT $LN3@validate_a@3
  00045	b8 01 00 00 00	 mov	 eax, 1

; 307  : }

  0004a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5f		 pop	 rdi
  00054	c3		 ret	 0
$LN3@validate_a@3:

; 305  :     return validate_nonempty_seq(targets, "targets", ctx == Del ? "Delete" : "Assign") &&
; 306  :         validate_exprs(targets, ctx, 0);

  00055	33 c0		 xor	 eax, eax

; 307  : }

  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5f		 pop	 rdi
  00061	c3		 ret	 0
validate_assignlist ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@BHMAOFEE@unexpected?5statement?$AA@	; `string'
PUBLIC	??_C@_08BAHOEEIH@Nonlocal?$AA@			; `string'
PUBLIC	??_C@_06JGBJPOPP@Global?$AA@			; `string'
PUBLIC	??_C@_0L@IKBFEFKH@ImportFrom?$AA@		; `string'
PUBLIC	??_C@_0BO@MEDGNNAA@ImportFrom?5level?5less?5than?5?91?$AA@ ; `string'
PUBLIC	??_C@_05FLNDGCKL@names?$AA@			; `string'
PUBLIC	??_C@_06IBNLALPJ@Import?$AA@			; `string'
PUBLIC	??_C@_0CO@FPIKDLC@Try?5has?5neither?5except?5handlers?5@ ; `string'
PUBLIC	??_C@_0O@IFPAFICE@ExceptHandler?$AA@		; `string'
PUBLIC	??_C@_0CG@GECHCPK@Try?5has?5orelse?5but?5no?5except?5han@ ; `string'
PUBLIC	??_C@_03DDFMMGJH@Try?$AA@			; `string'
PUBLIC	??_C@_0CC@OFNEJJFD@Raise?5with?5cause?5but?5no?5exceptio@ ; `string'
PUBLIC	??_C@_05CFHBDDLG@items?$AA@			; `string'
PUBLIC	??_C@_04LBMICJD@With?$AA@			; `string'
PUBLIC	??_C@_02EMFCFMID@If?$AA@			; `string'
PUBLIC	??_C@_05OJJNEPLA@While?$AA@			; `string'
PUBLIC	??_C@_03DOEGLAGL@For?$AA@			; `string'
PUBLIC	??_C@_08OGFMJMG@ClassDef?$AA@			; `string'
PUBLIC	??_C@_0M@POJILEOM@FunctionDef?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_stmt DD imagerel validate_stmt
	DD	imagerel validate_stmt+1452
	DD	imagerel $unwind$validate_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_stmt DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0d0143218H
	DD	07010c012H
xdata	ENDS
;	COMDAT ??_C@_0BF@BHMAOFEE@unexpected?5statement?$AA@
CONST	SEGMENT
??_C@_0BF@BHMAOFEE@unexpected?5statement?$AA@ DB 'unexpected statement', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BAHOEEIH@Nonlocal?$AA@
CONST	SEGMENT
??_C@_08BAHOEEIH@Nonlocal?$AA@ DB 'Nonlocal', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JGBJPOPP@Global?$AA@
CONST	SEGMENT
??_C@_06JGBJPOPP@Global?$AA@ DB 'Global', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IKBFEFKH@ImportFrom?$AA@
CONST	SEGMENT
??_C@_0L@IKBFEFKH@ImportFrom?$AA@ DB 'ImportFrom', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MEDGNNAA@ImportFrom?5level?5less?5than?5?91?$AA@
CONST	SEGMENT
??_C@_0BO@MEDGNNAA@ImportFrom?5level?5less?5than?5?91?$AA@ DB 'ImportFrom'
	DB	' level less than -1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FLNDGCKL@names?$AA@
CONST	SEGMENT
??_C@_05FLNDGCKL@names?$AA@ DB 'names', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IBNLALPJ@Import?$AA@
CONST	SEGMENT
??_C@_06IBNLALPJ@Import?$AA@ DB 'Import', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FPIKDLC@Try?5has?5neither?5except?5handlers?5@
CONST	SEGMENT
??_C@_0CO@FPIKDLC@Try?5has?5neither?5except?5handlers?5@ DB 'Try has neit'
	DB	'her except handlers nor finalbody', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IFPAFICE@ExceptHandler?$AA@
CONST	SEGMENT
??_C@_0O@IFPAFICE@ExceptHandler?$AA@ DB 'ExceptHandler', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GECHCPK@Try?5has?5orelse?5but?5no?5except?5han@
CONST	SEGMENT
??_C@_0CG@GECHCPK@Try?5has?5orelse?5but?5no?5except?5han@ DB 'Try has ore'
	DB	'lse but no except handlers', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DDFMMGJH@Try?$AA@
CONST	SEGMENT
??_C@_03DDFMMGJH@Try?$AA@ DB 'Try', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@OFNEJJFD@Raise?5with?5cause?5but?5no?5exceptio@
CONST	SEGMENT
??_C@_0CC@OFNEJJFD@Raise?5with?5cause?5but?5no?5exceptio@ DB 'Raise with '
	DB	'cause but no exception', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFHBDDLG@items?$AA@
CONST	SEGMENT
??_C@_05CFHBDDLG@items?$AA@ DB 'items', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBMICJD@With?$AA@
CONST	SEGMENT
??_C@_04LBMICJD@With?$AA@ DB 'With', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02EMFCFMID@If?$AA@
CONST	SEGMENT
??_C@_02EMFCFMID@If?$AA@ DB 'If', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OJJNEPLA@While?$AA@
CONST	SEGMENT
??_C@_05OJJNEPLA@While?$AA@ DB 'While', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DOEGLAGL@For?$AA@
CONST	SEGMENT
??_C@_03DOEGLAGL@For?$AA@ DB 'For', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08OGFMJMG@ClassDef?$AA@
CONST	SEGMENT
??_C@_08OGFMJMG@ClassDef?$AA@ DB 'ClassDef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@POJILEOM@FunctionDef?$AA@
CONST	SEGMENT
??_C@_0M@POJILEOM@FunctionDef?$AA@ DB 'FunctionDef', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT validate_stmt
_TEXT	SEGMENT
stmt$ = 64
validate_stmt PROC					; COMDAT

; 317  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 318  :     int i;
; 319  :     switch (stmt->kind) {

  00018	8b 01		 mov	 eax, DWORD PTR [rcx]
  0001a	48 8b f9	 mov	 rdi, rcx
  0001d	ff c8		 dec	 eax
  0001f	83 f8 14	 cmp	 eax, 20
  00022	0f 87 00 05 00
	00		 ja	 $LN1@validate_s@2
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0002f	48 98		 cdqe
  00031	8b 94 81 00 00
	00 00		 mov	 edx, DWORD PTR $LN94@validate_s@2[rcx+rax*4]
  00038	48 03 d1	 add	 rdx, rcx
  0003b	ff e2		 jmp	 rdx
$LN38@validate_s@2:

; 320  :     case FunctionDef_kind:
; 321  :         return validate_body(stmt->v.FunctionDef.body, "FunctionDef") &&
; 322  :             validate_arguments(stmt->v.FunctionDef.args) &&
; 323  :             validate_exprs(stmt->v.FunctionDef.decorator_list, Load, 0) &&
; 324  :             (!stmt->v.FunctionDef.returns ||
; 325  :              validate_expr(stmt->v.FunctionDef.returns, Load));

  0003d	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@POJILEOM@FunctionDef?$AA@
  00048	e8 00 00 00 00	 call	 validate_body
  0004d	85 c0		 test	 eax, eax
  0004f	74 38		 je	 SHORT $LN43@validate_s@2
  00051	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00055	e8 00 00 00 00	 call	 validate_arguments
  0005a	85 c0		 test	 eax, eax
  0005c	74 2b		 je	 SHORT $LN43@validate_s@2
  0005e	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  00062	bb 01 00 00 00	 mov	 ebx, 1
  00067	45 33 c0	 xor	 r8d, r8d
  0006a	8b d3		 mov	 edx, ebx
  0006c	e8 00 00 00 00	 call	 validate_exprs
  00071	85 c0		 test	 eax, eax
  00073	74 14		 je	 SHORT $LN43@validate_s@2
  00075	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  00079	48 85 c9	 test	 rcx, rcx
  0007c	74 0f		 je	 SHORT $LN45@validate_s@2
  0007e	8b d3		 mov	 edx, ebx
  00080	e8 00 00 00 00	 call	 validate_expr
  00085	85 c0		 test	 eax, eax
  00087	75 04		 jne	 SHORT $LN45@validate_s@2
$LN43@validate_s@2:
  00089	33 f6		 xor	 esi, esi
  0008b	8b de		 mov	 ebx, esi
$LN45@validate_s@2:
  0008d	8b c3		 mov	 eax, ebx
  0008f	e9 a9 04 00 00	 jmp	 $LN39@validate_s@2
$LN37@validate_s@2:

; 326  :     case ClassDef_kind:
; 327  :         return validate_body(stmt->v.ClassDef.body, "ClassDef") &&
; 328  :             validate_exprs(stmt->v.ClassDef.bases, Load, 0) &&
; 329  :             validate_keywords(stmt->v.ClassDef.keywords) &&
; 330  :             validate_exprs(stmt->v.ClassDef.decorator_list, Load, 0) &&
; 331  :             (!stmt->v.ClassDef.starargs || validate_expr(stmt->v.ClassDef.starargs, Load)) &&
; 332  :             (!stmt->v.ClassDef.kwargs || validate_expr(stmt->v.ClassDef.kwargs, Load));

  00094	48 8b 4f 30	 mov	 rcx, QWORD PTR [rdi+48]
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OGFMJMG@ClassDef?$AA@
  0009f	e8 00 00 00 00	 call	 validate_body
  000a4	85 c0		 test	 eax, eax
  000a6	74 5e		 je	 SHORT $LN46@validate_s@2
  000a8	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  000ac	bb 01 00 00 00	 mov	 ebx, 1
  000b1	45 33 c0	 xor	 r8d, r8d
  000b4	8b d3		 mov	 edx, ebx
  000b6	e8 00 00 00 00	 call	 validate_exprs
  000bb	85 c0		 test	 eax, eax
  000bd	74 47		 je	 SHORT $LN46@validate_s@2
  000bf	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  000c3	e8 00 00 00 00	 call	 validate_keywords
  000c8	85 c0		 test	 eax, eax
  000ca	74 3a		 je	 SHORT $LN46@validate_s@2
  000cc	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  000d0	45 33 c0	 xor	 r8d, r8d
  000d3	8b d3		 mov	 edx, ebx
  000d5	e8 00 00 00 00	 call	 validate_exprs
  000da	85 c0		 test	 eax, eax
  000dc	74 28		 je	 SHORT $LN46@validate_s@2
  000de	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  000e2	48 85 c9	 test	 rcx, rcx
  000e5	74 0b		 je	 SHORT $LN47@validate_s@2
  000e7	8b d3		 mov	 edx, ebx
  000e9	e8 00 00 00 00	 call	 validate_expr
  000ee	85 c0		 test	 eax, eax
  000f0	74 14		 je	 SHORT $LN46@validate_s@2
$LN47@validate_s@2:
  000f2	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  000f6	48 85 c9	 test	 rcx, rcx
  000f9	74 0f		 je	 SHORT $LN49@validate_s@2
  000fb	8b d3		 mov	 edx, ebx
  000fd	e8 00 00 00 00	 call	 validate_expr
  00102	85 c0		 test	 eax, eax
  00104	75 04		 jne	 SHORT $LN49@validate_s@2
$LN46@validate_s@2:
  00106	33 f6		 xor	 esi, esi
  00108	8b de		 mov	 ebx, esi
$LN49@validate_s@2:
  0010a	8b c3		 mov	 eax, ebx
  0010c	e9 2c 04 00 00	 jmp	 $LN39@validate_s@2
$LN36@validate_s@2:

; 333  :     case Return_kind:
; 334  :         return !stmt->v.Return.value || validate_expr(stmt->v.Return.value, Load);

  00111	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00115	bb 01 00 00 00	 mov	 ebx, 1
  0011a	48 85 c9	 test	 rcx, rcx
  0011d	0f 84 4f 03 00
	00		 je	 $LN82@validate_s@2
  00123	8b d3		 mov	 edx, ebx
  00125	e8 00 00 00 00	 call	 validate_expr
  0012a	85 c0		 test	 eax, eax
  0012c	0f 85 40 03 00
	00		 jne	 $LN82@validate_s@2
  00132	33 f6		 xor	 esi, esi

; 394  :                 return 0;
; 395  :         }
; 396  :         return (!asdl_seq_LEN(stmt->v.Try.finalbody) ||
; 397  :                 validate_stmts(stmt->v.Try.finalbody)) &&
; 398  :             (!asdl_seq_LEN(stmt->v.Try.orelse) ||
; 399  :              validate_stmts(stmt->v.Try.orelse));

  00134	8b c6		 mov	 eax, esi
  00136	e9 02 04 00 00	 jmp	 $LN39@validate_s@2
$LN35@validate_s@2:

; 335  :     case Delete_kind:
; 336  :         return validate_assignlist(stmt->v.Delete.targets, Del);

  0013b	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  0013f	ba 03 00 00 00	 mov	 edx, 3
  00144	e8 00 00 00 00	 call	 validate_assignlist
  00149	e9 ef 03 00 00	 jmp	 $LN39@validate_s@2
$LN34@validate_s@2:

; 337  :     case Assign_kind:
; 338  :         return validate_assignlist(stmt->v.Assign.targets, Store) &&
; 339  :             validate_expr(stmt->v.Assign.value, Load);

  0014e	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00152	ba 02 00 00 00	 mov	 edx, 2
  00157	e8 00 00 00 00	 call	 validate_assignlist
  0015c	85 c0		 test	 eax, eax
  0015e	74 14		 je	 SHORT $LN52@validate_s@2
  00160	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00164	bb 01 00 00 00	 mov	 ebx, 1
  00169	8b d3		 mov	 edx, ebx
  0016b	e8 00 00 00 00	 call	 validate_expr
  00170	85 c0		 test	 eax, eax
  00172	75 04		 jne	 SHORT $LN53@validate_s@2
$LN52@validate_s@2:
  00174	33 f6		 xor	 esi, esi
  00176	8b de		 mov	 ebx, esi
$LN53@validate_s@2:
  00178	8b c3		 mov	 eax, ebx
  0017a	e9 be 03 00 00	 jmp	 $LN39@validate_s@2
$LN33@validate_s@2:

; 340  :     case AugAssign_kind:
; 341  :         return validate_expr(stmt->v.AugAssign.target, Store) &&
; 342  :             validate_expr(stmt->v.AugAssign.value, Load);

  0017f	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00183	ba 02 00 00 00	 mov	 edx, 2
  00188	e8 00 00 00 00	 call	 validate_expr
  0018d	85 c0		 test	 eax, eax
  0018f	74 14		 je	 SHORT $LN54@validate_s@2
  00191	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00195	bb 01 00 00 00	 mov	 ebx, 1
  0019a	8b d3		 mov	 edx, ebx
  0019c	e8 00 00 00 00	 call	 validate_expr
  001a1	85 c0		 test	 eax, eax
  001a3	75 04		 jne	 SHORT $LN55@validate_s@2
$LN54@validate_s@2:
  001a5	33 f6		 xor	 esi, esi
  001a7	8b de		 mov	 ebx, esi
$LN55@validate_s@2:
  001a9	8b c3		 mov	 eax, ebx
  001ab	e9 8d 03 00 00	 jmp	 $LN39@validate_s@2
$LN32@validate_s@2:

; 343  :     case For_kind:
; 344  :         return validate_expr(stmt->v.For.target, Store) &&
; 345  :             validate_expr(stmt->v.For.iter, Load) &&
; 346  :             validate_body(stmt->v.For.body, "For") &&
; 347  :             validate_stmts(stmt->v.For.orelse);

  001b0	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  001b4	ba 02 00 00 00	 mov	 edx, 2
  001b9	e8 00 00 00 00	 call	 validate_expr
  001be	85 c0		 test	 eax, eax
  001c0	74 35		 je	 SHORT $LN56@validate_s@2
  001c2	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  001c6	bb 01 00 00 00	 mov	 ebx, 1
  001cb	8b d3		 mov	 edx, ebx
  001cd	e8 00 00 00 00	 call	 validate_expr
  001d2	85 c0		 test	 eax, eax
  001d4	74 21		 je	 SHORT $LN56@validate_s@2
  001d6	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  001da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03DOEGLAGL@For?$AA@
  001e1	e8 00 00 00 00	 call	 validate_body
  001e6	85 c0		 test	 eax, eax
  001e8	74 0d		 je	 SHORT $LN56@validate_s@2
  001ea	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  001ee	e8 00 00 00 00	 call	 validate_stmts
  001f3	85 c0		 test	 eax, eax
  001f5	75 04		 jne	 SHORT $LN57@validate_s@2
$LN56@validate_s@2:
  001f7	33 f6		 xor	 esi, esi
  001f9	8b de		 mov	 ebx, esi
$LN57@validate_s@2:
  001fb	8b c3		 mov	 eax, ebx
  001fd	e9 3b 03 00 00	 jmp	 $LN39@validate_s@2
$LN31@validate_s@2:

; 348  :     case While_kind:
; 349  :         return validate_expr(stmt->v.While.test, Load) &&
; 350  :             validate_body(stmt->v.While.body, "While") &&
; 351  :             validate_stmts(stmt->v.While.orelse);

  00202	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00206	bb 01 00 00 00	 mov	 ebx, 1
  0020b	8b d3		 mov	 edx, ebx
  0020d	e8 00 00 00 00	 call	 validate_expr
  00212	85 c0		 test	 eax, eax
  00214	74 21		 je	 SHORT $LN58@validate_s@2
  00216	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  0021a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05OJJNEPLA@While?$AA@
  00221	e8 00 00 00 00	 call	 validate_body
  00226	85 c0		 test	 eax, eax
  00228	74 0d		 je	 SHORT $LN58@validate_s@2
  0022a	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  0022e	e8 00 00 00 00	 call	 validate_stmts
  00233	85 c0		 test	 eax, eax
  00235	75 04		 jne	 SHORT $LN59@validate_s@2
$LN58@validate_s@2:
  00237	33 f6		 xor	 esi, esi
  00239	8b de		 mov	 ebx, esi
$LN59@validate_s@2:
  0023b	8b c3		 mov	 eax, ebx
  0023d	e9 fb 02 00 00	 jmp	 $LN39@validate_s@2
$LN30@validate_s@2:

; 352  :     case If_kind:
; 353  :         return validate_expr(stmt->v.If.test, Load) &&
; 354  :             validate_body(stmt->v.If.body, "If") &&
; 355  :             validate_stmts(stmt->v.If.orelse);

  00242	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00246	bb 01 00 00 00	 mov	 ebx, 1
  0024b	8b d3		 mov	 edx, ebx
  0024d	e8 00 00 00 00	 call	 validate_expr
  00252	85 c0		 test	 eax, eax
  00254	74 21		 je	 SHORT $LN60@validate_s@2
  00256	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  0025a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02EMFCFMID@If?$AA@
  00261	e8 00 00 00 00	 call	 validate_body
  00266	85 c0		 test	 eax, eax
  00268	74 0d		 je	 SHORT $LN60@validate_s@2
  0026a	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  0026e	e8 00 00 00 00	 call	 validate_stmts
  00273	85 c0		 test	 eax, eax
  00275	75 04		 jne	 SHORT $LN61@validate_s@2
$LN60@validate_s@2:
  00277	33 f6		 xor	 esi, esi
  00279	8b de		 mov	 ebx, esi
$LN61@validate_s@2:
  0027b	8b c3		 mov	 eax, ebx
  0027d	e9 bb 02 00 00	 jmp	 $LN39@validate_s@2
$LN29@validate_s@2:

; 356  :     case With_kind:
; 357  :         if (!validate_nonempty_seq(stmt->v.With.items, "items", "With"))

  00282	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00286	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04LBMICJD@With?$AA@
  0028d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CFHBDDLG@items?$AA@
  00294	e8 00 00 00 00	 call	 validate_nonempty_seq
  00299	85 c0		 test	 eax, eax

; 358  :             return 0;

  0029b	0f 84 9a 02 00
	00		 je	 $LN95@validate_s@2

; 359  :         for (i = 0; i < asdl_seq_LEN(stmt->v.With.items); i++) {

  002a1	33 f6		 xor	 esi, esi
  002a3	8b ee		 mov	 ebp, esi
  002a5	44 8b e6	 mov	 r12d, esi
  002a8	8d 5e 01	 lea	 ebx, QWORD PTR [rsi+1]
  002ab	0f 1f 44 00 00	 npad	 5
$LL27@validate_s@2:
  002b0	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  002b4	48 8b d6	 mov	 rdx, rsi
  002b7	48 85 c9	 test	 rcx, rcx
  002ba	74 03		 je	 SHORT $LN63@validate_s@2
  002bc	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
$LN63@validate_s@2:
  002bf	48 63 c5	 movsxd	 rax, ebp
  002c2	48 3b c2	 cmp	 rax, rdx
  002c5	7d 3b		 jge	 SHORT $LN25@validate_s@2

; 360  :             withitem_ty item = asdl_seq_GET(stmt->v.With.items, i);

  002c7	4d 8b 6c 0c 08	 mov	 r13, QWORD PTR [r12+rcx+8]

; 361  :             if (!validate_expr(item->context_expr, Load) ||
; 362  :                 (item->optional_vars && !validate_expr(item->optional_vars, Store)))

  002cc	8b d3		 mov	 edx, ebx
  002ce	49 8b 4d 00	 mov	 rcx, QWORD PTR [r13]
  002d2	e8 00 00 00 00	 call	 validate_expr
  002d7	85 c0		 test	 eax, eax
  002d9	0f 84 5c 02 00
	00		 je	 $LN95@validate_s@2
  002df	49 8b 4d 08	 mov	 rcx, QWORD PTR [r13+8]
  002e3	48 85 c9	 test	 rcx, rcx
  002e6	74 12		 je	 SHORT $LN26@validate_s@2
  002e8	ba 02 00 00 00	 mov	 edx, 2
  002ed	e8 00 00 00 00	 call	 validate_expr
  002f2	85 c0		 test	 eax, eax
  002f4	0f 84 41 02 00
	00		 je	 $LN95@validate_s@2
$LN26@validate_s@2:

; 359  :         for (i = 0; i < asdl_seq_LEN(stmt->v.With.items); i++) {

  002fa	ff c5		 inc	 ebp
  002fc	49 83 c4 08	 add	 r12, 8
  00300	eb ae		 jmp	 SHORT $LL27@validate_s@2
$LN25@validate_s@2:

; 363  :                 return 0;
; 364  :         }
; 365  :         return validate_body(stmt->v.With.body, "With");

  00302	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00306	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04LBMICJD@With?$AA@
  0030d	e8 00 00 00 00	 call	 validate_body
  00312	e9 26 02 00 00	 jmp	 $LN39@validate_s@2
$LN22@validate_s@2:

; 366  :     case Raise_kind:
; 367  :         if (stmt->v.Raise.exc) {

  00317	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  0031b	48 85 c9	 test	 rcx, rcx
  0031e	74 2f		 je	 SHORT $LN21@validate_s@2

; 368  :             return validate_expr(stmt->v.Raise.exc, Load) &&
; 369  :                 (!stmt->v.Raise.cause || validate_expr(stmt->v.Raise.cause, Load));

  00320	bb 01 00 00 00	 mov	 ebx, 1
  00325	8b d3		 mov	 edx, ebx
  00327	e8 00 00 00 00	 call	 validate_expr
  0032c	85 c0		 test	 eax, eax
  0032e	74 14		 je	 SHORT $LN65@validate_s@2
  00330	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00334	48 85 c9	 test	 rcx, rcx
  00337	74 0f		 je	 SHORT $LN66@validate_s@2
  00339	8b d3		 mov	 edx, ebx
  0033b	e8 00 00 00 00	 call	 validate_expr
  00340	85 c0		 test	 eax, eax
  00342	75 04		 jne	 SHORT $LN66@validate_s@2
$LN65@validate_s@2:
  00344	33 f6		 xor	 esi, esi
  00346	8b de		 mov	 ebx, esi
$LN66@validate_s@2:
  00348	8b c3		 mov	 eax, ebx
  0034a	e9 ee 01 00 00	 jmp	 $LN39@validate_s@2
$LN21@validate_s@2:

; 370  :         }
; 371  :         if (stmt->v.Raise.cause) {

  0034f	48 83 7f 10 00	 cmp	 QWORD PTR [rdi+16], 0
  00354	74 13		 je	 SHORT $LN20@validate_s@2

; 372  :             PyErr_SetString(PyExc_ValueError, "Raise with cause but no exception");

  00356	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0035d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@OFNEJJFD@Raise?5with?5cause?5but?5no?5exceptio@

; 373  :             return 0;

  00364	e9 cd 01 00 00	 jmp	 $LN96@validate_s@2
$LN20@validate_s@2:

; 374  :         }
; 375  :         return 1;

  00369	b8 01 00 00 00	 mov	 eax, 1
  0036e	e9 ca 01 00 00	 jmp	 $LN39@validate_s@2
$LN19@validate_s@2:

; 376  :     case Try_kind:
; 377  :         if (!validate_body(stmt->v.Try.body, "Try"))

  00373	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00377	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03DDFMMGJH@Try?$AA@
  0037e	e8 00 00 00 00	 call	 validate_body
  00383	85 c0		 test	 eax, eax

; 378  :             return 0;

  00385	0f 84 b0 01 00
	00		 je	 $LN95@validate_s@2

; 379  :         if (!asdl_seq_LEN(stmt->v.Try.handlers) &&
; 380  :             !asdl_seq_LEN(stmt->v.Try.finalbody)) {

  0038b	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0038f	48 85 c0	 test	 rax, rax
  00392	74 06		 je	 SHORT $LN91@validate_s@2
  00394	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00398	75 17		 jne	 SHORT $LN17@validate_s@2
$LN91@validate_s@2:
  0039a	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  0039e	48 85 c9	 test	 rcx, rcx
  003a1	0f 84 d4 00 00
	00		 je	 $LN92@validate_s@2
  003a7	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  003ab	0f 84 ca 00 00
	00		 je	 $LN92@validate_s@2
$LN17@validate_s@2:

; 383  :         }
; 384  :         if (!asdl_seq_LEN(stmt->v.Try.handlers) &&
; 385  :             asdl_seq_LEN(stmt->v.Try.orelse)) {

  003b1	48 85 c0	 test	 rax, rax
  003b4	74 06		 je	 SHORT $LN93@validate_s@2
  003b6	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  003ba	75 22		 jne	 SHORT $LN16@validate_s@2
$LN93@validate_s@2:
  003bc	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  003c0	48 85 c0	 test	 rax, rax
  003c3	74 19		 je	 SHORT $LN16@validate_s@2
  003c5	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  003c9	74 13		 je	 SHORT $LN16@validate_s@2

; 386  :             PyErr_SetString(PyExc_ValueError, "Try has orelse but no except handlers");

  003cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  003d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@GECHCPK@Try?5has?5orelse?5but?5no?5except?5han@

; 387  :             return 0;

  003d9	e9 58 01 00 00	 jmp	 $LN96@validate_s@2
$LN16@validate_s@2:

; 388  :         }
; 389  :         for (i = 0; i < asdl_seq_LEN(stmt->v.Try.handlers); i++) {

  003de	33 f6		 xor	 esi, esi
  003e0	8b ee		 mov	 ebp, esi
  003e2	44 8b e6	 mov	 r12d, esi
  003e5	8d 5e 01	 lea	 ebx, QWORD PTR [rsi+1]
  003e8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL15@validate_s@2:
  003f0	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  003f4	48 8b d6	 mov	 rdx, rsi
  003f7	48 85 c9	 test	 rcx, rcx
  003fa	74 03		 je	 SHORT $LN76@validate_s@2
  003fc	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
$LN76@validate_s@2:
  003ff	48 63 c5	 movsxd	 rax, ebp
  00402	48 3b c2	 cmp	 rax, rdx
  00405	7d 3d		 jge	 SHORT $LN13@validate_s@2

; 390  :             excepthandler_ty handler = asdl_seq_GET(stmt->v.Try.handlers, i);

  00407	4d 8b 6c 0c 08	 mov	 r13, QWORD PTR [r12+rcx+8]

; 391  :             if ((handler->v.ExceptHandler.type &&
; 392  :                  !validate_expr(handler->v.ExceptHandler.type, Load)) ||
; 393  :                 !validate_body(handler->v.ExceptHandler.body, "ExceptHandler"))

  0040c	49 8b 4d 08	 mov	 rcx, QWORD PTR [r13+8]
  00410	48 85 c9	 test	 rcx, rcx
  00413	74 0f		 je	 SHORT $LN10@validate_s@2
  00415	8b d3		 mov	 edx, ebx
  00417	e8 00 00 00 00	 call	 validate_expr
  0041c	85 c0		 test	 eax, eax
  0041e	0f 84 17 01 00
	00		 je	 $LN95@validate_s@2
$LN10@validate_s@2:
  00424	49 8b 4d 18	 mov	 rcx, QWORD PTR [r13+24]
  00428	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@IFPAFICE@ExceptHandler?$AA@
  0042f	e8 00 00 00 00	 call	 validate_body
  00434	85 c0		 test	 eax, eax
  00436	0f 84 ff 00 00
	00		 je	 $LN95@validate_s@2

; 388  :         }
; 389  :         for (i = 0; i < asdl_seq_LEN(stmt->v.Try.handlers); i++) {

  0043c	ff c5		 inc	 ebp
  0043e	49 83 c4 08	 add	 r12, 8
  00442	eb ac		 jmp	 SHORT $LL15@validate_s@2
$LN13@validate_s@2:

; 394  :                 return 0;
; 395  :         }
; 396  :         return (!asdl_seq_LEN(stmt->v.Try.finalbody) ||
; 397  :                 validate_stmts(stmt->v.Try.finalbody)) &&
; 398  :             (!asdl_seq_LEN(stmt->v.Try.orelse) ||
; 399  :              validate_stmts(stmt->v.Try.orelse));

  00444	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  00448	48 85 c9	 test	 rcx, rcx
  0044b	74 0e		 je	 SHORT $LN79@validate_s@2
  0044d	48 39 31	 cmp	 QWORD PTR [rcx], rsi
  00450	74 09		 je	 SHORT $LN79@validate_s@2
  00452	e8 00 00 00 00	 call	 validate_stmts
  00457	85 c0		 test	 eax, eax
  00459	74 19		 je	 SHORT $LN84@validate_s@2
$LN79@validate_s@2:
  0045b	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  0045f	48 85 c9	 test	 rcx, rcx
  00462	74 0e		 je	 SHORT $LN82@validate_s@2
  00464	48 39 31	 cmp	 QWORD PTR [rcx], rsi
  00467	74 09		 je	 SHORT $LN82@validate_s@2
  00469	e8 00 00 00 00	 call	 validate_stmts
  0046e	85 c0		 test	 eax, eax
  00470	74 02		 je	 SHORT $LN84@validate_s@2
$LN82@validate_s@2:
  00472	8b f3		 mov	 esi, ebx
$LN84@validate_s@2:
  00474	8b c6		 mov	 eax, esi
  00476	e9 c2 00 00 00	 jmp	 $LN39@validate_s@2
$LN92@validate_s@2:

; 381  :             PyErr_SetString(PyExc_ValueError, "Try has neither except handlers nor finalbody");

  0047b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00482	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@FPIKDLC@Try?5has?5neither?5except?5handlers?5@

; 382  :             return 0;

  00489	e9 a8 00 00 00	 jmp	 $LN96@validate_s@2
$LN9@validate_s@2:

; 400  :     case Assert_kind:
; 401  :         return validate_expr(stmt->v.Assert.test, Load) &&
; 402  :             (!stmt->v.Assert.msg || validate_expr(stmt->v.Assert.msg, Load));

  0048e	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00492	bb 01 00 00 00	 mov	 ebx, 1
  00497	8b d3		 mov	 edx, ebx
  00499	e8 00 00 00 00	 call	 validate_expr
  0049e	85 c0		 test	 eax, eax
  004a0	74 14		 je	 SHORT $LN86@validate_s@2
  004a2	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  004a6	48 85 c9	 test	 rcx, rcx
  004a9	74 0f		 je	 SHORT $LN87@validate_s@2
  004ab	8b d3		 mov	 edx, ebx
  004ad	e8 00 00 00 00	 call	 validate_expr
  004b2	85 c0		 test	 eax, eax
  004b4	75 04		 jne	 SHORT $LN87@validate_s@2
$LN86@validate_s@2:
  004b6	33 f6		 xor	 esi, esi
  004b8	8b de		 mov	 ebx, esi
$LN87@validate_s@2:
  004ba	8b c3		 mov	 eax, ebx
  004bc	eb 7f		 jmp	 SHORT $LN39@validate_s@2
$LN8@validate_s@2:

; 403  :     case Import_kind:
; 404  :         return validate_nonempty_seq(stmt->v.Import.names, "names", "Import");

  004be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06IBNLALPJ@Import?$AA@
$LN97@validate_s@2:
  004c5	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  004c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05FLNDGCKL@names?$AA@
  004d0	e8 00 00 00 00	 call	 validate_nonempty_seq
  004d5	eb 66		 jmp	 SHORT $LN39@validate_s@2
$LN7@validate_s@2:

; 405  :     case ImportFrom_kind:
; 406  :         if (stmt->v.ImportFrom.level < -1) {

  004d7	83 7f 18 ff	 cmp	 DWORD PTR [rdi+24], -1
  004db	7d 10		 jge	 SHORT $LN6@validate_s@2

; 407  :             PyErr_SetString(PyExc_ValueError, "ImportFrom level less than -1");

  004dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  004e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@MEDGNNAA@ImportFrom?5level?5less?5than?5?91?$AA@

; 408  :             return 0;

  004eb	eb 49		 jmp	 SHORT $LN96@validate_s@2
$LN6@validate_s@2:

; 409  :         }
; 410  :         return validate_nonempty_seq(stmt->v.ImportFrom.names, "names", "ImportFrom");

  004ed	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  004f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@IKBFEFKH@ImportFrom?$AA@
  004f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05FLNDGCKL@names?$AA@
  004ff	e8 00 00 00 00	 call	 validate_nonempty_seq
  00504	eb 37		 jmp	 SHORT $LN39@validate_s@2
$LN5@validate_s@2:

; 411  :     case Global_kind:
; 412  :         return validate_nonempty_seq(stmt->v.Global.names, "names", "Global");

  00506	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06JGBJPOPP@Global?$AA@
  0050d	eb b6		 jmp	 SHORT $LN97@validate_s@2
$LN4@validate_s@2:

; 413  :     case Nonlocal_kind:
; 414  :         return validate_nonempty_seq(stmt->v.Nonlocal.names, "names", "Nonlocal");

  0050f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08BAHOEEIH@Nonlocal?$AA@
  00516	eb ad		 jmp	 SHORT $LN97@validate_s@2
$LN3@validate_s@2:

; 415  :     case Expr_kind:
; 416  :         return validate_expr(stmt->v.Expr.value, Load);

  00518	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  0051c	ba 01 00 00 00	 mov	 edx, 1
  00521	e8 00 00 00 00	 call	 validate_expr
  00526	eb 15		 jmp	 SHORT $LN39@validate_s@2
$LN1@validate_s@2:

; 417  :     case Pass_kind:
; 418  :     case Break_kind:
; 419  :     case Continue_kind:
; 420  :         return 1;
; 421  :     default:
; 422  :         PyErr_SetString(PyExc_SystemError, "unexpected statement");

  00528	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0052f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@BHMAOFEE@unexpected?5statement?$AA@
$LN96@validate_s@2:
  00536	e8 00 00 00 00	 call	 PyErr_SetString
$LN95@validate_s@2:

; 423  :         return 0;

  0053b	33 c0		 xor	 eax, eax
$LN39@validate_s@2:

; 424  :     }
; 425  : }

  0053d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00542	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00547	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0054c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00550	41 5d		 pop	 r13
  00552	41 5c		 pop	 r12
  00554	5f		 pop	 rdi
  00555	c3		 ret	 0
  00556	66 90		 npad	 2
$LN94@validate_s@2:
  00558	00 00 00 00	 DD	 $LN38@validate_s@2
  0055c	00 00 00 00	 DD	 $LN37@validate_s@2
  00560	00 00 00 00	 DD	 $LN36@validate_s@2
  00564	00 00 00 00	 DD	 $LN35@validate_s@2
  00568	00 00 00 00	 DD	 $LN34@validate_s@2
  0056c	00 00 00 00	 DD	 $LN33@validate_s@2
  00570	00 00 00 00	 DD	 $LN32@validate_s@2
  00574	00 00 00 00	 DD	 $LN31@validate_s@2
  00578	00 00 00 00	 DD	 $LN30@validate_s@2
  0057c	00 00 00 00	 DD	 $LN29@validate_s@2
  00580	00 00 00 00	 DD	 $LN22@validate_s@2
  00584	00 00 00 00	 DD	 $LN19@validate_s@2
  00588	00 00 00 00	 DD	 $LN9@validate_s@2
  0058c	00 00 00 00	 DD	 $LN8@validate_s@2
  00590	00 00 00 00	 DD	 $LN7@validate_s@2
  00594	00 00 00 00	 DD	 $LN5@validate_s@2
  00598	00 00 00 00	 DD	 $LN4@validate_s@2
  0059c	00 00 00 00	 DD	 $LN3@validate_s@2
  005a0	00 00 00 00	 DD	 $LN20@validate_s@2
  005a4	00 00 00 00	 DD	 $LN20@validate_s@2
  005a8	00 00 00 00	 DD	 $LN20@validate_s@2
validate_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@JCLOGNHN@None?5disallowed?5in?5statement?5lis@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_stmts DD imagerel validate_stmts
	DD	imagerel validate_stmts+127
	DD	imagerel $unwind$validate_stmts
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_stmts DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CC@JCLOGNHN@None?5disallowed?5in?5statement?5lis@
CONST	SEGMENT
??_C@_0CC@JCLOGNHN@None?5disallowed?5in?5statement?5lis@ DB 'None disallo'
	DB	'wed in statement list', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT validate_stmts
_TEXT	SEGMENT
seq$ = 48
validate_stmts PROC					; COMDAT

; 429  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f1	 mov	 rsi, rcx

; 430  :     int i;
; 431  :     for (i = 0; i < asdl_seq_LEN(seq); i++) {

  00012	33 ff		 xor	 edi, edi
  00014	48 8d 59 08	 lea	 rbx, QWORD PTR [rcx+8]
$LL6@validate_s@3:
  00018	48 85 f6	 test	 rsi, rsi
  0001b	75 04		 jne	 SHORT $LN9@validate_s@3
  0001d	33 d2		 xor	 edx, edx
  0001f	eb 03		 jmp	 SHORT $LN10@validate_s@3
$LN9@validate_s@3:
  00021	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
$LN10@validate_s@3:
  00024	48 63 c7	 movsxd	 rax, edi
  00027	48 3b c2	 cmp	 rax, rdx
  0002a	7d 3e		 jge	 SHORT $LN4@validate_s@3

; 432  :         stmt_ty stmt = asdl_seq_GET(seq, i);

  0002c	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]

; 433  :         if (stmt) {

  0002f	48 85 c9	 test	 rcx, rcx
  00032	74 11		 je	 SHORT $LN3@validate_s@3

; 434  :             if (!validate_stmt(stmt))

  00034	e8 00 00 00 00	 call	 validate_stmt
  00039	85 c0		 test	 eax, eax
  0003b	74 1b		 je	 SHORT $LN12@validate_s@3

; 430  :     int i;
; 431  :     for (i = 0; i < asdl_seq_LEN(seq); i++) {

  0003d	ff c7		 inc	 edi
  0003f	48 83 c3 08	 add	 rbx, 8
  00043	eb d3		 jmp	 SHORT $LL6@validate_s@3
$LN3@validate_s@3:

; 435  :                 return 0;
; 436  :         }
; 437  :         else {
; 438  :             PyErr_SetString(PyExc_ValueError,
; 439  :                             "None disallowed in statement list");

  00045	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@JCLOGNHN@None?5disallowed?5in?5statement?5lis@
  00053	e8 00 00 00 00	 call	 PyErr_SetString
$LN12@validate_s@3:

; 440  :             return 0;

  00058	33 c0		 xor	 eax, eax

; 441  :         }
; 442  :     }
; 443  :     return 1;
; 444  : }

  0005a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00064	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00068	5f		 pop	 rdi
  00069	c3		 ret	 0
$LN4@validate_s@3:
  0006a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00074	b8 01 00 00 00	 mov	 eax, 1
  00079	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007d	5f		 pop	 rdi
  0007e	c3		 ret	 0
validate_stmts ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@ECMMLFPD@Suite?5is?5not?5valid?5in?5the?5CPytho@ ; `string'
PUBLIC	??_C@_0BH@GOGEICIH@impossible?5module?5node?$AA@ ; `string'
PUBLIC	PyAST_Validate
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyAST_Validate DD imagerel $LN10
	DD	imagerel $LN10+105
	DD	imagerel $unwind$PyAST_Validate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyAST_Validate DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CL@ECMMLFPD@Suite?5is?5not?5valid?5in?5the?5CPytho@
CONST	SEGMENT
??_C@_0CL@ECMMLFPD@Suite?5is?5not?5valid?5in?5the?5CPytho@ DB 'Suite is n'
	DB	'ot valid in the CPython compiler', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GOGEICIH@impossible?5module?5node?$AA@
CONST	SEGMENT
??_C@_0BH@GOGEICIH@impossible?5module?5node?$AA@ DB 'impossible module no'
	DB	'de', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyAST_Validate
_TEXT	SEGMENT
mod$ = 48
PyAST_Validate PROC					; COMDAT

; 468  : {

$LN10:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 469  :     int res = 0;
; 470  : 
; 471  :     switch (mod->kind) {

  00004	8b 11		 mov	 edx, DWORD PTR [rcx]
  00006	ff ca		 dec	 edx
  00008	74 52		 je	 SHORT $LN5@PyAST_Vali
  0000a	ff ca		 dec	 edx
  0000c	74 4e		 je	 SHORT $LN5@PyAST_Vali
  0000e	ff ca		 dec	 edx
  00010	74 38		 je	 SHORT $LN3@PyAST_Vali
  00012	ff ca		 dec	 edx
  00014	74 1a		 je	 SHORT $LN2@PyAST_Vali

; 483  :         break;
; 484  :     default:
; 485  :         PyErr_SetString(PyExc_SystemError, "impossible module node");

  00016	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@GOGEICIH@impossible?5module?5node?$AA@
  00024	e8 00 00 00 00	 call	 PyErr_SetString

; 486  :         res = 0;
; 487  :         break;
; 488  :     }
; 489  :     return res;

  00029	33 c0		 xor	 eax, eax

; 490  : }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
$LN2@PyAST_Vali:

; 480  :         break;
; 481  :     case Suite_kind:
; 482  :         PyErr_SetString(PyExc_ValueError, "Suite is not valid in the CPython compiler");

  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@ECMMLFPD@Suite?5is?5not?5valid?5in?5the?5CPytho@
  0003e	e8 00 00 00 00	 call	 PyErr_SetString

; 486  :         res = 0;
; 487  :         break;
; 488  :     }
; 489  :     return res;

  00043	33 c0		 xor	 eax, eax

; 490  : }

  00045	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00049	c3		 ret	 0
$LN3@PyAST_Vali:

; 474  :         break;
; 475  :     case Interactive_kind:
; 476  :         res = validate_stmts(mod->v.Interactive.body);
; 477  :         break;
; 478  :     case Expression_kind:
; 479  :         res = validate_expr(mod->v.Expression.body, Load);

  0004a	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0004e	ba 01 00 00 00	 mov	 edx, 1

; 490  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	e9 00 00 00 00	 jmp	 validate_expr
$LN5@PyAST_Vali:

; 472  :     case Module_kind:
; 473  :         res = validate_stmts(mod->v.Module.body);

  0005c	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]

; 490  : }

  00060	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00064	e9 00 00 00 00	 jmp	 validate_stmts
PyAST_Validate ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_decorator DD imagerel ast_for_decorator
	DD	imagerel ast_for_decorator+171
	DD	imagerel $unwind$ast_for_decorator
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_decorator DD 040a01H
	DD	0a340aH
	DD	07006720aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_decorator
_TEXT	SEGMENT
c$ = 80
n$ = 88
ast_for_decorator PROC					; COMDAT

; 1430 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b da	 mov	 rbx, rdx

; 1431 :     /* decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE */
; 1432 :     expr_ty d = NULL;
; 1433 :     expr_ty name_expr;
; 1434 : 
; 1435 :     REQ(n, decorator);
; 1436 :     REQ(CHILD(n, 0), AT);
; 1437 :     REQ(RCHILD(n, -1), NEWLINE);
; 1438 : 
; 1439 :     name_expr = ast_for_dotted_name(c, CHILD(n, 1));

  0000d	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 83 c2 28	 add	 rdx, 40			; 00000028H
  00018	e8 00 00 00 00	 call	 ast_for_dotted_name
  0001d	4c 8b d8	 mov	 r11, rax

; 1440 :     if (!name_expr)

  00020	48 85 c0	 test	 rax, rax

; 1441 :         return NULL;

  00023	74 45		 je	 SHORT $LN10@ast_for_de@2

; 1442 : 
; 1443 :     if (NCH(n) == 3) { /* No arguments */

  00025	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  00028	83 f8 03	 cmp	 eax, 3
  0002b	74 70		 je	 SHORT $LN1@ast_for_de@2

; 1444 :         d = name_expr;
; 1445 :         name_expr = NULL;
; 1446 :     }
; 1447 :     else if (NCH(n) == 5) { /* Call with no arguments */

  0002d	83 f8 05	 cmp	 eax, 5
  00030	75 45		 jne	 SHORT $LN4@ast_for_de@2

; 1448 :         d = Call(name_expr, NULL, NULL, NULL, NULL, LINENO(n),
; 1449 :                  n->n_col_offset, c->c_arena);

  00032	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00036	45 33 c9	 xor	 r9d, r9d
  00039	45 33 c0	 xor	 r8d, r8d
  0003c	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00041	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  00044	33 d2		 xor	 edx, edx
  00046	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0004a	8b 43 10	 mov	 eax, DWORD PTR [rbx+16]
  0004d	49 8b cb	 mov	 rcx, r11
  00050	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00054	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0005d	e8 00 00 00 00	 call	 _Py_Call
  00062	4c 8b d8	 mov	 r11, rax

; 1450 :         if (!d)

  00065	48 85 c0	 test	 rax, rax
  00068	75 33		 jne	 SHORT $LN1@ast_for_de@2
$LN10@ast_for_de@2:

; 1451 :             return NULL;

  0006a	33 c0		 xor	 eax, eax

; 1462 : }

  0006c	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00071	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
$LN4@ast_for_de@2:

; 1452 :         name_expr = NULL;
; 1453 :     }
; 1454 :     else {
; 1455 :         d = ast_for_call(c, CHILD(n, 3), name_expr);

  00077	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  0007b	4d 8b c3	 mov	 r8, r11
  0007e	48 8b cf	 mov	 rcx, rdi
  00081	48 83 c2 78	 add	 rdx, 120		; 00000078H
  00085	e8 00 00 00 00	 call	 ast_for_call
  0008a	4c 8b d8	 mov	 r11, rax

; 1456 :         if (!d)

  0008d	48 85 c0	 test	 rax, rax
  00090	75 0b		 jne	 SHORT $LN1@ast_for_de@2

; 1462 : }

  00092	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00097	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0009b	5f		 pop	 rdi
  0009c	c3		 ret	 0
$LN1@ast_for_de@2:

; 1457 :             return NULL;
; 1458 :         name_expr = NULL;
; 1459 :     }
; 1460 : 
; 1461 :     return d;

  0009d	49 8b c3	 mov	 rax, r11

; 1462 : }

  000a0	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000a5	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000a9	5f		 pop	 rdi
  000aa	c3		 ret	 0
ast_for_decorator ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_decorators DD imagerel ast_for_decorators
	DD	imagerel ast_for_decorators+61
	DD	imagerel $unwind$ast_for_decorators
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ast_for_decorators DD imagerel ast_for_decorators+61
	DD	imagerel ast_for_decorators+168
	DD	imagerel $chain$1$ast_for_decorators
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ast_for_decorators DD imagerel ast_for_decorators+168
	DD	imagerel ast_for_decorators+170
	DD	imagerel $chain$3$ast_for_decorators
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ast_for_decorators DD 040021H
	DD	077400H
	DD	063400H
	DD	imagerel ast_for_decorators
	DD	imagerel ast_for_decorators+61
	DD	imagerel $unwind$ast_for_decorators
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ast_for_decorators DD 040c21H
	DD	07740cH
	DD	063405H
	DD	imagerel ast_for_decorators
	DD	imagerel ast_for_decorators+61
	DD	imagerel $unwind$ast_for_decorators
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_decorators DD 061001H
	DD	096410H
	DD	085410H
	DD	0c00c3210H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_decorators
_TEXT	SEGMENT
c$ = 48
n$ = 56
ast_for_decorators PROC					; COMDAT

; 1466 : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	41 54		 push	 r12
  0000c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00010	4c 8b e1	 mov	 r12, rcx

; 1467 :     asdl_seq* decorator_seq;
; 1468 :     expr_ty d;
; 1469 :     int i;
; 1470 : 
; 1471 :     REQ(n, decorators);
; 1472 :     decorator_seq = asdl_seq_new(NCH(n), c->c_arena);

  00013	48 63 4a 18	 movsxd	 rcx, DWORD PTR [rdx+24]
  00017	48 8b f2	 mov	 rsi, rdx
  0001a	49 8b 54 24 08	 mov	 rdx, QWORD PTR [r12+8]
  0001f	e8 00 00 00 00	 call	 asdl_seq_new
  00024	48 8b e8	 mov	 rbp, rax

; 1473 :     if (!decorator_seq)

  00027	48 85 c0	 test	 rax, rax
  0002a	75 11		 jne	 SHORT $LN5@ast_for_de@3

; 1483 : }

  0002c	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00031	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	41 5c		 pop	 r12
  0003c	c3		 ret	 0
$LN5@ast_for_de@3:
  0003d	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1474 :         return NULL;
; 1475 : 
; 1476 :     for (i = 0; i < NCH(n); i++) {

  00042	33 db		 xor	 ebx, ebx
  00044	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00049	39 5e 18	 cmp	 DWORD PTR [rsi+24], ebx
  0004c	7e 3c		 jle	 SHORT $LN2@ast_for_de@3
  0004e	48 8d 78 08	 lea	 rdi, QWORD PTR [rax+8]
  00052	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL4@ast_for_de@3:

; 1477 :         d = ast_for_decorator(c, CHILD(n, i));

  00060	48 63 c3	 movsxd	 rax, ebx
  00063	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00067	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  0006b	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  0006f	49 8b cc	 mov	 rcx, r12
  00072	e8 00 00 00 00	 call	 ast_for_decorator

; 1478 :         if (!d)

  00077	48 85 c0	 test	 rax, rax
  0007a	74 2c		 je	 SHORT $LN9@ast_for_de@3

; 1480 :         asdl_seq_SET(decorator_seq, i, d);

  0007c	48 89 07	 mov	 QWORD PTR [rdi], rax
  0007f	ff c3		 inc	 ebx
  00081	48 83 c7 08	 add	 rdi, 8
  00085	3b 5e 18	 cmp	 ebx, DWORD PTR [rsi+24]
  00088	7c d6		 jl	 SHORT $LL4@ast_for_de@3
$LN2@ast_for_de@3:

; 1481 :     }
; 1482 :     return decorator_seq;

  0008a	48 8b c5	 mov	 rax, rbp
$LN12@ast_for_de@3:
  0008d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00092	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1483 : }

  00097	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0009c	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000a1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a5	41 5c		 pop	 r12
  000a7	c3		 ret	 0
$LN9@ast_for_de@3:

; 1479 :             return NULL;

  000a8	eb e3		 jmp	 SHORT $LN12@ast_for_de@3
ast_for_decorators ENDP
_TEXT	ENDS
EXTRN	_Py_FunctionDef:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_funcdef DD imagerel ast_for_funcdef
	DD	imagerel ast_for_funcdef+102
	DD	imagerel $unwind$ast_for_funcdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ast_for_funcdef DD imagerel ast_for_funcdef+102
	DD	imagerel ast_for_funcdef+248
	DD	imagerel $chain$0$ast_for_funcdef
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$ast_for_funcdef DD imagerel ast_for_funcdef+248
	DD	imagerel ast_for_funcdef+273
	DD	imagerel $chain$1$ast_for_funcdef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$ast_for_funcdef DD 021H
	DD	imagerel ast_for_funcdef
	DD	imagerel ast_for_funcdef+102
	DD	imagerel $unwind$ast_for_funcdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ast_for_funcdef DD 020521H
	DD	0cc405H
	DD	imagerel ast_for_funcdef
	DD	imagerel ast_for_funcdef+102
	DD	imagerel $unwind$ast_for_funcdef
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_funcdef DD 0a1801H
	DD	0f6418H
	DD	0e5418H
	DD	0d3418H
	DD	0e0147218H
	DD	07010d012H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_funcdef
_TEXT	SEGMENT
c$ = 96
n$ = 104
decorator_seq$ = 112
ast_for_funcdef PROC					; COMDAT

; 1487 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 55		 push	 r13
  00012	41 56		 push	 r14
  00014	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00018	48 8b f9	 mov	 rdi, rcx

; 1488 :     /* funcdef: 'def' NAME parameters ['->' test] ':' suite */
; 1489 :     identifier name;
; 1490 :     arguments_ty args;
; 1491 :     asdl_seq *body;
; 1492 :     expr_ty returns = NULL;
; 1493 :     int name_i = 1;
; 1494 : 
; 1495 :     REQ(n, funcdef);
; 1496 : 
; 1497 :     name = NEW_IDENTIFIER(CHILD(n, name_i));

  0001b	48 8b 4a 20	 mov	 rcx, QWORD PTR [rdx+32]
  0001f	48 8b da	 mov	 rbx, rdx
  00022	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00026	33 f6		 xor	 esi, esi
  00028	48 8b d7	 mov	 rdx, rdi
  0002b	4d 8b f0	 mov	 r14, r8
  0002e	8d 6e 01	 lea	 ebp, QWORD PTR [rsi+1]
  00031	e8 00 00 00 00	 call	 new_identifier
  00036	4c 8b e8	 mov	 r13, rax

; 1498 :     if (!name)

  00039	48 85 c0	 test	 rax, rax
  0003c	75 07		 jne	 SHORT $LN6@ast_for_fu
$LN11@ast_for_fu:

; 1499 :         return NULL;

  0003e	33 c0		 xor	 eax, eax
  00040	e9 b3 00 00 00	 jmp	 $LN7@ast_for_fu
$LN6@ast_for_fu:

; 1500 :     if (forbidden_name(c, name, CHILD(n, name_i), 0))

  00045	4c 8b 43 20	 mov	 r8, QWORD PTR [rbx+32]
  00049	45 33 c9	 xor	 r9d, r9d
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	49 83 c0 28	 add	 r8, 40			; 00000028H
  00053	48 8b cf	 mov	 rcx, rdi
  00056	e8 00 00 00 00	 call	 forbidden_name
  0005b	85 c0		 test	 eax, eax

; 1501 :         return NULL;

  0005d	75 df		 jne	 SHORT $LN11@ast_for_fu

; 1502 :     args = ast_for_arguments(c, CHILD(n, name_i + 1));

  0005f	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00063	48 8b cf	 mov	 rcx, rdi
  00066	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  0006b	48 83 c2 50	 add	 rdx, 80			; 00000050H
  0006f	e8 00 00 00 00	 call	 ast_for_arguments
  00074	4c 8b e0	 mov	 r12, rax

; 1503 :     if (!args)

  00077	48 85 c0	 test	 rax, rax

; 1504 :         return NULL;

  0007a	74 49		 je	 SHORT $LN10@ast_for_fu

; 1505 :     if (TYPE(CHILD(n, name_i+2)) == RARROW) {

  0007c	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00080	66 83 7a 78 32	 cmp	 WORD PTR [rdx+120], 50	; 00000032H
  00085	75 1c		 jne	 SHORT $LN3@ast_for_fu

; 1506 :         returns = ast_for_expr(c, CHILD(n, name_i + 3));

  00087	48 81 c2 a0 00
	00 00		 add	 rdx, 160		; 000000a0H
  0008e	48 8b cf	 mov	 rcx, rdi
  00091	e8 00 00 00 00	 call	 ast_for_expr
  00096	48 8b f0	 mov	 rsi, rax

; 1507 :         if (!returns)

  00099	48 85 c0	 test	 rax, rax

; 1508 :             return NULL;

  0009c	74 27		 je	 SHORT $LN10@ast_for_fu

; 1509 :         name_i += 2;

  0009e	bd 03 00 00 00	 mov	 ebp, 3
$LN3@ast_for_fu:

; 1510 :     }
; 1511 :     body = ast_for_suite(c, CHILD(n, name_i + 3));

  000a3	8d 45 03	 lea	 eax, DWORD PTR [rbp+3]
  000a6	48 63 c8	 movsxd	 rcx, eax
  000a9	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000ad	48 8d 14 89	 lea	 rdx, QWORD PTR [rcx+rcx*4]
  000b1	48 8b cf	 mov	 rcx, rdi
  000b4	48 8d 14 d0	 lea	 rdx, QWORD PTR [rax+rdx*8]
  000b8	e8 00 00 00 00	 call	 ast_for_suite
  000bd	4c 8b c0	 mov	 r8, rax

; 1512 :     if (!body)

  000c0	48 85 c0	 test	 rax, rax
  000c3	75 04		 jne	 SHORT $LN1@ast_for_fu
$LN10@ast_for_fu:

; 1513 :         return NULL;

  000c5	33 c0		 xor	 eax, eax
  000c7	eb 2a		 jmp	 SHORT $LN9@ast_for_fu
$LN1@ast_for_fu:

; 1514 : 
; 1515 :     return FunctionDef(name, args, body, decorator_seq, returns, LINENO(n),
; 1516 :                        n->n_col_offset, c->c_arena);

  000c9	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  000cd	4d 8b ce	 mov	 r9, r14
  000d0	49 8b d4	 mov	 rdx, r12
  000d3	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000d8	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  000db	49 8b cd	 mov	 rcx, r13
  000de	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000e2	8b 43 10	 mov	 eax, DWORD PTR [rbx+16]
  000e5	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000e9	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  000ee	e8 00 00 00 00	 call	 _Py_FunctionDef
$LN9@ast_for_fu:
  000f3	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]
$LN7@ast_for_fu:

; 1517 : }

  000f8	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  000fd	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00102	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00107	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0010b	41 5e		 pop	 r14
  0010d	41 5d		 pop	 r13
  0010f	5f		 pop	 rdi
  00110	c3		 ret	 0
ast_for_funcdef ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_decorated DD imagerel ast_for_decorated
	DD	imagerel ast_for_decorated+145
	DD	imagerel $unwind$ast_for_decorated
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_decorated DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ast_for_decorated
_TEXT	SEGMENT
c$ = 48
n$ = 56
ast_for_decorated PROC					; COMDAT

; 1521 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fa	 mov	 rdi, rdx

; 1522 :     /* decorated: decorators (classdef | funcdef) */
; 1523 :     stmt_ty thing = NULL;
; 1524 :     asdl_seq *decorator_seq = NULL;
; 1525 : 
; 1526 :     REQ(n, decorated);
; 1527 : 
; 1528 :     decorator_seq = ast_for_decorators(c, CHILD(n, 0));

  00012	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00016	48 8b f1	 mov	 rsi, rcx
  00019	33 db		 xor	 ebx, ebx
  0001b	e8 00 00 00 00	 call	 ast_for_decorators
  00020	4c 8b c0	 mov	 r8, rax

; 1529 :     if (!decorator_seq)

  00023	48 85 c0	 test	 rax, rax
  00026	75 10		 jne	 SHORT $LN5@ast_for_de@4

; 1545 :     }
; 1546 :     return thing;
; 1547 : }

  00028	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
$LN5@ast_for_de@4:

; 1530 :       return NULL;
; 1531 : 
; 1532 :     assert(TYPE(CHILD(n, 1)) == funcdef ||
; 1533 :            TYPE(CHILD(n, 1)) == classdef);
; 1534 : 
; 1535 :     if (TYPE(CHILD(n, 1)) == funcdef) {

  00038	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0003c	b9 06 01 00 00	 mov	 ecx, 262		; 00000106H
  00041	48 8d 50 28	 lea	 rdx, QWORD PTR [rax+40]
  00045	0f b7 40 28	 movzx	 eax, WORD PTR [rax+40]
  00049	66 3b c1	 cmp	 ax, cx
  0004c	75 0a		 jne	 SHORT $LN4@ast_for_de@4

; 1536 :       thing = ast_for_funcdef(c, CHILD(n, 1), decorator_seq);

  0004e	48 8b ce	 mov	 rcx, rsi
  00051	e8 00 00 00 00	 call	 ast_for_funcdef
  00056	eb 12		 jmp	 SHORT $LN8@ast_for_de@4
$LN4@ast_for_de@4:

; 1537 :     } else if (TYPE(CHILD(n, 1)) == classdef) {

  00058	b9 49 01 00 00	 mov	 ecx, 329		; 00000149H
  0005d	66 3b c1	 cmp	 ax, cx
  00060	75 1c		 jne	 SHORT $LN1@ast_for_de@4

; 1538 :       thing = ast_for_classdef(c, CHILD(n, 1), decorator_seq);

  00062	48 8b ce	 mov	 rcx, rsi
  00065	e8 00 00 00 00	 call	 ast_for_classdef
$LN8@ast_for_de@4:
  0006a	48 8b d8	 mov	 rbx, rax

; 1539 :     }
; 1540 :     /* we count the decorators in when talking about the class' or
; 1541 :      * function's line number */
; 1542 :     if (thing) {

  0006d	48 85 c0	 test	 rax, rax
  00070	74 0c		 je	 SHORT $LN1@ast_for_de@4

; 1543 :         thing->lineno = LINENO(n);

  00072	8b 47 10	 mov	 eax, DWORD PTR [rdi+16]
  00075	89 43 40	 mov	 DWORD PTR [rbx+64], eax

; 1544 :         thing->col_offset = n->n_col_offset;

  00078	8b 47 14	 mov	 eax, DWORD PTR [rdi+20]
  0007b	89 43 44	 mov	 DWORD PTR [rbx+68], eax
$LN1@ast_for_de@4:

; 1545 :     }
; 1546 :     return thing;
; 1547 : }

  0007e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00083	48 8b c3	 mov	 rax, rbx
  00086	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008f	5f		 pop	 rdi
  00090	c3		 ret	 0
ast_for_decorated ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@HBPFDBNP@unhandled?5small_stmt?3?5TYPE?$DN?$CFd?5NC@ ; `string'
EXTRN	_Py_Pass:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_stmt DD imagerel ast_for_stmt
	DD	imagerel ast_for_stmt+641
	DD	imagerel $unwind$ast_for_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_stmt DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CG@HBPFDBNP@unhandled?5small_stmt?3?5TYPE?$DN?$CFd?5NC@
CONST	SEGMENT
??_C@_0CG@HBPFDBNP@unhandled?5small_stmt?3?5TYPE?$DN?$CFd?5NC@ DB 'unhand'
	DB	'led small_stmt: TYPE=%d NCH=%d', 0aH, 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ast_for_stmt
_TEXT	SEGMENT
c$ = 48
n$ = 56
ast_for_stmt PROC					; COMDAT

; 3551 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3552 :     if (TYPE(n) == stmt) {

  00004	b8 0c 01 00 00	 mov	 eax, 268		; 0000010cH
  00009	4c 8b c9	 mov	 r9, rcx
  0000c	66 39 02	 cmp	 WORD PTR [rdx], ax
  0000f	75 04		 jne	 SHORT $LN26@ast_for_st@2

; 3553 :         assert(NCH(n) == 1);
; 3554 :         n = CHILD(n, 0);

  00011	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
$LN26@ast_for_st@2:

; 3555 :     }
; 3556 :     if (TYPE(n) == simple_stmt) {

  00015	b8 0d 01 00 00	 mov	 eax, 269		; 0000010dH
  0001a	66 39 02	 cmp	 WORD PTR [rdx], ax
  0001d	75 04		 jne	 SHORT $LN25@ast_for_st@2

; 3557 :         assert(num_stmts(n) == 1);
; 3558 :         n = CHILD(n, 0);

  0001f	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
$LN25@ast_for_st@2:

; 3559 :     }
; 3560 :     if (TYPE(n) == small_stmt) {

  00023	44 0f b7 02	 movzx	 r8d, WORD PTR [rdx]
  00027	b8 0e 01 00 00	 mov	 eax, 270		; 0000010eH
  0002c	66 44 3b c0	 cmp	 r8w, ax
  00030	0f 85 b3 00 00
	00		 jne	 $LN24@ast_for_st@2

; 3561 :         n = CHILD(n, 0);

  00036	48 8b 4a 20	 mov	 rcx, QWORD PTR [rdx+32]

; 3562 :         /* small_stmt: expr_stmt | del_stmt | pass_stmt | flow_stmt
; 3563 :                   | import_stmt | global_stmt | nonlocal_stmt | assert_stmt
; 3564 :         */
; 3565 :         switch (TYPE(n)) {

  0003a	44 0f bf 01	 movsx	 r8d, WORD PTR [rcx]
  0003e	41 8d 80 f1 fe
	ff ff		 lea	 eax, DWORD PTR [r8-271]
  00045	83 f8 15	 cmp	 eax, 21
  00048	0f 87 92 00 00
	00		 ja	 $LN13@ast_for_st@2
  0004e	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  00055	48 98		 cdqe
  00057	41 8b 84 83 00
	00 00 00	 mov	 eax, DWORD PTR $LN31@ast_for_st@2[r11+rax*4]
  0005f	49 03 c3	 add	 rax, r11
  00062	ff e0		 jmp	 rax
$LN21@ast_for_st@2:

; 3566 :             case expr_stmt:
; 3567 :                 return ast_for_expr_stmt(c, n);

  00064	48 8b d1	 mov	 rdx, rcx
  00067	49 8b c9	 mov	 rcx, r9

; 3617 :         }
; 3618 :     }
; 3619 : }

  0006a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006e	e9 00 00 00 00	 jmp	 ast_for_expr_stmt
$LN20@ast_for_st@2:

; 3568 :             case del_stmt:
; 3569 :                 return ast_for_del_stmt(c, n);

  00073	48 8b d1	 mov	 rdx, rcx
  00076	49 8b c9	 mov	 rcx, r9

; 3617 :         }
; 3618 :     }
; 3619 : }

  00079	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007d	e9 00 00 00 00	 jmp	 ast_for_del_stmt
$LN19@ast_for_st@2:

; 3570 :             case pass_stmt:
; 3571 :                 return Pass(LINENO(n), n->n_col_offset, c->c_arena);

  00082	8b 51 14	 mov	 edx, DWORD PTR [rcx+20]
  00085	4d 8b 41 08	 mov	 r8, QWORD PTR [r9+8]
  00089	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]

; 3617 :         }
; 3618 :     }
; 3619 : }

  0008c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00090	e9 00 00 00 00	 jmp	 _Py_Pass
$LN18@ast_for_st@2:

; 3572 :             case flow_stmt:
; 3573 :                 return ast_for_flow_stmt(c, n);

  00095	48 8b d1	 mov	 rdx, rcx
  00098	49 8b c9	 mov	 rcx, r9

; 3617 :         }
; 3618 :     }
; 3619 : }

  0009b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009f	e9 00 00 00 00	 jmp	 ast_for_flow_stmt
$LN17@ast_for_st@2:

; 3574 :             case import_stmt:
; 3575 :                 return ast_for_import_stmt(c, n);

  000a4	48 8b d1	 mov	 rdx, rcx
  000a7	49 8b c9	 mov	 rcx, r9

; 3617 :         }
; 3618 :     }
; 3619 : }

  000aa	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ae	e9 00 00 00 00	 jmp	 ast_for_import_stmt
$LN16@ast_for_st@2:

; 3576 :             case global_stmt:
; 3577 :                 return ast_for_global_stmt(c, n);

  000b3	48 8b d1	 mov	 rdx, rcx
  000b6	49 8b c9	 mov	 rcx, r9

; 3617 :         }
; 3618 :     }
; 3619 : }

  000b9	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000bd	e9 00 00 00 00	 jmp	 ast_for_global_stmt
$LN15@ast_for_st@2:

; 3578 :             case nonlocal_stmt:
; 3579 :                 return ast_for_nonlocal_stmt(c, n);

  000c2	48 8b d1	 mov	 rdx, rcx
  000c5	49 8b c9	 mov	 rcx, r9

; 3617 :         }
; 3618 :     }
; 3619 : }

  000c8	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000cc	e9 00 00 00 00	 jmp	 ast_for_nonlocal_stmt
$LN14@ast_for_st@2:

; 3580 :             case assert_stmt:
; 3581 :                 return ast_for_assert_stmt(c, n);

  000d1	48 8b d1	 mov	 rdx, rcx
  000d4	49 8b c9	 mov	 rcx, r9

; 3617 :         }
; 3618 :     }
; 3619 : }

  000d7	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000db	e9 00 00 00 00	 jmp	 ast_for_assert_stmt
$LN13@ast_for_st@2:

; 3582 :             default:
; 3583 :                 PyErr_Format(PyExc_SystemError,
; 3584 :                              "unhandled small_stmt: TYPE=%d NCH=%d\n",
; 3585 :                              TYPE(n), NCH(n));

  000e0	44 8b 49 18	 mov	 r9d, DWORD PTR [rcx+24]

; 3586 :                 return NULL;

  000e4	e9 bb 00 00 00	 jmp	 $LN32@ast_for_st@2
$LN24@ast_for_st@2:

; 3587 :         }
; 3588 :     }
; 3589 :     else {
; 3590 :         /* compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt
; 3591 :                         | funcdef | classdef | decorated
; 3592 :         */
; 3593 :         node *ch = CHILD(n, 0);

  000e9	4c 8b 52 20	 mov	 r10, QWORD PTR [rdx+32]

; 3594 :         REQ(n, compound_stmt);
; 3595 :         switch (TYPE(ch)) {

  000ed	41 0f bf 02	 movsx	 eax, WORD PTR [r10]
  000f1	05 fb fe ff ff	 add	 eax, -261		; fffffffffffffefbH
  000f6	83 f8 44	 cmp	 eax, 68			; 00000044H
  000f9	0f 87 9d 00 00
	00		 ja	 $LN1@ast_for_st@2
  000ff	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  00106	48 98		 cdqe
  00108	41 0f b6 84 03
	00 00 00 00	 movzx	 eax, BYTE PTR $LN29@ast_for_st@2[r11+rax]
  00111	41 8b 8c 83 00
	00 00 00	 mov	 ecx, DWORD PTR $LN30@ast_for_st@2[r11+rax*4]
  00119	49 03 cb	 add	 rcx, r11
  0011c	ff e1		 jmp	 rcx
$LN9@ast_for_st@2:

; 3596 :             case if_stmt:
; 3597 :                 return ast_for_if_stmt(c, ch);

  0011e	49 8b d2	 mov	 rdx, r10
  00121	49 8b c9	 mov	 rcx, r9

; 3617 :         }
; 3618 :     }
; 3619 : }

  00124	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00128	e9 00 00 00 00	 jmp	 ast_for_if_stmt
$LN8@ast_for_st@2:

; 3598 :             case while_stmt:
; 3599 :                 return ast_for_while_stmt(c, ch);

  0012d	49 8b d2	 mov	 rdx, r10
  00130	49 8b c9	 mov	 rcx, r9

; 3617 :         }
; 3618 :     }
; 3619 : }

  00133	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00137	e9 00 00 00 00	 jmp	 ast_for_while_stmt
$LN7@ast_for_st@2:

; 3600 :             case for_stmt:
; 3601 :                 return ast_for_for_stmt(c, ch);

  0013c	49 8b d2	 mov	 rdx, r10
  0013f	49 8b c9	 mov	 rcx, r9

; 3617 :         }
; 3618 :     }
; 3619 : }

  00142	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00146	e9 00 00 00 00	 jmp	 ast_for_for_stmt
$LN6@ast_for_st@2:

; 3602 :             case try_stmt:
; 3603 :                 return ast_for_try_stmt(c, ch);

  0014b	49 8b d2	 mov	 rdx, r10
  0014e	49 8b c9	 mov	 rcx, r9

; 3617 :         }
; 3618 :     }
; 3619 : }

  00151	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00155	e9 00 00 00 00	 jmp	 ast_for_try_stmt
$LN5@ast_for_st@2:

; 3604 :             case with_stmt:
; 3605 :                 return ast_for_with_stmt(c, ch);

  0015a	49 8b d2	 mov	 rdx, r10
  0015d	49 8b c9	 mov	 rcx, r9

; 3617 :         }
; 3618 :     }
; 3619 : }

  00160	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00164	e9 00 00 00 00	 jmp	 ast_for_with_stmt
$LN4@ast_for_st@2:

; 3606 :             case funcdef:
; 3607 :                 return ast_for_funcdef(c, ch, NULL);

  00169	45 33 c0	 xor	 r8d, r8d
  0016c	49 8b d2	 mov	 rdx, r10
  0016f	49 8b c9	 mov	 rcx, r9

; 3617 :         }
; 3618 :     }
; 3619 : }

  00172	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00176	e9 00 00 00 00	 jmp	 ast_for_funcdef
$LN3@ast_for_st@2:

; 3608 :             case classdef:
; 3609 :                 return ast_for_classdef(c, ch, NULL);

  0017b	45 33 c0	 xor	 r8d, r8d
  0017e	49 8b d2	 mov	 rdx, r10
  00181	49 8b c9	 mov	 rcx, r9

; 3617 :         }
; 3618 :     }
; 3619 : }

  00184	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00188	e9 00 00 00 00	 jmp	 ast_for_classdef
$LN2@ast_for_st@2:

; 3610 :             case decorated:
; 3611 :                 return ast_for_decorated(c, ch);

  0018d	49 8b d2	 mov	 rdx, r10
  00190	49 8b c9	 mov	 rcx, r9

; 3617 :         }
; 3618 :     }
; 3619 : }

  00193	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00197	e9 00 00 00 00	 jmp	 ast_for_decorated
$LN1@ast_for_st@2:

; 3612 :             default:
; 3613 :                 PyErr_Format(PyExc_SystemError,
; 3614 :                              "unhandled small_stmt: TYPE=%d NCH=%d\n",
; 3615 :                              TYPE(n), NCH(n));

  0019c	44 8b 4a 18	 mov	 r9d, DWORD PTR [rdx+24]
  001a0	45 0f bf c0	 movsx	 r8d, r8w
$LN32@ast_for_st@2:
  001a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  001ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@HBPFDBNP@unhandled?5small_stmt?3?5TYPE?$DN?$CFd?5NC@
  001b2	e8 00 00 00 00	 call	 PyErr_Format

; 3616 :                 return NULL;

  001b7	33 c0		 xor	 eax, eax

; 3617 :         }
; 3618 :     }
; 3619 : }

  001b9	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001bd	c3		 ret	 0
  001be	66 90		 npad	 2
$LN31@ast_for_st@2:
  001c0	00 00 00 00	 DD	 $LN21@ast_for_st@2
  001c4	00 00 00 00	 DD	 $LN13@ast_for_st@2
  001c8	00 00 00 00	 DD	 $LN13@ast_for_st@2
  001cc	00 00 00 00	 DD	 $LN20@ast_for_st@2
  001d0	00 00 00 00	 DD	 $LN19@ast_for_st@2
  001d4	00 00 00 00	 DD	 $LN18@ast_for_st@2
  001d8	00 00 00 00	 DD	 $LN13@ast_for_st@2
  001dc	00 00 00 00	 DD	 $LN13@ast_for_st@2
  001e0	00 00 00 00	 DD	 $LN13@ast_for_st@2
  001e4	00 00 00 00	 DD	 $LN13@ast_for_st@2
  001e8	00 00 00 00	 DD	 $LN13@ast_for_st@2
  001ec	00 00 00 00	 DD	 $LN17@ast_for_st@2
  001f0	00 00 00 00	 DD	 $LN13@ast_for_st@2
  001f4	00 00 00 00	 DD	 $LN13@ast_for_st@2
  001f8	00 00 00 00	 DD	 $LN13@ast_for_st@2
  001fc	00 00 00 00	 DD	 $LN13@ast_for_st@2
  00200	00 00 00 00	 DD	 $LN13@ast_for_st@2
  00204	00 00 00 00	 DD	 $LN13@ast_for_st@2
  00208	00 00 00 00	 DD	 $LN13@ast_for_st@2
  0020c	00 00 00 00	 DD	 $LN16@ast_for_st@2
  00210	00 00 00 00	 DD	 $LN15@ast_for_st@2
  00214	00 00 00 00	 DD	 $LN14@ast_for_st@2
$LN30@ast_for_st@2:
  00218	00 00 00 00	 DD	 $LN2@ast_for_st@2
  0021c	00 00 00 00	 DD	 $LN4@ast_for_st@2
  00220	00 00 00 00	 DD	 $LN9@ast_for_st@2
  00224	00 00 00 00	 DD	 $LN8@ast_for_st@2
  00228	00 00 00 00	 DD	 $LN7@ast_for_st@2
  0022c	00 00 00 00	 DD	 $LN6@ast_for_st@2
  00230	00 00 00 00	 DD	 $LN5@ast_for_st@2
  00234	00 00 00 00	 DD	 $LN3@ast_for_st@2
  00238	00 00 00 00	 DD	 $LN1@ast_for_st@2
$LN29@ast_for_st@2:
  0023c	00		 DB	 0
  0023d	01		 DB	 1
  0023e	08		 DB	 8
  0023f	08		 DB	 8
  00240	08		 DB	 8
  00241	08		 DB	 8
  00242	08		 DB	 8
  00243	08		 DB	 8
  00244	08		 DB	 8
  00245	08		 DB	 8
  00246	08		 DB	 8
  00247	08		 DB	 8
  00248	08		 DB	 8
  00249	08		 DB	 8
  0024a	08		 DB	 8
  0024b	08		 DB	 8
  0024c	08		 DB	 8
  0024d	08		 DB	 8
  0024e	08		 DB	 8
  0024f	08		 DB	 8
  00250	08		 DB	 8
  00251	08		 DB	 8
  00252	08		 DB	 8
  00253	08		 DB	 8
  00254	08		 DB	 8
  00255	08		 DB	 8
  00256	08		 DB	 8
  00257	08		 DB	 8
  00258	08		 DB	 8
  00259	08		 DB	 8
  0025a	08		 DB	 8
  0025b	08		 DB	 8
  0025c	08		 DB	 8
  0025d	02		 DB	 2
  0025e	03		 DB	 3
  0025f	04		 DB	 4
  00260	05		 DB	 5
  00261	06		 DB	 6
  00262	08		 DB	 8
  00263	08		 DB	 8
  00264	08		 DB	 8
  00265	08		 DB	 8
  00266	08		 DB	 8
  00267	08		 DB	 8
  00268	08		 DB	 8
  00269	08		 DB	 8
  0026a	08		 DB	 8
  0026b	08		 DB	 8
  0026c	08		 DB	 8
  0026d	08		 DB	 8
  0026e	08		 DB	 8
  0026f	08		 DB	 8
  00270	08		 DB	 8
  00271	08		 DB	 8
  00272	08		 DB	 8
  00273	08		 DB	 8
  00274	08		 DB	 8
  00275	08		 DB	 8
  00276	08		 DB	 8
  00277	08		 DB	 8
  00278	08		 DB	 8
  00279	08		 DB	 8
  0027a	08		 DB	 8
  0027b	08		 DB	 8
  0027c	08		 DB	 8
  0027d	08		 DB	 8
  0027e	08		 DB	 8
  0027f	08		 DB	 8
  00280	07		 DB	 7
ast_for_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@NFODNNNO@invalid?5node?5?$CFd?5for?5PyAST_FromNo@ ; `string'
PUBLIC	PyAST_FromNode
EXTRN	_Py_Interactive:PROC
EXTRN	_Py_Module:PROC
EXTRN	_Py_Expression:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyAST_FromNode DD imagerel $LN61
	DD	imagerel $LN61+15
	DD	imagerel $unwind$PyAST_FromNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$PyAST_FromNode DD imagerel $LN61+15
	DD	imagerel $LN61+885
	DD	imagerel $chain$6$PyAST_FromNode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$PyAST_FromNode DD imagerel $LN61+885
	DD	imagerel $LN61+925
	DD	imagerel $chain$7$PyAST_FromNode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$PyAST_FromNode DD 021H
	DD	imagerel $LN61
	DD	imagerel $LN61+15
	DD	imagerel $unwind$PyAST_FromNode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$PyAST_FromNode DD 0e9921H
	DD	0f7499H
	DD	0106491H
	DD	0115489H
	DD	0bf410H
	DD	0ce40cH
	DD	0dd408H
	DD	0ec404H
	DD	imagerel $LN61
	DD	imagerel $LN61+15
	DD	imagerel $unwind$PyAST_FromNode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyAST_FromNode DD 030f01H
	DD	012010fH
	DD	03008H
xdata	ENDS
;	COMDAT ??_C@_0CD@NFODNNNO@invalid?5node?5?$CFd?5for?5PyAST_FromNo@
CONST	SEGMENT
??_C@_0CD@NFODNNNO@invalid?5node?5?$CFd?5for?5PyAST_FromNo@ DB 'invalid n'
	DB	'ode %d for PyAST_FromNode', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyAST_FromNode
_TEXT	SEGMENT
ch$2$ = 32
c$ = 40
i$1$ = 160
n$ = 160
res$1$ = 168
flags$ = 168
stmts$1$ = 176
filename$ = 176
arena$ = 184
PyAST_FromNode PROC					; COMDAT

; 682  : {

$LN61:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	4d 89 4b 20	 mov	 QWORD PTR [r11+32], r9
  00007	53		 push	 rbx
  00008	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000f	4d 89 63 d8	 mov	 QWORD PTR [r11-40], r12
  00013	4d 89 6b d0	 mov	 QWORD PTR [r11-48], r13
  00017	4d 89 73 c8	 mov	 QWORD PTR [r11-56], r14
  0001b	4d 89 7b c0	 mov	 QWORD PTR [r11-64], r15

; 683  :     int i, j, k, num;
; 684  :     asdl_seq *stmts = NULL;
; 685  :     stmt_ty s;
; 686  :     node *ch;
; 687  :     struct compiling c;
; 688  :     mod_ty res = NULL;

  0001f	45 33 ff	 xor	 r15d, r15d
  00022	4d 8b f1	 mov	 r14, r9
  00025	41 8b df	 mov	 ebx, r15d
  00028	4c 8b e9	 mov	 r13, rcx

; 689  : 
; 690  :     c.c_arena = arena;

  0002b	4d 89 4b 98	 mov	 QWORD PTR [r11-104], r9

; 691  :     c.c_filename = filename;

  0002f	4d 89 43 a0	 mov	 QWORD PTR [r11-96], r8

; 692  :     c.c_normalize = c.c_normalize_args = NULL;

  00033	4d 89 7b b0	 mov	 QWORD PTR [r11-80], r15
  00037	4d 89 7b a8	 mov	 QWORD PTR [r11-88], r15
  0003b	48 89 9c 24 a8
	00 00 00	 mov	 QWORD PTR res$1$[rsp], rbx

; 693  :     if (flags && flags->cf_flags & PyCF_SOURCE_IS_UTF8) {

  00043	48 85 d2	 test	 rdx, rdx
  00046	74 23		 je	 SHORT $LN38@PyAST_From
  00048	f7 02 00 01 00
	00		 test	 DWORD PTR [rdx], 256	; 00000100H
  0004e	74 1b		 je	 SHORT $LN38@PyAST_From

; 694  :         c.c_encoding = "utf-8";

  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  00057	49 89 43 90	 mov	 QWORD PTR [r11-112], rax

; 695  :         if (TYPE(n) == encoding_decl) {

  0005b	b8 4f 01 00 00	 mov	 eax, 335		; 0000014fH
  00060	66 39 01	 cmp	 WORD PTR [rcx], ax
  00063	75 26		 jne	 SHORT $LN34@PyAST_From

; 696  : #if 0
; 697  :             ast_error(c, n, "encoding declaration in Unicode string");
; 698  :             goto out;
; 699  : #endif
; 700  :             n = CHILD(n, 0);

  00065	4c 8b 69 20	 mov	 r13, QWORD PTR [rcx+32]

; 701  :         }

  00069	eb 20		 jmp	 SHORT $LN34@PyAST_From
$LN38@PyAST_From:

; 702  :     } else if (TYPE(n) == encoding_decl) {

  0006b	b8 4f 01 00 00	 mov	 eax, 335		; 0000014fH
  00070	66 39 01	 cmp	 WORD PTR [rcx], ax
  00073	75 0a		 jne	 SHORT $LN35@PyAST_From

; 703  :         c.c_encoding = STR(n);

  00075	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 704  :         n = CHILD(n, 0);

  00079	4c 8b 69 20	 mov	 r13, QWORD PTR [rcx+32]

; 705  :     } else {

  0007d	eb 07		 jmp	 SHORT $LN59@PyAST_From
$LN35@PyAST_From:

; 706  :         /* PEP 3120 */
; 707  :         c.c_encoding = "utf-8";

  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
$LN59@PyAST_From:
  00086	48 89 44 24 28	 mov	 QWORD PTR c$[rsp], rax
$LN34@PyAST_From:

; 708  :     }
; 709  : 
; 710  :     k = 0;
; 711  :     switch (TYPE(n)) {

  0008b	45 0f bf 45 00	 movsx	 r8d, WORD PTR [r13]
  00090	48 89 ac 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbp
  00098	48 89 b4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rsi
  000a0	41 8b c8	 mov	 ecx, r8d
  000a3	48 89 7c 24 78	 mov	 QWORD PTR [rsp+120], rdi
  000a8	45 8b e7	 mov	 r12d, r15d
  000ab	81 e9 00 01 00
	00		 sub	 ecx, 256		; 00000100H
  000b1	0f 84 7c 01 00
	00		 je	 $LN16@PyAST_From
  000b7	ff c9		 dec	 ecx
  000b9	74 46		 je	 SHORT $LN31@PyAST_From
  000bb	ff c9		 dec	 ecx
  000bd	74 18		 je	 SHORT $LN18@PyAST_From

; 788  :             }
; 789  :             break;
; 790  :         default:
; 791  :             PyErr_Format(PyExc_SystemError,
; 792  :                          "invalid node %d for PyAST_FromNode", TYPE(n));

  000bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@NFODNNNO@invalid?5node?5?$CFd?5for?5PyAST_FromNo@
  000cd	e8 00 00 00 00	 call	 PyErr_Format

; 793  :             goto out;

  000d2	e9 6b 02 00 00	 jmp	 $out$22248
$LN18@PyAST_From:

; 741  :         case eval_input: {
; 742  :             expr_ty testlist_ast;
; 743  : 
; 744  :             /* XXX Why not comp_for here? */
; 745  :             testlist_ast = ast_for_testlist(&c, CHILD(n, 0));

  000d7	49 8b 55 20	 mov	 rdx, QWORD PTR [r13+32]
  000db	48 8d 4c 24 28	 lea	 rcx, QWORD PTR c$[rsp]
  000e0	e8 00 00 00 00	 call	 ast_for_testlist

; 746  :             if (!testlist_ast)

  000e5	48 85 c0	 test	 rax, rax
  000e8	0f 84 54 02 00
	00		 je	 $out$22248

; 747  :                 goto out;
; 748  :             res = Expression(testlist_ast, arena);

  000ee	49 8b d6	 mov	 rdx, r14
  000f1	48 8b c8	 mov	 rcx, rax
  000f4	e8 00 00 00 00	 call	 _Py_Expression
  000f9	48 8b d8	 mov	 rbx, rax

; 749  :             break;

  000fc	e9 41 02 00 00	 jmp	 $out$22248
$LN31@PyAST_From:

; 712  :         case file_input:
; 713  :             stmts = asdl_seq_new(num_stmts(n), arena);

  00101	49 8b cd	 mov	 rcx, r13
  00104	e8 00 00 00 00	 call	 num_stmts
  00109	49 8b d6	 mov	 rdx, r14
  0010c	48 63 c8	 movsxd	 rcx, eax
  0010f	e8 00 00 00 00	 call	 asdl_seq_new
  00114	48 8b e8	 mov	 rbp, rax
  00117	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR stmts$1$[rsp], rax

; 714  :             if (!stmts)

  0011f	48 85 c0	 test	 rax, rax
  00122	0f 84 1a 02 00
	00		 je	 $out$22248

; 715  :                 goto out;
; 716  :             for (i = 0; i < NCH(n) - 1; i++) {

  00128	41 8b 4d 18	 mov	 ecx, DWORD PTR [r13+24]
  0012c	41 8b f7	 mov	 esi, r15d
  0012f	44 89 bc 24 a0
	00 00 00	 mov	 DWORD PTR i$1$[rsp], r15d
  00137	ff c9		 dec	 ecx
  00139	85 c9		 test	 ecx, ecx
  0013b	0f 8e df 00 00
	00		 jle	 $LN27@PyAST_From
$LL29@PyAST_From:

; 717  :                 ch = CHILD(n, i);

  00141	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]

; 718  :                 if (TYPE(ch) == NEWLINE)

  00145	66 41 83 3c 07
	04		 cmp	 WORD PTR [r15+rax], 4
  0014b	49 8d 3c 07	 lea	 rdi, QWORD PTR [r15+rax]
  0014f	0f 84 a8 00 00
	00		 je	 $LN28@PyAST_From

; 719  :                     continue;
; 720  :                 REQ(ch, stmt);
; 721  :                 num = num_stmts(ch);

  00155	48 8b cf	 mov	 rcx, rdi
  00158	e8 00 00 00 00	 call	 num_stmts
  0015d	44 8b f0	 mov	 r14d, eax

; 722  :                 if (num == 1) {

  00160	83 f8 01	 cmp	 eax, 1
  00163	75 26		 jne	 SHORT $LN25@PyAST_From

; 723  :                     s = ast_for_stmt(&c, ch);

  00165	48 8d 4c 24 28	 lea	 rcx, QWORD PTR c$[rsp]
  0016a	48 8b d7	 mov	 rdx, rdi
  0016d	e8 00 00 00 00	 call	 ast_for_stmt

; 724  :                     if (!s)

  00172	48 85 c0	 test	 rax, rax
  00175	0f 84 ba 01 00
	00		 je	 $LN53@PyAST_From

; 725  :                         goto out;
; 726  :                     asdl_seq_SET(stmts, k++, s);

  0017b	48 89 44 dd 08	 mov	 QWORD PTR [rbp+rbx*8+8], rax
  00180	41 ff c4	 inc	 r12d
  00183	48 ff c3	 inc	 rbx

; 727  :                 }
; 728  :                 else {

  00186	e9 72 00 00 00	 jmp	 $LN28@PyAST_From
$LN25@PyAST_From:

; 729  :                     ch = CHILD(ch, 0);

  0018b	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]

; 730  :                     REQ(ch, simple_stmt);
; 731  :                     for (j = 0; j < num; j++) {

  0018f	33 ff		 xor	 edi, edi
  00191	48 89 54 24 20	 mov	 QWORD PTR ch$2$[rsp], rdx
  00196	85 c0		 test	 eax, eax
  00198	7e 63		 jle	 SHORT $LN28@PyAST_From

; 729  :                     ch = CHILD(ch, 0);

  0019a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR stmts$1$[rsp]
  001a2	33 ed		 xor	 ebp, ebp
  001a4	48 8d 74 d8 08	 lea	 rsi, QWORD PTR [rax+rbx*8+8]
  001a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL22@PyAST_From:

; 732  :                         s = ast_for_stmt(&c, CHILD(ch, j * 2));

  001b0	48 63 c5	 movsxd	 rax, ebp
  001b3	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  001b7	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  001bb	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  001bf	48 8d 4c 24 28	 lea	 rcx, QWORD PTR c$[rsp]
  001c4	e8 00 00 00 00	 call	 ast_for_stmt

; 733  :                         if (!s)

  001c9	48 85 c0	 test	 rax, rax
  001cc	0f 84 63 01 00
	00		 je	 $LN53@PyAST_From

; 730  :                     REQ(ch, simple_stmt);
; 731  :                     for (j = 0; j < num; j++) {

  001d2	48 8b 54 24 20	 mov	 rdx, QWORD PTR ch$2$[rsp]
  001d7	ff c7		 inc	 edi

; 734  :                             goto out;
; 735  :                         asdl_seq_SET(stmts, k++, s);

  001d9	48 89 06	 mov	 QWORD PTR [rsi], rax
  001dc	41 ff c4	 inc	 r12d
  001df	48 ff c3	 inc	 rbx
  001e2	48 83 c6 08	 add	 rsi, 8
  001e6	83 c5 02	 add	 ebp, 2
  001e9	41 3b fe	 cmp	 edi, r14d
  001ec	7c c2		 jl	 SHORT $LL22@PyAST_From
  001ee	8b b4 24 a0 00
	00 00		 mov	 esi, DWORD PTR i$1$[rsp]
  001f5	48 8b ac 24 b0
	00 00 00	 mov	 rbp, QWORD PTR stmts$1$[rsp]
$LN28@PyAST_From:

; 715  :                 goto out;
; 716  :             for (i = 0; i < NCH(n) - 1; i++) {

  001fd	41 8b 45 18	 mov	 eax, DWORD PTR [r13+24]
  00201	ff c6		 inc	 esi
  00203	49 83 c7 28	 add	 r15, 40			; 00000028H
  00207	ff c8		 dec	 eax
  00209	89 b4 24 a0 00
	00 00		 mov	 DWORD PTR i$1$[rsp], esi
  00210	3b f0		 cmp	 esi, eax
  00212	0f 8c 29 ff ff
	ff		 jl	 $LL29@PyAST_From
  00218	4c 8b b4 24 b8
	00 00 00	 mov	 r14, QWORD PTR arena$[rsp]
$LN27@PyAST_From:

; 736  :                     }
; 737  :                 }
; 738  :             }
; 739  :             res = Module(stmts, arena);

  00220	49 8b d6	 mov	 rdx, r14
  00223	48 8b cd	 mov	 rcx, rbp
  00226	e8 00 00 00 00	 call	 _Py_Module
  0022b	48 8b d8	 mov	 rbx, rax

; 740  :             break;

  0022e	e9 0f 01 00 00	 jmp	 $out$22248
$LN16@PyAST_From:

; 750  :         }
; 751  :         case single_input:
; 752  :             if (TYPE(CHILD(n, 0)) == NEWLINE) {

  00233	49 8b 7d 20	 mov	 rdi, QWORD PTR [r13+32]
  00237	66 83 3f 04	 cmp	 WORD PTR [rdi], 4
  0023b	75 49		 jne	 SHORT $LN15@PyAST_From

; 753  :                 stmts = asdl_seq_new(1, arena);

  0023d	49 8b d1	 mov	 rdx, r9
  00240	b9 01 00 00 00	 mov	 ecx, 1
  00245	e8 00 00 00 00	 call	 asdl_seq_new
  0024a	48 8b d8	 mov	 rbx, rax

; 754  :                 if (!stmts)

  0024d	48 85 c0	 test	 rax, rax
  00250	0f 84 e9 00 00
	00		 je	 $LN58@PyAST_From

; 755  :                     goto out;
; 756  :                 asdl_seq_SET(stmts, 0, Pass(n->n_lineno, n->n_col_offset,
; 757  :                                             arena));

  00256	41 8b 55 14	 mov	 edx, DWORD PTR [r13+20]
  0025a	41 8b 4d 10	 mov	 ecx, DWORD PTR [r13+16]
  0025e	4d 8b c6	 mov	 r8, r14
  00261	e8 00 00 00 00	 call	 _Py_Pass
  00266	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 758  :                 if (!asdl_seq_GET(stmts, 0))

  0026a	48 85 c0	 test	 rax, rax
  0026d	0f 84 cc 00 00
	00		 je	 $LN58@PyAST_From

; 759  :                     goto out;
; 760  :                 res = Interactive(stmts, arena);

  00273	49 8b d6	 mov	 rdx, r14
  00276	48 8b cb	 mov	 rcx, rbx
  00279	e8 00 00 00 00	 call	 _Py_Interactive
  0027e	48 8b d8	 mov	 rbx, rax

; 761  :             }
; 762  :             else {

  00281	e9 bc 00 00 00	 jmp	 $out$22248
$LN15@PyAST_From:

; 763  :                 n = CHILD(n, 0);
; 764  :                 num = num_stmts(n);

  00286	48 8b cf	 mov	 rcx, rdi
  00289	e8 00 00 00 00	 call	 num_stmts

; 765  :                 stmts = asdl_seq_new(num, arena);

  0028e	49 8b d6	 mov	 rdx, r14
  00291	48 63 d8	 movsxd	 rbx, eax
  00294	48 8b cb	 mov	 rcx, rbx
  00297	e8 00 00 00 00	 call	 asdl_seq_new
  0029c	48 8b e8	 mov	 rbp, rax

; 766  :                 if (!stmts)

  0029f	48 85 c0	 test	 rax, rax
  002a2	0f 84 97 00 00
	00		 je	 $LN58@PyAST_From

; 767  :                     goto out;
; 768  :                 if (num == 1) {

  002a8	83 fb 01	 cmp	 ebx, 1
  002ab	75 2a		 jne	 SHORT $LN10@PyAST_From

; 769  :                     s = ast_for_stmt(&c, n);

  002ad	48 8d 4c 24 28	 lea	 rcx, QWORD PTR c$[rsp]
  002b2	48 8b d7	 mov	 rdx, rdi
  002b5	e8 00 00 00 00	 call	 ast_for_stmt

; 770  :                     if (!s)

  002ba	48 85 c0	 test	 rax, rax
  002bd	0f 84 7c 00 00
	00		 je	 $LN58@PyAST_From

; 784  :                     }
; 785  :                 }
; 786  : 
; 787  :                 res = Interactive(stmts, arena);

  002c3	49 8b d6	 mov	 rdx, r14
  002c6	48 8b cd	 mov	 rcx, rbp
  002c9	48 89 45 08	 mov	 QWORD PTR [rbp+8], rax
  002cd	e8 00 00 00 00	 call	 _Py_Interactive
  002d2	48 8b d8	 mov	 rbx, rax
  002d5	eb 6b		 jmp	 SHORT $out$22248
$LN10@PyAST_From:

; 771  :                         goto out;
; 772  :                     asdl_seq_SET(stmts, 0, s);
; 773  :                 }
; 774  :                 else {
; 775  :                     /* Only a simple_stmt can contain multiple statements. */
; 776  :                     REQ(n, simple_stmt);
; 777  :                     for (i = 0; i < NCH(n); i += 2) {

  002d7	41 8b df	 mov	 ebx, r15d
  002da	39 5f 18	 cmp	 DWORD PTR [rdi+24], ebx
  002dd	7e 46		 jle	 SHORT $LN5@PyAST_From
  002df	49 8b f7	 mov	 rsi, r15
$LL7@PyAST_From:

; 778  :                         if (TYPE(CHILD(n, i)) == NEWLINE)

  002e2	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  002e6	66 83 3c 16 04	 cmp	 WORD PTR [rsi+rdx], 4
  002eb	74 38		 je	 SHORT $LN5@PyAST_From

; 779  :                             break;
; 780  :                         s = ast_for_stmt(&c, CHILD(n, i));

  002ed	48 63 c3	 movsxd	 rax, ebx
  002f0	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  002f4	48 8d 14 ca	 lea	 rdx, QWORD PTR [rdx+rcx*8]
  002f8	48 8d 4c 24 28	 lea	 rcx, QWORD PTR c$[rsp]
  002fd	e8 00 00 00 00	 call	 ast_for_stmt
  00302	4c 8b d8	 mov	 r11, rax

; 781  :                         if (!s)

  00305	48 85 c0	 test	 rax, rax
  00308	74 35		 je	 SHORT $LN58@PyAST_From

; 782  :                             goto out;
; 783  :                         asdl_seq_SET(stmts, i / 2, s);

  0030a	8b c3		 mov	 eax, ebx
  0030c	83 c3 02	 add	 ebx, 2
  0030f	48 83 c6 50	 add	 rsi, 80			; 00000050H
  00313	99		 cdq
  00314	2b c2		 sub	 eax, edx
  00316	d1 f8		 sar	 eax, 1
  00318	48 63 c8	 movsxd	 rcx, eax
  0031b	4c 89 5c cd 08	 mov	 QWORD PTR [rbp+rcx*8+8], r11
  00320	3b 5f 18	 cmp	 ebx, DWORD PTR [rdi+24]
  00323	7c bd		 jl	 SHORT $LL7@PyAST_From
$LN5@PyAST_From:

; 784  :                     }
; 785  :                 }
; 786  : 
; 787  :                 res = Interactive(stmts, arena);

  00325	49 8b d6	 mov	 rdx, r14
  00328	48 8b cd	 mov	 rcx, rbp
  0032b	e8 00 00 00 00	 call	 _Py_Interactive
  00330	48 8b d8	 mov	 rbx, rax
  00333	eb 0d		 jmp	 SHORT $out$22248
$LN53@PyAST_From:

; 683  :     int i, j, k, num;
; 684  :     asdl_seq *stmts = NULL;
; 685  :     stmt_ty s;
; 686  :     node *ch;
; 687  :     struct compiling c;
; 688  :     mod_ty res = NULL;

  00335	48 8b 9c 24 a8
	00 00 00	 mov	 rbx, QWORD PTR res$1$[rsp]
  0033d	eb 03		 jmp	 SHORT $out$22248
$LN58@PyAST_From:
  0033f	49 8b dc	 mov	 rbx, r12
$out$22248:

; 794  :     }
; 795  :  out:
; 796  :     if (c.c_normalize) {

  00342	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp+24]
  00347	4c 8b 7c 24 58	 mov	 r15, QWORD PTR [rsp+88]
  0034c	4c 8b 74 24 60	 mov	 r14, QWORD PTR [rsp+96]
  00351	4c 8b 6c 24 68	 mov	 r13, QWORD PTR [rsp+104]
  00356	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]
  0035b	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]
  00360	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  00368	48 8b ac 24 88
	00 00 00	 mov	 rbp, QWORD PTR [rsp+136]
  00370	48 85 c9	 test	 rcx, rcx
  00373	74 1c		 je	 SHORT $LN51@PyAST_From

; 797  :         Py_DECREF(c.c_normalize);

  00375	e8 00 00 00 00	 call	 _Py_DecRef

; 798  :         PyTuple_SET_ITEM(c.c_normalize_args, 1, NULL);

  0037a	4c 8b 5c 24 48	 mov	 r11, QWORD PTR c$[rsp+32]
  0037f	49 c7 43 78 00
	00 00 00	 mov	 QWORD PTR [r11+120], 0

; 799  :         Py_DECREF(c.c_normalize_args);

  00387	48 8b 4c 24 48	 mov	 rcx, QWORD PTR c$[rsp+32]
  0038c	e8 00 00 00 00	 call	 _Py_DecRef
$LN51@PyAST_From:

; 800  :     }
; 801  :     return res;

  00391	48 8b c3	 mov	 rax, rbx

; 802  : }

  00394	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  0039b	5b		 pop	 rbx
  0039c	c3		 ret	 0
PyAST_FromNode ENDP
_TEXT	ENDS
END
