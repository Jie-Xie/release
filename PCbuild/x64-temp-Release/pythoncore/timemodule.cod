; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@IHBBIOOL@get_clock_info?$AA@		; `string'
PUBLIC	??_C@_0N@MEONCEDN@perf_counter?$AA@		; `string'
PUBLIC	??_C@_0N@HNHIBMAE@process_time?$AA@		; `string'
PUBLIC	??_C@_09FKNHDPAJ@monotonic?$AA@			; `string'
PUBLIC	??_C@_08JKOOHOPP@strptime?$AA@			; `string'
PUBLIC	??_C@_08EPGBJPHJ@strftime?$AA@			; `string'
PUBLIC	??_C@_06PIDIMLCK@mktime?$AA@			; `string'
PUBLIC	??_C@_05NCKEBKLP@ctime?$AA@			; `string'
PUBLIC	??_C@_07MHIFAOOG@asctime?$AA@			; `string'
PUBLIC	??_C@_09EKBOCLDN@localtime?$AA@			; `string'
PUBLIC	??_C@_06IKBBHHHJ@gmtime?$AA@			; `string'
PUBLIC	??_C@_05PCJCMMHD@sleep?$AA@			; `string'
PUBLIC	??_C@_05DDECJJKE@clock?$AA@			; `string'
PUBLIC	??_C@_04CLCEDBPF@time?$AA@			; `string'
PUBLIC	??_C@_0P@FKAOFBKD@_strptime_time?$AA@		; `string'
PUBLIC	??_C@_0BKB@DDEPIBMP@The?5time?5value?5as?5returned?5by?5gm@ ; `string'
PUBLIC	??_C@_0BB@MGIFIEFG@time?4struct_time?$AA@	; `string'
PUBLIC	??_C@_0DL@PJPOCPKM@1?5if?5summer?5time?5is?5in?5effect?0?50@ ; `string'
PUBLIC	??_C@_08BCODJLJO@tm_isdst?$AA@			; `string'
PUBLIC	??_C@_0BM@HBKLLDAH@day?5of?5year?0?5range?5?$FL1?0?5366?$FN?$AA@ ; `string'
PUBLIC	??_C@_07FCBAKJLJ@tm_yday?$AA@			; `string'
PUBLIC	??_C@_0CH@OJOJLICN@day?5of?5week?0?5range?5?$FL0?0?56?$FN?0?5Monda@ ; `string'
PUBLIC	??_C@_07ONCABHNI@tm_wday?$AA@			; `string'
PUBLIC	??_C@_0BI@BFAAEDLC@seconds?0?5range?5?$FL0?0?561?$FN?$CJ?$AA@ ; `string'
PUBLIC	??_C@_06NNLKOPK@tm_sec?$AA@			; `string'
PUBLIC	??_C@_0BH@BDJOIMKA@minutes?0?5range?5?$FL0?0?559?$FN?$AA@ ; `string'
PUBLIC	??_C@_06BKJAJHP@tm_min?$AA@			; `string'
PUBLIC	??_C@_0BF@JJPIOGPE@hours?0?5range?5?$FL0?0?523?$FN?$AA@ ; `string'
PUBLIC	??_C@_07CAEKECON@tm_hour?$AA@			; `string'
PUBLIC	??_C@_0BM@EKABLPKI@day?5of?5month?0?5range?5?$FL1?0?531?$FN?$AA@ ; `string'
PUBLIC	??_C@_07MHHAJIPL@tm_mday?$AA@			; `string'
PUBLIC	??_C@_0BN@NIJEHJGK@month?5of?5year?0?5range?5?$FL1?0?512?$FN?$AA@ ; `string'
PUBLIC	??_C@_06FCEHFMN@tm_mon?$AA@			; `string'
PUBLIC	??_C@_0BI@BLDDGDNH@year?0?5for?5example?0?51993?$AA@ ; `string'
PUBLIC	??_C@_07JFIBHBH@tm_year?$AA@			; `string'
_BSS	SEGMENT
?cpu_frequency@?1??win_perf_counter@@9@9 DQ 01H DUP (?)	; `win_perf_counter'::`2'::cpu_frequency
?GetTickCount64@?1??pymonotonic@@9@9 DQ 01H DUP (?)	; `pymonotonic'::`2'::GetTickCount64
?last_ticks@?5??pymonotonic@@9@9 DD 01H DUP (?)		; `pymonotonic'::`6'::last_ticks
?n_overflow@?5??pymonotonic@@9@9 DD 01H DUP (?)		; `pymonotonic'::`6'::n_overflow
_BSS	ENDS
;	COMDAT ??_C@_0P@IHBBIOOL@get_clock_info?$AA@
CONST	SEGMENT
??_C@_0P@IHBBIOOL@get_clock_info?$AA@ DB 'get_clock_info', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MEONCEDN@perf_counter?$AA@
CONST	SEGMENT
??_C@_0N@MEONCEDN@perf_counter?$AA@ DB 'perf_counter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HNHIBMAE@process_time?$AA@
CONST	SEGMENT
??_C@_0N@HNHIBMAE@process_time?$AA@ DB 'process_time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FKNHDPAJ@monotonic?$AA@
CONST	SEGMENT
??_C@_09FKNHDPAJ@monotonic?$AA@ DB 'monotonic', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JKOOHOPP@strptime?$AA@
CONST	SEGMENT
??_C@_08JKOOHOPP@strptime?$AA@ DB 'strptime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPGBJPHJ@strftime?$AA@
CONST	SEGMENT
??_C@_08EPGBJPHJ@strftime?$AA@ DB 'strftime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06PIDIMLCK@mktime?$AA@
CONST	SEGMENT
??_C@_06PIDIMLCK@mktime?$AA@ DB 'mktime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NCKEBKLP@ctime?$AA@
CONST	SEGMENT
??_C@_05NCKEBKLP@ctime?$AA@ DB 'ctime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHIFAOOG@asctime?$AA@
CONST	SEGMENT
??_C@_07MHIFAOOG@asctime?$AA@ DB 'asctime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EKBOCLDN@localtime?$AA@
CONST	SEGMENT
??_C@_09EKBOCLDN@localtime?$AA@ DB 'localtime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKBBHHHJ@gmtime?$AA@
CONST	SEGMENT
??_C@_06IKBBHHHJ@gmtime?$AA@ DB 'gmtime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PCJCMMHD@sleep?$AA@
CONST	SEGMENT
??_C@_05PCJCMMHD@sleep?$AA@ DB 'sleep', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DDECJJKE@clock?$AA@
CONST	SEGMENT
??_C@_05DDECJJKE@clock?$AA@ DB 'clock', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLCEDBPF@time?$AA@
CONST	SEGMENT
??_C@_04CLCEDBPF@time?$AA@ DB 'time', 00H		; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId__strptime_time@?1??time_strptime@@9@9 DQ 0000000000000000H ; `time_strptime'::`2'::PyId__strptime_time
	DQ	FLAT:??_C@_0P@FKAOFBKD@_strptime_time?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_0P@FKAOFBKD@_strptime_time?$AA@
CONST	SEGMENT
??_C@_0P@FKAOFBKD@_strptime_time?$AA@ DB '_strptime_time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BKB@DDEPIBMP@The?5time?5value?5as?5returned?5by?5gm@
CONST	SEGMENT
??_C@_0BKB@DDEPIBMP@The?5time?5value?5as?5returned?5by?5gm@ DB 'The time '
	DB	'value as returned by gmtime(), localtime(), and strptime(), a'
	DB	'nd', 0aH, ' accepted by asctime(), mktime() and strftime().  '
	DB	'May be considered as a', 0aH, ' sequence of 9 integers.', 0aH
	DB	0aH, ' Note that several fields'' values are not the same as t'
	DB	'hose defined by', 0aH, ' the C language standard for struct t'
	DB	'm.  For example, the value of the', 0aH, ' field tm_year is t'
	DB	'he actual year, not year - 1900.  See individual', 0aH, ' fie'
	DB	'lds'' descriptions for details.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MGIFIEFG@time?4struct_time?$AA@
CONST	SEGMENT
??_C@_0BB@MGIFIEFG@time?4struct_time?$AA@ DB 'time.struct_time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@PJPOCPKM@1?5if?5summer?5time?5is?5in?5effect?0?50@
CONST	SEGMENT
??_C@_0DL@PJPOCPKM@1?5if?5summer?5time?5is?5in?5effect?0?50@ DB '1 if sum'
	DB	'mer time is in effect, 0 if not, and -1 if unknown', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BCODJLJO@tm_isdst?$AA@
CONST	SEGMENT
??_C@_08BCODJLJO@tm_isdst?$AA@ DB 'tm_isdst', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HBKLLDAH@day?5of?5year?0?5range?5?$FL1?0?5366?$FN?$AA@
CONST	SEGMENT
??_C@_0BM@HBKLLDAH@day?5of?5year?0?5range?5?$FL1?0?5366?$FN?$AA@ DB 'day '
	DB	'of year, range [1, 366]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FCBAKJLJ@tm_yday?$AA@
CONST	SEGMENT
??_C@_07FCBAKJLJ@tm_yday?$AA@ DB 'tm_yday', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OJOJLICN@day?5of?5week?0?5range?5?$FL0?0?56?$FN?0?5Monda@
CONST	SEGMENT
??_C@_0CH@OJOJLICN@day?5of?5week?0?5range?5?$FL0?0?56?$FN?0?5Monda@ DB 'd'
	DB	'ay of week, range [0, 6], Monday is 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07ONCABHNI@tm_wday?$AA@
CONST	SEGMENT
??_C@_07ONCABHNI@tm_wday?$AA@ DB 'tm_wday', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BFAAEDLC@seconds?0?5range?5?$FL0?0?561?$FN?$CJ?$AA@
CONST	SEGMENT
??_C@_0BI@BFAAEDLC@seconds?0?5range?5?$FL0?0?561?$FN?$CJ?$AA@ DB 'seconds'
	DB	', range [0, 61])', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NNLKOPK@tm_sec?$AA@
CONST	SEGMENT
??_C@_06NNLKOPK@tm_sec?$AA@ DB 'tm_sec', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BDJOIMKA@minutes?0?5range?5?$FL0?0?559?$FN?$AA@
CONST	SEGMENT
??_C@_0BH@BDJOIMKA@minutes?0?5range?5?$FL0?0?559?$FN?$AA@ DB 'minutes, ra'
	DB	'nge [0, 59]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06BKJAJHP@tm_min?$AA@
CONST	SEGMENT
??_C@_06BKJAJHP@tm_min?$AA@ DB 'tm_min', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JJPIOGPE@hours?0?5range?5?$FL0?0?523?$FN?$AA@
CONST	SEGMENT
??_C@_0BF@JJPIOGPE@hours?0?5range?5?$FL0?0?523?$FN?$AA@ DB 'hours, range '
	DB	'[0, 23]', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07CAEKECON@tm_hour?$AA@
CONST	SEGMENT
??_C@_07CAEKECON@tm_hour?$AA@ DB 'tm_hour', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EKABLPKI@day?5of?5month?0?5range?5?$FL1?0?531?$FN?$AA@
CONST	SEGMENT
??_C@_0BM@EKABLPKI@day?5of?5month?0?5range?5?$FL1?0?531?$FN?$AA@ DB 'day '
	DB	'of month, range [1, 31]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHHAJIPL@tm_mday?$AA@
CONST	SEGMENT
??_C@_07MHHAJIPL@tm_mday?$AA@ DB 'tm_mday', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NIJEHJGK@month?5of?5year?0?5range?5?$FL1?0?512?$FN?$AA@
CONST	SEGMENT
??_C@_0BN@NIJEHJGK@month?5of?5year?0?5range?5?$FL1?0?512?$FN?$AA@ DB 'mon'
	DB	'th of year, range [1, 12]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FCEHFMN@tm_mon?$AA@
CONST	SEGMENT
??_C@_06FCEHFMN@tm_mon?$AA@ DB 'tm_mon', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BLDDGDNH@year?0?5for?5example?0?51993?$AA@
CONST	SEGMENT
??_C@_0BI@BLDDGDNH@year?0?5for?5example?0?51993?$AA@ DB 'year, for exampl'
	DB	'e, 1993', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07JFIBHBH@tm_year?$AA@
CONST	SEGMENT
??_C@_07JFIBHBH@tm_year?$AA@ DB 'tm_year', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
time_doc DB	'time() -> floating point number', 0aH, 0aH, 'Return the '
	DB	'current time in seconds since the Epoch.', 0aH, 'Fractions of'
	DB	' a second may be present if the system clock provides them.', 00H
	ORG $+3
clock_doc DB	'clock() -> floating point number', 0aH, 0aH, 'Return the'
	DB	' CPU time or real time since the start of the process or sinc'
	DB	'e', 0aH, 'the first call to clock().  This has as much precis'
	DB	'ion as the system', 0aH, 'records.', 00H
	ORG $+7
sleep_doc DB	'sleep(seconds)', 0aH, 0aH, 'Delay execution for a given '
	DB	'number of seconds.  The argument may be', 0aH, 'a floating po'
	DB	'int number for subsecond precision.', 00H
	ORG $+3
struct_time_type_desc DQ FLAT:??_C@_0BB@MGIFIEFG@time?4struct_time?$AA@
	DQ	FLAT:??_C@_0BKB@DDEPIBMP@The?5time?5value?5as?5returned?5by?5gm@
	DQ	FLAT:struct_time_type_fields
	DD	09H
	ORG $+4
?has_getickcount64@?1??pymonotonic@@9@9 DD 0ffffffffH	; `pymonotonic'::`2'::has_getickcount64
	ORG $+4
struct_time_type_fields DQ FLAT:??_C@_07JFIBHBH@tm_year?$AA@
	DQ	FLAT:??_C@_0BI@BLDDGDNH@year?0?5for?5example?0?51993?$AA@
	DQ	FLAT:??_C@_06FCEHFMN@tm_mon?$AA@
	DQ	FLAT:??_C@_0BN@NIJEHJGK@month?5of?5year?0?5range?5?$FL1?0?512?$FN?$AA@
	DQ	FLAT:??_C@_07MHHAJIPL@tm_mday?$AA@
	DQ	FLAT:??_C@_0BM@EKABLPKI@day?5of?5month?0?5range?5?$FL1?0?531?$FN?$AA@
	DQ	FLAT:??_C@_07CAEKECON@tm_hour?$AA@
	DQ	FLAT:??_C@_0BF@JJPIOGPE@hours?0?5range?5?$FL0?0?523?$FN?$AA@
	DQ	FLAT:??_C@_06BKJAJHP@tm_min?$AA@
	DQ	FLAT:??_C@_0BH@BDJOIMKA@minutes?0?5range?5?$FL0?0?559?$FN?$AA@
	DQ	FLAT:??_C@_06NNLKOPK@tm_sec?$AA@
	DQ	FLAT:??_C@_0BI@BFAAEDLC@seconds?0?5range?5?$FL0?0?561?$FN?$CJ?$AA@
	DQ	FLAT:??_C@_07ONCABHNI@tm_wday?$AA@
	DQ	FLAT:??_C@_0CH@OJOJLICN@day?5of?5week?0?5range?5?$FL0?0?56?$FN?0?5Monda@
	DQ	FLAT:??_C@_07FCBAKJLJ@tm_yday?$AA@
	DQ	FLAT:??_C@_0BM@HBKLLDAH@day?5of?5year?0?5range?5?$FL1?0?5366?$FN?$AA@
	DQ	FLAT:??_C@_08BCODJLJO@tm_isdst?$AA@
	DQ	FLAT:??_C@_0DL@PJPOCPKM@1?5if?5summer?5time?5is?5in?5effect?0?50@
	DQ	0000000000000000H
	ORG $+8
gmtime_doc DB	'gmtime([seconds]) -> (tm_year, tm_mon, tm_mday, tm_hour,'
	DB	' tm_min,', 0aH, '                       tm_sec, tm_wday, tm_y'
	DB	'day, tm_isdst)', 0aH, 0aH, 'Convert seconds since the Epoch t'
	DB	'o a time tuple expressing UTC (a.k.a.', 0aH, 'GMT).  When ''s'
	DB	'econds'' is not passed in, convert the current time instead.', 0aH
	DB	0aH, 'If the platform supports the tm_gmtoff and tm_zone, they'
	DB	' are available as', 0aH, 'attributes only.', 00H
	ORG $+6
localtime_doc DB 'localtime([seconds]) -> (tm_year,tm_mon,tm_mday,tm_hour'
	DB	',tm_min,', 0aH, '                          tm_sec,tm_wday,tm_'
	DB	'yday,tm_isdst)', 0aH, 0aH, 'Convert seconds since the Epoch t'
	DB	'o a time tuple expressing local time.', 0aH, 'When ''seconds'''
	DB	' is not passed in, convert the current time instead.', 00H
	ORG $+2
?mon_name@?1??_asctime@@9@9 DB 'Jan', 00H		; `_asctime'::`2'::mon_name
	DB	'Feb', 00H
	DB	'Mar', 00H
	DB	'Apr', 00H
	DB	'May', 00H
	DB	'Jun', 00H
	DB	'Jul', 00H
	DB	'Aug', 00H
	DB	'Sep', 00H
	DB	'Oct', 00H
	DB	'Nov', 00H
	DB	'Dec', 00H
?use_perf_counter@?1??perf_counter@@9@9 DD 01H		; `perf_counter'::`2'::use_perf_counter
	ORG $+4
strftime_doc DB	'strftime(format[, tuple]) -> string', 0aH, 0aH, 'Convert'
	DB	' a time tuple to a string according to a format specification'
	DB	'.', 0aH, 'See the library reference manual for formatting cod'
	DB	'es. When the time tuple', 0aH, 'is not present, current time '
	DB	'as returned by localtime() is used.', 00H
	ORG $+1
?use_monotonic@?1??perf_counter@@9@9 DD 01H		; `perf_counter'::`2'::use_monotonic
	ORG $+4
strptime_doc DB	'strptime(string, format) -> struct_time', 0aH, 0aH, 'Par'
	DB	'se a string to a time tuple according to a format specificati'
	DB	'on.', 0aH, 'See the library reference manual for formatting c'
	DB	'odes (same as strftime()).', 00H
	ORG $+7
?wday_name@?1??_asctime@@9@9 DB 'Sun', 00H		; `_asctime'::`2'::wday_name
	DB	'Mon', 00H
	DB	'Tue', 00H
	DB	'Wed', 00H
	DB	'Thu', 00H
	DB	'Fri', 00H
	DB	'Sat', 00H
	ORG $+4
asctime_doc DB	'asctime([tuple]) -> string', 0aH, 0aH, 'Convert a time t'
	DB	'uple to a string, e.g. ''Sat Jun 06 16:26:11 1998''.', 0aH, 'W'
	DB	'hen the time tuple is not present, current time as returned b'
	DB	'y localtime()', 0aH, 'is used.', 00H
	ORG $+12
ctime_doc DB	'ctime(seconds) -> string', 0aH, 0aH, 'Convert a time in '
	DB	'seconds since the Epoch to a string in local time.', 0aH, 'Th'
	DB	'is is equivalent to asctime(localtime(seconds)). When the tim'
	DB	'e tuple is', 0aH, 'not present, current time as returned by l'
	DB	'ocaltime() is used.', 00H
	ORG $+9
mktime_doc DB	'mktime(tuple) -> floating point number', 0aH, 0aH, 'Conv'
	DB	'ert a time tuple in local time to seconds since the Epoch.', 0aH
	DB	'Note that mktime(gmtime(0)) will not generally return zero fo'
	DB	'r most', 0aH, 'time zones; instead the returned value will ei'
	DB	'ther be equal to that', 0aH, 'of the timezone or altzone attr'
	DB	'ibutes on the time module.', 00H
	ORG $+7
monotonic_doc DB 'monotonic() -> float', 0aH, 0aH, 'Monotonic clock, cann'
	DB	'ot go backward.', 00H
	ORG $+5
perf_counter_doc DB 'perf_counter() -> float', 0aH, 0aH, 'Performance cou'
	DB	'nter for benchmarking.', 00H
	ORG $+1
process_time_doc DB 'process_time() -> float', 0aH, 0aH, 'Process time fo'
	DB	'r profiling: sum of the kernel and user-space CPU time.', 00H
get_clock_info_doc DB 'get_clock_info(name: str) -> dict', 0aH, 0aH, 'Get'
	DB	' information of the specified clock.', 00H
	ORG $+5
time_methods DQ	FLAT:??_C@_04CLCEDBPF@time?$AA@
	DQ	FLAT:time_time
	DD	04H
	ORG $+4
	DQ	FLAT:time_doc
	DQ	FLAT:??_C@_05DDECJJKE@clock?$AA@
	DQ	FLAT:time_clock
	DD	04H
	ORG $+4
	DQ	FLAT:clock_doc
	DQ	FLAT:??_C@_05PCJCMMHD@sleep?$AA@
	DQ	FLAT:time_sleep
	DD	01H
	ORG $+4
	DQ	FLAT:sleep_doc
	DQ	FLAT:??_C@_06IKBBHHHJ@gmtime?$AA@
	DQ	FLAT:time_gmtime
	DD	01H
	ORG $+4
	DQ	FLAT:gmtime_doc
	DQ	FLAT:??_C@_09EKBOCLDN@localtime?$AA@
	DQ	FLAT:time_localtime
	DD	01H
	ORG $+4
	DQ	FLAT:localtime_doc
	DQ	FLAT:??_C@_07MHIFAOOG@asctime?$AA@
	DQ	FLAT:time_asctime
	DD	01H
	ORG $+4
	DQ	FLAT:asctime_doc
	DQ	FLAT:??_C@_05NCKEBKLP@ctime?$AA@
	DQ	FLAT:time_ctime
	DD	01H
	ORG $+4
	DQ	FLAT:ctime_doc
	DQ	FLAT:??_C@_06PIDIMLCK@mktime?$AA@
	DQ	FLAT:time_mktime
	DD	08H
	ORG $+4
	DQ	FLAT:mktime_doc
	DQ	FLAT:??_C@_08EPGBJPHJ@strftime?$AA@
	DQ	FLAT:time_strftime
	DD	01H
	ORG $+4
	DQ	FLAT:strftime_doc
	DQ	FLAT:??_C@_08JKOOHOPP@strptime?$AA@
	DQ	FLAT:time_strptime
	DD	01H
	ORG $+4
	DQ	FLAT:strptime_doc
	DQ	FLAT:??_C@_09FKNHDPAJ@monotonic?$AA@
	DQ	FLAT:time_monotonic
	DD	04H
	ORG $+4
	DQ	FLAT:monotonic_doc
	DQ	FLAT:??_C@_0N@HNHIBMAE@process_time?$AA@
	DQ	FLAT:time_process_time
	DD	04H
	ORG $+4
	DQ	FLAT:process_time_doc
	DQ	FLAT:??_C@_0N@MEONCEDN@perf_counter?$AA@
	DQ	FLAT:time_perf_counter
	DD	04H
	ORG $+4
	DQ	FLAT:perf_counter_doc
	DQ	FLAT:??_C@_0P@IHBBIOOL@get_clock_info?$AA@
	DQ	FLAT:time_get_clock_info
	DD	01H
	ORG $+4
	DQ	FLAT:get_clock_info_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
module_doc DB	'This module provides various functions to manipulate tim'
	DB	'e values.', 0aH, 0aH, 'There are two standard representations'
	DB	' of time.  One is the number', 0aH, 'of seconds since the Epo'
	DB	'ch, in UTC (a.k.a. GMT).  It may be an integer', 0aH, 'or a f'
	DB	'loating point number (to represent fractions of seconds).', 0aH
	DB	'The Epoch is system-defined; on Unix, it is generally January'
	DB	' 1st, 1970.', 0aH, 'The actual value can be retrieved by call'
	DB	'ing gmtime(0).', 0aH, 0aH, 'The other representation is a tup'
	DB	'le of 9 integers giving local time.', 0aH, 'The tuple items a'
	DB	're:', 0aH, '  year (including century, e.g. 1998)', 0aH, '  m'
	DB	'onth (1-12)', 0aH, '  day (1-31)', 0aH, '  hours (0-23)', 0aH
	DB	'  minutes (0-59)', 0aH, '  seconds (0-59)', 0aH, '  weekday ('
	DB	'0-6, Monday is 0)', 0aH, '  Julian day (day in the year, 1-36'
	DB	'6)', 0aH, '  DST (Daylight Savings Time) flag (-1, 0 or 1)', 0aH
	DB	'If the DST flag is 0, the time is given in the regular time z'
	DB	'one;', 0aH, 'if it is 1, the time is given in the DST time zo'
	DB	'ne;', 0aH, 'if it is -1, mktime() should guess based on the d'
	DB	'ate and time.', 0aH, 0aH, 'Variables:', 0aH, 0aH, 'timezone -'
	DB	'- difference in seconds between UTC and local standard time', 0aH
	DB	'altzone -- difference in  seconds between UTC and local DST t'
	DB	'ime', 0aH, 'daylight -- whether local time should reflect DST'
	DB	0aH, 'tzname -- tuple of (standard time zone name, DST time zo'
	DB	'ne name)', 0aH, 0aH, 'Functions:', 0aH, 0aH, 'time() -- retur'
	DB	'n current time in seconds since the Epoch as a float', 0aH, 'c'
	DB	'lock() -- return CPU time since process start as a float', 0aH
	DB	'sleep() -- delay for a number of seconds given as a float', 0aH
	DB	'gmtime() -- convert seconds since Epoch to UTC tuple', 0aH, 'l'
	DB	'ocaltime() -- convert seconds since Epoch to local time tuple'
	DB	0aH, 'asctime() -- convert time tuple to string', 0aH, 'ctime('
	DB	') -- convert time in seconds to string', 0aH, 'mktime() -- co'
	DB	'nvert local time tuple to seconds since Epoch', 0aH, 'strftim'
	DB	'e() -- convert time tuple to string according to format speci'
	DB	'fication', 0aH, 'strptime() -- parse string to time tuple acc'
	DB	'ording to format specification', 0aH, 'tzset() -- change the '
	DB	'local timezone', 00H
	ORG $+12
timemodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_04CLCEDBPF@time?$AA@
	DQ	FLAT:module_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:time_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
EXTRN	__imp__gmtime64:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT gmtime
_TEXT	SEGMENT
_Time$ = 8
gmtime	PROC						; COMDAT

; 101  : #pragma warning( push )
; 102  : #pragma warning( disable : 4996 )
; 103  :     return _gmtime64(_Time);
; 104  : #pragma warning( pop )
; 105  : }

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__gmtime64
gmtime	ENDP
_TEXT	ENDS
EXTRN	__imp__localtime64:PROC
; Function compile flags: /Ogtpy
;	COMDAT localtime
_TEXT	SEGMENT
_Time$ = 8
localtime PROC						; COMDAT

; 114  : #pragma warning( push )
; 115  : #pragma warning( disable : 4996 )
; 116  :     return _localtime64(_Time);
; 117  : #pragma warning( pop )
; 118  : }

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__localtime64
localtime ENDP
_TEXT	ENDS
EXTRN	__imp__mktime64:PROC
; Function compile flags: /Ogtpy
;	COMDAT mktime
_TEXT	SEGMENT
_Tm$ = 8
mktime	PROC						; COMDAT

; 125  :     return _mktime64(_Tm);
; 126  : }

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__mktime64
mktime	ENDP
_TEXT	ENDS
EXTRN	__imp__time64:PROC
; Function compile flags: /Ogtpy
;	COMDAT time
_TEXT	SEGMENT
_Time$ = 8
time	PROC						; COMDAT

; 133  :     return _time64(_Time);
; 134  : }

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__time64
time	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	__real@408f400000000000
PUBLIC	??_C@_07DBKAOJPM@clock?$CI?$CJ?$AA@		; `string'
PUBLIC	??_C@_0EM@CHFAIPKH@the?5processor?5time?5used?5is?5not?5a@ ; `string'
EXTRN	PyFloat_FromDouble:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_RuntimeError:QWORD
EXTRN	__imp_clock:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\modules\timemodule.c
pdata	SEGMENT
$pdata$floatclock DD imagerel floatclock
	DD	imagerel floatclock+110
	DD	imagerel $unwind$floatclock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$floatclock DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT ??_C@_07DBKAOJPM@clock?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_07DBKAOJPM@clock?$CI?$CJ?$AA@ DB 'clock()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@CHFAIPKH@the?5processor?5time?5used?5is?5not?5a@
CONST	SEGMENT
??_C@_0EM@CHFAIPKH@the?5processor?5time?5used?5is?5not?5a@ DB 'the proces'
	DB	'sor time used is not available or its value cannot be represe'
	DB	'nted', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT floatclock
_TEXT	SEGMENT
info$ = 48
floatclock PROC						; COMDAT

; 86   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 87   :     clock_t value;
; 88   :     value = clock();

  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clock

; 89   :     if (value == (clock_t)-1) {

  0000f	83 f8 ff	 cmp	 eax, -1
  00012	75 1b		 jne	 SHORT $LN2@floatclock

; 90   :         PyErr_SetString(PyExc_RuntimeError,
; 91   :                 "the processor time used is not available "
; 92   :                 "or its value cannot be represented");

  00014	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EM@CHFAIPKH@the?5processor?5time?5used?5is?5not?5a@
  00022	e8 00 00 00 00	 call	 PyErr_SetString

; 93   :         return NULL;

  00027	33 c0		 xor	 eax, eax

; 102  : }

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5b		 pop	 rbx
  0002e	c3		 ret	 0
$LN2@floatclock:

; 94   :     }
; 95   :     if (info) {

  0002f	48 85 db	 test	 rbx, rbx
  00032	74 20		 je	 SHORT $LN1@floatclock

; 96   :         info->implementation = "clock()";

  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07DBKAOJPM@clock?$CI?$CJ?$AA@

; 97   :         info->resolution = 1.0 / (double)CLOCKS_PER_SEC;
; 98   :         info->monotonic = 1;

  0003b	48 c7 43 08 01
	00 00 00	 mov	 QWORD PTR [rbx+8], 1
  00043	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  00046	48 b9 fc a9 f1
	d2 4d 62 50 3f	 mov	 rcx, 4562254508917369340 ; 3f50624dd2f1a9fcH
  00050	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx
$LN1@floatclock:

; 99   :         info->adjustable = 0;
; 100  :     }
; 101  :     return PyFloat_FromDouble((double)value / CLOCKS_PER_SEC);

  00054	66 0f 6e c0	 movd	 xmm0, eax
  00058	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0005c	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@408f400000000000

; 102  : }

  00064	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00068	5b		 pop	 rbx
  00069	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
floatclock ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@GHHFKNCE@QueryPerformanceCounter?$CI?$CJ?$AA@ ; `string'
PUBLIC	__real@3ff0000000000000
EXTRN	__imp_QueryPerformanceFrequency:PROC
EXTRN	__imp_QueryPerformanceCounter:PROC
_BSS	SEGMENT
?ctrStart@?1??win_perf_counter@@9@9 DQ 01H DUP (?)	; `win_perf_counter'::`2'::ctrStart
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$win_perf_counter DD imagerel win_perf_counter
	DD	imagerel win_perf_counter+232
	DD	imagerel $unwind$win_perf_counter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win_perf_counter DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BK@GHHFKNCE@QueryPerformanceCounter?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BK@GHHFKNCE@QueryPerformanceCounter?$CI?$CJ?$AA@ DB 'QueryPerforma'
	DB	'nceCounter()', 00H				; `string'
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT win_perf_counter
_TEXT	SEGMENT
info$ = 48
result$ = 56
now$ = 64
freq$63579 = 72
win_perf_counter PROC					; COMDAT

; 111  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 112  :     static LONGLONG cpu_frequency = 0;
; 113  :     static LONGLONG ctrStart;
; 114  :     LARGE_INTEGER now;
; 115  :     double diff;
; 116  : 
; 117  :     if (cpu_frequency == 0) {

  0000a	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?cpu_frequency@?1??win_perf_counter@@9@9, 0
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b d9	 mov	 rbx, rcx
  00018	75 3f		 jne	 SHORT $LN4@win_perf_c

; 118  :         LARGE_INTEGER freq;
; 119  :         QueryPerformanceCounter(&now);

  0001a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR now$[rsp]
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceCounter

; 120  :         ctrStart = now.QuadPart;

  00025	4c 8b 5c 24 40	 mov	 r11, QWORD PTR now$[rsp]

; 121  :         if (!QueryPerformanceFrequency(&freq) || freq.QuadPart == 0) {

  0002a	48 8d 4c 24 48	 lea	 rcx, QWORD PTR freq$63579[rsp]
  0002f	4c 89 1d 00 00
	00 00		 mov	 QWORD PTR ?ctrStart@?1??win_perf_counter@@9@9, r11
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceFrequency
  0003c	85 c0		 test	 eax, eax
  0003e	0f 84 8f 00 00
	00		 je	 $LN2@win_perf_c
  00044	48 8b 44 24 48	 mov	 rax, QWORD PTR freq$63579[rsp]
  00049	48 85 c0	 test	 rax, rax
  0004c	0f 84 81 00 00
	00		 je	 $LN2@win_perf_c

; 122  :             /* Unlikely to happen - this works on all intel
; 123  :                machines at least!  Revert to clock() */
; 124  :             *result = NULL;
; 125  :             return -1;
; 126  :         }
; 127  :         cpu_frequency = freq.QuadPart;

  00052	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?cpu_frequency@?1??win_perf_counter@@9@9, rax
$LN4@win_perf_c:

; 128  :     }
; 129  :     QueryPerformanceCounter(&now);

  00059	48 8d 4c 24 40	 lea	 rcx, QWORD PTR now$[rsp]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceCounter

; 130  :     diff = (double)(now.QuadPart - ctrStart);

  00064	4c 8b 5c 24 40	 mov	 r11, QWORD PTR now$[rsp]

; 131  :     if (info) {

  00069	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?cpu_frequency@?1??win_perf_counter@@9@9
  00070	66 0f ef c0	 pxor	 xmm0, xmm0
  00074	4c 2b 1d 00 00
	00 00		 sub	 r11, QWORD PTR ?ctrStart@?1??win_perf_counter@@9@9
  0007b	f2 49 0f 2a c3	 cvtsi2sd xmm0, r11
  00080	48 85 db	 test	 rbx, rbx
  00083	74 2c		 je	 SHORT $LN1@win_perf_c

; 132  :         info->implementation = "QueryPerformanceCounter()";
; 133  :         info->resolution = 1.0 / (double)cpu_frequency;

  00085	f2 0f 10 15 00
	00 00 00	 movsdx	 xmm2, QWORD PTR __real@3ff0000000000000
  0008d	66 0f ef c9	 pxor	 xmm1, xmm1
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@GHHFKNCE@QueryPerformanceCounter?$CI?$CJ?$AA@
  00098	48 89 0b	 mov	 QWORD PTR [rbx], rcx

; 134  :         info->monotonic = 1;

  0009b	48 c7 43 08 01
	00 00 00	 mov	 QWORD PTR [rbx+8], 1
  000a3	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  000a8	f2 0f 5e d1	 divsd	 xmm2, xmm1
  000ac	f2 0f 11 53 10	 movsdx	 QWORD PTR [rbx+16], xmm2
$LN1@win_perf_c:

; 135  :         info->adjustable = 0;
; 136  :     }
; 137  :     *result = PyFloat_FromDouble(diff / (double)cpu_frequency);

  000b1	66 0f ef c9	 pxor	 xmm1, xmm1
  000b5	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  000ba	f2 0f 5e c1	 divsd	 xmm0, xmm1
  000be	e8 00 00 00 00	 call	 PyFloat_FromDouble
  000c3	48 89 07	 mov	 QWORD PTR [rdi], rax

; 138  :     return 0;

  000c6	33 c0		 xor	 eax, eax

; 139  : }

  000c8	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000cd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d1	5f		 pop	 rdi
  000d2	c3		 ret	 0
$LN2@win_perf_c:
  000d3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000d8	48 c7 07 00 00
	00 00		 mov	 QWORD PTR [rdi], 0
  000df	83 c8 ff	 or	 eax, -1
  000e2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e6	5f		 pop	 rdi
  000e7	c3		 ret	 0
win_perf_counter ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pyclock DD imagerel pyclock
	DD	imagerel pyclock+47
	DD	imagerel $unwind$pyclock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pyclock DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT pyclock
_TEXT	SEGMENT
info$ = 48
res$ = 56
pyclock	PROC						; COMDAT

; 146  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 147  : #ifdef WIN32_PERF_COUNTER
; 148  :     PyObject *res;
; 149  :     if (win_perf_counter(info, &res) == 0)

  00006	48 8d 54 24 38	 lea	 rdx, QWORD PTR res$[rsp]
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	e8 00 00 00 00	 call	 win_perf_counter
  00013	85 c0		 test	 eax, eax
  00015	75 0b		 jne	 SHORT $LN1@pyclock

; 150  :         return res;

  00017	48 8b 44 24 38	 mov	 rax, QWORD PTR res$[rsp]

; 153  : }

  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5b		 pop	 rbx
  00021	c3		 ret	 0
$LN1@pyclock:

; 151  : #endif
; 152  :     return floatclock(info);

  00022	48 8b cb	 mov	 rcx, rbx

; 153  : }

  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5b		 pop	 rbx
  0002a	e9 00 00 00 00	 jmp	 floatclock
pyclock	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT time_clock
_TEXT	SEGMENT
self$ = 8
unused$ = 16
time_clock PROC						; COMDAT

; 158  :     return pyclock(NULL);

  00000	33 c9		 xor	 ecx, ecx

; 159  : }

  00002	e9 00 00 00 00	 jmp	 pyclock
time_clock ENDP
_TEXT	ENDS
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyStructSequence_New:PROC
_BSS	SEGMENT
StructTimeType DB 01e0H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$tmtotuple DD imagerel tmtotuple
	DD	imagerel tmtotuple+366
	DD	imagerel $unwind$tmtotuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tmtotuple DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\timemodule.c
xdata	ENDS
;	COMDAT tmtotuple
_TEXT	SEGMENT
p$ = 64
tmtotuple PROC						; COMDAT

; 308  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 309  :     PyObject *v = PyStructSequence_New(&StructTimeType);

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:StructTimeType
  00014	e8 00 00 00 00	 call	 PyStructSequence_New
  00019	48 8b d8	 mov	 rbx, rax

; 310  :     if (v == NULL)

  0001c	48 85 c0	 test	 rax, rax

; 311  :         return NULL;

  0001f	0f 84 2e 01 00
	00		 je	 $LN3@tmtotuple

; 312  : 
; 313  : #define SET(i,val) PyStructSequence_SET_ITEM(v, i, PyLong_FromLong((long) val))
; 314  : 
; 315  :     SET(0, p->tm_year + 1900);

  00025	8b 4f 14	 mov	 ecx, DWORD PTR [rdi+20]
  00028	81 c1 6c 07 00
	00		 add	 ecx, 1900		; 0000076cH
  0002e	e8 00 00 00 00	 call	 PyLong_FromLong
  00033	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 316  :     SET(1, p->tm_mon + 1);         /* Want January == 1 */

  00037	8b 4f 10	 mov	 ecx, DWORD PTR [rdi+16]
  0003a	ff c1		 inc	 ecx
  0003c	e8 00 00 00 00	 call	 PyLong_FromLong
  00041	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 317  :     SET(2, p->tm_mday);

  00045	8b 4f 0c	 mov	 ecx, DWORD PTR [rdi+12]
  00048	e8 00 00 00 00	 call	 PyLong_FromLong
  0004d	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax

; 318  :     SET(3, p->tm_hour);

  00054	8b 4f 08	 mov	 ecx, DWORD PTR [rdi+8]
  00057	e8 00 00 00 00	 call	 PyLong_FromLong
  0005c	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 319  :     SET(4, p->tm_min);

  00063	8b 4f 04	 mov	 ecx, DWORD PTR [rdi+4]
  00066	e8 00 00 00 00	 call	 PyLong_FromLong
  0006b	48 89 83 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rax

; 320  :     SET(5, p->tm_sec);

  00072	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00074	e8 00 00 00 00	 call	 PyLong_FromLong
  00079	48 89 83 98 00
	00 00		 mov	 QWORD PTR [rbx+152], rax

; 321  :     SET(6, (p->tm_wday + 6) % 7); /* Want Monday == 0 */

  00080	8b 4f 18	 mov	 ecx, DWORD PTR [rdi+24]
  00083	b8 93 24 49 92	 mov	 eax, -1840700269	; ffffffff92492493H
  00088	83 c1 06	 add	 ecx, 6
  0008b	f7 e9		 imul	 ecx
  0008d	03 d1		 add	 edx, ecx
  0008f	c1 fa 02	 sar	 edx, 2
  00092	8b c2		 mov	 eax, edx
  00094	c1 e8 1f	 shr	 eax, 31
  00097	03 d0		 add	 edx, eax
  00099	6b d2 07	 imul	 edx, 7
  0009c	2b ca		 sub	 ecx, edx
  0009e	e8 00 00 00 00	 call	 PyLong_FromLong
  000a3	48 89 83 a0 00
	00 00		 mov	 QWORD PTR [rbx+160], rax

; 322  :     SET(7, p->tm_yday + 1);        /* Want January, 1 == 1 */

  000aa	8b 4f 1c	 mov	 ecx, DWORD PTR [rdi+28]
  000ad	ff c1		 inc	 ecx
  000af	e8 00 00 00 00	 call	 PyLong_FromLong
  000b4	48 89 83 a8 00
	00 00		 mov	 QWORD PTR [rbx+168], rax

; 323  :     SET(8, p->tm_isdst);

  000bb	8b 4f 20	 mov	 ecx, DWORD PTR [rdi+32]
  000be	e8 00 00 00 00	 call	 PyLong_FromLong
  000c3	48 89 83 b0 00
	00 00		 mov	 QWORD PTR [rbx+176], rax

; 324  : #ifdef HAVE_STRUCT_TM_TM_ZONE
; 325  :     PyStructSequence_SET_ITEM(v, 9,
; 326  :         PyUnicode_DecodeLocale(p->tm_zone, "surrogateescape"));
; 327  :     SET(10, p->tm_gmtoff);
; 328  : #endif /* HAVE_STRUCT_TM_TM_ZONE */
; 329  : #undef SET
; 330  :     if (PyErr_Occurred()) {

  000ca	e8 00 00 00 00	 call	 PyErr_Occurred
  000cf	48 85 c0	 test	 rax, rax
  000d2	0f 84 88 00 00
	00		 je	 $LN5@tmtotuple

; 331  :         Py_XDECREF(v);

  000d8	e8 00 00 00 00	 call	 _Py_PXCTX
  000dd	85 c0		 test	 eax, eax
  000df	75 72		 jne	 SHORT $LN3@tmtotuple
  000e1	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000e5	a8 20		 test	 al, 32			; 00000020H
  000e7	75 62		 jne	 SHORT $LN13@tmtotuple
  000e9	84 c0		 test	 al, al
  000eb	78 5e		 js	 SHORT $LN13@tmtotuple
  000ed	a8 02		 test	 al, 2
  000ef	75 62		 jne	 SHORT $LN3@tmtotuple
  000f1	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000f5	75 5c		 jne	 SHORT $LN3@tmtotuple
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00105	4c 8b cb	 mov	 r9, rbx
  00108	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0010e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00116	e8 00 00 00 00	 call	 _PyParallel_Guard
  0011b	48 8b cb	 mov	 rcx, rbx
  0011e	85 c0		 test	 eax, eax
  00120	74 12		 je	 SHORT $LN18@tmtotuple
  00122	e8 00 00 00 00	 call	 _Px_Dealloc

; 332  :         return NULL;

  00127	33 c0		 xor	 eax, eax

; 336  : }

  00129	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0012e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00132	5f		 pop	 rdi
  00133	c3		 ret	 0

; 331  :         Py_XDECREF(v);

$LN18@tmtotuple:
  00134	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00138	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 332  :         return NULL;

  0013e	33 c0		 xor	 eax, eax

; 336  : }

  00140	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00145	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00149	5f		 pop	 rdi
  0014a	c3		 ret	 0

; 331  :         Py_XDECREF(v);

$LN13@tmtotuple:
  0014b	48 8b cb	 mov	 rcx, rbx
  0014e	e8 00 00 00 00	 call	 Px_DecRef
$LN3@tmtotuple:

; 332  :         return NULL;

  00153	33 c0		 xor	 eax, eax

; 336  : }

  00155	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0015a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0015e	5f		 pop	 rdi
  0015f	c3		 ret	 0
$LN5@tmtotuple:

; 333  :     }
; 334  : 
; 335  :     return v;

  00160	48 8b c3	 mov	 rax, rbx

; 336  : }

  00163	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00168	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0016c	5f		 pop	 rdi
  0016d	c3		 ret	 0
tmtotuple ENDP
_TEXT	ENDS
EXTRN	_PyTime_ObjectToTime_t:PROC
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
pdata	SEGMENT
$pdata$parse_time_t_args DD imagerel parse_time_t_args
	DD	imagerel parse_time_t_args+118
	DD	imagerel $unwind$parse_time_t_args
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parse_time_t_args DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\timemodule.c
xdata	ENDS
;	COMDAT parse_time_t_args
_TEXT	SEGMENT
whent$ = 32
args$ = 64
format$ = 72
pwhen$ = 80
ot$ = 88
parse_time_t_args PROC					; COMDAT

; 344  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	49 8b d8	 mov	 rbx, r8

; 345  :     PyObject *ot = NULL;
; 346  :     time_t whent;
; 347  : 
; 348  :     if (!PyArg_ParseTuple(args, format, &ot))

  00009	4c 8d 44 24 58	 lea	 r8, QWORD PTR ot$[rsp]
  0000e	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR ot$[rsp], 0
  00017	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0001c	85 c0		 test	 eax, eax
  0001e	75 08		 jne	 SHORT $LN5@parse_time
$LN11@parse_time:

; 349  :         return 0;

  00020	33 c0		 xor	 eax, eax

; 359  : }

  00022	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00026	5b		 pop	 rbx
  00027	c3		 ret	 0
$LN5@parse_time:

; 350  :     if (ot == NULL || ot == Py_None) {

  00028	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ot$[rsp]
  0002d	48 85 c9	 test	 rcx, rcx
  00030	74 2e		 je	 SHORT $LN3@parse_time
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00039	48 3b c8	 cmp	 rcx, rax
  0003c	74 22		 je	 SHORT $LN3@parse_time

; 352  :     }
; 353  :     else {
; 354  :         if (_PyTime_ObjectToTime_t(ot, &whent) == -1)

  0003e	48 8d 54 24 20	 lea	 rdx, QWORD PTR whent$[rsp]
  00043	e8 00 00 00 00	 call	 _PyTime_ObjectToTime_t
  00048	83 f8 ff	 cmp	 eax, -1

; 355  :             return 0;

  0004b	74 d3		 je	 SHORT $LN11@parse_time

; 356  :     }
; 357  :     *pwhen = whent;

  0004d	48 8b 44 24 20	 mov	 rax, QWORD PTR whent$[rsp]
  00052	48 89 03	 mov	 QWORD PTR [rbx], rax

; 358  :     return 1;

  00055	b8 01 00 00 00	 mov	 eax, 1

; 359  : }

  0005a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005e	5b		 pop	 rbx
  0005f	c3		 ret	 0
$LN3@parse_time:

; 351  :         whent = time(NULL);

  00060	33 c9		 xor	 ecx, ecx
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 356  :     }
; 357  :     *pwhen = whent;

  00068	48 89 03	 mov	 QWORD PTR [rbx], rax

; 358  :     return 1;

  0006b	b8 01 00 00 00	 mov	 eax, 1

; 359  : }

  00070	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00074	5b		 pop	 rbx
  00075	c3		 ret	 0
parse_time_t_args ENDP
_TEXT	ENDS
PUBLIC	??_C@_09NKECGAE@?$HMO?3gmtime?$AA@		; `string'
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	PyExc_OSError:QWORD
EXTRN	__imp__errno:PROC
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
pdata	SEGMENT
$pdata$time_gmtime DD imagerel time_gmtime
	DD	imagerel time_gmtime+191
	DD	imagerel $unwind$time_gmtime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_gmtime DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_09NKECGAE@?$HMO?3gmtime?$AA@
CONST	SEGMENT
??_C@_09NKECGAE@?$HMO?3gmtime?$AA@ DB '|O:gmtime', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\timemodule.c
CONST	ENDS
;	COMDAT time_gmtime
_TEXT	SEGMENT
buf$ = 32
self$ = 96
args$ = 104
when$ = 112
time_gmtime PROC					; COMDAT

; 363  : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 364  :     time_t when;
; 365  :     struct tm buf, *local;
; 366  : 
; 367  :     if (!parse_time_t_args(args, "|O:gmtime", &when))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 70	 lea	 r8, QWORD PTR when$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09NKECGAE@?$HMO?3gmtime?$AA@
  00013	e8 00 00 00 00	 call	 parse_time_t_args
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN3@time_gmtim

; 368  :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 381  : }

  0001e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00022	c3		 ret	 0
$LN3@time_gmtim:

; 369  : 
; 370  :     errno = 0;

  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 371  :     local = gmtime(&when);

  00029	48 8d 4c 24 70	 lea	 rcx, QWORD PTR when$[rsp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__gmtime64
  0003a	4c 8b d8	 mov	 r11, rax

; 372  :     if (local == NULL) {

  0003d	48 85 c0	 test	 rax, rax
  00040	75 28		 jne	 SHORT $LN2@time_gmtim

; 373  : #ifdef EINVAL
; 374  :         if (errno == 0)

  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00048	83 38 00	 cmp	 DWORD PTR [rax], 0
  0004b	75 0c		 jne	 SHORT $LN1@time_gmtim

; 375  :             errno = EINVAL;

  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00053	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22
$LN1@time_gmtim:

; 376  : #endif
; 377  :         return PyErr_SetFromErrno(PyExc_OSError);

  00059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  00060	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 381  : }

  00065	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00069	c3		 ret	 0
$LN2@time_gmtim:

; 378  :     }
; 379  :     buf = *local;

  0006a	8b 00		 mov	 eax, DWORD PTR [rax]

; 380  :     return tmtotuple(&buf);

  0006c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00071	89 44 24 20	 mov	 DWORD PTR buf$[rsp], eax
  00075	41 8b 43 04	 mov	 eax, DWORD PTR [r11+4]
  00079	89 44 24 24	 mov	 DWORD PTR buf$[rsp+4], eax
  0007d	41 8b 43 08	 mov	 eax, DWORD PTR [r11+8]
  00081	89 44 24 28	 mov	 DWORD PTR buf$[rsp+8], eax
  00085	41 8b 43 0c	 mov	 eax, DWORD PTR [r11+12]
  00089	89 44 24 2c	 mov	 DWORD PTR buf$[rsp+12], eax
  0008d	41 8b 43 10	 mov	 eax, DWORD PTR [r11+16]
  00091	89 44 24 30	 mov	 DWORD PTR buf$[rsp+16], eax
  00095	41 8b 43 14	 mov	 eax, DWORD PTR [r11+20]
  00099	89 44 24 34	 mov	 DWORD PTR buf$[rsp+20], eax
  0009d	41 8b 43 18	 mov	 eax, DWORD PTR [r11+24]
  000a1	89 44 24 38	 mov	 DWORD PTR buf$[rsp+24], eax
  000a5	41 8b 43 1c	 mov	 eax, DWORD PTR [r11+28]
  000a9	89 44 24 3c	 mov	 DWORD PTR buf$[rsp+28], eax
  000ad	41 8b 43 20	 mov	 eax, DWORD PTR [r11+32]
  000b1	89 44 24 40	 mov	 DWORD PTR buf$[rsp+32], eax
  000b5	e8 00 00 00 00	 call	 tmtotuple

; 381  : }

  000ba	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000be	c3		 ret	 0
time_gmtime ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
pdata	SEGMENT
$pdata$pylocaltime DD imagerel pylocaltime
	DD	imagerel pylocaltime+135
	DD	imagerel $unwind$pylocaltime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pylocaltime DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\timemodule.c
xdata	ENDS
;	COMDAT pylocaltime
_TEXT	SEGMENT
timep$ = 48
result$ = 56
pylocaltime PROC					; COMDAT

; 395  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 396  :     struct tm *local;
; 397  : 
; 398  :     assert (timep != NULL);
; 399  :     local = localtime(timep);

  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__localtime64
  0000f	4c 8b d8	 mov	 r11, rax

; 400  :     if (local == NULL) {

  00012	48 85 c0	 test	 rax, rax
  00015	75 2c		 jne	 SHORT $LN2@pylocaltim

; 401  :         /* unconvertible time */
; 402  : #ifdef EINVAL
; 403  :         if (errno == 0)

  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0001d	83 38 00	 cmp	 DWORD PTR [rax], 0
  00020	75 0c		 jne	 SHORT $LN1@pylocaltim

; 404  :             errno = EINVAL;

  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00028	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22
$LN1@pylocaltim:

; 405  : #endif
; 406  :         PyErr_SetFromErrno(PyExc_OSError);

  0002e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  00035	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 407  :         return -1;

  0003a	83 c8 ff	 or	 eax, -1

; 411  : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5b		 pop	 rbx
  00042	c3		 ret	 0
$LN2@pylocaltim:

; 408  :     }
; 409  :     *result = *local;

  00043	8b 00		 mov	 eax, DWORD PTR [rax]
  00045	89 03		 mov	 DWORD PTR [rbx], eax
  00047	41 8b 43 04	 mov	 eax, DWORD PTR [r11+4]
  0004b	89 43 04	 mov	 DWORD PTR [rbx+4], eax
  0004e	41 8b 43 08	 mov	 eax, DWORD PTR [r11+8]
  00052	89 43 08	 mov	 DWORD PTR [rbx+8], eax
  00055	41 8b 43 0c	 mov	 eax, DWORD PTR [r11+12]
  00059	89 43 0c	 mov	 DWORD PTR [rbx+12], eax
  0005c	41 8b 43 10	 mov	 eax, DWORD PTR [r11+16]
  00060	89 43 10	 mov	 DWORD PTR [rbx+16], eax
  00063	41 8b 43 14	 mov	 eax, DWORD PTR [r11+20]
  00067	89 43 14	 mov	 DWORD PTR [rbx+20], eax
  0006a	41 8b 43 18	 mov	 eax, DWORD PTR [r11+24]
  0006e	89 43 18	 mov	 DWORD PTR [rbx+24], eax
  00071	41 8b 43 1c	 mov	 eax, DWORD PTR [r11+28]
  00075	89 43 1c	 mov	 DWORD PTR [rbx+28], eax
  00078	41 8b 43 20	 mov	 eax, DWORD PTR [r11+32]
  0007c	89 43 20	 mov	 DWORD PTR [rbx+32], eax

; 410  :     return 0;

  0007f	33 c0		 xor	 eax, eax

; 411  : }

  00081	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00085	5b		 pop	 rbx
  00086	c3		 ret	 0
pylocaltime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@OJMPLKP@?$HMO?3localtime?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_localtime DD imagerel time_localtime
	DD	imagerel time_localtime+70
	DD	imagerel $unwind$time_localtime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_localtime DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0N@OJMPLKP@?$HMO?3localtime?$AA@
CONST	SEGMENT
??_C@_0N@OJMPLKP@?$HMO?3localtime?$AA@ DB '|O:localtime', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT time_localtime
_TEXT	SEGMENT
buf$ = 32
self$ = 96
args$ = 104
when$ = 112
time_localtime PROC					; COMDAT

; 415  : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 416  :     time_t when;
; 417  :     struct tm buf;
; 418  : 
; 419  :     if (!parse_time_t_args(args, "|O:localtime", &when))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 70	 lea	 r8, QWORD PTR when$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@OJMPLKP@?$HMO?3localtime?$AA@
  00013	e8 00 00 00 00	 call	 parse_time_t_args
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN2@time_local
$LN5@time_local:

; 420  :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 424  : }

  0001e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00022	c3		 ret	 0
$LN2@time_local:

; 421  :     if (pylocaltime(&when, &buf) == -1)

  00023	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
  00028	48 8d 4c 24 70	 lea	 rcx, QWORD PTR when$[rsp]
  0002d	e8 00 00 00 00	 call	 pylocaltime
  00032	83 f8 ff	 cmp	 eax, -1

; 422  :         return NULL;

  00035	74 e5		 je	 SHORT $LN5@time_local

; 423  :     return tmtotuple(&buf);

  00037	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0003c	e8 00 00 00 00	 call	 tmtotuple

; 424  : }

  00041	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00045	c3		 ret	 0
time_localtime ENDP
_TEXT	ENDS
PUBLIC	??_C@_09BOADOOAM@iiiiiiiii?$AA@			; `string'
PUBLIC	??_C@_0CH@CHMFHGAK@Tuple?5or?5struct_time?5argument?5re@ ; `string'
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$gettmarg DD imagerel gettmarg
	DD	imagerel gettmarg+262
	DD	imagerel $unwind$gettmarg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gettmarg DD 087501H
	DD	0117475H
	DD	0106465H
	DD	0f5458H
	DD	03002b206H
xdata	ENDS
;	COMDAT ??_C@_09BOADOOAM@iiiiiiiii?$AA@
CONST	SEGMENT
??_C@_09BOADOOAM@iiiiiiiii?$AA@ DB 'iiiiiiiii', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CHMFHGAK@Tuple?5or?5struct_time?5argument?5re@
CONST	SEGMENT
??_C@_0CH@CHMFHGAK@Tuple?5or?5struct_time?5argument?5re@ DB 'Tuple or str'
	DB	'uct_time argument required', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT gettmarg
_TEXT	SEGMENT
y$ = 112
args$ = 112
p$ = 120
gettmarg PROC						; COMDAT

; 438  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 439  :     int y;
; 440  : 
; 441  :     memset((void *) p, '\0', sizeof(struct tm));

  00006	33 c0		 xor	 eax, eax
  00008	48 8b da	 mov	 rbx, rdx
  0000b	4c 8b d1	 mov	 r10, rcx
  0000e	48 89 02	 mov	 QWORD PTR [rdx], rax
  00011	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax
  00015	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax
  00019	48 89 42 18	 mov	 QWORD PTR [rdx+24], rax
  0001d	89 42 20	 mov	 DWORD PTR [rdx+32], eax

; 442  : 
; 443  :     if (!PyTuple_Check(args)) {

  00020	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00024	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  0002e	75 1b		 jne	 SHORT $LN2@gettmarg

; 444  :         PyErr_SetString(PyExc_TypeError,
; 445  :                         "Tuple or struct_time argument required");

  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@CHMFHGAK@Tuple?5or?5struct_time?5argument?5re@
  0003e	e8 00 00 00 00	 call	 PyErr_SetString

; 446  :         return 0;

  00043	33 c0		 xor	 eax, eax

; 470  : }

  00045	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
$LN2@gettmarg:

; 447  :     }
; 448  : 
; 449  :     if (!PyArg_ParseTuple(args, "iiiiiiiii",
; 450  :                           &y, &p->tm_mon, &p->tm_mday,
; 451  :                           &p->tm_hour, &p->tm_min, &p->tm_sec,
; 452  :                           &p->tm_wday, &p->tm_yday, &p->tm_isdst))

  0004b	48 8d 4a 04	 lea	 rcx, QWORD PTR [rdx+4]
  0004f	48 8d 42 20	 lea	 rax, QWORD PTR [rdx+32]
  00053	48 89 6c 24 78	 mov	 QWORD PTR [rsp+120], rbp
  00058	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0005d	48 89 b4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rsi
  00065	48 8d 72 18	 lea	 rsi, QWORD PTR [rdx+24]
  00069	4c 8d 43 0c	 lea	 r8, QWORD PTR [rbx+12]
  0006d	48 89 bc 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rdi
  00075	48 8d 7a 1c	 lea	 rdi, QWORD PTR [rdx+28]
  00079	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0007e	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00083	48 83 c2 08	 add	 rdx, 8
  00087	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  0008c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00091	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00096	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  0009b	4c 8d 4b 10	 lea	 r9, QWORD PTR [rbx+16]
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09BOADOOAM@iiiiiiiii?$AA@
  000a6	4c 8d 44 24 70	 lea	 r8, QWORD PTR y$[rsp]
  000ab	49 8b ca	 mov	 rcx, r10
  000ae	e8 00 00 00 00	 call	 PyArg_ParseTuple
  000b3	85 c0		 test	 eax, eax
  000b5	74 34		 je	 SHORT $LN7@gettmarg
$LN1@gettmarg:

; 453  :         return 0;
; 454  :     p->tm_year = y - 1900;
; 455  :     p->tm_mon--;
; 456  :     p->tm_wday = (p->tm_wday + 1) % 7;

  000b7	8b 0e		 mov	 ecx, DWORD PTR [rsi]
  000b9	8b 44 24 70	 mov	 eax, DWORD PTR y$[rsp]
  000bd	ff 4b 10	 dec	 DWORD PTR [rbx+16]
  000c0	05 94 f8 ff ff	 add	 eax, -1900		; fffffffffffff894H
  000c5	ff c1		 inc	 ecx
  000c7	89 43 14	 mov	 DWORD PTR [rbx+20], eax
  000ca	b8 93 24 49 92	 mov	 eax, -1840700269	; ffffffff92492493H
  000cf	f7 e9		 imul	 ecx
  000d1	03 d1		 add	 edx, ecx
  000d3	c1 fa 02	 sar	 edx, 2
  000d6	8b c2		 mov	 eax, edx
  000d8	c1 e8 1f	 shr	 eax, 31
  000db	03 d0		 add	 edx, eax

; 457  :     p->tm_yday--;
; 458  : #ifdef HAVE_STRUCT_TM_TM_ZONE
; 459  :     if (Py_TYPE(args) == &StructTimeType) {
; 460  :         PyObject *item;
; 461  :         item = PyTuple_GET_ITEM(args, 9);
; 462  :         p->tm_zone = item == Py_None ? NULL : _PyUnicode_AsString(item);
; 463  :         item = PyTuple_GET_ITEM(args, 10);
; 464  :         p->tm_gmtoff = item == Py_None ? 0 : PyLong_AsLong(item);
; 465  :         if (PyErr_Occurred())
; 466  :             return 0;
; 467  :     }
; 468  : #endif /* HAVE_STRUCT_TM_TM_ZONE */
; 469  :     return 1;

  000dd	b8 01 00 00 00	 mov	 eax, 1
  000e2	6b d2 07	 imul	 edx, 7
  000e5	2b ca		 sub	 ecx, edx
  000e7	ff 0f		 dec	 DWORD PTR [rdi]
  000e9	89 0e		 mov	 DWORD PTR [rsi], ecx
$LN7@gettmarg:
  000eb	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  000f3	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  000f8	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR [rsp+136]

; 470  : }

  00100	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00104	5b		 pop	 rbx
  00105	c3		 ret	 0
gettmarg ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@LDNNMEKK@month?5out?5of?5range?$AA@	; `string'
PUBLIC	??_C@_0BK@OOCFANMD@day?5of?5month?5out?5of?5range?$AA@ ; `string'
PUBLIC	??_C@_0BC@LJOEHKGE@hour?5out?5of?5range?$AA@	; `string'
PUBLIC	??_C@_0BE@KHLKCEJA@minute?5out?5of?5range?$AA@	; `string'
PUBLIC	??_C@_0BF@JHEAABND@seconds?5out?5of?5range?$AA@	; `string'
PUBLIC	??_C@_0BJ@OIPNFGCH@day?5of?5year?5out?5of?5range?$AA@ ; `string'
PUBLIC	??_C@_0BJ@BHPBIAAJ@day?5of?5week?5out?5of?5range?$AA@ ; `string'
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$checktm DD imagerel checktm
	DD	imagerel checktm+347
	DD	imagerel $unwind$checktm
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$checktm DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BD@LDNNMEKK@month?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BD@LDNNMEKK@month?5out?5of?5range?$AA@ DB 'month out of range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OOCFANMD@day?5of?5month?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BK@OOCFANMD@day?5of?5month?5out?5of?5range?$AA@ DB 'day of month o'
	DB	'ut of range', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LJOEHKGE@hour?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BC@LJOEHKGE@hour?5out?5of?5range?$AA@ DB 'hour out of range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KHLKCEJA@minute?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BE@KHLKCEJA@minute?5out?5of?5range?$AA@ DB 'minute out of range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JHEAABND@seconds?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BF@JHEAABND@seconds?5out?5of?5range?$AA@ DB 'seconds out of range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OIPNFGCH@day?5of?5year?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BJ@OIPNFGCH@day?5of?5year?5out?5of?5range?$AA@ DB 'day of year out'
	DB	' of range', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BHPBIAAJ@day?5of?5week?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BJ@BHPBIAAJ@day?5of?5week?5out?5of?5range?$AA@ DB 'day of week out'
	DB	' of range', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT checktm
_TEXT	SEGMENT
buf$ = 48
checktm	PROC						; COMDAT

; 478  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 479  :     /* Checks added to make sure strftime() and asctime() does not crash Python by
; 480  :        indexing blindly into some array for a textual representation
; 481  :        by some bad index (fixes bug #897625 and #6608).
; 482  : 
; 483  :        Also support values of zero from Python code for arguments in which
; 484  :        that is out of range by forcing that value to the lowest value that
; 485  :        is valid (fixed bug #1520914).
; 486  : 
; 487  :        Valid ranges based on what is allowed in struct tm:
; 488  : 
; 489  :        - tm_year: [0, max(int)] (1)
; 490  :        - tm_mon: [0, 11] (2)
; 491  :        - tm_mday: [1, 31]
; 492  :        - tm_hour: [0, 23]
; 493  :        - tm_min: [0, 59]
; 494  :        - tm_sec: [0, 60]
; 495  :        - tm_wday: [0, 6] (1)
; 496  :        - tm_yday: [0, 365] (2)
; 497  :        - tm_isdst: [-max(int), max(int)]
; 498  : 
; 499  :        (1) gettmarg() handles bounds-checking.
; 500  :        (2) Python's acceptable range is one greater than the range in C,
; 501  :        thus need to check against automatic decrement by gettmarg().
; 502  :     */
; 503  :     if (buf->tm_mon == -1)

  00004	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  00007	33 d2		 xor	 edx, edx
  00009	83 f8 ff	 cmp	 eax, -1
  0000c	75 05		 jne	 SHORT $LN19@checktm

; 504  :         buf->tm_mon = 0;

  0000e	89 51 10	 mov	 DWORD PTR [rcx+16], edx
  00011	eb 11		 jmp	 SHORT $LN17@checktm
$LN19@checktm:

; 505  :     else if (buf->tm_mon < 0 || buf->tm_mon > 11) {

  00013	85 c0		 test	 eax, eax
  00015	0f 88 26 01 00
	00		 js	 $LN16@checktm
  0001b	83 f8 0b	 cmp	 eax, 11
  0001e	0f 8f 1d 01 00
	00		 jg	 $LN16@checktm
$LN17@checktm:

; 508  :     }
; 509  :     if (buf->tm_mday == 0)

  00024	8b 41 0c	 mov	 eax, DWORD PTR [rcx+12]
  00027	85 c0		 test	 eax, eax
  00029	75 09		 jne	 SHORT $LN22@checktm

; 510  :         buf->tm_mday = 1;

  0002b	c7 41 0c 01 00
	00 00		 mov	 DWORD PTR [rcx+12], 1
  00032	eb 0f		 jmp	 SHORT $LN13@checktm
$LN22@checktm:

; 511  :     else if (buf->tm_mday < 0 || buf->tm_mday > 31) {

  00034	0f 88 ed 00 00
	00		 js	 $LN12@checktm
  0003a	83 f8 1f	 cmp	 eax, 31
  0003d	0f 8f e4 00 00
	00		 jg	 $LN12@checktm
$LN13@checktm:

; 513  :         return 0;
; 514  :     }
; 515  :     if (buf->tm_hour < 0 || buf->tm_hour > 23) {

  00043	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00046	85 c0		 test	 eax, eax
  00048	0f 88 bf 00 00
	00		 js	 $LN10@checktm
  0004e	83 f8 17	 cmp	 eax, 23
  00051	0f 8f b6 00 00
	00		 jg	 $LN10@checktm

; 517  :         return 0;
; 518  :     }
; 519  :     if (buf->tm_min < 0 || buf->tm_min > 59) {

  00057	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]
  0005a	85 c0		 test	 eax, eax
  0005c	0f 88 91 00 00
	00		 js	 $LN8@checktm
  00062	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  00065	0f 8f 88 00 00
	00		 jg	 $LN8@checktm

; 521  :         return 0;
; 522  :     }
; 523  :     if (buf->tm_sec < 0 || buf->tm_sec > 61) {

  0006b	8b 01		 mov	 eax, DWORD PTR [rcx]
  0006d	85 c0		 test	 eax, eax
  0006f	78 68		 js	 SHORT $LN6@checktm
  00071	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  00074	7f 63		 jg	 SHORT $LN6@checktm

; 525  :         return 0;
; 526  :     }
; 527  :     /* tm_wday does not need checking of its upper-bound since taking
; 528  :     ``% 7`` in gettmarg() automatically restricts the range. */
; 529  :     if (buf->tm_wday < 0) {

  00076	39 51 18	 cmp	 DWORD PTR [rcx+24], edx
  00079	7d 1a		 jge	 SHORT $LN5@checktm

; 530  :         PyErr_SetString(PyExc_ValueError, "day of week out of range");

  0007b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@BHPBIAAJ@day?5of?5week?5out?5of?5range?$AA@
  00089	e8 00 00 00 00	 call	 PyErr_SetString
  0008e	33 c0		 xor	 eax, eax

; 540  : }

  00090	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00094	c3		 ret	 0
$LN5@checktm:

; 531  :         return 0;
; 532  :     }
; 533  :     if (buf->tm_yday == -1)

  00095	8b 41 1c	 mov	 eax, DWORD PTR [rcx+28]
  00098	83 f8 ff	 cmp	 eax, -1
  0009b	75 0d		 jne	 SHORT $LN4@checktm

; 534  :         buf->tm_yday = 0;

  0009d	89 51 1c	 mov	 DWORD PTR [rcx+28], edx

; 537  :         return 0;
; 538  :     }
; 539  :     return 1;

  000a0	b8 01 00 00 00	 mov	 eax, 1

; 540  : }

  000a5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a9	c3		 ret	 0
$LN4@checktm:

; 535  :     else if (buf->tm_yday < 0 || buf->tm_yday > 365) {

  000aa	85 c0		 test	 eax, eax
  000ac	78 11		 js	 SHORT $LN1@checktm
  000ae	3d 6d 01 00 00	 cmp	 eax, 365		; 0000016dH
  000b3	7f 0a		 jg	 SHORT $LN1@checktm

; 537  :         return 0;
; 538  :     }
; 539  :     return 1;

  000b5	b8 01 00 00 00	 mov	 eax, 1

; 540  : }

  000ba	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000be	c3		 ret	 0
$LN1@checktm:

; 506  :         PyErr_SetString(PyExc_ValueError, "month out of range");

  000bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError

; 536  :         PyErr_SetString(PyExc_ValueError, "day of year out of range");

  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@OIPNFGCH@day?5of?5year?5out?5of?5range?$AA@
  000cd	e8 00 00 00 00	 call	 PyErr_SetString
  000d2	33 c0		 xor	 eax, eax

; 540  : }

  000d4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d8	c3		 ret	 0
$LN6@checktm:

; 506  :         PyErr_SetString(PyExc_ValueError, "month out of range");

  000d9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError

; 524  :         PyErr_SetString(PyExc_ValueError, "seconds out of range");

  000e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@JHEAABND@seconds?5out?5of?5range?$AA@
  000e7	e8 00 00 00 00	 call	 PyErr_SetString
  000ec	33 c0		 xor	 eax, eax

; 540  : }

  000ee	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000f2	c3		 ret	 0
$LN8@checktm:

; 506  :         PyErr_SetString(PyExc_ValueError, "month out of range");

  000f3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError

; 520  :         PyErr_SetString(PyExc_ValueError, "minute out of range");

  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@KHLKCEJA@minute?5out?5of?5range?$AA@
  00101	e8 00 00 00 00	 call	 PyErr_SetString
  00106	33 c0		 xor	 eax, eax

; 540  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
$LN10@checktm:

; 506  :         PyErr_SetString(PyExc_ValueError, "month out of range");

  0010d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError

; 516  :         PyErr_SetString(PyExc_ValueError, "hour out of range");

  00114	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@LJOEHKGE@hour?5out?5of?5range?$AA@
  0011b	e8 00 00 00 00	 call	 PyErr_SetString
  00120	33 c0		 xor	 eax, eax

; 540  : }

  00122	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00126	c3		 ret	 0
$LN12@checktm:

; 506  :         PyErr_SetString(PyExc_ValueError, "month out of range");

  00127	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError

; 512  :         PyErr_SetString(PyExc_ValueError, "day of month out of range");

  0012e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@OOCFANMD@day?5of?5month?5out?5of?5range?$AA@
  00135	e8 00 00 00 00	 call	 PyErr_SetString
  0013a	33 c0		 xor	 eax, eax

; 540  : }

  0013c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00140	c3		 ret	 0
$LN16@checktm:

; 506  :         PyErr_SetString(PyExc_ValueError, "month out of range");

  00141	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00148	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@LDNNMEKK@month?5out?5of?5range?$AA@
  0014f	e8 00 00 00 00	 call	 PyErr_SetString

; 507  :         return 0;

  00154	33 c0		 xor	 eax, eax

; 540  : }

  00156	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0015a	c3		 ret	 0
checktm	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@HINAEAFH@strftime?$CI?$CJ?5requires?5year?5in?5?$FL1?$DL?5@ ; `string'
PUBLIC	??_C@_0BG@HMAFAPHD@Invalid?5format?5string?$AA@	; `string'
PUBLIC	??_C@_0CL@FIDKHLFK@format?5?$CFy?5requires?5year?5?$DO?$DN?51900?5@ ; `string'
PUBLIC	??_C@_0BI@PAENNBAG@aAbBcdHIjmMpSUwWxXyYzZ?$CF?$AA@ ; `string'
PUBLIC	??_C@_0BA@GMJLDMKP@surrogateescape?$AA@		; `string'
PUBLIC	??_C@_0N@KJJIHKJK@U?$HMO?3strftime?$AA@		; `string'
EXTRN	PyUnicode_DecodeLocaleAndSize:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyMem_Free:PROC
EXTRN	__imp_strftime:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	__imp_strchr:PROC
EXTRN	PyUnicode_EncodeLocale:PROC
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
pdata	SEGMENT
$pdata$time_strftime DD imagerel time_strftime
	DD	imagerel time_strftime+194
	DD	imagerel $unwind$time_strftime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$time_strftime DD imagerel time_strftime+194
	DD	imagerel time_strftime+268
	DD	imagerel $chain$0$time_strftime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$time_strftime DD imagerel time_strftime+268
	DD	imagerel time_strftime+397
	DD	imagerel $chain$4$time_strftime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$time_strftime DD imagerel time_strftime+397
	DD	imagerel time_strftime+599
	DD	imagerel $chain$8$time_strftime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$time_strftime DD imagerel time_strftime+599
	DD	imagerel time_strftime+653
	DD	imagerel $chain$9$time_strftime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$time_strftime DD imagerel time_strftime+653
	DD	imagerel time_strftime+662
	DD	imagerel $chain$11$time_strftime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$time_strftime DD imagerel time_strftime+662
	DD	imagerel time_strftime+717
	DD	imagerel $chain$12$time_strftime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$time_strftime DD imagerel time_strftime+717
	DD	imagerel time_strftime+748
	DD	imagerel $chain$13$time_strftime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$time_strftime DD 021H
	DD	imagerel time_strftime
	DD	imagerel time_strftime+194
	DD	imagerel $unwind$time_strftime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$time_strftime DD 0e0021H
	DD	0ae400H
	DD	0bd400H
	DD	0cc400H
	DD	0d7400H
	DD	0e6400H
	DD	0f5400H
	DD	0123400H
	DD	imagerel time_strftime
	DD	imagerel time_strftime+194
	DD	imagerel $unwind$time_strftime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$time_strftime DD 060021H
	DD	0ae400H
	DD	0bd400H
	DD	0d7400H
	DD	imagerel time_strftime
	DD	imagerel time_strftime+194
	DD	imagerel $unwind$time_strftime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$time_strftime DD 021H
	DD	imagerel time_strftime+268
	DD	imagerel time_strftime+397
	DD	imagerel $chain$4$time_strftime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$time_strftime DD 082421H
	DD	0cc424H
	DD	0e6418H
	DD	0f540fH
	DD	0123408H
	DD	imagerel time_strftime+268
	DD	imagerel time_strftime+397
	DD	imagerel $chain$4$time_strftime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$time_strftime DD 061321H
	DD	0ae413H
	DD	0d740eH
	DD	0bd400H
	DD	imagerel time_strftime
	DD	imagerel time_strftime+194
	DD	imagerel $unwind$time_strftime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$time_strftime DD 020521H
	DD	0bd405H
	DD	imagerel time_strftime
	DD	imagerel time_strftime+194
	DD	imagerel $unwind$time_strftime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_strftime DD 020c01H
	DD	0f005f20cH
xdata	ENDS
;	COMDAT ??_C@_0CG@HINAEAFH@strftime?$CI?$CJ?5requires?5year?5in?5?$FL1?$DL?5@
CONST	SEGMENT
??_C@_0CG@HINAEAFH@strftime?$CI?$CJ?5requires?5year?5in?5?$FL1?$DL?5@ DB 's'
	DB	'trftime() requires year in [1; 9999]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HMAFAPHD@Invalid?5format?5string?$AA@
CONST	SEGMENT
??_C@_0BG@HMAFAPHD@Invalid?5format?5string?$AA@ DB 'Invalid format string'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FIDKHLFK@format?5?$CFy?5requires?5year?5?$DO?$DN?51900?5@
CONST	SEGMENT
??_C@_0CL@FIDKHLFK@format?5?$CFy?5requires?5year?5?$DO?$DN?51900?5@ DB 'f'
	DB	'ormat %y requires year >= 1900 on Windows', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PAENNBAG@aAbBcdHIjmMpSUwWxXyYzZ?$CF?$AA@
CONST	SEGMENT
??_C@_0BI@PAENNBAG@aAbBcdHIjmMpSUwWxXyYzZ?$CF?$AA@ DB 'aAbBcdHIjmMpSUwWxX'
	DB	'yYzZ%', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
CONST	SEGMENT
??_C@_0BA@GMJLDMKP@surrogateescape?$AA@ DB 'surrogateescape', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KJJIHKJK@U?$HMO?3strftime?$AA@
CONST	SEGMENT
??_C@_0N@KJJIHKJK@U?$HMO?3strftime?$AA@ DB 'U|O:strftime', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\timemodule.c
CONST	ENDS
;	COMDAT time_strftime
_TEXT	SEGMENT
format_arg$ = 32
buf$ = 40
self$ = 144
args$ = 152
tup$ = 160
tt$63809 = 168
time_strftime PROC					; COMDAT

; 560  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	41 57		 push	 r15
  00005	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 561  :     PyObject *tup = NULL;
; 562  :     struct tm buf;
; 563  :     const time_char *fmt;
; 564  : #ifdef HAVE_WCSFTIME
; 565  :     wchar_t *format;
; 566  : #else
; 567  :     PyObject *format;
; 568  : #endif
; 569  :     PyObject *format_arg;
; 570  :     size_t fmtlen, buflen;
; 571  :     time_char *outbuf = NULL;
; 572  :     size_t i;
; 573  :     PyObject *ret = NULL;
; 574  : 
; 575  :     memset((void *) &buf, '\0', sizeof(buf));

  0000c	33 c9		 xor	 ecx, ecx
  0000e	48 8b c2	 mov	 rax, rdx

; 576  : 
; 577  :     /* Will always expect a unicode string to be passed as format.
; 578  :        Given that there's no str type anymore in py3k this seems safe.
; 579  :     */
; 580  :     if (!PyArg_ParseTuple(args, "U|O:strftime", &format_arg, &tup))

  00011	4d 8d 4b 18	 lea	 r9, QWORD PTR [r11+24]
  00015	49 89 4b a0	 mov	 QWORD PTR [r11-96], rcx
  00019	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  0001d	49 89 4b b0	 mov	 QWORD PTR [r11-80], rcx
  00021	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  00025	89 4c 24 48	 mov	 DWORD PTR buf$[rsp+32], ecx
  00029	4d 8d 43 98	 lea	 r8, QWORD PTR [r11-104]
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@KJJIHKJK@U?$HMO?3strftime?$AA@
  00034	45 33 ff	 xor	 r15d, r15d
  00037	48 8b c8	 mov	 rcx, rax
  0003a	4d 89 7b 18	 mov	 QWORD PTR [r11+24], r15
  0003e	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00043	85 c0		 test	 eax, eax

; 581  :         return NULL;

  00045	74 32		 je	 SHORT $LN46@time_strft

; 582  : 
; 583  :     if (tup == NULL) {

  00047	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tup$[rsp]
  0004f	48 85 c9	 test	 rcx, rcx
  00052	75 31		 jne	 SHORT $LN25@time_strft

; 584  :         time_t tt = time(NULL);

  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 585  :         if (pylocaltime(&tt, &buf) == -1)

  0005a	48 8d 54 24 28	 lea	 rdx, QWORD PTR buf$[rsp]
  0005f	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR tt$63809[rsp]
  00067	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tt$63809[rsp], rax
  0006f	e8 00 00 00 00	 call	 pylocaltime
  00074	83 f8 ff	 cmp	 eax, -1
  00077	75 28		 jne	 SHORT $LN22@time_strft
$LN46@time_strft:

; 586  :             return NULL;

  00079	33 c0		 xor	 eax, eax

; 693  : }

  0007b	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00082	41 5f		 pop	 r15
  00084	c3		 ret	 0
$LN25@time_strft:

; 587  :     }
; 588  :     else if (!gettmarg(tup, &buf) || !checktm(&buf))

  00085	48 8d 54 24 28	 lea	 rdx, QWORD PTR buf$[rsp]
  0008a	e8 00 00 00 00	 call	 gettmarg
  0008f	85 c0		 test	 eax, eax
  00091	74 e6		 je	 SHORT $LN46@time_strft
  00093	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  00098	e8 00 00 00 00	 call	 checktm
  0009d	85 c0		 test	 eax, eax
  0009f	74 d8		 je	 SHORT $LN46@time_strft
$LN22@time_strft:

; 589  :         return NULL;
; 590  : 
; 591  : #if defined(_MSC_VER) || defined(sun) || defined(_AIX)
; 592  :     if (buf.tm_year + 1900 < 1 || 9999 < buf.tm_year + 1900) {

  000a1	8b 44 24 3c	 mov	 eax, DWORD PTR buf$[rsp+20]
  000a5	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 8c 1a 02 00
	00		 jl	 $LN19@time_strft
  000b3	3d 0f 27 00 00	 cmp	 eax, 9999		; 0000270fH
  000b8	0f 8f 0f 02 00
	00		 jg	 $LN19@time_strft

; 596  :     }
; 597  : #endif
; 598  : 
; 599  :     /* Normalize tm_isdst just in case someone foolishly implements %Z
; 600  :        based on the assumption that tm_isdst falls within the range of
; 601  :        [-1, 1] */
; 602  :     if (buf.tm_isdst < -1)

  000be	8b 44 24 48	 mov	 eax, DWORD PTR buf$[rsp+32]
  000c2	4c 89 6c 24 58	 mov	 QWORD PTR [rsp+88], r13
  000c7	83 f8 ff	 cmp	 eax, -1
  000ca	7d 0a		 jge	 SHORT $LN18@time_strft

; 603  :         buf.tm_isdst = -1;

  000cc	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR buf$[rsp+32], -1
  000d4	eb 0e		 jmp	 SHORT $LN16@time_strft
$LN18@time_strft:

; 604  :     else if (buf.tm_isdst > 1)

  000d6	b9 01 00 00 00	 mov	 ecx, 1
  000db	3b c1		 cmp	 eax, ecx
  000dd	0f 4f c1	 cmovg	 eax, ecx
  000e0	89 44 24 48	 mov	 DWORD PTR buf$[rsp+32], eax
$LN16@time_strft:

; 605  :         buf.tm_isdst = 1;
; 606  : 
; 607  : #ifdef HAVE_WCSFTIME
; 608  :     format = PyUnicode_AsWideCharString(format_arg, NULL);
; 609  :     if (format == NULL)
; 610  :         return NULL;
; 611  :     fmt = format;
; 612  : #else
; 613  :     /* Convert the unicode string to an ascii one */
; 614  :     format = PyUnicode_EncodeLocale(format_arg, "surrogateescape");

  000e4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR format_arg$[rsp]
  000e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
  000f0	e8 00 00 00 00	 call	 PyUnicode_EncodeLocale
  000f5	4c 8b e8	 mov	 r13, rax

; 615  :     if (format == NULL)

  000f8	48 85 c0	 test	 rax, rax
  000fb	75 0f		 jne	 SHORT $LN15@time_strft
  000fd	4c 8b 6c 24 58	 mov	 r13, QWORD PTR [rsp+88]

; 693  : }

  00102	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00109	41 5f		 pop	 r15
  0010b	c3		 ret	 0
$LN15@time_strft:

; 616  :         return NULL;
; 617  :     fmt = PyBytes_AS_STRING(format);
; 618  : #endif
; 619  : 
; 620  : #if defined(MS_WINDOWS) && !defined(HAVE_WCSFTIME)
; 621  :     /* check that the format string contains only valid directives */
; 622  :     for(outbuf = strchr(fmt, '%');
; 623  :         outbuf != NULL;
; 624  :         outbuf = strchr(outbuf+2, '%'))

  0010c	48 8d 48 78	 lea	 rcx, QWORD PTR [rax+120]
  00110	ba 25 00 00 00	 mov	 edx, 37			; 00000025H
  00115	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  0011a	4c 89 74 24 50	 mov	 QWORD PTR [rsp+80], r14
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  00125	48 8b f8	 mov	 rdi, rax
  00128	48 85 c0	 test	 rax, rax
  0012b	74 5c		 je	 SHORT $LN12@time_strft
  0012d	0f 1f 00	 npad	 3
$LL14@time_strft:

; 625  :     {
; 626  :         if (outbuf[1]=='#')

  00130	80 7f 01 23	 cmp	 BYTE PTR [rdi+1], 35	; 00000023H
  00134	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
  00138	48 0f 44 f9	 cmove	 rdi, rcx

; 627  :             ++outbuf; /* not documented by python, */
; 628  :         if (outbuf[1]=='\0' ||
; 629  :             !strchr("aAbBcdHIjmMpSUwWxXyYzZ%", outbuf[1]))

  0013c	0f b6 47 01	 movzx	 eax, BYTE PTR [rdi+1]
  00140	84 c0		 test	 al, al
  00142	0f 84 45 01 00
	00		 je	 $LN9@time_strft
  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@PAENNBAG@aAbBcdHIjmMpSUwWxXyYzZ?$CF?$AA@
  0014f	0f be d0	 movsx	 edx, al
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  00158	48 85 c0	 test	 rax, rax
  0015b	0f 84 2c 01 00
	00		 je	 $LN9@time_strft

; 634  :         }
; 635  :         if ((outbuf[1] == 'y') && buf.tm_year < 0)

  00161	80 7f 01 79	 cmp	 BYTE PTR [rdi+1], 121	; 00000079H
  00165	75 0b		 jne	 SHORT $LN13@time_strft
  00167	44 39 7c 24 3c	 cmp	 DWORD PTR buf$[rsp+20], r15d
  0016c	0f 8c e5 00 00
	00		 jl	 $LN34@time_strft
$LN13@time_strft:

; 616  :         return NULL;
; 617  :     fmt = PyBytes_AS_STRING(format);
; 618  : #endif
; 619  : 
; 620  : #if defined(MS_WINDOWS) && !defined(HAVE_WCSFTIME)
; 621  :     /* check that the format string contains only valid directives */
; 622  :     for(outbuf = strchr(fmt, '%');
; 623  :         outbuf != NULL;
; 624  :         outbuf = strchr(outbuf+2, '%'))

  00172	48 8d 4f 02	 lea	 rcx, QWORD PTR [rdi+2]
  00176	ba 25 00 00 00	 mov	 edx, 37			; 00000025H
  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  00181	48 8b f8	 mov	 rdi, rax
  00184	48 85 c0	 test	 rax, rax
  00187	75 a7		 jne	 SHORT $LL14@time_strft
$LN12@time_strft:

; 641  :         }
; 642  :     }
; 643  : #endif
; 644  : 
; 645  :     fmtlen = time_strlen(fmt);

  00189	48 83 c9 ff	 or	 rcx, -1
  0018d	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx
  00195	33 c0		 xor	 eax, eax
  00197	48 89 6c 24 78	 mov	 QWORD PTR [rsp+120], rbp
  0019c	49 8d 7d 78	 lea	 rdi, QWORD PTR [r13+120]
  001a0	48 89 74 24 70	 mov	 QWORD PTR [rsp+112], rsi
  001a5	f2 ae		 repne scasb

; 646  : 
; 647  :     /* I hate these functions that presume you know how big the output
; 648  :      * will be ahead of time...
; 649  :      */
; 650  :     for (i = 1024; ; i += i) {

  001a7	bf 00 04 00 00	 mov	 edi, 1024		; 00000400H
  001ac	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  001b1	48 f7 d1	 not	 rcx
  001b4	4c 8d 61 ff	 lea	 r12, QWORD PTR [rcx-1]

; 651  : #if defined _MSC_VER && _MSC_VER >= 1400 && defined(__STDC_SECURE_LIB__)
; 652  :         int err;
; 653  : #endif
; 654  :         outbuf = (time_char *)PyMem_Malloc(i*sizeof(time_char));

  001b8	8b cf		 mov	 ecx, edi
  001ba	e8 00 00 00 00	 call	 PyMem_Malloc
  001bf	48 8b d8	 mov	 rbx, rax

; 655  :         if (outbuf == NULL) {

  001c2	48 85 c0	 test	 rax, rax
  001c5	74 67		 je	 SHORT $LN35@time_strft
  001c7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL7@time_strft:

; 657  :             break;
; 658  :         }
; 659  :         buflen = format_time(outbuf, i, fmt, &buf);

  001d0	4c 8d 4c 24 28	 lea	 r9, QWORD PTR buf$[rsp]
  001d5	4d 8d 45 78	 lea	 r8, QWORD PTR [r13+120]
  001d9	48 8b d7	 mov	 rdx, rdi
  001dc	48 8b cb	 mov	 rcx, rbx
  001df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strftime
  001e5	48 8b f0	 mov	 rsi, rax

; 660  : #if defined _MSC_VER && _MSC_VER >= 1400 && defined(__STDC_SECURE_LIB__)
; 661  :         err = errno;

  001e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001ee	8b 28		 mov	 ebp, DWORD PTR [rax]

; 662  : #endif
; 663  :         if (buflen > 0 || i >= 256 * fmtlen) {

  001f0	48 85 f6	 test	 rsi, rsi
  001f3	0f 85 b2 00 00
	00		 jne	 $LN2@time_strft
  001f9	49 8b cc	 mov	 rcx, r12
  001fc	48 c1 e1 08	 shl	 rcx, 8
  00200	48 3b f9	 cmp	 rdi, rcx
  00203	0f 83 a2 00 00
	00		 jae	 $LN2@time_strft

; 676  :             break;
; 677  :         }
; 678  :         PyMem_Free(outbuf);

  00209	48 8b cb	 mov	 rcx, rbx
  0020c	e8 00 00 00 00	 call	 PyMem_Free

; 679  : #if defined _MSC_VER && _MSC_VER >= 1400 && defined(__STDC_SECURE_LIB__)
; 680  :         /* VisualStudio .NET 2005 does this properly */
; 681  :         if (buflen == 0 && err == EINVAL) {

  00211	48 85 f6	 test	 rsi, rsi
  00214	75 05		 jne	 SHORT $LN6@time_strft
  00216	83 fd 16	 cmp	 ebp, 22
  00219	74 7b		 je	 SHORT $LN37@time_strft
$LN6@time_strft:

; 646  : 
; 647  :     /* I hate these functions that presume you know how big the output
; 648  :      * will be ahead of time...
; 649  :      */
; 650  :     for (i = 1024; ; i += i) {

  0021b	48 03 ff	 add	 rdi, rdi

; 651  : #if defined _MSC_VER && _MSC_VER >= 1400 && defined(__STDC_SECURE_LIB__)
; 652  :         int err;
; 653  : #endif
; 654  :         outbuf = (time_char *)PyMem_Malloc(i*sizeof(time_char));

  0021e	48 8b cf	 mov	 rcx, rdi
  00221	e8 00 00 00 00	 call	 PyMem_Malloc
  00226	48 8b d8	 mov	 rbx, rax

; 655  :         if (outbuf == NULL) {

  00229	48 85 c0	 test	 rax, rax
  0022c	75 a2		 jne	 SHORT $LL7@time_strft
$LN35@time_strft:

; 656  :             PyErr_NoMemory();

  0022e	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN5@time_strft:

; 684  :         }
; 685  : #endif
; 686  :     }
; 687  : #ifdef HAVE_WCSFTIME
; 688  :     PyMem_Free(format);
; 689  : #else
; 690  :     Py_DECREF(format);

  00233	49 8b cd	 mov	 rcx, r13
  00236	e8 00 00 00 00	 call	 _Py_DecRef
  0023b	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]
  00240	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  00245	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  0024a	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]

; 691  : #endif
; 692  :     return ret;

  00252	49 8b c7	 mov	 rax, r15
  00255	eb 1d		 jmp	 SHORT $LN44@time_strft
$LN34@time_strft:

; 636  :         {
; 637  :             PyErr_SetString(PyExc_ValueError,
; 638  :                         "format %y requires year >= 1900 on Windows");

  00257	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@FIDKHLFK@format?5?$CFy?5requires?5year?5?$DO?$DN?51900?5@
$LN45@time_strft:
  0025e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00265	e8 00 00 00 00	 call	 PyErr_SetString

; 639  :             Py_DECREF(format);

  0026a	49 8b cd	 mov	 rcx, r13
  0026d	e8 00 00 00 00	 call	 _Py_DecRef

; 640  :             return NULL;

  00272	33 c0		 xor	 eax, eax
$LN44@time_strft:
  00274	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00279	4c 8b 74 24 50	 mov	 r14, QWORD PTR [rsp+80]
  0027e	4c 8b 6c 24 58	 mov	 r13, QWORD PTR [rsp+88]

; 693  : }

  00283	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0028a	41 5f		 pop	 r15
  0028c	c3		 ret	 0
$LN9@time_strft:

; 630  :         {
; 631  :             PyErr_SetString(PyExc_ValueError, "Invalid format string");

  0028d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@HMAFAPHD@Invalid?5format?5string?$AA@

; 632  :             Py_DECREF(format);
; 633  :             return NULL;

  00294	eb c8		 jmp	 SHORT $LN45@time_strft
$LN37@time_strft:

; 682  :             PyErr_SetString(PyExc_ValueError, "Invalid format string");

  00296	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0029d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@HMAFAPHD@Invalid?5format?5string?$AA@
  002a4	e8 00 00 00 00	 call	 PyErr_SetString

; 683  :             break;

  002a9	eb 88		 jmp	 SHORT $LN5@time_strft
$LN2@time_strft:

; 664  :             /* If the buffer is 256 times as long as the format,
; 665  :                it's probably not failing for lack of room!
; 666  :                More likely, the format yields an empty result,
; 667  :                e.g. an empty format, or %Z when the timezone
; 668  :                is unknown. */
; 669  : #ifdef HAVE_WCSFTIME
; 670  :             ret = PyUnicode_FromWideChar(outbuf, buflen);
; 671  : #else
; 672  :             ret = PyUnicode_DecodeLocaleAndSize(outbuf, buflen,
; 673  :                                                 "surrogateescape");

  002ab	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
  002b2	48 8b d6	 mov	 rdx, rsi
  002b5	48 8b cb	 mov	 rcx, rbx
  002b8	e8 00 00 00 00	 call	 PyUnicode_DecodeLocaleAndSize

; 674  : #endif
; 675  :             PyMem_Free(outbuf);

  002bd	48 8b cb	 mov	 rcx, rbx
  002c0	4c 8b f8	 mov	 r15, rax
  002c3	e8 00 00 00 00	 call	 PyMem_Free
  002c8	e9 66 ff ff ff	 jmp	 $LN5@time_strft
$LN19@time_strft:

; 593  :         PyErr_SetString(PyExc_ValueError,
; 594  :                         "strftime() requires year in [1; 9999]");

  002cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  002d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@HINAEAFH@strftime?$CI?$CJ?5requires?5year?5in?5?$FL1?$DL?5@
  002db	e8 00 00 00 00	 call	 PyErr_SetString

; 595  :         return NULL;

  002e0	33 c0		 xor	 eax, eax

; 693  : }

  002e2	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  002e9	41 5f		 pop	 r15
  002eb	c3		 ret	 0
time_strftime ENDP
_TEXT	ENDS
PUBLIC	??_C@_01MJMHLOMK@O?$AA@				; `string'
PUBLIC	??_C@_09NHHCNPOC@_strptime?$AA@			; `string'
EXTRN	_PyObject_CallMethodId:PROC
EXTRN	PyImport_ImportModuleNoBlock:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_strptime DD imagerel time_strptime
	DD	imagerel time_strptime+111
	DD	imagerel $unwind$time_strptime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_strptime DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_01MJMHLOMK@O?$AA@
CONST	SEGMENT
??_C@_01MJMHLOMK@O?$AA@ DB 'O', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09NHHCNPOC@_strptime?$AA@
CONST	SEGMENT
??_C@_09NHHCNPOC@_strptime?$AA@ DB '_strptime', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT time_strptime
_TEXT	SEGMENT
self$ = 48
args$ = 56
time_strptime PROC					; COMDAT

; 708  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 709  :     PyObject *strptime_module = PyImport_ImportModuleNoBlock("_strptime");

  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09NHHCNPOC@_strptime?$AA@
  00011	48 8b da	 mov	 rbx, rdx
  00014	e8 00 00 00 00	 call	 PyImport_ImportModuleNoBlock
  00019	48 8b f8	 mov	 rdi, rax

; 710  :     PyObject *strptime_result;
; 711  :     _Py_IDENTIFIER(_strptime_time);
; 712  : 
; 713  :     if (!strptime_module)

  0001c	48 85 c0	 test	 rax, rax
  0001f	75 0b		 jne	 SHORT $LN1@time_strpt

; 719  : }

  00021	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5f		 pop	 rdi
  0002b	c3		 ret	 0
$LN1@time_strpt:

; 714  :         return NULL;
; 715  :     strptime_result = _PyObject_CallMethodId(strptime_module,
; 716  :                                              &PyId__strptime_time, "O", args);

  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00032	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0003b	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId__strptime_time@?1??time_strptime@@9@9
  00040	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00044	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  0004b	4c 8b cb	 mov	 r9, rbx
  0004e	48 8b cf	 mov	 rcx, rdi
  00051	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 717  :     Py_DECREF(strptime_module);

  00056	48 8b cf	 mov	 rcx, rdi
  00059	48 8b d8	 mov	 rbx, rax
  0005c	e8 00 00 00 00	 call	 _Py_DecRef

; 718  :     return strptime_result;

  00061	48 8b c3	 mov	 rax, rbx

; 719  : }

  00064	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00069	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
time_strptime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@HJNEELDC@?$CFs?5?$CFs?$CF3d?5?$CF?42d?3?$CF?42d?3?$CF?42d?5?$CFd?$AA@ ; `string'
EXTRN	PyUnicode_FromFormat:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$_asctime DD imagerel _asctime
	DD	imagerel _asctime+92
	DD	imagerel $unwind$_asctime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_asctime DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_0BL@HJNEELDC@?$CFs?5?$CFs?$CF3d?5?$CF?42d?3?$CF?42d?3?$CF?42d?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BL@HJNEELDC@?$CFs?5?$CFs?$CF3d?5?$CF?42d?3?$CF?42d?3?$CF?42d?5?$CFd?$AA@ DB '%'
	DB	's %s%3d %.2d:%.2d:%.2d %d', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _asctime
_TEXT	SEGMENT
timeptr$ = 80
_asctime PROC						; COMDAT

; 730  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 731  :     /* Inspired by Open Group reference implementation available at
; 732  :      * http://pubs.opengroup.org/onlinepubs/009695399/functions/asctime.html */
; 733  :     static char wday_name[7][4] = {
; 734  :         "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
; 735  :     };
; 736  :     static char mon_name[12][4] = {
; 737  :         "Jan", "Feb", "Mar", "Apr", "May", "Jun",
; 738  :         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
; 739  :     };
; 740  :     return PyUnicode_FromFormat(
; 741  :         "%s %s%3d %.2d:%.2d:%.2d %d",
; 742  :         wday_name[timeptr->tm_wday],
; 743  :         mon_name[timeptr->tm_mon],
; 744  :         timeptr->tm_mday, timeptr->tm_hour,
; 745  :         timeptr->tm_min, timeptr->tm_sec,
; 746  :         1900 + timeptr->tm_year);

  00004	48 63 41 10	 movsxd	 rax, DWORD PTR [rcx+16]
  00008	44 8b 49 14	 mov	 r9d, DWORD PTR [rcx+20]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00013	4c 8d 84 82 00
	00 00 00	 lea	 r8, QWORD PTR ?mon_name@?1??_asctime@@9@9[rdx+rax*4]
  0001b	48 63 41 18	 movsxd	 rax, DWORD PTR [rcx+24]
  0001f	41 81 c1 6c 07
	00 00		 add	 r9d, 1900		; 0000076cH
  00026	44 89 4c 24 38	 mov	 DWORD PTR [rsp+56], r9d
  0002b	44 8b 49 0c	 mov	 r9d, DWORD PTR [rcx+12]
  0002f	48 8d 94 82 00
	00 00 00	 lea	 rdx, QWORD PTR ?wday_name@?1??_asctime@@9@9[rdx+rax*4]
  00037	8b 01		 mov	 eax, DWORD PTR [rcx]
  00039	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0003d	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]
  00040	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00044	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@HJNEELDC@?$CFs?5?$CFs?$CF3d?5?$CF?42d?3?$CF?42d?3?$CF?42d?5?$CFd?$AA@
  0004e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00052	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 747  : }

  00057	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005b	c3		 ret	 0
_asctime ENDP
_TEXT	ENDS
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
pdata	SEGMENT
$pdata$time_asctime DD imagerel time_asctime
	DD	imagerel time_asctime+154
	DD	imagerel $unwind$time_asctime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_asctime DD 010701H
	DD	0c207H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\timemodule.c
xdata	ENDS
;	COMDAT time_asctime
_TEXT	SEGMENT
buf$ = 48
self$ = 112
args$ = 120
tup$ = 128
tt$63898 = 136
time_asctime PROC					; COMDAT

; 751  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 752  :     PyObject *tup = NULL;
; 753  :     struct tm buf;
; 754  : 
; 755  :     if (!PyArg_UnpackTuple(args, "asctime", 0, 1, &tup))

  00007	49 8d 4b 18	 lea	 rcx, QWORD PTR [r11+24]
  0000b	48 8b c2	 mov	 rax, rdx
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07MHIFAOOG@asctime?$AA@
  00015	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  00019	41 b9 01 00 00
	00		 mov	 r9d, 1
  0001f	45 33 c0	 xor	 r8d, r8d
  00022	48 8b c8	 mov	 rcx, rax
  00025	49 c7 43 18 00
	00 00 00	 mov	 QWORD PTR [r11+24], 0
  0002d	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00032	85 c0		 test	 eax, eax

; 756  :         return NULL;

  00034	74 32		 je	 SHORT $LN1@time_ascti

; 757  :     if (tup == NULL) {

  00036	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tup$[rsp]
  0003e	48 85 c9	 test	 rcx, rcx
  00041	75 2c		 jne	 SHORT $LN5@time_ascti

; 758  :         time_t tt = time(NULL);

  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 759  :         if (pylocaltime(&tt, &buf) == -1)

  00049	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  0004e	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR tt$63898[rsp]
  00056	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tt$63898[rsp], rax
  0005e	e8 00 00 00 00	 call	 pylocaltime
  00063	83 f8 ff	 cmp	 eax, -1
  00066	75 23		 jne	 SHORT $LN2@time_ascti
$LN1@time_ascti:

; 763  :         return NULL;

  00068	33 c0		 xor	 eax, eax

; 765  : }

  0006a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0006e	c3		 ret	 0
$LN5@time_ascti:

; 760  :             return NULL;
; 761  : 
; 762  :     } else if (!gettmarg(tup, &buf) || !checktm(&buf))

  0006f	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  00074	e8 00 00 00 00	 call	 gettmarg
  00079	85 c0		 test	 eax, eax
  0007b	74 eb		 je	 SHORT $LN1@time_ascti
  0007d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  00082	e8 00 00 00 00	 call	 checktm
  00087	85 c0		 test	 eax, eax
  00089	74 dd		 je	 SHORT $LN1@time_ascti
$LN2@time_ascti:

; 764  :     return _asctime(&buf);

  0008b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  00090	e8 00 00 00 00	 call	 _asctime

; 765  : }

  00095	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00099	c3		 ret	 0
time_asctime ENDP
_TEXT	ENDS
PUBLIC	??_C@_08GPFGLFCO@?$HMO?3ctime?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_ctime DD imagerel time_ctime
	DD	imagerel time_ctime+70
	DD	imagerel $unwind$time_ctime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_ctime DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_08GPFGLFCO@?$HMO?3ctime?$AA@
CONST	SEGMENT
??_C@_08GPFGLFCO@?$HMO?3ctime?$AA@ DB '|O:ctime', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT time_ctime
_TEXT	SEGMENT
buf$ = 32
self$ = 96
args$ = 104
tt$ = 112
time_ctime PROC						; COMDAT

; 776  : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 777  :     time_t tt;
; 778  :     struct tm buf;
; 779  :     if (!parse_time_t_args(args, "|O:ctime", &tt))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 70	 lea	 r8, QWORD PTR tt$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08GPFGLFCO@?$HMO?3ctime?$AA@
  00013	e8 00 00 00 00	 call	 parse_time_t_args
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN2@time_ctime
$LN5@time_ctime:

; 780  :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 784  : }

  0001e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00022	c3		 ret	 0
$LN2@time_ctime:

; 781  :     if (pylocaltime(&tt, &buf) == -1)

  00023	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
  00028	48 8d 4c 24 70	 lea	 rcx, QWORD PTR tt$[rsp]
  0002d	e8 00 00 00 00	 call	 pylocaltime
  00032	83 f8 ff	 cmp	 eax, -1

; 782  :         return NULL;

  00035	74 e5		 je	 SHORT $LN5@time_ctime

; 783  :     return _asctime(&buf);

  00037	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0003c	e8 00 00 00 00	 call	 _asctime

; 784  : }

  00041	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00045	c3		 ret	 0
time_ctime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@HBGMICKE@mktime?5argument?5out?5of?5range?$AA@ ; `string'
EXTRN	PyExc_OverflowError:QWORD
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
pdata	SEGMENT
$pdata$time_mktime DD imagerel time_mktime
	DD	imagerel time_mktime+97
	DD	imagerel $unwind$time_mktime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_mktime DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0BN@HBGMICKE@mktime?5argument?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BN@HBGMICKE@mktime?5argument?5out?5of?5range?$AA@ DB 'mktime argum'
	DB	'ent out of range', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\timemodule.c
CONST	ENDS
;	COMDAT time_mktime
_TEXT	SEGMENT
buf$ = 32
self$ = 96
tup$ = 104
time_mktime PROC					; COMDAT

; 796  : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 797  :     struct tm buf;
; 798  :     time_t tt;
; 799  :     if (!gettmarg(tup, &buf))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
  0000c	e8 00 00 00 00	 call	 gettmarg
  00011	85 c0		 test	 eax, eax

; 800  :         return NULL;

  00013	74 32		 je	 SHORT $LN7@time_mktim

; 801  :     buf.tm_wday = -1;  /* sentinel; original value ignored */
; 802  :     tt = mktime(&buf);

  00015	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0001a	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR buf$[rsp+24], -1
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__mktime64

; 803  :     /* Return value of -1 does not necessarily mean an error, but tm_wday
; 804  :      * cannot remain set to -1 if mktime succeeded. */
; 805  :     if (tt == (time_t)(-1) && buf.tm_wday == -1) {

  00028	48 83 f8 ff	 cmp	 rax, -1
  0002c	75 20		 jne	 SHORT $LN1@time_mktim
  0002e	39 44 24 38	 cmp	 DWORD PTR buf$[rsp+24], eax
  00032	75 1a		 jne	 SHORT $LN1@time_mktim

; 806  :         PyErr_SetString(PyExc_OverflowError,
; 807  :                         "mktime argument out of range");

  00034	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@HBGMICKE@mktime?5argument?5out?5of?5range?$AA@
  00042	e8 00 00 00 00	 call	 PyErr_SetString
$LN7@time_mktim:

; 808  :         return NULL;

  00047	33 c0		 xor	 eax, eax

; 811  : }

  00049	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0004d	c3		 ret	 0
$LN1@time_mktim:

; 809  :     }
; 810  :     return PyFloat_FromDouble((double)tt);

  0004e	66 0f ef c0	 pxor	 xmm0, xmm0
  00052	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00057	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 811  : }

  0005c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00060	c3		 ret	 0
time_mktime ENDP
_TEXT	ENDS
PUBLIC	__real@3e7ad7f29abcaf48
PUBLIC	__real@43f0000000000000
PUBLIC	??_C@_0BB@GFOJHMDJ@GetTickCount64?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0P@MKKDAFMJ@GetTickCount?$CI?$CJ?$AA@	; `string'
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	??_C@_0P@CDHHOHKP@GetTickCount64?$AA@		; `string'
PUBLIC	??_C@_1BC@EKMDCNOB@?$AAK?$AAE?$AAR?$AAN?$AAE?$AAL?$AA3?$AA2?$AA?$AA@ ; `string'
EXTRN	PyErr_SetFromWindowsErr:PROC
EXTRN	__imp_GetSystemTimeAdjustment:PROC
EXTRN	__imp_ldexp:PROC
EXTRN	__imp_GetTickCount:PROC
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_GetModuleHandleW:PROC
_BSS	SEGMENT
?Py_GetTickCount64@?1??pymonotonic@@9@9 DQ 01H DUP (?)	; `pymonotonic'::`2'::Py_GetTickCount64
winver	DB	09cH DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pymonotonic DD imagerel pymonotonic
	DD	imagerel pymonotonic+106
	DD	imagerel $unwind$pymonotonic
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pymonotonic DD imagerel pymonotonic+106
	DD	imagerel pymonotonic+191
	DD	imagerel $chain$0$pymonotonic
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$pymonotonic DD imagerel pymonotonic+191
	DD	imagerel pymonotonic+389
	DD	imagerel $chain$1$pymonotonic
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$pymonotonic DD 021H
	DD	imagerel pymonotonic
	DD	imagerel pymonotonic+106
	DD	imagerel $unwind$pymonotonic
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pymonotonic DD 020521H
	DD	0b7405H
	DD	imagerel pymonotonic
	DD	imagerel pymonotonic+106
	DD	imagerel $unwind$pymonotonic
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pymonotonic DD 041101H
	DD	026811H
	DD	030025206H
xdata	ENDS
;	COMDAT __real@3e7ad7f29abcaf48
CONST	SEGMENT
__real@3e7ad7f29abcaf48 DQ 03e7ad7f29abcaf48r	; 1e-007
CONST	ENDS
;	COMDAT __real@43f0000000000000
CONST	SEGMENT
__real@43f0000000000000 DQ 043f0000000000000r	; 1.84467e+019
CONST	ENDS
;	COMDAT ??_C@_0BB@GFOJHMDJ@GetTickCount64?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BB@GFOJHMDJ@GetTickCount64?$CI?$CJ?$AA@ DB 'GetTickCount64()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MKKDAFMJ@GetTickCount?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0P@MKKDAFMJ@GetTickCount?$CI?$CJ?$AA@ DB 'GetTickCount()', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3f50624dd2f1a9fc
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
CONST	ENDS
;	COMDAT ??_C@_0P@CDHHOHKP@GetTickCount64?$AA@
CONST	SEGMENT
??_C@_0P@CDHHOHKP@GetTickCount64?$AA@ DB 'GetTickCount64', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@EKMDCNOB@?$AAK?$AAE?$AAR?$AAN?$AAE?$AAL?$AA3?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@EKMDCNOB@?$AAK?$AAE?$AAR?$AAN?$AAE?$AAL?$AA3?$AA2?$AA?$AA@ DB 'K'
	DB	00H, 'E', 00H, 'R', 00H, 'N', 00H, 'E', 00H, 'L', 00H, '3', 00H
	DB	'2', 00H, 00H, 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT pymonotonic
_TEXT	SEGMENT
timeIncrement$63972 = 64
info$ = 64
isTimeAdjustmentDisabled$63973 = 72
timeAdjustment$63971 = 80
pymonotonic PROC					; COMDAT

; 868  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 869  : #if defined(MS_WINDOWS)
; 870  :     static ULONGLONG (*GetTickCount64) (void) = NULL;
; 871  :     static ULONGLONG (CALLBACK *Py_GetTickCount64)(void);
; 872  :     static int has_getickcount64 = -1;
; 873  :     double result;
; 874  : 
; 875  :     if (has_getickcount64 == -1) {

  00006	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?has_getickcount64@?1??pymonotonic@@9@9
  0000c	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  00011	48 8b d9	 mov	 rbx, rcx
  00014	83 f8 ff	 cmp	 eax, -1
  00017	0f 85 03 01 00
	00		 jne	 $LN14@pymonotoni

; 876  :         /* GetTickCount64() was added to Windows Vista */
; 877  :         if (winver.dwMajorVersion >= 6) {

  0001d	83 3d 04 00 00
	00 06		 cmp	 DWORD PTR winver+4, 6
  00024	72 3a		 jb	 SHORT $LN9@pymonotoni

; 878  :             HINSTANCE hKernel32;
; 879  :             hKernel32 = GetModuleHandleW(L"KERNEL32");

  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@EKMDCNOB@?$AAK?$AAE?$AAR?$AAN?$AAE?$AAL?$AA3?$AA2?$AA?$AA@
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleW

; 880  :             *(FARPROC*)&Py_GetTickCount64 = GetProcAddress(hKernel32,
; 881  :                                                            "GetTickCount64");

  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@CDHHOHKP@GetTickCount64?$AA@
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00043	4c 8b d8	 mov	 r11, rax
  00046	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?Py_GetTickCount64@?1??pymonotonic@@9@9, rax

; 882  :             has_getickcount64 = (Py_GetTickCount64 != NULL);

  0004d	33 c0		 xor	 eax, eax
  0004f	4d 85 db	 test	 r11, r11
  00052	0f 95 c0	 setne	 al
  00055	89 05 00 00 00
	00		 mov	 DWORD PTR ?has_getickcount64@?1??pymonotonic@@9@9, eax

; 883  :         }
; 884  :         else

  0005b	e9 c7 00 00 00	 jmp	 $LN8@pymonotoni
$LN9@pymonotoni:

; 885  :             has_getickcount64 = 0;

  00060	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?has_getickcount64@?1??pymonotonic@@9@9, 0
$LN7@pymonotoni:
  0006a	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi

; 894  :         static DWORD last_ticks = 0;
; 895  :         static DWORD n_overflow = 0;
; 896  :         DWORD ticks;
; 897  : 
; 898  :         ticks = GetTickCount();

  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount

; 899  :         if (ticks < last_ticks)
; 900  :             n_overflow++;

  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?n_overflow@?5??pymonotonic@@9@9
  0007b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?last_ticks@?5??pymonotonic@@9@9
  00081	8b f8		 mov	 edi, eax
  00083	73 08		 jae	 SHORT $LN5@pymonotoni
  00085	ff c1		 inc	 ecx
  00087	89 0d 00 00 00
	00		 mov	 DWORD PTR ?n_overflow@?5??pymonotonic@@9@9, ecx
$LN5@pymonotoni:

; 901  :         last_ticks = ticks;
; 902  : 
; 903  :         result = ldexp(n_overflow, 32);
; 904  :         result += ticks;
; 905  :         result *= 1e-3;

  0008d	66 0f ef c0	 pxor	 xmm0, xmm0
  00091	8b c1		 mov	 eax, ecx
  00093	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00098	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0009d	89 3d 00 00 00
	00		 mov	 DWORD PTR ?last_ticks@?5??pymonotonic@@9@9, edi
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  000a9	66 0f 28 f0	 movapd	 xmm6, xmm0
  000ad	66 0f ef c0	 pxor	 xmm0, xmm0
  000b1	f2 48 0f 2a c7	 cvtsi2sd xmm0, rdi
  000b6	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000bb	f2 0f 58 f0	 addsd	 xmm6, xmm0
$LN13@pymonotoni:
  000bf	f2 0f 59 35 00
	00 00 00	 mulsd	 xmm6, QWORD PTR __real@3f50624dd2f1a9fc

; 906  :     }
; 907  : 
; 908  :     if (info) {

  000c7	48 85 db	 test	 rbx, rbx
  000ca	0f 84 a2 00 00
	00		 je	 $LN4@pymonotoni

; 909  :         DWORD timeAdjustment, timeIncrement;
; 910  :         BOOL isTimeAdjustmentDisabled, ok;
; 911  :         if (has_getickcount64)

  000d0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?has_getickcount64@?1??pymonotonic@@9@9, 0
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@MKKDAFMJ@GetTickCount?$CI?$CJ?$AA@
  000de	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BB@GFOJHMDJ@GetTickCount64?$CI?$CJ?$AA@
  000e5	48 0f 44 c1	 cmove	 rax, rcx

; 912  :             info->implementation = "GetTickCount64()";
; 913  :         else
; 914  :             info->implementation = "GetTickCount()";
; 915  :         info->monotonic = 1;
; 916  :         ok = GetSystemTimeAdjustment(&timeAdjustment, &timeIncrement,
; 917  :                                      &isTimeAdjustmentDisabled);

  000e9	4c 8d 44 24 48	 lea	 r8, QWORD PTR isTimeAdjustmentDisabled$63973[rsp]
  000ee	48 8d 54 24 40	 lea	 rdx, QWORD PTR timeIncrement$63972[rsp]
  000f3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR timeAdjustment$63971[rsp]
  000f8	c7 43 08 01 00
	00 00		 mov	 DWORD PTR [rbx+8], 1
  000ff	48 89 03	 mov	 QWORD PTR [rbx], rax
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetSystemTimeAdjustment

; 918  :         if (!ok) {

  00108	85 c0		 test	 eax, eax
  0010a	75 45		 jne	 SHORT $LN1@pymonotoni

; 919  :             PyErr_SetFromWindowsErr(0);

  0010c	33 c9		 xor	 ecx, ecx
  0010e	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr

; 920  :             return NULL;

  00113	33 c0		 xor	 eax, eax

; 926  : 
; 927  : #elif defined(__APPLE__)
; 928  :     static mach_timebase_info_data_t timebase;
; 929  :     uint64_t time;
; 930  :     double secs;
; 931  : 
; 932  :     if (timebase.denom == 0) {
; 933  :         /* According to the Technical Q&A QA1398, mach_timebase_info() cannot
; 934  :            fail: https://developer.apple.com/library/mac/#qa/qa1398/ */
; 935  :         (void)mach_timebase_info(&timebase);
; 936  :     }
; 937  : 
; 938  :     time = mach_absolute_time();
; 939  :     secs = (double)time * timebase.numer / timebase.denom * 1e-9;
; 940  :     if (info) {
; 941  :         info->implementation = "mach_absolute_time()";
; 942  :         info->resolution = (double)timebase.numer / timebase.denom * 1e-9;
; 943  :         info->monotonic = 1;
; 944  :         info->adjustable = 0;
; 945  :     }
; 946  :     return PyFloat_FromDouble(secs);
; 947  : 
; 948  : #elif defined(HAVE_CLOCK_GETTIME) && (defined(CLOCK_HIGHRES) || defined(CLOCK_MONOTONIC))
; 949  :     struct timespec tp;
; 950  : #ifdef CLOCK_HIGHRES
; 951  :     const clockid_t clk_id = CLOCK_HIGHRES;
; 952  :     const char *function = "clock_gettime(CLOCK_HIGHRES)";
; 953  : #else
; 954  :     const clockid_t clk_id = CLOCK_MONOTONIC;
; 955  :     const char *function = "clock_gettime(CLOCK_MONOTONIC)";
; 956  : #endif
; 957  : 
; 958  :     if (clock_gettime(clk_id, &tp) != 0) {
; 959  :         PyErr_SetFromErrno(PyExc_OSError);
; 960  :         return NULL;
; 961  :     }
; 962  : 
; 963  :     if (info) {
; 964  :         struct timespec res;
; 965  :         info->monotonic = 1;
; 966  :         info->implementation = function;
; 967  :         info->adjustable = 0;
; 968  :         if (clock_getres(clk_id, &res) == 0)
; 969  :             info->resolution = res.tv_sec + res.tv_nsec * 1e-9;
; 970  :         else
; 971  :             info->resolution = 1e-9;
; 972  :     }
; 973  :     return PyFloat_FromDouble(tp.tv_sec + tp.tv_nsec * 1e-9);
; 974  : #endif
; 975  : }

  00115	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0011a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011e	5b		 pop	 rbx
  0011f	c3		 ret	 0
$LN14@pymonotoni:

; 886  :     }
; 887  : 
; 888  :     if (has_getickcount64) {

  00120	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR ?Py_GetTickCount64@?1??pymonotonic@@9@9
$LN8@pymonotoni:
  00127	85 c0		 test	 eax, eax
  00129	0f 84 3b ff ff
	ff		 je	 $LN7@pymonotoni

; 889  :         ULONGLONG ticks;
; 890  :         ticks = Py_GetTickCount64();

  0012f	41 ff d3	 call	 r11

; 891  :         result = (double)ticks * 1e-3;

  00132	66 0f ef f6	 pxor	 xmm6, xmm6
  00136	f2 48 0f 2a f0	 cvtsi2sd xmm6, rax
  0013b	48 85 c0	 test	 rax, rax
  0013e	0f 89 7b ff ff
	ff		 jns	 $LN13@pymonotoni
  00144	f2 0f 58 35 00
	00 00 00	 addsd	 xmm6, QWORD PTR __real@43f0000000000000

; 892  :     }
; 893  :     else {

  0014c	e9 6e ff ff ff	 jmp	 $LN13@pymonotoni
$LN1@pymonotoni:

; 921  :         }
; 922  :         info->resolution = timeIncrement * 1e-7;

  00151	8b 44 24 40	 mov	 eax, DWORD PTR timeIncrement$63972[rsp]
  00155	66 0f ef c9	 pxor	 xmm1, xmm1

; 923  :         info->adjustable = 0;

  00159	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [rbx+12], 0
  00160	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  00165	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3e7ad7f29abcaf48
  0016d	f2 0f 11 4b 10	 movsdx	 QWORD PTR [rbx+16], xmm1
$LN4@pymonotoni:

; 924  :     }
; 925  :     return PyFloat_FromDouble(result);

  00172	66 0f 28 c6	 movapd	 xmm0, xmm6

; 926  : 
; 927  : #elif defined(__APPLE__)
; 928  :     static mach_timebase_info_data_t timebase;
; 929  :     uint64_t time;
; 930  :     double secs;
; 931  : 
; 932  :     if (timebase.denom == 0) {
; 933  :         /* According to the Technical Q&A QA1398, mach_timebase_info() cannot
; 934  :            fail: https://developer.apple.com/library/mac/#qa/qa1398/ */
; 935  :         (void)mach_timebase_info(&timebase);
; 936  :     }
; 937  : 
; 938  :     time = mach_absolute_time();
; 939  :     secs = (double)time * timebase.numer / timebase.denom * 1e-9;
; 940  :     if (info) {
; 941  :         info->implementation = "mach_absolute_time()";
; 942  :         info->resolution = (double)timebase.numer / timebase.denom * 1e-9;
; 943  :         info->monotonic = 1;
; 944  :         info->adjustable = 0;
; 945  :     }
; 946  :     return PyFloat_FromDouble(secs);
; 947  : 
; 948  : #elif defined(HAVE_CLOCK_GETTIME) && (defined(CLOCK_HIGHRES) || defined(CLOCK_MONOTONIC))
; 949  :     struct timespec tp;
; 950  : #ifdef CLOCK_HIGHRES
; 951  :     const clockid_t clk_id = CLOCK_HIGHRES;
; 952  :     const char *function = "clock_gettime(CLOCK_HIGHRES)";
; 953  : #else
; 954  :     const clockid_t clk_id = CLOCK_MONOTONIC;
; 955  :     const char *function = "clock_gettime(CLOCK_MONOTONIC)";
; 956  : #endif
; 957  : 
; 958  :     if (clock_gettime(clk_id, &tp) != 0) {
; 959  :         PyErr_SetFromErrno(PyExc_OSError);
; 960  :         return NULL;
; 961  :     }
; 962  : 
; 963  :     if (info) {
; 964  :         struct timespec res;
; 965  :         info->monotonic = 1;
; 966  :         info->implementation = function;
; 967  :         info->adjustable = 0;
; 968  :         if (clock_getres(clk_id, &res) == 0)
; 969  :             info->resolution = res.tv_sec + res.tv_nsec * 1e-9;
; 970  :         else
; 971  :             info->resolution = 1e-9;
; 972  :     }
; 973  :     return PyFloat_FromDouble(tp.tv_sec + tp.tv_nsec * 1e-9);
; 974  : #endif
; 975  : }

  00176	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0017b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0017f	5b		 pop	 rbx
  00180	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
pymonotonic ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT time_monotonic
_TEXT	SEGMENT
self$ = 8
unused$ = 16
time_monotonic PROC					; COMDAT

; 980  :     return pymonotonic(NULL);

  00000	33 c9		 xor	 ecx, ecx

; 981  : }

  00002	e9 00 00 00 00	 jmp	 pymonotonic
time_monotonic ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@GIDHEAGA@GetProcessTimes?$CI?$CJ?$AA@	; `string'
EXTRN	__imp_GetProcessTimes:PROC
EXTRN	__imp_GetCurrentProcess:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$py_process_time DD imagerel py_process_time
	DD	imagerel py_process_time+212
	DD	imagerel $unwind$py_process_time
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$py_process_time DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT ??_C@_0BC@GIDHEAGA@GetProcessTimes?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@GIDHEAGA@GetProcessTimes?$CI?$CJ?$AA@ DB 'GetProcessTimes()', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT py_process_time
_TEXT	SEGMENT
exit_time$ = 48
creation_time$ = 56
info$ = 80
large$ = 88
kernel_time$ = 96
user_time$ = 104
py_process_time PROC					; COMDAT

; 1036 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8b d9	 mov	 rbx, rcx

; 1037 : #if defined(MS_WINDOWS)
; 1038 :     HANDLE process;
; 1039 :     FILETIME creation_time, exit_time, kernel_time, user_time;
; 1040 :     ULARGE_INTEGER large;
; 1041 :     double total;
; 1042 :     BOOL ok;
; 1043 : 
; 1044 :     process = GetCurrentProcess();

  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentProcess

; 1045 :     ok = GetProcessTimes(process, &creation_time, &exit_time, &kernel_time, &user_time);

  0000f	48 8d 4c 24 68	 lea	 rcx, QWORD PTR user_time$[rsp]
  00014	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00019	4c 8d 4c 24 60	 lea	 r9, QWORD PTR kernel_time$[rsp]
  0001e	4c 8d 44 24 30	 lea	 r8, QWORD PTR exit_time$[rsp]
  00023	48 8d 54 24 38	 lea	 rdx, QWORD PTR creation_time$[rsp]
  00028	48 8b c8	 mov	 rcx, rax
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcessTimes

; 1046 :     if (!ok)

  00031	85 c0		 test	 eax, eax
  00033	75 0d		 jne	 SHORT $LN2@py_process

; 1047 :         return PyErr_SetFromWindowsErr(0);

  00035	33 c9		 xor	 ecx, ecx
  00037	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr

; 1062 : #else
; 1063 : 
; 1064 : #if defined(HAVE_SYS_RESOURCE_H)
; 1065 :     struct rusage ru;
; 1066 : #endif
; 1067 : #ifdef HAVE_TIMES
; 1068 :     struct tms t;
; 1069 :     static long ticks_per_second = -1;
; 1070 : #endif
; 1071 : 
; 1072 : #if defined(HAVE_CLOCK_GETTIME) \
; 1073 :     && (defined(CLOCK_PROCESS_CPUTIME_ID) || defined(CLOCK_PROF))
; 1074 :     struct timespec tp;
; 1075 : #ifdef CLOCK_PROF
; 1076 :     const clockid_t clk_id = CLOCK_PROF;
; 1077 :     const char *function = "clock_gettime(CLOCK_PROF)";
; 1078 : #else
; 1079 :     const clockid_t clk_id = CLOCK_PROCESS_CPUTIME_ID;
; 1080 :     const char *function = "clock_gettime(CLOCK_PROCESS_CPUTIME_ID)";
; 1081 : #endif
; 1082 : 
; 1083 :     if (clock_gettime(clk_id, &tp) == 0) {
; 1084 :         if (info) {
; 1085 :             struct timespec res;
; 1086 :             info->implementation = function;
; 1087 :             info->monotonic = 1;
; 1088 :             info->adjustable = 0;
; 1089 :             if (clock_getres(clk_id, &res) == 0)
; 1090 :                 info->resolution = res.tv_sec + res.tv_nsec * 1e-9;
; 1091 :             else
; 1092 :                 info->resolution = 1e-9;
; 1093 :         }
; 1094 :         return PyFloat_FromDouble(tp.tv_sec + tp.tv_nsec * 1e-9);
; 1095 :     }
; 1096 : #endif
; 1097 : 
; 1098 : #if defined(HAVE_SYS_RESOURCE_H)
; 1099 :     if (getrusage(RUSAGE_SELF, &ru) == 0) {
; 1100 :         double total;
; 1101 :         total = ru.ru_utime.tv_sec + ru.ru_utime.tv_usec * 1e-6;
; 1102 :         total += ru.ru_stime.tv_sec + ru.ru_stime.tv_usec * 1e-6;
; 1103 :         if (info) {
; 1104 :             info->implementation = "getrusage(RUSAGE_SELF)";
; 1105 :             info->monotonic = 1;
; 1106 :             info->adjustable = 0;
; 1107 :             info->resolution = 1e-6;
; 1108 :         }
; 1109 :         return PyFloat_FromDouble(total);
; 1110 :     }
; 1111 : #endif
; 1112 : 
; 1113 : #ifdef HAVE_TIMES
; 1114 :     if (times(&t) != (clock_t)-1) {
; 1115 :         double total;
; 1116 : 
; 1117 :         if (ticks_per_second == -1) {
; 1118 : #if defined(HAVE_SYSCONF) && defined(_SC_CLK_TCK)
; 1119 :             ticks_per_second = sysconf(_SC_CLK_TCK);
; 1120 :             if (ticks_per_second < 1)
; 1121 :                 ticks_per_second = -1;
; 1122 : #elif defined(HZ)
; 1123 :             ticks_per_second = HZ;
; 1124 : #else
; 1125 :             ticks_per_second = 60; /* magic fallback value; may be bogus */
; 1126 : #endif
; 1127 :         }
; 1128 : 
; 1129 :         if (ticks_per_second != -1) {
; 1130 :             total = (double)t.tms_utime / ticks_per_second;
; 1131 :             total += (double)t.tms_stime / ticks_per_second;
; 1132 :             if (info) {
; 1133 :                 info->implementation = "times()";
; 1134 :                 info->monotonic = 1;
; 1135 :                 info->adjustable = 0;
; 1136 :                 info->resolution = 1.0 / ticks_per_second;
; 1137 :             }
; 1138 :             return PyFloat_FromDouble(total);
; 1139 :         }
; 1140 :     }
; 1141 : #endif
; 1142 : 
; 1143 :     return floatclock(info);
; 1144 : #endif
; 1145 : }

  0003c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00040	5b		 pop	 rbx
  00041	c3		 ret	 0
$LN2@py_process:

; 1048 : 
; 1049 :     large.u.LowPart = kernel_time.dwLowDateTime;

  00042	8b 44 24 60	 mov	 eax, DWORD PTR kernel_time$[rsp]

; 1050 :     large.u.HighPart = kernel_time.dwHighDateTime;
; 1051 :     total = (double)large.QuadPart;

  00046	f2 0f 10 15 00
	00 00 00	 movsdx	 xmm2, QWORD PTR __real@43f0000000000000
  0004e	66 0f ef c0	 pxor	 xmm0, xmm0
  00052	89 44 24 58	 mov	 DWORD PTR large$[rsp], eax
  00056	8b 44 24 64	 mov	 eax, DWORD PTR kernel_time$[rsp+4]
  0005a	89 44 24 5c	 mov	 DWORD PTR large$[rsp+4], eax
  0005e	48 8b 44 24 58	 mov	 rax, QWORD PTR large$[rsp]
  00063	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00068	48 85 c0	 test	 rax, rax
  0006b	79 04		 jns	 SHORT $LN6@py_process
  0006d	f2 0f 58 c2	 addsd	 xmm0, xmm2
$LN6@py_process:

; 1052 :     large.u.LowPart = user_time.dwLowDateTime;

  00071	8b 44 24 68	 mov	 eax, DWORD PTR user_time$[rsp]

; 1053 :     large.u.HighPart = user_time.dwHighDateTime;
; 1054 :     total += (double)large.QuadPart;

  00075	66 0f ef c9	 pxor	 xmm1, xmm1
  00079	89 44 24 58	 mov	 DWORD PTR large$[rsp], eax
  0007d	8b 44 24 6c	 mov	 eax, DWORD PTR user_time$[rsp+4]
  00081	89 44 24 5c	 mov	 DWORD PTR large$[rsp+4], eax
  00085	48 8b 44 24 58	 mov	 rax, QWORD PTR large$[rsp]
  0008a	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  0008f	48 85 c0	 test	 rax, rax
  00092	79 04		 jns	 SHORT $LN5@py_process
  00094	f2 0f 58 ca	 addsd	 xmm1, xmm2
$LN5@py_process:
  00098	f2 0f 58 c1	 addsd	 xmm0, xmm1

; 1055 :     if (info) {

  0009c	48 85 db	 test	 rbx, rbx
  0009f	74 20		 je	 SHORT $LN1@py_process

; 1056 :         info->implementation = "GetProcessTimes()";

  000a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@GIDHEAGA@GetProcessTimes?$CI?$CJ?$AA@

; 1057 :         info->resolution = 1e-7;
; 1058 :         info->monotonic = 1;

  000a8	48 c7 43 08 01
	00 00 00	 mov	 QWORD PTR [rbx+8], 1
  000b0	48 89 03	 mov	 QWORD PTR [rbx], rax
  000b3	48 b8 48 af bc
	9a f2 d7 7a 3e	 mov	 rax, 4502148214488346440 ; 3e7ad7f29abcaf48H
  000bd	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
$LN1@py_process:

; 1059 :         info->adjustable = 0;
; 1060 :     }
; 1061 :     return PyFloat_FromDouble(total * 1e-7);

  000c1	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3e7ad7f29abcaf48
  000c9	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 1062 : #else
; 1063 : 
; 1064 : #if defined(HAVE_SYS_RESOURCE_H)
; 1065 :     struct rusage ru;
; 1066 : #endif
; 1067 : #ifdef HAVE_TIMES
; 1068 :     struct tms t;
; 1069 :     static long ticks_per_second = -1;
; 1070 : #endif
; 1071 : 
; 1072 : #if defined(HAVE_CLOCK_GETTIME) \
; 1073 :     && (defined(CLOCK_PROCESS_CPUTIME_ID) || defined(CLOCK_PROF))
; 1074 :     struct timespec tp;
; 1075 : #ifdef CLOCK_PROF
; 1076 :     const clockid_t clk_id = CLOCK_PROF;
; 1077 :     const char *function = "clock_gettime(CLOCK_PROF)";
; 1078 : #else
; 1079 :     const clockid_t clk_id = CLOCK_PROCESS_CPUTIME_ID;
; 1080 :     const char *function = "clock_gettime(CLOCK_PROCESS_CPUTIME_ID)";
; 1081 : #endif
; 1082 : 
; 1083 :     if (clock_gettime(clk_id, &tp) == 0) {
; 1084 :         if (info) {
; 1085 :             struct timespec res;
; 1086 :             info->implementation = function;
; 1087 :             info->monotonic = 1;
; 1088 :             info->adjustable = 0;
; 1089 :             if (clock_getres(clk_id, &res) == 0)
; 1090 :                 info->resolution = res.tv_sec + res.tv_nsec * 1e-9;
; 1091 :             else
; 1092 :                 info->resolution = 1e-9;
; 1093 :         }
; 1094 :         return PyFloat_FromDouble(tp.tv_sec + tp.tv_nsec * 1e-9);
; 1095 :     }
; 1096 : #endif
; 1097 : 
; 1098 : #if defined(HAVE_SYS_RESOURCE_H)
; 1099 :     if (getrusage(RUSAGE_SELF, &ru) == 0) {
; 1100 :         double total;
; 1101 :         total = ru.ru_utime.tv_sec + ru.ru_utime.tv_usec * 1e-6;
; 1102 :         total += ru.ru_stime.tv_sec + ru.ru_stime.tv_usec * 1e-6;
; 1103 :         if (info) {
; 1104 :             info->implementation = "getrusage(RUSAGE_SELF)";
; 1105 :             info->monotonic = 1;
; 1106 :             info->adjustable = 0;
; 1107 :             info->resolution = 1e-6;
; 1108 :         }
; 1109 :         return PyFloat_FromDouble(total);
; 1110 :     }
; 1111 : #endif
; 1112 : 
; 1113 : #ifdef HAVE_TIMES
; 1114 :     if (times(&t) != (clock_t)-1) {
; 1115 :         double total;
; 1116 : 
; 1117 :         if (ticks_per_second == -1) {
; 1118 : #if defined(HAVE_SYSCONF) && defined(_SC_CLK_TCK)
; 1119 :             ticks_per_second = sysconf(_SC_CLK_TCK);
; 1120 :             if (ticks_per_second < 1)
; 1121 :                 ticks_per_second = -1;
; 1122 : #elif defined(HZ)
; 1123 :             ticks_per_second = HZ;
; 1124 : #else
; 1125 :             ticks_per_second = 60; /* magic fallback value; may be bogus */
; 1126 : #endif
; 1127 :         }
; 1128 : 
; 1129 :         if (ticks_per_second != -1) {
; 1130 :             total = (double)t.tms_utime / ticks_per_second;
; 1131 :             total += (double)t.tms_stime / ticks_per_second;
; 1132 :             if (info) {
; 1133 :                 info->implementation = "times()";
; 1134 :                 info->monotonic = 1;
; 1135 :                 info->adjustable = 0;
; 1136 :                 info->resolution = 1.0 / ticks_per_second;
; 1137 :             }
; 1138 :             return PyFloat_FromDouble(total);
; 1139 :         }
; 1140 :     }
; 1141 : #endif
; 1142 : 
; 1143 :     return floatclock(info);
; 1144 : #endif
; 1145 : }

  000ce	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000d2	5b		 pop	 rbx
  000d3	c3		 ret	 0
py_process_time ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT time_process_time
_TEXT	SEGMENT
self$ = 8
unused$ = 16
time_process_time PROC					; COMDAT

; 1150 :     return py_process_time(NULL);

  00000	33 c9		 xor	 ecx, ecx

; 1151 : }

  00002	e9 00 00 00 00	 jmp	 py_process_time
time_process_time ENDP
_TEXT	ENDS
PUBLIC	??_C@_06CNBAGEMF@tzname?$AA@			; `string'
PUBLIC	??_C@_04INOFHMAI@?$CINN?$CJ?$AA@		; `string'
PUBLIC	??_C@_08DNLKDNOJ@daylight?$AA@			; `string'
PUBLIC	??_C@_07NANNIPAG@altzone?$AA@			; `string'
PUBLIC	??_C@_08EDKBBHCH@timezone?$AA@			; `string'
EXTRN	PyModule_AddObject:PROC
EXTRN	Py_BuildValue:PROC
EXTRN	PyUnicode_DecodeLocale:PROC
EXTRN	__imp_tzname:BYTE
EXTRN	__imp_daylight:DWORD
EXTRN	PyModule_AddIntConstant:PROC
EXTRN	__imp_timezone:DWORD
EXTRN	__imp_tzset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_timezone DD imagerel PyInit_timezone
	DD	imagerel PyInit_timezone+195
	DD	imagerel $unwind$PyInit_timezone
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_timezone DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_06CNBAGEMF@tzname?$AA@
CONST	SEGMENT
??_C@_06CNBAGEMF@tzname?$AA@ DB 'tzname', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04INOFHMAI@?$CINN?$CJ?$AA@
CONST	SEGMENT
??_C@_04INOFHMAI@?$CINN?$CJ?$AA@ DB '(NN)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DNLKDNOJ@daylight?$AA@
CONST	SEGMENT
??_C@_08DNLKDNOJ@daylight?$AA@ DB 'daylight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NANNIPAG@altzone?$AA@
CONST	SEGMENT
??_C@_07NANNIPAG@altzone?$AA@ DB 'altzone', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EDKBBHCH@timezone?$AA@
CONST	SEGMENT
??_C@_08EDKBBHCH@timezone?$AA@ DB 'timezone', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyInit_timezone
_TEXT	SEGMENT
m$ = 48
PyInit_timezone PROC					; COMDAT

; 1256 : PyInit_timezone(PyObject *m) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 1257 :     /* This code moved from PyInit_time wholesale to allow calling it from
; 1258 :     time_tzset. In the future, some parts of it can be moved back
; 1259 :     (for platforms that don't HAVE_WORKING_TZSET, when we know what they
; 1260 :     are), and the extraneous calls to tzset(3) should be removed.
; 1261 :     I haven't done this yet, as I don't want to change this code as
; 1262 :     little as possible when introducing the time.tzset and time.tzsetwall
; 1263 :     methods. This should simply be a method of doing the following once,
; 1264 :     at the top of this function and removing the call to tzset() from
; 1265 :     time_tzset():
; 1266 : 
; 1267 :         #ifdef HAVE_TZSET
; 1268 :         tzset()
; 1269 :         #endif
; 1270 : 
; 1271 :     And I'm lazy and hate C so nyer.
; 1272 :      */
; 1273 : #if defined(HAVE_TZNAME) && !defined(__GLIBC__) && !defined(__CYGWIN__)
; 1274 :     PyObject *otz0, *otz1;
; 1275 :     tzset();

  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tzset

; 1276 : #ifdef PYOS_OS2
; 1277 :     PyModule_AddIntConstant(m, "timezone", _timezone);
; 1278 : #else /* !PYOS_OS2 */
; 1279 :     PyModule_AddIntConstant(m, "timezone", timezone);

  00013	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR __imp_timezone
  0001a	45 8b 03	 mov	 r8d, DWORD PTR [r11]
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08EDKBBHCH@timezone?$AA@
  00024	48 8b cf	 mov	 rcx, rdi
  00027	e8 00 00 00 00	 call	 PyModule_AddIntConstant

; 1280 : #endif /* PYOS_OS2 */
; 1281 : #ifdef HAVE_ALTZONE
; 1282 :     PyModule_AddIntConstant(m, "altzone", altzone);
; 1283 : #else
; 1284 : #ifdef PYOS_OS2
; 1285 :     PyModule_AddIntConstant(m, "altzone", _timezone-3600);
; 1286 : #else /* !PYOS_OS2 */
; 1287 :     PyModule_AddIntConstant(m, "altzone", timezone-3600);

  0002c	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR __imp_timezone
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07NANNIPAG@altzone?$AA@
  0003a	45 8b 03	 mov	 r8d, DWORD PTR [r11]
  0003d	48 8b cf	 mov	 rcx, rdi
  00040	41 81 e8 10 0e
	00 00		 sub	 r8d, 3600		; 00000e10H
  00047	e8 00 00 00 00	 call	 PyModule_AddIntConstant

; 1288 : #endif /* PYOS_OS2 */
; 1289 : #endif
; 1290 :     PyModule_AddIntConstant(m, "daylight", daylight);

  0004c	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR __imp_daylight
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08DNLKDNOJ@daylight?$AA@
  0005a	45 8b 03	 mov	 r8d, DWORD PTR [r11]
  0005d	48 8b cf	 mov	 rcx, rdi
  00060	e8 00 00 00 00	 call	 PyModule_AddIntConstant

; 1291 :     otz0 = PyUnicode_DecodeLocale(tzname[0], "surrogateescape");

  00065	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_tzname
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
  00073	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00076	e8 00 00 00 00	 call	 PyUnicode_DecodeLocale

; 1292 :     otz1 = PyUnicode_DecodeLocale(tzname[1], "surrogateescape");

  0007b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_tzname
  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
  00089	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0008d	48 8b d8	 mov	 rbx, rax
  00090	e8 00 00 00 00	 call	 PyUnicode_DecodeLocale

; 1293 :     PyModule_AddObject(m, "tzname", Py_BuildValue("(NN)", otz0, otz1));

  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04INOFHMAI@?$CINN?$CJ?$AA@
  0009c	48 8b d3	 mov	 rdx, rbx
  0009f	4c 8b c0	 mov	 r8, rax
  000a2	e8 00 00 00 00	 call	 Py_BuildValue
  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06CNBAGEMF@tzname?$AA@
  000ae	48 8b cf	 mov	 rcx, rdi
  000b1	4c 8b c0	 mov	 r8, rax

; 1294 : #else /* !HAVE_TZNAME || __GLIBC__ || __CYGWIN__*/
; 1295 : #ifdef HAVE_STRUCT_TM_TM_ZONE
; 1296 :     {
; 1297 : #define YEAR ((time_t)((365 * 24 + 6) * 3600))
; 1298 :         time_t t;
; 1299 :         struct tm *p;
; 1300 :         long janzone, julyzone;
; 1301 :         char janname[10], julyname[10];
; 1302 :         t = (time((time_t *)0) / YEAR) * YEAR;
; 1303 :         p = localtime(&t);
; 1304 :         janzone = -p->tm_gmtoff;
; 1305 :         strncpy(janname, p->tm_zone ? p->tm_zone : "   ", 9);
; 1306 :         janname[9] = '\0';
; 1307 :         t += YEAR/2;
; 1308 :         p = localtime(&t);
; 1309 :         julyzone = -p->tm_gmtoff;
; 1310 :         strncpy(julyname, p->tm_zone ? p->tm_zone : "   ", 9);
; 1311 :         julyname[9] = '\0';
; 1312 : 
; 1313 :         if( janzone < julyzone ) {
; 1314 :             /* DST is reversed in the southern hemisphere */
; 1315 :             PyModule_AddIntConstant(m, "timezone", julyzone);
; 1316 :             PyModule_AddIntConstant(m, "altzone", janzone);
; 1317 :             PyModule_AddIntConstant(m, "daylight",
; 1318 :                                     janzone != julyzone);
; 1319 :             PyModule_AddObject(m, "tzname",
; 1320 :                                Py_BuildValue("(zz)",
; 1321 :                                              julyname, janname));
; 1322 :         } else {
; 1323 :             PyModule_AddIntConstant(m, "timezone", janzone);
; 1324 :             PyModule_AddIntConstant(m, "altzone", julyzone);
; 1325 :             PyModule_AddIntConstant(m, "daylight",
; 1326 :                                     janzone != julyzone);
; 1327 :             PyModule_AddObject(m, "tzname",
; 1328 :                                Py_BuildValue("(zz)",
; 1329 :                                              janname, julyname));
; 1330 :         }
; 1331 :     }
; 1332 : #else
; 1333 : #endif /* HAVE_STRUCT_TM_TM_ZONE */
; 1334 : #ifdef __CYGWIN__
; 1335 :     tzset();
; 1336 :     PyModule_AddIntConstant(m, "timezone", _timezone);
; 1337 :     PyModule_AddIntConstant(m, "altzone", _timezone-3600);
; 1338 :     PyModule_AddIntConstant(m, "daylight", _daylight);
; 1339 :     PyModule_AddObject(m, "tzname",
; 1340 :                        Py_BuildValue("(zz)", _tzname[0], _tzname[1]));
; 1341 : #endif /* __CYGWIN__ */
; 1342 : #endif /* !HAVE_TZNAME || __GLIBC__ || __CYGWIN__*/
; 1343 : 
; 1344 : #if defined(HAVE_CLOCK_GETTIME)
; 1345 :     PyModule_AddIntMacro(m, CLOCK_REALTIME);
; 1346 : #ifdef CLOCK_MONOTONIC
; 1347 :     PyModule_AddIntMacro(m, CLOCK_MONOTONIC);
; 1348 : #endif
; 1349 : #ifdef CLOCK_MONOTONIC_RAW
; 1350 :     PyModule_AddIntMacro(m, CLOCK_MONOTONIC_RAW);
; 1351 : #endif
; 1352 : #ifdef CLOCK_HIGHRES
; 1353 :     PyModule_AddIntMacro(m, CLOCK_HIGHRES);
; 1354 : #endif
; 1355 : #ifdef CLOCK_PROCESS_CPUTIME_ID
; 1356 :     PyModule_AddIntMacro(m, CLOCK_PROCESS_CPUTIME_ID);
; 1357 : #endif
; 1358 : #ifdef CLOCK_THREAD_CPUTIME_ID
; 1359 :     PyModule_AddIntMacro(m, CLOCK_THREAD_CPUTIME_ID);
; 1360 : #endif
; 1361 : #endif /* HAVE_CLOCK_GETTIME */
; 1362 : }

  000b4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bd	5f		 pop	 rdi
  000be	e9 00 00 00 00	 jmp	 PyModule_AddObject
PyInit_timezone ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@HIOPEIIP@struct_time?$AA@		; `string'
PUBLIC	??_C@_0BB@KCNFHFFE@_STRUCT_TM_ITEMS?$AA@	; `string'
PUBLIC	PyInit_time
EXTRN	__imp_GetVersionExA:PROC
EXTRN	PyStructSequence_InitType:PROC
EXTRN	PyModule_Create2:PROC
_BSS	SEGMENT
initialized DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyInit_time DD imagerel $LN11
	DD	imagerel $LN11+248
	DD	imagerel $unwind$PyInit_time
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_time DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0M@HIOPEIIP@struct_time?$AA@
CONST	SEGMENT
??_C@_0M@HIOPEIIP@struct_time?$AA@ DB 'struct_time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KCNFHFFE@_STRUCT_TM_ITEMS?$AA@
CONST	SEGMENT
??_C@_0BB@KCNFHFFE@_STRUCT_TM_ITEMS?$AA@ DB '_STRUCT_TM_ITEMS', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\timemodule.c
CONST	ENDS
;	COMDAT PyInit_time
_TEXT	SEGMENT
PyInit_time PROC					; COMDAT

; 1461 : {

$LN11:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1462 :     PyObject *m;
; 1463 :     m = PyModule_Create(&timemodule);

  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:timemodule
  0000d	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00012	e8 00 00 00 00	 call	 PyModule_Create2
  00017	48 8b d8	 mov	 rbx, rax

; 1464 :     if (m == NULL)

  0001a	48 85 c0	 test	 rax, rax

; 1465 :         return NULL;

  0001d	74 4e		 je	 SHORT $LN10@PyInit_tim

; 1466 : 
; 1467 :     /* Set, or reset, module variables like time.timezone */
; 1468 :     PyInit_timezone(m);

  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 PyInit_timezone

; 1469 : 
; 1470 :     if (!initialized) {

  00027	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR initialized, 0
  0002e	75 45		 jne	 SHORT $LN1@PyInit_tim

; 1471 :         PyStructSequence_InitType(&StructTimeType,
; 1472 :                                   &struct_time_type_desc);

  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:struct_time_type_desc
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:StructTimeType
  0003e	e8 00 00 00 00	 call	 PyStructSequence_InitType

; 1473 : 
; 1474 : #ifdef MS_WINDOWS
; 1475 :         winver.dwOSVersionInfoSize = sizeof(winver);
; 1476 :         if (!GetVersionEx((OSVERSIONINFO*)&winver)) {

  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:winver
  0004a	c7 05 00 00 00
	00 9c 00 00 00	 mov	 DWORD PTR winver, 156	; 0000009cH
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetVersionExA
  0005a	85 c0		 test	 eax, eax
  0005c	75 17		 jne	 SHORT $LN1@PyInit_tim

; 1477 :             Py_DECREF(m);

  0005e	48 8b cb	 mov	 rcx, rbx
  00061	e8 00 00 00 00	 call	 _Py_DecRef

; 1478 :             PyErr_SetFromWindowsErr(0);

  00066	33 c9		 xor	 ecx, ecx
  00068	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
$LN10@PyInit_tim:

; 1479 :             return NULL;

  0006d	33 c0		 xor	 eax, eax

; 1492 : }

  0006f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00073	5b		 pop	 rbx
  00074	c3		 ret	 0
$LN1@PyInit_tim:

; 1480 :         }
; 1481 : #endif
; 1482 :     }
; 1483 :     Py_INCREF(&StructTimeType);

  00075	e8 00 00 00 00	 call	 _Py_PXCTX
  0007a	85 c0		 test	 eax, eax
  0007c	75 3c		 jne	 SHORT $LN7@PyInit_tim
  0007e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:StructTimeType
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00093	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00099	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a1	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a6	85 c0		 test	 eax, eax
  000a8	75 09		 jne	 SHORT $LN6@PyInit_tim
  000aa	f6 05 20 00 00
	00 20		 test	 BYTE PTR StructTimeType+32, 32 ; 00000020H
  000b1	74 07		 je	 SHORT $LN7@PyInit_tim
$LN6@PyInit_tim:
  000b3	48 ff 05 50 00
	00 00		 inc	 QWORD PTR StructTimeType+80
$LN7@PyInit_tim:

; 1484 : #ifdef HAVE_STRUCT_TM_TM_ZONE
; 1485 :     PyModule_AddIntConstant(m, "_STRUCT_TM_ITEMS", 11);
; 1486 : #else
; 1487 :     PyModule_AddIntConstant(m, "_STRUCT_TM_ITEMS", 9);

  000ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@KCNFHFFE@_STRUCT_TM_ITEMS?$AA@
  000c1	41 b8 09 00 00
	00		 mov	 r8d, 9
  000c7	48 8b cb	 mov	 rcx, rbx
  000ca	e8 00 00 00 00	 call	 PyModule_AddIntConstant

; 1488 : #endif
; 1489 :     PyModule_AddObject(m, "struct_time", (PyObject*) &StructTimeType);

  000cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:StructTimeType
  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@HIOPEIIP@struct_time?$AA@
  000dd	48 8b cb	 mov	 rcx, rbx
  000e0	e8 00 00 00 00	 call	 PyModule_AddObject

; 1490 :     initialized = 1;

  000e5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR initialized, 1

; 1491 :     return m;

  000ef	48 8b c3	 mov	 rax, rbx

; 1492 : }

  000f2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f6	5b		 pop	 rbx
  000f7	c3		 ret	 0
PyInit_time ENDP
_TEXT	ENDS
PUBLIC	__real@3eb0c6f7a0b5ed8d
EXTRN	_PyTime_gettimeofday_info:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$floattime DD imagerel floattime
	DD	imagerel floattime+60
	DD	imagerel $unwind$floattime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$floattime DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT __real@3eb0c6f7a0b5ed8d
CONST	SEGMENT
__real@3eb0c6f7a0b5ed8d DQ 03eb0c6f7a0b5ed8dr	; 1e-006
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT floattime
_TEXT	SEGMENT
t$ = 32
info$ = 64
floattime PROC						; COMDAT

; 1496 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1497 :     _PyTime_timeval t;
; 1498 : #ifdef HAVE_CLOCK_GETTIME
; 1499 :     struct timespec tp;
; 1500 :     int ret;
; 1501 : 
; 1502 :     /* _PyTime_gettimeofday() does not use clock_gettime()
; 1503 :        because it would require to link Python to the rt (real-time)
; 1504 :        library, at least on Linux */
; 1505 :     ret = clock_gettime(CLOCK_REALTIME, &tp);
; 1506 :     if (ret == 0) {
; 1507 :         if (info) {
; 1508 :             struct timespec res;
; 1509 :             info->implementation = "clock_gettime(CLOCK_REALTIME)";
; 1510 :             info->monotonic = 0;
; 1511 :             info->adjustable = 1;
; 1512 :             if (clock_getres(CLOCK_REALTIME, &res) == 0)
; 1513 :                 info->resolution = res.tv_sec + res.tv_nsec * 1e-9;
; 1514 :             else
; 1515 :                 info->resolution = 1e-9;
; 1516 :         }
; 1517 :         return PyFloat_FromDouble(tp.tv_sec + tp.tv_nsec * 1e-9);
; 1518 :     }
; 1519 : #endif
; 1520 :     _PyTime_gettimeofday_info(&t, info);

  00004	48 8b d1	 mov	 rdx, rcx
  00007	48 8d 4c 24 20	 lea	 rcx, QWORD PTR t$[rsp]
  0000c	e8 00 00 00 00	 call	 _PyTime_gettimeofday_info

; 1521 :     return PyFloat_FromDouble((double)t.tv_sec + t.tv_usec * 1e-6);

  00011	66 0f 6e 44 24
	28		 movd	 xmm0, DWORD PTR t$[rsp+8]
  00017	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0001b	66 0f ef c9	 pxor	 xmm1, xmm1
  0001f	f2 48 0f 2a 4c
	24 20		 cvtsi2sd xmm1, QWORD PTR t$[rsp]
  00026	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3eb0c6f7a0b5ed8d
  0002e	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00032	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 1522 : }

  00037	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003b	c3		 ret	 0
floattime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@KJCKCBEI@sleep?5length?5is?5too?5large?$AA@ ; `string'
PUBLIC	__real@41efffffffe00000
EXTRN	__imp_Sleep:PROC
EXTRN	PyExc_IOError:QWORD
EXTRN	PyEval_RestoreThread:PROC
EXTRN	__imp_WaitForSingleObject:PROC
EXTRN	__imp_ResetEvent:PROC
EXTRN	_PyOS_SigintEvent:PROC
EXTRN	_PyOS_IsMainThread:PROC
EXTRN	PyEval_SaveThread:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$floatsleep DD imagerel floatsleep
	DD	imagerel floatsleep+63
	DD	imagerel $unwind$floatsleep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$floatsleep DD imagerel floatsleep+63
	DD	imagerel floatsleep+99
	DD	imagerel $chain$1$floatsleep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$floatsleep DD imagerel floatsleep+99
	DD	imagerel floatsleep+141
	DD	imagerel $chain$2$floatsleep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$floatsleep DD imagerel floatsleep+141
	DD	imagerel floatsleep+196
	DD	imagerel $chain$3$floatsleep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$floatsleep DD imagerel floatsleep+196
	DD	imagerel floatsleep+234
	DD	imagerel $chain$5$floatsleep
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$floatsleep DD 040021H
	DD	067400H
	DD	096400H
	DD	imagerel floatsleep
	DD	imagerel floatsleep+63
	DD	imagerel $unwind$floatsleep
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$floatsleep DD 021H
	DD	imagerel floatsleep+63
	DD	imagerel floatsleep+99
	DD	imagerel $chain$1$floatsleep
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$floatsleep DD 020521H
	DD	083405H
	DD	imagerel floatsleep+63
	DD	imagerel floatsleep+99
	DD	imagerel $chain$1$floatsleep
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$floatsleep DD 040a21H
	DD	06740aH
	DD	096405H
	DD	imagerel floatsleep
	DD	imagerel floatsleep+63
	DD	imagerel $unwind$floatsleep
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$floatsleep DD 030901H
	DD	026809H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0BK@KJCKCBEI@sleep?5length?5is?5too?5large?$AA@
CONST	SEGMENT
??_C@_0BK@KJCKCBEI@sleep?5length?5is?5too?5large?$AA@ DB 'sleep length is'
	DB	' too large', 00H				; `string'
CONST	ENDS
;	COMDAT __real@41efffffffe00000
CONST	SEGMENT
__real@41efffffffe00000 DQ 041efffffffe00000r	; 4.29497e+009
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT floatsleep
_TEXT	SEGMENT
secs$ = 64
floatsleep PROC						; COMDAT

; 1531 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  00009	66 0f 28 f0	 movapd	 xmm6, xmm0

; 1532 : /* XXX Should test for MS_WINDOWS first! */
; 1533 : #if defined(HAVE_SELECT) && !defined(__EMX__)
; 1534 :     struct timeval t;
; 1535 :     double frac;
; 1536 :     int err;
; 1537 : 
; 1538 :     frac = fmod(secs, 1.0);
; 1539 :     secs = floor(secs);
; 1540 :     t.tv_sec = (long)secs;
; 1541 :     t.tv_usec = (long)(frac*1000000.0);
; 1542 :     Py_BEGIN_ALLOW_THREADS
; 1543 :     err = select(0, (fd_set *)0, (fd_set *)0, (fd_set *)0, &t);
; 1544 :     Py_END_ALLOW_THREADS
; 1545 :     if (err != 0) {
; 1546 : #ifdef EINTR
; 1547 :         if (errno == EINTR) {
; 1548 :             if (PyErr_CheckSignals())
; 1549 :                 return -1;
; 1550 :         }
; 1551 :         else
; 1552 : #endif
; 1553 :         {
; 1554 :             PyErr_SetFromErrno(PyExc_IOError);
; 1555 :             return -1;
; 1556 :         }
; 1557 :     }
; 1558 : #elif defined(__WATCOMC__) && !defined(__QNX__)
; 1559 :     /* XXX Can't interrupt this sleep */
; 1560 :     Py_BEGIN_ALLOW_THREADS
; 1561 :     delay((int)(secs * 1000 + 0.5));  /* delay() uses milliseconds */
; 1562 :     Py_END_ALLOW_THREADS
; 1563 : #elif defined(MS_WINDOWS)
; 1564 :     {
; 1565 :         double millisecs = secs * 1000.0;

  0000d	f2 0f 59 35 00
	00 00 00	 mulsd	 xmm6, QWORD PTR __real@408f400000000000

; 1566 :         unsigned long ul_millis;
; 1567 : 
; 1568 :         if (millisecs > (double)ULONG_MAX) {

  00015	66 0f 2f 35 00
	00 00 00	 comisd	 xmm6, QWORD PTR __real@41efffffffe00000
  0001d	76 20		 jbe	 SHORT $LN5@floatsleep

; 1569 :             PyErr_SetString(PyExc_OverflowError,
; 1570 :                             "sleep length is too large");

  0001f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@KJCKCBEI@sleep?5length?5is?5too?5large?$AA@
  0002d	e8 00 00 00 00	 call	 PyErr_SetString

; 1571 :             return -1;

  00032	83 c8 ff	 or	 eax, -1

; 1593 :     }
; 1594 : #elif defined(PYOS_OS2)
; 1595 :     /* This Sleep *IS* Interruptable by Exceptions */
; 1596 :     Py_BEGIN_ALLOW_THREADS
; 1597 :     if (DosSleep(secs * 1000) != NO_ERROR) {
; 1598 :         Py_BLOCK_THREADS
; 1599 :         PyErr_SetFromErrno(PyExc_IOError);
; 1600 :         return -1;
; 1601 :     }
; 1602 :     Py_END_ALLOW_THREADS
; 1603 : #else
; 1604 :     /* XXX Can't interrupt this sleep */
; 1605 :     Py_BEGIN_ALLOW_THREADS
; 1606 :     sleep((int)secs);
; 1607 :     Py_END_ALLOW_THREADS
; 1608 : #endif
; 1609 : 
; 1610 :     return 0;
; 1611 : }

  00035	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0003a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003e	c3		 ret	 0
$LN5@floatsleep:
  0003f	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00044	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 1572 :         }
; 1573 :         Py_BEGIN_ALLOW_THREADS

  00049	e8 00 00 00 00	 call	 PyEval_SaveThread

; 1574 :         /* Allow sleep(0) to maintain win32 semantics, and as decreed
; 1575 :          * by Guido, only the main thread can be interrupted.
; 1576 :          */
; 1577 :         ul_millis = (unsigned long)millisecs;

  0004e	f2 48 0f 2c fe	 cvttsd2si rdi, xmm6
  00053	48 8b f0	 mov	 rsi, rax

; 1578 :         if (ul_millis == 0 || !_PyOS_IsMainThread())

  00056	85 ff		 test	 edi, edi
  00058	74 6a		 je	 SHORT $LN3@floatsleep
  0005a	e8 00 00 00 00	 call	 _PyOS_IsMainThread
  0005f	85 c0		 test	 eax, eax
  00061	74 61		 je	 SHORT $LN3@floatsleep

; 1580 :         else {
; 1581 :             DWORD rc;
; 1582 :             HANDLE hInterruptEvent = _PyOS_SigintEvent();

  00063	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00068	e8 00 00 00 00	 call	 _PyOS_SigintEvent

; 1583 :             ResetEvent(hInterruptEvent);

  0006d	48 8b c8	 mov	 rcx, rax
  00070	48 8b d8	 mov	 rbx, rax
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ResetEvent

; 1584 :             rc = WaitForSingleObject(hInterruptEvent, ul_millis);

  00079	8b d7		 mov	 edx, edi
  0007b	48 8b cb	 mov	 rcx, rbx
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  00084	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1585 :             if (rc == WAIT_OBJECT_0) {

  00089	85 c0		 test	 eax, eax
  0008b	75 3f		 jne	 SHORT $LN1@floatsleep

; 1586 :                 Py_BLOCK_THREADS

  0008d	48 8b ce	 mov	 rcx, rsi
  00090	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1587 :                 errno = EINTR;

  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0009b	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4

; 1588 :                 PyErr_SetFromErrno(PyExc_IOError);

  000a1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  000a8	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  000ad	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b2	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1589 :                 return -1;

  000b7	83 c8 ff	 or	 eax, -1

; 1593 :     }
; 1594 : #elif defined(PYOS_OS2)
; 1595 :     /* This Sleep *IS* Interruptable by Exceptions */
; 1596 :     Py_BEGIN_ALLOW_THREADS
; 1597 :     if (DosSleep(secs * 1000) != NO_ERROR) {
; 1598 :         Py_BLOCK_THREADS
; 1599 :         PyErr_SetFromErrno(PyExc_IOError);
; 1600 :         return -1;
; 1601 :     }
; 1602 :     Py_END_ALLOW_THREADS
; 1603 : #else
; 1604 :     /* XXX Can't interrupt this sleep */
; 1605 :     Py_BEGIN_ALLOW_THREADS
; 1606 :     sleep((int)secs);
; 1607 :     Py_END_ALLOW_THREADS
; 1608 : #endif
; 1609 : 
; 1610 :     return 0;
; 1611 : }

  000ba	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000bf	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c3	c3		 ret	 0
$LN3@floatsleep:

; 1579 :             Sleep(ul_millis);

  000c4	8b cf		 mov	 ecx, edi
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep
$LN1@floatsleep:

; 1590 :             }
; 1591 :         }
; 1592 :         Py_END_ALLOW_THREADS

  000cc	48 8b ce	 mov	 rcx, rsi
  000cf	e8 00 00 00 00	 call	 PyEval_RestoreThread
  000d4	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000d9	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1593 :     }
; 1594 : #elif defined(PYOS_OS2)
; 1595 :     /* This Sleep *IS* Interruptable by Exceptions */
; 1596 :     Py_BEGIN_ALLOW_THREADS
; 1597 :     if (DosSleep(secs * 1000) != NO_ERROR) {
; 1598 :         Py_BLOCK_THREADS
; 1599 :         PyErr_SetFromErrno(PyExc_IOError);
; 1600 :         return -1;
; 1601 :     }
; 1602 :     Py_END_ALLOW_THREADS
; 1603 : #else
; 1604 :     /* XXX Can't interrupt this sleep */
; 1605 :     Py_BEGIN_ALLOW_THREADS
; 1606 :     sleep((int)secs);
; 1607 :     Py_END_ALLOW_THREADS
; 1608 : #endif
; 1609 : 
; 1610 :     return 0;
; 1611 : }

  000de	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000e3	33 c0		 xor	 eax, eax
  000e5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e9	c3		 ret	 0
floatsleep ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT time_time
_TEXT	SEGMENT
self$ = 8
unused$ = 16
time_time PROC						; COMDAT

; 65   :     return floattime(NULL);

  00000	33 c9		 xor	 ecx, ecx

; 66   : }

  00002	e9 00 00 00 00	 jmp	 floattime
time_time ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@ODLECAHN@sleep?5length?5must?5be?5non?9negativ@ ; `string'
PUBLIC	??_C@_07HOMAOGOE@d?3sleep?$AA@			; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$time_sleep DD imagerel time_sleep
	DD	imagerel time_sleep+164
	DD	imagerel $unwind$time_sleep
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_sleep DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0CC@ODLECAHN@sleep?5length?5must?5be?5non?9negativ@
CONST	SEGMENT
??_C@_0CC@ODLECAHN@sleep?5length?5must?5be?5non?9negativ@ DB 'sleep lengt'
	DB	'h must be non-negative', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HOMAOGOE@d?3sleep?$AA@
CONST	SEGMENT
??_C@_07HOMAOGOE@d?3sleep?$AA@ DB 'd:sleep', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\timemodule.c
CONST	ENDS
;	COMDAT time_sleep
_TEXT	SEGMENT
self$ = 64
args$ = 72
secs$ = 80
time_sleep PROC						; COMDAT

; 251  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 252  :     double secs;
; 253  :     if (!PyArg_ParseTuple(args, "d:sleep", &secs))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 50	 lea	 r8, QWORD PTR secs$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07HOMAOGOE@d?3sleep?$AA@
  00013	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00018	85 c0		 test	 eax, eax

; 254  :         return NULL;

  0001a	74 23		 je	 SHORT $LN10@time_sleep

; 255  :     if (secs < 0) {

  0001c	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00020	f2 0f 10 4c 24
	50		 movsdx	 xmm1, QWORD PTR secs$[rsp]
  00026	66 0f 2f c1	 comisd	 xmm0, xmm1
  0002a	76 1a		 jbe	 SHORT $LN2@time_sleep

; 256  :         PyErr_SetString(PyExc_ValueError,
; 257  :                         "sleep length must be non-negative");

  0002c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@ODLECAHN@sleep?5length?5must?5be?5non?9negativ@
  0003a	e8 00 00 00 00	 call	 PyErr_SetString
$LN10@time_sleep:

; 258  :         return NULL;

  0003f	33 c0		 xor	 eax, eax

; 264  : }

  00041	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00045	c3		 ret	 0
$LN2@time_sleep:

; 259  :     }
; 260  :     if (floatsleep(secs) != 0)

  00046	66 0f 28 c1	 movapd	 xmm0, xmm1
  0004a	e8 00 00 00 00	 call	 floatsleep
  0004f	85 c0		 test	 eax, eax

; 261  :         return NULL;

  00051	75 ec		 jne	 SHORT $LN10@time_sleep

; 262  :     Py_INCREF(Py_None);

  00053	e8 00 00 00 00	 call	 _Py_PXCTX
  00058	85 c0		 test	 eax, eax
  0005a	75 3c		 jne	 SHORT $LN7@time_sleep
  0005c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00071	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00077	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00084	85 c0		 test	 eax, eax
  00086	75 09		 jne	 SHORT $LN6@time_sleep
  00088	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0008f	74 07		 je	 SHORT $LN7@time_sleep
$LN6@time_sleep:
  00091	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN7@time_sleep:

; 263  :     return Py_None;

  00098	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 264  : }

  0009f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a3	c3		 ret	 0
time_sleep ENDP
_TEXT	ENDS
EXTRN	PyErr_Clear:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$perf_counter DD imagerel perf_counter
	DD	imagerel perf_counter+100
	DD	imagerel $unwind$perf_counter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$perf_counter DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT perf_counter
_TEXT	SEGMENT
info$ = 48
res$ = 56
perf_counter PROC					; COMDAT

; 991  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 992  : #if defined(WIN32_PERF_COUNTER) || defined(PYMONOTONIC)
; 993  :     PyObject *res;
; 994  : #endif
; 995  : #if defined(WIN32_PERF_COUNTER)
; 996  :     static int use_perf_counter = 1;
; 997  : #endif
; 998  : #ifdef PYMONOTONIC
; 999  :     static int use_monotonic = 1;
; 1000 : #endif
; 1001 : 
; 1002 : #ifdef WIN32_PERF_COUNTER
; 1003 :     if (use_perf_counter) {

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?use_perf_counter@?1??perf_counter@@9@9, 0
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	74 23		 je	 SHORT $LN4@perf_count

; 1004 :         if (win_perf_counter(info, &res) == 0)

  00012	48 8d 54 24 38	 lea	 rdx, QWORD PTR res$[rsp]
  00017	e8 00 00 00 00	 call	 win_perf_counter
  0001c	85 c0		 test	 eax, eax
  0001e	75 0b		 jne	 SHORT $LN3@perf_count

; 1005 :             return res;

  00020	48 8b 44 24 38	 mov	 rax, QWORD PTR res$[rsp]

; 1021 : }

  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5b		 pop	 rbx
  0002a	c3		 ret	 0
$LN3@perf_count:

; 1006 :         use_perf_counter = 0;

  0002b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?use_perf_counter@?1??perf_counter@@9@9, 0
$LN4@perf_count:

; 1007 :     }
; 1008 : #endif
; 1009 : 
; 1010 : #ifdef PYMONOTONIC
; 1011 :     if (use_monotonic) {

  00035	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?use_monotonic@?1??perf_counter@@9@9, 0
  0003c	74 18		 je	 SHORT $LN2@perf_count

; 1012 :         res = pymonotonic(info);

  0003e	48 8b cb	 mov	 rcx, rbx
  00041	e8 00 00 00 00	 call	 pymonotonic

; 1013 :         if (res != NULL)

  00046	48 85 c0	 test	 rax, rax

; 1014 :             return res;

  00049	75 13		 jne	 SHORT $LN5@perf_count

; 1015 :         use_monotonic = 0;

  0004b	89 05 00 00 00
	00		 mov	 DWORD PTR ?use_monotonic@?1??perf_counter@@9@9, eax

; 1016 :         PyErr_Clear();

  00051	e8 00 00 00 00	 call	 PyErr_Clear
$LN2@perf_count:

; 1017 :     }
; 1018 : #endif
; 1019 : 
; 1020 :     return floattime(info);

  00056	48 8b cb	 mov	 rcx, rbx
  00059	e8 00 00 00 00	 call	 floattime
$LN5@perf_count:

; 1021 : }

  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5b		 pop	 rbx
  00063	c3		 ret	 0
perf_counter ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT time_perf_counter
_TEXT	SEGMENT
self$ = 8
unused$ = 16
time_perf_counter PROC					; COMDAT

; 1026 :     return perf_counter(NULL);

  00000	33 c9		 xor	 ecx, ecx

; 1027 : }

  00002	e9 00 00 00 00	 jmp	 perf_counter
time_perf_counter ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@CMHCEFMK@unknown?5clock?$AA@		; `string'
PUBLIC	??_C@_0L@CAGNKJED@resolution?$AA@		; `string'
PUBLIC	??_C@_0L@NBNKHOJN@adjustable?$AA@		; `string'
PUBLIC	??_C@_0BE@LOGPLCGG@time_get_clock_info?$AA@	; `string'
PUBLIC	??_C@_0BI@HJACFKFO@?4?4?2Modules?2timemodule?4c?$AA@ ; `string'
PUBLIC	??_C@_0P@EPOCNDEG@implementation?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BB@KLKIBGIJ@s?3get_clock_info?$AA@	; `string'
EXTRN	_PyNamespace_New:PROC
EXTRN	PyBool_FromLong:PROC
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyUnicode_FromString:PROC
EXTRN	PyDict_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_get_clock_info DD imagerel time_get_clock_info
	DD	imagerel time_get_clock_info+50
	DD	imagerel $unwind$time_get_clock_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$time_get_clock_info DD imagerel time_get_clock_info+50
	DD	imagerel time_get_clock_info+690
	DD	imagerel $chain$1$time_get_clock_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$time_get_clock_info DD imagerel time_get_clock_info+690
	DD	imagerel time_get_clock_info+728
	DD	imagerel $chain$3$time_get_clock_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$time_get_clock_info DD imagerel time_get_clock_info+728
	DD	imagerel time_get_clock_info+764
	DD	imagerel $chain$5$time_get_clock_info
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$time_get_clock_info DD 040021H
	DD	0a7400H
	DD	0c6400H
	DD	imagerel time_get_clock_info
	DD	imagerel time_get_clock_info+50
	DD	imagerel $unwind$time_get_clock_info
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$time_get_clock_info DD 040021H
	DD	0a7400H
	DD	0c6400H
	DD	imagerel time_get_clock_info
	DD	imagerel time_get_clock_info+50
	DD	imagerel $unwind$time_get_clock_info
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$time_get_clock_info DD 041121H
	DD	0a7411H
	DD	0c6405H
	DD	imagerel time_get_clock_info
	DD	imagerel time_get_clock_info+50
	DD	imagerel $unwind$time_get_clock_info
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_get_clock_info DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0O@CMHCEFMK@unknown?5clock?$AA@
CONST	SEGMENT
??_C@_0O@CMHCEFMK@unknown?5clock?$AA@ DB 'unknown clock', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CAGNKJED@resolution?$AA@
CONST	SEGMENT
??_C@_0L@CAGNKJED@resolution?$AA@ DB 'resolution', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NBNKHOJN@adjustable?$AA@
CONST	SEGMENT
??_C@_0L@NBNKHOJN@adjustable?$AA@ DB 'adjustable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LOGPLCGG@time_get_clock_info?$AA@
CONST	SEGMENT
??_C@_0BE@LOGPLCGG@time_get_clock_info?$AA@ DB 'time_get_clock_info', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HJACFKFO@?4?4?2Modules?2timemodule?4c?$AA@
CONST	SEGMENT
??_C@_0BI@HJACFKFO@?4?4?2Modules?2timemodule?4c?$AA@ DB '..\Modules\timem'
	DB	'odule.c', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EPOCNDEG@implementation?$AA@
CONST	SEGMENT
??_C@_0P@EPOCNDEG@implementation?$AA@ DB 'implementation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KLKIBGIJ@s?3get_clock_info?$AA@
CONST	SEGMENT
??_C@_0BB@KLKIBGIJ@s?3get_clock_info?$AA@ DB 's:get_clock_info', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT time_get_clock_info
_TEXT	SEGMENT
info$ = 48
self$ = 96
args$ = 104
name$ = 112
time_get_clock_info PROC				; COMDAT

; 1161 : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1162 :     char *name;
; 1163 :     _Py_clock_info_t info;
; 1164 :     PyObject *obj = NULL, *dict, *ns;
; 1165 : 
; 1166 :     if (!PyArg_ParseTuple(args, "s:get_clock_info", &name))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 70	 lea	 r8, QWORD PTR name$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@KLKIBGIJ@s?3get_clock_info?$AA@
  00013	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN41@time_get_c

; 1167 :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 1247 :     return NULL;
; 1248 : }

  0001e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00022	c3		 ret	 0
$LN41@time_get_c:

; 1168 : 
; 1169 : #ifdef Py_DEBUG
; 1170 :     info.implementation = NULL;
; 1171 :     info.monotonic = -1;
; 1172 :     info.adjustable = -1;
; 1173 :     info.resolution = -1.0;
; 1174 : #else
; 1175 :     info.implementation = "";
; 1176 :     info.monotonic = 0;
; 1177 :     info.adjustable = 0;
; 1178 :     info.resolution = 1.0;

  00023	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00032	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00037	48 89 44 24 30	 mov	 QWORD PTR info$[rsp], rax
  0003c	33 c0		 xor	 eax, eax
  0003e	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00043	f2 0f 11 44 24
	40		 movsdx	 QWORD PTR info$[rsp+16], xmm0
  00049	48 89 44 24 38	 mov	 QWORD PTR info$[rsp+8], rax

; 1179 : #endif
; 1180 : 
; 1181 :     if (strcmp(name, "time") == 0)

  0004e	48 8b 44 24 70	 mov	 rax, QWORD PTR name$[rsp]
  00053	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_04CLCEDBPF@time?$AA@
  0005a	48 8b f0	 mov	 rsi, rax
  0005d	b9 05 00 00 00	 mov	 ecx, 5
  00062	f3 a6		 repe cmpsb
  00064	75 0c		 jne	 SHORT $LN40@time_get_c

; 1182 :         obj = floattime(&info);

  00066	48 8d 4c 24 30	 lea	 rcx, QWORD PTR info$[rsp]
  0006b	e8 00 00 00 00	 call	 floattime
  00070	eb 7e		 jmp	 SHORT $LN31@time_get_c
$LN40@time_get_c:

; 1183 : #ifdef PYCLOCK
; 1184 :     else if (strcmp(name, "clock") == 0)

  00072	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_05DDECJJKE@clock?$AA@
  00079	48 8b f0	 mov	 rsi, rax
  0007c	b9 06 00 00 00	 mov	 ecx, 6
  00081	f3 a6		 repe cmpsb
  00083	75 0c		 jne	 SHORT $LN38@time_get_c

; 1185 :         obj = pyclock(&info);

  00085	48 8d 4c 24 30	 lea	 rcx, QWORD PTR info$[rsp]
  0008a	e8 00 00 00 00	 call	 pyclock
  0008f	eb 5f		 jmp	 SHORT $LN31@time_get_c
$LN38@time_get_c:

; 1186 : #endif
; 1187 : #ifdef PYMONOTONIC
; 1188 :     else if (strcmp(name, "monotonic") == 0)

  00091	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_09FKNHDPAJ@monotonic?$AA@
  00098	48 8b f0	 mov	 rsi, rax
  0009b	b9 0a 00 00 00	 mov	 ecx, 10
  000a0	f3 a6		 repe cmpsb
  000a2	75 0c		 jne	 SHORT $LN36@time_get_c

; 1189 :         obj = pymonotonic(&info);

  000a4	48 8d 4c 24 30	 lea	 rcx, QWORD PTR info$[rsp]
  000a9	e8 00 00 00 00	 call	 pymonotonic
  000ae	eb 40		 jmp	 SHORT $LN31@time_get_c
$LN36@time_get_c:

; 1190 : #endif
; 1191 :     else if (strcmp(name, "perf_counter") == 0)

  000b0	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0N@MEONCEDN@perf_counter?$AA@
  000b7	48 8b f0	 mov	 rsi, rax
  000ba	b9 0d 00 00 00	 mov	 ecx, 13
  000bf	f3 a6		 repe cmpsb
  000c1	75 0c		 jne	 SHORT $LN34@time_get_c

; 1192 :         obj = perf_counter(&info);

  000c3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR info$[rsp]
  000c8	e8 00 00 00 00	 call	 perf_counter
  000cd	eb 21		 jmp	 SHORT $LN31@time_get_c
$LN34@time_get_c:

; 1193 :     else if (strcmp(name, "process_time") == 0)

  000cf	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0N@HNHIBMAE@process_time?$AA@
  000d6	48 8b f0	 mov	 rsi, rax
  000d9	b9 0d 00 00 00	 mov	 ecx, 13
  000de	f3 a6		 repe cmpsb
  000e0	0f 85 f2 01 00
	00		 jne	 $LN32@time_get_c

; 1194 :         obj = py_process_time(&info);

  000e6	48 8d 4c 24 30	 lea	 rcx, QWORD PTR info$[rsp]
  000eb	e8 00 00 00 00	 call	 py_process_time
$LN31@time_get_c:

; 1198 :     }
; 1199 :     if (obj == NULL)

  000f0	48 85 c0	 test	 rax, rax

; 1200 :         return NULL;

  000f3	0f 84 f2 01 00
	00		 je	 $LN46@time_get_c

; 1201 :     Py_DECREF(obj);

  000f9	48 8b c8	 mov	 rcx, rax
  000fc	e8 00 00 00 00	 call	 _Py_DecRef

; 1202 : 
; 1203 :     dict = PyDict_New();

  00101	e8 00 00 00 00	 call	 PyDict_New
  00106	48 8b f0	 mov	 rsi, rax

; 1204 :     if (dict == NULL)

  00109	48 85 c0	 test	 rax, rax

; 1205 :         return NULL;

  0010c	0f 84 d9 01 00
	00		 je	 $LN46@time_get_c

; 1206 : 
; 1207 :     assert(info.implementation != NULL);
; 1208 :     obj = PyUnicode_FromString(info.implementation);

  00112	48 8b 4c 24 30	 mov	 rcx, QWORD PTR info$[rsp]
  00117	e8 00 00 00 00	 call	 PyUnicode_FromString
  0011c	48 8b f8	 mov	 rdi, rax

; 1209 :     if (obj == NULL)

  0011f	48 85 c0	 test	 rax, rax
  00122	0f 84 8a 01 00
	00		 je	 $error$64079

; 1210 :         goto error;
; 1211 :     if (PyDict_SetItemString(dict, "implementation", obj) == -1)

  00128	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@EPOCNDEG@implementation?$AA@
  0012f	4c 8b c0	 mov	 r8, rax
  00132	48 8b ce	 mov	 rcx, rsi
  00135	e8 00 00 00 00	 call	 PyDict_SetItemString
  0013a	83 f8 ff	 cmp	 eax, -1
  0013d	0f 84 6f 01 00
	00		 je	 $error$64079

; 1212 :         goto error;
; 1213 :     Py_CLEAR(obj);

  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@HJACFKFO@?4?4?2Modules?2timemodule?4c?$AA@
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@LOGPLCGG@time_get_clock_info?$AA@
  00151	4c 8b cf	 mov	 r9, rdi
  00154	41 b8 bd 04 00
	00		 mov	 r8d, 1213		; 000004bdH
  0015a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00162	e8 00 00 00 00	 call	 _PyParallel_Guard
  00167	85 c0		 test	 eax, eax
  00169	75 08		 jne	 SHORT $LN25@time_get_c
  0016b	48 8b cf	 mov	 rcx, rdi
  0016e	e8 00 00 00 00	 call	 _Py_DecRef
$LN25@time_get_c:

; 1214 : 
; 1215 :     assert(info.monotonic != -1);
; 1216 :     obj = PyBool_FromLong(info.monotonic);

  00173	8b 4c 24 38	 mov	 ecx, DWORD PTR info$[rsp+8]
  00177	e8 00 00 00 00	 call	 PyBool_FromLong
  0017c	48 8b f8	 mov	 rdi, rax

; 1217 :     if (obj == NULL)

  0017f	48 85 c0	 test	 rax, rax
  00182	0f 84 2a 01 00
	00		 je	 $error$64079

; 1218 :         goto error;
; 1219 :     if (PyDict_SetItemString(dict, "monotonic", obj) == -1)

  00188	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09FKNHDPAJ@monotonic?$AA@
  0018f	4c 8b c0	 mov	 r8, rax
  00192	48 8b ce	 mov	 rcx, rsi
  00195	e8 00 00 00 00	 call	 PyDict_SetItemString
  0019a	83 f8 ff	 cmp	 eax, -1
  0019d	0f 84 0f 01 00
	00		 je	 $error$64079

; 1220 :         goto error;
; 1221 :     Py_CLEAR(obj);

  001a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@HJACFKFO@?4?4?2Modules?2timemodule?4c?$AA@
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@LOGPLCGG@time_get_clock_info?$AA@
  001b1	4c 8b cf	 mov	 r9, rdi
  001b4	41 b8 c5 04 00
	00		 mov	 r8d, 1221		; 000004c5H
  001ba	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001c2	e8 00 00 00 00	 call	 _PyParallel_Guard
  001c7	85 c0		 test	 eax, eax
  001c9	75 08		 jne	 SHORT $LN19@time_get_c
  001cb	48 8b cf	 mov	 rcx, rdi
  001ce	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@time_get_c:

; 1222 : 
; 1223 :     assert(info.adjustable != -1);
; 1224 :     obj = PyBool_FromLong(info.adjustable);

  001d3	8b 4c 24 3c	 mov	 ecx, DWORD PTR info$[rsp+12]
  001d7	e8 00 00 00 00	 call	 PyBool_FromLong
  001dc	48 8b f8	 mov	 rdi, rax

; 1225 :     if (obj == NULL)

  001df	48 85 c0	 test	 rax, rax
  001e2	0f 84 ca 00 00
	00		 je	 $error$64079

; 1226 :         goto error;
; 1227 :     if (PyDict_SetItemString(dict, "adjustable", obj) == -1)

  001e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@NBNKHOJN@adjustable?$AA@
  001ef	4c 8b c0	 mov	 r8, rax
  001f2	48 8b ce	 mov	 rcx, rsi
  001f5	e8 00 00 00 00	 call	 PyDict_SetItemString
  001fa	83 f8 ff	 cmp	 eax, -1
  001fd	0f 84 af 00 00
	00		 je	 $error$64079

; 1228 :         goto error;
; 1229 :     Py_CLEAR(obj);

  00203	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@HJACFKFO@?4?4?2Modules?2timemodule?4c?$AA@
  0020a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@LOGPLCGG@time_get_clock_info?$AA@
  00211	4c 8b cf	 mov	 r9, rdi
  00214	41 b8 cd 04 00
	00		 mov	 r8d, 1229		; 000004cdH
  0021a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00222	e8 00 00 00 00	 call	 _PyParallel_Guard
  00227	85 c0		 test	 eax, eax
  00229	75 08		 jne	 SHORT $LN13@time_get_c
  0022b	48 8b cf	 mov	 rcx, rdi
  0022e	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@time_get_c:

; 1230 : 
; 1231 :     assert(info.resolution > 0.0);
; 1232 :     assert(info.resolution <= 1.0);
; 1233 :     obj = PyFloat_FromDouble(info.resolution);

  00233	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR info$[rsp+16]
  00239	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0023e	48 8b f8	 mov	 rdi, rax

; 1234 :     if (obj == NULL)

  00241	48 85 c0	 test	 rax, rax
  00244	74 6c		 je	 SHORT $error$64079

; 1235 :         goto error;
; 1236 :     if (PyDict_SetItemString(dict, "resolution", obj) == -1)

  00246	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@CAGNKJED@resolution?$AA@
  0024d	4c 8b c0	 mov	 r8, rax
  00250	48 8b ce	 mov	 rcx, rsi
  00253	e8 00 00 00 00	 call	 PyDict_SetItemString
  00258	83 f8 ff	 cmp	 eax, -1
  0025b	74 55		 je	 SHORT $error$64079

; 1237 :         goto error;
; 1238 :     Py_CLEAR(obj);

  0025d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@HJACFKFO@?4?4?2Modules?2timemodule?4c?$AA@
  00264	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@LOGPLCGG@time_get_clock_info?$AA@
  0026b	4c 8b cf	 mov	 r9, rdi
  0026e	41 b8 d6 04 00
	00		 mov	 r8d, 1238		; 000004d6H
  00274	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0027c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00281	85 c0		 test	 eax, eax
  00283	75 08		 jne	 SHORT $LN7@time_get_c
  00285	48 8b cf	 mov	 rcx, rdi
  00288	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@time_get_c:

; 1239 : 
; 1240 :     ns = _PyNamespace_New(dict);

  0028d	48 8b ce	 mov	 rcx, rsi
  00290	e8 00 00 00 00	 call	 _PyNamespace_New

; 1241 :     Py_DECREF(dict);

  00295	48 8b ce	 mov	 rcx, rsi
  00298	48 8b f8	 mov	 rdi, rax
  0029b	e8 00 00 00 00	 call	 _Py_DecRef
  002a0	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]

; 1242 :     return ns;

  002a5	48 8b c7	 mov	 rax, rdi
  002a8	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 1247 :     return NULL;
; 1248 : }

  002ad	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002b1	c3		 ret	 0
$error$64079:

; 1243 : 
; 1244 : error:
; 1245 :     Py_DECREF(dict);

  002b2	48 8b ce	 mov	 rcx, rsi
  002b5	e8 00 00 00 00	 call	 _Py_DecRef

; 1246 :     Py_XDECREF(obj);

  002ba	48 85 ff	 test	 rdi, rdi
  002bd	74 2c		 je	 SHORT $LN46@time_get_c
  002bf	48 8b cf	 mov	 rcx, rdi
  002c2	e8 00 00 00 00	 call	 _Py_DecRef
  002c7	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  002cc	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  002d1	33 c0		 xor	 eax, eax

; 1247 :     return NULL;
; 1248 : }

  002d3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002d7	c3		 ret	 0
$LN32@time_get_c:

; 1195 :     else {
; 1196 :         PyErr_SetString(PyExc_ValueError, "unknown clock");

  002d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  002df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@CMHCEFMK@unknown?5clock?$AA@
  002e6	e8 00 00 00 00	 call	 PyErr_SetString
$LN46@time_get_c:

; 1197 :         return NULL;

  002eb	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  002f0	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  002f5	33 c0		 xor	 eax, eax

; 1247 :     return NULL;
; 1248 : }

  002f7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002fb	c3		 ret	 0
time_get_clock_info ENDP
_TEXT	ENDS
END
