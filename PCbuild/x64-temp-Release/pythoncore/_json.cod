; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05KBBIEONE@_json?$AA@			; `string'
PUBLIC	??_C@_0L@KHOLHHPB@scanstring?$AA@		; `string'
PUBLIC	??_C@_0BI@DMGDCBIM@encode_basestring_ascii?$AA@	; `string'
PUBLIC	??_C@_0O@LGDFANJB@_json?4Encoder?$AA@		; `string'
PUBLIC	??_C@_0BG@KGHPPKCC@_current_indent_level?$AA@	; `string'
PUBLIC	??_C@_03GJLPFLNF@obj?$AA@			; `string'
PUBLIC	??_C@_09KHELABOC@allow_nan?$AA@			; `string'
PUBLIC	??_C@_0O@HCCDDMCC@_json?4Scanner?$AA@		; `string'
PUBLIC	??_C@_07JKKCBBMM@context?$AA@			; `string'
PUBLIC	??_C@_03DAKNAIGI@idx?$AA@			; `string'
PUBLIC	??_C@_06ICGJLFIM@string?$AA@			; `string'
PUBLIC	??_C@_08PFHNJENM@skipkeys?$AA@			; `string'
PUBLIC	??_C@_09DEHDAHBH@sort_keys?$AA@			; `string'
PUBLIC	??_C@_0P@HDLIMBKH@item_separator?$AA@		; `string'
PUBLIC	??_C@_0O@HOKELHBC@key_separator?$AA@		; `string'
PUBLIC	??_C@_06CHBDMLPJ@indent?$AA@			; `string'
PUBLIC	??_C@_07KLAMFGHC@encoder?$AA@			; `string'
PUBLIC	??_C@_07DLHCIBDH@default?$AA@			; `string'
PUBLIC	??_C@_07LGFKJAB@markers?$AA@			; `string'
PUBLIC	??_C@_0P@GDIKPOIP@parse_constant?$AA@		; `string'
PUBLIC	??_C@_09DPJPPPAP@parse_int?$AA@			; `string'
PUBLIC	??_C@_0M@KEFCOABD@parse_float?$AA@		; `string'
PUBLIC	??_C@_0BC@KHLDCHIO@object_pairs_hook?$AA@	; `string'
PUBLIC	??_C@_0M@LCHLLJKI@object_hook?$AA@		; `string'
PUBLIC	??_C@_06OLFOGHEN@strict?$AA@			; `string'
_BSS	SEGMENT
?sep@?1??join_list_unicode@@9@9 DQ 01H DUP (?)		; `join_list_unicode'::`2'::sep
?errmsg_fn@?1??raise_errmsg@@9@9 DQ 01H DUP (?)		; `raise_errmsg'::`2'::errmsg_fn
?s_null@?2??_encoded_const@@9@9 DQ 01H DUP (?)		; `_encoded_const'::`3'::s_null
?s_true@?4??_encoded_const@@9@9 DQ 01H DUP (?)		; `_encoded_const'::`5'::s_true
?s_false@?6??_encoded_const@@9@9 DQ 01H DUP (?)		; `_encoded_const'::`7'::s_false
?open_dict@?1??encoder_listencode_dict@@9@9 DQ 01H DUP (?) ; `encoder_listencode_dict'::`2'::open_dict
?close_dict@?1??encoder_listencode_dict@@9@9 DQ 01H DUP (?) ; `encoder_listencode_dict'::`2'::close_dict
?empty_dict@?1??encoder_listencode_dict@@9@9 DQ 01H DUP (?) ; `encoder_listencode_dict'::`2'::empty_dict
?open_array@?1??encoder_listencode_list@@9@9 DQ 01H DUP (?) ; `encoder_listencode_list'::`2'::open_array
?close_array@?1??encoder_listencode_list@@9@9 DQ 01H DUP (?) ; `encoder_listencode_list'::`2'::close_array
?empty_array@?1??encoder_listencode_list@@9@9 DQ 01H DUP (?) ; `encoder_listencode_list'::`2'::empty_array
_BSS	ENDS
;	COMDAT ??_C@_05KBBIEONE@_json?$AA@
CONST	SEGMENT
??_C@_05KBBIEONE@_json?$AA@ DB '_json', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KHOLHHPB@scanstring?$AA@
CONST	SEGMENT
??_C@_0L@KHOLHHPB@scanstring?$AA@ DB 'scanstring', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DMGDCBIM@encode_basestring_ascii?$AA@
CONST	SEGMENT
??_C@_0BI@DMGDCBIM@encode_basestring_ascii?$AA@ DB 'encode_basestring_asc'
	DB	'ii', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LGDFANJB@_json?4Encoder?$AA@
CONST	SEGMENT
??_C@_0O@LGDFANJB@_json?4Encoder?$AA@ DB '_json.Encoder', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KGHPPKCC@_current_indent_level?$AA@
CONST	SEGMENT
??_C@_0BG@KGHPPKCC@_current_indent_level?$AA@ DB '_current_indent_level', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03GJLPFLNF@obj?$AA@
CONST	SEGMENT
??_C@_03GJLPFLNF@obj?$AA@ DB 'obj', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09KHELABOC@allow_nan?$AA@
CONST	SEGMENT
??_C@_09KHELABOC@allow_nan?$AA@ DB 'allow_nan', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HCCDDMCC@_json?4Scanner?$AA@
CONST	SEGMENT
??_C@_0O@HCCDDMCC@_json?4Scanner?$AA@ DB '_json.Scanner', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07JKKCBBMM@context?$AA@
CONST	SEGMENT
??_C@_07JKKCBBMM@context?$AA@ DB 'context', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DAKNAIGI@idx?$AA@
CONST	SEGMENT
??_C@_03DAKNAIGI@idx?$AA@ DB 'idx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICGJLFIM@string?$AA@
CONST	SEGMENT
??_C@_06ICGJLFIM@string?$AA@ DB 'string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PFHNJENM@skipkeys?$AA@
CONST	SEGMENT
??_C@_08PFHNJENM@skipkeys?$AA@ DB 'skipkeys', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DEHDAHBH@sort_keys?$AA@
CONST	SEGMENT
??_C@_09DEHDAHBH@sort_keys?$AA@ DB 'sort_keys', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HDLIMBKH@item_separator?$AA@
CONST	SEGMENT
??_C@_0P@HDLIMBKH@item_separator?$AA@ DB 'item_separator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HOKELHBC@key_separator?$AA@
CONST	SEGMENT
??_C@_0O@HOKELHBC@key_separator?$AA@ DB 'key_separator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CHBDMLPJ@indent?$AA@
CONST	SEGMENT
??_C@_06CHBDMLPJ@indent?$AA@ DB 'indent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KLAMFGHC@encoder?$AA@
CONST	SEGMENT
??_C@_07KLAMFGHC@encoder?$AA@ DB 'encoder', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DLHCIBDH@default?$AA@
CONST	SEGMENT
??_C@_07DLHCIBDH@default?$AA@ DB 'default', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LGFKJAB@markers?$AA@
CONST	SEGMENT
??_C@_07LGFKJAB@markers?$AA@ DB 'markers', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
scanner_members DQ FLAT:??_C@_06OLFOGHEN@strict?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000060H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_06OLFOGHEN@strict?$AA@
	DQ	FLAT:??_C@_0M@LCHLLJKI@object_hook?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000068H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0M@LCHLLJKI@object_hook?$AA@
	DQ	FLAT:??_C@_0BC@KHLDCHIO@object_pairs_hook?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000070H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0M@KEFCOABD@parse_float?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000078H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0M@KEFCOABD@parse_float?$AA@
	DQ	FLAT:??_C@_09DPJPPPAP@parse_int?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000080H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_09DPJPPPAP@parse_int?$AA@
	DQ	FLAT:??_C@_0P@GDIKPOIP@parse_constant?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000088H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0P@GDIKPOIP@parse_constant?$AA@
	DQ	0000000000000000H
	ORG $+32
?kwlist@?1??scanner_call@@9@9 DQ FLAT:??_C@_06ICGJLFIM@string?$AA@ ; `scanner_call'::`2'::kwlist
	DQ	FLAT:??_C@_03DAKNAIGI@idx?$AA@
	DQ	0000000000000000H
encoder_members DQ FLAT:??_C@_07LGFKJAB@markers?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000060H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_07LGFKJAB@markers?$AA@
	DQ	FLAT:??_C@_07DLHCIBDH@default?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000068H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_07DLHCIBDH@default?$AA@
	DQ	FLAT:??_C@_07KLAMFGHC@encoder?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000070H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_07KLAMFGHC@encoder?$AA@
	DQ	FLAT:??_C@_06CHBDMLPJ@indent?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000078H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_06CHBDMLPJ@indent?$AA@
	DQ	FLAT:??_C@_0O@HOKELHBC@key_separator?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000080H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0O@HOKELHBC@key_separator?$AA@
	DQ	FLAT:??_C@_0P@HDLIMBKH@item_separator?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000088H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0P@HDLIMBKH@item_separator?$AA@
	DQ	FLAT:??_C@_09DEHDAHBH@sort_keys?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000090H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_09DEHDAHBH@sort_keys?$AA@
	DQ	FLAT:??_C@_08PFHNJENM@skipkeys?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000098H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_08PFHNJENM@skipkeys?$AA@
	DQ	0000000000000000H
	ORG $+32
scanner_doc DB	'JSON scanner object', 00H
	ORG $+4
pydoc_scanstring DB 'scanstring(string, end, strict=True) -> (string, end'
	DB	')', 0aH, 0aH, 'Scan the string s for a JSON string. End is th'
	DB	'e index of the', 0aH, 'character in s after the quote that st'
	DB	'arted the JSON string.', 0aH, 'Unescapes all valid JSON strin'
	DB	'g escape sequences and raises ValueError', 0aH, 'on attempt t'
	DB	'o decode an invalid string. If strict is False then literal', 0aH
	DB	'control characters are allowed in the string.', 0aH, 0aH, 'Re'
	DB	'turns a tuple of the decoded string and the index of the char'
	DB	'acter in s', 0aH, 'after the end quote.', 00H
	ORG $+2
pydoc_encode_basestring_ascii DB 'encode_basestring_ascii(string) -> stri'
	DB	'ng', 0aH, 0aH, 'Return an ASCII-only JSON representation of a'
	DB	' Python string', 00H
	ORG $+1
?kwlist@?1??scanner_init@@9@9 DQ FLAT:??_C@_07JKKCBBMM@context?$AA@ ; `scanner_init'::`2'::kwlist
	DQ	0000000000000000H
	ORG $+8
PyScannerType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0O@HCCDDMCC@_json?4Scanner?$AA@
	DQ	00000000000000a0H
	DQ	0000000000000000H
	DQ	FLAT:scanner_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:scanner_call
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	FLAT:scanner_doc
	DQ	FLAT:scanner_traverse
	DQ	FLAT:scanner_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:scanner_members
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:scanner_init
	DQ	0000000000000000H
	DQ	FLAT:scanner_new
	DQ	0000000000000000H
	ORG $+64
?kwlist@?1??encoder_init@@9@9 DQ FLAT:??_C@_07LGFKJAB@markers?$AA@ ; `encoder_init'::`2'::kwlist
	DQ	FLAT:??_C@_07DLHCIBDH@default?$AA@
	DQ	FLAT:??_C@_07KLAMFGHC@encoder?$AA@
	DQ	FLAT:??_C@_06CHBDMLPJ@indent?$AA@
	DQ	FLAT:??_C@_0O@HOKELHBC@key_separator?$AA@
	DQ	FLAT:??_C@_0P@HDLIMBKH@item_separator?$AA@
	DQ	FLAT:??_C@_09DEHDAHBH@sort_keys?$AA@
	DQ	FLAT:??_C@_08PFHNJENM@skipkeys?$AA@
	DQ	FLAT:??_C@_09KHELABOC@allow_nan?$AA@
	DQ	0000000000000000H
?kwlist@?1??encoder_call@@9@9 DQ FLAT:??_C@_03GJLPFLNF@obj?$AA@ ; `encoder_call'::`2'::kwlist
	DQ	FLAT:??_C@_0BG@KGHPPKCC@_current_indent_level?$AA@
	DQ	0000000000000000H
encoder_doc DB	'_iterencode(obj, _current_indent_level) -> iterable', 00H
	ORG $+4
PyEncoderType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0O@LGDFANJB@_json?4Encoder?$AA@
	DQ	00000000000000b0H
	DQ	0000000000000000H
	DQ	FLAT:encoder_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:encoder_call
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	FLAT:encoder_doc
	DQ	FLAT:encoder_traverse
	DQ	FLAT:encoder_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:encoder_members
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:encoder_init
	DQ	0000000000000000H
	DQ	FLAT:encoder_new
	DQ	0000000000000000H
	ORG $+64
speedups_methods DQ FLAT:??_C@_0BI@DMGDCBIM@encode_basestring_ascii?$AA@
	DQ	FLAT:py_encode_basestring_ascii
	DD	08H
	ORG $+4
	DQ	FLAT:pydoc_encode_basestring_ascii
	DQ	FLAT:??_C@_0L@KHOLHHPB@scanstring?$AA@
	DQ	FLAT:py_scanstring
	DD	01H
	ORG $+4
	DQ	FLAT:pydoc_scanstring
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	00H
	ORG $+4
	DQ	0000000000000000H
module_doc DB	'json speedups', 0aH, 00H
	ORG $+1
jsonmodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_05KBBIEONE@_json?$AA@
	DQ	FLAT:module_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:speedups_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ??_C@_0P@GDIKPOIP@parse_constant?$AA@
CONST	SEGMENT
??_C@_0P@GDIKPOIP@parse_constant?$AA@ DB 'parse_constant', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09DPJPPPAP@parse_int?$AA@
CONST	SEGMENT
??_C@_09DPJPPPAP@parse_int?$AA@ DB 'parse_int', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KEFCOABD@parse_float?$AA@
CONST	SEGMENT
??_C@_0M@KEFCOABD@parse_float?$AA@ DB 'parse_float', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KHLDCHIO@object_pairs_hook?$AA@
CONST	SEGMENT
??_C@_0BC@KHLDCHIO@object_pairs_hook?$AA@ DB 'object_pairs_hook', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LCHLLJKI@object_hook?$AA@
CONST	SEGMENT
??_C@_0M@LCHLLJKI@object_hook?$AA@ DB 'object_hook', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OLFOGHEN@strict?$AA@
CONST	SEGMENT
??_C@_06OLFOGHEN@strict?$AA@ DB 'strict', 00H		; `string'
CONST	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
EXTRN	PyUnicode_Join:PROC
EXTRN	PyUnicode_FromStringAndSize:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_json.c
pdata	SEGMENT
$pdata$join_list_unicode DD imagerel join_list_unicode
	DD	imagerel join_list_unicode+69
	DD	imagerel $unwind$join_list_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$join_list_unicode DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT join_list_unicode
_TEXT	SEGMENT
lst$ = 48
join_list_unicode PROC					; COMDAT

; 82   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 83   :     /* return u''.join(lst) */
; 84   :     static PyObject *sep = NULL;
; 85   :     if (sep == NULL) {

  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?sep@?1??join_list_unicode@@9@9
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 85 c0	 test	 rax, rax
  00013	75 20		 jne	 SHORT $LN1@join_list_

; 86   :         sep = PyUnicode_FromStringAndSize("", 0);

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0001c	33 d2		 xor	 edx, edx
  0001e	e8 00 00 00 00	 call	 PyUnicode_FromStringAndSize
  00023	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?sep@?1??join_list_unicode@@9@9, rax

; 87   :         if (sep == NULL)

  0002a	48 85 c0	 test	 rax, rax
  0002d	75 06		 jne	 SHORT $LN1@join_list_

; 91   : }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5b		 pop	 rbx
  00034	c3		 ret	 0
$LN1@join_list_:

; 88   :             return NULL;
; 89   :     }
; 90   :     return PyUnicode_Join(sep, lst);

  00035	48 8b d3	 mov	 rdx, rbx
  00038	48 8b c8	 mov	 rcx, rax

; 91   : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5b		 pop	 rbx
  00040	e9 00 00 00 00	 jmp	 PyUnicode_Join
join_list_unicode ENDP
_TEXT	ENDS
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_convertPyInt_AsSsize_t DD imagerel _convertPyInt_AsSsize_t
	DD	imagerel _convertPyInt_AsSsize_t+52
	DD	imagerel $unwind$_convertPyInt_AsSsize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_convertPyInt_AsSsize_t DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _convertPyInt_AsSsize_t
_TEXT	SEGMENT
o$ = 48
size_ptr$ = 56
_convertPyInt_AsSsize_t PROC				; COMDAT

; 144  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 145  :     /* PyObject to Py_ssize_t converter */
; 146  :     *size_ptr = PyLong_AsSsize_t(o);

  00009	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  0000e	48 89 03	 mov	 QWORD PTR [rbx], rax

; 147  :     if (*size_ptr == -1 && PyErr_Occurred())

  00011	48 83 f8 ff	 cmp	 rax, -1
  00015	75 12		 jne	 SHORT $LN1@convertPyI
  00017	e8 00 00 00 00	 call	 PyErr_Occurred
  0001c	48 85 c0	 test	 rax, rax
  0001f	74 08		 je	 SHORT $LN1@convertPyI

; 148  :         return 0;

  00021	33 c0		 xor	 eax, eax

; 150  : }

  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
$LN1@convertPyI:

; 149  :     return 1;

  00029	b8 01 00 00 00	 mov	 eax, 1

; 150  : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
_convertPyInt_AsSsize_t ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSsize_t:PROC
; Function compile flags: /Ogtpy
;	COMDAT _convertPyInt_FromSsize_t
_TEXT	SEGMENT
size_ptr$ = 8
_convertPyInt_FromSsize_t PROC				; COMDAT

; 155  :     /* Py_ssize_t to PyObject converter */
; 156  :     return PyLong_FromSsize_t(*size_ptr);

  00000	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 157  : }

  00003	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
_convertPyInt_FromSsize_t ENDP
_TEXT	ENDS
EXTRN	Py_hexdigits:QWORD
EXTRN	__ImageBase:BYTE
; Function compile flags: /Ogtpy
;	COMDAT ascii_escape_unichar
_TEXT	SEGMENT
c$ = 8
output$ = 16
chars$ = 24
ascii_escape_unichar PROC				; COMDAT

; 162  :     /* Escape unicode code point c to ASCII escape sequences
; 163  :     in char *output. output must have at least 12 bytes unused to
; 164  :     accommodate an escaped surrogate pair "\uXXXX\uXXXX" */
; 165  :     output[chars++] = '\\';
; 166  :     switch (c) {

  00000	8d 41 f8	 lea	 eax, DWORD PTR [rcx-8]
  00003	42 c6 04 02 5c	 mov	 BYTE PTR [rdx+r8], 92	; 0000005cH
  00008	49 ff c0	 inc	 r8
  0000b	4c 8b d2	 mov	 r10, rdx
  0000e	44 8b d9	 mov	 r11d, ecx
  00011	83 f8 54	 cmp	 eax, 84			; 00000054H
  00014	77 58		 ja	 SHORT $LN2@ascii_esca
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0001d	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN14@ascii_esca[rcx+rax]
  00025	44 8b 8c 81 00
	00 00 00	 mov	 r9d, DWORD PTR $LN15@ascii_esca[rcx+rax*4]
  0002d	4c 03 c9	 add	 r9, rcx
  00030	41 ff e1	 jmp	 r9
$LN9@ascii_esca:

; 167  :         case '\\': output[chars++] = c; break;

  00033	46 88 1c 02	 mov	 BYTE PTR [rdx+r8], r11b

; 192  :     }
; 193  :     return chars;

  00037	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]

; 194  : }

  0003b	c3		 ret	 0
$LN7@ascii_esca:

; 168  :         case '"': output[chars++] = c; break;
; 169  :         case '\b': output[chars++] = 'b'; break;

  0003c	42 c6 04 02 62	 mov	 BYTE PTR [rdx+r8], 98	; 00000062H

; 192  :     }
; 193  :     return chars;

  00041	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]

; 194  : }

  00045	c3		 ret	 0
$LN6@ascii_esca:

; 170  :         case '\f': output[chars++] = 'f'; break;

  00046	42 c6 04 02 66	 mov	 BYTE PTR [rdx+r8], 102	; 00000066H

; 192  :     }
; 193  :     return chars;

  0004b	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]

; 194  : }

  0004f	c3		 ret	 0
$LN5@ascii_esca:

; 171  :         case '\n': output[chars++] = 'n'; break;

  00050	42 c6 04 02 6e	 mov	 BYTE PTR [rdx+r8], 110	; 0000006eH

; 192  :     }
; 193  :     return chars;

  00055	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]

; 194  : }

  00059	c3		 ret	 0
$LN4@ascii_esca:

; 172  :         case '\r': output[chars++] = 'r'; break;

  0005a	42 c6 04 02 72	 mov	 BYTE PTR [rdx+r8], 114	; 00000072H

; 192  :     }
; 193  :     return chars;

  0005f	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]

; 194  : }

  00063	c3		 ret	 0
$LN3@ascii_esca:

; 173  :         case '\t': output[chars++] = 't'; break;

  00064	42 c6 04 02 74	 mov	 BYTE PTR [rdx+r8], 116	; 00000074H

; 192  :     }
; 193  :     return chars;

  00069	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]

; 194  : }

  0006d	c3		 ret	 0
$LN2@ascii_esca:

; 174  :         default:
; 175  :             if (c >= 0x10000) {

  0006e	41 81 fb 00 00
	01 00		 cmp	 r11d, 65536		; 00010000H
  00075	0f 82 94 00 00
	00		 jb	 $LN1@ascii_esca

; 176  :                 /* UTF-16 surrogate pair */
; 177  :                 Py_UCS4 v = c - 0x10000;
; 178  :                 c = 0xd800 | ((v >> 10) & 0x3ff);
; 179  :                 output[chars++] = 'u';

  0007b	42 c6 04 02 75	 mov	 BYTE PTR [rdx+r8], 117	; 00000075H
  00080	41 81 c3 00 00
	ff ff		 add	 r11d, -65536		; ffff0000H
  00087	41 8b c3	 mov	 eax, r11d

; 180  :                 output[chars++] = Py_hexdigits[(c >> 12) & 0xf];
; 181  :                 output[chars++] = Py_hexdigits[(c >>  8) & 0xf];
; 182  :                 output[chars++] = Py_hexdigits[(c >>  4) & 0xf];
; 183  :                 output[chars++] = Py_hexdigits[(c      ) & 0xf];
; 184  :                 c = 0xdc00 | (v & 0x3ff);

  0008a	41 81 e3 ff 03
	00 00		 and	 r11d, 1023		; 000003ffH
  00091	25 00 fc 0f 00	 and	 eax, 1047552		; 000ffc00H
  00096	41 81 cb 00 dc
	00 00		 or	 r11d, 56320		; 0000dc00H
  0009d	0d 00 00 60 03	 or	 eax, 56623104		; 03600000H
  000a2	c1 e8 0a	 shr	 eax, 10
  000a5	8b d0		 mov	 edx, eax
  000a7	8b c8		 mov	 ecx, eax
  000a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  000b0	48 c1 e9 0c	 shr	 rcx, 12
  000b4	83 e1 0f	 and	 ecx, 15
  000b7	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  000bb	43 88 4c 02 01	 mov	 BYTE PTR [r10+r8+1], cl
  000c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  000c7	8b ca		 mov	 ecx, edx
  000c9	48 c1 e9 08	 shr	 rcx, 8
  000cd	83 e1 0f	 and	 ecx, 15
  000d0	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  000d4	43 88 4c 02 02	 mov	 BYTE PTR [r10+r8+2], cl
  000d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  000e0	8b ca		 mov	 ecx, edx
  000e2	48 c1 e9 04	 shr	 rcx, 4
  000e6	83 e2 0f	 and	 edx, 15
  000e9	83 e1 0f	 and	 ecx, 15

; 185  :                 output[chars++] = '\\';

  000ec	49 83 c0 06	 add	 r8, 6
  000f0	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  000f4	43 88 4c 02 fd	 mov	 BYTE PTR [r10+r8-3], cl
  000f9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00100	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  00104	43 88 4c 02 fe	 mov	 BYTE PTR [r10+r8-2], cl
  00109	43 c6 44 02 ff
	5c		 mov	 BYTE PTR [r10+r8-1], 92	; 0000005cH
$LN1@ascii_esca:

; 186  :             }
; 187  :             output[chars++] = 'u';

  0010f	43 c6 04 02 75	 mov	 BYTE PTR [r10+r8], 117	; 00000075H

; 188  :             output[chars++] = Py_hexdigits[(c >> 12) & 0xf];

  00114	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  0011b	41 8b cb	 mov	 ecx, r11d
  0011e	48 c1 e9 0c	 shr	 rcx, 12
  00122	41 8b d3	 mov	 edx, r11d
  00125	83 e1 0f	 and	 ecx, 15

; 189  :             output[chars++] = Py_hexdigits[(c >>  8) & 0xf];
; 190  :             output[chars++] = Py_hexdigits[(c >>  4) & 0xf];
; 191  :             output[chars++] = Py_hexdigits[(c      ) & 0xf];

  00128	83 e2 0f	 and	 edx, 15
  0012b	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0012f	43 88 4c 02 01	 mov	 BYTE PTR [r10+r8+1], cl
  00134	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  0013b	41 8b cb	 mov	 ecx, r11d
  0013e	48 c1 e9 08	 shr	 rcx, 8
  00142	83 e1 0f	 and	 ecx, 15
  00145	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00149	43 88 4c 02 02	 mov	 BYTE PTR [r10+r8+2], cl
  0014e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00155	41 8b cb	 mov	 ecx, r11d
  00158	48 c1 e9 04	 shr	 rcx, 4
  0015c	83 e1 0f	 and	 ecx, 15
  0015f	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00163	43 88 4c 02 03	 mov	 BYTE PTR [r10+r8+3], cl
  00168	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  0016f	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]

; 192  :     }
; 193  :     return chars;

  00173	49 8d 40 05	 lea	 rax, QWORD PTR [r8+5]
  00177	43 88 4c 02 04	 mov	 BYTE PTR [r10+r8+4], cl

; 194  : }

  0017c	c3		 ret	 0
  0017d	0f 1f 00	 npad	 3
$LN15@ascii_esca:
  00180	00 00 00 00	 DD	 $LN7@ascii_esca
  00184	00 00 00 00	 DD	 $LN3@ascii_esca
  00188	00 00 00 00	 DD	 $LN5@ascii_esca
  0018c	00 00 00 00	 DD	 $LN6@ascii_esca
  00190	00 00 00 00	 DD	 $LN4@ascii_esca
  00194	00 00 00 00	 DD	 $LN9@ascii_esca
  00198	00 00 00 00	 DD	 $LN2@ascii_esca
$LN14@ascii_esca:
  0019c	00		 DB	 0
  0019d	01		 DB	 1
  0019e	02		 DB	 2
  0019f	06		 DB	 6
  001a0	03		 DB	 3
  001a1	04		 DB	 4
  001a2	06		 DB	 6
  001a3	06		 DB	 6
  001a4	06		 DB	 6
  001a5	06		 DB	 6
  001a6	06		 DB	 6
  001a7	06		 DB	 6
  001a8	06		 DB	 6
  001a9	06		 DB	 6
  001aa	06		 DB	 6
  001ab	06		 DB	 6
  001ac	06		 DB	 6
  001ad	06		 DB	 6
  001ae	06		 DB	 6
  001af	06		 DB	 6
  001b0	06		 DB	 6
  001b1	06		 DB	 6
  001b2	06		 DB	 6
  001b3	06		 DB	 6
  001b4	06		 DB	 6
  001b5	06		 DB	 6
  001b6	05		 DB	 5
  001b7	06		 DB	 6
  001b8	06		 DB	 6
  001b9	06		 DB	 6
  001ba	06		 DB	 6
  001bb	06		 DB	 6
  001bc	06		 DB	 6
  001bd	06		 DB	 6
  001be	06		 DB	 6
  001bf	06		 DB	 6
  001c0	06		 DB	 6
  001c1	06		 DB	 6
  001c2	06		 DB	 6
  001c3	06		 DB	 6
  001c4	06		 DB	 6
  001c5	06		 DB	 6
  001c6	06		 DB	 6
  001c7	06		 DB	 6
  001c8	06		 DB	 6
  001c9	06		 DB	 6
  001ca	06		 DB	 6
  001cb	06		 DB	 6
  001cc	06		 DB	 6
  001cd	06		 DB	 6
  001ce	06		 DB	 6
  001cf	06		 DB	 6
  001d0	06		 DB	 6
  001d1	06		 DB	 6
  001d2	06		 DB	 6
  001d3	06		 DB	 6
  001d4	06		 DB	 6
  001d5	06		 DB	 6
  001d6	06		 DB	 6
  001d7	06		 DB	 6
  001d8	06		 DB	 6
  001d9	06		 DB	 6
  001da	06		 DB	 6
  001db	06		 DB	 6
  001dc	06		 DB	 6
  001dd	06		 DB	 6
  001de	06		 DB	 6
  001df	06		 DB	 6
  001e0	06		 DB	 6
  001e1	06		 DB	 6
  001e2	06		 DB	 6
  001e3	06		 DB	 6
  001e4	06		 DB	 6
  001e5	06		 DB	 6
  001e6	06		 DB	 6
  001e7	06		 DB	 6
  001e8	06		 DB	 6
  001e9	06		 DB	 6
  001ea	06		 DB	 6
  001eb	06		 DB	 6
  001ec	06		 DB	 6
  001ed	06		 DB	 6
  001ee	06		 DB	 6
  001ef	06		 DB	 6
  001f0	05		 DB	 5
ascii_escape_unichar ENDP
_TEXT	ENDS
EXTRN	PyUnicode_New:PROC
EXTRN	_PyUnicode_Ready:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ascii_escape_unicode DD imagerel ascii_escape_unicode
	DD	imagerel ascii_escape_unicode+36
	DD	imagerel $unwind$ascii_escape_unicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$ascii_escape_unicode DD imagerel ascii_escape_unicode+36
	DD	imagerel ascii_escape_unicode+271
	DD	imagerel $chain$3$ascii_escape_unicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$ascii_escape_unicode DD imagerel ascii_escape_unicode+271
	DD	imagerel ascii_escape_unicode+412
	DD	imagerel $chain$4$ascii_escape_unicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$ascii_escape_unicode DD imagerel ascii_escape_unicode+412
	DD	imagerel ascii_escape_unicode+440
	DD	imagerel $chain$5$ascii_escape_unicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$ascii_escape_unicode DD imagerel ascii_escape_unicode+440
	DD	imagerel ascii_escape_unicode+533
	DD	imagerel $chain$7$ascii_escape_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$ascii_escape_unicode DD 080021H
	DD	04d400H
	DD	05c400H
	DD	095400H
	DD	083400H
	DD	imagerel ascii_escape_unicode
	DD	imagerel ascii_escape_unicode+36
	DD	imagerel $unwind$ascii_escape_unicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$ascii_escape_unicode DD 021H
	DD	imagerel ascii_escape_unicode+36
	DD	imagerel ascii_escape_unicode+271
	DD	imagerel $chain$3$ascii_escape_unicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$ascii_escape_unicode DD 020521H
	DD	0a6405H
	DD	imagerel ascii_escape_unicode+36
	DD	imagerel ascii_escape_unicode+271
	DD	imagerel $chain$3$ascii_escape_unicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$ascii_escape_unicode DD 081421H
	DD	04d414H
	DD	05c40fH
	DD	09540aH
	DD	083405H
	DD	imagerel ascii_escape_unicode
	DD	imagerel ascii_escape_unicode+36
	DD	imagerel $unwind$ascii_escape_unicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ascii_escape_unicode DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ascii_escape_unicode
_TEXT	SEGMENT
pystr$ = 64
ascii_escape_unicode PROC				; COMDAT

; 198  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 199  :     /* Take a PyUnicode pystr and return a new ASCII-only escaped PyUnicode */
; 200  :     Py_ssize_t i;
; 201  :     Py_ssize_t input_chars;
; 202  :     Py_ssize_t output_size;
; 203  :     Py_ssize_t chars;
; 204  :     PyObject *rval;
; 205  :     void *input;
; 206  :     unsigned char *output;
; 207  :     int kind;
; 208  : 
; 209  :     if (PyUnicode_READY(pystr) == -1)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	75 12		 jne	 SHORT $LN16@ascii_esca@2
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 08		 jne	 SHORT $LN16@ascii_esca@2

; 210  :         return NULL;

  00019	33 c0		 xor	 eax, eax

; 253  : }

  0001b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001f	5f		 pop	 rdi
  00020	c3		 ret	 0
$LN16@ascii_esca@2:

; 211  : 
; 212  :     input_chars = PyUnicode_GET_LENGTH(pystr);
; 213  :     input = PyUnicode_DATA(pystr);

  00021	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  00024	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00029	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  0002e	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  00033	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00038	4c 8b 6f 60	 mov	 r13, QWORD PTR [rdi+96]
  0003c	a8 20		 test	 al, 32			; 00000020H
  0003e	74 13		 je	 SHORT $LN23@ascii_esca@2
  00040	a8 40		 test	 al, 64			; 00000040H
  00042	74 06		 je	 SHORT $LN21@ascii_esca@2
  00044	48 83 ef 80	 sub	 rdi, -128		; ffffffffffffff80H
  00048	eb 10		 jmp	 SHORT $LN24@ascii_esca@2
$LN21@ascii_esca@2:
  0004a	48 81 c7 a0 00
	00 00		 add	 rdi, 160		; 000000a0H
  00051	eb 07		 jmp	 SHORT $LN24@ascii_esca@2
$LN23@ascii_esca@2:
  00053	48 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [rdi+160]
$LN24@ascii_esca@2:

; 214  :     kind = PyUnicode_KIND(pystr);
; 215  : 
; 216  :     /* Compute the output size */
; 217  :     for (i = 0, output_size = 2; i < input_chars; i++) {

  0005a	33 db		 xor	 ebx, ebx
  0005c	c1 e8 02	 shr	 eax, 2
  0005f	83 e0 07	 and	 eax, 7
  00062	44 8b c3	 mov	 r8d, ebx
  00065	44 8d 4b 02	 lea	 r9d, QWORD PTR [rbx+2]

; 218  :         Py_UCS4 c = PyUnicode_READ(kind, input, i);

  00069	48 63 e8	 movsxd	 rbp, eax
  0006c	4d 85 ed	 test	 r13, r13
  0006f	0f 8e 7e 00 00
	00		 jle	 $LN13@ascii_esca@2

; 214  :     kind = PyUnicode_KIND(pystr);
; 215  : 
; 216  :     /* Compute the output size */
; 217  :     for (i = 0, output_size = 2; i < input_chars; i++) {

  00075	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  0007c	44 8d 53 0c	 lea	 r10d, QWORD PTR [rbx+12]
$LL15@ascii_esca@2:

; 218  :         Py_UCS4 c = PyUnicode_READ(kind, input, i);

  00080	48 83 fd 01	 cmp	 rbp, 1
  00084	75 07		 jne	 SHORT $LN27@ascii_esca@2
  00086	41 0f b6 14 38	 movzx	 edx, BYTE PTR [r8+rdi]
  0008b	eb 11		 jmp	 SHORT $LN26@ascii_esca@2
$LN27@ascii_esca@2:
  0008d	48 83 fd 02	 cmp	 rbp, 2
  00091	75 07		 jne	 SHORT $LN25@ascii_esca@2
  00093	42 0f b7 14 47	 movzx	 edx, WORD PTR [rdi+r8*2]
  00098	eb 04		 jmp	 SHORT $LN26@ascii_esca@2
$LN25@ascii_esca@2:
  0009a	42 8b 14 87	 mov	 edx, DWORD PTR [rdi+r8*4]
$LN26@ascii_esca@2:

; 219  :         if (S_CHAR(c))

  0009e	8d 42 e0	 lea	 eax, DWORD PTR [rdx-32]
  000a1	83 f8 5e	 cmp	 eax, 94			; 0000005eH
  000a4	77 0f		 ja	 SHORT $LN12@ascii_esca@2
  000a6	83 fa 5c	 cmp	 edx, 92			; 0000005cH
  000a9	74 0a		 je	 SHORT $LN12@ascii_esca@2
  000ab	83 fa 22	 cmp	 edx, 34			; 00000022H
  000ae	74 05		 je	 SHORT $LN12@ascii_esca@2

; 220  :             output_size++;

  000b0	49 ff c1	 inc	 r9

; 221  :         else {

  000b3	eb 36		 jmp	 SHORT $LN14@ascii_esca@2
$LN12@ascii_esca@2:

; 222  :             switch(c) {

  000b5	8d 42 f8	 lea	 eax, DWORD PTR [rdx-8]
  000b8	83 f8 54	 cmp	 eax, 84			; 00000054H
  000bb	77 1c		 ja	 SHORT $LN7@ascii_esca@2
  000bd	41 0f b6 84 03
	00 00 00 00	 movzx	 eax, BYTE PTR $LN41@ascii_esca@2[r11+rax]
  000c6	41 8b 8c 83 00
	00 00 00	 mov	 ecx, DWORD PTR $LN42@ascii_esca@2[r11+rax*4]
  000ce	49 03 cb	 add	 rcx, r11
  000d1	ff e1		 jmp	 rcx
$LN8@ascii_esca@2:

; 223  :             case '\\': case '"': case '\b': case '\f':
; 224  :             case '\n': case '\r': case '\t':
; 225  :                 output_size += 2; break;

  000d3	49 83 c1 02	 add	 r9, 2
  000d7	eb 12		 jmp	 SHORT $LN14@ascii_esca@2
$LN7@ascii_esca@2:

; 226  :             default:
; 227  :                 output_size += c >= 0x10000 ? 12 : 6;

  000d9	81 fa 00 00 01
	00		 cmp	 edx, 65536		; 00010000H
  000df	b8 06 00 00 00	 mov	 eax, 6
  000e4	49 0f 43 c2	 cmovae	 rax, r10
  000e8	4c 03 c8	 add	 r9, rax
$LN14@ascii_esca@2:

; 214  :     kind = PyUnicode_KIND(pystr);
; 215  : 
; 216  :     /* Compute the output size */
; 217  :     for (i = 0, output_size = 2; i < input_chars; i++) {

  000eb	49 ff c0	 inc	 r8
  000ee	4d 3b c5	 cmp	 r8, r13
  000f1	7c 8d		 jl	 SHORT $LL15@ascii_esca@2
$LN13@ascii_esca@2:

; 228  :             }
; 229  :         }
; 230  :     }
; 231  : 
; 232  :     rval = PyUnicode_New(output_size, 127);

  000f3	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  000f8	49 8b c9	 mov	 rcx, r9
  000fb	e8 00 00 00 00	 call	 PyUnicode_New
  00100	4c 8b e0	 mov	 r12, rax

; 233  :     if (rval == NULL) {

  00103	48 85 c0	 test	 rax, rax
  00106	0f 84 90 00 00
	00		 je	 $LN46@ascii_esca@2
$LN6@ascii_esca@2:

; 234  :         return NULL;
; 235  :     }
; 236  :     output = PyUnicode_1BYTE_DATA(rval);

  0010c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0010f	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  00114	a8 20		 test	 al, 32			; 00000020H
  00116	74 18		 je	 SHORT $LN31@ascii_esca@2
  00118	a8 40		 test	 al, 64			; 00000040H
  0011a	74 0a		 je	 SHORT $LN29@ascii_esca@2
  0011c	49 8d b4 24 80
	00 00 00	 lea	 rsi, QWORD PTR [r12+128]
  00124	eb 12		 jmp	 SHORT $LN32@ascii_esca@2
$LN29@ascii_esca@2:
  00126	49 8d b4 24 a0
	00 00 00	 lea	 rsi, QWORD PTR [r12+160]
  0012e	eb 08		 jmp	 SHORT $LN32@ascii_esca@2
$LN31@ascii_esca@2:
  00130	49 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR [r12+160]
$LN32@ascii_esca@2:

; 237  :     chars = 0;
; 238  :     output[chars++] = '"';

  00138	c6 06 22	 mov	 BYTE PTR [rsi], 34	; 00000022H
  0013b	ba 01 00 00 00	 mov	 edx, 1

; 239  :     for (i = 0; i < input_chars; i++) {

  00140	4d 85 ed	 test	 r13, r13
  00143	7e 4b		 jle	 SHORT $LN3@ascii_esca@2
$LL5@ascii_esca@2:

; 240  :         Py_UCS4 c = PyUnicode_READ(kind, input, i);

  00145	48 83 fd 01	 cmp	 rbp, 1
  00149	75 06		 jne	 SHORT $LN35@ascii_esca@2
  0014b	0f b6 0c 3b	 movzx	 ecx, BYTE PTR [rbx+rdi]
  0014f	eb 0f		 jmp	 SHORT $LN34@ascii_esca@2
$LN35@ascii_esca@2:
  00151	48 83 fd 02	 cmp	 rbp, 2
  00155	75 06		 jne	 SHORT $LN33@ascii_esca@2
  00157	0f b7 0c 5f	 movzx	 ecx, WORD PTR [rdi+rbx*2]
  0015b	eb 03		 jmp	 SHORT $LN34@ascii_esca@2
$LN33@ascii_esca@2:
  0015d	8b 0c 9f	 mov	 ecx, DWORD PTR [rdi+rbx*4]
$LN34@ascii_esca@2:

; 241  :         if (S_CHAR(c)) {

  00160	8d 41 e0	 lea	 eax, DWORD PTR [rcx-32]
  00163	83 f8 5e	 cmp	 eax, 94			; 0000005eH
  00166	77 12		 ja	 SHORT $LN2@ascii_esca@2
  00168	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  0016b	74 0d		 je	 SHORT $LN2@ascii_esca@2
  0016d	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00170	74 08		 je	 SHORT $LN2@ascii_esca@2

; 242  :             output[chars++] = c;

  00172	88 0c 32	 mov	 BYTE PTR [rdx+rsi], cl
  00175	48 ff c2	 inc	 rdx

; 243  :         }
; 244  :         else {

  00178	eb 0e		 jmp	 SHORT $LN4@ascii_esca@2
$LN2@ascii_esca@2:

; 245  :             chars = ascii_escape_unichar(c, output, chars);

  0017a	4c 8b c2	 mov	 r8, rdx
  0017d	48 8b d6	 mov	 rdx, rsi
  00180	e8 00 00 00 00	 call	 ascii_escape_unichar
  00185	48 8b d0	 mov	 rdx, rax
$LN4@ascii_esca@2:

; 239  :     for (i = 0; i < input_chars; i++) {

  00188	48 ff c3	 inc	 rbx
  0018b	49 3b dd	 cmp	 rbx, r13
  0018e	7c b5		 jl	 SHORT $LL5@ascii_esca@2
$LN3@ascii_esca@2:

; 246  :         }
; 247  :     }
; 248  :     output[chars++] = '"';

  00190	c6 04 32 22	 mov	 BYTE PTR [rdx+rsi], 34	; 00000022H
  00194	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 249  : #ifdef Py_DEBUG
; 250  :     assert(_PyUnicode_CheckConsistency(rval, 1));
; 251  : #endif
; 252  :     return rval;

  00199	49 8b c4	 mov	 rax, r12
$LN46@ascii_esca@2:
  0019c	4c 8b 64 24 28	 mov	 r12, QWORD PTR [rsp+40]
  001a1	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001a6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001ab	4c 8b 6c 24 20	 mov	 r13, QWORD PTR [rsp+32]

; 253  : }

  001b0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b4	5f		 pop	 rdi
  001b5	c3		 ret	 0
  001b6	66 90		 npad	 2
$LN42@ascii_esca@2:
  001b8	00 00 00 00	 DD	 $LN8@ascii_esca@2
  001bc	00 00 00 00	 DD	 $LN7@ascii_esca@2
$LN41@ascii_esca@2:
  001c0	00		 DB	 0
  001c1	00		 DB	 0
  001c2	00		 DB	 0
  001c3	01		 DB	 1
  001c4	00		 DB	 0
  001c5	00		 DB	 0
  001c6	01		 DB	 1
  001c7	01		 DB	 1
  001c8	01		 DB	 1
  001c9	01		 DB	 1
  001ca	01		 DB	 1
  001cb	01		 DB	 1
  001cc	01		 DB	 1
  001cd	01		 DB	 1
  001ce	01		 DB	 1
  001cf	01		 DB	 1
  001d0	01		 DB	 1
  001d1	01		 DB	 1
  001d2	01		 DB	 1
  001d3	01		 DB	 1
  001d4	01		 DB	 1
  001d5	01		 DB	 1
  001d6	01		 DB	 1
  001d7	01		 DB	 1
  001d8	01		 DB	 1
  001d9	01		 DB	 1
  001da	00		 DB	 0
  001db	01		 DB	 1
  001dc	01		 DB	 1
  001dd	01		 DB	 1
  001de	01		 DB	 1
  001df	01		 DB	 1
  001e0	01		 DB	 1
  001e1	01		 DB	 1
  001e2	01		 DB	 1
  001e3	01		 DB	 1
  001e4	01		 DB	 1
  001e5	01		 DB	 1
  001e6	01		 DB	 1
  001e7	01		 DB	 1
  001e8	01		 DB	 1
  001e9	01		 DB	 1
  001ea	01		 DB	 1
  001eb	01		 DB	 1
  001ec	01		 DB	 1
  001ed	01		 DB	 1
  001ee	01		 DB	 1
  001ef	01		 DB	 1
  001f0	01		 DB	 1
  001f1	01		 DB	 1
  001f2	01		 DB	 1
  001f3	01		 DB	 1
  001f4	01		 DB	 1
  001f5	01		 DB	 1
  001f6	01		 DB	 1
  001f7	01		 DB	 1
  001f8	01		 DB	 1
  001f9	01		 DB	 1
  001fa	01		 DB	 1
  001fb	01		 DB	 1
  001fc	01		 DB	 1
  001fd	01		 DB	 1
  001fe	01		 DB	 1
  001ff	01		 DB	 1
  00200	01		 DB	 1
  00201	01		 DB	 1
  00202	01		 DB	 1
  00203	01		 DB	 1
  00204	01		 DB	 1
  00205	01		 DB	 1
  00206	01		 DB	 1
  00207	01		 DB	 1
  00208	01		 DB	 1
  00209	01		 DB	 1
  0020a	01		 DB	 1
  0020b	01		 DB	 1
  0020c	01		 DB	 1
  0020d	01		 DB	 1
  0020e	01		 DB	 1
  0020f	01		 DB	 1
  00210	01		 DB	 1
  00211	01		 DB	 1
  00212	01		 DB	 1
  00213	01		 DB	 1
  00214	00		 DB	 0
ascii_escape_unicode ENDP
_TEXT	ENDS
PUBLIC	??_C@_06FFCKFLJH@?$CIzOO?$CG?$CJ?$AA@		; `string'
PUBLIC	??_C@_06MLKCFIBB@errmsg?$AA@			; `string'
PUBLIC	??_C@_0N@COLOHLIN@json?4decoder?$AA@		; `string'
EXTRN	PyErr_SetObject:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyObject_CallFunction:PROC
EXTRN	PyObject_GetAttrString:PROC
EXTRN	PyImport_ImportModule:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$raise_errmsg DD imagerel raise_errmsg
	DD	imagerel raise_errmsg+187
	DD	imagerel $unwind$raise_errmsg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$raise_errmsg DD 061401H
	DD	096414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT ??_C@_06FFCKFLJH@?$CIzOO?$CG?$CJ?$AA@
CONST	SEGMENT
??_C@_06FFCKFLJH@?$CIzOO?$CG?$CJ?$AA@ DB '(zOO&)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MLKCFIBB@errmsg?$AA@
CONST	SEGMENT
??_C@_06MLKCFIBB@errmsg?$AA@ DB 'errmsg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@COLOHLIN@json?4decoder?$AA@
CONST	SEGMENT
??_C@_0N@COLOHLIN@json?4decoder?$AA@ DB 'json.decoder', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT raise_errmsg
_TEXT	SEGMENT
msg$ = 64
s$ = 72
end$ = 80
raise_errmsg PROC					; COMDAT

; 257  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f1	 mov	 rsi, rcx

; 258  :     /* Use the Python function json.decoder.errmsg to raise a nice
; 259  :     looking ValueError exception */
; 260  :     static PyObject *errmsg_fn = NULL;
; 261  :     PyObject *pymsg;
; 262  :     if (errmsg_fn == NULL) {

  00017	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?errmsg_fn@?1??raise_errmsg@@9@9
  0001e	48 8b fa	 mov	 rdi, rdx
  00021	48 85 c9	 test	 rcx, rcx
  00024	75 3e		 jne	 SHORT $LN2@raise_errm

; 263  :         PyObject *decoder = PyImport_ImportModule("json.decoder");

  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@COLOHLIN@json?4decoder?$AA@
  0002d	e8 00 00 00 00	 call	 PyImport_ImportModule
  00032	48 8b d8	 mov	 rbx, rax

; 264  :         if (decoder == NULL)

  00035	48 85 c0	 test	 rax, rax
  00038	74 71		 je	 SHORT $LN1@raise_errm

; 265  :             return;
; 266  :         errmsg_fn = PyObject_GetAttrString(decoder, "errmsg");

  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06MLKCFIBB@errmsg?$AA@
  00041	48 8b c8	 mov	 rcx, rax
  00044	e8 00 00 00 00	 call	 PyObject_GetAttrString

; 267  :         Py_DECREF(decoder);

  00049	48 8b cb	 mov	 rcx, rbx
  0004c	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?errmsg_fn@?1??raise_errmsg@@9@9, rax
  00053	e8 00 00 00 00	 call	 _Py_DecRef

; 268  :         if (errmsg_fn == NULL)

  00058	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?errmsg_fn@?1??raise_errmsg@@9@9
  0005f	48 85 c9	 test	 rcx, rcx
  00062	74 47		 je	 SHORT $LN1@raise_errm
$LN2@raise_errm:

; 269  :             return;
; 270  :     }
; 271  :     pymsg = PyObject_CallFunction(errmsg_fn, "(zOO&)", msg, s, _convertPyInt_FromSsize_t, &end);

  00064	48 8d 44 24 50	 lea	 rax, QWORD PTR end$[rsp]
  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06FFCKFLJH@?$CIzOO?$CG?$CJ?$AA@
  00070	4c 8b cf	 mov	 r9, rdi
  00073	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00078	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_convertPyInt_FromSsize_t
  0007f	4c 8b c6	 mov	 r8, rsi
  00082	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00087	e8 00 00 00 00	 call	 PyObject_CallFunction
  0008c	48 8b d8	 mov	 rbx, rax

; 272  :     if (pymsg) {

  0008f	48 85 c0	 test	 rax, rax
  00092	74 17		 je	 SHORT $LN1@raise_errm

; 273  :         PyErr_SetObject(PyExc_ValueError, pymsg);

  00094	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0009b	48 8b d0	 mov	 rdx, rax
  0009e	e8 00 00 00 00	 call	 PyErr_SetObject

; 274  :         Py_DECREF(pymsg);

  000a3	48 8b cb	 mov	 rcx, rbx
  000a6	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@raise_errm:

; 275  :     }
; 276  : }

  000ab	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b0	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b9	5f		 pop	 rdi
  000ba	c3		 ret	 0
raise_errmsg ENDP
_TEXT	ENDS
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_build_rval_index_tuple DD imagerel _build_rval_index_tuple
	DD	imagerel _build_rval_index_tuple+25
	DD	imagerel $unwind$_build_rval_index_tuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_build_rval_index_tuple DD imagerel _build_rval_index_tuple+25
	DD	imagerel _build_rval_index_tuple+87
	DD	imagerel $chain$0$_build_rval_index_tuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_build_rval_index_tuple DD imagerel _build_rval_index_tuple+87
	DD	imagerel _build_rval_index_tuple+106
	DD	imagerel $chain$2$_build_rval_index_tuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_build_rval_index_tuple DD 020021H
	DD	067400H
	DD	imagerel _build_rval_index_tuple
	DD	imagerel _build_rval_index_tuple+25
	DD	imagerel $unwind$_build_rval_index_tuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_build_rval_index_tuple DD 020521H
	DD	067405H
	DD	imagerel _build_rval_index_tuple
	DD	imagerel _build_rval_index_tuple+25
	DD	imagerel $unwind$_build_rval_index_tuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_build_rval_index_tuple DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _build_rval_index_tuple
_TEXT	SEGMENT
rval$ = 48
idx$ = 56
_build_rval_index_tuple PROC				; COMDAT

; 279  : _build_rval_index_tuple(PyObject *rval, Py_ssize_t idx) {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 280  :     /* return (rval, idx) tuple, stealing reference to rval */
; 281  :     PyObject *tpl;
; 282  :     PyObject *pyidx;
; 283  :     /*
; 284  :     steal a reference to rval, returns (rval, idx)
; 285  :     */
; 286  :     if (rval == NULL) {

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 08		 jne	 SHORT $LN3@build_rval

; 287  :         return NULL;

  0000e	33 c0		 xor	 eax, eax

; 302  :     return tpl;
; 303  : }

  00010	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00014	5b		 pop	 rbx
  00015	c3		 ret	 0
$LN3@build_rval:

; 288  :     }
; 289  :     pyidx = PyLong_FromSsize_t(idx);

  00016	48 8b ca	 mov	 rcx, rdx
  00019	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0001e	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00023	48 8b f8	 mov	 rdi, rax

; 290  :     if (pyidx == NULL) {

  00026	48 85 c0	 test	 rax, rax

; 291  :         Py_DECREF(rval);
; 292  :         return NULL;

  00029	74 17		 je	 SHORT $LN7@build_rval

; 293  :     }
; 294  :     tpl = PyTuple_New(2);

  0002b	b9 02 00 00 00	 mov	 ecx, 2
  00030	e8 00 00 00 00	 call	 PyTuple_New

; 295  :     if (tpl == NULL) {

  00035	48 85 c0	 test	 rax, rax
  00038	75 1d		 jne	 SHORT $LN1@build_rval

; 296  :         Py_DECREF(pyidx);

  0003a	48 8b cf	 mov	 rcx, rdi
  0003d	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@build_rval:

; 297  :         Py_DECREF(rval);

  00042	48 8b cb	 mov	 rcx, rbx
  00045	e8 00 00 00 00	 call	 _Py_DecRef
  0004a	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 298  :         return NULL;

  0004f	33 c0		 xor	 eax, eax

; 302  :     return tpl;
; 303  : }

  00051	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
$LN1@build_rval:

; 299  :     }
; 300  :     PyTuple_SET_ITEM(tpl, 0, rval);
; 301  :     PyTuple_SET_ITEM(tpl, 1, pyidx);

  00057	48 89 78 78	 mov	 QWORD PTR [rax+120], rdi
  0005b	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00060	48 89 58 70	 mov	 QWORD PTR [rax+112], rbx

; 302  :     return tpl;
; 303  : }

  00064	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00068	5b		 pop	 rbx
  00069	c3		 ret	 0
_build_rval_index_tuple ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@LLLKOJNO@end?5is?5out?5of?5bounds?$AA@ ; `string'
PUBLIC	??_C@_0CA@GLFFIBAO@Unterminated?5string?5starting?5at?$AA@ ; `string'
PUBLIC	??_C@_0BG@HFBFLOEL@Invalid?5?2uXXXX?5escape?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFDKNFEA@Invalid?5?2escape?$AA@	; `string'
PUBLIC	??_C@_0BN@KFIIHLME@Invalid?5control?5character?5at?$AA@ ; `string'
PUBLIC	??_C@_0BD@PDCADMBJ@scanstring_unicode?$AA@	; `string'
PUBLIC	??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@	; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyUnicode_FromKindAndData:PROC
EXTRN	PyList_Append:PROC
EXTRN	PyList_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$scanstring_unicode DD imagerel scanstring_unicode
	DD	imagerel scanstring_unicode+86
	DD	imagerel $unwind$scanstring_unicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$scanstring_unicode DD imagerel scanstring_unicode+86
	DD	imagerel scanstring_unicode+1832
	DD	imagerel $chain$3$scanstring_unicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$scanstring_unicode DD imagerel scanstring_unicode+1832
	DD	imagerel scanstring_unicode+2087
	DD	imagerel $chain$5$scanstring_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$scanstring_unicode DD 080021H
	DD	07e400H
	DD	087400H
	DD	096400H
	DD	0a3400H
	DD	imagerel scanstring_unicode
	DD	imagerel scanstring_unicode+86
	DD	imagerel $unwind$scanstring_unicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$scanstring_unicode DD 084421H
	DD	0a3444H
	DD	07e413H
	DD	08740eH
	DD	096405H
	DD	imagerel scanstring_unicode
	DD	imagerel scanstring_unicode+86
	DD	imagerel $unwind$scanstring_unicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scanstring_unicode DD 051501H
	DD	0f011a215H
	DD	0c00dd00fH
	DD	0500bH
xdata	ENDS
;	COMDAT ??_C@_0BF@LLLKOJNO@end?5is?5out?5of?5bounds?$AA@
CONST	SEGMENT
??_C@_0BF@LLLKOJNO@end?5is?5out?5of?5bounds?$AA@ DB 'end is out of bounds'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GLFFIBAO@Unterminated?5string?5starting?5at?$AA@
CONST	SEGMENT
??_C@_0CA@GLFFIBAO@Unterminated?5string?5starting?5at?$AA@ DB 'Unterminat'
	DB	'ed string starting at', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HFBFLOEL@Invalid?5?2uXXXX?5escape?$AA@
CONST	SEGMENT
??_C@_0BG@HFBFLOEL@Invalid?5?2uXXXX?5escape?$AA@ DB 'Invalid \uXXXX escap'
	DB	'e', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFDKNFEA@Invalid?5?2escape?$AA@
CONST	SEGMENT
??_C@_0BA@JFDKNFEA@Invalid?5?2escape?$AA@ DB 'Invalid \escape', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KFIIHLME@Invalid?5control?5character?5at?$AA@
CONST	SEGMENT
??_C@_0BN@KFIIHLME@Invalid?5control?5character?5at?$AA@ DB 'Invalid contr'
	DB	'ol character at', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PDCADMBJ@scanstring_unicode?$AA@
CONST	SEGMENT
??_C@_0BD@PDCADMBJ@scanstring_unicode?$AA@ DB 'scanstring_unicode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
CONST	SEGMENT
??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@ DB '..\Modules\_json.c', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_json.c
CONST	ENDS
;	COMDAT scanstring_unicode
_TEXT	SEGMENT
c$20664 = 128
pystr$ = 128
begin$1$ = 136
end$ = 136
strict$ = 144
next_end_ptr$ = 152
scanstring_unicode PROC					; COMDAT

; 322  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	55		 push	 rbp
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 57		 push	 r15
  00011	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00015	4c 8b f9	 mov	 r15, rcx

; 323  :     /* Read the JSON string from PyUnicode pystr.
; 324  :     end is the index of the first character after the quote.
; 325  :     if strict is zero then literal control characters are allowed
; 326  :     *next_end_ptr is a return-by-reference index of the character
; 327  :         after the end quote
; 328  : 
; 329  :     Return value is a new PyUnicode
; 330  :     */
; 331  :     PyObject *rval = NULL;
; 332  :     Py_ssize_t len;
; 333  :     Py_ssize_t begin = end - 1;

  00018	48 8d 4a ff	 lea	 rcx, QWORD PTR [rdx-1]

; 334  :     Py_ssize_t next /* = begin */;
; 335  :     const void *buf;
; 336  :     int kind;
; 337  :     PyObject *chunks = NULL;

  0001c	45 33 ed	 xor	 r13d, r13d

; 338  :     PyObject *chunk = NULL;

  0001f	33 ed		 xor	 ebp, ebp

; 339  : 
; 340  :     if (PyUnicode_READY(pystr) == -1)

  00021	41 f6 47 70 80	 test	 BYTE PTR [r15+112], 128	; 00000080H
  00026	4c 8b e2	 mov	 r12, rdx
  00029	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR begin$1$[rsp], rcx
  00031	75 23		 jne	 SHORT $LN95@scanstring
  00033	49 8b cf	 mov	 rcx, r15
  00036	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0003b	83 f8 ff	 cmp	 eax, -1
  0003e	75 0e		 jne	 SHORT $LN179@scanstring

; 341  :         return 0;

  00040	33 c0		 xor	 eax, eax

; 495  : }

  00042	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00046	41 5f		 pop	 r15
  00048	41 5d		 pop	 r13
  0004a	41 5c		 pop	 r12
  0004c	5d		 pop	 rbp
  0004d	c3		 ret	 0
$LN179@scanstring:

; 469  :             goto bail;
; 470  :         }
; 471  :     }

  0004e	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR strict$[rsp]
$LN95@scanstring:
  00056	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi

; 342  : 
; 343  :     len = PyUnicode_GET_LENGTH(pystr);
; 344  :     buf = PyUnicode_DATA(pystr);

  0005b	41 8b 77 70	 mov	 esi, DWORD PTR [r15+112]
  0005f	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00064	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  00069	4d 8b 77 60	 mov	 r14, QWORD PTR [r15+96]
  0006d	40 f6 c6 20	 test	 sil, 32			; 00000020H
  00071	74 18		 je	 SHORT $LN102@scanstring
  00073	40 f6 c6 40	 test	 sil, 64			; 00000040H
  00077	74 09		 je	 SHORT $LN100@scanstring
  00079	49 8d bf 80 00
	00 00		 lea	 rdi, QWORD PTR [r15+128]
  00080	eb 10		 jmp	 SHORT $LN103@scanstring
$LN100@scanstring:
  00082	49 8d bf a0 00
	00 00		 lea	 rdi, QWORD PTR [r15+160]
  00089	eb 07		 jmp	 SHORT $LN103@scanstring
$LN102@scanstring:
  0008b	49 8b bf a0 00
	00 00		 mov	 rdi, QWORD PTR [r15+160]
$LN103@scanstring:

; 345  :     kind = PyUnicode_KIND(pystr);

  00092	c1 ee 02	 shr	 esi, 2
  00095	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0009a	83 e6 07	 and	 esi, 7

; 346  : 
; 347  :     if (end < 0 || len <= end) {

  0009d	4d 85 e4	 test	 r12, r12
  000a0	0f 88 6a 05 00
	00		 js	 $LN93@scanstring
  000a6	4d 3b f4	 cmp	 r14, r12
  000a9	0f 8e 61 05 00
	00		 jle	 $LN93@scanstring
$LN191@scanstring:
  000af	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase

; 349  :         goto bail;
; 350  :     }
; 351  :     while (1) {
; 352  :         /* Find the end of the string or the next escape */
; 353  :         Py_UCS4 c = 0;

  000b6	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR c$20664[rsp], 0

; 354  :         for (next = end; next < len; next++) {

  000c1	49 8b dc	 mov	 rbx, r12
  000c4	4d 3b e6	 cmp	 r12, r14
  000c7	0f 8d 2a 05 00
	00		 jge	 $LN156@scanstring
  000cd	0f 1f 00	 npad	 3
$LL90@scanstring:

; 355  :             c = PyUnicode_READ(kind, buf, next);

  000d0	83 fe 01	 cmp	 esi, 1
  000d3	75 06		 jne	 SHORT $LN106@scanstring
  000d5	0f b6 04 3b	 movzx	 eax, BYTE PTR [rbx+rdi]
  000d9	eb 0e		 jmp	 SHORT $LN184@scanstring
$LN106@scanstring:
  000db	83 fe 02	 cmp	 esi, 2
  000de	75 06		 jne	 SHORT $LN104@scanstring
  000e0	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  000e4	eb 03		 jmp	 SHORT $LN184@scanstring
$LN104@scanstring:
  000e6	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN184@scanstring:
  000e9	89 84 24 80 00
	00 00		 mov	 DWORD PTR c$20664[rsp], eax

; 356  :             if (c == '"' || c == '\\') {

  000f0	83 f8 22	 cmp	 eax, 34			; 00000022H
  000f3	74 24		 je	 SHORT $LN83@scanstring
  000f5	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  000f8	74 1f		 je	 SHORT $LN83@scanstring

; 357  :                 break;
; 358  :             }
; 359  :             else if (strict && c <= 0x1f) {

  000fa	45 85 c0	 test	 r8d, r8d
  000fd	74 09		 je	 SHORT $LN89@scanstring
  000ff	83 f8 1f	 cmp	 eax, 31
  00102	0f 86 99 03 00
	00		 jbe	 $LN155@scanstring
$LN89@scanstring:

; 354  :         for (next = end; next < len; next++) {

  00108	48 ff c3	 inc	 rbx
  0010b	49 3b de	 cmp	 rbx, r14
  0010e	7c c0		 jl	 SHORT $LL90@scanstring

; 362  :             }
; 363  :         }
; 364  :         if (!(c == '"' || c == '\\')) {

  00110	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00113	0f 85 de 04 00
	00		 jne	 $LN156@scanstring
$LN83@scanstring:

; 367  :         }
; 368  :         /* Pick up this chunk if it's not zero length */
; 369  :         if (next != end) {

  00119	49 3b dc	 cmp	 rbx, r12
  0011c	0f 84 91 00 00
	00		 je	 $LN73@scanstring

; 370  :             APPEND_OLD_CHUNK

  00122	48 85 ed	 test	 rbp, rbp
  00125	74 5b		 je	 SHORT $LN75@scanstring
  00127	4d 85 ed	 test	 r13, r13
  0012a	75 13		 jne	 SHORT $LN79@scanstring
  0012c	33 c9		 xor	 ecx, ecx
  0012e	e8 00 00 00 00	 call	 PyList_New
  00133	4c 8b e8	 mov	 r13, rax
  00136	48 85 c0	 test	 rax, rax
  00139	0f 84 e4 04 00
	00		 je	 $bail$20660
$LN79@scanstring:
  0013f	48 8b d5	 mov	 rdx, rbp
  00142	49 8b cd	 mov	 rcx, r13
  00145	e8 00 00 00 00	 call	 PyList_Append
  0014a	85 c0		 test	 eax, eax
  0014c	0f 85 13 04 00
	00		 jne	 $LN158@scanstring
  00152	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@PDCADMBJ@scanstring_unicode?$AA@
  00160	4c 8b cd	 mov	 r9, rbp
  00163	41 b8 72 01 00
	00		 mov	 r8d, 370		; 00000172H
  00169	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00171	e8 00 00 00 00	 call	 _PyParallel_Guard
  00176	85 c0		 test	 eax, eax
  00178	75 08		 jne	 SHORT $LN75@scanstring
  0017a	48 8b cd	 mov	 rcx, rbp
  0017d	e8 00 00 00 00	 call	 _Py_DecRef
$LN75@scanstring:

; 371  :                 chunk = PyUnicode_FromKindAndData(
; 372  :                     kind,
; 373  :                     (char*)buf + kind * end,
; 374  :                     next - end);

  00182	48 63 d6	 movsxd	 rdx, esi
  00185	4c 8b c3	 mov	 r8, rbx
  00188	8b ce		 mov	 ecx, esi
  0018a	4d 2b c4	 sub	 r8, r12
  0018d	49 0f af d4	 imul	 rdx, r12
  00191	48 03 d7	 add	 rdx, rdi
  00194	e8 00 00 00 00	 call	 PyUnicode_FromKindAndData
  00199	48 8b e8	 mov	 rbp, rax

; 375  :             if (chunk == NULL) {

  0019c	48 85 c0	 test	 rax, rax
  0019f	0f 84 7e 04 00
	00		 je	 $bail$20660
  001a5	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR c$20664[rsp]
  001ac	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
$LN73@scanstring:

; 376  :                 goto bail;
; 377  :             }
; 378  :         }
; 379  :         next++;

  001b3	48 ff c3	 inc	 rbx

; 380  :         if (c == '"') {

  001b6	83 f8 22	 cmp	 eax, 34			; 00000022H
  001b9	0f 84 4e 03 00
	00		 je	 $LN160@scanstring

; 381  :             end = next;
; 382  :             break;
; 383  :         }
; 384  :         if (next == len) {

  001bf	49 3b de	 cmp	 rbx, r14
  001c2	0f 84 2f 04 00
	00		 je	 $LN156@scanstring

; 385  :             raise_errmsg("Unterminated string starting at", pystr, begin);
; 386  :             goto bail;
; 387  :         }
; 388  :         c = PyUnicode_READ(kind, buf, next);

  001c8	83 fe 01	 cmp	 esi, 1
  001cb	75 06		 jne	 SHORT $LN110@scanstring
  001cd	0f b6 14 3b	 movzx	 edx, BYTE PTR [rbx+rdi]
  001d1	eb 0e		 jmp	 SHORT $LN185@scanstring
$LN110@scanstring:
  001d3	83 fe 02	 cmp	 esi, 2
  001d6	75 06		 jne	 SHORT $LN108@scanstring
  001d8	0f b7 14 5f	 movzx	 edx, WORD PTR [rdi+rbx*2]
  001dc	eb 03		 jmp	 SHORT $LN185@scanstring
$LN108@scanstring:
  001de	8b 14 9f	 mov	 edx, DWORD PTR [rdi+rbx*4]
$LN185@scanstring:
  001e1	89 94 24 80 00
	00 00		 mov	 DWORD PTR c$20664[rsp], edx

; 389  :         if (c != 'u') {

  001e8	83 fa 75	 cmp	 edx, 117		; 00000075H
  001eb	0f 84 83 00 00
	00		 je	 $LN70@scanstring

; 390  :             /* Non-unicode backslash escapes */
; 391  :             end = next + 1;
; 392  :             switch (c) {

  001f1	8d 42 de	 lea	 eax, DWORD PTR [rdx-34]
  001f4	4c 8d 63 01	 lea	 r12, QWORD PTR [rbx+1]
  001f8	83 f8 52	 cmp	 eax, 82			; 00000052H
  001fb	0f 87 b7 02 00
	00		 ja	 $LN59@scanstring
  00201	41 0f b6 84 03
	00 00 00 00	 movzx	 eax, BYTE PTR $LN176@scanstring[r11+rax]
  0020a	41 8b 8c 83 00
	00 00 00	 mov	 ecx, DWORD PTR $LN177@scanstring[r11+rax*4]
  00212	49 03 cb	 add	 rcx, r11
  00215	ff e1		 jmp	 rcx
$LN64@scanstring:

; 393  :                 case '"': break;
; 394  :                 case '\\': break;
; 395  :                 case '/': break;
; 396  :                 case 'b': c = '\b'; break;

  00217	c7 84 24 80 00
	00 00 08 00 00
	00		 mov	 DWORD PTR c$20664[rsp], 8
  00222	e9 ea 01 00 00	 jmp	 $LN35@scanstring
$LN63@scanstring:

; 397  :                 case 'f': c = '\f'; break;

  00227	c7 84 24 80 00
	00 00 0c 00 00
	00		 mov	 DWORD PTR c$20664[rsp], 12
  00232	e9 da 01 00 00	 jmp	 $LN35@scanstring
$LN62@scanstring:

; 398  :                 case 'n': c = '\n'; break;

  00237	c7 84 24 80 00
	00 00 0a 00 00
	00		 mov	 DWORD PTR c$20664[rsp], 10
  00242	e9 ca 01 00 00	 jmp	 $LN35@scanstring
$LN61@scanstring:

; 399  :                 case 'r': c = '\r'; break;

  00247	c7 84 24 80 00
	00 00 0d 00 00
	00		 mov	 DWORD PTR c$20664[rsp], 13
  00252	e9 ba 01 00 00	 jmp	 $LN35@scanstring
$LN60@scanstring:

; 400  :                 case 't': c = '\t'; break;

  00257	c7 84 24 80 00
	00 00 09 00 00
	00		 mov	 DWORD PTR c$20664[rsp], 9
  00262	e9 aa 01 00 00	 jmp	 $LN35@scanstring
$LN68@scanstring:

; 402  :             }
; 403  :             if (c == 0) {

  00267	85 d2		 test	 edx, edx
  00269	0f 84 54 02 00
	00		 je	 $LN162@scanstring

; 406  :             }
; 407  :         }
; 408  :         else {

  0026f	e9 9d 01 00 00	 jmp	 $LN35@scanstring
$LN70@scanstring:

; 409  :             c = 0;
; 410  :             next++;

  00274	48 ff c3	 inc	 rbx
  00277	45 33 d2	 xor	 r10d, r10d

; 411  :             end = next + 4;

  0027a	4c 8d 63 04	 lea	 r12, QWORD PTR [rbx+4]
  0027e	44 89 94 24 80
	00 00 00	 mov	 DWORD PTR c$20664[rsp], r10d

; 412  :             if (end >= len) {

  00286	4d 3b e6	 cmp	 r12, r14
  00289	0f 8d 66 02 00
	00		 jge	 $LN163@scanstring

; 415  :             }
; 416  :             /* Decode 4 hex digits */
; 417  :             for (; next < end; next++) {

  0028f	49 3b dc	 cmp	 rbx, r12
  00292	0f 8d 79 01 00
	00		 jge	 $LN35@scanstring
$LL55@scanstring:

; 418  :                 Py_UCS4 digit = PyUnicode_READ(kind, buf, next);

  00298	83 fe 01	 cmp	 esi, 1
  0029b	75 06		 jne	 SHORT $LN114@scanstring
  0029d	0f b6 14 3b	 movzx	 edx, BYTE PTR [rbx+rdi]
  002a1	eb 0e		 jmp	 SHORT $LN113@scanstring
$LN114@scanstring:
  002a3	83 fe 02	 cmp	 esi, 2
  002a6	75 06		 jne	 SHORT $LN112@scanstring
  002a8	0f b7 14 5f	 movzx	 edx, WORD PTR [rdi+rbx*2]
  002ac	eb 03		 jmp	 SHORT $LN113@scanstring
$LN112@scanstring:
  002ae	8b 14 9f	 mov	 edx, DWORD PTR [rdi+rbx*4]
$LN113@scanstring:

; 419  :                 c <<= 4;

  002b1	41 c1 e2 04	 shl	 r10d, 4

; 420  :                 switch (digit) {

  002b5	44 8d 42 d0	 lea	 r8d, DWORD PTR [rdx-48]
  002b9	44 89 94 24 80
	00 00 00	 mov	 DWORD PTR c$20664[rsp], r10d
  002c1	41 83 f8 36	 cmp	 r8d, 54			; 00000036H
  002c5	0f 87 11 02 00
	00		 ja	 $LN47@scanstring
  002cb	43 0f b6 84 03
	00 00 00 00	 movzx	 eax, BYTE PTR $LN174@scanstring[r11+r8]
  002d4	41 8b 8c 83 00
	00 00 00	 mov	 ecx, DWORD PTR $LN175@scanstring[r11+rax*4]
  002dc	49 03 cb	 add	 rcx, r11
  002df	ff e1		 jmp	 rcx
$LN50@scanstring:

; 421  :                     case '0': case '1': case '2': case '3': case '4':
; 422  :                     case '5': case '6': case '7': case '8': case '9':
; 423  :                         c |= (digit - '0'); break;

  002e1	45 0b d0	 or	 r10d, r8d
  002e4	eb 0b		 jmp	 SHORT $LN186@scanstring
$LN49@scanstring:

; 424  :                     case 'a': case 'b': case 'c': case 'd': case 'e':
; 425  :                     case 'f':
; 426  :                         c |= (digit - 'a' + 10); break;

  002e6	8d 42 a9	 lea	 eax, DWORD PTR [rdx-87]
  002e9	eb 03		 jmp	 SHORT $LN187@scanstring
$LN48@scanstring:

; 427  :                     case 'A': case 'B': case 'C': case 'D': case 'E':
; 428  :                     case 'F':
; 429  :                         c |= (digit - 'A' + 10); break;

  002eb	8d 42 c9	 lea	 eax, DWORD PTR [rdx-55]
$LN187@scanstring:
  002ee	44 0b d0	 or	 r10d, eax
$LN186@scanstring:

; 415  :             }
; 416  :             /* Decode 4 hex digits */
; 417  :             for (; next < end; next++) {

  002f1	48 ff c3	 inc	 rbx

; 427  :                     case 'A': case 'B': case 'C': case 'D': case 'E':
; 428  :                     case 'F':
; 429  :                         c |= (digit - 'A' + 10); break;

  002f4	44 89 94 24 80
	00 00 00	 mov	 DWORD PTR c$20664[rsp], r10d
  002fc	49 3b dc	 cmp	 rbx, r12
  002ff	7c 97		 jl	 SHORT $LL55@scanstring

; 433  :                 }
; 434  :             }
; 435  :             /* Surrogate pair */
; 436  :             if (Py_UNICODE_IS_HIGH_SURROGATE(c) && end + 6 < len &&
; 437  :                 PyUnicode_READ(kind, buf, next++) == '\\' &&
; 438  :                 PyUnicode_READ(kind, buf, next++) == 'u') {

  00301	41 8d 82 00 28
	ff ff		 lea	 eax, DWORD PTR [r10-55296]
  00308	3d ff 03 00 00	 cmp	 eax, 1023		; 000003ffH
  0030d	0f 87 fe 00 00
	00		 ja	 $LN35@scanstring
  00313	49 8d 4c 24 06	 lea	 rcx, QWORD PTR [r12+6]
  00318	49 3b ce	 cmp	 rcx, r14
  0031b	0f 8d f0 00 00
	00		 jge	 $LN35@scanstring
  00321	83 fe 01	 cmp	 esi, 1
  00324	75 06		 jne	 SHORT $LN118@scanstring
  00326	0f b6 04 3b	 movzx	 eax, BYTE PTR [rbx+rdi]
  0032a	eb 0e		 jmp	 SHORT $LN188@scanstring
$LN118@scanstring:
  0032c	83 fe 02	 cmp	 esi, 2
  0032f	75 06		 jne	 SHORT $LN116@scanstring
  00331	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00335	eb 03		 jmp	 SHORT $LN188@scanstring
$LN116@scanstring:
  00337	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN188@scanstring:
  0033a	48 ff c3	 inc	 rbx
  0033d	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00340	0f 85 cb 00 00
	00		 jne	 $LN35@scanstring
  00346	83 fe 01	 cmp	 esi, 1
  00349	75 06		 jne	 SHORT $LN122@scanstring
  0034b	0f b6 04 3b	 movzx	 eax, BYTE PTR [rbx+rdi]
  0034f	eb 0e		 jmp	 SHORT $LN189@scanstring
$LN122@scanstring:
  00351	83 fe 02	 cmp	 esi, 2
  00354	75 06		 jne	 SHORT $LN120@scanstring
  00356	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  0035a	eb 03		 jmp	 SHORT $LN189@scanstring
$LN120@scanstring:
  0035c	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN189@scanstring:
  0035f	48 ff c3	 inc	 rbx
  00362	83 f8 75	 cmp	 eax, 117		; 00000075H
  00365	0f 85 a6 00 00
	00		 jne	 $LN35@scanstring

; 439  :                 Py_UCS4 c2 = 0;

  0036b	45 33 c9	 xor	 r9d, r9d

; 440  :                 end += 6;

  0036e	4c 8b e1	 mov	 r12, rcx

; 441  :                 /* Decode 4 hex digits */
; 442  :                 for (; next < end; next++) {

  00371	48 3b d9	 cmp	 rbx, rcx
  00374	0f 8d 93 00 00
	00		 jge	 $LN36@scanstring
  0037a	66 0f 1f 44 00
	00		 npad	 6
$LL45@scanstring:

; 443  :                     Py_UCS4 digit = PyUnicode_READ(kind, buf, next);

  00380	83 fe 01	 cmp	 esi, 1
  00383	75 06		 jne	 SHORT $LN126@scanstring
  00385	0f b6 14 3b	 movzx	 edx, BYTE PTR [rbx+rdi]
  00389	eb 0e		 jmp	 SHORT $LN125@scanstring
$LN126@scanstring:
  0038b	83 fe 02	 cmp	 esi, 2
  0038e	75 06		 jne	 SHORT $LN124@scanstring
  00390	0f b7 14 5f	 movzx	 edx, WORD PTR [rdi+rbx*2]
  00394	eb 03		 jmp	 SHORT $LN125@scanstring
$LN124@scanstring:
  00396	8b 14 9f	 mov	 edx, DWORD PTR [rdi+rbx*4]
$LN125@scanstring:

; 444  :                     c2 <<= 4;
; 445  :                     switch (digit) {

  00399	44 8d 42 d0	 lea	 r8d, DWORD PTR [rdx-48]
  0039d	41 c1 e1 04	 shl	 r9d, 4
  003a1	41 83 f8 36	 cmp	 r8d, 54			; 00000036H
  003a5	0f 87 31 01 00
	00		 ja	 $LN47@scanstring
  003ab	43 0f b6 84 03
	00 00 00 00	 movzx	 eax, BYTE PTR $LN172@scanstring[r11+r8]
  003b4	41 8b 8c 83 00
	00 00 00	 mov	 ecx, DWORD PTR $LN173@scanstring[r11+rax*4]
  003bc	49 03 cb	 add	 rcx, r11
  003bf	ff e1		 jmp	 rcx
$LN40@scanstring:

; 446  :                         case '0': case '1': case '2': case '3': case '4':
; 447  :                         case '5': case '6': case '7': case '8': case '9':
; 448  :                             c2 |= (digit - '0'); break;

  003c1	45 0b c8	 or	 r9d, r8d
  003c4	eb 0b		 jmp	 SHORT $LN44@scanstring
$LN39@scanstring:

; 449  :                         case 'a': case 'b': case 'c': case 'd': case 'e':
; 450  :                         case 'f':
; 451  :                             c2 |= (digit - 'a' + 10); break;

  003c6	8d 42 a9	 lea	 eax, DWORD PTR [rdx-87]
  003c9	eb 03		 jmp	 SHORT $LN190@scanstring
$LN38@scanstring:

; 452  :                         case 'A': case 'B': case 'C': case 'D': case 'E':
; 453  :                         case 'F':
; 454  :                             c2 |= (digit - 'A' + 10); break;

  003cb	8d 42 c9	 lea	 eax, DWORD PTR [rdx-55]
$LN190@scanstring:
  003ce	44 0b c8	 or	 r9d, eax
$LN44@scanstring:

; 441  :                 /* Decode 4 hex digits */
; 442  :                 for (; next < end; next++) {

  003d1	48 ff c3	 inc	 rbx
  003d4	49 3b dc	 cmp	 rbx, r12
  003d7	7c a7		 jl	 SHORT $LL45@scanstring

; 455  :                         default:
; 456  :                             raise_errmsg("Invalid \\uXXXX escape", pystr, end - 5);
; 457  :                             goto bail;
; 458  :                     }
; 459  :                 }
; 460  :                 if (Py_UNICODE_IS_LOW_SURROGATE(c2))

  003d9	41 8d 81 00 24
	ff ff		 lea	 eax, DWORD PTR [r9-56320]
  003e0	3d ff 03 00 00	 cmp	 eax, 1023		; 000003ffH
  003e5	77 26		 ja	 SHORT $LN36@scanstring

; 461  :                     c = Py_UNICODE_JOIN_SURROGATES(c, c2);

  003e7	41 81 e2 ff 03
	00 00		 and	 r10d, 1023		; 000003ffH
  003ee	41 81 e1 ff 03
	00 00		 and	 r9d, 1023		; 000003ffH
  003f5	41 c1 e2 0a	 shl	 r10d, 10
  003f9	45 0b d1	 or	 r10d, r9d
  003fc	41 81 c2 00 00
	01 00		 add	 r10d, 65536		; 00010000H
  00403	44 89 94 24 80
	00 00 00	 mov	 DWORD PTR c$20664[rsp], r10d

; 462  :                 else

  0040b	eb 04		 jmp	 SHORT $LN35@scanstring
$LN36@scanstring:

; 463  :                     end -= 6;

  0040d	49 83 ec 06	 sub	 r12, 6
$LN35@scanstring:

; 464  :             }
; 465  :         }
; 466  :         APPEND_OLD_CHUNK

  00411	48 85 ed	 test	 rbp, rbp
  00414	74 5b		 je	 SHORT $LN28@scanstring
  00416	4d 85 ed	 test	 r13, r13
  00419	75 13		 jne	 SHORT $LN32@scanstring
  0041b	33 c9		 xor	 ecx, ecx
  0041d	e8 00 00 00 00	 call	 PyList_New
  00422	4c 8b e8	 mov	 r13, rax
  00425	48 85 c0	 test	 rax, rax
  00428	0f 84 f5 01 00
	00		 je	 $bail$20660
$LN32@scanstring:
  0042e	48 8b d5	 mov	 rdx, rbp
  00431	49 8b cd	 mov	 rcx, r13
  00434	e8 00 00 00 00	 call	 PyList_Append
  00439	85 c0		 test	 eax, eax
  0043b	0f 85 24 01 00
	00		 jne	 $LN158@scanstring
  00441	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00448	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@PDCADMBJ@scanstring_unicode?$AA@
  0044f	4c 8b cd	 mov	 r9, rbp
  00452	41 b8 d2 01 00
	00		 mov	 r8d, 466		; 000001d2H
  00458	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00460	e8 00 00 00 00	 call	 _PyParallel_Guard
  00465	85 c0		 test	 eax, eax
  00467	75 08		 jne	 SHORT $LN28@scanstring
  00469	48 8b cd	 mov	 rcx, rbp
  0046c	e8 00 00 00 00	 call	 _Py_DecRef
$LN28@scanstring:

; 467  :         chunk = PyUnicode_FromKindAndData(PyUnicode_4BYTE_KIND, &c, 1);

  00471	41 b8 01 00 00
	00		 mov	 r8d, 1
  00477	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR c$20664[rsp]
  0047f	41 8d 48 03	 lea	 ecx, QWORD PTR [r8+3]
  00483	e8 00 00 00 00	 call	 PyUnicode_FromKindAndData
  00488	48 8b e8	 mov	 rbp, rax

; 468  :         if (chunk == NULL) {

  0048b	48 85 c0	 test	 rax, rax
  0048e	0f 84 8f 01 00
	00		 je	 $bail$20660

; 469  :             goto bail;
; 470  :         }
; 471  :     }

  00494	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR strict$[rsp]
  0049c	e9 0e fc ff ff	 jmp	 $LN191@scanstring
$LN155@scanstring:

; 360  :                 raise_errmsg("Invalid control character at", pystr, next);

  004a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@KFIIHLME@Invalid?5control?5character?5at?$AA@
  004a8	4c 8b c3	 mov	 r8, rbx
  004ab	49 8b d7	 mov	 rdx, r15
  004ae	e8 00 00 00 00	 call	 raise_errmsg

; 361  :                 goto bail;

  004b3	e9 6b 01 00 00	 jmp	 $bail$20660
$LN59@scanstring:

; 401  :                 default: c = 0;

  004b8	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR c$20664[rsp], 0
$LN162@scanstring:

; 404  :                 raise_errmsg("Invalid \\escape", pystr, end - 2);

  004c3	4d 8d 44 24 fe	 lea	 r8, QWORD PTR [r12-2]
  004c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFDKNFEA@Invalid?5?2escape?$AA@
  004cf	49 8b d7	 mov	 rdx, r15
  004d2	e8 00 00 00 00	 call	 raise_errmsg

; 405  :                 goto bail;

  004d7	e9 47 01 00 00	 jmp	 $bail$20660
$LN47@scanstring:

; 430  :                     default:
; 431  :                         raise_errmsg("Invalid \\uXXXX escape", pystr, end - 5);

  004dc	4d 8d 44 24 fb	 lea	 r8, QWORD PTR [r12-5]
  004e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@HFBFLOEL@Invalid?5?2uXXXX?5escape?$AA@
  004e8	49 8b d7	 mov	 rdx, r15
  004eb	e8 00 00 00 00	 call	 raise_errmsg

; 432  :                         goto bail;

  004f0	e9 2e 01 00 00	 jmp	 $bail$20660
$LN163@scanstring:

; 413  :                 raise_errmsg("Invalid \\uXXXX escape", pystr, next - 1);

  004f5	4c 8d 43 ff	 lea	 r8, QWORD PTR [rbx-1]
  004f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@HFBFLOEL@Invalid?5?2uXXXX?5escape?$AA@
  00500	49 8b d7	 mov	 rdx, r15
  00503	e8 00 00 00 00	 call	 raise_errmsg

; 414  :                 goto bail;

  00508	e9 16 01 00 00	 jmp	 $bail$20660
$LN160@scanstring:

; 472  : 
; 473  :     if (chunks == NULL) {

  0050d	4d 85 ed	 test	 r13, r13
  00510	75 3f		 jne	 SHORT $LN25@scanstring

; 474  :         if (chunk != NULL)

  00512	48 85 ed	 test	 rbp, rbp
  00515	74 16		 je	 SHORT $LN24@scanstring

; 486  :     }
; 487  : 
; 488  :     *next_end_ptr = end;

  00517	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR next_end_ptr$[rsp]
  0051f	48 8b fd	 mov	 rdi, rbp
  00522	48 89 18	 mov	 QWORD PTR [rax], rbx

; 489  :     return rval;

  00525	48 8b c5	 mov	 rax, rbp
  00528	e9 db 01 00 00	 jmp	 $LN183@scanstring
$LN24@scanstring:

; 475  :             rval = chunk;
; 476  :         else
; 477  :             rval = PyUnicode_FromStringAndSize("", 0);

  0052d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00534	33 d2		 xor	 edx, edx
  00536	e8 00 00 00 00	 call	 PyUnicode_FromStringAndSize
  0053b	48 8b f8	 mov	 rdi, rax

; 486  :     }
; 487  : 
; 488  :     *next_end_ptr = end;

  0053e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR next_end_ptr$[rsp]
  00546	48 89 18	 mov	 QWORD PTR [rax], rbx

; 489  :     return rval;

  00549	48 8b c7	 mov	 rax, rdi
  0054c	e9 b7 01 00 00	 jmp	 $LN183@scanstring
$LN25@scanstring:

; 478  :     }
; 479  :     else {
; 480  :         APPEND_OLD_CHUNK

  00551	48 85 ed	 test	 rbp, rbp
  00554	74 4e		 je	 SHORT $LN15@scanstring
  00556	48 8b d5	 mov	 rdx, rbp
  00559	49 8b cd	 mov	 rcx, r13
  0055c	e8 00 00 00 00	 call	 PyList_Append
  00561	85 c0		 test	 eax, eax
  00563	74 0d		 je	 SHORT $LN17@scanstring
$LN158@scanstring:
  00565	48 8b cd	 mov	 rcx, rbp
  00568	e8 00 00 00 00	 call	 _Py_DecRef
  0056d	e9 b1 00 00 00	 jmp	 $bail$20660
$LN17@scanstring:
  00572	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00579	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@PDCADMBJ@scanstring_unicode?$AA@
  00580	4c 8b cd	 mov	 r9, rbp
  00583	41 b8 e0 01 00
	00		 mov	 r8d, 480		; 000001e0H
  00589	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00591	e8 00 00 00 00	 call	 _PyParallel_Guard
  00596	85 c0		 test	 eax, eax
  00598	75 0a		 jne	 SHORT $LN15@scanstring
  0059a	48 8b cd	 mov	 rcx, rbp
  0059d	33 ed		 xor	 ebp, ebp
  0059f	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@scanstring:

; 481  :         rval = join_list_unicode(chunks);

  005a4	49 8b cd	 mov	 rcx, r13
  005a7	e8 00 00 00 00	 call	 join_list_unicode
  005ac	48 8b f8	 mov	 rdi, rax

; 482  :         if (rval == NULL) {

  005af	48 85 c0	 test	 rax, rax
  005b2	74 6f		 je	 SHORT $bail$20660

; 483  :             goto bail;
; 484  :         }
; 485  :         Py_CLEAR(chunks);

  005b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  005bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@PDCADMBJ@scanstring_unicode?$AA@
  005c2	4d 8b cd	 mov	 r9, r13
  005c5	41 b8 e5 01 00
	00		 mov	 r8d, 485		; 000001e5H
  005cb	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  005d3	e8 00 00 00 00	 call	 _PyParallel_Guard
  005d8	85 c0		 test	 eax, eax
  005da	75 08		 jne	 SHORT $LN10@scanstring
  005dc	49 8b cd	 mov	 rcx, r13
  005df	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@scanstring:

; 486  :     }
; 487  : 
; 488  :     *next_end_ptr = end;

  005e4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR next_end_ptr$[rsp]
  005ec	48 89 18	 mov	 QWORD PTR [rax], rbx

; 489  :     return rval;

  005ef	48 8b c7	 mov	 rax, rdi
  005f2	e9 11 01 00 00	 jmp	 $LN183@scanstring
$LN156@scanstring:

; 365  :             raise_errmsg("Unterminated string starting at", pystr, begin);

  005f7	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR begin$1$[rsp]
  005ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@GLFFIBAO@Unterminated?5string?5starting?5at?$AA@
  00606	49 8b d7	 mov	 rdx, r15
  00609	e8 00 00 00 00	 call	 raise_errmsg

; 366  :             goto bail;

  0060e	eb 13		 jmp	 SHORT $bail$20660
$LN93@scanstring:

; 348  :         PyErr_SetString(PyExc_ValueError, "end is out of bounds");

  00610	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00617	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@LLLKOJNO@end?5is?5out?5of?5bounds?$AA@
  0061e	e8 00 00 00 00	 call	 PyErr_SetString
$bail$20660:

; 490  : bail:
; 491  :     *next_end_ptr = -1;

  00623	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR next_end_ptr$[rsp]
  0062b	48 c7 00 ff ff
	ff ff		 mov	 QWORD PTR [rax], -1

; 492  :     Py_XDECREF(chunks);

  00632	4d 85 ed	 test	 r13, r13
  00635	74 65		 je	 SHORT $LN7@scanstring
  00637	e8 00 00 00 00	 call	 _Py_PXCTX
  0063c	85 c0		 test	 eax, eax
  0063e	75 5c		 jne	 SHORT $LN7@scanstring
  00640	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  00644	a8 20		 test	 al, 32			; 00000020H
  00646	75 4c		 jne	 SHORT $LN132@scanstring
  00648	84 c0		 test	 al, al
  0064a	78 48		 js	 SHORT $LN132@scanstring
  0064c	a8 02		 test	 al, 2
  0064e	75 4c		 jne	 SHORT $LN7@scanstring
  00650	49 ff 4d 50	 dec	 QWORD PTR [r13+80]
  00654	75 46		 jne	 SHORT $LN7@scanstring
  00656	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0065d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00664	4d 8b cd	 mov	 r9, r13
  00667	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0066d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00675	e8 00 00 00 00	 call	 _PyParallel_Guard
  0067a	49 8b cd	 mov	 rcx, r13
  0067d	85 c0		 test	 eax, eax
  0067f	74 07		 je	 SHORT $LN137@scanstring
  00681	e8 00 00 00 00	 call	 _Px_Dealloc
  00686	eb 14		 jmp	 SHORT $LN7@scanstring
$LN137@scanstring:
  00688	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  0068c	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00692	eb 08		 jmp	 SHORT $LN7@scanstring
$LN132@scanstring:
  00694	49 8b cd	 mov	 rcx, r13
  00697	e8 00 00 00 00	 call	 Px_DecRef
$LN7@scanstring:

; 493  :     Py_XDECREF(chunk);

  0069c	48 85 ed	 test	 rbp, rbp
  0069f	74 65		 je	 SHORT $LN3@scanstring
  006a1	e8 00 00 00 00	 call	 _Py_PXCTX
  006a6	85 c0		 test	 eax, eax
  006a8	75 5c		 jne	 SHORT $LN3@scanstring
  006aa	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  006ae	a8 20		 test	 al, 32			; 00000020H
  006b0	75 4c		 jne	 SHORT $LN143@scanstring
  006b2	84 c0		 test	 al, al
  006b4	78 48		 js	 SHORT $LN143@scanstring
  006b6	a8 02		 test	 al, 2
  006b8	75 4c		 jne	 SHORT $LN3@scanstring
  006ba	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  006be	75 46		 jne	 SHORT $LN3@scanstring
  006c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  006c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  006ce	4c 8b cd	 mov	 r9, rbp
  006d1	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  006d7	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  006df	e8 00 00 00 00	 call	 _PyParallel_Guard
  006e4	48 8b cd	 mov	 rcx, rbp
  006e7	85 c0		 test	 eax, eax
  006e9	74 07		 je	 SHORT $LN148@scanstring
  006eb	e8 00 00 00 00	 call	 _Px_Dealloc
  006f0	eb 14		 jmp	 SHORT $LN3@scanstring
$LN148@scanstring:
  006f2	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  006f6	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  006fc	eb 08		 jmp	 SHORT $LN3@scanstring
$LN143@scanstring:
  006fe	48 8b cd	 mov	 rcx, rbp
  00701	e8 00 00 00 00	 call	 Px_DecRef
$LN3@scanstring:

; 494  :     return NULL;

  00706	33 c0		 xor	 eax, eax
$LN183@scanstring:
  00708	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0070d	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00712	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00717	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]

; 495  : }

  0071c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00720	41 5f		 pop	 r15
  00722	41 5d		 pop	 r13
  00724	41 5c		 pop	 r12
  00726	5d		 pop	 rbp
  00727	c3		 ret	 0
$LN177@scanstring:
  00728	00 00 00 00	 DD	 $LN68@scanstring
  0072c	00 00 00 00	 DD	 $LN64@scanstring
  00730	00 00 00 00	 DD	 $LN63@scanstring
  00734	00 00 00 00	 DD	 $LN62@scanstring
  00738	00 00 00 00	 DD	 $LN61@scanstring
  0073c	00 00 00 00	 DD	 $LN60@scanstring
  00740	00 00 00 00	 DD	 $LN59@scanstring
$LN176@scanstring:
  00744	00		 DB	 0
  00745	06		 DB	 6
  00746	06		 DB	 6
  00747	06		 DB	 6
  00748	06		 DB	 6
  00749	06		 DB	 6
  0074a	06		 DB	 6
  0074b	06		 DB	 6
  0074c	06		 DB	 6
  0074d	06		 DB	 6
  0074e	06		 DB	 6
  0074f	06		 DB	 6
  00750	06		 DB	 6
  00751	00		 DB	 0
  00752	06		 DB	 6
  00753	06		 DB	 6
  00754	06		 DB	 6
  00755	06		 DB	 6
  00756	06		 DB	 6
  00757	06		 DB	 6
  00758	06		 DB	 6
  00759	06		 DB	 6
  0075a	06		 DB	 6
  0075b	06		 DB	 6
  0075c	06		 DB	 6
  0075d	06		 DB	 6
  0075e	06		 DB	 6
  0075f	06		 DB	 6
  00760	06		 DB	 6
  00761	06		 DB	 6
  00762	06		 DB	 6
  00763	06		 DB	 6
  00764	06		 DB	 6
  00765	06		 DB	 6
  00766	06		 DB	 6
  00767	06		 DB	 6
  00768	06		 DB	 6
  00769	06		 DB	 6
  0076a	06		 DB	 6
  0076b	06		 DB	 6
  0076c	06		 DB	 6
  0076d	06		 DB	 6
  0076e	06		 DB	 6
  0076f	06		 DB	 6
  00770	06		 DB	 6
  00771	06		 DB	 6
  00772	06		 DB	 6
  00773	06		 DB	 6
  00774	06		 DB	 6
  00775	06		 DB	 6
  00776	06		 DB	 6
  00777	06		 DB	 6
  00778	06		 DB	 6
  00779	06		 DB	 6
  0077a	06		 DB	 6
  0077b	06		 DB	 6
  0077c	06		 DB	 6
  0077d	06		 DB	 6
  0077e	00		 DB	 0
  0077f	06		 DB	 6
  00780	06		 DB	 6
  00781	06		 DB	 6
  00782	06		 DB	 6
  00783	06		 DB	 6
  00784	01		 DB	 1
  00785	06		 DB	 6
  00786	06		 DB	 6
  00787	06		 DB	 6
  00788	02		 DB	 2
  00789	06		 DB	 6
  0078a	06		 DB	 6
  0078b	06		 DB	 6
  0078c	06		 DB	 6
  0078d	06		 DB	 6
  0078e	06		 DB	 6
  0078f	06		 DB	 6
  00790	03		 DB	 3
  00791	06		 DB	 6
  00792	06		 DB	 6
  00793	06		 DB	 6
  00794	04		 DB	 4
  00795	06		 DB	 6
  00796	05		 DB	 5
  00797	90		 npad	 1
$LN175@scanstring:
  00798	00 00 00 00	 DD	 $LN50@scanstring
  0079c	00 00 00 00	 DD	 $LN48@scanstring
  007a0	00 00 00 00	 DD	 $LN49@scanstring
  007a4	00 00 00 00	 DD	 $LN47@scanstring
$LN174@scanstring:
  007a8	00		 DB	 0
  007a9	00		 DB	 0
  007aa	00		 DB	 0
  007ab	00		 DB	 0
  007ac	00		 DB	 0
  007ad	00		 DB	 0
  007ae	00		 DB	 0
  007af	00		 DB	 0
  007b0	00		 DB	 0
  007b1	00		 DB	 0
  007b2	03		 DB	 3
  007b3	03		 DB	 3
  007b4	03		 DB	 3
  007b5	03		 DB	 3
  007b6	03		 DB	 3
  007b7	03		 DB	 3
  007b8	03		 DB	 3
  007b9	01		 DB	 1
  007ba	01		 DB	 1
  007bb	01		 DB	 1
  007bc	01		 DB	 1
  007bd	01		 DB	 1
  007be	01		 DB	 1
  007bf	03		 DB	 3
  007c0	03		 DB	 3
  007c1	03		 DB	 3
  007c2	03		 DB	 3
  007c3	03		 DB	 3
  007c4	03		 DB	 3
  007c5	03		 DB	 3
  007c6	03		 DB	 3
  007c7	03		 DB	 3
  007c8	03		 DB	 3
  007c9	03		 DB	 3
  007ca	03		 DB	 3
  007cb	03		 DB	 3
  007cc	03		 DB	 3
  007cd	03		 DB	 3
  007ce	03		 DB	 3
  007cf	03		 DB	 3
  007d0	03		 DB	 3
  007d1	03		 DB	 3
  007d2	03		 DB	 3
  007d3	03		 DB	 3
  007d4	03		 DB	 3
  007d5	03		 DB	 3
  007d6	03		 DB	 3
  007d7	03		 DB	 3
  007d8	03		 DB	 3
  007d9	02		 DB	 2
  007da	02		 DB	 2
  007db	02		 DB	 2
  007dc	02		 DB	 2
  007dd	02		 DB	 2
  007de	02		 DB	 2
  007df	90		 npad	 1
$LN173@scanstring:
  007e0	00 00 00 00	 DD	 $LN40@scanstring
  007e4	00 00 00 00	 DD	 $LN38@scanstring
  007e8	00 00 00 00	 DD	 $LN39@scanstring
  007ec	00 00 00 00	 DD	 $LN47@scanstring
$LN172@scanstring:
  007f0	00		 DB	 0
  007f1	00		 DB	 0
  007f2	00		 DB	 0
  007f3	00		 DB	 0
  007f4	00		 DB	 0
  007f5	00		 DB	 0
  007f6	00		 DB	 0
  007f7	00		 DB	 0
  007f8	00		 DB	 0
  007f9	00		 DB	 0
  007fa	03		 DB	 3
  007fb	03		 DB	 3
  007fc	03		 DB	 3
  007fd	03		 DB	 3
  007fe	03		 DB	 3
  007ff	03		 DB	 3
  00800	03		 DB	 3
  00801	01		 DB	 1
  00802	01		 DB	 1
  00803	01		 DB	 1
  00804	01		 DB	 1
  00805	01		 DB	 1
  00806	01		 DB	 1
  00807	03		 DB	 3
  00808	03		 DB	 3
  00809	03		 DB	 3
  0080a	03		 DB	 3
  0080b	03		 DB	 3
  0080c	03		 DB	 3
  0080d	03		 DB	 3
  0080e	03		 DB	 3
  0080f	03		 DB	 3
  00810	03		 DB	 3
  00811	03		 DB	 3
  00812	03		 DB	 3
  00813	03		 DB	 3
  00814	03		 DB	 3
  00815	03		 DB	 3
  00816	03		 DB	 3
  00817	03		 DB	 3
  00818	03		 DB	 3
  00819	03		 DB	 3
  0081a	03		 DB	 3
  0081b	03		 DB	 3
  0081c	03		 DB	 3
  0081d	03		 DB	 3
  0081e	03		 DB	 3
  0081f	03		 DB	 3
  00820	03		 DB	 3
  00821	02		 DB	 2
  00822	02		 DB	 2
  00823	02		 DB	 2
  00824	02		 DB	 2
  00825	02		 DB	 2
  00826	02		 DB	 2
scanstring_unicode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@OIEJEOOL@first?5argument?5must?5be?5a?5string?0@ ; `string'
PUBLIC	??_C@_0BB@CDAODGJG@OO?$CG?$HMi?3scanstring?$AA@	; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$py_scanstring DD imagerel py_scanstring
	DD	imagerel py_scanstring+165
	DD	imagerel $unwind$py_scanstring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$py_scanstring DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_0CL@OIEJEOOL@first?5argument?5must?5be?5a?5string?0@
CONST	SEGMENT
??_C@_0CL@OIEJEOOL@first?5argument?5must?5be?5a?5string?0@ DB 'first argu'
	DB	'ment must be a string, not %.80s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CDAODGJG@OO?$CG?$HMi?3scanstring?$AA@
CONST	SEGMENT
??_C@_0BB@CDAODGJG@OO?$CG?$HMi?3scanstring?$AA@ DB 'OO&|i:scanstring', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT py_scanstring
_TEXT	SEGMENT
pystr$ = 48
end$ = 56
self$ = 80
args$ = 88
strict$ = 96
next_end$ = 104
py_scanstring PROC					; COMDAT

; 512  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00004	48 8b c2	 mov	 rax, rdx

; 513  :     PyObject *pystr;
; 514  :     PyObject *rval;
; 515  :     Py_ssize_t end;
; 516  :     Py_ssize_t next_end = -1;
; 517  :     int strict = 1;
; 518  :     if (!PyArg_ParseTuple(args, "OO&|i:scanstring", &pystr, _convertPyInt_AsSsize_t, &end, &strict)) {

  00007	48 8d 4c 24 60	 lea	 rcx, QWORD PTR strict$[rsp]
  0000c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_convertPyInt_AsSsize_t
  00013	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00018	48 8d 4c 24 38	 lea	 rcx, QWORD PTR end$[rsp]
  0001d	4c 8d 44 24 30	 lea	 r8, QWORD PTR pystr$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@CDAODGJG@OO?$CG?$HMi?3scanstring?$AA@
  0002e	48 8b c8	 mov	 rcx, rax
  00031	48 c7 44 24 68
	ff ff ff ff	 mov	 QWORD PTR next_end$[rsp], -1
  0003a	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR strict$[rsp], 1
  00042	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00047	85 c0		 test	 eax, eax

; 519  :         return NULL;

  00049	74 53		 je	 SHORT $LN6@py_scanstr

; 520  :     }
; 521  :     if (PyUnicode_Check(pystr)) {

  0004b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pystr$[rsp]
  00050	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  00054	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  0005f	74 26		 je	 SHORT $LN2@py_scanstr

; 522  :         rval = scanstring_unicode(pystr, end, strict, &next_end);

  00061	44 8b 44 24 60	 mov	 r8d, DWORD PTR strict$[rsp]
  00066	48 8b 54 24 38	 mov	 rdx, QWORD PTR end$[rsp]
  0006b	4c 8d 4c 24 68	 lea	 r9, QWORD PTR next_end$[rsp]
  00070	e8 00 00 00 00	 call	 scanstring_unicode

; 529  :     }
; 530  :     return _build_rval_index_tuple(rval, next_end);

  00075	48 8b 54 24 68	 mov	 rdx, QWORD PTR next_end$[rsp]
  0007a	48 8b c8	 mov	 rcx, rax
  0007d	e8 00 00 00 00	 call	 _build_rval_index_tuple

; 531  : }

  00082	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00086	c3		 ret	 0
$LN2@py_scanstr:

; 523  :     }
; 524  :     else {
; 525  :         PyErr_Format(PyExc_TypeError,
; 526  :                      "first argument must be a string, not %.80s",
; 527  :                      Py_TYPE(pystr)->tp_name);

  00087	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0008b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@OIEJEOOL@first?5argument?5must?5be?5a?5string?0@
  00099	e8 00 00 00 00	 call	 PyErr_Format
$LN6@py_scanstr:

; 528  :         return NULL;

  0009e	33 c0		 xor	 eax, eax

; 531  : }

  000a0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a4	c3		 ret	 0
py_scanstring ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$py_encode_basestring_ascii DD imagerel py_encode_basestring_ascii
	DD	imagerel py_encode_basestring_ascii+63
	DD	imagerel $unwind$py_encode_basestring_ascii
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$py_encode_basestring_ascii DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT py_encode_basestring_ascii
_TEXT	SEGMENT
self$ = 48
pystr$ = 56
py_encode_basestring_ascii PROC				; COMDAT

; 541  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 542  :     PyObject *rval;
; 543  :     /* Return an ASCII-only JSON representation of a Python string */
; 544  :     /* METH_O */
; 545  :     if (PyUnicode_Check(pystr)) {

  00004	4c 8b 42 58	 mov	 r8, QWORD PTR [rdx+88]
  00008	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  00013	74 0c		 je	 SHORT $LN2@py_encode_

; 546  :         rval = ascii_escape_unicode(pystr);

  00015	48 8b ca	 mov	 rcx, rdx

; 553  :     }
; 554  :     return rval;
; 555  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	e9 00 00 00 00	 jmp	 ascii_escape_unicode
$LN2@py_encode_:

; 547  :     }
; 548  :     else {
; 549  :         PyErr_Format(PyExc_TypeError,
; 550  :                      "first argument must be a string, not %.80s",
; 551  :                      Py_TYPE(pystr)->tp_name);

  00021	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00025	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@OIEJEOOL@first?5argument?5must?5be?5a?5string?0@
  00033	e8 00 00 00 00	 call	 PyErr_Format

; 552  :         return NULL;

  00038	33 c0		 xor	 eax, eax

; 553  :     }
; 554  :     return rval;
; 555  : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
py_encode_basestring_ascii ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@GKNIGJBL@scanner_traverse?$AA@	; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$scanner_traverse DD imagerel scanner_traverse
	DD	imagerel scanner_traverse+390
	DD	imagerel $unwind$scanner_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scanner_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BB@GKNIGJBL@scanner_traverse?$AA@
CONST	SEGMENT
??_C@_0BB@GKNIGJBL@scanner_traverse?$AA@ DB 'scanner_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT scanner_traverse
_TEXT	SEGMENT
self$ = 48
visit$ = 56
arg$ = 64
scanner_traverse PROC					; COMDAT

; 567  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 568  :     PyScannerObject *s;
; 569  :     assert(PyScanner_Check(self));
; 570  :     s = (PyScannerObject *)self;
; 571  :     Py_VISIT(s->strict);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN33@scanner_tr
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GKNIGJBL@scanner_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 3b 02 00
	00		 mov	 r8d, 571		; 0000023bH
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN33@scanner_tr:
  0003d	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00041	48 85 c9	 test	 rcx, rcx
  00044	74 0d		 je	 SHORT $LN35@scanner_tr
  00046	48 8b d7	 mov	 rdx, rdi
  00049	ff d6		 call	 rsi
  0004b	85 c0		 test	 eax, eax
  0004d	0f 85 23 01 00
	00		 jne	 $LN37@scanner_tr
$LN35@scanner_tr:

; 572  :     Py_VISIT(s->object_hook);

  00053	e8 00 00 00 00	 call	 _Py_PXCTX
  00058	85 c0		 test	 eax, eax
  0005a	74 1c		 je	 SHORT $LN27@scanner_tr
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GKNIGJBL@scanner_traverse?$AA@
  0006a	45 33 c9	 xor	 r9d, r9d
  0006d	41 b8 3c 02 00
	00		 mov	 r8d, 572		; 0000023cH
  00073	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN27@scanner_tr:
  00078	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  0007c	48 85 c9	 test	 rcx, rcx
  0007f	74 0d		 je	 SHORT $LN29@scanner_tr
  00081	48 8b d7	 mov	 rdx, rdi
  00084	ff d6		 call	 rsi
  00086	85 c0		 test	 eax, eax
  00088	0f 85 e8 00 00
	00		 jne	 $LN37@scanner_tr
$LN29@scanner_tr:

; 573  :     Py_VISIT(s->object_pairs_hook);

  0008e	e8 00 00 00 00	 call	 _Py_PXCTX
  00093	85 c0		 test	 eax, eax
  00095	74 1c		 je	 SHORT $LN21@scanner_tr
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GKNIGJBL@scanner_traverse?$AA@
  000a5	45 33 c9	 xor	 r9d, r9d
  000a8	41 b8 3d 02 00
	00		 mov	 r8d, 573		; 0000023dH
  000ae	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN21@scanner_tr:
  000b3	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  000b7	48 85 c9	 test	 rcx, rcx
  000ba	74 0d		 je	 SHORT $LN23@scanner_tr
  000bc	48 8b d7	 mov	 rdx, rdi
  000bf	ff d6		 call	 rsi
  000c1	85 c0		 test	 eax, eax
  000c3	0f 85 ad 00 00
	00		 jne	 $LN37@scanner_tr
$LN23@scanner_tr:

; 574  :     Py_VISIT(s->parse_float);

  000c9	e8 00 00 00 00	 call	 _Py_PXCTX
  000ce	85 c0		 test	 eax, eax
  000d0	74 1c		 je	 SHORT $LN15@scanner_tr
  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GKNIGJBL@scanner_traverse?$AA@
  000e0	45 33 c9	 xor	 r9d, r9d
  000e3	41 b8 3e 02 00
	00		 mov	 r8d, 574		; 0000023eH
  000e9	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN15@scanner_tr:
  000ee	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  000f2	48 85 c9	 test	 rcx, rcx
  000f5	74 09		 je	 SHORT $LN17@scanner_tr
  000f7	48 8b d7	 mov	 rdx, rdi
  000fa	ff d6		 call	 rsi
  000fc	85 c0		 test	 eax, eax
  000fe	75 76		 jne	 SHORT $LN37@scanner_tr
$LN17@scanner_tr:

; 575  :     Py_VISIT(s->parse_int);

  00100	e8 00 00 00 00	 call	 _Py_PXCTX
  00105	85 c0		 test	 eax, eax
  00107	74 1c		 je	 SHORT $LN9@scanner_tr
  00109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00110	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GKNIGJBL@scanner_traverse?$AA@
  00117	45 33 c9	 xor	 r9d, r9d
  0011a	41 b8 3f 02 00
	00		 mov	 r8d, 575		; 0000023fH
  00120	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@scanner_tr:
  00125	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  0012c	48 85 c9	 test	 rcx, rcx
  0012f	74 09		 je	 SHORT $LN11@scanner_tr
  00131	48 8b d7	 mov	 rdx, rdi
  00134	ff d6		 call	 rsi
  00136	85 c0		 test	 eax, eax
  00138	75 3c		 jne	 SHORT $LN37@scanner_tr
$LN11@scanner_tr:

; 576  :     Py_VISIT(s->parse_constant);

  0013a	e8 00 00 00 00	 call	 _Py_PXCTX
  0013f	85 c0		 test	 eax, eax
  00141	74 1c		 je	 SHORT $LN3@scanner_tr
  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GKNIGJBL@scanner_traverse?$AA@
  00151	45 33 c9	 xor	 r9d, r9d
  00154	41 b8 40 02 00
	00		 mov	 r8d, 576		; 00000240H
  0015a	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@scanner_tr:
  0015f	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
  00166	48 85 c9	 test	 rcx, rcx
  00169	74 09		 je	 SHORT $LN5@scanner_tr
  0016b	48 8b d7	 mov	 rdx, rdi
  0016e	ff d6		 call	 rsi
  00170	85 c0		 test	 eax, eax
  00172	75 02		 jne	 SHORT $LN37@scanner_tr
$LN5@scanner_tr:

; 577  :     return 0;

  00174	33 c0		 xor	 eax, eax
$LN37@scanner_tr:

; 578  : }

  00176	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0017b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00180	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00184	5f		 pop	 rdi
  00185	c3		 ret	 0
scanner_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@NCFCJOBO@scanner_clear?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$scanner_clear DD imagerel scanner_clear
	DD	imagerel scanner_clear+1214
	DD	imagerel $unwind$scanner_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scanner_clear DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0O@NCFCJOBO@scanner_clear?$AA@
CONST	SEGMENT
??_C@_0O@NCFCJOBO@scanner_clear?$AA@ DB 'scanner_clear', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_json.c
CONST	ENDS
;	COMDAT scanner_clear
_TEXT	SEGMENT
self$ = 64
scanner_clear PROC					; COMDAT

; 582  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 583  :     PyScannerObject *s;
; 584  :     assert(PyScanner_Check(self));
; 585  :     s = (PyScannerObject *)self;
; 586  :     Py_CLEAR(s->strict);

  0000f	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  00013	33 f6		 xor	 esi, esi
  00015	48 8b f9	 mov	 rdi, rcx
  00018	4d 85 c9	 test	 r9, r9
  0001b	0f 84 92 00 00
	00		 je	 $LN27@scanner_cl
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@NCFCJOBO@scanner_clear?$AA@
  0002f	41 b8 4a 02 00
	00		 mov	 r8d, 586		; 0000024aH
  00035	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0003d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00042	85 c0		 test	 eax, eax
  00044	75 6d		 jne	 SHORT $LN27@scanner_cl
  00046	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  0004a	48 89 77 60	 mov	 QWORD PTR [rdi+96], rsi
  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	75 5c		 jne	 SHORT $LN27@scanner_cl
  00057	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0005b	a8 20		 test	 al, 32			; 00000020H
  0005d	75 4c		 jne	 SHORT $LN35@scanner_cl
  0005f	84 c0		 test	 al, al
  00061	78 48		 js	 SHORT $LN35@scanner_cl
  00063	a8 02		 test	 al, 2
  00065	75 4c		 jne	 SHORT $LN27@scanner_cl
  00067	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0006b	75 46		 jne	 SHORT $LN27@scanner_cl
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0007b	4c 8b cb	 mov	 r9, rbx
  0007e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00084	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0008c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00091	48 8b cb	 mov	 rcx, rbx
  00094	85 c0		 test	 eax, eax
  00096	74 07		 je	 SHORT $LN40@scanner_cl
  00098	e8 00 00 00 00	 call	 _Px_Dealloc
  0009d	eb 14		 jmp	 SHORT $LN27@scanner_cl
$LN40@scanner_cl:
  0009f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000a3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000a9	eb 08		 jmp	 SHORT $LN27@scanner_cl
$LN35@scanner_cl:
  000ab	48 8b cb	 mov	 rcx, rbx
  000ae	e8 00 00 00 00	 call	 Px_DecRef
$LN27@scanner_cl:

; 587  :     Py_CLEAR(s->object_hook);

  000b3	4c 8b 4f 68	 mov	 r9, QWORD PTR [rdi+104]
  000b7	4d 85 c9	 test	 r9, r9
  000ba	0f 84 92 00 00
	00		 je	 $LN23@scanner_cl
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@NCFCJOBO@scanner_clear?$AA@
  000ce	41 b8 4b 02 00
	00		 mov	 r8d, 587		; 0000024bH
  000d4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000dc	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e1	85 c0		 test	 eax, eax
  000e3	75 6d		 jne	 SHORT $LN23@scanner_cl
  000e5	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
  000e9	48 89 77 68	 mov	 QWORD PTR [rdi+104], rsi
  000ed	e8 00 00 00 00	 call	 _Py_PXCTX
  000f2	85 c0		 test	 eax, eax
  000f4	75 5c		 jne	 SHORT $LN23@scanner_cl
  000f6	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000fa	a8 20		 test	 al, 32			; 00000020H
  000fc	75 4c		 jne	 SHORT $LN46@scanner_cl
  000fe	84 c0		 test	 al, al
  00100	78 48		 js	 SHORT $LN46@scanner_cl
  00102	a8 02		 test	 al, 2
  00104	75 4c		 jne	 SHORT $LN23@scanner_cl
  00106	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0010a	75 46		 jne	 SHORT $LN23@scanner_cl
  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0011a	4c 8b cb	 mov	 r9, rbx
  0011d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00123	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0012b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00130	48 8b cb	 mov	 rcx, rbx
  00133	85 c0		 test	 eax, eax
  00135	74 07		 je	 SHORT $LN51@scanner_cl
  00137	e8 00 00 00 00	 call	 _Px_Dealloc
  0013c	eb 14		 jmp	 SHORT $LN23@scanner_cl
$LN51@scanner_cl:
  0013e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00142	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00148	eb 08		 jmp	 SHORT $LN23@scanner_cl
$LN46@scanner_cl:
  0014a	48 8b cb	 mov	 rcx, rbx
  0014d	e8 00 00 00 00	 call	 Px_DecRef
$LN23@scanner_cl:

; 588  :     Py_CLEAR(s->object_pairs_hook);

  00152	4c 8b 4f 70	 mov	 r9, QWORD PTR [rdi+112]
  00156	4d 85 c9	 test	 r9, r9
  00159	0f 84 92 00 00
	00		 je	 $LN19@scanner_cl
  0015f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@NCFCJOBO@scanner_clear?$AA@
  0016d	41 b8 4c 02 00
	00		 mov	 r8d, 588		; 0000024cH
  00173	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0017b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00180	85 c0		 test	 eax, eax
  00182	75 6d		 jne	 SHORT $LN19@scanner_cl
  00184	48 8b 5f 70	 mov	 rbx, QWORD PTR [rdi+112]
  00188	48 89 77 70	 mov	 QWORD PTR [rdi+112], rsi
  0018c	e8 00 00 00 00	 call	 _Py_PXCTX
  00191	85 c0		 test	 eax, eax
  00193	75 5c		 jne	 SHORT $LN19@scanner_cl
  00195	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00199	a8 20		 test	 al, 32			; 00000020H
  0019b	75 4c		 jne	 SHORT $LN57@scanner_cl
  0019d	84 c0		 test	 al, al
  0019f	78 48		 js	 SHORT $LN57@scanner_cl
  001a1	a8 02		 test	 al, 2
  001a3	75 4c		 jne	 SHORT $LN19@scanner_cl
  001a5	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001a9	75 46		 jne	 SHORT $LN19@scanner_cl
  001ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001b9	4c 8b cb	 mov	 r9, rbx
  001bc	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001c2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001ca	e8 00 00 00 00	 call	 _PyParallel_Guard
  001cf	48 8b cb	 mov	 rcx, rbx
  001d2	85 c0		 test	 eax, eax
  001d4	74 07		 je	 SHORT $LN62@scanner_cl
  001d6	e8 00 00 00 00	 call	 _Px_Dealloc
  001db	eb 14		 jmp	 SHORT $LN19@scanner_cl
$LN62@scanner_cl:
  001dd	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001e1	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001e7	eb 08		 jmp	 SHORT $LN19@scanner_cl
$LN57@scanner_cl:
  001e9	48 8b cb	 mov	 rcx, rbx
  001ec	e8 00 00 00 00	 call	 Px_DecRef
$LN19@scanner_cl:

; 589  :     Py_CLEAR(s->parse_float);

  001f1	4c 8b 4f 78	 mov	 r9, QWORD PTR [rdi+120]
  001f5	4d 85 c9	 test	 r9, r9
  001f8	0f 84 92 00 00
	00		 je	 $LN15@scanner_cl
  001fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00205	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@NCFCJOBO@scanner_clear?$AA@
  0020c	41 b8 4d 02 00
	00		 mov	 r8d, 589		; 0000024dH
  00212	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0021a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0021f	85 c0		 test	 eax, eax
  00221	75 6d		 jne	 SHORT $LN15@scanner_cl
  00223	48 8b 5f 78	 mov	 rbx, QWORD PTR [rdi+120]
  00227	48 89 77 78	 mov	 QWORD PTR [rdi+120], rsi
  0022b	e8 00 00 00 00	 call	 _Py_PXCTX
  00230	85 c0		 test	 eax, eax
  00232	75 5c		 jne	 SHORT $LN15@scanner_cl
  00234	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00238	a8 20		 test	 al, 32			; 00000020H
  0023a	75 4c		 jne	 SHORT $LN68@scanner_cl
  0023c	84 c0		 test	 al, al
  0023e	78 48		 js	 SHORT $LN68@scanner_cl
  00240	a8 02		 test	 al, 2
  00242	75 4c		 jne	 SHORT $LN15@scanner_cl
  00244	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00248	75 46		 jne	 SHORT $LN15@scanner_cl
  0024a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00251	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00258	4c 8b cb	 mov	 r9, rbx
  0025b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00261	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00269	e8 00 00 00 00	 call	 _PyParallel_Guard
  0026e	48 8b cb	 mov	 rcx, rbx
  00271	85 c0		 test	 eax, eax
  00273	74 07		 je	 SHORT $LN73@scanner_cl
  00275	e8 00 00 00 00	 call	 _Px_Dealloc
  0027a	eb 14		 jmp	 SHORT $LN15@scanner_cl
$LN73@scanner_cl:
  0027c	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00280	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00286	eb 08		 jmp	 SHORT $LN15@scanner_cl
$LN68@scanner_cl:
  00288	48 8b cb	 mov	 rcx, rbx
  0028b	e8 00 00 00 00	 call	 Px_DecRef
$LN15@scanner_cl:

; 590  :     Py_CLEAR(s->parse_int);

  00290	4c 8b 8f 80 00
	00 00		 mov	 r9, QWORD PTR [rdi+128]
  00297	4d 85 c9	 test	 r9, r9
  0029a	0f 84 98 00 00
	00		 je	 $LN11@scanner_cl
  002a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  002a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@NCFCJOBO@scanner_clear?$AA@
  002ae	41 b8 4e 02 00
	00		 mov	 r8d, 590		; 0000024eH
  002b4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002bc	e8 00 00 00 00	 call	 _PyParallel_Guard
  002c1	85 c0		 test	 eax, eax
  002c3	75 73		 jne	 SHORT $LN11@scanner_cl
  002c5	48 8b 9f 80 00
	00 00		 mov	 rbx, QWORD PTR [rdi+128]
  002cc	48 89 b7 80 00
	00 00		 mov	 QWORD PTR [rdi+128], rsi
  002d3	e8 00 00 00 00	 call	 _Py_PXCTX
  002d8	85 c0		 test	 eax, eax
  002da	75 5c		 jne	 SHORT $LN11@scanner_cl
  002dc	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  002e0	a8 20		 test	 al, 32			; 00000020H
  002e2	75 4c		 jne	 SHORT $LN79@scanner_cl
  002e4	84 c0		 test	 al, al
  002e6	78 48		 js	 SHORT $LN79@scanner_cl
  002e8	a8 02		 test	 al, 2
  002ea	75 4c		 jne	 SHORT $LN11@scanner_cl
  002ec	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  002f0	75 46		 jne	 SHORT $LN11@scanner_cl
  002f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00300	4c 8b cb	 mov	 r9, rbx
  00303	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00309	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00311	e8 00 00 00 00	 call	 _PyParallel_Guard
  00316	48 8b cb	 mov	 rcx, rbx
  00319	85 c0		 test	 eax, eax
  0031b	74 07		 je	 SHORT $LN84@scanner_cl
  0031d	e8 00 00 00 00	 call	 _Px_Dealloc
  00322	eb 14		 jmp	 SHORT $LN11@scanner_cl
$LN84@scanner_cl:
  00324	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00328	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0032e	eb 08		 jmp	 SHORT $LN11@scanner_cl
$LN79@scanner_cl:
  00330	48 8b cb	 mov	 rcx, rbx
  00333	e8 00 00 00 00	 call	 Px_DecRef
$LN11@scanner_cl:

; 591  :     Py_CLEAR(s->parse_constant);

  00338	4c 8b 8f 88 00
	00 00		 mov	 r9, QWORD PTR [rdi+136]
  0033f	4d 85 c9	 test	 r9, r9
  00342	0f 84 98 00 00
	00		 je	 $LN7@scanner_cl
  00348	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  0034f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@NCFCJOBO@scanner_clear?$AA@
  00356	41 b8 4f 02 00
	00		 mov	 r8d, 591		; 0000024fH
  0035c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00364	e8 00 00 00 00	 call	 _PyParallel_Guard
  00369	85 c0		 test	 eax, eax
  0036b	75 73		 jne	 SHORT $LN7@scanner_cl
  0036d	48 8b 9f 88 00
	00 00		 mov	 rbx, QWORD PTR [rdi+136]
  00374	48 89 b7 88 00
	00 00		 mov	 QWORD PTR [rdi+136], rsi
  0037b	e8 00 00 00 00	 call	 _Py_PXCTX
  00380	85 c0		 test	 eax, eax
  00382	75 5c		 jne	 SHORT $LN7@scanner_cl
  00384	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00388	a8 20		 test	 al, 32			; 00000020H
  0038a	75 4c		 jne	 SHORT $LN90@scanner_cl
  0038c	84 c0		 test	 al, al
  0038e	78 48		 js	 SHORT $LN90@scanner_cl
  00390	a8 02		 test	 al, 2
  00392	75 4c		 jne	 SHORT $LN7@scanner_cl
  00394	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00398	75 46		 jne	 SHORT $LN7@scanner_cl
  0039a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  003a8	4c 8b cb	 mov	 r9, rbx
  003ab	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  003b1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003b9	e8 00 00 00 00	 call	 _PyParallel_Guard
  003be	48 8b cb	 mov	 rcx, rbx
  003c1	85 c0		 test	 eax, eax
  003c3	74 07		 je	 SHORT $LN95@scanner_cl
  003c5	e8 00 00 00 00	 call	 _Px_Dealloc
  003ca	eb 14		 jmp	 SHORT $LN7@scanner_cl
$LN95@scanner_cl:
  003cc	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  003d0	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  003d6	eb 08		 jmp	 SHORT $LN7@scanner_cl
$LN90@scanner_cl:
  003d8	48 8b cb	 mov	 rcx, rbx
  003db	e8 00 00 00 00	 call	 Px_DecRef
$LN7@scanner_cl:

; 592  :     Py_CLEAR(s->memo);

  003e0	4c 8b 8f 90 00
	00 00		 mov	 r9, QWORD PTR [rdi+144]
  003e7	4d 85 c9	 test	 r9, r9
  003ea	0f 84 bc 00 00
	00		 je	 $LN110@scanner_cl
  003f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  003f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@NCFCJOBO@scanner_clear?$AA@
  003fe	41 b8 50 02 00
	00		 mov	 r8d, 592		; 00000250H
  00404	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0040c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00411	85 c0		 test	 eax, eax
  00413	0f 85 93 00 00
	00		 jne	 $LN110@scanner_cl
  00419	48 8b 9f 90 00
	00 00		 mov	 rbx, QWORD PTR [rdi+144]
  00420	48 89 b7 90 00
	00 00		 mov	 QWORD PTR [rdi+144], rsi
  00427	e8 00 00 00 00	 call	 _Py_PXCTX
  0042c	85 c0		 test	 eax, eax
  0042e	75 7c		 jne	 SHORT $LN110@scanner_cl
  00430	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00434	a8 20		 test	 al, 32			; 00000020H
  00436	75 6c		 jne	 SHORT $LN101@scanner_cl
  00438	84 c0		 test	 al, al
  0043a	78 68		 js	 SHORT $LN101@scanner_cl
  0043c	a8 02		 test	 al, 2
  0043e	75 6c		 jne	 SHORT $LN110@scanner_cl
  00440	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00444	75 66		 jne	 SHORT $LN110@scanner_cl
  00446	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0044d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00454	4c 8b cb	 mov	 r9, rbx
  00457	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0045d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00465	e8 00 00 00 00	 call	 _PyParallel_Guard
  0046a	48 8b cb	 mov	 rcx, rbx
  0046d	85 c0		 test	 eax, eax
  0046f	74 17		 je	 SHORT $LN106@scanner_cl
  00471	e8 00 00 00 00	 call	 _Px_Dealloc

; 593  :     return 0;

  00476	33 c0		 xor	 eax, eax

; 594  : }

  00478	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0047d	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00482	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00486	5f		 pop	 rdi
  00487	c3		 ret	 0

; 592  :     Py_CLEAR(s->memo);

$LN106@scanner_cl:
  00488	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0048c	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 593  :     return 0;

  00492	33 c0		 xor	 eax, eax

; 594  : }

  00494	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00499	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0049e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  004a2	5f		 pop	 rdi
  004a3	c3		 ret	 0

; 592  :     Py_CLEAR(s->memo);

$LN101@scanner_cl:
  004a4	48 8b cb	 mov	 rcx, rbx
  004a7	e8 00 00 00 00	 call	 Px_DecRef
$LN110@scanner_cl:

; 594  : }

  004ac	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  004b1	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  004b6	33 c0		 xor	 eax, eax
  004b8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  004bc	5f		 pop	 rdi
  004bd	c3		 ret	 0
scanner_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@COPDFPMD@Expecting?5property?5name?5enclosed@ ; `string'
PUBLIC	??_C@_0BI@EKLMLIIK@Expecting?5?8?0?8?5delimiter?$AA@ ; `string'
PUBLIC	??_C@_0BG@PKFBKFJI@_parse_object_unicode?$AA@	; `string'
PUBLIC	??_C@_0BI@FOFOMBIN@Expecting?5?8?3?8?5delimiter?$AA@ ; `string'
PUBLIC	??_C@_0BB@GKGDLNNB@Expecting?5object?$AA@	; `string'
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	PyTuple_Pack:PROC
EXTRN	PyDict_SetItem:PROC
EXTRN	PyDict_GetItem:PROC
EXTRN	PyDict_New:PROC
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyObject_IsTrue:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_parse_object_unicode DD imagerel _parse_object_unicode
	DD	imagerel _parse_object_unicode+112
	DD	imagerel $unwind$_parse_object_unicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_parse_object_unicode DD imagerel _parse_object_unicode+112
	DD	imagerel _parse_object_unicode+466
	DD	imagerel $chain$2$_parse_object_unicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_parse_object_unicode DD imagerel _parse_object_unicode+466
	DD	imagerel _parse_object_unicode+2027
	DD	imagerel $chain$4$_parse_object_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_parse_object_unicode DD 060021H
	DD	0af400H
	DD	0bc400H
	DD	0146400H
	DD	imagerel _parse_object_unicode
	DD	imagerel _parse_object_unicode+112
	DD	imagerel $unwind$_parse_object_unicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_parse_object_unicode DD 061621H
	DD	0af416H
	DD	0bc411H
	DD	0146408H
	DD	imagerel _parse_object_unicode
	DD	imagerel _parse_object_unicode+112
	DD	imagerel $unwind$_parse_object_unicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_parse_object_unicode DD 061501H
	DD	0e011b215H
	DD	0700dd00fH
	DD	0300b500cH
xdata	ENDS
;	COMDAT ??_C@_0DC@COPDFPMD@Expecting?5property?5name?5enclosed@
CONST	SEGMENT
??_C@_0DC@COPDFPMD@Expecting?5property?5name?5enclosed@ DB 'Expecting pro'
	DB	'perty name enclosed in double quotes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@EKLMLIIK@Expecting?5?8?0?8?5delimiter?$AA@
CONST	SEGMENT
??_C@_0BI@EKLMLIIK@Expecting?5?8?0?8?5delimiter?$AA@ DB 'Expecting '','' '
	DB	'delimiter', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PKFBKFJI@_parse_object_unicode?$AA@
CONST	SEGMENT
??_C@_0BG@PKFBKFJI@_parse_object_unicode?$AA@ DB '_parse_object_unicode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FOFOMBIN@Expecting?5?8?3?8?5delimiter?$AA@
CONST	SEGMENT
??_C@_0BI@FOFOMBIN@Expecting?5?8?3?8?5delimiter?$AA@ DB 'Expecting '':'' '
	DB	'delimiter', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GKGDLNNB@Expecting?5object?$AA@
CONST	SEGMENT
??_C@_0BB@GKGDLNNB@Expecting?5object?$AA@ DB 'Expecting object', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_json.c
CONST	ENDS
;	COMDAT _parse_object_unicode
_TEXT	SEGMENT
kind$1$ = 48
strict$1$ = 52
rval$1$ = 56
next_idx$ = 64
s$ = 144
has_pairs_hook$1$ = 152
pystr$ = 152
idx$ = 160
next_idx_ptr$ = 168
_parse_object_unicode PROC				; COMDAT

; 597  : _parse_object_unicode(PyScannerObject *s, PyObject *pystr, Py_ssize_t idx, Py_ssize_t *next_idx_ptr) {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	57		 push	 rdi
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00015	48 8b f9	 mov	 rdi, rcx

; 598  :     /* Read a JSON object from PyUnicode pystr.
; 599  :     idx is the index of the first character after the opening curly brace.
; 600  :     *next_idx_ptr is a return-by-reference index to the first character after
; 601  :         the closing curly brace.
; 602  : 
; 603  :     Returns a new PyObject (usually a dict, but object_hook can change that)
; 604  :     */
; 605  :     void *str;
; 606  :     int kind;
; 607  :     Py_ssize_t end_idx;
; 608  :     PyObject *val = NULL;
; 609  :     PyObject *rval = NULL;
; 610  :     PyObject *key = NULL;
; 611  :     int strict = PyObject_IsTrue(s->strict);

  00018	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0001c	49 8b d8	 mov	 rbx, r8
  0001f	4c 8b f2	 mov	 r14, rdx
  00022	33 ed		 xor	 ebp, ebp
  00024	45 33 ed	 xor	 r13d, r13d
  00027	e8 00 00 00 00	 call	 PyObject_IsTrue

; 612  :     int has_pairs_hook = (s->object_pairs_hook != Py_None);

  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00033	89 44 24 34	 mov	 DWORD PTR strict$1$[rsp], eax
  00037	33 c0		 xor	 eax, eax
  00039	48 39 4f 70	 cmp	 QWORD PTR [rdi+112], rcx
  0003d	0f 95 c0	 setne	 al

; 613  :     Py_ssize_t next_idx;
; 614  : 
; 615  :     if (PyUnicode_READY(pystr) == -1)

  00040	41 f6 46 70 80	 test	 BYTE PTR [r14+112], 128	; 00000080H
  00045	89 84 24 98 00
	00 00		 mov	 DWORD PTR has_pairs_hook$1$[rsp], eax
  0004c	75 22		 jne	 SHORT $LN71@parse_obje
  0004e	49 8b ce	 mov	 rcx, r14
  00051	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00056	83 f8 ff	 cmp	 eax, -1
  00059	75 0e		 jne	 SHORT $LN218@parse_obje

; 616  :         return NULL;

  0005b	33 c0		 xor	 eax, eax

; 736  : }

  0005d	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00061	41 5e		 pop	 r14
  00063	41 5d		 pop	 r13
  00065	5f		 pop	 rdi
  00066	5d		 pop	 rbp
  00067	5b		 pop	 rbx
  00068	c3		 ret	 0
$LN218@parse_obje:

; 612  :     int has_pairs_hook = (s->object_pairs_hook != Py_None);

  00069	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR has_pairs_hook$1$[rsp]
$LN71@parse_obje:
  00070	48 89 b4 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rsi

; 617  : 
; 618  :     str = PyUnicode_DATA(pystr);

  00078	41 8b 76 70	 mov	 esi, DWORD PTR [r14+112]
  0007c	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12
  00081	4c 89 7c 24 50	 mov	 QWORD PTR [rsp+80], r15
  00086	40 f6 c6 20	 test	 sil, 32			; 00000020H
  0008a	74 18		 je	 SHORT $LN78@parse_obje
  0008c	40 f6 c6 40	 test	 sil, 64			; 00000040H
  00090	74 09		 je	 SHORT $LN76@parse_obje
  00092	49 8d be 80 00
	00 00		 lea	 rdi, QWORD PTR [r14+128]
  00099	eb 10		 jmp	 SHORT $LN79@parse_obje
$LN76@parse_obje:
  0009b	49 8d be a0 00
	00 00		 lea	 rdi, QWORD PTR [r14+160]
  000a2	eb 07		 jmp	 SHORT $LN79@parse_obje
$LN78@parse_obje:
  000a4	49 8b be a0 00
	00 00		 mov	 rdi, QWORD PTR [r14+160]
$LN79@parse_obje:

; 619  :     kind = PyUnicode_KIND(pystr);
; 620  :     end_idx = PyUnicode_GET_LENGTH(pystr) - 1;

  000ab	4d 8b 66 60	 mov	 r12, QWORD PTR [r14+96]
  000af	c1 ee 02	 shr	 esi, 2
  000b2	83 e6 07	 and	 esi, 7
  000b5	49 ff cc	 dec	 r12
  000b8	89 74 24 30	 mov	 DWORD PTR kind$1$[rsp], esi

; 621  : 
; 622  :     if (has_pairs_hook)

  000bc	85 c0		 test	 eax, eax
  000be	74 09		 je	 SHORT $LN70@parse_obje

; 623  :         rval = PyList_New(0);

  000c0	33 c9		 xor	 ecx, ecx
  000c2	e8 00 00 00 00	 call	 PyList_New

; 624  :     else

  000c7	eb 05		 jmp	 SHORT $LN222@parse_obje
$LN70@parse_obje:

; 625  :         rval = PyDict_New();

  000c9	e8 00 00 00 00	 call	 PyDict_New
$LN222@parse_obje:
  000ce	4c 8b f8	 mov	 r15, rax
  000d1	48 89 44 24 38	 mov	 QWORD PTR rval$1$[rsp], rax

; 626  :     if (rval == NULL)

  000d6	48 85 c0	 test	 rax, rax

; 627  :         return NULL;

  000d9	0f 84 d3 00 00
	00		 je	 $LN223@parse_obje

; 628  : 
; 629  :     /* skip whitespace after { */
; 630  :     while (idx <= end_idx && IS_WHITESPACE(PyUnicode_READ(kind,str, idx))) idx++;

  000df	48 63 f6	 movsxd	 rsi, esi
  000e2	49 3b dc	 cmp	 rbx, r12
  000e5	0f 8f 91 00 00
	00		 jg	 $LN215@parse_obje
  000eb	0f 1f 44 00 00	 npad	 5
$LL67@parse_obje:
  000f0	48 83 fe 01	 cmp	 rsi, 1
  000f4	75 06		 jne	 SHORT $LN82@parse_obje
  000f6	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  000fa	eb 0f		 jmp	 SHORT $LN81@parse_obje
$LN82@parse_obje:
  000fc	48 83 fe 02	 cmp	 rsi, 2
  00100	75 06		 jne	 SHORT $LN80@parse_obje
  00102	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00106	eb 03		 jmp	 SHORT $LN81@parse_obje
$LN80@parse_obje:
  00108	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN81@parse_obje:
  0010b	83 f8 20	 cmp	 eax, 32			; 00000020H
  0010e	74 60		 je	 SHORT $LN65@parse_obje
  00110	48 83 fe 01	 cmp	 rsi, 1
  00114	75 06		 jne	 SHORT $LN86@parse_obje
  00116	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0011a	eb 0f		 jmp	 SHORT $LN85@parse_obje
$LN86@parse_obje:
  0011c	48 83 fe 02	 cmp	 rsi, 2
  00120	75 06		 jne	 SHORT $LN84@parse_obje
  00122	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00126	eb 03		 jmp	 SHORT $LN85@parse_obje
$LN84@parse_obje:
  00128	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN85@parse_obje:
  0012b	83 f8 09	 cmp	 eax, 9
  0012e	74 40		 je	 SHORT $LN65@parse_obje
  00130	48 83 fe 01	 cmp	 rsi, 1
  00134	75 06		 jne	 SHORT $LN90@parse_obje
  00136	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0013a	eb 0f		 jmp	 SHORT $LN89@parse_obje
$LN90@parse_obje:
  0013c	48 83 fe 02	 cmp	 rsi, 2
  00140	75 06		 jne	 SHORT $LN88@parse_obje
  00142	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00146	eb 03		 jmp	 SHORT $LN89@parse_obje
$LN88@parse_obje:
  00148	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN89@parse_obje:
  0014b	83 f8 0a	 cmp	 eax, 10
  0014e	74 20		 je	 SHORT $LN65@parse_obje
  00150	48 83 fe 01	 cmp	 rsi, 1
  00154	75 06		 jne	 SHORT $LN94@parse_obje
  00156	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0015a	eb 0f		 jmp	 SHORT $LN93@parse_obje
$LN94@parse_obje:
  0015c	48 83 fe 02	 cmp	 rsi, 2
  00160	75 06		 jne	 SHORT $LN92@parse_obje
  00162	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00166	eb 03		 jmp	 SHORT $LN93@parse_obje
$LN92@parse_obje:
  00168	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN93@parse_obje:
  0016b	83 f8 0d	 cmp	 eax, 13
  0016e	75 62		 jne	 SHORT $LN66@parse_obje
$LN65@parse_obje:
  00170	48 ff c3	 inc	 rbx
  00173	49 3b dc	 cmp	 rbx, r12
  00176	0f 8e 74 ff ff
	ff		 jle	 $LL67@parse_obje
$LN215@parse_obje:

; 712  :         raise_errmsg("Expecting object", pystr, end_idx);

  0017c	4d 8b c4	 mov	 r8, r12
  0017f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GKGDLNNB@Expecting?5object?$AA@
$LN225@parse_obje:
  00186	49 8b d6	 mov	 rdx, r14
  00189	e8 00 00 00 00	 call	 raise_errmsg
$bail$21077:

; 731  : bail:
; 732  :     Py_XDECREF(key);

  0018e	4d 85 ed	 test	 r13, r13
  00191	74 08		 je	 SHORT $LN11@parse_obje
  00193	49 8b cd	 mov	 rcx, r13
  00196	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@parse_obje:

; 733  :     Py_XDECREF(val);

  0019b	48 85 ed	 test	 rbp, rbp
  0019e	74 08		 je	 SHORT $LN7@parse_obje
  001a0	48 8b cd	 mov	 rcx, rbp
  001a3	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@parse_obje:

; 734  :     Py_XDECREF(rval);

  001a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rval$1$[rsp]
  001ad	e8 00 00 00 00	 call	 _Py_DecRef
$LN223@parse_obje:

; 735  :     return NULL;

  001b2	33 c0		 xor	 eax, eax
$LN221@parse_obje:
  001b4	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]
  001b9	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+160]
  001c1	4c 8b 7c 24 50	 mov	 r15, QWORD PTR [rsp+80]

; 736  : }

  001c6	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001ca	41 5e		 pop	 r14
  001cc	41 5d		 pop	 r13
  001ce	5f		 pop	 rdi
  001cf	5d		 pop	 rbp
  001d0	5b		 pop	 rbx
  001d1	c3		 ret	 0
$LN66@parse_obje:

; 631  : 
; 632  :     /* only loop if the object is non-empty */
; 633  :     if (idx <= end_idx && PyUnicode_READ(kind, str, idx) != '}') {

  001d2	49 3b dc	 cmp	 rbx, r12
  001d5	7f a5		 jg	 SHORT $LN215@parse_obje
  001d7	8b 4c 24 30	 mov	 ecx, DWORD PTR kind$1$[rsp]
  001db	83 f9 01	 cmp	 ecx, 1
  001de	75 06		 jne	 SHORT $LN98@parse_obje
  001e0	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  001e4	eb 0e		 jmp	 SHORT $LN97@parse_obje
$LN98@parse_obje:
  001e6	83 f9 02	 cmp	 ecx, 2
  001e9	75 06		 jne	 SHORT $LN96@parse_obje
  001eb	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  001ef	eb 03		 jmp	 SHORT $LN97@parse_obje
$LN96@parse_obje:
  001f1	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN97@parse_obje:
  001f4	83 f8 7d	 cmp	 eax, 125		; 0000007dH
  001f7	0f 84 6f 05 00
	00		 je	 $LN62@parse_obje

; 669  :                 goto bail;
; 670  : 
; 671  :             if (has_pairs_hook) {

  001fd	4c 63 bc 24 98
	00 00 00	 movsxd	 r15, DWORD PTR has_pairs_hook$1$[rsp]
$LL63@parse_obje:

; 635  :             PyObject *memokey;
; 636  : 
; 637  :             /* read key */
; 638  :             if (PyUnicode_READ(kind, str, idx) != '"') {

  00205	48 83 fe 01	 cmp	 rsi, 1
  00209	75 06		 jne	 SHORT $LN102@parse_obje
  0020b	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0020f	eb 0f		 jmp	 SHORT $LN101@parse_obje
$LN102@parse_obje:
  00211	48 83 fe 02	 cmp	 rsi, 2
  00215	75 06		 jne	 SHORT $LN100@parse_obje
  00217	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  0021b	eb 03		 jmp	 SHORT $LN101@parse_obje
$LN100@parse_obje:
  0021d	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN101@parse_obje:
  00220	83 f8 22	 cmp	 eax, 34			; 00000022H
  00223	0f 85 2b 05 00
	00		 jne	 $LN194@parse_obje

; 641  :             }
; 642  :             key = scanstring_unicode(pystr, idx + 1, strict, &next_idx);

  00229	44 8b 44 24 34	 mov	 r8d, DWORD PTR strict$1$[rsp]
  0022e	48 8d 53 01	 lea	 rdx, QWORD PTR [rbx+1]
  00232	4c 8d 4c 24 40	 lea	 r9, QWORD PTR next_idx$[rsp]
  00237	49 8b ce	 mov	 rcx, r14
  0023a	e8 00 00 00 00	 call	 scanstring_unicode
  0023f	4c 8b e8	 mov	 r13, rax

; 643  :             if (key == NULL)

  00242	48 85 c0	 test	 rax, rax
  00245	0f 84 50 ff ff
	ff		 je	 $LN11@parse_obje

; 644  :                 goto bail;
; 645  :             memokey = PyDict_GetItem(s->memo, key);

  0024b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00253	48 8b d0	 mov	 rdx, rax
  00256	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  0025d	e8 00 00 00 00	 call	 PyDict_GetItem
  00262	48 8b d8	 mov	 rbx, rax

; 646  :             if (memokey != NULL) {

  00265	48 85 c0	 test	 rax, rax
  00268	74 50		 je	 SHORT $LN59@parse_obje

; 647  :                 Py_INCREF(memokey);

  0026a	e8 00 00 00 00	 call	 _Py_PXCTX
  0026f	85 c0		 test	 eax, eax
  00271	75 32		 jne	 SHORT $LN185@parse_obje
  00273	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0027a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00281	4c 8b cb	 mov	 r9, rbx
  00284	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0028a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00292	e8 00 00 00 00	 call	 _PyParallel_Guard
  00297	85 c0		 test	 eax, eax
  00299	75 06		 jne	 SHORT $LN184@parse_obje
  0029b	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0029f	74 04		 je	 SHORT $LN185@parse_obje
$LN184@parse_obje:
  002a1	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN185@parse_obje:

; 648  :                 Py_DECREF(key);

  002a5	49 8b cd	 mov	 rcx, r13
  002a8	e8 00 00 00 00	 call	 _Py_DecRef

; 649  :                 key = memokey;

  002ad	4c 8b eb	 mov	 r13, rbx

; 650  :             }
; 651  :             else {

  002b0	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR s$[rsp]
  002b8	eb 22		 jmp	 SHORT $LN57@parse_obje
$LN59@parse_obje:

; 652  :                 if (PyDict_SetItem(s->memo, key, key) < 0)

  002ba	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR s$[rsp]
  002c2	4d 8b c5	 mov	 r8, r13
  002c5	49 8b d5	 mov	 rdx, r13
  002c8	48 8b 8b 90 00
	00 00		 mov	 rcx, QWORD PTR [rbx+144]
  002cf	e8 00 00 00 00	 call	 PyDict_SetItem
  002d4	85 c0		 test	 eax, eax
  002d6	0f 88 b2 fe ff
	ff		 js	 $bail$21077
$LN57@parse_obje:

; 653  :                     goto bail;
; 654  :             }
; 655  :             idx = next_idx;

  002dc	4c 8b 44 24 40	 mov	 r8, QWORD PTR next_idx$[rsp]

; 656  : 
; 657  :             /* skip whitespace between key and : delimiter, read :, skip whitespace */
; 658  :             while (idx <= end_idx && IS_WHITESPACE(PyUnicode_READ(kind, str, idx))) idx++;

  002e1	4d 3b c4	 cmp	 r8, r12
  002e4	0f 8f 9e 00 00
	00		 jg	 $LN52@parse_obje
  002ea	66 0f 1f 44 00
	00		 npad	 6
$LL56@parse_obje:
  002f0	48 83 fe 01	 cmp	 rsi, 1
  002f4	75 07		 jne	 SHORT $LN106@parse_obje
  002f6	42 0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+r8]
  002fb	eb 11		 jmp	 SHORT $LN105@parse_obje
$LN106@parse_obje:
  002fd	48 83 fe 02	 cmp	 rsi, 2
  00301	75 07		 jne	 SHORT $LN104@parse_obje
  00303	42 0f b7 04 47	 movzx	 eax, WORD PTR [rdi+r8*2]
  00308	eb 04		 jmp	 SHORT $LN105@parse_obje
$LN104@parse_obje:
  0030a	42 8b 04 87	 mov	 eax, DWORD PTR [rdi+r8*4]
$LN105@parse_obje:
  0030e	83 f8 20	 cmp	 eax, 32			; 00000020H
  00311	74 69		 je	 SHORT $LN54@parse_obje
  00313	48 83 fe 01	 cmp	 rsi, 1
  00317	75 07		 jne	 SHORT $LN110@parse_obje
  00319	42 0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+r8]
  0031e	eb 11		 jmp	 SHORT $LN109@parse_obje
$LN110@parse_obje:
  00320	48 83 fe 02	 cmp	 rsi, 2
  00324	75 07		 jne	 SHORT $LN108@parse_obje
  00326	42 0f b7 04 47	 movzx	 eax, WORD PTR [rdi+r8*2]
  0032b	eb 04		 jmp	 SHORT $LN109@parse_obje
$LN108@parse_obje:
  0032d	42 8b 04 87	 mov	 eax, DWORD PTR [rdi+r8*4]
$LN109@parse_obje:
  00331	83 f8 09	 cmp	 eax, 9
  00334	74 46		 je	 SHORT $LN54@parse_obje
  00336	48 83 fe 01	 cmp	 rsi, 1
  0033a	75 07		 jne	 SHORT $LN114@parse_obje
  0033c	42 0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+r8]
  00341	eb 11		 jmp	 SHORT $LN113@parse_obje
$LN114@parse_obje:
  00343	48 83 fe 02	 cmp	 rsi, 2
  00347	75 07		 jne	 SHORT $LN112@parse_obje
  00349	42 0f b7 04 47	 movzx	 eax, WORD PTR [rdi+r8*2]
  0034e	eb 04		 jmp	 SHORT $LN113@parse_obje
$LN112@parse_obje:
  00350	42 8b 04 87	 mov	 eax, DWORD PTR [rdi+r8*4]
$LN113@parse_obje:
  00354	83 f8 0a	 cmp	 eax, 10
  00357	74 23		 je	 SHORT $LN54@parse_obje
  00359	48 83 fe 01	 cmp	 rsi, 1
  0035d	75 07		 jne	 SHORT $LN118@parse_obje
  0035f	42 0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+r8]
  00364	eb 11		 jmp	 SHORT $LN117@parse_obje
$LN118@parse_obje:
  00366	48 83 fe 02	 cmp	 rsi, 2
  0036a	75 07		 jne	 SHORT $LN116@parse_obje
  0036c	42 0f b7 04 47	 movzx	 eax, WORD PTR [rdi+r8*2]
  00371	eb 04		 jmp	 SHORT $LN117@parse_obje
$LN116@parse_obje:
  00373	42 8b 04 87	 mov	 eax, DWORD PTR [rdi+r8*4]
$LN117@parse_obje:
  00377	83 f8 0d	 cmp	 eax, 13
  0037a	75 18		 jne	 SHORT $LN55@parse_obje
$LN54@parse_obje:
  0037c	49 ff c0	 inc	 r8
  0037f	4d 3b c4	 cmp	 r8, r12
  00382	0f 8e 68 ff ff
	ff		 jle	 $LL56@parse_obje
$LN52@parse_obje:

; 660  :                 raise_errmsg("Expecting ':' delimiter", pystr, idx);

  00388	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@FOFOMBIN@Expecting?5?8?3?8?5delimiter?$AA@

; 661  :                 goto bail;

  0038f	e9 f2 fd ff ff	 jmp	 $LN225@parse_obje
$LN55@parse_obje:

; 659  :             if (idx > end_idx || PyUnicode_READ(kind, str, idx) != ':') {

  00394	4d 3b c4	 cmp	 r8, r12
  00397	7f ef		 jg	 SHORT $LN52@parse_obje
  00399	48 83 fe 01	 cmp	 rsi, 1
  0039d	75 07		 jne	 SHORT $LN122@parse_obje
  0039f	42 0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+r8]
  003a4	eb 11		 jmp	 SHORT $LN121@parse_obje
$LN122@parse_obje:
  003a6	48 83 fe 02	 cmp	 rsi, 2
  003aa	75 07		 jne	 SHORT $LN120@parse_obje
  003ac	42 0f b7 04 47	 movzx	 eax, WORD PTR [rdi+r8*2]
  003b1	eb 04		 jmp	 SHORT $LN121@parse_obje
$LN120@parse_obje:
  003b3	42 8b 04 87	 mov	 eax, DWORD PTR [rdi+r8*4]
$LN121@parse_obje:
  003b7	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  003ba	75 cc		 jne	 SHORT $LN52@parse_obje

; 662  :             }
; 663  :             idx++;

  003bc	49 ff c0	 inc	 r8

; 664  :             while (idx <= end_idx && IS_WHITESPACE(PyUnicode_READ(kind, str, idx))) idx++;

  003bf	4d 3b c4	 cmp	 r8, r12
  003c2	0f 8f 98 00 00
	00		 jg	 $LN216@parse_obje
$LL51@parse_obje:
  003c8	48 83 fe 01	 cmp	 rsi, 1
  003cc	75 07		 jne	 SHORT $LN126@parse_obje
  003ce	42 0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+r8]
  003d3	eb 11		 jmp	 SHORT $LN125@parse_obje
$LN126@parse_obje:
  003d5	48 83 fe 02	 cmp	 rsi, 2
  003d9	75 07		 jne	 SHORT $LN124@parse_obje
  003db	42 0f b7 04 47	 movzx	 eax, WORD PTR [rdi+r8*2]
  003e0	eb 04		 jmp	 SHORT $LN125@parse_obje
$LN124@parse_obje:
  003e2	42 8b 04 87	 mov	 eax, DWORD PTR [rdi+r8*4]
$LN125@parse_obje:
  003e6	83 f8 20	 cmp	 eax, 32			; 00000020H
  003e9	74 69		 je	 SHORT $LN49@parse_obje
  003eb	48 83 fe 01	 cmp	 rsi, 1
  003ef	75 07		 jne	 SHORT $LN130@parse_obje
  003f1	42 0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+r8]
  003f6	eb 11		 jmp	 SHORT $LN129@parse_obje
$LN130@parse_obje:
  003f8	48 83 fe 02	 cmp	 rsi, 2
  003fc	75 07		 jne	 SHORT $LN128@parse_obje
  003fe	42 0f b7 04 47	 movzx	 eax, WORD PTR [rdi+r8*2]
  00403	eb 04		 jmp	 SHORT $LN129@parse_obje
$LN128@parse_obje:
  00405	42 8b 04 87	 mov	 eax, DWORD PTR [rdi+r8*4]
$LN129@parse_obje:
  00409	83 f8 09	 cmp	 eax, 9
  0040c	74 46		 je	 SHORT $LN49@parse_obje
  0040e	48 83 fe 01	 cmp	 rsi, 1
  00412	75 07		 jne	 SHORT $LN134@parse_obje
  00414	42 0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+r8]
  00419	eb 11		 jmp	 SHORT $LN133@parse_obje
$LN134@parse_obje:
  0041b	48 83 fe 02	 cmp	 rsi, 2
  0041f	75 07		 jne	 SHORT $LN132@parse_obje
  00421	42 0f b7 04 47	 movzx	 eax, WORD PTR [rdi+r8*2]
  00426	eb 04		 jmp	 SHORT $LN133@parse_obje
$LN132@parse_obje:
  00428	42 8b 04 87	 mov	 eax, DWORD PTR [rdi+r8*4]
$LN133@parse_obje:
  0042c	83 f8 0a	 cmp	 eax, 10
  0042f	74 23		 je	 SHORT $LN49@parse_obje
  00431	48 83 fe 01	 cmp	 rsi, 1
  00435	75 07		 jne	 SHORT $LN138@parse_obje
  00437	42 0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+r8]
  0043c	eb 11		 jmp	 SHORT $LN137@parse_obje
$LN138@parse_obje:
  0043e	48 83 fe 02	 cmp	 rsi, 2
  00442	75 07		 jne	 SHORT $LN136@parse_obje
  00444	42 0f b7 04 47	 movzx	 eax, WORD PTR [rdi+r8*2]
  00449	eb 04		 jmp	 SHORT $LN137@parse_obje
$LN136@parse_obje:
  0044b	42 8b 04 87	 mov	 eax, DWORD PTR [rdi+r8*4]
$LN137@parse_obje:
  0044f	83 f8 0d	 cmp	 eax, 13
  00452	75 0c		 jne	 SHORT $LN216@parse_obje
$LN49@parse_obje:
  00454	49 ff c0	 inc	 r8
  00457	4d 3b c4	 cmp	 r8, r12
  0045a	0f 8e 68 ff ff
	ff		 jle	 $LL51@parse_obje
$LN216@parse_obje:

; 665  : 
; 666  :             /* read any JSON term */
; 667  :             val = scan_once_unicode(s, pystr, idx, &next_idx);

  00460	4c 8d 4c 24 40	 lea	 r9, QWORD PTR next_idx$[rsp]
  00465	49 8b d6	 mov	 rdx, r14
  00468	48 8b cb	 mov	 rcx, rbx
  0046b	e8 00 00 00 00	 call	 scan_once_unicode
  00470	48 8b e8	 mov	 rbp, rax

; 668  :             if (val == NULL)

  00473	48 85 c0	 test	 rax, rax
  00476	0f 84 12 fd ff
	ff		 je	 $bail$21077

; 672  :                 PyObject *item = PyTuple_Pack(2, key, val);

  0047c	4c 8b c0	 mov	 r8, rax
  0047f	49 8b d5	 mov	 rdx, r13
  00482	4d 85 ff	 test	 r15, r15
  00485	0f 84 a3 00 00
	00		 je	 $LN47@parse_obje
  0048b	b9 02 00 00 00	 mov	 ecx, 2
  00490	e8 00 00 00 00	 call	 PyTuple_Pack
  00495	48 8b d8	 mov	 rbx, rax

; 673  :                 if (item == NULL)

  00498	48 85 c0	 test	 rax, rax
  0049b	0f 84 ed fc ff
	ff		 je	 $bail$21077

; 674  :                     goto bail;
; 675  :                 Py_CLEAR(key);

  004a1	4d 85 ed	 test	 r13, r13
  004a4	74 33		 je	 SHORT $LN44@parse_obje
  004a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  004ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@PKFBKFJI@_parse_object_unicode?$AA@
  004b4	4d 8b cd	 mov	 r9, r13
  004b7	41 b8 a3 02 00
	00		 mov	 r8d, 675		; 000002a3H
  004bd	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  004ca	85 c0		 test	 eax, eax
  004cc	75 0b		 jne	 SHORT $LN44@parse_obje
  004ce	49 8b cd	 mov	 rcx, r13
  004d1	45 33 ed	 xor	 r13d, r13d
  004d4	e8 00 00 00 00	 call	 _Py_DecRef
$LN44@parse_obje:

; 676  :                 Py_CLEAR(val);

  004d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  004e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@PKFBKFJI@_parse_object_unicode?$AA@
  004e7	4c 8b cd	 mov	 r9, rbp
  004ea	41 b8 a4 02 00
	00		 mov	 r8d, 676		; 000002a4H
  004f0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004f8	e8 00 00 00 00	 call	 _PyParallel_Guard
  004fd	85 c0		 test	 eax, eax
  004ff	75 0a		 jne	 SHORT $LN40@parse_obje
  00501	48 8b cd	 mov	 rcx, rbp
  00504	33 ed		 xor	 ebp, ebp
  00506	e8 00 00 00 00	 call	 _Py_DecRef
$LN40@parse_obje:

; 677  :                 if (PyList_Append(rval, item) == -1) {

  0050b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rval$1$[rsp]
  00510	48 8b d3	 mov	 rdx, rbx
  00513	e8 00 00 00 00	 call	 PyList_Append

; 680  :                 }
; 681  :                 Py_DECREF(item);

  00518	48 8b cb	 mov	 rcx, rbx
  0051b	83 f8 ff	 cmp	 eax, -1
  0051e	0f 85 81 00 00
	00		 jne	 $LN224@parse_obje

; 678  :                     Py_DECREF(item);

  00524	e8 00 00 00 00	 call	 _Py_DecRef

; 679  :                     goto bail;

  00529	e9 60 fc ff ff	 jmp	 $bail$21077
$LN47@parse_obje:

; 682  :             }
; 683  :             else {
; 684  :                 if (PyDict_SetItem(rval, key, val) < 0)

  0052e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR rval$1$[rsp]
  00533	e8 00 00 00 00	 call	 PyDict_SetItem
  00538	85 c0		 test	 eax, eax
  0053a	0f 88 4e fc ff
	ff		 js	 $bail$21077

; 685  :                     goto bail;
; 686  :                 Py_CLEAR(key);

  00540	4d 85 ed	 test	 r13, r13
  00543	74 33		 je	 SHORT $LN33@parse_obje
  00545	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  0054c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@PKFBKFJI@_parse_object_unicode?$AA@
  00553	4d 8b cd	 mov	 r9, r13
  00556	41 b8 ae 02 00
	00		 mov	 r8d, 686		; 000002aeH
  0055c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00564	e8 00 00 00 00	 call	 _PyParallel_Guard
  00569	85 c0		 test	 eax, eax
  0056b	75 0b		 jne	 SHORT $LN33@parse_obje
  0056d	49 8b cd	 mov	 rcx, r13
  00570	45 33 ed	 xor	 r13d, r13d
  00573	e8 00 00 00 00	 call	 _Py_DecRef
$LN33@parse_obje:

; 687  :                 Py_CLEAR(val);

  00578	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  0057f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@PKFBKFJI@_parse_object_unicode?$AA@
  00586	4c 8b cd	 mov	 r9, rbp
  00589	41 b8 af 02 00
	00		 mov	 r8d, 687		; 000002afH
  0058f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00597	e8 00 00 00 00	 call	 _PyParallel_Guard
  0059c	85 c0		 test	 eax, eax
  0059e	75 0a		 jne	 SHORT $LN28@parse_obje
  005a0	48 8b cd	 mov	 rcx, rbp
  005a3	33 ed		 xor	 ebp, ebp
$LN224@parse_obje:
  005a5	e8 00 00 00 00	 call	 _Py_DecRef
$LN28@parse_obje:

; 688  :             }
; 689  :             idx = next_idx;

  005aa	48 8b 5c 24 40	 mov	 rbx, QWORD PTR next_idx$[rsp]

; 690  : 
; 691  :             /* skip whitespace before } or , */
; 692  :             while (idx <= end_idx && IS_WHITESPACE(PyUnicode_READ(kind, str, idx))) idx++;

  005af	49 3b dc	 cmp	 rbx, r12
  005b2	0f 8f c4 fb ff
	ff		 jg	 $LN215@parse_obje
$LL26@parse_obje:
  005b8	48 83 fe 01	 cmp	 rsi, 1
  005bc	75 06		 jne	 SHORT $LN142@parse_obje
  005be	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  005c2	eb 0f		 jmp	 SHORT $LN141@parse_obje
$LN142@parse_obje:
  005c4	48 83 fe 02	 cmp	 rsi, 2
  005c8	75 06		 jne	 SHORT $LN140@parse_obje
  005ca	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  005ce	eb 03		 jmp	 SHORT $LN141@parse_obje
$LN140@parse_obje:
  005d0	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN141@parse_obje:
  005d3	83 f8 20	 cmp	 eax, 32			; 00000020H
  005d6	74 60		 je	 SHORT $LN24@parse_obje
  005d8	48 83 fe 01	 cmp	 rsi, 1
  005dc	75 06		 jne	 SHORT $LN146@parse_obje
  005de	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  005e2	eb 0f		 jmp	 SHORT $LN145@parse_obje
$LN146@parse_obje:
  005e4	48 83 fe 02	 cmp	 rsi, 2
  005e8	75 06		 jne	 SHORT $LN144@parse_obje
  005ea	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  005ee	eb 03		 jmp	 SHORT $LN145@parse_obje
$LN144@parse_obje:
  005f0	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN145@parse_obje:
  005f3	83 f8 09	 cmp	 eax, 9
  005f6	74 40		 je	 SHORT $LN24@parse_obje
  005f8	48 83 fe 01	 cmp	 rsi, 1
  005fc	75 06		 jne	 SHORT $LN150@parse_obje
  005fe	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  00602	eb 0f		 jmp	 SHORT $LN149@parse_obje
$LN150@parse_obje:
  00604	48 83 fe 02	 cmp	 rsi, 2
  00608	75 06		 jne	 SHORT $LN148@parse_obje
  0060a	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  0060e	eb 03		 jmp	 SHORT $LN149@parse_obje
$LN148@parse_obje:
  00610	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN149@parse_obje:
  00613	83 f8 0a	 cmp	 eax, 10
  00616	74 20		 je	 SHORT $LN24@parse_obje
  00618	48 83 fe 01	 cmp	 rsi, 1
  0061c	75 06		 jne	 SHORT $LN154@parse_obje
  0061e	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  00622	eb 0f		 jmp	 SHORT $LN153@parse_obje
$LN154@parse_obje:
  00624	48 83 fe 02	 cmp	 rsi, 2
  00628	75 06		 jne	 SHORT $LN152@parse_obje
  0062a	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  0062e	eb 03		 jmp	 SHORT $LN153@parse_obje
$LN152@parse_obje:
  00630	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN153@parse_obje:
  00633	83 f8 0d	 cmp	 eax, 13
  00636	75 11		 jne	 SHORT $LN25@parse_obje
$LN24@parse_obje:
  00638	48 ff c3	 inc	 rbx
  0063b	49 3b dc	 cmp	 rbx, r12
  0063e	0f 8e 74 ff ff
	ff		 jle	 $LL26@parse_obje
  00644	e9 33 fb ff ff	 jmp	 $LN215@parse_obje
$LN25@parse_obje:

; 693  : 
; 694  :             /* bail if the object is closed or we didn't get the , delimiter */
; 695  :             if (idx > end_idx) break;

  00649	49 3b dc	 cmp	 rbx, r12
  0064c	0f 8f 2a fb ff
	ff		 jg	 $LN215@parse_obje

; 696  :             if (PyUnicode_READ(kind, str, idx) == '}') {

  00652	48 83 fe 01	 cmp	 rsi, 1
  00656	75 06		 jne	 SHORT $LN158@parse_obje
  00658	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0065c	eb 0f		 jmp	 SHORT $LN157@parse_obje
$LN158@parse_obje:
  0065e	48 83 fe 02	 cmp	 rsi, 2
  00662	75 06		 jne	 SHORT $LN156@parse_obje
  00664	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00668	eb 03		 jmp	 SHORT $LN157@parse_obje
$LN156@parse_obje:
  0066a	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN157@parse_obje:
  0066d	83 f8 7d	 cmp	 eax, 125		; 0000007dH
  00670	0f 84 ed 00 00
	00		 je	 $LN217@parse_obje

; 697  :                 break;
; 698  :             }
; 699  :             else if (PyUnicode_READ(kind, str, idx) != ',') {

  00676	48 83 fe 01	 cmp	 rsi, 1
  0067a	75 06		 jne	 SHORT $LN162@parse_obje
  0067c	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  00680	eb 0f		 jmp	 SHORT $LN161@parse_obje
$LN162@parse_obje:
  00682	48 83 fe 02	 cmp	 rsi, 2
  00686	75 06		 jne	 SHORT $LN160@parse_obje
  00688	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  0068c	eb 03		 jmp	 SHORT $LN161@parse_obje
$LN160@parse_obje:
  0068e	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN161@parse_obje:
  00691	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  00694	0f 85 ab 00 00
	00		 jne	 $LN204@parse_obje

; 702  :             }
; 703  :             idx++;

  0069a	48 ff c3	 inc	 rbx

; 704  : 
; 705  :             /* skip whitespace after , delimiter */
; 706  :             while (idx <= end_idx && IS_WHITESPACE(PyUnicode_READ(kind, str, idx))) idx++;

  0069d	49 3b dc	 cmp	 rbx, r12
  006a0	0f 8f d6 fa ff
	ff		 jg	 $LN215@parse_obje
$LL19@parse_obje:
  006a6	48 83 fe 01	 cmp	 rsi, 1
  006aa	75 06		 jne	 SHORT $LN166@parse_obje
  006ac	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  006b0	eb 0f		 jmp	 SHORT $LN165@parse_obje
$LN166@parse_obje:
  006b2	48 83 fe 02	 cmp	 rsi, 2
  006b6	75 06		 jne	 SHORT $LN164@parse_obje
  006b8	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  006bc	eb 03		 jmp	 SHORT $LN165@parse_obje
$LN164@parse_obje:
  006be	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN165@parse_obje:
  006c1	83 f8 20	 cmp	 eax, 32			; 00000020H
  006c4	74 60		 je	 SHORT $LN17@parse_obje
  006c6	48 83 fe 01	 cmp	 rsi, 1
  006ca	75 06		 jne	 SHORT $LN170@parse_obje
  006cc	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  006d0	eb 0f		 jmp	 SHORT $LN169@parse_obje
$LN170@parse_obje:
  006d2	48 83 fe 02	 cmp	 rsi, 2
  006d6	75 06		 jne	 SHORT $LN168@parse_obje
  006d8	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  006dc	eb 03		 jmp	 SHORT $LN169@parse_obje
$LN168@parse_obje:
  006de	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN169@parse_obje:
  006e1	83 f8 09	 cmp	 eax, 9
  006e4	74 40		 je	 SHORT $LN17@parse_obje
  006e6	48 83 fe 01	 cmp	 rsi, 1
  006ea	75 06		 jne	 SHORT $LN174@parse_obje
  006ec	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  006f0	eb 0f		 jmp	 SHORT $LN173@parse_obje
$LN174@parse_obje:
  006f2	48 83 fe 02	 cmp	 rsi, 2
  006f6	75 06		 jne	 SHORT $LN172@parse_obje
  006f8	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  006fc	eb 03		 jmp	 SHORT $LN173@parse_obje
$LN172@parse_obje:
  006fe	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN173@parse_obje:
  00701	83 f8 0a	 cmp	 eax, 10
  00704	74 20		 je	 SHORT $LN17@parse_obje
  00706	48 83 fe 01	 cmp	 rsi, 1
  0070a	75 06		 jne	 SHORT $LN178@parse_obje
  0070c	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  00710	eb 0f		 jmp	 SHORT $LN177@parse_obje
$LN178@parse_obje:
  00712	48 83 fe 02	 cmp	 rsi, 2
  00716	75 06		 jne	 SHORT $LN176@parse_obje
  00718	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  0071c	eb 03		 jmp	 SHORT $LN177@parse_obje
$LN176@parse_obje:
  0071e	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN177@parse_obje:
  00721	83 f8 0d	 cmp	 eax, 13
  00724	75 11		 jne	 SHORT $LN18@parse_obje
$LN17@parse_obje:
  00726	48 ff c3	 inc	 rbx
  00729	49 3b dc	 cmp	 rbx, r12
  0072c	0f 8e 74 ff ff
	ff		 jle	 $LL19@parse_obje
  00732	e9 45 fa ff ff	 jmp	 $LN215@parse_obje
$LN18@parse_obje:

; 634  :         while (idx <= end_idx) {

  00737	49 3b dc	 cmp	 rbx, r12
  0073a	0f 8e c5 fa ff
	ff		 jle	 $LL63@parse_obje

; 628  : 
; 629  :     /* skip whitespace after { */
; 630  :     while (idx <= end_idx && IS_WHITESPACE(PyUnicode_READ(kind,str, idx))) idx++;

  00740	e9 37 fa ff ff	 jmp	 $LN215@parse_obje
$LN204@parse_obje:

; 700  :                 raise_errmsg("Expecting ',' delimiter", pystr, idx);

  00745	4c 8b c3	 mov	 r8, rbx
  00748	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EKLMLIIK@Expecting?5?8?0?8?5delimiter?$AA@

; 701  :                 goto bail;

  0074f	e9 32 fa ff ff	 jmp	 $LN225@parse_obje
$LN194@parse_obje:

; 639  :                 raise_errmsg("Expecting property name enclosed in double quotes", pystr, idx);

  00754	4c 8b c3	 mov	 r8, rbx
  00757	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DC@COPDFPMD@Expecting?5property?5name?5enclosed@

; 640  :                 goto bail;

  0075e	e9 23 fa ff ff	 jmp	 $LN225@parse_obje
$LN217@parse_obje:

; 625  :         rval = PyDict_New();

  00763	4c 8b 7c 24 38	 mov	 r15, QWORD PTR rval$1$[rsp]
  00768	8b 4c 24 30	 mov	 ecx, DWORD PTR kind$1$[rsp]
$LN62@parse_obje:

; 707  :         }
; 708  :     }
; 709  : 
; 710  :     /* verify that idx < end_idx, str[idx] should be '}' */
; 711  :     if (idx > end_idx || PyUnicode_READ(kind, str, idx) != '}') {

  0076c	83 f9 01	 cmp	 ecx, 1
  0076f	75 06		 jne	 SHORT $LN182@parse_obje
  00771	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  00775	eb 0e		 jmp	 SHORT $LN181@parse_obje
$LN182@parse_obje:
  00777	83 f9 02	 cmp	 ecx, 2
  0077a	75 06		 jne	 SHORT $LN180@parse_obje
  0077c	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00780	eb 03		 jmp	 SHORT $LN181@parse_obje
$LN180@parse_obje:
  00782	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN181@parse_obje:
  00785	83 f8 7d	 cmp	 eax, 125		; 0000007dH
  00788	0f 85 ee f9 ff
	ff		 jne	 $LN215@parse_obje

; 713  :         goto bail;
; 714  :     }
; 715  : 
; 716  :     *next_idx_ptr = idx + 1;
; 717  : 
; 718  :     if (has_pairs_hook) {

  0078e	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR has_pairs_hook$1$[rsp], 0
  00796	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR next_idx_ptr$[rsp]
  0079e	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
  007a2	48 89 01	 mov	 QWORD PTR [rcx], rax

; 719  :         val = PyObject_CallFunctionObjArgs(s->object_pairs_hook, rval, NULL);

  007a5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007ad	74 06		 je	 SHORT $LN14@parse_obje
  007af	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]

; 720  :         Py_DECREF(rval);
; 721  :         return val;

  007b3	eb 10		 jmp	 SHORT $LN227@parse_obje
$LN14@parse_obje:

; 722  :     }
; 723  : 
; 724  :     /* if object_hook is not None: rval = object_hook(rval) */
; 725  :     if (s->object_hook != Py_None) {

  007b5	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  007b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  007c0	48 3b c8	 cmp	 rcx, rax
  007c3	74 1e		 je	 SHORT $LN13@parse_obje
$LN227@parse_obje:

; 726  :         val = PyObject_CallFunctionObjArgs(s->object_hook, rval, NULL);

  007c5	49 8b d7	 mov	 rdx, r15
  007c8	45 33 c0	 xor	 r8d, r8d
  007cb	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs

; 727  :         Py_DECREF(rval);

  007d0	49 8b cf	 mov	 rcx, r15
  007d3	48 8b d8	 mov	 rbx, rax
  007d6	e8 00 00 00 00	 call	 _Py_DecRef

; 728  :         return val;

  007db	48 8b c3	 mov	 rax, rbx
  007de	e9 d1 f9 ff ff	 jmp	 $LN221@parse_obje
$LN13@parse_obje:

; 729  :     }
; 730  :     return rval;

  007e3	49 8b c7	 mov	 rax, r15
  007e6	e9 c9 f9 ff ff	 jmp	 $LN221@parse_obje
_parse_object_unicode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@JDHLIHOH@_parse_array_unicode?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_parse_array_unicode DD imagerel _parse_array_unicode
	DD	imagerel _parse_array_unicode+79
	DD	imagerel $unwind$_parse_array_unicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_parse_array_unicode DD imagerel _parse_array_unicode+79
	DD	imagerel _parse_array_unicode+392
	DD	imagerel $chain$3$_parse_array_unicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$_parse_array_unicode DD imagerel _parse_array_unicode+392
	DD	imagerel _parse_array_unicode+1049
	DD	imagerel $chain$5$_parse_array_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$_parse_array_unicode DD 080021H
	DD	08e400H
	DD	097400H
	DD	0a6400H
	DD	0115400H
	DD	imagerel _parse_array_unicode
	DD	imagerel _parse_array_unicode+79
	DD	imagerel $unwind$_parse_array_unicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_parse_array_unicode DD 081721H
	DD	08e417H
	DD	097412H
	DD	0a640dH
	DD	0115408H
	DD	imagerel _parse_array_unicode
	DD	imagerel _parse_array_unicode+79
	DD	imagerel $unwind$_parse_array_unicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_parse_array_unicode DD 051501H
	DD	0f011a215H
	DD	0c00dd00fH
	DD	0300bH
xdata	ENDS
;	COMDAT ??_C@_0BF@JDHLIHOH@_parse_array_unicode?$AA@
CONST	SEGMENT
??_C@_0BF@JDHLIHOH@_parse_array_unicode?$AA@ DB '_parse_array_unicode', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _parse_array_unicode
_TEXT	SEGMENT
next_idx$ = 48
s$ = 128
pystr$ = 136
idx$ = 144
next_idx_ptr$ = 152
_parse_array_unicode PROC				; COMDAT

; 739  : _parse_array_unicode(PyScannerObject *s, PyObject *pystr, Py_ssize_t idx, Py_ssize_t *next_idx_ptr) {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 57		 push	 r15
  00011	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 740  :     /* Read a JSON array from PyString pystr.
; 741  :     idx is the index of the first character after the opening brace.
; 742  :     *next_idx_ptr is a return-by-reference index to the first character after
; 743  :         the closing brace.
; 744  : 
; 745  :     Returns a new PyList
; 746  :     */
; 747  :     void *str;
; 748  :     int kind;
; 749  :     Py_ssize_t end_idx;
; 750  :     PyObject *val = NULL;
; 751  :     PyObject *rval = PyList_New(0);

  00015	33 c9		 xor	 ecx, ecx
  00017	49 8b d8	 mov	 rbx, r8
  0001a	4c 8b ea	 mov	 r13, rdx
  0001d	45 33 e4	 xor	 r12d, r12d
  00020	e8 00 00 00 00	 call	 PyList_New
  00025	4c 8b f8	 mov	 r15, rax

; 752  :     Py_ssize_t next_idx;
; 753  :     if (rval == NULL)

  00028	48 85 c0	 test	 rax, rax
  0002b	75 0e		 jne	 SHORT $LN30@parse_arra
$LN125@parse_arra:

; 754  :         return NULL;

  0002d	33 c0		 xor	 eax, eax

; 811  : }

  0002f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00033	41 5f		 pop	 r15
  00035	41 5d		 pop	 r13
  00037	41 5c		 pop	 r12
  00039	5b		 pop	 rbx
  0003a	c3		 ret	 0
$LN30@parse_arra:

; 755  : 
; 756  :     if (PyUnicode_READY(pystr) == -1)

  0003b	41 f6 45 70 80	 test	 BYTE PTR [r13+112], 128	; 00000080H
  00040	75 0d		 jne	 SHORT $LN29@parse_arra
  00042	49 8b cd	 mov	 rcx, r13
  00045	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0004a	83 f8 ff	 cmp	 eax, -1

; 757  :         return NULL;

  0004d	74 de		 je	 SHORT $LN125@parse_arra
$LN29@parse_arra:
  0004f	48 89 ac 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbp
  00057	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0005c	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00061	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14

; 758  : 
; 759  :     str = PyUnicode_DATA(pystr);

  00066	45 8b 75 70	 mov	 r14d, DWORD PTR [r13+112]
  0006a	41 f6 c6 20	 test	 r14b, 32		; 00000020H
  0006e	74 18		 je	 SHORT $LN37@parse_arra
  00070	41 f6 c6 40	 test	 r14b, 64		; 00000040H
  00074	74 09		 je	 SHORT $LN35@parse_arra
  00076	49 8d bd 80 00
	00 00		 lea	 rdi, QWORD PTR [r13+128]
  0007d	eb 10		 jmp	 SHORT $LN38@parse_arra
$LN35@parse_arra:
  0007f	49 8d bd a0 00
	00 00		 lea	 rdi, QWORD PTR [r13+160]
  00086	eb 07		 jmp	 SHORT $LN38@parse_arra
$LN37@parse_arra:
  00088	49 8b bd a0 00
	00 00		 mov	 rdi, QWORD PTR [r13+160]
$LN38@parse_arra:

; 760  :     kind = PyUnicode_KIND(pystr);
; 761  :     end_idx = PyUnicode_GET_LENGTH(pystr) - 1;

  0008f	49 8b 6d 60	 mov	 rbp, QWORD PTR [r13+96]
  00093	41 c1 ee 02	 shr	 r14d, 2
  00097	41 83 e6 07	 and	 r14d, 7
  0009b	48 ff cd	 dec	 rbp

; 762  : 
; 763  :     /* skip whitespace after [ */
; 764  :     while (idx <= end_idx && IS_WHITESPACE(PyUnicode_READ(kind, str, idx))) idx++;

  0009e	49 63 f6	 movsxd	 rsi, r14d
  000a1	48 3b dd	 cmp	 rbx, rbp
  000a4	0f 8f 92 00 00
	00		 jg	 $LN119@parse_arra
  000aa	66 0f 1f 44 00
	00		 npad	 6
$LL28@parse_arra:
  000b0	48 83 fe 01	 cmp	 rsi, 1
  000b4	75 06		 jne	 SHORT $LN41@parse_arra
  000b6	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  000ba	eb 0f		 jmp	 SHORT $LN40@parse_arra
$LN41@parse_arra:
  000bc	48 83 fe 02	 cmp	 rsi, 2
  000c0	75 06		 jne	 SHORT $LN39@parse_arra
  000c2	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  000c6	eb 03		 jmp	 SHORT $LN40@parse_arra
$LN39@parse_arra:
  000c8	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN40@parse_arra:
  000cb	83 f8 20	 cmp	 eax, 32			; 00000020H
  000ce	74 60		 je	 SHORT $LN26@parse_arra
  000d0	48 83 fe 01	 cmp	 rsi, 1
  000d4	75 06		 jne	 SHORT $LN45@parse_arra
  000d6	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  000da	eb 0f		 jmp	 SHORT $LN44@parse_arra
$LN45@parse_arra:
  000dc	48 83 fe 02	 cmp	 rsi, 2
  000e0	75 06		 jne	 SHORT $LN43@parse_arra
  000e2	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  000e6	eb 03		 jmp	 SHORT $LN44@parse_arra
$LN43@parse_arra:
  000e8	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN44@parse_arra:
  000eb	83 f8 09	 cmp	 eax, 9
  000ee	74 40		 je	 SHORT $LN26@parse_arra
  000f0	48 83 fe 01	 cmp	 rsi, 1
  000f4	75 06		 jne	 SHORT $LN49@parse_arra
  000f6	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  000fa	eb 0f		 jmp	 SHORT $LN48@parse_arra
$LN49@parse_arra:
  000fc	48 83 fe 02	 cmp	 rsi, 2
  00100	75 06		 jne	 SHORT $LN47@parse_arra
  00102	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00106	eb 03		 jmp	 SHORT $LN48@parse_arra
$LN47@parse_arra:
  00108	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN48@parse_arra:
  0010b	83 f8 0a	 cmp	 eax, 10
  0010e	74 20		 je	 SHORT $LN26@parse_arra
  00110	48 83 fe 01	 cmp	 rsi, 1
  00114	75 06		 jne	 SHORT $LN53@parse_arra
  00116	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0011a	eb 0f		 jmp	 SHORT $LN52@parse_arra
$LN53@parse_arra:
  0011c	48 83 fe 02	 cmp	 rsi, 2
  00120	75 06		 jne	 SHORT $LN51@parse_arra
  00122	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00126	eb 03		 jmp	 SHORT $LN52@parse_arra
$LN51@parse_arra:
  00128	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN52@parse_arra:
  0012b	83 f8 0d	 cmp	 eax, 13
  0012e	75 58		 jne	 SHORT $LN27@parse_arra
$LN26@parse_arra:
  00130	48 ff c3	 inc	 rbx
  00133	48 3b dd	 cmp	 rbx, rbp
  00136	0f 8e 74 ff ff
	ff		 jle	 $LL28@parse_arra
$LN119@parse_arra:

; 802  :         raise_errmsg("Expecting object", pystr, end_idx);

  0013c	4c 8b c5	 mov	 r8, rbp
  0013f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GKGDLNNB@Expecting?5object?$AA@
$LN124@parse_arra:
  00146	49 8b d5	 mov	 rdx, r13
  00149	e8 00 00 00 00	 call	 raise_errmsg
$bail$21331:

; 807  : bail:
; 808  :     Py_XDECREF(val);

  0014e	4d 85 e4	 test	 r12, r12
  00151	74 08		 je	 SHORT $LN3@parse_arra
  00153	49 8b cc	 mov	 rcx, r12
  00156	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@parse_arra:

; 809  :     Py_DECREF(rval);

  0015b	49 8b cf	 mov	 rcx, r15
  0015e	e8 00 00 00 00	 call	 _Py_DecRef

; 810  :     return NULL;

  00163	33 c0		 xor	 eax, eax
$LN123@parse_arra:
  00165	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0016a	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0016f	48 8b ac 24 88
	00 00 00	 mov	 rbp, QWORD PTR [rsp+136]
  00177	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]

; 811  : }

  0017c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00180	41 5f		 pop	 r15
  00182	41 5d		 pop	 r13
  00184	41 5c		 pop	 r12
  00186	5b		 pop	 rbx
  00187	c3		 ret	 0
$LN27@parse_arra:

; 765  : 
; 766  :     /* only loop if the array is non-empty */
; 767  :     if (idx <= end_idx && PyUnicode_READ(kind, str, idx) != ']') {

  00188	48 3b dd	 cmp	 rbx, rbp
  0018b	7f af		 jg	 SHORT $LN119@parse_arra
  0018d	41 83 fe 01	 cmp	 r14d, 1
  00191	75 06		 jne	 SHORT $LN57@parse_arra
  00193	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  00197	eb 0f		 jmp	 SHORT $LN56@parse_arra
$LN57@parse_arra:
  00199	41 83 fe 02	 cmp	 r14d, 2
  0019d	75 06		 jne	 SHORT $LN55@parse_arra
  0019f	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  001a3	eb 03		 jmp	 SHORT $LN56@parse_arra
$LN55@parse_arra:
  001a5	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN56@parse_arra:
  001a8	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  001ab	0f 84 2d 02 00
	00		 je	 $LN23@parse_arra
  001b1	66 66 66 66 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL24@parse_arra:

; 769  : 
; 770  :             /* read any JSON term  */
; 771  :             val = scan_once_unicode(s, pystr, idx, &next_idx);

  001c0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001c8	4c 8d 4c 24 30	 lea	 r9, QWORD PTR next_idx$[rsp]
  001cd	4c 8b c3	 mov	 r8, rbx
  001d0	49 8b d5	 mov	 rdx, r13
  001d3	e8 00 00 00 00	 call	 scan_once_unicode
  001d8	4c 8b e0	 mov	 r12, rax

; 772  :             if (val == NULL)

  001db	48 85 c0	 test	 rax, rax
  001de	0f 84 77 ff ff
	ff		 je	 $LN3@parse_arra

; 773  :                 goto bail;
; 774  : 
; 775  :             if (PyList_Append(rval, val) == -1)

  001e4	48 8b d0	 mov	 rdx, rax
  001e7	49 8b cf	 mov	 rcx, r15
  001ea	e8 00 00 00 00	 call	 PyList_Append
  001ef	83 f8 ff	 cmp	 eax, -1
  001f2	0f 84 56 ff ff
	ff		 je	 $bail$21331

; 776  :                 goto bail;
; 777  : 
; 778  :             Py_CLEAR(val);

  001f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  001ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@JDHLIHOH@_parse_array_unicode?$AA@
  00206	4d 8b cc	 mov	 r9, r12
  00209	41 b8 0a 03 00
	00		 mov	 r8d, 778		; 0000030aH
  0020f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00217	e8 00 00 00 00	 call	 _PyParallel_Guard
  0021c	85 c0		 test	 eax, eax
  0021e	75 0b		 jne	 SHORT $LN19@parse_arra
  00220	49 8b cc	 mov	 rcx, r12
  00223	45 33 e4	 xor	 r12d, r12d
  00226	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@parse_arra:

; 779  :             idx = next_idx;

  0022b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR next_idx$[rsp]

; 780  : 
; 781  :             /* skip whitespace between term and , */
; 782  :             while (idx <= end_idx && IS_WHITESPACE(PyUnicode_READ(kind, str, idx))) idx++;

  00230	48 3b dd	 cmp	 rbx, rbp
  00233	0f 8f 03 ff ff
	ff		 jg	 $LN119@parse_arra
  00239	0f 1f 80 00 00
	00 00		 npad	 7
$LL16@parse_arra:
  00240	48 83 fe 01	 cmp	 rsi, 1
  00244	75 06		 jne	 SHORT $LN61@parse_arra
  00246	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0024a	eb 0f		 jmp	 SHORT $LN60@parse_arra
$LN61@parse_arra:
  0024c	48 83 fe 02	 cmp	 rsi, 2
  00250	75 06		 jne	 SHORT $LN59@parse_arra
  00252	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00256	eb 03		 jmp	 SHORT $LN60@parse_arra
$LN59@parse_arra:
  00258	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN60@parse_arra:
  0025b	83 f8 20	 cmp	 eax, 32			; 00000020H
  0025e	74 60		 je	 SHORT $LN14@parse_arra
  00260	48 83 fe 01	 cmp	 rsi, 1
  00264	75 06		 jne	 SHORT $LN65@parse_arra
  00266	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0026a	eb 0f		 jmp	 SHORT $LN64@parse_arra
$LN65@parse_arra:
  0026c	48 83 fe 02	 cmp	 rsi, 2
  00270	75 06		 jne	 SHORT $LN63@parse_arra
  00272	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00276	eb 03		 jmp	 SHORT $LN64@parse_arra
$LN63@parse_arra:
  00278	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN64@parse_arra:
  0027b	83 f8 09	 cmp	 eax, 9
  0027e	74 40		 je	 SHORT $LN14@parse_arra
  00280	48 83 fe 01	 cmp	 rsi, 1
  00284	75 06		 jne	 SHORT $LN69@parse_arra
  00286	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0028a	eb 0f		 jmp	 SHORT $LN68@parse_arra
$LN69@parse_arra:
  0028c	48 83 fe 02	 cmp	 rsi, 2
  00290	75 06		 jne	 SHORT $LN67@parse_arra
  00292	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00296	eb 03		 jmp	 SHORT $LN68@parse_arra
$LN67@parse_arra:
  00298	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN68@parse_arra:
  0029b	83 f8 0a	 cmp	 eax, 10
  0029e	74 20		 je	 SHORT $LN14@parse_arra
  002a0	48 83 fe 01	 cmp	 rsi, 1
  002a4	75 06		 jne	 SHORT $LN73@parse_arra
  002a6	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  002aa	eb 0f		 jmp	 SHORT $LN72@parse_arra
$LN73@parse_arra:
  002ac	48 83 fe 02	 cmp	 rsi, 2
  002b0	75 06		 jne	 SHORT $LN71@parse_arra
  002b2	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  002b6	eb 03		 jmp	 SHORT $LN72@parse_arra
$LN71@parse_arra:
  002b8	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN72@parse_arra:
  002bb	83 f8 0d	 cmp	 eax, 13
  002be	75 11		 jne	 SHORT $LN15@parse_arra
$LN14@parse_arra:
  002c0	48 ff c3	 inc	 rbx
  002c3	48 3b dd	 cmp	 rbx, rbp
  002c6	0f 8e 74 ff ff
	ff		 jle	 $LL16@parse_arra
  002cc	e9 6b fe ff ff	 jmp	 $LN119@parse_arra
$LN15@parse_arra:

; 783  : 
; 784  :             /* bail if the array is closed or we didn't get the , delimiter */
; 785  :             if (idx > end_idx) break;

  002d1	48 3b dd	 cmp	 rbx, rbp
  002d4	0f 8f 62 fe ff
	ff		 jg	 $LN119@parse_arra

; 786  :             if (PyUnicode_READ(kind, str, idx) == ']') {

  002da	48 83 fe 01	 cmp	 rsi, 1
  002de	75 06		 jne	 SHORT $LN77@parse_arra
  002e0	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  002e4	eb 0f		 jmp	 SHORT $LN76@parse_arra
$LN77@parse_arra:
  002e6	48 83 fe 02	 cmp	 rsi, 2
  002ea	75 06		 jne	 SHORT $LN75@parse_arra
  002ec	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  002f0	eb 03		 jmp	 SHORT $LN76@parse_arra
$LN75@parse_arra:
  002f2	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN76@parse_arra:
  002f5	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  002f8	0f 84 e0 00 00
	00		 je	 $LN23@parse_arra

; 787  :                 break;
; 788  :             }
; 789  :             else if (PyUnicode_READ(kind, str, idx) != ',') {

  002fe	48 83 fe 01	 cmp	 rsi, 1
  00302	75 06		 jne	 SHORT $LN81@parse_arra
  00304	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  00308	eb 0f		 jmp	 SHORT $LN80@parse_arra
$LN81@parse_arra:
  0030a	48 83 fe 02	 cmp	 rsi, 2
  0030e	75 06		 jne	 SHORT $LN79@parse_arra
  00310	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00314	eb 03		 jmp	 SHORT $LN80@parse_arra
$LN79@parse_arra:
  00316	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN80@parse_arra:
  00319	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  0031c	0f 85 ad 00 00
	00		 jne	 $LN111@parse_arra

; 792  :             }
; 793  :             idx++;

  00322	48 ff c3	 inc	 rbx

; 794  : 
; 795  :             /* skip whitespace after , */
; 796  :             while (idx <= end_idx && IS_WHITESPACE(PyUnicode_READ(kind, str, idx))) idx++;

  00325	48 3b dd	 cmp	 rbx, rbp
  00328	0f 8f 0e fe ff
	ff		 jg	 $LN119@parse_arra
  0032e	66 90		 npad	 2
$LL9@parse_arra:
  00330	48 83 fe 01	 cmp	 rsi, 1
  00334	75 06		 jne	 SHORT $LN85@parse_arra
  00336	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0033a	eb 0f		 jmp	 SHORT $LN84@parse_arra
$LN85@parse_arra:
  0033c	48 83 fe 02	 cmp	 rsi, 2
  00340	75 06		 jne	 SHORT $LN83@parse_arra
  00342	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00346	eb 03		 jmp	 SHORT $LN84@parse_arra
$LN83@parse_arra:
  00348	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN84@parse_arra:
  0034b	83 f8 20	 cmp	 eax, 32			; 00000020H
  0034e	74 60		 je	 SHORT $LN7@parse_arra
  00350	48 83 fe 01	 cmp	 rsi, 1
  00354	75 06		 jne	 SHORT $LN89@parse_arra
  00356	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0035a	eb 0f		 jmp	 SHORT $LN88@parse_arra
$LN89@parse_arra:
  0035c	48 83 fe 02	 cmp	 rsi, 2
  00360	75 06		 jne	 SHORT $LN87@parse_arra
  00362	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00366	eb 03		 jmp	 SHORT $LN88@parse_arra
$LN87@parse_arra:
  00368	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN88@parse_arra:
  0036b	83 f8 09	 cmp	 eax, 9
  0036e	74 40		 je	 SHORT $LN7@parse_arra
  00370	48 83 fe 01	 cmp	 rsi, 1
  00374	75 06		 jne	 SHORT $LN93@parse_arra
  00376	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0037a	eb 0f		 jmp	 SHORT $LN92@parse_arra
$LN93@parse_arra:
  0037c	48 83 fe 02	 cmp	 rsi, 2
  00380	75 06		 jne	 SHORT $LN91@parse_arra
  00382	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00386	eb 03		 jmp	 SHORT $LN92@parse_arra
$LN91@parse_arra:
  00388	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN92@parse_arra:
  0038b	83 f8 0a	 cmp	 eax, 10
  0038e	74 20		 je	 SHORT $LN7@parse_arra
  00390	48 83 fe 01	 cmp	 rsi, 1
  00394	75 06		 jne	 SHORT $LN97@parse_arra
  00396	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0039a	eb 0f		 jmp	 SHORT $LN96@parse_arra
$LN97@parse_arra:
  0039c	48 83 fe 02	 cmp	 rsi, 2
  003a0	75 06		 jne	 SHORT $LN95@parse_arra
  003a2	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  003a6	eb 03		 jmp	 SHORT $LN96@parse_arra
$LN95@parse_arra:
  003a8	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN96@parse_arra:
  003ab	83 f8 0d	 cmp	 eax, 13
  003ae	75 11		 jne	 SHORT $LN8@parse_arra
$LN7@parse_arra:
  003b0	48 ff c3	 inc	 rbx
  003b3	48 3b dd	 cmp	 rbx, rbp
  003b6	0f 8e 74 ff ff
	ff		 jle	 $LL9@parse_arra
  003bc	e9 7b fd ff ff	 jmp	 $LN119@parse_arra
$LN8@parse_arra:

; 768  :         while (idx <= end_idx) {

  003c1	48 3b dd	 cmp	 rbx, rbp
  003c4	0f 8e f6 fd ff
	ff		 jle	 $LL24@parse_arra

; 762  : 
; 763  :     /* skip whitespace after [ */
; 764  :     while (idx <= end_idx && IS_WHITESPACE(PyUnicode_READ(kind, str, idx))) idx++;

  003ca	e9 6d fd ff ff	 jmp	 $LN119@parse_arra
$LN111@parse_arra:

; 790  :                 raise_errmsg("Expecting ',' delimiter", pystr, idx);

  003cf	4c 8b c3	 mov	 r8, rbx
  003d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@EKLMLIIK@Expecting?5?8?0?8?5delimiter?$AA@

; 791  :                 goto bail;

  003d9	e9 68 fd ff ff	 jmp	 $LN124@parse_arra
$LN23@parse_arra:

; 797  :         }
; 798  :     }
; 799  : 
; 800  :     /* verify that idx < end_idx, PyUnicode_READ(kind, str, idx) should be ']' */
; 801  :     if (idx > end_idx || PyUnicode_READ(kind, str, idx) != ']') {

  003de	41 83 fe 01	 cmp	 r14d, 1
  003e2	75 06		 jne	 SHORT $LN101@parse_arra
  003e4	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  003e8	eb 0f		 jmp	 SHORT $LN100@parse_arra
$LN101@parse_arra:
  003ea	41 83 fe 02	 cmp	 r14d, 2
  003ee	75 06		 jne	 SHORT $LN99@parse_arra
  003f0	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  003f4	eb 03		 jmp	 SHORT $LN100@parse_arra
$LN99@parse_arra:
  003f6	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN100@parse_arra:
  003f9	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  003fc	0f 85 3a fd ff
	ff		 jne	 $LN119@parse_arra

; 803  :         goto bail;
; 804  :     }
; 805  :     *next_idx_ptr = idx + 1;

  00402	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR next_idx_ptr$[rsp]
  0040a	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
  0040e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 806  :     return rval;

  00411	49 8b c7	 mov	 rax, r15
  00414	e9 4c fd ff ff	 jmp	 $LN123@parse_arra
_parse_array_unicode ENDP
_TEXT	ENDS
EXTRN	PyUnicode_InternFromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_parse_constant DD imagerel _parse_constant
	DD	imagerel _parse_constant+106
	DD	imagerel $unwind$_parse_constant
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_parse_constant DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _parse_constant
_TEXT	SEGMENT
s$ = 48
constant$ = 56
idx$ = 64
next_idx_ptr$ = 72
_parse_constant PROC					; COMDAT

; 814  : _parse_constant(PyScannerObject *s, char *constant, Py_ssize_t idx, Py_ssize_t *next_idx_ptr) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b d9	 mov	 rbx, rcx

; 815  :     /* Read a JSON constant from PyString pystr.
; 816  :     constant is the constant string that was found
; 817  :         ("NaN", "Infinity", "-Infinity").
; 818  :     idx is the index of the first character of the constant
; 819  :     *next_idx_ptr is a return-by-reference index to the first character after
; 820  :         the constant.
; 821  : 
; 822  :     Returns the result of parse_constant
; 823  :     */
; 824  :     PyObject *cstr;
; 825  :     PyObject *rval;
; 826  :     /* constant is "NaN", "Infinity", or "-Infinity" */
; 827  :     cstr = PyUnicode_InternFromString(constant);

  00017	48 8b ca	 mov	 rcx, rdx
  0001a	49 8b e9	 mov	 rbp, r9
  0001d	49 8b f0	 mov	 rsi, r8
  00020	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00025	48 8b f8	 mov	 rdi, rax

; 828  :     if (cstr == NULL)

  00028	48 85 c0	 test	 rax, rax
  0002b	74 28		 je	 SHORT $LN2@parse_cons
$LN1@parse_cons:

; 829  :         return NULL;
; 830  : 
; 831  :     /* rval = parse_constant(constant) */
; 832  :     rval = PyObject_CallFunctionObjArgs(s->parse_constant, cstr, NULL);

  0002d	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
  00034	45 33 c0	 xor	 r8d, r8d
  00037	48 8b d0	 mov	 rdx, rax
  0003a	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs

; 833  :     idx += PyUnicode_GET_LENGTH(cstr);

  0003f	48 03 77 60	 add	 rsi, QWORD PTR [rdi+96]

; 834  :     Py_DECREF(cstr);

  00043	48 8b cf	 mov	 rcx, rdi
  00046	48 8b d8	 mov	 rbx, rax
  00049	e8 00 00 00 00	 call	 _Py_DecRef

; 835  :     *next_idx_ptr = idx;

  0004e	48 89 75 00	 mov	 QWORD PTR [rbp], rsi

; 836  :     return rval;

  00052	48 8b c3	 mov	 rax, rbx
$LN2@parse_cons:

; 837  : }

  00055	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005a	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0005f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00064	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00068	5f		 pop	 rdi
  00069	c3		 ret	 0
_parse_constant ENDP
_TEXT	ENDS
EXTRN	PyLong_FromString:PROC
EXTRN	PyFloat_FromString:PROC
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	PyLong_Type:BYTE
EXTRN	PyFloat_Type:BYTE
EXTRN	PyErr_SetNone:PROC
EXTRN	PyExc_StopIteration:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_match_number_unicode DD imagerel _match_number_unicode
	DD	imagerel _match_number_unicode+203
	DD	imagerel $unwind$_match_number_unicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_match_number_unicode DD imagerel _match_number_unicode+203
	DD	imagerel _match_number_unicode+1198
	DD	imagerel $chain$1$_match_number_unicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_match_number_unicode DD imagerel _match_number_unicode+1198
	DD	imagerel _match_number_unicode+1221
	DD	imagerel $chain$2$_match_number_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_match_number_unicode DD 021H
	DD	imagerel _match_number_unicode
	DD	imagerel _match_number_unicode+203
	DD	imagerel $unwind$_match_number_unicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_match_number_unicode DD 020521H
	DD	0bc405H
	DD	imagerel _match_number_unicode
	DD	imagerel _match_number_unicode+203
	DD	imagerel $unwind$_match_number_unicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_match_number_unicode DD 0a5801H
	DD	0a7458H
	DD	0c3416H
	DD	0f0123216H
	DD	0d00ee010H
	DD	0500b600cH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _match_number_unicode
_TEXT	SEGMENT
s$ = 80
pystr$ = 88
start$ = 96
next_idx_ptr$ = 104
_match_number_unicode PROC				; COMDAT

; 840  : _match_number_unicode(PyScannerObject *s, PyObject *pystr, Py_ssize_t start, Py_ssize_t *next_idx_ptr) {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	41 55		 push	 r13
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 841  :     /* Read a JSON number from PyUnicode pystr.
; 842  :     idx is the index of the first character of the number
; 843  :     *next_idx_ptr is a return-by-reference index to the first character after
; 844  :         the number.
; 845  : 
; 846  :     Returns a new PyObject representation of that number:
; 847  :         PyInt, PyLong, or PyFloat.
; 848  :         May return other types if parse_int or parse_float are set
; 849  :     */
; 850  :     void *str;
; 851  :     int kind;
; 852  :     Py_ssize_t end_idx;
; 853  :     Py_ssize_t idx = start;
; 854  :     int is_float = 0;

  00016	45 33 ed	 xor	 r13d, r13d

; 855  :     PyObject *rval;
; 856  :     PyObject *numstr = NULL;
; 857  :     PyObject *custom_func;
; 858  : 
; 859  :     if (PyUnicode_READY(pystr) == -1)

  00019	f6 42 70 80	 test	 BYTE PTR [rdx+112], 128	; 00000080H
  0001d	4d 8b f0	 mov	 r14, r8
  00020	48 8b f2	 mov	 rsi, rdx
  00023	48 8b e9	 mov	 rbp, rcx
  00026	49 8b d8	 mov	 rbx, r8
  00029	45 8b fd	 mov	 r15d, r13d
  0002c	75 21		 jne	 SHORT $LN33@match_numb
  0002e	48 8b ca	 mov	 rcx, rdx
  00031	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00036	83 f8 ff	 cmp	 eax, -1
  00039	75 14		 jne	 SHORT $LN33@match_numb

; 860  :         return NULL;

  0003b	33 c0		 xor	 eax, eax

; 954  : }

  0003d	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	41 5f		 pop	 r15
  00048	41 5e		 pop	 r14
  0004a	41 5d		 pop	 r13
  0004c	5e		 pop	 rsi
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
$LN33@match_numb:

; 861  : 
; 862  :     str = PyUnicode_DATA(pystr);

  0004f	44 8b 4e 70	 mov	 r9d, DWORD PTR [rsi+112]
  00053	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00058	41 f6 c1 20	 test	 r9b, 32			; 00000020H
  0005c	74 18		 je	 SHORT $LN40@match_numb
  0005e	41 f6 c1 40	 test	 r9b, 64			; 00000040H
  00062	74 09		 je	 SHORT $LN38@match_numb
  00064	48 8d be 80 00
	00 00		 lea	 rdi, QWORD PTR [rsi+128]
  0006b	eb 10		 jmp	 SHORT $LN41@match_numb
$LN38@match_numb:
  0006d	48 8d be a0 00
	00 00		 lea	 rdi, QWORD PTR [rsi+160]
  00074	eb 07		 jmp	 SHORT $LN41@match_numb
$LN40@match_numb:
  00076	48 8b be a0 00
	00 00		 mov	 rdi, QWORD PTR [rsi+160]
$LN41@match_numb:

; 863  :     kind = PyUnicode_KIND(pystr);
; 864  :     end_idx = PyUnicode_GET_LENGTH(pystr) - 1;

  0007d	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]
  00081	41 c1 e9 02	 shr	 r9d, 2
  00085	41 83 e1 07	 and	 r9d, 7
  00089	48 ff ca	 dec	 rdx

; 865  : 
; 866  :     /* read a sign if it's there, make sure it's not the end of the string */
; 867  :     if (PyUnicode_READ(kind, str, idx) == '-') {

  0008c	41 83 f9 01	 cmp	 r9d, 1
  00090	75 07		 jne	 SHORT $LN44@match_numb
  00092	42 0f b6 04 37	 movzx	 eax, BYTE PTR [rdi+r14]
  00097	eb 11		 jmp	 SHORT $LN43@match_numb
$LN44@match_numb:
  00099	41 83 f9 02	 cmp	 r9d, 2
  0009d	75 07		 jne	 SHORT $LN42@match_numb
  0009f	42 0f b7 04 77	 movzx	 eax, WORD PTR [rdi+r14*2]
  000a4	eb 04		 jmp	 SHORT $LN43@match_numb
$LN42@match_numb:
  000a6	42 8b 04 b7	 mov	 eax, DWORD PTR [rdi+r14*4]
$LN43@match_numb:
  000aa	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000ad	75 1c		 jne	 SHORT $LN31@match_numb

; 868  :         idx++;

  000af	49 8d 5e 01	 lea	 rbx, QWORD PTR [r14+1]

; 869  :         if (idx > end_idx) {

  000b3	48 3b da	 cmp	 rbx, rdx
  000b6	7e 13		 jle	 SHORT $LN31@match_numb

; 870  :             PyErr_SetNone(PyExc_StopIteration);

  000b8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_StopIteration
  000bf	e8 00 00 00 00	 call	 PyErr_SetNone

; 871  :             return NULL;

  000c4	33 c0		 xor	 eax, eax
  000c6	e9 e3 03 00 00	 jmp	 $LN134@match_numb
$LN31@match_numb:
  000cb	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12

; 872  :         }
; 873  :     }
; 874  : 
; 875  :     /* read as many integer digits as we find as long as it doesn't start with 0 */
; 876  :     if (PyUnicode_READ(kind, str, idx) >= '1' && PyUnicode_READ(kind, str, idx) <= '9') {

  000d0	41 83 f9 01	 cmp	 r9d, 1
  000d4	75 06		 jne	 SHORT $LN48@match_numb
  000d6	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  000da	eb 0f		 jmp	 SHORT $LN47@match_numb
$LN48@match_numb:
  000dc	41 83 f9 02	 cmp	 r9d, 2
  000e0	75 06		 jne	 SHORT $LN46@match_numb
  000e2	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  000e6	eb 03		 jmp	 SHORT $LN47@match_numb
$LN46@match_numb:
  000e8	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN47@match_numb:

; 878  :         while (idx <= end_idx && PyUnicode_READ(kind, str, idx) >= '0' && PyUnicode_READ(kind, str, idx) <= '9') idx++;

  000eb	4d 63 e1	 movsxd	 r12, r9d
  000ee	83 f8 31	 cmp	 eax, 49			; 00000031H
  000f1	72 77		 jb	 SHORT $LN30@match_numb

; 872  :         }
; 873  :     }
; 874  : 
; 875  :     /* read as many integer digits as we find as long as it doesn't start with 0 */
; 876  :     if (PyUnicode_READ(kind, str, idx) >= '1' && PyUnicode_READ(kind, str, idx) <= '9') {

  000f3	41 83 f9 01	 cmp	 r9d, 1
  000f7	75 06		 jne	 SHORT $LN52@match_numb
  000f9	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  000fd	eb 0f		 jmp	 SHORT $LN51@match_numb
$LN52@match_numb:
  000ff	41 83 f9 02	 cmp	 r9d, 2
  00103	75 06		 jne	 SHORT $LN50@match_numb
  00105	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00109	eb 03		 jmp	 SHORT $LN51@match_numb
$LN50@match_numb:
  0010b	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN51@match_numb:
  0010e	83 f8 39	 cmp	 eax, 57			; 00000039H
  00111	77 57		 ja	 SHORT $LN30@match_numb

; 877  :         idx++;

  00113	48 ff c3	 inc	 rbx

; 878  :         while (idx <= end_idx && PyUnicode_READ(kind, str, idx) >= '0' && PyUnicode_READ(kind, str, idx) <= '9') idx++;

  00116	48 3b da	 cmp	 rbx, rdx
  00119	0f 8f 97 02 00
	00		 jg	 $LN130@match_numb
  0011f	90		 npad	 1
$LL29@match_numb:
  00120	49 83 fc 01	 cmp	 r12, 1
  00124	75 06		 jne	 SHORT $LN56@match_numb
  00126	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0012a	eb 0f		 jmp	 SHORT $LN55@match_numb
$LN56@match_numb:
  0012c	49 83 fc 02	 cmp	 r12, 2
  00130	75 06		 jne	 SHORT $LN54@match_numb
  00132	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00136	eb 03		 jmp	 SHORT $LN55@match_numb
$LN54@match_numb:
  00138	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN55@match_numb:
  0013b	83 f8 30	 cmp	 eax, 48			; 00000030H
  0013e	72 51		 jb	 SHORT $LN25@match_numb
  00140	49 83 fc 01	 cmp	 r12, 1
  00144	75 06		 jne	 SHORT $LN60@match_numb
  00146	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0014a	eb 0f		 jmp	 SHORT $LN59@match_numb
$LN60@match_numb:
  0014c	49 83 fc 02	 cmp	 r12, 2
  00150	75 06		 jne	 SHORT $LN58@match_numb
  00152	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00156	eb 03		 jmp	 SHORT $LN59@match_numb
$LN58@match_numb:
  00158	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN59@match_numb:
  0015b	83 f8 39	 cmp	 eax, 57			; 00000039H
  0015e	77 31		 ja	 SHORT $LN25@match_numb
  00160	48 ff c3	 inc	 rbx
  00163	48 3b da	 cmp	 rbx, rdx
  00166	7e b8		 jle	 SHORT $LL29@match_numb

; 879  :     }
; 880  :     /* if it starts with 0 we only expect one integer digit */
; 881  :     else if (PyUnicode_READ(kind, str, idx) == '0') {

  00168	eb 27		 jmp	 SHORT $LN25@match_numb
$LN30@match_numb:
  0016a	41 83 f9 01	 cmp	 r9d, 1
  0016e	75 06		 jne	 SHORT $LN64@match_numb
  00170	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  00174	eb 0f		 jmp	 SHORT $LN63@match_numb
$LN64@match_numb:
  00176	41 83 f9 02	 cmp	 r9d, 2
  0017a	75 06		 jne	 SHORT $LN62@match_numb
  0017c	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00180	eb 03		 jmp	 SHORT $LN63@match_numb
$LN62@match_numb:
  00182	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN63@match_numb:
  00185	83 f8 30	 cmp	 eax, 48			; 00000030H
  00188	0f 85 0d 03 00
	00		 jne	 $LN26@match_numb

; 882  :         idx++;

  0018e	48 ff c3	 inc	 rbx
$LN25@match_numb:

; 888  :     }
; 889  : 
; 890  :     /* if the next char is '.' followed by a digit then read all float digits */
; 891  :     if (idx < end_idx && PyUnicode_READ(kind, str, idx) == '.' && PyUnicode_READ(kind, str, idx + 1) >= '0' && PyUnicode_READ(kind, str, idx + 1) <= '9') {

  00191	48 3b da	 cmp	 rbx, rdx
  00194	0f 8d 1c 02 00
	00		 jge	 $LN130@match_numb
  0019a	41 83 f9 01	 cmp	 r9d, 1
  0019e	75 06		 jne	 SHORT $LN68@match_numb
  001a0	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  001a4	eb 0f		 jmp	 SHORT $LN67@match_numb
$LN68@match_numb:
  001a6	41 83 f9 02	 cmp	 r9d, 2
  001aa	75 06		 jne	 SHORT $LN66@match_numb
  001ac	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  001b0	eb 03		 jmp	 SHORT $LN67@match_numb
$LN66@match_numb:
  001b2	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN67@match_numb:
  001b5	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001b8	0f 85 9f 00 00
	00		 jne	 $LN132@match_numb
  001be	41 83 f9 01	 cmp	 r9d, 1
  001c2	75 07		 jne	 SHORT $LN72@match_numb
  001c4	0f b6 44 1f 01	 movzx	 eax, BYTE PTR [rdi+rbx+1]
  001c9	eb 11		 jmp	 SHORT $LN71@match_numb
$LN72@match_numb:
  001cb	41 83 f9 02	 cmp	 r9d, 2
  001cf	75 07		 jne	 SHORT $LN70@match_numb
  001d1	0f b7 44 5f 02	 movzx	 eax, WORD PTR [rdi+rbx*2+2]
  001d6	eb 04		 jmp	 SHORT $LN71@match_numb
$LN70@match_numb:
  001d8	8b 44 9f 04	 mov	 eax, DWORD PTR [rdi+rbx*4+4]
$LN71@match_numb:
  001dc	83 f8 30	 cmp	 eax, 48			; 00000030H
  001df	72 7c		 jb	 SHORT $LN132@match_numb
  001e1	41 83 f9 01	 cmp	 r9d, 1
  001e5	75 07		 jne	 SHORT $LN76@match_numb
  001e7	0f b6 44 1f 01	 movzx	 eax, BYTE PTR [rdi+rbx+1]
  001ec	eb 11		 jmp	 SHORT $LN75@match_numb
$LN76@match_numb:
  001ee	41 83 f9 02	 cmp	 r9d, 2
  001f2	75 07		 jne	 SHORT $LN74@match_numb
  001f4	0f b7 44 5f 02	 movzx	 eax, WORD PTR [rdi+rbx*2+2]
  001f9	eb 04		 jmp	 SHORT $LN75@match_numb
$LN74@match_numb:
  001fb	8b 44 9f 04	 mov	 eax, DWORD PTR [rdi+rbx*4+4]
$LN75@match_numb:
  001ff	83 f8 39	 cmp	 eax, 57			; 00000039H
  00202	77 59		 ja	 SHORT $LN132@match_numb

; 892  :         is_float = 1;
; 893  :         idx += 2;

  00204	48 83 c3 02	 add	 rbx, 2
  00208	41 bf 01 00 00
	00		 mov	 r15d, 1

; 894  :         while (idx <= end_idx && PyUnicode_READ(kind, str, idx) >= '0' && PyUnicode_READ(kind, str, idx) <= '9') idx++;

  0020e	48 3b da	 cmp	 rbx, rdx
  00211	0f 8f 8d 01 00
	00		 jg	 $LN14@match_numb
$LL23@match_numb:
  00217	4d 3b e7	 cmp	 r12, r15
  0021a	75 06		 jne	 SHORT $LN80@match_numb
  0021c	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  00220	eb 0f		 jmp	 SHORT $LN79@match_numb
$LN80@match_numb:
  00222	49 83 fc 02	 cmp	 r12, 2
  00226	75 06		 jne	 SHORT $LN78@match_numb
  00228	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  0022c	eb 03		 jmp	 SHORT $LN79@match_numb
$LN78@match_numb:
  0022e	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN79@match_numb:
  00231	83 f8 30	 cmp	 eax, 48			; 00000030H
  00234	72 27		 jb	 SHORT $LN132@match_numb
  00236	4d 3b e7	 cmp	 r12, r15
  00239	75 06		 jne	 SHORT $LN84@match_numb
  0023b	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0023f	eb 0f		 jmp	 SHORT $LN83@match_numb
$LN84@match_numb:
  00241	49 83 fc 02	 cmp	 r12, 2
  00245	75 06		 jne	 SHORT $LN82@match_numb
  00247	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  0024b	eb 03		 jmp	 SHORT $LN83@match_numb
$LN82@match_numb:
  0024d	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN83@match_numb:
  00250	83 f8 39	 cmp	 eax, 57			; 00000039H
  00253	77 08		 ja	 SHORT $LN132@match_numb
  00255	48 ff c3	 inc	 rbx
  00258	48 3b da	 cmp	 rbx, rdx
  0025b	7e ba		 jle	 SHORT $LL23@match_numb
$LN132@match_numb:

; 895  :     }
; 896  : 
; 897  :     /* if the next char is 'e' or 'E' then maybe read the exponent (or backtrack) */
; 898  :     if (idx < end_idx && (PyUnicode_READ(kind, str, idx) == 'e' || PyUnicode_READ(kind, str, idx) == 'E')) {

  0025d	48 3b da	 cmp	 rbx, rdx
  00260	0f 8d 3e 01 00
	00		 jge	 $LN14@match_numb
  00266	41 83 f9 01	 cmp	 r9d, 1
  0026a	75 06		 jne	 SHORT $LN88@match_numb
  0026c	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  00270	eb 0f		 jmp	 SHORT $LN87@match_numb
$LN88@match_numb:
  00272	41 83 f9 02	 cmp	 r9d, 2
  00276	75 06		 jne	 SHORT $LN86@match_numb
  00278	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  0027c	eb 03		 jmp	 SHORT $LN87@match_numb
$LN86@match_numb:
  0027e	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN87@match_numb:
  00281	83 f8 65	 cmp	 eax, 101		; 00000065H
  00284	74 24		 je	 SHORT $LN20@match_numb
  00286	41 83 f9 01	 cmp	 r9d, 1
  0028a	75 06		 jne	 SHORT $LN92@match_numb
  0028c	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  00290	eb 0f		 jmp	 SHORT $LN91@match_numb
$LN92@match_numb:
  00292	41 83 f9 02	 cmp	 r9d, 2
  00296	75 06		 jne	 SHORT $LN90@match_numb
  00298	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  0029c	eb 03		 jmp	 SHORT $LN91@match_numb
$LN90@match_numb:
  0029e	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN91@match_numb:
  002a1	83 f8 45	 cmp	 eax, 69			; 00000045H
  002a4	0f 85 fa 00 00
	00		 jne	 $LN14@match_numb
$LN20@match_numb:

; 899  :         Py_ssize_t e_start = idx;

  002aa	48 8b cb	 mov	 rcx, rbx

; 900  :         idx++;

  002ad	48 ff c3	 inc	 rbx

; 901  : 
; 902  :         /* read an exponent sign if present */
; 903  :         if (idx < end_idx && (PyUnicode_READ(kind, str, idx) == '-' || PyUnicode_READ(kind, str, idx) == '+')) idx++;

  002b0	48 3b da	 cmp	 rbx, rdx
  002b3	7d 46		 jge	 SHORT $LN138@match_numb
  002b5	41 83 f9 01	 cmp	 r9d, 1
  002b9	75 06		 jne	 SHORT $LN96@match_numb
  002bb	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  002bf	eb 0f		 jmp	 SHORT $LN95@match_numb
$LN96@match_numb:
  002c1	41 83 f9 02	 cmp	 r9d, 2
  002c5	75 06		 jne	 SHORT $LN94@match_numb
  002c7	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  002cb	eb 03		 jmp	 SHORT $LN95@match_numb
$LN94@match_numb:
  002cd	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN95@match_numb:
  002d0	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  002d3	74 20		 je	 SHORT $LN18@match_numb
  002d5	41 83 f9 01	 cmp	 r9d, 1
  002d9	75 06		 jne	 SHORT $LN100@match_numb
  002db	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  002df	eb 0f		 jmp	 SHORT $LN99@match_numb
$LN100@match_numb:
  002e1	41 83 f9 02	 cmp	 r9d, 2
  002e5	75 06		 jne	 SHORT $LN98@match_numb
  002e7	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  002eb	eb 03		 jmp	 SHORT $LN99@match_numb
$LN98@match_numb:
  002ed	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN99@match_numb:
  002f0	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  002f3	75 03		 jne	 SHORT $LN124@match_numb
$LN18@match_numb:
  002f5	48 ff c3	 inc	 rbx
$LN124@match_numb:

; 904  : 
; 905  :         /* read all digits */
; 906  :         while (idx <= end_idx && PyUnicode_READ(kind, str, idx) >= '0' && PyUnicode_READ(kind, str, idx) <= '9') idx++;

  002f8	48 3b da	 cmp	 rbx, rdx
$LN138@match_numb:
  002fb	7f 4b		 jg	 SHORT $LN133@match_numb
  002fd	0f 1f 00	 npad	 3
$LL17@match_numb:
  00300	49 83 fc 01	 cmp	 r12, 1
  00304	75 06		 jne	 SHORT $LN104@match_numb
  00306	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0030a	eb 0f		 jmp	 SHORT $LN103@match_numb
$LN104@match_numb:
  0030c	49 83 fc 02	 cmp	 r12, 2
  00310	75 06		 jne	 SHORT $LN102@match_numb
  00312	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00316	eb 03		 jmp	 SHORT $LN103@match_numb
$LN102@match_numb:
  00318	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN103@match_numb:
  0031b	83 f8 30	 cmp	 eax, 48			; 00000030H
  0031e	72 28		 jb	 SHORT $LN133@match_numb
  00320	49 83 fc 01	 cmp	 r12, 1
  00324	75 06		 jne	 SHORT $LN108@match_numb
  00326	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  0032a	eb 0f		 jmp	 SHORT $LN107@match_numb
$LN108@match_numb:
  0032c	49 83 fc 02	 cmp	 r12, 2
  00330	75 06		 jne	 SHORT $LN106@match_numb
  00332	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00336	eb 03		 jmp	 SHORT $LN107@match_numb
$LN106@match_numb:
  00338	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN107@match_numb:
  0033b	83 f8 39	 cmp	 eax, 57			; 00000039H
  0033e	77 08		 ja	 SHORT $LN133@match_numb
  00340	48 ff c3	 inc	 rbx
  00343	48 3b da	 cmp	 rbx, rdx
  00346	7e b8		 jle	 SHORT $LL17@match_numb
$LN133@match_numb:

; 907  : 
; 908  :         /* if we got a digit, then parse as float. if not, backtrack */
; 909  :         if (PyUnicode_READ(kind, str, idx - 1) >= '0' && PyUnicode_READ(kind, str, idx - 1) <= '9') {

  00348	41 83 f9 01	 cmp	 r9d, 1
  0034c	75 07		 jne	 SHORT $LN112@match_numb
  0034e	0f b6 44 1f ff	 movzx	 eax, BYTE PTR [rdi+rbx-1]
  00353	eb 11		 jmp	 SHORT $LN111@match_numb
$LN112@match_numb:
  00355	41 83 f9 02	 cmp	 r9d, 2
  00359	75 07		 jne	 SHORT $LN110@match_numb
  0035b	0f b7 44 5f fe	 movzx	 eax, WORD PTR [rdi+rbx*2-2]
  00360	eb 04		 jmp	 SHORT $LN111@match_numb
$LN110@match_numb:
  00362	8b 44 9f fc	 mov	 eax, DWORD PTR [rdi+rbx*4-4]
$LN111@match_numb:
  00366	83 f8 30	 cmp	 eax, 48			; 00000030H
  00369	72 36		 jb	 SHORT $LN15@match_numb
  0036b	41 83 f9 01	 cmp	 r9d, 1
  0036f	75 07		 jne	 SHORT $LN116@match_numb
  00371	0f b6 44 1f ff	 movzx	 eax, BYTE PTR [rdi+rbx-1]
  00376	eb 11		 jmp	 SHORT $LN115@match_numb
$LN116@match_numb:
  00378	41 83 f9 02	 cmp	 r9d, 2
  0037c	75 07		 jne	 SHORT $LN114@match_numb
  0037e	0f b7 44 5f fe	 movzx	 eax, WORD PTR [rdi+rbx*2-2]
  00383	eb 04		 jmp	 SHORT $LN115@match_numb
$LN114@match_numb:
  00385	8b 44 9f fc	 mov	 eax, DWORD PTR [rdi+rbx*4-4]
$LN115@match_numb:
  00389	83 f8 39	 cmp	 eax, 57			; 00000039H
  0038c	77 13		 ja	 SHORT $LN15@match_numb

; 914  :         }
; 915  :     }
; 916  : 
; 917  :     if (is_float && s->parse_float != (PyObject *)&PyFloat_Type)

  0038e	48 8b 75 78	 mov	 rsi, QWORD PTR [rbp+120]
  00392	41 bf 01 00 00
	00		 mov	 r15d, 1
  00398	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type

; 918  :         custom_func = s->parse_float;

  0039f	eb 23		 jmp	 SHORT $LN140@match_numb
$LN15@match_numb:

; 910  :             is_float = 1;
; 911  :         }
; 912  :         else {
; 913  :             idx = e_start;

  003a1	48 8b d9	 mov	 rbx, rcx
$LN14@match_numb:

; 914  :         }
; 915  :     }
; 916  : 
; 917  :     if (is_float && s->parse_float != (PyObject *)&PyFloat_Type)

  003a4	45 85 ff	 test	 r15d, r15d
  003a7	74 0d		 je	 SHORT $LN130@match_numb
  003a9	48 8b 75 78	 mov	 rsi, QWORD PTR [rbp+120]
  003ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type

; 918  :         custom_func = s->parse_float;

  003b4	eb 0e		 jmp	 SHORT $LN140@match_numb
$LN130@match_numb:

; 919  :     else if (!is_float && s->parse_int != (PyObject *) &PyLong_Type)

  003b6	48 8b b5 80 00
	00 00		 mov	 rsi, QWORD PTR [rbp+128]
  003bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
$LN140@match_numb:
  003c4	48 3b f0	 cmp	 rsi, rax
  003c7	74 3a		 je	 SHORT $LN9@match_numb

; 920  :         custom_func = s->parse_int;
; 921  :     else
; 922  :         custom_func = NULL;
; 923  : 
; 924  :     if (custom_func) {

  003c9	48 85 f6	 test	 rsi, rsi
  003cc	74 35		 je	 SHORT $LN9@match_numb

; 925  :         /* copy the section we determined to be a number */
; 926  :         numstr = PyUnicode_FromKindAndData(kind,
; 927  :                                            (char*)str + kind * start,
; 928  :                                            idx - start);

  003ce	4d 0f af e6	 imul	 r12, r14
  003d2	4c 8b c3	 mov	 r8, rbx
  003d5	41 8b c9	 mov	 ecx, r9d
  003d8	4d 2b c6	 sub	 r8, r14
  003db	4a 8d 14 27	 lea	 rdx, QWORD PTR [rdi+r12]
  003df	e8 00 00 00 00	 call	 PyUnicode_FromKindAndData
  003e4	48 8b e8	 mov	 rbp, rax

; 929  :         if (numstr == NULL)

  003e7	48 85 c0	 test	 rax, rax

; 930  :             return NULL;

  003ea	0f 84 b7 00 00
	00		 je	 $LN141@match_numb

; 931  :         rval = PyObject_CallFunctionObjArgs(custom_func, numstr, NULL);

  003f0	45 33 c0	 xor	 r8d, r8d
  003f3	48 8b d0	 mov	 rdx, rax
  003f6	48 8b ce	 mov	 rcx, rsi
  003f9	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs

; 932  :     }
; 933  :     else {

  003fe	e9 80 00 00 00	 jmp	 $LN142@match_numb
$LN9@match_numb:

; 934  :         Py_ssize_t i, n;
; 935  :         char *buf;
; 936  :         /* Straight conversion to ASCII, to avoid costly conversion of
; 937  :            decimal unicode digits (which cannot appear here) */
; 938  :         n = idx - start;

  00403	48 8b f3	 mov	 rsi, rbx

; 939  :         numstr = PyBytes_FromStringAndSize(NULL, n);

  00406	33 c9		 xor	 ecx, ecx
  00408	49 2b f6	 sub	 rsi, r14
  0040b	48 8b d6	 mov	 rdx, rsi
  0040e	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00413	48 8b e8	 mov	 rbp, rax

; 940  :         if (numstr == NULL)

  00416	48 85 c0	 test	 rax, rax

; 941  :             return NULL;

  00419	0f 84 88 00 00
	00		 je	 $LN141@match_numb

; 943  :         for (i = 0; i < n; i++) {

  0041f	48 85 f6	 test	 rsi, rsi
  00422	7e 41		 jle	 SHORT $LN3@match_numb

; 942  :         buf = PyBytes_AS_STRING(numstr);

  00424	4a 8d 14 b7	 lea	 rdx, QWORD PTR [rdi+r14*4]
  00428	4e 8d 04 77	 lea	 r8, QWORD PTR [rdi+r14*2]
  0042c	0f 1f 40 00	 npad	 4
$LL5@match_numb:

; 944  :             buf[i] = (char) PyUnicode_READ(kind, str, i + start);

  00430	49 83 fc 01	 cmp	 r12, 1
  00434	75 0c		 jne	 SHORT $LN120@match_numb
  00436	49 8d 44 3d 00	 lea	 rax, QWORD PTR [r13+rdi]
  0043b	42 0f b6 0c 30	 movzx	 ecx, BYTE PTR [rax+r14]
  00440	eb 0e		 jmp	 SHORT $LN119@match_numb
$LN120@match_numb:
  00442	49 83 fc 02	 cmp	 r12, 2
  00446	75 06		 jne	 SHORT $LN118@match_numb
  00448	41 0f b7 08	 movzx	 ecx, WORD PTR [r8]
  0044c	eb 02		 jmp	 SHORT $LN119@match_numb
$LN118@match_numb:
  0044e	8b 0a		 mov	 ecx, DWORD PTR [rdx]
$LN119@match_numb:
  00450	41 88 4c 2d 78	 mov	 BYTE PTR [r13+rbp+120], cl
  00455	49 ff c5	 inc	 r13
  00458	49 83 c0 02	 add	 r8, 2
  0045c	48 83 c2 04	 add	 rdx, 4
  00460	4c 3b ee	 cmp	 r13, rsi
  00463	7c cb		 jl	 SHORT $LL5@match_numb
$LN3@match_numb:

; 945  :         }
; 946  :         if (is_float)

  00465	45 85 ff	 test	 r15d, r15d
  00468	74 0a		 je	 SHORT $LN2@match_numb

; 947  :             rval = PyFloat_FromString(numstr);

  0046a	48 8b cd	 mov	 rcx, rbp
  0046d	e8 00 00 00 00	 call	 PyFloat_FromString

; 948  :         else

  00472	eb 0f		 jmp	 SHORT $LN142@match_numb
$LN2@match_numb:

; 949  :             rval = PyLong_FromString(buf, NULL, 10);

  00474	33 d2		 xor	 edx, edx
  00476	48 8d 4d 78	 lea	 rcx, QWORD PTR [rbp+120]
  0047a	44 8d 42 0a	 lea	 r8d, QWORD PTR [rdx+10]
  0047e	e8 00 00 00 00	 call	 PyLong_FromString
$LN142@match_numb:

; 950  :     }
; 951  :     Py_DECREF(numstr);

  00483	48 8b cd	 mov	 rcx, rbp
  00486	48 8b f8	 mov	 rdi, rax
  00489	e8 00 00 00 00	 call	 _Py_DecRef

; 952  :     *next_idx_ptr = idx;

  0048e	4c 8b 5c 24 68	 mov	 r11, QWORD PTR next_idx_ptr$[rsp]

; 953  :     return rval;

  00493	48 8b c7	 mov	 rax, rdi
  00496	49 89 1b	 mov	 QWORD PTR [r11], rbx
  00499	eb 0e		 jmp	 SHORT $LN135@match_numb
$LN26@match_numb:

; 883  :     }
; 884  :     /* no integer digits, error */
; 885  :     else {
; 886  :         PyErr_SetNone(PyExc_StopIteration);

  0049b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_StopIteration
  004a2	e8 00 00 00 00	 call	 PyErr_SetNone
$LN141@match_numb:

; 887  :         return NULL;

  004a7	33 c0		 xor	 eax, eax
$LN135@match_numb:
  004a9	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]
$LN134@match_numb:
  004ae	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 954  : }

  004b3	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  004b8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  004bc	41 5f		 pop	 r15
  004be	41 5e		 pop	 r14
  004c0	41 5d		 pop	 r13
  004c2	5e		 pop	 rsi
  004c3	5d		 pop	 rbp
  004c4	c3		 ret	 0
_match_number_unicode ENDP
_TEXT	ENDS
PUBLIC	??_C@_09BLDCEMOH@?9Infinity?$AA@		; `string'
PUBLIC	??_C@_08KEBCLIFP@Infinity?$AA@			; `string'
PUBLIC	??_C@_03ICJPMMHB@NaN?$AA@			; `string'
PUBLIC	??_C@_0DD@KJGHDLGJ@?5while?5decoding?5a?5JSON?5array?5fro@ ; `string'
PUBLIC	??_C@_0DE@POAICCIC@?5while?5decoding?5a?5JSON?5object?5fr@ ; `string'
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_Py_CheckRecursiveCall:PROC
EXTRN	_Py_CheckRecursionLimit:DWORD
EXTRN	_PyThreadState_Current:QWORD
EXTRN	_PyParallel_GetThreadState:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$scan_once_unicode DD imagerel scan_once_unicode
	DD	imagerel scan_once_unicode+1930
	DD	imagerel $unwind$scan_once_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scan_once_unicode DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_09BLDCEMOH@?9Infinity?$AA@
CONST	SEGMENT
??_C@_09BLDCEMOH@?9Infinity?$AA@ DB '-Infinity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KEBCLIFP@Infinity?$AA@
CONST	SEGMENT
??_C@_08KEBCLIFP@Infinity?$AA@ DB 'Infinity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICJPMMHB@NaN?$AA@
CONST	SEGMENT
??_C@_03ICJPMMHB@NaN?$AA@ DB 'NaN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@KJGHDLGJ@?5while?5decoding?5a?5JSON?5array?5fro@
CONST	SEGMENT
??_C@_0DD@KJGHDLGJ@?5while?5decoding?5a?5JSON?5array?5fro@ DB ' while dec'
	DB	'oding a JSON array from a unicode string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@POAICCIC@?5while?5decoding?5a?5JSON?5object?5fr@
CONST	SEGMENT
??_C@_0DE@POAICCIC@?5while?5decoding?5a?5JSON?5object?5fr@ DB ' while dec'
	DB	'oding a JSON object from a unicode string', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT scan_once_unicode
_TEXT	SEGMENT
s$ = 48
pystr$ = 56
idx$ = 64
next_idx_ptr$ = 72
scan_once_unicode PROC					; COMDAT

; 958  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 959  :     /* Read one JSON term (of any kind) from PyUnicode pystr.
; 960  :     idx is the index of the first character of the term
; 961  :     *next_idx_ptr is a return-by-reference index to the first character after
; 962  :         the number.
; 963  : 
; 964  :     Returns a new PyObject representation of the term.
; 965  :     */
; 966  :     PyObject *res;
; 967  :     void *str;
; 968  :     int kind;
; 969  :     Py_ssize_t length;
; 970  : 
; 971  :     if (PyUnicode_READY(pystr) == -1)

  00014	f6 42 70 80	 test	 BYTE PTR [rdx+112], 128	; 00000080H
  00018	49 8b f1	 mov	 rsi, r9
  0001b	49 8b d8	 mov	 rbx, r8
  0001e	48 8b fa	 mov	 rdi, rdx
  00021	48 8b e9	 mov	 rbp, rcx
  00024	75 0d		 jne	 SHORT $LN29@scan_once_
  00026	48 8b ca	 mov	 rcx, rdx
  00029	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0002e	83 f8 ff	 cmp	 eax, -1

; 972  :         return NULL;

  00031	74 46		 je	 SHORT $LN168@scan_once_
$LN29@scan_once_:

; 973  : 
; 974  :     str = PyUnicode_DATA(pystr);

  00033	44 8b 47 70	 mov	 r8d, DWORD PTR [rdi+112]
  00037	41 f6 c0 20	 test	 r8b, 32			; 00000020H
  0003b	74 18		 je	 SHORT $LN36@scan_once_
  0003d	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00041	74 09		 je	 SHORT $LN34@scan_once_
  00043	48 8d 97 80 00
	00 00		 lea	 rdx, QWORD PTR [rdi+128]
  0004a	eb 10		 jmp	 SHORT $LN37@scan_once_
$LN34@scan_once_:
  0004c	48 8d 97 a0 00
	00 00		 lea	 rdx, QWORD PTR [rdi+160]
  00053	eb 07		 jmp	 SHORT $LN37@scan_once_
$LN36@scan_once_:
  00055	48 8b 97 a0 00
	00 00		 mov	 rdx, QWORD PTR [rdi+160]
$LN37@scan_once_:

; 975  :     kind = PyUnicode_KIND(pystr);
; 976  :     length = PyUnicode_GET_LENGTH(pystr);

  0005c	4c 8b 4f 60	 mov	 r9, QWORD PTR [rdi+96]
  00060	41 c1 e8 02	 shr	 r8d, 2
  00064	41 83 e0 07	 and	 r8d, 7

; 977  : 
; 978  :     if (idx >= length) {

  00068	49 3b d9	 cmp	 rbx, r9
  0006b	7c 13		 jl	 SHORT $LN28@scan_once_

; 979  :         PyErr_SetNone(PyExc_StopIteration);

  0006d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_StopIteration
  00074	e8 00 00 00 00	 call	 PyErr_SetNone
$LN168@scan_once_:

; 980  :         return NULL;

  00079	33 c0		 xor	 eax, eax
  0007b	e9 71 06 00 00	 jmp	 $LN30@scan_once_
$LN28@scan_once_:

; 981  :     }
; 982  : 
; 983  :     switch (PyUnicode_READ(kind, str, idx)) {

  00080	41 83 f8 01	 cmp	 r8d, 1
  00084	75 06		 jne	 SHORT $LN40@scan_once_
  00086	0f b6 04 1a	 movzx	 eax, BYTE PTR [rdx+rbx]
  0008a	eb 0f		 jmp	 SHORT $LN39@scan_once_
$LN40@scan_once_:
  0008c	41 83 f8 02	 cmp	 r8d, 2
  00090	75 06		 jne	 SHORT $LN38@scan_once_
  00092	0f b7 04 5a	 movzx	 eax, WORD PTR [rdx+rbx*2]
  00096	eb 03		 jmp	 SHORT $LN39@scan_once_
$LN38@scan_once_:
  00098	8b 04 9a	 mov	 eax, DWORD PTR [rdx+rbx*4]
$LN39@scan_once_:
  0009b	83 c0 de	 add	 eax, -34		; ffffffdeH
  0009e	83 f8 59	 cmp	 eax, 89			; 00000059H
  000a1	0f 87 39 06 00
	00		 ja	 $LN1@scan_once_
  000a7	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:__ImageBase
  000ae	41 0f b6 84 02
	00 00 00 00	 movzx	 eax, BYTE PTR $LN166@scan_once_[r10+rax]
  000b7	41 8b 8c 82 00
	00 00 00	 mov	 ecx, DWORD PTR $LN167@scan_once_[r10+rax*4]
  000bf	49 03 ca	 add	 rcx, r10
  000c2	ff e1		 jmp	 rcx
$LN25@scan_once_:

; 984  :         case '"':
; 985  :             /* string */
; 986  :             return scanstring_unicode(pystr, idx + 1,
; 987  :                 PyObject_IsTrue(s->strict),
; 988  :                 next_idx_ptr);

  000c4	48 8b 4d 60	 mov	 rcx, QWORD PTR [rbp+96]
  000c8	e8 00 00 00 00	 call	 PyObject_IsTrue
  000cd	48 8d 53 01	 lea	 rdx, QWORD PTR [rbx+1]
  000d1	4c 8b ce	 mov	 r9, rsi
  000d4	44 8b c0	 mov	 r8d, eax
  000d7	48 8b cf	 mov	 rcx, rdi
  000da	e8 00 00 00 00	 call	 scanstring_unicode
  000df	e9 0d 06 00 00	 jmp	 $LN30@scan_once_
$LN24@scan_once_:

; 989  :         case '{':
; 990  :             /* object */
; 991  :             if (Py_EnterRecursiveCall(" while decoding a JSON object "
; 992  :                                       "from a unicode string"))

  000e4	e8 00 00 00 00	 call	 _Py_PXCTX
  000e9	85 c0		 test	 eax, eax
  000eb	74 07		 je	 SHORT $LN42@scan_once_
  000ed	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  000f2	eb 07		 jmp	 SHORT $LN43@scan_once_
$LN42@scan_once_:
  000f4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN43@scan_once_:
  000fb	ff 40 18	 inc	 DWORD PTR [rax+24]
  000fe	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00101	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  00107	7e 14		 jle	 SHORT $LN23@scan_once_
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DE@POAICCIC@?5while?5decoding?5a?5JSON?5object?5fr@
  00110	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  00115	85 c0		 test	 eax, eax

; 993  :                 return NULL;

  00117	0f 85 5c ff ff
	ff		 jne	 $LN168@scan_once_
$LN23@scan_once_:

; 994  :             res = _parse_object_unicode(s, pystr, idx + 1, next_idx_ptr);

  0011d	4c 8d 43 01	 lea	 r8, QWORD PTR [rbx+1]
  00121	4c 8b ce	 mov	 r9, rsi
  00124	48 8b d7	 mov	 rdx, rdi
  00127	48 8b cd	 mov	 rcx, rbp
  0012a	e8 00 00 00 00	 call	 _parse_object_unicode
$LN169@scan_once_:
  0012f	48 8b d8	 mov	 rbx, rax

; 995  :             Py_LeaveRecursiveCall();

  00132	e8 00 00 00 00	 call	 _Py_PXCTX
  00137	85 c0		 test	 eax, eax
  00139	74 0a		 je	 SHORT $LN44@scan_once_
  0013b	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00140	4c 8b d8	 mov	 r11, rax
  00143	eb 07		 jmp	 SHORT $LN45@scan_once_
$LN44@scan_once_:
  00145	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _PyThreadState_Current
$LN45@scan_once_:
  0014c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  00152	83 f8 64	 cmp	 eax, 100		; 00000064H
  00155	7e 05		 jle	 SHORT $LN46@scan_once_
  00157	83 c0 ce	 add	 eax, -50		; ffffffffffffffceH
  0015a	eb 06		 jmp	 SHORT $LN47@scan_once_
$LN46@scan_once_:
  0015c	c1 f8 02	 sar	 eax, 2
  0015f	8d 04 40	 lea	 eax, DWORD PTR [rax+rax*2]
$LN47@scan_once_:
  00162	41 ff 4b 18	 dec	 DWORD PTR [r11+24]
  00166	41 39 43 18	 cmp	 DWORD PTR [r11+24], eax
  0016a	7d 25		 jge	 SHORT $LN21@scan_once_
  0016c	e8 00 00 00 00	 call	 _Py_PXCTX
  00171	85 c0		 test	 eax, eax
  00173	74 11		 je	 SHORT $LN48@scan_once_
  00175	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0017a	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0

; 996  :             return res;

  0017e	48 8b c3	 mov	 rax, rbx
  00181	e9 6b 05 00 00	 jmp	 $LN30@scan_once_
$LN48@scan_once_:

; 995  :             Py_LeaveRecursiveCall();

  00186	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
  0018d	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN21@scan_once_:

; 996  :             return res;

  00191	48 8b c3	 mov	 rax, rbx
  00194	e9 58 05 00 00	 jmp	 $LN30@scan_once_
$LN18@scan_once_:

; 997  :         case '[':
; 998  :             /* array */
; 999  :             if (Py_EnterRecursiveCall(" while decoding a JSON array "
; 1000 :                                       "from a unicode string"))

  00199	e8 00 00 00 00	 call	 _Py_PXCTX
  0019e	85 c0		 test	 eax, eax
  001a0	74 07		 je	 SHORT $LN50@scan_once_
  001a2	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  001a7	eb 07		 jmp	 SHORT $LN51@scan_once_
$LN50@scan_once_:
  001a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN51@scan_once_:
  001b0	ff 40 18	 inc	 DWORD PTR [rax+24]
  001b3	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  001b6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  001bc	7e 14		 jle	 SHORT $LN17@scan_once_
  001be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DD@KJGHDLGJ@?5while?5decoding?5a?5JSON?5array?5fro@
  001c5	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  001ca	85 c0		 test	 eax, eax

; 1001 :                 return NULL;

  001cc	0f 85 a7 fe ff
	ff		 jne	 $LN168@scan_once_
$LN17@scan_once_:

; 1002 :             res = _parse_array_unicode(s, pystr, idx + 1, next_idx_ptr);

  001d2	4c 8d 43 01	 lea	 r8, QWORD PTR [rbx+1]
  001d6	4c 8b ce	 mov	 r9, rsi
  001d9	48 8b d7	 mov	 rdx, rdi
  001dc	48 8b cd	 mov	 rcx, rbp
  001df	e8 00 00 00 00	 call	 _parse_array_unicode

; 1003 :             Py_LeaveRecursiveCall();

  001e4	e9 46 ff ff ff	 jmp	 $LN169@scan_once_
$LN12@scan_once_:

; 1004 :             return res;
; 1005 :         case 'n':
; 1006 :             /* null */
; 1007 :             if ((idx + 3 < length) && PyUnicode_READ(kind, str, idx + 1) == 'u' && PyUnicode_READ(kind, str, idx + 2) == 'l' && PyUnicode_READ(kind, str, idx + 3) == 'l') {

  001e9	48 8d 4b 03	 lea	 rcx, QWORD PTR [rbx+3]
  001ed	49 3b c9	 cmp	 rcx, r9
  001f0	0f 8d ea 04 00
	00		 jge	 $LN1@scan_once_
  001f6	41 83 f8 01	 cmp	 r8d, 1
  001fa	75 07		 jne	 SHORT $LN60@scan_once_
  001fc	0f b6 44 1a 01	 movzx	 eax, BYTE PTR [rdx+rbx+1]
  00201	eb 11		 jmp	 SHORT $LN59@scan_once_
$LN60@scan_once_:
  00203	41 83 f8 02	 cmp	 r8d, 2
  00207	75 07		 jne	 SHORT $LN58@scan_once_
  00209	0f b7 44 5a 02	 movzx	 eax, WORD PTR [rdx+rbx*2+2]
  0020e	eb 04		 jmp	 SHORT $LN59@scan_once_
$LN58@scan_once_:
  00210	8b 44 9a 04	 mov	 eax, DWORD PTR [rdx+rbx*4+4]
$LN59@scan_once_:
  00214	83 f8 75	 cmp	 eax, 117		; 00000075H
  00217	0f 85 c3 04 00
	00		 jne	 $LN1@scan_once_
  0021d	41 83 f8 01	 cmp	 r8d, 1
  00221	75 07		 jne	 SHORT $LN64@scan_once_
  00223	0f b6 44 1a 02	 movzx	 eax, BYTE PTR [rdx+rbx+2]
  00228	eb 11		 jmp	 SHORT $LN63@scan_once_
$LN64@scan_once_:
  0022a	41 83 f8 02	 cmp	 r8d, 2
  0022e	75 07		 jne	 SHORT $LN62@scan_once_
  00230	0f b7 44 5a 04	 movzx	 eax, WORD PTR [rdx+rbx*2+4]
  00235	eb 04		 jmp	 SHORT $LN63@scan_once_
$LN62@scan_once_:
  00237	8b 44 9a 08	 mov	 eax, DWORD PTR [rdx+rbx*4+8]
$LN63@scan_once_:
  0023b	83 f8 6c	 cmp	 eax, 108		; 0000006cH
  0023e	0f 85 9c 04 00
	00		 jne	 $LN1@scan_once_
  00244	41 83 f8 01	 cmp	 r8d, 1
  00248	75 07		 jne	 SHORT $LN68@scan_once_
  0024a	0f b6 44 1a 03	 movzx	 eax, BYTE PTR [rdx+rbx+3]
  0024f	eb 0f		 jmp	 SHORT $LN67@scan_once_
$LN68@scan_once_:
  00251	41 83 f8 02	 cmp	 r8d, 2
  00255	75 06		 jne	 SHORT $LN66@scan_once_
  00257	0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+rcx*2]
  0025b	eb 03		 jmp	 SHORT $LN67@scan_once_
$LN66@scan_once_:
  0025d	8b 04 8a	 mov	 eax, DWORD PTR [rdx+rcx*4]
$LN67@scan_once_:
  00260	83 f8 6c	 cmp	 eax, 108		; 0000006cH
  00263	0f 85 77 04 00
	00		 jne	 $LN1@scan_once_

; 1008 :                 Py_INCREF(Py_None);

  00269	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00270	e8 00 00 00 00	 call	 _Py_IncRef

; 1009 :                 *next_idx_ptr = idx + 4;

  00275	4c 8d 5b 04	 lea	 r11, QWORD PTR [rbx+4]

; 1010 :                 return Py_None;

  00279	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00280	4c 89 1e	 mov	 QWORD PTR [rsi], r11
  00283	e9 69 04 00 00	 jmp	 $LN30@scan_once_
$LN10@scan_once_:

; 1011 :             }
; 1012 :             break;
; 1013 :         case 't':
; 1014 :             /* true */
; 1015 :             if ((idx + 3 < length) && PyUnicode_READ(kind, str, idx + 1) == 'r' && PyUnicode_READ(kind, str, idx + 2) == 'u' && PyUnicode_READ(kind, str, idx + 3) == 'e') {

  00288	48 8d 4b 03	 lea	 rcx, QWORD PTR [rbx+3]
  0028c	49 3b c9	 cmp	 rcx, r9
  0028f	0f 8d 4b 04 00
	00		 jge	 $LN1@scan_once_
  00295	41 83 f8 01	 cmp	 r8d, 1
  00299	75 07		 jne	 SHORT $LN72@scan_once_
  0029b	0f b6 44 1a 01	 movzx	 eax, BYTE PTR [rdx+rbx+1]
  002a0	eb 11		 jmp	 SHORT $LN71@scan_once_
$LN72@scan_once_:
  002a2	41 83 f8 02	 cmp	 r8d, 2
  002a6	75 07		 jne	 SHORT $LN70@scan_once_
  002a8	0f b7 44 5a 02	 movzx	 eax, WORD PTR [rdx+rbx*2+2]
  002ad	eb 04		 jmp	 SHORT $LN71@scan_once_
$LN70@scan_once_:
  002af	8b 44 9a 04	 mov	 eax, DWORD PTR [rdx+rbx*4+4]
$LN71@scan_once_:
  002b3	83 f8 72	 cmp	 eax, 114		; 00000072H
  002b6	0f 85 24 04 00
	00		 jne	 $LN1@scan_once_
  002bc	41 83 f8 01	 cmp	 r8d, 1
  002c0	75 07		 jne	 SHORT $LN76@scan_once_
  002c2	0f b6 44 1a 02	 movzx	 eax, BYTE PTR [rdx+rbx+2]
  002c7	eb 11		 jmp	 SHORT $LN75@scan_once_
$LN76@scan_once_:
  002c9	41 83 f8 02	 cmp	 r8d, 2
  002cd	75 07		 jne	 SHORT $LN74@scan_once_
  002cf	0f b7 44 5a 04	 movzx	 eax, WORD PTR [rdx+rbx*2+4]
  002d4	eb 04		 jmp	 SHORT $LN75@scan_once_
$LN74@scan_once_:
  002d6	8b 44 9a 08	 mov	 eax, DWORD PTR [rdx+rbx*4+8]
$LN75@scan_once_:
  002da	83 f8 75	 cmp	 eax, 117		; 00000075H
  002dd	0f 85 fd 03 00
	00		 jne	 $LN1@scan_once_
  002e3	41 83 f8 01	 cmp	 r8d, 1
  002e7	75 07		 jne	 SHORT $LN80@scan_once_
  002e9	0f b6 44 1a 03	 movzx	 eax, BYTE PTR [rdx+rbx+3]
  002ee	eb 0f		 jmp	 SHORT $LN79@scan_once_
$LN80@scan_once_:
  002f0	41 83 f8 02	 cmp	 r8d, 2
  002f4	75 06		 jne	 SHORT $LN78@scan_once_
  002f6	0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+rcx*2]
  002fa	eb 03		 jmp	 SHORT $LN79@scan_once_
$LN78@scan_once_:
  002fc	8b 04 8a	 mov	 eax, DWORD PTR [rdx+rcx*4]
$LN79@scan_once_:
  002ff	83 f8 65	 cmp	 eax, 101		; 00000065H
  00302	0f 85 d8 03 00
	00		 jne	 $LN1@scan_once_

; 1016 :                 Py_INCREF(Py_True);

  00308	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  0030f	e8 00 00 00 00	 call	 _Py_IncRef

; 1017 :                 *next_idx_ptr = idx + 4;

  00314	4c 8d 5b 04	 lea	 r11, QWORD PTR [rbx+4]

; 1018 :                 return Py_True;

  00318	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  0031f	4c 89 1e	 mov	 QWORD PTR [rsi], r11
  00322	e9 ca 03 00 00	 jmp	 $LN30@scan_once_
$LN8@scan_once_:

; 1019 :             }
; 1020 :             break;
; 1021 :         case 'f':
; 1022 :             /* false */
; 1023 :             if ((idx + 4 < length) && PyUnicode_READ(kind, str, idx + 1) == 'a' &&
; 1024 :                 PyUnicode_READ(kind, str, idx + 2) == 'l' &&
; 1025 :                 PyUnicode_READ(kind, str, idx + 3) == 's' &&
; 1026 :                 PyUnicode_READ(kind, str, idx + 4) == 'e') {

  00327	48 8d 4b 04	 lea	 rcx, QWORD PTR [rbx+4]
  0032b	49 3b c9	 cmp	 rcx, r9
  0032e	0f 8d ac 03 00
	00		 jge	 $LN1@scan_once_
  00334	41 83 f8 01	 cmp	 r8d, 1
  00338	75 07		 jne	 SHORT $LN84@scan_once_
  0033a	0f b6 44 1a 01	 movzx	 eax, BYTE PTR [rdx+rbx+1]
  0033f	eb 11		 jmp	 SHORT $LN83@scan_once_
$LN84@scan_once_:
  00341	41 83 f8 02	 cmp	 r8d, 2
  00345	75 07		 jne	 SHORT $LN82@scan_once_
  00347	0f b7 44 5a 02	 movzx	 eax, WORD PTR [rdx+rbx*2+2]
  0034c	eb 04		 jmp	 SHORT $LN83@scan_once_
$LN82@scan_once_:
  0034e	8b 44 9a 04	 mov	 eax, DWORD PTR [rdx+rbx*4+4]
$LN83@scan_once_:
  00352	83 f8 61	 cmp	 eax, 97			; 00000061H
  00355	0f 85 85 03 00
	00		 jne	 $LN1@scan_once_
  0035b	41 83 f8 01	 cmp	 r8d, 1
  0035f	75 07		 jne	 SHORT $LN88@scan_once_
  00361	0f b6 44 1a 02	 movzx	 eax, BYTE PTR [rdx+rbx+2]
  00366	eb 11		 jmp	 SHORT $LN87@scan_once_
$LN88@scan_once_:
  00368	41 83 f8 02	 cmp	 r8d, 2
  0036c	75 07		 jne	 SHORT $LN86@scan_once_
  0036e	0f b7 44 5a 04	 movzx	 eax, WORD PTR [rdx+rbx*2+4]
  00373	eb 04		 jmp	 SHORT $LN87@scan_once_
$LN86@scan_once_:
  00375	8b 44 9a 08	 mov	 eax, DWORD PTR [rdx+rbx*4+8]
$LN87@scan_once_:
  00379	83 f8 6c	 cmp	 eax, 108		; 0000006cH
  0037c	0f 85 5e 03 00
	00		 jne	 $LN1@scan_once_
  00382	41 83 f8 01	 cmp	 r8d, 1
  00386	75 07		 jne	 SHORT $LN92@scan_once_
  00388	0f b6 44 1a 03	 movzx	 eax, BYTE PTR [rdx+rbx+3]
  0038d	eb 11		 jmp	 SHORT $LN91@scan_once_
$LN92@scan_once_:
  0038f	41 83 f8 02	 cmp	 r8d, 2
  00393	75 07		 jne	 SHORT $LN90@scan_once_
  00395	0f b7 44 5a 06	 movzx	 eax, WORD PTR [rdx+rbx*2+6]
  0039a	eb 04		 jmp	 SHORT $LN91@scan_once_
$LN90@scan_once_:
  0039c	8b 44 9a 0c	 mov	 eax, DWORD PTR [rdx+rbx*4+12]
$LN91@scan_once_:
  003a0	83 f8 73	 cmp	 eax, 115		; 00000073H
  003a3	0f 85 37 03 00
	00		 jne	 $LN1@scan_once_
  003a9	41 83 f8 01	 cmp	 r8d, 1
  003ad	75 07		 jne	 SHORT $LN96@scan_once_
  003af	0f b6 44 1a 04	 movzx	 eax, BYTE PTR [rdx+rbx+4]
  003b4	eb 0f		 jmp	 SHORT $LN95@scan_once_
$LN96@scan_once_:
  003b6	41 83 f8 02	 cmp	 r8d, 2
  003ba	75 06		 jne	 SHORT $LN94@scan_once_
  003bc	0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+rcx*2]
  003c0	eb 03		 jmp	 SHORT $LN95@scan_once_
$LN94@scan_once_:
  003c2	8b 04 8a	 mov	 eax, DWORD PTR [rdx+rcx*4]
$LN95@scan_once_:
  003c5	83 f8 65	 cmp	 eax, 101		; 00000065H
  003c8	0f 85 12 03 00
	00		 jne	 $LN1@scan_once_

; 1027 :                 Py_INCREF(Py_False);

  003ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  003d5	e8 00 00 00 00	 call	 _Py_IncRef

; 1028 :                 *next_idx_ptr = idx + 5;

  003da	4c 8d 5b 05	 lea	 r11, QWORD PTR [rbx+5]

; 1029 :                 return Py_False;

  003de	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  003e5	4c 89 1e	 mov	 QWORD PTR [rsi], r11
  003e8	e9 04 03 00 00	 jmp	 $LN30@scan_once_
$LN6@scan_once_:

; 1030 :             }
; 1031 :             break;
; 1032 :         case 'N':
; 1033 :             /* NaN */
; 1034 :             if ((idx + 2 < length) && PyUnicode_READ(kind, str, idx + 1) == 'a' &&
; 1035 :                 PyUnicode_READ(kind, str, idx + 2) == 'N') {

  003ed	48 8d 4b 02	 lea	 rcx, QWORD PTR [rbx+2]
  003f1	49 3b c9	 cmp	 rcx, r9
  003f4	0f 8d e6 02 00
	00		 jge	 $LN1@scan_once_
  003fa	41 83 f8 01	 cmp	 r8d, 1
  003fe	75 07		 jne	 SHORT $LN100@scan_once_
  00400	0f b6 44 1a 01	 movzx	 eax, BYTE PTR [rdx+rbx+1]
  00405	eb 11		 jmp	 SHORT $LN99@scan_once_
$LN100@scan_once_:
  00407	41 83 f8 02	 cmp	 r8d, 2
  0040b	75 07		 jne	 SHORT $LN98@scan_once_
  0040d	0f b7 44 5a 02	 movzx	 eax, WORD PTR [rdx+rbx*2+2]
  00412	eb 04		 jmp	 SHORT $LN99@scan_once_
$LN98@scan_once_:
  00414	8b 44 9a 04	 mov	 eax, DWORD PTR [rdx+rbx*4+4]
$LN99@scan_once_:
  00418	83 f8 61	 cmp	 eax, 97			; 00000061H
  0041b	0f 85 bf 02 00
	00		 jne	 $LN1@scan_once_
  00421	41 83 f8 01	 cmp	 r8d, 1
  00425	75 07		 jne	 SHORT $LN104@scan_once_
  00427	0f b6 44 1a 02	 movzx	 eax, BYTE PTR [rdx+rbx+2]
  0042c	eb 0f		 jmp	 SHORT $LN103@scan_once_
$LN104@scan_once_:
  0042e	41 83 f8 02	 cmp	 r8d, 2
  00432	75 06		 jne	 SHORT $LN102@scan_once_
  00434	0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+rcx*2]
  00438	eb 03		 jmp	 SHORT $LN103@scan_once_
$LN102@scan_once_:
  0043a	8b 04 8a	 mov	 eax, DWORD PTR [rdx+rcx*4]
$LN103@scan_once_:
  0043d	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00440	0f 85 9a 02 00
	00		 jne	 $LN1@scan_once_

; 1036 :                 return _parse_constant(s, "NaN", idx, next_idx_ptr);

  00446	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03ICJPMMHB@NaN?$AA@
  0044d	4c 8b ce	 mov	 r9, rsi
  00450	4c 8b c3	 mov	 r8, rbx
  00453	48 8b cd	 mov	 rcx, rbp
  00456	e8 00 00 00 00	 call	 _parse_constant
  0045b	e9 91 02 00 00	 jmp	 $LN30@scan_once_
$LN4@scan_once_:

; 1037 :             }
; 1038 :             break;
; 1039 :         case 'I':
; 1040 :             /* Infinity */
; 1041 :             if ((idx + 7 < length) && PyUnicode_READ(kind, str, idx + 1) == 'n' &&
; 1042 :                 PyUnicode_READ(kind, str, idx + 2) == 'f' &&
; 1043 :                 PyUnicode_READ(kind, str, idx + 3) == 'i' &&
; 1044 :                 PyUnicode_READ(kind, str, idx + 4) == 'n' &&
; 1045 :                 PyUnicode_READ(kind, str, idx + 5) == 'i' &&
; 1046 :                 PyUnicode_READ(kind, str, idx + 6) == 't' &&
; 1047 :                 PyUnicode_READ(kind, str, idx + 7) == 'y') {

  00460	48 8d 4b 07	 lea	 rcx, QWORD PTR [rbx+7]
  00464	49 3b c9	 cmp	 rcx, r9
  00467	0f 8d 73 02 00
	00		 jge	 $LN1@scan_once_
  0046d	41 83 f8 01	 cmp	 r8d, 1
  00471	75 07		 jne	 SHORT $LN108@scan_once_
  00473	0f b6 44 1a 01	 movzx	 eax, BYTE PTR [rdx+rbx+1]
  00478	eb 11		 jmp	 SHORT $LN107@scan_once_
$LN108@scan_once_:
  0047a	41 83 f8 02	 cmp	 r8d, 2
  0047e	75 07		 jne	 SHORT $LN106@scan_once_
  00480	0f b7 44 5a 02	 movzx	 eax, WORD PTR [rdx+rbx*2+2]
  00485	eb 04		 jmp	 SHORT $LN107@scan_once_
$LN106@scan_once_:
  00487	8b 44 9a 04	 mov	 eax, DWORD PTR [rdx+rbx*4+4]
$LN107@scan_once_:
  0048b	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  0048e	0f 85 4c 02 00
	00		 jne	 $LN1@scan_once_
  00494	41 83 f8 01	 cmp	 r8d, 1
  00498	75 07		 jne	 SHORT $LN112@scan_once_
  0049a	0f b6 44 1a 02	 movzx	 eax, BYTE PTR [rdx+rbx+2]
  0049f	eb 11		 jmp	 SHORT $LN111@scan_once_
$LN112@scan_once_:
  004a1	41 83 f8 02	 cmp	 r8d, 2
  004a5	75 07		 jne	 SHORT $LN110@scan_once_
  004a7	0f b7 44 5a 04	 movzx	 eax, WORD PTR [rdx+rbx*2+4]
  004ac	eb 04		 jmp	 SHORT $LN111@scan_once_
$LN110@scan_once_:
  004ae	8b 44 9a 08	 mov	 eax, DWORD PTR [rdx+rbx*4+8]
$LN111@scan_once_:
  004b2	83 f8 66	 cmp	 eax, 102		; 00000066H
  004b5	0f 85 25 02 00
	00		 jne	 $LN1@scan_once_
  004bb	41 83 f8 01	 cmp	 r8d, 1
  004bf	75 07		 jne	 SHORT $LN116@scan_once_
  004c1	0f b6 44 1a 03	 movzx	 eax, BYTE PTR [rdx+rbx+3]
  004c6	eb 11		 jmp	 SHORT $LN115@scan_once_
$LN116@scan_once_:
  004c8	41 83 f8 02	 cmp	 r8d, 2
  004cc	75 07		 jne	 SHORT $LN114@scan_once_
  004ce	0f b7 44 5a 06	 movzx	 eax, WORD PTR [rdx+rbx*2+6]
  004d3	eb 04		 jmp	 SHORT $LN115@scan_once_
$LN114@scan_once_:
  004d5	8b 44 9a 0c	 mov	 eax, DWORD PTR [rdx+rbx*4+12]
$LN115@scan_once_:
  004d9	83 f8 69	 cmp	 eax, 105		; 00000069H
  004dc	0f 85 fe 01 00
	00		 jne	 $LN1@scan_once_
  004e2	41 83 f8 01	 cmp	 r8d, 1
  004e6	75 07		 jne	 SHORT $LN120@scan_once_
  004e8	0f b6 44 1a 04	 movzx	 eax, BYTE PTR [rdx+rbx+4]
  004ed	eb 11		 jmp	 SHORT $LN119@scan_once_
$LN120@scan_once_:
  004ef	41 83 f8 02	 cmp	 r8d, 2
  004f3	75 07		 jne	 SHORT $LN118@scan_once_
  004f5	0f b7 44 5a 08	 movzx	 eax, WORD PTR [rdx+rbx*2+8]
  004fa	eb 04		 jmp	 SHORT $LN119@scan_once_
$LN118@scan_once_:
  004fc	8b 44 9a 10	 mov	 eax, DWORD PTR [rdx+rbx*4+16]
$LN119@scan_once_:
  00500	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  00503	0f 85 d7 01 00
	00		 jne	 $LN1@scan_once_
  00509	41 83 f8 01	 cmp	 r8d, 1
  0050d	75 07		 jne	 SHORT $LN124@scan_once_
  0050f	0f b6 44 1a 05	 movzx	 eax, BYTE PTR [rdx+rbx+5]
  00514	eb 11		 jmp	 SHORT $LN123@scan_once_
$LN124@scan_once_:
  00516	41 83 f8 02	 cmp	 r8d, 2
  0051a	75 07		 jne	 SHORT $LN122@scan_once_
  0051c	0f b7 44 5a 0a	 movzx	 eax, WORD PTR [rdx+rbx*2+10]
  00521	eb 04		 jmp	 SHORT $LN123@scan_once_
$LN122@scan_once_:
  00523	8b 44 9a 14	 mov	 eax, DWORD PTR [rdx+rbx*4+20]
$LN123@scan_once_:
  00527	83 f8 69	 cmp	 eax, 105		; 00000069H
  0052a	0f 85 b0 01 00
	00		 jne	 $LN1@scan_once_
  00530	41 83 f8 01	 cmp	 r8d, 1
  00534	75 07		 jne	 SHORT $LN128@scan_once_
  00536	0f b6 44 1a 06	 movzx	 eax, BYTE PTR [rdx+rbx+6]
  0053b	eb 11		 jmp	 SHORT $LN127@scan_once_
$LN128@scan_once_:
  0053d	41 83 f8 02	 cmp	 r8d, 2
  00541	75 07		 jne	 SHORT $LN126@scan_once_
  00543	0f b7 44 5a 0c	 movzx	 eax, WORD PTR [rdx+rbx*2+12]
  00548	eb 04		 jmp	 SHORT $LN127@scan_once_
$LN126@scan_once_:
  0054a	8b 44 9a 18	 mov	 eax, DWORD PTR [rdx+rbx*4+24]
$LN127@scan_once_:
  0054e	83 f8 74	 cmp	 eax, 116		; 00000074H
  00551	0f 85 89 01 00
	00		 jne	 $LN1@scan_once_
  00557	41 83 f8 01	 cmp	 r8d, 1
  0055b	75 07		 jne	 SHORT $LN132@scan_once_
  0055d	0f b6 44 1a 07	 movzx	 eax, BYTE PTR [rdx+rbx+7]
  00562	eb 0f		 jmp	 SHORT $LN131@scan_once_
$LN132@scan_once_:
  00564	41 83 f8 02	 cmp	 r8d, 2
  00568	75 06		 jne	 SHORT $LN130@scan_once_
  0056a	0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+rcx*2]
  0056e	eb 03		 jmp	 SHORT $LN131@scan_once_
$LN130@scan_once_:
  00570	8b 04 8a	 mov	 eax, DWORD PTR [rdx+rcx*4]
$LN131@scan_once_:
  00573	83 f8 79	 cmp	 eax, 121		; 00000079H
  00576	0f 85 64 01 00
	00		 jne	 $LN1@scan_once_

; 1048 :                 return _parse_constant(s, "Infinity", idx, next_idx_ptr);

  0057c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08KEBCLIFP@Infinity?$AA@
  00583	4c 8b ce	 mov	 r9, rsi
  00586	4c 8b c3	 mov	 r8, rbx
  00589	48 8b cd	 mov	 rcx, rbp
  0058c	e8 00 00 00 00	 call	 _parse_constant
  00591	e9 5b 01 00 00	 jmp	 $LN30@scan_once_
$LN2@scan_once_:

; 1049 :             }
; 1050 :             break;
; 1051 :         case '-':
; 1052 :             /* -Infinity */
; 1053 :             if ((idx + 8 < length) && PyUnicode_READ(kind, str, idx + 1) == 'I' &&
; 1054 :                 PyUnicode_READ(kind, str, idx + 2) == 'n' &&
; 1055 :                 PyUnicode_READ(kind, str, idx + 3) == 'f' &&
; 1056 :                 PyUnicode_READ(kind, str, idx + 4) == 'i' &&
; 1057 :                 PyUnicode_READ(kind, str, idx + 5) == 'n' &&
; 1058 :                 PyUnicode_READ(kind, str, idx + 6) == 'i' &&
; 1059 :                 PyUnicode_READ(kind, str, idx + 7) == 't' &&
; 1060 :                 PyUnicode_READ(kind, str, idx + 8) == 'y') {

  00596	48 8d 4b 08	 lea	 rcx, QWORD PTR [rbx+8]
  0059a	49 3b c9	 cmp	 rcx, r9
  0059d	0f 8d 3d 01 00
	00		 jge	 $LN1@scan_once_
  005a3	41 83 f8 01	 cmp	 r8d, 1
  005a7	75 07		 jne	 SHORT $LN136@scan_once_
  005a9	0f b6 44 1a 01	 movzx	 eax, BYTE PTR [rdx+rbx+1]
  005ae	eb 11		 jmp	 SHORT $LN135@scan_once_
$LN136@scan_once_:
  005b0	41 83 f8 02	 cmp	 r8d, 2
  005b4	75 07		 jne	 SHORT $LN134@scan_once_
  005b6	0f b7 44 5a 02	 movzx	 eax, WORD PTR [rdx+rbx*2+2]
  005bb	eb 04		 jmp	 SHORT $LN135@scan_once_
$LN134@scan_once_:
  005bd	8b 44 9a 04	 mov	 eax, DWORD PTR [rdx+rbx*4+4]
$LN135@scan_once_:
  005c1	83 f8 49	 cmp	 eax, 73			; 00000049H
  005c4	0f 85 16 01 00
	00		 jne	 $LN1@scan_once_
  005ca	41 83 f8 01	 cmp	 r8d, 1
  005ce	75 07		 jne	 SHORT $LN140@scan_once_
  005d0	0f b6 44 1a 02	 movzx	 eax, BYTE PTR [rdx+rbx+2]
  005d5	eb 11		 jmp	 SHORT $LN139@scan_once_
$LN140@scan_once_:
  005d7	41 83 f8 02	 cmp	 r8d, 2
  005db	75 07		 jne	 SHORT $LN138@scan_once_
  005dd	0f b7 44 5a 04	 movzx	 eax, WORD PTR [rdx+rbx*2+4]
  005e2	eb 04		 jmp	 SHORT $LN139@scan_once_
$LN138@scan_once_:
  005e4	8b 44 9a 08	 mov	 eax, DWORD PTR [rdx+rbx*4+8]
$LN139@scan_once_:
  005e8	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  005eb	0f 85 ef 00 00
	00		 jne	 $LN1@scan_once_
  005f1	41 83 f8 01	 cmp	 r8d, 1
  005f5	75 07		 jne	 SHORT $LN144@scan_once_
  005f7	0f b6 44 1a 03	 movzx	 eax, BYTE PTR [rdx+rbx+3]
  005fc	eb 11		 jmp	 SHORT $LN143@scan_once_
$LN144@scan_once_:
  005fe	41 83 f8 02	 cmp	 r8d, 2
  00602	75 07		 jne	 SHORT $LN142@scan_once_
  00604	0f b7 44 5a 06	 movzx	 eax, WORD PTR [rdx+rbx*2+6]
  00609	eb 04		 jmp	 SHORT $LN143@scan_once_
$LN142@scan_once_:
  0060b	8b 44 9a 0c	 mov	 eax, DWORD PTR [rdx+rbx*4+12]
$LN143@scan_once_:
  0060f	83 f8 66	 cmp	 eax, 102		; 00000066H
  00612	0f 85 c8 00 00
	00		 jne	 $LN1@scan_once_
  00618	41 83 f8 01	 cmp	 r8d, 1
  0061c	75 07		 jne	 SHORT $LN148@scan_once_
  0061e	0f b6 44 1a 04	 movzx	 eax, BYTE PTR [rdx+rbx+4]
  00623	eb 11		 jmp	 SHORT $LN147@scan_once_
$LN148@scan_once_:
  00625	41 83 f8 02	 cmp	 r8d, 2
  00629	75 07		 jne	 SHORT $LN146@scan_once_
  0062b	0f b7 44 5a 08	 movzx	 eax, WORD PTR [rdx+rbx*2+8]
  00630	eb 04		 jmp	 SHORT $LN147@scan_once_
$LN146@scan_once_:
  00632	8b 44 9a 10	 mov	 eax, DWORD PTR [rdx+rbx*4+16]
$LN147@scan_once_:
  00636	83 f8 69	 cmp	 eax, 105		; 00000069H
  00639	0f 85 a1 00 00
	00		 jne	 $LN1@scan_once_
  0063f	41 83 f8 01	 cmp	 r8d, 1
  00643	75 07		 jne	 SHORT $LN152@scan_once_
  00645	0f b6 44 1a 05	 movzx	 eax, BYTE PTR [rdx+rbx+5]
  0064a	eb 11		 jmp	 SHORT $LN151@scan_once_
$LN152@scan_once_:
  0064c	41 83 f8 02	 cmp	 r8d, 2
  00650	75 07		 jne	 SHORT $LN150@scan_once_
  00652	0f b7 44 5a 0a	 movzx	 eax, WORD PTR [rdx+rbx*2+10]
  00657	eb 04		 jmp	 SHORT $LN151@scan_once_
$LN150@scan_once_:
  00659	8b 44 9a 14	 mov	 eax, DWORD PTR [rdx+rbx*4+20]
$LN151@scan_once_:
  0065d	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  00660	75 7e		 jne	 SHORT $LN1@scan_once_
  00662	41 83 f8 01	 cmp	 r8d, 1
  00666	75 07		 jne	 SHORT $LN156@scan_once_
  00668	0f b6 44 1a 06	 movzx	 eax, BYTE PTR [rdx+rbx+6]
  0066d	eb 11		 jmp	 SHORT $LN155@scan_once_
$LN156@scan_once_:
  0066f	41 83 f8 02	 cmp	 r8d, 2
  00673	75 07		 jne	 SHORT $LN154@scan_once_
  00675	0f b7 44 5a 0c	 movzx	 eax, WORD PTR [rdx+rbx*2+12]
  0067a	eb 04		 jmp	 SHORT $LN155@scan_once_
$LN154@scan_once_:
  0067c	8b 44 9a 18	 mov	 eax, DWORD PTR [rdx+rbx*4+24]
$LN155@scan_once_:
  00680	83 f8 69	 cmp	 eax, 105		; 00000069H
  00683	75 5b		 jne	 SHORT $LN1@scan_once_
  00685	41 83 f8 01	 cmp	 r8d, 1
  00689	75 07		 jne	 SHORT $LN160@scan_once_
  0068b	0f b6 44 1a 07	 movzx	 eax, BYTE PTR [rdx+rbx+7]
  00690	eb 11		 jmp	 SHORT $LN159@scan_once_
$LN160@scan_once_:
  00692	41 83 f8 02	 cmp	 r8d, 2
  00696	75 07		 jne	 SHORT $LN158@scan_once_
  00698	0f b7 44 5a 0e	 movzx	 eax, WORD PTR [rdx+rbx*2+14]
  0069d	eb 04		 jmp	 SHORT $LN159@scan_once_
$LN158@scan_once_:
  0069f	8b 44 9a 1c	 mov	 eax, DWORD PTR [rdx+rbx*4+28]
$LN159@scan_once_:
  006a3	83 f8 74	 cmp	 eax, 116		; 00000074H
  006a6	75 38		 jne	 SHORT $LN1@scan_once_
  006a8	41 83 f8 01	 cmp	 r8d, 1
  006ac	75 07		 jne	 SHORT $LN164@scan_once_
  006ae	0f b6 44 1a 08	 movzx	 eax, BYTE PTR [rdx+rbx+8]
  006b3	eb 0f		 jmp	 SHORT $LN163@scan_once_
$LN164@scan_once_:
  006b5	41 83 f8 02	 cmp	 r8d, 2
  006b9	75 06		 jne	 SHORT $LN162@scan_once_
  006bb	0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+rcx*2]
  006bf	eb 03		 jmp	 SHORT $LN163@scan_once_
$LN162@scan_once_:
  006c1	8b 04 8a	 mov	 eax, DWORD PTR [rdx+rcx*4]
$LN163@scan_once_:
  006c4	83 f8 79	 cmp	 eax, 121		; 00000079H
  006c7	75 17		 jne	 SHORT $LN1@scan_once_

; 1061 :                 return _parse_constant(s, "-Infinity", idx, next_idx_ptr);

  006c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09BLDCEMOH@?9Infinity?$AA@
  006d0	4c 8b ce	 mov	 r9, rsi
  006d3	4c 8b c3	 mov	 r8, rbx
  006d6	48 8b cd	 mov	 rcx, rbp
  006d9	e8 00 00 00 00	 call	 _parse_constant
  006de	eb 11		 jmp	 SHORT $LN30@scan_once_
$LN1@scan_once_:

; 1062 :             }
; 1063 :             break;
; 1064 :     }
; 1065 :     /* Didn't find a string, object, array, or named constant. Look for a number. */
; 1066 :     return _match_number_unicode(s, pystr, idx, next_idx_ptr);

  006e0	4c 8b ce	 mov	 r9, rsi
  006e3	4c 8b c3	 mov	 r8, rbx
  006e6	48 8b d7	 mov	 rdx, rdi
  006e9	48 8b cd	 mov	 rcx, rbp
  006ec	e8 00 00 00 00	 call	 _match_number_unicode
$LN30@scan_once_:

; 1067 : }

  006f1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  006f6	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  006fb	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00700	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00704	5f		 pop	 rdi
  00705	c3		 ret	 0
  00706	66 90		 npad	 2
$LN167@scan_once_:
  00708	00 00 00 00	 DD	 $LN25@scan_once_
  0070c	00 00 00 00	 DD	 $LN2@scan_once_
  00710	00 00 00 00	 DD	 $LN4@scan_once_
  00714	00 00 00 00	 DD	 $LN6@scan_once_
  00718	00 00 00 00	 DD	 $LN18@scan_once_
  0071c	00 00 00 00	 DD	 $LN8@scan_once_
  00720	00 00 00 00	 DD	 $LN12@scan_once_
  00724	00 00 00 00	 DD	 $LN10@scan_once_
  00728	00 00 00 00	 DD	 $LN24@scan_once_
  0072c	00 00 00 00	 DD	 $LN1@scan_once_
$LN166@scan_once_:
  00730	00		 DB	 0
  00731	09		 DB	 9
  00732	09		 DB	 9
  00733	09		 DB	 9
  00734	09		 DB	 9
  00735	09		 DB	 9
  00736	09		 DB	 9
  00737	09		 DB	 9
  00738	09		 DB	 9
  00739	09		 DB	 9
  0073a	09		 DB	 9
  0073b	01		 DB	 1
  0073c	09		 DB	 9
  0073d	09		 DB	 9
  0073e	09		 DB	 9
  0073f	09		 DB	 9
  00740	09		 DB	 9
  00741	09		 DB	 9
  00742	09		 DB	 9
  00743	09		 DB	 9
  00744	09		 DB	 9
  00745	09		 DB	 9
  00746	09		 DB	 9
  00747	09		 DB	 9
  00748	09		 DB	 9
  00749	09		 DB	 9
  0074a	09		 DB	 9
  0074b	09		 DB	 9
  0074c	09		 DB	 9
  0074d	09		 DB	 9
  0074e	09		 DB	 9
  0074f	09		 DB	 9
  00750	09		 DB	 9
  00751	09		 DB	 9
  00752	09		 DB	 9
  00753	09		 DB	 9
  00754	09		 DB	 9
  00755	09		 DB	 9
  00756	09		 DB	 9
  00757	02		 DB	 2
  00758	09		 DB	 9
  00759	09		 DB	 9
  0075a	09		 DB	 9
  0075b	09		 DB	 9
  0075c	03		 DB	 3
  0075d	09		 DB	 9
  0075e	09		 DB	 9
  0075f	09		 DB	 9
  00760	09		 DB	 9
  00761	09		 DB	 9
  00762	09		 DB	 9
  00763	09		 DB	 9
  00764	09		 DB	 9
  00765	09		 DB	 9
  00766	09		 DB	 9
  00767	09		 DB	 9
  00768	09		 DB	 9
  00769	04		 DB	 4
  0076a	09		 DB	 9
  0076b	09		 DB	 9
  0076c	09		 DB	 9
  0076d	09		 DB	 9
  0076e	09		 DB	 9
  0076f	09		 DB	 9
  00770	09		 DB	 9
  00771	09		 DB	 9
  00772	09		 DB	 9
  00773	09		 DB	 9
  00774	05		 DB	 5
  00775	09		 DB	 9
  00776	09		 DB	 9
  00777	09		 DB	 9
  00778	09		 DB	 9
  00779	09		 DB	 9
  0077a	09		 DB	 9
  0077b	09		 DB	 9
  0077c	06		 DB	 6
  0077d	09		 DB	 9
  0077e	09		 DB	 9
  0077f	09		 DB	 9
  00780	09		 DB	 9
  00781	09		 DB	 9
  00782	07		 DB	 7
  00783	09		 DB	 9
  00784	09		 DB	 9
  00785	09		 DB	 9
  00786	09		 DB	 9
  00787	09		 DB	 9
  00788	09		 DB	 9
  00789	08		 DB	 8
scan_once_unicode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@EOFNMIFD@OO?$CG?3scan_once?$AA@	; `string'
EXTRN	PyDict_Clear:PROC
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$scanner_call DD imagerel scanner_call
	DD	imagerel scanner_call+120
	DD	imagerel $unwind$scanner_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$scanner_call DD imagerel scanner_call+120
	DD	imagerel scanner_call+163
	DD	imagerel $chain$0$scanner_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$scanner_call DD imagerel scanner_call+163
	DD	imagerel scanner_call+187
	DD	imagerel $chain$2$scanner_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$scanner_call DD imagerel scanner_call+187
	DD	imagerel scanner_call+218
	DD	imagerel $chain$3$scanner_call
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$scanner_call DD 021H
	DD	imagerel scanner_call
	DD	imagerel scanner_call+120
	DD	imagerel $unwind$scanner_call
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$scanner_call DD 020021H
	DD	0d3400H
	DD	imagerel scanner_call
	DD	imagerel scanner_call+120
	DD	imagerel $unwind$scanner_call
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$scanner_call DD 020521H
	DD	0d3405H
	DD	imagerel scanner_call
	DD	imagerel scanner_call+120
	DD	imagerel $unwind$scanner_call
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scanner_call DD 020601H
	DD	070029206H
xdata	ENDS
;	COMDAT ??_C@_0O@EOFNMIFD@OO?$CG?3scan_once?$AA@
CONST	SEGMENT
??_C@_0O@EOFNMIFD@OO?$CG?3scan_once?$AA@ DB 'OO&:scan_once', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT scanner_call
_TEXT	SEGMENT
idx$ = 64
next_idx$ = 96
self$ = 96
args$ = 104
kwds$ = 112
pystr$ = 120
scanner_call PROC					; COMDAT

; 1071 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 8b f9	 mov	 rdi, rcx
  00009	49 8b c0	 mov	 rax, r8
  0000c	4c 8b d2	 mov	 r10, rdx

; 1072 :     /* Python callable interface to scan_once_{str,unicode} */
; 1073 :     PyObject *pystr;
; 1074 :     PyObject *rval;
; 1075 :     Py_ssize_t idx;
; 1076 :     Py_ssize_t next_idx = -1;
; 1077 :     static char *kwlist[] = {"string", "idx", NULL};
; 1078 :     PyScannerObject *s;
; 1079 :     assert(PyScanner_Check(self));
; 1080 :     s = (PyScannerObject *)self;
; 1081 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO&:scan_once", kwlist, &pystr, _convertPyInt_AsSsize_t, &idx))

  0000f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR idx$[rsp]
  00014	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??scanner_call@@9@9
  0001b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@EOFNMIFD@OO?$CG?3scan_once?$AA@
  00022	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_convertPyInt_AsSsize_t
  0002e	48 8b d0	 mov	 rdx, rax
  00031	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00036	48 8d 4c 24 78	 lea	 rcx, QWORD PTR pystr$[rsp]
  0003b	48 c7 44 24 60
	ff ff ff ff	 mov	 QWORD PTR next_idx$[rsp], -1
  00044	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00049	49 8b ca	 mov	 rcx, r10
  0004c	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00051	85 c0		 test	 eax, eax

; 1082 :         return NULL;

  00053	74 7d		 je	 SHORT $LN8@scanner_ca

; 1083 : 
; 1084 :     if (PyUnicode_Check(pystr)) {

  00055	48 8b 54 24 78	 mov	 rdx, QWORD PTR pystr$[rsp]
  0005a	4c 8b 42 58	 mov	 r8, QWORD PTR [rdx+88]
  0005e	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  00069	74 50		 je	 SHORT $LN3@scanner_ca

; 1085 :         rval = scan_once_unicode(s, pystr, idx, &next_idx);

  0006b	4c 8b 44 24 40	 mov	 r8, QWORD PTR idx$[rsp]
  00070	4c 8d 4c 24 60	 lea	 r9, QWORD PTR next_idx$[rsp]
  00075	48 8b cf	 mov	 rcx, rdi
  00078	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx
  0007d	e8 00 00 00 00	 call	 scan_once_unicode

; 1092 :     }
; 1093 :     PyDict_Clear(s->memo);

  00082	48 8b 8f 90 00
	00 00		 mov	 rcx, QWORD PTR [rdi+144]
  00089	48 8b d8	 mov	 rbx, rax
  0008c	e8 00 00 00 00	 call	 PyDict_Clear

; 1094 :     if (rval == NULL)

  00091	48 85 db	 test	 rbx, rbx
  00094	75 0d		 jne	 SHORT $LN1@scanner_ca

; 1095 :         return NULL;

  00096	33 c0		 xor	 eax, eax
  00098	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]

; 1097 : }

  0009d	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000a1	5f		 pop	 rdi
  000a2	c3		 ret	 0
$LN1@scanner_ca:

; 1096 :     return _build_rval_index_tuple(rval, next_idx);

  000a3	48 8b 54 24 60	 mov	 rdx, QWORD PTR next_idx$[rsp]
  000a8	48 8b cb	 mov	 rcx, rbx
  000ab	e8 00 00 00 00	 call	 _build_rval_index_tuple
  000b0	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]

; 1097 : }

  000b5	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000b9	5f		 pop	 rdi
  000ba	c3		 ret	 0
$LN3@scanner_ca:

; 1086 :     }
; 1087 :     else {
; 1088 :         PyErr_Format(PyExc_TypeError,
; 1089 :                  "first argument must be a string, not %.80s",
; 1090 :                  Py_TYPE(pystr)->tp_name);

  000bb	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@OIEJEOOL@first?5argument?5must?5be?5a?5string?0@
  000cd	e8 00 00 00 00	 call	 PyErr_Format
$LN8@scanner_ca:

; 1091 :         return NULL;

  000d2	33 c0		 xor	 eax, eax

; 1097 : }

  000d4	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000d8	5f		 pop	 rdi
  000d9	c3		 ret	 0
scanner_call ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$scanner_new DD imagerel scanner_new
	DD	imagerel scanner_new+57
	DD	imagerel $unwind$scanner_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scanner_new DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT scanner_new
_TEXT	SEGMENT
type$ = 48
args$ = 56
kwds$ = 64
scanner_new PROC					; COMDAT

; 1101 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b c1	 mov	 rax, rcx

; 1102 :     PyScannerObject *s;
; 1103 :     s = (PyScannerObject *)type->tp_alloc(type, 0);

  00007	33 d2		 xor	 edx, edx
  00009	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]

; 1104 :     if (s != NULL) {

  0000f	48 85 c0	 test	 rax, rax
  00012	74 20		 je	 SHORT $LN4@scanner_ne

; 1105 :         s->strict = NULL;

  00014	33 c9		 xor	 ecx, ecx
  00016	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 1106 :         s->object_hook = NULL;

  0001a	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 1107 :         s->object_pairs_hook = NULL;

  0001e	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 1108 :         s->parse_float = NULL;

  00022	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 1109 :         s->parse_int = NULL;

  00026	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 1110 :         s->parse_constant = NULL;

  0002d	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx
$LN4@scanner_ne:

; 1111 :     }
; 1112 :     return (PyObject *)s;
; 1113 : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
scanner_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@DPAGDMGM@scanner_init?$AA@		; `string'
PUBLIC	??_C@_0P@CJIBFHCI@O?3make_scanner?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$scanner_init DD imagerel scanner_init
	DD	imagerel scanner_init+267
	DD	imagerel $unwind$scanner_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$scanner_init DD imagerel scanner_init+267
	DD	imagerel scanner_init+647
	DD	imagerel $chain$0$scanner_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$scanner_init DD imagerel scanner_init+647
	DD	imagerel scanner_init+656
	DD	imagerel $chain$1$scanner_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$scanner_init DD 021H
	DD	imagerel scanner_init
	DD	imagerel scanner_init+267
	DD	imagerel $unwind$scanner_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$scanner_init DD 020521H
	DD	097405H
	DD	imagerel scanner_init
	DD	imagerel scanner_init+267
	DD	imagerel $unwind$scanner_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scanner_init DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0N@DPAGDMGM@scanner_init?$AA@
CONST	SEGMENT
??_C@_0N@DPAGDMGM@scanner_init?$AA@ DB 'scanner_init', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CJIBFHCI@O?3make_scanner?$AA@
CONST	SEGMENT
??_C@_0P@CJIBFHCI@O?3make_scanner?$AA@ DB 'O:make_scanner', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT scanner_init
_TEXT	SEGMENT
ctx$ = 64
self$ = 64
args$ = 72
kwds$ = 80
scanner_init PROC					; COMDAT

; 1117 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	49 8b c0	 mov	 rax, r8
  0000c	4c 8b d2	 mov	 r10, rdx

; 1118 :     /* Initialize Scanner object */
; 1119 :     PyObject *ctx;
; 1120 :     static char *kwlist[] = {"context", NULL};
; 1121 :     PyScannerObject *s;
; 1122 : 
; 1123 :     assert(PyScanner_Check(self));
; 1124 :     s = (PyScannerObject *)self;
; 1125 : 
; 1126 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O:make_scanner", kwlist, &ctx))

  0000f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ctx$[rsp]
  00014	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??scanner_init@@9@9
  0001b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0P@CJIBFHCI@O?3make_scanner?$AA@
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	49 8b ca	 mov	 rcx, r10
  0002a	48 8b d0	 mov	 rdx, rax
  0002d	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00032	85 c0		 test	 eax, eax

; 1127 :         return -1;

  00034	0f 84 4d 02 00
	00		 je	 $LN36@scanner_in

; 1128 : 
; 1129 :     if (s->memo == NULL) {

  0003a	48 83 bb 90 00
	00 00 00	 cmp	 QWORD PTR [rbx+144], 0
  00042	75 15		 jne	 SHORT $LN31@scanner_in

; 1130 :         s->memo = PyDict_New();

  00044	e8 00 00 00 00	 call	 PyDict_New
  00049	48 89 83 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rax

; 1131 :         if (s->memo == NULL)

  00050	48 85 c0	 test	 rax, rax
  00053	0f 84 ae 00 00
	00		 je	 $bail$21872
$LN31@scanner_in:

; 1132 :             goto bail;
; 1133 :     }
; 1134 : 
; 1135 :     /* All of these will fail "gracefully" so we don't need to verify them */
; 1136 :     s->strict = PyObject_GetAttrString(ctx, "strict");

  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ctx$[rsp]
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  00065	e8 00 00 00 00	 call	 PyObject_GetAttrString
  0006a	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 1137 :     if (s->strict == NULL)

  0006e	48 85 c0	 test	 rax, rax
  00071	0f 84 90 00 00
	00		 je	 $bail$21872

; 1138 :         goto bail;
; 1139 :     s->object_hook = PyObject_GetAttrString(ctx, "object_hook");

  00077	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ctx$[rsp]
  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@LCHLLJKI@object_hook?$AA@
  00083	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00088	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax

; 1140 :     if (s->object_hook == NULL)

  0008c	48 85 c0	 test	 rax, rax
  0008f	74 76		 je	 SHORT $bail$21872

; 1141 :         goto bail;
; 1142 :     s->object_pairs_hook = PyObject_GetAttrString(ctx, "object_pairs_hook");

  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ctx$[rsp]
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@KHLDCHIO@object_pairs_hook?$AA@
  0009d	e8 00 00 00 00	 call	 PyObject_GetAttrString
  000a2	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 1143 :     if (s->object_pairs_hook == NULL)

  000a6	48 85 c0	 test	 rax, rax
  000a9	74 5c		 je	 SHORT $bail$21872

; 1144 :         goto bail;
; 1145 :     s->parse_float = PyObject_GetAttrString(ctx, "parse_float");

  000ab	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ctx$[rsp]
  000b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@KEFCOABD@parse_float?$AA@
  000b7	e8 00 00 00 00	 call	 PyObject_GetAttrString
  000bc	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 1146 :     if (s->parse_float == NULL)

  000c0	48 85 c0	 test	 rax, rax
  000c3	74 42		 je	 SHORT $bail$21872

; 1147 :         goto bail;
; 1148 :     s->parse_int = PyObject_GetAttrString(ctx, "parse_int");

  000c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ctx$[rsp]
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09DPJPPPAP@parse_int?$AA@
  000d1	e8 00 00 00 00	 call	 PyObject_GetAttrString
  000d6	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax

; 1149 :     if (s->parse_int == NULL)

  000dd	48 85 c0	 test	 rax, rax
  000e0	74 25		 je	 SHORT $bail$21872

; 1150 :         goto bail;
; 1151 :     s->parse_constant = PyObject_GetAttrString(ctx, "parse_constant");

  000e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ctx$[rsp]
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@GDIKPOIP@parse_constant?$AA@
  000ee	e8 00 00 00 00	 call	 PyObject_GetAttrString
  000f3	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 1152 :     if (s->parse_constant == NULL)

  000fa	48 85 c0	 test	 rax, rax
  000fd	74 08		 je	 SHORT $bail$21872

; 1153 :         goto bail;
; 1154 : 
; 1155 :     return 0;

  000ff	33 c0		 xor	 eax, eax

; 1165 : }

  00101	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00105	5b		 pop	 rbx
  00106	c3		 ret	 0
$bail$21872:

; 1156 : 
; 1157 : bail:
; 1158 :     Py_CLEAR(s->strict);

  00107	4c 8b 4b 60	 mov	 r9, QWORD PTR [rbx+96]
  0010b	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00110	33 ff		 xor	 edi, edi
  00112	4d 85 c9	 test	 r9, r9
  00115	74 32		 je	 SHORT $LN23@scanner_in
  00117	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  0011e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@DPAGDMGM@scanner_init?$AA@
  00125	41 b8 86 04 00
	00		 mov	 r8d, 1158		; 00000486H
  0012b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00133	e8 00 00 00 00	 call	 _PyParallel_Guard
  00138	85 c0		 test	 eax, eax
  0013a	75 0d		 jne	 SHORT $LN23@scanner_in
  0013c	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00140	48 89 7b 60	 mov	 QWORD PTR [rbx+96], rdi
  00144	e8 00 00 00 00	 call	 _Py_DecRef
$LN23@scanner_in:

; 1159 :     Py_CLEAR(s->object_hook);

  00149	4c 8b 4b 68	 mov	 r9, QWORD PTR [rbx+104]
  0014d	4d 85 c9	 test	 r9, r9
  00150	74 32		 je	 SHORT $LN19@scanner_in
  00152	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@DPAGDMGM@scanner_init?$AA@
  00160	41 b8 87 04 00
	00		 mov	 r8d, 1159		; 00000487H
  00166	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0016e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00173	85 c0		 test	 eax, eax
  00175	75 0d		 jne	 SHORT $LN19@scanner_in
  00177	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  0017b	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi
  0017f	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@scanner_in:

; 1160 :     Py_CLEAR(s->object_pairs_hook);

  00184	4c 8b 4b 70	 mov	 r9, QWORD PTR [rbx+112]
  00188	4d 85 c9	 test	 r9, r9
  0018b	74 32		 je	 SHORT $LN15@scanner_in
  0018d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@DPAGDMGM@scanner_init?$AA@
  0019b	41 b8 88 04 00
	00		 mov	 r8d, 1160		; 00000488H
  001a1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001a9	e8 00 00 00 00	 call	 _PyParallel_Guard
  001ae	85 c0		 test	 eax, eax
  001b0	75 0d		 jne	 SHORT $LN15@scanner_in
  001b2	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  001b6	48 89 7b 70	 mov	 QWORD PTR [rbx+112], rdi
  001ba	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@scanner_in:

; 1161 :     Py_CLEAR(s->parse_float);

  001bf	4c 8b 4b 78	 mov	 r9, QWORD PTR [rbx+120]
  001c3	4d 85 c9	 test	 r9, r9
  001c6	74 32		 je	 SHORT $LN11@scanner_in
  001c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  001cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@DPAGDMGM@scanner_init?$AA@
  001d6	41 b8 89 04 00
	00		 mov	 r8d, 1161		; 00000489H
  001dc	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001e4	e8 00 00 00 00	 call	 _PyParallel_Guard
  001e9	85 c0		 test	 eax, eax
  001eb	75 0d		 jne	 SHORT $LN11@scanner_in
  001ed	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  001f1	48 89 7b 78	 mov	 QWORD PTR [rbx+120], rdi
  001f5	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@scanner_in:

; 1162 :     Py_CLEAR(s->parse_int);

  001fa	4c 8b 8b 80 00
	00 00		 mov	 r9, QWORD PTR [rbx+128]
  00201	4d 85 c9	 test	 r9, r9
  00204	74 38		 je	 SHORT $LN7@scanner_in
  00206	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  0020d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@DPAGDMGM@scanner_init?$AA@
  00214	41 b8 8a 04 00
	00		 mov	 r8d, 1162		; 0000048aH
  0021a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00222	e8 00 00 00 00	 call	 _PyParallel_Guard
  00227	85 c0		 test	 eax, eax
  00229	75 13		 jne	 SHORT $LN7@scanner_in
  0022b	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00232	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi
  00239	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@scanner_in:

; 1163 :     Py_CLEAR(s->parse_constant);

  0023e	4c 8b 8b 88 00
	00 00		 mov	 r9, QWORD PTR [rbx+136]
  00245	4d 85 c9	 test	 r9, r9
  00248	74 38		 je	 SHORT $LN3@scanner_in
  0024a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00251	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@DPAGDMGM@scanner_init?$AA@
  00258	41 b8 8b 04 00
	00		 mov	 r8d, 1163		; 0000048bH
  0025e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00266	e8 00 00 00 00	 call	 _PyParallel_Guard
  0026b	85 c0		 test	 eax, eax
  0026d	75 13		 jne	 SHORT $LN3@scanner_in
  0026f	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
  00276	48 89 bb 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rdi
  0027d	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@scanner_in:
  00282	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
$LN36@scanner_in:

; 1164 :     return -1;

  00287	83 c8 ff	 or	 eax, -1

; 1165 : }

  0028a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0028e	5b		 pop	 rbx
  0028f	c3		 ret	 0
scanner_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$encoder_new DD imagerel encoder_new
	DD	imagerel encoder_new+71
	DD	imagerel $unwind$encoder_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encoder_new DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT encoder_new
_TEXT	SEGMENT
type$ = 48
args$ = 56
kwds$ = 64
encoder_new PROC					; COMDAT

; 1214 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b c1	 mov	 rax, rcx

; 1215 :     PyEncoderObject *s;
; 1216 :     s = (PyEncoderObject *)type->tp_alloc(type, 0);

  00007	33 d2		 xor	 edx, edx
  00009	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]

; 1217 :     if (s != NULL) {

  0000f	48 85 c0	 test	 rax, rax
  00012	74 2e		 je	 SHORT $LN4@encoder_ne

; 1218 :         s->markers = NULL;

  00014	33 c9		 xor	 ecx, ecx
  00016	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 1219 :         s->defaultfn = NULL;

  0001a	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 1220 :         s->encoder = NULL;

  0001e	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 1221 :         s->indent = NULL;

  00022	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 1222 :         s->key_separator = NULL;

  00026	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 1223 :         s->item_separator = NULL;

  0002d	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 1224 :         s->sort_keys = NULL;

  00034	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 1225 :         s->skipkeys = NULL;

  0003b	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx
$LN4@encoder_ne:

; 1226 :     }
; 1227 :     return (PyObject *)s;
; 1228 : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
encoder_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@KFFMMDOA@OOOOOOOOO?3make_encoder?$AA@	; `string'
EXTRN	PyCFunction_GetFunction:PROC
EXTRN	PyCFunction_Type:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$encoder_init DD imagerel encoder_init
	DD	imagerel encoder_init+149
	DD	imagerel $unwind$encoder_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$encoder_init DD imagerel encoder_init+149
	DD	imagerel encoder_init+784
	DD	imagerel $chain$0$encoder_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$encoder_init DD imagerel encoder_init+784
	DD	imagerel encoder_init+845
	DD	imagerel $chain$1$encoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$encoder_init DD 021H
	DD	imagerel encoder_init
	DD	imagerel encoder_init+149
	DD	imagerel $unwind$encoder_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$encoder_init DD 020821H
	DD	0197408H
	DD	imagerel encoder_init
	DD	imagerel encoder_init+149
	DD	imagerel $unwind$encoder_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encoder_init DD 030b01H
	DD	016010bH
	DD	03004H
xdata	ENDS
;	COMDAT ??_C@_0BH@KFFMMDOA@OOOOOOOOO?3make_encoder?$AA@
CONST	SEGMENT
??_C@_0BH@KFFMMDOA@OOOOOOOOO?3make_encoder?$AA@ DB 'OOOOOOOOO:make_encode'
	DB	'r', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_json.c
CONST	ENDS
;	COMDAT encoder_init
_TEXT	SEGMENT
encoder$ = 112
indent$ = 120
key_separator$ = 128
item_separator$ = 136
sort_keys$ = 144
skipkeys$ = 152
allow_nan$ = 160
markers$ = 192
self$ = 192
args$ = 200
kwds$ = 208
defaultfn$ = 216
encoder_init PROC					; COMDAT

; 1232 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  0000b	48 8b d9	 mov	 rbx, rcx

; 1233 :     /* initialize Encoder object */
; 1234 :     static char *kwlist[] = {"markers", "default", "encoder", "indent", "key_separator", "item_separator", "sort_keys", "skipkeys", "allow_nan", NULL};
; 1235 : 
; 1236 :     PyEncoderObject *s;
; 1237 :     PyObject *markers, *defaultfn, *encoder, *indent, *key_separator;
; 1238 :     PyObject *item_separator, *sort_keys, *skipkeys, *allow_nan;
; 1239 : 
; 1240 :     assert(PyEncoder_Check(self));
; 1241 :     s = (PyEncoderObject *)self;
; 1242 : 
; 1243 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "OOOOOOOOO:make_encoder", kwlist,
; 1244 :         &markers, &defaultfn, &encoder, &indent, &key_separator, &item_separator,
; 1245 :         &sort_keys, &skipkeys, &allow_nan))

  0000e	49 8d 4b e8	 lea	 rcx, QWORD PTR [r11-24]
  00012	49 8b c0	 mov	 rax, r8
  00015	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  00019	49 8d 4b e0	 lea	 rcx, QWORD PTR [r11-32]
  0001d	4c 8b d2	 mov	 r10, rdx
  00020	49 89 4b a0	 mov	 QWORD PTR [r11-96], rcx
  00024	49 8d 4b d8	 lea	 rcx, QWORD PTR [r11-40]
  00028	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??encoder_init@@9@9
  0002f	49 89 4b 98	 mov	 QWORD PTR [r11-104], rcx
  00033	49 8d 4b d0	 lea	 rcx, QWORD PTR [r11-48]
  00037	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BH@KFFMMDOA@OOOOOOOOO?3make_encoder?$AA@
  0003e	49 89 4b 90	 mov	 QWORD PTR [r11-112], rcx
  00042	49 8d 4b c8	 lea	 rcx, QWORD PTR [r11-56]
  00046	48 8b d0	 mov	 rdx, rax
  00049	49 89 4b 88	 mov	 QWORD PTR [r11-120], rcx
  0004d	49 8d 4b c0	 lea	 rcx, QWORD PTR [r11-64]
  00051	49 89 4b 80	 mov	 QWORD PTR [r11-128], rcx
  00055	49 8d 4b b8	 lea	 rcx, QWORD PTR [r11-72]
  00059	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005e	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00062	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00067	49 8d 4b 08	 lea	 rcx, QWORD PTR [r11+8]
  0006b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00070	49 8b ca	 mov	 rcx, r10
  00073	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00078	85 c0		 test	 eax, eax
  0007a	75 0c		 jne	 SHORT $LN1@encoder_in

; 1246 :         return -1;

  0007c	83 c8 ff	 or	 eax, -1

; 1268 : }

  0007f	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  00086	5b		 pop	 rbx
  00087	c3		 ret	 0
$LN1@encoder_in:

; 1247 : 
; 1248 :     s->markers = markers;

  00088	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR markers$[rsp]

; 1249 :     s->defaultfn = defaultfn;
; 1250 :     s->encoder = encoder;

  00090	48 8b 4c 24 70	 mov	 rcx, QWORD PTR encoder$[rsp]
  00095	48 89 bc 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], rdi
  0009d	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax
  000a1	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR defaultfn$[rsp]
  000a9	48 89 4b 70	 mov	 QWORD PTR [rbx+112], rcx
  000ad	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax

; 1251 :     s->indent = indent;

  000b1	48 8b 44 24 78	 mov	 rax, QWORD PTR indent$[rsp]
  000b6	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 1252 :     s->key_separator = key_separator;

  000ba	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR key_separator$[rsp]
  000c2	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax

; 1253 :     s->item_separator = item_separator;

  000c9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR item_separator$[rsp]
  000d1	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 1254 :     s->sort_keys = sort_keys;

  000d8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sort_keys$[rsp]
  000e0	48 89 83 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rax

; 1255 :     s->skipkeys = skipkeys;

  000e7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR skipkeys$[rsp]
  000ef	48 89 83 98 00
	00 00		 mov	 QWORD PTR [rbx+152], rax

; 1256 :     s->fast_encode = (PyCFunction_Check(s->encoder) && PyCFunction_GetFunction(s->encoder) == (PyCFunction)py_encode_basestring_ascii);

  000f6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyCFunction_Type
  000fd	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00101	75 18		 jne	 SHORT $LN4@encoder_in
  00103	e8 00 00 00 00	 call	 PyCFunction_GetFunction
  00108	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:py_encode_basestring_ascii
  0010f	48 3b c1	 cmp	 rax, rcx
  00112	75 07		 jne	 SHORT $LN4@encoder_in
  00114	b8 01 00 00 00	 mov	 eax, 1
  00119	eb 02		 jmp	 SHORT $LN5@encoder_in
$LN4@encoder_in:
  0011b	33 c0		 xor	 eax, eax
$LN5@encoder_in:

; 1257 :     s->allow_nan = PyObject_IsTrue(allow_nan);

  0011d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR allow_nan$[rsp]
  00125	89 83 a0 00 00
	00		 mov	 DWORD PTR [rbx+160], eax
  0012b	e8 00 00 00 00	 call	 PyObject_IsTrue

; 1258 : 
; 1259 :     Py_INCREF(s->markers);

  00130	48 8b 7b 60	 mov	 rdi, QWORD PTR [rbx+96]
  00134	89 83 a4 00 00
	00		 mov	 DWORD PTR [rbx+164], eax
  0013a	e8 00 00 00 00	 call	 _Py_PXCTX
  0013f	85 c0		 test	 eax, eax
  00141	75 32		 jne	 SHORT $LN7@encoder_in
  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00151	4c 8b cf	 mov	 r9, rdi
  00154	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0015a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00162	e8 00 00 00 00	 call	 _PyParallel_Guard
  00167	85 c0		 test	 eax, eax
  00169	75 06		 jne	 SHORT $LN6@encoder_in
  0016b	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0016f	74 04		 je	 SHORT $LN7@encoder_in
$LN6@encoder_in:
  00171	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN7@encoder_in:

; 1260 :     Py_INCREF(s->defaultfn);

  00175	48 8b 7b 68	 mov	 rdi, QWORD PTR [rbx+104]
  00179	e8 00 00 00 00	 call	 _Py_PXCTX
  0017e	85 c0		 test	 eax, eax
  00180	75 32		 jne	 SHORT $LN11@encoder_in
  00182	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00190	4c 8b cf	 mov	 r9, rdi
  00193	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00199	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001a1	e8 00 00 00 00	 call	 _PyParallel_Guard
  001a6	85 c0		 test	 eax, eax
  001a8	75 06		 jne	 SHORT $LN10@encoder_in
  001aa	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  001ae	74 04		 je	 SHORT $LN11@encoder_in
$LN10@encoder_in:
  001b0	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN11@encoder_in:

; 1261 :     Py_INCREF(s->encoder);

  001b4	48 8b 7b 70	 mov	 rdi, QWORD PTR [rbx+112]
  001b8	e8 00 00 00 00	 call	 _Py_PXCTX
  001bd	85 c0		 test	 eax, eax
  001bf	75 32		 jne	 SHORT $LN15@encoder_in
  001c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  001cf	4c 8b cf	 mov	 r9, rdi
  001d2	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  001d8	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001e0	e8 00 00 00 00	 call	 _PyParallel_Guard
  001e5	85 c0		 test	 eax, eax
  001e7	75 06		 jne	 SHORT $LN14@encoder_in
  001e9	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  001ed	74 04		 je	 SHORT $LN15@encoder_in
$LN14@encoder_in:
  001ef	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN15@encoder_in:

; 1262 :     Py_INCREF(s->indent);

  001f3	48 8b 7b 78	 mov	 rdi, QWORD PTR [rbx+120]
  001f7	e8 00 00 00 00	 call	 _Py_PXCTX
  001fc	85 c0		 test	 eax, eax
  001fe	75 32		 jne	 SHORT $LN19@encoder_in
  00200	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00207	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0020e	4c 8b cf	 mov	 r9, rdi
  00211	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00217	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0021f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00224	85 c0		 test	 eax, eax
  00226	75 06		 jne	 SHORT $LN18@encoder_in
  00228	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0022c	74 04		 je	 SHORT $LN19@encoder_in
$LN18@encoder_in:
  0022e	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN19@encoder_in:

; 1263 :     Py_INCREF(s->key_separator);

  00232	48 8b bb 80 00
	00 00		 mov	 rdi, QWORD PTR [rbx+128]
  00239	e8 00 00 00 00	 call	 _Py_PXCTX
  0023e	85 c0		 test	 eax, eax
  00240	75 32		 jne	 SHORT $LN23@encoder_in
  00242	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00249	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00250	4c 8b cf	 mov	 r9, rdi
  00253	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00259	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00261	e8 00 00 00 00	 call	 _PyParallel_Guard
  00266	85 c0		 test	 eax, eax
  00268	75 06		 jne	 SHORT $LN22@encoder_in
  0026a	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0026e	74 04		 je	 SHORT $LN23@encoder_in
$LN22@encoder_in:
  00270	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN23@encoder_in:

; 1264 :     Py_INCREF(s->item_separator);

  00274	48 8b bb 88 00
	00 00		 mov	 rdi, QWORD PTR [rbx+136]
  0027b	e8 00 00 00 00	 call	 _Py_PXCTX
  00280	85 c0		 test	 eax, eax
  00282	75 32		 jne	 SHORT $LN27@encoder_in
  00284	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0028b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00292	4c 8b cf	 mov	 r9, rdi
  00295	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0029b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  002a3	e8 00 00 00 00	 call	 _PyParallel_Guard
  002a8	85 c0		 test	 eax, eax
  002aa	75 06		 jne	 SHORT $LN26@encoder_in
  002ac	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  002b0	74 04		 je	 SHORT $LN27@encoder_in
$LN26@encoder_in:
  002b2	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN27@encoder_in:

; 1265 :     Py_INCREF(s->sort_keys);

  002b6	48 8b bb 90 00
	00 00		 mov	 rdi, QWORD PTR [rbx+144]
  002bd	e8 00 00 00 00	 call	 _Py_PXCTX
  002c2	85 c0		 test	 eax, eax
  002c4	75 32		 jne	 SHORT $LN31@encoder_in
  002c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  002d4	4c 8b cf	 mov	 r9, rdi
  002d7	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  002dd	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  002e5	e8 00 00 00 00	 call	 _PyParallel_Guard
  002ea	85 c0		 test	 eax, eax
  002ec	75 06		 jne	 SHORT $LN30@encoder_in
  002ee	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  002f2	74 04		 je	 SHORT $LN31@encoder_in
$LN30@encoder_in:
  002f4	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN31@encoder_in:

; 1266 :     Py_INCREF(s->skipkeys);

  002f8	48 8b 9b 98 00
	00 00		 mov	 rbx, QWORD PTR [rbx+152]
  002ff	e8 00 00 00 00	 call	 _Py_PXCTX
  00304	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR [rsp+200]
  0030c	85 c0		 test	 eax, eax
  0030e	75 32		 jne	 SHORT $LN35@encoder_in
  00310	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00317	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0031e	4c 8b cb	 mov	 r9, rbx
  00321	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00327	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0032f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00334	85 c0		 test	 eax, eax
  00336	75 06		 jne	 SHORT $LN34@encoder_in
  00338	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0033c	74 04		 je	 SHORT $LN35@encoder_in
$LN34@encoder_in:
  0033e	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN35@encoder_in:

; 1267 :     return 0;

  00342	33 c0		 xor	 eax, eax

; 1268 : }

  00344	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  0034b	5b		 pop	 rbx
  0034c	c3		 ret	 0
encoder_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@HLNFKNCD@not?5a?5const?$AA@		; `string'
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
PUBLIC	??_C@_04MLLLIHIP@null?$AA@			; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_encoded_const DD imagerel _encoded_const
	DD	imagerel _encoded_const+333
	DD	imagerel $unwind$_encoded_const
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_encoded_const DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0M@HLNFKNCD@not?5a?5const?$AA@
CONST	SEGMENT
??_C@_0M@HLNFKNCD@not?5a?5const?$AA@ DB 'not a const', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLLLIHIP@null?$AA@
CONST	SEGMENT
??_C@_04MLLLIHIP@null?$AA@ DB 'null', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_json.c
CONST	ENDS
;	COMDAT _encoded_const
_TEXT	SEGMENT
obj$ = 64
_encoded_const PROC					; COMDAT

; 1296 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1297 :     /* Return the JSON string representation of None, True, False */
; 1298 :     if (obj == Py_None) {

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0000d	48 3b c8	 cmp	 rcx, rax
  00010	75 6a		 jne	 SHORT $LN9@encoded_co

; 1299 :         static PyObject *s_null = NULL;
; 1300 :         if (s_null == NULL) {

  00012	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?s_null@?2??_encoded_const@@9@9
  00019	48 85 db	 test	 rbx, rbx
  0001c	75 16		 jne	 SHORT $LN8@encoded_co

; 1301 :             s_null = PyUnicode_InternFromString("null");

  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04MLLLIHIP@null?$AA@
  00025	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0002a	48 8b d8	 mov	 rbx, rax
  0002d	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?s_null@?2??_encoded_const@@9@9, rax
$LN8@encoded_co:

; 1302 :         }
; 1303 :         Py_INCREF(s_null);

  00034	e8 00 00 00 00	 call	 _Py_PXCTX
  00039	85 c0		 test	 eax, eax
  0003b	75 32		 jne	 SHORT $LN13@encoded_co
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0004b	4c 8b cb	 mov	 r9, rbx
  0004e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00054	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0005c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00061	85 c0		 test	 eax, eax
  00063	75 06		 jne	 SHORT $LN12@encoded_co
  00065	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00069	74 04		 je	 SHORT $LN13@encoded_co
$LN12@encoded_co:
  0006b	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN13@encoded_co:

; 1304 :         return s_null;

  0006f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?s_null@?2??_encoded_const@@9@9

; 1325 :     }
; 1326 : }

  00076	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007a	5b		 pop	 rbx
  0007b	c3		 ret	 0
$LN9@encoded_co:

; 1305 :     }
; 1306 :     else if (obj == Py_True) {

  0007c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00083	48 3b c8	 cmp	 rcx, rax
  00086	75 6a		 jne	 SHORT $LN6@encoded_co

; 1307 :         static PyObject *s_true = NULL;
; 1308 :         if (s_true == NULL) {

  00088	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?s_true@?4??_encoded_const@@9@9
  0008f	48 85 db	 test	 rbx, rbx
  00092	75 16		 jne	 SHORT $LN5@encoded_co

; 1309 :             s_true = PyUnicode_InternFromString("true");

  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LOAJBDKD@true?$AA@
  0009b	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  000a0	48 8b d8	 mov	 rbx, rax
  000a3	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?s_true@?4??_encoded_const@@9@9, rax
$LN5@encoded_co:

; 1310 :         }
; 1311 :         Py_INCREF(s_true);

  000aa	e8 00 00 00 00	 call	 _Py_PXCTX
  000af	85 c0		 test	 eax, eax
  000b1	75 32		 jne	 SHORT $LN17@encoded_co
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000c1	4c 8b cb	 mov	 r9, rbx
  000c4	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000ca	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000d2	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d7	85 c0		 test	 eax, eax
  000d9	75 06		 jne	 SHORT $LN16@encoded_co
  000db	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000df	74 04		 je	 SHORT $LN17@encoded_co
$LN16@encoded_co:
  000e1	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN17@encoded_co:

; 1312 :         return s_true;

  000e5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?s_true@?4??_encoded_const@@9@9

; 1325 :     }
; 1326 : }

  000ec	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f0	5b		 pop	 rbx
  000f1	c3		 ret	 0
$LN6@encoded_co:

; 1313 :     }
; 1314 :     else if (obj == Py_False) {

  000f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  000f9	48 3b c8	 cmp	 rcx, rax
  000fc	75 34		 jne	 SHORT $LN3@encoded_co

; 1315 :         static PyObject *s_false = NULL;
; 1316 :         if (s_false == NULL) {

  000fe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?s_false@?6??_encoded_const@@9@9
  00105	48 85 c0	 test	 rax, rax
  00108	75 13		 jne	 SHORT $LN2@encoded_co

; 1317 :             s_false = PyUnicode_InternFromString("false");

  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
  00111	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00116	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?s_false@?6??_encoded_const@@9@9, rax
$LN2@encoded_co:

; 1318 :         }
; 1319 :         Py_INCREF(s_false);

  0011d	48 8b c8	 mov	 rcx, rax
  00120	e8 00 00 00 00	 call	 _Py_IncRef

; 1320 :         return s_false;

  00125	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?s_false@?6??_encoded_const@@9@9

; 1325 :     }
; 1326 : }

  0012c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00130	5b		 pop	 rbx
  00131	c3		 ret	 0
$LN3@encoded_co:

; 1321 :     }
; 1322 :     else {
; 1323 :         PyErr_SetString(PyExc_ValueError, "not a const");

  00132	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00139	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@HLNFKNCD@not?5a?5const?$AA@
  00140	e8 00 00 00 00	 call	 PyErr_SetString

; 1324 :         return NULL;

  00145	33 c0		 xor	 eax, eax

; 1325 :     }
; 1326 : }

  00147	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014b	5b		 pop	 rbx
  0014c	c3		 ret	 0
_encoded_const ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@BGGMNKIO@Out?5of?5range?5float?5values?5are?5no@ ; `string'
EXTRN	PyObject_Repr:PROC
EXTRN	PyUnicode_FromString:PROC
EXTRN	__imp__finite:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$encoder_encode_float DD imagerel encoder_encode_float
	DD	imagerel encoder_encode_float+209
	DD	imagerel $unwind$encoder_encode_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encoder_encode_float DD 060f01H
	DD	02680fH
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0DB@BGGMNKIO@Out?5of?5range?5float?5values?5are?5no@
CONST	SEGMENT
??_C@_0DB@BGGMNKIO@Out?5of?5range?5float?5values?5are?5no@ DB 'Out of ran'
	DB	'ge float values are not JSON compliant', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT encoder_encode_float
_TEXT	SEGMENT
s$ = 64
obj$ = 72
encoder_encode_float PROC				; COMDAT

; 1330 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6

; 1331 :     /* Return the JSON representation of a PyFloat */
; 1332 :     double i = PyFloat_AS_DOUBLE(obj);

  0000f	f2 0f 10 72 60	 movsdx	 xmm6, QWORD PTR [rdx+96]
  00014	48 8b fa	 mov	 rdi, rdx

; 1333 :     if (!Py_IS_FINITE(i)) {

  00017	66 0f 28 c6	 movapd	 xmm0, xmm6
  0001b	48 8b d9	 mov	 rbx, rcx
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00024	85 c0		 test	 eax, eax
  00026	0f 85 8e 00 00
	00		 jne	 $LN1@encoder_en

; 1334 :         if (!s->allow_nan) {

  0002c	39 83 a4 00 00
	00		 cmp	 DWORD PTR [rbx+164], eax
  00032	75 25		 jne	 SHORT $LN5@encoder_en

; 1335 :             PyErr_SetString(PyExc_ValueError, "Out of range float values are not JSON compliant");

  00034	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@BGGMNKIO@Out?5of?5range?5float?5values?5are?5no@
  00042	e8 00 00 00 00	 call	 PyErr_SetString

; 1336 :             return NULL;

  00047	33 c0		 xor	 eax, eax

; 1350 : }

  00049	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0004e	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
$LN5@encoder_en:

; 1337 :         }
; 1338 :         if (i > 0) {

  00059	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0005d	66 0f 2f f0	 comisd	 xmm6, xmm0
  00061	76 1b		 jbe	 SHORT $LN4@encoder_en

; 1339 :             return PyUnicode_FromString("Infinity");

  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08KEBCLIFP@Infinity?$AA@

; 1350 : }

  0006a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0006f	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00074	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00078	5f		 pop	 rdi
  00079	e9 00 00 00 00	 jmp	 PyUnicode_FromString
$LN4@encoder_en:

; 1340 :         }
; 1341 :         else if (i < 0) {

  0007e	66 0f 2f c6	 comisd	 xmm0, xmm6
  00082	76 1b		 jbe	 SHORT $LN2@encoder_en

; 1342 :             return PyUnicode_FromString("-Infinity");

  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09BLDCEMOH@?9Infinity?$AA@

; 1350 : }

  0008b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00090	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00095	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00099	5f		 pop	 rdi
  0009a	e9 00 00 00 00	 jmp	 PyUnicode_FromString
$LN2@encoder_en:

; 1343 :         }
; 1344 :         else {
; 1345 :             return PyUnicode_FromString("NaN");

  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03ICJPMMHB@NaN?$AA@

; 1350 : }

  000a6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ab	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000b0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b4	5f		 pop	 rdi
  000b5	e9 00 00 00 00	 jmp	 PyUnicode_FromString
$LN1@encoder_en:

; 1346 :         }
; 1347 :     }
; 1348 :     /* Use a better float format here? */
; 1349 :     return PyObject_Repr(obj);

  000ba	48 8b cf	 mov	 rcx, rdi

; 1350 : }

  000bd	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c2	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000c7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cb	5f		 pop	 rdi
  000cc	e9 00 00 00 00	 jmp	 PyObject_Repr
encoder_encode_float ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT encoder_encode_string
_TEXT	SEGMENT
s$ = 8
obj$ = 16
encoder_encode_string PROC				; COMDAT

; 1355 :     /* Return the JSON representation of a string */
; 1356 :     if (s->fast_encode)

  00000	83 b9 a0 00 00
	00 00		 cmp	 DWORD PTR [rcx+160], 0
  00007	74 07		 je	 SHORT $LN2@encoder_en@2

; 1357 :         return py_encode_basestring_ascii(NULL, obj);

  00009	33 c9		 xor	 ecx, ecx

; 1360 : }

  0000b	e9 00 00 00 00	 jmp	 py_encode_basestring_ascii
$LN2@encoder_en@2:

; 1358 :     else
; 1359 :         return PyObject_CallFunctionObjArgs(s->encoder, obj, NULL);

  00010	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00014	45 33 c0	 xor	 r8d, r8d

; 1360 : }

  00017	e9 00 00 00 00	 jmp	 PyObject_CallFunctionObjArgs
encoder_encode_string ENDP
_TEXT	ENDS
EXTRN	_PyAccu_Accumulate:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_steal_accumulate DD imagerel _steal_accumulate
	DD	imagerel _steal_accumulate+41
	DD	imagerel $unwind$_steal_accumulate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_steal_accumulate DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _steal_accumulate
_TEXT	SEGMENT
acc$ = 48
stolen$ = 56
_steal_accumulate PROC					; COMDAT

; 1364 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx

; 1365 :     /* Append stolen and then decrement its reference count */
; 1366 :     int rval = _PyAccu_Accumulate(acc, stolen);

  0000d	e8 00 00 00 00	 call	 _PyAccu_Accumulate

; 1367 :     Py_DECREF(stolen);

  00012	48 8b cf	 mov	 rcx, rdi
  00015	8b d8		 mov	 ebx, eax
  00017	e8 00 00 00 00	 call	 _Py_DecRef

; 1368 :     return rval;

  0001c	8b c3		 mov	 eax, ebx

; 1369 : }

  0001e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5f		 pop	 rdi
  00028	c3		 ret	 0
_steal_accumulate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@NAMMALPE@items?5must?5return?52?9tuples?$AA@ ; `string'
PUBLIC	??_C@_0BI@LAIECFEL@encoder_listencode_dict?$AA@	; `string'
PUBLIC	??_C@_0BG@KBENEGNI@keys?5must?5be?5a?5string?$AA@ ; `string'
PUBLIC	??_C@_0BG@MAFCIFGN@keys?5must?5return?5list?$AA@ ; `string'
PUBLIC	??_C@_0BM@PEOODJKM@Circular?5reference?5detected?$AA@ ; `string'
PUBLIC	??_C@_02MCILKGOH@?$HL?$HN?$AA@			; `string'
PUBLIC	??_C@_01CELHOKLL@?$HN?$AA@			; `string'
PUBLIC	??_C@_01HCONENDN@?$HL?$AA@			; `string'
EXTRN	PyDict_DelItem:PROC
EXTRN	PyObject_Str:PROC
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyMapping_Items:PROC
EXTRN	PyIter_Next:PROC
EXTRN	PyObject_GetIter:PROC
EXTRN	PyList_Sort:PROC
EXTRN	PyMapping_Keys:PROC
EXTRN	PyDict_Contains:PROC
EXTRN	PyLong_FromVoidPtr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$encoder_listencode_dict DD imagerel encoder_listencode_dict
	DD	imagerel encoder_listencode_dict+208
	DD	imagerel $unwind$encoder_listencode_dict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$encoder_listencode_dict DD imagerel encoder_listencode_dict+208
	DD	imagerel encoder_listencode_dict+951
	DD	imagerel $chain$1$encoder_listencode_dict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$encoder_listencode_dict DD imagerel encoder_listencode_dict+951
	DD	imagerel encoder_listencode_dict+1386
	DD	imagerel $chain$3$encoder_listencode_dict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$encoder_listencode_dict DD imagerel encoder_listencode_dict+1386
	DD	imagerel encoder_listencode_dict+1404
	DD	imagerel $chain$4$encoder_listencode_dict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$encoder_listencode_dict DD 021H
	DD	imagerel encoder_listencode_dict
	DD	imagerel encoder_listencode_dict+208
	DD	imagerel $unwind$encoder_listencode_dict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$encoder_listencode_dict DD 040021H
	DD	087400H
	DD	0106400H
	DD	imagerel encoder_listencode_dict
	DD	imagerel encoder_listencode_dict+208
	DD	imagerel $unwind$encoder_listencode_dict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$encoder_listencode_dict DD 040d21H
	DD	08740dH
	DD	0106408H
	DD	imagerel encoder_listencode_dict
	DD	imagerel encoder_listencode_dict+208
	DD	imagerel $unwind$encoder_listencode_dict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encoder_listencode_dict DD 071801H
	DD	0f0148218H
	DD	0d010e012H
	DD	0500cc00eH
	DD	0300bH
xdata	ENDS
;	COMDAT ??_C@_0BL@NAMMALPE@items?5must?5return?52?9tuples?$AA@
CONST	SEGMENT
??_C@_0BL@NAMMALPE@items?5must?5return?52?9tuples?$AA@ DB 'items must ret'
	DB	'urn 2-tuples', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LAIECFEL@encoder_listencode_dict?$AA@
CONST	SEGMENT
??_C@_0BI@LAIECFEL@encoder_listencode_dict?$AA@ DB 'encoder_listencode_di'
	DB	'ct', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KBENEGNI@keys?5must?5be?5a?5string?$AA@
CONST	SEGMENT
??_C@_0BG@KBENEGNI@keys?5must?5be?5a?5string?$AA@ DB 'keys must be a stri'
	DB	'ng', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MAFCIFGN@keys?5must?5return?5list?$AA@
CONST	SEGMENT
??_C@_0BG@MAFCIFGN@keys?5must?5return?5list?$AA@ DB 'keys must return lis'
	DB	't', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PEOODJKM@Circular?5reference?5detected?$AA@
CONST	SEGMENT
??_C@_0BM@PEOODJKM@Circular?5reference?5detected?$AA@ DB 'Circular refere'
	DB	'nce detected', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCILKGOH@?$HL?$HN?$AA@
CONST	SEGMENT
??_C@_02MCILKGOH@?$HL?$HN?$AA@ DB '{}', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN?$AA@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN?$AA@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL?$AA@
CONST	SEGMENT
??_C@_01HCONENDN@?$HL?$AA@ DB '{', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT encoder_listencode_dict
_TEXT	SEGMENT
ident$1$ = 48
s$ = 128
acc$ = 136
dct$ = 144
indent_level$ = 152
encoder_listencode_dict PROC				; COMDAT

; 1467 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1468 :     /* Encode Python dict dct a JSON term */
; 1469 :     static PyObject *open_dict = NULL;
; 1470 :     static PyObject *close_dict = NULL;
; 1471 :     static PyObject *empty_dict = NULL;
; 1472 :     PyObject *kstr = NULL;
; 1473 :     PyObject *ident = NULL;

  00018	33 c0		 xor	 eax, eax
  0001a	4c 8b e2	 mov	 r12, rdx

; 1474 :     PyObject *it = NULL;
; 1475 :     PyObject *items;
; 1476 :     PyObject *item = NULL;
; 1477 :     int skipkeys;
; 1478 :     Py_ssize_t idx;
; 1479 : 
; 1480 :     if (open_dict == NULL || close_dict == NULL || empty_dict == NULL) {

  0001d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?open_dict@?1??encoder_listencode_dict@@9@9
  00024	45 33 f6	 xor	 r14d, r14d
  00027	45 33 ed	 xor	 r13d, r13d
  0002a	49 8b d9	 mov	 rbx, r9
  0002d	49 8b e8	 mov	 rbp, r8
  00030	4c 8b f9	 mov	 r15, rcx
  00033	48 89 44 24 30	 mov	 QWORD PTR ident$1$[rsp], rax
  00038	48 85 d2	 test	 rdx, rdx
  0003b	74 15		 je	 SHORT $LN79@encoder_li
  0003d	48 39 05 00 00
	00 00		 cmp	 QWORD PTR ?close_dict@?1??encoder_listencode_dict@@9@9, rax
  00044	74 0c		 je	 SHORT $LN79@encoder_li
  00046	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?empty_dict@?1??encoder_listencode_dict@@9@9
  0004d	48 85 c0	 test	 rax, rax
  00050	75 5f		 jne	 SHORT $LN78@encoder_li
$LN79@encoder_li:

; 1481 :         open_dict = PyUnicode_InternFromString("{");

  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01HCONENDN@?$HL?$AA@
  00059	e8 00 00 00 00	 call	 PyUnicode_InternFromString

; 1482 :         close_dict = PyUnicode_InternFromString("}");

  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01CELHOKLL@?$HN?$AA@
  00065	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?open_dict@?1??encoder_listencode_dict@@9@9, rax
  0006c	e8 00 00 00 00	 call	 PyUnicode_InternFromString

; 1483 :         empty_dict = PyUnicode_InternFromString("{}");

  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02MCILKGOH@?$HL?$HN?$AA@
  00078	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?close_dict@?1??encoder_listencode_dict@@9@9, rax
  0007f	e8 00 00 00 00	 call	 PyUnicode_InternFromString

; 1484 :         if (open_dict == NULL || close_dict == NULL || empty_dict == NULL)

  00084	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?open_dict@?1??encoder_listencode_dict@@9@9
  0008b	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?empty_dict@?1??encoder_listencode_dict@@9@9, rax
  00092	48 85 d2	 test	 rdx, rdx
  00095	0f 84 cf 04 00
	00		 je	 $LN77@encoder_li
  0009b	4c 39 2d 00 00
	00 00		 cmp	 QWORD PTR ?close_dict@?1??encoder_listencode_dict@@9@9, r13
  000a2	0f 84 c2 04 00
	00		 je	 $LN77@encoder_li
  000a8	48 85 c0	 test	 rax, rax
  000ab	0f 84 b9 04 00
	00		 je	 $LN77@encoder_li
$LN78@encoder_li:

; 1486 :     }
; 1487 :     if (Py_SIZE(dct) == 0)

  000b1	4c 39 6d 60	 cmp	 QWORD PTR [rbp+96], r13
  000b5	75 19		 jne	 SHORT $LN76@encoder_li

; 1488 :         return _PyAccu_Accumulate(acc, empty_dict);

  000b7	48 8b d0	 mov	 rdx, rax
  000ba	49 8b cc	 mov	 rcx, r12

; 1640 : }

  000bd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c1	41 5f		 pop	 r15
  000c3	41 5e		 pop	 r14
  000c5	41 5d		 pop	 r13
  000c7	41 5c		 pop	 r12
  000c9	5d		 pop	 rbp
  000ca	5b		 pop	 rbx
  000cb	e9 00 00 00 00	 jmp	 _PyAccu_Accumulate
$LN76@encoder_li:
  000d0	48 89 b4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rsi
  000d8	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 1489 : 
; 1490 :     if (s->markers != Py_None) {

  000dd	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  000e4	49 39 7f 60	 cmp	 QWORD PTR [r15+96], rdi
  000e8	74 70		 je	 SHORT $LN71@encoder_li

; 1491 :         int has_key;
; 1492 :         ident = PyLong_FromVoidPtr(dct);

  000ea	48 8b cd	 mov	 rcx, rbp
  000ed	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
  000f2	48 8b d8	 mov	 rbx, rax
  000f5	48 89 44 24 30	 mov	 QWORD PTR ident$1$[rsp], rax

; 1493 :         if (ident == NULL)

  000fa	48 85 c0	 test	 rax, rax
  000fd	0f 84 95 02 00
	00		 je	 $LN3@encoder_li

; 1494 :             goto bail;
; 1495 :         has_key = PyDict_Contains(s->markers, ident);

  00103	49 8b 4f 60	 mov	 rcx, QWORD PTR [r15+96]
  00107	48 8b d0	 mov	 rdx, rax
  0010a	e8 00 00 00 00	 call	 PyDict_Contains

; 1496 :         if (has_key) {

  0010f	85 c0		 test	 eax, eax
  00111	74 21		 je	 SHORT $LN73@encoder_li

; 1497 :             if (has_key != -1)

  00113	83 f8 ff	 cmp	 eax, -1
  00116	0f 84 6a 02 00
	00		 je	 $LN7@encoder_li

; 1498 :                 PyErr_SetString(PyExc_ValueError, "Circular reference detected");

  0011c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00123	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@PEOODJKM@Circular?5reference?5detected?$AA@
  0012a	e8 00 00 00 00	 call	 PyErr_SetString

; 1499 :             goto bail;

  0012f	e9 52 02 00 00	 jmp	 $LN7@encoder_li
$LN73@encoder_li:

; 1500 :         }
; 1501 :         if (PyDict_SetItem(s->markers, ident, dct)) {

  00134	49 8b 4f 60	 mov	 rcx, QWORD PTR [r15+96]
  00138	4c 8b c5	 mov	 r8, rbp
  0013b	48 8b d3	 mov	 rdx, rbx
  0013e	e8 00 00 00 00	 call	 PyDict_SetItem
  00143	85 c0		 test	 eax, eax
  00145	0f 85 3b 02 00
	00		 jne	 $LN7@encoder_li
  0014b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?open_dict@?1??encoder_listencode_dict@@9@9
  00152	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR indent_level$[rsp]
$LN71@encoder_li:

; 1502 :             goto bail;
; 1503 :         }
; 1504 :     }
; 1505 : 
; 1506 :     if (_PyAccu_Accumulate(acc, open_dict))

  0015a	49 8b cc	 mov	 rcx, r12
  0015d	e8 00 00 00 00	 call	 _PyAccu_Accumulate
  00162	85 c0		 test	 eax, eax
  00164	0f 85 1c 02 00
	00		 jne	 $LN7@encoder_li

; 1507 :         goto bail;
; 1508 : 
; 1509 :     if (s->indent != Py_None) {

  0016a	49 39 7f 78	 cmp	 QWORD PTR [r15+120], rdi
  0016e	74 0b		 je	 SHORT $LN69@encoder_li

; 1510 :         /* TODO: DOES NOT RUN */
; 1511 :         indent_level += 1;

  00170	48 ff c3	 inc	 rbx
  00173	48 89 9c 24 98
	00 00 00	 mov	 QWORD PTR indent_level$[rsp], rbx
$LN69@encoder_li:

; 1512 :         /*
; 1513 :             newline_indent = '\n' + (' ' * (_indent * _current_indent_level))
; 1514 :             separator = _item_separator + newline_indent
; 1515 :             buf += newline_indent
; 1516 :         */
; 1517 :     }
; 1518 : 
; 1519 :     if (PyObject_IsTrue(s->sort_keys)) {

  0017b	49 8b 8f 90 00
	00 00		 mov	 rcx, QWORD PTR [r15+144]
  00182	e8 00 00 00 00	 call	 PyObject_IsTrue

; 1520 :         /* First sort the keys then replace them with (key, value) tuples. */
; 1521 :         Py_ssize_t i, nitems;
; 1522 :         items = PyMapping_Keys(dct);

  00187	48 8b cd	 mov	 rcx, rbp
  0018a	85 c0		 test	 eax, eax
  0018c	0f 84 41 01 00
	00		 je	 $LN68@encoder_li
  00192	e8 00 00 00 00	 call	 PyMapping_Keys
  00197	48 8b d8	 mov	 rbx, rax

; 1523 :         if (items == NULL)

  0019a	48 85 c0	 test	 rax, rax
  0019d	0f 84 e3 01 00
	00		 je	 $LN7@encoder_li

; 1524 :             goto bail;
; 1525 :         if (!PyList_Check(items)) {

  001a3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001a7	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  001b1	75 18		 jne	 SHORT $LN66@encoder_li

; 1526 :             PyErr_SetString(PyExc_ValueError, "keys must return list");

  001b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@MAFCIFGN@keys?5must?5return?5list?$AA@
  001c1	e8 00 00 00 00	 call	 PyErr_SetString

; 1527 :             goto bail;

  001c6	e9 bb 01 00 00	 jmp	 $LN7@encoder_li
$LN66@encoder_li:

; 1528 :         }
; 1529 :         if (PyList_Sort(items) < 0)

  001cb	48 8b cb	 mov	 rcx, rbx
  001ce	e8 00 00 00 00	 call	 PyList_Sort
  001d3	85 c0		 test	 eax, eax
  001d5	0f 88 ab 01 00
	00		 js	 $LN7@encoder_li

; 1530 :             goto bail;
; 1531 :         nitems = PyList_GET_SIZE(items);

  001db	4c 8b 63 60	 mov	 r12, QWORD PTR [rbx+96]

; 1532 :         for (i = 0; i < nitems; i++) {

  001df	33 ff		 xor	 edi, edi
  001e1	4d 85 e4	 test	 r12, r12
  001e4	7e 51		 jle	 SHORT $LN99@encoder_li
  001e6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL64@encoder_li:

; 1533 :             PyObject *key, *value;
; 1534 :             key = PyList_GET_ITEM(items, i);

  001f0	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]

; 1535 :             value = PyDict_GetItem(dct, key);

  001f4	48 8b cd	 mov	 rcx, rbp
  001f7	48 8b 34 f8	 mov	 rsi, QWORD PTR [rax+rdi*8]
  001fb	48 8b d6	 mov	 rdx, rsi
  001fe	e8 00 00 00 00	 call	 PyDict_GetItem

; 1536 :             item = PyTuple_Pack(2, key, value);

  00203	48 8b d6	 mov	 rdx, rsi
  00206	b9 02 00 00 00	 mov	 ecx, 2
  0020b	4c 8b c0	 mov	 r8, rax
  0020e	e8 00 00 00 00	 call	 PyTuple_Pack
  00213	4c 8b e8	 mov	 r13, rax

; 1537 :             if (item == NULL)

  00216	48 85 c0	 test	 rax, rax
  00219	0f 84 67 01 00
	00		 je	 $LN7@encoder_li

; 1538 :                 goto bail;
; 1539 :             PyList_SET_ITEM(items, i, item);

  0021f	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]

; 1540 :             Py_DECREF(key);

  00223	48 8b ce	 mov	 rcx, rsi
  00226	4c 89 2c f8	 mov	 QWORD PTR [rax+rdi*8], r13
  0022a	e8 00 00 00 00	 call	 _Py_DecRef
  0022f	48 ff c7	 inc	 rdi
  00232	49 3b fc	 cmp	 rdi, r12
  00235	7c b9		 jl	 SHORT $LL64@encoder_li
$LN99@encoder_li:

; 1467 : {

  00237	4c 8b a4 24 88
	00 00 00	 mov	 r12, QWORD PTR acc$[rsp]
$LN60@encoder_li:

; 1545 :     }
; 1546 :     if (items == NULL)

  0023f	48 85 db	 test	 rbx, rbx
  00242	0f 84 24 01 00
	00		 je	 $LN15@encoder_li

; 1547 :         goto bail;
; 1548 :     it = PyObject_GetIter(items);

  00248	48 8b cb	 mov	 rcx, rbx
  0024b	e8 00 00 00 00	 call	 PyObject_GetIter

; 1549 :     Py_DECREF(items);

  00250	48 8b cb	 mov	 rcx, rbx
  00253	48 8b f8	 mov	 rdi, rax
  00256	e8 00 00 00 00	 call	 _Py_DecRef

; 1550 :     if (it == NULL)

  0025b	48 85 ff	 test	 rdi, rdi
  0025e	0f 84 08 01 00
	00		 je	 $LN15@encoder_li

; 1551 :         goto bail;
; 1552 :     skipkeys = PyObject_IsTrue(s->skipkeys);

  00264	49 8b 8f 98 00
	00 00		 mov	 rcx, QWORD PTR [r15+152]
  0026b	e8 00 00 00 00	 call	 PyObject_IsTrue

; 1553 :     idx = 0;

  00270	33 f6		 xor	 esi, esi
  00272	48 63 e8	 movsxd	 rbp, eax
$LN106@encoder_li:

; 1554 :     while ((item = PyIter_Next(it)) != NULL) {

  00275	48 8b cf	 mov	 rcx, rdi
  00278	e8 00 00 00 00	 call	 PyIter_Next
  0027d	4c 8b e8	 mov	 r13, rax
  00280	48 85 c0	 test	 rax, rax
  00283	0f 84 30 02 00
	00		 je	 $LN56@encoder_li

; 1555 :         PyObject *encoded, *key, *value;
; 1556 :         if (!PyTuple_Check(item) || Py_SIZE(item) != 2) {

  00289	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0028d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00294	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  0029e	0f 84 02 02 00
	00		 je	 $LN54@encoder_li
  002a4	49 83 7d 60 02	 cmp	 QWORD PTR [r13+96], 2
  002a9	0f 85 f7 01 00
	00		 jne	 $LN54@encoder_li

; 1559 :         }
; 1560 :         key = PyTuple_GET_ITEM(item, 0);

  002af	49 8b 5d 70	 mov	 rbx, QWORD PTR [r13+112]

; 1561 :         if (PyUnicode_Check(key)) {

  002b3	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  002b7	f7 81 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rcx+256], 268435456 ; 10000000H
  002c1	74 1d		 je	 SHORT $LN53@encoder_li

; 1562 :             Py_INCREF(key);

  002c3	48 8b cb	 mov	 rcx, rbx
  002c6	e8 00 00 00 00	 call	 _Py_IncRef

; 1563 :             kstr = key;

  002cb	4c 8b f3	 mov	 r14, rbx
  002ce	e9 01 01 00 00	 jmp	 $LN49@encoder_li
$LN68@encoder_li:

; 1541 :         }
; 1542 :     }
; 1543 :     else {
; 1544 :         items = PyMapping_Items(dct);

  002d3	e8 00 00 00 00	 call	 PyMapping_Items
  002d8	48 8b d8	 mov	 rbx, rax
  002db	e9 5f ff ff ff	 jmp	 $LN60@encoder_li
$LN53@encoder_li:

; 1564 :         }
; 1565 :         else if (PyFloat_Check(key)) {

  002e0	48 3b ca	 cmp	 rcx, rdx
  002e3	0f 84 d8 00 00
	00		 je	 $LN50@encoder_li
  002e9	e8 00 00 00 00	 call	 PyType_IsSubtype
  002ee	85 c0		 test	 eax, eax
  002f0	0f 85 cb 00 00
	00		 jne	 $LN50@encoder_li

; 1568 :                 goto bail;
; 1569 :         }
; 1570 :         else if (key == Py_True || key == Py_False || key == Py_None) {

  002f6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  002fd	48 3b d8	 cmp	 rbx, rax
  00300	0f 84 b1 00 00
	00		 je	 $LN46@encoder_li
  00306	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0030d	48 3b d8	 cmp	 rbx, rax
  00310	0f 84 a1 00 00
	00		 je	 $LN46@encoder_li
  00316	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0031d	48 3b d8	 cmp	 rbx, rax
  00320	0f 84 91 00 00
	00		 je	 $LN46@encoder_li

; 1574 :             if (kstr == NULL)
; 1575 :                 goto bail;
; 1576 :         }
; 1577 :         else if (PyLong_Check(key)) {

  00326	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0032a	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00334	74 0d		 je	 SHORT $LN43@encoder_li

; 1578 :             kstr = PyObject_Str(key);

  00336	48 8b cb	 mov	 rcx, rbx
  00339	e8 00 00 00 00	 call	 PyObject_Str

; 1579 :             if (kstr == NULL)
; 1580 :                 goto bail;
; 1581 :         }
; 1582 :         else if (skipkeys) {

  0033e	e9 89 00 00 00	 jmp	 $LN103@encoder_li
$LN43@encoder_li:
  00343	48 85 ed	 test	 rbp, rbp
  00346	0f 85 43 01 00
	00		 jne	 $LN104@encoder_li

; 1583 :             Py_DECREF(item);
; 1584 :             continue;
; 1585 :         }
; 1586 :         else {
; 1587 :             /* TODO: include repr of key */
; 1588 :             PyErr_SetString(PyExc_TypeError, "keys must be a string");

  0034c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00353	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@KBENEGNI@keys?5must?5be?5a?5string?$AA@
$LN107@encoder_li:
  0035a	e8 00 00 00 00	 call	 PyErr_SetString
$bail$22257:

; 1633 : 
; 1634 : bail:
; 1635 :     Py_XDECREF(it);

  0035f	48 85 ff	 test	 rdi, rdi
  00362	74 08		 je	 SHORT $LN15@encoder_li
  00364	48 8b cf	 mov	 rcx, rdi
  00367	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@encoder_li:

; 1636 :     Py_XDECREF(item);

  0036c	4d 85 ed	 test	 r13, r13
  0036f	74 08		 je	 SHORT $LN11@encoder_li
  00371	49 8b cd	 mov	 rcx, r13
  00374	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@encoder_li:

; 1637 :     Py_XDECREF(kstr);

  00379	4d 85 f6	 test	 r14, r14
  0037c	74 08		 je	 SHORT $LN7@encoder_li
  0037e	49 8b ce	 mov	 rcx, r14
  00381	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@encoder_li:

; 1638 :     Py_XDECREF(ident);

  00386	48 8b 44 24 30	 mov	 rax, QWORD PTR ident$1$[rsp]
  0038b	48 85 c0	 test	 rax, rax
  0038e	74 08		 je	 SHORT $LN3@encoder_li
  00390	48 8b c8	 mov	 rcx, rax
  00393	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@encoder_li:

; 1639 :     return -1;

  00398	83 c8 ff	 or	 eax, -1
$LN101@encoder_li:
  0039b	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  003a3	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 1640 : }

  003a8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  003ac	41 5f		 pop	 r15
  003ae	41 5e		 pop	 r14
  003b0	41 5d		 pop	 r13
  003b2	41 5c		 pop	 r12
  003b4	5d		 pop	 rbp
  003b5	5b		 pop	 rbx
  003b6	c3		 ret	 0
$LN46@encoder_li:

; 1571 :                         /* This must come before the PyLong_Check because
; 1572 :                            True and False are also 1 and 0.*/
; 1573 :             kstr = _encoded_const(key);

  003b7	48 8b cb	 mov	 rcx, rbx
  003ba	e8 00 00 00 00	 call	 _encoded_const

; 1574 :             if (kstr == NULL)
; 1575 :                 goto bail;
; 1576 :         }
; 1577 :         else if (PyLong_Check(key)) {

  003bf	eb 0b		 jmp	 SHORT $LN103@encoder_li
$LN50@encoder_li:

; 1566 :             kstr = encoder_encode_float(s, key);

  003c1	48 8b d3	 mov	 rdx, rbx
  003c4	49 8b cf	 mov	 rcx, r15
  003c7	e8 00 00 00 00	 call	 encoder_encode_float
$LN103@encoder_li:
  003cc	4c 8b f0	 mov	 r14, rax

; 1567 :             if (kstr == NULL)

  003cf	48 85 c0	 test	 rax, rax
  003d2	74 8b		 je	 SHORT $bail$22257
$LN49@encoder_li:

; 1589 :             goto bail;
; 1590 :         }
; 1591 : 
; 1592 :         if (idx) {

  003d4	48 85 f6	 test	 rsi, rsi
  003d7	74 17		 je	 SHORT $LN37@encoder_li

; 1593 :             if (_PyAccu_Accumulate(acc, s->item_separator))

  003d9	49 8b 97 88 00
	00 00		 mov	 rdx, QWORD PTR [r15+136]
  003e0	49 8b cc	 mov	 rcx, r12
  003e3	e8 00 00 00 00	 call	 _PyAccu_Accumulate
  003e8	85 c0		 test	 eax, eax
  003ea	0f 85 6f ff ff
	ff		 jne	 $bail$22257
$LN37@encoder_li:

; 1594 :                 goto bail;
; 1595 :         }
; 1596 : 
; 1597 :         encoded = encoder_encode_string(s, kstr);

  003f0	49 8b d6	 mov	 rdx, r14
  003f3	49 8b cf	 mov	 rcx, r15
  003f6	e8 00 00 00 00	 call	 encoder_encode_string
  003fb	48 8b d8	 mov	 rbx, rax

; 1598 :         Py_CLEAR(kstr);

  003fe	4d 85 f6	 test	 r14, r14
  00401	74 33		 je	 SHORT $LN35@encoder_li
  00403	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  0040a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@LAIECFEL@encoder_listencode_dict?$AA@
  00411	4d 8b ce	 mov	 r9, r14
  00414	41 b8 3e 06 00
	00		 mov	 r8d, 1598		; 0000063eH
  0041a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00422	e8 00 00 00 00	 call	 _PyParallel_Guard
  00427	85 c0		 test	 eax, eax
  00429	75 0b		 jne	 SHORT $LN35@encoder_li
  0042b	49 8b ce	 mov	 rcx, r14
  0042e	45 33 f6	 xor	 r14d, r14d
  00431	e8 00 00 00 00	 call	 _Py_DecRef
$LN35@encoder_li:

; 1599 :         if (encoded == NULL)

  00436	48 85 db	 test	 rbx, rbx
  00439	0f 84 20 ff ff
	ff		 je	 $bail$22257

; 1600 :             goto bail;
; 1601 :         if (_PyAccu_Accumulate(acc, encoded)) {

  0043f	48 8b d3	 mov	 rdx, rbx
  00442	49 8b cc	 mov	 rcx, r12
  00445	e8 00 00 00 00	 call	 _PyAccu_Accumulate

; 1604 :         }
; 1605 :         Py_DECREF(encoded);

  0044a	48 8b cb	 mov	 rcx, rbx
  0044d	85 c0		 test	 eax, eax
  0044f	75 4b		 jne	 SHORT $LN93@encoder_li
  00451	e8 00 00 00 00	 call	 _Py_DecRef

; 1606 :         if (_PyAccu_Accumulate(acc, s->key_separator))

  00456	49 8b 97 80 00
	00 00		 mov	 rdx, QWORD PTR [r15+128]
  0045d	49 8b cc	 mov	 rcx, r12
  00460	e8 00 00 00 00	 call	 _PyAccu_Accumulate
  00465	85 c0		 test	 eax, eax
  00467	0f 85 f2 fe ff
	ff		 jne	 $bail$22257

; 1607 :             goto bail;
; 1608 : 
; 1609 :         value = PyTuple_GET_ITEM(item, 1);
; 1610 :         if (encoder_listencode_obj(s, acc, value, indent_level))

  0046d	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR indent_level$[rsp]
  00475	4d 8b 45 78	 mov	 r8, QWORD PTR [r13+120]
  00479	49 8b d4	 mov	 rdx, r12
  0047c	49 8b cf	 mov	 rcx, r15
  0047f	e8 00 00 00 00	 call	 encoder_listencode_obj
  00484	85 c0		 test	 eax, eax
  00486	0f 85 d3 fe ff
	ff		 jne	 $bail$22257

; 1611 :             goto bail;
; 1612 :         idx += 1;

  0048c	48 ff c6	 inc	 rsi
$LN104@encoder_li:

; 1613 :         Py_DECREF(item);

  0048f	49 8b cd	 mov	 rcx, r13
  00492	e8 00 00 00 00	 call	 _Py_DecRef
  00497	e9 d9 fd ff ff	 jmp	 $LN106@encoder_li
$LN93@encoder_li:

; 1602 :             Py_DECREF(encoded);

  0049c	e8 00 00 00 00	 call	 _Py_DecRef

; 1603 :             goto bail;

  004a1	e9 b9 fe ff ff	 jmp	 $bail$22257
$LN54@encoder_li:

; 1557 :             PyErr_SetString(PyExc_ValueError, "items must return 2-tuples");

  004a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  004ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@NAMMALPE@items?5must?5return?52?9tuples?$AA@

; 1558 :             goto bail;

  004b4	e9 a1 fe ff ff	 jmp	 $LN107@encoder_li
$LN56@encoder_li:

; 1614 :     }
; 1615 :     if (PyErr_Occurred())

  004b9	e8 00 00 00 00	 call	 PyErr_Occurred
  004be	48 85 c0	 test	 rax, rax
  004c1	0f 85 98 fe ff
	ff		 jne	 $bail$22257

; 1616 :         goto bail;
; 1617 :     Py_CLEAR(it);

  004c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  004ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@LAIECFEL@encoder_listencode_dict?$AA@
  004d5	4c 8b cf	 mov	 r9, rdi
  004d8	41 b8 51 06 00
	00		 mov	 r8d, 1617		; 00000651H
  004de	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004e6	e8 00 00 00 00	 call	 _PyParallel_Guard
  004eb	85 c0		 test	 eax, eax
  004ed	75 0a		 jne	 SHORT $LN26@encoder_li
  004ef	48 8b cf	 mov	 rcx, rdi
  004f2	33 ff		 xor	 edi, edi
  004f4	e8 00 00 00 00	 call	 _Py_DecRef
$LN26@encoder_li:

; 1618 : 
; 1619 :     if (ident != NULL) {

  004f9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR ident$1$[rsp]
  004fe	48 85 db	 test	 rbx, rbx
  00501	74 4b		 je	 SHORT $LN19@encoder_li

; 1620 :         if (PyDict_DelItem(s->markers, ident))

  00503	49 8b 4f 60	 mov	 rcx, QWORD PTR [r15+96]
  00507	48 8b d3	 mov	 rdx, rbx
  0050a	e8 00 00 00 00	 call	 PyDict_DelItem
  0050f	85 c0		 test	 eax, eax
  00511	0f 85 48 fe ff
	ff		 jne	 $bail$22257

; 1621 :             goto bail;
; 1622 :         Py_CLEAR(ident);

  00517	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  0051e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@LAIECFEL@encoder_listencode_dict?$AA@
  00525	4c 8b cb	 mov	 r9, rbx
  00528	41 b8 56 06 00
	00		 mov	 r8d, 1622		; 00000656H
  0052e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00536	e8 00 00 00 00	 call	 _PyParallel_Guard
  0053b	85 c0		 test	 eax, eax
  0053d	75 0f		 jne	 SHORT $LN19@encoder_li
  0053f	33 c0		 xor	 eax, eax
  00541	48 8b cb	 mov	 rcx, rbx
  00544	48 89 44 24 30	 mov	 QWORD PTR ident$1$[rsp], rax
  00549	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@encoder_li:

; 1623 :     }
; 1624 :     /* TODO DOES NOT RUN; dead code
; 1625 :     if (s->indent != Py_None) {
; 1626 :         indent_level -= 1;
; 1627 : 
; 1628 :         yield '\n' + (' ' * (_indent * _current_indent_level))
; 1629 :     }*/
; 1630 :     if (_PyAccu_Accumulate(acc, close_dict))

  0054e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?close_dict@?1??encoder_listencode_dict@@9@9
  00555	49 8b cc	 mov	 rcx, r12
  00558	e8 00 00 00 00	 call	 _PyAccu_Accumulate
  0055d	85 c0		 test	 eax, eax
  0055f	0f 85 fa fd ff
	ff		 jne	 $bail$22257

; 1631 :         goto bail;
; 1632 :     return 0;

  00565	e9 31 fe ff ff	 jmp	 $LN101@encoder_li
$LN77@encoder_li:

; 1485 :             return -1;

  0056a	83 c8 ff	 or	 eax, -1

; 1640 : }

  0056d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00571	41 5f		 pop	 r15
  00573	41 5e		 pop	 r14
  00575	41 5d		 pop	 r13
  00577	41 5c		 pop	 r12
  00579	5d		 pop	 rbp
  0057a	5b		 pop	 rbx
  0057b	c3		 ret	 0
encoder_listencode_dict ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@NMCBDDPG@encoder_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$encoder_traverse DD imagerel encoder_traverse
	DD	imagerel encoder_traverse+514
	DD	imagerel $unwind$encoder_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encoder_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BB@NMCBDDPG@encoder_traverse?$AA@
CONST	SEGMENT
??_C@_0BB@NMCBDDPG@encoder_traverse?$AA@ DB 'encoder_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT encoder_traverse
_TEXT	SEGMENT
self$ = 48
visit$ = 56
arg$ = 64
encoder_traverse PROC					; COMDAT

; 1740 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 1741 :     PyEncoderObject *s;
; 1742 :     assert(PyEncoder_Check(self));
; 1743 :     s = (PyEncoderObject *)self;
; 1744 :     Py_VISIT(s->markers);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN45@encoder_tr
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NMCBDDPG@encoder_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 d0 06 00
	00		 mov	 r8d, 1744		; 000006d0H
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN45@encoder_tr:
  0003d	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00041	48 85 c9	 test	 rcx, rcx
  00044	74 0d		 je	 SHORT $LN47@encoder_tr
  00046	48 8b d7	 mov	 rdx, rdi
  00049	ff d6		 call	 rsi
  0004b	85 c0		 test	 eax, eax
  0004d	0f 85 9f 01 00
	00		 jne	 $LN49@encoder_tr
$LN47@encoder_tr:

; 1745 :     Py_VISIT(s->defaultfn);

  00053	e8 00 00 00 00	 call	 _Py_PXCTX
  00058	85 c0		 test	 eax, eax
  0005a	74 1c		 je	 SHORT $LN39@encoder_tr
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NMCBDDPG@encoder_traverse?$AA@
  0006a	45 33 c9	 xor	 r9d, r9d
  0006d	41 b8 d1 06 00
	00		 mov	 r8d, 1745		; 000006d1H
  00073	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN39@encoder_tr:
  00078	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  0007c	48 85 c9	 test	 rcx, rcx
  0007f	74 0d		 je	 SHORT $LN41@encoder_tr
  00081	48 8b d7	 mov	 rdx, rdi
  00084	ff d6		 call	 rsi
  00086	85 c0		 test	 eax, eax
  00088	0f 85 64 01 00
	00		 jne	 $LN49@encoder_tr
$LN41@encoder_tr:

; 1746 :     Py_VISIT(s->encoder);

  0008e	e8 00 00 00 00	 call	 _Py_PXCTX
  00093	85 c0		 test	 eax, eax
  00095	74 1c		 je	 SHORT $LN33@encoder_tr
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NMCBDDPG@encoder_traverse?$AA@
  000a5	45 33 c9	 xor	 r9d, r9d
  000a8	41 b8 d2 06 00
	00		 mov	 r8d, 1746		; 000006d2H
  000ae	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN33@encoder_tr:
  000b3	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  000b7	48 85 c9	 test	 rcx, rcx
  000ba	74 0d		 je	 SHORT $LN35@encoder_tr
  000bc	48 8b d7	 mov	 rdx, rdi
  000bf	ff d6		 call	 rsi
  000c1	85 c0		 test	 eax, eax
  000c3	0f 85 29 01 00
	00		 jne	 $LN49@encoder_tr
$LN35@encoder_tr:

; 1747 :     Py_VISIT(s->indent);

  000c9	e8 00 00 00 00	 call	 _Py_PXCTX
  000ce	85 c0		 test	 eax, eax
  000d0	74 1c		 je	 SHORT $LN27@encoder_tr
  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NMCBDDPG@encoder_traverse?$AA@
  000e0	45 33 c9	 xor	 r9d, r9d
  000e3	41 b8 d3 06 00
	00		 mov	 r8d, 1747		; 000006d3H
  000e9	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN27@encoder_tr:
  000ee	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  000f2	48 85 c9	 test	 rcx, rcx
  000f5	74 0d		 je	 SHORT $LN29@encoder_tr
  000f7	48 8b d7	 mov	 rdx, rdi
  000fa	ff d6		 call	 rsi
  000fc	85 c0		 test	 eax, eax
  000fe	0f 85 ee 00 00
	00		 jne	 $LN49@encoder_tr
$LN29@encoder_tr:

; 1748 :     Py_VISIT(s->key_separator);

  00104	e8 00 00 00 00	 call	 _Py_PXCTX
  00109	85 c0		 test	 eax, eax
  0010b	74 1c		 je	 SHORT $LN21@encoder_tr
  0010d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NMCBDDPG@encoder_traverse?$AA@
  0011b	45 33 c9	 xor	 r9d, r9d
  0011e	41 b8 d4 06 00
	00		 mov	 r8d, 1748		; 000006d4H
  00124	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN21@encoder_tr:
  00129	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00130	48 85 c9	 test	 rcx, rcx
  00133	74 0d		 je	 SHORT $LN23@encoder_tr
  00135	48 8b d7	 mov	 rdx, rdi
  00138	ff d6		 call	 rsi
  0013a	85 c0		 test	 eax, eax
  0013c	0f 85 b0 00 00
	00		 jne	 $LN49@encoder_tr
$LN23@encoder_tr:

; 1749 :     Py_VISIT(s->item_separator);

  00142	e8 00 00 00 00	 call	 _Py_PXCTX
  00147	85 c0		 test	 eax, eax
  00149	74 1c		 je	 SHORT $LN15@encoder_tr
  0014b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00152	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NMCBDDPG@encoder_traverse?$AA@
  00159	45 33 c9	 xor	 r9d, r9d
  0015c	41 b8 d5 06 00
	00		 mov	 r8d, 1749		; 000006d5H
  00162	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN15@encoder_tr:
  00167	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
  0016e	48 85 c9	 test	 rcx, rcx
  00171	74 09		 je	 SHORT $LN17@encoder_tr
  00173	48 8b d7	 mov	 rdx, rdi
  00176	ff d6		 call	 rsi
  00178	85 c0		 test	 eax, eax
  0017a	75 76		 jne	 SHORT $LN49@encoder_tr
$LN17@encoder_tr:

; 1750 :     Py_VISIT(s->sort_keys);

  0017c	e8 00 00 00 00	 call	 _Py_PXCTX
  00181	85 c0		 test	 eax, eax
  00183	74 1c		 je	 SHORT $LN9@encoder_tr
  00185	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NMCBDDPG@encoder_traverse?$AA@
  00193	45 33 c9	 xor	 r9d, r9d
  00196	41 b8 d6 06 00
	00		 mov	 r8d, 1750		; 000006d6H
  0019c	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@encoder_tr:
  001a1	48 8b 8b 90 00
	00 00		 mov	 rcx, QWORD PTR [rbx+144]
  001a8	48 85 c9	 test	 rcx, rcx
  001ab	74 09		 je	 SHORT $LN11@encoder_tr
  001ad	48 8b d7	 mov	 rdx, rdi
  001b0	ff d6		 call	 rsi
  001b2	85 c0		 test	 eax, eax
  001b4	75 3c		 jne	 SHORT $LN49@encoder_tr
$LN11@encoder_tr:

; 1751 :     Py_VISIT(s->skipkeys);

  001b6	e8 00 00 00 00	 call	 _Py_PXCTX
  001bb	85 c0		 test	 eax, eax
  001bd	74 1c		 je	 SHORT $LN3@encoder_tr
  001bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  001c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NMCBDDPG@encoder_traverse?$AA@
  001cd	45 33 c9	 xor	 r9d, r9d
  001d0	41 b8 d7 06 00
	00		 mov	 r8d, 1751		; 000006d7H
  001d6	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@encoder_tr:
  001db	48 8b 8b 98 00
	00 00		 mov	 rcx, QWORD PTR [rbx+152]
  001e2	48 85 c9	 test	 rcx, rcx
  001e5	74 09		 je	 SHORT $LN5@encoder_tr
  001e7	48 8b d7	 mov	 rdx, rdi
  001ea	ff d6		 call	 rsi
  001ec	85 c0		 test	 eax, eax
  001ee	75 02		 jne	 SHORT $LN49@encoder_tr
$LN5@encoder_tr:

; 1752 :     return 0;

  001f0	33 c0		 xor	 eax, eax
$LN49@encoder_tr:

; 1753 : }

  001f2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001f7	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001fc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00200	5f		 pop	 rdi
  00201	c3		 ret	 0
encoder_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@DBJJFICM@encoder_clear?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$encoder_clear DD imagerel encoder_clear
	DD	imagerel encoder_clear+1382
	DD	imagerel $unwind$encoder_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encoder_clear DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0O@DBJJFICM@encoder_clear?$AA@
CONST	SEGMENT
??_C@_0O@DBJJFICM@encoder_clear?$AA@ DB 'encoder_clear', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_json.c
CONST	ENDS
;	COMDAT encoder_clear
_TEXT	SEGMENT
self$ = 64
encoder_clear PROC					; COMDAT

; 1757 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1758 :     /* Deallocate Encoder */
; 1759 :     PyEncoderObject *s;
; 1760 :     assert(PyEncoder_Check(self));
; 1761 :     s = (PyEncoderObject *)self;
; 1762 :     Py_CLEAR(s->markers);

  0000f	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  00013	33 f6		 xor	 esi, esi
  00015	48 8b f9	 mov	 rdi, rcx
  00018	4d 85 c9	 test	 r9, r9
  0001b	0f 84 92 00 00
	00		 je	 $LN31@encoder_cl
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DBJJFICM@encoder_clear?$AA@
  0002f	41 b8 e2 06 00
	00		 mov	 r8d, 1762		; 000006e2H
  00035	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0003d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00042	85 c0		 test	 eax, eax
  00044	75 6d		 jne	 SHORT $LN31@encoder_cl
  00046	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  0004a	48 89 77 60	 mov	 QWORD PTR [rdi+96], rsi
  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	75 5c		 jne	 SHORT $LN31@encoder_cl
  00057	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0005b	a8 20		 test	 al, 32			; 00000020H
  0005d	75 4c		 jne	 SHORT $LN39@encoder_cl
  0005f	84 c0		 test	 al, al
  00061	78 48		 js	 SHORT $LN39@encoder_cl
  00063	a8 02		 test	 al, 2
  00065	75 4c		 jne	 SHORT $LN31@encoder_cl
  00067	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0006b	75 46		 jne	 SHORT $LN31@encoder_cl
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0007b	4c 8b cb	 mov	 r9, rbx
  0007e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00084	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0008c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00091	48 8b cb	 mov	 rcx, rbx
  00094	85 c0		 test	 eax, eax
  00096	74 07		 je	 SHORT $LN44@encoder_cl
  00098	e8 00 00 00 00	 call	 _Px_Dealloc
  0009d	eb 14		 jmp	 SHORT $LN31@encoder_cl
$LN44@encoder_cl:
  0009f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000a3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000a9	eb 08		 jmp	 SHORT $LN31@encoder_cl
$LN39@encoder_cl:
  000ab	48 8b cb	 mov	 rcx, rbx
  000ae	e8 00 00 00 00	 call	 Px_DecRef
$LN31@encoder_cl:

; 1763 :     Py_CLEAR(s->defaultfn);

  000b3	4c 8b 4f 68	 mov	 r9, QWORD PTR [rdi+104]
  000b7	4d 85 c9	 test	 r9, r9
  000ba	0f 84 92 00 00
	00		 je	 $LN27@encoder_cl
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DBJJFICM@encoder_clear?$AA@
  000ce	41 b8 e3 06 00
	00		 mov	 r8d, 1763		; 000006e3H
  000d4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000dc	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e1	85 c0		 test	 eax, eax
  000e3	75 6d		 jne	 SHORT $LN27@encoder_cl
  000e5	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
  000e9	48 89 77 68	 mov	 QWORD PTR [rdi+104], rsi
  000ed	e8 00 00 00 00	 call	 _Py_PXCTX
  000f2	85 c0		 test	 eax, eax
  000f4	75 5c		 jne	 SHORT $LN27@encoder_cl
  000f6	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000fa	a8 20		 test	 al, 32			; 00000020H
  000fc	75 4c		 jne	 SHORT $LN50@encoder_cl
  000fe	84 c0		 test	 al, al
  00100	78 48		 js	 SHORT $LN50@encoder_cl
  00102	a8 02		 test	 al, 2
  00104	75 4c		 jne	 SHORT $LN27@encoder_cl
  00106	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0010a	75 46		 jne	 SHORT $LN27@encoder_cl
  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0011a	4c 8b cb	 mov	 r9, rbx
  0011d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00123	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0012b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00130	48 8b cb	 mov	 rcx, rbx
  00133	85 c0		 test	 eax, eax
  00135	74 07		 je	 SHORT $LN55@encoder_cl
  00137	e8 00 00 00 00	 call	 _Px_Dealloc
  0013c	eb 14		 jmp	 SHORT $LN27@encoder_cl
$LN55@encoder_cl:
  0013e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00142	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00148	eb 08		 jmp	 SHORT $LN27@encoder_cl
$LN50@encoder_cl:
  0014a	48 8b cb	 mov	 rcx, rbx
  0014d	e8 00 00 00 00	 call	 Px_DecRef
$LN27@encoder_cl:

; 1764 :     Py_CLEAR(s->encoder);

  00152	4c 8b 4f 70	 mov	 r9, QWORD PTR [rdi+112]
  00156	4d 85 c9	 test	 r9, r9
  00159	0f 84 92 00 00
	00		 je	 $LN23@encoder_cl
  0015f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DBJJFICM@encoder_clear?$AA@
  0016d	41 b8 e4 06 00
	00		 mov	 r8d, 1764		; 000006e4H
  00173	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0017b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00180	85 c0		 test	 eax, eax
  00182	75 6d		 jne	 SHORT $LN23@encoder_cl
  00184	48 8b 5f 70	 mov	 rbx, QWORD PTR [rdi+112]
  00188	48 89 77 70	 mov	 QWORD PTR [rdi+112], rsi
  0018c	e8 00 00 00 00	 call	 _Py_PXCTX
  00191	85 c0		 test	 eax, eax
  00193	75 5c		 jne	 SHORT $LN23@encoder_cl
  00195	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00199	a8 20		 test	 al, 32			; 00000020H
  0019b	75 4c		 jne	 SHORT $LN61@encoder_cl
  0019d	84 c0		 test	 al, al
  0019f	78 48		 js	 SHORT $LN61@encoder_cl
  001a1	a8 02		 test	 al, 2
  001a3	75 4c		 jne	 SHORT $LN23@encoder_cl
  001a5	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001a9	75 46		 jne	 SHORT $LN23@encoder_cl
  001ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001b9	4c 8b cb	 mov	 r9, rbx
  001bc	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001c2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001ca	e8 00 00 00 00	 call	 _PyParallel_Guard
  001cf	48 8b cb	 mov	 rcx, rbx
  001d2	85 c0		 test	 eax, eax
  001d4	74 07		 je	 SHORT $LN66@encoder_cl
  001d6	e8 00 00 00 00	 call	 _Px_Dealloc
  001db	eb 14		 jmp	 SHORT $LN23@encoder_cl
$LN66@encoder_cl:
  001dd	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001e1	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001e7	eb 08		 jmp	 SHORT $LN23@encoder_cl
$LN61@encoder_cl:
  001e9	48 8b cb	 mov	 rcx, rbx
  001ec	e8 00 00 00 00	 call	 Px_DecRef
$LN23@encoder_cl:

; 1765 :     Py_CLEAR(s->indent);

  001f1	4c 8b 4f 78	 mov	 r9, QWORD PTR [rdi+120]
  001f5	4d 85 c9	 test	 r9, r9
  001f8	0f 84 92 00 00
	00		 je	 $LN19@encoder_cl
  001fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00205	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DBJJFICM@encoder_clear?$AA@
  0020c	41 b8 e5 06 00
	00		 mov	 r8d, 1765		; 000006e5H
  00212	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0021a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0021f	85 c0		 test	 eax, eax
  00221	75 6d		 jne	 SHORT $LN19@encoder_cl
  00223	48 8b 5f 78	 mov	 rbx, QWORD PTR [rdi+120]
  00227	48 89 77 78	 mov	 QWORD PTR [rdi+120], rsi
  0022b	e8 00 00 00 00	 call	 _Py_PXCTX
  00230	85 c0		 test	 eax, eax
  00232	75 5c		 jne	 SHORT $LN19@encoder_cl
  00234	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00238	a8 20		 test	 al, 32			; 00000020H
  0023a	75 4c		 jne	 SHORT $LN72@encoder_cl
  0023c	84 c0		 test	 al, al
  0023e	78 48		 js	 SHORT $LN72@encoder_cl
  00240	a8 02		 test	 al, 2
  00242	75 4c		 jne	 SHORT $LN19@encoder_cl
  00244	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00248	75 46		 jne	 SHORT $LN19@encoder_cl
  0024a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00251	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00258	4c 8b cb	 mov	 r9, rbx
  0025b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00261	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00269	e8 00 00 00 00	 call	 _PyParallel_Guard
  0026e	48 8b cb	 mov	 rcx, rbx
  00271	85 c0		 test	 eax, eax
  00273	74 07		 je	 SHORT $LN77@encoder_cl
  00275	e8 00 00 00 00	 call	 _Px_Dealloc
  0027a	eb 14		 jmp	 SHORT $LN19@encoder_cl
$LN77@encoder_cl:
  0027c	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00280	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00286	eb 08		 jmp	 SHORT $LN19@encoder_cl
$LN72@encoder_cl:
  00288	48 8b cb	 mov	 rcx, rbx
  0028b	e8 00 00 00 00	 call	 Px_DecRef
$LN19@encoder_cl:

; 1766 :     Py_CLEAR(s->key_separator);

  00290	4c 8b 8f 80 00
	00 00		 mov	 r9, QWORD PTR [rdi+128]
  00297	4d 85 c9	 test	 r9, r9
  0029a	0f 84 98 00 00
	00		 je	 $LN15@encoder_cl
  002a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  002a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DBJJFICM@encoder_clear?$AA@
  002ae	41 b8 e6 06 00
	00		 mov	 r8d, 1766		; 000006e6H
  002b4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002bc	e8 00 00 00 00	 call	 _PyParallel_Guard
  002c1	85 c0		 test	 eax, eax
  002c3	75 73		 jne	 SHORT $LN15@encoder_cl
  002c5	48 8b 9f 80 00
	00 00		 mov	 rbx, QWORD PTR [rdi+128]
  002cc	48 89 b7 80 00
	00 00		 mov	 QWORD PTR [rdi+128], rsi
  002d3	e8 00 00 00 00	 call	 _Py_PXCTX
  002d8	85 c0		 test	 eax, eax
  002da	75 5c		 jne	 SHORT $LN15@encoder_cl
  002dc	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  002e0	a8 20		 test	 al, 32			; 00000020H
  002e2	75 4c		 jne	 SHORT $LN83@encoder_cl
  002e4	84 c0		 test	 al, al
  002e6	78 48		 js	 SHORT $LN83@encoder_cl
  002e8	a8 02		 test	 al, 2
  002ea	75 4c		 jne	 SHORT $LN15@encoder_cl
  002ec	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  002f0	75 46		 jne	 SHORT $LN15@encoder_cl
  002f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00300	4c 8b cb	 mov	 r9, rbx
  00303	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00309	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00311	e8 00 00 00 00	 call	 _PyParallel_Guard
  00316	48 8b cb	 mov	 rcx, rbx
  00319	85 c0		 test	 eax, eax
  0031b	74 07		 je	 SHORT $LN88@encoder_cl
  0031d	e8 00 00 00 00	 call	 _Px_Dealloc
  00322	eb 14		 jmp	 SHORT $LN15@encoder_cl
$LN88@encoder_cl:
  00324	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00328	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0032e	eb 08		 jmp	 SHORT $LN15@encoder_cl
$LN83@encoder_cl:
  00330	48 8b cb	 mov	 rcx, rbx
  00333	e8 00 00 00 00	 call	 Px_DecRef
$LN15@encoder_cl:

; 1767 :     Py_CLEAR(s->item_separator);

  00338	4c 8b 8f 88 00
	00 00		 mov	 r9, QWORD PTR [rdi+136]
  0033f	4d 85 c9	 test	 r9, r9
  00342	0f 84 98 00 00
	00		 je	 $LN11@encoder_cl
  00348	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  0034f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DBJJFICM@encoder_clear?$AA@
  00356	41 b8 e7 06 00
	00		 mov	 r8d, 1767		; 000006e7H
  0035c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00364	e8 00 00 00 00	 call	 _PyParallel_Guard
  00369	85 c0		 test	 eax, eax
  0036b	75 73		 jne	 SHORT $LN11@encoder_cl
  0036d	48 8b 9f 88 00
	00 00		 mov	 rbx, QWORD PTR [rdi+136]
  00374	48 89 b7 88 00
	00 00		 mov	 QWORD PTR [rdi+136], rsi
  0037b	e8 00 00 00 00	 call	 _Py_PXCTX
  00380	85 c0		 test	 eax, eax
  00382	75 5c		 jne	 SHORT $LN11@encoder_cl
  00384	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00388	a8 20		 test	 al, 32			; 00000020H
  0038a	75 4c		 jne	 SHORT $LN94@encoder_cl
  0038c	84 c0		 test	 al, al
  0038e	78 48		 js	 SHORT $LN94@encoder_cl
  00390	a8 02		 test	 al, 2
  00392	75 4c		 jne	 SHORT $LN11@encoder_cl
  00394	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00398	75 46		 jne	 SHORT $LN11@encoder_cl
  0039a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  003a8	4c 8b cb	 mov	 r9, rbx
  003ab	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  003b1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003b9	e8 00 00 00 00	 call	 _PyParallel_Guard
  003be	48 8b cb	 mov	 rcx, rbx
  003c1	85 c0		 test	 eax, eax
  003c3	74 07		 je	 SHORT $LN99@encoder_cl
  003c5	e8 00 00 00 00	 call	 _Px_Dealloc
  003ca	eb 14		 jmp	 SHORT $LN11@encoder_cl
$LN99@encoder_cl:
  003cc	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  003d0	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  003d6	eb 08		 jmp	 SHORT $LN11@encoder_cl
$LN94@encoder_cl:
  003d8	48 8b cb	 mov	 rcx, rbx
  003db	e8 00 00 00 00	 call	 Px_DecRef
$LN11@encoder_cl:

; 1768 :     Py_CLEAR(s->sort_keys);

  003e0	4c 8b 8f 90 00
	00 00		 mov	 r9, QWORD PTR [rdi+144]
  003e7	4d 85 c9	 test	 r9, r9
  003ea	0f 84 98 00 00
	00		 je	 $LN7@encoder_cl
  003f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  003f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DBJJFICM@encoder_clear?$AA@
  003fe	41 b8 e8 06 00
	00		 mov	 r8d, 1768		; 000006e8H
  00404	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0040c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00411	85 c0		 test	 eax, eax
  00413	75 73		 jne	 SHORT $LN7@encoder_cl
  00415	48 8b 9f 90 00
	00 00		 mov	 rbx, QWORD PTR [rdi+144]
  0041c	48 89 b7 90 00
	00 00		 mov	 QWORD PTR [rdi+144], rsi
  00423	e8 00 00 00 00	 call	 _Py_PXCTX
  00428	85 c0		 test	 eax, eax
  0042a	75 5c		 jne	 SHORT $LN7@encoder_cl
  0042c	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00430	a8 20		 test	 al, 32			; 00000020H
  00432	75 4c		 jne	 SHORT $LN105@encoder_cl
  00434	84 c0		 test	 al, al
  00436	78 48		 js	 SHORT $LN105@encoder_cl
  00438	a8 02		 test	 al, 2
  0043a	75 4c		 jne	 SHORT $LN7@encoder_cl
  0043c	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00440	75 46		 jne	 SHORT $LN7@encoder_cl
  00442	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00449	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00450	4c 8b cb	 mov	 r9, rbx
  00453	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00459	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00461	e8 00 00 00 00	 call	 _PyParallel_Guard
  00466	48 8b cb	 mov	 rcx, rbx
  00469	85 c0		 test	 eax, eax
  0046b	74 07		 je	 SHORT $LN110@encoder_cl
  0046d	e8 00 00 00 00	 call	 _Px_Dealloc
  00472	eb 14		 jmp	 SHORT $LN7@encoder_cl
$LN110@encoder_cl:
  00474	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00478	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0047e	eb 08		 jmp	 SHORT $LN7@encoder_cl
$LN105@encoder_cl:
  00480	48 8b cb	 mov	 rcx, rbx
  00483	e8 00 00 00 00	 call	 Px_DecRef
$LN7@encoder_cl:

; 1769 :     Py_CLEAR(s->skipkeys);

  00488	4c 8b 8f 98 00
	00 00		 mov	 r9, QWORD PTR [rdi+152]
  0048f	4d 85 c9	 test	 r9, r9
  00492	0f 84 bc 00 00
	00		 je	 $LN125@encoder_cl
  00498	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  0049f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DBJJFICM@encoder_clear?$AA@
  004a6	41 b8 e9 06 00
	00		 mov	 r8d, 1769		; 000006e9H
  004ac	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004b4	e8 00 00 00 00	 call	 _PyParallel_Guard
  004b9	85 c0		 test	 eax, eax
  004bb	0f 85 93 00 00
	00		 jne	 $LN125@encoder_cl
  004c1	48 8b 9f 98 00
	00 00		 mov	 rbx, QWORD PTR [rdi+152]
  004c8	48 89 b7 98 00
	00 00		 mov	 QWORD PTR [rdi+152], rsi
  004cf	e8 00 00 00 00	 call	 _Py_PXCTX
  004d4	85 c0		 test	 eax, eax
  004d6	75 7c		 jne	 SHORT $LN125@encoder_cl
  004d8	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  004dc	a8 20		 test	 al, 32			; 00000020H
  004de	75 6c		 jne	 SHORT $LN116@encoder_cl
  004e0	84 c0		 test	 al, al
  004e2	78 68		 js	 SHORT $LN116@encoder_cl
  004e4	a8 02		 test	 al, 2
  004e6	75 6c		 jne	 SHORT $LN125@encoder_cl
  004e8	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  004ec	75 66		 jne	 SHORT $LN125@encoder_cl
  004ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  004f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  004fc	4c 8b cb	 mov	 r9, rbx
  004ff	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00505	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0050d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00512	48 8b cb	 mov	 rcx, rbx
  00515	85 c0		 test	 eax, eax
  00517	74 17		 je	 SHORT $LN121@encoder_cl
  00519	e8 00 00 00 00	 call	 _Px_Dealloc

; 1770 :     return 0;

  0051e	33 c0		 xor	 eax, eax

; 1771 : }

  00520	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00525	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0052a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0052e	5f		 pop	 rdi
  0052f	c3		 ret	 0

; 1769 :     Py_CLEAR(s->skipkeys);

$LN121@encoder_cl:
  00530	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00534	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 1770 :     return 0;

  0053a	33 c0		 xor	 eax, eax

; 1771 : }

  0053c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00541	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00546	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0054a	5f		 pop	 rdi
  0054b	c3		 ret	 0

; 1769 :     Py_CLEAR(s->skipkeys);

$LN116@encoder_cl:
  0054c	48 8b cb	 mov	 rcx, rbx
  0054f	e8 00 00 00 00	 call	 Px_DecRef
$LN125@encoder_cl:

; 1771 : }

  00554	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00559	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0055e	33 c0		 xor	 eax, eax
  00560	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00564	5f		 pop	 rdi
  00565	c3		 ret	 0
encoder_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@NCKCAFDB@make_encoder?$AA@		; `string'
PUBLIC	??_C@_0N@BGLEDEIC@make_scanner?$AA@		; `string'
PUBLIC	PyInit__json
EXTRN	PyModule_AddObject:PROC
EXTRN	PyType_Ready:PROC
EXTRN	PyType_GenericNew:PROC
EXTRN	PyModule_Create2:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyInit__json DD imagerel $LN18
	DD	imagerel $LN18+37
	DD	imagerel $unwind$PyInit__json
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyInit__json DD imagerel $LN18+37
	DD	imagerel $LN18+227
	DD	imagerel $chain$0$PyInit__json
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyInit__json DD imagerel $LN18+227
	DD	imagerel $LN18+348
	DD	imagerel $chain$2$PyInit__json
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyInit__json DD 020021H
	DD	087400H
	DD	imagerel $LN18
	DD	imagerel $LN18+37
	DD	imagerel $unwind$PyInit__json
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyInit__json DD 020521H
	DD	087405H
	DD	imagerel $LN18
	DD	imagerel $LN18+37
	DD	imagerel $unwind$PyInit__json
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__json DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0N@NCKCAFDB@make_encoder?$AA@
CONST	SEGMENT
??_C@_0N@NCKCAFDB@make_encoder?$AA@ DB 'make_encoder', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BGLEDEIC@make_scanner?$AA@
CONST	SEGMENT
??_C@_0N@BGLEDEIC@make_scanner?$AA@ DB 'make_scanner', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_json.c
CONST	ENDS
;	COMDAT PyInit__json
_TEXT	SEGMENT
PyInit__json PROC					; COMDAT

; 1847 : {

$LN18:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1848 :     PyObject *m = PyModule_Create(&jsonmodule);

  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:jsonmodule
  0000d	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00012	e8 00 00 00 00	 call	 PyModule_Create2
  00017	48 8b d8	 mov	 rbx, rax

; 1849 :     if (!m)

  0001a	48 85 c0	 test	 rax, rax
  0001d	75 06		 jne	 SHORT $LN5@PyInit__js

; 1871 : }

  0001f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00023	5b		 pop	 rbx
  00024	c3		 ret	 0
$LN5@PyInit__js:
  00025	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 1850 :         return NULL;
; 1851 :     PyScannerType.tp_new = PyType_GenericNew;

  0002a	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:PyType_GenericNew

; 1852 :     if (PyType_Ready(&PyScannerType) < 0)

  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyScannerType
  00038	48 89 3d 90 01
	00 00		 mov	 QWORD PTR PyScannerType+400, rdi
  0003f	e8 00 00 00 00	 call	 PyType_Ready
  00044	85 c0		 test	 eax, eax
  00046	0f 88 82 00 00
	00		 js	 $fail$22682

; 1853 :         goto fail;
; 1854 :     PyEncoderType.tp_new = PyType_GenericNew;
; 1855 :     if (PyType_Ready(&PyEncoderType) < 0)

  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyEncoderType
  00053	48 89 3d 90 01
	00 00		 mov	 QWORD PTR PyEncoderType+400, rdi
  0005a	e8 00 00 00 00	 call	 PyType_Ready
  0005f	85 c0		 test	 eax, eax
  00061	78 6b		 js	 SHORT $fail$22682

; 1856 :         goto fail;
; 1857 :     Py_INCREF((PyObject*)&PyScannerType);

  00063	e8 00 00 00 00	 call	 _Py_PXCTX
  00068	85 c0		 test	 eax, eax
  0006a	75 3c		 jne	 SHORT $LN9@PyInit__js
  0006c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyScannerType
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00081	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00087	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00094	85 c0		 test	 eax, eax
  00096	75 09		 jne	 SHORT $LN8@PyInit__js
  00098	f6 05 20 00 00
	00 20		 test	 BYTE PTR PyScannerType+32, 32 ; 00000020H
  0009f	74 07		 je	 SHORT $LN9@PyInit__js
$LN8@PyInit__js:
  000a1	48 ff 05 50 00
	00 00		 inc	 QWORD PTR PyScannerType+80
$LN9@PyInit__js:

; 1858 :     if (PyModule_AddObject(m, "make_scanner", (PyObject*)&PyScannerType) < 0) {

  000a8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyScannerType
  000af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@BGLEDEIC@make_scanner?$AA@
  000b6	48 8b cb	 mov	 rcx, rbx
  000b9	e8 00 00 00 00	 call	 PyModule_AddObject
  000be	85 c0		 test	 eax, eax
  000c0	79 21		 jns	 SHORT $LN2@PyInit__js

; 1859 :         Py_DECREF((PyObject*)&PyScannerType);

  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyScannerType
$LN17@PyInit__js:

; 1864 :         Py_DECREF((PyObject*)&PyEncoderType);

  000c9	e8 00 00 00 00	 call	 _Py_DecRef
$fail$22682:

; 1868 :   fail:
; 1869 :     Py_DECREF(m);

  000ce	48 8b cb	 mov	 rcx, rbx
  000d1	e8 00 00 00 00	 call	 _Py_DecRef
  000d6	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 1870 :     return NULL;

  000db	33 c0		 xor	 eax, eax

; 1871 : }

  000dd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e1	5b		 pop	 rbx
  000e2	c3		 ret	 0
$LN2@PyInit__js:

; 1860 :         goto fail;
; 1861 :     }
; 1862 :     Py_INCREF((PyObject*)&PyEncoderType);

  000e3	e8 00 00 00 00	 call	 _Py_PXCTX
  000e8	85 c0		 test	 eax, eax
  000ea	75 3c		 jne	 SHORT $LN13@PyInit__js
  000ec	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyEncoderType
  000f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00101	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00107	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0010f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00114	85 c0		 test	 eax, eax
  00116	75 09		 jne	 SHORT $LN12@PyInit__js
  00118	f6 05 20 00 00
	00 20		 test	 BYTE PTR PyEncoderType+32, 32 ; 00000020H
  0011f	74 07		 je	 SHORT $LN13@PyInit__js
$LN12@PyInit__js:
  00121	48 ff 05 50 00
	00 00		 inc	 QWORD PTR PyEncoderType+80
$LN13@PyInit__js:

; 1863 :     if (PyModule_AddObject(m, "make_encoder", (PyObject*)&PyEncoderType) < 0) {

  00128	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyEncoderType
  0012f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@NCKCAFDB@make_encoder?$AA@
  00136	48 8b cb	 mov	 rcx, rbx
  00139	e8 00 00 00 00	 call	 PyModule_AddObject
  0013e	85 c0		 test	 eax, eax
  00140	79 0c		 jns	 SHORT $LN1@PyInit__js

; 1864 :         Py_DECREF((PyObject*)&PyEncoderType);

  00142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyEncoderType
  00149	e9 7b ff ff ff	 jmp	 $LN17@PyInit__js
$LN1@PyInit__js:

; 1865 :         goto fail;
; 1866 :     }
; 1867 :     return m;

  0014e	48 8b c3	 mov	 rax, rbx
  00151	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 1871 : }

  00156	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0015a	5b		 pop	 rbx
  0015b	c3		 ret	 0
PyInit__json ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$scanner_dealloc DD imagerel scanner_dealloc
	DD	imagerel scanner_dealloc+33
	DD	imagerel $unwind$scanner_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scanner_dealloc DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT scanner_dealloc
_TEXT	SEGMENT
self$ = 48
scanner_dealloc PROC					; COMDAT

; 559  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 560  :     /* Deallocate scanner object */
; 561  :     scanner_clear(self);

  00009	e8 00 00 00 00	 call	 scanner_clear

; 562  :     Py_TYPE(self)->tp_free(self);

  0000e	4c 8b 5b 58	 mov	 r11, QWORD PTR [rbx+88]
  00012	48 8b cb	 mov	 rcx, rbx

; 563  : }

  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5b		 pop	 rbx
  0001a	49 ff a3 98 01
	00 00		 rex_jmp QWORD PTR [r11+408]
scanner_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@PDLAPALN@?5while?5encoding?5a?5JSON?5object?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$encoder_listencode_obj DD imagerel encoder_listencode_obj
	DD	imagerel encoder_listencode_obj+897
	DD	imagerel $unwind$encoder_listencode_obj
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encoder_listencode_obj DD 081901H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	070153219H
xdata	ENDS
;	COMDAT ??_C@_0BO@PDLAPALN@?5while?5encoding?5a?5JSON?5object?$AA@
CONST	SEGMENT
??_C@_0BO@PDLAPALN@?5while?5encoding?5a?5JSON?5object?$AA@ DB ' while enc'
	DB	'oding a JSON object', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT encoder_listencode_obj
_TEXT	SEGMENT
s$ = 48
acc$ = 56
obj$ = 64
indent_level$ = 72
encoder_listencode_obj PROC				; COMDAT

; 1374 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1375 :     /* Encode Python object obj to a JSON term */
; 1376 :     PyObject *newobj;
; 1377 :     int rv;
; 1378 : 
; 1379 :     if (obj == Py_None || obj == Py_True || obj == Py_False) {

  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00020	49 8b d9	 mov	 rbx, r9
  00023	49 8b f8	 mov	 rdi, r8
  00026	48 8b ea	 mov	 rbp, rdx
  00029	48 8b f1	 mov	 rsi, rcx
  0002c	4c 3b c0	 cmp	 r8, rax
  0002f	0f 84 1b 03 00
	00		 je	 $LN58@encoder_li@2
  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  0003c	4c 3b c0	 cmp	 r8, rax
  0003f	0f 84 0b 03 00
	00		 je	 $LN58@encoder_li@2
  00045	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0004c	4c 3b c0	 cmp	 r8, rax
  0004f	0f 84 fb 02 00
	00		 je	 $LN58@encoder_li@2

; 1384 :     }
; 1385 :     else if (PyUnicode_Check(obj))

  00055	49 8b 48 58	 mov	 rcx, QWORD PTR [r8+88]
  00059	8b 81 00 01 00
	00		 mov	 eax, DWORD PTR [rcx+256]
  0005f	0f ba e0 1c	 bt	 eax, 28
  00063	73 10		 jae	 SHORT $LN55@encoder_li@2

; 1386 :     {
; 1387 :         PyObject *encoded = encoder_encode_string(s, obj);

  00065	49 8b d0	 mov	 rdx, r8
  00068	48 8b ce	 mov	 rcx, rsi
  0006b	e8 00 00 00 00	 call	 encoder_encode_string

; 1388 :         if (encoded == NULL)
; 1389 :             return -1;
; 1390 :         return _steal_accumulate(acc, encoded);

  00070	e9 e3 02 00 00	 jmp	 $LN88@encoder_li@2
$LN55@encoder_li@2:

; 1391 :     }
; 1392 :     else if (PyLong_Check(obj)) {

  00075	0f ba e0 18	 bt	 eax, 24
  00079	73 0d		 jae	 SHORT $LN52@encoder_li@2

; 1393 :         PyObject *encoded = PyObject_Str(obj);

  0007b	49 8b c8	 mov	 rcx, r8
  0007e	e8 00 00 00 00	 call	 PyObject_Str

; 1394 :         if (encoded == NULL)
; 1395 :             return -1;
; 1396 :         return _steal_accumulate(acc, encoded);

  00083	e9 d0 02 00 00	 jmp	 $LN88@encoder_li@2
$LN52@encoder_li@2:

; 1397 :     }
; 1398 :     else if (PyFloat_Check(obj)) {

  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0008f	48 3b ca	 cmp	 rcx, rdx
  00092	0f 84 ab 02 00
	00		 je	 $LN48@encoder_li@2
  00098	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009d	85 c0		 test	 eax, eax
  0009f	0f 85 9e 02 00
	00		 jne	 $LN48@encoder_li@2

; 1403 :     }
; 1404 :     else if (PyList_Check(obj) || PyTuple_Check(obj)) {

  000a5	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  000a9	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  000af	0f ba e1 19	 bt	 ecx, 25
  000b3	0f 82 df 01 00
	00		 jb	 $LN44@encoder_li@2
  000b9	0f ba e1 1a	 bt	 ecx, 26
  000bd	0f 82 d5 01 00
	00		 jb	 $LN44@encoder_li@2

; 1410 :     }
; 1411 :     else if (PyDict_Check(obj)) {

  000c3	0f ba e1 1d	 bt	 ecx, 29
  000c7	73 62		 jae	 SHORT $LN37@encoder_li@2

; 1412 :         if (Py_EnterRecursiveCall(" while encoding a JSON object"))

  000c9	e8 00 00 00 00	 call	 _Py_PXCTX
  000ce	85 c0		 test	 eax, eax
  000d0	74 07		 je	 SHORT $LN70@encoder_li@2
  000d2	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  000d7	eb 07		 jmp	 SHORT $LN71@encoder_li@2
$LN70@encoder_li@2:
  000d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN71@encoder_li@2:
  000e0	ff 40 18	 inc	 DWORD PTR [rax+24]
  000e3	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000e6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  000ec	7e 10		 jle	 SHORT $LN36@encoder_li@2
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@PDLAPALN@?5while?5encoding?5a?5JSON?5object?$AA@
  000f5	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  000fa	85 c0		 test	 eax, eax

; 1413 :             return -1;

  000fc	75 7c		 jne	 SHORT $LN89@encoder_li@2
$LN36@encoder_li@2:

; 1414 :         rv = encoder_listencode_dict(s, acc, obj, indent_level);

  000fe	4c 8b cb	 mov	 r9, rbx
  00101	4c 8b c7	 mov	 r8, rdi
  00104	48 8b d5	 mov	 rdx, rbp
  00107	48 8b ce	 mov	 rcx, rsi
  0010a	e8 00 00 00 00	 call	 encoder_listencode_dict
  0010f	8b d8		 mov	 ebx, eax

; 1415 :         Py_LeaveRecursiveCall();

  00111	e8 00 00 00 00	 call	 _Py_PXCTX
  00116	85 c0		 test	 eax, eax
  00118	0f 84 d9 01 00
	00		 je	 $LN64@encoder_li@2
  0011e	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00123	4c 8b d8	 mov	 r11, rax
  00126	e9 d3 01 00 00	 jmp	 $LN65@encoder_li@2
$LN37@encoder_li@2:

; 1416 :         return rv;
; 1417 :     }
; 1418 :     else {
; 1419 :         PyObject *ident = NULL;
; 1420 :         if (s->markers != Py_None) {

  0012b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00132	33 db		 xor	 ebx, ebx
  00134	48 39 46 60	 cmp	 QWORD PTR [rsi+96], rax
  00138	74 5b		 je	 SHORT $LN26@encoder_li@2

; 1421 :             int has_key;
; 1422 :             ident = PyLong_FromVoidPtr(obj);

  0013a	48 8b cf	 mov	 rcx, rdi
  0013d	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
  00142	48 8b d8	 mov	 rbx, rax

; 1423 :             if (ident == NULL)

  00145	48 85 c0	 test	 rax, rax

; 1424 :                 return -1;

  00148	74 30		 je	 SHORT $LN89@encoder_li@2

; 1425 :             has_key = PyDict_Contains(s->markers, ident);

  0014a	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  0014e	48 8b d0	 mov	 rdx, rax
  00151	e8 00 00 00 00	 call	 PyDict_Contains

; 1426 :             if (has_key) {

  00156	85 c0		 test	 eax, eax
  00158	74 28		 je	 SHORT $LN28@encoder_li@2

; 1427 :                 if (has_key != -1)

  0015a	83 f8 ff	 cmp	 eax, -1
  0015d	74 13		 je	 SHORT $LN27@encoder_li@2

; 1428 :                     PyErr_SetString(PyExc_ValueError, "Circular reference detected");

  0015f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00166	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@PEOODJKM@Circular?5reference?5detected?$AA@
  0016d	e8 00 00 00 00	 call	 PyErr_SetString
$LN27@encoder_li@2:

; 1429 :                 Py_DECREF(ident);

  00172	48 8b cb	 mov	 rcx, rbx
$LN90@encoder_li@2:
  00175	e8 00 00 00 00	 call	 _Py_DecRef
$LN89@encoder_li@2:

; 1430 :                 return -1;

  0017a	83 c8 ff	 or	 eax, -1
  0017d	e9 ea 01 00 00	 jmp	 $LN31@encoder_li@2
$LN28@encoder_li@2:

; 1431 :             }
; 1432 :             if (PyDict_SetItem(s->markers, ident, obj)) {

  00182	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  00186	4c 8b c7	 mov	 r8, rdi
  00189	48 8b d3	 mov	 rdx, rbx
  0018c	e8 00 00 00 00	 call	 PyDict_SetItem
  00191	85 c0		 test	 eax, eax

; 1433 :                 Py_DECREF(ident);
; 1434 :                 return -1;

  00193	75 dd		 jne	 SHORT $LN27@encoder_li@2
$LN26@encoder_li@2:

; 1435 :             }
; 1436 :         }
; 1437 :         newobj = PyObject_CallFunctionObjArgs(s->defaultfn, obj, NULL);

  00195	48 8b 4e 68	 mov	 rcx, QWORD PTR [rsi+104]
  00199	45 33 c0	 xor	 r8d, r8d
  0019c	48 8b d7	 mov	 rdx, rdi
  0019f	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  001a4	48 8b f8	 mov	 rdi, rax

; 1438 :         if (newobj == NULL) {

  001a7	48 85 c0	 test	 rax, rax
  001aa	75 15		 jne	 SHORT $LN25@encoder_li@2
$LN91@encoder_li@2:

; 1439 :             Py_XDECREF(ident);

  001ac	48 85 db	 test	 rbx, rbx
  001af	74 c9		 je	 SHORT $LN89@encoder_li@2
  001b1	48 8b cb	 mov	 rcx, rbx
  001b4	e8 00 00 00 00	 call	 _Py_DecRef

; 1440 :             return -1;

  001b9	83 c8 ff	 or	 eax, -1
  001bc	e9 ab 01 00 00	 jmp	 $LN31@encoder_li@2
$LN25@encoder_li@2:

; 1441 :         }
; 1442 : 
; 1443 :         if (Py_EnterRecursiveCall(" while encoding a JSON object"))

  001c1	e8 00 00 00 00	 call	 _Py_PXCTX
  001c6	85 c0		 test	 eax, eax
  001c8	74 07		 je	 SHORT $LN78@encoder_li@2
  001ca	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  001cf	eb 07		 jmp	 SHORT $LN79@encoder_li@2
$LN78@encoder_li@2:
  001d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN79@encoder_li@2:
  001d8	ff 40 18	 inc	 DWORD PTR [rax+24]
  001db	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  001de	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  001e4	7e 10		 jle	 SHORT $LN20@encoder_li@2
  001e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@PDLAPALN@?5while?5encoding?5a?5JSON?5object?$AA@
  001ed	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  001f2	85 c0		 test	 eax, eax

; 1444 :             return -1;

  001f4	75 84		 jne	 SHORT $LN89@encoder_li@2
$LN20@encoder_li@2:

; 1445 :         rv = encoder_listencode_obj(s, acc, newobj, indent_level);

  001f6	4c 8b 4c 24 48	 mov	 r9, QWORD PTR indent_level$[rsp]
  001fb	4c 8b c7	 mov	 r8, rdi
  001fe	48 8b d5	 mov	 rdx, rbp
  00201	48 8b ce	 mov	 rcx, rsi
  00204	e8 00 00 00 00	 call	 encoder_listencode_obj
  00209	8b e8		 mov	 ebp, eax

; 1446 :         Py_LeaveRecursiveCall();

  0020b	e8 00 00 00 00	 call	 _Py_PXCTX
  00210	85 c0		 test	 eax, eax
  00212	74 0a		 je	 SHORT $LN80@encoder_li@2
  00214	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00219	4c 8b d8	 mov	 r11, rax
  0021c	eb 07		 jmp	 SHORT $LN81@encoder_li@2
$LN80@encoder_li@2:
  0021e	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _PyThreadState_Current
$LN81@encoder_li@2:
  00225	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  0022b	83 f8 64	 cmp	 eax, 100		; 00000064H
  0022e	7e 05		 jle	 SHORT $LN82@encoder_li@2
  00230	83 c0 ce	 add	 eax, -50		; ffffffffffffffceH
  00233	eb 06		 jmp	 SHORT $LN83@encoder_li@2
$LN82@encoder_li@2:
  00235	c1 f8 02	 sar	 eax, 2
  00238	8d 04 40	 lea	 eax, DWORD PTR [rax+rax*2]
$LN83@encoder_li@2:
  0023b	41 ff 4b 18	 dec	 DWORD PTR [r11+24]
  0023f	41 39 43 18	 cmp	 DWORD PTR [r11+24], eax
  00243	7d 1b		 jge	 SHORT $LN18@encoder_li@2
  00245	e8 00 00 00 00	 call	 _Py_PXCTX
  0024a	85 c0		 test	 eax, eax
  0024c	74 07		 je	 SHORT $LN84@encoder_li@2
  0024e	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00253	eb 07		 jmp	 SHORT $LN85@encoder_li@2
$LN84@encoder_li@2:
  00255	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN85@encoder_li@2:
  0025c	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN18@encoder_li@2:

; 1447 : 
; 1448 :         Py_DECREF(newobj);

  00260	48 8b cf	 mov	 rcx, rdi
  00263	e8 00 00 00 00	 call	 _Py_DecRef

; 1449 :         if (rv) {

  00268	85 ed		 test	 ebp, ebp

; 1450 :             Py_XDECREF(ident);
; 1451 :             return -1;

  0026a	0f 85 3c ff ff
	ff		 jne	 $LN91@encoder_li@2

; 1452 :         }
; 1453 :         if (ident != NULL) {

  00270	48 85 db	 test	 rbx, rbx
  00273	74 1c		 je	 SHORT $LN2@encoder_li@2

; 1454 :             if (PyDict_DelItem(s->markers, ident)) {

  00275	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  00279	48 8b d3	 mov	 rdx, rbx
  0027c	e8 00 00 00 00	 call	 PyDict_DelItem

; 1455 :                 Py_XDECREF(ident);

  00281	48 8b cb	 mov	 rcx, rbx
  00284	85 c0		 test	 eax, eax

; 1456 :                 return -1;

  00286	0f 85 e9 fe ff
	ff		 jne	 $LN90@encoder_li@2

; 1457 :             }
; 1458 :             Py_XDECREF(ident);

  0028c	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@encoder_li@2:

; 1459 :         }
; 1460 :         return rv;

  00291	33 c0		 xor	 eax, eax
  00293	e9 d4 00 00 00	 jmp	 $LN31@encoder_li@2
$LN44@encoder_li@2:

; 1405 :         if (Py_EnterRecursiveCall(" while encoding a JSON object"))

  00298	e8 00 00 00 00	 call	 _Py_PXCTX
  0029d	85 c0		 test	 eax, eax
  0029f	74 07		 je	 SHORT $LN62@encoder_li@2
  002a1	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  002a6	eb 07		 jmp	 SHORT $LN63@encoder_li@2
$LN62@encoder_li@2:
  002a8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN63@encoder_li@2:
  002af	ff 40 18	 inc	 DWORD PTR [rax+24]
  002b2	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  002b5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  002bb	7e 14		 jle	 SHORT $LN43@encoder_li@2
  002bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@PDLAPALN@?5while?5encoding?5a?5JSON?5object?$AA@
  002c4	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  002c9	85 c0		 test	 eax, eax

; 1406 :             return -1;

  002cb	0f 85 a9 fe ff
	ff		 jne	 $LN89@encoder_li@2
$LN43@encoder_li@2:

; 1407 :         rv = encoder_listencode_list(s, acc, obj, indent_level);

  002d1	4c 8b cb	 mov	 r9, rbx
  002d4	4c 8b c7	 mov	 r8, rdi
  002d7	48 8b d5	 mov	 rdx, rbp
  002da	48 8b ce	 mov	 rcx, rsi
  002dd	e8 00 00 00 00	 call	 encoder_listencode_list
  002e2	8b d8		 mov	 ebx, eax

; 1408 :         Py_LeaveRecursiveCall();

  002e4	e8 00 00 00 00	 call	 _Py_PXCTX
  002e9	85 c0		 test	 eax, eax
  002eb	74 0a		 je	 SHORT $LN64@encoder_li@2
  002ed	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  002f2	4c 8b d8	 mov	 r11, rax
  002f5	eb 07		 jmp	 SHORT $LN65@encoder_li@2
$LN64@encoder_li@2:
  002f7	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _PyThreadState_Current
$LN65@encoder_li@2:
  002fe	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  00304	83 f8 64	 cmp	 eax, 100		; 00000064H
  00307	7e 05		 jle	 SHORT $LN66@encoder_li@2
  00309	83 c0 ce	 add	 eax, -50		; ffffffffffffffceH
  0030c	eb 06		 jmp	 SHORT $LN67@encoder_li@2
$LN66@encoder_li@2:
  0030e	c1 f8 02	 sar	 eax, 2
  00311	8d 04 40	 lea	 eax, DWORD PTR [rax+rax*2]
$LN67@encoder_li@2:
  00314	41 ff 4b 18	 dec	 DWORD PTR [r11+24]
  00318	41 39 43 18	 cmp	 DWORD PTR [r11+24], eax
  0031c	7d 21		 jge	 SHORT $LN41@encoder_li@2
  0031e	e8 00 00 00 00	 call	 _Py_PXCTX
  00323	85 c0		 test	 eax, eax
  00325	74 0d		 je	 SHORT $LN68@encoder_li@2
  00327	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0032c	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0

; 1409 :         return rv;

  00330	8b c3		 mov	 eax, ebx
  00332	eb 38		 jmp	 SHORT $LN31@encoder_li@2
$LN68@encoder_li@2:

; 1408 :         Py_LeaveRecursiveCall();

  00334	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
  0033b	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN41@encoder_li@2:

; 1409 :         return rv;

  0033f	8b c3		 mov	 eax, ebx
  00341	eb 29		 jmp	 SHORT $LN31@encoder_li@2
$LN48@encoder_li@2:

; 1399 :         PyObject *encoded = encoder_encode_float(s, obj);

  00343	48 8b d7	 mov	 rdx, rdi
  00346	48 8b ce	 mov	 rcx, rsi
  00349	e8 00 00 00 00	 call	 encoder_encode_float

; 1400 :         if (encoded == NULL)
; 1401 :             return -1;
; 1402 :         return _steal_accumulate(acc, encoded);

  0034e	eb 08		 jmp	 SHORT $LN88@encoder_li@2
$LN58@encoder_li@2:

; 1380 :         PyObject *cstr = _encoded_const(obj);

  00350	49 8b c8	 mov	 rcx, r8
  00353	e8 00 00 00 00	 call	 _encoded_const
$LN88@encoder_li@2:

; 1381 :         if (cstr == NULL)

  00358	48 85 c0	 test	 rax, rax

; 1382 :             return -1;

  0035b	0f 84 19 fe ff
	ff		 je	 $LN89@encoder_li@2

; 1383 :         return _steal_accumulate(acc, cstr);

  00361	48 8b d0	 mov	 rdx, rax
  00364	48 8b cd	 mov	 rcx, rbp
  00367	e8 00 00 00 00	 call	 _steal_accumulate
$LN31@encoder_li@2:

; 1461 :     }
; 1462 : }

  0036c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00371	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00376	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0037b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0037f	5f		 pop	 rdi
  00380	c3		 ret	 0
encoder_listencode_obj ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@JMNCMNPK@encoder_listencode_list?$AA@	; `string'
PUBLIC	??_C@_0CC@BFEMEHI@_iterencode_list?5needs?5a?5sequenc@ ; `string'
PUBLIC	??_C@_02GPECMEKF@?$FL?$FN?$AA@			; `string'
PUBLIC	??_C@_01LBDDMOBJ@?$FN?$AA@			; `string'
PUBLIC	??_C@_01OHGJGJJP@?$FL?$AA@			; `string'
EXTRN	PySequence_Fast:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$encoder_listencode_list DD imagerel encoder_listencode_list
	DD	imagerel encoder_listencode_list+158
	DD	imagerel $unwind$encoder_listencode_list
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$encoder_listencode_list DD imagerel encoder_listencode_list+158
	DD	imagerel encoder_listencode_list+242
	DD	imagerel $chain$1$encoder_listencode_list
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$encoder_listencode_list DD imagerel encoder_listencode_list+242
	DD	imagerel encoder_listencode_list+351
	DD	imagerel $chain$2$encoder_listencode_list
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$encoder_listencode_list DD imagerel encoder_listencode_list+351
	DD	imagerel encoder_listencode_list+377
	DD	imagerel $chain$3$encoder_listencode_list
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$encoder_listencode_list DD imagerel encoder_listencode_list+377
	DD	imagerel encoder_listencode_list+649
	DD	imagerel $chain$5$encoder_listencode_list
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$encoder_listencode_list DD imagerel encoder_listencode_list+649
	DD	imagerel encoder_listencode_list+668
	DD	imagerel $chain$6$encoder_listencode_list
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$encoder_listencode_list DD 021H
	DD	imagerel encoder_listencode_list
	DD	imagerel encoder_listencode_list+158
	DD	imagerel $unwind$encoder_listencode_list
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$encoder_listencode_list DD 060021H
	DD	0c6400H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel encoder_listencode_list
	DD	imagerel encoder_listencode_list+158
	DD	imagerel $unwind$encoder_listencode_list
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$encoder_listencode_list DD 021H
	DD	imagerel encoder_listencode_list+158
	DD	imagerel encoder_listencode_list+242
	DD	imagerel $chain$1$encoder_listencode_list
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$encoder_listencode_list DD 020521H
	DD	0c6405H
	DD	imagerel encoder_listencode_list+158
	DD	imagerel encoder_listencode_list+242
	DD	imagerel $chain$1$encoder_listencode_list
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$encoder_listencode_list DD 040d21H
	DD	0b540dH
	DD	0a3405H
	DD	imagerel encoder_listencode_list
	DD	imagerel encoder_listencode_list+158
	DD	imagerel $unwind$encoder_listencode_list
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encoder_listencode_list DD 060f01H
	DD	0d740fH
	DD	0e00b520fH
	DD	0c007d009H
xdata	ENDS
;	COMDAT ??_C@_0BI@JMNCMNPK@encoder_listencode_list?$AA@
CONST	SEGMENT
??_C@_0BI@JMNCMNPK@encoder_listencode_list?$AA@ DB 'encoder_listencode_li'
	DB	'st', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BFEMEHI@_iterencode_list?5needs?5a?5sequenc@
CONST	SEGMENT
??_C@_0CC@BFEMEHI@_iterencode_list?5needs?5a?5sequenc@ DB '_iterencode_li'
	DB	'st needs a sequence', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GPECMEKF@?$FL?$FN?$AA@
CONST	SEGMENT
??_C@_02GPECMEKF@?$FL?$FN?$AA@ DB '[]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN?$AA@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN?$AA@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL?$AA@
CONST	SEGMENT
??_C@_01OHGJGJJP@?$FL?$AA@ DB '[', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT encoder_listencode_list
_TEXT	SEGMENT
s$ = 80
acc$ = 88
seq$ = 96
indent_level$ = 104
encoder_listencode_list PROC				; COMDAT

; 1646 : {

  00000	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1647 :     /* Encode Python list seq to a JSON term */
; 1648 :     static PyObject *open_array = NULL;
; 1649 :     static PyObject *close_array = NULL;
; 1650 :     static PyObject *empty_array = NULL;
; 1651 :     PyObject *ident = NULL;
; 1652 :     PyObject *s_fast = NULL;
; 1653 :     Py_ssize_t i;
; 1654 : 
; 1655 :     if (open_array == NULL || close_array == NULL || empty_array == NULL) {

  0000f	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?open_array@?1??encoder_listencode_list@@9@9, 0
  00017	4d 8b f1	 mov	 r14, r9
  0001a	49 8b f8	 mov	 rdi, r8
  0001d	4c 8b ea	 mov	 r13, rdx
  00020	4c 8b e1	 mov	 r12, rcx
  00023	74 14		 je	 SHORT $LN29@encoder_li@3
  00025	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?close_array@?1??encoder_listencode_list@@9@9, 0
  0002d	74 0a		 je	 SHORT $LN29@encoder_li@3
  0002f	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?empty_array@?1??encoder_listencode_list@@9@9, 0
  00037	75 5e		 jne	 SHORT $LN28@encoder_li@3
$LN29@encoder_li@3:

; 1656 :         open_array = PyUnicode_InternFromString("[");

  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01OHGJGJJP@?$FL?$AA@
  00040	e8 00 00 00 00	 call	 PyUnicode_InternFromString

; 1657 :         close_array = PyUnicode_InternFromString("]");

  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01LBDDMOBJ@?$FN?$AA@
  0004c	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?open_array@?1??encoder_listencode_list@@9@9, rax
  00053	e8 00 00 00 00	 call	 PyUnicode_InternFromString

; 1658 :         empty_array = PyUnicode_InternFromString("[]");

  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02GPECMEKF@?$FL?$FN?$AA@
  0005f	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?close_array@?1??encoder_listencode_list@@9@9, rax
  00066	e8 00 00 00 00	 call	 PyUnicode_InternFromString

; 1659 :         if (open_array == NULL || close_array == NULL || empty_array == NULL)

  0006b	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?open_array@?1??encoder_listencode_list@@9@9, 0
  00073	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?empty_array@?1??encoder_listencode_list@@9@9, rax
  0007a	0f 84 09 02 00
	00		 je	 $LN27@encoder_li@3
  00080	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?close_array@?1??encoder_listencode_list@@9@9, 0
  00088	0f 84 fb 01 00
	00		 je	 $LN27@encoder_li@3
  0008e	48 85 c0	 test	 rax, rax
  00091	0f 84 f2 01 00
	00		 je	 $LN27@encoder_li@3
$LN28@encoder_li@3:

; 1661 :     }
; 1662 :     ident = NULL;
; 1663 :     s_fast = PySequence_Fast(seq, "_iterencode_list needs a sequence");

  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@BFEMEHI@_iterencode_list?5needs?5a?5sequenc@
  0009e	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  000a3	48 8b cf	 mov	 rcx, rdi
  000a6	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  000ab	33 ed		 xor	 ebp, ebp
  000ad	e8 00 00 00 00	 call	 PySequence_Fast
  000b2	48 8b d8	 mov	 rbx, rax

; 1664 :     if (s_fast == NULL)

  000b5	48 85 c0	 test	 rax, rax
  000b8	75 08		 jne	 SHORT $LN26@encoder_li@3

; 1665 :         return -1;

  000ba	83 c8 ff	 or	 eax, -1
  000bd	e9 9d 00 00 00	 jmp	 $LN43@encoder_li@3
$LN26@encoder_li@3:

; 1666 :     if (PySequence_Fast_GET_SIZE(s_fast) == 0) {

  000c2	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000c6	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  000d0	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  000d4	48 85 c0	 test	 rax, rax
  000d7	75 19		 jne	 SHORT $LN25@encoder_li@3

; 1667 :         Py_DECREF(s_fast);

  000d9	48 8b cb	 mov	 rcx, rbx
  000dc	e8 00 00 00 00	 call	 _Py_DecRef

; 1668 :         return _PyAccu_Accumulate(acc, empty_array);

  000e1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?empty_array@?1??encoder_listencode_list@@9@9
  000e8	49 8b cd	 mov	 rcx, r13
  000eb	e8 00 00 00 00	 call	 _PyAccu_Accumulate
  000f0	eb 6d		 jmp	 SHORT $LN43@encoder_li@3
$LN25@encoder_li@3:
  000f2	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi

; 1669 :     }
; 1670 : 
; 1671 :     if (s->markers != Py_None) {

  000f7	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  000fe	49 39 74 24 60	 cmp	 QWORD PTR [r12+96], rsi
  00103	0f 84 84 00 00
	00		 je	 $LN20@encoder_li@3

; 1672 :         int has_key;
; 1673 :         ident = PyLong_FromVoidPtr(seq);

  00109	48 8b cf	 mov	 rcx, rdi
  0010c	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
  00111	48 8b e8	 mov	 rbp, rax

; 1674 :         if (ident == NULL)

  00114	48 85 c0	 test	 rax, rax
  00117	74 36		 je	 SHORT $LN3@encoder_li@3

; 1675 :             goto bail;
; 1676 :         has_key = PyDict_Contains(s->markers, ident);

  00119	49 8b 4c 24 60	 mov	 rcx, QWORD PTR [r12+96]
  0011e	48 8b d0	 mov	 rdx, rax
  00121	e8 00 00 00 00	 call	 PyDict_Contains

; 1677 :         if (has_key) {

  00126	85 c0		 test	 eax, eax
  00128	74 4f		 je	 SHORT $LN22@encoder_li@3

; 1678 :             if (has_key != -1)

  0012a	83 f8 ff	 cmp	 eax, -1
  0012d	74 13		 je	 SHORT $bail$22439

; 1679 :                 PyErr_SetString(PyExc_ValueError, "Circular reference detected");

  0012f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00136	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@PEOODJKM@Circular?5reference?5detected?$AA@
  0013d	e8 00 00 00 00	 call	 PyErr_SetString
$bail$22439:

; 1723 : 
; 1724 : bail:
; 1725 :     Py_XDECREF(ident);

  00142	48 85 ed	 test	 rbp, rbp
  00145	74 08		 je	 SHORT $LN3@encoder_li@3
  00147	48 8b cd	 mov	 rcx, rbp
  0014a	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@encoder_li@3:

; 1726 :     Py_DECREF(s_fast);

  0014f	48 8b cb	 mov	 rcx, rbx
  00152	e8 00 00 00 00	 call	 _Py_DecRef

; 1727 :     return -1;

  00157	83 c8 ff	 or	 eax, -1
$LN44@encoder_li@3:
  0015a	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
$LN43@encoder_li@3:
  0015f	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00164	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]

; 1728 : }

  00169	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  0016e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00172	41 5e		 pop	 r14
  00174	41 5d		 pop	 r13
  00176	41 5c		 pop	 r12
  00178	c3		 ret	 0
$LN22@encoder_li@3:

; 1680 :             goto bail;
; 1681 :         }
; 1682 :         if (PyDict_SetItem(s->markers, ident, seq)) {

  00179	49 8b 4c 24 60	 mov	 rcx, QWORD PTR [r12+96]
  0017e	4c 8b c7	 mov	 r8, rdi
  00181	48 8b d5	 mov	 rdx, rbp
  00184	e8 00 00 00 00	 call	 PyDict_SetItem
  00189	85 c0		 test	 eax, eax
  0018b	75 b5		 jne	 SHORT $bail$22439
$LN20@encoder_li@3:

; 1683 :             goto bail;
; 1684 :         }
; 1685 :     }
; 1686 : 
; 1687 :     if (_PyAccu_Accumulate(acc, open_array))

  0018d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?open_array@?1??encoder_listencode_list@@9@9
  00194	49 8b cd	 mov	 rcx, r13
  00197	e8 00 00 00 00	 call	 _PyAccu_Accumulate
  0019c	85 c0		 test	 eax, eax
  0019e	75 a2		 jne	 SHORT $bail$22439

; 1688 :         goto bail;
; 1689 :     if (s->indent != Py_None) {

  001a0	49 39 74 24 78	 cmp	 QWORD PTR [r12+120], rsi
  001a5	74 03		 je	 SHORT $LN18@encoder_li@3

; 1690 :         /* TODO: DOES NOT RUN */
; 1691 :         indent_level += 1;

  001a7	49 ff c6	 inc	 r14
$LN18@encoder_li@3:

; 1692 :         /*
; 1693 :             newline_indent = '\n' + (' ' * (_indent * _current_indent_level))
; 1694 :             separator = _item_separator + newline_indent
; 1695 :             buf += newline_indent
; 1696 :         */
; 1697 :     }
; 1698 :     for (i = 0; i < PySequence_Fast_GET_SIZE(s_fast); i++) {

  001aa	33 ff		 xor	 edi, edi
  001ac	0f 1f 40 00	 npad	 4
$LL17@encoder_li@3:
  001b0	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001b4	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  001ba	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  001be	81 e1 00 00 00
	02		 and	 ecx, 33554432		; 02000000H
  001c4	48 3b f8	 cmp	 rdi, rax
  001c7	7d 4e		 jge	 SHORT $LN15@encoder_li@3

; 1699 :         PyObject *obj = PySequence_Fast_GET_ITEM(s_fast, i);

  001c9	85 c9		 test	 ecx, ecx
  001cb	74 0a		 je	 SHORT $LN37@encoder_li@3
  001cd	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  001d1	48 8b 34 f8	 mov	 rsi, QWORD PTR [rax+rdi*8]
  001d5	eb 05		 jmp	 SHORT $LN38@encoder_li@3
$LN37@encoder_li@3:
  001d7	48 8b 74 fb 70	 mov	 rsi, QWORD PTR [rbx+rdi*8+112]
$LN38@encoder_li@3:

; 1700 :         if (i) {

  001dc	48 85 ff	 test	 rdi, rdi
  001df	74 18		 je	 SHORT $LN13@encoder_li@3

; 1701 :             if (_PyAccu_Accumulate(acc, s->item_separator))

  001e1	49 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR [r12+136]
  001e9	49 8b cd	 mov	 rcx, r13
  001ec	e8 00 00 00 00	 call	 _PyAccu_Accumulate
  001f1	85 c0		 test	 eax, eax
  001f3	0f 85 49 ff ff
	ff		 jne	 $bail$22439
$LN13@encoder_li@3:

; 1702 :                 goto bail;
; 1703 :         }
; 1704 :         if (encoder_listencode_obj(s, acc, obj, indent_level))

  001f9	4d 8b ce	 mov	 r9, r14
  001fc	4c 8b c6	 mov	 r8, rsi
  001ff	49 8b d5	 mov	 rdx, r13
  00202	49 8b cc	 mov	 rcx, r12
  00205	e8 00 00 00 00	 call	 encoder_listencode_obj
  0020a	85 c0		 test	 eax, eax
  0020c	0f 85 30 ff ff
	ff		 jne	 $bail$22439

; 1692 :         /*
; 1693 :             newline_indent = '\n' + (' ' * (_indent * _current_indent_level))
; 1694 :             separator = _item_separator + newline_indent
; 1695 :             buf += newline_indent
; 1696 :         */
; 1697 :     }
; 1698 :     for (i = 0; i < PySequence_Fast_GET_SIZE(s_fast); i++) {

  00212	48 ff c7	 inc	 rdi
  00215	eb 99		 jmp	 SHORT $LL17@encoder_li@3
$LN15@encoder_li@3:

; 1705 :             goto bail;
; 1706 :     }
; 1707 :     if (ident != NULL) {

  00217	48 85 ed	 test	 rbp, rbp
  0021a	74 47		 je	 SHORT $LN7@encoder_li@3

; 1708 :         if (PyDict_DelItem(s->markers, ident))

  0021c	49 8b 4c 24 60	 mov	 rcx, QWORD PTR [r12+96]
  00221	48 8b d5	 mov	 rdx, rbp
  00224	e8 00 00 00 00	 call	 PyDict_DelItem
  00229	85 c0		 test	 eax, eax
  0022b	0f 85 11 ff ff
	ff		 jne	 $bail$22439

; 1709 :             goto bail;
; 1710 :         Py_CLEAR(ident);

  00231	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BIGPLMIN@?4?4?2Modules?2_json?4c?$AA@
  00238	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@JMNCMNPK@encoder_listencode_list?$AA@
  0023f	4c 8b cd	 mov	 r9, rbp
  00242	41 b8 ae 06 00
	00		 mov	 r8d, 1710		; 000006aeH
  00248	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00250	e8 00 00 00 00	 call	 _PyParallel_Guard
  00255	85 c0		 test	 eax, eax
  00257	75 0a		 jne	 SHORT $LN7@encoder_li@3
  00259	48 8b cd	 mov	 rcx, rbp
  0025c	33 ed		 xor	 ebp, ebp
  0025e	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@encoder_li@3:

; 1711 :     }
; 1712 : 
; 1713 :     /* TODO: DOES NOT RUN
; 1714 :     if (s->indent != Py_None) {
; 1715 :         indent_level -= 1;
; 1716 : 
; 1717 :         yield '\n' + (' ' * (_indent * _current_indent_level))
; 1718 :     }*/
; 1719 :     if (_PyAccu_Accumulate(acc, close_array))

  00263	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?close_array@?1??encoder_listencode_list@@9@9
  0026a	49 8b cd	 mov	 rcx, r13
  0026d	e8 00 00 00 00	 call	 _PyAccu_Accumulate
  00272	85 c0		 test	 eax, eax
  00274	0f 85 c8 fe ff
	ff		 jne	 $bail$22439

; 1720 :         goto bail;
; 1721 :     Py_DECREF(s_fast);

  0027a	48 8b cb	 mov	 rcx, rbx
  0027d	e8 00 00 00 00	 call	 _Py_DecRef

; 1722 :     return 0;

  00282	33 c0		 xor	 eax, eax
  00284	e9 d1 fe ff ff	 jmp	 $LN44@encoder_li@3
$LN27@encoder_li@3:

; 1660 :             return -1;

  00289	83 c8 ff	 or	 eax, -1

; 1728 : }

  0028c	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00291	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00295	41 5e		 pop	 r14
  00297	41 5d		 pop	 r13
  00299	41 5c		 pop	 r12
  0029b	c3		 ret	 0
encoder_listencode_list ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$encoder_dealloc DD imagerel encoder_dealloc
	DD	imagerel encoder_dealloc+33
	DD	imagerel $unwind$encoder_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encoder_dealloc DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT encoder_dealloc
_TEXT	SEGMENT
self$ = 48
encoder_dealloc PROC					; COMDAT

; 1732 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1733 :     /* Deallocate Encoder */
; 1734 :     encoder_clear(self);

  00009	e8 00 00 00 00	 call	 encoder_clear

; 1735 :     Py_TYPE(self)->tp_free(self);

  0000e	4c 8b 5b 58	 mov	 r11, QWORD PTR [rbx+88]
  00012	48 8b cb	 mov	 rcx, rbx

; 1736 : }

  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5b		 pop	 rbx
  0001a	49 ff a3 98 01
	00 00		 rex_jmp QWORD PTR [r11+408]
encoder_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@EGIFCEHH@OO?$CG?3_iterencode?$AA@	; `string'
EXTRN	_PyAccu_FinishAsList:PROC
EXTRN	_PyAccu_Destroy:PROC
EXTRN	_PyAccu_Init:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$encoder_call DD imagerel encoder_call
	DD	imagerel encoder_call+146
	DD	imagerel $unwind$encoder_call
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$encoder_call DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT ??_C@_0BA@EGIFCEHH@OO?$CG?3_iterencode?$AA@
CONST	SEGMENT
??_C@_0BA@EGIFCEHH@OO?$CG?3_iterencode?$AA@ DB 'OO&:_iterencode', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT encoder_call
_TEXT	SEGMENT
acc$ = 64
indent_level$ = 96
self$ = 96
args$ = 104
kwds$ = 112
obj$ = 120
encoder_call PROC					; COMDAT

; 1272 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	49 8b c0	 mov	 rax, r8
  0000c	4c 8b d2	 mov	 r10, rdx

; 1273 :     /* Python callable interface to encode_listencode_obj */
; 1274 :     static char *kwlist[] = {"obj", "_current_indent_level", NULL};
; 1275 :     PyObject *obj;
; 1276 :     Py_ssize_t indent_level;
; 1277 :     PyEncoderObject *s;
; 1278 :     _PyAccu acc;
; 1279 : 
; 1280 :     assert(PyEncoder_Check(self));
; 1281 :     s = (PyEncoderObject *)self;
; 1282 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO&:_iterencode", kwlist,
; 1283 :         &obj, _convertPyInt_AsSsize_t, &indent_level))

  0000f	48 8d 4c 24 60	 lea	 rcx, QWORD PTR indent_level$[rsp]
  00014	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??encoder_call@@9@9
  0001b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@EGIFCEHH@OO?$CG?3_iterencode?$AA@
  00022	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_convertPyInt_AsSsize_t
  0002e	48 8b d0	 mov	 rdx, rax
  00031	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00036	48 8d 4c 24 78	 lea	 rcx, QWORD PTR obj$[rsp]
  0003b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00040	49 8b ca	 mov	 rcx, r10
  00043	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00048	85 c0		 test	 eax, eax

; 1284 :         return NULL;

  0004a	74 33		 je	 SHORT $LN6@encoder_ca

; 1285 :     if (_PyAccu_Init(&acc))

  0004c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR acc$[rsp]
  00051	e8 00 00 00 00	 call	 _PyAccu_Init
  00056	85 c0		 test	 eax, eax

; 1286 :         return NULL;

  00058	75 25		 jne	 SHORT $LN6@encoder_ca

; 1287 :     if (encoder_listencode_obj(s, &acc, obj, indent_level)) {

  0005a	4c 8b 4c 24 60	 mov	 r9, QWORD PTR indent_level$[rsp]
  0005f	4c 8b 44 24 78	 mov	 r8, QWORD PTR obj$[rsp]
  00064	48 8d 54 24 40	 lea	 rdx, QWORD PTR acc$[rsp]
  00069	48 8b cb	 mov	 rcx, rbx
  0006c	e8 00 00 00 00	 call	 encoder_listencode_obj

; 1288 :         _PyAccu_Destroy(&acc);

  00071	48 8d 4c 24 40	 lea	 rcx, QWORD PTR acc$[rsp]
  00076	85 c0		 test	 eax, eax
  00078	74 0d		 je	 SHORT $LN1@encoder_ca
  0007a	e8 00 00 00 00	 call	 _PyAccu_Destroy
$LN6@encoder_ca:

; 1289 :         return NULL;

  0007f	33 c0		 xor	 eax, eax

; 1292 : }

  00081	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00085	5b		 pop	 rbx
  00086	c3		 ret	 0
$LN1@encoder_ca:

; 1290 :     }
; 1291 :     return _PyAccu_FinishAsList(&acc);

  00087	e8 00 00 00 00	 call	 _PyAccu_FinishAsList

; 1292 : }

  0008c	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00090	5b		 pop	 rbx
  00091	c3		 ret	 0
encoder_call ENDP
_TEXT	ENDS
END
