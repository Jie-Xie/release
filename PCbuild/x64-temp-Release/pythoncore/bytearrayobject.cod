; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@FCNILHGP@bytearray_iterator?$AA@	; `string'
PUBLIC	??_C@_0N@MOOGCAMH@__setstate__?$AA@		; `string'
PUBLIC	??_C@_0BA@BJLPBKGK@__length_hint__?$AA@		; `string'
PUBLIC	??_C@_09FCJHKOIN@bytearray?$AA@			; `string'
PUBLIC	??_C@_05DMFNFMHA@zfill?$AA@			; `string'
PUBLIC	??_C@_05NECKJAMC@upper?$AA@			; `string'
PUBLIC	??_C@_09ODNGOEIO@translate?$AA@			; `string'
PUBLIC	??_C@_05PHLGJONK@title?$AA@			; `string'
PUBLIC	??_C@_08EDJLBCEI@swapcase?$AA@			; `string'
PUBLIC	??_C@_05GGNGIGHC@strip?$AA@			; `string'
PUBLIC	??_C@_0L@MPOGHCCL@startswith?$AA@		; `string'
PUBLIC	??_C@_0L@BCMGLLLC@splitlines?$AA@		; `string'
PUBLIC	??_C@_05EHPMMFBK@split?$AA@			; `string'
PUBLIC	??_C@_06DBIPDJKN@rstrip?$AA@			; `string'
PUBLIC	??_C@_06BAKFHKMF@rsplit?$AA@			; `string'
PUBLIC	??_C@_0L@KEEHLNKL@rpartition?$AA@		; `string'
PUBLIC	??_C@_05JKFAKHCP@rjust?$AA@			; `string'
PUBLIC	??_C@_06NCDOMFM@rindex?$AA@			; `string'
PUBLIC	??_C@_05BLFDIAHL@rfind?$AA@			; `string'
PUBLIC	??_C@_07KOIEOCCE@reverse?$AA@			; `string'
PUBLIC	??_C@_07CLEHDIEJ@replace?$AA@			; `string'
PUBLIC	??_C@_06LEMKAMD@remove?$AA@			; `string'
PUBLIC	??_C@_03NJDAHFJE@pop?$AA@			; `string'
PUBLIC	??_C@_09IKAEIPAD@partition?$AA@			; `string'
PUBLIC	??_C@_09PBBLPCAA@maketrans?$AA@			; `string'
PUBLIC	??_C@_06GGONODO@lstrip?$AA@			; `string'
PUBLIC	??_C@_05IPJEPLHL@lower?$AA@			; `string'
PUBLIC	??_C@_05KDIMMEME@ljust?$AA@			; `string'
PUBLIC	??_C@_04DFGCDGNN@join?$AA@			; `string'
PUBLIC	??_C@_07BCOOJPCO@isupper?$AA@			; `string'
PUBLIC	??_C@_07DBHCJBDG@istitle?$AA@			; `string'
PUBLIC	??_C@_07CNBMLEON@isspace?$AA@			; `string'
PUBLIC	??_C@_07EJFAPEJH@islower?$AA@			; `string'
PUBLIC	??_C@_07CFBKIKCH@isdigit?$AA@			; `string'
PUBLIC	??_C@_07EGIOHHOB@isalpha?$AA@			; `string'
PUBLIC	??_C@_07EOADCIGC@isalnum?$AA@			; `string'
PUBLIC	??_C@_06OAOPNKHP@insert?$AA@			; `string'
PUBLIC	??_C@_05FKHKFDID@index?$AA@			; `string'
PUBLIC	??_C@_07DIMGGDAC@fromhex?$AA@			; `string'
PUBLIC	??_C@_04CKFJHKAP@find?$AA@			; `string'
PUBLIC	??_C@_06BPBOMFNI@extend?$AA@			; `string'
PUBLIC	??_C@_0L@DEOCELBD@expandtabs?$AA@		; `string'
PUBLIC	??_C@_08MLCMCPNP@endswith?$AA@			; `string'
PUBLIC	??_C@_06KPNAMAEI@decode?$AA@			; `string'
PUBLIC	??_C@_05IOMEMJEC@count?$AA@			; `string'
PUBLIC	??_C@_04COAGEIMF@copy?$AA@			; `string'
PUBLIC	??_C@_05MEHLAELG@clear?$AA@			; `string'
PUBLIC	??_C@_06BBLOAEEI@center?$AA@			; `string'
PUBLIC	??_C@_0L@NMODNBEH@capitalize?$AA@		; `string'
PUBLIC	??_C@_06PCICMFGG@append?$AA@			; `string'
PUBLIC	??_C@_0L@HOGGIPGN@__sizeof__?$AA@		; `string'
PUBLIC	??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@		; `string'
PUBLIC	??_C@_0L@NNMACJIG@__reduce__?$AA@		; `string'
PUBLIC	??_C@_09LONCBNBJ@__alloc__?$AA@			; `string'
PUBLIC	PyByteArray_Concat
PUBLIC	??_C@_08IBFKALI@__dict__?$AA@			; `string'
PUBLIC	??_C@_08EMIAAFLA@keepends?$AA@			; `string'
PUBLIC	??_C@_08HONNCIIN@maxsplit?$AA@			; `string'
PUBLIC	??_C@_03MGBCFPKM@sep?$AA@			; `string'
PUBLIC	??_C@_06EOMHCNPI@errors?$AA@			; `string'
PUBLIC	??_C@_08MLPGAEIK@encoding?$AA@			; `string'
PUBLIC	??_C@_06OEKOLKIL@source?$AA@			; `string'
PUBLIC	_PyByteArray_empty_string
PUBLIC	PyByteArray_Type
PUBLIC	PyByteArrayIter_Type
EXTRN	PyObject_SelfIter:PROC
EXTRN	PyObject_Free:PROC
EXTRN	PyType_GenericNew:PROC
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	PyType_Type:BYTE
EXTRN	_Py_upper__doc__:BYTE
EXTRN	_Py_title__doc__:BYTE
EXTRN	_Py_swapcase__doc__:BYTE
EXTRN	_Py_maketrans__doc__:BYTE
EXTRN	_Py_lower__doc__:BYTE
EXTRN	_Py_isupper__doc__:BYTE
EXTRN	_Py_istitle__doc__:BYTE
EXTRN	_Py_isspace__doc__:BYTE
EXTRN	_Py_islower__doc__:BYTE
EXTRN	_Py_isdigit__doc__:BYTE
EXTRN	_Py_isalpha__doc__:BYTE
EXTRN	_Py_isalnum__doc__:BYTE
EXTRN	_Py_capitalize__doc__:BYTE
_BSS	SEGMENT
_PyByteArray_empty_string DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BD@FCNILHGP@bytearray_iterator?$AA@
CONST	SEGMENT
??_C@_0BD@FCNILHGP@bytearray_iterator?$AA@ DB 'bytearray_iterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOOGCAMH@__setstate__?$AA@
CONST	SEGMENT
??_C@_0N@MOOGCAMH@__setstate__?$AA@ DB '__setstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
CONST	SEGMENT
??_C@_0BA@BJLPBKGK@__length_hint__?$AA@ DB '__length_hint__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FCJHKOIN@bytearray?$AA@
CONST	SEGMENT
??_C@_09FCJHKOIN@bytearray?$AA@ DB 'bytearray', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DMFNFMHA@zfill?$AA@
CONST	SEGMENT
??_C@_05DMFNFMHA@zfill?$AA@ DB 'zfill', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NECKJAMC@upper?$AA@
CONST	SEGMENT
??_C@_05NECKJAMC@upper?$AA@ DB 'upper', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09ODNGOEIO@translate?$AA@
CONST	SEGMENT
??_C@_09ODNGOEIO@translate?$AA@ DB 'translate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PHLGJONK@title?$AA@
CONST	SEGMENT
??_C@_05PHLGJONK@title?$AA@ DB 'title', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EDJLBCEI@swapcase?$AA@
CONST	SEGMENT
??_C@_08EDJLBCEI@swapcase?$AA@ DB 'swapcase', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05GGNGIGHC@strip?$AA@
CONST	SEGMENT
??_C@_05GGNGIGHC@strip?$AA@ DB 'strip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MPOGHCCL@startswith?$AA@
CONST	SEGMENT
??_C@_0L@MPOGHCCL@startswith?$AA@ DB 'startswith', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BCMGLLLC@splitlines?$AA@
CONST	SEGMENT
??_C@_0L@BCMGLLLC@splitlines?$AA@ DB 'splitlines', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05EHPMMFBK@split?$AA@
CONST	SEGMENT
??_C@_05EHPMMFBK@split?$AA@ DB 'split', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DBIPDJKN@rstrip?$AA@
CONST	SEGMENT
??_C@_06DBIPDJKN@rstrip?$AA@ DB 'rstrip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BAKFHKMF@rsplit?$AA@
CONST	SEGMENT
??_C@_06BAKFHKMF@rsplit?$AA@ DB 'rsplit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KEEHLNKL@rpartition?$AA@
CONST	SEGMENT
??_C@_0L@KEEHLNKL@rpartition?$AA@ DB 'rpartition', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKFAKHCP@rjust?$AA@
CONST	SEGMENT
??_C@_05JKFAKHCP@rjust?$AA@ DB 'rjust', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NCDOMFM@rindex?$AA@
CONST	SEGMENT
??_C@_06NCDOMFM@rindex?$AA@ DB 'rindex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BLFDIAHL@rfind?$AA@
CONST	SEGMENT
??_C@_05BLFDIAHL@rfind?$AA@ DB 'rfind', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KOIEOCCE@reverse?$AA@
CONST	SEGMENT
??_C@_07KOIEOCCE@reverse?$AA@ DB 'reverse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CLEHDIEJ@replace?$AA@
CONST	SEGMENT
??_C@_07CLEHDIEJ@replace?$AA@ DB 'replace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LEMKAMD@remove?$AA@
CONST	SEGMENT
??_C@_06LEMKAMD@remove?$AA@ DB 'remove', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJDAHFJE@pop?$AA@
CONST	SEGMENT
??_C@_03NJDAHFJE@pop?$AA@ DB 'pop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09IKAEIPAD@partition?$AA@
CONST	SEGMENT
??_C@_09IKAEIPAD@partition?$AA@ DB 'partition', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PBBLPCAA@maketrans?$AA@
CONST	SEGMENT
??_C@_09PBBLPCAA@maketrans?$AA@ DB 'maketrans', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GGONODO@lstrip?$AA@
CONST	SEGMENT
??_C@_06GGONODO@lstrip?$AA@ DB 'lstrip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IPJEPLHL@lower?$AA@
CONST	SEGMENT
??_C@_05IPJEPLHL@lower?$AA@ DB 'lower', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KDIMMEME@ljust?$AA@
CONST	SEGMENT
??_C@_05KDIMMEME@ljust?$AA@ DB 'ljust', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DFGCDGNN@join?$AA@
CONST	SEGMENT
??_C@_04DFGCDGNN@join?$AA@ DB 'join', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BCOOJPCO@isupper?$AA@
CONST	SEGMENT
??_C@_07BCOOJPCO@isupper?$AA@ DB 'isupper', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DBHCJBDG@istitle?$AA@
CONST	SEGMENT
??_C@_07DBHCJBDG@istitle?$AA@ DB 'istitle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNBMLEON@isspace?$AA@
CONST	SEGMENT
??_C@_07CNBMLEON@isspace?$AA@ DB 'isspace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EJFAPEJH@islower?$AA@
CONST	SEGMENT
??_C@_07EJFAPEJH@islower?$AA@ DB 'islower', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CFBKIKCH@isdigit?$AA@
CONST	SEGMENT
??_C@_07CFBKIKCH@isdigit?$AA@ DB 'isdigit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EGIOHHOB@isalpha?$AA@
CONST	SEGMENT
??_C@_07EGIOHHOB@isalpha?$AA@ DB 'isalpha', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EOADCIGC@isalnum?$AA@
CONST	SEGMENT
??_C@_07EOADCIGC@isalnum?$AA@ DB 'isalnum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OAOPNKHP@insert?$AA@
CONST	SEGMENT
??_C@_06OAOPNKHP@insert?$AA@ DB 'insert', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKHKFDID@index?$AA@
CONST	SEGMENT
??_C@_05FKHKFDID@index?$AA@ DB 'index', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DIMGGDAC@fromhex?$AA@
CONST	SEGMENT
??_C@_07DIMGGDAC@fromhex?$AA@ DB 'fromhex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CKFJHKAP@find?$AA@
CONST	SEGMENT
??_C@_04CKFJHKAP@find?$AA@ DB 'find', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BPBOMFNI@extend?$AA@
CONST	SEGMENT
??_C@_06BPBOMFNI@extend?$AA@ DB 'extend', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DEOCELBD@expandtabs?$AA@
CONST	SEGMENT
??_C@_0L@DEOCELBD@expandtabs?$AA@ DB 'expandtabs', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLCMCPNP@endswith?$AA@
CONST	SEGMENT
??_C@_08MLCMCPNP@endswith?$AA@ DB 'endswith', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KPNAMAEI@decode?$AA@
CONST	SEGMENT
??_C@_06KPNAMAEI@decode?$AA@ DB 'decode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count?$AA@
CONST	SEGMENT
??_C@_05IOMEMJEC@count?$AA@ DB 'count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04COAGEIMF@copy?$AA@
CONST	SEGMENT
??_C@_04COAGEIMF@copy?$AA@ DB 'copy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEHLAELG@clear?$AA@
CONST	SEGMENT
??_C@_05MEHLAELG@clear?$AA@ DB 'clear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BBLOAEEI@center?$AA@
CONST	SEGMENT
??_C@_06BBLOAEEI@center?$AA@ DB 'center', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NMODNBEH@capitalize?$AA@
CONST	SEGMENT
??_C@_0L@NMODNBEH@capitalize?$AA@ DB 'capitalize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06PCICMFGG@append?$AA@
CONST	SEGMENT
??_C@_06PCICMFGG@append?$AA@ DB 'append', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGGIPGN@__sizeof__?$AA@
CONST	SEGMENT
??_C@_0L@HOGGIPGN@__sizeof__?$AA@ DB '__sizeof__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@
CONST	SEGMENT
??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@ DB '__reduce_ex__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNMACJIG@__reduce__?$AA@
CONST	SEGMENT
??_C@_0L@NNMACJIG@__reduce__?$AA@ DB '__reduce__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LONCBNBJ@__alloc__?$AA@
CONST	SEGMENT
??_C@_09LONCBNBJ@__alloc__?$AA@ DB '__alloc__', 00H	; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId___dict__@?1??_common_reduce@@9@9 DQ 0000000000000000H ; `_common_reduce'::`2'::PyId___dict__
	DQ	FLAT:??_C@_08IBFKALI@__dict__?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_08IBFKALI@__dict__?$AA@
CONST	SEGMENT
??_C@_08IBFKALI@__dict__?$AA@ DB '__dict__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EMIAAFLA@keepends?$AA@
CONST	SEGMENT
??_C@_08EMIAAFLA@keepends?$AA@ DB 'keepends', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HONNCIIN@maxsplit?$AA@
CONST	SEGMENT
??_C@_08HONNCIIN@maxsplit?$AA@ DB 'maxsplit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03MGBCFPKM@sep?$AA@
CONST	SEGMENT
??_C@_03MGBCFPKM@sep?$AA@ DB 'sep', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
?kwlist@?1??bytearray_init@@9@9 DQ FLAT:??_C@_06OEKOLKIL@source?$AA@ ; `bytearray_init'::`2'::kwlist
	DQ	FLAT:??_C@_08MLPGAEIK@encoding?$AA@
	DQ	FLAT:??_C@_06EOMHCNPI@errors?$AA@
	DQ	0000000000000000H
expandtabs__doc__ DB 'B.expandtabs([tabsize]) -> copy of B', 0aH, 0aH, 'R'
	DB	'eturn a copy of B where all tab characters are expanded using'
	DB	' spaces.', 0aH, 'If tabsize is not given, a tab size of 8 cha'
	DB	'racters is assumed.', 00H
	ORG $+3
ljust__doc__ DB	'B.ljust(width[, fillchar]) -> copy of B', 0aH, 0aH, 'Ret'
	DB	'urn B left justified in a string of length width. Padding is', 0aH
	DB	'done using the specified fill character (default is a space).'
	DB	00H
	ORG $+9
rjust__doc__ DB	'B.rjust(width[, fillchar]) -> copy of B', 0aH, 0aH, 'Ret'
	DB	'urn B right justified in a string of length width. Padding is'
	DB	0aH, 'done using the specified fill character (default is a sp'
	DB	'ace)', 00H
	ORG $+9
center__doc__ DB 'B.center(width[, fillchar]) -> copy of B', 0aH, 0aH, 'R'
	DB	'eturn B centered in a string of length width.  Padding is', 0aH
	DB	'done using the specified fill character (default is a space).'
	DB	00H
	ORG $+13
zfill__doc__ DB	'B.zfill(width) -> copy of B', 0aH, 0aH, 'Pad a numeric s'
	DB	'tring B with zeros on the left, to fill a field', 0aH, 'of th'
	DB	'e specified width.  B is never truncated.', 00H
	ORG $+5
find__doc__ DB	'B.find(sub[, start[, end]]) -> int', 0aH, 0aH, 'Return t'
	DB	'he lowest index in B where subsection sub is found,', 0aH, 's'
	DB	'uch that sub is contained within B[start,end].  Optional', 0aH
	DB	'arguments start and end are interpreted as in slice notation.'
	DB	0aH, 0aH, 'Return -1 on failure.', 00H
	ORG $+1
count__doc__ DB	'B.count(sub[, start[, end]]) -> int', 0aH, 0aH, 'Return '
	DB	'the number of non-overlapping occurrences of subsection sub i'
	DB	'n', 0aH, 'bytes B[start:end].  Optional arguments start and e'
	DB	'nd are interpreted', 0aH, 'as in slice notation.', 00H
	ORG $+1
clear__doc__ DB	'B.clear() -> None', 0aH, 0aH, 'Remove all items from B.', 00H
	ORG $+4
copy__doc__ DB	'B.copy() -> bytearray', 0aH, 0aH, 'Return a copy of B.', 00H
	ORG $+13
index__doc__ DB	'B.index(sub[, start[, end]]) -> int', 0aH, 0aH, 'Like B.'
	DB	'find() but raise ValueError when the subsection is not found.'
	DB	00H
	ORG $+6
rfind__doc__ DB	'B.rfind(sub[, start[, end]]) -> int', 0aH, 0aH, 'Return '
	DB	'the highest index in B where subsection sub is found,', 0aH, 's'
	DB	'uch that sub is contained within B[start,end].  Optional', 0aH
	DB	'arguments start and end are interpreted as in slice notation.'
	DB	0aH, 0aH, 'Return -1 on failure.', 00H
	ORG $+15
rindex__doc__ DB 'B.rindex(sub[, start[, end]]) -> int', 0aH, 0aH, 'Like '
	DB	'B.rfind() but raise ValueError when the subsection is not fou'
	DB	'nd.', 00H
	ORG $+4
startswith__doc__ DB 'B.startswith(prefix[, start[, end]]) -> bool', 0aH, 0aH
	DB	'Return True if B starts with the specified prefix, False othe'
	DB	'rwise.', 0aH, 'With optional start, test B beginning at that '
	DB	'position.', 0aH, 'With optional end, stop comparing B at that'
	DB	' position.', 0aH, 'prefix can also be a tuple of bytes to try'
	DB	'.', 00H
	ORG $+4
endswith__doc__ DB 'B.endswith(suffix[, start[, end]]) -> bool', 0aH, 0aH
	DB	'Return True if B ends with the specified suffix, False otherw'
	DB	'ise.', 0aH, 'With optional start, test B beginning at that po'
	DB	'sition.', 0aH, 'With optional end, stop comparing B at that p'
	DB	'osition.', 0aH, 'suffix can also be a tuple of bytes to try.', 00H
	ORG $+8
translate__doc__ DB 'B.translate(table[, deletechars]) -> bytearray', 0aH
	DB	0aH, 'Return a copy of B, where all characters occurring in th'
	DB	'e', 0aH, 'optional argument deletechars are removed, and the '
	DB	'remaining', 0aH, 'characters have been mapped through the giv'
	DB	'en translation', 0aH, 'table, which must be a bytes object of'
	DB	' length 256.', 00H
	ORG $+12
replace__doc__ DB 'B.replace(old, new[, count]) -> bytearray', 0aH, 0aH, 'R'
	DB	'eturn a copy of B with all occurrences of subsection', 0aH, 'o'
	DB	'ld replaced by new.  If the optional argument count is', 0aH, 'g'
	DB	'iven, only the first count occurrences are replaced.', 00H
	ORG $+1
split__doc__ DB	'B.split(sep=None, maxsplit=-1) -> list of bytearrays', 0aH
	DB	0aH, 'Return a list of the sections in B, using sep as the del'
	DB	'imiter.', 0aH, 'If sep is not given, B is split on ASCII whit'
	DB	'espace characters', 0aH, '(space, tab, return, newline, formf'
	DB	'eed, vertical tab).', 0aH, 'If maxsplit is given, at most max'
	DB	'split splits are done.', 00H
	ORG $+4
?kwlist@?1??bytearray_split@@9@9 DQ FLAT:??_C@_03MGBCFPKM@sep?$AA@ ; `bytearray_split'::`2'::kwlist
	DQ	FLAT:??_C@_08HONNCIIN@maxsplit?$AA@
	DQ	0000000000000000H
partition__doc__ DB 'B.partition(sep) -> (head, sep, tail)', 0aH, 0aH, 'S'
	DB	'earch for the separator sep in B, and return the part before '
	DB	'it,', 0aH, 'the separator itself, and the part after it.  If '
	DB	'the separator is not', 0aH, 'found, returns B and two empty b'
	DB	'ytearray objects.', 00H
	ORG $+15
rpartition__doc__ DB 'B.rpartition(sep) -> (head, sep, tail)', 0aH, 0aH, 'S'
	DB	'earch for the separator sep in B, starting at the end of B,', 0aH
	DB	'and return the part before it, the separator itself, and the', 0aH
	DB	'part after it.  If the separator is not found, returns two em'
	DB	'pty', 0aH, 'bytearray objects and B.', 00H
	ORG $+4
rsplit__doc__ DB 'B.rsplit(sep=None, maxsplit=-1) -> list of bytearrays', 0aH
	DB	0aH, 'Return a list of the sections in B, using sep as the del'
	DB	'imiter,', 0aH, 'starting at the end of B and working to the f'
	DB	'ront.', 0aH, 'If sep is not given, B is split on ASCII whites'
	DB	'pace characters', 0aH, '(space, tab, return, newline, formfee'
	DB	'd, vertical tab).', 0aH, 'If maxsplit is given, at most maxsp'
	DB	'lit splits are done.', 00H
?kwlist@?1??bytearray_rsplit@@9@9 DQ FLAT:??_C@_03MGBCFPKM@sep?$AA@ ; `bytearray_rsplit'::`2'::kwlist
	DQ	FLAT:??_C@_08HONNCIIN@maxsplit?$AA@
	DQ	0000000000000000H
reverse__doc__ DB 'B.reverse() -> None', 0aH, 0aH, 'Reverse the order of '
	DB	'the values in B in place.', 00H
	ORG $+12
insert__doc__ DB 'B.insert(index, int) -> None', 0aH, 0aH, 'Insert a sing'
	DB	'le item into the bytearray before the given index.', 00H
	ORG $+2
append__doc__ DB 'B.append(int) -> None', 0aH, 0aH, 'Append a single item'
	DB	' to the end of B.', 00H
	ORG $+3
extend__doc__ DB 'B.extend(iterable_of_ints) -> None', 0aH, 0aH, 'Append '
	DB	'all the elements from the iterator or sequence to the', 0aH, 'e'
	DB	'nd of B.', 00H
	ORG $+5
pop__doc__ DB	'B.pop([index]) -> int', 0aH, 0aH, 'Remove and return a s'
	DB	'ingle item from B. If no index', 0aH, 'argument is given, wil'
	DB	'l pop the last value.', 00H
	ORG $+9
remove__doc__ DB 'B.remove(int) -> None', 0aH, 0aH, 'Remove the first occ'
	DB	'urrence of a value in B.', 00H
	ORG $+12
strip__doc__ DB	'B.strip([bytes]) -> bytearray', 0aH, 0aH, 'Strip leading'
	DB	' and trailing bytes contained in the argument', 0aH, 'and ret'
	DB	'urn the result as a new bytearray.', 0aH, 'If the argument is'
	DB	' omitted, strip ASCII whitespace.', 00H
	ORG $+8
lstrip__doc__ DB 'B.lstrip([bytes]) -> bytearray', 0aH, 0aH, 'Strip leadi'
	DB	'ng bytes contained in the argument', 0aH, 'and return the res'
	DB	'ult as a new bytearray.', 0aH, 'If the argument is omitted, s'
	DB	'trip leading ASCII whitespace.', 00H
	ORG $+12
rstrip__doc__ DB 'B.rstrip([bytes]) -> bytearray', 0aH, 0aH, 'Strip trail'
	DB	'ing bytes contained in the argument', 0aH, 'and return the re'
	DB	'sult as a new bytearray.', 0aH, 'If the argument is omitted, '
	DB	'strip trailing ASCII whitespace.', 00H
	ORG $+10
decode_doc DB	'B.decode(encoding=''utf-8'', errors=''strict'') -> str', 0aH
	DB	0aH, 'Decode B using the codec registered for encoding. Defaul'
	DB	't encoding', 0aH, 'is ''utf-8''. errors may be given to set a'
	DB	' different error', 0aH, 'handling scheme.  Default is ''stric'
	DB	't'' meaning that encoding errors raise', 0aH, 'a UnicodeDecod'
	DB	'eError.  Other possible values are ''ignore'' and ''replace'''
	DB	0aH, 'as well as any other name registered with codecs.registe'
	DB	'r_error that is', 0aH, 'able to handle UnicodeDecodeErrors.', 00H
	ORG $+3
?kwlist@?1??bytearray_decode@@9@9 DQ FLAT:??_C@_08MLPGAEIK@encoding?$AA@ ; `bytearray_decode'::`2'::kwlist
	DQ	FLAT:??_C@_06EOMHCNPI@errors?$AA@
	DQ	0000000000000000H
	ORG $+8
alloc_doc DB	'B.__alloc__() -> int', 0aH, 0aH, 'Return the number of b'
	DB	'ytes actually allocated.', 00H
	ORG $+11
join_doc DB	'B.join(iterable_of_bytes) -> bytearray', 0aH, 0aH, 'Conc'
	DB	'atenate any number of bytes/bytearray objects, with B', 0aH, 'i'
	DB	'n between each pair, and return the result as a new bytearray'
	DB	'.', 00H
	ORG $+14
splitlines__doc__ DB 'B.splitlines([keepends]) -> list of lines', 0aH, 0aH
	DB	'Return a list of the lines in B, breaking at line boundaries.'
	DB	0aH, 'Line breaks are not included in the resulting list unles'
	DB	's keepends', 0aH, 'is given and true.', 00H
	ORG $+1
?kwlist@?1??bytearray_splitlines@@9@9 DQ FLAT:??_C@_08EMIAAFLA@keepends?$AA@ ; `bytearray_splitlines'::`2'::kwlist
	DQ	0000000000000000H
fromhex_doc DB	'bytearray.fromhex(string) -> bytearray (static method)', 0aH
	DB	0aH, 'Create a bytearray object from a string of hexadecimal n'
	DB	'umbers.', 0aH, 'Spaces between two numbers are accepted.', 0aH
	DB	'Example: bytearray.fromhex(''B9 01EF'') -> bytearray(b''\xb9\'
	DB	'x01\xef'').', 00H
	ORG $+2
reduce_doc DB	'Return state information for pickling.', 00H
	ORG $+1
reduce_ex_doc DB 'Return state information for pickling.', 00H
	ORG $+9
sizeof_doc DB	'B.__sizeof__() -> int', 0aH, ' ', 0aH, 'Returns the size'
	DB	' of B in memory, in bytes', 00H
	ORG $+14
bytearray_as_sequence DQ FLAT:bytearray_length
	DQ	FLAT:PyByteArray_Concat
	DQ	FLAT:bytearray_repeat
	DQ	FLAT:bytearray_getitem
	DQ	0000000000000000H
	DQ	FLAT:bytearray_setitem
	DQ	0000000000000000H
	DQ	FLAT:bytearray_contains
	DQ	FLAT:bytearray_iconcat
	DQ	FLAT:bytearray_irepeat
bytearray_as_mapping DQ FLAT:bytearray_length
	DQ	FLAT:bytearray_subscript
	DQ	FLAT:bytearray_ass_subscript
bytearray_as_buffer DQ FLAT:bytearray_getbuffer
	DQ	FLAT:bytearray_releasebuffer
	ORG $+8
bytearray_methods DQ FLAT:??_C@_09LONCBNBJ@__alloc__?$AA@
	DQ	FLAT:bytearray_alloc
	DD	04H
	ORG $+4
	DQ	FLAT:alloc_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:bytearray_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@
	DQ	FLAT:bytearray_reduce_ex
	DD	01H
	ORG $+4
	DQ	FLAT:reduce_ex_doc
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:bytearray_sizeof
	DD	04H
	ORG $+4
	DQ	FLAT:sizeof_doc
	DQ	FLAT:??_C@_06PCICMFGG@append?$AA@
	DQ	FLAT:bytearray_append
	DD	08H
	ORG $+4
	DQ	FLAT:append__doc__
	DQ	FLAT:??_C@_0L@NMODNBEH@capitalize?$AA@
	DQ	FLAT:stringlib_capitalize
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_capitalize__doc__
	DQ	FLAT:??_C@_06BBLOAEEI@center?$AA@
	DQ	FLAT:stringlib_center
	DD	01H
	ORG $+4
	DQ	FLAT:center__doc__
	DQ	FLAT:??_C@_05MEHLAELG@clear?$AA@
	DQ	FLAT:bytearray_clear
	DD	04H
	ORG $+4
	DQ	FLAT:clear__doc__
	DQ	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DQ	FLAT:bytearray_copy
	DD	04H
	ORG $+4
	DQ	FLAT:copy__doc__
	DQ	FLAT:??_C@_05IOMEMJEC@count?$AA@
	DQ	FLAT:bytearray_count
	DD	01H
	ORG $+4
	DQ	FLAT:count__doc__
	DQ	FLAT:??_C@_06KPNAMAEI@decode?$AA@
	DQ	FLAT:bytearray_decode
	DD	03H
	ORG $+4
	DQ	FLAT:decode_doc
	DQ	FLAT:??_C@_08MLCMCPNP@endswith?$AA@
	DQ	FLAT:bytearray_endswith
	DD	01H
	ORG $+4
	DQ	FLAT:endswith__doc__
	DQ	FLAT:??_C@_0L@DEOCELBD@expandtabs?$AA@
	DQ	FLAT:stringlib_expandtabs
	DD	01H
	ORG $+4
	DQ	FLAT:expandtabs__doc__
	DQ	FLAT:??_C@_06BPBOMFNI@extend?$AA@
	DQ	FLAT:bytearray_extend
	DD	08H
	ORG $+4
	DQ	FLAT:extend__doc__
	DQ	FLAT:??_C@_04CKFJHKAP@find?$AA@
	DQ	FLAT:bytearray_find
	DD	01H
	ORG $+4
	DQ	FLAT:find__doc__
	DQ	FLAT:??_C@_07DIMGGDAC@fromhex?$AA@
	DQ	FLAT:bytearray_fromhex
	DD	011H
	ORG $+4
	DQ	FLAT:fromhex_doc
	DQ	FLAT:??_C@_05FKHKFDID@index?$AA@
	DQ	FLAT:bytearray_index
	DD	01H
	ORG $+4
	DQ	FLAT:index__doc__
	DQ	FLAT:??_C@_06OAOPNKHP@insert?$AA@
	DQ	FLAT:bytearray_insert
	DD	01H
	ORG $+4
	DQ	FLAT:insert__doc__
	DQ	FLAT:??_C@_07EOADCIGC@isalnum?$AA@
	DQ	FLAT:stringlib_isalnum
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_isalnum__doc__
	DQ	FLAT:??_C@_07EGIOHHOB@isalpha?$AA@
	DQ	FLAT:stringlib_isalpha
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_isalpha__doc__
	DQ	FLAT:??_C@_07CFBKIKCH@isdigit?$AA@
	DQ	FLAT:stringlib_isdigit
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_isdigit__doc__
	DQ	FLAT:??_C@_07EJFAPEJH@islower?$AA@
	DQ	FLAT:stringlib_islower
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_islower__doc__
	DQ	FLAT:??_C@_07CNBMLEON@isspace?$AA@
	DQ	FLAT:stringlib_isspace
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_isspace__doc__
	DQ	FLAT:??_C@_07DBHCJBDG@istitle?$AA@
	DQ	FLAT:stringlib_istitle
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_istitle__doc__
	DQ	FLAT:??_C@_07BCOOJPCO@isupper?$AA@
	DQ	FLAT:stringlib_isupper
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_isupper__doc__
	DQ	FLAT:??_C@_04DFGCDGNN@join?$AA@
	DQ	FLAT:bytearray_join
	DD	08H
	ORG $+4
	DQ	FLAT:join_doc
	DQ	FLAT:??_C@_05KDIMMEME@ljust?$AA@
	DQ	FLAT:stringlib_ljust
	DD	01H
	ORG $+4
	DQ	FLAT:ljust__doc__
	DQ	FLAT:??_C@_05IPJEPLHL@lower?$AA@
	DQ	FLAT:stringlib_lower
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_lower__doc__
	DQ	FLAT:??_C@_06GGONODO@lstrip?$AA@
	DQ	FLAT:bytearray_lstrip
	DD	01H
	ORG $+4
	DQ	FLAT:lstrip__doc__
	DQ	FLAT:??_C@_09PBBLPCAA@maketrans?$AA@
	DQ	FLAT:bytearray_maketrans
	DD	021H
	ORG $+4
	DQ	FLAT:_Py_maketrans__doc__
	DQ	FLAT:??_C@_09IKAEIPAD@partition?$AA@
	DQ	FLAT:bytearray_partition
	DD	08H
	ORG $+4
	DQ	FLAT:partition__doc__
	DQ	FLAT:??_C@_03NJDAHFJE@pop?$AA@
	DQ	FLAT:bytearray_pop
	DD	01H
	ORG $+4
	DQ	FLAT:pop__doc__
	DQ	FLAT:??_C@_06LEMKAMD@remove?$AA@
	DQ	FLAT:bytearray_remove
	DD	08H
	ORG $+4
	DQ	FLAT:remove__doc__
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	FLAT:bytearray_replace
	DD	01H
	ORG $+4
	DQ	FLAT:replace__doc__
	DQ	FLAT:??_C@_07KOIEOCCE@reverse?$AA@
	DQ	FLAT:bytearray_reverse
	DD	04H
	ORG $+4
	DQ	FLAT:reverse__doc__
	DQ	FLAT:??_C@_05BLFDIAHL@rfind?$AA@
	DQ	FLAT:bytearray_rfind
	DD	01H
	ORG $+4
	DQ	FLAT:rfind__doc__
	DQ	FLAT:??_C@_06NCDOMFM@rindex?$AA@
	DQ	FLAT:bytearray_rindex
	DD	01H
	ORG $+4
	DQ	FLAT:rindex__doc__
	DQ	FLAT:??_C@_05JKFAKHCP@rjust?$AA@
	DQ	FLAT:stringlib_rjust
	DD	01H
	ORG $+4
	DQ	FLAT:rjust__doc__
	DQ	FLAT:??_C@_0L@KEEHLNKL@rpartition?$AA@
	DQ	FLAT:bytearray_rpartition
	DD	08H
	ORG $+4
	DQ	FLAT:rpartition__doc__
	DQ	FLAT:??_C@_06BAKFHKMF@rsplit?$AA@
	DQ	FLAT:bytearray_rsplit
	DD	03H
	ORG $+4
	DQ	FLAT:rsplit__doc__
	DQ	FLAT:??_C@_06DBIPDJKN@rstrip?$AA@
	DQ	FLAT:bytearray_rstrip
	DD	01H
	ORG $+4
	DQ	FLAT:rstrip__doc__
	DQ	FLAT:??_C@_05EHPMMFBK@split?$AA@
	DQ	FLAT:bytearray_split
	DD	03H
	ORG $+4
	DQ	FLAT:split__doc__
	DQ	FLAT:??_C@_0L@BCMGLLLC@splitlines?$AA@
	DQ	FLAT:bytearray_splitlines
	DD	03H
	ORG $+4
	DQ	FLAT:splitlines__doc__
	DQ	FLAT:??_C@_0L@MPOGHCCL@startswith?$AA@
	DQ	FLAT:bytearray_startswith
	DD	01H
	ORG $+4
	DQ	FLAT:startswith__doc__
	DQ	FLAT:??_C@_05GGNGIGHC@strip?$AA@
	DQ	FLAT:bytearray_strip
	DD	01H
	ORG $+4
	DQ	FLAT:strip__doc__
	DQ	FLAT:??_C@_08EDJLBCEI@swapcase?$AA@
	DQ	FLAT:stringlib_swapcase
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_swapcase__doc__
	DQ	FLAT:??_C@_05PHLGJONK@title?$AA@
	DQ	FLAT:stringlib_title
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_title__doc__
	DQ	FLAT:??_C@_09ODNGOEIO@translate?$AA@
	DQ	FLAT:bytearray_translate
	DD	01H
	ORG $+4
	DQ	FLAT:translate__doc__
	DQ	FLAT:??_C@_05NECKJAMC@upper?$AA@
	DQ	FLAT:stringlib_upper
	DD	04H
	ORG $+4
	DQ	FLAT:_Py_upper__doc__
	DQ	FLAT:??_C@_05DMFNFMHA@zfill?$AA@
	DQ	FLAT:stringlib_zfill
	DD	01H
	ORG $+4
	DQ	FLAT:zfill__doc__
	DQ	0000000000000000H
	ORG $+24
bytearray_doc DB 'bytearray(iterable_of_ints) -> bytearray', 0aH, 'bytear'
	DB	'ray(string, encoding[, errors]) -> bytearray', 0aH, 'bytearra'
	DB	'y(bytes_or_buffer) -> mutable copy of bytes_or_buffer', 0aH, 'b'
	DB	'ytearray(int) -> bytes array of size given by the parameter i'
	DB	'nitialized with null bytes', 0aH, 'bytearray() -> empty bytes'
	DB	' array', 0aH, 0aH, 'Construct an mutable bytearray object fro'
	DB	'm:', 0aH, '  - an iterable yielding integers in range(256)', 0aH
	DB	'  - a text string encoded using the specified encoding', 0aH, ' '
	DB	' - a bytes or a buffer object', 0aH, '  - any object implemen'
	DB	'ting the buffer API.', 0aH, '  - an integer', 00H
	ORG $+14
PyByteArray_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_09FCJHKOIN@bytearray?$AA@
	DQ	0000000000000090H
	DQ	0000000000000000H
	DQ	FLAT:bytearray_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:bytearray_repr
	DQ	0000000000000000H
	DQ	FLAT:bytearray_as_sequence
	DQ	FLAT:bytearray_as_mapping
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:bytearray_str
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	FLAT:bytearray_as_buffer
	DD	040400H
	ORG $+4
	DQ	FLAT:bytearray_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:bytearray_richcompare
	DQ	0000000000000000H
	DQ	FLAT:bytearray_iter
	DQ	0000000000000000H
	DQ	FLAT:bytearray_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:bytearray_init
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:PyType_GenericNew
	DQ	FLAT:PyObject_Free
	ORG $+64
length_hint_doc DB 'Private method returning an estimate of len(list(it))'
	DB	'.', 00H
	ORG $+1
setstate_doc DB	'Set state information for unpickling.', 00H
	ORG $+2
bytearrayiter_methods DQ FLAT:??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
	DQ	FLAT:bytearrayiter_length_hint
	DD	04H
	ORG $+4
	DQ	FLAT:length_hint_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:bytearrayiter_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:bytearrayiter_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
PyByteArrayIter_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BD@FCNILHGP@bytearray_iterator?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:bytearrayiter_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:bytearrayiter_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:bytearrayiter_next
	DQ	FLAT:bytearrayiter_methods
	DQ	0000000000000000H
	ORG $+144
_DATA	ENDS
;	COMDAT ??_C@_06EOMHCNPI@errors?$AA@
CONST	SEGMENT
??_C@_06EOMHCNPI@errors?$AA@ DB 'errors', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLPGAEIK@encoding?$AA@
CONST	SEGMENT
??_C@_08MLPGAEIK@encoding?$AA@ DB 'encoding', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OEKOLKIL@source?$AA@
CONST	SEGMENT
??_C@_06OEKOLKIL@source?$AA@ DB 'source', 00H		; `string'
CONST	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	PyByteArray_Fini
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
;	COMDAT PyByteArray_Fini
_TEXT	SEGMENT
PyByteArray_Fini PROC					; COMDAT

; 13   : }

  00000	c2 00 00	 ret	 0
PyByteArray_Fini ENDP
_TEXT	ENDS
PUBLIC	PyByteArray_Init
; Function compile flags: /Ogtpy
;	COMDAT PyByteArray_Init
_TEXT	SEGMENT
PyByteArray_Init PROC					; COMDAT

; 18   :     return 1;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 19   : }

  00005	c3		 ret	 0
PyByteArray_Init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyNumber_Index:PROC
EXTRN	PyLong_AsLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_getbytevalue DD imagerel _getbytevalue
	DD	imagerel _getbytevalue+169
	DD	imagerel $unwind$_getbytevalue
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_getbytevalue DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@
CONST	SEGMENT
??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@ DB 'byt'
	DB	'e must be in range(0, 256)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
CONST	SEGMENT
??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@ DB 'an integer is requi'
	DB	'red', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _getbytevalue
_TEXT	SEGMENT
arg$ = 48
value$ = 56
_getbytevalue PROC					; COMDAT

; 27   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 28   :     long face_value;
; 29   : 
; 30   :     if (PyLong_Check(arg)) {

  0000f	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00013	48 8b fa	 mov	 rdi, rdx
  00016	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00020	74 09		 je	 SHORT $LN5@getbyteval

; 31   :         face_value = PyLong_AsLong(arg);

  00022	e8 00 00 00 00	 call	 PyLong_AsLong
  00027	8b d8		 mov	 ebx, eax

; 32   :     } else {

  00029	eb 34		 jmp	 SHORT $LN4@getbyteval
$LN5@getbyteval:

; 33   :         PyObject *index = PyNumber_Index(arg);

  0002b	e8 00 00 00 00	 call	 PyNumber_Index
  00030	48 8b f0	 mov	 rsi, rax

; 34   :         if (index == NULL) {

  00033	48 85 c0	 test	 rax, rax
  00036	75 15		 jne	 SHORT $LN3@getbyteval

; 35   :             PyErr_Format(PyExc_TypeError, "an integer is required");

  00038	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
  00046	e8 00 00 00 00	 call	 PyErr_Format

; 36   :             *value = -1;
; 37   :             return 0;

  0004b	eb 44		 jmp	 SHORT $LN8@getbyteval
$LN3@getbyteval:

; 38   :         }
; 39   :         face_value = PyLong_AsLong(index);

  0004d	48 8b c8	 mov	 rcx, rax
  00050	e8 00 00 00 00	 call	 PyLong_AsLong

; 40   :         Py_DECREF(index);

  00055	48 8b ce	 mov	 rcx, rsi
  00058	8b d8		 mov	 ebx, eax
  0005a	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@getbyteval:

; 41   :     }
; 42   : 
; 43   :     if (face_value < 0 || face_value >= 256) {

  0005f	81 fb ff 00 00
	00		 cmp	 ebx, 255		; 000000ffH
  00065	77 17		 ja	 SHORT $LN1@getbyteval

; 46   :         *value = -1;
; 47   :         return 0;
; 48   :     }
; 49   : 
; 50   :     *value = face_value;

  00067	89 1f		 mov	 DWORD PTR [rdi], ebx

; 51   :     return 1;

  00069	b8 01 00 00 00	 mov	 eax, 1

; 52   : }

  0006e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00073	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00078	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007c	5f		 pop	 rdi
  0007d	c3		 ret	 0
$LN1@getbyteval:

; 44   :         /* this includes the OverflowError in case the long is too large */
; 45   :         PyErr_SetString(PyExc_ValueError, "byte must be in range(0, 256)");

  0007e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@
  0008c	e8 00 00 00 00	 call	 PyErr_SetString
$LN8@getbyteval:

; 52   : }

  00091	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00096	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0009b	33 c0		 xor	 eax, eax
  0009d	c7 07 ff ff ff
	ff		 mov	 DWORD PTR [rdi], -1
  000a3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a7	5f		 pop	 rdi
  000a8	c3		 ret	 0
_getbytevalue ENDP
_TEXT	ENDS
EXTRN	PyBuffer_FillInfo:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_getbuffer DD imagerel bytearray_getbuffer
	DD	imagerel bytearray_getbuffer+91
	DD	imagerel $unwind$bytearray_getbuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_getbuffer DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytearray_getbuffer
_TEXT	SEGMENT
obj$ = 64
view$ = 72
flags$ = 80
bytearray_getbuffer PROC				; COMDAT

; 56   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	45 8b d0	 mov	 r10d, r8d
  00009	48 8b c2	 mov	 rax, rdx
  0000c	48 8b d9	 mov	 rbx, rcx

; 57   :     int ret;
; 58   :     void *ptr;
; 59   :     if (view == NULL) {

  0000f	48 85 d2	 test	 rdx, rdx
  00012	75 09		 jne	 SHORT $LN2@bytearray_

; 60   :         obj->ob_exports++;

  00014	ff 41 70	 inc	 DWORD PTR [rcx+112]

; 67   :     }
; 68   :     return ret;
; 69   : }

  00017	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
$LN2@bytearray_:

; 61   :         return 0;
; 62   :     }
; 63   :     ptr = (void *) PyByteArray_AS_STRING(obj);

  0001d	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  00021	4d 85 c9	 test	 r9, r9
  00024	74 09		 je	 SHORT $LN5@bytearray_
  00026	4c 8b 81 80 00
	00 00		 mov	 r8, QWORD PTR [rcx+128]
  0002d	eb 07		 jmp	 SHORT $LN6@bytearray_
$LN5@bytearray_:
  0002f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_PyByteArray_empty_string
$LN6@bytearray_:

; 64   :     ret = PyBuffer_FillInfo(view, (PyObject*)obj, ptr, Py_SIZE(obj), 0, flags);

  00036	48 8b d1	 mov	 rdx, rcx
  00039	44 89 54 24 28	 mov	 DWORD PTR [rsp+40], r10d
  0003e	48 8b c8	 mov	 rcx, rax
  00041	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00049	e8 00 00 00 00	 call	 PyBuffer_FillInfo

; 65   :     if (ret >= 0) {

  0004e	85 c0		 test	 eax, eax
  00050	78 03		 js	 SHORT $LN1@bytearray_

; 66   :         obj->ob_exports++;

  00052	ff 43 70	 inc	 DWORD PTR [rbx+112]
$LN1@bytearray_:

; 67   :     }
; 68   :     return ret;
; 69   : }

  00055	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00059	5b		 pop	 rbx
  0005a	c3		 ret	 0
bytearray_getbuffer ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bytearray_releasebuffer
_TEXT	SEGMENT
obj$ = 8
view$ = 16
bytearray_releasebuffer PROC				; COMDAT

; 74   :     obj->ob_exports--;

  00000	ff 49 70	 dec	 DWORD PTR [rcx+112]

; 75   : }

  00003	c3		 ret	 0
bytearray_releasebuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@HMLNEJOC@Type?5?$CF?4100s?5doesn?8t?5support?5the?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_getbuffer DD imagerel _getbuffer
	DD	imagerel _getbuffer+86
	DD	imagerel $unwind$_getbuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_getbuffer DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CL@HMLNEJOC@Type?5?$CF?4100s?5doesn?8t?5support?5the?5@
CONST	SEGMENT
??_C@_0CL@HMLNEJOC@Type?5?$CF?4100s?5doesn?8t?5support?5the?5@ DB 'Type %'
	DB	'.100s doesn''t support the buffer API', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _getbuffer
_TEXT	SEGMENT
obj$ = 48
view$ = 56
_getbuffer PROC						; COMDAT

; 79   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 80   :     PyBufferProcs *buffer = Py_TYPE(obj)->tp_as_buffer;

  00006	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	49 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [r8+248]

; 81   : 
; 82   :     if (buffer == NULL || buffer->bf_getbuffer == NULL)

  00014	48 85 c0	 test	 rax, rax
  00017	74 1c		 je	 SHORT $LN2@getbuffer
  00019	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  0001c	4d 85 c9	 test	 r9, r9
  0001f	74 14		 je	 SHORT $LN2@getbuffer

; 88   :     }
; 89   : 
; 90   :     if (buffer->bf_getbuffer(obj, view, PyBUF_SIMPLE) < 0)

  00021	45 33 c0	 xor	 r8d, r8d
  00024	41 ff d1	 call	 r9
  00027	85 c0		 test	 eax, eax

; 91   :             return -1;

  00029	78 21		 js	 SHORT $LN6@getbuffer

; 92   :     return view->len;

  0002b	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]

; 93   : }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5b		 pop	 rbx
  00034	c3		 ret	 0
$LN2@getbuffer:

; 83   :     {
; 84   :         PyErr_Format(PyExc_TypeError,
; 85   :                      "Type %.100s doesn't support the buffer API",
; 86   :                      Py_TYPE(obj)->tp_name);

  00035	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@HMLNEJOC@Type?5?$CF?4100s?5doesn?8t?5support?5the?5@
  00047	e8 00 00 00 00	 call	 PyErr_Format
$LN6@getbuffer:

; 87   :         return -1;

  0004c	48 83 c8 ff	 or	 rax, -1

; 93   : }

  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5b		 pop	 rbx
  00055	c3		 ret	 0
_getbuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@ ; `string'
EXTRN	PyExc_BufferError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_canresize DD imagerel _canresize
	DD	imagerel _canresize+46
	DD	imagerel $unwind$_canresize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_canresize DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@
CONST	SEGMENT
??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@ DB 'Existing ex'
	DB	'ports of data: object cannot be re-sized', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _canresize
_TEXT	SEGMENT
self$ = 48
_canresize PROC						; COMDAT

; 97   : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 98   :     if (self->ob_exports > 0) {

  00004	83 79 70 00	 cmp	 DWORD PTR [rcx+112], 0
  00008	7e 1a		 jle	 SHORT $LN1@canresize

; 99   :         PyErr_SetString(PyExc_BufferError,
; 100  :                 "Existing exports of data: object cannot be re-sized");

  0000a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@
  00018	e8 00 00 00 00	 call	 PyErr_SetString

; 101  :         return 0;

  0001d	33 c0		 xor	 eax, eax

; 104  : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
$LN1@canresize:

; 102  :     }
; 103  :     return 1;

  00024	b8 01 00 00 00	 mov	 eax, 1

; 104  : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
_canresize ENDP
_TEXT	ENDS
PUBLIC	PyByteArray_FromObject
EXTRN	PyObject_CallFunctionObjArgs:PROC
; Function compile flags: /Ogtpy
;	COMDAT PyByteArray_FromObject
_TEXT	SEGMENT
input$ = 8
PyByteArray_FromObject PROC				; COMDAT

; 111  :     return PyObject_CallFunctionObjArgs((PyObject *)&PyByteArray_Type,
; 112  :                                         input, NULL);

  00000	48 8b d1	 mov	 rdx, rcx
  00003	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyByteArray_Type
  0000a	45 33 c0	 xor	 r8d, r8d

; 113  : }

  0000d	e9 00 00 00 00	 jmp	 PyObject_CallFunctionObjArgs
PyByteArray_FromObject ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@DPPIIPAI@Negative?5size?5passed?5to?5PyByteAr@ ; `string'
PUBLIC	PyByteArray_FromStringAndSize
EXTRN	PyObject_Malloc:PROC
EXTRN	_PyObject_New:PROC
EXTRN	_PxObject_New:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyExc_SystemError:QWORD
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyByteArray_FromStringAndSize DD imagerel $LN15
	DD	imagerel $LN15+83
	DD	imagerel $unwind$PyByteArray_FromStringAndSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyByteArray_FromStringAndSize DD imagerel $LN15+83
	DD	imagerel $LN15+140
	DD	imagerel $chain$0$PyByteArray_FromStringAndSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyByteArray_FromStringAndSize DD imagerel $LN15+140
	DD	imagerel $LN15+274
	DD	imagerel $chain$3$PyByteArray_FromStringAndSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyByteArray_FromStringAndSize DD 040521H
	DD	076405H
	DD	063400H
	DD	imagerel $LN15
	DD	imagerel $LN15+83
	DD	imagerel $unwind$PyByteArray_FromStringAndSize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyByteArray_FromStringAndSize DD 020521H
	DD	063405H
	DD	imagerel $LN15
	DD	imagerel $LN15+83
	DD	imagerel $unwind$PyByteArray_FromStringAndSize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyByteArray_FromStringAndSize DD 040a01H
	DD	08540aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0DG@DPPIIPAI@Negative?5size?5passed?5to?5PyByteAr@
CONST	SEGMENT
??_C@_0DG@DPPIIPAI@Negative?5size?5passed?5to?5PyByteAr@ DB 'Negative siz'
	DB	'e passed to PyByteArray_FromStringAndSize', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyByteArray_FromStringAndSize
_TEXT	SEGMENT
bytes$ = 48
size$ = 56
PyByteArray_FromStringAndSize PROC			; COMDAT

; 117  : {

$LN15:
  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b e9	 mov	 rbp, rcx

; 118  :     PyByteArrayObject *new;
; 119  :     Py_ssize_t alloc;
; 120  : 
; 121  :     if (size < 0) {

  00010	48 85 d2	 test	 rdx, rdx
  00013	79 20		 jns	 SHORT $LN7@PyByteArra

; 122  :         PyErr_SetString(PyExc_SystemError,
; 123  :             "Negative size passed to PyByteArray_FromStringAndSize");

  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@DPPIIPAI@Negative?5size?5passed?5to?5PyByteAr@
  00023	e8 00 00 00 00	 call	 PyErr_SetString

; 124  :         return NULL;

  00028	33 c0		 xor	 eax, eax

; 156  : }

  0002a	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	c3		 ret	 0
$LN7@PyByteArra:

; 125  :     }
; 126  : 
; 127  :     /* Prevent buffer overflow when setting alloc to size+1. */
; 128  :     if (size == PY_SSIZE_T_MAX) {

  00035	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0003f	48 3b d0	 cmp	 rdx, rax
  00042	75 0f		 jne	 SHORT $LN6@PyByteArra

; 156  : }

  00044	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5f		 pop	 rdi
  0004e	e9 00 00 00 00	 jmp	 PyErr_NoMemory
$LN6@PyByteArra:
  00053	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 129  :         return PyErr_NoMemory();
; 130  :     }
; 131  : 
; 132  :     new = PyObject_New(PyByteArrayObject, &PyByteArray_Type);

  00058	e8 00 00 00 00	 call	 _Py_PXCTX
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyByteArray_Type
  00064	85 c0		 test	 eax, eax
  00066	74 07		 je	 SHORT $LN10@PyByteArra
  00068	e8 00 00 00 00	 call	 _PxObject_New
  0006d	eb 05		 jmp	 SHORT $LN14@PyByteArra
$LN10@PyByteArra:
  0006f	e8 00 00 00 00	 call	 _PyObject_New
$LN14@PyByteArra:
  00074	48 8b d8	 mov	 rbx, rax

; 133  :     if (new == NULL)

  00077	48 85 c0	 test	 rax, rax
  0007a	75 10		 jne	 SHORT $LN5@PyByteArra
  0007c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 156  : }

  00081	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00086	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008a	5f		 pop	 rdi
  0008b	c3		 ret	 0
$LN5@PyByteArra:
  0008c	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi

; 134  :         return NULL;
; 135  : 
; 136  :     if (size == 0) {

  00091	48 85 ff	 test	 rdi, rdi
  00094	75 0b		 jne	 SHORT $LN4@PyByteArra

; 137  :         new->ob_bytes = NULL;

  00096	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi

; 138  :         alloc = 0;

  0009d	33 f6		 xor	 esi, esi

; 139  :     }
; 140  :     else {

  0009f	eb 4a		 jmp	 SHORT $LN3@PyByteArra
$LN4@PyByteArra:

; 141  :         alloc = size + 1;

  000a1	48 8d 77 01	 lea	 rsi, QWORD PTR [rdi+1]

; 142  :         new->ob_bytes = PyObject_Malloc(alloc);

  000a5	48 8b ce	 mov	 rcx, rsi
  000a8	e8 00 00 00 00	 call	 PyObject_Malloc
  000ad	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax

; 143  :         if (new->ob_bytes == NULL) {

  000b4	48 85 c0	 test	 rax, rax
  000b7	75 0f		 jne	 SHORT $LN2@PyByteArra

; 144  :             Py_DECREF(new);

  000b9	48 8b cb	 mov	 rcx, rbx
  000bc	e8 00 00 00 00	 call	 _Py_DecRef

; 145  :             return PyErr_NoMemory();

  000c1	e8 00 00 00 00	 call	 PyErr_NoMemory
  000c6	eb 35		 jmp	 SHORT $LN13@PyByteArra
$LN2@PyByteArra:

; 146  :         }
; 147  :         if (bytes != NULL && size > 0)

  000c8	48 85 ed	 test	 rbp, rbp
  000cb	74 13		 je	 SHORT $LN1@PyByteArra
  000cd	48 85 ff	 test	 rdi, rdi
  000d0	7e 0e		 jle	 SHORT $LN1@PyByteArra

; 148  :             memcpy(new->ob_bytes, bytes, size);

  000d2	4c 8b c7	 mov	 r8, rdi
  000d5	48 8b d5	 mov	 rdx, rbp
  000d8	48 8b c8	 mov	 rcx, rax
  000db	e8 00 00 00 00	 call	 memcpy
$LN1@PyByteArra:

; 149  :         new->ob_bytes[size] = '\0';  /* Trailing null byte */

  000e0	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]
  000e7	c6 04 07 00	 mov	 BYTE PTR [rdi+rax], 0
$LN3@PyByteArra:

; 150  :     }
; 151  :     Py_SIZE(new) = size;

  000eb	48 89 7b 60	 mov	 QWORD PTR [rbx+96], rdi

; 152  :     new->ob_alloc = alloc;

  000ef	48 89 73 78	 mov	 QWORD PTR [rbx+120], rsi

; 153  :     new->ob_exports = 0;

  000f3	c7 43 70 00 00
	00 00		 mov	 DWORD PTR [rbx+112], 0

; 154  : 
; 155  :     return (PyObject *)new;

  000fa	48 8b c3	 mov	 rax, rbx
$LN13@PyByteArra:

; 156  : }

  000fd	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00102	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00107	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0010c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00110	5f		 pop	 rdi
  00111	c3		 ret	 0
PyByteArray_FromStringAndSize ENDP
_TEXT	ENDS
PUBLIC	PyByteArray_Size
; Function compile flags: /Ogtpy
;	COMDAT PyByteArray_Size
_TEXT	SEGMENT
self$ = 8
PyByteArray_Size PROC					; COMDAT

; 161  :     assert(self != NULL);
; 162  :     assert(PyByteArray_Check(self));
; 163  : 
; 164  :     return PyByteArray_GET_SIZE(self);

  00000	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]

; 165  : }

  00004	c3		 ret	 0
PyByteArray_Size ENDP
_TEXT	ENDS
PUBLIC	PyByteArray_AsString
; Function compile flags: /Ogtpy
;	COMDAT PyByteArray_AsString
_TEXT	SEGMENT
self$ = 8
PyByteArray_AsString PROC				; COMDAT

; 170  :     assert(self != NULL);
; 171  :     assert(PyByteArray_Check(self));
; 172  : 
; 173  :     return PyByteArray_AS_STRING(self);

  00000	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  00005	74 08		 je	 SHORT $LN3@PyByteArra@2
  00007	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]

; 174  : }

  0000e	c3		 ret	 0
$LN3@PyByteArra@2:

; 170  :     assert(self != NULL);
; 171  :     assert(PyByteArray_Check(self));
; 172  : 
; 173  :     return PyByteArray_AS_STRING(self);

  0000f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string

; 174  : }

  00016	c3		 ret	 0
PyByteArray_AsString ENDP
_TEXT	ENDS
PUBLIC	__real@3ff2000000000000
PUBLIC	PyByteArray_Resize
EXTRN	PyObject_Realloc:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyByteArray_Resize DD imagerel $LN14
	DD	imagerel $LN14+251
	DD	imagerel $unwind$PyByteArray_Resize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyByteArray_Resize DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT __real@3ff2000000000000
CONST	SEGMENT
__real@3ff2000000000000 DQ 03ff2000000000000r	; 1.125
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyByteArray_Resize
_TEXT	SEGMENT
self$ = 48
size$ = 56
PyByteArray_Resize PROC					; COMDAT

; 178  : {

$LN14:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 179  :     void *sval;
; 180  :     Py_ssize_t alloc = ((PyByteArrayObject *)self)->ob_alloc;

  0000f	48 8b 71 78	 mov	 rsi, QWORD PTR [rcx+120]
  00013	48 8b da	 mov	 rbx, rdx
  00016	48 8b f9	 mov	 rdi, rcx

; 181  : 
; 182  :     assert(self != NULL);
; 183  :     assert(PyByteArray_Check(self));
; 184  :     assert(size >= 0);
; 185  : 
; 186  :     if (size == Py_SIZE(self)) {

  00019	48 3b 51 60	 cmp	 rdx, QWORD PTR [rcx+96]

; 187  :         return 0;

  0001d	0f 84 c6 00 00
	00		 je	 $LN12@PyByteArra@3

; 188  :     }
; 189  :     if (!_canresize((PyByteArrayObject *)self)) {

  00023	e8 00 00 00 00	 call	 _canresize
  00028	85 c0		 test	 eax, eax

; 190  :         return -1;

  0002a	0f 84 93 00 00
	00		 je	 $LN13@PyByteArra@3

; 191  :     }
; 192  : 
; 193  :     if (size < alloc / 2) {

  00030	48 8b c6	 mov	 rax, rsi
  00033	48 99		 cdq
  00035	48 2b c2	 sub	 rax, rdx
  00038	48 d1 f8	 sar	 rax, 1
  0003b	48 3b d8	 cmp	 rbx, rax

; 194  :         /* Major downsize; resize down to exact size */
; 195  :         alloc = size + 1;

  0003e	7c 66		 jl	 SHORT $LN3@PyByteArra@3

; 196  :     }
; 197  :     else if (size < alloc) {

  00040	48 3b de	 cmp	 rbx, rsi
  00043	7d 21		 jge	 SHORT $LN5@PyByteArra@3

; 198  :         /* Within allocated size; quick exit */
; 199  :         Py_SIZE(self) = size;
; 200  :         ((PyByteArrayObject *)self)->ob_bytes[size] = '\0'; /* Trailing null */

  00045	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  0004c	48 89 5f 60	 mov	 QWORD PTR [rdi+96], rbx
  00050	c6 04 03 00	 mov	 BYTE PTR [rbx+rax], 0

; 222  : 
; 223  :     return 0;

  00054	33 c0		 xor	 eax, eax

; 224  : }

  00056	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
$LN5@PyByteArra@3:

; 201  :         return 0;
; 202  :     }
; 203  :     else if (size <= alloc * 1.125) {

  00066	66 0f ef c0	 pxor	 xmm0, xmm0
  0006a	66 0f ef c9	 pxor	 xmm1, xmm1
  0006e	f2 48 0f 2a c6	 cvtsi2sd xmm0, rsi
  00073	f2 48 0f 2a cb	 cvtsi2sd xmm1, rbx
  00078	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3ff2000000000000
  00080	66 0f 2f c1	 comisd	 xmm0, xmm1
  00084	72 20		 jb	 SHORT $LN3@PyByteArra@3

; 204  :         /* Moderate upsize; overallocate similar to list_resize() */
; 205  :         alloc = size + (size >> 3) + (size < 9 ? 3 : 6);

  00086	48 83 fb 09	 cmp	 rbx, 9
  0008a	b8 06 00 00 00	 mov	 eax, 6
  0008f	b9 03 00 00 00	 mov	 ecx, 3
  00094	0f 4c c1	 cmovl	 eax, ecx
  00097	48 8b f3	 mov	 rsi, rbx
  0009a	48 03 c3	 add	 rax, rbx
  0009d	48 c1 fe 03	 sar	 rsi, 3
  000a1	48 03 f0	 add	 rsi, rax

; 206  :     }
; 207  :     else {

  000a4	eb 04		 jmp	 SHORT $LN2@PyByteArra@3
$LN3@PyByteArra@3:

; 208  :         /* Major upsize; resize up to exact size */
; 209  :         alloc = size + 1;

  000a6	48 8d 73 01	 lea	 rsi, QWORD PTR [rbx+1]
$LN2@PyByteArra@3:

; 210  :     }
; 211  : 
; 212  :     sval = PyObject_Realloc(((PyByteArrayObject *)self)->ob_bytes, alloc);

  000aa	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  000b1	48 8b d6	 mov	 rdx, rsi
  000b4	e8 00 00 00 00	 call	 PyObject_Realloc

; 213  :     if (sval == NULL) {

  000b9	48 85 c0	 test	 rax, rax
  000bc	75 18		 jne	 SHORT $LN1@PyByteArra@3

; 214  :         PyErr_NoMemory();

  000be	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN13@PyByteArra@3:

; 215  :         return -1;

  000c3	83 c8 ff	 or	 eax, -1

; 224  : }

  000c6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000cb	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000d0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d4	5f		 pop	 rdi
  000d5	c3		 ret	 0
$LN1@PyByteArra@3:

; 216  :     }
; 217  : 
; 218  :     ((PyByteArrayObject *)self)->ob_bytes = sval;

  000d6	48 89 87 80 00
	00 00		 mov	 QWORD PTR [rdi+128], rax

; 219  :     Py_SIZE(self) = size;

  000dd	48 89 5f 60	 mov	 QWORD PTR [rdi+96], rbx

; 220  :     ((PyByteArrayObject *)self)->ob_alloc = alloc;

  000e1	48 89 77 78	 mov	 QWORD PTR [rdi+120], rsi

; 221  :     ((PyByteArrayObject *)self)->ob_bytes[size] = '\0'; /* Trailing null byte */

  000e5	c6 04 18 00	 mov	 BYTE PTR [rax+rbx], 0
$LN12@PyByteArra@3:

; 224  : }

  000e9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ee	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000f3	33 c0		 xor	 eax, eax
  000f5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f9	5f		 pop	 rdi
  000fa	c3		 ret	 0
PyByteArray_Resize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@KJMEMNEM@can?8t?5concat?5?$CF?4100s?5to?5?$CF?4100s?$AA@ ; `string'
EXTRN	PyBuffer_Release:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyByteArray_Concat DD imagerel $LN10
	DD	imagerel $LN10+269
	DD	imagerel $unwind$PyByteArray_Concat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyByteArray_Concat DD 071201H
	DD	01b6412H
	DD	01a3412H
	DD	0180112H
	DD	0700bH
xdata	ENDS
;	COMDAT ??_C@_0BO@KJMEMNEM@can?8t?5concat?5?$CF?4100s?5to?5?$CF?4100s?$AA@
CONST	SEGMENT
??_C@_0BO@KJMEMNEM@can?8t?5concat?5?$CF?4100s?5to?5?$CF?4100s?$AA@ DB 'ca'
	DB	'n''t concat %.100s to %.100s', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyByteArray_Concat
_TEXT	SEGMENT
va$ = 32
vb$ = 112
a$ = 208
b$ = 216
PyByteArray_Concat PROC					; COMDAT

; 228  : {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00012	48 8b fa	 mov	 rdi, rdx

; 229  :     Py_ssize_t size;
; 230  :     Py_buffer va, vb;
; 231  :     PyByteArrayObject *result = NULL;
; 232  : 
; 233  :     va.len = -1;
; 234  :     vb.len = -1;
; 235  :     if (_getbuffer(a, &va) < 0  ||
; 236  :         _getbuffer(b, &vb) < 0) {

  00015	48 8d 54 24 20	 lea	 rdx, QWORD PTR va$[rsp]
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	33 db		 xor	 ebx, ebx
  0001f	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR va$[rsp+16], -1
  00028	48 c7 84 24 80
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR vb$[rsp+16], -1
  00034	e8 00 00 00 00	 call	 _getbuffer
  00039	48 85 c0	 test	 rax, rax
  0003c	78 6d		 js	 SHORT $LN5@PyByteArra@4
  0003e	48 8d 54 24 70	 lea	 rdx, QWORD PTR vb$[rsp]
  00043	48 8b cf	 mov	 rcx, rdi
  00046	e8 00 00 00 00	 call	 _getbuffer
  0004b	48 85 c0	 test	 rax, rax
  0004e	78 5b		 js	 SHORT $LN5@PyByteArra@4

; 239  :             goto done;
; 240  :     }
; 241  : 
; 242  :     size = va.len + vb.len;

  00050	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR vb$[rsp+16]
  00058	48 03 54 24 30	 add	 rdx, QWORD PTR va$[rsp+16]

; 243  :     if (size < 0) {

  0005d	79 07		 jns	 SHORT $LN4@PyByteArra@4

; 244  :             PyErr_NoMemory();

  0005f	e8 00 00 00 00	 call	 PyErr_NoMemory

; 245  :             goto done;

  00064	eb 68		 jmp	 SHORT $done$20471
$LN4@PyByteArra@4:

; 246  :     }
; 247  : 
; 248  :     result = (PyByteArrayObject *) PyByteArray_FromStringAndSize(NULL, size);

  00066	33 c9		 xor	 ecx, ecx
  00068	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0006d	48 8b d8	 mov	 rbx, rax

; 249  :     if (result != NULL) {

  00070	48 85 c0	 test	 rax, rax
  00073	74 59		 je	 SHORT $done$20471

; 250  :         memcpy(result->ob_bytes, va.buf, va.len);

  00075	4c 8b 44 24 30	 mov	 r8, QWORD PTR va$[rsp+16]
  0007a	48 8b 54 24 20	 mov	 rdx, QWORD PTR va$[rsp]
  0007f	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00086	e8 00 00 00 00	 call	 memcpy

; 251  :         memcpy(result->ob_bytes + va.len, vb.buf, vb.len);

  0008b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR va$[rsp+16]
  00090	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR vb$[rsp+16]
  00098	48 03 8b 80 00
	00 00		 add	 rcx, QWORD PTR [rbx+128]
  0009f	48 8b 54 24 70	 mov	 rdx, QWORD PTR vb$[rsp]
  000a4	e8 00 00 00 00	 call	 memcpy
  000a9	eb 23		 jmp	 SHORT $done$20471
$LN5@PyByteArra@4:

; 237  :             PyErr_Format(PyExc_TypeError, "can't concat %.100s to %.100s",
; 238  :                          Py_TYPE(a)->tp_name, Py_TYPE(b)->tp_name);

  000ab	4c 8b 4f 58	 mov	 r9, QWORD PTR [rdi+88]
  000af	4c 8b 46 58	 mov	 r8, QWORD PTR [rsi+88]
  000b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000ba	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  000be	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@KJMEMNEM@can?8t?5concat?5?$CF?4100s?5to?5?$CF?4100s?$AA@
  000c9	e8 00 00 00 00	 call	 PyErr_Format
$done$20471:

; 252  :     }
; 253  : 
; 254  :   done:
; 255  :     if (va.len != -1)

  000ce	48 83 7c 24 30
	ff		 cmp	 QWORD PTR va$[rsp+16], -1
  000d4	74 0a		 je	 SHORT $LN2@PyByteArra@4

; 256  :         PyBuffer_Release(&va);

  000d6	48 8d 4c 24 20	 lea	 rcx, QWORD PTR va$[rsp]
  000db	e8 00 00 00 00	 call	 PyBuffer_Release
$LN2@PyByteArra@4:

; 257  :     if (vb.len != -1)

  000e0	48 83 bc 24 80
	00 00 00 ff	 cmp	 QWORD PTR vb$[rsp+16], -1
  000e9	74 0a		 je	 SHORT $LN9@PyByteArra@4

; 258  :         PyBuffer_Release(&vb);

  000eb	48 8d 4c 24 70	 lea	 rcx, QWORD PTR vb$[rsp]
  000f0	e8 00 00 00 00	 call	 PyBuffer_Release
$LN9@PyByteArra@4:

; 259  :     return (PyObject *)result;
; 260  : }

  000f5	4c 8d 9c 24 c0
	00 00 00	 lea	 r11, QWORD PTR [rsp+192]
  000fd	48 8b c3	 mov	 rax, rbx
  00100	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00104	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00108	49 8b e3	 mov	 rsp, r11
  0010b	5f		 pop	 rdi
  0010c	c3		 ret	 0
PyByteArray_Concat ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bytearray_length
_TEXT	SEGMENT
self$ = 8
bytearray_length PROC					; COMDAT

; 267  :     return Py_SIZE(self);

  00000	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]

; 268  : }

  00004	c3		 ret	 0
bytearray_length ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_iconcat DD imagerel bytearray_iconcat
	DD	imagerel bytearray_iconcat+248
	DD	imagerel $unwind$bytearray_iconcat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_iconcat DD 040a01H
	DD	010340aH
	DD	07006d20aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytearray_iconcat
_TEXT	SEGMENT
vo$ = 32
self$ = 128
other$ = 136
bytearray_iconcat PROC					; COMDAT

; 272  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 273  :     Py_ssize_t mysize;
; 274  :     Py_ssize_t size;
; 275  :     Py_buffer vo;
; 276  : 
; 277  :     if (_getbuffer(other, &vo) < 0) {

  00010	48 8d 54 24 20	 lea	 rdx, QWORD PTR vo$[rsp]
  00015	48 8b cf	 mov	 rcx, rdi
  00018	e8 00 00 00 00	 call	 _getbuffer
  0001d	48 85 c0	 test	 rax, rax
  00020	79 33		 jns	 SHORT $LN5@bytearray_@2

; 278  :         PyErr_Format(PyExc_TypeError, "can't concat %.100s to %.100s",
; 279  :                      Py_TYPE(other)->tp_name, Py_TYPE(self)->tp_name);

  00022	4c 8b 4b 58	 mov	 r9, QWORD PTR [rbx+88]
  00026	4c 8b 47 58	 mov	 r8, QWORD PTR [rdi+88]
  0002a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00031	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  00035	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@KJMEMNEM@can?8t?5concat?5?$CF?4100s?5to?5?$CF?4100s?$AA@
  00040	e8 00 00 00 00	 call	 PyErr_Format

; 280  :         return NULL;

  00045	33 c0		 xor	 eax, eax

; 301  : }

  00047	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  0004f	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00053	5f		 pop	 rdi
  00054	c3		 ret	 0
$LN5@bytearray_@2:

; 281  :     }
; 282  : 
; 283  :     mysize = Py_SIZE(self);

  00055	48 8b 7b 60	 mov	 rdi, QWORD PTR [rbx+96]

; 284  :     size = mysize + vo.len;

  00059	48 8b 54 24 30	 mov	 rdx, QWORD PTR vo$[rsp+16]
  0005e	48 03 d7	 add	 rdx, rdi

; 285  :     if (size < 0) {

  00061	79 1d		 jns	 SHORT $LN4@bytearray_@2

; 286  :         PyBuffer_Release(&vo);

  00063	48 8d 4c 24 20	 lea	 rcx, QWORD PTR vo$[rsp]
  00068	e8 00 00 00 00	 call	 PyBuffer_Release

; 287  :         return PyErr_NoMemory();

  0006d	e8 00 00 00 00	 call	 PyErr_NoMemory

; 301  : }

  00072	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  0007a	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0007e	5f		 pop	 rdi
  0007f	c3		 ret	 0
$LN4@bytearray_@2:

; 288  :     }
; 289  :     if (size < self->ob_alloc) {

  00080	48 3b 53 78	 cmp	 rdx, QWORD PTR [rbx+120]
  00084	7d 4c		 jge	 SHORT $LN3@bytearray_@2

; 290  :         Py_SIZE(self) = size;
; 291  :         self->ob_bytes[Py_SIZE(self)] = '\0'; /* Trailing null byte */

  00086	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]
  0008d	48 89 53 60	 mov	 QWORD PTR [rbx+96], rdx
  00091	c6 04 02 00	 mov	 BYTE PTR [rdx+rax], 0
$LN1@bytearray_@2:

; 295  :         return NULL;
; 296  :     }
; 297  :     memcpy(self->ob_bytes + mysize, vo.buf, vo.len);

  00095	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]
  0009c	4c 8b 44 24 30	 mov	 r8, QWORD PTR vo$[rsp+16]
  000a1	48 8b 54 24 20	 mov	 rdx, QWORD PTR vo$[rsp]
  000a6	48 8d 0c 07	 lea	 rcx, QWORD PTR [rdi+rax]
  000aa	e8 00 00 00 00	 call	 memcpy

; 298  :     PyBuffer_Release(&vo);

  000af	48 8d 4c 24 20	 lea	 rcx, QWORD PTR vo$[rsp]
  000b4	e8 00 00 00 00	 call	 PyBuffer_Release

; 299  :     Py_INCREF(self);

  000b9	48 8b cb	 mov	 rcx, rbx
  000bc	e8 00 00 00 00	 call	 _Py_IncRef

; 300  :     return (PyObject *)self;

  000c1	48 8b c3	 mov	 rax, rbx

; 301  : }

  000c4	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  000cc	48 83 c4 70	 add	 rsp, 112		; 00000070H
  000d0	5f		 pop	 rdi
  000d1	c3		 ret	 0
$LN3@bytearray_@2:

; 292  :     }
; 293  :     else if (PyByteArray_Resize((PyObject *)self, size) < 0) {

  000d2	48 8b cb	 mov	 rcx, rbx
  000d5	e8 00 00 00 00	 call	 PyByteArray_Resize
  000da	85 c0		 test	 eax, eax
  000dc	79 b7		 jns	 SHORT $LN1@bytearray_@2

; 294  :         PyBuffer_Release(&vo);

  000de	48 8d 4c 24 20	 lea	 rcx, QWORD PTR vo$[rsp]
  000e3	e8 00 00 00 00	 call	 PyBuffer_Release

; 301  : }

  000e8	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  000f0	33 c0		 xor	 eax, eax
  000f2	48 83 c4 70	 add	 rsp, 112		; 00000070H
  000f6	5f		 pop	 rdi
  000f7	c3		 ret	 0
bytearray_iconcat ENDP
_TEXT	ENDS
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_repeat DD imagerel bytearray_repeat
	DD	imagerel bytearray_repeat+222
	DD	imagerel $unwind$bytearray_repeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_repeat DD 0a5d01H
	DD	09745dH
	DD	085453H
	DD	0a340eH
	DD	0d00a320eH
	DD	06006c008H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytearray_repeat
_TEXT	SEGMENT
self$ = 64
count$ = 72
bytearray_repeat PROC					; COMDAT

; 305  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 306  :     PyByteArrayObject *result;
; 307  :     Py_ssize_t mysize;
; 308  :     Py_ssize_t size;
; 309  : 
; 310  :     if (count < 0)
; 311  :         count = 0;
; 312  :     mysize = Py_SIZE(self);

  0000e	48 8b 71 60	 mov	 rsi, QWORD PTR [rcx+96]
  00012	45 33 e4	 xor	 r12d, r12d
  00015	48 85 d2	 test	 rdx, rdx
  00018	48 8b da	 mov	 rbx, rdx
  0001b	4c 8b e9	 mov	 r13, rcx
  0001e	49 0f 48 dc	 cmovs	 rbx, r12

; 313  :     if (count > 0 && mysize > PY_SSIZE_T_MAX / count)

  00022	48 85 db	 test	 rbx, rbx
  00025	7e 27		 jle	 SHORT $LN7@bytearray_@3
  00027	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00031	48 99		 cdq
  00033	48 f7 fb	 idiv	 rbx
  00036	48 3b f0	 cmp	 rsi, rax
  00039	7e 13		 jle	 SHORT $LN7@bytearray_@3

; 324  :         }
; 325  :     }
; 326  :     return (PyObject *)result;
; 327  : }

  0003b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	41 5d		 pop	 r13
  00046	41 5c		 pop	 r12
  00048	5e		 pop	 rsi
  00049	e9 00 00 00 00	 jmp	 PyErr_NoMemory
$LN7@bytearray_@3:
  0004e	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp

; 314  :         return PyErr_NoMemory();
; 315  :     size = mysize * count;

  00053	48 8b ee	 mov	 rbp, rsi

; 316  :     result = (PyByteArrayObject *)PyByteArray_FromStringAndSize(NULL, size);

  00056	33 c9		 xor	 ecx, ecx
  00058	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0005d	48 0f af eb	 imul	 rbp, rbx
  00061	48 8b d5	 mov	 rdx, rbp
  00064	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00069	48 8b f8	 mov	 rdi, rax

; 317  :     if (result != NULL && size != 0) {

  0006c	48 85 c0	 test	 rax, rax
  0006f	74 51		 je	 SHORT $LN1@bytearray_@3
  00071	48 85 ed	 test	 rbp, rbp
  00074	74 4c		 je	 SHORT $LN1@bytearray_@3

; 318  :         if (mysize == 1)

  00076	48 83 fe 01	 cmp	 rsi, 1
  0007a	75 1b		 jne	 SHORT $LN5@bytearray_@3

; 319  :             memset(result->ob_bytes, self->ob_bytes[0], size);

  0007c	49 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR [r13+128]
  00083	4c 8b c5	 mov	 r8, rbp
  00086	0f be 11	 movsx	 edx, BYTE PTR [rcx]
  00089	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00090	e8 00 00 00 00	 call	 memset

; 320  :         else {

  00095	eb 2b		 jmp	 SHORT $LN1@bytearray_@3
$LN5@bytearray_@3:

; 321  :             Py_ssize_t i;
; 322  :             for (i = 0; i < count; i++)

  00097	48 85 db	 test	 rbx, rbx
  0009a	7e 26		 jle	 SHORT $LN1@bytearray_@3
  0009c	0f 1f 40 00	 npad	 4
$LL3@bytearray_@3:

; 323  :                 memcpy(result->ob_bytes + i*mysize, self->ob_bytes, mysize);

  000a0	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  000a7	49 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR [r13+128]
  000ae	4c 8b c6	 mov	 r8, rsi
  000b1	49 8d 0c 04	 lea	 rcx, QWORD PTR [r12+rax]
  000b5	e8 00 00 00 00	 call	 memcpy
  000ba	4c 03 e6	 add	 r12, rsi
  000bd	48 ff cb	 dec	 rbx
  000c0	75 de		 jne	 SHORT $LL3@bytearray_@3
$LN1@bytearray_@3:
  000c2	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 324  :         }
; 325  :     }
; 326  :     return (PyObject *)result;
; 327  : }

  000c7	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000cc	48 8b c7	 mov	 rax, rdi
  000cf	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000d4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d8	41 5d		 pop	 r13
  000da	41 5c		 pop	 r12
  000dc	5e		 pop	 rsi
  000dd	c3		 ret	 0
bytearray_repeat ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytearray_irepeat DD imagerel bytearray_irepeat
	DD	imagerel bytearray_irepeat+286
	DD	imagerel $unwind$bytearray_irepeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_irepeat DD 085401H
	DD	087454H
	DD	0a540fH
	DD	09340fH
	DD	0600b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
xdata	ENDS
;	COMDAT bytearray_irepeat
_TEXT	SEGMENT
self$ = 64
count$ = 72
bytearray_irepeat PROC					; COMDAT

; 331  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 332  :     Py_ssize_t mysize;
; 333  :     Py_ssize_t size;
; 334  : 
; 335  :     if (count < 0)
; 336  :         count = 0;
; 337  :     mysize = Py_SIZE(self);

  0000f	48 8b 71 60	 mov	 rsi, QWORD PTR [rcx+96]
  00013	33 c0		 xor	 eax, eax
  00015	48 85 d2	 test	 rdx, rdx
  00018	48 8b ea	 mov	 rbp, rdx
  0001b	48 8b d9	 mov	 rbx, rcx
  0001e	48 0f 48 e8	 cmovs	 rbp, rax

; 338  :     if (count > 0 && mysize > PY_SSIZE_T_MAX / count)

  00022	48 85 ed	 test	 rbp, rbp
  00025	7e 28		 jle	 SHORT $LN9@bytearray_@4
  00027	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00031	48 99		 cdq
  00033	48 f7 fd	 idiv	 rbp
  00036	48 3b f0	 cmp	 rsi, rax
  00039	7e 14		 jle	 SHORT $LN9@bytearray_@4

; 358  : }

  0003b	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00040	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00045	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00049	5e		 pop	 rsi
  0004a	e9 00 00 00 00	 jmp	 PyErr_NoMemory
$LN9@bytearray_@4:
  0004f	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 339  :         return PyErr_NoMemory();
; 340  :     size = mysize * count;

  00054	48 8b fe	 mov	 rdi, rsi
  00057	48 0f af fd	 imul	 rdi, rbp

; 341  :     if (size < self->ob_alloc) {

  0005b	48 3b 79 78	 cmp	 rdi, QWORD PTR [rcx+120]
  0005f	7d 29		 jge	 SHORT $LN8@bytearray_@4

; 342  :         Py_SIZE(self) = size;
; 343  :         self->ob_bytes[Py_SIZE(self)] = '\0'; /* Trailing null byte */

  00061	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  00068	48 89 79 60	 mov	 QWORD PTR [rcx+96], rdi
  0006c	c6 04 07 00	 mov	 BYTE PTR [rdi+rax], 0
$LN6@bytearray_@4:

; 347  : 
; 348  :     if (mysize == 1)

  00070	48 83 fe 01	 cmp	 rsi, 1
  00074	75 24		 jne	 SHORT $LN5@bytearray_@4

; 349  :         memset(self->ob_bytes, self->ob_bytes[0], size);

  00076	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  0007d	4c 8b c7	 mov	 r8, rdi
  00080	0f be 11	 movsx	 edx, BYTE PTR [rcx]
  00083	e8 00 00 00 00	 call	 memset

; 350  :     else {

  00088	eb 41		 jmp	 SHORT $LN1@bytearray_@4
$LN8@bytearray_@4:

; 344  :     }
; 345  :     else if (PyByteArray_Resize((PyObject *)self, size) < 0)

  0008a	48 8b d7	 mov	 rdx, rdi
  0008d	e8 00 00 00 00	 call	 PyByteArray_Resize
  00092	85 c0		 test	 eax, eax
  00094	79 da		 jns	 SHORT $LN6@bytearray_@4

; 346  :         return NULL;

  00096	33 c0		 xor	 eax, eax
  00098	eb 6f		 jmp	 SHORT $LN19@bytearray_@4
$LN5@bytearray_@4:

; 351  :         Py_ssize_t i;
; 352  :         for (i = 1; i < count; i++)

  0009a	48 83 fd 01	 cmp	 rbp, 1
  0009e	7e 2b		 jle	 SHORT $LN1@bytearray_@4
  000a0	48 8b fe	 mov	 rdi, rsi
  000a3	48 ff cd	 dec	 rbp
  000a6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL3@bytearray_@4:

; 353  :             memcpy(self->ob_bytes + i*mysize, self->ob_bytes, mysize);

  000b0	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  000b7	4c 8b c6	 mov	 r8, rsi
  000ba	48 8d 0c 17	 lea	 rcx, QWORD PTR [rdi+rdx]
  000be	e8 00 00 00 00	 call	 memcpy
  000c3	48 03 fe	 add	 rdi, rsi
  000c6	48 ff cd	 dec	 rbp
  000c9	75 e5		 jne	 SHORT $LL3@bytearray_@4
$LN1@bytearray_@4:

; 354  :     }
; 355  : 
; 356  :     Py_INCREF(self);

  000cb	e8 00 00 00 00	 call	 _Py_PXCTX
  000d0	85 c0		 test	 eax, eax
  000d2	75 32		 jne	 SHORT $LN14@bytearray_@4
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000e2	4c 8b cb	 mov	 r9, rbx
  000e5	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000eb	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000f3	e8 00 00 00 00	 call	 _PyParallel_Guard
  000f8	85 c0		 test	 eax, eax
  000fa	75 06		 jne	 SHORT $LN13@bytearray_@4
  000fc	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00100	74 04		 je	 SHORT $LN14@bytearray_@4
$LN13@bytearray_@4:
  00102	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN14@bytearray_@4:

; 357  :     return (PyObject *)self;

  00106	48 8b c3	 mov	 rax, rbx
$LN19@bytearray_@4:
  00109	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 358  : }

  0010e	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00113	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00118	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011c	5e		 pop	 rsi
  0011d	c3		 ret	 0
bytearray_irepeat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@DBGBDBKF@bytearray?5index?5out?5of?5range?$AA@ ; `string'
EXTRN	PyExc_IndexError:QWORD
EXTRN	PyLong_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_getitem DD imagerel bytearray_getitem
	DD	imagerel bytearray_getitem+67
	DD	imagerel $unwind$bytearray_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_getitem DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BN@DBGBDBKF@bytearray?5index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BN@DBGBDBKF@bytearray?5index?5out?5of?5range?$AA@ DB 'bytearray in'
	DB	'dex out of range', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_getitem
_TEXT	SEGMENT
self$ = 48
i$ = 56
bytearray_getitem PROC					; COMDAT

; 362  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 363  :     if (i < 0)

  00004	48 85 d2	 test	 rdx, rdx
  00007	79 06		 jns	 SHORT $LN6@bytearray_@5

; 364  :         i += Py_SIZE(self);

  00009	48 03 51 60	 add	 rdx, QWORD PTR [rcx+96]

; 365  :     if (i < 0 || i >= Py_SIZE(self)) {

  0000d	78 1a		 js	 SHORT $LN1@bytearray_@5
$LN6@bytearray_@5:
  0000f	48 3b 51 60	 cmp	 rdx, QWORD PTR [rcx+96]
  00013	7d 14		 jge	 SHORT $LN1@bytearray_@5

; 368  :     }
; 369  :     return PyLong_FromLong((unsigned char)(self->ob_bytes[i]));

  00015	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  0001c	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]

; 370  : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN1@bytearray_@5:

; 366  :         PyErr_SetString(PyExc_IndexError, "bytearray index out of range");

  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@DBGBDBKF@bytearray?5index?5out?5of?5range?$AA@
  00037	e8 00 00 00 00	 call	 PyErr_SetString

; 367  :         return NULL;

  0003c	33 c0		 xor	 eax, eax

; 370  : }

  0003e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00042	c3		 ret	 0
bytearray_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@MBEBMMIP@bytearray?5indices?5must?5be?5intege@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
EXTRN	PySlice_GetIndicesEx:PROC
EXTRN	PySlice_Type:BYTE
EXTRN	PyErr_Occurred:PROC
EXTRN	PyNumber_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_subscript DD imagerel bytearray_subscript
	DD	imagerel bytearray_subscript+453
	DD	imagerel $unwind$bytearray_subscript
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_subscript DD 040a01H
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT ??_C@_0CD@MBEBMMIP@bytearray?5indices?5must?5be?5intege@
CONST	SEGMENT
??_C@_0CD@MBEBMMIP@bytearray?5indices?5must?5be?5intege@ DB 'bytearray in'
	DB	'dices must be integers', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_subscript
_TEXT	SEGMENT
stop$20600 = 48
self$ = 80
slicelength$20602 = 88
index$ = 88
start$20599 = 96
step$20601 = 104
bytearray_subscript PROC				; COMDAT

; 374  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b f9	 mov	 rdi, rcx

; 375  :     if (PyIndex_Check(index)) {

  0000d	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00011	4c 8b d2	 mov	 r10, rdx
  00014	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  0001b	48 85 c0	 test	 rax, rax
  0001e	0f 84 84 00 00
	00		 je	 $LN17@bytearray_@6
  00024	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  0002c	74 7a		 je	 SHORT $LN17@bytearray_@6

; 376  :         Py_ssize_t i = PyNumber_AsSsize_t(index, PyExc_IndexError);

  0002e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  00035	49 8b ca	 mov	 rcx, r10
  00038	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  0003d	48 8b d8	 mov	 rbx, rax

; 377  : 
; 378  :         if (i == -1 && PyErr_Occurred())

  00040	48 83 f8 ff	 cmp	 rax, -1
  00044	75 17		 jne	 SHORT $LN16@bytearray_@6
  00046	e8 00 00 00 00	 call	 PyErr_Occurred
  0004b	48 85 c0	 test	 rax, rax
  0004e	74 12		 je	 SHORT $LN27@bytearray_@6

; 423  :         return NULL;

  00050	33 c0		 xor	 eax, eax

; 424  :     }
; 425  : }

  00052	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00057	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0005b	5f		 pop	 rdi
  0005c	c3		 ret	 0
$LN16@bytearray_@6:

; 379  :             return NULL;
; 380  : 
; 381  :         if (i < 0)

  0005d	48 85 c0	 test	 rax, rax
  00060	79 06		 jns	 SHORT $LN26@bytearray_@6
$LN27@bytearray_@6:

; 382  :             i += PyByteArray_GET_SIZE(self);

  00062	48 03 5f 60	 add	 rbx, QWORD PTR [rdi+96]

; 383  : 
; 384  :         if (i < 0 || i >= Py_SIZE(self)) {

  00066	78 20		 js	 SHORT $LN13@bytearray_@6
$LN26@bytearray_@6:
  00068	48 3b 5f 60	 cmp	 rbx, QWORD PTR [rdi+96]
  0006c	7d 1a		 jge	 SHORT $LN13@bytearray_@6

; 386  :             return NULL;
; 387  :         }
; 388  :         return PyLong_FromLong((unsigned char)(self->ob_bytes[i]));

  0006e	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  00075	0f b6 0c 18	 movzx	 ecx, BYTE PTR [rax+rbx]

; 424  :     }
; 425  : }

  00079	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0007e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00082	5f		 pop	 rdi
  00083	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN13@bytearray_@6:

; 385  :             PyErr_SetString(PyExc_IndexError, "bytearray index out of range");

  00088	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@DBGBDBKF@bytearray?5index?5out?5of?5range?$AA@

; 419  :         }
; 420  :     }
; 421  :     else {
; 422  :         PyErr_SetString(PyExc_TypeError, "bytearray indices must be integers");

  00096	e8 00 00 00 00	 call	 PyErr_SetString

; 423  :         return NULL;

  0009b	33 c0		 xor	 eax, eax

; 424  :     }
; 425  : }

  0009d	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000a2	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000a6	5f		 pop	 rdi
  000a7	c3		 ret	 0
$LN17@bytearray_@6:

; 389  :     }
; 390  :     else if (PySlice_Check(index)) {

  000a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  000af	48 3b c8	 cmp	 rcx, rax
  000b2	0f 85 ed 00 00
	00		 jne	 $LN11@bytearray_@6

; 391  :         Py_ssize_t start, stop, step, slicelength, cur, i;
; 392  :         if (PySlice_GetIndicesEx(index,
; 393  :                                  PyByteArray_GET_SIZE(self),
; 394  :                                  &start, &stop, &step, &slicelength) < 0) {

  000b8	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]
  000bc	48 8d 44 24 58	 lea	 rax, QWORD PTR slicelength$20602[rsp]
  000c1	4c 8d 4c 24 30	 lea	 r9, QWORD PTR stop$20600[rsp]
  000c6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000cb	48 8d 44 24 68	 lea	 rax, QWORD PTR step$20601[rsp]
  000d0	4c 8d 44 24 60	 lea	 r8, QWORD PTR start$20599[rsp]
  000d5	49 8b ca	 mov	 rcx, r10
  000d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000dd	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  000e2	85 c0		 test	 eax, eax

; 395  :             return NULL;

  000e4	0f 88 ce 00 00
	00		 js	 $LN28@bytearray_@6

; 396  :         }
; 397  : 
; 398  :         if (slicelength <= 0)

  000ea	48 8b 54 24 58	 mov	 rdx, QWORD PTR slicelength$20602[rsp]
  000ef	48 85 d2	 test	 rdx, rdx
  000f2	7f 19		 jg	 SHORT $LN9@bytearray_@6

; 399  :             return PyByteArray_FromStringAndSize("", 0);

  000f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000fb	33 d2		 xor	 edx, edx
  000fd	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize

; 424  :     }
; 425  : }

  00102	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00107	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0010b	5f		 pop	 rdi
  0010c	c3		 ret	 0
$LN9@bytearray_@6:

; 400  :         else if (step == 1) {

  0010d	48 83 7c 24 68
	01		 cmp	 QWORD PTR step$20601[rsp], 1
  00113	75 1c		 jne	 SHORT $LN7@bytearray_@6

; 401  :             return PyByteArray_FromStringAndSize(self->ob_bytes + start,
; 402  :                                              slicelength);

  00115	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  0011c	48 03 4c 24 60	 add	 rcx, QWORD PTR start$20599[rsp]
  00121	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize

; 424  :     }
; 425  : }

  00126	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0012b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0012f	5f		 pop	 rdi
  00130	c3		 ret	 0
$LN7@bytearray_@6:

; 403  :         }
; 404  :         else {
; 405  :             char *source_buf = PyByteArray_AS_STRING(self);

  00131	48 83 7f 60 00	 cmp	 QWORD PTR [rdi+96], 0
  00136	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_PyByteArray_empty_string
  0013d	74 09		 je	 SHORT $LN20@bytearray_@6
  0013f	48 8b bf 80 00
	00 00		 mov	 rdi, QWORD PTR [rdi+128]
  00146	eb 03		 jmp	 SHORT $LN21@bytearray_@6
$LN20@bytearray_@6:
  00148	48 8b fb	 mov	 rdi, rbx
$LN21@bytearray_@6:

; 406  :             char *result_buf;
; 407  :             PyObject *result;
; 408  : 
; 409  :             result = PyByteArray_FromStringAndSize(NULL, slicelength);

  0014b	33 c9		 xor	 ecx, ecx
  0014d	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00152	4c 8b d8	 mov	 r11, rax

; 410  :             if (result == NULL)

  00155	48 85 c0	 test	 rax, rax

; 411  :                 return NULL;

  00158	74 5e		 je	 SHORT $LN28@bytearray_@6

; 412  : 
; 413  :             result_buf = PyByteArray_AS_STRING(result);

  0015a	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0015f	74 07		 je	 SHORT $LN22@bytearray_@6
  00161	48 8b 98 80 00
	00 00		 mov	 rbx, QWORD PTR [rax+128]
$LN22@bytearray_@6:

; 414  :             for (cur = start, i = 0; i < slicelength;
; 415  :                  cur += step, i++) {

  00168	48 8b 54 24 60	 mov	 rdx, QWORD PTR start$20599[rsp]
  0016d	33 c9		 xor	 ecx, ecx
  0016f	48 39 4c 24 58	 cmp	 QWORD PTR slicelength$20602[rsp], rcx
  00174	7e 21		 jle	 SHORT $LN2@bytearray_@6
  00176	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@bytearray_@6:

; 416  :                      result_buf[i] = source_buf[cur];

  00180	0f b6 04 3a	 movzx	 eax, BYTE PTR [rdx+rdi]
  00184	48 ff c1	 inc	 rcx
  00187	88 44 19 ff	 mov	 BYTE PTR [rcx+rbx-1], al
  0018b	48 03 54 24 68	 add	 rdx, QWORD PTR step$20601[rsp]
  00190	48 3b 4c 24 58	 cmp	 rcx, QWORD PTR slicelength$20602[rsp]
  00195	7c e9		 jl	 SHORT $LL4@bytearray_@6
$LN2@bytearray_@6:

; 417  :             }
; 418  :             return result;

  00197	49 8b c3	 mov	 rax, r11

; 424  :     }
; 425  : }

  0019a	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0019f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001a3	5f		 pop	 rdi
  001a4	c3		 ret	 0
$LN11@bytearray_@6:

; 419  :         }
; 420  :     }
; 421  :     else {
; 422  :         PyErr_SetString(PyExc_TypeError, "bytearray indices must be integers");

  001a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@MBEBMMIP@bytearray?5indices?5must?5be?5intege@
  001b3	e8 00 00 00 00	 call	 PyErr_SetString
$LN28@bytearray_@6:

; 423  :         return NULL;

  001b8	33 c0		 xor	 eax, eax

; 424  :     }
; 425  : }

  001ba	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001bf	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001c3	5f		 pop	 rdi
  001c4	c3		 ret	 0
bytearray_subscript ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@LDFFEMNP@can?8t?5set?5bytearray?5slice?5from?5?$CF@ ; `string'
EXTRN	__imp_memmove:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_setslice DD imagerel bytearray_setslice
	DD	imagerel bytearray_setslice+511
	DD	imagerel $unwind$bytearray_setslice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_setslice DD 061101H
	DD	0133411H
	DD	0700dd211H
	DD	0500b600cH
xdata	ENDS
;	COMDAT ??_C@_0CG@LDFFEMNP@can?8t?5set?5bytearray?5slice?5from?5?$CF@
CONST	SEGMENT
??_C@_0CG@LDFFEMNP@can?8t?5set?5bytearray?5slice?5from?5?$CF@ DB 'can''t '
	DB	'set bytearray slice from %.100s', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_setslice
_TEXT	SEGMENT
vbytes$ = 32
avail$1$ = 144
self$ = 144
lo$ = 152
hi$ = 160
bytes$1$ = 168
values$ = 168
bytearray_setslice PROC					; COMDAT

; 430  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 431  :     Py_ssize_t avail, needed;
; 432  :     void *bytes;
; 433  :     Py_buffer vbytes;
; 434  :     int res = 0;

  00011	33 ff		 xor	 edi, edi
  00013	49 8b d9	 mov	 rbx, r9
  00016	48 8b ea	 mov	 rbp, rdx
  00019	48 8b f1	 mov	 rsi, rcx

; 435  : 
; 436  :     vbytes.len = -1;

  0001c	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR vbytes$[rsp+16], -1

; 437  :     if (values == (PyObject *)self) {

  00025	4c 3b c9	 cmp	 r9, rcx
  00028	75 42		 jne	 SHORT $LN16@bytearray_@7

; 438  :         /* Make a copy and call this function recursively */
; 439  :         int err;
; 440  :         values = PyByteArray_FromObject(values);

  0002a	48 8b cb	 mov	 rcx, rbx
  0002d	e8 00 00 00 00	 call	 PyByteArray_FromObject
  00032	48 8b f8	 mov	 rdi, rax

; 441  :         if (values == NULL)

  00035	48 85 c0	 test	 rax, rax

; 442  :             return -1;

  00038	74 71		 je	 SHORT $LN20@bytearray_@7

; 443  :         err = bytearray_setslice(self, lo, hi, values);

  0003a	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR hi$[rsp]
  00042	4c 8b c8	 mov	 r9, rax
  00045	48 8b d5	 mov	 rdx, rbp
  00048	48 8b ce	 mov	 rcx, rsi
  0004b	e8 00 00 00 00	 call	 bytearray_setslice

; 444  :         Py_DECREF(values);

  00050	48 8b cf	 mov	 rcx, rdi
  00053	8b d8		 mov	 ebx, eax
  00055	e8 00 00 00 00	 call	 _Py_DecRef

; 445  :         return err;

  0005a	8b c3		 mov	 eax, ebx

; 515  : }

  0005c	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  00064	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00068	5f		 pop	 rdi
  00069	5e		 pop	 rsi
  0006a	5d		 pop	 rbp
  0006b	c3		 ret	 0
$LN16@bytearray_@7:

; 446  :     }
; 447  :     if (values == NULL) {

  0006c	48 85 db	 test	 rbx, rbx
  0006f	75 0d		 jne	 SHORT $LN14@bytearray_@7

; 448  :         /* del b[lo:hi] */
; 449  :         bytes = NULL;

  00071	48 89 bc 24 a8
	00 00 00	 mov	 QWORD PTR bytes$1$[rsp], rdi

; 450  :         needed = 0;

  00079	48 8b df	 mov	 rbx, rdi

; 451  :     }
; 452  :     else {

  0007c	eb 5a		 jmp	 SHORT $LN13@bytearray_@7
$LN14@bytearray_@7:

; 453  :             if (_getbuffer(values, &vbytes) < 0) {

  0007e	48 8d 54 24 20	 lea	 rdx, QWORD PTR vbytes$[rsp]
  00083	48 8b cb	 mov	 rcx, rbx
  00086	e8 00 00 00 00	 call	 _getbuffer
  0008b	48 85 c0	 test	 rax, rax
  0008e	79 2e		 jns	 SHORT $LN12@bytearray_@7

; 454  :                     PyErr_Format(PyExc_TypeError,
; 455  :                                  "can't set bytearray slice from %.100s",
; 456  :                                  Py_TYPE(values)->tp_name);

  00090	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  00094	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@LDFFEMNP@can?8t?5set?5bytearray?5slice?5from?5?$CF@
  000a2	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000a6	e8 00 00 00 00	 call	 PyErr_Format
$LN20@bytearray_@7:

; 457  :                     return -1;

  000ab	83 c8 ff	 or	 eax, -1

; 515  : }

  000ae	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  000b6	48 83 c4 70	 add	 rsp, 112		; 00000070H
  000ba	5f		 pop	 rdi
  000bb	5e		 pop	 rsi
  000bc	5d		 pop	 rbp
  000bd	c3		 ret	 0
$LN12@bytearray_@7:

; 458  :             }
; 459  :             needed = vbytes.len;
; 460  :             bytes = vbytes.buf;

  000be	48 8b 44 24 20	 mov	 rax, QWORD PTR vbytes$[rsp]
  000c3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR vbytes$[rsp+16]
  000c8	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR hi$[rsp]
  000d0	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR bytes$1$[rsp], rax
$LN13@bytearray_@7:

; 461  :     }
; 462  : 
; 463  :     if (lo < 0)
; 464  :         lo = 0;
; 465  :     if (hi < lo)
; 466  :         hi = lo;
; 467  :     if (hi > Py_SIZE(self))

  000d8	48 8b 46 60	 mov	 rax, QWORD PTR [rsi+96]
  000dc	48 85 ed	 test	 rbp, rbp
  000df	48 0f 48 ef	 cmovs	 rbp, rdi
  000e3	4c 3b c5	 cmp	 r8, rbp
  000e6	4c 0f 4c c5	 cmovl	 r8, rbp
  000ea	4c 3b c0	 cmp	 r8, rax
  000ed	4c 0f 4f c0	 cmovg	 r8, rax

; 468  :         hi = Py_SIZE(self);
; 469  : 
; 470  :     avail = hi - lo;

  000f1	49 8b c0	 mov	 rax, r8
  000f4	4c 89 84 24 a0
	00 00 00	 mov	 QWORD PTR hi$[rsp], r8
  000fc	48 2b c5	 sub	 rax, rbp
  000ff	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR avail$1$[rsp], rax

; 471  :     if (avail < 0)

  00107	79 16		 jns	 SHORT $LN8@bytearray_@7

; 472  :         lo = hi = avail = 0;

  00109	48 8b c7	 mov	 rax, rdi
  0010c	48 89 bc 24 a0
	00 00 00	 mov	 QWORD PTR hi$[rsp], rdi
  00114	48 8b ef	 mov	 rbp, rdi
  00117	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR avail$1$[rsp], rax
$LN8@bytearray_@7:

; 473  : 
; 474  :     if (avail != needed) {

  0011f	48 3b c3	 cmp	 rax, rbx
  00122	0f 84 94 00 00
	00		 je	 $LN19@bytearray_@7

; 475  :         if (avail > needed) {

  00128	7e 43		 jle	 SHORT $LN6@bytearray_@7

; 476  :             if (!_canresize(self)) {

  0012a	48 8b ce	 mov	 rcx, rsi
  0012d	e8 00 00 00 00	 call	 _canresize
  00132	85 c0		 test	 eax, eax
  00134	75 08		 jne	 SHORT $LN5@bytearray_@7

; 477  :                 res = -1;

  00136	83 cf ff	 or	 edi, -1

; 478  :                 goto finish;

  00139	e9 9d 00 00 00	 jmp	 $finish$20670
$LN5@bytearray_@7:

; 479  :             }
; 480  :             /*
; 481  :               0   lo               hi               old_size
; 482  :               |   |<----avail----->|<-----tomove------>|
; 483  :               |   |<-needed->|<-----tomove------>|
; 484  :               0   lo      new_hi              new_size
; 485  :             */
; 486  :             memmove(self->ob_bytes + lo + needed, self->ob_bytes + hi,
; 487  :                     Py_SIZE(self) - hi);

  0013e	48 8b 86 80 00
	00 00		 mov	 rax, QWORD PTR [rsi+128]
  00145	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR hi$[rsp]
  0014d	4c 8b 46 60	 mov	 r8, QWORD PTR [rsi+96]
  00151	48 8d 14 08	 lea	 rdx, QWORD PTR [rax+rcx]
  00155	4c 2b c1	 sub	 r8, rcx
  00158	48 8d 0c 18	 lea	 rcx, QWORD PTR [rax+rbx]
  0015c	48 03 cd	 add	 rcx, rbp
  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
  00165	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR avail$1$[rsp]
$LN6@bytearray_@7:

; 488  :         }
; 489  :         /* XXX(nnorwitz): need to verify this can't overflow! */
; 490  :         if (PyByteArray_Resize((PyObject *)self,
; 491  :                            Py_SIZE(self) + needed - avail) < 0) {

  0016d	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]
  00171	48 8b ce	 mov	 rcx, rsi
  00174	48 2b d0	 sub	 rdx, rax
  00177	48 03 d3	 add	 rdx, rbx
  0017a	e8 00 00 00 00	 call	 PyByteArray_Resize
  0017f	85 c0		 test	 eax, eax
  00181	79 05		 jns	 SHORT $LN4@bytearray_@7

; 492  :                 res = -1;

  00183	83 cf ff	 or	 edi, -1

; 493  :                 goto finish;

  00186	eb 53		 jmp	 SHORT $finish$20670
$LN4@bytearray_@7:

; 494  :         }
; 495  :         if (avail < needed) {

  00188	48 39 9c 24 90
	00 00 00	 cmp	 QWORD PTR avail$1$[rsp], rbx
  00190	7d 2a		 jge	 SHORT $LN19@bytearray_@7

; 496  :             /*
; 497  :               0   lo        hi               old_size
; 498  :               |   |<-avail->|<-----tomove------>|
; 499  :               |   |<----needed---->|<-----tomove------>|
; 500  :               0   lo            new_hi              new_size
; 501  :              */
; 502  :             memmove(self->ob_bytes + lo + needed, self->ob_bytes + hi,
; 503  :                     Py_SIZE(self) - lo - needed);

  00192	48 8b 86 80 00
	00 00		 mov	 rax, QWORD PTR [rsi+128]
  00199	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR hi$[rsp]
  001a1	4c 8b 46 60	 mov	 r8, QWORD PTR [rsi+96]
  001a5	48 8d 14 08	 lea	 rdx, QWORD PTR [rax+rcx]
  001a9	48 8d 0c 18	 lea	 rcx, QWORD PTR [rax+rbx]
  001ad	4c 2b c3	 sub	 r8, rbx
  001b0	48 03 cd	 add	 rcx, rbp
  001b3	4c 2b c5	 sub	 r8, rbp
  001b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN19@bytearray_@7:

; 504  :         }
; 505  :     }
; 506  : 
; 507  :     if (needed > 0)

  001bc	48 85 db	 test	 rbx, rbx
  001bf	7e 1a		 jle	 SHORT $finish$20670

; 508  :         memcpy(self->ob_bytes + lo, bytes, needed);

  001c1	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  001c8	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR bytes$1$[rsp]
  001d0	4c 8b c3	 mov	 r8, rbx
  001d3	48 03 cd	 add	 rcx, rbp
  001d6	e8 00 00 00 00	 call	 memcpy
$finish$20670:

; 509  : 
; 510  : 
; 511  :  finish:
; 512  :     if (vbytes.len != -1)

  001db	48 83 7c 24 30
	ff		 cmp	 QWORD PTR vbytes$[rsp+16], -1
  001e1	74 0a		 je	 SHORT $LN1@bytearray_@7

; 513  :             PyBuffer_Release(&vbytes);

  001e3	48 8d 4c 24 20	 lea	 rcx, QWORD PTR vbytes$[rsp]
  001e8	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@bytearray_@7:

; 514  :     return res;

  001ed	8b c7		 mov	 eax, edi

; 515  : }

  001ef	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  001f7	48 83 c4 70	 add	 rsp, 112		; 00000070H
  001fb	5f		 pop	 rdi
  001fc	5e		 pop	 rsi
  001fd	5d		 pop	 rbp
  001fe	c3		 ret	 0
bytearray_setslice ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_setitem DD imagerel bytearray_setitem
	DD	imagerel bytearray_setitem+141
	DD	imagerel $unwind$bytearray_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_setitem DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytearray_setitem
_TEXT	SEGMENT
self$ = 48
ival$ = 56
i$ = 56
value$ = 64
bytearray_setitem PROC					; COMDAT

; 519  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 520  :     int ival;
; 521  : 
; 522  :     if (i < 0)

  00010	48 85 d2	 test	 rdx, rdx
  00013	79 06		 jns	 SHORT $LN8@bytearray_@8

; 523  :         i += Py_SIZE(self);

  00015	48 03 59 60	 add	 rbx, QWORD PTR [rcx+96]

; 524  : 
; 525  :     if (i < 0 || i >= Py_SIZE(self)) {

  00019	78 51		 js	 SHORT $LN3@bytearray_@8
$LN8@bytearray_@8:
  0001b	48 3b 59 60	 cmp	 rbx, QWORD PTR [rcx+96]
  0001f	7d 4b		 jge	 SHORT $LN3@bytearray_@8

; 528  :     }
; 529  : 
; 530  :     if (value == NULL)

  00021	4d 85 c0	 test	 r8, r8
  00024	75 19		 jne	 SHORT $LN2@bytearray_@8

; 531  :         return bytearray_setslice(self, i, i+1, NULL);

  00026	4c 8d 43 01	 lea	 r8, QWORD PTR [rbx+1]
  0002a	45 33 c9	 xor	 r9d, r9d
  0002d	48 8b d3	 mov	 rdx, rbx

; 538  : }

  00030	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	e9 00 00 00 00	 jmp	 bytearray_setslice
$LN2@bytearray_@8:

; 532  : 
; 533  :     if (!_getbytevalue(value, &ival))

  0003f	48 8d 54 24 38	 lea	 rdx, QWORD PTR ival$[rsp]
  00044	49 8b c8	 mov	 rcx, r8
  00047	e8 00 00 00 00	 call	 _getbytevalue
  0004c	85 c0		 test	 eax, eax

; 534  :         return -1;

  0004e	74 2f		 je	 SHORT $LN9@bytearray_@8

; 535  : 
; 536  :     self->ob_bytes[i] = ival;

  00050	0f b6 44 24 38	 movzx	 eax, BYTE PTR ival$[rsp]
  00055	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  0005c	88 04 0b	 mov	 BYTE PTR [rbx+rcx], al

; 537  :     return 0;

  0005f	33 c0		 xor	 eax, eax

; 538  : }

  00061	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00066	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006a	5f		 pop	 rdi
  0006b	c3		 ret	 0
$LN3@bytearray_@8:

; 526  :         PyErr_SetString(PyExc_IndexError, "bytearray index out of range");

  0006c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@DBGBDBKF@bytearray?5index?5out?5of?5range?$AA@
  0007a	e8 00 00 00 00	 call	 PyErr_SetString
$LN9@bytearray_@8:

; 527  :         return -1;

  0007f	83 c8 ff	 or	 eax, -1

; 538  : }

  00082	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00087	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
bytearray_setitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@OJNNAELI@bytearray?5indices?5must?5be?5intege@ ; `string'
PUBLIC	??_C@_0EG@MMMHLNMC@can?5assign?5only?5bytes?0?5buffers?0?5@ ; `string'
PUBLIC	??_C@_0EC@MMHHEENM@attempt?5to?5assign?5bytes?5of?5size?5@ ; `string'
EXTRN	PyNumber_Check:PROC
EXTRN	PyType_IsSubtype:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_ass_subscript DD imagerel bytearray_ass_subscript
	DD	imagerel bytearray_ass_subscript+1146
	DD	imagerel $unwind$bytearray_ass_subscript
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_ass_subscript DD 061901H
	DD	0e3419H
	DD	070129219H
	DD	050106011H
xdata	ENDS
;	COMDAT ??_C@_0CC@OJNNAELI@bytearray?5indices?5must?5be?5intege@
CONST	SEGMENT
??_C@_0CC@OJNNAELI@bytearray?5indices?5must?5be?5intege@ DB 'bytearray in'
	DB	'dices must be integer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@MMMHLNMC@can?5assign?5only?5bytes?0?5buffers?0?5@
CONST	SEGMENT
??_C@_0EG@MMMHLNMC@can?5assign?5only?5bytes?0?5buffers?0?5@ DB 'can assig'
	DB	'n only bytes, buffers, or iterables of ints in range(0, 256)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@MMHHEENM@attempt?5to?5assign?5bytes?5of?5size?5@
CONST	SEGMENT
??_C@_0EC@MMHHEENM@attempt?5to?5assign?5bytes?5of?5size?5@ DB 'attempt to'
	DB	' assign bytes of size %zd to extended slice of size %zd', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_ass_subscript
_TEXT	SEGMENT
slicelen$ = 48
stop$ = 56
step$ = 64
bytes$1$ = 72
self$ = 112
needed$1$ = 120
ival$20725 = 120
index$ = 120
values$ = 128
start$ = 136
bytearray_ass_subscript PROC				; COMDAT

; 542  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 8b ec	 mov	 rbp, rsp
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8b c2	 mov	 rax, rdx

; 543  :     Py_ssize_t start, stop, step, slicelen, needed;
; 544  :     char *bytes;
; 545  : 
; 546  :     if (PyIndex_Check(index)) {

  0001c	48 8b 52 58	 mov	 rdx, QWORD PTR [rdx+88]
  00020	48 8b f1	 mov	 rsi, rcx
  00023	48 8b 8a b8 00
	00 00		 mov	 rcx, QWORD PTR [rdx+184]
  0002a	33 ff		 xor	 edi, edi
  0002c	49 8b d8	 mov	 rbx, r8
  0002f	48 85 c9	 test	 rcx, rcx
  00032	0f 84 c3 00 00
	00		 je	 $LN46@bytearray_@9
  00038	48 39 b9 08 01
	00 00		 cmp	 QWORD PTR [rcx+264], rdi
  0003f	0f 84 b6 00 00
	00		 je	 $LN46@bytearray_@9

; 547  :         Py_ssize_t i = PyNumber_AsSsize_t(index, PyExc_IndexError);

  00045	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  0004c	48 8b c8	 mov	 rcx, rax
  0004f	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00054	48 8b d8	 mov	 rbx, rax

; 548  : 
; 549  :         if (i == -1 && PyErr_Occurred())

  00057	48 83 f8 ff	 cmp	 rax, -1
  0005b	75 19		 jne	 SHORT $LN45@bytearray_@9
  0005d	e8 00 00 00 00	 call	 PyErr_Occurred
  00062	48 85 c0	 test	 rax, rax
  00065	74 14		 je	 SHORT $LN54@bytearray_@9

; 584  :         return -1;

  00067	0b c3		 or	 eax, ebx

; 706  :         }
; 707  :     }
; 708  : }

  00069	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0006e	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00072	5f		 pop	 rdi
  00073	5e		 pop	 rsi
  00074	5d		 pop	 rbp
  00075	c3		 ret	 0
$LN45@bytearray_@9:

; 550  :             return -1;
; 551  : 
; 552  :         if (i < 0)

  00076	48 85 c0	 test	 rax, rax
  00079	79 06		 jns	 SHORT $LN53@bytearray_@9
$LN54@bytearray_@9:

; 553  :             i += PyByteArray_GET_SIZE(self);

  0007b	48 03 5e 60	 add	 rbx, QWORD PTR [rsi+96]

; 554  : 
; 555  :         if (i < 0 || i >= Py_SIZE(self)) {

  0007f	78 67		 js	 SHORT $LN42@bytearray_@9
$LN53@bytearray_@9:
  00081	48 3b 5e 60	 cmp	 rbx, QWORD PTR [rsi+96]
  00085	7d 61		 jge	 SHORT $LN42@bytearray_@9

; 558  :         }
; 559  : 
; 560  :         if (values == NULL) {

  00087	48 8b 4d 30	 mov	 rcx, QWORD PTR values$[rbp-80]
  0008b	48 85 c9	 test	 rcx, rcx
  0008e	75 2a		 jne	 SHORT $LN41@bytearray_@9

; 561  :             /* Fall through to slice assignment */
; 562  :             start = i;
; 563  :             stop = i + 1;
; 564  :             step = 1;

  00090	b9 01 00 00 00	 mov	 ecx, 1
  00095	4c 8d 43 01	 lea	 r8, QWORD PTR [rbx+1]
  00099	48 89 5d 38	 mov	 QWORD PTR start$[rbp-80], rbx

; 588  :         bytes = NULL;

  0009d	48 8b d7	 mov	 rdx, rdi

; 589  :         needed = 0;

  000a0	4c 8b d7	 mov	 r10, rdi
  000a3	48 89 7d 28	 mov	 QWORD PTR needed$1$[rbp-80], rdi
  000a7	4c 89 45 e8	 mov	 QWORD PTR stop$[rbp-80], r8
  000ab	48 89 4d f0	 mov	 QWORD PTR step$[rbp-80], rcx
  000af	8b c1		 mov	 eax, ecx
  000b1	48 89 4d e0	 mov	 QWORD PTR slicelen$[rbp-80], rcx
  000b5	e9 e5 00 00 00	 jmp	 $LN60@bytearray_@9
$LN41@bytearray_@9:

; 565  :             slicelen = 1;
; 566  :         }
; 567  :         else {
; 568  :             int ival;
; 569  :             if (!_getbytevalue(values, &ival))

  000ba	48 8d 55 28	 lea	 rdx, QWORD PTR ival$20725[rbp-80]
  000be	e8 00 00 00 00	 call	 _getbytevalue
  000c3	85 c0		 test	 eax, eax

; 570  :                 return -1;

  000c5	0f 84 9f 03 00
	00		 je	 $LN58@bytearray_@9

; 571  :             self->ob_bytes[i] = (char)ival;

  000cb	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  000d2	0f b6 45 28	 movzx	 eax, BYTE PTR ival$20725[rbp-80]
  000d6	88 04 0b	 mov	 BYTE PTR [rbx+rcx], al
$LN63@bytearray_@9:

; 572  :             return 0;

  000d9	33 c0		 xor	 eax, eax

; 706  :         }
; 707  :     }
; 708  : }

  000db	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  000e0	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000e4	5f		 pop	 rdi
  000e5	5e		 pop	 rsi
  000e6	5d		 pop	 rbp
  000e7	c3		 ret	 0
$LN42@bytearray_@9:

; 556  :             PyErr_SetString(PyExc_IndexError, "bytearray index out of range");

  000e8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  000ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@DBGBDBKF@bytearray?5index?5out?5of?5range?$AA@

; 557  :             return -1;

  000f6	e9 6a 03 00 00	 jmp	 $LN59@bytearray_@9
$LN46@bytearray_@9:

; 573  :         }
; 574  :     }
; 575  :     else if (PySlice_Check(index)) {

  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PySlice_Type
  00102	48 3b d1	 cmp	 rdx, rcx
  00105	0f 85 4c 03 00
	00		 jne	 $LN37@bytearray_@9

; 576  :         if (PySlice_GetIndicesEx(index,
; 577  :                                  PyByteArray_GET_SIZE(self),
; 578  :                                  &start, &stop, &step, &slicelen) < 0) {

  0010b	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]
  0010f	48 8d 4d e0	 lea	 rcx, QWORD PTR slicelen$[rbp-80]
  00113	4c 8d 4d e8	 lea	 r9, QWORD PTR stop$[rbp-80]
  00117	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0011c	48 8d 4d f0	 lea	 rcx, QWORD PTR step$[rbp-80]
  00120	4c 8d 45 38	 lea	 r8, QWORD PTR start$[rbp-80]
  00124	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00129	48 8b c8	 mov	 rcx, rax
  0012c	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  00131	85 c0		 test	 eax, eax

; 579  :             return -1;

  00133	0f 88 31 03 00
	00		 js	 $LN58@bytearray_@9

; 585  :     }
; 586  : 
; 587  :     if (values == NULL) {

  00139	48 85 db	 test	 rbx, rbx
  0013c	75 1c		 jne	 SHORT $LN34@bytearray_@9
  0013e	48 8b 5d 38	 mov	 rbx, QWORD PTR start$[rbp-80]
  00142	4c 8b 45 e8	 mov	 r8, QWORD PTR stop$[rbp-80]
  00146	48 8b 4d f0	 mov	 rcx, QWORD PTR step$[rbp-80]
  0014a	48 8b 45 e0	 mov	 rax, QWORD PTR slicelen$[rbp-80]

; 588  :         bytes = NULL;

  0014e	48 8b d7	 mov	 rdx, rdi

; 589  :         needed = 0;

  00151	4c 8b d7	 mov	 r10, rdi
  00154	48 89 7d 28	 mov	 QWORD PTR needed$1$[rbp-80], rdi
  00158	eb 45		 jmp	 SHORT $LN60@bytearray_@9
$LN34@bytearray_@9:

; 590  :     }
; 591  :     else if (values == (PyObject *)self || !PyByteArray_Check(values)) {

  0015a	48 3b de	 cmp	 rbx, rsi
  0015d	0f 84 97 02 00
	00		 je	 $LN31@bytearray_@9
  00163	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00167	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  0016e	48 3b ca	 cmp	 rcx, rdx
  00171	74 0d		 je	 SHORT $LN32@bytearray_@9
  00173	e8 00 00 00 00	 call	 PyType_IsSubtype
  00178	85 c0		 test	 eax, eax
  0017a	0f 84 7a 02 00
	00		 je	 $LN31@bytearray_@9
$LN32@bytearray_@9:

; 606  :     }
; 607  :     else {
; 608  :         assert(PyByteArray_Check(values));
; 609  :         bytes = ((PyByteArrayObject *)values)->ob_bytes;
; 610  :         needed = Py_SIZE(values);

  00180	4c 8b 53 60	 mov	 r10, QWORD PTR [rbx+96]
  00184	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  0018b	4c 8b 45 e8	 mov	 r8, QWORD PTR stop$[rbp-80]
  0018f	48 8b 5d 38	 mov	 rbx, QWORD PTR start$[rbp-80]
  00193	48 8b 4d f0	 mov	 rcx, QWORD PTR step$[rbp-80]
  00197	48 8b 45 e0	 mov	 rax, QWORD PTR slicelen$[rbp-80]
  0019b	4c 89 55 28	 mov	 QWORD PTR needed$1$[rbp-80], r10
$LN60@bytearray_@9:

; 611  :     }
; 612  :     /* Make sure b[5:2] = ... inserts before 5, not before 2. */
; 613  :     if ((step < 0 && start < stop) ||
; 614  :         (step > 0 && start > stop))

  0019f	48 89 55 f8	 mov	 QWORD PTR bytes$1$[rbp-80], rdx
  001a3	48 85 c9	 test	 rcx, rcx
  001a6	79 08		 jns	 SHORT $LN61@bytearray_@9
  001a8	49 3b d8	 cmp	 rbx, r8
  001ab	7c 0a		 jl	 SHORT $LN25@bytearray_@9
  001ad	48 85 c9	 test	 rcx, rcx
$LN61@bytearray_@9:
  001b0	7e 09		 jle	 SHORT $LN26@bytearray_@9
  001b2	49 3b d8	 cmp	 rbx, r8
  001b5	7e 04		 jle	 SHORT $LN26@bytearray_@9
$LN25@bytearray_@9:

; 615  :         stop = start;

  001b7	48 89 5d e8	 mov	 QWORD PTR stop$[rbp-80], rbx
$LN26@bytearray_@9:

; 616  :     if (step == 1) {

  001bb	48 83 f9 01	 cmp	 rcx, 1
  001bf	0f 85 cc 00 00
	00		 jne	 $LN23@bytearray_@9

; 617  :         if (slicelen != needed) {

  001c5	49 3b c2	 cmp	 rax, r10
  001c8	0f 84 98 00 00
	00		 je	 $LN18@bytearray_@9

; 618  :             if (!_canresize(self))

  001ce	48 8b ce	 mov	 rcx, rsi
  001d1	e8 00 00 00 00	 call	 _canresize
  001d6	85 c0		 test	 eax, eax

; 619  :                 return -1;

  001d8	0f 84 8c 02 00
	00		 je	 $LN58@bytearray_@9

; 620  :             if (slicelen > needed) {

  001de	48 8b 45 e0	 mov	 rax, QWORD PTR slicelen$[rbp-80]
  001e2	48 8b 5d 28	 mov	 rbx, QWORD PTR needed$1$[rbp-80]
  001e6	48 3b c3	 cmp	 rax, rbx
  001e9	7e 27		 jle	 SHORT $LN20@bytearray_@9

; 621  :                 /*
; 622  :                   0   start           stop              old_size
; 623  :                   |   |<---slicelen--->|<-----tomove------>|
; 624  :                   |   |<-needed->|<-----tomove------>|
; 625  :                   0   lo      new_hi              new_size
; 626  :                 */
; 627  :                 memmove(self->ob_bytes + start + needed, self->ob_bytes + stop,
; 628  :                         Py_SIZE(self) - stop);

  001eb	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  001f2	48 8b 45 e8	 mov	 rax, QWORD PTR stop$[rbp-80]
  001f6	4c 8b 46 60	 mov	 r8, QWORD PTR [rsi+96]
  001fa	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  001fe	48 03 cb	 add	 rcx, rbx
  00201	4c 2b c0	 sub	 r8, rax
  00204	48 03 4d 38	 add	 rcx, QWORD PTR start$[rbp-80]
  00208	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
  0020e	48 8b 45 e0	 mov	 rax, QWORD PTR slicelen$[rbp-80]
$LN20@bytearray_@9:

; 629  :             }
; 630  :             if (PyByteArray_Resize((PyObject *)self,
; 631  :                                Py_SIZE(self) + needed - slicelen) < 0)

  00212	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]
  00216	48 8b ce	 mov	 rcx, rsi
  00219	48 2b d0	 sub	 rdx, rax
  0021c	48 03 d3	 add	 rdx, rbx
  0021f	e8 00 00 00 00	 call	 PyByteArray_Resize
  00224	85 c0		 test	 eax, eax

; 632  :                 return -1;

  00226	0f 88 3e 02 00
	00		 js	 $LN58@bytearray_@9

; 633  :             if (slicelen < needed) {

  0022c	4c 8b d3	 mov	 r10, rbx
  0022f	48 39 5d e0	 cmp	 QWORD PTR slicelen$[rbp-80], rbx
  00233	7d 2d		 jge	 SHORT $LN56@bytearray_@9

; 634  :                 /*
; 635  :                   0   lo        hi               old_size
; 636  :                   |   |<-avail->|<-----tomove------>|
; 637  :                   |   |<----needed---->|<-----tomove------>|
; 638  :                   0   lo            new_hi              new_size
; 639  :                  */
; 640  :                 memmove(self->ob_bytes + start + needed, self->ob_bytes + stop,
; 641  :                         Py_SIZE(self) - start - needed);

  00235	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  0023c	4c 8b 4d 38	 mov	 r9, QWORD PTR start$[rbp-80]
  00240	48 8b 45 e8	 mov	 rax, QWORD PTR stop$[rbp-80]
  00244	4c 8b 46 60	 mov	 r8, QWORD PTR [rsi+96]
  00248	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  0024c	48 03 cb	 add	 rcx, rbx
  0024f	4c 2b c3	 sub	 r8, rbx
  00252	49 03 c9	 add	 rcx, r9
  00255	4d 2b c1	 sub	 r8, r9
  00258	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
  0025e	4c 8b 55 28	 mov	 r10, QWORD PTR needed$1$[rbp-80]
$LN56@bytearray_@9:
  00262	48 8b 5d 38	 mov	 rbx, QWORD PTR start$[rbp-80]
$LN18@bytearray_@9:

; 642  :             }
; 643  :         }
; 644  : 
; 645  :         if (needed > 0)

  00266	4d 85 d2	 test	 r10, r10
  00269	7e 17		 jle	 SHORT $LN17@bytearray_@9

; 646  :             memcpy(self->ob_bytes + start, bytes, needed);

  0026b	48 8b 86 80 00
	00 00		 mov	 rax, QWORD PTR [rsi+128]
  00272	48 8b 55 f8	 mov	 rdx, QWORD PTR bytes$1$[rbp-80]
  00276	4d 8b c2	 mov	 r8, r10
  00279	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
  0027d	e8 00 00 00 00	 call	 memcpy
$LN17@bytearray_@9:

; 647  : 
; 648  :         return 0;

  00282	33 c0		 xor	 eax, eax

; 706  :         }
; 707  :     }
; 708  : }

  00284	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00289	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0028d	5f		 pop	 rdi
  0028e	5e		 pop	 rsi
  0028f	5d		 pop	 rbp
  00290	c3		 ret	 0
$LN23@bytearray_@9:

; 649  :     }
; 650  :     else {
; 651  :         if (needed == 0) {

  00291	4d 85 d2	 test	 r10, r10
  00294	0f 85 fa 00 00
	00		 jne	 $LN15@bytearray_@9

; 652  :             /* Delete slice */
; 653  :             size_t cur;
; 654  :             Py_ssize_t i;
; 655  : 
; 656  :             if (!_canresize(self))

  0029a	48 8b ce	 mov	 rcx, rsi
  0029d	e8 00 00 00 00	 call	 _canresize
  002a2	85 c0		 test	 eax, eax

; 657  :                 return -1;

  002a4	0f 84 c0 01 00
	00		 je	 $LN58@bytearray_@9

; 658  : 
; 659  :             if (slicelen == 0)

  002aa	4c 8b 45 e0	 mov	 r8, QWORD PTR slicelen$[rbp-80]
  002ae	4d 85 c0	 test	 r8, r8

; 660  :                 /* Nothing to do here. */
; 661  :                 return 0;

  002b1	0f 84 22 fe ff
	ff		 je	 $LN63@bytearray_@9

; 662  : 
; 663  :             if (step < 0) {

  002b7	48 8b 55 f0	 mov	 rdx, QWORD PTR step$[rbp-80]
  002bb	48 85 d2	 test	 rdx, rdx
  002be	79 25		 jns	 SHORT $LN57@bytearray_@9

; 664  :                 stop = start + 1;

  002c0	48 8b 4d 38	 mov	 rcx, QWORD PTR start$[rbp-80]

; 665  :                 start = stop + step * (slicelen - 1) - 1;

  002c4	49 8d 40 ff	 lea	 rax, QWORD PTR [r8-1]
  002c8	48 ff c1	 inc	 rcx
  002cb	48 89 4d e8	 mov	 QWORD PTR stop$[rbp-80], rcx
  002cf	48 0f af c2	 imul	 rax, rdx
  002d3	48 8d 5c 08 ff	 lea	 rbx, QWORD PTR [rax+rcx-1]

; 666  :                 step = -step;

  002d8	48 f7 da	 neg	 rdx
  002db	48 89 5d 38	 mov	 QWORD PTR start$[rbp-80], rbx
  002df	48 89 55 f0	 mov	 QWORD PTR step$[rbp-80], rdx
  002e3	eb 04		 jmp	 SHORT $LN12@bytearray_@9
$LN57@bytearray_@9:
  002e5	48 8b 5d 38	 mov	 rbx, QWORD PTR start$[rbp-80]
$LN12@bytearray_@9:

; 667  :             }
; 668  :             for (cur = start, i = 0;
; 669  :                  i < slicelen; cur += step, i++) {

  002e9	4d 85 c0	 test	 r8, r8
  002ec	7e 4d		 jle	 SHORT $LN9@bytearray_@9
  002ee	66 90		 npad	 2
$LL11@bytearray_@9:

; 670  :                 Py_ssize_t lim = step - 1;
; 671  : 
; 672  :                 if (cur + step >= (size_t)PyByteArray_GET_SIZE(self))

  002f0	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  002f4	48 8d 04 13	 lea	 rax, QWORD PTR [rbx+rdx]
  002f8	4c 8d 42 ff	 lea	 r8, QWORD PTR [rdx-1]
  002fc	48 3b c1	 cmp	 rax, rcx
  002ff	72 09		 jb	 SHORT $LN8@bytearray_@9

; 673  :                     lim = PyByteArray_GET_SIZE(self) - cur - 1;

  00301	4c 8b c1	 mov	 r8, rcx
  00304	4c 2b c3	 sub	 r8, rbx
  00307	49 ff c8	 dec	 r8
$LN8@bytearray_@9:

; 674  : 
; 675  :                 memmove(self->ob_bytes + cur - i,
; 676  :                         self->ob_bytes + cur + 1, lim);

  0030a	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  00311	48 8d 54 19 01	 lea	 rdx, QWORD PTR [rcx+rbx+1]
  00316	48 2b cf	 sub	 rcx, rdi
  00319	48 03 cb	 add	 rcx, rbx
  0031c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
  00322	48 8b 55 f0	 mov	 rdx, QWORD PTR step$[rbp-80]
  00326	4c 8b 45 e0	 mov	 r8, QWORD PTR slicelen$[rbp-80]
  0032a	48 ff c7	 inc	 rdi
  0032d	48 03 da	 add	 rbx, rdx
  00330	49 3b f8	 cmp	 rdi, r8
  00333	7c bb		 jl	 SHORT $LL11@bytearray_@9

; 667  :             }
; 668  :             for (cur = start, i = 0;
; 669  :                  i < slicelen; cur += step, i++) {

  00335	48 8b 5d 38	 mov	 rbx, QWORD PTR start$[rbp-80]
  00339	33 ff		 xor	 edi, edi
$LN9@bytearray_@9:

; 677  :             }
; 678  :             /* Move the tail of the bytes, in one chunk */
; 679  :             cur = start + (size_t)slicelen*step;
; 680  :             if (cur < (size_t)PyByteArray_GET_SIZE(self)) {

  0033b	4c 8b 4e 60	 mov	 r9, QWORD PTR [rsi+96]
  0033f	49 8b c0	 mov	 rax, r8
  00342	48 0f af c2	 imul	 rax, rdx
  00346	48 03 c3	 add	 rax, rbx
  00349	49 3b c1	 cmp	 rax, r9
  0034c	73 21		 jae	 SHORT $LN7@bytearray_@9

; 681  :                 memmove(self->ob_bytes + cur - slicelen,
; 682  :                         self->ob_bytes + cur,
; 683  :                         PyByteArray_GET_SIZE(self) - cur);

  0034e	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  00355	4c 2b c8	 sub	 r9, rax
  00358	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  0035c	49 2b c8	 sub	 rcx, r8
  0035f	4d 8b c1	 mov	 r8, r9
  00362	48 03 c8	 add	 rcx, rax
  00365	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
  0036b	4c 8b 45 e0	 mov	 r8, QWORD PTR slicelen$[rbp-80]
$LN7@bytearray_@9:

; 684  :             }
; 685  :             if (PyByteArray_Resize((PyObject *)self,
; 686  :                                PyByteArray_GET_SIZE(self) - slicelen) < 0)

  0036f	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]
  00373	48 8b ce	 mov	 rcx, rsi
  00376	49 2b d0	 sub	 rdx, r8
  00379	e8 00 00 00 00	 call	 PyByteArray_Resize
  0037e	85 c0		 test	 eax, eax
  00380	40 0f 99 c7	 setns	 dil
  00384	8d 47 ff	 lea	 eax, DWORD PTR [rdi-1]

; 706  :         }
; 707  :     }
; 708  : }

  00387	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0038c	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00390	5f		 pop	 rdi
  00391	5e		 pop	 rsi
  00392	5d		 pop	 rbp
  00393	c3		 ret	 0
$LN15@bytearray_@9:

; 687  :                 return -1;
; 688  : 
; 689  :             return 0;
; 690  :         }
; 691  :         else {
; 692  :             /* Assign slice */
; 693  :             Py_ssize_t i;
; 694  :             size_t cur;
; 695  : 
; 696  :             if (needed != slicelen) {

  00394	4c 3b d0	 cmp	 r10, rax
  00397	74 29		 je	 SHORT $LN4@bytearray_@9

; 697  :                 PyErr_Format(PyExc_ValueError,
; 698  :                              "attempt to assign bytes of size %zd "
; 699  :                              "to extended slice of size %zd",
; 700  :                              needed, slicelen);

  00399	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  003a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@MMHHEENM@attempt?5to?5assign?5bytes?5of?5size?5@
  003a7	4c 8b c8	 mov	 r9, rax
  003aa	4d 8b c2	 mov	 r8, r10
  003ad	e8 00 00 00 00	 call	 PyErr_Format
  003b2	83 c8 ff	 or	 eax, -1

; 706  :         }
; 707  :     }
; 708  : }

  003b5	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  003ba	48 83 c4 50	 add	 rsp, 80			; 00000050H
  003be	5f		 pop	 rdi
  003bf	5e		 pop	 rsi
  003c0	5d		 pop	 rbp
  003c1	c3		 ret	 0
$LN4@bytearray_@9:

; 701  :                 return -1;
; 702  :             }
; 703  :             for (cur = start, i = 0; i < slicelen; cur += step, i++)

  003c2	48 85 c0	 test	 rax, rax
  003c5	7e 24		 jle	 SHORT $LN1@bytearray_@9
  003c7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL3@bytearray_@9:

; 704  :                 self->ob_bytes[cur] = bytes[i];

  003d0	0f b6 04 17	 movzx	 eax, BYTE PTR [rdi+rdx]
  003d4	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  003db	48 ff c7	 inc	 rdi
  003de	88 04 0b	 mov	 BYTE PTR [rbx+rcx], al
  003e1	48 03 5d f0	 add	 rbx, QWORD PTR step$[rbp-80]
  003e5	48 3b 7d e0	 cmp	 rdi, QWORD PTR slicelen$[rbp-80]
  003e9	7c e5		 jl	 SHORT $LL3@bytearray_@9
$LN1@bytearray_@9:

; 705  :             return 0;

  003eb	33 c0		 xor	 eax, eax

; 706  :         }
; 707  :     }
; 708  : }

  003ed	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  003f2	48 83 c4 50	 add	 rsp, 80			; 00000050H
  003f6	5f		 pop	 rdi
  003f7	5e		 pop	 rsi
  003f8	5d		 pop	 rbp
  003f9	c3		 ret	 0
$LN31@bytearray_@9:

; 592  :         int err;
; 593  :         if (PyNumber_Check(values) || PyUnicode_Check(values)) {

  003fa	48 8b cb	 mov	 rcx, rbx
  003fd	e8 00 00 00 00	 call	 PyNumber_Check
  00402	85 c0		 test	 eax, eax
  00404	75 48		 jne	 SHORT $LN29@bytearray_@9
  00406	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0040a	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00414	75 38		 jne	 SHORT $LN29@bytearray_@9

; 598  :         }
; 599  :         /* Make a copy and call this function recursively */
; 600  :         values = PyByteArray_FromObject(values);

  00416	48 8b cb	 mov	 rcx, rbx
  00419	e8 00 00 00 00	 call	 PyByteArray_FromObject
  0041e	48 8b f8	 mov	 rdi, rax

; 601  :         if (values == NULL)

  00421	48 85 c0	 test	 rax, rax

; 602  :             return -1;

  00424	74 44		 je	 SHORT $LN58@bytearray_@9

; 603  :         err = bytearray_ass_subscript(self, index, values);

  00426	48 8b 55 28	 mov	 rdx, QWORD PTR index$[rbp-80]
  0042a	4c 8b c0	 mov	 r8, rax
  0042d	48 8b ce	 mov	 rcx, rsi
  00430	e8 00 00 00 00	 call	 bytearray_ass_subscript

; 604  :         Py_DECREF(values);

  00435	48 8b cf	 mov	 rcx, rdi
  00438	8b d8		 mov	 ebx, eax
  0043a	e8 00 00 00 00	 call	 _Py_DecRef

; 605  :         return err;

  0043f	8b c3		 mov	 eax, ebx

; 706  :         }
; 707  :     }
; 708  : }

  00441	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00446	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0044a	5f		 pop	 rdi
  0044b	5e		 pop	 rsi
  0044c	5d		 pop	 rbp
  0044d	c3		 ret	 0
$LN29@bytearray_@9:

; 594  :             PyErr_SetString(PyExc_TypeError,
; 595  :                             "can assign only bytes, buffers, or iterables "
; 596  :                             "of ints in range(0, 256)");

  0044e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EG@MMMHLNMC@can?5assign?5only?5bytes?0?5buffers?0?5@

; 597  :             return -1;

  00455	eb 07		 jmp	 SHORT $LN62@bytearray_@9
$LN37@bytearray_@9:

; 580  :         }
; 581  :     }
; 582  :     else {
; 583  :         PyErr_SetString(PyExc_TypeError, "bytearray indices must be integer");

  00457	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@OJNNAELI@bytearray?5indices?5must?5be?5intege@
$LN62@bytearray_@9:
  0045e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
$LN59@bytearray_@9:
  00465	e8 00 00 00 00	 call	 PyErr_SetString
$LN58@bytearray_@9:

; 584  :         return -1;

  0046a	83 c8 ff	 or	 eax, -1

; 706  :         }
; 707  :     }
; 708  : }

  0046d	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00472	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00476	5f		 pop	 rdi
  00477	5e		 pop	 rsi
  00478	5d		 pop	 rbp
  00479	c3		 ret	 0
bytearray_ass_subscript ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@GAIODIPO@encoding?5or?5errors?5without?5a?5str@ ; `string'
PUBLIC	??_C@_0P@DIJHAIGC@negative?5count?$AA@		; `string'
PUBLIC	??_C@_0CE@DBOLPEDK@string?5argument?5without?5an?5encod@ ; `string'
PUBLIC	??_C@_0CN@GEIFFAEN@encoding?5or?5errors?5without?5seque@ ; `string'
PUBLIC	??_C@_0P@KMGFKFIF@?$HMOss?3bytearray?$AA@	; `string'
EXTRN	PyExc_StopIteration:QWORD
EXTRN	PyObject_GetIter:PROC
EXTRN	PyBuffer_ToContiguous:PROC
EXTRN	PyObject_GetBuffer:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyUnicode_AsEncodedString:PROC
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_init DD imagerel bytearray_init
	DD	imagerel bytearray_init+547
	DD	imagerel $unwind$bytearray_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$bytearray_init DD imagerel bytearray_init+547
	DD	imagerel bytearray_init+580
	DD	imagerel $chain$0$bytearray_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$bytearray_init DD imagerel bytearray_init+580
	DD	imagerel bytearray_init+779
	DD	imagerel $chain$1$bytearray_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$bytearray_init DD imagerel bytearray_init+779
	DD	imagerel bytearray_init+798
	DD	imagerel $chain$2$bytearray_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$bytearray_init DD imagerel bytearray_init+798
	DD	imagerel bytearray_init+811
	DD	imagerel $chain$4$bytearray_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$bytearray_init DD imagerel bytearray_init+811
	DD	imagerel bytearray_init+933
	DD	imagerel $chain$5$bytearray_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$bytearray_init DD 021H
	DD	imagerel bytearray_init
	DD	imagerel bytearray_init+547
	DD	imagerel $unwind$bytearray_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$bytearray_init DD 040021H
	DD	01ac400H
	DD	0195400H
	DD	imagerel bytearray_init
	DD	imagerel bytearray_init+547
	DD	imagerel $unwind$bytearray_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$bytearray_init DD 021H
	DD	imagerel bytearray_init+547
	DD	imagerel bytearray_init+580
	DD	imagerel $chain$0$bytearray_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$bytearray_init DD 020821H
	DD	01ac408H
	DD	imagerel bytearray_init+547
	DD	imagerel bytearray_init+580
	DD	imagerel $chain$0$bytearray_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$bytearray_init DD 020821H
	DD	0195408H
	DD	imagerel bytearray_init
	DD	imagerel bytearray_init+547
	DD	imagerel $unwind$bytearray_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_init DD 050b01H
	DD	014010bH
	DD	060037004H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_0CN@GAIODIPO@encoding?5or?5errors?5without?5a?5str@
CONST	SEGMENT
??_C@_0CN@GAIODIPO@encoding?5or?5errors?5without?5a?5str@ DB 'encoding or'
	DB	' errors without a string argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DIJHAIGC@negative?5count?$AA@
CONST	SEGMENT
??_C@_0P@DIJHAIGC@negative?5count?$AA@ DB 'negative count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DBOLPEDK@string?5argument?5without?5an?5encod@
CONST	SEGMENT
??_C@_0CE@DBOLPEDK@string?5argument?5without?5an?5encod@ DB 'string argum'
	DB	'ent without an encoding', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GEIFFAEN@encoding?5or?5errors?5without?5seque@
CONST	SEGMENT
??_C@_0CN@GEIFFAEN@encoding?5or?5errors?5without?5seque@ DB 'encoding or '
	DB	'errors without sequence argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KMGFKFIF@?$HMOss?3bytearray?$AA@
CONST	SEGMENT
??_C@_0P@KMGFKFIF@?$HMOss?3bytearray?$AA@ DB '|Oss:bytearray', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_init
_TEXT	SEGMENT
errors$ = 64
arg$ = 72
view$20875 = 80
value$20889 = 192
self$ = 192
args$ = 200
kwds$ = 208
encoding$ = 216
bytearray_init PROC					; COMDAT

; 712  : {

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 713  :     static char *kwlist[] = {"source", "encoding", "errors", 0};
; 714  :     PyObject *arg = NULL;

  0000b	33 c0		 xor	 eax, eax
  0000d	49 8b d8	 mov	 rbx, r8
  00010	48 8b f2	 mov	 rsi, rdx
  00013	48 8b f9	 mov	 rdi, rcx
  00016	48 89 44 24 48	 mov	 QWORD PTR arg$[rsp], rax

; 715  :     const char *encoding = NULL;

  0001b	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR encoding$[rsp], rax

; 716  :     const char *errors = NULL;

  00023	48 89 44 24 40	 mov	 QWORD PTR errors$[rsp], rax

; 717  :     Py_ssize_t count;
; 718  :     PyObject *it;
; 719  :     PyObject *(*iternext)(PyObject *);
; 720  : 
; 721  :     if (Py_SIZE(self) != 0) {

  00028	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  0002c	74 0b		 je	 SHORT $LN32@bytearray_@10

; 722  :         /* Empty previous contents (yes, do this first of all!) */
; 723  :         if (PyByteArray_Resize((PyObject *)self, 0) < 0)

  0002e	33 d2		 xor	 edx, edx
  00030	e8 00 00 00 00	 call	 PyByteArray_Resize
  00035	85 c0		 test	 eax, eax

; 724  :             return -1;

  00037	78 70		 js	 SHORT $LN45@bytearray_@10
$LN32@bytearray_@10:

; 725  :     }
; 726  : 
; 727  :     /* Parse arguments */
; 728  :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|Oss:bytearray", kwlist,
; 729  :                                      &arg, &encoding, &errors))

  00039	48 8d 44 24 40	 lea	 rax, QWORD PTR errors$[rsp]
  0003e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??bytearray_init@@9@9
  00045	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0P@KMGFKFIF@?$HMOss?3bytearray?$AA@
  0004c	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00051	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR encoding$[rsp]
  00059	48 8b d3	 mov	 rdx, rbx
  0005c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00061	48 8d 44 24 48	 lea	 rax, QWORD PTR arg$[rsp]
  00066	48 8b ce	 mov	 rcx, rsi
  00069	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006e	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00073	85 c0		 test	 eax, eax

; 730  :         return -1;

  00075	74 32		 je	 SHORT $LN45@bytearray_@10

; 731  : 
; 732  :     /* Make a quick exit if no first argument */
; 733  :     if (arg == NULL) {

  00077	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arg$[rsp]
  0007c	48 85 c9	 test	 rcx, rcx
  0007f	75 36		 jne	 SHORT $LN30@bytearray_@10

; 734  :         if (encoding != NULL || errors != NULL) {

  00081	48 39 8c 24 d8
	00 00 00	 cmp	 QWORD PTR encoding$[rsp], rcx
  00089	75 0b		 jne	 SHORT $LN28@bytearray_@10
  0008b	48 39 4c 24 40	 cmp	 QWORD PTR errors$[rsp], rcx

; 738  :         }
; 739  :         return 0;

  00090	0f 84 94 00 00
	00		 je	 $LN46@bytearray_@10
$LN28@bytearray_@10:

; 735  :             PyErr_SetString(PyExc_TypeError,
; 736  :                             "encoding or errors without sequence argument");

  00096	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@GEIFFAEN@encoding?5or?5errors?5without?5seque@
  000a4	e8 00 00 00 00	 call	 PyErr_SetString
$LN45@bytearray_@10:

; 737  :             return -1;

  000a9	83 c8 ff	 or	 eax, -1

; 852  : }

  000ac	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  000b3	5f		 pop	 rdi
  000b4	5e		 pop	 rsi
  000b5	5b		 pop	 rbx
  000b6	c3		 ret	 0
$LN30@bytearray_@10:

; 740  :     }
; 741  : 
; 742  :     if (PyUnicode_Check(arg)) {

  000b7	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  000bb	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  000c5	74 70		 je	 SHORT $LN27@bytearray_@10

; 743  :         /* Encode via the codec registry */
; 744  :         PyObject *encoded, *new;
; 745  :         if (encoding == NULL) {

  000c7	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR encoding$[rsp]
  000cf	48 85 d2	 test	 rdx, rdx
  000d2	75 21		 jne	 SHORT $LN26@bytearray_@10

; 746  :             PyErr_SetString(PyExc_TypeError,
; 747  :                             "string argument without an encoding");

  000d4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@DBOLPEDK@string?5argument?5without?5an?5encod@
  000e2	e8 00 00 00 00	 call	 PyErr_SetString

; 748  :             return -1;

  000e7	83 c8 ff	 or	 eax, -1

; 852  : }

  000ea	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  000f1	5f		 pop	 rdi
  000f2	5e		 pop	 rsi
  000f3	5b		 pop	 rbx
  000f4	c3		 ret	 0
$LN26@bytearray_@10:

; 749  :         }
; 750  :         encoded = PyUnicode_AsEncodedString(arg, encoding, errors);

  000f5	4c 8b 44 24 40	 mov	 r8, QWORD PTR errors$[rsp]
  000fa	e8 00 00 00 00	 call	 PyUnicode_AsEncodedString
  000ff	48 8b d8	 mov	 rbx, rax

; 751  :         if (encoded == NULL)

  00102	48 85 c0	 test	 rax, rax

; 752  :             return -1;

  00105	74 a2		 je	 SHORT $LN45@bytearray_@10

; 753  :         assert(PyBytes_Check(encoded));
; 754  :         new = bytearray_iconcat(self, encoded);

  00107	48 8b d0	 mov	 rdx, rax
  0010a	48 8b cf	 mov	 rcx, rdi
  0010d	e8 00 00 00 00	 call	 bytearray_iconcat

; 755  :         Py_DECREF(encoded);

  00112	48 8b cb	 mov	 rcx, rbx
  00115	48 8b f8	 mov	 rdi, rax
  00118	e8 00 00 00 00	 call	 _Py_DecRef

; 756  :         if (new == NULL)

  0011d	48 85 ff	 test	 rdi, rdi

; 757  :             return -1;

  00120	74 87		 je	 SHORT $LN45@bytearray_@10

; 758  :         Py_DECREF(new);

  00122	48 8b cf	 mov	 rcx, rdi
  00125	e8 00 00 00 00	 call	 _Py_DecRef
$LN46@bytearray_@10:

; 759  :         return 0;

  0012a	33 c0		 xor	 eax, eax

; 852  : }

  0012c	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00133	5f		 pop	 rdi
  00134	5e		 pop	 rsi
  00135	5b		 pop	 rbx
  00136	c3		 ret	 0
$LN27@bytearray_@10:

; 760  :     }
; 761  : 
; 762  :     /* If it's not unicode, there can't be encoding or errors */
; 763  :     if (encoding != NULL || errors != NULL) {

  00137	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR encoding$[rsp], 0
  00140	0f 85 3e 02 00
	00		 jne	 $LN22@bytearray_@10
  00146	48 83 7c 24 40
	00		 cmp	 QWORD PTR errors$[rsp], 0
  0014c	0f 85 32 02 00
	00		 jne	 $LN22@bytearray_@10

; 767  :     }
; 768  : 
; 769  :     /* Is it an int? */
; 770  :     count = PyNumber_AsSsize_t(arg, PyExc_OverflowError);

  00152	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00159	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  0015e	48 8b d8	 mov	 rbx, rax

; 771  :     if (count == -1 && PyErr_Occurred()) {

  00161	48 83 f8 ff	 cmp	 rax, -1
  00165	0f 85 c0 01 00
	00		 jne	 $LN21@bytearray_@10
  0016b	e8 00 00 00 00	 call	 PyErr_Occurred
  00170	48 85 c0	 test	 rax, rax
  00173	0f 84 b7 01 00
	00		 je	 $LN41@bytearray_@10

; 772  :         if (PyErr_ExceptionMatches(PyExc_OverflowError))

  00179	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00180	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00185	85 c0		 test	 eax, eax

; 773  :             return -1;

  00187	0f 85 1c ff ff
	ff		 jne	 $LN45@bytearray_@10

; 774  :         PyErr_Clear();

  0018d	e8 00 00 00 00	 call	 PyErr_Clear

; 787  :     }
; 788  : 
; 789  :     /* Use the buffer API */
; 790  :     if (PyObject_CheckBuffer(arg)) {

  00192	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arg$[rsp]
  00197	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0019b	48 8b 90 f8 00
	00 00		 mov	 rdx, QWORD PTR [rax+248]
  001a2	48 85 d2	 test	 rdx, rdx
  001a5	74 7c		 je	 SHORT $LN14@bytearray_@10
  001a7	48 83 3a 00	 cmp	 QWORD PTR [rdx], 0
  001ab	74 76		 je	 SHORT $LN14@bytearray_@10

; 791  :         Py_ssize_t size;
; 792  :         Py_buffer view;
; 793  :         if (PyObject_GetBuffer(arg, &view, PyBUF_FULL_RO) < 0)

  001ad	48 8d 54 24 50	 lea	 rdx, QWORD PTR view$20875[rsp]
  001b2	41 b8 1c 01 00
	00		 mov	 r8d, 284		; 0000011cH
  001b8	e8 00 00 00 00	 call	 PyObject_GetBuffer
  001bd	85 c0		 test	 eax, eax

; 794  :             return -1;

  001bf	0f 88 e4 fe ff
	ff		 js	 $LN45@bytearray_@10

; 795  :         size = view.len;

  001c5	48 8b 5c 24 60	 mov	 rbx, QWORD PTR view$20875[rsp+16]

; 796  :         if (PyByteArray_Resize((PyObject *)self, size) < 0) goto fail;

  001ca	48 8b cf	 mov	 rcx, rdi
  001cd	48 8b d3	 mov	 rdx, rbx
  001d0	e8 00 00 00 00	 call	 PyByteArray_Resize
  001d5	85 c0		 test	 eax, eax
  001d7	78 32		 js	 SHORT $fail$20879

; 797  :         if (PyBuffer_ToContiguous(self->ob_bytes, &view, size, 'C') < 0)

  001d9	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  001e0	48 8d 54 24 50	 lea	 rdx, QWORD PTR view$20875[rsp]
  001e5	41 b1 43	 mov	 r9b, 67			; 00000043H
  001e8	4c 8b c3	 mov	 r8, rbx
  001eb	e8 00 00 00 00	 call	 PyBuffer_ToContiguous
  001f0	85 c0		 test	 eax, eax
  001f2	78 17		 js	 SHORT $fail$20879

; 798  :             goto fail;
; 799  :         PyBuffer_Release(&view);

  001f4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR view$20875[rsp]
  001f9	e8 00 00 00 00	 call	 PyBuffer_Release

; 800  :         return 0;

  001fe	33 c0		 xor	 eax, eax

; 852  : }

  00200	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00207	5f		 pop	 rdi
  00208	5e		 pop	 rsi
  00209	5b		 pop	 rbx
  0020a	c3		 ret	 0
$fail$20879:

; 801  :     fail:
; 802  :         PyBuffer_Release(&view);

  0020b	48 8d 4c 24 50	 lea	 rcx, QWORD PTR view$20875[rsp]
  00210	e8 00 00 00 00	 call	 PyBuffer_Release

; 803  :         return -1;

  00215	83 c8 ff	 or	 eax, -1

; 852  : }

  00218	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  0021f	5f		 pop	 rdi
  00220	5e		 pop	 rsi
  00221	5b		 pop	 rbx
  00222	c3		 ret	 0
$LN14@bytearray_@10:
  00223	48 89 ac 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], rbp

; 804  :     }
; 805  : 
; 806  :     /* XXX Optimize this if the arguments is a list, tuple */
; 807  : 
; 808  :     /* Get the iterator */
; 809  :     it = PyObject_GetIter(arg);

  0022b	e8 00 00 00 00	 call	 PyObject_GetIter
  00230	48 8b e8	 mov	 rbp, rax

; 810  :     if (it == NULL)

  00233	48 85 c0	 test	 rax, rax
  00236	75 08		 jne	 SHORT $LN10@bytearray_@10

; 811  :         return -1;

  00238	83 c8 ff	 or	 eax, -1
  0023b	e9 cb 00 00 00	 jmp	 $LN42@bytearray_@10
$LN10@bytearray_@10:

; 812  :     iternext = *Py_TYPE(it)->tp_iternext;

  00240	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00244	4c 89 a4 24 d0
	00 00 00	 mov	 QWORD PTR [rsp+208], r12

; 813  : 
; 814  :     /* Run the iterator to exhaustion */
; 815  :     for (;;) {
; 816  :         PyObject *item;
; 817  :         int rc, value;
; 818  : 
; 819  :         /* Get the next item */
; 820  :         item = iternext(it);

  0024c	48 8b cd	 mov	 rcx, rbp
  0024f	4c 8b a0 38 01
	00 00		 mov	 r12, QWORD PTR [rax+312]
  00256	41 ff d4	 call	 r12
  00259	48 8b f0	 mov	 rsi, rax

; 821  :         if (item == NULL) {

  0025c	48 85 c0	 test	 rax, rax
  0025f	74 79		 je	 SHORT $LN37@bytearray_@10
  00261	66 66 66 66 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL9@bytearray_@10:

; 826  :             }
; 827  :             break;
; 828  :         }
; 829  : 
; 830  :         /* Interpret it as an int (__index__) */
; 831  :         rc = _getbytevalue(item, &value);

  00270	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR value$20889[rsp]
  00278	48 8b ce	 mov	 rcx, rsi
  0027b	e8 00 00 00 00	 call	 _getbytevalue

; 832  :         Py_DECREF(item);

  00280	48 8b ce	 mov	 rcx, rsi
  00283	8b d8		 mov	 ebx, eax
  00285	e8 00 00 00 00	 call	 _Py_DecRef

; 833  :         if (!rc)

  0028a	85 db		 test	 ebx, ebx
  0028c	0f 84 8c 00 00
	00		 je	 $error$20894

; 834  :             goto error;
; 835  : 
; 836  :         /* Append the byte */
; 837  :         if (Py_SIZE(self) < self->ob_alloc)

  00292	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]
  00296	48 3b 57 78	 cmp	 rdx, QWORD PTR [rdi+120]
  0029a	7d 0a		 jge	 SHORT $LN3@bytearray_@10

; 838  :             Py_SIZE(self)++;

  0029c	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  002a0	48 89 47 60	 mov	 QWORD PTR [rdi+96], rax
  002a4	eb 0f		 jmp	 SHORT $LN1@bytearray_@10
$LN3@bytearray_@10:

; 839  :         else if (PyByteArray_Resize((PyObject *)self, Py_SIZE(self)+1) < 0)

  002a6	48 ff c2	 inc	 rdx
  002a9	48 8b cf	 mov	 rcx, rdi
  002ac	e8 00 00 00 00	 call	 PyByteArray_Resize
  002b1	85 c0		 test	 eax, eax
  002b3	78 69		 js	 SHORT $error$20894
$LN1@bytearray_@10:

; 840  :             goto error;
; 841  :         self->ob_bytes[Py_SIZE(self)-1] = value;

  002b5	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  002b9	48 8b 97 80 00
	00 00		 mov	 rdx, QWORD PTR [rdi+128]
  002c0	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR value$20889[rsp]
  002c8	88 44 0a ff	 mov	 BYTE PTR [rdx+rcx-1], al
  002cc	48 8b cd	 mov	 rcx, rbp
  002cf	41 ff d4	 call	 r12
  002d2	48 8b f0	 mov	 rsi, rax
  002d5	48 85 c0	 test	 rax, rax
  002d8	75 96		 jne	 SHORT $LL9@bytearray_@10
$LN37@bytearray_@10:

; 822  :             if (PyErr_Occurred()) {

  002da	e8 00 00 00 00	 call	 PyErr_Occurred
  002df	48 85 c0	 test	 rax, rax
  002e2	74 15		 je	 SHORT $LN6@bytearray_@10

; 823  :                 if (!PyErr_ExceptionMatches(PyExc_StopIteration))

  002e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_StopIteration
  002eb	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  002f0	85 c0		 test	 eax, eax
  002f2	74 2a		 je	 SHORT $error$20894

; 824  :                     goto error;
; 825  :                 PyErr_Clear();

  002f4	e8 00 00 00 00	 call	 PyErr_Clear
$LN6@bytearray_@10:

; 842  :     }
; 843  : 
; 844  :     /* Clean up and return success */
; 845  :     Py_DECREF(it);

  002f9	48 8b cd	 mov	 rcx, rbp
  002fc	e8 00 00 00 00	 call	 _Py_DecRef

; 846  :     return 0;

  00301	33 c0		 xor	 eax, eax
$LN43@bytearray_@10:
  00303	4c 8b a4 24 d0
	00 00 00	 mov	 r12, QWORD PTR [rsp+208]
$LN42@bytearray_@10:
  0030b	48 8b ac 24 c8
	00 00 00	 mov	 rbp, QWORD PTR [rsp+200]

; 852  : }

  00313	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  0031a	5f		 pop	 rdi
  0031b	5e		 pop	 rsi
  0031c	5b		 pop	 rbx
  0031d	c3		 ret	 0
$error$20894:

; 847  : 
; 848  :  error:
; 849  :     /* Error handling when it != NULL */
; 850  :     Py_DECREF(it);

  0031e	48 8b cd	 mov	 rcx, rbp
  00321	e8 00 00 00 00	 call	 _Py_DecRef

; 851  :     return -1;

  00326	83 c8 ff	 or	 eax, -1
  00329	eb d8		 jmp	 SHORT $LN43@bytearray_@10
$LN21@bytearray_@10:

; 775  :     }
; 776  :     else if (count < 0) {

  0032b	48 85 c0	 test	 rax, rax
  0032e	79 21		 jns	 SHORT $LN44@bytearray_@10
$LN41@bytearray_@10:

; 777  :         PyErr_SetString(PyExc_ValueError, "negative count");

  00330	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00337	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@DIJHAIGC@negative?5count?$AA@
  0033e	e8 00 00 00 00	 call	 PyErr_SetString

; 778  :         return -1;

  00343	83 c8 ff	 or	 eax, -1

; 852  : }

  00346	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  0034d	5f		 pop	 rdi
  0034e	5e		 pop	 rsi
  0034f	5b		 pop	 rbx
  00350	c3		 ret	 0
$LN44@bytearray_@10:

; 779  :     }
; 780  :     else {
; 781  :         if (count > 0) {

  00351	7e 24		 jle	 SHORT $LN16@bytearray_@10

; 782  :             if (PyByteArray_Resize((PyObject *)self, count))

  00353	48 8b d0	 mov	 rdx, rax
  00356	48 8b cf	 mov	 rcx, rdi
  00359	e8 00 00 00 00	 call	 PyByteArray_Resize
  0035e	85 c0		 test	 eax, eax

; 783  :                 return -1;

  00360	0f 85 43 fd ff
	ff		 jne	 $LN45@bytearray_@10

; 784  :             memset(self->ob_bytes, 0, count);

  00366	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  0036d	4c 8b c3	 mov	 r8, rbx
  00370	33 d2		 xor	 edx, edx
  00372	e8 00 00 00 00	 call	 memset
$LN16@bytearray_@10:

; 785  :         }
; 786  :         return 0;

  00377	33 c0		 xor	 eax, eax

; 852  : }

  00379	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00380	5f		 pop	 rdi
  00381	5e		 pop	 rsi
  00382	5b		 pop	 rbx
  00383	c3		 ret	 0
$LN22@bytearray_@10:

; 764  :         PyErr_SetString(PyExc_TypeError,
; 765  :                         "encoding or errors without a string argument");

  00384	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0038b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@GAIODIPO@encoding?5or?5errors?5without?5a?5str@
  00392	e8 00 00 00 00	 call	 PyErr_SetString

; 766  :         return -1;

  00397	83 c8 ff	 or	 eax, -1

; 852  : }

  0039a	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  003a1	5f		 pop	 rdi
  003a2	5e		 pop	 rsi
  003a3	5b		 pop	 rbx
  003a4	c3		 ret	 0
bytearray_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@NONGCEAD@bytearray?$CIb?$AA@		; `string'
PUBLIC	??_C@_0CL@FAAGOMMC@bytearray?5object?5is?5too?5large?5to@ ; `string'
PUBLIC	??_C@_01PKGAHCOL@?$CJ?$AA@			; `string'
EXTRN	PyUnicode_DecodeASCII:PROC
EXTRN	Py_hexdigits:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_repr DD imagerel bytearray_repr
	DD	imagerel bytearray_repr+514
	DD	imagerel $unwind$bytearray_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_repr DD 085e01H
	DD	06545eH
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0M@NONGCEAD@bytearray?$CIb?$AA@
CONST	SEGMENT
??_C@_0M@NONGCEAD@bytearray?$CIb?$AA@ DB 'bytearray(b', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FAAGOMMC@bytearray?5object?5is?5too?5large?5to@
CONST	SEGMENT
??_C@_0CL@FAAGOMMC@bytearray?5object?5is?5too?5large?5to@ DB 'bytearray o'
	DB	'bject is too large to make repr', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ?$AA@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ?$AA@ DB ')', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_repr
_TEXT	SEGMENT
self$ = 48
bytearray_repr PROC					; COMDAT

; 858  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 859  :     const char *quote_prefix = "bytearray(b";
; 860  :     const char *quote_postfix = ")";
; 861  :     Py_ssize_t length = Py_SIZE(self);

  0000f	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]

; 862  :     /* 15 == strlen(quote_prefix) + 2 + strlen(quote_postfix) + 1 */
; 863  :     size_t newsize;
; 864  :     PyObject *v;
; 865  :     register Py_ssize_t i;
; 866  :     register char c;
; 867  :     register char *p;
; 868  :     int quote;
; 869  :     char *test, *start;
; 870  :     char *buffer;
; 871  : 
; 872  :     if (length > (PY_SSIZE_T_MAX - 15) / 4) {

  00013	48 b8 fc ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693948 ; 1ffffffffffffffcH
  0001d	48 8b f1	 mov	 rsi, rcx
  00020	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ?$AA@
  00027	48 3b f8	 cmp	 rdi, rax
  0002a	7e 25		 jle	 SHORT $LN29@bytearray_@11

; 873  :         PyErr_SetString(PyExc_OverflowError,
; 874  :             "bytearray object is too large to make repr");

  0002c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@FAAGOMMC@bytearray?5object?5is?5too?5large?5to@
  0003a	e8 00 00 00 00	 call	 PyErr_SetString

; 875  :         return NULL;

  0003f	33 c0		 xor	 eax, eax

; 935  : }

  00041	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00046	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
$LN29@bytearray_@11:

; 876  :     }
; 877  : 
; 878  :     newsize = 15 + length * 4;

  00051	48 8d 0c bd 0f
	00 00 00	 lea	 rcx, QWORD PTR [rdi*4+15]
  00059	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp

; 879  :     buffer = PyObject_Malloc(newsize);

  0005e	e8 00 00 00 00	 call	 PyObject_Malloc
  00063	48 8b e8	 mov	 rbp, rax

; 880  :     if (buffer == NULL) {

  00066	48 85 c0	 test	 rax, rax
  00069	75 0c		 jne	 SHORT $LN28@bytearray_@11

; 881  :         PyErr_NoMemory();

  0006b	e8 00 00 00 00	 call	 PyErr_NoMemory

; 882  :         return NULL;

  00070	33 c0		 xor	 eax, eax
  00072	e9 76 01 00 00	 jmp	 $LN43@bytearray_@11
$LN28@bytearray_@11:

; 883  :     }
; 884  : 
; 885  :     /* Figure out which quote to use; single is preferred */
; 886  :     quote = '\'';
; 887  :     start = PyByteArray_AS_STRING(self);

  00077	48 83 7e 60 00	 cmp	 QWORD PTR [rsi+96], 0
  0007c	41 ba 27 00 00
	00		 mov	 r10d, 39		; 00000027H
  00082	74 09		 je	 SHORT $LN32@bytearray_@11
  00084	48 8b 86 80 00
	00 00		 mov	 rax, QWORD PTR [rsi+128]
  0008b	eb 07		 jmp	 SHORT $LN33@bytearray_@11
$LN32@bytearray_@11:
  0008d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
$LN33@bytearray_@11:

; 888  :     for (test = start; test < start+length; ++test) {

  00094	48 8d 14 38	 lea	 rdx, QWORD PTR [rax+rdi]
  00098	48 3b c2	 cmp	 rax, rdx
  0009b	73 25		 jae	 SHORT $LN25@bytearray_@11
  0009d	41 b8 22 00 00
	00		 mov	 r8d, 34			; 00000022H
$LL27@bytearray_@11:

; 889  :         if (*test == '"') {

  000a3	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000a6	41 3a c8	 cmp	 cl, r8b
  000a9	74 11		 je	 SHORT $LN38@bytearray_@11

; 891  :             break;
; 892  :         }
; 893  :         else if (*test == '\'')

  000ab	80 f9 27	 cmp	 cl, 39			; 00000027H
  000ae	45 0f 44 d0	 cmove	 r10d, r8d
  000b2	48 ff c0	 inc	 rax
  000b5	48 3b c2	 cmp	 rax, rdx
  000b8	72 e9		 jb	 SHORT $LL27@bytearray_@11

; 889  :         if (*test == '"') {

  000ba	eb 06		 jmp	 SHORT $LN25@bytearray_@11
$LN38@bytearray_@11:

; 890  :             quote = '\''; /* back to single */

  000bc	41 ba 27 00 00
	00		 mov	 r10d, 39		; 00000027H
$LN25@bytearray_@11:

; 894  :             quote = '"';
; 895  :     }
; 896  : 
; 897  :     p = buffer;
; 898  :     while (*quote_prefix)

  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@NONGCEAD@bytearray?$CIb?$AA@
  000c9	48 8b d5	 mov	 rdx, rbp
  000cc	b0 62		 mov	 al, 98			; 00000062H
  000ce	48 2b cd	 sub	 rcx, rbp
$LL21@bytearray_@11:

; 899  :         *p++ = *quote_prefix++;

  000d1	88 02		 mov	 BYTE PTR [rdx], al
  000d3	0f b6 44 11 01	 movzx	 eax, BYTE PTR [rcx+rdx+1]
  000d8	48 ff c2	 inc	 rdx
  000db	84 c0		 test	 al, al
  000dd	75 f2		 jne	 SHORT $LL21@bytearray_@11

; 900  :     *p++ = quote;

  000df	44 88 12	 mov	 BYTE PTR [rdx], r10b
  000e2	48 ff c2	 inc	 rdx

; 901  : 
; 902  :     for (i = 0; i < length; i++) {

  000e5	45 33 c9	 xor	 r9d, r9d
  000e8	48 85 ff	 test	 rdi, rdi
  000eb	0f 8e c9 00 00
	00		 jle	 $LN17@bytearray_@11
  000f1	66 66 66 66 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL19@bytearray_@11:

; 903  :         /* There's at least enough room for a hex escape
; 904  :            and a closing quote. */
; 905  :         assert(newsize - (p - buffer) >= 5);
; 906  :         c = self->ob_bytes[i];

  00100	48 8b 86 80 00
	00 00		 mov	 rax, QWORD PTR [rsi+128]
  00107	45 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+rax]

; 907  :         if (c == '\'' || c == '\\')

  0010c	41 80 f8 27	 cmp	 r8b, 39			; 00000027H
  00110	0f 84 8d 00 00
	00		 je	 $LN15@bytearray_@11
  00116	41 80 f8 5c	 cmp	 r8b, 92			; 0000005cH
  0011a	0f 84 83 00 00
	00		 je	 $LN15@bytearray_@11

; 909  :         else if (c == '\t')

  00120	41 80 f8 09	 cmp	 r8b, 9
  00124	75 07		 jne	 SHORT $LN13@bytearray_@11

; 910  :             *p++ = '\\', *p++ = 't';

  00126	66 c7 02 5c 74	 mov	 WORD PTR [rdx], 29788	; 0000745cH
  0012b	eb 7d		 jmp	 SHORT $LN44@bytearray_@11
$LN13@bytearray_@11:

; 911  :         else if (c == '\n')

  0012d	41 80 f8 0a	 cmp	 r8b, 10
  00131	75 07		 jne	 SHORT $LN11@bytearray_@11

; 912  :             *p++ = '\\', *p++ = 'n';

  00133	66 c7 02 5c 6e	 mov	 WORD PTR [rdx], 28252	; 00006e5cH
  00138	eb 70		 jmp	 SHORT $LN44@bytearray_@11
$LN11@bytearray_@11:

; 913  :         else if (c == '\r')

  0013a	41 80 f8 0d	 cmp	 r8b, 13
  0013e	75 07		 jne	 SHORT $LN9@bytearray_@11

; 914  :             *p++ = '\\', *p++ = 'r';

  00140	66 c7 02 5c 72	 mov	 WORD PTR [rdx], 29276	; 0000725cH
  00145	eb 63		 jmp	 SHORT $LN44@bytearray_@11
$LN9@bytearray_@11:

; 915  :         else if (c == 0)

  00147	45 84 c0	 test	 r8b, r8b
  0014a	75 11		 jne	 SHORT $LN7@bytearray_@11

; 916  :             *p++ = '\\', *p++ = 'x', *p++ = '0', *p++ = '0';

  0014c	66 c7 02 5c 78	 mov	 WORD PTR [rdx], 30812	; 0000785cH
  00151	66 c7 42 02 30
	30		 mov	 WORD PTR [rdx+2], 12336	; 00003030H
  00157	48 83 c2 04	 add	 rdx, 4
  0015b	eb 51		 jmp	 SHORT $LN18@bytearray_@11
$LN7@bytearray_@11:

; 917  :         else if (c < ' ' || c >= 0x7f) {

  0015d	41 8d 40 e0	 lea	 eax, DWORD PTR [r8-32]
  00161	3c 5e		 cmp	 al, 94			; 0000005eH
  00163	77 08		 ja	 SHORT $LN4@bytearray_@11

; 924  :             *p++ = c;

  00165	44 88 02	 mov	 BYTE PTR [rdx], r8b
  00168	48 ff c2	 inc	 rdx
  0016b	eb 41		 jmp	 SHORT $LN18@bytearray_@11
$LN4@bytearray_@11:

; 918  :             *p++ = '\\';

  0016d	66 c7 02 5c 78	 mov	 WORD PTR [rdx], 30812	; 0000785cH

; 919  :             *p++ = 'x';
; 920  :             *p++ = Py_hexdigits[(c & 0xf0) >> 4];

  00172	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00179	41 0f b6 c8	 movzx	 ecx, r8b
  0017d	48 c1 e9 04	 shr	 rcx, 4
  00181	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00185	88 4a 02	 mov	 BYTE PTR [rdx+2], cl

; 921  :             *p++ = Py_hexdigits[c & 0xf];

  00188	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  0018f	49 0f be c8	 movsx	 rcx, r8b
  00193	83 e1 0f	 and	 ecx, 15
  00196	48 83 c2 04	 add	 rdx, 4
  0019a	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0019e	88 4a ff	 mov	 BYTE PTR [rdx-1], cl

; 922  :         }
; 923  :         else

  001a1	eb 0b		 jmp	 SHORT $LN18@bytearray_@11
$LN15@bytearray_@11:

; 908  :             *p++ = '\\', *p++ = c;

  001a3	c6 02 5c	 mov	 BYTE PTR [rdx], 92	; 0000005cH
  001a6	44 88 42 01	 mov	 BYTE PTR [rdx+1], r8b
$LN44@bytearray_@11:
  001aa	48 83 c2 02	 add	 rdx, 2
$LN18@bytearray_@11:

; 901  : 
; 902  :     for (i = 0; i < length; i++) {

  001ae	49 ff c1	 inc	 r9
  001b1	4c 3b cf	 cmp	 r9, rdi
  001b4	0f 8c 46 ff ff
	ff		 jl	 $LL19@bytearray_@11
$LN17@bytearray_@11:

; 925  :     }
; 926  :     assert(newsize - (p - buffer) >= 1);
; 927  :     *p++ = quote;

  001ba	44 88 12	 mov	 BYTE PTR [rdx], r10b
  001bd	48 ff c2	 inc	 rdx
  001c0	b0 29		 mov	 al, 41			; 00000029H
$LL2@bytearray_@11:

; 928  :     while (*quote_postfix) {
; 929  :        *p++ = *quote_postfix++;

  001c2	48 ff c3	 inc	 rbx
  001c5	88 02		 mov	 BYTE PTR [rdx], al
  001c7	48 ff c2	 inc	 rdx
  001ca	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  001cd	84 c0		 test	 al, al
  001cf	75 f1		 jne	 SHORT $LL2@bytearray_@11

; 930  :     }
; 931  : 
; 932  :     v = PyUnicode_DecodeASCII(buffer, p - buffer, NULL);

  001d1	48 2b d5	 sub	 rdx, rbp
  001d4	45 33 c0	 xor	 r8d, r8d
  001d7	48 8b cd	 mov	 rcx, rbp
  001da	e8 00 00 00 00	 call	 PyUnicode_DecodeASCII

; 933  :     PyObject_Free(buffer);

  001df	48 8b cd	 mov	 rcx, rbp
  001e2	48 8b d8	 mov	 rbx, rax
  001e5	e8 00 00 00 00	 call	 PyObject_Free

; 934  :     return v;

  001ea	48 8b c3	 mov	 rax, rbx
$LN43@bytearray_@11:

; 935  : }

  001ed	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  001f2	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  001f7	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  001fc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00200	5f		 pop	 rdi
  00201	c3		 ret	 0
bytearray_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@DAKHFBFN@str?$CI?$CJ?5on?5a?5bytearray?5instance?$AA@ ; `string'
EXTRN	PyErr_WarnEx:PROC
EXTRN	PyExc_BytesWarning:QWORD
EXTRN	Py_BytesWarningFlag:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_str DD imagerel bytearray_str
	DD	imagerel bytearray_str+68
	DD	imagerel $unwind$bytearray_str
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_str DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BO@DAKHFBFN@str?$CI?$CJ?5on?5a?5bytearray?5instance?$AA@
CONST	SEGMENT
??_C@_0BO@DAKHFBFN@str?$CI?$CJ?5on?5a?5bytearray?5instance?$AA@ DB 'str()'
	DB	' on a bytearray instance', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_str
_TEXT	SEGMENT
op$ = 48
bytearray_str PROC					; COMDAT

; 939  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 940  :         if (Py_BytesWarningFlag) {

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_BytesWarningFlag, 0
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	74 25		 je	 SHORT $LN1@bytearray_@12

; 941  :                 if (PyErr_WarnEx(PyExc_BytesWarning,
; 942  :                                  "str() on a bytearray instance", 1))

  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BytesWarning
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@DAKHFBFN@str?$CI?$CJ?5on?5a?5bytearray?5instance?$AA@
  00020	41 b8 01 00 00
	00		 mov	 r8d, 1
  00026	e8 00 00 00 00	 call	 PyErr_WarnEx
  0002b	85 c0		 test	 eax, eax
  0002d	74 08		 je	 SHORT $LN1@bytearray_@12

; 943  :                         return NULL;

  0002f	33 c0		 xor	 eax, eax

; 946  : }

  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5b		 pop	 rbx
  00036	c3		 ret	 0
$LN1@bytearray_@12:

; 944  :         }
; 945  :         return bytearray_repr((PyByteArrayObject*)op);

  00037	48 8b cb	 mov	 rcx, rbx

; 946  : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	e9 00 00 00 00	 jmp	 bytearray_repr
bytearray_str ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@GNKEBMCE@Comparison?5between?5bytearray?5and@ ; `string'
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	_Py_NotImplementedStruct:BYTE
EXTRN	PyObject_IsInstance:PROC
EXTRN	PyUnicode_Type:BYTE
EXTRN	memcmp:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytearray_richcompare DD imagerel bytearray_richcompare
	DD	imagerel bytearray_richcompare+560
	DD	imagerel $unwind$bytearray_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_richcompare DD 071201H
	DD	01d6412H
	DD	01c3412H
	DD	01a0112H
	DD	0700bH
xdata	ENDS
;	COMDAT ??_C@_0CI@GNKEBMCE@Comparison?5between?5bytearray?5and@
CONST	SEGMENT
??_C@_0CI@GNKEBMCE@Comparison?5between?5bytearray?5and@ DB 'Comparison be'
	DB	'tween bytearray and string', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
CONST	ENDS
;	COMDAT bytearray_richcompare
_TEXT	SEGMENT
self_bytes$ = 48
other_bytes$ = 128
self$ = 224
other$ = 232
op$ = 240
bytearray_richcompare PROC				; COMDAT

; 950  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00012	48 8b fa	 mov	 rdi, rdx

; 951  :     Py_ssize_t self_size, other_size;
; 952  :     Py_buffer self_bytes, other_bytes;
; 953  :     PyObject *res;
; 954  :     Py_ssize_t minsize;
; 955  :     int cmp;
; 956  : 
; 957  :     /* Bytes can be compared to anything that supports the (binary)
; 958  :        buffer API.  Except that a comparison with Unicode is always an
; 959  :        error, even if the comparison is for equality. */
; 960  :     if (PyObject_IsInstance(self, (PyObject*)&PyUnicode_Type) ||
; 961  :         PyObject_IsInstance(other, (PyObject*)&PyUnicode_Type)) {

  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyUnicode_Type
  0001c	49 63 d8	 movsxd	 rbx, r8d
  0001f	48 8b f1	 mov	 rsi, rcx
  00022	e8 00 00 00 00	 call	 PyObject_IsInstance
  00027	85 c0		 test	 eax, eax
  00029	0f 85 a6 01 00
	00		 jne	 $LN22@bytearray_@13
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyUnicode_Type
  00036	48 8b cf	 mov	 rcx, rdi
  00039	e8 00 00 00 00	 call	 PyObject_IsInstance
  0003e	85 c0		 test	 eax, eax
  00040	0f 85 8f 01 00
	00		 jne	 $LN22@bytearray_@13

; 969  :     }
; 970  : 
; 971  :     self_size = _getbuffer(self, &self_bytes);

  00046	48 8d 54 24 30	 lea	 rdx, QWORD PTR self_bytes$[rsp]
  0004b	48 8b ce	 mov	 rcx, rsi
  0004e	e8 00 00 00 00	 call	 _getbuffer
  00053	48 8b f0	 mov	 rsi, rax

; 972  :     if (self_size < 0) {

  00056	48 85 c0	 test	 rax, rax
  00059	79 66		 jns	 SHORT $LN18@bytearray_@13

; 973  :         PyErr_Clear();

  0005b	e8 00 00 00 00	 call	 PyErr_Clear
$LN19@bytearray_@13:

; 966  :         }
; 967  : 
; 968  :         Py_RETURN_NOTIMPLEMENTED;

  00060	e8 00 00 00 00	 call	 _Py_PXCTX
  00065	85 c0		 test	 eax, eax
  00067	75 3c		 jne	 SHORT $LN27@bytearray_@13
  00069	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0007e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00084	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00091	85 c0		 test	 eax, eax
  00093	75 09		 jne	 SHORT $LN26@bytearray_@13
  00095	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0009c	74 07		 je	 SHORT $LN27@bytearray_@13
$LN26@bytearray_@13:
  0009e	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN27@bytearray_@13:
  000a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
$LN24@bytearray_@13:

; 1018 : }

  000ac	4c 8d 9c 24 d0
	00 00 00	 lea	 r11, QWORD PTR [rsp+208]
  000b4	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000b8	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  000bc	49 8b e3	 mov	 rsp, r11
  000bf	5f		 pop	 rdi
  000c0	c3		 ret	 0
$LN18@bytearray_@13:

; 974  :         Py_RETURN_NOTIMPLEMENTED;
; 975  :     }
; 976  : 
; 977  :     other_size = _getbuffer(other, &other_bytes);

  000c1	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR other_bytes$[rsp]
  000c9	48 8b cf	 mov	 rcx, rdi
  000cc	e8 00 00 00 00	 call	 _getbuffer
  000d1	48 8b f8	 mov	 rdi, rax

; 978  :     if (other_size < 0) {

  000d4	48 85 c0	 test	 rax, rax
  000d7	79 1d		 jns	 SHORT $LN17@bytearray_@13

; 979  :         PyErr_Clear();

  000d9	e8 00 00 00 00	 call	 PyErr_Clear

; 980  :         PyBuffer_Release(&self_bytes);

  000de	48 8d 4c 24 30	 lea	 rcx, QWORD PTR self_bytes$[rsp]
  000e3	e8 00 00 00 00	 call	 PyBuffer_Release

; 981  :         Py_RETURN_NOTIMPLEMENTED;

  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  000ef	e8 00 00 00 00	 call	 _Py_IncRef
  000f4	eb af		 jmp	 SHORT $LN27@bytearray_@13
$LN17@bytearray_@13:

; 982  :     }
; 983  : 
; 984  :     if (self_size != other_size && (op == Py_EQ || op == Py_NE)) {

  000f6	48 3b f0	 cmp	 rsi, rax
  000f9	74 17		 je	 SHORT $LN16@bytearray_@13
  000fb	83 fb 02	 cmp	 ebx, 2
  000fe	74 05		 je	 SHORT $LN15@bytearray_@13
  00100	83 fb 03	 cmp	 ebx, 3
  00103	75 0d		 jne	 SHORT $LN16@bytearray_@13
$LN15@bytearray_@13:

; 985  :         /* Shortcut: if the lengths differ, the objects differ */
; 986  :         cmp = (op == Py_NE);

  00105	33 c0		 xor	 eax, eax
  00107	83 fb 03	 cmp	 ebx, 3
  0010a	0f 94 c0	 sete	 al

; 987  :     }
; 988  :     else {

  0010d	e9 86 00 00 00	 jmp	 $LN38@bytearray_@13
$LN16@bytearray_@13:

; 989  :         minsize = self_size;
; 990  :         if (other_size < minsize)
; 991  :             minsize = other_size;
; 992  : 
; 993  :         cmp = memcmp(self_bytes.buf, other_bytes.buf, minsize);

  00112	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR other_bytes$[rsp]
  0011a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self_bytes$[rsp]
  0011f	48 3b c6	 cmp	 rax, rsi
  00122	4c 8b c6	 mov	 r8, rsi
  00125	4c 0f 4c c0	 cmovl	 r8, rax
  00129	e8 00 00 00 00	 call	 memcmp
  0012e	8b d0		 mov	 edx, eax

; 994  :         /* In ISO C, memcmp() guarantees to use unsigned bytes! */
; 995  : 
; 996  :         if (cmp == 0) {

  00130	85 c0		 test	 eax, eax
  00132	75 17		 jne	 SHORT $LN9@bytearray_@13

; 997  :             if (self_size < other_size)

  00134	48 3b f7	 cmp	 rsi, rdi
  00137	7d 05		 jge	 SHORT $LN11@bytearray_@13

; 998  :                 cmp = -1;

  00139	83 ca ff	 or	 edx, -1
  0013c	eb 0d		 jmp	 SHORT $LN9@bytearray_@13
$LN11@bytearray_@13:

; 999  :             else if (self_size > other_size)

  0013e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00144	48 3b f7	 cmp	 rsi, rdi
  00147	41 0f 4f d0	 cmovg	 edx, r8d
$LN9@bytearray_@13:

; 1000 :                 cmp = 1;
; 1001 :         }
; 1002 : 
; 1003 :         switch (op) {

  0014b	83 fb 05	 cmp	 ebx, 5
  0014e	77 4a		 ja	 SHORT $LN7@bytearray_@13
  00150	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00157	41 8b 8c 98 00
	00 00 00	 mov	 ecx, DWORD PTR $LN34@bytearray_@13[r8+rbx*4]
  0015f	49 03 c8	 add	 rcx, r8
  00162	ff e1		 jmp	 rcx
$LN6@bytearray_@13:

; 1004 :         case Py_LT: cmp = cmp <  0; break;

  00164	33 c0		 xor	 eax, eax
  00166	85 d2		 test	 edx, edx
  00168	0f 98 c0	 sets	 al
  0016b	eb 2b		 jmp	 SHORT $LN38@bytearray_@13
$LN5@bytearray_@13:

; 1005 :         case Py_LE: cmp = cmp <= 0; break;

  0016d	33 c0		 xor	 eax, eax
  0016f	85 d2		 test	 edx, edx
  00171	0f 9e c0	 setle	 al
  00174	eb 22		 jmp	 SHORT $LN38@bytearray_@13
$LN4@bytearray_@13:

; 1006 :         case Py_EQ: cmp = cmp == 0; break;

  00176	33 c0		 xor	 eax, eax
  00178	85 d2		 test	 edx, edx
  0017a	0f 94 c0	 sete	 al
  0017d	eb 19		 jmp	 SHORT $LN38@bytearray_@13
$LN3@bytearray_@13:

; 1007 :         case Py_NE: cmp = cmp != 0; break;

  0017f	33 c0		 xor	 eax, eax
  00181	85 d2		 test	 edx, edx
  00183	0f 95 c0	 setne	 al
  00186	eb 10		 jmp	 SHORT $LN38@bytearray_@13
$LN2@bytearray_@13:

; 1008 :         case Py_GT: cmp = cmp >  0; break;

  00188	33 c0		 xor	 eax, eax
  0018a	85 d2		 test	 edx, edx
  0018c	0f 9f c0	 setg	 al
  0018f	eb 07		 jmp	 SHORT $LN38@bytearray_@13
$LN1@bytearray_@13:

; 1009 :         case Py_GE: cmp = cmp >= 0; break;

  00191	33 c0		 xor	 eax, eax
  00193	85 d2		 test	 edx, edx
  00195	0f 99 c0	 setns	 al
$LN38@bytearray_@13:
  00198	8b d0		 mov	 edx, eax
$LN7@bytearray_@13:

; 1010 :         }
; 1011 :     }
; 1012 : 
; 1013 :     res = cmp ? Py_True : Py_False;

  0019a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  001a1	85 d2		 test	 edx, edx
  001a3	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct

; 1014 :     PyBuffer_Release(&self_bytes);

  001aa	48 8d 4c 24 30	 lea	 rcx, QWORD PTR self_bytes$[rsp]
  001af	48 0f 45 d8	 cmovne	 rbx, rax
  001b3	e8 00 00 00 00	 call	 PyBuffer_Release

; 1015 :     PyBuffer_Release(&other_bytes);

  001b8	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR other_bytes$[rsp]
  001c0	e8 00 00 00 00	 call	 PyBuffer_Release

; 1016 :     Py_INCREF(res);

  001c5	48 8b cb	 mov	 rcx, rbx
  001c8	e8 00 00 00 00	 call	 _Py_IncRef

; 1017 :     return res;

  001cd	48 8b c3	 mov	 rax, rbx
  001d0	e9 d7 fe ff ff	 jmp	 $LN24@bytearray_@13
$LN22@bytearray_@13:

; 962  :         if (Py_BytesWarningFlag && (op == Py_EQ || op == Py_NE)) {

  001d5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_BytesWarningFlag, 0
  001dc	0f 84 7e fe ff
	ff		 je	 $LN19@bytearray_@13
  001e2	83 fb 02	 cmp	 ebx, 2
  001e5	74 09		 je	 SHORT $LN20@bytearray_@13
  001e7	83 fb 03	 cmp	 ebx, 3
  001ea	0f 85 70 fe ff
	ff		 jne	 $LN19@bytearray_@13
$LN20@bytearray_@13:

; 963  :             if (PyErr_WarnEx(PyExc_BytesWarning,
; 964  :                             "Comparison between bytearray and string", 1))

  001f0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BytesWarning
  001f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@GNKEBMCE@Comparison?5between?5bytearray?5and@
  001fe	41 b8 01 00 00
	00		 mov	 r8d, 1
  00204	e8 00 00 00 00	 call	 PyErr_WarnEx
  00209	85 c0		 test	 eax, eax
  0020b	0f 84 4f fe ff
	ff		 je	 $LN19@bytearray_@13

; 965  :                 return NULL;

  00211	33 c0		 xor	 eax, eax
  00213	e9 94 fe ff ff	 jmp	 $LN24@bytearray_@13
$LN34@bytearray_@13:

; 1018 : }

  00218	00 00 00 00	 DD	 $LN6@bytearray_@13
  0021c	00 00 00 00	 DD	 $LN5@bytearray_@13
  00220	00 00 00 00	 DD	 $LN4@bytearray_@13
  00224	00 00 00 00	 DD	 $LN3@bytearray_@13
  00228	00 00 00 00	 DD	 $LN2@bytearray_@13
  0022c	00 00 00 00	 DD	 $LN1@bytearray_@13
bytearray_richcompare ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@LNAAPJIN@deallocated?5bytearray?5object?5has@ ; `string'
EXTRN	PyErr_Print:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_dealloc DD imagerel bytearray_dealloc
	DD	imagerel bytearray_dealloc+75
	DD	imagerel $unwind$bytearray_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_dealloc DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0DC@LNAAPJIN@deallocated?5bytearray?5object?5has@
CONST	SEGMENT
??_C@_0DC@LNAAPJIN@deallocated?5bytearray?5object?5has@ DB 'deallocated b'
	DB	'ytearray object has exported buffers', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_dealloc
_TEXT	SEGMENT
self$ = 48
bytearray_dealloc PROC					; COMDAT

; 1022 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1023 :     if (self->ob_exports > 0) {

  00006	83 79 70 00	 cmp	 DWORD PTR [rcx+112], 0
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	7e 18		 jle	 SHORT $LN2@bytearray_@14

; 1024 :         PyErr_SetString(PyExc_SystemError,
; 1025 :                         "deallocated bytearray object has exported buffers");

  0000f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LNAAPJIN@deallocated?5bytearray?5object?5has@
  0001d	e8 00 00 00 00	 call	 PyErr_SetString

; 1026 :         PyErr_Print();

  00022	e8 00 00 00 00	 call	 PyErr_Print
$LN2@bytearray_@14:

; 1027 :     }
; 1028 :     if (self->ob_bytes != 0) {

  00027	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  0002e	48 85 c9	 test	 rcx, rcx
  00031	74 05		 je	 SHORT $LN1@bytearray_@14

; 1029 :         PyObject_Free(self->ob_bytes);

  00033	e8 00 00 00 00	 call	 PyObject_Free
$LN1@bytearray_@14:

; 1030 :     }
; 1031 :     Py_TYPE(self)->tp_free((PyObject *)self);

  00038	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0003c	48 8b cb	 mov	 rcx, rbx

; 1032 : }

  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5b		 pop	 rbx
  00044	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
bytearray_dealloc ENDP
_TEXT	ENDS
EXTRN	__imp_memchr:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$stringlib_fastsearch_memchr_1char DD imagerel stringlib_fastsearch_memchr_1char
	DD	imagerel stringlib_fastsearch_memchr_1char+72
	DD	imagerel $unwind$stringlib_fastsearch_memchr_1char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_fastsearch_memchr_1char DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT stringlib_fastsearch_memchr_1char
_TEXT	SEGMENT
s$ = 48
n$ = 56
needle$ = 64
mode$ = 72
stringlib_fastsearch_memchr_1char PROC			; COMDAT

; 40   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	41 0f b6 c0	 movzx	 eax, r8b
  0000a	48 8b d9	 mov	 rbx, rcx

; 41   :     if (mode == FAST_SEARCH) {

  0000d	41 83 f9 01	 cmp	 r9d, 1
  00011	75 2d		 jne	 SHORT $LN6@stringlib_

; 42   :         const STRINGLIB_CHAR *ptr = s;
; 43   :         const STRINGLIB_CHAR *e = s + n;

  00013	4c 8d 04 11	 lea	 r8, QWORD PTR [rcx+rdx]

; 44   :         while (ptr < e) {

  00017	49 3b c8	 cmp	 rcx, r8
  0001a	73 11		 jae	 SHORT $LN4@stringlib_

; 45   :             void *candidate = memchr((const void *) ptr, needle, (e - ptr) * sizeof(STRINGLIB_CHAR));

  0001c	4c 2b c1	 sub	 r8, rcx
  0001f	0f b6 d0	 movzx	 edx, al
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr

; 46   :             if (candidate == NULL)

  00028	48 85 c0	 test	 rax, rax
  0002b	75 0a		 jne	 SHORT $LN3@stringlib_
$LN4@stringlib_:

; 47   :                 return -1;

  0002d	48 83 c8 ff	 or	 rax, -1

; 78   :     }
; 79   : 
; 80   : #undef DO_MEMCHR
; 81   : }

  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5b		 pop	 rbx
  00036	c3		 ret	 0
$LN3@stringlib_:

; 48   :             ptr = (const STRINGLIB_CHAR *) _Py_ALIGN_DOWN(candidate, sizeof(STRINGLIB_CHAR));
; 49   :             if (sizeof(STRINGLIB_CHAR) == 1 || *ptr == ch)
; 50   :                 return (ptr - s);

  00037	48 2b c3	 sub	 rax, rbx

; 78   :     }
; 79   : 
; 80   : #undef DO_MEMCHR
; 81   : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	c3		 ret	 0
$LN6@stringlib_:

; 51   :             /* False positive */
; 52   :             ptr++;
; 53   :         }
; 54   :         return -1;
; 55   :     }
; 56   : #ifdef HAVE_MEMRCHR
; 57   :     /* memrchr() is a GNU extension, available since glibc 2.1.91.
; 58   :        it doesn't seem as optimized as memchr(), but is still quite
; 59   :        faster than our hand-written loop in FASTSEARCH below */
; 60   :     else if (mode == FAST_RSEARCH) {
; 61   :         while (n > 0) {
; 62   :             const STRINGLIB_CHAR *found;
; 63   :             void *candidate = memrchr((const void *) s, needle, n * sizeof(STRINGLIB_CHAR));
; 64   :             if (candidate == NULL)
; 65   :                 return -1;
; 66   :             found = (const STRINGLIB_CHAR *) _Py_ALIGN_DOWN(candidate, sizeof(STRINGLIB_CHAR));
; 67   :             n = found - s;
; 68   :             if (sizeof(STRINGLIB_CHAR) == 1 || *found == ch)
; 69   :                 return n;
; 70   :             /* False positive */
; 71   :         }
; 72   :         return -1;
; 73   :     }
; 74   : #endif
; 75   :     else {
; 76   :         assert(0); /* Should never get here */
; 77   :         return 0;

  00040	33 c0		 xor	 eax, eax

; 78   :     }
; 79   : 
; 80   : #undef DO_MEMCHR
; 81   : }

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5b		 pop	 rbx
  00047	c3		 ret	 0
stringlib_fastsearch_memchr_1char ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fastsearch DD imagerel fastsearch
	DD	imagerel fastsearch+346
	DD	imagerel $unwind$fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$fastsearch DD imagerel fastsearch+346
	DD	imagerel fastsearch+977
	DD	imagerel $chain$2$fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$fastsearch DD imagerel fastsearch+977
	DD	imagerel fastsearch+991
	DD	imagerel $chain$3$fastsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$fastsearch DD imagerel fastsearch+991
	DD	imagerel fastsearch+996
	DD	imagerel $chain$4$fastsearch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$fastsearch DD 060021H
	DD	067400H
	DD	076400H
	DD	0e5400H
	DD	imagerel fastsearch
	DD	imagerel fastsearch+346
	DD	imagerel $unwind$fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$fastsearch DD 021H
	DD	imagerel fastsearch
	DD	imagerel fastsearch+346
	DD	imagerel $unwind$fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$fastsearch DD 061321H
	DD	067413H
	DD	07640aH
	DD	0e5405H
	DD	imagerel fastsearch
	DD	imagerel fastsearch+346
	DD	imagerel $unwind$fastsearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fastsearch DD 061201H
	DD	0f00e7212H
	DD	0d00ae00cH
	DD	03006c008H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT fastsearch
_TEXT	SEGMENT
s$ = 112
mask$1$ = 120
n$ = 120
p$ = 128
skip$1$ = 136
m$ = 136
maxcount$ = 144
mode$ = 152
fastsearch PROC						; COMDAT

; 87   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	53		 push	 rbx
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	41 56		 push	 r14
  0000c	41 57		 push	 r15
  0000e	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00012	4d 8b e9	 mov	 r13, r9

; 88   :     unsigned long mask;
; 89   :     Py_ssize_t skip, count = 0;

  00015	45 33 db	 xor	 r11d, r11d

; 90   :     Py_ssize_t i, j, mlast, w;
; 91   : 
; 92   :     w = n - m;

  00018	4c 8b d2	 mov	 r10, rdx
  0001b	4d 2b d5	 sub	 r10, r13
  0001e	4d 8b f8	 mov	 r15, r8
  00021	48 8b d9	 mov	 rbx, rcx
  00024	45 8b cb	 mov	 r9d, r11d

; 93   : 
; 94   :     if (w < 0 || (mode == FAST_COUNT && maxcount == 0))

  00027	0f 88 1b 01 00
	00		 js	 $LN41@fastsearch
  0002d	44 8b b4 24 98
	00 00 00	 mov	 r14d, DWORD PTR mode$[rsp]
  00035	4c 8b a4 24 90
	00 00 00	 mov	 r12, QWORD PTR maxcount$[rsp]
  0003d	45 85 f6	 test	 r14d, r14d
  00040	75 09		 jne	 SHORT $LN61@fastsearch
  00042	4d 85 e4	 test	 r12, r12
  00045	0f 84 fd 00 00
	00		 je	 $LN41@fastsearch
$LN61@fastsearch:

; 95   :         return -1;
; 96   : 
; 97   :     /* look for special cases */
; 98   :     if (m <= 1) {

  0004b	49 83 fd 01	 cmp	 r13, 1
  0004f	0f 8f 05 01 00
	00		 jg	 $LN59@fastsearch

; 99   :         if (m <= 0)

  00055	4d 85 ed	 test	 r13, r13

; 100  :             return -1;

  00058	0f 8e ea 00 00
	00		 jle	 $LN41@fastsearch

; 101  :         /* use special case for 1-character strings */
; 102  :         if (n > 10 && (mode == FAST_SEARCH
; 103  : #ifdef HAVE_MEMRCHR
; 104  :                     || mode == FAST_RSEARCH
; 105  : #endif
; 106  :                     )) {

  0005e	48 83 fa 0a	 cmp	 rdx, 10
  00062	7e 3a		 jle	 SHORT $LN57@fastsearch
  00064	41 83 fe 01	 cmp	 r14d, 1
  00068	75 34		 jne	 SHORT $LN57@fastsearch

; 107  :             /* use memchr if we can choose a needle without two many likely
; 108  :                false positives */
; 109  :             unsigned char needle;
; 110  :             needle = p[0] & 0xff;
; 111  : #if STRINGLIB_SIZEOF_CHAR > 1
; 112  :             /* If looking for a multiple of 256, we'd have too
; 113  :                many false positives looking for the '\0' byte in UCS2
; 114  :                and UCS4 representations. */
; 115  :             if (needle != 0)
; 116  : #endif
; 117  :                 return STRINGLIB(fastsearch_memchr_1char)
; 118  :                        (s, n, p[0], needle, maxcount, mode);

  0006a	4c 8d 04 11	 lea	 r8, QWORD PTR [rcx+rdx]
  0006e	49 3b c8	 cmp	 rcx, r8
  00071	0f 83 d1 00 00
	00		 jae	 $LN41@fastsearch
  00077	41 0f b6 17	 movzx	 edx, BYTE PTR [r15]
  0007b	4c 2b c1	 sub	 r8, rcx
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00084	48 85 c0	 test	 rax, rax
  00087	0f 84 bb 00 00
	00		 je	 $LN41@fastsearch
  0008d	48 2b c3	 sub	 rax, rbx

; 223  : }

  00090	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00094	41 5f		 pop	 r15
  00096	41 5e		 pop	 r14
  00098	41 5d		 pop	 r13
  0009a	41 5c		 pop	 r12
  0009c	5b		 pop	 rbx
  0009d	c3		 ret	 0
$LN57@fastsearch:

; 119  :         }
; 120  :         if (mode == FAST_COUNT) {

  0009e	45 85 f6	 test	 r14d, r14d
  000a1	75 45		 jne	 SHORT $LN56@fastsearch

; 121  :             for (i = 0; i < n; i++)

  000a3	48 85 d2	 test	 rdx, rdx
  000a6	7e 1e		 jle	 SHORT $LN99@fastsearch
  000a8	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  000ac	0f 1f 40 00	 npad	 4
$LL55@fastsearch:

; 122  :                 if (s[i] == p[0]) {

  000b0	41 38 04 0b	 cmp	 BYTE PTR [r11+rcx], al
  000b4	75 08		 jne	 SHORT $LN54@fastsearch

; 123  :                     count++;

  000b6	49 ff c1	 inc	 r9

; 124  :                     if (count == maxcount)

  000b9	4d 3b cc	 cmp	 r9, r12
  000bc	74 19		 je	 SHORT $LN81@fastsearch
$LN54@fastsearch:

; 121  :             for (i = 0; i < n; i++)

  000be	49 ff c3	 inc	 r11
  000c1	4c 3b da	 cmp	 r11, rdx
  000c4	7c ea		 jl	 SHORT $LL55@fastsearch
$LN99@fastsearch:

; 126  :                 }
; 127  :             return count;

  000c6	49 8b c1	 mov	 rax, r9

; 223  : }

  000c9	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000cd	41 5f		 pop	 r15
  000cf	41 5e		 pop	 r14
  000d1	41 5d		 pop	 r13
  000d3	41 5c		 pop	 r12
  000d5	5b		 pop	 rbx
  000d6	c3		 ret	 0
$LN81@fastsearch:

; 125  :                         return maxcount;

  000d7	49 8b c4	 mov	 rax, r12

; 223  : }

  000da	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000de	41 5f		 pop	 r15
  000e0	41 5e		 pop	 r14
  000e2	41 5d		 pop	 r13
  000e4	41 5c		 pop	 r12
  000e6	5b		 pop	 rbx
  000e7	c3		 ret	 0
$LN56@fastsearch:

; 128  :         } else if (mode == FAST_SEARCH) {

  000e8	41 83 fe 01	 cmp	 r14d, 1
  000ec	75 3a		 jne	 SHORT $LN49@fastsearch

; 129  :             for (i = 0; i < n; i++)

  000ee	48 85 d2	 test	 rdx, rdx
  000f1	7e 55		 jle	 SHORT $LN41@fastsearch
  000f3	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
$LL48@fastsearch:

; 130  :                 if (s[i] == p[0])

  000f7	41 38 04 0b	 cmp	 BYTE PTR [r11+rcx], al
  000fb	74 1a		 je	 SHORT $LN82@fastsearch

; 129  :             for (i = 0; i < n; i++)

  000fd	49 ff c3	 inc	 r11
  00100	4c 3b da	 cmp	 r11, rdx
  00103	7c f2		 jl	 SHORT $LL48@fastsearch

; 135  :                     return i;
; 136  :         }
; 137  :         return -1;

  00105	48 83 c8 ff	 or	 rax, -1

; 223  : }

  00109	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0010d	41 5f		 pop	 r15
  0010f	41 5e		 pop	 r14
  00111	41 5d		 pop	 r13
  00113	41 5c		 pop	 r12
  00115	5b		 pop	 rbx
  00116	c3		 ret	 0
$LN82@fastsearch:

; 131  :                     return i;

  00117	49 8b c3	 mov	 rax, r11

; 223  : }

  0011a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0011e	41 5f		 pop	 r15
  00120	41 5e		 pop	 r14
  00122	41 5d		 pop	 r13
  00124	41 5c		 pop	 r12
  00126	5b		 pop	 rbx
  00127	c3		 ret	 0
$LN49@fastsearch:

; 132  :         } else {    /* FAST_RSEARCH */
; 133  :             for (i = n - 1; i > -1; i--)

  00128	48 8d 42 ff	 lea	 rax, QWORD PTR [rdx-1]
  0012c	48 83 f8 ff	 cmp	 rax, -1
  00130	7e 16		 jle	 SHORT $LN41@fastsearch
  00132	41 0f b6 08	 movzx	 ecx, BYTE PTR [r8]
$LL43@fastsearch:

; 134  :                 if (s[i] == p[0])

  00136	38 0c 18	 cmp	 BYTE PTR [rax+rbx], cl
  00139	0f 84 92 02 00
	00		 je	 $LN62@fastsearch

; 132  :         } else {    /* FAST_RSEARCH */
; 133  :             for (i = n - 1; i > -1; i--)

  0013f	48 ff c8	 dec	 rax
  00142	48 83 f8 ff	 cmp	 rax, -1
  00146	7f ee		 jg	 SHORT $LL43@fastsearch
$LN41@fastsearch:

; 135  :                     return i;
; 136  :         }
; 137  :         return -1;

  00148	48 83 c8 ff	 or	 rax, -1

; 223  : }

  0014c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00150	41 5f		 pop	 r15
  00152	41 5e		 pop	 r14
  00154	41 5d		 pop	 r13
  00156	41 5c		 pop	 r12
  00158	5b		 pop	 rbx
  00159	c3		 ret	 0
$LN59@fastsearch:
  0015a	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  0015f	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi

; 138  :     }
; 139  : 
; 140  :     mlast = m - 1;
; 141  :     skip = mlast - 1;
; 142  :     mask = 0;
; 143  : 
; 144  :     if (mode != FAST_RSEARCH) {

  00164	48 83 cd ff	 or	 rbp, -1
  00168	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0016d	49 8d 7d ff	 lea	 rdi, QWORD PTR [r13-1]
  00171	45 8b c3	 mov	 r8d, r11d
  00174	48 8d 47 ff	 lea	 rax, QWORD PTR [rdi-1]

; 145  : 
; 146  :         /* create compressed boyer-moore delta 1 table */
; 147  : 
; 148  :         /* process pattern[:-1] */
; 149  :         for (i = 0; i < mlast; i++) {

  00178	8d 75 02	 lea	 esi, QWORD PTR [rbp+2]
  0017b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR skip$1$[rsp], rax
  00183	41 83 fe 02	 cmp	 r14d, 2
  00187	0f 84 5b 01 00
	00		 je	 $LN39@fastsearch
  0018d	48 85 ff	 test	 rdi, rdi
  00190	7e 75		 jle	 SHORT $LN36@fastsearch
  00192	46 0f b6 3c 3f	 movzx	 r15d, BYTE PTR [rdi+r15]
  00197	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR p$[rsp]
  0019f	4c 8d 4f ff	 lea	 r9, QWORD PTR [rdi-1]
  001a3	4c 8b f7	 mov	 r14, rdi
  001a6	4d 8b e1	 mov	 r12, r9
  001a9	41 8b fb	 mov	 edi, r11d
  001ac	0f 1f 40 00	 npad	 4
$LL38@fastsearch:

; 150  :             STRINGLIB_BLOOM_ADD(mask, p[i]);

  001b0	44 0f be 45 00	 movsx	 r8d, BYTE PTR [rbp]
  001b5	8b d6		 mov	 edx, esi
  001b7	41 8b c8	 mov	 ecx, r8d
  001ba	83 e1 1f	 and	 ecx, 31
  001bd	d3 e2		 shl	 edx, cl
  001bf	0b fa		 or	 edi, edx

; 151  :             if (p[i] == p[mlast])

  001c1	45 3a c7	 cmp	 r8b, r15b
  001c4	4d 0f 44 cc	 cmove	 r9, r12
  001c8	48 ff c5	 inc	 rbp
  001cb	49 ff cc	 dec	 r12
  001ce	49 ff ce	 dec	 r14
  001d1	75 dd		 jne	 SHORT $LL38@fastsearch
  001d3	4c 8b a4 24 90
	00 00 00	 mov	 r12, QWORD PTR maxcount$[rsp]
  001db	44 8b b4 24 98
	00 00 00	 mov	 r14d, DWORD PTR mode$[rsp]
  001e3	4c 8b bc 24 80
	00 00 00	 mov	 r15, QWORD PTR p$[rsp]
  001eb	89 7c 24 78	 mov	 DWORD PTR mask$1$[rsp], edi
  001ef	4c 89 8c 24 88
	00 00 00	 mov	 QWORD PTR skip$1$[rsp], r9
  001f7	48 83 cd ff	 or	 rbp, -1
  001fb	44 8b 44 24 78	 mov	 r8d, DWORD PTR mask$1$[rsp]
  00200	4d 8b cb	 mov	 r9, r11
  00203	49 8d 7d ff	 lea	 rdi, QWORD PTR [r13-1]
$LN36@fastsearch:

; 152  :                 skip = mlast - i - 1;
; 153  :         }
; 154  :         /* process pattern[-1] outside the loop */
; 155  :         STRINGLIB_BLOOM_ADD(mask, p[mlast]);

  00207	42 0f be 04 3f	 movsx	 eax, BYTE PTR [rdi+r15]

; 156  : 
; 157  :         for (i = 0; i <= w; i++) {

  0020c	49 8b d3	 mov	 rdx, r11
  0020f	83 e0 1f	 and	 eax, 31
  00212	0f b6 c8	 movzx	 ecx, al
  00215	d3 e6		 shl	 esi, cl
  00217	44 0b c6	 or	 r8d, esi
  0021a	44 89 44 24 78	 mov	 DWORD PTR mask$1$[rsp], r8d
  0021f	4d 85 d2	 test	 r10, r10
  00222	0f 88 9f 00 00
	00		 js	 $LN100@fastsearch
  00228	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR p$[rsp]
  00230	4e 8d 3c 2b	 lea	 r15, QWORD PTR [rbx+r13]
$LN108@fastsearch:
  00234	42 0f b6 44 2e
	ff		 movzx	 eax, BYTE PTR [rsi+r13-1]

; 158  :             /* note: using mlast in the skip path slows things down on x86 */
; 159  :             if (s[i+m-1] == p[m-1]) {

  0023a	41 38 44 17 ff	 cmp	 BYTE PTR [r15+rdx-1], al
  0023f	75 69		 jne	 SHORT $LN31@fastsearch

; 160  :                 /* candidate match */
; 161  :                 for (j = 0; j < mlast; j++)

  00241	4d 8b c3	 mov	 r8, r11
  00244	48 85 ff	 test	 rdi, rdi
  00247	7e 28		 jle	 SHORT $LN84@fastsearch
  00249	48 8b c2	 mov	 rax, rdx
  0024c	48 8b ce	 mov	 rcx, rsi
  0024f	48 2b c6	 sub	 rax, rsi
  00252	48 8d 34 18	 lea	 rsi, QWORD PTR [rax+rbx]
$LL30@fastsearch:

; 162  :                     if (s[i+j] != p[j])

  00256	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00259	38 04 0e	 cmp	 BYTE PTR [rsi+rcx], al
  0025c	75 0b		 jne	 SHORT $LN102@fastsearch

; 160  :                 /* candidate match */
; 161  :                 for (j = 0; j < mlast; j++)

  0025e	49 ff c0	 inc	 r8
  00261	48 ff c1	 inc	 rcx
  00264	4c 3b c7	 cmp	 r8, rdi
  00267	7c ed		 jl	 SHORT $LL30@fastsearch
$LN102@fastsearch:
  00269	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR p$[rsp]
$LN84@fastsearch:

; 163  :                         break;
; 164  :                 if (j == mlast) {

  00271	4c 3b c7	 cmp	 r8, rdi
  00274	75 17		 jne	 SHORT $LN26@fastsearch

; 165  :                     /* got a match! */
; 166  :                     if (mode != FAST_COUNT)

  00276	45 85 f6	 test	 r14d, r14d
  00279	75 65		 jne	 SHORT $LN85@fastsearch

; 168  :                     count++;

  0027b	49 ff c1	 inc	 r9

; 169  :                     if (count == maxcount)

  0027e	4d 3b cc	 cmp	 r9, r12
  00281	74 55		 je	 SHORT $LN86@fastsearch

; 171  :                     i = i + mlast;
; 172  :                     continue;

  00283	44 8b 44 24 78	 mov	 r8d, DWORD PTR mask$1$[rsp]
  00288	48 03 d7	 add	 rdx, rdi
  0028b	eb 2e		 jmp	 SHORT $LN33@fastsearch
$LN26@fastsearch:

; 173  :                 }
; 174  :                 /* miss: check if next character is part of pattern */
; 175  :                 if (!STRINGLIB_BLOOM(mask, s[i+m]))

  0028d	41 0f be 04 17	 movsx	 eax, BYTE PTR [r15+rdx]
  00292	44 8b 44 24 78	 mov	 r8d, DWORD PTR mask$1$[rsp]
  00297	83 e0 1f	 and	 eax, 31
  0029a	41 0f a3 c0	 bt	 r8d, eax

; 176  :                     i = i + m;
; 177  :                 else

  0029e	73 18		 jae	 SHORT $LN107@fastsearch

; 178  :                     i = i + skip;

  002a0	48 03 94 24 88
	00 00 00	 add	 rdx, QWORD PTR skip$1$[rsp]

; 179  :             } else {

  002a8	eb 11		 jmp	 SHORT $LN33@fastsearch
$LN31@fastsearch:

; 180  :                 /* skip: check if next character is part of pattern */
; 181  :                 if (!STRINGLIB_BLOOM(mask, s[i+m]))

  002aa	41 0f be 04 17	 movsx	 eax, BYTE PTR [r15+rdx]
  002af	83 e0 1f	 and	 eax, 31
  002b2	41 0f a3 c0	 bt	 r8d, eax
  002b6	72 03		 jb	 SHORT $LN33@fastsearch
$LN107@fastsearch:

; 182  :                     i = i + m;

  002b8	49 03 d5	 add	 rdx, r13
$LN33@fastsearch:

; 156  : 
; 157  :         for (i = 0; i <= w; i++) {

  002bb	48 ff c2	 inc	 rdx
  002be	49 3b d2	 cmp	 rdx, r10
  002c1	0f 8e 6d ff ff
	ff		 jle	 $LN108@fastsearch
$LN100@fastsearch:

; 216  :             }
; 217  :         }
; 218  :     }
; 219  : 
; 220  :     if (mode != FAST_COUNT)

  002c7	45 85 f6	 test	 r14d, r14d
  002ca	0f 85 ef 00 00
	00		 jne	 $LN101@fastsearch

; 222  :     return count;

  002d0	49 8b c1	 mov	 rax, r9
  002d3	e9 ea 00 00 00	 jmp	 $LN106@fastsearch
$LN86@fastsearch:

; 170  :                         return maxcount;

  002d8	49 8b c4	 mov	 rax, r12
  002db	e9 e2 00 00 00	 jmp	 $LN106@fastsearch
$LN85@fastsearch:

; 167  :                         return i;

  002e0	48 8b c2	 mov	 rax, rdx
  002e3	e9 da 00 00 00	 jmp	 $LN106@fastsearch
$LN39@fastsearch:

; 183  :             }
; 184  :         }
; 185  :     } else {    /* FAST_RSEARCH */
; 186  : 
; 187  :         /* create compressed boyer-moore delta 1 table */
; 188  : 
; 189  :         /* process pattern[0] outside the loop */
; 190  :         STRINGLIB_BLOOM_ADD(mask, p[0]);

  002e8	45 0f be 37	 movsx	 r14d, BYTE PTR [r15]
  002ec	44 8b e6	 mov	 r12d, esi
  002ef	41 8b ce	 mov	 ecx, r14d
  002f2	83 e1 1f	 and	 ecx, 31
  002f5	41 d3 e4	 shl	 r12d, cl

; 191  :         /* process pattern[:0:-1] */
; 192  :         for (i = mlast; i > 0; i--) {

  002f8	48 85 ff	 test	 rdi, rdi
  002fb	7e 41		 jle	 SHORT $LN16@fastsearch
  002fd	4e 8d 0c 3f	 lea	 r9, QWORD PTR [rdi+r15]
  00301	49 2b ef	 sub	 rbp, r15
  00304	4c 8b df	 mov	 r11, rdi
  00307	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL18@fastsearch:

; 193  :             STRINGLIB_BLOOM_ADD(mask, p[i]);

  00310	45 0f be 01	 movsx	 r8d, BYTE PTR [r9]
  00314	8b d6		 mov	 edx, esi
  00316	41 8b c8	 mov	 ecx, r8d
  00319	83 e1 1f	 and	 ecx, 31
  0031c	d3 e2		 shl	 edx, cl
  0031e	44 0b e2	 or	 r12d, edx

; 194  :             if (p[i] == p[0])

  00321	45 3a c6	 cmp	 r8b, r14b
  00324	75 0c		 jne	 SHORT $LN17@fastsearch

; 195  :                 skip = i - 1;

  00326	49 8d 04 29	 lea	 rax, QWORD PTR [r9+rbp]
  0032a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR skip$1$[rsp], rax
$LN17@fastsearch:

; 191  :         /* process pattern[:0:-1] */
; 192  :         for (i = mlast; i > 0; i--) {

  00332	49 ff c9	 dec	 r9
  00335	49 ff cb	 dec	 r11
  00338	75 d6		 jne	 SHORT $LL18@fastsearch
  0033a	48 83 cd ff	 or	 rbp, -1
$LN16@fastsearch:

; 196  :         }
; 197  : 
; 198  :         for (i = w; i >= 0; i--) {

  0033e	4d 8b c2	 mov	 r8, r10
  00341	4d 2b c7	 sub	 r8, r15
  00344	4c 03 c3	 add	 r8, rbx
$LL14@fastsearch:

; 199  :             if (s[i] == p[0]) {

  00347	45 38 34 1a	 cmp	 BYTE PTR [r10+rbx], r14b
  0034b	75 50		 jne	 SHORT $LN11@fastsearch

; 200  :                 /* candidate match */
; 201  :                 for (j = mlast; j > 0; j--)

  0034d	48 8b d7	 mov	 rdx, rdi
  00350	48 85 ff	 test	 rdi, rdi
  00353	7e 1f		 jle	 SHORT $LN103@fastsearch
  00355	4a 8d 0c 3f	 lea	 rcx, QWORD PTR [rdi+r15]
  00359	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@fastsearch:

; 202  :                     if (s[i+j] != p[j])

  00360	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00363	41 38 04 08	 cmp	 BYTE PTR [r8+rcx], al
  00367	75 0b		 jne	 SHORT $LN103@fastsearch

; 200  :                 /* candidate match */
; 201  :                 for (j = mlast; j > 0; j--)

  00369	48 ff ca	 dec	 rdx
  0036c	48 ff c9	 dec	 rcx
  0036f	48 85 d2	 test	 rdx, rdx
  00372	7f ec		 jg	 SHORT $LL10@fastsearch
$LN103@fastsearch:

; 203  :                         break;
; 204  :                 if (j == 0)

  00374	48 85 d2	 test	 rdx, rdx
  00377	74 66		 je	 SHORT $LN88@fastsearch

; 207  :                 /* miss: check if previous character is part of pattern */
; 208  :                 if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))

  00379	4d 85 d2	 test	 r10, r10
  0037c	7e 0f		 jle	 SHORT $LN5@fastsearch
  0037e	41 0f be 44 1a
	ff		 movsx	 eax, BYTE PTR [r10+rbx-1]
  00384	83 e0 1f	 and	 eax, 31
  00387	41 0f a3 c4	 bt	 r12d, eax

; 209  :                     i = i - m;
; 210  :                 else

  0038b	73 24		 jae	 SHORT $LN109@fastsearch
$LN5@fastsearch:

; 211  :                     i = i - skip;

  0038d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR skip$1$[rsp]
  00395	4c 2b d2	 sub	 r10, rdx
  00398	4c 2b c2	 sub	 r8, rdx

; 212  :             } else {

  0039b	eb 1a		 jmp	 SHORT $LN13@fastsearch
$LN11@fastsearch:

; 213  :                 /* skip: check if previous character is part of pattern */
; 214  :                 if (i > 0 && !STRINGLIB_BLOOM(mask, s[i-1]))

  0039d	4d 85 d2	 test	 r10, r10
  003a0	7e 15		 jle	 SHORT $LN13@fastsearch
  003a2	41 0f be 44 1a
	ff		 movsx	 eax, BYTE PTR [r10+rbx-1]
  003a8	83 e0 1f	 and	 eax, 31
  003ab	41 0f a3 c4	 bt	 r12d, eax
  003af	72 06		 jb	 SHORT $LN13@fastsearch
$LN109@fastsearch:

; 215  :                     i = i - m;

  003b1	4d 2b d5	 sub	 r10, r13
  003b4	4d 2b c5	 sub	 r8, r13
$LN13@fastsearch:

; 196  :         }
; 197  : 
; 198  :         for (i = w; i >= 0; i--) {

  003b7	49 ff c8	 dec	 r8
  003ba	49 ff ca	 dec	 r10
  003bd	79 88		 jns	 SHORT $LL14@fastsearch
$LN101@fastsearch:

; 221  :         return -1;

  003bf	48 8b c5	 mov	 rax, rbp
$LN106@fastsearch:
  003c2	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  003c7	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  003cc	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN62@fastsearch:

; 223  : }

  003d1	48 83 c4 40	 add	 rsp, 64			; 00000040H
  003d5	41 5f		 pop	 r15
  003d7	41 5e		 pop	 r14
  003d9	41 5d		 pop	 r13
  003db	41 5c		 pop	 r12
  003dd	5b		 pop	 rbx
  003de	c3		 ret	 0
$LN88@fastsearch:

; 205  :                     /* got a match! */
; 206  :                     return i;

  003df	49 8b c2	 mov	 rax, r10
  003e2	eb de		 jmp	 SHORT $LN106@fastsearch
fastsearch ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\count.h
pdata	SEGMENT
$pdata$stringlib_count DD imagerel stringlib_count
	DD	imagerel stringlib_count+40
	DD	imagerel $unwind$stringlib_count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$stringlib_count DD imagerel stringlib_count+40
	DD	imagerel stringlib_count+73
	DD	imagerel $chain$0$stringlib_count
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$stringlib_count DD imagerel stringlib_count+73
	DD	imagerel stringlib_count+78
	DD	imagerel $chain$1$stringlib_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$stringlib_count DD 021H
	DD	imagerel stringlib_count
	DD	imagerel stringlib_count+40
	DD	imagerel $unwind$stringlib_count
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$stringlib_count DD 020521H
	DD	063405H
	DD	imagerel stringlib_count
	DD	imagerel stringlib_count+40
	DD	imagerel $unwind$stringlib_count
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_count DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT stringlib_count
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
maxcount$ = 96
stringlib_count PROC					; COMDAT

; 11   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 12   :     Py_ssize_t count;
; 13   : 
; 14   :     if (str_len < 0)

  00004	48 85 d2	 test	 rdx, rdx
  00007	79 07		 jns	 SHORT $LN3@stringlib_@2

; 15   :         return 0; /* start > len(str) */

  00009	33 c0		 xor	 eax, eax

; 22   :         return 0; /* no match */
; 23   : 
; 24   :     return count;
; 25   : }

  0000b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0000f	c3		 ret	 0
$LN3@stringlib_@2:

; 16   :     if (sub_len == 0)
; 17   :         return (str_len < maxcount) ? str_len + 1 : maxcount;

  00010	48 8b 44 24 60	 mov	 rax, QWORD PTR maxcount$[rsp]
  00015	4d 85 c9	 test	 r9, r9
  00018	75 0e		 jne	 SHORT $LN2@stringlib_@2
  0001a	48 3b d0	 cmp	 rdx, rax
  0001d	7d 2a		 jge	 SHORT $LN1@stringlib_@2
  0001f	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]

; 22   :         return 0; /* no match */
; 23   : 
; 24   :     return count;
; 25   : }

  00023	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00027	c3		 ret	 0
$LN2@stringlib_@2:
  00028	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 18   : 
; 19   :     count = FASTSEARCH(str, str_len, sub, sub_len, maxcount, FAST_COUNT);

  0002d	33 db		 xor	 ebx, ebx
  0002f	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  00033	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00038	e8 00 00 00 00	 call	 fastsearch

; 20   : 
; 21   :     if (count < 0)

  0003d	48 85 c0	 test	 rax, rax
  00040	48 0f 48 c3	 cmovs	 rax, rbx
  00044	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN1@stringlib_@2:

; 22   :         return 0; /* no match */
; 23   : 
; 24   :     return count;
; 25   : }

  00049	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004d	c3		 ret	 0
stringlib_count ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$stringlib_find DD imagerel stringlib_find
	DD	imagerel stringlib_find+58
	DD	imagerel $unwind$stringlib_find
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$stringlib_find DD imagerel stringlib_find+58
	DD	imagerel stringlib_find+235
	DD	imagerel $chain$4$stringlib_find
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$stringlib_find DD imagerel stringlib_find+235
	DD	imagerel stringlib_find+513
	DD	imagerel $chain$6$stringlib_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$stringlib_find DD 0a0021H
	DD	06f400H
	DD	07d400H
	DD	0fc400H
	DD	0e6400H
	DD	0c5400H
	DD	imagerel stringlib_find
	DD	imagerel stringlib_find+58
	DD	imagerel $unwind$stringlib_find
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$stringlib_find DD 0a1c21H
	DD	06f41cH
	DD	07d417H
	DD	0fc40fH
	DD	0e640aH
	DD	0c5405H
	DD	imagerel stringlib_find
	DD	imagerel stringlib_find+58
	DD	imagerel $unwind$stringlib_find
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_find DD 040901H
	DD	0e0057209H
	DD	030027003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\find.h
xdata	ENDS
;	COMDAT stringlib_find
_TEXT	SEGMENT
w$1$ = 32
str$ = 96
skip$1$ = 104
str_len$ = 104
sub$ = 112
sub_len$ = 120
offset$ = 128
stringlib_find PROC					; COMDAT

; 11   : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 56		 push	 r14
  00005	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00009	49 8b d9	 mov	 rbx, r9
  0000c	4d 8b f0	 mov	 r14, r8
  0000f	48 8b f9	 mov	 rdi, rcx

; 12   :     Py_ssize_t pos;
; 13   : 
; 14   :     if (str_len < 0)

  00012	48 85 d2	 test	 rdx, rdx
  00015	79 0d		 jns	 SHORT $LN3@stringlib_@3

; 15   :         return -1;

  00017	48 83 c8 ff	 or	 rax, -1

; 25   : }

  0001b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0001f	41 5e		 pop	 r14
  00021	5f		 pop	 rdi
  00022	5b		 pop	 rbx
  00023	c3		 ret	 0
$LN3@stringlib_@3:

; 16   :     if (sub_len == 0)

  00024	48 85 db	 test	 rbx, rbx
  00027	75 11		 jne	 SHORT $LN2@stringlib_@3

; 17   :         return offset;

  00029	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR offset$[rsp]

; 25   : }

  00031	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00035	41 5e		 pop	 r14
  00037	5f		 pop	 rdi
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
$LN2@stringlib_@3:
  0003a	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  0003f	48 89 74 24 70	 mov	 QWORD PTR [rsp+112], rsi
  00044	4c 89 64 24 78	 mov	 QWORD PTR [rsp+120], r12

; 18   : 
; 19   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_SEARCH);

  00049	48 8b ea	 mov	 rbp, rdx
  0004c	4c 89 6c 24 38	 mov	 QWORD PTR [rsp+56], r13
  00051	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  00056	48 2b eb	 sub	 rbp, rbx
  00059	48 89 6c 24 20	 mov	 QWORD PTR w$1$[rsp], rbp
  0005e	78 62		 js	 SHORT $LN65@stringlib_@3
  00060	48 83 fb 01	 cmp	 rbx, 1
  00064	0f 8f 81 00 00
	00		 jg	 $LN64@stringlib_@3
  0006a	48 85 db	 test	 rbx, rbx
  0006d	7e 53		 jle	 SHORT $LN65@stringlib_@3
  0006f	48 83 fa 0a	 cmp	 rdx, 10
  00073	7e 2f		 jle	 SHORT $LN62@stringlib_@3
  00075	4c 8d 04 11	 lea	 r8, QWORD PTR [rcx+rdx]
  00079	49 3b c8	 cmp	 rcx, r8
  0007c	73 15		 jae	 SHORT $LN72@stringlib_@3
  0007e	41 0f b6 16	 movzx	 edx, BYTE PTR [r14]
  00082	4c 2b c1	 sub	 r8, rcx
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0008b	4c 8b c8	 mov	 r9, rax
  0008e	48 85 c0	 test	 rax, rax
  00091	75 09		 jne	 SHORT $LN71@stringlib_@3
$LN72@stringlib_@3:
  00093	49 83 c9 ff	 or	 r9, -1
  00097	e9 4f 01 00 00	 jmp	 $LN67@stringlib_@3
$LN71@stringlib_@3:
  0009c	4c 2b cf	 sub	 r9, rdi
  0009f	e9 47 01 00 00	 jmp	 $LN67@stringlib_@3
$LN62@stringlib_@3:
  000a4	45 33 c9	 xor	 r9d, r9d
  000a7	48 85 d2	 test	 rdx, rdx
  000aa	7e 16		 jle	 SHORT $LN65@stringlib_@3
  000ac	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
$LL53@stringlib_@3:
  000b0	41 38 04 09	 cmp	 BYTE PTR [r9+rcx], al
  000b4	0f 84 31 01 00
	00		 je	 $LN67@stringlib_@3
  000ba	49 ff c1	 inc	 r9
  000bd	4c 3b ca	 cmp	 r9, rdx
  000c0	7c ee		 jl	 SHORT $LL53@stringlib_@3
$LN65@stringlib_@3:
  000c2	49 83 c9 ff	 or	 r9, -1
$LN1@stringlib_@3:
  000c6	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]
  000cb	4c 8b 6c 24 38	 mov	 r13, QWORD PTR [rsp+56]
  000d0	4c 8b 64 24 78	 mov	 r12, QWORD PTR [rsp+120]
  000d5	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  000da	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]

; 23   : 
; 24   :     return pos;

  000df	49 8b c1	 mov	 rax, r9

; 25   : }

  000e2	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000e6	41 5e		 pop	 r14
  000e8	5f		 pop	 rdi
  000e9	5b		 pop	 rbx
  000ea	c3		 ret	 0

; 18   : 
; 19   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_SEARCH);

$LN64@stringlib_@3:
  000eb	4d 8d 51 ff	 lea	 r10, QWORD PTR [r9-1]
  000ef	45 33 c9	 xor	 r9d, r9d
  000f2	4d 8d 62 ff	 lea	 r12, QWORD PTR [r10-1]
  000f6	45 8b f9	 mov	 r15d, r9d
  000f9	45 8d 59 01	 lea	 r11d, QWORD PTR [r9+1]
  000fd	4d 85 d2	 test	 r10, r10
  00100	7e 55		 jle	 SHORT $LN41@stringlib_@3
  00102	47 0f b6 2c 02	 movzx	 r13d, BYTE PTR [r10+r8]
  00107	49 8b ec	 mov	 rbp, r12
  0010a	4d 8b e2	 mov	 r12, r10
  0010d	4c 8b d5	 mov	 r10, rbp
  00110	49 8b f0	 mov	 rsi, r8
  00113	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL43@stringlib_@3:
  00120	44 0f be 06	 movsx	 r8d, BYTE PTR [rsi]
  00124	41 8b d3	 mov	 edx, r11d
  00127	41 8b c8	 mov	 ecx, r8d
  0012a	83 e1 1f	 and	 ecx, 31
  0012d	d3 e2		 shl	 edx, cl
  0012f	44 0b fa	 or	 r15d, edx
  00132	45 3a c5	 cmp	 r8b, r13b
  00135	4c 0f 44 d5	 cmove	 r10, rbp
  00139	48 ff c6	 inc	 rsi
  0013c	48 ff cd	 dec	 rbp
  0013f	49 ff cc	 dec	 r12
  00142	75 dc		 jne	 SHORT $LL43@stringlib_@3
  00144	48 8b 6c 24 20	 mov	 rbp, QWORD PTR w$1$[rsp]
  00149	4c 89 54 24 68	 mov	 QWORD PTR skip$1$[rsp], r10
  0014e	4c 8d 53 ff	 lea	 r10, QWORD PTR [rbx-1]
  00152	4c 8b 64 24 68	 mov	 r12, QWORD PTR skip$1$[rsp]
$LN41@stringlib_@3:
  00157	43 0f be 0c 32	 movsx	 ecx, BYTE PTR [r10+r14]
  0015c	49 8b d1	 mov	 rdx, r9
  0015f	83 e1 1f	 and	 ecx, 31
  00162	41 d3 e3	 shl	 r11d, cl
  00165	45 0b fb	 or	 r15d, r11d
  00168	48 85 ed	 test	 rbp, rbp
  0016b	0f 88 51 ff ff
	ff		 js	 $LN65@stringlib_@3
  00171	45 0f b6 6c 1e
	ff		 movzx	 r13d, BYTE PTR [r14+rbx-1]
  00177	48 8d 34 1f	 lea	 rsi, QWORD PTR [rdi+rbx]
  0017b	0f 1f 44 00 00	 npad	 5
$LL39@stringlib_@3:
  00180	44 38 6c 16 ff	 cmp	 BYTE PTR [rsi+rdx-1], r13b
  00185	75 44		 jne	 SHORT $LN36@stringlib_@3
  00187	4d 8b c1	 mov	 r8, r9
  0018a	4d 85 d2	 test	 r10, r10
  0018d	7e 25		 jle	 SHORT $LN89@stringlib_@3
  0018f	4c 8b da	 mov	 r11, rdx
  00192	49 8b ce	 mov	 rcx, r14
  00195	4d 2b de	 sub	 r11, r14
  00198	4c 03 df	 add	 r11, rdi
  0019b	0f 1f 44 00 00	 npad	 5
$LL35@stringlib_@3:
  001a0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  001a3	41 38 04 0b	 cmp	 BYTE PTR [r11+rcx], al
  001a7	75 0b		 jne	 SHORT $LN89@stringlib_@3
  001a9	49 ff c0	 inc	 r8
  001ac	48 ff c1	 inc	 rcx
  001af	4d 3b c2	 cmp	 r8, r10
  001b2	7c ec		 jl	 SHORT $LL35@stringlib_@3
$LN89@stringlib_@3:
  001b4	4d 3b c2	 cmp	 r8, r10
  001b7	74 2f		 je	 SHORT $LN83@stringlib_@3
  001b9	0f be 04 16	 movsx	 eax, BYTE PTR [rsi+rdx]
  001bd	83 e0 1f	 and	 eax, 31
  001c0	41 0f a3 c7	 bt	 r15d, eax
  001c4	73 12		 jae	 SHORT $LN90@stringlib_@3
  001c6	49 03 d4	 add	 rdx, r12
  001c9	eb 10		 jmp	 SHORT $LN38@stringlib_@3
$LN36@stringlib_@3:
  001cb	0f be 04 16	 movsx	 eax, BYTE PTR [rsi+rdx]
  001cf	83 e0 1f	 and	 eax, 31
  001d2	41 0f a3 c7	 bt	 r15d, eax
  001d6	72 03		 jb	 SHORT $LN38@stringlib_@3
$LN90@stringlib_@3:
  001d8	48 03 d3	 add	 rdx, rbx
$LN38@stringlib_@3:
  001db	48 ff c2	 inc	 rdx
  001de	48 3b d5	 cmp	 rdx, rbp
  001e1	7e 9d		 jle	 SHORT $LL39@stringlib_@3
  001e3	e9 da fe ff ff	 jmp	 $LN65@stringlib_@3
$LN83@stringlib_@3:
  001e8	4c 8b ca	 mov	 r9, rdx
$LN67@stringlib_@3:

; 20   : 
; 21   :     if (pos >= 0)

  001eb	4d 85 c9	 test	 r9, r9
  001ee	0f 88 d2 fe ff
	ff		 js	 $LN1@stringlib_@3

; 22   :         pos += offset;

  001f4	4c 03 8c 24 80
	00 00 00	 add	 r9, QWORD PTR offset$[rsp]
  001fc	e9 c5 fe ff ff	 jmp	 $LN1@stringlib_@3
stringlib_find ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$stringlib_rfind DD imagerel stringlib_rfind
	DD	imagerel stringlib_rfind+58
	DD	imagerel $unwind$stringlib_rfind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$stringlib_rfind DD imagerel stringlib_rfind+58
	DD	imagerel stringlib_rfind+161
	DD	imagerel $chain$2$stringlib_rfind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$stringlib_rfind DD imagerel stringlib_rfind+161
	DD	imagerel stringlib_rfind+198
	DD	imagerel $chain$4$stringlib_rfind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$stringlib_rfind DD imagerel stringlib_rfind+198
	DD	imagerel stringlib_rfind+280
	DD	imagerel $chain$6$stringlib_rfind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$stringlib_rfind DD imagerel stringlib_rfind+280
	DD	imagerel stringlib_rfind+425
	DD	imagerel $chain$7$stringlib_rfind
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$stringlib_rfind DD 021H
	DD	imagerel stringlib_rfind+161
	DD	imagerel stringlib_rfind+198
	DD	imagerel $chain$4$stringlib_rfind
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$stringlib_rfind DD 040d21H
	DD	07740dH
	DD	066405H
	DD	imagerel stringlib_rfind+161
	DD	imagerel stringlib_rfind+198
	DD	imagerel $chain$4$stringlib_rfind
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$stringlib_rfind DD 060021H
	DD	0e400H
	DD	01d400H
	DD	08c400H
	DD	imagerel stringlib_rfind
	DD	imagerel stringlib_rfind+58
	DD	imagerel $unwind$stringlib_rfind
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$stringlib_rfind DD 061421H
	DD	0e414H
	DD	01d40dH
	DD	08c405H
	DD	imagerel stringlib_rfind
	DD	imagerel stringlib_rfind+58
	DD	imagerel $unwind$stringlib_rfind
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rfind DD 040901H
	DD	0f0051209H
	DD	030025003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\find.h
xdata	ENDS
;	COMDAT stringlib_rfind
_TEXT	SEGMENT
str$ = 48
str_len$ = 56
sub$ = 64
sub_len$ = 72
offset$ = 80
stringlib_rfind PROC					; COMDAT

; 31   : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	41 57		 push	 r15
  00005	48 83 ec 10	 sub	 rsp, 16
  00009	49 8b d9	 mov	 rbx, r9
  0000c	4d 8b f8	 mov	 r15, r8
  0000f	48 8b e9	 mov	 rbp, rcx

; 32   :     Py_ssize_t pos;
; 33   : 
; 34   :     if (str_len < 0)

  00012	48 85 d2	 test	 rdx, rdx
  00015	79 0d		 jns	 SHORT $LN3@stringlib_@4

; 35   :         return -1;

  00017	48 83 c8 ff	 or	 rax, -1

; 45   : }

  0001b	48 83 c4 10	 add	 rsp, 16
  0001f	41 5f		 pop	 r15
  00021	5d		 pop	 rbp
  00022	5b		 pop	 rbx
  00023	c3		 ret	 0
$LN3@stringlib_@4:

; 36   :     if (sub_len == 0)

  00024	48 85 db	 test	 rbx, rbx
  00027	75 11		 jne	 SHORT $LN2@stringlib_@4

; 37   :         return str_len + offset;

  00029	48 8b 44 24 50	 mov	 rax, QWORD PTR offset$[rsp]
  0002e	48 03 c2	 add	 rax, rdx

; 45   : }

  00031	48 83 c4 10	 add	 rsp, 16
  00035	41 5f		 pop	 r15
  00037	5d		 pop	 rbp
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
$LN2@stringlib_@4:
  0003a	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12

; 38   : 
; 39   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_RSEARCH);

  0003f	4c 8b ca	 mov	 r9, rdx
  00042	4c 89 6c 24 08	 mov	 QWORD PTR [rsp+8], r13
  00047	4c 2b cb	 sub	 r9, rbx
  0004a	4c 89 34 24	 mov	 QWORD PTR [rsp], r14
  0004e	78 33		 js	 SHORT $LN65@stringlib_@4
  00050	48 83 fb 01	 cmp	 rbx, 1
  00054	7f 4b		 jg	 SHORT $LN64@stringlib_@4
  00056	48 85 db	 test	 rbx, rbx
  00059	7e 28		 jle	 SHORT $LN65@stringlib_@4
  0005b	4c 8d 4a ff	 lea	 r9, QWORD PTR [rdx-1]
  0005f	49 83 f9 ff	 cmp	 r9, -1
  00063	7e 1e		 jle	 SHORT $LN65@stringlib_@4
  00065	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL48@stringlib_@4:
  00070	41 38 04 09	 cmp	 BYTE PTR [r9+rcx], al
  00074	0f 84 15 01 00
	00		 je	 $LN83@stringlib_@4
  0007a	49 ff c9	 dec	 r9
  0007d	49 83 f9 ff	 cmp	 r9, -1
  00081	7f ed		 jg	 SHORT $LL48@stringlib_@4
$LN65@stringlib_@4:
  00083	49 83 ca ff	 or	 r10, -1
$LN1@stringlib_@4:
  00087	4c 8b 34 24	 mov	 r14, QWORD PTR [rsp]
  0008b	4c 8b 6c 24 08	 mov	 r13, QWORD PTR [rsp+8]
  00090	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]

; 43   : 
; 44   :     return pos;

  00095	49 8b c2	 mov	 rax, r10

; 45   : }

  00098	48 83 c4 10	 add	 rsp, 16
  0009c	41 5f		 pop	 r15
  0009e	5d		 pop	 rbp
  0009f	5b		 pop	 rbx
  000a0	c3		 ret	 0

; 38   : 
; 39   :     pos = FASTSEARCH(str, str_len, sub, sub_len, -1, FAST_RSEARCH);

$LN64@stringlib_@4:
  000a1	45 0f be 18	 movsx	 r11d, BYTE PTR [r8]
  000a5	4c 8d 63 ff	 lea	 r12, QWORD PTR [rbx-1]
  000a9	41 be 01 00 00
	00		 mov	 r14d, 1
  000af	41 8b cb	 mov	 ecx, r11d
  000b2	49 83 ca ff	 or	 r10, -1
  000b6	4d 8d 6c 24 ff	 lea	 r13, QWORD PTR [r12-1]
  000bb	83 e1 1f	 and	 ecx, 31
  000be	41 d3 e6	 shl	 r14d, cl
  000c1	4d 85 e4	 test	 r12, r12
  000c4	7e 52		 jle	 SHORT $LN21@stringlib_@4
  000c6	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  000cb	49 8b f2	 mov	 rsi, r10
  000ce	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  000d3	4f 8d 1c 04	 lea	 r11, QWORD PTR [r12+r8]
  000d7	49 8b fc	 mov	 rdi, r12
  000da	45 0f b6 20	 movzx	 r12d, BYTE PTR [r8]
  000de	49 2b f0	 sub	 rsi, r8
$LL23@stringlib_@4:
  000e1	45 0f be 03	 movsx	 r8d, BYTE PTR [r11]
  000e5	ba 01 00 00 00	 mov	 edx, 1
  000ea	41 8b c8	 mov	 ecx, r8d
  000ed	83 e1 1f	 and	 ecx, 31
  000f0	d3 e2		 shl	 edx, cl
  000f2	44 0b f2	 or	 r14d, edx
  000f5	45 3a c4	 cmp	 r8b, r12b
  000f8	75 04		 jne	 SHORT $LN22@stringlib_@4
  000fa	4e 8d 2c 1e	 lea	 r13, QWORD PTR [rsi+r11]
$LN22@stringlib_@4:
  000fe	49 ff cb	 dec	 r11
  00101	48 ff cf	 dec	 rdi
  00104	75 db		 jne	 SHORT $LL23@stringlib_@4
  00106	45 0f b6 1f	 movzx	 r11d, BYTE PTR [r15]
  0010a	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  0010f	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00114	4c 8d 63 ff	 lea	 r12, QWORD PTR [rbx-1]
$LN21@stringlib_@4:
  00118	4d 8b c1	 mov	 r8, r9
  0011b	4d 2b c7	 sub	 r8, r15
  0011e	4c 03 c5	 add	 r8, rbp
$LL19@stringlib_@4:
  00121	45 38 1c 29	 cmp	 BYTE PTR [r9+rbp], r11b
  00125	75 41		 jne	 SHORT $LN16@stringlib_@4
  00127	49 8b d4	 mov	 rdx, r12
  0012a	4d 85 e4	 test	 r12, r12
  0012d	7e 18		 jle	 SHORT $LN89@stringlib_@4
  0012f	4b 8d 0c 3c	 lea	 rcx, QWORD PTR [r12+r15]
$LL15@stringlib_@4:
  00133	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00136	41 38 04 08	 cmp	 BYTE PTR [r8+rcx], al
  0013a	75 0b		 jne	 SHORT $LN89@stringlib_@4
  0013c	48 ff ca	 dec	 rdx
  0013f	48 ff c9	 dec	 rcx
  00142	48 85 d2	 test	 rdx, rdx
  00145	7f ec		 jg	 SHORT $LL15@stringlib_@4
$LN89@stringlib_@4:
  00147	48 85 d2	 test	 rdx, rdx
  0014a	74 43		 je	 SHORT $LN83@stringlib_@4
  0014c	4d 85 c9	 test	 r9, r9
  0014f	7e 0f		 jle	 SHORT $LN10@stringlib_@4
  00151	41 0f be 44 29
	ff		 movsx	 eax, BYTE PTR [r9+rbp-1]
  00157	83 e0 1f	 and	 eax, 31
  0015a	41 0f a3 c6	 bt	 r14d, eax
  0015e	73 1c		 jae	 SHORT $LN90@stringlib_@4
$LN10@stringlib_@4:
  00160	4d 2b cd	 sub	 r9, r13
  00163	4d 2b c5	 sub	 r8, r13
  00166	eb 1a		 jmp	 SHORT $LN18@stringlib_@4
$LN16@stringlib_@4:
  00168	4d 85 c9	 test	 r9, r9
  0016b	7e 15		 jle	 SHORT $LN18@stringlib_@4
  0016d	41 0f be 44 29
	ff		 movsx	 eax, BYTE PTR [r9+rbp-1]
  00173	83 e0 1f	 and	 eax, 31
  00176	41 0f a3 c6	 bt	 r14d, eax
  0017a	72 06		 jb	 SHORT $LN18@stringlib_@4
$LN90@stringlib_@4:
  0017c	4c 2b cb	 sub	 r9, rbx
  0017f	4c 2b c3	 sub	 r8, rbx
$LN18@stringlib_@4:
  00182	49 ff c8	 dec	 r8
  00185	49 ff c9	 dec	 r9
  00188	79 97		 jns	 SHORT $LL19@stringlib_@4
  0018a	e9 f8 fe ff ff	 jmp	 $LN1@stringlib_@4
$LN83@stringlib_@4:
  0018f	4d 8b d1	 mov	 r10, r9

; 40   : 
; 41   :     if (pos >= 0)

  00192	4d 85 c9	 test	 r9, r9
  00195	0f 88 ec fe ff
	ff		 js	 $LN1@stringlib_@4

; 42   :         pos += offset;

  0019b	48 8b 44 24 50	 mov	 rax, QWORD PTR offset$[rsp]
  001a0	4d 8d 14 01	 lea	 r10, QWORD PTR [r9+rax]
  001a4	e9 de fe ff ff	 jmp	 $LN1@stringlib_@4
stringlib_rfind ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_find_slice DD imagerel stringlib_find_slice
	DD	imagerel stringlib_find_slice+75
	DD	imagerel $unwind$stringlib_find_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_find_slice DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT stringlib_find_slice
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
start$ = 96
end$ = 104
stringlib_find_slice PROC				; COMDAT

; 66   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	4c 8b d2	 mov	 r10, rdx

; 67   :     ADJUST_INDICES(start, end, str_len);

  00007	48 8b 54 24 68	 mov	 rdx, QWORD PTR end$[rsp]
  0000c	45 33 db	 xor	 r11d, r11d
  0000f	49 3b d2	 cmp	 rdx, r10
  00012	7e 05		 jle	 SHORT $LN6@stringlib_@5
  00014	49 8b d2	 mov	 rdx, r10
  00017	eb 0c		 jmp	 SHORT $LN3@stringlib_@5
$LN6@stringlib_@5:
  00019	48 85 d2	 test	 rdx, rdx
  0001c	79 07		 jns	 SHORT $LN3@stringlib_@5
  0001e	49 03 d2	 add	 rdx, r10
  00021	49 0f 48 d3	 cmovs	 rdx, r11
$LN3@stringlib_@5:
  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0002a	48 85 c0	 test	 rax, rax
  0002d	79 07		 jns	 SHORT $LN1@stringlib_@5
  0002f	49 03 c2	 add	 rax, r10
  00032	49 0f 48 c3	 cmovs	 rax, r11
$LN1@stringlib_@5:

; 68   :     return STRINGLIB(find)(str + start, end - start, sub, sub_len, start);

  00036	48 2b d0	 sub	 rdx, rax
  00039	48 03 c8	 add	 rcx, rax
  0003c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00041	e8 00 00 00 00	 call	 stringlib_find

; 69   : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
stringlib_find_slice ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_rfind_slice DD imagerel stringlib_rfind_slice
	DD	imagerel stringlib_rfind_slice+75
	DD	imagerel $unwind$stringlib_rfind_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rfind_slice DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT stringlib_rfind_slice
_TEXT	SEGMENT
str$ = 64
str_len$ = 72
sub$ = 80
sub_len$ = 88
start$ = 96
end$ = 104
stringlib_rfind_slice PROC				; COMDAT

; 75   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	4c 8b d2	 mov	 r10, rdx

; 76   :     ADJUST_INDICES(start, end, str_len);

  00007	48 8b 54 24 68	 mov	 rdx, QWORD PTR end$[rsp]
  0000c	45 33 db	 xor	 r11d, r11d
  0000f	49 3b d2	 cmp	 rdx, r10
  00012	7e 05		 jle	 SHORT $LN6@stringlib_@6
  00014	49 8b d2	 mov	 rdx, r10
  00017	eb 0c		 jmp	 SHORT $LN3@stringlib_@6
$LN6@stringlib_@6:
  00019	48 85 d2	 test	 rdx, rdx
  0001c	79 07		 jns	 SHORT $LN3@stringlib_@6
  0001e	49 03 d2	 add	 rdx, r10
  00021	49 0f 48 d3	 cmovs	 rdx, r11
$LN3@stringlib_@6:
  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR start$[rsp]
  0002a	48 85 c0	 test	 rax, rax
  0002d	79 07		 jns	 SHORT $LN1@stringlib_@6
  0002f	49 03 c2	 add	 rax, r10
  00032	49 0f 48 c3	 cmovs	 rax, r11
$LN1@stringlib_@6:

; 77   :     return STRINGLIB(rfind)(str + start, end - start, sub, sub_len, start);

  00036	48 2b d0	 sub	 rdx, rax
  00039	48 03 c8	 add	 rcx, rax
  0003c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00041	e8 00 00 00 00	 call	 stringlib_rfind

; 78   : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
stringlib_rfind_slice ENDP
_TEXT	ENDS
PUBLIC	??_C@_05BBAJLHME@O?$HMOO?3?$AA@			; `string'
EXTRN	_PyEval_SliceIndex:PROC
EXTRN	_PyArg_ParseTuple_SizeT:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_parse_args_finds DD imagerel stringlib_parse_args_finds
	DD	imagerel stringlib_parse_args_finds+307
	DD	imagerel $unwind$stringlib_parse_args_finds
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_parse_args_finds DD 0b2001H
	DD	0187420H
	DD	0176420H
	DD	0163420H
	DD	0120120H
	DD	0c012d014H
	DD	05010H
xdata	ENDS
;	COMDAT ??_C@_05BBAJLHME@O?$HMOO?3?$AA@
CONST	SEGMENT
??_C@_05BBAJLHME@O?$HMOO?3?$AA@ DB 'O|OO:', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT stringlib_parse_args_finds
_TEXT	SEGMENT
tmp_start$ = 48
tmp_end$ = 56
obj_end$ = 64
obj_start$ = 72
tmp_subobj$ = 80
format$ = 88
function_name$ = 176
args$ = 184
subobj$ = 192
start$ = 200
end$ = 208
stringlib_parse_args_finds PROC				; COMDAT

; 108  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	55		 push	 rbp
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 8d 6c 24 c1	 lea	 rbp, QWORD PTR [rsp-63]
  00019	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 109  :     PyObject *tmp_subobj;
; 110  :     Py_ssize_t tmp_start = 0;
; 111  :     Py_ssize_t tmp_end = PY_SSIZE_T_MAX;

  00020	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0002a	4d 8b e0	 mov	 r12, r8
  0002d	48 8b da	 mov	 rbx, rdx
  00030	48 8b d1	 mov	 rdx, rcx

; 112  :     PyObject *obj_start=Py_None, *obj_end=Py_None;
; 113  :     char format[FORMAT_BUFFER_SIZE] = "O|OO:";
; 114  :     size_t len = strlen(format);

  00033	48 83 c9 ff	 or	 rcx, -1
  00037	48 89 45 e7	 mov	 QWORD PTR tmp_end$[rbp-81], rax
  0003b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@
  00041	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NoneStruct
  00048	48 8d 7d 07	 lea	 rdi, QWORD PTR format$[rbp-81]
  0004c	89 45 07	 mov	 DWORD PTR format$[rbp-81], eax
  0004f	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@+4

; 115  : 
; 116  :     strncpy(format + len, function_name, FORMAT_BUFFER_SIZE - len - 1);

  00056	41 b8 31 00 00
	00		 mov	 r8d, 49			; 00000031H
  0005c	66 89 45 0b	 mov	 WORD PTR format$[rbp-77], ax
  00060	33 c0		 xor	 eax, eax
  00062	49 8b f1	 mov	 rsi, r9
  00065	48 89 45 0d	 mov	 QWORD PTR format$[rbp-75], rax
  00069	48 89 45 15	 mov	 QWORD PTR format$[rbp-67], rax
  0006d	48 89 45 1d	 mov	 QWORD PTR format$[rbp-59], rax
  00071	48 89 45 25	 mov	 QWORD PTR format$[rbp-51], rax
  00075	48 89 45 2d	 mov	 QWORD PTR format$[rbp-43], rax
  00079	89 45 35	 mov	 DWORD PTR format$[rbp-35], eax
  0007c	f2 ae		 repne scasb
  0007e	48 c7 45 df 00
	00 00 00	 mov	 QWORD PTR tmp_start$[rbp-81], 0
  00086	4c 89 6d f7	 mov	 QWORD PTR obj_start$[rbp-81], r13
  0008a	48 f7 d1	 not	 rcx
  0008d	4c 89 6d ef	 mov	 QWORD PTR obj_end$[rbp-81], r13
  00091	48 ff c9	 dec	 rcx
  00094	4c 2b c1	 sub	 r8, rcx
  00097	48 8d 4c 0d 07	 lea	 rcx, QWORD PTR format$[rbp+rcx-81]
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 117  :     format[FORMAT_BUFFER_SIZE - 1] = '\0';
; 118  : 
; 119  :     if (!PyArg_ParseTuple(args, format, &tmp_subobj, &obj_start, &obj_end))

  000a2	48 8d 45 ef	 lea	 rax, QWORD PTR obj_end$[rbp-81]
  000a6	4c 8d 4d f7	 lea	 r9, QWORD PTR obj_start$[rbp-81]
  000aa	4c 8d 45 ff	 lea	 r8, QWORD PTR tmp_subobj$[rbp-81]
  000ae	48 8d 55 07	 lea	 rdx, QWORD PTR format$[rbp-81]
  000b2	48 8b cb	 mov	 rcx, rbx
  000b5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ba	c6 45 38 00	 mov	 BYTE PTR format$[rbp-32], 0
  000be	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000c3	85 c0		 test	 eax, eax
  000c5	75 04		 jne	 SHORT $LN5@stringlib_@7
$LN8@stringlib_@7:

; 120  :         return 0;

  000c7	33 c0		 xor	 eax, eax
  000c9	eb 4b		 jmp	 SHORT $LN6@stringlib_@7
$LN5@stringlib_@7:

; 121  : 
; 122  :     /* To support None in "start" and "end" arguments, meaning
; 123  :        the same as if they were not passed.
; 124  :     */
; 125  :     if (obj_start != Py_None)

  000cb	48 8b 4d f7	 mov	 rcx, QWORD PTR obj_start$[rbp-81]
  000cf	49 3b cd	 cmp	 rcx, r13
  000d2	74 0d		 je	 SHORT $LN3@stringlib_@7

; 126  :         if (!_PyEval_SliceIndex(obj_start, &tmp_start))

  000d4	48 8d 55 df	 lea	 rdx, QWORD PTR tmp_start$[rbp-81]
  000d8	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000dd	85 c0		 test	 eax, eax

; 127  :             return 0;

  000df	74 e6		 je	 SHORT $LN8@stringlib_@7
$LN3@stringlib_@7:

; 128  :     if (obj_end != Py_None)

  000e1	48 8b 4d ef	 mov	 rcx, QWORD PTR obj_end$[rbp-81]
  000e5	49 3b cd	 cmp	 rcx, r13
  000e8	74 0d		 je	 SHORT $LN1@stringlib_@7

; 129  :         if (!_PyEval_SliceIndex(obj_end, &tmp_end))

  000ea	48 8d 55 e7	 lea	 rdx, QWORD PTR tmp_end$[rbp-81]
  000ee	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000f3	85 c0		 test	 eax, eax

; 130  :             return 0;

  000f5	74 d0		 je	 SHORT $LN8@stringlib_@7
$LN1@stringlib_@7:

; 131  : 
; 132  :     *start = tmp_start;

  000f7	48 8b 45 df	 mov	 rax, QWORD PTR tmp_start$[rbp-81]

; 133  :     *end = tmp_end;

  000fb	48 8b 4d 7f	 mov	 rcx, QWORD PTR end$[rbp-81]
  000ff	48 89 06	 mov	 QWORD PTR [rsi], rax
  00102	48 8b 45 e7	 mov	 rax, QWORD PTR tmp_end$[rbp-81]
  00106	48 89 01	 mov	 QWORD PTR [rcx], rax

; 134  :     *subobj = tmp_subobj;

  00109	48 8b 45 ff	 mov	 rax, QWORD PTR tmp_subobj$[rbp-81]
  0010d	49 89 04 24	 mov	 QWORD PTR [r12], rax

; 135  :     return 1;

  00111	b8 01 00 00 00	 mov	 eax, 1
$LN6@stringlib_@7:

; 136  : }

  00116	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  0011e	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  00122	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  00126	49 8b 7b 30	 mov	 rdi, QWORD PTR [r11+48]
  0012a	49 8b e3	 mov	 rsp, r11
  0012d	41 5d		 pop	 r13
  0012f	41 5c		 pop	 r12
  00131	5d		 pop	 rbp
  00132	c3		 ret	 0
stringlib_parse_args_finds ENDP
_TEXT	ENDS
EXTRN	PyErr_GivenExceptionMatches:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_parse_args_finds_byte DD imagerel stringlib_parse_args_finds_byte
	DD	imagerel stringlib_parse_args_finds_byte+56
	DD	imagerel $unwind$stringlib_parse_args_finds_byte
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$stringlib_parse_args_finds_byte DD imagerel stringlib_parse_args_finds_byte+56
	DD	imagerel stringlib_parse_args_finds_byte+157
	DD	imagerel $chain$0$stringlib_parse_args_finds_byte
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$stringlib_parse_args_finds_byte DD imagerel stringlib_parse_args_finds_byte+157
	DD	imagerel stringlib_parse_args_finds_byte+195
	DD	imagerel $chain$2$stringlib_parse_args_finds_byte
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$stringlib_parse_args_finds_byte DD imagerel stringlib_parse_args_finds_byte+195
	DD	imagerel stringlib_parse_args_finds_byte+232
	DD	imagerel $chain$4$stringlib_parse_args_finds_byte
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$stringlib_parse_args_finds_byte DD 020021H
	DD	0a3400H
	DD	imagerel stringlib_parse_args_finds_byte
	DD	imagerel stringlib_parse_args_finds_byte+56
	DD	imagerel $unwind$stringlib_parse_args_finds_byte
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$stringlib_parse_args_finds_byte DD 020021H
	DD	0a3400H
	DD	imagerel stringlib_parse_args_finds_byte
	DD	imagerel stringlib_parse_args_finds_byte+56
	DD	imagerel $unwind$stringlib_parse_args_finds_byte
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$stringlib_parse_args_finds_byte DD 020521H
	DD	0a3405H
	DD	imagerel stringlib_parse_args_finds_byte
	DD	imagerel stringlib_parse_args_finds_byte+56
	DD	imagerel $unwind$stringlib_parse_args_finds_byte
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_parse_args_finds_byte DD 040a01H
	DD	0b640aH
	DD	07006720aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT stringlib_parse_args_finds_byte
_TEXT	SEGMENT
tmp_subobj$ = 48
function_name$ = 80
args$ = 88
subobj$ = 96
byte$ = 104
start$ = 112
end$ = 120
stringlib_parse_args_finds_byte PROC			; COMDAT

; 186  : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 187  :     PyObject *tmp_subobj;
; 188  :     Py_ssize_t ival;
; 189  :     PyObject *err;
; 190  : 
; 191  :     if(!STRINGLIB(parse_args_finds)(function_name, args, &tmp_subobj,
; 192  :                                     start, end))

  0000a	48 8b 44 24 78	 mov	 rax, QWORD PTR end$[rsp]
  0000f	49 8b f1	 mov	 rsi, r9
  00012	4c 8b 4c 24 70	 mov	 r9, QWORD PTR start$[rsp]
  00017	49 8b f8	 mov	 rdi, r8
  0001a	4c 8d 44 24 30	 lea	 r8, QWORD PTR tmp_subobj$[rsp]
  0001f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00024	e8 00 00 00 00	 call	 stringlib_parse_args_finds
  00029	85 c0		 test	 eax, eax
  0002b	75 0b		 jne	 SHORT $LN6@stringlib_@8

; 218  : }

  0002d	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00032	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
$LN6@stringlib_@8:
  00038	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx

; 193  :         return 0;
; 194  : 
; 195  :     if (!PyNumber_Check(tmp_subobj)) {

  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR tmp_subobj$[rsp]
  00042	48 8b cb	 mov	 rcx, rbx
  00045	e8 00 00 00 00	 call	 PyNumber_Check
  0004a	85 c0		 test	 eax, eax

; 196  :         *subobj = tmp_subobj;
; 197  :         return 1;

  0004c	74 37		 je	 SHORT $LN10@stringlib_@8

; 198  :     }
; 199  : 
; 200  :     ival = PyNumber_AsSsize_t(tmp_subobj, PyExc_OverflowError);

  0004e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00055	48 8b cb	 mov	 rcx, rbx
  00058	e8 00 00 00 00	 call	 PyNumber_AsSsize_t

; 201  :     if (ival == -1) {

  0005d	48 83 f8 ff	 cmp	 rax, -1
  00061	75 3a		 jne	 SHORT $LN3@stringlib_@8

; 202  :         err = PyErr_Occurred();

  00063	e8 00 00 00 00	 call	 PyErr_Occurred

; 203  :         if (err && !PyErr_GivenExceptionMatches(err, PyExc_OverflowError)) {

  00068	48 85 c0	 test	 rax, rax
  0006b	74 56		 je	 SHORT $LN1@stringlib_@8
  0006d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00074	48 8b c8	 mov	 rcx, rax
  00077	e8 00 00 00 00	 call	 PyErr_GivenExceptionMatches
  0007c	85 c0		 test	 eax, eax
  0007e	75 43		 jne	 SHORT $LN1@stringlib_@8

; 204  :             PyErr_Clear();

  00080	e8 00 00 00 00	 call	 PyErr_Clear
$LN10@stringlib_@8:

; 205  :             *subobj = tmp_subobj;

  00085	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  00088	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 206  :             return 1;

  0008d	b8 01 00 00 00	 mov	 eax, 1

; 218  : }

  00092	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00097	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0009b	5f		 pop	 rdi
  0009c	c3		 ret	 0
$LN3@stringlib_@8:

; 207  :         }
; 208  :     }
; 209  : 
; 210  :     if (ival < 0 || ival > 255) {

  0009d	48 3d ff 00 00
	00		 cmp	 rax, 255		; 000000ffH
  000a3	77 1e		 ja	 SHORT $LN1@stringlib_@8

; 212  :         return 0;
; 213  :     }
; 214  : 
; 215  :     *subobj = NULL;

  000a5	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000aa	48 c7 07 00 00
	00 00		 mov	 QWORD PTR [rdi], 0

; 216  :     *byte = (char)ival;

  000b1	88 06		 mov	 BYTE PTR [rsi], al

; 217  :     return 1;

  000b3	b8 01 00 00 00	 mov	 eax, 1

; 218  : }

  000b8	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  000bd	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0
$LN1@stringlib_@8:

; 211  :         PyErr_SetString(PyExc_ValueError, "byte must be in range(0, 256)");

  000c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@
  000d1	e8 00 00 00 00	 call	 PyErr_SetString
  000d6	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 218  : }

  000db	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  000e0	33 c0		 xor	 eax, eax
  000e2	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000e6	5f		 pop	 rdi
  000e7	c3		 ret	 0
stringlib_parse_args_finds_byte ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@JDENDMBF@empty?5separator?$AA@	; `string'
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$stringlib_partition DD imagerel stringlib_partition
	DD	imagerel stringlib_partition+83
	DD	imagerel $unwind$stringlib_partition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$stringlib_partition DD imagerel stringlib_partition+83
	DD	imagerel stringlib_partition+113
	DD	imagerel $chain$0$stringlib_partition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$stringlib_partition DD imagerel stringlib_partition+113
	DD	imagerel stringlib_partition+305
	DD	imagerel $chain$2$stringlib_partition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$stringlib_partition DD imagerel stringlib_partition+305
	DD	imagerel stringlib_partition+327
	DD	imagerel $chain$3$stringlib_partition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$stringlib_partition DD imagerel stringlib_partition+327
	DD	imagerel stringlib_partition+704
	DD	imagerel $chain$5$stringlib_partition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$stringlib_partition DD 060021H
	DD	0136400H
	DD	0115400H
	DD	0103400H
	DD	imagerel stringlib_partition
	DD	imagerel stringlib_partition+83
	DD	imagerel $unwind$stringlib_partition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$stringlib_partition DD 021H
	DD	imagerel stringlib_partition+83
	DD	imagerel stringlib_partition+113
	DD	imagerel $chain$0$stringlib_partition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$stringlib_partition DD 041021H
	DD	0115410H
	DD	0103408H
	DD	imagerel stringlib_partition+83
	DD	imagerel stringlib_partition+113
	DD	imagerel $chain$0$stringlib_partition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$stringlib_partition DD 020821H
	DD	0136408H
	DD	imagerel stringlib_partition
	DD	imagerel stringlib_partition+83
	DD	imagerel $unwind$stringlib_partition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_partition DD 061201H
	DD	0f00e9212H
	DD	0d00ae00cH
	DD	07006c008H
xdata	ENDS
;	COMDAT ??_C@_0BA@JDENDMBF@empty?5separator?$AA@
CONST	SEGMENT
??_C@_0BA@JDENDMBF@empty?5separator?$AA@ DB 'empty separator', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\partition.h
CONST	ENDS
;	COMDAT stringlib_partition
_TEXT	SEGMENT
mask$1$ = 32
skip$1$ = 40
mlast$1$ = 48
out$1$ = 56
w$1$ = 64
str$ = 128
str_len$ = 136
sep_obj$ = 144
sep$ = 152
sep_len$ = 160
stringlib_partition PROC				; COMDAT

; 12   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	57		 push	 rdi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	41 56		 push	 r14
  0000c	41 57		 push	 r15
  0000e	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 13   :     PyObject* out;
; 14   :     Py_ssize_t pos;
; 15   : 
; 16   :     if (sep_len == 0) {

  00012	4c 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR sep_len$[rsp]
  0001a	4d 8b f9	 mov	 r15, r9
  0001d	49 8b f8	 mov	 rdi, r8
  00020	4c 8b f2	 mov	 r14, rdx
  00023	4c 8b e1	 mov	 r12, rcx
  00026	4d 85 ed	 test	 r13, r13
  00029	75 23		 jne	 SHORT $LN4@stringlib_@9

; 17   :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00039	e8 00 00 00 00	 call	 PyErr_SetString

; 18   :         return NULL;

  0003e	33 c0		 xor	 eax, eax

; 52   :     }
; 53   : 
; 54   :     return out;
; 55   : }

  00040	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00044	41 5f		 pop	 r15
  00046	41 5e		 pop	 r14
  00048	41 5d		 pop	 r13
  0004a	41 5c		 pop	 r12
  0004c	5f		 pop	 rdi
  0004d	c3		 ret	 0
$LN4@stringlib_@9:

; 19   :     }
; 20   : 
; 21   :     out = PyTuple_New(3);

  0004e	b9 03 00 00 00	 mov	 ecx, 3
  00053	48 89 b4 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rsi
  0005b	e8 00 00 00 00	 call	 PyTuple_New
  00060	48 8b f0	 mov	 rsi, rax
  00063	48 89 44 24 38	 mov	 QWORD PTR out$1$[rsp], rax

; 22   :     if (!out)

  00068	48 85 c0	 test	 rax, rax
  0006b	0f 84 c0 00 00
	00		 je	 $LN92@stringlib_@9
$LN3@stringlib_@9:
  00071	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbx
  00079	48 89 ac 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbp

; 23   :         return NULL;
; 24   : 
; 25   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_SEARCH);

  00081	49 8b ee	 mov	 rbp, r14
  00084	49 2b ed	 sub	 rbp, r13
  00087	48 89 6c 24 40	 mov	 QWORD PTR w$1$[rsp], rbp
  0008c	78 64		 js	 SHORT $LN90@stringlib_@9
  0008e	49 83 fd 01	 cmp	 r13, 1
  00092	0f 8f af 00 00
	00		 jg	 $LN65@stringlib_@9
  00098	4d 85 ed	 test	 r13, r13
  0009b	7e 55		 jle	 SHORT $LN90@stringlib_@9
  0009d	49 83 fe 0a	 cmp	 r14, 10
  000a1	7e 32		 jle	 SHORT $LN63@stringlib_@9
  000a3	4f 8d 04 34	 lea	 r8, QWORD PTR [r12+r14]
  000a7	4d 3b e0	 cmp	 r12, r8
  000aa	73 18		 jae	 SHORT $LN73@stringlib_@9
  000ac	41 0f b6 17	 movzx	 edx, BYTE PTR [r15]
  000b0	4d 2b c4	 sub	 r8, r12
  000b3	49 8b cc	 mov	 rcx, r12
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000bc	48 8b d8	 mov	 rbx, rax
  000bf	48 85 c0	 test	 rax, rax
  000c2	75 09		 jne	 SHORT $LN72@stringlib_@9
$LN73@stringlib_@9:
  000c4	48 83 cb ff	 or	 rbx, -1
  000c8	e9 99 01 00 00	 jmp	 $LN68@stringlib_@9
$LN72@stringlib_@9:
  000cd	49 2b dc	 sub	 rbx, r12
  000d0	e9 91 01 00 00	 jmp	 $LN68@stringlib_@9
$LN63@stringlib_@9:
  000d5	33 db		 xor	 ebx, ebx
  000d7	4d 85 f6	 test	 r14, r14
  000da	7e 16		 jle	 SHORT $LN90@stringlib_@9
  000dc	41 0f b6 07	 movzx	 eax, BYTE PTR [r15]
$LL54@stringlib_@9:
  000e0	42 38 04 23	 cmp	 BYTE PTR [rbx+r12], al
  000e4	0f 84 7c 01 00
	00		 je	 $LN68@stringlib_@9
  000ea	48 ff c3	 inc	 rbx
  000ed	49 3b de	 cmp	 rbx, r14
  000f0	7c ee		 jl	 SHORT $LL54@stringlib_@9
$LN90@stringlib_@9:

; 28   : #if STRINGLIB_MUTABLE
; 29   :         PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, str_len));

  000f2	49 8b d6	 mov	 rdx, r14
  000f5	49 8b cc	 mov	 rcx, r12
  000f8	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize

; 30   :         PyTuple_SET_ITEM(out, 1, STRINGLIB_NEW(NULL, 0));

  000fd	33 d2		 xor	 edx, edx
  000ff	33 c9		 xor	 ecx, ecx
  00101	48 89 46 70	 mov	 QWORD PTR [rsi+112], rax
  00105	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize

; 31   :         PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(NULL, 0));

  0010a	33 d2		 xor	 edx, edx
  0010c	33 c9		 xor	 ecx, ecx
  0010e	48 89 46 78	 mov	 QWORD PTR [rsi+120], rax
  00112	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00117	48 89 86 80 00
	00 00		 mov	 QWORD PTR [rsi+128], rax
$LN1@stringlib_@9:

; 32   : #else
; 33   :         Py_INCREF(str_obj);
; 34   :         PyTuple_SET_ITEM(out, 0, (PyObject*) str_obj);
; 35   :         Py_INCREF(STRINGLIB_EMPTY);
; 36   :         PyTuple_SET_ITEM(out, 1, (PyObject*) STRINGLIB_EMPTY);
; 37   :         Py_INCREF(STRINGLIB_EMPTY);
; 38   :         PyTuple_SET_ITEM(out, 2, (PyObject*) STRINGLIB_EMPTY);
; 39   : #endif
; 40   :         return out;

  0011e	48 8b c6	 mov	 rax, rsi
$LN94@stringlib_@9:
  00121	48 8b ac 24 88
	00 00 00	 mov	 rbp, QWORD PTR [rsp+136]
  00129	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
$LN92@stringlib_@9:
  00131	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR [rsp+152]

; 52   :     }
; 53   : 
; 54   :     return out;
; 55   : }

  00139	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0013d	41 5f		 pop	 r15
  0013f	41 5e		 pop	 r14
  00141	41 5d		 pop	 r13
  00143	41 5c		 pop	 r12
  00145	5f		 pop	 rdi
  00146	c3		 ret	 0

; 23   :         return NULL;
; 24   : 
; 25   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_SEARCH);

$LN65@stringlib_@9:
  00147	4d 8d 4d ff	 lea	 r9, QWORD PTR [r13-1]
  0014b	33 db		 xor	 ebx, ebx
  0014d	49 8d 41 ff	 lea	 rax, QWORD PTR [r9-1]
  00151	4c 89 4c 24 30	 mov	 QWORD PTR mlast$1$[rsp], r9
  00156	8b fb		 mov	 edi, ebx
  00158	44 8d 53 01	 lea	 r10d, QWORD PTR [rbx+1]
  0015c	48 89 44 24 28	 mov	 QWORD PTR skip$1$[rsp], rax
  00161	4d 85 c9	 test	 r9, r9
  00164	7e 63		 jle	 SHORT $LN42@stringlib_@9
  00166	43 0f b6 2c 39	 movzx	 ebp, BYTE PTR [r9+r15]
  0016b	49 8b f1	 mov	 rsi, r9
  0016e	4d 8b df	 mov	 r11, r15
  00171	4c 8b c8	 mov	 r9, rax
  00174	48 8b f8	 mov	 rdi, rax
  00177	44 8b eb	 mov	 r13d, ebx
  0017a	66 0f 1f 44 00
	00		 npad	 6
$LL44@stringlib_@9:
  00180	45 0f be 03	 movsx	 r8d, BYTE PTR [r11]
  00184	41 8b d2	 mov	 edx, r10d
  00187	41 8b c8	 mov	 ecx, r8d
  0018a	83 e1 1f	 and	 ecx, 31
  0018d	d3 e2		 shl	 edx, cl
  0018f	44 0b ea	 or	 r13d, edx
  00192	44 3a c5	 cmp	 r8b, bpl
  00195	4c 0f 44 cf	 cmove	 r9, rdi
  00199	49 ff c3	 inc	 r11
  0019c	48 ff cf	 dec	 rdi
  0019f	48 ff ce	 dec	 rsi
  001a2	75 dc		 jne	 SHORT $LL44@stringlib_@9
  001a4	48 8b 74 24 38	 mov	 rsi, QWORD PTR out$1$[rsp]
  001a9	48 8b 6c 24 40	 mov	 rbp, QWORD PTR w$1$[rsp]
  001ae	44 89 6c 24 20	 mov	 DWORD PTR mask$1$[rsp], r13d
  001b3	8b 7c 24 20	 mov	 edi, DWORD PTR mask$1$[rsp]
  001b7	4c 8b ac 24 a0
	00 00 00	 mov	 r13, QWORD PTR sep_len$[rsp]
  001bf	4c 89 4c 24 28	 mov	 QWORD PTR skip$1$[rsp], r9
  001c4	4c 8b 4c 24 30	 mov	 r9, QWORD PTR mlast$1$[rsp]
$LN42@stringlib_@9:
  001c9	43 0f be 04 39	 movsx	 eax, BYTE PTR [r9+r15]
  001ce	48 8b d3	 mov	 rdx, rbx
  001d1	83 e0 1f	 and	 eax, 31
  001d4	0f b6 c8	 movzx	 ecx, al
  001d7	41 d3 e2	 shl	 r10d, cl
  001da	41 0b fa	 or	 edi, r10d
  001dd	48 85 ed	 test	 rbp, rbp
  001e0	0f 88 0c ff ff
	ff		 js	 $LN90@stringlib_@9
  001e6	4f 8d 1c 2c	 lea	 r11, QWORD PTR [r12+r13]
$LN96@stringlib_@9:
  001ea	43 0f b6 44 2f
	ff		 movzx	 eax, BYTE PTR [r15+r13-1]
  001f0	41 38 44 13 ff	 cmp	 BYTE PTR [r11+rdx-1], al
  001f5	75 46		 jne	 SHORT $LN37@stringlib_@9
  001f7	4c 8b c3	 mov	 r8, rbx
  001fa	4d 85 c9	 test	 r9, r9
  001fd	7e 25		 jle	 SHORT $LN91@stringlib_@9
  001ff	4c 8b d2	 mov	 r10, rdx
  00202	49 8b cf	 mov	 rcx, r15
  00205	4d 2b d7	 sub	 r10, r15
  00208	4d 03 d4	 add	 r10, r12
  0020b	0f 1f 44 00 00	 npad	 5
$LL36@stringlib_@9:
  00210	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00213	41 38 04 0a	 cmp	 BYTE PTR [r10+rcx], al
  00217	75 0b		 jne	 SHORT $LN91@stringlib_@9
  00219	49 ff c0	 inc	 r8
  0021c	48 ff c1	 inc	 rcx
  0021f	4d 3b c1	 cmp	 r8, r9
  00222	7c ec		 jl	 SHORT $LL36@stringlib_@9
$LN91@stringlib_@9:
  00224	4d 3b c1	 cmp	 r8, r9
  00227	74 32		 je	 SHORT $LN84@stringlib_@9
  00229	41 0f be 04 13	 movsx	 eax, BYTE PTR [r11+rdx]
  0022e	83 e0 1f	 and	 eax, 31
  00231	0f a3 c7	 bt	 edi, eax
  00234	73 14		 jae	 SHORT $LN95@stringlib_@9
  00236	48 03 54 24 28	 add	 rdx, QWORD PTR skip$1$[rsp]
  0023b	eb 10		 jmp	 SHORT $LN39@stringlib_@9
$LN37@stringlib_@9:
  0023d	41 0f be 04 13	 movsx	 eax, BYTE PTR [r11+rdx]
  00242	83 e0 1f	 and	 eax, 31
  00245	0f a3 c7	 bt	 edi, eax
  00248	72 03		 jb	 SHORT $LN39@stringlib_@9
$LN95@stringlib_@9:
  0024a	49 03 d5	 add	 rdx, r13
$LN39@stringlib_@9:
  0024d	48 ff c2	 inc	 rdx
  00250	48 3b d5	 cmp	 rdx, rbp
  00253	0f 8f 99 fe ff
	ff		 jg	 $LN90@stringlib_@9
  00259	eb 8f		 jmp	 SHORT $LN96@stringlib_@9
$LN84@stringlib_@9:
  0025b	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR sep_obj$[rsp]
  00263	48 8b da	 mov	 rbx, rdx
$LN68@stringlib_@9:

; 26   : 
; 27   :     if (pos < 0) {

  00266	48 85 db	 test	 rbx, rbx
  00269	0f 88 83 fe ff
	ff		 js	 $LN90@stringlib_@9

; 41   :     }
; 42   : 
; 43   :     PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, pos));

  0026f	48 8b d3	 mov	 rdx, rbx
  00272	49 8b cc	 mov	 rcx, r12
  00275	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize

; 44   :     Py_INCREF(sep_obj);

  0027a	48 8b cf	 mov	 rcx, rdi
  0027d	48 89 46 70	 mov	 QWORD PTR [rsi+112], rax
  00281	e8 00 00 00 00	 call	 _Py_IncRef

; 45   :     PyTuple_SET_ITEM(out, 1, sep_obj);
; 46   :     pos += sep_len;

  00286	49 03 dd	 add	 rbx, r13

; 47   :     PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str + pos, str_len - pos));

  00289	4c 2b f3	 sub	 r14, rbx
  0028c	4a 8d 0c 23	 lea	 rcx, QWORD PTR [rbx+r12]
  00290	48 89 7e 78	 mov	 QWORD PTR [rsi+120], rdi
  00294	49 8b d6	 mov	 rdx, r14
  00297	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0029c	48 89 86 80 00
	00 00		 mov	 QWORD PTR [rsi+128], rax

; 48   : 
; 49   :     if (PyErr_Occurred()) {

  002a3	e8 00 00 00 00	 call	 PyErr_Occurred
  002a8	48 85 c0	 test	 rax, rax
  002ab	0f 84 6d fe ff
	ff		 je	 $LN1@stringlib_@9

; 50   :         Py_DECREF(out);

  002b1	48 8b ce	 mov	 rcx, rsi
  002b4	e8 00 00 00 00	 call	 _Py_DecRef

; 51   :         return NULL;

  002b9	33 c0		 xor	 eax, eax
  002bb	e9 61 fe ff ff	 jmp	 $LN94@stringlib_@9
stringlib_partition ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$stringlib_rpartition DD imagerel stringlib_rpartition
	DD	imagerel stringlib_rpartition+84
	DD	imagerel $unwind$stringlib_rpartition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$stringlib_rpartition DD imagerel stringlib_rpartition+84
	DD	imagerel stringlib_rpartition+119
	DD	imagerel $chain$0$stringlib_rpartition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$stringlib_rpartition DD imagerel stringlib_rpartition+119
	DD	imagerel stringlib_rpartition+256
	DD	imagerel $chain$4$stringlib_rpartition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$stringlib_rpartition DD imagerel stringlib_rpartition+256
	DD	imagerel stringlib_rpartition+593
	DD	imagerel $chain$6$stringlib_rpartition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$stringlib_rpartition DD 060021H
	DD	04f400H
	DD	05d400H
	DD	0c3400H
	DD	imagerel stringlib_rpartition
	DD	imagerel stringlib_rpartition+84
	DD	imagerel $unwind$stringlib_rpartition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$stringlib_rpartition DD 060d21H
	DD	05d40dH
	DD	0c3405H
	DD	04f400H
	DD	imagerel stringlib_rpartition
	DD	imagerel stringlib_rpartition+84
	DD	imagerel $unwind$stringlib_rpartition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$stringlib_rpartition DD 020521H
	DD	04f405H
	DD	imagerel stringlib_rpartition
	DD	imagerel stringlib_rpartition+84
	DD	imagerel $unwind$stringlib_rpartition
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rpartition DD 061501H
	DD	0e0115215H
	DD	0700dc00fH
	DD	0500b600cH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\partition.h
xdata	ENDS
;	COMDAT stringlib_rpartition
_TEXT	SEGMENT
str$ = 96
str_len$ = 104
sep_obj$ = 112
sep$ = 120
sep_len$ = 128
stringlib_rpartition PROC				; COMDAT

; 62   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 56		 push	 r14
  00011	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 63   :     PyObject* out;
; 64   :     Py_ssize_t pos;
; 65   : 
; 66   :     if (sep_len == 0) {

  00015	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR sep_len$[rsp]
  0001d	4d 8b f1	 mov	 r14, r9
  00020	4d 8b e0	 mov	 r12, r8
  00023	48 8b ea	 mov	 rbp, rdx
  00026	48 8b f1	 mov	 rsi, rcx
  00029	48 85 ff	 test	 rdi, rdi
  0002c	75 21		 jne	 SHORT $LN4@stringlib_@10

; 67   :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0002e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  0003c	e8 00 00 00 00	 call	 PyErr_SetString

; 68   :         return NULL;

  00041	33 c0		 xor	 eax, eax

; 102  :     }
; 103  : 
; 104  :     return out;
; 105  : }

  00043	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00047	41 5e		 pop	 r14
  00049	41 5c		 pop	 r12
  0004b	5f		 pop	 rdi
  0004c	5e		 pop	 rsi
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
$LN4@stringlib_@10:

; 69   :     }
; 70   : 
; 71   :     out = PyTuple_New(3);

  0004f	b9 03 00 00 00	 mov	 ecx, 3
  00054	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00059	e8 00 00 00 00	 call	 PyTuple_New
  0005e	4c 8b f8	 mov	 r15, rax

; 72   :     if (!out)

  00061	48 85 c0	 test	 rax, rax
  00064	75 11		 jne	 SHORT $LN3@stringlib_@10
  00066	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]

; 102  :     }
; 103  : 
; 104  :     return out;
; 105  : }

  0006b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006f	41 5e		 pop	 r14
  00071	41 5c		 pop	 r12
  00073	5f		 pop	 rdi
  00074	5e		 pop	 rsi
  00075	5d		 pop	 rbp
  00076	c3		 ret	 0
$LN3@stringlib_@10:
  00077	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx

; 73   :         return NULL;
; 74   : 
; 75   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_RSEARCH);

  0007c	48 8b dd	 mov	 rbx, rbp
  0007f	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  00084	48 2b df	 sub	 rbx, rdi
  00087	78 2b		 js	 SHORT $LN90@stringlib_@10
  00089	48 83 ff 01	 cmp	 rdi, 1
  0008d	7f 71		 jg	 SHORT $LN65@stringlib_@10
  0008f	48 85 ff	 test	 rdi, rdi
  00092	7e 20		 jle	 SHORT $LN90@stringlib_@10
  00094	48 8d 5d ff	 lea	 rbx, QWORD PTR [rbp-1]
  00098	48 83 fb ff	 cmp	 rbx, -1
  0009c	7e 16		 jle	 SHORT $LN90@stringlib_@10
  0009e	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
$LL49@stringlib_@10:
  000a2	38 04 33	 cmp	 BYTE PTR [rbx+rsi], al
  000a5	0f 84 4b 01 00
	00		 je	 $LN68@stringlib_@10
  000ab	48 ff cb	 dec	 rbx
  000ae	48 83 fb ff	 cmp	 rbx, -1
  000b2	7f ee		 jg	 SHORT $LL49@stringlib_@10
$LN90@stringlib_@10:

; 78   : #if STRINGLIB_MUTABLE
; 79   :         PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(NULL, 0));

  000b4	33 d2		 xor	 edx, edx
  000b6	33 c9		 xor	 ecx, ecx
  000b8	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize

; 80   :         PyTuple_SET_ITEM(out, 1, STRINGLIB_NEW(NULL, 0));

  000bd	33 d2		 xor	 edx, edx
  000bf	33 c9		 xor	 ecx, ecx
  000c1	49 89 47 70	 mov	 QWORD PTR [r15+112], rax
  000c5	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize

; 81   :         PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str, str_len));

  000ca	48 8b 54 24 68	 mov	 rdx, QWORD PTR str_len$[rsp]
  000cf	48 8b ce	 mov	 rcx, rsi
  000d2	49 89 47 78	 mov	 QWORD PTR [r15+120], rax
  000d6	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000db	49 89 87 80 00
	00 00		 mov	 QWORD PTR [r15+128], rax
$LN1@stringlib_@10:

; 82   : #else
; 83   :         Py_INCREF(STRINGLIB_EMPTY);
; 84   :         PyTuple_SET_ITEM(out, 0, (PyObject*) STRINGLIB_EMPTY);
; 85   :         Py_INCREF(STRINGLIB_EMPTY);
; 86   :         PyTuple_SET_ITEM(out, 1, (PyObject*) STRINGLIB_EMPTY);
; 87   :         Py_INCREF(str_obj);
; 88   :         PyTuple_SET_ITEM(out, 2, (PyObject*) str_obj);
; 89   : #endif
; 90   :         return out;

  000e2	49 8b c7	 mov	 rax, r15
$LN95@stringlib_@10:
  000e5	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]
  000ea	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000ef	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]

; 102  :     }
; 103  : 
; 104  :     return out;
; 105  : }

  000f4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f8	41 5e		 pop	 r14
  000fa	41 5c		 pop	 r12
  000fc	5f		 pop	 rdi
  000fd	5e		 pop	 rsi
  000fe	5d		 pop	 rbp
  000ff	c3		 ret	 0

; 73   :         return NULL;
; 74   : 
; 75   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_RSEARCH);

$LN65@stringlib_@10:
  00100	45 0f be 0e	 movsx	 r9d, BYTE PTR [r14]
  00104	48 8d 6f ff	 lea	 rbp, QWORD PTR [rdi-1]
  00108	41 bd 01 00 00
	00		 mov	 r13d, 1
  0010e	41 8b c9	 mov	 ecx, r9d
  00111	4c 8d 65 ff	 lea	 r12, QWORD PTR [rbp-1]
  00115	83 e1 1f	 and	 ecx, 31
  00118	41 d3 e5	 shl	 r13d, cl
  0011b	48 85 ed	 test	 rbp, rbp
  0011e	7e 51		 jle	 SHORT $LN22@stringlib_@10
  00120	41 0f b6 3e	 movzx	 edi, BYTE PTR [r14]
  00124	49 83 cb ff	 or	 r11, -1
  00128	4d 8d 0c 2e	 lea	 r9, QWORD PTR [r14+rbp]
  0012c	4d 2b de	 sub	 r11, r14
  0012f	4c 8b d5	 mov	 r10, rbp
  00132	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL24@stringlib_@10:
  00140	45 0f be 01	 movsx	 r8d, BYTE PTR [r9]
  00144	ba 01 00 00 00	 mov	 edx, 1
  00149	41 8b c8	 mov	 ecx, r8d
  0014c	83 e1 1f	 and	 ecx, 31
  0014f	d3 e2		 shl	 edx, cl
  00151	44 0b ea	 or	 r13d, edx
  00154	44 3a c7	 cmp	 r8b, dil
  00157	75 04		 jne	 SHORT $LN23@stringlib_@10
  00159	4f 8d 24 0b	 lea	 r12, QWORD PTR [r11+r9]
$LN23@stringlib_@10:
  0015d	49 ff c9	 dec	 r9
  00160	49 ff ca	 dec	 r10
  00163	75 db		 jne	 SHORT $LL24@stringlib_@10
  00165	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR sep_len$[rsp]
  0016d	45 0f b6 0e	 movzx	 r9d, BYTE PTR [r14]
$LN22@stringlib_@10:
  00171	4c 8b c3	 mov	 r8, rbx
  00174	4d 2b c6	 sub	 r8, r14
  00177	4c 03 c6	 add	 r8, rsi
  0017a	66 0f 1f 44 00
	00		 npad	 6
$LL20@stringlib_@10:
  00180	44 38 0c 33	 cmp	 BYTE PTR [rbx+rsi], r9b
  00184	75 40		 jne	 SHORT $LN17@stringlib_@10
  00186	48 8b d5	 mov	 rdx, rbp
  00189	48 85 ed	 test	 rbp, rbp
  0018c	7e 18		 jle	 SHORT $LN91@stringlib_@10
  0018e	49 8d 0c 2e	 lea	 rcx, QWORD PTR [r14+rbp]
$LL16@stringlib_@10:
  00192	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00195	41 38 04 08	 cmp	 BYTE PTR [r8+rcx], al
  00199	75 0b		 jne	 SHORT $LN91@stringlib_@10
  0019b	48 ff ca	 dec	 rdx
  0019e	48 ff c9	 dec	 rcx
  001a1	48 85 d2	 test	 rdx, rdx
  001a4	7f ec		 jg	 SHORT $LL16@stringlib_@10
$LN91@stringlib_@10:
  001a6	48 85 d2	 test	 rdx, rdx
  001a9	74 41		 je	 SHORT $LN92@stringlib_@10
  001ab	48 85 db	 test	 rbx, rbx
  001ae	7e 0e		 jle	 SHORT $LN11@stringlib_@10
  001b0	0f be 44 33 ff	 movsx	 eax, BYTE PTR [rbx+rsi-1]
  001b5	83 e0 1f	 and	 eax, 31
  001b8	41 0f a3 c5	 bt	 r13d, eax
  001bc	73 1b		 jae	 SHORT $LN96@stringlib_@10
$LN11@stringlib_@10:
  001be	49 2b dc	 sub	 rbx, r12
  001c1	4d 2b c4	 sub	 r8, r12
  001c4	eb 19		 jmp	 SHORT $LN19@stringlib_@10
$LN17@stringlib_@10:
  001c6	48 85 db	 test	 rbx, rbx
  001c9	7e 14		 jle	 SHORT $LN19@stringlib_@10
  001cb	0f be 44 33 ff	 movsx	 eax, BYTE PTR [rbx+rsi-1]
  001d0	83 e0 1f	 and	 eax, 31
  001d3	41 0f a3 c5	 bt	 r13d, eax
  001d7	72 06		 jb	 SHORT $LN19@stringlib_@10
$LN96@stringlib_@10:
  001d9	48 2b df	 sub	 rbx, rdi
  001dc	4c 2b c7	 sub	 r8, rdi
$LN19@stringlib_@10:
  001df	49 ff c8	 dec	 r8
  001e2	48 ff cb	 dec	 rbx
  001e5	79 99		 jns	 SHORT $LL20@stringlib_@10
  001e7	e9 c8 fe ff ff	 jmp	 $LN90@stringlib_@10
$LN92@stringlib_@10:

; 62   : {

  001ec	48 8b 6c 24 68	 mov	 rbp, QWORD PTR str_len$[rsp]
  001f1	4c 8b 64 24 70	 mov	 r12, QWORD PTR sep_obj$[rsp]

; 73   :         return NULL;
; 74   : 
; 75   :     pos = FASTSEARCH(str, str_len, sep, sep_len, -1, FAST_RSEARCH);

$LN68@stringlib_@10:

; 76   : 
; 77   :     if (pos < 0) {

  001f6	48 85 db	 test	 rbx, rbx
  001f9	0f 88 b5 fe ff
	ff		 js	 $LN90@stringlib_@10

; 91   :     }
; 92   : 
; 93   :     PyTuple_SET_ITEM(out, 0, STRINGLIB_NEW(str, pos));

  001ff	48 8b d3	 mov	 rdx, rbx
  00202	48 8b ce	 mov	 rcx, rsi
  00205	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize

; 94   :     Py_INCREF(sep_obj);

  0020a	49 8b cc	 mov	 rcx, r12
  0020d	49 89 47 70	 mov	 QWORD PTR [r15+112], rax
  00211	e8 00 00 00 00	 call	 _Py_IncRef

; 95   :     PyTuple_SET_ITEM(out, 1, sep_obj);
; 96   :     pos += sep_len;

  00216	48 8d 04 3b	 lea	 rax, QWORD PTR [rbx+rdi]

; 97   :     PyTuple_SET_ITEM(out, 2, STRINGLIB_NEW(str + pos, str_len - pos));

  0021a	48 2b e8	 sub	 rbp, rax
  0021d	48 8d 0c 30	 lea	 rcx, QWORD PTR [rax+rsi]
  00221	4d 89 67 78	 mov	 QWORD PTR [r15+120], r12
  00225	48 8b d5	 mov	 rdx, rbp
  00228	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0022d	49 89 87 80 00
	00 00		 mov	 QWORD PTR [r15+128], rax

; 98   : 
; 99   :     if (PyErr_Occurred()) {

  00234	e8 00 00 00 00	 call	 PyErr_Occurred
  00239	48 85 c0	 test	 rax, rax
  0023c	0f 84 a0 fe ff
	ff		 je	 $LN1@stringlib_@10

; 100  :         Py_DECREF(out);

  00242	49 8b cf	 mov	 rcx, r15
  00245	e8 00 00 00 00	 call	 _Py_DecRef

; 101  :         return NULL;

  0024a	33 c0		 xor	 eax, eax
  0024c	e9 94 fe ff ff	 jmp	 $LN95@stringlib_@10
stringlib_rpartition ENDP
_TEXT	ENDS
EXTRN	PyList_Append:PROC
EXTRN	_Py_ctype_table:BYTE
EXTRN	PyList_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$stringlib_split_whitespace DD imagerel stringlib_split_whitespace
	DD	imagerel stringlib_split_whitespace+516
	DD	imagerel $unwind$stringlib_split_whitespace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_split_whitespace DD 0c5101H
	DD	0ef451H
	DD	0d644cH
	DD	0c3447H
	DD	0e009520dH
	DD	0c005d007H
	DD	050027003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT stringlib_split_whitespace
_TEXT	SEGMENT
str$ = 96
str_len$ = 104
maxcount$ = 112
stringlib_split_whitespace PROC				; COMDAT

; 57   : {

  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 58   :     Py_ssize_t i, j, count=0;

  0000d	45 33 e4	 xor	 r12d, r12d
  00010	48 8b e9	 mov	 rbp, rcx
  00013	4d 8b e8	 mov	 r13, r8
  00016	48 8b fa	 mov	 rdi, rdx

; 59   :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00019	41 8d 4c 24 0c	 lea	 ecx, QWORD PTR [r12+12]
  0001e	49 83 f8 0c	 cmp	 r8, 12
  00022	7d 04		 jge	 SHORT $LN26@stringlib_@11
  00024	49 8d 48 01	 lea	 rcx, QWORD PTR [r8+1]
$LN26@stringlib_@11:
  00028	e8 00 00 00 00	 call	 PyList_New
  0002d	4c 8b f0	 mov	 r14, rax

; 60   :     PyObject *sub;
; 61   : 
; 62   :     if (list == NULL)

  00030	48 85 c0	 test	 rax, rax
  00033	75 0d		 jne	 SHORT $LN22@stringlib_@11

; 99   : }

  00035	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00039	41 5e		 pop	 r14
  0003b	41 5d		 pop	 r13
  0003d	41 5c		 pop	 r12
  0003f	5f		 pop	 rdi
  00040	5d		 pop	 rbp
  00041	c3		 ret	 0
$LN22@stringlib_@11:
  00042	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00047	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  0004c	4c 89 7c 24 70	 mov	 QWORD PTR [rsp+112], r15

; 63   :         return NULL;
; 64   : 
; 65   :     i = j = 0;
; 66   :     while (maxcount-- > 0) {

  00051	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:_Py_ctype_table
  00058	49 8b dc	 mov	 rbx, r12
  0005b	4d 85 ed	 test	 r13, r13
  0005e	0f 8e fd 00 00
	00		 jle	 $LN47@stringlib_@11
$LL21@stringlib_@11:
  00064	49 ff cd	 dec	 r13

; 67   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  00067	48 3b df	 cmp	 rbx, rdi
  0006a	7d 1a		 jge	 SHORT $LN57@stringlib_@11
  0006c	0f 1f 40 00	 npad	 4
$LL19@stringlib_@11:
  00070	0f b6 04 2b	 movzx	 eax, BYTE PTR [rbx+rbp]
  00074	41 f6 04 87 08	 test	 BYTE PTR [r15+rax*4], 8
  00079	74 08		 je	 SHORT $LN52@stringlib_@11

; 68   :             i++;

  0007b	48 ff c3	 inc	 rbx
  0007e	48 3b df	 cmp	 rbx, rdi
  00081	7c ed		 jl	 SHORT $LL19@stringlib_@11
$LN52@stringlib_@11:

; 69   :         if (i == str_len) break;

  00083	48 3b df	 cmp	 rbx, rdi
$LN57@stringlib_@11:
  00086	0f 84 d5 00 00
	00		 je	 $LN47@stringlib_@11

; 70   :         j = i; i++;

  0008c	48 8b cb	 mov	 rcx, rbx
  0008f	48 ff c3	 inc	 rbx

; 71   :         while (i < str_len && !STRINGLIB_ISSPACE(str[i]))

  00092	48 3b df	 cmp	 rbx, rdi
  00095	7d 1c		 jge	 SHORT $LN53@stringlib_@11
  00097	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL16@stringlib_@11:
  000a0	0f b6 04 2b	 movzx	 eax, BYTE PTR [rbx+rbp]
  000a4	41 f6 04 87 08	 test	 BYTE PTR [r15+rax*4], 8
  000a9	75 08		 jne	 SHORT $LN53@stringlib_@11

; 72   :             i++;

  000ab	48 ff c3	 inc	 rbx
  000ae	48 3b df	 cmp	 rbx, rdi
  000b1	7c ed		 jl	 SHORT $LL16@stringlib_@11
$LN53@stringlib_@11:

; 73   : #ifndef STRINGLIB_MUTABLE
; 74   :         if (j == 0 && i == str_len && STRINGLIB_CHECK_EXACT(str_obj)) {
; 75   :             /* No whitespace in str_obj, so just use it as list[0] */
; 76   :             Py_INCREF(str_obj);
; 77   :             PyList_SET_ITEM(list, 0, (PyObject *)str_obj);
; 78   :             count++;
; 79   :             break;
; 80   :         }
; 81   : #endif
; 82   :         SPLIT_ADD(str, j, i);

  000b3	48 8b d3	 mov	 rdx, rbx
  000b6	48 2b d1	 sub	 rdx, rcx
  000b9	48 03 cd	 add	 rcx, rbp
  000bc	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000c1	48 8b f0	 mov	 rsi, rax
  000c4	48 85 c0	 test	 rax, rax
  000c7	0f 84 ee 00 00
	00		 je	 $onError$21422
  000cd	49 83 fc 0c	 cmp	 r12, 12
  000d1	7d 0a		 jge	 SHORT $LN13@stringlib_@11
  000d3	49 8b 4e 70	 mov	 rcx, QWORD PTR [r14+112]
  000d7	4a 89 04 e1	 mov	 QWORD PTR [rcx+r12*8], rax
  000db	eb 78		 jmp	 SHORT $LN37@stringlib_@11
$LN13@stringlib_@11:
  000dd	48 8b d0	 mov	 rdx, rax
  000e0	49 8b ce	 mov	 rcx, r14
  000e3	e8 00 00 00 00	 call	 PyList_Append
  000e8	85 c0		 test	 eax, eax
  000ea	0f 85 c3 00 00
	00		 jne	 $LN44@stringlib_@11
  000f0	e8 00 00 00 00	 call	 _Py_PXCTX
  000f5	85 c0		 test	 eax, eax
  000f7	75 5c		 jne	 SHORT $LN37@stringlib_@11
  000f9	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  000fd	a8 20		 test	 al, 32			; 00000020H
  000ff	75 4c		 jne	 SHORT $LN31@stringlib_@11
  00101	84 c0		 test	 al, al
  00103	78 48		 js	 SHORT $LN31@stringlib_@11
  00105	a8 02		 test	 al, 2
  00107	75 4c		 jne	 SHORT $LN37@stringlib_@11
  00109	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  0010d	75 46		 jne	 SHORT $LN37@stringlib_@11
  0010f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0011d	4c 8b ce	 mov	 r9, rsi
  00120	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00126	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0012e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00133	48 8b ce	 mov	 rcx, rsi
  00136	85 c0		 test	 eax, eax
  00138	74 07		 je	 SHORT $LN36@stringlib_@11
  0013a	e8 00 00 00 00	 call	 _Px_Dealloc
  0013f	eb 14		 jmp	 SHORT $LN37@stringlib_@11
$LN36@stringlib_@11:
  00141	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00145	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0014b	eb 08		 jmp	 SHORT $LN37@stringlib_@11
$LN31@stringlib_@11:
  0014d	48 8b ce	 mov	 rcx, rsi
  00150	e8 00 00 00 00	 call	 Px_DecRef
$LN37@stringlib_@11:
  00155	49 ff c4	 inc	 r12
  00158	4d 85 ed	 test	 r13, r13
  0015b	0f 8f 03 ff ff
	ff		 jg	 $LL21@stringlib_@11
$LN47@stringlib_@11:

; 83   :     }
; 84   : 
; 85   :     if (i < str_len) {

  00161	48 3b df	 cmp	 rbx, rdi
  00164	7d 7b		 jge	 SHORT $LN6@stringlib_@11
  00166	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL8@stringlib_@11:

; 86   :         /* Only occurs when maxcount was reached */
; 87   :         /* Skip any remaining whitespace and copy to end of string */
; 88   :         while (i < str_len && STRINGLIB_ISSPACE(str[i]))

  00170	0f b6 04 2b	 movzx	 eax, BYTE PTR [rbx+rbp]
  00174	41 f6 04 87 08	 test	 BYTE PTR [r15+rax*4], 8
  00179	74 08		 je	 SHORT $LN7@stringlib_@11

; 89   :             i++;

  0017b	48 ff c3	 inc	 rbx
  0017e	48 3b df	 cmp	 rbx, rdi
  00181	7c ed		 jl	 SHORT $LL8@stringlib_@11
$LN7@stringlib_@11:

; 90   :         if (i != str_len)

  00183	48 3b df	 cmp	 rbx, rdi
  00186	74 59		 je	 SHORT $LN6@stringlib_@11

; 91   :             SPLIT_ADD(str, i, str_len);

  00188	48 2b fb	 sub	 rdi, rbx
  0018b	48 8d 0c 2b	 lea	 rcx, QWORD PTR [rbx+rbp]
  0018f	48 8b d7	 mov	 rdx, rdi
  00192	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00197	48 8b d8	 mov	 rbx, rax
  0019a	48 85 c0	 test	 rax, rax
  0019d	74 1c		 je	 SHORT $onError$21422
  0019f	49 83 fc 0c	 cmp	 r12, 12
  001a3	7d 22		 jge	 SHORT $LN4@stringlib_@11
  001a5	49 8b 4e 70	 mov	 rcx, QWORD PTR [r14+112]
  001a9	49 ff c4	 inc	 r12
  001ac	4a 89 44 e1 f8	 mov	 QWORD PTR [rcx+r12*8-8], rax
  001b1	eb 2e		 jmp	 SHORT $LN6@stringlib_@11
$LN44@stringlib_@11:

; 73   : #ifndef STRINGLIB_MUTABLE
; 74   :         if (j == 0 && i == str_len && STRINGLIB_CHECK_EXACT(str_obj)) {
; 75   :             /* No whitespace in str_obj, so just use it as list[0] */
; 76   :             Py_INCREF(str_obj);
; 77   :             PyList_SET_ITEM(list, 0, (PyObject *)str_obj);
; 78   :             count++;
; 79   :             break;
; 80   :         }
; 81   : #endif
; 82   :         SPLIT_ADD(str, j, i);

  001b3	48 8b ce	 mov	 rcx, rsi
$LN58@stringlib_@11:
  001b6	e8 00 00 00 00	 call	 _Py_DecRef
$onError$21422:

; 95   : 
; 96   :   onError:
; 97   :     Py_DECREF(list);

  001bb	49 8b ce	 mov	 rcx, r14
  001be	e8 00 00 00 00	 call	 _Py_DecRef

; 98   :     return NULL;

  001c3	33 c0		 xor	 eax, eax
  001c5	eb 21		 jmp	 SHORT $LN56@stringlib_@11
$LN4@stringlib_@11:

; 91   :             SPLIT_ADD(str, i, str_len);

  001c7	48 8b d0	 mov	 rdx, rax
  001ca	49 8b ce	 mov	 rcx, r14
  001cd	e8 00 00 00 00	 call	 PyList_Append
  001d2	48 8b cb	 mov	 rcx, rbx
  001d5	85 c0		 test	 eax, eax
  001d7	75 dd		 jne	 SHORT $LN58@stringlib_@11
  001d9	e8 00 00 00 00	 call	 _Py_DecRef
  001de	49 ff c4	 inc	 r12
$LN6@stringlib_@11:

; 92   :     }
; 93   :     FIX_PREALLOC_SIZE(list);

  001e1	4d 89 66 60	 mov	 QWORD PTR [r14+96], r12

; 94   :     return list;

  001e5	49 8b c6	 mov	 rax, r14
$LN56@stringlib_@11:
  001e8	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  001ed	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  001f2	4c 8b 7c 24 70	 mov	 r15, QWORD PTR [rsp+112]

; 99   : }

  001f7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001fb	41 5e		 pop	 r14
  001fd	41 5d		 pop	 r13
  001ff	41 5c		 pop	 r12
  00201	5f		 pop	 rdi
  00202	5d		 pop	 rbp
  00203	c3		 ret	 0
stringlib_split_whitespace ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$stringlib_split_char DD imagerel stringlib_split_char
	DD	imagerel stringlib_split_char+76
	DD	imagerel $unwind$stringlib_split_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$stringlib_split_char DD imagerel stringlib_split_char+76
	DD	imagerel stringlib_split_char+404
	DD	imagerel $chain$1$stringlib_split_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$stringlib_split_char DD imagerel stringlib_split_char+404
	DD	imagerel stringlib_split_char+430
	DD	imagerel $chain$3$stringlib_split_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$stringlib_split_char DD 040021H
	DD	0dc400H
	DD	0c3400H
	DD	imagerel stringlib_split_char
	DD	imagerel stringlib_split_char+76
	DD	imagerel $unwind$stringlib_split_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$stringlib_split_char DD 040d21H
	DD	0dc40dH
	DD	0c3405H
	DD	imagerel stringlib_split_char
	DD	imagerel stringlib_split_char+76
	DD	imagerel $unwind$stringlib_split_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_split_char DD 081101H
	DD	0e5411H
	DD	0f00d5211H
	DD	0d009e00bH
	DD	060067007H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT stringlib_split_char
_TEXT	SEGMENT
str$ = 96
str_len$ = 104
ch$ = 112
maxcount$ = 120
stringlib_split_char PROC				; COMDAT

; 106  : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 107  :     Py_ssize_t i, j, count=0;

  00011	33 ed		 xor	 ebp, ebp
  00013	4c 8b e9	 mov	 r13, rcx
  00016	4d 8b f9	 mov	 r15, r9
  00019	45 0f b6 f0	 movzx	 r14d, r8b
  0001d	48 8b fa	 mov	 rdi, rdx

; 108  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00020	8d 4d 0c	 lea	 ecx, QWORD PTR [rbp+12]
  00023	49 83 f9 0c	 cmp	 r9, 12
  00027	7d 04		 jge	 SHORT $LN22@stringlib_@12
  00029	49 8d 49 01	 lea	 rcx, QWORD PTR [r9+1]
$LN22@stringlib_@12:
  0002d	e8 00 00 00 00	 call	 PyList_New
  00032	48 8b f0	 mov	 rsi, rax

; 109  :     PyObject *sub;
; 110  : 
; 111  :     if (list == NULL)

  00035	48 85 c0	 test	 rax, rax
  00038	75 12		 jne	 SHORT $LN18@stringlib_@12

; 142  : }

  0003a	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	41 5f		 pop	 r15
  00045	41 5e		 pop	 r14
  00047	41 5d		 pop	 r13
  00049	5f		 pop	 rdi
  0004a	5e		 pop	 rsi
  0004b	c3		 ret	 0
$LN18@stringlib_@12:
  0004c	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx

; 112  :         return NULL;
; 113  : 
; 114  :     i = j = 0;

  00051	48 8b cd	 mov	 rcx, rbp
  00054	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  00059	48 8b dd	 mov	 rbx, rbp

; 115  :     while ((j < str_len) && (maxcount-- > 0)) {

  0005c	48 85 ff	 test	 rdi, rdi
  0005f	7e 6b		 jle	 SHORT $LN16@stringlib_@12
$LL17@stringlib_@12:
  00061	49 8b c7	 mov	 rax, r15
  00064	49 ff cf	 dec	 r15
  00067	48 85 c0	 test	 rax, rax
  0006a	7e 60		 jle	 SHORT $LN16@stringlib_@12

; 116  :         for(; j < str_len; j++) {

  0006c	48 3b df	 cmp	 rbx, rdi
  0006f	7d 5b		 jge	 SHORT $LN16@stringlib_@12
$LL15@stringlib_@12:

; 117  :             /* I found that using memchr makes no difference */
; 118  :             if (str[j] == ch) {

  00071	46 38 34 2b	 cmp	 BYTE PTR [rbx+r13], r14b
  00075	74 0a		 je	 SHORT $LN36@stringlib_@12

; 116  :         for(; j < str_len; j++) {

  00077	48 ff c3	 inc	 rbx
  0007a	48 3b df	 cmp	 rbx, rdi
  0007d	7c f2		 jl	 SHORT $LL15@stringlib_@12
  0007f	eb 4b		 jmp	 SHORT $LN16@stringlib_@12
$LN36@stringlib_@12:

; 119  :                 SPLIT_ADD(str, i, j);

  00081	48 8b d3	 mov	 rdx, rbx
  00084	48 2b d1	 sub	 rdx, rcx
  00087	49 03 cd	 add	 rcx, r13
  0008a	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0008f	4c 8b e0	 mov	 r12, rax
  00092	48 85 c0	 test	 rax, rax
  00095	74 7b		 je	 SHORT $onError$21477
  00097	48 83 fd 0c	 cmp	 rbp, 12
  0009b	7d 0a		 jge	 SHORT $LN10@stringlib_@12
  0009d	48 8b 4e 70	 mov	 rcx, QWORD PTR [rsi+112]
  000a1	48 89 04 e9	 mov	 QWORD PTR [rcx+rbp*8], rax
  000a5	eb 17		 jmp	 SHORT $LN7@stringlib_@12
$LN10@stringlib_@12:
  000a7	48 8b d0	 mov	 rdx, rax
  000aa	48 8b ce	 mov	 rcx, rsi
  000ad	e8 00 00 00 00	 call	 PyList_Append
  000b2	49 8b cc	 mov	 rcx, r12
  000b5	85 c0		 test	 eax, eax
  000b7	75 54		 jne	 SHORT $LN38@stringlib_@12
  000b9	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@stringlib_@12:

; 120  :                 i = j = j + 1;

  000be	48 ff c3	 inc	 rbx
  000c1	48 ff c5	 inc	 rbp
  000c4	48 8b cb	 mov	 rcx, rbx
  000c7	48 3b df	 cmp	 rbx, rdi
  000ca	7c 95		 jl	 SHORT $LL17@stringlib_@12
$LN16@stringlib_@12:

; 121  :                 break;
; 122  :             }
; 123  :         }
; 124  :     }
; 125  : #ifndef STRINGLIB_MUTABLE
; 126  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {
; 127  :         /* ch not in str_obj, so just use str_obj as list[0] */
; 128  :         Py_INCREF(str_obj);
; 129  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);
; 130  :         count++;
; 131  :     } else
; 132  : #endif
; 133  :     if (i <= str_len) {

  000cc	48 3b cf	 cmp	 rcx, rdi
  000cf	0f 8f 9c 00 00
	00		 jg	 $LN6@stringlib_@12

; 134  :         SPLIT_ADD(str, i, str_len);

  000d5	48 2b f9	 sub	 rdi, rcx
  000d8	49 03 cd	 add	 rcx, r13
  000db	48 8b d7	 mov	 rdx, rdi
  000de	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000e3	48 8b d8	 mov	 rbx, rax
  000e6	48 85 c0	 test	 rax, rax
  000e9	74 27		 je	 SHORT $onError$21477
  000eb	48 83 fd 0c	 cmp	 rbp, 12
  000ef	7d 0a		 jge	 SHORT $LN4@stringlib_@12
  000f1	48 8b 4e 70	 mov	 rcx, QWORD PTR [rsi+112]
  000f5	48 89 04 e9	 mov	 QWORD PTR [rcx+rbp*8], rax
  000f9	eb 73		 jmp	 SHORT $LN1@stringlib_@12
$LN4@stringlib_@12:
  000fb	48 8b d0	 mov	 rdx, rax
  000fe	48 8b ce	 mov	 rcx, rsi
  00101	e8 00 00 00 00	 call	 PyList_Append
  00106	48 8b cb	 mov	 rcx, rbx
  00109	85 c0		 test	 eax, eax
  0010b	74 5c		 je	 SHORT $LN2@stringlib_@12
$LN38@stringlib_@12:
  0010d	e8 00 00 00 00	 call	 _Py_DecRef
$onError$21477:

; 138  : 
; 139  :   onError:
; 140  :     Py_DECREF(list);

  00112	e8 00 00 00 00	 call	 _Py_PXCTX
  00117	85 c0		 test	 eax, eax
  00119	0f 85 8b 00 00
	00		 jne	 $LN33@stringlib_@12
  0011f	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  00123	a8 20		 test	 al, 32			; 00000020H
  00125	75 7b		 jne	 SHORT $LN27@stringlib_@12
  00127	84 c0		 test	 al, al
  00129	78 77		 js	 SHORT $LN27@stringlib_@12
  0012b	a8 02		 test	 al, 2
  0012d	75 7b		 jne	 SHORT $LN33@stringlib_@12
  0012f	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  00133	75 75		 jne	 SHORT $LN33@stringlib_@12
  00135	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0013c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00143	4c 8b ce	 mov	 r9, rsi
  00146	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0014c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00154	e8 00 00 00 00	 call	 _PyParallel_Guard
  00159	48 8b ce	 mov	 rcx, rsi
  0015c	85 c0		 test	 eax, eax
  0015e	74 34		 je	 SHORT $LN32@stringlib_@12
  00160	e8 00 00 00 00	 call	 _Px_Dealloc

; 141  :     return NULL;

  00165	33 c0		 xor	 eax, eax
  00167	eb 0f		 jmp	 SHORT $LN43@stringlib_@12
$LN2@stringlib_@12:

; 134  :         SPLIT_ADD(str, i, str_len);

  00169	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@stringlib_@12:
  0016e	48 ff c5	 inc	 rbp
$LN6@stringlib_@12:

; 135  :     }
; 136  :     FIX_PREALLOC_SIZE(list);

  00171	48 89 6e 60	 mov	 QWORD PTR [rsi+96], rbp

; 137  :     return list;

  00175	48 8b c6	 mov	 rax, rsi
$LN43@stringlib_@12:

; 142  : }

  00178	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0017d	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  00182	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00187	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0018b	41 5f		 pop	 r15
  0018d	41 5e		 pop	 r14
  0018f	41 5d		 pop	 r13
  00191	5f		 pop	 rdi
  00192	5e		 pop	 rsi
  00193	c3		 ret	 0

; 138  : 
; 139  :   onError:
; 140  :     Py_DECREF(list);

$LN32@stringlib_@12:
  00194	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00198	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 141  :     return NULL;

  0019e	33 c0		 xor	 eax, eax
  001a0	eb d6		 jmp	 SHORT $LN43@stringlib_@12

; 138  : 
; 139  :   onError:
; 140  :     Py_DECREF(list);

$LN27@stringlib_@12:
  001a2	48 8b ce	 mov	 rcx, rsi
  001a5	e8 00 00 00 00	 call	 Px_DecRef
$LN33@stringlib_@12:

; 141  :     return NULL;

  001aa	33 c0		 xor	 eax, eax
  001ac	eb ca		 jmp	 SHORT $LN43@stringlib_@12
stringlib_split_char ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$stringlib_split DD imagerel stringlib_split
	DD	imagerel stringlib_split+107
	DD	imagerel $unwind$stringlib_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$stringlib_split DD imagerel stringlib_split+107
	DD	imagerel stringlib_split+165
	DD	imagerel $chain$1$stringlib_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$stringlib_split DD imagerel stringlib_split+165
	DD	imagerel stringlib_split+817
	DD	imagerel $chain$3$stringlib_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$stringlib_split DD imagerel stringlib_split+817
	DD	imagerel stringlib_split+838
	DD	imagerel $chain$4$stringlib_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$stringlib_split DD imagerel stringlib_split+838
	DD	imagerel stringlib_split+881
	DD	imagerel $chain$6$stringlib_split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$stringlib_split DD 080021H
	DD	08e400H
	DD	09d400H
	DD	0a7400H
	DD	0123400H
	DD	imagerel stringlib_split
	DD	imagerel stringlib_split+107
	DD	imagerel $unwind$stringlib_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$stringlib_split DD 021H
	DD	imagerel stringlib_split+107
	DD	imagerel stringlib_split+165
	DD	imagerel $chain$1$stringlib_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$stringlib_split DD 040f21H
	DD	08e40fH
	DD	0123408H
	DD	imagerel stringlib_split+107
	DD	imagerel stringlib_split+165
	DD	imagerel $chain$1$stringlib_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$stringlib_split DD 041721H
	DD	09d417H
	DD	0a7405H
	DD	imagerel stringlib_split
	DD	imagerel stringlib_split+107
	DD	imagerel $unwind$stringlib_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_split DD 051401H
	DD	0f010a214H
	DD	0600cc00eH
	DD	0500bH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT stringlib_split
_TEXT	SEGMENT
count$1$ = 32
i$1$ = 40
maxcount$1$ = 48
str$ = 128
str_len$ = 136
sep$ = 144
list$1$ = 152
sep_len$ = 152
maxcount$ = 160
stringlib_split PROC					; COMDAT

; 149  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	41 54		 push	 r12
  0000e	41 57		 push	 r15
  00010	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 150  :     Py_ssize_t i, j, pos, count=0;

  00014	45 33 e4	 xor	 r12d, r12d
  00017	49 8b f1	 mov	 rsi, r9
  0001a	4d 8b f8	 mov	 r15, r8
  0001d	48 8b ea	 mov	 rbp, rdx
  00020	4c 89 64 24 20	 mov	 QWORD PTR count$1$[rsp], r12

; 151  :     PyObject *list, *sub;
; 152  : 
; 153  :     if (sep_len == 0) {

  00025	4d 85 c9	 test	 r9, r9
  00028	75 20		 jne	 SHORT $LN17@stringlib_@13

; 154  :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0002a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00038	e8 00 00 00 00	 call	 PyErr_SetString

; 155  :         return NULL;

  0003d	33 c0		 xor	 eax, eax

; 190  : }

  0003f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00043	41 5f		 pop	 r15
  00045	41 5c		 pop	 r12
  00047	5e		 pop	 rsi
  00048	5d		 pop	 rbp
  00049	c3		 ret	 0
$LN17@stringlib_@13:

; 156  :     }
; 157  :     else if (sep_len == 1)

  0004a	49 83 f9 01	 cmp	 r9, 1
  0004e	75 1b		 jne	 SHORT $LN15@stringlib_@13

; 158  :         return STRINGLIB(split_char)(str_obj, str, str_len, sep[0], maxcount);

  00050	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR maxcount$[rsp]
  00058	45 0f b6 00	 movzx	 r8d, BYTE PTR [r8]

; 190  : }

  0005c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00060	41 5f		 pop	 r15
  00062	41 5c		 pop	 r12
  00064	5e		 pop	 rsi
  00065	5d		 pop	 rbp
  00066	e9 00 00 00 00	 jmp	 stringlib_split_char
$LN15@stringlib_@13:
  0006b	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi

; 159  : 
; 160  :     list = PyList_New(PREALLOC_SIZE(maxcount));

  00070	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR maxcount$[rsp]
  00078	b9 0c 00 00 00	 mov	 ecx, 12
  0007d	4c 89 6c 24 48	 mov	 QWORD PTR [rsp+72], r13
  00082	48 83 ff 0c	 cmp	 rdi, 12
  00086	7d 04		 jge	 SHORT $LN21@stringlib_@13
  00088	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
$LN21@stringlib_@13:
  0008c	e8 00 00 00 00	 call	 PyList_New
  00091	4c 8b e8	 mov	 r13, rax
  00094	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR list$1$[rsp], rax

; 161  :     if (list == NULL)

  0009c	48 85 c0	 test	 rax, rax
  0009f	0f 84 8c 02 00
	00		 je	 $LN119@stringlib_@13
$LN14@stringlib_@13:
  000a5	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx

; 162  :         return NULL;
; 163  : 
; 164  :     i = j = 0;

  000ad	33 db		 xor	 ebx, ebx
  000af	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  000b4	48 89 5c 24 28	 mov	 QWORD PTR i$1$[rsp], rbx

; 165  :     while (maxcount-- > 0) {

  000b9	48 85 ff	 test	 rdi, rdi
  000bc	0f 8e 90 00 00
	00		 jle	 $LN108@stringlib_@13
$LL13@stringlib_@13:

; 166  :         pos = FASTSEARCH(str+i, str_len-i, sep, sep_len, -1, FAST_SEARCH);

  000c2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  000ca	48 8b c5	 mov	 rax, rbp
  000cd	48 ff cf	 dec	 rdi
  000d0	48 2b c3	 sub	 rax, rbx
  000d3	48 89 7c 24 30	 mov	 QWORD PTR maxcount$1$[rsp], rdi
  000d8	48 8d 2c 0b	 lea	 rbp, QWORD PTR [rbx+rcx]
  000dc	4c 8b f0	 mov	 r14, rax
  000df	4c 2b f6	 sub	 r14, rsi
  000e2	78 6e		 js	 SHORT $LN108@stringlib_@13
  000e4	48 83 fe 01	 cmp	 rsi, 1
  000e8	0f 8f bb 00 00
	00		 jg	 $LN80@stringlib_@13
  000ee	48 85 f6	 test	 rsi, rsi
  000f1	7e 5f		 jle	 SHORT $LN108@stringlib_@13
  000f3	48 83 f8 0a	 cmp	 rax, 10
  000f7	7e 32		 jle	 SHORT $LN78@stringlib_@13
  000f9	4c 8d 04 28	 lea	 r8, QWORD PTR [rax+rbp]
  000fd	49 3b e8	 cmp	 rbp, r8
  00100	73 18		 jae	 SHORT $LN88@stringlib_@13
  00102	41 0f b6 17	 movzx	 edx, BYTE PTR [r15]
  00106	4c 2b c5	 sub	 r8, rbp
  00109	48 8b cd	 mov	 rcx, rbp
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00112	4c 8b d8	 mov	 r11, rax
  00115	48 85 c0	 test	 rax, rax
  00118	75 09		 jne	 SHORT $LN87@stringlib_@13
$LN88@stringlib_@13:
  0011a	49 83 cb ff	 or	 r11, -1
  0011e	e9 74 01 00 00	 jmp	 $LN83@stringlib_@13
$LN87@stringlib_@13:
  00123	4c 2b dd	 sub	 r11, rbp
  00126	e9 6c 01 00 00	 jmp	 $LN83@stringlib_@13
$LN78@stringlib_@13:
  0012b	45 33 db	 xor	 r11d, r11d
  0012e	48 85 c0	 test	 rax, rax
  00131	7e 1f		 jle	 SHORT $LN108@stringlib_@13
  00133	41 0f b6 0f	 movzx	 ecx, BYTE PTR [r15]
  00137	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL69@stringlib_@13:
  00140	41 38 0c 2b	 cmp	 BYTE PTR [r11+rbp], cl
  00144	0f 84 4d 01 00
	00		 je	 $LN83@stringlib_@13
  0014a	49 ff c3	 inc	 r11
  0014d	4c 3b d8	 cmp	 r11, rax
  00150	7c ee		 jl	 SHORT $LL69@stringlib_@13
$LN108@stringlib_@13:

; 172  :     }
; 173  : #ifndef STRINGLIB_MUTABLE
; 174  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {
; 175  :         /* No match in str_obj, so just use it as list[0] */
; 176  :         Py_INCREF(str_obj);
; 177  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);
; 178  :         count++;
; 179  :     } else
; 180  : #endif
; 181  :     {
; 182  :         SPLIT_ADD(str, i, str_len);

  00152	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR str$[rsp]
  0015a	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR str_len$[rsp]
  00162	4a 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+r8]
  00166	48 2b d3	 sub	 rdx, rbx
  00169	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0016e	48 8b d8	 mov	 rbx, rax
  00171	48 85 c0	 test	 rax, rax
  00174	0f 84 98 01 00
	00		 je	 $LN117@stringlib_@13
  0017a	48 8b 7c 24 20	 mov	 rdi, QWORD PTR count$1$[rsp]
  0017f	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR list$1$[rsp]
  00187	48 83 ff 0c	 cmp	 rdi, 12
  0018b	0f 8d b5 01 00
	00		 jge	 $LN4@stringlib_@13
  00191	48 8b 4e 70	 mov	 rcx, QWORD PTR [rsi+112]
  00195	48 89 04 f9	 mov	 QWORD PTR [rcx+rdi*8], rax
  00199	48 8d 47 01	 lea	 rax, QWORD PTR [rdi+1]

; 183  :     }
; 184  :     FIX_PREALLOC_SIZE(list);

  0019d	48 89 46 60	 mov	 QWORD PTR [rsi+96], rax

; 185  :     return list;

  001a1	48 8b c6	 mov	 rax, rsi
  001a4	e9 7b 01 00 00	 jmp	 $LN121@stringlib_@13

; 166  :         pos = FASTSEARCH(str+i, str_len-i, sep, sep_len, -1, FAST_SEARCH);

$LN80@stringlib_@13:
  001a9	48 8d 7e ff	 lea	 rdi, QWORD PTR [rsi-1]
  001ad	45 33 e4	 xor	 r12d, r12d
  001b0	4c 8d 6f ff	 lea	 r13, QWORD PTR [rdi-1]
  001b4	48 85 ff	 test	 rdi, rdi
  001b7	7e 42		 jle	 SHORT $LN57@stringlib_@13
  001b9	42 0f b6 1c 3f	 movzx	 ebx, BYTE PTR [rdi+r15]
  001be	4d 8b cf	 mov	 r9, r15
  001c1	4d 8b d5	 mov	 r10, r13
  001c4	4c 8b df	 mov	 r11, rdi
  001c7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL59@stringlib_@13:
  001d0	45 0f be 01	 movsx	 r8d, BYTE PTR [r9]
  001d4	ba 01 00 00 00	 mov	 edx, 1
  001d9	41 8b c8	 mov	 ecx, r8d
  001dc	83 e1 1f	 and	 ecx, 31
  001df	d3 e2		 shl	 edx, cl
  001e1	44 0b e2	 or	 r12d, edx
  001e4	44 3a c3	 cmp	 r8b, bl
  001e7	4d 0f 44 ea	 cmove	 r13, r10
  001eb	49 ff c1	 inc	 r9
  001ee	49 ff ca	 dec	 r10
  001f1	49 ff cb	 dec	 r11
  001f4	75 da		 jne	 SHORT $LL59@stringlib_@13
  001f6	48 8b 5c 24 28	 mov	 rbx, QWORD PTR i$1$[rsp]
$LN57@stringlib_@13:
  001fb	42 0f be 0c 3f	 movsx	 ecx, BYTE PTR [rdi+r15]
  00200	ba 01 00 00 00	 mov	 edx, 1
  00205	45 33 db	 xor	 r11d, r11d
  00208	83 e1 1f	 and	 ecx, 31
  0020b	d3 e2		 shl	 edx, cl
  0020d	44 0b e2	 or	 r12d, edx
  00210	4d 85 f6	 test	 r14, r14
  00213	0f 88 39 ff ff
	ff		 js	 $LN108@stringlib_@13
  00219	45 0f b6 54 37
	ff		 movzx	 r10d, BYTE PTR [r15+rsi-1]
  0021f	4c 8d 0c 2e	 lea	 r9, QWORD PTR [rsi+rbp]
$LL55@stringlib_@13:
  00223	47 38 54 19 ff	 cmp	 BYTE PTR [r9+r11-1], r10b
  00228	75 42		 jne	 SHORT $LN52@stringlib_@13
  0022a	33 d2		 xor	 edx, edx
  0022c	48 85 ff	 test	 rdi, rdi
  0022f	7e 23		 jle	 SHORT $LN115@stringlib_@13
  00231	4c 8b c5	 mov	 r8, rbp
  00234	49 8b cf	 mov	 rcx, r15
  00237	4d 2b c7	 sub	 r8, r15
  0023a	4d 03 c3	 add	 r8, r11
  0023d	0f 1f 00	 npad	 3
$LL51@stringlib_@13:
  00240	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00243	41 38 04 08	 cmp	 BYTE PTR [r8+rcx], al
  00247	75 0b		 jne	 SHORT $LN115@stringlib_@13
  00249	48 ff c2	 inc	 rdx
  0024c	48 ff c1	 inc	 rcx
  0024f	48 3b d7	 cmp	 rdx, rdi
  00252	7c ec		 jl	 SHORT $LL51@stringlib_@13
$LN115@stringlib_@13:
  00254	48 3b d7	 cmp	 rdx, rdi
  00257	74 31		 je	 SHORT $LN100@stringlib_@13
  00259	43 0f be 04 19	 movsx	 eax, BYTE PTR [r9+r11]
  0025e	83 e0 1f	 and	 eax, 31
  00261	41 0f a3 c4	 bt	 r12d, eax
  00265	73 13		 jae	 SHORT $LN122@stringlib_@13
  00267	4d 03 dd	 add	 r11, r13
  0026a	eb 11		 jmp	 SHORT $LN54@stringlib_@13
$LN52@stringlib_@13:
  0026c	43 0f be 04 19	 movsx	 eax, BYTE PTR [r9+r11]
  00271	83 e0 1f	 and	 eax, 31
  00274	41 0f a3 c4	 bt	 r12d, eax
  00278	72 03		 jb	 SHORT $LN54@stringlib_@13
$LN122@stringlib_@13:
  0027a	4c 03 de	 add	 r11, rsi
$LN54@stringlib_@13:
  0027d	49 ff c3	 inc	 r11
  00280	4d 3b de	 cmp	 r11, r14
  00283	7e 9e		 jle	 SHORT $LL55@stringlib_@13
  00285	e9 c8 fe ff ff	 jmp	 $LN108@stringlib_@13
$LN100@stringlib_@13:
  0028a	4c 8b 64 24 20	 mov	 r12, QWORD PTR count$1$[rsp]
  0028f	4c 8b ac 24 98
	00 00 00	 mov	 r13, QWORD PTR list$1$[rsp]
$LN83@stringlib_@13:

; 167  :         if (pos < 0)

  00297	4d 85 db	 test	 r11, r11
  0029a	0f 88 b2 fe ff
	ff		 js	 $LN108@stringlib_@13

; 168  :             break;
; 169  :         j = i + pos;

  002a0	49 8d 3c 1b	 lea	 rdi, QWORD PTR [r11+rbx]

; 170  :         SPLIT_ADD(str, i, j);

  002a4	48 8b cd	 mov	 rcx, rbp
  002a7	48 8b d7	 mov	 rdx, rdi
  002aa	48 2b d3	 sub	 rdx, rbx
  002ad	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  002b2	48 8b d8	 mov	 rbx, rax
  002b5	48 85 c0	 test	 rax, rax
  002b8	74 58		 je	 SHORT $LN117@stringlib_@13
  002ba	49 83 fc 0c	 cmp	 r12, 12
  002be	7d 0a		 jge	 SHORT $LN9@stringlib_@13
  002c0	49 8b 4d 70	 mov	 rcx, QWORD PTR [r13+112]
  002c4	4a 89 04 e1	 mov	 QWORD PTR [rcx+r12*8], rax
  002c8	eb 17		 jmp	 SHORT $LN6@stringlib_@13
$LN9@stringlib_@13:
  002ca	48 8b d0	 mov	 rdx, rax
  002cd	49 8b cd	 mov	 rcx, r13
  002d0	e8 00 00 00 00	 call	 PyList_Append
  002d5	48 8b cb	 mov	 rcx, rbx
  002d8	85 c0		 test	 eax, eax
  002da	75 31		 jne	 SHORT $LN103@stringlib_@13
  002dc	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@stringlib_@13:

; 171  :         i = j + sep_len;

  002e1	48 8d 1c 37	 lea	 rbx, QWORD PTR [rdi+rsi]
  002e5	48 8b 7c 24 30	 mov	 rdi, QWORD PTR maxcount$1$[rsp]
  002ea	49 ff c4	 inc	 r12
  002ed	4c 89 64 24 20	 mov	 QWORD PTR count$1$[rsp], r12
  002f2	48 89 5c 24 28	 mov	 QWORD PTR i$1$[rsp], rbx
  002f7	48 85 ff	 test	 rdi, rdi
  002fa	0f 8e 52 fe ff
	ff		 jle	 $LN108@stringlib_@13

; 172  :     }
; 173  : #ifndef STRINGLIB_MUTABLE
; 174  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {
; 175  :         /* No match in str_obj, so just use it as list[0] */
; 176  :         Py_INCREF(str_obj);
; 177  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);
; 178  :         count++;
; 179  :     } else
; 180  : #endif
; 181  :     {
; 182  :         SPLIT_ADD(str, i, str_len);

  00300	48 8b ac 24 88
	00 00 00	 mov	 rbp, QWORD PTR str_len$[rsp]
  00308	e9 b5 fd ff ff	 jmp	 $LL13@stringlib_@13
$LN103@stringlib_@13:

; 170  :         SPLIT_ADD(str, i, j);

  0030d	e8 00 00 00 00	 call	 _Py_DecRef
$LN117@stringlib_@13:

; 171  :         i = j + sep_len;

  00312	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR list$1$[rsp]
$onError$21531:

; 186  : 
; 187  :   onError:
; 188  :     Py_DECREF(list);

  0031a	48 8b ce	 mov	 rcx, rsi
  0031d	e8 00 00 00 00	 call	 _Py_DecRef

; 189  :     return NULL;

  00322	33 c0		 xor	 eax, eax
$LN121@stringlib_@13:
  00324	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  0032c	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]
$LN119@stringlib_@13:
  00331	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00336	4c 8b 6c 24 48	 mov	 r13, QWORD PTR [rsp+72]

; 190  : }

  0033b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0033f	41 5f		 pop	 r15
  00341	41 5c		 pop	 r12
  00343	5e		 pop	 rsi
  00344	5d		 pop	 rbp
  00345	c3		 ret	 0
$LN4@stringlib_@13:

; 172  :     }
; 173  : #ifndef STRINGLIB_MUTABLE
; 174  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {
; 175  :         /* No match in str_obj, so just use it as list[0] */
; 176  :         Py_INCREF(str_obj);
; 177  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);
; 178  :         count++;
; 179  :     } else
; 180  : #endif
; 181  :     {
; 182  :         SPLIT_ADD(str, i, str_len);

  00346	48 8b d0	 mov	 rdx, rax
  00349	48 8b ce	 mov	 rcx, rsi
  0034c	e8 00 00 00 00	 call	 PyList_Append
  00351	48 8b cb	 mov	 rcx, rbx
  00354	85 c0		 test	 eax, eax
  00356	74 07		 je	 SHORT $LN2@stringlib_@13
  00358	e8 00 00 00 00	 call	 _Py_DecRef
  0035d	eb bb		 jmp	 SHORT $onError$21531
$LN2@stringlib_@13:
  0035f	e8 00 00 00 00	 call	 _Py_DecRef
  00364	48 8d 47 01	 lea	 rax, QWORD PTR [rdi+1]

; 183  :     }
; 184  :     FIX_PREALLOC_SIZE(list);

  00368	48 89 46 60	 mov	 QWORD PTR [rsi+96], rax

; 185  :     return list;

  0036c	48 8b c6	 mov	 rax, rsi
  0036f	eb b3		 jmp	 SHORT $LN121@stringlib_@13
stringlib_split ENDP
_TEXT	ENDS
EXTRN	PyList_Reverse:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$stringlib_rsplit_whitespace DD imagerel stringlib_rsplit_whitespace
	DD	imagerel stringlib_rsplit_whitespace+60
	DD	imagerel $unwind$stringlib_rsplit_whitespace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$stringlib_rsplit_whitespace DD imagerel stringlib_rsplit_whitespace+60
	DD	imagerel stringlib_rsplit_whitespace+500
	DD	imagerel $chain$1$stringlib_rsplit_whitespace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$stringlib_rsplit_whitespace DD imagerel stringlib_rsplit_whitespace+500
	DD	imagerel stringlib_rsplit_whitespace+520
	DD	imagerel $chain$2$stringlib_rsplit_whitespace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$stringlib_rsplit_whitespace DD 021H
	DD	imagerel stringlib_rsplit_whitespace
	DD	imagerel stringlib_rsplit_whitespace+60
	DD	imagerel $unwind$stringlib_rsplit_whitespace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$stringlib_rsplit_whitespace DD 040d21H
	DD	0be40dH
	DD	0a7405H
	DD	imagerel stringlib_rsplit_whitespace
	DD	imagerel stringlib_rsplit_whitespace+60
	DD	imagerel $unwind$stringlib_rsplit_whitespace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rsplit_whitespace DD 081301H
	DD	0d5413H
	DD	0c3413H
	DD	0d00f5213H
	DD	0600bc00dH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT stringlib_rsplit_whitespace
_TEXT	SEGMENT
str$ = 80
str_len$ = 88
maxcount$ = 96
stringlib_rsplit_whitespace PROC			; COMDAT

; 196  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 197  :     Py_ssize_t i, j, count=0;

  00013	33 ed		 xor	 ebp, ebp
  00015	48 8b f1	 mov	 rsi, rcx
  00018	4d 8b e0	 mov	 r12, r8
  0001b	48 8b da	 mov	 rbx, rdx

; 198  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  0001e	8d 4d 0c	 lea	 ecx, QWORD PTR [rbp+12]
  00021	49 83 f8 0c	 cmp	 r8, 12
  00025	7d 04		 jge	 SHORT $LN27@stringlib_@14
  00027	49 8d 48 01	 lea	 rcx, QWORD PTR [r8+1]
$LN27@stringlib_@14:
  0002b	e8 00 00 00 00	 call	 PyList_New
  00030	4c 8b e8	 mov	 r13, rax

; 199  :     PyObject *sub;
; 200  : 
; 201  :     if (list == NULL)

  00033	48 85 c0	 test	 rax, rax
  00036	0f 84 b8 01 00
	00		 je	 $LN24@stringlib_@14
$LN23@stringlib_@14:
  0003c	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi

; 202  :         return NULL;
; 203  : 
; 204  :     i = j = str_len - 1;

  00041	48 ff cb	 dec	 rbx
  00044	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14

; 205  :     while (maxcount-- > 0) {

  00049	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:_Py_ctype_table
  00050	4d 85 e4	 test	 r12, r12
  00053	0f 8e 04 01 00
	00		 jle	 $LN48@stringlib_@14
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL22@stringlib_@14:
  00060	49 ff cc	 dec	 r12

; 206  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  00063	48 85 db	 test	 rbx, rbx
  00066	0f 88 5f 01 00
	00		 js	 $LN7@stringlib_@14
  0006c	0f 1f 40 00	 npad	 4
$LL20@stringlib_@14:
  00070	0f b6 04 33	 movzx	 eax, BYTE PTR [rbx+rsi]
  00074	41 f6 04 86 08	 test	 BYTE PTR [r14+rax*4], 8
  00079	74 0a		 je	 SHORT $LN19@stringlib_@14

; 207  :             i--;

  0007b	48 ff cb	 dec	 rbx

; 206  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  0007e	79 f0		 jns	 SHORT $LL20@stringlib_@14
  00080	e9 46 01 00 00	 jmp	 $LN7@stringlib_@14
$LN19@stringlib_@14:

; 208  :         if (i < 0) break;

  00085	48 85 db	 test	 rbx, rbx
  00088	0f 88 3d 01 00
	00		 js	 $LN7@stringlib_@14

; 209  :         j = i; i--;

  0008e	48 8b d3	 mov	 rdx, rbx
  00091	48 ff cb	 dec	 rbx

; 210  :         while (i >= 0 && !STRINGLIB_ISSPACE(str[i]))

  00094	78 1a		 js	 SHORT $LN55@stringlib_@14
  00096	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL17@stringlib_@14:
  000a0	0f b6 04 33	 movzx	 eax, BYTE PTR [rbx+rsi]
  000a4	41 f6 04 86 08	 test	 BYTE PTR [r14+rax*4], 8
  000a9	75 05		 jne	 SHORT $LN55@stringlib_@14

; 211  :             i--;

  000ab	48 ff cb	 dec	 rbx

; 210  :         while (i >= 0 && !STRINGLIB_ISSPACE(str[i]))

  000ae	79 f0		 jns	 SHORT $LL17@stringlib_@14
$LN55@stringlib_@14:

; 212  : #ifndef STRINGLIB_MUTABLE
; 213  :         if (j == str_len - 1 && i < 0 && STRINGLIB_CHECK_EXACT(str_obj)) {
; 214  :             /* No whitespace in str_obj, so just use it as list[0] */
; 215  :             Py_INCREF(str_obj);
; 216  :             PyList_SET_ITEM(list, 0, (PyObject *)str_obj);
; 217  :             count++;
; 218  :             break;
; 219  :         }
; 220  : #endif
; 221  :         SPLIT_ADD(str, i + 1, j + 1);

  000b0	48 8d 4c 33 01	 lea	 rcx, QWORD PTR [rbx+rsi+1]
  000b5	48 2b d3	 sub	 rdx, rbx
  000b8	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000bd	48 8b f8	 mov	 rdi, rax
  000c0	48 85 c0	 test	 rax, rax
  000c3	0f 84 12 01 00
	00		 je	 $onError$21583
  000c9	48 83 fd 0c	 cmp	 rbp, 12
  000cd	7d 0a		 jge	 SHORT $LN14@stringlib_@14
  000cf	49 8b 4d 70	 mov	 rcx, QWORD PTR [r13+112]
  000d3	48 89 04 e9	 mov	 QWORD PTR [rcx+rbp*8], rax
  000d7	eb 78		 jmp	 SHORT $LN38@stringlib_@14
$LN14@stringlib_@14:
  000d9	48 8b d0	 mov	 rdx, rax
  000dc	49 8b cd	 mov	 rcx, r13
  000df	e8 00 00 00 00	 call	 PyList_Append
  000e4	85 c0		 test	 eax, eax
  000e6	0f 85 88 00 00
	00		 jne	 $LN45@stringlib_@14
  000ec	e8 00 00 00 00	 call	 _Py_PXCTX
  000f1	85 c0		 test	 eax, eax
  000f3	75 5c		 jne	 SHORT $LN38@stringlib_@14
  000f5	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000f9	a8 20		 test	 al, 32			; 00000020H
  000fb	75 4c		 jne	 SHORT $LN32@stringlib_@14
  000fd	84 c0		 test	 al, al
  000ff	78 48		 js	 SHORT $LN32@stringlib_@14
  00101	a8 02		 test	 al, 2
  00103	75 4c		 jne	 SHORT $LN38@stringlib_@14
  00105	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00109	75 46		 jne	 SHORT $LN38@stringlib_@14
  0010b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00112	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00119	4c 8b cf	 mov	 r9, rdi
  0011c	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00122	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0012a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0012f	48 8b cf	 mov	 rcx, rdi
  00132	85 c0		 test	 eax, eax
  00134	74 07		 je	 SHORT $LN37@stringlib_@14
  00136	e8 00 00 00 00	 call	 _Px_Dealloc
  0013b	eb 14		 jmp	 SHORT $LN38@stringlib_@14
$LN37@stringlib_@14:
  0013d	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00141	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00147	eb 08		 jmp	 SHORT $LN38@stringlib_@14
$LN32@stringlib_@14:
  00149	48 8b cf	 mov	 rcx, rdi
  0014c	e8 00 00 00 00	 call	 Px_DecRef
$LN38@stringlib_@14:
  00151	48 ff c5	 inc	 rbp
  00154	4d 85 e4	 test	 r12, r12
  00157	0f 8f 03 ff ff
	ff		 jg	 $LL22@stringlib_@14
$LN48@stringlib_@14:

; 222  :     }
; 223  : 
; 224  :     if (i >= 0) {

  0015d	48 85 db	 test	 rbx, rbx
  00160	78 69		 js	 SHORT $LN7@stringlib_@14
$LL9@stringlib_@14:

; 225  :         /* Only occurs when maxcount was reached */
; 226  :         /* Skip any remaining whitespace and copy to beginning of string */
; 227  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  00162	0f b6 04 33	 movzx	 eax, BYTE PTR [rbx+rsi]
  00166	41 f6 04 86 08	 test	 BYTE PTR [r14+rax*4], 8
  0016b	74 1b		 je	 SHORT $LN8@stringlib_@14

; 228  :             i--;

  0016d	48 ff cb	 dec	 rbx

; 225  :         /* Only occurs when maxcount was reached */
; 226  :         /* Skip any remaining whitespace and copy to beginning of string */
; 227  :         while (i >= 0 && STRINGLIB_ISSPACE(str[i]))

  00170	79 f0		 jns	 SHORT $LL9@stringlib_@14

; 229  :         if (i >= 0)

  00172	eb 57		 jmp	 SHORT $LN7@stringlib_@14
$LN45@stringlib_@14:

; 212  : #ifndef STRINGLIB_MUTABLE
; 213  :         if (j == str_len - 1 && i < 0 && STRINGLIB_CHECK_EXACT(str_obj)) {
; 214  :             /* No whitespace in str_obj, so just use it as list[0] */
; 215  :             Py_INCREF(str_obj);
; 216  :             PyList_SET_ITEM(list, 0, (PyObject *)str_obj);
; 217  :             count++;
; 218  :             break;
; 219  :         }
; 220  : #endif
; 221  :         SPLIT_ADD(str, i + 1, j + 1);

  00174	48 8b cf	 mov	 rcx, rdi
$LN58@stringlib_@14:
  00177	e8 00 00 00 00	 call	 _Py_DecRef

; 236  : 
; 237  :   onError:
; 238  :     Py_DECREF(list);

  0017c	49 8b cd	 mov	 rcx, r13
  0017f	e8 00 00 00 00	 call	 _Py_DecRef

; 239  :     return NULL;

  00184	33 c0		 xor	 eax, eax
  00186	eb 62		 jmp	 SHORT $LN57@stringlib_@14
$LN8@stringlib_@14:

; 229  :         if (i >= 0)

  00188	48 85 db	 test	 rbx, rbx
  0018b	78 3e		 js	 SHORT $LN7@stringlib_@14

; 230  :             SPLIT_ADD(str, 0, i + 1);

  0018d	48 8d 53 01	 lea	 rdx, QWORD PTR [rbx+1]
  00191	48 8b ce	 mov	 rcx, rsi
  00194	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00199	48 8b d8	 mov	 rbx, rax
  0019c	48 85 c0	 test	 rax, rax
  0019f	74 3a		 je	 SHORT $onError$21583
  001a1	48 83 fd 0c	 cmp	 rbp, 12
  001a5	7d 0a		 jge	 SHORT $LN5@stringlib_@14
  001a7	49 8b 4d 70	 mov	 rcx, QWORD PTR [r13+112]
  001ab	48 89 04 e9	 mov	 QWORD PTR [rcx+rbp*8], rax
  001af	eb 17		 jmp	 SHORT $LN2@stringlib_@14
$LN5@stringlib_@14:
  001b1	48 8b d0	 mov	 rdx, rax
  001b4	49 8b cd	 mov	 rcx, r13
  001b7	e8 00 00 00 00	 call	 PyList_Append
  001bc	48 8b cb	 mov	 rcx, rbx
  001bf	85 c0		 test	 eax, eax
  001c1	75 b4		 jne	 SHORT $LN58@stringlib_@14
  001c3	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@stringlib_@14:
  001c8	48 ff c5	 inc	 rbp
$LN7@stringlib_@14:

; 231  :     }
; 232  :     FIX_PREALLOC_SIZE(list);
; 233  :     if (PyList_Reverse(list) < 0)

  001cb	49 8b cd	 mov	 rcx, r13
  001ce	49 89 6d 60	 mov	 QWORD PTR [r13+96], rbp
  001d2	e8 00 00 00 00	 call	 PyList_Reverse
  001d7	85 c0		 test	 eax, eax
  001d9	79 0c		 jns	 SHORT $LN1@stringlib_@14
$onError$21583:

; 236  : 
; 237  :   onError:
; 238  :     Py_DECREF(list);

  001db	49 8b cd	 mov	 rcx, r13
  001de	e8 00 00 00 00	 call	 _Py_DecRef

; 239  :     return NULL;

  001e3	33 c0		 xor	 eax, eax
  001e5	eb 03		 jmp	 SHORT $LN57@stringlib_@14
$LN1@stringlib_@14:

; 234  :         goto onError;
; 235  :     return list;

  001e7	49 8b c5	 mov	 rax, r13
$LN57@stringlib_@14:
  001ea	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  001ef	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
$LN24@stringlib_@14:

; 240  : }

  001f4	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  001f9	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  001fe	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00202	41 5d		 pop	 r13
  00204	41 5c		 pop	 r12
  00206	5e		 pop	 rsi
  00207	c3		 ret	 0
stringlib_rsplit_whitespace ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$stringlib_rsplit_char DD imagerel stringlib_rsplit_char
	DD	imagerel stringlib_rsplit_char+74
	DD	imagerel $unwind$stringlib_rsplit_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$stringlib_rsplit_char DD imagerel stringlib_rsplit_char+74
	DD	imagerel stringlib_rsplit_char+407
	DD	imagerel $chain$0$stringlib_rsplit_char
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$stringlib_rsplit_char DD imagerel stringlib_rsplit_char+407
	DD	imagerel stringlib_rsplit_char+433
	DD	imagerel $chain$1$stringlib_rsplit_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$stringlib_rsplit_char DD 021H
	DD	imagerel stringlib_rsplit_char
	DD	imagerel stringlib_rsplit_char+74
	DD	imagerel $unwind$stringlib_rsplit_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$stringlib_rsplit_char DD 020521H
	DD	0a5405H
	DD	imagerel stringlib_rsplit_char
	DD	imagerel stringlib_rsplit_char+74
	DD	imagerel $unwind$stringlib_rsplit_char
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rsplit_char DD 0a1901H
	DD	0d7419H
	DD	0c6419H
	DD	0b3419H
	DD	0e0155219H
	DD	0c011d013H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT stringlib_rsplit_char
_TEXT	SEGMENT
str$ = 80
str_len$ = 88
ch$ = 96
maxcount$ = 104
stringlib_rsplit_char PROC				; COMDAT

; 247  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	41 55		 push	 r13
  00013	41 56		 push	 r14
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 248  :     Py_ssize_t i, j, count=0;

  00019	33 f6		 xor	 esi, esi
  0001b	4c 8b e1	 mov	 r12, rcx
  0001e	4d 8b f1	 mov	 r14, r9
  00021	45 0f b6 e8	 movzx	 r13d, r8b
  00025	48 8b da	 mov	 rbx, rdx

; 249  :     PyObject *list = PyList_New(PREALLOC_SIZE(maxcount));

  00028	8d 4e 0c	 lea	 ecx, QWORD PTR [rsi+12]
  0002b	49 83 f9 0c	 cmp	 r9, 12
  0002f	7d 04		 jge	 SHORT $LN23@stringlib_@15
  00031	49 8d 49 01	 lea	 rcx, QWORD PTR [r9+1]
$LN23@stringlib_@15:
  00035	e8 00 00 00 00	 call	 PyList_New
  0003a	48 8b f8	 mov	 rdi, rax

; 250  :     PyObject *sub;
; 251  : 
; 252  :     if (list == NULL)

  0003d	48 85 c0	 test	 rax, rax
  00040	0f 84 51 01 00
	00		 je	 $LN20@stringlib_@15
$LN19@stringlib_@15:

; 253  :         return NULL;
; 254  : 
; 255  :     i = j = str_len - 1;

  00046	48 8d 53 ff	 lea	 rdx, QWORD PTR [rbx-1]
  0004a	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0004f	48 8b da	 mov	 rbx, rdx

; 256  :     while ((i >= 0) && (maxcount-- > 0)) {

  00052	48 85 d2	 test	 rdx, rdx
  00055	78 71		 js	 SHORT $LN17@stringlib_@15
  00057	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL18@stringlib_@15:
  00060	49 8b c6	 mov	 rax, r14
  00063	49 ff ce	 dec	 r14
  00066	48 85 c0	 test	 rax, rax
  00069	7e 5d		 jle	 SHORT $LN17@stringlib_@15
  0006b	0f 1f 44 00 00	 npad	 5
$LL16@stringlib_@15:

; 258  :             if (str[i] == ch) {

  00070	46 38 2c 23	 cmp	 BYTE PTR [rbx+r12], r13b
  00074	74 07		 je	 SHORT $LN37@stringlib_@15

; 257  :         for(; i >= 0; i--) {

  00076	48 ff cb	 dec	 rbx
  00079	79 f5		 jns	 SHORT $LL16@stringlib_@15
  0007b	eb 4b		 jmp	 SHORT $LN17@stringlib_@15
$LN37@stringlib_@15:

; 259  :                 SPLIT_ADD(str, i + 1, j + 1);

  0007d	4a 8d 4c 23 01	 lea	 rcx, QWORD PTR [rbx+r12+1]
  00082	48 2b d3	 sub	 rdx, rbx
  00085	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0008a	48 8b e8	 mov	 rbp, rax
  0008d	48 85 c0	 test	 rax, rax
  00090	0f 84 8c 00 00
	00		 je	 $onError$21639
  00096	48 83 fe 0c	 cmp	 rsi, 12
  0009a	7d 0a		 jge	 SHORT $LN11@stringlib_@15
  0009c	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  000a0	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  000a4	eb 17		 jmp	 SHORT $LN8@stringlib_@15
$LN11@stringlib_@15:
  000a6	48 8b d0	 mov	 rdx, rax
  000a9	48 8b cf	 mov	 rcx, rdi
  000ac	e8 00 00 00 00	 call	 PyList_Append
  000b1	48 8b cd	 mov	 rcx, rbp
  000b4	85 c0		 test	 eax, eax
  000b6	75 4b		 jne	 SHORT $LN39@stringlib_@15
  000b8	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@stringlib_@15:
  000bd	48 ff c6	 inc	 rsi

; 260  :                 j = i = i - 1;

  000c0	48 ff cb	 dec	 rbx
  000c3	48 8b d3	 mov	 rdx, rbx
  000c6	79 98		 jns	 SHORT $LL18@stringlib_@15
$LN17@stringlib_@15:

; 261  :                 break;
; 262  :             }
; 263  :         }
; 264  :     }
; 265  : #ifndef STRINGLIB_MUTABLE
; 266  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {
; 267  :         /* ch not in str_obj, so just use str_obj as list[0] */
; 268  :         Py_INCREF(str_obj);
; 269  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);
; 270  :         count++;
; 271  :     } else
; 272  : #endif
; 273  :     if (j >= -1) {

  000c8	48 83 fa ff	 cmp	 rdx, -1
  000cc	7c 44		 jl	 SHORT $LN7@stringlib_@15

; 274  :         SPLIT_ADD(str, 0, j + 1);

  000ce	48 ff c2	 inc	 rdx
  000d1	49 8b cc	 mov	 rcx, r12
  000d4	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000d9	48 8b d8	 mov	 rbx, rax
  000dc	48 85 c0	 test	 rax, rax
  000df	74 41		 je	 SHORT $onError$21639
  000e1	48 83 fe 0c	 cmp	 rsi, 12
  000e5	7d 0a		 jge	 SHORT $LN5@stringlib_@15
  000e7	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  000eb	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  000ef	eb 1e		 jmp	 SHORT $LN2@stringlib_@15
$LN5@stringlib_@15:
  000f1	48 8b d0	 mov	 rdx, rax
  000f4	48 8b cf	 mov	 rcx, rdi
  000f7	e8 00 00 00 00	 call	 PyList_Append
  000fc	48 8b cb	 mov	 rcx, rbx
  000ff	85 c0		 test	 eax, eax
  00101	74 07		 je	 SHORT $LN3@stringlib_@15
$LN39@stringlib_@15:
  00103	e8 00 00 00 00	 call	 _Py_DecRef
  00108	eb 18		 jmp	 SHORT $onError$21639
$LN3@stringlib_@15:
  0010a	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@stringlib_@15:
  0010f	48 ff c6	 inc	 rsi
$LN7@stringlib_@15:

; 275  :     }
; 276  :     FIX_PREALLOC_SIZE(list);
; 277  :     if (PyList_Reverse(list) < 0)

  00112	48 8b cf	 mov	 rcx, rdi
  00115	48 89 77 60	 mov	 QWORD PTR [rdi+96], rsi
  00119	e8 00 00 00 00	 call	 PyList_Reverse
  0011e	85 c0		 test	 eax, eax
  00120	79 6d		 jns	 SHORT $LN1@stringlib_@15
$onError$21639:

; 280  : 
; 281  :   onError:
; 282  :     Py_DECREF(list);

  00122	e8 00 00 00 00	 call	 _Py_PXCTX
  00127	85 c0		 test	 eax, eax
  00129	75 60		 jne	 SHORT $LN34@stringlib_@15
  0012b	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0012f	a8 20		 test	 al, 32			; 00000020H
  00131	75 50		 jne	 SHORT $LN28@stringlib_@15
  00133	84 c0		 test	 al, al
  00135	78 4c		 js	 SHORT $LN28@stringlib_@15
  00137	a8 02		 test	 al, 2
  00139	75 50		 jne	 SHORT $LN34@stringlib_@15
  0013b	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0013f	75 4a		 jne	 SHORT $LN34@stringlib_@15
  00141	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0014f	4c 8b cf	 mov	 r9, rdi
  00152	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00158	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00160	e8 00 00 00 00	 call	 _PyParallel_Guard
  00165	48 8b cf	 mov	 rcx, rdi
  00168	85 c0		 test	 eax, eax
  0016a	74 09		 je	 SHORT $LN33@stringlib_@15
  0016c	e8 00 00 00 00	 call	 _Px_Dealloc

; 283  :     return NULL;

  00171	33 c0		 xor	 eax, eax
  00173	eb 1d		 jmp	 SHORT $LN43@stringlib_@15

; 280  : 
; 281  :   onError:
; 282  :     Py_DECREF(list);

$LN33@stringlib_@15:
  00175	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00179	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 283  :     return NULL;

  0017f	33 c0		 xor	 eax, eax
  00181	eb 0f		 jmp	 SHORT $LN43@stringlib_@15

; 280  : 
; 281  :   onError:
; 282  :     Py_DECREF(list);

$LN28@stringlib_@15:
  00183	48 8b cf	 mov	 rcx, rdi
  00186	e8 00 00 00 00	 call	 Px_DecRef
$LN34@stringlib_@15:

; 283  :     return NULL;

  0018b	33 c0		 xor	 eax, eax
  0018d	eb 03		 jmp	 SHORT $LN43@stringlib_@15
$LN1@stringlib_@15:

; 278  :         goto onError;
; 279  :     return list;

  0018f	48 8b c7	 mov	 rax, rdi
$LN43@stringlib_@15:
  00192	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
$LN20@stringlib_@15:

; 284  : }

  00197	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0019c	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  001a1	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  001a6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001aa	41 5e		 pop	 r14
  001ac	41 5d		 pop	 r13
  001ae	41 5c		 pop	 r12
  001b0	c3		 ret	 0
stringlib_rsplit_char ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$stringlib_rsplit DD imagerel stringlib_rsplit
	DD	imagerel stringlib_rsplit+111
	DD	imagerel $unwind$stringlib_rsplit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$stringlib_rsplit DD imagerel stringlib_rsplit+111
	DD	imagerel stringlib_rsplit+169
	DD	imagerel $chain$1$stringlib_rsplit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$stringlib_rsplit DD imagerel stringlib_rsplit+169
	DD	imagerel stringlib_rsplit+710
	DD	imagerel $chain$2$stringlib_rsplit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$stringlib_rsplit DD imagerel stringlib_rsplit+710
	DD	imagerel stringlib_rsplit+733
	DD	imagerel $chain$3$stringlib_rsplit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$stringlib_rsplit DD imagerel stringlib_rsplit+733
	DD	imagerel stringlib_rsplit+788
	DD	imagerel $chain$5$stringlib_rsplit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$stringlib_rsplit DD 060021H
	DD	06e400H
	DD	077400H
	DD	0e3400H
	DD	imagerel stringlib_rsplit
	DD	imagerel stringlib_rsplit+111
	DD	imagerel $unwind$stringlib_rsplit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$stringlib_rsplit DD 021H
	DD	imagerel stringlib_rsplit+111
	DD	imagerel stringlib_rsplit+169
	DD	imagerel $chain$1$stringlib_rsplit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$stringlib_rsplit DD 020521H
	DD	077405H
	DD	imagerel stringlib_rsplit+111
	DD	imagerel stringlib_rsplit+169
	DD	imagerel $chain$1$stringlib_rsplit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$stringlib_rsplit DD 041721H
	DD	06e417H
	DD	0e3405H
	DD	imagerel stringlib_rsplit
	DD	imagerel stringlib_rsplit+111
	DD	imagerel $unwind$stringlib_rsplit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rsplit DD 061101H
	DD	0f00d7211H
	DD	0c009d00bH
	DD	050066007H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT stringlib_rsplit
_TEXT	SEGMENT
count$1$ = 32
maxcount$1$ = 40
str$ = 112
str_len$ = 120
sep$ = 128
list$1$ = 136
sep_len$ = 136
maxcount$ = 144
stringlib_rsplit PROC					; COMDAT

; 291  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 57		 push	 r15
  0000d	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 292  :     Py_ssize_t j, pos, count=0;

  00011	45 33 ed	 xor	 r13d, r13d
  00014	49 8b f1	 mov	 rsi, r9
  00017	4d 8b e0	 mov	 r12, r8
  0001a	4c 8b fa	 mov	 r15, rdx
  0001d	48 8b e9	 mov	 rbp, rcx
  00020	4c 89 6c 24 20	 mov	 QWORD PTR count$1$[rsp], r13

; 293  :     PyObject *list, *sub;
; 294  : 
; 295  :     if (sep_len == 0) {

  00025	4d 85 c9	 test	 r9, r9
  00028	75 22		 jne	 SHORT $LN18@stringlib_@16

; 296  :         PyErr_SetString(PyExc_ValueError, "empty separator");

  0002a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@JDENDMBF@empty?5separator?$AA@
  00038	e8 00 00 00 00	 call	 PyErr_SetString

; 297  :         return NULL;

  0003d	33 c0		 xor	 eax, eax

; 333  : }

  0003f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00043	41 5f		 pop	 r15
  00045	41 5d		 pop	 r13
  00047	41 5c		 pop	 r12
  00049	5e		 pop	 rsi
  0004a	5d		 pop	 rbp
  0004b	c3		 ret	 0
$LN18@stringlib_@16:

; 298  :     }
; 299  :     else if (sep_len == 1)

  0004c	49 83 f9 01	 cmp	 r9, 1
  00050	75 1d		 jne	 SHORT $LN16@stringlib_@16

; 300  :         return STRINGLIB(rsplit_char)(str_obj, str, str_len, sep[0], maxcount);

  00052	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR maxcount$[rsp]
  0005a	45 0f b6 00	 movzx	 r8d, BYTE PTR [r8]

; 333  : }

  0005e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00062	41 5f		 pop	 r15
  00064	41 5d		 pop	 r13
  00066	41 5c		 pop	 r12
  00068	5e		 pop	 rsi
  00069	5d		 pop	 rbp
  0006a	e9 00 00 00 00	 jmp	 stringlib_rsplit_char
$LN16@stringlib_@16:
  0006f	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx

; 301  : 
; 302  :     list = PyList_New(PREALLOC_SIZE(maxcount));

  00074	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR maxcount$[rsp]
  0007c	b9 0c 00 00 00	 mov	 ecx, 12
  00081	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  00086	48 83 fb 0c	 cmp	 rbx, 12
  0008a	7d 04		 jge	 SHORT $LN22@stringlib_@16
  0008c	48 8d 4b 01	 lea	 rcx, QWORD PTR [rbx+1]
$LN22@stringlib_@16:
  00090	e8 00 00 00 00	 call	 PyList_New
  00095	4c 8b f0	 mov	 r14, rax
  00098	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR list$1$[rsp], rax

; 303  :     if (list == NULL)

  000a0	48 85 c0	 test	 rax, rax
  000a3	0f 84 1d 02 00
	00		 je	 $LN121@stringlib_@16
$LN15@stringlib_@16:
  000a9	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 304  :         return NULL;
; 305  : 
; 306  :     j = str_len;
; 307  :     while (maxcount-- > 0) {

  000ae	48 85 db	 test	 rbx, rbx
  000b1	7e 4f		 jle	 SHORT $LN109@stringlib_@16
  000b3	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL14@stringlib_@16:
  000c0	48 ff cb	 dec	 rbx
  000c3	48 89 5c 24 28	 mov	 QWORD PTR maxcount$1$[rsp], rbx

; 308  :         pos = FASTSEARCH(str, j, sep, sep_len, -1, FAST_RSEARCH);

  000c8	49 8b df	 mov	 rbx, r15
  000cb	48 2b de	 sub	 rbx, rsi
  000ce	78 32		 js	 SHORT $LN109@stringlib_@16
  000d0	48 83 fe 01	 cmp	 rsi, 1
  000d4	7f 67		 jg	 SHORT $LN81@stringlib_@16
  000d6	48 85 f6	 test	 rsi, rsi
  000d9	7e 27		 jle	 SHORT $LN109@stringlib_@16
  000db	49 8d 5f ff	 lea	 rbx, QWORD PTR [r15-1]
  000df	48 83 fb ff	 cmp	 rbx, -1
  000e3	7e 1d		 jle	 SHORT $LN109@stringlib_@16
  000e5	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  000ea	66 0f 1f 44 00
	00		 npad	 6
$LL65@stringlib_@16:
  000f0	38 04 2b	 cmp	 BYTE PTR [rbx+rbp], al
  000f3	0f 84 46 01 00
	00		 je	 $LN101@stringlib_@16
  000f9	48 ff cb	 dec	 rbx
  000fc	48 83 fb ff	 cmp	 rbx, -1
  00100	7f ee		 jg	 SHORT $LL65@stringlib_@16
$LN109@stringlib_@16:

; 313  :     }
; 314  : #ifndef STRINGLIB_MUTABLE
; 315  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {
; 316  :         /* No match in str_obj, so just use it as list[0] */
; 317  :         Py_INCREF(str_obj);
; 318  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);
; 319  :         count++;
; 320  :     } else
; 321  : #endif
; 322  :     {
; 323  :         SPLIT_ADD(str, 0, j);

  00102	49 8b d7	 mov	 rdx, r15
  00105	48 8b cd	 mov	 rcx, rbp
  00108	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0010d	48 8b d8	 mov	 rbx, rax
  00110	48 85 c0	 test	 rax, rax
  00113	0f 84 96 01 00
	00		 je	 $LN119@stringlib_@16
  00119	48 8b 7c 24 20	 mov	 rdi, QWORD PTR count$1$[rsp]
  0011e	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR list$1$[rsp]
  00126	48 83 ff 0c	 cmp	 rdi, 12
  0012a	0f 8d ad 01 00
	00		 jge	 $LN5@stringlib_@16
  00130	48 8b 4e 70	 mov	 rcx, QWORD PTR [rsi+112]
  00134	48 89 04 f9	 mov	 QWORD PTR [rcx+rdi*8], rax
  00138	e9 be 01 00 00	 jmp	 $LN2@stringlib_@16

; 308  :         pos = FASTSEARCH(str, j, sep, sep_len, -1, FAST_RSEARCH);

$LN81@stringlib_@16:
  0013d	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR sep$[rsp]
  00145	48 8d 7e ff	 lea	 rdi, QWORD PTR [rsi-1]
  00149	41 bd 01 00 00
	00		 mov	 r13d, 1
  0014f	45 0f be 32	 movsx	 r14d, BYTE PTR [r10]
  00153	4c 8d 67 ff	 lea	 r12, QWORD PTR [rdi-1]
  00157	41 8b ce	 mov	 ecx, r14d
  0015a	83 e1 1f	 and	 ecx, 31
  0015d	41 d3 e5	 shl	 r13d, cl
  00160	48 85 ff	 test	 rdi, rdi
  00163	7e 48		 jle	 SHORT $LN38@stringlib_@16
  00165	49 83 cb ff	 or	 r11, -1
  00169	4e 8d 0c 17	 lea	 r9, QWORD PTR [rdi+r10]
  0016d	4d 2b da	 sub	 r11, r10
  00170	4c 8b d7	 mov	 r10, rdi
  00173	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL40@stringlib_@16:
  00180	45 0f be 01	 movsx	 r8d, BYTE PTR [r9]
  00184	ba 01 00 00 00	 mov	 edx, 1
  00189	41 8b c8	 mov	 ecx, r8d
  0018c	83 e1 1f	 and	 ecx, 31
  0018f	d3 e2		 shl	 edx, cl
  00191	44 0b ea	 or	 r13d, edx
  00194	45 3a c6	 cmp	 r8b, r14b
  00197	75 04		 jne	 SHORT $LN39@stringlib_@16
  00199	4f 8d 24 0b	 lea	 r12, QWORD PTR [r11+r9]
$LN39@stringlib_@16:
  0019d	49 ff c9	 dec	 r9
  001a0	49 ff ca	 dec	 r10
  001a3	75 db		 jne	 SHORT $LL40@stringlib_@16
  001a5	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR sep$[rsp]
$LN38@stringlib_@16:
  001ad	4c 8b c3	 mov	 r8, rbx
  001b0	4d 2b c2	 sub	 r8, r10
  001b3	4c 03 c5	 add	 r8, rbp
$LL36@stringlib_@16:
  001b6	44 38 34 2b	 cmp	 BYTE PTR [rbx+rbp], r14b
  001ba	75 48		 jne	 SHORT $LN33@stringlib_@16
  001bc	48 8b d7	 mov	 rdx, rdi
  001bf	48 85 ff	 test	 rdi, rdi
  001c2	7e 20		 jle	 SHORT $LN116@stringlib_@16
  001c4	4a 8d 0c 17	 lea	 rcx, QWORD PTR [rdi+r10]
  001c8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL32@stringlib_@16:
  001d0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  001d3	41 38 04 08	 cmp	 BYTE PTR [r8+rcx], al
  001d7	75 0b		 jne	 SHORT $LN116@stringlib_@16
  001d9	48 ff ca	 dec	 rdx
  001dc	48 ff c9	 dec	 rcx
  001df	48 85 d2	 test	 rdx, rdx
  001e2	7f ec		 jg	 SHORT $LL32@stringlib_@16
$LN116@stringlib_@16:
  001e4	48 85 d2	 test	 rdx, rdx
  001e7	74 41		 je	 SHORT $LN117@stringlib_@16
  001e9	48 85 db	 test	 rbx, rbx
  001ec	7e 0e		 jle	 SHORT $LN27@stringlib_@16
  001ee	0f be 44 2b ff	 movsx	 eax, BYTE PTR [rbx+rbp-1]
  001f3	83 e0 1f	 and	 eax, 31
  001f6	41 0f a3 c5	 bt	 r13d, eax
  001fa	73 1b		 jae	 SHORT $LN123@stringlib_@16
$LN27@stringlib_@16:
  001fc	49 2b dc	 sub	 rbx, r12
  001ff	4d 2b c4	 sub	 r8, r12
  00202	eb 19		 jmp	 SHORT $LN35@stringlib_@16
$LN33@stringlib_@16:
  00204	48 85 db	 test	 rbx, rbx
  00207	7e 14		 jle	 SHORT $LN35@stringlib_@16
  00209	0f be 44 2b ff	 movsx	 eax, BYTE PTR [rbx+rbp-1]
  0020e	83 e0 1f	 and	 eax, 31
  00211	41 0f a3 c5	 bt	 r13d, eax
  00215	72 06		 jb	 SHORT $LN35@stringlib_@16
$LN123@stringlib_@16:
  00217	48 2b de	 sub	 rbx, rsi
  0021a	4c 2b c6	 sub	 r8, rsi
$LN35@stringlib_@16:
  0021d	49 ff c8	 dec	 r8
  00220	48 ff cb	 dec	 rbx
  00223	79 91		 jns	 SHORT $LL36@stringlib_@16
  00225	e9 d8 fe ff ff	 jmp	 $LN109@stringlib_@16
$LN117@stringlib_@16:

; 291  : {

  0022a	4c 8b a4 24 80
	00 00 00	 mov	 r12, QWORD PTR sep$[rsp]
  00232	4c 8b 6c 24 20	 mov	 r13, QWORD PTR count$1$[rsp]
  00237	4c 8b b4 24 88
	00 00 00	 mov	 r14, QWORD PTR list$1$[rsp]
$LN101@stringlib_@16:

; 309  :         if (pos < 0)

  0023f	48 85 db	 test	 rbx, rbx
  00242	0f 88 ba fe ff
	ff		 js	 $LN109@stringlib_@16

; 310  :             break;
; 311  :         SPLIT_ADD(str, pos + sep_len, j);

  00248	4c 2b fb	 sub	 r15, rbx
  0024b	48 8d 0c 2b	 lea	 rcx, QWORD PTR [rbx+rbp]
  0024f	4c 2b fe	 sub	 r15, rsi
  00252	48 03 ce	 add	 rcx, rsi
  00255	49 8b d7	 mov	 rdx, r15
  00258	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0025d	48 8b f8	 mov	 rdi, rax
  00260	48 85 c0	 test	 rax, rax
  00263	74 4a		 je	 SHORT $LN119@stringlib_@16
  00265	49 83 fd 0c	 cmp	 r13, 12
  00269	7d 0a		 jge	 SHORT $LN10@stringlib_@16
  0026b	49 8b 4e 70	 mov	 rcx, QWORD PTR [r14+112]
  0026f	4a 89 04 e9	 mov	 QWORD PTR [rcx+r13*8], rax
  00273	eb 17		 jmp	 SHORT $LN7@stringlib_@16
$LN10@stringlib_@16:
  00275	48 8b d0	 mov	 rdx, rax
  00278	49 8b ce	 mov	 rcx, r14
  0027b	e8 00 00 00 00	 call	 PyList_Append
  00280	48 8b cf	 mov	 rcx, rdi
  00283	85 c0		 test	 eax, eax
  00285	75 23		 jne	 SHORT $LN104@stringlib_@16
  00287	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@stringlib_@16:
  0028c	49 ff c5	 inc	 r13

; 312  :         j = pos;

  0028f	4c 8b fb	 mov	 r15, rbx
  00292	48 8b 5c 24 28	 mov	 rbx, QWORD PTR maxcount$1$[rsp]
  00297	4c 89 6c 24 20	 mov	 QWORD PTR count$1$[rsp], r13
  0029c	48 85 db	 test	 rbx, rbx
  0029f	0f 8f 1b fe ff
	ff		 jg	 $LL14@stringlib_@16

; 324  :     }
; 325  :     FIX_PREALLOC_SIZE(list);
; 326  :     if (PyList_Reverse(list) < 0)

  002a5	e9 58 fe ff ff	 jmp	 $LN109@stringlib_@16
$LN104@stringlib_@16:

; 310  :             break;
; 311  :         SPLIT_ADD(str, pos + sep_len, j);

  002aa	e8 00 00 00 00	 call	 _Py_DecRef
$LN119@stringlib_@16:

; 291  : {

  002af	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR list$1$[rsp]
$onError$21693:

; 329  : 
; 330  :   onError:
; 331  :     Py_DECREF(list);

  002b7	48 8b ce	 mov	 rcx, rsi
  002ba	e8 00 00 00 00	 call	 _Py_DecRef

; 332  :     return NULL;

  002bf	33 c0		 xor	 eax, eax
$LN122@stringlib_@16:
  002c1	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
$LN121@stringlib_@16:
  002c6	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  002cb	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]

; 333  : }

  002d0	48 83 c4 40	 add	 rsp, 64			; 00000040H
  002d4	41 5f		 pop	 r15
  002d6	41 5d		 pop	 r13
  002d8	41 5c		 pop	 r12
  002da	5e		 pop	 rsi
  002db	5d		 pop	 rbp
  002dc	c3		 ret	 0
$LN5@stringlib_@16:

; 313  :     }
; 314  : #ifndef STRINGLIB_MUTABLE
; 315  :     if (count == 0 && STRINGLIB_CHECK_EXACT(str_obj)) {
; 316  :         /* No match in str_obj, so just use it as list[0] */
; 317  :         Py_INCREF(str_obj);
; 318  :         PyList_SET_ITEM(list, 0, (PyObject *)str_obj);
; 319  :         count++;
; 320  :     } else
; 321  : #endif
; 322  :     {
; 323  :         SPLIT_ADD(str, 0, j);

  002dd	48 8b d0	 mov	 rdx, rax
  002e0	48 8b ce	 mov	 rcx, rsi
  002e3	e8 00 00 00 00	 call	 PyList_Append
  002e8	48 8b cb	 mov	 rcx, rbx
  002eb	85 c0		 test	 eax, eax
  002ed	74 07		 je	 SHORT $LN3@stringlib_@16
  002ef	e8 00 00 00 00	 call	 _Py_DecRef
  002f4	eb c1		 jmp	 SHORT $onError$21693
$LN3@stringlib_@16:
  002f6	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@stringlib_@16:
  002fb	48 8d 47 01	 lea	 rax, QWORD PTR [rdi+1]

; 324  :     }
; 325  :     FIX_PREALLOC_SIZE(list);
; 326  :     if (PyList_Reverse(list) < 0)

  002ff	48 8b ce	 mov	 rcx, rsi
  00302	48 89 46 60	 mov	 QWORD PTR [rsi+96], rax
  00306	e8 00 00 00 00	 call	 PyList_Reverse
  0030b	85 c0		 test	 eax, eax
  0030d	78 a8		 js	 SHORT $onError$21693

; 327  :         goto onError;
; 328  :     return list;

  0030f	48 8b c6	 mov	 rax, rsi
  00312	eb ad		 jmp	 SHORT $LN122@stringlib_@16
stringlib_rsplit ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$stringlib_splitlines DD imagerel stringlib_splitlines
	DD	imagerel stringlib_splitlines+55
	DD	imagerel $unwind$stringlib_splitlines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$stringlib_splitlines DD imagerel stringlib_splitlines+55
	DD	imagerel stringlib_splitlines+330
	DD	imagerel $chain$1$stringlib_splitlines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$stringlib_splitlines DD imagerel stringlib_splitlines+330
	DD	imagerel stringlib_splitlines+350
	DD	imagerel $chain$3$stringlib_splitlines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$stringlib_splitlines DD 040021H
	DD	0b7400H
	DD	0a3400H
	DD	imagerel stringlib_splitlines
	DD	imagerel stringlib_splitlines+55
	DD	imagerel $unwind$stringlib_splitlines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$stringlib_splitlines DD 040a21H
	DD	0b740aH
	DD	0a3405H
	DD	imagerel stringlib_splitlines
	DD	imagerel stringlib_splitlines+55
	DD	imagerel $unwind$stringlib_splitlines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_splitlines DD 060e01H
	DD	0c540eH
	DD	0d00a520eH
	DD	06006c008H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\split.h
xdata	ENDS
;	COMDAT stringlib_splitlines
_TEXT	SEGMENT
str$ = 80
str_len$ = 88
keepends$ = 96
stringlib_splitlines PROC				; COMDAT

; 339  : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 8b e9	 mov	 rbp, rcx

; 340  :     /* This does not use the preallocated list because splitlines is
; 341  :        usually run with hundreds of newlines.  The overhead of
; 342  :        switching between PyList_SET_ITEM and append causes about a
; 343  :        2-3% slowdown for that common case.  A smarter implementation
; 344  :        could move the if check out, so the SET_ITEMs are done first
; 345  :        and the appends only done when the prealloc buffer is full.
; 346  :        That's too much work for little gain.*/
; 347  : 
; 348  :     register Py_ssize_t i;
; 349  :     register Py_ssize_t j;
; 350  :     PyObject *list = PyList_New(0);

  00011	33 c9		 xor	 ecx, ecx
  00013	45 8b e8	 mov	 r13d, r8d
  00016	48 8b f2	 mov	 rsi, rdx
  00019	e8 00 00 00 00	 call	 PyList_New
  0001e	4c 8b e0	 mov	 r12, rax

; 351  :     PyObject *sub;
; 352  : 
; 353  :     if (list == NULL)

  00021	48 85 c0	 test	 rax, rax
  00024	75 0f		 jne	 SHORT $LN12@stringlib_@17

; 389  : }

  00026	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  0002b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002f	41 5d		 pop	 r13
  00031	41 5c		 pop	 r12
  00033	5e		 pop	 rsi
  00034	c3		 ret	 0
$LN12@stringlib_@17:

; 354  :         return NULL;
; 355  : 
; 356  :     for (i = j = 0; i < str_len; ) {

  00035	33 c9		 xor	 ecx, ecx
  00037	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0003c	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  00041	8b d9		 mov	 ebx, ecx
  00043	48 85 f6	 test	 rsi, rsi
  00046	0f 8e e2 00 00
	00		 jle	 $LN10@stringlib_@17

; 357  :         Py_ssize_t eol;
; 358  : 
; 359  :         /* Find a line and append it */
; 360  :         while (i < str_len && !STRINGLIB_ISLINEBREAK(str[i]))

  0004c	48 3b ce	 cmp	 rcx, rsi
  0004f	7d 14		 jge	 SHORT $LN32@stringlib_@17
$LL9@stringlib_@17:
  00051	0f b6 04 2b	 movzx	 eax, BYTE PTR [rbx+rbp]
  00055	3c 0a		 cmp	 al, 10
  00057	74 0c		 je	 SHORT $LN32@stringlib_@17
  00059	3c 0d		 cmp	 al, 13
  0005b	74 08		 je	 SHORT $LN32@stringlib_@17

; 361  :             i++;

  0005d	48 ff c3	 inc	 rbx
  00060	48 3b de	 cmp	 rbx, rsi
  00063	7c ec		 jl	 SHORT $LL9@stringlib_@17
$LN32@stringlib_@17:

; 362  : 
; 363  :         /* Skip the line break reading CRLF as one line break */
; 364  :         eol = i;

  00065	48 8b d3	 mov	 rdx, rbx

; 365  :         if (i < str_len) {

  00068	48 3b de	 cmp	 rbx, rsi
  0006b	7d 26		 jge	 SHORT $LN4@stringlib_@17

; 366  :             if (str[i] == '\r' && i + 1 < str_len && str[i+1] == '\n')

  0006d	80 3c 2b 0d	 cmp	 BYTE PTR [rbx+rbp], 13
  00071	75 16		 jne	 SHORT $LN6@stringlib_@17
  00073	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
  00077	48 3b c6	 cmp	 rax, rsi
  0007a	7d 0d		 jge	 SHORT $LN6@stringlib_@17
  0007c	80 7c 2b 01 0a	 cmp	 BYTE PTR [rbx+rbp+1], 10
  00081	75 06		 jne	 SHORT $LN6@stringlib_@17

; 367  :                 i += 2;

  00083	48 83 c3 02	 add	 rbx, 2

; 368  :             else

  00087	eb 03		 jmp	 SHORT $LN5@stringlib_@17
$LN6@stringlib_@17:

; 369  :                 i++;

  00089	48 ff c3	 inc	 rbx
$LN5@stringlib_@17:

; 370  :             if (keepends)

  0008c	45 85 ed	 test	 r13d, r13d
  0008f	48 0f 45 d3	 cmovne	 rdx, rbx
$LN4@stringlib_@17:

; 371  :                 eol = i;
; 372  :         }
; 373  : #ifndef STRINGLIB_MUTABLE
; 374  :         if (j == 0 && eol == str_len && STRINGLIB_CHECK_EXACT(str_obj)) {
; 375  :             /* No linebreak in str_obj, so just use it as list[0] */
; 376  :             if (PyList_Append(list, str_obj))
; 377  :                 goto onError;
; 378  :             break;
; 379  :         }
; 380  : #endif
; 381  :         SPLIT_APPEND(str, j, eol);

  00093	48 2b d1	 sub	 rdx, rcx
  00096	48 03 cd	 add	 rcx, rbp
  00099	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0009e	48 8b f8	 mov	 rdi, rax
  000a1	48 85 c0	 test	 rax, rax
  000a4	0f 84 a8 00 00
	00		 je	 $onError$21744
  000aa	48 8b d0	 mov	 rdx, rax
  000ad	49 8b cc	 mov	 rcx, r12
  000b0	e8 00 00 00 00	 call	 PyList_Append
  000b5	85 c0		 test	 eax, eax
  000b7	0f 85 8d 00 00
	00		 jne	 $LN29@stringlib_@17
  000bd	e8 00 00 00 00	 call	 _Py_PXCTX
  000c2	85 c0		 test	 eax, eax
  000c4	75 5c		 jne	 SHORT $LN25@stringlib_@17
  000c6	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000ca	a8 20		 test	 al, 32			; 00000020H
  000cc	75 4c		 jne	 SHORT $LN19@stringlib_@17
  000ce	84 c0		 test	 al, al
  000d0	78 48		 js	 SHORT $LN19@stringlib_@17
  000d2	a8 02		 test	 al, 2
  000d4	75 4c		 jne	 SHORT $LN25@stringlib_@17
  000d6	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000da	75 46		 jne	 SHORT $LN25@stringlib_@17
  000dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000ea	4c 8b cf	 mov	 r9, rdi
  000ed	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000f3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000fb	e8 00 00 00 00	 call	 _PyParallel_Guard
  00100	48 8b cf	 mov	 rcx, rdi
  00103	85 c0		 test	 eax, eax
  00105	74 07		 je	 SHORT $LN24@stringlib_@17
  00107	e8 00 00 00 00	 call	 _Px_Dealloc
  0010c	eb 14		 jmp	 SHORT $LN25@stringlib_@17
$LN24@stringlib_@17:
  0010e	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00112	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00118	eb 08		 jmp	 SHORT $LN25@stringlib_@17
$LN19@stringlib_@17:
  0011a	48 8b cf	 mov	 rcx, rdi
  0011d	e8 00 00 00 00	 call	 Px_DecRef
$LN25@stringlib_@17:

; 382  :         j = i;

  00122	48 8b cb	 mov	 rcx, rbx
  00125	48 3b de	 cmp	 rbx, rsi
  00128	0f 8c 23 ff ff
	ff		 jl	 $LL9@stringlib_@17
$LN10@stringlib_@17:

; 383  :     }
; 384  :     return list;

  0012e	49 8b c4	 mov	 rax, r12
$LN34@stringlib_@17:
  00131	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00136	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]

; 389  : }

  0013b	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00140	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00144	41 5d		 pop	 r13
  00146	41 5c		 pop	 r12
  00148	5e		 pop	 rsi
  00149	c3		 ret	 0
$LN29@stringlib_@17:

; 371  :                 eol = i;
; 372  :         }
; 373  : #ifndef STRINGLIB_MUTABLE
; 374  :         if (j == 0 && eol == str_len && STRINGLIB_CHECK_EXACT(str_obj)) {
; 375  :             /* No linebreak in str_obj, so just use it as list[0] */
; 376  :             if (PyList_Append(list, str_obj))
; 377  :                 goto onError;
; 378  :             break;
; 379  :         }
; 380  : #endif
; 381  :         SPLIT_APPEND(str, j, eol);

  0014a	48 8b cf	 mov	 rcx, rdi
  0014d	e8 00 00 00 00	 call	 _Py_DecRef
$onError$21744:

; 385  : 
; 386  :   onError:
; 387  :     Py_DECREF(list);

  00152	49 8b cc	 mov	 rcx, r12
  00155	e8 00 00 00 00	 call	 _Py_DecRef

; 388  :     return NULL;

  0015a	33 c0		 xor	 eax, eax
  0015c	eb d3		 jmp	 SHORT $LN34@stringlib_@17
stringlib_splitlines ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_isspace:PROC
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\stringlib\ctype.h
;	COMDAT stringlib_isspace
_TEXT	SEGMENT
self$ = 8
stringlib_isspace PROC					; COMDAT

; 9    :     return _Py_bytes_isspace(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00000	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00004	48 85 d2	 test	 rdx, rdx
  00007	74 0c		 je	 SHORT $LN3@stringlib_@18
  00009	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]

; 10   : }

  00010	e9 00 00 00 00	 jmp	 _Py_bytes_isspace
$LN3@stringlib_@18:

; 9    :     return _Py_bytes_isspace(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string

; 10   : }

  0001c	e9 00 00 00 00	 jmp	 _Py_bytes_isspace
stringlib_isspace ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_isalpha:PROC
; Function compile flags: /Ogtpy
;	COMDAT stringlib_isalpha
_TEXT	SEGMENT
self$ = 8
stringlib_isalpha PROC					; COMDAT

; 15   :     return _Py_bytes_isalpha(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00000	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00004	48 85 d2	 test	 rdx, rdx
  00007	74 0c		 je	 SHORT $LN3@stringlib_@19
  00009	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]

; 16   : }

  00010	e9 00 00 00 00	 jmp	 _Py_bytes_isalpha
$LN3@stringlib_@19:

; 15   :     return _Py_bytes_isalpha(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string

; 16   : }

  0001c	e9 00 00 00 00	 jmp	 _Py_bytes_isalpha
stringlib_isalpha ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_isalnum:PROC
; Function compile flags: /Ogtpy
;	COMDAT stringlib_isalnum
_TEXT	SEGMENT
self$ = 8
stringlib_isalnum PROC					; COMDAT

; 21   :     return _Py_bytes_isalnum(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00000	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00004	48 85 d2	 test	 rdx, rdx
  00007	74 0c		 je	 SHORT $LN3@stringlib_@20
  00009	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]

; 22   : }

  00010	e9 00 00 00 00	 jmp	 _Py_bytes_isalnum
$LN3@stringlib_@20:

; 21   :     return _Py_bytes_isalnum(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string

; 22   : }

  0001c	e9 00 00 00 00	 jmp	 _Py_bytes_isalnum
stringlib_isalnum ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_isdigit:PROC
; Function compile flags: /Ogtpy
;	COMDAT stringlib_isdigit
_TEXT	SEGMENT
self$ = 8
stringlib_isdigit PROC					; COMDAT

; 27   :     return _Py_bytes_isdigit(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00000	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00004	48 85 d2	 test	 rdx, rdx
  00007	74 0c		 je	 SHORT $LN3@stringlib_@21
  00009	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]

; 28   : }

  00010	e9 00 00 00 00	 jmp	 _Py_bytes_isdigit
$LN3@stringlib_@21:

; 27   :     return _Py_bytes_isdigit(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string

; 28   : }

  0001c	e9 00 00 00 00	 jmp	 _Py_bytes_isdigit
stringlib_isdigit ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_islower:PROC
; Function compile flags: /Ogtpy
;	COMDAT stringlib_islower
_TEXT	SEGMENT
self$ = 8
stringlib_islower PROC					; COMDAT

; 33   :     return _Py_bytes_islower(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00000	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00004	48 85 d2	 test	 rdx, rdx
  00007	74 0c		 je	 SHORT $LN3@stringlib_@22
  00009	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]

; 34   : }

  00010	e9 00 00 00 00	 jmp	 _Py_bytes_islower
$LN3@stringlib_@22:

; 33   :     return _Py_bytes_islower(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string

; 34   : }

  0001c	e9 00 00 00 00	 jmp	 _Py_bytes_islower
stringlib_islower ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_isupper:PROC
; Function compile flags: /Ogtpy
;	COMDAT stringlib_isupper
_TEXT	SEGMENT
self$ = 8
stringlib_isupper PROC					; COMDAT

; 39   :     return _Py_bytes_isupper(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00000	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00004	48 85 d2	 test	 rdx, rdx
  00007	74 0c		 je	 SHORT $LN3@stringlib_@23
  00009	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]

; 40   : }

  00010	e9 00 00 00 00	 jmp	 _Py_bytes_isupper
$LN3@stringlib_@23:

; 39   :     return _Py_bytes_isupper(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string

; 40   : }

  0001c	e9 00 00 00 00	 jmp	 _Py_bytes_isupper
stringlib_isupper ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_istitle:PROC
; Function compile flags: /Ogtpy
;	COMDAT stringlib_istitle
_TEXT	SEGMENT
self$ = 8
stringlib_istitle PROC					; COMDAT

; 45   :     return _Py_bytes_istitle(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00000	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00004	48 85 d2	 test	 rdx, rdx
  00007	74 0c		 je	 SHORT $LN3@stringlib_@24
  00009	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]

; 46   : }

  00010	e9 00 00 00 00	 jmp	 _Py_bytes_istitle
$LN3@stringlib_@24:

; 45   :     return _Py_bytes_istitle(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string

; 46   : }

  0001c	e9 00 00 00 00	 jmp	 _Py_bytes_istitle
stringlib_istitle ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_lower:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_lower DD imagerel stringlib_lower
	DD	imagerel stringlib_lower+104
	DD	imagerel $unwind$stringlib_lower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_lower DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT stringlib_lower
_TEXT	SEGMENT
self$ = 48
stringlib_lower PROC					; COMDAT

; 53   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 54   :     PyObject* newobj;
; 55   :     newobj = STRINGLIB_NEW(NULL, STRINGLIB_LEN(self));

  0000a	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	33 c9		 xor	 ecx, ecx
  00013	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00018	48 8b d8	 mov	 rbx, rax

; 56   :     if (!newobj)

  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0b		 jne	 SHORT $LN1@stringlib_@25

; 61   : }

  00020	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN1@stringlib_@25:

; 57   :             return NULL;
; 58   :     _Py_bytes_lower(STRINGLIB_STR(newobj), STRINGLIB_STR(self),
; 59   :                  STRINGLIB_LEN(self));

  0002b	4c 8b 47 60	 mov	 r8, QWORD PTR [rdi+96]
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string
  00036	4d 85 c0	 test	 r8, r8
  00039	74 09		 je	 SHORT $LN4@stringlib_@25
  0003b	48 8b 97 80 00
	00 00		 mov	 rdx, QWORD PTR [rdi+128]
  00042	eb 03		 jmp	 SHORT $LN5@stringlib_@25
$LN4@stringlib_@25:
  00044	48 8b d1	 mov	 rdx, rcx
$LN5@stringlib_@25:
  00047	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0004c	74 07		 je	 SHORT $LN6@stringlib_@25
  0004e	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
$LN6@stringlib_@25:
  00055	e8 00 00 00 00	 call	 _Py_bytes_lower

; 60   :     return newobj;

  0005a	48 8b c3	 mov	 rax, rbx

; 61   : }

  0005d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
stringlib_lower ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_upper:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_upper DD imagerel stringlib_upper
	DD	imagerel stringlib_upper+104
	DD	imagerel $unwind$stringlib_upper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_upper DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT stringlib_upper
_TEXT	SEGMENT
self$ = 48
stringlib_upper PROC					; COMDAT

; 65   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 66   :     PyObject* newobj;
; 67   :     newobj = STRINGLIB_NEW(NULL, STRINGLIB_LEN(self));

  0000a	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	33 c9		 xor	 ecx, ecx
  00013	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00018	48 8b d8	 mov	 rbx, rax

; 68   :     if (!newobj)

  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0b		 jne	 SHORT $LN1@stringlib_@26

; 73   : }

  00020	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN1@stringlib_@26:

; 69   :             return NULL;
; 70   :     _Py_bytes_upper(STRINGLIB_STR(newobj), STRINGLIB_STR(self),
; 71   :                  STRINGLIB_LEN(self));

  0002b	4c 8b 47 60	 mov	 r8, QWORD PTR [rdi+96]
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string
  00036	4d 85 c0	 test	 r8, r8
  00039	74 09		 je	 SHORT $LN4@stringlib_@26
  0003b	48 8b 97 80 00
	00 00		 mov	 rdx, QWORD PTR [rdi+128]
  00042	eb 03		 jmp	 SHORT $LN5@stringlib_@26
$LN4@stringlib_@26:
  00044	48 8b d1	 mov	 rdx, rcx
$LN5@stringlib_@26:
  00047	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0004c	74 07		 je	 SHORT $LN6@stringlib_@26
  0004e	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
$LN6@stringlib_@26:
  00055	e8 00 00 00 00	 call	 _Py_bytes_upper

; 72   :     return newobj;

  0005a	48 8b c3	 mov	 rax, rbx

; 73   : }

  0005d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
stringlib_upper ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_title:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_title DD imagerel stringlib_title
	DD	imagerel stringlib_title+104
	DD	imagerel $unwind$stringlib_title
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_title DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT stringlib_title
_TEXT	SEGMENT
self$ = 48
stringlib_title PROC					; COMDAT

; 77   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 78   :     PyObject* newobj;
; 79   :     newobj = STRINGLIB_NEW(NULL, STRINGLIB_LEN(self));

  0000a	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	33 c9		 xor	 ecx, ecx
  00013	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00018	48 8b d8	 mov	 rbx, rax

; 80   :     if (!newobj)

  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0b		 jne	 SHORT $LN1@stringlib_@27

; 85   : }

  00020	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN1@stringlib_@27:

; 81   :             return NULL;
; 82   :     _Py_bytes_title(STRINGLIB_STR(newobj), STRINGLIB_STR(self),
; 83   :                  STRINGLIB_LEN(self));

  0002b	4c 8b 47 60	 mov	 r8, QWORD PTR [rdi+96]
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string
  00036	4d 85 c0	 test	 r8, r8
  00039	74 09		 je	 SHORT $LN4@stringlib_@27
  0003b	48 8b 97 80 00
	00 00		 mov	 rdx, QWORD PTR [rdi+128]
  00042	eb 03		 jmp	 SHORT $LN5@stringlib_@27
$LN4@stringlib_@27:
  00044	48 8b d1	 mov	 rdx, rcx
$LN5@stringlib_@27:
  00047	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0004c	74 07		 je	 SHORT $LN6@stringlib_@27
  0004e	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
$LN6@stringlib_@27:
  00055	e8 00 00 00 00	 call	 _Py_bytes_title

; 84   :     return newobj;

  0005a	48 8b c3	 mov	 rax, rbx

; 85   : }

  0005d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
stringlib_title ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_capitalize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_capitalize DD imagerel stringlib_capitalize
	DD	imagerel stringlib_capitalize+104
	DD	imagerel $unwind$stringlib_capitalize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_capitalize DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT stringlib_capitalize
_TEXT	SEGMENT
self$ = 48
stringlib_capitalize PROC				; COMDAT

; 89   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 90   :     PyObject* newobj;
; 91   :     newobj = STRINGLIB_NEW(NULL, STRINGLIB_LEN(self));

  0000a	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	33 c9		 xor	 ecx, ecx
  00013	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00018	48 8b d8	 mov	 rbx, rax

; 92   :     if (!newobj)

  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0b		 jne	 SHORT $LN1@stringlib_@28

; 97   : }

  00020	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN1@stringlib_@28:

; 93   :             return NULL;
; 94   :     _Py_bytes_capitalize(STRINGLIB_STR(newobj), STRINGLIB_STR(self),
; 95   :                       STRINGLIB_LEN(self));

  0002b	4c 8b 47 60	 mov	 r8, QWORD PTR [rdi+96]
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string
  00036	4d 85 c0	 test	 r8, r8
  00039	74 09		 je	 SHORT $LN4@stringlib_@28
  0003b	48 8b 97 80 00
	00 00		 mov	 rdx, QWORD PTR [rdi+128]
  00042	eb 03		 jmp	 SHORT $LN5@stringlib_@28
$LN4@stringlib_@28:
  00044	48 8b d1	 mov	 rdx, rcx
$LN5@stringlib_@28:
  00047	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0004c	74 07		 je	 SHORT $LN6@stringlib_@28
  0004e	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
$LN6@stringlib_@28:
  00055	e8 00 00 00 00	 call	 _Py_bytes_capitalize

; 96   :     return newobj;

  0005a	48 8b c3	 mov	 rax, rbx

; 97   : }

  0005d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
stringlib_capitalize ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_swapcase:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_swapcase DD imagerel stringlib_swapcase
	DD	imagerel stringlib_swapcase+104
	DD	imagerel $unwind$stringlib_swapcase
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_swapcase DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT stringlib_swapcase
_TEXT	SEGMENT
self$ = 48
stringlib_swapcase PROC					; COMDAT

; 101  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 102  :     PyObject* newobj;
; 103  :     newobj = STRINGLIB_NEW(NULL, STRINGLIB_LEN(self));

  0000a	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	33 c9		 xor	 ecx, ecx
  00013	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00018	48 8b d8	 mov	 rbx, rax

; 104  :     if (!newobj)

  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0b		 jne	 SHORT $LN1@stringlib_@29

; 109  : }

  00020	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN1@stringlib_@29:

; 105  :             return NULL;
; 106  :     _Py_bytes_swapcase(STRINGLIB_STR(newobj), STRINGLIB_STR(self),
; 107  :                     STRINGLIB_LEN(self));

  0002b	4c 8b 47 60	 mov	 r8, QWORD PTR [rdi+96]
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string
  00036	4d 85 c0	 test	 r8, r8
  00039	74 09		 je	 SHORT $LN4@stringlib_@29
  0003b	48 8b 97 80 00
	00 00		 mov	 rdx, QWORD PTR [rdi+128]
  00042	eb 03		 jmp	 SHORT $LN5@stringlib_@29
$LN4@stringlib_@29:
  00044	48 8b d1	 mov	 rdx, rcx
$LN5@stringlib_@29:
  00047	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0004c	74 07		 je	 SHORT $LN6@stringlib_@29
  0004e	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
$LN6@stringlib_@29:
  00055	e8 00 00 00 00	 call	 _Py_bytes_swapcase

; 108  :     return newobj;

  0005a	48 8b c3	 mov	 rax, rbx

; 109  : }

  0005d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
stringlib_swapcase ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBJEGKI@result?5is?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0O@DJDMKPID@?$HMi?3expandtabs?$AA@	; `string'
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\transmogrify.h
pdata	SEGMENT
$pdata$stringlib_expandtabs DD imagerel stringlib_expandtabs
	DD	imagerel stringlib_expandtabs+246
	DD	imagerel $unwind$stringlib_expandtabs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$stringlib_expandtabs DD imagerel stringlib_expandtabs+246
	DD	imagerel stringlib_expandtabs+268
	DD	imagerel $chain$3$stringlib_expandtabs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$stringlib_expandtabs DD imagerel stringlib_expandtabs+268
	DD	imagerel stringlib_expandtabs+404
	DD	imagerel $chain$4$stringlib_expandtabs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$stringlib_expandtabs DD imagerel stringlib_expandtabs+404
	DD	imagerel stringlib_expandtabs+409
	DD	imagerel $chain$5$stringlib_expandtabs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$stringlib_expandtabs DD imagerel stringlib_expandtabs+409
	DD	imagerel stringlib_expandtabs+430
	DD	imagerel $chain$6$stringlib_expandtabs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$stringlib_expandtabs DD 021H
	DD	imagerel stringlib_expandtabs
	DD	imagerel stringlib_expandtabs+246
	DD	imagerel $unwind$stringlib_expandtabs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$stringlib_expandtabs DD 021H
	DD	imagerel stringlib_expandtabs+246
	DD	imagerel stringlib_expandtabs+268
	DD	imagerel $chain$3$stringlib_expandtabs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$stringlib_expandtabs DD 020521H
	DD	096405H
	DD	imagerel stringlib_expandtabs+246
	DD	imagerel stringlib_expandtabs+268
	DD	imagerel $chain$3$stringlib_expandtabs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$stringlib_expandtabs DD 020521H
	DD	04d405H
	DD	imagerel stringlib_expandtabs
	DD	imagerel stringlib_expandtabs+246
	DD	imagerel $unwind$stringlib_expandtabs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_expandtabs DD 084901H
	DD	05c449H
	DD	0b743eH
	DD	083439H
	DD	050025206H
xdata	ENDS
;	COMDAT ??_C@_0BD@OLBJEGKI@result?5is?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBJEGKI@result?5is?5too?5long?$AA@ DB 'result is too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DJDMKPID@?$HMi?3expandtabs?$AA@
CONST	SEGMENT
??_C@_0O@DJDMKPID@?$HMi?3expandtabs?$AA@ DB '|i:expandtabs', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT stringlib_expandtabs
_TEXT	SEGMENT
self$ = 64
args$ = 72
tabsize$ = 80
stringlib_expandtabs PROC				; COMDAT

; 15   : {

  00000	40 55		 push	 rbp
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b e9	 mov	 rbp, rcx

; 16   :     const char *e, *p;
; 17   :     char *q;
; 18   :     size_t i, j;
; 19   :     PyObject *u;
; 20   :     int tabsize = 8;
; 21   : 
; 22   :     if (!PyArg_ParseTuple(args, "|i:expandtabs", &tabsize))

  0000c	4c 8d 44 24 50	 lea	 r8, QWORD PTR tabsize$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@DJDMKPID@?$HMi?3expandtabs?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	c7 44 24 50 08
	00 00 00	 mov	 DWORD PTR tabsize$[rsp], 8
  00023	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00028	85 c0		 test	 eax, eax
  0002a	75 08		 jne	 SHORT $LN23@stringlib_@30

; 23   :         return NULL;

  0002c	33 c0		 xor	 eax, eax

; 82   : }

  0002e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00032	5d		 pop	 rbp
  00033	c3		 ret	 0
$LN23@stringlib_@30:
  00034	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00039	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi

; 24   : 
; 25   :     /* First pass: determine size of output string */
; 26   :     i = j = 0;

  0003e	45 33 c9	 xor	 r9d, r9d
  00041	45 33 d2	 xor	 r10d, r10d
  00044	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12

; 27   :     e = STRINGLIB_STR(self) + STRINGLIB_LEN(self);

  00049	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_PyByteArray_empty_string
  00050	4c 39 4d 60	 cmp	 QWORD PTR [rbp+96], r9
  00054	74 09		 je	 SHORT $LN26@stringlib_@30
  00056	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR [rbp+128]
  0005d	eb 03		 jmp	 SHORT $LN27@stringlib_@30
$LN26@stringlib_@30:
  0005f	48 8b cf	 mov	 rcx, rdi
$LN27@stringlib_@30:
  00062	48 8b 45 60	 mov	 rax, QWORD PTR [rbp+96]
  00066	4c 8d 24 08	 lea	 r12, QWORD PTR [rax+rcx]

; 28   :     for (p = STRINGLIB_STR(self); p < e; p++)

  0006a	48 85 c0	 test	 rax, rax
  0006d	74 09		 je	 SHORT $LN28@stringlib_@30
  0006f	4c 8b 85 80 00
	00 00		 mov	 r8, QWORD PTR [rbp+128]
  00076	eb 03		 jmp	 SHORT $LN29@stringlib_@30
$LN28@stringlib_@30:
  00078	4c 8b c7	 mov	 r8, rdi
$LN29@stringlib_@30:
  0007b	48 bb ff ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775807 ; 7fffffffffffffffH
  00085	4d 3b c4	 cmp	 r8, r12
  00088	73 47		 jae	 SHORT $LN20@stringlib_@30
  0008a	4c 63 5c 24 50	 movsxd	 r11, DWORD PTR tabsize$[rsp]
  0008f	90		 npad	 1
$LL22@stringlib_@30:

; 29   :         if (*p == '\t') {

  00090	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00094	3c 09		 cmp	 al, 9
  00096	75 1b		 jne	 SHORT $LN19@stringlib_@30

; 30   :             if (tabsize > 0) {

  00098	45 85 db	 test	 r11d, r11d
  0009b	7e 2c		 jle	 SHORT $LN21@stringlib_@30

; 31   :                 j += tabsize - (j % tabsize);

  0009d	33 d2		 xor	 edx, edx
  0009f	49 8b c1	 mov	 rax, r9
  000a2	49 8b cb	 mov	 rcx, r11
  000a5	49 f7 f3	 div	 r11
  000a8	48 2b ca	 sub	 rcx, rdx
  000ab	4c 03 c9	 add	 r9, rcx

; 32   :                 if (j > PY_SSIZE_T_MAX) {

  000ae	4c 3b cb	 cmp	 r9, rbx

; 33   :                     PyErr_SetString(PyExc_OverflowError,
; 34   :                                     "result is too long");
; 35   :                     return NULL;
; 36   :                 }
; 37   :             }
; 38   :         }
; 39   :         else {

  000b1	eb 14		 jmp	 SHORT $LN49@stringlib_@30
$LN19@stringlib_@30:

; 40   :             j++;

  000b3	49 ff c1	 inc	 r9

; 41   :             if (*p == '\n' || *p == '\r') {

  000b6	3c 0a		 cmp	 al, 10
  000b8	74 04		 je	 SHORT $LN14@stringlib_@30
  000ba	3c 0d		 cmp	 al, 13
  000bc	75 0b		 jne	 SHORT $LN21@stringlib_@30
$LN14@stringlib_@30:

; 42   :                 i += j;

  000be	4d 03 d1	 add	 r10, r9

; 43   :                 j = 0;

  000c1	45 33 c9	 xor	 r9d, r9d

; 44   :                 if (i > PY_SSIZE_T_MAX) {

  000c4	4c 3b d3	 cmp	 r10, rbx
$LN49@stringlib_@30:
  000c7	77 11		 ja	 SHORT $LN38@stringlib_@30
$LN21@stringlib_@30:

; 28   :     for (p = STRINGLIB_STR(self); p < e; p++)

  000c9	49 ff c0	 inc	 r8
  000cc	4d 3b c4	 cmp	 r8, r12
  000cf	72 bf		 jb	 SHORT $LL22@stringlib_@30
$LN20@stringlib_@30:

; 45   :                     PyErr_SetString(PyExc_OverflowError,
; 46   :                                     "result is too long");
; 47   :                     return NULL;
; 48   :                 }
; 49   :             }
; 50   :         }
; 51   : 
; 52   :     if ((i + j) > PY_SSIZE_T_MAX) {

  000d1	4b 8d 14 11	 lea	 rdx, QWORD PTR [r9+r10]
  000d5	48 3b d3	 cmp	 rdx, rbx
  000d8	76 1a		 jbe	 SHORT $LN12@stringlib_@30
$LN38@stringlib_@30:

; 53   :         PyErr_SetString(PyExc_OverflowError, "result is too long");

  000da	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@OLBJEGKI@result?5is?5too?5long?$AA@
  000e8	e8 00 00 00 00	 call	 PyErr_SetString

; 54   :         return NULL;

  000ed	33 c0		 xor	 eax, eax
  000ef	e9 a5 00 00 00	 jmp	 $LN47@stringlib_@30
$LN12@stringlib_@30:

; 55   :     }
; 56   : 
; 57   :     /* Second pass: create output string and fill it */
; 58   :     u = STRINGLIB_NEW(NULL, i + j);

  000f4	33 c9		 xor	 ecx, ecx
  000f6	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  000fb	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00100	4c 8b e8	 mov	 r13, rax

; 59   :     if (!u)

  00103	48 85 c0	 test	 rax, rax
  00106	0f 84 88 00 00
	00		 je	 $LN48@stringlib_@30
$LN11@stringlib_@30:
  0010c	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi

; 60   :         return NULL;
; 61   : 
; 62   :     j = 0;

  00111	33 f6		 xor	 esi, esi

; 63   :     q = STRINGLIB_STR(u);

  00113	48 39 70 60	 cmp	 QWORD PTR [rax+96], rsi
  00117	74 09		 je	 SHORT $LN30@stringlib_@30
  00119	48 8b 98 80 00
	00 00		 mov	 rbx, QWORD PTR [rax+128]
  00120	eb 03		 jmp	 SHORT $LN31@stringlib_@30
$LN30@stringlib_@30:
  00122	48 8b df	 mov	 rbx, rdi
$LN31@stringlib_@30:

; 64   : 
; 65   :     for (p = STRINGLIB_STR(self); p < e; p++)

  00125	48 39 75 60	 cmp	 QWORD PTR [rbp+96], rsi
  00129	74 07		 je	 SHORT $LN32@stringlib_@30
  0012b	48 8b bd 80 00
	00 00		 mov	 rdi, QWORD PTR [rbp+128]
$LN32@stringlib_@30:
  00132	49 3b fc	 cmp	 rdi, r12
  00135	73 55		 jae	 SHORT $LN8@stringlib_@30
$LL10@stringlib_@30:

; 66   :         if (*p == '\t') {

  00137	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  0013a	3c 09		 cmp	 al, 9
  0013c	75 31		 jne	 SHORT $LN7@stringlib_@30

; 67   :             if (tabsize > 0) {

  0013e	48 63 44 24 50	 movsxd	 rax, DWORD PTR tabsize$[rsp]
  00143	85 c0		 test	 eax, eax
  00145	7e 3d		 jle	 SHORT $LN9@stringlib_@30

; 68   :                 i = tabsize - (j % tabsize);

  00147	48 8b e8	 mov	 rbp, rax
  0014a	33 d2		 xor	 edx, edx
  0014c	48 8b c6	 mov	 rax, rsi
  0014f	48 f7 f5	 div	 rbp
  00152	48 2b ea	 sub	 rbp, rdx

; 69   :                 j += i;

  00155	48 03 f5	 add	 rsi, rbp

; 70   :                 while (i--)

  00158	48 85 ed	 test	 rbp, rbp
  0015b	74 27		 je	 SHORT $LN9@stringlib_@30

; 68   :                 i = tabsize - (j % tabsize);

  0015d	4c 8b c5	 mov	 r8, rbp
  00160	b2 20		 mov	 dl, 32			; 00000020H
  00162	48 8b cb	 mov	 rcx, rbx
  00165	e8 00 00 00 00	 call	 memset

; 70   :                 while (i--)

  0016a	48 03 dd	 add	 rbx, rbp

; 71   :                     *q++ = ' ';
; 72   :             }
; 73   :         }
; 74   :         else {

  0016d	eb 15		 jmp	 SHORT $LN9@stringlib_@30
$LN7@stringlib_@30:

; 75   :             j++;
; 76   :             *q++ = *p;

  0016f	88 03		 mov	 BYTE PTR [rbx], al

; 77   :             if (*p == '\n' || *p == '\r')

  00171	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  00174	48 ff c6	 inc	 rsi
  00177	48 ff c3	 inc	 rbx
  0017a	3c 0a		 cmp	 al, 10
  0017c	74 04		 je	 SHORT $LN1@stringlib_@30
  0017e	3c 0d		 cmp	 al, 13
  00180	75 02		 jne	 SHORT $LN9@stringlib_@30
$LN1@stringlib_@30:

; 78   :                 j = 0;

  00182	33 f6		 xor	 esi, esi
$LN9@stringlib_@30:

; 64   : 
; 65   :     for (p = STRINGLIB_STR(self); p < e; p++)

  00184	48 ff c7	 inc	 rdi
  00187	49 3b fc	 cmp	 rdi, r12
  0018a	72 ab		 jb	 SHORT $LL10@stringlib_@30
$LN8@stringlib_@30:
  0018c	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 79   :         }
; 80   : 
; 81   :     return u;

  00191	49 8b c5	 mov	 rax, r13
$LN48@stringlib_@30:
  00194	4c 8b 6c 24 20	 mov	 r13, QWORD PTR [rsp+32]
$LN47@stringlib_@30:
  00199	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0019e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001a3	4c 8b 64 24 28	 mov	 r12, QWORD PTR [rsp+40]

; 82   : }

  001a8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001ac	5d		 pop	 rbp
  001ad	c3		 ret	 0
stringlib_expandtabs ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pad DD	imagerel pad
	DD	imagerel pad+124
	DD	imagerel $unwind$pad
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pad DD	imagerel pad+124
	DD	imagerel pad+335
	DD	imagerel $chain$0$pad
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$pad DD	imagerel pad+335
	DD	imagerel pad+355
	DD	imagerel $chain$1$pad
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$pad DD	021H
	DD	imagerel pad
	DD	imagerel pad+124
	DD	imagerel $unwind$pad
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pad DD	020521H
	DD	087405H
	DD	imagerel pad
	DD	imagerel pad+124
	DD	imagerel $unwind$pad
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pad DD	081301H
	DD	0a5413H
	DD	093413H
	DD	0d00f3213H
	DD	0600bc00dH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT pad
_TEXT	SEGMENT
self$ = 64
left$ = 72
right$ = 80
fill$ = 88
pad	PROC						; COMDAT

; 86   : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 87   :     PyObject *u;
; 88   : 
; 89   :     if (left < 0)

  00013	33 c0		 xor	 eax, eax
  00015	48 85 d2	 test	 rdx, rdx
  00018	48 8b ea	 mov	 rbp, rdx
  0001b	48 0f 48 e8	 cmovs	 rbp, rax

; 90   :         left = 0;
; 91   :     if (right < 0)

  0001f	4d 85 c0	 test	 r8, r8
  00022	4d 8b e0	 mov	 r12, r8
  00025	4c 0f 48 e0	 cmovs	 r12, rax
  00029	45 0f b6 e9	 movzx	 r13d, r9b
  0002d	48 8b f1	 mov	 rsi, rcx

; 92   :         right = 0;
; 93   : 
; 94   :     if (left == 0 && right == 0 && STRINGLIB_CHECK_EXACT(self)) {

  00030	48 85 ed	 test	 rbp, rbp
  00033	75 43		 jne	 SHORT $LN12@pad
  00035	4d 85 e4	 test	 r12, r12
  00038	75 3e		 jne	 SHORT $LN12@pad
  0003a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00041	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00045	75 31		 jne	 SHORT $LN12@pad

; 95   : #if STRINGLIB_MUTABLE
; 96   :         /* We're defined as returning a copy;  If the object is mutable
; 97   :          * that means we must make an identical copy. */
; 98   :         return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00047	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  0004b	48 85 d2	 test	 rdx, rdx
  0004e	74 14		 je	 SHORT $LN17@pad
  00050	48 8b 99 80 00
	00 00		 mov	 rbx, QWORD PTR [rcx+128]
  00057	48 8b cb	 mov	 rcx, rbx
  0005a	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0005f	e9 eb 00 00 00	 jmp	 $LN15@pad
$LN17@pad:
  00064	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_PyByteArray_empty_string
  0006b	48 8b cb	 mov	 rcx, rbx
  0006e	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00073	e9 d7 00 00 00	 jmp	 $LN15@pad
$LN12@pad:

; 99   : #else
; 100  :         Py_INCREF(self);
; 101  :         return (PyObject *)self;
; 102  : #endif /* STRINGLIB_MUTABLE */
; 103  :     }
; 104  : 
; 105  :     u = STRINGLIB_NEW(NULL,
; 106  : 				   left + STRINGLIB_LEN(self) + right);

  00078	49 8d 14 2c	 lea	 rdx, QWORD PTR [r12+rbp]
  0007c	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00081	48 03 51 60	 add	 rdx, QWORD PTR [rcx+96]
  00085	33 c9		 xor	 ecx, ecx
  00087	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0008c	48 8b f8	 mov	 rdi, rax

; 107  :     if (u) {

  0008f	48 85 c0	 test	 rax, rax
  00092	0f 84 af 00 00
	00		 je	 $LN1@pad

; 108  :         if (left)

  00098	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_PyByteArray_empty_string
  0009f	48 85 ed	 test	 rbp, rbp
  000a2	74 1f		 je	 SHORT $LN9@pad

; 109  :             memset(STRINGLIB_STR(u), fill, left);

  000a4	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000a9	74 09		 je	 SHORT $LN19@pad
  000ab	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  000b2	eb 03		 jmp	 SHORT $LN20@pad
$LN19@pad:
  000b4	48 8b cb	 mov	 rcx, rbx
$LN20@pad:
  000b7	41 0f be d5	 movsx	 edx, r13b
  000bb	4c 8b c5	 mov	 r8, rbp
  000be	e8 00 00 00 00	 call	 memset
$LN9@pad:

; 110  :         Py_MEMCPY(STRINGLIB_STR(u) + left,
; 111  : 	       STRINGLIB_STR(self),
; 112  : 	       STRINGLIB_LEN(self));

  000c3	48 83 7f 60 00	 cmp	 QWORD PTR [rdi+96], 0
  000c8	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]
  000cc	74 09		 je	 SHORT $LN21@pad
  000ce	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  000d5	eb 03		 jmp	 SHORT $LN22@pad
$LN21@pad:
  000d7	48 8b c3	 mov	 rax, rbx
$LN22@pad:
  000da	48 8d 0c 28	 lea	 rcx, QWORD PTR [rax+rbp]
  000de	48 85 d2	 test	 rdx, rdx
  000e1	74 09		 je	 SHORT $LN23@pad
  000e3	4c 8b 8e 80 00
	00 00		 mov	 r9, QWORD PTR [rsi+128]
  000ea	eb 03		 jmp	 SHORT $LN24@pad
$LN23@pad:
  000ec	4c 8b cb	 mov	 r9, rbx
$LN24@pad:
  000ef	48 83 fa 10	 cmp	 rdx, 16
  000f3	72 0d		 jb	 SHORT $LN6@pad
  000f5	4c 8b c2	 mov	 r8, rdx
  000f8	49 8b d1	 mov	 rdx, r9
  000fb	e8 00 00 00 00	 call	 memcpy
  00100	eb 1e		 jmp	 SHORT $LN8@pad
$LN6@pad:
  00102	48 85 d2	 test	 rdx, rdx
  00105	74 19		 je	 SHORT $LN8@pad
  00107	4c 2b c9	 sub	 r9, rcx
  0010a	66 0f 1f 44 00
	00		 npad	 6
$LL4@pad:
  00110	41 0f b6 04 09	 movzx	 eax, BYTE PTR [r9+rcx]
  00115	48 ff c1	 inc	 rcx
  00118	48 ff ca	 dec	 rdx
  0011b	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0011e	75 f0		 jne	 SHORT $LL4@pad
$LN8@pad:

; 113  :         if (right)

  00120	4d 85 e4	 test	 r12, r12
  00123	74 22		 je	 SHORT $LN1@pad

; 114  :             memset(STRINGLIB_STR(u) + left + STRINGLIB_LEN(self),
; 115  : 		   fill, right);

  00125	48 83 7f 60 00	 cmp	 QWORD PTR [rdi+96], 0
  0012a	74 07		 je	 SHORT $LN25@pad
  0012c	48 8b 9f 80 00
	00 00		 mov	 rbx, QWORD PTR [rdi+128]
$LN25@pad:
  00133	48 8d 0c 2b	 lea	 rcx, QWORD PTR [rbx+rbp]
  00137	41 0f be d5	 movsx	 edx, r13b
  0013b	4d 8b c4	 mov	 r8, r12
  0013e	48 03 4e 60	 add	 rcx, QWORD PTR [rsi+96]
  00142	e8 00 00 00 00	 call	 memset
$LN1@pad:

; 116  :     }
; 117  : 
; 118  :     return u;

  00147	48 8b c7	 mov	 rax, rdi
  0014a	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
$LN15@pad:

; 119  : }

  0014f	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00154	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00159	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0015d	41 5d		 pop	 r13
  0015f	41 5c		 pop	 r12
  00161	5e		 pop	 rsi
  00162	c3		 ret	 0
pad	ENDP
_TEXT	ENDS
PUBLIC	??_C@_09HKAKFEFH@n?$HMc?3ljust?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_ljust DD imagerel stringlib_ljust
	DD	imagerel stringlib_ljust+153
	DD	imagerel $unwind$stringlib_ljust
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_ljust DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_09HKAKFEFH@n?$HMc?3ljust?$AA@
CONST	SEGMENT
??_C@_09HKAKFEFH@n?$HMc?3ljust?$AA@ DB 'n|c:ljust', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT stringlib_ljust
_TEXT	SEGMENT
self$ = 48
args$ = 56
fillchar$ = 64
width$ = 72
stringlib_ljust PROC					; COMDAT

; 129  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 130  :     Py_ssize_t width;
; 131  :     char fillchar = ' ';
; 132  : 
; 133  :     if (!PyArg_ParseTuple(args, "n|c:ljust", &width, &fillchar))

  0000c	4c 8d 4c 24 40	 lea	 r9, QWORD PTR fillchar$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09HKAKFEFH@n?$HMc?3ljust?$AA@
  00018	4c 8d 44 24 48	 lea	 r8, QWORD PTR width$[rsp]
  0001d	48 8b c8	 mov	 rcx, rax
  00020	c6 44 24 40 20	 mov	 BYTE PTR fillchar$[rsp], 32 ; 00000020H
  00025	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002a	85 c0		 test	 eax, eax
  0002c	75 08		 jne	 SHORT $LN2@stringlib_@31

; 134  :         return NULL;

  0002e	33 c0		 xor	 eax, eax

; 148  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
$LN2@stringlib_@31:

; 135  : 
; 136  :     if (STRINGLIB_LEN(self) >= width && STRINGLIB_CHECK_EXACT(self)) {

  00036	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  0003a	4c 8b 44 24 48	 mov	 r8, QWORD PTR width$[rsp]
  0003f	49 3b c0	 cmp	 rax, r8
  00042	7c 3c		 jl	 SHORT $LN1@stringlib_@31
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyByteArray_Type
  0004b	48 39 4b 58	 cmp	 QWORD PTR [rbx+88], rcx
  0004f	75 2f		 jne	 SHORT $LN1@stringlib_@31

; 137  : #if STRINGLIB_MUTABLE
; 138  :         /* We're defined as returning a copy;  If the object is mutable
; 139  :          * that means we must make an identical copy. */
; 140  :         return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00051	48 85 c0	 test	 rax, rax
  00054	74 15		 je	 SHORT $LN5@stringlib_@31
  00056	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  0005d	48 8b d0	 mov	 rdx, rax
  00060	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize

; 148  : }

  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	5b		 pop	 rbx
  0006a	c3		 ret	 0
$LN5@stringlib_@31:

; 137  : #if STRINGLIB_MUTABLE
; 138  :         /* We're defined as returning a copy;  If the object is mutable
; 139  :          * that means we must make an identical copy. */
; 140  :         return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string
  00072	48 8b d0	 mov	 rdx, rax
  00075	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize

; 148  : }

  0007a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007e	5b		 pop	 rbx
  0007f	c3		 ret	 0
$LN1@stringlib_@31:

; 141  : #else
; 142  :         Py_INCREF(self);
; 143  :         return (PyObject*) self;
; 144  : #endif
; 145  :     }
; 146  : 
; 147  :     return pad(self, 0, width - STRINGLIB_LEN(self), fillchar);

  00080	44 0f b6 4c 24
	40		 movzx	 r9d, BYTE PTR fillchar$[rsp]
  00086	4c 2b c0	 sub	 r8, rax
  00089	33 d2		 xor	 edx, edx
  0008b	48 8b cb	 mov	 rcx, rbx
  0008e	e8 00 00 00 00	 call	 pad

; 148  : }

  00093	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00097	5b		 pop	 rbx
  00098	c3		 ret	 0
stringlib_ljust ENDP
_TEXT	ENDS
PUBLIC	??_C@_09EDNGDHLM@n?$HMc?3rjust?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_rjust DD imagerel stringlib_rjust
	DD	imagerel stringlib_rjust+154
	DD	imagerel $unwind$stringlib_rjust
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_rjust DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_09EDNGDHLM@n?$HMc?3rjust?$AA@
CONST	SEGMENT
??_C@_09EDNGDHLM@n?$HMc?3rjust?$AA@ DB 'n|c:rjust', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT stringlib_rjust
_TEXT	SEGMENT
self$ = 48
args$ = 56
fillchar$ = 64
width$ = 72
stringlib_rjust PROC					; COMDAT

; 159  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 160  :     Py_ssize_t width;
; 161  :     char fillchar = ' ';
; 162  : 
; 163  :     if (!PyArg_ParseTuple(args, "n|c:rjust", &width, &fillchar))

  0000c	4c 8d 4c 24 40	 lea	 r9, QWORD PTR fillchar$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09EDNGDHLM@n?$HMc?3rjust?$AA@
  00018	4c 8d 44 24 48	 lea	 r8, QWORD PTR width$[rsp]
  0001d	48 8b c8	 mov	 rcx, rax
  00020	c6 44 24 40 20	 mov	 BYTE PTR fillchar$[rsp], 32 ; 00000020H
  00025	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002a	85 c0		 test	 eax, eax
  0002c	75 08		 jne	 SHORT $LN2@stringlib_@32

; 164  :         return NULL;

  0002e	33 c0		 xor	 eax, eax

; 178  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
$LN2@stringlib_@32:

; 165  : 
; 166  :     if (STRINGLIB_LEN(self) >= width && STRINGLIB_CHECK_EXACT(self)) {

  00036	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  0003a	48 8b 54 24 48	 mov	 rdx, QWORD PTR width$[rsp]
  0003f	48 3b c2	 cmp	 rax, rdx
  00042	7c 3c		 jl	 SHORT $LN1@stringlib_@32
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyByteArray_Type
  0004b	48 39 4b 58	 cmp	 QWORD PTR [rbx+88], rcx
  0004f	75 2f		 jne	 SHORT $LN1@stringlib_@32

; 167  : #if STRINGLIB_MUTABLE
; 168  :         /* We're defined as returning a copy;  If the object is mutable
; 169  :          * that means we must make an identical copy. */
; 170  :         return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00051	48 85 c0	 test	 rax, rax
  00054	74 15		 je	 SHORT $LN5@stringlib_@32
  00056	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  0005d	48 8b d0	 mov	 rdx, rax
  00060	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize

; 178  : }

  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	5b		 pop	 rbx
  0006a	c3		 ret	 0
$LN5@stringlib_@32:

; 167  : #if STRINGLIB_MUTABLE
; 168  :         /* We're defined as returning a copy;  If the object is mutable
; 169  :          * that means we must make an identical copy. */
; 170  :         return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string
  00072	48 8b d0	 mov	 rdx, rax
  00075	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize

; 178  : }

  0007a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007e	5b		 pop	 rbx
  0007f	c3		 ret	 0
$LN1@stringlib_@32:

; 171  : #else
; 172  :         Py_INCREF(self);
; 173  :         return (PyObject*) self;
; 174  : #endif
; 175  :     }
; 176  : 
; 177  :     return pad(self, width - STRINGLIB_LEN(self), 0, fillchar);

  00080	44 0f b6 4c 24
	40		 movzx	 r9d, BYTE PTR fillchar$[rsp]
  00086	48 2b d0	 sub	 rdx, rax
  00089	45 33 c0	 xor	 r8d, r8d
  0008c	48 8b cb	 mov	 rcx, rbx
  0008f	e8 00 00 00 00	 call	 pad

; 178  : }

  00094	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00098	5b		 pop	 rbx
  00099	c3		 ret	 0
stringlib_rjust ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@HIGBEACG@n?$HMc?3center?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_center DD imagerel stringlib_center
	DD	imagerel stringlib_center+183
	DD	imagerel $unwind$stringlib_center
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_center DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0L@HIGBEACG@n?$HMc?3center?$AA@
CONST	SEGMENT
??_C@_0L@HIGBEACG@n?$HMc?3center?$AA@ DB 'n|c:center', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT stringlib_center
_TEXT	SEGMENT
self$ = 48
args$ = 56
fillchar$ = 64
width$ = 72
stringlib_center PROC					; COMDAT

; 189  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 190  :     Py_ssize_t marg, left;
; 191  :     Py_ssize_t width;
; 192  :     char fillchar = ' ';
; 193  : 
; 194  :     if (!PyArg_ParseTuple(args, "n|c:center", &width, &fillchar))

  0000c	4c 8d 4c 24 40	 lea	 r9, QWORD PTR fillchar$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@HIGBEACG@n?$HMc?3center?$AA@
  00018	4c 8d 44 24 48	 lea	 r8, QWORD PTR width$[rsp]
  0001d	48 8b c8	 mov	 rcx, rax
  00020	c6 44 24 40 20	 mov	 BYTE PTR fillchar$[rsp], 32 ; 00000020H
  00025	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002a	85 c0		 test	 eax, eax
  0002c	75 08		 jne	 SHORT $LN2@stringlib_@33

; 195  :         return NULL;

  0002e	33 c0		 xor	 eax, eax

; 212  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
$LN2@stringlib_@33:

; 196  : 
; 197  :     if (STRINGLIB_LEN(self) >= width && STRINGLIB_CHECK_EXACT(self)) {

  00036	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  0003a	48 8b 54 24 48	 mov	 rdx, QWORD PTR width$[rsp]
  0003f	48 3b c2	 cmp	 rax, rdx
  00042	7c 3c		 jl	 SHORT $LN1@stringlib_@33
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyByteArray_Type
  0004b	48 39 4b 58	 cmp	 QWORD PTR [rbx+88], rcx
  0004f	75 2f		 jne	 SHORT $LN1@stringlib_@33

; 198  : #if STRINGLIB_MUTABLE
; 199  :         /* We're defined as returning a copy;  If the object is mutable
; 200  :          * that means we must make an identical copy. */
; 201  :         return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  00051	48 85 c0	 test	 rax, rax
  00054	74 15		 je	 SHORT $LN5@stringlib_@33
  00056	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  0005d	48 8b d0	 mov	 rdx, rax
  00060	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize

; 212  : }

  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	5b		 pop	 rbx
  0006a	c3		 ret	 0
$LN5@stringlib_@33:

; 198  : #if STRINGLIB_MUTABLE
; 199  :         /* We're defined as returning a copy;  If the object is mutable
; 200  :          * that means we must make an identical copy. */
; 201  :         return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));

  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string
  00072	48 8b d0	 mov	 rdx, rax
  00075	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize

; 212  : }

  0007a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007e	5b		 pop	 rbx
  0007f	c3		 ret	 0
$LN1@stringlib_@33:

; 202  : #else
; 203  :         Py_INCREF(self);
; 204  :         return (PyObject*) self;
; 205  : #endif
; 206  :     }
; 207  : 
; 208  :     marg = width - STRINGLIB_LEN(self);
; 209  :     left = marg / 2 + (marg & width & 1);
; 210  : 
; 211  :     return pad(self, left, marg - left, fillchar);

  00080	44 0f b6 4c 24
	40		 movzx	 r9d, BYTE PTR fillchar$[rsp]
  00086	4c 8b c2	 mov	 r8, rdx
  00089	4c 2b c0	 sub	 r8, rax
  0008c	49 8b c8	 mov	 rcx, r8
  0008f	49 8b c0	 mov	 rax, r8
  00092	48 23 ca	 and	 rcx, rdx
  00095	48 99		 cdq
  00097	48 2b c2	 sub	 rax, rdx
  0009a	83 e1 01	 and	 ecx, 1
  0009d	48 d1 f8	 sar	 rax, 1
  000a0	48 03 c8	 add	 rcx, rax
  000a3	4c 2b c1	 sub	 r8, rcx
  000a6	48 8b d1	 mov	 rdx, rcx
  000a9	48 8b cb	 mov	 rcx, rbx
  000ac	e8 00 00 00 00	 call	 pad

; 212  : }

  000b1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b5	5b		 pop	 rbx
  000b6	c3		 ret	 0
stringlib_center ENDP
_TEXT	ENDS
PUBLIC	??_C@_07CBMPGKCP@n?3zfill?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringlib_zfill DD imagerel stringlib_zfill
	DD	imagerel stringlib_zfill+48
	DD	imagerel $unwind$stringlib_zfill
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$stringlib_zfill DD imagerel stringlib_zfill+48
	DD	imagerel stringlib_zfill+104
	DD	imagerel $chain$0$stringlib_zfill
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$stringlib_zfill DD imagerel stringlib_zfill+104
	DD	imagerel stringlib_zfill+133
	DD	imagerel $chain$2$stringlib_zfill
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$stringlib_zfill DD imagerel stringlib_zfill+133
	DD	imagerel stringlib_zfill+172
	DD	imagerel $chain$4$stringlib_zfill
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$stringlib_zfill DD imagerel stringlib_zfill+172
	DD	imagerel stringlib_zfill+229
	DD	imagerel $chain$6$stringlib_zfill
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$stringlib_zfill DD 020021H
	DD	067400H
	DD	imagerel stringlib_zfill
	DD	imagerel stringlib_zfill+48
	DD	imagerel $unwind$stringlib_zfill
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$stringlib_zfill DD 020021H
	DD	067400H
	DD	imagerel stringlib_zfill
	DD	imagerel stringlib_zfill+48
	DD	imagerel $unwind$stringlib_zfill
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$stringlib_zfill DD 020021H
	DD	067400H
	DD	imagerel stringlib_zfill
	DD	imagerel stringlib_zfill+48
	DD	imagerel $unwind$stringlib_zfill
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$stringlib_zfill DD 020521H
	DD	067405H
	DD	imagerel stringlib_zfill
	DD	imagerel stringlib_zfill+48
	DD	imagerel $unwind$stringlib_zfill
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringlib_zfill DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_07CBMPGKCP@n?3zfill?$AA@
CONST	SEGMENT
??_C@_07CBMPGKCP@n?3zfill?$AA@ DB 'n:zfill', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT stringlib_zfill
_TEXT	SEGMENT
self$ = 48
args$ = 56
width$ = 64
stringlib_zfill PROC					; COMDAT

; 222  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 223  :     Py_ssize_t fill;
; 224  :     PyObject *s;
; 225  :     char *p;
; 226  :     Py_ssize_t width;
; 227  : 
; 228  :     if (!PyArg_ParseTuple(args, "n:zfill", &width))

  0000c	4c 8d 44 24 40	 lea	 r8, QWORD PTR width$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07CBMPGKCP@n?3zfill?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00020	85 c0		 test	 eax, eax
  00022	75 08		 jne	 SHORT $LN7@stringlib_@34

; 229  :         return NULL;

  00024	33 c0		 xor	 eax, eax

; 264  : }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
$LN7@stringlib_@34:

; 230  : 
; 231  :     if (STRINGLIB_LEN(self) >= width) {

  0002c	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00030	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00035	48 8b 7c 24 40	 mov	 rdi, QWORD PTR width$[rsp]
  0003a	48 3b cf	 cmp	 rcx, rdi
  0003d	7c 46		 jl	 SHORT $LN4@stringlib_@34

; 232  :         if (STRINGLIB_CHECK_EXACT(self)) {

  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type

; 233  : #if STRINGLIB_MUTABLE
; 234  :             /* We're defined as returning a copy;  If the object is mutable
; 235  :              * that means we must make an identical copy. */
; 236  :             return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));
; 237  : #else
; 238  :             Py_INCREF(self);
; 239  :             return (PyObject*) self;
; 240  : #endif
; 241  :         }
; 242  :         else
; 243  :             return STRINGLIB_NEW(
; 244  :                 STRINGLIB_STR(self),
; 245  :                 STRINGLIB_LEN(self)
; 246  :             );

  00046	48 85 c9	 test	 rcx, rcx
  00049	74 1d		 je	 SHORT $LN12@stringlib_@34
  0004b	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]
  00052	48 8b d1	 mov	 rdx, rcx
  00055	48 8b c8	 mov	 rcx, rax
  00058	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0005d	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 264  : }

  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5b		 pop	 rbx
  00067	c3		 ret	 0
$LN12@stringlib_@34:

; 233  : #if STRINGLIB_MUTABLE
; 234  :             /* We're defined as returning a copy;  If the object is mutable
; 235  :              * that means we must make an identical copy. */
; 236  :             return STRINGLIB_NEW(STRINGLIB_STR(self), STRINGLIB_LEN(self));
; 237  : #else
; 238  :             Py_INCREF(self);
; 239  :             return (PyObject*) self;
; 240  : #endif
; 241  :         }
; 242  :         else
; 243  :             return STRINGLIB_NEW(
; 244  :                 STRINGLIB_STR(self),
; 245  :                 STRINGLIB_LEN(self)
; 246  :             );

  00068	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
  0006f	48 8b d1	 mov	 rdx, rcx
  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0007a	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 264  : }

  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	5b		 pop	 rbx
  00084	c3		 ret	 0
$LN4@stringlib_@34:

; 247  :     }
; 248  : 
; 249  :     fill = width - STRINGLIB_LEN(self);

  00085	48 2b f9	 sub	 rdi, rcx

; 250  : 
; 251  :     s = pad(self, fill, 0, '0');

  00088	41 b1 30	 mov	 r9b, 48			; 00000030H
  0008b	45 33 c0	 xor	 r8d, r8d
  0008e	48 8b d7	 mov	 rdx, rdi
  00091	48 8b cb	 mov	 rcx, rbx
  00094	e8 00 00 00 00	 call	 pad
  00099	4c 8b d8	 mov	 r11, rax

; 252  : 
; 253  :     if (s == NULL)

  0009c	48 85 c0	 test	 rax, rax
  0009f	75 0b		 jne	 SHORT $LN3@stringlib_@34
  000a1	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 264  : }

  000a6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000aa	5b		 pop	 rbx
  000ab	c3		 ret	 0
$LN3@stringlib_@34:

; 254  :         return NULL;
; 255  : 
; 256  :     p = STRINGLIB_STR(s);

  000ac	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000b1	74 09		 je	 SHORT $LN14@stringlib_@34
  000b3	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000ba	eb 07		 jmp	 SHORT $LN15@stringlib_@34
$LN14@stringlib_@34:
  000bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_PyByteArray_empty_string
$LN15@stringlib_@34:

; 257  :     if (p[fill] == '+' || p[fill] == '-') {

  000c3	0f b6 0c 38	 movzx	 ecx, BYTE PTR [rax+rdi]
  000c7	80 f9 2b	 cmp	 cl, 43			; 0000002bH
  000ca	74 05		 je	 SHORT $LN1@stringlib_@34
  000cc	80 f9 2d	 cmp	 cl, 45			; 0000002dH
  000cf	75 06		 jne	 SHORT $LN2@stringlib_@34
$LN1@stringlib_@34:

; 258  :         /* move sign to beginning of string */
; 259  :         p[0] = p[fill];

  000d1	88 08		 mov	 BYTE PTR [rax], cl

; 260  :         p[fill] = '0';

  000d3	c6 04 38 30	 mov	 BYTE PTR [rax+rdi], 48	; 00000030H
$LN2@stringlib_@34:

; 261  :     }
; 262  : 
; 263  :     return (PyObject*) s;

  000d7	49 8b c3	 mov	 rax, r11
  000da	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 264  : }

  000df	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e3	5b		 pop	 rbx
  000e4	c3		 ret	 0
stringlib_zfill ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@BAIIFBKB@find?1rfind?1index?1rindex?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\find.h
pdata	SEGMENT
$pdata$bytearray_find_internal DD imagerel bytearray_find_internal
	DD	imagerel bytearray_find_internal+689
	DD	imagerel $unwind$bytearray_find_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_find_internal DD 0d2401H
	DD	0247424H
	DD	0236424H
	DD	0223424H
	DD	01c0124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
xdata	ENDS
;	COMDAT ??_C@_0BI@BAIIFBKB@find?1rfind?1index?1rindex?$AA@
CONST	SEGMENT
??_C@_0BI@BAIIFBKB@find?1rfind?1index?1rindex?$AA@ DB 'find/rfind/index/r'
	DB	'index', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
CONST	ENDS
;	COMDAT bytearray_find_internal
_TEXT	SEGMENT
tmp_end$26887 = 48
tmp_start$26886 = 56
obj_end$26889 = 64
tmp_subobj$26885 = 72
format$26890 = 80
subbuf$ = 144
self$ = 272
args$ = 280
dir$ = 288
obj_start$26888 = 296
byte$ = 296
bytearray_find_internal PROC				; COMDAT

; 1078 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	55		 push	 rbp
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 8d 6c 24 c9	 lea	 rbp, QWORD PTR [rsp-55]
  0001d	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00024	4c 8b e1	 mov	 r12, rcx

; 1079 :     PyObject *subobj;
; 1080 :     char byte;
; 1081 :     Py_buffer subbuf;
; 1082 :     const char *sub;
; 1083 :     Py_ssize_t sub_len;
; 1084 :     Py_ssize_t start=0, end=PY_SSIZE_T_MAX;
; 1085 :     Py_ssize_t res;
; 1086 : 
; 1087 :     if (!stringlib_parse_args_finds_byte("find/rfind/index/rindex",
; 1088 :                                          args, &subobj, &byte, &start, &end))

  00027	48 83 c9 ff	 or	 rcx, -1
  0002b	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00035	48 89 45 87	 mov	 QWORD PTR tmp_end$26887[rbp-169], rax
  00039	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@
  0003f	45 8b f0	 mov	 r14d, r8d
  00042	89 45 a7	 mov	 DWORD PTR format$26890[rbp-169], eax
  00045	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@+4
  0004c	48 8b da	 mov	 rbx, rdx
  0004f	66 89 45 ab	 mov	 WORD PTR format$26890[rbp-165], ax
  00053	33 c0		 xor	 eax, eax
  00055	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  0005c	48 89 45 ad	 mov	 QWORD PTR format$26890[rbp-163], rax
  00060	48 89 45 b5	 mov	 QWORD PTR format$26890[rbp-155], rax
  00064	48 89 45 bd	 mov	 QWORD PTR format$26890[rbp-147], rax
  00068	48 89 45 c5	 mov	 QWORD PTR format$26890[rbp-139], rax
  0006c	48 89 45 cd	 mov	 QWORD PTR format$26890[rbp-131], rax
  00070	89 45 d5	 mov	 DWORD PTR format$26890[rbp-123], eax
  00073	48 8d 7d a7	 lea	 rdi, QWORD PTR format$26890[rbp-169]
  00077	41 b8 31 00 00
	00		 mov	 r8d, 49			; 00000031H
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@BAIIFBKB@find?1rfind?1index?1rindex?$AA@
  00084	f2 ae		 repne scasb
  00086	45 33 ff	 xor	 r15d, r15d
  00089	48 89 75 7f	 mov	 QWORD PTR obj_start$26888[rbp-169], rsi
  0008d	48 f7 d1	 not	 rcx
  00090	4c 89 7d 8f	 mov	 QWORD PTR tmp_start$26886[rbp-169], r15
  00094	48 89 75 97	 mov	 QWORD PTR obj_end$26889[rbp-169], rsi
  00098	48 ff c9	 dec	 rcx
  0009b	4c 2b c1	 sub	 r8, rcx
  0009e	48 8d 4c 0d a7	 lea	 rcx, QWORD PTR format$26890[rbp+rcx-169]
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
  000a9	48 8d 45 97	 lea	 rax, QWORD PTR obj_end$26889[rbp-169]
  000ad	4c 8d 4d 7f	 lea	 r9, QWORD PTR obj_start$26888[rbp-169]
  000b1	4c 8d 45 9f	 lea	 r8, QWORD PTR tmp_subobj$26885[rbp-169]
  000b5	48 8d 55 a7	 lea	 rdx, QWORD PTR format$26890[rbp-169]
  000b9	48 8b cb	 mov	 rcx, rbx
  000bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c1	44 88 7d d8	 mov	 BYTE PTR format$26890[rbp-120], r15b
  000c5	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 b7 01 00
	00		 je	 $LN46@bytearray_@15
  000d2	48 8b 4d 7f	 mov	 rcx, QWORD PTR obj_start$26888[rbp-169]
  000d6	48 3b ce	 cmp	 rcx, rsi
  000d9	74 11		 je	 SHORT $LN24@bytearray_@15
  000db	48 8d 55 8f	 lea	 rdx, QWORD PTR tmp_start$26886[rbp-169]
  000df	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000e4	85 c0		 test	 eax, eax
  000e6	0f 84 9d 01 00
	00		 je	 $LN46@bytearray_@15
$LN24@bytearray_@15:
  000ec	48 8b 4d 97	 mov	 rcx, QWORD PTR obj_end$26889[rbp-169]
  000f0	48 3b ce	 cmp	 rcx, rsi
  000f3	74 11		 je	 SHORT $LN22@bytearray_@15
  000f5	48 8d 55 87	 lea	 rdx, QWORD PTR tmp_end$26887[rbp-169]
  000f9	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000fe	85 c0		 test	 eax, eax
  00100	0f 84 83 01 00
	00		 je	 $LN46@bytearray_@15
$LN22@bytearray_@15:
  00106	48 8b 75 9f	 mov	 rsi, QWORD PTR tmp_subobj$26885[rbp-169]
  0010a	48 8b 5d 8f	 mov	 rbx, QWORD PTR tmp_start$26886[rbp-169]
  0010e	48 8b 7d 87	 mov	 rdi, QWORD PTR tmp_end$26887[rbp-169]
  00112	48 8b ce	 mov	 rcx, rsi
  00115	e8 00 00 00 00	 call	 PyNumber_Check
  0011a	85 c0		 test	 eax, eax
  0011c	74 3f		 je	 SHORT $LN47@bytearray_@15
  0011e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00125	48 8b ce	 mov	 rcx, rsi
  00128	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  0012d	48 83 f8 ff	 cmp	 rax, -1
  00131	75 51		 jne	 SHORT $LN16@bytearray_@15
  00133	e8 00 00 00 00	 call	 PyErr_Occurred
  00138	48 85 c0	 test	 rax, rax
  0013b	0f 84 35 01 00
	00		 je	 $LN14@bytearray_@15
  00141	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00148	48 8b c8	 mov	 rcx, rax
  0014b	e8 00 00 00 00	 call	 PyErr_GivenExceptionMatches
  00150	85 c0		 test	 eax, eax
  00152	0f 85 1e 01 00
	00		 jne	 $LN14@bytearray_@15
  00158	e8 00 00 00 00	 call	 PyErr_Clear
$LN47@bytearray_@15:
  0015d	4c 8b ee	 mov	 r13, rsi

; 1090 : 
; 1091 :     if (subobj) {

  00160	48 85 f6	 test	 rsi, rsi
  00163	74 31		 je	 SHORT $LN6@bytearray_@15

; 1092 :         if (_getbuffer(subobj, &subbuf) < 0)

  00165	48 8d 55 e7	 lea	 rdx, QWORD PTR subbuf$[rbp-169]
  00169	48 8b ce	 mov	 rcx, rsi
  0016c	e8 00 00 00 00	 call	 _getbuffer
  00171	48 85 c0	 test	 rax, rax

; 1093 :             return -2;

  00174	0f 88 0f 01 00
	00		 js	 $LN46@bytearray_@15

; 1094 : 
; 1095 :         sub = subbuf.buf;

  0017a	4c 8b 45 e7	 mov	 r8, QWORD PTR subbuf$[rbp-169]

; 1096 :         sub_len = subbuf.len;

  0017e	4c 8b 4d f7	 mov	 r9, QWORD PTR subbuf$[rbp-153]

; 1097 :     }
; 1098 :     else {

  00182	eb 1c		 jmp	 SHORT $LN4@bytearray_@15

; 1079 :     PyObject *subobj;
; 1080 :     char byte;
; 1081 :     Py_buffer subbuf;
; 1082 :     const char *sub;
; 1083 :     Py_ssize_t sub_len;
; 1084 :     Py_ssize_t start=0, end=PY_SSIZE_T_MAX;
; 1085 :     Py_ssize_t res;
; 1086 : 
; 1087 :     if (!stringlib_parse_args_finds_byte("find/rfind/index/rindex",
; 1088 :                                          args, &subobj, &byte, &start, &end))

$LN16@bytearray_@15:
  00184	48 3d ff 00 00
	00		 cmp	 rax, 255		; 000000ffH
  0018a	0f 87 e6 00 00
	00		 ja	 $LN14@bytearray_@15
  00190	4d 8b ef	 mov	 r13, r15
  00193	88 45 7f	 mov	 BYTE PTR byte$[rbp-169], al
$LN6@bytearray_@15:

; 1099 :         sub = &byte;

  00196	4c 8d 45 7f	 lea	 r8, QWORD PTR byte$[rbp-169]

; 1100 :         sub_len = 1;

  0019a	41 b9 01 00 00
	00		 mov	 r9d, 1
$LN4@bytearray_@15:

; 1101 :     }
; 1102 : 
; 1103 :     if (dir > 0)
; 1104 :         res = stringlib_find_slice(
; 1105 :             PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self),
; 1106 :             sub, sub_len, start, end);

  001a0	49 8b 4c 24 60	 mov	 rcx, QWORD PTR [r12+96]
  001a5	45 85 f6	 test	 r14d, r14d
  001a8	7e 5c		 jle	 SHORT $LN3@bytearray_@15
  001aa	48 85 c9	 test	 rcx, rcx
  001ad	74 0a		 je	 SHORT $LN10@bytearray_@15
  001af	49 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR [r12+128]
  001b7	eb 07		 jmp	 SHORT $LN11@bytearray_@15
$LN10@bytearray_@15:
  001b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_PyByteArray_empty_string
$LN11@bytearray_@15:
  001c0	48 3b f9	 cmp	 rdi, rcx
  001c3	7e 05		 jle	 SHORT $LN34@bytearray_@15
  001c5	48 8b f9	 mov	 rdi, rcx
  001c8	eb 13		 jmp	 SHORT $LN31@bytearray_@15
$LN34@bytearray_@15:
  001ca	48 85 ff	 test	 rdi, rdi
  001cd	79 0e		 jns	 SHORT $LN31@bytearray_@15
  001cf	48 8d 04 39	 lea	 rax, QWORD PTR [rcx+rdi]
  001d3	48 8b f8	 mov	 rdi, rax
  001d6	48 85 c0	 test	 rax, rax
  001d9	49 0f 48 ff	 cmovs	 rdi, r15
$LN31@bytearray_@15:
  001dd	48 85 db	 test	 rbx, rbx
  001e0	79 0e		 jns	 SHORT $LN29@bytearray_@15
  001e2	48 8d 04 19	 lea	 rax, QWORD PTR [rcx+rbx]
  001e6	48 8b d8	 mov	 rbx, rax
  001e9	48 85 c0	 test	 rax, rax
  001ec	49 0f 48 df	 cmovs	 rbx, r15
$LN29@bytearray_@15:
  001f0	48 2b fb	 sub	 rdi, rbx
  001f3	48 8d 0c 1a	 lea	 rcx, QWORD PTR [rdx+rbx]
  001f7	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  001fc	48 8b d7	 mov	 rdx, rdi
  001ff	e8 00 00 00 00	 call	 stringlib_find

; 1107 :     else

  00204	eb 5a		 jmp	 SHORT $LN48@bytearray_@15
$LN3@bytearray_@15:

; 1108 :         res = stringlib_rfind_slice(
; 1109 :             PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self),
; 1110 :             sub, sub_len, start, end);

  00206	48 85 c9	 test	 rcx, rcx
  00209	74 0a		 je	 SHORT $LN12@bytearray_@15
  0020b	49 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR [r12+128]
  00213	eb 07		 jmp	 SHORT $LN13@bytearray_@15
$LN12@bytearray_@15:
  00215	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_PyByteArray_empty_string
$LN13@bytearray_@15:
  0021c	48 3b f9	 cmp	 rdi, rcx
  0021f	7e 05		 jle	 SHORT $LN42@bytearray_@15
  00221	48 8b f9	 mov	 rdi, rcx
  00224	eb 13		 jmp	 SHORT $LN39@bytearray_@15
$LN42@bytearray_@15:
  00226	48 85 ff	 test	 rdi, rdi
  00229	79 0e		 jns	 SHORT $LN39@bytearray_@15
  0022b	48 8d 04 39	 lea	 rax, QWORD PTR [rcx+rdi]
  0022f	48 8b f8	 mov	 rdi, rax
  00232	48 85 c0	 test	 rax, rax
  00235	49 0f 48 ff	 cmovs	 rdi, r15
$LN39@bytearray_@15:
  00239	48 85 db	 test	 rbx, rbx
  0023c	79 0e		 jns	 SHORT $LN37@bytearray_@15
  0023e	48 8d 04 19	 lea	 rax, QWORD PTR [rcx+rbx]
  00242	48 8b d8	 mov	 rbx, rax
  00245	48 85 c0	 test	 rax, rax
  00248	49 0f 48 df	 cmovs	 rbx, r15
$LN37@bytearray_@15:
  0024c	48 2b fb	 sub	 rdi, rbx
  0024f	48 8d 0c 1a	 lea	 rcx, QWORD PTR [rdx+rbx]
  00253	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00258	48 8b d7	 mov	 rdx, rdi
  0025b	e8 00 00 00 00	 call	 stringlib_rfind
$LN48@bytearray_@15:
  00260	48 8b f8	 mov	 rdi, rax

; 1111 : 
; 1112 :     if (subobj)

  00263	4d 85 ed	 test	 r13, r13
  00266	74 09		 je	 SHORT $LN1@bytearray_@15

; 1113 :         PyBuffer_Release(&subbuf);

  00268	48 8d 4d e7	 lea	 rcx, QWORD PTR subbuf$[rbp-169]
  0026c	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@bytearray_@15:

; 1114 : 
; 1115 :     return res;

  00271	48 8b c7	 mov	 rax, rdi
  00274	eb 1a		 jmp	 SHORT $LN8@bytearray_@15

; 1079 :     PyObject *subobj;
; 1080 :     char byte;
; 1081 :     Py_buffer subbuf;
; 1082 :     const char *sub;
; 1083 :     Py_ssize_t sub_len;
; 1084 :     Py_ssize_t start=0, end=PY_SSIZE_T_MAX;
; 1085 :     Py_ssize_t res;
; 1086 : 
; 1087 :     if (!stringlib_parse_args_finds_byte("find/rfind/index/rindex",
; 1088 :                                          args, &subobj, &byte, &start, &end))

$LN14@bytearray_@15:
  00276	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0027d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@
  00284	e8 00 00 00 00	 call	 PyErr_SetString
$LN46@bytearray_@15:

; 1089 :         return -2;

  00289	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
$LN8@bytearray_@15:

; 1116 : }

  00290	4c 8d 9c 24 e0
	00 00 00	 lea	 r11, QWORD PTR [rsp+224]
  00298	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  0029c	49 8b 73 38	 mov	 rsi, QWORD PTR [r11+56]
  002a0	49 8b 7b 40	 mov	 rdi, QWORD PTR [r11+64]
  002a4	49 8b e3	 mov	 rsp, r11
  002a7	41 5f		 pop	 r15
  002a9	41 5e		 pop	 r14
  002ab	41 5d		 pop	 r13
  002ad	41 5c		 pop	 r12
  002af	5d		 pop	 rbp
  002b0	c3		 ret	 0
bytearray_find_internal ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_find DD imagerel bytearray_find
	DD	imagerel bytearray_find+40
	DD	imagerel $unwind$bytearray_find
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_find DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytearray_find
_TEXT	SEGMENT
self$ = 48
args$ = 56
bytearray_find PROC					; COMDAT

; 1129 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1130 :     Py_ssize_t result = bytearray_find_internal(self, args, +1);

  00004	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000a	e8 00 00 00 00	 call	 bytearray_find_internal

; 1131 :     if (result == -2)

  0000f	48 83 f8 fe	 cmp	 rax, -2
  00013	75 07		 jne	 SHORT $LN1@bytearray_@16

; 1132 :         return NULL;

  00015	33 c0		 xor	 eax, eax

; 1134 : }

  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	c3		 ret	 0
$LN1@bytearray_@16:

; 1133 :     return PyLong_FromSsize_t(result);

  0001c	48 8b c8	 mov	 rcx, rax

; 1134 : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
bytearray_find ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\fastsearch.h
pdata	SEGMENT
$pdata$bytearray_count DD imagerel bytearray_count
	DD	imagerel bytearray_count+1010
	DD	imagerel $unwind$bytearray_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_count DD 0b9901H
	DD	029d499H
	DD	0200117H
	DD	0e009f00bH
	DD	07005c007H
	DD	030036004H
	DD	05002H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
xdata	ENDS
;	COMDAT bytearray_count
_TEXT	SEGMENT
$T27250 = 48
sub_obj$1$ = 56
tmp_end$27008 = 64
tmp_start$27007 = 72
obj_end$27010 = 80
obj_start$27009 = 88
tmp_subobj$27006 = 96
w$1$ = 104
skip$1$ = 112
format$27011 = 120
vsub$ = 176
byte$ = 320
self$ = 320
args$ = 328
sub$1$ = 336
sub_len$1$ = 344
bytearray_count PROC					; COMDAT

; 1145 : {

  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 56		 push	 r14
  00009	41 57		 push	 r15
  0000b	48 8d 6c 24 d9	 lea	 rbp, QWORD PTR [rsp-39]
  00010	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H

; 1146 :     PyObject *sub_obj;
; 1147 :     const char *str = PyByteArray_AS_STRING(self), *sub;

  00017	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  0001c	48 8b da	 mov	 rbx, rdx
  0001f	4c 8b e1	 mov	 r12, rcx
  00022	74 09		 je	 SHORT $LN14@bytearray_@17
  00024	4c 8b b1 80 00
	00 00		 mov	 r14, QWORD PTR [rcx+128]
  0002b	eb 07		 jmp	 SHORT $LN15@bytearray_@17
$LN14@bytearray_@17:
  0002d	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:_PyByteArray_empty_string
$LN15@bytearray_@17:

; 1148 :     Py_ssize_t sub_len;
; 1149 :     char byte;
; 1150 :     Py_ssize_t start = 0, end = PY_SSIZE_T_MAX;
; 1151 : 
; 1152 :     Py_buffer vsub;
; 1153 :     PyObject *count_obj;
; 1154 : 
; 1155 :     if (!stringlib_parse_args_finds_byte("count", args, &sub_obj, &byte,
; 1156 :                                          &start, &end))

  00034	48 83 c9 ff	 or	 rcx, -1
  00038	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00042	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  00049	48 89 44 24 40	 mov	 QWORD PTR tmp_end$27008[rsp], rax
  0004e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@
  00054	48 8d 7d 9f	 lea	 rdi, QWORD PTR format$27011[rbp-217]
  00058	89 45 9f	 mov	 DWORD PTR format$27011[rbp-217], eax
  0005b	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@+4
  00062	41 b8 31 00 00
	00		 mov	 r8d, 49			; 00000031H
  00068	66 89 45 a3	 mov	 WORD PTR format$27011[rbp-213], ax
  0006c	33 c0		 xor	 eax, eax
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05IOMEMJEC@count?$AA@
  00075	48 89 45 a5	 mov	 QWORD PTR format$27011[rbp-211], rax
  00079	48 89 45 ad	 mov	 QWORD PTR format$27011[rbp-203], rax
  0007d	48 89 45 b5	 mov	 QWORD PTR format$27011[rbp-195], rax
  00081	48 89 45 bd	 mov	 QWORD PTR format$27011[rbp-187], rax
  00085	48 89 45 c5	 mov	 QWORD PTR format$27011[rbp-179], rax
  00089	89 45 cd	 mov	 DWORD PTR format$27011[rbp-171], eax
  0008c	f2 ae		 repne scasb
  0008e	45 33 ff	 xor	 r15d, r15d
  00091	4c 89 ac 24 48
	01 00 00	 mov	 QWORD PTR [rsp+328], r13
  00099	48 f7 d1	 not	 rcx
  0009c	4c 89 7c 24 48	 mov	 QWORD PTR tmp_start$27007[rsp], r15
  000a1	48 89 74 24 58	 mov	 QWORD PTR obj_start$27009[rsp], rsi
  000a6	48 ff c9	 dec	 rcx
  000a9	48 89 74 24 50	 mov	 QWORD PTR obj_end$27010[rsp], rsi
  000ae	4c 2b c1	 sub	 r8, rcx
  000b1	48 8d 4c 0d 9f	 lea	 rcx, QWORD PTR format$27011[rbp+rcx-217]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
  000bc	48 8d 44 24 50	 lea	 rax, QWORD PTR obj_end$27010[rsp]
  000c1	4c 8d 4c 24 58	 lea	 r9, QWORD PTR obj_start$27009[rsp]
  000c6	4c 8d 45 87	 lea	 r8, QWORD PTR tmp_subobj$27006[rbp-217]
  000ca	48 8d 55 9f	 lea	 rdx, QWORD PTR format$27011[rbp-217]
  000ce	48 8b cb	 mov	 rcx, rbx
  000d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d6	44 88 7d d0	 mov	 BYTE PTR format$27011[rbp-168], r15b
  000da	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000df	85 c0		 test	 eax, eax
  000e1	0f 84 ef 02 00
	00		 je	 $LN121@bytearray_@17
  000e7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR obj_start$27009[rsp]
  000ec	48 3b ce	 cmp	 rcx, rsi
  000ef	74 12		 je	 SHORT $LN26@bytearray_@17
  000f1	48 8d 54 24 48	 lea	 rdx, QWORD PTR tmp_start$27007[rsp]
  000f6	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000fb	85 c0		 test	 eax, eax
  000fd	0f 84 d3 02 00
	00		 je	 $LN121@bytearray_@17
$LN26@bytearray_@17:
  00103	48 8b 4c 24 50	 mov	 rcx, QWORD PTR obj_end$27010[rsp]
  00108	48 3b ce	 cmp	 rcx, rsi
  0010b	74 12		 je	 SHORT $LN24@bytearray_@17
  0010d	48 8d 54 24 40	 lea	 rdx, QWORD PTR tmp_end$27008[rsp]
  00112	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  00117	85 c0		 test	 eax, eax
  00119	0f 84 b7 02 00
	00		 je	 $LN121@bytearray_@17
$LN24@bytearray_@17:
  0011f	48 8b 75 87	 mov	 rsi, QWORD PTR tmp_subobj$27006[rbp-217]
  00123	48 8b 5c 24 48	 mov	 rbx, QWORD PTR tmp_start$27007[rsp]
  00128	48 8b 7c 24 40	 mov	 rdi, QWORD PTR tmp_end$27008[rsp]
  0012d	48 8b ce	 mov	 rcx, rsi
  00130	e8 00 00 00 00	 call	 PyNumber_Check
  00135	41 bd 01 00 00
	00		 mov	 r13d, 1
  0013b	85 c0		 test	 eax, eax
  0013d	74 3f		 je	 SHORT $LN127@bytearray_@17
  0013f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00146	48 8b ce	 mov	 rcx, rsi
  00149	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  0014e	48 83 f8 ff	 cmp	 rax, -1
  00152	75 53		 jne	 SHORT $LN18@bytearray_@17
  00154	e8 00 00 00 00	 call	 PyErr_Occurred
  00159	48 85 c0	 test	 rax, rax
  0015c	0f 84 61 02 00
	00		 je	 $LN16@bytearray_@17
  00162	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00169	48 8b c8	 mov	 rcx, rax
  0016c	e8 00 00 00 00	 call	 PyErr_GivenExceptionMatches
  00171	85 c0		 test	 eax, eax
  00173	0f 85 4a 02 00
	00		 jne	 $LN16@bytearray_@17
  00179	e8 00 00 00 00	 call	 PyErr_Clear
$LN127@bytearray_@17:
  0017e	48 89 74 24 38	 mov	 QWORD PTR sub_obj$1$[rsp], rsi

; 1158 : 
; 1159 :     if (sub_obj) {

  00183	48 85 f6	 test	 rsi, rsi
  00186	74 33		 je	 SHORT $LN10@bytearray_@17

; 1160 :         if (_getbuffer(sub_obj, &vsub) < 0)

  00188	48 8d 55 d7	 lea	 rdx, QWORD PTR vsub$[rbp-217]
  0018c	48 8b ce	 mov	 rcx, rsi
  0018f	e8 00 00 00 00	 call	 _getbuffer
  00194	48 85 c0	 test	 rax, rax

; 1161 :             return NULL;

  00197	0f 88 39 02 00
	00		 js	 $LN121@bytearray_@17

; 1162 : 
; 1163 :         sub = vsub.buf;

  0019d	48 8b 4d d7	 mov	 rcx, QWORD PTR vsub$[rbp-217]

; 1164 :         sub_len = vsub.len;

  001a1	4c 8b 55 e7	 mov	 r10, QWORD PTR vsub$[rbp-201]

; 1165 :     }
; 1166 :     else {

  001a5	eb 1b		 jmp	 SHORT $LN128@bytearray_@17

; 1148 :     Py_ssize_t sub_len;
; 1149 :     char byte;
; 1150 :     Py_ssize_t start = 0, end = PY_SSIZE_T_MAX;
; 1151 : 
; 1152 :     Py_buffer vsub;
; 1153 :     PyObject *count_obj;
; 1154 : 
; 1155 :     if (!stringlib_parse_args_finds_byte("count", args, &sub_obj, &byte,
; 1156 :                                          &start, &end))

$LN18@bytearray_@17:
  001a7	48 3d ff 00 00
	00		 cmp	 rax, 255		; 000000ffH
  001ad	0f 87 10 02 00
	00		 ja	 $LN16@bytearray_@17
  001b3	4c 89 7c 24 38	 mov	 QWORD PTR sub_obj$1$[rsp], r15
  001b8	88 45 67	 mov	 BYTE PTR byte$[rbp-217], al
$LN10@bytearray_@17:

; 1167 :         sub = &byte;

  001bb	48 8d 4d 67	 lea	 rcx, QWORD PTR byte$[rbp-217]

; 1168 :         sub_len = 1;

  001bf	4d 8b d5	 mov	 r10, r13
$LN128@bytearray_@17:

; 1169 :     }
; 1170 : 
; 1171 :     ADJUST_INDICES(start, end, PyByteArray_GET_SIZE(self));

  001c2	49 8b 44 24 60	 mov	 rax, QWORD PTR [r12+96]
  001c7	4c 89 55 7f	 mov	 QWORD PTR sub_len$1$[rbp-217], r10
  001cb	48 89 4d 77	 mov	 QWORD PTR sub$1$[rbp-217], rcx
  001cf	48 3b f8	 cmp	 rdi, rax
  001d2	7e 05		 jle	 SHORT $LN7@bytearray_@17
  001d4	48 8b f8	 mov	 rdi, rax
  001d7	eb 0c		 jmp	 SHORT $LN4@bytearray_@17
$LN7@bytearray_@17:
  001d9	48 85 ff	 test	 rdi, rdi
  001dc	79 07		 jns	 SHORT $LN4@bytearray_@17
  001de	48 03 f8	 add	 rdi, rax
  001e1	49 0f 48 ff	 cmovs	 rdi, r15
$LN4@bytearray_@17:
  001e5	48 85 db	 test	 rbx, rbx
  001e8	79 07		 jns	 SHORT $LN2@bytearray_@17
  001ea	48 03 d8	 add	 rbx, rax
  001ed	49 0f 48 df	 cmovs	 rbx, r15
$LN2@bytearray_@17:

; 1172 : 
; 1173 :     count_obj = PyLong_FromSsize_t(
; 1174 :         stringlib_count(str + start, end - start, sub, sub_len, PY_SSIZE_T_MAX)
; 1175 :         );

  001f1	48 2b fb	 sub	 rdi, rbx
  001f4	4e 8d 1c 33	 lea	 r11, QWORD PTR [rbx+r14]
  001f8	4c 89 5c 24 30	 mov	 QWORD PTR $T27250[rsp], r11
  001fd	0f 88 9f 01 00
	00		 js	 $LN122@bytearray_@17
  00203	4d 85 d2	 test	 r10, r10
  00206	75 1c		 jne	 SHORT $LN32@bytearray_@17
  00208	49 bf ff ff ff
	ff ff ff ff 7f	 mov	 r15, 9223372036854775807 ; 7fffffffffffffffH
  00212	49 3b ff	 cmp	 rdi, r15
  00215	0f 8d 87 01 00
	00		 jge	 $LN122@bytearray_@17
  0021b	4c 8d 7f 01	 lea	 r15, QWORD PTR [rdi+1]
  0021f	e9 7e 01 00 00	 jmp	 $LN122@bytearray_@17
$LN32@bytearray_@17:
  00224	48 8b c7	 mov	 rax, rdi
  00227	4d 8b c7	 mov	 r8, r15
  0022a	49 2b c2	 sub	 rax, r10
  0022d	48 89 45 8f	 mov	 QWORD PTR w$1$[rbp-217], rax
  00231	0f 88 6b 01 00
	00		 js	 $LN122@bytearray_@17
  00237	4d 3b d5	 cmp	 r10, r13
  0023a	7f 46		 jg	 SHORT $LN96@bytearray_@17
  0023c	4d 85 d2	 test	 r10, r10
  0023f	0f 8e 5d 01 00
	00		 jle	 $LN122@bytearray_@17
  00245	49 8b c7	 mov	 rax, r15
  00248	48 85 ff	 test	 rdi, rdi
  0024b	0f 8e 46 01 00
	00		 jle	 $LN124@bytearray_@17
  00251	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
$LL92@bytearray_@17:
  00254	42 38 0c 18	 cmp	 BYTE PTR [rax+r11], cl
  00258	75 1b		 jne	 SHORT $LN91@bytearray_@17
  0025a	49 ff c0	 inc	 r8
  0025d	49 bb ff ff ff
	ff ff ff ff 7f	 mov	 r11, 9223372036854775807 ; 7fffffffffffffffH
  00267	4d 3b c3	 cmp	 r8, r11
  0026a	0f 84 2f 01 00
	00		 je	 $LN31@bytearray_@17
  00270	4c 8b 5c 24 30	 mov	 r11, QWORD PTR $T27250[rsp]
$LN91@bytearray_@17:
  00275	48 ff c0	 inc	 rax
  00278	48 3b c7	 cmp	 rax, rdi
  0027b	7c d7		 jl	 SHORT $LL92@bytearray_@17
  0027d	e9 15 01 00 00	 jmp	 $LN124@bytearray_@17
$LN96@bytearray_@17:
  00282	4c 8b 75 77	 mov	 r14, QWORD PTR sub$1$[rbp-217]
  00286	4d 8d 4a ff	 lea	 r9, QWORD PTR [r10-1]
  0028a	45 8b e7	 mov	 r12d, r15d
  0028d	49 8d 71 ff	 lea	 rsi, QWORD PTR [r9-1]
  00291	4d 85 c9	 test	 r9, r9
  00294	7e 52		 jle	 SHORT $LN73@bytearray_@17
  00296	43 0f b6 34 31	 movzx	 esi, BYTE PTR [r9+r14]
  0029b	4d 8b d6	 mov	 r10, r14
  0029e	4d 8d 71 ff	 lea	 r14, QWORD PTR [r9-1]
  002a2	4d 8b de	 mov	 r11, r14
  002a5	49 8b d9	 mov	 rbx, r9
  002a8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL75@bytearray_@17:
  002b0	41 0f be 3a	 movsx	 edi, BYTE PTR [r10]
  002b4	41 8b d5	 mov	 edx, r13d
  002b7	8b cf		 mov	 ecx, edi
  002b9	83 e1 1f	 and	 ecx, 31
  002bc	d3 e2		 shl	 edx, cl
  002be	44 0b e2	 or	 r12d, edx
  002c1	40 3a fe	 cmp	 dil, sil
  002c4	4d 0f 44 f3	 cmove	 r14, r11
  002c8	49 ff c2	 inc	 r10
  002cb	49 ff cb	 dec	 r11
  002ce	48 ff cb	 dec	 rbx
  002d1	75 dd		 jne	 SHORT $LL75@bytearray_@17

; 1167 :         sub = &byte;

  002d3	4c 8b 55 7f	 mov	 r10, QWORD PTR sub_len$1$[rbp-217]
  002d7	4c 8b 5c 24 30	 mov	 r11, QWORD PTR $T27250[rsp]
  002dc	4c 89 75 97	 mov	 QWORD PTR skip$1$[rbp-217], r14
  002e0	48 8b 75 97	 mov	 rsi, QWORD PTR skip$1$[rbp-217]
  002e4	4c 8b 75 77	 mov	 r14, QWORD PTR sub$1$[rbp-217]

; 1172 : 
; 1173 :     count_obj = PyLong_FromSsize_t(
; 1174 :         stringlib_count(str + start, end - start, sub, sub_len, PY_SSIZE_T_MAX)
; 1175 :         );

$LN73@bytearray_@17:
  002e8	43 0f be 04 31	 movsx	 eax, BYTE PTR [r9+r14]
  002ed	49 8b d7	 mov	 rdx, r15
  002f0	83 e0 1f	 and	 eax, 31
  002f3	0f b6 c8	 movzx	 ecx, al
  002f6	41 d3 e5	 shl	 r13d, cl
  002f9	45 0b e5	 or	 r12d, r13d
  002fc	4c 8b 6d 8f	 mov	 r13, QWORD PTR w$1$[rbp-217]
  00300	4d 85 ed	 test	 r13, r13
  00303	0f 88 8e 00 00
	00		 js	 $LN124@bytearray_@17
  00309	4b 8d 1c 13	 lea	 rbx, QWORD PTR [r11+r10]
$LN130@bytearray_@17:
  0030d	43 0f b6 44 32
	ff		 movzx	 eax, BYTE PTR [r10+r14-1]
  00313	38 44 13 ff	 cmp	 BYTE PTR [rbx+rdx-1], al
  00317	75 62		 jne	 SHORT $LN68@bytearray_@17
  00319	49 8b ff	 mov	 rdi, r15
  0031c	4d 85 c9	 test	 r9, r9
  0031f	7e 27		 jle	 SHORT $LN114@bytearray_@17
  00321	48 8b c2	 mov	 rax, rdx
  00324	49 8b ce	 mov	 rcx, r14
  00327	49 2b c6	 sub	 rax, r14
  0032a	4e 8d 14 18	 lea	 r10, QWORD PTR [rax+r11]
  0032e	66 90		 npad	 2
$LL67@bytearray_@17:
  00330	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00333	41 38 04 0a	 cmp	 BYTE PTR [r10+rcx], al
  00337	75 0b		 jne	 SHORT $LN125@bytearray_@17
  00339	48 ff c7	 inc	 rdi
  0033c	48 ff c1	 inc	 rcx
  0033f	49 3b f9	 cmp	 rdi, r9
  00342	7c ec		 jl	 SHORT $LL67@bytearray_@17
$LN125@bytearray_@17:
  00344	4c 8b 55 7f	 mov	 r10, QWORD PTR sub_len$1$[rbp-217]
$LN114@bytearray_@17:
  00348	49 3b f9	 cmp	 rdi, r9
  0034b	75 1c		 jne	 SHORT $LN63@bytearray_@17
  0034d	49 ff c0	 inc	 r8
  00350	49 bb ff ff ff
	ff ff ff ff 7f	 mov	 r11, 9223372036854775807 ; 7fffffffffffffffH
  0035a	4d 3b c3	 cmp	 r8, r11
  0035d	74 40		 je	 SHORT $LN31@bytearray_@17
  0035f	4c 8b 5c 24 30	 mov	 r11, QWORD PTR $T27250[rsp]
  00364	49 03 d1	 add	 rdx, r9
  00367	eb 22		 jmp	 SHORT $LN70@bytearray_@17
$LN63@bytearray_@17:
  00369	0f be 04 13	 movsx	 eax, BYTE PTR [rbx+rdx]
  0036d	83 e0 1f	 and	 eax, 31
  00370	41 0f a3 c4	 bt	 r12d, eax
  00374	73 12		 jae	 SHORT $LN129@bytearray_@17
  00376	48 03 d6	 add	 rdx, rsi
  00379	eb 10		 jmp	 SHORT $LN70@bytearray_@17
$LN68@bytearray_@17:
  0037b	0f be 04 13	 movsx	 eax, BYTE PTR [rbx+rdx]
  0037f	83 e0 1f	 and	 eax, 31
  00382	41 0f a3 c4	 bt	 r12d, eax
  00386	72 03		 jb	 SHORT $LN70@bytearray_@17
$LN129@bytearray_@17:
  00388	49 03 d2	 add	 rdx, r10
$LN70@bytearray_@17:
  0038b	48 ff c2	 inc	 rdx
  0038e	49 3b d5	 cmp	 rdx, r13
  00391	0f 8e 76 ff ff
	ff		 jle	 $LN130@bytearray_@17
$LN124@bytearray_@17:
  00397	4d 8b d8	 mov	 r11, r8
  0039a	4d 85 c0	 test	 r8, r8
  0039d	78 03		 js	 SHORT $LN122@bytearray_@17
$LN31@bytearray_@17:
  0039f	4d 8b fb	 mov	 r15, r11
$LN122@bytearray_@17:
  003a2	49 8b cf	 mov	 rcx, r15
  003a5	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 1176 : 
; 1177 :     if (sub_obj)

  003aa	48 83 7c 24 38
	00		 cmp	 QWORD PTR sub_obj$1$[rsp], 0
  003b0	48 8b f8	 mov	 rdi, rax
  003b3	74 09		 je	 SHORT $LN1@bytearray_@17

; 1178 :         PyBuffer_Release(&vsub);

  003b5	48 8d 4d d7	 lea	 rcx, QWORD PTR vsub$[rbp-217]
  003b9	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@bytearray_@17:

; 1179 : 
; 1180 :     return count_obj;

  003be	48 8b c7	 mov	 rax, rdi
  003c1	eb 15		 jmp	 SHORT $LN12@bytearray_@17

; 1148 :     Py_ssize_t sub_len;
; 1149 :     char byte;
; 1150 :     Py_ssize_t start = 0, end = PY_SSIZE_T_MAX;
; 1151 : 
; 1152 :     Py_buffer vsub;
; 1153 :     PyObject *count_obj;
; 1154 : 
; 1155 :     if (!stringlib_parse_args_finds_byte("count", args, &sub_obj, &byte,
; 1156 :                                          &start, &end))

$LN16@bytearray_@17:
  003c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  003ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@
  003d1	e8 00 00 00 00	 call	 PyErr_SetString
$LN121@bytearray_@17:

; 1157 :         return NULL;

  003d6	33 c0		 xor	 eax, eax
$LN12@bytearray_@17:
  003d8	4c 8b ac 24 48
	01 00 00	 mov	 r13, QWORD PTR [rsp+328]

; 1181 : }

  003e0	48 81 c4 00 01
	00 00		 add	 rsp, 256		; 00000100H
  003e7	41 5f		 pop	 r15
  003e9	41 5e		 pop	 r14
  003eb	41 5c		 pop	 r12
  003ed	5f		 pop	 rdi
  003ee	5e		 pop	 rsi
  003ef	5b		 pop	 rbx
  003f0	5d		 pop	 rbp
  003f1	c3		 ret	 0
bytearray_count ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytearray_clear DD imagerel bytearray_clear
	DD	imagerel bytearray_clear+103
	DD	imagerel $unwind$bytearray_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_clear DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
xdata	ENDS
;	COMDAT bytearray_clear
_TEXT	SEGMENT
self$ = 64
bytearray_clear PROC					; COMDAT

; 1190 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1191 :     if (PyByteArray_Resize((PyObject *)self, 0) < 0)

  00004	33 d2		 xor	 edx, edx
  00006	e8 00 00 00 00	 call	 PyByteArray_Resize
  0000b	85 c0		 test	 eax, eax
  0000d	79 07		 jns	 SHORT $LN1@bytearray_@18

; 1192 :         return NULL;

  0000f	33 c0		 xor	 eax, eax

; 1194 : }

  00011	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00015	c3		 ret	 0
$LN1@bytearray_@18:

; 1193 :     Py_RETURN_NONE;

  00016	e8 00 00 00 00	 call	 _Py_PXCTX
  0001b	85 c0		 test	 eax, eax
  0001d	75 3c		 jne	 SHORT $LN5@bytearray_@18
  0001f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00034	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0003a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00042	e8 00 00 00 00	 call	 _PyParallel_Guard
  00047	85 c0		 test	 eax, eax
  00049	75 09		 jne	 SHORT $LN4@bytearray_@18
  0004b	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00052	74 07		 je	 SHORT $LN5@bytearray_@18
$LN4@bytearray_@18:
  00054	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@bytearray_@18:
  0005b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1194 : }

  00062	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00066	c3		 ret	 0
bytearray_clear ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bytearray_copy
_TEXT	SEGMENT
self$ = 8
bytearray_copy PROC					; COMDAT

; 1204 :     return PyByteArray_FromStringAndSize(PyByteArray_AS_STRING((PyObject *)self),
; 1205 :                                          PyByteArray_GET_SIZE(self));

  00000	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00004	48 85 d2	 test	 rdx, rdx
  00007	74 0c		 je	 SHORT $LN3@bytearray_@19
  00009	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]

; 1206 : }

  00010	e9 00 00 00 00	 jmp	 PyByteArray_FromStringAndSize
$LN3@bytearray_@19:

; 1204 :     return PyByteArray_FromStringAndSize(PyByteArray_AS_STRING((PyObject *)self),
; 1205 :                                          PyByteArray_GET_SIZE(self));

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string

; 1206 : }

  0001c	e9 00 00 00 00	 jmp	 PyByteArray_FromStringAndSize
bytearray_copy ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@BDAGCGNF@subsection?5not?5found?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_index DD imagerel bytearray_index
	DD	imagerel bytearray_index+65
	DD	imagerel $unwind$bytearray_index
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_index DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BF@BDAGCGNF@subsection?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BF@BDAGCGNF@subsection?5not?5found?$AA@ DB 'subsection not found', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_index
_TEXT	SEGMENT
self$ = 48
args$ = 56
bytearray_index PROC					; COMDAT

; 1215 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1216 :     Py_ssize_t result = bytearray_find_internal(self, args, +1);

  00004	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000a	e8 00 00 00 00	 call	 bytearray_find_internal

; 1217 :     if (result == -2)

  0000f	48 83 f8 fe	 cmp	 rax, -2

; 1218 :         return NULL;

  00013	74 19		 je	 SHORT $LN5@bytearray_@20

; 1219 :     if (result == -1) {

  00015	48 83 f8 ff	 cmp	 rax, -1
  00019	75 1a		 jne	 SHORT $LN1@bytearray_@20

; 1220 :         PyErr_SetString(PyExc_ValueError,
; 1221 :                         "subsection not found");

  0001b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@BDAGCGNF@subsection?5not?5found?$AA@
  00029	e8 00 00 00 00	 call	 PyErr_SetString
$LN5@bytearray_@20:

; 1222 :         return NULL;

  0002e	33 c0		 xor	 eax, eax

; 1225 : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
$LN1@bytearray_@20:

; 1223 :     }
; 1224 :     return PyLong_FromSsize_t(result);

  00035	48 8b c8	 mov	 rcx, rax

; 1225 : }

  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
bytearray_index ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_rfind DD imagerel bytearray_rfind
	DD	imagerel bytearray_rfind+38
	DD	imagerel $unwind$bytearray_rfind
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_rfind DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytearray_rfind
_TEXT	SEGMENT
self$ = 48
args$ = 56
bytearray_rfind PROC					; COMDAT

; 1239 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1240 :     Py_ssize_t result = bytearray_find_internal(self, args, -1);

  00004	41 83 c8 ff	 or	 r8d, -1
  00008	e8 00 00 00 00	 call	 bytearray_find_internal

; 1241 :     if (result == -2)

  0000d	48 83 f8 fe	 cmp	 rax, -2
  00011	75 07		 jne	 SHORT $LN1@bytearray_@21

; 1242 :         return NULL;

  00013	33 c0		 xor	 eax, eax

; 1244 : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
$LN1@bytearray_@21:

; 1243 :     return PyLong_FromSsize_t(result);

  0001a	48 8b c8	 mov	 rcx, rax

; 1244 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
bytearray_rfind ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_rindex DD imagerel bytearray_rindex
	DD	imagerel bytearray_rindex+63
	DD	imagerel $unwind$bytearray_rindex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_rindex DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytearray_rindex
_TEXT	SEGMENT
self$ = 48
args$ = 56
bytearray_rindex PROC					; COMDAT

; 1254 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1255 :     Py_ssize_t result = bytearray_find_internal(self, args, -1);

  00004	41 83 c8 ff	 or	 r8d, -1
  00008	e8 00 00 00 00	 call	 bytearray_find_internal

; 1256 :     if (result == -2)

  0000d	48 83 f8 fe	 cmp	 rax, -2

; 1257 :         return NULL;

  00011	74 19		 je	 SHORT $LN5@bytearray_@22

; 1258 :     if (result == -1) {

  00013	48 83 f8 ff	 cmp	 rax, -1
  00017	75 1a		 jne	 SHORT $LN1@bytearray_@22

; 1259 :         PyErr_SetString(PyExc_ValueError,
; 1260 :                         "subsection not found");

  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@BDAGCGNF@subsection?5not?5found?$AA@
  00027	e8 00 00 00 00	 call	 PyErr_SetString
$LN5@bytearray_@22:

; 1261 :         return NULL;

  0002c	33 c0		 xor	 eax, eax

; 1264 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
$LN1@bytearray_@22:

; 1262 :     }
; 1263 :     return PyLong_FromSsize_t(result);

  00033	48 8b c8	 mov	 rcx, rax

; 1264 : }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
bytearray_rindex ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_contains DD imagerel bytearray_contains
	DD	imagerel bytearray_contains+275
	DD	imagerel $unwind$bytearray_contains
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_contains DD 040d01H
	DD	012340dH
	DD	07006f20dH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytearray_contains
_TEXT	SEGMENT
varg$22295 = 48
self$ = 144
arg$ = 152
bytearray_contains PROC					; COMDAT

; 1269 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8b fa	 mov	 rdi, rdx

; 1270 :     Py_ssize_t ival = PyNumber_AsSsize_t(arg, PyExc_ValueError);

  00010	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_ValueError
  00017	48 8b d9	 mov	 rbx, rcx
  0001a	48 8b cf	 mov	 rcx, rdi
  0001d	e8 00 00 00 00	 call	 PyNumber_AsSsize_t

; 1271 :     if (ival == -1 && PyErr_Occurred()) {

  00022	48 83 f8 ff	 cmp	 rax, -1
  00026	75 7f		 jne	 SHORT $LN4@bytearray_@23
  00028	e8 00 00 00 00	 call	 PyErr_Occurred
  0002d	48 85 c0	 test	 rax, rax
  00030	0f 84 b6 00 00
	00		 je	 $LN1@bytearray_@23

; 1272 :         Py_buffer varg;
; 1273 :         Py_ssize_t pos;
; 1274 :         PyErr_Clear();

  00036	e8 00 00 00 00	 call	 PyErr_Clear

; 1275 :         if (_getbuffer(arg, &varg) < 0)

  0003b	48 8d 54 24 30	 lea	 rdx, QWORD PTR varg$22295[rsp]
  00040	48 8b cf	 mov	 rcx, rdi
  00043	e8 00 00 00 00	 call	 _getbuffer
  00048	48 85 c0	 test	 rax, rax

; 1276 :             return -1;

  0004b	0f 88 ae 00 00
	00		 js	 $LN11@bytearray_@23

; 1277 :         pos = stringlib_find(PyByteArray_AS_STRING(self), Py_SIZE(self),
; 1278 :                              varg.buf, varg.len, 0);

  00051	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  00055	48 85 d2	 test	 rdx, rdx
  00058	74 09		 je	 SHORT $LN7@bytearray_@23
  0005a	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00061	eb 07		 jmp	 SHORT $LN8@bytearray_@23
$LN7@bytearray_@23:
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string
$LN8@bytearray_@23:
  0006a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR varg$22295[rsp+16]
  0006f	4c 8b 44 24 30	 mov	 r8, QWORD PTR varg$22295[rsp]
  00074	33 ff		 xor	 edi, edi
  00076	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0007b	e8 00 00 00 00	 call	 stringlib_find

; 1279 :         PyBuffer_Release(&varg);

  00080	48 8d 4c 24 30	 lea	 rcx, QWORD PTR varg$22295[rsp]
  00085	48 8b d8	 mov	 rbx, rax
  00088	e8 00 00 00 00	 call	 PyBuffer_Release

; 1280 :         return pos >= 0;

  0008d	48 85 db	 test	 rbx, rbx
  00090	40 0f 99 c7	 setns	 dil
  00094	8b c7		 mov	 eax, edi

; 1288 : }

  00096	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  0009e	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000a5	5f		 pop	 rdi
  000a6	c3		 ret	 0
$LN4@bytearray_@23:

; 1281 :     }
; 1282 :     if (ival < 0 || ival >= 256) {

  000a7	48 3d ff 00 00
	00		 cmp	 rax, 255		; 000000ffH
  000ad	77 3d		 ja	 SHORT $LN1@bytearray_@23

; 1285 :     }
; 1286 : 
; 1287 :     return memchr(PyByteArray_AS_STRING(self), (int) ival, Py_SIZE(self)) != NULL;

  000af	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  000b3	4d 85 c0	 test	 r8, r8
  000b6	74 09		 je	 SHORT $LN9@bytearray_@23
  000b8	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  000bf	eb 07		 jmp	 SHORT $LN10@bytearray_@23
$LN9@bytearray_@23:
  000c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string
$LN10@bytearray_@23:
  000c8	8b d0		 mov	 edx, eax
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000d0	33 ff		 xor	 edi, edi
  000d2	48 85 c0	 test	 rax, rax
  000d5	40 0f 95 c7	 setne	 dil
  000d9	8b c7		 mov	 eax, edi

; 1288 : }

  000db	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  000e3	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000ea	5f		 pop	 rdi
  000eb	c3		 ret	 0
$LN1@bytearray_@23:

; 1283 :         PyErr_SetString(PyExc_ValueError, "byte must be in range(0, 256)");

  000ec	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJOIMFKH@byte?5must?5be?5in?5range?$CI0?0?5256?$CJ?$AA@
  000fa	e8 00 00 00 00	 call	 PyErr_SetString
$LN11@bytearray_@23:

; 1284 :         return -1;

  000ff	83 c8 ff	 or	 eax, -1

; 1288 : }

  00102	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  0010a	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00111	5f		 pop	 rdi
  00112	c3		 ret	 0
bytearray_contains ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_bytearray_tailmatch DD imagerel _bytearray_tailmatch
	DD	imagerel _bytearray_tailmatch+243
	DD	imagerel $unwind$_bytearray_tailmatch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_bytearray_tailmatch DD 0a1a01H
	DD	013741aH
	DD	012641aH
	DD	011541aH
	DD	010341aH
	DD	0c016d21aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _bytearray_tailmatch
_TEXT	SEGMENT
vsubstr$ = 32
self$ = 128
substr$ = 136
start$ = 144
end$ = 152
direction$ = 160
_bytearray_tailmatch PROC				; COMDAT

; 1298 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 1299 :     Py_ssize_t len = PyByteArray_GET_SIZE(self);

  0001a	48 8b 71 60	 mov	 rsi, QWORD PTR [rcx+96]

; 1300 :     const char* str;
; 1301 :     Py_buffer vsubstr;
; 1302 :     int rv = 0;

  0001e	33 ed		 xor	 ebp, ebp
  00020	49 8b d9	 mov	 rbx, r9
  00023	49 8b f8	 mov	 rdi, r8
  00026	48 8b c2	 mov	 rax, rdx

; 1303 : 
; 1304 :     str = PyByteArray_AS_STRING(self);

  00029	48 85 f6	 test	 rsi, rsi
  0002c	74 09		 je	 SHORT $LN17@bytearray_@24
  0002e	4c 8b a1 80 00
	00 00		 mov	 r12, QWORD PTR [rcx+128]
  00035	eb 07		 jmp	 SHORT $LN18@bytearray_@24
$LN17@bytearray_@24:
  00037	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_PyByteArray_empty_string
$LN18@bytearray_@24:

; 1305 : 
; 1306 :     if (_getbuffer(substr, &vsubstr) < 0)

  0003e	48 8d 54 24 20	 lea	 rdx, QWORD PTR vsubstr$[rsp]
  00043	48 8b c8	 mov	 rcx, rax
  00046	e8 00 00 00 00	 call	 _getbuffer
  0004b	48 85 c0	 test	 rax, rax
  0004e	79 08		 jns	 SHORT $LN14@bytearray_@24

; 1307 :         return -1;

  00050	83 c8 ff	 or	 eax, -1
  00053	e9 80 00 00 00	 jmp	 $LN15@bytearray_@24
$LN14@bytearray_@24:

; 1308 : 
; 1309 :     ADJUST_INDICES(start, end, len);

  00058	48 3b de	 cmp	 rbx, rsi
  0005b	7e 05		 jle	 SHORT $LN13@bytearray_@24
  0005d	48 8b de	 mov	 rbx, rsi
  00060	eb 0c		 jmp	 SHORT $LN10@bytearray_@24
$LN13@bytearray_@24:
  00062	48 85 db	 test	 rbx, rbx
  00065	79 07		 jns	 SHORT $LN10@bytearray_@24
  00067	48 03 de	 add	 rbx, rsi
  0006a	48 0f 48 dd	 cmovs	 rbx, rbp
$LN10@bytearray_@24:
  0006e	48 85 ff	 test	 rdi, rdi
  00071	79 07		 jns	 SHORT $LN8@bytearray_@24
  00073	48 03 fe	 add	 rdi, rsi
  00076	48 0f 48 fd	 cmovs	 rdi, rbp
$LN8@bytearray_@24:

; 1310 : 
; 1311 :     if (direction < 0) {
; 1312 :         /* startswith */
; 1313 :         if (start+vsubstr.len > len) {

  0007a	4c 8b 44 24 30	 mov	 r8, QWORD PTR vsubstr$[rsp+16]
  0007f	39 ac 24 a0 00
	00 00		 cmp	 DWORD PTR direction$[rsp], ebp
  00086	7d 0b		 jge	 SHORT $LN7@bytearray_@24
  00088	49 8d 04 38	 lea	 rax, QWORD PTR [r8+rdi]
  0008c	48 3b c6	 cmp	 rax, rsi
  0008f	7f 3b		 jg	 SHORT $done$22340

; 1314 :             goto done;
; 1315 :         }
; 1316 :     } else {

  00091	eb 1d		 jmp	 SHORT $LN2@bytearray_@24
$LN7@bytearray_@24:

; 1317 :         /* endswith */
; 1318 :         if (end-start < vsubstr.len || start > len) {

  00093	48 8b c3	 mov	 rax, rbx
  00096	48 2b c7	 sub	 rax, rdi
  00099	49 3b c0	 cmp	 rax, r8
  0009c	7c 2e		 jl	 SHORT $done$22340
  0009e	48 3b fe	 cmp	 rdi, rsi
  000a1	7f 29		 jg	 SHORT $done$22340

; 1319 :             goto done;
; 1320 :         }
; 1321 : 
; 1322 :         if (end-vsubstr.len > start)

  000a3	48 8b c3	 mov	 rax, rbx
  000a6	49 2b c0	 sub	 rax, r8
  000a9	48 3b c7	 cmp	 rax, rdi
  000ac	48 0f 4f f8	 cmovg	 rdi, rax
$LN2@bytearray_@24:

; 1323 :             start = end - vsubstr.len;
; 1324 :     }
; 1325 :     if (end-start >= vsubstr.len)

  000b0	48 2b df	 sub	 rbx, rdi
  000b3	49 3b d8	 cmp	 rbx, r8
  000b6	7c 14		 jl	 SHORT $done$22340

; 1326 :         rv = ! memcmp(str+start, vsubstr.buf, vsubstr.len);

  000b8	48 8b 54 24 20	 mov	 rdx, QWORD PTR vsubstr$[rsp]
  000bd	49 8d 0c 3c	 lea	 rcx, QWORD PTR [r12+rdi]
  000c1	e8 00 00 00 00	 call	 memcmp
  000c6	85 c0		 test	 eax, eax
  000c8	40 0f 94 c5	 sete	 bpl
$done$22340:

; 1327 : 
; 1328 : done:
; 1329 :     PyBuffer_Release(&vsubstr);

  000cc	48 8d 4c 24 20	 lea	 rcx, QWORD PTR vsubstr$[rsp]
  000d1	e8 00 00 00 00	 call	 PyBuffer_Release

; 1330 :     return rv;

  000d6	8b c5		 mov	 eax, ebp
$LN15@bytearray_@24:

; 1331 : }

  000d8	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  000dd	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000e1	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  000e5	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  000e9	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  000ed	49 8b e3	 mov	 rsp, r11
  000f0	41 5c		 pop	 r12
  000f2	c3		 ret	 0
_bytearray_tailmatch ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DP@ICIHPOAP@startswith?5first?5arg?5must?5be?5byt@ ; `string'
EXTRN	PyBool_FromLong:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytearray_startswith DD imagerel bytearray_startswith
	DD	imagerel bytearray_startswith+268
	DD	imagerel $unwind$bytearray_startswith
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$bytearray_startswith DD imagerel bytearray_startswith+268
	DD	imagerel bytearray_startswith+439
	DD	imagerel $chain$0$bytearray_startswith
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$bytearray_startswith DD imagerel bytearray_startswith+439
	DD	imagerel bytearray_startswith+462
	DD	imagerel $chain$1$bytearray_startswith
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$bytearray_startswith DD imagerel bytearray_startswith+462
	DD	imagerel bytearray_startswith+544
	DD	imagerel $chain$2$bytearray_startswith
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$bytearray_startswith DD imagerel bytearray_startswith+544
	DD	imagerel bytearray_startswith+638
	DD	imagerel $chain$3$bytearray_startswith
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$bytearray_startswith DD 021H
	DD	imagerel bytearray_startswith
	DD	imagerel bytearray_startswith+268
	DD	imagerel $unwind$bytearray_startswith
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$bytearray_startswith DD 020021H
	DD	016d400H
	DD	imagerel bytearray_startswith
	DD	imagerel bytearray_startswith+268
	DD	imagerel $unwind$bytearray_startswith
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$bytearray_startswith DD 021H
	DD	imagerel bytearray_startswith
	DD	imagerel bytearray_startswith+268
	DD	imagerel $unwind$bytearray_startswith
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$bytearray_startswith DD 020821H
	DD	016d408H
	DD	imagerel bytearray_startswith
	DD	imagerel bytearray_startswith+268
	DD	imagerel $unwind$bytearray_startswith
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_startswith DD 081601H
	DD	0173416H
	DD	0e00cf216H
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT ??_C@_0DP@ICIHPOAP@startswith?5first?5arg?5must?5be?5byt@
CONST	SEGMENT
??_C@_0DP@ICIHPOAP@startswith?5first?5arg?5must?5be?5byt@ DB 'startswith '
	DB	'first arg must be bytes or a tuple of bytes, not %s', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
CONST	ENDS
;	COMDAT bytearray_startswith
_TEXT	SEGMENT
obj_start$27377 = 48
obj_end$27378 = 56
tmp_subobj$27374 = 64
format$27379 = 72
self$ = 176
args$ = 184
tmp_end$27376 = 192
tmp_start$27375 = 200
bytearray_startswith PROC				; COMDAT

; 1344 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 56		 push	 r14
  0000c	48 8b ec	 mov	 rbp, rsp
  0000f	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00016	4c 8b f1	 mov	 r14, rcx

; 1345 :     Py_ssize_t start = 0;
; 1346 :     Py_ssize_t end = PY_SSIZE_T_MAX;
; 1347 :     PyObject *subobj;
; 1348 :     int result;
; 1349 : 
; 1350 :     if (!stringlib_parse_args_finds("startswith", args, &subobj, &start, &end))

  00019	48 83 c9 ff	 or	 rcx, -1
  0001d	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00027	48 89 45 40	 mov	 QWORD PTR tmp_end$27376[rbp-128], rax
  0002b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@
  00031	48 8b da	 mov	 rbx, rdx
  00034	89 45 c8	 mov	 DWORD PTR format$27379[rbp-128], eax
  00037	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@+4
  0003e	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_NoneStruct
  00045	66 89 45 cc	 mov	 WORD PTR format$27379[rbp-124], ax
  00049	33 c0		 xor	 eax, eax
  0004b	48 8d 7d c8	 lea	 rdi, QWORD PTR format$27379[rbp-128]
  0004f	48 89 45 ce	 mov	 QWORD PTR format$27379[rbp-122], rax
  00053	48 89 45 d6	 mov	 QWORD PTR format$27379[rbp-114], rax
  00057	48 89 45 de	 mov	 QWORD PTR format$27379[rbp-106], rax
  0005b	48 89 45 e6	 mov	 QWORD PTR format$27379[rbp-98], rax
  0005f	48 89 45 ee	 mov	 QWORD PTR format$27379[rbp-90], rax
  00063	89 45 f6	 mov	 DWORD PTR format$27379[rbp-82], eax
  00066	f2 ae		 repne scasb
  00068	41 b8 31 00 00
	00		 mov	 r8d, 49			; 00000031H
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@MPOGHCCL@startswith?$AA@
  00075	48 f7 d1	 not	 rcx
  00078	33 f6		 xor	 esi, esi
  0007a	4c 89 65 b0	 mov	 QWORD PTR obj_start$27377[rbp-128], r12
  0007e	48 ff c9	 dec	 rcx
  00081	48 89 75 48	 mov	 QWORD PTR tmp_start$27375[rbp-128], rsi
  00085	4c 89 65 b8	 mov	 QWORD PTR obj_end$27378[rbp-128], r12
  00089	4c 2b c1	 sub	 r8, rcx
  0008c	48 8d 4c 0d c8	 lea	 rcx, QWORD PTR format$27379[rbp+rcx-128]
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
  00097	48 8d 45 b8	 lea	 rax, QWORD PTR obj_end$27378[rbp-128]
  0009b	4c 8d 4d b0	 lea	 r9, QWORD PTR obj_start$27377[rbp-128]
  0009f	4c 8d 45 c0	 lea	 r8, QWORD PTR tmp_subobj$27374[rbp-128]
  000a3	48 8d 55 c8	 lea	 rdx, QWORD PTR format$27379[rbp-128]
  000a7	48 8b cb	 mov	 rcx, rbx
  000aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000af	40 88 75 f9	 mov	 BYTE PTR format$27379[rbp-79], sil
  000b3	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000b8	85 c0		 test	 eax, eax
  000ba	0f 84 ab 01 00
	00		 je	 $LN2@bytearray_@25
  000c0	48 8b 4d b0	 mov	 rcx, QWORD PTR obj_start$27377[rbp-128]
  000c4	49 3b cc	 cmp	 rcx, r12
  000c7	74 11		 je	 SHORT $LN16@bytearray_@25
  000c9	48 8d 55 48	 lea	 rdx, QWORD PTR tmp_start$27375[rbp-128]
  000cd	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000d2	85 c0		 test	 eax, eax
  000d4	0f 84 91 01 00
	00		 je	 $LN2@bytearray_@25
$LN16@bytearray_@25:
  000da	48 8b 4d b8	 mov	 rcx, QWORD PTR obj_end$27378[rbp-128]
  000de	49 3b cc	 cmp	 rcx, r12
  000e1	74 11		 je	 SHORT $LN11@bytearray_@25
  000e3	48 8d 55 40	 lea	 rdx, QWORD PTR tmp_end$27376[rbp-128]
  000e7	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000ec	85 c0		 test	 eax, eax
  000ee	0f 84 77 01 00
	00		 je	 $LN2@bytearray_@25
$LN11@bytearray_@25:

; 1351 :         return NULL;
; 1352 :     if (PyTuple_Check(subobj)) {

  000f4	48 8b 5d c0	 mov	 rbx, QWORD PTR tmp_subobj$27374[rbp-128]
  000f8	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000fc	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00106	0f 84 14 01 00
	00		 je	 $LN10@bytearray_@25

; 1353 :         Py_ssize_t i;
; 1354 :         for (i = 0; i < PyTuple_GET_SIZE(subobj); i++) {

  0010c	4c 89 ac 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], r13
  00114	48 39 73 60	 cmp	 QWORD PTR [rbx+96], rsi
  00118	7e 49		 jle	 SHORT $LN7@bytearray_@25
  0011a	4c 8b 65 48	 mov	 r12, QWORD PTR tmp_start$27375[rbp-128]
  0011e	4c 8b 6d 40	 mov	 r13, QWORD PTR tmp_end$27376[rbp-128]
  00122	48 8d 7b 70	 lea	 rdi, QWORD PTR [rbx+112]
  00126	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL9@bytearray_@25:

; 1355 :             result = _bytearray_tailmatch(self,
; 1356 :                                       PyTuple_GET_ITEM(subobj, i),
; 1357 :                                       start, end, -1);

  00130	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00133	4d 8b cd	 mov	 r9, r13
  00136	4d 8b c4	 mov	 r8, r12
  00139	49 8b ce	 mov	 rcx, r14
  0013c	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  00144	e8 00 00 00 00	 call	 _bytearray_tailmatch

; 1358 :             if (result == -1)

  00149	83 f8 ff	 cmp	 eax, -1
  0014c	0f 84 ca 00 00
	00		 je	 $LN30@bytearray_@25

; 1360 :             else if (result) {

  00152	85 c0		 test	 eax, eax
  00154	75 78		 jne	 SHORT $LN31@bytearray_@25

; 1353 :         Py_ssize_t i;
; 1354 :         for (i = 0; i < PyTuple_GET_SIZE(subobj); i++) {

  00156	48 ff c6	 inc	 rsi
  00159	48 83 c7 08	 add	 rdi, 8
  0015d	48 3b 73 60	 cmp	 rsi, QWORD PTR [rbx+96]
  00161	7c cd		 jl	 SHORT $LL9@bytearray_@25
$LN7@bytearray_@25:

; 1362 :             }
; 1363 :         }
; 1364 :         Py_RETURN_FALSE;

  00163	e8 00 00 00 00	 call	 _Py_PXCTX
  00168	85 c0		 test	 eax, eax
  0016a	75 3c		 jne	 SHORT $LN26@bytearray_@25
  0016c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  00173	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0017a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00181	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00187	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0018f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00194	85 c0		 test	 eax, eax
  00196	75 09		 jne	 SHORT $LN25@bytearray_@25
  00198	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  0019f	74 07		 je	 SHORT $LN26@bytearray_@25
$LN25@bytearray_@25:
  001a1	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN26@bytearray_@25:
  001a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
$LN34@bytearray_@25:
  001af	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR [rsp+176]
$LN1@bytearray_@25:

; 1375 : }

  001b7	48 8b 9c 24 b8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+184]
  001bf	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  001c6	41 5e		 pop	 r14
  001c8	41 5c		 pop	 r12
  001ca	5f		 pop	 rdi
  001cb	5e		 pop	 rsi
  001cc	5d		 pop	 rbp
  001cd	c3		 ret	 0
$LN31@bytearray_@25:

; 1361 :                 Py_RETURN_TRUE;

  001ce	e8 00 00 00 00	 call	 _Py_PXCTX
  001d3	85 c0		 test	 eax, eax
  001d5	75 3c		 jne	 SHORT $LN22@bytearray_@25
  001d7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_TrueStruct
  001de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  001ec	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  001f2	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001fa	e8 00 00 00 00	 call	 _PyParallel_Guard
  001ff	85 c0		 test	 eax, eax
  00201	75 09		 jne	 SHORT $LN21@bytearray_@25
  00203	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  0020a	74 07		 je	 SHORT $LN22@bytearray_@25
$LN21@bytearray_@25:
  0020c	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80
$LN22@bytearray_@25:
  00213	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  0021a	eb 93		 jmp	 SHORT $LN34@bytearray_@25
$LN30@bytearray_@25:

; 1359 :                 return NULL;

  0021c	33 c0		 xor	 eax, eax
  0021e	eb 8f		 jmp	 SHORT $LN34@bytearray_@25
$LN10@bytearray_@25:

; 1365 :     }
; 1366 :     result = _bytearray_tailmatch(self, subobj, start, end, -1);

  00220	4c 8b 4d 40	 mov	 r9, QWORD PTR tmp_end$27376[rbp-128]
  00224	4c 8b 45 48	 mov	 r8, QWORD PTR tmp_start$27375[rbp-128]
  00228	48 8b d3	 mov	 rdx, rbx
  0022b	49 8b ce	 mov	 rcx, r14
  0022e	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  00236	e8 00 00 00 00	 call	 _bytearray_tailmatch

; 1367 :     if (result == -1) {

  0023b	83 f8 ff	 cmp	 eax, -1
  0023e	75 32		 jne	 SHORT $LN3@bytearray_@25

; 1368 :         if (PyErr_ExceptionMatches(PyExc_TypeError))

  00240	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00247	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0024c	85 c0		 test	 eax, eax
  0024e	74 1b		 je	 SHORT $LN2@bytearray_@25

; 1369 :             PyErr_Format(PyExc_TypeError, "startswith first arg must be bytes "
; 1370 :                          "or a tuple of bytes, not %s", Py_TYPE(subobj)->tp_name);

  00250	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  00254	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0025b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DP@ICIHPOAP@startswith?5first?5arg?5must?5be?5byt@
  00262	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00266	e8 00 00 00 00	 call	 PyErr_Format
$LN2@bytearray_@25:

; 1371 :         return NULL;

  0026b	33 c0		 xor	 eax, eax
  0026d	e9 45 ff ff ff	 jmp	 $LN1@bytearray_@25
$LN3@bytearray_@25:

; 1372 :     }
; 1373 :     else
; 1374 :         return PyBool_FromLong(result);

  00272	8b c8		 mov	 ecx, eax
  00274	e8 00 00 00 00	 call	 PyBool_FromLong
  00279	e9 39 ff ff ff	 jmp	 $LN1@bytearray_@25
bytearray_startswith ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@DLKPFMBA@endswith?5first?5arg?5must?5be?5bytes@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytearray_endswith DD imagerel bytearray_endswith
	DD	imagerel bytearray_endswith+268
	DD	imagerel $unwind$bytearray_endswith
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$bytearray_endswith DD imagerel bytearray_endswith+268
	DD	imagerel bytearray_endswith+439
	DD	imagerel $chain$0$bytearray_endswith
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$bytearray_endswith DD imagerel bytearray_endswith+439
	DD	imagerel bytearray_endswith+462
	DD	imagerel $chain$1$bytearray_endswith
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$bytearray_endswith DD imagerel bytearray_endswith+462
	DD	imagerel bytearray_endswith+544
	DD	imagerel $chain$2$bytearray_endswith
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$bytearray_endswith DD imagerel bytearray_endswith+544
	DD	imagerel bytearray_endswith+638
	DD	imagerel $chain$3$bytearray_endswith
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$bytearray_endswith DD 021H
	DD	imagerel bytearray_endswith
	DD	imagerel bytearray_endswith+268
	DD	imagerel $unwind$bytearray_endswith
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$bytearray_endswith DD 020021H
	DD	016d400H
	DD	imagerel bytearray_endswith
	DD	imagerel bytearray_endswith+268
	DD	imagerel $unwind$bytearray_endswith
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$bytearray_endswith DD 021H
	DD	imagerel bytearray_endswith
	DD	imagerel bytearray_endswith+268
	DD	imagerel $unwind$bytearray_endswith
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$bytearray_endswith DD 020821H
	DD	016d408H
	DD	imagerel bytearray_endswith
	DD	imagerel bytearray_endswith+268
	DD	imagerel $unwind$bytearray_endswith
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_endswith DD 081601H
	DD	0173416H
	DD	0e00cf216H
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT ??_C@_0DN@DLKPFMBA@endswith?5first?5arg?5must?5be?5bytes@
CONST	SEGMENT
??_C@_0DN@DLKPFMBA@endswith?5first?5arg?5must?5be?5bytes@ DB 'endswith fi'
	DB	'rst arg must be bytes or a tuple of bytes, not %s', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
CONST	ENDS
;	COMDAT bytearray_endswith
_TEXT	SEGMENT
obj_start$27443 = 48
obj_end$27444 = 56
tmp_subobj$27440 = 64
format$27445 = 72
self$ = 176
args$ = 184
tmp_end$27442 = 192
tmp_start$27441 = 200
bytearray_endswith PROC					; COMDAT

; 1387 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 56		 push	 r14
  0000c	48 8b ec	 mov	 rbp, rsp
  0000f	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00016	4c 8b f1	 mov	 r14, rcx

; 1388 :     Py_ssize_t start = 0;
; 1389 :     Py_ssize_t end = PY_SSIZE_T_MAX;
; 1390 :     PyObject *subobj;
; 1391 :     int result;
; 1392 : 
; 1393 :     if (!stringlib_parse_args_finds("endswith", args, &subobj, &start, &end))

  00019	48 83 c9 ff	 or	 rcx, -1
  0001d	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00027	48 89 45 40	 mov	 QWORD PTR tmp_end$27442[rbp-128], rax
  0002b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@
  00031	48 8b da	 mov	 rbx, rdx
  00034	89 45 c8	 mov	 DWORD PTR format$27445[rbp-128], eax
  00037	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05BBAJLHME@O?$HMOO?3?$AA@+4
  0003e	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_NoneStruct
  00045	66 89 45 cc	 mov	 WORD PTR format$27445[rbp-124], ax
  00049	33 c0		 xor	 eax, eax
  0004b	48 8d 7d c8	 lea	 rdi, QWORD PTR format$27445[rbp-128]
  0004f	48 89 45 ce	 mov	 QWORD PTR format$27445[rbp-122], rax
  00053	48 89 45 d6	 mov	 QWORD PTR format$27445[rbp-114], rax
  00057	48 89 45 de	 mov	 QWORD PTR format$27445[rbp-106], rax
  0005b	48 89 45 e6	 mov	 QWORD PTR format$27445[rbp-98], rax
  0005f	48 89 45 ee	 mov	 QWORD PTR format$27445[rbp-90], rax
  00063	89 45 f6	 mov	 DWORD PTR format$27445[rbp-82], eax
  00066	f2 ae		 repne scasb
  00068	41 b8 31 00 00
	00		 mov	 r8d, 49			; 00000031H
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08MLCMCPNP@endswith?$AA@
  00075	48 f7 d1	 not	 rcx
  00078	33 f6		 xor	 esi, esi
  0007a	4c 89 65 b0	 mov	 QWORD PTR obj_start$27443[rbp-128], r12
  0007e	48 ff c9	 dec	 rcx
  00081	48 89 75 48	 mov	 QWORD PTR tmp_start$27441[rbp-128], rsi
  00085	4c 89 65 b8	 mov	 QWORD PTR obj_end$27444[rbp-128], r12
  00089	4c 2b c1	 sub	 r8, rcx
  0008c	48 8d 4c 0d c8	 lea	 rcx, QWORD PTR format$27445[rbp+rcx-128]
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
  00097	48 8d 45 b8	 lea	 rax, QWORD PTR obj_end$27444[rbp-128]
  0009b	4c 8d 4d b0	 lea	 r9, QWORD PTR obj_start$27443[rbp-128]
  0009f	4c 8d 45 c0	 lea	 r8, QWORD PTR tmp_subobj$27440[rbp-128]
  000a3	48 8d 55 c8	 lea	 rdx, QWORD PTR format$27445[rbp-128]
  000a7	48 8b cb	 mov	 rcx, rbx
  000aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000af	40 88 75 f9	 mov	 BYTE PTR format$27445[rbp-79], sil
  000b3	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000b8	85 c0		 test	 eax, eax
  000ba	0f 84 ab 01 00
	00		 je	 $LN2@bytearray_@26
  000c0	48 8b 4d b0	 mov	 rcx, QWORD PTR obj_start$27443[rbp-128]
  000c4	49 3b cc	 cmp	 rcx, r12
  000c7	74 11		 je	 SHORT $LN16@bytearray_@26
  000c9	48 8d 55 48	 lea	 rdx, QWORD PTR tmp_start$27441[rbp-128]
  000cd	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000d2	85 c0		 test	 eax, eax
  000d4	0f 84 91 01 00
	00		 je	 $LN2@bytearray_@26
$LN16@bytearray_@26:
  000da	48 8b 4d b8	 mov	 rcx, QWORD PTR obj_end$27444[rbp-128]
  000de	49 3b cc	 cmp	 rcx, r12
  000e1	74 11		 je	 SHORT $LN11@bytearray_@26
  000e3	48 8d 55 40	 lea	 rdx, QWORD PTR tmp_end$27442[rbp-128]
  000e7	e8 00 00 00 00	 call	 _PyEval_SliceIndex
  000ec	85 c0		 test	 eax, eax
  000ee	0f 84 77 01 00
	00		 je	 $LN2@bytearray_@26
$LN11@bytearray_@26:

; 1394 :         return NULL;
; 1395 :     if (PyTuple_Check(subobj)) {

  000f4	48 8b 5d c0	 mov	 rbx, QWORD PTR tmp_subobj$27440[rbp-128]
  000f8	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000fc	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00106	0f 84 14 01 00
	00		 je	 $LN10@bytearray_@26

; 1396 :         Py_ssize_t i;
; 1397 :         for (i = 0; i < PyTuple_GET_SIZE(subobj); i++) {

  0010c	4c 89 ac 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], r13
  00114	48 39 73 60	 cmp	 QWORD PTR [rbx+96], rsi
  00118	7e 49		 jle	 SHORT $LN7@bytearray_@26
  0011a	4c 8b 65 48	 mov	 r12, QWORD PTR tmp_start$27441[rbp-128]
  0011e	4c 8b 6d 40	 mov	 r13, QWORD PTR tmp_end$27442[rbp-128]
  00122	48 8d 7b 70	 lea	 rdi, QWORD PTR [rbx+112]
  00126	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL9@bytearray_@26:

; 1398 :             result = _bytearray_tailmatch(self,
; 1399 :                                       PyTuple_GET_ITEM(subobj, i),
; 1400 :                                       start, end, +1);

  00130	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00133	4d 8b cd	 mov	 r9, r13
  00136	4d 8b c4	 mov	 r8, r12
  00139	49 8b ce	 mov	 rcx, r14
  0013c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00144	e8 00 00 00 00	 call	 _bytearray_tailmatch

; 1401 :             if (result == -1)

  00149	83 f8 ff	 cmp	 eax, -1
  0014c	0f 84 ca 00 00
	00		 je	 $LN30@bytearray_@26

; 1403 :             else if (result) {

  00152	85 c0		 test	 eax, eax
  00154	75 78		 jne	 SHORT $LN31@bytearray_@26

; 1396 :         Py_ssize_t i;
; 1397 :         for (i = 0; i < PyTuple_GET_SIZE(subobj); i++) {

  00156	48 ff c6	 inc	 rsi
  00159	48 83 c7 08	 add	 rdi, 8
  0015d	48 3b 73 60	 cmp	 rsi, QWORD PTR [rbx+96]
  00161	7c cd		 jl	 SHORT $LL9@bytearray_@26
$LN7@bytearray_@26:

; 1405 :             }
; 1406 :         }
; 1407 :         Py_RETURN_FALSE;

  00163	e8 00 00 00 00	 call	 _Py_PXCTX
  00168	85 c0		 test	 eax, eax
  0016a	75 3c		 jne	 SHORT $LN26@bytearray_@26
  0016c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  00173	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0017a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00181	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00187	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0018f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00194	85 c0		 test	 eax, eax
  00196	75 09		 jne	 SHORT $LN25@bytearray_@26
  00198	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  0019f	74 07		 je	 SHORT $LN26@bytearray_@26
$LN25@bytearray_@26:
  001a1	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN26@bytearray_@26:
  001a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
$LN34@bytearray_@26:
  001af	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR [rsp+176]
$LN1@bytearray_@26:

; 1418 : }

  001b7	48 8b 9c 24 b8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+184]
  001bf	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  001c6	41 5e		 pop	 r14
  001c8	41 5c		 pop	 r12
  001ca	5f		 pop	 rdi
  001cb	5e		 pop	 rsi
  001cc	5d		 pop	 rbp
  001cd	c3		 ret	 0
$LN31@bytearray_@26:

; 1404 :                 Py_RETURN_TRUE;

  001ce	e8 00 00 00 00	 call	 _Py_PXCTX
  001d3	85 c0		 test	 eax, eax
  001d5	75 3c		 jne	 SHORT $LN22@bytearray_@26
  001d7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_TrueStruct
  001de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  001ec	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  001f2	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001fa	e8 00 00 00 00	 call	 _PyParallel_Guard
  001ff	85 c0		 test	 eax, eax
  00201	75 09		 jne	 SHORT $LN21@bytearray_@26
  00203	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  0020a	74 07		 je	 SHORT $LN22@bytearray_@26
$LN21@bytearray_@26:
  0020c	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80
$LN22@bytearray_@26:
  00213	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  0021a	eb 93		 jmp	 SHORT $LN34@bytearray_@26
$LN30@bytearray_@26:

; 1402 :                 return NULL;

  0021c	33 c0		 xor	 eax, eax
  0021e	eb 8f		 jmp	 SHORT $LN34@bytearray_@26
$LN10@bytearray_@26:

; 1408 :     }
; 1409 :     result = _bytearray_tailmatch(self, subobj, start, end, +1);

  00220	4c 8b 4d 40	 mov	 r9, QWORD PTR tmp_end$27442[rbp-128]
  00224	4c 8b 45 48	 mov	 r8, QWORD PTR tmp_start$27441[rbp-128]
  00228	48 8b d3	 mov	 rdx, rbx
  0022b	49 8b ce	 mov	 rcx, r14
  0022e	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00236	e8 00 00 00 00	 call	 _bytearray_tailmatch

; 1410 :     if (result == -1) {

  0023b	83 f8 ff	 cmp	 eax, -1
  0023e	75 32		 jne	 SHORT $LN3@bytearray_@26

; 1411 :         if (PyErr_ExceptionMatches(PyExc_TypeError))

  00240	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00247	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0024c	85 c0		 test	 eax, eax
  0024e	74 1b		 je	 SHORT $LN2@bytearray_@26

; 1412 :             PyErr_Format(PyExc_TypeError, "endswith first arg must be bytes or "
; 1413 :                          "a tuple of bytes, not %s", Py_TYPE(subobj)->tp_name);

  00250	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  00254	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0025b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@DLKPFMBA@endswith?5first?5arg?5must?5be?5bytes@
  00262	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00266	e8 00 00 00 00	 call	 PyErr_Format
$LN2@bytearray_@26:

; 1414 :         return NULL;

  0026b	33 c0		 xor	 eax, eax
  0026d	e9 45 ff ff ff	 jmp	 $LN1@bytearray_@26
$LN3@bytearray_@26:

; 1415 :     }
; 1416 :     else
; 1417 :         return PyBool_FromLong(result);

  00272	8b c8		 mov	 ecx, eax
  00274	e8 00 00 00 00	 call	 PyBool_FromLong
  00279	e9 39 ff ff ff	 jmp	 $LN1@bytearray_@26
bytearray_endswith ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@LKHHMEFM@bytearray_translate?$AA@	; `string'
PUBLIC	??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@ ; `string'
PUBLIC	??_C@_0CO@HBGAJPNJ@translation?5table?5must?5be?5256?5ch@ ; `string'
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_translate DD imagerel bytearray_translate
	DD	imagerel bytearray_translate+272
	DD	imagerel $unwind$bytearray_translate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$bytearray_translate DD imagerel bytearray_translate+272
	DD	imagerel bytearray_translate+280
	DD	imagerel $chain$1$bytearray_translate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$bytearray_translate DD imagerel bytearray_translate+280
	DD	imagerel bytearray_translate+646
	DD	imagerel $chain$2$bytearray_translate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$bytearray_translate DD imagerel bytearray_translate+646
	DD	imagerel bytearray_translate+685
	DD	imagerel $chain$3$bytearray_translate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$bytearray_translate DD imagerel bytearray_translate+685
	DD	imagerel bytearray_translate+705
	DD	imagerel $chain$4$bytearray_translate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$bytearray_translate DD 021H
	DD	imagerel bytearray_translate
	DD	imagerel bytearray_translate+272
	DD	imagerel $unwind$bytearray_translate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$bytearray_translate DD 021H
	DD	imagerel bytearray_translate+272
	DD	imagerel bytearray_translate+280
	DD	imagerel $chain$1$bytearray_translate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$bytearray_translate DD 020821H
	DD	09ac408H
	DD	imagerel bytearray_translate+272
	DD	imagerel bytearray_translate+280
	DD	imagerel $chain$1$bytearray_translate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$bytearray_translate DD 020821H
	DD	09b6408H
	DD	imagerel bytearray_translate
	DD	imagerel bytearray_translate+272
	DD	imagerel $unwind$bytearray_translate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_translate DD 078201H
	DD	0a13482H
	DD	09c0114H
	DD	07003d005H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0BE@LKHHMEFM@bytearray_translate?$AA@
CONST	SEGMENT
??_C@_0BE@LKHHMEFM@bytearray_translate?$AA@ DB 'bytearray_translate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@
CONST	SEGMENT
??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@ DB '..\Objects\'
	DB	'bytearrayobject.c', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HBGAJPNJ@translation?5table?5must?5be?5256?5ch@
CONST	SEGMENT
??_C@_0CO@HBGAJPNJ@translation?5table?5must?5be?5256?5ch@ DB 'translation'
	DB	' table must be 256 characters long', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_translate
_TEXT	SEGMENT
vdel$ = 48
vtable$ = 128
trans_table$ = 208
tableobj$ = 1280
self$ = 1280
args$ = 1288
delobj$ = 1296
bytearray_translate PROC				; COMDAT

; 1431 : {

  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	41 55		 push	 r13
  00005	48 8d ac 24 20
	fc ff ff	 lea	 rbp, QWORD PTR [rsp-992]
  0000d	48 81 ec e0 04
	00 00		 sub	 rsp, 1248		; 000004e0H
  00014	48 8b f9	 mov	 rdi, rcx

; 1432 :     register char *input, *output;
; 1433 :     register const char *table;
; 1434 :     register Py_ssize_t i, c;
; 1435 :     PyObject *input_obj = (PyObject*)self;
; 1436 :     const char *output_start;
; 1437 :     Py_ssize_t inlen;
; 1438 :     PyObject *result = NULL;
; 1439 :     int trans_table[256];
; 1440 :     PyObject *tableobj = NULL, *delobj = NULL;

  00017	45 33 ed	 xor	 r13d, r13d
  0001a	48 8b c2	 mov	 rax, rdx

; 1441 :     Py_buffer vtable, vdel;
; 1442 : 
; 1443 :     if (!PyArg_UnpackTuple(args, "translate", 1, 2,
; 1444 :                            &tableobj, &delobj))

  0001d	48 8d 8d 10 04
	00 00		 lea	 rcx, QWORD PTR delobj$[rbp-256]
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09ODNGOEIO@translate?$AA@
  0002b	45 8d 4d 02	 lea	 r9d, QWORD PTR [r13+2]
  0002f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00034	48 8d 8d 00 04
	00 00		 lea	 rcx, QWORD PTR tableobj$[rbp-256]
  0003b	45 8d 45 01	 lea	 r8d, QWORD PTR [r13+1]
  0003f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00044	48 8b c8	 mov	 rcx, rax
  00047	4c 89 ad 00 04
	00 00		 mov	 QWORD PTR tableobj$[rbp-256], r13
  0004e	4c 89 ad 10 04
	00 00		 mov	 QWORD PTR delobj$[rbp-256], r13
  00055	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0005a	85 c0		 test	 eax, eax
  0005c	75 0e		 jne	 SHORT $LN37@bytearray_@27

; 1445 :           return NULL;

  0005e	33 c0		 xor	 eax, eax

; 1520 : }

  00060	48 81 c4 e0 04
	00 00		 add	 rsp, 1248		; 000004e0H
  00067	41 5d		 pop	 r13
  00069	5f		 pop	 rdi
  0006a	5d		 pop	 rbp
  0006b	c3		 ret	 0
$LN37@bytearray_@27:

; 1446 : 
; 1447 :     if (tableobj == Py_None) {

  0006c	48 8b 8d 00 04
	00 00		 mov	 rcx, QWORD PTR tableobj$[rbp-256]
  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0007a	48 89 9c 24 08
	05 00 00	 mov	 QWORD PTR [rsp+1288], rbx
  00082	48 3b c8	 cmp	 rcx, rax
  00085	75 0c		 jne	 SHORT $LN36@bytearray_@27

; 1448 :         table = NULL;

  00087	49 8b dd	 mov	 rbx, r13

; 1449 :         tableobj = NULL;

  0008a	4c 89 ad 00 04
	00 00		 mov	 QWORD PTR tableobj$[rbp-256], r13
  00091	eb 3f		 jmp	 SHORT $LN33@bytearray_@27
$LN36@bytearray_@27:

; 1450 :     } else if (_getbuffer(tableobj, &vtable) < 0) {

  00093	48 8d 55 80	 lea	 rdx, QWORD PTR vtable$[rbp-256]
  00097	e8 00 00 00 00	 call	 _getbuffer
  0009c	48 85 c0	 test	 rax, rax

; 1451 :         return NULL;

  0009f	78 5e		 js	 SHORT $LN29@bytearray_@27

; 1452 :     } else {
; 1453 :         if (vtable.len != 256) {

  000a1	48 81 7d 90 00
	01 00 00	 cmp	 QWORD PTR vtable$[rbp-240], 256 ; 00000100H
  000a9	74 23		 je	 SHORT $LN32@bytearray_@27

; 1454 :             PyErr_SetString(PyExc_ValueError,
; 1455 :                             "translation table must be 256 characters long");

  000ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@HBGAJPNJ@translation?5table?5must?5be?5256?5ch@
  000b9	e8 00 00 00 00	 call	 PyErr_SetString

; 1456 :             PyBuffer_Release(&vtable);

  000be	48 8d 4d 80	 lea	 rcx, QWORD PTR vtable$[rbp-256]
  000c2	e8 00 00 00 00	 call	 PyBuffer_Release

; 1457 :             return NULL;

  000c7	33 c0		 xor	 eax, eax
  000c9	e9 df 01 00 00	 jmp	 $LN53@bytearray_@27
$LN32@bytearray_@27:

; 1458 :         }
; 1459 :         table = (const char*)vtable.buf;

  000ce	48 8b 5d 80	 mov	 rbx, QWORD PTR vtable$[rbp-256]
$LN33@bytearray_@27:

; 1460 :     }
; 1461 : 
; 1462 :     if (delobj != NULL) {

  000d2	48 8b 8d 10 04
	00 00		 mov	 rcx, QWORD PTR delobj$[rbp-256]
  000d9	48 85 c9	 test	 rcx, rcx
  000dc	74 28		 je	 SHORT $LN31@bytearray_@27

; 1463 :         if (_getbuffer(delobj, &vdel) < 0) {

  000de	48 8d 54 24 30	 lea	 rdx, QWORD PTR vdel$[rsp]
  000e3	e8 00 00 00 00	 call	 _getbuffer
  000e8	48 85 c0	 test	 rax, rax
  000eb	79 23		 jns	 SHORT $LN28@bytearray_@27

; 1464 :             if (tableobj != NULL)

  000ed	4c 39 ad 00 04
	00 00		 cmp	 QWORD PTR tableobj$[rbp-256], r13
  000f4	74 09		 je	 SHORT $LN29@bytearray_@27

; 1465 :                 PyBuffer_Release(&vtable);

  000f6	48 8d 4d 80	 lea	 rcx, QWORD PTR vtable$[rbp-256]
  000fa	e8 00 00 00 00	 call	 PyBuffer_Release
$LN29@bytearray_@27:

; 1466 :             return NULL;

  000ff	33 c0		 xor	 eax, eax
  00101	e9 a7 01 00 00	 jmp	 $LN53@bytearray_@27
$LN31@bytearray_@27:

; 1467 :         }
; 1468 :     }
; 1469 :     else {
; 1470 :         vdel.buf = NULL;

  00106	4c 89 6c 24 30	 mov	 QWORD PTR vdel$[rsp], r13

; 1471 :         vdel.len = 0;

  0010b	4c 89 6c 24 40	 mov	 QWORD PTR vdel$[rsp+16], r13
$LN28@bytearray_@27:

; 1472 :     }
; 1473 : 
; 1474 :     inlen = PyByteArray_GET_SIZE(input_obj);

  00110	48 89 b4 24 d8
	04 00 00	 mov	 QWORD PTR [rsp+1240], rsi
  00118	4c 89 a4 24 d0
	04 00 00	 mov	 QWORD PTR [rsp+1232], r12
  00120	4c 8b 67 60	 mov	 r12, QWORD PTR [rdi+96]

; 1475 :     result = PyByteArray_FromStringAndSize((char *)NULL, inlen);

  00124	49 8b d4	 mov	 rdx, r12
  00127	33 c9		 xor	 ecx, ecx
  00129	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0012e	48 8b f0	 mov	 rsi, rax

; 1476 :     if (result == NULL)

  00131	48 85 c0	 test	 rax, rax
  00134	0f 84 3b 01 00
	00		 je	 $done$22479

; 1477 :         goto done;
; 1478 :     output_start = output = PyByteArray_AsString(result);

  0013a	48 8b c8	 mov	 rcx, rax
  0013d	e8 00 00 00 00	 call	 PyByteArray_AsString
  00142	48 8b d0	 mov	 rdx, rax
  00145	4c 8b d8	 mov	 r11, rax

; 1479 :     input = PyByteArray_AS_STRING(input_obj);

  00148	4c 39 6f 60	 cmp	 QWORD PTR [rdi+96], r13
  0014c	74 09		 je	 SHORT $LN40@bytearray_@27
  0014e	4c 8b 87 80 00
	00 00		 mov	 r8, QWORD PTR [rdi+128]
  00155	eb 07		 jmp	 SHORT $LN41@bytearray_@27
$LN40@bytearray_@27:
  00157	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_PyByteArray_empty_string
$LN41@bytearray_@27:

; 1480 : 
; 1481 :     if (vdel.len == 0 && table != NULL) {

  0015e	4c 8b 54 24 40	 mov	 r10, QWORD PTR vdel$[rsp+16]
  00163	4d 85 d2	 test	 r10, r10
  00166	75 31		 jne	 SHORT $LN26@bytearray_@27
  00168	48 85 db	 test	 rbx, rbx
  0016b	74 31		 je	 SHORT $LN52@bytearray_@27

; 1482 :         /* If no deletions are required, use faster code */
; 1483 :         for (i = inlen; --i >= 0; ) {

  0016d	4d 8d 4c 24 ff	 lea	 r9, QWORD PTR [r12-1]
  00172	4d 85 c9	 test	 r9, r9
  00175	0f 88 fa 00 00
	00		 js	 $done$22479
  0017b	4c 2b c0	 sub	 r8, rax
  0017e	66 90		 npad	 2
$LL25@bytearray_@27:

; 1484 :             c = Py_CHARMASK(*input++);

  00180	41 0f b6 04 10	 movzx	 eax, BYTE PTR [r8+rdx]

; 1485 :             *output++ = table[c];

  00185	48 ff c2	 inc	 rdx
  00188	49 ff c9	 dec	 r9
  0018b	0f b6 0c 18	 movzx	 ecx, BYTE PTR [rax+rbx]
  0018f	88 4a ff	 mov	 BYTE PTR [rdx-1], cl
  00192	79 ec		 jns	 SHORT $LL25@bytearray_@27

; 1486 :         }
; 1487 :         goto done;

  00194	e9 dc 00 00 00	 jmp	 $done$22479
$LN26@bytearray_@27:

; 1488 :     }
; 1489 : 
; 1490 :     if (table == NULL) {

  00199	48 85 db	 test	 rbx, rbx
  0019c	75 18		 jne	 SHORT $LN23@bytearray_@27
$LN52@bytearray_@27:

; 1491 :         for (i = 0; i < 256; i++)

  0019e	49 8b cd	 mov	 rcx, r13
$LL22@bytearray_@27:

; 1492 :             trans_table[i] = Py_CHARMASK(i);

  001a1	0f b6 c1	 movzx	 eax, cl
  001a4	48 ff c1	 inc	 rcx
  001a7	89 44 8d cc	 mov	 DWORD PTR trans_table$[rbp+rcx*4-260], eax
  001ab	48 81 f9 00 01
	00 00		 cmp	 rcx, 256		; 00000100H
  001b2	7c ed		 jl	 SHORT $LL22@bytearray_@27

; 1493 :     } else {

  001b4	eb 1e		 jmp	 SHORT $LN16@bytearray_@27
$LN23@bytearray_@27:

; 1494 :         for (i = 0; i < 256; i++)

  001b6	49 8b cd	 mov	 rcx, r13
  001b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL18@bytearray_@27:

; 1495 :             trans_table[i] = Py_CHARMASK(table[i]);

  001c0	0f b6 04 19	 movzx	 eax, BYTE PTR [rcx+rbx]
  001c4	48 ff c1	 inc	 rcx
  001c7	89 44 8d cc	 mov	 DWORD PTR trans_table$[rbp+rcx*4-260], eax
  001cb	48 81 f9 00 01
	00 00		 cmp	 rcx, 256		; 00000100H
  001d2	7c ec		 jl	 SHORT $LL18@bytearray_@27
$LN16@bytearray_@27:

; 1496 :     }
; 1497 : 
; 1498 :     for (i = 0; i < vdel.len; i++)

  001d4	49 8b cd	 mov	 rcx, r13
  001d7	4d 85 d2	 test	 r10, r10
  001da	7e 29		 jle	 SHORT $LN13@bytearray_@27
  001dc	4c 8b 4c 24 30	 mov	 r9, QWORD PTR vdel$[rsp]
  001e1	66 66 66 66 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL15@bytearray_@27:

; 1499 :         trans_table[(int) Py_CHARMASK( ((unsigned char*)vdel.buf)[i] )] = -1;

  001f0	42 0f b6 04 09	 movzx	 eax, BYTE PTR [rcx+r9]
  001f5	48 ff c1	 inc	 rcx
  001f8	c7 44 85 d0 ff
	ff ff ff	 mov	 DWORD PTR trans_table$[rbp+rax*4-256], -1
  00200	49 3b ca	 cmp	 rcx, r10
  00203	7c eb		 jl	 SHORT $LL15@bytearray_@27
$LN13@bytearray_@27:

; 1500 : 
; 1501 :     for (i = inlen; --i >= 0; ) {

  00205	49 8d 4c 24 ff	 lea	 rcx, QWORD PTR [r12-1]
  0020a	48 85 c9	 test	 rcx, rcx
  0020d	78 1f		 js	 SHORT $LN11@bytearray_@27
  0020f	90		 npad	 1
$LL12@bytearray_@27:

; 1502 :         c = Py_CHARMASK(*input++);

  00210	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00214	49 ff c0	 inc	 r8

; 1503 :         if (trans_table[c] != -1)

  00217	83 7c 85 d0 ff	 cmp	 DWORD PTR trans_table$[rbp+rax*4-256], -1
  0021c	74 0b		 je	 SHORT $LN9@bytearray_@27

; 1504 :             if (Py_CHARMASK(*output++ = (char)trans_table[c]) == c)

  0021e	0f b6 44 85 d0	 movzx	 eax, BYTE PTR trans_table$[rbp+rax*4-256]
  00223	48 ff c2	 inc	 rdx
  00226	88 42 ff	 mov	 BYTE PTR [rdx-1], al
$LN9@bytearray_@27:

; 1500 : 
; 1501 :     for (i = inlen; --i >= 0; ) {

  00229	48 ff c9	 dec	 rcx
  0022c	79 e2		 jns	 SHORT $LL12@bytearray_@27
$LN11@bytearray_@27:

; 1505 :                     continue;
; 1506 :     }
; 1507 :     /* Fix the size of the resulting string */
; 1508 :     if (inlen > 0)

  0022e	4d 85 e4	 test	 r12, r12
  00231	7e 42		 jle	 SHORT $done$22479

; 1509 :         if (PyByteArray_Resize(result, output - output_start) < 0) {

  00233	49 2b d3	 sub	 rdx, r11
  00236	48 8b ce	 mov	 rcx, rsi
  00239	e8 00 00 00 00	 call	 PyByteArray_Resize
  0023e	85 c0		 test	 eax, eax
  00240	79 33		 jns	 SHORT $done$22479

; 1510 :             Py_CLEAR(result);

  00242	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@
  00249	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@LKHHMEFM@bytearray_translate?$AA@
  00250	4c 8b ce	 mov	 r9, rsi
  00253	41 b8 e6 05 00
	00		 mov	 r8d, 1510		; 000005e6H
  00259	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00261	e8 00 00 00 00	 call	 _PyParallel_Guard
  00266	85 c0		 test	 eax, eax
  00268	75 0b		 jne	 SHORT $done$22479
  0026a	48 8b ce	 mov	 rcx, rsi
  0026d	49 8b f5	 mov	 rsi, r13
  00270	e8 00 00 00 00	 call	 _Py_DecRef
$done$22479:

; 1511 :             goto done;
; 1512 :         }
; 1513 : 
; 1514 : done:
; 1515 :     if (tableobj != NULL)

  00275	4c 8b a4 24 d0
	04 00 00	 mov	 r12, QWORD PTR [rsp+1232]
  0027d	4c 39 ad 00 04
	00 00		 cmp	 QWORD PTR tableobj$[rbp-256], r13
  00284	74 09		 je	 SHORT $LN2@bytearray_@27

; 1516 :         PyBuffer_Release(&vtable);

  00286	48 8d 4d 80	 lea	 rcx, QWORD PTR vtable$[rbp-256]
  0028a	e8 00 00 00 00	 call	 PyBuffer_Release
$LN2@bytearray_@27:

; 1517 :     if (delobj != NULL)

  0028f	4c 39 ad 10 04
	00 00		 cmp	 QWORD PTR delobj$[rbp-256], r13
  00296	74 0a		 je	 SHORT $LN1@bytearray_@27

; 1518 :         PyBuffer_Release(&vdel);

  00298	48 8d 4c 24 30	 lea	 rcx, QWORD PTR vdel$[rsp]
  0029d	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@bytearray_@27:

; 1519 :     return result;

  002a2	48 8b c6	 mov	 rax, rsi
  002a5	48 8b b4 24 d8
	04 00 00	 mov	 rsi, QWORD PTR [rsp+1240]
$LN53@bytearray_@27:
  002ad	48 8b 9c 24 08
	05 00 00	 mov	 rbx, QWORD PTR [rsp+1288]

; 1520 : }

  002b5	48 81 c4 e0 04
	00 00		 add	 rsp, 1248		; 000004e0H
  002bc	41 5d		 pop	 r13
  002be	5f		 pop	 rdi
  002bf	5d		 pop	 rbp
  002c0	c3		 ret	 0
bytearray_translate ENDP
_TEXT	ENDS
EXTRN	_Py_bytes_maketrans:PROC
; Function compile flags: /Ogtpy
;	COMDAT bytearray_maketrans
_TEXT	SEGMENT
null$ = 8
args$ = 16
bytearray_maketrans PROC				; COMDAT

; 1526 :         return _Py_bytes_maketrans(args);

  00000	48 8b ca	 mov	 rcx, rdx

; 1527 : }

  00003	e9 00 00 00 00	 jmp	 _Py_bytes_maketrans
bytearray_maketrans ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT return_self
_TEXT	SEGMENT
self$ = 8
return_self PROC					; COMDAT

; 1540 :     /* always return a new bytearray */
; 1541 :     return (PyByteArrayObject *)PyByteArray_FromStringAndSize(
; 1542 :             PyByteArray_AS_STRING(self),
; 1543 :             PyByteArray_GET_SIZE(self));

  00000	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00004	48 85 d2	 test	 rdx, rdx
  00007	74 0c		 je	 SHORT $LN3@return_sel
  00009	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]

; 1544 : }

  00010	e9 00 00 00 00	 jmp	 PyByteArray_FromStringAndSize
$LN3@return_sel:

; 1540 :     /* always return a new bytearray */
; 1541 :     return (PyByteArrayObject *)PyByteArray_FromStringAndSize(
; 1542 :             PyByteArray_AS_STRING(self),
; 1543 :             PyByteArray_GET_SIZE(self));

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string

; 1544 : }

  0001c	e9 00 00 00 00	 jmp	 PyByteArray_FromStringAndSize
return_self ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$countchar DD imagerel countchar
	DD	imagerel countchar+109
	DD	imagerel $unwind$countchar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$countchar DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT countchar
_TEXT	SEGMENT
target$ = 48
target_len$ = 56
c$ = 64
maxcount$ = 72
countchar PROC						; COMDAT

; 1548 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1549 :     Py_ssize_t count=0;
; 1550 :     const char *start=target;
; 1551 :     const char *end=target+target_len;
; 1552 : 
; 1553 :     while ( (start=findchar(start, end-start, c)) != NULL ) {

  00014	41 0f be e8	 movsx	 ebp, r8b
  00018	48 8d 34 11	 lea	 rsi, QWORD PTR [rcx+rdx]
  0001c	49 8b f9	 mov	 rdi, r9
  0001f	4c 8b c6	 mov	 r8, rsi
  00022	8b d5		 mov	 edx, ebp
  00024	33 db		 xor	 ebx, ebx
  00026	4c 2b c1	 sub	 r8, rcx
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0002f	48 85 c0	 test	 rax, rax
  00032	74 21		 je	 SHORT $LN10@countchar
$LL3@countchar:

; 1554 :         count++;

  00034	48 ff c3	 inc	 rbx

; 1555 :         if (count >= maxcount)

  00037	48 3b df	 cmp	 rbx, rdi
  0003a	7d 19		 jge	 SHORT $LN10@countchar

; 1556 :             break;
; 1557 :         start += 1;

  0003c	48 ff c0	 inc	 rax
  0003f	4c 8b c6	 mov	 r8, rsi
  00042	8b d5		 mov	 edx, ebp
  00044	4c 2b c0	 sub	 r8, rax
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00050	48 85 c0	 test	 rax, rax
  00053	75 df		 jne	 SHORT $LL3@countchar
$LN10@countchar:

; 1558 :     }
; 1559 :     return count;
; 1560 : }

  00055	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0005a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0005f	48 8b c3	 mov	 rax, rbx
  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5f		 pop	 rdi
  0006c	c3		 ret	 0
countchar ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@HBDILGAP@replace?5string?5is?5too?5long?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_interleave DD imagerel replace_interleave
	DD	imagerel replace_interleave+109
	DD	imagerel $unwind$replace_interleave
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$replace_interleave DD imagerel replace_interleave+109
	DD	imagerel replace_interleave+157
	DD	imagerel $chain$0$replace_interleave
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$replace_interleave DD imagerel replace_interleave+157
	DD	imagerel replace_interleave+168
	DD	imagerel $chain$3$replace_interleave
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$replace_interleave DD imagerel replace_interleave+168
	DD	imagerel replace_interleave+418
	DD	imagerel $chain$4$replace_interleave
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$replace_interleave DD imagerel replace_interleave+418
	DD	imagerel replace_interleave+490
	DD	imagerel $chain$5$replace_interleave
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$replace_interleave DD 021H
	DD	imagerel replace_interleave+157
	DD	imagerel replace_interleave+168
	DD	imagerel $chain$3$replace_interleave
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$replace_interleave DD 020521H
	DD	04f405H
	DD	imagerel replace_interleave+157
	DD	imagerel replace_interleave+168
	DD	imagerel $chain$3$replace_interleave
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$replace_interleave DD 040b21H
	DD	0f340bH
	DD	057400H
	DD	imagerel replace_interleave
	DD	imagerel replace_interleave+109
	DD	imagerel $unwind$replace_interleave
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$replace_interleave DD 020521H
	DD	057405H
	DD	imagerel replace_interleave
	DD	imagerel replace_interleave+109
	DD	imagerel $unwind$replace_interleave
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_interleave DD 061101H
	DD	0e00d5211H
	DD	0c009d00bH
	DD	050066007H
xdata	ENDS
;	COMDAT ??_C@_0BL@HBDILGAP@replace?5string?5is?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BL@HBDILGAP@replace?5string?5is?5too?5long?$AA@ DB 'replace string'
	DB	' is too long', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT replace_interleave
_TEXT	SEGMENT
n_$1$ = 96
self$ = 96
to_s$ = 104
result$1$ = 112
to_len$ = 112
maxcount$ = 120
replace_interleave PROC					; COMDAT

; 1570 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1571 :     char *self_s, *result_s;
; 1572 :     Py_ssize_t self_len, result_len;
; 1573 :     Py_ssize_t count, i;
; 1574 :     PyByteArrayObject *result;
; 1575 : 
; 1576 :     self_len = PyByteArray_GET_SIZE(self);

  00011	48 8b 71 60	 mov	 rsi, QWORD PTR [rcx+96]
  00015	4d 8b e9	 mov	 r13, r9
  00018	49 8b e8	 mov	 rbp, r8
  0001b	4c 8b f2	 mov	 r14, rdx
  0001e	4c 8b e1	 mov	 r12, rcx
  00021	48 89 74 24 60	 mov	 QWORD PTR n_$1$[rsp], rsi

; 1577 : 
; 1578 :     /* 1 at the end plus 1 after every character;
; 1579 :        count = min(maxcount, self_len + 1) */
; 1580 :     if (maxcount <= self_len)

  00026	4c 3b ce	 cmp	 r9, rsi
  00029	7e 04		 jle	 SHORT $LN30@replace_in

; 1581 :         count = maxcount;
; 1582 :     else
; 1583 :         /* Can't overflow: self_len + 1 <= maxcount <= PY_SSIZE_T_MAX. */
; 1584 :         count = self_len + 1;

  0002b	4c 8d 6e 01	 lea	 r13, QWORD PTR [rsi+1]
$LN30@replace_in:

; 1585 : 
; 1586 :     /* Check for overflow */
; 1587 :     /*   result_len = count * to_len + self_len; */
; 1588 :     assert(count > 0);
; 1589 :     if (to_len > (PY_SSIZE_T_MAX - self_len) / count) {

  0002f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00039	48 2b c6	 sub	 rax, rsi
  0003c	48 99		 cdq
  0003e	49 f7 fd	 idiv	 r13
  00041	4c 3b c0	 cmp	 r8, rax
  00044	7e 22		 jle	 SHORT $LN29@replace_in

; 1590 :         PyErr_SetString(PyExc_OverflowError,
; 1591 :                         "replace string is too long");

  00046	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@HBDILGAP@replace?5string?5is?5too?5long?$AA@
  00054	e8 00 00 00 00	 call	 PyErr_SetString

; 1592 :         return NULL;

  00059	33 c0		 xor	 eax, eax

; 1620 : }

  0005b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005f	41 5e		 pop	 r14
  00061	41 5d		 pop	 r13
  00063	41 5c		 pop	 r12
  00065	5e		 pop	 rsi
  00066	5d		 pop	 rbp
  00067	c3		 ret	 0
$LN29@replace_in:

; 1593 :     }
; 1594 :     result_len = count * to_len + self_len;

  00068	49 8b d5	 mov	 rdx, r13

; 1595 : 
; 1596 :     if (! (result = (PyByteArrayObject *)
; 1597 :                      PyByteArray_FromStringAndSize(NULL, result_len)) )

  0006b	33 c9		 xor	 ecx, ecx
  0006d	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  00072	48 0f af d5	 imul	 rdx, rbp
  00076	48 03 d6	 add	 rdx, rsi
  00079	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0007e	48 8b f8	 mov	 rdi, rax
  00081	48 89 44 24 70	 mov	 QWORD PTR result$1$[rsp], rax
  00086	48 85 c0	 test	 rax, rax
  00089	75 12		 jne	 SHORT $LN28@replace_in
  0008b	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]

; 1620 : }

  00090	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00094	41 5e		 pop	 r14
  00096	41 5d		 pop	 r13
  00098	41 5c		 pop	 r12
  0009a	5e		 pop	 rsi
  0009b	5d		 pop	 rbp
  0009c	c3		 ret	 0
$LN28@replace_in:

; 1598 :         return NULL;
; 1599 : 
; 1600 :     self_s = PyByteArray_AS_STRING(self);

  0009d	49 83 7c 24 60
	00		 cmp	 QWORD PTR [r12+96], 0
  000a3	48 89 5c 24 78	 mov	 QWORD PTR [rsp+120], rbx
  000a8	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  000ad	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_PyByteArray_empty_string
  000b4	74 0a		 je	 SHORT $LN34@replace_in
  000b6	4d 8b a4 24 80
	00 00 00	 mov	 r12, QWORD PTR [r12+128]
  000be	eb 03		 jmp	 SHORT $LN35@replace_in
$LN34@replace_in:
  000c0	4c 8b e3	 mov	 r12, rbx
$LN35@replace_in:

; 1601 :     result_s = PyByteArray_AS_STRING(result);

  000c3	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000c8	74 07		 je	 SHORT $LN36@replace_in
  000ca	48 8b 98 80 00
	00 00		 mov	 rbx, QWORD PTR [rax+128]
$LN36@replace_in:

; 1602 : 
; 1603 :     /* TODO: special case single character, which doesn't need memcpy */
; 1604 : 
; 1605 :     /* Lay the first one down (guaranteed this will occur) */
; 1606 :     Py_MEMCPY(result_s, to_s, to_len);

  000d1	48 83 fd 10	 cmp	 rbp, 16
  000d5	72 10		 jb	 SHORT $LN24@replace_in
  000d7	4c 8b c5	 mov	 r8, rbp
  000da	49 8b d6	 mov	 rdx, r14
  000dd	48 8b cb	 mov	 rcx, rbx
  000e0	e8 00 00 00 00	 call	 memcpy
  000e5	eb 29		 jmp	 SHORT $LN26@replace_in
$LN24@replace_in:
  000e7	48 85 ed	 test	 rbp, rbp
  000ea	74 24		 je	 SHORT $LN26@replace_in
  000ec	4d 8b c6	 mov	 r8, r14
  000ef	48 8b cb	 mov	 rcx, rbx
  000f2	48 8b d5	 mov	 rdx, rbp
  000f5	4c 2b c3	 sub	 r8, rbx
  000f8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL22@replace_in:
  00100	41 0f b6 04 08	 movzx	 eax, BYTE PTR [r8+rcx]
  00105	48 ff c1	 inc	 rcx
  00108	48 ff ca	 dec	 rdx
  0010b	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0010e	75 f0		 jne	 SHORT $LL22@replace_in
$LN26@replace_in:

; 1608 :     count -= 1;

  00110	49 ff cd	 dec	 r13
  00113	48 03 dd	 add	 rbx, rbp

; 1609 : 
; 1610 :     for (i=0; i<count; i++) {

  00116	45 33 ff	 xor	 r15d, r15d
  00119	4d 85 ed	 test	 r13, r13
  0011c	7e 76		 jle	 SHORT $LN8@replace_in

; 1607 :     result_s += to_len;

  0011e	48 8b 74 24 68	 mov	 rsi, QWORD PTR to_s$[rsp]
  00123	4c 8b f5	 mov	 r14, rbp

; 1609 : 
; 1610 :     for (i=0; i<count; i++) {

  00126	4d 8b fd	 mov	 r15, r13
  00129	48 8b fe	 mov	 rdi, rsi
  0012c	49 f7 de	 neg	 r14
  0012f	48 2b fb	 sub	 rdi, rbx
$LL19@replace_in:

; 1611 :         *result_s++ = *self_s++;

  00132	41 0f b6 04 24	 movzx	 eax, BYTE PTR [r12]
  00137	48 ff c3	 inc	 rbx
  0013a	48 ff cf	 dec	 rdi
  0013d	88 43 ff	 mov	 BYTE PTR [rbx-1], al
  00140	49 ff c4	 inc	 r12

; 1612 :         Py_MEMCPY(result_s, to_s, to_len);

  00143	48 83 fd 10	 cmp	 rbp, 16
  00147	72 10		 jb	 SHORT $LN13@replace_in
  00149	4c 8b c5	 mov	 r8, rbp
  0014c	48 8b d6	 mov	 rdx, rsi
  0014f	48 8b cb	 mov	 rcx, rbx
  00152	e8 00 00 00 00	 call	 memcpy
  00157	eb 26		 jmp	 SHORT $LN15@replace_in
$LN13@replace_in:
  00159	48 85 ed	 test	 rbp, rbp
  0015c	74 21		 je	 SHORT $LN15@replace_in
  0015e	48 8b cb	 mov	 rcx, rbx
  00161	48 8b d5	 mov	 rdx, rbp
  00164	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL11@replace_in:
  00170	0f b6 04 0f	 movzx	 eax, BYTE PTR [rdi+rcx]
  00174	48 ff c1	 inc	 rcx
  00177	48 ff ca	 dec	 rdx
  0017a	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0017d	75 f1		 jne	 SHORT $LL11@replace_in
$LN15@replace_in:

; 1613 :         result_s += to_len;

  0017f	48 03 dd	 add	 rbx, rbp
  00182	49 03 fe	 add	 rdi, r14
  00185	49 ff cd	 dec	 r13
  00188	75 a8		 jne	 SHORT $LL19@replace_in
  0018a	48 8b 74 24 60	 mov	 rsi, QWORD PTR n_$1$[rsp]
  0018f	48 8b 7c 24 70	 mov	 rdi, QWORD PTR result$1$[rsp]
$LN8@replace_in:

; 1614 :     }
; 1615 : 
; 1616 :     /* Copy the rest of the original string */
; 1617 :     Py_MEMCPY(result_s, self_s, self_len-i);

  00194	49 2b f7	 sub	 rsi, r15
  00197	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  0019c	48 83 fe 10	 cmp	 rsi, 16
  001a0	72 10		 jb	 SHORT $LN5@replace_in
  001a2	4c 8b c6	 mov	 r8, rsi
  001a5	49 8b d4	 mov	 rdx, r12
  001a8	48 8b cb	 mov	 rcx, rbx
  001ab	e8 00 00 00 00	 call	 memcpy
  001b0	eb 1e		 jmp	 SHORT $LN7@replace_in
$LN5@replace_in:
  001b2	48 85 f6	 test	 rsi, rsi
  001b5	74 19		 je	 SHORT $LN7@replace_in
  001b7	4c 2b e3	 sub	 r12, rbx
  001ba	66 0f 1f 44 00
	00		 npad	 6
$LL3@replace_in:
  001c0	41 0f b6 04 1c	 movzx	 eax, BYTE PTR [r12+rbx]
  001c5	48 ff c3	 inc	 rbx
  001c8	48 ff ce	 dec	 rsi
  001cb	88 43 ff	 mov	 BYTE PTR [rbx-1], al
  001ce	75 f0		 jne	 SHORT $LL3@replace_in
$LN7@replace_in:
  001d0	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]

; 1618 : 
; 1619 :     return result;

  001d5	48 8b c7	 mov	 rax, rdi
  001d8	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]

; 1620 : }

  001dd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001e1	41 5e		 pop	 r14
  001e3	41 5d		 pop	 r13
  001e5	41 5c		 pop	 r12
  001e7	5e		 pop	 rsi
  001e8	5d		 pop	 rbp
  001e9	c3		 ret	 0
replace_interleave ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_delete_single_character DD imagerel replace_delete_single_character
	DD	imagerel replace_delete_single_character+383
	DD	imagerel $unwind$replace_delete_single_character
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_delete_single_character DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT replace_delete_single_character
_TEXT	SEGMENT
self$ = 80
from_c$ = 88
maxcount$ = 96
replace_delete_single_character PROC			; COMDAT

; 1627 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1628 :     char *self_s, *result_s;
; 1629 :     char *start, *next, *end;
; 1630 :     Py_ssize_t self_len, result_len;
; 1631 :     Py_ssize_t count;
; 1632 :     PyByteArrayObject *result;
; 1633 : 
; 1634 :     self_len = PyByteArray_GET_SIZE(self);

  0001c	4c 8b 71 60	 mov	 r14, QWORD PTR [rcx+96]
  00020	49 8b f0	 mov	 rsi, r8
  00023	4c 8b e9	 mov	 r13, rcx

; 1635 :     self_s = PyByteArray_AS_STRING(self);

  00026	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_PyByteArray_empty_string
  0002d	4d 85 f6	 test	 r14, r14
  00030	74 09		 je	 SHORT $LN24@replace_de
  00032	48 8b 99 80 00
	00 00		 mov	 rbx, QWORD PTR [rcx+128]
  00039	eb 03		 jmp	 SHORT $LN25@replace_de
$LN24@replace_de:
  0003b	48 8b df	 mov	 rbx, rdi
$LN25@replace_de:

; 1636 : 
; 1637 :     count = countchar(self_s, self_len, from_c, maxcount);

  0003e	44 0f be fa	 movsx	 r15d, dl
  00042	4e 8d 24 33	 lea	 r12, QWORD PTR [rbx+r14]
  00046	48 8b cb	 mov	 rcx, rbx
  00049	4d 8b c4	 mov	 r8, r12
  0004c	41 8b d7	 mov	 edx, r15d
  0004f	33 ed		 xor	 ebp, ebp
  00051	4c 2b c3	 sub	 r8, rbx
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0005a	48 85 c0	 test	 rax, rax
  0005d	74 23		 je	 SHORT $LN44@replace_de
  0005f	90		 npad	 1
$LL30@replace_de:
  00060	48 ff c5	 inc	 rbp
  00063	48 3b ee	 cmp	 rbp, rsi
  00066	7d 1a		 jge	 SHORT $LN44@replace_de
  00068	48 ff c0	 inc	 rax
  0006b	4d 8b c4	 mov	 r8, r12
  0006e	41 8b d7	 mov	 edx, r15d
  00071	4c 2b c0	 sub	 r8, rax
  00074	48 8b c8	 mov	 rcx, rax
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0007d	48 85 c0	 test	 rax, rax
  00080	75 de		 jne	 SHORT $LL30@replace_de
$LN44@replace_de:

; 1638 :     if (count == 0) {

  00082	48 85 ed	 test	 rbp, rbp
  00085	75 0d		 jne	 SHORT $LN21@replace_de

; 1639 :         return return_self(self);

  00087	49 8b cd	 mov	 rcx, r13
  0008a	e8 00 00 00 00	 call	 return_self
  0008f	e9 ce 00 00 00	 jmp	 $LN22@replace_de
$LN21@replace_de:

; 1640 :     }
; 1641 : 
; 1642 :     result_len = self_len - count;  /* from_len == 1 */

  00094	4c 2b f5	 sub	 r14, rbp

; 1643 :     assert(result_len>=0);
; 1644 : 
; 1645 :     if ( (result = (PyByteArrayObject *)
; 1646 :                     PyByteArray_FromStringAndSize(NULL, result_len)) == NULL)

  00097	33 c9		 xor	 ecx, ecx
  00099	49 8b d6	 mov	 rdx, r14
  0009c	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000a1	4c 8b f0	 mov	 r14, rax
  000a4	48 85 c0	 test	 rax, rax
  000a7	0f 84 b5 00 00
	00		 je	 $LN22@replace_de
$LN20@replace_de:

; 1647 :         return NULL;
; 1648 :     result_s = PyByteArray_AS_STRING(result);

  000ad	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000b2	74 07		 je	 SHORT $LN26@replace_de
  000b4	48 8b b8 80 00
	00 00		 mov	 rdi, QWORD PTR [rax+128]
$LN26@replace_de:

; 1649 : 
; 1650 :     start = self_s;
; 1651 :     end = self_s + self_len;
; 1652 :     while (count-- > 0) {

  000bb	48 85 ed	 test	 rbp, rbp
  000be	7e 6b		 jle	 SHORT $LN8@replace_de
$LL19@replace_de:

; 1653 :         next = findchar(start, end-start, from_c);

  000c0	4d 8b c4	 mov	 r8, r12
  000c3	41 8b d7	 mov	 edx, r15d
  000c6	48 8b cb	 mov	 rcx, rbx
  000c9	4c 2b c3	 sub	 r8, rbx
  000cc	48 ff cd	 dec	 rbp
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000d5	4c 8b e8	 mov	 r13, rax

; 1654 :         if (next == NULL)

  000d8	48 85 c0	 test	 rax, rax
  000db	74 4e		 je	 SHORT $LN8@replace_de

; 1655 :             break;
; 1656 :         Py_MEMCPY(result_s, start, next-start);

  000dd	48 8b f0	 mov	 rsi, rax
  000e0	48 2b f3	 sub	 rsi, rbx
  000e3	48 83 fe 10	 cmp	 rsi, 16
  000e7	72 10		 jb	 SHORT $LN13@replace_de
  000e9	4c 8b c6	 mov	 r8, rsi
  000ec	48 8b d3	 mov	 rdx, rbx
  000ef	48 8b cf	 mov	 rcx, rdi
  000f2	e8 00 00 00 00	 call	 memcpy
  000f7	eb 26		 jmp	 SHORT $LN15@replace_de
$LN13@replace_de:
  000f9	48 85 f6	 test	 rsi, rsi
  000fc	74 21		 je	 SHORT $LN15@replace_de
  000fe	48 8b cf	 mov	 rcx, rdi
  00101	48 2b df	 sub	 rbx, rdi
  00104	48 8b d6	 mov	 rdx, rsi
  00107	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL11@replace_de:
  00110	0f b6 04 0b	 movzx	 eax, BYTE PTR [rbx+rcx]
  00114	48 ff c1	 inc	 rcx
  00117	48 ff ca	 dec	 rdx
  0011a	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0011d	75 f1		 jne	 SHORT $LL11@replace_de
$LN15@replace_de:

; 1657 :         result_s += (next-start);

  0011f	48 03 fe	 add	 rdi, rsi

; 1658 :         start = next+1;

  00122	49 8d 5d 01	 lea	 rbx, QWORD PTR [r13+1]
  00126	48 85 ed	 test	 rbp, rbp
  00129	7f 95		 jg	 SHORT $LL19@replace_de
$LN8@replace_de:

; 1659 :     }
; 1660 :     Py_MEMCPY(result_s, start, end-start);

  0012b	4c 2b e3	 sub	 r12, rbx
  0012e	49 83 fc 10	 cmp	 r12, 16
  00132	72 10		 jb	 SHORT $LN5@replace_de
  00134	4d 8b c4	 mov	 r8, r12
  00137	48 8b d3	 mov	 rdx, rbx
  0013a	48 8b cf	 mov	 rcx, rdi
  0013d	e8 00 00 00 00	 call	 memcpy
  00142	eb 1b		 jmp	 SHORT $LN7@replace_de
$LN5@replace_de:
  00144	4d 85 e4	 test	 r12, r12
  00147	74 16		 je	 SHORT $LN7@replace_de
  00149	48 2b df	 sub	 rbx, rdi
  0014c	0f 1f 40 00	 npad	 4
$LL3@replace_de:
  00150	0f b6 04 1f	 movzx	 eax, BYTE PTR [rdi+rbx]
  00154	48 ff c7	 inc	 rdi
  00157	49 ff cc	 dec	 r12
  0015a	88 47 ff	 mov	 BYTE PTR [rdi-1], al
  0015d	75 f1		 jne	 SHORT $LL3@replace_de
$LN7@replace_de:

; 1661 : 
; 1662 :     return result;

  0015f	49 8b c6	 mov	 rax, r14
$LN22@replace_de:

; 1663 : }

  00162	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00167	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  0016c	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00171	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00175	41 5f		 pop	 r15
  00177	41 5e		 pop	 r14
  00179	41 5d		 pop	 r13
  0017b	41 5c		 pop	 r12
  0017d	5f		 pop	 rdi
  0017e	c3		 ret	 0
replace_delete_single_character ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\count.h
pdata	SEGMENT
$pdata$replace_delete_substring DD imagerel replace_delete_substring
	DD	imagerel replace_delete_substring+138
	DD	imagerel $unwind$replace_delete_substring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$replace_delete_substring DD imagerel replace_delete_substring+138
	DD	imagerel replace_delete_substring+186
	DD	imagerel $chain$0$replace_delete_substring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$replace_delete_substring DD imagerel replace_delete_substring+186
	DD	imagerel replace_delete_substring+217
	DD	imagerel $chain$2$replace_delete_substring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$replace_delete_substring DD imagerel replace_delete_substring+217
	DD	imagerel replace_delete_substring+361
	DD	imagerel $chain$3$replace_delete_substring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$replace_delete_substring DD imagerel replace_delete_substring+361
	DD	imagerel replace_delete_substring+423
	DD	imagerel $chain$4$replace_delete_substring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$replace_delete_substring DD imagerel replace_delete_substring+423
	DD	imagerel replace_delete_substring+443
	DD	imagerel $chain$5$replace_delete_substring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$replace_delete_substring DD 021H
	DD	imagerel replace_delete_substring
	DD	imagerel replace_delete_substring+138
	DD	imagerel $unwind$replace_delete_substring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$replace_delete_substring DD 021H
	DD	imagerel replace_delete_substring+186
	DD	imagerel replace_delete_substring+217
	DD	imagerel $chain$2$replace_delete_substring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$replace_delete_substring DD 020821H
	DD	010d408H
	DD	imagerel replace_delete_substring+186
	DD	imagerel replace_delete_substring+217
	DD	imagerel $chain$2$replace_delete_substring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$replace_delete_substring DD 020021H
	DD	06f400H
	DD	imagerel replace_delete_substring
	DD	imagerel replace_delete_substring+138
	DD	imagerel $unwind$replace_delete_substring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$replace_delete_substring DD 020521H
	DD	06f405H
	DD	imagerel replace_delete_substring
	DD	imagerel replace_delete_substring+138
	DD	imagerel $unwind$replace_delete_substring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_delete_substring DD 071101H
	DD	0e00d6211H
	DD	07009c00bH
	DD	050076008H
	DD	03006H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
xdata	ENDS
;	COMDAT replace_delete_substring
_TEXT	SEGMENT
result$1$ = 112
self$ = 112
from_s$ = 120
from_len$ = 128
maxcount$ = 136
replace_delete_substring PROC				; COMDAT

; 1671 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 56		 push	 r14
  0000d	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1672 :     char *self_s, *result_s;
; 1673 :     char *start, *next, *end;
; 1674 :     Py_ssize_t self_len, result_len;
; 1675 :     Py_ssize_t count, offset;
; 1676 :     PyByteArrayObject *result;
; 1677 : 
; 1678 :     self_len = PyByteArray_GET_SIZE(self);

  00011	48 8b 71 60	 mov	 rsi, QWORD PTR [rcx+96]
  00015	4d 8b e1	 mov	 r12, r9
  00018	4d 8b f0	 mov	 r14, r8
  0001b	48 8b e9	 mov	 rbp, rcx

; 1679 :     self_s = PyByteArray_AS_STRING(self);

  0001e	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_PyByteArray_empty_string
  00025	48 85 f6	 test	 rsi, rsi
  00028	74 09		 je	 SHORT $LN24@replace_de@2
  0002a	48 8b b9 80 00
	00 00		 mov	 rdi, QWORD PTR [rcx+128]
  00031	eb 03		 jmp	 SHORT $LN25@replace_de@2
$LN24@replace_de@2:
  00033	48 8b fb	 mov	 rdi, rbx
$LN25@replace_de@2:

; 1680 : 
; 1681 :     count = stringlib_count(self_s, self_len,
; 1682 :                             from_s, from_len,
; 1683 :                             maxcount);

  00036	48 85 f6	 test	 rsi, rsi
  00039	0f 88 68 01 00
	00		 js	 $LN43@replace_de@2
  0003f	4d 85 c0	 test	 r8, r8
  00042	75 0b		 jne	 SHORT $LN29@replace_de@2
  00044	49 3b f1	 cmp	 rsi, r9
  00047	7d 30		 jge	 SHORT $LN31@replace_de@2
  00049	4c 8d 66 01	 lea	 r12, QWORD PTR [rsi+1]
  0004d	eb 2a		 jmp	 SHORT $LN31@replace_de@2
$LN29@replace_de@2:
  0004f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00057	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0005c	4d 8b c8	 mov	 r9, r8
  0005f	4c 8b c2	 mov	 r8, rdx
  00062	48 8b cf	 mov	 rcx, rdi
  00065	48 8b d6	 mov	 rdx, rsi
  00068	e8 00 00 00 00	 call	 fastsearch
  0006d	4c 8b e0	 mov	 r12, rax
  00070	48 85 c0	 test	 rax, rax
  00073	0f 88 2e 01 00
	00		 js	 $LN43@replace_de@2
$LN31@replace_de@2:

; 1684 : 
; 1685 :     if (count == 0) {

  00079	4d 85 e4	 test	 r12, r12
  0007c	0f 84 25 01 00
	00		 je	 $LN43@replace_de@2

; 1688 :     }
; 1689 : 
; 1690 :     result_len = self_len - (count * from_len);

  00082	49 8b c4	 mov	 rax, r12
  00085	48 8b d6	 mov	 rdx, rsi

; 1691 :     assert (result_len>=0);
; 1692 : 
; 1693 :     if ( (result = (PyByteArrayObject *)
; 1694 :         PyByteArray_FromStringAndSize(NULL, result_len)) == NULL )

  00088	33 c9		 xor	 ecx, ecx
  0008a	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  0008f	49 0f af c6	 imul	 rax, r14
  00093	48 2b d0	 sub	 rdx, rax
  00096	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0009b	4c 8b f8	 mov	 r15, rax
  0009e	48 89 44 24 70	 mov	 QWORD PTR result$1$[rsp], rax
  000a3	48 85 c0	 test	 rax, rax
  000a6	75 12		 jne	 SHORT $LN20@replace_de@2
$LN45@replace_de@2:
  000a8	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]

; 1716 : }

  000ad	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b1	41 5e		 pop	 r14
  000b3	41 5c		 pop	 r12
  000b5	5f		 pop	 rdi
  000b6	5e		 pop	 rsi
  000b7	5d		 pop	 rbp
  000b8	5b		 pop	 rbx
  000b9	c3		 ret	 0
$LN20@replace_de@2:

; 1695 :             return NULL;
; 1696 : 
; 1697 :     result_s = PyByteArray_AS_STRING(result);

  000ba	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000bf	74 07		 je	 SHORT $LN26@replace_de@2
  000c1	48 8b 98 80 00
	00 00		 mov	 rbx, QWORD PTR [rax+128]
$LN26@replace_de@2:

; 1698 : 
; 1699 :     start = self_s;
; 1700 :     end = self_s + self_len;

  000c8	48 03 f7	 add	 rsi, rdi

; 1701 :     while (count-- > 0) {

  000cb	4d 85 e4	 test	 r12, r12
  000ce	0f 8e 95 00 00
	00		 jle	 $LN8@replace_de@2
  000d4	4c 8b 7c 24 78	 mov	 r15, QWORD PTR from_s$[rsp]
  000d9	4c 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r13
$LL19@replace_de@2:

; 1702 :         offset = stringlib_find(start, end-start,
; 1703 :                                 from_s, from_len,
; 1704 :                                 0);

  000e1	48 8b d6	 mov	 rdx, rsi
  000e4	4d 8b ce	 mov	 r9, r14
  000e7	4d 8b c7	 mov	 r8, r15
  000ea	48 8b cf	 mov	 rcx, rdi
  000ed	48 2b d7	 sub	 rdx, rdi
  000f0	49 ff cc	 dec	 r12
  000f3	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000fc	e8 00 00 00 00	 call	 stringlib_find

; 1705 :         if (offset == -1)

  00101	48 83 f8 ff	 cmp	 rax, -1
  00105	74 55		 je	 SHORT $LN44@replace_de@2

; 1706 :             break;
; 1707 :         next = start + offset;

  00107	4c 8d 2c 38	 lea	 r13, QWORD PTR [rax+rdi]

; 1708 : 
; 1709 :         Py_MEMCPY(result_s, start, next-start);

  0010b	49 8b ed	 mov	 rbp, r13
  0010e	48 2b ef	 sub	 rbp, rdi
  00111	48 83 fd 10	 cmp	 rbp, 16
  00115	72 10		 jb	 SHORT $LN13@replace_de@2
  00117	4c 8b c5	 mov	 r8, rbp
  0011a	48 8b d7	 mov	 rdx, rdi
  0011d	48 8b cb	 mov	 rcx, rbx
  00120	e8 00 00 00 00	 call	 memcpy
  00125	eb 28		 jmp	 SHORT $LN15@replace_de@2
$LN13@replace_de@2:
  00127	48 85 ed	 test	 rbp, rbp
  0012a	74 23		 je	 SHORT $LN15@replace_de@2
  0012c	48 8b cb	 mov	 rcx, rbx
  0012f	48 2b fb	 sub	 rdi, rbx
  00132	48 8b d5	 mov	 rdx, rbp
  00135	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL11@replace_de@2:
  00140	0f b6 04 0f	 movzx	 eax, BYTE PTR [rdi+rcx]
  00144	48 ff c1	 inc	 rcx
  00147	48 ff ca	 dec	 rdx
  0014a	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0014d	75 f1		 jne	 SHORT $LL11@replace_de@2
$LN15@replace_de@2:

; 1710 : 
; 1711 :         result_s += (next-start);

  0014f	48 03 dd	 add	 rbx, rbp

; 1712 :         start = next+from_len;

  00152	4b 8d 7c 35 00	 lea	 rdi, QWORD PTR [r13+r14]
  00157	4d 85 e4	 test	 r12, r12
  0015a	7f 85		 jg	 SHORT $LL19@replace_de@2
$LN44@replace_de@2:
  0015c	4c 8b 7c 24 70	 mov	 r15, QWORD PTR result$1$[rsp]
  00161	4c 8b ac 24 80
	00 00 00	 mov	 r13, QWORD PTR [rsp+128]
$LN8@replace_de@2:

; 1713 :     }
; 1714 :     Py_MEMCPY(result_s, start, end-start);

  00169	48 2b f7	 sub	 rsi, rdi
  0016c	48 83 fe 10	 cmp	 rsi, 16
  00170	72 16		 jb	 SHORT $LN5@replace_de@2
  00172	4c 8b c6	 mov	 r8, rsi
  00175	48 8b d7	 mov	 rdx, rdi
  00178	48 8b cb	 mov	 rcx, rbx
  0017b	e8 00 00 00 00	 call	 memcpy

; 1715 :     return result;

  00180	49 8b c7	 mov	 rax, r15
  00183	e9 20 ff ff ff	 jmp	 $LN45@replace_de@2
$LN5@replace_de@2:

; 1713 :     }
; 1714 :     Py_MEMCPY(result_s, start, end-start);

  00188	48 85 f6	 test	 rsi, rsi
  0018b	74 12		 je	 SHORT $LN7@replace_de@2
  0018d	48 2b fb	 sub	 rdi, rbx
$LL3@replace_de@2:
  00190	0f b6 04 3b	 movzx	 eax, BYTE PTR [rbx+rdi]
  00194	48 ff c3	 inc	 rbx
  00197	48 ff ce	 dec	 rsi
  0019a	88 43 ff	 mov	 BYTE PTR [rbx-1], al
  0019d	75 f1		 jne	 SHORT $LL3@replace_de@2
$LN7@replace_de@2:

; 1715 :     return result;

  0019f	49 8b c7	 mov	 rax, r15
  001a2	e9 01 ff ff ff	 jmp	 $LN45@replace_de@2
$LN43@replace_de@2:

; 1686 :         /* no matches */
; 1687 :         return return_self(self);

  001a7	48 8b cd	 mov	 rcx, rbp

; 1716 : }

  001aa	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001ae	41 5e		 pop	 r14
  001b0	41 5c		 pop	 r12
  001b2	5f		 pop	 rdi
  001b3	5e		 pop	 rsi
  001b4	5d		 pop	 rbp
  001b5	5b		 pop	 rbx
  001b6	e9 00 00 00 00	 jmp	 return_self
replace_delete_substring ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_single_character_in_place DD imagerel replace_single_character_in_place
	DD	imagerel replace_single_character_in_place+107
	DD	imagerel $unwind$replace_single_character_in_place
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$replace_single_character_in_place DD imagerel replace_single_character_in_place+107
	DD	imagerel replace_single_character_in_place+283
	DD	imagerel $chain$0$replace_single_character_in_place
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$replace_single_character_in_place DD imagerel replace_single_character_in_place+283
	DD	imagerel replace_single_character_in_place+306
	DD	imagerel $chain$1$replace_single_character_in_place
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$replace_single_character_in_place DD 021H
	DD	imagerel replace_single_character_in_place
	DD	imagerel replace_single_character_in_place+107
	DD	imagerel $unwind$replace_single_character_in_place
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$replace_single_character_in_place DD 020521H
	DD	0be405H
	DD	imagerel replace_single_character_in_place
	DD	imagerel replace_single_character_in_place+107
	DD	imagerel $unwind$replace_single_character_in_place
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_single_character_in_place DD 0a1601H
	DD	0d5416H
	DD	0c3416H
	DD	0f0123216H
	DD	0c00ed010H
	DD	0600b700cH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT replace_single_character_in_place
_TEXT	SEGMENT
next$1$ = 80
self$ = 80
from_c$ = 88
to_c$ = 96
maxcount$ = 104
replace_single_character_in_place PROC			; COMDAT

; 1723 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 57		 push	 r15
  00012	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1724 :     char *self_s, *result_s, *start, *end, *next;
; 1725 :     Py_ssize_t self_len;
; 1726 :     PyByteArrayObject *result;
; 1727 : 
; 1728 :     /* The result string will be the same size */
; 1729 :     self_s = PyByteArray_AS_STRING(self);

  00016	48 8b 71 60	 mov	 rsi, QWORD PTR [rcx+96]
  0001a	49 8b d9	 mov	 rbx, r9
  0001d	45 0f b6 e8	 movzx	 r13d, r8b
  00021	48 8b f9	 mov	 rdi, rcx
  00024	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:_PyByteArray_empty_string
  0002b	48 85 f6	 test	 rsi, rsi
  0002e	74 09		 je	 SHORT $LN16@replace_si
  00030	4c 8b a1 80 00
	00 00		 mov	 r12, QWORD PTR [rcx+128]
  00037	eb 03		 jmp	 SHORT $LN17@replace_si
$LN16@replace_si:
  00039	4c 8b e5	 mov	 r12, rbp
$LN17@replace_si:

; 1730 :     self_len = PyByteArray_GET_SIZE(self);
; 1731 : 
; 1732 :     next = findchar(self_s, self_len, from_c);

  0003c	44 0f be fa	 movsx	 r15d, dl
  00040	4c 8b c6	 mov	 r8, rsi
  00043	49 8b cc	 mov	 rcx, r12
  00046	41 8b d7	 mov	 edx, r15d
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0004f	48 89 44 24 50	 mov	 QWORD PTR next$1$[rsp], rax

; 1733 : 
; 1734 :     if (next == NULL) {

  00054	48 85 c0	 test	 rax, rax
  00057	75 0d		 jne	 SHORT $LN13@replace_si

; 1735 :         /* No matches; return the original bytes */
; 1736 :         return return_self(self);

  00059	48 8b cf	 mov	 rcx, rdi
  0005c	e8 00 00 00 00	 call	 return_self
  00061	e9 b5 00 00 00	 jmp	 $LN14@replace_si
$LN13@replace_si:

; 1737 :     }
; 1738 : 
; 1739 :     /* Need to make a new bytes */
; 1740 :     result = (PyByteArrayObject *) PyByteArray_FromStringAndSize(NULL, self_len);

  00066	48 8b d6	 mov	 rdx, rsi
  00069	33 c9		 xor	 ecx, ecx
  0006b	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14
  00070	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00075	4c 8b f0	 mov	 r14, rax

; 1741 :     if (result == NULL)

  00078	48 85 c0	 test	 rax, rax
  0007b	0f 84 95 00 00
	00		 je	 $LN26@replace_si
$LN12@replace_si:

; 1742 :         return NULL;
; 1743 :     result_s = PyByteArray_AS_STRING(result);

  00081	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00086	74 07		 je	 SHORT $LN18@replace_si
  00088	48 8b a8 80 00
	00 00		 mov	 rbp, QWORD PTR [rax+128]
$LN18@replace_si:

; 1744 :     Py_MEMCPY(result_s, self_s, self_len);

  0008f	48 83 fe 10	 cmp	 rsi, 16
  00093	72 10		 jb	 SHORT $LN8@replace_si
  00095	4c 8b c6	 mov	 r8, rsi
  00098	49 8b d4	 mov	 rdx, r12
  0009b	48 8b cd	 mov	 rcx, rbp
  0009e	e8 00 00 00 00	 call	 memcpy
  000a3	eb 2b		 jmp	 SHORT $LN10@replace_si
$LN8@replace_si:
  000a5	48 85 f6	 test	 rsi, rsi
  000a8	74 26		 je	 SHORT $LN10@replace_si
  000aa	4d 8b c4	 mov	 r8, r12
  000ad	48 8b cd	 mov	 rcx, rbp
  000b0	48 8b d6	 mov	 rdx, rsi
  000b3	4c 2b c5	 sub	 r8, rbp
  000b6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL6@replace_si:
  000c0	41 0f b6 04 08	 movzx	 eax, BYTE PTR [r8+rcx]
  000c5	48 ff c1	 inc	 rcx
  000c8	48 ff ca	 dec	 rdx
  000cb	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  000ce	75 f0		 jne	 SHORT $LL6@replace_si
$LN10@replace_si:

; 1745 : 
; 1746 :     /* change everything in-place, starting with this one */
; 1747 :     start =  result_s + (next-self_s);

  000d0	48 8b cd	 mov	 rcx, rbp

; 1748 :     *start = to_c;
; 1749 :     start++;
; 1750 :     end = result_s + self_len;
; 1751 : 
; 1752 :     while (--maxcount > 0) {

  000d3	48 ff cb	 dec	 rbx
  000d6	48 8d 3c 2e	 lea	 rdi, QWORD PTR [rsi+rbp]
  000da	49 2b cc	 sub	 rcx, r12
  000dd	48 03 4c 24 50	 add	 rcx, QWORD PTR next$1$[rsp]
  000e2	48 ff c1	 inc	 rcx
  000e5	44 88 69 ff	 mov	 BYTE PTR [rcx-1], r13b
  000e9	48 85 db	 test	 rbx, rbx
  000ec	7e 25		 jle	 SHORT $LN25@replace_si
  000ee	66 90		 npad	 2
$LL3@replace_si:

; 1753 :         next = findchar(start, end-start, from_c);

  000f0	4c 8b c7	 mov	 r8, rdi
  000f3	41 8b d7	 mov	 edx, r15d
  000f6	4c 2b c1	 sub	 r8, rcx
  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr

; 1754 :         if (next == NULL)

  000ff	48 85 c0	 test	 rax, rax
  00102	74 0f		 je	 SHORT $LN25@replace_si

; 1755 :             break;
; 1756 :         *next = to_c;

  00104	48 ff cb	 dec	 rbx
  00107	44 88 28	 mov	 BYTE PTR [rax], r13b

; 1757 :         start = next+1;

  0010a	48 8d 48 01	 lea	 rcx, QWORD PTR [rax+1]
  0010e	48 85 db	 test	 rbx, rbx
  00111	7f dd		 jg	 SHORT $LL3@replace_si
$LN25@replace_si:

; 1758 :     }
; 1759 : 
; 1760 :     return result;

  00113	49 8b c6	 mov	 rax, r14
$LN26@replace_si:
  00116	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
$LN14@replace_si:

; 1761 : }

  0011b	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00120	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00125	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00129	41 5f		 pop	 r15
  0012b	41 5d		 pop	 r13
  0012d	41 5c		 pop	 r12
  0012f	5f		 pop	 rdi
  00130	5e		 pop	 rsi
  00131	c3		 ret	 0
replace_single_character_in_place ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_substring_in_place DD imagerel replace_substring_in_place
	DD	imagerel replace_substring_in_place+117
	DD	imagerel $unwind$replace_substring_in_place
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$replace_substring_in_place DD imagerel replace_substring_in_place+117
	DD	imagerel replace_substring_in_place+419
	DD	imagerel $chain$0$replace_substring_in_place
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$replace_substring_in_place DD imagerel replace_substring_in_place+419
	DD	imagerel replace_substring_in_place+442
	DD	imagerel $chain$1$replace_substring_in_place
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$replace_substring_in_place DD 021H
	DD	imagerel replace_substring_in_place
	DD	imagerel replace_substring_in_place+117
	DD	imagerel $unwind$replace_substring_in_place
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$replace_substring_in_place DD 020521H
	DD	0cf405H
	DD	imagerel replace_substring_in_place
	DD	imagerel replace_substring_in_place+117
	DD	imagerel $unwind$replace_substring_in_place
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_substring_in_place DD 0a1b01H
	DD	0f541bH
	DD	0e341bH
	DD	0e017521bH
	DD	0c013d015H
	DD	060107011H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT replace_substring_in_place
_TEXT	SEGMENT
self$ = 96
from_s$ = 104
from_len$ = 112
to_s$ = 120
maxcount$ = 128
replace_substring_in_place PROC				; COMDAT

; 1769 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	41 54		 push	 r12
  00013	41 55		 push	 r13
  00015	41 56		 push	 r14
  00017	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1770 :     char *result_s, *start, *end;
; 1771 :     char *self_s;
; 1772 :     Py_ssize_t self_len, offset;
; 1773 :     PyByteArrayObject *result;
; 1774 : 
; 1775 :     /* The result bytes will be the same size */
; 1776 : 
; 1777 :     self_s = PyByteArray_AS_STRING(self);

  0001b	48 8b 69 60	 mov	 rbp, QWORD PTR [rcx+96]
  0001f	4d 8b f1	 mov	 r14, r9
  00022	49 8b d8	 mov	 rbx, r8
  00025	48 8b f1	 mov	 rsi, rcx
  00028	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_PyByteArray_empty_string
  0002f	48 85 ed	 test	 rbp, rbp
  00032	74 09		 je	 SHORT $LN32@replace_su
  00034	48 8b b9 80 00
	00 00		 mov	 rdi, QWORD PTR [rcx+128]
  0003b	eb 03		 jmp	 SHORT $LN33@replace_su
$LN32@replace_su:
  0003d	49 8b fc	 mov	 rdi, r12
$LN33@replace_su:

; 1778 :     self_len = PyByteArray_GET_SIZE(self);
; 1779 : 
; 1780 :     offset = stringlib_find(self_s, self_len,
; 1781 :                             from_s, from_len,
; 1782 :                             0);

  00040	4c 8b c2	 mov	 r8, rdx
  00043	4c 8b cb	 mov	 r9, rbx
  00046	48 8b cf	 mov	 rcx, rdi
  00049	48 8b d5	 mov	 rdx, rbp
  0004c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00055	e8 00 00 00 00	 call	 stringlib_find
  0005a	4c 8b e8	 mov	 r13, rax

; 1783 :     if (offset == -1) {

  0005d	48 83 f8 ff	 cmp	 rax, -1
  00061	75 0d		 jne	 SHORT $LN29@replace_su

; 1784 :         /* No matches; return the original bytes */
; 1785 :         return return_self(self);

  00063	48 8b ce	 mov	 rcx, rsi
  00066	e8 00 00 00 00	 call	 return_self
  0006b	e9 33 01 00 00	 jmp	 $LN30@replace_su
$LN29@replace_su:

; 1786 :     }
; 1787 : 
; 1788 :     /* Need to make a new bytes */
; 1789 :     result = (PyByteArrayObject *) PyByteArray_FromStringAndSize(NULL, self_len);

  00070	48 8b d5	 mov	 rdx, rbp
  00073	33 c9		 xor	 ecx, ecx
  00075	4c 89 7c 24 60	 mov	 QWORD PTR [rsp+96], r15
  0007a	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0007f	4c 8b f8	 mov	 r15, rax

; 1790 :     if (result == NULL)

  00082	48 85 c0	 test	 rax, rax
  00085	0f 84 13 01 00
	00		 je	 $LN46@replace_su
$LN28@replace_su:

; 1791 :         return NULL;
; 1792 :     result_s = PyByteArray_AS_STRING(result);

  0008b	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00090	74 07		 je	 SHORT $LN34@replace_su
  00092	4c 8b a0 80 00
	00 00		 mov	 r12, QWORD PTR [rax+128]
$LN34@replace_su:

; 1793 :     Py_MEMCPY(result_s, self_s, self_len);

  00099	48 83 fd 10	 cmp	 rbp, 16
  0009d	72 10		 jb	 SHORT $LN24@replace_su
  0009f	4c 8b c5	 mov	 r8, rbp
  000a2	48 8b d7	 mov	 rdx, rdi
  000a5	49 8b cc	 mov	 rcx, r12
  000a8	e8 00 00 00 00	 call	 memcpy
  000ad	eb 20		 jmp	 SHORT $LN26@replace_su
$LN24@replace_su:
  000af	48 85 ed	 test	 rbp, rbp
  000b2	74 1b		 je	 SHORT $LN26@replace_su
  000b4	49 8b cc	 mov	 rcx, r12
  000b7	49 2b fc	 sub	 rdi, r12
  000ba	48 8b d5	 mov	 rdx, rbp
  000bd	0f 1f 00	 npad	 3
$LL22@replace_su:
  000c0	0f b6 04 0f	 movzx	 eax, BYTE PTR [rdi+rcx]
  000c4	48 ff c1	 inc	 rcx
  000c7	48 ff ca	 dec	 rdx
  000ca	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  000cd	75 f1		 jne	 SHORT $LL22@replace_su
$LN26@replace_su:

; 1794 : 
; 1795 :     /* change everything in-place, starting with this one */
; 1796 :     start =  result_s + offset;

  000cf	4b 8d 3c 2c	 lea	 rdi, QWORD PTR [r12+r13]

; 1797 :     Py_MEMCPY(start, to_s, from_len);

  000d3	48 83 fb 10	 cmp	 rbx, 16
  000d7	72 10		 jb	 SHORT $LN16@replace_su
  000d9	4c 8b c3	 mov	 r8, rbx
  000dc	49 8b d6	 mov	 rdx, r14
  000df	48 8b cf	 mov	 rcx, rdi
  000e2	e8 00 00 00 00	 call	 memcpy
  000e7	eb 27		 jmp	 SHORT $LN18@replace_su
$LN16@replace_su:
  000e9	48 85 db	 test	 rbx, rbx
  000ec	74 22		 je	 SHORT $LN18@replace_su
  000ee	4d 8b c6	 mov	 r8, r14
  000f1	48 8b cf	 mov	 rcx, rdi
  000f4	48 8b d3	 mov	 rdx, rbx
  000f7	4c 2b c7	 sub	 r8, rdi
  000fa	66 0f 1f 44 00
	00		 npad	 6
$LL14@replace_su:
  00100	41 0f b6 04 08	 movzx	 eax, BYTE PTR [r8+rcx]
  00105	48 ff c1	 inc	 rcx
  00108	48 ff ca	 dec	 rdx
  0010b	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0010e	75 f0		 jne	 SHORT $LL14@replace_su
$LN18@replace_su:

; 1798 :     start += from_len;
; 1799 :     end = result_s + self_len;
; 1800 : 
; 1801 :     while ( --maxcount > 0) {

  00110	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR maxcount$[rsp]
  00118	48 03 fb	 add	 rdi, rbx
  0011b	49 03 ec	 add	 rbp, r12
  0011e	48 ff ce	 dec	 rsi
  00121	48 85 f6	 test	 rsi, rsi
  00124	7e 75		 jle	 SHORT $LN45@replace_su
  00126	4c 8b 64 24 68	 mov	 r12, QWORD PTR from_s$[rsp]
  0012b	45 33 ed	 xor	 r13d, r13d
  0012e	66 90		 npad	 2
$LL11@replace_su:

; 1802 :         offset = stringlib_find(start, end-start,
; 1803 :                                 from_s, from_len,
; 1804 :                                 0);

  00130	48 8b d5	 mov	 rdx, rbp
  00133	4c 8b cb	 mov	 r9, rbx
  00136	4d 8b c4	 mov	 r8, r12
  00139	48 8b cf	 mov	 rcx, rdi
  0013c	48 2b d7	 sub	 rdx, rdi
  0013f	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00144	e8 00 00 00 00	 call	 stringlib_find

; 1805 :         if (offset==-1)

  00149	48 83 f8 ff	 cmp	 rax, -1
  0014d	74 4c		 je	 SHORT $LN45@replace_su

; 1806 :             break;
; 1807 :         Py_MEMCPY(start+offset, to_s, from_len);

  0014f	48 03 f8	 add	 rdi, rax
  00152	48 83 fb 10	 cmp	 rbx, 16
  00156	72 10		 jb	 SHORT $LN5@replace_su
  00158	4c 8b c3	 mov	 r8, rbx
  0015b	49 8b d6	 mov	 rdx, r14
  0015e	48 8b cf	 mov	 rcx, rdi
  00161	e8 00 00 00 00	 call	 memcpy
  00166	eb 28		 jmp	 SHORT $LN7@replace_su
$LN5@replace_su:
  00168	48 85 db	 test	 rbx, rbx
  0016b	74 23		 je	 SHORT $LN7@replace_su
  0016d	4d 8b c6	 mov	 r8, r14
  00170	48 8b cf	 mov	 rcx, rdi
  00173	48 8b d3	 mov	 rdx, rbx
  00176	4c 2b c7	 sub	 r8, rdi
  00179	0f 1f 80 00 00
	00 00		 npad	 7
$LL3@replace_su:
  00180	41 0f b6 04 08	 movzx	 eax, BYTE PTR [r8+rcx]
  00185	48 ff c1	 inc	 rcx
  00188	48 ff ca	 dec	 rdx
  0018b	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0018e	75 f0		 jne	 SHORT $LL3@replace_su
$LN7@replace_su:

; 1798 :     start += from_len;
; 1799 :     end = result_s + self_len;
; 1800 : 
; 1801 :     while ( --maxcount > 0) {

  00190	48 ff ce	 dec	 rsi

; 1808 :         start += offset+from_len;

  00193	48 03 fb	 add	 rdi, rbx
  00196	48 85 f6	 test	 rsi, rsi
  00199	7f 95		 jg	 SHORT $LL11@replace_su
$LN45@replace_su:

; 1809 :     }
; 1810 : 
; 1811 :     return result;

  0019b	49 8b c7	 mov	 rax, r15
$LN46@replace_su:
  0019e	4c 8b 7c 24 60	 mov	 r15, QWORD PTR [rsp+96]
$LN30@replace_su:

; 1812 : }

  001a3	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  001a8	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  001ad	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b1	41 5e		 pop	 r14
  001b3	41 5d		 pop	 r13
  001b5	41 5c		 pop	 r12
  001b7	5f		 pop	 rdi
  001b8	5e		 pop	 rsi
  001b9	c3		 ret	 0
replace_substring_in_place ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@JCBPECJD@replace?5bytes?5is?5too?5long?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace_single_character DD imagerel replace_single_character
	DD	imagerel replace_single_character+659
	DD	imagerel $unwind$replace_single_character
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_single_character DD 091a01H
	DD	0f016421aH
	DD	0d012e014H
	DD	0700ec010H
	DD	0500c600dH
	DD	0300bH
xdata	ENDS
;	COMDAT ??_C@_0BK@JCBPECJD@replace?5bytes?5is?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BK@JCBPECJD@replace?5bytes?5is?5too?5long?$AA@ DB 'replace bytes i'
	DB	's too long', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT replace_single_character
_TEXT	SEGMENT
result$1$ = 112
self$ = 112
tv641 = 120
from_c$ = 120
to_s$ = 128
to_len$ = 136
maxcount$ = 144
replace_single_character PROC				; COMDAT

; 1820 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	41 54		 push	 r12
  00010	41 55		 push	 r13
  00012	41 56		 push	 r14
  00014	41 57		 push	 r15
  00016	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1821 :     char *self_s, *result_s;
; 1822 :     char *start, *next, *end;
; 1823 :     Py_ssize_t self_len, result_len;
; 1824 :     Py_ssize_t count;
; 1825 :     PyByteArrayObject *result;
; 1826 : 
; 1827 :     self_s = PyByteArray_AS_STRING(self);

  0001a	4c 8b 69 60	 mov	 r13, QWORD PTR [rcx+96]
  0001e	49 8b f1	 mov	 rsi, r9
  00021	49 8b e8	 mov	 rbp, r8
  00024	4c 8b e1	 mov	 r12, rcx
  00027	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_PyByteArray_empty_string
  0002e	4d 85 ed	 test	 r13, r13
  00031	74 09		 je	 SHORT $LN43@replace_si@2
  00033	48 8b b9 80 00
	00 00		 mov	 rdi, QWORD PTR [rcx+128]
  0003a	eb 03		 jmp	 SHORT $LN44@replace_si@2
$LN43@replace_si@2:
  0003c	48 8b fb	 mov	 rdi, rbx
$LN44@replace_si@2:

; 1828 :     self_len = PyByteArray_GET_SIZE(self);
; 1829 : 
; 1830 :     count = countchar(self_s, self_len, from_c, maxcount);

  0003f	0f be c2	 movsx	 eax, dl
  00042	4d 8d 74 3d 00	 lea	 r14, QWORD PTR [r13+rdi]
  00047	48 8b cf	 mov	 rcx, rdi
  0004a	4d 8b c6	 mov	 r8, r14
  0004d	8b d0		 mov	 edx, eax
  0004f	45 33 ff	 xor	 r15d, r15d
  00052	4c 2b c7	 sub	 r8, rdi
  00055	89 44 24 78	 mov	 DWORD PTR tv641[rsp], eax
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0005f	48 85 c0	 test	 rax, rax
  00062	74 3d		 je	 SHORT $LN58@replace_si@2
  00064	48 8b ac 24 90
	00 00 00	 mov	 rbp, QWORD PTR maxcount$[rsp]
  0006c	8b 74 24 78	 mov	 esi, DWORD PTR tv641[rsp]
$LL49@replace_si@2:
  00070	49 ff c7	 inc	 r15
  00073	4c 3b fd	 cmp	 r15, rbp
  00076	7d 19		 jge	 SHORT $LN66@replace_si@2
  00078	48 ff c0	 inc	 rax
  0007b	4d 8b c6	 mov	 r8, r14
  0007e	8b d6		 mov	 edx, esi
  00080	4c 2b c0	 sub	 r8, rax
  00083	48 8b c8	 mov	 rcx, rax
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0008c	48 85 c0	 test	 rax, rax
  0008f	75 df		 jne	 SHORT $LL49@replace_si@2
$LN66@replace_si@2:
  00091	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR to_len$[rsp]
  00099	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR to_s$[rsp]
$LN58@replace_si@2:

; 1831 :     if (count == 0) {

  000a1	4d 85 ff	 test	 r15, r15
  000a4	75 0d		 jne	 SHORT $LN40@replace_si@2

; 1832 :         /* no matches, return unchanged */
; 1833 :         return return_self(self);

  000a6	49 8b cc	 mov	 rcx, r12
  000a9	e8 00 00 00 00	 call	 return_self
  000ae	e9 cf 01 00 00	 jmp	 $LN41@replace_si@2
$LN40@replace_si@2:

; 1834 :     }
; 1835 : 
; 1836 :     /* use the difference between current and new, hence the "-1" */
; 1837 :     /*   result_len = self_len + count * (to_len-1)  */
; 1838 :     assert(count > 0);
; 1839 :     if (to_len - 1 > (PY_SSIZE_T_MAX - self_len) / count) {

  000b3	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000bd	48 8d 4e ff	 lea	 rcx, QWORD PTR [rsi-1]
  000c1	49 2b c5	 sub	 rax, r13
  000c4	48 99		 cdq
  000c6	49 f7 ff	 idiv	 r15
  000c9	48 3b c8	 cmp	 rcx, rax
  000cc	7e 1a		 jle	 SHORT $LN39@replace_si@2

; 1840 :         PyErr_SetString(PyExc_OverflowError, "replace bytes is too long");

  000ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@JCBPECJD@replace?5bytes?5is?5too?5long?$AA@
  000dc	e8 00 00 00 00	 call	 PyErr_SetString
$LN68@replace_si@2:

; 1841 :         return NULL;

  000e1	33 c0		 xor	 eax, eax
  000e3	e9 9a 01 00 00	 jmp	 $LN41@replace_si@2
$LN39@replace_si@2:

; 1842 :     }
; 1843 :     result_len = self_len + count * (to_len - 1);

  000e8	49 0f af cf	 imul	 rcx, r15
  000ec	49 8d 54 0d 00	 lea	 rdx, QWORD PTR [r13+rcx]

; 1844 : 
; 1845 :     if ( (result = (PyByteArrayObject *)
; 1846 :           PyByteArray_FromStringAndSize(NULL, result_len)) == NULL)

  000f1	33 c9		 xor	 ecx, ecx
  000f3	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000f8	4c 8b e8	 mov	 r13, rax
  000fb	48 89 44 24 70	 mov	 QWORD PTR result$1$[rsp], rax
  00100	48 85 c0	 test	 rax, rax

; 1847 :             return NULL;

  00103	74 dc		 je	 SHORT $LN68@replace_si@2

; 1848 :     result_s = PyByteArray_AS_STRING(result);

  00105	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0010a	74 07		 je	 SHORT $LN45@replace_si@2
  0010c	48 8b 98 80 00
	00 00		 mov	 rbx, QWORD PTR [rax+128]
$LN45@replace_si@2:

; 1849 : 
; 1850 :     start = self_s;
; 1851 :     end = self_s + self_len;
; 1852 :     while (count-- > 0) {

  00113	4d 85 ff	 test	 r15, r15
  00116	0f 8e 32 01 00
	00		 jle	 $LN8@replace_si@2
  0011c	44 8b 6c 24 78	 mov	 r13d, DWORD PTR tv641[rsp]
$LL37@replace_si@2:

; 1853 :         next = findchar(start, end-start, from_c);

  00121	4d 8b c6	 mov	 r8, r14
  00124	41 8b d5	 mov	 edx, r13d
  00127	48 8b cf	 mov	 rcx, rdi
  0012a	4c 2b c7	 sub	 r8, rdi
  0012d	49 ff cf	 dec	 r15
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00136	4c 8b e0	 mov	 r12, rax

; 1854 :         if (next == NULL)

  00139	48 85 c0	 test	 rax, rax
  0013c	0f 84 07 01 00
	00		 je	 $LN67@replace_si@2

; 1855 :             break;
; 1856 : 
; 1857 :         if (next == start) {

  00142	48 3b c7	 cmp	 rax, rdi
  00145	75 54		 jne	 SHORT $LN24@replace_si@2

; 1858 :             /* replace with the 'to' */
; 1859 :             Py_MEMCPY(result_s, to_s, to_len);

  00147	48 83 fe 10	 cmp	 rsi, 16
  0014b	72 19		 jb	 SHORT $LN30@replace_si@2
  0014d	4c 8b c6	 mov	 r8, rsi
  00150	48 8b d5	 mov	 rdx, rbp
  00153	48 8b cb	 mov	 rcx, rbx
  00156	e8 00 00 00 00	 call	 memcpy

; 1860 :             result_s += to_len;

  0015b	48 03 de	 add	 rbx, rsi

; 1861 :             start += 1;

  0015e	48 ff c7	 inc	 rdi

; 1862 :         } else {

  00161	e9 d2 00 00 00	 jmp	 $LN25@replace_si@2
$LN30@replace_si@2:

; 1858 :             /* replace with the 'to' */
; 1859 :             Py_MEMCPY(result_s, to_s, to_len);

  00166	48 85 f6	 test	 rsi, rsi
  00169	74 25		 je	 SHORT $LN32@replace_si@2
  0016b	4c 8b c5	 mov	 r8, rbp
  0016e	48 8b cb	 mov	 rcx, rbx
  00171	48 8b d6	 mov	 rdx, rsi
  00174	4c 2b c3	 sub	 r8, rbx
  00177	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL28@replace_si@2:
  00180	41 0f b6 04 08	 movzx	 eax, BYTE PTR [r8+rcx]
  00185	48 ff c1	 inc	 rcx
  00188	48 ff ca	 dec	 rdx
  0018b	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0018e	75 f0		 jne	 SHORT $LL28@replace_si@2
$LN32@replace_si@2:

; 1860 :             result_s += to_len;

  00190	48 03 de	 add	 rbx, rsi

; 1861 :             start += 1;

  00193	48 ff c7	 inc	 rdi

; 1862 :         } else {

  00196	e9 9d 00 00 00	 jmp	 $LN25@replace_si@2
$LN24@replace_si@2:

; 1863 :             /* copy the unchanged old then the 'to' */
; 1864 :             Py_MEMCPY(result_s, start, next-start);

  0019b	48 8b e8	 mov	 rbp, rax
  0019e	48 2b ef	 sub	 rbp, rdi
  001a1	48 83 fd 10	 cmp	 rbp, 16
  001a5	72 10		 jb	 SHORT $LN21@replace_si@2
  001a7	4c 8b c5	 mov	 r8, rbp
  001aa	48 8b d7	 mov	 rdx, rdi
  001ad	48 8b cb	 mov	 rcx, rbx
  001b0	e8 00 00 00 00	 call	 memcpy
  001b5	eb 28		 jmp	 SHORT $LN23@replace_si@2
$LN21@replace_si@2:
  001b7	48 85 ed	 test	 rbp, rbp
  001ba	74 23		 je	 SHORT $LN23@replace_si@2
  001bc	48 8b cb	 mov	 rcx, rbx
  001bf	48 2b fb	 sub	 rdi, rbx
  001c2	48 8b d5	 mov	 rdx, rbp
  001c5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL19@replace_si@2:
  001d0	0f b6 04 0f	 movzx	 eax, BYTE PTR [rdi+rcx]
  001d4	48 ff c1	 inc	 rcx
  001d7	48 ff ca	 dec	 rdx
  001da	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  001dd	75 f1		 jne	 SHORT $LL19@replace_si@2
$LN23@replace_si@2:

; 1865 :             result_s += (next-start);

  001df	48 03 dd	 add	 rbx, rbp

; 1866 :             Py_MEMCPY(result_s, to_s, to_len);

  001e2	48 83 fe 10	 cmp	 rsi, 16
  001e6	72 15		 jb	 SHORT $LN13@replace_si@2
  001e8	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR to_s$[rsp]
  001f0	4c 8b c6	 mov	 r8, rsi
  001f3	48 8b cb	 mov	 rcx, rbx
  001f6	e8 00 00 00 00	 call	 memcpy
  001fb	eb 33		 jmp	 SHORT $LN15@replace_si@2
$LN13@replace_si@2:
  001fd	48 85 f6	 test	 rsi, rsi
  00200	74 2e		 je	 SHORT $LN15@replace_si@2
  00202	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR to_s$[rsp]
  0020a	48 8b cb	 mov	 rcx, rbx
  0020d	48 8b d6	 mov	 rdx, rsi
  00210	4c 2b c3	 sub	 r8, rbx
  00213	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL11@replace_si@2:
  00220	41 0f b6 04 08	 movzx	 eax, BYTE PTR [r8+rcx]
  00225	48 ff c1	 inc	 rcx
  00228	48 ff ca	 dec	 rdx
  0022b	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0022e	75 f0		 jne	 SHORT $LL11@replace_si@2
$LN15@replace_si@2:

; 1867 :             result_s += to_len;

  00230	48 03 de	 add	 rbx, rsi

; 1868 :             start = next+1;

  00233	49 8d 7c 24 01	 lea	 rdi, QWORD PTR [r12+1]
$LN25@replace_si@2:

; 1849 : 
; 1850 :     start = self_s;
; 1851 :     end = self_s + self_len;
; 1852 :     while (count-- > 0) {

  00238	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR to_s$[rsp]
  00240	4d 85 ff	 test	 r15, r15
  00243	0f 8f d8 fe ff
	ff		 jg	 $LL37@replace_si@2
$LN67@replace_si@2:
  00249	4c 8b 6c 24 70	 mov	 r13, QWORD PTR result$1$[rsp]
$LN8@replace_si@2:

; 1869 :         }
; 1870 :     }
; 1871 :     /* Copy the remainder of the remaining bytes */
; 1872 :     Py_MEMCPY(result_s, start, end-start);

  0024e	4c 2b f7	 sub	 r14, rdi
  00251	49 83 fe 10	 cmp	 r14, 16
  00255	72 10		 jb	 SHORT $LN5@replace_si@2
  00257	4d 8b c6	 mov	 r8, r14
  0025a	48 8b d7	 mov	 rdx, rdi
  0025d	48 8b cb	 mov	 rcx, rbx
  00260	e8 00 00 00 00	 call	 memcpy
  00265	eb 18		 jmp	 SHORT $LN7@replace_si@2
$LN5@replace_si@2:
  00267	4d 85 f6	 test	 r14, r14
  0026a	74 13		 je	 SHORT $LN7@replace_si@2
  0026c	48 2b fb	 sub	 rdi, rbx
  0026f	90		 npad	 1
$LL3@replace_si@2:
  00270	0f b6 04 3b	 movzx	 eax, BYTE PTR [rbx+rdi]
  00274	48 ff c3	 inc	 rbx
  00277	49 ff ce	 dec	 r14
  0027a	88 43 ff	 mov	 BYTE PTR [rbx-1], al
  0027d	75 f1		 jne	 SHORT $LL3@replace_si@2
$LN7@replace_si@2:

; 1873 : 
; 1874 :     return result;

  0027f	49 8b c5	 mov	 rax, r13
$LN41@replace_si@2:

; 1875 : }

  00282	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00286	41 5f		 pop	 r15
  00288	41 5e		 pop	 r14
  0028a	41 5d		 pop	 r13
  0028c	41 5c		 pop	 r12
  0028e	5f		 pop	 rdi
  0028f	5e		 pop	 rsi
  00290	5d		 pop	 rbp
  00291	5b		 pop	 rbx
  00292	c3		 ret	 0
replace_single_character ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\objects\stringlib\count.h
pdata	SEGMENT
$pdata$replace_substring DD imagerel replace_substring
	DD	imagerel replace_substring+229
	DD	imagerel $unwind$replace_substring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$replace_substring DD imagerel replace_substring+229
	DD	imagerel replace_substring+285
	DD	imagerel $chain$1$replace_substring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$replace_substring DD imagerel replace_substring+285
	DD	imagerel replace_substring+290
	DD	imagerel $chain$3$replace_substring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$replace_substring DD imagerel replace_substring+290
	DD	imagerel replace_substring+665
	DD	imagerel $chain$4$replace_substring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$replace_substring DD imagerel replace_substring+665
	DD	imagerel replace_substring+701
	DD	imagerel $chain$6$replace_substring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$replace_substring DD imagerel replace_substring+701
	DD	imagerel replace_substring+724
	DD	imagerel $chain$8$replace_substring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$replace_substring DD 021H
	DD	imagerel replace_substring
	DD	imagerel replace_substring+229
	DD	imagerel $unwind$replace_substring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$replace_substring DD 020021H
	DD	07d400H
	DD	imagerel replace_substring+285
	DD	imagerel replace_substring+290
	DD	imagerel $chain$3$replace_substring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$replace_substring DD 020521H
	DD	07d405H
	DD	imagerel replace_substring+285
	DD	imagerel replace_substring+290
	DD	imagerel $chain$3$replace_substring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$replace_substring DD 020021H
	DD	010c400H
	DD	imagerel replace_substring
	DD	imagerel replace_substring+229
	DD	imagerel $unwind$replace_substring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$replace_substring DD 020821H
	DD	010c408H
	DD	imagerel replace_substring
	DD	imagerel replace_substring+229
	DD	imagerel $unwind$replace_substring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace_substring DD 083b01H
	DD	06e43bH
	DD	0f0107214H
	DD	0600d700eH
	DD	0300b500cH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
xdata	ENDS
;	COMDAT replace_substring
_TEXT	SEGMENT
result$1$ = 112
self$ = 112
from_s$ = 120
from_len$ = 128
to_s$ = 136
to_len$ = 144
maxcount$ = 152
replace_substring PROC					; COMDAT

; 1883 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	41 57		 push	 r15
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1884 :     char *self_s, *result_s;
; 1885 :     char *start, *next, *end;
; 1886 :     Py_ssize_t self_len, result_len;
; 1887 :     Py_ssize_t count, offset;
; 1888 :     PyByteArrayObject *result;
; 1889 : 
; 1890 :     self_s = PyByteArray_AS_STRING(self);

  00014	48 8b 71 60	 mov	 rsi, QWORD PTR [rcx+96]
  00018	4d 8b f8	 mov	 r15, r8
  0001b	48 8b e9	 mov	 rbp, rcx
  0001e	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_PyByteArray_empty_string
  00025	48 85 f6	 test	 rsi, rsi
  00028	74 09		 je	 SHORT $LN43@replace_su@2
  0002a	48 8b b9 80 00
	00 00		 mov	 rdi, QWORD PTR [rcx+128]
  00031	eb 03		 jmp	 SHORT $LN44@replace_su@2
$LN43@replace_su@2:
  00033	48 8b fb	 mov	 rdi, rbx
$LN44@replace_su@2:
  00036	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14

; 1891 :     self_len = PyByteArray_GET_SIZE(self);
; 1892 : 
; 1893 :     count = stringlib_count(self_s, self_len,
; 1894 :                             from_s, from_len,
; 1895 :                             maxcount);

  0003b	48 85 f6	 test	 rsi, rsi
  0003e	0f 88 79 02 00
	00		 js	 $LN65@replace_su@2
  00044	4d 85 c0	 test	 r8, r8
  00047	75 13		 jne	 SHORT $LN48@replace_su@2
  00049	4c 8b b4 24 98
	00 00 00	 mov	 r14, QWORD PTR maxcount$[rsp]
  00051	49 3b f6	 cmp	 rsi, r14
  00054	7d 38		 jge	 SHORT $LN50@replace_su@2
  00056	4c 8d 76 01	 lea	 r14, QWORD PTR [rsi+1]
  0005a	eb 32		 jmp	 SHORT $LN50@replace_su@2
$LN48@replace_su@2:
  0005c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR maxcount$[rsp]
  00064	4d 8b c8	 mov	 r9, r8
  00067	4c 8b c2	 mov	 r8, rdx
  0006a	48 8b d6	 mov	 rdx, rsi
  0006d	48 8b cf	 mov	 rcx, rdi
  00070	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00078	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007d	e8 00 00 00 00	 call	 fastsearch
  00082	4c 8b f0	 mov	 r14, rax
  00085	48 85 c0	 test	 rax, rax
  00088	0f 88 2f 02 00
	00		 js	 $LN65@replace_su@2
$LN50@replace_su@2:

; 1896 : 
; 1897 :     if (count == 0) {

  0008e	4d 85 f6	 test	 r14, r14
  00091	0f 84 26 02 00
	00		 je	 $LN65@replace_su@2

; 1900 :     }
; 1901 : 
; 1902 :     /* Check for overflow */
; 1903 :     /*    result_len = self_len + count * (to_len-from_len) */
; 1904 :     assert(count > 0);
; 1905 :     if (to_len - from_len > (PY_SSIZE_T_MAX - self_len) / count) {

  00097	48 8b ac 24 90
	00 00 00	 mov	 rbp, QWORD PTR to_len$[rsp]
  0009f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000a9	48 2b c6	 sub	 rax, rsi
  000ac	48 8b cd	 mov	 rcx, rbp
  000af	48 99		 cdq
  000b1	49 2b cf	 sub	 rcx, r15
  000b4	49 f7 fe	 idiv	 r14
  000b7	48 3b c8	 cmp	 rcx, rax
  000ba	7e 25		 jle	 SHORT $LN39@replace_su@2

; 1906 :         PyErr_SetString(PyExc_OverflowError, "replace bytes is too long");

  000bc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@JCBPECJD@replace?5bytes?5is?5too?5long?$AA@
  000ca	e8 00 00 00 00	 call	 PyErr_SetString

; 1907 :         return NULL;

  000cf	33 c0		 xor	 eax, eax
  000d1	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]

; 1943 : }

  000d6	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000da	41 5f		 pop	 r15
  000dc	5f		 pop	 rdi
  000dd	5e		 pop	 rsi
  000de	5d		 pop	 rbp
  000df	5b		 pop	 rbx
  000e0	c3		 ret	 0
$LN39@replace_su@2:

; 1908 :     }
; 1909 :     result_len = self_len + count * (to_len - from_len);

  000e1	49 0f af ce	 imul	 rcx, r14
  000e5	4c 89 a4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r12
  000ed	48 8d 14 0e	 lea	 rdx, QWORD PTR [rsi+rcx]

; 1910 : 
; 1911 :     if ( (result = (PyByteArrayObject *)
; 1912 :           PyByteArray_FromStringAndSize(NULL, result_len)) == NULL)

  000f1	33 c9		 xor	 ecx, ecx
  000f3	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000f8	4c 8b e0	 mov	 r12, rax
  000fb	48 89 44 24 70	 mov	 QWORD PTR result$1$[rsp], rax
  00100	48 85 c0	 test	 rax, rax
  00103	75 18		 jne	 SHORT $LN38@replace_su@2
$LN67@replace_su@2:
  00105	4c 8b a4 24 80
	00 00 00	 mov	 r12, QWORD PTR [rsp+128]
  0010d	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]

; 1943 : }

  00112	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00116	41 5f		 pop	 r15
  00118	5f		 pop	 rdi
  00119	5e		 pop	 rsi
  0011a	5d		 pop	 rbp
  0011b	5b		 pop	 rbx
  0011c	c3		 ret	 0
$LN38@replace_su@2:

; 1913 :         return NULL;
; 1914 :     result_s = PyByteArray_AS_STRING(result);

  0011d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00122	4c 89 6c 24 38	 mov	 QWORD PTR [rsp+56], r13
  00127	74 07		 je	 SHORT $LN45@replace_su@2
  00129	48 8b 98 80 00
	00 00		 mov	 rbx, QWORD PTR [rax+128]
$LN45@replace_su@2:

; 1915 : 
; 1916 :     start = self_s;
; 1917 :     end = self_s + self_len;

  00130	4c 8d 2c 3e	 lea	 r13, QWORD PTR [rsi+rdi]

; 1918 :     while (count-- > 0) {

  00134	4d 85 f6	 test	 r14, r14
  00137	0f 8e 38 01 00
	00		 jle	 $LN8@replace_su@2
  0013d	0f 1f 00	 npad	 3
$LL37@replace_su@2:

; 1919 :         offset = stringlib_find(start, end-start,
; 1920 :                                 from_s, from_len,
; 1921 :                                 0);

  00140	4c 8b 44 24 78	 mov	 r8, QWORD PTR from_s$[rsp]
  00145	49 8b d5	 mov	 rdx, r13
  00148	4d 8b cf	 mov	 r9, r15
  0014b	48 8b cf	 mov	 rcx, rdi
  0014e	48 2b d7	 sub	 rdx, rdi
  00151	49 ff ce	 dec	 r14
  00154	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0015d	e8 00 00 00 00	 call	 stringlib_find

; 1922 :         if (offset == -1)

  00162	48 83 f8 ff	 cmp	 rax, -1
  00166	0f 84 04 01 00
	00		 je	 $LN66@replace_su@2

; 1923 :             break;
; 1924 :         next = start+offset;

  0016c	4c 8d 24 38	 lea	 r12, QWORD PTR [rax+rdi]

; 1925 :         if (next == start) {

  00170	4c 3b e7	 cmp	 r12, rdi
  00173	75 56		 jne	 SHORT $LN24@replace_su@2

; 1926 :             /* replace with the 'to' */
; 1927 :             Py_MEMCPY(result_s, to_s, to_len);

  00175	48 83 fd 10	 cmp	 rbp, 16
  00179	72 1e		 jb	 SHORT $LN30@replace_su@2
  0017b	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR to_s$[rsp]
  00183	4c 8b c5	 mov	 r8, rbp
  00186	48 8b cb	 mov	 rcx, rbx
  00189	e8 00 00 00 00	 call	 memcpy

; 1928 :             result_s += to_len;

  0018e	48 03 dd	 add	 rbx, rbp

; 1929 :             start += from_len;

  00191	49 03 ff	 add	 rdi, r15

; 1930 :         } else {

  00194	e9 ce 00 00 00	 jmp	 $LN25@replace_su@2
$LN30@replace_su@2:

; 1926 :             /* replace with the 'to' */
; 1927 :             Py_MEMCPY(result_s, to_s, to_len);

  00199	48 85 ed	 test	 rbp, rbp
  0019c	74 22		 je	 SHORT $LN32@replace_su@2
  0019e	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR to_s$[rsp]
  001a6	48 8b cb	 mov	 rcx, rbx
  001a9	48 8b d5	 mov	 rdx, rbp
  001ac	4c 2b c3	 sub	 r8, rbx
  001af	90		 npad	 1
$LL28@replace_su@2:
  001b0	41 0f b6 04 08	 movzx	 eax, BYTE PTR [r8+rcx]
  001b5	48 ff c1	 inc	 rcx
  001b8	48 ff ca	 dec	 rdx
  001bb	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  001be	75 f0		 jne	 SHORT $LL28@replace_su@2
$LN32@replace_su@2:

; 1928 :             result_s += to_len;

  001c0	48 03 dd	 add	 rbx, rbp

; 1929 :             start += from_len;

  001c3	49 03 ff	 add	 rdi, r15

; 1930 :         } else {

  001c6	e9 9c 00 00 00	 jmp	 $LN25@replace_su@2
$LN24@replace_su@2:

; 1931 :             /* copy the unchanged old then the 'to' */
; 1932 :             Py_MEMCPY(result_s, start, next-start);

  001cb	49 8b f4	 mov	 rsi, r12
  001ce	48 2b f7	 sub	 rsi, rdi
  001d1	48 83 fe 10	 cmp	 rsi, 16
  001d5	72 10		 jb	 SHORT $LN21@replace_su@2
  001d7	4c 8b c6	 mov	 r8, rsi
  001da	48 8b d7	 mov	 rdx, rdi
  001dd	48 8b cb	 mov	 rcx, rbx
  001e0	e8 00 00 00 00	 call	 memcpy
  001e5	eb 28		 jmp	 SHORT $LN23@replace_su@2
$LN21@replace_su@2:
  001e7	48 85 f6	 test	 rsi, rsi
  001ea	74 23		 je	 SHORT $LN23@replace_su@2
  001ec	48 8b cb	 mov	 rcx, rbx
  001ef	48 2b fb	 sub	 rdi, rbx
  001f2	48 8b d6	 mov	 rdx, rsi
  001f5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL19@replace_su@2:
  00200	0f b6 04 0f	 movzx	 eax, BYTE PTR [rdi+rcx]
  00204	48 ff c1	 inc	 rcx
  00207	48 ff ca	 dec	 rdx
  0020a	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0020d	75 f1		 jne	 SHORT $LL19@replace_su@2
$LN23@replace_su@2:

; 1933 :             result_s += (next-start);

  0020f	48 03 de	 add	 rbx, rsi

; 1934 :             Py_MEMCPY(result_s, to_s, to_len);

  00212	48 83 fd 10	 cmp	 rbp, 16
  00216	72 15		 jb	 SHORT $LN13@replace_su@2
  00218	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR to_s$[rsp]
  00220	4c 8b c5	 mov	 r8, rbp
  00223	48 8b cb	 mov	 rcx, rbx
  00226	e8 00 00 00 00	 call	 memcpy
  0022b	eb 33		 jmp	 SHORT $LN15@replace_su@2
$LN13@replace_su@2:
  0022d	48 85 ed	 test	 rbp, rbp
  00230	74 2e		 je	 SHORT $LN15@replace_su@2
  00232	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR to_s$[rsp]
  0023a	48 8b cb	 mov	 rcx, rbx
  0023d	48 8b d5	 mov	 rdx, rbp
  00240	4c 2b c3	 sub	 r8, rbx
  00243	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL11@replace_su@2:
  00250	41 0f b6 04 08	 movzx	 eax, BYTE PTR [r8+rcx]
  00255	48 ff c1	 inc	 rcx
  00258	48 ff ca	 dec	 rdx
  0025b	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0025e	75 f0		 jne	 SHORT $LL11@replace_su@2
$LN15@replace_su@2:

; 1935 :             result_s += to_len;

  00260	48 03 dd	 add	 rbx, rbp

; 1936 :             start = next+from_len;

  00263	4b 8d 3c 3c	 lea	 rdi, QWORD PTR [r12+r15]
$LN25@replace_su@2:

; 1918 :     while (count-- > 0) {

  00267	4d 85 f6	 test	 r14, r14
  0026a	0f 8f d0 fe ff
	ff		 jg	 $LL37@replace_su@2
$LN66@replace_su@2:
  00270	4c 8b 64 24 70	 mov	 r12, QWORD PTR result$1$[rsp]
$LN8@replace_su@2:

; 1937 :         }
; 1938 :     }
; 1939 :     /* Copy the remainder of the remaining bytes */
; 1940 :     Py_MEMCPY(result_s, start, end-start);

  00275	4c 2b ef	 sub	 r13, rdi
  00278	49 83 fd 10	 cmp	 r13, 16
  0027c	72 1b		 jb	 SHORT $LN5@replace_su@2
  0027e	4d 8b c5	 mov	 r8, r13
  00281	48 8b d7	 mov	 rdx, rdi
  00284	48 8b cb	 mov	 rcx, rbx
  00287	e8 00 00 00 00	 call	 memcpy
  0028c	4c 8b 6c 24 38	 mov	 r13, QWORD PTR [rsp+56]

; 1941 : 
; 1942 :     return result;

  00291	49 8b c4	 mov	 rax, r12
  00294	e9 6c fe ff ff	 jmp	 $LN67@replace_su@2
$LN5@replace_su@2:

; 1937 :         }
; 1938 :     }
; 1939 :     /* Copy the remainder of the remaining bytes */
; 1940 :     Py_MEMCPY(result_s, start, end-start);

  00299	4d 85 ed	 test	 r13, r13
  0029c	74 12		 je	 SHORT $LN7@replace_su@2
  0029e	48 2b fb	 sub	 rdi, rbx
$LL3@replace_su@2:
  002a1	0f b6 04 3b	 movzx	 eax, BYTE PTR [rbx+rdi]
  002a5	48 ff c3	 inc	 rbx
  002a8	49 ff cd	 dec	 r13
  002ab	88 43 ff	 mov	 BYTE PTR [rbx-1], al
  002ae	75 f1		 jne	 SHORT $LL3@replace_su@2
$LN7@replace_su@2:
  002b0	4c 8b 6c 24 38	 mov	 r13, QWORD PTR [rsp+56]

; 1941 : 
; 1942 :     return result;

  002b5	49 8b c4	 mov	 rax, r12
  002b8	e9 48 fe ff ff	 jmp	 $LN67@replace_su@2
$LN65@replace_su@2:

; 1898 :         /* no matches, return unchanged */
; 1899 :         return return_self(self);

  002bd	48 8b cd	 mov	 rcx, rbp
  002c0	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]

; 1943 : }

  002c5	48 83 c4 40	 add	 rsp, 64			; 00000040H
  002c9	41 5f		 pop	 r15
  002cb	5f		 pop	 rdi
  002cc	5e		 pop	 rsi
  002cd	5d		 pop	 rbp
  002ce	5b		 pop	 rbx
  002cf	e9 00 00 00 00	 jmp	 return_self
replace_substring ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$replace DD imagerel replace
	DD	imagerel replace+253
	DD	imagerel $unwind$replace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$replace DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT replace
_TEXT	SEGMENT
self$ = 64
from_s$ = 72
from_len$ = 80
to_s$ = 88
to_len$ = 96
maxcount$ = 104
replace	PROC						; COMDAT

; 1951 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1952 :     if (maxcount < 0) {

  00004	48 8b 44 24 68	 mov	 rax, QWORD PTR maxcount$[rsp]
  00009	4d 8b d9	 mov	 r11, r9
  0000c	4c 8b d2	 mov	 r10, rdx
  0000f	48 85 c0	 test	 rax, rax
  00012	79 0c		 jns	 SHORT $LN21@replace

; 1953 :         maxcount = PY_SSIZE_T_MAX;

  00014	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0001e	eb 11		 jmp	 SHORT $LN14@replace
$LN21@replace:

; 1954 :     } else if (maxcount == 0 || PyByteArray_GET_SIZE(self) == 0) {

  00020	0f 84 ce 00 00
	00		 je	 $LN13@replace
  00026	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  0002b	0f 84 c3 00 00
	00		 je	 $LN13@replace
$LN14@replace:

; 1955 :         /* nothing to do; return the original bytes */
; 1956 :         return return_self(self);
; 1957 :     }
; 1958 : 
; 1959 :     if (maxcount == 0 ||
; 1960 :         (from_len == 0 && to_len == 0)) {

  00031	4d 85 c0	 test	 r8, r8
  00034	75 1d		 jne	 SHORT $LN10@replace
  00036	4c 8b 44 24 60	 mov	 r8, QWORD PTR to_len$[rsp]
  0003b	4d 85 c0	 test	 r8, r8
  0003e	0f 84 b0 00 00
	00		 je	 $LN13@replace

; 1961 :         /* nothing to do; return the original bytes */
; 1962 :         return return_self(self);
; 1963 :     }
; 1964 : 
; 1965 :     /* Handle zero-length special cases */
; 1966 : 
; 1967 :     if (from_len == 0) {
; 1968 :         /* insert the 'to' bytes everywhere.   */
; 1969 :         /*    >>> "Python".replace("", ".")     */
; 1970 :         /*    '.P.y.t.h.o.n.'                   */
; 1971 :         return replace_interleave(self, to_s, to_len, maxcount);

  00044	4c 8b c8	 mov	 r9, rax
  00047	49 8b d3	 mov	 rdx, r11

; 2013 :     }
; 2014 : }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	e9 00 00 00 00	 jmp	 replace_interleave
$LN10@replace:

; 1972 :     }
; 1973 : 
; 1974 :     /* Except for "".replace("", "A") == "A" there is no way beyond this */
; 1975 :     /* point for an empty self bytes to generate a non-empty bytes */
; 1976 :     /* Special case so the remaining code always gets a non-empty bytes */
; 1977 :     if (PyByteArray_GET_SIZE(self) == 0) {

  00053	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0

; 1978 :         return return_self(self);

  00058	0f 84 96 00 00
	00		 je	 $LN13@replace

; 1979 :     }
; 1980 : 
; 1981 :     if (to_len == 0) {

  0005e	48 8b 54 24 60	 mov	 rdx, QWORD PTR to_len$[rsp]
  00063	48 85 d2	 test	 rdx, rdx
  00066	75 25		 jne	 SHORT $LN6@replace

; 1982 :         /* delete all occurrences of 'from' bytes */
; 1983 :         if (from_len == 1) {

  00068	49 83 f8 01	 cmp	 r8, 1
  0006c	75 10		 jne	 SHORT $LN7@replace

; 1984 :             return replace_delete_single_character(
; 1985 :                     self, from_s[0], maxcount);

  0006e	41 0f b6 12	 movzx	 edx, BYTE PTR [r10]
  00072	4c 8b c0	 mov	 r8, rax

; 2013 :     }
; 2014 : }

  00075	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00079	e9 00 00 00 00	 jmp	 replace_delete_single_character
$LN7@replace:

; 1986 :         } else {
; 1987 :             return replace_delete_substring(self, from_s, from_len, maxcount);

  0007e	4c 8b c8	 mov	 r9, rax
  00081	49 8b d2	 mov	 rdx, r10

; 2013 :     }
; 2014 : }

  00084	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00088	e9 00 00 00 00	 jmp	 replace_delete_substring
$LN6@replace:

; 1988 :         }
; 1989 :     }
; 1990 : 
; 1991 :     /* Handle special case where both bytes have the same length */
; 1992 : 
; 1993 :     if (from_len == to_len) {

  0008d	4c 3b c2	 cmp	 r8, rdx
  00090	75 2c		 jne	 SHORT $LN3@replace

; 1994 :         if (from_len == 1) {

  00092	49 83 f8 01	 cmp	 r8, 1
  00096	75 14		 jne	 SHORT $LN4@replace

; 1995 :             return replace_single_character_in_place(
; 1996 :                     self,
; 1997 :                     from_s[0],
; 1998 :                     to_s[0],
; 1999 :                     maxcount);

  00098	45 0f b6 03	 movzx	 r8d, BYTE PTR [r11]
  0009c	41 0f b6 12	 movzx	 edx, BYTE PTR [r10]
  000a0	4c 8b c8	 mov	 r9, rax

; 2013 :     }
; 2014 : }

  000a3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a7	e9 00 00 00 00	 jmp	 replace_single_character_in_place
$LN4@replace:

; 2000 :         } else {
; 2001 :             return replace_substring_in_place(
; 2002 :                 self, from_s, from_len, to_s, to_len, maxcount);

  000ac	49 8b d2	 mov	 rdx, r10
  000af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b4	e8 00 00 00 00	 call	 replace_substring_in_place

; 2013 :     }
; 2014 : }

  000b9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bd	c3		 ret	 0
$LN3@replace:

; 2003 :         }
; 2004 :     }
; 2005 : 
; 2006 :     /* Otherwise use the more generic algorithms */
; 2007 :     if (from_len == 1) {

  000be	49 83 f8 01	 cmp	 r8, 1
  000c2	75 19		 jne	 SHORT $LN2@replace

; 2008 :         return replace_single_character(self, from_s[0],
; 2009 :                                         to_s, to_len, maxcount);

  000c4	4c 8b ca	 mov	 r9, rdx
  000c7	41 0f b6 12	 movzx	 edx, BYTE PTR [r10]
  000cb	4d 8b c3	 mov	 r8, r11
  000ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d3	e8 00 00 00 00	 call	 replace_single_character

; 2013 :     }
; 2014 : }

  000d8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000dc	c3		 ret	 0
$LN2@replace:

; 2010 :     } else {
; 2011 :         /* len('from')>=2, len('to')>=1 */
; 2012 :         return replace_substring(self, from_s, from_len, to_s, to_len, maxcount);

  000dd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000e2	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000e7	49 8b d2	 mov	 rdx, r10
  000ea	e8 00 00 00 00	 call	 replace_substring

; 2013 :     }
; 2014 : }

  000ef	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f3	c3		 ret	 0
$LN13@replace:
  000f4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f8	e9 00 00 00 00	 jmp	 return_self
replace	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@BJBCHDAG@OO?$HMn?3replace?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_replace DD imagerel bytearray_replace
	DD	imagerel bytearray_replace+219
	DD	imagerel $unwind$bytearray_replace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_replace DD 030b01H
	DD	01c010bH
	DD	03004H
xdata	ENDS
;	COMDAT ??_C@_0N@BJBCHDAG@OO?$HMn?3replace?$AA@
CONST	SEGMENT
??_C@_0N@BJBCHDAG@OO?$HMn?3replace?$AA@ DB 'OO|n:replace', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_replace
_TEXT	SEGMENT
to$ = 48
vfrom$ = 64
vto$ = 144
self$ = 240
args$ = 248
count$ = 256
from$ = 264
bytearray_replace PROC					; COMDAT

; 2026 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  0000b	48 8b d9	 mov	 rbx, rcx

; 2027 :     Py_ssize_t count = -1;
; 2028 :     PyObject *from, *to, *res;
; 2029 :     Py_buffer vfrom, vto;
; 2030 : 
; 2031 :     if (!PyArg_ParseTuple(args, "OO|n:replace", &from, &to, &count))

  0000e	49 8d 4b 18	 lea	 rcx, QWORD PTR [r11+24]
  00012	48 8b c2	 mov	 rax, rdx
  00015	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0001a	4c 8d 4c 24 30	 lea	 r9, QWORD PTR to$[rsp]
  0001f	4d 8d 43 20	 lea	 r8, QWORD PTR [r11+32]
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@BJBCHDAG@OO?$HMn?3replace?$AA@
  0002a	48 8b c8	 mov	 rcx, rax
  0002d	49 c7 43 18 ff
	ff ff ff	 mov	 QWORD PTR [r11+24], -1
  00035	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003a	85 c0		 test	 eax, eax

; 2032 :         return NULL;

  0003c	74 38		 je	 SHORT $LN6@bytearray_@28

; 2033 : 
; 2034 :     if (_getbuffer(from, &vfrom) < 0)

  0003e	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR from$[rsp]
  00046	48 8d 54 24 40	 lea	 rdx, QWORD PTR vfrom$[rsp]
  0004b	e8 00 00 00 00	 call	 _getbuffer
  00050	48 85 c0	 test	 rax, rax

; 2035 :         return NULL;

  00053	78 21		 js	 SHORT $LN6@bytearray_@28

; 2036 :     if (_getbuffer(to, &vto) < 0) {

  00055	48 8b 4c 24 30	 mov	 rcx, QWORD PTR to$[rsp]
  0005a	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR vto$[rsp]
  00062	e8 00 00 00 00	 call	 _getbuffer
  00067	48 85 c0	 test	 rax, rax
  0006a	79 15		 jns	 SHORT $LN1@bytearray_@28

; 2037 :         PyBuffer_Release(&vfrom);

  0006c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR vfrom$[rsp]
  00071	e8 00 00 00 00	 call	 PyBuffer_Release
$LN6@bytearray_@28:

; 2038 :         return NULL;

  00076	33 c0		 xor	 eax, eax

; 2048 : }

  00078	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  0007f	5b		 pop	 rbx
  00080	c3		 ret	 0
$LN1@bytearray_@28:

; 2039 :     }
; 2040 : 
; 2041 :     res = (PyObject *)replace((PyByteArrayObject *) self,
; 2042 :                               vfrom.buf, vfrom.len,
; 2043 :                               vto.buf, vto.len, count);

  00081	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR count$[rsp]
  00089	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR vto$[rsp]
  00091	4c 8b 44 24 50	 mov	 r8, QWORD PTR vfrom$[rsp+16]
  00096	48 8b 54 24 40	 mov	 rdx, QWORD PTR vfrom$[rsp]
  0009b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000a0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR vto$[rsp+16]
  000a8	48 8b cb	 mov	 rcx, rbx
  000ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b0	e8 00 00 00 00	 call	 replace

; 2044 : 
; 2045 :     PyBuffer_Release(&vfrom);

  000b5	48 8d 4c 24 40	 lea	 rcx, QWORD PTR vfrom$[rsp]
  000ba	48 8b d8	 mov	 rbx, rax
  000bd	e8 00 00 00 00	 call	 PyBuffer_Release

; 2046 :     PyBuffer_Release(&vto);

  000c2	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR vto$[rsp]
  000ca	e8 00 00 00 00	 call	 PyBuffer_Release

; 2047 :     return res;

  000cf	48 8b c3	 mov	 rax, rbx

; 2048 : }

  000d2	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  000d9	5b		 pop	 rbx
  000da	c3		 ret	 0
bytearray_replace ENDP
_TEXT	ENDS
PUBLIC	??_C@_09DBJIONJK@?$HMOn?3split?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_split DD imagerel bytearray_split
	DD	imagerel bytearray_split+280
	DD	imagerel $unwind$bytearray_split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_split DD 061201H
	DD	0146412H
	DD	0133412H
	DD	0700bf212H
xdata	ENDS
;	COMDAT ??_C@_09DBJIONJK@?$HMOn?3split?$AA@
CONST	SEGMENT
??_C@_09DBJIONJK@?$HMOn?3split?$AA@ DB '|On:split', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_split
_TEXT	SEGMENT
vsub$ = 48
maxsplit$ = 144
self$ = 144
args$ = 152
kwds$ = 160
subobj$ = 168
bytearray_split PROC					; COMDAT

; 2060 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 2061 :     static char *kwlist[] = {"sep", "maxsplit", 0};
; 2062 :     Py_ssize_t len = PyByteArray_GET_SIZE(self), n;

  00012	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]
  00016	49 8b c0	 mov	 rax, r8
  00019	4c 8b d2	 mov	 r10, rdx

; 2063 :     Py_ssize_t maxsplit = -1;

  0001c	48 c7 84 24 90
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR maxsplit$[rsp], -1

; 2064 :     const char *s = PyByteArray_AS_STRING(self), *sub;

  00028	48 85 ff	 test	 rdi, rdi
  0002b	74 09		 je	 SHORT $LN7@bytearray_@29
  0002d	48 8b 99 80 00
	00 00		 mov	 rbx, QWORD PTR [rcx+128]
  00034	eb 07		 jmp	 SHORT $LN8@bytearray_@29
$LN7@bytearray_@29:
  00036	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_PyByteArray_empty_string
$LN8@bytearray_@29:

; 2065 :     PyObject *list, *subobj = Py_None;
; 2066 :     Py_buffer vsub;
; 2067 : 
; 2068 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|On:split",
; 2069 :                                      kwlist, &subobj, &maxsplit))

  0003d	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR maxsplit$[rsp]
  00045	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  0004c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??bytearray_split@@9@9
  00053	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00058	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR subobj$[rsp]
  00060	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09DBJIONJK@?$HMOn?3split?$AA@
  00067	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0006c	48 8b d0	 mov	 rdx, rax
  0006f	49 8b ca	 mov	 rcx, r10
  00072	48 89 b4 24 a8
	00 00 00	 mov	 QWORD PTR subobj$[rsp], rsi
  0007a	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0007f	85 c0		 test	 eax, eax
  00081	75 04		 jne	 SHORT $LN4@bytearray_@29
$LN9@bytearray_@29:

; 2070 :         return NULL;

  00083	33 c0		 xor	 eax, eax
  00085	eb 7c		 jmp	 SHORT $LN5@bytearray_@29
$LN4@bytearray_@29:

; 2071 :     if (maxsplit < 0)

  00087	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR maxsplit$[rsp]

; 2072 :         maxsplit = PY_SSIZE_T_MAX;
; 2073 : 
; 2074 :     if (subobj == Py_None)

  0008f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR subobj$[rsp]
  00097	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000a1	4d 85 c0	 test	 r8, r8
  000a4	4c 0f 48 c0	 cmovs	 r8, rax
  000a8	4c 89 84 24 90
	00 00 00	 mov	 QWORD PTR maxsplit$[rsp], r8
  000b0	48 3b ce	 cmp	 rcx, rsi
  000b3	75 0d		 jne	 SHORT $LN2@bytearray_@29

; 2075 :         return stringlib_split_whitespace((PyObject*) self, s, len, maxsplit);

  000b5	48 8b d7	 mov	 rdx, rdi
  000b8	48 8b cb	 mov	 rcx, rbx
  000bb	e8 00 00 00 00	 call	 stringlib_split_whitespace
  000c0	eb 41		 jmp	 SHORT $LN5@bytearray_@29
$LN2@bytearray_@29:

; 2076 : 
; 2077 :     if (_getbuffer(subobj, &vsub) < 0)

  000c2	48 8d 54 24 30	 lea	 rdx, QWORD PTR vsub$[rsp]
  000c7	e8 00 00 00 00	 call	 _getbuffer
  000cc	48 85 c0	 test	 rax, rax

; 2078 :         return NULL;

  000cf	78 b2		 js	 SHORT $LN9@bytearray_@29

; 2079 :     sub = vsub.buf;
; 2080 :     n = vsub.len;
; 2081 : 
; 2082 :     list = stringlib_split(
; 2083 :         (PyObject*) self, s, len, sub, n, maxsplit
; 2084 :         );

  000d1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR maxsplit$[rsp]
  000d9	4c 8b 4c 24 40	 mov	 r9, QWORD PTR vsub$[rsp+16]
  000de	4c 8b 44 24 30	 mov	 r8, QWORD PTR vsub$[rsp]
  000e3	48 8b d7	 mov	 rdx, rdi
  000e6	48 8b cb	 mov	 rcx, rbx
  000e9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ee	e8 00 00 00 00	 call	 stringlib_split

; 2085 :     PyBuffer_Release(&vsub);

  000f3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR vsub$[rsp]
  000f8	48 8b d8	 mov	 rbx, rax
  000fb	e8 00 00 00 00	 call	 PyBuffer_Release

; 2086 :     return list;

  00100	48 8b c3	 mov	 rax, rbx
$LN5@bytearray_@29:

; 2087 : }

  00103	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  0010b	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  0010f	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00113	49 8b e3	 mov	 rsp, r11
  00116	5f		 pop	 rdi
  00117	c3		 ret	 0
bytearray_split ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_partition DD imagerel bytearray_partition
	DD	imagerel bytearray_partition+122
	DD	imagerel $unwind$bytearray_partition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_partition DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytearray_partition
_TEXT	SEGMENT
self$ = 64
sep_obj$ = 72
bytearray_partition PROC				; COMDAT

; 2098 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b d9	 mov	 rbx, rcx

; 2099 :     PyObject *bytesep, *result;
; 2100 : 
; 2101 :     bytesep = PyByteArray_FromObject(sep_obj);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 PyByteArray_FromObject
  00015	48 8b f8	 mov	 rdi, rax

; 2102 :     if (! bytesep)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0b		 jne	 SHORT $LN1@bytearray_@30

; 2114 : }

  0001d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00022	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN1@bytearray_@30:

; 2103 :         return NULL;
; 2104 : 
; 2105 :     result = stringlib_partition(
; 2106 :             (PyObject*) self,
; 2107 :             PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self),
; 2108 :             bytesep,
; 2109 :             PyByteArray_AS_STRING(bytesep), PyByteArray_GET_SIZE(bytesep)
; 2110 :             );

  00028	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string
  00033	48 85 c0	 test	 rax, rax
  00036	74 09		 je	 SHORT $LN4@bytearray_@30
  00038	4c 8b 8f 80 00
	00 00		 mov	 r9, QWORD PTR [rdi+128]
  0003f	eb 03		 jmp	 SHORT $LN5@bytearray_@30
$LN4@bytearray_@30:
  00041	4c 8b c9	 mov	 r9, rcx
$LN5@bytearray_@30:
  00044	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  00048	48 85 d2	 test	 rdx, rdx
  0004b	74 07		 je	 SHORT $LN6@bytearray_@30
  0004d	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
$LN6@bytearray_@30:
  00054	4c 8b c7	 mov	 r8, rdi
  00057	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005c	e8 00 00 00 00	 call	 stringlib_partition

; 2111 : 
; 2112 :     Py_DECREF(bytesep);

  00061	48 8b cf	 mov	 rcx, rdi
  00064	48 8b d8	 mov	 rbx, rax
  00067	e8 00 00 00 00	 call	 _Py_DecRef

; 2113 :     return result;

  0006c	48 8b c3	 mov	 rax, rbx

; 2114 : }

  0006f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00074	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
bytearray_partition ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_rpartition DD imagerel bytearray_rpartition
	DD	imagerel bytearray_rpartition+122
	DD	imagerel $unwind$bytearray_rpartition
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_rpartition DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytearray_rpartition
_TEXT	SEGMENT
self$ = 64
sep_obj$ = 72
bytearray_rpartition PROC				; COMDAT

; 2126 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b d9	 mov	 rbx, rcx

; 2127 :     PyObject *bytesep, *result;
; 2128 : 
; 2129 :     bytesep = PyByteArray_FromObject(sep_obj);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 PyByteArray_FromObject
  00015	48 8b f8	 mov	 rdi, rax

; 2130 :     if (! bytesep)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0b		 jne	 SHORT $LN1@bytearray_@31

; 2142 : }

  0001d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00022	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN1@bytearray_@31:

; 2131 :         return NULL;
; 2132 : 
; 2133 :     result = stringlib_rpartition(
; 2134 :             (PyObject*) self,
; 2135 :             PyByteArray_AS_STRING(self), PyByteArray_GET_SIZE(self),
; 2136 :             bytesep,
; 2137 :             PyByteArray_AS_STRING(bytesep), PyByteArray_GET_SIZE(bytesep)
; 2138 :             );

  00028	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string
  00033	48 85 c0	 test	 rax, rax
  00036	74 09		 je	 SHORT $LN4@bytearray_@31
  00038	4c 8b 8f 80 00
	00 00		 mov	 r9, QWORD PTR [rdi+128]
  0003f	eb 03		 jmp	 SHORT $LN5@bytearray_@31
$LN4@bytearray_@31:
  00041	4c 8b c9	 mov	 r9, rcx
$LN5@bytearray_@31:
  00044	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  00048	48 85 d2	 test	 rdx, rdx
  0004b	74 07		 je	 SHORT $LN6@bytearray_@31
  0004d	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
$LN6@bytearray_@31:
  00054	4c 8b c7	 mov	 r8, rdi
  00057	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005c	e8 00 00 00 00	 call	 stringlib_rpartition

; 2139 : 
; 2140 :     Py_DECREF(bytesep);

  00061	48 8b cf	 mov	 rcx, rdi
  00064	48 8b d8	 mov	 rbx, rax
  00067	e8 00 00 00 00	 call	 _Py_DecRef

; 2141 :     return result;

  0006c	48 8b c3	 mov	 rax, rbx

; 2142 : }

  0006f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00074	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
bytearray_rpartition ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@PNGLJNMN@?$HMOn?3rsplit?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_rsplit DD imagerel bytearray_rsplit
	DD	imagerel bytearray_rsplit+280
	DD	imagerel $unwind$bytearray_rsplit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_rsplit DD 061201H
	DD	0146412H
	DD	0133412H
	DD	0700bf212H
xdata	ENDS
;	COMDAT ??_C@_0L@PNGLJNMN@?$HMOn?3rsplit?$AA@
CONST	SEGMENT
??_C@_0L@PNGLJNMN@?$HMOn?3rsplit?$AA@ DB '|On:rsplit', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_rsplit
_TEXT	SEGMENT
vsub$ = 48
maxsplit$ = 144
self$ = 144
args$ = 152
kwds$ = 160
subobj$ = 168
bytearray_rsplit PROC					; COMDAT

; 2155 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 2156 :     static char *kwlist[] = {"sep", "maxsplit", 0};
; 2157 :     Py_ssize_t len = PyByteArray_GET_SIZE(self), n;

  00012	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]
  00016	49 8b c0	 mov	 rax, r8
  00019	4c 8b d2	 mov	 r10, rdx

; 2158 :     Py_ssize_t maxsplit = -1;

  0001c	48 c7 84 24 90
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR maxsplit$[rsp], -1

; 2159 :     const char *s = PyByteArray_AS_STRING(self), *sub;

  00028	48 85 ff	 test	 rdi, rdi
  0002b	74 09		 je	 SHORT $LN7@bytearray_@32
  0002d	48 8b 99 80 00
	00 00		 mov	 rbx, QWORD PTR [rcx+128]
  00034	eb 07		 jmp	 SHORT $LN8@bytearray_@32
$LN7@bytearray_@32:
  00036	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_PyByteArray_empty_string
$LN8@bytearray_@32:

; 2160 :     PyObject *list, *subobj = Py_None;
; 2161 :     Py_buffer vsub;
; 2162 : 
; 2163 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|On:rsplit",
; 2164 :                                      kwlist, &subobj, &maxsplit))

  0003d	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR maxsplit$[rsp]
  00045	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  0004c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??bytearray_rsplit@@9@9
  00053	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00058	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR subobj$[rsp]
  00060	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@PNGLJNMN@?$HMOn?3rsplit?$AA@
  00067	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0006c	48 8b d0	 mov	 rdx, rax
  0006f	49 8b ca	 mov	 rcx, r10
  00072	48 89 b4 24 a8
	00 00 00	 mov	 QWORD PTR subobj$[rsp], rsi
  0007a	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0007f	85 c0		 test	 eax, eax
  00081	75 04		 jne	 SHORT $LN4@bytearray_@32
$LN9@bytearray_@32:

; 2165 :         return NULL;

  00083	33 c0		 xor	 eax, eax
  00085	eb 7c		 jmp	 SHORT $LN5@bytearray_@32
$LN4@bytearray_@32:

; 2166 :     if (maxsplit < 0)

  00087	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR maxsplit$[rsp]

; 2167 :         maxsplit = PY_SSIZE_T_MAX;
; 2168 : 
; 2169 :     if (subobj == Py_None)

  0008f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR subobj$[rsp]
  00097	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000a1	4d 85 c0	 test	 r8, r8
  000a4	4c 0f 48 c0	 cmovs	 r8, rax
  000a8	4c 89 84 24 90
	00 00 00	 mov	 QWORD PTR maxsplit$[rsp], r8
  000b0	48 3b ce	 cmp	 rcx, rsi
  000b3	75 0d		 jne	 SHORT $LN2@bytearray_@32

; 2170 :         return stringlib_rsplit_whitespace((PyObject*) self, s, len, maxsplit);

  000b5	48 8b d7	 mov	 rdx, rdi
  000b8	48 8b cb	 mov	 rcx, rbx
  000bb	e8 00 00 00 00	 call	 stringlib_rsplit_whitespace
  000c0	eb 41		 jmp	 SHORT $LN5@bytearray_@32
$LN2@bytearray_@32:

; 2171 : 
; 2172 :     if (_getbuffer(subobj, &vsub) < 0)

  000c2	48 8d 54 24 30	 lea	 rdx, QWORD PTR vsub$[rsp]
  000c7	e8 00 00 00 00	 call	 _getbuffer
  000cc	48 85 c0	 test	 rax, rax

; 2173 :         return NULL;

  000cf	78 b2		 js	 SHORT $LN9@bytearray_@32

; 2174 :     sub = vsub.buf;
; 2175 :     n = vsub.len;
; 2176 : 
; 2177 :     list = stringlib_rsplit(
; 2178 :         (PyObject*) self, s, len, sub, n, maxsplit
; 2179 :         );

  000d1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR maxsplit$[rsp]
  000d9	4c 8b 4c 24 40	 mov	 r9, QWORD PTR vsub$[rsp+16]
  000de	4c 8b 44 24 30	 mov	 r8, QWORD PTR vsub$[rsp]
  000e3	48 8b d7	 mov	 rdx, rdi
  000e6	48 8b cb	 mov	 rcx, rbx
  000e9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ee	e8 00 00 00 00	 call	 stringlib_rsplit

; 2180 :     PyBuffer_Release(&vsub);

  000f3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR vsub$[rsp]
  000f8	48 8b d8	 mov	 rbx, rax
  000fb	e8 00 00 00 00	 call	 PyBuffer_Release

; 2181 :     return list;

  00100	48 8b c3	 mov	 rax, rbx
$LN5@bytearray_@32:

; 2182 : }

  00103	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  0010b	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  0010f	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00113	49 8b e3	 mov	 rsp, r11
  00116	5f		 pop	 rdi
  00117	c3		 ret	 0
bytearray_rsplit ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytearray_reverse DD imagerel bytearray_reverse
	DD	imagerel bytearray_reverse+181
	DD	imagerel $unwind$bytearray_reverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_reverse DD 034f01H
	DD	06344fH
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
xdata	ENDS
;	COMDAT bytearray_reverse
_TEXT	SEGMENT
self$ = 64
unused$ = 72
bytearray_reverse PROC					; COMDAT

; 2190 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2191 :     char swap, *head, *tail;
; 2192 :     Py_ssize_t i, j, n = Py_SIZE(self);

  00004	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]

; 2193 : 
; 2194 :     j = n / 2;
; 2195 :     head = self->ob_bytes;

  00008	4c 8b 89 80 00
	00 00		 mov	 r9, QWORD PTR [rcx+128]
  0000f	49 8b c0	 mov	 rax, r8

; 2196 :     tail = head + n - 1;

  00012	4f 8d 54 01 ff	 lea	 r10, QWORD PTR [r9+r8-1]
  00017	48 99		 cdq
  00019	48 2b c2	 sub	 rax, rdx
  0001c	48 d1 f8	 sar	 rax, 1

; 2197 :     for (i = 0; i < j; i++) {

  0001f	48 85 c0	 test	 rax, rax
  00022	7e 26		 jle	 SHORT $LN1@bytearray_@33
  00024	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL3@bytearray_@33:

; 2198 :         swap = *head;
; 2199 :         *head++ = *tail;

  00030	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  00034	41 0f b6 11	 movzx	 edx, BYTE PTR [r9]

; 2200 :         *tail-- = swap;

  00038	49 ff ca	 dec	 r10
  0003b	41 88 09	 mov	 BYTE PTR [r9], cl
  0003e	41 88 52 01	 mov	 BYTE PTR [r10+1], dl
  00042	49 ff c1	 inc	 r9
  00045	48 ff c8	 dec	 rax
  00048	75 e6		 jne	 SHORT $LL3@bytearray_@33
$LN1@bytearray_@33:
  0004a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 2201 :     }
; 2202 : 
; 2203 :     Py_RETURN_NONE;

  0004f	e8 00 00 00 00	 call	 _Py_PXCTX
  00054	85 c0		 test	 eax, eax
  00056	75 4c		 jne	 SHORT $LN12@bytearray_@33
  00058	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0006d	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00073	4c 8b cb	 mov	 r9, rbx
  00076	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00083	85 c0		 test	 eax, eax
  00085	75 09		 jne	 SHORT $LN6@bytearray_@33
  00087	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0008e	74 07		 je	 SHORT $LN14@bytearray_@33
$LN6@bytearray_@33:
  00090	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN14@bytearray_@33:
  00097	48 8b c3	 mov	 rax, rbx
  0009a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 2204 : }

  0009f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a3	c3		 ret	 0
$LN12@bytearray_@33:

; 2201 :     }
; 2202 : 
; 2203 :     Py_RETURN_NONE;

  000a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000ab	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 2204 : }

  000b0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b4	c3		 ret	 0
bytearray_reverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@BJCCKGGB@cannot?5add?5more?5objects?5to?5bytea@ ; `string'
PUBLIC	??_C@_09EEABNKNH@nO?3insert?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_insert DD imagerel bytearray_insert
	DD	imagerel bytearray_insert+243
	DD	imagerel $unwind$bytearray_insert
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_insert DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0CF@BJCCKGGB@cannot?5add?5more?5objects?5to?5bytea@
CONST	SEGMENT
??_C@_0CF@BJCCKGGB@cannot?5add?5more?5objects?5to?5bytea@ DB 'cannot add '
	DB	'more objects to bytearray', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EEABNKNH@nO?3insert?$AA@
CONST	SEGMENT
??_C@_09EEABNKNH@nO?3insert?$AA@ DB 'nO:insert', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_insert
_TEXT	SEGMENT
ival$ = 48
self$ = 48
args$ = 56
where$ = 64
value$ = 72
bytearray_insert PROC					; COMDAT

; 2212 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2213 :     PyObject *value;
; 2214 :     int ival;
; 2215 :     Py_ssize_t where, n = Py_SIZE(self);

  0000a	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  0000e	48 8b c2	 mov	 rax, rdx
  00011	48 8b f9	 mov	 rdi, rcx

; 2216 : 
; 2217 :     if (!PyArg_ParseTuple(args, "nO:insert", &where, &value))

  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09EEABNKNH@nO?3insert?$AA@
  0001b	4c 8d 4c 24 48	 lea	 r9, QWORD PTR value$[rsp]
  00020	4c 8d 44 24 40	 lea	 r8, QWORD PTR where$[rsp]
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002d	85 c0		 test	 eax, eax

; 2218 :         return NULL;

  0002f	74 22		 je	 SHORT $LN10@bytearray_@34

; 2219 : 
; 2220 :     if (n == PY_SSIZE_T_MAX) {

  00031	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0003b	48 3b d8	 cmp	 rbx, rax
  0003e	75 20		 jne	 SHORT $LN6@bytearray_@34

; 2221 :         PyErr_SetString(PyExc_OverflowError,
; 2222 :                         "cannot add more objects to bytearray");

  00040	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@BJCCKGGB@cannot?5add?5more?5objects?5to?5bytea@
  0004e	e8 00 00 00 00	 call	 PyErr_SetString
$LN10@bytearray_@34:

; 2223 :         return NULL;

  00053	33 c0		 xor	 eax, eax

; 2241 : }

  00055	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0005a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005e	5f		 pop	 rdi
  0005f	c3		 ret	 0
$LN6@bytearray_@34:

; 2224 :     }
; 2225 :     if (!_getbytevalue(value, &ival))

  00060	48 8b 4c 24 48	 mov	 rcx, QWORD PTR value$[rsp]
  00065	48 8d 54 24 30	 lea	 rdx, QWORD PTR ival$[rsp]
  0006a	e8 00 00 00 00	 call	 _getbytevalue
  0006f	85 c0		 test	 eax, eax

; 2226 :         return NULL;

  00071	74 e0		 je	 SHORT $LN10@bytearray_@34

; 2227 :     if (PyByteArray_Resize((PyObject *)self, n + 1) < 0)

  00073	48 8d 53 01	 lea	 rdx, QWORD PTR [rbx+1]
  00077	48 8b cf	 mov	 rcx, rdi
  0007a	e8 00 00 00 00	 call	 PyByteArray_Resize
  0007f	85 c0		 test	 eax, eax

; 2228 :         return NULL;

  00081	78 d0		 js	 SHORT $LN10@bytearray_@34

; 2229 : 
; 2230 :     if (where < 0) {

  00083	48 8b 4c 24 40	 mov	 rcx, QWORD PTR where$[rsp]
  00088	48 85 c9	 test	 rcx, rcx
  0008b	79 0c		 jns	 SHORT $LN2@bytearray_@34

; 2231 :         where += n;

  0008d	48 03 cb	 add	 rcx, rbx

; 2232 :         if (where < 0)

  00090	b8 00 00 00 00	 mov	 eax, 0
  00095	48 0f 48 c8	 cmovs	 rcx, rax
$LN2@bytearray_@34:

; 2233 :             where = 0;
; 2234 :     }
; 2235 :     if (where > n)
; 2236 :         where = n;
; 2237 :     memmove(self->ob_bytes + where + 1, self->ob_bytes + where, n - where);

  00099	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  000a0	48 3b cb	 cmp	 rcx, rbx
  000a3	48 0f 4f cb	 cmovg	 rcx, rbx
  000a7	48 2b d9	 sub	 rbx, rcx
  000aa	48 89 4c 24 40	 mov	 QWORD PTR where$[rsp], rcx
  000af	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  000b3	4c 8b c3	 mov	 r8, rbx
  000b6	48 8d 4a 01	 lea	 rcx, QWORD PTR [rdx+1]
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 2238 :     self->ob_bytes[where] = ival;

  000c0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR where$[rsp]
  000c5	4c 8b 9f 80 00
	00 00		 mov	 r11, QWORD PTR [rdi+128]
  000cc	0f b6 44 24 30	 movzx	 eax, BYTE PTR ival$[rsp]
  000d1	42 88 04 19	 mov	 BYTE PTR [rcx+r11], al

; 2239 : 
; 2240 :     Py_RETURN_NONE;

  000d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000dc	e8 00 00 00 00	 call	 _Py_IncRef

; 2241 : }

  000e1	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000ed	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f1	5f		 pop	 rdi
  000f2	c3		 ret	 0
bytearray_insert ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytearray_append DD imagerel bytearray_append
	DD	imagerel bytearray_append+202
	DD	imagerel $unwind$bytearray_append
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_append DD 040a01H
	DD	09340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
xdata	ENDS
;	COMDAT bytearray_append
_TEXT	SEGMENT
value$ = 64
self$ = 64
arg$ = 72
bytearray_append PROC					; COMDAT

; 2249 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2250 :     int value;
; 2251 :     Py_ssize_t n = Py_SIZE(self);

  0000a	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  0000e	48 8b c2	 mov	 rax, rdx
  00011	48 8b f9	 mov	 rdi, rcx

; 2252 : 
; 2253 :     if (! _getbytevalue(arg, &value))

  00014	48 8d 54 24 40	 lea	 rdx, QWORD PTR value$[rsp]
  00019	48 8b c8	 mov	 rcx, rax
  0001c	e8 00 00 00 00	 call	 _getbytevalue
  00021	85 c0		 test	 eax, eax

; 2254 :         return NULL;

  00023	74 22		 je	 SHORT $LN10@bytearray_@35

; 2255 :     if (n == PY_SSIZE_T_MAX) {

  00025	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0002f	48 3b d8	 cmp	 rbx, rax
  00032	75 20		 jne	 SHORT $LN2@bytearray_@35

; 2256 :         PyErr_SetString(PyExc_OverflowError,
; 2257 :                         "cannot add more objects to bytearray");

  00034	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@BJCCKGGB@cannot?5add?5more?5objects?5to?5bytea@
  00042	e8 00 00 00 00	 call	 PyErr_SetString
$LN10@bytearray_@35:

; 2258 :         return NULL;

  00047	33 c0		 xor	 eax, eax

; 2266 : }

  00049	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0004e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
$LN2@bytearray_@35:

; 2259 :     }
; 2260 :     if (PyByteArray_Resize((PyObject *)self, n + 1) < 0)

  00054	48 8d 53 01	 lea	 rdx, QWORD PTR [rbx+1]
  00058	48 8b cf	 mov	 rcx, rdi
  0005b	e8 00 00 00 00	 call	 PyByteArray_Resize
  00060	85 c0		 test	 eax, eax

; 2261 :         return NULL;

  00062	78 e3		 js	 SHORT $LN10@bytearray_@35

; 2262 : 
; 2263 :     self->ob_bytes[n] = value;

  00064	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  0006b	0f b6 44 24 40	 movzx	 eax, BYTE PTR value$[rsp]
  00070	88 04 0b	 mov	 BYTE PTR [rbx+rcx], al

; 2264 : 
; 2265 :     Py_RETURN_NONE;

  00073	e8 00 00 00 00	 call	 _Py_PXCTX
  00078	85 c0		 test	 eax, eax
  0007a	75 3c		 jne	 SHORT $LN7@bytearray_@35
  0007c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00091	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00097	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0009f	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a4	85 c0		 test	 eax, eax
  000a6	75 09		 jne	 SHORT $LN6@bytearray_@35
  000a8	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000af	74 07		 je	 SHORT $LN7@bytearray_@35
$LN6@bytearray_@35:
  000b1	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN7@bytearray_@35:
  000b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 2266 : }

  000bf	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000c4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c8	5f		 pop	 rdi
  000c9	c3		 ret	 0
bytearray_append ENDP
_TEXT	ENDS
EXTRN	PyIter_Next:PROC
EXTRN	_PyObject_LengthHint:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytearray_extend DD imagerel bytearray_extend
	DD	imagerel bytearray_extend+157
	DD	imagerel $unwind$bytearray_extend
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$bytearray_extend DD imagerel bytearray_extend+157
	DD	imagerel bytearray_extend+189
	DD	imagerel $chain$0$bytearray_extend
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$bytearray_extend DD imagerel bytearray_extend+189
	DD	imagerel bytearray_extend+249
	DD	imagerel $chain$3$bytearray_extend
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$bytearray_extend DD imagerel bytearray_extend+249
	DD	imagerel bytearray_extend+504
	DD	imagerel $chain$6$bytearray_extend
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$bytearray_extend DD imagerel bytearray_extend+504
	DD	imagerel bytearray_extend+523
	DD	imagerel $chain$7$bytearray_extend
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$bytearray_extend DD imagerel bytearray_extend+523
	DD	imagerel bytearray_extend+551
	DD	imagerel $chain$9$bytearray_extend
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$bytearray_extend DD 0a0021H
	DD	06f400H
	DD	07d400H
	DD	0fc400H
	DD	0e7400H
	DD	0c6400H
	DD	imagerel bytearray_extend
	DD	imagerel bytearray_extend+157
	DD	imagerel $unwind$bytearray_extend
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$bytearray_extend DD 021H
	DD	imagerel bytearray_extend+189
	DD	imagerel bytearray_extend+249
	DD	imagerel $chain$3$bytearray_extend
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$bytearray_extend DD 060f21H
	DD	06f40fH
	DD	0e740aH
	DD	0c6405H
	DD	imagerel bytearray_extend+189
	DD	imagerel bytearray_extend+249
	DD	imagerel $chain$3$bytearray_extend
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$bytearray_extend DD 040d21H
	DD	07d40dH
	DD	0fc400H
	DD	imagerel bytearray_extend
	DD	imagerel bytearray_extend+157
	DD	imagerel $unwind$bytearray_extend
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$bytearray_extend DD 020521H
	DD	0fc405H
	DD	imagerel bytearray_extend
	DD	imagerel bytearray_extend+157
	DD	imagerel $unwind$bytearray_extend
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_extend DD 040901H
	DD	0e0057209H
	DD	030025003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
xdata	ENDS
;	COMDAT bytearray_extend
_TEXT	SEGMENT
self$ = 96
value$ = 104
arg$ = 104
bytearray_extend PROC					; COMDAT

; 2275 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	41 56		 push	 r14
  00005	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 2276 :     PyObject *it, *item, *bytearray_obj;
; 2277 :     Py_ssize_t buf_size = 0, len = 0;
; 2278 :     int value;
; 2279 :     char *buf;
; 2280 : 
; 2281 :     /* bytearray_setslice code only accepts something supporting PEP 3118. */
; 2282 :     if (PyObject_CheckBuffer(arg)) {

  00009	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0000d	48 8b da	 mov	 rbx, rdx
  00010	33 ed		 xor	 ebp, ebp
  00012	48 8b 90 f8 00
	00 00		 mov	 rdx, QWORD PTR [rax+248]
  00019	4c 8b f1	 mov	 r14, rcx
  0001c	48 85 d2	 test	 rdx, rdx
  0001f	74 79		 je	 SHORT $LN12@bytearray_@36
  00021	48 39 2a	 cmp	 QWORD PTR [rdx], rbp
  00024	74 74		 je	 SHORT $LN12@bytearray_@36

; 2283 :         if (bytearray_setslice(self, Py_SIZE(self), Py_SIZE(self), arg) == -1)

  00026	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  0002a	4c 8b cb	 mov	 r9, rbx
  0002d	4c 8b c2	 mov	 r8, rdx
  00030	e8 00 00 00 00	 call	 bytearray_setslice
  00035	83 f8 ff	 cmp	 eax, -1
  00038	75 0b		 jne	 SHORT $LN11@bytearray_@36

; 2284 :             return NULL;

  0003a	33 c0		 xor	 eax, eax

; 2344 : }

  0003c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00040	41 5e		 pop	 r14
  00042	5d		 pop	 rbp
  00043	5b		 pop	 rbx
  00044	c3		 ret	 0
$LN11@bytearray_@36:

; 2285 : 
; 2286 :         Py_RETURN_NONE;

  00045	e8 00 00 00 00	 call	 _Py_PXCTX
  0004a	85 c0		 test	 eax, eax
  0004c	75 3c		 jne	 SHORT $LN20@bytearray_@36
  0004e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00063	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00069	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00071	e8 00 00 00 00	 call	 _PyParallel_Guard
  00076	85 c0		 test	 eax, eax
  00078	75 09		 jne	 SHORT $LN19@bytearray_@36
  0007a	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00081	74 07		 je	 SHORT $LN20@bytearray_@36
$LN19@bytearray_@36:
  00083	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN20@bytearray_@36:
  0008a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 2344 : }

  00091	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00095	41 5e		 pop	 r14
  00097	5d		 pop	 rbp
  00098	5b		 pop	 rbx
  00099	c3		 ret	 0
$LN12@bytearray_@36:

; 2287 :     }
; 2288 : 
; 2289 :     it = PyObject_GetIter(arg);

  0009a	48 8b cb	 mov	 rcx, rbx
  0009d	4c 89 64 24 78	 mov	 QWORD PTR [rsp+120], r12
  000a2	e8 00 00 00 00	 call	 PyObject_GetIter
  000a7	4c 8b e0	 mov	 r12, rax

; 2290 :     if (it == NULL)

  000aa	48 85 c0	 test	 rax, rax
  000ad	75 0e		 jne	 SHORT $LN10@bytearray_@36
  000af	4c 8b 64 24 78	 mov	 r12, QWORD PTR [rsp+120]

; 2344 : }

  000b4	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000b8	41 5e		 pop	 r14
  000ba	5d		 pop	 rbp
  000bb	5b		 pop	 rbx
  000bc	c3		 ret	 0
$LN10@bytearray_@36:

; 2291 :         return NULL;
; 2292 : 
; 2293 :     /* Try to determine the length of the argument. 32 is arbitrary. */
; 2294 :     buf_size = _PyObject_LengthHint(arg, 32);

  000bd	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000c2	48 8b cb	 mov	 rcx, rbx
  000c5	4c 89 6c 24 38	 mov	 QWORD PTR [rsp+56], r13
  000ca	e8 00 00 00 00	 call	 _PyObject_LengthHint
  000cf	4c 8b e8	 mov	 r13, rax

; 2295 :     if (buf_size == -1) {

  000d2	48 83 f8 ff	 cmp	 rax, -1

; 2296 :         Py_DECREF(it);
; 2297 :         return NULL;

  000d6	74 12		 je	 SHORT $LN34@bytearray_@36

; 2298 :     }
; 2299 : 
; 2300 :     bytearray_obj = PyByteArray_FromStringAndSize(NULL, buf_size);

  000d8	48 8b d0	 mov	 rdx, rax
  000db	33 c9		 xor	 ecx, ecx
  000dd	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000e2	48 8b d8	 mov	 rbx, rax

; 2301 :     if (bytearray_obj == NULL) {

  000e5	48 85 c0	 test	 rax, rax
  000e8	75 0f		 jne	 SHORT $LN8@bytearray_@36
$LN34@bytearray_@36:

; 2302 :         Py_DECREF(it);

  000ea	49 8b cc	 mov	 rcx, r12
  000ed	e8 00 00 00 00	 call	 _Py_DecRef

; 2303 :         return NULL;

  000f2	33 c0		 xor	 eax, eax
  000f4	e9 ff 00 00 00	 jmp	 $LN28@bytearray_@36
$LN8@bytearray_@36:
  000f9	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  000fe	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi
  00103	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15

; 2304 :     }
; 2305 :     buf = PyByteArray_AS_STRING(bytearray_obj);

  00108	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:_PyByteArray_empty_string
  0010f	48 39 68 60	 cmp	 QWORD PTR [rax+96], rbp
  00113	74 09		 je	 SHORT $LN15@bytearray_@36
  00115	48 8b b8 80 00
	00 00		 mov	 rdi, QWORD PTR [rax+128]
  0011c	eb 03		 jmp	 SHORT $LN16@bytearray_@36
$LN15@bytearray_@36:
  0011e	49 8b ff	 mov	 rdi, r15
$LN16@bytearray_@36:

; 2306 : 
; 2307 :     while ((item = PyIter_Next(it)) != NULL) {

  00121	49 8b cc	 mov	 rcx, r12
  00124	e8 00 00 00 00	 call	 PyIter_Next
  00129	48 8b f0	 mov	 rsi, rax
  0012c	48 85 c0	 test	 rax, rax
  0012f	74 6f		 je	 SHORT $LN6@bytearray_@36
$LL7@bytearray_@36:

; 2308 :         if (! _getbytevalue(item, &value)) {

  00131	48 8d 54 24 68	 lea	 rdx, QWORD PTR value$[rsp]
  00136	48 8b ce	 mov	 rcx, rsi
  00139	e8 00 00 00 00	 call	 _getbytevalue
  0013e	85 c0		 test	 eax, eax
  00140	0f 84 c5 00 00
	00		 je	 $LN24@bytearray_@36

; 2313 :         }
; 2314 :         buf[len++] = value;

  00146	0f b6 4c 24 68	 movzx	 ecx, BYTE PTR value$[rsp]
  0014b	48 ff c5	 inc	 rbp
  0014e	88 4c 2f ff	 mov	 BYTE PTR [rdi+rbp-1], cl

; 2315 :         Py_DECREF(item);

  00152	48 8b ce	 mov	 rcx, rsi
  00155	e8 00 00 00 00	 call	 _Py_DecRef

; 2316 : 
; 2317 :         if (len >= buf_size) {

  0015a	49 3b ed	 cmp	 rbp, r13
  0015d	7c 31		 jl	 SHORT $LN18@bytearray_@36

; 2318 :             buf_size = len + (len >> 1) + 1;

  0015f	48 8b c5	 mov	 rax, rbp

; 2319 :             if (PyByteArray_Resize((PyObject *)bytearray_obj, buf_size) < 0) {

  00162	48 8b cb	 mov	 rcx, rbx
  00165	48 d1 f8	 sar	 rax, 1
  00168	4c 8d 6c 28 01	 lea	 r13, QWORD PTR [rax+rbp+1]
  0016d	49 8b d5	 mov	 rdx, r13
  00170	e8 00 00 00 00	 call	 PyByteArray_Resize
  00175	85 c0		 test	 eax, eax
  00177	0f 88 96 00 00
	00		 js	 $LN25@bytearray_@36

; 2320 :                 Py_DECREF(it);
; 2321 :                 Py_DECREF(bytearray_obj);
; 2322 :                 return NULL;
; 2323 :             }
; 2324 :             /* Recompute the `buf' pointer, since the resizing operation may
; 2325 :                have invalidated it. */
; 2326 :             buf = PyByteArray_AS_STRING(bytearray_obj);

  0017d	48 83 7b 60 00	 cmp	 QWORD PTR [rbx+96], 0
  00182	74 09		 je	 SHORT $LN17@bytearray_@36
  00184	48 8b bb 80 00
	00 00		 mov	 rdi, QWORD PTR [rbx+128]
  0018b	eb 03		 jmp	 SHORT $LN18@bytearray_@36
$LN17@bytearray_@36:
  0018d	49 8b ff	 mov	 rdi, r15
$LN18@bytearray_@36:

; 2306 : 
; 2307 :     while ((item = PyIter_Next(it)) != NULL) {

  00190	49 8b cc	 mov	 rcx, r12
  00193	e8 00 00 00 00	 call	 PyIter_Next
  00198	48 8b f0	 mov	 rsi, rax
  0019b	48 85 c0	 test	 rax, rax
  0019e	75 91		 jne	 SHORT $LL7@bytearray_@36
$LN6@bytearray_@36:

; 2327 :         }
; 2328 :     }
; 2329 :     Py_DECREF(it);

  001a0	49 8b cc	 mov	 rcx, r12
  001a3	e8 00 00 00 00	 call	 _Py_DecRef

; 2330 : 
; 2331 :     /* Resize down to exact size. */
; 2332 :     if (PyByteArray_Resize((PyObject *)bytearray_obj, len) < 0) {

  001a8	48 8b d5	 mov	 rdx, rbp
  001ab	48 8b cb	 mov	 rcx, rbx
  001ae	e8 00 00 00 00	 call	 PyByteArray_Resize
  001b3	85 c0		 test	 eax, eax

; 2333 :         Py_DECREF(bytearray_obj);
; 2334 :         return NULL;

  001b5	78 64		 js	 SHORT $LN33@bytearray_@36

; 2335 :     }
; 2336 : 
; 2337 :     if (bytearray_setslice(self, Py_SIZE(self), Py_SIZE(self), bytearray_obj) == -1) {

  001b7	49 8b 56 60	 mov	 rdx, QWORD PTR [r14+96]
  001bb	4c 8b cb	 mov	 r9, rbx
  001be	49 8b ce	 mov	 rcx, r14
  001c1	4c 8b c2	 mov	 r8, rdx
  001c4	e8 00 00 00 00	 call	 bytearray_setslice

; 2338 :         Py_DECREF(bytearray_obj);

  001c9	48 8b cb	 mov	 rcx, rbx
  001cc	83 f8 ff	 cmp	 eax, -1

; 2339 :         return NULL;

  001cf	74 4d		 je	 SHORT $LN32@bytearray_@36

; 2340 :     }
; 2341 :     Py_DECREF(bytearray_obj);

  001d1	e8 00 00 00 00	 call	 _Py_DecRef

; 2342 : 
; 2343 :     Py_RETURN_NONE;

  001d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  001dd	e8 00 00 00 00	 call	 _Py_IncRef
  001e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN31@bytearray_@36:
  001e9	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
  001ee	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  001f3	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]
$LN28@bytearray_@36:
  001f8	4c 8b 6c 24 38	 mov	 r13, QWORD PTR [rsp+56]
  001fd	4c 8b 64 24 78	 mov	 r12, QWORD PTR [rsp+120]

; 2344 : }

  00202	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00206	41 5e		 pop	 r14
  00208	5d		 pop	 rbp
  00209	5b		 pop	 rbx
  0020a	c3		 ret	 0
$LN24@bytearray_@36:

; 2309 :             Py_DECREF(item);

  0020b	48 8b ce	 mov	 rcx, rsi
  0020e	e8 00 00 00 00	 call	 _Py_DecRef
$LN25@bytearray_@36:

; 2310 :             Py_DECREF(it);

  00213	49 8b cc	 mov	 rcx, r12
  00216	e8 00 00 00 00	 call	 _Py_DecRef
$LN33@bytearray_@36:

; 2311 :             Py_DECREF(bytearray_obj);

  0021b	48 8b cb	 mov	 rcx, rbx
$LN32@bytearray_@36:
  0021e	e8 00 00 00 00	 call	 _Py_DecRef

; 2312 :             return NULL;

  00223	33 c0		 xor	 eax, eax
  00225	eb c2		 jmp	 SHORT $LN31@bytearray_@36
bytearray_extend ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@ ; `string'
PUBLIC	??_C@_0BJ@GOKGLLGN@pop?5from?5empty?5bytearray?$AA@ ; `string'
PUBLIC	??_C@_06JHLPABKE@?$HMn?3pop?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_pop DD imagerel bytearray_pop
	DD	imagerel bytearray_pop+150
	DD	imagerel $unwind$bytearray_pop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$bytearray_pop DD imagerel bytearray_pop+150
	DD	imagerel bytearray_pop+202
	DD	imagerel $chain$0$bytearray_pop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$bytearray_pop DD imagerel bytearray_pop+202
	DD	imagerel bytearray_pop+227
	DD	imagerel $chain$2$bytearray_pop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$bytearray_pop DD imagerel bytearray_pop+227
	DD	imagerel bytearray_pop+259
	DD	imagerel $chain$3$bytearray_pop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$bytearray_pop DD 021H
	DD	imagerel bytearray_pop
	DD	imagerel bytearray_pop+150
	DD	imagerel $unwind$bytearray_pop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$bytearray_pop DD 020021H
	DD	076400H
	DD	imagerel bytearray_pop
	DD	imagerel bytearray_pop+150
	DD	imagerel $unwind$bytearray_pop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$bytearray_pop DD 020521H
	DD	076405H
	DD	imagerel bytearray_pop
	DD	imagerel bytearray_pop+150
	DD	imagerel $unwind$bytearray_pop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_pop DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@ DB 'pop index out of r'
	DB	'ange', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GOKGLLGN@pop?5from?5empty?5bytearray?$AA@
CONST	SEGMENT
??_C@_0BJ@GOKGLLGN@pop?5from?5empty?5bytearray?$AA@ DB 'pop from empty by'
	DB	'tearray', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06JHLPABKE@?$HMn?3pop?$AA@
CONST	SEGMENT
??_C@_06JHLPABKE@?$HMn?3pop?$AA@ DB '|n:pop', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_pop
_TEXT	SEGMENT
where$ = 48
self$ = 48
args$ = 56
bytearray_pop PROC					; COMDAT

; 2353 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2354 :     int value;
; 2355 :     Py_ssize_t where = -1, n = Py_SIZE(self);

  0000a	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]
  0000e	48 8b c2	 mov	 rax, rdx
  00011	48 8b d9	 mov	 rbx, rcx

; 2356 : 
; 2357 :     if (!PyArg_ParseTuple(args, "|n:pop", &where))

  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06JHLPABKE@?$HMn?3pop?$AA@
  0001b	4c 8d 44 24 30	 lea	 r8, QWORD PTR where$[rsp]
  00020	48 8b c8	 mov	 rcx, rax
  00023	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR where$[rsp], -1
  0002c	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00031	85 c0		 test	 eax, eax

; 2358 :         return NULL;

  00033	74 18		 je	 SHORT $LN12@bytearray_@37

; 2359 : 
; 2360 :     if (n == 0) {

  00035	48 85 ff	 test	 rdi, rdi
  00038	75 20		 jne	 SHORT $LN6@bytearray_@37

; 2361 :         PyErr_SetString(PyExc_IndexError,
; 2362 :                         "pop from empty bytearray");

  0003a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@GOKGLLGN@pop?5from?5empty?5bytearray?$AA@
  00048	e8 00 00 00 00	 call	 PyErr_SetString
$LN12@bytearray_@37:

; 2363 :         return NULL;

  0004d	33 c0		 xor	 eax, eax

; 2380 : }

  0004f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
$LN6@bytearray_@37:

; 2364 :     }
; 2365 :     if (where < 0)

  0005a	48 8b 44 24 30	 mov	 rax, QWORD PTR where$[rsp]
  0005f	48 85 c0	 test	 rax, rax
  00062	79 0b		 jns	 SHORT $LN10@bytearray_@37

; 2366 :         where += Py_SIZE(self);

  00064	48 03 43 60	 add	 rax, QWORD PTR [rbx+96]
  00068	48 89 44 24 30	 mov	 QWORD PTR where$[rsp], rax

; 2367 :     if (where < 0 || where >= Py_SIZE(self)) {

  0006d	78 74		 js	 SHORT $LN3@bytearray_@37
$LN10@bytearray_@37:
  0006f	48 3b 43 60	 cmp	 rax, QWORD PTR [rbx+96]
  00073	7d 6e		 jge	 SHORT $LN3@bytearray_@37

; 2369 :         return NULL;
; 2370 :     }
; 2371 :     if (!_canresize(self))

  00075	48 8b cb	 mov	 rcx, rbx
  00078	e8 00 00 00 00	 call	 _canresize
  0007d	85 c0		 test	 eax, eax

; 2372 :         return NULL;

  0007f	74 cc		 je	 SHORT $LN12@bytearray_@37

; 2373 : 
; 2374 :     value = self->ob_bytes[where];

  00081	48 8b 54 24 30	 mov	 rdx, QWORD PTR where$[rsp]
  00086	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]

; 2375 :     memmove(self->ob_bytes + where, self->ob_bytes + where + 1, n - where);

  0008d	4c 8b c7	 mov	 r8, rdi
  00090	48 03 ca	 add	 rcx, rdx
  00093	4c 2b c2	 sub	 r8, rdx
  00096	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0009b	0f be 31	 movsx	 esi, BYTE PTR [rcx]
  0009e	48 8d 51 01	 lea	 rdx, QWORD PTR [rcx+1]
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 2376 :     if (PyByteArray_Resize((PyObject *)self, n - 1) < 0)

  000a8	48 8d 57 ff	 lea	 rdx, QWORD PTR [rdi-1]
  000ac	48 8b cb	 mov	 rcx, rbx
  000af	e8 00 00 00 00	 call	 PyByteArray_Resize
  000b4	85 c0		 test	 eax, eax
  000b6	79 12		 jns	 SHORT $LN1@bytearray_@37

; 2377 :         return NULL;

  000b8	33 c0		 xor	 eax, eax
  000ba	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 2380 : }

  000bf	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c8	5f		 pop	 rdi
  000c9	c3		 ret	 0
$LN1@bytearray_@37:

; 2378 : 
; 2379 :     return PyLong_FromLong((unsigned char)value);

  000ca	40 0f b6 ce	 movzx	 ecx, sil
  000ce	e8 00 00 00 00	 call	 PyLong_FromLong
  000d3	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 2380 : }

  000d8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000dd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e1	5f		 pop	 rdi
  000e2	c3		 ret	 0
$LN3@bytearray_@37:

; 2368 :         PyErr_SetString(PyExc_IndexError, "pop index out of range");

  000e3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  000ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@
  000f1	e8 00 00 00 00	 call	 PyErr_SetString

; 2380 : }

  000f6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000fb	33 c0		 xor	 eax, eax
  000fd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00101	5f		 pop	 rdi
  00102	c3		 ret	 0
bytearray_pop ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@JMCHNHHH@value?5not?5found?5in?5bytearray?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytearray_remove DD imagerel bytearray_remove
	DD	imagerel bytearray_remove+50
	DD	imagerel $unwind$bytearray_remove
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$bytearray_remove DD imagerel bytearray_remove+50
	DD	imagerel bytearray_remove+138
	DD	imagerel $chain$0$bytearray_remove
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$bytearray_remove DD imagerel bytearray_remove+138
	DD	imagerel bytearray_remove+284
	DD	imagerel $chain$2$bytearray_remove
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$bytearray_remove DD 020021H
	DD	093400H
	DD	imagerel bytearray_remove
	DD	imagerel bytearray_remove+50
	DD	imagerel $unwind$bytearray_remove
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$bytearray_remove DD 020521H
	DD	093405H
	DD	imagerel bytearray_remove
	DD	imagerel bytearray_remove+50
	DD	imagerel $unwind$bytearray_remove
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_remove DD 040a01H
	DD	0a640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0BN@JMCHNHHH@value?5not?5found?5in?5bytearray?$AA@
CONST	SEGMENT
??_C@_0BN@JMCHNHHH@value?5not?5found?5in?5bytearray?$AA@ DB 'value not fo'
	DB	'und in bytearray', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
CONST	ENDS
;	COMDAT bytearray_remove
_TEXT	SEGMENT
value$ = 64
self$ = 64
arg$ = 72
bytearray_remove PROC					; COMDAT

; 2388 : {

  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2389 :     int value;
; 2390 :     Py_ssize_t where, n = Py_SIZE(self);

  0000a	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]
  0000e	48 8b c2	 mov	 rax, rdx
  00011	48 8b f1	 mov	 rsi, rcx

; 2391 : 
; 2392 :     if (! _getbytevalue(arg, &value))

  00014	48 8d 54 24 40	 lea	 rdx, QWORD PTR value$[rsp]
  00019	48 8b c8	 mov	 rcx, rax
  0001c	e8 00 00 00 00	 call	 _getbytevalue
  00021	85 c0		 test	 eax, eax
  00023	75 0d		 jne	 SHORT $LN8@bytearray_@38

; 2393 :         return NULL;

  00025	33 c0		 xor	 eax, eax

; 2411 : }

  00027	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0002c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN8@bytearray_@38:
  00032	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx

; 2394 : 
; 2395 :     for (where = 0; where < n; where++) {

  00037	33 db		 xor	 ebx, ebx
  00039	48 85 ff	 test	 rdi, rdi
  0003c	7e 22		 jle	 SHORT $LN18@bytearray_@38
  0003e	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  00045	8b 54 24 40	 mov	 edx, DWORD PTR value$[rsp]
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@bytearray_@38:

; 2396 :         if (self->ob_bytes[where] == value)

  00050	0f be 04 19	 movsx	 eax, BYTE PTR [rcx+rbx]
  00054	3b c2		 cmp	 eax, edx
  00056	74 08		 je	 SHORT $LN18@bytearray_@38

; 2394 : 
; 2395 :     for (where = 0; where < n; where++) {

  00058	48 ff c3	 inc	 rbx
  0005b	48 3b df	 cmp	 rbx, rdi
  0005e	7c f0		 jl	 SHORT $LL7@bytearray_@38
$LN18@bytearray_@38:

; 2397 :             break;
; 2398 :     }
; 2399 :     if (where == n) {

  00060	48 3b df	 cmp	 rbx, rdi
  00063	75 25		 jne	 SHORT $LN3@bytearray_@38

; 2400 :         PyErr_SetString(PyExc_ValueError, "value not found in bytearray");

  00065	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@JMCHNHHH@value?5not?5found?5in?5bytearray?$AA@
  00073	e8 00 00 00 00	 call	 PyErr_SetString
$LN20@bytearray_@38:

; 2401 :         return NULL;

  00078	33 c0		 xor	 eax, eax
  0007a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]

; 2411 : }

  0007f	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00084	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00088	5f		 pop	 rdi
  00089	c3		 ret	 0
$LN3@bytearray_@38:

; 2402 :     }
; 2403 :     if (!_canresize(self))

  0008a	48 8b ce	 mov	 rcx, rsi
  0008d	e8 00 00 00 00	 call	 _canresize
  00092	85 c0		 test	 eax, eax

; 2404 :         return NULL;

  00094	74 e2		 je	 SHORT $LN20@bytearray_@38

; 2405 : 
; 2406 :     memmove(self->ob_bytes + where, self->ob_bytes + where + 1, n - where);

  00096	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  0009d	4c 8b c7	 mov	 r8, rdi
  000a0	48 03 cb	 add	 rcx, rbx
  000a3	4c 2b c3	 sub	 r8, rbx
  000a6	48 8d 51 01	 lea	 rdx, QWORD PTR [rcx+1]
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 2407 :     if (PyByteArray_Resize((PyObject *)self, n - 1) < 0)

  000b0	48 8d 57 ff	 lea	 rdx, QWORD PTR [rdi-1]
  000b4	48 8b ce	 mov	 rcx, rsi
  000b7	e8 00 00 00 00	 call	 PyByteArray_Resize
  000bc	85 c0		 test	 eax, eax

; 2408 :         return NULL;

  000be	78 b8		 js	 SHORT $LN20@bytearray_@38

; 2409 : 
; 2410 :     Py_RETURN_NONE;

  000c0	e8 00 00 00 00	 call	 _Py_PXCTX
  000c5	85 c0		 test	 eax, eax
  000c7	75 3c		 jne	 SHORT $LN12@bytearray_@38
  000c9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000de	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000e4	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000ec	e8 00 00 00 00	 call	 _PyParallel_Guard
  000f1	85 c0		 test	 eax, eax
  000f3	75 09		 jne	 SHORT $LN11@bytearray_@38
  000f5	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000fc	74 07		 je	 SHORT $LN12@bytearray_@38
$LN11@bytearray_@38:
  000fe	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN12@bytearray_@38:

; 2411 : }

  00105	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0010a	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0010f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00116	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011a	5f		 pop	 rdi
  0011b	c3		 ret	 0
bytearray_remove ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lstrip_helper DD imagerel lstrip_helper
	DD	imagerel lstrip_helper+108
	DD	imagerel $unwind$lstrip_helper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lstrip_helper DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT lstrip_helper
_TEXT	SEGMENT
myptr$ = 48
mysize$ = 56
argptr$ = 64
argsize$ = 72
lstrip_helper PROC					; COMDAT

; 2418 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2419 :     Py_ssize_t i = 0;

  0001a	33 db		 xor	 ebx, ebx
  0001c	49 8b f1	 mov	 rsi, r9
  0001f	49 8b e8	 mov	 rbp, r8
  00022	48 8b fa	 mov	 rdi, rdx
  00025	4c 8b e1	 mov	 r12, rcx

; 2420 :     while (i < mysize && memchr(argptr, myptr[i], argsize))

  00028	48 85 d2	 test	 rdx, rdx
  0002b	7e 21		 jle	 SHORT $LN7@lstrip_hel
  0002d	0f 1f 00	 npad	 3
$LL2@lstrip_hel:
  00030	42 0f b6 14 23	 movzx	 edx, BYTE PTR [rbx+r12]
  00035	4c 8b c6	 mov	 r8, rsi
  00038	48 8b cd	 mov	 rcx, rbp
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00041	48 85 c0	 test	 rax, rax
  00044	74 08		 je	 SHORT $LN7@lstrip_hel

; 2421 :         i++;

  00046	48 ff c3	 inc	 rbx
  00049	48 3b df	 cmp	 rbx, rdi
  0004c	7c e2		 jl	 SHORT $LL2@lstrip_hel
$LN7@lstrip_hel:

; 2422 :     return i;
; 2423 : }

  0004e	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00053	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00058	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0005d	48 8b c3	 mov	 rax, rbx
  00060	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	41 5c		 pop	 r12
  0006b	c3		 ret	 0
lstrip_helper ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rstrip_helper DD imagerel rstrip_helper
	DD	imagerel rstrip_helper+99
	DD	imagerel $unwind$rstrip_helper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rstrip_helper DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT rstrip_helper
_TEXT	SEGMENT
myptr$ = 48
mysize$ = 56
argptr$ = 64
argsize$ = 72
rstrip_helper PROC					; COMDAT

; 2428 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2429 :     Py_ssize_t i = mysize - 1;

  00014	48 8d 5a ff	 lea	 rbx, QWORD PTR [rdx-1]
  00018	49 8b f9	 mov	 rdi, r9
  0001b	49 8b f0	 mov	 rsi, r8
  0001e	48 8b e9	 mov	 rbp, rcx

; 2430 :     while (i >= 0 && memchr(argptr, myptr[i], argsize))

  00021	48 85 db	 test	 rbx, rbx
  00024	78 24		 js	 SHORT $LN7@rstrip_hel
  00026	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL2@rstrip_hel:
  00030	0f b6 14 2b	 movzx	 edx, BYTE PTR [rbx+rbp]
  00034	4c 8b c7	 mov	 r8, rdi
  00037	48 8b ce	 mov	 rcx, rsi
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00040	48 85 c0	 test	 rax, rax
  00043	74 05		 je	 SHORT $LN7@rstrip_hel

; 2431 :         i--;

  00045	48 ff cb	 dec	 rbx

; 2430 :     while (i >= 0 && memchr(argptr, myptr[i], argsize))

  00048	79 e6		 jns	 SHORT $LL2@rstrip_hel
$LN7@rstrip_hel:

; 2432 :     return i + 1;
; 2433 : }

  0004a	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0004f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00054	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
  00058	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
rstrip_helper ENDP
_TEXT	ENDS
PUBLIC	??_C@_06HNAHPGHO@?7?6?$AN?$AM?$AL?5?$AA@	; `string'
PUBLIC	??_C@_08NLCECJOD@?$HMO?3strip?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_strip DD imagerel bytearray_strip
	DD	imagerel bytearray_strip+141
	DD	imagerel $unwind$bytearray_strip
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$bytearray_strip DD imagerel bytearray_strip+141
	DD	imagerel bytearray_strip+149
	DD	imagerel $chain$2$bytearray_strip
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$bytearray_strip DD imagerel bytearray_strip+149
	DD	imagerel bytearray_strip+235
	DD	imagerel $chain$4$bytearray_strip
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$bytearray_strip DD imagerel bytearray_strip+235
	DD	imagerel bytearray_strip+274
	DD	imagerel $chain$5$bytearray_strip
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$bytearray_strip DD imagerel bytearray_strip+274
	DD	imagerel bytearray_strip+301
	DD	imagerel $chain$6$bytearray_strip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$bytearray_strip DD 021H
	DD	imagerel bytearray_strip
	DD	imagerel bytearray_strip+141
	DD	imagerel $unwind$bytearray_strip
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$bytearray_strip DD 021H
	DD	imagerel bytearray_strip+141
	DD	imagerel bytearray_strip+149
	DD	imagerel $chain$2$bytearray_strip
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$bytearray_strip DD 040e21H
	DD	0ed40eH
	DD	0fc405H
	DD	imagerel bytearray_strip+141
	DD	imagerel bytearray_strip+149
	DD	imagerel $chain$2$bytearray_strip
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$bytearray_strip DD 020821H
	DD	0156408H
	DD	imagerel bytearray_strip
	DD	imagerel bytearray_strip+141
	DD	imagerel $unwind$bytearray_strip
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_strip DD 085a01H
	DD	010745aH
	DD	0143452H
	DD	011010dH
	DD	05004e006H
xdata	ENDS
;	COMDAT ??_C@_06HNAHPGHO@?7?6?$AN?$AM?$AL?5?$AA@
CONST	SEGMENT
??_C@_06HNAHPGHO@?7?6?$AN?$AM?$AL?5?$AA@ DB 09H, 0aH, 0dH, 0cH, 0bH, ' ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NLCECJOD@?$HMO?3strip?$AA@
CONST	SEGMENT
??_C@_08NLCECJOD@?$HMO?3strip?$AA@ DB '|O:strip', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_strip
_TEXT	SEGMENT
varg$ = 32
self$ = 160
args$ = 168
arg$ = 176
bytearray_strip PROC					; COMDAT

; 2443 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	55		 push	 rbp
  00004	41 56		 push	 r14
  00006	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0000d	48 8b c2	 mov	 rax, rdx
  00010	48 8b e9	 mov	 rbp, rcx

; 2444 :     Py_ssize_t left, right, mysize, argsize;
; 2445 :     void *myptr, *argptr;
; 2446 :     PyObject *arg = Py_None;

  00013	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:_Py_NoneStruct

; 2447 :     Py_buffer varg;
; 2448 :     if (!PyArg_ParseTuple(args, "|O:strip", &arg))

  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08NLCECJOD@?$HMO?3strip?$AA@
  00021	4d 8d 43 18	 lea	 r8, QWORD PTR [r11+24]
  00025	48 8b c8	 mov	 rcx, rax
  00028	4d 89 73 18	 mov	 QWORD PTR [r11+24], r14
  0002c	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00031	85 c0		 test	 eax, eax
  00033	75 0d		 jne	 SHORT $LN7@bytearray_@39

; 2449 :         return NULL;

  00035	33 c0		 xor	 eax, eax

; 2470 : }

  00037	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0003e	41 5e		 pop	 r14
  00040	5d		 pop	 rbp
  00041	c3		 ret	 0
$LN7@bytearray_@39:

; 2450 :     if (arg == Py_None) {

  00042	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  0004a	48 89 9c 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rbx
  00052	48 89 bc 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rdi
  0005a	49 3b ce	 cmp	 rcx, r14
  0005d	75 0e		 jne	 SHORT $LN6@bytearray_@39

; 2451 :         argptr = "\t\n\r\f\v ";

  0005f	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:??_C@_06HNAHPGHO@?7?6?$AN?$AM?$AL?5?$AA@

; 2452 :         argsize = 6;

  00066	bf 06 00 00 00	 mov	 edi, 6

; 2453 :     }
; 2454 :     else {

  0006b	eb 20		 jmp	 SHORT $LN5@bytearray_@39
$LN6@bytearray_@39:

; 2455 :         if (_getbuffer(arg, &varg) < 0)

  0006d	48 8d 54 24 20	 lea	 rdx, QWORD PTR varg$[rsp]
  00072	e8 00 00 00 00	 call	 _getbuffer
  00077	48 85 c0	 test	 rax, rax
  0007a	79 07		 jns	 SHORT $LN4@bytearray_@39

; 2456 :             return NULL;

  0007c	33 c0		 xor	 eax, eax
  0007e	e9 8f 00 00 00	 jmp	 $LN11@bytearray_@39
$LN4@bytearray_@39:

; 2457 :         argptr = varg.buf;

  00083	48 8b 5c 24 20	 mov	 rbx, QWORD PTR varg$[rsp]

; 2458 :         argsize = varg.len;

  00088	48 8b 7c 24 30	 mov	 rdi, QWORD PTR varg$[rsp+16]
$LN5@bytearray_@39:

; 2459 :     }
; 2460 :     myptr = self->ob_bytes;
; 2461 :     mysize = Py_SIZE(self);

  0008d	48 89 b4 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rsi
  00095	4c 89 64 24 78	 mov	 QWORD PTR [rsp+120], r12
  0009a	4c 8b 65 60	 mov	 r12, QWORD PTR [rbp+96]
  0009e	4c 89 6c 24 70	 mov	 QWORD PTR [rsp+112], r13
  000a3	4c 8b ad 80 00
	00 00		 mov	 r13, QWORD PTR [rbp+128]

; 2462 :     left = lstrip_helper(myptr, mysize, argptr, argsize);

  000aa	4c 8b cf	 mov	 r9, rdi
  000ad	4c 8b c3	 mov	 r8, rbx
  000b0	49 8b d4	 mov	 rdx, r12
  000b3	49 8b cd	 mov	 rcx, r13
  000b6	e8 00 00 00 00	 call	 lstrip_helper
  000bb	48 8b f0	 mov	 rsi, rax

; 2463 :     if (left == mysize)

  000be	49 3b c4	 cmp	 rax, r12

; 2464 :         right = left;
; 2465 :     else

  000c1	74 11		 je	 SHORT $LN12@bytearray_@39

; 2466 :         right = rstrip_helper(myptr, mysize, argptr, argsize);

  000c3	4c 8b cf	 mov	 r9, rdi
  000c6	4c 8b c3	 mov	 r8, rbx
  000c9	49 8b d4	 mov	 rdx, r12
  000cc	49 8b cd	 mov	 rcx, r13
  000cf	e8 00 00 00 00	 call	 rstrip_helper
$LN12@bytearray_@39:
  000d4	4c 8b 6c 24 70	 mov	 r13, QWORD PTR [rsp+112]
  000d9	4c 8b 64 24 78	 mov	 r12, QWORD PTR [rsp+120]
  000de	48 8b d8	 mov	 rbx, rax

; 2467 :     if (arg != Py_None)

  000e1	4c 39 b4 24 b0
	00 00 00	 cmp	 QWORD PTR arg$[rsp], r14
  000e9	74 0a		 je	 SHORT $LN1@bytearray_@39

; 2468 :         PyBuffer_Release(&varg);

  000eb	48 8d 4c 24 20	 lea	 rcx, QWORD PTR varg$[rsp]
  000f0	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@bytearray_@39:

; 2469 :     return PyByteArray_FromStringAndSize(self->ob_bytes + left, right - left);

  000f5	48 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR [rbp+128]
  000fc	48 2b de	 sub	 rbx, rsi
  000ff	48 03 ce	 add	 rcx, rsi
  00102	48 8b d3	 mov	 rdx, rbx
  00105	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  0010a	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+168]
$LN11@bytearray_@39:
  00112	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]
  0011a	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR [rsp+128]

; 2470 : }

  00122	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00129	41 5e		 pop	 r14
  0012b	5d		 pop	 rbp
  0012c	c3		 ret	 0
bytearray_strip ENDP
_TEXT	ENDS
PUBLIC	??_C@_09IBNLIPED@?$HMO?3lstrip?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_lstrip DD imagerel bytearray_lstrip
	DD	imagerel bytearray_lstrip+230
	DD	imagerel $unwind$bytearray_lstrip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_lstrip DD 089701H
	DD	0117497H
	DD	0103488H
	DD	013540cH
	DD	06008d20cH
xdata	ENDS
;	COMDAT ??_C@_09IBNLIPED@?$HMO?3lstrip?$AA@
CONST	SEGMENT
??_C@_09IBNLIPED@?$HMO?3lstrip?$AA@ DB '|O:lstrip', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_lstrip
_TEXT	SEGMENT
varg$ = 32
self$ = 128
args$ = 136
arg$ = 144
bytearray_lstrip PROC					; COMDAT

; 2480 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 6b 20	 mov	 QWORD PTR [r11+32], rbp
  00007	56		 push	 rsi
  00008	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000c	48 8b c2	 mov	 rax, rdx
  0000f	48 8b f1	 mov	 rsi, rcx

; 2481 :     Py_ssize_t left, right, mysize, argsize;
; 2482 :     void *myptr, *argptr;
; 2483 :     PyObject *arg = Py_None;

  00012	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:_Py_NoneStruct

; 2484 :     Py_buffer varg;
; 2485 :     if (!PyArg_ParseTuple(args, "|O:lstrip", &arg))

  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09IBNLIPED@?$HMO?3lstrip?$AA@
  00020	4d 8d 43 18	 lea	 r8, QWORD PTR [r11+24]
  00024	48 8b c8	 mov	 rcx, rax
  00027	49 89 6b 18	 mov	 QWORD PTR [r11+24], rbp
  0002b	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00030	85 c0		 test	 eax, eax
  00032	75 10		 jne	 SHORT $LN5@bytearray_@40
$LN8@bytearray_@40:

; 2486 :         return NULL;

  00034	33 c0		 xor	 eax, eax

; 2504 : }

  00036	48 8b ac 24 98
	00 00 00	 mov	 rbp, QWORD PTR [rsp+152]
  0003e	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00042	5e		 pop	 rsi
  00043	c3		 ret	 0
$LN5@bytearray_@40:

; 2487 :     if (arg == Py_None) {

  00044	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  0004c	48 3b cd	 cmp	 rcx, rbp
  0004f	75 0f		 jne	 SHORT $LN4@bytearray_@40

; 2488 :         argptr = "\t\n\r\f\v ";

  00051	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06HNAHPGHO@?7?6?$AN?$AM?$AL?5?$AA@

; 2489 :         argsize = 6;

  00058	41 b9 06 00 00
	00		 mov	 r9d, 6

; 2490 :     }
; 2491 :     else {

  0005e	eb 19		 jmp	 SHORT $LN3@bytearray_@40
$LN4@bytearray_@40:

; 2492 :         if (_getbuffer(arg, &varg) < 0)

  00060	48 8d 54 24 20	 lea	 rdx, QWORD PTR varg$[rsp]
  00065	e8 00 00 00 00	 call	 _getbuffer
  0006a	48 85 c0	 test	 rax, rax

; 2493 :             return NULL;

  0006d	78 c5		 js	 SHORT $LN8@bytearray_@40

; 2494 :         argptr = varg.buf;

  0006f	4c 8b 44 24 20	 mov	 r8, QWORD PTR varg$[rsp]

; 2495 :         argsize = varg.len;

  00074	4c 8b 4c 24 30	 mov	 r9, QWORD PTR varg$[rsp+16]
$LN3@bytearray_@40:

; 2496 :     }
; 2497 :     myptr = self->ob_bytes;
; 2498 :     mysize = Py_SIZE(self);
; 2499 :     left = lstrip_helper(myptr, mysize, argptr, argsize);

  00079	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  00080	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbx
  00088	48 8b 5e 60	 mov	 rbx, QWORD PTR [rsi+96]
  0008c	48 8b d3	 mov	 rdx, rbx
  0008f	48 89 bc 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rdi
  00097	e8 00 00 00 00	 call	 lstrip_helper
  0009c	48 8b f8	 mov	 rdi, rax

; 2500 :     right = mysize;
; 2501 :     if (arg != Py_None)

  0009f	48 39 ac 24 90
	00 00 00	 cmp	 QWORD PTR arg$[rsp], rbp
  000a7	74 0a		 je	 SHORT $LN1@bytearray_@40

; 2502 :         PyBuffer_Release(&varg);

  000a9	48 8d 4c 24 20	 lea	 rcx, QWORD PTR varg$[rsp]
  000ae	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@bytearray_@40:

; 2503 :     return PyByteArray_FromStringAndSize(self->ob_bytes + left, right - left);

  000b3	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  000ba	48 2b df	 sub	 rbx, rdi
  000bd	48 03 cf	 add	 rcx, rdi
  000c0	48 8b d3	 mov	 rdx, rbx
  000c3	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000c8	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR [rsp+136]
  000d0	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]

; 2504 : }

  000d8	48 8b ac 24 98
	00 00 00	 mov	 rbp, QWORD PTR [rsp+152]
  000e0	48 83 c4 70	 add	 rsp, 112		; 00000070H
  000e4	5e		 pop	 rsi
  000e5	c3		 ret	 0
bytearray_lstrip ENDP
_TEXT	ENDS
PUBLIC	??_C@_09LGDKGINA@?$HMO?3rstrip?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_rstrip DD imagerel bytearray_rstrip
	DD	imagerel bytearray_rstrip+205
	DD	imagerel $unwind$bytearray_rstrip
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_rstrip DD 068c01H
	DD	010748cH
	DD	011340cH
	DD	06008d20cH
xdata	ENDS
;	COMDAT ??_C@_09LGDKGINA@?$HMO?3rstrip?$AA@
CONST	SEGMENT
??_C@_09LGDKGINA@?$HMO?3rstrip?$AA@ DB '|O:rstrip', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_rstrip
_TEXT	SEGMENT
varg$ = 32
self$ = 128
args$ = 136
arg$ = 144
bytearray_rstrip PROC					; COMDAT

; 2514 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00007	56		 push	 rsi
  00008	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000c	48 8b c2	 mov	 rax, rdx
  0000f	48 8b d9	 mov	 rbx, rcx

; 2515 :     Py_ssize_t right, mysize, argsize;
; 2516 :     void *myptr, *argptr;
; 2517 :     PyObject *arg = Py_None;

  00012	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct

; 2518 :     Py_buffer varg;
; 2519 :     if (!PyArg_ParseTuple(args, "|O:rstrip", &arg))

  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09LGDKGINA@?$HMO?3rstrip?$AA@
  00020	4d 8d 43 18	 lea	 r8, QWORD PTR [r11+24]
  00024	48 8b c8	 mov	 rcx, rax
  00027	49 89 73 18	 mov	 QWORD PTR [r11+24], rsi
  0002b	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00030	85 c0		 test	 eax, eax
  00032	75 10		 jne	 SHORT $LN5@bytearray_@41
$LN8@bytearray_@41:

; 2520 :         return NULL;

  00034	33 c0		 xor	 eax, eax

; 2537 : }

  00036	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR [rsp+136]
  0003e	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00042	5e		 pop	 rsi
  00043	c3		 ret	 0
$LN5@bytearray_@41:

; 2521 :     if (arg == Py_None) {

  00044	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  0004c	48 3b ce	 cmp	 rcx, rsi
  0004f	75 0f		 jne	 SHORT $LN4@bytearray_@41

; 2522 :         argptr = "\t\n\r\f\v ";

  00051	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06HNAHPGHO@?7?6?$AN?$AM?$AL?5?$AA@

; 2523 :         argsize = 6;

  00058	41 b9 06 00 00
	00		 mov	 r9d, 6

; 2524 :     }
; 2525 :     else {

  0005e	eb 19		 jmp	 SHORT $LN3@bytearray_@41
$LN4@bytearray_@41:

; 2526 :         if (_getbuffer(arg, &varg) < 0)

  00060	48 8d 54 24 20	 lea	 rdx, QWORD PTR varg$[rsp]
  00065	e8 00 00 00 00	 call	 _getbuffer
  0006a	48 85 c0	 test	 rax, rax

; 2527 :             return NULL;

  0006d	78 c5		 js	 SHORT $LN8@bytearray_@41

; 2528 :         argptr = varg.buf;

  0006f	4c 8b 44 24 20	 mov	 r8, QWORD PTR varg$[rsp]

; 2529 :         argsize = varg.len;

  00074	4c 8b 4c 24 30	 mov	 r9, QWORD PTR varg$[rsp+16]
$LN3@bytearray_@41:

; 2530 :     }
; 2531 :     myptr = self->ob_bytes;
; 2532 :     mysize = Py_SIZE(self);
; 2533 :     right = rstrip_helper(myptr, mysize, argptr, argsize);

  00079	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  0007d	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00084	48 89 bc 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rdi
  0008c	e8 00 00 00 00	 call	 rstrip_helper
  00091	48 8b f8	 mov	 rdi, rax

; 2534 :     if (arg != Py_None)

  00094	48 39 b4 24 90
	00 00 00	 cmp	 QWORD PTR arg$[rsp], rsi
  0009c	74 0a		 je	 SHORT $LN1@bytearray_@41

; 2535 :         PyBuffer_Release(&varg);

  0009e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR varg$[rsp]
  000a3	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@bytearray_@41:

; 2536 :     return PyByteArray_FromStringAndSize(self->ob_bytes, right);

  000a8	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  000af	48 8b d7	 mov	 rdx, rdi
  000b2	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000b7	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR [rsp+128]

; 2537 : }

  000bf	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR [rsp+136]
  000c7	48 83 c4 70	 add	 rsp, 112		; 00000070H
  000cb	5e		 pop	 rsi
  000cc	c3		 ret	 0
bytearray_rstrip ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@GNFOOANA@?$HMss?3decode?$AA@		; `string'
EXTRN	PyUnicode_FromEncodedObject:PROC
EXTRN	PyUnicode_GetDefaultEncoding:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_decode DD imagerel bytearray_decode
	DD	imagerel bytearray_decode+126
	DD	imagerel $unwind$bytearray_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_decode DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT ??_C@_0L@GNFOOANA@?$HMss?3decode?$AA@
CONST	SEGMENT
??_C@_0L@GNFOOANA@?$HMss?3decode?$AA@ DB '|ss:decode', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_decode
_TEXT	SEGMENT
errors$ = 48
self$ = 80
args$ = 88
kwargs$ = 96
encoding$ = 104
bytearray_decode PROC					; COMDAT

; 2551 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8b d9	 mov	 rbx, rcx

; 2552 :     const char *encoding = NULL;

  00009	33 c9		 xor	 ecx, ecx
  0000b	49 8b c0	 mov	 rax, r8
  0000e	48 89 4c 24 68	 mov	 QWORD PTR encoding$[rsp], rcx

; 2553 :     const char *errors = NULL;

  00013	48 89 4c 24 30	 mov	 QWORD PTR errors$[rsp], rcx
  00018	4c 8b d2	 mov	 r10, rdx

; 2554 :     static char *kwlist[] = {"encoding", "errors", 0};
; 2555 : 
; 2556 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|ss:decode", kwlist, &encoding, &errors))

  0001b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR errors$[rsp]
  00020	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??bytearray_decode@@9@9
  00027	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@GNFOOANA@?$HMss?3decode?$AA@
  0002e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00033	48 8d 4c 24 68	 lea	 rcx, QWORD PTR encoding$[rsp]
  00038	48 8b d0	 mov	 rdx, rax
  0003b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00040	49 8b ca	 mov	 rcx, r10
  00043	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00048	85 c0		 test	 eax, eax
  0004a	75 08		 jne	 SHORT $LN2@bytearray_@42

; 2557 :         return NULL;

  0004c	33 c0		 xor	 eax, eax

; 2561 : }

  0004e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00052	5b		 pop	 rbx
  00053	c3		 ret	 0
$LN2@bytearray_@42:

; 2558 :     if (encoding == NULL)

  00054	48 8b 44 24 68	 mov	 rax, QWORD PTR encoding$[rsp]
  00059	48 85 c0	 test	 rax, rax
  0005c	75 0a		 jne	 SHORT $LN1@bytearray_@42

; 2559 :         encoding = PyUnicode_GetDefaultEncoding();

  0005e	e8 00 00 00 00	 call	 PyUnicode_GetDefaultEncoding
  00063	48 89 44 24 68	 mov	 QWORD PTR encoding$[rsp], rax
$LN1@bytearray_@42:

; 2560 :     return PyUnicode_FromEncodedObject(self, encoding, errors);

  00068	4c 8b 44 24 30	 mov	 r8, QWORD PTR errors$[rsp]
  0006d	48 8b d0	 mov	 rdx, rax
  00070	48 8b cb	 mov	 rcx, rbx
  00073	e8 00 00 00 00	 call	 PyUnicode_FromEncodedObject

; 2561 : }

  00078	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0007c	5b		 pop	 rbx
  0007d	c3		 ret	 0
bytearray_decode ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bytearray_alloc
_TEXT	SEGMENT
self$ = 8
bytearray_alloc PROC					; COMDAT

; 2571 :     return PyLong_FromSsize_t(self->ob_alloc);

  00000	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]

; 2572 : }

  00004	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
bytearray_alloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EA@LOOJBHHN@can?5only?5join?5an?5iterable?5of?5byt@ ; `string'
PUBLIC	??_C@_0BK@DFNCEILI@can?5only?5join?5an?5iterable?$AA@ ; `string'
EXTRN	PySequence_Fast:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytearray_join DD imagerel bytearray_join
	DD	imagerel bytearray_join+748
	DD	imagerel $unwind$bytearray_join
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_join DD 0d8a01H
	DD	09d48aH
	DD	011547aH
	DD	08e454H
	DD	0a744fH
	DD	0f00ba20fH
	DD	06007c009H
	DD	03006H
xdata	ENDS
;	COMDAT ??_C@_0EA@LOOJBHHN@can?5only?5join?5an?5iterable?5of?5byt@
CONST	SEGMENT
??_C@_0EA@LOOJBHHN@can?5only?5join?5an?5iterable?5of?5byt@ DB 'can only j'
	DB	'oin an iterable of bytes (item %ld has type ''%.100s'')', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DFNCEILI@can?5only?5join?5an?5iterable?$AA@
CONST	SEGMENT
??_C@_0BK@DFNCEILI@can?5only?5join?5an?5iterable?$AA@ DB 'can only join a'
	DB	'n iterable', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
CONST	ENDS
;	COMDAT bytearray_join
_TEXT	SEGMENT
result$1$ = 48
self$ = 128
it$ = 136
items$1$ = 144
seq$1$ = 152
bytearray_join PROC					; COMDAT

; 2582 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	56		 push	 rsi
  00007	41 54		 push	 r12
  00009	41 57		 push	 r15
  0000b	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2583 :     PyObject *seq;
; 2584 :     Py_ssize_t mysize = Py_SIZE(self);

  0000f	4c 8b 79 60	 mov	 r15, QWORD PTR [rcx+96]
  00013	48 8b c2	 mov	 rax, rdx

; 2585 :     Py_ssize_t i;
; 2586 :     Py_ssize_t n;
; 2587 :     PyObject **items;
; 2588 :     Py_ssize_t totalsize = 0;
; 2589 :     PyObject *result;
; 2590 :     char *dest;
; 2591 : 
; 2592 :     seq = PySequence_Fast(it, "can only join an iterable");

  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@DFNCEILI@can?5only?5join?5an?5iterable?$AA@
  0001d	45 33 e4	 xor	 r12d, r12d
  00020	48 8b c8	 mov	 rcx, rax
  00023	41 8b f4	 mov	 esi, r12d
  00026	e8 00 00 00 00	 call	 PySequence_Fast
  0002b	48 8b d8	 mov	 rbx, rax
  0002e	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR seq$1$[rsp], rax

; 2593 :     if (seq == NULL)

  00036	48 85 c0	 test	 rax, rax
  00039	75 0b		 jne	 SHORT $LN15@bytearray_@43

; 2648 : }

  0003b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0003f	41 5f		 pop	 r15
  00041	41 5c		 pop	 r12
  00043	5e		 pop	 rsi
  00044	5b		 pop	 rbx
  00045	c3		 ret	 0
$LN15@bytearray_@43:

; 2594 :         return NULL;
; 2595 :     n = PySequence_Fast_GET_SIZE(seq);

  00046	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0004a	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0004f	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  00054	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  0005a	4c 8b 73 60	 mov	 r14, QWORD PTR [rbx+96]
  0005e	81 e1 00 00 00
	02		 and	 ecx, 33554432		; 02000000H

; 2596 :     items = PySequence_Fast_ITEMS(seq);

  00064	85 c9		 test	 ecx, ecx
  00066	74 06		 je	 SHORT $LN20@bytearray_@43
  00068	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  0006c	eb 04		 jmp	 SHORT $LN61@bytearray_@43
$LN20@bytearray_@43:
  0006e	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
$LN61@bytearray_@43:
  00072	48 89 ac 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbp
  0007a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR items$1$[rsp], rax

; 2597 : 
; 2598 :     /* Compute the total size, and check that they are all bytes */
; 2599 :     /* XXX Shouldn't we use _getbuffer() on these items instead? */
; 2600 :     for (i = 0; i < n; i++) {

  00082	49 8b fc	 mov	 rdi, r12
  00085	4c 89 6c 24 48	 mov	 QWORD PTR [rsp+72], r13
  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00091	4d 85 f6	 test	 r14, r14
  00094	7e 5d		 jle	 SHORT $LN12@bytearray_@43
  00096	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL14@bytearray_@43:

; 2601 :         PyObject *obj = items[i];

  000a0	48 8b 2c f8	 mov	 rbp, QWORD PTR [rax+rdi*8]

; 2602 :         if (!PyByteArray_Check(obj) && !PyBytes_Check(obj)) {

  000a4	48 8b 4d 58	 mov	 rcx, QWORD PTR [rbp+88]
  000a8	48 3b ca	 cmp	 rcx, rdx
  000ab	74 2c		 je	 SHORT $LN11@bytearray_@43
  000ad	e8 00 00 00 00	 call	 PyType_IsSubtype
  000b2	85 c0		 test	 eax, eax
  000b4	75 14		 jne	 SHORT $LN56@bytearray_@43
  000b6	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  000ba	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  000c4	0f 84 9e 00 00
	00		 je	 $LN50@bytearray_@43
$LN56@bytearray_@43:

; 2596 :     items = PySequence_Fast_ITEMS(seq);

  000ca	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR items$1$[rsp]
  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
$LN11@bytearray_@43:

; 2609 :         }
; 2610 :         if (i > 0)

  000d9	48 85 ff	 test	 rdi, rdi
  000dc	7e 03		 jle	 SHORT $LN10@bytearray_@43

; 2611 :             totalsize += mysize;

  000de	49 03 f7	 add	 rsi, r15
$LN10@bytearray_@43:

; 2612 :         totalsize += Py_SIZE(obj);

  000e1	48 03 75 60	 add	 rsi, QWORD PTR [rbp+96]

; 2613 :         if (totalsize < 0) {

  000e5	0f 88 99 00 00
	00		 js	 $LN51@bytearray_@43

; 2597 : 
; 2598 :     /* Compute the total size, and check that they are all bytes */
; 2599 :     /* XXX Shouldn't we use _getbuffer() on these items instead? */
; 2600 :     for (i = 0; i < n; i++) {

  000eb	48 ff c7	 inc	 rdi
  000ee	49 3b fe	 cmp	 rdi, r14
  000f1	7c ad		 jl	 SHORT $LL14@bytearray_@43
$LN12@bytearray_@43:

; 2616 :         }
; 2617 :     }
; 2618 : 
; 2619 :     /* Allocate the result, and copy the bytes */
; 2620 :     result = PyByteArray_FromStringAndSize(NULL, totalsize);

  000f3	48 8b d6	 mov	 rdx, rsi
  000f6	33 c9		 xor	 ecx, ecx
  000f8	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000fd	4c 8b e8	 mov	 r13, rax
  00100	48 89 44 24 30	 mov	 QWORD PTR result$1$[rsp], rax

; 2621 :     if (result == NULL)

  00105	48 85 c0	 test	 rax, rax
  00108	0f 85 9d 00 00
	00		 jne	 $LN8@bytearray_@43
$error$23660:

; 2643 : 
; 2644 :     /* Error handling */
; 2645 :   error:
; 2646 :     Py_DECREF(seq);

  0010e	e8 00 00 00 00	 call	 _Py_PXCTX
  00113	85 c0		 test	 eax, eax
  00115	0f 85 89 00 00
	00		 jne	 $LN47@bytearray_@43
  0011b	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0011f	a8 20		 test	 al, 32			; 00000020H
  00121	75 79		 jne	 SHORT $LN41@bytearray_@43
  00123	84 c0		 test	 al, al
  00125	78 75		 js	 SHORT $LN41@bytearray_@43
  00127	a8 02		 test	 al, 2
  00129	75 79		 jne	 SHORT $LN47@bytearray_@43
  0012b	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0012f	75 73		 jne	 SHORT $LN47@bytearray_@43
  00131	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0013f	4c 8b cb	 mov	 r9, rbx
  00142	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00148	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00150	e8 00 00 00 00	 call	 _PyParallel_Guard
  00155	48 8b cb	 mov	 rcx, rbx
  00158	85 c0		 test	 eax, eax
  0015a	74 2f		 je	 SHORT $LN46@bytearray_@43
  0015c	e8 00 00 00 00	 call	 _Px_Dealloc

; 2647 :     return NULL;

  00161	33 c0		 xor	 eax, eax
  00163	e9 62 01 00 00	 jmp	 $LN60@bytearray_@43
$LN50@bytearray_@43:

; 2603 :             PyErr_Format(PyExc_TypeError,
; 2604 :                          "can only join an iterable of bytes "
; 2605 :                          "(item %ld has type '%.100s')",
; 2606 :                          /* XXX %ld isn't right on Win64 */
; 2607 :                          (long)i, Py_TYPE(obj)->tp_name);

  00168	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  0016c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00173	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EA@LOOJBHHN@can?5only?5join?5an?5iterable?5of?5byt@
  0017a	44 8b c7	 mov	 r8d, edi
  0017d	e8 00 00 00 00	 call	 PyErr_Format

; 2608 :             goto error;

  00182	eb 8a		 jmp	 SHORT $error$23660
$LN51@bytearray_@43:

; 2614 :             PyErr_NoMemory();

  00184	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2615 :             goto error;

  00189	eb 83		 jmp	 SHORT $error$23660

; 2643 : 
; 2644 :     /* Error handling */
; 2645 :   error:
; 2646 :     Py_DECREF(seq);

$LN46@bytearray_@43:
  0018b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0018f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 2647 :     return NULL;

  00195	33 c0		 xor	 eax, eax
  00197	e9 2e 01 00 00	 jmp	 $LN60@bytearray_@43

; 2643 : 
; 2644 :     /* Error handling */
; 2645 :   error:
; 2646 :     Py_DECREF(seq);

$LN41@bytearray_@43:
  0019c	48 8b cb	 mov	 rcx, rbx
  0019f	e8 00 00 00 00	 call	 Px_DecRef
$LN47@bytearray_@43:

; 2647 :     return NULL;

  001a4	33 c0		 xor	 eax, eax
  001a6	e9 1f 01 00 00	 jmp	 $LN60@bytearray_@43
$LN8@bytearray_@43:

; 2622 :         goto error;
; 2623 :     dest = PyByteArray_AS_STRING(result);

  001ab	4c 39 60 60	 cmp	 QWORD PTR [rax+96], r12
  001af	74 09		 je	 SHORT $LN22@bytearray_@43
  001b1	48 8b b0 80 00
	00 00		 mov	 rsi, QWORD PTR [rax+128]
  001b8	eb 07		 jmp	 SHORT $LN23@bytearray_@43
$LN22@bytearray_@43:
  001ba	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_PyByteArray_empty_string
$LN23@bytearray_@43:

; 2624 :     for (i = 0; i < n; i++) {

  001c1	4d 85 f6	 test	 r14, r14
  001c4	0f 8e 98 00 00
	00		 jle	 $LN5@bytearray_@43
  001ca	4c 8b ac 24 90
	00 00 00	 mov	 r13, QWORD PTR items$1$[rsp]
  001d2	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR self$[rsp]
  001da	66 0f 1f 44 00
	00		 npad	 6
$LL7@bytearray_@43:

; 2625 :         PyObject *obj = items[i];

  001e0	4b 8b 7c e5 00	 mov	 rdi, QWORD PTR [r13+r12*8]

; 2626 :         Py_ssize_t size = Py_SIZE(obj);
; 2627 :         char *buf;
; 2628 :         if (PyByteArray_Check(obj))

  001e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  001ec	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  001f0	48 8b 6f 60	 mov	 rbp, QWORD PTR [rdi+96]
  001f4	48 3b c8	 cmp	 rcx, rax
  001f7	74 12		 je	 SHORT $LN3@bytearray_@43
  001f9	48 8b d0	 mov	 rdx, rax
  001fc	e8 00 00 00 00	 call	 PyType_IsSubtype
  00201	85 c0		 test	 eax, eax
  00203	75 06		 jne	 SHORT $LN3@bytearray_@43

; 2630 :         else
; 2631 :            buf = PyBytes_AS_STRING(obj);

  00205	48 83 c7 78	 add	 rdi, 120		; 00000078H
  00209	eb 17		 jmp	 SHORT $LN25@bytearray_@43
$LN3@bytearray_@43:

; 2629 :            buf = PyByteArray_AS_STRING(obj);

  0020b	48 83 7f 60 00	 cmp	 QWORD PTR [rdi+96], 0
  00210	74 09		 je	 SHORT $LN24@bytearray_@43
  00212	48 8b bf 80 00
	00 00		 mov	 rdi, QWORD PTR [rdi+128]
  00219	eb 07		 jmp	 SHORT $LN25@bytearray_@43
$LN24@bytearray_@43:
  0021b	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_PyByteArray_empty_string
$LN25@bytearray_@43:

; 2632 :         if (i) {

  00222	4d 85 e4	 test	 r12, r12
  00225	74 15		 je	 SHORT $LN1@bytearray_@43

; 2633 :             memcpy(dest, self->ob_bytes, mysize);

  00227	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  0022e	4d 8b c7	 mov	 r8, r15
  00231	48 8b ce	 mov	 rcx, rsi
  00234	e8 00 00 00 00	 call	 memcpy

; 2634 :             dest += mysize;

  00239	49 03 f7	 add	 rsi, r15
$LN1@bytearray_@43:

; 2635 :         }
; 2636 :         memcpy(dest, buf, size);

  0023c	4c 8b c5	 mov	 r8, rbp
  0023f	48 8b d7	 mov	 rdx, rdi
  00242	48 8b ce	 mov	 rcx, rsi
  00245	e8 00 00 00 00	 call	 memcpy
  0024a	49 ff c4	 inc	 r12

; 2637 :         dest += size;

  0024d	48 03 f5	 add	 rsi, rbp
  00250	4d 3b e6	 cmp	 r12, r14
  00253	7c 8b		 jl	 SHORT $LL7@bytearray_@43
  00255	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR seq$1$[rsp]
  0025d	4c 8b 6c 24 30	 mov	 r13, QWORD PTR result$1$[rsp]
$LN5@bytearray_@43:

; 2638 :     }
; 2639 : 
; 2640 :     /* Done */
; 2641 :     Py_DECREF(seq);

  00262	e8 00 00 00 00	 call	 _Py_PXCTX
  00267	85 c0		 test	 eax, eax
  00269	75 5c		 jne	 SHORT $LN36@bytearray_@43
  0026b	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0026f	a8 20		 test	 al, 32			; 00000020H
  00271	75 4c		 jne	 SHORT $LN30@bytearray_@43
  00273	84 c0		 test	 al, al
  00275	78 48		 js	 SHORT $LN30@bytearray_@43
  00277	a8 02		 test	 al, 2
  00279	75 4c		 jne	 SHORT $LN36@bytearray_@43
  0027b	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0027f	75 46		 jne	 SHORT $LN36@bytearray_@43
  00281	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00288	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0028f	4c 8b cb	 mov	 r9, rbx
  00292	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00298	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002a0	e8 00 00 00 00	 call	 _PyParallel_Guard
  002a5	48 8b cb	 mov	 rcx, rbx
  002a8	85 c0		 test	 eax, eax
  002aa	74 07		 je	 SHORT $LN35@bytearray_@43
  002ac	e8 00 00 00 00	 call	 _Px_Dealloc
  002b1	eb 14		 jmp	 SHORT $LN36@bytearray_@43
$LN35@bytearray_@43:
  002b3	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  002b7	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002bd	eb 08		 jmp	 SHORT $LN36@bytearray_@43
$LN30@bytearray_@43:
  002bf	48 8b cb	 mov	 rcx, rbx
  002c2	e8 00 00 00 00	 call	 Px_DecRef
$LN36@bytearray_@43:

; 2642 :     return result;

  002c7	49 8b c5	 mov	 rax, r13
$LN60@bytearray_@43:
  002ca	4c 8b 6c 24 48	 mov	 r13, QWORD PTR [rsp+72]
  002cf	48 8b ac 24 88
	00 00 00	 mov	 rbp, QWORD PTR [rsp+136]
  002d7	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  002dc	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]

; 2648 : }

  002e1	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002e5	41 5f		 pop	 r15
  002e7	41 5c		 pop	 r12
  002e9	5e		 pop	 rsi
  002ea	5b		 pop	 rbx
  002eb	c3		 ret	 0
bytearray_join ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@BPBIFPCC@?$HMi?3splitlines?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_splitlines DD imagerel bytearray_splitlines
	DD	imagerel bytearray_splitlines+125
	DD	imagerel $unwind$bytearray_splitlines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_splitlines DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0O@BPBIFPCC@?$HMi?3splitlines?$AA@
CONST	SEGMENT
??_C@_0O@BPBIFPCC@?$HMi?3splitlines?$AA@ DB '|i:splitlines', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_splitlines
_TEXT	SEGMENT
self$ = 64
args$ = 72
kwds$ = 80
keepends$ = 88
bytearray_splitlines PROC				; COMDAT

; 2659 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	49 8b c0	 mov	 rax, r8
  0000c	4c 8b d2	 mov	 r10, rdx

; 2660 :     static char *kwlist[] = {"keepends", 0};
; 2661 :     int keepends = 0;
; 2662 : 
; 2663 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|i:splitlines",
; 2664 :                                      kwlist, &keepends))

  0000f	48 8d 4c 24 58	 lea	 rcx, QWORD PTR keepends$[rsp]
  00014	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??bytearray_splitlines@@9@9
  0001b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BPBIFPCC@?$HMi?3splitlines?$AA@
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	48 8b d0	 mov	 rdx, rax
  0002a	49 8b ca	 mov	 rcx, r10
  0002d	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR keepends$[rsp], 0
  00035	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0003a	85 c0		 test	 eax, eax
  0003c	75 08		 jne	 SHORT $LN1@bytearray_@44

; 2665 :         return NULL;

  0003e	33 c0		 xor	 eax, eax

; 2671 : }

  00040	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00044	5b		 pop	 rbx
  00045	c3		 ret	 0
$LN1@bytearray_@44:

; 2666 : 
; 2667 :     return stringlib_splitlines(
; 2668 :         (PyObject*) self, PyByteArray_AS_STRING(self),
; 2669 :         PyByteArray_GET_SIZE(self), keepends
; 2670 :         );

  00046	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  0004a	48 85 d2	 test	 rdx, rdx
  0004d	74 17		 je	 SHORT $LN4@bytearray_@44
  0004f	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00056	44 8b 44 24 58	 mov	 r8d, DWORD PTR keepends$[rsp]
  0005b	e8 00 00 00 00	 call	 stringlib_splitlines

; 2671 : }

  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5b		 pop	 rbx
  00065	c3		 ret	 0
$LN4@bytearray_@44:

; 2666 : 
; 2667 :     return stringlib_splitlines(
; 2668 :         (PyObject*) self, PyByteArray_AS_STRING(self),
; 2669 :         PyByteArray_GET_SIZE(self), keepends
; 2670 :         );

  00066	44 8b 44 24 58	 mov	 r8d, DWORD PTR keepends$[rsp]
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyByteArray_empty_string
  00072	e8 00 00 00 00	 call	 stringlib_splitlines

; 2671 : }

  00077	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007b	5b		 pop	 rbx
  0007c	c3		 ret	 0
bytearray_splitlines ENDP
_TEXT	ENDS
EXTRN	_Py_ctype_tolower:BYTE
; Function compile flags: /Ogtpy
;	COMDAT hex_digit_to_int
_TEXT	SEGMENT
c$ = 8
hex_digit_to_int PROC					; COMDAT

; 2683 :     if (c >= 128)

  00000	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H

; 2684 :         return -1;

  00006	73 33		 jae	 SHORT $LN1@hex_digit_

; 2685 :     if (Py_ISDIGIT(c))

  00008	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  0000f	0f b6 d1	 movzx	 edx, cl
  00012	41 8b 84 90 00
	00 00 00	 mov	 eax, DWORD PTR _Py_ctype_table[r8+rdx*4]
  0001a	a8 04		 test	 al, 4
  0001c	74 04		 je	 SHORT $LN4@hex_digit_

; 2686 :         return c - '0';

  0001e	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]

; 2694 : }

  00021	c3		 ret	 0
$LN4@hex_digit_:

; 2687 :     else {
; 2688 :         if (Py_ISUPPER(c))

  00022	a8 02		 test	 al, 2
  00024	74 09		 je	 SHORT $LN2@hex_digit_

; 2689 :             c = Py_TOLOWER(c);

  00026	42 0f b6 8c 02
	00 00 00 00	 movzx	 ecx, BYTE PTR _Py_ctype_tolower[rdx+r8]
$LN2@hex_digit_:

; 2690 :         if (c >= 'a' && c <= 'f')

  0002f	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  00032	83 f8 05	 cmp	 eax, 5
  00035	77 04		 ja	 SHORT $LN1@hex_digit_

; 2691 :             return c - 'a' + 10;

  00037	8d 41 a9	 lea	 eax, DWORD PTR [rcx-87]

; 2694 : }

  0003a	c3		 ret	 0
$LN1@hex_digit_:

; 2692 :     }
; 2693 :     return -1;

  0003b	83 c8 ff	 or	 eax, -1

; 2694 : }

  0003e	c3		 ret	 0
hex_digit_to_int ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DO@GIPAEFDP@non?9hexadecimal?5number?5found?5in?5@ ; `string'
PUBLIC	??_C@_09FKEMNDFN@U?3fromhex?$AA@		; `string'
EXTRN	_PyUnicode_Ready:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_fromhex DD imagerel bytearray_fromhex
	DD	imagerel bytearray_fromhex+166
	DD	imagerel $unwind$bytearray_fromhex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$bytearray_fromhex DD imagerel bytearray_fromhex+166
	DD	imagerel bytearray_fromhex+431
	DD	imagerel $chain$4$bytearray_fromhex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$bytearray_fromhex DD imagerel bytearray_fromhex+431
	DD	imagerel bytearray_fromhex+456
	DD	imagerel $chain$5$bytearray_fromhex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$bytearray_fromhex DD 021H
	DD	imagerel bytearray_fromhex
	DD	imagerel bytearray_fromhex+166
	DD	imagerel $unwind$bytearray_fromhex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$bytearray_fromhex DD 020521H
	DD	04c405H
	DD	imagerel bytearray_fromhex
	DD	imagerel bytearray_fromhex+166
	DD	imagerel $unwind$bytearray_fromhex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_fromhex DD 095301H
	DD	057453H
	DD	06644eH
	DD	095449H
	DD	083444H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0DO@GIPAEFDP@non?9hexadecimal?5number?5found?5in?5@
CONST	SEGMENT
??_C@_0DO@GIPAEFDP@non?9hexadecimal?5number?5found?5in?5@ DB 'non-hexadec'
	DB	'imal number found in fromhex() arg at position %zd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FKEMNDFN@U?3fromhex?$AA@
CONST	SEGMENT
??_C@_09FKEMNDFN@U?3fromhex?$AA@ DB 'U:fromhex', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_fromhex
_TEXT	SEGMENT
cls$ = 64
args$ = 72
hexobj$ = 80
bytearray_fromhex PROC					; COMDAT

; 2698 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2699 :     PyObject *newbytes, *hexobj;
; 2700 :     char *buf;
; 2701 :     Py_ssize_t hexlen, byteslen, i, j;
; 2702 :     int top, bot;
; 2703 :     void *data;
; 2704 :     unsigned int kind;
; 2705 : 
; 2706 :     if (!PyArg_ParseTuple(args, "U:fromhex", &hexobj))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 50	 lea	 r8, QWORD PTR hexobj$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09FKEMNDFN@U?3fromhex?$AA@
  00013	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN12@bytearray_@45
$LN46@bytearray_@45:

; 2707 :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 2743 : }

  0001e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00022	c3		 ret	 0
$LN12@bytearray_@45:

; 2708 :     assert(PyUnicode_Check(hexobj));
; 2709 :     if (PyUnicode_READY(hexobj))

  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hexobj$[rsp]
  00028	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0002c	75 0e		 jne	 SHORT $LN11@bytearray_@45
  0002e	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00033	85 c0		 test	 eax, eax

; 2710 :         return NULL;

  00035	75 e5		 jne	 SHORT $LN46@bytearray_@45
  00037	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hexobj$[rsp]
$LN11@bytearray_@45:

; 2711 :     kind = PyUnicode_KIND(hexobj);

  0003c	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  0003f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00044	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  00049	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0004e	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  00053	8b f8		 mov	 edi, eax
  00055	c1 ef 02	 shr	 edi, 2
  00058	83 e7 07	 and	 edi, 7

; 2712 :     data = PyUnicode_DATA(hexobj);

  0005b	a8 20		 test	 al, 32			; 00000020H
  0005d	74 16		 je	 SHORT $LN19@bytearray_@45
  0005f	a8 40		 test	 al, 64			; 00000040H
  00061	74 09		 je	 SHORT $LN17@bytearray_@45
  00063	48 8d 99 80 00
	00 00		 lea	 rbx, QWORD PTR [rcx+128]
  0006a	eb 10		 jmp	 SHORT $LN20@bytearray_@45
$LN17@bytearray_@45:
  0006c	48 8d 99 a0 00
	00 00		 lea	 rbx, QWORD PTR [rcx+160]
  00073	eb 07		 jmp	 SHORT $LN20@bytearray_@45
$LN19@bytearray_@45:
  00075	48 8b 99 a0 00
	00 00		 mov	 rbx, QWORD PTR [rcx+160]
$LN20@bytearray_@45:

; 2713 :     hexlen = PyUnicode_GET_LENGTH(hexobj);

  0007c	48 8b 69 60	 mov	 rbp, QWORD PTR [rcx+96]

; 2714 : 
; 2715 :     byteslen = hexlen/2; /* This overestimates if there are spaces */
; 2716 :     newbytes = PyByteArray_FromStringAndSize(NULL, byteslen);

  00080	33 c9		 xor	 ecx, ecx
  00082	48 8b c5	 mov	 rax, rbp
  00085	48 99		 cdq
  00087	48 2b c2	 sub	 rax, rdx
  0008a	48 d1 f8	 sar	 rax, 1
  0008d	48 8b d0	 mov	 rdx, rax
  00090	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00095	48 8b f0	 mov	 rsi, rax

; 2717 :     if (!newbytes)

  00098	48 85 c0	 test	 rax, rax
  0009b	0f 84 0e 01 00
	00		 je	 $LN44@bytearray_@45
$LN10@bytearray_@45:

; 2718 :         return NULL;
; 2719 :     buf = PyByteArray_AS_STRING(newbytes);

  000a1	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000a6	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  000ab	74 09		 je	 SHORT $LN21@bytearray_@45
  000ad	4c 8b a0 80 00
	00 00		 mov	 r12, QWORD PTR [rax+128]
  000b4	eb 07		 jmp	 SHORT $LN22@bytearray_@45
$LN21@bytearray_@45:
  000b6	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_PyByteArray_empty_string
$LN22@bytearray_@45:

; 2720 :     for (i = j = 0; i < hexlen; i += 2) {

  000bd	45 33 db	 xor	 r11d, r11d
  000c0	45 8b cb	 mov	 r9d, r11d
  000c3	48 85 ed	 test	 rbp, rbp
  000c6	0f 8e 9e 00 00
	00		 jle	 $LN7@bytearray_@45
  000cc	0f 1f 40 00	 npad	 4
$LL6@bytearray_@45:

; 2721 :         /* skip over spaces in the input */
; 2722 :         while (PyUnicode_READ(kind, data, i) == ' ')

  000d0	83 ff 01	 cmp	 edi, 1
  000d3	75 07		 jne	 SHORT $LN25@bytearray_@45
  000d5	41 0f b6 04 19	 movzx	 eax, BYTE PTR [r9+rbx]
  000da	eb 10		 jmp	 SHORT $LN24@bytearray_@45
$LN25@bytearray_@45:
  000dc	83 ff 02	 cmp	 edi, 2
  000df	75 07		 jne	 SHORT $LN23@bytearray_@45
  000e1	42 0f b7 04 4b	 movzx	 eax, WORD PTR [rbx+r9*2]
  000e6	eb 04		 jmp	 SHORT $LN24@bytearray_@45
$LN23@bytearray_@45:

; 2720 :     for (i = j = 0; i < hexlen; i += 2) {

  000e8	42 8b 04 8b	 mov	 eax, DWORD PTR [rbx+r9*4]
$LN24@bytearray_@45:

; 2721 :         /* skip over spaces in the input */
; 2722 :         while (PyUnicode_READ(kind, data, i) == ' ')

  000ec	83 f8 20	 cmp	 eax, 32			; 00000020H
  000ef	75 05		 jne	 SHORT $LN5@bytearray_@45

; 2723 :             i++;

  000f1	49 ff c1	 inc	 r9
  000f4	eb da		 jmp	 SHORT $LL6@bytearray_@45
$LN5@bytearray_@45:

; 2724 :         if (i >= hexlen)

  000f6	4c 3b cd	 cmp	 r9, rbp
  000f9	7d 6f		 jge	 SHORT $LN7@bytearray_@45

; 2725 :             break;
; 2726 :         top = hex_digit_to_int(PyUnicode_READ(kind, data, i));

  000fb	83 ff 01	 cmp	 edi, 1
  000fe	75 07		 jne	 SHORT $LN29@bytearray_@45
  00100	41 0f b6 0c 19	 movzx	 ecx, BYTE PTR [r9+rbx]
  00105	eb 10		 jmp	 SHORT $LN28@bytearray_@45
$LN29@bytearray_@45:
  00107	83 ff 02	 cmp	 edi, 2
  0010a	75 07		 jne	 SHORT $LN27@bytearray_@45
  0010c	42 0f b7 0c 4b	 movzx	 ecx, WORD PTR [rbx+r9*2]
  00111	eb 04		 jmp	 SHORT $LN28@bytearray_@45
$LN27@bytearray_@45:

; 2720 :     for (i = j = 0; i < hexlen; i += 2) {

  00113	42 8b 0c 8b	 mov	 ecx, DWORD PTR [rbx+r9*4]
$LN28@bytearray_@45:

; 2725 :             break;
; 2726 :         top = hex_digit_to_int(PyUnicode_READ(kind, data, i));

  00117	e8 00 00 00 00	 call	 hex_digit_to_int
  0011c	44 8b d0	 mov	 r10d, eax

; 2727 :         bot = hex_digit_to_int(PyUnicode_READ(kind, data, i+1));

  0011f	83 ff 01	 cmp	 edi, 1
  00122	75 08		 jne	 SHORT $LN33@bytearray_@45
  00124	41 0f b6 4c 19
	01		 movzx	 ecx, BYTE PTR [r9+rbx+1]
  0012a	eb 12		 jmp	 SHORT $LN32@bytearray_@45
$LN33@bytearray_@45:
  0012c	83 ff 02	 cmp	 edi, 2
  0012f	75 08		 jne	 SHORT $LN31@bytearray_@45
  00131	42 0f b7 4c 4b
	02		 movzx	 ecx, WORD PTR [rbx+r9*2+2]
  00137	eb 05		 jmp	 SHORT $LN32@bytearray_@45
$LN31@bytearray_@45:

; 2720 :     for (i = j = 0; i < hexlen; i += 2) {

  00139	42 8b 4c 8b 04	 mov	 ecx, DWORD PTR [rbx+r9*4+4]
$LN32@bytearray_@45:

; 2727 :         bot = hex_digit_to_int(PyUnicode_READ(kind, data, i+1));

  0013e	e8 00 00 00 00	 call	 hex_digit_to_int

; 2728 :         if (top == -1 || bot == -1) {

  00143	41 83 fa ff	 cmp	 r10d, -1
  00147	74 3c		 je	 SHORT $LN38@bytearray_@45
  00149	83 f8 ff	 cmp	 eax, -1
  0014c	74 37		 je	 SHORT $LN38@bytearray_@45

; 2732 :             goto error;
; 2733 :         }
; 2734 :         buf[j++] = (top << 4) + bot;

  0014e	41 c0 e2 04	 shl	 r10b, 4
  00152	49 83 c1 02	 add	 r9, 2
  00156	49 ff c3	 inc	 r11
  00159	44 02 d0	 add	 r10b, al
  0015c	47 88 54 23 ff	 mov	 BYTE PTR [r11+r12-1], r10b
  00161	4c 3b cd	 cmp	 r9, rbp
  00164	0f 8c 66 ff ff
	ff		 jl	 $LL6@bytearray_@45
$LN7@bytearray_@45:

; 2735 :     }
; 2736 :     if (PyByteArray_Resize(newbytes, j) < 0)

  0016a	49 8b d3	 mov	 rdx, r11
  0016d	48 8b ce	 mov	 rcx, rsi
  00170	e8 00 00 00 00	 call	 PyByteArray_Resize
  00175	85 c0		 test	 eax, eax
  00177	79 2e		 jns	 SHORT $LN1@bytearray_@45

; 2739 : 
; 2740 :   error:
; 2741 :     Py_DECREF(newbytes);

  00179	48 8b ce	 mov	 rcx, rsi
$error$23797:
  0017c	e8 00 00 00 00	 call	 _Py_DecRef

; 2742 :     return NULL;

  00181	33 c0		 xor	 eax, eax
  00183	eb 25		 jmp	 SHORT $LN45@bytearray_@45
$LN38@bytearray_@45:

; 2729 :             PyErr_Format(PyExc_ValueError,
; 2730 :                          "non-hexadecimal number found in "
; 2731 :                          "fromhex() arg at position %zd", i);

  00185	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0018c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DO@GIPAEFDP@non?9hexadecimal?5number?5found?5in?5@
  00193	4d 8b c1	 mov	 r8, r9
  00196	e8 00 00 00 00	 call	 PyErr_Format

; 2739 : 
; 2740 :   error:
; 2741 :     Py_DECREF(newbytes);

  0019b	48 8b ce	 mov	 rcx, rsi
  0019e	e8 00 00 00 00	 call	 _Py_DecRef

; 2742 :     return NULL;

  001a3	33 c0		 xor	 eax, eax
  001a5	eb 03		 jmp	 SHORT $LN45@bytearray_@45
$LN1@bytearray_@45:

; 2737 :         goto error;
; 2738 :     return newbytes;

  001a7	48 8b c6	 mov	 rax, rsi
$LN45@bytearray_@45:
  001aa	4c 8b 64 24 20	 mov	 r12, QWORD PTR [rsp+32]
$LN44@bytearray_@45:
  001af	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  001b4	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001b9	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001be	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]

; 2743 : }

  001c3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001c7	c3		 ret	 0
bytearray_fromhex ENDP
_TEXT	ENDS
PUBLIC	??_C@_06HCAGFEJD@?$CIO?$CI?$CJN?$CJ?$AA@	; `string'
PUBLIC	??_C@_08GFAELKBI@?$CIO?$CIy?$CD?$CJN?$CJ?$AA@	; `string'
PUBLIC	??_C@_08EEGIECMG@?$CIO?$CINs?$CJN?$CJ?$AA@	; `string'
PUBLIC	??_C@_07BJPINKOJ@latin?91?$AA@			; `string'
EXTRN	_Py_BuildValue_SizeT:PROC
EXTRN	PyUnicode_FromString:PROC
EXTRN	PyUnicode_DecodeLatin1:PROC
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_common_reduce DD imagerel _common_reduce
	DD	imagerel _common_reduce+308
	DD	imagerel $unwind$_common_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_common_reduce DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_06HCAGFEJD@?$CIO?$CI?$CJN?$CJ?$AA@
CONST	SEGMENT
??_C@_06HCAGFEJD@?$CIO?$CI?$CJN?$CJ?$AA@ DB '(O()N)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GFAELKBI@?$CIO?$CIy?$CD?$CJN?$CJ?$AA@
CONST	SEGMENT
??_C@_08GFAELKBI@?$CIO?$CIy?$CD?$CJN?$CJ?$AA@ DB '(O(y#)N)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EEGIECMG@?$CIO?$CINs?$CJN?$CJ?$AA@
CONST	SEGMENT
??_C@_08EEGIECMG@?$CIO?$CINs?$CJN?$CJ?$AA@ DB '(O(Ns)N)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BJPINKOJ@latin?91?$AA@
CONST	SEGMENT
??_C@_07BJPINKOJ@latin?91?$AA@ DB 'latin-1', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
CONST	ENDS
;	COMDAT _common_reduce
_TEXT	SEGMENT
self$ = 64
proto$ = 72
_common_reduce PROC					; COMDAT

; 2748 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2749 :     PyObject *dict;
; 2750 :     _Py_IDENTIFIER(__dict__);
; 2751 : 
; 2752 :     dict = _PyObject_GetAttrId((PyObject *)self, &PyId___dict__);

  0000f	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00016	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0001f	8b f2		 mov	 esi, edx
  00021	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___dict__@?1??_common_reduce@@9@9
  00026	48 8b d9	 mov	 rbx, rcx
  00029	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0002d	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00032	48 8b f8	 mov	 rdi, rax

; 2753 :     if (dict == NULL) {

  00035	48 85 c0	 test	 rax, rax
  00038	75 4d		 jne	 SHORT $LN11@common_red

; 2754 :         PyErr_Clear();

  0003a	e8 00 00 00 00	 call	 PyErr_Clear

; 2755 :         dict = Py_None;

  0003f	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct

; 2756 :         Py_INCREF(dict);

  00046	e8 00 00 00 00	 call	 _Py_PXCTX
  0004b	85 c0		 test	 eax, eax
  0004d	75 38		 jne	 SHORT $LN11@common_red
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0005d	4c 8b cf	 mov	 r9, rdi
  00060	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00066	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0006e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00073	85 c0		 test	 eax, eax
  00075	75 09		 jne	 SHORT $LN10@common_red
  00077	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0007e	74 07		 je	 SHORT $LN11@common_red
$LN10@common_red:
  00080	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN11@common_red:

; 2757 :     }
; 2758 : 
; 2759 :     if (proto < 3) {

  00087	83 fe 03	 cmp	 esi, 3
  0008a	7d 55		 jge	 SHORT $LN6@common_red

; 2760 :         /* use str based reduction for backwards compatibility with Python 2.x */
; 2761 :         PyObject *latin1;
; 2762 :         if (self->ob_bytes)

  0008c	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00093	48 85 c9	 test	 rcx, rcx
  00096	74 0e		 je	 SHORT $LN5@common_red

; 2763 :             latin1 = PyUnicode_DecodeLatin1(self->ob_bytes, Py_SIZE(self), NULL);

  00098	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  0009c	45 33 c0	 xor	 r8d, r8d
  0009f	e8 00 00 00 00	 call	 PyUnicode_DecodeLatin1

; 2764 :         else

  000a4	eb 0c		 jmp	 SHORT $LN4@common_red
$LN5@common_red:

; 2765 :             latin1 = PyUnicode_FromString("");

  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000ad	e8 00 00 00 00	 call	 PyUnicode_FromString
$LN4@common_red:

; 2766 :         return Py_BuildValue("(O(Ns)N)", Py_TYPE(self), latin1, "latin-1", dict);

  000b2	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  000b6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_07BJPINKOJ@latin?91?$AA@
  000bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08EEGIECMG@?$CIO?$CINs?$CJN?$CJ?$AA@
  000c4	4c 8b c0	 mov	 r8, rax
  000c7	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  000cc	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 2775 :         }
; 2776 :     }
; 2777 : }

  000d1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d6	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000db	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000df	5f		 pop	 rdi
  000e0	c3		 ret	 0
$LN6@common_red:

; 2767 :     }
; 2768 :     else {
; 2769 :         /* use more efficient byte based reduction */
; 2770 :         if (self->ob_bytes) {

  000e1	4c 8b 83 80 00
	00 00		 mov	 r8, QWORD PTR [rbx+128]

; 2771 :             return Py_BuildValue("(O(y#)N)", Py_TYPE(self), self->ob_bytes, Py_SIZE(self), dict);

  000e8	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  000ec	4d 85 c0	 test	 r8, r8
  000ef	74 25		 je	 SHORT $LN2@common_red
  000f1	4c 8b 4b 60	 mov	 r9, QWORD PTR [rbx+96]
  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GFAELKBI@?$CIO?$CIy?$CD?$CJN?$CJ?$AA@
  000fc	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00101	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 2775 :         }
; 2776 :     }
; 2777 : }

  00106	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0010b	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00110	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00114	5f		 pop	 rdi
  00115	c3		 ret	 0
$LN2@common_red:

; 2772 :         }
; 2773 :         else {
; 2774 :             return Py_BuildValue("(O()N)", Py_TYPE(self), dict);

  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06HCAGFEJD@?$CIO?$CI?$CJN?$CJ?$AA@
  0011d	4c 8b c7	 mov	 r8, rdi

; 2775 :         }
; 2776 :     }
; 2777 : }

  00120	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00125	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0012a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0012e	5f		 pop	 rdi
  0012f	e9 00 00 00 00	 jmp	 _Py_BuildValue_SizeT
_common_reduce ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bytearray_reduce
_TEXT	SEGMENT
self$ = 8
bytearray_reduce PROC					; COMDAT

; 2784 :     return _common_reduce(self, 2);

  00000	ba 02 00 00 00	 mov	 edx, 2

; 2785 : }

  00005	e9 00 00 00 00	 jmp	 _common_reduce
bytearray_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@IDCJELDA@?$HMi?3__reduce_ex__?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearray_reduce_ex DD imagerel bytearray_reduce_ex
	DD	imagerel bytearray_reduce_ex+70
	DD	imagerel $unwind$bytearray_reduce_ex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_reduce_ex DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BB@IDCJELDA@?$HMi?3__reduce_ex__?$AA@
CONST	SEGMENT
??_C@_0BB@IDCJELDA@?$HMi?3__reduce_ex__?$AA@ DB '|i:__reduce_ex__', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearray_reduce_ex
_TEXT	SEGMENT
self$ = 48
args$ = 56
proto$ = 64
bytearray_reduce_ex PROC				; COMDAT

; 2791 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 2792 :     int proto = 0;
; 2793 : 
; 2794 :     if (!PyArg_ParseTuple(args, "|i:__reduce_ex__", &proto))

  0000c	4c 8d 44 24 40	 lea	 r8, QWORD PTR proto$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@IDCJELDA@?$HMi?3__reduce_ex__?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR proto$[rsp], 0
  00023	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00028	85 c0		 test	 eax, eax
  0002a	75 08		 jne	 SHORT $LN1@bytearray_@46

; 2795 :         return NULL;

  0002c	33 c0		 xor	 eax, eax

; 2798 : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
$LN1@bytearray_@46:

; 2796 : 
; 2797 :     return _common_reduce(self, proto);

  00034	8b 54 24 40	 mov	 edx, DWORD PTR proto$[rsp]
  00038	48 8b cb	 mov	 rcx, rbx
  0003b	e8 00 00 00 00	 call	 _common_reduce

; 2798 : }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5b		 pop	 rbx
  00045	c3		 ret	 0
bytearray_reduce_ex ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bytearray_sizeof
_TEXT	SEGMENT
self$ = 8
bytearray_sizeof PROC					; COMDAT

; 2807 :     Py_ssize_t res;
; 2808 : 
; 2809 :     res = sizeof(PyByteArrayObject) + self->ob_alloc * sizeof(char);

  00000	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00004	48 81 c1 90 00
	00 00		 add	 rcx, 144		; 00000090H

; 2810 :     return PyLong_FromSsize_t(res);
; 2811 : }

  0000b	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
bytearray_sizeof ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@JMKAPJBH@bytearrayiter_dealloc?$AA@	; `string'
EXTRN	PyObject_GC_Del:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytearrayiter_dealloc DD imagerel bytearrayiter_dealloc
	DD	imagerel bytearrayiter_dealloc+301
	DD	imagerel $unwind$bytearrayiter_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearrayiter_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0BG@JMKAPJBH@bytearrayiter_dealloc?$AA@
CONST	SEGMENT
??_C@_0BG@JMKAPJBH@bytearrayiter_dealloc?$AA@ DB 'bytearrayiter_dealloc', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
CONST	ENDS
;	COMDAT bytearrayiter_dealloc
_TEXT	SEGMENT
it$ = 64
bytearrayiter_dealloc PROC				; COMDAT

; 2976 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 2977 :     _PyObject_GC_UNTRACK(it);

  0000d	4c 8b c9	 mov	 r9, rcx
  00010	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@JMKAPJBH@bytearrayiter_dealloc?$AA@
  0001e	41 b8 a1 0b 00
	00		 mov	 r8d, 2977		; 00000ba1H
  00024	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0002c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00031	85 c0		 test	 eax, eax
  00033	75 54		 jne	 SHORT $LN5@bytearrayi
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@JMKAPJBH@bytearrayiter_dealloc?$AA@
  00043	4c 8b cf	 mov	 r9, rdi
  00046	41 b8 a1 0b 00
	00		 mov	 r8d, 2977		; 00000ba1H
  0004c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00054	e8 00 00 00 00	 call	 _PyParallel_Guard
  00059	85 c0		 test	 eax, eax
  0005b	74 04		 je	 SHORT $LN11@bytearrayi
  0005d	33 d2		 xor	 edx, edx
  0005f	eb 04		 jmp	 SHORT $LN12@bytearrayi
$LN11@bytearrayi:
  00061	48 8d 57 e8	 lea	 rdx, QWORD PTR [rdi-24]
$LN12@bytearrayi:
  00065	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00068	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  0006c	48 c7 42 10 fe
	ff ff ff	 mov	 QWORD PTR [rdx+16], -2
  00074	48 89 01	 mov	 QWORD PTR [rcx], rax
  00077	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  0007a	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0007e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00082	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0
$LN5@bytearrayi:

; 2978 :     Py_XDECREF(it->it_seq);

  00089	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
  0008d	48 85 db	 test	 rbx, rbx
  00090	0f 84 85 00 00
	00		 je	 $LN3@bytearrayi
  00096	e8 00 00 00 00	 call	 _Py_PXCTX
  0009b	85 c0		 test	 eax, eax
  0009d	75 7c		 jne	 SHORT $LN3@bytearrayi
  0009f	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000a3	a8 20		 test	 al, 32			; 00000020H
  000a5	75 6c		 jne	 SHORT $LN17@bytearrayi
  000a7	84 c0		 test	 al, al
  000a9	78 68		 js	 SHORT $LN17@bytearrayi
  000ab	a8 02		 test	 al, 2
  000ad	75 6c		 jne	 SHORT $LN3@bytearrayi
  000af	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000b3	75 66		 jne	 SHORT $LN3@bytearrayi
  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c3	4c 8b cb	 mov	 r9, rbx
  000c6	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000cc	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d4	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d9	48 8b cb	 mov	 rcx, rbx
  000dc	85 c0		 test	 eax, eax
  000de	74 17		 je	 SHORT $LN22@bytearrayi
  000e0	e8 00 00 00 00	 call	 _Px_Dealloc

; 2979 :     PyObject_GC_Del(it);

  000e5	48 8b cf	 mov	 rcx, rdi

; 2980 : }

  000e8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ed	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f1	5f		 pop	 rdi
  000f2	e9 00 00 00 00	 jmp	 PyObject_GC_Del

; 2978 :     Py_XDECREF(it->it_seq);

$LN22@bytearrayi:
  000f7	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000fb	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 2979 :     PyObject_GC_Del(it);

  00101	48 8b cf	 mov	 rcx, rdi

; 2980 : }

  00104	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00109	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010d	5f		 pop	 rdi
  0010e	e9 00 00 00 00	 jmp	 PyObject_GC_Del

; 2978 :     Py_XDECREF(it->it_seq);

$LN17@bytearrayi:
  00113	48 8b cb	 mov	 rcx, rbx
  00116	e8 00 00 00 00	 call	 Px_DecRef
$LN3@bytearrayi:

; 2979 :     PyObject_GC_Del(it);

  0011b	48 8b cf	 mov	 rcx, rdi

; 2980 : }

  0011e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00123	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00127	5f		 pop	 rdi
  00128	e9 00 00 00 00	 jmp	 PyObject_GC_Del
bytearrayiter_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@FAHDKPCB@bytearrayiter_traverse?$AA@	; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearrayiter_traverse DD imagerel bytearrayiter_traverse
	DD	imagerel bytearrayiter_traverse+97
	DD	imagerel $unwind$bytearrayiter_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearrayiter_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BH@FAHDKPCB@bytearrayiter_traverse?$AA@
CONST	SEGMENT
??_C@_0BH@FAHDKPCB@bytearrayiter_traverse?$AA@ DB 'bytearrayiter_traverse'
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearrayiter_traverse
_TEXT	SEGMENT
it$ = 48
visit$ = 56
arg$ = 64
bytearrayiter_traverse PROC				; COMDAT

; 2984 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 2985 :     Py_VISIT(it->it_seq);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN3@bytearrayi@2
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@FAHDKPCB@bytearrayiter_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 a9 0b 00
	00		 mov	 r8d, 2985		; 00000ba9H
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@bytearrayi@2:
  0003d	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00041	48 85 c9	 test	 rcx, rcx
  00044	74 09		 je	 SHORT $LN5@bytearrayi@2
  00046	48 8b d7	 mov	 rdx, rdi
  00049	ff d6		 call	 rsi
  0004b	85 c0		 test	 eax, eax
  0004d	75 02		 jne	 SHORT $LN7@bytearrayi@2
$LN5@bytearrayi@2:

; 2986 :     return 0;

  0004f	33 c0		 xor	 eax, eax
$LN7@bytearrayi@2:

; 2987 : }

  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
bytearrayiter_traverse ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearrayiter_next DD imagerel bytearrayiter_next
	DD	imagerel bytearrayiter_next+80
	DD	imagerel $unwind$bytearrayiter_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearrayiter_next DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytearrayiter_next
_TEXT	SEGMENT
it$ = 48
bytearrayiter_next PROC					; COMDAT

; 2991 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 2992 :     PyByteArrayObject *seq;
; 2993 :     PyObject *item;
; 2994 : 
; 2995 :     assert(it != NULL);
; 2996 :     seq = it->it_seq;

  00009	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]

; 2997 :     if (seq == NULL)

  0000d	48 85 c9	 test	 rcx, rcx

; 2998 :         return NULL;

  00010	74 36		 je	 SHORT $LN6@bytearrayi@3

; 2999 :     assert(PyByteArray_Check(seq));
; 3000 : 
; 3001 :     if (it->it_index < PyByteArray_GET_SIZE(seq)) {

  00012	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  00016	48 3b 51 60	 cmp	 rdx, QWORD PTR [rcx+96]
  0001a	7d 1f		 jge	 SHORT $LN2@bytearrayi@3

; 3002 :         item = PyLong_FromLong(
; 3003 :             (unsigned char)seq->ob_bytes[it->it_index]);

  0001c	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  00023	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]
  00027	e8 00 00 00 00	 call	 PyLong_FromLong

; 3004 :         if (item != NULL)

  0002c	48 85 c0	 test	 rax, rax
  0002f	74 19		 je	 SHORT $LN4@bytearrayi@3

; 3005 :             ++it->it_index;

  00031	48 ff 43 60	 inc	 QWORD PTR [rbx+96]

; 3012 : }

  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5b		 pop	 rbx
  0003a	c3		 ret	 0
$LN2@bytearrayi@3:

; 3006 :         return item;
; 3007 :     }
; 3008 : 
; 3009 :     Py_DECREF(seq);

  0003b	e8 00 00 00 00	 call	 _Py_DecRef

; 3010 :     it->it_seq = NULL;

  00040	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0
$LN6@bytearrayi@3:

; 3011 :     return NULL;

  00048	33 c0		 xor	 eax, eax
$LN4@bytearrayi@3:

; 3012 : }

  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5b		 pop	 rbx
  0004f	c3		 ret	 0
bytearrayiter_next ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bytearrayiter_length_hint
_TEXT	SEGMENT
it$ = 8
bytearrayiter_length_hint PROC				; COMDAT

; 3016 : {

  00000	48 8b c1	 mov	 rax, rcx

; 3017 :     Py_ssize_t len = 0;

  00003	33 c9		 xor	 ecx, ecx

; 3018 :     if (it->it_seq)

  00005	48 8b 50 68	 mov	 rdx, QWORD PTR [rax+104]
  00009	48 85 d2	 test	 rdx, rdx
  0000c	74 08		 je	 SHORT $LN1@bytearrayi@4

; 3019 :         len = PyByteArray_GET_SIZE(it->it_seq) - it->it_index;

  0000e	48 8b 4a 60	 mov	 rcx, QWORD PTR [rdx+96]
  00012	48 2b 48 60	 sub	 rcx, QWORD PTR [rax+96]
$LN1@bytearrayi@4:

; 3020 :     return PyLong_FromSsize_t(len);
; 3021 : }

  00016	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
bytearrayiter_length_hint ENDP
_TEXT	ENDS
PUBLIC	??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@		; `string'
PUBLIC	??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@		; `string'
PUBLIC	??_C@_04BKLHDIKK@iter?$AA@			; `string'
EXTRN	PyUnicode_FromUnicode:PROC
EXTRN	_PyObject_GetBuiltin:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytearrayiter_reduce DD imagerel bytearrayiter_reduce
	DD	imagerel bytearrayiter_reduce+134
	DD	imagerel $unwind$bytearrayiter_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearrayiter_reduce DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@
CONST	SEGMENT
??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@ DB 'N(N)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@
CONST	SEGMENT
??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@ DB 'N(O)n', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKLHDIKK@iter?$AA@
CONST	SEGMENT
??_C@_04BKLHDIKK@iter?$AA@ DB 'iter', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytearrayiter_reduce
_TEXT	SEGMENT
it$ = 48
bytearrayiter_reduce PROC				; COMDAT

; 3028 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3029 :     if (it->it_seq != NULL) {

  0000a	48 8b 79 68	 mov	 rdi, QWORD PTR [rcx+104]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	48 85 ff	 test	 rdi, rdi
  00014	74 2c		 je	 SHORT $LN3@bytearrayi@5

; 3030 :         return Py_BuildValue("N(O)n", _PyObject_GetBuiltin("iter"),
; 3031 :                              it->it_seq, it->it_index);

  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BKLHDIKK@iter?$AA@
  0001d	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  00022	4c 8b 4b 60	 mov	 r9, QWORD PTR [rbx+96]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@
  0002d	48 8b d0	 mov	 rdx, rax
  00030	4c 8b c7	 mov	 r8, rdi

; 3037 :     }
; 3038 : }

  00033	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5f		 pop	 rdi
  0003d	e9 00 00 00 00	 jmp	 _Py_BuildValue_SizeT
$LN3@bytearrayi@5:

; 3032 :     } else {
; 3033 :         PyObject *u = PyUnicode_FromUnicode(NULL, 0);

  00042	33 d2		 xor	 edx, edx
  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
  0004b	48 8b d8	 mov	 rbx, rax

; 3034 :         if (u == NULL)

  0004e	48 85 c0	 test	 rax, rax
  00051	75 0b		 jne	 SHORT $LN1@bytearrayi@5

; 3037 :     }
; 3038 : }

  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
$LN1@bytearrayi@5:

; 3035 :             return NULL;
; 3036 :         return Py_BuildValue("N(N)", _PyObject_GetBuiltin("iter"), u);

  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BKLHDIKK@iter?$AA@
  00065	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04IFNKFGDK@N?$CIN?$CJ?$AA@
  00071	4c 8b c3	 mov	 r8, rbx
  00074	48 8b d0	 mov	 rdx, rax

; 3037 :     }
; 3038 : }

  00077	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	5f		 pop	 rdi
  00081	e9 00 00 00 00	 jmp	 _Py_BuildValue_SizeT
bytearrayiter_reduce ENDP
_TEXT	ENDS
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytearrayiter_setstate DD imagerel bytearrayiter_setstate
	DD	imagerel bytearrayiter_setstate+134
	DD	imagerel $unwind$bytearrayiter_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearrayiter_setstate DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
xdata	ENDS
;	COMDAT bytearrayiter_setstate
_TEXT	SEGMENT
it$ = 64
state$ = 72
bytearrayiter_setstate PROC				; COMDAT

; 3042 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 3043 :     Py_ssize_t index = PyLong_AsSsize_t(state);

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	e8 00 00 00 00	 call	 PyLong_AsSsize_t

; 3044 :     if (index == -1 && PyErr_Occurred())

  00011	48 83 f8 ff	 cmp	 rax, -1
  00015	75 12		 jne	 SHORT $LN2@bytearrayi@6
  00017	e8 00 00 00 00	 call	 PyErr_Occurred
  0001c	48 85 c0	 test	 rax, rax
  0001f	74 0d		 je	 SHORT $LN9@bytearrayi@6

; 3045 :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 3050 : }

  00023	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
$LN2@bytearrayi@6:

; 3046 :     if (index < 0)

  00029	48 85 c0	 test	 rax, rax
  0002c	79 02		 jns	 SHORT $LN1@bytearrayi@6
$LN9@bytearrayi@6:

; 3047 :         index = 0;

  0002e	33 c0		 xor	 eax, eax
$LN1@bytearrayi@6:

; 3048 :     it->it_index = index;

  00030	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 3049 :     Py_RETURN_NONE;

  00034	e8 00 00 00 00	 call	 _Py_PXCTX
  00039	85 c0		 test	 eax, eax
  0003b	75 3c		 jne	 SHORT $LN6@bytearrayi@6
  0003d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00052	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00058	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00060	e8 00 00 00 00	 call	 _PyParallel_Guard
  00065	85 c0		 test	 eax, eax
  00067	75 09		 jne	 SHORT $LN5@bytearrayi@6
  00069	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00070	74 07		 je	 SHORT $LN6@bytearrayi@6
$LN5@bytearrayi@6:
  00072	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN6@bytearrayi@6:
  00079	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 3050 : }

  00080	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00084	5b		 pop	 rbx
  00085	c3		 ret	 0
bytearrayiter_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ ; `string'
PUBLIC	??_C@_0P@EKKBABNM@bytearray_iter?$AA@		; `string'
EXTRN	_PyGC_generation0:QWORD
EXTRN	Py_FatalError:PROC
EXTRN	_PyObject_GC_New:PROC
EXTRN	_PyErr_BadInternalCall:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytearray_iter DD imagerel bytearray_iter
	DD	imagerel bytearray_iter+59
	DD	imagerel $unwind$bytearray_iter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$bytearray_iter DD imagerel bytearray_iter+59
	DD	imagerel bytearray_iter+111
	DD	imagerel $chain$0$bytearray_iter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$bytearray_iter DD imagerel bytearray_iter+111
	DD	imagerel bytearray_iter+354
	DD	imagerel $chain$3$bytearray_iter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$bytearray_iter DD 040521H
	DD	083405H
	DD	097400H
	DD	imagerel bytearray_iter
	DD	imagerel bytearray_iter+59
	DD	imagerel $unwind$bytearray_iter
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$bytearray_iter DD 020521H
	DD	097405H
	DD	imagerel bytearray_iter
	DD	imagerel bytearray_iter+59
	DD	imagerel $unwind$bytearray_iter
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytearray_iter DD 020601H
	DD	060025206H
xdata	ENDS
;	COMDAT ??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
CONST	SEGMENT
??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ DB 'GC object alread'
	DB	'y tracked', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EKKBABNM@bytearray_iter?$AA@
CONST	SEGMENT
??_C@_0P@EKKBABNM@bytearray_iter?$AA@ DB 'bytearray_iter', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\bytearrayobject.c
CONST	ENDS
;	COMDAT bytearray_iter
_TEXT	SEGMENT
seq$ = 64
bytearray_iter PROC					; COMDAT

; 3099 : {

  00000	40 56		 push	 rsi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b f1	 mov	 rsi, rcx

; 3100 :     bytesiterobject *it;
; 3101 : 
; 3102 :     if (!PyByteArray_Check(seq)) {

  00009	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00014	48 3b ca	 cmp	 rcx, rdx
  00017	74 22		 je	 SHORT $LN7@bytearray_@47
  00019	e8 00 00 00 00	 call	 PyType_IsSubtype
  0001e	85 c0		 test	 eax, eax
  00020	75 19		 jne	 SHORT $LN7@bytearray_@47

; 3103 :         PyErr_BadInternalCall();

  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@
  00029	ba 1f 0c 00 00	 mov	 edx, 3103		; 00000c1fH
  0002e	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 3104 :         return NULL;

  00033	33 c0		 xor	 eax, eax

; 3114 : }

  00035	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00039	5e		 pop	 rsi
  0003a	c3		 ret	 0
$LN7@bytearray_@47:
  0003b	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 3105 :     }
; 3106 :     it = PyObject_GC_New(bytesiterobject, &PyByteArrayIter_Type);

  00040	e8 00 00 00 00	 call	 _Py_PXCTX
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyByteArrayIter_Type
  0004c	85 c0		 test	 eax, eax
  0004e	74 07		 je	 SHORT $LN10@bytearray_@47
  00050	e8 00 00 00 00	 call	 _PxObject_New
  00055	eb 05		 jmp	 SHORT $LN19@bytearray_@47
$LN10@bytearray_@47:
  00057	e8 00 00 00 00	 call	 _PyObject_GC_New
$LN19@bytearray_@47:
  0005c	48 8b f8	 mov	 rdi, rax

; 3107 :     if (it == NULL)

  0005f	48 85 c0	 test	 rax, rax
  00062	75 0b		 jne	 SHORT $LN6@bytearray_@47
  00064	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 3114 : }

  00069	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006d	5e		 pop	 rsi
  0006e	c3		 ret	 0
$LN6@bytearray_@47:
  0006f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 3108 :         return NULL;
; 3109 :     it->it_index = 0;

  00074	33 db		 xor	 ebx, ebx
  00076	48 89 5f 60	 mov	 QWORD PTR [rdi+96], rbx

; 3110 :     Py_INCREF(seq);

  0007a	e8 00 00 00 00	 call	 _Py_PXCTX
  0007f	85 c0		 test	 eax, eax
  00081	75 32		 jne	 SHORT $LN15@bytearray_@47
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00091	4c 8b ce	 mov	 r9, rsi
  00094	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0009a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a2	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a7	85 c0		 test	 eax, eax
  000a9	75 06		 jne	 SHORT $LN14@bytearray_@47
  000ab	f6 46 20 20	 test	 BYTE PTR [rsi+32], 32	; 00000020H
  000af	74 04		 je	 SHORT $LN15@bytearray_@47
$LN14@bytearray_@47:
  000b1	48 ff 46 50	 inc	 QWORD PTR [rsi+80]
$LN15@bytearray_@47:

; 3111 :     it->it_seq = (PyByteArrayObject *)seq;
; 3112 :     _PyObject_GC_TRACK(it);

  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@EKKBABNM@bytearray_iter?$AA@
  000c3	4c 8b cf	 mov	 r9, rdi
  000c6	41 b8 28 0c 00
	00		 mov	 r8d, 3112		; 00000c28H
  000cc	48 89 77 68	 mov	 QWORD PTR [rdi+104], rsi
  000d0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000dd	85 c0		 test	 eax, eax
  000df	75 6e		 jne	 SHORT $LN2@bytearray_@47
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@FLILKPAO@?4?4?2Objects?2bytearrayobject?4c?$AA@
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@EKKBABNM@bytearray_iter?$AA@
  000ef	4c 8b cf	 mov	 r9, rdi
  000f2	41 b8 28 0c 00
	00		 mov	 r8d, 3112		; 00000c28H
  000f8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00100	e8 00 00 00 00	 call	 _PyParallel_Guard
  00105	85 c0		 test	 eax, eax
  00107	75 04		 jne	 SHORT $LN13@bytearray_@47
  00109	48 8d 5f e8	 lea	 rbx, QWORD PTR [rdi-24]
$LN13@bytearray_@47:
  0010d	48 83 7b 10 fe	 cmp	 QWORD PTR [rbx+16], -2
  00112	74 0c		 je	 SHORT $LN1@bytearray_@47
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
  0011b	e8 00 00 00 00	 call	 Py_FatalError
$LN1@bytearray_@47:
  00120	48 c7 43 10 fd
	ff ff ff	 mov	 QWORD PTR [rbx+16], -3
  00128	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  0012f	48 89 03	 mov	 QWORD PTR [rbx], rax
  00132	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  00139	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0013d	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx
  00141	48 89 19	 mov	 QWORD PTR [rcx], rbx
  00144	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  0014b	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
$LN2@bytearray_@47:

; 3113 :     return (PyObject *)it;

  0014f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00154	48 8b c7	 mov	 rax, rdi
  00157	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 3114 : }

  0015c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00160	5e		 pop	 rsi
  00161	c3		 ret	 0
bytearray_iter ENDP
_TEXT	ENDS
END
