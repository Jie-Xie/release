; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
smallmax DD	00H
	DD	00H
	DD	07fffffffH
	DD	055555555H
	DD	03fffffffH
	DD	033333333H
	DD	02aaaaaaaH
	DD	024924924H
	DD	01fffffffH
	DD	01c71c71cH
	DD	019999999H
	DD	01745d174H
	DD	015555555H
	DD	013b13b13H
	DD	012492492H
	DD	011111111H
	DD	0fffffffH
	DD	0f0f0f0fH
	DD	0e38e38eH
	DD	0d79435eH
	DD	0cccccccH
	DD	0c30c30cH
	DD	0ba2e8baH
	DD	0b21642cH
	DD	0aaaaaaaH
	DD	0a3d70a3H
	DD	09d89d89H
	DD	097b425eH
	DD	09249249H
	DD	08d3dcb0H
	DD	08888888H
	DD	08421084H
	DD	07ffffffH
	DD	07c1f07cH
	DD	07878787H
	DD	07507507H
	DD	071c71c7H
	ORG $+12
digitlimit DD	00H
	DD	00H
	DD	020H
	DD	014H
	DD	010H
	DD	0dH
	DD	0cH
	DD	0bH
	DD	0aH
	DD	0aH
	DD	09H
	DD	09H
	DD	08H
	DD	08H
	DD	08H
	DD	08H
	DD	08H
	DD	07H
	DD	07H
	DD	07H
	DD	07H
	DD	07H
	DD	07H
	DD	07H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
	DD	06H
_DATA	ENDS
PUBLIC	PyOS_strtoul
EXTRN	__imp__errno:PROC
EXTRN	_PyLong_DigitValue:BYTE
EXTRN	_Py_ctype_table:BYTE
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\python\mystrtoul.c
pdata	SEGMENT
$pdata$PyOS_strtoul DD imagerel $LN86
	DD	imagerel $LN86+501
	DD	imagerel $unwind$PyOS_strtoul
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyOS_strtoul DD imagerel $LN86+501
	DD	imagerel $LN86+636
	DD	imagerel $chain$0$PyOS_strtoul
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyOS_strtoul DD imagerel $LN86+636
	DD	imagerel $LN86+706
	DD	imagerel $chain$2$PyOS_strtoul
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyOS_strtoul DD 020021H
	DD	063400H
	DD	imagerel $LN86
	DD	imagerel $LN86+501
	DD	imagerel $unwind$PyOS_strtoul
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyOS_strtoul DD 020521H
	DD	063405H
	DD	imagerel $LN86
	DD	imagerel $LN86+501
	DD	imagerel $unwind$PyOS_strtoul
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_strtoul DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyOS_strtoul
_TEXT	SEGMENT
str$ = 48
ptr$ = 56
base$ = 64
PyOS_strtoul PROC					; COMDAT

; 96   : {

$LN86:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 97   :     register unsigned long result = 0; /* return value of the function */
; 98   :     register int c;             /* current input character */
; 99   :     register int ovlimit;       /* required digits to overflow */
; 100  : 
; 101  :     /* skip leading white space */
; 102  :     while (*str && Py_ISSPACE(Py_CHARMASK(*str)))

  00006	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00009	45 33 c9	 xor	 r9d, r9d
  0000c	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:__ImageBase
  00013	84 c0		 test	 al, al
  00015	74 21		 je	 SHORT $LN82@PyOS_strto
  00017	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL61@PyOS_strto:
  00020	0f b6 c0	 movzx	 eax, al
  00023	f6 84 87 00 00
	00 00 08	 test	 BYTE PTR _Py_ctype_table[rdi+rax*4], 8
  0002b	74 0b		 je	 SHORT $LN82@PyOS_strto
  0002d	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 103  :         ++str;

  00031	48 ff c1	 inc	 rcx
  00034	84 c0		 test	 al, al
  00036	75 e8		 jne	 SHORT $LL61@PyOS_strto
$LN82@PyOS_strto:

; 104  : 
; 105  :     /* check for leading 0b, 0o or 0x for auto-base or base 16 */
; 106  :     switch (base) {

  00038	45 85 c0	 test	 r8d, r8d
  0003b	0f 84 ec 00 00
	00		 je	 $LN57@PyOS_strto
  00041	41 83 f8 02	 cmp	 r8d, 2
  00045	0f 84 a4 00 00
	00		 je	 $LN22@PyOS_strto
  0004b	41 83 f8 08	 cmp	 r8d, 8
  0004f	74 60		 je	 SHORT $LN28@PyOS_strto
  00051	41 83 f8 10	 cmp	 r8d, 16
  00055	75 36		 jne	 SHORT $LN35@PyOS_strto

; 150  :         break;
; 151  : 
; 152  :     /* even with explicit base, skip leading 0? prefix */
; 153  :     case 16:
; 154  :         if (*str == '0') {

  00057	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  0005a	0f 85 92 01 00
	00		 jne	 $LN80@PyOS_strto

; 155  :             ++str;
; 156  :             if (*str == 'x' || *str == 'X') {

  00060	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00064	48 ff c1	 inc	 rcx
  00067	3c 78		 cmp	 al, 120			; 00000078H
  00069	74 08		 je	 SHORT $LN31@PyOS_strto
  0006b	3c 58		 cmp	 al, 88			; 00000058H
  0006d	0f 85 7f 01 00
	00		 jne	 $LN80@PyOS_strto
$LN31@PyOS_strto:

; 157  :                 /* there must be at least one digit after 0x */
; 158  :                 if (_PyLong_DigitValue[Py_CHARMASK(str[1])] >= 16) {

  00073	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00077	80 bc 38 00 00
	00 00 10	 cmp	 BYTE PTR _PyLong_DigitValue[rax+rdi], 16

; 159  :                     if (ptr)
; 160  :                         *ptr = str;
; 161  :                     return 0;

  0007f	0f 83 0c 01 00
	00		 jae	 $LN37@PyOS_strto
$LN30@PyOS_strto:

; 162  :                 }
; 163  :                 ++str;

  00085	48 ff c1	 inc	 rcx

; 164  :             }
; 165  :         }
; 166  :         break;

  00088	e9 65 01 00 00	 jmp	 $LN80@PyOS_strto
$LN35@PyOS_strto:

; 190  :                 }
; 191  :                 ++str;
; 192  :             }
; 193  :         }
; 194  :         break;
; 195  :     }
; 196  : 
; 197  :     /* catch silly bases */
; 198  :     if (base < 2 || base > 36) {

  0008d	41 83 f8 02	 cmp	 r8d, 2
  00091	7c 0a		 jl	 SHORT $LN15@PyOS_strto
  00093	41 83 f8 24	 cmp	 r8d, 36			; 00000024H
  00097	0f 8e 55 01 00
	00		 jle	 $LN80@PyOS_strto
$LN15@PyOS_strto:

; 199  :         if (ptr)

  0009d	48 85 d2	 test	 rdx, rdx
  000a0	0f 84 f3 00 00
	00		 je	 $LN52@PyOS_strto

; 200  :             *ptr = str;

  000a6	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 201  :         return 0;

  000a9	33 c0		 xor	 eax, eax

; 255  : }

  000ab	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000af	5f		 pop	 rdi
  000b0	c3		 ret	 0
$LN28@PyOS_strto:

; 167  :     case 8:
; 168  :         if (*str == '0') {

  000b1	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  000b4	0f 85 38 01 00
	00		 jne	 $LN80@PyOS_strto

; 169  :             ++str;
; 170  :             if (*str == 'o' || *str == 'O') {

  000ba	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000be	48 ff c1	 inc	 rcx
  000c1	3c 6f		 cmp	 al, 111			; 0000006fH
  000c3	74 08		 je	 SHORT $LN25@PyOS_strto
  000c5	3c 4f		 cmp	 al, 79			; 0000004fH
  000c7	0f 85 25 01 00
	00		 jne	 $LN80@PyOS_strto
$LN25@PyOS_strto:

; 171  :                 /* there must be at least one digit after 0o */
; 172  :                 if (_PyLong_DigitValue[Py_CHARMASK(str[1])] >= 8) {

  000cd	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000d1	80 bc 38 00 00
	00 00 08	 cmp	 BYTE PTR _PyLong_DigitValue[rax+rdi], 8
  000d9	72 aa		 jb	 SHORT $LN30@PyOS_strto

; 173  :                     if (ptr)

  000db	48 85 d2	 test	 rdx, rdx
  000de	0f 84 b5 00 00
	00		 je	 $LN52@PyOS_strto

; 174  :                         *ptr = str;

  000e4	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 175  :                     return 0;

  000e7	33 c0		 xor	 eax, eax

; 255  : }

  000e9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ed	5f		 pop	 rdi
  000ee	c3		 ret	 0
$LN22@PyOS_strto:

; 176  :                 }
; 177  :                 ++str;
; 178  :             }
; 179  :         }
; 180  :         break;
; 181  :     case 2:
; 182  :         if(*str == '0') {

  000ef	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  000f2	0f 85 fa 00 00
	00		 jne	 $LN80@PyOS_strto

; 183  :             ++str;
; 184  :             if (*str == 'b' || *str == 'B') {

  000f8	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000fc	48 ff c1	 inc	 rcx
  000ff	3c 62		 cmp	 al, 98			; 00000062H
  00101	74 08		 je	 SHORT $LN19@PyOS_strto
  00103	3c 42		 cmp	 al, 66			; 00000042H
  00105	0f 85 e7 00 00
	00		 jne	 $LN80@PyOS_strto
$LN19@PyOS_strto:

; 185  :                 /* there must be at least one digit after 0b */
; 186  :                 if (_PyLong_DigitValue[Py_CHARMASK(str[1])] >= 2) {

  0010b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0010f	80 bc 38 00 00
	00 00 02	 cmp	 BYTE PTR _PyLong_DigitValue[rax+rdi], 2
  00117	0f 82 68 ff ff
	ff		 jb	 $LN30@PyOS_strto

; 187  :                     if (ptr)

  0011d	48 85 d2	 test	 rdx, rdx
  00120	74 77		 je	 SHORT $LN52@PyOS_strto

; 188  :                         *ptr = str;

  00122	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 189  :                     return 0;

  00125	33 c0		 xor	 eax, eax

; 255  : }

  00127	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0012b	5f		 pop	 rdi
  0012c	c3		 ret	 0
$LN57@PyOS_strto:

; 107  :     case 0:             /* look for leading 0b, 0o or 0x */
; 108  :         if (*str == '0') {

  0012d	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00130	0f 85 b6 00 00
	00		 jne	 $LN56@PyOS_strto

; 109  :             ++str;
; 110  :             if (*str == 'x' || *str == 'X') {

  00136	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  0013a	48 ff c1	 inc	 rcx
  0013d	3c 78		 cmp	 al, 120			; 00000078H
  0013f	0f 84 8e 00 00
	00		 je	 $LN54@PyOS_strto
  00145	3c 58		 cmp	 al, 88			; 00000058H
  00147	0f 84 86 00 00
	00		 je	 $LN54@PyOS_strto

; 119  :             } else if (*str == 'o' || *str == 'O') {

  0014d	3c 6f		 cmp	 al, 111			; 0000006fH
  0014f	74 69		 je	 SHORT $LN49@PyOS_strto
  00151	3c 4f		 cmp	 al, 79			; 0000004fH
  00153	74 65		 je	 SHORT $LN49@PyOS_strto

; 128  :             } else if (*str == 'b' || *str == 'B') {

  00155	3c 62		 cmp	 al, 98			; 00000062H
  00157	74 48		 je	 SHORT $LN44@PyOS_strto
  00159	3c 42		 cmp	 al, 66			; 00000042H
  0015b	74 44		 je	 SHORT $LN44@PyOS_strto

; 138  :                 /* skip all zeroes... */
; 139  :                 while (*str == '0')

  0015d	3c 30		 cmp	 al, 48			; 00000030H
  0015f	75 08		 jne	 SHORT $LN66@PyOS_strto
$LL40@PyOS_strto:

; 140  :                     ++str;

  00161	48 ff c1	 inc	 rcx
  00164	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00167	74 f8		 je	 SHORT $LL40@PyOS_strto
$LN66@PyOS_strto:

; 141  :                 while (Py_ISSPACE(Py_CHARMASK(*str)))

  00169	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  0016c	f6 84 87 00 00
	00 00 08	 test	 BYTE PTR _Py_ctype_table[rdi+rax*4], 8
  00174	74 1b		 je	 SHORT $LN37@PyOS_strto
  00176	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL38@PyOS_strto:
  00180	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 142  :                     ++str;

  00184	48 ff c1	 inc	 rcx
  00187	f6 84 87 00 00
	00 00 08	 test	 BYTE PTR _Py_ctype_table[rdi+rax*4], 8
  0018f	75 ef		 jne	 SHORT $LL38@PyOS_strto
$LN37@PyOS_strto:

; 143  :                 if (ptr)

  00191	48 85 d2	 test	 rdx, rdx
  00194	74 03		 je	 SHORT $LN52@PyOS_strto

; 144  :                     *ptr = str;

  00196	48 89 0a	 mov	 QWORD PTR [rdx], rcx
$LN52@PyOS_strto:

; 145  :                 return 0;

  00199	33 c0		 xor	 eax, eax

; 255  : }

  0019b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0019f	5f		 pop	 rdi
  001a0	c3		 ret	 0
$LN44@PyOS_strto:

; 129  :                 /* there must be at least one digit after 0b */
; 130  :                 if (_PyLong_DigitValue[Py_CHARMASK(str[1])] >= 2) {

  001a1	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  001a5	80 bc 38 00 00
	00 00 02	 cmp	 BYTE PTR _PyLong_DigitValue[rax+rdi], 2

; 131  :                     if (ptr)
; 132  :                         *ptr = str;
; 133  :                     return 0;

  001ad	73 e2		 jae	 SHORT $LN37@PyOS_strto

; 134  :                 }
; 135  :                 ++str;

  001af	48 ff c1	 inc	 rcx

; 136  :                 base = 2;

  001b2	41 b8 02 00 00
	00		 mov	 r8d, 2

; 137  :             } else {

  001b8	eb 38		 jmp	 SHORT $LN80@PyOS_strto
$LN49@PyOS_strto:

; 120  :                 /* there must be at least one digit after 0o */
; 121  :                 if (_PyLong_DigitValue[Py_CHARMASK(str[1])] >= 8) {

  001ba	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  001be	80 bc 38 00 00
	00 00 08	 cmp	 BYTE PTR _PyLong_DigitValue[rax+rdi], 8

; 122  :                     if (ptr)
; 123  :                         *ptr = str;
; 124  :                     return 0;

  001c6	73 c9		 jae	 SHORT $LN37@PyOS_strto

; 125  :                 }
; 126  :                 ++str;

  001c8	48 ff c1	 inc	 rcx

; 127  :                 base = 8;

  001cb	41 b8 08 00 00
	00		 mov	 r8d, 8
  001d1	eb 1f		 jmp	 SHORT $LN80@PyOS_strto
$LN54@PyOS_strto:

; 111  :                 /* there must be at least one digit after 0x */
; 112  :                 if (_PyLong_DigitValue[Py_CHARMASK(str[1])] >= 16) {

  001d3	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  001d7	80 bc 38 00 00
	00 00 10	 cmp	 BYTE PTR _PyLong_DigitValue[rax+rdi], 16

; 113  :                     if (ptr)
; 114  :                         *ptr = str;
; 115  :                     return 0;

  001df	73 b0		 jae	 SHORT $LN37@PyOS_strto

; 116  :                 }
; 117  :                 ++str;

  001e1	48 ff c1	 inc	 rcx

; 118  :                 base = 16;

  001e4	41 b8 10 00 00
	00		 mov	 r8d, 16

; 146  :             }
; 147  :         }
; 148  :         else

  001ea	eb 06		 jmp	 SHORT $LN80@PyOS_strto
$LN56@PyOS_strto:

; 149  :             base = 10;

  001ec	41 b8 0a 00 00
	00		 mov	 r8d, 10
$LN80@PyOS_strto:

; 202  :     }
; 203  : 
; 204  :     /* skip leading zeroes */
; 205  :     while (*str == '0')

  001f2	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  001f5	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  001fa	75 0c		 jne	 SHORT $LN12@PyOS_strto
  001fc	0f 1f 40 00	 npad	 4
$LL13@PyOS_strto:

; 206  :         ++str;

  00200	48 ff c1	 inc	 rcx
  00203	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00206	74 f8		 je	 SHORT $LL13@PyOS_strto
$LN12@PyOS_strto:

; 207  : 
; 208  :     /* base is guaranteed to be in [2, 36] at this point */
; 209  :     ovlimit = digitlimit[base];
; 210  : 
; 211  :     /* do the conversion until non-digit character encountered */
; 212  :     while ((c = _PyLong_DigitValue[Py_CHARMASK(*str)]) < base) {

  00208	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  0020b	49 63 d8	 movsxd	 rbx, r8d
  0020e	44 0f b6 9c 38
	00 00 00 00	 movzx	 r11d, BYTE PTR _PyLong_DigitValue[rax+rdi]
  00217	44 8b 94 9f 00
	00 00 00	 mov	 r10d, DWORD PTR digitlimit[rdi+rbx*4]
  0021f	45 3b d8	 cmp	 r11d, r8d
  00222	7d 42		 jge	 SHORT $LN10@PyOS_strto
$LL11@PyOS_strto:

; 213  :         if (ovlimit > 0) /* no overflow check required */

  00224	45 85 d2	 test	 r10d, r10d
  00227	7e 09		 jle	 SHORT $LN84@PyOS_strto

; 214  :             result = result * base + c;

  00229	45 0f af c8	 imul	 r9d, r8d
  0022d	45 03 cb	 add	 r9d, r11d

; 215  :         else { /* requires overflow check */

  00230	eb 1c		 jmp	 SHORT $LN8@PyOS_strto
$LN84@PyOS_strto:

; 216  :             register unsigned long temp_result;
; 217  : 
; 218  :             if (ovlimit < 0) /* guaranteed overflow */

  00232	78 48		 js	 SHORT $overflowed$20264

; 219  :                 goto overflowed;
; 220  : 
; 221  :             /* there could be an overflow */
; 222  :             /* check overflow just from shifting */
; 223  :             if (result > smallmax[base])

  00234	44 3b 8c 9f 00
	00 00 00	 cmp	 r9d, DWORD PTR smallmax[rdi+rbx*4]
  0023c	77 3e		 ja	 SHORT $overflowed$20264

; 224  :                 goto overflowed;
; 225  : 
; 226  :             result *= base;

  0023e	45 0f af c8	 imul	 r9d, r8d

; 227  : 
; 228  :             /* check overflow from the digit's value */
; 229  :             temp_result = result + c;

  00242	43 8d 04 0b	 lea	 eax, DWORD PTR [r11+r9]

; 230  :             if (temp_result < result)

  00246	41 3b c1	 cmp	 eax, r9d
  00249	72 31		 jb	 SHORT $overflowed$20264

; 231  :                 goto overflowed;
; 232  : 
; 233  :             result = temp_result;

  0024b	44 8b c8	 mov	 r9d, eax
$LN8@PyOS_strto:

; 207  : 
; 208  :     /* base is guaranteed to be in [2, 36] at this point */
; 209  :     ovlimit = digitlimit[base];
; 210  : 
; 211  :     /* do the conversion until non-digit character encountered */
; 212  :     while ((c = _PyLong_DigitValue[Py_CHARMASK(*str)]) < base) {

  0024e	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 234  :         }
; 235  : 
; 236  :         ++str;

  00252	48 ff c1	 inc	 rcx

; 237  :         --ovlimit;

  00255	41 ff ca	 dec	 r10d
  00258	44 0f b6 9c 38
	00 00 00 00	 movzx	 r11d, BYTE PTR _PyLong_DigitValue[rax+rdi]
  00261	45 3b d8	 cmp	 r11d, r8d
  00264	7c be		 jl	 SHORT $LL11@PyOS_strto
$LN10@PyOS_strto:

; 238  :     }
; 239  : 
; 240  :     /* set pointer to point to the last character scanned */
; 241  :     if (ptr)

  00266	48 85 d2	 test	 rdx, rdx
  00269	74 03		 je	 SHORT $LN4@PyOS_strto

; 242  :         *ptr = str;

  0026b	48 89 0a	 mov	 QWORD PTR [rdx], rcx
$LN4@PyOS_strto:

; 243  : 
; 244  :     return result;

  0026e	41 8b c1	 mov	 eax, r9d
  00271	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 255  : }

  00276	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0027a	5f		 pop	 rdi
  0027b	c3		 ret	 0
$overflowed$20264:

; 245  : 
; 246  : overflowed:
; 247  :     if (ptr) {

  0027c	48 85 d2	 test	 rdx, rdx
  0027f	74 27		 je	 SHORT $LN3@PyOS_strto

; 248  :         /* spool through remaining digit characters */
; 249  :         while (_PyLong_DigitValue[Py_CHARMASK(*str)] < base)

  00281	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00284	0f b6 84 38 00
	00 00 00	 movzx	 eax, BYTE PTR _PyLong_DigitValue[rax+rdi]
  0028c	41 3b c0	 cmp	 eax, r8d
  0028f	7d 14		 jge	 SHORT $LN1@PyOS_strto
$LL2@PyOS_strto:
  00291	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 250  :             ++str;

  00295	48 ff c1	 inc	 rcx
  00298	0f b6 84 38 00
	00 00 00	 movzx	 eax, BYTE PTR _PyLong_DigitValue[rax+rdi]
  002a0	41 3b c0	 cmp	 eax, r8d
  002a3	7c ec		 jl	 SHORT $LL2@PyOS_strto
$LN1@PyOS_strto:

; 251  :         *ptr = str;

  002a5	48 89 0a	 mov	 QWORD PTR [rdx], rcx
$LN3@PyOS_strto:

; 252  :     }
; 253  :     errno = ERANGE;

  002a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002ae	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  002b3	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H

; 254  :     return (unsigned long)-1;

  002b9	83 c8 ff	 or	 eax, -1			; ffffffffH

; 255  : }

  002bc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002c0	5f		 pop	 rdi
  002c1	c3		 ret	 0
PyOS_strtoul ENDP
_TEXT	ENDS
PUBLIC	PyOS_strtol
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOS_strtol DD imagerel $LN16
	DD	imagerel $LN16+128
	DD	imagerel $unwind$PyOS_strtol
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_strtol DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyOS_strtol
_TEXT	SEGMENT
str$ = 48
ptr$ = 56
base$ = 64
PyOS_strtol PROC					; COMDAT

; 264  : {

$LN16:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 265  :     long result;
; 266  :     unsigned long uresult;
; 267  :     char sign;
; 268  : 
; 269  :     while (*str && Py_ISSPACE(Py_CHARMASK(*str)))

  00006	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00009	84 c0		 test	 al, al
  0000b	74 1c		 je	 SHORT $LN15@PyOS_strto@2
  0000d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_ctype_table
$LL9@PyOS_strto@2:
  00014	0f b6 c0	 movzx	 eax, al
  00017	41 f6 04 81 08	 test	 BYTE PTR [r9+rax*4], 8
  0001c	74 0b		 je	 SHORT $LN15@PyOS_strto@2
  0001e	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 270  :         str++;

  00022	48 ff c1	 inc	 rcx
  00025	84 c0		 test	 al, al
  00027	75 eb		 jne	 SHORT $LL9@PyOS_strto@2
$LN15@PyOS_strto@2:

; 271  : 
; 272  :     sign = *str;

  00029	0f b6 19	 movzx	 ebx, BYTE PTR [rcx]

; 273  :     if (sign == '+' || sign == '-')

  0002c	80 fb 2b	 cmp	 bl, 43			; 0000002bH
  0002f	74 05		 je	 SHORT $LN6@PyOS_strto@2
  00031	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  00034	75 03		 jne	 SHORT $LN7@PyOS_strto@2
$LN6@PyOS_strto@2:

; 274  :         str++;

  00036	48 ff c1	 inc	 rcx
$LN7@PyOS_strto@2:

; 275  : 
; 276  :     uresult = PyOS_strtoul(str, ptr, base);

  00039	e8 00 00 00 00	 call	 PyOS_strtoul

; 277  : 
; 278  :     if (uresult <= (unsigned long)LONG_MAX) {

  0003e	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00043	77 0d		 ja	 SHORT $LN5@PyOS_strto@2

; 279  :         result = (long)uresult;
; 280  :         if (sign == '-')

  00045	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  00048	75 30		 jne	 SHORT $LN1@PyOS_strto@2

; 281  :             result = -result;

  0004a	f7 d8		 neg	 eax

; 291  : }

  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5b		 pop	 rbx
  00051	c3		 ret	 0
$LN5@PyOS_strto@2:

; 282  :     }
; 283  :     else if (sign == '-' && uresult == PY_ABS_LONG_MIN) {

  00052	80 fb 2d	 cmp	 bl, 45			; 0000002dH
  00055	75 12		 jne	 SHORT $LN2@PyOS_strto@2
  00057	3d 00 00 00 80	 cmp	 eax, -2147483648	; 80000000H
  0005c	75 0b		 jne	 SHORT $LN2@PyOS_strto@2

; 288  :         result = LONG_MAX;
; 289  :     }
; 290  :     return result;

  0005e	b8 00 00 00 80	 mov	 eax, -2147483648	; ffffffff80000000H

; 291  : }

  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5b		 pop	 rbx
  00068	c3		 ret	 0
$LN2@PyOS_strto@2:

; 284  :         result = LONG_MIN;
; 285  :     }
; 286  :     else {
; 287  :         errno = ERANGE;

  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0006f	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H

; 288  :         result = LONG_MAX;
; 289  :     }
; 290  :     return result;

  00075	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN1@PyOS_strto@2:

; 291  : }

  0007a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007e	5b		 pop	 rbx
  0007f	c3		 ret	 0
PyOS_strtol ENDP
_TEXT	ENDS
END
