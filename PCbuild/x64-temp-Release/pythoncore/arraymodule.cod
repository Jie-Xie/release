; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05HIFJDKLD@array?$AA@			; `string'
PUBLIC	??_C@_0CF@GMIJNGPM@Internal?4?5Used?5for?5pickling?5supp@ ; `string'
PUBLIC	??_C@_0O@OPHKEACL@arrayiterator?$AA@		; `string'
PUBLIC	??_C@_0N@MOOGCAMH@__setstate__?$AA@		; `string'
PUBLIC	??_C@_0L@NNMACJIG@__reduce__?$AA@		; `string'
PUBLIC	??_C@_0M@DCMOJOBC@array?4array?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0L@HOGGIPGN@__sizeof__?$AA@		; `string'
PUBLIC	??_C@_09JKEMBMBG@tounicode?$AA@			; `string'
PUBLIC	??_C@_07NAJELLCK@tobytes?$AA@			; `string'
PUBLIC	??_C@_08FNIIFOJC@tostring?$AA@			; `string'
PUBLIC	??_C@_06IEBOCBAI@tolist?$AA@			; `string'
PUBLIC	??_C@_06IKANPOPE@tofile?$AA@			; `string'
PUBLIC	??_C@_07KOIEOCCE@reverse?$AA@			; `string'
PUBLIC	??_C@_06LEMKAMD@remove?$AA@			; `string'
PUBLIC	??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@		; `string'
PUBLIC	??_C@_03NJDAHFJE@pop?$AA@			; `string'
PUBLIC	??_C@_06OAOPNKHP@insert?$AA@			; `string'
PUBLIC	??_C@_05FKHKFDID@index?$AA@			; `string'
PUBLIC	??_C@_0M@JCIKMCEM@fromunicode?$AA@		; `string'
PUBLIC	??_C@_09OCNOKPAF@frombytes?$AA@			; `string'
PUBLIC	??_C@_0L@PGGLCJNP@fromstring?$AA@		; `string'
PUBLIC	??_C@_08BGGGONCE@fromlist?$AA@			; `string'
PUBLIC	??_C@_08BIHFDCNI@fromfile?$AA@			; `string'
PUBLIC	??_C@_06BPBOMFNI@extend?$AA@			; `string'
PUBLIC	??_C@_0N@LCDCNIJ@__deepcopy__?$AA@		; `string'
PUBLIC	??_C@_05IOMEMJEC@count?$AA@			; `string'
PUBLIC	??_C@_08MOMBEIKE@__copy__?$AA@			; `string'
PUBLIC	??_C@_08LGNCHIMC@byteswap?$AA@			; `string'
PUBLIC	??_C@_0M@MDHGDJKG@buffer_info?$AA@		; `string'
PUBLIC	??_C@_06PCICMFGG@append?$AA@			; `string'
PUBLIC	??_C@_0CG@DALNPKGO@the?5size?0?5in?5bytes?0?5of?5one?5array@ ; `string'
PUBLIC	??_C@_08BFHIGMPA@itemsize?$AA@			; `string'
PUBLIC	??_C@_0DA@HJNMFPLE@the?5typecode?5character?5used?5to?5c@ ; `string'
PUBLIC	??_C@_08FJHEKLCH@typecode?$AA@			; `string'
PUBLIC	??_C@_08IBFKALI@__dict__?$AA@			; `string'
PUBLIC	??_C@_0BF@FHDBJGA@_array_reconstructor?$AA@	; `string'
PUBLIC	??_C@_05NGFEDHGN@write?$AA@			; `string'
PUBLIC	??_C@_04POLDLDMI@read?$AA@			; `string'
PUBLIC	??_C@_01LPLHEDKD@d?$AA@				; `string'
PUBLIC	??_C@_01INIBCBCB@f?$AA@				; `string'
PUBLIC	??_C@_01BNIGIBBF@Q?$AA@				; `string'
PUBLIC	??_C@_01IIACKFLH@q?$AA@				; `string'
PUBLIC	??_C@_01OCOKONAJ@L?$AA@				; `string'
PUBLIC	??_C@_01HHGOMJKL@l?$AA@				; `string'
PUBLIC	??_C@_01JPJNBJEM@I?$AA@				; `string'
PUBLIC	??_C@_01KBJDNOO@i?$AA@				; `string'
PUBLIC	??_C@_01IGIGCIAN@H?$AA@				; `string'
PUBLIC	??_C@_01BDACAMKP@h?$AA@				; `string'
PUBLIC	??_C@_01OMGOGALD@u?$AA@				; `string'
PUBLIC	??_C@_01HMGJMAIH@B?$AA@				; `string'
PUBLIC	??_C@_01OJONOECF@b?$AA@				; `string'
EXTRN	PyObject_SelfIter:PROC
EXTRN	PyObject_Free:PROC
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyObject_GenericGetAttr:PROC
_BSS	SEGMENT
?array_reconstructor@?1??array_reduce_ex@@9@9 DQ 01H DUP (?) ; `array_reduce_ex'::`2'::array_reconstructor
_BSS	ENDS
;	COMDAT ??_C@_05HIFJDKLD@array?$AA@
CONST	SEGMENT
??_C@_05HIFJDKLD@array?$AA@ DB 'array', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GMIJNGPM@Internal?4?5Used?5for?5pickling?5supp@
CONST	SEGMENT
??_C@_0CF@GMIJNGPM@Internal?4?5Used?5for?5pickling?5supp@ DB 'Internal. U'
	DB	'sed for pickling support.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OPHKEACL@arrayiterator?$AA@
CONST	SEGMENT
??_C@_0O@OPHKEACL@arrayiterator?$AA@ DB 'arrayiterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOOGCAMH@__setstate__?$AA@
CONST	SEGMENT
??_C@_0N@MOOGCAMH@__setstate__?$AA@ DB '__setstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNMACJIG@__reduce__?$AA@
CONST	SEGMENT
??_C@_0L@NNMACJIG@__reduce__?$AA@ DB '__reduce__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DCMOJOBC@array?4array?$AA@
CONST	SEGMENT
??_C@_0M@DCMOJOBC@array?4array?$AA@ DB 'array.array', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGGIPGN@__sizeof__?$AA@
CONST	SEGMENT
??_C@_0L@HOGGIPGN@__sizeof__?$AA@ DB '__sizeof__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JKEMBMBG@tounicode?$AA@
CONST	SEGMENT
??_C@_09JKEMBMBG@tounicode?$AA@ DB 'tounicode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NAJELLCK@tobytes?$AA@
CONST	SEGMENT
??_C@_07NAJELLCK@tobytes?$AA@ DB 'tobytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FNIIFOJC@tostring?$AA@
CONST	SEGMENT
??_C@_08FNIIFOJC@tostring?$AA@ DB 'tostring', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IEBOCBAI@tolist?$AA@
CONST	SEGMENT
??_C@_06IEBOCBAI@tolist?$AA@ DB 'tolist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKANPOPE@tofile?$AA@
CONST	SEGMENT
??_C@_06IKANPOPE@tofile?$AA@ DB 'tofile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KOIEOCCE@reverse?$AA@
CONST	SEGMENT
??_C@_07KOIEOCCE@reverse?$AA@ DB 'reverse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LEMKAMD@remove?$AA@
CONST	SEGMENT
??_C@_06LEMKAMD@remove?$AA@ DB 'remove', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@
CONST	SEGMENT
??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@ DB '__reduce_ex__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJDAHFJE@pop?$AA@
CONST	SEGMENT
??_C@_03NJDAHFJE@pop?$AA@ DB 'pop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06OAOPNKHP@insert?$AA@
CONST	SEGMENT
??_C@_06OAOPNKHP@insert?$AA@ DB 'insert', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKHKFDID@index?$AA@
CONST	SEGMENT
??_C@_05FKHKFDID@index?$AA@ DB 'index', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JCIKMCEM@fromunicode?$AA@
CONST	SEGMENT
??_C@_0M@JCIKMCEM@fromunicode?$AA@ DB 'fromunicode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OCNOKPAF@frombytes?$AA@
CONST	SEGMENT
??_C@_09OCNOKPAF@frombytes?$AA@ DB 'frombytes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PGGLCJNP@fromstring?$AA@
CONST	SEGMENT
??_C@_0L@PGGLCJNP@fromstring?$AA@ DB 'fromstring', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BGGGONCE@fromlist?$AA@
CONST	SEGMENT
??_C@_08BGGGONCE@fromlist?$AA@ DB 'fromlist', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BIHFDCNI@fromfile?$AA@
CONST	SEGMENT
??_C@_08BIHFDCNI@fromfile?$AA@ DB 'fromfile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06BPBOMFNI@extend?$AA@
CONST	SEGMENT
??_C@_06BPBOMFNI@extend?$AA@ DB 'extend', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LCDCNIJ@__deepcopy__?$AA@
CONST	SEGMENT
??_C@_0N@LCDCNIJ@__deepcopy__?$AA@ DB '__deepcopy__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count?$AA@
CONST	SEGMENT
??_C@_05IOMEMJEC@count?$AA@ DB 'count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MOMBEIKE@__copy__?$AA@
CONST	SEGMENT
??_C@_08MOMBEIKE@__copy__?$AA@ DB '__copy__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LGNCHIMC@byteswap?$AA@
CONST	SEGMENT
??_C@_08LGNCHIMC@byteswap?$AA@ DB 'byteswap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MDHGDJKG@buffer_info?$AA@
CONST	SEGMENT
??_C@_0M@MDHGDJKG@buffer_info?$AA@ DB 'buffer_info', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PCICMFGG@append?$AA@
CONST	SEGMENT
??_C@_06PCICMFGG@append?$AA@ DB 'append', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DALNPKGO@the?5size?0?5in?5bytes?0?5of?5one?5array@
CONST	SEGMENT
??_C@_0CG@DALNPKGO@the?5size?0?5in?5bytes?0?5of?5one?5array@ DB 'the size'
	DB	', in bytes, of one array item', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BFHIGMPA@itemsize?$AA@
CONST	SEGMENT
??_C@_08BFHIGMPA@itemsize?$AA@ DB 'itemsize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HJNMFPLE@the?5typecode?5character?5used?5to?5c@
CONST	SEGMENT
??_C@_0DA@HJNMFPLE@the?5typecode?5character?5used?5to?5c@ DB 'the typecod'
	DB	'e character used to create the array', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FJHEKLCH@typecode?$AA@
CONST	SEGMENT
??_C@_08FJHEKLCH@typecode?$AA@ DB 'typecode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBFKALI@__dict__?$AA@
CONST	SEGMENT
??_C@_08IBFKALI@__dict__?$AA@ DB '__dict__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FHDBJGA@_array_reconstructor?$AA@
CONST	SEGMENT
??_C@_0BF@FHDBJGA@_array_reconstructor?$AA@ DB '_array_reconstructor', 00H ; `string'
CONST	ENDS
CONST	SEGMENT
mformat_descriptors DQ 0000000000000001H
	DD	00H
	DD	00H
	DQ	0000000000000001H
	DD	01H
	DD	00H
	DQ	0000000000000002H
	DD	00H
	DD	00H
	DQ	0000000000000002H
	DD	00H
	DD	01H
	DQ	0000000000000002H
	DD	01H
	DD	00H
	DQ	0000000000000002H
	DD	01H
	DD	01H
	DQ	0000000000000004H
	DD	00H
	DD	00H
	DQ	0000000000000004H
	DD	00H
	DD	01H
	DQ	0000000000000004H
	DD	01H
	DD	00H
	DQ	0000000000000004H
	DD	01H
	DD	01H
	DQ	0000000000000008H
	DD	00H
	DD	00H
	DQ	0000000000000008H
	DD	00H
	DD	01H
	DQ	0000000000000008H
	DD	01H
	DD	00H
	DQ	0000000000000008H
	DD	01H
	DD	01H
	DQ	0000000000000004H
	DD	00H
	DD	00H
	DQ	0000000000000004H
	DD	00H
	DD	01H
	DQ	0000000000000008H
	DD	00H
	DD	00H
	DQ	0000000000000008H
	DD	00H
	DD	01H
	DQ	0000000000000004H
	DD	00H
	DD	00H
	DQ	0000000000000004H
	DD	00H
	DD	01H
	DQ	0000000000000008H
	DD	00H
	DD	00H
	DQ	0000000000000008H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT ??_C@_05NGFEDHGN@write?$AA@
CONST	SEGMENT
??_C@_05NGFEDHGN@write?$AA@ DB 'write', 00H		; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId___dict__@?1??array_reduce_ex@@9@9 DQ 0000000000000000H ; `array_reduce_ex'::`2'::PyId___dict__
	DQ	FLAT:??_C@_08IBFKALI@__dict__?$AA@
	DQ	0000000000000000H
?PyId__array_reconstructor@?1??array_reduce_ex@@9@9 DQ 0000000000000000H ; `array_reduce_ex'::`2'::PyId__array_reconstructor
	DQ	FLAT:??_C@_0BF@FHDBJGA@_array_reconstructor?$AA@
	DQ	0000000000000000H
?PyId_write@?2??array_tofile@@9@9 DQ 0000000000000000H	; `array_tofile'::`3'::PyId_write
	DQ	FLAT:??_C@_05NGFEDHGN@write?$AA@
	DQ	0000000000000000H
?PyId_read@?1??array_fromfile@@9@9 DQ 0000000000000000H	; `array_fromfile'::`2'::PyId_read
	DQ	FLAT:??_C@_04POLDLDMI@read?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_04POLDLDMI@read?$AA@
CONST	SEGMENT
??_C@_04POLDLDMI@read?$AA@ DB 'read', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
descriptors DB	062H
	ORG $+3
	DD	01H
	DQ	FLAT:b_getitem
	DQ	FLAT:b_setitem
	DQ	FLAT:??_C@_01OJONOECF@b?$AA@
	DD	01H
	DD	01H
	DB	042H
	ORG $+3
	DD	01H
	DQ	FLAT:BB_getitem
	DQ	FLAT:BB_setitem
	DQ	FLAT:??_C@_01HMGJMAIH@B?$AA@
	DD	01H
	DD	00H
	DB	075H
	ORG $+3
	DD	02H
	DQ	FLAT:u_getitem
	DQ	FLAT:u_setitem
	DQ	FLAT:??_C@_01OMGOGALD@u?$AA@
	DD	00H
	DD	00H
	DB	068H
	ORG $+3
	DD	02H
	DQ	FLAT:h_getitem
	DQ	FLAT:h_setitem
	DQ	FLAT:??_C@_01BDACAMKP@h?$AA@
	DD	01H
	DD	01H
	DB	048H
	ORG $+3
	DD	02H
	DQ	FLAT:HH_getitem
	DQ	FLAT:HH_setitem
	DQ	FLAT:??_C@_01IGIGCIAN@H?$AA@
	DD	01H
	DD	00H
	DB	069H
	ORG $+3
	DD	04H
	DQ	FLAT:i_getitem
	DQ	FLAT:i_setitem
	DQ	FLAT:??_C@_01KBJDNOO@i?$AA@
	DD	01H
	DD	01H
	DB	049H
	ORG $+3
	DD	04H
	DQ	FLAT:II_getitem
	DQ	FLAT:II_setitem
	DQ	FLAT:??_C@_01JPJNBJEM@I?$AA@
	DD	01H
	DD	00H
	DB	06cH
	ORG $+3
	DD	04H
	DQ	FLAT:l_getitem
	DQ	FLAT:l_setitem
	DQ	FLAT:??_C@_01HHGOMJKL@l?$AA@
	DD	01H
	DD	01H
	DB	04cH
	ORG $+3
	DD	04H
	DQ	FLAT:LL_getitem
	DQ	FLAT:LL_setitem
	DQ	FLAT:??_C@_01OCOKONAJ@L?$AA@
	DD	01H
	DD	00H
	DB	071H
	ORG $+3
	DD	08H
	DQ	FLAT:q_getitem
	DQ	FLAT:q_setitem
	DQ	FLAT:??_C@_01IIACKFLH@q?$AA@
	DD	01H
	DD	01H
	DB	051H
	ORG $+3
	DD	08H
	DQ	FLAT:QQ_getitem
	DQ	FLAT:QQ_setitem
	DQ	FLAT:??_C@_01BNIGIBBF@Q?$AA@
	DD	01H
	DD	00H
	DB	066H
	ORG $+3
	DD	04H
	DQ	FLAT:f_getitem
	DQ	FLAT:f_setitem
	DQ	FLAT:??_C@_01INIBCBCB@f?$AA@
	DD	00H
	DD	00H
	DB	064H
	ORG $+3
	DD	08H
	DQ	FLAT:d_getitem
	DQ	FLAT:d_setitem
	DQ	FLAT:??_C@_01LPLHEDKD@d?$AA@
	DD	00H
	DD	00H
	DB	00H
	ORG $+3
	DD	00H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	00H
	DD	00H
copy_doc DB	'copy(array)', 0aH, 0aH, ' Return a copy of the array.', 00H
	ORG $+6
count_doc DB	'count(x)', 0aH, 0aH, 'Return number of occurrences of x '
	DB	'in the array.', 00H
	ORG $+6
index_doc DB	'index(x)', 0aH, 0aH, 'Return index of first occurrence o'
	DB	'f x in the array.', 00H
	ORG $+2
remove_doc DB	'remove(x)', 0aH, 0aH, 'Remove the first occurrence of x '
	DB	'in the array.', 00H
	ORG $+6
pop_doc	DB	'pop([i])', 0aH, 0aH, 'Return the i-th element and delete'
	DB	' it from the array. i defaults to -1.', 00H
	ORG $+6
append_doc DB	'append(x)', 0aH, 0aH, 'Append new value x to the end of '
	DB	'the array.', 00H
	ORG $+1
extend_doc DB	'extend(array or iterable)', 0aH, 0aH, ' Append items to '
	DB	'the end of the array.', 00H
	ORG $+6
reverse_doc DB	'reverse()', 0aH, 0aH, 'Reverse the order of the items in'
	DB	' the array.', 00H
insert_doc DB	'insert(i,x)', 0aH, 0aH, 'Insert a new item x into the ar'
	DB	'ray before position i.', 00H
	ORG $+5
fromlist_doc DB	'fromlist(list)', 0aH, 0aH, 'Append items to array from l'
	DB	'ist.', 00H
	ORG $+7
buffer_info_doc DB 'buffer_info() -> (address, length)', 0aH, 0aH, 'Retur'
	DB	'n a tuple (address, length) giving the current memory address'
	DB	' and', 0aH, 'the length in items of the buffer used to hold a'
	DB	'rray''s contents', 0aH, 'The length should be multiplied by t'
	DB	'he itemsize attribute to calculate', 0aH, 'the buffer length '
	DB	'in bytes.', 00H
	ORG $+2
byteswap_doc DB	'byteswap()', 0aH, 0aH, 'Byteswap all items of the array.'
	DB	'  If the items in the array are not 1, 2,', 0aH, '4, or 8 byt'
	DB	'es in size, RuntimeError is raised.', 00H
	ORG $+3
reduce_doc DB	'Return state information for pickling.', 00H
	ORG $+1
fromfile_doc DB	'fromfile(f, n)', 0aH, 0aH, 'Read n objects from the file'
	DB	' object f and append them to the end of the', 0aH, 'array.', 00H
	ORG $+1
tofile_doc DB	'tofile(f)', 0aH, 0aH, 'Write all items (as machine value'
	DB	's) to the file object f.', 00H
	ORG $+3
array_as_mapping DQ FLAT:array_length
	DQ	FLAT:array_subscr
	DQ	FLAT:array_ass_subscr
tolist_doc DB	'tolist() -> list', 0aH, 0aH, 'Convert array to an ordina'
	DB	'ry list with the same items.', 00H
	ORG $+7
fromstring_doc DB 'fromstring(string)', 0aH, 0aH, 'Appends items from the'
	DB	' string, interpreting it as an array of machine', 0aH, 'value'
	DB	's, as if it had been read from a file using the fromfile() me'
	DB	'thod).', 0aH, 0aH, 'This method is deprecated. Use frombytes '
	DB	'instead.', 00H
	ORG $+2
emptybuf DQ	FLAT:??_C@_00CNPNBAHC@?$AA@
frombytes_doc DB 'frombytes(bytestring)', 0aH, 0aH, 'Appends items from t'
	DB	'he string, interpreting it as an array of machine', 0aH, 'val'
	DB	'ues, as if it had been read from a file using the fromfile() '
	DB	'method).', 00H
	ORG $+2
array_as_buffer DQ FLAT:array_buffer_getbuf
	DQ	FLAT:array_buffer_relbuf
setstate_doc DB	'Set state information for unpickling.', 00H
	ORG $+2
tobytes_doc DB	'tobytes() -> bytes', 0aH, 0aH, 'Convert the array to an '
	DB	'array of machine values and return the bytes', 0aH, 'represen'
	DB	'tation.', 00H
	ORG $+7
tostring_doc DB	'tostring() -> bytes', 0aH, 0aH, 'Convert the array to an'
	DB	' array of machine values and return the bytes', 0aH, 'represe'
	DB	'ntation.', 0aH, 0aH, 'This method is deprecated. Use tobytes '
	DB	'instead.', 00H
	ORG $+5
fromunicode_doc DB 'fromunicode(ustr)', 0aH, 0aH, 'Extends this array wit'
	DB	'h data from the unicode string ustr.', 0aH, 'The array must b'
	DB	'e a unicode type array; otherwise a ValueError', 0aH, 'is rai'
	DB	'sed.  Use array.frombytes(ustr.encode(...)) to', 0aH, 'append'
	DB	' Unicode data to an array of some other type.', 00H
	ORG $+10
tounicode_doc DB 'tounicode() -> unicode', 0aH, 0aH, 'Convert the array t'
	DB	'o a unicode string.  The array must be', 0aH, 'a unicode type'
	DB	' array; otherwise a ValueError is raised.  Use', 0aH, 'array.'
	DB	'tobytes().decode() to obtain a unicode string from', 0aH, 'an'
	DB	' array of some other type.', 00H
	ORG $+3
sizeof_doc DB	'__sizeof__() -> int', 0aH, 0aH, 'Size of the array in me'
	DB	'mory, in bytes.', 00H
	ORG $+12
array_getsets DQ FLAT:??_C@_08FJHEKLCH@typecode?$AA@
	DQ	FLAT:array_get_typecode
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0DA@HJNMFPLE@the?5typecode?5character?5used?5to?5c@
	ORG $+8
	DQ	FLAT:??_C@_08BFHIGMPA@itemsize?$AA@
	DQ	FLAT:array_get_itemsize
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0CG@DALNPKGO@the?5size?0?5in?5bytes?0?5of?5one?5array@
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
array_methods DQ FLAT:??_C@_06PCICMFGG@append?$AA@
	DQ	FLAT:array_append
	DD	08H
	ORG $+4
	DQ	FLAT:append_doc
	DQ	FLAT:??_C@_0M@MDHGDJKG@buffer_info?$AA@
	DQ	FLAT:array_buffer_info
	DD	04H
	ORG $+4
	DQ	FLAT:buffer_info_doc
	DQ	FLAT:??_C@_08LGNCHIMC@byteswap?$AA@
	DQ	FLAT:array_byteswap
	DD	04H
	ORG $+4
	DQ	FLAT:byteswap_doc
	DQ	FLAT:??_C@_08MOMBEIKE@__copy__?$AA@
	DQ	FLAT:array_copy
	DD	04H
	ORG $+4
	DQ	FLAT:copy_doc
	DQ	FLAT:??_C@_05IOMEMJEC@count?$AA@
	DQ	FLAT:array_count
	DD	08H
	ORG $+4
	DQ	FLAT:count_doc
	DQ	FLAT:??_C@_0N@LCDCNIJ@__deepcopy__?$AA@
	DQ	FLAT:array_copy
	DD	08H
	ORG $+4
	DQ	FLAT:copy_doc
	DQ	FLAT:??_C@_06BPBOMFNI@extend?$AA@
	DQ	FLAT:array_extend
	DD	08H
	ORG $+4
	DQ	FLAT:extend_doc
	DQ	FLAT:??_C@_08BIHFDCNI@fromfile?$AA@
	DQ	FLAT:array_fromfile
	DD	01H
	ORG $+4
	DQ	FLAT:fromfile_doc
	DQ	FLAT:??_C@_08BGGGONCE@fromlist?$AA@
	DQ	FLAT:array_fromlist
	DD	08H
	ORG $+4
	DQ	FLAT:fromlist_doc
	DQ	FLAT:??_C@_0L@PGGLCJNP@fromstring?$AA@
	DQ	FLAT:array_fromstring
	DD	01H
	ORG $+4
	DQ	FLAT:fromstring_doc
	DQ	FLAT:??_C@_09OCNOKPAF@frombytes?$AA@
	DQ	FLAT:array_frombytes
	DD	01H
	ORG $+4
	DQ	FLAT:frombytes_doc
	DQ	FLAT:??_C@_0M@JCIKMCEM@fromunicode?$AA@
	DQ	FLAT:array_fromunicode
	DD	01H
	ORG $+4
	DQ	FLAT:fromunicode_doc
	DQ	FLAT:??_C@_05FKHKFDID@index?$AA@
	DQ	FLAT:array_index
	DD	08H
	ORG $+4
	DQ	FLAT:index_doc
	DQ	FLAT:??_C@_06OAOPNKHP@insert?$AA@
	DQ	FLAT:array_insert
	DD	01H
	ORG $+4
	DQ	FLAT:insert_doc
	DQ	FLAT:??_C@_03NJDAHFJE@pop?$AA@
	DQ	FLAT:array_pop
	DD	01H
	ORG $+4
	DQ	FLAT:pop_doc
	DQ	FLAT:??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@
	DQ	FLAT:array_reduce_ex
	DD	08H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_06LEMKAMD@remove?$AA@
	DQ	FLAT:array_remove
	DD	08H
	ORG $+4
	DQ	FLAT:remove_doc
	DQ	FLAT:??_C@_07KOIEOCCE@reverse?$AA@
	DQ	FLAT:array_reverse
	DD	04H
	ORG $+4
	DQ	FLAT:reverse_doc
	DQ	FLAT:??_C@_06IKANPOPE@tofile?$AA@
	DQ	FLAT:array_tofile
	DD	08H
	ORG $+4
	DQ	FLAT:tofile_doc
	DQ	FLAT:??_C@_06IEBOCBAI@tolist?$AA@
	DQ	FLAT:array_tolist
	DD	04H
	ORG $+4
	DQ	FLAT:tolist_doc
	DQ	FLAT:??_C@_08FNIIFOJC@tostring?$AA@
	DQ	FLAT:array_tostring
	DD	04H
	ORG $+4
	DQ	FLAT:tostring_doc
	DQ	FLAT:??_C@_07NAJELLCK@tobytes?$AA@
	DQ	FLAT:array_tobytes
	DD	04H
	ORG $+4
	DQ	FLAT:tobytes_doc
	DQ	FLAT:??_C@_09JKEMBMBG@tounicode?$AA@
	DQ	FLAT:array_tounicode
	DD	04H
	ORG $+4
	DQ	FLAT:tounicode_doc
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:array_sizeof
	DD	04H
	ORG $+4
	DQ	FLAT:sizeof_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
array_as_sequence DQ FLAT:array_length
	DQ	FLAT:array_concat
	DQ	FLAT:array_repeat
	DQ	FLAT:array_item
	DQ	0000000000000000H
	DQ	FLAT:array_ass_item
	DQ	0000000000000000H
	DQ	FLAT:array_contains
	DQ	FLAT:array_inplace_concat
	DQ	FLAT:array_inplace_repeat
module_doc DB	'This module defines an object type which can efficiently'
	DB	' represent', 0aH, 'an array of basic values: characters, inte'
	DB	'gers, floating point', 0aH, 'numbers.  Arrays are sequence ty'
	DB	'pes and behave very much like lists,', 0aH, 'except that the '
	DB	'type of objects stored in them is constrained.  The', 0aH, 't'
	DB	'ype is specified at object creation time by using a type code'
	DB	', which', 0aH, 'is a single character.  The following type co'
	DB	'des are defined:', 0aH, 0aH, '    Type code   C Type         '
	DB	'    Minimum size in bytes ', 0aH, '    ''b''         signed i'
	DB	'nteger     1 ', 0aH, '    ''B''         unsigned integer   1 '
	DB	0aH, '    ''u''         Unicode character  2 (see note) ', 0aH
	DB	'    ''h''         signed integer     2 ', 0aH, '    ''H''    '
	DB	'     unsigned integer   2 ', 0aH, '    ''i''         signed i'
	DB	'nteger     2 ', 0aH, '    ''I''         unsigned integer   2 '
	DB	0aH, '    ''l''         signed integer     4 ', 0aH, '    ''L'''
	DB	'         unsigned integer   4 ', 0aH, '    ''q''         sign'
	DB	'ed integer     8 (see note) ', 0aH, '    ''Q''         unsign'
	DB	'ed integer   8 (see note) ', 0aH, '    ''f''         floating'
	DB	' point     4 ', 0aH, '    ''d''         floating point     8 '
	DB	0aH, 0aH, 'NOTE: The ''u'' typecode corresponds to Python''s u'
	DB	'nicode character. On ', 0aH, 'narrow builds this is 2-bytes o'
	DB	'n wide builds this is 4-bytes.', 0aH, 0aH, 'NOTE: The ''q'' a'
	DB	'nd ''Q'' type codes are only available if the platform ', 0aH
	DB	'C compiler used to build Python supports ''long long'', or, o'
	DB	'n Windows, ', 0aH, '''__int64''.', 0aH, 0aH, 'The constructor'
	DB	' is:', 0aH, 0aH, 'array(typecode [, initializer]) -- create a'
	DB	' new array', 0aH, 00H
	ORG $+13
arraytype_doc DB 'array(typecode [, initializer]) -> array', 0aH, 0aH, 'R'
	DB	'eturn a new array whose items are restricted by typecode, and'
	DB	0aH, 'initialized from the optional initializer value, which m'
	DB	'ust be a list,', 0aH, 'string or iterable over elements of th'
	DB	'e appropriate type.', 0aH, 0aH, 'Arrays represent basic value'
	DB	's and behave very much like lists, except', 0aH, 'the type of'
	DB	' objects stored in them is constrained.', 0aH, 0aH, 'Methods:'
	DB	0aH, 0aH, 'append() -- append a new item to the end of the arr'
	DB	'ay', 0aH, 'buffer_info() -- return information giving the cur'
	DB	'rent memory info', 0aH, 'byteswap() -- byteswap all the items'
	DB	' of the array', 0aH, 'count() -- return number of occurrences'
	DB	' of an object', 0aH, 'extend() -- extend array by appending m'
	DB	'ultiple elements from an iterable', 0aH, 'fromfile() -- read '
	DB	'items from a file object', 0aH, 'fromlist() -- append items f'
	DB	'rom the list', 0aH, 'frombytes() -- append items from the str'
	DB	'ing', 0aH, 'index() -- return index of first occurrence of an'
	DB	' object', 0aH, 'insert() -- insert a new item into the array '
	DB	'at a provided position', 0aH, 'pop() -- remove and return ite'
	DB	'm (default last)', 0aH, 'remove() -- remove first occurrence '
	DB	'of an object', 0aH, 'reverse() -- reverse the order of the it'
	DB	'ems in the array', 0aH, 'tofile() -- write all items to a fil'
	DB	'e object', 0aH, 'tolist() -- return the array converted to an'
	DB	' ordinary list', 0aH, 'tobytes() -- return the array converte'
	DB	'd to a string', 0aH, 0aH, 'Attributes:', 0aH, 0aH, 'typecode '
	DB	'-- the typecode character used to create the array', 0aH, 'it'
	DB	'emsize -- the length in bytes of one array item', 0aH, 00H
	ORG $+8
Arraytype DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0M@DCMOJOBC@array?4array?$AA@
	DQ	00000000000000a0H
	DQ	0000000000000000H
	DQ	FLAT:array_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:array_repr
	DQ	0000000000000000H
	DQ	FLAT:array_as_sequence
	DQ	FLAT:array_as_mapping
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	FLAT:array_as_buffer
	DD	040400H
	ORG $+4
	DQ	FLAT:arraytype_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:array_richcompare
	DQ	0000000000000088H
	DQ	FLAT:array_iter
	DQ	0000000000000000H
	DQ	FLAT:array_methods
	DQ	0000000000000000H
	DQ	FLAT:array_getsets
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:array_new
	DQ	FLAT:PyObject_Free
	ORG $+64
arrayiter_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:arrayiter_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:arrayiter_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
PyArrayIter_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0O@OPHKEACL@arrayiterator?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:arrayiter_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:arrayiter_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:arrayiter_next
	DQ	FLAT:arrayiter_methods
	ORG $+152
a_methods DQ	FLAT:??_C@_0BF@FHDBJGA@_array_reconstructor?$AA@
	DQ	FLAT:array_reconstructor
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0CF@GMIJNGPM@Internal?4?5Used?5for?5pickling?5supp@
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	00H
	ORG $+4
	DQ	0000000000000000H
arraymodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_05HIFJDKLD@array?$AA@
	DQ	FLAT:module_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:a_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ??_C@_01LPLHEDKD@d?$AA@
CONST	SEGMENT
??_C@_01LPLHEDKD@d?$AA@ DB 'd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01INIBCBCB@f?$AA@
CONST	SEGMENT
??_C@_01INIBCBCB@f?$AA@ DB 'f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BNIGIBBF@Q?$AA@
CONST	SEGMENT
??_C@_01BNIGIBBF@Q?$AA@ DB 'Q', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IIACKFLH@q?$AA@
CONST	SEGMENT
??_C@_01IIACKFLH@q?$AA@ DB 'q', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OCOKONAJ@L?$AA@
CONST	SEGMENT
??_C@_01OCOKONAJ@L?$AA@ DB 'L', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HHGOMJKL@l?$AA@
CONST	SEGMENT
??_C@_01HHGOMJKL@l?$AA@ DB 'l', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JPJNBJEM@I?$AA@
CONST	SEGMENT
??_C@_01JPJNBJEM@I?$AA@ DB 'I', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KBJDNOO@i?$AA@
CONST	SEGMENT
??_C@_01KBJDNOO@i?$AA@ DB 'i', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IGIGCIAN@H?$AA@
CONST	SEGMENT
??_C@_01IGIGCIAN@H?$AA@ DB 'H', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BDACAMKP@h?$AA@
CONST	SEGMENT
??_C@_01BDACAMKP@h?$AA@ DB 'h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OMGOGALD@u?$AA@
CONST	SEGMENT
??_C@_01OMGOGALD@u?$AA@ DB 'u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B?$AA@
CONST	SEGMENT
??_C@_01HMGJMAIH@B?$AA@ DB 'B', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OJONOECF@b?$AA@
CONST	SEGMENT
??_C@_01OJONOECF@b?$AA@ DB 'b', 00H			; `string'
CONST	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@GJKGCBFK@cannot?5resize?5an?5array?5that?5is?5e@ ; `string'
EXTRN	PyErr_NoMemory:PROC
EXTRN	__imp_realloc:PROC
EXTRN	_PxMem_Realloc:PROC
EXTRN	__imp_free:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_BufferError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\modules\arraymodule.c
pdata	SEGMENT
$pdata$array_resize DD imagerel array_resize
	DD	imagerel array_resize+400
	DD	imagerel $unwind$array_resize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_resize DD 0adc01H
	DD	08c4dcH
	DD	0764caH
	DD	0654c1H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0DB@GJKGCBFK@cannot?5resize?5an?5array?5that?5is?5e@
CONST	SEGMENT
??_C@_0DB@GJKGCBFK@cannot?5resize?5an?5array?5that?5is?5e@ DB 'cannot res'
	DB	'ize an array that is exporting buffers', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_resize
_TEXT	SEGMENT
self$ = 48
newsize$ = 56
array_resize PROC					; COMDAT

; 50   : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 51   :     char *items;
; 52   :     size_t _new_size;
; 53   : 
; 54   :     if (self->ob_exports > 0 && newsize != Py_SIZE(self)) {

  0000a	83 b9 90 00 00
	00 00		 cmp	 DWORD PTR [rcx+144], 0
  00011	48 8b fa	 mov	 rdi, rdx
  00014	48 8b d9	 mov	 rbx, rcx
  00017	7e 27		 jle	 SHORT $LN6@array_resi
  00019	48 3b 51 60	 cmp	 rdx, QWORD PTR [rcx+96]
  0001d	74 21		 je	 SHORT $LN6@array_resi

; 55   :         PyErr_SetString(PyExc_BufferError,
; 56   :             "cannot resize an array that is exporting buffers");

  0001f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@GJKGCBFK@cannot?5resize?5an?5array?5that?5is?5e@
  0002d	e8 00 00 00 00	 call	 PyErr_SetString

; 57   :         return -1;

  00032	83 c8 ff	 or	 eax, -1

; 108  : }

  00035	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5f		 pop	 rdi
  0003f	c3		 ret	 0
$LN6@array_resi:

; 58   :     }
; 59   : 
; 60   :     /* Bypass realloc() when a previous overallocation is large enough
; 61   :        to accommodate the newsize.  If the newsize is 16 smaller than the
; 62   :        current size, then proceed with the realloc() to shrink the array.
; 63   :     */
; 64   : 
; 65   :     if (self->allocated >= newsize &&
; 66   :         Py_SIZE(self) < newsize + 16 &&
; 67   :         self->ob_item != NULL) {

  00040	48 39 51 78	 cmp	 QWORD PTR [rcx+120], rdx
  00044	7c 22		 jl	 SHORT $LN5@array_resi
  00046	48 8d 42 10	 lea	 rax, QWORD PTR [rdx+16]
  0004a	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  0004e	7d 18		 jge	 SHORT $LN5@array_resi
  00050	48 83 79 70 00	 cmp	 QWORD PTR [rcx+112], 0
  00055	74 11		 je	 SHORT $LN5@array_resi

; 68   :         Py_SIZE(self) = newsize;

  00057	48 89 51 60	 mov	 QWORD PTR [rcx+96], rdx

; 69   :         return 0;

  0005b	33 c0		 xor	 eax, eax

; 108  : }

  0005d	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
$LN5@array_resi:

; 70   :     }
; 71   : 
; 72   :     if (newsize == 0) {

  00068	48 85 d2	 test	 rdx, rdx
  0006b	75 4a		 jne	 SHORT $LN4@array_resi

; 73   :         PyMem_FREE(self->ob_item);

  0006d	e8 00 00 00 00	 call	 _Py_PXCTX
  00072	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00076	85 c0		 test	 eax, eax
  00078	74 1e		 je	 SHORT $LN9@array_resi
  0007a	e8 00 00 00 00	 call	 _PxMem_Free

; 74   :         self->ob_item = NULL;

  0007f	33 c0		 xor	 eax, eax
  00081	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 75   :         Py_SIZE(self) = 0;

  00085	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 76   :         self->allocated = 0;

  00089	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 108  : }

  0008d	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00092	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
$LN9@array_resi:

; 73   :         PyMem_FREE(self->ob_item);

  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 74   :         self->ob_item = NULL;

  0009e	33 c0		 xor	 eax, eax
  000a0	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 75   :         Py_SIZE(self) = 0;

  000a4	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 76   :         self->allocated = 0;

  000a8	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 108  : }

  000ac	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000b1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b5	5f		 pop	 rdi
  000b6	c3		 ret	 0
$LN4@array_resi:

; 77   :         return 0;
; 78   :     }
; 79   : 
; 80   :     /* This over-allocates proportional to the array size, making room
; 81   :      * for additional growth.  The over-allocation is mild, but is
; 82   :      * enough to give linear-time amortized behavior over a long
; 83   :      * sequence of appends() in the presence of a poorly-performing
; 84   :      * system realloc().
; 85   :      * The growth pattern is:  0, 4, 8, 16, 25, 34, 46, 56, 67, 79, ...
; 86   :      * Note, the pattern starts out the same as for lists but then
; 87   :      * grows at a smaller rate so that larger arrays only overallocate
; 88   :      * by about 1/16th -- this is done because arrays are presumed to be more
; 89   :      * memory critical.
; 90   :      */
; 91   : 
; 92   :     _new_size = (newsize >> 4) + (Py_SIZE(self) < 8 ? 3 : 7) + newsize;

  000b7	48 83 7b 60 08	 cmp	 QWORD PTR [rbx+96], 8
  000bc	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp

; 93   :     items = self->ob_item;

  000c1	48 8b 6b 70	 mov	 rbp, QWORD PTR [rbx+112]
  000c5	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  000ca	48 8b f2	 mov	 rsi, rdx
  000cd	b8 07 00 00 00	 mov	 eax, 7
  000d2	b9 03 00 00 00	 mov	 ecx, 3
  000d7	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12
  000dc	0f 4c c1	 cmovl	 eax, ecx
  000df	48 c1 fe 04	 sar	 rsi, 4
  000e3	48 03 c2	 add	 rax, rdx

; 94   :     /* XXX The following multiplication and division does not optimize away
; 95   :        like it does for lists since the size is not known at compile time */
; 96   :     if (_new_size <= ((~(size_t)0) / self->ob_descr->itemsize))

  000e6	33 d2		 xor	 edx, edx
  000e8	48 03 f0	 add	 rsi, rax
  000eb	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]
  000f2	4c 63 40 04	 movsxd	 r8, DWORD PTR [rax+4]
  000f6	48 83 c8 ff	 or	 rax, -1
  000fa	49 f7 f0	 div	 r8
  000fd	48 3b f0	 cmp	 rsi, rax
  00100	77 6c		 ja	 SHORT $LN19@array_resi

; 97   :         PyMem_RESIZE(items, char, (_new_size * self->ob_descr->itemsize));

  00102	4c 0f af c6	 imul	 r8, rsi
  00106	49 bc ff ff ff
	ff ff ff ff 7f	 mov	 r12, 9223372036854775807 ; 7fffffffffffffffH
  00110	4d 3b c4	 cmp	 r8, r12
  00113	77 59		 ja	 SHORT $LN19@array_resi
  00115	e8 00 00 00 00	 call	 _Py_PXCTX
  0011a	85 c0		 test	 eax, eax
  0011c	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]
  00123	74 12		 je	 SHORT $LN15@array_resi
  00125	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  00129	48 8b cd	 mov	 rcx, rbp
  0012c	48 0f af d6	 imul	 rdx, rsi
  00130	e8 00 00 00 00	 call	 _PxMem_Realloc
  00135	eb 22		 jmp	 SHORT $LN2@array_resi
$LN15@array_resi:
  00137	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0013b	48 0f af ce	 imul	 rcx, rsi
  0013f	49 3b cc	 cmp	 rcx, r12
  00142	77 2a		 ja	 SHORT $LN19@array_resi
  00144	48 85 c9	 test	 rcx, rcx
  00147	ba 01 00 00 00	 mov	 edx, 1
  0014c	48 0f 45 d1	 cmovne	 rdx, rcx
  00150	48 8b cd	 mov	 rcx, rbp
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
$LN2@array_resi:

; 98   :     else
; 99   :         items = NULL;
; 100  :     if (items == NULL) {

  00159	48 85 c0	 test	 rax, rax
  0015c	74 10		 je	 SHORT $LN19@array_resi

; 103  :     }
; 104  :     self->ob_item = items;

  0015e	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 105  :     Py_SIZE(self) = newsize;

  00162	48 89 7b 60	 mov	 QWORD PTR [rbx+96], rdi

; 106  :     self->allocated = _new_size;

  00166	48 89 73 78	 mov	 QWORD PTR [rbx+120], rsi

; 107  :     return 0;

  0016a	33 c0		 xor	 eax, eax
  0016c	eb 08		 jmp	 SHORT $LN22@array_resi
$LN19@array_resi:

; 101  :         PyErr_NoMemory();

  0016e	e8 00 00 00 00	 call	 PyErr_NoMemory

; 102  :         return -1;

  00173	83 c8 ff	 or	 eax, -1
$LN22@array_resi:

; 108  : }

  00176	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0017b	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  00180	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]
  00185	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0018a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0018e	5f		 pop	 rdi
  0018f	c3		 ret	 0
array_resize ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT b_getitem
_TEXT	SEGMENT
ap$ = 8
i$ = 16
b_getitem PROC						; COMDAT

; 125  :     long x = ((char *)ap->ob_item)[i];

  00000	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00004	0f be 0c 10	 movsx	 ecx, BYTE PTR [rax+rdx]

; 126  :     if (x >= 128)

  00008	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0000e	7c 06		 jl	 SHORT $LN1@b_getitem

; 127  :         x -= 256;

  00010	81 e9 00 01 00
	00		 sub	 ecx, 256		; 00000100H
$LN1@b_getitem:

; 128  :     return PyLong_FromLong(x);
; 129  : }

  00016	e9 00 00 00 00	 jmp	 PyLong_FromLong
b_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@LPIDPKAF@signed?5char?5is?5greater?5than?5maxi@ ; `string'
PUBLIC	??_C@_0CB@KFFPLEPD@signed?5char?5is?5less?5than?5minimum@ ; `string'
PUBLIC	??_C@_0BN@IIFFHIEL@h?$DLarray?5item?5must?5be?5integer?$AA@ ; `string'
EXTRN	PyExc_OverflowError:QWORD
EXTRN	_PyArg_Parse_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$b_setitem DD imagerel b_setitem
	DD	imagerel b_setitem+151
	DD	imagerel $unwind$b_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$b_setitem DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0CE@LPIDPKAF@signed?5char?5is?5greater?5than?5maxi@
CONST	SEGMENT
??_C@_0CE@LPIDPKAF@signed?5char?5is?5greater?5than?5maxi@ DB 'signed char'
	DB	' is greater than maximum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KFFPLEPD@signed?5char?5is?5less?5than?5minimum@
CONST	SEGMENT
??_C@_0CB@KFFPLEPD@signed?5char?5is?5less?5than?5minimum@ DB 'signed char'
	DB	' is less than minimum', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IIFFHIEL@h?$DLarray?5item?5must?5be?5integer?$AA@
CONST	SEGMENT
??_C@_0BN@IIFFHIEL@h?$DLarray?5item?5must?5be?5integer?$AA@ DB 'h;array i'
	DB	'tem must be integer', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT b_setitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
v$ = 64
x$ = 72
b_setitem PROC						; COMDAT

; 133  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b c0	 mov	 rax, r8
  0000d	48 8b da	 mov	 rbx, rdx
  00010	48 8b f9	 mov	 rdi, rcx

; 134  :     short x;
; 135  :     /* PyArg_Parse's 'b' formatter is for an unsigned char, therefore
; 136  :        must use the next size up that is signed ('h') and manually do
; 137  :        the overflow checking */
; 138  :     if (!PyArg_Parse(v, "h;array item must be integer", &x))

  00013	4c 8d 44 24 48	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@IIFFHIEL@h?$DLarray?5item?5must?5be?5integer?$AA@
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00027	85 c0		 test	 eax, eax

; 139  :         return -1;

  00029	74 1e		 je	 SHORT $LN9@b_setitem

; 140  :     else if (x < -128) {

  0002b	0f b7 4c 24 48	 movzx	 ecx, WORD PTR x$[rsp]
  00030	66 83 f9 80	 cmp	 cx, -128		; ffffffffffffff80H
  00034	7d 21		 jge	 SHORT $LN4@b_setitem

; 141  :         PyErr_SetString(PyExc_OverflowError,
; 142  :             "signed char is less than minimum");

  00036	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@KFFPLEPD@signed?5char?5is?5less?5than?5minimum@
  00044	e8 00 00 00 00	 call	 PyErr_SetString
$LN9@b_setitem:

; 143  :         return -1;

  00049	83 c8 ff	 or	 eax, -1

; 153  : }

  0004c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00051	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00055	5f		 pop	 rdi
  00056	c3		 ret	 0
$LN4@b_setitem:

; 144  :     }
; 145  :     else if (x > 127) {

  00057	66 83 f9 7f	 cmp	 cx, 127			; 0000007fH
  0005b	7e 21		 jle	 SHORT $LN2@b_setitem

; 146  :         PyErr_SetString(PyExc_OverflowError,
; 147  :             "signed char is greater than maximum");

  0005d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@LPIDPKAF@signed?5char?5is?5greater?5than?5maxi@
  0006b	e8 00 00 00 00	 call	 PyErr_SetString

; 148  :         return -1;

  00070	83 c8 ff	 or	 eax, -1

; 153  : }

  00073	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00078	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007c	5f		 pop	 rdi
  0007d	c3		 ret	 0
$LN2@b_setitem:

; 149  :     }
; 150  :     if (i >= 0)

  0007e	48 85 db	 test	 rbx, rbx
  00081	78 07		 js	 SHORT $LN1@b_setitem

; 151  :         ((char *)ap->ob_item)[i] = (char)x;

  00083	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  00087	88 0c 03	 mov	 BYTE PTR [rbx+rax], cl
$LN1@b_setitem:

; 152  :     return 0;

  0008a	33 c0		 xor	 eax, eax

; 153  : }

  0008c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00091	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00095	5f		 pop	 rdi
  00096	c3		 ret	 0
b_setitem ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT BB_getitem
_TEXT	SEGMENT
ap$ = 8
i$ = 16
BB_getitem PROC						; COMDAT

; 158  :     long x = ((unsigned char *)ap->ob_item)[i];

  00000	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00004	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]

; 159  :     return PyLong_FromLong(x);
; 160  : }

  00008	e9 00 00 00 00	 jmp	 PyLong_FromLong
BB_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@OAIGAPKB@b?$DLarray?5item?5must?5be?5integer?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$BB_setitem DD imagerel BB_setitem
	DD	imagerel BB_setitem+87
	DD	imagerel $unwind$BB_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$BB_setitem DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BN@OAIGAPKB@b?$DLarray?5item?5must?5be?5integer?$AA@
CONST	SEGMENT
??_C@_0BN@OAIGAPKB@b?$DLarray?5item?5must?5be?5integer?$AA@ DB 'b;array i'
	DB	'tem must be integer', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT BB_setitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
v$ = 64
x$ = 72
BB_setitem PROC						; COMDAT

; 164  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b c0	 mov	 rax, r8
  0000d	48 8b da	 mov	 rbx, rdx
  00010	48 8b f9	 mov	 rdi, rcx

; 165  :     unsigned char x;
; 166  :     /* 'B' == unsigned char, maps to PyArg_Parse's 'b' formatter */
; 167  :     if (!PyArg_Parse(v, "b;array item must be integer", &x))

  00013	4c 8d 44 24 48	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OAIGAPKB@b?$DLarray?5item?5must?5be?5integer?$AA@
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00027	85 c0		 test	 eax, eax
  00029	75 0e		 jne	 SHORT $LN2@BB_setitem

; 168  :         return -1;

  0002b	83 c8 ff	 or	 eax, -1

; 172  : }

  0002e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
$LN2@BB_setitem:

; 169  :     if (i >= 0)

  00039	48 85 db	 test	 rbx, rbx
  0003c	78 0c		 js	 SHORT $LN1@BB_setitem

; 170  :         ((char *)ap->ob_item)[i] = x;

  0003e	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  00042	0f b6 44 24 48	 movzx	 eax, BYTE PTR x$[rsp]
  00047	88 04 0b	 mov	 BYTE PTR [rbx+rcx], al
$LN1@BB_setitem:

; 171  :     return 0;

  0004a	33 c0		 xor	 eax, eax

; 172  : }

  0004c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00051	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00055	5f		 pop	 rdi
  00056	c3		 ret	 0
BB_setitem ENDP
_TEXT	ENDS
EXTRN	PyUnicode_FromUnicode:PROC
; Function compile flags: /Ogtpy
;	COMDAT u_getitem
_TEXT	SEGMENT
ap$ = 8
i$ = 16
u_getitem PROC						; COMDAT

; 177  :     return PyUnicode_FromUnicode(&((Py_UNICODE *) ap->ob_item)[i], 1);

  00000	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00004	48 8d 0c 50	 lea	 rcx, QWORD PTR [rax+rdx*2]
  00008	ba 01 00 00 00	 mov	 edx, 1

; 178  : }

  0000d	e9 00 00 00 00	 jmp	 PyUnicode_FromUnicode
u_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@JPMPNLNP@array?5item?5must?5be?5unicode?5chara@ ; `string'
PUBLIC	??_C@_0CI@MFMIOCHL@u?$CD?$DLarray?5item?5must?5be?5unicode?5ch@ ; `string'
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$u_setitem DD imagerel u_setitem
	DD	imagerel u_setitem+123
	DD	imagerel $unwind$u_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$u_setitem DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0CF@JPMPNLNP@array?5item?5must?5be?5unicode?5chara@
CONST	SEGMENT
??_C@_0CF@JPMPNLNP@array?5item?5must?5be?5unicode?5chara@ DB 'array item '
	DB	'must be unicode character', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MFMIOCHL@u?$CD?$DLarray?5item?5must?5be?5unicode?5ch@
CONST	SEGMENT
??_C@_0CI@MFMIOCHL@u?$CD?$DLarray?5item?5must?5be?5unicode?5ch@ DB 'u#;ar'
	DB	'ray item must be unicode character', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT u_setitem
_TEXT	SEGMENT
p$ = 32
ap$ = 64
i$ = 72
v$ = 80
len$ = 88
u_setitem PROC						; COMDAT

; 182  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	49 8b c0	 mov	 rax, r8
  0000d	48 8b da	 mov	 rbx, rdx
  00010	48 8b f9	 mov	 rdi, rcx

; 183  :     Py_UNICODE *p;
; 184  :     Py_ssize_t len;
; 185  : 
; 186  :     if (!PyArg_Parse(v, "u#;array item must be unicode character", &p, &len))

  00013	4c 8d 44 24 20	 lea	 r8, QWORD PTR p$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@MFMIOCHL@u?$CD?$DLarray?5item?5must?5be?5unicode?5ch@
  0001f	4c 8d 4c 24 58	 lea	 r9, QWORD PTR len$[rsp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  0002c	85 c0		 test	 eax, eax

; 187  :         return -1;

  0002e	74 1b		 je	 SHORT $LN6@u_setitem

; 188  :     if (len != 1) {

  00030	48 83 7c 24 58
	01		 cmp	 QWORD PTR len$[rsp], 1
  00036	74 21		 je	 SHORT $LN2@u_setitem

; 189  :         PyErr_SetString(PyExc_TypeError,
; 190  :                         "array item must be unicode character");

  00038	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@JPMPNLNP@array?5item?5must?5be?5unicode?5chara@
  00046	e8 00 00 00 00	 call	 PyErr_SetString
$LN6@u_setitem:

; 191  :         return -1;

  0004b	83 c8 ff	 or	 eax, -1

; 196  : }

  0004e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
$LN2@u_setitem:

; 192  :     }
; 193  :     if (i >= 0)

  00059	48 85 db	 test	 rbx, rbx
  0005c	78 10		 js	 SHORT $LN1@u_setitem

; 194  :         ((Py_UNICODE *)ap->ob_item)[i] = p[0];

  0005e	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00063	48 8b 57 70	 mov	 rdx, QWORD PTR [rdi+112]
  00067	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  0006a	66 89 0c 5a	 mov	 WORD PTR [rdx+rbx*2], cx
$LN1@u_setitem:

; 195  :     return 0;

  0006e	33 c0		 xor	 eax, eax

; 196  : }

  00070	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5f		 pop	 rdi
  0007a	c3		 ret	 0
u_setitem ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT h_getitem
_TEXT	SEGMENT
ap$ = 8
i$ = 16
h_getitem PROC						; COMDAT

; 202  :     return PyLong_FromLong((long) ((short *)ap->ob_item)[i]);

  00000	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00004	0f bf 0c 50	 movsx	 ecx, WORD PTR [rax+rdx*2]

; 203  : }

  00008	e9 00 00 00 00	 jmp	 PyLong_FromLong
h_getitem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$h_setitem DD imagerel h_setitem
	DD	imagerel h_setitem+88
	DD	imagerel $unwind$h_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$h_setitem DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT h_setitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
v$ = 64
x$ = 72
h_setitem PROC						; COMDAT

; 208  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b c0	 mov	 rax, r8
  0000d	48 8b da	 mov	 rbx, rdx
  00010	48 8b f9	 mov	 rdi, rcx

; 209  :     short x;
; 210  :     /* 'h' == signed short, maps to PyArg_Parse's 'h' formatter */
; 211  :     if (!PyArg_Parse(v, "h;array item must be integer", &x))

  00013	4c 8d 44 24 48	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@IIFFHIEL@h?$DLarray?5item?5must?5be?5integer?$AA@
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00027	85 c0		 test	 eax, eax
  00029	75 0e		 jne	 SHORT $LN2@h_setitem

; 212  :         return -1;

  0002b	83 c8 ff	 or	 eax, -1

; 216  : }

  0002e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
$LN2@h_setitem:

; 213  :     if (i >= 0)

  00039	48 85 db	 test	 rbx, rbx
  0003c	78 0d		 js	 SHORT $LN1@h_setitem

; 214  :                  ((short *)ap->ob_item)[i] = x;

  0003e	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  00042	0f b7 44 24 48	 movzx	 eax, WORD PTR x$[rsp]
  00047	66 89 04 59	 mov	 WORD PTR [rcx+rbx*2], ax
$LN1@h_setitem:

; 215  :     return 0;

  0004b	33 c0		 xor	 eax, eax

; 216  : }

  0004d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
h_setitem ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT HH_getitem
_TEXT	SEGMENT
ap$ = 8
i$ = 16
HH_getitem PROC						; COMDAT

; 221  :     return PyLong_FromLong((long) ((unsigned short *)ap->ob_item)[i]);

  00000	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00004	0f b7 0c 50	 movzx	 ecx, WORD PTR [rax+rdx*2]

; 222  : }

  00008	e9 00 00 00 00	 jmp	 PyLong_FromLong
HH_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@FGIAJPNJ@unsigned?5short?5is?5greater?5than?5m@ ; `string'
PUBLIC	??_C@_0CE@KIHIKEPG@unsigned?5short?5is?5less?5than?5mini@ ; `string'
PUBLIC	??_C@_0BN@OLFCKBGP@i?$DLarray?5item?5must?5be?5integer?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$HH_setitem DD imagerel HH_setitem
	DD	imagerel HH_setitem+151
	DD	imagerel $unwind$HH_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HH_setitem DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0CH@FGIAJPNJ@unsigned?5short?5is?5greater?5than?5m@
CONST	SEGMENT
??_C@_0CH@FGIAJPNJ@unsigned?5short?5is?5greater?5than?5m@ DB 'unsigned sh'
	DB	'ort is greater than maximum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KIHIKEPG@unsigned?5short?5is?5less?5than?5mini@
CONST	SEGMENT
??_C@_0CE@KIHIKEPG@unsigned?5short?5is?5less?5than?5mini@ DB 'unsigned sh'
	DB	'ort is less than minimum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OLFCKBGP@i?$DLarray?5item?5must?5be?5integer?$AA@
CONST	SEGMENT
??_C@_0BN@OLFCKBGP@i?$DLarray?5item?5must?5be?5integer?$AA@ DB 'i;array i'
	DB	'tem must be integer', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT HH_setitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
v$ = 64
x$ = 72
HH_setitem PROC						; COMDAT

; 226  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b c0	 mov	 rax, r8
  0000d	48 8b da	 mov	 rbx, rdx
  00010	48 8b f9	 mov	 rdi, rcx

; 227  :     int x;
; 228  :     /* PyArg_Parse's 'h' formatter is for a signed short, therefore
; 229  :        must use the next size up and manually do the overflow checking */
; 230  :     if (!PyArg_Parse(v, "i;array item must be integer", &x))

  00013	4c 8d 44 24 48	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OLFCKBGP@i?$DLarray?5item?5must?5be?5integer?$AA@
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00027	85 c0		 test	 eax, eax

; 231  :         return -1;

  00029	74 1b		 je	 SHORT $LN9@HH_setitem

; 232  :     else if (x < 0) {

  0002b	8b 4c 24 48	 mov	 ecx, DWORD PTR x$[rsp]
  0002f	85 c9		 test	 ecx, ecx
  00031	79 21		 jns	 SHORT $LN4@HH_setitem

; 233  :         PyErr_SetString(PyExc_OverflowError,
; 234  :             "unsigned short is less than minimum");

  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KIHIKEPG@unsigned?5short?5is?5less?5than?5mini@
  00041	e8 00 00 00 00	 call	 PyErr_SetString
$LN9@HH_setitem:

; 235  :         return -1;

  00046	83 c8 ff	 or	 eax, -1

; 245  : }

  00049	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
$LN4@HH_setitem:

; 236  :     }
; 237  :     else if (x > USHRT_MAX) {

  00054	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  0005a	7e 21		 jle	 SHORT $LN2@HH_setitem

; 238  :         PyErr_SetString(PyExc_OverflowError,
; 239  :             "unsigned short is greater than maximum");

  0005c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@FGIAJPNJ@unsigned?5short?5is?5greater?5than?5m@
  0006a	e8 00 00 00 00	 call	 PyErr_SetString

; 240  :         return -1;

  0006f	83 c8 ff	 or	 eax, -1

; 245  : }

  00072	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
$LN2@HH_setitem:

; 241  :     }
; 242  :     if (i >= 0)

  0007d	48 85 db	 test	 rbx, rbx
  00080	78 08		 js	 SHORT $LN1@HH_setitem

; 243  :         ((short *)ap->ob_item)[i] = (short)x;

  00082	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  00086	66 89 0c 58	 mov	 WORD PTR [rax+rbx*2], cx
$LN1@HH_setitem:

; 244  :     return 0;

  0008a	33 c0		 xor	 eax, eax

; 245  : }

  0008c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00091	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00095	5f		 pop	 rdi
  00096	c3		 ret	 0
HH_setitem ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT i_getitem
_TEXT	SEGMENT
ap$ = 8
i$ = 16
i_getitem PROC						; COMDAT

; 250  :     return PyLong_FromLong((long) ((int *)ap->ob_item)[i]);

  00000	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00004	8b 0c 90	 mov	 ecx, DWORD PTR [rax+rdx*4]

; 251  : }

  00007	e9 00 00 00 00	 jmp	 PyLong_FromLong
i_getitem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$i_setitem DD imagerel i_setitem
	DD	imagerel i_setitem+86
	DD	imagerel $unwind$i_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$i_setitem DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT i_setitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
v$ = 64
x$ = 72
i_setitem PROC						; COMDAT

; 255  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b c0	 mov	 rax, r8
  0000d	48 8b da	 mov	 rbx, rdx
  00010	48 8b f9	 mov	 rdi, rcx

; 256  :     int x;
; 257  :     /* 'i' == signed int, maps to PyArg_Parse's 'i' formatter */
; 258  :     if (!PyArg_Parse(v, "i;array item must be integer", &x))

  00013	4c 8d 44 24 48	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OLFCKBGP@i?$DLarray?5item?5must?5be?5integer?$AA@
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00027	85 c0		 test	 eax, eax
  00029	75 0e		 jne	 SHORT $LN2@i_setitem

; 259  :         return -1;

  0002b	83 c8 ff	 or	 eax, -1

; 263  : }

  0002e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
$LN2@i_setitem:

; 260  :     if (i >= 0)

  00039	48 85 db	 test	 rbx, rbx
  0003c	78 0b		 js	 SHORT $LN1@i_setitem

; 261  :                  ((int *)ap->ob_item)[i] = x;

  0003e	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  00042	8b 44 24 48	 mov	 eax, DWORD PTR x$[rsp]
  00046	89 04 99	 mov	 DWORD PTR [rcx+rbx*4], eax
$LN1@i_setitem:

; 262  :     return 0;

  00049	33 c0		 xor	 eax, eax

; 263  : }

  0004b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5f		 pop	 rdi
  00055	c3		 ret	 0
i_setitem ENDP
_TEXT	ENDS
EXTRN	PyLong_FromUnsignedLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT II_getitem
_TEXT	SEGMENT
ap$ = 8
i$ = 16
II_getitem PROC						; COMDAT

; 268  :     return PyLong_FromUnsignedLong(
; 269  :         (unsigned long) ((unsigned int *)ap->ob_item)[i]);

  00000	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00004	8b 0c 90	 mov	 ecx, DWORD PTR [rax+rdx*4]

; 270  : }

  00007	e9 00 00 00 00	 jmp	 PyLong_FromUnsignedLong
II_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@FJOCEHKO@unsigned?5int?5is?5greater?5than?5max@ ; `string'
PUBLIC	??_C@_0CC@EPGGIEKN@unsigned?5int?5is?5less?5than?5minimu@ ; `string'
PUBLIC	??_C@_0BN@NPDLBKJK@l?$DLarray?5item?5must?5be?5integer?$AA@ ; `string'
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsUnsignedLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$II_setitem DD imagerel II_setitem
	DD	imagerel II_setitem+231
	DD	imagerel $unwind$II_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$II_setitem DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CF@FJOCEHKO@unsigned?5int?5is?5greater?5than?5max@
CONST	SEGMENT
??_C@_0CF@FJOCEHKO@unsigned?5int?5is?5greater?5than?5max@ DB 'unsigned in'
	DB	't is greater than maximum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@EPGGIEKN@unsigned?5int?5is?5less?5than?5minimu@
CONST	SEGMENT
??_C@_0CC@EPGGIEKN@unsigned?5int?5is?5less?5than?5minimu@ DB 'unsigned in'
	DB	't is less than minimum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NPDLBKJK@l?$DLarray?5item?5must?5be?5integer?$AA@
CONST	SEGMENT
??_C@_0BN@NPDLBKJK@l?$DLarray?5item?5must?5be?5integer?$AA@ DB 'l;array i'
	DB	'tem must be integer', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT II_setitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
y$20449 = 64
v$ = 64
II_setitem PROC						; COMDAT

; 274  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 275  :     unsigned long x;
; 276  :     if (PyLong_Check(v)) {

  0000f	49 8b 40 58	 mov	 rax, QWORD PTR [r8+88]
  00013	4d 8b c8	 mov	 r9, r8
  00016	48 8b fa	 mov	 rdi, rdx
  00019	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00023	48 8b f1	 mov	 rsi, rcx
  00026	74 30		 je	 SHORT $LN7@II_setitem@2

; 277  :         x = PyLong_AsUnsignedLong(v);

  00028	49 8b c8	 mov	 rcx, r8
  0002b	e8 00 00 00 00	 call	 PyLong_AsUnsignedLong
  00030	8b d8		 mov	 ebx, eax

; 278  :         if (x == (unsigned long) -1 && PyErr_Occurred())

  00032	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00035	75 67		 jne	 SHORT $LN3@II_setitem@2
  00037	e8 00 00 00 00	 call	 PyErr_Occurred
  0003c	48 85 c0	 test	 rax, rax
  0003f	0f 84 84 00 00
	00		 je	 $LN2@II_setitem@2
$LN10@II_setitem@2:

; 279  :             return -1;

  00045	83 c8 ff	 or	 eax, -1

; 301  :     return 0;
; 302  : }

  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
$LN7@II_setitem@2:

; 280  :     }
; 281  :     else {
; 282  :         long y;
; 283  :         if (!PyArg_Parse(v, "l;array item must be integer", &y))

  00058	4c 8d 44 24 40	 lea	 r8, QWORD PTR y$20449[rsp]
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@NPDLBKJK@l?$DLarray?5item?5must?5be?5integer?$AA@
  00064	49 8b c9	 mov	 rcx, r9
  00067	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  0006c	85 c0		 test	 eax, eax

; 284  :             return -1;

  0006e	74 d5		 je	 SHORT $LN10@II_setitem@2

; 285  :         if (y < 0) {

  00070	8b 5c 24 40	 mov	 ebx, DWORD PTR y$20449[rsp]
  00074	85 db		 test	 ebx, ebx
  00076	79 26		 jns	 SHORT $LN3@II_setitem@2

; 286  :             PyErr_SetString(PyExc_OverflowError,
; 287  :                 "unsigned int is less than minimum");

  00078	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@EPGGIEKN@unsigned?5int?5is?5less?5than?5minimu@
  00086	e8 00 00 00 00	 call	 PyErr_SetString

; 288  :             return -1;

  0008b	83 c8 ff	 or	 eax, -1

; 301  :     return 0;
; 302  : }

  0008e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00093	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00098	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
$LN3@II_setitem@2:

; 289  :         }
; 290  :         x = (unsigned long)y;
; 291  : 
; 292  :     }
; 293  :     if (x > UINT_MAX) {

  0009e	83 fb ff	 cmp	 ebx, -1			; ffffffffH
  000a1	76 26		 jbe	 SHORT $LN2@II_setitem@2

; 294  :         PyErr_SetString(PyExc_OverflowError,
; 295  :             "unsigned int is greater than maximum");

  000a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@FJOCEHKO@unsigned?5int?5is?5greater?5than?5max@
  000b1	e8 00 00 00 00	 call	 PyErr_SetString

; 296  :         return -1;

  000b6	83 c8 ff	 or	 eax, -1

; 301  :     return 0;
; 302  : }

  000b9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000be	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000c3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c7	5f		 pop	 rdi
  000c8	c3		 ret	 0
$LN2@II_setitem@2:

; 297  :     }
; 298  : 
; 299  :     if (i >= 0)

  000c9	48 85 ff	 test	 rdi, rdi
  000cc	78 07		 js	 SHORT $LN1@II_setitem@2

; 300  :         ((unsigned int *)ap->ob_item)[i] = (unsigned int)x;

  000ce	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  000d2	89 1c b8	 mov	 DWORD PTR [rax+rdi*4], ebx
$LN1@II_setitem@2:

; 301  :     return 0;
; 302  : }

  000d5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000da	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000df	33 c0		 xor	 eax, eax
  000e1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e5	5f		 pop	 rdi
  000e6	c3		 ret	 0
II_setitem ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT l_getitem
_TEXT	SEGMENT
ap$ = 8
i$ = 16
l_getitem PROC						; COMDAT

; 307  :     return PyLong_FromLong(((long *)ap->ob_item)[i]);

  00000	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00004	8b 0c 90	 mov	 ecx, DWORD PTR [rax+rdx*4]

; 308  : }

  00007	e9 00 00 00 00	 jmp	 PyLong_FromLong
l_getitem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$l_setitem DD imagerel l_setitem
	DD	imagerel l_setitem+86
	DD	imagerel $unwind$l_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$l_setitem DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT l_setitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
v$ = 64
x$ = 72
l_setitem PROC						; COMDAT

; 312  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b c0	 mov	 rax, r8
  0000d	48 8b da	 mov	 rbx, rdx
  00010	48 8b f9	 mov	 rdi, rcx

; 313  :     long x;
; 314  :     if (!PyArg_Parse(v, "l;array item must be integer", &x))

  00013	4c 8d 44 24 48	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@NPDLBKJK@l?$DLarray?5item?5must?5be?5integer?$AA@
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00027	85 c0		 test	 eax, eax
  00029	75 0e		 jne	 SHORT $LN2@l_setitem

; 315  :         return -1;

  0002b	83 c8 ff	 or	 eax, -1

; 319  : }

  0002e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
$LN2@l_setitem:

; 316  :     if (i >= 0)

  00039	48 85 db	 test	 rbx, rbx
  0003c	78 0b		 js	 SHORT $LN1@l_setitem

; 317  :                  ((long *)ap->ob_item)[i] = x;

  0003e	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  00042	8b 44 24 48	 mov	 eax, DWORD PTR x$[rsp]
  00046	89 04 99	 mov	 DWORD PTR [rcx+rbx*4], eax
$LN1@l_setitem:

; 318  :     return 0;

  00049	33 c0		 xor	 eax, eax

; 319  : }

  0004b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5f		 pop	 rdi
  00055	c3		 ret	 0
l_setitem ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT LL_getitem
_TEXT	SEGMENT
ap$ = 8
i$ = 16
LL_getitem PROC						; COMDAT

; 324  :     return PyLong_FromUnsignedLong(((unsigned long *)ap->ob_item)[i]);

  00000	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00004	8b 0c 90	 mov	 ecx, DWORD PTR [rax+rdx*4]

; 325  : }

  00007	e9 00 00 00 00	 jmp	 PyLong_FromUnsignedLong
LL_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@PFKJNNEL@unsigned?5long?5is?5greater?5than?5ma@ ; `string'
PUBLIC	??_C@_0CD@GGGBBGOM@unsigned?5long?5is?5less?5than?5minim@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$LL_setitem DD imagerel LL_setitem
	DD	imagerel LL_setitem+231
	DD	imagerel $unwind$LL_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$LL_setitem DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CG@PFKJNNEL@unsigned?5long?5is?5greater?5than?5ma@
CONST	SEGMENT
??_C@_0CG@PFKJNNEL@unsigned?5long?5is?5greater?5than?5ma@ DB 'unsigned lo'
	DB	'ng is greater than maximum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GGGBBGOM@unsigned?5long?5is?5less?5than?5minim@
CONST	SEGMENT
??_C@_0CD@GGGBBGOM@unsigned?5long?5is?5less?5than?5minim@ DB 'unsigned lo'
	DB	'ng is less than minimum', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT LL_setitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
y$20500 = 64
v$ = 64
LL_setitem PROC						; COMDAT

; 329  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 330  :     unsigned long x;
; 331  :     if (PyLong_Check(v)) {

  0000f	49 8b 40 58	 mov	 rax, QWORD PTR [r8+88]
  00013	4d 8b c8	 mov	 r9, r8
  00016	48 8b fa	 mov	 rdi, rdx
  00019	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00023	48 8b f1	 mov	 rsi, rcx
  00026	74 30		 je	 SHORT $LN7@LL_setitem@3

; 332  :         x = PyLong_AsUnsignedLong(v);

  00028	49 8b c8	 mov	 rcx, r8
  0002b	e8 00 00 00 00	 call	 PyLong_AsUnsignedLong
  00030	8b d8		 mov	 ebx, eax

; 333  :         if (x == (unsigned long) -1 && PyErr_Occurred())

  00032	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00035	75 67		 jne	 SHORT $LN3@LL_setitem@3
  00037	e8 00 00 00 00	 call	 PyErr_Occurred
  0003c	48 85 c0	 test	 rax, rax
  0003f	0f 84 84 00 00
	00		 je	 $LN2@LL_setitem@3
$LN10@LL_setitem@3:

; 334  :             return -1;

  00045	83 c8 ff	 or	 eax, -1

; 356  :     return 0;
; 357  : }

  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
$LN7@LL_setitem@3:

; 335  :     }
; 336  :     else {
; 337  :         long y;
; 338  :         if (!PyArg_Parse(v, "l;array item must be integer", &y))

  00058	4c 8d 44 24 40	 lea	 r8, QWORD PTR y$20500[rsp]
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@NPDLBKJK@l?$DLarray?5item?5must?5be?5integer?$AA@
  00064	49 8b c9	 mov	 rcx, r9
  00067	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  0006c	85 c0		 test	 eax, eax

; 339  :             return -1;

  0006e	74 d5		 je	 SHORT $LN10@LL_setitem@3

; 340  :         if (y < 0) {

  00070	8b 5c 24 40	 mov	 ebx, DWORD PTR y$20500[rsp]
  00074	85 db		 test	 ebx, ebx
  00076	79 26		 jns	 SHORT $LN3@LL_setitem@3

; 341  :             PyErr_SetString(PyExc_OverflowError,
; 342  :                 "unsigned long is less than minimum");

  00078	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@GGGBBGOM@unsigned?5long?5is?5less?5than?5minim@
  00086	e8 00 00 00 00	 call	 PyErr_SetString

; 343  :             return -1;

  0008b	83 c8 ff	 or	 eax, -1

; 356  :     return 0;
; 357  : }

  0008e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00093	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00098	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
$LN3@LL_setitem@3:

; 344  :         }
; 345  :         x = (unsigned long)y;
; 346  : 
; 347  :     }
; 348  :     if (x > ULONG_MAX) {

  0009e	83 fb ff	 cmp	 ebx, -1			; ffffffffH
  000a1	76 26		 jbe	 SHORT $LN2@LL_setitem@3

; 349  :         PyErr_SetString(PyExc_OverflowError,
; 350  :             "unsigned long is greater than maximum");

  000a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@PFKJNNEL@unsigned?5long?5is?5greater?5than?5ma@
  000b1	e8 00 00 00 00	 call	 PyErr_SetString

; 351  :         return -1;

  000b6	83 c8 ff	 or	 eax, -1

; 356  :     return 0;
; 357  : }

  000b9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000be	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000c3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c7	5f		 pop	 rdi
  000c8	c3		 ret	 0
$LN2@LL_setitem@3:

; 352  :     }
; 353  : 
; 354  :     if (i >= 0)

  000c9	48 85 ff	 test	 rdi, rdi
  000cc	78 07		 js	 SHORT $LN1@LL_setitem@3

; 355  :         ((unsigned long *)ap->ob_item)[i] = x;

  000ce	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  000d2	89 1c b8	 mov	 DWORD PTR [rax+rdi*4], ebx
$LN1@LL_setitem@3:

; 356  :     return 0;
; 357  : }

  000d5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000da	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000df	33 c0		 xor	 eax, eax
  000e1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e5	5f		 pop	 rdi
  000e6	c3		 ret	 0
LL_setitem ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLongLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT q_getitem
_TEXT	SEGMENT
ap$ = 8
i$ = 16
q_getitem PROC						; COMDAT

; 364  :     return PyLong_FromLongLong(((PY_LONG_LONG *)ap->ob_item)[i]);

  00000	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00004	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]

; 365  : }

  00008	e9 00 00 00 00	 jmp	 PyLong_FromLongLong
q_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@JNLAGNB@L?$DLarray?5item?5must?5be?5integer?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$q_setitem DD imagerel q_setitem
	DD	imagerel q_setitem+88
	DD	imagerel $unwind$q_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$q_setitem DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BN@JNLAGNB@L?$DLarray?5item?5must?5be?5integer?$AA@
CONST	SEGMENT
??_C@_0BN@JNLAGNB@L?$DLarray?5item?5must?5be?5integer?$AA@ DB 'L;array it'
	DB	'em must be integer', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT q_setitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
v$ = 64
x$ = 72
q_setitem PROC						; COMDAT

; 369  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b c0	 mov	 rax, r8
  0000d	48 8b da	 mov	 rbx, rdx
  00010	48 8b f9	 mov	 rdi, rcx

; 370  :     PY_LONG_LONG x;
; 371  :     if (!PyArg_Parse(v, "L;array item must be integer", &x))

  00013	4c 8d 44 24 48	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@JNLAGNB@L?$DLarray?5item?5must?5be?5integer?$AA@
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00027	85 c0		 test	 eax, eax
  00029	75 0e		 jne	 SHORT $LN2@q_setitem

; 372  :         return -1;

  0002b	83 c8 ff	 or	 eax, -1

; 376  : }

  0002e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
$LN2@q_setitem:

; 373  :     if (i >= 0)

  00039	48 85 db	 test	 rbx, rbx
  0003c	78 0d		 js	 SHORT $LN1@q_setitem

; 374  :         ((PY_LONG_LONG *)ap->ob_item)[i] = x;

  0003e	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  00042	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  00047	48 89 04 d9	 mov	 QWORD PTR [rcx+rbx*8], rax
$LN1@q_setitem:

; 375  :     return 0;

  0004b	33 c0		 xor	 eax, eax

; 376  : }

  0004d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
q_setitem ENDP
_TEXT	ENDS
EXTRN	PyLong_FromUnsignedLongLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT QQ_getitem
_TEXT	SEGMENT
ap$ = 8
i$ = 16
QQ_getitem PROC						; COMDAT

; 381  :     return PyLong_FromUnsignedLongLong(
; 382  :         ((unsigned PY_LONG_LONG *)ap->ob_item)[i]);

  00000	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00004	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]

; 383  : }

  00008	e9 00 00 00 00	 jmp	 PyLong_FromUnsignedLongLong
QQ_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@CLOIAIHO@unsigned?5long?5long?5is?5less?5than?5@ ; `string'
EXTRN	PyLong_AsUnsignedLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$QQ_setitem DD imagerel QQ_setitem
	DD	imagerel QQ_setitem+189
	DD	imagerel $unwind$QQ_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$QQ_setitem DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CI@CLOIAIHO@unsigned?5long?5long?5is?5less?5than?5@
CONST	SEGMENT
??_C@_0CI@CLOIAIHO@unsigned?5long?5long?5is?5less?5than?5@ DB 'unsigned l'
	DB	'ong long is less than minimum', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT QQ_setitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
y$20550 = 64
v$ = 64
QQ_setitem PROC						; COMDAT

; 387  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 388  :     unsigned PY_LONG_LONG x;
; 389  :     if (PyLong_Check(v)) {

  0000f	49 8b 40 58	 mov	 rax, QWORD PTR [r8+88]
  00013	4d 8b c8	 mov	 r9, r8
  00016	48 8b fa	 mov	 rdi, rdx
  00019	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00023	48 8b f1	 mov	 rsi, rcx
  00026	74 2e		 je	 SHORT $LN6@QQ_setitem@2

; 390  :         x = PyLong_AsUnsignedLongLong(v);

  00028	49 8b c8	 mov	 rcx, r8
  0002b	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongLong
  00030	48 8b d8	 mov	 rbx, rax

; 391  :         if (x == (unsigned PY_LONG_LONG) -1 && PyErr_Occurred())

  00033	48 83 f8 ff	 cmp	 rax, -1
  00037	75 65		 jne	 SHORT $LN2@QQ_setitem@2
  00039	e8 00 00 00 00	 call	 PyErr_Occurred
  0003e	48 85 c0	 test	 rax, rax
  00041	74 5b		 je	 SHORT $LN2@QQ_setitem@2
$LN9@QQ_setitem@2:

; 392  :             return -1;

  00043	83 c8 ff	 or	 eax, -1

; 408  :     return 0;
; 409  : }

  00046	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5f		 pop	 rdi
  00055	c3		 ret	 0
$LN6@QQ_setitem@2:

; 393  :     }
; 394  :     else {
; 395  :         PY_LONG_LONG y;
; 396  :         if (!PyArg_Parse(v, "L;array item must be integer", &y))

  00056	4c 8d 44 24 40	 lea	 r8, QWORD PTR y$20550[rsp]
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@JNLAGNB@L?$DLarray?5item?5must?5be?5integer?$AA@
  00062	49 8b c9	 mov	 rcx, r9
  00065	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  0006a	85 c0		 test	 eax, eax

; 397  :             return -1;

  0006c	74 d5		 je	 SHORT $LN9@QQ_setitem@2

; 398  :         if (y < 0) {

  0006e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR y$20550[rsp]
  00073	48 85 db	 test	 rbx, rbx
  00076	79 26		 jns	 SHORT $LN2@QQ_setitem@2

; 399  :             PyErr_SetString(PyExc_OverflowError,
; 400  :                 "unsigned long long is less than minimum");

  00078	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@CLOIAIHO@unsigned?5long?5long?5is?5less?5than?5@
  00086	e8 00 00 00 00	 call	 PyErr_SetString

; 401  :             return -1;

  0008b	83 c8 ff	 or	 eax, -1

; 408  :     return 0;
; 409  : }

  0008e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00093	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00098	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
$LN2@QQ_setitem@2:

; 402  :         }
; 403  :         x = (unsigned PY_LONG_LONG)y;
; 404  :     }
; 405  : 
; 406  :     if (i >= 0)

  0009e	48 85 ff	 test	 rdi, rdi
  000a1	78 08		 js	 SHORT $LN1@QQ_setitem@2

; 407  :         ((unsigned PY_LONG_LONG *)ap->ob_item)[i] = x;

  000a3	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  000a7	48 89 1c f8	 mov	 QWORD PTR [rax+rdi*8], rbx
$LN1@QQ_setitem@2:

; 408  :     return 0;
; 409  : }

  000ab	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b0	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b5	33 c0		 xor	 eax, eax
  000b7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bb	5f		 pop	 rdi
  000bc	c3		 ret	 0
QQ_setitem ENDP
_TEXT	ENDS
EXTRN	PyFloat_FromDouble:PROC
EXTRN	_fltused:DWORD
; Function compile flags: /Ogtpy
;	COMDAT f_getitem
_TEXT	SEGMENT
ap$ = 8
i$ = 16
f_getitem PROC						; COMDAT

; 415  :     return PyFloat_FromDouble((double) ((float *)ap->ob_item)[i]);

  00000	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00004	66 0f 6e 04 90	 movd	 xmm0, DWORD PTR [rax+rdx*4]
  00009	0f 5a c0	 cvtps2pd xmm0, xmm0

; 416  : }

  0000c	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
f_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@GDNNBMHH@f?$DLarray?5item?5must?5be?5float?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$f_setitem DD imagerel f_setitem
	DD	imagerel f_setitem+90
	DD	imagerel $unwind$f_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$f_setitem DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BL@GDNNBMHH@f?$DLarray?5item?5must?5be?5float?$AA@
CONST	SEGMENT
??_C@_0BL@GDNNBMHH@f?$DLarray?5item?5must?5be?5float?$AA@ DB 'f;array ite'
	DB	'm must be float', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT f_setitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
v$ = 64
x$ = 72
f_setitem PROC						; COMDAT

; 420  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b c0	 mov	 rax, r8
  0000d	48 8b da	 mov	 rbx, rdx
  00010	48 8b f9	 mov	 rdi, rcx

; 421  :     float x;
; 422  :     if (!PyArg_Parse(v, "f;array item must be float", &x))

  00013	4c 8d 44 24 48	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@GDNNBMHH@f?$DLarray?5item?5must?5be?5float?$AA@
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00027	85 c0		 test	 eax, eax
  00029	75 0e		 jne	 SHORT $LN2@f_setitem

; 423  :         return -1;

  0002b	83 c8 ff	 or	 eax, -1

; 427  : }

  0002e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
$LN2@f_setitem:

; 424  :     if (i >= 0)

  00039	48 85 db	 test	 rbx, rbx
  0003c	78 0f		 js	 SHORT $LN1@f_setitem

; 425  :                  ((float *)ap->ob_item)[i] = x;

  0003e	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  00042	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR x$[rsp]
  00048	f3 0f 11 04 98	 movss	 DWORD PTR [rax+rbx*4], xmm0
$LN1@f_setitem:

; 426  :     return 0;

  0004d	33 c0		 xor	 eax, eax

; 427  : }

  0004f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
f_setitem ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT d_getitem
_TEXT	SEGMENT
ap$ = 8
i$ = 16
d_getitem PROC						; COMDAT

; 432  :     return PyFloat_FromDouble(((double *)ap->ob_item)[i]);

  00000	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00004	f2 0f 10 04 d0	 movsdx	 xmm0, QWORD PTR [rax+rdx*8]

; 433  : }

  00009	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
d_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@LOMFCKPF@d?$DLarray?5item?5must?5be?5float?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$d_setitem DD imagerel d_setitem
	DD	imagerel d_setitem+90
	DD	imagerel $unwind$d_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$d_setitem DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BL@LOMFCKPF@d?$DLarray?5item?5must?5be?5float?$AA@
CONST	SEGMENT
??_C@_0BL@LOMFCKPF@d?$DLarray?5item?5must?5be?5float?$AA@ DB 'd;array ite'
	DB	'm must be float', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT d_setitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
v$ = 64
x$ = 72
d_setitem PROC						; COMDAT

; 437  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b c0	 mov	 rax, r8
  0000d	48 8b da	 mov	 rbx, rdx
  00010	48 8b f9	 mov	 rdi, rcx

; 438  :     double x;
; 439  :     if (!PyArg_Parse(v, "d;array item must be float", &x))

  00013	4c 8d 44 24 48	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@LOMFCKPF@d?$DLarray?5item?5must?5be?5float?$AA@
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00027	85 c0		 test	 eax, eax
  00029	75 0e		 jne	 SHORT $LN2@d_setitem

; 440  :         return -1;

  0002b	83 c8 ff	 or	 eax, -1

; 444  : }

  0002e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
$LN2@d_setitem:

; 441  :     if (i >= 0)

  00039	48 85 db	 test	 rbx, rbx
  0003c	78 0f		 js	 SHORT $LN1@d_setitem

; 442  :                  ((double *)ap->ob_item)[i] = x;

  0003e	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  00042	f2 0f 10 44 24
	48		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00048	f2 0f 11 04 d8	 movsdx	 QWORD PTR [rax+rbx*8], xmm0
$LN1@d_setitem:

; 443  :     return 0;

  0004d	33 c0		 xor	 eax, eax

; 444  : }

  0004f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
d_setitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@DMBOHOAP@?4?4?2Modules?2arraymodule?4c?$AA@ ; `string'
EXTRN	__imp_malloc:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	_PyErr_BadInternalCall:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$newarrayobject DD imagerel newarrayobject
	DD	imagerel newarrayobject+54
	DD	imagerel $unwind$newarrayobject
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$newarrayobject DD imagerel newarrayobject+54
	DD	imagerel newarrayobject+100
	DD	imagerel $chain$1$newarrayobject
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$newarrayobject DD imagerel newarrayobject+100
	DD	imagerel newarrayobject+171
	DD	imagerel $chain$2$newarrayobject
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$newarrayobject DD imagerel newarrayobject+171
	DD	imagerel newarrayobject+192
	DD	imagerel $chain$3$newarrayobject
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$newarrayobject DD imagerel newarrayobject+192
	DD	imagerel newarrayobject+263
	DD	imagerel $chain$5$newarrayobject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$newarrayobject DD 060021H
	DD	08c400H
	DD	076400H
	DD	063400H
	DD	imagerel newarrayobject
	DD	imagerel newarrayobject+54
	DD	imagerel $unwind$newarrayobject
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$newarrayobject DD 021H
	DD	imagerel newarrayobject+54
	DD	imagerel newarrayobject+100
	DD	imagerel $chain$1$newarrayobject
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$newarrayobject DD 020521H
	DD	063405H
	DD	imagerel newarrayobject+54
	DD	imagerel newarrayobject+100
	DD	imagerel $chain$1$newarrayobject
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$newarrayobject DD 040e21H
	DD	08c40eH
	DD	076405H
	DD	imagerel newarrayobject
	DD	imagerel newarrayobject+54
	DD	imagerel $unwind$newarrayobject
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newarrayobject DD 040a01H
	DD	09540aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BJ@DMBOHOAP@?4?4?2Modules?2arraymodule?4c?$AA@
CONST	SEGMENT
??_C@_0BJ@DMBOHOAP@?4?4?2Modules?2arraymodule?4c?$AA@ DB '..\Modules\arra'
	DB	'ymodule.c', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT newarrayobject
_TEXT	SEGMENT
type$ = 48
size$ = 56
descr$ = 64
newarrayobject PROC					; COMDAT

; 477  : {

  00000	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b e8	 mov	 rbp, r8
  0000d	48 8b fa	 mov	 rdi, rdx
  00010	4c 8b c1	 mov	 r8, rcx

; 478  :     arrayobject *op;
; 479  :     size_t nbytes;
; 480  : 
; 481  :     if (size < 0) {

  00013	48 85 d2	 test	 rdx, rdx
  00016	79 1e		 jns	 SHORT $LN6@newarrayob

; 482  :         PyErr_BadInternalCall();

  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@DMBOHOAP@?4?4?2Modules?2arraymodule?4c?$AA@
  0001f	ba e2 01 00 00	 mov	 edx, 482		; 000001e2H
  00024	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 483  :         return NULL;

  00029	33 c0		 xor	 eax, eax

; 511  : }

  0002b	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
$LN6@newarrayob:
  00036	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi

; 484  :     }
; 485  : 
; 486  :     /* Check for overflow */
; 487  :     if (size > PY_SSIZE_T_MAX / descr->itemsize) {

  0003b	48 63 75 04	 movsxd	 rsi, DWORD PTR [rbp+4]
  0003f	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12
  00044	49 bc ff ff ff
	ff ff ff ff 7f	 mov	 r12, 9223372036854775807 ; 7fffffffffffffffH
  0004e	49 8b c4	 mov	 rax, r12
  00051	48 99		 cdq
  00053	48 f7 fe	 idiv	 rsi
  00056	48 3b f8	 cmp	 rdi, rax
  00059	7e 07		 jle	 SHORT $LN5@newarrayob

; 488  :         return PyErr_NoMemory();

  0005b	e8 00 00 00 00	 call	 PyErr_NoMemory
  00060	eb 49		 jmp	 SHORT $LN16@newarrayob
$LN5@newarrayob:

; 489  :     }
; 490  :     nbytes = size * descr->itemsize;
; 491  :     op = (arrayobject *) type->tp_alloc(type, 0);

  00062	33 d2		 xor	 edx, edx
  00064	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00069	48 0f af f7	 imul	 rsi, rdi
  0006d	41 ff 90 88 01
	00 00		 call	 QWORD PTR [r8+392]
  00074	48 8b d8	 mov	 rbx, rax

; 492  :     if (op == NULL) {

  00077	48 85 c0	 test	 rax, rax
  0007a	74 2a		 je	 SHORT $LN17@newarrayob
$LN4@newarrayob:

; 493  :         return NULL;
; 494  :     }
; 495  :     op->ob_descr = descr;

  0007c	48 89 a8 80 00
	00 00		 mov	 QWORD PTR [rax+128], rbp

; 496  :     op->allocated = size;
; 497  :     op->weakreflist = NULL;

  00083	33 ed		 xor	 ebp, ebp
  00085	48 89 78 78	 mov	 QWORD PTR [rax+120], rdi

; 498  :     Py_SIZE(op) = size;

  00089	48 89 78 60	 mov	 QWORD PTR [rax+96], rdi
  0008d	48 89 a8 88 00
	00 00		 mov	 QWORD PTR [rax+136], rbp

; 499  :     if (size <= 0) {

  00094	48 85 ff	 test	 rdi, rdi
  00097	7f 27		 jg	 SHORT $LN3@newarrayob

; 500  :         op->ob_item = NULL;

  00099	48 89 68 70	 mov	 QWORD PTR [rax+112], rbp
$LN1@newarrayob:

; 507  :         }
; 508  :     }
; 509  :     op->ob_exports = 0;

  0009d	89 ab 90 00 00
	00		 mov	 DWORD PTR [rbx+144], ebp

; 510  :     return (PyObject *) op;

  000a3	48 8b c3	 mov	 rax, rbx
$LN17@newarrayob:
  000a6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN16@newarrayob:
  000ab	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b0	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]

; 511  : }

  000b5	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000ba	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
$LN3@newarrayob:

; 501  :     }
; 502  :     else {
; 503  :         op->ob_item = PyMem_NEW(char, nbytes);

  000c0	49 3b f4	 cmp	 rsi, r12
  000c3	76 05		 jbe	 SHORT $LN13@newarrayob
  000c5	48 8b c5	 mov	 rax, rbp
  000c8	eb 25		 jmp	 SHORT $LN10@newarrayob
$LN13@newarrayob:
  000ca	e8 00 00 00 00	 call	 _Py_PXCTX
  000cf	85 c0		 test	 eax, eax
  000d1	74 0a		 je	 SHORT $LN11@newarrayob
  000d3	48 8b ce	 mov	 rcx, rsi
  000d6	e8 00 00 00 00	 call	 _PxMem_Malloc
  000db	eb 12		 jmp	 SHORT $LN10@newarrayob
$LN11@newarrayob:
  000dd	48 85 f6	 test	 rsi, rsi
  000e0	b9 01 00 00 00	 mov	 ecx, 1
  000e5	48 0f 45 ce	 cmovne	 rcx, rsi
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN10@newarrayob:
  000ef	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 504  :         if (op->ob_item == NULL) {

  000f3	48 85 c0	 test	 rax, rax
  000f6	75 a5		 jne	 SHORT $LN1@newarrayob

; 505  :             Py_DECREF(op);

  000f8	48 8b cb	 mov	 rcx, rbx
  000fb	e8 00 00 00 00	 call	 _Py_DecRef

; 506  :             return PyErr_NoMemory();

  00100	e8 00 00 00 00	 call	 PyErr_NoMemory
  00105	eb 9f		 jmp	 SHORT $LN17@newarrayob
newarrayobject ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT getarrayitem
_TEXT	SEGMENT
op$ = 8
i$ = 16
getarrayitem PROC					; COMDAT

; 516  :     register arrayobject *ap;
; 517  :     assert(array_Check(op));
; 518  :     ap = (arrayobject *)op;
; 519  :     assert(i>=0 && i<Py_SIZE(ap));
; 520  :     return (*ap->ob_descr->getitem)(ap, i);

  00000	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]

; 521  : }

  00007	48 ff 60 08	 rex_jmp QWORD PTR [rax+8]
getarrayitem ENDP
_TEXT	ENDS
EXTRN	__imp_memmove:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ins1 DD	imagerel ins1
	DD	imagerel ins1+219
	DD	imagerel $unwind$ins1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ins1 DD	081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ins1
_TEXT	SEGMENT
self$ = 48
where$ = 56
v$ = 64
ins1	PROC						; COMDAT

; 525  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 526  :     char *items;
; 527  :     Py_ssize_t n = Py_SIZE(self);

  00014	48 8b 71 60	 mov	 rsi, QWORD PTR [rcx+96]
  00018	49 8b e8	 mov	 rbp, r8
  0001b	48 8b da	 mov	 rbx, rdx
  0001e	48 8b f9	 mov	 rdi, rcx

; 528  :     if (v == NULL) {

  00021	4d 85 c0	 test	 r8, r8
  00024	75 19		 jne	 SHORT $LN7@ins1

; 529  :         PyErr_BadInternalCall();

  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@DMBOHOAP@?4?4?2Modules?2arraymodule?4c?$AA@
  0002d	ba 11 02 00 00	 mov	 edx, 529		; 00000211H
  00032	e8 00 00 00 00	 call	 _PyErr_BadInternalCall
$LN11@ins1:

; 530  :         return -1;

  00037	83 c8 ff	 or	 eax, -1
  0003a	e9 87 00 00 00	 jmp	 $LN8@ins1
$LN7@ins1:

; 531  :     }
; 532  :     if ((*self->ob_descr->setitem)(self, -1, v) < 0)

  0003f	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  00046	48 83 ca ff	 or	 rdx, -1
  0004a	ff 50 10	 call	 QWORD PTR [rax+16]
  0004d	85 c0		 test	 eax, eax

; 533  :         return -1;

  0004f	78 e6		 js	 SHORT $LN11@ins1

; 534  : 
; 535  :     if (array_resize(self, n+1) == -1)

  00051	48 8d 56 01	 lea	 rdx, QWORD PTR [rsi+1]
  00055	48 8b cf	 mov	 rcx, rdi
  00058	e8 00 00 00 00	 call	 array_resize
  0005d	83 f8 ff	 cmp	 eax, -1

; 536  :         return -1;

  00060	74 d5		 je	 SHORT $LN11@ins1

; 537  :     items = self->ob_item;

  00062	4c 8b 47 70	 mov	 r8, QWORD PTR [rdi+112]

; 538  :     if (where < 0) {

  00066	48 85 db	 test	 rbx, rbx
  00069	79 0c		 jns	 SHORT $LN3@ins1

; 539  :         where += n;

  0006b	48 03 de	 add	 rbx, rsi

; 540  :         if (where < 0)

  0006e	b8 00 00 00 00	 mov	 eax, 0
  00073	48 0f 48 d8	 cmovs	 rbx, rax
$LN3@ins1:

; 541  :             where = 0;
; 542  :     }
; 543  :     if (where > n)

  00077	48 3b de	 cmp	 rbx, rsi
  0007a	7e 05		 jle	 SHORT $LN10@ins1

; 544  :         where = n;

  0007c	48 8b de	 mov	 rbx, rsi

; 545  :     /* appends don't need to call memmove() */
; 546  :     if (where != n)

  0007f	eb 32		 jmp	 SHORT $LN1@ins1
$LN10@ins1:
  00081	74 30		 je	 SHORT $LN1@ins1

; 547  :         memmove(items + (where+1)*self->ob_descr->itemsize,
; 548  :             items + where*self->ob_descr->itemsize,
; 549  :             (n-where)*self->ob_descr->itemsize);

  00083	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  0008a	48 2b f3	 sub	 rsi, rbx
  0008d	48 8d 4b 01	 lea	 rcx, QWORD PTR [rbx+1]
  00091	4c 63 48 04	 movsxd	 r9, DWORD PTR [rax+4]
  00095	49 8b d1	 mov	 rdx, r9
  00098	49 0f af c9	 imul	 rcx, r9
  0009c	49 0f af f1	 imul	 rsi, r9
  000a0	49 03 c8	 add	 rcx, r8
  000a3	48 0f af d3	 imul	 rdx, rbx
  000a7	49 03 d0	 add	 rdx, r8
  000aa	4c 8b c6	 mov	 r8, rsi
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN1@ins1:

; 550  :     return (*self->ob_descr->setitem)(self, where, v);

  000b3	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  000ba	4c 8b c5	 mov	 r8, rbp
  000bd	48 8b d3	 mov	 rdx, rbx
  000c0	48 8b cf	 mov	 rcx, rdi
  000c3	ff 50 10	 call	 QWORD PTR [rax+16]
$LN8@ins1:

; 551  : }

  000c6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000cb	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000d0	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000d5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
ins1	ENDP
_TEXT	ENDS
EXTRN	PyObject_ClearWeakRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_dealloc DD imagerel array_dealloc
	DD	imagerel array_dealloc+93
	DD	imagerel $unwind$array_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_dealloc DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT array_dealloc
_TEXT	SEGMENT
op$ = 48
array_dealloc PROC					; COMDAT

; 557  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 558  :     if (op->weakreflist != NULL)

  00006	48 83 b9 88 00
	00 00 00	 cmp	 QWORD PTR [rcx+136], 0
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	74 05		 je	 SHORT $LN2@array_deal

; 559  :         PyObject_ClearWeakRefs((PyObject *) op);

  00013	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN2@array_deal:

; 560  :     if (op->ob_item != NULL)

  00018	48 83 7b 70 00	 cmp	 QWORD PTR [rbx+112], 0
  0001d	74 2b		 je	 SHORT $LN6@array_deal

; 561  :         PyMem_DEL(op->ob_item);

  0001f	e8 00 00 00 00	 call	 _Py_PXCTX
  00024	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00028	85 c0		 test	 eax, eax
  0002a	74 18		 je	 SHORT $LN5@array_deal
  0002c	e8 00 00 00 00	 call	 _PxMem_Free

; 562  :     Py_TYPE(op)->tp_free((PyObject *)op);

  00031	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00035	48 8b cb	 mov	 rcx, rbx

; 563  : }

  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5b		 pop	 rbx
  0003d	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
$LN5@array_deal:

; 561  :         PyMem_DEL(op->ob_item);

  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN6@array_deal:

; 562  :     Py_TYPE(op)->tp_free((PyObject *)op);

  0004a	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0004e	48 8b cb	 mov	 rcx, rbx

; 563  : }

  00051	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00055	5b		 pop	 rbx
  00056	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
array_dealloc ENDP
_TEXT	ENDS
EXTRN	__ImageBase:BYTE
EXTRN	PyObject_RichCompare:PROC
EXTRN	PyObject_RichCompareBool:PROC
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_Py_NotImplementedStruct:BYTE
EXTRN	PyType_IsSubtype:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$array_richcompare DD imagerel array_richcompare
	DD	imagerel array_richcompare+235
	DD	imagerel $unwind$array_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$array_richcompare DD imagerel array_richcompare+235
	DD	imagerel array_richcompare+564
	DD	imagerel $chain$0$array_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$array_richcompare DD imagerel array_richcompare+564
	DD	imagerel array_richcompare+587
	DD	imagerel $chain$1$array_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$array_richcompare DD imagerel array_richcompare+587
	DD	imagerel array_richcompare+1028
	DD	imagerel $chain$2$array_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$array_richcompare DD 020021H
	DD	0cd400H
	DD	imagerel array_richcompare
	DD	imagerel array_richcompare+235
	DD	imagerel $unwind$array_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$array_richcompare DD 021H
	DD	imagerel array_richcompare
	DD	imagerel array_richcompare+235
	DD	imagerel $unwind$array_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$array_richcompare DD 020521H
	DD	0cd405H
	DD	imagerel array_richcompare
	DD	imagerel array_richcompare+235
	DD	imagerel $unwind$array_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_richcompare DD 0a1601H
	DD	0e5416H
	DD	0d3416H
	DD	0f0125216H
	DD	0c00ee010H
	DD	0600b700cH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
xdata	ENDS
;	COMDAT array_richcompare
_TEXT	SEGMENT
v$ = 96
w$ = 104
op$ = 112
array_richcompare PROC					; COMDAT

; 567  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 568  :     arrayobject *va, *wa;
; 569  :     PyObject *vi = NULL;

  00016	33 f6		 xor	 esi, esi
  00018	4c 8b f9	 mov	 r15, rcx

; 570  :     PyObject *wi = NULL;
; 571  :     Py_ssize_t i, k;
; 572  :     PyObject *res;
; 573  : 
; 574  :     if (!array_Check(v) || !array_Check(w))

  0001b	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0001f	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:Arraytype
  00026	4d 63 e0	 movsxd	 r12, r8d
  00029	4c 8b f2	 mov	 r14, rdx
  0002c	8b ee		 mov	 ebp, esi
  0002e	8b de		 mov	 ebx, esi
  00030	48 3b cf	 cmp	 rcx, rdi
  00033	74 0c		 je	 SHORT $LN36@array_rich
  00035	48 8b d7	 mov	 rdx, rdi
  00038	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003d	85 c0		 test	 eax, eax
  0003f	74 15		 je	 SHORT $LN37@array_rich
$LN36@array_rich:
  00041	49 8b 4e 58	 mov	 rcx, QWORD PTR [r14+88]
  00045	48 3b cf	 cmp	 rcx, rdi
  00048	74 5d		 je	 SHORT $LN38@array_rich
  0004a	48 8b d7	 mov	 rdx, rdi
  0004d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00052	85 c0		 test	 eax, eax
  00054	75 51		 jne	 SHORT $LN38@array_rich
$LN37@array_rich:

; 575  :         Py_RETURN_NOTIMPLEMENTED;

  00056	e8 00 00 00 00	 call	 _Py_PXCTX
  0005b	85 c0		 test	 eax, eax
  0005d	75 3c		 jne	 SHORT $LN42@array_rich
  0005f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00074	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0007a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00082	e8 00 00 00 00	 call	 _PyParallel_Guard
  00087	85 c0		 test	 eax, eax
  00089	75 09		 jne	 SHORT $LN41@array_rich
  0008b	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00092	74 07		 je	 SHORT $LN42@array_rich
$LN41@array_rich:
  00094	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN42@array_rich:
  0009b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000a2	e9 8d 01 00 00	 jmp	 $LN39@array_rich
$LN38@array_rich:

; 576  : 
; 577  :     va = (arrayobject *)v;
; 578  :     wa = (arrayobject *)w;
; 579  : 
; 580  :     if (Py_SIZE(va) != Py_SIZE(wa) && (op == Py_EQ || op == Py_NE)) {

  000a7	49 8b 47 60	 mov	 rax, QWORD PTR [r15+96]
  000ab	49 3b 46 60	 cmp	 rax, QWORD PTR [r14+96]
  000af	74 3a		 je	 SHORT $LN35@array_rich
  000b1	41 83 fc 02	 cmp	 r12d, 2
  000b5	74 1d		 je	 SHORT $LN84@array_rich
  000b7	41 83 fc 03	 cmp	 r12d, 3
  000bb	75 2e		 jne	 SHORT $LN35@array_rich

; 584  :         else
; 585  :             res = Py_True;

  000bd	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_TrueStruct

; 586  :         Py_INCREF(res);

  000c4	48 8b cf	 mov	 rcx, rdi
  000c7	e8 00 00 00 00	 call	 _Py_IncRef

; 587  :         return res;

  000cc	48 8b c7	 mov	 rax, rdi
  000cf	e9 60 01 00 00	 jmp	 $LN39@array_rich
$LN84@array_rich:

; 581  :         /* Shortcut: if the lengths differ, the arrays differ */
; 582  :         if (op == Py_EQ)
; 583  :             res = Py_False;

  000d4	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_FalseStruct

; 586  :         Py_INCREF(res);

  000db	48 8b cf	 mov	 rcx, rdi
  000de	e8 00 00 00 00	 call	 _Py_IncRef

; 587  :         return res;

  000e3	48 8b c7	 mov	 rax, rdi
  000e6	e9 49 01 00 00	 jmp	 $LN39@array_rich
$LN35@array_rich:
  000eb	4c 89 6c 24 60	 mov	 QWORD PTR [rsp+96], r13

; 588  :     }
; 589  : 
; 590  :     /* Search for the first index where items are different */
; 591  :     k = 1;
; 592  :     for (i = 0; i < Py_SIZE(va) && i < Py_SIZE(wa); i++) {

  000f0	48 8b fe	 mov	 rdi, rsi
  000f3	41 bd 01 00 00
	00		 mov	 r13d, 1
  000f9	48 85 c0	 test	 rax, rax
  000fc	0f 8e 38 02 00
	00		 jle	 $LN85@array_rich
$LL31@array_rich:
  00102	49 3b 7e 60	 cmp	 rdi, QWORD PTR [r14+96]
  00106	7d 68		 jge	 SHORT $LN29@array_rich

; 593  :         vi = getarrayitem(v, i);

  00108	48 8b d7	 mov	 rdx, rdi
  0010b	49 8b cf	 mov	 rcx, r15
  0010e	e8 00 00 00 00	 call	 getarrayitem

; 594  :         wi = getarrayitem(w, i);

  00113	48 8b d7	 mov	 rdx, rdi
  00116	49 8b ce	 mov	 rcx, r14
  00119	48 8b e8	 mov	 rbp, rax
  0011c	e8 00 00 00 00	 call	 getarrayitem
  00121	48 8b d8	 mov	 rbx, rax

; 595  :         if (vi == NULL || wi == NULL) {

  00124	48 85 ed	 test	 rbp, rbp
  00127	0f 84 28 01 00
	00		 je	 $LN25@array_rich
  0012d	48 85 c0	 test	 rax, rax
  00130	0f 84 9f 00 00
	00		 je	 $LN26@array_rich

; 599  :         }
; 600  :         k = PyObject_RichCompareBool(vi, wi, Py_EQ);

  00136	41 b8 02 00 00
	00		 mov	 r8d, 2
  0013c	48 8b d0	 mov	 rdx, rax
  0013f	48 8b cd	 mov	 rcx, rbp
  00142	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00147	4c 63 e8	 movsxd	 r13, eax

; 601  :         if (k == 0)

  0014a	85 c0		 test	 eax, eax
  0014c	74 2b		 je	 SHORT $LN16@array_rich

; 602  :             break; /* Keeping vi and wi alive! */
; 603  :         Py_DECREF(vi);

  0014e	48 8b cd	 mov	 rcx, rbp
  00151	e8 00 00 00 00	 call	 _Py_DecRef

; 604  :         Py_DECREF(wi);

  00156	48 8b cb	 mov	 rcx, rbx
  00159	e8 00 00 00 00	 call	 _Py_DecRef

; 605  :         if (k < 0)

  0015e	4d 85 ed	 test	 r13, r13
  00161	0f 88 c6 00 00
	00		 js	 $LN7@array_rich

; 588  :     }
; 589  : 
; 590  :     /* Search for the first index where items are different */
; 591  :     k = 1;
; 592  :     for (i = 0; i < Py_SIZE(va) && i < Py_SIZE(wa); i++) {

  00167	48 ff c7	 inc	 rdi
  0016a	49 3b 7f 60	 cmp	 rdi, QWORD PTR [r15+96]
  0016e	7c 92		 jl	 SHORT $LL31@array_rich
$LN29@array_rich:

; 606  :             return NULL;
; 607  :     }
; 608  : 
; 609  :     if (k) {

  00170	4d 85 ed	 test	 r13, r13
  00173	0f 85 c1 01 00
	00		 jne	 $LN85@array_rich
$LN16@array_rich:

; 629  :     }
; 630  : 
; 631  :     /* We have an item that differs.  First, shortcuts for EQ/NE */
; 632  :     if (op == Py_EQ) {

  00179	41 83 fc 02	 cmp	 r12d, 2
  0017d	0f 85 3e 01 00
	00		 jne	 $LN4@array_rich

; 633  :         Py_INCREF(Py_False);

  00183	e8 00 00 00 00	 call	 _Py_PXCTX
  00188	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_FalseStruct
  0018f	85 c0		 test	 eax, eax
  00191	0f 85 8b 01 00
	00		 jne	 $LN1@array_rich
  00197	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0019e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  001a5	4c 8b cf	 mov	 r9, rdi
  001a8	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  001ae	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  001b3	e8 00 00 00 00	 call	 _PyParallel_Guard
  001b8	85 c0		 test	 eax, eax
  001ba	75 0d		 jne	 SHORT $LN71@array_rich
  001bc	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  001c3	0f 84 59 01 00
	00		 je	 $LN1@array_rich
$LN71@array_rich:
  001c9	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80

; 634  :         res = Py_False;

  001d0	e9 4d 01 00 00	 jmp	 $LN1@array_rich
$LN26@array_rich:

; 596  :             Py_XDECREF(vi);

  001d5	e8 00 00 00 00	 call	 _Py_PXCTX
  001da	85 c0		 test	 eax, eax
  001dc	75 4f		 jne	 SHORT $LN7@array_rich
  001de	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  001e2	a8 20		 test	 al, 32			; 00000020H
  001e4	75 65		 jne	 SHORT $LN49@array_rich
  001e6	84 c0		 test	 al, al
  001e8	78 61		 js	 SHORT $LN49@array_rich
  001ea	a8 02		 test	 al, 2
  001ec	75 3f		 jne	 SHORT $LN7@array_rich
  001ee	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  001f2	75 39		 jne	 SHORT $LN7@array_rich
  001f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00202	4c 8b cd	 mov	 r9, rbp
  00205	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0020b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00213	e8 00 00 00 00	 call	 _PyParallel_Guard
  00218	48 8b cd	 mov	 rcx, rbp
  0021b	85 c0		 test	 eax, eax
  0021d	0f 85 81 00 00
	00		 jne	 $LN89@array_rich
  00223	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
$LN90@array_rich:
  00227	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
$LN7@array_rich:

; 621  :         default: return NULL; /* cannot happen */

  0022d	33 c0		 xor	 eax, eax
$LN87@array_rich:
  0022f	4c 8b 6c 24 60	 mov	 r13, QWORD PTR [rsp+96]
$LN39@array_rich:

; 647  : }

  00234	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  00239	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  0023e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00242	41 5f		 pop	 r15
  00244	41 5e		 pop	 r14
  00246	41 5c		 pop	 r12
  00248	5f		 pop	 rdi
  00249	5e		 pop	 rsi
  0024a	c3		 ret	 0

; 596  :             Py_XDECREF(vi);

$LN49@array_rich:
  0024b	48 8b cd	 mov	 rcx, rbp

; 597  :             Py_XDECREF(wi);

  0024e	e8 00 00 00 00	 call	 Px_DecRef

; 598  :             return NULL;

  00253	eb d8		 jmp	 SHORT $LN7@array_rich
$LN25@array_rich:

; 597  :             Py_XDECREF(wi);

  00255	48 85 c0	 test	 rax, rax
  00258	74 d3		 je	 SHORT $LN7@array_rich
  0025a	e8 00 00 00 00	 call	 _Py_PXCTX
  0025f	85 c0		 test	 eax, eax
  00261	75 ca		 jne	 SHORT $LN7@array_rich
  00263	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00267	a8 20		 test	 al, 32			; 00000020H
  00269	75 49		 jne	 SHORT $LN60@array_rich
  0026b	84 c0		 test	 al, al
  0026d	78 45		 js	 SHORT $LN60@array_rich
  0026f	a8 02		 test	 al, 2
  00271	75 ba		 jne	 SHORT $LN7@array_rich
  00273	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00277	75 b4		 jne	 SHORT $LN7@array_rich
  00279	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00280	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00287	4c 8b cb	 mov	 r9, rbx
  0028a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00290	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00298	e8 00 00 00 00	 call	 _PyParallel_Guard
  0029d	48 8b cb	 mov	 rcx, rbx
  002a0	85 c0		 test	 eax, eax
  002a2	74 07		 je	 SHORT $LN65@array_rich
$LN89@array_rich:
  002a4	e8 00 00 00 00	 call	 _Px_Dealloc
  002a9	eb 82		 jmp	 SHORT $LN7@array_rich
$LN65@array_rich:
  002ab	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  002af	e9 73 ff ff ff	 jmp	 $LN90@array_rich
$LN60@array_rich:
  002b4	48 8b cb	 mov	 rcx, rbx
  002b7	e8 00 00 00 00	 call	 Px_DecRef

; 598  :             return NULL;

  002bc	e9 6c ff ff ff	 jmp	 $LN7@array_rich
$LN4@array_rich:

; 635  :     }
; 636  :     else if (op == Py_NE) {

  002c1	41 83 fc 03	 cmp	 r12d, 3
  002c5	75 4a		 jne	 SHORT $LN2@array_rich

; 637  :         Py_INCREF(Py_True);

  002c7	e8 00 00 00 00	 call	 _Py_PXCTX
  002cc	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_TrueStruct
  002d3	85 c0		 test	 eax, eax
  002d5	75 4b		 jne	 SHORT $LN1@array_rich
  002d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  002e5	4c 8b cf	 mov	 r9, rdi
  002e8	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  002ee	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  002f6	e8 00 00 00 00	 call	 _PyParallel_Guard
  002fb	85 c0		 test	 eax, eax
  002fd	75 09		 jne	 SHORT $LN75@array_rich
  002ff	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  00306	74 1a		 je	 SHORT $LN1@array_rich
$LN75@array_rich:
  00308	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80

; 638  :         res = Py_True;
; 639  :     }
; 640  :     else {

  0030f	eb 11		 jmp	 SHORT $LN1@array_rich
$LN2@array_rich:

; 641  :         /* Compare the final item again using the proper operator */
; 642  :         res = PyObject_RichCompare(vi, wi, op);

  00311	45 8b c4	 mov	 r8d, r12d
  00314	48 8b d3	 mov	 rdx, rbx
  00317	48 8b cd	 mov	 rcx, rbp
  0031a	e8 00 00 00 00	 call	 PyObject_RichCompare
  0031f	48 8b f8	 mov	 rdi, rax
$LN1@array_rich:

; 643  :     }
; 644  :     Py_DECREF(vi);

  00322	48 8b cd	 mov	 rcx, rbp
  00325	e8 00 00 00 00	 call	 _Py_DecRef

; 645  :     Py_DECREF(wi);

  0032a	48 8b cb	 mov	 rcx, rbx
  0032d	e8 00 00 00 00	 call	 _Py_DecRef

; 646  :     return res;

  00332	48 8b c7	 mov	 rax, rdi
  00335	e9 f5 fe ff ff	 jmp	 $LN87@array_rich
$LN85@array_rich:

; 610  :         /* No more items to compare -- compare sizes */
; 611  :         Py_ssize_t vs = Py_SIZE(va);

  0033a	49 8b 57 60	 mov	 rdx, QWORD PTR [r15+96]

; 612  :         Py_ssize_t ws = Py_SIZE(wa);

  0033e	4d 8b 46 60	 mov	 r8, QWORD PTR [r14+96]

; 613  :         int cmp;
; 614  :         switch (op) {

  00342	41 83 fc 05	 cmp	 r12d, 5
  00346	0f 87 e1 fe ff
	ff		 ja	 $LN7@array_rich
  0034c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:__ImageBase
  00353	43 8b 8c a1 00
	00 00 00	 mov	 ecx, DWORD PTR $LN86@array_rich[r9+r12*4]
  0035b	49 03 c9	 add	 rcx, r9
  0035e	ff e1		 jmp	 rcx
$LN13@array_rich:

; 615  :         case Py_LT: cmp = vs <  ws; break;

  00360	49 3b d0	 cmp	 rdx, r8
  00363	40 0f 9c c6	 setl	 sil
  00367	eb 2b		 jmp	 SHORT $LN14@array_rich
$LN12@array_rich:

; 616  :         case Py_LE: cmp = vs <= ws; break;

  00369	49 3b d0	 cmp	 rdx, r8
  0036c	40 0f 9e c6	 setle	 sil
  00370	eb 22		 jmp	 SHORT $LN14@array_rich
$LN11@array_rich:

; 617  :         case Py_EQ: cmp = vs == ws; break;

  00372	49 3b d0	 cmp	 rdx, r8
  00375	40 0f 94 c6	 sete	 sil
  00379	eb 19		 jmp	 SHORT $LN14@array_rich
$LN10@array_rich:

; 618  :         case Py_NE: cmp = vs != ws; break;

  0037b	49 3b d0	 cmp	 rdx, r8
  0037e	40 0f 95 c6	 setne	 sil
  00382	eb 10		 jmp	 SHORT $LN14@array_rich
$LN9@array_rich:

; 619  :         case Py_GT: cmp = vs >  ws; break;

  00384	49 3b d0	 cmp	 rdx, r8
  00387	40 0f 9f c6	 setg	 sil
  0038b	eb 07		 jmp	 SHORT $LN14@array_rich
$LN8@array_rich:

; 620  :         case Py_GE: cmp = vs >= ws; break;

  0038d	49 3b d0	 cmp	 rdx, r8
  00390	40 0f 9d c6	 setge	 sil
$LN14@array_rich:

; 622  :         }
; 623  :         if (cmp)

  00394	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_TrueStruct
  0039b	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_FalseStruct
  003a2	85 f6		 test	 esi, esi
  003a4	48 0f 44 df	 cmove	 rbx, rdi

; 624  :             res = Py_True;
; 625  :         else
; 626  :             res = Py_False;
; 627  :         Py_INCREF(res);

  003a8	e8 00 00 00 00	 call	 _Py_PXCTX
  003ad	85 c0		 test	 eax, eax
  003af	75 32		 jne	 SHORT $LN68@array_rich
  003b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  003bf	4c 8b cb	 mov	 r9, rbx
  003c2	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  003c8	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  003d0	e8 00 00 00 00	 call	 _PyParallel_Guard
  003d5	85 c0		 test	 eax, eax
  003d7	75 06		 jne	 SHORT $LN67@array_rich
  003d9	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  003dd	74 04		 je	 SHORT $LN68@array_rich
$LN67@array_rich:
  003df	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN68@array_rich:

; 628  :         return res;

  003e3	48 8b c3	 mov	 rax, rbx
  003e6	e9 44 fe ff ff	 jmp	 $LN87@array_rich
  003eb	90		 npad	 1
$LN86@array_rich:

; 647  : }

  003ec	00 00 00 00	 DD	 $LN13@array_rich
  003f0	00 00 00 00	 DD	 $LN12@array_rich
  003f4	00 00 00 00	 DD	 $LN11@array_rich
  003f8	00 00 00 00	 DD	 $LN10@array_rich
  003fc	00 00 00 00	 DD	 $LN9@array_rich
  00400	00 00 00 00	 DD	 $LN8@array_rich
array_richcompare ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT array_length
_TEXT	SEGMENT
a$ = 8
array_length PROC					; COMDAT

; 652  :     return Py_SIZE(a);

  00000	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]

; 653  : }

  00004	c3		 ret	 0
array_length ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@FONIJAGJ@array?5index?5out?5of?5range?$AA@ ; `string'
EXTRN	PyExc_IndexError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_item DD imagerel array_item
	DD	imagerel array_item+50
	DD	imagerel $unwind$array_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_item DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BJ@FONIJAGJ@array?5index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BJ@FONIJAGJ@array?5index?5out?5of?5range?$AA@ DB 'array index out '
	DB	'of range', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_item
_TEXT	SEGMENT
a$ = 48
i$ = 56
array_item PROC						; COMDAT

; 657  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 658  :     if (i < 0 || i >= Py_SIZE(a)) {

  00004	48 85 d2	 test	 rdx, rdx
  00007	78 0f		 js	 SHORT $LN1@array_item
  00009	48 3b 51 60	 cmp	 rdx, QWORD PTR [rcx+96]
  0000d	7d 09		 jge	 SHORT $LN1@array_item

; 661  :     }
; 662  :     return getarrayitem((PyObject *)a, i);
; 663  : }

  0000f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00013	e9 00 00 00 00	 jmp	 getarrayitem
$LN1@array_item:

; 659  :         PyErr_SetString(PyExc_IndexError, "array index out of range");

  00018	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@FONIJAGJ@array?5index?5out?5of?5range?$AA@
  00026	e8 00 00 00 00	 call	 PyErr_SetString

; 660  :         return NULL;

  0002b	33 c0		 xor	 eax, eax

; 661  :     }
; 662  :     return getarrayitem((PyObject *)a, i);
; 663  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
array_item ENDP
_TEXT	ENDS
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_slice DD imagerel array_slice
	DD	imagerel array_slice+171
	DD	imagerel $unwind$array_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_slice DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT array_slice
_TEXT	SEGMENT
a$ = 48
ilow$ = 56
ihigh$ = 64
array_slice PROC					; COMDAT

; 667  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b f1	 mov	 rsi, rcx

; 668  :     arrayobject *np;
; 669  :     if (ilow < 0)

  00017	33 c9		 xor	 ecx, ecx
  00019	49 8b d8	 mov	 rbx, r8
  0001c	48 8b fa	 mov	 rdi, rdx
  0001f	48 85 d2	 test	 rdx, rdx
  00022	79 04		 jns	 SHORT $LN8@array_slic

; 670  :         ilow = 0;

  00024	8b f9		 mov	 edi, ecx
  00026	eb 0b		 jmp	 SHORT $LN6@array_slic
$LN8@array_slic:

; 671  :     else if (ilow > Py_SIZE(a))

  00028	48 8b 46 60	 mov	 rax, QWORD PTR [rsi+96]
  0002c	48 3b d0	 cmp	 rdx, rax
  0002f	48 0f 4f f8	 cmovg	 rdi, rax
$LN6@array_slic:

; 672  :         ilow = Py_SIZE(a);
; 673  :     if (ihigh < 0)

  00033	48 85 db	 test	 rbx, rbx
  00036	48 0f 48 d9	 cmovs	 rbx, rcx

; 674  :         ihigh = 0;
; 675  :     if (ihigh < ilow)

  0003a	48 3b df	 cmp	 rbx, rdi
  0003d	7d 05		 jge	 SHORT $LN4@array_slic

; 676  :         ihigh = ilow;

  0003f	48 8b df	 mov	 rbx, rdi
  00042	eb 0b		 jmp	 SHORT $LN2@array_slic
$LN4@array_slic:

; 677  :     else if (ihigh > Py_SIZE(a))

  00044	48 8b 46 60	 mov	 rax, QWORD PTR [rsi+96]
  00048	48 3b d8	 cmp	 rbx, rax
  0004b	48 0f 4f d8	 cmovg	 rbx, rax
$LN2@array_slic:

; 678  :         ihigh = Py_SIZE(a);
; 679  :     np = (arrayobject *) newarrayobject(&Arraytype, ihigh - ilow, a->ob_descr);

  0004f	4c 8b 86 80 00
	00 00		 mov	 r8, QWORD PTR [rsi+128]
  00056	48 2b df	 sub	 rbx, rdi
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Arraytype
  00060	48 8b d3	 mov	 rdx, rbx
  00063	e8 00 00 00 00	 call	 newarrayobject
  00068	48 8b e8	 mov	 rbp, rax

; 680  :     if (np == NULL)

  0006b	48 85 c0	 test	 rax, rax
  0006e	74 26		 je	 SHORT $LN9@array_slic
$LN1@array_slic:

; 681  :         return NULL;
; 682  :     memcpy(np->ob_item, a->ob_item + ilow * a->ob_descr->itemsize,
; 683  :            (ihigh-ilow) * a->ob_descr->itemsize);

  00070	48 8b 86 80 00
	00 00		 mov	 rax, QWORD PTR [rsi+128]
  00077	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  0007b	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  0007f	4c 8b c2	 mov	 r8, rdx
  00082	48 0f af d7	 imul	 rdx, rdi
  00086	4c 0f af c3	 imul	 r8, rbx
  0008a	48 03 56 70	 add	 rdx, QWORD PTR [rsi+112]
  0008e	e8 00 00 00 00	 call	 memcpy

; 684  :     return (PyObject *)np;

  00093	48 8b c5	 mov	 rax, rbp
$LN9@array_slic:

; 685  : }

  00096	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009b	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000a0	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000a5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a9	5f		 pop	 rdi
  000aa	c3		 ret	 0
array_slice ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT array_copy
_TEXT	SEGMENT
a$ = 8
unused$ = 16
array_copy PROC						; COMDAT

; 690  :     return array_slice(a, 0, Py_SIZE(a));

  00000	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  00004	33 d2		 xor	 edx, edx

; 691  : }

  00006	e9 00 00 00 00	 jmp	 array_slice
array_copy ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@HGBNJIFC@can?5only?5append?5array?5?$CInot?5?$CC?$CF?420@ ; `string'
EXTRN	PyErr_BadArgument:PROC
EXTRN	PyErr_Format:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_concat DD imagerel array_concat
	DD	imagerel array_concat+291
	DD	imagerel $unwind$array_concat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_concat DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CO@HGBNJIFC@can?5only?5append?5array?5?$CInot?5?$CC?$CF?420@
CONST	SEGMENT
??_C@_0CO@HGBNJIFC@can?5only?5append?5array?5?$CInot?5?$CC?$CF?420@ DB 'c'
	DB	'an only append array (not "%.200s") to array', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_concat
_TEXT	SEGMENT
a$ = 48
bb$ = 56
array_concat PROC					; COMDAT

; 700  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f9	 mov	 rdi, rcx

; 701  :     Py_ssize_t size;
; 702  :     arrayobject *np;
; 703  :     if (!array_Check(bb)) {

  00012	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00016	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:Arraytype
  0001d	48 8b da	 mov	 rbx, rdx
  00020	48 3b ce	 cmp	 rcx, rsi
  00023	74 39		 je	 SHORT $LN4@array_conc
  00025	48 8b d6	 mov	 rdx, rsi
  00028	e8 00 00 00 00	 call	 PyType_IsSubtype
  0002d	85 c0		 test	 eax, eax
  0002f	75 2d		 jne	 SHORT $LN4@array_conc

; 704  :         PyErr_Format(PyExc_TypeError,
; 705  :              "can only append array (not \"%.200s\") to array",
; 706  :                  Py_TYPE(bb)->tp_name);

  00031	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@HGBNJIFC@can?5only?5append?5array?5?$CInot?5?$CC?$CF?420@
  00043	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00047	e8 00 00 00 00	 call	 PyErr_Format
$LN7@array_conc:

; 707  :         return NULL;

  0004c	33 c0		 xor	 eax, eax

; 725  :     return (PyObject *)np;
; 726  : #undef b
; 727  : }

  0004e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00053	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
$LN4@array_conc:

; 708  :     }
; 709  : #define b ((arrayobject *)bb)
; 710  :     if (a->ob_descr != b->ob_descr) {

  0005e	4c 8b 87 80 00
	00 00		 mov	 r8, QWORD PTR [rdi+128]
  00065	4c 3b 83 80 00
	00 00		 cmp	 r8, QWORD PTR [rbx+128]
  0006c	74 17		 je	 SHORT $LN3@array_conc

; 711  :         PyErr_BadArgument();

  0006e	e8 00 00 00 00	 call	 PyErr_BadArgument

; 712  :         return NULL;

  00073	33 c0		 xor	 eax, eax

; 725  :     return (PyObject *)np;
; 726  : #undef b
; 727  : }

  00075	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
$LN3@array_conc:

; 713  :     }
; 714  :     if (Py_SIZE(a) > PY_SSIZE_T_MAX - Py_SIZE(b)) {

  00085	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00089	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]
  0008d	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00097	48 2b c1	 sub	 rax, rcx
  0009a	48 3b d0	 cmp	 rdx, rax
  0009d	7e 14		 jle	 SHORT $LN2@array_conc

; 725  :     return (PyObject *)np;
; 726  : #undef b
; 727  : }

  0009f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a4	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000a9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ad	5f		 pop	 rdi
  000ae	e9 00 00 00 00	 jmp	 PyErr_NoMemory
$LN2@array_conc:

; 715  :         return PyErr_NoMemory();
; 716  :     }
; 717  :     size = Py_SIZE(a) + Py_SIZE(b);

  000b3	48 03 d1	 add	 rdx, rcx

; 718  :     np = (arrayobject *) newarrayobject(&Arraytype, size, a->ob_descr);

  000b6	48 8b ce	 mov	 rcx, rsi
  000b9	e8 00 00 00 00	 call	 newarrayobject
  000be	48 8b f0	 mov	 rsi, rax

; 719  :     if (np == NULL) {

  000c1	48 85 c0	 test	 rax, rax

; 720  :         return NULL;

  000c4	74 86		 je	 SHORT $LN7@array_conc

; 721  :     }
; 722  :     memcpy(np->ob_item, a->ob_item, Py_SIZE(a)*a->ob_descr->itemsize);

  000c6	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  000cd	48 8b 57 70	 mov	 rdx, QWORD PTR [rdi+112]
  000d1	48 8b 4e 70	 mov	 rcx, QWORD PTR [rsi+112]
  000d5	4c 63 40 04	 movsxd	 r8, DWORD PTR [rax+4]
  000d9	4c 0f af 47 60	 imul	 r8, QWORD PTR [rdi+96]
  000de	e8 00 00 00 00	 call	 memcpy

; 723  :     memcpy(np->ob_item + Py_SIZE(a)*a->ob_descr->itemsize,
; 724  :            b->ob_item, Py_SIZE(b)*b->ob_descr->itemsize);

  000e3	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  000ea	4c 8b 9b 80 00
	00 00		 mov	 r11, QWORD PTR [rbx+128]
  000f1	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000f5	4d 63 43 04	 movsxd	 r8, DWORD PTR [r11+4]
  000f9	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
  000fd	48 0f af 4f 60	 imul	 rcx, QWORD PTR [rdi+96]
  00102	4c 0f af 43 60	 imul	 r8, QWORD PTR [rbx+96]
  00107	48 03 4e 70	 add	 rcx, QWORD PTR [rsi+112]
  0010b	e8 00 00 00 00	 call	 memcpy

; 725  :     return (PyObject *)np;
; 726  : #undef b
; 727  : }

  00110	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00115	48 8b c6	 mov	 rax, rsi
  00118	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0011d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00121	5f		 pop	 rdi
  00122	c3		 ret	 0
array_concat ENDP
_TEXT	ENDS
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_repeat DD imagerel array_repeat
	DD	imagerel array_repeat+80
	DD	imagerel $unwind$array_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$array_repeat DD imagerel array_repeat+80
	DD	imagerel array_repeat+124
	DD	imagerel $chain$0$array_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$array_repeat DD imagerel array_repeat+124
	DD	imagerel array_repeat+145
	DD	imagerel $chain$2$array_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$array_repeat DD imagerel array_repeat+145
	DD	imagerel array_repeat+373
	DD	imagerel $chain$4$array_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$array_repeat DD imagerel array_repeat+373
	DD	imagerel array_repeat+389
	DD	imagerel $chain$5$array_repeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$array_repeat DD 021H
	DD	imagerel array_repeat+124
	DD	imagerel array_repeat+145
	DD	imagerel $chain$2$array_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$array_repeat DD 040e21H
	DD	07540eH
	DD	063405H
	DD	imagerel array_repeat+124
	DD	imagerel array_repeat+145
	DD	imagerel $chain$2$array_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$array_repeat DD 020021H
	DD	08c400H
	DD	imagerel array_repeat
	DD	imagerel array_repeat+80
	DD	imagerel $unwind$array_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$array_repeat DD 020521H
	DD	08c405H
	DD	imagerel array_repeat
	DD	imagerel array_repeat+80
	DD	imagerel $unwind$array_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_repeat DD 040a01H
	DD	09640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT array_repeat
_TEXT	SEGMENT
a$ = 48
n$ = 56
array_repeat PROC					; COMDAT

; 731  : {

  00000	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 732  :     Py_ssize_t size;
; 733  :     arrayobject *np;
; 734  :     Py_ssize_t oldbytes, newbytes;
; 735  :     if (n < 0)

  0000a	33 c0		 xor	 eax, eax
  0000c	48 85 d2	 test	 rdx, rdx
  0000f	48 8b f1	 mov	 rsi, rcx

; 736  :         n = 0;
; 737  :     if ((Py_SIZE(a) != 0) && (n > PY_SSIZE_T_MAX / Py_SIZE(a))) {

  00012	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00016	48 8b fa	 mov	 rdi, rdx
  00019	48 0f 48 f8	 cmovs	 rdi, rax
  0001d	48 85 c9	 test	 rcx, rcx
  00020	74 23		 je	 SHORT $LN23@array_repe
  00022	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0002c	48 99		 cdq
  0002e	48 f7 f9	 idiv	 rcx
  00031	48 3b f8	 cmp	 rdi, rax
  00034	7e 0f		 jle	 SHORT $LN23@array_repe

; 761  : }

  00036	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5f		 pop	 rdi
  00040	e9 00 00 00 00	 jmp	 PyErr_NoMemory
$LN23@array_repe:

; 738  :         return PyErr_NoMemory();
; 739  :     }
; 740  :     size = Py_SIZE(a) * n;
; 741  :     np = (arrayobject *) newarrayobject(&Arraytype, size, a->ob_descr);

  00045	4c 8b 86 80 00
	00 00		 mov	 r8, QWORD PTR [rsi+128]
  0004c	48 0f af cf	 imul	 rcx, rdi
  00050	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12
  00055	48 8b d1	 mov	 rdx, rcx
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Arraytype
  0005f	e8 00 00 00 00	 call	 newarrayobject
  00064	4c 8b e0	 mov	 r12, rax

; 742  :     if (np == NULL)

  00067	48 85 c0	 test	 rax, rax
  0006a	75 10		 jne	 SHORT $LN22@array_repe
  0006c	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]

; 761  : }

  00071	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00076	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007a	5f		 pop	 rdi
  0007b	c3		 ret	 0
$LN22@array_repe:

; 743  :         return NULL;
; 744  :     if (n == 0)

  0007c	48 85 ff	 test	 rdi, rdi

; 745  :         return (PyObject *)np;

  0007f	0f 84 f0 00 00
	00		 je	 $LN35@array_repe

; 746  :     oldbytes = Py_SIZE(a) * a->ob_descr->itemsize;

  00085	48 8b 86 80 00
	00 00		 mov	 rax, QWORD PTR [rsi+128]

; 747  :     newbytes = oldbytes * n;
; 748  :     /* this follows the code in unicode_repeat */
; 749  :     if (oldbytes == 1) {
; 750  :         memset(np->ob_item, a->ob_item[0], newbytes);

  0008c	49 8b 4c 24 70	 mov	 rcx, QWORD PTR [r12+112]
  00091	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00096	48 63 58 04	 movsxd	 rbx, DWORD PTR [rax+4]
  0009a	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  0009f	48 0f af 5e 60	 imul	 rbx, QWORD PTR [rsi+96]
  000a4	48 8b eb	 mov	 rbp, rbx
  000a7	48 0f af ef	 imul	 rbp, rdi
  000ab	48 83 fb 01	 cmp	 rbx, 1
  000af	75 14		 jne	 SHORT $LN20@array_repe
  000b1	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  000b5	4c 8b c5	 mov	 r8, rbp
  000b8	0f be 10	 movsx	 edx, BYTE PTR [rax]
  000bb	e8 00 00 00 00	 call	 memset

; 751  :     } else {

  000c0	e9 a3 00 00 00	 jmp	 $LN9@array_repe
$LN20@array_repe:

; 752  :         Py_ssize_t done = oldbytes;
; 753  :         Py_MEMCPY(np->ob_item, a->ob_item, oldbytes);

  000c5	4c 8b 4e 70	 mov	 r9, QWORD PTR [rsi+112]
  000c9	48 83 fb 10	 cmp	 rbx, 16
  000cd	72 0d		 jb	 SHORT $LN15@array_repe
  000cf	4c 8b c3	 mov	 r8, rbx
  000d2	49 8b d1	 mov	 rdx, r9
  000d5	e8 00 00 00 00	 call	 memcpy
  000da	eb 24		 jmp	 SHORT $LN17@array_repe
$LN15@array_repe:
  000dc	48 85 db	 test	 rbx, rbx
  000df	74 1f		 je	 SHORT $LN17@array_repe
  000e1	4c 2b c9	 sub	 r9, rcx
  000e4	48 8b d3	 mov	 rdx, rbx
  000e7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL13@array_repe:
  000f0	41 0f b6 04 09	 movzx	 eax, BYTE PTR [r9+rcx]
  000f5	48 ff c1	 inc	 rcx
  000f8	48 ff ca	 dec	 rdx
  000fb	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  000fe	75 f0		 jne	 SHORT $LL13@array_repe
$LN17@array_repe:

; 754  :         while (done < newbytes) {

  00100	48 3b dd	 cmp	 rbx, rbp
  00103	7d 63		 jge	 SHORT $LN9@array_repe
  00105	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL10@array_repe:

; 755  :             Py_ssize_t ncopy = (done <= newbytes-done) ? done : newbytes-done;
; 756  :             Py_MEMCPY(np->ob_item+done, np->ob_item, ncopy);

  00110	4d 8b 4c 24 70	 mov	 r9, QWORD PTR [r12+112]
  00115	48 8b fd	 mov	 rdi, rbp
  00118	48 2b fb	 sub	 rdi, rbx
  0011b	49 8d 0c 19	 lea	 rcx, QWORD PTR [r9+rbx]
  0011f	48 3b df	 cmp	 rbx, rdi
  00122	48 0f 4e fb	 cmovle	 rdi, rbx
  00126	48 83 ff 10	 cmp	 rdi, 16
  0012a	72 0d		 jb	 SHORT $LN5@array_repe
  0012c	4c 8b c7	 mov	 r8, rdi
  0012f	49 8b d1	 mov	 rdx, r9
  00132	e8 00 00 00 00	 call	 memcpy
  00137	eb 27		 jmp	 SHORT $LN7@array_repe
$LN5@array_repe:
  00139	48 85 ff	 test	 rdi, rdi
  0013c	74 22		 je	 SHORT $LN7@array_repe
  0013e	4c 2b c9	 sub	 r9, rcx
  00141	48 8b d7	 mov	 rdx, rdi
  00144	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL3@array_repe:
  00150	41 0f b6 04 09	 movzx	 eax, BYTE PTR [r9+rcx]
  00155	48 ff c1	 inc	 rcx
  00158	48 ff ca	 dec	 rdx
  0015b	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0015e	75 f0		 jne	 SHORT $LL3@array_repe
$LN7@array_repe:

; 757  :             done += ncopy;

  00160	48 03 df	 add	 rbx, rdi
  00163	48 3b dd	 cmp	 rbx, rbp
  00166	7c a8		 jl	 SHORT $LL10@array_repe
$LN9@array_repe:
  00168	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0016d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 758  :         }
; 759  :     }
; 760  :     return (PyObject *)np;

  00172	49 8b c4	 mov	 rax, r12
$LN35@array_repe:
  00175	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]

; 761  : }

  0017a	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0017f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00183	5f		 pop	 rdi
  00184	c3		 ret	 0
array_repeat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@JBAHFOA@can?5only?5assign?5array?5?$CInot?5?$CC?$CF?420@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_ass_slice DD imagerel array_ass_slice
	DD	imagerel array_ass_slice+573
	DD	imagerel $unwind$array_ass_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_ass_slice DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT ??_C@_0DE@JBAHFOA@can?5only?5assign?5array?5?$CInot?5?$CC?$CF?420@
CONST	SEGMENT
??_C@_0DE@JBAHFOA@can?5only?5assign?5array?5?$CInot?5?$CC?$CF?420@ DB 'ca'
	DB	'n only assign array (not "%.200s") to array slice', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_ass_slice
_TEXT	SEGMENT
d$1$ = 32
n$1$ = 40
a$ = 64
ilow$ = 72
ihigh$ = 80
item$1$ = 88
v$ = 88
array_ass_slice PROC					; COMDAT

; 765  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f2	 mov	 rsi, rdx

; 766  :     char *item;
; 767  :     Py_ssize_t n; /* Size of replacement array */
; 768  :     Py_ssize_t d; /* Change in size */
; 769  : #define b ((arrayobject *)v)
; 770  :     if (v == NULL)

  00017	33 d2		 xor	 edx, edx
  00019	49 8b e9	 mov	 rbp, r9
  0001c	49 8b d8	 mov	 rbx, r8
  0001f	48 8b f9	 mov	 rdi, rcx
  00022	4d 85 c9	 test	 r9, r9
  00025	75 18		 jne	 SHORT $LN22@array_ass_

; 771  :         n = 0;

  00027	8b ca		 mov	 ecx, edx
  00029	48 89 54 24 28	 mov	 QWORD PTR n$1$[rsp], rdx
$LN16@array_ass_:

; 794  :     }
; 795  :     if (ilow < 0)

  0002e	48 85 f6	 test	 rsi, rsi
  00031	0f 89 af 00 00
	00		 jns	 $LN14@array_ass_

; 796  :         ilow = 0;

  00037	48 8b f2	 mov	 rsi, rdx
  0003a	e9 b2 00 00 00	 jmp	 $LN12@array_ass_
$LN22@array_ass_:

; 772  :     else if (array_Check(v)) {

  0003f	49 8b 49 58	 mov	 rcx, QWORD PTR [r9+88]
  00043	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Arraytype
  0004a	48 3b c8	 cmp	 rcx, rax
  0004d	74 31		 je	 SHORT $LN19@array_ass_
  0004f	48 8b d0	 mov	 rdx, rax
  00052	e8 00 00 00 00	 call	 PyType_IsSubtype
  00057	85 c0		 test	 eax, eax
  00059	75 23		 jne	 SHORT $LN26@array_ass_

; 787  :         }
; 788  :     }
; 789  :     else {
; 790  :         PyErr_Format(PyExc_TypeError,
; 791  :          "can only assign array (not \"%.200s\") to array slice",
; 792  :                          Py_TYPE(v)->tp_name);

  0005b	4c 8b 45 58	 mov	 r8, QWORD PTR [rbp+88]
  0005f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@JBAHFOA@can?5only?5assign?5array?5?$CInot?5?$CC?$CF?420@
  0006d	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00071	e8 00 00 00 00	 call	 PyErr_Format

; 793  :         return -1;

  00076	83 c8 ff	 or	 eax, -1
  00079	e9 aa 01 00 00	 jmp	 $LN23@array_ass_
$LN26@array_ass_:

; 804  :         ihigh = Py_SIZE(a);
; 805  :     item = a->ob_item;

  0007e	33 d2		 xor	 edx, edx
$LN19@array_ass_:

; 773  :         n = Py_SIZE(b);

  00080	48 8b 4d 60	 mov	 rcx, QWORD PTR [rbp+96]
  00084	48 89 4c 24 28	 mov	 QWORD PTR n$1$[rsp], rcx

; 774  :         if (a == b) {

  00089	48 3b fd	 cmp	 rdi, rbp
  0008c	75 37		 jne	 SHORT $LN18@array_ass_

; 775  :             /* Special case "a[i:j] = a" -- copy b first */
; 776  :             int ret;
; 777  :             v = array_slice(b, 0, n);

  0008e	4c 8b c1	 mov	 r8, rcx
  00091	33 d2		 xor	 edx, edx
  00093	48 8b cd	 mov	 rcx, rbp
  00096	e8 00 00 00 00	 call	 array_slice
  0009b	48 8b e8	 mov	 rbp, rax

; 778  :             if (!v)

  0009e	48 85 c0	 test	 rax, rax

; 779  :                 return -1;

  000a1	74 3b		 je	 SHORT $LN28@array_ass_

; 780  :             ret = array_ass_slice(a, ilow, ihigh, v);

  000a3	4c 8b c8	 mov	 r9, rax
  000a6	4c 8b c3	 mov	 r8, rbx
  000a9	48 8b d6	 mov	 rdx, rsi
  000ac	48 8b cf	 mov	 rcx, rdi
  000af	e8 00 00 00 00	 call	 array_ass_slice

; 781  :             Py_DECREF(v);

  000b4	48 8b cd	 mov	 rcx, rbp
  000b7	8b d8		 mov	 ebx, eax
  000b9	e8 00 00 00 00	 call	 _Py_DecRef

; 782  :             return ret;

  000be	8b c3		 mov	 eax, ebx
  000c0	e9 63 01 00 00	 jmp	 $LN23@array_ass_
$LN18@array_ass_:

; 783  :         }
; 784  :         if (b->ob_descr != a->ob_descr) {

  000c5	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  000cc	48 39 85 80 00
	00 00		 cmp	 QWORD PTR [rbp+128], rax
  000d3	0f 84 55 ff ff
	ff		 je	 $LN16@array_ass_

; 785  :             PyErr_BadArgument();

  000d9	e8 00 00 00 00	 call	 PyErr_BadArgument
$LN28@array_ass_:

; 786  :             return -1;

  000de	83 c8 ff	 or	 eax, -1
  000e1	e9 42 01 00 00	 jmp	 $LN23@array_ass_
$LN14@array_ass_:

; 797  :     else if (ilow > Py_SIZE(a))

  000e6	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  000ea	48 3b f0	 cmp	 rsi, rax
  000ed	48 0f 4f f0	 cmovg	 rsi, rax
$LN12@array_ass_:

; 798  :         ilow = Py_SIZE(a);
; 799  :     if (ihigh < 0)

  000f1	48 85 db	 test	 rbx, rbx
  000f4	48 0f 48 da	 cmovs	 rbx, rdx

; 800  :         ihigh = 0;
; 801  :     if (ihigh < ilow)

  000f8	48 3b de	 cmp	 rbx, rsi
  000fb	7d 05		 jge	 SHORT $LN10@array_ass_

; 802  :         ihigh = ilow;

  000fd	48 8b de	 mov	 rbx, rsi
  00100	eb 0b		 jmp	 SHORT $LN8@array_ass_
$LN10@array_ass_:

; 803  :     else if (ihigh > Py_SIZE(a))

  00102	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00106	48 3b d8	 cmp	 rbx, rax
  00109	48 0f 4f d8	 cmovg	 rbx, rax
$LN8@array_ass_:

; 804  :         ihigh = Py_SIZE(a);
; 805  :     item = a->ob_item;

  0010d	4c 8b 57 70	 mov	 r10, QWORD PTR [rdi+112]

; 806  :     d = n - (ihigh-ilow);

  00111	48 2b cb	 sub	 rcx, rbx
  00114	48 03 ce	 add	 rcx, rsi
  00117	4c 89 54 24 58	 mov	 QWORD PTR item$1$[rsp], r10
  0011c	48 89 4c 24 20	 mov	 QWORD PTR d$1$[rsp], rcx

; 807  :     /* Issue #4509: If the array has exported buffers and the slice
; 808  :        assignment would change the size of the array, fail early to make
; 809  :        sure we don't modify it. */
; 810  :     if (d != 0 && a->ob_exports > 0) {

  00121	74 24		 je	 SHORT $LN7@array_ass_
  00123	83 bf 90 00 00
	00 00		 cmp	 DWORD PTR [rdi+144], 0
  0012a	7e 1b		 jle	 SHORT $LN7@array_ass_

; 811  :         PyErr_SetString(PyExc_BufferError,
; 812  :             "cannot resize an array that is exporting buffers");

  0012c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00133	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@GJKGCBFK@cannot?5resize?5an?5array?5that?5is?5e@
  0013a	e8 00 00 00 00	 call	 PyErr_SetString

; 813  :         return -1;

  0013f	83 c8 ff	 or	 eax, -1
  00142	e9 e1 00 00 00	 jmp	 $LN23@array_ass_
$LN7@array_ass_:

; 814  :     }
; 815  :     if (d < 0) { /* Delete -d items */

  00147	48 85 c9	 test	 rcx, rcx
  0014a	79 4d		 jns	 SHORT $LN27@array_ass_

; 816  :         memmove(item + (ihigh+d)*a->ob_descr->itemsize,
; 817  :             item + ihigh*a->ob_descr->itemsize,
; 818  :             (Py_SIZE(a)-ihigh)*a->ob_descr->itemsize);

  0014c	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  00153	4c 8b 47 60	 mov	 r8, QWORD PTR [rdi+96]
  00157	48 03 cb	 add	 rcx, rbx
  0015a	4c 63 48 04	 movsxd	 r9, DWORD PTR [rax+4]
  0015e	4c 2b c3	 sub	 r8, rbx
  00161	49 8b d1	 mov	 rdx, r9
  00164	49 0f af c9	 imul	 rcx, r9
  00168	4d 0f af c1	 imul	 r8, r9
  0016c	49 03 ca	 add	 rcx, r10
  0016f	48 0f af d3	 imul	 rdx, rbx
  00173	49 03 d2	 add	 rdx, r10
  00176	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 819  :         if (array_resize(a, Py_SIZE(a) + d) == -1)

  0017c	48 8b 54 24 20	 mov	 rdx, QWORD PTR d$1$[rsp]
  00181	48 8b cf	 mov	 rcx, rdi
  00184	48 03 57 60	 add	 rdx, QWORD PTR [rdi+96]
  00188	e8 00 00 00 00	 call	 array_resize
  0018d	83 f8 ff	 cmp	 eax, -1
  00190	75 5b		 jne	 SHORT $LN25@array_ass_

; 820  :             return -1;

  00192	0b c0		 or	 eax, eax
  00194	e9 8f 00 00 00	 jmp	 $LN23@array_ass_
$LN27@array_ass_:

; 821  :     }
; 822  :     else if (d > 0) { /* Insert d items */

  00199	7e 57		 jle	 SHORT $LN3@array_ass_

; 823  :         if (array_resize(a, Py_SIZE(a) + d))

  0019b	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  0019f	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  001a3	48 8b cf	 mov	 rcx, rdi
  001a6	e8 00 00 00 00	 call	 array_resize
  001ab	85 c0		 test	 eax, eax

; 824  :             return -1;

  001ad	0f 85 2b ff ff
	ff		 jne	 $LN28@array_ass_

; 825  :         memmove(item + (ihigh+d)*a->ob_descr->itemsize,
; 826  :             item + ihigh*a->ob_descr->itemsize,
; 827  :             (Py_SIZE(a)-ihigh)*a->ob_descr->itemsize);

  001b3	4c 8b 54 24 58	 mov	 r10, QWORD PTR item$1$[rsp]
  001b8	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  001bf	4c 8b 47 60	 mov	 r8, QWORD PTR [rdi+96]
  001c3	4c 63 48 04	 movsxd	 r9, DWORD PTR [rax+4]
  001c7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$1$[rsp]
  001cc	4c 2b c3	 sub	 r8, rbx
  001cf	48 03 cb	 add	 rcx, rbx
  001d2	49 8b d1	 mov	 rdx, r9
  001d5	4d 0f af c1	 imul	 r8, r9
  001d9	48 0f af d3	 imul	 rdx, rbx
  001dd	49 0f af c9	 imul	 rcx, r9
  001e1	49 03 d2	 add	 rdx, r10
  001e4	49 03 ca	 add	 rcx, r10
  001e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN25@array_ass_:

; 804  :         ihigh = Py_SIZE(a);
; 805  :     item = a->ob_item;

  001ed	4c 8b 54 24 58	 mov	 r10, QWORD PTR item$1$[rsp]
$LN3@array_ass_:

; 828  :     }
; 829  :     if (n > 0)

  001f2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$1$[rsp]
  001f7	48 85 c9	 test	 rcx, rcx
  001fa	7e 2a		 jle	 SHORT $LN1@array_ass_

; 830  :         memcpy(item + ilow*a->ob_descr->itemsize, b->ob_item,
; 831  :                n*b->ob_descr->itemsize);

  001fc	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR [rbp+128]
  00203	48 8b 55 70	 mov	 rdx, QWORD PTR [rbp+112]
  00207	4c 63 40 04	 movsxd	 r8, DWORD PTR [rax+4]
  0020b	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  00212	4c 0f af c1	 imul	 r8, rcx
  00216	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0021a	48 0f af ce	 imul	 rcx, rsi
  0021e	49 03 ca	 add	 rcx, r10
  00221	e8 00 00 00 00	 call	 memcpy
$LN1@array_ass_:

; 832  :     return 0;

  00226	33 c0		 xor	 eax, eax
$LN23@array_ass_:

; 833  : #undef b
; 834  : }

  00228	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0022d	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00232	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00237	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0023b	5f		 pop	 rdi
  0023c	c3		 ret	 0
array_ass_slice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@DDILIBCI@array?5assignment?5index?5out?5of?5ra@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_ass_item DD imagerel array_ass_item
	DD	imagerel array_ass_item+78
	DD	imagerel $unwind$array_ass_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_ass_item DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CE@DDILIBCI@array?5assignment?5index?5out?5of?5ra@
CONST	SEGMENT
??_C@_0CE@DDILIBCI@array?5assignment?5index?5out?5of?5ra@ DB 'array assig'
	DB	'nment index out of range', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_ass_item
_TEXT	SEGMENT
a$ = 48
i$ = 56
v$ = 64
array_ass_item PROC					; COMDAT

; 838  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 839  :     if (i < 0 || i >= Py_SIZE(a)) {

  00004	48 85 d2	 test	 rdx, rdx
  00007	78 2a		 js	 SHORT $LN2@array_ass_@2
  00009	48 3b 51 60	 cmp	 rdx, QWORD PTR [rcx+96]
  0000d	7d 24		 jge	 SHORT $LN2@array_ass_@2

; 843  :     }
; 844  :     if (v == NULL)

  0000f	4d 85 c0	 test	 r8, r8
  00012	75 10		 jne	 SHORT $LN1@array_ass_@2

; 845  :         return array_ass_slice(a, i, i+1, v);

  00014	4c 8d 42 01	 lea	 r8, QWORD PTR [rdx+1]
  00018	45 33 c9	 xor	 r9d, r9d

; 847  : }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	e9 00 00 00 00	 jmp	 array_ass_slice
$LN1@array_ass_@2:

; 846  :     return (*a->ob_descr->setitem)(a, i, v);

  00024	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]

; 847  : }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	48 ff 60 10	 rex_jmp QWORD PTR [rax+16]
$LN2@array_ass_@2:

; 840  :         PyErr_SetString(PyExc_IndexError,
; 841  :                          "array assignment index out of range");

  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@DDILIBCI@array?5assignment?5index?5out?5of?5ra@
  00041	e8 00 00 00 00	 call	 PyErr_SetString

; 842  :         return -1;

  00046	83 c8 ff	 or	 eax, -1

; 847  : }

  00049	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004d	c3		 ret	 0
array_ass_item ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT setarrayitem
_TEXT	SEGMENT
a$ = 8
i$ = 16
v$ = 24
setarrayitem PROC					; COMDAT

; 852  :     assert(array_Check(a));
; 853  :     return array_ass_item((arrayobject *)a, i, v);
; 854  : }

  00000	e9 00 00 00 00	 jmp	 array_ass_item
setarrayitem ENDP
_TEXT	ENDS
EXTRN	PyIter_Next:PROC
EXTRN	PyObject_GetIter:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$array_iter_extend DD imagerel array_iter_extend
	DD	imagerel array_iter_extend+46
	DD	imagerel $unwind$array_iter_extend
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$array_iter_extend DD imagerel array_iter_extend+46
	DD	imagerel array_iter_extend+258
	DD	imagerel $chain$0$array_iter_extend
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$array_iter_extend DD imagerel array_iter_extend+258
	DD	imagerel array_iter_extend+293
	DD	imagerel $chain$2$array_iter_extend
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$array_iter_extend DD 020021H
	DD	083400H
	DD	imagerel array_iter_extend
	DD	imagerel array_iter_extend+46
	DD	imagerel $unwind$array_iter_extend
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$array_iter_extend DD 020521H
	DD	083405H
	DD	imagerel array_iter_extend
	DD	imagerel array_iter_extend+46
	DD	imagerel $unwind$array_iter_extend
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_iter_extend DD 040a01H
	DD	09640aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
xdata	ENDS
;	COMDAT array_iter_extend
_TEXT	SEGMENT
self$ = 64
bb$ = 72
array_iter_extend PROC					; COMDAT

; 858  : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f1	 mov	 rsi, rcx

; 859  :     PyObject *it, *v;
; 860  : 
; 861  :     it = PyObject_GetIter(bb);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 PyObject_GetIter
  00015	48 8b f8	 mov	 rdi, rax

; 862  :     if (it == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0e		 jne	 SHORT $LN19@array_iter

; 863  :         return -1;

  0001d	83 c8 ff	 or	 eax, -1

; 875  :         return -1;
; 876  :     return 0;
; 877  : }

  00020	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00025	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN19@array_iter:

; 864  : 
; 865  :     while ((v = PyIter_Next(it)) != NULL) {

  0002b	48 8b c8	 mov	 rcx, rax
  0002e	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00033	e8 00 00 00 00	 call	 PyIter_Next
  00038	48 8b d8	 mov	 rbx, rax
  0003b	48 85 c0	 test	 rax, rax
  0003e	0f 84 9c 00 00
	00		 je	 $LN3@array_iter
  00044	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@array_iter:

; 866  :         if (ins1(self, Py_SIZE(self), v) != 0) {

  00050	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]
  00054	4c 8b c3	 mov	 r8, rbx
  00057	48 8b ce	 mov	 rcx, rsi
  0005a	e8 00 00 00 00	 call	 ins1
  0005f	85 c0		 test	 eax, eax
  00061	0f 85 9b 00 00
	00		 jne	 $LN20@array_iter

; 869  :             return -1;
; 870  :         }
; 871  :         Py_DECREF(v);

  00067	e8 00 00 00 00	 call	 _Py_PXCTX
  0006c	85 c0		 test	 eax, eax
  0006e	75 5c		 jne	 SHORT $LN18@array_iter
  00070	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00074	a8 20		 test	 al, 32			; 00000020H
  00076	75 4c		 jne	 SHORT $LN12@array_iter
  00078	84 c0		 test	 al, al
  0007a	78 48		 js	 SHORT $LN12@array_iter
  0007c	a8 02		 test	 al, 2
  0007e	75 4c		 jne	 SHORT $LN18@array_iter
  00080	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00084	75 46		 jne	 SHORT $LN18@array_iter
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00094	4c 8b cb	 mov	 r9, rbx
  00097	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0009d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000a5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000aa	48 8b cb	 mov	 rcx, rbx
  000ad	85 c0		 test	 eax, eax
  000af	74 07		 je	 SHORT $LN17@array_iter
  000b1	e8 00 00 00 00	 call	 _Px_Dealloc
  000b6	eb 14		 jmp	 SHORT $LN18@array_iter
$LN17@array_iter:
  000b8	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000bc	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000c2	eb 08		 jmp	 SHORT $LN18@array_iter
$LN12@array_iter:
  000c4	48 8b cb	 mov	 rcx, rbx
  000c7	e8 00 00 00 00	 call	 Px_DecRef
$LN18@array_iter:

; 864  : 
; 865  :     while ((v = PyIter_Next(it)) != NULL) {

  000cc	48 8b cf	 mov	 rcx, rdi
  000cf	e8 00 00 00 00	 call	 PyIter_Next
  000d4	48 8b d8	 mov	 rbx, rax
  000d7	48 85 c0	 test	 rax, rax
  000da	0f 85 70 ff ff
	ff		 jne	 $LL4@array_iter
$LN3@array_iter:

; 872  :     }
; 873  :     Py_DECREF(it);

  000e0	48 8b cf	 mov	 rcx, rdi
  000e3	e8 00 00 00 00	 call	 _Py_DecRef

; 874  :     if (PyErr_Occurred())

  000e8	e8 00 00 00 00	 call	 PyErr_Occurred
  000ed	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000f2	48 f7 d8	 neg	 rax
  000f5	1b c0		 sbb	 eax, eax

; 875  :         return -1;
; 876  :     return 0;
; 877  : }

  000f7	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000fc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00100	5f		 pop	 rdi
  00101	c3		 ret	 0
$LN20@array_iter:

; 867  :             Py_DECREF(v);

  00102	48 8b cb	 mov	 rcx, rbx
  00105	e8 00 00 00 00	 call	 _Py_DecRef

; 868  :             Py_DECREF(it);

  0010a	48 8b cf	 mov	 rcx, rdi
  0010d	e8 00 00 00 00	 call	 _Py_DecRef
  00112	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 875  :         return -1;
; 876  :     return 0;
; 877  : }

  00117	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0011c	83 c8 ff	 or	 eax, -1
  0011f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00123	5f		 pop	 rdi
  00124	c3		 ret	 0
array_iter_extend ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@PPGDJIHM@can?5only?5extend?5with?5array?5of?5sa@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_do_extend DD imagerel array_do_extend
	DD	imagerel array_do_extend+125
	DD	imagerel $unwind$array_do_extend
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$array_do_extend DD imagerel array_do_extend+125
	DD	imagerel array_do_extend+214
	DD	imagerel $chain$1$array_do_extend
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$array_do_extend DD imagerel array_do_extend+214
	DD	imagerel array_do_extend+261
	DD	imagerel $chain$3$array_do_extend
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$array_do_extend DD imagerel array_do_extend+261
	DD	imagerel array_do_extend+285
	DD	imagerel $chain$4$array_do_extend
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$array_do_extend DD 020021H
	DD	076400H
	DD	imagerel array_do_extend
	DD	imagerel array_do_extend+125
	DD	imagerel $unwind$array_do_extend
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$array_do_extend DD 040021H
	DD	076400H
	DD	065400H
	DD	imagerel array_do_extend
	DD	imagerel array_do_extend+125
	DD	imagerel $unwind$array_do_extend
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$array_do_extend DD 043521H
	DD	065435H
	DD	076405H
	DD	imagerel array_do_extend
	DD	imagerel array_do_extend+125
	DD	imagerel $unwind$array_do_extend
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_do_extend DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0CI@PPGDJIHM@can?5only?5extend?5with?5array?5of?5sa@
CONST	SEGMENT
??_C@_0CI@PPGDJIHM@can?5only?5extend?5with?5array?5of?5sa@ DB 'can only e'
	DB	'xtend with array of same kind', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_do_extend
_TEXT	SEGMENT
self$ = 48
bb$ = 56
array_do_extend PROC					; COMDAT

; 881  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 882  :     Py_ssize_t size, oldsize, bbsize;
; 883  : 
; 884  :     if (!array_Check(bb))

  0000d	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00011	48 8b da	 mov	 rbx, rdx
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  0001b	48 3b ca	 cmp	 rcx, rdx
  0001e	74 1e		 je	 SHORT $LN5@array_do_e
  00020	e8 00 00 00 00	 call	 PyType_IsSubtype
  00025	85 c0		 test	 eax, eax
  00027	75 15		 jne	 SHORT $LN5@array_do_e

; 885  :         return array_iter_extend(self, bb);

  00029	48 8b d3	 mov	 rdx, rbx
  0002c	48 8b cf	 mov	 rcx, rdi

; 907  : #undef b
; 908  : }

  0002f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5f		 pop	 rdi
  00039	e9 00 00 00 00	 jmp	 array_iter_extend
$LN5@array_do_e:

; 886  : #define b ((arrayobject *)bb)
; 887  :     if (self->ob_descr != b->ob_descr) {

  0003e	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  00045	48 3b 83 80 00
	00 00		 cmp	 rax, QWORD PTR [rbx+128]
  0004c	74 21		 je	 SHORT $LN4@array_do_e

; 888  :         PyErr_SetString(PyExc_TypeError,
; 889  :                      "can only extend with array of same kind");

  0004e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@PPGDJIHM@can?5only?5extend?5with?5array?5of?5sa@
  0005c	e8 00 00 00 00	 call	 PyErr_SetString

; 890  :         return -1;

  00061	83 c8 ff	 or	 eax, -1

; 907  : #undef b
; 908  : }

  00064	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00069	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
$LN4@array_do_e:

; 891  :     }
; 892  :     if ((Py_SIZE(self) > PY_SSIZE_T_MAX - Py_SIZE(b)) ||
; 893  :         ((Py_SIZE(self) + Py_SIZE(b)) > PY_SSIZE_T_MAX / self->ob_descr->itemsize)) {

  0006f	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  00073	48 ba ff ff ff
	ff ff ff ff 7f	 mov	 rdx, 9223372036854775807 ; 7fffffffffffffffH
  0007d	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00082	48 8b 77 60	 mov	 rsi, QWORD PTR [rdi+96]
  00086	48 8b ca	 mov	 rcx, rdx
  00089	49 2b c8	 sub	 rcx, r8
  0008c	48 3b f1	 cmp	 rsi, rcx
  0008f	7f 74		 jg	 SHORT $LN2@array_do_e
  00091	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00095	48 8b c2	 mov	 rax, rdx
  00098	48 99		 cdq
  0009a	48 f7 f9	 idiv	 rcx
  0009d	4a 8d 0c 06	 lea	 rcx, QWORD PTR [rsi+r8]
  000a1	48 3b c8	 cmp	 rcx, rax
  000a4	7f 5f		 jg	 SHORT $LN2@array_do_e

; 895  :         return -1;
; 896  :     }
; 897  :     oldsize = Py_SIZE(self);
; 898  :     /* Get the size of bb before resizing the array since bb could be self. */
; 899  :     bbsize = Py_SIZE(bb);
; 900  :     size = oldsize + Py_SIZE(b);

  000a6	4a 8d 14 06	 lea	 rdx, QWORD PTR [rsi+r8]

; 901  :     if (array_resize(self, size) == -1)

  000aa	48 8b cf	 mov	 rcx, rdi
  000ad	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  000b2	49 8b e8	 mov	 rbp, r8
  000b5	e8 00 00 00 00	 call	 array_resize
  000ba	83 f8 ff	 cmp	 eax, -1
  000bd	75 17		 jne	 SHORT $LN1@array_do_e

; 902  :         return -1;

  000bf	0b c0		 or	 eax, eax
$LN9@array_do_e:
  000c1	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  000c6	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 907  : #undef b
; 908  : }

  000cb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d4	5f		 pop	 rdi
  000d5	c3		 ret	 0
$LN1@array_do_e:

; 903  :     memcpy(self->ob_item + oldsize * self->ob_descr->itemsize,
; 904  :         b->ob_item, bbsize * b->ob_descr->itemsize);

  000d6	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]
  000dd	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
  000e1	4c 63 40 04	 movsxd	 r8, DWORD PTR [rax+4]
  000e5	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  000ec	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000f0	4c 0f af c5	 imul	 r8, rbp
  000f4	48 0f af ce	 imul	 rcx, rsi
  000f8	48 03 4f 70	 add	 rcx, QWORD PTR [rdi+112]
  000fc	e8 00 00 00 00	 call	 memcpy

; 905  : 
; 906  :     return 0;

  00101	33 c0		 xor	 eax, eax
  00103	eb bc		 jmp	 SHORT $LN9@array_do_e
$LN2@array_do_e:

; 894  :         PyErr_NoMemory();

  00105	e8 00 00 00 00	 call	 PyErr_NoMemory
  0010a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 907  : #undef b
; 908  : }

  0010f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00114	83 c8 ff	 or	 eax, -1
  00117	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011b	5f		 pop	 rdi
  0011c	c3		 ret	 0
array_do_extend ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@CFHNCMNJ@can?5only?5extend?5array?5with?5array@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$array_inplace_concat DD imagerel array_inplace_concat
	DD	imagerel array_inplace_concat+170
	DD	imagerel $unwind$array_inplace_concat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_inplace_concat DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0DA@CFHNCMNJ@can?5only?5extend?5array?5with?5array@
CONST	SEGMENT
??_C@_0DA@CFHNCMNJ@can?5only?5extend?5array?5with?5array@ DB 'can only ex'
	DB	'tend array with array (not "%.200s")', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
CONST	ENDS
;	COMDAT array_inplace_concat
_TEXT	SEGMENT
self$ = 64
bb$ = 72
array_inplace_concat PROC				; COMDAT

; 912  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b d9	 mov	 rbx, rcx

; 913  :     if (!array_Check(bb)) {

  0000d	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00011	48 8b fa	 mov	 rdi, rdx
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  0001b	48 3b ca	 cmp	 rcx, rdx
  0001e	74 31		 je	 SHORT $LN2@array_inpl
  00020	e8 00 00 00 00	 call	 PyType_IsSubtype
  00025	85 c0		 test	 eax, eax
  00027	75 28		 jne	 SHORT $LN2@array_inpl

; 914  :         PyErr_Format(PyExc_TypeError,
; 915  :             "can only extend array with array (not \"%.200s\")",
; 916  :             Py_TYPE(bb)->tp_name);

  00029	4c 8b 47 58	 mov	 r8, QWORD PTR [rdi+88]
  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@CFHNCMNJ@can?5only?5extend?5array?5with?5array@
  0003b	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0003f	e8 00 00 00 00	 call	 PyErr_Format
$LN9@array_inpl:

; 917  :         return NULL;

  00044	33 c0		 xor	 eax, eax

; 923  : }

  00046	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0004b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
$LN2@array_inpl:

; 918  :     }
; 919  :     if (array_do_extend(self, bb) == -1)

  00051	48 8b d7	 mov	 rdx, rdi
  00054	48 8b cb	 mov	 rcx, rbx
  00057	e8 00 00 00 00	 call	 array_do_extend
  0005c	83 f8 ff	 cmp	 eax, -1

; 920  :         return NULL;

  0005f	74 e3		 je	 SHORT $LN9@array_inpl

; 921  :     Py_INCREF(self);

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	75 32		 jne	 SHORT $LN6@array_inpl
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00078	4c 8b cb	 mov	 r9, rbx
  0007b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00081	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00089	e8 00 00 00 00	 call	 _PyParallel_Guard
  0008e	85 c0		 test	 eax, eax
  00090	75 06		 jne	 SHORT $LN5@array_inpl
  00092	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00096	74 04		 je	 SHORT $LN6@array_inpl
$LN5@array_inpl:
  00098	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@array_inpl:

; 922  :     return (PyObject *)self;

  0009c	48 8b c3	 mov	 rax, rbx

; 923  : }

  0009f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a8	5f		 pop	 rdi
  000a9	c3		 ret	 0
array_inplace_concat ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$array_inplace_repeat DD imagerel array_inplace_repeat
	DD	imagerel array_inplace_repeat+162
	DD	imagerel $unwind$array_inplace_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$array_inplace_repeat DD imagerel array_inplace_repeat+162
	DD	imagerel array_inplace_repeat+224
	DD	imagerel $chain$1$array_inplace_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$array_inplace_repeat DD imagerel array_inplace_repeat+224
	DD	imagerel array_inplace_repeat+302
	DD	imagerel $chain$2$array_inplace_repeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$array_inplace_repeat DD 021H
	DD	imagerel array_inplace_repeat
	DD	imagerel array_inplace_repeat+162
	DD	imagerel $unwind$array_inplace_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$array_inplace_repeat DD 040e21H
	DD	09c40eH
	DD	087405H
	DD	imagerel array_inplace_repeat
	DD	imagerel array_inplace_repeat+162
	DD	imagerel $unwind$array_inplace_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_inplace_repeat DD 060f01H
	DD	0b540fH
	DD	0a340fH
	DD	0600b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
xdata	ENDS
;	COMDAT array_inplace_repeat
_TEXT	SEGMENT
self$ = 64
n$ = 72
array_inplace_repeat PROC				; COMDAT

; 927  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 928  :     char *items, *p;
; 929  :     Py_ssize_t size, i;
; 930  : 
; 931  :     if (Py_SIZE(self) > 0) {

  0000f	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  00013	48 8b ea	 mov	 rbp, rdx
  00016	48 8b d9	 mov	 rbx, rcx
  00019	4d 85 c0	 test	 r8, r8
  0001c	0f 8e be 00 00
	00		 jle	 $LN1@array_inpl@2

; 932  :         if (n < 0)

  00022	33 c0		 xor	 eax, eax
  00024	48 85 d2	 test	 rdx, rdx

; 933  :             n = 0;
; 934  :         if ((self->ob_descr->itemsize != 0) &&
; 935  :             (Py_SIZE(self) > PY_SSIZE_T_MAX / self->ob_descr->itemsize)) {

  00027	49 ba ff ff ff
	ff ff ff ff 7f	 mov	 r10, 9223372036854775807 ; 7fffffffffffffffH
  00031	48 0f 48 e8	 cmovs	 rbp, rax
  00035	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  0003c	4c 63 48 04	 movsxd	 r9, DWORD PTR [rax+4]
  00040	45 85 c9	 test	 r9d, r9d
  00043	74 21		 je	 SHORT $LN6@array_inpl@2
  00045	49 8b c2	 mov	 rax, r10
  00048	48 99		 cdq
  0004a	49 f7 f9	 idiv	 r9
  0004d	4c 3b c0	 cmp	 r8, rax
  00050	7e 14		 jle	 SHORT $LN6@array_inpl@2
$LN19@array_inpl@2:

; 951  :     return (PyObject *)self;
; 952  : }

  00052	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00057	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  0005c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00060	5e		 pop	 rsi
  00061	e9 00 00 00 00	 jmp	 PyErr_NoMemory
$LN6@array_inpl@2:

; 936  :             return PyErr_NoMemory();
; 937  :         }
; 938  :         size = Py_SIZE(self) * self->ob_descr->itemsize;

  00066	49 8b f1	 mov	 rsi, r9
  00069	49 0f af f0	 imul	 rsi, r8

; 939  :         if (n > 0 && size > PY_SSIZE_T_MAX / n) {

  0006d	48 85 ed	 test	 rbp, rbp
  00070	7e 0d		 jle	 SHORT $LN5@array_inpl@2
  00072	49 8b c2	 mov	 rax, r10
  00075	48 99		 cdq
  00077	48 f7 fd	 idiv	 rbp
  0007a	48 3b f0	 cmp	 rsi, rax

; 940  :             return PyErr_NoMemory();

  0007d	7f d3		 jg	 SHORT $LN19@array_inpl@2
$LN5@array_inpl@2:

; 941  :         }
; 942  :         if (array_resize(self, n * Py_SIZE(self)) == -1)

  0007f	4c 0f af c5	 imul	 r8, rbp
  00083	49 8b d0	 mov	 rdx, r8
  00086	e8 00 00 00 00	 call	 array_resize
  0008b	83 f8 ff	 cmp	 eax, -1
  0008e	75 12		 jne	 SHORT $LN4@array_inpl@2

; 943  :             return NULL;

  00090	33 c0		 xor	 eax, eax

; 951  :     return (PyObject *)self;
; 952  : }

  00092	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00097	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  0009c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a0	5e		 pop	 rsi
  000a1	c3		 ret	 0
$LN4@array_inpl@2:
  000a2	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 944  :         items = p = self->ob_item;

  000a7	48 8b 7b 70	 mov	 rdi, QWORD PTR [rbx+112]
  000ab	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  000b0	4c 8b e7	 mov	 r12, rdi

; 945  :         for (i = 1; i < n; i++) {

  000b3	48 83 fd 01	 cmp	 rbp, 1
  000b7	7e 1d		 jle	 SHORT $LN18@array_inpl@2

; 944  :         items = p = self->ob_item;

  000b9	48 ff cd	 dec	 rbp
  000bc	0f 1f 40 00	 npad	 4
$LL3@array_inpl@2:

; 946  :             p += size;

  000c0	48 03 fe	 add	 rdi, rsi

; 947  :             memcpy(p, items, size);

  000c3	4c 8b c6	 mov	 r8, rsi
  000c6	49 8b d4	 mov	 rdx, r12
  000c9	48 8b cf	 mov	 rcx, rdi
  000cc	e8 00 00 00 00	 call	 memcpy
  000d1	48 ff cd	 dec	 rbp
  000d4	75 ea		 jne	 SHORT $LL3@array_inpl@2
$LN18@array_inpl@2:
  000d6	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000db	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
$LN1@array_inpl@2:

; 948  :         }
; 949  :     }
; 950  :     Py_INCREF(self);

  000e0	e8 00 00 00 00	 call	 _Py_PXCTX
  000e5	85 c0		 test	 eax, eax
  000e7	75 32		 jne	 SHORT $LN12@array_inpl@2
  000e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000f7	4c 8b cb	 mov	 r9, rbx
  000fa	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00100	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00108	e8 00 00 00 00	 call	 _PyParallel_Guard
  0010d	85 c0		 test	 eax, eax
  0010f	75 06		 jne	 SHORT $LN11@array_inpl@2
  00111	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00115	74 04		 je	 SHORT $LN12@array_inpl@2
$LN11@array_inpl@2:
  00117	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN12@array_inpl@2:

; 951  :     return (PyObject *)self;
; 952  : }

  0011b	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00120	48 8b c3	 mov	 rax, rbx
  00123	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00128	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0012c	5e		 pop	 rsi
  0012d	c3		 ret	 0
array_inplace_repeat ENDP
_TEXT	ENDS
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ins DD	imagerel ins
	DD	imagerel ins+101
	DD	imagerel $unwind$ins
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ins DD	010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
xdata	ENDS
;	COMDAT ins
_TEXT	SEGMENT
self$ = 64
where$ = 72
v$ = 80
ins	PROC						; COMDAT

; 957  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 958  :     if (ins1(self, where, v) != 0)

  00004	e8 00 00 00 00	 call	 ins1
  00009	85 c0		 test	 eax, eax
  0000b	74 07		 je	 SHORT $LN1@ins

; 959  :         return NULL;

  0000d	33 c0		 xor	 eax, eax

; 962  : }

  0000f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00013	c3		 ret	 0
$LN1@ins:

; 960  :     Py_INCREF(Py_None);

  00014	e8 00 00 00 00	 call	 _Py_PXCTX
  00019	85 c0		 test	 eax, eax
  0001b	75 3c		 jne	 SHORT $LN5@ins
  0001d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00032	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00038	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00040	e8 00 00 00 00	 call	 _PyParallel_Guard
  00045	85 c0		 test	 eax, eax
  00047	75 09		 jne	 SHORT $LN4@ins
  00049	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00050	74 07		 je	 SHORT $LN5@ins
$LN4@ins:
  00052	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@ins:

; 961  :     return Py_None;

  00059	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 962  : }

  00060	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00064	c3		 ret	 0
ins	ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$array_count DD imagerel array_count
	DD	imagerel array_count+246
	DD	imagerel $unwind$array_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_count DD 0a1801H
	DD	0c6418H
	DD	0b5418H
	DD	0a3418H
	DD	0d0145218H
	DD	07010c012H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
xdata	ENDS
;	COMDAT array_count
_TEXT	SEGMENT
self$ = 80
v$ = 88
array_count PROC					; COMDAT

; 966  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 967  :     Py_ssize_t count = 0;

  00018	33 f6		 xor	 esi, esi
  0001a	4c 8b ea	 mov	 r13, rdx
  0001d	4c 8b e1	 mov	 r12, rcx

; 968  :     Py_ssize_t i;
; 969  : 
; 970  :     for (i = 0; i < Py_SIZE(self); i++) {

  00020	8b fe		 mov	 edi, esi
  00022	48 39 71 60	 cmp	 QWORD PTR [rcx+96], rsi
  00026	0f 8e a5 00 00
	00		 jle	 $LN4@array_coun
  0002c	0f 1f 40 00	 npad	 4
$LL6@array_coun:

; 971  :         PyObject *selfi = getarrayitem((PyObject *)self, i);

  00030	48 8b d7	 mov	 rdx, rdi
  00033	49 8b cc	 mov	 rcx, r12
  00036	e8 00 00 00 00	 call	 getarrayitem

; 972  :         int cmp = PyObject_RichCompareBool(selfi, v, Py_EQ);

  0003b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00041	49 8b d5	 mov	 rdx, r13
  00044	48 8b c8	 mov	 rcx, rax
  00047	48 8b d8	 mov	 rbx, rax
  0004a	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0004f	8b e8		 mov	 ebp, eax

; 973  :         Py_DECREF(selfi);

  00051	e8 00 00 00 00	 call	 _Py_PXCTX
  00056	85 c0		 test	 eax, eax
  00058	75 5e		 jne	 SHORT $LN19@array_coun
  0005a	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  0005e	f6 c1 20	 test	 cl, 32			; 00000020H
  00061	75 4d		 jne	 SHORT $LN13@array_coun
  00063	84 c9		 test	 cl, cl
  00065	78 49		 js	 SHORT $LN13@array_coun
  00067	f6 c1 02	 test	 cl, 2
  0006a	75 4c		 jne	 SHORT $LN19@array_coun
  0006c	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00070	75 46		 jne	 SHORT $LN19@array_coun
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00080	4c 8b cb	 mov	 r9, rbx
  00083	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00089	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00091	e8 00 00 00 00	 call	 _PyParallel_Guard
  00096	48 8b cb	 mov	 rcx, rbx
  00099	85 c0		 test	 eax, eax
  0009b	74 07		 je	 SHORT $LN18@array_coun
  0009d	e8 00 00 00 00	 call	 _Px_Dealloc
  000a2	eb 14		 jmp	 SHORT $LN19@array_coun
$LN18@array_coun:
  000a4	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000a8	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000ae	eb 08		 jmp	 SHORT $LN19@array_coun
$LN13@array_coun:
  000b0	48 8b cb	 mov	 rcx, rbx
  000b3	e8 00 00 00 00	 call	 Px_DecRef
$LN19@array_coun:

; 974  :         if (cmp > 0)

  000b8	85 ed		 test	 ebp, ebp
  000ba	7e 05		 jle	 SHORT $LN23@array_coun

; 975  :             count++;

  000bc	48 ff c6	 inc	 rsi
  000bf	eb 02		 jmp	 SHORT $LN5@array_coun
$LN23@array_coun:

; 976  :         else if (cmp < 0)

  000c1	78 2f		 js	 SHORT $LN21@array_coun
$LN5@array_coun:

; 968  :     Py_ssize_t i;
; 969  : 
; 970  :     for (i = 0; i < Py_SIZE(self); i++) {

  000c3	48 ff c7	 inc	 rdi
  000c6	49 3b 7c 24 60	 cmp	 rdi, QWORD PTR [r12+96]
  000cb	0f 8c 5f ff ff
	ff		 jl	 $LL6@array_coun
$LN4@array_coun:

; 978  :     }
; 979  :     return PyLong_FromSsize_t(count);

  000d1	48 8b ce	 mov	 rcx, rsi
  000d4	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN7@array_coun:

; 980  : }

  000d9	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000de	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000e3	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000e8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ec	41 5d		 pop	 r13
  000ee	41 5c		 pop	 r12
  000f0	5f		 pop	 rdi
  000f1	c3		 ret	 0
$LN21@array_coun:

; 977  :             return NULL;

  000f2	33 c0		 xor	 eax, eax
  000f4	eb e3		 jmp	 SHORT $LN7@array_coun
array_count ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@LMBGGMKK@array?4index?$CIx?$CJ?3?5x?5not?5in?5list?$AA@ ; `string'
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$array_index DD imagerel array_index
	DD	imagerel array_index+260
	DD	imagerel $unwind$array_index
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_index DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
xdata	ENDS
;	COMDAT ??_C@_0BO@LMBGGMKK@array?4index?$CIx?$CJ?3?5x?5not?5in?5list?$AA@
CONST	SEGMENT
??_C@_0BO@LMBGGMKK@array?4index?$CIx?$CJ?3?5x?5not?5in?5list?$AA@ DB 'arr'
	DB	'ay.index(x): x not in list', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
CONST	ENDS
;	COMDAT array_index
_TEXT	SEGMENT
self$ = 64
v$ = 72
array_index PROC					; COMDAT

; 989  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 990  :     Py_ssize_t i;
; 991  : 
; 992  :     for (i = 0; i < Py_SIZE(self); i++) {

  0001a	33 ff		 xor	 edi, edi
  0001c	4c 8b e2	 mov	 r12, rdx
  0001f	48 8b e9	 mov	 rbp, rcx
  00022	48 39 79 60	 cmp	 QWORD PTR [rcx+96], rdi
  00026	0f 8e 9f 00 00
	00		 jle	 $LN4@array_inde
  0002c	0f 1f 40 00	 npad	 4
$LL6@array_inde:

; 993  :         PyObject *selfi = getarrayitem((PyObject *)self, i);

  00030	48 8b d7	 mov	 rdx, rdi
  00033	48 8b cd	 mov	 rcx, rbp
  00036	e8 00 00 00 00	 call	 getarrayitem

; 994  :         int cmp = PyObject_RichCompareBool(selfi, v, Py_EQ);

  0003b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00041	49 8b d4	 mov	 rdx, r12
  00044	48 8b c8	 mov	 rcx, rax
  00047	48 8b d8	 mov	 rbx, rax
  0004a	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0004f	8b f0		 mov	 esi, eax

; 995  :         Py_DECREF(selfi);

  00051	e8 00 00 00 00	 call	 _Py_PXCTX
  00056	85 c0		 test	 eax, eax
  00058	75 5e		 jne	 SHORT $LN19@array_inde
  0005a	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  0005e	f6 c1 20	 test	 cl, 32			; 00000020H
  00061	75 4d		 jne	 SHORT $LN13@array_inde
  00063	84 c9		 test	 cl, cl
  00065	78 49		 js	 SHORT $LN13@array_inde
  00067	f6 c1 02	 test	 cl, 2
  0006a	75 4c		 jne	 SHORT $LN19@array_inde
  0006c	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00070	75 46		 jne	 SHORT $LN19@array_inde
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00080	4c 8b cb	 mov	 r9, rbx
  00083	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00089	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00091	e8 00 00 00 00	 call	 _PyParallel_Guard
  00096	48 8b cb	 mov	 rcx, rbx
  00099	85 c0		 test	 eax, eax
  0009b	74 07		 je	 SHORT $LN18@array_inde
  0009d	e8 00 00 00 00	 call	 _Px_Dealloc
  000a2	eb 14		 jmp	 SHORT $LN19@array_inde
$LN18@array_inde:
  000a4	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000a8	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000ae	eb 08		 jmp	 SHORT $LN19@array_inde
$LN13@array_inde:
  000b0	48 8b cb	 mov	 rcx, rbx
  000b3	e8 00 00 00 00	 call	 Px_DecRef
$LN19@array_inde:

; 996  :         if (cmp > 0) {

  000b8	85 f6		 test	 esi, esi
  000ba	7f 3f		 jg	 SHORT $LN21@array_inde

; 998  :         }
; 999  :         else if (cmp < 0)

  000bc	78 20		 js	 SHORT $LN22@array_inde

; 990  :     Py_ssize_t i;
; 991  : 
; 992  :     for (i = 0; i < Py_SIZE(self); i++) {

  000be	48 ff c7	 inc	 rdi
  000c1	48 3b 7d 60	 cmp	 rdi, QWORD PTR [rbp+96]
  000c5	0f 8c 65 ff ff
	ff		 jl	 $LL6@array_inde
$LN4@array_inde:

; 1000 :             return NULL;
; 1001 :     }
; 1002 :     PyErr_SetString(PyExc_ValueError, "array.index(x): x not in list");

  000cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@LMBGGMKK@array?4index?$CIx?$CJ?3?5x?5not?5in?5list?$AA@
  000d9	e8 00 00 00 00	 call	 PyErr_SetString
$LN22@array_inde:

; 1003 :     return NULL;

  000de	33 c0		 xor	 eax, eax
$LN7@array_inde:

; 1004 : }

  000e0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e5	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000ea	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000ef	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000f4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f8	41 5c		 pop	 r12
  000fa	c3		 ret	 0
$LN21@array_inde:

; 997  :             return PyLong_FromLong((long)i);

  000fb	8b cf		 mov	 ecx, edi
  000fd	e8 00 00 00 00	 call	 PyLong_FromLong
  00102	eb dc		 jmp	 SHORT $LN7@array_inde
array_index ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$array_contains DD imagerel array_contains
	DD	imagerel array_contains+222
	DD	imagerel $unwind$array_contains
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_contains DD 0a2401H
	DD	083424H
	DD	0b7415H
	DD	0a6415H
	DD	095415H
	DD	0c0115215H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
xdata	ENDS
;	COMDAT array_contains
_TEXT	SEGMENT
self$ = 64
v$ = 72
array_contains PROC					; COMDAT

; 1013 : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1014 :     Py_ssize_t i;
; 1015 :     int cmp;
; 1016 : 
; 1017 :     for (i = 0, cmp = 0 ; cmp == 0 && i < Py_SIZE(self); i++) {

  00015	33 ff		 xor	 edi, edi
  00017	4c 8b e2	 mov	 r12, rdx
  0001a	48 8b e9	 mov	 rbp, rcx
  0001d	8b f7		 mov	 esi, edi
  0001f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
$LL3@array_cont:
  00024	48 3b 7d 60	 cmp	 rdi, QWORD PTR [rbp+96]
  00028	0f 8d 93 00 00
	00		 jge	 $LN19@array_cont

; 1018 :         PyObject *selfi = getarrayitem((PyObject *)self, i);

  0002e	48 8b d7	 mov	 rdx, rdi
  00031	48 8b cd	 mov	 rcx, rbp
  00034	e8 00 00 00 00	 call	 getarrayitem

; 1019 :         cmp = PyObject_RichCompareBool(selfi, v, Py_EQ);

  00039	41 b8 02 00 00
	00		 mov	 r8d, 2
  0003f	49 8b d4	 mov	 rdx, r12
  00042	48 8b c8	 mov	 rcx, rax
  00045	48 8b d8	 mov	 rbx, rax
  00048	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0004d	8b f0		 mov	 esi, eax

; 1020 :         Py_DECREF(selfi);

  0004f	e8 00 00 00 00	 call	 _Py_PXCTX
  00054	85 c0		 test	 eax, eax
  00056	75 5e		 jne	 SHORT $LN2@array_cont
  00058	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  0005c	f6 c1 20	 test	 cl, 32			; 00000020H
  0005f	75 4d		 jne	 SHORT $LN10@array_cont
  00061	84 c9		 test	 cl, cl
  00063	78 49		 js	 SHORT $LN10@array_cont
  00065	f6 c1 02	 test	 cl, 2
  00068	75 4c		 jne	 SHORT $LN2@array_cont
  0006a	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0006e	75 46		 jne	 SHORT $LN2@array_cont
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0007e	4c 8b cb	 mov	 r9, rbx
  00081	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00087	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0008f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00094	48 8b cb	 mov	 rcx, rbx
  00097	85 c0		 test	 eax, eax
  00099	74 07		 je	 SHORT $LN15@array_cont
  0009b	e8 00 00 00 00	 call	 _Px_Dealloc
  000a0	eb 14		 jmp	 SHORT $LN2@array_cont
$LN15@array_cont:
  000a2	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000a6	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000ac	eb 08		 jmp	 SHORT $LN2@array_cont
$LN10@array_cont:
  000ae	48 8b cb	 mov	 rcx, rbx
  000b1	e8 00 00 00 00	 call	 Px_DecRef
$LN2@array_cont:

; 1014 :     Py_ssize_t i;
; 1015 :     int cmp;
; 1016 : 
; 1017 :     for (i = 0, cmp = 0 ; cmp == 0 && i < Py_SIZE(self); i++) {

  000b6	48 ff c7	 inc	 rdi
  000b9	85 f6		 test	 esi, esi
  000bb	0f 84 63 ff ff
	ff		 je	 $LL3@array_cont
$LN19@array_cont:
  000c1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1021 :     }
; 1022 :     return cmp;
; 1023 : }

  000c6	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000cb	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000d0	8b c6		 mov	 eax, esi
  000d2	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000d7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000db	41 5c		 pop	 r12
  000dd	c3		 ret	 0
array_contains ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@MLCNIPFC@array?4remove?$CIx?$CJ?3?5x?5not?5in?5list?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$array_remove DD imagerel array_remove
	DD	imagerel array_remove+358
	DD	imagerel $unwind$array_remove
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_remove DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
xdata	ENDS
;	COMDAT ??_C@_0BP@MLCNIPFC@array?4remove?$CIx?$CJ?3?5x?5not?5in?5list?$AA@
CONST	SEGMENT
??_C@_0BP@MLCNIPFC@array?4remove?$CIx?$CJ?3?5x?5not?5in?5list?$AA@ DB 'ar'
	DB	'ray.remove(x): x not in list', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
CONST	ENDS
;	COMDAT array_remove
_TEXT	SEGMENT
self$ = 64
v$ = 72
array_remove PROC					; COMDAT

; 1027 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1028 :     int i;
; 1029 : 
; 1030 :     for (i = 0; i < Py_SIZE(self); i++) {

  0001a	33 ff		 xor	 edi, edi
  0001c	4c 8b e2	 mov	 r12, rdx
  0001f	48 8b e9	 mov	 rbp, rcx
  00022	48 39 79 60	 cmp	 QWORD PTR [rcx+96], rdi
  00026	0f 8e a1 00 00
	00		 jle	 $LN5@array_remo
  0002c	8b c7		 mov	 eax, edi
  0002e	66 90		 npad	 2
$LL7@array_remo:

; 1031 :         PyObject *selfi = getarrayitem((PyObject *)self,i);

  00030	48 8b d0	 mov	 rdx, rax
  00033	48 8b cd	 mov	 rcx, rbp
  00036	e8 00 00 00 00	 call	 getarrayitem

; 1032 :         int cmp = PyObject_RichCompareBool(selfi, v, Py_EQ);

  0003b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00041	49 8b d4	 mov	 rdx, r12
  00044	48 8b c8	 mov	 rcx, rax
  00047	48 8b d8	 mov	 rbx, rax
  0004a	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0004f	8b f0		 mov	 esi, eax

; 1033 :         Py_DECREF(selfi);

  00051	e8 00 00 00 00	 call	 _Py_PXCTX
  00056	85 c0		 test	 eax, eax
  00058	75 5e		 jne	 SHORT $LN20@array_remo
  0005a	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  0005e	f6 c1 20	 test	 cl, 32			; 00000020H
  00061	75 4d		 jne	 SHORT $LN14@array_remo
  00063	84 c9		 test	 cl, cl
  00065	78 49		 js	 SHORT $LN14@array_remo
  00067	f6 c1 02	 test	 cl, 2
  0006a	75 4c		 jne	 SHORT $LN20@array_remo
  0006c	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00070	75 46		 jne	 SHORT $LN20@array_remo
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00080	4c 8b cb	 mov	 r9, rbx
  00083	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00089	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00091	e8 00 00 00 00	 call	 _PyParallel_Guard
  00096	48 8b cb	 mov	 rcx, rbx
  00099	85 c0		 test	 eax, eax
  0009b	74 07		 je	 SHORT $LN19@array_remo
  0009d	e8 00 00 00 00	 call	 _Px_Dealloc
  000a2	eb 14		 jmp	 SHORT $LN20@array_remo
$LN19@array_remo:
  000a4	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000a8	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000ae	eb 08		 jmp	 SHORT $LN20@array_remo
$LN14@array_remo:
  000b0	48 8b cb	 mov	 rcx, rbx
  000b3	e8 00 00 00 00	 call	 Px_DecRef
$LN20@array_remo:

; 1034 :         if (cmp > 0) {

  000b8	85 f6		 test	 esi, esi
  000ba	7f 41		 jg	 SHORT $LN26@array_remo

; 1040 :         }
; 1041 :         else if (cmp < 0)

  000bc	78 22		 js	 SHORT $LN27@array_remo

; 1028 :     int i;
; 1029 : 
; 1030 :     for (i = 0; i < Py_SIZE(self); i++) {

  000be	ff c7		 inc	 edi
  000c0	48 63 c7	 movsxd	 rax, edi
  000c3	48 3b 45 60	 cmp	 rax, QWORD PTR [rbp+96]
  000c7	0f 8c 63 ff ff
	ff		 jl	 $LL7@array_remo
$LN5@array_remo:

; 1042 :             return NULL;
; 1043 :     }
; 1044 :     PyErr_SetString(PyExc_ValueError, "array.remove(x): x not in list");

  000cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@MLCNIPFC@array?4remove?$CIx?$CJ?3?5x?5not?5in?5list?$AA@
  000db	e8 00 00 00 00	 call	 PyErr_SetString
$LN27@array_remo:

; 1045 :     return NULL;

  000e0	33 c0		 xor	 eax, eax
$LN8@array_remo:

; 1046 : }

  000e2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e7	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000ec	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000f1	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000f6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fa	41 5c		 pop	 r12
  000fc	c3		 ret	 0
$LN26@array_remo:

; 1035 :             if (array_ass_slice(self, i, i+1,
; 1036 :                                (PyObject *)NULL) != 0)

  000fd	8d 47 01	 lea	 eax, DWORD PTR [rdi+1]
  00100	48 63 d7	 movsxd	 rdx, edi
  00103	45 33 c9	 xor	 r9d, r9d
  00106	4c 63 c0	 movsxd	 r8, eax
  00109	48 8b cd	 mov	 rcx, rbp
  0010c	e8 00 00 00 00	 call	 array_ass_slice
  00111	85 c0		 test	 eax, eax

; 1037 :                 return NULL;

  00113	75 cb		 jne	 SHORT $LN27@array_remo

; 1038 :             Py_INCREF(Py_None);

  00115	e8 00 00 00 00	 call	 _Py_PXCTX
  0011a	85 c0		 test	 eax, eax
  0011c	75 3c		 jne	 SHORT $LN22@array_remo
  0011e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00125	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0012c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00133	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00139	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00141	e8 00 00 00 00	 call	 _PyParallel_Guard
  00146	85 c0		 test	 eax, eax
  00148	75 09		 jne	 SHORT $LN21@array_remo
  0014a	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00151	74 07		 je	 SHORT $LN22@array_remo
$LN21@array_remo:
  00153	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN22@array_remo:

; 1039 :             return Py_None;

  0015a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00161	e9 7c ff ff ff	 jmp	 $LN8@array_remo
array_remove ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@ ; `string'
PUBLIC	??_C@_0BF@MIKMJNKA@pop?5from?5empty?5array?$AA@	; `string'
PUBLIC	??_C@_06JHLPABKE@?$HMn?3pop?$AA@		; `string'
EXTRN	_PyArg_ParseTuple_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_pop DD imagerel array_pop
	DD	imagerel array_pop+109
	DD	imagerel $unwind$array_pop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$array_pop DD imagerel array_pop+109
	DD	imagerel array_pop+167
	DD	imagerel $chain$0$array_pop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$array_pop DD imagerel array_pop+167
	DD	imagerel array_pop+181
	DD	imagerel $chain$2$array_pop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$array_pop DD imagerel array_pop+181
	DD	imagerel array_pop+208
	DD	imagerel $chain$3$array_pop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$array_pop DD 021H
	DD	imagerel array_pop
	DD	imagerel array_pop+109
	DD	imagerel $unwind$array_pop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$array_pop DD 020021H
	DD	063400H
	DD	imagerel array_pop
	DD	imagerel array_pop+109
	DD	imagerel $unwind$array_pop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$array_pop DD 020521H
	DD	063405H
	DD	imagerel array_pop
	DD	imagerel array_pop+109
	DD	imagerel $unwind$array_pop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_pop DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT ??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@ DB 'pop index out of r'
	DB	'ange', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MIKMJNKA@pop?5from?5empty?5array?$AA@
CONST	SEGMENT
??_C@_0BF@MIKMJNKA@pop?5from?5empty?5array?$AA@ DB 'pop from empty array', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JHLPABKE@?$HMn?3pop?$AA@
CONST	SEGMENT
??_C@_06JHLPABKE@?$HMn?3pop?$AA@ DB '|n:pop', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_pop
_TEXT	SEGMENT
self$ = 48
args$ = 56
i$ = 64
array_pop PROC						; COMDAT

; 1055 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b f9	 mov	 rdi, rcx

; 1056 :     Py_ssize_t i = -1;
; 1057 :     PyObject *v;
; 1058 :     if (!PyArg_ParseTuple(args, "|n:pop", &i))

  0000c	4c 8d 44 24 40	 lea	 r8, QWORD PTR i$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06JHLPABKE@?$HMn?3pop?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	48 c7 44 24 40
	ff ff ff ff	 mov	 QWORD PTR i$[rsp], -1
  00024	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00029	85 c0		 test	 eax, eax

; 1059 :         return NULL;

  0002b	74 1c		 je	 SHORT $LN11@array_pop

; 1060 :     if (Py_SIZE(self) == 0) {

  0002d	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00031	48 85 c0	 test	 rax, rax
  00034	75 1b		 jne	 SHORT $LN5@array_pop

; 1061 :         /* Special-case most common failure cause */
; 1062 :         PyErr_SetString(PyExc_IndexError, "pop from empty array");

  00036	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@MIKMJNKA@pop?5from?5empty?5array?$AA@
  00044	e8 00 00 00 00	 call	 PyErr_SetString
$LN11@array_pop:

; 1063 :         return NULL;

  00049	33 c0		 xor	 eax, eax

; 1077 : }

  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
$LN5@array_pop:

; 1064 :     }
; 1065 :     if (i < 0)

  00051	48 8b 54 24 40	 mov	 rdx, QWORD PTR i$[rsp]
  00056	48 85 d2	 test	 rdx, rdx
  00059	79 0a		 jns	 SHORT $LN9@array_pop

; 1066 :         i += Py_SIZE(self);

  0005b	48 03 d0	 add	 rdx, rax
  0005e	48 89 54 24 40	 mov	 QWORD PTR i$[rsp], rdx

; 1067 :     if (i < 0 || i >= Py_SIZE(self)) {

  00063	78 50		 js	 SHORT $LN2@array_pop
$LN9@array_pop:
  00065	48 3b d0	 cmp	 rdx, rax
  00068	7d 4b		 jge	 SHORT $LN2@array_pop

; 1070 :     }
; 1071 :     v = getarrayitem((PyObject *)self,i);

  0006a	48 8b cf	 mov	 rcx, rdi
  0006d	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00072	e8 00 00 00 00	 call	 getarrayitem

; 1072 :     if (array_ass_slice(self, i, i+1, (PyObject *)NULL) != 0) {

  00077	48 8b 54 24 40	 mov	 rdx, QWORD PTR i$[rsp]
  0007c	45 33 c9	 xor	 r9d, r9d
  0007f	4c 8d 42 01	 lea	 r8, QWORD PTR [rdx+1]
  00083	48 8b cf	 mov	 rcx, rdi
  00086	48 8b d8	 mov	 rbx, rax
  00089	e8 00 00 00 00	 call	 array_ass_slice
  0008e	85 c0		 test	 eax, eax
  00090	74 15		 je	 SHORT $LN1@array_pop

; 1073 :         Py_DECREF(v);

  00092	48 8b cb	 mov	 rcx, rbx
  00095	e8 00 00 00 00	 call	 _Py_DecRef
  0009a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1074 :         return NULL;

  0009f	33 c0		 xor	 eax, eax

; 1077 : }

  000a1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a5	5f		 pop	 rdi
  000a6	c3		 ret	 0
$LN1@array_pop:

; 1075 :     }
; 1076 :     return v;

  000a7	48 8b c3	 mov	 rax, rbx
  000aa	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1077 : }

  000af	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b3	5f		 pop	 rdi
  000b4	c3		 ret	 0
$LN2@array_pop:

; 1068 :         PyErr_SetString(PyExc_IndexError, "pop index out of range");

  000b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@
  000c3	e8 00 00 00 00	 call	 PyErr_SetString

; 1069 :         return NULL;

  000c8	33 c0		 xor	 eax, eax

; 1077 : }

  000ca	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ce	5f		 pop	 rdi
  000cf	c3		 ret	 0
array_pop ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$array_extend DD imagerel array_extend
	DD	imagerel array_extend+102
	DD	imagerel $unwind$array_extend
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_extend DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
xdata	ENDS
;	COMDAT array_extend
_TEXT	SEGMENT
self$ = 64
bb$ = 72
array_extend PROC					; COMDAT

; 1086 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1087 :     if (array_do_extend(self, bb) == -1)

  00004	e8 00 00 00 00	 call	 array_do_extend
  00009	83 f8 ff	 cmp	 eax, -1
  0000c	75 07		 jne	 SHORT $LN1@array_exte

; 1088 :         return NULL;

  0000e	33 c0		 xor	 eax, eax

; 1091 : }

  00010	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00014	c3		 ret	 0
$LN1@array_exte:

; 1089 :     Py_INCREF(Py_None);

  00015	e8 00 00 00 00	 call	 _Py_PXCTX
  0001a	85 c0		 test	 eax, eax
  0001c	75 3c		 jne	 SHORT $LN5@array_exte
  0001e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00039	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00041	e8 00 00 00 00	 call	 _PyParallel_Guard
  00046	85 c0		 test	 eax, eax
  00048	75 09		 jne	 SHORT $LN4@array_exte
  0004a	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00051	74 07		 je	 SHORT $LN5@array_exte
$LN4@array_exte:
  00053	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@array_exte:

; 1090 :     return Py_None;

  0005a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1091 : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
array_extend ENDP
_TEXT	ENDS
PUBLIC	??_C@_09EEABNKNH@nO?3insert?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_insert DD imagerel array_insert
	DD	imagerel array_insert+73
	DD	imagerel $unwind$array_insert
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_insert DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_09EEABNKNH@nO?3insert?$AA@
CONST	SEGMENT
??_C@_09EEABNKNH@nO?3insert?$AA@ DB 'nO:insert', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_insert
_TEXT	SEGMENT
self$ = 48
args$ = 56
v$ = 64
i$ = 72
array_insert PROC					; COMDAT

; 1100 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 1101 :     Py_ssize_t i;
; 1102 :     PyObject *v;
; 1103 :     if (!PyArg_ParseTuple(args, "nO:insert", &i, &v))

  0000c	4c 8d 4c 24 40	 lea	 r9, QWORD PTR v$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09EEABNKNH@nO?3insert?$AA@
  00018	4c 8d 44 24 48	 lea	 r8, QWORD PTR i$[rsp]
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00025	85 c0		 test	 eax, eax
  00027	75 08		 jne	 SHORT $LN1@array_inse

; 1104 :         return NULL;

  00029	33 c0		 xor	 eax, eax

; 1106 : }

  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx
  00030	c3		 ret	 0
$LN1@array_inse:

; 1105 :     return ins(self, i, v);

  00031	4c 8b 44 24 40	 mov	 r8, QWORD PTR v$[rsp]
  00036	48 8b 54 24 48	 mov	 rdx, QWORD PTR i$[rsp]
  0003b	48 8b cb	 mov	 rcx, rbx
  0003e	e8 00 00 00 00	 call	 ins

; 1106 : }

  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5b		 pop	 rbx
  00048	c3		 ret	 0
array_insert ENDP
_TEXT	ENDS
EXTRN	PyLong_FromVoidPtr:PROC
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_buffer_info DD imagerel array_buffer_info
	DD	imagerel array_buffer_info+81
	DD	imagerel $unwind$array_buffer_info
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_buffer_info DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT array_buffer_info
_TEXT	SEGMENT
self$ = 48
unused$ = 56
array_buffer_info PROC					; COMDAT

; 1116 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 1117 :     PyObject* retval = NULL;
; 1118 :     retval = PyTuple_New(2);

  0000d	b9 02 00 00 00	 mov	 ecx, 2
  00012	e8 00 00 00 00	 call	 PyTuple_New
  00017	48 8b d8	 mov	 rbx, rax

; 1119 :     if (!retval)

  0001a	48 85 c0	 test	 rax, rax
  0001d	75 0b		 jne	 SHORT $LN1@array_buff

; 1126 : }

  0001f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5f		 pop	 rdi
  00029	c3		 ret	 0
$LN1@array_buff:

; 1120 :         return NULL;
; 1121 : 
; 1122 :     PyTuple_SET_ITEM(retval, 0, PyLong_FromVoidPtr(self->ob_item));

  0002a	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  0002e	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
  00033	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 1123 :     PyTuple_SET_ITEM(retval, 1, PyLong_FromLong((long)(Py_SIZE(self))));

  00037	8b 4f 60	 mov	 ecx, DWORD PTR [rdi+96]
  0003a	e8 00 00 00 00	 call	 PyLong_FromLong
  0003f	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 1124 : 
; 1125 :     return retval;

  00043	48 8b c3	 mov	 rax, rbx

; 1126 : }

  00046	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
array_buffer_info ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT array_append
_TEXT	SEGMENT
self$ = 8
v$ = 16
array_append PROC					; COMDAT

; 1140 :     return ins(self, Py_SIZE(self), v);

  00000	4c 8b c2	 mov	 r8, rdx
  00003	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]

; 1141 : }

  00007	e9 00 00 00 00	 jmp	 ins
array_append ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@PDOKFCDD@don?8t?5know?5how?5to?5byteswap?5this?5@ ; `string'
EXTRN	PyExc_RuntimeError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$array_byteswap DD imagerel array_byteswap
	DD	imagerel array_byteswap+359
	DD	imagerel $unwind$array_byteswap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_byteswap DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0CL@PDOKFCDD@don?8t?5know?5how?5to?5byteswap?5this?5@
CONST	SEGMENT
??_C@_0CL@PDOKFCDD@don?8t?5know?5how?5to?5byteswap?5this?5@ DB 'don''t kn'
	DB	'ow how to byteswap this array type', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
CONST	ENDS
;	COMDAT array_byteswap
_TEXT	SEGMENT
self$ = 64
unused$ = 72
array_byteswap PROC					; COMDAT

; 1151 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1152 :     char *p;
; 1153 :     Py_ssize_t i;
; 1154 : 
; 1155 :     switch (self->ob_descr->itemsize) {

  00004	48 8b 91 80 00
	00 00		 mov	 rdx, QWORD PTR [rcx+128]
  0000b	44 8b 42 04	 mov	 r8d, DWORD PTR [rdx+4]
  0000f	41 ff c8	 dec	 r8d
  00012	0f 84 fe 00 00
	00		 je	 $LN10@array_byte
  00018	41 ff c8	 dec	 r8d
  0001b	0f 84 cc 00 00
	00		 je	 $LN13@array_byte
  00021	41 83 e8 02	 sub	 r8d, 2
  00025	0f 84 86 00 00
	00		 je	 $LN9@array_byte
  0002b	41 83 f8 04	 cmp	 r8d, 4
  0002f	74 1a		 je	 SHORT $LN5@array_byte

; 1191 :     default:
; 1192 :         PyErr_SetString(PyExc_RuntimeError,
; 1193 :                    "don't know how to byteswap this array type");

  00031	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@PDOKFCDD@don?8t?5know?5how?5to?5byteswap?5this?5@
  0003f	e8 00 00 00 00	 call	 PyErr_SetString

; 1194 :         return NULL;

  00044	33 c0		 xor	 eax, eax

; 1198 : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
$LN5@array_byte:

; 1175 :     case 8:
; 1176 :         for (p = self->ob_item, i = Py_SIZE(self); --i >= 0; p += 8) {

  0004b	4c 8b 59 60	 mov	 r11, QWORD PTR [rcx+96]
  0004f	4c 8b 51 70	 mov	 r10, QWORD PTR [rcx+112]
  00053	49 ff cb	 dec	 r11
  00056	0f 88 ba 00 00
	00		 js	 $LN10@array_byte
  0005c	0f 1f 40 00	 npad	 4
$LL4@array_byte:

; 1177 :             char p0 = p[0];
; 1178 :             char p1 = p[1];
; 1179 :             char p2 = p[2];
; 1180 :             char p3 = p[3];
; 1181 :             p[0] = p[7];

  00060	41 0f b6 42 07	 movzx	 eax, BYTE PTR [r10+7]
  00065	45 0f b6 0a	 movzx	 r9d, BYTE PTR [r10]
  00069	45 0f b6 42 01	 movzx	 r8d, BYTE PTR [r10+1]
  0006e	41 0f b6 52 02	 movzx	 edx, BYTE PTR [r10+2]
  00073	41 0f b6 4a 03	 movzx	 ecx, BYTE PTR [r10+3]
  00078	41 88 02	 mov	 BYTE PTR [r10], al

; 1182 :             p[1] = p[6];

  0007b	41 0f b6 42 06	 movzx	 eax, BYTE PTR [r10+6]

; 1183 :             p[2] = p[5];
; 1184 :             p[3] = p[4];
; 1185 :             p[4] = p3;
; 1186 :             p[5] = p2;
; 1187 :             p[6] = p1;
; 1188 :             p[7] = p0;

  00080	45 88 4a 07	 mov	 BYTE PTR [r10+7], r9b
  00084	45 88 42 06	 mov	 BYTE PTR [r10+6], r8b
  00088	41 88 42 01	 mov	 BYTE PTR [r10+1], al
  0008c	41 0f b6 42 05	 movzx	 eax, BYTE PTR [r10+5]
  00091	41 88 52 05	 mov	 BYTE PTR [r10+5], dl
  00095	41 88 42 02	 mov	 BYTE PTR [r10+2], al
  00099	41 0f b6 42 04	 movzx	 eax, BYTE PTR [r10+4]
  0009e	41 88 4a 04	 mov	 BYTE PTR [r10+4], cl
  000a2	41 88 42 03	 mov	 BYTE PTR [r10+3], al
  000a6	49 83 c2 08	 add	 r10, 8
  000aa	49 ff cb	 dec	 r11
  000ad	79 b1		 jns	 SHORT $LL4@array_byte

; 1189 :         }
; 1190 :         break;

  000af	eb 65		 jmp	 SHORT $LN10@array_byte
$LN9@array_byte:

; 1163 :         }
; 1164 :         break;
; 1165 :     case 4:
; 1166 :         for (p = self->ob_item, i = Py_SIZE(self); --i >= 0; p += 4) {

  000b1	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  000b5	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  000b9	49 ff c9	 dec	 r9
  000bc	78 58		 js	 SHORT $LN10@array_byte
  000be	66 90		 npad	 2
$LL8@array_byte:

; 1167 :             char p0 = p[0];
; 1168 :             char p1 = p[1];
; 1169 :             p[0] = p[3];

  000c0	41 0f b6 40 03	 movzx	 eax, BYTE PTR [r8+3]
  000c5	41 0f b6 10	 movzx	 edx, BYTE PTR [r8]
  000c9	41 0f b6 48 01	 movzx	 ecx, BYTE PTR [r8+1]
  000ce	41 88 00	 mov	 BYTE PTR [r8], al

; 1170 :             p[1] = p[2];

  000d1	41 0f b6 40 02	 movzx	 eax, BYTE PTR [r8+2]

; 1171 :             p[2] = p1;
; 1172 :             p[3] = p0;

  000d6	41 88 50 03	 mov	 BYTE PTR [r8+3], dl
  000da	41 88 48 02	 mov	 BYTE PTR [r8+2], cl
  000de	41 88 40 01	 mov	 BYTE PTR [r8+1], al
  000e2	49 83 c0 04	 add	 r8, 4
  000e6	49 ff c9	 dec	 r9
  000e9	79 d5		 jns	 SHORT $LL8@array_byte

; 1173 :         }
; 1174 :         break;

  000eb	eb 29		 jmp	 SHORT $LN10@array_byte
$LN13@array_byte:

; 1156 :     case 1:
; 1157 :         break;
; 1158 :     case 2:
; 1159 :         for (p = self->ob_item, i = Py_SIZE(self); --i >= 0; p += 2) {

  000ed	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  000f1	48 8b 51 70	 mov	 rdx, QWORD PTR [rcx+112]
  000f5	49 ff c8	 dec	 r8
  000f8	78 1c		 js	 SHORT $LN10@array_byte
  000fa	66 0f 1f 44 00
	00		 npad	 6
$LL12@array_byte:

; 1160 :             char p0 = p[0];

  00100	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]

; 1161 :             p[0] = p[1];

  00103	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  00107	48 83 c2 02	 add	 rdx, 2
  0010b	49 ff c8	 dec	 r8
  0010e	88 42 fe	 mov	 BYTE PTR [rdx-2], al

; 1162 :             p[1] = p0;

  00111	88 4a ff	 mov	 BYTE PTR [rdx-1], cl
  00114	79 ea		 jns	 SHORT $LL12@array_byte
$LN10@array_byte:

; 1195 :     }
; 1196 :     Py_INCREF(Py_None);

  00116	e8 00 00 00 00	 call	 _Py_PXCTX
  0011b	85 c0		 test	 eax, eax
  0011d	75 3c		 jne	 SHORT $LN20@array_byte
  0011f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00126	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00134	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0013a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00142	e8 00 00 00 00	 call	 _PyParallel_Guard
  00147	85 c0		 test	 eax, eax
  00149	75 09		 jne	 SHORT $LN19@array_byte
  0014b	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00152	74 07		 je	 SHORT $LN20@array_byte
$LN19@array_byte:
  00154	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN20@array_byte:

; 1197 :     return Py_None;

  0015b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1198 : }

  00162	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00166	c3		 ret	 0
array_byteswap ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$array_reverse DD imagerel array_reverse
	DD	imagerel array_reverse+22
	DD	imagerel $unwind$array_reverse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$array_reverse DD imagerel array_reverse+22
	DD	imagerel array_reverse+39
	DD	imagerel $chain$0$array_reverse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$array_reverse DD imagerel array_reverse+39
	DD	imagerel array_reverse+129
	DD	imagerel $chain$1$array_reverse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$array_reverse DD imagerel array_reverse+129
	DD	imagerel array_reverse+146
	DD	imagerel $chain$2$array_reverse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$array_reverse DD imagerel array_reverse+146
	DD	imagerel array_reverse+237
	DD	imagerel $chain$3$array_reverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$array_reverse DD 021H
	DD	imagerel array_reverse
	DD	imagerel array_reverse+22
	DD	imagerel $unwind$array_reverse
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$array_reverse DD 021H
	DD	imagerel array_reverse+22
	DD	imagerel array_reverse+39
	DD	imagerel $chain$0$array_reverse
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$array_reverse DD 020421H
	DD	0297404H
	DD	imagerel array_reverse+22
	DD	imagerel array_reverse+39
	DD	imagerel $chain$0$array_reverse
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$array_reverse DD 020421H
	DD	0286404H
	DD	imagerel array_reverse
	DD	imagerel array_reverse+22
	DD	imagerel $unwind$array_reverse
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_reverse DD 030b01H
	DD	026010bH
	DD	03004H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
xdata	ENDS
;	COMDAT array_reverse
_TEXT	SEGMENT
tmp$ = 48
self$ = 320
unused$ = 328
array_reverse PROC					; COMDAT

; 1208 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 81 ec 30 01
	00 00		 sub	 rsp, 304		; 00000130H

; 1209 :     register Py_ssize_t itemsize = self->ob_descr->itemsize;

  0000b	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]

; 1210 :     register char *p, *q;
; 1211 :     /* little buffer to hold items while swapping */
; 1212 :     char tmp[256];      /* 8 is probably enough -- but why skimp */
; 1213 :     assert((size_t)itemsize <= sizeof(tmp));
; 1214 : 
; 1215 :     if (Py_SIZE(self) > 1) {

  00012	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  00016	49 89 73 08	 mov	 QWORD PTR [r11+8], rsi
  0001a	48 63 70 04	 movsxd	 rsi, DWORD PTR [rax+4]
  0001e	48 83 fb 01	 cmp	 rbx, 1
  00022	7e 5d		 jle	 SHORT $LN1@array_reve

; 1216 :         for (p = self->ob_item,
; 1217 :              q = self->ob_item + (Py_SIZE(self) - 1)*itemsize;
; 1218 :              p < q;
; 1219 :              p += itemsize, q -= itemsize) {

  00024	48 ff cb	 dec	 rbx
  00027	49 89 7b 10	 mov	 QWORD PTR [r11+16], rdi
  0002b	48 8b 79 70	 mov	 rdi, QWORD PTR [rcx+112]
  0002f	48 0f af de	 imul	 rbx, rsi
  00033	48 03 df	 add	 rbx, rdi
  00036	48 3b fb	 cmp	 rdi, rbx
  00039	73 3e		 jae	 SHORT $LN15@array_reve
  0003b	0f 1f 44 00 00	 npad	 5
$LL3@array_reve:

; 1220 :             /* memory areas guaranteed disjoint, so memcpy
; 1221 :              * is safe (& memmove may be slower).
; 1222 :              */
; 1223 :             memcpy(tmp, p, itemsize);

  00040	48 8d 4c 24 30	 lea	 rcx, QWORD PTR tmp$[rsp]
  00045	4c 8b c6	 mov	 r8, rsi
  00048	48 8b d7	 mov	 rdx, rdi
  0004b	e8 00 00 00 00	 call	 memcpy

; 1224 :             memcpy(p, q, itemsize);

  00050	4c 8b c6	 mov	 r8, rsi
  00053	48 8b d3	 mov	 rdx, rbx
  00056	48 8b cf	 mov	 rcx, rdi
  00059	e8 00 00 00 00	 call	 memcpy

; 1225 :             memcpy(q, tmp, itemsize);

  0005e	48 8d 54 24 30	 lea	 rdx, QWORD PTR tmp$[rsp]
  00063	4c 8b c6	 mov	 r8, rsi
  00066	48 8b cb	 mov	 rcx, rbx
  00069	e8 00 00 00 00	 call	 memcpy
  0006e	48 03 fe	 add	 rdi, rsi
  00071	48 2b de	 sub	 rbx, rsi
  00074	48 3b fb	 cmp	 rdi, rbx
  00077	72 c7		 jb	 SHORT $LL3@array_reve
$LN15@array_reve:
  00079	48 8b bc 24 48
	01 00 00	 mov	 rdi, QWORD PTR [rsp+328]
$LN1@array_reve:

; 1226 :         }
; 1227 :     }
; 1228 : 
; 1229 :     Py_INCREF(Py_None);

  00081	e8 00 00 00 00	 call	 _Py_PXCTX
  00086	48 8b b4 24 40
	01 00 00	 mov	 rsi, QWORD PTR [rsp+320]
  0008e	85 c0		 test	 eax, eax
  00090	75 4b		 jne	 SHORT $LN13@array_reve
  00092	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000a7	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000ad	4c 8b cb	 mov	 r9, rbx
  000b0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000bd	85 c0		 test	 eax, eax
  000bf	75 09		 jne	 SHORT $LN7@array_reve
  000c1	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000c8	74 07		 je	 SHORT $LN16@array_reve
$LN7@array_reve:
  000ca	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN16@array_reve:

; 1230 :     return Py_None;

  000d1	48 8b c3	 mov	 rax, rbx

; 1231 : }

  000d4	48 81 c4 30 01
	00 00		 add	 rsp, 304		; 00000130H
  000db	5b		 pop	 rbx
  000dc	c3		 ret	 0
$LN13@array_reve:

; 1230 :     return Py_None;

  000dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1231 : }

  000e4	48 81 c4 30 01
	00 00		 add	 rsp, 304		; 00000130H
  000eb	5b		 pop	 rbx
  000ec	c3		 ret	 0
array_reverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_01MJMHLOMK@O?$AA@				; `string'
EXTRN	_PyObject_CallMethodId_SizeT:PROC
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$array_tofile DD imagerel array_tofile
	DD	imagerel array_tofile+367
	DD	imagerel $unwind$array_tofile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_tofile DD 0c2101H
	DD	0f6421H
	DD	0e5421H
	DD	0c3421H
	DD	0f01d5221H
	DD	0d019e01bH
	DD	07015c017H
xdata	ENDS
;	COMDAT ??_C@_01MJMHLOMK@O?$AA@
CONST	SEGMENT
??_C@_01MJMHLOMK@O?$AA@ DB 'O', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
CONST	ENDS
;	COMDAT array_tofile
_TEXT	SEGMENT
self$ = 96
f$ = 104
array_tofile PROC					; COMDAT

; 1306 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00014	57		 push	 rdi
  00015	41 54		 push	 r12
  00017	41 55		 push	 r13
  00019	41 56		 push	 r14
  0001b	41 57		 push	 r15
  0001d	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1307 :     Py_ssize_t nbytes = Py_SIZE(self) * self->ob_descr->itemsize;

  00021	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  00028	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  0002c	48 8b ea	 mov	 rbp, rdx
  0002f	4c 63 68 04	 movsxd	 r13, DWORD PTR [rax+4]
  00033	4c 8b f9	 mov	 r15, rcx
  00036	4d 0f af e8	 imul	 r13, r8

; 1308 :     /* Write 64K blocks at a time */
; 1309 :     /* XXX Make the block size settable */
; 1310 :     int BLOCKSIZE = 64*1024;
; 1311 :     Py_ssize_t nblocks = (nbytes + BLOCKSIZE - 1) / BLOCKSIZE;

  0003a	49 8d 85 ff ff
	00 00		 lea	 rax, QWORD PTR [r13+65535]
  00041	48 99		 cdq
  00043	0f b7 d2	 movzx	 edx, dx
  00046	48 03 c2	 add	 rax, rdx
  00049	48 c1 f8 10	 sar	 rax, 16
  0004d	4c 8b e0	 mov	 r12, rax

; 1312 :     Py_ssize_t i;
; 1313 : 
; 1314 :     if (Py_SIZE(self) == 0)

  00050	4d 85 c0	 test	 r8, r8
  00053	0f 84 a9 00 00
	00		 je	 $done$21437

; 1315 :         goto done;
; 1316 : 
; 1317 :     for (i = 0; i < nblocks; i++) {

  00059	33 db		 xor	 ebx, ebx
  0005b	48 85 c0	 test	 rax, rax
  0005e	0f 8e 9e 00 00
	00		 jle	 $done$21437
  00064	8b fb		 mov	 edi, ebx
  00066	49 8b f5	 mov	 rsi, r13
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@array_tofi:

; 1318 :         char* ptr = self->ob_item + i*BLOCKSIZE;

  00070	49 8b 47 70	 mov	 rax, QWORD PTR [r15+112]

; 1319 :         Py_ssize_t size = BLOCKSIZE;
; 1320 :         PyObject *bytes, *res;
; 1321 :         _Py_IDENTIFIER(write);
; 1322 : 
; 1323 :         if (i*BLOCKSIZE + size > nbytes)

  00074	ba 00 00 01 00	 mov	 edx, 65536		; 00010000H
  00079	48 8d 0c 07	 lea	 rcx, QWORD PTR [rdi+rax]
  0007d	48 8d 87 00 00
	01 00		 lea	 rax, QWORD PTR [rdi+65536]
  00084	49 3b c5	 cmp	 rax, r13
  00087	48 0f 4f d6	 cmovg	 rdx, rsi

; 1324 :             size = nbytes - i*BLOCKSIZE;
; 1325 :         bytes = PyBytes_FromStringAndSize(ptr, size);

  0008b	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00090	4c 8b f0	 mov	 r14, rax

; 1326 :         if (bytes == NULL)

  00093	48 85 c0	 test	 rax, rax
  00096	0f 84 cf 00 00
	00		 je	 $LN15@array_tofi

; 1328 :         res = _PyObject_CallMethodId(f, &PyId_write, "O", bytes);

  0009c	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  000a3	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  000ac	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_write@?2??array_tofile@@9@9
  000b1	4a 03 14 c1	 add	 rdx, QWORD PTR [rcx+r8*8]
  000b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  000bc	4c 8b c8	 mov	 r9, rax
  000bf	48 8b cd	 mov	 rcx, rbp
  000c2	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT

; 1329 :         Py_DECREF(bytes);

  000c7	49 8b ce	 mov	 rcx, r14
  000ca	48 8b e8	 mov	 rbp, rax
  000cd	e8 00 00 00 00	 call	 _Py_DecRef

; 1330 :         if (res == NULL)

  000d2	48 85 ed	 test	 rbp, rbp
  000d5	0f 84 90 00 00
	00		 je	 $LN15@array_tofi

; 1331 :             return NULL;
; 1332 :         Py_DECREF(res); /* drop write result */

  000db	48 8b cd	 mov	 rcx, rbp
  000de	e8 00 00 00 00	 call	 _Py_DecRef
  000e3	48 8b 6c 24 68	 mov	 rbp, QWORD PTR f$[rsp]
  000e8	48 ff c3	 inc	 rbx
  000eb	48 81 c7 00 00
	01 00		 add	 rdi, 65536		; 00010000H
  000f2	48 81 ee 00 00
	01 00		 sub	 rsi, 65536		; 00010000H
  000f9	49 3b dc	 cmp	 rbx, r12
  000fc	0f 8c 6e ff ff
	ff		 jl	 $LL6@array_tofi
$done$21437:

; 1333 :     }
; 1334 : 
; 1335 :   done:
; 1336 :     Py_INCREF(Py_None);

  00102	e8 00 00 00 00	 call	 _Py_PXCTX
  00107	85 c0		 test	 eax, eax
  00109	75 3c		 jne	 SHORT $LN11@array_tofi
  0010b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00112	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00120	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00126	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0012e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00133	85 c0		 test	 eax, eax
  00135	75 09		 jne	 SHORT $LN10@array_tofi
  00137	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0013e	74 07		 je	 SHORT $LN11@array_tofi
$LN10@array_tofi:
  00140	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN11@array_tofi:

; 1337 :     return Py_None;

  00147	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN8@array_tofi:

; 1338 : }

  0014e	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00153	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00158	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  0015d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00161	41 5f		 pop	 r15
  00163	41 5e		 pop	 r14
  00165	41 5d		 pop	 r13
  00167	41 5c		 pop	 r12
  00169	5f		 pop	 rdi
  0016a	c3		 ret	 0
$LN15@array_tofi:

; 1327 :             return NULL;

  0016b	33 c0		 xor	 eax, eax
  0016d	eb df		 jmp	 SHORT $LN8@array_tofi
array_tofile ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@CKIPGAKP@arg?5must?5be?5list?$AA@	; `string'
EXTRN	PyList_GetItem:PROC
EXTRN	PyList_Size:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$array_fromlist DD imagerel array_fromlist
	DD	imagerel array_fromlist+64
	DD	imagerel $unwind$array_fromlist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$array_fromlist DD imagerel array_fromlist+64
	DD	imagerel array_fromlist+280
	DD	imagerel $chain$2$array_fromlist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$array_fromlist DD imagerel array_fromlist+280
	DD	imagerel array_fromlist+295
	DD	imagerel $chain$4$array_fromlist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$array_fromlist DD 060021H
	DD	0ac400H
	DD	097400H
	DD	083400H
	DD	imagerel array_fromlist
	DD	imagerel array_fromlist+64
	DD	imagerel $unwind$array_fromlist
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$array_fromlist DD 061221H
	DD	0ac412H
	DD	09740dH
	DD	083405H
	DD	imagerel array_fromlist
	DD	imagerel array_fromlist+64
	DD	imagerel $unwind$array_fromlist
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_fromlist DD 040a01H
	DD	0b540aH
	DD	06006520aH
xdata	ENDS
;	COMDAT ??_C@_0BB@CKIPGAKP@arg?5must?5be?5list?$AA@
CONST	SEGMENT
??_C@_0BB@CKIPGAKP@arg?5must?5be?5list?$AA@ DB 'arg must be list', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
CONST	ENDS
;	COMDAT array_fromlist
_TEXT	SEGMENT
self$ = 64
list$ = 72
array_fromlist PROC					; COMDAT

; 1348 : {

  00000	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1349 :     Py_ssize_t n;
; 1350 : 
; 1351 :     if (!PyList_Check(list)) {

  0000a	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0000e	48 8b ea	 mov	 rbp, rdx
  00011	48 8b f1	 mov	 rsi, rcx
  00014	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  0001e	75 20		 jne	 SHORT $LN7@array_from

; 1352 :         PyErr_SetString(PyExc_TypeError, "arg must be list");

  00020	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@CKIPGAKP@arg?5must?5be?5list?$AA@
  0002e	e8 00 00 00 00	 call	 PyErr_SetString

; 1353 :         return NULL;

  00033	33 c0		 xor	 eax, eax

; 1372 : }

  00035	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  0003a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003e	5e		 pop	 rsi
  0003f	c3		 ret	 0
$LN7@array_from:
  00040	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 1354 :     }
; 1355 :     n = PyList_Size(list);

  00045	48 8b ca	 mov	 rcx, rdx
  00048	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0004d	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  00052	e8 00 00 00 00	 call	 PyList_Size
  00057	48 8b f8	 mov	 rdi, rax

; 1356 :     if (n > 0) {

  0005a	48 85 c0	 test	 rax, rax
  0005d	7e 53		 jle	 SHORT $LN2@array_from

; 1357 :         Py_ssize_t i, old_size;
; 1358 :         old_size = Py_SIZE(self);

  0005f	4c 8b 66 60	 mov	 r12, QWORD PTR [rsi+96]

; 1359 :         if (array_resize(self, old_size + n) == -1)

  00063	48 8b ce	 mov	 rcx, rsi
  00066	49 8d 14 04	 lea	 rdx, QWORD PTR [r12+rax]
  0006a	e8 00 00 00 00	 call	 array_resize
  0006f	83 f8 ff	 cmp	 eax, -1

; 1360 :             return NULL;

  00072	0f 84 ab 00 00
	00		 je	 $LN20@array_from

; 1361 :         for (i = 0; i < n; i++) {

  00078	33 db		 xor	 ebx, ebx
  0007a	48 85 ff	 test	 rdi, rdi
  0007d	7e 33		 jle	 SHORT $LN2@array_from
  0007f	90		 npad	 1
$LL4@array_from:

; 1362 :             PyObject *v = PyList_GetItem(list, i);

  00080	48 8b d3	 mov	 rdx, rbx
  00083	48 8b cd	 mov	 rcx, rbp
  00086	e8 00 00 00 00	 call	 PyList_GetItem

; 1363 :             if ((*self->ob_descr->setitem)(self,
; 1364 :                             Py_SIZE(self) - n + i, v) != 0) {

  0008b	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]
  0008f	4c 8b 8e 80 00
	00 00		 mov	 r9, QWORD PTR [rsi+128]
  00096	48 2b d7	 sub	 rdx, rdi
  00099	4c 8b c0	 mov	 r8, rax
  0009c	48 8b ce	 mov	 rcx, rsi
  0009f	48 03 d3	 add	 rdx, rbx
  000a2	41 ff 51 10	 call	 QWORD PTR [r9+16]
  000a6	85 c0		 test	 eax, eax
  000a8	75 6e		 jne	 SHORT $LN15@array_from

; 1361 :         for (i = 0; i < n; i++) {

  000aa	48 ff c3	 inc	 rbx
  000ad	48 3b df	 cmp	 rbx, rdi
  000b0	7c ce		 jl	 SHORT $LL4@array_from
$LN2@array_from:

; 1367 :             }
; 1368 :         }
; 1369 :     }
; 1370 :     Py_INCREF(Py_None);

  000b2	e8 00 00 00 00	 call	 _Py_PXCTX
  000b7	85 c0		 test	 eax, eax
  000b9	75 3c		 jne	 SHORT $LN11@array_from
  000bb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000d0	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000d6	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000de	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e3	85 c0		 test	 eax, eax
  000e5	75 09		 jne	 SHORT $LN10@array_from
  000e7	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000ee	74 07		 je	 SHORT $LN11@array_from
$LN10@array_from:
  000f0	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN11@array_from:

; 1371 :     return Py_None;

  000f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN19@array_from:
  000fe	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00103	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00108	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]

; 1372 : }

  0010d	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00112	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00116	5e		 pop	 rsi
  00117	c3		 ret	 0
$LN15@array_from:

; 1365 :                 array_resize(self, old_size);

  00118	49 8b d4	 mov	 rdx, r12
  0011b	48 8b ce	 mov	 rcx, rsi
  0011e	e8 00 00 00 00	 call	 array_resize
$LN20@array_from:

; 1366 :                 return NULL;

  00123	33 c0		 xor	 eax, eax
  00125	eb d7		 jmp	 SHORT $LN19@array_from
array_fromlist ENDP
_TEXT	ENDS
EXTRN	PyList_SetItem:PROC
EXTRN	PyList_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$array_tolist DD imagerel array_tolist
	DD	imagerel array_tolist+41
	DD	imagerel $unwind$array_tolist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$array_tolist DD imagerel array_tolist+41
	DD	imagerel array_tolist+122
	DD	imagerel $chain$0$array_tolist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$array_tolist DD imagerel array_tolist+122
	DD	imagerel array_tolist+219
	DD	imagerel $chain$2$array_tolist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$array_tolist DD imagerel array_tolist+219
	DD	imagerel array_tolist+247
	DD	imagerel $chain$4$array_tolist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$array_tolist DD imagerel array_tolist+247
	DD	imagerel array_tolist+273
	DD	imagerel $chain$6$array_tolist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$array_tolist DD 020021H
	DD	087400H
	DD	imagerel array_tolist
	DD	imagerel array_tolist+41
	DD	imagerel $unwind$array_tolist
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$array_tolist DD 020021H
	DD	087400H
	DD	imagerel array_tolist
	DD	imagerel array_tolist+41
	DD	imagerel $unwind$array_tolist
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$array_tolist DD 020021H
	DD	087400H
	DD	imagerel array_tolist
	DD	imagerel array_tolist+41
	DD	imagerel $unwind$array_tolist
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$array_tolist DD 020521H
	DD	087405H
	DD	imagerel array_tolist
	DD	imagerel array_tolist+41
	DD	imagerel $unwind$array_tolist
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_tolist DD 040a01H
	DD	09340aH
	DD	06006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
xdata	ENDS
;	COMDAT array_tolist
_TEXT	SEGMENT
self$ = 64
unused$ = 72
array_tolist PROC					; COMDAT

; 1381 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f1	 mov	 rsi, rcx

; 1382 :     PyObject *list = PyList_New(Py_SIZE(self));

  0000d	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00011	e8 00 00 00 00	 call	 PyList_New
  00016	48 8b d8	 mov	 rbx, rax

; 1383 :     Py_ssize_t i;
; 1384 : 
; 1385 :     if (list == NULL)

  00019	48 85 c0	 test	 rax, rax
  0001c	75 0b		 jne	 SHORT $LN5@array_toli

; 1396 : }

  0001e	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00023	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00027	5e		 pop	 rsi
  00028	c3		 ret	 0
$LN5@array_toli:
  00029	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 1386 :         return NULL;
; 1387 :     for (i = 0; i < Py_SIZE(self); i++) {

  0002e	33 ff		 xor	 edi, edi
  00030	48 39 7e 60	 cmp	 QWORD PTR [rsi+96], rdi
  00034	7e 31		 jle	 SHORT $LN2@array_toli
  00036	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@array_toli:

; 1388 :         PyObject *v = getarrayitem((PyObject *)self, i);

  00040	48 8b d7	 mov	 rdx, rdi
  00043	48 8b ce	 mov	 rcx, rsi
  00046	e8 00 00 00 00	 call	 getarrayitem

; 1389 :         if (v == NULL) {

  0004b	48 85 c0	 test	 rax, rax
  0004e	74 2a		 je	 SHORT $LN20@array_toli

; 1392 :         }
; 1393 :         PyList_SetItem(list, i, v);

  00050	4c 8b c0	 mov	 r8, rax
  00053	48 8b d7	 mov	 rdx, rdi
  00056	48 8b cb	 mov	 rcx, rbx
  00059	e8 00 00 00 00	 call	 PyList_SetItem
  0005e	48 ff c7	 inc	 rdi
  00061	48 3b 7e 60	 cmp	 rdi, QWORD PTR [rsi+96]
  00065	7c d9		 jl	 SHORT $LL4@array_toli
$LN2@array_toli:

; 1394 :     }
; 1395 :     return list;

  00067	48 8b c3	 mov	 rax, rbx
  0006a	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 1396 : }

  0006f	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00074	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00078	5e		 pop	 rsi
  00079	c3		 ret	 0
$LN20@array_toli:

; 1390 :             Py_DECREF(list);

  0007a	e8 00 00 00 00	 call	 _Py_PXCTX
  0007f	85 c0		 test	 eax, eax
  00081	75 7c		 jne	 SHORT $LN18@array_toli
  00083	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00087	a8 20		 test	 al, 32			; 00000020H
  00089	75 6c		 jne	 SHORT $LN12@array_toli
  0008b	84 c0		 test	 al, al
  0008d	78 68		 js	 SHORT $LN12@array_toli
  0008f	a8 02		 test	 al, 2
  00091	75 6c		 jne	 SHORT $LN18@array_toli
  00093	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00097	75 66		 jne	 SHORT $LN18@array_toli
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000a7	4c 8b cb	 mov	 r9, rbx
  000aa	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000b0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000b8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000bd	48 8b cb	 mov	 rcx, rbx
  000c0	85 c0		 test	 eax, eax
  000c2	74 17		 je	 SHORT $LN17@array_toli
  000c4	e8 00 00 00 00	 call	 _Px_Dealloc
  000c9	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 1391 :             return NULL;

  000ce	33 c0		 xor	 eax, eax

; 1396 : }

  000d0	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000d5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d9	5e		 pop	 rsi
  000da	c3		 ret	 0

; 1390 :             Py_DECREF(list);

$LN17@array_toli:
  000db	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000df	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000e5	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 1391 :             return NULL;

  000ea	33 c0		 xor	 eax, eax

; 1396 : }

  000ec	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000f1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f5	5e		 pop	 rsi
  000f6	c3		 ret	 0

; 1390 :             Py_DECREF(list);

$LN12@array_toli:
  000f7	48 8b cb	 mov	 rcx, rbx
  000fa	e8 00 00 00 00	 call	 Px_DecRef
$LN18@array_toli:

; 1396 : }

  000ff	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00104	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00109	33 c0		 xor	 eax, eax
  0010b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010f	5e		 pop	 rsi
  00110	c3		 ret	 0
array_tolist ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@CCOBPACL@string?5length?5not?5a?5multiple?5of?5@ ; `string'
PUBLIC	??_C@_0CB@DDGOLKLL@string?1buffer?5of?5bytes?5required?4@ ; `string'
EXTRN	PyBuffer_Release:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$frombytes DD imagerel frombytes
	DD	imagerel frombytes+78
	DD	imagerel $unwind$frombytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$frombytes DD imagerel frombytes+78
	DD	imagerel frombytes+138
	DD	imagerel $chain$1$frombytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$frombytes DD imagerel frombytes+138
	DD	imagerel frombytes+338
	DD	imagerel $chain$2$frombytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$frombytes DD imagerel frombytes+338
	DD	imagerel frombytes+359
	DD	imagerel $chain$3$frombytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$frombytes DD imagerel frombytes+359
	DD	imagerel frombytes+374
	DD	imagerel $chain$5$frombytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$frombytes DD 060021H
	DD	0ac400H
	DD	096400H
	DD	085400H
	DD	imagerel frombytes
	DD	imagerel frombytes+78
	DD	imagerel $unwind$frombytes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$frombytes DD 021H
	DD	imagerel frombytes+78
	DD	imagerel frombytes+138
	DD	imagerel $chain$1$frombytes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$frombytes DD 020521H
	DD	085405H
	DD	imagerel frombytes+78
	DD	imagerel frombytes+138
	DD	imagerel $chain$1$frombytes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$frombytes DD 040a21H
	DD	0ac40aH
	DD	096405H
	DD	imagerel frombytes
	DD	imagerel frombytes+78
	DD	imagerel $unwind$frombytes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$frombytes DD 040a01H
	DD	0b340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0CK@CCOBPACL@string?5length?5not?5a?5multiple?5of?5@
CONST	SEGMENT
??_C@_0CK@CCOBPACL@string?5length?5not?5a?5multiple?5of?5@ DB 'string len'
	DB	'gth not a multiple of item size', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DDGOLKLL@string?1buffer?5of?5bytes?5required?4@
CONST	SEGMENT
??_C@_0CB@DDGOLKLL@string?1buffer?5of?5bytes?5required?4@ DB 'string/buff'
	DB	'er of bytes required.', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
CONST	ENDS
;	COMDAT frombytes
_TEXT	SEGMENT
self$ = 64
buffer$ = 72
frombytes PROC						; COMDAT

; 1405 : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1406 :     int itemsize = self->ob_descr->itemsize;
; 1407 :     Py_ssize_t n;
; 1408 :     if (buffer->itemsize != 1) {

  0000a	48 83 7a 18 01	 cmp	 QWORD PTR [rdx+24], 1
  0000f	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  00016	48 8b f9	 mov	 rdi, rcx
  00019	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0001d	48 8b da	 mov	 rbx, rdx
  00020	74 28		 je	 SHORT $LN6@frombytes

; 1409 :         PyBuffer_Release(buffer);

  00022	48 8b ca	 mov	 rcx, rdx
  00025	e8 00 00 00 00	 call	 PyBuffer_Release

; 1410 :         PyErr_SetString(PyExc_TypeError, "string/buffer of bytes required.");

  0002a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@DDGOLKLL@string?1buffer?5of?5bytes?5required?4@
  00038	e8 00 00 00 00	 call	 PyErr_SetString

; 1411 :         return NULL;

  0003d	33 c0		 xor	 eax, eax

; 1438 : }

  0003f	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5f		 pop	 rdi
  00049	c3		 ret	 0
$LN6@frombytes:

; 1412 :     }
; 1413 :     n = buffer->len;
; 1414 :     if (n % itemsize != 0) {

  0004a	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  0004e	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00053	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  00058	48 99		 cdq
  0005a	4c 8b e1	 mov	 r12, rcx
  0005d	48 f7 f9	 idiv	 rcx
  00060	48 8b f0	 mov	 rsi, rax
  00063	48 85 d2	 test	 rdx, rdx
  00066	74 22		 je	 SHORT $LN5@frombytes

; 1415 :         PyBuffer_Release(buffer);

  00068	48 8b cb	 mov	 rcx, rbx
  0006b	e8 00 00 00 00	 call	 PyBuffer_Release

; 1416 :         PyErr_SetString(PyExc_ValueError,
; 1417 :                    "string length not a multiple of item size");

  00070	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@CCOBPACL@string?5length?5not?5a?5multiple?5of?5@
  0007e	e8 00 00 00 00	 call	 PyErr_SetString

; 1418 :         return NULL;

  00083	33 c0		 xor	 eax, eax
  00085	e9 c8 00 00 00	 jmp	 $LN14@frombytes
$LN5@frombytes:
  0008a	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp

; 1419 :     }
; 1420 :     n = n / itemsize;
; 1421 :     if (n > 0) {

  0008f	48 85 c0	 test	 rax, rax
  00092	7e 65		 jle	 SHORT $LN4@frombytes

; 1422 :         Py_ssize_t old_size = Py_SIZE(self);

  00094	48 8b 6f 60	 mov	 rbp, QWORD PTR [rdi+96]

; 1423 :         if ((n > PY_SSIZE_T_MAX - old_size) ||
; 1424 :             ((old_size + n) > PY_SSIZE_T_MAX / itemsize)) {

  00098	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000a2	48 8b c8	 mov	 rcx, rax
  000a5	48 2b cd	 sub	 rcx, rbp
  000a8	48 3b f1	 cmp	 rsi, rcx
  000ab	0f 8f b6 00 00
	00		 jg	 $LN2@frombytes
  000b1	48 99		 cdq
  000b3	48 8d 0c 2e	 lea	 rcx, QWORD PTR [rsi+rbp]
  000b7	49 f7 fc	 idiv	 r12
  000ba	48 3b c8	 cmp	 rcx, rax
  000bd	0f 8f a4 00 00
	00		 jg	 $LN2@frombytes

; 1427 :         }
; 1428 :         if (array_resize(self, old_size + n) == -1) {

  000c3	48 8b d1	 mov	 rdx, rcx
  000c6	48 8b cf	 mov	 rcx, rdi
  000c9	e8 00 00 00 00	 call	 array_resize
  000ce	83 f8 ff	 cmp	 eax, -1
  000d1	75 0c		 jne	 SHORT $LN1@frombytes

; 1429 :             PyBuffer_Release(buffer);

  000d3	48 8b cb	 mov	 rcx, rbx
  000d6	e8 00 00 00 00	 call	 PyBuffer_Release

; 1430 :             return NULL;

  000db	33 c0		 xor	 eax, eax
  000dd	eb 6e		 jmp	 SHORT $LN15@frombytes
$LN1@frombytes:

; 1431 :         }
; 1432 :         memcpy(self->ob_item + old_size * itemsize,
; 1433 :             buffer->buf, n * itemsize);

  000df	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  000e2	4d 8b c4	 mov	 r8, r12
  000e5	4c 0f af e5	 imul	 r12, rbp
  000e9	4c 03 67 70	 add	 r12, QWORD PTR [rdi+112]
  000ed	4c 0f af c6	 imul	 r8, rsi
  000f1	49 8b cc	 mov	 rcx, r12
  000f4	e8 00 00 00 00	 call	 memcpy
$LN4@frombytes:

; 1434 :     }
; 1435 :     PyBuffer_Release(buffer);

  000f9	48 8b cb	 mov	 rcx, rbx
  000fc	e8 00 00 00 00	 call	 PyBuffer_Release

; 1436 :     Py_INCREF(Py_None);

  00101	e8 00 00 00 00	 call	 _Py_PXCTX
  00106	85 c0		 test	 eax, eax
  00108	75 3c		 jne	 SHORT $LN10@frombytes
  0010a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00111	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00118	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0011f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00125	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0012d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00132	85 c0		 test	 eax, eax
  00134	75 09		 jne	 SHORT $LN9@frombytes
  00136	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0013d	74 07		 je	 SHORT $LN10@frombytes
$LN9@frombytes:
  0013f	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN10@frombytes:

; 1437 :     return Py_None;

  00146	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN15@frombytes:
  0014d	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
$LN14@frombytes:
  00152	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00157	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]

; 1438 : }

  0015c	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00161	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00165	5f		 pop	 rdi
  00166	c3		 ret	 0
$LN2@frombytes:

; 1425 :                 PyBuffer_Release(buffer);

  00167	48 8b cb	 mov	 rcx, rbx
  0016a	e8 00 00 00 00	 call	 PyBuffer_Release

; 1426 :                 return PyErr_NoMemory();

  0016f	e8 00 00 00 00	 call	 PyErr_NoMemory
  00174	eb d7		 jmp	 SHORT $LN15@frombytes
frombytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@KNGGIENM@s?$CK?3fromstring?$AA@	; `string'
PUBLIC	??_C@_0DF@BOBJEIFM@fromstring?$CI?$CJ?5is?5deprecated?4?5Use?5@ ; `string'
EXTRN	PyErr_WarnEx:PROC
EXTRN	PyExc_DeprecationWarning:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_fromstring DD imagerel array_fromstring
	DD	imagerel array_fromstring+112
	DD	imagerel $unwind$array_fromstring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_fromstring DD 040a01H
	DD	010340aH
	DD	07006d20aH
xdata	ENDS
;	COMDAT ??_C@_0O@KNGGIENM@s?$CK?3fromstring?$AA@
CONST	SEGMENT
??_C@_0O@KNGGIENM@s?$CK?3fromstring?$AA@ DB 's*:fromstring', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BOBJEIFM@fromstring?$CI?$CJ?5is?5deprecated?4?5Use?5@
CONST	SEGMENT
??_C@_0DF@BOBJEIFM@fromstring?$CI?$CJ?5is?5deprecated?4?5Use?5@ DB 'froms'
	DB	'tring() is deprecated. Use frombytes() instead.', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_fromstring
_TEXT	SEGMENT
buffer$ = 32
self$ = 128
args$ = 136
array_fromstring PROC					; COMDAT

; 1442 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8b d9	 mov	 rbx, rcx

; 1443 :     Py_buffer buffer;
; 1444 :     if (PyErr_WarnEx(PyExc_DeprecationWarning,
; 1445 :             "fromstring() is deprecated. Use frombytes() instead.", 2) != 0)

  0000d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_DeprecationWarning
  00014	48 8b fa	 mov	 rdi, rdx
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@BOBJEIFM@fromstring?$CI?$CJ?5is?5deprecated?4?5Use?5@
  0001e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00024	e8 00 00 00 00	 call	 PyErr_WarnEx
  00029	85 c0		 test	 eax, eax
  0002b	74 10		 je	 SHORT $LN3@array_from@2
$LN6@array_from@2:

; 1446 :         return NULL;

  0002d	33 c0		 xor	 eax, eax

; 1451 : }

  0002f	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  00037	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0003b	5f		 pop	 rdi
  0003c	c3		 ret	 0
$LN3@array_from@2:

; 1447 :     if (!PyArg_ParseTuple(args, "s*:fromstring", &buffer))

  0003d	4c 8d 44 24 20	 lea	 r8, QWORD PTR buffer$[rsp]
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@KNGGIENM@s?$CK?3fromstring?$AA@
  00049	48 8b cf	 mov	 rcx, rdi
  0004c	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00051	85 c0		 test	 eax, eax

; 1448 :         return NULL;

  00053	74 d8		 je	 SHORT $LN6@array_from@2

; 1449 :     else
; 1450 :         return frombytes(self, &buffer);

  00055	48 8d 54 24 20	 lea	 rdx, QWORD PTR buffer$[rsp]
  0005a	48 8b cb	 mov	 rcx, rbx
  0005d	e8 00 00 00 00	 call	 frombytes

; 1451 : }

  00062	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  0006a	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0006e	5f		 pop	 rdi
  0006f	c3		 ret	 0
array_fromstring ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@LICNHJM@y?$CK?3frombytes?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_frombytes DD imagerel array_frombytes
	DD	imagerel array_frombytes+63
	DD	imagerel $unwind$array_frombytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_frombytes DD 020601H
	DD	03002d206H
xdata	ENDS
;	COMDAT ??_C@_0N@LICNHJM@y?$CK?3frombytes?$AA@
CONST	SEGMENT
??_C@_0N@LICNHJM@y?$CK?3frombytes?$AA@ DB 'y*:frombytes', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_frombytes
_TEXT	SEGMENT
buffer$ = 32
self$ = 128
args$ = 136
array_frombytes PROC					; COMDAT

; 1464 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 1465 :     Py_buffer buffer;
; 1466 :     if (!PyArg_ParseTuple(args, "y*:frombytes", &buffer))

  0000c	4c 8d 44 24 20	 lea	 r8, QWORD PTR buffer$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@LICNHJM@y?$CK?3frombytes?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00020	85 c0		 test	 eax, eax
  00022	75 08		 jne	 SHORT $LN2@array_from@3

; 1467 :         return NULL;

  00024	33 c0		 xor	 eax, eax

; 1470 : }

  00026	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
$LN2@array_from@3:

; 1468 :     else
; 1469 :         return frombytes(self, &buffer);

  0002c	48 8d 54 24 20	 lea	 rdx, QWORD PTR buffer$[rsp]
  00031	48 8b cb	 mov	 rcx, rbx
  00034	e8 00 00 00 00	 call	 frombytes

; 1470 : }

  00039	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
array_frombytes ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT array_tobytes
_TEXT	SEGMENT
self$ = 8
unused$ = 16
array_tobytes PROC					; COMDAT

; 1482 :     if (Py_SIZE(self) <= PY_SSIZE_T_MAX / self->ob_descr->itemsize) {

  00000	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  00007	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  0000b	4c 63 48 04	 movsxd	 r9, DWORD PTR [rax+4]
  0000f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00019	48 99		 cdq
  0001b	49 f7 f9	 idiv	 r9
  0001e	4c 3b c0	 cmp	 r8, rax
  00021	7f 10		 jg	 SHORT $LN2@array_toby

; 1483 :         return PyBytes_FromStringAndSize(self->ob_item,
; 1484 :                             Py_SIZE(self) * self->ob_descr->itemsize);

  00023	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00027	4d 0f af c1	 imul	 r8, r9
  0002b	49 8b d0	 mov	 rdx, r8

; 1485 :     } else {
; 1486 :         return PyErr_NoMemory();
; 1487 :     }
; 1488 : }

  0002e	e9 00 00 00 00	 jmp	 PyBytes_FromStringAndSize
$LN2@array_toby:
  00033	e9 00 00 00 00	 jmp	 PyErr_NoMemory
array_tobytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@BGKCCGMJ@tostring?$CI?$CJ?5is?5deprecated?4?5Use?5to@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_tostring DD imagerel array_tostring
	DD	imagerel array_tostring+79
	DD	imagerel $unwind$array_tostring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_tostring DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0DB@BGKCCGMJ@tostring?$CI?$CJ?5is?5deprecated?4?5Use?5to@
CONST	SEGMENT
??_C@_0DB@BGKCCGMJ@tostring?$CI?$CJ?5is?5deprecated?4?5Use?5to@ DB 'tostr'
	DB	'ing() is deprecated. Use tobytes() instead.', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_tostring
_TEXT	SEGMENT
self$ = 48
unused$ = 56
array_tostring PROC					; COMDAT

; 1499 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 1500 :     if (PyErr_WarnEx(PyExc_DeprecationWarning,
; 1501 :             "tostring() is deprecated. Use tobytes() instead.", 2) != 0)

  0000d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_DeprecationWarning
  00014	48 8b da	 mov	 rbx, rdx
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@BGKCCGMJ@tostring?$CI?$CJ?5is?5deprecated?4?5Use?5to@
  0001e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00024	e8 00 00 00 00	 call	 PyErr_WarnEx
  00029	85 c0		 test	 eax, eax
  0002b	74 0d		 je	 SHORT $LN1@array_tost

; 1502 :         return NULL;

  0002d	33 c0		 xor	 eax, eax

; 1504 : }

  0002f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5f		 pop	 rdi
  00039	c3		 ret	 0
$LN1@array_tost:

; 1503 :     return array_tobytes(self, unused);

  0003a	48 8b d3	 mov	 rdx, rbx
  0003d	48 8b cf	 mov	 rcx, rdi

; 1504 : }

  00040	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5f		 pop	 rdi
  0004a	e9 00 00 00 00	 jmp	 array_tobytes
array_tostring ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DI@MJAINOPC@fromunicode?$CI?$CJ?5may?5only?5be?5called@ ; `string'
PUBLIC	??_C@_0P@IHHELFOJ@u?$CD?3fromunicode?$AA@	; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$array_fromunicode DD imagerel array_fromunicode
	DD	imagerel array_fromunicode+85
	DD	imagerel $unwind$array_fromunicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$array_fromunicode DD imagerel array_fromunicode+85
	DD	imagerel array_fromunicode+129
	DD	imagerel $chain$0$array_fromunicode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$array_fromunicode DD imagerel array_fromunicode+129
	DD	imagerel array_fromunicode+242
	DD	imagerel $chain$2$array_fromunicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$array_fromunicode DD 020021H
	DD	087400H
	DD	imagerel array_fromunicode
	DD	imagerel array_fromunicode+85
	DD	imagerel $unwind$array_fromunicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$array_fromunicode DD 020521H
	DD	087405H
	DD	imagerel array_fromunicode
	DD	imagerel array_fromunicode+85
	DD	imagerel $unwind$array_fromunicode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_fromunicode DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0DI@MJAINOPC@fromunicode?$CI?$CJ?5may?5only?5be?5called@
CONST	SEGMENT
??_C@_0DI@MJAINOPC@fromunicode?$CI?$CJ?5may?5only?5be?5called@ DB 'fromun'
	DB	'icode() may only be called on unicode type arrays', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IHHELFOJ@u?$CD?3fromunicode?$AA@
CONST	SEGMENT
??_C@_0P@IHHELFOJ@u?$CD?3fromunicode?$AA@ DB 'u#:fromunicode', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
CONST	ENDS
;	COMDAT array_fromunicode
_TEXT	SEGMENT
self$ = 64
args$ = 72
n$ = 80
ustr$ = 88
array_fromunicode PROC					; COMDAT

; 1517 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 1518 :     Py_UNICODE *ustr;
; 1519 :     Py_ssize_t n;
; 1520 :     char typecode;
; 1521 : 
; 1522 :     if (!PyArg_ParseTuple(args, "u#:fromunicode", &ustr, &n))

  0000c	4c 8d 4c 24 50	 lea	 r9, QWORD PTR n$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@IHHELFOJ@u?$CD?3fromunicode?$AA@
  00018	4c 8d 44 24 58	 lea	 r8, QWORD PTR ustr$[rsp]
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00025	85 c0		 test	 eax, eax

; 1523 :         return NULL;

  00027	74 1f		 je	 SHORT $LN12@array_from@4

; 1524 :     typecode = self->ob_descr->typecode;

  00029	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]

; 1525 :     if (typecode != 'u') {

  00030	80 38 75	 cmp	 BYTE PTR [rax], 117	; 00000075H
  00033	74 1b		 je	 SHORT $LN3@array_from@4

; 1526 :         PyErr_SetString(PyExc_ValueError,
; 1527 :             "fromunicode() may only be called on "
; 1528 :             "unicode type arrays");

  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DI@MJAINOPC@fromunicode?$CI?$CJ?5may?5only?5be?5called@
  00043	e8 00 00 00 00	 call	 PyErr_SetString
$LN12@array_from@4:

; 1529 :         return NULL;

  00048	33 c0		 xor	 eax, eax

; 1541 : }

  0004a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004e	5b		 pop	 rbx
  0004f	c3		 ret	 0
$LN3@array_from@4:

; 1530 :     }
; 1531 :     if (n > 0) {

  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR n$[rsp]
  00055	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0005a	48 85 c0	 test	 rax, rax
  0005d	7e 3c		 jle	 SHORT $LN2@array_from@4

; 1532 :         Py_ssize_t old_size = Py_SIZE(self);

  0005f	48 8b 7b 60	 mov	 rdi, QWORD PTR [rbx+96]

; 1533 :         if (array_resize(self, old_size + n) == -1)

  00063	48 8b cb	 mov	 rcx, rbx
  00066	48 8d 14 07	 lea	 rdx, QWORD PTR [rdi+rax]
  0006a	e8 00 00 00 00	 call	 array_resize
  0006f	83 f8 ff	 cmp	 eax, -1
  00072	75 0d		 jne	 SHORT $LN1@array_from@4

; 1534 :             return NULL;

  00074	33 c0		 xor	 eax, eax
  00076	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 1541 : }

  0007b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007f	5b		 pop	 rbx
  00080	c3		 ret	 0
$LN1@array_from@4:

; 1535 :         memcpy(self->ob_item + old_size * sizeof(Py_UNICODE),
; 1536 :                ustr, n * sizeof(Py_UNICODE));

  00081	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  00085	4c 8b 44 24 50	 mov	 r8, QWORD PTR n$[rsp]
  0008a	48 8b 54 24 58	 mov	 rdx, QWORD PTR ustr$[rsp]
  0008f	48 8d 0c 78	 lea	 rcx, QWORD PTR [rax+rdi*2]
  00093	4d 03 c0	 add	 r8, r8
  00096	e8 00 00 00 00	 call	 memcpy
$LN2@array_from@4:

; 1537 :     }
; 1538 : 
; 1539 :     Py_INCREF(Py_None);

  0009b	e8 00 00 00 00	 call	 _Py_PXCTX
  000a0	85 c0		 test	 eax, eax
  000a2	75 3c		 jne	 SHORT $LN8@array_from@4
  000a4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000b9	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000bf	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000c7	e8 00 00 00 00	 call	 _PyParallel_Guard
  000cc	85 c0		 test	 eax, eax
  000ce	75 09		 jne	 SHORT $LN7@array_from@4
  000d0	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000d7	74 07		 je	 SHORT $LN8@array_from@4
$LN7@array_from@4:
  000d9	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN8@array_from@4:

; 1540 :     return Py_None;

  000e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000e7	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 1541 : }

  000ec	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f0	5b		 pop	 rbx
  000f1	c3		 ret	 0
array_fromunicode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@PJNLGLLC@tounicode?$CI?$CJ?5may?5only?5be?5called?5o@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_tounicode DD imagerel array_tounicode
	DD	imagerel array_tounicode+59
	DD	imagerel $unwind$array_tounicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_tounicode DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0DG@PJNLGLLC@tounicode?$CI?$CJ?5may?5only?5be?5called?5o@
CONST	SEGMENT
??_C@_0DG@PJNLGLLC@tounicode?$CI?$CJ?5may?5only?5be?5called?5o@ DB 'touni'
	DB	'code() may only be called on unicode type arrays', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_tounicode
_TEXT	SEGMENT
self$ = 48
unused$ = 56
array_tounicode PROC					; COMDAT

; 1554 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1555 :     char typecode;
; 1556 :     typecode = self->ob_descr->typecode;

  00004	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]

; 1557 :     if (typecode != 'u') {

  0000b	80 38 75	 cmp	 BYTE PTR [rax], 117	; 00000075H
  0000e	74 1a		 je	 SHORT $LN1@array_toun

; 1558 :         PyErr_SetString(PyExc_ValueError,
; 1559 :              "tounicode() may only be called on unicode type arrays");

  00010	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@PJNLGLLC@tounicode?$CI?$CJ?5may?5only?5be?5called?5o@
  0001e	e8 00 00 00 00	 call	 PyErr_SetString

; 1560 :         return NULL;

  00023	33 c0		 xor	 eax, eax

; 1563 : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
$LN1@array_toun:

; 1561 :     }
; 1562 :     return PyUnicode_FromUnicode((Py_UNICODE *) self->ob_item, Py_SIZE(self));

  0002a	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  0002e	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]

; 1563 : }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00036	e9 00 00 00 00	 jmp	 PyUnicode_FromUnicode
array_tounicode ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT array_sizeof
_TEXT	SEGMENT
self$ = 8
unused$ = 16
array_sizeof PROC					; COMDAT

; 1577 :     Py_ssize_t res;
; 1578 :     res = sizeof(arrayobject) + self->allocated * self->ob_descr->itemsize;

  00000	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  00007	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  0000b	48 0f af 51 78	 imul	 rdx, QWORD PTR [rcx+120]

; 1579 :     return PyLong_FromSsize_t(res);

  00010	48 8d 8a a0 00
	00 00		 lea	 rcx, QWORD PTR [rdx+160]

; 1580 : }

  00017	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
array_sizeof ENDP
_TEXT	ENDS
PUBLIC	??_C@_08LMANIKFI@?$AF?$AE?$AD?$AC?$AB?$PP?$DPC?$AA@ ; `string'
PUBLIC	??_C@_08OJGFKMMA@C?$DP?$PP?$AB?$AC?$AD?$AE?$AF?$AA@ ; `string'
PUBLIC	__real@433fff0102030405
PUBLIC	??_C@_04LHIBIFEE@?$AC?$AB?$HPK?$AA@		; `string'
PUBLIC	??_C@_04BGFGNJMF@K?$HP?$AB?$AC?$AA@		; `string'
PUBLIC	__real@4b7f0102
;	COMDAT ??_C@_08LMANIKFI@?$AF?$AE?$AD?$AC?$AB?$PP?$DPC?$AA@
CONST	SEGMENT
??_C@_08LMANIKFI@?$AF?$AE?$AD?$AC?$AB?$PP?$DPC?$AA@ DB 05H, 04H, 03H, 02H
	DB	01H, 0ffH, '?C', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08OJGFKMMA@C?$DP?$PP?$AB?$AC?$AD?$AE?$AF?$AA@
CONST	SEGMENT
??_C@_08OJGFKMMA@C?$DP?$PP?$AB?$AC?$AD?$AE?$AF?$AA@ DB 'C?', 0ffH, 01H, 02H
	DB	03H, 04H, 05H, 00H				; `string'
CONST	ENDS
;	COMDAT __real@433fff0102030405
CONST	SEGMENT
__real@433fff0102030405 DQ 0433fff0102030405r	; 9.0061e+015
CONST	ENDS
;	COMDAT ??_C@_04LHIBIFEE@?$AC?$AB?$HPK?$AA@
CONST	SEGMENT
??_C@_04LHIBIFEE@?$AC?$AB?$HPK?$AA@ DB 02H, 01H, 07fH, 'K', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BGFGNJMF@K?$HP?$AB?$AC?$AA@
CONST	SEGMENT
??_C@_04BGFGNJMF@K?$HP?$AB?$AC?$AA@ DB 'K', 07fH, 01H, 02H, 00H ; `string'
CONST	ENDS
;	COMDAT __real@4b7f0102
CONST	SEGMENT
__real@4b7f0102 DD 04b7f0102r			; 1.67119e+007
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT typecode_to_mformat_code
_TEXT	SEGMENT
y$21682 = 8
typecode$ = 8
x$21690 = 16
typecode_to_mformat_code PROC				; COMDAT

; 1667 : #ifdef WORDS_BIGENDIAN
; 1668 :     const int is_big_endian = 1;
; 1669 : #else
; 1670 :     const int is_big_endian = 0;
; 1671 : #endif
; 1672 :     size_t intsize;
; 1673 :     int is_signed;
; 1674 : 
; 1675 :     switch (typecode) {

  00000	0f be c1	 movsx	 eax, cl
  00003	83 c0 be	 add	 eax, -66		; ffffffffffffffbeH
  00006	83 f8 33	 cmp	 eax, 51			; 00000033H
  00009	0f 87 ca 00 00
	00		 ja	 $LN7@typecode_t
  0000f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00016	48 98		 cdqe
  00018	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN35@typecode_t[rdx+rax]
  00020	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN36@typecode_t[rdx+rax*4]
  00027	48 03 ca	 add	 rcx, rdx
  0002a	ff e1		 jmp	 rcx
$LN28@typecode_t:

; 1676 :     case 'b':
; 1677 :         return SIGNED_INT8;

  0002c	b8 01 00 00 00	 mov	 eax, 1

; 1755 :     default:
; 1756 :         return UNKNOWN_FORMAT;
; 1757 :     }
; 1758 : }

  00031	c3		 ret	 0
$LN27@typecode_t:

; 1678 :     case 'B':
; 1679 :         return UNSIGNED_INT8;

  00032	33 c0		 xor	 eax, eax

; 1755 :     default:
; 1756 :         return UNKNOWN_FORMAT;
; 1757 :     }
; 1758 : }

  00034	c3		 ret	 0
$LN26@typecode_t:

; 1680 : 
; 1681 :     case 'u':
; 1682 :         if (sizeof(Py_UNICODE) == 2) {
; 1683 :             return UTF16_LE + is_big_endian;

  00035	b8 12 00 00 00	 mov	 eax, 18

; 1755 :     default:
; 1756 :         return UNKNOWN_FORMAT;
; 1757 :     }
; 1758 : }

  0003a	c3		 ret	 0
$LN23@typecode_t:

; 1684 :         }
; 1685 :         if (sizeof(Py_UNICODE) == 4) {
; 1686 :             return UTF32_LE + is_big_endian;
; 1687 :         }
; 1688 :         return UNKNOWN_FORMAT;
; 1689 : 
; 1690 :     case 'f':
; 1691 :         if (sizeof(float) == 4) {
; 1692 :             const float y = 16711938.0;

  0003b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@4b7f0102
  00043	f3 0f 11 44 24
	08		 movss	 DWORD PTR y$21682[rsp], xmm0

; 1693 :             if (memcmp(&y, "\x4b\x7f\x01\x02", 4) == 0)

  00049	8b 4c 24 08	 mov	 ecx, DWORD PTR y$21682[rsp]
  0004d	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ??_C@_04BGFGNJMF@K?$HP?$AB?$AC?$AA@
  00053	75 06		 jne	 SHORT $LN21@typecode_t

; 1694 :                 return IEEE_754_FLOAT_BE;

  00055	b8 0f 00 00 00	 mov	 eax, 15

; 1755 :     default:
; 1756 :         return UNKNOWN_FORMAT;
; 1757 :     }
; 1758 : }

  0005a	c3		 ret	 0
$LN21@typecode_t:

; 1695 :             if (memcmp(&y, "\x02\x01\x7f\x4b", 4) == 0)

  0005b	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ??_C@_04LHIBIFEE@?$AC?$AB?$HPK?$AA@
  00061	b8 ff ff ff ff	 mov	 eax, -1
  00066	b9 0e 00 00 00	 mov	 ecx, 14
  0006b	0f 44 c1	 cmove	 eax, ecx

; 1755 :     default:
; 1756 :         return UNKNOWN_FORMAT;
; 1757 :     }
; 1758 : }

  0006e	c3		 ret	 0
$LN19@typecode_t:

; 1696 :                 return IEEE_754_FLOAT_LE;
; 1697 :         }
; 1698 :         return UNKNOWN_FORMAT;
; 1699 : 
; 1700 :     case 'd':
; 1701 :         if (sizeof(double) == 8) {
; 1702 :             const double x = 9006104071832581.0;

  0006f	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@433fff0102030405
  00077	f2 0f 11 44 24
	10		 movsdx	 QWORD PTR x$21690[rsp], xmm0

; 1703 :             if (memcmp(&x, "\x43\x3f\xff\x01\x02\x03\x04\x05", 8) == 0)

  0007d	48 8b 44 24 10	 mov	 rax, QWORD PTR x$21690[rsp]
  00082	48 3b 05 00 00
	00 00		 cmp	 rax, QWORD PTR ??_C@_08OJGFKMMA@C?$DP?$PP?$AB?$AC?$AD?$AE?$AF?$AA@
  00089	75 06		 jne	 SHORT $LN17@typecode_t

; 1704 :                 return IEEE_754_DOUBLE_BE;

  0008b	b8 11 00 00 00	 mov	 eax, 17

; 1755 :     default:
; 1756 :         return UNKNOWN_FORMAT;
; 1757 :     }
; 1758 : }

  00090	c3		 ret	 0
$LN17@typecode_t:

; 1705 :             if (memcmp(&x, "\x05\x04\x03\x02\x01\xff\x3f\x43", 8) == 0)

  00091	48 3b 05 00 00
	00 00		 cmp	 rax, QWORD PTR ??_C@_08LMANIKFI@?$AF?$AE?$AD?$AC?$AB?$PP?$DPC?$AA@
  00098	b9 10 00 00 00	 mov	 ecx, 16
  0009d	b8 ff ff ff ff	 mov	 eax, -1
  000a2	0f 44 c1	 cmove	 eax, ecx

; 1755 :     default:
; 1756 :         return UNKNOWN_FORMAT;
; 1757 :     }
; 1758 : }

  000a5	c3		 ret	 0
$LN15@typecode_t:

; 1706 :                 return IEEE_754_DOUBLE_LE;
; 1707 :         }
; 1708 :         return UNKNOWN_FORMAT;
; 1709 : 
; 1710 :     /* Integers */
; 1711 :     case 'h':
; 1712 :         intsize = sizeof(short);
; 1713 :         is_signed = 1;

  000a6	b8 01 00 00 00	 mov	 eax, 1

; 1747 :     }
; 1748 :     switch (intsize) {
; 1749 :     case 2:
; 1750 :         return UNSIGNED_INT16_LE + is_big_endian + (2 * is_signed);

  000ab	8d 44 00 02	 lea	 eax, DWORD PTR [rax+rax+2]

; 1755 :     default:
; 1756 :         return UNKNOWN_FORMAT;
; 1757 :     }
; 1758 : }

  000af	c3		 ret	 0
$LN14@typecode_t:

; 1714 :         break;
; 1715 :     case 'H':
; 1716 :         intsize = sizeof(short);
; 1717 :         is_signed = 0;

  000b0	33 c0		 xor	 eax, eax

; 1747 :     }
; 1748 :     switch (intsize) {
; 1749 :     case 2:
; 1750 :         return UNSIGNED_INT16_LE + is_big_endian + (2 * is_signed);

  000b2	8d 44 00 02	 lea	 eax, DWORD PTR [rax+rax+2]

; 1755 :     default:
; 1756 :         return UNKNOWN_FORMAT;
; 1757 :     }
; 1758 : }

  000b6	c3		 ret	 0
$LN11@typecode_t:

; 1718 :         break;
; 1719 :     case 'i':
; 1720 :         intsize = sizeof(int);
; 1721 :         is_signed = 1;
; 1722 :         break;
; 1723 :     case 'I':
; 1724 :         intsize = sizeof(int);
; 1725 :         is_signed = 0;
; 1726 :         break;
; 1727 :     case 'l':
; 1728 :         intsize = sizeof(long);
; 1729 :         is_signed = 1;

  000b7	b8 01 00 00 00	 mov	 eax, 1

; 1751 :     case 4:
; 1752 :         return UNSIGNED_INT32_LE + is_big_endian + (2 * is_signed);

  000bc	8d 44 00 06	 lea	 eax, DWORD PTR [rax+rax+6]

; 1755 :     default:
; 1756 :         return UNKNOWN_FORMAT;
; 1757 :     }
; 1758 : }

  000c0	c3		 ret	 0
$LN10@typecode_t:

; 1730 :         break;
; 1731 :     case 'L':
; 1732 :         intsize = sizeof(long);
; 1733 :         is_signed = 0;

  000c1	33 c0		 xor	 eax, eax

; 1751 :     case 4:
; 1752 :         return UNSIGNED_INT32_LE + is_big_endian + (2 * is_signed);

  000c3	8d 44 00 06	 lea	 eax, DWORD PTR [rax+rax+6]

; 1755 :     default:
; 1756 :         return UNKNOWN_FORMAT;
; 1757 :     }
; 1758 : }

  000c7	c3		 ret	 0
$LN9@typecode_t:

; 1734 :         break;
; 1735 : #if HAVE_LONG_LONG
; 1736 :     case 'q':
; 1737 :         intsize = sizeof(PY_LONG_LONG);
; 1738 :         is_signed = 1;

  000c8	b8 01 00 00 00	 mov	 eax, 1

; 1753 :     case 8:
; 1754 :         return UNSIGNED_INT64_LE + is_big_endian + (2 * is_signed);

  000cd	8d 44 00 0a	 lea	 eax, DWORD PTR [rax+rax+10]

; 1755 :     default:
; 1756 :         return UNKNOWN_FORMAT;
; 1757 :     }
; 1758 : }

  000d1	c3		 ret	 0
$LN8@typecode_t:

; 1739 :         break;
; 1740 :     case 'Q':
; 1741 :         intsize = sizeof(PY_LONG_LONG);
; 1742 :         is_signed = 0;

  000d2	33 c0		 xor	 eax, eax

; 1753 :     case 8:
; 1754 :         return UNSIGNED_INT64_LE + is_big_endian + (2 * is_signed);

  000d4	8d 44 00 0a	 lea	 eax, DWORD PTR [rax+rax+10]

; 1755 :     default:
; 1756 :         return UNKNOWN_FORMAT;
; 1757 :     }
; 1758 : }

  000d8	c3		 ret	 0
$LN7@typecode_t:

; 1743 :         break;
; 1744 : #endif
; 1745 :     default:
; 1746 :         return UNKNOWN_FORMAT;

  000d9	83 c8 ff	 or	 eax, -1

; 1755 :     default:
; 1756 :         return UNKNOWN_FORMAT;
; 1757 :     }
; 1758 : }

  000dc	c3		 ret	 0
  000dd	0f 1f 00	 npad	 3
$LN36@typecode_t:
  000e0	00 00 00 00	 DD	 $LN27@typecode_t
  000e4	00 00 00 00	 DD	 $LN14@typecode_t
  000e8	00 00 00 00	 DD	 $LN10@typecode_t
  000ec	00 00 00 00	 DD	 $LN8@typecode_t
  000f0	00 00 00 00	 DD	 $LN28@typecode_t
  000f4	00 00 00 00	 DD	 $LN19@typecode_t
  000f8	00 00 00 00	 DD	 $LN23@typecode_t
  000fc	00 00 00 00	 DD	 $LN15@typecode_t
  00100	00 00 00 00	 DD	 $LN11@typecode_t
  00104	00 00 00 00	 DD	 $LN9@typecode_t
  00108	00 00 00 00	 DD	 $LN26@typecode_t
  0010c	00 00 00 00	 DD	 $LN7@typecode_t
$LN35@typecode_t:
  00110	00		 DB	 0
  00111	0b		 DB	 11
  00112	0b		 DB	 11
  00113	0b		 DB	 11
  00114	0b		 DB	 11
  00115	0b		 DB	 11
  00116	01		 DB	 1
  00117	02		 DB	 2
  00118	0b		 DB	 11
  00119	0b		 DB	 11
  0011a	02		 DB	 2
  0011b	0b		 DB	 11
  0011c	0b		 DB	 11
  0011d	0b		 DB	 11
  0011e	0b		 DB	 11
  0011f	03		 DB	 3
  00120	0b		 DB	 11
  00121	0b		 DB	 11
  00122	0b		 DB	 11
  00123	0b		 DB	 11
  00124	0b		 DB	 11
  00125	0b		 DB	 11
  00126	0b		 DB	 11
  00127	0b		 DB	 11
  00128	0b		 DB	 11
  00129	0b		 DB	 11
  0012a	0b		 DB	 11
  0012b	0b		 DB	 11
  0012c	0b		 DB	 11
  0012d	0b		 DB	 11
  0012e	0b		 DB	 11
  0012f	0b		 DB	 11
  00130	04		 DB	 4
  00131	0b		 DB	 11
  00132	05		 DB	 5
  00133	0b		 DB	 11
  00134	06		 DB	 6
  00135	0b		 DB	 11
  00136	07		 DB	 7
  00137	08		 DB	 8
  00138	0b		 DB	 11
  00139	0b		 DB	 11
  0013a	08		 DB	 8
  0013b	0b		 DB	 11
  0013c	0b		 DB	 11
  0013d	0b		 DB	 11
  0013e	0b		 DB	 11
  0013f	09		 DB	 9
  00140	0b		 DB	 11
  00141	0b		 DB	 11
  00142	0b		 DB	 11
  00143	0a		 DB	 10
typecode_to_mformat_code ENDP
_TEXT	ENDS
PUBLIC	??_C@_06KHHGOGBN@O?$CICO?$CJO?$AA@		; `string'
PUBLIC	??_C@_08KGFFDHKB@O?$CIOCiN?$CJO?$AA@		; `string'
PUBLIC	??_C@_0CJ@JNEGJPIC@__reduce_ex__?5argument?5should?5an@ ; `string'
EXTRN	_Py_BuildValue_SizeT:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_AttributeError:QWORD
EXTRN	PyLong_AsLong:PROC
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	PyImport_ImportModule:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_reduce_ex DD imagerel array_reduce_ex
	DD	imagerel array_reduce_ex+454
	DD	imagerel $unwind$array_reduce_ex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_reduce_ex DD 0a1a01H
	DD	0d741aH
	DD	0c641aH
	DD	0b541aH
	DD	0a341aH
	DD	0c016721aH
xdata	ENDS
;	COMDAT ??_C@_06KHHGOGBN@O?$CICO?$CJO?$AA@
CONST	SEGMENT
??_C@_06KHHGOGBN@O?$CICO?$CJO?$AA@ DB 'O(CO)O', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KGFFDHKB@O?$CIOCiN?$CJO?$AA@
CONST	SEGMENT
??_C@_08KGFFDHKB@O?$CIOCiN?$CJO?$AA@ DB 'O(OCiN)O', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JNEGJPIC@__reduce_ex__?5argument?5should?5an@
CONST	SEGMENT
??_C@_0CJ@JNEGJPIC@__reduce_ex__?5argument?5should?5an@ DB '__reduce_ex__'
	DB	' argument should an integer', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_reduce_ex
_TEXT	SEGMENT
array$ = 80
value$ = 88
array_reduce_ex PROC					; COMDAT

; 2012 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 2013 :     PyObject *dict;
; 2014 :     PyObject *result;
; 2015 :     PyObject *array_str;
; 2016 :     int typecode = array->ob_descr->typecode;
; 2017 :     int mformat_code;
; 2018 :     static PyObject *array_reconstructor = NULL;
; 2019 :     long protocol;
; 2020 :     _Py_IDENTIFIER(_array_reconstructor);
; 2021 :     _Py_IDENTIFIER(__dict__);
; 2022 : 
; 2023 :     if (array_reconstructor == NULL) {

  0001a	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?array_reconstructor@?1??array_reduce_ex@@9@9, 0
  00022	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  00029	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _tls_index
  0002f	44 0f be 20	 movsx	 r12d, BYTE PTR [rax]
  00033	48 8b fa	 mov	 rdi, rdx
  00036	48 8b d9	 mov	 rbx, rcx
  00039	75 47		 jne	 SHORT $LN9@array_redu

; 2024 :         PyObject *array_module = PyImport_ImportModule("array");

  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05HIFJDKLD@array?$AA@
  00042	e8 00 00 00 00	 call	 PyImport_ImportModule
  00047	48 8b f0	 mov	 rsi, rax

; 2025 :         if (array_module == NULL)

  0004a	48 85 c0	 test	 rax, rax

; 2026 :             return NULL;

  0004d	74 56		 je	 SHORT $LN15@array_redu

; 2027 :         array_reconstructor = _PyObject_GetAttrId(
; 2028 :             array_module,
; 2029 :             &PyId__array_reconstructor);

  0004f	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00058	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId__array_reconstructor@?1??array_reduce_ex@@9@9
  0005d	48 8b ce	 mov	 rcx, rsi
  00060	48 03 14 e8	 add	 rdx, QWORD PTR [rax+rbp*8]
  00064	e8 00 00 00 00	 call	 _PyObject_GetAttrId

; 2030 :         Py_DECREF(array_module);

  00069	48 8b ce	 mov	 rcx, rsi
  0006c	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?array_reconstructor@?1??array_reduce_ex@@9@9, rax
  00073	e8 00 00 00 00	 call	 _Py_DecRef

; 2031 :         if (array_reconstructor == NULL)

  00078	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?array_reconstructor@?1??array_reduce_ex@@9@9, 0

; 2032 :             return NULL;

  00080	74 23		 je	 SHORT $LN15@array_redu
$LN9@array_redu:

; 2033 :     }
; 2034 : 
; 2035 :     if (!PyLong_Check(value)) {

  00082	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00086	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00090	75 1a		 jne	 SHORT $LN8@array_redu

; 2036 :         PyErr_SetString(PyExc_TypeError,
; 2037 :                         "__reduce_ex__ argument should an integer");

  00092	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@JNEGJPIC@__reduce_ex__?5argument?5should?5an@
  000a0	e8 00 00 00 00	 call	 PyErr_SetString
$LN15@array_redu:

; 2038 :         return NULL;

  000a5	33 c0		 xor	 eax, eax
  000a7	e9 ff 00 00 00	 jmp	 $LN12@array_redu
$LN8@array_redu:

; 2039 :     }
; 2040 :     protocol = PyLong_AsLong(value);

  000ac	48 8b cf	 mov	 rcx, rdi
  000af	e8 00 00 00 00	 call	 PyLong_AsLong
  000b4	8b f0		 mov	 esi, eax

; 2041 :     if (protocol == -1 && PyErr_Occurred())

  000b6	83 f8 ff	 cmp	 eax, -1
  000b9	75 0a		 jne	 SHORT $LN7@array_redu
  000bb	e8 00 00 00 00	 call	 PyErr_Occurred
  000c0	48 85 c0	 test	 rax, rax

; 2042 :         return NULL;

  000c3	75 e0		 jne	 SHORT $LN15@array_redu
$LN7@array_redu:

; 2043 : 
; 2044 :     dict = _PyObject_GetAttrId((PyObject *)array, &PyId___dict__);

  000c5	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000ce	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___dict__@?1??array_reduce_ex@@9@9
  000d3	48 8b cb	 mov	 rcx, rbx
  000d6	48 03 14 e8	 add	 rdx, QWORD PTR [rax+rbp*8]
  000da	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  000df	48 8b f8	 mov	 rdi, rax

; 2045 :     if (dict == NULL) {

  000e2	48 85 c0	 test	 rax, rax
  000e5	75 24		 jne	 SHORT $LN6@array_redu

; 2046 :         if (!PyErr_ExceptionMatches(PyExc_AttributeError))

  000e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  000ee	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  000f3	85 c0		 test	 eax, eax

; 2047 :             return NULL;

  000f5	74 ae		 je	 SHORT $LN15@array_redu

; 2048 :         PyErr_Clear();

  000f7	e8 00 00 00 00	 call	 PyErr_Clear

; 2049 :         dict = Py_None;

  000fc	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct

; 2050 :         Py_INCREF(dict);

  00103	48 8b cf	 mov	 rcx, rdi
  00106	e8 00 00 00 00	 call	 _Py_IncRef
$LN6@array_redu:

; 2051 :     }
; 2052 : 
; 2053 :     mformat_code = typecode_to_mformat_code(typecode);

  0010b	41 0f b6 cc	 movzx	 ecx, r12b
  0010f	e8 00 00 00 00	 call	 typecode_to_mformat_code
  00114	8b e8		 mov	 ebp, eax

; 2054 :     if (mformat_code == UNKNOWN_FORMAT || protocol < 3) {

  00116	83 f8 ff	 cmp	 eax, -1
  00119	74 41		 je	 SHORT $LN3@array_redu
  0011b	83 fe 03	 cmp	 esi, 3
  0011e	7c 3c		 jl	 SHORT $LN3@array_redu

; 2077 :     }
; 2078 : 
; 2079 :     array_str = array_tobytes(array, NULL);

  00120	33 d2		 xor	 edx, edx
  00122	48 8b cb	 mov	 rcx, rbx
  00125	e8 00 00 00 00	 call	 array_tobytes

; 2080 :     if (array_str == NULL) {

  0012a	48 85 c0	 test	 rax, rax

; 2081 :         Py_DECREF(dict);
; 2082 :         return NULL;

  0012d	74 3f		 je	 SHORT $LN16@array_redu

; 2083 :     }
; 2084 :     result = Py_BuildValue(
; 2085 :         "O(OCiN)O", array_reconstructor, Py_TYPE(array), typecode,
; 2086 :         mformat_code, array_str, dict);

  0012f	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  00133	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?array_reconstructor@?1??array_reduce_ex@@9@9
  0013a	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0013f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08KGFFDHKB@O?$CIOCiN?$CJO?$AA@
  0014b	45 8b cc	 mov	 r9d, r12d
  0014e	89 6c 24 20	 mov	 DWORD PTR [rsp+32], ebp
  00152	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  00157	48 8b d8	 mov	 rbx, rax

; 2087 :     Py_DECREF(dict);
; 2088 :     return result;

  0015a	eb 44		 jmp	 SHORT $LN14@array_redu
$LN3@array_redu:

; 2055 :         /* Convert the array to a list if we got something weird
; 2056 :          * (e.g., non-IEEE floats), or we are pickling the array using
; 2057 :          * a Python 2.x compatible protocol.
; 2058 :          *
; 2059 :          * It is necessary to use a list representation for Python 2.x
; 2060 :          * compatible pickle protocol, since Python 2's str objects
; 2061 :          * are unpickled as unicode by Python 3. Thus it is impossible
; 2062 :          * to make arrays unpicklable by Python 3 by using their memory
; 2063 :          * representation, unless we resort to ugly hacks such as
; 2064 :          * coercing unicode objects to bytes in array_reconstructor.
; 2065 :          */
; 2066 :         PyObject *list;
; 2067 :         list = array_tolist(array, NULL);

  0015c	33 d2		 xor	 edx, edx
  0015e	48 8b cb	 mov	 rcx, rbx
  00161	e8 00 00 00 00	 call	 array_tolist
  00166	48 8b f0	 mov	 rsi, rax

; 2068 :         if (list == NULL) {

  00169	48 85 c0	 test	 rax, rax
  0016c	75 0c		 jne	 SHORT $LN2@array_redu
$LN16@array_redu:

; 2069 :             Py_DECREF(dict);

  0016e	48 8b cf	 mov	 rcx, rdi
  00171	e8 00 00 00 00	 call	 _Py_DecRef

; 2070 :             return NULL;

  00176	33 c0		 xor	 eax, eax
  00178	eb 31		 jmp	 SHORT $LN12@array_redu
$LN2@array_redu:

; 2071 :         }
; 2072 :         result = Py_BuildValue(
; 2073 :             "O(CO)O", Py_TYPE(array), typecode, list, dict);

  0017a	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  0017e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06KHHGOGBN@O?$CICO?$CJO?$AA@
  00185	4c 8b c8	 mov	 r9, rax
  00188	45 8b c4	 mov	 r8d, r12d
  0018b	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00190	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 2074 :         Py_DECREF(list);

  00195	48 8b ce	 mov	 rcx, rsi
  00198	48 8b d8	 mov	 rbx, rax
  0019b	e8 00 00 00 00	 call	 _Py_DecRef
$LN14@array_redu:

; 2075 :         Py_DECREF(dict);

  001a0	48 8b cf	 mov	 rcx, rdi
  001a3	e8 00 00 00 00	 call	 _Py_DecRef

; 2076 :         return result;

  001a8	48 8b c3	 mov	 rax, rbx
$LN12@array_redu:

; 2089 : }

  001ab	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001b0	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  001b5	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  001ba	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  001bf	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001c3	41 5c		 pop	 r12
  001c5	c3		 ret	 0
array_reduce_ex ENDP
_TEXT	ENDS
EXTRN	PyUnicode_FromOrdinal:PROC
; Function compile flags: /Ogtpy
;	COMDAT array_get_typecode
_TEXT	SEGMENT
a$ = 8
closure$ = 16
array_get_typecode PROC					; COMDAT

; 2096 :     char typecode = a->ob_descr->typecode;

  00000	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]

; 2097 :     return PyUnicode_FromOrdinal(typecode);

  00007	0f be 08	 movsx	 ecx, BYTE PTR [rax]

; 2098 : }

  0000a	e9 00 00 00 00	 jmp	 PyUnicode_FromOrdinal
array_get_typecode ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT array_get_itemsize
_TEXT	SEGMENT
a$ = 8
closure$ = 16
array_get_itemsize PROC					; COMDAT

; 2103 :     return PyLong_FromLong((long)a->ob_descr->itemsize);

  00000	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  00007	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]

; 2104 : }

  0000a	e9 00 00 00 00	 jmp	 PyLong_FromLong
array_get_itemsize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@ELMLMNDK@array?$CI?8?$CFc?8?0?5?$CFR?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0M@CECFMNFO@array?$CI?8?$CFc?8?$CJ?$AA@	; `string'
EXTRN	PyUnicode_FromFormat:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_repr DD imagerel array_repr
	DD	imagerel array_repr+45
	DD	imagerel $unwind$array_repr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$array_repr DD imagerel array_repr+45
	DD	imagerel array_repr+86
	DD	imagerel $chain$0$array_repr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$array_repr DD imagerel array_repr+86
	DD	imagerel array_repr+129
	DD	imagerel $chain$2$array_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$array_repr DD 020021H
	DD	067400H
	DD	imagerel array_repr
	DD	imagerel array_repr+45
	DD	imagerel $unwind$array_repr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$array_repr DD 020521H
	DD	067405H
	DD	imagerel array_repr
	DD	imagerel array_repr+45
	DD	imagerel $unwind$array_repr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_repr DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BA@ELMLMNDK@array?$CI?8?$CFc?8?0?5?$CFR?$CJ?$AA@
CONST	SEGMENT
??_C@_0BA@ELMLMNDK@array?$CI?8?$CFc?8?0?5?$CFR?$CJ?$AA@ DB 'array(''%c'','
	DB	' %R)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CECFMNFO@array?$CI?8?$CFc?8?$CJ?$AA@
CONST	SEGMENT
??_C@_0M@CECFMNFO@array?$CI?8?$CFc?8?$CJ?$AA@ DB 'array(''%c'')', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_repr
_TEXT	SEGMENT
a$ = 48
array_repr PROC						; COMDAT

; 2168 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2169 :     char typecode;
; 2170 :     PyObject *s, *v = NULL;
; 2171 :     Py_ssize_t len;
; 2172 : 
; 2173 :     len = Py_SIZE(a);
; 2174 :     typecode = a->ob_descr->typecode;
; 2175 :     if (len == 0) {

  00006	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  0000b	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  00012	0f b6 18	 movzx	 ebx, BYTE PTR [rax]
  00015	75 14		 jne	 SHORT $LN4@array_repr

; 2176 :         return PyUnicode_FromFormat("array('%c')", (int)typecode);

  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@CECFMNFO@array?$CI?8?$CFc?8?$CJ?$AA@
  0001e	0f be d3	 movsx	 edx, bl

; 2189 : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5b		 pop	 rbx
  00026	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
$LN4@array_repr:

; 2177 :     }
; 2178 :     if (typecode == 'u') {
; 2179 :         v = array_tounicode(a, NULL);

  0002b	33 d2		 xor	 edx, edx
  0002d	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00032	80 fb 75	 cmp	 bl, 117			; 00000075H
  00035	75 07		 jne	 SHORT $LN3@array_repr
  00037	e8 00 00 00 00	 call	 array_tounicode

; 2180 :     } else {

  0003c	eb 05		 jmp	 SHORT $LN8@array_repr
$LN3@array_repr:

; 2181 :         v = array_tolist(a, NULL);

  0003e	e8 00 00 00 00	 call	 array_tolist
$LN8@array_repr:
  00043	48 8b f8	 mov	 rdi, rax

; 2182 :     }
; 2183 :     if (v == NULL)

  00046	48 85 c0	 test	 rax, rax
  00049	75 0b		 jne	 SHORT $LN1@array_repr
  0004b	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 2189 : }

  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5b		 pop	 rbx
  00055	c3		 ret	 0
$LN1@array_repr:

; 2184 :         return NULL;
; 2185 : 
; 2186 :     s = PyUnicode_FromFormat("array('%c', %R)", (int)typecode, v);

  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@ELMLMNDK@array?$CI?8?$CFc?8?0?5?$CFR?$CJ?$AA@
  0005d	0f be d3	 movsx	 edx, bl
  00060	4c 8b c7	 mov	 r8, rdi
  00063	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 2187 :     Py_DECREF(v);

  00068	48 8b cf	 mov	 rcx, rdi
  0006b	48 8b d8	 mov	 rbx, rax
  0006e	e8 00 00 00 00	 call	 _Py_DecRef
  00073	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 2188 :     return s;

  00078	48 8b c3	 mov	 rax, rbx

; 2189 : }

  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5b		 pop	 rbx
  00080	c3		 ret	 0
array_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@MJNNCJGL@array?5indices?5must?5be?5integers?$AA@ ; `string'
EXTRN	PySlice_GetIndicesEx:PROC
EXTRN	PySlice_Type:BYTE
EXTRN	PyNumber_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_subscr DD imagerel array_subscr
	DD	imagerel array_subscr+135
	DD	imagerel $unwind$array_subscr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$array_subscr DD imagerel array_subscr+135
	DD	imagerel array_subscr+235
	DD	imagerel $chain$0$array_subscr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$array_subscr DD imagerel array_subscr+235
	DD	imagerel array_subscr+273
	DD	imagerel $chain$2$array_subscr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$array_subscr DD imagerel array_subscr+273
	DD	imagerel array_subscr+322
	DD	imagerel $chain$4$array_subscr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$array_subscr DD imagerel array_subscr+322
	DD	imagerel array_subscr+357
	DD	imagerel $chain$7$array_subscr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$array_subscr DD imagerel array_subscr+357
	DD	imagerel array_subscr+379
	DD	imagerel $chain$10$array_subscr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$array_subscr DD imagerel array_subscr+379
	DD	imagerel array_subscr+454
	DD	imagerel $chain$11$array_subscr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$array_subscr DD imagerel array_subscr+454
	DD	imagerel array_subscr+479
	DD	imagerel $chain$12$array_subscr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$array_subscr DD imagerel array_subscr+479
	DD	imagerel array_subscr+507
	DD	imagerel $chain$13$array_subscr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$array_subscr DD 021H
	DD	imagerel array_subscr
	DD	imagerel array_subscr+135
	DD	imagerel $unwind$array_subscr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$array_subscr DD 021H
	DD	imagerel array_subscr+357
	DD	imagerel array_subscr+379
	DD	imagerel $chain$10$array_subscr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$array_subscr DD 020521H
	DD	08d405H
	DD	imagerel array_subscr+357
	DD	imagerel array_subscr+379
	DD	imagerel $chain$10$array_subscr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$array_subscr DD 060721H
	DD	0e5407H
	DD	09c400H
	DD	0a6400H
	DD	imagerel array_subscr
	DD	imagerel array_subscr+135
	DD	imagerel $unwind$array_subscr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$array_subscr DD 040521H
	DD	0a6405H
	DD	09c400H
	DD	imagerel array_subscr
	DD	imagerel array_subscr+135
	DD	imagerel $unwind$array_subscr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$array_subscr DD 020021H
	DD	09c400H
	DD	imagerel array_subscr
	DD	imagerel array_subscr+135
	DD	imagerel $unwind$array_subscr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$array_subscr DD 020021H
	DD	09c400H
	DD	imagerel array_subscr
	DD	imagerel array_subscr+135
	DD	imagerel $unwind$array_subscr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$array_subscr DD 020521H
	DD	09c405H
	DD	imagerel array_subscr
	DD	imagerel array_subscr+135
	DD	imagerel $unwind$array_subscr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_subscr DD 030701H
	DD	07003a207H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_0BP@MJNNCJGL@array?5indices?5must?5be?5integers?$AA@
CONST	SEGMENT
??_C@_0BP@MJNNCJGL@array?5indices?5must?5be?5integers?$AA@ DB 'array indi'
	DB	'ces must be integers', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_subscr
_TEXT	SEGMENT
stop$22076 = 48
self$ = 112
slicelength$22078 = 120
item$ = 120
start$22075 = 128
step$22077 = 136
array_subscr PROC					; COMDAT

; 2193 : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00007	48 8b f9	 mov	 rdi, rcx

; 2194 :     if (PyIndex_Check(item)) {

  0000a	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  0000e	4c 8b d2	 mov	 r10, rdx
  00011	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  00018	48 85 c0	 test	 rax, rax
  0001b	74 4f		 je	 SHORT $LN16@array_subs
  0001d	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  00025	74 45		 je	 SHORT $LN16@array_subs

; 2195 :         Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);

  00027	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  0002e	49 8b ca	 mov	 rcx, r10
  00031	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00036	48 8b d8	 mov	 rbx, rax

; 2196 :         if (i==-1 && PyErr_Occurred()) {

  00039	48 83 f8 ff	 cmp	 rax, -1
  0003d	75 13		 jne	 SHORT $LN15@array_subs
  0003f	e8 00 00 00 00	 call	 PyErr_Occurred
  00044	48 85 c0	 test	 rax, rax
  00047	74 0e		 je	 SHORT $LN21@array_subs

; 2197 :             return NULL;

  00049	33 c0		 xor	 eax, eax

; 2247 :     }
; 2248 : }

  0004b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0004f	5f		 pop	 rdi
  00050	5b		 pop	 rbx
  00051	c3		 ret	 0
$LN15@array_subs:

; 2198 :         }
; 2199 :         if (i < 0)

  00052	48 85 c0	 test	 rax, rax
  00055	79 04		 jns	 SHORT $LN14@array_subs
$LN21@array_subs:

; 2200 :             i += Py_SIZE(self);

  00057	48 03 5f 60	 add	 rbx, QWORD PTR [rdi+96]
$LN14@array_subs:

; 2201 :         return array_item(self, i);

  0005b	48 8b d3	 mov	 rdx, rbx
  0005e	48 8b cf	 mov	 rcx, rdi

; 2247 :     }
; 2248 : }

  00061	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00065	5f		 pop	 rdi
  00066	5b		 pop	 rbx
  00067	e9 00 00 00 00	 jmp	 array_item
$LN16@array_subs:

; 2202 :     }
; 2203 :     else if (PySlice_Check(item)) {

  0006c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  00073	48 3b c8	 cmp	 rcx, rax
  00076	0f 85 63 01 00
	00		 jne	 $LN12@array_subs

; 2204 :         Py_ssize_t start, stop, step, slicelength, cur, i;
; 2205 :         PyObject* result;
; 2206 :         arrayobject* ar;
; 2207 :         int itemsize = self->ob_descr->itemsize;

  0007c	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]

; 2208 : 
; 2209 :         if (PySlice_GetIndicesEx(item, Py_SIZE(self),
; 2210 :                          &start, &stop, &step, &slicelength) < 0) {

  00083	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]
  00087	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  0008c	4c 63 60 04	 movsxd	 r12, DWORD PTR [rax+4]
  00090	48 8d 44 24 78	 lea	 rax, QWORD PTR slicelength$22078[rsp]
  00095	4c 8d 4c 24 30	 lea	 r9, QWORD PTR stop$22076[rsp]
  0009a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0009f	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR step$22077[rsp]
  000a7	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR start$22075[rsp]
  000af	49 8b ca	 mov	 rcx, r10
  000b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b7	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  000bc	85 c0		 test	 eax, eax

; 2211 :             return NULL;

  000be	78 43		 js	 SHORT $LN24@array_subs

; 2212 :         }
; 2213 : 
; 2214 :         if (slicelength <= 0) {

  000c0	48 8b 54 24 78	 mov	 rdx, QWORD PTR slicelength$22078[rsp]

; 2215 :             return newarrayobject(&Arraytype, 0, self->ob_descr);

  000c5	4c 8b 87 80 00
	00 00		 mov	 r8, QWORD PTR [rdi+128]
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Arraytype
  000d3	48 85 d2	 test	 rdx, rdx
  000d6	7f 13		 jg	 SHORT $LN10@array_subs
  000d8	33 d2		 xor	 edx, edx
  000da	e8 00 00 00 00	 call	 newarrayobject
  000df	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]

; 2247 :     }
; 2248 : }

  000e4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e8	5f		 pop	 rdi
  000e9	5b		 pop	 rbx
  000ea	c3		 ret	 0
$LN10@array_subs:

; 2216 :         }
; 2217 :         else if (step == 1) {

  000eb	48 83 bc 24 88
	00 00 00 01	 cmp	 QWORD PTR step$22077[rsp], 1
  000f4	75 4c		 jne	 SHORT $LN8@array_subs

; 2218 :             PyObject *result = newarrayobject(&Arraytype,
; 2219 :                                     slicelength, self->ob_descr);

  000f6	e8 00 00 00 00	 call	 newarrayobject
  000fb	48 8b d8	 mov	 rbx, rax

; 2220 :             if (result == NULL)

  000fe	48 85 c0	 test	 rax, rax
  00101	75 0e		 jne	 SHORT $LN7@array_subs
$LN24@array_subs:

; 2221 :                 return NULL;

  00103	33 c0		 xor	 eax, eax
  00105	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]

; 2247 :     }
; 2248 : }

  0010a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0010e	5f		 pop	 rdi
  0010f	5b		 pop	 rbx
  00110	c3		 ret	 0
$LN7@array_subs:

; 2222 :             memcpy(((arrayobject *)result)->ob_item,
; 2223 :                    self->ob_item + start * itemsize,
; 2224 :                    slicelength * itemsize);

  00111	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00115	49 8b d4	 mov	 rdx, r12
  00118	4d 8b c4	 mov	 r8, r12
  0011b	48 0f af 94 24
	80 00 00 00	 imul	 rdx, QWORD PTR start$22075[rsp]
  00124	4c 0f af 44 24
	78		 imul	 r8, QWORD PTR slicelength$22078[rsp]
  0012a	48 03 57 70	 add	 rdx, QWORD PTR [rdi+112]
  0012e	e8 00 00 00 00	 call	 memcpy
  00133	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]

; 2225 :             return result;

  00138	48 8b c3	 mov	 rax, rbx

; 2247 :     }
; 2248 : }

  0013b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0013f	5f		 pop	 rdi
  00140	5b		 pop	 rbx
  00141	c3		 ret	 0
$LN8@array_subs:
  00142	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi

; 2226 :         }
; 2227 :         else {
; 2228 :             result = newarrayobject(&Arraytype, slicelength, self->ob_descr);

  00147	e8 00 00 00 00	 call	 newarrayobject
  0014c	48 8b f0	 mov	 rsi, rax

; 2229 :             if (!result) return NULL;

  0014f	48 85 c0	 test	 rax, rax
  00152	75 11		 jne	 SHORT $LN5@array_subs
  00154	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00159	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]

; 2247 :     }
; 2248 : }

  0015e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00162	5f		 pop	 rdi
  00163	5b		 pop	 rbx
  00164	c3		 ret	 0
$LN5@array_subs:

; 2230 : 
; 2231 :             ar = (arrayobject*)result;
; 2232 : 
; 2233 :             for (cur = start, i = 0; i < slicelength;
; 2234 :                  cur += step, i++) {

  00165	33 db		 xor	 ebx, ebx
  00167	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  0016c	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR start$22075[rsp]
  00174	48 39 5c 24 78	 cmp	 QWORD PTR slicelength$22078[rsp], rbx
  00179	7e 4b		 jle	 SHORT $LN2@array_subs
  0017b	4c 89 6c 24 40	 mov	 QWORD PTR [rsp+64], r13
  00180	44 8b eb	 mov	 r13d, ebx
  00183	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL4@array_subs:

; 2235 :                 memcpy(ar->ob_item + i*itemsize,
; 2236 :                        self->ob_item + cur*itemsize,
; 2237 :                        itemsize);

  00190	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  00194	49 8b d4	 mov	 rdx, r12
  00197	4d 8b c4	 mov	 r8, r12
  0019a	49 8d 4c 05 00	 lea	 rcx, QWORD PTR [r13+rax]
  0019f	48 0f af d5	 imul	 rdx, rbp
  001a3	48 03 57 70	 add	 rdx, QWORD PTR [rdi+112]
  001a7	e8 00 00 00 00	 call	 memcpy
  001ac	48 03 ac 24 88
	00 00 00	 add	 rbp, QWORD PTR step$22077[rsp]
  001b4	48 ff c3	 inc	 rbx
  001b7	4d 03 ec	 add	 r13, r12
  001ba	48 3b 5c 24 78	 cmp	 rbx, QWORD PTR slicelength$22078[rsp]
  001bf	7c cf		 jl	 SHORT $LL4@array_subs
  001c1	4c 8b 6c 24 40	 mov	 r13, QWORD PTR [rsp+64]
$LN2@array_subs:
  001c6	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  001cb	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]

; 2238 :             }
; 2239 : 
; 2240 :             return result;

  001d0	48 8b c6	 mov	 rax, rsi
  001d3	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 2247 :     }
; 2248 : }

  001d8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001dc	5f		 pop	 rdi
  001dd	5b		 pop	 rbx
  001de	c3		 ret	 0
$LN12@array_subs:

; 2241 :         }
; 2242 :     }
; 2243 :     else {
; 2244 :         PyErr_SetString(PyExc_TypeError,
; 2245 :                         "array indices must be integers");

  001df	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@MJNNCJGL@array?5indices?5must?5be?5integers?$AA@
  001ed	e8 00 00 00 00	 call	 PyErr_SetString

; 2246 :         return NULL;

  001f2	33 c0		 xor	 eax, eax

; 2247 :     }
; 2248 : }

  001f4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001f8	5f		 pop	 rdi
  001f9	5b		 pop	 rbx
  001fa	c3		 ret	 0
array_subscr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@BIAFMNPF@array?5indices?5must?5be?5integer?$AA@ ; `string'
PUBLIC	??_C@_0EC@CKGLHKPA@attempt?5to?5assign?5array?5of?5size?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_ass_subscr DD imagerel array_ass_subscr
	DD	imagerel array_ass_subscr+1263
	DD	imagerel $unwind$array_ass_subscr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_ass_subscr DD 060f01H
	DD	010340fH
	DD	07008b20fH
	DD	050066007H
xdata	ENDS
;	COMDAT ??_C@_0BO@BIAFMNPF@array?5indices?5must?5be?5integer?$AA@
CONST	SEGMENT
??_C@_0BO@BIAFMNPF@array?5indices?5must?5be?5integer?$AA@ DB 'array indic'
	DB	'es must be integer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@CKGLHKPA@attempt?5to?5assign?5array?5of?5size?5@
CONST	SEGMENT
??_C@_0EC@CKGLHKPA@attempt?5to?5assign?5array?5of?5size?5@ DB 'attempt to'
	DB	' assign array of size %zd to extended slice of size %zd', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_ass_subscr
_TEXT	SEGMENT
slicelength$ = 48
tv531 = 56
other$1$ = 56
stop$ = 64
step$ = 72
tv520 = 80
needed$1$ = 80
self$ = 128
itemsize$1$ = 136
item$ = 136
value$ = 144
start$ = 152
array_ass_subscr PROC					; COMDAT

; 2252 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 8b ec	 mov	 rbp, rsp
  0000b	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000f	48 8b f9	 mov	 rdi, rcx

; 2253 :     Py_ssize_t start, stop, step, slicelength, needed;
; 2254 :     arrayobject* other;
; 2255 :     int itemsize;
; 2256 : 
; 2257 :     if (PyIndex_Check(item)) {

  00012	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00016	33 f6		 xor	 esi, esi
  00018	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]
  0001f	4c 89 45 d8	 mov	 QWORD PTR other$1$[rbp-96], r8
  00023	48 8b da	 mov	 rbx, rdx
  00026	48 85 c0	 test	 rax, rax
  00029	0f 84 b3 00 00
	00		 je	 $LN45@array_ass_@3
  0002f	48 39 b0 08 01
	00 00		 cmp	 QWORD PTR [rax+264], rsi
  00036	0f 84 a6 00 00
	00		 je	 $LN45@array_ass_@3

; 2258 :         Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);

  0003c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  00043	48 8b cb	 mov	 rcx, rbx
  00046	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  0004b	48 8b d8	 mov	 rbx, rax

; 2259 : 
; 2260 :         if (i == -1 && PyErr_Occurred())

  0004e	48 83 f8 ff	 cmp	 rax, -1
  00052	75 0f		 jne	 SHORT $LN44@array_ass_@3
  00054	e8 00 00 00 00	 call	 PyErr_Occurred
  00059	48 85 c0	 test	 rax, rax
  0005c	74 0a		 je	 SHORT $LN53@array_ass_@3

; 2261 :             return -1;

  0005e	e9 79 04 00 00	 jmp	 $LN58@array_ass_@3
$LN44@array_ass_@3:

; 2262 :         if (i < 0)

  00063	48 85 c0	 test	 rax, rax
  00066	79 06		 jns	 SHORT $LN52@array_ass_@3
$LN53@array_ass_@3:

; 2263 :             i += Py_SIZE(self);

  00068	48 03 5f 60	 add	 rbx, QWORD PTR [rdi+96]

; 2264 :         if (i < 0 || i >= Py_SIZE(self)) {

  0006c	78 61		 js	 SHORT $LN41@array_ass_@3
$LN52@array_ass_@3:
  0006e	48 3b 5f 60	 cmp	 rbx, QWORD PTR [rdi+96]
  00072	7d 5b		 jge	 SHORT $LN41@array_ass_@3

; 2268 :         }
; 2269 :         if (value == NULL) {

  00074	48 8b 55 d8	 mov	 rdx, QWORD PTR other$1$[rbp-96]
  00078	48 85 d2	 test	 rdx, rdx
  0007b	75 2f		 jne	 SHORT $LN40@array_ass_@3

; 2270 :             /* Fall through to slice assignment */
; 2271 :             start = i;
; 2272 :             stop = i + 1;
; 2273 :             step = 1;

  0007d	ba 01 00 00 00	 mov	 edx, 1
  00082	4c 8d 5b 01	 lea	 r11, QWORD PTR [rbx+1]

; 2292 :         other = NULL;

  00086	48 8b ce	 mov	 rcx, rsi
  00089	48 89 5d 38	 mov	 QWORD PTR start$[rbp-96], rbx

; 2293 :         needed = 0;

  0008d	4c 8b d6	 mov	 r10, rsi
  00090	48 89 75 f0	 mov	 QWORD PTR needed$1$[rbp-96], rsi
  00094	4c 89 5d e0	 mov	 QWORD PTR stop$[rbp-96], r11
  00098	48 89 55 e8	 mov	 QWORD PTR step$[rbp-96], rdx
  0009c	44 8b c2	 mov	 r8d, edx
  0009f	48 89 55 d0	 mov	 QWORD PTR slicelength$[rbp-96], rdx
  000a3	48 89 4d d8	 mov	 QWORD PTR other$1$[rbp-96], rcx
  000a7	e9 5b 01 00 00	 jmp	 $LN28@array_ass_@3
$LN40@array_ass_@3:

; 2274 :             slicelength = 1;
; 2275 :         }
; 2276 :         else
; 2277 :             return (*self->ob_descr->setitem)(self, i, value);

  000ac	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  000b3	4c 8b c2	 mov	 r8, rdx
  000b6	48 8b cf	 mov	 rcx, rdi
  000b9	48 8b d3	 mov	 rdx, rbx
  000bc	ff 50 10	 call	 QWORD PTR [rax+16]

; 2403 :     }
; 2404 : }

  000bf	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  000c7	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000cb	5f		 pop	 rdi
  000cc	5e		 pop	 rsi
  000cd	5d		 pop	 rbp
  000ce	c3		 ret	 0
$LN41@array_ass_@3:

; 2265 :             PyErr_SetString(PyExc_IndexError,
; 2266 :                 "array assignment index out of range");

  000cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@DDILIBCI@array?5assignment?5index?5out?5of?5ra@

; 2267 :             return -1;

  000dd	e9 f5 03 00 00	 jmp	 $LN59@array_ass_@3
$LN45@array_ass_@3:

; 2278 :     }
; 2279 :     else if (PySlice_Check(item)) {

  000e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  000e9	48 3b c8	 cmp	 rcx, rax
  000ec	0f 85 d7 03 00
	00		 jne	 $LN37@array_ass_@3

; 2280 :         if (PySlice_GetIndicesEx(item,
; 2281 :                                  Py_SIZE(self), &start, &stop,
; 2282 :                                  &step, &slicelength) < 0) {

  000f2	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]
  000f6	48 8d 45 d0	 lea	 rax, QWORD PTR slicelength$[rbp-96]
  000fa	4c 8d 4d e0	 lea	 r9, QWORD PTR stop$[rbp-96]
  000fe	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00103	48 8d 45 e8	 lea	 rax, QWORD PTR step$[rbp-96]
  00107	4c 8d 45 38	 lea	 r8, QWORD PTR start$[rbp-96]
  0010b	48 8b cb	 mov	 rcx, rbx
  0010e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00113	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  00118	85 c0		 test	 eax, eax

; 2283 :             return -1;

  0011a	0f 88 bc 03 00
	00		 js	 $LN58@array_ass_@3

; 2290 :     }
; 2291 :     if (value == NULL) {

  00120	48 8b 4d d8	 mov	 rcx, QWORD PTR other$1$[rbp-96]
  00124	48 85 c9	 test	 rcx, rcx
  00127	75 23		 jne	 SHORT $LN34@array_ass_@3
  00129	48 8b 5d 38	 mov	 rbx, QWORD PTR start$[rbp-96]
  0012d	4c 8b 5d e0	 mov	 r11, QWORD PTR stop$[rbp-96]
  00131	48 8b 55 e8	 mov	 rdx, QWORD PTR step$[rbp-96]
  00135	4c 8b 45 d0	 mov	 r8, QWORD PTR slicelength$[rbp-96]

; 2292 :         other = NULL;

  00139	48 8b ce	 mov	 rcx, rsi

; 2293 :         needed = 0;

  0013c	4c 8b d6	 mov	 r10, rsi
  0013f	48 89 4d d8	 mov	 QWORD PTR other$1$[rbp-96], rcx
  00143	48 89 75 f0	 mov	 QWORD PTR needed$1$[rbp-96], rsi
  00147	e9 bb 00 00 00	 jmp	 $LN28@array_ass_@3
$LN34@array_ass_@3:

; 2294 :     }
; 2295 :     else if (array_Check(value)) {

  0014c	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  00157	48 3b c2	 cmp	 rax, rdx
  0015a	74 34		 je	 SHORT $LN31@array_ass_@3
  0015c	48 8b c8	 mov	 rcx, rax
  0015f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00164	85 c0		 test	 eax, eax
  00166	75 24		 jne	 SHORT $LN57@array_ass_@3

; 2311 :         }
; 2312 :     }
; 2313 :     else {
; 2314 :         PyErr_Format(PyExc_TypeError,
; 2315 :          "can only assign array (not \"%.200s\") to array slice",
; 2316 :                          Py_TYPE(value)->tp_name);

  00168	48 8b 55 d8	 mov	 rdx, QWORD PTR other$1$[rbp-96]
  0016c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00173	4c 8b 42 58	 mov	 r8, QWORD PTR [rdx+88]
  00177	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@JBAHFOA@can?5only?5assign?5array?5?$CInot?5?$CC?$CF?420@
  0017e	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00182	e8 00 00 00 00	 call	 PyErr_Format

; 2317 :         return -1;

  00187	e9 50 03 00 00	 jmp	 $LN58@array_ass_@3
$LN57@array_ass_@3:

; 2395 :         }
; 2396 :         for (cur = start, i = 0; i < slicelength;
; 2397 :              cur += step, i++) {

  0018c	48 8b 4d d8	 mov	 rcx, QWORD PTR other$1$[rbp-96]
$LN31@array_ass_@3:

; 2296 :         other = (arrayobject *)value;
; 2297 :         needed = Py_SIZE(other);

  00190	4c 8b 51 60	 mov	 r10, QWORD PTR [rcx+96]
  00194	4c 89 55 f0	 mov	 QWORD PTR needed$1$[rbp-96], r10

; 2298 :         if (self == other) {

  00198	48 3b f9	 cmp	 rdi, rcx
  0019b	75 40		 jne	 SHORT $LN30@array_ass_@3

; 2299 :             /* Special case "self[i:j] = self" -- copy self first */
; 2300 :             int ret;
; 2301 :             value = array_slice(other, 0, needed);

  0019d	4d 8b c2	 mov	 r8, r10
  001a0	33 d2		 xor	 edx, edx
  001a2	e8 00 00 00 00	 call	 array_slice
  001a7	48 8b f0	 mov	 rsi, rax

; 2302 :             if (value == NULL)

  001aa	48 85 c0	 test	 rax, rax

; 2303 :                 return -1;

  001ad	0f 84 29 03 00
	00		 je	 $LN58@array_ass_@3

; 2304 :             ret = array_ass_subscr(self, item, value);

  001b3	4c 8b c0	 mov	 r8, rax
  001b6	48 8b d3	 mov	 rdx, rbx
  001b9	48 8b cf	 mov	 rcx, rdi
  001bc	e8 00 00 00 00	 call	 array_ass_subscr

; 2305 :             Py_DECREF(value);

  001c1	48 8b ce	 mov	 rcx, rsi
  001c4	8b d8		 mov	 ebx, eax
  001c6	e8 00 00 00 00	 call	 _Py_DecRef

; 2306 :             return ret;

  001cb	8b c3		 mov	 eax, ebx

; 2403 :     }
; 2404 : }

  001cd	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  001d5	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001d9	5f		 pop	 rdi
  001da	5e		 pop	 rsi
  001db	5d		 pop	 rbp
  001dc	c3		 ret	 0
$LN30@array_ass_@3:

; 2307 :         }
; 2308 :         if (other->ob_descr != self->ob_descr) {

  001dd	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  001e4	48 39 81 80 00
	00 00		 cmp	 QWORD PTR [rcx+128], rax
  001eb	74 0a		 je	 SHORT $LN55@array_ass_@3

; 2309 :             PyErr_BadArgument();

  001ed	e8 00 00 00 00	 call	 PyErr_BadArgument

; 2310 :             return -1;

  001f2	e9 e5 02 00 00	 jmp	 $LN58@array_ass_@3
$LN55@array_ass_@3:
  001f7	48 8b 5d 38	 mov	 rbx, QWORD PTR start$[rbp-96]
  001fb	4c 8b 5d e0	 mov	 r11, QWORD PTR stop$[rbp-96]
  001ff	48 8b 55 e8	 mov	 rdx, QWORD PTR step$[rbp-96]
  00203	4c 8b 45 d0	 mov	 r8, QWORD PTR slicelength$[rbp-96]
$LN28@array_ass_@3:

; 2318 :     }
; 2319 :     itemsize = self->ob_descr->itemsize;

  00207	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  0020e	4c 63 48 04	 movsxd	 r9, DWORD PTR [rax+4]
  00212	44 89 4d 28	 mov	 DWORD PTR itemsize$1$[rbp-96], r9d

; 2320 :     /* for 'a[2:1] = ...', the insertion point is 'start', not 'stop' */
; 2321 :     if ((step > 0 && stop < start) ||
; 2322 :         (step < 0 && stop > start))

  00216	48 85 d2	 test	 rdx, rdx
  00219	7e 08		 jle	 SHORT $LN60@array_ass_@3
  0021b	4c 3b db	 cmp	 r11, rbx
  0021e	7c 0a		 jl	 SHORT $LN25@array_ass_@3
  00220	48 85 d2	 test	 rdx, rdx
$LN60@array_ass_@3:
  00223	79 0c		 jns	 SHORT $LN26@array_ass_@3
  00225	4c 3b db	 cmp	 r11, rbx
  00228	7e 07		 jle	 SHORT $LN26@array_ass_@3
$LN25@array_ass_@3:

; 2323 :         stop = start;

  0022a	4c 8b db	 mov	 r11, rbx
  0022d	48 89 5d e0	 mov	 QWORD PTR stop$[rbp-96], rbx
$LN26@array_ass_@3:

; 2324 : 
; 2325 :     /* Issue #4509: If the array has exported buffers and the slice
; 2326 :        assignment would change the size of the array, fail early to make
; 2327 :        sure we don't modify it. */
; 2328 :     if ((needed == 0 || slicelength != needed) && self->ob_exports > 0) {

  00231	4d 85 d2	 test	 r10, r10
  00234	74 05		 je	 SHORT $LN22@array_ass_@3
  00236	4d 3b c2	 cmp	 r8, r10
  00239	74 1b		 je	 SHORT $LN23@array_ass_@3
$LN22@array_ass_@3:
  0023b	39 b7 90 00 00
	00		 cmp	 DWORD PTR [rdi+144], esi
  00241	7e 13		 jle	 SHORT $LN23@array_ass_@3

; 2329 :         PyErr_SetString(PyExc_BufferError,
; 2330 :             "cannot resize an array that is exporting buffers");

  00243	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  0024a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@GJKGCBFK@cannot?5resize?5an?5array?5that?5is?5e@

; 2331 :         return -1;

  00251	e9 81 02 00 00	 jmp	 $LN59@array_ass_@3
$LN23@array_ass_@3:

; 2332 :     }
; 2333 : 
; 2334 :     if (step == 1) {

  00256	48 83 fa 01	 cmp	 rdx, 1
  0025a	0f 85 e7 00 00
	00		 jne	 $LN21@array_ass_@3

; 2335 :         if (slicelength > needed) {

  00260	4d 3b c2	 cmp	 r8, r10
  00263	7e 4b		 jle	 SHORT $LN61@array_ass_@3

; 2336 :             memmove(self->ob_item + (start + needed) * itemsize,
; 2337 :                 self->ob_item + stop * itemsize,
; 2338 :                 (Py_SIZE(self) - stop) * itemsize);

  00265	4c 8b 47 60	 mov	 r8, QWORD PTR [rdi+96]
  00269	49 8b c1	 mov	 rax, r9
  0026c	4c 8b 4f 70	 mov	 r9, QWORD PTR [rdi+112]
  00270	49 8d 0c 1a	 lea	 rcx, QWORD PTR [r10+rbx]
  00274	48 8b d0	 mov	 rdx, rax
  00277	4d 2b c3	 sub	 r8, r11
  0027a	49 0f af d3	 imul	 rdx, r11
  0027e	4c 0f af c0	 imul	 r8, rax
  00282	49 03 d1	 add	 rdx, r9
  00285	48 0f af c8	 imul	 rcx, rax
  00289	49 03 c9	 add	 rcx, r9
  0028c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 2339 :             if (array_resize(self, Py_SIZE(self) +
; 2340 :                 needed - slicelength) < 0)

  00292	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]
  00296	48 8b cf	 mov	 rcx, rdi
  00299	48 2b 55 d0	 sub	 rdx, QWORD PTR slicelength$[rbp-96]
  0029d	48 03 55 f0	 add	 rdx, QWORD PTR needed$1$[rbp-96]
  002a1	e8 00 00 00 00	 call	 array_resize
  002a6	85 c0		 test	 eax, eax

; 2341 :                 return -1;

  002a8	0f 88 2e 02 00
	00		 js	 $LN58@array_ass_@3

; 2347 :             memmove(self->ob_item + (start + needed) * itemsize,
; 2348 :                 self->ob_item + stop * itemsize,
; 2349 :                 (Py_SIZE(self) - start - needed) * itemsize);

  002ae	eb 55		 jmp	 SHORT $LN62@array_ass_@3
$LN61@array_ass_@3:

; 2342 :         }
; 2343 :         else if (slicelength < needed) {

  002b0	7d 5f		 jge	 SHORT $LN17@array_ass_@3

; 2344 :             if (array_resize(self, Py_SIZE(self) +
; 2345 :                 needed - slicelength) < 0)

  002b2	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]
  002b6	48 8b cf	 mov	 rcx, rdi
  002b9	49 2b d0	 sub	 rdx, r8
  002bc	49 03 d2	 add	 rdx, r10
  002bf	e8 00 00 00 00	 call	 array_resize
  002c4	85 c0		 test	 eax, eax

; 2346 :                 return -1;

  002c6	0f 88 10 02 00
	00		 js	 $LN58@array_ass_@3

; 2347 :             memmove(self->ob_item + (start + needed) * itemsize,
; 2348 :                 self->ob_item + stop * itemsize,
; 2349 :                 (Py_SIZE(self) - start - needed) * itemsize);

  002cc	4c 63 4d 28	 movsxd	 r9, DWORD PTR itemsize$1$[rbp-96]
  002d0	48 8b 45 38	 mov	 rax, QWORD PTR start$[rbp-96]
  002d4	4c 8b 57 70	 mov	 r10, QWORD PTR [rdi+112]
  002d8	4c 8b 47 60	 mov	 r8, QWORD PTR [rdi+96]
  002dc	48 8b 4d f0	 mov	 rcx, QWORD PTR needed$1$[rbp-96]
  002e0	49 8b d1	 mov	 rdx, r9
  002e3	48 0f af 55 e0	 imul	 rdx, QWORD PTR stop$[rbp-96]
  002e8	4c 2b c1	 sub	 r8, rcx
  002eb	48 03 c8	 add	 rcx, rax
  002ee	49 03 d2	 add	 rdx, r10
  002f1	4c 2b c0	 sub	 r8, rax
  002f4	49 0f af c9	 imul	 rcx, r9
  002f8	49 03 ca	 add	 rcx, r10
  002fb	4d 0f af c1	 imul	 r8, r9
  002ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN62@array_ass_@3:
  00305	44 8b 4d 28	 mov	 r9d, DWORD PTR itemsize$1$[rbp-96]
  00309	4c 8b 55 f0	 mov	 r10, QWORD PTR needed$1$[rbp-96]
  0030d	48 8b 5d 38	 mov	 rbx, QWORD PTR start$[rbp-96]
$LN17@array_ass_@3:

; 2350 :         }
; 2351 :         if (needed > 0)

  00311	4d 85 d2	 test	 r10, r10
  00314	7e 1f		 jle	 SHORT $LN15@array_ass_@3

; 2352 :             memcpy(self->ob_item + start * itemsize,
; 2353 :                    other->ob_item, needed * itemsize);

  00316	48 8b 55 d8	 mov	 rdx, QWORD PTR other$1$[rbp-96]
  0031a	49 63 c9	 movsxd	 rcx, r9d
  0031d	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00321	4c 8b c1	 mov	 r8, rcx
  00324	48 0f af cb	 imul	 rcx, rbx
  00328	48 03 4f 70	 add	 rcx, QWORD PTR [rdi+112]
  0032c	4d 0f af c2	 imul	 r8, r10
  00330	e8 00 00 00 00	 call	 memcpy
$LN15@array_ass_@3:

; 2354 :         return 0;

  00335	33 c0		 xor	 eax, eax

; 2403 :     }
; 2404 : }

  00337	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  0033f	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00343	5f		 pop	 rdi
  00344	5e		 pop	 rsi
  00345	5d		 pop	 rbp
  00346	c3		 ret	 0
$LN21@array_ass_@3:

; 2355 :     }
; 2356 :     else if (needed == 0) {

  00347	4d 85 d2	 test	 r10, r10
  0034a	0f 85 fa 00 00
	00		 jne	 $LN13@array_ass_@3

; 2357 :         /* Delete slice */
; 2358 :         size_t cur;
; 2359 :         Py_ssize_t i;
; 2360 : 
; 2361 :         if (step < 0) {

  00350	48 85 d2	 test	 rdx, rdx
  00353	79 20		 jns	 SHORT $LN12@array_ass_@3

; 2362 :             stop = start + 1;

  00355	48 8d 4b 01	 lea	 rcx, QWORD PTR [rbx+1]

; 2363 :             start = stop + step * (slicelength - 1) - 1;

  00359	49 8d 40 ff	 lea	 rax, QWORD PTR [r8-1]
  0035d	48 89 4d e0	 mov	 QWORD PTR stop$[rbp-96], rcx
  00361	48 0f af c2	 imul	 rax, rdx
  00365	48 8d 5c 08 ff	 lea	 rbx, QWORD PTR [rax+rcx-1]

; 2364 :             step = -step;

  0036a	48 f7 da	 neg	 rdx
  0036d	48 89 5d 38	 mov	 QWORD PTR start$[rbp-96], rbx
  00371	48 89 55 e8	 mov	 QWORD PTR step$[rbp-96], rdx
$LN12@array_ass_@3:

; 2365 :         }
; 2366 :         for (cur = start, i = 0; i < slicelength;
; 2367 :              cur += step, i++) {

  00375	4d 85 c0	 test	 r8, r8
  00378	7e 66		 jle	 SHORT $LN9@array_ass_@3
  0037a	4c 89 4d d8	 mov	 QWORD PTR tv531[rbp-96], r9
  0037e	66 90		 npad	 2
$LL11@array_ass_@3:

; 2368 :             Py_ssize_t lim = step - 1;
; 2369 : 
; 2370 :             if (cur + step >= (size_t)Py_SIZE(self))

  00380	4c 8b 47 60	 mov	 r8, QWORD PTR [rdi+96]
  00384	48 8d 04 13	 lea	 rax, QWORD PTR [rbx+rdx]
  00388	48 8d 4a ff	 lea	 rcx, QWORD PTR [rdx-1]
  0038c	49 3b c0	 cmp	 rax, r8
  0038f	72 09		 jb	 SHORT $LN8@array_ass_@3

; 2371 :                 lim = Py_SIZE(self) - cur - 1;

  00391	49 8b c8	 mov	 rcx, r8
  00394	48 2b cb	 sub	 rcx, rbx
  00397	48 ff c9	 dec	 rcx
$LN8@array_ass_@3:

; 2372 :             memmove(self->ob_item + (cur - i) * itemsize,
; 2373 :                 self->ob_item + (cur + 1) * itemsize,
; 2374 :                 lim * itemsize);

  0039a	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  0039e	4d 8b c1	 mov	 r8, r9
  003a1	48 8d 53 01	 lea	 rdx, QWORD PTR [rbx+1]
  003a5	4c 0f af c1	 imul	 r8, rcx
  003a9	48 8b cb	 mov	 rcx, rbx
  003ac	48 2b ce	 sub	 rcx, rsi
  003af	49 0f af d1	 imul	 rdx, r9
  003b3	48 03 d0	 add	 rdx, rax
  003b6	49 0f af c9	 imul	 rcx, r9
  003ba	48 03 c8	 add	 rcx, rax
  003bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
  003c3	48 8b 55 e8	 mov	 rdx, QWORD PTR step$[rbp-96]
  003c7	4c 8b 45 d0	 mov	 r8, QWORD PTR slicelength$[rbp-96]
  003cb	4c 8b 4d d8	 mov	 r9, QWORD PTR tv531[rbp-96]
  003cf	48 ff c6	 inc	 rsi
  003d2	48 03 da	 add	 rbx, rdx
  003d5	49 3b f0	 cmp	 rsi, r8
  003d8	7c a6		 jl	 SHORT $LL11@array_ass_@3

; 2365 :         }
; 2366 :         for (cur = start, i = 0; i < slicelength;
; 2367 :              cur += step, i++) {

  003da	48 8b 5d 38	 mov	 rbx, QWORD PTR start$[rbp-96]
  003de	33 f6		 xor	 esi, esi
$LN9@array_ass_@3:

; 2375 :         }
; 2376 :         cur = start + (size_t)slicelength * step;
; 2377 :         if (cur < (size_t)Py_SIZE(self)) {

  003e0	4c 8b 57 60	 mov	 r10, QWORD PTR [rdi+96]
  003e4	49 8b c8	 mov	 rcx, r8
  003e7	48 0f af ca	 imul	 rcx, rdx
  003eb	48 03 cb	 add	 rcx, rbx
  003ee	49 3b ca	 cmp	 rcx, r10
  003f1	73 2f		 jae	 SHORT $LN7@array_ass_@3

; 2378 :             memmove(self->ob_item + (cur-slicelength) * itemsize,
; 2379 :                 self->ob_item + cur * itemsize,
; 2380 :                 (Py_SIZE(self) - cur) * itemsize);

  003f3	49 63 c1	 movsxd	 rax, r9d
  003f6	4c 8b 4f 70	 mov	 r9, QWORD PTR [rdi+112]
  003fa	4c 2b d1	 sub	 r10, rcx
  003fd	48 8b d0	 mov	 rdx, rax
  00400	4c 0f af d0	 imul	 r10, rax
  00404	48 0f af d1	 imul	 rdx, rcx
  00408	49 2b c8	 sub	 rcx, r8
  0040b	4d 8b c2	 mov	 r8, r10
  0040e	48 0f af c8	 imul	 rcx, rax
  00412	49 03 d1	 add	 rdx, r9
  00415	49 03 c9	 add	 rcx, r9
  00418	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
  0041e	4c 8b 45 d0	 mov	 r8, QWORD PTR slicelength$[rbp-96]
$LN7@array_ass_@3:

; 2381 :         }
; 2382 :         if (array_resize(self, Py_SIZE(self) - slicelength) < 0)

  00422	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]
  00426	48 8b cf	 mov	 rcx, rdi
  00429	49 2b d0	 sub	 rdx, r8
  0042c	e8 00 00 00 00	 call	 array_resize
  00431	85 c0		 test	 eax, eax
  00433	40 0f 99 c6	 setns	 sil
  00437	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]

; 2403 :     }
; 2404 : }

  0043a	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  00442	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00446	5f		 pop	 rdi
  00447	5e		 pop	 rsi
  00448	5d		 pop	 rbp
  00449	c3		 ret	 0
$LN13@array_ass_@3:

; 2383 :             return -1;
; 2384 :         return 0;
; 2385 :     }
; 2386 :     else {
; 2387 :         Py_ssize_t cur, i;
; 2388 : 
; 2389 :         if (needed != slicelength) {

  0044a	4d 3b d0	 cmp	 r10, r8
  0044d	74 1b		 je	 SHORT $LN4@array_ass_@3

; 2390 :             PyErr_Format(PyExc_ValueError,
; 2391 :                 "attempt to assign array of size %zd "
; 2392 :                 "to extended slice of size %zd",
; 2393 :                 needed, slicelength);

  0044f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00456	4d 8b c8	 mov	 r9, r8
  00459	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@CKGLHKPA@attempt?5to?5assign?5array?5of?5size?5@
  00460	4d 8b c2	 mov	 r8, r10
  00463	e8 00 00 00 00	 call	 PyErr_Format

; 2394 :             return -1;

  00468	eb 72		 jmp	 SHORT $LN58@array_ass_@3
$LN4@array_ass_@3:

; 2395 :         }
; 2396 :         for (cur = start, i = 0; i < slicelength;
; 2397 :              cur += step, i++) {

  0046a	4d 85 c0	 test	 r8, r8
  0046d	7e 48		 jle	 SHORT $LN1@array_ass_@3
  0046f	48 8b d6	 mov	 rdx, rsi
  00472	4d 8b c1	 mov	 r8, r9
  00475	48 89 55 f0	 mov	 QWORD PTR tv520[rbp-96], rdx
  00479	0f 1f 80 00 00
	00 00		 npad	 7
$LL3@array_ass_@3:

; 2398 :             memcpy(self->ob_item + cur * itemsize,
; 2399 :                    other->ob_item + i * itemsize,
; 2400 :                    itemsize);

  00480	48 03 51 70	 add	 rdx, QWORD PTR [rcx+112]
  00484	49 8b c8	 mov	 rcx, r8
  00487	48 0f af cb	 imul	 rcx, rbx
  0048b	48 03 4f 70	 add	 rcx, QWORD PTR [rdi+112]
  0048f	e8 00 00 00 00	 call	 memcpy
  00494	48 63 45 28	 movsxd	 rax, DWORD PTR itemsize$1$[rbp-96]
  00498	48 8b 55 f0	 mov	 rdx, QWORD PTR tv520[rbp-96]
  0049c	48 03 5d e8	 add	 rbx, QWORD PTR step$[rbp-96]
  004a0	48 8b 4d d8	 mov	 rcx, QWORD PTR other$1$[rbp-96]
  004a4	48 03 d0	 add	 rdx, rax
  004a7	48 ff c6	 inc	 rsi
  004aa	48 89 55 f0	 mov	 QWORD PTR tv520[rbp-96], rdx
  004ae	4c 8b c0	 mov	 r8, rax
  004b1	48 3b 75 d0	 cmp	 rsi, QWORD PTR slicelength$[rbp-96]
  004b5	7c c9		 jl	 SHORT $LL3@array_ass_@3
$LN1@array_ass_@3:

; 2401 :         }
; 2402 :         return 0;

  004b7	33 c0		 xor	 eax, eax

; 2403 :     }
; 2404 : }

  004b9	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  004c1	48 83 c4 60	 add	 rsp, 96			; 00000060H
  004c5	5f		 pop	 rdi
  004c6	5e		 pop	 rsi
  004c7	5d		 pop	 rbp
  004c8	c3		 ret	 0
$LN37@array_ass_@3:

; 2284 :         }
; 2285 :     }
; 2286 :     else {
; 2287 :         PyErr_SetString(PyExc_TypeError,
; 2288 :                         "array indices must be integer");

  004c9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  004d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@BIAFMNPF@array?5indices?5must?5be?5integer?$AA@
$LN59@array_ass_@3:
  004d7	e8 00 00 00 00	 call	 PyErr_SetString
$LN58@array_ass_@3:

; 2289 :         return -1;

  004dc	83 c8 ff	 or	 eax, -1

; 2403 :     }
; 2404 : }

  004df	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  004e7	48 83 c4 60	 add	 rsp, 96			; 00000060H
  004eb	5f		 pop	 rdi
  004ec	5e		 pop	 rsi
  004ed	5d		 pop	 rbp
  004ee	c3		 ret	 0
array_ass_subscr ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$array_buffer_getbuf DD imagerel array_buffer_getbuf
	DD	imagerel array_buffer_getbuf+264
	DD	imagerel $unwind$array_buffer_getbuf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_buffer_getbuf DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
xdata	ENDS
;	COMDAT array_buffer_getbuf
_TEXT	SEGMENT
self$ = 64
view$ = 72
flags$ = 80
array_buffer_getbuf PROC				; COMDAT

; 2417 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	41 8b f0	 mov	 esi, r8d
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 2418 :     if (view==NULL) goto finish;

  00018	48 85 d2	 test	 rdx, rdx
  0001b	0f 84 cf 00 00
	00		 je	 $finish$22218

; 2419 : 
; 2420 :     view->buf = (void *)self->ob_item;

  00021	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]

; 2421 :     view->obj = (PyObject*)self;

  00025	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx
  00029	48 89 02	 mov	 QWORD PTR [rdx], rax

; 2422 :     Py_INCREF(self);

  0002c	e8 00 00 00 00	 call	 _Py_PXCTX
  00031	85 c0		 test	 eax, eax
  00033	75 32		 jne	 SHORT $LN9@array_buff@2
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00043	4c 8b cb	 mov	 r9, rbx
  00046	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0004c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00054	e8 00 00 00 00	 call	 _PyParallel_Guard
  00059	85 c0		 test	 eax, eax
  0005b	75 06		 jne	 SHORT $LN8@array_buff@2
  0005d	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00061	74 04		 je	 SHORT $LN9@array_buff@2
$LN8@array_buff@2:
  00063	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN9@array_buff@2:

; 2423 :     if (view->buf == NULL)

  00067	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 2424 :         view->buf = (void *)emptybuf;
; 2425 :     view->len = (Py_SIZE(self)) * self->ob_descr->itemsize;

  0006a	48 8d 53 60	 lea	 rdx, QWORD PTR [rbx+96]

; 2426 :     view->readonly = 0;
; 2427 :     view->ndim = 1;
; 2428 :     view->itemsize = self->ob_descr->itemsize;

  0006e	4c 8d 47 18	 lea	 r8, QWORD PTR [rdi+24]
  00072	48 83 f8 00	 cmp	 rax, 0
  00076	48 0f 44 05 00
	00 00 00	 cmove	 rax, QWORD PTR emptybuf
  0007e	45 33 c9	 xor	 r9d, r9d
  00081	48 89 07	 mov	 QWORD PTR [rdi], rax
  00084	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]
  0008b	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0008f	48 0f af 0a	 imul	 rcx, QWORD PTR [rdx]
  00093	44 89 4f 20	 mov	 DWORD PTR [rdi+32], r9d
  00097	c7 47 24 01 00
	00 00		 mov	 DWORD PTR [rdi+36], 1
  0009e	48 89 4f 10	 mov	 QWORD PTR [rdi+16], rcx
  000a2	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]
  000a9	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]

; 2429 :     view->suboffsets = NULL;

  000ad	4c 89 4f 40	 mov	 QWORD PTR [rdi+64], r9

; 2430 :     view->shape = NULL;

  000b1	4c 89 4f 30	 mov	 QWORD PTR [rdi+48], r9
  000b5	49 89 08	 mov	 QWORD PTR [r8], rcx

; 2431 :     if ((flags & PyBUF_ND)==PyBUF_ND) {

  000b8	40 f6 c6 08	 test	 sil, 8
  000bc	74 04		 je	 SHORT $LN3@array_buff@2

; 2432 :         view->shape = &((Py_SIZE(self)));

  000be	48 89 57 30	 mov	 QWORD PTR [rdi+48], rdx
$LN3@array_buff@2:

; 2433 :     }
; 2434 :     view->strides = NULL;
; 2435 :     if ((flags & PyBUF_STRIDES)==PyBUF_STRIDES)

  000c2	8b c6		 mov	 eax, esi
  000c4	4c 89 4f 38	 mov	 QWORD PTR [rdi+56], r9
  000c8	83 e0 18	 and	 eax, 24
  000cb	3c 18		 cmp	 al, 24
  000cd	75 04		 jne	 SHORT $LN2@array_buff@2

; 2436 :         view->strides = &(view->itemsize);

  000cf	4c 89 47 38	 mov	 QWORD PTR [rdi+56], r8
$LN2@array_buff@2:

; 2437 :     view->format = NULL;

  000d3	4c 89 4f 28	 mov	 QWORD PTR [rdi+40], r9

; 2438 :     view->internal = NULL;

  000d7	4c 89 4f 48	 mov	 QWORD PTR [rdi+72], r9

; 2439 :     if ((flags & PyBUF_FORMAT) == PyBUF_FORMAT) {

  000db	40 f6 c6 04	 test	 sil, 4
  000df	74 0f		 je	 SHORT $finish$22218

; 2440 :         view->format = self->ob_descr->formats;

  000e1	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]
  000e8	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  000ec	48 89 4f 28	 mov	 QWORD PTR [rdi+40], rcx
$finish$22218:

; 2441 : #ifdef Py_UNICODE_WIDE
; 2442 :         if (self->ob_descr->typecode == 'u') {
; 2443 :             view->format = "w";
; 2444 :         }
; 2445 : #endif
; 2446 :     }
; 2447 : 
; 2448 :  finish:
; 2449 :     self->ob_exports++;

  000f0	ff 83 90 00 00
	00		 inc	 DWORD PTR [rbx+144]

; 2450 :     return 0;
; 2451 : }

  000f6	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000fb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00100	33 c0		 xor	 eax, eax
  00102	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00106	5f		 pop	 rdi
  00107	c3		 ret	 0
array_buffer_getbuf ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT array_buffer_relbuf
_TEXT	SEGMENT
self$ = 8
view$ = 16
array_buffer_relbuf PROC				; COMDAT

; 2456 :     self->ob_exports--;

  00000	ff 89 90 00 00
	00		 dec	 DWORD PTR [rcx+144]

; 2457 : }

  00006	c3		 ret	 0
array_buffer_relbuf ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DP@FIAOOIAE@bad?5typecode?5?$CImust?5be?5b?0?5B?0?5u?0?5h@ ; `string'
PUBLIC	??_C@_09LFKFFFFJ@C?$HMO?3array?$AA@		; `string'
PUBLIC	??_C@_0O@BNFLHEON@array?4array?$CI?$CJ?$AA@	; `string'
EXTRN	PyTuple_Pack:PROC
EXTRN	PyMem_Realloc:PROC
EXTRN	PyUnicode_AsUnicode:PROC
EXTRN	PySequence_GetItem:PROC
EXTRN	PyByteArray_Type:BYTE
EXTRN	_PyArg_NoKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_new DD imagerel array_new
	DD	imagerel array_new+102
	DD	imagerel $unwind$array_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$array_new DD imagerel array_new+102
	DD	imagerel array_new+352
	DD	imagerel $chain$1$array_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$array_new DD imagerel array_new+352
	DD	imagerel array_new+970
	DD	imagerel $chain$3$array_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$array_new DD 040021H
	DD	0ce400H
	DD	0b5400H
	DD	imagerel array_new
	DD	imagerel array_new+102
	DD	imagerel $unwind$array_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$array_new DD 040f21H
	DD	0ce40fH
	DD	0b5405H
	DD	imagerel array_new
	DD	imagerel array_new+102
	DD	imagerel $unwind$array_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_new DD 060c01H
	DD	0d008320cH
	DD	07004c006H
	DD	030026003H
xdata	ENDS
;	COMDAT ??_C@_0DP@FIAOOIAE@bad?5typecode?5?$CImust?5be?5b?0?5B?0?5u?0?5h@
CONST	SEGMENT
??_C@_0DP@FIAOOIAE@bad?5typecode?5?$CImust?5be?5b?0?5B?0?5u?0?5h@ DB 'bad'
	DB	' typecode (must be b, B, u, h, H, i, I, l, L, q, Q, f or d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LFKFFFFJ@C?$HMO?3array?$AA@
CONST	SEGMENT
??_C@_09LFKFFFFJ@C?$HMO?3array?$AA@ DB 'C|O:array', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNFLHEON@array?4array?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@BNFLHEON@array?4array?$CI?$CJ?$AA@ DB 'array.array()', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_new
_TEXT	SEGMENT
c$ = 80
type$ = 80
args$ = 88
kwds$ = 96
initial$ = 104
array_new PROC						; COMDAT

; 2479 : {

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2480 :     int c;
; 2481 :     PyObject *initial = NULL, *it = NULL;

  0000c	33 ff		 xor	 edi, edi

; 2482 :     struct arraydescr *descr;
; 2483 : 
; 2484 :     if (type == &Arraytype && !_PyArg_NoKeywords("array.array()", kwds))

  0000e	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:Arraytype
  00015	48 8b da	 mov	 rbx, rdx
  00018	48 8b f1	 mov	 rsi, rcx
  0001b	48 89 7c 24 68	 mov	 QWORD PTR initial$[rsp], rdi
  00020	44 8b e7	 mov	 r12d, edi
  00023	49 3b cd	 cmp	 rcx, r13
  00026	75 21		 jne	 SHORT $LN41@array_new
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@BNFLHEON@array?4array?$CI?$CJ?$AA@
  0002f	49 8b d0	 mov	 rdx, r8
  00032	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  00037	85 c0		 test	 eax, eax
  00039	75 0e		 jne	 SHORT $LN41@array_new
$LN69@array_new:

; 2485 :         return NULL;

  0003b	33 c0		 xor	 eax, eax

; 2609 : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	41 5d		 pop	 r13
  00043	41 5c		 pop	 r12
  00045	5f		 pop	 rdi
  00046	5e		 pop	 rsi
  00047	5b		 pop	 rbx
  00048	c3		 ret	 0
$LN41@array_new:

; 2486 : 
; 2487 :     if (!PyArg_ParseTuple(args, "C|O:array", &c, &initial))

  00049	4c 8d 4c 24 68	 lea	 r9, QWORD PTR initial$[rsp]
  0004e	4c 8d 44 24 50	 lea	 r8, QWORD PTR c$[rsp]
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09LFKFFFFJ@C?$HMO?3array?$AA@
  0005a	48 8b cb	 mov	 rcx, rbx
  0005d	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00062	85 c0		 test	 eax, eax

; 2488 :         return NULL;

  00064	74 d5		 je	 SHORT $LN69@array_new

; 2489 : 
; 2490 :     if (!(initial == NULL || PyList_Check(initial)
; 2491 :           || PyByteArray_Check(initial)
; 2492 :           || PyBytes_Check(initial)
; 2493 :           || PyTuple_Check(initial)
; 2494 :           || ((c=='u') && PyUnicode_Check(initial))
; 2495 :           || (array_Check(initial)
; 2496 :               && c == ((arrayobject*)initial)->ob_descr->typecode))) {

  00066	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  0006b	48 8b 6c 24 68	 mov	 rbp, QWORD PTR initial$[rsp]
  00070	4c 89 74 24 60	 mov	 QWORD PTR [rsp+96], r14
  00075	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:PyByteArray_Type
  0007c	48 85 ed	 test	 rbp, rbp
  0007f	0f 84 87 00 00
	00		 je	 $LN58@array_new
  00085	48 8b 4d 58	 mov	 rcx, QWORD PTR [rbp+88]
  00089	f7 81 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rcx+256], 33554432 ; 02000000H
  00093	75 77		 jne	 SHORT $LN58@array_new
  00095	49 3b ce	 cmp	 rcx, r14
  00098	74 72		 je	 SHORT $LN58@array_new
  0009a	49 8b d6	 mov	 rdx, r14
  0009d	e8 00 00 00 00	 call	 PyType_IsSubtype
  000a2	48 8b 6c 24 68	 mov	 rbp, QWORD PTR initial$[rsp]
  000a7	85 c0		 test	 eax, eax
  000a9	75 61		 jne	 SHORT $LN58@array_new
  000ab	48 8b 4d 58	 mov	 rcx, QWORD PTR [rbp+88]
  000af	8b 81 00 01 00
	00		 mov	 eax, DWORD PTR [rcx+256]
  000b5	0f ba e0 1b	 bt	 eax, 27
  000b9	72 51		 jb	 SHORT $LN58@array_new
  000bb	0f ba e0 1a	 bt	 eax, 26
  000bf	72 4b		 jb	 SHORT $LN58@array_new
  000c1	83 7c 24 50 75	 cmp	 DWORD PTR c$[rsp], 117	; 00000075H
  000c6	75 06		 jne	 SHORT $LN38@array_new
  000c8	0f ba e0 1c	 bt	 eax, 28
  000cc	72 3e		 jb	 SHORT $LN58@array_new
$LN38@array_new:
  000ce	49 3b cd	 cmp	 rcx, r13
  000d1	74 11		 je	 SHORT $LN36@array_new
  000d3	49 8b d5	 mov	 rdx, r13
  000d6	e8 00 00 00 00	 call	 PyType_IsSubtype
  000db	48 8b 6c 24 68	 mov	 rbp, QWORD PTR initial$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 10		 je	 SHORT $LN37@array_new
$LN36@array_new:
  000e4	48 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR [rbp+128]
  000eb	0f be 10	 movsx	 edx, BYTE PTR [rax]
  000ee	39 54 24 50	 cmp	 DWORD PTR c$[rsp], edx
  000f2	74 18		 je	 SHORT $LN58@array_new
$LN37@array_new:

; 2497 :         it = PyObject_GetIter(initial);

  000f4	48 8b cd	 mov	 rcx, rbp
  000f7	e8 00 00 00 00	 call	 PyObject_GetIter
  000fc	4c 8b e0	 mov	 r12, rax

; 2498 :         if (it == NULL)

  000ff	48 85 c0	 test	 rax, rax

; 2499 :             return NULL;

  00102	74 44		 je	 SHORT $LN66@array_new

; 2500 :         /* We set initial to NULL so that the subsequent code
; 2501 :            will create an empty array of the appropriate type
; 2502 :            and afterwards we can use array_iter_extend to populate
; 2503 :            the array.
; 2504 :         */
; 2505 :         initial = NULL;

  00104	48 8b ef	 mov	 rbp, rdi
  00107	48 89 7c 24 68	 mov	 QWORD PTR initial$[rsp], rdi
$LN58@array_new:

; 2506 :     }
; 2507 :     for (descr = descriptors; descr->typecode != '\0'; descr++) {

  0010c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR descriptors
  00113	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:descriptors
  0011a	84 c0		 test	 al, al
  0011c	74 17		 je	 SHORT $LN32@array_new
  0011e	66 90		 npad	 2
$LL34@array_new:

; 2508 :         if (descr->typecode == c) {

  00120	0f be c0	 movsx	 eax, al
  00123	3b 44 24 50	 cmp	 eax, DWORD PTR c$[rsp]
  00127	74 37		 je	 SHORT $LN52@array_new

; 2506 :     }
; 2507 :     for (descr = descriptors; descr->typecode != '\0'; descr++) {

  00129	0f b6 43 28	 movzx	 eax, BYTE PTR [rbx+40]
  0012d	48 83 c3 28	 add	 rbx, 40			; 00000028H
  00131	84 c0		 test	 al, al
  00133	75 eb		 jne	 SHORT $LL34@array_new
$LN32@array_new:

; 2600 :         }
; 2601 :     }
; 2602 :     PyErr_SetString(PyExc_ValueError,
; 2603 : #ifdef HAVE_LONG_LONG
; 2604 :         "bad typecode (must be b, B, u, h, H, i, I, l, L, q, Q, f or d)");

  00135	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0013c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DP@FIAOOIAE@bad?5typecode?5?$CImust?5be?5b?0?5B?0?5u?0?5h@
  00143	e8 00 00 00 00	 call	 PyErr_SetString
$LN66@array_new:

; 2605 : #else
; 2606 :         "bad typecode (must be b, B, u, h, H, i, I, l, L, f or d)");
; 2607 : #endif
; 2608 :     return NULL;

  00148	33 c0		 xor	 eax, eax
$LN65@array_new:
  0014a	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  0014f	4c 8b 74 24 60	 mov	 r14, QWORD PTR [rsp+96]

; 2609 : }

  00154	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00158	41 5d		 pop	 r13
  0015a	41 5c		 pop	 r12
  0015c	5f		 pop	 rdi
  0015d	5e		 pop	 rsi
  0015e	5b		 pop	 rbx
  0015f	c3		 ret	 0
$LN52@array_new:

; 2509 :             PyObject *a;
; 2510 :             Py_ssize_t len;
; 2511 : 
; 2512 :             if (initial == NULL)

  00160	48 85 ed	 test	 rbp, rbp
  00163	75 05		 jne	 SHORT $LN30@array_new

; 2513 :                 len = 0;

  00165	48 8b ef	 mov	 rbp, rdi
  00168	eb 35		 jmp	 SHORT $LN23@array_new
$LN30@array_new:

; 2514 :             else if (PyList_Check(initial))

  0016a	48 8b 4d 58	 mov	 rcx, QWORD PTR [rbp+88]
  0016e	8b 81 00 01 00
	00		 mov	 eax, DWORD PTR [rcx+256]
  00174	0f ba e0 19	 bt	 eax, 25

; 2515 :                 len = PyList_GET_SIZE(initial);

  00178	72 21		 jb	 SHORT $LN24@array_new

; 2516 :             else if (PyTuple_Check(initial) || array_Check(initial))

  0017a	0f ba e0 1a	 bt	 eax, 26
  0017e	72 1b		 jb	 SHORT $LN24@array_new
  00180	49 3b cd	 cmp	 rcx, r13
  00183	74 16		 je	 SHORT $LN24@array_new
  00185	49 8b d5	 mov	 rdx, r13
  00188	e8 00 00 00 00	 call	 PyType_IsSubtype
  0018d	85 c0		 test	 eax, eax
  0018f	75 05		 jne	 SHORT $LN61@array_new

; 2518 :             else
; 2519 :                 len = 0;

  00191	48 8b ef	 mov	 rbp, rdi
  00194	eb 09		 jmp	 SHORT $LN23@array_new
$LN61@array_new:
  00196	48 8b 6c 24 68	 mov	 rbp, QWORD PTR initial$[rsp]
$LN24@array_new:

; 2517 :                 len = Py_SIZE(initial);

  0019b	48 8b 6d 60	 mov	 rbp, QWORD PTR [rbp+96]
$LN23@array_new:

; 2520 : 
; 2521 :             a = newarrayobject(type, len, descr);

  0019f	4c 8b c3	 mov	 r8, rbx
  001a2	48 8b d5	 mov	 rdx, rbp
  001a5	48 8b ce	 mov	 rcx, rsi
  001a8	e8 00 00 00 00	 call	 newarrayobject
  001ad	48 8b d8	 mov	 rbx, rax

; 2522 :             if (a == NULL)

  001b0	48 85 c0	 test	 rax, rax

; 2523 :                 return NULL;

  001b3	74 93		 je	 SHORT $LN66@array_new

; 2524 : 
; 2525 :             if (len > 0 && !array_Check(initial)) {

  001b5	48 85 ed	 test	 rbp, rbp
  001b8	7e 74		 jle	 SHORT $LN62@array_new
  001ba	48 8b 4c 24 68	 mov	 rcx, QWORD PTR initial$[rsp]
  001bf	4c 39 69 58	 cmp	 QWORD PTR [rcx+88], r13
  001c3	74 6e		 je	 SHORT $LN21@array_new
  001c5	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  001c9	49 8b d5	 mov	 rdx, r13
  001cc	e8 00 00 00 00	 call	 PyType_IsSubtype
  001d1	85 c0		 test	 eax, eax
  001d3	75 59		 jne	 SHORT $LN62@array_new

; 2526 :                 Py_ssize_t i;
; 2527 :                 for (i = 0; i < len; i++) {

  001d5	48 85 ed	 test	 rbp, rbp
  001d8	0f 8e c3 01 00
	00		 jle	 $LN4@array_new
  001de	66 90		 npad	 2
$LL20@array_new:

; 2528 :                     PyObject *v =
; 2529 :                         PySequence_GetItem(initial, i);

  001e0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR initial$[rsp]
  001e5	48 8b d7	 mov	 rdx, rdi
  001e8	e8 00 00 00 00	 call	 PySequence_GetItem

; 2530 :                     if (v == NULL) {
; 2531 :                         Py_DECREF(a);
; 2532 :                         return NULL;
; 2533 :                     }
; 2534 :                     if (setarrayitem(a, i, v) != 0) {

  001ed	48 8b cb	 mov	 rcx, rbx
  001f0	48 8b f0	 mov	 rsi, rax
  001f3	48 85 c0	 test	 rax, rax
  001f6	74 2c		 je	 SHORT $LN53@array_new
  001f8	4c 8b c0	 mov	 r8, rax
  001fb	48 8b d7	 mov	 rdx, rdi
  001fe	e8 00 00 00 00	 call	 setarrayitem

; 2538 :                     }
; 2539 :                     Py_DECREF(v);

  00203	48 8b ce	 mov	 rcx, rsi
  00206	85 c0		 test	 eax, eax
  00208	75 12		 jne	 SHORT $LN54@array_new
  0020a	e8 00 00 00 00	 call	 _Py_DecRef
  0020f	48 ff c7	 inc	 rdi
  00212	48 3b fd	 cmp	 rdi, rbp
  00215	7c c9		 jl	 SHORT $LL20@array_new

; 2530 :                     if (v == NULL) {
; 2531 :                         Py_DECREF(a);
; 2532 :                         return NULL;
; 2533 :                     }
; 2534 :                     if (setarrayitem(a, i, v) != 0) {

  00217	e9 85 01 00 00	 jmp	 $LN4@array_new
$LN54@array_new:

; 2535 :                         Py_DECREF(v);

  0021c	e8 00 00 00 00	 call	 _Py_DecRef
$LN67@array_new:

; 2536 :                         Py_DECREF(a);

  00221	48 8b cb	 mov	 rcx, rbx
$LN53@array_new:
  00224	e8 00 00 00 00	 call	 _Py_DecRef

; 2537 :                         return NULL;

  00229	e9 1a ff ff ff	 jmp	 $LN66@array_new
$LN62@array_new:
  0022e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR initial$[rsp]
$LN21@array_new:

; 2540 :                 }
; 2541 :             }
; 2542 :             else if (initial != NULL && (PyByteArray_Check(initial) ||
; 2543 :                                PyBytes_Check(initial))) {

  00233	48 85 c9	 test	 rcx, rcx
  00236	0f 84 65 01 00
	00		 je	 $LN4@array_new
  0023c	4c 39 71 58	 cmp	 QWORD PTR [rcx+88], r14
  00240	0f 84 1b 01 00
	00		 je	 $LN13@array_new
  00246	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0024a	49 8b d6	 mov	 rdx, r14
  0024d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00252	48 8b 4c 24 68	 mov	 rcx, QWORD PTR initial$[rsp]
  00257	85 c0		 test	 eax, eax
  00259	0f 85 02 01 00
	00		 jne	 $LN13@array_new
  0025f	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  00263	41 8b 80 00 01
	00 00		 mov	 eax, DWORD PTR [r8+256]
  0026a	0f ba e0 1b	 bt	 eax, 27
  0026e	0f 82 ed 00 00
	00		 jb	 $LN13@array_new

; 2558 :             }
; 2559 :             else if (initial != NULL && PyUnicode_Check(initial))  {

  00274	0f ba e0 1c	 bt	 eax, 28
  00278	0f 83 ac 00 00
	00		 jae	 $LN9@array_new

; 2560 :                 Py_UNICODE *ustr;
; 2561 :                 Py_ssize_t n;
; 2562 : 
; 2563 :                 ustr = PyUnicode_AsUnicode(initial);

  0027e	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  00283	48 8b f0	 mov	 rsi, rax

; 2564 :                 if (ustr == NULL) {

  00286	48 85 c0	 test	 rax, rax
  00289	75 12		 jne	 SHORT $LN8@array_new
$LN68@array_new:

; 2565 :                     PyErr_NoMemory();

  0028b	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2566 :                     Py_DECREF(a);

  00290	48 8b cb	 mov	 rcx, rbx
  00293	e8 00 00 00 00	 call	 _Py_DecRef

; 2567 :                     return NULL;

  00298	e9 ab fe ff ff	 jmp	 $LN66@array_new
$LN8@array_new:

; 2568 :                 }
; 2569 : 
; 2570 :                 n = PyUnicode_GET_DATA_SIZE(initial);

  0029d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR initial$[rsp]
  002a2	48 39 79 78	 cmp	 QWORD PTR [rcx+120], rdi
  002a6	74 1a		 je	 SHORT $LN48@array_new
  002a8	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  002ab	a8 40		 test	 al, 64			; 00000040H
  002ad	74 0a		 je	 SHORT $LN44@array_new
  002af	a8 20		 test	 al, 32			; 00000020H
  002b1	74 06		 je	 SHORT $LN44@array_new
  002b3	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  002b7	eb 2d		 jmp	 SHORT $LN47@array_new
$LN44@array_new:
  002b9	48 8b 81 90 00
	00 00		 mov	 rax, QWORD PTR [rcx+144]
  002c0	eb 24		 jmp	 SHORT $LN47@array_new
$LN48@array_new:
  002c2	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  002c7	48 8b 44 24 68	 mov	 rax, QWORD PTR initial$[rsp]
  002cc	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  002cf	f6 c1 40	 test	 cl, 64			; 00000040H
  002d2	74 0b		 je	 SHORT $LN46@array_new
  002d4	f6 c1 20	 test	 cl, 32			; 00000020H
  002d7	74 06		 je	 SHORT $LN46@array_new
  002d9	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002dd	eb 07		 jmp	 SHORT $LN47@array_new
$LN46@array_new:
  002df	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
$LN47@array_new:
  002e6	48 8d 3c 00	 lea	 rdi, QWORD PTR [rax+rax]

; 2571 :                 if (n > 0) {

  002ea	48 85 ff	 test	 rdi, rdi
  002ed	0f 8e ae 00 00
	00		 jle	 $LN4@array_new

; 2572 :                     arrayobject *self = (arrayobject *)a;
; 2573 :                     char *item = self->ob_item;
; 2574 :                     item = (char *)PyMem_Realloc(item, n);

  002f3	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  002f7	48 8b d7	 mov	 rdx, rdi
  002fa	e8 00 00 00 00	 call	 PyMem_Realloc
  002ff	48 8b c8	 mov	 rcx, rax

; 2575 :                     if (item == NULL) {

  00302	48 85 c0	 test	 rax, rax

; 2576 :                         PyErr_NoMemory();
; 2577 :                         Py_DECREF(a);
; 2578 :                         return NULL;

  00305	74 84		 je	 SHORT $LN68@array_new

; 2579 :                     }
; 2580 :                     self->ob_item = item;

  00307	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 2581 :                     Py_SIZE(self) = n / sizeof(Py_UNICODE);

  0030b	48 8b c7	 mov	 rax, rdi

; 2582 :                     memcpy(item, ustr, n);

  0030e	4c 8b c7	 mov	 r8, rdi
  00311	48 d1 e8	 shr	 rax, 1
  00314	48 8b d6	 mov	 rdx, rsi
  00317	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax
  0031b	e8 00 00 00 00	 call	 memcpy

; 2583 :                     self->allocated = Py_SIZE(self);

  00320	4c 8b 5b 60	 mov	 r11, QWORD PTR [rbx+96]
  00324	4c 89 5b 78	 mov	 QWORD PTR [rbx+120], r11

; 2584 :                 }

  00328	eb 77		 jmp	 SHORT $LN4@array_new
$LN9@array_new:

; 2585 :             }
; 2586 :             else if (initial != NULL && array_Check(initial)) {

  0032a	4d 3b c5	 cmp	 r8, r13
  0032d	74 14		 je	 SHORT $LN3@array_new
  0032f	49 8b d5	 mov	 rdx, r13
  00332	49 8b c8	 mov	 rcx, r8
  00335	e8 00 00 00 00	 call	 PyType_IsSubtype
  0033a	85 c0		 test	 eax, eax
  0033c	74 63		 je	 SHORT $LN4@array_new
  0033e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR initial$[rsp]
$LN3@array_new:

; 2587 :                 arrayobject *self = (arrayobject *)a;
; 2588 :                 arrayobject *other = (arrayobject *)initial;
; 2589 :                 memcpy(self->ob_item, other->ob_item, len * other->ob_descr->itemsize);

  00343	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  0034a	48 8b 51 70	 mov	 rdx, QWORD PTR [rcx+112]
  0034e	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00352	4c 63 40 04	 movsxd	 r8, DWORD PTR [rax+4]
  00356	4c 0f af c5	 imul	 r8, rbp
  0035a	e8 00 00 00 00	 call	 memcpy
  0035f	eb 40		 jmp	 SHORT $LN4@array_new
$LN13@array_new:

; 2544 :                 PyObject *t_initial, *v;
; 2545 :                 t_initial = PyTuple_Pack(1, initial);

  00361	48 8b d1	 mov	 rdx, rcx
  00364	b9 01 00 00 00	 mov	 ecx, 1
  00369	e8 00 00 00 00	 call	 PyTuple_Pack

; 2546 :                 if (t_initial == NULL) {
; 2547 :                     Py_DECREF(a);

  0036e	48 8b cb	 mov	 rcx, rbx
  00371	48 8b f8	 mov	 rdi, rax
  00374	48 85 c0	 test	 rax, rax

; 2548 :                     return NULL;

  00377	0f 84 a7 fe ff
	ff		 je	 $LN53@array_new

; 2549 :                 }
; 2550 :                 v = array_frombytes((arrayobject *)a,
; 2551 :                                          t_initial);

  0037d	48 8b d0	 mov	 rdx, rax
  00380	e8 00 00 00 00	 call	 array_frombytes

; 2552 :                 Py_DECREF(t_initial);

  00385	48 8b cf	 mov	 rcx, rdi
  00388	48 8b f0	 mov	 rsi, rax
  0038b	e8 00 00 00 00	 call	 _Py_DecRef

; 2553 :                 if (v == NULL) {

  00390	48 85 f6	 test	 rsi, rsi

; 2554 :                     Py_DECREF(a);
; 2555 :                     return NULL;

  00393	0f 84 88 fe ff
	ff		 je	 $LN67@array_new

; 2556 :                 }
; 2557 :                 Py_DECREF(v);

  00399	48 8b ce	 mov	 rcx, rsi
  0039c	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@array_new:

; 2590 :             }
; 2591 :             if (it != NULL) {

  003a1	4d 85 e4	 test	 r12, r12
  003a4	74 1c		 je	 SHORT $LN2@array_new

; 2592 :                 if (array_iter_extend((arrayobject *)a, it) == -1) {

  003a6	49 8b d4	 mov	 rdx, r12
  003a9	48 8b cb	 mov	 rcx, rbx
  003ac	e8 00 00 00 00	 call	 array_iter_extend

; 2593 :                     Py_DECREF(it);

  003b1	49 8b cc	 mov	 rcx, r12
  003b4	83 f8 ff	 cmp	 eax, -1

; 2594 :                     Py_DECREF(a);
; 2595 :                     return NULL;

  003b7	0f 84 5f fe ff
	ff		 je	 $LN54@array_new

; 2596 :                 }
; 2597 :                 Py_DECREF(it);

  003bd	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@array_new:

; 2598 :             }
; 2599 :             return a;

  003c2	48 8b c3	 mov	 rax, rbx
  003c5	e9 80 fd ff ff	 jmp	 $LN65@array_new
array_new ENDP
_TEXT	ENDS
EXTRN	PyObject_GC_Track:PROC
EXTRN	_PyObject_GC_New:PROC
EXTRN	_PxObject_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$array_iter DD imagerel array_iter
	DD	imagerel array_iter+59
	DD	imagerel $unwind$array_iter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$array_iter DD imagerel array_iter+59
	DD	imagerel array_iter+111
	DD	imagerel $chain$0$array_iter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$array_iter DD imagerel array_iter+111
	DD	imagerel array_iter+219
	DD	imagerel $chain$2$array_iter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$array_iter DD 020021H
	DD	083400H
	DD	imagerel array_iter
	DD	imagerel array_iter+59
	DD	imagerel $unwind$array_iter
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$array_iter DD 020521H
	DD	083405H
	DD	imagerel array_iter
	DD	imagerel array_iter+59
	DD	imagerel $unwind$array_iter
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_iter DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
xdata	ENDS
;	COMDAT array_iter
_TEXT	SEGMENT
ao$ = 64
array_iter PROC						; COMDAT

; 2742 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b f9	 mov	 rdi, rcx

; 2743 :     arrayiterobject *it;
; 2744 : 
; 2745 :     if (!array_Check(ao)) {

  00009	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  00014	48 3b ca	 cmp	 rcx, rdx
  00017	74 22		 je	 SHORT $LN2@array_iter@2
  00019	e8 00 00 00 00	 call	 PyType_IsSubtype
  0001e	85 c0		 test	 eax, eax
  00020	75 19		 jne	 SHORT $LN2@array_iter@2

; 2746 :         PyErr_BadInternalCall();

  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@DMBOHOAP@?4?4?2Modules?2arraymodule?4c?$AA@
  00029	ba ba 0a 00 00	 mov	 edx, 2746		; 00000abaH
  0002e	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2747 :         return NULL;

  00033	33 c0		 xor	 eax, eax

; 2760 : }

  00035	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
$LN2@array_iter@2:
  0003b	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 2748 :     }
; 2749 : 
; 2750 :     it = PyObject_GC_New(arrayiterobject, &PyArrayIter_Type);

  00040	e8 00 00 00 00	 call	 _Py_PXCTX
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyArrayIter_Type
  0004c	85 c0		 test	 eax, eax
  0004e	74 07		 je	 SHORT $LN5@array_iter@2
  00050	e8 00 00 00 00	 call	 _PxObject_New
  00055	eb 05		 jmp	 SHORT $LN12@array_iter@2
$LN5@array_iter@2:
  00057	e8 00 00 00 00	 call	 _PyObject_GC_New
$LN12@array_iter@2:
  0005c	48 8b d8	 mov	 rbx, rax

; 2751 :     if (it == NULL)

  0005f	48 85 c0	 test	 rax, rax
  00062	75 0b		 jne	 SHORT $LN1@array_iter@2
  00064	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2760 : }

  00069	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
$LN1@array_iter@2:

; 2752 :         return NULL;
; 2753 : 
; 2754 :     Py_INCREF(ao);

  0006f	e8 00 00 00 00	 call	 _Py_PXCTX
  00074	85 c0		 test	 eax, eax
  00076	75 32		 jne	 SHORT $LN8@array_iter@2
  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00086	4c 8b cf	 mov	 r9, rdi
  00089	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0008f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00097	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009c	85 c0		 test	 eax, eax
  0009e	75 06		 jne	 SHORT $LN7@array_iter@2
  000a0	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  000a4	74 04		 je	 SHORT $LN8@array_iter@2
$LN7@array_iter@2:
  000a6	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN8@array_iter@2:

; 2755 :     it->ao = ao;

  000aa	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi

; 2756 :     it->index = 0;

  000ae	48 c7 43 60 00
	00 00 00	 mov	 QWORD PTR [rbx+96], 0

; 2757 :     it->getitem = ao->ob_descr->getitem;

  000b6	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  000bd	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000c1	48 89 4b 70	 mov	 QWORD PTR [rbx+112], rcx

; 2758 :     PyObject_GC_Track(it);

  000c5	48 8b cb	 mov	 rcx, rbx
  000c8	e8 00 00 00 00	 call	 PyObject_GC_Track

; 2759 :     return (PyObject *)it;

  000cd	48 8b c3	 mov	 rax, rbx
  000d0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2760 : }

  000d5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
array_iter ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT arrayiter_next
_TEXT	SEGMENT
it$ = 8
arrayiter_next PROC					; COMDAT

; 2764 : {

  00000	4c 8b c1	 mov	 r8, rcx

; 2765 :     assert(PyArrayIter_Check(it));
; 2766 :     if (it->index < Py_SIZE(it->ao))

  00003	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00007	49 8b 50 60	 mov	 rdx, QWORD PTR [r8+96]
  0000b	48 3b 51 60	 cmp	 rdx, QWORD PTR [rcx+96]
  0000f	7d 0c		 jge	 SHORT $LN1@arrayiter_

; 2767 :         return (*it->getitem)(it->ao, it->index++);

  00011	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  00015	49 89 40 60	 mov	 QWORD PTR [r8+96], rax

; 2769 : }

  00019	49 ff 60 70	 rex_jmp QWORD PTR [r8+112]
$LN1@arrayiter_:

; 2768 :     return NULL;

  0001d	33 c0		 xor	 eax, eax

; 2769 : }

  0001f	c3		 ret	 0
arrayiter_next ENDP
_TEXT	ENDS
EXTRN	PyObject_GC_Del:PROC
EXTRN	PyObject_GC_UnTrack:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$arrayiter_dealloc DD imagerel arrayiter_dealloc
	DD	imagerel arrayiter_dealloc+182
	DD	imagerel $unwind$arrayiter_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$arrayiter_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
xdata	ENDS
;	COMDAT arrayiter_dealloc
_TEXT	SEGMENT
it$ = 64
arrayiter_dealloc PROC					; COMDAT

; 2773 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 2774 :     PyObject_GC_UnTrack(it);

  0000d	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 2775 :     Py_XDECREF(it->ao);

  00012	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
  00016	48 85 db	 test	 rbx, rbx
  00019	0f 84 85 00 00
	00		 je	 $LN3@arrayiter_@2
  0001f	e8 00 00 00 00	 call	 _Py_PXCTX
  00024	85 c0		 test	 eax, eax
  00026	75 7c		 jne	 SHORT $LN3@arrayiter_@2
  00028	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0002c	a8 20		 test	 al, 32			; 00000020H
  0002e	75 6c		 jne	 SHORT $LN11@arrayiter_@2
  00030	84 c0		 test	 al, al
  00032	78 68		 js	 SHORT $LN11@arrayiter_@2
  00034	a8 02		 test	 al, 2
  00036	75 6c		 jne	 SHORT $LN3@arrayiter_@2
  00038	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0003c	75 66		 jne	 SHORT $LN3@arrayiter_@2
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0004c	4c 8b cb	 mov	 r9, rbx
  0004f	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00055	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0005d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00062	48 8b cb	 mov	 rcx, rbx
  00065	85 c0		 test	 eax, eax
  00067	74 17		 je	 SHORT $LN16@arrayiter_@2
  00069	e8 00 00 00 00	 call	 _Px_Dealloc

; 2776 :     PyObject_GC_Del(it);

  0006e	48 8b cf	 mov	 rcx, rdi

; 2777 : }

  00071	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00076	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007a	5f		 pop	 rdi
  0007b	e9 00 00 00 00	 jmp	 PyObject_GC_Del

; 2775 :     Py_XDECREF(it->ao);

$LN16@arrayiter_@2:
  00080	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00084	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 2776 :     PyObject_GC_Del(it);

  0008a	48 8b cf	 mov	 rcx, rdi

; 2777 : }

  0008d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00092	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00096	5f		 pop	 rdi
  00097	e9 00 00 00 00	 jmp	 PyObject_GC_Del

; 2775 :     Py_XDECREF(it->ao);

$LN11@arrayiter_@2:
  0009c	48 8b cb	 mov	 rcx, rbx
  0009f	e8 00 00 00 00	 call	 Px_DecRef
$LN3@arrayiter_@2:

; 2776 :     PyObject_GC_Del(it);

  000a4	48 8b cf	 mov	 rcx, rdi

; 2777 : }

  000a7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b0	5f		 pop	 rdi
  000b1	e9 00 00 00 00	 jmp	 PyObject_GC_Del
arrayiter_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@GJJFGDLC@arrayiter_traverse?$AA@	; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$arrayiter_traverse DD imagerel arrayiter_traverse
	DD	imagerel arrayiter_traverse+97
	DD	imagerel $unwind$arrayiter_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$arrayiter_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BD@GJJFGDLC@arrayiter_traverse?$AA@
CONST	SEGMENT
??_C@_0BD@GJJFGDLC@arrayiter_traverse?$AA@ DB 'arrayiter_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT arrayiter_traverse
_TEXT	SEGMENT
it$ = 48
visit$ = 56
arg$ = 64
arrayiter_traverse PROC					; COMDAT

; 2781 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 2782 :     Py_VISIT(it->ao);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN3@arrayiter_@3
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@DMBOHOAP@?4?4?2Modules?2arraymodule?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@GJJFGDLC@arrayiter_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 de 0a 00
	00		 mov	 r8d, 2782		; 00000adeH
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@arrayiter_@3:
  0003d	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00041	48 85 c9	 test	 rcx, rcx
  00044	74 09		 je	 SHORT $LN5@arrayiter_@3
  00046	48 8b d7	 mov	 rdx, rdi
  00049	ff d6		 call	 rsi
  0004b	85 c0		 test	 eax, eax
  0004d	75 02		 jne	 SHORT $LN7@arrayiter_@3
$LN5@arrayiter_@3:

; 2783 :     return 0;

  0004f	33 c0		 xor	 eax, eax
$LN7@arrayiter_@3:

; 2784 : }

  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
arrayiter_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@		; `string'
PUBLIC	??_C@_04BKLHDIKK@iter?$AA@			; `string'
EXTRN	_PyObject_GetBuiltin:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$arrayiter_reduce DD imagerel arrayiter_reduce
	DD	imagerel arrayiter_reduce+49
	DD	imagerel $unwind$arrayiter_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$arrayiter_reduce DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@
CONST	SEGMENT
??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@ DB 'N(O)n', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKLHDIKK@iter?$AA@
CONST	SEGMENT
??_C@_04BKLHDIKK@iter?$AA@ DB 'iter', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT arrayiter_reduce
_TEXT	SEGMENT
it$ = 48
arrayiter_reduce PROC					; COMDAT

; 2788 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 2789 :     return Py_BuildValue("N(O)n", _PyObject_GetBuiltin("iter"),
; 2790 :                          it->ao, it->index);

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BKLHDIKK@iter?$AA@
  00010	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  00015	4c 8b 4b 60	 mov	 r9, QWORD PTR [rbx+96]
  00019	4c 8b 43 68	 mov	 r8, QWORD PTR [rbx+104]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@
  00024	48 8b d0	 mov	 rdx, rax

; 2791 : }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx
  0002c	e9 00 00 00 00	 jmp	 _Py_BuildValue_SizeT
arrayiter_reduce ENDP
_TEXT	ENDS
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$arrayiter_setstate DD imagerel arrayiter_setstate
	DD	imagerel arrayiter_setstate+134
	DD	imagerel $unwind$arrayiter_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$arrayiter_setstate DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
xdata	ENDS
;	COMDAT arrayiter_setstate
_TEXT	SEGMENT
it$ = 64
state$ = 72
arrayiter_setstate PROC					; COMDAT

; 2795 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 2796 :     Py_ssize_t index = PyLong_AsSsize_t(state);

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	e8 00 00 00 00	 call	 PyLong_AsSsize_t

; 2797 :     if (index == -1 && PyErr_Occurred())

  00011	48 83 f8 ff	 cmp	 rax, -1
  00015	75 12		 jne	 SHORT $LN2@arrayiter_@4
  00017	e8 00 00 00 00	 call	 PyErr_Occurred
  0001c	48 85 c0	 test	 rax, rax
  0001f	74 0d		 je	 SHORT $LN9@arrayiter_@4

; 2798 :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 2803 : }

  00023	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
$LN2@arrayiter_@4:

; 2799 :     if (index < 0)

  00029	48 85 c0	 test	 rax, rax
  0002c	79 02		 jns	 SHORT $LN1@arrayiter_@4
$LN9@arrayiter_@4:

; 2800 :         index = 0;

  0002e	33 c0		 xor	 eax, eax
$LN1@arrayiter_@4:

; 2801 :     it->index = index;

  00030	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 2802 :     Py_RETURN_NONE;

  00034	e8 00 00 00 00	 call	 _Py_PXCTX
  00039	85 c0		 test	 eax, eax
  0003b	75 3c		 jne	 SHORT $LN6@arrayiter_@4
  0003d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00052	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00058	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00060	e8 00 00 00 00	 call	 _PyParallel_Guard
  00065	85 c0		 test	 eax, eax
  00067	75 09		 jne	 SHORT $LN5@arrayiter_@4
  00069	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00070	74 07		 je	 SHORT $LN6@arrayiter_@4
$LN5@arrayiter_@4:
  00072	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN6@arrayiter_@4:
  00079	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 2803 : }

  00080	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00084	5b		 pop	 rbx
  00085	c3		 ret	 0
arrayiter_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_09KBEBOLPF@typecodes?$AA@			; `string'
PUBLIC	??_C@_09MLBOOMFO@ArrayType?$AA@			; `string'
PUBLIC	PyInit_array
EXTRN	PyUnicode_DecodeASCII:PROC
EXTRN	PyModule_AddObject:PROC
EXTRN	PyModule_Create2:PROC
EXTRN	PyType_Type:BYTE
EXTRN	PyType_Ready:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyInit_array DD imagerel $LN36
	DD	imagerel $LN36+53
	DD	imagerel $unwind$PyInit_array
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyInit_array DD imagerel $LN36+53
	DD	imagerel $LN36+81
	DD	imagerel $chain$0$PyInit_array
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyInit_array DD imagerel $LN36+81
	DD	imagerel $LN36+479
	DD	imagerel $chain$2$PyInit_array
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyInit_array DD imagerel $LN36+479
	DD	imagerel $LN36+503
	DD	imagerel $chain$4$PyInit_array
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$PyInit_array DD imagerel $LN36+503
	DD	imagerel $LN36+526
	DD	imagerel $chain$6$PyInit_array
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$PyInit_array DD 020021H
	DD	083400H
	DD	imagerel $LN36
	DD	imagerel $LN36+53
	DD	imagerel $unwind$PyInit_array
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyInit_array DD 020021H
	DD	083400H
	DD	imagerel $LN36
	DD	imagerel $LN36+53
	DD	imagerel $unwind$PyInit_array
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyInit_array DD 020021H
	DD	083400H
	DD	imagerel $LN36
	DD	imagerel $LN36+53
	DD	imagerel $unwind$PyInit_array
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyInit_array DD 020521H
	DD	083405H
	DD	imagerel $LN36
	DD	imagerel $LN36+53
	DD	imagerel $unwind$PyInit_array
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_array DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_09KBEBOLPF@typecodes?$AA@
CONST	SEGMENT
??_C@_09KBEBOLPF@typecodes?$AA@ DB 'typecodes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MLBOOMFO@ArrayType?$AA@
CONST	SEGMENT
??_C@_09MLBOOMFO@ArrayType?$AA@ DB 'ArrayType', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
CONST	ENDS
;	COMDAT PyInit_array
_TEXT	SEGMENT
buffer$ = 48
PyInit_array PROC					; COMDAT

; 2871 : {

$LN36:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2872 :     PyObject *m;
; 2873 :     char buffer[Py_ARRAY_LENGTH(descriptors)], *p;
; 2874 :     PyObject *typecodes;
; 2875 :     Py_ssize_t size = 0;
; 2876 :     struct arraydescr *descr;
; 2877 : 
; 2878 :     if (PyType_Ready(&Arraytype) < 0)

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Arraytype
  0000b	e8 00 00 00 00	 call	 PyType_Ready
  00010	85 c0		 test	 eax, eax
  00012	79 07		 jns	 SHORT $LN9@PyInit_arr

; 2879 :         return NULL;

  00014	33 c0		 xor	 eax, eax

; 2907 : }

  00016	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0001a	c3		 ret	 0
$LN9@PyInit_arr:

; 2880 :     Py_TYPE(&PyArrayIter_Type) = &PyType_Type;

  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyType_Type

; 2881 :     m = PyModule_Create(&arraymodule);

  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:arraymodule
  00029	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  0002e	48 89 05 58 00
	00 00		 mov	 QWORD PTR PyArrayIter_Type+88, rax
  00035	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0003a	e8 00 00 00 00	 call	 PyModule_Create2
  0003f	48 8b d8	 mov	 rbx, rax

; 2882 :     if (m == NULL)

  00042	48 85 c0	 test	 rax, rax
  00045	75 0a		 jne	 SHORT $LN8@PyInit_arr
  00047	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2907 : }

  0004c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00050	c3		 ret	 0
$LN8@PyInit_arr:

; 2883 :         return NULL;
; 2884 : 
; 2885 :     Py_INCREF((PyObject *)&Arraytype);

  00051	e8 00 00 00 00	 call	 _Py_PXCTX
  00056	85 c0		 test	 eax, eax
  00058	75 3c		 jne	 SHORT $LN13@PyInit_arr
  0005a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:Arraytype
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0006f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00075	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00082	85 c0		 test	 eax, eax
  00084	75 09		 jne	 SHORT $LN12@PyInit_arr
  00086	f6 05 20 00 00
	00 20		 test	 BYTE PTR Arraytype+32, 32 ; 00000020H
  0008d	74 07		 je	 SHORT $LN13@PyInit_arr
$LN12@PyInit_arr:
  0008f	48 ff 05 50 00
	00 00		 inc	 QWORD PTR Arraytype+80
$LN13@PyInit_arr:

; 2886 :     PyModule_AddObject(m, "ArrayType", (PyObject *)&Arraytype);

  00096	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:Arraytype
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09MLBOOMFO@ArrayType?$AA@
  000a4	48 8b cb	 mov	 rcx, rbx
  000a7	e8 00 00 00 00	 call	 PyModule_AddObject

; 2887 :     Py_INCREF((PyObject *)&Arraytype);

  000ac	e8 00 00 00 00	 call	 _Py_PXCTX
  000b1	85 c0		 test	 eax, eax
  000b3	75 3c		 jne	 SHORT $LN17@PyInit_arr
  000b5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:Arraytype
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000ca	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000d0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000d8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000dd	85 c0		 test	 eax, eax
  000df	75 09		 jne	 SHORT $LN16@PyInit_arr
  000e1	f6 05 20 00 00
	00 20		 test	 BYTE PTR Arraytype+32, 32 ; 00000020H
  000e8	74 07		 je	 SHORT $LN17@PyInit_arr
$LN16@PyInit_arr:
  000ea	48 ff 05 50 00
	00 00		 inc	 QWORD PTR Arraytype+80
$LN17@PyInit_arr:

; 2888 :     PyModule_AddObject(m, "array", (PyObject *)&Arraytype);

  000f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:Arraytype
  000f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05HIFJDKLD@array?$AA@
  000ff	48 8b cb	 mov	 rcx, rbx
  00102	e8 00 00 00 00	 call	 PyModule_AddObject

; 2889 : 
; 2890 :     for (descr=descriptors; descr->typecode != '\0'; descr++) {

  00107	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR descriptors
  0010e	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:descriptors
  00115	49 8b c3	 mov	 rax, r11
  00118	84 c9		 test	 cl, cl
  0011a	74 0d		 je	 SHORT $LN5@PyInit_arr
  0011c	0f 1f 40 00	 npad	 4
$LL7@PyInit_arr:
  00120	48 83 c0 28	 add	 rax, 40			; 00000028H
  00124	80 38 00	 cmp	 BYTE PTR [rax], 0
  00127	75 f7		 jne	 SHORT $LL7@PyInit_arr
$LN5@PyInit_arr:

; 2891 :         size++;
; 2892 :     }
; 2893 : 
; 2894 :     p = buffer;

  00129	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]

; 2895 :     for (descr = descriptors; descr->typecode != '\0'; descr++) {

  0012e	84 c9		 test	 cl, cl
  00130	74 1f		 je	 SHORT $LN2@PyInit_arr
  00132	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL4@PyInit_arr:
  00140	49 83 c3 28	 add	 r11, 40			; 00000028H

; 2896 :         *p++ = (char)descr->typecode;

  00144	88 0a		 mov	 BYTE PTR [rdx], cl
  00146	48 ff c2	 inc	 rdx
  00149	41 0f b6 0b	 movzx	 ecx, BYTE PTR [r11]
  0014d	84 c9		 test	 cl, cl
  0014f	75 ef		 jne	 SHORT $LL4@PyInit_arr
$LN2@PyInit_arr:

; 2897 :     }
; 2898 :     typecodes = PyUnicode_DecodeASCII(buffer, p - buffer, NULL);

  00151	48 8d 44 24 30	 lea	 rax, QWORD PTR buffer$[rsp]
  00156	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0015b	45 33 c0	 xor	 r8d, r8d
  0015e	48 2b d0	 sub	 rdx, rax
  00161	e8 00 00 00 00	 call	 PyUnicode_DecodeASCII

; 2899 : 
; 2900 :     PyModule_AddObject(m, "typecodes", typecodes);

  00166	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09KBEBOLPF@typecodes?$AA@
  0016d	48 8b cb	 mov	 rcx, rbx
  00170	4c 8b c0	 mov	 r8, rax
  00173	e8 00 00 00 00	 call	 PyModule_AddObject

; 2901 : 
; 2902 :     if (PyErr_Occurred()) {

  00178	e8 00 00 00 00	 call	 PyErr_Occurred
  0017d	48 85 c0	 test	 rax, rax
  00180	74 7f		 je	 SHORT $LN1@PyInit_arr

; 2903 :         Py_DECREF(m);

  00182	e8 00 00 00 00	 call	 _Py_PXCTX
  00187	85 c0		 test	 eax, eax
  00189	75 74		 jne	 SHORT $LN30@PyInit_arr
  0018b	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0018f	a8 20		 test	 al, 32			; 00000020H
  00191	75 64		 jne	 SHORT $LN24@PyInit_arr
  00193	84 c0		 test	 al, al
  00195	78 60		 js	 SHORT $LN24@PyInit_arr
  00197	a8 02		 test	 al, 2
  00199	75 64		 jne	 SHORT $LN30@PyInit_arr
  0019b	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0019f	75 5e		 jne	 SHORT $LN30@PyInit_arr
  001a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001af	4c 8b cb	 mov	 r9, rbx
  001b2	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001b8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001c0	e8 00 00 00 00	 call	 _PyParallel_Guard
  001c5	48 8b cb	 mov	 rcx, rbx
  001c8	85 c0		 test	 eax, eax
  001ca	74 13		 je	 SHORT $LN29@PyInit_arr
  001cc	e8 00 00 00 00	 call	 _Px_Dealloc

; 2904 :         m = NULL;

  001d1	33 db		 xor	 ebx, ebx

; 2905 :     }
; 2906 :     return m;

  001d3	8b c3		 mov	 eax, ebx
  001d5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2907 : }

  001da	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001de	c3		 ret	 0

; 2903 :         Py_DECREF(m);

$LN29@PyInit_arr:
  001df	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001e3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 2904 :         m = NULL;

  001e9	33 db		 xor	 ebx, ebx

; 2905 :     }
; 2906 :     return m;

  001eb	8b c3		 mov	 eax, ebx
  001ed	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2907 : }

  001f2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001f6	c3		 ret	 0

; 2903 :         Py_DECREF(m);

$LN24@PyInit_arr:
  001f7	48 8b cb	 mov	 rcx, rbx
  001fa	e8 00 00 00 00	 call	 Px_DecRef
$LN30@PyInit_arr:

; 2904 :         m = NULL;

  001ff	33 db		 xor	 ebx, ebx
$LN1@PyInit_arr:

; 2905 :     }
; 2906 :     return m;

  00201	48 8b c3	 mov	 rax, rbx
  00204	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2907 : }

  00209	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0020d	c3		 ret	 0
PyInit_array ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@GIMCCOCP@read?$CI?$CJ?5didn?8t?5return?5enough?5byte@ ; `string'
PUBLIC	??_C@_03IELNPCCE@?$CIO?$CJ?$AA@			; `string'
PUBLIC	??_C@_0BL@MCBECLD@read?$CI?$CJ?5didn?8t?5return?5bytes?$AA@ ; `string'
PUBLIC	??_C@_01EFFIKLCJ@n?$AA@				; `string'
PUBLIC	??_C@_0P@DIJHAIGC@negative?5count?$AA@		; `string'
PUBLIC	??_C@_0M@LKCNGHFH@On?3fromfile?$AA@		; `string'
EXTRN	PyExc_EOFError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_fromfile DD imagerel array_fromfile
	DD	imagerel array_fromfile+64
	DD	imagerel $unwind$array_fromfile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$array_fromfile DD imagerel array_fromfile+64
	DD	imagerel array_fromfile+113
	DD	imagerel $chain$0$array_fromfile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$array_fromfile DD imagerel array_fromfile+113
	DD	imagerel array_fromfile+153
	DD	imagerel $chain$2$array_fromfile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$array_fromfile DD imagerel array_fromfile+153
	DD	imagerel array_fromfile+267
	DD	imagerel $chain$4$array_fromfile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$array_fromfile DD imagerel array_fromfile+267
	DD	imagerel array_fromfile+406
	DD	imagerel $chain$8$array_fromfile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$array_fromfile DD 061a21H
	DD	04641aH
	DD	0b5405H
	DD	093400H
	DD	imagerel array_fromfile
	DD	imagerel array_fromfile+64
	DD	imagerel $unwind$array_fromfile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$array_fromfile DD 020021H
	DD	093400H
	DD	imagerel array_fromfile
	DD	imagerel array_fromfile+64
	DD	imagerel $unwind$array_fromfile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$array_fromfile DD 020021H
	DD	093400H
	DD	imagerel array_fromfile
	DD	imagerel array_fromfile+64
	DD	imagerel $unwind$array_fromfile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$array_fromfile DD 020521H
	DD	093405H
	DD	imagerel array_fromfile
	DD	imagerel array_fromfile+64
	DD	imagerel $unwind$array_fromfile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_fromfile DD 030801H
	DD	0c0044208H
	DD	07002H
xdata	ENDS
;	COMDAT ??_C@_0CC@GIMCCOCP@read?$CI?$CJ?5didn?8t?5return?5enough?5byte@
CONST	SEGMENT
??_C@_0CC@GIMCCOCP@read?$CI?$CJ?5didn?8t?5return?5enough?5byte@ DB 'read('
	DB	') didn''t return enough bytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
CONST	SEGMENT
??_C@_03IELNPCCE@?$CIO?$CJ?$AA@ DB '(O)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MCBECLD@read?$CI?$CJ?5didn?8t?5return?5bytes?$AA@
CONST	SEGMENT
??_C@_0BL@MCBECLD@read?$CI?$CJ?5didn?8t?5return?5bytes?$AA@ DB 'read() di'
	DB	'dn''t return bytes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EFFIKLCJ@n?$AA@
CONST	SEGMENT
??_C@_01EFFIKLCJ@n?$AA@ DB 'n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DIJHAIGC@negative?5count?$AA@
CONST	SEGMENT
??_C@_0P@DIJHAIGC@negative?5count?$AA@ DB 'negative count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LKCNGHFH@On?3fromfile?$AA@
CONST	SEGMENT
??_C@_0M@LKCNGHFH@On?3fromfile?$AA@ DB 'On:fromfile', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_fromfile
_TEXT	SEGMENT
n$ = 64
self$ = 64
args$ = 72
f$ = 80
array_fromfile PROC					; COMDAT

; 1244 : {

  00000	40 57		 push	 rdi
  00002	41 54		 push	 r12
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1245 :     PyObject *f, *b, *res;
; 1246 :     Py_ssize_t itemsize = self->ob_descr->itemsize;

  00008	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  0000f	4c 8b d2	 mov	 r10, rdx
  00012	4c 8b e1	 mov	 r12, rcx
  00015	48 63 78 04	 movsxd	 rdi, DWORD PTR [rax+4]

; 1247 :     Py_ssize_t n, nbytes;
; 1248 :     _Py_IDENTIFIER(read);
; 1249 :     int not_enough_bytes;
; 1250 : 
; 1251 :     if (!PyArg_ParseTuple(args, "On:fromfile", &f, &n))

  00019	4c 8d 4c 24 40	 lea	 r9, QWORD PTR n$[rsp]
  0001e	4c 8d 44 24 50	 lea	 r8, QWORD PTR f$[rsp]
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@LKCNGHFH@On?3fromfile?$AA@
  0002a	49 8b ca	 mov	 rcx, r10
  0002d	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00032	85 c0		 test	 eax, eax
  00034	75 0a		 jne	 SHORT $LN8@array_from@5

; 1252 :         return NULL;

  00036	33 c0		 xor	 eax, eax

; 1295 : }

  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	41 5c		 pop	 r12
  0003e	5f		 pop	 rdi
  0003f	c3		 ret	 0
$LN8@array_from@5:
  00040	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx

; 1253 : 
; 1254 :     if (n < 0) {

  00045	48 8b 5c 24 40	 mov	 rbx, QWORD PTR n$[rsp]
  0004a	48 85 db	 test	 rbx, rbx
  0004d	79 22		 jns	 SHORT $LN7@array_from@5

; 1255 :         PyErr_SetString(PyExc_ValueError, "negative count");

  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@DIJHAIGC@negative?5count?$AA@
  0005d	e8 00 00 00 00	 call	 PyErr_SetString
  00062	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]

; 1256 :         return NULL;

  00067	33 c0		 xor	 eax, eax

; 1295 : }

  00069	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006d	41 5c		 pop	 r12
  0006f	5f		 pop	 rdi
  00070	c3		 ret	 0
$LN7@array_from@5:

; 1257 :     }
; 1258 :     if (n > PY_SSIZE_T_MAX / itemsize) {

  00071	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0007b	48 99		 cdq
  0007d	48 f7 ff	 idiv	 rdi
  00080	48 3b d8	 cmp	 rbx, rax
  00083	7e 14		 jle	 SHORT $LN6@array_from@5

; 1259 :         PyErr_NoMemory();

  00085	e8 00 00 00 00	 call	 PyErr_NoMemory
  0008a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]

; 1260 :         return NULL;

  0008f	33 c0		 xor	 eax, eax

; 1295 : }

  00091	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00095	41 5c		 pop	 r12
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
$LN6@array_from@5:

; 1261 :     }
; 1262 :     nbytes = n * itemsize;
; 1263 : 
; 1264 :     b = _PyObject_CallMethodId(f, &PyId_read, "n", nbytes);

  00099	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0009f	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000a8	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_read@?1??array_fromfile@@9@9
  000ad	48 0f af df	 imul	 rbx, rdi
  000b1	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR f$[rsp]
  000ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01EFFIKLCJ@n?$AA@
  000c1	4c 8b cb	 mov	 r9, rbx
  000c4	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
  000c9	48 8b f8	 mov	 rdi, rax

; 1265 :     if (b == NULL)

  000cc	48 85 c0	 test	 rax, rax

; 1266 :         return NULL;

  000cf	74 2b		 je	 SHORT $LN15@array_from@5

; 1267 : 
; 1268 :     if (!PyBytes_Check(b)) {

  000d1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d5	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  000df	75 2a		 jne	 SHORT $LN4@array_from@5

; 1269 :         PyErr_SetString(PyExc_TypeError,
; 1270 :                         "read() didn't return bytes");

  000e1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@MCBECLD@read?$CI?$CJ?5didn?8t?5return?5bytes?$AA@
  000ef	e8 00 00 00 00	 call	 PyErr_SetString

; 1271 :         Py_DECREF(b);

  000f4	48 8b cf	 mov	 rcx, rdi
  000f7	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@array_from@5:

; 1272 :         return NULL;

  000fc	33 c0		 xor	 eax, eax
  000fe	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]

; 1295 : }

  00103	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00107	41 5c		 pop	 r12
  00109	5f		 pop	 rdi
  0010a	c3		 ret	 0
$LN4@array_from@5:
  0010b	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp

; 1273 :     }
; 1274 : 
; 1275 :     not_enough_bytes = (PyBytes_GET_SIZE(b) != nbytes);

  00110	33 ed		 xor	 ebp, ebp
  00112	48 39 5f 60	 cmp	 QWORD PTR [rdi+96], rbx

; 1276 : 
; 1277 :     args = Py_BuildValue("(O)", b);

  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  0011d	48 8b d7	 mov	 rdx, rdi
  00120	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00125	40 0f 95 c5	 setne	 bpl
  00129	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 1278 :     Py_DECREF(b);

  0012e	48 8b cf	 mov	 rcx, rdi
  00131	48 8b f0	 mov	 rsi, rax
  00134	e8 00 00 00 00	 call	 _Py_DecRef

; 1279 :     if (args == NULL)

  00139	48 85 f6	 test	 rsi, rsi

; 1280 :         return NULL;

  0013c	74 3a		 je	 SHORT $LN14@array_from@5

; 1281 : 
; 1282 :     res = array_frombytes(self, args);

  0013e	48 8b d6	 mov	 rdx, rsi
  00141	49 8b cc	 mov	 rcx, r12
  00144	e8 00 00 00 00	 call	 array_frombytes

; 1283 :     Py_DECREF(args);

  00149	48 8b ce	 mov	 rcx, rsi
  0014c	48 8b d8	 mov	 rbx, rax
  0014f	e8 00 00 00 00	 call	 _Py_DecRef

; 1284 :     if (res == NULL)

  00154	48 85 db	 test	 rbx, rbx

; 1285 :         return NULL;

  00157	74 1f		 je	 SHORT $LN14@array_from@5

; 1286 : 
; 1287 :     if (not_enough_bytes) {

  00159	85 ed		 test	 ebp, ebp
  0015b	74 1f		 je	 SHORT $LN1@array_from@5

; 1288 :         PyErr_SetString(PyExc_EOFError,
; 1289 :                         "read() didn't return enough bytes");

  0015d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_EOFError
  00164	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@GIMCCOCP@read?$CI?$CJ?5didn?8t?5return?5enough?5byte@
  0016b	e8 00 00 00 00	 call	 PyErr_SetString

; 1290 :         Py_DECREF(res);

  00170	48 8b cb	 mov	 rcx, rbx
  00173	e8 00 00 00 00	 call	 _Py_DecRef
$LN14@array_from@5:

; 1291 :         return NULL;

  00178	33 c0		 xor	 eax, eax
  0017a	eb 03		 jmp	 SHORT $LN13@array_from@5
$LN1@array_from@5:

; 1292 :     }
; 1293 : 
; 1294 :     return res;

  0017c	48 8b c3	 mov	 rax, rbx
$LN13@array_from@5:
  0017f	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00184	48 8b 74 24 20	 mov	 rsi, QWORD PTR [rsp+32]
  00189	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]

; 1295 : }

  0018e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00192	41 5c		 pop	 r12
  00194	5f		 pop	 rdi
  00195	c3		 ret	 0
array_fromfile ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$make_array DD imagerel make_array
	DD	imagerel make_array+192
	DD	imagerel $unwind$make_array
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$make_array DD 083f01H
	DD	08743fH
	DD	0a540fH
	DD	09340fH
	DD	0600b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\arraymodule.c
xdata	ENDS
;	COMDAT make_array
_TEXT	SEGMENT
arraytype$ = 64
typecode$ = 72
items$ = 80
make_array PROC						; COMDAT

; 1776 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b e9	 mov	 rbp, rcx

; 1777 :     PyObject *new_args;
; 1778 :     PyObject *array_obj;
; 1779 :     PyObject *typecode_obj;
; 1780 : 
; 1781 :     assert(arraytype != NULL);
; 1782 :     assert(items != NULL);
; 1783 : 
; 1784 :     typecode_obj = PyUnicode_FromOrdinal(typecode);

  00012	0f be ca	 movsx	 ecx, dl
  00015	49 8b d8	 mov	 rbx, r8
  00018	e8 00 00 00 00	 call	 PyUnicode_FromOrdinal
  0001d	48 8b f0	 mov	 rsi, rax

; 1785 :     if (typecode_obj == NULL)

  00020	48 85 c0	 test	 rax, rax
  00023	75 10		 jne	 SHORT $LN3@make_array

; 1798 :         return NULL;
; 1799 : 
; 1800 :     return array_obj;
; 1801 : }

  00025	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0002a	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0002f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00033	5e		 pop	 rsi
  00034	c3		 ret	 0
$LN3@make_array:

; 1786 :         return NULL;
; 1787 : 
; 1788 :     new_args = PyTuple_New(2);

  00035	b9 02 00 00 00	 mov	 ecx, 2
  0003a	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0003f	e8 00 00 00 00	 call	 PyTuple_New
  00044	48 8b f8	 mov	 rdi, rax

; 1789 :     if (new_args == NULL)

  00047	48 85 c0	 test	 rax, rax
  0004a	74 5f		 je	 SHORT $LN10@make_array
$LN2@make_array:

; 1790 :         return NULL;
; 1791 :     Py_INCREF(items);

  0004c	e8 00 00 00 00	 call	 _Py_PXCTX
  00051	85 c0		 test	 eax, eax
  00053	75 32		 jne	 SHORT $LN7@make_array
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00063	4c 8b cb	 mov	 r9, rbx
  00066	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0006c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00074	e8 00 00 00 00	 call	 _PyParallel_Guard
  00079	85 c0		 test	 eax, eax
  0007b	75 06		 jne	 SHORT $LN6@make_array
  0007d	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00081	74 04		 je	 SHORT $LN7@make_array
$LN6@make_array:
  00083	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN7@make_array:

; 1792 :     PyTuple_SET_ITEM(new_args, 0, typecode_obj);
; 1793 :     PyTuple_SET_ITEM(new_args, 1, items);
; 1794 : 
; 1795 :     array_obj = array_new(arraytype, new_args, NULL);

  00087	45 33 c0	 xor	 r8d, r8d
  0008a	48 8b d7	 mov	 rdx, rdi
  0008d	48 8b cd	 mov	 rcx, rbp
  00090	48 89 77 70	 mov	 QWORD PTR [rdi+112], rsi
  00094	48 89 5f 78	 mov	 QWORD PTR [rdi+120], rbx
  00098	e8 00 00 00 00	 call	 array_new

; 1796 :     Py_DECREF(new_args);

  0009d	48 8b cf	 mov	 rcx, rdi
  000a0	48 8b d8	 mov	 rbx, rax
  000a3	e8 00 00 00 00	 call	 _Py_DecRef

; 1797 :     if (array_obj == NULL)

  000a8	48 8b c3	 mov	 rax, rbx
$LN10@make_array:

; 1798 :         return NULL;
; 1799 : 
; 1800 :     return array_obj;
; 1801 : }

  000ab	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000b0	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000b5	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000ba	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000be	5e		 pop	 rsi
  000bf	c3		 ret	 0
make_array ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@LPGEONDD@third?5argument?5must?5be?5a?5valid?5m@ ; `string'
PUBLIC	??_C@_06OLFOGHEN@strict?$AA@			; `string'
PUBLIC	??_C@_0CM@KIFEFODB@fourth?5argument?5should?5be?5bytes?0@ ; `string'
PUBLIC	??_C@_0CK@IOECFFFB@second?5argument?5must?5be?5a?5valid?5@ ; `string'
PUBLIC	??_C@_0CC@KBLJKDGE@?$CF?4200s?5is?5not?5a?5subtype?5of?5?$CF?4200@ ; `string'
PUBLIC	??_C@_0CO@GMHDDNBE@first?5argument?5must?5a?5type?5objec@ ; `string'
PUBLIC	??_C@_0CA@FLLPLEGM@OCiO?3array?4_array_reconstructor?$AA@ ; `string'
EXTRN	_PyLong_FromByteArray:PROC
EXTRN	PyUnicode_DecodeUTF32:PROC
EXTRN	PyUnicode_DecodeUTF16:PROC
EXTRN	_PyFloat_Unpack8:PROC
EXTRN	_PyFloat_Unpack4:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_reconstructor DD imagerel array_reconstructor
	DD	imagerel array_reconstructor+366
	DD	imagerel $unwind$array_reconstructor
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$array_reconstructor DD imagerel array_reconstructor+366
	DD	imagerel array_reconstructor+436
	DD	imagerel $chain$1$array_reconstructor
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$array_reconstructor DD imagerel array_reconstructor+436
	DD	imagerel array_reconstructor+890
	DD	imagerel $chain$7$array_reconstructor
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$array_reconstructor DD imagerel array_reconstructor+890
	DD	imagerel array_reconstructor+911
	DD	imagerel $chain$8$array_reconstructor
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$array_reconstructor DD imagerel array_reconstructor+911
	DD	imagerel array_reconstructor+1182
	DD	imagerel $chain$10$array_reconstructor
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$array_reconstructor DD imagerel array_reconstructor+1182
	DD	imagerel array_reconstructor+1236
	DD	imagerel $chain$11$array_reconstructor
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$array_reconstructor DD imagerel array_reconstructor+1236
	DD	imagerel array_reconstructor+1278
	DD	imagerel $chain$12$array_reconstructor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$array_reconstructor DD 0100021H
	DD	0cf400H
	DD	0de400H
	DD	0ed400H
	DD	0fc400H
	DD	0107400H
	DD	0116400H
	DD	0125400H
	DD	0143400H
	DD	imagerel array_reconstructor
	DD	imagerel array_reconstructor+366
	DD	imagerel $unwind$array_reconstructor
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$array_reconstructor DD 021H
	DD	imagerel array_reconstructor
	DD	imagerel array_reconstructor+366
	DD	imagerel $unwind$array_reconstructor
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$array_reconstructor DD 0100021H
	DD	0cf400H
	DD	0de400H
	DD	0ed400H
	DD	0fc400H
	DD	0107400H
	DD	0116400H
	DD	0125400H
	DD	0143400H
	DD	imagerel array_reconstructor
	DD	imagerel array_reconstructor+366
	DD	imagerel $unwind$array_reconstructor
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$array_reconstructor DD 021H
	DD	imagerel array_reconstructor+366
	DD	imagerel array_reconstructor+436
	DD	imagerel $chain$1$array_reconstructor
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$array_reconstructor DD 0c2721H
	DD	0cf427H
	DD	0de422H
	DD	0ed41dH
	DD	0107418H
	DD	0116410H
	DD	0125408H
	DD	imagerel array_reconstructor+366
	DD	imagerel array_reconstructor+436
	DD	imagerel $chain$1$array_reconstructor
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$array_reconstructor DD 040d21H
	DD	0fc40dH
	DD	0143408H
	DD	imagerel array_reconstructor
	DD	imagerel array_reconstructor+366
	DD	imagerel $unwind$array_reconstructor
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_reconstructor DD 020a01H
	DD	013010aH
xdata	ENDS
;	COMDAT ??_C@_0DE@LPGEONDD@third?5argument?5must?5be?5a?5valid?5m@
CONST	SEGMENT
??_C@_0DE@LPGEONDD@third?5argument?5must?5be?5a?5valid?5m@ DB 'third argu'
	DB	'ment must be a valid machine format code.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OLFOGHEN@strict?$AA@
CONST	SEGMENT
??_C@_06OLFOGHEN@strict?$AA@ DB 'strict', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@KIFEFODB@fourth?5argument?5should?5be?5bytes?0@
CONST	SEGMENT
??_C@_0CM@KIFEFODB@fourth?5argument?5should?5be?5bytes?0@ DB 'fourth argu'
	DB	'ment should be bytes, not %.200s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IOECFFFB@second?5argument?5must?5be?5a?5valid?5@
CONST	SEGMENT
??_C@_0CK@IOECFFFB@second?5argument?5must?5be?5a?5valid?5@ DB 'second arg'
	DB	'ument must be a valid type code', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KBLJKDGE@?$CF?4200s?5is?5not?5a?5subtype?5of?5?$CF?4200@
CONST	SEGMENT
??_C@_0CC@KBLJKDGE@?$CF?4200s?5is?5not?5a?5subtype?5of?5?$CF?4200@ DB '%.'
	DB	'200s is not a subtype of %.200s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GMHDDNBE@first?5argument?5must?5a?5type?5objec@
CONST	SEGMENT
??_C@_0CO@GMHDDNBE@first?5argument?5must?5a?5type?5objec@ DB 'first argum'
	DB	'ent must a type object, not %.200s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FLLPLEGM@OCiO?3array?4_array_reconstructor?$AA@
CONST	SEGMENT
??_C@_0CA@FLLPLEGM@OCiO?3array?4_array_reconstructor?$AA@ DB 'OCiO:array.'
	DB	'_array_reconstructor', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT array_reconstructor
_TEXT	SEGMENT
byteorder$21849 = 48
byteorder$21858 = 52
arraytype$ = 56
items$ = 64
mf_descr$21867 = 72
self$ = 160
args$ = 168
typecode$ = 176
mformat_code$ = 184
array_reconstructor PROC				; COMDAT

; 1809 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1810 :     PyTypeObject *arraytype;
; 1811 :     PyObject *items;
; 1812 :     PyObject *converted_items;
; 1813 :     PyObject *result;
; 1814 :     int typecode;
; 1815 :     enum machine_format_code mformat_code;
; 1816 :     struct arraydescr *descr;
; 1817 : 
; 1818 :     if (!PyArg_ParseTuple(args, "OCiO:array._array_reconstructor",
; 1819 :                     &arraytype, &typecode, &mformat_code, &items))

  0000a	49 8d 4b a8	 lea	 rcx, QWORD PTR [r11-88]
  0000e	48 8b c2	 mov	 rax, rdx
  00011	4d 8d 4b 18	 lea	 r9, QWORD PTR [r11+24]
  00015	49 89 4b 90	 mov	 QWORD PTR [r11-112], rcx
  00019	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0001d	4d 8d 43 a0	 lea	 r8, QWORD PTR [r11-96]
  00021	49 89 4b 88	 mov	 QWORD PTR [r11-120], rcx
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@FLLPLEGM@OCiO?3array?4_array_reconstructor?$AA@
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00034	85 c0		 test	 eax, eax

; 1820 :         return NULL;

  00036	74 2d		 je	 SHORT $LN72@array_reco

; 1821 : 
; 1822 :     if (!PyType_Check(arraytype)) {

  00038	48 8b 4c 24 38	 mov	 rcx, QWORD PTR arraytype$[rsp]
  0003d	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  00041	41 f7 80 00 01
	00 00 00 00 00
	80		 test	 DWORD PTR [r8+256], -2147483648 ; ffffffff80000000H
  0004c	75 21		 jne	 SHORT $LN42@array_reco

; 1823 :         PyErr_Format(PyExc_TypeError,
; 1824 :             "first argument must a type object, not %.200s",
; 1825 :             Py_TYPE(arraytype)->tp_name);

  0004e	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00052	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@GMHDDNBE@first?5argument?5must?5a?5type?5objec@
  00060	e8 00 00 00 00	 call	 PyErr_Format
$LN72@array_reco:

; 1826 :         return NULL;

  00065	33 c0		 xor	 eax, eax

; 2008 : }

  00067	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0006e	c3		 ret	 0
$LN42@array_reco:

; 1827 :     }
; 1828 :     if (!PyType_IsSubtype(arraytype, &Arraytype)) {

  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  00076	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007b	85 c0		 test	 eax, eax
  0007d	75 2d		 jne	 SHORT $LN41@array_reco

; 1829 :         PyErr_Format(PyExc_TypeError,
; 1830 :             "%.200s is not a subtype of %.200s",
; 1831 :             arraytype->tp_name, Arraytype.tp_name);

  0007f	4c 8b 44 24 38	 mov	 r8, QWORD PTR arraytype$[rsp]
  00084	4c 8b 0d 70 00
	00 00		 mov	 r9, QWORD PTR Arraytype+112
  0008b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00092	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@KBLJKDGE@?$CF?4200s?5is?5not?5a?5subtype?5of?5?$CF?4200@
  0009d	e8 00 00 00 00	 call	 PyErr_Format

; 1832 :         return NULL;

  000a2	33 c0		 xor	 eax, eax

; 2008 : }

  000a4	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  000ab	c3		 ret	 0
$LN41@array_reco:

; 1833 :     }
; 1834 :     for (descr = descriptors; descr->typecode != '\0'; descr++) {

  000ac	44 0f b6 05 00
	00 00 00	 movzx	 r8d, BYTE PTR descriptors
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:descriptors
  000bb	45 84 c0	 test	 r8b, r8b
  000be	74 24		 je	 SHORT $LN60@array_reco
  000c0	44 8b 94 24 b0
	00 00 00	 mov	 r10d, DWORD PTR typecode$[rsp]
  000c8	41 0f b6 c0	 movzx	 eax, r8b
  000cc	0f 1f 40 00	 npad	 4
$LL40@array_reco:

; 1835 :         if ((int)descr->typecode == typecode)

  000d0	0f be c0	 movsx	 eax, al
  000d3	41 3b c2	 cmp	 eax, r10d
  000d6	74 29		 je	 SHORT $LN51@array_reco

; 1833 :     }
; 1834 :     for (descr = descriptors; descr->typecode != '\0'; descr++) {

  000d8	0f b6 41 28	 movzx	 eax, BYTE PTR [rcx+40]
  000dc	48 83 c1 28	 add	 rcx, 40			; 00000028H
  000e0	84 c0		 test	 al, al
  000e2	75 ec		 jne	 SHORT $LL40@array_reco
$LN60@array_reco:

; 1839 :         PyErr_SetString(PyExc_ValueError,
; 1840 :                         "second argument must be a valid type code");

  000e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@IOECFFFB@second?5argument?5must?5be?5a?5valid?5@
  000f2	e8 00 00 00 00	 call	 PyErr_SetString

; 1841 :         return NULL;

  000f7	33 c0		 xor	 eax, eax

; 2008 : }

  000f9	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00100	c3		 ret	 0
$LN51@array_reco:

; 1836 :             break;
; 1837 :     }
; 1838 :     if (descr->typecode == '\0') {

  00101	80 39 00	 cmp	 BYTE PTR [rcx], 0
  00104	74 de		 je	 SHORT $LN60@array_reco

; 1842 :     }
; 1843 :     if (mformat_code < MACHINE_FORMAT_CODE_MIN ||
; 1844 :         mformat_code > MACHINE_FORMAT_CODE_MAX) {

  00106	4c 63 8c 24 b8
	00 00 00	 movsxd	 r9, DWORD PTR mformat_code$[rsp]
  0010e	41 83 f9 15	 cmp	 r9d, 21
  00112	0f 87 9f 03 00
	00		 ja	 $LN34@array_reco

; 1848 :     }
; 1849 :     if (!PyBytes_Check(items)) {

  00118	4c 8b 5c 24 40	 mov	 r11, QWORD PTR items$[rsp]
  0011d	49 8b 43 58	 mov	 rax, QWORD PTR [r11+88]
  00121	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  0012b	75 21		 jne	 SHORT $LN33@array_reco

; 1850 :         PyErr_Format(PyExc_TypeError,
; 1851 :             "fourth argument should be bytes, not %.200s",
; 1852 :             Py_TYPE(items)->tp_name);

  0012d	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00131	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00138	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@KIFEFODB@fourth?5argument?5should?5be?5bytes?0@
  0013f	e8 00 00 00 00	 call	 PyErr_Format

; 1853 :         return NULL;

  00144	33 c0		 xor	 eax, eax

; 2008 : }

  00146	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0014d	c3		 ret	 0
$LN33@array_reco:

; 1854 :     }
; 1855 : 
; 1856 :     /* Fast path: No decoding has to be done. */
; 1857 :     if (mformat_code == typecode_to_mformat_code((char)typecode) ||
; 1858 :         mformat_code == UNKNOWN_FORMAT) {

  0014e	41 0f b6 ca	 movzx	 ecx, r10b
  00152	e8 00 00 00 00	 call	 typecode_to_mformat_code
  00157	44 3b c8	 cmp	 r9d, eax
  0015a	0f 84 3e 03 00
	00		 je	 $LN31@array_reco
  00160	41 83 f9 ff	 cmp	 r9d, -1
  00164	0f 84 34 03 00
	00		 je	 $LN31@array_reco

; 1860 :     }
; 1861 : 
; 1862 :     /* Slow path: Decode the byte string according to the given machine
; 1863 :      * format code. This occurs when the computer unpickling the array
; 1864 :      * object is architecturally different from the one that pickled the
; 1865 :      * array.
; 1866 :      */
; 1867 :     if (Py_SIZE(items) % mformat_descriptors[mformat_code].size != 0) {

  0016a	4d 8b 53 60	 mov	 r10, QWORD PTR [r11+96]
  0016e	48 89 9c 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rbx
  00176	4c 89 64 24 78	 mov	 QWORD PTR [rsp+120], r12
  0017b	33 d2		 xor	 edx, edx
  0017d	4d 8b e1	 mov	 r12, r9
  00180	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:__ImageBase
  00187	4d 03 e4	 add	 r12, r12
  0018a	49 8b c2	 mov	 rax, r10
  0018d	4a f7 b4 e3 00
	00 00 00	 div	 QWORD PTR mformat_descriptors[rbx+r12*8]
  00195	48 85 d2	 test	 rdx, rdx
  00198	74 1a		 je	 SHORT $LN30@array_reco

; 1868 :         PyErr_SetString(PyExc_ValueError,
; 1869 :                         "string length not a multiple of item size");

  0019a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@CCOBPACL@string?5length?5not?5a?5multiple?5of?5@
  001a8	e8 00 00 00 00	 call	 PyErr_SetString

; 1870 :         return NULL;

  001ad	33 c0		 xor	 eax, eax
  001af	e9 c6 01 00 00	 jmp	 $LN64@array_reco
$LN30@array_reco:
  001b4	48 89 ac 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbp
  001bc	48 89 b4 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rsi
  001c4	48 89 bc 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rdi
  001cc	4c 89 6c 24 70	 mov	 QWORD PTR [rsp+112], r13
  001d1	4c 89 74 24 68	 mov	 QWORD PTR [rsp+104], r14
  001d6	4c 89 7c 24 60	 mov	 QWORD PTR [rsp+96], r15

; 1871 :     }
; 1872 :     switch (mformat_code) {

  001db	41 83 f9 15	 cmp	 r9d, 21
  001df	0f 87 af 02 00
	00		 ja	 $LN1@array_reco
  001e5	42 0f b6 8c 0b
	00 00 00 00	 movzx	 ecx, BYTE PTR $LN61@array_reco[rbx+r9]
  001ee	8b 94 8b 00 00
	00 00		 mov	 edx, DWORD PTR $LN62@array_reco[rbx+rcx*4]
  001f5	48 03 d3	 add	 rdx, rbx
  001f8	ff e2		 jmp	 rdx
$LN27@array_reco:

; 1873 :     case IEEE_754_FLOAT_LE:
; 1874 :     case IEEE_754_FLOAT_BE: {
; 1875 :         int i;
; 1876 :         int le = (mformat_code == IEEE_754_FLOAT_LE) ? 1 : 0;
; 1877 :         Py_ssize_t itemcount = Py_SIZE(items) / 4;

  001fa	49 8b c2	 mov	 rax, r10
  001fd	33 db		 xor	 ebx, ebx
  001ff	41 83 f9 0e	 cmp	 r9d, 14
  00203	48 99		 cdq
  00205	44 8b eb	 mov	 r13d, ebx
  00208	41 0f 94 c5	 sete	 r13b
  0020c	83 e2 03	 and	 edx, 3

; 1878 :         const unsigned char *memstr =
; 1879 :             (unsigned char *)PyBytes_AS_STRING(items);

  0020f	4d 8d 73 78	 lea	 r14, QWORD PTR [r11+120]
  00213	48 03 c2	 add	 rax, rdx
  00216	48 c1 f8 02	 sar	 rax, 2

; 1880 : 
; 1881 :         converted_items = PyList_New(itemcount);

  0021a	48 8b c8	 mov	 rcx, rax
  0021d	4c 8b e0	 mov	 r12, rax
  00220	e8 00 00 00 00	 call	 PyList_New
  00225	48 8b f8	 mov	 rdi, rax

; 1882 :         if (converted_items == NULL)

  00228	48 85 c0	 test	 rax, rax

; 1883 :             return NULL;

  0022b	0f 84 20 01 00
	00		 je	 $LN71@array_reco

; 1884 :         for (i = 0; i < itemcount; i++) {

  00231	4d 85 e4	 test	 r12, r12
  00234	7e 3f		 jle	 SHORT $LN3@array_reco
  00236	8b f3		 mov	 esi, ebx
  00238	8b eb		 mov	 ebp, ebx
  0023a	66 0f 1f 44 00
	00		 npad	 6
$LL25@array_reco:

; 1885 :             PyObject *pyfloat = PyFloat_FromDouble(
; 1886 :                 _PyFloat_Unpack4(&memstr[i * 4], le));

  00240	48 63 cd	 movsxd	 rcx, ebp
  00243	41 8b d5	 mov	 edx, r13d
  00246	49 03 ce	 add	 rcx, r14
  00249	e8 00 00 00 00	 call	 _PyFloat_Unpack4
  0024e	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 1887 :             if (pyfloat == NULL) {

  00253	48 85 c0	 test	 rax, rax
  00256	0f 84 2b 02 00
	00		 je	 $LN54@array_reco

; 1888 :                 Py_DECREF(converted_items);
; 1889 :                 return NULL;
; 1890 :             }
; 1891 :             PyList_SET_ITEM(converted_items, i, pyfloat);

  0025c	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  00260	ff c3		 inc	 ebx
  00262	83 c5 04	 add	 ebp, 4
  00265	48 89 04 0e	 mov	 QWORD PTR [rsi+rcx], rax
  00269	48 63 c3	 movsxd	 rax, ebx
  0026c	48 83 c6 08	 add	 rsi, 8
  00270	49 3b c4	 cmp	 rax, r12
  00273	7c cb		 jl	 SHORT $LL25@array_reco
$LN3@array_reco:

; 2003 :     }
; 2004 : 
; 2005 :     result = make_array(arraytype, (char)typecode, converted_items);

  00275	0f b6 94 24 b0
	00 00 00	 movzx	 edx, BYTE PTR typecode$[rsp]
  0027d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR arraytype$[rsp]
  00282	4c 8b c7	 mov	 r8, rdi
  00285	e8 00 00 00 00	 call	 make_array

; 2006 :     Py_DECREF(converted_items);

  0028a	48 8b cf	 mov	 rcx, rdi
  0028d	48 8b d8	 mov	 rbx, rax
  00290	e8 00 00 00 00	 call	 _Py_DecRef

; 2007 :     return result;

  00295	48 8b c3	 mov	 rax, rbx
  00298	e9 b6 00 00 00	 jmp	 $LN70@array_reco
$LN21@array_reco:

; 1892 :         }
; 1893 :         break;
; 1894 :     }
; 1895 :     case IEEE_754_DOUBLE_LE:
; 1896 :     case IEEE_754_DOUBLE_BE: {
; 1897 :         int i;
; 1898 :         int le = (mformat_code == IEEE_754_DOUBLE_LE) ? 1 : 0;
; 1899 :         Py_ssize_t itemcount = Py_SIZE(items) / 8;

  0029d	49 8b c2	 mov	 rax, r10
  002a0	33 db		 xor	 ebx, ebx
  002a2	41 83 f9 10	 cmp	 r9d, 16
  002a6	48 99		 cdq
  002a8	44 8b eb	 mov	 r13d, ebx
  002ab	41 0f 94 c5	 sete	 r13b
  002af	83 e2 07	 and	 edx, 7

; 1900 :         const unsigned char *memstr =
; 1901 :             (unsigned char *)PyBytes_AS_STRING(items);

  002b2	4d 8d 73 78	 lea	 r14, QWORD PTR [r11+120]
  002b6	48 03 c2	 add	 rax, rdx
  002b9	48 c1 f8 03	 sar	 rax, 3

; 1902 : 
; 1903 :         converted_items = PyList_New(itemcount);

  002bd	48 8b c8	 mov	 rcx, rax
  002c0	4c 8b e0	 mov	 r12, rax
  002c3	e8 00 00 00 00	 call	 PyList_New
  002c8	48 8b f8	 mov	 rdi, rax

; 1904 :         if (converted_items == NULL)

  002cb	48 85 c0	 test	 rax, rax

; 1905 :             return NULL;

  002ce	0f 84 7d 00 00
	00		 je	 $LN71@array_reco

; 1906 :         for (i = 0; i < itemcount; i++) {

  002d4	4d 85 e4	 test	 r12, r12
  002d7	7e 9c		 jle	 SHORT $LN3@array_reco
  002d9	8b f3		 mov	 esi, ebx
  002db	8b eb		 mov	 ebp, ebx
  002dd	0f 1f 00	 npad	 3
$LL19@array_reco:

; 1907 :             PyObject *pyfloat = PyFloat_FromDouble(
; 1908 :                 _PyFloat_Unpack8(&memstr[i * 8], le));

  002e0	48 63 cd	 movsxd	 rcx, ebp
  002e3	41 8b d5	 mov	 edx, r13d
  002e6	49 03 ce	 add	 rcx, r14
  002e9	e8 00 00 00 00	 call	 _PyFloat_Unpack8
  002ee	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 1909 :             if (pyfloat == NULL) {

  002f3	48 85 c0	 test	 rax, rax
  002f6	0f 84 8b 01 00
	00		 je	 $LN54@array_reco

; 1910 :                 Py_DECREF(converted_items);
; 1911 :                 return NULL;
; 1912 :             }
; 1913 :             PyList_SET_ITEM(converted_items, i, pyfloat);

  002fc	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  00300	ff c3		 inc	 ebx
  00302	83 c5 08	 add	 ebp, 8
  00305	48 89 04 0e	 mov	 QWORD PTR [rsi+rcx], rax
  00309	48 63 c3	 movsxd	 rax, ebx
  0030c	48 83 c6 08	 add	 rsi, 8
  00310	49 3b c4	 cmp	 rax, r12
  00313	7c cb		 jl	 SHORT $LL19@array_reco

; 1988 :             if (pylong == NULL) {

  00315	e9 5b ff ff ff	 jmp	 $LN3@array_reco
$LN15@array_reco:

; 1914 :         }
; 1915 :         break;
; 1916 :     }
; 1917 :     case UTF16_LE:
; 1918 :     case UTF16_BE: {
; 1919 :         int byteorder = (mformat_code == UTF16_LE) ? -1 : 1;

  0031a	83 c9 ff	 or	 ecx, -1
  0031d	41 83 f9 12	 cmp	 r9d, 18
  00321	b8 01 00 00 00	 mov	 eax, 1
  00326	0f 44 c1	 cmove	 eax, ecx

; 1920 :         converted_items = PyUnicode_DecodeUTF16(
; 1921 :             PyBytes_AS_STRING(items), Py_SIZE(items),
; 1922 :             "strict", &byteorder);

  00329	4c 8d 4c 24 30	 lea	 r9, QWORD PTR byteorder$21849[rsp]
  0032e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  00335	49 8d 4b 78	 lea	 rcx, QWORD PTR [r11+120]
  00339	49 8b d2	 mov	 rdx, r10
  0033c	89 44 24 30	 mov	 DWORD PTR byteorder$21849[rsp], eax
  00340	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF16
$LN73@array_reco:

; 1930 :         converted_items = PyUnicode_DecodeUTF32(
; 1931 :             PyBytes_AS_STRING(items), Py_SIZE(items),
; 1932 :             "strict", &byteorder);

  00345	48 8b f8	 mov	 rdi, rax

; 1933 :         if (converted_items == NULL)

  00348	48 85 c0	 test	 rax, rax
  0034b	0f 85 24 ff ff
	ff		 jne	 $LN3@array_reco
$LN71@array_reco:

; 1990 :                 return NULL;

  00351	33 c0		 xor	 eax, eax
$LN70@array_reco:
  00353	4c 8b 74 24 68	 mov	 r14, QWORD PTR [rsp+104]
  00358	4c 8b 6c 24 70	 mov	 r13, QWORD PTR [rsp+112]
  0035d	48 8b ac 24 90
	00 00 00	 mov	 rbp, QWORD PTR [rsp+144]
  00365	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR [rsp+128]
  0036d	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR [rsp+136]
  00375	4c 8b 7c 24 60	 mov	 r15, QWORD PTR [rsp+96]
$LN64@array_reco:
  0037a	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]
  00382	4c 8b 64 24 78	 mov	 r12, QWORD PTR [rsp+120]

; 2008 : }

  00387	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0038e	c3		 ret	 0
$LN13@array_reco:

; 1923 :         if (converted_items == NULL)
; 1924 :             return NULL;
; 1925 :         break;
; 1926 :     }
; 1927 :     case UTF32_LE:
; 1928 :     case UTF32_BE: {
; 1929 :         int byteorder = (mformat_code == UTF32_LE) ? -1 : 1;

  0038f	83 c9 ff	 or	 ecx, -1
  00392	41 83 f9 14	 cmp	 r9d, 20
  00396	b8 01 00 00 00	 mov	 eax, 1
  0039b	0f 44 c1	 cmove	 eax, ecx

; 1930 :         converted_items = PyUnicode_DecodeUTF32(
; 1931 :             PyBytes_AS_STRING(items), Py_SIZE(items),
; 1932 :             "strict", &byteorder);

  0039e	4c 8d 4c 24 34	 lea	 r9, QWORD PTR byteorder$21858[rsp]
  003a3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  003aa	49 8d 4b 78	 lea	 rcx, QWORD PTR [r11+120]
  003ae	49 8b d2	 mov	 rdx, r10
  003b1	89 44 24 34	 mov	 DWORD PTR byteorder$21858[rsp], eax
  003b5	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF32

; 1934 :             return NULL;

  003ba	eb 89		 jmp	 SHORT $LN73@array_reco
$LN11@array_reco:

; 1935 :         break;
; 1936 :     }
; 1937 : 
; 1938 :     case UNSIGNED_INT8:
; 1939 :     case SIGNED_INT8:
; 1940 :     case UNSIGNED_INT16_LE:
; 1941 :     case UNSIGNED_INT16_BE:
; 1942 :     case SIGNED_INT16_LE:
; 1943 :     case SIGNED_INT16_BE:
; 1944 :     case UNSIGNED_INT32_LE:
; 1945 :     case UNSIGNED_INT32_BE:
; 1946 :     case SIGNED_INT32_LE:
; 1947 :     case SIGNED_INT32_BE:
; 1948 :     case UNSIGNED_INT64_LE:
; 1949 :     case UNSIGNED_INT64_BE:
; 1950 :     case SIGNED_INT64_LE:
; 1951 :     case SIGNED_INT64_BE: {
; 1952 :         int i;
; 1953 :         const struct mformatdescr mf_descr =
; 1954 :             mformat_descriptors[mformat_code];

  003bc	4a 8b ac e3 00
	00 00 00	 mov	 rbp, QWORD PTR mformat_descriptors[rbx+r12*8]
  003c4	4e 8b a4 e3 08
	00 00 00	 mov	 r12, QWORD PTR mformat_descriptors[rbx+r12*8+8]

; 1955 :         Py_ssize_t itemcount = Py_SIZE(items) / mf_descr.size;

  003cc	33 d2		 xor	 edx, edx
  003ce	49 8b c2	 mov	 rax, r10

; 1956 :         const unsigned char *memstr =
; 1957 :             (unsigned char *)PyBytes_AS_STRING(items);

  003d1	4d 8d 7b 78	 lea	 r15, QWORD PTR [r11+120]
  003d5	4c 89 64 24 50	 mov	 QWORD PTR mf_descr$21867[rsp+8], r12
  003da	48 f7 f5	 div	 rbp
  003dd	48 8d 15 04 00
	00 00		 lea	 rdx, OFFSET FLAT:descriptors+4
  003e4	4c 8b e8	 mov	 r13, rax
$LL10@array_reco:

; 1971 :             if (descr->is_integer_type &&
; 1972 :                 descr->itemsize == mf_descr.size &&
; 1973 :                 descr->is_signed == mf_descr.is_signed)

  003e7	83 7a 1c 00	 cmp	 DWORD PTR [rdx+28], 0
  003eb	74 19		 je	 SHORT $LN9@array_reco
  003ed	48 63 0a	 movsxd	 rcx, DWORD PTR [rdx]
  003f0	48 3b cd	 cmp	 rcx, rbp
  003f3	75 11		 jne	 SHORT $LN9@array_reco
  003f5	44 39 62 20	 cmp	 DWORD PTR [rdx+32], r12d
  003f9	75 0b		 jne	 SHORT $LN9@array_reco

; 1974 :                 typecode = descr->typecode;

  003fb	41 0f be c0	 movsx	 eax, r8b
  003ff	89 84 24 b0 00
	00 00		 mov	 DWORD PTR typecode$[rsp], eax
$LN9@array_reco:

; 1958 :         struct arraydescr *descr;
; 1959 : 
; 1960 :         /* If possible, try to pack array's items using a data type
; 1961 :          * that fits better. This may result in an array with narrower
; 1962 :          * or wider elements.
; 1963 :          *
; 1964 :          * For example, if a 32-bit machine pickles a L-code array of
; 1965 :          * unsigned longs, then the array will be unpickled by 64-bit
; 1966 :          * machine as an I-code array of unsigned ints.
; 1967 :          *
; 1968 :          * XXX: Is it possible to write a unit test for this?
; 1969 :          */
; 1970 :         for (descr = descriptors; descr->typecode != '\0'; descr++) {

  00406	0f b6 42 24	 movzx	 eax, BYTE PTR [rdx+36]
  0040a	48 83 c2 28	 add	 rdx, 40			; 00000028H
  0040e	44 0f b6 c0	 movzx	 r8d, al
  00412	84 c0		 test	 al, al
  00414	75 d1		 jne	 SHORT $LL10@array_reco

; 1975 :         }
; 1976 : 
; 1977 :         converted_items = PyList_New(itemcount);

  00416	49 8b cd	 mov	 rcx, r13
  00419	e8 00 00 00 00	 call	 PyList_New
  0041e	48 8b f8	 mov	 rdi, rax

; 1978 :         if (converted_items == NULL)

  00421	48 85 c0	 test	 rax, rax

; 1979 :             return NULL;

  00424	0f 84 27 ff ff
	ff		 je	 $LN71@array_reco

; 1980 :         for (i = 0; i < itemcount; i++) {

  0042a	33 db		 xor	 ebx, ebx
  0042c	4d 85 ed	 test	 r13, r13
  0042f	0f 8e 40 fe ff
	ff		 jle	 $LN3@array_reco

; 1981 :             PyObject *pylong;
; 1982 : 
; 1983 :             pylong = _PyLong_FromByteArray(
; 1984 :                 &memstr[i * mf_descr.size],
; 1985 :                 mf_descr.size,
; 1986 :                 !mf_descr.is_big_endian,
; 1987 :                 mf_descr.is_signed);

  00435	39 5c 24 54	 cmp	 DWORD PTR mf_descr$21867[rsp+12], ebx
  00439	44 8b f3	 mov	 r14d, ebx
  0043c	8b c3		 mov	 eax, ebx
  0043e	41 0f 94 c6	 sete	 r14b
  00442	8b f3		 mov	 esi, ebx
  00444	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL5@array_reco:
  00450	48 0f af c5	 imul	 rax, rbp
  00454	45 8b cc	 mov	 r9d, r12d
  00457	45 8b c6	 mov	 r8d, r14d
  0045a	48 8b d5	 mov	 rdx, rbp
  0045d	49 8d 0c 07	 lea	 rcx, QWORD PTR [r15+rax]
  00461	e8 00 00 00 00	 call	 _PyLong_FromByteArray

; 1988 :             if (pylong == NULL) {

  00466	48 85 c0	 test	 rax, rax
  00469	74 1c		 je	 SHORT $LN54@array_reco

; 1991 :             }
; 1992 :             PyList_SET_ITEM(converted_items, i, pylong);

  0046b	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  0046f	ff c3		 inc	 ebx
  00471	48 83 c6 08	 add	 rsi, 8
  00475	48 89 44 0e f8	 mov	 QWORD PTR [rsi+rcx-8], rax
  0047a	48 63 c3	 movsxd	 rax, ebx
  0047d	49 3b c5	 cmp	 rax, r13
  00480	7c ce		 jl	 SHORT $LL5@array_reco

; 1988 :             if (pylong == NULL) {

  00482	e9 ee fd ff ff	 jmp	 $LN3@array_reco
$LN54@array_reco:

; 1989 :                 Py_DECREF(converted_items);

  00487	48 8b cf	 mov	 rcx, rdi
  0048a	e8 00 00 00 00	 call	 _Py_DecRef

; 1990 :                 return NULL;

  0048f	e9 bd fe ff ff	 jmp	 $LN71@array_reco
$LN1@array_reco:

; 1993 :         }
; 1994 :         break;
; 1995 :     }
; 1996 :     case UNKNOWN_FORMAT:
; 1997 :         /* Impossible, but needed to shut up GCC about the unhandled
; 1998 :          * enumeration value.
; 1999 :          */
; 2000 :     default:
; 2001 :         PyErr_BadArgument();

  00494	e8 00 00 00 00	 call	 PyErr_BadArgument

; 2002 :         return NULL;

  00499	e9 b3 fe ff ff	 jmp	 $LN71@array_reco
$LN31@array_reco:

; 1859 :         return make_array(arraytype, (char)typecode, items);

  0049e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR arraytype$[rsp]
  004a3	4d 8b c3	 mov	 r8, r11
  004a6	41 0f b6 d2	 movzx	 edx, r10b
  004aa	e8 00 00 00 00	 call	 make_array

; 2008 : }

  004af	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  004b6	c3		 ret	 0
$LN34@array_reco:

; 1845 :         PyErr_SetString(PyExc_ValueError,
; 1846 :             "third argument must be a valid machine format code.");

  004b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  004be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@LPGEONDD@third?5argument?5must?5be?5a?5valid?5m@
  004c5	e8 00 00 00 00	 call	 PyErr_SetString

; 1847 :         return NULL;

  004ca	33 c0		 xor	 eax, eax

; 2008 : }

  004cc	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  004d3	c3		 ret	 0
$LN62@array_reco:
  004d4	00 00 00 00	 DD	 $LN11@array_reco
  004d8	00 00 00 00	 DD	 $LN27@array_reco
  004dc	00 00 00 00	 DD	 $LN21@array_reco
  004e0	00 00 00 00	 DD	 $LN15@array_reco
  004e4	00 00 00 00	 DD	 $LN13@array_reco
$LN61@array_reco:
  004e8	00		 DB	 0
  004e9	00		 DB	 0
  004ea	00		 DB	 0
  004eb	00		 DB	 0
  004ec	00		 DB	 0
  004ed	00		 DB	 0
  004ee	00		 DB	 0
  004ef	00		 DB	 0
  004f0	00		 DB	 0
  004f1	00		 DB	 0
  004f2	00		 DB	 0
  004f3	00		 DB	 0
  004f4	00		 DB	 0
  004f5	00		 DB	 0
  004f6	01		 DB	 1
  004f7	01		 DB	 1
  004f8	02		 DB	 2
  004f9	02		 DB	 2
  004fa	03		 DB	 3
  004fb	03		 DB	 3
  004fc	04		 DB	 4
  004fd	04		 DB	 4
array_reconstructor ENDP
_TEXT	ENDS
END
